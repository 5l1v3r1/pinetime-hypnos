
zephyr.elf:     file format elf32-littlearm


Disassembly of section text:

00000000 <_vector_table>:

	return fd_entry->obj;
}

int z_reserve_fd(void)
{
   0:	20009298 	.word	0x20009298
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&mutex, *(uintptr_t *)&timeout, K_SYSCALL_K_MUTEX_LOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_lock(mutex, timeout);
   4:	00001401 	.word	0x00001401
   8:	00008857 	.word	0x00008857
		if (fdtable[fd].obj == NULL) {
   c:	000012d5 	.word	0x000012d5
  10:	000012d5 	.word	0x000012d5
  14:	000012d5 	.word	0x000012d5
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
  18:	000012d5 	.word	0x000012d5
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
  1c:	000012d5 	.word	0x000012d5
	errno = ENFILE;
  20:	000012d5 	.word	0x000012d5
	return -1;
  24:	000012d5 	.word	0x000012d5
		arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_mutex_unlock(mutex);
  28:	000012d5 	.word	0x000012d5
  2c:	000011cd 	.word	0x000011cd
	}

	k_mutex_unlock(&fdtable_lock);

	return fd;
}
  30:	000012d5 	.word	0x000012d5
		fdtable[fd].obj = FD_OBJ_RESERVED;
  34:	000012d5 	.word	0x000012d5
  38:	00001179 	.word	0x00001179
  3c:	00008847 	.word	0x00008847

00000040 <_irq_vector_table>:
  40:	000013c1 000013c1 000013c1 000013c1     ................
		sys_pm_notify_power_state_exit(pm_state);
		_sys_pm_power_state_exit_post_ops(pm_state);
	}

	return pm_state;
}
  50:	000013c1 000013c1 000013c1 000013c1     ................
  60:	000013c1 000013c1 000013c1 000013c1     ................
  70:	000013c1 000013c1 000013c1 000013c1     ................
  80:	000013c1 000013c1 000013c1 000013c1     ................
  90:	000013c1 000013c1 000013c1 000013c1     ................
  a0:	000013c1 000013c1 000013c1 000013c1     ................
  b0:	000013c1 000013c1 000013c1 000013c1     ................
  c0:	000013c1 000013c1 000013c1 000013c1     ................
  d0:	000013c1 000013c1 000013c1              ............

Disassembly of section _TEXT_SECTION_NAME_2:

000000dc <__aeabi_uldivmod>:
      dc:	b953      	cbnz	r3, f4 <CONFIG_LVGL_HOR_RES+0x4>
      de:	b94a      	cbnz	r2, f4 <CONFIG_LVGL_HOR_RES+0x4>
      e0:	2900      	cmp	r1, #0
      e2:	bf08      	it	eq
      e4:	2800      	cmpeq	r0, #0
      e6:	bf1c      	itt	ne
      e8:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
      ec:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
      f0:	f000 b80c 	b.w	10c <__aeabi_idiv0>
      f4:	f1ad 0c08 	sub.w	ip, sp, #8
      f8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
      fc:	f000 f808 	bl	110 <__udivmoddi4>
     100:	f8dd e004 	ldr.w	lr, [sp, #4]
     104:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     108:	b004      	add	sp, #16
     10a:	4770      	bx	lr

0000010c <__aeabi_idiv0>:
     10c:	4770      	bx	lr
     10e:	bf00      	nop

00000110 <__udivmoddi4>:
     110:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     114:	9f09      	ldr	r7, [sp, #36]	; 0x24
     116:	4615      	mov	r5, r2
     118:	4604      	mov	r4, r0
     11a:	468e      	mov	lr, r1
     11c:	461e      	mov	r6, r3
     11e:	2b00      	cmp	r3, #0
     120:	f040 80cc 	bne.w	2bc <CONFIG_FLASH_SIZE+0xbc>
     124:	428a      	cmp	r2, r1
     126:	fab2 fc82 	clz	ip, r2
     12a:	d94c      	bls.n	1c6 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x36>
     12c:	f1bc 0f00 	cmp.w	ip, #0
     130:	d00b      	beq.n	14a <CONFIG_IDLE_STACK_SIZE+0xa>
     132:	f1cc 0820 	rsb	r8, ip, #32
     136:	fa01 fe0c 	lsl.w	lr, r1, ip
     13a:	fa20 f808 	lsr.w	r8, r0, r8
     13e:	fa02 f50c 	lsl.w	r5, r2, ip
     142:	ea48 0e0e 	orr.w	lr, r8, lr
     146:	fa00 f40c 	lsl.w	r4, r0, ip
     14a:	ea4f 4915 	mov.w	r9, r5, lsr #16
     14e:	fa1f f885 	uxth.w	r8, r5
     152:	fbbe faf9 	udiv	sl, lr, r9
     156:	0c21      	lsrs	r1, r4, #16
     158:	fb09 e31a 	mls	r3, r9, sl, lr
     15c:	fb0a fb08 	mul.w	fp, sl, r8
     160:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
     164:	459b      	cmp	fp, r3
     166:	d92a      	bls.n	1be <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x2e>
     168:	18eb      	adds	r3, r5, r3
     16a:	f10a 30ff 	add.w	r0, sl, #4294967295	; 0xffffffff
     16e:	d204      	bcs.n	17a <CONFIG_IDLE_STACK_SIZE+0x3a>
     170:	459b      	cmp	fp, r3
     172:	d902      	bls.n	17a <CONFIG_IDLE_STACK_SIZE+0x3a>
     174:	f1aa 0002 	sub.w	r0, sl, #2
     178:	442b      	add	r3, r5
     17a:	eba3 030b 	sub.w	r3, r3, fp
     17e:	b2a4      	uxth	r4, r4
     180:	fbb3 f2f9 	udiv	r2, r3, r9
     184:	fb09 3312 	mls	r3, r9, r2, r3
     188:	fb02 f808 	mul.w	r8, r2, r8
     18c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     190:	45a0      	cmp	r8, r4
     192:	d916      	bls.n	1c2 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x32>
     194:	192c      	adds	r4, r5, r4
     196:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
     19a:	d203      	bcs.n	1a4 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x14>
     19c:	45a0      	cmp	r8, r4
     19e:	d901      	bls.n	1a4 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x14>
     1a0:	1e93      	subs	r3, r2, #2
     1a2:	442c      	add	r4, r5
     1a4:	eba4 0408 	sub.w	r4, r4, r8
     1a8:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
     1ac:	b127      	cbz	r7, 1b8 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x28>
     1ae:	fa24 f40c 	lsr.w	r4, r4, ip
     1b2:	2300      	movs	r3, #0
     1b4:	603c      	str	r4, [r7, #0]
     1b6:	607b      	str	r3, [r7, #4]
     1b8:	4631      	mov	r1, r6
     1ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     1be:	4650      	mov	r0, sl
     1c0:	e7db      	b.n	17a <CONFIG_IDLE_STACK_SIZE+0x3a>
     1c2:	4613      	mov	r3, r2
     1c4:	e7ee      	b.n	1a4 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x14>
     1c6:	b902      	cbnz	r2, 1ca <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x3a>
     1c8:	deff      	udf	#255	; 0xff
     1ca:	f1bc 0f00 	cmp.w	ip, #0
     1ce:	d12e      	bne.n	22e <CONFIG_FLASH_SIZE+0x2e>
     1d0:	1a8b      	subs	r3, r1, r2
     1d2:	2601      	movs	r6, #1
     1d4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
     1d8:	b2aa      	uxth	r2, r5
     1da:	fbb3 f8fe 	udiv	r8, r3, lr
     1de:	0c21      	lsrs	r1, r4, #16
     1e0:	fb0e 3318 	mls	r3, lr, r8, r3
     1e4:	fb08 f902 	mul.w	r9, r8, r2
     1e8:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
     1ec:	4599      	cmp	r9, r3
     1ee:	d961      	bls.n	2b4 <CONFIG_FLASH_SIZE+0xb4>
     1f0:	18eb      	adds	r3, r5, r3
     1f2:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
     1f6:	d204      	bcs.n	202 <CONFIG_FLASH_SIZE+0x2>
     1f8:	4599      	cmp	r9, r3
     1fa:	d902      	bls.n	202 <CONFIG_FLASH_SIZE+0x2>
     1fc:	f1a8 0002 	sub.w	r0, r8, #2
     200:	442b      	add	r3, r5
     202:	eba3 0309 	sub.w	r3, r3, r9
     206:	b2a4      	uxth	r4, r4
     208:	fbb3 f1fe 	udiv	r1, r3, lr
     20c:	fb0e 3311 	mls	r3, lr, r1, r3
     210:	434a      	muls	r2, r1
     212:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     216:	42a2      	cmp	r2, r4
     218:	d94e      	bls.n	2b8 <CONFIG_FLASH_SIZE+0xb8>
     21a:	192c      	adds	r4, r5, r4
     21c:	f101 33ff 	add.w	r3, r1, #4294967295	; 0xffffffff
     220:	d203      	bcs.n	22a <CONFIG_FLASH_SIZE+0x2a>
     222:	42a2      	cmp	r2, r4
     224:	d901      	bls.n	22a <CONFIG_FLASH_SIZE+0x2a>
     226:	1e8b      	subs	r3, r1, #2
     228:	442c      	add	r4, r5
     22a:	1aa4      	subs	r4, r4, r2
     22c:	e7bc      	b.n	1a8 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x18>
     22e:	f1cc 0e20 	rsb	lr, ip, #32
     232:	fa02 f50c 	lsl.w	r5, r2, ip
     236:	fa21 f90e 	lsr.w	r9, r1, lr
     23a:	fa01 f30c 	lsl.w	r3, r1, ip
     23e:	fa20 fe0e 	lsr.w	lr, r0, lr
     242:	ea4e 0303 	orr.w	r3, lr, r3
     246:	ea4f 4815 	mov.w	r8, r5, lsr #16
     24a:	fa00 f40c 	lsl.w	r4, r0, ip
     24e:	fbb9 f1f8 	udiv	r1, r9, r8
     252:	fa1f fe85 	uxth.w	lr, r5
     256:	fb08 9211 	mls	r2, r8, r1, r9
     25a:	0c18      	lsrs	r0, r3, #16
     25c:	fb01 f60e 	mul.w	r6, r1, lr
     260:	ea40 4202 	orr.w	r2, r0, r2, lsl #16
     264:	4296      	cmp	r6, r2
     266:	d921      	bls.n	2ac <CONFIG_FLASH_SIZE+0xac>
     268:	18aa      	adds	r2, r5, r2
     26a:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
     26e:	d203      	bcs.n	278 <CONFIG_FLASH_SIZE+0x78>
     270:	4296      	cmp	r6, r2
     272:	d901      	bls.n	278 <CONFIG_FLASH_SIZE+0x78>
     274:	1e88      	subs	r0, r1, #2
     276:	442a      	add	r2, r5
     278:	1b92      	subs	r2, r2, r6
     27a:	b29b      	uxth	r3, r3
     27c:	fbb2 f9f8 	udiv	r9, r2, r8
     280:	fb08 2219 	mls	r2, r8, r9, r2
     284:	fb09 fe0e 	mul.w	lr, r9, lr
     288:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
     28c:	459e      	cmp	lr, r3
     28e:	d90f      	bls.n	2b0 <CONFIG_FLASH_SIZE+0xb0>
     290:	18eb      	adds	r3, r5, r3
     292:	f109 36ff 	add.w	r6, r9, #4294967295	; 0xffffffff
     296:	d204      	bcs.n	2a2 <CONFIG_FLASH_SIZE+0xa2>
     298:	459e      	cmp	lr, r3
     29a:	d902      	bls.n	2a2 <CONFIG_FLASH_SIZE+0xa2>
     29c:	f1a9 0602 	sub.w	r6, r9, #2
     2a0:	442b      	add	r3, r5
     2a2:	eba3 030e 	sub.w	r3, r3, lr
     2a6:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     2aa:	e793      	b.n	1d4 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x44>
     2ac:	4608      	mov	r0, r1
     2ae:	e7e3      	b.n	278 <CONFIG_FLASH_SIZE+0x78>
     2b0:	464e      	mov	r6, r9
     2b2:	e7f6      	b.n	2a2 <CONFIG_FLASH_SIZE+0xa2>
     2b4:	4640      	mov	r0, r8
     2b6:	e7a4      	b.n	202 <CONFIG_FLASH_SIZE+0x2>
     2b8:	460b      	mov	r3, r1
     2ba:	e7b6      	b.n	22a <CONFIG_FLASH_SIZE+0x2a>
     2bc:	428b      	cmp	r3, r1
     2be:	d905      	bls.n	2cc <CONFIG_FLASH_SIZE+0xcc>
     2c0:	b10f      	cbz	r7, 2c6 <CONFIG_FLASH_SIZE+0xc6>
     2c2:	e9c7 0100 	strd	r0, r1, [r7]
     2c6:	2600      	movs	r6, #0
     2c8:	4630      	mov	r0, r6
     2ca:	e775      	b.n	1b8 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x28>
     2cc:	fab3 fc83 	clz	ip, r3
     2d0:	f1bc 0f00 	cmp.w	ip, #0
     2d4:	d10f      	bne.n	2f6 <CONFIG_FLASH_SIZE+0xf6>
     2d6:	428b      	cmp	r3, r1
     2d8:	d301      	bcc.n	2de <CONFIG_FLASH_SIZE+0xde>
     2da:	4282      	cmp	r2, r0
     2dc:	d809      	bhi.n	2f2 <CONFIG_FLASH_SIZE+0xf2>
     2de:	1a84      	subs	r4, r0, r2
     2e0:	eb61 0e03 	sbc.w	lr, r1, r3
     2e4:	2001      	movs	r0, #1
     2e6:	2f00      	cmp	r7, #0
     2e8:	d06a      	beq.n	3c0 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xc0>
     2ea:	e9c7 4e00 	strd	r4, lr, [r7]
     2ee:	2600      	movs	r6, #0
     2f0:	e762      	b.n	1b8 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x28>
     2f2:	4660      	mov	r0, ip
     2f4:	e7f7      	b.n	2e6 <CONFIG_FLASH_SIZE+0xe6>
     2f6:	f1cc 0e20 	rsb	lr, ip, #32
     2fa:	fa03 f30c 	lsl.w	r3, r3, ip
     2fe:	fa22 f50e 	lsr.w	r5, r2, lr
     302:	fa21 f40e 	lsr.w	r4, r1, lr
     306:	431d      	orrs	r5, r3
     308:	fa01 f30c 	lsl.w	r3, r1, ip
     30c:	fa20 f10e 	lsr.w	r1, r0, lr
     310:	430b      	orrs	r3, r1
     312:	ea4f 4a15 	mov.w	sl, r5, lsr #16
     316:	fa00 f60c 	lsl.w	r6, r0, ip
     31a:	fbb4 f9fa 	udiv	r9, r4, sl
     31e:	fa1f f885 	uxth.w	r8, r5
     322:	fb0a 4019 	mls	r0, sl, r9, r4
     326:	0c1c      	lsrs	r4, r3, #16
     328:	fb09 f108 	mul.w	r1, r9, r8
     32c:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
     330:	42a1      	cmp	r1, r4
     332:	fa02 f20c 	lsl.w	r2, r2, ip
     336:	d93f      	bls.n	3b8 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xb8>
     338:	192c      	adds	r4, r5, r4
     33a:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
     33e:	d204      	bcs.n	34a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x4a>
     340:	42a1      	cmp	r1, r4
     342:	d902      	bls.n	34a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x4a>
     344:	f1a9 0002 	sub.w	r0, r9, #2
     348:	442c      	add	r4, r5
     34a:	1a64      	subs	r4, r4, r1
     34c:	b29b      	uxth	r3, r3
     34e:	fbb4 f9fa 	udiv	r9, r4, sl
     352:	fb0a 4419 	mls	r4, sl, r9, r4
     356:	fb09 f808 	mul.w	r8, r9, r8
     35a:	ea43 4104 	orr.w	r1, r3, r4, lsl #16
     35e:	4588      	cmp	r8, r1
     360:	d92c      	bls.n	3bc <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xbc>
     362:	1869      	adds	r1, r5, r1
     364:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
     368:	d204      	bcs.n	374 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x74>
     36a:	4588      	cmp	r8, r1
     36c:	d902      	bls.n	374 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x74>
     36e:	f1a9 0302 	sub.w	r3, r9, #2
     372:	4429      	add	r1, r5
     374:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
     378:	eba1 0108 	sub.w	r1, r1, r8
     37c:	fba0 8902 	umull	r8, r9, r0, r2
     380:	4549      	cmp	r1, r9
     382:	46c2      	mov	sl, r8
     384:	464c      	mov	r4, r9
     386:	d302      	bcc.n	38e <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x8e>
     388:	d106      	bne.n	398 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x98>
     38a:	4546      	cmp	r6, r8
     38c:	d204      	bcs.n	398 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x98>
     38e:	ebb8 0a02 	subs.w	sl, r8, r2
     392:	eb69 0405 	sbc.w	r4, r9, r5
     396:	3801      	subs	r0, #1
     398:	b197      	cbz	r7, 3c0 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xc0>
     39a:	ebb6 030a 	subs.w	r3, r6, sl
     39e:	eb61 0604 	sbc.w	r6, r1, r4
     3a2:	fa06 fe0e 	lsl.w	lr, r6, lr
     3a6:	fa23 f30c 	lsr.w	r3, r3, ip
     3aa:	ea4e 0303 	orr.w	r3, lr, r3
     3ae:	fa26 f60c 	lsr.w	r6, r6, ip
     3b2:	e9c7 3600 	strd	r3, r6, [r7]
     3b6:	e79a      	b.n	2ee <CONFIG_FLASH_SIZE+0xee>
     3b8:	4648      	mov	r0, r9
     3ba:	e7c6      	b.n	34a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x4a>
     3bc:	464b      	mov	r3, r9
     3be:	e7d9      	b.n	374 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x74>
     3c0:	463e      	mov	r6, r7
     3c2:	e6f9      	b.n	1b8 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x28>

000003c4 <test_counter_interrupt_fn>:
	//u64_t now_usec = counter_ticks_to_us(counter_dev, now_ticks);
//	int now_sec = (int)(now_usec / USEC_PER_SEC);
//	struct counter_alarm_cfg *config = user_data;


	seconden++;
     3c4:	4a0c      	ldr	r2, [pc, #48]	; (3f8 <CONFIG_LOG_PROCESS_THREAD_SLEEP_MS+0x10>)
     3c6:	6813      	ldr	r3, [r2, #0]
     3c8:	3301      	adds	r3, #1
	if (seconden > 59) {
     3ca:	2b3b      	cmp	r3, #59	; 0x3b
     3cc:	dc01      	bgt.n	3d2 <test_counter_interrupt_fn+0xe>
	seconden++;
     3ce:	6013      	str	r3, [r2, #0]
     3d0:	4770      	bx	lr
		seconden=0;
		minuten++;
     3d2:	490a      	ldr	r1, [pc, #40]	; (3fc <CONFIG_LOG_PROCESS_THREAD_SLEEP_MS+0x14>)
		seconden=0;
     3d4:	2300      	movs	r3, #0
     3d6:	6013      	str	r3, [r2, #0]
		minuten++;
     3d8:	680a      	ldr	r2, [r1, #0]
     3da:	3201      	adds	r2, #1
		if (minuten > 59){
     3dc:	2a3b      	cmp	r2, #59	; 0x3b
     3de:	dc01      	bgt.n	3e4 <test_counter_interrupt_fn+0x20>
		minuten++;
     3e0:	600a      	str	r2, [r1, #0]
     3e2:	4770      	bx	lr
			minuten=0;
     3e4:	600b      	str	r3, [r1, #0]
			uren++;
     3e6:	4906      	ldr	r1, [pc, #24]	; (400 <CONFIG_LOG_BUFFER_SIZE>)
     3e8:	680a      	ldr	r2, [r1, #0]
     3ea:	3201      	adds	r2, #1
			if (uren > 23)
     3ec:	2a17      	cmp	r2, #23
			uren++;
     3ee:	bfd8      	it	le
     3f0:	4613      	movle	r3, r2
     3f2:	600b      	str	r3, [r1, #0]

	//	err = counter_set_channel_alarm(counter_dev, ALARM_CHANNEL_ID,
	//			user_data);


}
     3f4:	4770      	bx	lr
     3f6:	bf00      	nop
     3f8:	2000001c 	.word	0x2000001c
     3fc:	20000018 	.word	0x20000018
     400:	20000020 	.word	0x20000020

00000404 <main>:
}



void main(void)
{
     404:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     408:	b087      	sub	sp, #28
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
     40a:	4858      	ldr	r0, [pc, #352]	; (56c <main+0x168>)
     40c:	f006 fd96 	bl	6f3c <z_impl_device_get_binding>
     410:	4605      	mov	r5, r0
static inline int z_impl_counter_start(struct device *dev)
{
	const struct counter_driver_api *api =
				(struct counter_driver_api *)dev->driver_api;

	return api->start(dev);
     412:	6843      	ldr	r3, [r0, #4]
	int err;
	struct device *counter_dev;
	counter_dev = device_get_binding(DT_RTC_0_NAME);
	counter_start(counter_dev);

	alarm_cfg.flags = 0;
     414:	4c56      	ldr	r4, [pc, #344]	; (570 <main+0x16c>)
     416:	681b      	ldr	r3, [r3, #0]
     418:	4798      	blx	r3
	const struct counter_config_info *config =
     41a:	682b      	ldr	r3, [r5, #0]
	u64_t ticks = (us * config->freq) / USEC_PER_SEC;
     41c:	4955      	ldr	r1, [pc, #340]	; (574 <main+0x170>)
     41e:	689b      	ldr	r3, [r3, #8]
     420:	4a54      	ldr	r2, [pc, #336]	; (574 <main+0x170>)
     422:	6858      	ldr	r0, [r3, #4]
     424:	2600      	movs	r6, #0
     426:	2300      	movs	r3, #0
     428:	60e6      	str	r6, [r4, #12]
     42a:	fba0 0101 	umull	r0, r1, r0, r1
     42e:	f7ff fe55 	bl	dc <__aeabi_uldivmod>
	alarm_cfg.ticks = counter_us_to_ticks(counter_dev, DELAY);
	alarm_cfg.callback = test_counter_interrupt_fn;
     432:	4b51      	ldr	r3, [pc, #324]	; (578 <main+0x174>)
	alarm_cfg.user_data = &alarm_cfg;
     434:	60a4      	str	r4, [r4, #8]
	alarm_cfg.callback = test_counter_interrupt_fn;
     436:	6023      	str	r3, [r4, #0]
	const struct counter_config_info *config =
     438:	e9d5 2300 	ldrd	r2, r3, [r5]
	return config->channels;
     43c:	6892      	ldr	r2, [r2, #8]
	return (ticks > (u64_t)UINT32_MAX) ? UINT32_MAX : ticks;
     43e:	6060      	str	r0, [r4, #4]
				      const struct counter_alarm_cfg *alarm_cfg)
{
	const struct counter_driver_api *api =
				(struct counter_driver_api *)dev->driver_api;

	if (chan_id >= counter_get_num_of_channels(dev)) {
     440:	7a52      	ldrb	r2, [r2, #9]
     442:	b122      	cbz	r2, 44e <main+0x4a>
		return -ENOTSUP;
	}

	return api->set_alarm(dev, chan_id, alarm_cfg);
     444:	68db      	ldr	r3, [r3, #12]
     446:	4622      	mov	r2, r4
     448:	4631      	mov	r1, r6
     44a:	4628      	mov	r0, r5
     44c:	4798      	blx	r3




	//lv_obj_t *scr = lv_scr_act();
	lv_obj_t * img_bin = lv_img_create(lv_scr_act(), NULL);
     44e:	f007 fd93 	bl	7f78 <lv_scr_act>
     452:	2100      	movs	r1, #0
     454:	f006 fa48 	bl	68e8 <lv_img_create>

	//int year;
	//int buff[10];
	char snum[3];
	u32_t count = 0U;
	char count_str[11] = {0};
     458:	2400      	movs	r4, #0
	lv_img_set_src(img_bin, &klokje);
     45a:	4948      	ldr	r1, [pc, #288]	; (57c <main+0x178>)
     45c:	f006 f98e 	bl	677c <lv_img_set_src>
	char count_str[11] = {0};
     460:	e9cd 4403 	strd	r4, r4, [sp, #12]
     464:	f8cd 4013 	str.w	r4, [sp, #19]
     468:	4845      	ldr	r0, [pc, #276]	; (580 <main+0x17c>)
     46a:	f006 fd67 	bl	6f3c <z_impl_device_get_binding>

//	lv_style_copy(&style1, &lv_style_plain);        /*Copy a built-in style*/
//	style1.body.main_color = LV_COLOR_RED;          /*Main color*/


	if (display_dev == NULL) {
     46e:	4605      	mov	r5, r0
     470:	b980      	cbnz	r0, 494 <main+0x90>
		LOG_ERR("device not found.  Aborting test.");
     472:	2301      	movs	r3, #1
     474:	f04f 0100 	mov.w	r1, #0
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
     478:	4a42      	ldr	r2, [pc, #264]	; (584 <main+0x180>)
     47a:	4843      	ldr	r0, [pc, #268]	; (588 <main+0x184>)
     47c:	f363 0107 	bfi	r1, r3, #0, #8
     480:	4b42      	ldr	r3, [pc, #264]	; (58c <main+0x188>)
     482:	1a9b      	subs	r3, r3, r2
     484:	08db      	lsrs	r3, r3, #3
     486:	f363 118f 	bfi	r1, r3, #6, #10
     48a:	f007 ff84 	bl	8396 <log_0>
		}
		lv_task_handler();
		k_sleep(K_MSEC(10));
		++count;
	}
}
     48e:	b007      	add	sp, #28
     490:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     494:	483e      	ldr	r0, [pc, #248]	; (590 <main+0x18c>)
     496:	f006 fd51 	bl	6f3c <z_impl_device_get_binding>
     49a:	4606      	mov	r6, r0
				    u32_t pin, int flags)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	return api->config(port, access_op, pin, flags);
     49c:	6843      	ldr	r3, [r0, #4]
     49e:	2216      	movs	r2, #22
     4a0:	681f      	ldr	r7, [r3, #0]
     4a2:	4621      	mov	r1, r4
     4a4:	2301      	movs	r3, #1
     4a6:	47b8      	blx	r7
				   u32_t pin, u32_t value)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	return api->write(port, access_op, pin, value);
     4a8:	6873      	ldr	r3, [r6, #4]
		sprintf(snum, "%2d:%2d:%2d", uren, minuten,seconden); //seconden gets updated by interrupt
     4aa:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 5a4 <main+0x1a0>
     4ae:	685f      	ldr	r7, [r3, #4]
     4b0:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 5a8 <main+0x1a4>
     4b4:	4623      	mov	r3, r4
     4b6:	2216      	movs	r2, #22
     4b8:	4621      	mov	r1, r4
     4ba:	4630      	mov	r0, r6
     4bc:	47b8      	blx	r7
	hello_world_label = lv_label_create(lv_scr_act(), NULL);
     4be:	f007 fd5b 	bl	7f78 <lv_scr_act>
     4c2:	4621      	mov	r1, r4
     4c4:	f005 ffec 	bl	64a0 <lv_label_create>
	lv_label_set_long_mode(hello_world_label, LV_LABEL_LONG_BREAK);     //Break the long lines
     4c8:	2101      	movs	r1, #1
	hello_world_label = lv_label_create(lv_scr_act(), NULL);
     4ca:	4606      	mov	r6, r0
	lv_label_set_long_mode(hello_world_label, LV_LABEL_LONG_BREAK);     //Break the long lines
     4cc:	f00b fb28 	bl	bb20 <lv_label_set_long_mode>
	lv_label_set_recolor(hello_world_label, true);                      //Enable re-coloring by commands in the text
     4d0:	4630      	mov	r0, r6
     4d2:	2101      	movs	r1, #1
     4d4:	f00b fb4b 	bl	bb6e <lv_label_set_recolor>
	lv_obj_set_width(hello_world_label, 240);
     4d8:	4630      	mov	r0, r6
     4da:	21f0      	movs	r1, #240	; 0xf0
     4dc:	f009 fa15 	bl	990a <lv_obj_set_width>
	lv_label_set_text(hello_world_label, "#0000ff Hello world! Still Space Here"); //recoloring should be blue ...
     4e0:	492c      	ldr	r1, [pc, #176]	; (594 <main+0x190>)
     4e2:	4630      	mov	r0, r6
     4e4:	f00b fac7 	bl	ba76 <lv_label_set_text>
	count_label = lv_label_create(lv_scr_act(), NULL);
     4e8:	f007 fd46 	bl	7f78 <lv_scr_act>
     4ec:	4621      	mov	r1, r4
     4ee:	f005 ffd7 	bl	64a0 <lv_label_create>
     4f2:	4606      	mov	r6, r0
	clock_label = lv_label_create(lv_scr_act(), NULL);
     4f4:	f007 fd40 	bl	7f78 <lv_scr_act>
     4f8:	4621      	mov	r1, r4
     4fa:	f005 ffd1 	bl	64a0 <lv_label_create>
	lv_obj_align(count_label, NULL, LV_ALIGN_IN_BOTTOM_MID, 0, 0);
     4fe:	4623      	mov	r3, r4
	clock_label = lv_label_create(lv_scr_act(), NULL);
     500:	4607      	mov	r7, r0
	lv_obj_align(count_label, NULL, LV_ALIGN_IN_BOTTOM_MID, 0, 0);
     502:	2205      	movs	r2, #5
     504:	4621      	mov	r1, r4
     506:	4630      	mov	r0, r6
     508:	9400      	str	r4, [sp, #0]
     50a:	f009 fa52 	bl	99b2 <lv_obj_align>
	lv_obj_align(clock_label, NULL, LV_ALIGN_CENTER, 0, 0);
     50e:	4623      	mov	r3, r4
     510:	4622      	mov	r2, r4
     512:	4621      	mov	r1, r4
     514:	4638      	mov	r0, r7
     516:	9400      	str	r4, [sp, #0]
     518:	f009 fa4b 	bl	99b2 <lv_obj_align>
static inline int display_blanking_off(const struct device *dev)
{
	struct display_driver_api *api =
		(struct display_driver_api *)dev->driver_api;

	return api->blanking_off(dev);
     51c:	686b      	ldr	r3, [r5, #4]
     51e:	4628      	mov	r0, r5
     520:	685b      	ldr	r3, [r3, #4]
		sprintf(snum, "%2d:%2d:%2d", uren, minuten,seconden); //seconden gets updated by interrupt
     522:	4d1d      	ldr	r5, [pc, #116]	; (598 <main+0x194>)
     524:	4798      	blx	r3
     526:	f8d9 3000 	ldr.w	r3, [r9]
     52a:	9300      	str	r3, [sp, #0]
     52c:	682b      	ldr	r3, [r5, #0]
     52e:	f8d8 2000 	ldr.w	r2, [r8]
     532:	491a      	ldr	r1, [pc, #104]	; (59c <main+0x198>)
     534:	a802      	add	r0, sp, #8
     536:	f001 ffd9 	bl	24ec <sprintf>
		lv_label_set_text(clock_label, snum); 
     53a:	a902      	add	r1, sp, #8
     53c:	4638      	mov	r0, r7
     53e:	f00b fa9a 	bl	ba76 <lv_label_set_text>
		if ((count % 100) == 0U) {
     542:	2364      	movs	r3, #100	; 0x64
     544:	fbb4 f2f3 	udiv	r2, r4, r3
     548:	fb03 4312 	mls	r3, r3, r2, r4
     54c:	b93b      	cbnz	r3, 55e <main+0x15a>
			sprintf(count_str, "%d", count/100U);
     54e:	4914      	ldr	r1, [pc, #80]	; (5a0 <main+0x19c>)
     550:	a803      	add	r0, sp, #12
     552:	f001 ffcb 	bl	24ec <sprintf>
			lv_label_set_text(count_label, count_str);
     556:	a903      	add	r1, sp, #12
     558:	4630      	mov	r0, r6
     55a:	f00b fa8c 	bl	ba76 <lv_label_set_text>
		lv_task_handler();
     55e:	f005 fa89 	bl	5a74 <lv_task_handler>
	return z_impl_k_sleep(ms);
     562:	200a      	movs	r0, #10
     564:	f007 fa68 	bl	7a38 <z_impl_k_sleep>
		++count;
     568:	3401      	adds	r4, #1
		sprintf(snum, "%2d:%2d:%2d", uren, minuten,seconden); //seconden gets updated by interrupt
     56a:	e7dc      	b.n	526 <main+0x122>
     56c:	00044ce2 	.word	0x00044ce2
     570:	20000008 	.word	0x20000008
     574:	000f4240 	.word	0x000f4240
     578:	000003c5 	.word	0x000003c5
     57c:	0000c208 	.word	0x0000c208
     580:	00044ce8 	.word	0x00044ce8
     584:	0000c174 	.word	0x0000c174
     588:	00044cf0 	.word	0x00044cf0
     58c:	0000c174 	.word	0x0000c174
     590:	00044d12 	.word	0x00044d12
     594:	00044d19 	.word	0x00044d19
     598:	20000018 	.word	0x20000018
     59c:	00044d3f 	.word	0x00044d3f
     5a0:	0004da73 	.word	0x0004da73
     5a4:	20000020 	.word	0x20000020
     5a8:	2000001c 	.word	0x2000001c

000005ac <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
     5ac:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
     5ae:	2200      	movs	r2, #0
{
     5b0:	b087      	sub	sp, #28
		k_timer_init(&log_process_thread_timer,
     5b2:	490d      	ldr	r1, [pc, #52]	; (5e8 <enable_logger+0x3c>)
     5b4:	480d      	ldr	r0, [pc, #52]	; (5ec <enable_logger+0x40>)
     5b6:	f00b fcba 	bl	bf2e <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
     5ba:	4d0d      	ldr	r5, [pc, #52]	; (5f0 <enable_logger+0x44>)
     5bc:	490d      	ldr	r1, [pc, #52]	; (5f4 <enable_logger+0x48>)
     5be:	2400      	movs	r4, #0
     5c0:	230e      	movs	r3, #14
     5c2:	e9cd 4302 	strd	r4, r3, [sp, #8]
     5c6:	e9cd 4404 	strd	r4, r4, [sp, #16]
     5ca:	e9cd 4400 	strd	r4, r4, [sp]
     5ce:	4b0a      	ldr	r3, [pc, #40]	; (5f8 <enable_logger+0x4c>)
     5d0:	f44f 7240 	mov.w	r2, #768	; 0x300
     5d4:	4628      	mov	r0, r5
     5d6:	f007 fae3 	bl	7ba0 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
     5da:	4908      	ldr	r1, [pc, #32]	; (5fc <enable_logger+0x50>)
     5dc:	4628      	mov	r0, r5
     5de:	f00b fc40 	bl	be62 <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
     5e2:	4620      	mov	r0, r4
     5e4:	b007      	add	sp, #28
     5e6:	bd30      	pop	{r4, r5, pc}
     5e8:	00000601 	.word	0x00000601
     5ec:	20000038 	.word	0x20000038
     5f0:	20000080 	.word	0x20000080
     5f4:	20008b98 	.word	0x20008b98
     5f8:	000009d5 	.word	0x000009d5
     5fc:	00044d4f 	.word	0x00044d4f

00000600 <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
     600:	4801      	ldr	r0, [pc, #4]	; (608 <log_process_thread_timer_expiry_fn+0x8>)
     602:	f007 ba47 	b.w	7a94 <z_impl_k_sem_give>
     606:	bf00      	nop
     608:	2000a258 	.word	0x2000a258

0000060c <log_core_init>:
{
     60c:	b508      	push	{r3, lr}
		log_msg_pool_init();
     60e:	f000 fa41 	bl	a94 <log_msg_pool_init>
		log_list_init(&list);
     612:	4809      	ldr	r0, [pc, #36]	; (638 <log_core_init+0x2c>)
     614:	f007 fe7c 	bl	8310 <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
     618:	2304      	movs	r3, #4
     61a:	2228      	movs	r2, #40	; 0x28
     61c:	4807      	ldr	r0, [pc, #28]	; (63c <log_core_init+0x30>)
     61e:	4908      	ldr	r1, [pc, #32]	; (640 <log_core_init+0x34>)
     620:	f00b fb07 	bl	bc32 <k_mem_slab_init>
		timestamp_func = k_cycle_get_32_wrapper;
     624:	4b07      	ldr	r3, [pc, #28]	; (644 <log_core_init+0x38>)
     626:	4a08      	ldr	r2, [pc, #32]	; (648 <log_core_init+0x3c>)
     628:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
     62a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
}
     62e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	log_output_timestamp_freq_set(freq);
     632:	f000 baa5 	b.w	b80 <log_output_timestamp_freq_set>
     636:	bf00      	nop
     638:	20000030 	.word	0x20000030
     63c:	20000064 	.word	0x20000064
     640:	20009bd8 	.word	0x20009bd8
     644:	2000a078 	.word	0x2000a078
     648:	0000834f 	.word	0x0000834f

0000064c <dropped_notify>:
{
     64c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
     64e:	4b0f      	ldr	r3, [pc, #60]	; (68c <dropped_notify+0x40>)
     650:	f3bf 8f5b 	dmb	ish
     654:	2500      	movs	r5, #0
     656:	e853 7f00 	ldrex	r7, [r3]
     65a:	e843 5200 	strex	r2, r5, [r3]
     65e:	2a00      	cmp	r2, #0
     660:	d1f9      	bne.n	656 <dropped_notify+0xa>
     662:	f3bf 8f5b 	dmb	ish
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
     666:	4c0a      	ldr	r4, [pc, #40]	; (690 <dropped_notify+0x44>)
     668:	4e0a      	ldr	r6, [pc, #40]	; (694 <dropped_notify+0x48>)
     66a:	1b36      	subs	r6, r6, r4
     66c:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
     66e:	42b5      	cmp	r5, r6
     670:	db00      	blt.n	674 <dropped_notify+0x28>
}
     672:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
     674:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
     676:	795b      	ldrb	r3, [r3, #5]
     678:	b12b      	cbz	r3, 686 <dropped_notify+0x3a>
	if (backend->api->dropped != NULL) {
     67a:	6823      	ldr	r3, [r4, #0]
     67c:	68db      	ldr	r3, [r3, #12]
     67e:	b113      	cbz	r3, 686 <dropped_notify+0x3a>
		backend->api->dropped(backend, cnt);
     680:	4639      	mov	r1, r7
     682:	4620      	mov	r0, r4
     684:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
     686:	3501      	adds	r5, #1
     688:	3410      	adds	r4, #16
     68a:	e7f0      	b.n	66e <dropped_notify+0x22>
     68c:	20000028 	.word	0x20000028
     690:	0000c1dc 	.word	0x0000c1dc
     694:	0000c1dc 	.word	0x0000c1dc

00000698 <log_dropped>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
     698:	4b06      	ldr	r3, [pc, #24]	; (6b4 <log_dropped+0x1c>)
     69a:	f3bf 8f5b 	dmb	ish
     69e:	e853 2f00 	ldrex	r2, [r3]
     6a2:	3201      	adds	r2, #1
     6a4:	e843 2100 	strex	r1, r2, [r3]
     6a8:	2900      	cmp	r1, #0
     6aa:	d1f8      	bne.n	69e <log_dropped+0x6>
     6ac:	f3bf 8f5b 	dmb	ish
}
     6b0:	4770      	bx	lr
     6b2:	bf00      	nop
     6b4:	20000028 	.word	0x20000028

000006b8 <log_backend_enable>:
	id += backend - log_backend_get(0);
     6b8:	4b09      	ldr	r3, [pc, #36]	; (6e0 <log_backend_enable+0x28>)
	log_backend_id_set(backend, id);
     6ba:	6842      	ldr	r2, [r0, #4]
	id += backend - log_backend_get(0);
     6bc:	1ac3      	subs	r3, r0, r3
     6be:	111b      	asrs	r3, r3, #4
     6c0:	3301      	adds	r3, #1
{
     6c2:	b510      	push	{r4, lr}
	log_backend_id_set(backend, id);
     6c4:	7113      	strb	r3, [r2, #4]
	log_backend_activate(backend, ctx);
     6c6:	6843      	ldr	r3, [r0, #4]
	if (!backend_attached) {
     6c8:	4c06      	ldr	r4, [pc, #24]	; (6e4 <log_backend_enable+0x2c>)
	backend->cb->ctx = ctx;
     6ca:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
     6cc:	2201      	movs	r2, #1
     6ce:	715a      	strb	r2, [r3, #5]
     6d0:	7822      	ldrb	r2, [r4, #0]
     6d2:	b912      	cbnz	r2, 6da <log_backend_enable+0x22>
     6d4:	4804      	ldr	r0, [pc, #16]	; (6e8 <log_backend_enable+0x30>)
     6d6:	f007 f9dd 	bl	7a94 <z_impl_k_sem_give>
	backend_attached = true;
     6da:	2301      	movs	r3, #1
     6dc:	7023      	strb	r3, [r4, #0]
}
     6de:	bd10      	pop	{r4, pc}
     6e0:	0000c1dc 	.word	0x0000c1dc
     6e4:	20004806 	.word	0x20004806
     6e8:	2000a258 	.word	0x2000a258

000006ec <log_init>:
{
     6ec:	b570      	push	{r4, r5, r6, lr}
     6ee:	4b11      	ldr	r3, [pc, #68]	; (734 <log_init+0x48>)
     6f0:	f3bf 8f5b 	dmb	ish
     6f4:	e853 5f00 	ldrex	r5, [r3]
     6f8:	1c6a      	adds	r2, r5, #1
     6fa:	e843 2100 	strex	r1, r2, [r3]
     6fe:	2900      	cmp	r1, #0
     700:	d1f8      	bne.n	6f4 <log_init+0x8>
     702:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&initialized) != 0) {
     706:	b92d      	cbnz	r5, 714 <log_init+0x28>
	return __log_backends_end - __log_backends_start;
     708:	4c0b      	ldr	r4, [pc, #44]	; (738 <log_init+0x4c>)
     70a:	4e0c      	ldr	r6, [pc, #48]	; (73c <log_init+0x50>)
     70c:	1b36      	subs	r6, r6, r4
     70e:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
     710:	42b5      	cmp	r5, r6
     712:	db00      	blt.n	716 <log_init+0x2a>
}
     714:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
     716:	7b23      	ldrb	r3, [r4, #12]
     718:	b143      	cbz	r3, 72c <log_init+0x40>
			if (backend->api->init != NULL) {
     71a:	6823      	ldr	r3, [r4, #0]
     71c:	695b      	ldr	r3, [r3, #20]
     71e:	b103      	cbz	r3, 722 <log_init+0x36>
				backend->api->init();
     720:	4798      	blx	r3
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
     722:	2204      	movs	r2, #4
     724:	2100      	movs	r1, #0
     726:	4620      	mov	r0, r4
     728:	f7ff ffc6 	bl	6b8 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
     72c:	3501      	adds	r5, #1
     72e:	3410      	adds	r4, #16
     730:	e7ee      	b.n	710 <log_init+0x24>
     732:	bf00      	nop
     734:	2000002c 	.word	0x2000002c
     738:	0000c1dc 	.word	0x0000c1dc
     73c:	0000c1dc 	.word	0x0000c1dc

00000740 <log_strdup>:
	return (((const char *)addr >= (const char *)RO_START) &&
     740:	4b16      	ldr	r3, [pc, #88]	; (79c <log_strdup+0x5c>)
     742:	4298      	cmp	r0, r3
{
     744:	b537      	push	{r0, r1, r2, r4, r5, lr}
     746:	4604      	mov	r4, r0
	return (((const char *)addr >= (const char *)RO_START) &&
     748:	d302      	bcc.n	750 <log_strdup+0x10>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
     74a:	4b15      	ldr	r3, [pc, #84]	; (7a0 <log_strdup+0x60>)
     74c:	4298      	cmp	r0, r3
     74e:	d31f      	bcc.n	790 <log_strdup+0x50>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
     750:	2200      	movs	r2, #0
     752:	a901      	add	r1, sp, #4
     754:	4813      	ldr	r0, [pc, #76]	; (7a4 <log_strdup+0x64>)
     756:	f006 fd91 	bl	727c <k_mem_slab_alloc>
	if (err != 0) {
     75a:	4605      	mov	r5, r0
     75c:	b9d8      	cbnz	r0, 796 <log_strdup+0x56>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
     75e:	2201      	movs	r2, #1
     760:	9b01      	ldr	r3, [sp, #4]
     762:	f3bf 8f5b 	dmb	ish
     766:	e853 1f00 	ldrex	r1, [r3]
     76a:	e843 2000 	strex	r0, r2, [r3]
     76e:	2800      	cmp	r0, #0
     770:	d1f9      	bne.n	766 <log_strdup+0x26>
     772:	f3bf 8f5b 	dmb	ish
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
     776:	9801      	ldr	r0, [sp, #4]
     778:	4621      	mov	r1, r4
     77a:	221f      	movs	r2, #31
     77c:	3004      	adds	r0, #4
     77e:	f008 f883 	bl	8888 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
     782:	9c01      	ldr	r4, [sp, #4]
     784:	237e      	movs	r3, #126	; 0x7e
     786:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
     78a:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
	return dup->buf;
     78e:	3404      	adds	r4, #4
}
     790:	4620      	mov	r0, r4
     792:	b003      	add	sp, #12
     794:	bd30      	pop	{r4, r5, pc}
		return (char *)log_strdup_fail_msg;
     796:	4c04      	ldr	r4, [pc, #16]	; (7a8 <log_strdup+0x68>)
     798:	e7fa      	b.n	790 <log_strdup+0x50>
     79a:	bf00      	nop
     79c:	0000bfa0 	.word	0x0000bfa0
     7a0:	0004dabc 	.word	0x0004dabc
     7a4:	20000064 	.word	0x20000064
     7a8:	00044d57 	.word	0x00044d57

000007ac <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (u8_t *)buf);
     7ac:	b148      	cbz	r0, 7c2 <log_is_strdup+0x16>
     7ae:	4b05      	ldr	r3, [pc, #20]	; (7c4 <log_is_strdup+0x18>)
     7b0:	4298      	cmp	r0, r3
     7b2:	d305      	bcc.n	7c0 <log_is_strdup+0x14>
     7b4:	33a0      	adds	r3, #160	; 0xa0
     7b6:	4298      	cmp	r0, r3
     7b8:	bf2c      	ite	cs
     7ba:	2000      	movcs	r0, #0
     7bc:	2001      	movcc	r0, #1
     7be:	4770      	bx	lr
     7c0:	2000      	movs	r0, #0
}
     7c2:	4770      	bx	lr
     7c4:	20009bd8 	.word	0x20009bd8

000007c8 <z_impl_log_process>:
{
     7c8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!backend_attached && !bypass) {
     7cc:	4b46      	ldr	r3, [pc, #280]	; (8e8 <CONFIG_ISR_STACK_SIZE+0xe8>)
     7ce:	781b      	ldrb	r3, [r3, #0]
{
     7d0:	4605      	mov	r5, r0
	if (!backend_attached && !bypass) {
     7d2:	b903      	cbnz	r3, 7d6 <z_impl_log_process+0xe>
     7d4:	b360      	cbz	r0, 830 <CONFIG_ISR_STACK_SIZE+0x30>
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
     7d6:	f04f 0320 	mov.w	r3, #32
     7da:	f3ef 8611 	mrs	r6, BASEPRI
     7de:	f383 8811 	msr	BASEPRI, r3
     7e2:	f3bf 8f6f 	isb	sy
	msg = log_list_head_get(&list);
     7e6:	4841      	ldr	r0, [pc, #260]	; (8ec <CONFIG_ISR_STACK_SIZE+0xec>)
     7e8:	f007 fda2 	bl	8330 <log_list_head_get>
     7ec:	4604      	mov	r4, r0
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
     7ee:	f386 8811 	msr	BASEPRI, r6
     7f2:	f3bf 8f6f 	isb	sy
	if (msg != NULL) {
     7f6:	b178      	cbz	r0, 818 <CONFIG_ISR_STACK_SIZE+0x18>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
     7f8:	f3bf 8f5b 	dmb	ish
     7fc:	4b3c      	ldr	r3, [pc, #240]	; (8f0 <CONFIG_ISR_STACK_SIZE+0xf0>)
     7fe:	e853 2f00 	ldrex	r2, [r3]
     802:	3a01      	subs	r2, #1
     804:	e843 2100 	strex	r1, r2, [r3]
     808:	2900      	cmp	r1, #0
     80a:	d1f8      	bne.n	7fe <z_impl_log_process+0x36>
     80c:	f3bf 8f5b 	dmb	ish
	if (!bypass) {
     810:	b18d      	cbz	r5, 836 <CONFIG_ISR_STACK_SIZE+0x36>
	log_msg_put(msg);
     812:	4620      	mov	r0, r4
     814:	f007 fe33 	bl	847e <log_msg_put>
	if (!bypass && dropped_cnt) {
     818:	b925      	cbnz	r5, 824 <CONFIG_ISR_STACK_SIZE+0x24>
     81a:	4b36      	ldr	r3, [pc, #216]	; (8f4 <CONFIG_ISR_STACK_SIZE+0xf4>)
     81c:	681b      	ldr	r3, [r3, #0]
     81e:	b10b      	cbz	r3, 824 <CONFIG_ISR_STACK_SIZE+0x24>
		dropped_notify();
     820:	f7ff ff14 	bl	64c <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
     824:	4831      	ldr	r0, [pc, #196]	; (8ec <CONFIG_ISR_STACK_SIZE+0xec>)
     826:	f007 fd81 	bl	832c <log_list_head_peek>
     82a:	1c05      	adds	r5, r0, #0
     82c:	bf18      	it	ne
     82e:	2501      	movne	r5, #1
}
     830:	4628      	mov	r0, r5
     832:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    !panic_mode) {
     836:	4b30      	ldr	r3, [pc, #192]	; (8f8 <CONFIG_ISR_STACK_SIZE+0xf8>)
		if (IS_ENABLED(CONFIG_LOG_DETECT_MISSED_STRDUP) &&
     838:	781b      	ldrb	r3, [r3, #0]
     83a:	b9ab      	cbnz	r3, 868 <CONFIG_ISR_STACK_SIZE+0x68>
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
     83c:	7a23      	ldrb	r3, [r4, #8]
	if (!log_msg_is_std(msg)) {
     83e:	07db      	lsls	r3, r3, #31
     840:	d412      	bmi.n	868 <CONFIG_ISR_STACK_SIZE+0x68>
	msg_str = log_msg_str_get(msg);
     842:	f007 fe2f 	bl	84a4 <log_msg_str_get>
     846:	4681      	mov	r9, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
     848:	4620      	mov	r0, r4
     84a:	f007 fdf8 	bl	843e <log_msg_nargs_get>
     84e:	4601      	mov	r1, r0
     850:	4648      	mov	r0, r9
     852:	f007 fd80 	bl	8356 <z_log_get_s_mask>
     856:	4b29      	ldr	r3, [pc, #164]	; (8fc <CONFIG_ISR_STACK_SIZE+0xfc>)
				LOG_ERR(ERR_MSG, idx, msg_str);
     858:	4a29      	ldr	r2, [pc, #164]	; (900 <CONFIG_ISR_STACK_SIZE+0x100>)
     85a:	f8df b0bc 	ldr.w	fp, [pc, #188]	; 918 <CONFIG_ISR_STACK_SIZE+0x118>
     85e:	1a9b      	subs	r3, r3, r2
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
     860:	4607      	mov	r7, r0
				LOG_ERR(ERR_MSG, idx, msg_str);
     862:	f3c3 0ac9 	ubfx	sl, r3, #3, #10
	while (mask) {
     866:	b937      	cbnz	r7, 876 <CONFIG_ISR_STACK_SIZE+0x76>
     868:	4e26      	ldr	r6, [pc, #152]	; (904 <CONFIG_ISR_STACK_SIZE+0x104>)
     86a:	4f27      	ldr	r7, [pc, #156]	; (908 <CONFIG_ISR_STACK_SIZE+0x108>)
     86c:	1bbf      	subs	r7, r7, r6
     86e:	113f      	asrs	r7, r7, #4
     870:	f04f 0800 	mov.w	r8, #0
     874:	e034      	b.n	8e0 <CONFIG_ISR_STACK_SIZE+0xe0>
		idx = 31 - __builtin_clz(mask);
     876:	fab7 f687 	clz	r6, r7
     87a:	f1c6 061f 	rsb	r6, r6, #31
		str = (const char *)log_msg_arg_get(msg, idx);
     87e:	4631      	mov	r1, r6
     880:	4620      	mov	r0, r4
     882:	f007 fddf 	bl	8444 <log_msg_arg_get>
	return (((const char *)addr >= (const char *)RO_START) &&
     886:	4b21      	ldr	r3, [pc, #132]	; (90c <CONFIG_ISR_STACK_SIZE+0x10c>)
     888:	4298      	cmp	r0, r3
		str = (const char *)log_msg_arg_get(msg, idx);
     88a:	4602      	mov	r2, r0
	return (((const char *)addr >= (const char *)RO_START) &&
     88c:	d302      	bcc.n	894 <CONFIG_ISR_STACK_SIZE+0x94>
		if (!is_rodata(str) && !log_is_strdup(str) &&
     88e:	4b20      	ldr	r3, [pc, #128]	; (910 <CONFIG_ISR_STACK_SIZE+0x110>)
     890:	4298      	cmp	r0, r3
     892:	d314      	bcc.n	8be <CONFIG_ISR_STACK_SIZE+0xbe>
     894:	4610      	mov	r0, r2
     896:	f7ff ff89 	bl	7ac <log_is_strdup>
     89a:	b980      	cbnz	r0, 8be <CONFIG_ISR_STACK_SIZE+0xbe>
     89c:	4b1d      	ldr	r3, [pc, #116]	; (914 <CONFIG_ISR_STACK_SIZE+0x114>)
     89e:	429a      	cmp	r2, r3
     8a0:	d00d      	beq.n	8be <CONFIG_ISR_STACK_SIZE+0xbe>
				LOG_ERR(ERR_MSG, idx, msg_str);
     8a2:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
     8a6:	f043 0301 	orr.w	r3, r3, #1
     8aa:	f363 0807 	bfi	r8, r3, #0, #8
     8ae:	f36a 188f 	bfi	r8, sl, #6, #10
     8b2:	4643      	mov	r3, r8
     8b4:	464a      	mov	r2, r9
     8b6:	4631      	mov	r1, r6
     8b8:	4658      	mov	r0, fp
     8ba:	f007 fd8d 	bl	83d8 <log_2>
		mask &= ~BIT(idx);
     8be:	2301      	movs	r3, #1
     8c0:	fa03 f606 	lsl.w	r6, r3, r6
     8c4:	ea27 0706 	bic.w	r7, r7, r6
     8c8:	e7cd      	b.n	866 <CONFIG_ISR_STACK_SIZE+0x66>
	return backend->cb->active;
     8ca:	6873      	ldr	r3, [r6, #4]
			if (log_backend_is_active(backend) &&
     8cc:	795b      	ldrb	r3, [r3, #5]
     8ce:	b123      	cbz	r3, 8da <CONFIG_ISR_STACK_SIZE+0xda>
	backend->api->put(backend, msg);
     8d0:	6833      	ldr	r3, [r6, #0]
     8d2:	4621      	mov	r1, r4
     8d4:	681b      	ldr	r3, [r3, #0]
     8d6:	4630      	mov	r0, r6
     8d8:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
     8da:	f108 0801 	add.w	r8, r8, #1
     8de:	3610      	adds	r6, #16
     8e0:	45b8      	cmp	r8, r7
     8e2:	dbf2      	blt.n	8ca <CONFIG_ISR_STACK_SIZE+0xca>
     8e4:	e795      	b.n	812 <CONFIG_ISR_STACK_SIZE+0x12>
     8e6:	bf00      	nop
     8e8:	20004806 	.word	0x20004806
     8ec:	20000030 	.word	0x20000030
     8f0:	20000024 	.word	0x20000024
     8f4:	20000028 	.word	0x20000028
     8f8:	20004807 	.word	0x20004807
     8fc:	0000c1a4 	.word	0x0000c1a4
     900:	0000c174 	.word	0x0000c174
     904:	0000c1dc 	.word	0x0000c1dc
     908:	0000c1dc 	.word	0x0000c1dc
     90c:	0000bfa0 	.word	0x0000bfa0
     910:	0004dabc 	.word	0x0004dabc
     914:	00044d57 	.word	0x00044d57
     918:	00044d75 	.word	0x00044d75

0000091c <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
     91c:	4b26      	ldr	r3, [pc, #152]	; (9b8 <msg_finalize+0x9c>)
{
     91e:	b570      	push	{r4, r5, r6, lr}
	msg->hdr.timestamp = timestamp_func();
     920:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
     922:	8141      	strh	r1, [r0, #10]
{
     924:	4605      	mov	r5, r0
	msg->hdr.timestamp = timestamp_func();
     926:	4798      	blx	r3
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
     928:	4c24      	ldr	r4, [pc, #144]	; (9bc <msg_finalize+0xa0>)
     92a:	60e8      	str	r0, [r5, #12]
     92c:	f3bf 8f5b 	dmb	ish
     930:	e854 3f00 	ldrex	r3, [r4]
     934:	3301      	adds	r3, #1
     936:	e844 3200 	strex	r2, r3, [r4]
     93a:	2a00      	cmp	r2, #0
     93c:	d1f8      	bne.n	930 <msg_finalize+0x14>
     93e:	f3bf 8f5b 	dmb	ish
	__asm__ volatile(
     942:	f04f 0320 	mov.w	r3, #32
     946:	f3ef 8611 	mrs	r6, BASEPRI
     94a:	f383 8811 	msr	BASEPRI, r3
     94e:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
     952:	481b      	ldr	r0, [pc, #108]	; (9c0 <msg_finalize+0xa4>)
     954:	4629      	mov	r1, r5
     956:	f007 fcdf 	bl	8318 <log_list_add_tail>
	__asm__ volatile(
     95a:	f386 8811 	msr	BASEPRI, r6
     95e:	f3bf 8f6f 	isb	sy
	if (panic_mode) {
     962:	4b18      	ldr	r3, [pc, #96]	; (9c4 <msg_finalize+0xa8>)
     964:	781a      	ldrb	r2, [r3, #0]
     966:	b17a      	cbz	r2, 988 <msg_finalize+0x6c>
	__asm__ volatile(
     968:	f04f 0320 	mov.w	r3, #32
     96c:	f3ef 8411 	mrs	r4, BASEPRI
     970:	f383 8811 	msr	BASEPRI, r3
     974:	f3bf 8f6f 	isb	sy
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
     978:	2000      	movs	r0, #0
     97a:	f7ff ff25 	bl	7c8 <z_impl_log_process>
	__asm__ volatile(
     97e:	f384 8811 	msr	BASEPRI, r4
     982:	f3bf 8f6f 	isb	sy
}
     986:	bd70      	pop	{r4, r5, r6, pc}
	} else if (proc_tid != NULL && buffered_cnt == 1) {
     988:	490f      	ldr	r1, [pc, #60]	; (9c8 <msg_finalize+0xac>)
     98a:	6823      	ldr	r3, [r4, #0]
     98c:	6809      	ldr	r1, [r1, #0]
     98e:	2900      	cmp	r1, #0
     990:	d0f9      	beq.n	986 <msg_finalize+0x6a>
     992:	2b01      	cmp	r3, #1
     994:	d106      	bne.n	9a4 <msg_finalize+0x88>
	z_impl_k_timer_start(timer, duration, period);
     996:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
     99a:	480c      	ldr	r0, [pc, #48]	; (9cc <msg_finalize+0xb0>)
}
     99c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
     9a0:	f007 babc 	b.w	7f1c <z_impl_k_timer_start>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
     9a4:	2b0a      	cmp	r3, #10
     9a6:	d1ee      	bne.n	986 <msg_finalize+0x6a>
	z_impl_k_timer_stop(timer);
     9a8:	4808      	ldr	r0, [pc, #32]	; (9cc <msg_finalize+0xb0>)
     9aa:	f00b facc 	bl	bf46 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
     9ae:	4808      	ldr	r0, [pc, #32]	; (9d0 <msg_finalize+0xb4>)
}
     9b0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
     9b4:	f007 b86e 	b.w	7a94 <z_impl_k_sem_give>
     9b8:	2000a078 	.word	0x2000a078
     9bc:	20000024 	.word	0x20000024
     9c0:	20000030 	.word	0x20000030
     9c4:	20004807 	.word	0x20004807
     9c8:	200000ec 	.word	0x200000ec
     9cc:	20000038 	.word	0x20000038
     9d0:	2000a258 	.word	0x2000a258

000009d4 <log_process_thread_func>:
{
     9d4:	b508      	push	{r3, lr}
	log_init();
     9d6:	f7ff fe89 	bl	6ec <log_init>
	return z_impl_k_current_get();
     9da:	f007 f855 	bl	7a88 <z_impl_k_current_get>
	proc_tid = process_tid;
     9de:	4b0b      	ldr	r3, [pc, #44]	; (a0c <log_process_thread_func+0x38>)
     9e0:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
     9e2:	b130      	cbz	r0, 9f2 <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
     9e4:	4b0a      	ldr	r3, [pc, #40]	; (a10 <log_process_thread_func+0x3c>)
	    process_tid &&
     9e6:	681b      	ldr	r3, [r3, #0]
     9e8:	2b09      	cmp	r3, #9
     9ea:	dd02      	ble.n	9f2 <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
     9ec:	4809      	ldr	r0, [pc, #36]	; (a14 <log_process_thread_func+0x40>)
     9ee:	f007 f851 	bl	7a94 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
     9f2:	4c08      	ldr	r4, [pc, #32]	; (a14 <log_process_thread_func+0x40>)
     9f4:	2000      	movs	r0, #0
     9f6:	f7ff fee7 	bl	7c8 <z_impl_log_process>
		if (log_process(false) == false) {
     9fa:	2800      	cmp	r0, #0
     9fc:	d1fa      	bne.n	9f4 <log_process_thread_func+0x20>
     9fe:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
     a02:	4620      	mov	r0, r4
     a04:	f007 f86c 	bl	7ae0 <z_impl_k_sem_take>
     a08:	e7f4      	b.n	9f4 <log_process_thread_func+0x20>
     a0a:	bf00      	nop
     a0c:	200000ec 	.word	0x200000ec
     a10:	20000024 	.word	0x20000024
     a14:	2000a258 	.word	0x2000a258

00000a18 <z_impl_log_panic>:
{
     a18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
     a1a:	4f0e      	ldr	r7, [pc, #56]	; (a54 <z_impl_log_panic+0x3c>)
     a1c:	783d      	ldrb	r5, [r7, #0]
     a1e:	b975      	cbnz	r5, a3e <z_impl_log_panic+0x26>
	return __log_backends_end - __log_backends_start;
     a20:	4c0d      	ldr	r4, [pc, #52]	; (a58 <z_impl_log_panic+0x40>)
     a22:	4e0e      	ldr	r6, [pc, #56]	; (a5c <z_impl_log_panic+0x44>)
	log_init();
     a24:	f7ff fe62 	bl	6ec <log_init>
     a28:	1b36      	subs	r6, r6, r4
     a2a:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
     a2c:	42b5      	cmp	r5, r6
     a2e:	db07      	blt.n	a40 <z_impl_log_panic+0x28>
     a30:	2000      	movs	r0, #0
     a32:	f7ff fec9 	bl	7c8 <z_impl_log_process>
		while (log_process(false) == true) {
     a36:	2800      	cmp	r0, #0
     a38:	d1fa      	bne.n	a30 <z_impl_log_panic+0x18>
	panic_mode = true;
     a3a:	2301      	movs	r3, #1
     a3c:	703b      	strb	r3, [r7, #0]
}
     a3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
     a40:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
     a42:	795b      	ldrb	r3, [r3, #5]
     a44:	b11b      	cbz	r3, a4e <z_impl_log_panic+0x36>
	backend->api->panic(backend);
     a46:	6823      	ldr	r3, [r4, #0]
     a48:	4620      	mov	r0, r4
     a4a:	691b      	ldr	r3, [r3, #16]
     a4c:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
     a4e:	3501      	adds	r5, #1
     a50:	3410      	adds	r4, #16
     a52:	e7eb      	b.n	a2c <z_impl_log_panic+0x14>
     a54:	20004807 	.word	0x20004807
     a58:	0000c1dc 	.word	0x0000c1dc
     a5c:	0000c1dc 	.word	0x0000c1dc

00000a60 <log_free>:
{
     a60:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
     a62:	3804      	subs	r0, #4
     a64:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
     a66:	f3bf 8f5b 	dmb	ish
     a6a:	e850 3f00 	ldrex	r3, [r0]
     a6e:	1e5a      	subs	r2, r3, #1
     a70:	e840 2100 	strex	r1, r2, [r0]
     a74:	2900      	cmp	r1, #0
     a76:	d1f8      	bne.n	a6a <log_free+0xa>
     a78:	f3bf 8f5b 	dmb	ish
	if (atomic_dec(&dup->refcount) == 1) {
     a7c:	2b01      	cmp	r3, #1
     a7e:	d103      	bne.n	a88 <log_free+0x28>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
     a80:	a901      	add	r1, sp, #4
     a82:	4803      	ldr	r0, [pc, #12]	; (a90 <log_free+0x30>)
     a84:	f006 fc26 	bl	72d4 <k_mem_slab_free>
}
     a88:	b003      	add	sp, #12
     a8a:	f85d fb04 	ldr.w	pc, [sp], #4
     a8e:	bf00      	nop
     a90:	20000064 	.word	0x20000064

00000a94 <log_msg_pool_init>:
static u8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
     a94:	2320      	movs	r3, #32
     a96:	461a      	mov	r2, r3
     a98:	4901      	ldr	r1, [pc, #4]	; (aa0 <log_msg_pool_init+0xc>)
     a9a:	4802      	ldr	r0, [pc, #8]	; (aa4 <log_msg_pool_init+0x10>)
     a9c:	f00b b8c9 	b.w	bc32 <k_mem_slab_init>
     aa0:	20009c78 	.word	0x20009c78
     aa4:	200000f0 	.word	0x200000f0

00000aa8 <log_msg_no_space_handle>:

	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
     aa8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	union log_msg_chunk *msg = NULL;
     aaa:	2300      	movs	r3, #0

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
     aac:	4d09      	ldr	r5, [pc, #36]	; (ad4 <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
     aae:	9301      	str	r3, [sp, #4]
     ab0:	2001      	movs	r0, #1
     ab2:	f7ff fe89 	bl	7c8 <z_impl_log_process>
     ab6:	4604      	mov	r4, r0
			log_dropped();
     ab8:	f7ff fdee 	bl	698 <log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
     abc:	2200      	movs	r2, #0
     abe:	a901      	add	r1, sp, #4
     ac0:	4628      	mov	r0, r5
     ac2:	f006 fbdb 	bl	727c <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
     ac6:	b108      	cbz	r0, acc <log_msg_no_space_handle+0x24>
     ac8:	2c00      	cmp	r4, #0
     aca:	d1f1      	bne.n	ab0 <log_msg_no_space_handle+0x8>
	} else {
		log_dropped();
	}
	return msg;

}
     acc:	9801      	ldr	r0, [sp, #4]
     ace:	b003      	add	sp, #12
     ad0:	bd30      	pop	{r4, r5, pc}
     ad2:	bf00      	nop
     ad4:	200000f0 	.word	0x200000f0

00000ad8 <log_msg_chunk_alloc>:
{
     ad8:	b507      	push	{r0, r1, r2, lr}
	union log_msg_chunk *msg = NULL;
     ada:	2200      	movs	r2, #0
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
     adc:	a901      	add	r1, sp, #4
     ade:	4806      	ldr	r0, [pc, #24]	; (af8 <log_msg_chunk_alloc+0x20>)
	union log_msg_chunk *msg = NULL;
     ae0:	9201      	str	r2, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
     ae2:	f006 fbcb 	bl	727c <k_mem_slab_alloc>
	if (err != 0) {
     ae6:	b110      	cbz	r0, aee <log_msg_chunk_alloc+0x16>
		msg = log_msg_no_space_handle();
     ae8:	f7ff ffde 	bl	aa8 <log_msg_no_space_handle>
     aec:	9001      	str	r0, [sp, #4]
}
     aee:	9801      	ldr	r0, [sp, #4]
     af0:	b003      	add	sp, #12
     af2:	f85d fb04 	ldr.w	pc, [sp], #4
     af6:	bf00      	nop
     af8:	200000f0 	.word	0x200000f0

00000afc <msg_free>:
{
     afc:	b5f0      	push	{r4, r5, r6, r7, lr}
     afe:	7a04      	ldrb	r4, [r0, #8]
	}
}

u32_t log_msg_nargs_get(struct log_msg *msg)
{
	return msg->hdr.params.std.nargs;
     b00:	7a46      	ldrb	r6, [r0, #9]
{
     b02:	b085      	sub	sp, #20
	if (log_msg_is_std(msg) && nargs) {
     b04:	f014 0401 	ands.w	r4, r4, #1
{
     b08:	9001      	str	r0, [sp, #4]
	return msg->hdr.params.std.nargs;
     b0a:	ea4f 1616 	mov.w	r6, r6, lsr #4
	if (log_msg_is_std(msg) && nargs) {
     b0e:	d00e      	beq.n	b2e <msg_free+0x32>
	if (msg->hdr.params.generic.ext == 1) {
     b10:	9b01      	ldr	r3, [sp, #4]
     b12:	7a1a      	ldrb	r2, [r3, #8]
     b14:	0792      	lsls	r2, r2, #30
     b16:	d504      	bpl.n	b22 <msg_free+0x26>
		cont_free(msg->payload.ext.next);
     b18:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
     b1a:	4c18      	ldr	r4, [pc, #96]	; (b7c <msg_free+0x80>)
     b1c:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
     b1e:	9b03      	ldr	r3, [sp, #12]
     b20:	bb2b      	cbnz	r3, b6e <msg_free+0x72>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
     b22:	a901      	add	r1, sp, #4
     b24:	4815      	ldr	r0, [pc, #84]	; (b7c <msg_free+0x80>)
     b26:	f006 fbd5 	bl	72d4 <k_mem_slab_free>
}
     b2a:	b005      	add	sp, #20
     b2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (log_msg_is_std(msg) && nargs) {
     b2e:	2e00      	cmp	r6, #0
     b30:	d0ee      	beq.n	b10 <msg_free+0x14>
		for (i = 0; i < nargs; i++) {
     b32:	4625      	mov	r5, r4
     b34:	e017      	b.n	b66 <msg_free+0x6a>
			void *buf = (void *)log_msg_arg_get(msg, i);
     b36:	4629      	mov	r1, r5
     b38:	f007 fc84 	bl	8444 <log_msg_arg_get>
     b3c:	4607      	mov	r7, r0
			if (log_is_strdup(buf)) {
     b3e:	f7ff fe35 	bl	7ac <log_is_strdup>
     b42:	b178      	cbz	r0, b64 <msg_free+0x68>
				if (smask == 0) {
     b44:	b93c      	cbnz	r4, b56 <msg_free+0x5a>
					smask = z_log_get_s_mask(
     b46:	9b01      	ldr	r3, [sp, #4]
     b48:	4631      	mov	r1, r6
     b4a:	6918      	ldr	r0, [r3, #16]
     b4c:	f007 fc03 	bl	8356 <z_log_get_s_mask>
					if (smask == 0) {
     b50:	4604      	mov	r4, r0
     b52:	2800      	cmp	r0, #0
     b54:	d0dc      	beq.n	b10 <msg_free+0x14>
				if (smask & BIT(i)) {
     b56:	fa24 f305 	lsr.w	r3, r4, r5
     b5a:	07db      	lsls	r3, r3, #31
     b5c:	d502      	bpl.n	b64 <msg_free+0x68>
					log_free(buf);
     b5e:	4638      	mov	r0, r7
     b60:	f7ff ff7e 	bl	a60 <log_free>
		for (i = 0; i < nargs; i++) {
     b64:	3501      	adds	r5, #1
     b66:	42ae      	cmp	r6, r5
     b68:	9801      	ldr	r0, [sp, #4]
     b6a:	d8e4      	bhi.n	b36 <msg_free+0x3a>
     b6c:	e7d0      	b.n	b10 <msg_free+0x14>
		next = cont->next;
     b6e:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
     b70:	a903      	add	r1, sp, #12
     b72:	4620      	mov	r0, r4
     b74:	f006 fbae 	bl	72d4 <k_mem_slab_free>
		cont = next;
     b78:	9503      	str	r5, [sp, #12]
     b7a:	e7d0      	b.n	b1e <msg_free+0x22>
     b7c:	200000f0 	.word	0x200000f0

00000b80 <log_output_timestamp_freq_set>:
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
}

void log_output_timestamp_freq_set(u32_t frequency)
{
	timestamp_div = 1U;
     b80:	4a08      	ldr	r2, [pc, #32]	; (ba4 <log_output_timestamp_freq_set+0x24>)
{
     b82:	b510      	push	{r4, lr}
	timestamp_div = 1U;
     b84:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
     b86:	4c08      	ldr	r4, [pc, #32]	; (ba8 <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
     b88:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
     b8a:	2100      	movs	r1, #0
     b8c:	42a0      	cmp	r0, r4
     b8e:	d804      	bhi.n	b9a <log_output_timestamp_freq_set+0x1a>
     b90:	b101      	cbz	r1, b94 <log_output_timestamp_freq_set+0x14>
     b92:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
     b94:	4b05      	ldr	r3, [pc, #20]	; (bac <log_output_timestamp_freq_set+0x2c>)
     b96:	6018      	str	r0, [r3, #0]
}
     b98:	bd10      	pop	{r4, pc}
		frequency /= 2U;
     b9a:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
     b9c:	005b      	lsls	r3, r3, #1
     b9e:	2101      	movs	r1, #1
     ba0:	e7f4      	b.n	b8c <log_output_timestamp_freq_set+0xc>
     ba2:	bf00      	nop
     ba4:	20000110 	.word	0x20000110
     ba8:	000f4240 	.word	0x000f4240
     bac:	2000010c 	.word	0x2000010c

00000bb0 <nrf_power_clock_isr>:
#endif
}

NRF_STATIC_INLINE bool nrf_clock_event_check(NRF_CLOCK_Type const * p_reg, nrf_clock_event_t event)
{
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
     bb0:	4b16      	ldr	r3, [pc, #88]	; (c0c <nrf_power_clock_isr+0x5c>)
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
     bb2:	b507      	push	{r0, r1, r2, lr}
     bb4:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
     bb6:	b182      	cbz	r2, bda <nrf_power_clock_isr+0x2a>
    return p_reg->INTENSET & mask;
     bb8:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
     bbc:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
     bc0:	07d1      	lsls	r1, r2, #31
     bc2:	d50a      	bpl.n	bda <nrf_power_clock_isr+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
     bc4:	2200      	movs	r2, #0
     bc6:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
     bc8:	681b      	ldr	r3, [r3, #0]
	struct device *dev = DEVICE_GET(clock_nrf);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
     bca:	4811      	ldr	r0, [pc, #68]	; (c10 <nrf_power_clock_isr+0x60>)
     bcc:	9300      	str	r3, [sp, #0]
    (void)dummy;
     bce:	9b00      	ldr	r3, [sp, #0]

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
     bd0:	6883      	ldr	r3, [r0, #8]
     bd2:	7a59      	ldrb	r1, [r3, #9]
     bd4:	b909      	cbnz	r1, bda <nrf_power_clock_isr+0x2a>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
     bd6:	f007 fc75 	bl	84c4 <clkstarted_handle>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
     bda:	4b0e      	ldr	r3, [pc, #56]	; (c14 <nrf_power_clock_isr+0x64>)
     bdc:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
     bde:	b18a      	cbz	r2, c04 <nrf_power_clock_isr+0x54>
    return p_reg->INTENSET & mask;
     be0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
     be4:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
     be8:	0792      	lsls	r2, r2, #30
     bea:	d50b      	bpl.n	c04 <nrf_power_clock_isr+0x54>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
     bec:	2200      	movs	r2, #0
     bee:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
     bf0:	681b      	ldr	r3, [r3, #0]
     bf2:	9301      	str	r3, [sp, #4]
    (void)dummy;
     bf4:	9b01      	ldr	r3, [sp, #4]
					NRF_CLOCK_INT_LF_STARTED_MASK)) {
		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started(dev);
		}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
     bf6:	4806      	ldr	r0, [pc, #24]	; (c10 <nrf_power_clock_isr+0x60>)
     bf8:	2101      	movs	r1, #1
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
     bfa:	b003      	add	sp, #12
     bfc:	f85d eb04 	ldr.w	lr, [sp], #4
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
     c00:	f007 bc60 	b.w	84c4 <clkstarted_handle>
}
     c04:	b003      	add	sp, #12
     c06:	f85d fb04 	ldr.w	pc, [sp], #4
     c0a:	bf00      	nop
     c0c:	40000100 	.word	0x40000100
     c10:	2000a1d0 	.word	0x2000a1d0
     c14:	40000104 	.word	0x40000104

00000c18 <st7789v_set_orientation>:
	return -ENOTSUP;
}

static int st7789v_set_orientation(const struct device *dev,
			    const enum display_orientation orientation)
{
     c18:	b508      	push	{r3, lr}
	if (orientation == DISPLAY_ORIENTATION_NORMAL) {
     c1a:	b181      	cbz	r1, c3e <st7789v_set_orientation+0x26>
		return 0;
	}
	LOG_ERR("Changing display orientation not implemented");
     c1c:	2301      	movs	r3, #1
     c1e:	f04f 0100 	mov.w	r1, #0
     c22:	f363 0107 	bfi	r1, r3, #0, #8
     c26:	4a07      	ldr	r2, [pc, #28]	; (c44 <st7789v_set_orientation+0x2c>)
     c28:	4b07      	ldr	r3, [pc, #28]	; (c48 <st7789v_set_orientation+0x30>)
     c2a:	4808      	ldr	r0, [pc, #32]	; (c4c <st7789v_set_orientation+0x34>)
     c2c:	1a9b      	subs	r3, r3, r2
     c2e:	08db      	lsrs	r3, r3, #3
     c30:	f363 118f 	bfi	r1, r3, #6, #10
     c34:	f007 fbaf 	bl	8396 <log_0>
	return -ENOTSUP;
     c38:	f06f 0022 	mvn.w	r0, #34	; 0x22
}
     c3c:	bd08      	pop	{r3, pc}
		return 0;
     c3e:	4608      	mov	r0, r1
     c40:	e7fc      	b.n	c3c <st7789v_set_orientation+0x24>
     c42:	bf00      	nop
     c44:	0000c174 	.word	0x0000c174
     c48:	0000c194 	.word	0x0000c194
     c4c:	00044e89 	.word	0x00044e89

00000c50 <st7789v_set_pixel_format>:
	if (pixel_format == PIXEL_FORMAT_RGB_565) {
     c50:	2910      	cmp	r1, #16
{
     c52:	b508      	push	{r3, lr}
	if (pixel_format == PIXEL_FORMAT_RGB_565) {
     c54:	d010      	beq.n	c78 <st7789v_set_pixel_format+0x28>
	LOG_ERR("Pixel format change not implemented");
     c56:	2301      	movs	r3, #1
     c58:	f04f 0100 	mov.w	r1, #0
     c5c:	f363 0107 	bfi	r1, r3, #0, #8
     c60:	4a06      	ldr	r2, [pc, #24]	; (c7c <st7789v_set_pixel_format+0x2c>)
     c62:	4b07      	ldr	r3, [pc, #28]	; (c80 <st7789v_set_pixel_format+0x30>)
     c64:	4807      	ldr	r0, [pc, #28]	; (c84 <st7789v_set_pixel_format+0x34>)
     c66:	1a9b      	subs	r3, r3, r2
     c68:	08db      	lsrs	r3, r3, #3
     c6a:	f363 118f 	bfi	r1, r3, #6, #10
     c6e:	f007 fb92 	bl	8396 <log_0>
	return -ENOTSUP;
     c72:	f06f 0022 	mvn.w	r0, #34	; 0x22
}
     c76:	bd08      	pop	{r3, pc}
		return 0;
     c78:	2000      	movs	r0, #0
     c7a:	e7fc      	b.n	c76 <st7789v_set_pixel_format+0x26>
     c7c:	0000c174 	.word	0x0000c174
     c80:	0000c194 	.word	0x0000c194
     c84:	00044eb6 	.word	0x00044eb6

00000c88 <st7789v_init>:
	st7789v_transmit(p_st7789v, ST7789V_CMD_RGBCTRL, st7789v_rgb_param,
			 sizeof(st7789v_rgb_param));
}

static int st7789v_init(struct device *dev)
{
     c88:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
     c8c:	4607      	mov	r7, r0
	struct st7789v_data *data = (struct st7789v_data *)dev->driver_data;
     c8e:	6884      	ldr	r4, [r0, #8]
     c90:	489e      	ldr	r0, [pc, #632]	; (f0c <st7789v_init+0x284>)
     c92:	f006 f953 	bl	6f3c <z_impl_device_get_binding>

	data->spi_dev = device_get_binding(DT_INST_0_SITRONIX_ST7789V_BUS_NAME);
     c96:	6020      	str	r0, [r4, #0]
	if (data->spi_dev == NULL) {
     c98:	b998      	cbnz	r0, cc2 <st7789v_init+0x3a>
		LOG_ERR("Could not get SPI device for LCD");
     c9a:	2301      	movs	r3, #1
     c9c:	f04f 0100 	mov.w	r1, #0
     ca0:	f363 0107 	bfi	r1, r3, #0, #8
     ca4:	4a9a      	ldr	r2, [pc, #616]	; (f10 <st7789v_init+0x288>)
     ca6:	4b9b      	ldr	r3, [pc, #620]	; (f14 <st7789v_init+0x28c>)
     ca8:	489b      	ldr	r0, [pc, #620]	; (f18 <st7789v_init+0x290>)
     caa:	1a9b      	subs	r3, r3, r2
     cac:	08db      	lsrs	r3, r3, #3
     cae:	f363 118f 	bfi	r1, r3, #6, #10
#endif

	data->cmd_data_gpio = device_get_binding(
			DT_INST_0_SITRONIX_ST7789V_CMD_DATA_GPIOS_CONTROLLER);
	if (data->cmd_data_gpio == NULL) {
		LOG_ERR("Could not get GPIO port for cmd/DATA port");
     cb2:	f007 fb70 	bl	8396 <log_0>
		return -EPERM;
     cb6:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
	st7789v_lcd_init(data);

	st7789v_exit_sleep(data);

	return 0;
}
     cba:	4628      	mov	r0, r5
     cbc:	b002      	add	sp, #8
     cbe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	data->spi_config.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
     cc2:	4a96      	ldr	r2, [pc, #600]	; (f1c <st7789v_init+0x294>)
     cc4:	f44f 7380 	mov.w	r3, #256	; 0x100
     cc8:	e9c4 2301 	strd	r2, r3, [r4, #4]
     ccc:	4894      	ldr	r0, [pc, #592]	; (f20 <st7789v_init+0x298>)
     cce:	f006 f935 	bl	6f3c <z_impl_device_get_binding>
	data->cs_ctrl.delay = 0U;
     cd2:	2619      	movs	r6, #25
     cd4:	2500      	movs	r5, #0
	data->spi_config.cs = &(data->cs_ctrl);
     cd6:	f104 0310 	add.w	r3, r4, #16
	data->cs_ctrl.gpio_dev = device_get_binding(
     cda:	6120      	str	r0, [r4, #16]
	data->cs_ctrl.delay = 0U;
     cdc:	e9c4 6505 	strd	r6, r5, [r4, #20]
	data->spi_config.cs = &(data->cs_ctrl);
     ce0:	60e3      	str	r3, [r4, #12]
     ce2:	488f      	ldr	r0, [pc, #572]	; (f20 <st7789v_init+0x298>)
     ce4:	f006 f92a 	bl	6f3c <z_impl_device_get_binding>
	data->reset_gpio = device_get_binding(
     ce8:	61e0      	str	r0, [r4, #28]
	if (data->reset_gpio == NULL) {
     cea:	b960      	cbnz	r0, d06 <st7789v_init+0x7e>
		LOG_ERR("Could not get GPIO port for display reset");
     cec:	2301      	movs	r3, #1
     cee:	f04f 0100 	mov.w	r1, #0
     cf2:	f363 0107 	bfi	r1, r3, #0, #8
     cf6:	4a86      	ldr	r2, [pc, #536]	; (f10 <st7789v_init+0x288>)
     cf8:	4b86      	ldr	r3, [pc, #536]	; (f14 <st7789v_init+0x28c>)
     cfa:	488a      	ldr	r0, [pc, #552]	; (f24 <st7789v_init+0x29c>)
     cfc:	1a9b      	subs	r3, r3, r2
     cfe:	08db      	lsrs	r3, r3, #3
     d00:	f363 118f 	bfi	r1, r3, #6, #10
     d04:	e7d5      	b.n	cb2 <st7789v_init+0x2a>
	return api->config(port, access_op, pin, flags);
     d06:	6843      	ldr	r3, [r0, #4]
     d08:	4629      	mov	r1, r5
     d0a:	f8d3 8000 	ldr.w	r8, [r3]
     d0e:	221a      	movs	r2, #26
     d10:	2301      	movs	r3, #1
     d12:	47c0      	blx	r8
	if (gpio_pin_configure(data->reset_gpio, ST7789V_RESET_PIN,
     d14:	4605      	mov	r5, r0
     d16:	b180      	cbz	r0, d3a <st7789v_init+0xb2>
		LOG_ERR("Couldn't configure reset pin");
     d18:	2301      	movs	r3, #1
     d1a:	f04f 0100 	mov.w	r1, #0
     d1e:	f363 0107 	bfi	r1, r3, #0, #8
     d22:	4a7b      	ldr	r2, [pc, #492]	; (f10 <st7789v_init+0x288>)
     d24:	4b7b      	ldr	r3, [pc, #492]	; (f14 <st7789v_init+0x28c>)
     d26:	4880      	ldr	r0, [pc, #512]	; (f28 <st7789v_init+0x2a0>)
     d28:	1a9b      	subs	r3, r3, r2
     d2a:	08db      	lsrs	r3, r3, #3
     d2c:	f363 118f 	bfi	r1, r3, #6, #10
		LOG_ERR("Couldn't configure cmd/DATA pin");
     d30:	f007 fb31 	bl	8396 <log_0>
		return -EIO;
     d34:	f06f 0504 	mvn.w	r5, #4
     d38:	e7bf      	b.n	cba <st7789v_init+0x32>
     d3a:	4879      	ldr	r0, [pc, #484]	; (f20 <st7789v_init+0x298>)
     d3c:	f006 f8fe 	bl	6f3c <z_impl_device_get_binding>
	data->cmd_data_gpio = device_get_binding(
     d40:	6220      	str	r0, [r4, #32]
	if (data->cmd_data_gpio == NULL) {
     d42:	b960      	cbnz	r0, d5e <st7789v_init+0xd6>
		LOG_ERR("Could not get GPIO port for cmd/DATA port");
     d44:	2301      	movs	r3, #1
     d46:	f04f 0100 	mov.w	r1, #0
     d4a:	f363 0107 	bfi	r1, r3, #0, #8
     d4e:	4a70      	ldr	r2, [pc, #448]	; (f10 <st7789v_init+0x288>)
     d50:	4b70      	ldr	r3, [pc, #448]	; (f14 <st7789v_init+0x28c>)
     d52:	4876      	ldr	r0, [pc, #472]	; (f2c <st7789v_init+0x2a4>)
     d54:	1a9b      	subs	r3, r3, r2
     d56:	08db      	lsrs	r3, r3, #3
     d58:	f363 118f 	bfi	r1, r3, #6, #10
     d5c:	e7a9      	b.n	cb2 <st7789v_init+0x2a>
     d5e:	6843      	ldr	r3, [r0, #4]
     d60:	4629      	mov	r1, r5
     d62:	f8d3 8000 	ldr.w	r8, [r3]
     d66:	2212      	movs	r2, #18
     d68:	2301      	movs	r3, #1
     d6a:	47c0      	blx	r8
	if (gpio_pin_configure(data->cmd_data_gpio, ST7789V_CMD_DATA_PIN,
     d6c:	4605      	mov	r5, r0
     d6e:	b160      	cbz	r0, d8a <st7789v_init+0x102>
		LOG_ERR("Couldn't configure cmd/DATA pin");
     d70:	2301      	movs	r3, #1
     d72:	f04f 0100 	mov.w	r1, #0
     d76:	f363 0107 	bfi	r1, r3, #0, #8
     d7a:	4a65      	ldr	r2, [pc, #404]	; (f10 <st7789v_init+0x288>)
     d7c:	4b65      	ldr	r3, [pc, #404]	; (f14 <st7789v_init+0x28c>)
     d7e:	486c      	ldr	r0, [pc, #432]	; (f30 <st7789v_init+0x2a8>)
     d80:	1a9b      	subs	r3, r3, r2
     d82:	08db      	lsrs	r3, r3, #3
     d84:	f363 118f 	bfi	r1, r3, #6, #10
     d88:	e7d2      	b.n	d30 <st7789v_init+0xa8>
	gpio_pin_write(data->reset_gpio, ST7789V_RESET_PIN, 1);
     d8a:	2201      	movs	r2, #1
     d8c:	211a      	movs	r1, #26
     d8e:	69e0      	ldr	r0, [r4, #28]
     d90:	f007 fca3 	bl	86da <gpio_pin_write>
	k_sleep(K_MSEC(1));
     d94:	2001      	movs	r0, #1
     d96:	f007 fc8e 	bl	86b6 <k_sleep>
	gpio_pin_write(data->reset_gpio, ST7789V_RESET_PIN, 0);
     d9a:	462a      	mov	r2, r5
     d9c:	211a      	movs	r1, #26
     d9e:	69e0      	ldr	r0, [r4, #28]
     da0:	f007 fc9b 	bl	86da <gpio_pin_write>
	k_sleep(K_MSEC(6));
     da4:	2006      	movs	r0, #6
     da6:	f007 fc86 	bl	86b6 <k_sleep>
	gpio_pin_write(data->reset_gpio, ST7789V_RESET_PIN, 1);
     daa:	2201      	movs	r2, #1
     dac:	211a      	movs	r1, #26
     dae:	69e0      	ldr	r0, [r4, #28]
     db0:	f007 fc93 	bl	86da <gpio_pin_write>
	k_sleep(K_MSEC(20));
     db4:	2014      	movs	r0, #20
     db6:	f007 fc7e 	bl	86b6 <k_sleep>
	st7789v_blanking_on(dev);
     dba:	4638      	mov	r0, r7
     dbc:	f007 fcca 	bl	8754 <st7789v_blanking_on>
	st7789v_transmit(p_st7789v, ST7789V_CMD_PORCTRL, st7789v_porch_param,
     dc0:	4620      	mov	r0, r4
	data->x_offset = x_offset;
     dc2:	62a5      	str	r5, [r4, #40]	; 0x28
	st7789v_transmit(p_st7789v, ST7789V_CMD_PORCTRL, st7789v_porch_param,
     dc4:	2305      	movs	r3, #5
     dc6:	4a5b      	ldr	r2, [pc, #364]	; (f34 <st7789v_init+0x2ac>)
     dc8:	21b2      	movs	r1, #178	; 0xb2
     dca:	f007 fc92 	bl	86f2 <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_CMD2EN, st7789v_cmd2en_param,
     dce:	4620      	mov	r0, r4
     dd0:	2304      	movs	r3, #4
     dd2:	4a59      	ldr	r2, [pc, #356]	; (f38 <st7789v_init+0x2b0>)
     dd4:	21df      	movs	r1, #223	; 0xdf
     dd6:	f007 fc8c 	bl	86f2 <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_DGMEN, &tmp, 1);
     dda:	f10d 0207 	add.w	r2, sp, #7
     dde:	4620      	mov	r0, r4
     de0:	2301      	movs	r3, #1
     de2:	21ba      	movs	r1, #186	; 0xba
	tmp = 0x00;
     de4:	f88d 5007 	strb.w	r5, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_DGMEN, &tmp, 1);
     de8:	f007 fc83 	bl	86f2 <st7789v_transmit>
	tmp = 0x0f;
     dec:	230f      	movs	r3, #15
     dee:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_FRCTRL2, &tmp, 1);
     df2:	f10d 0207 	add.w	r2, sp, #7
     df6:	4620      	mov	r0, r4
     df8:	2301      	movs	r3, #1
     dfa:	21c6      	movs	r1, #198	; 0xc6
     dfc:	f007 fc79 	bl	86f2 <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_GCTRL;
     e00:	2335      	movs	r3, #53	; 0x35
     e02:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_GCTRL, &tmp, 1);
     e06:	f10d 0207 	add.w	r2, sp, #7
     e0a:	4620      	mov	r0, r4
     e0c:	2301      	movs	r3, #1
     e0e:	21b7      	movs	r1, #183	; 0xb7
     e10:	f007 fc6f 	bl	86f2 <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_VCOM;
     e14:	f88d 6007 	strb.w	r6, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_VCOMS, &tmp, 1);
     e18:	f10d 0207 	add.w	r2, sp, #7
	tmp = 0x01;
     e1c:	2601      	movs	r6, #1
	st7789v_transmit(p_st7789v, ST7789V_CMD_VCOMS, &tmp, 1);
     e1e:	4620      	mov	r0, r4
     e20:	2301      	movs	r3, #1
     e22:	21bb      	movs	r1, #187	; 0xbb
     e24:	f007 fc65 	bl	86f2 <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_VDVVRHEN, &tmp, 1);
     e28:	4633      	mov	r3, r6
     e2a:	f10d 0207 	add.w	r2, sp, #7
     e2e:	4620      	mov	r0, r4
     e30:	21c2      	movs	r1, #194	; 0xc2
	tmp = 0x01;
     e32:	f88d 6007 	strb.w	r6, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_VDVVRHEN, &tmp, 1);
     e36:	f007 fc5c 	bl	86f2 <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_VRHS;
     e3a:	2312      	movs	r3, #18
     e3c:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_VRH, &tmp, 1);
     e40:	f10d 0207 	add.w	r2, sp, #7
     e44:	4633      	mov	r3, r6
     e46:	4620      	mov	r0, r4
     e48:	21c3      	movs	r1, #195	; 0xc3
     e4a:	f007 fc52 	bl	86f2 <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_VDVS;
     e4e:	2320      	movs	r3, #32
     e50:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_VDS, &tmp, 1);
     e54:	f10d 0207 	add.w	r2, sp, #7
     e58:	4633      	mov	r3, r6
     e5a:	4620      	mov	r0, r4
     e5c:	21c4      	movs	r1, #196	; 0xc4
     e5e:	f007 fc48 	bl	86f2 <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_PWCTRL1, st7789v_pwctrl1_param,
     e62:	4620      	mov	r0, r4
     e64:	2302      	movs	r3, #2
     e66:	4a35      	ldr	r2, [pc, #212]	; (f3c <st7789v_init+0x2b4>)
     e68:	21d0      	movs	r1, #208	; 0xd0
     e6a:	f007 fc42 	bl	86f2 <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_MADCTL, &tmp, 1);
     e6e:	4633      	mov	r3, r6
     e70:	f10d 0207 	add.w	r2, sp, #7
     e74:	4620      	mov	r0, r4
     e76:	2136      	movs	r1, #54	; 0x36
	tmp = DT_INST_0_SITRONIX_ST7789V_MDAC;
     e78:	f88d 5007 	strb.w	r5, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_MADCTL, &tmp, 1);
     e7c:	f007 fc39 	bl	86f2 <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_COLMOD;
     e80:	2305      	movs	r3, #5
     e82:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_COLMOD, &tmp, 1);
     e86:	f10d 0207 	add.w	r2, sp, #7
     e8a:	4633      	mov	r3, r6
     e8c:	4620      	mov	r0, r4
     e8e:	213a      	movs	r1, #58	; 0x3a
     e90:	f007 fc2f 	bl	86f2 <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_LCM;
     e94:	232c      	movs	r3, #44	; 0x2c
     e96:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_LCMCTRL, &tmp, 1);
     e9a:	f10d 0207 	add.w	r2, sp, #7
     e9e:	4633      	mov	r3, r6
     ea0:	4620      	mov	r0, r4
     ea2:	21c0      	movs	r1, #192	; 0xc0
     ea4:	f007 fc25 	bl	86f2 <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_GAMSET, &tmp, 1);
     ea8:	4633      	mov	r3, r6
     eaa:	f10d 0207 	add.w	r2, sp, #7
     eae:	4620      	mov	r0, r4
     eb0:	2126      	movs	r1, #38	; 0x26
	tmp = DT_INST_0_SITRONIX_ST7789V_GAMMA;
     eb2:	f88d 6007 	strb.w	r6, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_GAMSET, &tmp, 1);
     eb6:	f007 fc1c 	bl	86f2 <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_INV_ON, NULL, 0);
     eba:	462b      	mov	r3, r5
     ebc:	462a      	mov	r2, r5
     ebe:	4620      	mov	r0, r4
     ec0:	2121      	movs	r1, #33	; 0x21
     ec2:	f007 fc16 	bl	86f2 <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_PVGAMCTRL, st7789v_pvgam_param,
     ec6:	4620      	mov	r0, r4
     ec8:	230e      	movs	r3, #14
     eca:	4a1d      	ldr	r2, [pc, #116]	; (f40 <st7789v_init+0x2b8>)
     ecc:	21e0      	movs	r1, #224	; 0xe0
     ece:	f007 fc10 	bl	86f2 <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_NVGAMCTRL, st7789v_nvgam_param,
     ed2:	4620      	mov	r0, r4
     ed4:	230e      	movs	r3, #14
     ed6:	4a1b      	ldr	r2, [pc, #108]	; (f44 <st7789v_init+0x2bc>)
     ed8:	21e1      	movs	r1, #225	; 0xe1
     eda:	f007 fc0a 	bl	86f2 <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_RAMCTRL, st7789v_ram_param,
     ede:	4620      	mov	r0, r4
     ee0:	2302      	movs	r3, #2
     ee2:	4a19      	ldr	r2, [pc, #100]	; (f48 <st7789v_init+0x2c0>)
     ee4:	21b0      	movs	r1, #176	; 0xb0
     ee6:	f007 fc04 	bl	86f2 <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_RGBCTRL, st7789v_rgb_param,
     eea:	4620      	mov	r0, r4
     eec:	2303      	movs	r3, #3
     eee:	4a17      	ldr	r2, [pc, #92]	; (f4c <st7789v_init+0x2c4>)
     ef0:	21b1      	movs	r1, #177	; 0xb1
     ef2:	f007 fbfe 	bl	86f2 <st7789v_transmit>
	st7789v_transmit(data, ST7789V_CMD_SLEEP_OUT, NULL, 0);
     ef6:	4620      	mov	r0, r4
     ef8:	462b      	mov	r3, r5
     efa:	462a      	mov	r2, r5
     efc:	2111      	movs	r1, #17
     efe:	f007 fbf8 	bl	86f2 <st7789v_transmit>
	k_sleep(K_MSEC(120));
     f02:	2078      	movs	r0, #120	; 0x78
     f04:	f007 fbd7 	bl	86b6 <k_sleep>
     f08:	e6d7      	b.n	cba <st7789v_init+0x32>
     f0a:	bf00      	nop
     f0c:	00044dd1 	.word	0x00044dd1
     f10:	0000c174 	.word	0x0000c174
     f14:	0000c194 	.word	0x0000c194
     f18:	00044dd7 	.word	0x00044dd7
     f1c:	007a1200 	.word	0x007a1200
     f20:	00044d12 	.word	0x00044d12
     f24:	00044df8 	.word	0x00044df8
     f28:	00044e22 	.word	0x00044e22
     f2c:	00044e3f 	.word	0x00044e3f
     f30:	00044e69 	.word	0x00044e69
     f34:	2000a186 	.word	0x2000a186
     f38:	2000a174 	.word	0x2000a174
     f3c:	2000a199 	.word	0x2000a199
     f40:	2000a18b 	.word	0x2000a18b
     f44:	2000a178 	.word	0x2000a178
     f48:	2000a19b 	.word	0x2000a19b
     f4c:	2000a19d 	.word	0x2000a19d

00000f50 <rtc1_nrf_isr>:
 * symbol.
 */
void rtc1_nrf_isr(void *arg)
{
	ARG_UNUSED(arg);
	RTC->EVENTS_COMPARE[0] = 0;
     f50:	4b0d      	ldr	r3, [pc, #52]	; (f88 <rtc1_nrf_isr+0x38>)
     f52:	2200      	movs	r2, #0
     f54:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
	__asm__ volatile(
     f58:	f04f 0220 	mov.w	r2, #32
     f5c:	f3ef 8111 	mrs	r1, BASEPRI
     f60:	f382 8811 	msr	BASEPRI, r2
     f64:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t t = counter();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
     f68:	4a08      	ldr	r2, [pc, #32]	; (f8c <rtc1_nrf_isr+0x3c>)
#endif
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
     f6a:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
     f6e:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
     f70:	1ac0      	subs	r0, r0, r3
     f72:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
     f76:	4403      	add	r3, r0
     f78:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
     f7a:	f381 8811 	msr	BASEPRI, r1
     f7e:	f3bf 8f6f 	isb	sy
		}
		set_comparator(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
     f82:	f006 bf33 	b.w	7dec <z_clock_announce>
     f86:	bf00      	nop
     f88:	40011000 	.word	0x40011000
     f8c:	2000012c 	.word	0x2000012c

00000f90 <z_clock_driver_init>:
}

int z_clock_driver_init(struct device *device)
{
     f90:	b573      	push	{r0, r1, r4, r5, r6, lr}
     f92:	481c      	ldr	r0, [pc, #112]	; (1004 <z_clock_driver_init+0x74>)
     f94:	f005 ffd2 	bl	6f3c <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_INST_0_NORDIC_NRF_CLOCK_LABEL);
	if (!clock) {
     f98:	b380      	cbz	r0, ffc <z_clock_driver_init+0x6c>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
     f9a:	6843      	ldr	r3, [r0, #4]
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
     f9c:	4d1a      	ldr	r5, [pc, #104]	; (1008 <z_clock_driver_init+0x78>)
     f9e:	681b      	ldr	r3, [r3, #0]
     fa0:	2101      	movs	r1, #1
     fa2:	4798      	blx	r3
    p_reg->CC[ch] = cc_val;
     fa4:	2601      	movs	r6, #1
    p_reg->PRESCALER = val;
     fa6:	2400      	movs	r4, #0
    p_reg->INTENSET = mask;
     fa8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->PRESCALER = val;
     fac:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
     fb0:	f8c5 6540 	str.w	r6, [r5, #1344]	; 0x540
    p_reg->INTENSET = mask;
     fb4:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
     fb8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
     fbc:	f503 538a 	add.w	r3, r3, #4416	; 0x1140
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     fc0:	f44f 3200 	mov.w	r2, #131072	; 0x20000
     fc4:	601c      	str	r4, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
     fc6:	681b      	ldr	r3, [r3, #0]
     fc8:	9301      	str	r3, [sp, #4]
    (void)dummy;
     fca:	9b01      	ldr	r3, [sp, #4]
     fcc:	4b0f      	ldr	r3, [pc, #60]	; (100c <z_clock_driver_init+0x7c>)

	/* Clear the event flag and possible pending interrupt */
	nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_COMPARE_0);
	NVIC_ClearPendingIRQ(RTC1_IRQn);

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
     fce:	4631      	mov	r1, r6
     fd0:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
     fd4:	2011      	movs	r0, #17
     fd6:	4622      	mov	r2, r4
     fd8:	f000 f918 	bl	120c <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
     fdc:	2011      	movs	r0, #17
     fde:	f000 f905 	bl	11ec <arch_irq_enable>
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
     fe2:	4b0b      	ldr	r3, [pc, #44]	; (1010 <z_clock_driver_init+0x80>)
     fe4:	601e      	str	r6, [r3, #0]
     fe6:	602e      	str	r6, [r5, #0]
     return p_reg->COUNTER;
     fe8:	f8d5 3504 	ldr.w	r3, [r5, #1284]	; 0x504

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	if (!IS_ENABLED(TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
     fec:	4433      	add	r3, r6
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
     fee:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
     ff2:	f8c5 3540 	str.w	r3, [r5, #1344]	; 0x540
	}

	return 0;
     ff6:	4620      	mov	r0, r4
}
     ff8:	b002      	add	sp, #8
     ffa:	bd70      	pop	{r4, r5, r6, pc}
		return -1;
     ffc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1000:	e7fa      	b.n	ff8 <z_clock_driver_init+0x68>
    1002:	bf00      	nop
    1004:	00044db1 	.word	0x00044db1
    1008:	40011000 	.word	0x40011000
    100c:	e000e100 	.word	0xe000e100
    1010:	40011008 	.word	0x40011008

00001014 <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
    1014:	b5f0      	push	{r4, r5, r6, r7, lr}
	ARG_UNUSED(idle);

#ifdef CONFIG_TICKLESS_KERNEL
	ticks = (ticks == K_FOREVER) ? MAX_TICKS : ticks;
    1016:	4e25      	ldr	r6, [pc, #148]	; (10ac <z_clock_set_timeout+0x98>)
    1018:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    101c:	bf08      	it	eq
    101e:	4630      	moveq	r0, r6
	__asm__ volatile(
    1020:	f04f 0320 	mov.w	r3, #32
    1024:	f3ef 8511 	mrs	r5, BASEPRI
    1028:	f383 8811 	msr	BASEPRI, r3
    102c:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
    1030:	491f      	ldr	r1, [pc, #124]	; (10b0 <z_clock_set_timeout+0x9c>)
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t cyc, dt, t = counter();
	u32_t unannounced = counter_sub(t, last_count);
    1032:	4b20      	ldr	r3, [pc, #128]	; (10b4 <z_clock_set_timeout+0xa0>)
    1034:	f8d1 4504 	ldr.w	r4, [r1, #1284]	; 0x504
    1038:	681b      	ldr	r3, [r3, #0]
	return (a - b) & COUNTER_MAX;
    103a:	1ae2      	subs	r2, r4, r3
    103c:	f022 477f 	bic.w	r7, r2, #4278190080	; 0xff000000
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
    1040:	0212      	lsls	r2, r2, #8
    1042:	d419      	bmi.n	1078 <z_clock_set_timeout+0x64>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
    1044:	1e42      	subs	r2, r0, #1
    1046:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    104a:	42b2      	cmp	r2, r6
    104c:	bfa8      	it	ge
    104e:	4632      	movge	r2, r6
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    1050:	1c78      	adds	r0, r7, #1
    1052:	4410      	add	r0, r2
	 */
	if (cyc > MAX_CYCLES) {
		cyc = MAX_CYCLES;
	}

	cyc += last_count;
    1054:	42b0      	cmp	r0, r6
    1056:	bf94      	ite	ls
    1058:	1818      	addls	r0, r3, r0
    105a:	1998      	addhi	r0, r3, r6
	return (a - b) & COUNTER_MAX;
    105c:	1b04      	subs	r4, r0, r4
    105e:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
    1062:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
	 * least on nRF52.  Some experimentation on nrf52840 shows
	 * that you need to be early by about 400 processor cycles
	 * (about 1/5th of a RTC cycle) in order to reliably get the
	 * interrupt.  The docs say two cycles, they mean two cycles.
	 */
	if (counter_sub(cyc, t) > 2) {
    1066:	2c02      	cmp	r4, #2
    p_reg->CC[ch] = cc_val;
    1068:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
    106c:	d906      	bls.n	107c <z_clock_set_timeout+0x68>
	__asm__ volatile(
    106e:	f385 8811 	msr	BASEPRI, r5
    1072:	f3bf 8f6f 	isb	sy
	}
#endif

	k_spin_unlock(&lock, key);
#endif /* CONFIG_TICKLESS_KERNEL */
}
    1076:	bdf0      	pop	{r4, r5, r6, r7, pc}
		ticks = 0;
    1078:	2200      	movs	r2, #0
    107a:	e7e9      	b.n	1050 <z_clock_set_timeout+0x3c>
     return p_reg->COUNTER;
    107c:	f8d1 3504 	ldr.w	r3, [r1, #1284]	; 0x504
		if (dt == 0 || dt > 0x7fffff) {
    1080:	4a0d      	ldr	r2, [pc, #52]	; (10b8 <z_clock_set_timeout+0xa4>)
	return (a - b) & COUNTER_MAX;
    1082:	1ac3      	subs	r3, r0, r3
    1084:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		if (dt == 0 || dt > 0x7fffff) {
    1088:	1e5c      	subs	r4, r3, #1
    108a:	4294      	cmp	r4, r2
    108c:	d905      	bls.n	109a <z_clock_set_timeout+0x86>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    108e:	4b0b      	ldr	r3, [pc, #44]	; (10bc <z_clock_set_timeout+0xa8>)
    1090:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    1094:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    1098:	e7e9      	b.n	106e <z_clock_set_timeout+0x5a>
		} else if (dt == 1) {
    109a:	2b01      	cmp	r3, #1
			set_comparator(cyc + 2);
    109c:	bf02      	ittt	eq
    109e:	3002      	addeq	r0, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    10a0:	f020 407f 	biceq.w	r0, r0, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    10a4:	f8c1 0540 	streq.w	r0, [r1, #1344]	; 0x540
    10a8:	e7e1      	b.n	106e <z_clock_set_timeout+0x5a>
    10aa:	bf00      	nop
    10ac:	00fffffe 	.word	0x00fffffe
    10b0:	40011000 	.word	0x40011000
    10b4:	2000012c 	.word	0x2000012c
    10b8:	007ffffe 	.word	0x007ffffe
    10bc:	e000e100 	.word	0xe000e100

000010c0 <z_clock_elapsed>:
	__asm__ volatile(
    10c0:	f04f 0220 	mov.w	r2, #32
    10c4:	f3ef 8311 	mrs	r3, BASEPRI
    10c8:	f382 8811 	msr	BASEPRI, r2
    10cc:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
    10d0:	4a06      	ldr	r2, [pc, #24]	; (10ec <z_clock_elapsed+0x2c>)
    10d2:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
    10d6:	4a06      	ldr	r2, [pc, #24]	; (10f0 <z_clock_elapsed+0x30>)
	return (a - b) & COUNTER_MAX;
    10d8:	6812      	ldr	r2, [r2, #0]
    10da:	1a80      	subs	r0, r0, r2
    10dc:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	__asm__ volatile(
    10e0:	f383 8811 	msr	BASEPRI, r3
    10e4:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    10e8:	4770      	bx	lr
    10ea:	bf00      	nop
    10ec:	40011000 	.word	0x40011000
    10f0:	2000012c 	.word	0x2000012c

000010f4 <z_timer_cycle_get_32>:
	__asm__ volatile(
    10f4:	f04f 0320 	mov.w	r3, #32
    10f8:	f3ef 8211 	mrs	r2, BASEPRI
    10fc:	f383 8811 	msr	BASEPRI, r3
    1100:	f3bf 8f6f 	isb	sy

u32_t z_timer_cycle_get_32(void)
{
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) + last_count;
    1104:	4906      	ldr	r1, [pc, #24]	; (1120 <z_timer_cycle_get_32+0x2c>)
    1106:	4b07      	ldr	r3, [pc, #28]	; (1124 <z_timer_cycle_get_32+0x30>)
    1108:	6808      	ldr	r0, [r1, #0]
    110a:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	__asm__ volatile(
    110e:	f382 8811 	msr	BASEPRI, r2
    1112:	f3bf 8f6f 	isb	sy
	return (a - b) & COUNTER_MAX;
    1116:	1a1b      	subs	r3, r3, r0
    1118:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000

	k_spin_unlock(&lock, key);
	return ret;
}
    111c:	4418      	add	r0, r3
    111e:	4770      	bx	lr
    1120:	2000012c 	.word	0x2000012c
    1124:	40011000 	.word	0x40011000

00001128 <z_arm_exc_exit>:
    /* r0 contains the caller mode */
    push {r0, lr}
#endif

#ifdef CONFIG_PREEMPT_ENABLED
    ldr r0, =_kernel
    1128:	4804      	ldr	r0, [pc, #16]	; (113c <_EXIT_EXC+0x2>)

    ldr r1, [r0, #_kernel_offset_to_current]
    112a:	6881      	ldr	r1, [r0, #8]

    ldr r0, [r0, #_kernel_offset_to_ready_q_cache]
    112c:	6a40      	ldr	r0, [r0, #36]	; 0x24
    cmp r0, r1
    112e:	4288      	cmp	r0, r1
    beq _EXIT_EXC
    1130:	d003      	beq.n	113a <_EXIT_EXC>

#if defined(CONFIG_CPU_CORTEX_M)
    /* context switch required, pend the PendSV exception */
    ldr r1, =_SCS_ICSR
    1132:	4903      	ldr	r1, [pc, #12]	; (1140 <_EXIT_EXC+0x6>)
    ldr r2, =_SCS_ICSR_PENDSV
    1134:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    str r2, [r1]
    1138:	600a      	str	r2, [r1, #0]

0000113a <_EXIT_EXC>:
    bl z_check_stack_sentinel
#endif /* CONFIG_CPU_CORTEX_M */
#endif /* CONFIG_STACK_SENTINEL */

#if defined(CONFIG_CPU_CORTEX_M)
    bx lr
    113a:	4770      	bx	lr
    ldr r0, =_kernel
    113c:	200047c4 	.word	0x200047c4
    ldr r1, =_SCS_ICSR
    1140:	e000ed04 	.word	0xe000ed04

00001144 <arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
    1144:	4a09      	ldr	r2, [pc, #36]	; (116c <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
    1146:	490a      	ldr	r1, [pc, #40]	; (1170 <arch_swap+0x2c>)
	_current->arch.basepri = key;
    1148:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    114a:	6809      	ldr	r1, [r1, #0]
    114c:	6699      	str	r1, [r3, #104]	; 0x68

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    114e:	4909      	ldr	r1, [pc, #36]	; (1174 <arch_swap+0x30>)
	_current->arch.basepri = key;
    1150:	6658      	str	r0, [r3, #100]	; 0x64
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    1152:	684b      	ldr	r3, [r1, #4]
    1154:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    1158:	604b      	str	r3, [r1, #4]
    115a:	2300      	movs	r3, #0
    115c:	f383 8811 	msr	BASEPRI, r3
    1160:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    1164:	6893      	ldr	r3, [r2, #8]
}
    1166:	6e98      	ldr	r0, [r3, #104]	; 0x68
    1168:	4770      	bx	lr
    116a:	bf00      	nop
    116c:	200047c4 	.word	0x200047c4
    1170:	0000c858 	.word	0x0000c858
    1174:	e000ed00 	.word	0xe000ed00

00001178 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    1178:	4912      	ldr	r1, [pc, #72]	; (11c4 <z_arm_pendsv+0x4c>)
    ldr r2, [r1, #_kernel_offset_to_current]
    117a:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    117c:	f04f 0028 	mov.w	r0, #40	; 0x28
    add r0, r2
    1180:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    1182:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    1186:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    118a:	2020      	movs	r0, #32
    msr BASEPRI, r0
    118c:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    1190:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    1194:	4f0c      	ldr	r7, [pc, #48]	; (11c8 <z_arm_pendsv+0x50>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    1196:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    119a:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
    119c:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    119e:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    11a0:	6e50      	ldr	r0, [r2, #100]	; 0x64
    movs r3, #0
    11a2:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    11a4:	6653      	str	r3, [r2, #100]	; 0x64
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    11a6:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined (CONFIG_ARM_MPU)
    /* Re-program dynamic memory map */
    push {r2,lr}
    11aa:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
    11ac:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
    11ae:	f007 fb59 	bl	8864 <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
    11b2:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    11b6:	f102 0028 	add.w	r0, r2, #40	; 0x28
    ldmia r0, {v1-v8, ip}
    11ba:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
    mov r0, #0
    msr PSPLIM, r0
#endif /* CONFIG_BUILTIN_STACK_GUARD */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    11be:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
    11c2:	4770      	bx	lr
    ldr r1, =_kernel
    11c4:	200047c4 	.word	0x200047c4
    ldr v4, =_SCS_ICSR
    11c8:	e000ed04 	.word	0xe000ed04

000011cc <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
    11cc:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    11d0:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    11d2:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    11d6:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    11da:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    11dc:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    11e0:	2902      	cmp	r1, #2
    beq _oops
    11e2:	d0ff      	beq.n	11e4 <_oops>

000011e4 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    11e4:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    11e6:	f007 fb32 	bl	884e <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    11ea:	bd01      	pop	{r0, pc}

000011ec <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    11ec:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    11ee:	2b00      	cmp	r3, #0
    11f0:	db08      	blt.n	1204 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    11f2:	2201      	movs	r2, #1
    11f4:	f000 001f 	and.w	r0, r0, #31
    11f8:	fa02 f000 	lsl.w	r0, r2, r0
    11fc:	095b      	lsrs	r3, r3, #5
    11fe:	4a02      	ldr	r2, [pc, #8]	; (1208 <arch_irq_enable+0x1c>)
    1200:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    1204:	4770      	bx	lr
    1206:	bf00      	nop
    1208:	e000e100 	.word	0xe000e100

0000120c <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(DT_NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    120c:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    120e:	2b00      	cmp	r3, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    1210:	bfa8      	it	ge
    1212:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
	prio += _IRQ_PRIO_OFFSET;
    1216:	f101 0101 	add.w	r1, r1, #1
    121a:	ea4f 1141 	mov.w	r1, r1, lsl #5
    121e:	bfae      	itee	ge
    1220:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    1224:	f000 000f 	andlt.w	r0, r0, #15
    1228:	4b03      	ldrlt	r3, [pc, #12]	; (1238 <z_arm_irq_priority_set+0x2c>)
    122a:	b2c9      	uxtb	r1, r1
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    122c:	bfac      	ite	ge
    122e:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    1232:	5419      	strblt	r1, [r3, r0]
}
    1234:	4770      	bx	lr
    1236:	bf00      	nop
    1238:	e000ed14 	.word	0xe000ed14

0000123c <arch_new_thread>:
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     size_t stackSize, k_thread_entry_t pEntry,
		     void *parameter1, void *parameter2, void *parameter3,
		     int priority, unsigned int options)
{
    123c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    123e:	461e      	mov	r6, r3
#endif
	stackEnd = pStackMem + stackSize;

	struct __esf *pInitCtx;

	z_new_thread_init(thread, pStackMem, stackSize, priority,
    1240:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1242:	9300      	str	r3, [sp, #0]
	stackEnd = pStackMem + stackSize;
    1244:	188c      	adds	r4, r1, r2
	z_new_thread_init(thread, pStackMem, stackSize, priority,
    1246:	9b09      	ldr	r3, [sp, #36]	; 0x24
{
    1248:	4605      	mov	r5, r0
	z_new_thread_init(thread, pStackMem, stackSize, priority,
    124a:	f00a fe0f 	bl	be6c <z_new_thread_init>
	 *
	 * The initial carved stack frame only needs to contain the basic
	 * stack frame (state context), because no FP operations have been
	 * performed yet for this thread.
	 */
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
    124e:	f1a4 0320 	sub.w	r3, r4, #32
	pInitCtx->basic.pc = (u32_t)z_thread_entry;
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
    1252:	4a0a      	ldr	r2, [pc, #40]	; (127c <arch_new_thread+0x40>)
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
    1254:	f023 0307 	bic.w	r3, r3, #7
	pInitCtx->basic.pc &= 0xfffffffe;
    1258:	f022 0201 	bic.w	r2, r2, #1
    125c:	619a      	str	r2, [r3, #24]
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
	pInitCtx->basic.a2 = (u32_t)parameter1;
    125e:	9a06      	ldr	r2, [sp, #24]
    1260:	605a      	str	r2, [r3, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
    1262:	9a07      	ldr	r2, [sp, #28]
    1264:	609a      	str	r2, [r3, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
    1266:	9a08      	ldr	r2, [sp, #32]
    1268:	60da      	str	r2, [r3, #12]
	pInitCtx->basic.xpsr =
    126a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
	pInitCtx->basic.a1 = (u32_t)pEntry;
    126e:	601e      	str	r6, [r3, #0]
	pInitCtx->basic.xpsr =
    1270:	61da      	str	r2, [r3, #28]
		0x01000000UL; /* clear all, thumb bit is 1, even if RO */

	thread->callee_saved.psp = (u32_t)pInitCtx;
    1272:	64ab      	str	r3, [r5, #72]	; 0x48
#if defined(CONFIG_CPU_CORTEX_R)
	pInitCtx->basic.lr = (u32_t)pInitCtx->basic.pc;
	thread->callee_saved.spsr = A_BIT | T_BIT | MODE_SYS;
	thread->callee_saved.lr = (u32_t)pInitCtx->basic.pc;
#endif
	thread->arch.basepri = 0;
    1274:	2300      	movs	r3, #0
    1276:	666b      	str	r3, [r5, #100]	; 0x64

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    1278:	b002      	add	sp, #8
    127a:	bd70      	pop	{r4, r5, r6, pc}
    127c:	000082fb 	.word	0x000082fb

00001280 <arch_switch_to_main_thread>:

void arch_switch_to_main_thread(struct k_thread *main_thread,
				k_thread_stack_t *main_stack,
				size_t main_stack_size,
				k_thread_entry_t _main)
{
    1280:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1282:	4605      	mov	r5, r0
    1284:	460c      	mov	r4, r1
    1286:	4617      	mov	r7, r2
    1288:	461e      	mov	r6, r3
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    128a:	f000 fb93 	bl	19b4 <z_arm_configure_static_mpu_regions>
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);

	_current = main_thread;
    128e:	4b0a      	ldr	r3, [pc, #40]	; (12b8 <arch_switch_to_main_thread+0x38>)
	start_of_main_stack =
    1290:	443c      	add	r4, r7
#ifdef CONFIG_ARM_MPU
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
    1292:	4628      	mov	r0, r5
	_current = main_thread;
    1294:	609d      	str	r5, [r3, #8]
	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);
    1296:	f024 0407 	bic.w	r4, r4, #7
	z_arm_configure_dynamic_mpu_regions(main_thread);
    129a:	f007 fae3 	bl	8864 <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    129e:	4630      	mov	r0, r6
    12a0:	f384 8809 	msr	PSP, r4
    12a4:	2100      	movs	r1, #0
    12a6:	b663      	cpsie	if
    12a8:	f381 8811 	msr	BASEPRI, r1
    12ac:	f3bf 8f6f 	isb	sy
    12b0:	2200      	movs	r2, #0
    12b2:	2300      	movs	r3, #0
    12b4:	f007 f821 	bl	82fa <z_thread_entry>
	:
	: "r" (_main), "r" (start_of_main_stack)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    12b8:	200047c4 	.word	0x200047c4

000012bc <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr r1, =_SCB_SCR
    12bc:	4901      	ldr	r1, [pc, #4]	; (12c4 <z_arm_cpu_idle_init+0x8>)
	movs.n r2, #_SCR_INIT_BITS
    12be:	2210      	movs	r2, #16
	str r2, [r1]
    12c0:	600a      	str	r2, [r1, #0]
#endif
	bx lr
    12c2:	4770      	bx	lr
	ldr r1, =_SCB_SCR
    12c4:	e000ed10 	.word	0xe000ed10

000012c8 <arch_cpu_idle>:
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	cpsie i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* clear BASEPRI so wfi is awakened by incoming interrupts */
	eors.n r0, r0
    12c8:	4040      	eors	r0, r0
	msr BASEPRI, r0
    12ca:	f380 8811 	msr	BASEPRI, r0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	wfi
    12ce:	bf30      	wfi

	bx lr
    12d0:	4770      	bx	lr
    12d2:	bf00      	nop

000012d4 <z_arm_bus_fault>:
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_reserved)

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) || \
	defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	mrs r0, MSP
    12d4:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    12d8:	f3ef 8109 	mrs	r1, PSP
	mov r2, lr /* EXC_RETURN */
    12dc:	4672      	mov	r2, lr

	push {r0, lr}
    12de:	b501      	push	{r0, lr}
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE || CONFIG_ARMv7_M_ARMV8_M_MAINLINE */

	bl z_arm_fault
    12e0:	f000 fa46 	bl	1770 <z_arm_fault>

#if defined(CONFIG_CPU_CORTEX_M)
	pop {r0, pc}
    12e4:	bd01      	pop	{r0, pc}
    12e6:	bf00      	nop

000012e8 <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    12e8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    12ea:	4606      	mov	r6, r0

	if (esf != NULL) {
    12ec:	460c      	mov	r4, r1
    12ee:	2900      	cmp	r1, #0
    12f0:	d038      	beq.n	1364 <z_arm_fatal_error+0x7c>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
    12f2:	2201      	movs	r2, #1
    12f4:	f04f 0300 	mov.w	r3, #0
    12f8:	f362 0307 	bfi	r3, r2, #0, #8
    12fc:	4d1d      	ldr	r5, [pc, #116]	; (1374 <z_arm_fatal_error+0x8c>)
    12fe:	4a1e      	ldr	r2, [pc, #120]	; (1378 <z_arm_fatal_error+0x90>)
    1300:	481e      	ldr	r0, [pc, #120]	; (137c <z_arm_fatal_error+0x94>)
    1302:	1aad      	subs	r5, r5, r2
    1304:	f3c5 05c9 	ubfx	r5, r5, #3, #10
    1308:	f365 138f 	bfi	r3, r5, #6, #10
    130c:	f8ad 3000 	strh.w	r3, [sp]
    1310:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
    1314:	6809      	ldr	r1, [r1, #0]
    1316:	f007 f877 	bl	8408 <log_3>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
    131a:	2201      	movs	r2, #1
    131c:	f04f 0300 	mov.w	r3, #0
    1320:	f362 0307 	bfi	r3, r2, #0, #8
    1324:	f365 138f 	bfi	r3, r5, #6, #10
    1328:	f8ad 3000 	strh.w	r3, [sp]
    132c:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    1330:	68e1      	ldr	r1, [r4, #12]
    1332:	4813      	ldr	r0, [pc, #76]	; (1380 <z_arm_fatal_error+0x98>)
    1334:	f007 f868 	bl	8408 <log_3>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
    1338:	2301      	movs	r3, #1
    133a:	f04f 0200 	mov.w	r2, #0
    133e:	f363 0207 	bfi	r2, r3, #0, #8
    1342:	f365 128f 	bfi	r2, r5, #6, #10
    1346:	69e1      	ldr	r1, [r4, #28]
    1348:	480e      	ldr	r0, [pc, #56]	; (1384 <z_arm_fatal_error+0x9c>)
    134a:	f007 f831 	bl	83b0 <log_1>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    134e:	f04f 0200 	mov.w	r2, #0
    1352:	2301      	movs	r3, #1
    1354:	f363 0207 	bfi	r2, r3, #0, #8
    1358:	f365 128f 	bfi	r2, r5, #6, #10
    135c:	69a1      	ldr	r1, [r4, #24]
    135e:	480a      	ldr	r0, [pc, #40]	; (1388 <z_arm_fatal_error+0xa0>)
    1360:	f007 f826 	bl	83b0 <log_1>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
    1364:	4621      	mov	r1, r4
    1366:	4630      	mov	r0, r6
}
    1368:	b002      	add	sp, #8
    136a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_fatal_error(reason, esf);
    136e:	f005 be27 	b.w	6fc0 <z_fatal_error>
    1372:	bf00      	nop
    1374:	0000c1bc 	.word	0x0000c1bc
    1378:	0000c174 	.word	0x0000c174
    137c:	00044ef4 	.word	0x00044ef4
    1380:	00044f23 	.word	0x00044f23
    1384:	00044f52 	.word	0x00044f52
    1388:	00044f61 	.word	0x00044f61

0000138c <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    138c:	bf30      	wfi
    b z_SysNmiOnReset
    138e:	f7ff bffd 	b.w	138c <z_SysNmiOnReset>
    1392:	bf00      	nop

00001394 <z_arm_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    1394:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    1396:	4b08      	ldr	r3, [pc, #32]	; (13b8 <z_arm_prep_c+0x24>)
    1398:	4a08      	ldr	r2, [pc, #32]	; (13bc <z_arm_prep_c+0x28>)
    139a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    139e:	6093      	str	r3, [r2, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    13a0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    13a4:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
	enable_floating_point();
	z_bss_zero();
    13a8:	f005 fe88 	bl	70bc <z_bss_zero>
	z_data_copy();
    13ac:	f005 fe90 	bl	70d0 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_int_lib_init();
    13b0:	f000 face 	bl	1950 <z_arm_int_lib_init>
	z_cstart();
    13b4:	f005 febe 	bl	7134 <z_cstart>
    13b8:	00000000 	.word	0x00000000
    13bc:	e000ed00 	.word	0xe000ed00

000013c0 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    13c0:	b501      	push	{r0, lr}
      * FIXME: Remove the Cortex-M conditional compilation checks for `cpsid i`
      *        and `cpsie i` after the Cortex-R port is updated to support
      *        interrupt nesting.  For more details, refer to the issue #21758.
      */
#if defined(CONFIG_CPU_CORTEX_M)
	cpsid i  /* PRIMASK = 1 */
    13c2:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    13c4:	4a0b      	ldr	r2, [pc, #44]	; (13f4 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    13c6:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
    13c8:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    13ca:	bf1e      	ittt	ne
	movne	r1, #0
    13cc:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    13ce:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
    13d0:	f00a fc2d 	blne	bc2e <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    13d4:	b662      	cpsie	i
#endif

#endif /* CONFIG_SYS_POWER_MANAGEMENT */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    13d6:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    13da:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    13de:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 */
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldr r1, =_sw_isr_table
    13e2:	4905      	ldr	r1, [pc, #20]	; (13f8 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    13e4:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    13e6:	c909      	ldmia	r1!, {r0, r3}
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldm sp!,{r0-r3} /* Restore r0 to r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
    13e8:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    13ea:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    13ee:	4903      	ldr	r1, [pc, #12]	; (13fc <_isr_wrapper+0x3c>)
	bx r1
    13f0:	4708      	bx	r1
    13f2:	0000      	.short	0x0000
	ldr r2, =_kernel
    13f4:	200047c4 	.word	0x200047c4
	ldr r1, =_sw_isr_table
    13f8:	0000bfa0 	.word	0x0000bfa0
	ldr r1, =z_arm_int_exit
    13fc:	00001129 	.word	0x00001129

00001400 <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
    1400:	f007 fcb7 	bl	8d72 <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    1404:	2020      	movs	r0, #32
    msr BASEPRI, r0
    1406:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to _interrupt_stack during initialization.
     */
    ldr r0, =_interrupt_stack
    140a:	4808      	ldr	r0, [pc, #32]	; (142c <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
    140c:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
    1410:	1840      	adds	r0, r0, r1
    msr PSP, r0
    1412:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    1416:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    141a:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    141c:	4308      	orrs	r0, r1
    msr CONTROL, r0
    141e:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    1422:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    1426:	f7ff ffb5 	bl	1394 <z_arm_prep_c>
    142a:	0000      	.short	0x0000
    ldr r0, =_interrupt_stack
    142c:	200093d8 	.word	0x200093d8

00001430 <usage_fault.isra.2>:
 */
static u32_t usage_fault(const z_arch_esf_t *esf)
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
    1430:	2301      	movs	r3, #1
    1432:	f04f 0100 	mov.w	r1, #0
static u32_t usage_fault(const z_arch_esf_t *esf)
    1436:	b510      	push	{r4, lr}
	PR_FAULT_INFO("***** USAGE FAULT *****");
    1438:	f363 0107 	bfi	r1, r3, #0, #8
    143c:	4c33      	ldr	r4, [pc, #204]	; (150c <usage_fault.isra.2+0xdc>)
    143e:	4b34      	ldr	r3, [pc, #208]	; (1510 <usage_fault.isra.2+0xe0>)
    1440:	4834      	ldr	r0, [pc, #208]	; (1514 <usage_fault.isra.2+0xe4>)
    1442:	1ae4      	subs	r4, r4, r3
    1444:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    1448:	f364 118f 	bfi	r1, r4, #6, #10
    144c:	f006 ffa3 	bl	8396 <log_0>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    1450:	4b31      	ldr	r3, [pc, #196]	; (1518 <usage_fault.isra.2+0xe8>)
    1452:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1454:	019a      	lsls	r2, r3, #6
    1456:	d509      	bpl.n	146c <usage_fault.isra.2+0x3c>
		PR_FAULT_INFO("  Division by zero");
    1458:	f04f 0100 	mov.w	r1, #0
    145c:	2301      	movs	r3, #1
    145e:	f363 0107 	bfi	r1, r3, #0, #8
    1462:	f364 118f 	bfi	r1, r4, #6, #10
    1466:	482d      	ldr	r0, [pc, #180]	; (151c <usage_fault.isra.2+0xec>)
    1468:	f006 ff95 	bl	8396 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    146c:	4b2a      	ldr	r3, [pc, #168]	; (1518 <usage_fault.isra.2+0xe8>)
    146e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1470:	01db      	lsls	r3, r3, #7
    1472:	d509      	bpl.n	1488 <usage_fault.isra.2+0x58>
		PR_FAULT_INFO("  Unaligned memory access");
    1474:	f04f 0100 	mov.w	r1, #0
    1478:	2301      	movs	r3, #1
    147a:	f363 0107 	bfi	r1, r3, #0, #8
    147e:	f364 118f 	bfi	r1, r4, #6, #10
    1482:	4827      	ldr	r0, [pc, #156]	; (1520 <usage_fault.isra.2+0xf0>)
    1484:	f006 ff87 	bl	8396 <log_0>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    1488:	4b23      	ldr	r3, [pc, #140]	; (1518 <usage_fault.isra.2+0xe8>)
    148a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    148c:	0318      	lsls	r0, r3, #12
    148e:	d509      	bpl.n	14a4 <usage_fault.isra.2+0x74>
		PR_FAULT_INFO("  No coprocessor instructions");
    1490:	f04f 0100 	mov.w	r1, #0
    1494:	2301      	movs	r3, #1
    1496:	f363 0107 	bfi	r1, r3, #0, #8
    149a:	f364 118f 	bfi	r1, r4, #6, #10
    149e:	4821      	ldr	r0, [pc, #132]	; (1524 <usage_fault.isra.2+0xf4>)
    14a0:	f006 ff79 	bl	8396 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    14a4:	4b1c      	ldr	r3, [pc, #112]	; (1518 <usage_fault.isra.2+0xe8>)
    14a6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    14a8:	0359      	lsls	r1, r3, #13
    14aa:	d509      	bpl.n	14c0 <usage_fault.isra.2+0x90>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
    14ac:	f04f 0100 	mov.w	r1, #0
    14b0:	2301      	movs	r3, #1
    14b2:	f363 0107 	bfi	r1, r3, #0, #8
    14b6:	f364 118f 	bfi	r1, r4, #6, #10
    14ba:	481b      	ldr	r0, [pc, #108]	; (1528 <usage_fault.isra.2+0xf8>)
    14bc:	f006 ff6b 	bl	8396 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    14c0:	4b15      	ldr	r3, [pc, #84]	; (1518 <usage_fault.isra.2+0xe8>)
    14c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    14c4:	039a      	lsls	r2, r3, #14
    14c6:	d509      	bpl.n	14dc <usage_fault.isra.2+0xac>
		PR_FAULT_INFO("  Illegal use of the EPSR");
    14c8:	f04f 0100 	mov.w	r1, #0
    14cc:	2301      	movs	r3, #1
    14ce:	f363 0107 	bfi	r1, r3, #0, #8
    14d2:	f364 118f 	bfi	r1, r4, #6, #10
    14d6:	4815      	ldr	r0, [pc, #84]	; (152c <usage_fault.isra.2+0xfc>)
    14d8:	f006 ff5d 	bl	8396 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    14dc:	4b0e      	ldr	r3, [pc, #56]	; (1518 <usage_fault.isra.2+0xe8>)
    14de:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    14e0:	03db      	lsls	r3, r3, #15
    14e2:	d509      	bpl.n	14f8 <usage_fault.isra.2+0xc8>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
    14e4:	f04f 0100 	mov.w	r1, #0
    14e8:	2301      	movs	r3, #1
    14ea:	f363 0107 	bfi	r1, r3, #0, #8
    14ee:	f364 118f 	bfi	r1, r4, #6, #10
    14f2:	480f      	ldr	r0, [pc, #60]	; (1530 <usage_fault.isra.2+0x100>)
    14f4:	f006 ff4f 	bl	8396 <log_0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    14f8:	4a07      	ldr	r2, [pc, #28]	; (1518 <usage_fault.isra.2+0xe8>)
    14fa:	6a93      	ldr	r3, [r2, #40]	; 0x28
    14fc:	ea6f 4303 	mvn.w	r3, r3, lsl #16
    1500:	ea6f 4313 	mvn.w	r3, r3, lsr #16
    1504:	6293      	str	r3, [r2, #40]	; 0x28

	return reason;
}
    1506:	2000      	movs	r0, #0
    1508:	bd10      	pop	{r4, pc}
    150a:	bf00      	nop
    150c:	0000c1bc 	.word	0x0000c1bc
    1510:	0000c174 	.word	0x0000c174
    1514:	000450ef 	.word	0x000450ef
    1518:	e000ed00 	.word	0xe000ed00
    151c:	00045107 	.word	0x00045107
    1520:	0004511a 	.word	0x0004511a
    1524:	00045134 	.word	0x00045134
    1528:	00045152 	.word	0x00045152
    152c:	00045177 	.word	0x00045177
    1530:	00045191 	.word	0x00045191

00001534 <mem_manage_fault.isra.4>:
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
    1534:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	PR_FAULT_INFO("***** MPU FAULT *****");
    1536:	2301      	movs	r3, #1
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
    1538:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
    153a:	f04f 0100 	mov.w	r1, #0
    153e:	f363 0107 	bfi	r1, r3, #0, #8
    1542:	4c36      	ldr	r4, [pc, #216]	; (161c <mem_manage_fault.isra.4+0xe8>)
    1544:	4b36      	ldr	r3, [pc, #216]	; (1620 <mem_manage_fault.isra.4+0xec>)
    1546:	1ae4      	subs	r4, r4, r3
    1548:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    154c:	f364 118f 	bfi	r1, r4, #6, #10
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
    1550:	4607      	mov	r7, r0
	PR_FAULT_INFO("***** MPU FAULT *****");
    1552:	4834      	ldr	r0, [pc, #208]	; (1624 <mem_manage_fault.isra.4+0xf0>)
    1554:	f006 ff1f 	bl	8396 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    1558:	4b33      	ldr	r3, [pc, #204]	; (1628 <mem_manage_fault.isra.4+0xf4>)
    155a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    155c:	06d9      	lsls	r1, r3, #27
    155e:	d509      	bpl.n	1574 <mem_manage_fault.isra.4+0x40>
		PR_FAULT_INFO("  Stacking error (context area might be"
    1560:	f04f 0100 	mov.w	r1, #0
    1564:	2301      	movs	r3, #1
    1566:	f363 0107 	bfi	r1, r3, #0, #8
    156a:	f364 118f 	bfi	r1, r4, #6, #10
    156e:	482f      	ldr	r0, [pc, #188]	; (162c <mem_manage_fault.isra.4+0xf8>)
    1570:	f006 ff11 	bl	8396 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    1574:	4b2c      	ldr	r3, [pc, #176]	; (1628 <mem_manage_fault.isra.4+0xf4>)
    1576:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1578:	071a      	lsls	r2, r3, #28
    157a:	d509      	bpl.n	1590 <mem_manage_fault.isra.4+0x5c>
		PR_FAULT_INFO("  Unstacking error");
    157c:	f04f 0100 	mov.w	r1, #0
    1580:	2301      	movs	r3, #1
    1582:	f363 0107 	bfi	r1, r3, #0, #8
    1586:	f364 118f 	bfi	r1, r4, #6, #10
    158a:	4829      	ldr	r0, [pc, #164]	; (1630 <mem_manage_fault.isra.4+0xfc>)
    158c:	f006 ff03 	bl	8396 <log_0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    1590:	4d25      	ldr	r5, [pc, #148]	; (1628 <mem_manage_fault.isra.4+0xf4>)
    1592:	6aab      	ldr	r3, [r5, #40]	; 0x28
    1594:	079b      	lsls	r3, r3, #30
    1596:	d51c      	bpl.n	15d2 <mem_manage_fault.isra.4+0x9e>
		PR_FAULT_INFO("  Data Access Violation");
    1598:	2301      	movs	r3, #1
    159a:	f04f 0100 	mov.w	r1, #0
    159e:	f363 0107 	bfi	r1, r3, #0, #8
    15a2:	f364 118f 	bfi	r1, r4, #6, #10
    15a6:	4823      	ldr	r0, [pc, #140]	; (1634 <mem_manage_fault.isra.4+0x100>)
    15a8:	f006 fef5 	bl	8396 <log_0>
		mmfar = SCB->MMFAR;
    15ac:	6b69      	ldr	r1, [r5, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    15ae:	6aab      	ldr	r3, [r5, #40]	; 0x28
    15b0:	0618      	lsls	r0, r3, #24
    15b2:	d50e      	bpl.n	15d2 <mem_manage_fault.isra.4+0x9e>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
    15b4:	f04f 0200 	mov.w	r2, #0
    15b8:	2301      	movs	r3, #1
    15ba:	f363 0207 	bfi	r2, r3, #0, #8
    15be:	f364 128f 	bfi	r2, r4, #6, #10
    15c2:	481d      	ldr	r0, [pc, #116]	; (1638 <mem_manage_fault.isra.4+0x104>)
    15c4:	f006 fef4 	bl	83b0 <log_1>
			if (from_hard_fault) {
    15c8:	b11f      	cbz	r7, 15d2 <mem_manage_fault.isra.4+0x9e>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    15ca:	6aab      	ldr	r3, [r5, #40]	; 0x28
    15cc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    15d0:	62ab      	str	r3, [r5, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    15d2:	4b15      	ldr	r3, [pc, #84]	; (1628 <mem_manage_fault.isra.4+0xf4>)
    15d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    15d6:	07da      	lsls	r2, r3, #31
    15d8:	d509      	bpl.n	15ee <mem_manage_fault.isra.4+0xba>
		PR_FAULT_INFO("  Instruction Access Violation");
    15da:	f04f 0100 	mov.w	r1, #0
    15de:	2301      	movs	r3, #1
    15e0:	f363 0107 	bfi	r1, r3, #0, #8
    15e4:	f364 118f 	bfi	r1, r4, #6, #10
    15e8:	4814      	ldr	r0, [pc, #80]	; (163c <mem_manage_fault.isra.4+0x108>)
    15ea:	f006 fed4 	bl	8396 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    15ee:	4b0e      	ldr	r3, [pc, #56]	; (1628 <mem_manage_fault.isra.4+0xf4>)
    15f0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    15f2:	069b      	lsls	r3, r3, #26
    15f4:	d509      	bpl.n	160a <mem_manage_fault.isra.4+0xd6>
		PR_FAULT_INFO(
    15f6:	f04f 0100 	mov.w	r1, #0
    15fa:	2301      	movs	r3, #1
    15fc:	f363 0107 	bfi	r1, r3, #0, #8
    1600:	f364 118f 	bfi	r1, r4, #6, #10
    1604:	480e      	ldr	r0, [pc, #56]	; (1640 <mem_manage_fault.isra.4+0x10c>)
    1606:	f006 fec6 	bl	8396 <log_0>
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
    160a:	4b07      	ldr	r3, [pc, #28]	; (1628 <mem_manage_fault.isra.4+0xf4>)
    160c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    160e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    1610:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    1612:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
    1616:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    1618:	7030      	strb	r0, [r6, #0]
}
    161a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    161c:	0000c1bc 	.word	0x0000c1bc
    1620:	0000c174 	.word	0x0000c174
    1624:	00045017 	.word	0x00045017
    1628:	e000ed00 	.word	0xe000ed00
    162c:	0004502d 	.word	0x0004502d
    1630:	00045060 	.word	0x00045060
    1634:	00045073 	.word	0x00045073
    1638:	0004508b 	.word	0x0004508b
    163c:	000450a1 	.word	0x000450a1
    1640:	000450c0 	.word	0x000450c0

00001644 <bus_fault.isra.5>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    1644:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	PR_FAULT_INFO("***** BUS FAULT *****");
    1646:	2301      	movs	r3, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    1648:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
    164a:	f04f 0100 	mov.w	r1, #0
    164e:	f363 0107 	bfi	r1, r3, #0, #8
    1652:	4c3c      	ldr	r4, [pc, #240]	; (1744 <bus_fault.isra.5+0x100>)
    1654:	4b3c      	ldr	r3, [pc, #240]	; (1748 <bus_fault.isra.5+0x104>)
    1656:	1ae4      	subs	r4, r4, r3
    1658:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    165c:	f364 118f 	bfi	r1, r4, #6, #10
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    1660:	4607      	mov	r7, r0
	PR_FAULT_INFO("***** BUS FAULT *****");
    1662:	483a      	ldr	r0, [pc, #232]	; (174c <bus_fault.isra.5+0x108>)
    1664:	f006 fe97 	bl	8396 <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    1668:	4b39      	ldr	r3, [pc, #228]	; (1750 <bus_fault.isra.5+0x10c>)
    166a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    166c:	04d9      	lsls	r1, r3, #19
    166e:	d509      	bpl.n	1684 <bus_fault.isra.5+0x40>
		PR_FAULT_INFO("  Stacking error");
    1670:	f04f 0100 	mov.w	r1, #0
    1674:	2301      	movs	r3, #1
    1676:	f363 0107 	bfi	r1, r3, #0, #8
    167a:	f364 118f 	bfi	r1, r4, #6, #10
    167e:	4835      	ldr	r0, [pc, #212]	; (1754 <bus_fault.isra.5+0x110>)
    1680:	f006 fe89 	bl	8396 <log_0>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    1684:	4b32      	ldr	r3, [pc, #200]	; (1750 <bus_fault.isra.5+0x10c>)
    1686:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1688:	051a      	lsls	r2, r3, #20
    168a:	d509      	bpl.n	16a0 <bus_fault.isra.5+0x5c>
		PR_FAULT_INFO("  Unstacking error");
    168c:	f04f 0100 	mov.w	r1, #0
    1690:	2301      	movs	r3, #1
    1692:	f363 0107 	bfi	r1, r3, #0, #8
    1696:	f364 118f 	bfi	r1, r4, #6, #10
    169a:	482f      	ldr	r0, [pc, #188]	; (1758 <bus_fault.isra.5+0x114>)
    169c:	f006 fe7b 	bl	8396 <log_0>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    16a0:	4d2b      	ldr	r5, [pc, #172]	; (1750 <bus_fault.isra.5+0x10c>)
    16a2:	6aab      	ldr	r3, [r5, #40]	; 0x28
    16a4:	059b      	lsls	r3, r3, #22
    16a6:	d51c      	bpl.n	16e2 <bus_fault.isra.5+0x9e>
		PR_FAULT_INFO("  Precise data bus error");
    16a8:	2301      	movs	r3, #1
    16aa:	f04f 0100 	mov.w	r1, #0
    16ae:	f363 0107 	bfi	r1, r3, #0, #8
    16b2:	f364 118f 	bfi	r1, r4, #6, #10
    16b6:	4829      	ldr	r0, [pc, #164]	; (175c <bus_fault.isra.5+0x118>)
    16b8:	f006 fe6d 	bl	8396 <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
    16bc:	6ba9      	ldr	r1, [r5, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    16be:	6aab      	ldr	r3, [r5, #40]	; 0x28
    16c0:	0418      	lsls	r0, r3, #16
    16c2:	d50e      	bpl.n	16e2 <bus_fault.isra.5+0x9e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
    16c4:	f04f 0200 	mov.w	r2, #0
    16c8:	2301      	movs	r3, #1
    16ca:	f363 0207 	bfi	r2, r3, #0, #8
    16ce:	f364 128f 	bfi	r2, r4, #6, #10
    16d2:	4823      	ldr	r0, [pc, #140]	; (1760 <bus_fault.isra.5+0x11c>)
    16d4:	f006 fe6c 	bl	83b0 <log_1>
			if (from_hard_fault) {
    16d8:	b11f      	cbz	r7, 16e2 <bus_fault.isra.5+0x9e>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    16da:	6aab      	ldr	r3, [r5, #40]	; 0x28
    16dc:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    16e0:	62ab      	str	r3, [r5, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    16e2:	4b1b      	ldr	r3, [pc, #108]	; (1750 <bus_fault.isra.5+0x10c>)
    16e4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    16e6:	0559      	lsls	r1, r3, #21
    16e8:	d509      	bpl.n	16fe <bus_fault.isra.5+0xba>
		PR_FAULT_INFO("  Imprecise data bus error");
    16ea:	f04f 0100 	mov.w	r1, #0
    16ee:	2301      	movs	r3, #1
    16f0:	f363 0107 	bfi	r1, r3, #0, #8
    16f4:	f364 118f 	bfi	r1, r4, #6, #10
    16f8:	481a      	ldr	r0, [pc, #104]	; (1764 <bus_fault.isra.5+0x120>)
    16fa:	f006 fe4c 	bl	8396 <log_0>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    16fe:	4b14      	ldr	r3, [pc, #80]	; (1750 <bus_fault.isra.5+0x10c>)
    1700:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    1702:	05d2      	lsls	r2, r2, #23
    1704:	d511      	bpl.n	172a <bus_fault.isra.5+0xe6>
		PR_FAULT_INFO("  Instruction bus error");
    1706:	f04f 0100 	mov.w	r1, #0
    170a:	2301      	movs	r3, #1
    170c:	f363 0107 	bfi	r1, r3, #0, #8
    1710:	4815      	ldr	r0, [pc, #84]	; (1768 <bus_fault.isra.5+0x124>)
    1712:	f364 118f 	bfi	r1, r4, #6, #10
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    1716:	f006 fe3e 	bl	8396 <log_0>
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    171a:	4a0d      	ldr	r2, [pc, #52]	; (1750 <bus_fault.isra.5+0x10c>)
    171c:	6a93      	ldr	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    171e:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    1720:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
    1724:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    1726:	7030      	strb	r0, [r6, #0]
}
    1728:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    172a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    172c:	049b      	lsls	r3, r3, #18
    172e:	d5f4      	bpl.n	171a <bus_fault.isra.5+0xd6>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    1730:	f04f 0100 	mov.w	r1, #0
    1734:	2301      	movs	r3, #1
    1736:	f363 0107 	bfi	r1, r3, #0, #8
    173a:	f364 118f 	bfi	r1, r4, #6, #10
    173e:	480b      	ldr	r0, [pc, #44]	; (176c <bus_fault.isra.5+0x128>)
    1740:	e7e9      	b.n	1716 <bus_fault.isra.5+0xd2>
    1742:	bf00      	nop
    1744:	0000c1bc 	.word	0x0000c1bc
    1748:	0000c174 	.word	0x0000c174
    174c:	00044f8f 	.word	0x00044f8f
    1750:	e000ed00 	.word	0xe000ed00
    1754:	00044fa5 	.word	0x00044fa5
    1758:	00045060 	.word	0x00045060
    175c:	00044fb6 	.word	0x00044fb6
    1760:	00044fcf 	.word	0x00044fcf
    1764:	00044fe4 	.word	0x00044fe4
    1768:	00044fff 	.word	0x00044fff
    176c:	000450c0 	.word	0x000450c0

00001770 <z_arm_fault>:
 * @param psp PSP value immediately after the exception occurred
 * @param exc_return EXC_RETURN value present in LR after exception entry.
 *
 */
void z_arm_fault(u32_t msp, u32_t psp, u32_t exc_return)
{
    1770:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    1774:	4b64      	ldr	r3, [pc, #400]	; (1908 <z_arm_fault+0x198>)
    1776:	685e      	ldr	r6, [r3, #4]
{
    1778:	b08a      	sub	sp, #40	; 0x28
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    177a:	f3c6 0408 	ubfx	r4, r6, #0, #9
    177e:	2500      	movs	r5, #0
    1780:	f385 8811 	msr	BASEPRI, r5
    1784:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    1788:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
    178c:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
    1790:	d111      	bne.n	17b6 <z_arm_fault+0x46>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    1792:	f002 030c 	and.w	r3, r2, #12
    1796:	2b08      	cmp	r3, #8
    1798:	d10f      	bne.n	17ba <z_arm_fault+0x4a>
		PR_EXC("SPSEL in thread mode does not indicate PSP");
    179a:	2301      	movs	r3, #1
    179c:	f04f 0100 	mov.w	r1, #0
    17a0:	f363 0107 	bfi	r1, r3, #0, #8
    17a4:	4a59      	ldr	r2, [pc, #356]	; (190c <z_arm_fault+0x19c>)
    17a6:	4b5a      	ldr	r3, [pc, #360]	; (1910 <z_arm_fault+0x1a0>)
    17a8:	485a      	ldr	r0, [pc, #360]	; (1914 <z_arm_fault+0x1a4>)
    17aa:	1a9b      	subs	r3, r3, r2
    17ac:	08db      	lsrs	r3, r3, #3
    17ae:	f363 118f 	bfi	r1, r3, #6, #10
    17b2:	f006 fdf0 	bl	8396 <log_0>
		return NULL;
    17b6:	462f      	mov	r7, r5
    17b8:	e004      	b.n	17c4 <z_arm_fault+0x54>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    17ba:	0712      	lsls	r2, r2, #28
			ptr_esf =  (z_arch_esf_t *)psp;
    17bc:	bf4e      	itee	mi
    17be:	460f      	movmi	r7, r1
			ptr_esf = (z_arch_esf_t *)msp;
    17c0:	4607      	movpl	r7, r0
			*nested_exc = true;
    17c2:	2501      	movpl	r5, #1
	*recoverable = false;
    17c4:	2300      	movs	r3, #0
    17c6:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
    17ca:	1ee3      	subs	r3, r4, #3
    17cc:	2b09      	cmp	r3, #9
    17ce:	d87f      	bhi.n	18d0 <z_arm_fault+0x160>
    17d0:	e8df f003 	tbb	[pc, r3]
    17d4:	4c6d6905 	.word	0x4c6d6905
    17d8:	7e7e7e7e 	.word	0x7e7e7e7e
    17dc:	717e      	.short	0x717e
	PR_FAULT_INFO("***** HARD FAULT *****");
    17de:	2301      	movs	r3, #1
    17e0:	f04f 0100 	mov.w	r1, #0
    17e4:	f363 0107 	bfi	r1, r3, #0, #8
    17e8:	4e49      	ldr	r6, [pc, #292]	; (1910 <z_arm_fault+0x1a0>)
    17ea:	4b48      	ldr	r3, [pc, #288]	; (190c <z_arm_fault+0x19c>)
    17ec:	484a      	ldr	r0, [pc, #296]	; (1918 <z_arm_fault+0x1a8>)
    17ee:	1af6      	subs	r6, r6, r3
    17f0:	f3c6 06c9 	ubfx	r6, r6, #3, #10
    17f4:	f366 118f 	bfi	r1, r6, #6, #10
    17f8:	f006 fdcd 	bl	8396 <log_0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    17fc:	4b42      	ldr	r3, [pc, #264]	; (1908 <z_arm_fault+0x198>)
    17fe:	6adc      	ldr	r4, [r3, #44]	; 0x2c
	*recoverable = false;
    1800:	f04f 0800 	mov.w	r8, #0
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    1804:	f014 0402 	ands.w	r4, r4, #2
	*recoverable = false;
    1808:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    180c:	d00b      	beq.n	1826 <z_arm_fault+0xb6>
		PR_EXC("  Bus fault on vector table read");
    180e:	f04f 0100 	mov.w	r1, #0
    1812:	2301      	movs	r3, #1
    1814:	f363 0107 	bfi	r1, r3, #0, #8
    1818:	4840      	ldr	r0, [pc, #256]	; (191c <z_arm_fault+0x1ac>)
    181a:	f366 118f 	bfi	r1, r6, #6, #10
	PR_FAULT_INFO(
    181e:	f006 fdba 	bl	8396 <log_0>
	u32_t reason = K_ERR_CPU_EXCEPTION;
    1822:	2400      	movs	r4, #0
    1824:	e025      	b.n	1872 <z_arm_fault+0x102>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    1826:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1828:	005b      	lsls	r3, r3, #1
    182a:	d522      	bpl.n	1872 <z_arm_fault+0x102>
		PR_EXC("  Fault escalation (see below)");
    182c:	2301      	movs	r3, #1
    182e:	f04f 0100 	mov.w	r1, #0
    1832:	f363 0107 	bfi	r1, r3, #0, #8
    1836:	f366 118f 	bfi	r1, r6, #6, #10
    183a:	4839      	ldr	r0, [pc, #228]	; (1920 <z_arm_fault+0x1b0>)
    183c:	f006 fdab 	bl	8396 <log_0>
		if (SCB_MMFSR != 0) {
    1840:	4b38      	ldr	r3, [pc, #224]	; (1924 <z_arm_fault+0x1b4>)
    1842:	781b      	ldrb	r3, [r3, #0]
    1844:	b12b      	cbz	r3, 1852 <z_arm_fault+0xe2>
			reason = mem_manage_fault(esf, 1, recoverable);
    1846:	f10d 0107 	add.w	r1, sp, #7
    184a:	2001      	movs	r0, #1
		reason = mem_manage_fault(esf, 0, recoverable);
    184c:	f7ff fe72 	bl	1534 <mem_manage_fault.isra.4>
    1850:	e00e      	b.n	1870 <z_arm_fault+0x100>
		} else if (SCB_BFSR != 0) {
    1852:	4b35      	ldr	r3, [pc, #212]	; (1928 <z_arm_fault+0x1b8>)
    1854:	781b      	ldrb	r3, [r3, #0]
    1856:	b12b      	cbz	r3, 1864 <z_arm_fault+0xf4>
			reason = bus_fault(esf, 1, recoverable);
    1858:	f10d 0107 	add.w	r1, sp, #7
    185c:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
    185e:	f7ff fef1 	bl	1644 <bus_fault.isra.5>
    1862:	e005      	b.n	1870 <z_arm_fault+0x100>
		} else if (SCB_UFSR != 0) {
    1864:	4b31      	ldr	r3, [pc, #196]	; (192c <z_arm_fault+0x1bc>)
    1866:	881b      	ldrh	r3, [r3, #0]
    1868:	b29b      	uxth	r3, r3
    186a:	b113      	cbz	r3, 1872 <z_arm_fault+0x102>
			reason = usage_fault(esf);
    186c:	f7ff fde0 	bl	1430 <usage_fault.isra.2>
    1870:	4604      	mov	r4, r0
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
		"ESF could not be retrieved successfully. Shall never occur.");

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
    1872:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1876:	b99b      	cbnz	r3, 18a0 <z_arm_fault+0x130>
		return;
	}

	/* Copy ESF */
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    1878:	2220      	movs	r2, #32
    187a:	4639      	mov	r1, r7
    187c:	a802      	add	r0, sp, #8
    187e:	f007 f837 	bl	88f0 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    1882:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1884:	2d00      	cmp	r5, #0
    1886:	d03a      	beq.n	18fe <z_arm_fault+0x18e>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    1888:	f3c3 0208 	ubfx	r2, r3, #0, #9
    188c:	b922      	cbnz	r2, 1898 <z_arm_fault+0x128>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    188e:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    1892:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    1896:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
    1898:	a902      	add	r1, sp, #8
    189a:	4620      	mov	r0, r4
    189c:	f7ff fd24 	bl	12e8 <z_arm_fatal_error>
}
    18a0:	b00a      	add	sp, #40	; 0x28
    18a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
    18a6:	f10d 0107 	add.w	r1, sp, #7
    18aa:	2000      	movs	r0, #0
    18ac:	e7ce      	b.n	184c <z_arm_fault+0xdc>
		reason = bus_fault(esf, 0, recoverable);
    18ae:	f10d 0107 	add.w	r1, sp, #7
    18b2:	2000      	movs	r0, #0
    18b4:	e7d3      	b.n	185e <z_arm_fault+0xee>
	PR_FAULT_INFO(
    18b6:	2301      	movs	r3, #1
    18b8:	f04f 0100 	mov.w	r1, #0
    18bc:	f363 0107 	bfi	r1, r3, #0, #8
    18c0:	4a12      	ldr	r2, [pc, #72]	; (190c <z_arm_fault+0x19c>)
    18c2:	4b13      	ldr	r3, [pc, #76]	; (1910 <z_arm_fault+0x1a0>)
    18c4:	481a      	ldr	r0, [pc, #104]	; (1930 <z_arm_fault+0x1c0>)
    18c6:	1a9b      	subs	r3, r3, r2
    18c8:	08db      	lsrs	r3, r3, #3
    18ca:	f363 118f 	bfi	r1, r3, #6, #10
    18ce:	e7a6      	b.n	181e <z_arm_fault+0xae>
	PR_FAULT_INFO("***** %s %d) *****",
    18d0:	2201      	movs	r2, #1
    18d2:	f04f 0300 	mov.w	r3, #0
    18d6:	f362 0307 	bfi	r3, r2, #0, #8
    18da:	490d      	ldr	r1, [pc, #52]	; (1910 <z_arm_fault+0x1a0>)
    18dc:	4a0b      	ldr	r2, [pc, #44]	; (190c <z_arm_fault+0x19c>)
    18de:	4815      	ldr	r0, [pc, #84]	; (1934 <z_arm_fault+0x1c4>)
    18e0:	1a89      	subs	r1, r1, r2
    18e2:	08c9      	lsrs	r1, r1, #3
    18e4:	f416 7ff8 	tst.w	r6, #496	; 0x1f0
    18e8:	f361 138f 	bfi	r3, r1, #6, #10
    18ec:	f1a4 0210 	sub.w	r2, r4, #16
    18f0:	4911      	ldr	r1, [pc, #68]	; (1938 <z_arm_fault+0x1c8>)
    18f2:	bf18      	it	ne
    18f4:	4601      	movne	r1, r0
    18f6:	4811      	ldr	r0, [pc, #68]	; (193c <z_arm_fault+0x1cc>)
    18f8:	f006 fd6e 	bl	83d8 <log_2>
    18fc:	e791      	b.n	1822 <z_arm_fault+0xb2>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    18fe:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    1902:	f023 0301 	bic.w	r3, r3, #1
    1906:	e7c6      	b.n	1896 <z_arm_fault+0x126>
    1908:	e000ed00 	.word	0xe000ed00
    190c:	0000c174 	.word	0x0000c174
    1910:	0000c1bc 	.word	0x0000c1bc
    1914:	000451bc 	.word	0x000451bc
    1918:	000451e7 	.word	0x000451e7
    191c:	000451fe 	.word	0x000451fe
    1920:	0004521f 	.word	0x0004521f
    1924:	e000ed28 	.word	0xe000ed28
    1928:	e000ed29 	.word	0xe000ed29
    192c:	e000ed2a 	.word	0xe000ed2a
    1930:	0004523e 	.word	0x0004523e
    1934:	00045289 	.word	0x00045289
    1938:	00045274 	.word	0x00045274
    193c:	000452a2 	.word	0x000452a2

00001940 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    1940:	4a02      	ldr	r2, [pc, #8]	; (194c <z_arm_fault_init+0xc>)
    1942:	6953      	ldr	r3, [r2, #20]
    1944:	f043 0310 	orr.w	r3, r3, #16
    1948:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    194a:	4770      	bx	lr
    194c:	e000ed00 	.word	0xe000ed00

00001950 <z_arm_int_lib_init>:
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    1950:	4804      	ldr	r0, [pc, #16]	; (1964 <z_arm_int_lib_init+0x14>)
 * @return N/A
 */

void z_arm_int_lib_init(void)
{
	int irq = 0;
    1952:	2300      	movs	r3, #0
    1954:	2120      	movs	r1, #32
    1956:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    1958:	3301      	adds	r3, #1
    195a:	2b27      	cmp	r3, #39	; 0x27
    195c:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    1960:	d1f9      	bne.n	1956 <z_arm_int_lib_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    1962:	4770      	bx	lr
    1964:	e000e100 	.word	0xe000e100

00001968 <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
    1968:	b538      	push	{r3, r4, r5, lr}
    196a:	4605      	mov	r5, r0
	__asm__ volatile(
    196c:	f04f 0320 	mov.w	r3, #32
    1970:	f3ef 8411 	mrs	r4, BASEPRI
    1974:	f383 8811 	msr	BASEPRI, r3
    1978:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
		 "essential thread aborted");

	z_thread_single_abort(thread);
    197c:	f005 fef2 	bl	7764 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
    1980:	4b0a      	ldr	r3, [pc, #40]	; (19ac <z_impl_k_thread_abort+0x44>)
    1982:	689b      	ldr	r3, [r3, #8]
    1984:	42ab      	cmp	r3, r5
    1986:	d10b      	bne.n	19a0 <z_impl_k_thread_abort+0x38>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
    1988:	4b09      	ldr	r3, [pc, #36]	; (19b0 <z_impl_k_thread_abort+0x48>)
    198a:	685a      	ldr	r2, [r3, #4]
    198c:	f3c2 0208 	ubfx	r2, r2, #0, #9
    1990:	b912      	cbnz	r2, 1998 <z_impl_k_thread_abort+0x30>
	int ret;
	z_check_stack_sentinel();
#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
    1992:	4620      	mov	r0, r4
    1994:	f7ff fbd6 	bl	1144 <arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    1998:	685a      	ldr	r2, [r3, #4]
    199a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    199e:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
    19a0:	4620      	mov	r0, r4
}
    19a2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
    19a6:	f00a b9ac 	b.w	bd02 <z_reschedule_irqlock>
    19aa:	bf00      	nop
    19ac:	200047c4 	.word	0x200047c4
    19b0:	e000ed00 	.word	0xe000ed00

000019b4 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    19b4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
    19b6:	4b08      	ldr	r3, [pc, #32]	; (19d8 <z_arm_configure_static_mpu_regions+0x24>)
    19b8:	9301      	str	r3, [sp, #4]
    19ba:	4b08      	ldr	r3, [pc, #32]	; (19dc <z_arm_configure_static_mpu_regions+0x28>)
    19bc:	9302      	str	r3, [sp, #8]
    19be:	4b08      	ldr	r3, [pc, #32]	; (19e0 <z_arm_configure_static_mpu_regions+0x2c>)
    19c0:	9303      	str	r3, [sp, #12]

	/* Define a constant array of k_mem_partition objects
	 * to hold the configuration of the respective static
	 * MPU regions.
	 */
	const struct k_mem_partition *static_regions[] = {
    19c2:	ab01      	add	r3, sp, #4
    19c4:	9300      	str	r3, [sp, #0]
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    19c6:	4a07      	ldr	r2, [pc, #28]	; (19e4 <z_arm_configure_static_mpu_regions+0x30>)
    19c8:	4b07      	ldr	r3, [pc, #28]	; (19e8 <z_arm_configure_static_mpu_regions+0x34>)
    19ca:	2101      	movs	r1, #1
    19cc:	4668      	mov	r0, sp
    19ce:	f000 f8b5 	bl	1b3c <arm_core_mpu_configure_static_mpu_regions>
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    19d2:	b005      	add	sp, #20
    19d4:	f85d fb04 	ldr.w	pc, [sp], #4
    19d8:	20000000 	.word	0x20000000
    19dc:	00000000 	.word	0x00000000
    19e0:	060b0000 	.word	0x060b0000
    19e4:	20000000 	.word	0x20000000
    19e8:	20010000 	.word	0x20010000

000019ec <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct k_mem_partition
	*regions[], u8_t regions_num, u8_t start_reg_index,
	bool do_sanity_check)
{
    19ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Select the region you want to access */
	MPU->RNR = index;
    19ee:	4f2e      	ldr	r7, [pc, #184]	; (1aa8 <mpu_configure_regions+0xbc>)
    19f0:	460e      	mov	r6, r1
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
    19f2:	2100      	movs	r1, #0
    19f4:	42b1      	cmp	r1, r6
    19f6:	da22      	bge.n	1a3e <mpu_configure_regions+0x52>
		if (regions[i]->size == 0U) {
    19f8:	f850 c021 	ldr.w	ip, [r0, r1, lsl #2]
    19fc:	f8dc 4004 	ldr.w	r4, [ip, #4]
    1a00:	2c00      	cmp	r4, #0
    1a02:	d04f      	beq.n	1aa4 <mpu_configure_regions+0xb8>
			continue;
		}
		/* Non-empty region. */

		if (do_sanity_check &&
    1a04:	b1eb      	cbz	r3, 1a42 <mpu_configure_regions+0x56>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1)) == 0U)
    1a06:	f104 3eff 	add.w	lr, r4, #4294967295	; 0xffffffff
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
    1a0a:	ea14 0f0e 	tst.w	r4, lr
    1a0e:	d106      	bne.n	1a1e <mpu_configure_regions+0x32>
		&&
    1a10:	2c1f      	cmp	r4, #31
    1a12:	d904      	bls.n	1a1e <mpu_configure_regions+0x32>
		((part->start & (part->size - 1)) == 0U);
    1a14:	f8dc 5000 	ldr.w	r5, [ip]
		&&
    1a18:	ea1e 0f05 	tst.w	lr, r5
    1a1c:	d011      	beq.n	1a42 <mpu_configure_regions+0x56>
				(!mpu_partition_is_valid(regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
    1a1e:	2301      	movs	r3, #1
    1a20:	f04f 0200 	mov.w	r2, #0
    1a24:	f363 0207 	bfi	r2, r3, #0, #8
    1a28:	4820      	ldr	r0, [pc, #128]	; (1aac <mpu_configure_regions+0xc0>)
    1a2a:	4b21      	ldr	r3, [pc, #132]	; (1ab0 <mpu_configure_regions+0xc4>)
    1a2c:	1a1b      	subs	r3, r3, r0
    1a2e:	08db      	lsrs	r3, r3, #3
    1a30:	4820      	ldr	r0, [pc, #128]	; (1ab4 <mpu_configure_regions+0xc8>)
    1a32:	f363 128f 	bfi	r2, r3, #6, #10
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    1a36:	f006 fcbb 	bl	83b0 <log_1>
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, regions[i]);
    1a3a:	f06f 0215 	mvn.w	r2, #21
		/* Increment number of programmed MPU indices. */
		reg_index++;
	}

	return reg_index;
}
    1a3e:	4610      	mov	r0, r2
    1a40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * to that power-of-two value.
 */
static inline u32_t size_to_mpu_rasr_size(u32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
    1a42:	2c20      	cmp	r4, #32
		reg_index = mpu_configure_region(reg_index, regions[i]);
    1a44:	b2d5      	uxtb	r5, r2
	region_conf.base = new_region->start;
    1a46:	f8dc 2000 	ldr.w	r2, [ip]
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
    1a4a:	f8dc c008 	ldr.w	ip, [ip, #8]
    1a4e:	d91a      	bls.n	1a86 <mpu_configure_regions+0x9a>
	/*
	 * A size value greater than 2^31 could not be handled by
	 * round_up_to_next_power_of_two() properly. We handle
	 * it separately here.
	 */
	if (size > (1UL << 31)) {
    1a50:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
    1a54:	d819      	bhi.n	1a8a <mpu_configure_regions+0x9e>
		return REGION_4G;
	}

	return ((32 - __builtin_clz(size - 1) - 2 + 1) << MPU_RASR_SIZE_Pos) &
    1a56:	3c01      	subs	r4, #1
    1a58:	fab4 f484 	clz	r4, r4
    1a5c:	f1c4 041f 	rsb	r4, r4, #31
    1a60:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1)) {
    1a62:	2d07      	cmp	r5, #7
	/* in ARMv7-M MPU the base address is not required
	 * to determine region attributes
	 */
	(void) base;

	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    1a64:	ea4c 0404 	orr.w	r4, ip, r4
    1a68:	d911      	bls.n	1a8e <mpu_configure_regions+0xa2>
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    1a6a:	2301      	movs	r3, #1
    1a6c:	f04f 0200 	mov.w	r2, #0
    1a70:	f363 0207 	bfi	r2, r3, #0, #8
    1a74:	490d      	ldr	r1, [pc, #52]	; (1aac <mpu_configure_regions+0xc0>)
    1a76:	4b0e      	ldr	r3, [pc, #56]	; (1ab0 <mpu_configure_regions+0xc4>)
    1a78:	480f      	ldr	r0, [pc, #60]	; (1ab8 <mpu_configure_regions+0xcc>)
    1a7a:	1a5b      	subs	r3, r3, r1
    1a7c:	08db      	lsrs	r3, r3, #3
    1a7e:	f363 128f 	bfi	r2, r3, #6, #10
    1a82:	4629      	mov	r1, r5
    1a84:	e7d7      	b.n	1a36 <mpu_configure_regions+0x4a>
		return REGION_32B;
    1a86:	2408      	movs	r4, #8
    1a88:	e7eb      	b.n	1a62 <mpu_configure_regions+0x76>
		return REGION_4G;
    1a8a:	243e      	movs	r4, #62	; 0x3e
    1a8c:	e7e9      	b.n	1a62 <mpu_configure_regions+0x76>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    1a8e:	f022 021f 	bic.w	r2, r2, #31
				| MPU_RBAR_VALID_Msk | index;
    1a92:	432a      	orrs	r2, r5
    1a94:	f042 0210 	orr.w	r2, r2, #16
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    1a98:	f044 0401 	orr.w	r4, r4, #1
	MPU->RNR = index;
    1a9c:	60bd      	str	r5, [r7, #8]
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    1a9e:	60fa      	str	r2, [r7, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    1aa0:	613c      	str	r4, [r7, #16]
		reg_index++;
    1aa2:	1c6a      	adds	r2, r5, #1
	for (i = 0; i < regions_num; i++) {
    1aa4:	3101      	adds	r1, #1
    1aa6:	e7a5      	b.n	19f4 <mpu_configure_regions+0x8>
    1aa8:	e000ed90 	.word	0xe000ed90
    1aac:	0000c174 	.word	0x0000c174
    1ab0:	0000c1b4 	.word	0x0000c1b4
    1ab4:	000452b9 	.word	0x000452b9
    1ab8:	000452dc 	.word	0x000452dc

00001abc <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    1abc:	4b03      	ldr	r3, [pc, #12]	; (1acc <arm_core_mpu_enable+0x10>)
    1abe:	2205      	movs	r2, #5
    1ac0:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    1ac2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    1ac6:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    1aca:	4770      	bx	lr
    1acc:	e000ed90 	.word	0xe000ed90

00001ad0 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    1ad0:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    1ad4:	4b01      	ldr	r3, [pc, #4]	; (1adc <arm_core_mpu_disable+0xc>)
    1ad6:	2200      	movs	r2, #0
    1ad8:	605a      	str	r2, [r3, #4]
}
    1ada:	4770      	bx	lr
    1adc:	e000ed90 	.word	0xe000ed90

00001ae0 <arm_mpu_init>:
 */
static int arm_mpu_init(struct device *arg)
{
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    1ae0:	4913      	ldr	r1, [pc, #76]	; (1b30 <arm_mpu_init+0x50>)
    1ae2:	6808      	ldr	r0, [r1, #0]
    1ae4:	2808      	cmp	r0, #8
{
    1ae6:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
    1ae8:	d81e      	bhi.n	1b28 <arm_mpu_init+0x48>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    1aea:	f7ff fff1 	bl	1ad0 <arm_core_mpu_disable>
	MPU->RNR = index;
    1aee:	4c11      	ldr	r4, [pc, #68]	; (1b34 <arm_mpu_init+0x54>)
    1af0:	6849      	ldr	r1, [r1, #4]

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    1af2:	2200      	movs	r2, #0
    1af4:	4290      	cmp	r0, r2
    1af6:	f101 010c 	add.w	r1, r1, #12
    1afa:	d105      	bne.n	1b08 <arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    1afc:	4b0e      	ldr	r3, [pc, #56]	; (1b38 <arm_mpu_init+0x58>)
    1afe:	7018      	strb	r0, [r3, #0]


	arm_core_mpu_enable();
    1b00:	f7ff ffdc 	bl	1abc <arm_core_mpu_enable>
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		DT_NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
    1b04:	2000      	movs	r0, #0
}
    1b06:	bd10      	pop	{r4, pc}
    1b08:	60a2      	str	r2, [r4, #8]
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    1b0a:	f851 3c0c 	ldr.w	r3, [r1, #-12]
    1b0e:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
    1b12:	4313      	orrs	r3, r2
    1b14:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    1b18:	60e3      	str	r3, [r4, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    1b1a:	f851 3c04 	ldr.w	r3, [r1, #-4]
    1b1e:	f043 0301 	orr.w	r3, r3, #1
    1b22:	6123      	str	r3, [r4, #16]
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    1b24:	3201      	adds	r2, #1
    1b26:	e7e5      	b.n	1af4 <arm_mpu_init+0x14>
		return -1;
    1b28:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1b2c:	e7eb      	b.n	1b06 <arm_mpu_init+0x26>
    1b2e:	bf00      	nop
    1b30:	0000c270 	.word	0x0000c270
    1b34:	e000ed90 	.word	0xe000ed90
    1b38:	20004808 	.word	0x20004808

00001b3c <arm_core_mpu_configure_static_mpu_regions>:
{
    1b3c:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    1b3e:	4c03      	ldr	r4, [pc, #12]	; (1b4c <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    1b40:	2301      	movs	r3, #1
    1b42:	7822      	ldrb	r2, [r4, #0]
    1b44:	f7ff ff52 	bl	19ec <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    1b48:	7020      	strb	r0, [r4, #0]
}
    1b4a:	bd10      	pop	{r4, pc}
    1b4c:	20004808 	.word	0x20004808

00001b50 <arm_core_mpu_configure_dynamic_mpu_regions>:
{
    1b50:	b508      	push	{r3, lr}

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
    1b52:	4a08      	ldr	r2, [pc, #32]	; (1b74 <arm_core_mpu_configure_dynamic_mpu_regions+0x24>)
    1b54:	2300      	movs	r3, #0
    1b56:	7812      	ldrb	r2, [r2, #0]
    1b58:	f7ff ff48 	bl	19ec <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
    1b5c:	f110 0f16 	cmn.w	r0, #22
    1b60:	d003      	beq.n	1b6a <arm_core_mpu_configure_dynamic_mpu_regions+0x1a>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
    1b62:	4b05      	ldr	r3, [pc, #20]	; (1b78 <arm_core_mpu_configure_dynamic_mpu_regions+0x28>)
  MPU->RASR = 0U;
    1b64:	2200      	movs	r2, #0

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    1b66:	2807      	cmp	r0, #7
    1b68:	dd00      	ble.n	1b6c <arm_core_mpu_configure_dynamic_mpu_regions+0x1c>
}
    1b6a:	bd08      	pop	{r3, pc}
  MPU->RNR = rnr;
    1b6c:	6098      	str	r0, [r3, #8]
  MPU->RASR = 0U;
    1b6e:	611a      	str	r2, [r3, #16]
    1b70:	3001      	adds	r0, #1
    1b72:	e7f8      	b.n	1b66 <arm_core_mpu_configure_dynamic_mpu_regions+0x16>
    1b74:	20004808 	.word	0x20004808
    1b78:	e000ed90 	.word	0xe000ed90

00001b7c <z_prf>:
	*sptr = p;
	return i;
}

int z_prf(int (*func)(), void *dest, const char *format, va_list vargs)
{
    1b7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1b80:	b09f      	sub	sp, #124	; 0x7c
    1b82:	461e      	mov	r6, r3
	struct zero_padding zero;
	VALTYPE val;

#define PUTC(c)	do { if ((*func)(c, dest) == EOF) return EOF; } while (false)

	count = 0;
    1b84:	2300      	movs	r3, #0
{
    1b86:	9001      	str	r0, [sp, #4]
    1b88:	9104      	str	r1, [sp, #16]
	count = 0;
    1b8a:	9300      	str	r3, [sp, #0]

	while ((c = *format++)) {
    1b8c:	4613      	mov	r3, r2
    1b8e:	f813 0b01 	ldrb.w	r0, [r3], #1
    1b92:	9305      	str	r3, [sp, #20]
    1b94:	b158      	cbz	r0, 1bae <z_prf+0x32>
		if (c != '%') {
    1b96:	2825      	cmp	r0, #37	; 0x25
    1b98:	f000 8085 	beq.w	1ca6 <z_prf+0x12a>
			PUTC(c);
    1b9c:	9904      	ldr	r1, [sp, #16]
    1b9e:	9b01      	ldr	r3, [sp, #4]
    1ba0:	4798      	blx	r3
    1ba2:	3001      	adds	r0, #1
    1ba4:	f040 840d 	bne.w	23c2 <z_prf+0x846>
    1ba8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1bac:	9300      	str	r3, [sp, #0]
		}
	}
	return count;

#undef PUTC
}
    1bae:	9800      	ldr	r0, [sp, #0]
    1bb0:	b01f      	add	sp, #124	; 0x7c
    1bb2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				switch (c) {
    1bb6:	2c23      	cmp	r4, #35	; 0x23
    1bb8:	d06c      	beq.n	1c94 <z_prf+0x118>
    1bba:	d861      	bhi.n	1c80 <z_prf+0x104>
    1bbc:	2c00      	cmp	r4, #0
    1bbe:	d0f6      	beq.n	1bae <z_prf+0x32>
					fspace = true;
    1bc0:	2c20      	cmp	r4, #32
    1bc2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1bc4:	bf08      	it	eq
    1bc6:	2301      	moveq	r3, #1
    1bc8:	930a      	str	r3, [sp, #40]	; 0x28
					fminus = true;
    1bca:	f8cd 8014 	str.w	r8, [sp, #20]
			while (strchr("-+ #0", (c = *format++)) != NULL) {
    1bce:	f8dd 8014 	ldr.w	r8, [sp, #20]
    1bd2:	48b9      	ldr	r0, [pc, #740]	; (1eb8 <z_prf+0x33c>)
    1bd4:	f818 4b01 	ldrb.w	r4, [r8], #1
    1bd8:	4621      	mov	r1, r4
    1bda:	f006 fe68 	bl	88ae <strchr>
    1bde:	2800      	cmp	r0, #0
    1be0:	d1e9      	bne.n	1bb6 <z_prf+0x3a>
			if (c == '*') {
    1be2:	2c2a      	cmp	r4, #42	; 0x2a
    1be4:	d166      	bne.n	1cb4 <z_prf+0x138>
				width = va_arg(vargs, int);
    1be6:	f856 3b04 	ldr.w	r3, [r6], #4
    1bea:	9307      	str	r3, [sp, #28]
				if (width < 0) {
    1bec:	2b00      	cmp	r3, #0
					width = -width;
    1bee:	bfbf      	itttt	lt
    1bf0:	425b      	neglt	r3, r3
    1bf2:	9307      	strlt	r3, [sp, #28]
					fminus = true;
    1bf4:	2301      	movlt	r3, #1
    1bf6:	930b      	strlt	r3, [sp, #44]	; 0x2c
				c = *format++;
    1bf8:	9b05      	ldr	r3, [sp, #20]
    1bfa:	f898 4000 	ldrb.w	r4, [r8]
    1bfe:	f103 0802 	add.w	r8, r3, #2
			if (c == '.') {
    1c02:	2c2e      	cmp	r4, #46	; 0x2e
    1c04:	d17c      	bne.n	1d00 <z_prf+0x184>
				if (c == '*') {
    1c06:	f898 3000 	ldrb.w	r3, [r8]
    1c0a:	2b2a      	cmp	r3, #42	; 0x2a
    1c0c:	d175      	bne.n	1cfa <z_prf+0x17e>
					precision = va_arg(vargs, int);
    1c0e:	f856 5b04 	ldr.w	r5, [r6], #4
				c = *format++;
    1c12:	f108 0801 	add.w	r8, r8, #1
				c = *format++;
    1c16:	f818 4b01 	ldrb.w	r4, [r8], #1
			if (strchr("hlz", c) != NULL) {
    1c1a:	48a8      	ldr	r0, [pc, #672]	; (1ebc <z_prf+0x340>)
    1c1c:	4621      	mov	r1, r4
    1c1e:	4627      	mov	r7, r4
    1c20:	f006 fe45 	bl	88ae <strchr>
    1c24:	2800      	cmp	r0, #0
    1c26:	d06e      	beq.n	1d06 <z_prf+0x18a>
				c = *format++;
    1c28:	4643      	mov	r3, r8
				} else if (i == 'h' && c == 'h') {
    1c2a:	2f68      	cmp	r7, #104	; 0x68
				c = *format++;
    1c2c:	f813 4b01 	ldrb.w	r4, [r3], #1
    1c30:	9305      	str	r3, [sp, #20]
				} else if (i == 'h' && c == 'h') {
    1c32:	d107      	bne.n	1c44 <z_prf+0xc8>
    1c34:	2c68      	cmp	r4, #104	; 0x68
    1c36:	d105      	bne.n	1c44 <z_prf+0xc8>
					c = *format++;
    1c38:	f108 0302 	add.w	r3, r8, #2
    1c3c:	f898 4001 	ldrb.w	r4, [r8, #1]
    1c40:	9305      	str	r3, [sp, #20]
					i = 'H';
    1c42:	2748      	movs	r7, #72	; 0x48
			switch (c) {
    1c44:	2c67      	cmp	r4, #103	; 0x67
    1c46:	d87c      	bhi.n	1d42 <z_prf+0x1c6>
    1c48:	2c65      	cmp	r4, #101	; 0x65
    1c4a:	f080 8139 	bcs.w	1ec0 <z_prf+0x344>
    1c4e:	2c47      	cmp	r4, #71	; 0x47
    1c50:	d85d      	bhi.n	1d0e <z_prf+0x192>
    1c52:	2c45      	cmp	r4, #69	; 0x45
    1c54:	f080 8134 	bcs.w	1ec0 <z_prf+0x344>
    1c58:	2c00      	cmp	r4, #0
    1c5a:	d0a8      	beq.n	1bae <z_prf+0x32>
    1c5c:	2c25      	cmp	r4, #37	; 0x25
    1c5e:	f000 83ac 	beq.w	23ba <z_prf+0x83e>
				PUTC('%');
    1c62:	9904      	ldr	r1, [sp, #16]
    1c64:	9b01      	ldr	r3, [sp, #4]
    1c66:	2025      	movs	r0, #37	; 0x25
    1c68:	4798      	blx	r3
    1c6a:	3001      	adds	r0, #1
    1c6c:	d09c      	beq.n	1ba8 <z_prf+0x2c>
				PUTC(c);
    1c6e:	9904      	ldr	r1, [sp, #16]
    1c70:	9b01      	ldr	r3, [sp, #4]
    1c72:	4620      	mov	r0, r4
    1c74:	4798      	blx	r3
    1c76:	3001      	adds	r0, #1
    1c78:	d096      	beq.n	1ba8 <z_prf+0x2c>
				count += 2;
    1c7a:	9b00      	ldr	r3, [sp, #0]
    1c7c:	3302      	adds	r3, #2
    1c7e:	e3a2      	b.n	23c6 <z_prf+0x84a>
				switch (c) {
    1c80:	2c2d      	cmp	r4, #45	; 0x2d
    1c82:	d00a      	beq.n	1c9a <z_prf+0x11e>
    1c84:	2c30      	cmp	r4, #48	; 0x30
    1c86:	d00b      	beq.n	1ca0 <z_prf+0x124>
					fplus = true;
    1c88:	2c2b      	cmp	r4, #43	; 0x2b
    1c8a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1c8c:	bf08      	it	eq
    1c8e:	2301      	moveq	r3, #1
    1c90:	9309      	str	r3, [sp, #36]	; 0x24
    1c92:	e79a      	b.n	1bca <z_prf+0x4e>
					falt = true;
    1c94:	2301      	movs	r3, #1
    1c96:	9306      	str	r3, [sp, #24]
    1c98:	e797      	b.n	1bca <z_prf+0x4e>
					fminus = true;
    1c9a:	2301      	movs	r3, #1
    1c9c:	930b      	str	r3, [sp, #44]	; 0x2c
    1c9e:	e794      	b.n	1bca <z_prf+0x4e>
					fzero = true;
    1ca0:	2301      	movs	r3, #1
    1ca2:	9308      	str	r3, [sp, #32]
    1ca4:	e791      	b.n	1bca <z_prf+0x4e>
			fminus = fplus = fspace = falt = fzero = false;
    1ca6:	2300      	movs	r3, #0
    1ca8:	9308      	str	r3, [sp, #32]
    1caa:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
    1cae:	930b      	str	r3, [sp, #44]	; 0x2c
    1cb0:	9306      	str	r3, [sp, #24]
    1cb2:	e78c      	b.n	1bce <z_prf+0x52>
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    1cb4:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
			} else if (!isdigit(c)) {
    1cb8:	2b09      	cmp	r3, #9
				width = 0;
    1cba:	9007      	str	r0, [sp, #28]
			} else if (!isdigit(c)) {
    1cbc:	d8a1      	bhi.n	1c02 <z_prf+0x86>
		i = 10 * i + *p++ - '0';
    1cbe:	220a      	movs	r2, #10
	while (isdigit(*p)) {
    1cc0:	f8dd 8014 	ldr.w	r8, [sp, #20]
    1cc4:	f818 4b01 	ldrb.w	r4, [r8], #1
    1cc8:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
    1ccc:	2b09      	cmp	r3, #9
    1cce:	d898      	bhi.n	1c02 <z_prf+0x86>
		i = 10 * i + *p++ - '0';
    1cd0:	9b07      	ldr	r3, [sp, #28]
    1cd2:	f8cd 8014 	str.w	r8, [sp, #20]
    1cd6:	fb02 4403 	mla	r4, r2, r3, r4
    1cda:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
    1cde:	9307      	str	r3, [sp, #28]
    1ce0:	e7ee      	b.n	1cc0 <z_prf+0x144>
    1ce2:	fb01 3505 	mla	r5, r1, r5, r3
    1ce6:	3d30      	subs	r5, #48	; 0x30
    1ce8:	4690      	mov	r8, r2
	while (isdigit(*p)) {
    1cea:	4642      	mov	r2, r8
    1cec:	f812 3b01 	ldrb.w	r3, [r2], #1
    1cf0:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    1cf4:	2809      	cmp	r0, #9
    1cf6:	d9f4      	bls.n	1ce2 <z_prf+0x166>
    1cf8:	e78d      	b.n	1c16 <z_prf+0x9a>
	int i = 0;
    1cfa:	2500      	movs	r5, #0
		i = 10 * i + *p++ - '0';
    1cfc:	210a      	movs	r1, #10
    1cfe:	e7f4      	b.n	1cea <z_prf+0x16e>
			precision = -1;
    1d00:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    1d04:	e789      	b.n	1c1a <z_prf+0x9e>
    1d06:	f8cd 8014 	str.w	r8, [sp, #20]
			i = 0;
    1d0a:	4607      	mov	r7, r0
    1d0c:	e79a      	b.n	1c44 <z_prf+0xc8>
			switch (c) {
    1d0e:	2c63      	cmp	r4, #99	; 0x63
    1d10:	d05a      	beq.n	1dc8 <z_prf+0x24c>
    1d12:	d820      	bhi.n	1d56 <z_prf+0x1da>
    1d14:	2c58      	cmp	r4, #88	; 0x58
    1d16:	d1a4      	bne.n	1c62 <z_prf+0xe6>
				if (c == 'o') {
    1d18:	2c6f      	cmp	r4, #111	; 0x6f
    1d1a:	f106 0904 	add.w	r9, r6, #4
    1d1e:	6831      	ldr	r1, [r6, #0]
    1d20:	f040 831c 	bne.w	235c <z_prf+0x7e0>
	if (alt_form) {
    1d24:	9b06      	ldr	r3, [sp, #24]
    1d26:	2b00      	cmp	r3, #0
    1d28:	f000 830a 	beq.w	2340 <z_prf+0x7c4>
		*buf++ = '0';
    1d2c:	2330      	movs	r3, #48	; 0x30
    1d2e:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
		if (!value) {
    1d32:	2900      	cmp	r1, #0
    1d34:	f040 830f 	bne.w	2356 <z_prf+0x7da>
			*buf++ = 0;
    1d38:	f88d 105d 	strb.w	r1, [sp, #93]	; 0x5d
			prefix = 0;
    1d3c:	4688      	mov	r8, r1
			return 1;
    1d3e:	2601      	movs	r6, #1
    1d40:	e026      	b.n	1d90 <z_prf+0x214>
			switch (c) {
    1d42:	2c70      	cmp	r4, #112	; 0x70
    1d44:	f000 82e7 	beq.w	2316 <z_prf+0x79a>
    1d48:	d828      	bhi.n	1d9c <z_prf+0x220>
    1d4a:	2c6e      	cmp	r4, #110	; 0x6e
    1d4c:	f000 82d0 	beq.w	22f0 <z_prf+0x774>
    1d50:	d8e2      	bhi.n	1d18 <z_prf+0x19c>
    1d52:	2c69      	cmp	r4, #105	; 0x69
    1d54:	d185      	bne.n	1c62 <z_prf+0xe6>
				switch (i) {
    1d56:	6834      	ldr	r4, [r6, #0]
	if (value < 0) {
    1d58:	2c00      	cmp	r4, #0
    1d5a:	f106 0904 	add.w	r9, r6, #4
    1d5e:	f280 809c 	bge.w	1e9a <z_prf+0x31e>
		*buf++ = '-';
    1d62:	232d      	movs	r3, #45	; 0x2d
    1d64:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
		value = -value;
    1d68:	4261      	negs	r1, r4
		*buf++ = ' ';
    1d6a:	f10d 065d 	add.w	r6, sp, #93	; 0x5d
	return _to_x(buf, value, 10);
    1d6e:	4630      	mov	r0, r6
    1d70:	220a      	movs	r2, #10
    1d72:	f006 fe09 	bl	8988 <_to_x>
				if (fplus || fspace || val < 0) {
    1d76:	9b09      	ldr	r3, [sp, #36]	; 0x24
	return (buf + _to_udec(buf, value)) - start;
    1d78:	4406      	add	r6, r0
    1d7a:	a817      	add	r0, sp, #92	; 0x5c
    1d7c:	1a36      	subs	r6, r6, r0
				if (fplus || fspace || val < 0) {
    1d7e:	2b00      	cmp	r3, #0
    1d80:	f040 8324 	bne.w	23cc <z_prf+0x850>
    1d84:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1d86:	2b00      	cmp	r3, #0
    1d88:	f040 8320 	bne.w	23cc <z_prf+0x850>
    1d8c:	ea4f 78d4 	mov.w	r8, r4, lsr #31
			if (precision >= 0) {
    1d90:	2d00      	cmp	r5, #0
    1d92:	da22      	bge.n	1dda <z_prf+0x25e>
			zero.predot = zero.postdot = zero.trail = 0;
    1d94:	2500      	movs	r5, #0
    1d96:	462f      	mov	r7, r5
    1d98:	46aa      	mov	sl, r5
    1d9a:	e0e5      	b.n	1f68 <z_prf+0x3ec>
			switch (c) {
    1d9c:	2c75      	cmp	r4, #117	; 0x75
    1d9e:	d0bb      	beq.n	1d18 <z_prf+0x19c>
    1da0:	2c78      	cmp	r4, #120	; 0x78
    1da2:	d0b9      	beq.n	1d18 <z_prf+0x19c>
    1da4:	2c73      	cmp	r4, #115	; 0x73
    1da6:	f47f af5c 	bne.w	1c62 <z_prf+0xe6>
				cptr = va_arg(vargs, char *);
    1daa:	46b1      	mov	r9, r6
					precision = INT_MAX;
    1dac:	2d00      	cmp	r5, #0
				cptr = va_arg(vargs, char *);
    1dae:	f859 3b04 	ldr.w	r3, [r9], #4
					precision = INT_MAX;
    1db2:	bfb8      	it	lt
    1db4:	f06f 4500 	mvnlt.w	r5, #2147483648	; 0x80000000
				for (clen = 0; clen < precision; clen++) {
    1db8:	2600      	movs	r6, #0
    1dba:	42b5      	cmp	r5, r6
    1dbc:	f040 82bb 	bne.w	2336 <z_prf+0x7ba>
    1dc0:	462e      	mov	r6, r5
    1dc2:	2500      	movs	r5, #0
    1dc4:	46a8      	mov	r8, r5
    1dc6:	e009      	b.n	1ddc <z_prf+0x260>
				buf[0] = va_arg(vargs, int);
    1dc8:	46b1      	mov	r9, r6
				break;
    1dca:	f04f 0800 	mov.w	r8, #0
				buf[0] = va_arg(vargs, int);
    1dce:	f859 3b04 	ldr.w	r3, [r9], #4
    1dd2:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
				clen = 1;
    1dd6:	2601      	movs	r6, #1
				break;
    1dd8:	4645      	mov	r5, r8
    1dda:	ab17      	add	r3, sp, #92	; 0x5c
				zero_head = precision - clen + prefix;
    1ddc:	eb05 0208 	add.w	r2, r5, r8
			zero.predot = zero.postdot = zero.trail = 0;
    1de0:	2500      	movs	r5, #0
				zero_head = precision - clen + prefix;
    1de2:	1b92      	subs	r2, r2, r6
			zero.predot = zero.postdot = zero.trail = 0;
    1de4:	462f      	mov	r7, r5
    1de6:	46aa      	mov	sl, r5
			if (zero_head < 0) {
    1de8:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
			width -= clen + zero_head;
    1dec:	1991      	adds	r1, r2, r6
    1dee:	9106      	str	r1, [sp, #24]
    1df0:	9907      	ldr	r1, [sp, #28]
    1df2:	1990      	adds	r0, r2, r6
    1df4:	1a0c      	subs	r4, r1, r0
			if (!fminus && width > 0) {
    1df6:	990b      	ldr	r1, [sp, #44]	; 0x2c
    1df8:	b911      	cbnz	r1, 1e00 <z_prf+0x284>
    1dfa:	2c00      	cmp	r4, #0
    1dfc:	f300 8304 	bgt.w	2408 <z_prf+0x88c>
			while (prefix-- > 0) {
    1e00:	eb03 0b08 	add.w	fp, r3, r8
    1e04:	455b      	cmp	r3, fp
    1e06:	f040 8301 	bne.w	240c <z_prf+0x890>
			while (zero_head-- > 0) {
    1e0a:	f112 32ff 	adds.w	r2, r2, #4294967295	; 0xffffffff
    1e0e:	f080 830d 	bcs.w	242c <z_prf+0x8b0>
			clen -= prefix;
    1e12:	eba6 0608 	sub.w	r6, r6, r8
			if (zero.predot) {
    1e16:	f1ba 0f00 	cmp.w	sl, #0
    1e1a:	d011      	beq.n	1e40 <z_prf+0x2c4>
				c = *cptr;
    1e1c:	f89b 0000 	ldrb.w	r0, [fp]
				while (isdigit(c)) {
    1e20:	eb0b 0806 	add.w	r8, fp, r6
    1e24:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    1e28:	2b09      	cmp	r3, #9
    1e2a:	eba8 060b 	sub.w	r6, r8, fp
    1e2e:	f240 8308 	bls.w	2442 <z_prf+0x8c6>
    1e32:	46d0      	mov	r8, sl
				while (zero.predot-- > 0) {
    1e34:	f118 38ff 	adds.w	r8, r8, #4294967295	; 0xffffffff
    1e38:	f080 830c 	bcs.w	2454 <z_prf+0x8d8>
				clen -= zero.predot;
    1e3c:	eba6 060a 	sub.w	r6, r6, sl
			if (zero.postdot) {
    1e40:	b1af      	cbz	r7, 1e6e <z_prf+0x2f2>
    1e42:	eb0b 0806 	add.w	r8, fp, r6
					c = *cptr++;
    1e46:	f81b ab01 	ldrb.w	sl, [fp], #1
					PUTC(c);
    1e4a:	9904      	ldr	r1, [sp, #16]
    1e4c:	9b01      	ldr	r3, [sp, #4]
    1e4e:	4650      	mov	r0, sl
    1e50:	4798      	blx	r3
    1e52:	3001      	adds	r0, #1
    1e54:	f43f aea8 	beq.w	1ba8 <z_prf+0x2c>
				} while (c != '.');
    1e58:	f1ba 0f2e 	cmp.w	sl, #46	; 0x2e
    1e5c:	eba8 060b 	sub.w	r6, r8, fp
    1e60:	d1f1      	bne.n	1e46 <z_prf+0x2ca>
				while (zero.postdot-- > 0) {
    1e62:	46b8      	mov	r8, r7
    1e64:	f1b8 0f00 	cmp.w	r8, #0
    1e68:	f300 82fd 	bgt.w	2466 <z_prf+0x8ea>
				clen -= zero.postdot;
    1e6c:	1bf6      	subs	r6, r6, r7
			if (zero.trail) {
    1e6e:	b195      	cbz	r5, 1e96 <z_prf+0x31a>
				c = *cptr;
    1e70:	f89b 0000 	ldrb.w	r0, [fp]
				while (isdigit(c) || c == '.') {
    1e74:	eb0b 0806 	add.w	r8, fp, r6
    1e78:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    1e7c:	2b09      	cmp	r3, #9
    1e7e:	eba8 060b 	sub.w	r6, r8, fp
    1e82:	f240 82fb 	bls.w	247c <z_prf+0x900>
    1e86:	282e      	cmp	r0, #46	; 0x2e
    1e88:	f000 82f8 	beq.w	247c <z_prf+0x900>
				while (zero.trail-- > 0) {
    1e8c:	462f      	mov	r7, r5
    1e8e:	2f00      	cmp	r7, #0
    1e90:	f300 82fd 	bgt.w	248e <z_prf+0x912>
				clen -= zero.trail;
    1e94:	1b76      	subs	r6, r6, r5
    1e96:	445e      	add	r6, fp
    1e98:	e30c      	b.n	24b4 <z_prf+0x938>
	} else if (fplus) {
    1e9a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1e9c:	b123      	cbz	r3, 1ea8 <z_prf+0x32c>
		*buf++ = '+';
    1e9e:	232b      	movs	r3, #43	; 0x2b
		*buf++ = ' ';
    1ea0:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
    1ea4:	4621      	mov	r1, r4
    1ea6:	e760      	b.n	1d6a <z_prf+0x1ee>
	} else if (fspace) {
    1ea8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1eaa:	b10b      	cbz	r3, 1eb0 <z_prf+0x334>
		*buf++ = ' ';
    1eac:	2320      	movs	r3, #32
    1eae:	e7f7      	b.n	1ea0 <z_prf+0x324>
	} else if (fspace) {
    1eb0:	4621      	mov	r1, r4
    1eb2:	ae17      	add	r6, sp, #92	; 0x5c
    1eb4:	e75b      	b.n	1d6e <z_prf+0x1f2>
    1eb6:	bf00      	nop
    1eb8:	00045302 	.word	0x00045302
    1ebc:	00045308 	.word	0x00045308
				u.d = va_arg(vargs, double);
    1ec0:	f106 0907 	add.w	r9, r6, #7
    1ec4:	f029 0907 	bic.w	r9, r9, #7
    1ec8:	e8f9 2302 	ldrd	r2, r3, [r9], #8
	fract = (double_temp << 11) & ~HIGHBIT64;
    1ecc:	02d8      	lsls	r0, r3, #11
    1ece:	ea40 5052 	orr.w	r0, r0, r2, lsr #21
    1ed2:	02d6      	lsls	r6, r2, #11
    1ed4:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
    1ed8:	9602      	str	r6, [sp, #8]
    1eda:	9003      	str	r0, [sp, #12]
    1edc:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
	if (sign) {
    1ee0:	2a00      	cmp	r2, #0
	exp = double_temp >> 52 & 0x7ff;
    1ee2:	f3c3 510a 	ubfx	r1, r3, #20, #11
	if (sign) {
    1ee6:	f173 0300 	sbcs.w	r3, r3, #0
	fract = (double_temp << 11) & ~HIGHBIT64;
    1eea:	e9cd 6712 	strd	r6, r7, [sp, #72]	; 0x48
	if (sign) {
    1eee:	da43      	bge.n	1f78 <z_prf+0x3fc>
		*buf++ = '-';
    1ef0:	232d      	movs	r3, #45	; 0x2d
		*buf++ = ' ';
    1ef2:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
    1ef6:	f10d 075d 	add.w	r7, sp, #93	; 0x5d
	if (exp == 0x7ff) {
    1efa:	f240 73ff 	movw	r3, #2047	; 0x7ff
    1efe:	4299      	cmp	r1, r3
    1f00:	d155      	bne.n	1fae <z_prf+0x432>
		if (!fract) {
    1f02:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    1f06:	4313      	orrs	r3, r2
    1f08:	f1a4 0441 	sub.w	r4, r4, #65	; 0x41
    1f0c:	f107 0b03 	add.w	fp, r7, #3
    1f10:	d142      	bne.n	1f98 <z_prf+0x41c>
			if (isupper(c)) {
    1f12:	2c19      	cmp	r4, #25
    1f14:	d83a      	bhi.n	1f8c <z_prf+0x410>
				*buf++ = 'I';
    1f16:	2349      	movs	r3, #73	; 0x49
    1f18:	703b      	strb	r3, [r7, #0]
				*buf++ = 'N';
    1f1a:	234e      	movs	r3, #78	; 0x4e
    1f1c:	707b      	strb	r3, [r7, #1]
				*buf++ = 'F';
    1f1e:	2346      	movs	r3, #70	; 0x46
		*buf = 0;
    1f20:	2500      	movs	r5, #0
		return buf - start;
    1f22:	ae17      	add	r6, sp, #92	; 0x5c
				*buf++ = 'n';
    1f24:	70bb      	strb	r3, [r7, #2]
		*buf = 0;
    1f26:	70fd      	strb	r5, [r7, #3]
		return buf - start;
    1f28:	ebab 0b06 	sub.w	fp, fp, r6
			zero.predot = zero.postdot = zero.trail = 0;
    1f2c:	462f      	mov	r7, r5
    1f2e:	46aa      	mov	sl, r5
				if (fplus || fspace || (buf[0] == '-')) {
    1f30:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1f32:	2b00      	cmp	r3, #0
    1f34:	f040 81d9 	bne.w	22ea <z_prf+0x76e>
    1f38:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1f3a:	2b00      	cmp	r3, #0
    1f3c:	f040 81d5 	bne.w	22ea <z_prf+0x76e>
    1f40:	f89d 805c 	ldrb.w	r8, [sp, #92]	; 0x5c
    1f44:	f1a8 032d 	sub.w	r3, r8, #45	; 0x2d
    1f48:	f1d3 0800 	rsbs	r8, r3, #0
    1f4c:	eb48 0803 	adc.w	r8, r8, r3
				if (!isdigit(buf[prefix])) {
    1f50:	ab1e      	add	r3, sp, #120	; 0x78
    1f52:	4443      	add	r3, r8
				clen += zero.predot + zero.postdot + zero.trail;
    1f54:	44bb      	add	fp, r7
    1f56:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
    1f5a:	3b30      	subs	r3, #48	; 0x30
    1f5c:	eb0b 060a 	add.w	r6, fp, sl
				if (!isdigit(buf[prefix])) {
    1f60:	2b09      	cmp	r3, #9
				clen += zero.predot + zero.postdot + zero.trail;
    1f62:	442e      	add	r6, r5
				if (!isdigit(buf[prefix])) {
    1f64:	f200 8237 	bhi.w	23d6 <z_prf+0x85a>
			} else if (fzero) {
    1f68:	9b08      	ldr	r3, [sp, #32]
    1f6a:	2b00      	cmp	r3, #0
    1f6c:	f000 8236 	beq.w	23dc <z_prf+0x860>
    1f70:	9b07      	ldr	r3, [sp, #28]
    1f72:	1b9a      	subs	r2, r3, r6
    1f74:	ab17      	add	r3, sp, #92	; 0x5c
    1f76:	e737      	b.n	1de8 <z_prf+0x26c>
	} else if (fplus) {
    1f78:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1f7a:	b10b      	cbz	r3, 1f80 <z_prf+0x404>
		*buf++ = '+';
    1f7c:	232b      	movs	r3, #43	; 0x2b
    1f7e:	e7b8      	b.n	1ef2 <z_prf+0x376>
	} else if (fspace) {
    1f80:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1f82:	b10b      	cbz	r3, 1f88 <z_prf+0x40c>
		*buf++ = ' ';
    1f84:	2320      	movs	r3, #32
    1f86:	e7b4      	b.n	1ef2 <z_prf+0x376>
	} else if (fspace) {
    1f88:	af17      	add	r7, sp, #92	; 0x5c
    1f8a:	e7b6      	b.n	1efa <z_prf+0x37e>
				*buf++ = 'i';
    1f8c:	2369      	movs	r3, #105	; 0x69
    1f8e:	703b      	strb	r3, [r7, #0]
				*buf++ = 'n';
    1f90:	236e      	movs	r3, #110	; 0x6e
    1f92:	707b      	strb	r3, [r7, #1]
				*buf++ = 'f';
    1f94:	2366      	movs	r3, #102	; 0x66
    1f96:	e7c3      	b.n	1f20 <z_prf+0x3a4>
			if (isupper(c)) {
    1f98:	2c19      	cmp	r4, #25
				*buf++ = 'N';
    1f9a:	bf99      	ittee	ls
    1f9c:	234e      	movls	r3, #78	; 0x4e
				*buf++ = 'A';
    1f9e:	2241      	movls	r2, #65	; 0x41
				*buf++ = 'n';
    1fa0:	236e      	movhi	r3, #110	; 0x6e
				*buf++ = 'a';
    1fa2:	2261      	movhi	r2, #97	; 0x61
				*buf++ = 'N';
    1fa4:	bf94      	ite	ls
    1fa6:	703b      	strbls	r3, [r7, #0]
				*buf++ = 'n';
    1fa8:	703b      	strbhi	r3, [r7, #0]
				*buf++ = 'a';
    1faa:	707a      	strb	r2, [r7, #1]
    1fac:	e7b8      	b.n	1f20 <z_prf+0x3a4>
	if ((exp | fract) != 0) {
    1fae:	9b02      	ldr	r3, [sp, #8]
    1fb0:	9803      	ldr	r0, [sp, #12]
    1fb2:	430b      	orrs	r3, r1
    1fb4:	930c      	str	r3, [sp, #48]	; 0x30
    1fb6:	17cb      	asrs	r3, r1, #31
    1fb8:	4303      	orrs	r3, r0
    1fba:	930d      	str	r3, [sp, #52]	; 0x34
    1fbc:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
		c = 'f';
    1fc0:	2c46      	cmp	r4, #70	; 0x46
    1fc2:	bf08      	it	eq
    1fc4:	2466      	moveq	r4, #102	; 0x66
	if ((exp | fract) != 0) {
    1fc6:	4313      	orrs	r3, r2
    1fc8:	f000 80ff 	beq.w	21ca <z_prf+0x64e>
		if (exp == 0) {
    1fcc:	2900      	cmp	r1, #0
    1fce:	f000 809f 	beq.w	2110 <z_prf+0x594>
		fract |= HIGHBIT64;
    1fd2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    1fd4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
    1fd8:	f2a1 38fe 	subw	r8, r1, #1022	; 0x3fe
		fract |= HIGHBIT64;
    1fdc:	9313      	str	r3, [sp, #76]	; 0x4c
    1fde:	2600      	movs	r6, #0
	while (exp <= -3) {
    1fe0:	f118 0f02 	cmn.w	r8, #2
    1fe4:	f2c0 80a8 	blt.w	2138 <z_prf+0x5bc>
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    1fe8:	f06f 4a00 	mvn.w	sl, #2147483648	; 0x80000000
    1fec:	f04f 0b00 	mov.w	fp, #0
	while (exp > 0) {
    1ff0:	f1b8 0f00 	cmp.w	r8, #0
    1ff4:	f300 80cc 	bgt.w	2190 <z_prf+0x614>
		_rlrshift(&fract);
    1ff8:	a812      	add	r0, sp, #72	; 0x48
		exp++;
    1ffa:	f108 0801 	add.w	r8, r8, #1
		_rlrshift(&fract);
    1ffe:	f006 fce5 	bl	89cc <_rlrshift>
	while (exp < (0 + 4)) {
    2002:	f1b8 0f04 	cmp.w	r8, #4
    2006:	d1f7      	bne.n	1ff8 <z_prf+0x47c>
		precision = 6;		/* Default precision if none given */
    2008:	2d00      	cmp	r5, #0
	if ((c == 'g') || (c == 'G')) {
    200a:	f004 03df 	and.w	r3, r4, #223	; 0xdf
		precision = 6;		/* Default precision if none given */
    200e:	bfb8      	it	lt
    2010:	2506      	movlt	r5, #6
	if ((c == 'g') || (c == 'G')) {
    2012:	2b47      	cmp	r3, #71	; 0x47
    2014:	f040 80e1 	bne.w	21da <z_prf+0x65e>
		if (decexp < (-4 + 1) || decexp > precision) {
    2018:	1cf2      	adds	r2, r6, #3
    201a:	db02      	blt.n	2022 <z_prf+0x4a6>
    201c:	42ae      	cmp	r6, r5
    201e:	f340 80d7 	ble.w	21d0 <z_prf+0x654>
			c += 'e' - 'g';
    2022:	3c02      	subs	r4, #2
    2024:	b2e4      	uxtb	r4, r4
			if (precision > 0) {
    2026:	2d00      	cmp	r5, #0
    2028:	f000 80dd 	beq.w	21e6 <z_prf+0x66a>
		if (!falt && (precision > 0)) {
    202c:	9b06      	ldr	r3, [sp, #24]
				precision--;
    202e:	3d01      	subs	r5, #1
		if (!falt && (precision > 0)) {
    2030:	2b00      	cmp	r3, #0
    2032:	f040 80d8 	bne.w	21e6 <z_prf+0x66a>
    2036:	2d00      	cmp	r5, #0
    2038:	bfd4      	ite	le
    203a:	f04f 0800 	movle.w	r8, #0
    203e:	f04f 0801 	movgt.w	r8, #1
	if (c == 'f') {
    2042:	2c66      	cmp	r4, #102	; 0x66
    2044:	f040 80d1 	bne.w	21ea <z_prf+0x66e>
		if (exp < 0) {
    2048:	eb16 0a05 	adds.w	sl, r6, r5
    204c:	f140 80d5 	bpl.w	21fa <z_prf+0x67e>
	digit_count = 16;
    2050:	2310      	movs	r3, #16
    2052:	9311      	str	r3, [sp, #68]	; 0x44
    2054:	2466      	movs	r4, #102	; 0x66
			exp = 0;
    2056:	f04f 0a00 	mov.w	sl, #0
	ltemp = 0x0800000000000000;
    205a:	2200      	movs	r2, #0
    205c:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    2060:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
	while (exp--) {
    2064:	f11a 3aff 	adds.w	sl, sl, #4294967295	; 0xffffffff
    2068:	f080 80c9 	bcs.w	21fe <z_prf+0x682>
	fract += ltemp;
    206c:	9b12      	ldr	r3, [sp, #72]	; 0x48
    206e:	9a14      	ldr	r2, [sp, #80]	; 0x50
    2070:	9915      	ldr	r1, [sp, #84]	; 0x54
    2072:	189b      	adds	r3, r3, r2
    2074:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    2076:	eb41 0202 	adc.w	r2, r1, r2
    207a:	e9cd 3212 	strd	r3, r2, [sp, #72]	; 0x48
	if ((fract >> 32) & 0xF0000000) {
    207e:	f002 4370 	and.w	r3, r2, #4026531840	; 0xf0000000
    2082:	930e      	str	r3, [sp, #56]	; 0x38
    2084:	2300      	movs	r3, #0
    2086:	930f      	str	r3, [sp, #60]	; 0x3c
    2088:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
    208c:	4313      	orrs	r3, r2
    208e:	d006      	beq.n	209e <z_prf+0x522>
		_ldiv5(&fract);
    2090:	a812      	add	r0, sp, #72	; 0x48
    2092:	f006 fcad 	bl	89f0 <_ldiv5>
		_rlrshift(&fract);
    2096:	a812      	add	r0, sp, #72	; 0x48
    2098:	f006 fc98 	bl	89cc <_rlrshift>
		decexp++;
    209c:	3601      	adds	r6, #1
	if (c == 'f') {
    209e:	2c66      	cmp	r4, #102	; 0x66
    20a0:	f040 80c7 	bne.w	2232 <z_prf+0x6b6>
		if (decexp > 0) {
    20a4:	2e00      	cmp	r6, #0
    20a6:	f340 80b1 	ble.w	220c <z_prf+0x690>
			while (decexp > 0 && digit_count > 0) {
    20aa:	9b11      	ldr	r3, [sp, #68]	; 0x44
    20ac:	2b00      	cmp	r3, #0
    20ae:	dd07      	ble.n	20c0 <z_prf+0x544>
				*buf++ = _get_digit(&fract, &digit_count);
    20b0:	a911      	add	r1, sp, #68	; 0x44
    20b2:	a812      	add	r0, sp, #72	; 0x48
    20b4:	f006 fcc8 	bl	8a48 <_get_digit>
			while (decexp > 0 && digit_count > 0) {
    20b8:	3e01      	subs	r6, #1
				*buf++ = _get_digit(&fract, &digit_count);
    20ba:	f807 0b01 	strb.w	r0, [r7], #1
			while (decexp > 0 && digit_count > 0) {
    20be:	d1f4      	bne.n	20aa <z_prf+0x52e>
			zp->predot = decexp;
    20c0:	46b2      	mov	sl, r6
    20c2:	46bb      	mov	fp, r7
			decexp = 0;
    20c4:	2600      	movs	r6, #0
		if (falt || (precision > 0)) {
    20c6:	9b06      	ldr	r3, [sp, #24]
    20c8:	b913      	cbnz	r3, 20d0 <z_prf+0x554>
    20ca:	2d00      	cmp	r5, #0
    20cc:	f340 80af 	ble.w	222e <z_prf+0x6b2>
			*buf++ = '.';
    20d0:	232e      	movs	r3, #46	; 0x2e
    20d2:	f80b 3b01 	strb.w	r3, [fp], #1
		if (decexp < 0 && precision > 0) {
    20d6:	2e00      	cmp	r6, #0
    20d8:	f000 80a7 	beq.w	222a <z_prf+0x6ae>
    20dc:	2d00      	cmp	r5, #0
    20de:	f340 80a6 	ble.w	222e <z_prf+0x6b2>
			zp->postdot = -decexp;
    20e2:	4277      	negs	r7, r6
    20e4:	42af      	cmp	r7, r5
    20e6:	bfa8      	it	ge
    20e8:	462f      	movge	r7, r5
			precision -= zp->postdot;
    20ea:	1bed      	subs	r5, r5, r7
		while (precision > 0 && digit_count > 0) {
    20ec:	2d00      	cmp	r5, #0
    20ee:	dd03      	ble.n	20f8 <z_prf+0x57c>
    20f0:	9b11      	ldr	r3, [sp, #68]	; 0x44
    20f2:	2b00      	cmp	r3, #0
    20f4:	f300 8091 	bgt.w	221a <z_prf+0x69e>
	if (prune_zero) {
    20f8:	f1b8 0f00 	cmp.w	r8, #0
    20fc:	f040 80af 	bne.w	225e <z_prf+0x6e2>
	*buf = 0;
    2100:	2300      	movs	r3, #0
	return buf - start;
    2102:	ae17      	add	r6, sp, #92	; 0x5c
	*buf = 0;
    2104:	f88b 3000 	strb.w	r3, [fp]
	return buf - start;
    2108:	ebab 0b06 	sub.w	fp, fp, r6
    210c:	e710      	b.n	1f30 <z_prf+0x3b4>
				exp--;
    210e:	3901      	subs	r1, #1
			while (((fract <<= 1) & HIGHBIT64) == 0) {
    2110:	9b02      	ldr	r3, [sp, #8]
    2112:	18db      	adds	r3, r3, r3
    2114:	9302      	str	r3, [sp, #8]
    2116:	9b03      	ldr	r3, [sp, #12]
    2118:	415b      	adcs	r3, r3
    211a:	9303      	str	r3, [sp, #12]
    211c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    2120:	2a00      	cmp	r2, #0
    2122:	f173 0300 	sbcs.w	r3, r3, #0
    2126:	daf2      	bge.n	210e <z_prf+0x592>
    2128:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    212c:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
    2130:	e74f      	b.n	1fd2 <z_prf+0x456>
			_rlrshift(&fract);
    2132:	a812      	add	r0, sp, #72	; 0x48
    2134:	f006 fc4a 	bl	89cc <_rlrshift>
		while ((fract >> 32) >= (MAXFP1 / 5)) {
    2138:	e9dd 2c12 	ldrd	r2, ip, [sp, #72]	; 0x48
    213c:	f04f 0b00 	mov.w	fp, #0
    2140:	48b9      	ldr	r0, [pc, #740]	; (2428 <z_prf+0x8ac>)
    2142:	2100      	movs	r1, #0
    2144:	4559      	cmp	r1, fp
    2146:	bf08      	it	eq
    2148:	4560      	cmpeq	r0, ip
    214a:	f108 0801 	add.w	r8, r8, #1
    214e:	d3f0      	bcc.n	2132 <z_prf+0x5b6>
		fract *= 5U;
    2150:	2005      	movs	r0, #5
    2152:	fba2 2300 	umull	r2, r3, r2, r0
    2156:	fb00 330c 	mla	r3, r0, ip, r3
    215a:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
		decexp--;
    215e:	46dc      	mov	ip, fp
    2160:	3e01      	subs	r6, #1
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    2162:	f06f 4a00 	mvn.w	sl, #2147483648	; 0x80000000
    2166:	f04f 0b00 	mov.w	fp, #0
    216a:	2100      	movs	r1, #0
    216c:	458b      	cmp	fp, r1
    216e:	bf08      	it	eq
    2170:	459a      	cmpeq	sl, r3
    2172:	d206      	bcs.n	2182 <z_prf+0x606>
    2174:	f1bc 0f00 	cmp.w	ip, #0
    2178:	f43f af32 	beq.w	1fe0 <z_prf+0x464>
    217c:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
    2180:	e72e      	b.n	1fe0 <z_prf+0x464>
			fract <<= 1;
    2182:	1892      	adds	r2, r2, r2
    2184:	415b      	adcs	r3, r3
			exp--;
    2186:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    218a:	f04f 0c01 	mov.w	ip, #1
    218e:	e7ec      	b.n	216a <z_prf+0x5ee>
		_ldiv5(&fract);
    2190:	a812      	add	r0, sp, #72	; 0x48
    2192:	f006 fc2d 	bl	89f0 <_ldiv5>
		exp--;
    2196:	e9dd 1012 	ldrd	r1, r0, [sp, #72]	; 0x48
    219a:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
		decexp++;
    219e:	3601      	adds	r6, #1
    21a0:	f04f 0c00 	mov.w	ip, #0
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    21a4:	2300      	movs	r3, #0
    21a6:	459b      	cmp	fp, r3
    21a8:	bf08      	it	eq
    21aa:	4582      	cmpeq	sl, r0
    21ac:	d206      	bcs.n	21bc <z_prf+0x640>
    21ae:	f1bc 0f00 	cmp.w	ip, #0
    21b2:	f43f af1d 	beq.w	1ff0 <z_prf+0x474>
    21b6:	e9cd 1012 	strd	r1, r0, [sp, #72]	; 0x48
    21ba:	e719      	b.n	1ff0 <z_prf+0x474>
			fract <<= 1;
    21bc:	1849      	adds	r1, r1, r1
    21be:	4140      	adcs	r0, r0
			exp--;
    21c0:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    21c4:	f04f 0c01 	mov.w	ip, #1
    21c8:	e7ec      	b.n	21a4 <z_prf+0x628>
	if ((exp | fract) != 0) {
    21ca:	2600      	movs	r6, #0
    21cc:	46b0      	mov	r8, r6
    21ce:	e713      	b.n	1ff8 <z_prf+0x47c>
		if (!falt && (precision > 0)) {
    21d0:	9b06      	ldr	r3, [sp, #24]
			precision -= decexp;
    21d2:	1bad      	subs	r5, r5, r6
		if (!falt && (precision > 0)) {
    21d4:	b923      	cbnz	r3, 21e0 <z_prf+0x664>
			c = 'f';
    21d6:	2466      	movs	r4, #102	; 0x66
    21d8:	e72d      	b.n	2036 <z_prf+0x4ba>
	prune_zero = false;		/* Assume trailing 0's allowed     */
    21da:	f04f 0800 	mov.w	r8, #0
    21de:	e730      	b.n	2042 <z_prf+0x4c6>
    21e0:	f04f 0800 	mov.w	r8, #0
    21e4:	e730      	b.n	2048 <z_prf+0x4cc>
    21e6:	f04f 0800 	mov.w	r8, #0
		exp = precision + 1;
    21ea:	f105 0a01 	add.w	sl, r5, #1
	digit_count = 16;
    21ee:	2310      	movs	r3, #16
    21f0:	459a      	cmp	sl, r3
    21f2:	9311      	str	r3, [sp, #68]	; 0x44
	if (exp > 16) {
    21f4:	bfa8      	it	ge
    21f6:	469a      	movge	sl, r3
    21f8:	e72f      	b.n	205a <z_prf+0x4de>
		if (exp < 0) {
    21fa:	2466      	movs	r4, #102	; 0x66
    21fc:	e7f7      	b.n	21ee <z_prf+0x672>
		_ldiv5(&ltemp);
    21fe:	a814      	add	r0, sp, #80	; 0x50
    2200:	f006 fbf6 	bl	89f0 <_ldiv5>
		_rlrshift(&ltemp);
    2204:	a814      	add	r0, sp, #80	; 0x50
    2206:	f006 fbe1 	bl	89cc <_rlrshift>
    220a:	e72b      	b.n	2064 <z_prf+0x4e8>
			*buf++ = '0';
    220c:	46bb      	mov	fp, r7
    220e:	2330      	movs	r3, #48	; 0x30
    2210:	f80b 3b01 	strb.w	r3, [fp], #1
			zero.predot = zero.postdot = zero.trail = 0;
    2214:	f04f 0a00 	mov.w	sl, #0
    2218:	e755      	b.n	20c6 <z_prf+0x54a>
			*buf++ = _get_digit(&fract, &digit_count);
    221a:	a911      	add	r1, sp, #68	; 0x44
    221c:	a812      	add	r0, sp, #72	; 0x48
    221e:	f006 fc13 	bl	8a48 <_get_digit>
			precision--;
    2222:	3d01      	subs	r5, #1
			*buf++ = _get_digit(&fract, &digit_count);
    2224:	f80b 0b01 	strb.w	r0, [fp], #1
			precision--;
    2228:	e760      	b.n	20ec <z_prf+0x570>
			zero.predot = zero.postdot = zero.trail = 0;
    222a:	4637      	mov	r7, r6
    222c:	e75e      	b.n	20ec <z_prf+0x570>
    222e:	2700      	movs	r7, #0
    2230:	e762      	b.n	20f8 <z_prf+0x57c>
		*buf = _get_digit(&fract, &digit_count);
    2232:	a911      	add	r1, sp, #68	; 0x44
    2234:	a812      	add	r0, sp, #72	; 0x48
    2236:	f006 fc07 	bl	8a48 <_get_digit>
		if (falt || (precision > 0)) {
    223a:	9b06      	ldr	r3, [sp, #24]
		*buf = _get_digit(&fract, &digit_count);
    223c:	7038      	strb	r0, [r7, #0]
		if (*buf++ != '0') {
    223e:	2830      	cmp	r0, #48	; 0x30
			decexp--;
    2240:	bf18      	it	ne
    2242:	f106 36ff 	addne.w	r6, r6, #4294967295	; 0xffffffff
		if (falt || (precision > 0)) {
    2246:	2b00      	cmp	r3, #0
    2248:	d13b      	bne.n	22c2 <z_prf+0x746>
    224a:	2d00      	cmp	r5, #0
    224c:	dc39      	bgt.n	22c2 <z_prf+0x746>
		if (*buf++ != '0') {
    224e:	f107 0b01 	add.w	fp, r7, #1
	if (prune_zero) {
    2252:	f1b8 0f00 	cmp.w	r8, #0
    2256:	d045      	beq.n	22e4 <z_prf+0x768>
			zero.predot = zero.postdot = zero.trail = 0;
    2258:	f04f 0a00 	mov.w	sl, #0
    225c:	4657      	mov	r7, sl
		while (*--buf == '0')
    225e:	465b      	mov	r3, fp
    2260:	f81b 2d01 	ldrb.w	r2, [fp, #-1]!
    2264:	2a30      	cmp	r2, #48	; 0x30
    2266:	d0fa      	beq.n	225e <z_prf+0x6e2>
		if (*buf != '.') {
    2268:	2a2e      	cmp	r2, #46	; 0x2e
    226a:	bf18      	it	ne
    226c:	469b      	movne	fp, r3
    226e:	2500      	movs	r5, #0
	if ((c == 'e') || (c == 'E')) {
    2270:	f004 03df 	and.w	r3, r4, #223	; 0xdf
    2274:	2b45      	cmp	r3, #69	; 0x45
    2276:	f47f af43 	bne.w	2100 <z_prf+0x584>
		if (decexp < 0) {
    227a:	2e00      	cmp	r6, #0
		*buf++ = c;
    227c:	465a      	mov	r2, fp
			decexp = -decexp;
    227e:	bfba      	itte	lt
    2280:	4276      	neglt	r6, r6
			*buf++ = '-';
    2282:	232d      	movlt	r3, #45	; 0x2d
			*buf++ = '+';
    2284:	232b      	movge	r3, #43	; 0x2b
		if (decexp >= 100) {
    2286:	2e63      	cmp	r6, #99	; 0x63
		*buf++ = c;
    2288:	f802 4b02 	strb.w	r4, [r2], #2
			*buf++ = '-';
    228c:	f88b 3001 	strb.w	r3, [fp, #1]
		if (decexp >= 100) {
    2290:	dd0a      	ble.n	22a8 <z_prf+0x72c>
			*buf++ = (decexp / 100) + '0';
    2292:	2164      	movs	r1, #100	; 0x64
    2294:	fb96 f3f1 	sdiv	r3, r6, r1
    2298:	f103 0030 	add.w	r0, r3, #48	; 0x30
    229c:	f10b 0203 	add.w	r2, fp, #3
    22a0:	f88b 0002 	strb.w	r0, [fp, #2]
			decexp %= 100;
    22a4:	fb01 6613 	mls	r6, r1, r3, r6
		*buf++ = (decexp / 10) + '0';
    22a8:	210a      	movs	r1, #10
    22aa:	4693      	mov	fp, r2
    22ac:	fb96 f3f1 	sdiv	r3, r6, r1
		decexp %= 10;
    22b0:	fb01 6613 	mls	r6, r1, r3, r6
		*buf++ = (decexp / 10) + '0';
    22b4:	f103 0030 	add.w	r0, r3, #48	; 0x30
		*buf++ = decexp + '0';
    22b8:	3630      	adds	r6, #48	; 0x30
		*buf++ = (decexp / 10) + '0';
    22ba:	f80b 0b02 	strb.w	r0, [fp], #2
		*buf++ = decexp + '0';
    22be:	7056      	strb	r6, [r2, #1]
    22c0:	e71e      	b.n	2100 <z_prf+0x584>
			*buf++ = '.';
    22c2:	232e      	movs	r3, #46	; 0x2e
    22c4:	f107 0b02 	add.w	fp, r7, #2
    22c8:	707b      	strb	r3, [r7, #1]
		while (precision > 0 && digit_count > 0) {
    22ca:	2d00      	cmp	r5, #0
    22cc:	ddc1      	ble.n	2252 <z_prf+0x6d6>
    22ce:	9b11      	ldr	r3, [sp, #68]	; 0x44
    22d0:	2b00      	cmp	r3, #0
    22d2:	ddbe      	ble.n	2252 <z_prf+0x6d6>
			*buf++ = _get_digit(&fract, &digit_count);
    22d4:	a911      	add	r1, sp, #68	; 0x44
    22d6:	a812      	add	r0, sp, #72	; 0x48
    22d8:	f006 fbb6 	bl	8a48 <_get_digit>
			precision--;
    22dc:	3d01      	subs	r5, #1
			*buf++ = _get_digit(&fract, &digit_count);
    22de:	f80b 0b01 	strb.w	r0, [fp], #1
			precision--;
    22e2:	e7f2      	b.n	22ca <z_prf+0x74e>
			zero.predot = zero.postdot = zero.trail = 0;
    22e4:	46c2      	mov	sl, r8
    22e6:	4647      	mov	r7, r8
    22e8:	e7c2      	b.n	2270 <z_prf+0x6f4>
					prefix = 1;
    22ea:	f04f 0801 	mov.w	r8, #1
    22ee:	e62f      	b.n	1f50 <z_prf+0x3d4>
				switch (i) {
    22f0:	46b1      	mov	r9, r6
    22f2:	2f68      	cmp	r7, #104	; 0x68
    22f4:	f859 3b04 	ldr.w	r3, [r9], #4
    22f8:	d005      	beq.n	2306 <z_prf+0x78a>
    22fa:	dc01      	bgt.n	2300 <z_prf+0x784>
    22fc:	2f48      	cmp	r7, #72	; 0x48
    22fe:	d007      	beq.n	2310 <z_prf+0x794>
					*va_arg(vargs, int *) = count;
    2300:	9a00      	ldr	r2, [sp, #0]
    2302:	601a      	str	r2, [r3, #0]
					break;
    2304:	e001      	b.n	230a <z_prf+0x78e>
					*va_arg(vargs, short *) = count;
    2306:	9a00      	ldr	r2, [sp, #0]
    2308:	801a      	strh	r2, [r3, #0]
				continue;
    230a:	464e      	mov	r6, r9
    230c:	9a05      	ldr	r2, [sp, #20]
    230e:	e43d      	b.n	1b8c <z_prf+0x10>
					*va_arg(vargs, char *) = count;
    2310:	9a00      	ldr	r2, [sp, #0]
    2312:	701a      	strb	r2, [r3, #0]
					break;
    2314:	e7f9      	b.n	230a <z_prf+0x78e>
				val = (uintptr_t) va_arg(vargs, void *);
    2316:	46b1      	mov	r9, r6
		*buf++ = '0';
    2318:	f647 0330 	movw	r3, #30768	; 0x7830
	len = _to_x(buf, value, 16);
    231c:	2210      	movs	r2, #16
    231e:	f859 1b04 	ldr.w	r1, [r9], #4
		*buf++ = '0';
    2322:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
	len = _to_x(buf, value, 16);
    2326:	f10d 005e 	add.w	r0, sp, #94	; 0x5e
    232a:	f006 fb2d 	bl	8988 <_to_x>
				prefix = 2;
    232e:	f04f 0802 	mov.w	r8, #2
	return len + (buf - buf0);
    2332:	1c86      	adds	r6, r0, #2
				break;
    2334:	e52c      	b.n	1d90 <z_prf+0x214>
					if (cptr[clen] == '\0') {
    2336:	5d9a      	ldrb	r2, [r3, r6]
    2338:	2a00      	cmp	r2, #0
    233a:	d04a      	beq.n	23d2 <z_prf+0x856>
				for (clen = 0; clen < precision; clen++) {
    233c:	3601      	adds	r6, #1
    233e:	e53c      	b.n	1dba <z_prf+0x23e>
	if (alt_form) {
    2340:	ac17      	add	r4, sp, #92	; 0x5c
	return (buf - buf0) + _to_x(buf, value, 8);
    2342:	2208      	movs	r2, #8
    2344:	4620      	mov	r0, r4
    2346:	f006 fb1f 	bl	8988 <_to_x>
    234a:	ae17      	add	r6, sp, #92	; 0x5c
    234c:	1ba6      	subs	r6, r4, r6
    234e:	4406      	add	r6, r0
			prefix = 0;
    2350:	f04f 0800 	mov.w	r8, #0
    2354:	e51c      	b.n	1d90 <z_prf+0x214>
		*buf++ = '0';
    2356:	f10d 045d 	add.w	r4, sp, #93	; 0x5d
    235a:	e7f2      	b.n	2342 <z_prf+0x7c6>
				} else if (c == 'u') {
    235c:	2c75      	cmp	r4, #117	; 0x75
    235e:	d105      	bne.n	236c <z_prf+0x7f0>
	return _to_x(buf, value, 10);
    2360:	220a      	movs	r2, #10
    2362:	a817      	add	r0, sp, #92	; 0x5c
    2364:	f006 fb10 	bl	8988 <_to_x>
    2368:	4606      	mov	r6, r0
    236a:	e7f1      	b.n	2350 <z_prf+0x7d4>
	if (alt_form) {
    236c:	9b06      	ldr	r3, [sp, #24]
    236e:	b193      	cbz	r3, 2396 <z_prf+0x81a>
		*buf++ = '0';
    2370:	f647 0330 	movw	r3, #30768	; 0x7830
    2374:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
		*buf++ = 'x';
    2378:	f10d 075e 	add.w	r7, sp, #94	; 0x5e
	len = _to_x(buf, value, 16);
    237c:	2210      	movs	r2, #16
    237e:	4638      	mov	r0, r7
    2380:	f006 fb02 	bl	8988 <_to_x>
	if (prefix == 'X') {
    2384:	2c58      	cmp	r4, #88	; 0x58
    2386:	d008      	beq.n	239a <z_prf+0x81e>
	return len + (buf - buf0);
    2388:	ae17      	add	r6, sp, #92	; 0x5c
						prefix = 2;
    238a:	9b06      	ldr	r3, [sp, #24]
	return len + (buf - buf0);
    238c:	1bbe      	subs	r6, r7, r6
    238e:	4406      	add	r6, r0
						prefix = 2;
    2390:	ea4f 0843 	mov.w	r8, r3, lsl #1
    2394:	e4fc      	b.n	1d90 <z_prf+0x214>
	if (alt_form) {
    2396:	af17      	add	r7, sp, #92	; 0x5c
    2398:	e7f0      	b.n	237c <z_prf+0x800>
    239a:	aa17      	add	r2, sp, #92	; 0x5c
		if (*buf >= 'a' && *buf <= 'z') {
    239c:	f812 3b01 	ldrb.w	r3, [r2], #1
    23a0:	f1a3 0161 	sub.w	r1, r3, #97	; 0x61
    23a4:	2919      	cmp	r1, #25
    23a6:	d803      	bhi.n	23b0 <z_prf+0x834>
			*buf += 'A' - 'a';
    23a8:	3b20      	subs	r3, #32
    23aa:	f802 3c01 	strb.w	r3, [r2, #-1]
    23ae:	e7f5      	b.n	239c <z_prf+0x820>
	} while (*buf++);
    23b0:	f812 3c01 	ldrb.w	r3, [r2, #-1]
    23b4:	2b00      	cmp	r3, #0
    23b6:	d1f1      	bne.n	239c <z_prf+0x820>
    23b8:	e7e6      	b.n	2388 <z_prf+0x80c>
				PUTC('%');
    23ba:	9904      	ldr	r1, [sp, #16]
    23bc:	4620      	mov	r0, r4
    23be:	f7ff bbee 	b.w	1b9e <z_prf+0x22>
				count++;
    23c2:	9b00      	ldr	r3, [sp, #0]
    23c4:	3301      	adds	r3, #1
				count += 2;
    23c6:	9300      	str	r3, [sp, #0]
				continue;
    23c8:	46b1      	mov	r9, r6
    23ca:	e79e      	b.n	230a <z_prf+0x78e>
					prefix = 1;
    23cc:	f04f 0801 	mov.w	r8, #1
    23d0:	e4de      	b.n	1d90 <z_prf+0x214>
    23d2:	4615      	mov	r5, r2
    23d4:	e4f6      	b.n	1dc4 <z_prf+0x248>
			cptr = buf;
    23d6:	ab17      	add	r3, sp, #92	; 0x5c
				zero_head = 0;
    23d8:	2200      	movs	r2, #0
    23da:	e507      	b.n	1dec <z_prf+0x270>
    23dc:	ab17      	add	r3, sp, #92	; 0x5c
    23de:	9a08      	ldr	r2, [sp, #32]
    23e0:	e504      	b.n	1dec <z_prf+0x270>
    23e2:	e9cd 3207 	strd	r3, r2, [sp, #28]
					PUTC(' ');
    23e6:	9904      	ldr	r1, [sp, #16]
    23e8:	9b01      	ldr	r3, [sp, #4]
    23ea:	2020      	movs	r0, #32
    23ec:	4798      	blx	r3
    23ee:	3001      	adds	r0, #1
    23f0:	e9dd 3207 	ldrd	r3, r2, [sp, #28]
    23f4:	f43f abd8 	beq.w	1ba8 <z_prf+0x2c>
				while (width-- > 0) {
    23f8:	f11b 3bff 	adds.w	fp, fp, #4294967295	; 0xffffffff
    23fc:	d2f1      	bcs.n	23e2 <z_prf+0x866>
				count += width;
    23fe:	9900      	ldr	r1, [sp, #0]
    2400:	4421      	add	r1, r4
    2402:	9100      	str	r1, [sp, #0]
				while (width-- > 0) {
    2404:	465c      	mov	r4, fp
    2406:	e4fb      	b.n	1e00 <z_prf+0x284>
    2408:	46a3      	mov	fp, r4
    240a:	e7f5      	b.n	23f8 <z_prf+0x87c>
				PUTC(*cptr++);
    240c:	f813 0b01 	ldrb.w	r0, [r3], #1
    2410:	9307      	str	r3, [sp, #28]
    2412:	9904      	ldr	r1, [sp, #16]
    2414:	9b01      	ldr	r3, [sp, #4]
    2416:	9208      	str	r2, [sp, #32]
    2418:	4798      	blx	r3
    241a:	3001      	adds	r0, #1
    241c:	e9dd 3207 	ldrd	r3, r2, [sp, #28]
    2420:	f47f acf0 	bne.w	1e04 <z_prf+0x288>
    2424:	f7ff bbc0 	b.w	1ba8 <z_prf+0x2c>
    2428:	33333332 	.word	0x33333332
				PUTC('0');
    242c:	9904      	ldr	r1, [sp, #16]
    242e:	9b01      	ldr	r3, [sp, #4]
    2430:	9207      	str	r2, [sp, #28]
    2432:	2030      	movs	r0, #48	; 0x30
    2434:	4798      	blx	r3
    2436:	3001      	adds	r0, #1
    2438:	9a07      	ldr	r2, [sp, #28]
    243a:	f47f ace6 	bne.w	1e0a <z_prf+0x28e>
    243e:	f7ff bbb3 	b.w	1ba8 <z_prf+0x2c>
					PUTC(c);
    2442:	9904      	ldr	r1, [sp, #16]
    2444:	9b01      	ldr	r3, [sp, #4]
    2446:	4798      	blx	r3
    2448:	3001      	adds	r0, #1
    244a:	f43f abad 	beq.w	1ba8 <z_prf+0x2c>
					c = *++cptr;
    244e:	f81b 0f01 	ldrb.w	r0, [fp, #1]!
    2452:	e4e7      	b.n	1e24 <z_prf+0x2a8>
					PUTC('0');
    2454:	9904      	ldr	r1, [sp, #16]
    2456:	9b01      	ldr	r3, [sp, #4]
    2458:	2030      	movs	r0, #48	; 0x30
    245a:	4798      	blx	r3
    245c:	3001      	adds	r0, #1
    245e:	f47f ace9 	bne.w	1e34 <z_prf+0x2b8>
    2462:	f7ff bba1 	b.w	1ba8 <z_prf+0x2c>
					PUTC('0');
    2466:	9904      	ldr	r1, [sp, #16]
    2468:	9b01      	ldr	r3, [sp, #4]
    246a:	2030      	movs	r0, #48	; 0x30
    246c:	4798      	blx	r3
    246e:	3001      	adds	r0, #1
    2470:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    2474:	f47f acf6 	bne.w	1e64 <z_prf+0x2e8>
    2478:	f7ff bb96 	b.w	1ba8 <z_prf+0x2c>
					PUTC(c);
    247c:	9904      	ldr	r1, [sp, #16]
    247e:	9b01      	ldr	r3, [sp, #4]
    2480:	4798      	blx	r3
    2482:	3001      	adds	r0, #1
    2484:	f43f ab90 	beq.w	1ba8 <z_prf+0x2c>
					c = *++cptr;
    2488:	f81b 0f01 	ldrb.w	r0, [fp, #1]!
    248c:	e4f4      	b.n	1e78 <z_prf+0x2fc>
					PUTC('0');
    248e:	9904      	ldr	r1, [sp, #16]
    2490:	9b01      	ldr	r3, [sp, #4]
    2492:	2030      	movs	r0, #48	; 0x30
    2494:	4798      	blx	r3
    2496:	3001      	adds	r0, #1
    2498:	f107 37ff 	add.w	r7, r7, #4294967295	; 0xffffffff
    249c:	f47f acf7 	bne.w	1e8e <z_prf+0x312>
    24a0:	f7ff bb82 	b.w	1ba8 <z_prf+0x2c>
				PUTC(*cptr++);
    24a4:	9904      	ldr	r1, [sp, #16]
    24a6:	f81b 0b01 	ldrb.w	r0, [fp], #1
    24aa:	9b01      	ldr	r3, [sp, #4]
    24ac:	4798      	blx	r3
    24ae:	3001      	adds	r0, #1
    24b0:	f43f ab7a 	beq.w	1ba8 <z_prf+0x2c>
    24b4:	eba6 030b 	sub.w	r3, r6, fp
			while (clen-- > 0) {
    24b8:	2b00      	cmp	r3, #0
    24ba:	dcf3      	bgt.n	24a4 <z_prf+0x928>
			count += clen;
    24bc:	9b00      	ldr	r3, [sp, #0]
    24be:	9a06      	ldr	r2, [sp, #24]
			if (width > 0) {
    24c0:	2c00      	cmp	r4, #0
			count += clen;
    24c2:	4413      	add	r3, r2
    24c4:	9300      	str	r3, [sp, #0]
			if (width > 0) {
    24c6:	f77f af20 	ble.w	230a <z_prf+0x78e>
    24ca:	4625      	mov	r5, r4
    24cc:	e006      	b.n	24dc <z_prf+0x960>
					PUTC(' ');
    24ce:	9904      	ldr	r1, [sp, #16]
    24d0:	9b01      	ldr	r3, [sp, #4]
    24d2:	2020      	movs	r0, #32
    24d4:	4798      	blx	r3
    24d6:	3001      	adds	r0, #1
    24d8:	f43f ab66 	beq.w	1ba8 <z_prf+0x2c>
				while (width-- > 0) {
    24dc:	f115 35ff 	adds.w	r5, r5, #4294967295	; 0xffffffff
    24e0:	d2f5      	bcs.n	24ce <z_prf+0x952>
				count += width;
    24e2:	9b00      	ldr	r3, [sp, #0]
    24e4:	4423      	add	r3, r4
    24e6:	9300      	str	r3, [sp, #0]
    24e8:	e70f      	b.n	230a <z_prf+0x78e>
    24ea:	bf00      	nop

000024ec <sprintf>:
	*(p.ptr) = 0;
	return r;
}

int sprintf(char *_MLIBC_RESTRICT s, const char *_MLIBC_RESTRICT format, ...)
{
    24ec:	b40e      	push	{r1, r2, r3}
    24ee:	b50f      	push	{r0, r1, r2, r3, lr}
    24f0:	ab05      	add	r3, sp, #20

	struct emitter p;
	int     r;

	p.ptr = s;
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
    24f2:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
{
    24f6:	f853 2b04 	ldr.w	r2, [r3], #4
	p.ptr = s;
    24fa:	9002      	str	r0, [sp, #8]
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
    24fc:	9103      	str	r1, [sp, #12]

	va_start(vargs, format);
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
    24fe:	4806      	ldr	r0, [pc, #24]	; (2518 <sprintf+0x2c>)
	va_start(vargs, format);
    2500:	9301      	str	r3, [sp, #4]
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
    2502:	a902      	add	r1, sp, #8
    2504:	f7ff fb3a 	bl	1b7c <z_prf>
	va_end(vargs);

	*(p.ptr) = 0;
    2508:	9b02      	ldr	r3, [sp, #8]
    250a:	2200      	movs	r2, #0
    250c:	701a      	strb	r2, [r3, #0]
	return r;
}
    250e:	b004      	add	sp, #16
    2510:	f85d eb04 	ldr.w	lr, [sp], #4
    2514:	b003      	add	sp, #12
    2516:	4770      	bx	lr
    2518:	00008a77 	.word	0x00008a77

0000251c <set_lvgl_rendering_cb>:
 */

#include "lvgl_display.h"

int set_lvgl_rendering_cb(lv_disp_drv_t *disp_drv)
{
    251c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    251e:	4604      	mov	r4, r0
	int err = 0;
	struct device *display_dev = (struct device *)disp_drv->user_data;
    2520:	6a00      	ldr	r0, [r0, #32]
					    capabilities)
{
	struct display_driver_api *api =
		(struct display_driver_api *)dev->driver_api;

	api->get_capabilities(dev, capabilities);
    2522:	6843      	ldr	r3, [r0, #4]
    2524:	4669      	mov	r1, sp
    2526:	69db      	ldr	r3, [r3, #28]
    2528:	4798      	blx	r3
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);

	switch (cap.current_pixel_format) {
    252a:	f89d 200c 	ldrb.w	r2, [sp, #12]
    252e:	3a01      	subs	r2, #1
    2530:	2300      	movs	r3, #0
    2532:	2a0f      	cmp	r2, #15
    2534:	d820      	bhi.n	2578 <set_lvgl_rendering_cb+0x5c>
    2536:	e8df f002 	tbb	[pc, r2]
    253a:	190f      	.short	0x190f
    253c:	1f1f191f 	.word	0x1f1f191f
    2540:	1f1f081f 	.word	0x1f1f081f
    2544:	1f1f1f1f 	.word	0x1f1f1f1f
    2548:	141f      	.short	0x141f
	case PIXEL_FORMAT_ARGB_8888:
		disp_drv->flush_cb = lvgl_flush_cb_32bit;
    254a:	4a0e      	ldr	r2, [pc, #56]	; (2584 <set_lvgl_rendering_cb+0x68>)
		disp_drv->rounder_cb = NULL;
    254c:	e9c4 2303 	strd	r2, r3, [r4, #12]
		break;
	case PIXEL_FORMAT_MONO01:
	case PIXEL_FORMAT_MONO10:
		disp_drv->flush_cb = lvgl_flush_cb_mono;
		disp_drv->rounder_cb = lvgl_rounder_cb_mono;
		disp_drv->set_px_cb = lvgl_set_px_cb_mono;
    2550:	6163      	str	r3, [r4, #20]
	int err = 0;
    2552:	2000      	movs	r0, #0
		break;

	}

	return err;
}
    2554:	b004      	add	sp, #16
    2556:	bd10      	pop	{r4, pc}
		disp_drv->flush_cb = lvgl_flush_cb_24bit;
    2558:	4a0b      	ldr	r2, [pc, #44]	; (2588 <set_lvgl_rendering_cb+0x6c>)
		disp_drv->rounder_cb = NULL;
    255a:	e9c4 2303 	strd	r2, r3, [r4, #12]
		disp_drv->set_px_cb = lvgl_set_px_cb_24bit;
    255e:	4b0b      	ldr	r3, [pc, #44]	; (258c <set_lvgl_rendering_cb+0x70>)
    2560:	e7f6      	b.n	2550 <set_lvgl_rendering_cb+0x34>
		disp_drv->flush_cb = lvgl_flush_cb_16bit;
    2562:	4a0b      	ldr	r2, [pc, #44]	; (2590 <set_lvgl_rendering_cb+0x74>)
		disp_drv->rounder_cb = NULL;
    2564:	e9c4 2303 	strd	r2, r3, [r4, #12]
		disp_drv->set_px_cb = lvgl_set_px_cb_16bit;
    2568:	4b0a      	ldr	r3, [pc, #40]	; (2594 <set_lvgl_rendering_cb+0x78>)
    256a:	e7f1      	b.n	2550 <set_lvgl_rendering_cb+0x34>
		disp_drv->flush_cb = lvgl_flush_cb_mono;
    256c:	4b0a      	ldr	r3, [pc, #40]	; (2598 <set_lvgl_rendering_cb+0x7c>)
    256e:	60e3      	str	r3, [r4, #12]
		disp_drv->rounder_cb = lvgl_rounder_cb_mono;
    2570:	4b0a      	ldr	r3, [pc, #40]	; (259c <set_lvgl_rendering_cb+0x80>)
    2572:	6123      	str	r3, [r4, #16]
		disp_drv->set_px_cb = lvgl_set_px_cb_mono;
    2574:	4b0a      	ldr	r3, [pc, #40]	; (25a0 <set_lvgl_rendering_cb+0x84>)
    2576:	e7eb      	b.n	2550 <set_lvgl_rendering_cb+0x34>
		disp_drv->rounder_cb = NULL;
    2578:	e9c4 3303 	strd	r3, r3, [r4, #12]
		disp_drv->set_px_cb = NULL;
    257c:	6163      	str	r3, [r4, #20]
		err = -ENOTSUP;
    257e:	f06f 0022 	mvn.w	r0, #34	; 0x22
	return err;
    2582:	e7e7      	b.n	2554 <set_lvgl_rendering_cb+0x38>
    2584:	00008d27 	.word	0x00008d27
    2588:	00008c59 	.word	0x00008c59
    258c:	00008cab 	.word	0x00008cab
    2590:	00008bdf 	.word	0x00008bdf
    2594:	00008c2b 	.word	0x00008c2b
    2598:	00008a97 	.word	0x00008a97
    259c:	00008ba7 	.word	0x00008ba7
    25a0:	00008b11 	.word	0x00008b11

000025a4 <lvgl_log>:
	 * * LOG_LEVEL_ERR 1
	 * * LOG_LEVEL_WRN 2
	 * * LOG_LEVEL_INF 3
	 * * LOG_LEVEL_DBG 4
	 */
	u8_t zephyr_level = LOG_LEVEL_DBG - level;
    25a4:	f1c0 0004 	rsb	r0, r0, #4
    25a8:	b240      	sxtb	r0, r0
{
    25aa:	b410      	push	{r4}
	u8_t zephyr_level = LOG_LEVEL_DBG - level;
    25ac:	b2c4      	uxtb	r4, r0

	ARG_UNUSED(file);
	ARG_UNUSED(line);

	Z_LOG(zephyr_level, "%s", dsc);
    25ae:	2c03      	cmp	r4, #3
{
    25b0:	4619      	mov	r1, r3
	Z_LOG(zephyr_level, "%s", dsc);
    25b2:	d818      	bhi.n	25e6 <lvgl_log+0x42>
    25b4:	f04f 0300 	mov.w	r3, #0
    25b8:	f360 0302 	bfi	r3, r0, #0, #3
    25bc:	4a0b      	ldr	r2, [pc, #44]	; (25ec <lvgl_log+0x48>)
    25be:	480c      	ldr	r0, [pc, #48]	; (25f0 <lvgl_log+0x4c>)
    25c0:	1a12      	subs	r2, r2, r0
    25c2:	f36f 03c5 	bfc	r3, #3, #3
    25c6:	08d2      	lsrs	r2, r2, #3
    25c8:	2c04      	cmp	r4, #4
    25ca:	f362 138f 	bfi	r3, r2, #6, #10
    25ce:	d105      	bne.n	25dc <lvgl_log+0x38>
    25d0:	460a      	mov	r2, r1
    25d2:	4808      	ldr	r0, [pc, #32]	; (25f4 <lvgl_log+0x50>)
    25d4:	4908      	ldr	r1, [pc, #32]	; (25f8 <lvgl_log+0x54>)
}
    25d6:	bc10      	pop	{r4}
	Z_LOG(zephyr_level, "%s", dsc);
    25d8:	f005 befe 	b.w	83d8 <log_2>
    25dc:	461a      	mov	r2, r3
    25de:	4807      	ldr	r0, [pc, #28]	; (25fc <lvgl_log+0x58>)
}
    25e0:	bc10      	pop	{r4}
	Z_LOG(zephyr_level, "%s", dsc);
    25e2:	f005 bee5 	b.w	83b0 <log_1>
}
    25e6:	bc10      	pop	{r4}
    25e8:	4770      	bx	lr
    25ea:	bf00      	nop
    25ec:	0000c1ac 	.word	0x0000c1ac
    25f0:	0000c174 	.word	0x0000c174
    25f4:	00045369 	.word	0x00045369
    25f8:	0004530c 	.word	0x0004530c
    25fc:	00045405 	.word	0x00045405

00002600 <lvgl_init>:
	return 0;
}
#endif /* CONFIG_LVGL_BUFFER_ALLOC_STATIC */

static int lvgl_init(struct device *dev)
{
    2600:	b510      	push	{r4, lr}
    2602:	b08a      	sub	sp, #40	; 0x28
    2604:	482a      	ldr	r0, [pc, #168]	; (26b0 <lvgl_init+0xb0>)
    2606:	f004 fc99 	bl	6f3c <z_impl_device_get_binding>

	struct device *display_dev =
		device_get_binding(CONFIG_LVGL_DISPLAY_DEV_NAME);
	lv_disp_drv_t disp_drv;

	if (display_dev == NULL) {
    260a:	4604      	mov	r4, r0
    260c:	b990      	cbnz	r0, 2634 <lvgl_init+0x34>
		LOG_ERR("Display device not found.");
    260e:	2301      	movs	r3, #1
    2610:	f04f 0100 	mov.w	r1, #0
    2614:	f363 0107 	bfi	r1, r3, #0, #8
    2618:	4a26      	ldr	r2, [pc, #152]	; (26b4 <lvgl_init+0xb4>)
    261a:	4b27      	ldr	r3, [pc, #156]	; (26b8 <lvgl_init+0xb8>)
    261c:	4827      	ldr	r0, [pc, #156]	; (26bc <lvgl_init+0xbc>)
    261e:	1a9b      	subs	r3, r3, r2
    2620:	08db      	lsrs	r3, r3, #3
    2622:	f363 118f 	bfi	r1, r3, #6, #10
    2626:	f005 feb6 	bl	8396 <log_0>
		return -ENODEV;
    262a:	f06f 0412 	mvn.w	r4, #18
		LOG_ERR("Failed to register display device.");
		return -EPERM;
	}

	return 0;
}
    262e:	4620      	mov	r0, r4
    2630:	b00a      	add	sp, #40	; 0x28
    2632:	bd10      	pop	{r4, pc}
	lv_log_register_print_cb(lvgl_log);
    2634:	4822      	ldr	r0, [pc, #136]	; (26c0 <lvgl_init+0xc0>)
    2636:	f003 fc93 	bl	5f60 <lv_log_register_print_cb>
	lv_init();
    263a:	f001 fa4f 	bl	3adc <lv_init>
	lv_disp_drv_init(&disp_drv);
    263e:	a801      	add	r0, sp, #4
    2640:	f008 fda7 	bl	b192 <lv_disp_drv_init>
	disp_drv->buffer = &disp_buf;
    2644:	481f      	ldr	r0, [pc, #124]	; (26c4 <lvgl_init+0xc4>)
	lv_disp_buf_init(disp_drv->buffer, &buf0, NULL, NBR_PIXELS_IN_BUFFER);
    2646:	4920      	ldr	r1, [pc, #128]	; (26c8 <lvgl_init+0xc8>)
	disp_drv.user_data = (void *) display_dev;
    2648:	9409      	str	r4, [sp, #36]	; 0x24
	lv_disp_buf_init(disp_drv->buffer, &buf0, NULL, NBR_PIXELS_IN_BUFFER);
    264a:	f44f 53b4 	mov.w	r3, #5760	; 0x1680
    264e:	2200      	movs	r2, #0
	disp_drv->buffer = &disp_buf;
    2650:	9002      	str	r0, [sp, #8]
	lv_disp_buf_init(disp_drv->buffer, &buf0, NULL, NBR_PIXELS_IN_BUFFER);
    2652:	f008 fdb4 	bl	b1be <lv_disp_buf_init>
	if (set_lvgl_rendering_cb(&disp_drv) != 0) {
    2656:	a801      	add	r0, sp, #4
    2658:	f7ff ff60 	bl	251c <set_lvgl_rendering_cb>
    265c:	4604      	mov	r4, r0
    265e:	b180      	cbz	r0, 2682 <lvgl_init+0x82>
		LOG_ERR("Display not supported.");
    2660:	2301      	movs	r3, #1
    2662:	f04f 0100 	mov.w	r1, #0
    2666:	f363 0107 	bfi	r1, r3, #0, #8
    266a:	4a12      	ldr	r2, [pc, #72]	; (26b4 <lvgl_init+0xb4>)
    266c:	4b12      	ldr	r3, [pc, #72]	; (26b8 <lvgl_init+0xb8>)
    266e:	4817      	ldr	r0, [pc, #92]	; (26cc <lvgl_init+0xcc>)
    2670:	1a9b      	subs	r3, r3, r2
    2672:	08db      	lsrs	r3, r3, #3
    2674:	f363 118f 	bfi	r1, r3, #6, #10
    2678:	f005 fe8d 	bl	8396 <log_0>
		return -ENOTSUP;
    267c:	f06f 0422 	mvn.w	r4, #34	; 0x22
    2680:	e7d5      	b.n	262e <lvgl_init+0x2e>
	if (lv_disp_drv_register(&disp_drv) == NULL) {
    2682:	a801      	add	r0, sp, #4
    2684:	f003 f8e4 	bl	5850 <lv_disp_drv_register>
    2688:	2800      	cmp	r0, #0
    268a:	d1d0      	bne.n	262e <lvgl_init+0x2e>
		LOG_ERR("Failed to register display device.");
    268c:	2301      	movs	r3, #1
    268e:	f04f 0100 	mov.w	r1, #0
    2692:	f363 0107 	bfi	r1, r3, #0, #8
    2696:	4a07      	ldr	r2, [pc, #28]	; (26b4 <lvgl_init+0xb4>)
    2698:	4b07      	ldr	r3, [pc, #28]	; (26b8 <lvgl_init+0xb8>)
    269a:	480d      	ldr	r0, [pc, #52]	; (26d0 <lvgl_init+0xd0>)
    269c:	1a9b      	subs	r3, r3, r2
    269e:	08db      	lsrs	r3, r3, #3
    26a0:	f363 118f 	bfi	r1, r3, #6, #10
    26a4:	f005 fe77 	bl	8396 <log_0>
		return -EPERM;
    26a8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    26ac:	e7bf      	b.n	262e <lvgl_init+0x2e>
    26ae:	bf00      	nop
    26b0:	00044ce8 	.word	0x00044ce8
    26b4:	0000c174 	.word	0x0000c174
    26b8:	0000c1ac 	.word	0x0000c1ac
    26bc:	00045315 	.word	0x00045315
    26c0:	000025a5 	.word	0x000025a5
    26c4:	20000130 	.word	0x20000130
    26c8:	20004809 	.word	0x20004809
    26cc:	0004532f 	.word	0x0004532f
    26d0:	00045346 	.word	0x00045346

000026d4 <nordicsemi_nrf52_init>:
    26d4:	f04f 0320 	mov.w	r3, #32
    26d8:	f3ef 8211 	mrs	r2, BASEPRI
    26dc:	f383 8811 	msr	BASEPRI, r3
    26e0:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    26e4:	4906      	ldr	r1, [pc, #24]	; (2700 <nordicsemi_nrf52_init+0x2c>)
    26e6:	2301      	movs	r3, #1
    26e8:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
#endif

#if NRF_POWER_HAS_DCDCEN
NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable)
{
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
    26ec:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    26f0:	f8c1 3578 	str.w	r3, [r1, #1400]	; 0x578
	__asm__ volatile(
    26f4:	f382 8811 	msr	BASEPRI, r2
    26f8:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    26fc:	2000      	movs	r0, #0
    26fe:	4770      	bx	lr
    2700:	4001e000 	.word	0x4001e000

00002704 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    2704:	b120      	cbz	r0, 2710 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    2706:	4b03      	ldr	r3, [pc, #12]	; (2714 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
    2708:	0180      	lsls	r0, r0, #6
    270a:	f043 0301 	orr.w	r3, r3, #1
    270e:	4718      	bx	r3

void arch_busy_wait(u32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
    2710:	4770      	bx	lr
    2712:	bf00      	nop
    2714:	0000c200 	.word	0x0000c200

00002718 <counter_0_init>:
			    &nrfx_counter_##idx##_config.info,		       \
			    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,  \
			    &counter_nrfx_driver_api)

#ifdef CONFIG_COUNTER_RTC0
COUNTER_NRF_RTC_DEVICE(0);
    2718:	b5f0      	push	{r4, r5, r6, r7, lr}
    271a:	4605      	mov	r5, r0
    271c:	b085      	sub	sp, #20
    271e:	2200      	movs	r2, #0
    2720:	2101      	movs	r1, #1
    2722:	200b      	movs	r0, #11
    2724:	f7fe fd72 	bl	120c <z_arm_irq_priority_set>
	return CONTAINER_OF(dev->config->config_info,
    2728:	682b      	ldr	r3, [r5, #0]
    272a:	689b      	ldr	r3, [r3, #8]
	struct counter_top_cfg top_cfg = {
    272c:	2400      	movs	r4, #0
    272e:	f06f 467f 	mvn.w	r6, #4278190080	; 0xff000000
    2732:	e9cd 4401 	strd	r4, r4, [sp, #4]
    2736:	9403      	str	r4, [sp, #12]
    2738:	9600      	str	r6, [sp, #0]
	NRF_RTC_Type *rtc = nrfx_config->rtc;
    273a:	691f      	ldr	r7, [r3, #16]
    273c:	480c      	ldr	r0, [pc, #48]	; (2770 <counter_0_init+0x58>)
    273e:	f004 fbfd 	bl	6f3c <z_impl_device_get_binding>
	if (!clock) {
    2742:	b188      	cbz	r0, 2768 <counter_0_init+0x50>
    2744:	6843      	ldr	r3, [r0, #4]
    2746:	2101      	movs	r1, #1
    2748:	681b      	ldr	r3, [r3, #0]
    274a:	4798      	blx	r3
	NRFX_IRQ_ENABLE(NRFX_IRQ_NUMBER_GET(rtc));
    274c:	f3c7 3007 	ubfx	r0, r7, #12, #8
    p_reg->PRESCALER = val;
    2750:	f8c7 4508 	str.w	r4, [r7, #1288]	; 0x508
    2754:	f7fe fd4a 	bl	11ec <arch_irq_enable>
	get_dev_data(dev)->top = COUNTER_MAX_TOP_VALUE;
    2758:	68ab      	ldr	r3, [r5, #8]
	err = set_top_value(dev, &top_cfg);
    275a:	4669      	mov	r1, sp
	get_dev_data(dev)->top = COUNTER_MAX_TOP_VALUE;
    275c:	609e      	str	r6, [r3, #8]
	err = set_top_value(dev, &top_cfg);
    275e:	4628      	mov	r0, r5
    2760:	f006 fb3b 	bl	8dda <set_top_value>
COUNTER_NRF_RTC_DEVICE(0);
    2764:	b005      	add	sp, #20
    2766:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -ENODEV;
    2768:	f06f 0012 	mvn.w	r0, #18
COUNTER_NRF_RTC_DEVICE(0);
    276c:	e7fa      	b.n	2764 <counter_0_init+0x4c>
    276e:	bf00      	nop
    2770:	00044db1 	.word	0x00044db1

00002774 <set_cc_int_pending>:
{
    2774:	b510      	push	{r4, lr}
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    2776:	6883      	ldr	r3, [r0, #8]
    2778:	f3bf 8f5b 	dmb	ish
	atomic_or(&get_dev_data(dev)->ipend_adj, BIT(chan));
    277c:	2401      	movs	r4, #1
    277e:	fa04 f101 	lsl.w	r1, r4, r1
    2782:	3310      	adds	r3, #16
    2784:	e853 2f00 	ldrex	r2, [r3]
    2788:	430a      	orrs	r2, r1
    278a:	e843 2c00 	strex	ip, r2, [r3]
    278e:	f1bc 0f00 	cmp.w	ip, #0
    2792:	d1f7      	bne.n	2784 <set_cc_int_pending+0x10>
    2794:	f3bf 8f5b 	dmb	ish
	return CONTAINER_OF(dev->config->config_info,
    2798:	6803      	ldr	r3, [r0, #0]
	NRFX_IRQ_PENDING_SET(NRFX_IRQ_NUMBER_GET(get_nrfx_config(dev)->rtc));
    279a:	689b      	ldr	r3, [r3, #8]
    279c:	691a      	ldr	r2, [r3, #16]
    279e:	0b12      	lsrs	r2, r2, #12
    27a0:	b253      	sxtb	r3, r2
  if ((int32_t)(IRQn) >= 0)
    27a2:	2b00      	cmp	r3, #0
    27a4:	db08      	blt.n	27b8 <set_cc_int_pending+0x44>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    27a6:	095b      	lsrs	r3, r3, #5
    27a8:	f002 021f 	and.w	r2, r2, #31
    27ac:	3340      	adds	r3, #64	; 0x40
    27ae:	4903      	ldr	r1, [pc, #12]	; (27bc <set_cc_int_pending+0x48>)
    27b0:	fa04 f202 	lsl.w	r2, r4, r2
    27b4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    27b8:	bd10      	pop	{r4, pc}
    27ba:	bf00      	nop
    27bc:	e000e100 	.word	0xe000e100

000027c0 <gpio_nrfx_init>:
#endif
	}
}

static int gpio_nrfx_init(struct device *port)
{
    27c0:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
    27c2:	4b09      	ldr	r3, [pc, #36]	; (27e8 <gpio_nrfx_init+0x28>)
    27c4:	781a      	ldrb	r2, [r3, #0]
    27c6:	b96a      	cbnz	r2, 27e4 <gpio_nrfx_init+0x24>
		gpio_initialized = true;
    27c8:	2101      	movs	r1, #1
    27ca:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0,
    27cc:	2006      	movs	r0, #6
    27ce:	2105      	movs	r1, #5
    27d0:	f7fe fd1c 	bl	120c <z_arm_irq_priority_set>
			    DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0_PRIORITY,
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0);
    27d4:	2006      	movs	r0, #6
    27d6:	f7fe fd09 	bl	11ec <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
    27da:	4b04      	ldr	r3, [pc, #16]	; (27ec <gpio_nrfx_init+0x2c>)
    27dc:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    27e0:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
    27e4:	2000      	movs	r0, #0
    27e6:	bd08      	pop	{r3, pc}
    27e8:	20008b89 	.word	0x20008b89
    27ec:	40006000 	.word	0x40006000

000027f0 <gpiote_pin_int_cfg>:
{
    27f0:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return port->config->config_info;
    27f2:	6803      	ldr	r3, [r0, #0]
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
    27f4:	4d55      	ldr	r5, [pc, #340]	; (294c <gpiote_pin_int_cfg+0x15c>)
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    27f6:	689b      	ldr	r3, [r3, #8]
	struct gpio_nrfx_data *data = get_port_data(port);
    27f8:	6882      	ldr	r2, [r0, #8]
    27fa:	f8d5 4304 	ldr.w	r4, [r5, #772]	; 0x304
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    27fe:	7918      	ldrb	r0, [r3, #4]
    2800:	f001 031f 	and.w	r3, r1, #31
    2804:	ea43 1340 	orr.w	r3, r3, r0, lsl #5
    2808:	b2e4      	uxtb	r4, r4
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    280a:	2000      	movs	r0, #0
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    280c:	f500 76a2 	add.w	r6, r0, #324	; 0x144
    2810:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
    2814:	f3c6 2604 	ubfx	r6, r6, #8, #5
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
    2818:	42b3      	cmp	r3, r6
    281a:	d175      	bne.n	2908 <gpiote_pin_int_cfg+0x118>
		    && (intenset & BIT(i))) {
    281c:	fa24 f600 	lsr.w	r6, r4, r0
    2820:	07f6      	lsls	r6, r6, #31
    2822:	d571      	bpl.n	2908 <gpiote_pin_int_cfg+0x118>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
    2824:	0084      	lsls	r4, r0, #2
    2826:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
    282a:	f504 44c0 	add.w	r4, r4, #24576	; 0x6000
    282e:	f8d4 6510 	ldr.w	r6, [r4, #1296]	; 0x510
    2832:	f026 0601 	bic.w	r6, r6, #1
    2836:	f8c4 6510 	str.w	r6, [r4, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
    283a:	2401      	movs	r4, #1
    283c:	fa04 f000 	lsl.w	r0, r4, r0
    p_reg->INTENCLR = mask;
    2840:	f8c5 0308 	str.w	r0, [r5, #776]	; 0x308
NRF_STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t             pin_number,
                                              nrf_gpio_pin_sense_t sense_config)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    2844:	009c      	lsls	r4, r3, #2
    2846:	f104 44a0 	add.w	r4, r4, #1342177280	; 0x50000000
    284a:	f8d4 0700 	ldr.w	r0, [r4, #1792]	; 0x700
    284e:	f420 3040 	bic.w	r0, r0, #196608	; 0x30000

    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    2852:	f8c4 0700 	str.w	r0, [r4, #1792]	; 0x700
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
    2856:	6890      	ldr	r0, [r2, #8]
    2858:	40c8      	lsrs	r0, r1
    285a:	f010 0001 	ands.w	r0, r0, #1
    285e:	d051      	beq.n	2904 <gpiote_pin_int_cfg+0x114>
    2860:	68d0      	ldr	r0, [r2, #12]
    2862:	40c8      	lsrs	r0, r1
    2864:	f010 0001 	ands.w	r0, r0, #1
    2868:	d04c      	beq.n	2904 <gpiote_pin_int_cfg+0x114>
		if (data->trig_edge & BIT(pin)) {
    286a:	6950      	ldr	r0, [r2, #20]
    286c:	40c8      	lsrs	r0, r1
    286e:	f010 0001 	ands.w	r0, r0, #1
    2872:	d056      	beq.n	2922 <gpiote_pin_int_cfg+0x132>
			if (data->double_edge & BIT(pin)) {
    2874:	6990      	ldr	r0, [r2, #24]
    2876:	40c8      	lsrs	r0, r1
    2878:	07c0      	lsls	r0, r0, #31
    287a:	d44a      	bmi.n	2912 <gpiote_pin_int_cfg+0x122>
			} else if (((data->active_level & BIT(pin)) != 0U)
    287c:	6910      	ldr	r0, [r2, #16]
				   ^ ((BIT(pin) & data->inverted) != 0)) {
    287e:	69d2      	ldr	r2, [r2, #28]
			} else if (((data->active_level & BIT(pin)) != 0U)
    2880:	40c8      	lsrs	r0, r1
				   ^ ((BIT(pin) & data->inverted) != 0)) {
    2882:	fa22 f101 	lsr.w	r1, r2, r1
			} else if (((data->active_level & BIT(pin)) != 0U)
    2886:	f000 0001 	and.w	r0, r0, #1
    288a:	f001 0101 	and.w	r1, r1, #1
				pol = NRF_GPIOTE_POLARITY_HITOLO;
    288e:	4288      	cmp	r0, r1
    2890:	bf14      	ite	ne
    2892:	2101      	movne	r1, #1
    2894:	2102      	moveq	r1, #2
    p_reg->CONFIG[idx] = 0;
}

NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
    2896:	4d2d      	ldr	r5, [pc, #180]	; (294c <gpiote_pin_int_cfg+0x15c>)
    2898:	2400      	movs	r4, #0
    289a:	f504 72a2 	add.w	r2, r4, #324	; 0x144
    289e:	f855 0022 	ldr.w	r0, [r5, r2, lsl #2]
		if (!nrf_gpiote_te_is_enabled(NRF_GPIOTE, channel)) {
    28a2:	f010 0003 	ands.w	r0, r0, #3
    28a6:	d136      	bne.n	2916 <gpiote_pin_int_cfg+0x126>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    28a8:	00a2      	lsls	r2, r4, #2
    28aa:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    28ae:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    28b2:	021b      	lsls	r3, r3, #8
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    28b4:	f8d2 6510 	ldr.w	r6, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    28b8:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
    28bc:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    28c0:	f426 3647 	bic.w	r6, r6, #203776	; 0x31c00
			nrf_gpiote_event_t evt =
    28c4:	f104 0340 	add.w	r3, r4, #64	; 0x40
    28c8:	f426 7640 	bic.w	r6, r6, #768	; 0x300
    28cc:	009b      	lsls	r3, r3, #2
    28ce:	f8c2 6510 	str.w	r6, [r2, #1296]	; 0x510
    return ((uint32_t)p_reg + event);
    28d2:	b29b      	uxth	r3, r3
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    28d4:	f8d2 6510 	ldr.w	r6, [r2, #1296]	; 0x510
    return ((uint32_t)p_reg + event);
    28d8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    28dc:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    28e0:	4331      	orrs	r1, r6
    28e2:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    28e6:	6018      	str	r0, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
    28e8:	681b      	ldr	r3, [r3, #0]
    28ea:	9301      	str	r3, [sp, #4]
    (void)dummy;
    28ec:	9b01      	ldr	r3, [sp, #4]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    28ee:	f8d2 3510 	ldr.w	r3, [r2, #1296]	; 0x510
    28f2:	f043 0301 	orr.w	r3, r3, #1
    28f6:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
    28fa:	2301      	movs	r3, #1
    28fc:	fa03 f404 	lsl.w	r4, r3, r4
    p_reg->INTENSET = mask;
    2900:	f8c5 4304 	str.w	r4, [r5, #772]	; 0x304
}
    2904:	b002      	add	sp, #8
    2906:	bd70      	pop	{r4, r5, r6, pc}
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    2908:	3001      	adds	r0, #1
    290a:	2808      	cmp	r0, #8
    290c:	f47f af7e 	bne.w	280c <gpiote_pin_int_cfg+0x1c>
    2910:	e798      	b.n	2844 <gpiote_pin_int_cfg+0x54>
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
    2912:	2103      	movs	r1, #3
    2914:	e7bf      	b.n	2896 <gpiote_pin_int_cfg+0xa6>
    2916:	3401      	adds	r4, #1
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
    2918:	2c08      	cmp	r4, #8
    291a:	d1be      	bne.n	289a <gpiote_pin_int_cfg+0xaa>
	return -ENODEV;
    291c:	f06f 0012 	mvn.w	r0, #18
    2920:	e7f0      	b.n	2904 <gpiote_pin_int_cfg+0x114>
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
    2922:	6913      	ldr	r3, [r2, #16]
    2924:	69d2      	ldr	r2, [r2, #28]
    2926:	4053      	eors	r3, r2
    2928:	fa23 f101 	lsr.w	r1, r3, r1
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    292c:	f8d4 3700 	ldr.w	r3, [r4, #1792]	; 0x700
		return NRF_GPIO_PIN_SENSE_HIGH;
    2930:	f011 0f01 	tst.w	r1, #1
    2934:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    2938:	bf14      	ite	ne
    293a:	f44f 3200 	movne.w	r2, #131072	; 0x20000
    293e:	f44f 3240 	moveq.w	r2, #196608	; 0x30000
    2942:	4313      	orrs	r3, r2
    2944:	f8c4 3700 	str.w	r3, [r4, #1792]	; 0x700
    2948:	e7dc      	b.n	2904 <gpiote_pin_int_cfg+0x114>
    294a:	bf00      	nop
    294c:	40006000 	.word	0x40006000

00002950 <gpiote_event_handler>:
{
    2950:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    2954:	4953      	ldr	r1, [pc, #332]	; (2aa4 <gpiote_event_handler+0x154>)
    2956:	680d      	ldr	r5, [r1, #0]
	if (port_event) {
    2958:	2d00      	cmp	r5, #0
    295a:	d067      	beq.n	2a2c <gpiote_event_handler+0xdc>
	struct gpio_nrfx_data *data = get_port_data(port);
    295c:	4b52      	ldr	r3, [pc, #328]	; (2aa8 <gpiote_event_handler+0x158>)
    295e:	689a      	ldr	r2, [r3, #8]
	return port->config->config_info;
    2960:	681b      	ldr	r3, [r3, #0]
    2962:	689e      	ldr	r6, [r3, #8]
	u32_t out = data->int_en & data->pin_int_en;
    2964:	e9d2 0302 	ldrd	r0, r3, [r2, #8]
    2968:	4003      	ands	r3, r0
	out &= ~data->trig_edge & ~data->double_edge;
    296a:	e9d2 0405 	ldrd	r0, r4, [r2, #20]
    296e:	4320      	orrs	r0, r4
    2970:	ea23 0300 	bic.w	r3, r3, r0
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
    2974:	6830      	ldr	r0, [r6, #0]
	u32_t pin_states = ~(port_in ^ data->inverted ^ data->active_level);
    2976:	69d4      	ldr	r4, [r2, #28]
    2978:	6912      	ldr	r2, [r2, #16]
}


NRF_STATIC_INLINE uint32_t nrf_gpio_port_in_read(NRF_GPIO_Type const * p_reg)
{
    return p_reg->IN;
    297a:	f8d0 0510 	ldr.w	r0, [r0, #1296]	; 0x510
    297e:	4054      	eors	r4, r2
    2980:	4044      	eors	r4, r0
	u32_t out = pin_states & level_pins;
    2982:	ea23 0404 	bic.w	r4, r3, r4
	u32_t bit = 1U << pin;
    2986:	2001      	movs	r0, #1
	u32_t pin = 0U;
    2988:	2700      	movs	r7, #0
	while (level_pins) {
    298a:	2b00      	cmp	r3, #0
    298c:	d138      	bne.n	2a00 <gpiote_event_handler+0xb0>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    298e:	600b      	str	r3, [r1, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
    2990:	680b      	ldr	r3, [r1, #0]
    2992:	9300      	str	r3, [sp, #0]
    (void)dummy;
    2994:	9b00      	ldr	r3, [sp, #0]
    return p_reg->INTENSET & mask;
    2996:	4845      	ldr	r0, [pc, #276]	; (2aac <gpiote_event_handler+0x15c>)
	u32_t fired_triggers[GPIO_COUNT] = {0};
    2998:	2300      	movs	r3, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
    299a:	2601      	movs	r6, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    299c:	461f      	mov	r7, r3
    return p_reg->INTENSET & mask;
    299e:	f8d0 2304 	ldr.w	r2, [r0, #772]	; 0x304
    29a2:	fa06 f103 	lsl.w	r1, r6, r3
    29a6:	4211      	tst	r1, r2
    29a8:	d013      	beq.n	29d2 <gpiote_event_handler+0x82>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    29aa:	009a      	lsls	r2, r3, #2
    29ac:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    29b0:	f502 42c2 	add.w	r2, r2, #24832	; 0x6100
    29b4:	6811      	ldr	r1, [r2, #0]
    29b6:	b161      	cbz	r1, 29d2 <gpiote_event_handler+0x82>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    29b8:	f503 71a2 	add.w	r1, r3, #324	; 0x144
    29bc:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    29c0:	6017      	str	r7, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
    29c2:	6812      	ldr	r2, [r2, #0]
    29c4:	9201      	str	r2, [sp, #4]
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    29c6:	f3c1 2104 	ubfx	r1, r1, #8, #5
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
    29ca:	fa06 f101 	lsl.w	r1, r6, r1
    (void)dummy;
    29ce:	9a01      	ldr	r2, [sp, #4]
    29d0:	430c      	orrs	r4, r1
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    29d2:	3301      	adds	r3, #1
    29d4:	2b08      	cmp	r3, #8
    29d6:	d1e2      	bne.n	299e <gpiote_event_handler+0x4e>
	if (fired_triggers[0]) {
    29d8:	bb54      	cbnz	r4, 2a30 <gpiote_event_handler+0xe0>
	if (port_event) {
    29da:	b175      	cbz	r5, 29fa <gpiote_event_handler+0xaa>
	const struct gpio_nrfx_data *data = get_port_data(port);
    29dc:	4b32      	ldr	r3, [pc, #200]	; (2aa8 <gpiote_event_handler+0x158>)
    29de:	6899      	ldr	r1, [r3, #8]
	return port->config->config_info;
    29e0:	681b      	ldr	r3, [r3, #0]
    29e2:	689e      	ldr	r6, [r3, #8]
	u32_t out = data->int_en & data->pin_int_en;
    29e4:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    29e8:	4013      	ands	r3, r2
	out &= ~data->trig_edge & ~data->double_edge;
    29ea:	e9d1 2005 	ldrd	r2, r0, [r1, #20]
    29ee:	4302      	orrs	r2, r0
    29f0:	ea23 0302 	bic.w	r3, r3, r2
	u32_t bit = 1U << pin;
    29f4:	2401      	movs	r4, #1
	u32_t pin = 0U;
    29f6:	2500      	movs	r5, #0
	while (level_pins) {
    29f8:	bb8b      	cbnz	r3, 2a5e <gpiote_event_handler+0x10e>
}
    29fa:	b002      	add	sp, #8
    29fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (level_pins & bit) {
    2a00:	4203      	tst	r3, r0
    2a02:	d010      	beq.n	2a26 <gpiote_event_handler+0xd6>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    2a04:	f896 c004 	ldrb.w	ip, [r6, #4]
    2a08:	f007 021f 	and.w	r2, r7, #31
    2a0c:	ea42 124c 	orr.w	r2, r2, ip, lsl #5
    2a10:	0092      	lsls	r2, r2, #2
    2a12:	f102 42a0 	add.w	r2, r2, #1342177280	; 0x50000000
			level_pins &= ~bit;
    2a16:	ea23 0300 	bic.w	r3, r3, r0
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    2a1a:	f8d2 c700 	ldr.w	ip, [r2, #1792]	; 0x700
    2a1e:	f42c 3c40 	bic.w	ip, ip, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    2a22:	f8c2 c700 	str.w	ip, [r2, #1792]	; 0x700
		++pin;
    2a26:	3701      	adds	r7, #1
		bit <<= 1;
    2a28:	0040      	lsls	r0, r0, #1
    2a2a:	e7ae      	b.n	298a <gpiote_event_handler+0x3a>
	u32_t fired_triggers[GPIO_COUNT] = {0};
    2a2c:	462c      	mov	r4, r5
    2a2e:	e7b2      	b.n	2996 <gpiote_event_handler+0x46>
	struct gpio_nrfx_data *data = get_port_data(port);
    2a30:	4f1d      	ldr	r7, [pc, #116]	; (2aa8 <gpiote_event_handler+0x158>)
    2a32:	f8d7 8008 	ldr.w	r8, [r7, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    2a36:	f8d8 1000 	ldr.w	r1, [r8]
    2a3a:	2900      	cmp	r1, #0
    2a3c:	d0cd      	beq.n	29da <gpiote_event_handler+0x8a>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    2a3e:	680e      	ldr	r6, [r1, #0]
		if ((cb->pin_mask & pins) & data->int_en) {
    2a40:	f8d8 300c 	ldr.w	r3, [r8, #12]
    2a44:	688a      	ldr	r2, [r1, #8]
    2a46:	4023      	ands	r3, r4
    2a48:	4213      	tst	r3, r2
    2a4a:	d003      	beq.n	2a54 <gpiote_event_handler+0x104>
			cb->handler(port, cb, pins);
    2a4c:	684b      	ldr	r3, [r1, #4]
    2a4e:	4622      	mov	r2, r4
    2a50:	4638      	mov	r0, r7
    2a52:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    2a54:	2e00      	cmp	r6, #0
    2a56:	d0c0      	beq.n	29da <gpiote_event_handler+0x8a>
    2a58:	4631      	mov	r1, r6
    2a5a:	6836      	ldr	r6, [r6, #0]
    2a5c:	e7f0      	b.n	2a40 <gpiote_event_handler+0xf0>
		if (level_pins & bit) {
    2a5e:	421c      	tst	r4, r3
    2a60:	d01c      	beq.n	2a9c <gpiote_event_handler+0x14c>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    2a62:	7930      	ldrb	r0, [r6, #4]
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
    2a64:	69cf      	ldr	r7, [r1, #28]
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    2a66:	f005 021f 	and.w	r2, r5, #31
    2a6a:	ea42 1240 	orr.w	r2, r2, r0, lsl #5
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
    2a6e:	6908      	ldr	r0, [r1, #16]
    2a70:	0092      	lsls	r2, r2, #2
    2a72:	4078      	eors	r0, r7
    2a74:	f102 42a0 	add.w	r2, r2, #1342177280	; 0x50000000
    2a78:	40e8      	lsrs	r0, r5
		return NRF_GPIO_PIN_SENSE_HIGH;
    2a7a:	f010 0f01 	tst.w	r0, #1
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    2a7e:	f8d2 0700 	ldr.w	r0, [r2, #1792]	; 0x700
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    2a82:	bf18      	it	ne
    2a84:	f44f 3700 	movne.w	r7, #131072	; 0x20000
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    2a88:	f420 3040 	bic.w	r0, r0, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    2a8c:	bf08      	it	eq
    2a8e:	f44f 3740 	moveq.w	r7, #196608	; 0x30000
    2a92:	4338      	orrs	r0, r7
    2a94:	f8c2 0700 	str.w	r0, [r2, #1792]	; 0x700
			level_pins &= ~bit;
    2a98:	ea23 0304 	bic.w	r3, r3, r4
		++pin;
    2a9c:	3501      	adds	r5, #1
		bit <<= 1;
    2a9e:	0064      	lsls	r4, r4, #1
    2aa0:	e7aa      	b.n	29f8 <gpiote_event_handler+0xa8>
    2aa2:	bf00      	nop
    2aa4:	4000617c 	.word	0x4000617c
    2aa8:	2000a200 	.word	0x2000a200
    2aac:	40006000 	.word	0x40006000

00002ab0 <twi_1_init>:
#ifdef CONFIG_I2C_0_NRF_TWI
I2C_NRFX_TWI_DEVICE(0);
#endif

#ifdef CONFIG_I2C_1_NRF_TWI
I2C_NRFX_TWI_DEVICE(1);
    2ab0:	b510      	push	{r4, lr}
    2ab2:	4604      	mov	r4, r0
    2ab4:	2200      	movs	r2, #0
    2ab6:	2101      	movs	r1, #1
    2ab8:	2004      	movs	r0, #4
    2aba:	f7fe fba7 	bl	120c <z_arm_irq_priority_set>
	return dev->config->config_info;
    2abe:	6823      	ldr	r3, [r4, #0]
	nrfx_err_t result = nrfx_twi_init(&get_dev_config(dev)->twi,
    2ac0:	4a0f      	ldr	r2, [pc, #60]	; (2b00 <twi_1_init+0x50>)
	return dev->config->config_info;
    2ac2:	6898      	ldr	r0, [r3, #8]
	nrfx_err_t result = nrfx_twi_init(&get_dev_config(dev)->twi,
    2ac4:	4623      	mov	r3, r4
    2ac6:	f100 0108 	add.w	r1, r0, #8
    2aca:	f000 fe8f 	bl	37ec <nrfx_twi_init>
	if (result != NRFX_SUCCESS) {
    2ace:	4b0d      	ldr	r3, [pc, #52]	; (2b04 <twi_1_init+0x54>)
    2ad0:	4298      	cmp	r0, r3
    2ad2:	d012      	beq.n	2afa <twi_1_init+0x4a>
		LOG_ERR("Failed to initialize device: %s",
    2ad4:	2301      	movs	r3, #1
    2ad6:	f04f 0200 	mov.w	r2, #0
    2ada:	f363 0207 	bfi	r2, r3, #0, #8
    2ade:	490a      	ldr	r1, [pc, #40]	; (2b08 <twi_1_init+0x58>)
    2ae0:	4b0a      	ldr	r3, [pc, #40]	; (2b0c <twi_1_init+0x5c>)
    2ae2:	480b      	ldr	r0, [pc, #44]	; (2b10 <twi_1_init+0x60>)
    2ae4:	1a5b      	subs	r3, r3, r1
    2ae6:	08db      	lsrs	r3, r3, #3
    2ae8:	f363 128f 	bfi	r2, r3, #6, #10
    2aec:	6823      	ldr	r3, [r4, #0]
    2aee:	6819      	ldr	r1, [r3, #0]
    2af0:	f005 fc5e 	bl	83b0 <log_1>
		return -EBUSY;
    2af4:	f06f 000f 	mvn.w	r0, #15
I2C_NRFX_TWI_DEVICE(1);
    2af8:	bd10      	pop	{r4, pc}
	return 0;
    2afa:	2000      	movs	r0, #0
I2C_NRFX_TWI_DEVICE(1);
    2afc:	e7fc      	b.n	2af8 <twi_1_init+0x48>
    2afe:	bf00      	nop
    2b00:	00002c79 	.word	0x00002c79
    2b04:	0bad0000 	.word	0x0bad0000
    2b08:	0000c174 	.word	0x0000c174
    2b0c:	0000c19c 	.word	0x0000c19c
    2b10:	000453e8 	.word	0x000453e8

00002b14 <i2c_nrfx_twi_configure>:
{
    2b14:	b508      	push	{r3, lr}
	return dev->config->config_info;
    2b16:	6803      	ldr	r3, [r0, #0]
	if (I2C_ADDR_10_BITS & dev_config) {
    2b18:	07ca      	lsls	r2, r1, #31
	return dev->config->config_info;
    2b1a:	689b      	ldr	r3, [r3, #8]
	if (I2C_ADDR_10_BITS & dev_config) {
    2b1c:	d413      	bmi.n	2b46 <i2c_nrfx_twi_configure+0x32>
	switch (I2C_SPEED_GET(dev_config)) {
    2b1e:	f3c1 0242 	ubfx	r2, r1, #1, #3
    2b22:	2a01      	cmp	r2, #1
    2b24:	d012      	beq.n	2b4c <i2c_nrfx_twi_configure+0x38>
    2b26:	2a02      	cmp	r2, #2
    2b28:	d019      	beq.n	2b5e <i2c_nrfx_twi_configure+0x4a>
		LOG_ERR("unsupported speed");
    2b2a:	2301      	movs	r3, #1
    2b2c:	f04f 0100 	mov.w	r1, #0
    2b30:	f363 0107 	bfi	r1, r3, #0, #8
    2b34:	4a0c      	ldr	r2, [pc, #48]	; (2b68 <i2c_nrfx_twi_configure+0x54>)
    2b36:	4b0d      	ldr	r3, [pc, #52]	; (2b6c <i2c_nrfx_twi_configure+0x58>)
    2b38:	480d      	ldr	r0, [pc, #52]	; (2b70 <i2c_nrfx_twi_configure+0x5c>)
    2b3a:	1a9b      	subs	r3, r3, r2
    2b3c:	08db      	lsrs	r3, r3, #3
    2b3e:	f363 118f 	bfi	r1, r3, #6, #10
    2b42:	f005 fc28 	bl	8396 <log_0>
		return -EINVAL;
    2b46:	f06f 0015 	mvn.w	r0, #21
    2b4a:	e007      	b.n	2b5c <i2c_nrfx_twi_configure+0x48>
		nrf_twi_frequency_set(inst->p_twi, NRF_TWI_FREQ_100K);
    2b4c:	681b      	ldr	r3, [r3, #0]
}

NRF_STATIC_INLINE void nrf_twi_frequency_set(NRF_TWI_Type *      p_reg,
                                             nrf_twi_frequency_t frequency)
{
    p_reg->FREQUENCY = frequency;
    2b4e:	f04f 72cc 	mov.w	r2, #26738688	; 0x1980000
    2b52:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	get_dev_data(dev)->dev_config = dev_config;
    2b56:	6883      	ldr	r3, [r0, #8]
	return 0;
    2b58:	2000      	movs	r0, #0
	get_dev_data(dev)->dev_config = dev_config;
    2b5a:	6259      	str	r1, [r3, #36]	; 0x24
}
    2b5c:	bd08      	pop	{r3, pc}
		nrf_twi_frequency_set(inst->p_twi, NRF_TWI_FREQ_400K);
    2b5e:	681b      	ldr	r3, [r3, #0]
    2b60:	f04f 62cd 	mov.w	r2, #107479040	; 0x6680000
    2b64:	e7f5      	b.n	2b52 <i2c_nrfx_twi_configure+0x3e>
    2b66:	bf00      	nop
    2b68:	0000c174 	.word	0x0000c174
    2b6c:	0000c19c 	.word	0x0000c19c
    2b70:	000453a2 	.word	0x000453a2

00002b74 <i2c_nrfx_twi_transfer>:
{
    2b74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2b78:	4605      	mov	r5, r0
    2b7a:	b087      	sub	sp, #28
    2b7c:	460c      	mov	r4, r1
    2b7e:	4617      	mov	r7, r2
    2b80:	4699      	mov	r9, r3
	k_sem_take(&(get_dev_data(dev)->transfer_sync), K_FOREVER);
    2b82:	6880      	ldr	r0, [r0, #8]
    2b84:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2b88:	f004 ffaa 	bl	7ae0 <z_impl_k_sem_take>
	return dev->config->config_info;
    2b8c:	682b      	ldr	r3, [r5, #0]
		if (res != NRFX_SUCCESS) {
    2b8e:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 2c74 <i2c_nrfx_twi_transfer+0x100>
	nrfx_twi_enable(&get_dev_config(dev)->twi);
    2b92:	6898      	ldr	r0, [r3, #8]
    2b94:	f000 fe6e 	bl	3874 <nrfx_twi_enable>
	for (size_t i = 0; i < num_msgs; i++) {
    2b98:	2600      	movs	r6, #0
    2b9a:	42be      	cmp	r6, r7
    2b9c:	d301      	bcc.n	2ba2 <i2c_nrfx_twi_transfer+0x2e>
	int ret = 0;
    2b9e:	2400      	movs	r4, #0
    2ba0:	e02e      	b.n	2c00 <i2c_nrfx_twi_transfer+0x8c>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
    2ba2:	f894 b008 	ldrb.w	fp, [r4, #8]
    2ba6:	f01b 0a08 	ands.w	sl, fp, #8
    2baa:	d158      	bne.n	2c5e <i2c_nrfx_twi_transfer+0xea>
		nrfx_twi_xfer_desc_t cur_xfer = {
    2bac:	2212      	movs	r2, #18
    2bae:	4651      	mov	r1, sl
    2bb0:	f10d 0006 	add.w	r0, sp, #6
    2bb4:	f005 fec6 	bl	8944 <memset>
    2bb8:	6862      	ldr	r2, [r4, #4]
    2bba:	9202      	str	r2, [sp, #8]
					  NRFX_TWI_XFER_RX : NRFX_TWI_XFER_TX
    2bbc:	f00b 0301 	and.w	r3, fp, #1
		nrfx_twi_xfer_desc_t cur_xfer = {
    2bc0:	6822      	ldr	r2, [r4, #0]
    2bc2:	f88d 3004 	strb.w	r3, [sp, #4]
		if (!(msgs[i].flags & I2C_MSG_STOP)) {
    2bc6:	f01b 0f02 	tst.w	fp, #2
		nrfx_twi_xfer_desc_t cur_xfer = {
    2bca:	f88d 9005 	strb.w	r9, [sp, #5]
    2bce:	9204      	str	r2, [sp, #16]
		if (!(msgs[i].flags & I2C_MSG_STOP)) {
    2bd0:	d121      	bne.n	2c16 <i2c_nrfx_twi_transfer+0xa2>
			if ((i < (num_msgs - 1)) &&
    2bd2:	1e7a      	subs	r2, r7, #1
    2bd4:	42b2      	cmp	r2, r6
    2bd6:	d902      	bls.n	2bde <i2c_nrfx_twi_transfer+0x6a>
    2bd8:	7d22      	ldrb	r2, [r4, #20]
    2bda:	0752      	lsls	r2, r2, #29
    2bdc:	d51d      	bpl.n	2c1a <i2c_nrfx_twi_transfer+0xa6>
			} else if (msgs[i].flags & I2C_MSG_READ) {
    2bde:	2b00      	cmp	r3, #0
    2be0:	d13d      	bne.n	2c5e <i2c_nrfx_twi_transfer+0xea>
				xfer_flags |= NRFX_TWI_FLAG_TX_NO_STOP;
    2be2:	2220      	movs	r2, #32
	return dev->config->config_info;
    2be4:	682b      	ldr	r3, [r5, #0]
		res = nrfx_twi_xfer(&get_dev_config(dev)->twi,
    2be6:	a901      	add	r1, sp, #4
    2be8:	6898      	ldr	r0, [r3, #8]
    2bea:	f000 fe6d 	bl	38c8 <nrfx_twi_xfer>
		if (res != NRFX_SUCCESS) {
    2bee:	4540      	cmp	r0, r8
    2bf0:	d015      	beq.n	2c1e <i2c_nrfx_twi_transfer+0xaa>
			if (res == NRFX_ERROR_BUSY) {
    2bf2:	4b1c      	ldr	r3, [pc, #112]	; (2c64 <i2c_nrfx_twi_transfer+0xf0>)
				ret = -EIO;
    2bf4:	4298      	cmp	r0, r3
    2bf6:	bf0c      	ite	eq
    2bf8:	f06f 040f 	mvneq.w	r4, #15
    2bfc:	f06f 0404 	mvnne.w	r4, #4
	return dev->config->config_info;
    2c00:	682b      	ldr	r3, [r5, #0]
	nrfx_twi_disable(&get_dev_config(dev)->twi);
    2c02:	6898      	ldr	r0, [r3, #8]
    2c04:	f000 fe46 	bl	3894 <nrfx_twi_disable>
	k_sem_give(&(get_dev_data(dev)->transfer_sync));
    2c08:	68a8      	ldr	r0, [r5, #8]
	z_impl_k_sem_give(sem);
    2c0a:	f004 ff43 	bl	7a94 <z_impl_k_sem_give>
}
    2c0e:	4620      	mov	r0, r4
    2c10:	b007      	add	sp, #28
    2c12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		u32_t xfer_flags = 0;
    2c16:	4652      	mov	r2, sl
    2c18:	e7e4      	b.n	2be4 <i2c_nrfx_twi_transfer+0x70>
				xfer_flags |= NRFX_TWI_FLAG_SUSPEND;
    2c1a:	2240      	movs	r2, #64	; 0x40
    2c1c:	e7e2      	b.n	2be4 <i2c_nrfx_twi_transfer+0x70>
		k_sem_take(&(get_dev_data(dev)->completion_sync), K_FOREVER);
    2c1e:	68a8      	ldr	r0, [r5, #8]
    2c20:	3010      	adds	r0, #16
	return z_impl_k_sem_take(sem, timeout);
    2c22:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2c26:	f004 ff5b 	bl	7ae0 <z_impl_k_sem_take>
		res = get_dev_data(dev)->res;
    2c2a:	68ab      	ldr	r3, [r5, #8]
    2c2c:	6a19      	ldr	r1, [r3, #32]
		if (res != NRFX_SUCCESS) {
    2c2e:	4541      	cmp	r1, r8
    2c30:	f104 040c 	add.w	r4, r4, #12
    2c34:	d011      	beq.n	2c5a <i2c_nrfx_twi_transfer+0xe6>
			LOG_ERR("Error %d occurred for message %d", res, i);
    2c36:	2201      	movs	r2, #1
    2c38:	f04f 0300 	mov.w	r3, #0
    2c3c:	f362 0307 	bfi	r3, r2, #0, #8
    2c40:	4809      	ldr	r0, [pc, #36]	; (2c68 <i2c_nrfx_twi_transfer+0xf4>)
    2c42:	4a0a      	ldr	r2, [pc, #40]	; (2c6c <i2c_nrfx_twi_transfer+0xf8>)
    2c44:	1a12      	subs	r2, r2, r0
    2c46:	08d2      	lsrs	r2, r2, #3
    2c48:	f362 138f 	bfi	r3, r2, #6, #10
    2c4c:	4808      	ldr	r0, [pc, #32]	; (2c70 <i2c_nrfx_twi_transfer+0xfc>)
    2c4e:	4632      	mov	r2, r6
    2c50:	f005 fbc2 	bl	83d8 <log_2>
			ret = -EIO;
    2c54:	f06f 0404 	mvn.w	r4, #4
			break;
    2c58:	e7d2      	b.n	2c00 <i2c_nrfx_twi_transfer+0x8c>
	for (size_t i = 0; i < num_msgs; i++) {
    2c5a:	3601      	adds	r6, #1
    2c5c:	e79d      	b.n	2b9a <i2c_nrfx_twi_transfer+0x26>
			ret = -ENOTSUP;
    2c5e:	f06f 0422 	mvn.w	r4, #34	; 0x22
    2c62:	e7cd      	b.n	2c00 <i2c_nrfx_twi_transfer+0x8c>
    2c64:	0bad000b 	.word	0x0bad000b
    2c68:	0000c174 	.word	0x0000c174
    2c6c:	0000c19c 	.word	0x0000c19c
    2c70:	000453b4 	.word	0x000453b4
    2c74:	0bad0000 	.word	0x0bad0000

00002c78 <event_handler>:
	switch (p_event->type) {
    2c78:	7802      	ldrb	r2, [r0, #0]
	struct i2c_nrfx_twi_data *dev_data = get_dev_data(dev);
    2c7a:	688b      	ldr	r3, [r1, #8]
	switch (p_event->type) {
    2c7c:	2a01      	cmp	r2, #1
    2c7e:	d00a      	beq.n	2c96 <event_handler+0x1e>
    2c80:	b11a      	cbz	r2, 2c8a <event_handler+0x12>
    2c82:	2a02      	cmp	r2, #2
    2c84:	d009      	beq.n	2c9a <event_handler+0x22>
		dev_data->res = NRFX_ERROR_INTERNAL;
    2c86:	4a06      	ldr	r2, [pc, #24]	; (2ca0 <event_handler+0x28>)
    2c88:	e000      	b.n	2c8c <event_handler+0x14>
		dev_data->res = NRFX_SUCCESS;
    2c8a:	4a06      	ldr	r2, [pc, #24]	; (2ca4 <event_handler+0x2c>)
		dev_data->res = NRFX_ERROR_INTERNAL;
    2c8c:	621a      	str	r2, [r3, #32]
	z_impl_k_sem_give(sem);
    2c8e:	f103 0010 	add.w	r0, r3, #16
    2c92:	f004 beff 	b.w	7a94 <z_impl_k_sem_give>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
    2c96:	4a04      	ldr	r2, [pc, #16]	; (2ca8 <event_handler+0x30>)
    2c98:	e7f8      	b.n	2c8c <event_handler+0x14>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
    2c9a:	4a04      	ldr	r2, [pc, #16]	; (2cac <event_handler+0x34>)
    2c9c:	e7f6      	b.n	2c8c <event_handler+0x14>
    2c9e:	bf00      	nop
    2ca0:	0bad0001 	.word	0x0bad0001
    2ca4:	0bad0000 	.word	0x0bad0000
    2ca8:	0bae0001 	.word	0x0bae0001
    2cac:	0bae0002 	.word	0x0bae0002

00002cb0 <spi_0_init>:
		      &spi_##idx##z_config,				       \
		      POST_KERNEL, CONFIG_SPI_INIT_PRIORITY,		       \
		      &spi_nrfx_driver_api)

#ifdef CONFIG_SPI_0_NRF_SPI
SPI_NRFX_SPI_DEVICE(0);
    2cb0:	b510      	push	{r4, lr}
    2cb2:	4604      	mov	r4, r0
    2cb4:	2200      	movs	r2, #0
    2cb6:	2101      	movs	r1, #1
    2cb8:	2003      	movs	r0, #3
    2cba:	f7fe faa7 	bl	120c <z_arm_irq_priority_set>
	return dev->config->config_info;
    2cbe:	6823      	ldr	r3, [r4, #0]
	nrfx_err_t result = nrfx_spi_init(&get_dev_config(dev)->spi,
    2cc0:	4a10      	ldr	r2, [pc, #64]	; (2d04 <spi_0_init+0x54>)
	return dev->config->config_info;
    2cc2:	6898      	ldr	r0, [r3, #8]
	nrfx_err_t result = nrfx_spi_init(&get_dev_config(dev)->spi,
    2cc4:	4623      	mov	r3, r4
    2cc6:	f100 0108 	add.w	r1, r0, #8
    2cca:	f000 fb4f 	bl	336c <nrfx_spi_init>
	if (result != NRFX_SUCCESS) {
    2cce:	4b0e      	ldr	r3, [pc, #56]	; (2d08 <spi_0_init+0x58>)
    2cd0:	4298      	cmp	r0, r3
    2cd2:	d012      	beq.n	2cfa <spi_0_init+0x4a>
		LOG_ERR("Failed to initialize device: %s",
    2cd4:	2301      	movs	r3, #1
    2cd6:	f04f 0200 	mov.w	r2, #0
    2cda:	f363 0207 	bfi	r2, r3, #0, #8
    2cde:	490b      	ldr	r1, [pc, #44]	; (2d0c <spi_0_init+0x5c>)
    2ce0:	4b0b      	ldr	r3, [pc, #44]	; (2d10 <spi_0_init+0x60>)
    2ce2:	480c      	ldr	r0, [pc, #48]	; (2d14 <spi_0_init+0x64>)
    2ce4:	1a5b      	subs	r3, r3, r1
    2ce6:	08db      	lsrs	r3, r3, #3
    2ce8:	f363 128f 	bfi	r2, r3, #6, #10
    2cec:	6823      	ldr	r3, [r4, #0]
    2cee:	6819      	ldr	r1, [r3, #0]
    2cf0:	f005 fb5e 	bl	83b0 <log_1>
		return -EBUSY;
    2cf4:	f06f 000f 	mvn.w	r0, #15
SPI_NRFX_SPI_DEVICE(0);
    2cf8:	bd10      	pop	{r4, pc}
	spi_context_unlock_unconditionally(&get_dev_data(dev)->ctx);
    2cfa:	68a0      	ldr	r0, [r4, #8]
    2cfc:	f006 fbe8 	bl	94d0 <spi_context_unlock_unconditionally>
	return 0;
    2d00:	2000      	movs	r0, #0
SPI_NRFX_SPI_DEVICE(0);
    2d02:	e7f9      	b.n	2cf8 <spi_0_init+0x48>
    2d04:	00002d99 	.word	0x00002d99
    2d08:	0bad0000 	.word	0x0bad0000
    2d0c:	0000c174 	.word	0x0000c174
    2d10:	0000c1d4 	.word	0x0000c1d4
    2d14:	000453e8 	.word	0x000453e8

00002d18 <transfer_next_chunk>:
{
    2d18:	b530      	push	{r4, r5, lr}
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    2d1a:	6885      	ldr	r5, [r0, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
}

static inline size_t spi_context_longest_current_buf(struct spi_context *ctx)
{
	if (!ctx->tx_len) {
    2d1c:	6bea      	ldr	r2, [r5, #60]	; 0x3c
    2d1e:	6c6b      	ldr	r3, [r5, #68]	; 0x44
{
    2d20:	b085      	sub	sp, #20
    2d22:	b982      	cbnz	r2, 2d46 <transfer_next_chunk+0x2e>
	if (chunk_len > 0) {
    2d24:	bb7b      	cbnz	r3, 2d86 <transfer_next_chunk+0x6e>
	int error = 0;
    2d26:	461c      	mov	r4, r3
	_spi_context_cs_control(ctx, on, false);
    2d28:	2200      	movs	r2, #0
    2d2a:	4611      	mov	r1, r2
    2d2c:	4628      	mov	r0, r5
    2d2e:	f006 fba5 	bl	947c <_spi_context_cs_control.isra.7>
	ctx->sync_status = status;
    2d32:	626c      	str	r4, [r5, #36]	; 0x24
    2d34:	f105 0014 	add.w	r0, r5, #20
    2d38:	f004 feac 	bl	7a94 <z_impl_k_sem_give>
	dev_data->busy = false;
    2d3c:	2300      	movs	r3, #0
    2d3e:	f885 304c 	strb.w	r3, [r5, #76]	; 0x4c
}
    2d42:	b005      	add	sp, #20
    2d44:	bd30      	pop	{r4, r5, pc}
		return ctx->rx_len;
	} else if (!ctx->rx_len) {
    2d46:	4611      	mov	r1, r2
    2d48:	b113      	cbz	r3, 2d50 <transfer_next_chunk+0x38>
		return ctx->tx_len;
	} else if (ctx->tx_len < ctx->rx_len) {
    2d4a:	429a      	cmp	r2, r3
    2d4c:	bf28      	it	cs
    2d4e:	4619      	movcs	r1, r3
		xfer.p_tx_buffer = ctx->tx_buf;
    2d50:	6bac      	ldr	r4, [r5, #56]	; 0x38
		dev_data->chunk_len = chunk_len;
    2d52:	64a9      	str	r1, [r5, #72]	; 0x48
		xfer.p_tx_buffer = ctx->tx_buf;
    2d54:	9400      	str	r4, [sp, #0]
	return !!(ctx->tx_buf && ctx->tx_len);
    2d56:	b1c4      	cbz	r4, 2d8a <transfer_next_chunk+0x72>
    2d58:	2a00      	cmp	r2, #0
    2d5a:	bf18      	it	ne
    2d5c:	460a      	movne	r2, r1
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    2d5e:	9201      	str	r2, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
    2d60:	6c2a      	ldr	r2, [r5, #64]	; 0x40
    2d62:	9202      	str	r2, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
    2d64:	b19a      	cbz	r2, 2d8e <transfer_next_chunk+0x76>
    2d66:	2b00      	cmp	r3, #0
    2d68:	bf18      	it	ne
    2d6a:	460b      	movne	r3, r1
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    2d6c:	9303      	str	r3, [sp, #12]
	return dev->config->config_info;
    2d6e:	6803      	ldr	r3, [r0, #0]
		result = nrfx_spi_xfer(&get_dev_config(dev)->spi, &xfer, 0);
    2d70:	2200      	movs	r2, #0
    2d72:	6898      	ldr	r0, [r3, #8]
    2d74:	4669      	mov	r1, sp
    2d76:	f000 fb9f 	bl	34b8 <nrfx_spi_xfer>
		if (result == NRFX_SUCCESS) {
    2d7a:	4b06      	ldr	r3, [pc, #24]	; (2d94 <transfer_next_chunk+0x7c>)
    2d7c:	4298      	cmp	r0, r3
    2d7e:	d0e0      	beq.n	2d42 <transfer_next_chunk+0x2a>
		error = -EIO;
    2d80:	f06f 0404 	mvn.w	r4, #4
    2d84:	e7d0      	b.n	2d28 <transfer_next_chunk+0x10>
    2d86:	4619      	mov	r1, r3
    2d88:	e7e2      	b.n	2d50 <transfer_next_chunk+0x38>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    2d8a:	4622      	mov	r2, r4
    2d8c:	e7e7      	b.n	2d5e <transfer_next_chunk+0x46>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    2d8e:	4613      	mov	r3, r2
    2d90:	e7ec      	b.n	2d6c <transfer_next_chunk+0x54>
    2d92:	bf00      	nop
    2d94:	0bad0000 	.word	0x0bad0000

00002d98 <event_handler>:
{
    2d98:	b538      	push	{r3, r4, r5, lr}
	if (p_event->type == NRFX_SPI_EVENT_DONE) {
    2d9a:	7803      	ldrb	r3, [r0, #0]
{
    2d9c:	460d      	mov	r5, r1
	if (p_event->type == NRFX_SPI_EVENT_DONE) {
    2d9e:	2b00      	cmp	r3, #0
    2da0:	d157      	bne.n	2e52 <event_handler+0xba>
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    2da2:	688c      	ldr	r4, [r1, #8]
	if (!ctx->tx_len) {
    2da4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    2da6:	b183      	cbz	r3, 2dca <event_handler+0x32>
		spi_context_update_tx(&dev_data->ctx, 1, dev_data->chunk_len);
    2da8:	6ca2      	ldr	r2, [r4, #72]	; 0x48
	if (len > ctx->tx_len) {
    2daa:	429a      	cmp	r2, r3
    2dac:	d925      	bls.n	2dfa <event_handler+0x62>
		LOG_ERR("Update exceeds current buffer");
    2dae:	2301      	movs	r3, #1
    2db0:	f04f 0100 	mov.w	r1, #0
    2db4:	f363 0107 	bfi	r1, r3, #0, #8
    2db8:	4a26      	ldr	r2, [pc, #152]	; (2e54 <event_handler+0xbc>)
    2dba:	4b27      	ldr	r3, [pc, #156]	; (2e58 <event_handler+0xc0>)
    2dbc:	4827      	ldr	r0, [pc, #156]	; (2e5c <event_handler+0xc4>)
    2dbe:	1a9b      	subs	r3, r3, r2
    2dc0:	08db      	lsrs	r3, r3, #3
    2dc2:	f363 118f 	bfi	r1, r3, #6, #10
    2dc6:	f005 fae6 	bl	8396 <log_0>
	if (!ctx->rx_len) {
    2dca:	6c63      	ldr	r3, [r4, #68]	; 0x44
    2dcc:	b183      	cbz	r3, 2df0 <event_handler+0x58>
		spi_context_update_rx(&dev_data->ctx, 1, dev_data->chunk_len);
    2dce:	6ca2      	ldr	r2, [r4, #72]	; 0x48
	if (len > ctx->rx_len) {
    2dd0:	429a      	cmp	r2, r3
    2dd2:	d928      	bls.n	2e26 <event_handler+0x8e>
		LOG_ERR("Update exceeds current buffer");
    2dd4:	2301      	movs	r3, #1
    2dd6:	f04f 0100 	mov.w	r1, #0
    2dda:	f363 0107 	bfi	r1, r3, #0, #8
    2dde:	4a1d      	ldr	r2, [pc, #116]	; (2e54 <event_handler+0xbc>)
    2de0:	4b1d      	ldr	r3, [pc, #116]	; (2e58 <event_handler+0xc0>)
    2de2:	481e      	ldr	r0, [pc, #120]	; (2e5c <event_handler+0xc4>)
    2de4:	1a9b      	subs	r3, r3, r2
    2de6:	08db      	lsrs	r3, r3, #3
    2de8:	f363 118f 	bfi	r1, r3, #6, #10
    2dec:	f005 fad3 	bl	8396 <log_0>
		transfer_next_chunk(dev);
    2df0:	4628      	mov	r0, r5
}
    2df2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		transfer_next_chunk(dev);
    2df6:	f7ff bf8f 	b.w	2d18 <transfer_next_chunk>
	ctx->tx_len -= len;
    2dfa:	1a9b      	subs	r3, r3, r2
    2dfc:	63e3      	str	r3, [r4, #60]	; 0x3c
	if (!ctx->tx_len) {
    2dfe:	b963      	cbnz	r3, 2e1a <event_handler+0x82>
		ctx->tx_count--;
    2e00:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2e02:	3b01      	subs	r3, #1
    2e04:	62e3      	str	r3, [r4, #44]	; 0x2c
		if (ctx->tx_count) {
    2e06:	b163      	cbz	r3, 2e22 <event_handler+0x8a>
			ctx->current_tx++;
    2e08:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2e0a:	f103 0208 	add.w	r2, r3, #8
    2e0e:	62a2      	str	r2, [r4, #40]	; 0x28
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    2e10:	689a      	ldr	r2, [r3, #8]
			ctx->tx_len = ctx->current_tx->len / dfs;
    2e12:	68db      	ldr	r3, [r3, #12]
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    2e14:	63a2      	str	r2, [r4, #56]	; 0x38
			ctx->tx_len = ctx->current_tx->len / dfs;
    2e16:	63e3      	str	r3, [r4, #60]	; 0x3c
    2e18:	e7d7      	b.n	2dca <event_handler+0x32>
	} else if (ctx->tx_buf) {
    2e1a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    2e1c:	2b00      	cmp	r3, #0
    2e1e:	d0d4      	beq.n	2dca <event_handler+0x32>
		ctx->tx_buf += dfs * len;
    2e20:	4413      	add	r3, r2
    2e22:	63a3      	str	r3, [r4, #56]	; 0x38
    2e24:	e7d1      	b.n	2dca <event_handler+0x32>
	ctx->rx_len -= len;
    2e26:	1a9b      	subs	r3, r3, r2
    2e28:	6463      	str	r3, [r4, #68]	; 0x44
	if (!ctx->rx_len) {
    2e2a:	b963      	cbnz	r3, 2e46 <event_handler+0xae>
		ctx->rx_count--;
    2e2c:	6b63      	ldr	r3, [r4, #52]	; 0x34
    2e2e:	3b01      	subs	r3, #1
    2e30:	6363      	str	r3, [r4, #52]	; 0x34
		if (ctx->rx_count) {
    2e32:	b163      	cbz	r3, 2e4e <event_handler+0xb6>
			ctx->current_rx++;
    2e34:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2e36:	f103 0208 	add.w	r2, r3, #8
    2e3a:	6322      	str	r2, [r4, #48]	; 0x30
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    2e3c:	689a      	ldr	r2, [r3, #8]
			ctx->rx_len = ctx->current_rx->len / dfs;
    2e3e:	68db      	ldr	r3, [r3, #12]
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    2e40:	6422      	str	r2, [r4, #64]	; 0x40
			ctx->rx_len = ctx->current_rx->len / dfs;
    2e42:	6463      	str	r3, [r4, #68]	; 0x44
    2e44:	e7d4      	b.n	2df0 <event_handler+0x58>
	} else if (ctx->rx_buf) {
    2e46:	6c23      	ldr	r3, [r4, #64]	; 0x40
    2e48:	2b00      	cmp	r3, #0
    2e4a:	d0d1      	beq.n	2df0 <event_handler+0x58>
		ctx->rx_buf += dfs * len;
    2e4c:	4413      	add	r3, r2
    2e4e:	6423      	str	r3, [r4, #64]	; 0x40
    2e50:	e7ce      	b.n	2df0 <event_handler+0x58>
}
    2e52:	bd38      	pop	{r3, r4, r5, pc}
    2e54:	0000c174 	.word	0x0000c174
    2e58:	0000c1d4 	.word	0x0000c1d4
    2e5c:	00045408 	.word	0x00045408

00002e60 <spi_nrfx_transceive>:
{
    2e60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2e64:	4607      	mov	r7, r0
	k_sem_take(&ctx->lock, K_FOREVER);
    2e66:	6880      	ldr	r0, [r0, #8]
    2e68:	4688      	mov	r8, r1
    2e6a:	4616      	mov	r6, r2
    2e6c:	461d      	mov	r5, r3
    2e6e:	3004      	adds	r0, #4
	return z_impl_k_sem_take(sem, timeout);
    2e70:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2e74:	f004 fe34 	bl	7ae0 <z_impl_k_sem_take>
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    2e78:	68bc      	ldr	r4, [r7, #8]
	if (spi_context_configured(ctx, spi_cfg)) {
    2e7a:	6823      	ldr	r3, [r4, #0]
    2e7c:	4598      	cmp	r8, r3
    2e7e:	f000 80b0 	beq.w	2fe2 <spi_nrfx_transceive+0x182>
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
    2e82:	f8b8 3004 	ldrh.w	r3, [r8, #4]
	const nrfx_spi_t *spi = &get_dev_config(dev)->spi;
    2e86:	6838      	ldr	r0, [r7, #0]
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
    2e88:	07d9      	lsls	r1, r3, #31
    2e8a:	d516      	bpl.n	2eba <spi_nrfx_transceive+0x5a>
		LOG_ERR("Slave mode is not supported on %s",
    2e8c:	2301      	movs	r3, #1
    2e8e:	f04f 0200 	mov.w	r2, #0
    2e92:	f363 0207 	bfi	r2, r3, #0, #8
    2e96:	4980      	ldr	r1, [pc, #512]	; (3098 <spi_nrfx_transceive+0x238>)
    2e98:	4b80      	ldr	r3, [pc, #512]	; (309c <spi_nrfx_transceive+0x23c>)
    2e9a:	1a5b      	subs	r3, r3, r1
    2e9c:	08db      	lsrs	r3, r3, #3
    2e9e:	6801      	ldr	r1, [r0, #0]
    2ea0:	487f      	ldr	r0, [pc, #508]	; (30a0 <spi_nrfx_transceive+0x240>)
    2ea2:	f363 128f 	bfi	r2, r3, #6, #10
    2ea6:	f005 fa83 	bl	83b0 <log_1>
		return -EINVAL;
    2eaa:	f06f 0515 	mvn.w	r5, #21
	z_impl_k_sem_give(sem);
    2eae:	1d20      	adds	r0, r4, #4
    2eb0:	f004 fdf0 	bl	7a94 <z_impl_k_sem_give>
}
    2eb4:	4628      	mov	r0, r5
    2eb6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (spi_cfg->operation & SPI_MODE_LOOP) {
    2eba:	071a      	lsls	r2, r3, #28
    2ebc:	d50e      	bpl.n	2edc <spi_nrfx_transceive+0x7c>
		LOG_ERR("Loopback mode is not supported");
    2ebe:	2301      	movs	r3, #1
    2ec0:	f04f 0100 	mov.w	r1, #0
    2ec4:	f363 0107 	bfi	r1, r3, #0, #8
    2ec8:	4a73      	ldr	r2, [pc, #460]	; (3098 <spi_nrfx_transceive+0x238>)
    2eca:	4b74      	ldr	r3, [pc, #464]	; (309c <spi_nrfx_transceive+0x23c>)
    2ecc:	4875      	ldr	r0, [pc, #468]	; (30a4 <spi_nrfx_transceive+0x244>)
    2ece:	1a9b      	subs	r3, r3, r2
    2ed0:	08db      	lsrs	r3, r3, #3
    2ed2:	f363 118f 	bfi	r1, r3, #6, #10
		LOG_ERR("Word sizes other than 8 bits"
    2ed6:	f005 fa5e 	bl	8396 <log_0>
    2eda:	e7e6      	b.n	2eaa <spi_nrfx_transceive+0x4a>
	if ((spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
    2edc:	f413 51c0 	ands.w	r1, r3, #6144	; 0x1800
    2ee0:	d00c      	beq.n	2efc <spi_nrfx_transceive+0x9c>
		LOG_ERR("Only single line mode is supported");
    2ee2:	2301      	movs	r3, #1
    2ee4:	f04f 0100 	mov.w	r1, #0
    2ee8:	f363 0107 	bfi	r1, r3, #0, #8
    2eec:	4a6a      	ldr	r2, [pc, #424]	; (3098 <spi_nrfx_transceive+0x238>)
    2eee:	4b6b      	ldr	r3, [pc, #428]	; (309c <spi_nrfx_transceive+0x23c>)
    2ef0:	486d      	ldr	r0, [pc, #436]	; (30a8 <spi_nrfx_transceive+0x248>)
    2ef2:	1a9b      	subs	r3, r3, r2
    2ef4:	08db      	lsrs	r3, r3, #3
    2ef6:	f363 118f 	bfi	r1, r3, #6, #10
    2efa:	e7ec      	b.n	2ed6 <spi_nrfx_transceive+0x76>
	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
    2efc:	f3c3 1345 	ubfx	r3, r3, #5, #6
    2f00:	2b08      	cmp	r3, #8
    2f02:	d00c      	beq.n	2f1e <spi_nrfx_transceive+0xbe>
		LOG_ERR("Word sizes other than 8 bits"
    2f04:	2301      	movs	r3, #1
    2f06:	f04f 0100 	mov.w	r1, #0
    2f0a:	f363 0107 	bfi	r1, r3, #0, #8
    2f0e:	4a62      	ldr	r2, [pc, #392]	; (3098 <spi_nrfx_transceive+0x238>)
    2f10:	4b62      	ldr	r3, [pc, #392]	; (309c <spi_nrfx_transceive+0x23c>)
    2f12:	4866      	ldr	r0, [pc, #408]	; (30ac <spi_nrfx_transceive+0x24c>)
    2f14:	1a9b      	subs	r3, r3, r2
    2f16:	08db      	lsrs	r3, r3, #3
    2f18:	f363 118f 	bfi	r1, r3, #6, #10
    2f1c:	e7db      	b.n	2ed6 <spi_nrfx_transceive+0x76>
	if (spi_cfg->frequency < 125000) {
    2f1e:	f8d8 2000 	ldr.w	r2, [r8]
    2f22:	4b63      	ldr	r3, [pc, #396]	; (30b0 <spi_nrfx_transceive+0x250>)
    2f24:	429a      	cmp	r2, r3
    2f26:	d80c      	bhi.n	2f42 <spi_nrfx_transceive+0xe2>
		LOG_ERR("Frequencies lower than 125 kHz are not supported");
    2f28:	2301      	movs	r3, #1
    2f2a:	f04f 0100 	mov.w	r1, #0
    2f2e:	f363 0107 	bfi	r1, r3, #0, #8
    2f32:	4a59      	ldr	r2, [pc, #356]	; (3098 <spi_nrfx_transceive+0x238>)
    2f34:	4b59      	ldr	r3, [pc, #356]	; (309c <spi_nrfx_transceive+0x23c>)
    2f36:	485f      	ldr	r0, [pc, #380]	; (30b4 <spi_nrfx_transceive+0x254>)
    2f38:	1a9b      	subs	r3, r3, r2
    2f3a:	08db      	lsrs	r3, r3, #3
    2f3c:	f363 118f 	bfi	r1, r3, #6, #10
    2f40:	e7c9      	b.n	2ed6 <spi_nrfx_transceive+0x76>
	if (ctx->config->cs && ctx->config->cs->gpio_dev) {
    2f42:	f8d8 3008 	ldr.w	r3, [r8, #8]
	return dev->config->config_info;
    2f46:	f8d0 9008 	ldr.w	r9, [r0, #8]
	ctx->config = spi_cfg;
    2f4a:	f8c4 8000 	str.w	r8, [r4]
    2f4e:	2b00      	cmp	r3, #0
    2f50:	d06f      	beq.n	3032 <spi_nrfx_transceive+0x1d2>
    2f52:	6818      	ldr	r0, [r3, #0]
    2f54:	2800      	cmp	r0, #0
    2f56:	d06c      	beq.n	3032 <spi_nrfx_transceive+0x1d2>
		gpio_pin_configure(ctx->config->cs->gpio_dev,
    2f58:	685a      	ldr	r2, [r3, #4]
    2f5a:	6843      	ldr	r3, [r0, #4]
    2f5c:	f8d3 a000 	ldr.w	sl, [r3]
    2f60:	2301      	movs	r3, #1
    2f62:	47d0      	blx	sl
		gpio_pin_write(ctx->config->cs->gpio_dev,
    2f64:	6822      	ldr	r2, [r4, #0]
    2f66:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
    2f68:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
		gpio_pin_write(ctx->config->cs->gpio_dev,
    2f6c:	43d2      	mvns	r2, r2
    2f6e:	0fd2      	lsrs	r2, r2, #31
    2f70:	e9d3 0100 	ldrd	r0, r1, [r3]
    2f74:	f006 fa79 	bl	946a <gpio_pin_write>
	nrf_spi_configure(spi->p_reg,
    2f78:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    2f7c:	f8d9 1000 	ldr.w	r1, [r9]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
    2f80:	0798      	lsls	r0, r3, #30
    2f82:	f003 0204 	and.w	r2, r3, #4
    2f86:	d563      	bpl.n	3050 <spi_nrfx_transceive+0x1f0>
			return NRF_SPI_MODE_2;
    2f88:	2a00      	cmp	r2, #0
    2f8a:	bf14      	ite	ne
    2f8c:	2203      	movne	r2, #3
    2f8e:	2202      	moveq	r2, #2
                                         nrf_spi_mode_t      spi_mode,
                                         nrf_spi_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPI_BIT_ORDER_MSB_FIRST ?
        SPI_CONFIG_ORDER_MsbFirst : SPI_CONFIG_ORDER_LsbFirst);
    switch (spi_mode)
    2f90:	2a02      	cmp	r2, #2
	if (operation & SPI_TRANSFER_LSB) {
    2f92:	f3c3 1300 	ubfx	r3, r3, #4, #1
    2f96:	d05f      	beq.n	3058 <spi_nrfx_transceive+0x1f8>
    2f98:	2a03      	cmp	r2, #3
    2f9a:	d060      	beq.n	305e <spi_nrfx_transceive+0x1fe>
    2f9c:	2a01      	cmp	r2, #1
    2f9e:	d101      	bne.n	2fa4 <spi_nrfx_transceive+0x144>
        config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
                  (SPI_CONFIG_CPHA_Leading    << SPI_CONFIG_CPHA_Pos);
        break;

    case NRF_SPI_MODE_1:
        config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
    2fa0:	f043 0302 	orr.w	r3, r3, #2
    case NRF_SPI_MODE_3:
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
                  (SPI_CONFIG_CPHA_Trailing   << SPI_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
    2fa4:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
	if (frequency < 250000) {
    2fa8:	4a43      	ldr	r2, [pc, #268]	; (30b8 <spi_nrfx_transceive+0x258>)
	nrf_spi_frequency_set(spi->p_reg,
    2faa:	f8d8 3000 	ldr.w	r3, [r8]
	if (frequency < 250000) {
    2fae:	4293      	cmp	r3, r2
    2fb0:	d958      	bls.n	3064 <spi_nrfx_transceive+0x204>
	} else if (frequency < 500000) {
    2fb2:	4a42      	ldr	r2, [pc, #264]	; (30bc <spi_nrfx_transceive+0x25c>)
    2fb4:	4293      	cmp	r3, r2
    2fb6:	d958      	bls.n	306a <spi_nrfx_transceive+0x20a>
	} else if (frequency < 1000000) {
    2fb8:	4a41      	ldr	r2, [pc, #260]	; (30c0 <spi_nrfx_transceive+0x260>)
    2fba:	4293      	cmp	r3, r2
    2fbc:	d958      	bls.n	3070 <spi_nrfx_transceive+0x210>
	} else if (frequency < 2000000) {
    2fbe:	4a41      	ldr	r2, [pc, #260]	; (30c4 <spi_nrfx_transceive+0x264>)
    2fc0:	4293      	cmp	r3, r2
    2fc2:	d958      	bls.n	3076 <spi_nrfx_transceive+0x216>
	} else if (frequency < 4000000) {
    2fc4:	4a40      	ldr	r2, [pc, #256]	; (30c8 <spi_nrfx_transceive+0x268>)
    2fc6:	4293      	cmp	r3, r2
    2fc8:	d958      	bls.n	307c <spi_nrfx_transceive+0x21c>
		return NRF_SPI_FREQ_8M;
    2fca:	f502 1274 	add.w	r2, r2, #3997696	; 0x3d0000
    2fce:	f502 6210 	add.w	r2, r2, #2304	; 0x900
    2fd2:	4293      	cmp	r3, r2
    2fd4:	bf94      	ite	ls
    2fd6:	f04f 4380 	movls.w	r3, #1073741824	; 0x40000000
    2fda:	f04f 4300 	movhi.w	r3, #2147483648	; 0x80000000
    p_reg->FREQUENCY = (uint32_t)frequency;
    2fde:	f8c1 3524 	str.w	r3, [r1, #1316]	; 0x524
		dev_data->busy = true;
    2fe2:	2301      	movs	r3, #1
    2fe4:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
	if (tx_bufs) {
    2fe8:	2e00      	cmp	r6, #0
    2fea:	d04a      	beq.n	3082 <spi_nrfx_transceive+0x222>
		ctx->current_tx = tx_bufs->buffers;
    2fec:	6833      	ldr	r3, [r6, #0]
		ctx->tx_count = tx_bufs->count;
    2fee:	6872      	ldr	r2, [r6, #4]
		ctx->current_tx = tx_bufs->buffers;
    2ff0:	62a3      	str	r3, [r4, #40]	; 0x28
		ctx->tx_count = tx_bufs->count;
    2ff2:	62e2      	str	r2, [r4, #44]	; 0x2c
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    2ff4:	681a      	ldr	r2, [r3, #0]
		ctx->tx_len = ctx->current_tx->len / dfs;
    2ff6:	685b      	ldr	r3, [r3, #4]
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    2ff8:	63a2      	str	r2, [r4, #56]	; 0x38
		ctx->tx_len = ctx->current_tx->len / dfs;
    2ffa:	63e3      	str	r3, [r4, #60]	; 0x3c
	if (rx_bufs) {
    2ffc:	2d00      	cmp	r5, #0
    2ffe:	d045      	beq.n	308c <spi_nrfx_transceive+0x22c>
		ctx->current_rx = rx_bufs->buffers;
    3000:	682b      	ldr	r3, [r5, #0]
		ctx->rx_count = rx_bufs->count;
    3002:	686a      	ldr	r2, [r5, #4]
		ctx->current_rx = rx_bufs->buffers;
    3004:	6323      	str	r3, [r4, #48]	; 0x30
		ctx->rx_count = rx_bufs->count;
    3006:	6362      	str	r2, [r4, #52]	; 0x34
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    3008:	681a      	ldr	r2, [r3, #0]
		ctx->rx_len = ctx->current_rx->len / dfs;
    300a:	685b      	ldr	r3, [r3, #4]
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    300c:	6422      	str	r2, [r4, #64]	; 0x40
		ctx->rx_len = ctx->current_rx->len / dfs;
    300e:	6463      	str	r3, [r4, #68]	; 0x44
	ctx->sync_status = 0;
    3010:	2200      	movs	r2, #0
    3012:	6262      	str	r2, [r4, #36]	; 0x24
	_spi_context_cs_control(ctx, on, false);
    3014:	2101      	movs	r1, #1
    3016:	4620      	mov	r0, r4
    3018:	f006 fa30 	bl	947c <_spi_context_cs_control.isra.7>
		transfer_next_chunk(dev);
    301c:	4638      	mov	r0, r7
    301e:	f7ff fe7b 	bl	2d18 <transfer_next_chunk>
	return z_impl_k_sem_take(sem, timeout);
    3022:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3026:	f104 0014 	add.w	r0, r4, #20
    302a:	f004 fd59 	bl	7ae0 <z_impl_k_sem_take>
	status = ctx->sync_status;
    302e:	6a65      	ldr	r5, [r4, #36]	; 0x24
	return status;
    3030:	e73d      	b.n	2eae <spi_nrfx_transceive+0x4e>
		LOG_INF("CS control inhibited (no GPIO device)");
    3032:	2303      	movs	r3, #3
    3034:	f04f 0100 	mov.w	r1, #0
    3038:	f363 0107 	bfi	r1, r3, #0, #8
    303c:	4a16      	ldr	r2, [pc, #88]	; (3098 <spi_nrfx_transceive+0x238>)
    303e:	4b17      	ldr	r3, [pc, #92]	; (309c <spi_nrfx_transceive+0x23c>)
    3040:	4822      	ldr	r0, [pc, #136]	; (30cc <spi_nrfx_transceive+0x26c>)
    3042:	1a9b      	subs	r3, r3, r2
    3044:	08db      	lsrs	r3, r3, #3
    3046:	f363 118f 	bfi	r1, r3, #6, #10
    304a:	f005 f9a4 	bl	8396 <log_0>
    304e:	e793      	b.n	2f78 <spi_nrfx_transceive+0x118>
			return NRF_SPI_MODE_0;
    3050:	3200      	adds	r2, #0
    3052:	bf18      	it	ne
    3054:	2201      	movne	r2, #1
    3056:	e79b      	b.n	2f90 <spi_nrfx_transceive+0x130>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
    3058:	f043 0304 	orr.w	r3, r3, #4
        break;
    305c:	e7a2      	b.n	2fa4 <spi_nrfx_transceive+0x144>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
    305e:	f043 0306 	orr.w	r3, r3, #6
        break;
    3062:	e79f      	b.n	2fa4 <spi_nrfx_transceive+0x144>
		return NRF_SPI_FREQ_125K;
    3064:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
    3068:	e7b9      	b.n	2fde <spi_nrfx_transceive+0x17e>
		return NRF_SPI_FREQ_250K;
    306a:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    306e:	e7b6      	b.n	2fde <spi_nrfx_transceive+0x17e>
		return NRF_SPI_FREQ_500K;
    3070:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    3074:	e7b3      	b.n	2fde <spi_nrfx_transceive+0x17e>
		return NRF_SPI_FREQ_1M;
    3076:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    307a:	e7b0      	b.n	2fde <spi_nrfx_transceive+0x17e>
		return NRF_SPI_FREQ_2M;
    307c:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
    3080:	e7ad      	b.n	2fde <spi_nrfx_transceive+0x17e>
		ctx->tx_count = 0;
    3082:	e9c4 660a 	strd	r6, r6, [r4, #40]	; 0x28
		ctx->tx_len = 0;
    3086:	e9c4 660e 	strd	r6, r6, [r4, #56]	; 0x38
    308a:	e7b7      	b.n	2ffc <spi_nrfx_transceive+0x19c>
		ctx->rx_count = 0;
    308c:	e9c4 550c 	strd	r5, r5, [r4, #48]	; 0x30
		ctx->rx_len = 0;
    3090:	e9c4 5510 	strd	r5, r5, [r4, #64]	; 0x40
    3094:	e7bc      	b.n	3010 <spi_nrfx_transceive+0x1b0>
    3096:	bf00      	nop
    3098:	0000c174 	.word	0x0000c174
    309c:	0000c1d4 	.word	0x0000c1d4
    30a0:	00045426 	.word	0x00045426
    30a4:	00045448 	.word	0x00045448
    30a8:	00045467 	.word	0x00045467
    30ac:	0004548a 	.word	0x0004548a
    30b0:	0001e847 	.word	0x0001e847
    30b4:	000454b9 	.word	0x000454b9
    30b8:	0003d08f 	.word	0x0003d08f
    30bc:	0007a11f 	.word	0x0007a11f
    30c0:	000f423f 	.word	0x000f423f
    30c4:	001e847f 	.word	0x001e847f
    30c8:	003d08ff 	.word	0x003d08ff
    30cc:	000454ea 	.word	0x000454ea

000030d0 <errata_108>:
static bool errata_12(void)
{
    uint32_t var1;
    uint32_t var2;

    if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    30d0:	4b04      	ldr	r3, [pc, #16]	; (30e4 <errata_108+0x14>)
    30d2:	6818      	ldr	r0, [r3, #0]
    30d4:	1c42      	adds	r2, r0, #1
    {
        var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    30d6:	bf04      	itt	eq
    30d8:	4b03      	ldreq	r3, [pc, #12]	; (30e8 <errata_108+0x18>)
    30da:	7818      	ldrbeq	r0, [r3, #0]
        break;

    }

    return false;
}
    30dc:	1f83      	subs	r3, r0, #6
    30de:	4258      	negs	r0, r3
    30e0:	4158      	adcs	r0, r3
    30e2:	4770      	bx	lr
    30e4:	10000130 	.word	0x10000130
    30e8:	f0000fe0 	.word	0xf0000fe0

000030ec <errata_16>:
    return false;
}

static bool errata_16(void)
{
    uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    30ec:	4b07      	ldr	r3, [pc, #28]	; (310c <errata_16+0x20>)
    30ee:	781b      	ldrb	r3, [r3, #0]
    uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;

    switch(var1)
    30f0:	2b06      	cmp	r3, #6
    30f2:	d109      	bne.n	3108 <errata_16+0x1c>
    uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    30f4:	4b06      	ldr	r3, [pc, #24]	; (3110 <errata_16+0x24>)
    30f6:	681b      	ldr	r3, [r3, #0]
    30f8:	f3c3 1303 	ubfx	r3, r3, #4, #4
    30fc:	3b03      	subs	r3, #3
    30fe:	2b03      	cmp	r3, #3
    3100:	d802      	bhi.n	3108 <errata_16+0x1c>
    3102:	4a04      	ldr	r2, [pc, #16]	; (3114 <errata_16+0x28>)
    3104:	5cd0      	ldrb	r0, [r2, r3]
    3106:	4770      	bx	lr
            }
        break;

    }

    return false;
    3108:	2000      	movs	r0, #0
}
    310a:	4770      	bx	lr
    310c:	f0000fe0 	.word	0xf0000fe0
    3110:	f0000fe8 	.word	0xf0000fe8
    3114:	0004551d 	.word	0x0004551d

00003118 <SystemInit>:
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
}

void SystemInit(void)
{
    3118:	b508      	push	{r3, lr}
        NRF_P0->PIN_CNF[20] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
    #endif
    
    /* Workaround for Errata 12 "COMP: Reference ladder not correctly calibrated" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp */
    if (errata_12()){
    311a:	f7ff ffd9 	bl	30d0 <errata_108>
    311e:	b128      	cbz	r0, 312c <SystemInit+0x14>
        *(volatile uint32_t *)0x40013540 = (*(uint32_t *)0x10000324 & 0x00001F00) >> 8;
    3120:	4b7c      	ldr	r3, [pc, #496]	; (3314 <SystemInit+0x1fc>)
    3122:	4a7d      	ldr	r2, [pc, #500]	; (3318 <SystemInit+0x200>)
    3124:	681b      	ldr	r3, [r3, #0]
    3126:	f3c3 2304 	ubfx	r3, r3, #8, #5
    312a:	6013      	str	r3, [r2, #0]
    }
    
    /* Workaround for Errata 16 "System: RAM may be corrupt on wakeup from CPU IDLE" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp */
    if (errata_16()){
    312c:	f7ff ffde 	bl	30ec <errata_16>
    3130:	b110      	cbz	r0, 3138 <SystemInit+0x20>
        *(volatile uint32_t *)0x4007C074 = 3131961357ul;
    3132:	4b7a      	ldr	r3, [pc, #488]	; (331c <SystemInit+0x204>)
    3134:	4a7a      	ldr	r2, [pc, #488]	; (3320 <SystemInit+0x208>)
    3136:	601a      	str	r2, [r3, #0]
    }

    /* Workaround for Errata 31 "CLOCK: Calibration values are not correctly loaded from FICR at reset" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp */
    if (errata_31()){
    3138:	f7ff ffca 	bl	30d0 <errata_108>
    313c:	b128      	cbz	r0, 314a <SystemInit+0x32>
        *(volatile uint32_t *)0x4000053C = ((*(volatile uint32_t *)0x10000244) & 0x0000E000) >> 13;
    313e:	4b79      	ldr	r3, [pc, #484]	; (3324 <SystemInit+0x20c>)
    3140:	4a79      	ldr	r2, [pc, #484]	; (3328 <SystemInit+0x210>)
    3142:	681b      	ldr	r3, [r3, #0]
    3144:	f3c3 3342 	ubfx	r3, r3, #13, #3
    3148:	6013      	str	r3, [r2, #0]
    }

    /* Workaround for Errata 32 "DIF: Debug session automatically enables TracePort pins" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp */
    if (errata_32()){
    314a:	f7ff ffcf 	bl	30ec <errata_16>
    314e:	b120      	cbz	r0, 315a <SystemInit+0x42>
        CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk;
    3150:	4a76      	ldr	r2, [pc, #472]	; (332c <SystemInit+0x214>)
    3152:	68d3      	ldr	r3, [r2, #12]
    3154:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    3158:	60d3      	str	r3, [r2, #12]
    }

    /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_36()){
    315a:	f7ff ffb9 	bl	30d0 <errata_108>
    315e:	b140      	cbz	r0, 3172 <SystemInit+0x5a>
        NRF_CLOCK->EVENTS_DONE = 0;
    3160:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3164:	2200      	movs	r2, #0
    3166:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
        NRF_CLOCK->EVENTS_CTTO = 0;
    316a:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
        NRF_CLOCK->CTIV = 0;
    316e:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    }

    /* Workaround for Errata 37 "RADIO: Encryption engine is slow by default" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_37()){
    3172:	f7ff ffbb 	bl	30ec <errata_16>
    3176:	b110      	cbz	r0, 317e <SystemInit+0x66>
        *(volatile uint32_t *)0x400005A0 = 0x3;
    3178:	4b6d      	ldr	r3, [pc, #436]	; (3330 <SystemInit+0x218>)
    317a:	2203      	movs	r2, #3
    317c:	601a      	str	r2, [r3, #0]
    }

    /* Workaround for Errata 57 "NFCT: NFC Modulation amplitude" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_57()){
    317e:	f7ff ffb5 	bl	30ec <errata_16>
    3182:	b140      	cbz	r0, 3196 <SystemInit+0x7e>
        *(volatile uint32_t *)0x40005610 = 0x00000005;
    3184:	4b6b      	ldr	r3, [pc, #428]	; (3334 <SystemInit+0x21c>)
    3186:	2205      	movs	r2, #5
    3188:	601a      	str	r2, [r3, #0]
        *(volatile uint32_t *)0x40005688 = 0x00000001;
    318a:	2201      	movs	r2, #1
    318c:	679a      	str	r2, [r3, #120]	; 0x78
        *(volatile uint32_t *)0x40005618 = 0x00000000;
    318e:	2200      	movs	r2, #0
    3190:	609a      	str	r2, [r3, #8]
        *(volatile uint32_t *)0x40005614 = 0x0000003F;
    3192:	223f      	movs	r2, #63	; 0x3f
    3194:	605a      	str	r2, [r3, #4]
static bool errata_66(void)
{
    uint32_t var1;
    uint32_t var2;

    if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    3196:	4b68      	ldr	r3, [pc, #416]	; (3338 <SystemInit+0x220>)
    3198:	681a      	ldr	r2, [r3, #0]
    319a:	1c51      	adds	r1, r2, #1
    {
        var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    319c:	bf0b      	itete	eq
    319e:	4b67      	ldreq	r3, [pc, #412]	; (333c <SystemInit+0x224>)
        var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    }
    else
    {
        var1 = *(uint32_t *)0x10000130ul;
        var2 = *(uint32_t *)0x10000134ul;
    31a0:	4b67      	ldrne	r3, [pc, #412]	; (3340 <SystemInit+0x228>)
        var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    31a2:	781a      	ldrbeq	r2, [r3, #0]
        var2 = *(uint32_t *)0x10000134ul;
    31a4:	681b      	ldrne	r3, [r3, #0]
        var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    31a6:	bf02      	ittt	eq
    31a8:	3308      	addeq	r3, #8
    31aa:	681b      	ldreq	r3, [r3, #0]
    31ac:	f3c3 1303 	ubfxeq	r3, r3, #4, #4
    }

    switch(var1)
    31b0:	2a06      	cmp	r2, #6
    31b2:	d14d      	bne.n	3250 <SystemInit+0x138>
    {
        case 0x06:
            switch(var2)
    31b4:	3b03      	subs	r3, #3
    31b6:	2b03      	cmp	r3, #3
    31b8:	d803      	bhi.n	31c2 <SystemInit+0xaa>
    }

    /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_66()){
    31ba:	4a62      	ldr	r2, [pc, #392]	; (3344 <SystemInit+0x22c>)
    31bc:	5cd3      	ldrb	r3, [r2, r3]
    31be:	2b00      	cmp	r3, #0
    31c0:	d046      	beq.n	3250 <SystemInit+0x138>
        NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
    31c2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    31c6:	4b60      	ldr	r3, [pc, #384]	; (3348 <SystemInit+0x230>)
    31c8:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
    31cc:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
        NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
    31d0:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
    31d4:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
        NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
    31d8:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
    31dc:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
        NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
    31e0:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
    31e4:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
        NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
    31e8:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
    31ec:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
        NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
    31f0:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
    31f4:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
        NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
    31f8:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
    31fc:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
        NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
    3200:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
    3204:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
        NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
    3208:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
    320c:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
        NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
    3210:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
    3214:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
        NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
    3218:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
    321c:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
        NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
    3220:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
    3224:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
        NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
    3228:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
    322c:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
        NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
    3230:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
    3234:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
        NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
    3238:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
    323c:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
        NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
    3240:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
    3244:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
        NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
    3248:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
    324c:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    }

    /* Workaround for Errata 108 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_108()){
    3250:	f7ff ff3e 	bl	30d0 <errata_108>
    3254:	b128      	cbz	r0, 3262 <SystemInit+0x14a>
        *(volatile uint32_t *)0x40000EE4ul = *(volatile uint32_t *)0x10000258ul & 0x0000004Ful;
    3256:	4b3d      	ldr	r3, [pc, #244]	; (334c <SystemInit+0x234>)
    3258:	4a3d      	ldr	r2, [pc, #244]	; (3350 <SystemInit+0x238>)
    325a:	681b      	ldr	r3, [r3, #0]
    325c:	f003 034f 	and.w	r3, r3, #79	; 0x4f
    3260:	6013      	str	r3, [r2, #0]
    }
    
    /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_136()){
    3262:	f7ff ff35 	bl	30d0 <errata_108>
    3266:	b148      	cbz	r0, 327c <SystemInit+0x164>
        if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
    3268:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    326c:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    3270:	07d2      	lsls	r2, r2, #31
            NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
    3272:	bf44      	itt	mi
    3274:	f06f 0201 	mvnmi.w	r2, #1
    3278:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400
    return false;
}

static bool errata_182(void)
{
    uint32_t var1 = *(uint32_t *)0x10000130ul;
    327c:	4b2e      	ldr	r3, [pc, #184]	; (3338 <SystemInit+0x220>)
    uint32_t var2 = *(uint32_t *)0x10000134ul;

    switch(var1)
    327e:	681b      	ldr	r3, [r3, #0]
    3280:	2b06      	cmp	r3, #6
    3282:	d109      	bne.n	3298 <SystemInit+0x180>
    uint32_t var2 = *(uint32_t *)0x10000134ul;
    3284:	4b2e      	ldr	r3, [pc, #184]	; (3340 <SystemInit+0x228>)
    {
        case 0x06:
            switch(var2)
    3286:	681b      	ldr	r3, [r3, #0]
    3288:	3b03      	subs	r3, #3
    328a:	2b02      	cmp	r3, #2
    }
    
    /* Workaround for Errata 182 "RADIO: Fixes for anomalies #102, #106, and #107 do not take effect" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_182()){
        *(volatile uint32_t *) 0x4000173C |= (0x1 << 10);
    328c:	bf81      	itttt	hi
    328e:	4a31      	ldrhi	r2, [pc, #196]	; (3354 <SystemInit+0x23c>)
    3290:	6813      	ldrhi	r3, [r2, #0]
    3292:	f443 6380 	orrhi.w	r3, r3, #1024	; 0x400
    3296:	6013      	strhi	r3, [r2, #0]

    /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
      defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
      reserved for PinReset and not available as normal GPIO. */
    #if defined (CONFIG_GPIO_AS_PINRESET)
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    3298:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    329c:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    32a0:	2a00      	cmp	r2, #0
    32a2:	db03      	blt.n	32ac <SystemInit+0x194>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
    32a4:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    32a8:	2b00      	cmp	r3, #0
    32aa:	da2f      	bge.n	330c <SystemInit+0x1f4>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
    32ac:	4b2a      	ldr	r3, [pc, #168]	; (3358 <SystemInit+0x240>)
    32ae:	2201      	movs	r2, #1
    32b0:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    32b4:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    32b8:	2a00      	cmp	r2, #0
    32ba:	d0fb      	beq.n	32b4 <SystemInit+0x19c>
            NRF_UICR->PSELRESET[0] = 21;
    32bc:	f04f 2210 	mov.w	r2, #268439552	; 0x10001000
    32c0:	2115      	movs	r1, #21
    32c2:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    32c6:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    32ca:	2a00      	cmp	r2, #0
    32cc:	d0fb      	beq.n	32c6 <SystemInit+0x1ae>
            NRF_UICR->PSELRESET[1] = 21;
    32ce:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    32d2:	2215      	movs	r2, #21
    32d4:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    32d8:	4b1f      	ldr	r3, [pc, #124]	; (3358 <SystemInit+0x240>)
    32da:	461a      	mov	r2, r3
    32dc:	f8d3 1400 	ldr.w	r1, [r3, #1024]	; 0x400
    32e0:	2900      	cmp	r1, #0
    32e2:	d0fb      	beq.n	32dc <SystemInit+0x1c4>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
    32e4:	2100      	movs	r1, #0
    32e6:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    32ea:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
    32ee:	2b00      	cmp	r3, #0
    32f0:	d0fb      	beq.n	32ea <SystemInit+0x1d2>
  __ASM volatile ("dsb 0xF":::"memory");
    32f2:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    32f6:	4919      	ldr	r1, [pc, #100]	; (335c <SystemInit+0x244>)
    32f8:	4b19      	ldr	r3, [pc, #100]	; (3360 <SystemInit+0x248>)
    32fa:	68ca      	ldr	r2, [r1, #12]
    32fc:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    3300:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    3302:	60cb      	str	r3, [r1, #12]
    3304:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    3308:	bf00      	nop
    330a:	e7fd      	b.n	3308 <SystemInit+0x1f0>
    SystemCoreClock = __SYSTEM_CLOCK_64M;
    330c:	4b15      	ldr	r3, [pc, #84]	; (3364 <SystemInit+0x24c>)
    330e:	4a16      	ldr	r2, [pc, #88]	; (3368 <SystemInit+0x250>)
    3310:	601a      	str	r2, [r3, #0]
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
}
    3312:	bd08      	pop	{r3, pc}
    3314:	10000324 	.word	0x10000324
    3318:	40013540 	.word	0x40013540
    331c:	4007c074 	.word	0x4007c074
    3320:	baadf00d 	.word	0xbaadf00d
    3324:	10000244 	.word	0x10000244
    3328:	4000053c 	.word	0x4000053c
    332c:	e000edf0 	.word	0xe000edf0
    3330:	400005a0 	.word	0x400005a0
    3334:	40005610 	.word	0x40005610
    3338:	10000130 	.word	0x10000130
    333c:	f0000fe0 	.word	0xf0000fe0
    3340:	10000134 	.word	0x10000134
    3344:	00045521 	.word	0x00045521
    3348:	4000c000 	.word	0x4000c000
    334c:	10000258 	.word	0x10000258
    3350:	40000ee4 	.word	0x40000ee4
    3354:	4000173c 	.word	0x4000173c
    3358:	4001e000 	.word	0x4001e000
    335c:	e000ed00 	.word	0xe000ed00
    3360:	05fa0004 	.word	0x05fa0004
    3364:	2000a120 	.word	0x2000a120
    3368:	03d09000 	.word	0x03d09000

0000336c <nrfx_spi_init>:

nrfx_err_t nrfx_spi_init(nrfx_spi_t const *        p_instance,
                         nrfx_spi_config_t const * p_config,
                         nrfx_spi_evt_handler_t    handler,
                         void *                    p_context)
{
    336c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    NRFX_ASSERT(p_config);
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    3370:	7904      	ldrb	r4, [r0, #4]
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
    3372:	4d4e      	ldr	r5, [pc, #312]	; (34ac <nrfx_spi_init+0x140>)
    3374:	262c      	movs	r6, #44	; 0x2c
    3376:	4366      	muls	r6, r4
    3378:	19af      	adds	r7, r5, r6
    337a:	f897 c01c 	ldrb.w	ip, [r7, #28]
    337e:	f1bc 0f00 	cmp.w	ip, #0
    3382:	f040 8091 	bne.w	34a8 <nrfx_spi_init+0x13c>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler = handler;
    3386:	51aa      	str	r2, [r5, r6]
    p_cb->p_context = p_context;
    3388:	607b      	str	r3, [r7, #4]
    // Configure pins used by the peripheral:
    // - SCK - output with initial value corresponding with the SPI mode used:
    //   0 - for modes 0 and 1 (CPOL = 0), 1 - for modes 2 and 3 (CPOL = 1);
    //   according to the reference manual guidelines this pin and its input
    //   buffer must always be connected for the SPI to work.
    if (p_config->mode <= NRF_SPI_MODE_1)
    338a:	f891 e000 	ldrb.w	lr, [r1]
    338e:	7b0f      	ldrb	r7, [r1, #12]
    3390:	f04f 46a0 	mov.w	r6, #1342177280	; 0x50000000
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
    3394:	2301      	movs	r3, #1
    3396:	fa03 f30e 	lsl.w	r3, r3, lr
    339a:	2f01      	cmp	r7, #1
    339c:	bf94      	ite	ls
    339e:	f8c6 350c 	strls.w	r3, [r6, #1292]	; 0x50c
    p_reg->OUTSET = set_mask;
    33a2:	f8c6 3508 	strhi.w	r3, [r6, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    33a6:	f50e 73e0 	add.w	r3, lr, #448	; 0x1c0
    33aa:	f04f 0c01 	mov.w	ip, #1
    33ae:	f846 c023 	str.w	ip, [r6, r3, lsl #2]
                 NRF_GPIO_PIN_INPUT_CONNECT,
                 NRF_GPIO_PIN_NOPULL,
                 NRF_GPIO_PIN_S0S1,
                 NRF_GPIO_PIN_NOSENSE);
    // - MOSI (optional) - output with initial value 0,
    if (p_config->mosi_pin != NRFX_SPI_PIN_NOT_USED)
    33b2:	784b      	ldrb	r3, [r1, #1]
    33b4:	2bff      	cmp	r3, #255	; 0xff
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
    33b6:	bf1f      	itttt	ne
    33b8:	fa0c fc03 	lslne.w	ip, ip, r3
    p_reg->OUTCLR = clr_mask;
    33bc:	f8c6 c50c 	strne.w	ip, [r6, #1292]	; 0x50c
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    33c0:	f503 7ce0 	addne.w	ip, r3, #448	; 0x1c0
    33c4:	f04f 0803 	movne.w	r8, #3
    33c8:	bf18      	it	ne
    33ca:	f846 802c 	strne.w	r8, [r6, ip, lsl #2]
    else
    {
        mosi_pin = NRF_SPI_PIN_NOT_CONNECTED;
    }
    // - MISO (optional) - input,
    if (p_config->miso_pin != NRFX_SPI_PIN_NOT_USED)
    33ce:	788e      	ldrb	r6, [r1, #2]
        mosi_pin = NRF_SPI_PIN_NOT_CONNECTED;
    33d0:	bf08      	it	eq
    33d2:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
    if (p_config->miso_pin != NRFX_SPI_PIN_NOT_USED)
    33d6:	2eff      	cmp	r6, #255	; 0xff
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
    33d8:	bf1f      	itttt	ne
    33da:	f891 900e 	ldrbne.w	r9, [r1, #14]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    33de:	f506 7ce0 	addne.w	ip, r6, #448	; 0x1c0
    33e2:	f04f 4aa0 	movne.w	sl, #1342177280	; 0x50000000
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
    33e6:	ea4f 0989 	movne.w	r9, r9, lsl #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    33ea:	bf18      	it	ne
    33ec:	f84a 902c 	strne.w	r9, [sl, ip, lsl #2]
    }
    else
    {
        miso_pin = NRF_SPI_PIN_NOT_CONNECTED;
    }
    m_cb[p_instance->drv_inst_idx].miso_pin = p_config->miso_pin;
    33f0:	f04f 0c2c 	mov.w	ip, #44	; 0x2c
    33f4:	fb0c 5c04 	mla	ip, ip, r4, r5
        miso_pin = p_config->miso_pin;
    33f8:	bf18      	it	ne
    33fa:	46b0      	movne	r8, r6
    m_cb[p_instance->drv_inst_idx].miso_pin = p_config->miso_pin;
    33fc:	f88c 601f 	strb.w	r6, [ip, #31]
    // - Slave Select (optional) - output with initial value 1 (inactive).
    if (p_config->ss_pin != NRFX_SPI_PIN_NOT_USED)
    3400:	78ce      	ldrb	r6, [r1, #3]
        miso_pin = NRF_SPI_PIN_NOT_CONNECTED;
    3402:	bf08      	it	eq
    3404:	f04f 38ff 	moveq.w	r8, #4294967295	; 0xffffffff
    if (p_config->ss_pin != NRFX_SPI_PIN_NOT_USED)
    3408:	2eff      	cmp	r6, #255	; 0xff
    340a:	d00d      	beq.n	3428 <nrfx_spi_init+0xbc>
    p_reg->OUTSET = set_mask;
    340c:	f04f 49a0 	mov.w	r9, #1342177280	; 0x50000000
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    3410:	f04f 0c01 	mov.w	ip, #1
    3414:	fa0c fc06 	lsl.w	ip, ip, r6
    p_reg->OUTSET = set_mask;
    3418:	f8c9 c508 	str.w	ip, [r9, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    341c:	f506 7ce0 	add.w	ip, r6, #448	; 0x1c0
    3420:	f04f 0a03 	mov.w	sl, #3
    3424:	f849 a02c 	str.w	sl, [r9, ip, lsl #2]
    {
        nrf_gpio_pin_set(p_config->ss_pin);
        nrf_gpio_cfg_output(p_config->ss_pin);
    }
    m_cb[p_instance->drv_inst_idx].ss_pin = p_config->ss_pin;
    3428:	f04f 0c2c 	mov.w	ip, #44	; 0x2c
    342c:	fb0c 5c04 	mla	ip, ip, r4, r5
    3430:	f88c 601e 	strb.w	r6, [ip, #30]

    NRF_SPI_Type * p_spi = p_instance->p_reg;
    3434:	6800      	ldr	r0, [r0, #0]
    p_reg->PSELSCK  = sck_pin;
    3436:	f8c0 e508 	str.w	lr, [r0, #1288]	; 0x508
    p_reg->PSELMOSI = mosi_pin;
    343a:	f8c0 350c 	str.w	r3, [r0, #1292]	; 0x50c
    p_reg->FREQUENCY = (uint32_t)frequency;
    343e:	688b      	ldr	r3, [r1, #8]
    p_reg->PSELMISO = miso_pin;
    3440:	f8c0 8510 	str.w	r8, [r0, #1296]	; 0x510
    p_reg->FREQUENCY = (uint32_t)frequency;
    3444:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524
        SPI_CONFIG_ORDER_MsbFirst : SPI_CONFIG_ORDER_LsbFirst);
    3448:	7b4b      	ldrb	r3, [r1, #13]
    344a:	3300      	adds	r3, #0
    344c:	bf18      	it	ne
    344e:	2301      	movne	r3, #1
    switch (spi_mode)
    3450:	2f02      	cmp	r7, #2
    3452:	d023      	beq.n	349c <nrfx_spi_init+0x130>
    3454:	2f03      	cmp	r7, #3
    3456:	d024      	beq.n	34a2 <nrfx_spi_init+0x136>
    3458:	2f01      	cmp	r7, #1
    345a:	d101      	bne.n	3460 <nrfx_spi_init+0xf4>
        config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
    345c:	f043 0302 	orr.w	r3, r3, #2
    p_reg->CONFIG = config;
    3460:	f8c0 3554 	str.w	r3, [r0, #1364]	; 0x554
    nrf_spi_pins_set(p_spi, p_config->sck_pin, mosi_pin, miso_pin);
    nrf_spi_frequency_set(p_spi, p_config->frequency);
    nrf_spi_configure(p_spi, p_config->mode, p_config->bit_order);

    m_cb[p_instance->drv_inst_idx].orc = p_config->orc;
    3464:	232c      	movs	r3, #44	; 0x2c
    3466:	fb03 5304 	mla	r3, r3, r4, r5
    346a:	7949      	ldrb	r1, [r1, #5]
    346c:	f883 1020 	strb.w	r1, [r3, #32]

    if (p_cb->handler)
    3470:	b112      	cbz	r2, 3478 <nrfx_spi_init+0x10c>
    p_reg->INTENSET = mask;
    3472:	2304      	movs	r3, #4
    3474:	f8c0 3304 	str.w	r3, [r0, #772]	; 0x304
    p_reg->ENABLE = (SPI_ENABLE_ENABLE_Enabled << SPI_ENABLE_ENABLE_Pos);
    3478:	2301      	movs	r3, #1
    347a:	f8c0 3500 	str.w	r3, [r0, #1280]	; 0x500
        nrf_spi_int_enable(p_spi, NRF_SPI_INT_READY_MASK);
    }

    nrf_spi_enable(p_spi);

    if (p_cb->handler)
    347e:	b11a      	cbz	r2, 3488 <nrfx_spi_init+0x11c>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_reg),
            p_config->irq_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
    3480:	f340 3007 	sbfx	r0, r0, #12, #8
    3484:	f7fd feb2 	bl	11ec <arch_irq_enable>
    }

    p_cb->transfer_in_progress = false;
    3488:	232c      	movs	r3, #44	; 0x2c
    348a:	fb03 5404 	mla	r4, r3, r4, r5
    348e:	2300      	movs	r3, #0
    3490:	7763      	strb	r3, [r4, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
    3492:	4807      	ldr	r0, [pc, #28]	; (34b0 <nrfx_spi_init+0x144>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    3494:	2301      	movs	r3, #1
    3496:	7723      	strb	r3, [r4, #28]
}
    3498:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
    349c:	f043 0304 	orr.w	r3, r3, #4
        break;
    34a0:	e7de      	b.n	3460 <nrfx_spi_init+0xf4>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
    34a2:	f043 0306 	orr.w	r3, r3, #6
        break;
    34a6:	e7db      	b.n	3460 <nrfx_spi_init+0xf4>
        return err_code;
    34a8:	4802      	ldr	r0, [pc, #8]	; (34b4 <nrfx_spi_init+0x148>)
    34aa:	e7f5      	b.n	3498 <nrfx_spi_init+0x12c>
    34ac:	20000198 	.word	0x20000198
    34b0:	0bad0000 	.word	0x0bad0000
    34b4:	0bad0005 	.word	0x0bad0005

000034b8 <nrfx_spi_xfer>:
}

nrfx_err_t nrfx_spi_xfer(nrfx_spi_t const *           p_instance,
                         nrfx_spi_xfer_desc_t const * p_xfer_desc,
                         uint32_t                     flags)
{
    34b8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    34bc:	7906      	ldrb	r6, [r0, #4]
    NRFX_ASSERT(p_xfer_desc->p_tx_buffer != NULL || p_xfer_desc->tx_length == 0);
    NRFX_ASSERT(p_xfer_desc->p_rx_buffer != NULL || p_xfer_desc->rx_length == 0);

    nrfx_err_t err_code = NRFX_SUCCESS;

    if (p_cb->transfer_in_progress)
    34be:	4d42      	ldr	r5, [pc, #264]	; (35c8 <nrfx_spi_xfer+0x110>)
    34c0:	232c      	movs	r3, #44	; 0x2c
    34c2:	4373      	muls	r3, r6
{
    34c4:	4696      	mov	lr, r2
    if (p_cb->transfer_in_progress)
    34c6:	18ea      	adds	r2, r5, r3
{
    34c8:	460f      	mov	r7, r1
    if (p_cb->transfer_in_progress)
    34ca:	7f51      	ldrb	r1, [r2, #29]
{
    34cc:	4681      	mov	r9, r0
    if (p_cb->transfer_in_progress)
    34ce:	2900      	cmp	r1, #0
    34d0:	d178      	bne.n	35c4 <nrfx_spi_xfer+0x10c>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    else
    {
        if (p_cb->handler)
    34d2:	f855 c003 	ldr.w	ip, [r5, r3]
    34d6:	f1bc 0f00 	cmp.w	ip, #0
    34da:	d001      	beq.n	34e0 <nrfx_spi_xfer+0x28>
        {
            p_cb->transfer_in_progress = true;
    34dc:	2301      	movs	r3, #1
    34de:	7753      	strb	r3, [r2, #29]
        }
    }

    p_cb->evt.xfer_desc = *p_xfer_desc;
    34e0:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
    34e4:	242c      	movs	r4, #44	; 0x2c
    34e6:	fb04 5406 	mla	r4, r4, r6, r5
    34ea:	f104 080c 	add.w	r8, r4, #12
    34ee:	e888 000f 	stmia.w	r8, {r0, r1, r2, r3}
    p_cb->abort = false;

    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    34f2:	7fa2      	ldrb	r2, [r4, #30]
    p_cb->abort = false;
    34f4:	2300      	movs	r3, #0
    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    34f6:	2aff      	cmp	r2, #255	; 0xff
    p_cb->abort = false;
    34f8:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
    34fc:	bf1f      	itttt	ne
    34fe:	2301      	movne	r3, #1
    3500:	4093      	lslne	r3, r2
    p_reg->OUTCLR = clr_mask;
    3502:	f04f 42a0 	movne.w	r2, #1342177280	; 0x50000000
    3506:	f8c2 350c 	strne.w	r3, [r2, #1292]	; 0x50c
    {
        nrf_gpio_pin_clear(p_cb->ss_pin);
    }
    if (flags)
    350a:	232c      	movs	r3, #44	; 0x2c
    350c:	f1be 0f00 	cmp.w	lr, #0
    3510:	d007      	beq.n	3522 <nrfx_spi_xfer+0x6a>
    {
        p_cb->transfer_in_progress = false;
    3512:	fb03 5306 	mla	r3, r3, r6, r5
    3516:	2200      	movs	r2, #0
        err_code = NRFX_ERROR_NOT_SUPPORTED;
    3518:	482c      	ldr	r0, [pc, #176]	; (35cc <nrfx_spi_xfer+0x114>)
        p_cb->transfer_in_progress = false;
    351a:	775a      	strb	r2, [r3, #29]
    }
    NRFX_LOG_INFO("Function: %s, error code: %s.",
                  __func__,
                  NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    351c:	b003      	add	sp, #12
    351e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        spi_xfer(p_instance->p_reg, p_cb, p_xfer_desc);
    3522:	f8d9 4000 	ldr.w	r4, [r9]
    p_reg->INTENCLR = mask;
    3526:	2204      	movs	r2, #4
    3528:	f8c4 2308 	str.w	r2, [r4, #776]	; 0x308
    p_cb->bytes_transferred = 0;
    352c:	fb03 5306 	mla	r3, r3, r6, r5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    3530:	f8c4 e108 	str.w	lr, [r4, #264]	; 0x108
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    3534:	f8d4 2108 	ldr.w	r2, [r4, #264]	; 0x108
    3538:	f8c3 e024 	str.w	lr, [r3, #36]	; 0x24
    353c:	9200      	str	r2, [sp, #0]
    (void)dummy;
    353e:	9a00      	ldr	r2, [sp, #0]
        (p_xfer_desc->tx_length > 0 ? p_xfer_desc->p_tx_buffer[0] : p_cb->orc));
    3540:	687a      	ldr	r2, [r7, #4]
    nrf_spi_txd_set(p_spi,
    3542:	b18a      	cbz	r2, 3568 <nrfx_spi_xfer+0xb0>
    3544:	683b      	ldr	r3, [r7, #0]
    3546:	781b      	ldrb	r3, [r3, #0]
    p_reg->TXD = data;
    3548:	f8c4 351c 	str.w	r3, [r4, #1308]	; 0x51c
    if (p_xfer_desc->tx_length > 1)
    354c:	2a01      	cmp	r2, #1
    354e:	d90e      	bls.n	356e <nrfx_spi_xfer+0xb6>
        nrf_spi_txd_set(p_spi, p_xfer_desc->p_tx_buffer[1]);
    3550:	683b      	ldr	r3, [r7, #0]
    3552:	785b      	ldrb	r3, [r3, #1]
    3554:	f8c4 351c 	str.w	r3, [r4, #1308]	; 0x51c
    if (p_cb->handler)
    3558:	f1bc 0f00 	cmp.w	ip, #0
    355c:	d010      	beq.n	3580 <nrfx_spi_xfer+0xc8>
    p_reg->INTENSET = mask;
    355e:	2304      	movs	r3, #4
    3560:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
    nrfx_err_t err_code = NRFX_SUCCESS;
    3564:	481a      	ldr	r0, [pc, #104]	; (35d0 <nrfx_spi_xfer+0x118>)
    3566:	e7d9      	b.n	351c <nrfx_spi_xfer+0x64>
    nrf_spi_txd_set(p_spi,
    3568:	f893 3020 	ldrb.w	r3, [r3, #32]
    356c:	e7ec      	b.n	3548 <nrfx_spi_xfer+0x90>
    else if (p_xfer_desc->rx_length > 1)
    356e:	68fb      	ldr	r3, [r7, #12]
    3570:	2b01      	cmp	r3, #1
    3572:	d9f1      	bls.n	3558 <nrfx_spi_xfer+0xa0>
        nrf_spi_txd_set(p_spi, p_cb->orc);
    3574:	232c      	movs	r3, #44	; 0x2c
    3576:	fb03 5306 	mla	r3, r3, r6, r5
    p_reg->TXD = data;
    357a:	f893 3020 	ldrb.w	r3, [r3, #32]
    357e:	e7e9      	b.n	3554 <nrfx_spi_xfer+0x9c>
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    3580:	f04f 082c 	mov.w	r8, #44	; 0x2c
    3584:	fb06 5808 	mla	r8, r6, r8, r5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    3588:	4667      	mov	r7, ip
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    358a:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
            while (!nrf_spi_event_check(p_spi, NRF_SPI_EVENT_READY)) {}
    358e:	2b00      	cmp	r3, #0
    3590:	d0fb      	beq.n	358a <nrfx_spi_xfer+0xd2>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    3592:	f8c4 7108 	str.w	r7, [r4, #264]	; 0x108
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    3596:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
    359a:	9301      	str	r3, [sp, #4]
        } while (transfer_byte(p_spi, p_cb));
    359c:	4641      	mov	r1, r8
    359e:	4620      	mov	r0, r4
    (void)dummy;
    35a0:	9b01      	ldr	r3, [sp, #4]
    35a2:	f005 ffb8 	bl	9516 <transfer_byte>
    35a6:	2800      	cmp	r0, #0
    35a8:	d1ef      	bne.n	358a <nrfx_spi_xfer+0xd2>
        if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    35aa:	232c      	movs	r3, #44	; 0x2c
    35ac:	fb03 5506 	mla	r5, r3, r6, r5
    35b0:	7faa      	ldrb	r2, [r5, #30]
    35b2:	2aff      	cmp	r2, #255	; 0xff
    35b4:	d0d6      	beq.n	3564 <nrfx_spi_xfer+0xac>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    35b6:	2301      	movs	r3, #1
    35b8:	4093      	lsls	r3, r2
    p_reg->OUTSET = set_mask;
    35ba:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    35be:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    35c2:	e7cf      	b.n	3564 <nrfx_spi_xfer+0xac>
        return err_code;
    35c4:	4803      	ldr	r0, [pc, #12]	; (35d4 <nrfx_spi_xfer+0x11c>)
    35c6:	e7a9      	b.n	351c <nrfx_spi_xfer+0x64>
    35c8:	20000198 	.word	0x20000198
    35cc:	0bad0003 	.word	0x0bad0003
    35d0:	0bad0000 	.word	0x0bad0000
    35d4:	0bad000b 	.word	0x0bad000b

000035d8 <nrfx_spi_0_irq_handler>:
    }
}

#if NRFX_CHECK(NRFX_SPI0_ENABLED)
void nrfx_spi_0_irq_handler(void)
{
    35d8:	b513      	push	{r0, r1, r4, lr}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    35da:	4b10      	ldr	r3, [pc, #64]	; (361c <nrfx_spi_0_irq_handler+0x44>)
    if (!transfer_byte(p_spi, p_cb))
    35dc:	4c10      	ldr	r4, [pc, #64]	; (3620 <nrfx_spi_0_irq_handler+0x48>)
    35de:	4811      	ldr	r0, [pc, #68]	; (3624 <nrfx_spi_0_irq_handler+0x4c>)
    35e0:	2200      	movs	r2, #0
    35e2:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    35e4:	681b      	ldr	r3, [r3, #0]
    35e6:	9301      	str	r3, [sp, #4]
    35e8:	4621      	mov	r1, r4
    (void)dummy;
    35ea:	9b01      	ldr	r3, [sp, #4]
    35ec:	f005 ff93 	bl	9516 <transfer_byte>
    35f0:	b990      	cbnz	r0, 3618 <nrfx_spi_0_irq_handler+0x40>
    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    35f2:	7fa2      	ldrb	r2, [r4, #30]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
    35f4:	480c      	ldr	r0, [pc, #48]	; (3628 <nrfx_spi_0_irq_handler+0x50>)
    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    35f6:	2aff      	cmp	r2, #255	; 0xff
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    35f8:	bf1f      	itttt	ne
    35fa:	2301      	movne	r3, #1
    35fc:	4093      	lslne	r3, r2
    p_reg->OUTSET = set_mask;
    35fe:	f04f 42a0 	movne.w	r2, #1342177280	; 0x50000000
    3602:	f8c2 3508 	strne.w	r3, [r2, #1288]	; 0x508
    p_cb->transfer_in_progress = false;
    3606:	2300      	movs	r3, #0
    3608:	7763      	strb	r3, [r4, #29]
    p_cb->evt.type = NRFX_SPI_EVENT_DONE;
    360a:	7223      	strb	r3, [r4, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
    360c:	e9d4 3100 	ldrd	r3, r1, [r4]
    irq_handler(NRF_SPI0, &m_cb[NRFX_SPI0_INST_IDX]);
}
    3610:	b002      	add	sp, #8
    3612:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    p_cb->handler(&p_cb->evt, p_cb->p_context);
    3616:	4718      	bx	r3
}
    3618:	b002      	add	sp, #8
    361a:	bd10      	pop	{r4, pc}
    361c:	40003108 	.word	0x40003108
    3620:	20000198 	.word	0x20000198
    3624:	40003000 	.word	0x40003000
    3628:	200001a0 	.word	0x200001a0

0000362c <twi_rx_start_transfer>:
    return ret_code;
}

static nrfx_err_t twi_rx_start_transfer(NRF_TWI_Type        * p_twi,
                                        twi_control_block_t * p_cb)
{
    362c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    nrfx_err_t ret_code = NRFX_SUCCESS;
    volatile int32_t hw_timeout;

    hw_timeout = HW_TIMEOUT;
    362e:	4b34      	ldr	r3, [pc, #208]	; (3700 <twi_rx_start_transfer+0xd4>)
    3630:	9301      	str	r3, [sp, #4]
{
    3632:	460d      	mov	r5, r1

    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
    3634:	f44f 7182 	mov.w	r1, #260	; 0x104
{
    3638:	4604      	mov	r4, r0
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
    363a:	f005 ffa0 	bl	957e <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
    363e:	f44f 7192 	mov.w	r1, #292	; 0x124
    3642:	f005 ff9c 	bl	957e <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_TXDSENT);
    3646:	f44f 718e 	mov.w	r1, #284	; 0x11c
    364a:	f005 ff98 	bl	957e <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_RXDREADY);
    364e:	f44f 7184 	mov.w	r1, #264	; 0x108
    3652:	f005 ff94 	bl	957e <nrf_twi_event_clear>

    p_cb->bytes_transferred = 0;
    3656:	2300      	movs	r3, #0
    3658:	636b      	str	r3, [r5, #52]	; 0x34
    p_cb->error             = false;
    365a:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f

    if ((p_cb->curr_length == 1) && (!TWI_FLAG_SUSPEND(p_cb->flags)))
    365e:	6aab      	ldr	r3, [r5, #40]	; 0x28
    3660:	2b01      	cmp	r3, #1
    3662:	d118      	bne.n	3696 <twi_rx_start_transfer+0x6a>
    3664:	6a2b      	ldr	r3, [r5, #32]
    3666:	065b      	lsls	r3, r3, #25
    3668:	d415      	bmi.n	3696 <twi_rx_start_transfer+0x6a>
}

NRF_STATIC_INLINE void nrf_twi_shorts_set(NRF_TWI_Type * p_reg,
                                          uint32_t       mask)
{
    p_reg->SHORTS = mask;
    366a:	2302      	movs	r3, #2
        nrf_twi_shorts_set(p_twi, NRF_TWI_SHORT_BB_SUSPEND_MASK);
    }
    // In case TWI is suspended resume its operation.
    nrf_twi_task_trigger(p_twi, NRF_TWI_TASK_RESUME);

    if (p_cb->prev_suspend != TWI_SUSPEND_RX)
    366c:	f895 202d 	ldrb.w	r2, [r5, #45]	; 0x2d
    3670:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
    3674:	2a02      	cmp	r2, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    3676:	f04f 0301 	mov.w	r3, #1
    367a:	6223      	str	r3, [r4, #32]
    367c:	bf18      	it	ne
    367e:	6023      	strne	r3, [r4, #0]
    {
        nrf_twi_task_trigger(p_twi, NRF_TWI_TASK_STARTRX);
    }

    if (p_cb->handler)
    3680:	682b      	ldr	r3, [r5, #0]
    3682:	b193      	cbz	r3, 36aa <twi_rx_start_transfer+0x7e>
    {
        p_cb->int_mask = NRF_TWI_INT_STOPPED_MASK   |
    3684:	f240 2386 	movw	r3, #646	; 0x286
    3688:	60ab      	str	r3, [r5, #8]
                        NRF_TWI_INT_ERROR_MASK     |
                        NRF_TWI_INT_TXDSENT_MASK   |
                        NRF_TWI_INT_RXDREADY_MASK;
        nrf_twi_int_enable(p_twi, p_cb->int_mask);
    368a:	68ab      	ldr	r3, [r5, #8]
    nrfx_err_t ret_code = NRFX_SUCCESS;
    368c:	481d      	ldr	r0, [pc, #116]	; (3704 <twi_rx_start_transfer+0xd8>)
    p_reg->INTENSET = mask;
    368e:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
            nrf_twi_enable(p_twi);
            ret_code = NRFX_ERROR_INTERNAL;
        }
    }
    return ret_code;
}
    3692:	b003      	add	sp, #12
    3694:	bd30      	pop	{r4, r5, pc}
    p_reg->SHORTS = mask;
    3696:	2301      	movs	r3, #1
    3698:	e7e8      	b.n	366c <twi_rx_start_transfer+0x40>
               twi_transfer(p_twi, p_cb))
    369a:	4629      	mov	r1, r5
    369c:	4620      	mov	r0, r4
    369e:	f005 ff96 	bl	95ce <twi_transfer>
        while ((hw_timeout > 0) &&
    36a2:	b128      	cbz	r0, 36b0 <twi_rx_start_transfer+0x84>
               hw_timeout--;
    36a4:	9b01      	ldr	r3, [sp, #4]
    36a6:	3b01      	subs	r3, #1
    36a8:	9301      	str	r3, [sp, #4]
        while ((hw_timeout > 0) &&
    36aa:	9b01      	ldr	r3, [sp, #4]
    36ac:	2b00      	cmp	r3, #0
    36ae:	dcf4      	bgt.n	369a <twi_rx_start_transfer+0x6e>
        if (p_cb->error)
    36b0:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
    36b4:	b95b      	cbnz	r3, 36ce <twi_rx_start_transfer+0xa2>
    nrfx_err_t ret_code = NRFX_SUCCESS;
    36b6:	4813      	ldr	r0, [pc, #76]	; (3704 <twi_rx_start_transfer+0xd8>)
        if (hw_timeout <= 0)
    36b8:	9b01      	ldr	r3, [sp, #4]
    36ba:	2b00      	cmp	r3, #0
    36bc:	dce9      	bgt.n	3692 <twi_rx_start_transfer+0x66>
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos);
    36be:	2300      	movs	r3, #0
    36c0:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Enabled << TWI_ENABLE_ENABLE_Pos);
    36c4:	2305      	movs	r3, #5
    36c6:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
            ret_code = NRFX_ERROR_INTERNAL;
    36ca:	480f      	ldr	r0, [pc, #60]	; (3708 <twi_rx_start_transfer+0xdc>)
    return ret_code;
    36cc:	e7e1      	b.n	3692 <twi_rx_start_transfer+0x66>
    uint32_t error_source = p_reg->ERRORSRC;
    36ce:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
    36d2:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
            if (errorsrc)
    36d6:	2b00      	cmp	r3, #0
    36d8:	d0ed      	beq.n	36b6 <twi_rx_start_transfer+0x8a>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
    36da:	4a0c      	ldr	r2, [pc, #48]	; (370c <twi_rx_start_transfer+0xe0>)
    36dc:	480a      	ldr	r0, [pc, #40]	; (3708 <twi_rx_start_transfer+0xdc>)
    36de:	f013 0f01 	tst.w	r3, #1
    36e2:	bf18      	it	ne
    36e4:	4610      	movne	r0, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
    36e6:	f013 0f02 	tst.w	r3, #2
    36ea:	f102 0201 	add.w	r2, r2, #1
    36ee:	bf18      	it	ne
    36f0:	4610      	movne	r0, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
    36f2:	f013 0f04 	tst.w	r3, #4
    36f6:	4b06      	ldr	r3, [pc, #24]	; (3710 <twi_rx_start_transfer+0xe4>)
    36f8:	bf18      	it	ne
    36fa:	4618      	movne	r0, r3
    36fc:	e7dc      	b.n	36b8 <twi_rx_start_transfer+0x8c>
    36fe:	bf00      	nop
    3700:	000186a0 	.word	0x000186a0
    3704:	0bad0000 	.word	0x0bad0000
    3708:	0bad0001 	.word	0x0bad0001
    370c:	0bae0000 	.word	0x0bae0000
    3710:	0bae0002 	.word	0x0bae0002

00003714 <twi_tx_start_transfer>:
{
    3714:	b537      	push	{r0, r1, r2, r4, r5, lr}
    hw_timeout = HW_TIMEOUT;
    3716:	4b30      	ldr	r3, [pc, #192]	; (37d8 <twi_tx_start_transfer+0xc4>)
    3718:	9301      	str	r3, [sp, #4]
{
    371a:	460d      	mov	r5, r1
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
    371c:	f44f 7182 	mov.w	r1, #260	; 0x104
{
    3720:	4604      	mov	r4, r0
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
    3722:	f005 ff2c 	bl	957e <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
    3726:	f44f 7192 	mov.w	r1, #292	; 0x124
    372a:	f005 ff28 	bl	957e <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_TXDSENT);
    372e:	f44f 718e 	mov.w	r1, #284	; 0x11c
    3732:	f005 ff24 	bl	957e <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_RXDREADY);
    3736:	f44f 7184 	mov.w	r1, #264	; 0x108
    373a:	f005 ff20 	bl	957e <nrf_twi_event_clear>
    p_reg->SHORTS = mask;
    373e:	2300      	movs	r3, #0
    if (p_cb->prev_suspend != TWI_SUSPEND_TX)
    3740:	f895 202d 	ldrb.w	r2, [r5, #45]	; 0x2d
    3744:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
    p_cb->bytes_transferred = 0;
    3748:	636b      	str	r3, [r5, #52]	; 0x34
    p_cb->error             = false;
    374a:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    374e:	2301      	movs	r3, #1
    if (p_cb->prev_suspend != TWI_SUSPEND_TX)
    3750:	429a      	cmp	r2, r3
    3752:	6203      	str	r3, [r0, #32]
    (void)twi_send_byte(p_twi, p_cb);
    3754:	4629      	mov	r1, r5
    3756:	bf18      	it	ne
    3758:	6083      	strne	r3, [r0, #8]
    375a:	f005 ff18 	bl	958e <twi_send_byte>
    if (p_cb->handler)
    375e:	682b      	ldr	r3, [r5, #0]
    3760:	b183      	cbz	r3, 3784 <twi_tx_start_transfer+0x70>
        p_cb->int_mask = NRF_TWI_INT_STOPPED_MASK   |
    3762:	f240 2386 	movw	r3, #646	; 0x286
    3766:	60ab      	str	r3, [r5, #8]
        nrf_twi_int_enable(p_twi, p_cb->int_mask);
    3768:	68ab      	ldr	r3, [r5, #8]
    nrfx_err_t ret_code = NRFX_SUCCESS;
    376a:	481c      	ldr	r0, [pc, #112]	; (37dc <twi_tx_start_transfer+0xc8>)
    p_reg->INTENSET = mask;
    376c:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
    3770:	b003      	add	sp, #12
    3772:	bd30      	pop	{r4, r5, pc}
               twi_transfer(p_twi, p_cb))
    3774:	4629      	mov	r1, r5
    3776:	4620      	mov	r0, r4
    3778:	f005 ff29 	bl	95ce <twi_transfer>
        while ((hw_timeout > 0) &&
    377c:	b128      	cbz	r0, 378a <twi_tx_start_transfer+0x76>
            hw_timeout--;
    377e:	9b01      	ldr	r3, [sp, #4]
    3780:	3b01      	subs	r3, #1
    3782:	9301      	str	r3, [sp, #4]
        while ((hw_timeout > 0) &&
    3784:	9b01      	ldr	r3, [sp, #4]
    3786:	2b00      	cmp	r3, #0
    3788:	dcf4      	bgt.n	3774 <twi_tx_start_transfer+0x60>
        if (p_cb->error)
    378a:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
    378e:	b95b      	cbnz	r3, 37a8 <twi_tx_start_transfer+0x94>
    nrfx_err_t ret_code = NRFX_SUCCESS;
    3790:	4812      	ldr	r0, [pc, #72]	; (37dc <twi_tx_start_transfer+0xc8>)
        if (hw_timeout <= 0)
    3792:	9b01      	ldr	r3, [sp, #4]
    3794:	2b00      	cmp	r3, #0
    3796:	dceb      	bgt.n	3770 <twi_tx_start_transfer+0x5c>
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos);
    3798:	2300      	movs	r3, #0
    379a:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Enabled << TWI_ENABLE_ENABLE_Pos);
    379e:	2305      	movs	r3, #5
    37a0:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
            ret_code = NRFX_ERROR_INTERNAL;
    37a4:	480e      	ldr	r0, [pc, #56]	; (37e0 <twi_tx_start_transfer+0xcc>)
    return ret_code;
    37a6:	e7e3      	b.n	3770 <twi_tx_start_transfer+0x5c>
    uint32_t error_source = p_reg->ERRORSRC;
    37a8:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
    37ac:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
            if (errorsrc)
    37b0:	2b00      	cmp	r3, #0
    37b2:	d0ed      	beq.n	3790 <twi_tx_start_transfer+0x7c>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
    37b4:	4a0b      	ldr	r2, [pc, #44]	; (37e4 <twi_tx_start_transfer+0xd0>)
    37b6:	480a      	ldr	r0, [pc, #40]	; (37e0 <twi_tx_start_transfer+0xcc>)
    37b8:	f013 0f01 	tst.w	r3, #1
    37bc:	bf18      	it	ne
    37be:	4610      	movne	r0, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
    37c0:	f013 0f02 	tst.w	r3, #2
    37c4:	f102 0201 	add.w	r2, r2, #1
    37c8:	bf18      	it	ne
    37ca:	4610      	movne	r0, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
    37cc:	f013 0f04 	tst.w	r3, #4
    37d0:	4b05      	ldr	r3, [pc, #20]	; (37e8 <twi_tx_start_transfer+0xd4>)
    37d2:	bf18      	it	ne
    37d4:	4618      	movne	r0, r3
    37d6:	e7dc      	b.n	3792 <twi_tx_start_transfer+0x7e>
    37d8:	000186a0 	.word	0x000186a0
    37dc:	0bad0000 	.word	0x0bad0000
    37e0:	0bad0001 	.word	0x0bad0001
    37e4:	0bae0000 	.word	0x0bae0000
    37e8:	0bae0002 	.word	0x0bae0002

000037ec <nrfx_twi_init>:
{
    37ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    twi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    37ee:	7907      	ldrb	r7, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
    37f0:	4d1d      	ldr	r5, [pc, #116]	; (3868 <nrfx_twi_init+0x7c>)
    37f2:	f04f 0c3c 	mov.w	ip, #60	; 0x3c
    37f6:	fb0c fc07 	mul.w	ip, ip, r7
    37fa:	eb05 040c 	add.w	r4, r5, ip
    37fe:	f894 602e 	ldrb.w	r6, [r4, #46]	; 0x2e
    3802:	bb7e      	cbnz	r6, 3864 <nrfx_twi_init+0x78>
    p_cb->p_context       = p_context;
    3804:	6063      	str	r3, [r4, #4]
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
    3806:	7b4b      	ldrb	r3, [r1, #13]
    p_cb->int_mask        = 0;
    3808:	60a6      	str	r6, [r4, #8]
    p_cb->prev_suspend    = TWI_NO_SUSPEND;
    380a:	f884 602d 	strb.w	r6, [r4, #45]	; 0x2d
    p_cb->busy            = false;
    380e:	f884 6030 	strb.w	r6, [r4, #48]	; 0x30
    p_cb->repeated        = false;
    3812:	f884 6031 	strb.w	r6, [r4, #49]	; 0x31
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
    3816:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
    TWI_PIN_INIT(p_config->scl);
    381a:	680c      	ldr	r4, [r1, #0]
    p_cb->handler         = event_handler;
    381c:	f845 200c 	str.w	r2, [r5, ip]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    3820:	f04f 46a0 	mov.w	r6, #1342177280	; 0x50000000
    3824:	f504 73e0 	add.w	r3, r4, #448	; 0x1c0
    3828:	f240 6c0c 	movw	ip, #1548	; 0x60c
    382c:	f846 c023 	str.w	ip, [r6, r3, lsl #2]
    TWI_PIN_INIT(p_config->sda);
    3830:	684b      	ldr	r3, [r1, #4]
    NRF_TWI_Type * p_twi = p_instance->p_twi;
    3832:	6800      	ldr	r0, [r0, #0]
    3834:	f503 7ee0 	add.w	lr, r3, #448	; 0x1c0
    3838:	f846 c02e 	str.w	ip, [r6, lr, lsl #2]
    p_reg->PSELSCL = scl_pin;
    383c:	f8c0 4508 	str.w	r4, [r0, #1288]	; 0x508
    p_reg->PSELSDA = sda_pin;
    3840:	f8c0 350c 	str.w	r3, [r0, #1292]	; 0x50c
        (nrf_twi_frequency_t)p_config->frequency);
    3844:	688b      	ldr	r3, [r1, #8]
    p_reg->FREQUENCY = frequency;
    3846:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524
    if (p_cb->handler)
    384a:	b11a      	cbz	r2, 3854 <nrfx_twi_init+0x68>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twi));
    384c:	f340 3007 	sbfx	r0, r0, #12, #8
    3850:	f7fd fccc 	bl	11ec <arch_irq_enable>
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    3854:	233c      	movs	r3, #60	; 0x3c
    3856:	fb03 5507 	mla	r5, r3, r7, r5
    return err_code;
    385a:	4804      	ldr	r0, [pc, #16]	; (386c <nrfx_twi_init+0x80>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    385c:	2301      	movs	r3, #1
    385e:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e
}
    3862:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return err_code;
    3864:	4802      	ldr	r0, [pc, #8]	; (3870 <nrfx_twi_init+0x84>)
    3866:	e7fc      	b.n	3862 <nrfx_twi_init+0x76>
    3868:	200001c4 	.word	0x200001c4
    386c:	0bad0000 	.word	0x0bad0000
    3870:	0bad0005 	.word	0x0bad0005

00003874 <nrfx_twi_enable>:
    NRF_TWI_Type * p_twi = p_instance->p_twi;
    3874:	6802      	ldr	r2, [r0, #0]
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    3876:	7903      	ldrb	r3, [r0, #4]
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Enabled << TWI_ENABLE_ENABLE_Pos);
    3878:	2105      	movs	r1, #5
    387a:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
    387e:	4a04      	ldr	r2, [pc, #16]	; (3890 <nrfx_twi_enable+0x1c>)
    3880:	213c      	movs	r1, #60	; 0x3c
    3882:	fb01 2303 	mla	r3, r1, r3, r2
    3886:	2202      	movs	r2, #2
    3888:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
}
    388c:	4770      	bx	lr
    388e:	bf00      	nop
    3890:	200001c4 	.word	0x200001c4

00003894 <nrfx_twi_disable>:
    NRF_TWI_Type * p_twi = p_instance->p_twi;
    3894:	6803      	ldr	r3, [r0, #0]
    p_reg->INTENCLR = mask;
    3896:	490a      	ldr	r1, [pc, #40]	; (38c0 <nrfx_twi_disable+0x2c>)
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    3898:	7902      	ldrb	r2, [r0, #4]
    389a:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
    389e:	f8d3 1200 	ldr.w	r1, [r3, #512]	; 0x200
    38a2:	f021 0103 	bic.w	r1, r1, #3
    38a6:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos);
    38aa:	2100      	movs	r1, #0
    38ac:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    38b0:	4b04      	ldr	r3, [pc, #16]	; (38c4 <nrfx_twi_disable+0x30>)
    38b2:	213c      	movs	r1, #60	; 0x3c
    38b4:	fb01 3202 	mla	r2, r1, r2, r3
    38b8:	2301      	movs	r3, #1
    38ba:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
}
    38be:	4770      	bx	lr
    38c0:	00044286 	.word	0x00044286
    38c4:	200001c4 	.word	0x200001c4

000038c8 <nrfx_twi_xfer>:
}

nrfx_err_t nrfx_twi_xfer(nrfx_twi_t const *           p_instance,
                         nrfx_twi_xfer_desc_t const * p_xfer_desc,
                         uint32_t                     flags)
{
    38c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if ((p_cb->prev_suspend == TWI_SUSPEND_TX) && (p_xfer_desc->type == NRFX_TWI_XFER_RX))
    38cc:	4d32      	ldr	r5, [pc, #200]	; (3998 <nrfx_twi_xfer+0xd0>)

    nrfx_err_t err_code = NRFX_SUCCESS;
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    38ce:	f890 8004 	ldrb.w	r8, [r0, #4]
                           p_xfer_desc->primary_length * sizeof(p_xfer_desc->p_primary_buf[0]));
    NRFX_LOG_DEBUG("Secondary buffer data:");
    NRFX_LOG_HEXDUMP_DEBUG(p_xfer_desc->p_secondary_buf,
                           p_xfer_desc->secondary_length * sizeof(p_xfer_desc->p_secondary_buf[0]));

    err_code = twi_xfer((NRF_TWI_Type  *)p_instance->p_twi, p_cb, p_xfer_desc, flags);
    38d2:	f8d0 9000 	ldr.w	r9, [r0]
    if ((p_cb->prev_suspend == TWI_SUSPEND_TX) && (p_xfer_desc->type == NRFX_TWI_XFER_RX))
    38d6:	233c      	movs	r3, #60	; 0x3c
    38d8:	fb03 5308 	mla	r3, r3, r8, r5
{
    38dc:	460e      	mov	r6, r1
    if ((p_cb->prev_suspend == TWI_SUSPEND_TX) && (p_xfer_desc->type == NRFX_TWI_XFER_RX))
    38de:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
    38e2:	2b01      	cmp	r3, #1
{
    38e4:	4696      	mov	lr, r2
    if ((p_cb->prev_suspend == TWI_SUSPEND_TX) && (p_xfer_desc->type == NRFX_TWI_XFER_RX))
    38e6:	d104      	bne.n	38f2 <nrfx_twi_xfer+0x2a>
    38e8:	780b      	ldrb	r3, [r1, #0]
    38ea:	2b01      	cmp	r3, #1
    38ec:	d106      	bne.n	38fc <nrfx_twi_xfer+0x34>
        return NRFX_ERROR_INVALID_STATE;
    38ee:	482b      	ldr	r0, [pc, #172]	; (399c <nrfx_twi_xfer+0xd4>)
    NRFX_LOG_WARNING("Function: %s, error code: %s.",
                     __func__,
                     NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
    38f0:	e011      	b.n	3916 <nrfx_twi_xfer+0x4e>
    else if ((p_cb->prev_suspend == TWI_SUSPEND_RX) && (p_xfer_desc->type != NRFX_TWI_XFER_RX))
    38f2:	2b02      	cmp	r3, #2
    38f4:	d102      	bne.n	38fc <nrfx_twi_xfer+0x34>
    38f6:	780b      	ldrb	r3, [r1, #0]
    38f8:	2b01      	cmp	r3, #1
    38fa:	d1f8      	bne.n	38ee <nrfx_twi_xfer+0x26>
    if (p_cb->busy)
    38fc:	243c      	movs	r4, #60	; 0x3c
    p_reg->INTENCLR = mask;
    38fe:	4b28      	ldr	r3, [pc, #160]	; (39a0 <nrfx_twi_xfer+0xd8>)
    3900:	f8c9 3308 	str.w	r3, [r9, #776]	; 0x308
    3904:	fb04 5408 	mla	r4, r4, r8, r5
    3908:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
    390c:	b12b      	cbz	r3, 391a <nrfx_twi_xfer+0x52>
        nrf_twi_int_enable(p_twi, p_cb->int_mask);
    390e:	68a3      	ldr	r3, [r4, #8]
        return err_code;
    3910:	4824      	ldr	r0, [pc, #144]	; (39a4 <nrfx_twi_xfer+0xdc>)
    p_reg->INTENSET = mask;
    3912:	f8c9 3304 	str.w	r3, [r9, #772]	; 0x304
}
    3916:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        p_cb->busy = (TWI_FLAG_NO_HANDLER_IN_USE(flags)) ? false : true;
    391a:	f08e 0304 	eor.w	r3, lr, #4
    391e:	f3c3 0380 	ubfx	r3, r3, #2, #1
    3922:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
    p_cb->flags       = flags;
    3926:	f8c4 e020 	str.w	lr, [r4, #32]
    p_cb->xfer_desc   = *p_xfer_desc;
    392a:	46b4      	mov	ip, r6
    392c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    3930:	f104 070c 	add.w	r7, r4, #12
    3934:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    3936:	f8dc 3000 	ldr.w	r3, [ip]
    393a:	603b      	str	r3, [r7, #0]
    p_cb->curr_length = p_xfer_desc->primary_length;
    393c:	6873      	ldr	r3, [r6, #4]
    393e:	62a3      	str	r3, [r4, #40]	; 0x28
    p_cb->p_curr_buf  = p_xfer_desc->p_primary_buf;
    3940:	68f3      	ldr	r3, [r6, #12]
    3942:	6263      	str	r3, [r4, #36]	; 0x24
    p_reg->ADDRESS = address;
    3944:	7873      	ldrb	r3, [r6, #1]
    3946:	f8c9 3588 	str.w	r3, [r9, #1416]	; 0x588
    if (p_xfer_desc->type != NRFX_TWI_XFER_RX)
    394a:	7833      	ldrb	r3, [r6, #0]
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    394c:	ebc8 1a08 	rsb	sl, r8, r8, lsl #4
    if (p_xfer_desc->type != NRFX_TWI_XFER_RX)
    3950:	2b01      	cmp	r3, #1
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    3952:	eb05 0a8a 	add.w	sl, r5, sl, lsl #2
    if (p_xfer_desc->type != NRFX_TWI_XFER_RX)
    3956:	d01a      	beq.n	398e <nrfx_twi_xfer+0xc6>
                                 !(flags & NRFX_TWI_FLAG_TX_NO_STOP)) ? false : true;
    3958:	b9b3      	cbnz	r3, 3988 <nrfx_twi_xfer+0xc0>
    395a:	f3ce 1e40 	ubfx	lr, lr, #5, #1
        p_cb->curr_tx_no_stop = ((p_xfer_desc->type == NRFX_TWI_XFER_TX) &&
    395e:	233c      	movs	r3, #60	; 0x3c
    3960:	fb03 5308 	mla	r3, r3, r8, r5
        err_code = twi_tx_start_transfer(p_twi, p_cb);
    3964:	4651      	mov	r1, sl
                                 !(flags & NRFX_TWI_FLAG_TX_NO_STOP)) ? false : true;
    3966:	f883 e02c 	strb.w	lr, [r3, #44]	; 0x2c
        err_code = twi_tx_start_transfer(p_twi, p_cb);
    396a:	4648      	mov	r0, r9
    396c:	f7ff fed2 	bl	3714 <twi_tx_start_transfer>
    if (p_cb->handler == NULL)
    3970:	233c      	movs	r3, #60	; 0x3c
    3972:	fb03 f808 	mul.w	r8, r3, r8
    3976:	eb05 0208 	add.w	r2, r5, r8
    397a:	f855 3008 	ldr.w	r3, [r5, r8]
    397e:	2b00      	cmp	r3, #0
    3980:	d1c9      	bne.n	3916 <nrfx_twi_xfer+0x4e>
        p_cb->busy = false;
    3982:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
    3986:	e7c6      	b.n	3916 <nrfx_twi_xfer+0x4e>
                                 !(flags & NRFX_TWI_FLAG_TX_NO_STOP)) ? false : true;
    3988:	f04f 0e01 	mov.w	lr, #1
    398c:	e7e7      	b.n	395e <nrfx_twi_xfer+0x96>
        err_code = twi_rx_start_transfer(p_twi, p_cb);
    398e:	4651      	mov	r1, sl
    3990:	4648      	mov	r0, r9
    3992:	f7ff fe4b 	bl	362c <twi_rx_start_transfer>
    3996:	e7eb      	b.n	3970 <nrfx_twi_xfer+0xa8>
    3998:	200001c4 	.word	0x200001c4
    399c:	0bad0005 	.word	0x0bad0005
    39a0:	00044286 	.word	0x00044286
    39a4:	0bad000b 	.word	0x0bad000b

000039a8 <nrfx_twi_1_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_TWI1_ENABLED)
void nrfx_twi_1_irq_handler(void)
{
    39a8:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (twi_transfer(p_twi, p_cb))
    39aa:	4c29      	ldr	r4, [pc, #164]	; (3a50 <nrfx_twi_1_irq_handler+0xa8>)
{
    39ac:	b087      	sub	sp, #28
    if (twi_transfer(p_twi, p_cb))
    39ae:	4621      	mov	r1, r4
    39b0:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
    39b4:	f005 fe0b 	bl	95ce <twi_transfer>
    39b8:	46a4      	mov	ip, r4
    39ba:	b9e0      	cbnz	r0, 39f6 <nrfx_twi_1_irq_handler+0x4e>
    if (!p_cb->error &&
    39bc:	f894 702f 	ldrb.w	r7, [r4, #47]	; 0x2f
    39c0:	6a26      	ldr	r6, [r4, #32]
    39c2:	b9ef      	cbnz	r7, 3a00 <nrfx_twi_1_irq_handler+0x58>
        ((p_cb->xfer_desc.type == NRFX_TWI_XFER_TXRX) ||
    39c4:	7b23      	ldrb	r3, [r4, #12]
    if (!p_cb->error &&
    39c6:	1e9a      	subs	r2, r3, #2
    39c8:	2a01      	cmp	r2, #1
    39ca:	d819      	bhi.n	3a00 <nrfx_twi_1_irq_handler+0x58>
         (p_cb->xfer_desc.type == NRFX_TWI_XFER_TXTX)) &&
    39cc:	6a61      	ldr	r1, [r4, #36]	; 0x24
    39ce:	69a2      	ldr	r2, [r4, #24]
    39d0:	4291      	cmp	r1, r2
    39d2:	d115      	bne.n	3a00 <nrfx_twi_1_irq_handler+0x58>
        p_cb->p_curr_buf      = p_cb->xfer_desc.p_secondary_buf;
    39d4:	69e2      	ldr	r2, [r4, #28]
    39d6:	6262      	str	r2, [r4, #36]	; 0x24
        p_cb->curr_tx_no_stop = (p_cb->flags & NRFX_TWI_FLAG_TX_NO_STOP);
    39d8:	f3c6 1640 	ubfx	r6, r6, #5, #1
        p_cb->curr_length     = p_cb->xfer_desc.secondary_length;
    39dc:	6962      	ldr	r2, [r4, #20]
    39de:	62a2      	str	r2, [r4, #40]	; 0x28
        if (p_cb->xfer_desc.type == NRFX_TWI_XFER_TXTX)
    39e0:	2b03      	cmp	r3, #3
        p_cb->curr_tx_no_stop = (p_cb->flags & NRFX_TWI_FLAG_TX_NO_STOP);
    39e2:	f884 602c 	strb.w	r6, [r4, #44]	; 0x2c
        p_cb->prev_suspend    = TWI_NO_SUSPEND;
    39e6:	f884 702d 	strb.w	r7, [r4, #45]	; 0x2d
            (void)twi_tx_start_transfer(p_twi, p_cb);
    39ea:	4621      	mov	r1, r4
    39ec:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
        if (p_cb->xfer_desc.type == NRFX_TWI_XFER_TXTX)
    39f0:	d103      	bne.n	39fa <nrfx_twi_1_irq_handler+0x52>
            (void)twi_tx_start_transfer(p_twi, p_cb);
    39f2:	f7ff fe8f 	bl	3714 <twi_tx_start_transfer>
    twi_irq_handler(NRF_TWI1, &m_cb[NRFX_TWI1_INST_IDX]);
}
    39f6:	b007      	add	sp, #28
    39f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
            (void)twi_rx_start_transfer(p_twi, p_cb);
    39fa:	f7ff fe17 	bl	362c <twi_rx_start_transfer>
    39fe:	e7fa      	b.n	39f6 <nrfx_twi_1_irq_handler+0x4e>
        event.xfer_desc = p_cb->xfer_desc;
    3a00:	4d14      	ldr	r5, [pc, #80]	; (3a54 <nrfx_twi_1_irq_handler+0xac>)
    3a02:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3a04:	ac01      	add	r4, sp, #4
    3a06:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3a08:	682b      	ldr	r3, [r5, #0]
    3a0a:	6023      	str	r3, [r4, #0]
        if (p_cb->error)
    3a0c:	b1e7      	cbz	r7, 3a48 <nrfx_twi_1_irq_handler+0xa0>
    uint32_t error_source = p_reg->ERRORSRC;
    3a0e:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    3a12:	f8d2 34c4 	ldr.w	r3, [r2, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
    3a16:	f8c2 34c4 	str.w	r3, [r2, #1220]	; 0x4c4
            if (errorsrc & NRF_TWI_ERROR_ADDRESS_NACK)
    3a1a:	0798      	lsls	r0, r3, #30
    3a1c:	d50c      	bpl.n	3a38 <nrfx_twi_1_irq_handler+0x90>
                event.type = NRFX_TWI_EVT_ADDRESS_NACK;
    3a1e:	2301      	movs	r3, #1
                event.type = NRFX_TWI_EVT_DATA_NACK;
    3a20:	f88d 3000 	strb.w	r3, [sp]
        p_cb->busy = false;
    3a24:	2300      	movs	r3, #0
    3a26:	f88c 3030 	strb.w	r3, [ip, #48]	; 0x30
        if (!(TWI_FLAG_NO_HANDLER_IN_USE(p_cb->flags)))
    3a2a:	0773      	lsls	r3, r6, #29
    3a2c:	d4e3      	bmi.n	39f6 <nrfx_twi_1_irq_handler+0x4e>
            p_cb->handler(&event, p_cb->p_context);
    3a2e:	e9dc 3100 	ldrd	r3, r1, [ip]
    3a32:	4668      	mov	r0, sp
    3a34:	4798      	blx	r3
}
    3a36:	e7de      	b.n	39f6 <nrfx_twi_1_irq_handler+0x4e>
            else if (errorsrc & NRF_TWI_ERROR_DATA_NACK)
    3a38:	0759      	lsls	r1, r3, #29
    3a3a:	d501      	bpl.n	3a40 <nrfx_twi_1_irq_handler+0x98>
                event.type = NRFX_TWI_EVT_DATA_NACK;
    3a3c:	2302      	movs	r3, #2
    3a3e:	e7ef      	b.n	3a20 <nrfx_twi_1_irq_handler+0x78>
            else if (errorsrc & NRF_TWI_ERROR_OVERRUN)
    3a40:	07da      	lsls	r2, r3, #31
    3a42:	d5ef      	bpl.n	3a24 <nrfx_twi_1_irq_handler+0x7c>
                event.type = NRFX_TWI_EVT_OVERRUN;
    3a44:	2303      	movs	r3, #3
    3a46:	e7eb      	b.n	3a20 <nrfx_twi_1_irq_handler+0x78>
            event.type = NRFX_TWI_EVT_DONE;
    3a48:	f88d 7000 	strb.w	r7, [sp]
    3a4c:	e7ea      	b.n	3a24 <nrfx_twi_1_irq_handler+0x7c>
    3a4e:	bf00      	nop
    3a50:	200001c4 	.word	0x200001c4
    3a54:	200001d0 	.word	0x200001d0

00003a58 <lv_disp_get_scr_act>:
 * @param disp pointer to display which active screen should be get. (NULL to use the default
 * screen)
 * @return pointer to the active screen object (loaded by 'lv_scr_load()')
 */
lv_obj_t * lv_disp_get_scr_act(lv_disp_t * disp)
{
    3a58:	b510      	push	{r4, lr}
    if(!disp) disp = lv_disp_get_default();
    3a5a:	4604      	mov	r4, r0
    3a5c:	b958      	cbnz	r0, 3a76 <lv_disp_get_scr_act+0x1e>
    3a5e:	f001 ff53 	bl	5908 <lv_disp_get_default>
    if(!disp) {
    3a62:	4604      	mov	r4, r0
    3a64:	b938      	cbnz	r0, 3a76 <lv_disp_get_scr_act+0x1e>
        LV_LOG_WARN("lv_scr_act: no display registered to get its top layer");
    3a66:	4b05      	ldr	r3, [pc, #20]	; (3a7c <lv_disp_get_scr_act+0x24>)
    3a68:	4905      	ldr	r1, [pc, #20]	; (3a80 <lv_disp_get_scr_act+0x28>)
    3a6a:	222e      	movs	r2, #46	; 0x2e
    3a6c:	2002      	movs	r0, #2
    3a6e:	f002 fa7d 	bl	5f6c <lv_log_add>
        return NULL;
    }

    return disp->act_scr;
}
    3a72:	4620      	mov	r0, r4
    3a74:	bd10      	pop	{r4, pc}
    return disp->act_scr;
    3a76:	6b64      	ldr	r4, [r4, #52]	; 0x34
    3a78:	e7fb      	b.n	3a72 <lv_disp_get_scr_act+0x1a>
    3a7a:	bf00      	nop
    3a7c:	00045597 	.word	0x00045597
    3a80:	000455ce 	.word	0x000455ce

00003a84 <lv_disp_get_layer_top>:
 * Return with the top layer. (Same on every screen and it is above the normal screen layer)
 * @param disp pointer to display which top layer should be get. (NULL to use the default screen)
 * @return pointer to the top layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_top(lv_disp_t * disp)
{
    3a84:	b510      	push	{r4, lr}
    if(!disp) disp = lv_disp_get_default();
    3a86:	4604      	mov	r4, r0
    3a88:	b958      	cbnz	r0, 3aa2 <lv_disp_get_layer_top+0x1e>
    3a8a:	f001 ff3d 	bl	5908 <lv_disp_get_default>
    if(!disp) {
    3a8e:	4604      	mov	r4, r0
    3a90:	b938      	cbnz	r0, 3aa2 <lv_disp_get_layer_top+0x1e>
        LV_LOG_WARN("lv_layer_top: no display registered to get its top layer");
    3a92:	4b05      	ldr	r3, [pc, #20]	; (3aa8 <lv_disp_get_layer_top+0x24>)
    3a94:	4905      	ldr	r1, [pc, #20]	; (3aac <lv_disp_get_layer_top+0x28>)
    3a96:	224b      	movs	r2, #75	; 0x4b
    3a98:	2002      	movs	r0, #2
    3a9a:	f002 fa67 	bl	5f6c <lv_log_add>
        return NULL;
    }

    return disp->top_layer;
}
    3a9e:	4620      	mov	r0, r4
    3aa0:	bd10      	pop	{r4, pc}
    return disp->top_layer;
    3aa2:	6ba4      	ldr	r4, [r4, #56]	; 0x38
    3aa4:	e7fb      	b.n	3a9e <lv_disp_get_layer_top+0x1a>
    3aa6:	bf00      	nop
    3aa8:	0004555e 	.word	0x0004555e
    3aac:	000455ce 	.word	0x000455ce

00003ab0 <lv_disp_get_layer_sys>:
 * layer)
 * @param disp pointer to display which sys. layer  should be get. (NULL to use the default screen)
 * @return pointer to the sys layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_sys(lv_disp_t * disp)
{
    3ab0:	b510      	push	{r4, lr}
    if(!disp) disp = lv_disp_get_default();
    3ab2:	4604      	mov	r4, r0
    3ab4:	b958      	cbnz	r0, 3ace <lv_disp_get_layer_sys+0x1e>
    3ab6:	f001 ff27 	bl	5908 <lv_disp_get_default>
    if(!disp) {
    3aba:	4604      	mov	r4, r0
    3abc:	b938      	cbnz	r0, 3ace <lv_disp_get_layer_sys+0x1e>
        LV_LOG_WARN("lv_layer_sys: no display registered to get its top layer");
    3abe:	4b05      	ldr	r3, [pc, #20]	; (3ad4 <lv_disp_get_layer_sys+0x24>)
    3ac0:	4905      	ldr	r1, [pc, #20]	; (3ad8 <lv_disp_get_layer_sys+0x28>)
    3ac2:	225c      	movs	r2, #92	; 0x5c
    3ac4:	2002      	movs	r0, #2
    3ac6:	f002 fa51 	bl	5f6c <lv_log_add>
        return NULL;
    }

    return disp->sys_layer;
}
    3aca:	4620      	mov	r0, r4
    3acc:	bd10      	pop	{r4, pc}
    return disp->sys_layer;
    3ace:	6be4      	ldr	r4, [r4, #60]	; 0x3c
    3ad0:	e7fb      	b.n	3aca <lv_disp_get_layer_sys+0x1a>
    3ad2:	bf00      	nop
    3ad4:	00045525 	.word	0x00045525
    3ad8:	000455ce 	.word	0x000455ce

00003adc <lv_init>:

/**
 * Init. the 'lv' library.
 */
void lv_init(void)
{
    3adc:	b510      	push	{r4, lr}
    /* Do nothing if already initialized */
    if(lv_initialized) {
    3ade:	4c14      	ldr	r4, [pc, #80]	; (3b30 <lv_init+0x54>)
    3ae0:	7823      	ldrb	r3, [r4, #0]
    3ae2:	b13b      	cbz	r3, 3af4 <lv_init+0x18>
        LV_LOG_WARN("lv_init: already inited");
    3ae4:	4b13      	ldr	r3, [pc, #76]	; (3b34 <lv_init+0x58>)
    3ae6:	4914      	ldr	r1, [pc, #80]	; (3b38 <lv_init+0x5c>)
    3ae8:	2253      	movs	r2, #83	; 0x53
    3aea:	2002      	movs	r0, #2
    lv_img_decoder_init();
    lv_img_cache_set_size(LV_IMG_CACHE_DEF_SIZE);

    lv_initialized = true;
    LV_LOG_INFO("lv_init ready");
}
    3aec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LV_LOG_INFO("lv_init ready");
    3af0:	f002 ba3c 	b.w	5f6c <lv_log_add>
    lv_mem_init();
    3af4:	f007 fc7e 	bl	b3f4 <lv_mem_init>
    lv_task_core_init();
    3af8:	f001 ff36 	bl	5968 <lv_task_core_init>
    lv_style_init();
    3afc:	f000 fbe6 	bl	42cc <lv_style_init>
    lv_refr_init();
    3b00:	f006 f994 	bl	9e2c <lv_refr_init>
    lv_ll_init(&LV_GC_ROOT(_lv_disp_ll), sizeof(lv_disp_t));
    3b04:	f44f 71b4 	mov.w	r1, #360	; 0x168
    3b08:	480c      	ldr	r0, [pc, #48]	; (3b3c <lv_init+0x60>)
    3b0a:	f007 fc99 	bl	b440 <lv_ll_init>
    lv_ll_init(&LV_GC_ROOT(_lv_indev_ll), sizeof(lv_indev_t));
    3b0e:	2160      	movs	r1, #96	; 0x60
    3b10:	480b      	ldr	r0, [pc, #44]	; (3b40 <lv_init+0x64>)
    3b12:	f007 fc95 	bl	b440 <lv_ll_init>
    lv_indev_init();
    3b16:	f005 fddf 	bl	96d8 <lv_indev_init>
    lv_img_decoder_init();
    3b1a:	f001 fd65 	bl	55e8 <lv_img_decoder_init>
    lv_img_cache_set_size(LV_IMG_CACHE_DEF_SIZE);
    3b1e:	2001      	movs	r0, #1
    3b20:	f001 fe60 	bl	57e4 <lv_img_cache_set_size>
    lv_initialized = true;
    3b24:	2001      	movs	r0, #1
    3b26:	7020      	strb	r0, [r4, #0]
    LV_LOG_INFO("lv_init ready");
    3b28:	4b06      	ldr	r3, [pc, #24]	; (3b44 <lv_init+0x68>)
    3b2a:	4903      	ldr	r1, [pc, #12]	; (3b38 <lv_init+0x5c>)
    3b2c:	2279      	movs	r2, #121	; 0x79
    3b2e:	e7dd      	b.n	3aec <lv_init+0x10>
    3b30:	20008b8a 	.word	0x20008b8a
    3b34:	00045604 	.word	0x00045604
    3b38:	0004561c 	.word	0x0004561c
    3b3c:	20000634 	.word	0x20000634
    3b40:	20000654 	.word	0x20000654
    3b44:	00045651 	.word	0x00045651

00003b48 <lv_obj_get_disp>:
 * Get the display of an object
 * @param scr pointer to an object
 * @return pointer the object's display
 */
lv_disp_t * lv_obj_get_disp(const lv_obj_t * obj)
{
    3b48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);

    const lv_obj_t * scr;

    if(obj->par == NULL)
    3b4a:	6803      	ldr	r3, [r0, #0]
{
    3b4c:	4605      	mov	r5, r0
    if(obj->par == NULL)
    3b4e:	b97b      	cbnz	r3, 3b70 <lv_obj_get_disp+0x28>
        scr = obj; /*`obj` is a screen*/
    else
        scr = lv_obj_get_screen(obj); /*get the screen of `obj`*/

    lv_disp_t * d;
    LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d)
    3b50:	4813      	ldr	r0, [pc, #76]	; (3ba0 <lv_obj_get_disp+0x58>)
    3b52:	4f13      	ldr	r7, [pc, #76]	; (3ba0 <lv_obj_get_disp+0x58>)
    3b54:	f007 fcba 	bl	b4cc <lv_ll_get_head>
    3b58:	4604      	mov	r4, r0
    3b5a:	b96c      	cbnz	r4, 3b78 <lv_obj_get_disp+0x30>
        {
            if(s == scr) return d;
        }
    }

    LV_LOG_WARN("lv_scr_get_disp: screen not found")
    3b5c:	4b11      	ldr	r3, [pc, #68]	; (3ba4 <lv_obj_get_disp+0x5c>)
    3b5e:	4912      	ldr	r1, [pc, #72]	; (3ba8 <lv_obj_get_disp+0x60>)
    3b60:	f240 6267 	movw	r2, #1639	; 0x667
    3b64:	2002      	movs	r0, #2
    3b66:	f002 fa01 	bl	5f6c <lv_log_add>
    return NULL;
}
    3b6a:	4620      	mov	r0, r4
    3b6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    } while(par != NULL);
    3b6e:	461d      	mov	r5, r3
 */
lv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)
{
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);

    return obj->par;
    3b70:	682b      	ldr	r3, [r5, #0]
    } while(par != NULL);
    3b72:	2b00      	cmp	r3, #0
    3b74:	d1fb      	bne.n	3b6e <lv_obj_get_disp+0x26>
    3b76:	e7eb      	b.n	3b50 <lv_obj_get_disp+0x8>
        LV_LL_READ(d->scr_ll, s)
    3b78:	f104 0628 	add.w	r6, r4, #40	; 0x28
    3b7c:	4630      	mov	r0, r6
    3b7e:	f007 fca5 	bl	b4cc <lv_ll_get_head>
    3b82:	b928      	cbnz	r0, 3b90 <lv_obj_get_disp+0x48>
    LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d)
    3b84:	4621      	mov	r1, r4
    3b86:	4638      	mov	r0, r7
    3b88:	f007 fca6 	bl	b4d8 <lv_ll_get_next>
    3b8c:	4604      	mov	r4, r0
    3b8e:	e7e4      	b.n	3b5a <lv_obj_get_disp+0x12>
            if(s == scr) return d;
    3b90:	4285      	cmp	r5, r0
    3b92:	d0ea      	beq.n	3b6a <lv_obj_get_disp+0x22>
        LV_LL_READ(d->scr_ll, s)
    3b94:	4601      	mov	r1, r0
    3b96:	4630      	mov	r0, r6
    3b98:	f007 fc9e 	bl	b4d8 <lv_ll_get_next>
    3b9c:	e7f1      	b.n	3b82 <lv_obj_get_disp+0x3a>
    3b9e:	bf00      	nop
    3ba0:	20000634 	.word	0x20000634
    3ba4:	000456d7 	.word	0x000456d7
    3ba8:	0004561c 	.word	0x0004561c

00003bac <lv_obj_create>:
{
    3bac:	b570      	push	{r4, r5, r6, lr}
    3bae:	460d      	mov	r5, r1
    if(parent == NULL) {
    3bb0:	4606      	mov	r6, r0
    3bb2:	2800      	cmp	r0, #0
    3bb4:	f040 80d9 	bne.w	3d6a <lv_obj_create+0x1be>
        lv_disp_t * disp = lv_disp_get_default();
    3bb8:	f001 fea6 	bl	5908 <lv_disp_get_default>
        if(!disp) {
    3bbc:	4604      	mov	r4, r0
    3bbe:	b938      	cbnz	r0, 3bd0 <lv_obj_create+0x24>
            LV_LOG_WARN("lv_obj_create: not display created to so far. No place to assign the new screen");
    3bc0:	4b89      	ldr	r3, [pc, #548]	; (3de8 <lv_obj_create+0x23c>)
    3bc2:	498a      	ldr	r1, [pc, #552]	; (3dec <lv_obj_create+0x240>)
    3bc4:	2290      	movs	r2, #144	; 0x90
    3bc6:	2002      	movs	r0, #2
    3bc8:	f002 f9d0 	bl	5f6c <lv_log_add>
}
    3bcc:	4620      	mov	r0, r4
    3bce:	bd70      	pop	{r4, r5, r6, pc}
        new_obj = lv_ll_ins_head(&disp->scr_ll);
    3bd0:	3028      	adds	r0, #40	; 0x28
    3bd2:	f007 fc3f 	bl	b454 <lv_ll_ins_head>
        if(new_obj == NULL) return NULL;
    3bd6:	4604      	mov	r4, r0
    3bd8:	b908      	cbnz	r0, 3bde <lv_obj_create+0x32>
    3bda:	2400      	movs	r4, #0
    3bdc:	e7f6      	b.n	3bcc <lv_obj_create+0x20>
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
    3bde:	2138      	movs	r1, #56	; 0x38
        new_obj->par = NULL; /*Screens has no a parent*/
    3be0:	f840 6b04 	str.w	r6, [r0], #4
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
    3be4:	f007 fc2c 	bl	b440 <lv_ll_init>
        new_obj->signal_cb = lv_obj_signal;
    3be8:	4b81      	ldr	r3, [pc, #516]	; (3df0 <lv_obj_create+0x244>)
    3bea:	61e3      	str	r3, [r4, #28]
        new_obj->design_cb = lv_obj_design;
    3bec:	4b81      	ldr	r3, [pc, #516]	; (3df4 <lv_obj_create+0x248>)
    3bee:	6223      	str	r3, [r4, #32]
        new_obj->event_cb = NULL;
    3bf0:	61a6      	str	r6, [r4, #24]
        new_obj->coords.x1    = 0;
    3bf2:	6126      	str	r6, [r4, #16]
        new_obj->coords.x2    = lv_disp_get_hor_res(NULL) - 1;
    3bf4:	4630      	mov	r0, r6
    3bf6:	f001 fe8d 	bl	5914 <lv_disp_get_hor_res>
    3bfa:	3801      	subs	r0, #1
    3bfc:	82a0      	strh	r0, [r4, #20]
        new_obj->coords.y2    = lv_disp_get_ver_res(NULL) - 1;
    3bfe:	4630      	mov	r0, r6
    3c00:	f001 fe98 	bl	5934 <lv_disp_get_ver_res>
    3c04:	3801      	subs	r0, #1
    3c06:	82e0      	strh	r0, [r4, #22]
        new_obj->ext_draw_pad = 0;
    3c08:	8626      	strh	r6, [r4, #48]	; 0x30
        lv_theme_t * th = lv_theme_get_current();
    3c0a:	f002 ff17 	bl	6a3c <lv_theme_get_current>
        if(th) {
    3c0e:	2800      	cmp	r0, #0
    3c10:	f000 80a9 	beq.w	3d66 <lv_obj_create+0x1ba>
            new_obj->style_p = th->style.scr;
    3c14:	6803      	ldr	r3, [r0, #0]
    3c16:	62a3      	str	r3, [r4, #40]	; 0x28
        memset(&new_obj->user_data, 0, sizeof(lv_obj_user_data_t));
    3c18:	2204      	movs	r2, #4
    3c1a:	2100      	movs	r1, #0
    3c1c:	f104 0034 	add.w	r0, r4, #52	; 0x34
    3c20:	f004 fe90 	bl	8944 <memset>
        new_obj->click        = 0;
    3c24:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
        LV_LOG_INFO("Screen create ready");
    3c26:	4971      	ldr	r1, [pc, #452]	; (3dec <lv_obj_create+0x240>)
        new_obj->click        = 0;
    3c28:	f403 4303 	and.w	r3, r3, #33536	; 0x8300
    3c2c:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
    3c30:	62e3      	str	r3, [r4, #44]	; 0x2c
        new_obj->ext_attr = NULL;
    3c32:	2300      	movs	r3, #0
    3c34:	6263      	str	r3, [r4, #36]	; 0x24
        LV_LOG_INFO("Screen create ready");
    3c36:	22de      	movs	r2, #222	; 0xde
    3c38:	4b6f      	ldr	r3, [pc, #444]	; (3df8 <lv_obj_create+0x24c>)
    3c3a:	2001      	movs	r0, #1
    3c3c:	f002 f996 	bl	5f6c <lv_log_add>
    if(copy != NULL) {
    3c40:	2d00      	cmp	r5, #0
    3c42:	f000 8084 	beq.w	3d4e <lv_obj_create+0x1a2>
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
    memcpy(dest, src, sizeof(lv_area_t));
    3c46:	2208      	movs	r2, #8
    3c48:	f105 0110 	add.w	r1, r5, #16
    3c4c:	f104 0010 	add.w	r0, r4, #16
    3c50:	f004 fe4e 	bl	88f0 <memcpy>
        new_obj->ext_draw_pad = copy->ext_draw_pad;
    3c54:	f9b5 3030 	ldrsh.w	r3, [r5, #48]	; 0x30
    3c58:	8623      	strh	r3, [r4, #48]	; 0x30
        memcpy(&new_obj->user_data, &copy->user_data, sizeof(lv_obj_user_data_t));
    3c5a:	2204      	movs	r2, #4
    3c5c:	f105 0134 	add.w	r1, r5, #52	; 0x34
    3c60:	f104 0034 	add.w	r0, r4, #52	; 0x34
    3c64:	f004 fe44 	bl	88f0 <memcpy>
        new_obj->event_cb = copy->event_cb;
    3c68:	69ab      	ldr	r3, [r5, #24]
        new_obj->click        = copy->click;
    3c6a:	f895 202c 	ldrb.w	r2, [r5, #44]	; 0x2c
        new_obj->event_cb = copy->event_cb;
    3c6e:	61a3      	str	r3, [r4, #24]
        new_obj->click        = copy->click;
    3c70:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    3c74:	f362 0300 	bfi	r3, r2, #0, #1
    3c78:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
        new_obj->drag         = copy->drag;
    3c7c:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    3c80:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    3c84:	f3c3 0340 	ubfx	r3, r3, #1, #1
    3c88:	f363 0241 	bfi	r2, r3, #1, #1
    3c8c:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->drag_dir     = copy->drag_dir;
    3c90:	f895 202d 	ldrb.w	r2, [r5, #45]	; 0x2d
    3c94:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
    3c98:	f362 0301 	bfi	r3, r2, #0, #2
    3c9c:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
        new_obj->drag_throw   = copy->drag_throw;
    3ca0:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    3ca4:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    3ca8:	f3c3 0380 	ubfx	r3, r3, #2, #1
    3cac:	f363 0282 	bfi	r2, r3, #2, #1
    3cb0:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->drag_parent  = copy->drag_parent;
    3cb4:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    3cb8:	b2d2      	uxtb	r2, r2
    3cba:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    3cbe:	f363 02c3 	bfi	r2, r3, #3, #1
    3cc2:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->hidden       = copy->hidden;
    3cc6:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    3cca:	b2d2      	uxtb	r2, r2
    3ccc:	f3c3 1300 	ubfx	r3, r3, #4, #1
    3cd0:	f363 1204 	bfi	r2, r3, #4, #1
    3cd4:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->top          = copy->top;
    3cd8:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    3cdc:	b2d2      	uxtb	r2, r2
    3cde:	f3c3 1340 	ubfx	r3, r3, #5, #1
    3ce2:	f363 1245 	bfi	r2, r3, #5, #1
    3ce6:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->parent_event = copy->parent_event;
    3cea:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    3cee:	b2d2      	uxtb	r2, r2
    3cf0:	09db      	lsrs	r3, r3, #7
    3cf2:	f363 12c7 	bfi	r2, r3, #7, #1
    3cf6:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->opa_scale_en = copy->opa_scale_en;
    3cfa:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    3cfe:	b2d2      	uxtb	r2, r2
    3d00:	f3c3 1380 	ubfx	r3, r3, #6, #1
    3d04:	f363 1286 	bfi	r2, r3, #6, #1
    3d08:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->protect      = copy->protect;
    3d0c:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
    3d10:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
        new_obj->opa_scale    = copy->opa_scale;
    3d14:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
    3d18:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
        new_obj->style_p = copy->style_p;
    3d1c:	6aab      	ldr	r3, [r5, #40]	; 0x28
    3d1e:	62a3      	str	r3, [r4, #40]	; 0x28
        if(lv_obj_get_parent(copy) != NULL && parent != NULL) {
    3d20:	682b      	ldr	r3, [r5, #0]
    3d22:	2b00      	cmp	r3, #0
    3d24:	d05c      	beq.n	3de0 <lv_obj_create+0x234>
    3d26:	2e00      	cmp	r6, #0
    3d28:	d05a      	beq.n	3de0 <lv_obj_create+0x234>
            lv_obj_set_pos(new_obj, lv_obj_get_x(copy), lv_obj_get_y(copy));
    3d2a:	4628      	mov	r0, r5
    3d2c:	f005 fe31 	bl	9992 <lv_obj_get_x>
    3d30:	4601      	mov	r1, r0
    3d32:	4628      	mov	r0, r5
    3d34:	f005 fe35 	bl	99a2 <lv_obj_get_y>
    3d38:	4602      	mov	r2, r0
            lv_obj_set_pos(new_obj, 0, 0);
    3d3a:	4620      	mov	r0, r4
    3d3c:	f005 fd50 	bl	97e0 <lv_obj_set_pos>
        LV_LOG_INFO("Object create ready");
    3d40:	4b2e      	ldr	r3, [pc, #184]	; (3dfc <lv_obj_create+0x250>)
    3d42:	492a      	ldr	r1, [pc, #168]	; (3dec <lv_obj_create+0x240>)
    3d44:	f240 127d 	movw	r2, #381	; 0x17d
    3d48:	2001      	movs	r0, #1
    3d4a:	f002 f90f 	bl	5f6c <lv_log_add>
    if(parent != NULL) {
    3d4e:	2e00      	cmp	r6, #0
    3d50:	f43f af3c 	beq.w	3bcc <lv_obj_create+0x20>
        parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, new_obj);
    3d54:	69f3      	ldr	r3, [r6, #28]
    3d56:	4622      	mov	r2, r4
    3d58:	2101      	movs	r1, #1
    3d5a:	4630      	mov	r0, r6
    3d5c:	4798      	blx	r3
        lv_obj_invalidate(new_obj);
    3d5e:	4620      	mov	r0, r4
    3d60:	f005 fcee 	bl	9740 <lv_obj_invalidate>
    3d64:	e732      	b.n	3bcc <lv_obj_create+0x20>
            new_obj->style_p = &lv_style_scr;
    3d66:	4b26      	ldr	r3, [pc, #152]	; (3e00 <lv_obj_create+0x254>)
    3d68:	e755      	b.n	3c16 <lv_obj_create+0x6a>
        new_obj = lv_ll_ins_head(&parent->child_ll);
    3d6a:	3004      	adds	r0, #4
    3d6c:	f007 fb72 	bl	b454 <lv_ll_ins_head>
        if(new_obj == NULL) return NULL;
    3d70:	4604      	mov	r4, r0
    3d72:	2800      	cmp	r0, #0
    3d74:	f43f af31 	beq.w	3bda <lv_obj_create+0x2e>
        new_obj->par = parent; /*Set the parent*/
    3d78:	f840 6b04 	str.w	r6, [r0], #4
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
    3d7c:	2138      	movs	r1, #56	; 0x38
    3d7e:	f007 fb5f 	bl	b440 <lv_ll_init>
        new_obj->signal_cb = lv_obj_signal;
    3d82:	4b1b      	ldr	r3, [pc, #108]	; (3df0 <lv_obj_create+0x244>)
        new_obj->base_dir     = LV_BIDI_DIR_LTR;
    3d84:	f894 202d 	ldrb.w	r2, [r4, #45]	; 0x2d
        new_obj->signal_cb = lv_obj_signal;
    3d88:	61e3      	str	r3, [r4, #28]
        new_obj->design_cb = lv_obj_design;
    3d8a:	4b1a      	ldr	r3, [pc, #104]	; (3df4 <lv_obj_create+0x248>)
    3d8c:	6223      	str	r3, [r4, #32]
        new_obj->event_cb = NULL;
    3d8e:	2300      	movs	r3, #0
        new_obj->base_dir     = LV_BIDI_DIR_LTR;
    3d90:	f363 0283 	bfi	r2, r3, #2, #2
    3d94:	f884 202d 	strb.w	r2, [r4, #45]	; 0x2d
        new_obj->coords.y1    = parent->coords.y1;
    3d98:	f9b6 2012 	ldrsh.w	r2, [r6, #18]
    3d9c:	8262      	strh	r2, [r4, #18]
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
    3d9e:	8a72      	ldrh	r2, [r6, #18]
        new_obj->event_cb = NULL;
    3da0:	61a3      	str	r3, [r4, #24]
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
    3da2:	3242      	adds	r2, #66	; 0x42
    3da4:	82e2      	strh	r2, [r4, #22]
            new_obj->coords.x1    = parent->coords.x1;
    3da6:	f9b6 2010 	ldrsh.w	r2, [r6, #16]
    3daa:	8222      	strh	r2, [r4, #16]
            new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;
    3dac:	8a32      	ldrh	r2, [r6, #16]
        new_obj->ext_draw_pad = 0;
    3dae:	8623      	strh	r3, [r4, #48]	; 0x30
            new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;
    3db0:	3264      	adds	r2, #100	; 0x64
    3db2:	82a2      	strh	r2, [r4, #20]
        lv_theme_t * th = lv_theme_get_current();
    3db4:	f002 fe42 	bl	6a3c <lv_theme_get_current>
        if(th) {
    3db8:	b180      	cbz	r0, 3ddc <lv_obj_create+0x230>
            new_obj->style_p = th->style.panel;
    3dba:	6883      	ldr	r3, [r0, #8]
    3dbc:	62a3      	str	r3, [r4, #40]	; 0x28
        memset(&new_obj->user_data, 0, sizeof(lv_obj_user_data_t));
    3dbe:	2204      	movs	r2, #4
    3dc0:	2100      	movs	r1, #0
    3dc2:	f104 0034 	add.w	r0, r4, #52	; 0x34
    3dc6:	f004 fdbd 	bl	8944 <memset>
        new_obj->click        = 1;
    3dca:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    3dcc:	f403 420c 	and.w	r2, r3, #35840	; 0x8c00
    3dd0:	4b0c      	ldr	r3, [pc, #48]	; (3e04 <lv_obj_create+0x258>)
    3dd2:	4313      	orrs	r3, r2
    3dd4:	62e3      	str	r3, [r4, #44]	; 0x2c
        new_obj->ext_attr = NULL;
    3dd6:	2300      	movs	r3, #0
    3dd8:	6263      	str	r3, [r4, #36]	; 0x24
    3dda:	e731      	b.n	3c40 <lv_obj_create+0x94>
            new_obj->style_p = &lv_style_plain_color;
    3ddc:	4b0a      	ldr	r3, [pc, #40]	; (3e08 <lv_obj_create+0x25c>)
    3dde:	e7ed      	b.n	3dbc <lv_obj_create+0x210>
            lv_obj_set_pos(new_obj, 0, 0);
    3de0:	2200      	movs	r2, #0
    3de2:	4611      	mov	r1, r2
    3de4:	e7a9      	b.n	3d3a <lv_obj_create+0x18e>
    3de6:	bf00      	nop
    3de8:	0004565f 	.word	0x0004565f
    3dec:	0004561c 	.word	0x0004561c
    3df0:	00003e2d 	.word	0x00003e2d
    3df4:	00009c27 	.word	0x00009c27
    3df8:	000456af 	.word	0x000456af
    3dfc:	000456c3 	.word	0x000456c3
    3e00:	200004d8 	.word	0x200004d8
    3e04:	ff000301 	.word	0xff000301
    3e08:	200003e8 	.word	0x200003e8

00003e0c <lv_obj_get_style>:
 */
const lv_style_t * lv_obj_get_style(const lv_obj_t * obj)
{
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);

    const lv_style_t * style_act = obj->style_p;
    3e0c:	6a83      	ldr	r3, [r0, #40]	; 0x28
    if(style_act == NULL) {
    3e0e:	b913      	cbnz	r3, 3e16 <lv_obj_get_style+0xa>
        lv_obj_t * par = obj->par;
    3e10:	6802      	ldr	r2, [r0, #0]

        while(par) {
    3e12:	b912      	cbnz	r2, 3e1a <lv_obj_get_style+0xe>
            style_act = lv_group_mod_style(obj->group_p, style_act);
        }
    }
#endif

    if(style_act == NULL) style_act = &lv_style_plain;
    3e14:	4b04      	ldr	r3, [pc, #16]	; (3e28 <lv_obj_get_style+0x1c>)

    return style_act;
}
    3e16:	4618      	mov	r0, r3
    3e18:	4770      	bx	lr
            if(par->style_p) {
    3e1a:	6a93      	ldr	r3, [r2, #40]	; 0x28
    3e1c:	b113      	cbz	r3, 3e24 <lv_obj_get_style+0x18>
                if(par->style_p->glass == 0) {
    3e1e:	7819      	ldrb	r1, [r3, #0]
    3e20:	07c9      	lsls	r1, r1, #31
    3e22:	d5f8      	bpl.n	3e16 <lv_obj_get_style+0xa>
            par = par->par;
    3e24:	6812      	ldr	r2, [r2, #0]
    3e26:	e7f4      	b.n	3e12 <lv_obj_get_style+0x6>
    3e28:	20000398 	.word	0x20000398

00003e2c <lv_obj_signal>:
 * @param param parameter for the signal (depends on signal type)
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_obj_signal(lv_obj_t * obj, lv_signal_t sign, void * param)
{
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    3e2c:	2907      	cmp	r1, #7
{
    3e2e:	b510      	push	{r4, lr}
    3e30:	4604      	mov	r4, r0
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    3e32:	d105      	bne.n	3e40 <lv_obj_signal+0x14>
    3e34:	490f      	ldr	r1, [pc, #60]	; (3e74 <lv_obj_signal+0x48>)
    3e36:	4610      	mov	r0, r2
        if(style->body.shadow.width > obj->ext_draw_pad) obj->ext_draw_pad = style->body.shadow.width;
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
        lv_obj_refresh_ext_draw_pad(obj);
    }
    return res;
}
    3e38:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    3e3c:	f005 bf49 	b.w	9cd2 <lv_obj_handle_get_type_signal>
    if(sign == LV_SIGNAL_CHILD_CHG) {
    3e40:	2901      	cmp	r1, #1
    3e42:	d105      	bne.n	3e50 <lv_obj_signal+0x24>
    return (obj->protect & prot) == 0 ? false : true;
    3e44:	f890 002e 	ldrb.w	r0, [r0, #46]	; 0x2e
    3e48:	43c0      	mvns	r0, r0
    3e4a:	f000 0001 	and.w	r0, r0, #1
}
    3e4e:	bd10      	pop	{r4, pc}
    } else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
    3e50:	2906      	cmp	r1, #6
    3e52:	d10a      	bne.n	3e6a <lv_obj_signal+0x3e>
        const lv_style_t * style = lv_obj_get_style(obj);
    3e54:	f7ff ffda 	bl	3e0c <lv_obj_get_style>
        if(style->body.shadow.width > obj->ext_draw_pad) obj->ext_draw_pad = style->body.shadow.width;
    3e58:	f9b4 2030 	ldrsh.w	r2, [r4, #48]	; 0x30
    3e5c:	f9b0 301c 	ldrsh.w	r3, [r0, #28]
    3e60:	429a      	cmp	r2, r3
    3e62:	da00      	bge.n	3e66 <lv_obj_signal+0x3a>
    3e64:	8623      	strh	r3, [r4, #48]	; 0x30
    lv_res_t res = LV_RES_OK;
    3e66:	2001      	movs	r0, #1
    3e68:	e7f1      	b.n	3e4e <lv_obj_signal+0x22>
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
    3e6a:	2904      	cmp	r1, #4
    3e6c:	d1fb      	bne.n	3e66 <lv_obj_signal+0x3a>
        lv_obj_refresh_ext_draw_pad(obj);
    3e6e:	f005 fcfd 	bl	986c <lv_obj_refresh_ext_draw_pad>
    3e72:	e7f8      	b.n	3e66 <lv_obj_signal+0x3a>
    3e74:	000456f9 	.word	0x000456f9

00003e78 <lv_refr_vdb_flush>:

/**
 * Flush the content of the VDB
 */
static void lv_refr_vdb_flush(void)
{
    3e78:	b538      	push	{r3, r4, r5, lr}
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    3e7a:	4d10      	ldr	r5, [pc, #64]	; (3ebc <lv_refr_vdb_flush+0x44>)
    3e7c:	6828      	ldr	r0, [r5, #0]
    3e7e:	f007 f9b4 	bl	b1ea <lv_disp_get_buf>
    3e82:	4604      	mov	r4, r0

    /*In double buffered mode wait until the other buffer is flushed before flushing the current
     * one*/
    if(lv_disp_is_double_buf(disp_refr)) {
    3e84:	6828      	ldr	r0, [r5, #0]
    3e86:	f007 f9b2 	bl	b1ee <lv_disp_is_double_buf>
    3e8a:	b110      	cbz	r0, 3e92 <lv_refr_vdb_flush+0x1a>
        while(vdb->flushing)
    3e8c:	69a3      	ldr	r3, [r4, #24]
    3e8e:	07db      	lsls	r3, r3, #31
    3e90:	d4fc      	bmi.n	3e8c <lv_refr_vdb_flush+0x14>
            ;
    }

    vdb->flushing = 1;
    3e92:	7e23      	ldrb	r3, [r4, #24]
    return disp_refr;
    3e94:	6828      	ldr	r0, [r5, #0]
    vdb->flushing = 1;
    3e96:	f043 0301 	orr.w	r3, r3, #1
    3e9a:	7623      	strb	r3, [r4, #24]

    /*Flush the rendered content to the display*/
    lv_disp_t * disp = lv_refr_get_disp_refreshing();
    if(disp->driver.flush_cb) disp->driver.flush_cb(&disp->driver, &vdb->area, vdb->buf_act);
    3e9c:	68c3      	ldr	r3, [r0, #12]
    3e9e:	b11b      	cbz	r3, 3ea8 <lv_refr_vdb_flush+0x30>
    3ea0:	68a2      	ldr	r2, [r4, #8]
    3ea2:	f104 0110 	add.w	r1, r4, #16
    3ea6:	4798      	blx	r3

    if(vdb->buf1 && vdb->buf2) {
    3ea8:	6823      	ldr	r3, [r4, #0]
    3eaa:	b133      	cbz	r3, 3eba <lv_refr_vdb_flush+0x42>
    3eac:	6862      	ldr	r2, [r4, #4]
    3eae:	b122      	cbz	r2, 3eba <lv_refr_vdb_flush+0x42>
        if(vdb->buf_act == vdb->buf1)
    3eb0:	68a1      	ldr	r1, [r4, #8]
            vdb->buf_act = vdb->buf2;
    3eb2:	428b      	cmp	r3, r1
    3eb4:	bf08      	it	eq
    3eb6:	4613      	moveq	r3, r2
    3eb8:	60a3      	str	r3, [r4, #8]
        else
            vdb->buf_act = vdb->buf1;
    }
}
    3eba:	bd38      	pop	{r3, r4, r5, pc}
    3ebc:	20000200 	.word	0x20000200

00003ec0 <lv_refr_obj_and_children>:
{
    3ec0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3ec2:	460e      	mov	r6, r1
    if(top_p == NULL) top_p = lv_disp_get_scr_act(disp_refr);
    3ec4:	4605      	mov	r5, r0
    3ec6:	b920      	cbnz	r0, 3ed2 <lv_refr_obj_and_children+0x12>
    3ec8:	4b12      	ldr	r3, [pc, #72]	; (3f14 <lv_refr_obj_and_children+0x54>)
    3eca:	6818      	ldr	r0, [r3, #0]
    3ecc:	f7ff fdc4 	bl	3a58 <lv_disp_get_scr_act>
    3ed0:	4605      	mov	r5, r0
    lv_refr_obj(top_p, mask_p);
    3ed2:	4628      	mov	r0, r5
    3ed4:	4631      	mov	r1, r6
    3ed6:	f005 ff3c 	bl	9d52 <lv_refr_obj>
    par = lv_obj_get_parent(top_p);
    3eda:	4628      	mov	r0, r5
    3edc:	f005 fd24 	bl	9928 <lv_obj_get_parent>
        par = lv_obj_get_parent(par);
    3ee0:	4604      	mov	r4, r0
    while(par != NULL) {
    3ee2:	b900      	cbnz	r0, 3ee6 <lv_refr_obj_and_children+0x26>
}
    3ee4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        lv_obj_t * i = lv_ll_get_prev(&(par->child_ll), border_p);
    3ee6:	1d27      	adds	r7, r4, #4
            i = lv_ll_get_prev(&(par->child_ll), i);
    3ee8:	4629      	mov	r1, r5
    3eea:	4638      	mov	r0, r7
    3eec:	f007 fb04 	bl	b4f8 <lv_ll_get_prev>
    3ef0:	4605      	mov	r5, r0
        while(i != NULL) {
    3ef2:	b948      	cbnz	r0, 3f08 <lv_refr_obj_and_children+0x48>
        par->design_cb(par, mask_p, LV_DESIGN_DRAW_POST);
    3ef4:	6a23      	ldr	r3, [r4, #32]
    3ef6:	2201      	movs	r2, #1
    3ef8:	4631      	mov	r1, r6
    3efa:	4620      	mov	r0, r4
    3efc:	4798      	blx	r3
        par = lv_obj_get_parent(par);
    3efe:	4620      	mov	r0, r4
    3f00:	f005 fd12 	bl	9928 <lv_obj_get_parent>
    3f04:	4625      	mov	r5, r4
    3f06:	e7eb      	b.n	3ee0 <lv_refr_obj_and_children+0x20>
            lv_refr_obj(i, mask_p);
    3f08:	4631      	mov	r1, r6
    3f0a:	4628      	mov	r0, r5
    3f0c:	f005 ff21 	bl	9d52 <lv_refr_obj>
    3f10:	e7ea      	b.n	3ee8 <lv_refr_obj_and_children+0x28>
    3f12:	bf00      	nop
    3f14:	20000200 	.word	0x20000200

00003f18 <lv_refr_area_part>:
{
    3f18:	b573      	push	{r0, r1, r4, r5, r6, lr}
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    3f1a:	4c18      	ldr	r4, [pc, #96]	; (3f7c <lv_refr_area_part+0x64>)
{
    3f1c:	4606      	mov	r6, r0
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    3f1e:	6820      	ldr	r0, [r4, #0]
    3f20:	f007 f963 	bl	b1ea <lv_disp_get_buf>
    3f24:	4605      	mov	r5, r0
    if(lv_disp_is_double_buf(disp_refr) == false) {
    3f26:	6820      	ldr	r0, [r4, #0]
    3f28:	f007 f961 	bl	b1ee <lv_disp_is_double_buf>
    3f2c:	b910      	cbnz	r0, 3f34 <lv_refr_area_part+0x1c>
        while(vdb->flushing)
    3f2e:	69ab      	ldr	r3, [r5, #24]
    3f30:	07db      	lsls	r3, r3, #31
    3f32:	d4fc      	bmi.n	3f2e <lv_refr_area_part+0x16>
    lv_area_intersect(&start_mask, area_p, &vdb->area);
    3f34:	f105 0210 	add.w	r2, r5, #16
    3f38:	4631      	mov	r1, r6
    3f3a:	4668      	mov	r0, sp
    3f3c:	f007 f9b7 	bl	b2ae <lv_area_intersect>
    top_p = lv_refr_get_top_obj(&start_mask, lv_disp_get_scr_act(disp_refr));
    3f40:	6820      	ldr	r0, [r4, #0]
    3f42:	f7ff fd89 	bl	3a58 <lv_disp_get_scr_act>
    3f46:	4601      	mov	r1, r0
    3f48:	4668      	mov	r0, sp
    3f4a:	f005 fed0 	bl	9cee <lv_refr_get_top_obj>
    lv_refr_obj_and_children(top_p, &start_mask);
    3f4e:	4669      	mov	r1, sp
    3f50:	f7ff ffb6 	bl	3ec0 <lv_refr_obj_and_children>
    lv_refr_obj_and_children(lv_disp_get_layer_top(disp_refr), &start_mask);
    3f54:	6820      	ldr	r0, [r4, #0]
    3f56:	f7ff fd95 	bl	3a84 <lv_disp_get_layer_top>
    3f5a:	4669      	mov	r1, sp
    3f5c:	f7ff ffb0 	bl	3ec0 <lv_refr_obj_and_children>
    lv_refr_obj_and_children(lv_disp_get_layer_sys(disp_refr), &start_mask);
    3f60:	6820      	ldr	r0, [r4, #0]
    3f62:	f7ff fda5 	bl	3ab0 <lv_disp_get_layer_sys>
    3f66:	4669      	mov	r1, sp
    3f68:	f7ff ffaa 	bl	3ec0 <lv_refr_obj_and_children>
    if(lv_disp_is_true_double_buf(disp_refr) == false) {
    3f6c:	6820      	ldr	r0, [r4, #0]
    3f6e:	f007 f946 	bl	b1fe <lv_disp_is_true_double_buf>
    3f72:	b908      	cbnz	r0, 3f78 <lv_refr_area_part+0x60>
        lv_refr_vdb_flush();
    3f74:	f7ff ff80 	bl	3e78 <lv_refr_vdb_flush>
}
    3f78:	b002      	add	sp, #8
    3f7a:	bd70      	pop	{r4, r5, r6, pc}
    3f7c:	20000200 	.word	0x20000200

00003f80 <lv_refr_get_disp_refreshing>:
}
    3f80:	4b01      	ldr	r3, [pc, #4]	; (3f88 <lv_refr_get_disp_refreshing+0x8>)
    3f82:	6818      	ldr	r0, [r3, #0]
    3f84:	4770      	bx	lr
    3f86:	bf00      	nop
    3f88:	20000200 	.word	0x20000200

00003f8c <lv_disp_refr_task>:
{
    3f8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3f90:	b089      	sub	sp, #36	; 0x24
    3f92:	4605      	mov	r5, r0
    uint32_t start = lv_tick_get();
    3f94:	f007 f942 	bl	b21c <lv_tick_get>
    disp_refr = task->user_data;
    3f98:	4cae      	ldr	r4, [pc, #696]	; (4254 <CONFIG_HEAP_MEM_POOL_SIZE+0x254>)
    3f9a:	68eb      	ldr	r3, [r5, #12]
    uint32_t start = lv_tick_get();
    3f9c:	9003      	str	r0, [sp, #12]
    disp_refr = task->user_data;
    3f9e:	6023      	str	r3, [r4, #0]
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
    3fa0:	2600      	movs	r6, #0
    3fa2:	6823      	ldr	r3, [r4, #0]
    3fa4:	f8b3 2160 	ldrh.w	r2, [r3, #352]	; 0x160
    3fa8:	f3c2 0209 	ubfx	r2, r2, #0, #10
    3fac:	4296      	cmp	r6, r2
    3fae:	d330      	bcc.n	4012 <CONFIG_HEAP_MEM_POOL_SIZE+0x12>
    px_num = 0;
    3fb0:	4ba9      	ldr	r3, [pc, #676]	; (4258 <CONFIG_HEAP_MEM_POOL_SIZE+0x258>)
            if(disp_refr->driver.monitor_cb) px_num += lv_area_get_size(&disp_refr->inv_areas[i]);
    3fb2:	9302      	str	r3, [sp, #8]
    px_num = 0;
    3fb4:	2200      	movs	r2, #0
    3fb6:	601a      	str	r2, [r3, #0]
    for(i = 0; i < disp_refr->inv_p; i++) {
    3fb8:	4690      	mov	r8, r2
    3fba:	6827      	ldr	r7, [r4, #0]
    3fbc:	f8b7 3160 	ldrh.w	r3, [r7, #352]	; 0x160
    3fc0:	f3c3 0209 	ubfx	r2, r3, #0, #10
    3fc4:	4590      	cmp	r8, r2
    3fc6:	d368      	bcc.n	409a <CONFIG_HEAP_MEM_POOL_SIZE+0x9a>
    if(disp_refr->inv_p != 0) {
    3fc8:	b1f2      	cbz	r2, 4008 <CONFIG_HEAP_MEM_POOL_SIZE+0x8>
        if(lv_disp_is_true_double_buf(disp_refr)) {
    3fca:	4638      	mov	r0, r7
    3fcc:	f007 f917 	bl	b1fe <lv_disp_is_true_double_buf>
    3fd0:	2800      	cmp	r0, #0
    3fd2:	f040 811a 	bne.w	420a <CONFIG_HEAP_MEM_POOL_SIZE+0x20a>
        memset(disp_refr->inv_areas, 0, sizeof(disp_refr->inv_areas));
    3fd6:	6820      	ldr	r0, [r4, #0]
    3fd8:	f44f 7280 	mov.w	r2, #256	; 0x100
    3fdc:	2100      	movs	r1, #0
    3fde:	3040      	adds	r0, #64	; 0x40
    3fe0:	f004 fcb0 	bl	8944 <memset>
        memset(disp_refr->inv_area_joined, 0, sizeof(disp_refr->inv_area_joined));
    3fe4:	6820      	ldr	r0, [r4, #0]
    3fe6:	2220      	movs	r2, #32
    3fe8:	2100      	movs	r1, #0
    3fea:	f500 70a0 	add.w	r0, r0, #320	; 0x140
    3fee:	f004 fca9 	bl	8944 <memset>
        disp_refr->inv_p = 0;
    3ff2:	6824      	ldr	r4, [r4, #0]
    3ff4:	f8b4 3160 	ldrh.w	r3, [r4, #352]	; 0x160
        if(disp_refr->driver.monitor_cb) {
    3ff8:	69a5      	ldr	r5, [r4, #24]
        disp_refr->inv_p = 0;
    3ffa:	f36f 0309 	bfc	r3, #0, #10
    3ffe:	f8a4 3160 	strh.w	r3, [r4, #352]	; 0x160
        if(disp_refr->driver.monitor_cb) {
    4002:	2d00      	cmp	r5, #0
    4004:	f040 8156 	bne.w	42b4 <CONFIG_HEAP_MEM_POOL_SIZE+0x2b4>
    lv_draw_free_buf();
    4008:	f000 fcfa 	bl	4a00 <lv_draw_free_buf>
}
    400c:	b009      	add	sp, #36	; 0x24
    400e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(disp_refr->inv_area_joined[join_in] != 0) continue;
    4012:	4433      	add	r3, r6
    4014:	f893 5140 	ldrb.w	r5, [r3, #320]	; 0x140
    4018:	b10d      	cbz	r5, 401e <CONFIG_HEAP_MEM_POOL_SIZE+0x1e>
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
    401a:	3601      	adds	r6, #1
    401c:	e7c1      	b.n	3fa2 <lv_disp_refr_task+0x16>
    401e:	00f7      	lsls	r7, r6, #3
    4020:	3740      	adds	r7, #64	; 0x40
                disp_refr->inv_area_joined[join_from] = 1;
    4022:	f04f 0901 	mov.w	r9, #1
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
    4026:	6820      	ldr	r0, [r4, #0]
    4028:	f8b0 3160 	ldrh.w	r3, [r0, #352]	; 0x160
    402c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    4030:	429d      	cmp	r5, r3
    4032:	d2f2      	bcs.n	401a <CONFIG_HEAP_MEM_POOL_SIZE+0x1a>
            if(disp_refr->inv_area_joined[join_from] != 0 || join_in == join_from) {
    4034:	1943      	adds	r3, r0, r5
    4036:	f893 3140 	ldrb.w	r3, [r3, #320]	; 0x140
    403a:	bb63      	cbnz	r3, 4096 <CONFIG_HEAP_MEM_POOL_SIZE+0x96>
    403c:	42ae      	cmp	r6, r5
    403e:	d02a      	beq.n	4096 <CONFIG_HEAP_MEM_POOL_SIZE+0x96>
            if(lv_area_is_on(&disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]) == false) {
    4040:	ea4f 08c5 	mov.w	r8, r5, lsl #3
    4044:	f108 0840 	add.w	r8, r8, #64	; 0x40
    4048:	eb00 0108 	add.w	r1, r0, r8
    404c:	4438      	add	r0, r7
    404e:	f007 f97a 	bl	b346 <lv_area_is_on>
    4052:	b300      	cbz	r0, 4096 <CONFIG_HEAP_MEM_POOL_SIZE+0x96>
            lv_area_join(&joined_area, &disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]);
    4054:	6821      	ldr	r1, [r4, #0]
    4056:	a806      	add	r0, sp, #24
    4058:	eb01 0208 	add.w	r2, r1, r8
    405c:	4439      	add	r1, r7
    405e:	f007 f950 	bl	b302 <lv_area_join>
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
    4062:	a806      	add	r0, sp, #24
    4064:	f007 f915 	bl	b292 <lv_area_get_size>
    4068:	4683      	mov	fp, r0
    406a:	6820      	ldr	r0, [r4, #0]
    406c:	4438      	add	r0, r7
    406e:	f007 f910 	bl	b292 <lv_area_get_size>
    4072:	4682      	mov	sl, r0
                                                 lv_area_get_size(&disp_refr->inv_areas[join_from]))) {
    4074:	6820      	ldr	r0, [r4, #0]
    4076:	4440      	add	r0, r8
    4078:	f007 f90b 	bl	b292 <lv_area_get_size>
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
    407c:	4450      	add	r0, sl
    407e:	4583      	cmp	fp, r0
    4080:	d209      	bcs.n	4096 <CONFIG_HEAP_MEM_POOL_SIZE+0x96>
                lv_area_copy(&disp_refr->inv_areas[join_in], &joined_area);
    4082:	6820      	ldr	r0, [r4, #0]
    4084:	2208      	movs	r2, #8
    4086:	a906      	add	r1, sp, #24
    4088:	4438      	add	r0, r7
    408a:	f004 fc31 	bl	88f0 <memcpy>
                disp_refr->inv_area_joined[join_from] = 1;
    408e:	6823      	ldr	r3, [r4, #0]
    4090:	442b      	add	r3, r5
    4092:	f883 9140 	strb.w	r9, [r3, #320]	; 0x140
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
    4096:	3501      	adds	r5, #1
    4098:	e7c5      	b.n	4026 <CONFIG_HEAP_MEM_POOL_SIZE+0x26>
        if(disp_refr->inv_area_joined[i] == 0) {
    409a:	eb07 0308 	add.w	r3, r7, r8
    409e:	f893 6140 	ldrb.w	r6, [r3, #320]	; 0x140
    40a2:	2e00      	cmp	r6, #0
    40a4:	d17a      	bne.n	419c <CONFIG_HEAP_MEM_POOL_SIZE+0x19c>
            lv_refr_area(&disp_refr->inv_areas[i]);
    40a6:	ea4f 05c8 	mov.w	r5, r8, lsl #3
    40aa:	f105 0340 	add.w	r3, r5, #64	; 0x40
    if(lv_disp_is_true_double_buf(disp_refr)) {
    40ae:	4638      	mov	r0, r7
    40b0:	9301      	str	r3, [sp, #4]
            lv_refr_area(&disp_refr->inv_areas[i]);
    40b2:	eb07 0b03 	add.w	fp, r7, r3
    if(lv_disp_is_true_double_buf(disp_refr)) {
    40b6:	f007 f8a2 	bl	b1fe <lv_disp_is_true_double_buf>
    40ba:	b198      	cbz	r0, 40e4 <CONFIG_HEAP_MEM_POOL_SIZE+0xe4>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    40bc:	6820      	ldr	r0, [r4, #0]
    40be:	f007 f894 	bl	b1ea <lv_disp_get_buf>
    40c2:	4605      	mov	r5, r0
        vdb->area.x1        = 0;
    40c4:	8206      	strh	r6, [r0, #16]
        vdb->area.x2        = lv_disp_get_hor_res(disp_refr) - 1;
    40c6:	6820      	ldr	r0, [r4, #0]
    40c8:	f001 fc24 	bl	5914 <lv_disp_get_hor_res>
    40cc:	3801      	subs	r0, #1
    40ce:	82a8      	strh	r0, [r5, #20]
        vdb->area.y1        = 0;
    40d0:	826e      	strh	r6, [r5, #18]
        vdb->area.y2        = lv_disp_get_ver_res(disp_refr) - 1;
    40d2:	6820      	ldr	r0, [r4, #0]
    40d4:	f001 fc2e 	bl	5934 <lv_disp_get_ver_res>
    40d8:	3801      	subs	r0, #1
    40da:	82e8      	strh	r0, [r5, #22]
            lv_refr_area_part(area_p);
    40dc:	4658      	mov	r0, fp
    40de:	f7ff ff1b 	bl	3f18 <lv_refr_area_part>
    40e2:	e04f      	b.n	4184 <CONFIG_HEAP_MEM_POOL_SIZE+0x184>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    40e4:	443d      	add	r5, r7
    40e6:	6820      	ldr	r0, [r4, #0]
    40e8:	f007 f87f 	bl	b1ea <lv_disp_get_buf>
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    40ec:	f8b5 a044 	ldrh.w	sl, [r5, #68]	; 0x44
    40f0:	f8b5 7040 	ldrh.w	r7, [r5, #64]	; 0x40
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    40f4:	f9b5 9046 	ldrsh.w	r9, [r5, #70]	; 0x46
    40f8:	f8b5 3042 	ldrh.w	r3, [r5, #66]	; 0x42
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    40fc:	f10a 0a01 	add.w	sl, sl, #1
    4100:	ebaa 0a07 	sub.w	sl, sl, r7
    4104:	4606      	mov	r6, r0
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    4106:	f109 0701 	add.w	r7, r9, #1
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? y2 = lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
    410a:	6820      	ldr	r0, [r4, #0]
    410c:	1aff      	subs	r7, r7, r3
    410e:	f001 fc11 	bl	5934 <lv_disp_get_ver_res>
        lv_coord_t y2 =
    4112:	4581      	cmp	r9, r0
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    4114:	fa0f fa8a 	sxth.w	sl, sl
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    4118:	b23f      	sxth	r7, r7
    411a:	db42      	blt.n	41a2 <CONFIG_HEAP_MEM_POOL_SIZE+0x1a2>
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? y2 = lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
    411c:	6820      	ldr	r0, [r4, #0]
    411e:	f001 fc09 	bl	5934 <lv_disp_get_ver_res>
    4122:	3801      	subs	r0, #1
    4124:	fa0f f980 	sxth.w	r9, r0
        int32_t max_row = (uint32_t)vdb->size / w;
    4128:	68f3      	ldr	r3, [r6, #12]
    412a:	fbb3 f3fa 	udiv	r3, r3, sl
        if(max_row > h) max_row = h;
    412e:	429f      	cmp	r7, r3
    4130:	bfa8      	it	ge
    4132:	461f      	movge	r7, r3
        if(disp_refr->driver.rounder_cb) {
    4134:	6823      	ldr	r3, [r4, #0]
    4136:	691b      	ldr	r3, [r3, #16]
    4138:	2b00      	cmp	r3, #0
    413a:	d038      	beq.n	41ae <CONFIG_HEAP_MEM_POOL_SIZE+0x1ae>
            tmp.x1 = 0;
    413c:	2300      	movs	r3, #0
    413e:	9306      	str	r3, [sp, #24]
            tmp.x2 = 0;
    4140:	f8ad 301c 	strh.w	r3, [sp, #28]
            lv_coord_t h_tmp = max_row;
    4144:	b23b      	sxth	r3, r7
                tmp.y2 = h_tmp - 1;
    4146:	f103 3aff 	add.w	sl, r3, #4294967295	; 0xffffffff
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
    414a:	6820      	ldr	r0, [r4, #0]
                tmp.y2 = h_tmp - 1;
    414c:	9304      	str	r3, [sp, #16]
    414e:	fa0f fa8a 	sxth.w	sl, sl
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
    4152:	6902      	ldr	r2, [r0, #16]
                tmp.y2 = h_tmp - 1;
    4154:	f8ad a01e 	strh.w	sl, [sp, #30]
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
    4158:	a906      	add	r1, sp, #24
    415a:	4790      	blx	r2
    415c:	f9bd 101e 	ldrsh.w	r1, [sp, #30]
    4160:	f8bd 201a 	ldrh.w	r2, [sp, #26]
                if(lv_area_get_height(&tmp) <= max_row) break;
    4164:	9b04      	ldr	r3, [sp, #16]
    4166:	3101      	adds	r1, #1
    4168:	1a8a      	subs	r2, r1, r2
    416a:	b212      	sxth	r2, r2
    416c:	4297      	cmp	r7, r2
    416e:	da1b      	bge.n	41a8 <CONFIG_HEAP_MEM_POOL_SIZE+0x1a8>
            } while(h_tmp > 0);
    4170:	f1ba 0300 	subs.w	r3, sl, #0
    4174:	dce7      	bgt.n	4146 <CONFIG_HEAP_MEM_POOL_SIZE+0x146>
                LV_LOG_WARN("Can't set VDB height using the round function. (Wrong round_cb or to "
    4176:	4b39      	ldr	r3, [pc, #228]	; (425c <CONFIG_HEAP_MEM_POOL_SIZE+0x25c>)
    4178:	4939      	ldr	r1, [pc, #228]	; (4260 <CONFIG_HEAP_MEM_POOL_SIZE+0x260>)
    417a:	f240 124f 	movw	r2, #335	; 0x14f
    417e:	2002      	movs	r0, #2
    4180:	f001 fef4 	bl	5f6c <lv_log_add>
            if(disp_refr->driver.monitor_cb) px_num += lv_area_get_size(&disp_refr->inv_areas[i]);
    4184:	6820      	ldr	r0, [r4, #0]
    4186:	6983      	ldr	r3, [r0, #24]
    4188:	b143      	cbz	r3, 419c <CONFIG_HEAP_MEM_POOL_SIZE+0x19c>
    418a:	9b01      	ldr	r3, [sp, #4]
    418c:	4418      	add	r0, r3
    418e:	f007 f880 	bl	b292 <lv_area_get_size>
    4192:	9b02      	ldr	r3, [sp, #8]
    4194:	681b      	ldr	r3, [r3, #0]
    4196:	4418      	add	r0, r3
    4198:	9b02      	ldr	r3, [sp, #8]
    419a:	6018      	str	r0, [r3, #0]
    for(i = 0; i < disp_refr->inv_p; i++) {
    419c:	f108 0801 	add.w	r8, r8, #1
    41a0:	e70b      	b.n	3fba <lv_disp_refr_task+0x2e>
        lv_coord_t y2 =
    41a2:	f9b5 9046 	ldrsh.w	r9, [r5, #70]	; 0x46
    41a6:	e7bf      	b.n	4128 <CONFIG_HEAP_MEM_POOL_SIZE+0x128>
            if(h_tmp <= 0) {
    41a8:	2b00      	cmp	r3, #0
    41aa:	dde4      	ble.n	4176 <CONFIG_HEAP_MEM_POOL_SIZE+0x176>
                max_row = tmp.y2 + 1;
    41ac:	460f      	mov	r7, r1
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
    41ae:	f9b5 3042 	ldrsh.w	r3, [r5, #66]	; 0x42
        lv_coord_t row_last = 0;
    41b2:	f04f 0a00 	mov.w	sl, #0
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
    41b6:	1e7a      	subs	r2, r7, #1
    41b8:	18d1      	adds	r1, r2, r3
    41ba:	4549      	cmp	r1, r9
    41bc:	dd0b      	ble.n	41d6 <CONFIG_HEAP_MEM_POOL_SIZE+0x1d6>
        if(y2 != row_last) {
    41be:	45d1      	cmp	r9, sl
    41c0:	d0e0      	beq.n	4184 <CONFIG_HEAP_MEM_POOL_SIZE+0x184>
            vdb->area.x1 = area_p->x1;
    41c2:	f9b5 2040 	ldrsh.w	r2, [r5, #64]	; 0x40
    41c6:	8232      	strh	r2, [r6, #16]
            vdb->area.x2 = area_p->x2;
    41c8:	f9b5 2044 	ldrsh.w	r2, [r5, #68]	; 0x44
    41cc:	82b2      	strh	r2, [r6, #20]
            vdb->area.y1 = row;
    41ce:	8273      	strh	r3, [r6, #18]
            vdb->area.y2 = y2;
    41d0:	f8a6 9016 	strh.w	r9, [r6, #22]
    41d4:	e782      	b.n	40dc <CONFIG_HEAP_MEM_POOL_SIZE+0xdc>
            vdb->area.x1 = area_p->x1;
    41d6:	f9b5 1040 	ldrsh.w	r1, [r5, #64]	; 0x40
    41da:	8231      	strh	r1, [r6, #16]
            vdb->area.x2 = area_p->x2;
    41dc:	f9b5 1044 	ldrsh.w	r1, [r5, #68]	; 0x44
            vdb->area.y1 = row;
    41e0:	8273      	strh	r3, [r6, #18]
            vdb->area.y2 = row + max_row - 1;
    41e2:	443b      	add	r3, r7
    41e4:	b21b      	sxth	r3, r3
    41e6:	f103 3aff 	add.w	sl, r3, #4294967295	; 0xffffffff
    41ea:	fa0f fa8a 	sxth.w	sl, sl
    41ee:	45ca      	cmp	sl, r9
    41f0:	bfa8      	it	ge
    41f2:	46ca      	movge	sl, r9
            vdb->area.x2 = area_p->x2;
    41f4:	82b1      	strh	r1, [r6, #20]
            vdb->area.y2 = row + max_row - 1;
    41f6:	f8a6 a016 	strh.w	sl, [r6, #22]
            lv_refr_area_part(area_p);
    41fa:	4658      	mov	r0, fp
    41fc:	9205      	str	r2, [sp, #20]
    41fe:	9304      	str	r3, [sp, #16]
    4200:	f7ff fe8a 	bl	3f18 <lv_refr_area_part>
    4204:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
    4208:	e7d6      	b.n	41b8 <CONFIG_HEAP_MEM_POOL_SIZE+0x1b8>
            lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    420a:	6820      	ldr	r0, [r4, #0]
    420c:	f006 ffed 	bl	b1ea <lv_disp_get_buf>
    4210:	4605      	mov	r5, r0
            lv_refr_vdb_flush();
    4212:	f7ff fe31 	bl	3e78 <lv_refr_vdb_flush>
            while(vdb->flushing)
    4216:	69ab      	ldr	r3, [r5, #24]
    4218:	07db      	lsls	r3, r3, #31
    421a:	d4fc      	bmi.n	4216 <CONFIG_HEAP_MEM_POOL_SIZE+0x216>
            uint8_t * buf_ina = (uint8_t *)vdb->buf_act == vdb->buf1 ? vdb->buf2 : vdb->buf1;
    421c:	f8d5 9000 	ldr.w	r9, [r5]
            uint8_t * buf_act = (uint8_t *)vdb->buf_act;
    4220:	f8d5 b008 	ldr.w	fp, [r5, #8]
            lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
    4224:	6820      	ldr	r0, [r4, #0]
            uint8_t * buf_ina = (uint8_t *)vdb->buf_act == vdb->buf1 ? vdb->buf2 : vdb->buf1;
    4226:	45d9      	cmp	r9, fp
    4228:	bf08      	it	eq
    422a:	f8d5 9004 	ldreq.w	r9, [r5, #4]
            lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
    422e:	f001 fb71 	bl	5914 <lv_disp_get_hor_res>
            for(a = 0; a < disp_refr->inv_p; a++) {
    4232:	2600      	movs	r6, #0
            lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
    4234:	4603      	mov	r3, r0
            for(a = 0; a < disp_refr->inv_p; a++) {
    4236:	6822      	ldr	r2, [r4, #0]
    4238:	f8b2 1160 	ldrh.w	r1, [r2, #352]	; 0x160
    423c:	b2b0      	uxth	r0, r6
    423e:	f3c1 0109 	ubfx	r1, r1, #0, #10
    4242:	4281      	cmp	r1, r0
    4244:	f67f aec7 	bls.w	3fd6 <lv_disp_refr_task+0x4a>
                if(disp_refr->inv_area_joined[a] == 0) {
    4248:	1991      	adds	r1, r2, r6
    424a:	f891 1140 	ldrb.w	r1, [r1, #320]	; 0x140
    424e:	b149      	cbz	r1, 4264 <CONFIG_HEAP_MEM_POOL_SIZE+0x264>
    4250:	3601      	adds	r6, #1
    4252:	e7f0      	b.n	4236 <CONFIG_HEAP_MEM_POOL_SIZE+0x236>
    4254:	20000200 	.word	0x20000200
    4258:	20000204 	.word	0x20000204
    425c:	00045700 	.word	0x00045700
    4260:	00045750 	.word	0x00045750
                    uint32_t start_offs =
    4264:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
    4268:	f106 0a08 	add.w	sl, r6, #8
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    426c:	f8b2 5044 	ldrh.w	r5, [r2, #68]	; 0x44
                        (hres * disp_refr->inv_areas[a].y1 + disp_refr->inv_areas[a].x1) * sizeof(lv_color_t);
    4270:	f9b2 1040 	ldrsh.w	r1, [r2, #64]	; 0x40
    4274:	f9b2 7042 	ldrsh.w	r7, [r2, #66]	; 0x42
    4278:	3501      	adds	r5, #1
    427a:	1a6d      	subs	r5, r5, r1
    427c:	fb03 1807 	mla	r8, r3, r7, r1
                    uint32_t line_length = lv_area_get_width(&disp_refr->inv_areas[a]) * sizeof(lv_color_t);
    4280:	b22d      	sxth	r5, r5
                    uint32_t start_offs =
    4282:	ea4f 0888 	mov.w	r8, r8, lsl #2
                    uint32_t line_length = lv_area_get_width(&disp_refr->inv_areas[a]) * sizeof(lv_color_t);
    4286:	00ad      	lsls	r5, r5, #2
                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
    4288:	ea4f 0aca 	mov.w	sl, sl, lsl #3
    428c:	6822      	ldr	r2, [r4, #0]
    428e:	4452      	add	r2, sl
    4290:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
    4294:	42ba      	cmp	r2, r7
    4296:	dbdb      	blt.n	4250 <CONFIG_HEAP_MEM_POOL_SIZE+0x250>
                        memcpy(buf_act + start_offs, buf_ina + start_offs, line_length);
    4298:	eb09 0108 	add.w	r1, r9, r8
    429c:	eb0b 0008 	add.w	r0, fp, r8
    42a0:	462a      	mov	r2, r5
    42a2:	9301      	str	r3, [sp, #4]
    42a4:	f004 fb24 	bl	88f0 <memcpy>
                        start_offs += hres * sizeof(lv_color_t);
    42a8:	9b01      	ldr	r3, [sp, #4]
                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
    42aa:	3701      	adds	r7, #1
                        start_offs += hres * sizeof(lv_color_t);
    42ac:	eb08 0883 	add.w	r8, r8, r3, lsl #2
                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
    42b0:	b23f      	sxth	r7, r7
    42b2:	e7eb      	b.n	428c <CONFIG_HEAP_MEM_POOL_SIZE+0x28c>
            disp_refr->driver.monitor_cb(&disp_refr->driver, lv_tick_elaps(start), px_num);
    42b4:	9803      	ldr	r0, [sp, #12]
    42b6:	f006 ffb5 	bl	b224 <lv_tick_elaps>
    42ba:	4b03      	ldr	r3, [pc, #12]	; (42c8 <CONFIG_HEAP_MEM_POOL_SIZE+0x2c8>)
    42bc:	4601      	mov	r1, r0
    42be:	681a      	ldr	r2, [r3, #0]
    42c0:	4620      	mov	r0, r4
    42c2:	47a8      	blx	r5
    42c4:	e6a0      	b.n	4008 <CONFIG_HEAP_MEM_POOL_SIZE+0x8>
    42c6:	bf00      	nop
    42c8:	20000204 	.word	0x20000204

000042cc <lv_style_init>:
{
    /* Not White/Black/Gray colors are created by HSV model with
     * HUE = 210*/

    /*Screen style*/
    lv_style_scr.glass               = 0;
    42cc:	4977      	ldr	r1, [pc, #476]	; (44ac <lv_style_init+0x1e0>)
{
    42ce:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    lv_style_scr.glass               = 0;
    42d2:	780b      	ldrb	r3, [r1, #0]
    lv_style_scr.body.shadow.type  = LV_SHADOW_FULL;
    lv_style_scr.body.shadow.width = 0;

    lv_style_scr.text.opa          = LV_OPA_COVER;
    lv_style_scr.text.color        = lv_color_make(0x30, 0x30, 0x30);
    lv_style_scr.text.sel_color    = lv_color_make(0x55, 0x96, 0xd8);
    42d4:	4c76      	ldr	r4, [pc, #472]	; (44b0 <lv_style_init+0x1e4>)
    lv_style_scr.debug_sentinel = LV_STYLE_DEGUG_SENTINEL_VALUE;
#endif
#endif

    /*Plain style (by default near the same as the screen style)*/
    lv_style_copy(&lv_style_plain, &lv_style_scr);
    42d6:	4e77      	ldr	r6, [pc, #476]	; (44b4 <lv_style_init+0x1e8>)
    lv_style_scr.image.color   = lv_color_make(0x20, 0x20, 0x20);
    42d8:	4f77      	ldr	r7, [pc, #476]	; (44b8 <lv_style_init+0x1ec>)
    lv_style_scr.body.shadow.color = LV_COLOR_GRAY;
    42da:	f8df 925c 	ldr.w	r9, [pc, #604]	; 4538 <lv_style_init+0x26c>
    lv_style_plain.body.padding.right  = LV_DPI / 20;
    lv_style_plain.body.padding.top    = LV_DPI / 20;
    lv_style_plain.body.padding.bottom = LV_DPI / 20;

    /*Plain color style*/
    lv_style_copy(&lv_style_plain_color, &lv_style_plain);
    42de:	f8df a25c 	ldr.w	sl, [pc, #604]	; 453c <lv_style_init+0x270>
    lv_style_scr.image.color   = lv_color_make(0x20, 0x20, 0x20);
    42e2:	640f      	str	r7, [r1, #64]	; 0x40
    lv_style_scr.glass               = 0;
    42e4:	f36f 0300 	bfc	r3, #0, #1
    42e8:	700b      	strb	r3, [r1, #0]
    lv_style_scr.body.padding.inner  = LV_DPI / 20;
    42ea:	2305      	movs	r3, #5
    42ec:	850b      	strh	r3, [r1, #40]	; 0x28
    lv_style_scr.body.border.color = LV_COLOR_BLACK;
    42ee:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
    42f2:	610b      	str	r3, [r1, #16]
    lv_style_scr.body.border.width = 0;
    42f4:	f503 2370 	add.w	r3, r3, #983040	; 0xf0000
    42f8:	614b      	str	r3, [r1, #20]
    lv_style_scr.body.shadow.type  = LV_SHADOW_FULL;
    42fa:	2301      	movs	r3, #1
    42fc:	778b      	strb	r3, [r1, #30]
    lv_style_scr.text.sel_color    = lv_color_make(0x55, 0x96, 0xd8);
    42fe:	4b6f      	ldr	r3, [pc, #444]	; (44bc <lv_style_init+0x1f0>)
    lv_style_scr.line.color   = lv_color_make(0x20, 0x20, 0x20);
    4300:	648f      	str	r7, [r1, #72]	; 0x48
    lv_style_scr.text.sel_color    = lv_color_make(0x55, 0x96, 0xd8);
    4302:	e9c1 340b 	strd	r3, r4, [r1, #44]	; 0x2c
    lv_style_scr.text.font         = LV_FONT_DEFAULT;
    4306:	4b6e      	ldr	r3, [pc, #440]	; (44c0 <lv_style_init+0x1f4>)
    4308:	634b      	str	r3, [r1, #52]	; 0x34
    lv_style_scr.text.letter_space = 0;
    430a:	f44f 3300 	mov.w	r3, #131072	; 0x20000
    430e:	638b      	str	r3, [r1, #56]	; 0x38
    lv_style_scr.text.opa          = LV_OPA_COVER;
    4310:	23ff      	movs	r3, #255	; 0xff
    4312:	f881 303c 	strb.w	r3, [r1, #60]	; 0x3c
    lv_style_scr.image.intense = LV_OPA_TRANSP;
    4316:	f44f 437f 	mov.w	r3, #65280	; 0xff00
    431a:	f8a1 3044 	strh.w	r3, [r1, #68]	; 0x44
    lv_style_scr.line.width   = 2;
    431e:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
    lv_style_scr.body.shadow.color = LV_COLOR_GRAY;
    4320:	f8c1 9018 	str.w	r9, [r1, #24]
    lv_style_scr.line.width   = 2;
    4324:	f003 437e 	and.w	r3, r3, #4261412864	; 0xfe000000
    4328:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
    lv_style_scr.body.radius         = 0;
    432c:	2500      	movs	r5, #0
    lv_style_scr.body.main_color     = LV_COLOR_WHITE;
    432e:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    lv_style_scr.line.width   = 2;
    4332:	f043 0302 	orr.w	r3, r3, #2
    lv_style_scr.body.grad_color     = LV_COLOR_WHITE;
    4336:	e9c1 8801 	strd	r8, r8, [r1, #4]
    lv_style_scr.body.padding.left   = 0;
    433a:	e9c1 5508 	strd	r5, r5, [r1, #32]
    lv_style_scr.line.width   = 2;
    433e:	64cb      	str	r3, [r1, #76]	; 0x4c
    lv_style_copy(&lv_style_plain, &lv_style_scr);
    4340:	4630      	mov	r0, r6
    lv_style_scr.body.radius         = 0;
    4342:	818d      	strh	r5, [r1, #12]
    lv_style_scr.body.opa            = LV_OPA_COVER;
    4344:	f881 800e 	strb.w	r8, [r1, #14]
    lv_style_scr.body.shadow.width = 0;
    4348:	838d      	strh	r5, [r1, #28]
    lv_style_copy(&lv_style_plain, &lv_style_scr);
    434a:	f005 fdc8 	bl	9ede <lv_style_copy>
    lv_style_plain.body.padding.top    = LV_DPI / 20;
    434e:	f04f 1305 	mov.w	r3, #327685	; 0x50005
    lv_style_plain.body.padding.left   = LV_DPI / 20;
    4352:	e9c6 3308 	strd	r3, r3, [r6, #32]
    lv_style_copy(&lv_style_plain_color, &lv_style_plain);
    4356:	4631      	mov	r1, r6
    4358:	4650      	mov	r0, sl
    435a:	f005 fdc0 	bl	9ede <lv_style_copy>
    lv_style_plain_color.text.color      = lv_color_make(0xf0, 0xf0, 0xf0);
    lv_style_plain_color.image.color     = lv_color_make(0xf0, 0xf0, 0xf0);
    lv_style_plain_color.line.color      = lv_color_make(0xf0, 0xf0, 0xf0);
    lv_style_plain_color.body.main_color = lv_color_make(0x55, 0x96, 0xd8);
    lv_style_plain_color.body.grad_color = lv_style_plain_color.body.main_color;
    435e:	e9ca 4401 	strd	r4, r4, [sl, #4]

    /*Pretty style */
    lv_style_copy(&lv_style_pretty, &lv_style_plain);
    4362:	4c58      	ldr	r4, [pc, #352]	; (44c4 <lv_style_init+0x1f8>)
    lv_style_plain_color.text.color      = lv_color_make(0xf0, 0xf0, 0xf0);
    4364:	4b58      	ldr	r3, [pc, #352]	; (44c8 <lv_style_init+0x1fc>)
    4366:	f8ca 302c 	str.w	r3, [sl, #44]	; 0x2c
    lv_style_plain_color.image.color     = lv_color_make(0xf0, 0xf0, 0xf0);
    436a:	f8ca 3040 	str.w	r3, [sl, #64]	; 0x40
    lv_style_plain_color.line.color      = lv_color_make(0xf0, 0xf0, 0xf0);
    436e:	f8ca 3048 	str.w	r3, [sl, #72]	; 0x48
    lv_style_copy(&lv_style_pretty, &lv_style_plain);
    4372:	4631      	mov	r1, r6
    4374:	4620      	mov	r0, r4
    4376:	f005 fdb2 	bl	9ede <lv_style_copy>
    lv_style_pretty.text.color        = lv_color_make(0x20, 0x20, 0x20);
    437a:	62e7      	str	r7, [r4, #44]	; 0x2c
    lv_style_pretty.image.color       = lv_color_make(0x20, 0x20, 0x20);
    437c:	6427      	str	r7, [r4, #64]	; 0x40
    lv_style_pretty.line.color        = lv_color_make(0x20, 0x20, 0x20);
    437e:	64a7      	str	r7, [r4, #72]	; 0x48
    lv_style_pretty.body.border.color = lv_color_make(0x40, 0x40, 0x40);
    lv_style_pretty.body.border.width = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
    lv_style_pretty.body.border.opa   = LV_OPA_30;

    /*Pretty color style*/
    lv_style_copy(&lv_style_pretty_color, &lv_style_pretty);
    4380:	4f52      	ldr	r7, [pc, #328]	; (44cc <lv_style_init+0x200>)
    lv_style_pretty.body.grad_color   = LV_COLOR_SILVER;
    4382:	4b53      	ldr	r3, [pc, #332]	; (44d0 <lv_style_init+0x204>)
    lv_style_pretty.body.border.color = lv_color_make(0x40, 0x40, 0x40);
    4384:	4a53      	ldr	r2, [pc, #332]	; (44d4 <lv_style_init+0x208>)
    lv_style_pretty.body.main_color   = LV_COLOR_WHITE;
    4386:	f8c4 8004 	str.w	r8, [r4, #4]
    lv_style_pretty.body.grad_color   = LV_COLOR_SILVER;
    438a:	60a3      	str	r3, [r4, #8]
    lv_style_pretty.body.border.color = lv_color_make(0x40, 0x40, 0x40);
    438c:	6122      	str	r2, [r4, #16]
    lv_style_copy(&lv_style_pretty_color, &lv_style_pretty);
    438e:	4621      	mov	r1, r4
    lv_style_pretty.body.border.opa   = LV_OPA_30;
    4390:	224c      	movs	r2, #76	; 0x4c
    lv_style_copy(&lv_style_pretty_color, &lv_style_pretty);
    4392:	4638      	mov	r0, r7
    lv_style_pretty.body.radius       = LV_DPI / 15;
    4394:	f04f 0b06 	mov.w	fp, #6
    lv_style_pretty.body.border.width = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
    4398:	f04f 0a02 	mov.w	sl, #2
    lv_style_pretty.body.border.opa   = LV_OPA_30;
    439c:	75e2      	strb	r2, [r4, #23]
    lv_style_pretty.body.radius       = LV_DPI / 15;
    439e:	f8a4 b00c 	strh.w	fp, [r4, #12]
    lv_style_pretty.body.border.width = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
    43a2:	f8a4 a014 	strh.w	sl, [r4, #20]
    lv_style_copy(&lv_style_pretty_color, &lv_style_pretty);
    43a6:	f005 fd9a 	bl	9ede <lv_style_copy>
    lv_style_pretty_color.text.color        = lv_color_make(0xe0, 0xe0, 0xe0);
    lv_style_pretty_color.image.color       = lv_color_make(0xe0, 0xe0, 0xe0);
    lv_style_pretty_color.line.color        = lv_color_make(0xc0, 0xc0, 0xc0);
    43aa:	4b49      	ldr	r3, [pc, #292]	; (44d0 <lv_style_init+0x204>)
    43ac:	64bb      	str	r3, [r7, #72]	; 0x48
    lv_style_pretty_color.body.main_color   = lv_color_make(0x6b, 0x9a, 0xc7);
    lv_style_pretty_color.body.grad_color   = lv_color_make(0x2b, 0x59, 0x8b);
    43ae:	494a      	ldr	r1, [pc, #296]	; (44d8 <lv_style_init+0x20c>)
    43b0:	4b4a      	ldr	r3, [pc, #296]	; (44dc <lv_style_init+0x210>)
    lv_style_pretty_color.body.border.color = lv_color_make(0x15, 0x2c, 0x42);

    /*Transparent style*/
    lv_style_copy(&lv_style_transp, &lv_style_plain);
    43b2:	4c4b      	ldr	r4, [pc, #300]	; (44e0 <lv_style_init+0x214>)
    lv_style_pretty_color.text.color        = lv_color_make(0xe0, 0xe0, 0xe0);
    43b4:	4a4b      	ldr	r2, [pc, #300]	; (44e4 <lv_style_init+0x218>)
    43b6:	62fa      	str	r2, [r7, #44]	; 0x2c
    lv_style_pretty_color.body.grad_color   = lv_color_make(0x2b, 0x59, 0x8b);
    43b8:	e9c7 1301 	strd	r1, r3, [r7, #4]
    lv_style_pretty_color.body.border.color = lv_color_make(0x15, 0x2c, 0x42);
    43bc:	f5a3 13b1 	sub.w	r3, r3, #1449984	; 0x162000
    43c0:	f6a3 5349 	subw	r3, r3, #3401	; 0xd49
    lv_style_pretty_color.image.color       = lv_color_make(0xe0, 0xe0, 0xe0);
    43c4:	643a      	str	r2, [r7, #64]	; 0x40
    lv_style_pretty_color.body.border.color = lv_color_make(0x15, 0x2c, 0x42);
    43c6:	613b      	str	r3, [r7, #16]
    lv_style_copy(&lv_style_transp, &lv_style_plain);
    43c8:	4631      	mov	r1, r6
    43ca:	4620      	mov	r0, r4
    43cc:	f005 fd87 	bl	9ede <lv_style_copy>
    lv_style_transp.glass             = 1;
    43d0:	7823      	ldrb	r3, [r4, #0]
    lv_style_transp.body.border.width = 0;
    lv_style_transp.body.opa          = LV_OPA_TRANSP;

    /*Transparent fitting size*/
    lv_style_copy(&lv_style_transp_fit, &lv_style_transp);
    43d2:	4f45      	ldr	r7, [pc, #276]	; (44e8 <lv_style_init+0x21c>)
    lv_style_transp.body.border.width = 0;
    43d4:	82a5      	strh	r5, [r4, #20]
    lv_style_transp.glass             = 1;
    43d6:	f043 0301 	orr.w	r3, r3, #1
    43da:	7023      	strb	r3, [r4, #0]
    lv_style_transp.body.opa          = LV_OPA_TRANSP;
    43dc:	73a5      	strb	r5, [r4, #14]
    lv_style_copy(&lv_style_transp_fit, &lv_style_transp);
    43de:	4621      	mov	r1, r4
    lv_style_transp_fit.body.padding.right  = 0;
    lv_style_transp_fit.body.padding.top    = 0;
    lv_style_transp_fit.body.padding.bottom = 0;

    /*Transparent tight style*/
    lv_style_copy(&lv_style_transp_tight, &lv_style_transp_fit);
    43e0:	4c42      	ldr	r4, [pc, #264]	; (44ec <lv_style_init+0x220>)
    lv_style_copy(&lv_style_transp_fit, &lv_style_transp);
    43e2:	4638      	mov	r0, r7
    43e4:	f005 fd7b 	bl	9ede <lv_style_copy>
    lv_style_transp_fit.body.padding.left   = 0;
    43e8:	e9c7 5508 	strd	r5, r5, [r7, #32]
    lv_style_copy(&lv_style_transp_tight, &lv_style_transp_fit);
    43ec:	4639      	mov	r1, r7
    43ee:	4620      	mov	r0, r4
    43f0:	f005 fd75 	bl	9ede <lv_style_copy>
    lv_style_transp_tight.body.padding.inner = 0;
    43f4:	8525      	strh	r5, [r4, #40]	; 0x28

    /*Button released style*/
    lv_style_copy(&lv_style_btn_rel, &lv_style_plain);
    43f6:	4c3e      	ldr	r4, [pc, #248]	; (44f0 <lv_style_init+0x224>)
    lv_style_btn_rel.image.color         = lv_color_make(0xff, 0xff, 0xff);

    /*Button pressed style*/
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
    lv_style_btn_pr.body.main_color = lv_color_make(0x33, 0x62, 0x94);
    lv_style_btn_pr.body.grad_color = lv_color_make(0x10, 0x26, 0x3c);
    43f8:	4f3e      	ldr	r7, [pc, #248]	; (44f4 <lv_style_init+0x228>)
    lv_style_copy(&lv_style_btn_rel, &lv_style_plain);
    43fa:	4631      	mov	r1, r6
    43fc:	4620      	mov	r0, r4
    43fe:	f005 fd6e 	bl	9ede <lv_style_copy>
    lv_style_btn_rel.body.grad_color     = lv_color_make(0x19, 0x3a, 0x5d);
    4402:	483d      	ldr	r0, [pc, #244]	; (44f8 <lv_style_init+0x22c>)
    4404:	4b3d      	ldr	r3, [pc, #244]	; (44fc <lv_style_init+0x230>)
    lv_style_btn_rel.body.shadow.width   = 0;
    4406:	83a5      	strh	r5, [r4, #28]
    lv_style_btn_rel.body.grad_color     = lv_color_make(0x19, 0x3a, 0x5d);
    4408:	e9c4 0301 	strd	r0, r3, [r4, #4]
    lv_style_btn_rel.body.padding.left   = LV_DPI / 4;
    440c:	f04f 1610 	mov.w	r6, #1048592	; 0x100010
    4410:	f04f 1319 	mov.w	r3, #1638425	; 0x190019
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
    4414:	4d3a      	ldr	r5, [pc, #232]	; (4500 <lv_style_init+0x234>)
    lv_style_btn_rel.text.color          = lv_color_make(0xff, 0xff, 0xff);
    4416:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
    lv_style_btn_rel.body.padding.left   = LV_DPI / 4;
    441a:	e9c4 6308 	strd	r6, r3, [r4, #32]
    lv_style_btn_rel.body.padding.inner  = LV_DPI / 10;
    441e:	230a      	movs	r3, #10
    4420:	8523      	strh	r3, [r4, #40]	; 0x28
    lv_style_btn_rel.body.border.color   = lv_color_make(0x0b, 0x19, 0x28);
    4422:	4b38      	ldr	r3, [pc, #224]	; (4504 <lv_style_init+0x238>)
    4424:	6123      	str	r3, [r4, #16]
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
    4426:	4628      	mov	r0, r5
    lv_style_btn_rel.body.border.opa     = LV_OPA_70;
    4428:	23b2      	movs	r3, #178	; 0xb2
    lv_style_btn_rel.image.color         = lv_color_make(0xff, 0xff, 0xff);
    442a:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
    442e:	4621      	mov	r1, r4
    lv_style_btn_rel.body.shadow.color   = LV_COLOR_GRAY;
    4430:	f8c4 9018 	str.w	r9, [r4, #24]
    lv_style_btn_rel.body.border.opa     = LV_OPA_70;
    4434:	75e3      	strb	r3, [r4, #23]
    lv_style_btn_rel.body.radius         = LV_DPI / 15;
    4436:	f8a4 b00c 	strh.w	fp, [r4, #12]
    lv_style_btn_rel.body.border.width   = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
    443a:	f8a4 a014 	strh.w	sl, [r4, #20]
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
    443e:	f005 fd4e 	bl	9ede <lv_style_copy>
    lv_style_btn_pr.body.grad_color = lv_color_make(0x10, 0x26, 0x3c);
    4442:	4b31      	ldr	r3, [pc, #196]	; (4508 <lv_style_init+0x23c>)
    lv_style_btn_tgl_rel.text.color        = lv_color_make(0xc8, 0xdd, 0xf4);
    lv_style_btn_tgl_rel.image.color       = lv_color_make(0xc8, 0xdd, 0xf4);
    lv_style_btn_tgl_rel.line.color        = lv_color_make(0xc8, 0xdd, 0xf4);

    /*Button toggle pressed style*/
    lv_style_copy(&lv_style_btn_tgl_pr, &lv_style_btn_tgl_rel);
    4444:	4e31      	ldr	r6, [pc, #196]	; (450c <lv_style_init+0x240>)
    lv_style_btn_tgl_pr.body.main_color = lv_color_make(0x02, 0x14, 0x27);
    lv_style_btn_tgl_pr.body.grad_color = lv_color_make(0x2b, 0x4c, 0x70);
    4446:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 4540 <lv_style_init+0x274>
    lv_style_btn_pr.body.grad_color = lv_color_make(0x10, 0x26, 0x3c);
    444a:	e9c5 7301 	strd	r7, r3, [r5, #4]
    lv_style_btn_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
    444e:	4f30      	ldr	r7, [pc, #192]	; (4510 <lv_style_init+0x244>)
    4450:	62ef      	str	r7, [r5, #44]	; 0x2c
    lv_style_btn_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
    4452:	642f      	str	r7, [r5, #64]	; 0x40
    lv_style_btn_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);
    4454:	64af      	str	r7, [r5, #72]	; 0x48
    lv_style_copy(&lv_style_btn_tgl_rel, &lv_style_btn_rel);
    4456:	4d2f      	ldr	r5, [pc, #188]	; (4514 <lv_style_init+0x248>)
    4458:	4621      	mov	r1, r4
    445a:	4628      	mov	r0, r5
    445c:	f005 fd3f 	bl	9ede <lv_style_copy>
    lv_style_btn_tgl_rel.body.grad_color   = lv_color_make(0x37, 0x62, 0x90);
    4460:	f8df c0e0 	ldr.w	ip, [pc, #224]	; 4544 <lv_style_init+0x278>
    4464:	4b2c      	ldr	r3, [pc, #176]	; (4518 <lv_style_init+0x24c>)
    4466:	e9c5 c301 	strd	ip, r3, [r5, #4]
    lv_style_btn_tgl_rel.body.border.color = lv_color_make(0x01, 0x07, 0x0d);
    446a:	4b2c      	ldr	r3, [pc, #176]	; (451c <lv_style_init+0x250>)
    446c:	612b      	str	r3, [r5, #16]
    lv_style_btn_tgl_rel.text.color        = lv_color_make(0xc8, 0xdd, 0xf4);
    446e:	4b2c      	ldr	r3, [pc, #176]	; (4520 <lv_style_init+0x254>)
    4470:	62eb      	str	r3, [r5, #44]	; 0x2c
    lv_style_btn_tgl_rel.image.color       = lv_color_make(0xc8, 0xdd, 0xf4);
    4472:	642b      	str	r3, [r5, #64]	; 0x40
    lv_style_btn_tgl_rel.line.color        = lv_color_make(0xc8, 0xdd, 0xf4);
    4474:	64ab      	str	r3, [r5, #72]	; 0x48
    lv_style_copy(&lv_style_btn_tgl_pr, &lv_style_btn_tgl_rel);
    4476:	4629      	mov	r1, r5
    4478:	4630      	mov	r0, r6
    447a:	f005 fd30 	bl	9ede <lv_style_copy>
    lv_style_btn_tgl_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
    lv_style_btn_tgl_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
    lv_style_btn_tgl_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);

    /*Button inactive style*/
    lv_style_copy(&lv_style_btn_ina, &lv_style_btn_rel);
    447e:	4d29      	ldr	r5, [pc, #164]	; (4524 <lv_style_init+0x258>)
    lv_style_btn_tgl_pr.body.grad_color = lv_color_make(0x2b, 0x4c, 0x70);
    4480:	4b29      	ldr	r3, [pc, #164]	; (4528 <lv_style_init+0x25c>)
    lv_style_btn_tgl_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
    4482:	62f7      	str	r7, [r6, #44]	; 0x2c
    lv_style_btn_tgl_pr.body.grad_color = lv_color_make(0x2b, 0x4c, 0x70);
    4484:	e9c6 8301 	strd	r8, r3, [r6, #4]
    lv_style_btn_tgl_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
    4488:	6437      	str	r7, [r6, #64]	; 0x40
    lv_style_btn_tgl_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);
    448a:	64b7      	str	r7, [r6, #72]	; 0x48
    lv_style_copy(&lv_style_btn_ina, &lv_style_btn_rel);
    448c:	4621      	mov	r1, r4
    448e:	4628      	mov	r0, r5
    4490:	f005 fd25 	bl	9ede <lv_style_copy>
    lv_style_btn_ina.body.main_color   = lv_color_make(0xd8, 0xd8, 0xd8);
    4494:	4b25      	ldr	r3, [pc, #148]	; (452c <lv_style_init+0x260>)
    lv_style_btn_ina.body.grad_color   = lv_color_make(0xd8, 0xd8, 0xd8);
    4496:	e9c5 3301 	strd	r3, r3, [r5, #4]
    lv_style_btn_ina.body.border.color = lv_color_make(0x90, 0x90, 0x90);
    449a:	4b25      	ldr	r3, [pc, #148]	; (4530 <lv_style_init+0x264>)
    449c:	612b      	str	r3, [r5, #16]
    lv_style_btn_ina.text.color        = lv_color_make(0x70, 0x70, 0x70);
    449e:	4b25      	ldr	r3, [pc, #148]	; (4534 <lv_style_init+0x268>)
    44a0:	62eb      	str	r3, [r5, #44]	; 0x2c
    lv_style_btn_ina.image.color       = lv_color_make(0x70, 0x70, 0x70);
    44a2:	642b      	str	r3, [r5, #64]	; 0x40
    lv_style_btn_ina.line.color        = lv_color_make(0x70, 0x70, 0x70);
    44a4:	64ab      	str	r3, [r5, #72]	; 0x48
}
    44a6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    44aa:	bf00      	nop
    44ac:	200004d8 	.word	0x200004d8
    44b0:	ff5596d8 	.word	0xff5596d8
    44b4:	20000398 	.word	0x20000398
    44b8:	ff202020 	.word	0xff202020
    44bc:	ff303030 	.word	0xff303030
    44c0:	2000a158 	.word	0x2000a158
    44c4:	20000438 	.word	0x20000438
    44c8:	fff0f0f0 	.word	0xfff0f0f0
    44cc:	20000488 	.word	0x20000488
    44d0:	ffc0c0c0 	.word	0xffc0c0c0
    44d4:	ff404040 	.word	0xff404040
    44d8:	ff6b9ac7 	.word	0xff6b9ac7
    44dc:	ff2b598b 	.word	0xff2b598b
    44e0:	20000528 	.word	0x20000528
    44e4:	ffe0e0e0 	.word	0xffe0e0e0
    44e8:	20000578 	.word	0x20000578
    44ec:	200005c8 	.word	0x200005c8
    44f0:	200002a8 	.word	0x200002a8
    44f4:	ff336294 	.word	0xff336294
    44f8:	ff76a2d0 	.word	0xff76a2d0
    44fc:	ff193a5d 	.word	0xff193a5d
    4500:	20000258 	.word	0x20000258
    4504:	ff0b1928 	.word	0xff0b1928
    4508:	ff10263c 	.word	0xff10263c
    450c:	200002f8 	.word	0x200002f8
    4510:	ffa4b5c6 	.word	0xffa4b5c6
    4514:	20000348 	.word	0x20000348
    4518:	ff376290 	.word	0xff376290
    451c:	ff01070d 	.word	0xff01070d
    4520:	ffc8ddf4 	.word	0xffc8ddf4
    4524:	20000208 	.word	0x20000208
    4528:	ff2b4c70 	.word	0xff2b4c70
    452c:	ffd8d8d8 	.word	0xffd8d8d8
    4530:	ff909090 	.word	0xff909090
    4534:	ff707070 	.word	0xff707070
    4538:	ff808080 	.word	0xff808080
    453c:	200003e8 	.word	0x200003e8
    4540:	ff021427 	.word	0xff021427
    4544:	ff0a1122 	.word	0xff0a1122

00004548 <lv_draw_letter>:
 * @param color color of letter
 * @param opa opacity of letter (0..255)
 */
void lv_draw_letter(const lv_point_t * pos_p, const lv_area_t * mask_p, const lv_font_t * font_p, uint32_t letter,
                    lv_color_t color, lv_opa_t opa)
{
    4548:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    454c:	b0a3      	sub	sp, #140	; 0x8c
    454e:	469a      	mov	sl, r3
    4550:	f89d 30b4 	ldrb.w	r3, [sp, #180]	; 0xb4
    4554:	9308      	str	r3, [sp, #32]
    /*clang-format off*/
    const uint8_t bpp1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
    4556:	f44f 437f 	mov.w	r3, #65280	; 0xff00
    455a:	f8ad 3064 	strh.w	r3, [sp, #100]	; 0x64
    const uint8_t bpp2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
    455e:	f5a3 03ad 	sub.w	r3, r3, #5668864	; 0x568000
    4562:	f5a3 5328 	sub.w	r3, r3, #10752	; 0x2a00
    4566:	931b      	str	r3, [sp, #108]	; 0x6c
    const uint8_t bpp4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
    4568:	4bb4      	ldr	r3, [pc, #720]	; (483c <lv_draw_letter+0x2f4>)
{
    456a:	4617      	mov	r7, r2
    456c:	4604      	mov	r4, r0
    456e:	460d      	mov	r5, r1
    const uint8_t bpp4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
    4570:	aa1e      	add	r2, sp, #120	; 0x78
    4572:	f103 0c10 	add.w	ip, r3, #16
    4576:	6818      	ldr	r0, [r3, #0]
    4578:	6859      	ldr	r1, [r3, #4]
    457a:	4616      	mov	r6, r2
    457c:	c603      	stmia	r6!, {r0, r1}
    457e:	3308      	adds	r3, #8
    4580:	4563      	cmp	r3, ip
    4582:	4632      	mov	r2, r6
    4584:	d1f7      	bne.n	4576 <lv_draw_letter+0x2e>
                                        68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255};
    /*clang-format on*/

    if(opa < LV_OPA_MIN) return;
    4586:	9b08      	ldr	r3, [sp, #32]
    4588:	2b0f      	cmp	r3, #15
    458a:	d90a      	bls.n	45a2 <lv_draw_letter+0x5a>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
    458c:	2bfc      	cmp	r3, #252	; 0xfc
    458e:	bf28      	it	cs
    4590:	23ff      	movcs	r3, #255	; 0xff
    4592:	9308      	str	r3, [sp, #32]

    if(font_p == NULL) {
    4594:	b947      	cbnz	r7, 45a8 <lv_draw_letter+0x60>
        LV_LOG_WARN("Font: character's bitmap not found");
    4596:	4baa      	ldr	r3, [pc, #680]	; (4840 <lv_draw_letter+0x2f8>)
    4598:	49aa      	ldr	r1, [pc, #680]	; (4844 <lv_draw_letter+0x2fc>)
    459a:	22f7      	movs	r2, #247	; 0xf7
    459c:	2002      	movs	r0, #2
    459e:	f001 fce5 	bl	5f6c <lv_log_add>

        /*Next row in VDB*/
        if(subpx) vdb_buf_tmp += vdb_width - (col_end - col_start) / 3;
        else vdb_buf_tmp += vdb_width - (col_end - col_start);
    }
}
    45a2:	b023      	add	sp, #140	; 0x8c
    45a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bool g_ret = lv_font_get_glyph_dsc(font_p, &g, letter, '\0');
    45a8:	2300      	movs	r3, #0
    45aa:	4652      	mov	r2, sl
    45ac:	a91c      	add	r1, sp, #112	; 0x70
    45ae:	4638      	mov	r0, r7
    45b0:	f007 faf9 	bl	bba6 <lv_font_get_glyph_dsc>
    if(g_ret == false) return;
    45b4:	2800      	cmp	r0, #0
    45b6:	d0f4      	beq.n	45a2 <lv_draw_letter+0x5a>
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
    45b8:	f99d 1075 	ldrsb.w	r1, [sp, #117]	; 0x75
    45bc:	9106      	str	r1, [sp, #24]
    if(g.bpp == 3) g.bpp = 4;
    45be:	f89d 1076 	ldrb.w	r1, [sp, #118]	; 0x76
    lv_coord_t pos_x = pos_p->x + g.ofs_x;
    45c2:	f9b4 9000 	ldrsh.w	r9, [r4]
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
    45c6:	f9b4 6002 	ldrsh.w	r6, [r4, #2]
    lv_coord_t pos_x = pos_p->x + g.ofs_x;
    45ca:	f99d 2074 	ldrsb.w	r2, [sp, #116]	; 0x74
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
    45ce:	f897 8008 	ldrb.w	r8, [r7, #8]
    45d2:	7a7b      	ldrb	r3, [r7, #9]
    45d4:	f89d 4073 	ldrb.w	r4, [sp, #115]	; 0x73
    if(g.bpp == 3) g.bpp = 4;
    45d8:	2903      	cmp	r1, #3
    45da:	d106      	bne.n	45ea <lv_draw_letter+0xa2>
    45dc:	2104      	movs	r1, #4
    45de:	f88d 1076 	strb.w	r1, [sp, #118]	; 0x76
            bitmask_init  = 0xF0;
    45e2:	21f0      	movs	r1, #240	; 0xf0
    45e4:	9109      	str	r1, [sp, #36]	; 0x24
            bpp_opa_table = bpp4_opa_table;
    45e6:	a91e      	add	r1, sp, #120	; 0x78
    45e8:	e019      	b.n	461e <lv_draw_letter+0xd6>
    switch(g.bpp) {
    45ea:	3901      	subs	r1, #1
    45ec:	2907      	cmp	r1, #7
    45ee:	d8d8      	bhi.n	45a2 <lv_draw_letter+0x5a>
    45f0:	a001      	add	r0, pc, #4	; (adr r0, 45f8 <lv_draw_letter+0xb0>)
    45f2:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
    45f6:	bf00      	nop
    45f8:	000047ed 	.word	0x000047ed
    45fc:	00004619 	.word	0x00004619
    4600:	000045a3 	.word	0x000045a3
    4604:	000045e3 	.word	0x000045e3
    4608:	000045a3 	.word	0x000045a3
    460c:	000045a3 	.word	0x000045a3
    4610:	000045a3 	.word	0x000045a3
    4614:	000047e5 	.word	0x000047e5
            bitmask_init  = 0xC0;
    4618:	21c0      	movs	r1, #192	; 0xc0
    461a:	9109      	str	r1, [sp, #36]	; 0x24
            bpp_opa_table = bpp2_opa_table;
    461c:	a91b      	add	r1, sp, #108	; 0x6c
            bpp_opa_table = bpp1_opa_table;
    461e:	9105      	str	r1, [sp, #20]
    const uint8_t * map_p = lv_font_get_glyph_bitmap(font_p, letter);
    4620:	4638      	mov	r0, r7
    4622:	4651      	mov	r1, sl
    4624:	930a      	str	r3, [sp, #40]	; 0x28
    4626:	9207      	str	r2, [sp, #28]
    4628:	f007 fabb 	bl	bba2 <lv_font_get_glyph_bitmap>
    if(map_p == NULL) return;
    462c:	9004      	str	r0, [sp, #16]
    462e:	2800      	cmp	r0, #0
    4630:	d0b7      	beq.n	45a2 <lv_draw_letter+0x5a>
    lv_coord_t pos_x = pos_p->x + g.ofs_x;
    4632:	9a07      	ldr	r2, [sp, #28]
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
    4634:	f9b5 1000 	ldrsh.w	r1, [r5]
    lv_coord_t pos_x = pos_p->x + g.ofs_x;
    4638:	4491      	add	r9, r2
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
    463a:	f89d 2072 	ldrb.w	r2, [sp, #114]	; 0x72
    lv_coord_t pos_x = pos_p->x + g.ofs_x;
    463e:	fa0f f989 	sxth.w	r9, r9
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
    4642:	444a      	add	r2, r9
    4644:	428a      	cmp	r2, r1
    4646:	dbac      	blt.n	45a2 <lv_draw_letter+0x5a>
    4648:	f9b5 2004 	ldrsh.w	r2, [r5, #4]
    464c:	454a      	cmp	r2, r9
    464e:	dba8      	blt.n	45a2 <lv_draw_letter+0x5a>
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
    4650:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
    4652:	f9b5 2002 	ldrsh.w	r2, [r5, #2]
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
    4656:	eba8 0803 	sub.w	r8, r8, r3
    465a:	9b06      	ldr	r3, [sp, #24]
    465c:	4446      	add	r6, r8
    465e:	b236      	sxth	r6, r6
    4660:	441c      	add	r4, r3
    4662:	1b33      	subs	r3, r6, r4
    4664:	fa0f f883 	sxth.w	r8, r3
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
    4668:	f89d 3073 	ldrb.w	r3, [sp, #115]	; 0x73
    466c:	4443      	add	r3, r8
    466e:	4293      	cmp	r3, r2
    4670:	db97      	blt.n	45a2 <lv_draw_letter+0x5a>
    4672:	f9b5 3006 	ldrsh.w	r3, [r5, #6]
    4676:	4543      	cmp	r3, r8
    4678:	db93      	blt.n	45a2 <lv_draw_letter+0x5a>
    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
    467a:	f7ff fc81 	bl	3f80 <lv_refr_get_disp_refreshing>
    467e:	9011      	str	r0, [sp, #68]	; 0x44
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
    4680:	f006 fdb3 	bl	b1ea <lv_disp_get_buf>
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    4684:	8a83      	ldrh	r3, [r0, #20]
    4686:	f9b0 1010 	ldrsh.w	r1, [r0, #16]
    468a:	9007      	str	r0, [sp, #28]
    468c:	3301      	adds	r3, #1
    468e:	1a5b      	subs	r3, r3, r1
    4690:	b21b      	sxth	r3, r3
    4692:	930b      	str	r3, [sp, #44]	; 0x2c
    bool subpx = font_p->subpx == LV_FONT_SUBPX_NONE ? false : true;
    4694:	7abb      	ldrb	r3, [r7, #10]
    lv_color_t * vdb_buf_tmp = vdb->buf_act;
    4696:	f8d0 c008 	ldr.w	ip, [r0, #8]
    uint16_t width_bit = g.box_w * g.bpp; /*Letter width in bits*/
    469a:	f89d 2076 	ldrb.w	r2, [sp, #118]	; 0x76
    uint8_t width_byte_scr = g.box_w >> 3; /*Width in bytes (on the screen finally) (e.g. w = 11 -> 2 bytes wide)*/
    469e:	f89d 0072 	ldrb.w	r0, [sp, #114]	; 0x72
    uint16_t width_bit = g.box_w * g.bpp; /*Letter width in bits*/
    46a2:	f9b5 a000 	ldrsh.w	sl, [r5]
    if(subpx == false) {
    46a6:	f013 0303 	ands.w	r3, r3, #3
    uint16_t width_bit = g.box_w * g.bpp; /*Letter width in bits*/
    46aa:	fb00 fe02 	mul.w	lr, r0, r2
    if(subpx == false) {
    46ae:	930c      	str	r3, [sp, #48]	; 0x30
    46b0:	f040 80a5 	bne.w	47fe <lv_draw_letter+0x2b6>
        col_start = pos_x >= mask_p->x1 ? 0 : mask_p->x1 - pos_x;
    46b4:	45ca      	cmp	sl, r9
        col_end   = pos_x + g.box_w <= mask_p->x2 ? g.box_w : mask_p->x2 - pos_x + 1;
    46b6:	f9b5 3004 	ldrsh.w	r3, [r5, #4]
        col_start = pos_x >= mask_p->x1 ? 0 : mask_p->x1 - pos_x;
    46ba:	bfd4      	ite	le
    46bc:	f8dd a030 	ldrle.w	sl, [sp, #48]	; 0x30
    46c0:	ebaa 0a09 	subgt.w	sl, sl, r9
        col_end   = pos_x + g.box_w <= mask_p->x2 ? g.box_w : mask_p->x2 - pos_x + 1;
    46c4:	eb00 0709 	add.w	r7, r0, r9
        col_start = pos_x >= mask_p->x1 ? 0 : mask_p->x1 - pos_x;
    46c8:	bfc8      	it	gt
    46ca:	fa0f fa8a 	sxthgt.w	sl, sl
        col_end   = pos_x + g.box_w <= mask_p->x2 ? g.box_w : mask_p->x2 - pos_x + 1;
    46ce:	429f      	cmp	r7, r3
    46d0:	f300 8090 	bgt.w	47f4 <lv_draw_letter+0x2ac>
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
    46d4:	b203      	sxth	r3, r0
        row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
    46d6:	f9b5 7002 	ldrsh.w	r7, [r5, #2]
        row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
    46da:	f89d 0073 	ldrb.w	r0, [sp, #115]	; 0x73
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
    46de:	9306      	str	r3, [sp, #24]
        row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
    46e0:	4547      	cmp	r7, r8
    46e2:	bfc8      	it	gt
    46e4:	193f      	addgt	r7, r7, r4
        row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
    46e6:	f9b5 3006 	ldrsh.w	r3, [r5, #6]
        row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
    46ea:	bfc8      	it	gt
    46ec:	1bbf      	subgt	r7, r7, r6
        row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
    46ee:	eb00 0508 	add.w	r5, r0, r8
        row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
    46f2:	bfcc      	ite	gt
    46f4:	b23f      	sxthgt	r7, r7
    46f6:	2700      	movle	r7, #0
        row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
    46f8:	429d      	cmp	r5, r3
    46fa:	bfc2      	ittt	gt
    46fc:	3401      	addgt	r4, #1
    46fe:	18e4      	addgt	r4, r4, r3
    4700:	1ba0      	subgt	r0, r4, r6
    4702:	b203      	sxth	r3, r0
    4704:	930f      	str	r3, [sp, #60]	; 0x3c
    vdb_buf_tmp += ((pos_y - vdb->area.y1) * vdb_width) + pos_x - vdb->area.x1;
    4706:	9b07      	ldr	r3, [sp, #28]
    4708:	f9b3 4012 	ldrsh.w	r4, [r3, #18]
    470c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    470e:	eba9 0101 	sub.w	r1, r9, r1
    4712:	eba8 0404 	sub.w	r4, r8, r4
    4716:	fb03 1404 	mla	r4, r3, r4, r1
    471a:	fb03 f107 	mul.w	r1, r3, r7
    if(subpx) vdb_buf_tmp += (row_start * vdb_width) + col_start / 3;
    471e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    vdb_buf_tmp += ((pos_y - vdb->area.y1) * vdb_width) + pos_x - vdb->area.x1;
    4720:	eb0c 0484 	add.w	r4, ip, r4, lsl #2
    if(subpx) vdb_buf_tmp += (row_start * vdb_width) + col_start / 3;
    4724:	2b00      	cmp	r3, #0
    4726:	f000 8086 	beq.w	4836 <lv_draw_letter+0x2ee>
    472a:	2303      	movs	r3, #3
    472c:	fb9a f3f3 	sdiv	r3, sl, r3
    4730:	440b      	add	r3, r1
    uint32_t bit_ofs = (row_start * width_bit) + (col_start * g.bpp);
    4732:	fb12 f50a 	smulbb	r5, r2, sl
    else vdb_buf_tmp += (row_start * vdb_width) + col_start;
    4736:	eb04 0483 	add.w	r4, r4, r3, lsl #2
    map_p += bit_ofs >> 3;
    473a:	9b04      	ldr	r3, [sp, #16]
        else vdb_buf_tmp += vdb_width - (col_end - col_start);
    473c:	9a06      	ldr	r2, [sp, #24]
    uint32_t bit_ofs = (row_start * width_bit) + (col_start * g.bpp);
    473e:	fb07 550e 	mla	r5, r7, lr, r5
    map_p += bit_ofs >> 3;
    4742:	eb03 03d5 	add.w	r3, r3, r5, lsr #3
    4746:	930a      	str	r3, [sp, #40]	; 0x28
    col_bit = bit_ofs & 0x7; /* "& 0x7" equals to "% 8" just faster */
    4748:	f005 0307 	and.w	r3, r5, #7
    474c:	9304      	str	r3, [sp, #16]
    uint8_t txt_rgb[3] = {LV_COLOR_GET_R(color), LV_COLOR_GET_G(color), LV_COLOR_GET_B(color)};
    474e:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
    4750:	f3c3 4307 	ubfx	r3, r3, #16, #8
    4754:	9312      	str	r3, [sp, #72]	; 0x48
    4756:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
    4758:	f3c3 2307 	ubfx	r3, r3, #8, #8
    475c:	9313      	str	r3, [sp, #76]	; 0x4c
    475e:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
    4760:	b2db      	uxtb	r3, r3
    4762:	9314      	str	r3, [sp, #80]	; 0x50
        else vdb_buf_tmp += vdb_width - (col_end - col_start);
    4764:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    4766:	4453      	add	r3, sl
    4768:	1a9b      	subs	r3, r3, r2
    476a:	009b      	lsls	r3, r3, #2
    476c:	9316      	str	r3, [sp, #88]	; 0x58
        if(subpx) vdb_buf_tmp += vdb_width - (col_end - col_start) / 3;
    476e:	eba2 030a 	sub.w	r3, r2, sl
    4772:	f06f 0202 	mvn.w	r2, #2
    4776:	fb93 f3f2 	sdiv	r3, r3, r2
    477a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    477c:	4413      	add	r3, r2
    477e:	009b      	lsls	r3, r3, #2
    4780:	9315      	str	r3, [sp, #84]	; 0x54
    for(row = row_start; row < row_end; row++) {
    4782:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    4784:	429f      	cmp	r7, r3
    4786:	f6bf af0c 	bge.w	45a2 <lv_draw_letter+0x5a>
        bitmask = bitmask_init >> col_bit;
    478a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    478c:	9a04      	ldr	r2, [sp, #16]
    478e:	4113      	asrs	r3, r2
    4790:	b2db      	uxtb	r3, r3
        for(col = col_start; col < col_end; col++) {
    4792:	e9cd 3a0d 	strd	r3, sl, [sp, #52]	; 0x34
    4796:	f8bd 3020 	ldrh.w	r3, [sp, #32]
    479a:	9310      	str	r3, [sp, #64]	; 0x40
                                *vdb_buf_tmp = lv_color_mix(color, *vdb_buf_tmp, px_opa);
    479c:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
    479e:	f3c3 4307 	ubfx	r3, r3, #16, #8
        uint8_t sub_px_cnt = 0;
    47a2:	2600      	movs	r6, #0
                                *vdb_buf_tmp = lv_color_mix(color, *vdb_buf_tmp, px_opa);
    47a4:	9317      	str	r3, [sp, #92]	; 0x5c
        for(col = col_start; col < col_end; col++) {
    47a6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    47a8:	9a06      	ldr	r2, [sp, #24]
    47aa:	f89d 1076 	ldrb.w	r1, [sp, #118]	; 0x76
    47ae:	4293      	cmp	r3, r2
    47b0:	db4a      	blt.n	4848 <lv_draw_letter+0x300>
        col_bit += ((g.box_w - col_end) + col_start) * g.bpp;
    47b2:	f89d 3072 	ldrb.w	r3, [sp, #114]	; 0x72
    47b6:	4453      	add	r3, sl
    47b8:	1a9b      	subs	r3, r3, r2
    47ba:	9a04      	ldr	r2, [sp, #16]
    47bc:	fb13 f301 	smulbb	r3, r3, r1
    47c0:	441a      	add	r2, r3
        map_p += (col_bit >> 3);
    47c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        col_bit += ((g.box_w - col_end) + col_start) * g.bpp;
    47c4:	b295      	uxth	r5, r2
        map_p += (col_bit >> 3);
    47c6:	eb03 03d5 	add.w	r3, r3, r5, lsr #3
    47ca:	930a      	str	r3, [sp, #40]	; 0x28
        col_bit = col_bit & 0x7;
    47cc:	f005 0307 	and.w	r3, r5, #7
    47d0:	9304      	str	r3, [sp, #16]
        if(subpx) vdb_buf_tmp += vdb_width - (col_end - col_start) / 3;
    47d2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    47d4:	2b00      	cmp	r3, #0
    47d6:	f000 80f9 	beq.w	49cc <lv_draw_letter+0x484>
    47da:	9b15      	ldr	r3, [sp, #84]	; 0x54
    for(row = row_start; row < row_end; row++) {
    47dc:	3701      	adds	r7, #1
        else vdb_buf_tmp += vdb_width - (col_end - col_start);
    47de:	441c      	add	r4, r3
    for(row = row_start; row < row_end; row++) {
    47e0:	b23f      	sxth	r7, r7
    47e2:	e7ce      	b.n	4782 <lv_draw_letter+0x23a>
            bitmask_init  = 0xFF;
    47e4:	21ff      	movs	r1, #255	; 0xff
    47e6:	9109      	str	r1, [sp, #36]	; 0x24
            bpp_opa_table = NULL;
    47e8:	2100      	movs	r1, #0
    47ea:	e718      	b.n	461e <lv_draw_letter+0xd6>
            bitmask_init  = 0x80;
    47ec:	2180      	movs	r1, #128	; 0x80
    47ee:	9109      	str	r1, [sp, #36]	; 0x24
            bpp_opa_table = bpp1_opa_table;
    47f0:	a919      	add	r1, sp, #100	; 0x64
    47f2:	e714      	b.n	461e <lv_draw_letter+0xd6>
        col_end   = pos_x + g.box_w <= mask_p->x2 ? g.box_w : mask_p->x2 - pos_x + 1;
    47f4:	3301      	adds	r3, #1
    47f6:	eba3 0309 	sub.w	r3, r3, r9
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
    47fa:	b21b      	sxth	r3, r3
    47fc:	e76b      	b.n	46d6 <lv_draw_letter+0x18e>
        col_start = pos_x >= mask_p->x1 ? 0 : (mask_p->x1 - pos_x) * 3;
    47fe:	45ca      	cmp	sl, r9
    4800:	bfc8      	it	gt
    4802:	ebaa 0a09 	subgt.w	sl, sl, r9
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
    4806:	f9b5 3004 	ldrsh.w	r3, [r5, #4]
        col_start = pos_x >= mask_p->x1 ? 0 : (mask_p->x1 - pos_x) * 3;
    480a:	bfc8      	it	gt
    480c:	eb0a 0a4a 	addgt.w	sl, sl, sl, lsl #1
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
    4810:	f04f 0703 	mov.w	r7, #3
    4814:	fbb0 f7f7 	udiv	r7, r0, r7
    4818:	444f      	add	r7, r9
        col_start = pos_x >= mask_p->x1 ? 0 : (mask_p->x1 - pos_x) * 3;
    481a:	bfcc      	ite	gt
    481c:	fa0f fa8a 	sxthgt.w	sl, sl
    4820:	f04f 0a00 	movle.w	sl, #0
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
    4824:	429f      	cmp	r7, r3
    4826:	f77f af55 	ble.w	46d4 <lv_draw_letter+0x18c>
    482a:	3301      	adds	r3, #1
    482c:	eba3 0309 	sub.w	r3, r3, r9
    4830:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    4834:	e7e1      	b.n	47fa <lv_draw_letter+0x2b2>
    else vdb_buf_tmp += (row_start * vdb_width) + col_start;
    4836:	eb01 030a 	add.w	r3, r1, sl
    483a:	e77a      	b.n	4732 <lv_draw_letter+0x1ea>
    483c:	0000c1e0 	.word	0x0000c1e0
    4840:	00045786 	.word	0x00045786
    4844:	000457a9 	.word	0x000457a9
            letter_px = (*map_p & bitmask) >> (8 - col_bit - g.bpp);
    4848:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    484a:	9804      	ldr	r0, [sp, #16]
    484c:	781a      	ldrb	r2, [r3, #0]
    484e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    4850:	401a      	ands	r2, r3
    4852:	f1c1 0308 	rsb	r3, r1, #8
    4856:	1a1b      	subs	r3, r3, r0
    4858:	411a      	asrs	r2, r3
            if(subpx == false) {
    485a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
            letter_px = (*map_p & bitmask) >> (8 - col_bit - g.bpp);
    485c:	b2d2      	uxtb	r2, r2
            if(subpx == false) {
    485e:	2b00      	cmp	r3, #0
    4860:	d15c      	bne.n	491c <lv_draw_letter+0x3d4>
                if(letter_px != 0) {
    4862:	b30a      	cbz	r2, 48a8 <lv_draw_letter+0x360>
                    if(opa == LV_OPA_COVER) {
    4864:	9b08      	ldr	r3, [sp, #32]
    4866:	2bff      	cmp	r3, #255	; 0xff
    4868:	d134      	bne.n	48d4 <lv_draw_letter+0x38c>
                        px_opa = g.bpp == 8 ? letter_px : bpp_opa_table[letter_px];
    486a:	2908      	cmp	r1, #8
    486c:	d001      	beq.n	4872 <lv_draw_letter+0x32a>
    486e:	9b05      	ldr	r3, [sp, #20]
    4870:	5c9a      	ldrb	r2, [r3, r2]
                    if(disp->driver.set_px_cb) {
    4872:	9b11      	ldr	r3, [sp, #68]	; 0x44
    4874:	695b      	ldr	r3, [r3, #20]
    4876:	461d      	mov	r5, r3
    4878:	2b00      	cmp	r3, #0
    487a:	d035      	beq.n	48e8 <lv_draw_letter+0x3a0>
                        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width,
    487c:	9b07      	ldr	r3, [sp, #28]
    487e:	990e      	ldr	r1, [sp, #56]	; 0x38
    4880:	8a1b      	ldrh	r3, [r3, #16]
    4882:	9202      	str	r2, [sp, #8]
    4884:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
    4886:	9201      	str	r2, [sp, #4]
    4888:	9a07      	ldr	r2, [sp, #28]
    488a:	9811      	ldr	r0, [sp, #68]	; 0x44
    488c:	8a52      	ldrh	r2, [r2, #18]
    488e:	eba8 0202 	sub.w	r2, r8, r2
    4892:	eba9 0303 	sub.w	r3, r9, r3
    4896:	443a      	add	r2, r7
    4898:	440b      	add	r3, r1
    489a:	b212      	sxth	r2, r2
    489c:	9907      	ldr	r1, [sp, #28]
    489e:	9200      	str	r2, [sp, #0]
    48a0:	b21b      	sxth	r3, r3
    48a2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    48a4:	6889      	ldr	r1, [r1, #8]
    48a6:	47a8      	blx	r5
                vdb_buf_tmp++;
    48a8:	3404      	adds	r4, #4
            if(col_bit < 8 - g.bpp) {
    48aa:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
    48ae:	9904      	ldr	r1, [sp, #16]
    48b0:	f1c3 0208 	rsb	r2, r3, #8
    48b4:	4291      	cmp	r1, r2
    48b6:	f280 8081 	bge.w	49bc <lv_draw_letter+0x474>
                col_bit += g.bpp;
    48ba:	460a      	mov	r2, r1
    48bc:	441a      	add	r2, r3
    48be:	b292      	uxth	r2, r2
    48c0:	9204      	str	r2, [sp, #16]
                bitmask = bitmask >> g.bpp;
    48c2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    48c4:	411a      	asrs	r2, r3
    48c6:	b2d3      	uxtb	r3, r2
    48c8:	930d      	str	r3, [sp, #52]	; 0x34
        for(col = col_start; col < col_end; col++) {
    48ca:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    48cc:	3301      	adds	r3, #1
    48ce:	b21b      	sxth	r3, r3
    48d0:	930e      	str	r3, [sp, #56]	; 0x38
    48d2:	e768      	b.n	47a6 <lv_draw_letter+0x25e>
                        px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
    48d4:	2908      	cmp	r1, #8
                                : (uint16_t)((uint16_t)bpp_opa_table[letter_px] * opa) >> 8;
    48d6:	bf1c      	itt	ne
    48d8:	9b05      	ldrne	r3, [sp, #20]
    48da:	5c9a      	ldrbne	r2, [r3, r2]
    48dc:	9b10      	ldr	r3, [sp, #64]	; 0x40
    48de:	fb12 f203 	smulbb	r2, r2, r3
                        px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
    48e2:	f3c2 2207 	ubfx	r2, r2, #8, #8
    48e6:	e7c4      	b.n	4872 <lv_draw_letter+0x32a>
                    } else if(vdb_buf_tmp->full != color.full) {
    48e8:	6823      	ldr	r3, [r4, #0]
    48ea:	992c      	ldr	r1, [sp, #176]	; 0xb0
    48ec:	428b      	cmp	r3, r1
    48ee:	d0db      	beq.n	48a8 <lv_draw_letter+0x360>
                        if(px_opa > LV_OPA_MAX) {
    48f0:	2afb      	cmp	r2, #251	; 0xfb
    48f2:	d901      	bls.n	48f8 <lv_draw_letter+0x3b0>
                            *vdb_buf_tmp = color;
    48f4:	6021      	str	r1, [r4, #0]
    48f6:	e7d7      	b.n	48a8 <lv_draw_letter+0x360>
                        } else if(px_opa > LV_OPA_MIN) {
    48f8:	2a10      	cmp	r2, #16
    48fa:	d9d5      	bls.n	48a8 <lv_draw_letter+0x360>
                                *vdb_buf_tmp = lv_color_mix(color, *vdb_buf_tmp, px_opa);
    48fc:	7823      	ldrb	r3, [r4, #0]
    48fe:	9202      	str	r2, [sp, #8]
    4900:	78a2      	ldrb	r2, [r4, #2]
    4902:	9201      	str	r2, [sp, #4]
    4904:	992c      	ldr	r1, [sp, #176]	; 0xb0
    4906:	982c      	ldr	r0, [sp, #176]	; 0xb0
    4908:	7862      	ldrb	r2, [r4, #1]
    490a:	9200      	str	r2, [sp, #0]
    490c:	f3c1 2107 	ubfx	r1, r1, #8, #8
    4910:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    4912:	b2c0      	uxtb	r0, r0
    4914:	f005 fae6 	bl	9ee4 <lv_color_mix.isra.0>
    4918:	6020      	str	r0, [r4, #0]
    491a:	e7c5      	b.n	48a8 <lv_draw_letter+0x360>
                if(letter_px != 0) {
    491c:	b132      	cbz	r2, 492c <lv_draw_letter+0x3e4>
                    if(opa == LV_OPA_COVER) {
    491e:	9b08      	ldr	r3, [sp, #32]
    4920:	2bff      	cmp	r3, #255	; 0xff
    4922:	d11b      	bne.n	495c <lv_draw_letter+0x414>
                        px_opa = g.bpp == 8 ? letter_px : bpp_opa_table[letter_px];
    4924:	2908      	cmp	r1, #8
    4926:	d001      	beq.n	492c <lv_draw_letter+0x3e4>
    4928:	9b05      	ldr	r3, [sp, #20]
    492a:	5c9a      	ldrb	r2, [r3, r2]
                    font_rgb[sub_px_cnt] = 0;
    492c:	ab22      	add	r3, sp, #136	; 0x88
    492e:	4433      	add	r3, r6
                sub_px_cnt ++;
    4930:	3601      	adds	r6, #1
    4932:	b2f6      	uxtb	r6, r6
                if(sub_px_cnt == 3) {
    4934:	2e03      	cmp	r6, #3
                    font_rgb[sub_px_cnt] = 0;
    4936:	f803 2c20 	strb.w	r2, [r3, #-32]
                if(sub_px_cnt == 3) {
    493a:	d1b6      	bne.n	48aa <lv_draw_letter+0x362>
                    if(font_rgb[0] == 0 && font_rgb[1] == 0 && font_rgb[2] == 0) {
    493c:	f89d c068 	ldrb.w	ip, [sp, #104]	; 0x68
    4940:	f89d 2069 	ldrb.w	r2, [sp, #105]	; 0x69
    4944:	f89d 006a 	ldrb.w	r0, [sp, #106]	; 0x6a
    4948:	ea4c 0302 	orr.w	r3, ip, r2
    494c:	4303      	orrs	r3, r0
    494e:	d10f      	bne.n	4970 <lv_draw_letter+0x428>
                        res_color = *vdb_buf_tmp;
    4950:	f8d4 b000 	ldr.w	fp, [r4]
                        vdb_buf_tmp->full = res_color.full;
    4954:	f844 bb04 	str.w	fp, [r4], #4
                    sub_px_cnt = 0;
    4958:	2600      	movs	r6, #0
    495a:	e7a6      	b.n	48aa <lv_draw_letter+0x362>
                        px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
    495c:	2908      	cmp	r1, #8
                                : (uint16_t)((uint16_t)bpp_opa_table[letter_px] * opa) >> 8;
    495e:	bf1c      	itt	ne
    4960:	9b05      	ldrne	r3, [sp, #20]
    4962:	5c9a      	ldrbne	r2, [r3, r2]
    4964:	9b10      	ldr	r3, [sp, #64]	; 0x40
    4966:	fb12 f203 	smulbb	r2, r2, r3
                        px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
    496a:	f3c2 2207 	ubfx	r2, r2, #8, #8
                    font_rgb[sub_px_cnt] = px_opa;
    496e:	e7dd      	b.n	492c <lv_draw_letter+0x3e4>
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8);
    4970:	9d12      	ldr	r5, [sp, #72]	; 0x48
    4972:	f894 e002 	ldrb.w	lr, [r4, #2]
                        uint8_t bg_rgb[3] = {LV_COLOR_GET_R(*vdb_buf_tmp), LV_COLOR_GET_G(*vdb_buf_tmp), LV_COLOR_GET_B(*vdb_buf_tmp)};
    4976:	7821      	ldrb	r1, [r4, #0]
    4978:	7863      	ldrb	r3, [r4, #1]
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8);
    497a:	f1cc 06ff 	rsb	r6, ip, #255	; 0xff
    497e:	fb15 fc0c 	smulbb	ip, r5, ip
                        LV_COLOR_SET_B(res_color, (uint16_t)((uint16_t)txt_rgb[2] * font_rgb[2] + (bg_rgb[2] * (255 - font_rgb[2]))) >> 8);
    4982:	9d14      	ldr	r5, [sp, #80]	; 0x50
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8);
    4984:	fb0e cc06 	mla	ip, lr, r6, ip
                        LV_COLOR_SET_B(res_color, (uint16_t)((uint16_t)txt_rgb[2] * font_rgb[2] + (bg_rgb[2] * (255 - font_rgb[2]))) >> 8);
    4988:	f1c0 06ff 	rsb	r6, r0, #255	; 0xff
    498c:	fb15 f000 	smulbb	r0, r5, r0
    4990:	fb06 0101 	mla	r1, r6, r1, r0
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8);
    4994:	f3cc 2c07 	ubfx	ip, ip, #8, #8
                        LV_COLOR_SET_G(res_color, (uint16_t)((uint16_t)txt_rgb[1] * font_rgb[1] + (bg_rgb[1] * (255 - font_rgb[1]))) >> 8);
    4998:	9813      	ldr	r0, [sp, #76]	; 0x4c
                        LV_COLOR_SET_B(res_color, (uint16_t)((uint16_t)txt_rgb[2] * font_rgb[2] + (bg_rgb[2] * (255 - font_rgb[2]))) >> 8);
    499a:	f3c1 2107 	ubfx	r1, r1, #8, #8
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8);
    499e:	f36c 4b17 	bfi	fp, ip, #16, #8
                        LV_COLOR_SET_B(res_color, (uint16_t)((uint16_t)txt_rgb[2] * font_rgb[2] + (bg_rgb[2] * (255 - font_rgb[2]))) >> 8);
    49a2:	f361 0b07 	bfi	fp, r1, #0, #8
                        LV_COLOR_SET_G(res_color, (uint16_t)((uint16_t)txt_rgb[1] * font_rgb[1] + (bg_rgb[1] * (255 - font_rgb[1]))) >> 8);
    49a6:	f1c2 01ff 	rsb	r1, r2, #255	; 0xff
    49aa:	fb10 f202 	smulbb	r2, r0, r2
    49ae:	fb01 2303 	mla	r3, r1, r3, r2
    49b2:	f3c3 2307 	ubfx	r3, r3, #8, #8
    49b6:	f363 2b0f 	bfi	fp, r3, #8, #8
    49ba:	e7cb      	b.n	4954 <lv_draw_letter+0x40c>
                map_p++;
    49bc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    49be:	3301      	adds	r3, #1
    49c0:	930a      	str	r3, [sp, #40]	; 0x28
                bitmask = bitmask_init;
    49c2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    49c4:	930d      	str	r3, [sp, #52]	; 0x34
                col_bit = 0;
    49c6:	2300      	movs	r3, #0
    49c8:	9304      	str	r3, [sp, #16]
    49ca:	e77e      	b.n	48ca <lv_draw_letter+0x382>
        else vdb_buf_tmp += vdb_width - (col_end - col_start);
    49cc:	9b16      	ldr	r3, [sp, #88]	; 0x58
    49ce:	e705      	b.n	47dc <lv_draw_letter+0x294>

000049d0 <lv_draw_get_buf>:
 * Be careful to not use the buffer while other processes are using it.
 * @param size the required size
 */
void * lv_draw_get_buf(uint32_t size)
{
    if(size <= draw_buf_size) return LV_GC_ROOT(_lv_draw_buf);
    49d0:	4a09      	ldr	r2, [pc, #36]	; (49f8 <lv_draw_get_buf+0x28>)
{
    49d2:	b538      	push	{r3, r4, r5, lr}
    if(size <= draw_buf_size) return LV_GC_ROOT(_lv_draw_buf);
    49d4:	6815      	ldr	r5, [r2, #0]
    49d6:	4c09      	ldr	r4, [pc, #36]	; (49fc <lv_draw_get_buf+0x2c>)
    49d8:	4285      	cmp	r5, r0
{
    49da:	4601      	mov	r1, r0
    49dc:	6823      	ldr	r3, [r4, #0]
    if(size <= draw_buf_size) return LV_GC_ROOT(_lv_draw_buf);
    49de:	d205      	bcs.n	49ec <lv_draw_get_buf+0x1c>

    LV_LOG_TRACE("lv_draw_get_buf: allocate");

    draw_buf_size = size;
    49e0:	6010      	str	r0, [r2, #0]

    if(LV_GC_ROOT(_lv_draw_buf) == NULL) {
    49e2:	b92b      	cbnz	r3, 49f0 <lv_draw_get_buf+0x20>
        LV_GC_ROOT(_lv_draw_buf) = lv_mem_alloc(size);
    49e4:	f001 f900 	bl	5be8 <lv_mem_alloc>
        LV_ASSERT_MEM(LV_GC_ROOT(_lv_draw_buf));
        return LV_GC_ROOT(_lv_draw_buf);
    }

    LV_GC_ROOT(_lv_draw_buf) = lv_mem_realloc(LV_GC_ROOT(_lv_draw_buf), size);
    49e8:	4603      	mov	r3, r0
    49ea:	6020      	str	r0, [r4, #0]
    LV_ASSERT_MEM(LV_GC_ROOT(_lv_draw_buf));
    return LV_GC_ROOT(_lv_draw_buf);
}
    49ec:	4618      	mov	r0, r3
    49ee:	bd38      	pop	{r3, r4, r5, pc}
    LV_GC_ROOT(_lv_draw_buf) = lv_mem_realloc(LV_GC_ROOT(_lv_draw_buf), size);
    49f0:	4618      	mov	r0, r3
    49f2:	f001 f93d 	bl	5c70 <lv_mem_realloc>
    49f6:	e7f7      	b.n	49e8 <lv_draw_get_buf+0x18>
    49f8:	20000618 	.word	0x20000618
    49fc:	20000640 	.word	0x20000640

00004a00 <lv_draw_free_buf>:

/**
 * Free the draw buffer
 */
void lv_draw_free_buf(void)
{
    4a00:	b510      	push	{r4, lr}
    if(LV_GC_ROOT(_lv_draw_buf)) {
    4a02:	4c05      	ldr	r4, [pc, #20]	; (4a18 <lv_draw_free_buf+0x18>)
    4a04:	6820      	ldr	r0, [r4, #0]
    4a06:	b128      	cbz	r0, 4a14 <lv_draw_free_buf+0x14>
        lv_mem_free(LV_GC_ROOT(_lv_draw_buf));
    4a08:	f001 f914 	bl	5c34 <lv_mem_free>
        LV_GC_ROOT(_lv_draw_buf) = NULL;
        draw_buf_size = 0;
    4a0c:	4a03      	ldr	r2, [pc, #12]	; (4a1c <lv_draw_free_buf+0x1c>)
        LV_GC_ROOT(_lv_draw_buf) = NULL;
    4a0e:	2300      	movs	r3, #0
    4a10:	6023      	str	r3, [r4, #0]
        draw_buf_size = 0;
    4a12:	6013      	str	r3, [r2, #0]
    }
}
    4a14:	bd10      	pop	{r4, pc}
    4a16:	bf00      	nop
    4a18:	20000640 	.word	0x20000640
    4a1c:	20000618 	.word	0x20000618

00004a20 <hex_char_to_num>:
 * Convert a hexadecimal characters to a number (0..15)
 * @param hex Pointer to a hexadecimal character (0..9, A..F)
 * @return the numerical value of `hex` or 0 on error
 */
static uint8_t hex_char_to_num(char hex)
{
    4a20:	4603      	mov	r3, r0
    uint8_t result = 0;

    if(hex >= '0' && hex <= '9') {
    4a22:	3830      	subs	r0, #48	; 0x30
    4a24:	b2c0      	uxtb	r0, r0
    4a26:	2809      	cmp	r0, #9
    4a28:	d90b      	bls.n	4a42 <hex_char_to_num+0x22>
        result = hex - '0';
    } else {
        if(hex >= 'a') hex -= 'a' - 'A'; /*Convert to upper case*/
    4a2a:	2b60      	cmp	r3, #96	; 0x60
    4a2c:	bf84      	itt	hi
    4a2e:	3b20      	subhi	r3, #32
    4a30:	b2db      	uxtbhi	r3, r3

        switch(hex) {
    4a32:	3b41      	subs	r3, #65	; 0x41
    4a34:	b2db      	uxtb	r3, r3
    4a36:	2b05      	cmp	r3, #5
    4a38:	d802      	bhi.n	4a40 <hex_char_to_num+0x20>
    4a3a:	4a02      	ldr	r2, [pc, #8]	; (4a44 <hex_char_to_num+0x24>)
    4a3c:	5cd0      	ldrb	r0, [r2, r3]
    4a3e:	4770      	bx	lr
{
    4a40:	2000      	movs	r0, #0
        default: result = 0; break;
        }
    }

    return result;
}
    4a42:	4770      	bx	lr
    4a44:	000457e5 	.word	0x000457e5

00004a48 <lv_draw_label>:
{
    4a48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4a4c:	b0ad      	sub	sp, #180	; 0xb4
    4a4e:	4606      	mov	r6, r0
    4a50:	9305      	str	r3, [sp, #20]
    if (txt[0] == '\0')  return;
    4a52:	9b36      	ldr	r3, [sp, #216]	; 0xd8
{
    4a54:	910b      	str	r1, [sp, #44]	; 0x2c
    if (txt[0] == '\0')  return;
    4a56:	781b      	ldrb	r3, [r3, #0]
{
    4a58:	f89d b0dc 	ldrb.w	fp, [sp, #220]	; 0xdc
    4a5c:	9f3a      	ldr	r7, [sp, #232]	; 0xe8
    4a5e:	4615      	mov	r5, r2
    if (txt[0] == '\0')  return;
    4a60:	2b00      	cmp	r3, #0
    4a62:	f000 80a7 	beq.w	4bb4 <lv_draw_label+0x16c>
    const lv_font_t * font = style->text.font;
    4a66:	6b53      	ldr	r3, [r2, #52]	; 0x34
    4a68:	9304      	str	r3, [sp, #16]
    if((flag & LV_TXT_FLAG_EXPAND) == 0) {
    4a6a:	f01b 0f02 	tst.w	fp, #2
    4a6e:	f040 80a4 	bne.w	4bba <lv_draw_label+0x172>
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    4a72:	8883      	ldrh	r3, [r0, #4]
    4a74:	8802      	ldrh	r2, [r0, #0]
    4a76:	3301      	adds	r3, #1
    4a78:	1a9b      	subs	r3, r3, r2
    4a7a:	b21b      	sxth	r3, r3
        w = p.x;
    4a7c:	9308      	str	r3, [sp, #32]
    lv_coord_t line_height = lv_font_get_line_height(font) + style->text.line_space;
    4a7e:	9b04      	ldr	r3, [sp, #16]
    4a80:	8f6a      	ldrh	r2, [r5, #58]	; 0x3a
    4a82:	7a1b      	ldrb	r3, [r3, #8]
    4a84:	4413      	add	r3, r2
    4a86:	b21b      	sxth	r3, r3
    4a88:	9307      	str	r3, [sp, #28]
    pos.x = coords->x1;
    4a8a:	8833      	ldrh	r3, [r6, #0]
    4a8c:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
    if(offset != NULL) {
    4a90:	9b38      	ldr	r3, [sp, #224]	; 0xe0
    pos.y = coords->y1;
    4a92:	f9b6 2002 	ldrsh.w	r2, [r6, #2]
    4a96:	f8ad 2052 	strh.w	r2, [sp, #82]	; 0x52
    if(offset != NULL) {
    4a9a:	2b00      	cmp	r3, #0
    4a9c:	f000 820e 	beq.w	4ebc <lv_draw_label+0x474>
        x_ofs = offset->x;
    4aa0:	f9b3 3000 	ldrsh.w	r3, [r3]
    4aa4:	930e      	str	r3, [sp, #56]	; 0x38
        y_ofs = offset->y;
    4aa6:	9b38      	ldr	r3, [sp, #224]	; 0xe0
    4aa8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
        pos.y += y_ofs;
    4aac:	18d1      	adds	r1, r2, r3
    4aae:	f8ad 1052 	strh.w	r1, [sp, #82]	; 0x52
    if(hint && y_ofs == 0 && coords->y1 < 0) {
    4ab2:	2f00      	cmp	r7, #0
    4ab4:	f000 8206 	beq.w	4ec4 <lv_draw_label+0x47c>
    4ab8:	2b00      	cmp	r3, #0
    4aba:	f040 8203 	bne.w	4ec4 <lv_draw_label+0x47c>
    4abe:	2a00      	cmp	r2, #0
    4ac0:	f280 8200 	bge.w	4ec4 <lv_draw_label+0x47c>
        if(LV_MATH_ABS(hint->coord_y - coords->y1) > LV_LABEL_HINT_UPDATE_TH - 2 * line_height) {
    4ac4:	68bb      	ldr	r3, [r7, #8]
    4ac6:	1a9b      	subs	r3, r3, r2
    4ac8:	9a07      	ldr	r2, [sp, #28]
    4aca:	2b00      	cmp	r3, #0
    4acc:	bfb8      	it	lt
    4ace:	425b      	neglt	r3, r3
    4ad0:	f5c2 7200 	rsb	r2, r2, #512	; 0x200
    4ad4:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
            hint->line_start = -1;
    4ad8:	bfc4      	itt	gt
    4ada:	f04f 33ff 	movgt.w	r3, #4294967295	; 0xffffffff
    4ade:	603b      	strgt	r3, [r7, #0]
        last_line_start = hint->line_start;
    4ae0:	683c      	ldr	r4, [r7, #0]
    if(hint && last_line_start >= 0) {
    4ae2:	2c00      	cmp	r4, #0
    4ae4:	f2c0 81ee 	blt.w	4ec4 <lv_draw_label+0x47c>
        pos.y += hint->y;
    4ae8:	f8bd 2052 	ldrh.w	r2, [sp, #82]	; 0x52
    4aec:	687b      	ldr	r3, [r7, #4]
    4aee:	4413      	add	r3, r2
    4af0:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
    uint32_t line_end = line_start + lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
    4af4:	9836      	ldr	r0, [sp, #216]	; 0xd8
    4af6:	f8cd b000 	str.w	fp, [sp]
    4afa:	9b08      	ldr	r3, [sp, #32]
    4afc:	f9b5 2038 	ldrsh.w	r2, [r5, #56]	; 0x38
    4b00:	9904      	ldr	r1, [sp, #16]
    4b02:	4420      	add	r0, r4
    4b04:	f001 f936 	bl	5d74 <lv_txt_get_next_line>
    4b08:	eb00 0804 	add.w	r8, r0, r4
    while(pos.y + line_height < mask->y1) {
    4b0c:	9a07      	ldr	r2, [sp, #28]
    4b0e:	f9bd 3052 	ldrsh.w	r3, [sp, #82]	; 0x52
    4b12:	4413      	add	r3, r2
    4b14:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    4b16:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
    4b1a:	4293      	cmp	r3, r2
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
    4b1c:	9b36      	ldr	r3, [sp, #216]	; 0xd8
    while(pos.y + line_height < mask->y1) {
    4b1e:	db61      	blt.n	4be4 <lv_draw_label+0x19c>
    if(flag & LV_TXT_FLAG_CENTER) {
    4b20:	1918      	adds	r0, r3, r4
    4b22:	f01b 0304 	ands.w	r3, fp, #4
    4b26:	9312      	str	r3, [sp, #72]	; 0x48
    4b28:	f000 8084 	beq.w	4c34 <lv_draw_label+0x1ec>
        line_width = lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
    4b2c:	eba8 0104 	sub.w	r1, r8, r4
    4b30:	f9b5 3038 	ldrsh.w	r3, [r5, #56]	; 0x38
    4b34:	9a04      	ldr	r2, [sp, #16]
    4b36:	f8cd b000 	str.w	fp, [sp]
    4b3a:	b289      	uxth	r1, r1
    4b3c:	f001 f8ca 	bl	5cd4 <lv_txt_get_width>
    4b40:	88b3      	ldrh	r3, [r6, #4]
    4b42:	8832      	ldrh	r2, [r6, #0]
    4b44:	3301      	adds	r3, #1
    4b46:	1a9b      	subs	r3, r3, r2
        pos.x += (lv_area_get_width(coords) - line_width) / 2;
    4b48:	b21b      	sxth	r3, r3
    4b4a:	1a18      	subs	r0, r3, r0
    4b4c:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    4b50:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
    4b54:	eb03 0060 	add.w	r0, r3, r0, asr #1
        pos.x += lv_area_get_width(coords) - line_width;
    4b58:	f8ad 0050 	strh.w	r0, [sp, #80]	; 0x50
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->text.opa : (uint16_t)((uint16_t)style->text.opa * opa_scale) >> 8;
    4b5c:	f895 303c 	ldrb.w	r3, [r5, #60]	; 0x3c
    4b60:	9309      	str	r3, [sp, #36]	; 0x24
    4b62:	9b05      	ldr	r3, [sp, #20]
    4b64:	2bff      	cmp	r3, #255	; 0xff
    4b66:	d004      	beq.n	4b72 <lv_draw_label+0x12a>
    4b68:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4b6a:	9a05      	ldr	r2, [sp, #20]
    4b6c:	4353      	muls	r3, r2
    4b6e:	0a1b      	lsrs	r3, r3, #8
    4b70:	9309      	str	r3, [sp, #36]	; 0x24
    if(sel) {
    4b72:	9b39      	ldr	r3, [sp, #228]	; 0xe4
    4b74:	2b00      	cmp	r3, #0
    4b76:	d073      	beq.n	4c60 <lv_draw_label+0x218>
        sel_start = sel->start;
    4b78:	881b      	ldrh	r3, [r3, #0]
    4b7a:	9306      	str	r3, [sp, #24]
        sel_end = sel->end;
    4b7c:	9b39      	ldr	r3, [sp, #228]	; 0xe4
    4b7e:	885b      	ldrh	r3, [r3, #2]
    4b80:	9305      	str	r3, [sp, #20]
        if(sel_start > sel_end) {
    4b82:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    4b86:	4293      	cmp	r3, r2
    4b88:	d901      	bls.n	4b8e <lv_draw_label+0x146>
    4b8a:	e9cd 3205 	strd	r3, r2, [sp, #20]
    lv_style_copy(&sel_style, &lv_style_plain_color);
    4b8e:	4999      	ldr	r1, [pc, #612]	; (4df4 <lv_draw_label+0x3ac>)
    4b90:	a818      	add	r0, sp, #96	; 0x60
    4b92:	f005 f9a4 	bl	9ede <lv_style_copy>
    sel_style.body.main_color = sel_style.body.grad_color = style->text.sel_color;
    4b96:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    4b98:	e9cd 3319 	strd	r3, r3, [sp, #100]	; 0x64
    uint16_t par_start = 0;
    4b9c:	2300      	movs	r3, #0
    4b9e:	930d      	str	r3, [sp, #52]	; 0x34
    4ba0:	f00b 0301 	and.w	r3, fp, #1
    4ba4:	9311      	str	r3, [sp, #68]	; 0x44
    while(txt[line_start] != '\0') {
    4ba6:	9b36      	ldr	r3, [sp, #216]	; 0xd8
    4ba8:	4423      	add	r3, r4
    4baa:	930c      	str	r3, [sp, #48]	; 0x30
    4bac:	9b36      	ldr	r3, [sp, #216]	; 0xd8
    4bae:	5d1b      	ldrb	r3, [r3, r4]
    4bb0:	2b00      	cmp	r3, #0
    4bb2:	d15a      	bne.n	4c6a <lv_draw_label+0x222>
}
    4bb4:	b02d      	add	sp, #180	; 0xb4
    4bb6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        lv_txt_get_size(&p, txt, style->text.font, style->text.letter_space, style->text.line_space, LV_COORD_MAX,
    4bba:	f647 4318 	movw	r3, #31768	; 0x7c18
    4bbe:	f8cd b008 	str.w	fp, [sp, #8]
    4bc2:	9301      	str	r3, [sp, #4]
    4bc4:	f9b2 303a 	ldrsh.w	r3, [r2, #58]	; 0x3a
    4bc8:	9300      	str	r3, [sp, #0]
    4bca:	f9b2 3038 	ldrsh.w	r3, [r2, #56]	; 0x38
    4bce:	9936      	ldr	r1, [sp, #216]	; 0xd8
    4bd0:	9a04      	ldr	r2, [sp, #16]
    4bd2:	a818      	add	r0, sp, #96	; 0x60
    4bd4:	f006 fd6f 	bl	b6b6 <lv_txt_get_size>
        w = p.x;
    4bd8:	f9bd 3060 	ldrsh.w	r3, [sp, #96]	; 0x60
    4bdc:	e74e      	b.n	4a7c <lv_draw_label+0x34>
    lv_coord_t x_ofs = 0;
    4bde:	9b38      	ldr	r3, [sp, #224]	; 0xe0
    4be0:	930e      	str	r3, [sp, #56]	; 0x38
    4be2:	e76c      	b.n	4abe <lv_draw_label+0x76>
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
    4be4:	eb03 0908 	add.w	r9, r3, r8
    4be8:	f9b5 2038 	ldrsh.w	r2, [r5, #56]	; 0x38
    4bec:	9b08      	ldr	r3, [sp, #32]
    4bee:	f8cd b000 	str.w	fp, [sp]
    4bf2:	9904      	ldr	r1, [sp, #16]
    4bf4:	4648      	mov	r0, r9
    4bf6:	f001 f8bd 	bl	5d74 <lv_txt_get_next_line>
        pos.y += line_height;
    4bfa:	f8bd 3052 	ldrh.w	r3, [sp, #82]	; 0x52
    4bfe:	9a07      	ldr	r2, [sp, #28]
    4c00:	4413      	add	r3, r2
    4c02:	b21b      	sxth	r3, r3
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
    4c04:	4440      	add	r0, r8
        pos.y += line_height;
    4c06:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
        if(hint && pos.y >= -LV_LABEL_HINT_UPDATE_TH && hint->line_start < 0) {
    4c0a:	b167      	cbz	r7, 4c26 <lv_draw_label+0x1de>
    4c0c:	f513 6f80 	cmn.w	r3, #1024	; 0x400
    4c10:	db09      	blt.n	4c26 <lv_draw_label+0x1de>
    4c12:	683a      	ldr	r2, [r7, #0]
    4c14:	2a00      	cmp	r2, #0
            hint->y          = pos.y - coords->y1;
    4c16:	bfbf      	itttt	lt
    4c18:	f9b6 2002 	ldrshlt.w	r2, [r6, #2]
            hint->line_start = line_start;
    4c1c:	f8c7 8000 	strlt.w	r8, [r7]
            hint->y          = pos.y - coords->y1;
    4c20:	1a9b      	sublt	r3, r3, r2
            hint->coord_y    = coords->y1;
    4c22:	e9c7 3201 	strdlt	r3, r2, [r7, #4]
        if(txt[line_start] == '\0') return;
    4c26:	f899 3000 	ldrb.w	r3, [r9]
    4c2a:	4644      	mov	r4, r8
    4c2c:	2b00      	cmp	r3, #0
    4c2e:	d0c1      	beq.n	4bb4 <lv_draw_label+0x16c>
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
    4c30:	4680      	mov	r8, r0
    4c32:	e76b      	b.n	4b0c <lv_draw_label+0xc4>
    else if(flag & LV_TXT_FLAG_RIGHT) {
    4c34:	f01b 0f08 	tst.w	fp, #8
    4c38:	d090      	beq.n	4b5c <lv_draw_label+0x114>
        line_width = lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
    4c3a:	eba8 0104 	sub.w	r1, r8, r4
    4c3e:	f9b5 3038 	ldrsh.w	r3, [r5, #56]	; 0x38
    4c42:	9a04      	ldr	r2, [sp, #16]
    4c44:	f8cd b000 	str.w	fp, [sp]
    4c48:	b289      	uxth	r1, r1
    4c4a:	f001 f843 	bl	5cd4 <lv_txt_get_width>
        pos.x += lv_area_get_width(coords) - line_width;
    4c4e:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    4c52:	88b2      	ldrh	r2, [r6, #4]
    4c54:	3301      	adds	r3, #1
    4c56:	4413      	add	r3, r2
    4c58:	8832      	ldrh	r2, [r6, #0]
    4c5a:	1a9b      	subs	r3, r3, r2
    4c5c:	1a18      	subs	r0, r3, r0
    4c5e:	e77b      	b.n	4b58 <lv_draw_label+0x110>
    uint16_t sel_end = 0xFFFF;
    4c60:	f64f 73ff 	movw	r3, #65535	; 0xffff
    uint16_t sel_start = 0xFFFF;
    4c64:	e9cd 3305 	strd	r3, r3, [sp, #20]
    4c68:	e791      	b.n	4b8e <lv_draw_label+0x146>
        if(offset != NULL) {
    4c6a:	9b38      	ldr	r3, [sp, #224]	; 0xe0
    4c6c:	b12b      	cbz	r3, 4c7a <lv_draw_label+0x232>
            pos.x += x_ofs;
    4c6e:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    4c72:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    4c74:	4413      	add	r3, r2
    4c76:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
        i         = 0;
    4c7a:	2700      	movs	r7, #0
    4c7c:	9715      	str	r7, [sp, #84]	; 0x54
        while(i < line_end - line_start) {
    4c7e:	9915      	ldr	r1, [sp, #84]	; 0x54
    4c80:	eba8 0304 	sub.w	r3, r8, r4
    4c84:	428b      	cmp	r3, r1
    4c86:	d83b      	bhi.n	4d00 <lv_draw_label+0x2b8>
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
    4c88:	9b36      	ldr	r3, [sp, #216]	; 0xd8
    4c8a:	9904      	ldr	r1, [sp, #16]
    4c8c:	f8cd b000 	str.w	fp, [sp]
    4c90:	eb03 0408 	add.w	r4, r3, r8
    4c94:	f9b5 2038 	ldrsh.w	r2, [r5, #56]	; 0x38
    4c98:	9b08      	ldr	r3, [sp, #32]
    4c9a:	4620      	mov	r0, r4
    4c9c:	f001 f86a 	bl	5d74 <lv_txt_get_next_line>
        pos.x = coords->x1;
    4ca0:	8833      	ldrh	r3, [r6, #0]
    4ca2:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
        if(flag & LV_TXT_FLAG_CENTER) {
    4ca6:	9b12      	ldr	r3, [sp, #72]	; 0x48
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
    4ca8:	4601      	mov	r1, r0
    4caa:	eb00 0708 	add.w	r7, r0, r8
        if(flag & LV_TXT_FLAG_CENTER) {
    4cae:	2b00      	cmp	r3, #0
    4cb0:	f000 80ef 	beq.w	4e92 <lv_draw_label+0x44a>
                    lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
    4cb4:	f9b5 3038 	ldrsh.w	r3, [r5, #56]	; 0x38
    4cb8:	9a04      	ldr	r2, [sp, #16]
    4cba:	f8cd b000 	str.w	fp, [sp]
    4cbe:	4620      	mov	r0, r4
    4cc0:	f001 f808 	bl	5cd4 <lv_txt_get_width>
    4cc4:	88b3      	ldrh	r3, [r6, #4]
    4cc6:	8832      	ldrh	r2, [r6, #0]
    4cc8:	3301      	adds	r3, #1
    4cca:	1a9b      	subs	r3, r3, r2
            pos.x += (lv_area_get_width(coords) - line_width) / 2;
    4ccc:	b21b      	sxth	r3, r3
    4cce:	1a18      	subs	r0, r3, r0
    4cd0:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    4cd4:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
    4cd8:	eb03 0060 	add.w	r0, r3, r0, asr #1
            pos.x += lv_area_get_width(coords) - line_width;
    4cdc:	f8ad 0050 	strh.w	r0, [sp, #80]	; 0x50
        pos.y += line_height;
    4ce0:	f8bd 3052 	ldrh.w	r3, [sp, #82]	; 0x52
    4ce4:	9a07      	ldr	r2, [sp, #28]
    4ce6:	4413      	add	r3, r2
        if(pos.y > mask->y2) return;
    4ce8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    4cea:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
        pos.y += line_height;
    4cee:	b21b      	sxth	r3, r3
        if(pos.y > mask->y2) return;
    4cf0:	429a      	cmp	r2, r3
        pos.y += line_height;
    4cf2:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
        line_start = line_end;
    4cf6:	4644      	mov	r4, r8
        if(pos.y > mask->y2) return;
    4cf8:	f6ff af5c 	blt.w	4bb4 <lv_draw_label+0x16c>
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
    4cfc:	46b8      	mov	r8, r7
    4cfe:	e752      	b.n	4ba6 <lv_draw_label+0x15e>
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
    4d00:	9a06      	ldr	r2, [sp, #24]
    4d02:	f64f 73ff 	movw	r3, #65535	; 0xffff
    4d06:	429a      	cmp	r2, r3
    4d08:	d026      	beq.n	4d58 <lv_draw_label+0x310>
    4d0a:	9a05      	ldr	r2, [sp, #20]
    4d0c:	429a      	cmp	r2, r3
    4d0e:	d023      	beq.n	4d58 <lv_draw_label+0x310>
                logical_char_pos = lv_txt_encoded_get_char_id(txt, line_start + i);
    4d10:	4b39      	ldr	r3, [pc, #228]	; (4df8 <lv_draw_label+0x3b0>)
    4d12:	9836      	ldr	r0, [sp, #216]	; 0xd8
    4d14:	681b      	ldr	r3, [r3, #0]
    4d16:	4421      	add	r1, r4
    4d18:	4798      	blx	r3
    4d1a:	b283      	uxth	r3, r0
            letter      = lv_txt_encoded_next(bidi_txt, &i);
    4d1c:	f8df 90dc 	ldr.w	r9, [pc, #220]	; 4dfc <lv_draw_label+0x3b4>
    4d20:	980c      	ldr	r0, [sp, #48]	; 0x30
    4d22:	f8d9 2000 	ldr.w	r2, [r9]
    4d26:	9310      	str	r3, [sp, #64]	; 0x40
    4d28:	a915      	add	r1, sp, #84	; 0x54
    4d2a:	4790      	blx	r2
            letter_next = lv_txt_encoded_next(&bidi_txt[i], NULL);
    4d2c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
            letter      = lv_txt_encoded_next(bidi_txt, &i);
    4d2e:	900a      	str	r0, [sp, #40]	; 0x28
            letter_next = lv_txt_encoded_next(&bidi_txt[i], NULL);
    4d30:	9815      	ldr	r0, [sp, #84]	; 0x54
    4d32:	f8d9 2000 	ldr.w	r2, [r9]
    4d36:	2100      	movs	r1, #0
    4d38:	4418      	add	r0, r3
    4d3a:	4790      	blx	r2
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    4d3c:	e9dd 3110 	ldrd	r3, r1, [sp, #64]	; 0x40
            letter_next = lv_txt_encoded_next(&bidi_txt[i], NULL);
    4d40:	4602      	mov	r2, r0
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    4d42:	2900      	cmp	r1, #0
    4d44:	d051      	beq.n	4dea <lv_draw_label+0x3a2>
                if(letter == (uint32_t)LV_TXT_COLOR_CMD[0]) {
    4d46:	990a      	ldr	r1, [sp, #40]	; 0x28
    4d48:	2923      	cmp	r1, #35	; 0x23
    4d4a:	d10d      	bne.n	4d68 <lv_draw_label+0x320>
                    if(cmd_state == CMD_STATE_WAIT) { /*Start char*/
    4d4c:	b937      	cbnz	r7, 4d5c <lv_draw_label+0x314>
                        par_start = i;
    4d4e:	f8bd 3054 	ldrh.w	r3, [sp, #84]	; 0x54
    4d52:	930d      	str	r3, [sp, #52]	; 0x34
                        cmd_state = CMD_STATE_PAR;
    4d54:	9f11      	ldr	r7, [sp, #68]	; 0x44
                        continue;
    4d56:	e792      	b.n	4c7e <lv_draw_label+0x236>
            uint16_t logical_char_pos = 0;
    4d58:	2300      	movs	r3, #0
    4d5a:	e7df      	b.n	4d1c <lv_draw_label+0x2d4>
                    } else if(cmd_state == CMD_STATE_PAR) { /*Other start char in parameter escaped cmd. char */
    4d5c:	2f01      	cmp	r7, #1
    4d5e:	d04f      	beq.n	4e00 <lv_draw_label+0x3b8>
                    } else if(cmd_state == CMD_STATE_IN) { /*Command end */
    4d60:	2f02      	cmp	r7, #2
    4d62:	d14e      	bne.n	4e02 <lv_draw_label+0x3ba>
                        cmd_state = CMD_STATE_WAIT;
    4d64:	2700      	movs	r7, #0
    4d66:	e78a      	b.n	4c7e <lv_draw_label+0x236>
                if(cmd_state == CMD_STATE_PAR) {
    4d68:	2f01      	cmp	r7, #1
    4d6a:	d13e      	bne.n	4dea <lv_draw_label+0x3a2>
                    if(letter == ' ') {
    4d6c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4d6e:	2b20      	cmp	r3, #32
    4d70:	d185      	bne.n	4c7e <lv_draw_label+0x236>
                        if(i - par_start == LABEL_RECOLOR_PAR_LENGTH + 1) {
    4d72:	9b15      	ldr	r3, [sp, #84]	; 0x54
    4d74:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    4d76:	1a9b      	subs	r3, r3, r2
    4d78:	2b07      	cmp	r3, #7
    4d7a:	d133      	bne.n	4de4 <lv_draw_label+0x39c>
                            memcpy(buf, &bidi_txt[par_start], LABEL_RECOLOR_PAR_LENGTH);
    4d7c:	e9dd 310c 	ldrd	r3, r1, [sp, #48]	; 0x30
    4d80:	2206      	movs	r2, #6
    4d82:	1859      	adds	r1, r3, r1
    4d84:	a816      	add	r0, sp, #88	; 0x58
    4d86:	f003 fdb3 	bl	88f0 <memcpy>
                            r       = (hex_char_to_num(buf[0]) << 4) + hex_char_to_num(buf[1]);
    4d8a:	f89d 0058 	ldrb.w	r0, [sp, #88]	; 0x58
    4d8e:	f7ff fe47 	bl	4a20 <hex_char_to_num>
    4d92:	4601      	mov	r1, r0
    4d94:	f89d 0059 	ldrb.w	r0, [sp, #89]	; 0x59
    4d98:	f7ff fe42 	bl	4a20 <hex_char_to_num>
    4d9c:	eb00 1101 	add.w	r1, r0, r1, lsl #4
                            g       = (hex_char_to_num(buf[2]) << 4) + hex_char_to_num(buf[3]);
    4da0:	f89d 005a 	ldrb.w	r0, [sp, #90]	; 0x5a
    4da4:	f7ff fe3c 	bl	4a20 <hex_char_to_num>
    4da8:	4607      	mov	r7, r0
    4daa:	f89d 005b 	ldrb.w	r0, [sp, #91]	; 0x5b
    4dae:	f7ff fe37 	bl	4a20 <hex_char_to_num>
    4db2:	eb00 1707 	add.w	r7, r0, r7, lsl #4
                            b       = (hex_char_to_num(buf[4]) << 4) + hex_char_to_num(buf[5]);
    4db6:	f89d 005c 	ldrb.w	r0, [sp, #92]	; 0x5c
    4dba:	f7ff fe31 	bl	4a20 <hex_char_to_num>
    4dbe:	4681      	mov	r9, r0
    4dc0:	f89d 005d 	ldrb.w	r0, [sp, #93]	; 0x5d
    4dc4:	f7ff fe2c 	bl	4a20 <hex_char_to_num>
    4dc8:	eb00 1009 	add.w	r0, r0, r9, lsl #4
    4dcc:	f360 0a07 	bfi	sl, r0, #0, #8
    4dd0:	f367 2a0f 	bfi	sl, r7, #8, #8
    4dd4:	f361 4a17 	bfi	sl, r1, #16, #8
    4dd8:	f04a 4a7f 	orr.w	sl, sl, #4278190080	; 0xff000000
    4ddc:	f8cd a03c 	str.w	sl, [sp, #60]	; 0x3c
                        cmd_state = CMD_STATE_IN; /*After the parameter the text is in the command*/
    4de0:	2702      	movs	r7, #2
    4de2:	e74c      	b.n	4c7e <lv_draw_label+0x236>
                            recolor.full = style->text.color.full;
    4de4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    4de6:	930f      	str	r3, [sp, #60]	; 0x3c
    4de8:	e7fa      	b.n	4de0 <lv_draw_label+0x398>
            if(cmd_state == CMD_STATE_IN) color = recolor;
    4dea:	2f02      	cmp	r7, #2
    4dec:	d109      	bne.n	4e02 <lv_draw_label+0x3ba>
    4dee:	990f      	ldr	r1, [sp, #60]	; 0x3c
    4df0:	e008      	b.n	4e04 <lv_draw_label+0x3bc>
    4df2:	bf00      	nop
    4df4:	200003e8 	.word	0x200003e8
    4df8:	2000a128 	.word	0x2000a128
    4dfc:	2000a12c 	.word	0x2000a12c
                        cmd_state = CMD_STATE_WAIT;
    4e00:	2700      	movs	r7, #0
            lv_color_t color = style->text.color;
    4e02:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
            if(cmd_state == CMD_STATE_IN) color = recolor;
    4e04:	9110      	str	r1, [sp, #64]	; 0x40
            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
    4e06:	9804      	ldr	r0, [sp, #16]
    4e08:	990a      	ldr	r1, [sp, #40]	; 0x28
    4e0a:	9313      	str	r3, [sp, #76]	; 0x4c
    4e0c:	f006 fed0 	bl	bbb0 <lv_font_get_glyph_width>
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
    4e10:	9b06      	ldr	r3, [sp, #24]
    4e12:	f64f 72ff 	movw	r2, #65535	; 0xffff
    4e16:	4293      	cmp	r3, r2
            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
    4e18:	fa0f f980 	sxth.w	r9, r0
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
    4e1c:	d023      	beq.n	4e66 <lv_draw_label+0x41e>
    4e1e:	9b05      	ldr	r3, [sp, #20]
    4e20:	4293      	cmp	r3, r2
    4e22:	d020      	beq.n	4e66 <lv_draw_label+0x41e>
                if(logical_char_pos >= sel_start && logical_char_pos < sel_end) {
    4e24:	9b06      	ldr	r3, [sp, #24]
    4e26:	461a      	mov	r2, r3
    4e28:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4e2a:	429a      	cmp	r2, r3
    4e2c:	d81b      	bhi.n	4e66 <lv_draw_label+0x41e>
    4e2e:	9a05      	ldr	r2, [sp, #20]
    4e30:	429a      	cmp	r2, r3
    4e32:	d918      	bls.n	4e66 <lv_draw_label+0x41e>
                    sel_coords.x1 = pos.x;
    4e34:	f9bd 3050 	ldrsh.w	r3, [sp, #80]	; 0x50
                    sel_coords.x2 = pos.x + letter_w + style->text.letter_space - 1;
    4e38:	8f29      	ldrh	r1, [r5, #56]	; 0x38
                    sel_coords.x1 = pos.x;
    4e3a:	f8ad 3058 	strh.w	r3, [sp, #88]	; 0x58
                    sel_coords.x2 = pos.x + letter_w + style->text.letter_space - 1;
    4e3e:	3b01      	subs	r3, #1
    4e40:	440b      	add	r3, r1
                    sel_coords.y1 = pos.y;
    4e42:	f9bd 2052 	ldrsh.w	r2, [sp, #82]	; 0x52
    4e46:	f8ad 205a 	strh.w	r2, [sp, #90]	; 0x5a
                    sel_coords.x2 = pos.x + letter_w + style->text.letter_space - 1;
    4e4a:	444b      	add	r3, r9
    4e4c:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
                    sel_coords.y2 = pos.y + line_height - 1;
    4e50:	9b07      	ldr	r3, [sp, #28]
                    lv_draw_rect(&sel_coords, mask, &sel_style, opa);
    4e52:	990b      	ldr	r1, [sp, #44]	; 0x2c
                    sel_coords.y2 = pos.y + line_height - 1;
    4e54:	3a01      	subs	r2, #1
    4e56:	441a      	add	r2, r3
    4e58:	f8ad 205e 	strh.w	r2, [sp, #94]	; 0x5e
                    lv_draw_rect(&sel_coords, mask, &sel_style, opa);
    4e5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4e5e:	aa18      	add	r2, sp, #96	; 0x60
    4e60:	a816      	add	r0, sp, #88	; 0x58
    4e62:	f005 fada 	bl	a41a <lv_draw_rect>
            lv_draw_letter(&pos, mask, font, letter, color, opa);
    4e66:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4e68:	9301      	str	r3, [sp, #4]
    4e6a:	9b10      	ldr	r3, [sp, #64]	; 0x40
    4e6c:	9300      	str	r3, [sp, #0]
    4e6e:	9a04      	ldr	r2, [sp, #16]
    4e70:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4e72:	990b      	ldr	r1, [sp, #44]	; 0x2c
    4e74:	a814      	add	r0, sp, #80	; 0x50
    4e76:	f7ff fb67 	bl	4548 <lv_draw_letter>
            if(letter_w > 0) {
    4e7a:	f1b9 0f00 	cmp.w	r9, #0
    4e7e:	f77f aefe 	ble.w	4c7e <lv_draw_label+0x236>
                pos.x += letter_w + style->text.letter_space;
    4e82:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    4e86:	8f2a      	ldrh	r2, [r5, #56]	; 0x38
    4e88:	4413      	add	r3, r2
    4e8a:	4499      	add	r9, r3
    4e8c:	f8ad 9050 	strh.w	r9, [sp, #80]	; 0x50
    4e90:	e6f5      	b.n	4c7e <lv_draw_label+0x236>
        else if(flag & LV_TXT_FLAG_RIGHT) {
    4e92:	f01b 0f08 	tst.w	fp, #8
    4e96:	f43f af23 	beq.w	4ce0 <lv_draw_label+0x298>
                    lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
    4e9a:	f9b5 3038 	ldrsh.w	r3, [r5, #56]	; 0x38
    4e9e:	9a04      	ldr	r2, [sp, #16]
    4ea0:	f8cd b000 	str.w	fp, [sp]
    4ea4:	4620      	mov	r0, r4
    4ea6:	f000 ff15 	bl	5cd4 <lv_txt_get_width>
            pos.x += lv_area_get_width(coords) - line_width;
    4eaa:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    4eae:	88b2      	ldrh	r2, [r6, #4]
    4eb0:	3301      	adds	r3, #1
    4eb2:	4413      	add	r3, r2
    4eb4:	8832      	ldrh	r2, [r6, #0]
    4eb6:	1a9b      	subs	r3, r3, r2
    4eb8:	1a18      	subs	r0, r3, r0
    4eba:	e70f      	b.n	4cdc <lv_draw_label+0x294>
    if(hint && y_ofs == 0 && coords->y1 < 0) {
    4ebc:	2f00      	cmp	r7, #0
    4ebe:	f47f ae8e 	bne.w	4bde <lv_draw_label+0x196>
    lv_coord_t x_ofs = 0;
    4ec2:	970e      	str	r7, [sp, #56]	; 0x38
    uint32_t line_start     = 0;
    4ec4:	2400      	movs	r4, #0
    4ec6:	e615      	b.n	4af4 <lv_draw_label+0xac>

00004ec8 <lv_img_color_format_get_px_size>:
 */
uint8_t lv_img_color_format_get_px_size(lv_img_cf_t cf)
{
    uint8_t px_size = 0;

    switch(cf) {
    4ec8:	3804      	subs	r0, #4
    4eca:	b2c0      	uxtb	r0, r0
    4ecc:	280a      	cmp	r0, #10
    4ece:	bf9a      	itte	ls
    4ed0:	4b01      	ldrls	r3, [pc, #4]	; (4ed8 <lv_img_color_format_get_px_size+0x10>)
    4ed2:	5c18      	ldrbls	r0, [r3, r0]
{
    4ed4:	2000      	movhi	r0, #0
        case LV_IMG_CF_ALPHA_8BIT: px_size = 8; break;
        default: px_size = 0; break;
    }

    return px_size;
}
    4ed6:	4770      	bx	lr
    4ed8:	000457eb 	.word	0x000457eb

00004edc <lv_draw_img>:
{
    4edc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4ee0:	b091      	sub	sp, #68	; 0x44
    4ee2:	4604      	mov	r4, r0
    4ee4:	460e      	mov	r6, r1
    4ee6:	4698      	mov	r8, r3
    4ee8:	f89d 7068 	ldrb.w	r7, [sp, #104]	; 0x68
    if(src == NULL) {
    4eec:	4615      	mov	r5, r2
    4eee:	b992      	cbnz	r2, 4f16 <lv_draw_img+0x3a>
        LV_LOG_WARN("Image draw: src is NULL");
    4ef0:	4b69      	ldr	r3, [pc, #420]	; (5098 <lv_draw_img+0x1bc>)
    4ef2:	496a      	ldr	r1, [pc, #424]	; (509c <lv_draw_img+0x1c0>)
    4ef4:	2234      	movs	r2, #52	; 0x34
    4ef6:	2002      	movs	r0, #2
    4ef8:	f001 f838 	bl	5f6c <lv_log_add>
        lv_draw_rect(coords, mask, &lv_style_plain, LV_OPA_COVER);
    4efc:	23ff      	movs	r3, #255	; 0xff
    4efe:	4a68      	ldr	r2, [pc, #416]	; (50a0 <lv_draw_img+0x1c4>)
    4f00:	4631      	mov	r1, r6
    4f02:	4620      	mov	r0, r4
    4f04:	f005 fa89 	bl	a41a <lv_draw_rect>
        lv_draw_label(coords, mask, &lv_style_plain, LV_OPA_COVER, "No\ndata", LV_TXT_FLAG_NONE, NULL, NULL, NULL, LV_BIDI_DIR_LTR);
    4f08:	e9cd 5504 	strd	r5, r5, [sp, #16]
    4f0c:	e9cd 5502 	strd	r5, r5, [sp, #8]
    4f10:	9501      	str	r5, [sp, #4]
        lv_draw_label(coords, mask, &lv_style_plain, LV_OPA_COVER, "No\ndata", LV_TXT_FLAG_NONE, NULL,  NULL, NULL, LV_BIDI_DIR_LTR);
    4f12:	4b64      	ldr	r3, [pc, #400]	; (50a4 <lv_draw_img+0x1c8>)
    4f14:	e02b      	b.n	4f6e <lv_draw_img+0x92>
                                 const lv_style_t * style, lv_opa_t opa_scale)
{

    lv_area_t mask_com; /*Common area of mask and coords*/
    bool union_ok;
    union_ok = lv_area_intersect(&mask_com, mask, coords);
    4f16:	4602      	mov	r2, r0
    4f18:	a80c      	add	r0, sp, #48	; 0x30
    4f1a:	f006 f9c8 	bl	b2ae <lv_area_intersect>
    if(union_ok == false) {
    4f1e:	2800      	cmp	r0, #0
    4f20:	d048      	beq.n	4fb4 <lv_draw_img+0xd8>
        return LV_RES_OK; /*Out of mask. There is nothing to draw so the image is drawn
                             successfully.*/
    }

    lv_opa_t opa =
    4f22:	f898 9045 	ldrb.w	r9, [r8, #69]	; 0x45
    4f26:	2fff      	cmp	r7, #255	; 0xff
    4f28:	bf18      	it	ne
    4f2a:	fb09 f907 	mulne.w	r9, r9, r7
        opa_scale == LV_OPA_COVER ? style->image.opa : (uint16_t)((uint16_t)style->image.opa * opa_scale) >> 8;

    lv_img_cache_entry_t * cdsc = lv_img_cache_open(src, style);
    4f2e:	4641      	mov	r1, r8
    4f30:	4628      	mov	r0, r5
    lv_opa_t opa =
    4f32:	bf18      	it	ne
    4f34:	ea4f 2919 	movne.w	r9, r9, lsr #8
    lv_img_cache_entry_t * cdsc = lv_img_cache_open(src, style);
    4f38:	f000 fb7e 	bl	5638 <lv_img_cache_open>

    if(cdsc == NULL) return LV_RES_INV;
    4f3c:	4607      	mov	r7, r0
    4f3e:	2800      	cmp	r0, #0
    4f40:	d07a      	beq.n	5038 <lv_draw_img+0x15c>

    bool chroma_keyed = lv_img_color_format_is_chroma_keyed(cdsc->dec_dsc.header.cf);
    bool alpha_byte   = lv_img_color_format_has_alpha(cdsc->dec_dsc.header.cf);

    if(cdsc->dec_dsc.error_msg != NULL) {
    4f42:	69c3      	ldr	r3, [r0, #28]
    4f44:	b1db      	cbz	r3, 4f7e <lv_draw_img+0xa2>
        LV_LOG_WARN("Image draw error");
    4f46:	4b58      	ldr	r3, [pc, #352]	; (50a8 <lv_draw_img+0x1cc>)
    4f48:	4954      	ldr	r1, [pc, #336]	; (509c <lv_draw_img+0x1c0>)
    4f4a:	f240 2233 	movw	r2, #563	; 0x233
    4f4e:	2002      	movs	r0, #2
    4f50:	f001 f80c 	bl	5f6c <lv_log_add>
        lv_draw_rect(coords, mask, &lv_style_plain, LV_OPA_COVER);
    4f54:	23ff      	movs	r3, #255	; 0xff
    4f56:	4a52      	ldr	r2, [pc, #328]	; (50a0 <lv_draw_img+0x1c4>)
    4f58:	4631      	mov	r1, r6
    4f5a:	4620      	mov	r0, r4
    4f5c:	f005 fa5d 	bl	a41a <lv_draw_rect>
        lv_draw_label(coords, mask, &lv_style_plain, LV_OPA_COVER, cdsc->dec_dsc.error_msg, LV_TXT_FLAG_NONE, NULL, NULL, NULL, LV_BIDI_DIR_LTR);
    4f60:	2300      	movs	r3, #0
    4f62:	e9cd 3304 	strd	r3, r3, [sp, #16]
    4f66:	e9cd 3302 	strd	r3, r3, [sp, #8]
    4f6a:	9301      	str	r3, [sp, #4]
    4f6c:	69fb      	ldr	r3, [r7, #28]
        lv_draw_label(coords, mask, &lv_style_plain, LV_OPA_COVER, "No\ndata", LV_TXT_FLAG_NONE, NULL,  NULL, NULL, LV_BIDI_DIR_LTR);
    4f6e:	9300      	str	r3, [sp, #0]
    4f70:	4a4b      	ldr	r2, [pc, #300]	; (50a0 <lv_draw_img+0x1c4>)
    4f72:	23ff      	movs	r3, #255	; 0xff
    4f74:	4631      	mov	r1, r6
    4f76:	4620      	mov	r0, r4
    4f78:	f7ff fd66 	bl	4a48 <lv_draw_label>
        return;
    4f7c:	e01a      	b.n	4fb4 <lv_draw_img+0xd8>
    bool chroma_keyed = lv_img_color_format_is_chroma_keyed(cdsc->dec_dsc.header.cf);
    4f7e:	7c02      	ldrb	r2, [r0, #16]
    4f80:	f002 021f 	and.w	r2, r2, #31
    4f84:	4610      	mov	r0, r2
    4f86:	f006 f8b0 	bl	b0ea <lv_img_color_format_is_chroma_keyed>
    4f8a:	9007      	str	r0, [sp, #28]
    bool alpha_byte   = lv_img_color_format_has_alpha(cdsc->dec_dsc.header.cf);
    4f8c:	4610      	mov	r0, r2
    4f8e:	f006 f8b4 	bl	b0fa <lv_img_color_format_has_alpha>
    }
    /* The decoder open could open the image and gave the entire uncompressed image.
     * Just draw it!*/
    else if(cdsc->dec_dsc.img_data) {
    4f92:	697a      	ldr	r2, [r7, #20]
    bool alpha_byte   = lv_img_color_format_has_alpha(cdsc->dec_dsc.header.cf);
    4f94:	9008      	str	r0, [sp, #32]
    else if(cdsc->dec_dsc.img_data) {
    4f96:	b182      	cbz	r2, 4fba <lv_draw_img+0xde>
        lv_draw_map(coords, mask, cdsc->dec_dsc.img_data, opa, chroma_keyed, alpha_byte, style->image.color,
    4f98:	f898 3044 	ldrb.w	r3, [r8, #68]	; 0x44
    4f9c:	9303      	str	r3, [sp, #12]
    4f9e:	f8d8 3040 	ldr.w	r3, [r8, #64]	; 0x40
    4fa2:	9302      	str	r3, [sp, #8]
    4fa4:	9b07      	ldr	r3, [sp, #28]
    4fa6:	9001      	str	r0, [sp, #4]
    4fa8:	9300      	str	r3, [sp, #0]
    4faa:	4631      	mov	r1, r6
    4fac:	464b      	mov	r3, r9
    4fae:	4620      	mov	r0, r4
    4fb0:	f005 f889 	bl	a0c6 <lv_draw_map>
}
    4fb4:	b011      	add	sp, #68	; 0x44
    4fb6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4fba:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
    4fbe:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
    4fc2:	3301      	adds	r3, #1
    4fc4:	1a9b      	subs	r3, r3, r2
    4fc6:	fa0f fa83 	sxth.w	sl, r3
    }
    /* The whole uncompressed image is not available. Try to read it line-by-line*/
    else {
        lv_coord_t width = lv_area_get_width(&mask_com);

        uint8_t  * buf = lv_draw_get_buf(lv_area_get_width(&mask_com) * LV_IMG_PX_SIZE_ALPHA_BYTE);  /*space for the possible alpha byte*/
    4fca:	ea4f 008a 	mov.w	r0, sl, lsl #2
    4fce:	f7ff fcff 	bl	49d0 <lv_draw_get_buf>
    memcpy(dest, src, sizeof(lv_area_t));
    4fd2:	f10d 0b38 	add.w	fp, sp, #56	; 0x38
    4fd6:	2208      	movs	r2, #8
    4fd8:	9009      	str	r0, [sp, #36]	; 0x24
    4fda:	a90c      	add	r1, sp, #48	; 0x30
    4fdc:	4658      	mov	r0, fp
    4fde:	f003 fc87 	bl	88f0 <memcpy>

        lv_area_t line;
        lv_area_copy(&line, &mask_com);
        lv_area_set_height(&line, 1);
    4fe2:	2101      	movs	r1, #1
    4fe4:	4658      	mov	r0, fp
    4fe6:	f006 f94f 	bl	b288 <lv_area_set_height>
        lv_coord_t x = mask_com.x1 - coords->x1;
    4fea:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
    4fee:	8821      	ldrh	r1, [r4, #0]
        lv_coord_t y = mask_com.y1 - coords->y1;
    4ff0:	f9bd 5032 	ldrsh.w	r5, [sp, #50]	; 0x32
        lv_coord_t x = mask_com.x1 - coords->x1;
    4ff4:	1a52      	subs	r2, r2, r1
    4ff6:	b213      	sxth	r3, r2
        lv_coord_t y = mask_com.y1 - coords->y1;
    4ff8:	8862      	ldrh	r2, [r4, #2]
        lv_coord_t x = mask_com.x1 - coords->x1;
    4ffa:	930a      	str	r3, [sp, #40]	; 0x28
        lv_coord_t y = mask_com.y1 - coords->y1;
    4ffc:	1aaa      	subs	r2, r5, r2
    4ffe:	b212      	sxth	r2, r2
        lv_coord_t row;
        lv_res_t read_res;
        for(row = mask_com.y1; row <= mask_com.y2; row++) {
    5000:	1b53      	subs	r3, r2, r5
    5002:	930b      	str	r3, [sp, #44]	; 0x2c
    5004:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5006:	195a      	adds	r2, r3, r5
    5008:	f9bd 3036 	ldrsh.w	r3, [sp, #54]	; 0x36
    500c:	42ab      	cmp	r3, r5
    500e:	b212      	sxth	r2, r2
    5010:	dbd0      	blt.n	4fb4 <lv_draw_img+0xd8>
            read_res = lv_img_decoder_read_line(&cdsc->dec_dsc, x, y, width, buf);
    5012:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5014:	9300      	str	r3, [sp, #0]
    5016:	990a      	ldr	r1, [sp, #40]	; 0x28
    5018:	4653      	mov	r3, sl
    501a:	4638      	mov	r0, r7
    501c:	f006 f898 	bl	b150 <lv_img_decoder_read_line>
            if(read_res != LV_RES_OK) {
    5020:	2801      	cmp	r0, #1
    5022:	d01c      	beq.n	505e <lv_draw_img+0x182>
                lv_img_decoder_close(&cdsc->dec_dsc);
    5024:	4638      	mov	r0, r7
    5026:	f006 f8a3 	bl	b170 <lv_img_decoder_close>
                LV_LOG_WARN("Image draw can't read the line");
    502a:	4b20      	ldr	r3, [pc, #128]	; (50ac <lv_draw_img+0x1d0>)
    502c:	491b      	ldr	r1, [pc, #108]	; (509c <lv_draw_img+0x1c0>)
    502e:	f240 224e 	movw	r2, #590	; 0x24e
    5032:	2002      	movs	r0, #2
    5034:	f000 ff9a 	bl	5f6c <lv_log_add>
        LV_LOG_WARN("Image draw error");
    5038:	4b1b      	ldr	r3, [pc, #108]	; (50a8 <lv_draw_img+0x1cc>)
    503a:	4918      	ldr	r1, [pc, #96]	; (509c <lv_draw_img+0x1c0>)
    503c:	223e      	movs	r2, #62	; 0x3e
    503e:	2002      	movs	r0, #2
    5040:	f000 ff94 	bl	5f6c <lv_log_add>
        lv_draw_rect(coords, mask, &lv_style_plain, LV_OPA_COVER);
    5044:	23ff      	movs	r3, #255	; 0xff
    5046:	4a16      	ldr	r2, [pc, #88]	; (50a0 <lv_draw_img+0x1c4>)
    5048:	4631      	mov	r1, r6
    504a:	4620      	mov	r0, r4
    504c:	f005 f9e5 	bl	a41a <lv_draw_rect>
        lv_draw_label(coords, mask, &lv_style_plain, LV_OPA_COVER, "No\ndata", LV_TXT_FLAG_NONE, NULL,  NULL, NULL, LV_BIDI_DIR_LTR);
    5050:	2300      	movs	r3, #0
    5052:	e9cd 3304 	strd	r3, r3, [sp, #16]
    5056:	e9cd 3302 	strd	r3, r3, [sp, #8]
    505a:	9301      	str	r3, [sp, #4]
    505c:	e759      	b.n	4f12 <lv_draw_img+0x36>
                return LV_RES_INV;
            }
            lv_draw_map(&line, mask, buf, opa, chroma_keyed, alpha_byte, style->image.color, style->image.intense);
    505e:	f898 3044 	ldrb.w	r3, [r8, #68]	; 0x44
    5062:	9303      	str	r3, [sp, #12]
    5064:	f8d8 3040 	ldr.w	r3, [r8, #64]	; 0x40
    5068:	9302      	str	r3, [sp, #8]
    506a:	9b08      	ldr	r3, [sp, #32]
    506c:	9301      	str	r3, [sp, #4]
    506e:	9b07      	ldr	r3, [sp, #28]
    5070:	9300      	str	r3, [sp, #0]
    5072:	9a09      	ldr	r2, [sp, #36]	; 0x24
    5074:	464b      	mov	r3, r9
    5076:	4631      	mov	r1, r6
    5078:	4658      	mov	r0, fp
    507a:	f005 f824 	bl	a0c6 <lv_draw_map>
            line.y1++;
    507e:	f8bd 303a 	ldrh.w	r3, [sp, #58]	; 0x3a
    5082:	3301      	adds	r3, #1
    5084:	f8ad 303a 	strh.w	r3, [sp, #58]	; 0x3a
            line.y2++;
    5088:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
        for(row = mask_com.y1; row <= mask_com.y2; row++) {
    508c:	3501      	adds	r5, #1
            line.y2++;
    508e:	3301      	adds	r3, #1
    5090:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
        for(row = mask_com.y1; row <= mask_com.y2; row++) {
    5094:	b22d      	sxth	r5, r5
    5096:	e7b5      	b.n	5004 <lv_draw_img+0x128>
    5098:	000457f6 	.word	0x000457f6
    509c:	00045877 	.word	0x00045877
    50a0:	20000398 	.word	0x20000398
    50a4:	0004580e 	.word	0x0004580e
    50a8:	00045816 	.word	0x00045816
    50ac:	00045827 	.word	0x00045827

000050b0 <lv_img_decoder_built_in_open>:
 * @param decoder the decoder where this function belongs
 * @param dsc pointer to decoder descriptor. `src`, `style` are already initialized in it.
 * @return LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error.
 */
lv_res_t lv_img_decoder_built_in_open(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)
{
    50b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    /*Open the file if it's a file*/
    if(dsc->src_type == LV_IMG_SRC_FILE) {
    50b4:	7b0a      	ldrb	r2, [r1, #12]
    50b6:	2a01      	cmp	r2, #1
{
    50b8:	460c      	mov	r4, r1
    if(dsc->src_type == LV_IMG_SRC_FILE) {
    50ba:	d108      	bne.n	50ce <lv_img_decoder_built_in_open+0x1e>
        }

        memcpy(user_data->f, &f, sizeof(f));

#else
        LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
    50bc:	4b3b      	ldr	r3, [pc, #236]	; (51ac <lv_img_decoder_built_in_open+0xfc>)
    50be:	f240 1261 	movw	r2, #353	; 0x161
    /*Unknown format. Can't decode it.*/
    else {
        /*Free the potentially allocated memories*/
        lv_img_decoder_built_in_close(decoder, dsc);

        LV_LOG_WARN("Image decoder open: unknown color format")
    50c2:	2002      	movs	r0, #2
    50c4:	493a      	ldr	r1, [pc, #232]	; (51b0 <lv_img_decoder_built_in_open+0x100>)
    50c6:	f000 ff51 	bl	5f6c <lv_log_add>
        return LV_RES_INV;
    50ca:	2000      	movs	r0, #0
    50cc:	e00b      	b.n	50e6 <lv_img_decoder_built_in_open+0x36>
    lv_img_cf_t cf = dsc->header.cf;
    50ce:	7c0b      	ldrb	r3, [r1, #16]
    50d0:	f003 031f 	and.w	r3, r3, #31
    if(cf == LV_IMG_CF_TRUE_COLOR || cf == LV_IMG_CF_TRUE_COLOR_ALPHA || cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
    50d4:	1f1d      	subs	r5, r3, #4
    50d6:	2d02      	cmp	r5, #2
    50d8:	d807      	bhi.n	50ea <lv_img_decoder_built_in_open+0x3a>
        if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
    50da:	2a00      	cmp	r2, #0
    50dc:	d144      	bne.n	5168 <lv_img_decoder_built_in_open+0xb8>
            dsc->img_data = ((lv_img_dsc_t *)dsc->src)->data;
    50de:	684b      	ldr	r3, [r1, #4]
    50e0:	689b      	ldr	r3, [r3, #8]
            dsc->img_data = NULL;
    50e2:	6163      	str	r3, [r4, #20]
            return LV_RES_OK;
    50e4:	2001      	movs	r0, #1
    }
}
    50e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if(cf == LV_IMG_CF_INDEXED_1BIT || cf == LV_IMG_CF_INDEXED_2BIT || cf == LV_IMG_CF_INDEXED_4BIT ||
    50ea:	1fda      	subs	r2, r3, #7
    50ec:	2a03      	cmp	r2, #3
    50ee:	d853      	bhi.n	5198 <lv_img_decoder_built_in_open+0xe8>
        uint8_t px_size       = lv_img_color_format_get_px_size(cf);
    50f0:	4618      	mov	r0, r3
    50f2:	f7ff fee9 	bl	4ec8 <lv_img_color_format_get_px_size>
        if(dsc->user_data == NULL) {
    50f6:	6a23      	ldr	r3, [r4, #32]
        uint32_t palette_size = 1 << px_size;
    50f8:	2601      	movs	r6, #1
        uint8_t px_size       = lv_img_color_format_get_px_size(cf);
    50fa:	4607      	mov	r7, r0
        uint32_t palette_size = 1 << px_size;
    50fc:	4086      	lsls	r6, r0
        if(dsc->user_data == NULL) {
    50fe:	b983      	cbnz	r3, 5122 <lv_img_decoder_built_in_open+0x72>
            dsc->user_data = lv_mem_alloc(sizeof(lv_img_decoder_built_in_data_t));
    5100:	2008      	movs	r0, #8
    5102:	f000 fd71 	bl	5be8 <lv_mem_alloc>
    5106:	6220      	str	r0, [r4, #32]
            if(dsc->user_data == NULL) {
    5108:	b930      	cbnz	r0, 5118 <lv_img_decoder_built_in_open+0x68>
                LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
    510a:	4b2a      	ldr	r3, [pc, #168]	; (51b4 <lv_img_decoder_built_in_open+0x104>)
    510c:	4928      	ldr	r1, [pc, #160]	; (51b0 <lv_img_decoder_built_in_open+0x100>)
    510e:	f44f 72c0 	mov.w	r2, #384	; 0x180
    5112:	2003      	movs	r0, #3
    5114:	f000 ff2a 	bl	5f6c <lv_log_add>
            memset(dsc->user_data, 0, sizeof(lv_img_decoder_built_in_data_t));
    5118:	2208      	movs	r2, #8
    511a:	2100      	movs	r1, #0
    511c:	6a20      	ldr	r0, [r4, #32]
    511e:	f003 fc11 	bl	8944 <memset>
        user_data->palette                         = lv_mem_alloc(palette_size * sizeof(lv_color_t));
    5122:	2004      	movs	r0, #4
    5124:	40b8      	lsls	r0, r7
        lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
    5126:	6a25      	ldr	r5, [r4, #32]
        user_data->palette                         = lv_mem_alloc(palette_size * sizeof(lv_color_t));
    5128:	f000 fd5e 	bl	5be8 <lv_mem_alloc>
    512c:	6028      	str	r0, [r5, #0]
        user_data->opa                             = lv_mem_alloc(palette_size * sizeof(lv_opa_t));
    512e:	4630      	mov	r0, r6
    5130:	f000 fd5a 	bl	5be8 <lv_mem_alloc>
        if(user_data->palette == NULL || user_data->opa == NULL) {
    5134:	682b      	ldr	r3, [r5, #0]
        user_data->opa                             = lv_mem_alloc(palette_size * sizeof(lv_opa_t));
    5136:	6068      	str	r0, [r5, #4]
        if(user_data->palette == NULL || user_data->opa == NULL) {
    5138:	b103      	cbz	r3, 513c <lv_img_decoder_built_in_open+0x8c>
    513a:	b930      	cbnz	r0, 514a <lv_img_decoder_built_in_open+0x9a>
            LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
    513c:	4b1d      	ldr	r3, [pc, #116]	; (51b4 <lv_img_decoder_built_in_open+0x104>)
    513e:	491c      	ldr	r1, [pc, #112]	; (51b0 <lv_img_decoder_built_in_open+0x100>)
    5140:	f44f 72c5 	mov.w	r2, #394	; 0x18a
    5144:	2003      	movs	r0, #3
    5146:	f000 ff11 	bl	5f6c <lv_log_add>
        if(dsc->src_type == LV_IMG_SRC_FILE) {
    514a:	7b23      	ldrb	r3, [r4, #12]
    514c:	2b01      	cmp	r3, #1
    514e:	d103      	bne.n	5158 <lv_img_decoder_built_in_open+0xa8>
            LV_LOG_WARN("Image built-in decoder can read the palette because LV_USE_FILESYSTEM = 0");
    5150:	4b19      	ldr	r3, [pc, #100]	; (51b8 <lv_img_decoder_built_in_open+0x108>)
    5152:	f44f 72ce 	mov.w	r2, #412	; 0x19c
    5156:	e7b4      	b.n	50c2 <lv_img_decoder_built_in_open+0x12>
            lv_color32_t * palette_p = (lv_color32_t *)((lv_img_dsc_t *)dsc->src)->data;
    5158:	6863      	ldr	r3, [r4, #4]
                user_data->palette[i] = lv_color_make(palette_p[i].ch.red, palette_p[i].ch.green, palette_p[i].ch.blue);
    515a:	27ff      	movs	r7, #255	; 0xff
    515c:	689a      	ldr	r2, [r3, #8]
            for(i = 0; i < palette_size; i++) {
    515e:	2300      	movs	r3, #0
    5160:	42b3      	cmp	r3, r6
    5162:	f102 0204 	add.w	r2, r2, #4
    5166:	d101      	bne.n	516c <lv_img_decoder_built_in_open+0xbc>
            dsc->img_data = NULL;
    5168:	2300      	movs	r3, #0
    516a:	e7ba      	b.n	50e2 <lv_img_decoder_built_in_open+0x32>
                user_data->palette[i] = lv_color_make(palette_p[i].ch.red, palette_p[i].ch.green, palette_p[i].ch.blue);
    516c:	6828      	ldr	r0, [r5, #0]
    516e:	f812 8c04 	ldrb.w	r8, [r2, #-4]
    5172:	f812 cc02 	ldrb.w	ip, [r2, #-2]
    5176:	f812 ec03 	ldrb.w	lr, [r2, #-3]
    517a:	f800 8023 	strb.w	r8, [r0, r3, lsl #2]
    517e:	eb00 0183 	add.w	r1, r0, r3, lsl #2
    5182:	f881 e001 	strb.w	lr, [r1, #1]
    5186:	f881 c002 	strb.w	ip, [r1, #2]
    518a:	70cf      	strb	r7, [r1, #3]
                user_data->opa[i]     = palette_p[i].ch.alpha;
    518c:	6869      	ldr	r1, [r5, #4]
    518e:	f812 0c01 	ldrb.w	r0, [r2, #-1]
    5192:	54c8      	strb	r0, [r1, r3]
            for(i = 0; i < palette_size; i++) {
    5194:	3301      	adds	r3, #1
    5196:	e7e3      	b.n	5160 <lv_img_decoder_built_in_open+0xb0>
    else if(cf == LV_IMG_CF_ALPHA_1BIT || cf == LV_IMG_CF_ALPHA_2BIT || cf == LV_IMG_CF_ALPHA_4BIT ||
    5198:	3b0b      	subs	r3, #11
    519a:	2b03      	cmp	r3, #3
    519c:	d9e4      	bls.n	5168 <lv_img_decoder_built_in_open+0xb8>
        lv_img_decoder_built_in_close(decoder, dsc);
    519e:	f005 ffc9 	bl	b134 <lv_img_decoder_built_in_close>
        LV_LOG_WARN("Image decoder open: unknown color format")
    51a2:	4b06      	ldr	r3, [pc, #24]	; (51bc <lv_img_decoder_built_in_open+0x10c>)
    51a4:	f240 12c1 	movw	r2, #449	; 0x1c1
    51a8:	e78b      	b.n	50c2 <lv_img_decoder_built_in_open+0x12>
    51aa:	bf00      	nop
    51ac:	0004595e 	.word	0x0004595e
    51b0:	000459a4 	.word	0x000459a4
    51b4:	000459e1 	.word	0x000459e1
    51b8:	00045a0a 	.word	0x00045a0a
    51bc:	00045a54 	.word	0x00045a54

000051c0 <lv_img_decoder_built_in_info>:
{
    51c0:	b538      	push	{r3, r4, r5, lr}
    lv_img_src_t src_type = lv_img_src_get_type(src);
    51c2:	4608      	mov	r0, r1
{
    51c4:	460d      	mov	r5, r1
    51c6:	4614      	mov	r4, r2
    lv_img_src_t src_type = lv_img_src_get_type(src);
    51c8:	f005 ffa4 	bl	b114 <lv_img_src_get_type>
    if(src_type == LV_IMG_SRC_VARIABLE) {
    51cc:	b9c0      	cbnz	r0, 5200 <lv_img_decoder_built_in_info+0x40>
        lv_img_cf_t cf = ((lv_img_dsc_t *)src)->header.cf;
    51ce:	782b      	ldrb	r3, [r5, #0]
    51d0:	f3c3 0304 	ubfx	r3, r3, #0, #5
        if(cf < CF_BUILT_IN_FIRST || cf > CF_BUILT_IN_LAST) return LV_RES_INV;
    51d4:	3b04      	subs	r3, #4
    51d6:	b2db      	uxtb	r3, r3
    51d8:	2b0a      	cmp	r3, #10
    51da:	d810      	bhi.n	51fe <lv_img_decoder_built_in_info+0x3e>
        header->h  = ((lv_img_dsc_t *)src)->header.h;
    51dc:	886b      	ldrh	r3, [r5, #2]
    51de:	8862      	ldrh	r2, [r4, #2]
        lv_img_cf_t cf = ((lv_img_dsc_t *)src)->header.cf;
    51e0:	6829      	ldr	r1, [r5, #0]
        header->h  = ((lv_img_dsc_t *)src)->header.h;
    51e2:	095b      	lsrs	r3, r3, #5
    51e4:	f363 124f 	bfi	r2, r3, #5, #11
    51e8:	8062      	strh	r2, [r4, #2]
        header->cf = ((lv_img_dsc_t *)src)->header.cf;
    51ea:	6823      	ldr	r3, [r4, #0]
    51ec:	4a0c      	ldr	r2, [pc, #48]	; (5220 <lv_img_decoder_built_in_info+0x60>)
    51ee:	f023 131f 	bic.w	r3, r3, #2031647	; 0x1f001f
    51f2:	f423 437c 	bic.w	r3, r3, #64512	; 0xfc00
    51f6:	400a      	ands	r2, r1
        header->cf = LV_IMG_CF_ALPHA_1BIT;
    51f8:	4313      	orrs	r3, r2
    51fa:	6023      	str	r3, [r4, #0]
    return LV_RES_OK;
    51fc:	2001      	movs	r0, #1
}
    51fe:	bd38      	pop	{r3, r4, r5, pc}
    else if(src_type == LV_IMG_SRC_SYMBOL) {
    5200:	2802      	cmp	r0, #2
    5202:	d104      	bne.n	520e <lv_img_decoder_built_in_info+0x4e>
        header->cf = LV_IMG_CF_ALPHA_1BIT;
    5204:	6823      	ldr	r3, [r4, #0]
    5206:	f403 7278 	and.w	r2, r3, #992	; 0x3e0
    520a:	4b06      	ldr	r3, [pc, #24]	; (5224 <lv_img_decoder_built_in_info+0x64>)
    520c:	e7f4      	b.n	51f8 <lv_img_decoder_built_in_info+0x38>
        LV_LOG_WARN("Image get info found unknown src type");
    520e:	2002      	movs	r0, #2
    5210:	4b05      	ldr	r3, [pc, #20]	; (5228 <lv_img_decoder_built_in_info+0x68>)
    5212:	4906      	ldr	r1, [pc, #24]	; (522c <lv_img_decoder_built_in_info+0x6c>)
    5214:	f240 1231 	movw	r2, #305	; 0x131
    5218:	f000 fea8 	bl	5f6c <lv_log_add>
    521c:	2000      	movs	r0, #0
    521e:	e7ee      	b.n	51fe <lv_img_decoder_built_in_info+0x3e>
    5220:	001ffc1f 	.word	0x001ffc1f
    5224:	0020040b 	.word	0x0020040b
    5228:	00045938 	.word	0x00045938
    522c:	000459a4 	.word	0x000459a4

00005230 <lv_img_decoder_built_in_read_line>:
 * @param buf a buffer to store the decoded pixels
 * @return LV_RES_OK: ok; LV_RES_INV: failed
 */
lv_res_t lv_img_decoder_built_in_read_line(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc, lv_coord_t x,
                                                  lv_coord_t y, lv_coord_t len, uint8_t * buf)
{
    5230:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    (void)decoder; /*Unused*/

    lv_res_t res = LV_RES_INV;

    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
    5234:	7c08      	ldrb	r0, [r1, #16]
{
    5236:	b087      	sub	sp, #28
    5238:	461e      	mov	r6, r3
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
    523a:	f000 031e 	and.w	r3, r0, #30
    523e:	2b04      	cmp	r3, #4
{
    5240:	460d      	mov	r5, r1
    5242:	4614      	mov	r4, r2
    5244:	f9bd 7038 	ldrsh.w	r7, [sp, #56]	; 0x38
    5248:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
    524c:	d003      	beq.n	5256 <lv_img_decoder_built_in_read_line+0x26>
       dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
    524e:	f000 031f 	and.w	r3, r0, #31
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
    5252:	2b06      	cmp	r3, #6
    5254:	d10b      	bne.n	526e <lv_img_decoder_built_in_read_line+0x3e>
        /* For TRUE_COLOR images read line required only for files.
         * For variables the image data was returned in `open`*/
        if(dsc->src_type == LV_IMG_SRC_FILE) {
    5256:	7b2b      	ldrb	r3, [r5, #12]
    5258:	2b01      	cmp	r3, #1
    525a:	d106      	bne.n	526a <lv_img_decoder_built_in_read_line+0x3a>
        return LV_RES_INV;
    }

    return LV_RES_OK;
#else
    LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
    525c:	4b9d      	ldr	r3, [pc, #628]	; (54d4 <lv_img_decoder_built_in_read_line+0x2a4>)
    525e:	f240 2225 	movw	r2, #549	; 0x225
        LV_LOG_WARN("Built-in image decoder read not supports the color format");
    5262:	499d      	ldr	r1, [pc, #628]	; (54d8 <lv_img_decoder_built_in_read_line+0x2a8>)
    5264:	2002      	movs	r0, #2
    5266:	f000 fe81 	bl	5f6c <lv_log_add>
    lv_res_t res = LV_RES_INV;
    526a:	2000      	movs	r0, #0
    526c:	e05c      	b.n	5328 <lv_img_decoder_built_in_read_line+0xf8>
    } else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
    526e:	f1a3 020b 	sub.w	r2, r3, #11
    5272:	2a03      	cmp	r2, #3
    5274:	f200 80a7 	bhi.w	53c6 <lv_img_decoder_built_in_read_line+0x196>
static lv_res_t lv_img_decoder_built_in_line_alpha(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                   lv_coord_t len, uint8_t * buf)
{

#if LV_IMG_CF_ALPHA
    const lv_opa_t alpha1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
    5278:	f44f 437f 	mov.w	r3, #65280	; 0xff00
    527c:	f8ad 3000 	strh.w	r3, [sp]
    const lv_opa_t alpha2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
    5280:	f5a3 03ad 	sub.w	r3, r3, #5668864	; 0x568000
    5284:	f5a3 5328 	sub.w	r3, r3, #10752	; 0x2a00
    5288:	9301      	str	r3, [sp, #4]
    const lv_opa_t alpha4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
    528a:	4b94      	ldr	r3, [pc, #592]	; (54dc <lv_img_decoder_built_in_read_line+0x2ac>)
    528c:	aa02      	add	r2, sp, #8
    528e:	f103 0e10 	add.w	lr, r3, #16
    5292:	4691      	mov	r9, r2
    5294:	6818      	ldr	r0, [r3, #0]
    5296:	6859      	ldr	r1, [r3, #4]
    5298:	4694      	mov	ip, r2
    529a:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    529e:	3308      	adds	r3, #8
    52a0:	4573      	cmp	r3, lr
    52a2:	4662      	mov	r2, ip
    52a4:	d1f6      	bne.n	5294 <lv_img_decoder_built_in_read_line+0x64>
                                           68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255};

    /*Simply fill the buffer with the color. Later only the alpha value will be modified.*/
    lv_color_t bg_color = dsc->style->image.color;
    52a6:	68ab      	ldr	r3, [r5, #8]
    52a8:	6c19      	ldr	r1, [r3, #64]	; 0x40
    52aa:	2300      	movs	r3, #0
    lv_coord_t i;
    for(i = 0; i < len; i++) {
    52ac:	b21a      	sxth	r2, r3
    52ae:	4297      	cmp	r7, r2
    52b0:	dc16      	bgt.n	52e0 <lv_img_decoder_built_in_read_line+0xb0>
#error "Invalid LV_COLOR_DEPTH. Check it in lv_conf.h"
#endif
    }

    const lv_opa_t * opa_table = NULL;
    uint8_t px_size            = lv_img_color_format_get_px_size(dsc->header.cf);
    52b2:	7c28      	ldrb	r0, [r5, #16]
    52b4:	f000 001f 	and.w	r0, r0, #31
    52b8:	f7ff fe06 	bl	4ec8 <lv_img_color_format_get_px_size>
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/

    lv_coord_t w = 0;
    uint32_t ofs = 0;
    int8_t pos   = 0;
    switch(dsc->header.cf) {
    52bc:	7c2b      	ldrb	r3, [r5, #16]
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    52be:	f04f 0c01 	mov.w	ip, #1
    52c2:	fa0c fc00 	lsl.w	ip, ip, r0
    switch(dsc->header.cf) {
    52c6:	f003 031f 	and.w	r3, r3, #31
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    52ca:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    switch(dsc->header.cf) {
    52ce:	3b0b      	subs	r3, #11
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    52d0:	fa1f fc8c 	uxth.w	ip, ip
    switch(dsc->header.cf) {
    52d4:	2b03      	cmp	r3, #3
    52d6:	d856      	bhi.n	5386 <lv_img_decoder_built_in_read_line+0x156>
    52d8:	e8df f003 	tbb	[pc, r3]
    52dc:	4d3b2906 	.word	0x4d3b2906
        *((uint32_t *)&buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE]) = bg_color.full;
    52e0:	f848 1023 	str.w	r1, [r8, r3, lsl #2]
    52e4:	3301      	adds	r3, #1
    52e6:	e7e1      	b.n	52ac <lv_img_decoder_built_in_read_line+0x7c>
        case LV_IMG_CF_ALPHA_1BIT:
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
    52e8:	6929      	ldr	r1, [r5, #16]
    52ea:	f3c1 218a 	ubfx	r1, r1, #10, #11
    52ee:	08cb      	lsrs	r3, r1, #3
            if(dsc->header.w & 0x7) w++;
    52f0:	0749      	lsls	r1, r1, #29
            ofs += w * y + (x >> 3); /*First pixel*/
    52f2:	ea4f 02e4 	mov.w	r2, r4, asr #3
            if(dsc->header.w & 0x7) w++;
    52f6:	bf18      	it	ne
    52f8:	3301      	addne	r3, #1
            pos       = 7 - (x & 0x7);
    52fa:	43e4      	mvns	r4, r4
            ofs += w * y + (x >> 3); /*First pixel*/
    52fc:	fb03 2306 	mla	r3, r3, r6, r2
            pos       = 7 - (x & 0x7);
    5300:	f004 0407 	and.w	r4, r4, #7
            opa_table = alpha1_opa_table;
    5304:	466e      	mov	r6, sp
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
    uint8_t fs_buf[LV_HOR_RES_MAX];
#endif

    const uint8_t * data_tmp = NULL;
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
    5306:	7b29      	ldrb	r1, [r5, #12]
    5308:	2900      	cmp	r1, #0
    530a:	d13f      	bne.n	538c <lv_img_decoder_built_in_read_line+0x15c>
        const lv_img_dsc_t * img_dsc = dsc->src;

        data_tmp = img_dsc->data + ofs;
    530c:	686a      	ldr	r2, [r5, #4]
        val_act = (data_tmp[byte_act] & (mask << pos)) >> pos;

        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];

        pos -= px_size;
    530e:	b240      	sxtb	r0, r0
        data_tmp = img_dsc->data + ofs;
    5310:	6892      	ldr	r2, [r2, #8]
        if(pos < 0) {
            pos = 8 - px_size;
    5312:	f1c0 0e08 	rsb	lr, r0, #8
        data_tmp = img_dsc->data + ofs;
    5316:	4413      	add	r3, r2
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
    5318:	f108 0803 	add.w	r8, r8, #3
            pos = 8 - px_size;
    531c:	fa4f fe8e 	sxtb.w	lr, lr
    for(i = 0; i < len; i++) {
    5320:	b20a      	sxth	r2, r1
    5322:	4297      	cmp	r7, r2
    5324:	dc36      	bgt.n	5394 <lv_img_decoder_built_in_read_line+0x164>
            pos = 8 - px_size;
            data_tmp++;
        }
    }

    return LV_RES_OK;
    5326:	2001      	movs	r0, #1
}
    5328:	b007      	add	sp, #28
    532a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
    532e:	6929      	ldr	r1, [r5, #16]
    5330:	f3c1 218a 	ubfx	r1, r1, #10, #11
    5334:	088b      	lsrs	r3, r1, #2
            if(dsc->header.w & 0x3) w++;
    5336:	078a      	lsls	r2, r1, #30
            ofs += w * y + (x >> 2); /*First pixel*/
    5338:	ea4f 02a4 	mov.w	r2, r4, asr #2
            pos       = 6 - ((x & 0x3) * 2);
    533c:	ea6f 0404 	mvn.w	r4, r4
            if(dsc->header.w & 0x3) w++;
    5340:	bf18      	it	ne
    5342:	3301      	addne	r3, #1
            pos       = 6 - ((x & 0x3) * 2);
    5344:	f004 0403 	and.w	r4, r4, #3
            ofs += w * y + (x >> 2); /*First pixel*/
    5348:	fb03 2306 	mla	r3, r3, r6, r2
            pos       = 6 - ((x & 0x3) * 2);
    534c:	0064      	lsls	r4, r4, #1
            opa_table = alpha2_opa_table;
    534e:	ae01      	add	r6, sp, #4
    5350:	e7d9      	b.n	5306 <lv_img_decoder_built_in_read_line+0xd6>
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
    5352:	692b      	ldr	r3, [r5, #16]
    5354:	f3c3 218a 	ubfx	r1, r3, #10, #11
    5358:	084b      	lsrs	r3, r1, #1
            if(dsc->header.w & 0x1) w++;
    535a:	07c9      	lsls	r1, r1, #31
            ofs += w * y + (x >> 1); /*First pixel*/
    535c:	ea4f 0264 	mov.w	r2, r4, asr #1
            if(dsc->header.w & 0x1) w++;
    5360:	bf48      	it	mi
    5362:	3301      	addmi	r3, #1
            pos       = 4 - ((x & 0x1) * 4);
    5364:	f014 0f01 	tst.w	r4, #1
            ofs += w * y + (x >> 1); /*First pixel*/
    5368:	fb03 2306 	mla	r3, r3, r6, r2
            pos       = 4 - ((x & 0x1) * 4);
    536c:	bf0c      	ite	eq
    536e:	2404      	moveq	r4, #4
    5370:	2400      	movne	r4, #0
    5372:	464e      	mov	r6, r9
    5374:	e7c7      	b.n	5306 <lv_img_decoder_built_in_read_line+0xd6>
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
    5376:	692b      	ldr	r3, [r5, #16]
    5378:	f3c3 238a 	ubfx	r3, r3, #10, #11
            ofs += w * y + x;  /*First pixel*/
    537c:	fb16 4303 	smlabb	r3, r6, r3, r4
            pos = 0;
    5380:	2400      	movs	r4, #0
    const lv_opa_t * opa_table = NULL;
    5382:	4626      	mov	r6, r4
    5384:	e7bf      	b.n	5306 <lv_img_decoder_built_in_read_line+0xd6>
    int8_t pos   = 0;
    5386:	2400      	movs	r4, #0
    uint32_t ofs = 0;
    5388:	4623      	mov	r3, r4
    538a:	e7fa      	b.n	5382 <lv_img_decoder_built_in_read_line+0x152>
        LV_LOG_WARN("Image built-in alpha line reader can't read file because LV_USE_FILESYSTEM = 0");
    538c:	4b54      	ldr	r3, [pc, #336]	; (54e0 <lv_img_decoder_built_in_read_line+0x2b0>)
    538e:	f240 2279 	movw	r2, #633	; 0x279
    5392:	e766      	b.n	5262 <lv_img_decoder_built_in_read_line+0x32>
        val_act = (data_tmp[byte_act] & (mask << pos)) >> pos;
    5394:	781a      	ldrb	r2, [r3, #0]
    5396:	fa0c f904 	lsl.w	r9, ip, r4
    539a:	ea02 0209 	and.w	r2, r2, r9
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];
    539e:	f895 9010 	ldrb.w	r9, [r5, #16]
        val_act = (data_tmp[byte_act] & (mask << pos)) >> pos;
    53a2:	4122      	asrs	r2, r4
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
    53a4:	b2d2      	uxtb	r2, r2
    53a6:	f009 091f 	and.w	r9, r9, #31
        pos -= px_size;
    53aa:	1a24      	subs	r4, r4, r0
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
    53ac:	f1b9 0f0e 	cmp.w	r9, #14
        pos -= px_size;
    53b0:	b264      	sxtb	r4, r4
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
    53b2:	bf18      	it	ne
    53b4:	5cb2      	ldrbne	r2, [r6, r2]
    53b6:	f808 2021 	strb.w	r2, [r8, r1, lsl #2]
        if(pos < 0) {
    53ba:	2c00      	cmp	r4, #0
            pos = 8 - px_size;
    53bc:	bfbc      	itt	lt
    53be:	4674      	movlt	r4, lr
            data_tmp++;
    53c0:	3301      	addlt	r3, #1
    53c2:	3101      	adds	r1, #1
    53c4:	e7ac      	b.n	5320 <lv_img_decoder_built_in_read_line+0xf0>
    } else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT || dsc->header.cf == LV_IMG_CF_INDEXED_2BIT ||
    53c6:	3b07      	subs	r3, #7
    53c8:	2b03      	cmp	r3, #3
    53ca:	d87f      	bhi.n	54cc <lv_img_decoder_built_in_read_line+0x29c>
    uint8_t px_size = lv_img_color_format_get_px_size(dsc->header.cf);
    53cc:	f000 001f 	and.w	r0, r0, #31
    53d0:	f7ff fd7a 	bl	4ec8 <lv_img_color_format_get_px_size>
    switch(dsc->header.cf) {
    53d4:	7c2b      	ldrb	r3, [r5, #16]
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    53d6:	f04f 0c01 	mov.w	ip, #1
    53da:	fa0c fc00 	lsl.w	ip, ip, r0
    switch(dsc->header.cf) {
    53de:	f003 031f 	and.w	r3, r3, #31
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    53e2:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    switch(dsc->header.cf) {
    53e6:	3b07      	subs	r3, #7
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    53e8:	fa1f fc8c 	uxth.w	ip, ip
    switch(dsc->header.cf) {
    53ec:	2b03      	cmp	r3, #3
    53ee:	d866      	bhi.n	54be <lv_img_decoder_built_in_read_line+0x28e>
    53f0:	e8df f003 	tbb	[pc, r3]
    53f4:	5c4a3a02 	.word	0x5c4a3a02
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
    53f8:	692a      	ldr	r2, [r5, #16]
    53fa:	f3c2 228a 	ubfx	r2, r2, #10, #11
    53fe:	08d3      	lsrs	r3, r2, #3
            if(dsc->header.w & 0x7) w++;
    5400:	0752      	lsls	r2, r2, #29
    5402:	bf18      	it	ne
    5404:	3301      	addne	r3, #1
            ofs += w * y + (x >> 3); /*First pixel*/
    5406:	10e2      	asrs	r2, r4, #3
    5408:	fb03 2306 	mla	r3, r3, r6, r2
            pos = 7 - (x & 0x7);
    540c:	43e2      	mvns	r2, r4
            ofs += 8;                /*Skip the palette*/
    540e:	3308      	adds	r3, #8
            pos = 7 - (x & 0x7);
    5410:	f002 0207 	and.w	r2, r2, #7
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
    5414:	7b29      	ldrb	r1, [r5, #12]
    5416:	2900      	cmp	r1, #0
    5418:	d154      	bne.n	54c4 <lv_img_decoder_built_in_read_line+0x294>
        data_tmp                     = img_dsc->data + ofs;
    541a:	686c      	ldr	r4, [r5, #4]
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
    541c:	6a2e      	ldr	r6, [r5, #32]
        data_tmp                     = img_dsc->data + ofs;
    541e:	68a4      	ldr	r4, [r4, #8]
        pos -= px_size;
    5420:	b240      	sxtb	r0, r0
            pos = 8 - px_size;
    5422:	f1c0 0e08 	rsb	lr, r0, #8
        data_tmp                     = img_dsc->data + ofs;
    5426:	4423      	add	r3, r4
    for(i = 0; i < len; i++) {
    5428:	f1a8 0804 	sub.w	r8, r8, #4
        data_tmp                     = img_dsc->data + ofs;
    542c:	460d      	mov	r5, r1
            pos = 8 - px_size;
    542e:	fa4f fe8e 	sxtb.w	lr, lr
    for(i = 0; i < len; i++) {
    5432:	b229      	sxth	r1, r5
    5434:	428f      	cmp	r7, r1
    5436:	f77f af76 	ble.w	5326 <lv_img_decoder_built_in_read_line+0xf6>
        val_act = (*data_tmp & (mask << pos)) >> pos;
    543a:	7819      	ldrb	r1, [r3, #0]
    543c:	fa0c f402 	lsl.w	r4, ip, r2
    5440:	4021      	ands	r1, r4
    5442:	4111      	asrs	r1, r2
        lv_color_t color = user_data->palette[val_act];
    5444:	6834      	ldr	r4, [r6, #0]
    5446:	b2c9      	uxtb	r1, r1
        pos -= px_size;
    5448:	1a12      	subs	r2, r2, r0
        lv_color_t color = user_data->palette[val_act];
    544a:	f854 4021 	ldr.w	r4, [r4, r1, lsl #2]
        *((uint32_t *)&buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE]) = color.full;
    544e:	f848 4f04 	str.w	r4, [r8, #4]!
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] = user_data->opa[val_act];
    5452:	6874      	ldr	r4, [r6, #4]
        pos -= px_size;
    5454:	b252      	sxtb	r2, r2
        if(pos < 0) {
    5456:	2a00      	cmp	r2, #0
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] = user_data->opa[val_act];
    5458:	5c61      	ldrb	r1, [r4, r1]
    545a:	f888 1003 	strb.w	r1, [r8, #3]
            pos = 8 - px_size;
    545e:	bfbc      	itt	lt
    5460:	4672      	movlt	r2, lr
            data_tmp++;
    5462:	3301      	addlt	r3, #1
    5464:	3501      	adds	r5, #1
    5466:	e7e4      	b.n	5432 <lv_img_decoder_built_in_read_line+0x202>
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
    5468:	692a      	ldr	r2, [r5, #16]
    546a:	f3c2 228a 	ubfx	r2, r2, #10, #11
    546e:	0893      	lsrs	r3, r2, #2
            if(dsc->header.w & 0x3) w++;
    5470:	0791      	lsls	r1, r2, #30
    5472:	bf18      	it	ne
    5474:	3301      	addne	r3, #1
            ofs += w * y + (x >> 2); /*First pixel*/
    5476:	10a2      	asrs	r2, r4, #2
    5478:	fb03 2306 	mla	r3, r3, r6, r2
            pos = 6 - ((x & 0x3) * 2);
    547c:	43e2      	mvns	r2, r4
    547e:	f002 0203 	and.w	r2, r2, #3
            ofs += 16;               /*Skip the palette*/
    5482:	3310      	adds	r3, #16
            pos = 6 - ((x & 0x3) * 2);
    5484:	0052      	lsls	r2, r2, #1
            break;
    5486:	e7c5      	b.n	5414 <lv_img_decoder_built_in_read_line+0x1e4>
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
    5488:	692a      	ldr	r2, [r5, #16]
    548a:	f3c2 228a 	ubfx	r2, r2, #10, #11
    548e:	0853      	lsrs	r3, r2, #1
            if(dsc->header.w & 0x1) w++;
    5490:	07d2      	lsls	r2, r2, #31
    5492:	bf48      	it	mi
    5494:	3301      	addmi	r3, #1
            ofs += w * y + (x >> 1); /*First pixel*/
    5496:	1062      	asrs	r2, r4, #1
    5498:	fb03 2306 	mla	r3, r3, r6, r2
            pos = 4 - ((x & 0x1) * 4);
    549c:	f014 0f01 	tst.w	r4, #1
            ofs += 64;               /*Skip the palette*/
    54a0:	f103 0340 	add.w	r3, r3, #64	; 0x40
            pos = 4 - ((x & 0x1) * 4);
    54a4:	bf0c      	ite	eq
    54a6:	2204      	moveq	r2, #4
    54a8:	2200      	movne	r2, #0
    54aa:	e7b3      	b.n	5414 <lv_img_decoder_built_in_read_line+0x1e4>
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
    54ac:	692b      	ldr	r3, [r5, #16]
    54ae:	f3c3 238a 	ubfx	r3, r3, #10, #11
            ofs += w * y + x;  /*First pixel*/
    54b2:	fb16 4303 	smlabb	r3, r6, r3, r4
            ofs += 1024;       /*Skip the palette*/
    54b6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
            pos = 0;
    54ba:	2200      	movs	r2, #0
    54bc:	e7aa      	b.n	5414 <lv_img_decoder_built_in_read_line+0x1e4>
    uint32_t ofs = 0;
    54be:	2300      	movs	r3, #0
    int8_t pos   = 0;
    54c0:	461a      	mov	r2, r3
    54c2:	e7a7      	b.n	5414 <lv_img_decoder_built_in_read_line+0x1e4>
        LV_LOG_WARN("Image built-in indexed line reader can't read file because LV_USE_FILESYSTEM = 0");
    54c4:	4b07      	ldr	r3, [pc, #28]	; (54e4 <lv_img_decoder_built_in_read_line+0x2b4>)
    54c6:	f240 22ce 	movw	r2, #718	; 0x2ce
    54ca:	e6ca      	b.n	5262 <lv_img_decoder_built_in_read_line+0x32>
        LV_LOG_WARN("Built-in image decoder read not supports the color format");
    54cc:	4b06      	ldr	r3, [pc, #24]	; (54e8 <lv_img_decoder_built_in_read_line+0x2b8>)
    54ce:	f240 12e7 	movw	r2, #487	; 0x1e7
    54d2:	e6c6      	b.n	5262 <lv_img_decoder_built_in_read_line+0x32>
    54d4:	0004595e 	.word	0x0004595e
    54d8:	000459a4 	.word	0x000459a4
    54dc:	0000c1f0 	.word	0x0000c1f0
    54e0:	00045a7d 	.word	0x00045a7d
    54e4:	00045acc 	.word	0x00045acc
    54e8:	00045b1d 	.word	0x00045b1d

000054ec <lv_img_decoder_get_info>:
    header->always_zero = 0;
    54ec:	780b      	ldrb	r3, [r1, #0]
    54ee:	f36f 1347 	bfc	r3, #5, #3
{
    54f2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    54f6:	4607      	mov	r7, r0
    header->always_zero = 0;
    54f8:	700b      	strb	r3, [r1, #0]
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
    54fa:	480d      	ldr	r0, [pc, #52]	; (5530 <lv_img_decoder_get_info+0x44>)
    54fc:	f8df 8030 	ldr.w	r8, [pc, #48]	; 5530 <lv_img_decoder_get_info+0x44>
{
    5500:	460e      	mov	r6, r1
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
    5502:	f005 ffe3 	bl	b4cc <lv_ll_get_head>
    lv_res_t res = LV_RES_INV;
    5506:	2400      	movs	r4, #0
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
    5508:	4605      	mov	r5, r0
    550a:	b915      	cbnz	r5, 5512 <lv_img_decoder_get_info+0x26>
}
    550c:	4620      	mov	r0, r4
    550e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(d->info_cb) {
    5512:	682c      	ldr	r4, [r5, #0]
    5514:	b134      	cbz	r4, 5524 <lv_img_decoder_get_info+0x38>
            res = d->info_cb(d, src, header);
    5516:	4632      	mov	r2, r6
    5518:	4639      	mov	r1, r7
    551a:	4628      	mov	r0, r5
    551c:	47a0      	blx	r4
            if(res == LV_RES_OK) break;
    551e:	2801      	cmp	r0, #1
            res = d->info_cb(d, src, header);
    5520:	4604      	mov	r4, r0
            if(res == LV_RES_OK) break;
    5522:	d0f3      	beq.n	550c <lv_img_decoder_get_info+0x20>
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
    5524:	4629      	mov	r1, r5
    5526:	4640      	mov	r0, r8
    5528:	f005 ffd6 	bl	b4d8 <lv_ll_get_next>
    552c:	4605      	mov	r5, r0
    552e:	e7ec      	b.n	550a <lv_img_decoder_get_info+0x1e>
    5530:	20000648 	.word	0x20000648

00005534 <lv_img_decoder_open>:
{
    5534:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    5538:	4604      	mov	r4, r0
    dsc->style     = style;
    553a:	6082      	str	r2, [r0, #8]
    dsc->src_type  = lv_img_src_get_type(src);
    553c:	4608      	mov	r0, r1
{
    553e:	460f      	mov	r7, r1
    dsc->src_type  = lv_img_src_get_type(src);
    5540:	f005 fde8 	bl	b114 <lv_img_src_get_type>
    dsc->user_data = NULL;
    5544:	2300      	movs	r3, #0
    if(dsc->src_type == LV_IMG_SRC_FILE) {
    5546:	2801      	cmp	r0, #1
    dsc->src_type  = lv_img_src_get_type(src);
    5548:	7320      	strb	r0, [r4, #12]
    dsc->user_data = NULL;
    554a:	6223      	str	r3, [r4, #32]
    if(dsc->src_type == LV_IMG_SRC_FILE) {
    554c:	d11d      	bne.n	558a <lv_img_decoder_open+0x56>
        size_t fnlen = strlen(src);
    554e:	4638      	mov	r0, r7
    5550:	f003 f9bb 	bl	88ca <strlen>
        dsc->src = lv_mem_alloc(fnlen + 1);
    5554:	3001      	adds	r0, #1
    5556:	f000 fb47 	bl	5be8 <lv_mem_alloc>
        strcpy((char *)dsc->src, src);
    555a:	4639      	mov	r1, r7
        dsc->src = lv_mem_alloc(fnlen + 1);
    555c:	6060      	str	r0, [r4, #4]
        strcpy((char *)dsc->src, src);
    555e:	f003 f989 	bl	8874 <strcpy>
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
    5562:	4819      	ldr	r0, [pc, #100]	; (55c8 <lv_img_decoder_open+0x94>)
    5564:	f8df a060 	ldr.w	sl, [pc, #96]	; 55c8 <lv_img_decoder_open+0x94>
    5568:	f005 ffb0 	bl	b4cc <lv_ll_get_head>
    lv_res_t res = LV_RES_INV;
    556c:	2600      	movs	r6, #0
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
    556e:	4605      	mov	r5, r0
        res = d->info_cb(d, src, &dsc->header);
    5570:	f104 0910 	add.w	r9, r4, #16
        dsc->error_msg = NULL;
    5574:	46b0      	mov	r8, r6
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
    5576:	b955      	cbnz	r5, 558e <lv_img_decoder_open+0x5a>
    if(res == LV_RES_INV) {
    5578:	b926      	cbnz	r6, 5584 <lv_img_decoder_open+0x50>
        memset(dsc, 0, sizeof(lv_img_decoder_dsc_t));
    557a:	2224      	movs	r2, #36	; 0x24
    557c:	4631      	mov	r1, r6
    557e:	4620      	mov	r0, r4
    5580:	f003 f9e0 	bl	8944 <memset>
}
    5584:	4630      	mov	r0, r6
    5586:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        dsc->src       = src;
    558a:	6067      	str	r7, [r4, #4]
    558c:	e7e9      	b.n	5562 <lv_img_decoder_open+0x2e>
        if(d->info_cb == NULL || d->open_cb == NULL) continue;
    558e:	682b      	ldr	r3, [r5, #0]
    5590:	b1a3      	cbz	r3, 55bc <lv_img_decoder_open+0x88>
    5592:	686a      	ldr	r2, [r5, #4]
    5594:	b192      	cbz	r2, 55bc <lv_img_decoder_open+0x88>
        res = d->info_cb(d, src, &dsc->header);
    5596:	464a      	mov	r2, r9
    5598:	4639      	mov	r1, r7
    559a:	4628      	mov	r0, r5
    559c:	4798      	blx	r3
        if(res != LV_RES_OK) continue;
    559e:	2801      	cmp	r0, #1
        res = d->info_cb(d, src, &dsc->header);
    55a0:	4606      	mov	r6, r0
        if(res != LV_RES_OK) continue;
    55a2:	d10b      	bne.n	55bc <lv_img_decoder_open+0x88>
        dsc->error_msg = NULL;
    55a4:	f8c4 801c 	str.w	r8, [r4, #28]
        dsc->img_data  = NULL;
    55a8:	f8c4 8014 	str.w	r8, [r4, #20]
        dsc->decoder   = d;
    55ac:	6025      	str	r5, [r4, #0]
        res = d->open_cb(d, dsc);
    55ae:	686b      	ldr	r3, [r5, #4]
    55b0:	4621      	mov	r1, r4
    55b2:	4628      	mov	r0, r5
    55b4:	4798      	blx	r3
        if(res == LV_RES_OK) break;
    55b6:	2801      	cmp	r0, #1
        res = d->open_cb(d, dsc);
    55b8:	4606      	mov	r6, r0
        if(res == LV_RES_OK) break;
    55ba:	d0e3      	beq.n	5584 <lv_img_decoder_open+0x50>
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
    55bc:	4629      	mov	r1, r5
    55be:	4650      	mov	r0, sl
    55c0:	f005 ff8a 	bl	b4d8 <lv_ll_get_next>
    55c4:	4605      	mov	r5, r0
    55c6:	e7d6      	b.n	5576 <lv_img_decoder_open+0x42>
    55c8:	20000648 	.word	0x20000648

000055cc <lv_img_decoder_create>:
{
    55cc:	b510      	push	{r4, lr}
    decoder = lv_ll_ins_head(&LV_GC_ROOT(_lv_img_defoder_ll));
    55ce:	4805      	ldr	r0, [pc, #20]	; (55e4 <lv_img_decoder_create+0x18>)
    55d0:	f005 ff40 	bl	b454 <lv_ll_ins_head>
    if(decoder == NULL) return NULL;
    55d4:	4604      	mov	r4, r0
    55d6:	b118      	cbz	r0, 55e0 <lv_img_decoder_create+0x14>
    memset(decoder, 0, sizeof(lv_img_decoder_t));
    55d8:	2214      	movs	r2, #20
    55da:	2100      	movs	r1, #0
    55dc:	f003 f9b2 	bl	8944 <memset>
}
    55e0:	4620      	mov	r0, r4
    55e2:	bd10      	pop	{r4, pc}
    55e4:	20000648 	.word	0x20000648

000055e8 <lv_img_decoder_init>:
{
    55e8:	b510      	push	{r4, lr}
    lv_ll_init(&LV_GC_ROOT(_lv_img_defoder_ll), sizeof(lv_img_decoder_t));
    55ea:	2114      	movs	r1, #20
    55ec:	480b      	ldr	r0, [pc, #44]	; (561c <lv_img_decoder_init+0x34>)
    55ee:	f005 ff27 	bl	b440 <lv_ll_init>
    decoder = lv_img_decoder_create();
    55f2:	f7ff ffeb 	bl	55cc <lv_img_decoder_create>
    if(decoder == NULL) {
    55f6:	b938      	cbnz	r0, 5608 <lv_img_decoder_init+0x20>
        LV_LOG_WARN("lv_img_decoder_init: out of memory");
    55f8:	4b09      	ldr	r3, [pc, #36]	; (5620 <lv_img_decoder_init+0x38>)
    55fa:	490a      	ldr	r1, [pc, #40]	; (5624 <lv_img_decoder_init+0x3c>)
    55fc:	2248      	movs	r2, #72	; 0x48
    55fe:	2002      	movs	r0, #2
}
    5600:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        LV_LOG_WARN("lv_img_decoder_init: out of memory");
    5604:	f000 bcb2 	b.w	5f6c <lv_log_add>
    decoder->info_cb = info_cb;
    5608:	4b07      	ldr	r3, [pc, #28]	; (5628 <lv_img_decoder_init+0x40>)
    560a:	6003      	str	r3, [r0, #0]
    decoder->open_cb = open_cb;
    560c:	4b07      	ldr	r3, [pc, #28]	; (562c <lv_img_decoder_init+0x44>)
    560e:	6043      	str	r3, [r0, #4]
    decoder->read_line_cb = read_line_cb;
    5610:	4b07      	ldr	r3, [pc, #28]	; (5630 <lv_img_decoder_init+0x48>)
    5612:	6083      	str	r3, [r0, #8]
    decoder->close_cb = close_cb;
    5614:	4b07      	ldr	r3, [pc, #28]	; (5634 <lv_img_decoder_init+0x4c>)
    5616:	60c3      	str	r3, [r0, #12]
}
    5618:	bd10      	pop	{r4, pc}
    561a:	bf00      	nop
    561c:	20000648 	.word	0x20000648
    5620:	00045b57 	.word	0x00045b57
    5624:	000459a4 	.word	0x000459a4
    5628:	000051c1 	.word	0x000051c1
    562c:	000050b1 	.word	0x000050b1
    5630:	00005231 	.word	0x00005231
    5634:	0000b135 	.word	0x0000b135

00005638 <lv_img_cache_open>:
 * @param style style of the image
 * @return pointer to the cache entry or NULL if can open the image
 */
lv_img_cache_entry_t * lv_img_cache_open(const void * src, const lv_style_t * style)
{
    if(entry_cnt == 0) {
    5638:	4b4c      	ldr	r3, [pc, #304]	; (576c <lv_img_cache_open+0x134>)
{
    563a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if(entry_cnt == 0) {
    563e:	881c      	ldrh	r4, [r3, #0]
{
    5640:	4607      	mov	r7, r0
    5642:	4688      	mov	r8, r1
    5644:	4699      	mov	r9, r3
    if(entry_cnt == 0) {
    5646:	b944      	cbnz	r4, 565a <lv_img_cache_open+0x22>
        LV_LOG_WARN("lv_img_cache_open: the cache size is 0");
    5648:	4b49      	ldr	r3, [pc, #292]	; (5770 <lv_img_cache_open+0x138>)
    564a:	494a      	ldr	r1, [pc, #296]	; (5774 <lv_img_cache_open+0x13c>)
    564c:	2244      	movs	r2, #68	; 0x44
    564e:	2002      	movs	r0, #2
    5650:	f000 fc8c 	bl	5f6c <lv_log_add>

        if(cached_src->dec_dsc.time_to_open == 0) cached_src->dec_dsc.time_to_open = 1;
    }

    return cached_src;
}
    5654:	4620      	mov	r0, r4
    5656:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
    565a:	4b47      	ldr	r3, [pc, #284]	; (5778 <lv_img_cache_open+0x140>)
        if(cache[i].life > INT32_MIN + LV_IMG_CACHE_AGING) {
    565c:	4847      	ldr	r0, [pc, #284]	; (577c <lv_img_cache_open+0x144>)
    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
    565e:	681d      	ldr	r5, [r3, #0]
    for(i = 0; i < entry_cnt; i++) {
    5660:	2100      	movs	r1, #0
    5662:	462b      	mov	r3, r5
    5664:	b28a      	uxth	r2, r1
    5666:	4294      	cmp	r4, r2
    5668:	d83e      	bhi.n	56e8 <lv_img_cache_open+0xb0>
    566a:	2600      	movs	r6, #0
        lv_img_src_t src_type = lv_img_src_get_type(cache[i].dec_dsc.src);
    566c:	f04f 0a28 	mov.w	sl, #40	; 0x28
    for(i = 0; i < entry_cnt; i++) {
    5670:	f8b9 1000 	ldrh.w	r1, [r9]
    5674:	b2b3      	uxth	r3, r6
    5676:	4299      	cmp	r1, r3
    5678:	d83f      	bhi.n	56fa <lv_img_cache_open+0xc2>
    567a:	f105 0228 	add.w	r2, r5, #40	; 0x28
        cached_src = &cache[0];
    567e:	462c      	mov	r4, r5
        for(i = 1; i < entry_cnt; i++) {
    5680:	2301      	movs	r3, #1
    5682:	4299      	cmp	r1, r3
    5684:	d858      	bhi.n	5738 <lv_img_cache_open+0x100>
        if(cached_src->dec_dsc.src) {
    5686:	6863      	ldr	r3, [r4, #4]
    5688:	2b00      	cmp	r3, #0
    568a:	d05e      	beq.n	574a <lv_img_cache_open+0x112>
            lv_img_decoder_close(&cached_src->dec_dsc);
    568c:	4620      	mov	r0, r4
    568e:	f005 fd6f 	bl	b170 <lv_img_decoder_close>
            LV_LOG_INFO("image draw: cache miss, close and reuse an entry");
    5692:	4b3b      	ldr	r3, [pc, #236]	; (5780 <lv_img_cache_open+0x148>)
    5694:	2276      	movs	r2, #118	; 0x76
            LV_LOG_INFO("image draw: cache miss, cached to an empty entry");
    5696:	4937      	ldr	r1, [pc, #220]	; (5774 <lv_img_cache_open+0x13c>)
    5698:	2001      	movs	r0, #1
    569a:	f000 fc67 	bl	5f6c <lv_log_add>
        t_start                          = lv_tick_get();
    569e:	f005 fdbd 	bl	b21c <lv_tick_get>
        cached_src->dec_dsc.time_to_open = 0;
    56a2:	2600      	movs	r6, #0
        t_start                          = lv_tick_get();
    56a4:	4681      	mov	r9, r0
        cached_src->dec_dsc.time_to_open = 0;
    56a6:	61a6      	str	r6, [r4, #24]
        lv_res_t open_res                = lv_img_decoder_open(&cached_src->dec_dsc, src, style);
    56a8:	4642      	mov	r2, r8
    56aa:	4639      	mov	r1, r7
    56ac:	4620      	mov	r0, r4
    56ae:	f7ff ff41 	bl	5534 <lv_img_decoder_open>
        if(open_res == LV_RES_INV) {
    56b2:	4605      	mov	r5, r0
    56b4:	2800      	cmp	r0, #0
    56b6:	d14b      	bne.n	5750 <lv_img_cache_open+0x118>
            LV_LOG_WARN("Image draw cannot open the image resource");
    56b8:	4b32      	ldr	r3, [pc, #200]	; (5784 <lv_img_cache_open+0x14c>)
    56ba:	492e      	ldr	r1, [pc, #184]	; (5774 <lv_img_cache_open+0x13c>)
    56bc:	2281      	movs	r2, #129	; 0x81
    56be:	2002      	movs	r0, #2
    56c0:	f000 fc54 	bl	5f6c <lv_log_add>
            lv_img_decoder_close(&cached_src->dec_dsc);
    56c4:	4620      	mov	r0, r4
    56c6:	f005 fd53 	bl	b170 <lv_img_decoder_close>
            memset(&cached_src->dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
    56ca:	2224      	movs	r2, #36	; 0x24
    56cc:	4629      	mov	r1, r5
    56ce:	4620      	mov	r0, r4
    56d0:	f003 f938 	bl	8944 <memset>
            memset(cached_src, 0, sizeof(lv_img_cache_entry_t));
    56d4:	4620      	mov	r0, r4
    56d6:	2228      	movs	r2, #40	; 0x28
    56d8:	4629      	mov	r1, r5
    56da:	f003 f933 	bl	8944 <memset>
            cached_src->life = INT32_MIN; /*Make the empty entry very "weak" to force its use  */
    56de:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    56e2:	6263      	str	r3, [r4, #36]	; 0x24
            return NULL;
    56e4:	462c      	mov	r4, r5
    56e6:	e7b5      	b.n	5654 <lv_img_cache_open+0x1c>
        if(cache[i].life > INT32_MIN + LV_IMG_CACHE_AGING) {
    56e8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    56ea:	4282      	cmp	r2, r0
            cache[i].life -= LV_IMG_CACHE_AGING;
    56ec:	bfa4      	itt	ge
    56ee:	f102 32ff 	addge.w	r2, r2, #4294967295	; 0xffffffff
    56f2:	625a      	strge	r2, [r3, #36]	; 0x24
    56f4:	3101      	adds	r1, #1
    56f6:	3328      	adds	r3, #40	; 0x28
    56f8:	e7b4      	b.n	5664 <lv_img_cache_open+0x2c>
        lv_img_src_t src_type = lv_img_src_get_type(cache[i].dec_dsc.src);
    56fa:	b2b4      	uxth	r4, r6
    56fc:	fb0a 5404 	mla	r4, sl, r4, r5
    5700:	6860      	ldr	r0, [r4, #4]
    5702:	f005 fd07 	bl	b114 <lv_img_src_get_type>
        if(src_type == LV_IMG_SRC_VARIABLE) {
    5706:	b950      	cbnz	r0, 571e <lv_img_cache_open+0xe6>
            if(cache[i].dec_dsc.src == src) match = true;
    5708:	6863      	ldr	r3, [r4, #4]
    570a:	42bb      	cmp	r3, r7
    570c:	d10f      	bne.n	572e <lv_img_cache_open+0xf6>
            cached_src->life += cached_src->dec_dsc.time_to_open * LV_IMG_CACHE_LIFE_GAIN;
    570e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    5710:	69a2      	ldr	r2, [r4, #24]
    5712:	4413      	add	r3, r2
            if(cached_src->life > LV_IMG_CACHE_LIFE_LIMIT) cached_src->life = LV_IMG_CACHE_LIFE_LIMIT;
    5714:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    5718:	dc0b      	bgt.n	5732 <lv_img_cache_open+0xfa>
    571a:	6263      	str	r3, [r4, #36]	; 0x24
    571c:	e79a      	b.n	5654 <lv_img_cache_open+0x1c>
        } else if(src_type == LV_IMG_SRC_FILE) {
    571e:	2801      	cmp	r0, #1
    5720:	d105      	bne.n	572e <lv_img_cache_open+0xf6>
            if(strcmp(cache[i].dec_dsc.src, src) == 0) match = true;
    5722:	4639      	mov	r1, r7
    5724:	6860      	ldr	r0, [r4, #4]
    5726:	f003 f8d7 	bl	88d8 <strcmp>
    572a:	2800      	cmp	r0, #0
    572c:	d0ef      	beq.n	570e <lv_img_cache_open+0xd6>
    572e:	3601      	adds	r6, #1
    5730:	e79e      	b.n	5670 <lv_img_cache_open+0x38>
            if(cached_src->life > LV_IMG_CACHE_LIFE_LIMIT) cached_src->life = LV_IMG_CACHE_LIFE_LIMIT;
    5732:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    5736:	e7f0      	b.n	571a <lv_img_cache_open+0xe2>
            if(cache[i].life < cached_src->life) {
    5738:	6a55      	ldr	r5, [r2, #36]	; 0x24
    573a:	6a60      	ldr	r0, [r4, #36]	; 0x24
        for(i = 1; i < entry_cnt; i++) {
    573c:	3301      	adds	r3, #1
            if(cache[i].life < cached_src->life) {
    573e:	4285      	cmp	r5, r0
    5740:	bfb8      	it	lt
    5742:	4614      	movlt	r4, r2
        for(i = 1; i < entry_cnt; i++) {
    5744:	b29b      	uxth	r3, r3
    5746:	3228      	adds	r2, #40	; 0x28
    5748:	e79b      	b.n	5682 <lv_img_cache_open+0x4a>
            LV_LOG_INFO("image draw: cache miss, cached to an empty entry");
    574a:	4b0f      	ldr	r3, [pc, #60]	; (5788 <lv_img_cache_open+0x150>)
    574c:	2278      	movs	r2, #120	; 0x78
    574e:	e7a2      	b.n	5696 <lv_img_cache_open+0x5e>
        if(cached_src->dec_dsc.time_to_open == 0) {
    5750:	69a3      	ldr	r3, [r4, #24]
        cached_src->life = 0;
    5752:	6266      	str	r6, [r4, #36]	; 0x24
        if(cached_src->dec_dsc.time_to_open == 0) {
    5754:	2b00      	cmp	r3, #0
    5756:	f47f af7d 	bne.w	5654 <lv_img_cache_open+0x1c>
            cached_src->dec_dsc.time_to_open = lv_tick_elaps(t_start);
    575a:	4648      	mov	r0, r9
    575c:	f005 fd62 	bl	b224 <lv_tick_elaps>
        if(cached_src->dec_dsc.time_to_open == 0) cached_src->dec_dsc.time_to_open = 1;
    5760:	b108      	cbz	r0, 5766 <lv_img_cache_open+0x12e>
            cached_src->dec_dsc.time_to_open = lv_tick_elaps(t_start);
    5762:	61a0      	str	r0, [r4, #24]
    5764:	e776      	b.n	5654 <lv_img_cache_open+0x1c>
        if(cached_src->dec_dsc.time_to_open == 0) cached_src->dec_dsc.time_to_open = 1;
    5766:	2301      	movs	r3, #1
    5768:	61a3      	str	r3, [r4, #24]
    576a:	e773      	b.n	5654 <lv_img_cache_open+0x1c>
    576c:	20004804 	.word	0x20004804
    5770:	00045b7a 	.word	0x00045b7a
    5774:	00045ba1 	.word	0x00045ba1
    5778:	20000644 	.word	0x20000644
    577c:	80000002 	.word	0x80000002
    5780:	00045bdc 	.word	0x00045bdc
    5784:	00045c3e 	.word	0x00045c3e
    5788:	00045c0d 	.word	0x00045c0d

0000578c <lv_img_cache_invalidate_src>:
 * Invalidate an image source in the cache.
 * Useful if the image source is updated therefore it needs to be cached again.
 * @param src an image source path to a file or pointer to an `lv_img_dsc_t` variable.
 */
void lv_img_cache_invalidate_src(const void * src)
{
    578c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
    5790:	4b12      	ldr	r3, [pc, #72]	; (57dc <lv_img_cache_invalidate_src+0x50>)

    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
    5792:	4f13      	ldr	r7, [pc, #76]	; (57e0 <lv_img_cache_invalidate_src+0x54>)
    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
    5794:	f8d3 8000 	ldr.w	r8, [r3]
{
    5798:	4606      	mov	r6, r0
    for(i = 0; i < entry_cnt; i++) {
    579a:	2500      	movs	r5, #0
        if(cache[i].dec_dsc.src == src || src == NULL) {
    579c:	f04f 0928 	mov.w	r9, #40	; 0x28
    for(i = 0; i < entry_cnt; i++) {
    57a0:	883a      	ldrh	r2, [r7, #0]
    57a2:	b2ab      	uxth	r3, r5
    57a4:	429a      	cmp	r2, r3
    57a6:	d801      	bhi.n	57ac <lv_img_cache_invalidate_src+0x20>

            memset(&cache[i].dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
            memset(&cache[i], 0, sizeof(lv_img_cache_entry_t));
        }
    }
}
    57a8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if(cache[i].dec_dsc.src == src || src == NULL) {
    57ac:	b2ac      	uxth	r4, r5
    57ae:	fb09 8404 	mla	r4, r9, r4, r8
    57b2:	6863      	ldr	r3, [r4, #4]
    57b4:	42b3      	cmp	r3, r6
    57b6:	d000      	beq.n	57ba <lv_img_cache_invalidate_src+0x2e>
    57b8:	b96e      	cbnz	r6, 57d6 <lv_img_cache_invalidate_src+0x4a>
            if(cache[i].dec_dsc.src != NULL) {
    57ba:	b113      	cbz	r3, 57c2 <lv_img_cache_invalidate_src+0x36>
                lv_img_decoder_close(&cache[i].dec_dsc);
    57bc:	4620      	mov	r0, r4
    57be:	f005 fcd7 	bl	b170 <lv_img_decoder_close>
            memset(&cache[i].dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
    57c2:	2224      	movs	r2, #36	; 0x24
    57c4:	2100      	movs	r1, #0
    57c6:	4620      	mov	r0, r4
    57c8:	f003 f8bc 	bl	8944 <memset>
            memset(&cache[i], 0, sizeof(lv_img_cache_entry_t));
    57cc:	2228      	movs	r2, #40	; 0x28
    57ce:	2100      	movs	r1, #0
    57d0:	4620      	mov	r0, r4
    57d2:	f003 f8b7 	bl	8944 <memset>
    57d6:	3501      	adds	r5, #1
    57d8:	e7e2      	b.n	57a0 <lv_img_cache_invalidate_src+0x14>
    57da:	bf00      	nop
    57dc:	20000644 	.word	0x20000644
    57e0:	20004804 	.word	0x20004804

000057e4 <lv_img_cache_set_size>:
{
    57e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(LV_GC_ROOT(_lv_img_cache_array) != NULL) {
    57e8:	4c17      	ldr	r4, [pc, #92]	; (5848 <lv_img_cache_set_size+0x64>)
    57ea:	6823      	ldr	r3, [r4, #0]
{
    57ec:	4605      	mov	r5, r0
    if(LV_GC_ROOT(_lv_img_cache_array) != NULL) {
    57ee:	b12b      	cbz	r3, 57fc <lv_img_cache_set_size+0x18>
        lv_img_cache_invalidate_src(NULL);
    57f0:	2000      	movs	r0, #0
    57f2:	f7ff ffcb 	bl	578c <lv_img_cache_invalidate_src>
        lv_mem_free(LV_GC_ROOT(_lv_img_cache_array));
    57f6:	6820      	ldr	r0, [r4, #0]
    57f8:	f000 fa1c 	bl	5c34 <lv_mem_free>
    LV_GC_ROOT(_lv_img_cache_array) = lv_mem_alloc(sizeof(lv_img_cache_entry_t) * new_entry_cnt);
    57fc:	2728      	movs	r7, #40	; 0x28
    57fe:	fb07 f005 	mul.w	r0, r7, r5
    5802:	f000 f9f1 	bl	5be8 <lv_mem_alloc>
    5806:	f8df 8044 	ldr.w	r8, [pc, #68]	; 584c <lv_img_cache_set_size+0x68>
    580a:	6020      	str	r0, [r4, #0]
    if(LV_GC_ROOT(_lv_img_cache_array) == NULL) {
    580c:	b918      	cbnz	r0, 5816 <lv_img_cache_set_size+0x32>
        entry_cnt = 0;
    580e:	f8a8 0000 	strh.w	r0, [r8]
}
    5812:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    entry_cnt = new_entry_cnt;
    5816:	f8a8 5000 	strh.w	r5, [r8]
    for(i = 0; i < entry_cnt; i++) {
    581a:	2500      	movs	r5, #0
    581c:	f8b8 2000 	ldrh.w	r2, [r8]
    5820:	b2ab      	uxth	r3, r5
    5822:	429a      	cmp	r2, r3
    5824:	d9f5      	bls.n	5812 <lv_img_cache_set_size+0x2e>
        memset(&LV_GC_ROOT(_lv_img_cache_array)[i].dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
    5826:	b2ae      	uxth	r6, r5
    5828:	6820      	ldr	r0, [r4, #0]
    582a:	437e      	muls	r6, r7
    582c:	2224      	movs	r2, #36	; 0x24
    582e:	2100      	movs	r1, #0
    5830:	4430      	add	r0, r6
    5832:	f003 f887 	bl	8944 <memset>
        memset(&LV_GC_ROOT(_lv_img_cache_array)[i], 0, sizeof(lv_img_cache_entry_t));
    5836:	6820      	ldr	r0, [r4, #0]
    5838:	2228      	movs	r2, #40	; 0x28
    583a:	2100      	movs	r1, #0
    583c:	4430      	add	r0, r6
    583e:	f003 f881 	bl	8944 <memset>
    5842:	3501      	adds	r5, #1
    5844:	e7ea      	b.n	581c <lv_img_cache_set_size+0x38>
    5846:	bf00      	nop
    5848:	20000644 	.word	0x20000644
    584c:	20004804 	.word	0x20004804

00005850 <lv_disp_drv_register>:
 * Automatically set the first display as active.
 * @param driver pointer to an initialized 'lv_disp_drv_t' variable (can be local variable)
 * @return pointer to the new display or NULL on error
 */
lv_disp_t * lv_disp_drv_register(lv_disp_drv_t * driver)
{
    5850:	b570      	push	{r4, r5, r6, lr}
    5852:	4605      	mov	r5, r0
    lv_disp_t * disp = lv_ll_ins_head(&LV_GC_ROOT(_lv_disp_ll));
    5854:	4828      	ldr	r0, [pc, #160]	; (58f8 <lv_disp_drv_register+0xa8>)
    5856:	f005 fdfd 	bl	b454 <lv_ll_ins_head>
    if(!disp) {
    585a:	4604      	mov	r4, r0
    585c:	b910      	cbnz	r0, 5864 <lv_disp_drv_register+0x14>
        LV_ASSERT_MEM(disp);
        return NULL;
    585e:	2400      	movs	r4, #0
    if(disp->refr_task == NULL) return NULL;

    lv_task_ready(disp->refr_task); /*Be sure the screen will be refreshed immediately on start up*/

    return disp;
}
    5860:	4620      	mov	r0, r4
    5862:	bd70      	pop	{r4, r5, r6, pc}
    memcpy(&disp->driver, driver, sizeof(lv_disp_drv_t));
    5864:	4629      	mov	r1, r5
    5866:	2224      	movs	r2, #36	; 0x24
    5868:	f003 f842 	bl	88f0 <memcpy>
    memset(&disp->inv_area_joined, 0, sizeof(disp->inv_area_joined));
    586c:	2220      	movs	r2, #32
    586e:	2100      	movs	r1, #0
    5870:	f504 70a0 	add.w	r0, r4, #320	; 0x140
    5874:	f003 f866 	bl	8944 <memset>
    if(disp_def == NULL) disp_def = disp;
    5878:	4d20      	ldr	r5, [pc, #128]	; (58fc <lv_disp_drv_register+0xac>)
    memset(&disp->inv_areas, 0, sizeof(disp->inv_areas));
    587a:	f44f 7280 	mov.w	r2, #256	; 0x100
    587e:	2100      	movs	r1, #0
    5880:	f104 0040 	add.w	r0, r4, #64	; 0x40
    5884:	f003 f85e 	bl	8944 <memset>
    lv_ll_init(&disp->scr_ll, sizeof(lv_obj_t));
    5888:	2138      	movs	r1, #56	; 0x38
    588a:	f104 0028 	add.w	r0, r4, #40	; 0x28
    588e:	f005 fdd7 	bl	b440 <lv_ll_init>
    if(disp_def == NULL) disp_def = disp;
    5892:	682b      	ldr	r3, [r5, #0]
    5894:	b903      	cbnz	r3, 5898 <lv_disp_drv_register+0x48>
    5896:	602c      	str	r4, [r5, #0]
    disp->inv_p = 0;
    5898:	f8b4 3160 	ldrh.w	r3, [r4, #352]	; 0x160
    lv_disp_t * disp_def_tmp = disp_def;
    589c:	682e      	ldr	r6, [r5, #0]
    disp_def                 = disp; /*Temporarily change the default screen to create the default screens on the
    589e:	602c      	str	r4, [r5, #0]
    disp->inv_p = 0;
    58a0:	f36f 0309 	bfc	r3, #0, #10
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
    58a4:	2100      	movs	r1, #0
    disp->inv_p = 0;
    58a6:	f8a4 3160 	strh.w	r3, [r4, #352]	; 0x160
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
    58aa:	4608      	mov	r0, r1
    58ac:	f7fe f97e 	bl	3bac <lv_obj_create>
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
    58b0:	2100      	movs	r1, #0
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
    58b2:	6360      	str	r0, [r4, #52]	; 0x34
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
    58b4:	4608      	mov	r0, r1
    58b6:	f7fe f979 	bl	3bac <lv_obj_create>
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
    58ba:	2100      	movs	r1, #0
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
    58bc:	63a0      	str	r0, [r4, #56]	; 0x38
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
    58be:	4608      	mov	r0, r1
    58c0:	f7fe f974 	bl	3bac <lv_obj_create>
    lv_obj_set_style(disp->top_layer, &lv_style_transp);
    58c4:	490e      	ldr	r1, [pc, #56]	; (5900 <lv_disp_drv_register+0xb0>)
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
    58c6:	63e0      	str	r0, [r4, #60]	; 0x3c
    lv_obj_set_style(disp->top_layer, &lv_style_transp);
    58c8:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    58ca:	f004 f851 	bl	9970 <lv_obj_set_style>
    lv_obj_set_style(disp->sys_layer, &lv_style_transp);
    58ce:	490c      	ldr	r1, [pc, #48]	; (5900 <lv_disp_drv_register+0xb0>)
    58d0:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    58d2:	f004 f84d 	bl	9970 <lv_obj_set_style>
    lv_obj_invalidate(disp->act_scr);
    58d6:	6b60      	ldr	r0, [r4, #52]	; 0x34
    58d8:	f003 ff32 	bl	9740 <lv_obj_invalidate>
    disp->refr_task = lv_task_create(lv_disp_refr_task, LV_DISP_DEF_REFR_PERIOD, LV_TASK_PRIO_MID, disp);
    58dc:	4623      	mov	r3, r4
    58de:	2203      	movs	r2, #3
    58e0:	2132      	movs	r1, #50	; 0x32
    58e2:	4808      	ldr	r0, [pc, #32]	; (5904 <lv_disp_drv_register+0xb4>)
    disp_def = disp_def_tmp; /*Revert the default display*/
    58e4:	602e      	str	r6, [r5, #0]
    disp->refr_task = lv_task_create(lv_disp_refr_task, LV_DISP_DEF_REFR_PERIOD, LV_TASK_PRIO_MID, disp);
    58e6:	f005 fd68 	bl	b3ba <lv_task_create>
    58ea:	6260      	str	r0, [r4, #36]	; 0x24
    if(disp->refr_task == NULL) return NULL;
    58ec:	2800      	cmp	r0, #0
    58ee:	d0b6      	beq.n	585e <lv_disp_drv_register+0xe>
    lv_task_ready(disp->refr_task); /*Be sure the screen will be refreshed immediately on start up*/
    58f0:	f005 fd77 	bl	b3e2 <lv_task_ready>
    return disp;
    58f4:	e7b4      	b.n	5860 <lv_disp_drv_register+0x10>
    58f6:	bf00      	nop
    58f8:	20000634 	.word	0x20000634
    58fc:	2000061c 	.word	0x2000061c
    5900:	20000528 	.word	0x20000528
    5904:	00003f8d 	.word	0x00003f8d

00005908 <lv_disp_get_default>:
 * @return pointer to the default display
 */
lv_disp_t * lv_disp_get_default(void)
{
    return disp_def;
}
    5908:	4b01      	ldr	r3, [pc, #4]	; (5910 <lv_disp_get_default+0x8>)
    590a:	6818      	ldr	r0, [r3, #0]
    590c:	4770      	bx	lr
    590e:	bf00      	nop
    5910:	2000061c 	.word	0x2000061c

00005914 <lv_disp_get_hor_res>:
 * @param disp pointer to a display (NULL to use the default display)
 * @return the horizontal resolution of the display
 */
lv_coord_t lv_disp_get_hor_res(lv_disp_t * disp)
{
    if(disp == NULL) disp = lv_disp_get_default();
    5914:	b910      	cbnz	r0, 591c <lv_disp_get_hor_res+0x8>
    return disp_def;
    5916:	4b06      	ldr	r3, [pc, #24]	; (5930 <lv_disp_get_hor_res+0x1c>)
    5918:	6818      	ldr	r0, [r3, #0]

    if(disp == NULL)
    591a:	b138      	cbz	r0, 592c <lv_disp_get_hor_res+0x18>
        return LV_HOR_RES_MAX;
    else
        return disp->driver.rotated == 0 ? disp->driver.hor_res : disp->driver.ver_res;
    591c:	7a03      	ldrb	r3, [r0, #8]
    591e:	07db      	lsls	r3, r3, #31
    5920:	bf54      	ite	pl
    5922:	f9b0 0000 	ldrshpl.w	r0, [r0]
    5926:	f9b0 0002 	ldrshmi.w	r0, [r0, #2]
    592a:	4770      	bx	lr
        return LV_HOR_RES_MAX;
    592c:	20f0      	movs	r0, #240	; 0xf0
}
    592e:	4770      	bx	lr
    5930:	2000061c 	.word	0x2000061c

00005934 <lv_disp_get_ver_res>:
 * @param disp pointer to a display (NULL to use the default display)
 * @return the vertical resolution of the display
 */
lv_coord_t lv_disp_get_ver_res(lv_disp_t * disp)
{
    if(disp == NULL) disp = lv_disp_get_default();
    5934:	b910      	cbnz	r0, 593c <lv_disp_get_ver_res+0x8>
    return disp_def;
    5936:	4b06      	ldr	r3, [pc, #24]	; (5950 <lv_disp_get_ver_res+0x1c>)
    5938:	6818      	ldr	r0, [r3, #0]

    if(disp == NULL)
    593a:	b138      	cbz	r0, 594c <lv_disp_get_ver_res+0x18>
        return LV_VER_RES_MAX;
    else
        return disp->driver.rotated == 0 ? disp->driver.ver_res : disp->driver.hor_res;
    593c:	7a03      	ldrb	r3, [r0, #8]
    593e:	07db      	lsls	r3, r3, #31
    5940:	bf54      	ite	pl
    5942:	f9b0 0002 	ldrshpl.w	r0, [r0, #2]
    5946:	f9b0 0000 	ldrshmi.w	r0, [r0]
    594a:	4770      	bx	lr
        return LV_VER_RES_MAX;
    594c:	20f0      	movs	r0, #240	; 0xf0
}
    594e:	4770      	bx	lr
    5950:	2000061c 	.word	0x2000061c

00005954 <lv_indev_get_next>:
 * @return the next input devise or NULL if no more. Give the first input device when the parameter
 * is NULL
 */
lv_indev_t * lv_indev_get_next(lv_indev_t * indev)
{
    if(indev == NULL)
    5954:	4601      	mov	r1, r0
        return lv_ll_get_head(&LV_GC_ROOT(_lv_indev_ll));
    5956:	4803      	ldr	r0, [pc, #12]	; (5964 <lv_indev_get_next+0x10>)
    if(indev == NULL)
    5958:	b909      	cbnz	r1, 595e <lv_indev_get_next+0xa>
        return lv_ll_get_head(&LV_GC_ROOT(_lv_indev_ll));
    595a:	f005 bdb7 	b.w	b4cc <lv_ll_get_head>
    else
        return lv_ll_get_next(&LV_GC_ROOT(_lv_indev_ll), indev);
    595e:	f005 bdbb 	b.w	b4d8 <lv_ll_get_next>
    5962:	bf00      	nop
    5964:	20000654 	.word	0x20000654

00005968 <lv_task_core_init>:

/**
 * Init the lv_task module
 */
void lv_task_core_init(void)
{
    5968:	b508      	push	{r3, lr}
    lv_ll_init(&LV_GC_ROOT(_lv_task_ll), sizeof(lv_task_t));
    596a:	2114      	movs	r1, #20
    596c:	4803      	ldr	r0, [pc, #12]	; (597c <lv_task_core_init+0x14>)
    596e:	f005 fd67 	bl	b440 <lv_ll_init>
 * Enable or disable the whole lv_task handling
 * @param en: true: lv_task handling is running, false: lv_task handling is suspended
 */
void lv_task_enable(bool en)
{
    lv_task_run = en;
    5972:	4b03      	ldr	r3, [pc, #12]	; (5980 <lv_task_core_init+0x18>)
    5974:	2201      	movs	r2, #1
    5976:	701a      	strb	r2, [r3, #0]
}
    5978:	bd08      	pop	{r3, pc}
    597a:	bf00      	nop
    597c:	20000664 	.word	0x20000664
    5980:	20008b8d 	.word	0x20008b8d

00005984 <lv_task_create_basic>:
{
    5984:	b538      	push	{r3, r4, r5, lr}
    tmp = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
    5986:	481a      	ldr	r0, [pc, #104]	; (59f0 <lv_task_create_basic+0x6c>)
    5988:	f005 fda0 	bl	b4cc <lv_ll_get_head>
    if(NULL == tmp) {
    598c:	4601      	mov	r1, r0
    598e:	b148      	cbz	r0, 59a4 <lv_task_create_basic+0x20>
            tmp = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), tmp);
    5990:	4c17      	ldr	r4, [pc, #92]	; (59f0 <lv_task_create_basic+0x6c>)
            if(tmp->prio <= DEF_PRIO) {
    5992:	7c0b      	ldrb	r3, [r1, #16]
    5994:	f003 0307 	and.w	r3, r3, #7
    5998:	2b03      	cmp	r3, #3
    599a:	d80b      	bhi.n	59b4 <lv_task_create_basic+0x30>
                new_task = lv_ll_ins_prev(&LV_GC_ROOT(_lv_task_ll), tmp);
    599c:	4814      	ldr	r0, [pc, #80]	; (59f0 <lv_task_create_basic+0x6c>)
    599e:	f005 fdba 	bl	b516 <lv_ll_ins_prev>
    59a2:	e002      	b.n	59aa <lv_task_create_basic+0x26>
        new_task = lv_ll_ins_head(&LV_GC_ROOT(_lv_task_ll));
    59a4:	4812      	ldr	r0, [pc, #72]	; (59f0 <lv_task_create_basic+0x6c>)
    59a6:	f005 fd55 	bl	b454 <lv_ll_ins_head>
        if(new_task == NULL) return NULL;
    59aa:	4604      	mov	r4, r0
    59ac:	b960      	cbnz	r0, 59c8 <lv_task_create_basic+0x44>
    59ae:	2400      	movs	r4, #0
}
    59b0:	4620      	mov	r0, r4
    59b2:	bd38      	pop	{r3, r4, r5, pc}
            tmp = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), tmp);
    59b4:	4620      	mov	r0, r4
    59b6:	f005 fd8f 	bl	b4d8 <lv_ll_get_next>
        } while(tmp != NULL);
    59ba:	4601      	mov	r1, r0
    59bc:	2800      	cmp	r0, #0
    59be:	d1e8      	bne.n	5992 <lv_task_create_basic+0xe>
            new_task = lv_ll_ins_tail(&LV_GC_ROOT(_lv_task_ll));
    59c0:	480b      	ldr	r0, [pc, #44]	; (59f0 <lv_task_create_basic+0x6c>)
    59c2:	f005 fd65 	bl	b490 <lv_ll_ins_tail>
    59c6:	e7f0      	b.n	59aa <lv_task_create_basic+0x26>
    new_task->period  = DEF_PERIOD;
    59c8:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    59cc:	6003      	str	r3, [r0, #0]
    new_task->prio    = DEF_PRIO;
    59ce:	7c03      	ldrb	r3, [r0, #16]
    59d0:	f023 030f 	bic.w	r3, r3, #15
    59d4:	f043 0303 	orr.w	r3, r3, #3
    new_task->task_cb = NULL;
    59d8:	2500      	movs	r5, #0
    new_task->prio    = DEF_PRIO;
    59da:	7403      	strb	r3, [r0, #16]
    new_task->task_cb = NULL;
    59dc:	6085      	str	r5, [r0, #8]
    new_task->last_run = lv_tick_get();
    59de:	f005 fc1d 	bl	b21c <lv_tick_get>
    task_created = true;
    59e2:	4b04      	ldr	r3, [pc, #16]	; (59f4 <lv_task_create_basic+0x70>)
    new_task->last_run = lv_tick_get();
    59e4:	6060      	str	r0, [r4, #4]
    task_created = true;
    59e6:	2201      	movs	r2, #1
    new_task->user_data = NULL;
    59e8:	60e5      	str	r5, [r4, #12]
    task_created = true;
    59ea:	701a      	strb	r2, [r3, #0]
    return new_task;
    59ec:	e7e0      	b.n	59b0 <lv_task_create_basic+0x2c>
    59ee:	bf00      	nop
    59f0:	20000664 	.word	0x20000664
    59f4:	20008b8e 	.word	0x20008b8e

000059f8 <lv_task_del>:
{
    59f8:	b510      	push	{r4, lr}
    lv_ll_rem(&LV_GC_ROOT(_lv_task_ll), task);
    59fa:	4601      	mov	r1, r0
{
    59fc:	4604      	mov	r4, r0
    lv_ll_rem(&LV_GC_ROOT(_lv_task_ll), task);
    59fe:	4807      	ldr	r0, [pc, #28]	; (5a1c <lv_task_del+0x24>)
    5a00:	f005 fdba 	bl	b578 <lv_ll_rem>
    lv_mem_free(task);
    5a04:	4620      	mov	r0, r4
    5a06:	f000 f915 	bl	5c34 <lv_mem_free>
    if(LV_GC_ROOT(_lv_task_act) == task) task_deleted = true; /*The active task was deleted*/
    5a0a:	4b05      	ldr	r3, [pc, #20]	; (5a20 <lv_task_del+0x28>)
    5a0c:	681b      	ldr	r3, [r3, #0]
    5a0e:	42a3      	cmp	r3, r4
    5a10:	bf02      	ittt	eq
    5a12:	4b04      	ldreq	r3, [pc, #16]	; (5a24 <lv_task_del+0x2c>)
    5a14:	2201      	moveq	r2, #1
    5a16:	701a      	strbeq	r2, [r3, #0]
}
    5a18:	bd10      	pop	{r4, pc}
    5a1a:	bf00      	nop
    5a1c:	20000664 	.word	0x20000664
    5a20:	20000660 	.word	0x20000660
    5a24:	20008b8f 	.word	0x20008b8f

00005a28 <lv_task_exec>:
 * Execute task if its the priority is appropriate
 * @param task pointer to lv_task
 * @return true: execute, false: not executed
 */
static bool lv_task_exec(lv_task_t * task)
{
    5a28:	b538      	push	{r3, r4, r5, lr}
    5a2a:	4604      	mov	r4, r0
    bool exec = false;

    /*Execute if at least 'period' time elapsed*/
    uint32_t elp = lv_tick_elaps(task->last_run);
    5a2c:	6840      	ldr	r0, [r0, #4]
    5a2e:	f005 fbf9 	bl	b224 <lv_tick_elaps>
    if(elp >= task->period) {
    5a32:	6823      	ldr	r3, [r4, #0]
    5a34:	4283      	cmp	r3, r0
    5a36:	d817      	bhi.n	5a68 <lv_task_exec+0x40>
        task->last_run = lv_tick_get();
    5a38:	f005 fbf0 	bl	b21c <lv_tick_get>
        task_deleted   = false;
    5a3c:	4d0b      	ldr	r5, [pc, #44]	; (5a6c <lv_task_exec+0x44>)
        task_created   = false;
    5a3e:	4a0c      	ldr	r2, [pc, #48]	; (5a70 <lv_task_exec+0x48>)
        task->last_run = lv_tick_get();
    5a40:	6060      	str	r0, [r4, #4]
        task_deleted   = false;
    5a42:	2300      	movs	r3, #0
    5a44:	702b      	strb	r3, [r5, #0]
        task_created   = false;
    5a46:	7013      	strb	r3, [r2, #0]
        if(task->task_cb) task->task_cb(task);
    5a48:	68a3      	ldr	r3, [r4, #8]
    5a4a:	b933      	cbnz	r3, 5a5a <lv_task_exec+0x32>

        /*Delete if it was a one shot lv_task*/
        if(task_deleted == false) { /*The task might be deleted by itself as well*/
            if(task->once != 0) {
    5a4c:	7c23      	ldrb	r3, [r4, #16]
    5a4e:	071b      	lsls	r3, r3, #28
    5a50:	d508      	bpl.n	5a64 <lv_task_exec+0x3c>
                lv_task_del(task);
    5a52:	4620      	mov	r0, r4
    5a54:	f7ff ffd0 	bl	59f8 <lv_task_del>
    5a58:	e004      	b.n	5a64 <lv_task_exec+0x3c>
        if(task->task_cb) task->task_cb(task);
    5a5a:	4620      	mov	r0, r4
    5a5c:	4798      	blx	r3
        if(task_deleted == false) { /*The task might be deleted by itself as well*/
    5a5e:	782b      	ldrb	r3, [r5, #0]
    5a60:	2b00      	cmp	r3, #0
    5a62:	d0f3      	beq.n	5a4c <lv_task_exec+0x24>
                lv_task_del(task);
    5a64:	2001      	movs	r0, #1
        }
        exec = true;
    }

    return exec;
}
    5a66:	bd38      	pop	{r3, r4, r5, pc}
    bool exec = false;
    5a68:	2000      	movs	r0, #0
    5a6a:	e7fc      	b.n	5a66 <lv_task_exec+0x3e>
    5a6c:	20008b8f 	.word	0x20008b8f
    5a70:	20008b8e 	.word	0x20008b8e

00005a74 <lv_task_handler>:
{
    5a74:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(already_running) return;
    5a78:	4d3e      	ldr	r5, [pc, #248]	; (5b74 <lv_task_handler+0x100>)
    5a7a:	782c      	ldrb	r4, [r5, #0]
    5a7c:	b934      	cbnz	r4, 5a8c <lv_task_handler+0x18>
    already_running = true;
    5a7e:	2301      	movs	r3, #1
    5a80:	702b      	strb	r3, [r5, #0]
    if(lv_task_run == false) {
    5a82:	4b3d      	ldr	r3, [pc, #244]	; (5b78 <lv_task_handler+0x104>)
    5a84:	781b      	ldrb	r3, [r3, #0]
    5a86:	b923      	cbnz	r3, 5a92 <lv_task_handler+0x1e>
        already_running = false; /*Release mutex*/
    5a88:	2300      	movs	r3, #0
    5a8a:	702b      	strb	r3, [r5, #0]
}
    5a8c:	b003      	add	sp, #12
    5a8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    handler_start = lv_tick_get();
    5a92:	f005 fbc3 	bl	b21c <lv_tick_get>
    5a96:	4b39      	ldr	r3, [pc, #228]	; (5b7c <lv_task_handler+0x108>)
        task_deleted             = false;
    5a98:	4e39      	ldr	r6, [pc, #228]	; (5b80 <lv_task_handler+0x10c>)
    handler_start = lv_tick_get();
    5a9a:	6018      	str	r0, [r3, #0]
    lv_task_t * task_interrupter = NULL;
    5a9c:	9301      	str	r3, [sp, #4]
        task_deleted             = false;
    5a9e:	46a3      	mov	fp, r4
        task_created             = false;
    5aa0:	4f38      	ldr	r7, [pc, #224]	; (5b84 <lv_task_handler+0x110>)
        LV_GC_ROOT(_lv_task_act) = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
    5aa2:	4839      	ldr	r0, [pc, #228]	; (5b88 <lv_task_handler+0x114>)
        task_deleted             = false;
    5aa4:	f886 b000 	strb.w	fp, [r6]
        task_created             = false;
    5aa8:	f887 b000 	strb.w	fp, [r7]
        LV_GC_ROOT(_lv_task_act) = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
    5aac:	f005 fd0e 	bl	b4cc <lv_ll_get_head>
    5ab0:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 5b98 <lv_task_handler+0x124>
    5ab4:	f8c8 0000 	str.w	r0, [r8]
        while(LV_GC_ROOT(_lv_task_act)) {
    5ab8:	46c1      	mov	r9, r8
    5aba:	f8d9 1000 	ldr.w	r1, [r9]
    5abe:	b1b9      	cbz	r1, 5af0 <lv_task_handler+0x7c>
            next = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), LV_GC_ROOT(_lv_task_act));
    5ac0:	4831      	ldr	r0, [pc, #196]	; (5b88 <lv_task_handler+0x114>)
    5ac2:	f005 fd09 	bl	b4d8 <lv_ll_get_next>
    5ac6:	4682      	mov	sl, r0
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_OFF) {
    5ac8:	f8d9 0000 	ldr.w	r0, [r9]
    5acc:	7c03      	ldrb	r3, [r0, #16]
    5ace:	f013 0207 	ands.w	r2, r3, #7
    5ad2:	d00d      	beq.n	5af0 <lv_task_handler+0x7c>
            if(LV_GC_ROOT(_lv_task_act) == task_interrupter) {
    5ad4:	42a0      	cmp	r0, r4
    5ad6:	d103      	bne.n	5ae0 <lv_task_handler+0x6c>
                LV_GC_ROOT(_lv_task_act) = next;
    5ad8:	f8c9 a000 	str.w	sl, [r9]
                task_interrupter = NULL; /*From this point only task after the interrupter comes, so
    5adc:	2400      	movs	r4, #0
                continue; /*Load the next task*/
    5ade:	e7ec      	b.n	5aba <lv_task_handler+0x46>
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_HIGHEST) {
    5ae0:	2a05      	cmp	r2, #5
    5ae2:	d12b      	bne.n	5b3c <lv_task_handler+0xc8>
                lv_task_exec(LV_GC_ROOT(_lv_task_act));
    5ae4:	f7ff ffa0 	bl	5a28 <lv_task_exec>
            if(task_created || task_deleted) {
    5ae8:	4b26      	ldr	r3, [pc, #152]	; (5b84 <lv_task_handler+0x110>)
    5aea:	781b      	ldrb	r3, [r3, #0]
    5aec:	2b00      	cmp	r3, #0
    5aee:	d03a      	beq.n	5b66 <lv_task_handler+0xf2>
    busy_time += lv_tick_elaps(handler_start);
    5af0:	9b01      	ldr	r3, [sp, #4]
    5af2:	4c26      	ldr	r4, [pc, #152]	; (5b8c <lv_task_handler+0x118>)
    5af4:	6818      	ldr	r0, [r3, #0]
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
    5af6:	4e26      	ldr	r6, [pc, #152]	; (5b90 <lv_task_handler+0x11c>)
    busy_time += lv_tick_elaps(handler_start);
    5af8:	f005 fb94 	bl	b224 <lv_tick_elaps>
    5afc:	6823      	ldr	r3, [r4, #0]
    5afe:	4418      	add	r0, r3
    5b00:	6020      	str	r0, [r4, #0]
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
    5b02:	6830      	ldr	r0, [r6, #0]
    5b04:	f005 fb8e 	bl	b224 <lv_tick_elaps>
    if(idle_period_time >= IDLE_MEAS_PERIOD) {
    5b08:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
    5b0c:	d3bc      	bcc.n	5a88 <lv_task_handler+0x14>
        idle_last         = (uint32_t)((uint32_t)busy_time * 100) / IDLE_MEAS_PERIOD; /*Calculate the busy percentage*/
    5b0e:	6822      	ldr	r2, [r4, #0]
    5b10:	2364      	movs	r3, #100	; 0x64
    5b12:	4353      	muls	r3, r2
    5b14:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    5b18:	fbb3 f3f2 	udiv	r3, r3, r2
        idle_last         = idle_last > 100 ? 0 : 100 - idle_last;                    /*But we need idle time*/
    5b1c:	b2da      	uxtb	r2, r3
    5b1e:	2a64      	cmp	r2, #100	; 0x64
    5b20:	bf98      	it	ls
    5b22:	f1c3 0364 	rsbls	r3, r3, #100	; 0x64
    5b26:	4a1b      	ldr	r2, [pc, #108]	; (5b94 <lv_task_handler+0x120>)
    5b28:	bf94      	ite	ls
    5b2a:	b2db      	uxtbls	r3, r3
    5b2c:	2300      	movhi	r3, #0
    5b2e:	7013      	strb	r3, [r2, #0]
        busy_time         = 0;
    5b30:	2300      	movs	r3, #0
    5b32:	6023      	str	r3, [r4, #0]
        idle_period_start = lv_tick_get();
    5b34:	f005 fb72 	bl	b21c <lv_tick_get>
    5b38:	6030      	str	r0, [r6, #0]
    5b3a:	e7a5      	b.n	5a88 <lv_task_handler+0x14>
            else if(task_interrupter) {
    5b3c:	b134      	cbz	r4, 5b4c <lv_task_handler+0xd8>
                if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio > task_interrupter->prio) {
    5b3e:	7c22      	ldrb	r2, [r4, #16]
    5b40:	f003 0307 	and.w	r3, r3, #7
    5b44:	f002 0207 	and.w	r2, r2, #7
    5b48:	4293      	cmp	r3, r2
    5b4a:	d9cd      	bls.n	5ae8 <lv_task_handler+0x74>
                if(lv_task_exec(LV_GC_ROOT(_lv_task_act))) {
    5b4c:	f7ff ff6c 	bl	5a28 <lv_task_exec>
    5b50:	2800      	cmp	r0, #0
    5b52:	d0c9      	beq.n	5ae8 <lv_task_handler+0x74>
                    if(!task_created && !task_deleted) {
    5b54:	783b      	ldrb	r3, [r7, #0]
    5b56:	2b00      	cmp	r3, #0
    5b58:	d1ca      	bne.n	5af0 <lv_task_handler+0x7c>
    5b5a:	7833      	ldrb	r3, [r6, #0]
    5b5c:	2b00      	cmp	r3, #0
    5b5e:	d1c7      	bne.n	5af0 <lv_task_handler+0x7c>
                        task_interrupter = LV_GC_ROOT(_lv_task_act); /*Check all tasks again from the highest priority */
    5b60:	f8d8 4000 	ldr.w	r4, [r8]
                        break;
    5b64:	e79c      	b.n	5aa0 <lv_task_handler+0x2c>
            if(task_created || task_deleted) {
    5b66:	7833      	ldrb	r3, [r6, #0]
    5b68:	2b00      	cmp	r3, #0
    5b6a:	d1c1      	bne.n	5af0 <lv_task_handler+0x7c>
            LV_GC_ROOT(_lv_task_act) = next; /*Load the next task*/
    5b6c:	f8c9 a000 	str.w	sl, [r9]
    5b70:	e7a3      	b.n	5aba <lv_task_handler+0x46>
    5b72:	bf00      	nop
    5b74:	20008b8b 	.word	0x20008b8b
    5b78:	20008b8d 	.word	0x20008b8d
    5b7c:	20000624 	.word	0x20000624
    5b80:	20008b8f 	.word	0x20008b8f
    5b84:	20008b8e 	.word	0x20008b8e
    5b88:	20000664 	.word	0x20000664
    5b8c:	20000620 	.word	0x20000620
    5b90:	20000628 	.word	0x20000628
    5b94:	20008b8c 	.word	0x20008b8c
    5b98:	20000660 	.word	0x20000660

00005b9c <lv_task_set_prio>:
    if(task->prio == prio) return;
    5b9c:	7c03      	ldrb	r3, [r0, #16]
    5b9e:	f003 0307 	and.w	r3, r3, #7
    5ba2:	428b      	cmp	r3, r1
{
    5ba4:	b570      	push	{r4, r5, r6, lr}
    5ba6:	4604      	mov	r4, r0
    5ba8:	460d      	mov	r5, r1
    if(task->prio == prio) return;
    5baa:	d014      	beq.n	5bd6 <lv_task_set_prio+0x3a>
    LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i)
    5bac:	480d      	ldr	r0, [pc, #52]	; (5be4 <lv_task_set_prio+0x48>)
    5bae:	4e0d      	ldr	r6, [pc, #52]	; (5be4 <lv_task_set_prio+0x48>)
    5bb0:	f005 fc8c 	bl	b4cc <lv_ll_get_head>
    5bb4:	4602      	mov	r2, r0
    5bb6:	b132      	cbz	r2, 5bc6 <lv_task_set_prio+0x2a>
        if(i->prio <= prio) {
    5bb8:	7c13      	ldrb	r3, [r2, #16]
    5bba:	f003 0307 	and.w	r3, r3, #7
    5bbe:	429d      	cmp	r5, r3
    5bc0:	db0a      	blt.n	5bd8 <lv_task_set_prio+0x3c>
            if(i != task) lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, i);
    5bc2:	42a2      	cmp	r2, r4
    5bc4:	d003      	beq.n	5bce <lv_task_set_prio+0x32>
        lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, NULL);
    5bc6:	4621      	mov	r1, r4
    5bc8:	4806      	ldr	r0, [pc, #24]	; (5be4 <lv_task_set_prio+0x48>)
    5bca:	f005 fd0f 	bl	b5ec <lv_ll_move_before>
    task->prio = prio;
    5bce:	7c23      	ldrb	r3, [r4, #16]
    5bd0:	f365 0302 	bfi	r3, r5, #0, #3
    5bd4:	7423      	strb	r3, [r4, #16]
}
    5bd6:	bd70      	pop	{r4, r5, r6, pc}
    LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i)
    5bd8:	4611      	mov	r1, r2
    5bda:	4630      	mov	r0, r6
    5bdc:	f005 fc7c 	bl	b4d8 <lv_ll_get_next>
    5be0:	4602      	mov	r2, r0
    5be2:	e7e8      	b.n	5bb6 <lv_task_set_prio+0x1a>
    5be4:	20000664 	.word	0x20000664

00005be8 <lv_mem_alloc>:
 * Allocate a memory dynamically
 * @param size size of the memory to allocate in bytes
 * @return pointer to the allocated memory
 */
void * lv_mem_alloc(size_t size)
{
    5be8:	b538      	push	{r3, r4, r5, lr}
    if(size == 0) {
    5bea:	4604      	mov	r4, r0
    5bec:	b198      	cbz	r0, 5c16 <lv_mem_alloc+0x2e>
        size = size & (~0x7);
        size += 8;
    }
#else
    /*Round the size up to 4*/
    if(size & 0x3) {
    5bee:	0783      	lsls	r3, r0, #30
        size = size & (~0x3);
    5bf0:	bf1c      	itt	ne
    5bf2:	f020 0403 	bicne.w	r4, r0, #3
        size += 4;
    5bf6:	3404      	addne	r4, #4
/*Use custom, user defined malloc function*/
#if LV_ENABLE_GC == 1 /*gc must not include header*/
    alloc = LV_MEM_CUSTOM_ALLOC(size);
#else                 /* LV_ENABLE_GC */
    /*Allocate a header too to store the size*/
    alloc = LV_MEM_CUSTOM_ALLOC(size + sizeof(lv_mem_header_t));
    5bf8:	1d20      	adds	r0, r4, #4
    5bfa:	f001 fc25 	bl	7448 <k_malloc>
    if(alloc != NULL) {
    5bfe:	4605      	mov	r5, r0
    5c00:	b158      	cbz	r0, 5c1a <lv_mem_alloc+0x32>
        ((lv_mem_ent_t *)alloc)->header.s.d_size = size;
    5c02:	6803      	ldr	r3, [r0, #0]
    5c04:	f364 035f 	bfi	r3, r4, #1, #31
    5c08:	6003      	str	r3, [r0, #0]
        ((lv_mem_ent_t *)alloc)->header.s.used   = 1;
    5c0a:	f043 0301 	orr.w	r3, r3, #1
    5c0e:	f805 3b04 	strb.w	r3, [r5], #4
#endif

    if(alloc == NULL) LV_LOG_WARN("Couldn't allocate memory");

    return alloc;
}
    5c12:	4628      	mov	r0, r5
    5c14:	bd38      	pop	{r3, r4, r5, pc}
        return &zero_mem;
    5c16:	4d04      	ldr	r5, [pc, #16]	; (5c28 <lv_mem_alloc+0x40>)
    5c18:	e7fb      	b.n	5c12 <lv_mem_alloc+0x2a>
    if(alloc == NULL) LV_LOG_WARN("Couldn't allocate memory");
    5c1a:	4b04      	ldr	r3, [pc, #16]	; (5c2c <lv_mem_alloc+0x44>)
    5c1c:	4904      	ldr	r1, [pc, #16]	; (5c30 <lv_mem_alloc+0x48>)
    5c1e:	22a7      	movs	r2, #167	; 0xa7
    5c20:	2002      	movs	r0, #2
    5c22:	f000 f9a3 	bl	5f6c <lv_log_add>
    5c26:	e7f4      	b.n	5c12 <lv_mem_alloc+0x2a>
    5c28:	2000062c 	.word	0x2000062c
    5c2c:	00045c68 	.word	0x00045c68
    5c30:	00045c81 	.word	0x00045c81

00005c34 <lv_mem_free>:
 * Free an allocated data
 * @param data pointer to an allocated memory
 */
void lv_mem_free(const void * data)
{
    if(data == &zero_mem) return;
    5c34:	4b06      	ldr	r3, [pc, #24]	; (5c50 <lv_mem_free+0x1c>)
    5c36:	4298      	cmp	r0, r3
    5c38:	d008      	beq.n	5c4c <lv_mem_free+0x18>
    if(data == NULL) return;
    5c3a:	b138      	cbz	r0, 5c4c <lv_mem_free+0x18>
#endif

#if LV_ENABLE_GC == 0
    /*e points to the header*/
    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));
    e->header.s.used = 0;
    5c3c:	f810 3c04 	ldrb.w	r3, [r0, #-4]
    5c40:	f36f 0300 	bfc	r3, #0, #1
    5c44:	f800 3d04 	strb.w	r3, [r0, #-4]!
        e_next = ent_get_next(e_next);
    }
#endif
#else /*Use custom, user defined free function*/
#if LV_ENABLE_GC == 0
    LV_MEM_CUSTOM_FREE(e);
    5c48:	f006 b819 	b.w	bc7e <k_free>
#else
    LV_MEM_CUSTOM_FREE((void *)data);
#endif /*LV_ENABLE_GC*/
#endif
}
    5c4c:	4770      	bx	lr
    5c4e:	bf00      	nop
    5c50:	2000062c 	.word	0x2000062c

00005c54 <lv_mem_get_size>:

#if LV_ENABLE_GC == 0

uint32_t lv_mem_get_size(const void * data)
{
    if(data == NULL) return 0;
    5c54:	b140      	cbz	r0, 5c68 <lv_mem_get_size+0x14>
    if(data == &zero_mem) return 0;
    5c56:	4b05      	ldr	r3, [pc, #20]	; (5c6c <lv_mem_get_size+0x18>)
    5c58:	4298      	cmp	r0, r3
    5c5a:	d004      	beq.n	5c66 <lv_mem_get_size+0x12>

    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));

    return e->header.s.d_size;
    5c5c:	f850 0c04 	ldr.w	r0, [r0, #-4]
    5c60:	f3c0 005e 	ubfx	r0, r0, #1, #31
    5c64:	4770      	bx	lr
    if(data == NULL) return 0;
    5c66:	2000      	movs	r0, #0
}
    5c68:	4770      	bx	lr
    5c6a:	bf00      	nop
    5c6c:	2000062c 	.word	0x2000062c

00005c70 <lv_mem_realloc>:
{
    5c70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5c72:	460d      	mov	r5, r1
    if(data_p != NULL) {
    5c74:	4604      	mov	r4, r0
    5c76:	b130      	cbz	r0, 5c86 <lv_mem_realloc+0x16>
        if(e->header.s.used == 0) {
    5c78:	f810 3c04 	ldrb.w	r3, [r0, #-4]
            data_p = NULL;
    5c7c:	f013 0f01 	tst.w	r3, #1
    5c80:	bf14      	ite	ne
    5c82:	4604      	movne	r4, r0
    5c84:	2400      	moveq	r4, #0
    uint32_t old_size = lv_mem_get_size(data_p);
    5c86:	4620      	mov	r0, r4
    5c88:	f7ff ffe4 	bl	5c54 <lv_mem_get_size>
    if(old_size == new_size) return data_p; /*Also avoid reallocating the same memory*/
    5c8c:	42a8      	cmp	r0, r5
    uint32_t old_size = lv_mem_get_size(data_p);
    5c8e:	4606      	mov	r6, r0
    if(old_size == new_size) return data_p; /*Also avoid reallocating the same memory*/
    5c90:	d012      	beq.n	5cb8 <lv_mem_realloc+0x48>
    new_p = lv_mem_alloc(new_size);
    5c92:	4628      	mov	r0, r5
    5c94:	f7ff ffa8 	bl	5be8 <lv_mem_alloc>
    if(new_p != NULL && data_p != NULL) {
    5c98:	4607      	mov	r7, r0
    5c9a:	b178      	cbz	r0, 5cbc <lv_mem_realloc+0x4c>
    5c9c:	b154      	cbz	r4, 5cb4 <lv_mem_realloc+0x44>
        if(old_size != 0) {
    5c9e:	b14e      	cbz	r6, 5cb4 <lv_mem_realloc+0x44>
            memcpy(new_p, data_p, LV_MATH_MIN(new_size, old_size));
    5ca0:	42ae      	cmp	r6, r5
    5ca2:	4632      	mov	r2, r6
    5ca4:	4621      	mov	r1, r4
    5ca6:	bf28      	it	cs
    5ca8:	462a      	movcs	r2, r5
    5caa:	f002 fe21 	bl	88f0 <memcpy>
            lv_mem_free(data_p);
    5cae:	4620      	mov	r0, r4
    5cb0:	f7ff ffc0 	bl	5c34 <lv_mem_free>
}
    5cb4:	4638      	mov	r0, r7
    5cb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5cb8:	4627      	mov	r7, r4
    5cba:	e7fb      	b.n	5cb4 <lv_mem_realloc+0x44>
    if(new_p == NULL) LV_LOG_WARN("Couldn't allocate memory");
    5cbc:	4b03      	ldr	r3, [pc, #12]	; (5ccc <lv_mem_realloc+0x5c>)
    5cbe:	4904      	ldr	r1, [pc, #16]	; (5cd0 <lv_mem_realloc+0x60>)
    5cc0:	f44f 7281 	mov.w	r2, #258	; 0x102
    5cc4:	2002      	movs	r0, #2
    5cc6:	f000 f951 	bl	5f6c <lv_log_add>
    5cca:	e7f3      	b.n	5cb4 <lv_mem_realloc+0x44>
    5ccc:	00045c68 	.word	0x00045c68
    5cd0:	00045c81 	.word	0x00045c81

00005cd4 <lv_txt_get_width>:
 * @param flags settings for the text from 'txt_flag_t' enum
 * @return length of a char_num long text
 */
lv_coord_t lv_txt_get_width(const char * txt, uint16_t length, const lv_font_t * font, lv_coord_t letter_space,
                            lv_txt_flag_t flag)
{
    5cd4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5cd8:	4688      	mov	r8, r1
    5cda:	b085      	sub	sp, #20
    5cdc:	4617      	mov	r7, r2
    5cde:	461e      	mov	r6, r3
    if(txt == NULL) return 0;
    5ce0:	4605      	mov	r5, r0
    5ce2:	2400      	movs	r4, #0
    5ce4:	2800      	cmp	r0, #0
    5ce6:	d03f      	beq.n	5d68 <lv_txt_get_width+0x94>
    if(font == NULL) return 0;
    5ce8:	2a00      	cmp	r2, #0
    5cea:	d03f      	beq.n	5d6c <lv_txt_get_width+0x98>

    uint32_t i                   = 0;
    5cec:	9403      	str	r4, [sp, #12]
    lv_coord_t width             = 0;
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
    5cee:	f88d 400b 	strb.w	r4, [sp, #11]
    uint32_t letter;
    uint32_t letter_next;

    if(length != 0) {
    5cf2:	2900      	cmp	r1, #0
    5cf4:	d036      	beq.n	5d64 <lv_txt_get_width+0x90>
        while(i < length) {
            letter      = lv_txt_encoded_next(txt, &i);
            letter_next = lv_txt_encoded_next(&txt[i], NULL);
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    5cf6:	f89d 9038 	ldrb.w	r9, [sp, #56]	; 0x38
            letter      = lv_txt_encoded_next(txt, &i);
    5cfa:	f8df a074 	ldr.w	sl, [pc, #116]	; 5d70 <lv_txt_get_width+0x9c>
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    5cfe:	f009 0901 	and.w	r9, r9, #1
            letter      = lv_txt_encoded_next(txt, &i);
    5d02:	f8da 3000 	ldr.w	r3, [sl]
    5d06:	a903      	add	r1, sp, #12
    5d08:	4628      	mov	r0, r5
    5d0a:	4798      	blx	r3
    5d0c:	4683      	mov	fp, r0
            letter_next = lv_txt_encoded_next(&txt[i], NULL);
    5d0e:	9803      	ldr	r0, [sp, #12]
    5d10:	f8da 3000 	ldr.w	r3, [sl]
    5d14:	2100      	movs	r1, #0
    5d16:	4428      	add	r0, r5
    5d18:	4798      	blx	r3
    5d1a:	4602      	mov	r2, r0
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    5d1c:	f1b9 0f00 	cmp.w	r9, #0
    5d20:	d111      	bne.n	5d46 <lv_txt_get_width+0x72>
                if(lv_txt_is_cmd(&cmd_state, letter) != false) {
                    continue;
                }
            }

            lv_coord_t char_width = lv_font_get_glyph_width(font, letter, letter_next);
    5d22:	4659      	mov	r1, fp
    5d24:	4638      	mov	r0, r7
    5d26:	f005 ff43 	bl	bbb0 <lv_font_get_glyph_width>
    5d2a:	b200      	sxth	r0, r0
            if(char_width > 0) {
    5d2c:	2800      	cmp	r0, #0
    5d2e:	dc14      	bgt.n	5d5a <lv_txt_get_width+0x86>
        while(i < length) {
    5d30:	9b03      	ldr	r3, [sp, #12]
    5d32:	4598      	cmp	r8, r3
    5d34:	d8e5      	bhi.n	5d02 <lv_txt_get_width+0x2e>
                width += char_width;
                width += letter_space;
            }
        }

        if(width > 0) {
    5d36:	2c00      	cmp	r4, #0
    5d38:	dd01      	ble.n	5d3e <lv_txt_get_width+0x6a>
            width -= letter_space; /*Trim the last letter space. Important if the text is center
    5d3a:	1ba4      	subs	r4, r4, r6
    5d3c:	b224      	sxth	r4, r4
                                      aligned */
        }
    }

    return width;
}
    5d3e:	4620      	mov	r0, r4
    5d40:	b005      	add	sp, #20
    5d42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5d46:	9001      	str	r0, [sp, #4]
                if(lv_txt_is_cmd(&cmd_state, letter) != false) {
    5d48:	4659      	mov	r1, fp
    5d4a:	f10d 000b 	add.w	r0, sp, #11
    5d4e:	f005 fc95 	bl	b67c <lv_txt_is_cmd>
    5d52:	9a01      	ldr	r2, [sp, #4]
    5d54:	2800      	cmp	r0, #0
    5d56:	d0e4      	beq.n	5d22 <lv_txt_get_width+0x4e>
    5d58:	e7ea      	b.n	5d30 <lv_txt_get_width+0x5c>
                width += letter_space;
    5d5a:	19a3      	adds	r3, r4, r6
    5d5c:	fa00 f483 	sxtah	r4, r0, r3
    5d60:	b224      	sxth	r4, r4
    5d62:	e7e5      	b.n	5d30 <lv_txt_get_width+0x5c>
    lv_coord_t width             = 0;
    5d64:	460c      	mov	r4, r1
    5d66:	e7ea      	b.n	5d3e <lv_txt_get_width+0x6a>
    if(txt == NULL) return 0;
    5d68:	4604      	mov	r4, r0
    5d6a:	e7e8      	b.n	5d3e <lv_txt_get_width+0x6a>
    5d6c:	4614      	mov	r4, r2
    5d6e:	e7e6      	b.n	5d3e <lv_txt_get_width+0x6a>
    5d70:	2000a12c 	.word	0x2000a12c

00005d74 <lv_txt_get_next_line>:
{
    5d74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5d78:	b091      	sub	sp, #68	; 0x44
    5d7a:	4699      	mov	r9, r3
    5d7c:	f89d 3068 	ldrb.w	r3, [sp, #104]	; 0x68
    5d80:	9102      	str	r1, [sp, #8]
    5d82:	9207      	str	r2, [sp, #28]
    5d84:	9303      	str	r3, [sp, #12]
    if(txt == NULL) return 0;
    5d86:	4607      	mov	r7, r0
    5d88:	2800      	cmp	r0, #0
    5d8a:	d05a      	beq.n	5e42 <lv_txt_get_next_line+0xce>
    if(font == NULL) return 0;
    5d8c:	2900      	cmp	r1, #0
    5d8e:	f000 80de 	beq.w	5f4e <lv_txt_get_next_line+0x1da>
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
    5d92:	9b03      	ldr	r3, [sp, #12]
    5d94:	f013 0302 	ands.w	r3, r3, #2
    5d98:	9304      	str	r3, [sp, #16]
    5d9a:	f647 4318 	movw	r3, #31768	; 0x7c18
    5d9e:	bf18      	it	ne
    5da0:	4699      	movne	r9, r3
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
    5da2:	2300      	movs	r3, #0
    5da4:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    uint32_t i = 0;                                        /* Iterating index into txt */
    5da8:	930c      	str	r3, [sp, #48]	; 0x30
    while(txt[i] != '\0' && max_width > 0) {
    5daa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5dac:	9300      	str	r3, [sp, #0]
    5dae:	eb07 0b03 	add.w	fp, r7, r3
    5db2:	5cfb      	ldrb	r3, [r7, r3]
    5db4:	2b00      	cmp	r3, #0
    5db6:	d03b      	beq.n	5e30 <lv_txt_get_next_line+0xbc>
    5db8:	f1b9 0f00 	cmp.w	r9, #0
    5dbc:	dd38      	ble.n	5e30 <lv_txt_get_next_line+0xbc>
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
    5dbe:	9a04      	ldr	r2, [sp, #16]
    5dc0:	f647 4318 	movw	r3, #31768	; 0x7c18
    5dc4:	2a00      	cmp	r2, #0
    5dc6:	bf08      	it	eq
    5dc8:	464b      	moveq	r3, r9
    5dca:	9306      	str	r3, [sp, #24]
    letter = lv_txt_encoded_next(txt, &i_next);
    5dcc:	4b61      	ldr	r3, [pc, #388]	; (5f54 <lv_txt_get_next_line+0x1e0>)
    uint32_t i = 0, i_next = 0, i_next_next = 0;  /* Iterating index into txt */
    5dce:	2500      	movs	r5, #0
    letter = lv_txt_encoded_next(txt, &i_next);
    5dd0:	681b      	ldr	r3, [r3, #0]
    uint32_t i = 0, i_next = 0, i_next_next = 0;  /* Iterating index into txt */
    5dd2:	950f      	str	r5, [sp, #60]	; 0x3c
    5dd4:	e9cd 550d 	strd	r5, r5, [sp, #52]	; 0x34
    letter = lv_txt_encoded_next(txt, &i_next);
    5dd8:	a90e      	add	r1, sp, #56	; 0x38
    5dda:	4658      	mov	r0, fp
    5ddc:	4798      	blx	r3
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    5dde:	9a03      	ldr	r2, [sp, #12]
    i_next_next = i_next;
    5de0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    5de2:	930f      	str	r3, [sp, #60]	; 0x3c
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    5de4:	f002 0201 	and.w	r2, r2, #1
    letter = lv_txt_encoded_next(txt, &i_next);
    5de8:	4680      	mov	r8, r0
    uint32_t break_letter_count = 0; /* Number of characters up to the long word break point */
    5dea:	9501      	str	r5, [sp, #4]
    uint32_t break_index = NO_BREAK_FOUND; /* only used for "long" words */
    5dec:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    uint32_t word_len = 0;   /* Number of characters in the transversed word */
    5df0:	46aa      	mov	sl, r5
    lv_coord_t cur_w = 0;  /* Pixel Width of transversed string */
    5df2:	462e      	mov	r6, r5
    uint32_t letter_next = 0; /* Letter at i_next */
    5df4:	462b      	mov	r3, r5
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    5df6:	9208      	str	r2, [sp, #32]
    while(txt[i] != '\0') {
    5df8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    5dfa:	f81b 2002 	ldrb.w	r2, [fp, r2]
    5dfe:	bb1a      	cbnz	r2, 5e48 <lv_txt_get_next_line+0xd4>
    if( break_index == NO_BREAK_FOUND ) {
    5e00:	1c62      	adds	r2, r4, #1
    5e02:	d06f      	beq.n	5ee4 <lv_txt_get_next_line+0x170>
    if(word_len < LV_TXT_LINE_BREAK_LONG_LEN) {
    5e04:	f1ba 0f0b 	cmp.w	sl, #11
    5e08:	d879      	bhi.n	5efe <lv_txt_get_next_line+0x18a>
        if( force ) return break_index;
    5e0a:	9b00      	ldr	r3, [sp, #0]
    5e0c:	2b00      	cmp	r3, #0
    5e0e:	f040 8089 	bne.w	5f24 <lv_txt_get_next_line+0x1b0>
    5e12:	b2a4      	uxth	r4, r4
        max_width -= word_w;
    5e14:	eba9 0905 	sub.w	r9, r9, r5
    5e18:	fa0f f989 	sxth.w	r9, r9
        if( advance == 0 ){
    5e1c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5e1e:	2c00      	cmp	r4, #0
    5e20:	f040 8083 	bne.w	5f2a <lv_txt_get_next_line+0x1b6>
            if(i == 0) lv_txt_encoded_next(txt, &i); // prevent inf loops
    5e24:	b95b      	cbnz	r3, 5e3e <lv_txt_get_next_line+0xca>
    5e26:	4b4b      	ldr	r3, [pc, #300]	; (5f54 <lv_txt_get_next_line+0x1e0>)
    5e28:	a90c      	add	r1, sp, #48	; 0x30
    5e2a:	681b      	ldr	r3, [r3, #0]
    5e2c:	4638      	mov	r0, r7
    5e2e:	4798      	blx	r3
    if(i == 0) {
    5e30:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5e32:	b923      	cbnz	r3, 5e3e <lv_txt_get_next_line+0xca>
        lv_txt_encoded_next(txt, &i);
    5e34:	4b47      	ldr	r3, [pc, #284]	; (5f54 <lv_txt_get_next_line+0x1e0>)
    5e36:	a90c      	add	r1, sp, #48	; 0x30
    5e38:	681b      	ldr	r3, [r3, #0]
    5e3a:	4638      	mov	r0, r7
    5e3c:	4798      	blx	r3
    return i;
    5e3e:	f8bd 0030 	ldrh.w	r0, [sp, #48]	; 0x30
}
    5e42:	b011      	add	sp, #68	; 0x44
    5e44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        letter_next = lv_txt_encoded_next(txt, &i_next_next);
    5e48:	4b42      	ldr	r3, [pc, #264]	; (5f54 <lv_txt_get_next_line+0x1e0>)
    5e4a:	a90f      	add	r1, sp, #60	; 0x3c
    5e4c:	681b      	ldr	r3, [r3, #0]
    5e4e:	4658      	mov	r0, fp
    5e50:	4798      	blx	r3
        word_len++;
    5e52:	f10a 0201 	add.w	r2, sl, #1
    5e56:	9205      	str	r2, [sp, #20]
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    5e58:	9a08      	ldr	r2, [sp, #32]
        letter_next = lv_txt_encoded_next(txt, &i_next_next);
    5e5a:	4603      	mov	r3, r0
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    5e5c:	b17a      	cbz	r2, 5e7e <lv_txt_get_next_line+0x10a>
    5e5e:	9009      	str	r0, [sp, #36]	; 0x24
            if(lv_txt_is_cmd(cmd_state, letter) != false) {
    5e60:	4641      	mov	r1, r8
    5e62:	f10d 002f 	add.w	r0, sp, #47	; 0x2f
    5e66:	f005 fc09 	bl	b67c <lv_txt_is_cmd>
    5e6a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5e6c:	b138      	cbz	r0, 5e7e <lv_txt_get_next_line+0x10a>
        i = i_next;
    5e6e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    5e70:	920d      	str	r2, [sp, #52]	; 0x34
        i_next = i_next_next;
    5e72:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    5e74:	920e      	str	r2, [sp, #56]	; 0x38
        letter_next = lv_txt_encoded_next(txt, &i_next_next);
    5e76:	f8dd a014 	ldr.w	sl, [sp, #20]
    5e7a:	4698      	mov	r8, r3
    5e7c:	e7bc      	b.n	5df8 <lv_txt_get_next_line+0x84>
        letter_w = lv_font_get_glyph_width(font, letter, letter_next);
    5e7e:	461a      	mov	r2, r3
    5e80:	4641      	mov	r1, r8
    5e82:	9802      	ldr	r0, [sp, #8]
    5e84:	9309      	str	r3, [sp, #36]	; 0x24
    5e86:	f005 fe93 	bl	bbb0 <lv_font_get_glyph_width>
    5e8a:	b200      	sxth	r0, r0
        cur_w += letter_w;
    5e8c:	4406      	add	r6, r0
        if(break_index == NO_BREAK_FOUND && cur_w > max_width) {
    5e8e:	1c63      	adds	r3, r4, #1
        cur_w += letter_w;
    5e90:	b236      	sxth	r6, r6
        if(break_index == NO_BREAK_FOUND && cur_w > max_width) {
    5e92:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5e94:	d105      	bne.n	5ea2 <lv_txt_get_next_line+0x12e>
    5e96:	9a06      	ldr	r2, [sp, #24]
    5e98:	4296      	cmp	r6, r2
            break_index = i; 
    5e9a:	bfc4      	itt	gt
    5e9c:	9c0d      	ldrgt	r4, [sp, #52]	; 0x34
    5e9e:	f8cd a004 	strgt.w	sl, [sp, #4]
        if(letter == '\n' || letter == '\r' || is_break_char(letter)) {
    5ea2:	f1b8 0f0a 	cmp.w	r8, #10
    5ea6:	d017      	beq.n	5ed8 <lv_txt_get_next_line+0x164>
    5ea8:	f1b8 0f0d 	cmp.w	r8, #13
    5eac:	d014      	beq.n	5ed8 <lv_txt_get_next_line+0x164>
{
    uint8_t i;
    bool ret = false;

    /*Compare the letter to TXT_BREAK_CHARS*/
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
    5eae:	f8df c0ac 	ldr.w	ip, [pc, #172]	; 5f5c <lv_txt_get_next_line+0x1e8>
        if(letter == '\n' || letter == '\r' || is_break_char(letter)) {
    5eb2:	2200      	movs	r2, #0
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
    5eb4:	b2d1      	uxtb	r1, r2
    5eb6:	f81c 1001 	ldrb.w	r1, [ip, r1]
    5eba:	b949      	cbnz	r1, 5ed0 <lv_txt_get_next_line+0x15c>
        if( word_w_ptr != NULL && break_index == NO_BREAK_FOUND ) *word_w_ptr = cur_w;
    5ebc:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
    5ec0:	bf08      	it	eq
    5ec2:	4635      	moveq	r5, r6
        if(letter_w > 0) {
    5ec4:	2800      	cmp	r0, #0
    5ec6:	ddd2      	ble.n	5e6e <lv_txt_get_next_line+0xfa>
            cur_w += letter_space;
    5ec8:	9a07      	ldr	r2, [sp, #28]
    5eca:	4416      	add	r6, r2
    5ecc:	b236      	sxth	r6, r6
    5ece:	e7ce      	b.n	5e6e <lv_txt_get_next_line+0xfa>
        if(letter == (uint32_t)LV_TXT_BREAK_CHARS[i]) {
    5ed0:	4588      	cmp	r8, r1
    5ed2:	f102 0201 	add.w	r2, r2, #1
    5ed6:	d1ed      	bne.n	5eb4 <lv_txt_get_next_line+0x140>
            if(i == 0 && break_index == NO_BREAK_FOUND && word_w_ptr != NULL) *word_w_ptr = cur_w;
    5ed8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    5eda:	2a00      	cmp	r2, #0
    5edc:	d190      	bne.n	5e00 <lv_txt_get_next_line+0x8c>
    5ede:	1c61      	adds	r1, r4, #1
    5ee0:	d190      	bne.n	5e04 <lv_txt_get_next_line+0x90>
    5ee2:	4635      	mov	r5, r6
        if( word_len == 0 || (letter == '\r' && letter_next == '\n') ) i = i_next;
    5ee4:	f1ba 0f00 	cmp.w	sl, #0
    5ee8:	d004      	beq.n	5ef4 <lv_txt_get_next_line+0x180>
    5eea:	f1b8 0f0d 	cmp.w	r8, #13
    5eee:	d103      	bne.n	5ef8 <lv_txt_get_next_line+0x184>
    5ef0:	2b0a      	cmp	r3, #10
    5ef2:	d101      	bne.n	5ef8 <lv_txt_get_next_line+0x184>
    5ef4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    5ef6:	930d      	str	r3, [sp, #52]	; 0x34
    return i;
    5ef8:	f8bd 4034 	ldrh.w	r4, [sp, #52]	; 0x34
    5efc:	e78a      	b.n	5e14 <lv_txt_get_next_line+0xa0>
    if(break_letter_count < LV_TXT_LINE_BREAK_LONG_PRE_MIN_LEN) {
    5efe:	9b01      	ldr	r3, [sp, #4]
    5f00:	2b02      	cmp	r3, #2
    5f02:	d982      	bls.n	5e0a <lv_txt_get_next_line+0x96>
        int32_t n_move = LV_TXT_LINE_BREAK_LONG_POST_MIN_LEN - (word_len - break_letter_count);
    5f04:	9b01      	ldr	r3, [sp, #4]
        i = break_index;
    5f06:	940d      	str	r4, [sp, #52]	; 0x34
        int32_t n_move = LV_TXT_LINE_BREAK_LONG_POST_MIN_LEN - (word_len - break_letter_count);
    5f08:	3303      	adds	r3, #3
    5f0a:	eba3 0a0a 	sub.w	sl, r3, sl
        for(;n_move>0; n_move--){
    5f0e:	f1ba 0f00 	cmp.w	sl, #0
    5f12:	ddf1      	ble.n	5ef8 <lv_txt_get_next_line+0x184>
            lv_txt_encoded_prev(txt, &i);
    5f14:	4b10      	ldr	r3, [pc, #64]	; (5f58 <lv_txt_get_next_line+0x1e4>)
    5f16:	a90d      	add	r1, sp, #52	; 0x34
    5f18:	681b      	ldr	r3, [r3, #0]
    5f1a:	4658      	mov	r0, fp
    5f1c:	4798      	blx	r3
        for(;n_move>0; n_move--){
    5f1e:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
    5f22:	e7f4      	b.n	5f0e <lv_txt_get_next_line+0x19a>
        if(word_w_ptr != NULL) *word_w_ptr = 0; /* Return no word */
    5f24:	2500      	movs	r5, #0
        return 0;
    5f26:	462c      	mov	r4, r5
    5f28:	e774      	b.n	5e14 <lv_txt_get_next_line+0xa0>
        i += advance;
    5f2a:	441c      	add	r4, r3
        if(txt[0] == '\n' || txt[0] == '\r') break;
    5f2c:	783b      	ldrb	r3, [r7, #0]
        i += advance;
    5f2e:	940c      	str	r4, [sp, #48]	; 0x30
        if(txt[0] == '\n' || txt[0] == '\r') break;
    5f30:	2b0a      	cmp	r3, #10
    5f32:	f43f af7d 	beq.w	5e30 <lv_txt_get_next_line+0xbc>
    5f36:	2b0d      	cmp	r3, #13
    5f38:	f43f af7a 	beq.w	5e30 <lv_txt_get_next_line+0xbc>
        if(txt[i] == '\n' || txt[i] == '\r'){
    5f3c:	5d3b      	ldrb	r3, [r7, r4]
    5f3e:	2b0a      	cmp	r3, #10
    5f40:	d002      	beq.n	5f48 <lv_txt_get_next_line+0x1d4>
    5f42:	2b0d      	cmp	r3, #13
    5f44:	f47f af31 	bne.w	5daa <lv_txt_get_next_line+0x36>
            i++;  /* Include the following newline in the current line */
    5f48:	3401      	adds	r4, #1
    5f4a:	940c      	str	r4, [sp, #48]	; 0x30
            break;
    5f4c:	e770      	b.n	5e30 <lv_txt_get_next_line+0xbc>
    if(txt == NULL) return 0;
    5f4e:	9802      	ldr	r0, [sp, #8]
    5f50:	e777      	b.n	5e42 <lv_txt_get_next_line+0xce>
    5f52:	bf00      	nop
    5f54:	2000a12c 	.word	0x2000a12c
    5f58:	2000a130 	.word	0x2000a130
    5f5c:	00045cb6 	.word	0x00045cb6

00005f60 <lv_log_register_print_cb>:
 * and send the formatted log message to a consol or serial port.
 * @param print_cb a function pointer to print a log
 */
void lv_log_register_print_cb(lv_log_print_g_cb_t print_cb)
{
    custom_print_cb = print_cb;
    5f60:	4b01      	ldr	r3, [pc, #4]	; (5f68 <lv_log_register_print_cb+0x8>)
    5f62:	6018      	str	r0, [r3, #0]
}
    5f64:	4770      	bx	lr
    5f66:	bf00      	nop
    5f68:	20000630 	.word	0x20000630

00005f6c <lv_log_add>:
 * @param file name of the file when the log added
 * @param line line number in the source code where the log added
 * @param dsc description of the log
 */
void lv_log_add(lv_log_level_t level, const char * file, int line, const char * dsc)
{
    5f6c:	b410      	push	{r4}
    if(level >= _LV_LOG_LEVEL_NUM) return; /*Invalid level*/

    if(level >= LV_LOG_LEVEL) {
    5f6e:	1e44      	subs	r4, r0, #1
    5f70:	b2e4      	uxtb	r4, r4
    5f72:	2c03      	cmp	r4, #3
    5f74:	d805      	bhi.n	5f82 <lv_log_add+0x16>

#if LV_LOG_PRINTF
        static const char * lvl_prefix[] = {"Trace", "Info", "Warn", "Error"};
        printf("%s: %s \t(%s #%d)\n", lvl_prefix[level], dsc, file, line);
#else
        if(custom_print_cb) custom_print_cb(level, file, line, dsc);
    5f76:	4c04      	ldr	r4, [pc, #16]	; (5f88 <lv_log_add+0x1c>)
    5f78:	6824      	ldr	r4, [r4, #0]
    5f7a:	b114      	cbz	r4, 5f82 <lv_log_add+0x16>
    5f7c:	46a4      	mov	ip, r4
#endif
    }
}
    5f7e:	bc10      	pop	{r4}
        if(custom_print_cb) custom_print_cb(level, file, line, dsc);
    5f80:	4760      	bx	ip
}
    5f82:	bc10      	pop	{r4}
    5f84:	4770      	bx	lr
    5f86:	bf00      	nop
    5f88:	20000630 	.word	0x20000630

00005f8c <lv_label_revert_dots>:

    lv_obj_invalidate(label);
}

static void lv_label_revert_dots(lv_obj_t * label)
{
    5f8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5f90:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    5f92:	f003 fe9c 	bl	9cce <lv_obj_get_ext_attr>
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
    5f96:	7b83      	ldrb	r3, [r0, #14]
    5f98:	f003 0307 	and.w	r3, r3, #7
    5f9c:	2b02      	cmp	r3, #2
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    5f9e:	4604      	mov	r4, r0
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
    5fa0:	d126      	bne.n	5ff0 <lv_label_revert_dots+0x64>
    if(ext->dot_end == LV_LABEL_DOT_END_INV) return;
    5fa2:	8901      	ldrh	r1, [r0, #8]
    5fa4:	f64f 73ff 	movw	r3, #65535	; 0xffff
    5fa8:	4299      	cmp	r1, r3
    5faa:	d021      	beq.n	5ff0 <lv_label_revert_dots+0x64>
    uint32_t letter_i = ext->dot_end - LV_LABEL_DOT_NUM;
    uint32_t byte_i   = lv_txt_encoded_get_byte_id(ext->text, letter_i);
    5fac:	4b12      	ldr	r3, [pc, #72]	; (5ff8 <lv_label_revert_dots+0x6c>)
    5fae:	6800      	ldr	r0, [r0, #0]
    5fb0:	681b      	ldr	r3, [r3, #0]
    5fb2:	3903      	subs	r1, #3
    5fb4:	4798      	blx	r3
    5fb6:	4680      	mov	r8, r0
 * @param label pointer to label object
 * @return char pointer to a stored characters. Is *not* necessarily NULL-terminated.
 */
static char * lv_label_get_dot_tmp(lv_obj_t * label)
{
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    5fb8:	4628      	mov	r0, r5
    5fba:	f003 fe88 	bl	9cce <lv_obj_get_ext_attr>
    if(ext->dot_tmp_alloc) {
    5fbe:	7bc3      	ldrb	r3, [r0, #15]
    5fc0:	079b      	lsls	r3, r3, #30
        return ext->dot.tmp_ptr;
    5fc2:	bf4c      	ite	mi
    5fc4:	6840      	ldrmi	r0, [r0, #4]
    } else {
        return ext->dot.tmp;
    5fc6:	3004      	addpl	r0, #4
    while(ext->text[byte_i + i] != '\0') {
    5fc8:	2100      	movs	r1, #0
    5fca:	b2ce      	uxtb	r6, r1
    5fcc:	eb06 0308 	add.w	r3, r6, r8
    5fd0:	6822      	ldr	r2, [r4, #0]
    5fd2:	5d86      	ldrb	r6, [r0, r6]
    5fd4:	f812 c003 	ldrb.w	ip, [r2, r3]
    5fd8:	18d7      	adds	r7, r2, r3
    5fda:	3101      	adds	r1, #1
    5fdc:	f1bc 0f00 	cmp.w	ip, #0
    5fe0:	d108      	bne.n	5ff4 <lv_label_revert_dots+0x68>
    ext->text[byte_i + i] = dot_tmp[i];
    5fe2:	703e      	strb	r6, [r7, #0]
    lv_label_dot_tmp_free(label);
    5fe4:	4628      	mov	r0, r5
    5fe6:	f005 fbd9 	bl	b79c <lv_label_dot_tmp_free>
    ext->dot_end = LV_LABEL_DOT_END_INV;
    5fea:	f64f 73ff 	movw	r3, #65535	; 0xffff
    5fee:	8123      	strh	r3, [r4, #8]
}
    5ff0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ext->text[byte_i + i] = dot_tmp[i];
    5ff4:	54d6      	strb	r6, [r2, r3]
        i++;
    5ff6:	e7e8      	b.n	5fca <lv_label_revert_dots+0x3e>
    5ff8:	2000a124 	.word	0x2000a124

00005ffc <lv_label_set_dot_tmp>:
{
    5ffc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5ffe:	4616      	mov	r6, r2
    6000:	4604      	mov	r4, r0
    6002:	460f      	mov	r7, r1
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    6004:	f003 fe63 	bl	9cce <lv_obj_get_ext_attr>
    6008:	4605      	mov	r5, r0
    lv_label_dot_tmp_free(label); /* Deallocate any existing space */
    600a:	4620      	mov	r0, r4
    600c:	f005 fbc6 	bl	b79c <lv_label_dot_tmp_free>
    if(len > sizeof(char *)) {
    6010:	2e04      	cmp	r6, #4
    6012:	d91b      	bls.n	604c <lv_label_set_dot_tmp+0x50>
        ext->dot.tmp_ptr = lv_mem_alloc(len + 1);
    6014:	1c70      	adds	r0, r6, #1
    6016:	f7ff fde7 	bl	5be8 <lv_mem_alloc>
    601a:	4604      	mov	r4, r0
    601c:	6068      	str	r0, [r5, #4]
        if(ext->dot.tmp_ptr == NULL) {
    601e:	b940      	cbnz	r0, 6032 <lv_label_set_dot_tmp+0x36>
            LV_LOG_ERROR("Failed to allocate memory for dot_tmp_ptr");
    6020:	2003      	movs	r0, #3
    6022:	4b0f      	ldr	r3, [pc, #60]	; (6060 <lv_label_set_dot_tmp+0x64>)
    6024:	490f      	ldr	r1, [pc, #60]	; (6064 <lv_label_set_dot_tmp+0x68>)
    6026:	f240 526e 	movw	r2, #1390	; 0x56e
    602a:	f7ff ff9f 	bl	5f6c <lv_log_add>
    602e:	4620      	mov	r0, r4
}
    6030:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        memcpy(ext->dot.tmp_ptr, data, len);
    6032:	4632      	mov	r2, r6
    6034:	4639      	mov	r1, r7
    6036:	f002 fc5b 	bl	88f0 <memcpy>
        ext->dot.tmp_ptr[len] = '\0';
    603a:	686b      	ldr	r3, [r5, #4]
    603c:	2200      	movs	r2, #0
    603e:	559a      	strb	r2, [r3, r6]
        ext->dot_tmp_alloc    = true;
    6040:	7beb      	ldrb	r3, [r5, #15]
    6042:	f043 0302 	orr.w	r3, r3, #2
    6046:	73eb      	strb	r3, [r5, #15]
    return true;
    6048:	2001      	movs	r0, #1
    604a:	e7f1      	b.n	6030 <lv_label_set_dot_tmp+0x34>
        ext->dot_tmp_alloc = false;
    604c:	7beb      	ldrb	r3, [r5, #15]
    604e:	f36f 0341 	bfc	r3, #1, #1
    6052:	73eb      	strb	r3, [r5, #15]
        memcpy(ext->dot.tmp, data, len);
    6054:	4632      	mov	r2, r6
    6056:	4639      	mov	r1, r7
    6058:	1d28      	adds	r0, r5, #4
    605a:	f002 fc49 	bl	88f0 <memcpy>
    605e:	e7f3      	b.n	6048 <lv_label_set_dot_tmp+0x4c>
    6060:	00045cd1 	.word	0x00045cd1
    6064:	00045cfb 	.word	0x00045cfb

00006068 <lv_label_get_letter_on>:
{
    6068:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    606c:	b08b      	sub	sp, #44	; 0x2c
    606e:	4680      	mov	r8, r0
    6070:	9107      	str	r1, [sp, #28]
    const char * txt         = lv_label_get_text(label);
    6072:	f005 fbce 	bl	b812 <lv_label_get_text>
    6076:	9003      	str	r0, [sp, #12]
    lv_label_ext_t * ext     = lv_obj_get_ext_attr(label);
    6078:	4640      	mov	r0, r8
    607a:	f003 fe28 	bl	9cce <lv_obj_get_ext_attr>
    607e:	4604      	mov	r4, r0
    lv_coord_t max_w         = lv_obj_get_width(label);
    6080:	4640      	mov	r0, r8
    6082:	f003 fdb6 	bl	9bf2 <lv_obj_get_width>
    6086:	9005      	str	r0, [sp, #20]
    const lv_style_t * style = lv_obj_get_style(label);
    6088:	4640      	mov	r0, r8
    608a:	f7fd febf 	bl	3e0c <lv_obj_get_style>
    const lv_font_t * font   = style->text.font;
    608e:	6b43      	ldr	r3, [r0, #52]	; 0x34
    6090:	9304      	str	r3, [sp, #16]
    uint8_t letter_height    = lv_font_get_line_height(font);
    6092:	7a1b      	ldrb	r3, [r3, #8]
    6094:	9306      	str	r3, [sp, #24]
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
    6096:	7ba3      	ldrb	r3, [r4, #14]
    const lv_style_t * style = lv_obj_get_style(label);
    6098:	4683      	mov	fp, r0
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
    609a:	f3c3 1680 	ubfx	r6, r3, #6, #1
    lv_label_align_t align = lv_label_get_align(label);
    609e:	4640      	mov	r0, r8
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
    60a0:	061b      	lsls	r3, r3, #24
    60a2:	bf48      	it	mi
    60a4:	f046 0602 	orrmi.w	r6, r6, #2
    lv_label_align_t align = lv_label_get_align(label);
    60a8:	f005 fbbf 	bl	b82a <lv_label_get_align>
    if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
    60ac:	2801      	cmp	r0, #1
    lv_label_align_t align = lv_label_get_align(label);
    60ae:	4681      	mov	r9, r0
    if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
    60b0:	d113      	bne.n	60da <lv_label_get_letter_on+0x72>
    60b2:	f046 0604 	orr.w	r6, r6, #4
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
    60b6:	7ba3      	ldrb	r3, [r4, #14]
        max_w = LV_COORD_MAX;
    60b8:	9a05      	ldr	r2, [sp, #20]
    60ba:	f013 0f07 	tst.w	r3, #7
    60be:	f647 4318 	movw	r3, #31768	; 0x7c18
    60c2:	bf08      	it	eq
    60c4:	461a      	moveq	r2, r3
    60c6:	f04f 0a00 	mov.w	sl, #0
    60ca:	9205      	str	r2, [sp, #20]
    60cc:	4655      	mov	r5, sl
    while(txt[line_start] != '\0') {
    60ce:	9b03      	ldr	r3, [sp, #12]
    60d0:	195f      	adds	r7, r3, r5
    60d2:	5d5b      	ldrb	r3, [r3, r5]
    60d4:	b933      	cbnz	r3, 60e4 <lv_label_get_letter_on+0x7c>
    60d6:	462c      	mov	r4, r5
    60d8:	e021      	b.n	611e <lv_label_get_letter_on+0xb6>
    if(align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
    60da:	2802      	cmp	r0, #2
    60dc:	bf08      	it	eq
    60de:	f046 0608 	orreq.w	r6, r6, #8
    60e2:	e7e8      	b.n	60b6 <lv_label_get_letter_on+0x4e>
        new_line_start += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, max_w, flag);
    60e4:	f9bb 2038 	ldrsh.w	r2, [fp, #56]	; 0x38
    60e8:	9600      	str	r6, [sp, #0]
    60ea:	e9dd 1304 	ldrd	r1, r3, [sp, #16]
    60ee:	4638      	mov	r0, r7
    60f0:	f7ff fe40 	bl	5d74 <lv_txt_get_next_line>
        if(pos->y <= y + letter_height) {
    60f4:	9b07      	ldr	r3, [sp, #28]
    60f6:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
    60fa:	9b06      	ldr	r3, [sp, #24]
    60fc:	4453      	add	r3, sl
    60fe:	429a      	cmp	r2, r3
        new_line_start += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, max_w, flag);
    6100:	eb00 0405 	add.w	r4, r0, r5
        if(pos->y <= y + letter_height) {
    6104:	dc3a      	bgt.n	617c <lv_label_get_letter_on+0x114>
            letter = lv_txt_encoded_prev(txt, &tmp);
    6106:	4b4c      	ldr	r3, [pc, #304]	; (6238 <lv_label_get_letter_on+0x1d0>)
            uint32_t tmp = new_line_start;
    6108:	9409      	str	r4, [sp, #36]	; 0x24
            letter = lv_txt_encoded_prev(txt, &tmp);
    610a:	681b      	ldr	r3, [r3, #0]
    610c:	9803      	ldr	r0, [sp, #12]
    610e:	a909      	add	r1, sp, #36	; 0x24
    6110:	4798      	blx	r3
            if(letter != '\n' && txt[new_line_start] == '\0' ) new_line_start++;
    6112:	280a      	cmp	r0, #10
    6114:	d003      	beq.n	611e <lv_label_get_letter_on+0xb6>
    6116:	9b03      	ldr	r3, [sp, #12]
    6118:	5d1b      	ldrb	r3, [r3, r4]
    611a:	b903      	cbnz	r3, 611e <lv_label_get_letter_on+0xb6>
    611c:	3401      	adds	r4, #1
    if(align == LV_LABEL_ALIGN_CENTER) {
    611e:	f1b9 0f01 	cmp.w	r9, #1
    6122:	d134      	bne.n	618e <lv_label_get_letter_on+0x126>
        line_w = lv_txt_get_width(bidi_txt, new_line_start - line_start, font, style->text.letter_space, flag);
    6124:	1b61      	subs	r1, r4, r5
    6126:	f9bb 3038 	ldrsh.w	r3, [fp, #56]	; 0x38
    612a:	9a04      	ldr	r2, [sp, #16]
    612c:	9600      	str	r6, [sp, #0]
    612e:	b289      	uxth	r1, r1
    6130:	4638      	mov	r0, r7
    6132:	f7ff fdcf 	bl	5cd4 <lv_txt_get_width>
    6136:	4681      	mov	r9, r0
        x += lv_obj_get_width(label) / 2 - line_w / 2;
    6138:	4640      	mov	r0, r8
    613a:	f003 fd5a 	bl	9bf2 <lv_obj_get_width>
    613e:	eb09 79d9 	add.w	r9, r9, r9, lsr #31
    6142:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
    6146:	ea4f 0969 	mov.w	r9, r9, asr #1
    614a:	ebc9 0960 	rsb	r9, r9, r0, asr #1
    614e:	fa0f f889 	sxth.w	r8, r9
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
    6152:	2300      	movs	r3, #0
    6154:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    uint32_t i = 0;
    6158:	9309      	str	r3, [sp, #36]	; 0x24
    if(new_line_start > 0) {
    615a:	2c00      	cmp	r4, #0
    615c:	d165      	bne.n	622a <lv_label_get_letter_on+0x1c2>
    logical_pos = lv_txt_encoded_get_char_id(bidi_txt, i);
    615e:	4e37      	ldr	r6, [pc, #220]	; (623c <lv_label_get_letter_on+0x1d4>)
    6160:	9909      	ldr	r1, [sp, #36]	; 0x24
    6162:	6833      	ldr	r3, [r6, #0]
    6164:	4638      	mov	r0, r7
    6166:	4798      	blx	r3
    return  logical_pos + lv_txt_encoded_get_char_id(txt, line_start);
    6168:	6833      	ldr	r3, [r6, #0]
    logical_pos = lv_txt_encoded_get_char_id(bidi_txt, i);
    616a:	4604      	mov	r4, r0
    return  logical_pos + lv_txt_encoded_get_char_id(txt, line_start);
    616c:	4629      	mov	r1, r5
    616e:	9803      	ldr	r0, [sp, #12]
    6170:	4798      	blx	r3
    6172:	4420      	add	r0, r4
}
    6174:	b280      	uxth	r0, r0
    6176:	b00b      	add	sp, #44	; 0x2c
    6178:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        y += letter_height + style->text.line_space;
    617c:	f8bb 303a 	ldrh.w	r3, [fp, #58]	; 0x3a
    6180:	9a06      	ldr	r2, [sp, #24]
    6182:	4413      	add	r3, r2
    6184:	449a      	add	sl, r3
    6186:	fa0f fa8a 	sxth.w	sl, sl
        new_line_start += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, max_w, flag);
    618a:	4625      	mov	r5, r4
    618c:	e79f      	b.n	60ce <lv_label_get_letter_on+0x66>
    else if(align == LV_LABEL_ALIGN_RIGHT) {
    618e:	f1b9 0f02 	cmp.w	r9, #2
    6192:	d111      	bne.n	61b8 <lv_label_get_letter_on+0x150>
        line_w = lv_txt_get_width(bidi_txt, new_line_start - line_start, font, style->text.letter_space, flag);
    6194:	1b61      	subs	r1, r4, r5
    6196:	f9bb 3038 	ldrsh.w	r3, [fp, #56]	; 0x38
    619a:	9a04      	ldr	r2, [sp, #16]
    619c:	9600      	str	r6, [sp, #0]
    619e:	b289      	uxth	r1, r1
    61a0:	4638      	mov	r0, r7
    61a2:	f7ff fd97 	bl	5cd4 <lv_txt_get_width>
    61a6:	4681      	mov	r9, r0
        x += lv_obj_get_width(label) - line_w;
    61a8:	4640      	mov	r0, r8
    61aa:	f003 fd22 	bl	9bf2 <lv_obj_get_width>
    61ae:	eba0 0009 	sub.w	r0, r0, r9
    61b2:	fa0f f880 	sxth.w	r8, r0
    61b6:	e7cc      	b.n	6152 <lv_label_get_letter_on+0xea>
    lv_coord_t x = 0;
    61b8:	f04f 0800 	mov.w	r8, #0
    61bc:	e7c9      	b.n	6152 <lv_label_get_letter_on+0xea>
                if(lv_txt_is_cmd(&cmd_state, bidi_txt[i]) != false) {
    61be:	9b09      	ldr	r3, [sp, #36]	; 0x24
    61c0:	9006      	str	r0, [sp, #24]
    61c2:	5cf9      	ldrb	r1, [r7, r3]
    61c4:	f10d 0023 	add.w	r0, sp, #35	; 0x23
    61c8:	f005 fa58 	bl	b67c <lv_txt_is_cmd>
    61cc:	9a06      	ldr	r2, [sp, #24]
    61ce:	b190      	cbz	r0, 61f6 <lv_label_get_letter_on+0x18e>
        while(i + line_start < new_line_start) {
    61d0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    61d2:	442b      	add	r3, r5
    61d4:	42a3      	cmp	r3, r4
    61d6:	d2c2      	bcs.n	615e <lv_label_get_letter_on+0xf6>
            letter = lv_txt_encoded_next(bidi_txt, &i);
    61d8:	f8d9 3000 	ldr.w	r3, [r9]
    61dc:	a909      	add	r1, sp, #36	; 0x24
    61de:	4638      	mov	r0, r7
    61e0:	4798      	blx	r3
    61e2:	9005      	str	r0, [sp, #20]
            letter_next = lv_txt_encoded_next(&bidi_txt[i], NULL);
    61e4:	9809      	ldr	r0, [sp, #36]	; 0x24
    61e6:	f8d9 3000 	ldr.w	r3, [r9]
    61ea:	2100      	movs	r1, #0
    61ec:	4438      	add	r0, r7
    61ee:	4798      	blx	r3
    61f0:	4602      	mov	r2, r0
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    61f2:	2e00      	cmp	r6, #0
    61f4:	d1e3      	bne.n	61be <lv_label_get_letter_on+0x156>
            x += lv_font_get_glyph_width(font, letter, letter_next);
    61f6:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    61fa:	f005 fcd9 	bl	bbb0 <lv_font_get_glyph_width>
            if(pos->x < x || i + line_start == new_line_start) {
    61fe:	9b07      	ldr	r3, [sp, #28]
            x += lv_font_get_glyph_width(font, letter, letter_next);
    6200:	4480      	add	r8, r0
            if(pos->x < x || i + line_start == new_line_start) {
    6202:	f9b3 3000 	ldrsh.w	r3, [r3]
            x += lv_font_get_glyph_width(font, letter, letter_next);
    6206:	fa0f f888 	sxth.w	r8, r8
            if(pos->x < x || i + line_start == new_line_start) {
    620a:	4543      	cmp	r3, r8
    620c:	da02      	bge.n	6214 <lv_label_get_letter_on+0x1ac>
                i = i_act;
    620e:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
                break;
    6212:	e7a4      	b.n	615e <lv_label_get_letter_on+0xf6>
            if(pos->x < x || i + line_start == new_line_start) {
    6214:	9b09      	ldr	r3, [sp, #36]	; 0x24
    6216:	195a      	adds	r2, r3, r5
    6218:	42a2      	cmp	r2, r4
    621a:	d0f8      	beq.n	620e <lv_label_get_letter_on+0x1a6>
            x += style->text.letter_space;
    621c:	f8bb 0038 	ldrh.w	r0, [fp, #56]	; 0x38
    6220:	4480      	add	r8, r0
    6222:	fa0f f888 	sxth.w	r8, r8
            i_act = i;
    6226:	469a      	mov	sl, r3
    6228:	e7d2      	b.n	61d0 <lv_label_get_letter_on+0x168>
    uint32_t i_act = i;
    622a:	469a      	mov	sl, r3
            letter = lv_txt_encoded_next(bidi_txt, &i);
    622c:	f8df 9010 	ldr.w	r9, [pc, #16]	; 6240 <lv_label_get_letter_on+0x1d8>
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    6230:	f006 0601 	and.w	r6, r6, #1
    6234:	e7cc      	b.n	61d0 <lv_label_get_letter_on+0x168>
    6236:	bf00      	nop
    6238:	2000a130 	.word	0x2000a130
    623c:	2000a128 	.word	0x2000a128
    6240:	2000a12c 	.word	0x2000a12c

00006244 <lv_label_refr_text>:
{
    6244:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6248:	b089      	sub	sp, #36	; 0x24
    624a:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    624c:	f003 fd3f 	bl	9cce <lv_obj_get_ext_attr>
    if(ext->text == NULL) return;
    6250:	6803      	ldr	r3, [r0, #0]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    6252:	4604      	mov	r4, r0
    if(ext->text == NULL) return;
    6254:	b373      	cbz	r3, 62b4 <lv_label_refr_text+0x70>
    lv_coord_t max_w         = lv_obj_get_width(label);
    6256:	4628      	mov	r0, r5
    6258:	f003 fccb 	bl	9bf2 <lv_obj_get_width>
    625c:	4607      	mov	r7, r0
    const lv_style_t * style = lv_obj_get_style(label);
    625e:	4628      	mov	r0, r5
    6260:	f7fd fdd4 	bl	3e0c <lv_obj_get_style>
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
    6264:	7ba3      	ldrb	r3, [r4, #14]
    const lv_font_t * font   = style->text.font;
    6266:	6b42      	ldr	r2, [r0, #52]	; 0x34
        max_w = LV_COORD_MAX;
    6268:	f013 0f07 	tst.w	r3, #7
    626c:	f647 4118 	movw	r1, #31768	; 0x7c18
    6270:	bf08      	it	eq
    6272:	460f      	moveq	r7, r1
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
    6274:	f3c3 1180 	ubfx	r1, r3, #6, #1
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
    6278:	061b      	lsls	r3, r3, #24
    627a:	bf48      	it	mi
    627c:	f041 0102 	orrmi.w	r1, r1, #2
    lv_txt_get_size(&size, ext->text, font, style->text.letter_space, style->text.line_space, max_w, flag);
    6280:	f9b0 3038 	ldrsh.w	r3, [r0, #56]	; 0x38
    6284:	e9cd 7101 	strd	r7, r1, [sp, #4]
    6288:	f9b0 103a 	ldrsh.w	r1, [r0, #58]	; 0x3a
    628c:	9100      	str	r1, [sp, #0]
    const lv_style_t * style = lv_obj_get_style(label);
    628e:	4606      	mov	r6, r0
    lv_txt_get_size(&size, ext->text, font, style->text.letter_space, style->text.line_space, max_w, flag);
    6290:	6821      	ldr	r1, [r4, #0]
    6292:	a805      	add	r0, sp, #20
    6294:	f005 fa0f 	bl	b6b6 <lv_txt_get_size>
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
    6298:	7ba3      	ldrb	r3, [r4, #14]
    629a:	f013 0307 	ands.w	r3, r3, #7
    629e:	d10c      	bne.n	62ba <lv_label_refr_text+0x76>
        lv_obj_set_size(label, size.x, size.y);
    62a0:	f9bd 2016 	ldrsh.w	r2, [sp, #22]
    62a4:	f9bd 1014 	ldrsh.w	r1, [sp, #20]
    62a8:	4628      	mov	r0, r5
    62aa:	f003 faeb 	bl	9884 <lv_obj_set_size>
    lv_obj_invalidate(label);
    62ae:	4628      	mov	r0, r5
    62b0:	f003 fa46 	bl	9740 <lv_obj_invalidate>
}
    62b4:	b009      	add	sp, #36	; 0x24
    62b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    else if(ext->long_mode == LV_LABEL_LONG_SROLL) {
    62ba:	1eda      	subs	r2, r3, #3
    62bc:	2a01      	cmp	r2, #1
    62be:	d9f6      	bls.n	62ae <lv_label_refr_text+0x6a>
    } else if(ext->long_mode == LV_LABEL_LONG_DOT) {
    62c0:	2b02      	cmp	r3, #2
    62c2:	d16e      	bne.n	63a2 <lv_label_refr_text+0x15e>
        if(size.y <= lv_obj_get_height(label)) { /*No dots are required, the text is short enough*/
    62c4:	4628      	mov	r0, r5
    62c6:	f9bd 7016 	ldrsh.w	r7, [sp, #22]
    62ca:	f003 fc98 	bl	9bfe <lv_obj_get_height>
    62ce:	4287      	cmp	r7, r0
    62d0:	dc03      	bgt.n	62da <lv_label_refr_text+0x96>
            ext->dot_end = LV_LABEL_DOT_END_INV;
    62d2:	f64f 73ff 	movw	r3, #65535	; 0xffff
    62d6:	8123      	strh	r3, [r4, #8]
    62d8:	e7e9      	b.n	62ae <lv_label_refr_text+0x6a>
        } else if(lv_txt_get_encoded_length(ext->text) <= LV_LABEL_DOT_NUM) { /*Don't turn to dots all the characters*/
    62da:	4b36      	ldr	r3, [pc, #216]	; (63b4 <lv_label_refr_text+0x170>)
    62dc:	6820      	ldr	r0, [r4, #0]
    62de:	681b      	ldr	r3, [r3, #0]
    62e0:	4798      	blx	r3
    62e2:	2803      	cmp	r0, #3
    62e4:	d9f5      	bls.n	62d2 <lv_label_refr_text+0x8e>
            p.x = lv_obj_get_width(label) -
    62e6:	4628      	mov	r0, r5
    62e8:	f003 fc83 	bl	9bf2 <lv_obj_get_width>
                  (lv_font_get_glyph_width(style->text.font, '.', '.') + style->text.letter_space) *
    62ec:	222e      	movs	r2, #46	; 0x2e
    62ee:	4611      	mov	r1, r2
            p.x = lv_obj_get_width(label) -
    62f0:	4607      	mov	r7, r0
                  (lv_font_get_glyph_width(style->text.font, '.', '.') + style->text.letter_space) *
    62f2:	6b70      	ldr	r0, [r6, #52]	; 0x34
                len += lv_txt_encoded_size(&ext->text[byte_id]);
    62f4:	f8df a0c4 	ldr.w	sl, [pc, #196]	; 63bc <lv_label_refr_text+0x178>
                lv_txt_encoded_next(ext->text, &byte_id);
    62f8:	f8df b0c4 	ldr.w	fp, [pc, #196]	; 63c0 <lv_label_refr_text+0x17c>
                  (lv_font_get_glyph_width(style->text.font, '.', '.') + style->text.letter_space) *
    62fc:	f005 fc58 	bl	bbb0 <lv_font_get_glyph_width>
    6300:	f9b6 3038 	ldrsh.w	r3, [r6, #56]	; 0x38
    6304:	4418      	add	r0, r3
            p.x = lv_obj_get_width(label) -
    6306:	eba0 0080 	sub.w	r0, r0, r0, lsl #2
    630a:	4438      	add	r0, r7
    630c:	f8ad 0018 	strh.w	r0, [sp, #24]
            p.y = lv_obj_get_height(label);
    6310:	4628      	mov	r0, r5
    6312:	f003 fc74 	bl	9bfe <lv_obj_get_height>
                   (lv_font_get_line_height(style->text.font) + style->text.line_space); /*Round down to the last line*/
    6316:	6b73      	ldr	r3, [r6, #52]	; 0x34
    6318:	f9b6 103a 	ldrsh.w	r1, [r6, #58]	; 0x3a
    631c:	7a1b      	ldrb	r3, [r3, #8]
    631e:	440b      	add	r3, r1
            p.y -= style->text.line_space;                                               /*Trim the last line space*/
    6320:	1a42      	subs	r2, r0, r1
            p.y -= p.y %
    6322:	fb90 f1f3 	sdiv	r1, r0, r3
    6326:	fb03 0311 	mls	r3, r3, r1, r0
            p.y -= style->text.line_space;                                               /*Trim the last line space*/
    632a:	1ad2      	subs	r2, r2, r3
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
    632c:	a906      	add	r1, sp, #24
    632e:	4628      	mov	r0, r5
            p.y -= style->text.line_space;                                               /*Trim the last line space*/
    6330:	f8ad 201a 	strh.w	r2, [sp, #26]
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
    6334:	f7ff fe98 	bl	6068 <lv_label_get_letter_on>
            uint32_t byte_id     = lv_txt_encoded_get_byte_id(ext->text, letter_id);
    6338:	4b1f      	ldr	r3, [pc, #124]	; (63b8 <lv_label_refr_text+0x174>)
    633a:	4601      	mov	r1, r0
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
    633c:	4607      	mov	r7, r0
            uint32_t byte_id     = lv_txt_encoded_get_byte_id(ext->text, letter_id);
    633e:	681b      	ldr	r3, [r3, #0]
    6340:	6820      	ldr	r0, [r4, #0]
    6342:	4798      	blx	r3
    6344:	f04f 0804 	mov.w	r8, #4
    6348:	4606      	mov	r6, r0
    634a:	9007      	str	r0, [sp, #28]
            uint8_t len          = 0;
    634c:	f04f 0900 	mov.w	r9, #0
                len += lv_txt_encoded_size(&ext->text[byte_id]);
    6350:	9907      	ldr	r1, [sp, #28]
    6352:	6820      	ldr	r0, [r4, #0]
    6354:	f8da 3000 	ldr.w	r3, [sl]
    6358:	4408      	add	r0, r1
    635a:	4798      	blx	r3
                lv_txt_encoded_next(ext->text, &byte_id);
    635c:	f8db 3000 	ldr.w	r3, [fp]
                len += lv_txt_encoded_size(&ext->text[byte_id]);
    6360:	4481      	add	r9, r0
                lv_txt_encoded_next(ext->text, &byte_id);
    6362:	a907      	add	r1, sp, #28
    6364:	6820      	ldr	r0, [r4, #0]
    6366:	4798      	blx	r3
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
    6368:	f1b8 0801 	subs.w	r8, r8, #1
                len += lv_txt_encoded_size(&ext->text[byte_id]);
    636c:	fa5f f989 	uxtb.w	r9, r9
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
    6370:	d1ee      	bne.n	6350 <lv_label_refr_text+0x10c>
            if(lv_label_set_dot_tmp(label, &ext->text[byte_id_ori], len)) {
    6372:	6821      	ldr	r1, [r4, #0]
    6374:	464a      	mov	r2, r9
    6376:	4431      	add	r1, r6
    6378:	4628      	mov	r0, r5
    637a:	f7ff fe3f 	bl	5ffc <lv_label_set_dot_tmp>
    637e:	2800      	cmp	r0, #0
    6380:	d095      	beq.n	62ae <lv_label_refr_text+0x6a>
                    ext->text[byte_id_ori + i] = '.';
    6382:	6823      	ldr	r3, [r4, #0]
    6384:	222e      	movs	r2, #46	; 0x2e
    6386:	559a      	strb	r2, [r3, r6]
    6388:	6823      	ldr	r3, [r4, #0]
    638a:	4433      	add	r3, r6
                ext->dot_end                              = letter_id + LV_LABEL_DOT_NUM;
    638c:	3703      	adds	r7, #3
                    ext->text[byte_id_ori + i] = '.';
    638e:	705a      	strb	r2, [r3, #1]
    6390:	6823      	ldr	r3, [r4, #0]
    6392:	4433      	add	r3, r6
    6394:	709a      	strb	r2, [r3, #2]
                ext->text[byte_id_ori + LV_LABEL_DOT_NUM] = '\0';
    6396:	6823      	ldr	r3, [r4, #0]
    6398:	441e      	add	r6, r3
    639a:	f886 8003 	strb.w	r8, [r6, #3]
                ext->dot_end                              = letter_id + LV_LABEL_DOT_NUM;
    639e:	8127      	strh	r7, [r4, #8]
    63a0:	e785      	b.n	62ae <lv_label_refr_text+0x6a>
    else if(ext->long_mode == LV_LABEL_LONG_BREAK) {
    63a2:	2b01      	cmp	r3, #1
    63a4:	d183      	bne.n	62ae <lv_label_refr_text+0x6a>
        lv_obj_set_height(label, size.y);
    63a6:	f9bd 1016 	ldrsh.w	r1, [sp, #22]
    63aa:	4628      	mov	r0, r5
    63ac:	f003 fab4 	bl	9918 <lv_obj_set_height>
    63b0:	e77d      	b.n	62ae <lv_label_refr_text+0x6a>
    63b2:	bf00      	nop
    63b4:	2000a138 	.word	0x2000a138
    63b8:	2000a124 	.word	0x2000a124
    63bc:	2000a134 	.word	0x2000a134
    63c0:	2000a12c 	.word	0x2000a12c

000063c4 <lv_label_signal>:
    res = ancestor_signal(label, sign, param);
    63c4:	4b34      	ldr	r3, [pc, #208]	; (6498 <lv_label_signal+0xd4>)
{
    63c6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    res = ancestor_signal(label, sign, param);
    63ca:	681b      	ldr	r3, [r3, #0]
{
    63cc:	4604      	mov	r4, r0
    63ce:	460d      	mov	r5, r1
    63d0:	4617      	mov	r7, r2
    res = ancestor_signal(label, sign, param);
    63d2:	4798      	blx	r3
    if(res != LV_RES_OK) return res;
    63d4:	2801      	cmp	r0, #1
    res = ancestor_signal(label, sign, param);
    63d6:	4606      	mov	r6, r0
    if(res != LV_RES_OK) return res;
    63d8:	d118      	bne.n	640c <lv_label_signal+0x48>
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    63da:	2d07      	cmp	r5, #7
    63dc:	d105      	bne.n	63ea <lv_label_signal+0x26>
    63de:	4638      	mov	r0, r7
    63e0:	492e      	ldr	r1, [pc, #184]	; (649c <lv_label_signal+0xd8>)
}
    63e2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    63e6:	f003 bc74 	b.w	9cd2 <lv_obj_handle_get_type_signal>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    63ea:	4620      	mov	r0, r4
    63ec:	f003 fc6f 	bl	9cce <lv_obj_get_ext_attr>
    63f0:	4680      	mov	r8, r0
    if(sign == LV_SIGNAL_CLEANUP) {
    63f2:	b975      	cbnz	r5, 6412 <lv_label_signal+0x4e>
        if(ext->static_txt == 0) {
    63f4:	7b83      	ldrb	r3, [r0, #14]
    63f6:	f013 0508 	ands.w	r5, r3, #8
    63fa:	d104      	bne.n	6406 <lv_label_signal+0x42>
            lv_mem_free(ext->text);
    63fc:	6800      	ldr	r0, [r0, #0]
    63fe:	f7ff fc19 	bl	5c34 <lv_mem_free>
            ext->text = NULL;
    6402:	f8c8 5000 	str.w	r5, [r8]
        lv_label_dot_tmp_free(label);
    6406:	4620      	mov	r0, r4
    6408:	f005 f9c8 	bl	b79c <lv_label_dot_tmp_free>
}
    640c:	4630      	mov	r0, r6
    640e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
    6412:	2d04      	cmp	r5, #4
    6414:	d106      	bne.n	6424 <lv_label_signal+0x60>
        lv_label_revert_dots(label);
    6416:	4620      	mov	r0, r4
    6418:	f7ff fdb8 	bl	5f8c <lv_label_revert_dots>
        lv_label_refr_text(label);
    641c:	4620      	mov	r0, r4
    641e:	f7ff ff11 	bl	6244 <lv_label_refr_text>
    6422:	e7f3      	b.n	640c <lv_label_signal+0x48>
    } else if(sign == LV_SIGNAL_CORD_CHG) {
    6424:	2d02      	cmp	r5, #2
    6426:	d114      	bne.n	6452 <lv_label_signal+0x8e>
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    6428:	8a23      	ldrh	r3, [r4, #16]
    642a:	8aa2      	ldrh	r2, [r4, #20]
    642c:	8839      	ldrh	r1, [r7, #0]
    642e:	1ad2      	subs	r2, r2, r3
    6430:	88bb      	ldrh	r3, [r7, #4]
    6432:	1a5b      	subs	r3, r3, r1
        if(lv_area_get_width(&label->coords) != lv_area_get_width(param) ||
    6434:	b212      	sxth	r2, r2
    6436:	b21b      	sxth	r3, r3
    6438:	429a      	cmp	r2, r3
    643a:	d1ec      	bne.n	6416 <lv_label_signal+0x52>
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    643c:	8a63      	ldrh	r3, [r4, #18]
    643e:	8ae2      	ldrh	r2, [r4, #22]
    6440:	8879      	ldrh	r1, [r7, #2]
    6442:	1ad2      	subs	r2, r2, r3
    6444:	88fb      	ldrh	r3, [r7, #6]
    6446:	1a5b      	subs	r3, r3, r1
    6448:	b212      	sxth	r2, r2
    644a:	b21b      	sxth	r3, r3
    644c:	429a      	cmp	r2, r3
    644e:	d1e2      	bne.n	6416 <lv_label_signal+0x52>
    6450:	e7dc      	b.n	640c <lv_label_signal+0x48>
    } else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
    6452:	2d06      	cmp	r5, #6
    6454:	d1da      	bne.n	640c <lv_label_signal+0x48>
        if(ext->body_draw) {
    6456:	7bc3      	ldrb	r3, [r0, #15]
    6458:	f013 0501 	ands.w	r5, r3, #1
    645c:	d0d6      	beq.n	640c <lv_label_signal+0x48>
 * @return pointer to the label's style
 */
static inline const lv_style_t * lv_label_get_style(const lv_obj_t * label, lv_label_style_t type)
{
    (void)type; /*Unused*/
    return lv_obj_get_style(label);
    645e:	4620      	mov	r0, r4
    6460:	f7fd fcd4 	bl	3e0c <lv_obj_get_style>
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.right);
    6464:	f9b0 3024 	ldrsh.w	r3, [r0, #36]	; 0x24
    6468:	f9b0 2026 	ldrsh.w	r2, [r0, #38]	; 0x26
    646c:	4293      	cmp	r3, r2
    646e:	bfb8      	it	lt
    6470:	4613      	movlt	r3, r2
    6472:	f9b4 2030 	ldrsh.w	r2, [r4, #48]	; 0x30
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.top);
    6476:	4293      	cmp	r3, r2
    6478:	bfb8      	it	lt
    647a:	4613      	movlt	r3, r2
    647c:	f9b0 2020 	ldrsh.w	r2, [r0, #32]
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.bottom);
    6480:	4293      	cmp	r3, r2
    6482:	bfb8      	it	lt
    6484:	4613      	movlt	r3, r2
    6486:	f9b0 2022 	ldrsh.w	r2, [r0, #34]	; 0x22
    648a:	4293      	cmp	r3, r2
    648c:	bfb8      	it	lt
    648e:	4613      	movlt	r3, r2
    6490:	8623      	strh	r3, [r4, #48]	; 0x30
    6492:	462e      	mov	r6, r5
    6494:	e7ba      	b.n	640c <lv_label_signal+0x48>
    6496:	bf00      	nop
    6498:	20000670 	.word	0x20000670
    649c:	00045d32 	.word	0x00045d32

000064a0 <lv_label_create>:
{
    64a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    64a4:	460e      	mov	r6, r1
    lv_obj_t * new_label = lv_obj_create(par, copy);
    64a6:	f7fd fb81 	bl	3bac <lv_obj_create>
    if(new_label == NULL) return NULL;
    64aa:	4604      	mov	r4, r0
    64ac:	b918      	cbnz	r0, 64b6 <lv_label_create+0x16>
    64ae:	2400      	movs	r4, #0
}
    64b0:	4620      	mov	r0, r4
    64b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_label);
    64b6:	4d53      	ldr	r5, [pc, #332]	; (6604 <lv_label_create+0x164>)
    64b8:	682b      	ldr	r3, [r5, #0]
    64ba:	b913      	cbnz	r3, 64c2 <lv_label_create+0x22>
    64bc:	f003 fc05 	bl	9cca <lv_obj_get_signal_cb>
    64c0:	6028      	str	r0, [r5, #0]
    lv_obj_allocate_ext_attr(new_label, sizeof(lv_label_ext_t));
    64c2:	2110      	movs	r1, #16
    64c4:	4620      	mov	r0, r4
    64c6:	f003 f934 	bl	9732 <lv_obj_allocate_ext_attr>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(new_label);
    64ca:	4620      	mov	r0, r4
    64cc:	f003 fbff 	bl	9cce <lv_obj_get_ext_attr>
    if(ext == NULL) return NULL;
    64d0:	4605      	mov	r5, r0
    64d2:	2800      	cmp	r0, #0
    64d4:	d0eb      	beq.n	64ae <lv_label_create+0xe>
    ext->text       = NULL;
    64d6:	2300      	movs	r3, #0
    ext->dot.tmp_ptr   = NULL;
    64d8:	e9c0 3300 	strd	r3, r3, [r0]
    ext->dot_end    = LV_LABEL_DOT_END_INV;
    64dc:	f64f 73ff 	movw	r3, #65535	; 0xffff
    ext->offset.y = 0;
    64e0:	68c2      	ldr	r2, [r0, #12]
    ext->dot_end    = LV_LABEL_DOT_END_INV;
    64e2:	6083      	str	r3, [r0, #8]
    ext->offset.y = 0;
    64e4:	4b48      	ldr	r3, [pc, #288]	; (6608 <lv_label_create+0x168>)
    lv_obj_set_design_cb(new_label, lv_label_design);
    64e6:	4949      	ldr	r1, [pc, #292]	; (660c <lv_label_create+0x16c>)
    ext->offset.y = 0;
    64e8:	4013      	ands	r3, r2
    64ea:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
    64ee:	60c3      	str	r3, [r0, #12]
    lv_obj_set_design_cb(new_label, lv_label_design);
    64f0:	4620      	mov	r0, r4
    64f2:	f003 f91c 	bl	972e <lv_obj_set_design_cb>
    lv_obj_set_signal_cb(new_label, lv_label_signal);
    64f6:	4946      	ldr	r1, [pc, #280]	; (6610 <lv_label_create+0x170>)
    64f8:	4620      	mov	r0, r4
    64fa:	f003 f916 	bl	972a <lv_obj_set_signal_cb>
    if(copy == NULL) {
    64fe:	b9b6      	cbnz	r6, 652e <lv_label_create+0x8e>
        lv_obj_set_click(new_label, false);
    6500:	4631      	mov	r1, r6
    6502:	4620      	mov	r0, r4
    6504:	f003 f90a 	bl	971c <lv_obj_set_click>
        lv_label_set_long_mode(new_label, LV_LABEL_LONG_EXPAND);
    6508:	4631      	mov	r1, r6
    650a:	4620      	mov	r0, r4
    650c:	f005 fb08 	bl	bb20 <lv_label_set_long_mode>
        lv_label_set_text(new_label, "Text");
    6510:	4940      	ldr	r1, [pc, #256]	; (6614 <lv_label_create+0x174>)
    6512:	4620      	mov	r0, r4
    6514:	f005 faaf 	bl	ba76 <lv_label_set_text>
    lv_obj_set_style(label, style);
    6518:	4631      	mov	r1, r6
    651a:	4620      	mov	r0, r4
    651c:	f003 fa28 	bl	9970 <lv_obj_set_style>
    LV_LOG_INFO("label created");
    6520:	4b3d      	ldr	r3, [pc, #244]	; (6618 <lv_label_create+0x178>)
    6522:	493e      	ldr	r1, [pc, #248]	; (661c <lv_label_create+0x17c>)
    6524:	22a1      	movs	r2, #161	; 0xa1
    6526:	2001      	movs	r0, #1
    6528:	f7ff fd20 	bl	5f6c <lv_log_add>
    return new_label;
    652c:	e7c0      	b.n	64b0 <lv_label_create+0x10>
        lv_label_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
    652e:	4630      	mov	r0, r6
    6530:	f003 fbcd 	bl	9cce <lv_obj_get_ext_attr>
    6534:	4607      	mov	r7, r0
        lv_label_set_long_mode(new_label, lv_label_get_long_mode(copy));
    6536:	4630      	mov	r0, r6
    6538:	f005 f970 	bl	b81c <lv_label_get_long_mode>
    653c:	4601      	mov	r1, r0
    653e:	4620      	mov	r0, r4
    6540:	f005 faee 	bl	bb20 <lv_label_set_long_mode>
        lv_label_set_recolor(new_label, lv_label_get_recolor(copy));
    6544:	4630      	mov	r0, r6
    6546:	f005 fa88 	bl	ba5a <lv_label_get_recolor>
    654a:	4601      	mov	r1, r0
    654c:	4620      	mov	r0, r4
    654e:	f005 fb0e 	bl	bb6e <lv_label_set_recolor>
        lv_label_set_body_draw(new_label, lv_label_get_body_draw(copy));
    6552:	4630      	mov	r0, r6
    6554:	f005 fa88 	bl	ba68 <lv_label_get_body_draw>
    6558:	4601      	mov	r1, r0
    655a:	4620      	mov	r0, r4
    655c:	f005 f943 	bl	b7e6 <lv_label_set_body_draw>
        lv_label_set_align(new_label, lv_label_get_align(copy));
    6560:	4630      	mov	r0, r6
    6562:	f005 f962 	bl	b82a <lv_label_get_align>
    6566:	4601      	mov	r1, r0
    6568:	4620      	mov	r0, r4
    656a:	f005 f929 	bl	b7c0 <lv_label_set_align>
        if(copy_ext->static_txt == 0)
    656e:	7bbb      	ldrb	r3, [r7, #14]
    6570:	071a      	lsls	r2, r3, #28
            lv_label_set_text(new_label, lv_label_get_text(copy));
    6572:	4630      	mov	r0, r6
        if(copy_ext->static_txt == 0)
    6574:	d439      	bmi.n	65ea <lv_label_create+0x14a>
            lv_label_set_text(new_label, lv_label_get_text(copy));
    6576:	f005 f94c 	bl	b812 <lv_label_get_text>
    657a:	4601      	mov	r1, r0
    657c:	4620      	mov	r0, r4
    657e:	f005 fa7a 	bl	ba76 <lv_label_set_text>
        if(copy_ext->long_mode == LV_LABEL_LONG_DOT) {
    6582:	7bbb      	ldrb	r3, [r7, #14]
    6584:	f003 0307 	and.w	r3, r3, #7
    6588:	2b02      	cmp	r3, #2
    658a:	d115      	bne.n	65b8 <lv_label_create+0x118>
            ext->text = lv_mem_realloc(ext->text, lv_mem_get_size(copy_ext->text));
    658c:	6838      	ldr	r0, [r7, #0]
    658e:	682e      	ldr	r6, [r5, #0]
    6590:	f7ff fb60 	bl	5c54 <lv_mem_get_size>
    6594:	4601      	mov	r1, r0
    6596:	4630      	mov	r0, r6
    6598:	f7ff fb6a 	bl	5c70 <lv_mem_realloc>
    659c:	4606      	mov	r6, r0
    659e:	6028      	str	r0, [r5, #0]
            if(ext->text == NULL) return NULL;
    65a0:	2800      	cmp	r0, #0
    65a2:	d084      	beq.n	64ae <lv_label_create+0xe>
            memcpy(ext->text, copy_ext->text, lv_mem_get_size(copy_ext->text));
    65a4:	f8d7 8000 	ldr.w	r8, [r7]
    65a8:	4640      	mov	r0, r8
    65aa:	f7ff fb53 	bl	5c54 <lv_mem_get_size>
    65ae:	4641      	mov	r1, r8
    65b0:	4602      	mov	r2, r0
    65b2:	4630      	mov	r0, r6
    65b4:	f002 f99c 	bl	88f0 <memcpy>
        if(copy_ext->dot_tmp_alloc && copy_ext->dot.tmp_ptr) {
    65b8:	7bfb      	ldrb	r3, [r7, #15]
    65ba:	079b      	lsls	r3, r3, #30
    65bc:	d51c      	bpl.n	65f8 <lv_label_create+0x158>
    65be:	6878      	ldr	r0, [r7, #4]
    65c0:	b1d0      	cbz	r0, 65f8 <lv_label_create+0x158>
            uint16_t len = (uint16_t    )strlen(copy_ext->dot.tmp_ptr);
    65c2:	f002 f982 	bl	88ca <strlen>
            lv_label_set_dot_tmp(new_label, ext->dot.tmp_ptr, len);
    65c6:	6869      	ldr	r1, [r5, #4]
    65c8:	b282      	uxth	r2, r0
    65ca:	4620      	mov	r0, r4
    65cc:	f7ff fd16 	bl	5ffc <lv_label_set_dot_tmp>
        ext->dot_tmp_alloc = copy_ext->dot_tmp_alloc;
    65d0:	7bfb      	ldrb	r3, [r7, #15]
    65d2:	7bea      	ldrb	r2, [r5, #15]
    65d4:	f3c3 0340 	ubfx	r3, r3, #1, #1
    65d8:	f363 0241 	bfi	r2, r3, #1, #1
    65dc:	73ea      	strb	r2, [r5, #15]
        ext->dot_end       = copy_ext->dot_end;
    65de:	893b      	ldrh	r3, [r7, #8]
    65e0:	812b      	strh	r3, [r5, #8]
        lv_obj_refresh_style(new_label);
    65e2:	4620      	mov	r0, r4
    65e4:	f003 f934 	bl	9850 <lv_obj_refresh_style>
    65e8:	e79a      	b.n	6520 <lv_label_create+0x80>
            lv_label_set_static_text(new_label, lv_label_get_text(copy));
    65ea:	f005 f912 	bl	b812 <lv_label_get_text>
    65ee:	4601      	mov	r1, r0
    65f0:	4620      	mov	r0, r4
    65f2:	f005 fa7b 	bl	baec <lv_label_set_static_text>
    65f6:	e7c4      	b.n	6582 <lv_label_create+0xe2>
            memcpy(ext->dot.tmp, copy_ext->dot.tmp, sizeof(ext->dot.tmp));
    65f8:	2204      	movs	r2, #4
    65fa:	18b9      	adds	r1, r7, r2
    65fc:	18a8      	adds	r0, r5, r2
    65fe:	f002 f977 	bl	88f0 <memcpy>
    6602:	e7e5      	b.n	65d0 <lv_label_create+0x130>
    6604:	20000670 	.word	0x20000670
    6608:	fc800000 	.word	0xfc800000
    660c:	0000b83f 	.word	0x0000b83f
    6610:	000063c5 	.word	0x000063c5
    6614:	00045cbe 	.word	0x00045cbe
    6618:	00045cc3 	.word	0x00045cc3
    661c:	00045cfb 	.word	0x00045cfb

00006620 <lv_img_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return true/false, depends on 'mode'
 */
static bool lv_img_design(lv_obj_t * img, const lv_area_t * mask, lv_design_mode_t mode)
{
    6620:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6624:	b09d      	sub	sp, #116	; 0x74
    6626:	4690      	mov	r8, r2
    6628:	4681      	mov	r9, r0
    662a:	460d      	mov	r5, r1
    const lv_style_t * style = lv_obj_get_style(img);
    662c:	f7fd fbee 	bl	3e0c <lv_obj_get_style>
    6630:	4606      	mov	r6, r0
    lv_img_ext_t * ext       = lv_obj_get_ext_attr(img);
    6632:	4648      	mov	r0, r9
    6634:	f003 fb4b 	bl	9cce <lv_obj_get_ext_attr>

    if(mode == LV_DESIGN_COVER_CHK) {
    6638:	f1b8 0f02 	cmp.w	r8, #2
    lv_img_ext_t * ext       = lv_obj_get_ext_attr(img);
    663c:	4604      	mov	r4, r0
    if(mode == LV_DESIGN_COVER_CHK) {
    663e:	d112      	bne.n	6666 <lv_img_design+0x46>
        bool cover = false;
        if(ext->src_type == LV_IMG_SRC_UNKNOWN || ext->src_type == LV_IMG_SRC_SYMBOL) return false;
    6640:	7b03      	ldrb	r3, [r0, #12]
    6642:	f013 0002 	ands.w	r0, r3, #2
    6646:	f040 8093 	bne.w	6770 <lv_img_design+0x150>

        if(ext->cf == LV_IMG_CF_TRUE_COLOR || ext->cf == LV_IMG_CF_RAW) cover = lv_area_is_in(mask, &img->coords);
    664a:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
    664e:	2b20      	cmp	r3, #32
    6650:	d001      	beq.n	6656 <lv_img_design+0x36>
    6652:	2b08      	cmp	r3, #8
    6654:	d104      	bne.n	6660 <lv_img_design+0x40>
    6656:	f109 0110 	add.w	r1, r9, #16
    665a:	4628      	mov	r0, r5
    665c:	f004 fe90 	bl	b380 <lv_area_is_in>
            lv_draw_img(&img->coords, mask, NULL, style, opa_scale);
        }
    }

    return true;
}
    6660:	b01d      	add	sp, #116	; 0x74
    6662:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    } else if(mode == LV_DESIGN_DRAW_MAIN) {
    6666:	f1b8 0f00 	cmp.w	r8, #0
    666a:	d105      	bne.n	6678 <lv_img_design+0x58>
        if(ext->h == 0 || ext->w == 0) return true;
    666c:	f9b0 300a 	ldrsh.w	r3, [r0, #10]
    6670:	b113      	cbz	r3, 6678 <lv_img_design+0x58>
    6672:	f9b0 3008 	ldrsh.w	r3, [r0, #8]
    6676:	b90b      	cbnz	r3, 667c <lv_img_design+0x5c>
    return true;
    6678:	2001      	movs	r0, #1
    667a:	e7f1      	b.n	6660 <lv_img_design+0x40>
        lv_opa_t opa_scale = lv_obj_get_opa_scale(img);
    667c:	4648      	mov	r0, r9
    667e:	f003 fac6 	bl	9c0e <lv_obj_get_opa_scale>
        lv_obj_get_coords(img, &coords);
    6682:	a906      	add	r1, sp, #24
        lv_opa_t opa_scale = lv_obj_get_opa_scale(img);
    6684:	4607      	mov	r7, r0
        lv_obj_get_coords(img, &coords);
    6686:	4648      	mov	r0, r9
    6688:	f003 f97c 	bl	9984 <lv_obj_get_coords>
        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_VARIABLE) {
    668c:	7b23      	ldrb	r3, [r4, #12]
    668e:	079a      	lsls	r2, r3, #30
    6690:	d443      	bmi.n	671a <lv_img_design+0xfa>
            coords.x1 -= ext->offset.x;
    6692:	88a2      	ldrh	r2, [r4, #4]
    6694:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    6698:	1a9b      	subs	r3, r3, r2
    669a:	f8ad 3018 	strh.w	r3, [sp, #24]
            coords.y1 -= ext->offset.y;
    669e:	88e2      	ldrh	r2, [r4, #6]
    66a0:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    66a4:	1a9b      	subs	r3, r3, r2
            cords_tmp.y2 = coords.y1 + ext->h - 1;
    66a6:	8962      	ldrh	r2, [r4, #10]
            coords.y1 -= ext->offset.y;
    66a8:	b21b      	sxth	r3, r3
    66aa:	f8ad 301a 	strh.w	r3, [sp, #26]
            cords_tmp.y1 = coords.y1;
    66ae:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
            cords_tmp.y2 = coords.y1 + ext->h - 1;
    66b2:	3a01      	subs	r2, #1
            for(; cords_tmp.y1 <= coords.y2; cords_tmp.y1 += ext->h, cords_tmp.y2 += ext->h) {
    66b4:	4413      	add	r3, r2
    66b6:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
    66ba:	f9bd 2022 	ldrsh.w	r2, [sp, #34]	; 0x22
    66be:	f9bd 301e 	ldrsh.w	r3, [sp, #30]
    66c2:	429a      	cmp	r2, r3
    66c4:	dcd8      	bgt.n	6678 <lv_img_design+0x58>
                cords_tmp.x1 = coords.x1;
    66c6:	f9bd 3018 	ldrsh.w	r3, [sp, #24]
                cords_tmp.x2 = coords.x1 + ext->w - 1;
    66ca:	8922      	ldrh	r2, [r4, #8]
                cords_tmp.x1 = coords.x1;
    66cc:	f8ad 3020 	strh.w	r3, [sp, #32]
                cords_tmp.x2 = coords.x1 + ext->w - 1;
    66d0:	3b01      	subs	r3, #1
                for(; cords_tmp.x1 <= coords.x2; cords_tmp.x1 += ext->w, cords_tmp.x2 += ext->w) {
    66d2:	4413      	add	r3, r2
    66d4:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    66d8:	f9bd 2020 	ldrsh.w	r2, [sp, #32]
    66dc:	f9bd 301c 	ldrsh.w	r3, [sp, #28]
    66e0:	429a      	cmp	r2, r3
    66e2:	dd09      	ble.n	66f8 <lv_img_design+0xd8>
            for(; cords_tmp.y1 <= coords.y2; cords_tmp.y1 += ext->h, cords_tmp.y2 += ext->h) {
    66e4:	f9b4 300a 	ldrsh.w	r3, [r4, #10]
    66e8:	f8bd 2022 	ldrh.w	r2, [sp, #34]	; 0x22
    66ec:	441a      	add	r2, r3
    66ee:	f8ad 2022 	strh.w	r2, [sp, #34]	; 0x22
    66f2:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
    66f6:	e7dd      	b.n	66b4 <lv_img_design+0x94>
                    lv_draw_img(&cords_tmp, mask, ext->src, style, opa_scale);
    66f8:	9700      	str	r7, [sp, #0]
    66fa:	4633      	mov	r3, r6
    66fc:	6822      	ldr	r2, [r4, #0]
    66fe:	4629      	mov	r1, r5
    6700:	a808      	add	r0, sp, #32
    6702:	f7fe fbeb 	bl	4edc <lv_draw_img>
                for(; cords_tmp.x1 <= coords.x2; cords_tmp.x1 += ext->w, cords_tmp.x2 += ext->w) {
    6706:	f9b4 3008 	ldrsh.w	r3, [r4, #8]
    670a:	f8bd 2020 	ldrh.w	r2, [sp, #32]
    670e:	441a      	add	r2, r3
    6710:	f8ad 2020 	strh.w	r2, [sp, #32]
    6714:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
    6718:	e7db      	b.n	66d2 <lv_img_design+0xb2>
        } else if(ext->src_type == LV_IMG_SRC_SYMBOL) {
    671a:	f003 0303 	and.w	r3, r3, #3
    671e:	2b02      	cmp	r3, #2
    6720:	d116      	bne.n	6750 <lv_img_design+0x130>
            lv_style_copy(&style_mod, style);
    6722:	4631      	mov	r1, r6
    6724:	a808      	add	r0, sp, #32
    6726:	f003 fbda 	bl	9ede <lv_style_copy>
            style_mod.text.color = style->image.color;
    672a:	6c33      	ldr	r3, [r6, #64]	; 0x40
    672c:	9313      	str	r3, [sp, #76]	; 0x4c
            lv_draw_label(&coords, mask, &style_mod, opa_scale, ext->src, LV_TXT_FLAG_NONE, NULL, NULL, NULL, lv_obj_get_base_dir(img));
    672e:	4648      	mov	r0, r9
    6730:	6824      	ldr	r4, [r4, #0]
    6732:	f003 fa6a 	bl	9c0a <lv_obj_get_base_dir>
    6736:	e9cd 8802 	strd	r8, r8, [sp, #8]
    673a:	e9cd 8004 	strd	r8, r0, [sp, #16]
    673e:	e9cd 4800 	strd	r4, r8, [sp]
    6742:	463b      	mov	r3, r7
    6744:	aa08      	add	r2, sp, #32
    6746:	4629      	mov	r1, r5
    6748:	a806      	add	r0, sp, #24
    674a:	f7fe f97d 	bl	4a48 <lv_draw_label>
    674e:	e793      	b.n	6678 <lv_img_design+0x58>
            LV_LOG_WARN("lv_img_design: image source type is unknown");
    6750:	4b08      	ldr	r3, [pc, #32]	; (6774 <lv_img_design+0x154>)
    6752:	4909      	ldr	r1, [pc, #36]	; (6778 <lv_img_design+0x158>)
    6754:	f44f 72c3 	mov.w	r2, #390	; 0x186
    6758:	2002      	movs	r0, #2
    675a:	f7ff fc07 	bl	5f6c <lv_log_add>
            lv_draw_img(&img->coords, mask, NULL, style, opa_scale);
    675e:	9700      	str	r7, [sp, #0]
    6760:	4633      	mov	r3, r6
    6762:	4642      	mov	r2, r8
    6764:	4629      	mov	r1, r5
    6766:	f109 0010 	add.w	r0, r9, #16
    676a:	f7fe fbb7 	bl	4edc <lv_draw_img>
    676e:	e783      	b.n	6678 <lv_img_design+0x58>
        if(ext->src_type == LV_IMG_SRC_UNKNOWN || ext->src_type == LV_IMG_SRC_SYMBOL) return false;
    6770:	2000      	movs	r0, #0
    6772:	e775      	b.n	6660 <lv_img_design+0x40>
    6774:	00045d49 	.word	0x00045d49
    6778:	00045d75 	.word	0x00045d75

0000677c <lv_img_set_src>:
{
    677c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6780:	4607      	mov	r7, r0
    6782:	b087      	sub	sp, #28
    lv_img_src_t src_type = lv_img_src_get_type(src_img);
    6784:	4608      	mov	r0, r1
{
    6786:	460d      	mov	r5, r1
    lv_img_src_t src_type = lv_img_src_get_type(src_img);
    6788:	f004 fcc4 	bl	b114 <lv_img_src_get_type>
    678c:	4606      	mov	r6, r0
    lv_img_ext_t * ext    = lv_obj_get_ext_attr(img);
    678e:	4638      	mov	r0, r7
    6790:	f003 fa9d 	bl	9cce <lv_obj_get_ext_attr>
    switch(src_type) {
    6794:	2e02      	cmp	r6, #2
    lv_img_ext_t * ext    = lv_obj_get_ext_attr(img);
    6796:	4604      	mov	r4, r0
    switch(src_type) {
    6798:	d91f      	bls.n	67da <lv_img_set_src+0x5e>
        default: LV_LOG_WARN("lv_img_set_src: unknown type");
    679a:	4b4f      	ldr	r3, [pc, #316]	; (68d8 <lv_img_set_src+0x15c>)
    679c:	494f      	ldr	r1, [pc, #316]	; (68dc <lv_img_set_src+0x160>)
    679e:	2288      	movs	r2, #136	; 0x88
    67a0:	2002      	movs	r0, #2
    67a2:	f7ff fbe3 	bl	5f6c <lv_log_add>
    if(src_type == LV_IMG_SRC_UNKNOWN) {
    67a6:	2e03      	cmp	r6, #3
    67a8:	d117      	bne.n	67da <lv_img_set_src+0x5e>
        LV_LOG_WARN("lv_img_set_src: unknown image type");
    67aa:	4b4d      	ldr	r3, [pc, #308]	; (68e0 <lv_img_set_src+0x164>)
    67ac:	494b      	ldr	r1, [pc, #300]	; (68dc <lv_img_set_src+0x160>)
    67ae:	228e      	movs	r2, #142	; 0x8e
    67b0:	2002      	movs	r0, #2
    67b2:	f7ff fbdb 	bl	5f6c <lv_log_add>
        if(ext->src_type == LV_IMG_SRC_SYMBOL || ext->src_type == LV_IMG_SRC_FILE) {
    67b6:	7b23      	ldrb	r3, [r4, #12]
    67b8:	f003 0303 	and.w	r3, r3, #3
    67bc:	3b01      	subs	r3, #1
    67be:	2b01      	cmp	r3, #1
    67c0:	d802      	bhi.n	67c8 <lv_img_set_src+0x4c>
            lv_mem_free(ext->src);
    67c2:	6820      	ldr	r0, [r4, #0]
    67c4:	f7ff fa36 	bl	5c34 <lv_mem_free>
        ext->src      = NULL;
    67c8:	2300      	movs	r3, #0
    67ca:	6023      	str	r3, [r4, #0]
        ext->src_type = LV_IMG_SRC_UNKNOWN;
    67cc:	7b23      	ldrb	r3, [r4, #12]
    67ce:	f043 0303 	orr.w	r3, r3, #3
    67d2:	7323      	strb	r3, [r4, #12]
}
    67d4:	b007      	add	sp, #28
    67d6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    lv_img_decoder_get_info(src_img, &header);
    67da:	a904      	add	r1, sp, #16
    67dc:	4628      	mov	r0, r5
    67de:	f7fe fe85 	bl	54ec <lv_img_decoder_get_info>
    if(src_type == LV_IMG_SRC_VARIABLE) {
    67e2:	bb8e      	cbnz	r6, 6848 <lv_img_set_src+0xcc>
        LV_LOG_INFO("lv_img_set_src:  `LV_IMG_SRC_VARIABLE` type found");
    67e4:	4b3f      	ldr	r3, [pc, #252]	; (68e4 <lv_img_set_src+0x168>)
    67e6:	493d      	ldr	r1, [pc, #244]	; (68dc <lv_img_set_src+0x160>)
    67e8:	229c      	movs	r2, #156	; 0x9c
    67ea:	2001      	movs	r0, #1
    67ec:	f7ff fbbe 	bl	5f6c <lv_log_add>
        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
    67f0:	7b23      	ldrb	r3, [r4, #12]
    67f2:	f003 0303 	and.w	r3, r3, #3
    67f6:	3b01      	subs	r3, #1
    67f8:	2b01      	cmp	r3, #1
    67fa:	d802      	bhi.n	6802 <lv_img_set_src+0x86>
            lv_mem_free(ext->src);
    67fc:	6820      	ldr	r0, [r4, #0]
    67fe:	f7ff fa19 	bl	5c34 <lv_mem_free>
        ext->src = src_img;
    6802:	6025      	str	r5, [r4, #0]
    ext->w        = header.w;
    6804:	9a04      	ldr	r2, [sp, #16]
    ext->src_type = src_type;
    6806:	7b23      	ldrb	r3, [r4, #12]
    ext->w        = header.w;
    6808:	f3c2 228a 	ubfx	r2, r2, #10, #11
    680c:	8122      	strh	r2, [r4, #8]
    ext->h        = header.h;
    680e:	f8bd 2012 	ldrh.w	r2, [sp, #18]
    6812:	f3c2 124a 	ubfx	r2, r2, #5, #11
    6816:	8162      	strh	r2, [r4, #10]
    ext->cf       = header.cf;
    6818:	f89d 2010 	ldrb.w	r2, [sp, #16]
    ext->src_type = src_type;
    681c:	f366 0301 	bfi	r3, r6, #0, #2
    ext->cf       = header.cf;
    6820:	f3c2 0204 	ubfx	r2, r2, #0, #5
    6824:	f362 03c7 	bfi	r3, r2, #3, #5
    6828:	7323      	strb	r3, [r4, #12]
    if(lv_img_get_auto_size(img) != false) {
    682a:	4638      	mov	r0, r7
    682c:	f005 f9b2 	bl	bb94 <lv_img_get_auto_size>
    6830:	b130      	cbz	r0, 6840 <lv_img_set_src+0xc4>
        lv_obj_set_size(img, ext->w, ext->h);
    6832:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
    6836:	f9b4 1008 	ldrsh.w	r1, [r4, #8]
    683a:	4638      	mov	r0, r7
    683c:	f003 f822 	bl	9884 <lv_obj_set_size>
    lv_obj_invalidate(img);
    6840:	4638      	mov	r0, r7
    6842:	f002 ff7d 	bl	9740 <lv_obj_invalidate>
    6846:	e7c5      	b.n	67d4 <lv_img_set_src+0x58>
    } else if(src_type == LV_IMG_SRC_FILE || src_type == LV_IMG_SRC_SYMBOL) {
    6848:	1e73      	subs	r3, r6, #1
    684a:	b2db      	uxtb	r3, r3
    684c:	2b01      	cmp	r3, #1
    684e:	d81f      	bhi.n	6890 <lv_img_set_src+0x114>
        if(ext->src != src_img) {
    6850:	f8d4 8000 	ldr.w	r8, [r4]
    6854:	45a8      	cmp	r8, r5
    6856:	d01b      	beq.n	6890 <lv_img_set_src+0x114>
            if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
    6858:	7b23      	ldrb	r3, [r4, #12]
    685a:	f003 0303 	and.w	r3, r3, #3
    685e:	3b01      	subs	r3, #1
            const void * old_src = NULL;
    6860:	2b01      	cmp	r3, #1
            char * new_str = lv_mem_alloc(strlen(src_img) + 1);
    6862:	4628      	mov	r0, r5
            const void * old_src = NULL;
    6864:	bf88      	it	hi
    6866:	f04f 0800 	movhi.w	r8, #0
            char * new_str = lv_mem_alloc(strlen(src_img) + 1);
    686a:	f002 f82e 	bl	88ca <strlen>
    686e:	3001      	adds	r0, #1
    6870:	f7ff f9ba 	bl	5be8 <lv_mem_alloc>
            if(new_str == NULL) return;
    6874:	4681      	mov	r9, r0
    6876:	2800      	cmp	r0, #0
    6878:	d0ac      	beq.n	67d4 <lv_img_set_src+0x58>
            strcpy(new_str, src_img);
    687a:	4629      	mov	r1, r5
    687c:	f001 fffa 	bl	8874 <strcpy>
            ext->src = new_str;
    6880:	f8c4 9000 	str.w	r9, [r4]
            if(old_src) lv_mem_free(old_src);
    6884:	f1b8 0f00 	cmp.w	r8, #0
    6888:	d002      	beq.n	6890 <lv_img_set_src+0x114>
    688a:	4640      	mov	r0, r8
    688c:	f7ff f9d2 	bl	5c34 <lv_mem_free>
    if(src_type == LV_IMG_SRC_SYMBOL) {
    6890:	2e02      	cmp	r6, #2
    6892:	d1b7      	bne.n	6804 <lv_img_set_src+0x88>
 * @return pointer to the image's style
 */
static inline const lv_style_t * lv_img_get_style(const lv_obj_t * img, lv_img_style_t type)
{
    (void)type; /*Unused*/
    return lv_obj_get_style(img);
    6894:	4638      	mov	r0, r7
    6896:	f7fd fab9 	bl	3e0c <lv_obj_get_style>
        lv_txt_get_size(&size, src_img, style->text.font, style->text.letter_space, style->text.line_space,
    689a:	f647 4218 	movw	r2, #31768	; 0x7c18
    689e:	2100      	movs	r1, #0
    68a0:	f9b0 3038 	ldrsh.w	r3, [r0, #56]	; 0x38
    68a4:	e9cd 2101 	strd	r2, r1, [sp, #4]
    68a8:	f9b0 203a 	ldrsh.w	r2, [r0, #58]	; 0x3a
    68ac:	9200      	str	r2, [sp, #0]
    68ae:	6b42      	ldr	r2, [r0, #52]	; 0x34
    68b0:	4629      	mov	r1, r5
    68b2:	a805      	add	r0, sp, #20
    68b4:	f004 feff 	bl	b6b6 <lv_txt_get_size>
        header.w = size.x;
    68b8:	9b04      	ldr	r3, [sp, #16]
    68ba:	f8bd 2014 	ldrh.w	r2, [sp, #20]
    68be:	f362 2394 	bfi	r3, r2, #10, #11
        header.h = size.y;
    68c2:	f8bd 2016 	ldrh.w	r2, [sp, #22]
        header.w = size.x;
    68c6:	9304      	str	r3, [sp, #16]
        header.h = size.y;
    68c8:	f3c3 430f 	ubfx	r3, r3, #16, #16
    68cc:	f362 134f 	bfi	r3, r2, #5, #11
    68d0:	f8ad 3012 	strh.w	r3, [sp, #18]
    68d4:	e796      	b.n	6804 <lv_img_set_src+0x88>
    68d6:	bf00      	nop
    68d8:	00045daa 	.word	0x00045daa
    68dc:	00045d75 	.word	0x00045d75
    68e0:	00045dc7 	.word	0x00045dc7
    68e4:	00045dea 	.word	0x00045dea

000068e8 <lv_img_create>:
{
    68e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    68ec:	4607      	mov	r7, r0
    68ee:	460e      	mov	r6, r1
    new_img = lv_obj_create(par, copy);
    68f0:	f7fd f95c 	bl	3bac <lv_obj_create>
    if(new_img == NULL) return NULL;
    68f4:	4605      	mov	r5, r0
    68f6:	b918      	cbnz	r0, 6900 <lv_img_create+0x18>
    68f8:	2500      	movs	r5, #0
}
    68fa:	4628      	mov	r0, r5
    68fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_img);
    6900:	4c2c      	ldr	r4, [pc, #176]	; (69b4 <lv_img_create+0xcc>)
    6902:	6823      	ldr	r3, [r4, #0]
    6904:	b913      	cbnz	r3, 690c <lv_img_create+0x24>
    6906:	f003 f9e0 	bl	9cca <lv_obj_get_signal_cb>
    690a:	6020      	str	r0, [r4, #0]
    lv_img_ext_t * ext = lv_obj_allocate_ext_attr(new_img, sizeof(lv_img_ext_t));
    690c:	2110      	movs	r1, #16
    690e:	4628      	mov	r0, r5
    6910:	f002 ff0f 	bl	9732 <lv_obj_allocate_ext_attr>
    if(ext == NULL) return NULL;
    6914:	4604      	mov	r4, r0
    6916:	2800      	cmp	r0, #0
    6918:	d0ee      	beq.n	68f8 <lv_img_create+0x10>
    ext->src_type  = LV_IMG_SRC_UNKNOWN;
    691a:	7b03      	ldrb	r3, [r0, #12]
    691c:	f003 0304 	and.w	r3, r3, #4
    6920:	f043 0303 	orr.w	r3, r3, #3
    ext->src       = NULL;
    6924:	f04f 0800 	mov.w	r8, #0
    ext->src_type  = LV_IMG_SRC_UNKNOWN;
    6928:	7303      	strb	r3, [r0, #12]
    ext->src       = NULL;
    692a:	f8c0 8000 	str.w	r8, [r0]
    ext->w         = lv_obj_get_width(new_img);
    692e:	4628      	mov	r0, r5
    6930:	f003 f95f 	bl	9bf2 <lv_obj_get_width>
    6934:	8120      	strh	r0, [r4, #8]
    ext->h         = lv_obj_get_height(new_img);
    6936:	4628      	mov	r0, r5
    6938:	f003 f961 	bl	9bfe <lv_obj_get_height>
    ext->auto_size = 1;
    693c:	7b23      	ldrb	r3, [r4, #12]
    ext->h         = lv_obj_get_height(new_img);
    693e:	8160      	strh	r0, [r4, #10]
    ext->auto_size = 1;
    6940:	f043 0304 	orr.w	r3, r3, #4
    lv_obj_set_signal_cb(new_img, lv_img_signal);
    6944:	491c      	ldr	r1, [pc, #112]	; (69b8 <lv_img_create+0xd0>)
    ext->auto_size = 1;
    6946:	7323      	strb	r3, [r4, #12]
    lv_obj_set_signal_cb(new_img, lv_img_signal);
    6948:	4628      	mov	r0, r5
    ext->offset.x  = 0;
    694a:	f8c4 8004 	str.w	r8, [r4, #4]
    lv_obj_set_signal_cb(new_img, lv_img_signal);
    694e:	f002 feec 	bl	972a <lv_obj_set_signal_cb>
    lv_obj_set_design_cb(new_img, lv_img_design);
    6952:	491a      	ldr	r1, [pc, #104]	; (69bc <lv_img_create+0xd4>)
    6954:	4628      	mov	r0, r5
    6956:	f002 feea 	bl	972e <lv_obj_set_design_cb>
    if(copy == NULL) {
    695a:	b9c6      	cbnz	r6, 698e <lv_img_create+0xa6>
        lv_obj_set_click(new_img, false);
    695c:	4631      	mov	r1, r6
    695e:	4628      	mov	r0, r5
    6960:	f002 fedc 	bl	971c <lv_obj_set_click>
        if(par != NULL) {
    6964:	7b23      	ldrb	r3, [r4, #12]
    6966:	b16f      	cbz	r7, 6984 <lv_img_create+0x9c>
            ext->auto_size = 1;
    6968:	f043 0304 	orr.w	r3, r3, #4
    696c:	7323      	strb	r3, [r4, #12]
            lv_obj_set_style(new_img, NULL); /*Inherit the style  by default*/
    696e:	4631      	mov	r1, r6
            lv_obj_set_style(new_img, &lv_style_plain); /*Set a style for screens*/
    6970:	4628      	mov	r0, r5
    6972:	f002 fffd 	bl	9970 <lv_obj_set_style>
    LV_LOG_INFO("image created");
    6976:	4b12      	ldr	r3, [pc, #72]	; (69c0 <lv_img_create+0xd8>)
    6978:	4912      	ldr	r1, [pc, #72]	; (69c4 <lv_img_create+0xdc>)
    697a:	226e      	movs	r2, #110	; 0x6e
    697c:	2001      	movs	r0, #1
    697e:	f7ff faf5 	bl	5f6c <lv_log_add>
    return new_img;
    6982:	e7ba      	b.n	68fa <lv_img_create+0x12>
            ext->auto_size = 0;
    6984:	f367 0382 	bfi	r3, r7, #2, #1
    6988:	7323      	strb	r3, [r4, #12]
            lv_obj_set_style(new_img, &lv_style_plain); /*Set a style for screens*/
    698a:	490f      	ldr	r1, [pc, #60]	; (69c8 <lv_img_create+0xe0>)
    698c:	e7f0      	b.n	6970 <lv_img_create+0x88>
        lv_img_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
    698e:	4630      	mov	r0, r6
    6990:	f003 f99d 	bl	9cce <lv_obj_get_ext_attr>
        ext->auto_size          = copy_ext->auto_size;
    6994:	7b03      	ldrb	r3, [r0, #12]
    6996:	7b22      	ldrb	r2, [r4, #12]
    6998:	f3c3 0380 	ubfx	r3, r3, #2, #1
    699c:	f363 0282 	bfi	r2, r3, #2, #1
    69a0:	7322      	strb	r2, [r4, #12]
        lv_img_set_src(new_img, copy_ext->src);
    69a2:	6801      	ldr	r1, [r0, #0]
    69a4:	4628      	mov	r0, r5
    69a6:	f7ff fee9 	bl	677c <lv_img_set_src>
        lv_obj_refresh_style(new_img);
    69aa:	4628      	mov	r0, r5
    69ac:	f002 ff50 	bl	9850 <lv_obj_refresh_style>
    69b0:	e7e1      	b.n	6976 <lv_img_create+0x8e>
    69b2:	bf00      	nop
    69b4:	20000674 	.word	0x20000674
    69b8:	000069cd 	.word	0x000069cd
    69bc:	00006621 	.word	0x00006621
    69c0:	00045d3b 	.word	0x00045d3b
    69c4:	00045d75 	.word	0x00045d75
    69c8:	20000398 	.word	0x20000398

000069cc <lv_img_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_img_signal(lv_obj_t * img, lv_signal_t sign, void * param)
{
    69cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(img, sign, param);
    69ce:	4b19      	ldr	r3, [pc, #100]	; (6a34 <lv_img_signal+0x68>)
    69d0:	681b      	ldr	r3, [r3, #0]
{
    69d2:	4607      	mov	r7, r0
    69d4:	460d      	mov	r5, r1
    69d6:	4614      	mov	r4, r2
    res = ancestor_signal(img, sign, param);
    69d8:	4798      	blx	r3
    if(res != LV_RES_OK) return res;
    69da:	2801      	cmp	r0, #1
    res = ancestor_signal(img, sign, param);
    69dc:	4606      	mov	r6, r0
    if(res != LV_RES_OK) return res;
    69de:	d11a      	bne.n	6a16 <lv_img_signal+0x4a>

    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    69e0:	2d07      	cmp	r5, #7
    69e2:	d105      	bne.n	69f0 <lv_img_signal+0x24>
    69e4:	4620      	mov	r0, r4
    69e6:	4914      	ldr	r1, [pc, #80]	; (6a38 <lv_img_signal+0x6c>)
            lv_img_set_src(img, ext->src);
        }
    }

    return res;
}
    69e8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    69ec:	f003 b971 	b.w	9cd2 <lv_obj_handle_get_type_signal>
    lv_img_ext_t * ext = lv_obj_get_ext_attr(img);
    69f0:	4638      	mov	r0, r7
    69f2:	f003 f96c 	bl	9cce <lv_obj_get_ext_attr>
    69f6:	4604      	mov	r4, r0
    if(sign == LV_SIGNAL_CLEANUP) {
    69f8:	b97d      	cbnz	r5, 6a1a <lv_img_signal+0x4e>
        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
    69fa:	7b03      	ldrb	r3, [r0, #12]
    69fc:	f003 0303 	and.w	r3, r3, #3
    6a00:	3b01      	subs	r3, #1
    6a02:	2b01      	cmp	r3, #1
    6a04:	d807      	bhi.n	6a16 <lv_img_signal+0x4a>
            lv_mem_free(ext->src);
    6a06:	6800      	ldr	r0, [r0, #0]
    6a08:	f7ff f914 	bl	5c34 <lv_mem_free>
            ext->src_type = LV_IMG_SRC_UNKNOWN;
    6a0c:	7b23      	ldrb	r3, [r4, #12]
            ext->src      = NULL;
    6a0e:	6025      	str	r5, [r4, #0]
            ext->src_type = LV_IMG_SRC_UNKNOWN;
    6a10:	f043 0303 	orr.w	r3, r3, #3
    6a14:	7323      	strb	r3, [r4, #12]
}
    6a16:	4630      	mov	r0, r6
    6a18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
    6a1a:	2d04      	cmp	r5, #4
    6a1c:	d1fb      	bne.n	6a16 <lv_img_signal+0x4a>
        if(ext->src_type == LV_IMG_SRC_SYMBOL) {
    6a1e:	7b03      	ldrb	r3, [r0, #12]
    6a20:	f003 0303 	and.w	r3, r3, #3
    6a24:	2b02      	cmp	r3, #2
    6a26:	d1f6      	bne.n	6a16 <lv_img_signal+0x4a>
            lv_img_set_src(img, ext->src);
    6a28:	6801      	ldr	r1, [r0, #0]
    6a2a:	4638      	mov	r0, r7
    6a2c:	f7ff fea6 	bl	677c <lv_img_set_src>
    6a30:	e7f1      	b.n	6a16 <lv_img_signal+0x4a>
    6a32:	bf00      	nop
    6a34:	20000674 	.word	0x20000674
    6a38:	00045e1c 	.word	0x00045e1c

00006a3c <lv_theme_get_current>:
    if(!inited)
        return NULL;
    else
        return &current_theme;
#endif
}
    6a3c:	4b01      	ldr	r3, [pc, #4]	; (6a44 <lv_theme_get_current+0x8>)
    6a3e:	6818      	ldr	r0, [r3, #0]
    6a40:	4770      	bx	lr
    6a42:	bf00      	nop
    6a44:	20000678 	.word	0x20000678

00006a48 <bits_write>:
 * @param len length of bits to write from `val`. (Counted from the LSB).
 * @note `len == 3` will be converted to `len = 4` and `val` will be upscaled too
 */
static void bits_write(uint8_t * out, uint32_t bit_pos, uint8_t val, uint8_t len)
{
    if(len == 3) {
    6a48:	2b03      	cmp	r3, #3
{
    6a4a:	b530      	push	{r4, r5, lr}
    if(len == 3) {
    6a4c:	d104      	bne.n	6a58 <bits_write+0x10>
        len = 4;
        switch(val) {
    6a4e:	2a07      	cmp	r2, #7
    6a50:	bf9c      	itt	ls
    6a52:	4b0a      	ldrls	r3, [pc, #40]	; (6a7c <bits_write+0x34>)
    6a54:	5c9a      	ldrbls	r2, [r3, r2]
        len = 4;
    6a56:	2304      	movs	r3, #4
        case 7: val = 15; break;
        }
    }

    uint16_t byte_pos = bit_pos >> 3;
    bit_pos = bit_pos & 0x7;
    6a58:	f001 0507 	and.w	r5, r1, #7
    bit_pos = 8 - bit_pos - len;

    uint8_t bit_mask = (uint16_t)((uint16_t) 1 << len) - 1;
    6a5c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    out[byte_pos] &= ((~bit_mask) << bit_pos);
    6a60:	f3c1 01cf 	ubfx	r1, r1, #3, #16
    6a64:	409c      	lsls	r4, r3
    6a66:	f1c5 0508 	rsb	r5, r5, #8
    bit_pos = 8 - bit_pos - len;
    6a6a:	1aed      	subs	r5, r5, r3
    out[byte_pos] &= ((~bit_mask) << bit_pos);
    6a6c:	b264      	sxtb	r4, r4
    6a6e:	5c43      	ldrb	r3, [r0, r1]
    6a70:	40ac      	lsls	r4, r5
    6a72:	401c      	ands	r4, r3
    out[byte_pos] |= (val << bit_pos);
    6a74:	40aa      	lsls	r2, r5
    6a76:	4314      	orrs	r4, r2
    6a78:	5444      	strb	r4, [r0, r1]
}
    6a7a:	bd30      	pop	{r4, r5, pc}
    6a7c:	00045e23 	.word	0x00045e23

00006a80 <rle_next>:
    rle_prev_v = 0;
    rle_cnt = 0;
}

static uint8_t rle_next(void)
{
    6a80:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint8_t v = 0;
    uint8_t ret = 0;

    if(rle_state == RLE_STATE_SINGLE) {
    6a84:	4e4a      	ldr	r6, [pc, #296]	; (6bb0 <rle_next+0x130>)
    6a86:	f896 9000 	ldrb.w	r9, [r6]
    6a8a:	f1b9 0f00 	cmp.w	r9, #0
    6a8e:	d11d      	bne.n	6acc <rle_next+0x4c>
        ret = get_bits(rle_in, rle_rdp, rle_bpp);
    6a90:	4b48      	ldr	r3, [pc, #288]	; (6bb4 <rle_next+0x134>)
    6a92:	4d49      	ldr	r5, [pc, #292]	; (6bb8 <rle_next+0x138>)
    6a94:	781f      	ldrb	r7, [r3, #0]
    6a96:	f8d5 8000 	ldr.w	r8, [r5]
    6a9a:	4b48      	ldr	r3, [pc, #288]	; (6bbc <rle_next+0x13c>)
    6a9c:	463a      	mov	r2, r7
    6a9e:	6818      	ldr	r0, [r3, #0]
    6aa0:	4641      	mov	r1, r8
    6aa2:	f005 f8a3 	bl	bbec <get_bits>
    6aa6:	4b46      	ldr	r3, [pc, #280]	; (6bc0 <rle_next+0x140>)
    6aa8:	4604      	mov	r4, r0
        if(rle_rdp != 0 && rle_prev_v == ret) {
    6aaa:	f1b8 0f00 	cmp.w	r8, #0
    6aae:	d007      	beq.n	6ac0 <rle_next+0x40>
    6ab0:	781a      	ldrb	r2, [r3, #0]
    6ab2:	4282      	cmp	r2, r0
            rle_cnt = 0;
    6ab4:	bf01      	itttt	eq
    6ab6:	4a43      	ldreq	r2, [pc, #268]	; (6bc4 <rle_next+0x144>)
    6ab8:	f882 9000 	strbeq.w	r9, [r2]
            rle_state = RLE_STATE_REPEATE;
    6abc:	2201      	moveq	r2, #1
    6abe:	7032      	strbeq	r2, [r6, #0]
        }

        rle_prev_v = ret;
        rle_rdp += rle_bpp;
    6ac0:	4447      	add	r7, r8
        rle_prev_v = ret;
    6ac2:	701c      	strb	r4, [r3, #0]
        rle_rdp += rle_bpp;
    6ac4:	602f      	str	r7, [r5, #0]
            rle_state = RLE_STATE_SINGLE;
        }
    }

    return ret;
}
    6ac6:	4620      	mov	r0, r4
    6ac8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    else if(rle_state == RLE_STATE_REPEATE) {
    6acc:	f1b9 0f01 	cmp.w	r9, #1
    6ad0:	d149      	bne.n	6b66 <rle_next+0xe6>
        v = get_bits(rle_in, rle_rdp, 1);
    6ad2:	4b3a      	ldr	r3, [pc, #232]	; (6bbc <rle_next+0x13c>)
    6ad4:	4f38      	ldr	r7, [pc, #224]	; (6bb8 <rle_next+0x138>)
    6ad6:	f8d3 8000 	ldr.w	r8, [r3]
    6ada:	683d      	ldr	r5, [r7, #0]
        rle_cnt++;
    6adc:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 6bc4 <rle_next+0x144>
        v = get_bits(rle_in, rle_rdp, 1);
    6ae0:	464a      	mov	r2, r9
    6ae2:	4629      	mov	r1, r5
    6ae4:	4640      	mov	r0, r8
    6ae6:	f005 f881 	bl	bbec <get_bits>
        rle_cnt++;
    6aea:	f89a 3000 	ldrb.w	r3, [sl]
    6aee:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 6bc0 <rle_next+0x140>
    6af2:	3301      	adds	r3, #1
    6af4:	b2db      	uxtb	r3, r3
        rle_rdp += 1;
    6af6:	f105 0b01 	add.w	fp, r5, #1
        if(v == 1) {
    6afa:	2801      	cmp	r0, #1
        rle_cnt++;
    6afc:	f88a 3000 	strb.w	r3, [sl]
        rle_rdp += 1;
    6b00:	f8c7 b000 	str.w	fp, [r7]
        if(v == 1) {
    6b04:	d121      	bne.n	6b4a <rle_next+0xca>
            if(rle_cnt == 11) {
    6b06:	2b0b      	cmp	r3, #11
            ret = rle_prev_v;
    6b08:	f899 4000 	ldrb.w	r4, [r9]
            if(rle_cnt == 11) {
    6b0c:	d1db      	bne.n	6ac6 <rle_next+0x46>
                rle_cnt = get_bits(rle_in, rle_rdp, 6);
    6b0e:	4659      	mov	r1, fp
    6b10:	2206      	movs	r2, #6
    6b12:	4640      	mov	r0, r8
    6b14:	f005 f86a 	bl	bbec <get_bits>
                rle_rdp += 6;
    6b18:	3507      	adds	r5, #7
                rle_cnt = get_bits(rle_in, rle_rdp, 6);
    6b1a:	4683      	mov	fp, r0
    6b1c:	f88a 0000 	strb.w	r0, [sl]
                rle_rdp += 6;
    6b20:	603d      	str	r5, [r7, #0]
                if(rle_cnt != 0) {
    6b22:	b110      	cbz	r0, 6b2a <rle_next+0xaa>
                    rle_state = RLE_STATE_COUNTER;
    6b24:	2302      	movs	r3, #2
            rle_state = RLE_STATE_SINGLE;
    6b26:	7033      	strb	r3, [r6, #0]
    6b28:	e7cd      	b.n	6ac6 <rle_next+0x46>
                    ret = get_bits(rle_in, rle_rdp, rle_bpp);
    6b2a:	4b22      	ldr	r3, [pc, #136]	; (6bb4 <rle_next+0x134>)
    6b2c:	f893 a000 	ldrb.w	sl, [r3]
    6b30:	4629      	mov	r1, r5
    6b32:	4652      	mov	r2, sl
    6b34:	4640      	mov	r0, r8
    6b36:	f005 f859 	bl	bbec <get_bits>
                    rle_rdp += rle_bpp;
    6b3a:	4455      	add	r5, sl
                    ret = get_bits(rle_in, rle_rdp, rle_bpp);
    6b3c:	4604      	mov	r4, r0
                    rle_prev_v = ret;
    6b3e:	f889 0000 	strb.w	r0, [r9]
                    rle_rdp += rle_bpp;
    6b42:	603d      	str	r5, [r7, #0]
                    rle_state = RLE_STATE_SINGLE;
    6b44:	f886 b000 	strb.w	fp, [r6]
    6b48:	e7bd      	b.n	6ac6 <rle_next+0x46>
            ret = get_bits(rle_in, rle_rdp, rle_bpp);
    6b4a:	4b1a      	ldr	r3, [pc, #104]	; (6bb4 <rle_next+0x134>)
    6b4c:	781d      	ldrb	r5, [r3, #0]
    6b4e:	4659      	mov	r1, fp
    6b50:	462a      	mov	r2, r5
    6b52:	4640      	mov	r0, r8
    6b54:	f005 f84a 	bl	bbec <get_bits>
            rle_rdp += rle_bpp;
    6b58:	445d      	add	r5, fp
            ret = get_bits(rle_in, rle_rdp, rle_bpp);
    6b5a:	4604      	mov	r4, r0
            rle_prev_v = ret;
    6b5c:	f889 0000 	strb.w	r0, [r9]
            rle_rdp += rle_bpp;
    6b60:	603d      	str	r5, [r7, #0]
            rle_state = RLE_STATE_SINGLE;
    6b62:	2300      	movs	r3, #0
    6b64:	e7df      	b.n	6b26 <rle_next+0xa6>
    else if(rle_state == RLE_STATE_COUNTER) {
    6b66:	f1b9 0f02 	cmp.w	r9, #2
    6b6a:	d11e      	bne.n	6baa <rle_next+0x12a>
        rle_cnt--;
    6b6c:	4b15      	ldr	r3, [pc, #84]	; (6bc4 <rle_next+0x144>)
        ret = rle_prev_v;
    6b6e:	f8df a050 	ldr.w	sl, [pc, #80]	; 6bc0 <rle_next+0x140>
        rle_cnt--;
    6b72:	781d      	ldrb	r5, [r3, #0]
        ret = rle_prev_v;
    6b74:	f89a 4000 	ldrb.w	r4, [sl]
        rle_cnt--;
    6b78:	3d01      	subs	r5, #1
    6b7a:	b2ed      	uxtb	r5, r5
    6b7c:	701d      	strb	r5, [r3, #0]
        if(rle_cnt == 0) {
    6b7e:	2d00      	cmp	r5, #0
    6b80:	d1a1      	bne.n	6ac6 <rle_next+0x46>
            ret = get_bits(rle_in, rle_rdp, rle_bpp);
    6b82:	f8df 8034 	ldr.w	r8, [pc, #52]	; 6bb8 <rle_next+0x138>
    6b86:	4b0b      	ldr	r3, [pc, #44]	; (6bb4 <rle_next+0x134>)
    6b88:	f8d8 9000 	ldr.w	r9, [r8]
    6b8c:	781f      	ldrb	r7, [r3, #0]
    6b8e:	4b0b      	ldr	r3, [pc, #44]	; (6bbc <rle_next+0x13c>)
    6b90:	463a      	mov	r2, r7
    6b92:	4649      	mov	r1, r9
    6b94:	6818      	ldr	r0, [r3, #0]
    6b96:	f005 f829 	bl	bbec <get_bits>
            rle_rdp += rle_bpp;
    6b9a:	444f      	add	r7, r9
            ret = get_bits(rle_in, rle_rdp, rle_bpp);
    6b9c:	4604      	mov	r4, r0
            rle_prev_v = ret;
    6b9e:	f88a 0000 	strb.w	r0, [sl]
            rle_rdp += rle_bpp;
    6ba2:	f8c8 7000 	str.w	r7, [r8]
            rle_state = RLE_STATE_SINGLE;
    6ba6:	7035      	strb	r5, [r6, #0]
    6ba8:	e78d      	b.n	6ac6 <rle_next+0x46>
    uint8_t ret = 0;
    6baa:	2400      	movs	r4, #0
    6bac:	e78b      	b.n	6ac6 <rle_next+0x46>
    6bae:	bf00      	nop
    6bb0:	20008b93 	.word	0x20008b93
    6bb4:	20008b90 	.word	0x20008b90
    6bb8:	20000684 	.word	0x20000684
    6bbc:	20000680 	.word	0x20000680
    6bc0:	20008b92 	.word	0x20008b92
    6bc4:	20008b91 	.word	0x20008b91

00006bc8 <get_glyph_dsc_id.isra.0.part.1>:
static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
    6bc8:	b5f0      	push	{r4, r5, r6, r7, lr}
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
    6bca:	6804      	ldr	r4, [r0, #0]
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
    6bcc:	6963      	ldr	r3, [r4, #20]
    6bce:	428b      	cmp	r3, r1
static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
    6bd0:	b085      	sub	sp, #20
    6bd2:	460d      	mov	r5, r1
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
    6bd4:	d145      	bne.n	6c62 <get_glyph_dsc_id.isra.0.part.1+0x9a>
    6bd6:	69a0      	ldr	r0, [r4, #24]
}
    6bd8:	b005      	add	sp, #20
    6bda:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
    6bdc:	68a2      	ldr	r2, [r4, #8]
    6bde:	fb07 f603 	mul.w	r6, r7, r3
    6be2:	1991      	adds	r1, r2, r6
    6be4:	5992      	ldr	r2, [r2, r6]
        if(rcp > fdsc->cmaps[i].range_length) continue;
    6be6:	8888      	ldrh	r0, [r1, #4]
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
    6be8:	1aaa      	subs	r2, r5, r2
        if(rcp > fdsc->cmaps[i].range_length) continue;
    6bea:	4282      	cmp	r2, r0
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
    6bec:	9203      	str	r2, [sp, #12]
        if(rcp > fdsc->cmaps[i].range_length) continue;
    6bee:	f103 0301 	add.w	r3, r3, #1
    6bf2:	d838      	bhi.n	6c66 <get_glyph_dsc_id.isra.0.part.1+0x9e>
        if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY) {
    6bf4:	7c8b      	ldrb	r3, [r1, #18]
    6bf6:	b923      	cbnz	r3, 6c02 <get_glyph_dsc_id.isra.0.part.1+0x3a>
            glyph_id = fdsc->cmaps[i].glyph_id_start + rcp;
    6bf8:	88c8      	ldrh	r0, [r1, #6]
    6bfa:	4410      	add	r0, r2
        fdsc->last_letter = letter;
    6bfc:	6165      	str	r5, [r4, #20]
    fdsc->last_glyph_id = 0;
    6bfe:	61a0      	str	r0, [r4, #24]
    return 0;
    6c00:	e7ea      	b.n	6bd8 <get_glyph_dsc_id.isra.0.part.1+0x10>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL) {
    6c02:	2b01      	cmp	r3, #1
    6c04:	d104      	bne.n	6c10 <get_glyph_dsc_id.isra.0.part.1+0x48>
            glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_8[rcp];
    6c06:	68cb      	ldr	r3, [r1, #12]
    6c08:	5c98      	ldrb	r0, [r3, r2]
    6c0a:	88cb      	ldrh	r3, [r1, #6]
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
    6c0c:	4418      	add	r0, r3
    6c0e:	e7f5      	b.n	6bfc <get_glyph_dsc_id.isra.0.part.1+0x34>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_TINY) {
    6c10:	2b02      	cmp	r3, #2
    6c12:	d111      	bne.n	6c38 <get_glyph_dsc_id.isra.0.part.1+0x70>
            uint8_t * p = lv_utils_bsearch(&rcp, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length, sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);
    6c14:	4818      	ldr	r0, [pc, #96]	; (6c78 <get_glyph_dsc_id.isra.0.part.1+0xb0>)
    6c16:	8a0a      	ldrh	r2, [r1, #16]
    6c18:	9000      	str	r0, [sp, #0]
    6c1a:	6889      	ldr	r1, [r1, #8]
    6c1c:	a803      	add	r0, sp, #12
    6c1e:	f004 fd9f 	bl	b760 <lv_utils_bsearch>
            if(p) {
    6c22:	b908      	cbnz	r0, 6c28 <get_glyph_dsc_id.isra.0.part.1+0x60>
        uint32_t glyph_id = 0;
    6c24:	2000      	movs	r0, #0
    6c26:	e7e9      	b.n	6bfc <get_glyph_dsc_id.isra.0.part.1+0x34>
                lv_uintptr_t ofs = (lv_uintptr_t)(p - (uint8_t *) fdsc->cmaps[i].unicode_list);
    6c28:	68a3      	ldr	r3, [r4, #8]
    6c2a:	4433      	add	r3, r6
    6c2c:	689a      	ldr	r2, [r3, #8]
    6c2e:	1a82      	subs	r2, r0, r2
                glyph_id = fdsc->cmaps[i].glyph_id_start + ofs;
    6c30:	88d8      	ldrh	r0, [r3, #6]
    6c32:	eb00 0052 	add.w	r0, r0, r2, lsr #1
    6c36:	e7e1      	b.n	6bfc <get_glyph_dsc_id.isra.0.part.1+0x34>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_FULL) {
    6c38:	2b03      	cmp	r3, #3
    6c3a:	d1f3      	bne.n	6c24 <get_glyph_dsc_id.isra.0.part.1+0x5c>
            uint8_t * p = lv_utils_bsearch(&rcp, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length, sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);
    6c3c:	4b0e      	ldr	r3, [pc, #56]	; (6c78 <get_glyph_dsc_id.isra.0.part.1+0xb0>)
    6c3e:	8a0a      	ldrh	r2, [r1, #16]
    6c40:	9300      	str	r3, [sp, #0]
    6c42:	6889      	ldr	r1, [r1, #8]
    6c44:	2302      	movs	r3, #2
    6c46:	a803      	add	r0, sp, #12
    6c48:	f004 fd8a 	bl	b760 <lv_utils_bsearch>
            if(p) {
    6c4c:	2800      	cmp	r0, #0
    6c4e:	d0e9      	beq.n	6c24 <get_glyph_dsc_id.isra.0.part.1+0x5c>
                lv_uintptr_t ofs = (lv_uintptr_t)(p - (uint8_t*) fdsc->cmaps[i].unicode_list);
    6c50:	68a3      	ldr	r3, [r4, #8]
    6c52:	4433      	add	r3, r6
    6c54:	689a      	ldr	r2, [r3, #8]
    6c56:	1a80      	subs	r0, r0, r2
                ofs = ofs >> 1;     /*The list stores `uint16_t` so the get the index divide by 2*/
    6c58:	0840      	lsrs	r0, r0, #1
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
    6c5a:	68da      	ldr	r2, [r3, #12]
    6c5c:	88db      	ldrh	r3, [r3, #6]
    6c5e:	5c10      	ldrb	r0, [r2, r0]
    6c60:	e7d4      	b.n	6c0c <get_glyph_dsc_id.isra.0.part.1+0x44>
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
    6c62:	2300      	movs	r3, #0
    6c64:	2714      	movs	r7, #20
    for(i = 0; i < fdsc->cmap_num; i++) {
    6c66:	8a62      	ldrh	r2, [r4, #18]
    6c68:	b299      	uxth	r1, r3
    6c6a:	f3c2 0209 	ubfx	r2, r2, #0, #10
    6c6e:	428a      	cmp	r2, r1
    6c70:	d8b4      	bhi.n	6bdc <get_glyph_dsc_id.isra.0.part.1+0x14>
    fdsc->last_letter = letter;
    6c72:	6165      	str	r5, [r4, #20]
    fdsc->last_glyph_id = 0;
    6c74:	2000      	movs	r0, #0
    6c76:	e7c2      	b.n	6bfe <get_glyph_dsc_id.isra.0.part.1+0x36>
    6c78:	0000bc15 	.word	0x0000bc15

00006c7c <lv_font_get_bitmap_fmt_txt>:
{
    6c7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6c80:	b087      	sub	sp, #28
    if(letter == '\0') return 0;
    6c82:	b919      	cbnz	r1, 6c8c <lv_font_get_bitmap_fmt_txt+0x10>
    if(!gid) return NULL;
    6c84:	2000      	movs	r0, #0
}
    6c86:	b007      	add	sp, #28
    6c88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
    6c8c:	f850 6f0c 	ldr.w	r6, [r0, #12]!
    6c90:	f7ff ff9a 	bl	6bc8 <get_glyph_dsc_id.isra.0.part.1>
    if(!gid) return NULL;
    6c94:	4680      	mov	r8, r0
    6c96:	2800      	cmp	r0, #0
    6c98:	d0f4      	beq.n	6c84 <lv_font_get_bitmap_fmt_txt+0x8>
    if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {
    6c9a:	7cf3      	ldrb	r3, [r6, #19]
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
    6c9c:	f8d6 9004 	ldr.w	r9, [r6, #4]
    if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {
    6ca0:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
    6ca4:	eb09 07c0 	add.w	r7, r9, r0, lsl #3
    if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {
    6ca8:	d108      	bne.n	6cbc <lv_font_get_bitmap_fmt_txt+0x40>
        if(gdsc) return &fdsc->glyph_bitmap[gdsc->bitmap_index];
    6caa:	2f00      	cmp	r7, #0
    6cac:	d0ea      	beq.n	6c84 <lv_font_get_bitmap_fmt_txt+0x8>
    6cae:	f859 3030 	ldr.w	r3, [r9, r0, lsl #3]
    6cb2:	6830      	ldr	r0, [r6, #0]
    6cb4:	f3c3 0313 	ubfx	r3, r3, #0, #20
    6cb8:	4418      	add	r0, r3
    6cba:	e7e4      	b.n	6c86 <lv_font_get_bitmap_fmt_txt+0xa>
        uint32_t gsize = gdsc->box_w * gdsc->box_h;
    6cbc:	793c      	ldrb	r4, [r7, #4]
    6cbe:	7979      	ldrb	r1, [r7, #5]
    6cc0:	fb14 f401 	smulbb	r4, r4, r1
        if(gsize == 0) return NULL;
    6cc4:	2c00      	cmp	r4, #0
    6cc6:	d0dd      	beq.n	6c84 <lv_font_get_bitmap_fmt_txt+0x8>
        switch(fdsc->bpp) {
    6cc8:	f3c3 0382 	ubfx	r3, r3, #2, #3
    6ccc:	3b01      	subs	r3, #1
    6cce:	2b03      	cmp	r3, #3
    6cd0:	d804      	bhi.n	6cdc <lv_font_get_bitmap_fmt_txt+0x60>
    6cd2:	e8df f003 	tbb	[pc, r3]
    6cd6:	4502      	.short	0x4502
    6cd8:	4747      	.short	0x4747
        case 1: buf_size = gsize >> 3;  break;
    6cda:	08e4      	lsrs	r4, r4, #3
        if(lv_mem_get_size(buf) < buf_size) {
    6cdc:	4d41      	ldr	r5, [pc, #260]	; (6de4 <lv_font_get_bitmap_fmt_txt+0x168>)
    6cde:	6828      	ldr	r0, [r5, #0]
    6ce0:	f7fe ffb8 	bl	5c54 <lv_mem_get_size>
    6ce4:	42a0      	cmp	r0, r4
    6ce6:	d33f      	bcc.n	6d68 <lv_font_get_bitmap_fmt_txt+0xec>
        decompress(&fdsc->glyph_bitmap[gdsc->bitmap_index], buf, gdsc->box_w , gdsc->box_h, (uint8_t)fdsc->bpp);
    6ce8:	f859 2038 	ldr.w	r2, [r9, r8, lsl #3]
    6cec:	6833      	ldr	r3, [r6, #0]
    6cee:	f3c2 0213 	ubfx	r2, r2, #0, #20
    6cf2:	441a      	add	r2, r3
    6cf4:	682b      	ldr	r3, [r5, #0]
    6cf6:	9302      	str	r3, [sp, #8]
    6cf8:	797b      	ldrb	r3, [r7, #5]
    6cfa:	9304      	str	r3, [sp, #16]
    6cfc:	7cf3      	ldrb	r3, [r6, #19]
    6cfe:	793d      	ldrb	r5, [r7, #4]
    6d00:	f3c3 0382 	ubfx	r3, r3, #2, #3
    6d04:	b2df      	uxtb	r7, r3
    if(bpp == 3) wr_size = 4;
    6d06:	2f03      	cmp	r7, #3
    6d08:	bf14      	ite	ne
    6d0a:	4639      	movne	r1, r7
    6d0c:	2104      	moveq	r1, #4
    6d0e:	9100      	str	r1, [sp, #0]
    rle_in = in;
    6d10:	4935      	ldr	r1, [pc, #212]	; (6de8 <lv_font_get_bitmap_fmt_txt+0x16c>)
    6d12:	600a      	str	r2, [r1, #0]
    rle_bpp = bpp;
    6d14:	4a35      	ldr	r2, [pc, #212]	; (6dec <lv_font_get_bitmap_fmt_txt+0x170>)
    6d16:	7013      	strb	r3, [r2, #0]
    rle_state = RLE_STATE_SINGLE;
    6d18:	4a35      	ldr	r2, [pc, #212]	; (6df0 <lv_font_get_bitmap_fmt_txt+0x174>)
    6d1a:	2300      	movs	r3, #0
    6d1c:	7013      	strb	r3, [r2, #0]
    rle_rdp = 0;
    6d1e:	4a35      	ldr	r2, [pc, #212]	; (6df4 <lv_font_get_bitmap_fmt_txt+0x178>)
    6d20:	6013      	str	r3, [r2, #0]
    rle_prev_v = 0;
    6d22:	4a35      	ldr	r2, [pc, #212]	; (6df8 <lv_font_get_bitmap_fmt_txt+0x17c>)
    6d24:	7013      	strb	r3, [r2, #0]
    rle_cnt = 0;
    6d26:	4a35      	ldr	r2, [pc, #212]	; (6dfc <lv_font_get_bitmap_fmt_txt+0x180>)
    uint8_t * line_buf = lv_draw_get_buf(w * 2);
    6d28:	0068      	lsls	r0, r5, #1
    rle_cnt = 0;
    6d2a:	7013      	strb	r3, [r2, #0]
    uint8_t * line_buf = lv_draw_get_buf(w * 2);
    6d2c:	f7fd fe50 	bl	49d0 <lv_draw_get_buf>
    6d30:	4680      	mov	r8, r0
    uint8_t * line_buf2 = line_buf + w;
    6d32:	1946      	adds	r6, r0, r5
static void decompress_line(uint8_t * out, lv_coord_t w)
    6d34:	4681      	mov	r9, r0
    uint8_t * line_buf2 = line_buf + w;
    6d36:	4604      	mov	r4, r0
    for(i = 0; i < w; i++) {
    6d38:	42b4      	cmp	r4, r6
    6d3a:	d11d      	bne.n	6d78 <lv_font_get_bitmap_fmt_txt+0xfc>
    uint32_t wrp = 0;
    6d3c:	f04f 0a00 	mov.w	sl, #0
    for(x = 0; x < w; x++) {
    6d40:	45a1      	cmp	r9, r4
    6d42:	d11e      	bne.n	6d82 <lv_font_get_bitmap_fmt_txt+0x106>
    6d44:	9b00      	ldr	r3, [sp, #0]
    6d46:	fb15 f303 	smulbb	r3, r5, r3
    6d4a:	9303      	str	r3, [sp, #12]
    6d4c:	4699      	mov	r9, r3
    6d4e:	1973      	adds	r3, r6, r5
    for(y = 1; y < h; y++) {
    6d50:	2401      	movs	r4, #1
    6d52:	9305      	str	r3, [sp, #20]
    6d54:	9b04      	ldr	r3, [sp, #16]
    6d56:	42a3      	cmp	r3, r4
    6d58:	dd40      	ble.n	6ddc <lv_font_get_bitmap_fmt_txt+0x160>
    6d5a:	9601      	str	r6, [sp, #4]
    6d5c:	4635      	mov	r5, r6
    6d5e:	e01e      	b.n	6d9e <lv_font_get_bitmap_fmt_txt+0x122>
        case 2: buf_size = gsize >> 2;  break;
    6d60:	08a4      	lsrs	r4, r4, #2
    6d62:	e7bb      	b.n	6cdc <lv_font_get_bitmap_fmt_txt+0x60>
        case 4: buf_size = gsize >> 1;  break;
    6d64:	0864      	lsrs	r4, r4, #1
    6d66:	e7b9      	b.n	6cdc <lv_font_get_bitmap_fmt_txt+0x60>
            buf = lv_mem_realloc(buf, buf_size);
    6d68:	4621      	mov	r1, r4
    6d6a:	6828      	ldr	r0, [r5, #0]
    6d6c:	f7fe ff80 	bl	5c70 <lv_mem_realloc>
    6d70:	6028      	str	r0, [r5, #0]
            if(buf == NULL) return NULL;
    6d72:	2800      	cmp	r0, #0
    6d74:	d1b8      	bne.n	6ce8 <lv_font_get_bitmap_fmt_txt+0x6c>
    6d76:	e785      	b.n	6c84 <lv_font_get_bitmap_fmt_txt+0x8>
        out[i] = rle_next();
    6d78:	f7ff fe82 	bl	6a80 <rle_next>
    6d7c:	f804 0b01 	strb.w	r0, [r4], #1
    6d80:	e7da      	b.n	6d38 <lv_font_get_bitmap_fmt_txt+0xbc>
        bits_write(out,wrp, line_buf1[x], bpp);
    6d82:	463b      	mov	r3, r7
    6d84:	4651      	mov	r1, sl
    6d86:	f819 2b01 	ldrb.w	r2, [r9], #1
    6d8a:	9802      	ldr	r0, [sp, #8]
    6d8c:	f7ff fe5c 	bl	6a48 <bits_write>
        wrp += wr_size;
    6d90:	9b00      	ldr	r3, [sp, #0]
    6d92:	449a      	add	sl, r3
    6d94:	e7d4      	b.n	6d40 <lv_font_get_bitmap_fmt_txt+0xc4>
        out[i] = rle_next();
    6d96:	f7ff fe73 	bl	6a80 <rle_next>
    6d9a:	f805 0b01 	strb.w	r0, [r5], #1
    for(i = 0; i < w; i++) {
    6d9e:	9b05      	ldr	r3, [sp, #20]
    6da0:	429d      	cmp	r5, r3
    6da2:	d1f8      	bne.n	6d96 <lv_font_get_bitmap_fmt_txt+0x11a>
    6da4:	f108 3bff 	add.w	fp, r8, #4294967295	; 0xffffffff
    6da8:	46ca      	mov	sl, r9
        for(x = 0; x < w; x++) {
    6daa:	9b01      	ldr	r3, [sp, #4]
    6dac:	42ab      	cmp	r3, r5
    6dae:	d104      	bne.n	6dba <lv_font_get_bitmap_fmt_txt+0x13e>
    6db0:	9b03      	ldr	r3, [sp, #12]
    for(y = 1; y < h; y++) {
    6db2:	3401      	adds	r4, #1
    6db4:	4499      	add	r9, r3
    6db6:	b224      	sxth	r4, r4
    6db8:	e7cc      	b.n	6d54 <lv_font_get_bitmap_fmt_txt+0xd8>
            line_buf1[x] = line_buf2[x] ^ line_buf1[x];
    6dba:	9b01      	ldr	r3, [sp, #4]
            bits_write(out,wrp, line_buf1[x], bpp);
    6dbc:	9802      	ldr	r0, [sp, #8]
            line_buf1[x] = line_buf2[x] ^ line_buf1[x];
    6dbe:	f813 2b01 	ldrb.w	r2, [r3], #1
    6dc2:	9301      	str	r3, [sp, #4]
    6dc4:	f81b 3f01 	ldrb.w	r3, [fp, #1]!
    6dc8:	405a      	eors	r2, r3
            bits_write(out,wrp, line_buf1[x], bpp);
    6dca:	4651      	mov	r1, sl
    6dcc:	463b      	mov	r3, r7
            line_buf1[x] = line_buf2[x] ^ line_buf1[x];
    6dce:	f88b 2000 	strb.w	r2, [fp]
            bits_write(out,wrp, line_buf1[x], bpp);
    6dd2:	f7ff fe39 	bl	6a48 <bits_write>
            wrp += wr_size;
    6dd6:	9b00      	ldr	r3, [sp, #0]
    6dd8:	449a      	add	sl, r3
    6dda:	e7e6      	b.n	6daa <lv_font_get_bitmap_fmt_txt+0x12e>
        return buf;
    6ddc:	4b01      	ldr	r3, [pc, #4]	; (6de4 <lv_font_get_bitmap_fmt_txt+0x168>)
    6dde:	6818      	ldr	r0, [r3, #0]
    6de0:	e751      	b.n	6c86 <lv_font_get_bitmap_fmt_txt+0xa>
    6de2:	bf00      	nop
    6de4:	2000067c 	.word	0x2000067c
    6de8:	20000680 	.word	0x20000680
    6dec:	20008b90 	.word	0x20008b90
    6df0:	20008b93 	.word	0x20008b93
    6df4:	20000684 	.word	0x20000684
    6df8:	20008b92 	.word	0x20008b92
    6dfc:	20008b91 	.word	0x20008b91

00006e00 <lv_font_get_glyph_dsc_fmt_txt>:
{
    6e00:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6e04:	4680      	mov	r8, r0
    6e06:	b085      	sub	sp, #20
    6e08:	460c      	mov	r4, r1
    6e0a:	4699      	mov	r9, r3
    if(letter == '\0') return 0;
    6e0c:	b91a      	cbnz	r2, 6e16 <lv_font_get_glyph_dsc_fmt_txt+0x16>
    if(!gid) return false;
    6e0e:	2000      	movs	r0, #0
}
    6e10:	b005      	add	sp, #20
    6e12:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
    6e16:	4607      	mov	r7, r0
    6e18:	4611      	mov	r1, r2
    6e1a:	f857 5f0c 	ldr.w	r5, [r7, #12]!
    6e1e:	4638      	mov	r0, r7
    6e20:	f7ff fed2 	bl	6bc8 <get_glyph_dsc_id.isra.0.part.1>
    if(!gid) return false;
    6e24:	4606      	mov	r6, r0
    6e26:	2800      	cmp	r0, #0
    6e28:	d0f1      	beq.n	6e0e <lv_font_get_glyph_dsc_fmt_txt+0xe>
    if(fdsc->kern_dsc) {
    6e2a:	68eb      	ldr	r3, [r5, #12]
    6e2c:	b9d3      	cbnz	r3, 6e64 <lv_font_get_glyph_dsc_fmt_txt+0x64>
    int8_t kvalue = 0;
    6e2e:	2000      	movs	r0, #0
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
    6e30:	686b      	ldr	r3, [r5, #4]
    6e32:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
    int32_t kv = ((int32_t)((int32_t)kvalue * fdsc->kern_scale) >> 4);
    6e36:	8a2b      	ldrh	r3, [r5, #16]
    6e38:	4358      	muls	r0, r3
    uint32_t adv_w = gdsc->adv_w + kv;
    6e3a:	8873      	ldrh	r3, [r6, #2]
    6e3c:	091b      	lsrs	r3, r3, #4
    6e3e:	eb03 1020 	add.w	r0, r3, r0, asr #4
    adv_w  = (adv_w + (1 << 3)) >> 4;
    6e42:	3008      	adds	r0, #8
    6e44:	0900      	lsrs	r0, r0, #4
    dsc_out->adv_w = adv_w;
    6e46:	8020      	strh	r0, [r4, #0]
    dsc_out->box_h = gdsc->box_h;
    6e48:	7973      	ldrb	r3, [r6, #5]
    6e4a:	70e3      	strb	r3, [r4, #3]
    dsc_out->box_w = gdsc->box_w;
    6e4c:	7933      	ldrb	r3, [r6, #4]
    6e4e:	70a3      	strb	r3, [r4, #2]
    dsc_out->ofs_x = gdsc->ofs_x;
    6e50:	79b3      	ldrb	r3, [r6, #6]
    6e52:	7123      	strb	r3, [r4, #4]
    dsc_out->ofs_y = gdsc->ofs_y;
    6e54:	79f3      	ldrb	r3, [r6, #7]
    6e56:	7163      	strb	r3, [r4, #5]
    dsc_out->bpp   = (uint8_t)fdsc->bpp;
    6e58:	7ceb      	ldrb	r3, [r5, #19]
    6e5a:	f3c3 0382 	ubfx	r3, r3, #2, #3
    6e5e:	71a3      	strb	r3, [r4, #6]
    return true;
    6e60:	2001      	movs	r0, #1
    6e62:	e7d5      	b.n	6e10 <lv_font_get_glyph_dsc_fmt_txt+0x10>
    if(letter == '\0') return 0;
    6e64:	f1b9 0f00 	cmp.w	r9, #0
    6e68:	d0e1      	beq.n	6e2e <lv_font_get_glyph_dsc_fmt_txt+0x2e>
    6e6a:	4649      	mov	r1, r9
    6e6c:	4638      	mov	r0, r7
    6e6e:	f7ff feab 	bl	6bc8 <get_glyph_dsc_id.isra.0.part.1>
        if(gid_next) {
    6e72:	2800      	cmp	r0, #0
    6e74:	d0db      	beq.n	6e2e <lv_font_get_glyph_dsc_fmt_txt+0x2e>
            kvalue = get_kern_value(font, gid, gid_next);
    6e76:	f8d8 300c 	ldr.w	r3, [r8, #12]
    if(fdsc->kern_classes == 0) {
    6e7a:	68df      	ldr	r7, [r3, #12]
    6e7c:	7cdb      	ldrb	r3, [r3, #19]
    6e7e:	069b      	lsls	r3, r3, #26
    6e80:	d432      	bmi.n	6ee8 <lv_font_get_glyph_dsc_fmt_txt+0xe8>
        if(kdsc->glyph_ids_size == 0) {
    6e82:	7afb      	ldrb	r3, [r7, #11]
    6e84:	f013 0303 	ands.w	r3, r3, #3
    6e88:	d117      	bne.n	6eba <lv_font_get_glyph_dsc_fmt_txt+0xba>
            const uint8_t * g_ids = kdsc->glyph_ids;
    6e8a:	f8d7 8000 	ldr.w	r8, [r7]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
    6e8e:	68ba      	ldr	r2, [r7, #8]
    6e90:	4b1d      	ldr	r3, [pc, #116]	; (6f08 <lv_font_get_glyph_dsc_fmt_txt+0x108>)
    6e92:	9300      	str	r3, [sp, #0]
            uint16_t g_id_both = (gid_right << 8) + gid_left; /*Create one number from the ids*/
    6e94:	eb06 2000 	add.w	r0, r6, r0, lsl #8
    6e98:	f8ad 000c 	strh.w	r0, [sp, #12]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
    6e9c:	2302      	movs	r3, #2
    6e9e:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6ea2:	4641      	mov	r1, r8
    6ea4:	a803      	add	r0, sp, #12
    6ea6:	f004 fc5b 	bl	b760 <lv_utils_bsearch>
            if(kid_p) {
    6eaa:	2800      	cmp	r0, #0
    6eac:	d0c0      	beq.n	6e30 <lv_font_get_glyph_dsc_fmt_txt+0x30>
                lv_uintptr_t ofs = (lv_uintptr_t)(kid_p - g_ids);
    6eae:	eba0 0008 	sub.w	r0, r0, r8
                ofs = ofs >> 1;     /*ofs is for pair, divide by 2 to refer as a single value*/
    6eb2:	0840      	lsrs	r0, r0, #1
                value = kdsc->values[ofs];
    6eb4:	687b      	ldr	r3, [r7, #4]
    6eb6:	5618      	ldrsb	r0, [r3, r0]
    6eb8:	e7ba      	b.n	6e30 <lv_font_get_glyph_dsc_fmt_txt+0x30>
        } else if(kdsc->glyph_ids_size == 1) {
    6eba:	2b01      	cmp	r3, #1
    6ebc:	d1b7      	bne.n	6e2e <lv_font_get_glyph_dsc_fmt_txt+0x2e>
            const uint16_t * g_ids = kdsc->glyph_ids;
    6ebe:	f8d7 8000 	ldr.w	r8, [r7]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
    6ec2:	68ba      	ldr	r2, [r7, #8]
    6ec4:	4b11      	ldr	r3, [pc, #68]	; (6f0c <lv_font_get_glyph_dsc_fmt_txt+0x10c>)
    6ec6:	9300      	str	r3, [sp, #0]
            lv_uintptr_t g_id_both = (uint32_t)((uint32_t)gid_right << 8) + gid_left; /*Create one number from the ids*/
    6ec8:	eb06 2000 	add.w	r0, r6, r0, lsl #8
    6ecc:	9003      	str	r0, [sp, #12]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
    6ece:	2304      	movs	r3, #4
    6ed0:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6ed4:	4641      	mov	r1, r8
    6ed6:	a803      	add	r0, sp, #12
    6ed8:	f004 fc42 	bl	b760 <lv_utils_bsearch>
            if(kid_p) {
    6edc:	2800      	cmp	r0, #0
    6ede:	d0a7      	beq.n	6e30 <lv_font_get_glyph_dsc_fmt_txt+0x30>
                lv_uintptr_t ofs = (lv_uintptr_t) (kid_p - (const uint8_t *)g_ids);
    6ee0:	eba0 0008 	sub.w	r0, r0, r8
                ofs = ofs >> 4;     /*ofs is 4 byte pairs, divide by 4 to refer as a single value*/
    6ee4:	0900      	lsrs	r0, r0, #4
    6ee6:	e7e5      	b.n	6eb4 <lv_font_get_glyph_dsc_fmt_txt+0xb4>
        uint8_t left_class = kdsc->left_class_mapping[gid_left];
    6ee8:	687a      	ldr	r2, [r7, #4]
    6eea:	5d93      	ldrb	r3, [r2, r6]
        if(left_class > 0 && right_class > 0) {
    6eec:	2b00      	cmp	r3, #0
    6eee:	d09e      	beq.n	6e2e <lv_font_get_glyph_dsc_fmt_txt+0x2e>
        uint8_t right_class = kdsc->left_class_mapping[gid_right];
    6ef0:	5c11      	ldrb	r1, [r2, r0]
        if(left_class > 0 && right_class > 0) {
    6ef2:	2900      	cmp	r1, #0
    6ef4:	d09b      	beq.n	6e2e <lv_font_get_glyph_dsc_fmt_txt+0x2e>
            value = kdsc->class_pair_values[(left_class-1)* kdsc->right_class_cnt + (right_class-1)];
    6ef6:	683a      	ldr	r2, [r7, #0]
    6ef8:	7b78      	ldrb	r0, [r7, #13]
    6efa:	3b01      	subs	r3, #1
    6efc:	440a      	add	r2, r1
    6efe:	fb00 2303 	mla	r3, r0, r3, r2
    6f02:	f913 0c01 	ldrsb.w	r0, [r3, #-1]
    6f06:	e793      	b.n	6e30 <lv_font_get_glyph_dsc_fmt_txt+0x30>
    6f08:	0000bbc9 	.word	0x0000bbc9
    6f0c:	0000bbdb 	.word	0x0000bbdb

00006f10 <z_sys_device_do_config_level>:
		__device_APPLICATION_start,
		/* End marker */
		__device_init_end,
	};

	for (info = config_levels[level]; info < config_levels[level+1];
    6f10:	4b09      	ldr	r3, [pc, #36]	; (6f38 <z_sys_device_do_config_level+0x28>)
{
    6f12:	b570      	push	{r4, r5, r6, lr}
	for (info = config_levels[level]; info < config_levels[level+1];
    6f14:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    6f18:	3001      	adds	r0, #1
		retval = device_conf->init(info);
		if (retval != 0) {
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
    6f1a:	2600      	movs	r6, #0
	for (info = config_levels[level]; info < config_levels[level+1];
    6f1c:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
    6f20:	42a5      	cmp	r5, r4
    6f22:	d800      	bhi.n	6f26 <z_sys_device_do_config_level+0x16>
		} else {
			z_object_init(info);
		}
	}
}
    6f24:	bd70      	pop	{r4, r5, r6, pc}
		retval = device_conf->init(info);
    6f26:	6823      	ldr	r3, [r4, #0]
    6f28:	4620      	mov	r0, r4
    6f2a:	685b      	ldr	r3, [r3, #4]
    6f2c:	4798      	blx	r3
		if (retval != 0) {
    6f2e:	b100      	cbz	r0, 6f32 <z_sys_device_do_config_level+0x22>
			info->driver_api = NULL;
    6f30:	6066      	str	r6, [r4, #4]
								info++) {
    6f32:	340c      	adds	r4, #12
    6f34:	e7f4      	b.n	6f20 <z_sys_device_do_config_level+0x10>
    6f36:	bf00      	nop
    6f38:	0000c844 	.word	0x0000c844

00006f3c <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
    6f3c:	4b10      	ldr	r3, [pc, #64]	; (6f80 <z_impl_device_get_binding+0x44>)
{
    6f3e:	b570      	push	{r4, r5, r6, lr}
	for (info = __device_init_start; info != __device_init_end; info++) {
    6f40:	4c10      	ldr	r4, [pc, #64]	; (6f84 <z_impl_device_get_binding+0x48>)
{
    6f42:	4605      	mov	r5, r0
    6f44:	461e      	mov	r6, r3
	for (info = __device_init_start; info != __device_init_end; info++) {
    6f46:	429c      	cmp	r4, r3
    6f48:	d104      	bne.n	6f54 <z_impl_device_get_binding+0x18>
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
    6f4a:	4c0e      	ldr	r4, [pc, #56]	; (6f84 <z_impl_device_get_binding+0x48>)
    6f4c:	42b4      	cmp	r4, r6
    6f4e:	d109      	bne.n	6f64 <z_impl_device_get_binding+0x28>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
    6f50:	2400      	movs	r4, #0
    6f52:	e012      	b.n	6f7a <z_impl_device_get_binding+0x3e>
		if ((info->driver_api != NULL) &&
    6f54:	6862      	ldr	r2, [r4, #4]
    6f56:	b11a      	cbz	r2, 6f60 <z_impl_device_get_binding+0x24>
		    (info->config->name == name)) {
    6f58:	6822      	ldr	r2, [r4, #0]
		if ((info->driver_api != NULL) &&
    6f5a:	6812      	ldr	r2, [r2, #0]
    6f5c:	42aa      	cmp	r2, r5
    6f5e:	d00c      	beq.n	6f7a <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
    6f60:	340c      	adds	r4, #12
    6f62:	e7f0      	b.n	6f46 <z_impl_device_get_binding+0xa>
		if (info->driver_api == NULL) {
    6f64:	6863      	ldr	r3, [r4, #4]
    6f66:	b90b      	cbnz	r3, 6f6c <z_impl_device_get_binding+0x30>
	for (info = __device_init_start; info != __device_init_end; info++) {
    6f68:	340c      	adds	r4, #12
    6f6a:	e7ef      	b.n	6f4c <z_impl_device_get_binding+0x10>
		if (strcmp(name, info->config->name) == 0) {
    6f6c:	6823      	ldr	r3, [r4, #0]
    6f6e:	4628      	mov	r0, r5
    6f70:	6819      	ldr	r1, [r3, #0]
    6f72:	f001 fcb1 	bl	88d8 <strcmp>
    6f76:	2800      	cmp	r0, #0
    6f78:	d1f6      	bne.n	6f68 <z_impl_device_get_binding+0x2c>
}
    6f7a:	4620      	mov	r0, r4
    6f7c:	bd70      	pop	{r4, r5, r6, pc}
    6f7e:	bf00      	nop
    6f80:	2000a23c 	.word	0x2000a23c
    6f84:	2000a1a0 	.word	0x2000a1a0

00006f88 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
    6f88:	b510      	push	{r4, lr}
    6f8a:	4604      	mov	r4, r0
	z_impl_log_panic();
    6f8c:	f7f9 fd44 	bl	a18 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
    6f90:	2301      	movs	r3, #1
    6f92:	f04f 0100 	mov.w	r1, #0
    6f96:	f363 0107 	bfi	r1, r3, #0, #8
    6f9a:	4a06      	ldr	r2, [pc, #24]	; (6fb4 <k_sys_fatal_error_handler+0x2c>)
    6f9c:	4b06      	ldr	r3, [pc, #24]	; (6fb8 <k_sys_fatal_error_handler+0x30>)
    6f9e:	4807      	ldr	r0, [pc, #28]	; (6fbc <k_sys_fatal_error_handler+0x34>)
    6fa0:	1a9b      	subs	r3, r3, r2
    6fa2:	08db      	lsrs	r3, r3, #3
    6fa4:	f363 118f 	bfi	r1, r3, #6, #10
    6fa8:	f001 f9f5 	bl	8396 <log_0>
	arch_system_halt(reason);
    6fac:	4620      	mov	r0, r4
    6fae:	f004 fe35 	bl	bc1c <arch_system_halt>
    6fb2:	bf00      	nop
    6fb4:	0000c174 	.word	0x0000c174
    6fb8:	0000c1bc 	.word	0x0000c1bc
    6fbc:	0004d9e7 	.word	0x0004d9e7

00006fc0 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    6fc0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    6fc4:	4605      	mov	r5, r0
    6fc6:	4688      	mov	r8, r1
	return z_impl_k_current_get();
    6fc8:	f000 fd5e 	bl	7a88 <z_impl_k_current_get>
	struct k_thread *thread = k_current_get();

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
    6fcc:	2201      	movs	r2, #1
    6fce:	f04f 0300 	mov.w	r3, #0
    6fd2:	f362 0307 	bfi	r3, r2, #0, #8
    6fd6:	4c24      	ldr	r4, [pc, #144]	; (7068 <z_fatal_error+0xa8>)
    6fd8:	4a24      	ldr	r2, [pc, #144]	; (706c <z_fatal_error+0xac>)
    6fda:	2d04      	cmp	r5, #4
    6fdc:	eba4 0402 	sub.w	r4, r4, r2
    6fe0:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    6fe4:	bf96      	itet	ls
    6fe6:	4a22      	ldrls	r2, [pc, #136]	; (7070 <z_fatal_error+0xb0>)
    6fe8:	4a22      	ldrhi	r2, [pc, #136]	; (7074 <z_fatal_error+0xb4>)
    6fea:	f852 2025 	ldrls.w	r2, [r2, r5, lsl #2]
    6fee:	f364 138f 	bfi	r3, r4, #6, #10
    6ff2:	f8ad 3000 	strh.w	r3, [sp]
    6ff6:	4606      	mov	r6, r0
    6ff8:	2300      	movs	r3, #0
    6ffa:	4629      	mov	r1, r5
    6ffc:	481e      	ldr	r0, [pc, #120]	; (7078 <z_fatal_error+0xb8>)
    6ffe:	f001 fa03 	bl	8408 <log_3>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
    7002:	f8d8 301c 	ldr.w	r3, [r8, #28]
    7006:	f3c3 0308 	ubfx	r3, r3, #0, #9
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if (arch_is_in_nested_exception(esf)) {
    700a:	b14b      	cbz	r3, 7020 <z_fatal_error+0x60>
		LOG_ERR("Fault during interrupt handling\n");
    700c:	f04f 0100 	mov.w	r1, #0
    7010:	2301      	movs	r3, #1
    7012:	f363 0107 	bfi	r1, r3, #0, #8
    7016:	f364 118f 	bfi	r1, r4, #6, #10
    701a:	4818      	ldr	r0, [pc, #96]	; (707c <z_fatal_error+0xbc>)
    701c:	f001 f9bb 	bl	8396 <log_0>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
    7020:	f04f 0700 	mov.w	r7, #0
    7024:	2301      	movs	r3, #1
    7026:	f363 0707 	bfi	r7, r3, #0, #8
	const char *thread_name = k_thread_name_get(thread);
    702a:	4630      	mov	r0, r6
	LOG_ERR("Current thread: %p (%s)", thread,
    702c:	f364 178f 	bfi	r7, r4, #6, #10
	const char *thread_name = k_thread_name_get(thread);
    7030:	f004 ff1a 	bl	be68 <k_thread_name_get>
	if (thread_name == NULL || thread_name[0] == '\0') {
    7034:	b1b0      	cbz	r0, 7064 <z_fatal_error+0xa4>
    7036:	7802      	ldrb	r2, [r0, #0]
		thread_name = "unknown";
    7038:	4b11      	ldr	r3, [pc, #68]	; (7080 <z_fatal_error+0xc0>)
    703a:	2a00      	cmp	r2, #0
    703c:	bf08      	it	eq
    703e:	4618      	moveq	r0, r3
	LOG_ERR("Current thread: %p (%s)", thread,
    7040:	f7f9 fb7e 	bl	740 <log_strdup>
    7044:	463b      	mov	r3, r7
    7046:	4602      	mov	r2, r0
    7048:	4631      	mov	r1, r6
    704a:	480e      	ldr	r0, [pc, #56]	; (7084 <z_fatal_error+0xc4>)
    704c:	f001 f9c4 	bl	83d8 <log_2>
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
    7050:	4641      	mov	r1, r8
    7052:	4628      	mov	r0, r5
    7054:	f7ff ff98 	bl	6f88 <k_sys_fatal_error_handler>
	z_impl_k_thread_abort(thread);
    7058:	4630      	mov	r0, r6
			}
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	k_thread_abort(thread);
}
    705a:	b002      	add	sp, #8
    705c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    7060:	f7fa bc82 	b.w	1968 <z_impl_k_thread_abort>
		thread_name = "unknown";
    7064:	4806      	ldr	r0, [pc, #24]	; (7080 <z_fatal_error+0xc0>)
    7066:	e7eb      	b.n	7040 <z_fatal_error+0x80>
    7068:	0000c1bc 	.word	0x0000c1bc
    706c:	0000c174 	.word	0x0000c174
    7070:	0000c85c 	.word	0x0000c85c
    7074:	0004da40 	.word	0x0004da40
    7078:	0004da4e 	.word	0x0004da4e
    707c:	0004da76 	.word	0x0004da76
    7080:	00045d6d 	.word	0x00045d6d
    7084:	0004da97 	.word	0x0004da97

00007088 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
    7088:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
    708a:	4d0b      	ldr	r5, [pc, #44]	; (70b8 <idle+0x30>)
	__asm__ volatile(
    708c:	f04f 0220 	mov.w	r2, #32
    7090:	f3ef 8311 	mrs	r3, BASEPRI
    7094:	f382 8811 	msr	BASEPRI, r2
    7098:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
    709c:	f004 ff0b 	bl	beb6 <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    70a0:	2101      	movs	r1, #1
    70a2:	2802      	cmp	r0, #2
	s32_t ticks = z_get_next_timeout_expiry();
    70a4:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    70a6:	bfd8      	it	le
    70a8:	4608      	movle	r0, r1
    70aa:	f004 ff14 	bl	bed6 <z_set_timeout_expiry>
	_kernel.idle = ticks;
    70ae:	622c      	str	r4, [r5, #32]
 * @return N/A
 * @req K-CPU-IDLE-001
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    70b0:	f7fa f90a 	bl	12c8 <arch_cpu_idle>
    70b4:	e7ea      	b.n	708c <idle+0x4>
    70b6:	bf00      	nop
    70b8:	200047c4 	.word	0x200047c4

000070bc <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    70bc:	4802      	ldr	r0, [pc, #8]	; (70c8 <z_bss_zero+0xc>)
    70be:	4a03      	ldr	r2, [pc, #12]	; (70cc <z_bss_zero+0x10>)
    70c0:	2100      	movs	r1, #0
    70c2:	1a12      	subs	r2, r2, r0
    70c4:	f001 bc3e 	b.w	8944 <memset>
    70c8:	20000000 	.word	0x20000000
    70cc:	20008b98 	.word	0x20008b98

000070d0 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
    70d0:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
    70d2:	4806      	ldr	r0, [pc, #24]	; (70ec <z_data_copy+0x1c>)
	(void)memcpy(&__data_ram_start, &__data_rom_start,
    70d4:	4a06      	ldr	r2, [pc, #24]	; (70f0 <z_data_copy+0x20>)
    70d6:	4907      	ldr	r1, [pc, #28]	; (70f4 <z_data_copy+0x24>)
    70d8:	1a12      	subs	r2, r2, r0
    70da:	f001 fc09 	bl	88f0 <memcpy>
#ifdef CONFIG_ARCH_HAS_RAMFUNC_SUPPORT
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
    70de:	4a06      	ldr	r2, [pc, #24]	; (70f8 <z_data_copy+0x28>)
    70e0:	4906      	ldr	r1, [pc, #24]	; (70fc <z_data_copy+0x2c>)
    70e2:	4807      	ldr	r0, [pc, #28]	; (7100 <z_data_copy+0x30>)
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    70e4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
    70e8:	f001 bc02 	b.w	88f0 <memcpy>
    70ec:	2000a078 	.word	0x2000a078
    70f0:	2000a27c 	.word	0x2000a27c
    70f4:	0004dabc 	.word	0x0004dabc
    70f8:	00000000 	.word	0x00000000
    70fc:	0004dabc 	.word	0x0004dabc
    7100:	20000000 	.word	0x20000000

00007104 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
    7104:	b508      	push	{r3, lr}
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
    7106:	4b09      	ldr	r3, [pc, #36]	; (712c <bg_thread_main+0x28>)
    7108:	2201      	movs	r2, #1

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
    710a:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
    710c:	701a      	strb	r2, [r3, #0]
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
    710e:	f7ff feff 	bl	6f10 <z_sys_device_do_config_level>
			KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
    7112:	2003      	movs	r0, #3
    7114:	f7ff fefc 	bl	6f10 <z_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
    7118:	f000 fd92 	bl	7c40 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
    711c:	f7f9 f972 	bl	404 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    7120:	4a03      	ldr	r2, [pc, #12]	; (7130 <bg_thread_main+0x2c>)
    7122:	7b13      	ldrb	r3, [r2, #12]
    7124:	f023 0301 	bic.w	r3, r3, #1
    7128:	7313      	strb	r3, [r2, #12]

	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    712a:	bd08      	pop	{r3, pc}
    712c:	20008b94 	.word	0x20008b94
    7130:	200006f4 	.word	0x200006f4

00007134 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
    7134:	b580      	push	{r7, lr}
    7136:	b0a2      	sub	sp, #136	; 0x88
#endif	/* CONFIG_STACK_CANARIES */

	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
    7138:	f7f9 fa68 	bl	60c <log_core_init>
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(_interrupt_stack)) +
    713c:	4b35      	ldr	r3, [pc, #212]	; (7214 <z_cstart+0xe0>)
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    713e:	f383 8808 	msr	MSP, r3
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
    7142:	4c35      	ldr	r4, [pc, #212]	; (7218 <z_cstart+0xe4>)
	_kernel.ready_q.cache = &z_main_thread;
    7144:	4e35      	ldr	r6, [pc, #212]	; (721c <z_cstart+0xe8>)
    7146:	6963      	ldr	r3, [r4, #20]
    7148:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    714c:	6163      	str	r3, [r4, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    714e:	2500      	movs	r5, #0
    7150:	23e0      	movs	r3, #224	; 0xe0
    7152:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
    7156:	77e5      	strb	r5, [r4, #31]
    7158:	7625      	strb	r5, [r4, #24]
    715a:	7665      	strb	r5, [r4, #25]
    715c:	76a5      	strb	r5, [r4, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
    715e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    7160:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    7164:	6263      	str	r3, [r4, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    7166:	f7fa fbeb 	bl	1940 <z_arm_fault_init>
	z_arm_cpu_idle_init();
    716a:	f7fa f8a7 	bl	12bc <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
    716e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    7172:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
    7174:	62e3      	str	r3, [r4, #44]	; 0x2c

	/* perform any architecture-specific initialization */
	arch_kernel_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
    7176:	ab07      	add	r3, sp, #28
    7178:	226c      	movs	r2, #108	; 0x6c
    717a:	4629      	mov	r1, r5
    717c:	4618      	mov	r0, r3
    717e:	f001 fbe1 	bl	8944 <memset>
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
    7182:	4c27      	ldr	r4, [pc, #156]	; (7220 <z_cstart+0xec>)
	struct k_thread dummy_thread = {
    7184:	2701      	movs	r7, #1
	_current = &dummy_thread;
    7186:	60a0      	str	r0, [r4, #8]
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    7188:	4628      	mov	r0, r5
	struct k_thread dummy_thread = {
    718a:	f88d 7029 	strb.w	r7, [sp, #41]	; 0x29
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    718e:	f7ff febf 	bl	6f10 <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    7192:	4638      	mov	r0, r7
    7194:	f7ff febc 	bl	6f10 <z_sys_device_do_config_level>
	z_sched_init();
    7198:	f000 fbf6 	bl	7988 <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
    719c:	4b21      	ldr	r3, [pc, #132]	; (7224 <z_cstart+0xf0>)
	_kernel.ready_q.cache = &z_main_thread;
    719e:	6266      	str	r6, [r4, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
    71a0:	f44f 6280 	mov.w	r2, #1024	; 0x400
    71a4:	e9cd 7304 	strd	r7, r3, [sp, #16]
    71a8:	e9cd 5502 	strd	r5, r5, [sp, #8]
    71ac:	4b1e      	ldr	r3, [pc, #120]	; (7228 <z_cstart+0xf4>)
    71ae:	491f      	ldr	r1, [pc, #124]	; (722c <z_cstart+0xf8>)
    71b0:	e9cd 5500 	strd	r5, r5, [sp]
    71b4:	4630      	mov	r0, r6
    71b6:	f000 fcdb 	bl	7b70 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    71ba:	7b73      	ldrb	r3, [r6, #13]
    71bc:	f023 0204 	bic.w	r2, r3, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    71c0:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
    71c4:	7372      	strb	r2, [r6, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    71c6:	d104      	bne.n	71d2 <z_cstart+0x9e>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
    71c8:	69b3      	ldr	r3, [r6, #24]
    71ca:	b913      	cbnz	r3, 71d2 <z_cstart+0x9e>
		z_add_thread_to_ready_q(thread);
    71cc:	4630      	mov	r0, r6
    71ce:	f000 f9e7 	bl	75a0 <z_add_thread_to_ready_q>
	z_setup_new_thread(thread, stack,
    71d2:	4b17      	ldr	r3, [pc, #92]	; (7230 <z_cstart+0xfc>)
    71d4:	4d17      	ldr	r5, [pc, #92]	; (7234 <z_cstart+0x100>)
    71d6:	9305      	str	r3, [sp, #20]
    71d8:	2201      	movs	r2, #1
    71da:	230f      	movs	r3, #15
    71dc:	e9cd 3203 	strd	r3, r2, [sp, #12]
    71e0:	2300      	movs	r3, #0
    71e2:	e9cd 3301 	strd	r3, r3, [sp, #4]
    71e6:	9300      	str	r3, [sp, #0]
    71e8:	f44f 72a0 	mov.w	r2, #320	; 0x140
    71ec:	4b12      	ldr	r3, [pc, #72]	; (7238 <z_cstart+0x104>)
    71ee:	4913      	ldr	r1, [pc, #76]	; (723c <z_cstart+0x108>)
    71f0:	4628      	mov	r0, r5
    71f2:	f000 fcbd 	bl	7b70 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_PRESTART;
    71f6:	7b6b      	ldrb	r3, [r5, #13]
	_kernel.cpus[0].idle_thread = &z_idle_thread;
    71f8:	60e5      	str	r5, [r4, #12]
    71fa:	f023 0304 	bic.w	r3, r3, #4
    71fe:	736b      	strb	r3, [r5, #13]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    7200:	4b0f      	ldr	r3, [pc, #60]	; (7240 <z_cstart+0x10c>)
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
    7202:	490a      	ldr	r1, [pc, #40]	; (722c <z_cstart+0xf8>)
    7204:	4805      	ldr	r0, [pc, #20]	; (721c <z_cstart+0xe8>)
	list->tail = (sys_dnode_t *)list;
    7206:	e9c4 3306 	strd	r3, r3, [r4, #24]
    720a:	f44f 6280 	mov.w	r2, #1024	; 0x400
    720e:	4b06      	ldr	r3, [pc, #24]	; (7228 <z_cstart+0xf4>)
    7210:	f7fa f836 	bl	1280 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    7214:	20009bd8 	.word	0x20009bd8
    7218:	e000ed00 	.word	0xe000ed00
    721c:	200006f4 	.word	0x200006f4
    7220:	200047c4 	.word	0x200047c4
    7224:	0004dab2 	.word	0x0004dab2
    7228:	00007105 	.word	0x00007105
    722c:	20008e98 	.word	0x20008e98
    7230:	0004dab7 	.word	0x0004dab7
    7234:	20000688 	.word	0x20000688
    7238:	00007089 	.word	0x00007089
    723c:	20009298 	.word	0x20009298
    7240:	200047dc 	.word	0x200047dc

00007244 <init_mem_slab_module>:
 */
static int init_mem_slab_module(struct device *dev)
{
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    7244:	4b0b      	ldr	r3, [pc, #44]	; (7274 <init_mem_slab_module+0x30>)
    7246:	480c      	ldr	r0, [pc, #48]	; (7278 <init_mem_slab_module+0x34>)
{
    7248:	b570      	push	{r4, r5, r6, lr}
	slab->free_list = NULL;
    724a:	2400      	movs	r4, #0
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    724c:	4283      	cmp	r3, r0
    724e:	d301      	bcc.n	7254 <init_mem_slab_module+0x10>
		create_free_list(slab);
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}
	return 0;
}
    7250:	2000      	movs	r0, #0
    7252:	bd70      	pop	{r4, r5, r6, pc}
	p = slab->buffer;
    7254:	691a      	ldr	r2, [r3, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
    7256:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
    7258:	615c      	str	r4, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    725a:	2100      	movs	r1, #0
    725c:	42a9      	cmp	r1, r5
    725e:	d101      	bne.n	7264 <init_mem_slab_module+0x20>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    7260:	331c      	adds	r3, #28
    7262:	e7f3      	b.n	724c <init_mem_slab_module+0x8>
		*(char **)p = slab->free_list;
    7264:	695e      	ldr	r6, [r3, #20]
    7266:	6016      	str	r6, [r2, #0]
		p += slab->block_size;
    7268:	68de      	ldr	r6, [r3, #12]
		slab->free_list = p;
    726a:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    726c:	3101      	adds	r1, #1
		p += slab->block_size;
    726e:	4432      	add	r2, r6
    7270:	e7f4      	b.n	725c <init_mem_slab_module+0x18>
    7272:	bf00      	nop
    7274:	2000a23c 	.word	0x2000a23c
    7278:	2000a23c 	.word	0x2000a23c

0000727c <k_mem_slab_alloc>:

	z_object_init(slab);
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, s32_t timeout)
{
    727c:	b510      	push	{r4, lr}
    727e:	4613      	mov	r3, r2
    7280:	460c      	mov	r4, r1
    7282:	f04f 0220 	mov.w	r2, #32
    7286:	f3ef 8111 	mrs	r1, BASEPRI
    728a:	f382 8811 	msr	BASEPRI, r2
    728e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
    7292:	6942      	ldr	r2, [r0, #20]
    7294:	b15a      	cbz	r2, 72ae <k_mem_slab_alloc+0x32>
		/* take a free block */
		*mem = slab->free_list;
    7296:	6022      	str	r2, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
    7298:	6813      	ldr	r3, [r2, #0]
    729a:	6143      	str	r3, [r0, #20]
		slab->num_used++;
    729c:	6983      	ldr	r3, [r0, #24]
    729e:	3301      	adds	r3, #1
    72a0:	6183      	str	r3, [r0, #24]
		result = 0;
    72a2:	2000      	movs	r0, #0
	__asm__ volatile(
    72a4:	f381 8811 	msr	BASEPRI, r1
    72a8:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
    72ac:	e00d      	b.n	72ca <k_mem_slab_alloc+0x4e>
	} else if (timeout == K_NO_WAIT) {
    72ae:	b91b      	cbnz	r3, 72b8 <k_mem_slab_alloc+0x3c>
		*mem = NULL;
    72b0:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
    72b2:	f06f 000b 	mvn.w	r0, #11
    72b6:	e7f5      	b.n	72a4 <k_mem_slab_alloc+0x28>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
    72b8:	4602      	mov	r2, r0
    72ba:	4804      	ldr	r0, [pc, #16]	; (72cc <k_mem_slab_alloc+0x50>)
    72bc:	f000 fb22 	bl	7904 <z_pend_curr>
		if (result == 0) {
    72c0:	b918      	cbnz	r0, 72ca <k_mem_slab_alloc+0x4e>
			*mem = _current->base.swap_data;
    72c2:	4b03      	ldr	r3, [pc, #12]	; (72d0 <k_mem_slab_alloc+0x54>)
    72c4:	689b      	ldr	r3, [r3, #8]
    72c6:	695b      	ldr	r3, [r3, #20]
    72c8:	6023      	str	r3, [r4, #0]
}
    72ca:	bd10      	pop	{r4, pc}
    72cc:	20008b95 	.word	0x20008b95
    72d0:	200047c4 	.word	0x200047c4

000072d4 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
    72d4:	b570      	push	{r4, r5, r6, lr}
    72d6:	4604      	mov	r4, r0
    72d8:	460d      	mov	r5, r1
	__asm__ volatile(
    72da:	f04f 0320 	mov.w	r3, #32
    72de:	f3ef 8611 	mrs	r6, BASEPRI
    72e2:	f383 8811 	msr	BASEPRI, r3
    72e6:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
    72ea:	f004 fd75 	bl	bdd8 <z_unpend_first_thread>

	if (pending_thread != NULL) {
    72ee:	b180      	cbz	r0, 7312 <k_mem_slab_free+0x3e>
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
    72f0:	682a      	ldr	r2, [r5, #0]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
    72f2:	6142      	str	r2, [r0, #20]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    72f4:	7b42      	ldrb	r2, [r0, #13]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
    72f6:	2100      	movs	r1, #0
    72f8:	06d2      	lsls	r2, r2, #27
    72fa:	6681      	str	r1, [r0, #104]	; 0x68
    72fc:	d103      	bne.n	7306 <k_mem_slab_free+0x32>
	if (z_is_thread_ready(thread)) {
    72fe:	6983      	ldr	r3, [r0, #24]
    7300:	b90b      	cbnz	r3, 7306 <k_mem_slab_free+0x32>
		z_add_thread_to_ready_q(thread);
    7302:	f000 f94d 	bl	75a0 <z_add_thread_to_ready_q>
		z_ready_thread(pending_thread);
		z_reschedule(&lock, key);
    7306:	4631      	mov	r1, r6
    7308:	4808      	ldr	r0, [pc, #32]	; (732c <k_mem_slab_free+0x58>)
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
    730a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
    730e:	f004 bced 	b.w	bcec <z_reschedule>
		**(char ***)mem = slab->free_list;
    7312:	682b      	ldr	r3, [r5, #0]
    7314:	6962      	ldr	r2, [r4, #20]
    7316:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
    7318:	682b      	ldr	r3, [r5, #0]
    731a:	6163      	str	r3, [r4, #20]
		slab->num_used--;
    731c:	69a3      	ldr	r3, [r4, #24]
    731e:	3b01      	subs	r3, #1
    7320:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
    7322:	f386 8811 	msr	BASEPRI, r6
    7326:	f3bf 8f6f 	isb	sy
}
    732a:	bd70      	pop	{r4, r5, r6, pc}
    732c:	20008b95 	.word	0x20008b95

00007330 <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
    7330:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);

	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
    7332:	4c07      	ldr	r4, [pc, #28]	; (7350 <init_static_pools+0x20>)
    7334:	4d07      	ldr	r5, [pc, #28]	; (7354 <init_static_pools+0x24>)
    7336:	42ac      	cmp	r4, r5
    7338:	d301      	bcc.n	733e <init_static_pools+0xe>
		k_mem_pool_init(p);
	}

	return 0;
}
    733a:	2000      	movs	r0, #0
    733c:	bd38      	pop	{r3, r4, r5, pc}
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    733e:	f104 0314 	add.w	r3, r4, #20
	z_sys_mem_pool_base_init(&p->base);
    7342:	4620      	mov	r0, r4
    7344:	e9c4 3305 	strd	r3, r3, [r4, #20]
    7348:	f000 fe44 	bl	7fd4 <z_sys_mem_pool_base_init>
	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
    734c:	341c      	adds	r4, #28
    734e:	e7f2      	b.n	7336 <init_static_pools+0x6>
    7350:	2000a23c 	.word	0x2000a23c
    7354:	2000a258 	.word	0x2000a258

00007358 <k_mem_pool_alloc>:

SYS_INIT(init_static_pools, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, s32_t timeout)
{
    7358:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int ret;
	s64_t end = 0;

	__ASSERT(!(arch_is_in_isr() && timeout != K_NO_WAIT), "");

	if (timeout > 0) {
    735c:	1e1c      	subs	r4, r3, #0
{
    735e:	b085      	sub	sp, #20
    7360:	4607      	mov	r7, r0
    7362:	460d      	mov	r5, r1
    7364:	4692      	mov	sl, r2
	if (timeout > 0) {
    7366:	dd3b      	ble.n	73e0 <k_mem_pool_alloc+0x88>
	return z_impl_k_uptime_get();
    7368:	f004 fdd3 	bl	bf12 <z_impl_k_uptime_get>
		end = k_uptime_get() + timeout;
    736c:	eb10 0804 	adds.w	r8, r0, r4
	return pool - &_k_mem_pool_list_start[0];
    7370:	4b1d      	ldr	r3, [pc, #116]	; (73e8 <k_mem_pool_alloc+0x90>)
    7372:	4e1e      	ldr	r6, [pc, #120]	; (73ec <k_mem_pool_alloc+0x94>)
    7374:	1afb      	subs	r3, r7, r3
    7376:	109b      	asrs	r3, r3, #2
    7378:	435e      	muls	r6, r3
		u32_t level_num, block_num;

		ret = z_sys_mem_pool_block_alloc(&p->base, size,
						 &level_num, &block_num,
						 &block->data);
		block->id.pool = pool_id(p);
    737a:	b2f6      	uxtb	r6, r6
		if (ret == 0 || timeout == K_NO_WAIT ||
		    ret != -ENOMEM) {
			return ret;
		}

		z_pend_curr_unlocked(&p->wait_q, timeout);
    737c:	f107 0b14 	add.w	fp, r7, #20
		ret = z_sys_mem_pool_block_alloc(&p->base, size,
    7380:	ab03      	add	r3, sp, #12
    7382:	aa02      	add	r2, sp, #8
    7384:	9500      	str	r5, [sp, #0]
    7386:	4651      	mov	r1, sl
    7388:	4638      	mov	r0, r7
    738a:	f000 fe69 	bl	8060 <z_sys_mem_pool_block_alloc>
		block->id.level = level_num;
    738e:	796b      	ldrb	r3, [r5, #5]
    7390:	9a02      	ldr	r2, [sp, #8]
		block->id.pool = pool_id(p);
    7392:	712e      	strb	r6, [r5, #4]
		block->id.level = level_num;
    7394:	f362 0303 	bfi	r3, r2, #0, #4
    7398:	716b      	strb	r3, [r5, #5]
		block->id.block = block_num;
    739a:	686b      	ldr	r3, [r5, #4]
    739c:	9a03      	ldr	r2, [sp, #12]
    739e:	f362 331f 	bfi	r3, r2, #12, #20
    73a2:	606b      	str	r3, [r5, #4]
		if (ret == 0 || timeout == K_NO_WAIT ||
    73a4:	b1c8      	cbz	r0, 73da <k_mem_pool_alloc+0x82>
    73a6:	b1c4      	cbz	r4, 73da <k_mem_pool_alloc+0x82>
    73a8:	f110 0f0c 	cmn.w	r0, #12
    73ac:	d115      	bne.n	73da <k_mem_pool_alloc+0x82>
	__asm__ volatile(
    73ae:	f04f 0320 	mov.w	r3, #32
    73b2:	f3ef 8011 	mrs	r0, BASEPRI
    73b6:	f383 8811 	msr	BASEPRI, r3
    73ba:	f3bf 8f6f 	isb	sy
	(void) z_pend_curr_irqlock(arch_irq_lock(), wait_q, timeout);
    73be:	4622      	mov	r2, r4
    73c0:	4659      	mov	r1, fp
    73c2:	f000 fa7b 	bl	78bc <z_pend_curr_irqlock>

		if (timeout != K_FOREVER) {
    73c6:	1c63      	adds	r3, r4, #1
    73c8:	d0da      	beq.n	7380 <k_mem_pool_alloc+0x28>
    73ca:	f004 fda2 	bl	bf12 <z_impl_k_uptime_get>
			timeout = end - k_uptime_get();
    73ce:	eba8 0400 	sub.w	r4, r8, r0
			if (timeout <= 0) {
    73d2:	2c00      	cmp	r4, #0
    73d4:	dcd4      	bgt.n	7380 <k_mem_pool_alloc+0x28>
				break;
			}
		}
	}

	return -EAGAIN;
    73d6:	f06f 000a 	mvn.w	r0, #10
}
    73da:	b005      	add	sp, #20
    73dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	s64_t end = 0;
    73e0:	f04f 0800 	mov.w	r8, #0
    73e4:	e7c4      	b.n	7370 <k_mem_pool_alloc+0x18>
    73e6:	bf00      	nop
    73e8:	2000a23c 	.word	0x2000a23c
    73ec:	b6db6db7 	.word	0xb6db6db7

000073f0 <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
    73f0:	b570      	push	{r4, r5, r6, lr}
    73f2:	7804      	ldrb	r4, [r0, #0]
	int need_sched = 0;
	struct k_mem_pool *p = get_pool(id->pool);

	z_sys_mem_pool_block_free(&p->base, id->level, id->block);
    73f4:	6802      	ldr	r2, [r0, #0]
    73f6:	7841      	ldrb	r1, [r0, #1]
    73f8:	4e11      	ldr	r6, [pc, #68]	; (7440 <k_mem_pool_free_id+0x50>)
    73fa:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
    73fe:	00a4      	lsls	r4, r4, #2
    7400:	0b12      	lsrs	r2, r2, #12
    7402:	f001 010f 	and.w	r1, r1, #15
    7406:	1930      	adds	r0, r6, r4
    7408:	f000 fedd 	bl	81c6 <z_sys_mem_pool_block_free>
    740c:	f04f 0320 	mov.w	r3, #32
    7410:	f3ef 8511 	mrs	r5, BASEPRI
    7414:	f383 8811 	msr	BASEPRI, r3
    7418:	f3bf 8f6f 	isb	sy
	 * is unsynchronized.  Maybe we want to put the lock into the
	 * wait_q instead and make the API safe?)
	 */
	k_spinlock_key_t key = k_spin_lock(&lock);

	need_sched = z_unpend_all(&p->wait_q);
    741c:	f104 0014 	add.w	r0, r4, #20
    7420:	4430      	add	r0, r6
    7422:	f004 fd06 	bl	be32 <z_unpend_all>

	if (need_sched != 0) {
    7426:	b128      	cbz	r0, 7434 <k_mem_pool_free_id+0x44>
		z_reschedule(&lock, key);
    7428:	4629      	mov	r1, r5
    742a:	4806      	ldr	r0, [pc, #24]	; (7444 <k_mem_pool_free_id+0x54>)
	} else {
		k_spin_unlock(&lock, key);
	}
}
    742c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
    7430:	f004 bc5c 	b.w	bcec <z_reschedule>
	__asm__ volatile(
    7434:	f385 8811 	msr	BASEPRI, r5
    7438:	f3bf 8f6f 	isb	sy
}
    743c:	bd70      	pop	{r4, r5, r6, pc}
    743e:	bf00      	nop
    7440:	2000a23c 	.word	0x2000a23c
    7444:	20008b95 	.word	0x20008b95

00007448 <k_malloc>:
		  CONFIG_HEAP_MEM_POOL_SIZE, 1, 4);
#define _HEAP_MEM_POOL (&_heap_mem_pool)

void *k_malloc(size_t size)
{
	return k_mem_pool_malloc(_HEAP_MEM_POOL, size);
    7448:	4601      	mov	r1, r0
    744a:	4801      	ldr	r0, [pc, #4]	; (7450 <k_malloc+0x8>)
    744c:	f004 bc03 	b.w	bc56 <k_mem_pool_malloc>
    7450:	2000a23c 	.word	0x2000a23c

00007454 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
    7454:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
    7456:	4c08      	ldr	r4, [pc, #32]	; (7478 <z_reset_time_slice+0x24>)
    7458:	6823      	ldr	r3, [r4, #0]
    745a:	b15b      	cbz	r3, 7474 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
    745c:	f7f9 fe30 	bl	10c0 <z_clock_elapsed>
    7460:	6823      	ldr	r3, [r4, #0]
    7462:	4a06      	ldr	r2, [pc, #24]	; (747c <z_reset_time_slice+0x28>)
    7464:	4418      	add	r0, r3
    7466:	6110      	str	r0, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
    7468:	2100      	movs	r1, #0
    746a:	4618      	mov	r0, r3
	}
}
    746c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_set_timeout_expiry(slice_time, false);
    7470:	f004 bd31 	b.w	bed6 <z_set_timeout_expiry>
}
    7474:	bd10      	pop	{r4, pc}
    7476:	bf00      	nop
    7478:	200047fc 	.word	0x200047fc
    747c:	200047c4 	.word	0x200047c4

00007480 <k_sched_time_slice_set>:

void k_sched_time_slice_set(s32_t slice, int prio)
{
    7480:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7482:	460d      	mov	r5, r1
	__asm__ volatile(
    7484:	f04f 0320 	mov.w	r3, #32
    7488:	f3ef 8411 	mrs	r4, BASEPRI
    748c:	f383 8811 	msr	BASEPRI, r3
    7490:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
    7494:	4b0d      	ldr	r3, [pc, #52]	; (74cc <k_sched_time_slice_set+0x4c>)
		} else {
			return t * (to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
    7496:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    749a:	f240 36e7 	movw	r6, #999	; 0x3e7
    749e:	2700      	movs	r7, #0
    74a0:	fbe1 6700 	umlal	r6, r7, r1, r0
    74a4:	2200      	movs	r2, #0
    74a6:	611a      	str	r2, [r3, #16]
    74a8:	4630      	mov	r0, r6
    74aa:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    74ae:	2300      	movs	r3, #0
    74b0:	4639      	mov	r1, r7
    74b2:	f7f8 fe13 	bl	dc <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
    74b6:	4b06      	ldr	r3, [pc, #24]	; (74d0 <k_sched_time_slice_set+0x50>)
    74b8:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
    74ba:	4b06      	ldr	r3, [pc, #24]	; (74d4 <k_sched_time_slice_set+0x54>)
    74bc:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
    74be:	f7ff ffc9 	bl	7454 <z_reset_time_slice>
	__asm__ volatile(
    74c2:	f384 8811 	msr	BASEPRI, r4
    74c6:	f3bf 8f6f 	isb	sy
	}
}
    74ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    74cc:	200047c4 	.word	0x200047c4
    74d0:	200047fc 	.word	0x200047fc
    74d4:	200047f8 	.word	0x200047f8

000074d8 <k_sched_lock>:
	__asm__ volatile(
    74d8:	f04f 0320 	mov.w	r3, #32
    74dc:	f3ef 8111 	mrs	r1, BASEPRI
    74e0:	f383 8811 	msr	BASEPRI, r3
    74e4:	f3bf 8f6f 	isb	sy
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
    74e8:	4b04      	ldr	r3, [pc, #16]	; (74fc <k_sched_lock+0x24>)
    74ea:	689a      	ldr	r2, [r3, #8]
    74ec:	7bd3      	ldrb	r3, [r2, #15]
    74ee:	3b01      	subs	r3, #1
    74f0:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
    74f2:	f381 8811 	msr	BASEPRI, r1
    74f6:	f3bf 8f6f 	isb	sy
void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
    74fa:	4770      	bx	lr
    74fc:	200047c4 	.word	0x200047c4

00007500 <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
    7500:	4b09      	ldr	r3, [pc, #36]	; (7528 <z_priq_dumb_remove+0x28>)
    7502:	f103 0228 	add.w	r2, r3, #40	; 0x28
    7506:	4282      	cmp	r2, r0
    7508:	d105      	bne.n	7516 <z_priq_dumb_remove+0x16>
    750a:	689b      	ldr	r3, [r3, #8]
    750c:	428b      	cmp	r3, r1
    750e:	d102      	bne.n	7516 <z_priq_dumb_remove+0x16>
    7510:	7b4b      	ldrb	r3, [r1, #13]
    7512:	06db      	lsls	r3, r3, #27
    7514:	d106      	bne.n	7524 <z_priq_dumb_remove+0x24>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
    7516:	e9d1 3200 	ldrd	r3, r2, [r1]
    751a:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
    751c:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    751e:	2300      	movs	r3, #0
	node->prev = NULL;
    7520:	e9c1 3300 	strd	r3, r3, [r1]
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
    7524:	4770      	bx	lr
    7526:	bf00      	nop
    7528:	200047c4 	.word	0x200047c4

0000752c <update_cache>:
{
    752c:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
    752e:	4c0d      	ldr	r4, [pc, #52]	; (7564 <update_cache+0x38>)
{
    7530:	4602      	mov	r2, r0
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
    7532:	f104 0028 	add.w	r0, r4, #40	; 0x28
    7536:	f004 fc18 	bl	bd6a <z_priq_dumb_best>
	return thread ? thread : _current_cpu->idle_thread;
    753a:	4605      	mov	r5, r0
    753c:	b900      	cbnz	r0, 7540 <update_cache+0x14>
    753e:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
    7540:	68a3      	ldr	r3, [r4, #8]
    7542:	b94a      	cbnz	r2, 7558 <update_cache+0x2c>
	if (z_is_thread_prevented_from_running(_current)) {
    7544:	7b5a      	ldrb	r2, [r3, #13]
    7546:	06d2      	lsls	r2, r2, #27
    7548:	d106      	bne.n	7558 <update_cache+0x2c>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    754a:	69aa      	ldr	r2, [r5, #24]
    754c:	b922      	cbnz	r2, 7558 <update_cache+0x2c>
	if (is_preempt(_current) || is_metairq(thread)) {
    754e:	89da      	ldrh	r2, [r3, #14]
    7550:	2a7f      	cmp	r2, #127	; 0x7f
    7552:	d901      	bls.n	7558 <update_cache+0x2c>
		_kernel.ready_q.cache = _current;
    7554:	6263      	str	r3, [r4, #36]	; 0x24
}
    7556:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
    7558:	429d      	cmp	r5, r3
    755a:	d001      	beq.n	7560 <update_cache+0x34>
			z_reset_time_slice();
    755c:	f7ff ff7a 	bl	7454 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    7560:	6265      	str	r5, [r4, #36]	; 0x24
}
    7562:	e7f8      	b.n	7556 <update_cache+0x2a>
    7564:	200047c4 	.word	0x200047c4

00007568 <k_sched_unlock>:
{
    7568:	b510      	push	{r4, lr}
	__asm__ volatile(
    756a:	f04f 0320 	mov.w	r3, #32
    756e:	f3ef 8411 	mrs	r4, BASEPRI
    7572:	f383 8811 	msr	BASEPRI, r3
    7576:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
    757a:	4b08      	ldr	r3, [pc, #32]	; (759c <k_sched_unlock+0x34>)
    757c:	689a      	ldr	r2, [r3, #8]
    757e:	7bd3      	ldrb	r3, [r2, #15]
    7580:	3301      	adds	r3, #1
    7582:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
    7584:	2000      	movs	r0, #0
    7586:	f7ff ffd1 	bl	752c <update_cache>
	__asm__ volatile(
    758a:	f384 8811 	msr	BASEPRI, r4
    758e:	f3bf 8f6f 	isb	sy
}
    7592:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
    7596:	f004 bbc0 	b.w	bd1a <z_reschedule_unlocked>
    759a:	bf00      	nop
    759c:	200047c4 	.word	0x200047c4

000075a0 <z_add_thread_to_ready_q>:
{
    75a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
    75a2:	f04f 0320 	mov.w	r3, #32
    75a6:	f3ef 8411 	mrs	r4, BASEPRI
    75aa:	f383 8811 	msr	BASEPRI, r3
    75ae:	f3bf 8f6f 	isb	sy
	return list->head == list;
    75b2:	4a15      	ldr	r2, [pc, #84]	; (7608 <z_add_thread_to_ready_q+0x68>)
    75b4:	4611      	mov	r1, r2
    75b6:	f851 3f28 	ldr.w	r3, [r1, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    75ba:	428b      	cmp	r3, r1
    75bc:	d01d      	beq.n	75fa <z_add_thread_to_ready_q+0x5a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    75be:	b1e3      	cbz	r3, 75fa <z_add_thread_to_ready_q+0x5a>
    75c0:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
	if (thread_1->base.prio < thread_2->base.prio) {
    75c2:	f990 500e 	ldrsb.w	r5, [r0, #14]
    75c6:	f993 700e 	ldrsb.w	r7, [r3, #14]
    75ca:	42af      	cmp	r7, r5
    75cc:	dd10      	ble.n	75f0 <z_add_thread_to_ready_q+0x50>
	node->prev = successor->prev;
    75ce:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    75d0:	e9c0 3200 	strd	r3, r2, [r0]
	successor->prev->next = node;
    75d4:	6010      	str	r0, [r2, #0]
	successor->prev = node;
    75d6:	6058      	str	r0, [r3, #4]
	thread->base.thread_state |= states;
    75d8:	7b43      	ldrb	r3, [r0, #13]
    75da:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    75de:	7343      	strb	r3, [r0, #13]
		update_cache(0);
    75e0:	2000      	movs	r0, #0
    75e2:	f7ff ffa3 	bl	752c <update_cache>
	__asm__ volatile(
    75e6:	f384 8811 	msr	BASEPRI, r4
    75ea:	f3bf 8f6f 	isb	sy
}
    75ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
    75f0:	42b3      	cmp	r3, r6
    75f2:	d002      	beq.n	75fa <z_add_thread_to_ready_q+0x5a>
    75f4:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    75f6:	2b00      	cmp	r3, #0
    75f8:	d1e5      	bne.n	75c6 <z_add_thread_to_ready_q+0x26>
	node->prev = list->tail;
    75fa:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    75fc:	6043      	str	r3, [r0, #4]
	list->tail->next = node;
    75fe:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	node->next = list;
    7600:	6001      	str	r1, [r0, #0]
	list->tail->next = node;
    7602:	6018      	str	r0, [r3, #0]
	list->tail = node;
    7604:	62d0      	str	r0, [r2, #44]	; 0x2c
    7606:	e7e7      	b.n	75d8 <z_add_thread_to_ready_q+0x38>
    7608:	200047c4 	.word	0x200047c4

0000760c <z_move_thread_to_end_of_prio_q>:
{
    760c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    760e:	4604      	mov	r4, r0
	__asm__ volatile(
    7610:	f04f 0320 	mov.w	r3, #32
    7614:	f3ef 8511 	mrs	r5, BASEPRI
    7618:	f383 8811 	msr	BASEPRI, r3
    761c:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
    7620:	7b43      	ldrb	r3, [r0, #13]
    7622:	065a      	lsls	r2, r3, #25
    7624:	d503      	bpl.n	762e <z_move_thread_to_end_of_prio_q+0x22>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    7626:	4601      	mov	r1, r0
    7628:	4817      	ldr	r0, [pc, #92]	; (7688 <z_move_thread_to_end_of_prio_q+0x7c>)
    762a:	f7ff ff69 	bl	7500 <z_priq_dumb_remove>
	return list->head == list;
    762e:	4a17      	ldr	r2, [pc, #92]	; (768c <z_move_thread_to_end_of_prio_q+0x80>)
    7630:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
    7634:	f102 0128 	add.w	r1, r2, #40	; 0x28
    7638:	428b      	cmp	r3, r1
    763a:	d01f      	beq.n	767c <z_move_thread_to_end_of_prio_q+0x70>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    763c:	b1f3      	cbz	r3, 767c <z_move_thread_to_end_of_prio_q+0x70>
	if (thread_1->base.prio < thread_2->base.prio) {
    763e:	f994 600e 	ldrsb.w	r6, [r4, #14]
    7642:	f993 700e 	ldrsb.w	r7, [r3, #14]
    7646:	42b7      	cmp	r7, r6
    7648:	dd13      	ble.n	7672 <z_move_thread_to_end_of_prio_q+0x66>
	node->prev = successor->prev;
    764a:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
    764c:	e9c4 3100 	strd	r3, r1, [r4]
	successor->prev->next = node;
    7650:	600c      	str	r4, [r1, #0]
	successor->prev = node;
    7652:	605c      	str	r4, [r3, #4]
    7654:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
    7656:	6890      	ldr	r0, [r2, #8]
    7658:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    765c:	7363      	strb	r3, [r4, #13]
    765e:	1b03      	subs	r3, r0, r4
    7660:	4258      	negs	r0, r3
    7662:	4158      	adcs	r0, r3
    7664:	f7ff ff62 	bl	752c <update_cache>
	__asm__ volatile(
    7668:	f385 8811 	msr	BASEPRI, r5
    766c:	f3bf 8f6f 	isb	sy
}
    7670:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
    7672:	4283      	cmp	r3, r0
    7674:	d002      	beq.n	767c <z_move_thread_to_end_of_prio_q+0x70>
    7676:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    7678:	2b00      	cmp	r3, #0
    767a:	d1e2      	bne.n	7642 <z_move_thread_to_end_of_prio_q+0x36>
	node->prev = list->tail;
    767c:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
    7680:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    7682:	601c      	str	r4, [r3, #0]
	list->tail = node;
    7684:	62d4      	str	r4, [r2, #44]	; 0x2c
    7686:	e7e5      	b.n	7654 <z_move_thread_to_end_of_prio_q+0x48>
    7688:	200047ec 	.word	0x200047ec
    768c:	200047c4 	.word	0x200047c4

00007690 <z_time_slice>:
	if (pending_current == _current) {
    7690:	4a15      	ldr	r2, [pc, #84]	; (76e8 <z_time_slice+0x58>)
    7692:	4916      	ldr	r1, [pc, #88]	; (76ec <z_time_slice+0x5c>)
{
    7694:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
    7696:	680c      	ldr	r4, [r1, #0]
    7698:	6893      	ldr	r3, [r2, #8]
    769a:	42a3      	cmp	r3, r4
    769c:	4614      	mov	r4, r2
    769e:	d103      	bne.n	76a8 <z_time_slice+0x18>
}
    76a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
    76a4:	f7ff bed6 	b.w	7454 <z_reset_time_slice>
	pending_current = NULL;
    76a8:	2500      	movs	r5, #0
    76aa:	600d      	str	r5, [r1, #0]
	if (slice_time && sliceable(_current)) {
    76ac:	4910      	ldr	r1, [pc, #64]	; (76f0 <z_time_slice+0x60>)
    76ae:	6809      	ldr	r1, [r1, #0]
    76b0:	b1b9      	cbz	r1, 76e2 <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
    76b2:	89d9      	ldrh	r1, [r3, #14]
    76b4:	297f      	cmp	r1, #127	; 0x7f
    76b6:	d814      	bhi.n	76e2 <z_time_slice+0x52>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    76b8:	490e      	ldr	r1, [pc, #56]	; (76f4 <z_time_slice+0x64>)
    76ba:	f993 500e 	ldrsb.w	r5, [r3, #14]
    76be:	6809      	ldr	r1, [r1, #0]
    76c0:	428d      	cmp	r5, r1
    76c2:	db0e      	blt.n	76e2 <z_time_slice+0x52>
		&& !z_is_idle_thread_object(thread)
    76c4:	490c      	ldr	r1, [pc, #48]	; (76f8 <z_time_slice+0x68>)
    76c6:	428b      	cmp	r3, r1
    76c8:	d00b      	beq.n	76e2 <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
    76ca:	6999      	ldr	r1, [r3, #24]
    76cc:	b949      	cbnz	r1, 76e2 <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
    76ce:	6911      	ldr	r1, [r2, #16]
    76d0:	4281      	cmp	r1, r0
    76d2:	dc03      	bgt.n	76dc <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
    76d4:	4618      	mov	r0, r3
    76d6:	f7ff ff99 	bl	760c <z_move_thread_to_end_of_prio_q>
    76da:	e7e1      	b.n	76a0 <z_time_slice+0x10>
			_current_cpu->slice_ticks -= ticks;
    76dc:	1a09      	subs	r1, r1, r0
    76de:	6111      	str	r1, [r2, #16]
}
    76e0:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
    76e2:	2300      	movs	r3, #0
    76e4:	6123      	str	r3, [r4, #16]
    76e6:	e7fb      	b.n	76e0 <z_time_slice+0x50>
    76e8:	200047c4 	.word	0x200047c4
    76ec:	200047f4 	.word	0x200047f4
    76f0:	200047fc 	.word	0x200047fc
    76f4:	200047f8 	.word	0x200047f8
    76f8:	20000688 	.word	0x20000688

000076fc <z_thread_single_suspend>:
{
    76fc:	b570      	push	{r4, r5, r6, lr}
    76fe:	4604      	mov	r4, r0
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    7700:	3018      	adds	r0, #24
    7702:	f004 fbc2 	bl	be8a <z_abort_timeout>
	__asm__ volatile(
    7706:	f04f 0320 	mov.w	r3, #32
    770a:	f3ef 8611 	mrs	r6, BASEPRI
    770e:	f383 8811 	msr	BASEPRI, r3
    7712:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
    7716:	7b63      	ldrb	r3, [r4, #13]
    7718:	065a      	lsls	r2, r3, #25
    771a:	d507      	bpl.n	772c <z_thread_single_suspend+0x30>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    771c:	4621      	mov	r1, r4
    771e:	480f      	ldr	r0, [pc, #60]	; (775c <z_thread_single_suspend+0x60>)
    7720:	f7ff feee 	bl	7500 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    7724:	7b63      	ldrb	r3, [r4, #13]
    7726:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    772a:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
    772c:	4d0c      	ldr	r5, [pc, #48]	; (7760 <z_thread_single_suspend+0x64>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
    772e:	7b63      	ldrb	r3, [r4, #13]
    7730:	68a8      	ldr	r0, [r5, #8]
    7732:	f043 0310 	orr.w	r3, r3, #16
    7736:	7363      	strb	r3, [r4, #13]
    7738:	1b03      	subs	r3, r0, r4
    773a:	4258      	negs	r0, r3
    773c:	4158      	adcs	r0, r3
    773e:	f7ff fef5 	bl	752c <update_cache>
	__asm__ volatile(
    7742:	f386 8811 	msr	BASEPRI, r6
    7746:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
    774a:	68ab      	ldr	r3, [r5, #8]
    774c:	42a3      	cmp	r3, r4
    774e:	d103      	bne.n	7758 <z_thread_single_suspend+0x5c>
}
    7750:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
    7754:	f004 bae1 	b.w	bd1a <z_reschedule_unlocked>
}
    7758:	bd70      	pop	{r4, r5, r6, pc}
    775a:	bf00      	nop
    775c:	200047ec 	.word	0x200047ec
    7760:	200047c4 	.word	0x200047c4

00007764 <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
    7764:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
    7766:	b570      	push	{r4, r5, r6, lr}
    7768:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
    776a:	b103      	cbz	r3, 776e <z_thread_single_abort+0xa>
		thread->fn_abort();
    776c:	4798      	blx	r3
    776e:	f104 0018 	add.w	r0, r4, #24
    7772:	f004 fb8a 	bl	be8a <z_abort_timeout>
	__asm__ volatile(
    7776:	f04f 0320 	mov.w	r3, #32
    777a:	f3ef 8511 	mrs	r5, BASEPRI
    777e:	f383 8811 	msr	BASEPRI, r3
    7782:	f3bf 8f6f 	isb	sy
		if (z_is_thread_ready(thread)) {
    7786:	4620      	mov	r0, r4
    7788:	f004 fa7e 	bl	bc88 <z_is_thread_ready>
    778c:	7b63      	ldrb	r3, [r4, #13]
    778e:	4606      	mov	r6, r0
    7790:	b1c8      	cbz	r0, 77c6 <z_thread_single_abort+0x62>
			if (z_is_thread_queued(thread)) {
    7792:	0659      	lsls	r1, r3, #25
    7794:	d507      	bpl.n	77a6 <z_thread_single_abort+0x42>
				_priq_run_remove(&_kernel.ready_q.runq,
    7796:	4621      	mov	r1, r4
    7798:	4811      	ldr	r0, [pc, #68]	; (77e0 <z_thread_single_abort+0x7c>)
    779a:	f7ff feb1 	bl	7500 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    779e:	7b63      	ldrb	r3, [r4, #13]
    77a0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    77a4:	7363      	strb	r3, [r4, #13]
			update_cache(thread == _current);
    77a6:	4b0f      	ldr	r3, [pc, #60]	; (77e4 <z_thread_single_abort+0x80>)
    77a8:	6898      	ldr	r0, [r3, #8]
    77aa:	1b02      	subs	r2, r0, r4
    77ac:	4250      	negs	r0, r2
    77ae:	4150      	adcs	r0, r2
    77b0:	f7ff febc 	bl	752c <update_cache>
		thread->base.thread_state |= _THREAD_DEAD;
    77b4:	7b63      	ldrb	r3, [r4, #13]
    77b6:	f043 0308 	orr.w	r3, r3, #8
    77ba:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
    77bc:	f385 8811 	msr	BASEPRI, r5
    77c0:	f3bf 8f6f 	isb	sy
}
    77c4:	bd70      	pop	{r4, r5, r6, pc}
			if (z_is_thread_pending(thread)) {
    77c6:	079b      	lsls	r3, r3, #30
    77c8:	d5f4      	bpl.n	77b4 <z_thread_single_abort+0x50>
				_priq_wait_remove(&pended_on(thread)->waitq,
    77ca:	4621      	mov	r1, r4
    77cc:	68a0      	ldr	r0, [r4, #8]
    77ce:	f7ff fe97 	bl	7500 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    77d2:	7b63      	ldrb	r3, [r4, #13]
				thread->base.pended_on = NULL;
    77d4:	60a6      	str	r6, [r4, #8]
    77d6:	f023 0302 	bic.w	r3, r3, #2
    77da:	7363      	strb	r3, [r4, #13]
    77dc:	e7ea      	b.n	77b4 <z_thread_single_abort+0x50>
    77de:	bf00      	nop
    77e0:	200047ec 	.word	0x200047ec
    77e4:	200047c4 	.word	0x200047c4

000077e8 <z_remove_thread_from_ready_q>:
{
    77e8:	b538      	push	{r3, r4, r5, lr}
    77ea:	4604      	mov	r4, r0
	__asm__ volatile(
    77ec:	f04f 0320 	mov.w	r3, #32
    77f0:	f3ef 8511 	mrs	r5, BASEPRI
    77f4:	f383 8811 	msr	BASEPRI, r3
    77f8:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
    77fc:	7b43      	ldrb	r3, [r0, #13]
    77fe:	065a      	lsls	r2, r3, #25
    7800:	d507      	bpl.n	7812 <z_remove_thread_from_ready_q+0x2a>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    7802:	4601      	mov	r1, r0
    7804:	4809      	ldr	r0, [pc, #36]	; (782c <z_remove_thread_from_ready_q+0x44>)
    7806:	f7ff fe7b 	bl	7500 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    780a:	7b63      	ldrb	r3, [r4, #13]
    780c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    7810:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
    7812:	4b07      	ldr	r3, [pc, #28]	; (7830 <z_remove_thread_from_ready_q+0x48>)
    7814:	6898      	ldr	r0, [r3, #8]
    7816:	1b03      	subs	r3, r0, r4
    7818:	4258      	negs	r0, r3
    781a:	4158      	adcs	r0, r3
    781c:	f7ff fe86 	bl	752c <update_cache>
	__asm__ volatile(
    7820:	f385 8811 	msr	BASEPRI, r5
    7824:	f3bf 8f6f 	isb	sy
}
    7828:	bd38      	pop	{r3, r4, r5, pc}
    782a:	bf00      	nop
    782c:	200047ec 	.word	0x200047ec
    7830:	200047c4 	.word	0x200047c4

00007834 <pend>:
{
    7834:	b570      	push	{r4, r5, r6, lr}
    7836:	4604      	mov	r4, r0
    7838:	460d      	mov	r5, r1
    783a:	4616      	mov	r6, r2
	z_remove_thread_from_ready_q(thread);
    783c:	f7ff ffd4 	bl	77e8 <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_PENDING;
    7840:	7b63      	ldrb	r3, [r4, #13]
    7842:	f043 0302 	orr.w	r3, r3, #2
    7846:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
    7848:	b17d      	cbz	r5, 786a <pend+0x36>
	return list->head == list;
    784a:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
    784c:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    784e:	429d      	cmp	r5, r3
    7850:	d029      	beq.n	78a6 <pend+0x72>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    7852:	b343      	cbz	r3, 78a6 <pend+0x72>
	if (thread_1->base.prio < thread_2->base.prio) {
    7854:	f994 200e 	ldrsb.w	r2, [r4, #14]
    7858:	f993 100e 	ldrsb.w	r1, [r3, #14]
    785c:	4291      	cmp	r1, r2
    785e:	dd1c      	ble.n	789a <pend+0x66>
	node->prev = successor->prev;
    7860:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    7862:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
    7866:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    7868:	605c      	str	r4, [r3, #4]
	if (timeout != K_FOREVER) {
    786a:	1c73      	adds	r3, r6, #1
    786c:	d022      	beq.n	78b4 <pend+0x80>
    786e:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
    7872:	f44f 4500 	mov.w	r5, #32768	; 0x8000
    7876:	f240 30e7 	movw	r0, #999	; 0x3e7
    787a:	2100      	movs	r1, #0
    787c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    7880:	fbc5 0106 	smlal	r0, r1, r5, r6
    7884:	2300      	movs	r3, #0
    7886:	f7f8 fc29 	bl	dc <__aeabi_uldivmod>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
    788a:	490b      	ldr	r1, [pc, #44]	; (78b8 <pend+0x84>)
    788c:	1c42      	adds	r2, r0, #1
    788e:	f104 0018 	add.w	r0, r4, #24
}
    7892:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    7896:	f000 ba67 	b.w	7d68 <z_add_timeout>
	return (node == list->tail) ? NULL : node->next;
    789a:	6869      	ldr	r1, [r5, #4]
    789c:	428b      	cmp	r3, r1
    789e:	d002      	beq.n	78a6 <pend+0x72>
    78a0:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    78a2:	2b00      	cmp	r3, #0
    78a4:	d1d8      	bne.n	7858 <pend+0x24>
	node->prev = list->tail;
    78a6:	686b      	ldr	r3, [r5, #4]
    78a8:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
    78aa:	686b      	ldr	r3, [r5, #4]
	node->next = list;
    78ac:	6025      	str	r5, [r4, #0]
	list->tail->next = node;
    78ae:	601c      	str	r4, [r3, #0]
	list->tail = node;
    78b0:	606c      	str	r4, [r5, #4]
    78b2:	e7da      	b.n	786a <pend+0x36>
}
    78b4:	bd70      	pop	{r4, r5, r6, pc}
    78b6:	bf00      	nop
    78b8:	0000bd77 	.word	0x0000bd77

000078bc <z_pend_curr_irqlock>:
{
    78bc:	b570      	push	{r4, r5, r6, lr}
	pend(_current, wait_q, timeout);
    78be:	4d0f      	ldr	r5, [pc, #60]	; (78fc <z_pend_curr_irqlock+0x40>)
	pending_current = _current;
    78c0:	4c0f      	ldr	r4, [pc, #60]	; (7900 <z_pend_curr_irqlock+0x44>)
{
    78c2:	4606      	mov	r6, r0
	pend(_current, wait_q, timeout);
    78c4:	68a8      	ldr	r0, [r5, #8]
    78c6:	f7ff ffb5 	bl	7834 <pend>
	pending_current = _current;
    78ca:	68ab      	ldr	r3, [r5, #8]
    78cc:	6023      	str	r3, [r4, #0]
    78ce:	4630      	mov	r0, r6
    78d0:	f7f9 fc38 	bl	1144 <arch_swap>
	__asm__ volatile(
    78d4:	f04f 0220 	mov.w	r2, #32
    78d8:	f3ef 8311 	mrs	r3, BASEPRI
    78dc:	f382 8811 	msr	BASEPRI, r2
    78e0:	f3bf 8f6f 	isb	sy
		if (pending_current == _current) {
    78e4:	6822      	ldr	r2, [r4, #0]
    78e6:	68a9      	ldr	r1, [r5, #8]
    78e8:	4291      	cmp	r1, r2
			pending_current = NULL;
    78ea:	bf04      	itt	eq
    78ec:	2200      	moveq	r2, #0
    78ee:	6022      	streq	r2, [r4, #0]
	__asm__ volatile(
    78f0:	f383 8811 	msr	BASEPRI, r3
    78f4:	f3bf 8f6f 	isb	sy
}
    78f8:	bd70      	pop	{r4, r5, r6, pc}
    78fa:	bf00      	nop
    78fc:	200047c4 	.word	0x200047c4
    7900:	200047f4 	.word	0x200047f4

00007904 <z_pend_curr>:
{
    7904:	b510      	push	{r4, lr}
    7906:	460c      	mov	r4, r1
    7908:	4611      	mov	r1, r2
	pending_current = _current;
    790a:	4a06      	ldr	r2, [pc, #24]	; (7924 <z_pend_curr+0x20>)
    790c:	6890      	ldr	r0, [r2, #8]
    790e:	4a06      	ldr	r2, [pc, #24]	; (7928 <z_pend_curr+0x24>)
    7910:	6010      	str	r0, [r2, #0]
	pend(_current, wait_q, timeout);
    7912:	461a      	mov	r2, r3
    7914:	f7ff ff8e 	bl	7834 <pend>
    7918:	4620      	mov	r0, r4
}
    791a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    791e:	f7f9 bc11 	b.w	1144 <arch_swap>
    7922:	bf00      	nop
    7924:	200047c4 	.word	0x200047c4
    7928:	200047f4 	.word	0x200047f4

0000792c <z_tick_sleep.part.19>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static s32_t z_tick_sleep(s32_t ticks)
    792c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (ticks == 0) {
		k_yield();
		return 0;
	}

	ticks += _TICK_ALIGN;
    792e:	1c46      	adds	r6, r0, #1
	expected_wakeup_time = ticks + z_tick_get_32();
    7930:	f004 faeb 	bl	bf0a <z_tick_get_32>
    7934:	1834      	adds	r4, r6, r0
	__asm__ volatile(
    7936:	f04f 0320 	mov.w	r3, #32
    793a:	f3ef 8711 	mrs	r7, BASEPRI
    793e:	f383 8811 	msr	BASEPRI, r3
    7942:	f3bf 8f6f 	isb	sy
	 */
	struct k_spinlock local_lock = {};
	k_spinlock_key_t key = k_spin_lock(&local_lock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
    7946:	4d0d      	ldr	r5, [pc, #52]	; (797c <z_tick_sleep.part.19+0x50>)
    7948:	4b0d      	ldr	r3, [pc, #52]	; (7980 <z_tick_sleep.part.19+0x54>)
    794a:	68a8      	ldr	r0, [r5, #8]
    794c:	6018      	str	r0, [r3, #0]
#endif
	z_remove_thread_from_ready_q(_current);
    794e:	f7ff ff4b 	bl	77e8 <z_remove_thread_from_ready_q>
    7952:	68a8      	ldr	r0, [r5, #8]
    7954:	490b      	ldr	r1, [pc, #44]	; (7984 <z_tick_sleep.part.19+0x58>)
    7956:	4632      	mov	r2, r6
    7958:	3018      	adds	r0, #24
    795a:	f000 fa05 	bl	7d68 <z_add_timeout>
	z_add_thread_timeout(_current, ticks);
	z_mark_thread_as_suspended(_current);
    795e:	68aa      	ldr	r2, [r5, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
    7960:	7b53      	ldrb	r3, [r2, #13]
    7962:	f043 0310 	orr.w	r3, r3, #16
    7966:	7353      	strb	r3, [r2, #13]
    7968:	4638      	mov	r0, r7
    796a:	f7f9 fbeb 	bl	1144 <arch_swap>

	(void)z_swap(&local_lock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = expected_wakeup_time - z_tick_get_32();
    796e:	f004 facc 	bl	bf0a <z_tick_get_32>
    7972:	1a20      	subs	r0, r4, r0
		return ticks;
	}
#endif

	return 0;
}
    7974:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
    7978:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    797a:	bf00      	nop
    797c:	200047c4 	.word	0x200047c4
    7980:	200047f4 	.word	0x200047f4
    7984:	0000bd77 	.word	0x0000bd77

00007988 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
    7988:	4b04      	ldr	r3, [pc, #16]	; (799c <z_sched_init+0x14>)
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    798a:	2100      	movs	r1, #0
    798c:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
    7990:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
    7994:	4608      	mov	r0, r1
    7996:	f7ff bd73 	b.w	7480 <k_sched_time_slice_set>
    799a:	bf00      	nop
    799c:	200047c4 	.word	0x200047c4

000079a0 <z_impl_k_yield>:
{
    79a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!z_is_idle_thread_object(_current)) {
    79a2:	4c23      	ldr	r4, [pc, #140]	; (7a30 <z_impl_k_yield+0x90>)
    79a4:	4b23      	ldr	r3, [pc, #140]	; (7a34 <z_impl_k_yield+0x94>)
    79a6:	68a2      	ldr	r2, [r4, #8]
    79a8:	429a      	cmp	r2, r3
    79aa:	d029      	beq.n	7a00 <z_impl_k_yield+0x60>
    79ac:	f04f 0320 	mov.w	r3, #32
    79b0:	f3ef 8611 	mrs	r6, BASEPRI
    79b4:	f383 8811 	msr	BASEPRI, r3
    79b8:	f3bf 8f6f 	isb	sy
				_priq_run_remove(&_kernel.ready_q.runq,
    79bc:	f104 0528 	add.w	r5, r4, #40	; 0x28
    79c0:	68a1      	ldr	r1, [r4, #8]
    79c2:	4628      	mov	r0, r5
    79c4:	f7ff fd9c 	bl	7500 <z_priq_dumb_remove>
	return list->head == list;
    79c8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
			_priq_run_add(&_kernel.ready_q.runq, _current);
    79ca:	68a3      	ldr	r3, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    79cc:	42aa      	cmp	r2, r5
    79ce:	d028      	beq.n	7a22 <z_impl_k_yield+0x82>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    79d0:	b33a      	cbz	r2, 7a22 <z_impl_k_yield+0x82>
    79d2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
	if (thread_1->base.prio < thread_2->base.prio) {
    79d4:	f993 100e 	ldrsb.w	r1, [r3, #14]
    79d8:	f992 700e 	ldrsb.w	r7, [r2, #14]
    79dc:	428f      	cmp	r7, r1
    79de:	dd1b      	ble.n	7a18 <z_impl_k_yield+0x78>
	node->prev = successor->prev;
    79e0:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
    79e2:	e9c3 2100 	strd	r2, r1, [r3]
	successor->prev->next = node;
    79e6:	600b      	str	r3, [r1, #0]
	successor->prev = node;
    79e8:	6053      	str	r3, [r2, #4]
	thread->base.thread_state |= states;
    79ea:	7b5a      	ldrb	r2, [r3, #13]
    79ec:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    79f0:	735a      	strb	r2, [r3, #13]
			update_cache(1);
    79f2:	2001      	movs	r0, #1
    79f4:	f7ff fd9a 	bl	752c <update_cache>
	__asm__ volatile(
    79f8:	f386 8811 	msr	BASEPRI, r6
    79fc:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
    7a00:	f04f 0320 	mov.w	r3, #32
    7a04:	f3ef 8011 	mrs	r0, BASEPRI
    7a08:	f383 8811 	msr	BASEPRI, r3
    7a0c:	f3bf 8f6f 	isb	sy
}
    7a10:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    7a14:	f7f9 bb96 	b.w	1144 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
    7a18:	4282      	cmp	r2, r0
    7a1a:	d002      	beq.n	7a22 <z_impl_k_yield+0x82>
    7a1c:	6812      	ldr	r2, [r2, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    7a1e:	2a00      	cmp	r2, #0
    7a20:	d1da      	bne.n	79d8 <z_impl_k_yield+0x38>
	node->prev = list->tail;
    7a22:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    7a24:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
    7a26:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
	node->next = list;
    7a28:	601d      	str	r5, [r3, #0]
	list->tail->next = node;
    7a2a:	6013      	str	r3, [r2, #0]
	list->tail = node;
    7a2c:	62e3      	str	r3, [r4, #44]	; 0x2c
    7a2e:	e7dc      	b.n	79ea <z_impl_k_yield+0x4a>
    7a30:	200047c4 	.word	0x200047c4
    7a34:	20000688 	.word	0x20000688

00007a38 <z_impl_k_sleep>:

s32_t z_impl_k_sleep(int ms)
{
    7a38:	b538      	push	{r3, r4, r5, lr}
	s32_t ticks;

	__ASSERT(!arch_is_in_isr(), "");

	if (ms == K_FOREVER) {
    7a3a:	1c43      	adds	r3, r0, #1
{
    7a3c:	4604      	mov	r4, r0
	if (ms == K_FOREVER) {
    7a3e:	d105      	bne.n	7a4c <z_impl_k_sleep+0x14>
		k_thread_suspend(_current);
    7a40:	4b10      	ldr	r3, [pc, #64]	; (7a84 <z_impl_k_sleep+0x4c>)
    7a42:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
    7a44:	f000 f8dc 	bl	7c00 <z_impl_k_thread_suspend>
	}

	ticks = k_ms_to_ticks_ceil32(ms);
	ticks = z_tick_sleep(ticks);
	return k_ticks_to_ms_floor64(ticks);
}
    7a48:	4620      	mov	r0, r4
    7a4a:	bd38      	pop	{r3, r4, r5, pc}
    7a4c:	f44f 4500 	mov.w	r5, #32768	; 0x8000
    7a50:	f240 30e7 	movw	r0, #999	; 0x3e7
    7a54:	2100      	movs	r1, #0
    7a56:	fbe5 0104 	umlal	r0, r1, r5, r4
    7a5a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    7a5e:	2300      	movs	r3, #0
    7a60:	f7f8 fb3c 	bl	dc <__aeabi_uldivmod>
	if (ticks == 0) {
    7a64:	4604      	mov	r4, r0
    7a66:	b948      	cbnz	r0, 7a7c <z_impl_k_sleep+0x44>
	z_impl_k_yield();
    7a68:	f7ff ff9a 	bl	79a0 <z_impl_k_yield>
		} else {
			return (t * to_hz + off) / from_hz;
    7a6c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    7a70:	fb84 0100 	smull	r0, r1, r4, r0
    7a74:	0bc4      	lsrs	r4, r0, #15
    7a76:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
	return k_ticks_to_ms_floor64(ticks);
    7a7a:	e7e5      	b.n	7a48 <z_impl_k_sleep+0x10>
    7a7c:	f7ff ff56 	bl	792c <z_tick_sleep.part.19>
    7a80:	4604      	mov	r4, r0
    7a82:	e7f3      	b.n	7a6c <z_impl_k_sleep+0x34>
    7a84:	200047c4 	.word	0x200047c4

00007a88 <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
    7a88:	4b01      	ldr	r3, [pc, #4]	; (7a90 <z_impl_k_current_get+0x8>)
    7a8a:	6898      	ldr	r0, [r3, #8]
    7a8c:	4770      	bx	lr
    7a8e:	bf00      	nop
    7a90:	200047c4 	.word	0x200047c4

00007a94 <z_impl_k_sem_give>:
		handle_poll_events(sem);
	}
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    7a94:	b570      	push	{r4, r5, r6, lr}
    7a96:	4604      	mov	r4, r0
    7a98:	f04f 0320 	mov.w	r3, #32
    7a9c:	f3ef 8611 	mrs	r6, BASEPRI
    7aa0:	f383 8811 	msr	BASEPRI, r3
    7aa4:	f3bf 8f6f 	isb	sy
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
    7aa8:	f004 f996 	bl	bdd8 <z_unpend_first_thread>
	if (thread != NULL) {
    7aac:	4605      	mov	r5, r0
    7aae:	b170      	cbz	r0, 7ace <z_impl_k_sem_give+0x3a>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    7ab0:	7b43      	ldrb	r3, [r0, #13]
    7ab2:	06db      	lsls	r3, r3, #27
    7ab4:	d103      	bne.n	7abe <z_impl_k_sem_give+0x2a>
	if (z_is_thread_ready(thread)) {
    7ab6:	6983      	ldr	r3, [r0, #24]
    7ab8:	b90b      	cbnz	r3, 7abe <z_impl_k_sem_give+0x2a>
		z_add_thread_to_ready_q(thread);
    7aba:	f7ff fd71 	bl	75a0 <z_add_thread_to_ready_q>
    7abe:	2300      	movs	r3, #0
    7ac0:	66ab      	str	r3, [r5, #104]	; 0x68
	k_spinlock_key_t key = k_spin_lock(&lock);

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);
	do_sem_give(sem);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
    7ac2:	4631      	mov	r1, r6
    7ac4:	4805      	ldr	r0, [pc, #20]	; (7adc <z_impl_k_sem_give+0x48>)
}
    7ac6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&lock, key);
    7aca:	f004 b90f 	b.w	bcec <z_reschedule>
	sem->count += (sem->count != sem->limit) ? 1U : 0U;
    7ace:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
    7ad2:	429a      	cmp	r2, r3
    7ad4:	bf18      	it	ne
    7ad6:	3301      	addne	r3, #1
    7ad8:	60a3      	str	r3, [r4, #8]
    7ada:	e7f2      	b.n	7ac2 <z_impl_k_sem_give+0x2e>
    7adc:	20008b95 	.word	0x20008b95

00007ae0 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, s32_t timeout)
{
    7ae0:	b410      	push	{r4}
    7ae2:	4602      	mov	r2, r0
    7ae4:	460b      	mov	r3, r1
    7ae6:	f04f 0020 	mov.w	r0, #32
    7aea:	f3ef 8111 	mrs	r1, BASEPRI
    7aee:	f380 8811 	msr	BASEPRI, r0
    7af2:	f3bf 8f6f 	isb	sy
	__ASSERT(((arch_is_in_isr() == false) || (timeout == K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
    7af6:	6894      	ldr	r4, [r2, #8]
    7af8:	b144      	cbz	r4, 7b0c <z_impl_k_sem_take+0x2c>
		sem->count--;
    7afa:	3c01      	subs	r4, #1
    7afc:	6094      	str	r4, [r2, #8]
	__asm__ volatile(
    7afe:	f381 8811 	msr	BASEPRI, r1
    7b02:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
		return 0;
    7b06:	2000      	movs	r0, #0

	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);

	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
	return ret;
}
    7b08:	bc10      	pop	{r4}
    7b0a:	4770      	bx	lr
	if (timeout == K_NO_WAIT) {
    7b0c:	b933      	cbnz	r3, 7b1c <z_impl_k_sem_take+0x3c>
    7b0e:	f381 8811 	msr	BASEPRI, r1
    7b12:	f3bf 8f6f 	isb	sy
		return -EBUSY;
    7b16:	f06f 000f 	mvn.w	r0, #15
    7b1a:	e7f5      	b.n	7b08 <z_impl_k_sem_take+0x28>
	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    7b1c:	4801      	ldr	r0, [pc, #4]	; (7b24 <z_impl_k_sem_take+0x44>)
}
    7b1e:	bc10      	pop	{r4}
	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    7b20:	f7ff bef0 	b.w	7904 <z_pend_curr>
    7b24:	20008b95 	.word	0x20008b95

00007b28 <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
    7b28:	b510      	push	{r4, lr}
	__asm__ volatile(
    7b2a:	f04f 0220 	mov.w	r2, #32
    7b2e:	f3ef 8411 	mrs	r4, BASEPRI
    7b32:	f382 8811 	msr	BASEPRI, r2
    7b36:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock); /* protect kernel queues */

	if (z_has_thread_started(thread)) {
    7b3a:	7b42      	ldrb	r2, [r0, #13]
    7b3c:	0751      	lsls	r1, r2, #29
    7b3e:	d404      	bmi.n	7b4a <z_impl_k_thread_start+0x22>
	__asm__ volatile(
    7b40:	f384 8811 	msr	BASEPRI, r4
    7b44:	f3bf 8f6f 	isb	sy
	}

	z_mark_thread_as_started(thread);
	z_ready_thread(thread);
	z_reschedule(&lock, key);
}
    7b48:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
    7b4a:	f022 0104 	bic.w	r1, r2, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    7b4e:	f012 0f1b 	tst.w	r2, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
    7b52:	7341      	strb	r1, [r0, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    7b54:	d103      	bne.n	7b5e <z_impl_k_thread_start+0x36>
	if (z_is_thread_ready(thread)) {
    7b56:	6983      	ldr	r3, [r0, #24]
    7b58:	b90b      	cbnz	r3, 7b5e <z_impl_k_thread_start+0x36>
		z_add_thread_to_ready_q(thread);
    7b5a:	f7ff fd21 	bl	75a0 <z_add_thread_to_ready_q>
	z_reschedule(&lock, key);
    7b5e:	4621      	mov	r1, r4
    7b60:	4802      	ldr	r0, [pc, #8]	; (7b6c <z_impl_k_thread_start+0x44>)
}
    7b62:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&lock, key);
    7b66:	f004 b8c1 	b.w	bcec <z_reschedule>
    7b6a:	bf00      	nop
    7b6c:	20008b95 	.word	0x20008b95

00007b70 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
    7b70:	b530      	push	{r4, r5, lr}
    7b72:	b087      	sub	sp, #28
    7b74:	4604      	mov	r4, r0
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    7b76:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    7b78:	9504      	str	r5, [sp, #16]
    7b7a:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    7b7c:	9503      	str	r5, [sp, #12]
    7b7e:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    7b80:	9502      	str	r5, [sp, #8]
    7b82:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    7b84:	9501      	str	r5, [sp, #4]
    7b86:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    7b88:	9500      	str	r5, [sp, #0]
    7b8a:	f7f9 fb57 	bl	123c <arch_new_thread>
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
    7b8e:	4b03      	ldr	r3, [pc, #12]	; (7b9c <z_setup_new_thread+0x2c>)
    7b90:	689b      	ldr	r3, [r3, #8]
    7b92:	b103      	cbz	r3, 7b96 <z_setup_new_thread+0x26>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
    7b94:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    7b96:	6623      	str	r3, [r4, #96]	; 0x60
	sys_trace_thread_create(new_thread);
}
    7b98:	b007      	add	sp, #28
    7b9a:	bd30      	pop	{r4, r5, pc}
    7b9c:	200047c4 	.word	0x200047c4

00007ba0 <z_impl_k_thread_create>:
k_tid_t z_impl_k_thread_create(struct k_thread *new_thread,
			      k_thread_stack_t *stack,
			      size_t stack_size, k_thread_entry_t entry,
			      void *p1, void *p2, void *p3,
			      int prio, u32_t options, s32_t delay)
{
    7ba0:	b570      	push	{r4, r5, r6, lr}
    7ba2:	b086      	sub	sp, #24
	__ASSERT((options & K_USER) == 0,
		 "Platform is capable of user mode, and test thread created with K_USER option,"
		 " but neither CONFIG_TEST_USERSPACE nor CONFIG_USERSPACE is set\n");
#endif

	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    7ba4:	2600      	movs	r6, #0
    7ba6:	9605      	str	r6, [sp, #20]
    7ba8:	9e0e      	ldr	r6, [sp, #56]	; 0x38
    7baa:	9604      	str	r6, [sp, #16]
    7bac:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    7bae:	9603      	str	r6, [sp, #12]
    7bb0:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    7bb2:	9602      	str	r6, [sp, #8]
    7bb4:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
{
    7bb6:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    7bb8:	9601      	str	r6, [sp, #4]
    7bba:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    7bbc:	9600      	str	r6, [sp, #0]
{
    7bbe:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    7bc0:	f7ff ffd6 	bl	7b70 <z_setup_new_thread>
			  prio, options, NULL);

	if (delay != K_FOREVER) {
    7bc4:	1c6b      	adds	r3, r5, #1
    7bc6:	d003      	beq.n	7bd0 <z_impl_k_thread_create+0x30>
	if (delay == 0) {
    7bc8:	b92d      	cbnz	r5, 7bd6 <z_impl_k_thread_create+0x36>
	z_impl_k_thread_start(thread);
    7bca:	4620      	mov	r0, r4
    7bcc:	f7ff ffac 	bl	7b28 <z_impl_k_thread_start>
		schedule_new_thread(new_thread, delay);
	}

	return new_thread;
}
    7bd0:	4620      	mov	r0, r4
    7bd2:	b006      	add	sp, #24
    7bd4:	bd70      	pop	{r4, r5, r6, pc}
			return (u32_t)((t * to_hz + off) / from_hz);
    7bd6:	f44f 4600 	mov.w	r6, #32768	; 0x8000
    7bda:	f240 30e7 	movw	r0, #999	; 0x3e7
    7bde:	2100      	movs	r1, #0
    7be0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    7be4:	2300      	movs	r3, #0
    7be6:	fbe6 0105 	umlal	r0, r1, r6, r5
    7bea:	f7f8 fa77 	bl	dc <__aeabi_uldivmod>
    7bee:	4903      	ldr	r1, [pc, #12]	; (7bfc <z_impl_k_thread_create+0x5c>)
    7bf0:	1c42      	adds	r2, r0, #1
    7bf2:	f104 0018 	add.w	r0, r4, #24
    7bf6:	f000 f8b7 	bl	7d68 <z_add_timeout>
    7bfa:	e7e9      	b.n	7bd0 <z_impl_k_thread_create+0x30>
    7bfc:	0000bd77 	.word	0x0000bd77

00007c00 <z_impl_k_thread_suspend>:
#endif /* CONFIG_MULTITHREADING */

extern void z_thread_single_suspend(struct k_thread *thread);

void z_impl_k_thread_suspend(struct k_thread *thread)
{
    7c00:	b538      	push	{r3, r4, r5, lr}
    7c02:	4605      	mov	r5, r0
	__asm__ volatile(
    7c04:	f04f 0320 	mov.w	r3, #32
    7c08:	f3ef 8411 	mrs	r4, BASEPRI
    7c0c:	f383 8811 	msr	BASEPRI, r3
    7c10:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);

	z_thread_single_suspend(thread);
    7c14:	f7ff fd72 	bl	76fc <z_thread_single_suspend>

	if (thread == _current) {
    7c18:	4b07      	ldr	r3, [pc, #28]	; (7c38 <z_impl_k_thread_suspend+0x38>)
    7c1a:	689b      	ldr	r3, [r3, #8]
    7c1c:	42ab      	cmp	r3, r5
    7c1e:	d105      	bne.n	7c2c <z_impl_k_thread_suspend+0x2c>
		z_reschedule(&lock, key);
    7c20:	4621      	mov	r1, r4
    7c22:	4806      	ldr	r0, [pc, #24]	; (7c3c <z_impl_k_thread_suspend+0x3c>)
	} else {
		k_spin_unlock(&lock, key);
	}
}
    7c24:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&lock, key);
    7c28:	f004 b860 	b.w	bcec <z_reschedule>
	__asm__ volatile(
    7c2c:	f384 8811 	msr	BASEPRI, r4
    7c30:	f3bf 8f6f 	isb	sy
}
    7c34:	bd38      	pop	{r3, r4, r5, pc}
    7c36:	bf00      	nop
    7c38:	200047c4 	.word	0x200047c4
    7c3c:	20008b95 	.word	0x20008b95

00007c40 <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
    7c40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
    7c44:	4e28      	ldr	r6, [pc, #160]	; (7ce8 <z_init_static_threads+0xa8>)
    7c46:	4d29      	ldr	r5, [pc, #164]	; (7cec <z_init_static_threads+0xac>)
{
    7c48:	b087      	sub	sp, #28
    7c4a:	46b0      	mov	r8, r6
	_FOREACH_STATIC_THREAD(thread_data) {
    7c4c:	42b5      	cmp	r5, r6
    7c4e:	f105 0430 	add.w	r4, r5, #48	; 0x30
    7c52:	d310      	bcc.n	7c76 <z_init_static_threads+0x36>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
    7c54:	f7ff fc40 	bl	74d8 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    7c58:	4c24      	ldr	r4, [pc, #144]	; (7cec <z_init_static_threads+0xac>)
    7c5a:	f8df a094 	ldr.w	sl, [pc, #148]	; 7cf0 <z_init_static_threads+0xb0>
    7c5e:	f44f 4900 	mov.w	r9, #32768	; 0x8000
    7c62:	f240 36e7 	movw	r6, #999	; 0x3e7
    7c66:	2700      	movs	r7, #0
    7c68:	4544      	cmp	r4, r8
    7c6a:	d321      	bcc.n	7cb0 <z_init_static_threads+0x70>
			schedule_new_thread(thread_data->init_thread,
					    thread_data->init_delay);
		}
	}
	k_sched_unlock();
}
    7c6c:	b007      	add	sp, #28
    7c6e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	k_sched_unlock();
    7c72:	f7ff bc79 	b.w	7568 <k_sched_unlock>
		z_setup_new_thread(
    7c76:	f854 3c04 	ldr.w	r3, [r4, #-4]
    7c7a:	9305      	str	r3, [sp, #20]
    7c7c:	f854 3c10 	ldr.w	r3, [r4, #-16]
    7c80:	9304      	str	r3, [sp, #16]
    7c82:	f854 3c14 	ldr.w	r3, [r4, #-20]
    7c86:	9303      	str	r3, [sp, #12]
    7c88:	f854 3c18 	ldr.w	r3, [r4, #-24]
    7c8c:	9302      	str	r3, [sp, #8]
    7c8e:	f854 3c1c 	ldr.w	r3, [r4, #-28]
    7c92:	9301      	str	r3, [sp, #4]
    7c94:	f854 3c20 	ldr.w	r3, [r4, #-32]
    7c98:	9300      	str	r3, [sp, #0]
    7c9a:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
    7c9e:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
    7ca2:	f7ff ff65 	bl	7b70 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    7ca6:	f854 3c30 	ldr.w	r3, [r4, #-48]
    7caa:	64dd      	str	r5, [r3, #76]	; 0x4c
    7cac:	4625      	mov	r5, r4
    7cae:	e7cd      	b.n	7c4c <z_init_static_threads+0xc>
		if (thread_data->init_delay != K_FOREVER) {
    7cb0:	6a61      	ldr	r1, [r4, #36]	; 0x24
    7cb2:	1c4b      	adds	r3, r1, #1
    7cb4:	d004      	beq.n	7cc0 <z_init_static_threads+0x80>
			schedule_new_thread(thread_data->init_thread,
    7cb6:	6825      	ldr	r5, [r4, #0]
	if (delay == 0) {
    7cb8:	b921      	cbnz	r1, 7cc4 <z_init_static_threads+0x84>
    7cba:	4628      	mov	r0, r5
    7cbc:	f7ff ff34 	bl	7b28 <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    7cc0:	3430      	adds	r4, #48	; 0x30
    7cc2:	e7d1      	b.n	7c68 <z_init_static_threads+0x28>
    7cc4:	46b3      	mov	fp, r6
    7cc6:	46bc      	mov	ip, r7
    7cc8:	fbe9 bc01 	umlal	fp, ip, r9, r1
    7ccc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    7cd0:	2300      	movs	r3, #0
    7cd2:	4658      	mov	r0, fp
    7cd4:	4661      	mov	r1, ip
    7cd6:	f7f8 fa01 	bl	dc <__aeabi_uldivmod>
    7cda:	4651      	mov	r1, sl
    7cdc:	1c42      	adds	r2, r0, #1
    7cde:	f105 0018 	add.w	r0, r5, #24
    7ce2:	f000 f841 	bl	7d68 <z_add_timeout>
    7ce6:	e7eb      	b.n	7cc0 <z_init_static_threads+0x80>
    7ce8:	2000a23c 	.word	0x2000a23c
    7cec:	2000a23c 	.word	0x2000a23c
    7cf0:	0000bd77 	.word	0x0000bd77

00007cf4 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
    7cf4:	4b03      	ldr	r3, [pc, #12]	; (7d04 <elapsed+0x10>)
    7cf6:	681b      	ldr	r3, [r3, #0]
    7cf8:	b90b      	cbnz	r3, 7cfe <elapsed+0xa>
    7cfa:	f7f9 b9e1 	b.w	10c0 <z_clock_elapsed>
}
    7cfe:	2000      	movs	r0, #0
    7d00:	4770      	bx	lr
    7d02:	bf00      	nop
    7d04:	20004800 	.word	0x20004800

00007d08 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    7d08:	6803      	ldr	r3, [r0, #0]
    7d0a:	b140      	cbz	r0, 7d1e <remove_timeout+0x16>
    7d0c:	4a07      	ldr	r2, [pc, #28]	; (7d2c <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
    7d0e:	6852      	ldr	r2, [r2, #4]
    7d10:	4290      	cmp	r0, r2
    7d12:	d004      	beq.n	7d1e <remove_timeout+0x16>
	if (next(t) != NULL) {
    7d14:	b11b      	cbz	r3, 7d1e <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
    7d16:	689a      	ldr	r2, [r3, #8]
    7d18:	6881      	ldr	r1, [r0, #8]
    7d1a:	440a      	add	r2, r1
    7d1c:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
    7d1e:	6842      	ldr	r2, [r0, #4]
    7d20:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
    7d22:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    7d24:	2300      	movs	r3, #0
	node->prev = NULL;
    7d26:	e9c0 3300 	strd	r3, r3, [r0]
}
    7d2a:	4770      	bx	lr
    7d2c:	2000a16c 	.word	0x2000a16c

00007d30 <next_timeout>:
	return list->head == list;
    7d30:	4b0b      	ldr	r3, [pc, #44]	; (7d60 <next_timeout+0x30>)

static s32_t next_timeout(void)
{
    7d32:	b510      	push	{r4, lr}
    7d34:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    7d36:	429c      	cmp	r4, r3
    7d38:	bf08      	it	eq
    7d3a:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
    7d3c:	f7ff ffda 	bl	7cf4 <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
    7d40:	b154      	cbz	r4, 7d58 <next_timeout+0x28>
    7d42:	68a3      	ldr	r3, [r4, #8]
    7d44:	1a18      	subs	r0, r3, r0
    7d46:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    7d4a:	4b06      	ldr	r3, [pc, #24]	; (7d64 <next_timeout+0x34>)
    7d4c:	691b      	ldr	r3, [r3, #16]
    7d4e:	b113      	cbz	r3, 7d56 <next_timeout+0x26>
    7d50:	4298      	cmp	r0, r3
    7d52:	bfa8      	it	ge
    7d54:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    7d56:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
    7d58:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    7d5c:	e7f5      	b.n	7d4a <next_timeout+0x1a>
    7d5e:	bf00      	nop
    7d60:	2000a16c 	.word	0x2000a16c
    7d64:	200047c4 	.word	0x200047c4

00007d68 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
    7d68:	b570      	push	{r4, r5, r6, lr}
    7d6a:	4604      	mov	r4, r0
    7d6c:	4616      	mov	r6, r2
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    7d6e:	60c1      	str	r1, [r0, #12]
	__asm__ volatile(
    7d70:	f04f 0320 	mov.w	r3, #32
    7d74:	f3ef 8511 	mrs	r5, BASEPRI
    7d78:	f383 8811 	msr	BASEPRI, r3
    7d7c:	f3bf 8f6f 	isb	sy
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
    7d80:	f7ff ffb8 	bl	7cf4 <elapsed>
	return list->head == list;
    7d84:	4b18      	ldr	r3, [pc, #96]	; (7de8 <z_add_timeout+0x80>)
    7d86:	681a      	ldr	r2, [r3, #0]
    7d88:	2e01      	cmp	r6, #1
    7d8a:	bfac      	ite	ge
    7d8c:	1980      	addge	r0, r0, r6
    7d8e:	3001      	addlt	r0, #1
	return sys_dlist_is_empty(list) ? NULL : list->head;
    7d90:	429a      	cmp	r2, r3
    7d92:	60a0      	str	r0, [r4, #8]
    7d94:	d001      	beq.n	7d9a <z_add_timeout+0x32>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    7d96:	685e      	ldr	r6, [r3, #4]
		for (t = first(); t != NULL; t = next(t)) {
    7d98:	b932      	cbnz	r2, 7da8 <z_add_timeout+0x40>
	node->prev = list->tail;
    7d9a:	685a      	ldr	r2, [r3, #4]
    7d9c:	6062      	str	r2, [r4, #4]
	list->tail->next = node;
    7d9e:	685a      	ldr	r2, [r3, #4]
	node->next = list;
    7da0:	6023      	str	r3, [r4, #0]
	list->tail->next = node;
    7da2:	6014      	str	r4, [r2, #0]
	list->tail = node;
    7da4:	605c      	str	r4, [r3, #4]
    7da6:	e00a      	b.n	7dbe <z_add_timeout+0x56>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
    7da8:	6890      	ldr	r0, [r2, #8]
    7daa:	68a1      	ldr	r1, [r4, #8]
    7dac:	4288      	cmp	r0, r1
    7dae:	dd15      	ble.n	7ddc <z_add_timeout+0x74>
				t->dticks -= to->dticks;
    7db0:	1a41      	subs	r1, r0, r1
    7db2:	6091      	str	r1, [r2, #8]
	node->prev = successor->prev;
    7db4:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
    7db6:	e9c4 2100 	strd	r2, r1, [r4]
	successor->prev->next = node;
    7dba:	600c      	str	r4, [r1, #0]
	successor->prev = node;
    7dbc:	6054      	str	r4, [r2, #4]
	return list->head == list;
    7dbe:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    7dc0:	429a      	cmp	r2, r3
    7dc2:	d006      	beq.n	7dd2 <z_add_timeout+0x6a>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    7dc4:	4294      	cmp	r4, r2
    7dc6:	d104      	bne.n	7dd2 <z_add_timeout+0x6a>
			z_clock_set_timeout(next_timeout(), false);
    7dc8:	f7ff ffb2 	bl	7d30 <next_timeout>
    7dcc:	2100      	movs	r1, #0
    7dce:	f7f9 f921 	bl	1014 <z_clock_set_timeout>
	__asm__ volatile(
    7dd2:	f385 8811 	msr	BASEPRI, r5
    7dd6:	f3bf 8f6f 	isb	sy
		}
	}
}
    7dda:	bd70      	pop	{r4, r5, r6, pc}
			to->dticks -= t->dticks;
    7ddc:	1a09      	subs	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
    7dde:	42b2      	cmp	r2, r6
    7de0:	60a1      	str	r1, [r4, #8]
    7de2:	d0da      	beq.n	7d9a <z_add_timeout+0x32>
    7de4:	6812      	ldr	r2, [r2, #0]
    7de6:	e7d7      	b.n	7d98 <z_add_timeout+0x30>
    7de8:	2000a16c 	.word	0x2000a16c

00007dec <z_clock_announce>:
		}
	}
}

void z_clock_announce(s32_t ticks)
{
    7dec:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
    7df0:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    7df2:	f7ff fc4d 	bl	7690 <z_time_slice>
	__asm__ volatile(
    7df6:	f04f 0320 	mov.w	r3, #32
    7dfa:	f3ef 8511 	mrs	r5, BASEPRI
    7dfe:	f383 8811 	msr	BASEPRI, r3
    7e02:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    7e06:	4e21      	ldr	r6, [pc, #132]	; (7e8c <z_clock_announce+0xa0>)
    7e08:	4f21      	ldr	r7, [pc, #132]	; (7e90 <z_clock_announce+0xa4>)
	return list->head == list;
    7e0a:	f8df 9088 	ldr.w	r9, [pc, #136]	; 7e94 <z_clock_announce+0xa8>
    7e0e:	6034      	str	r4, [r6, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
    7e10:	46b8      	mov	r8, r7
    7e12:	f8d9 4000 	ldr.w	r4, [r9]
    7e16:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    7e18:	454c      	cmp	r4, r9
    7e1a:	e9d7 bc00 	ldrd	fp, ip, [r7]
    7e1e:	d005      	beq.n	7e2c <z_clock_announce+0x40>
    7e20:	b124      	cbz	r4, 7e2c <z_clock_announce+0x40>
    7e22:	68a3      	ldr	r3, [r4, #8]
    7e24:	4293      	cmp	r3, r2
    7e26:	dd14      	ble.n	7e52 <z_clock_announce+0x66>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    7e28:	1a9b      	subs	r3, r3, r2
    7e2a:	60a3      	str	r3, [r4, #8]
	}

	curr_tick += announce_remaining;
    7e2c:	eb1b 0002 	adds.w	r0, fp, r2
    7e30:	eb4c 71e2 	adc.w	r1, ip, r2, asr #31
	announce_remaining = 0;
    7e34:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
    7e36:	e9c8 0100 	strd	r0, r1, [r8]
	announce_remaining = 0;
    7e3a:	6034      	str	r4, [r6, #0]

	z_clock_set_timeout(next_timeout(), false);
    7e3c:	f7ff ff78 	bl	7d30 <next_timeout>
    7e40:	4621      	mov	r1, r4
    7e42:	f7f9 f8e7 	bl	1014 <z_clock_set_timeout>
	__asm__ volatile(
    7e46:	f385 8811 	msr	BASEPRI, r5
    7e4a:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
    7e4e:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		curr_tick += dt;
    7e52:	eb1b 0003 	adds.w	r0, fp, r3
    7e56:	eb4c 71e3 	adc.w	r1, ip, r3, asr #31
		announce_remaining -= dt;
    7e5a:	1ad3      	subs	r3, r2, r3
    7e5c:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
    7e5e:	2300      	movs	r3, #0
		curr_tick += dt;
    7e60:	e9c7 0100 	strd	r0, r1, [r7]
		t->dticks = 0;
    7e64:	60a3      	str	r3, [r4, #8]
		remove_timeout(t);
    7e66:	4620      	mov	r0, r4
    7e68:	f7ff ff4e 	bl	7d08 <remove_timeout>
    7e6c:	f385 8811 	msr	BASEPRI, r5
    7e70:	f3bf 8f6f 	isb	sy
		t->fn(t);
    7e74:	68e3      	ldr	r3, [r4, #12]
    7e76:	4798      	blx	r3
	__asm__ volatile(
    7e78:	f04f 0320 	mov.w	r3, #32
    7e7c:	f3ef 8511 	mrs	r5, BASEPRI
    7e80:	f383 8811 	msr	BASEPRI, r3
    7e84:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    7e88:	e7c3      	b.n	7e12 <z_clock_announce+0x26>
    7e8a:	bf00      	nop
    7e8c:	20004800 	.word	0x20004800
    7e90:	20000000 	.word	0x20000000
    7e94:	2000a16c 	.word	0x2000a16c

00007e98 <z_tick_get>:

s64_t z_tick_get(void)
{
    7e98:	e92d 4818 	stmdb	sp!, {r3, r4, fp, lr}
    7e9c:	f04f 0320 	mov.w	r3, #32
    7ea0:	f3ef 8411 	mrs	r4, BASEPRI
    7ea4:	f383 8811 	msr	BASEPRI, r3
    7ea8:	f3bf 8f6f 	isb	sy
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
    7eac:	f7f9 f908 	bl	10c0 <z_clock_elapsed>
    7eb0:	4b07      	ldr	r3, [pc, #28]	; (7ed0 <z_tick_get+0x38>)
    7eb2:	e9d3 2300 	ldrd	r2, r3, [r3]
    7eb6:	eb12 0b00 	adds.w	fp, r2, r0
    7eba:	f143 0c00 	adc.w	ip, r3, #0
    7ebe:	4658      	mov	r0, fp
    7ec0:	4661      	mov	r1, ip
	__asm__ volatile(
    7ec2:	f384 8811 	msr	BASEPRI, r4
    7ec6:	f3bf 8f6f 	isb	sy
	}
	return t;
}
    7eca:	e8bd 8818 	ldmia.w	sp!, {r3, r4, fp, pc}
    7ece:	bf00      	nop
    7ed0:	20000000 	.word	0x20000000

00007ed4 <z_timer_expiration_handler>:

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
    7ed4:	6a02      	ldr	r2, [r0, #32]
    7ed6:	2a00      	cmp	r2, #0
{
    7ed8:	b538      	push	{r3, r4, r5, lr}
    7eda:	4604      	mov	r4, r0
	if (timer->period > 0) {
    7edc:	dd02      	ble.n	7ee4 <z_timer_expiration_handler+0x10>
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    7ede:	490e      	ldr	r1, [pc, #56]	; (7f18 <z_timer_expiration_handler+0x44>)
    7ee0:	f7ff ff42 	bl	7d68 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
    7ee4:	6a63      	ldr	r3, [r4, #36]	; 0x24
    7ee6:	3301      	adds	r3, #1
    7ee8:	6263      	str	r3, [r4, #36]	; 0x24

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
    7eea:	69a3      	ldr	r3, [r4, #24]
    7eec:	b10b      	cbz	r3, 7ef2 <z_timer_expiration_handler+0x1e>
		timer->expiry_fn(timer);
    7eee:	4620      	mov	r0, r4
    7ef0:	4798      	blx	r3
	return list->head == list;
    7ef2:	f854 5f10 	ldr.w	r5, [r4, #16]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    7ef6:	42a5      	cmp	r5, r4
    7ef8:	d00d      	beq.n	7f16 <z_timer_expiration_handler+0x42>
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
    7efa:	b165      	cbz	r5, 7f16 <z_timer_expiration_handler+0x42>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
    7efc:	4628      	mov	r0, r5
    7efe:	f003 fedc 	bl	bcba <z_unpend_thread_no_timeout>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    7f02:	7b6b      	ldrb	r3, [r5, #13]
    7f04:	06db      	lsls	r3, r3, #27
    7f06:	d104      	bne.n	7f12 <z_timer_expiration_handler+0x3e>
	if (z_is_thread_ready(thread)) {
    7f08:	69ab      	ldr	r3, [r5, #24]
    7f0a:	b913      	cbnz	r3, 7f12 <z_timer_expiration_handler+0x3e>
		z_add_thread_to_ready_q(thread);
    7f0c:	4628      	mov	r0, r5
    7f0e:	f7ff fb47 	bl	75a0 <z_add_thread_to_ready_q>
    7f12:	2300      	movs	r3, #0
    7f14:	66ab      	str	r3, [r5, #104]	; 0x68

	z_ready_thread(thread);

	arch_thread_return_value_set(thread, 0);
}
    7f16:	bd38      	pop	{r3, r4, r5, pc}
    7f18:	00007ed5 	.word	0x00007ed5

00007f1c <z_impl_k_timer_start>:
	z_object_init(timer);
}


void z_impl_k_timer_start(struct k_timer *timer, s32_t duration, s32_t period)
{
    7f1c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    7f20:	f240 36e7 	movw	r6, #999	; 0x3e7
    7f24:	2700      	movs	r7, #0
    7f26:	4604      	mov	r4, r0
    7f28:	4688      	mov	r8, r1
    7f2a:	f44f 4500 	mov.w	r5, #32768	; 0x8000
    7f2e:	4630      	mov	r0, r6
    7f30:	4639      	mov	r1, r7
    7f32:	fbe5 0102 	umlal	r0, r1, r5, r2
    7f36:	2300      	movs	r3, #0
    7f38:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    7f3c:	f7f8 f8ce 	bl	dc <__aeabi_uldivmod>
    7f40:	4639      	mov	r1, r7
	__ASSERT(duration >= 0 && period >= 0 &&
		 (duration != 0 || period != 0), "invalid parameters\n");

	volatile s32_t period_in_ticks, duration_in_ticks;

	period_in_ticks = k_ms_to_ticks_ceil32(period);
    7f42:	9000      	str	r0, [sp, #0]
    7f44:	4630      	mov	r0, r6
    7f46:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    7f4a:	2300      	movs	r3, #0
    7f4c:	fbe5 0108 	umlal	r0, r1, r5, r8
    7f50:	f7f8 f8c4 	bl	dc <__aeabi_uldivmod>
	duration_in_ticks = k_ms_to_ticks_ceil32(duration);
    7f54:	9001      	str	r0, [sp, #4]

	(void)z_abort_timeout(&timer->timeout);
    7f56:	4620      	mov	r0, r4
    7f58:	f003 ff97 	bl	be8a <z_abort_timeout>
	timer->period = period_in_ticks;
    7f5c:	9b00      	ldr	r3, [sp, #0]
	timer->status = 0U;
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    7f5e:	4905      	ldr	r1, [pc, #20]	; (7f74 <z_impl_k_timer_start+0x58>)
    7f60:	9a01      	ldr	r2, [sp, #4]
	timer->period = period_in_ticks;
    7f62:	6223      	str	r3, [r4, #32]
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    7f64:	4620      	mov	r0, r4
	timer->status = 0U;
    7f66:	2300      	movs	r3, #0
    7f68:	6263      	str	r3, [r4, #36]	; 0x24
		     duration_in_ticks);
}
    7f6a:	b002      	add	sp, #8
    7f6c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    7f70:	f7ff befa 	b.w	7d68 <z_add_timeout>
    7f74:	00007ed5 	.word	0x00007ed5

00007f78 <lv_scr_act>:
/**
 * Get the active screen of the default display
 * @return pointer to the active screen
 */
static inline lv_obj_t * lv_scr_act(void)
{
    7f78:	b508      	push	{r3, lr}
    return lv_disp_get_scr_act(lv_disp_get_default());
    7f7a:	f7fd fcc5 	bl	5908 <lv_disp_get_default>
}
    7f7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return lv_disp_get_scr_act(lv_disp_get_default());
    7f82:	f7fb bd69 	b.w	3a58 <lv_disp_get_scr_act>

00007f86 <get_bit_ptr>:
/* Places a 32 bit output pointer in word, and an integer bit index
 * within that word as the return value
 */
static int get_bit_ptr(struct sys_mem_pool_base *p, int level, int bn,
		       u32_t **word)
{
    7f86:	b570      	push	{r4, r5, r6, lr}
    7f88:	68c6      	ldr	r6, [r0, #12]
	u32_t *bitarray = level <= p->max_inline_level ?
    7f8a:	f990 000b 	ldrsb.w	r0, [r0, #11]
    7f8e:	250c      	movs	r5, #12
    7f90:	434d      	muls	r5, r1
		p->levels[level].bits : p->levels[level].bits_p;
    7f92:	4288      	cmp	r0, r1
    7f94:	eb06 0405 	add.w	r4, r6, r5
    7f98:	bfb8      	it	lt
    7f9a:	5974      	ldrlt	r4, [r6, r5]

	*word = &bitarray[bn / 32];
    7f9c:	2a00      	cmp	r2, #0
    7f9e:	4610      	mov	r0, r2
    7fa0:	bfb8      	it	lt
    7fa2:	f102 001f 	addlt.w	r0, r2, #31
    7fa6:	1140      	asrs	r0, r0, #5
    7fa8:	eb04 0180 	add.w	r1, r4, r0, lsl #2
    7fac:	6019      	str	r1, [r3, #0]

	return bn & 0x1f;
}
    7fae:	f002 001f 	and.w	r0, r2, #31
    7fb2:	bd70      	pop	{r4, r5, r6, pc}

00007fb4 <pool_irq_lock.isra.2.part.3>:
	__asm__ volatile(
    7fb4:	f04f 0320 	mov.w	r3, #32
    7fb8:	f3ef 8011 	mrs	r0, BASEPRI
    7fbc:	f383 8811 	msr	BASEPRI, r3
    7fc0:	f3bf 8f6f 	isb	sy
	if (p->flags & SYS_MEM_POOL_KERNEL) {
		return irq_lock();
	} else {
		return 0;
	}
}
    7fc4:	4770      	bx	lr

00007fc6 <pool_irq_unlock.isra.4>:

static inline void pool_irq_unlock(struct sys_mem_pool_base *p, int key)
{
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    7fc6:	07c3      	lsls	r3, r0, #31
    7fc8:	d503      	bpl.n	7fd2 <pool_irq_unlock.isra.4+0xc>
	__asm__ volatile(
    7fca:	f381 8811 	msr	BASEPRI, r1
    7fce:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}
}
    7fd2:	4770      	bx	lr

00007fd4 <z_sys_mem_pool_base_init>:
{
    7fd4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    7fd8:	6846      	ldr	r6, [r0, #4]
    7fda:	8907      	ldrh	r7, [r0, #8]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
    7fdc:	6801      	ldr	r1, [r0, #0]
	for (i = 0; i < p->n_levels; i++) {
    7fde:	f890 800a 	ldrb.w	r8, [r0, #10]
	p->max_inline_level = -1;
    7fe2:	23ff      	movs	r3, #255	; 0xff
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    7fe4:	fb06 fc07 	mul.w	ip, r6, r7
	p->max_inline_level = -1;
    7fe8:	72c3      	strb	r3, [r0, #11]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
    7fea:	4461      	add	r1, ip
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    7fec:	4632      	mov	r2, r6
	for (i = 0; i < p->n_levels; i++) {
    7fee:	2300      	movs	r3, #0
		sys_dlist_init(&p->levels[i].free_list);
    7ff0:	f04f 090c 	mov.w	r9, #12
	for (i = 0; i < p->n_levels; i++) {
    7ff4:	4598      	cmp	r8, r3
    7ff6:	dc05      	bgt.n	8004 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x4>
    7ff8:	2300      	movs	r3, #0
	for (i = 0; i < p->n_max; i++) {
    7ffa:	4619      	mov	r1, r3
    7ffc:	428f      	cmp	r7, r1
    7ffe:	dc20      	bgt.n	8042 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x42>
}
    8000:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		sys_dlist_init(&p->levels[i].free_list);
    8004:	f8d0 a00c 	ldr.w	sl, [r0, #12]
		int nblocks = buflen / sz;
    8008:	fbbc f5f2 	udiv	r5, ip, r2
		sys_dlist_init(&p->levels[i].free_list);
    800c:	fb09 fe03 	mul.w	lr, r9, r3
    8010:	eb0a 040e 	add.w	r4, sl, lr
    8014:	f104 0b04 	add.w	fp, r4, #4
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
    8018:	2d20      	cmp	r5, #32
	list->tail = (sys_dnode_t *)list;
    801a:	e9c4 bb01 	strd	fp, fp, [r4, #4]
    801e:	d805      	bhi.n	802c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2c>
			p->max_inline_level = i;
    8020:	72c3      	strb	r3, [r0, #11]
		sz = WB_DN(sz / 4);
    8022:	0892      	lsrs	r2, r2, #2
    8024:	f022 0203 	bic.w	r2, r2, #3
	for (i = 0; i < p->n_levels; i++) {
    8028:	3301      	adds	r3, #1
    802a:	e7e3      	b.n	7ff4 <z_sys_mem_pool_base_init+0x20>
			bits += (nblocks + 31)/32;
    802c:	f115 041f 	adds.w	r4, r5, #31
    8030:	bf48      	it	mi
    8032:	f105 043e 	addmi.w	r4, r5, #62	; 0x3e
    8036:	1164      	asrs	r4, r4, #5
			p->levels[i].bits_p = bits;
    8038:	f84a 100e 	str.w	r1, [sl, lr]
			bits += (nblocks + 31)/32;
    803c:	eb01 0184 	add.w	r1, r1, r4, lsl #2
    8040:	e7ef      	b.n	8022 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x22>
		sys_dlist_append(&p->levels[0].free_list, block);
    8042:	68c2      	ldr	r2, [r0, #12]
	return (u8_t *)p->buf + lsz * block;
    8044:	6805      	ldr	r5, [r0, #0]
		sys_dlist_append(&p->levels[0].free_list, block);
    8046:	f102 0c04 	add.w	ip, r2, #4
	return (u8_t *)p->buf + lsz * block;
    804a:	18ec      	adds	r4, r5, r3
	node->next = list;
    804c:	f845 c003 	str.w	ip, [r5, r3]
	node->prev = list->tail;
    8050:	6895      	ldr	r5, [r2, #8]
    8052:	6065      	str	r5, [r4, #4]
	list->tail->next = node;
    8054:	6895      	ldr	r5, [r2, #8]
	for (i = 0; i < p->n_max; i++) {
    8056:	3101      	adds	r1, #1
    8058:	602c      	str	r4, [r5, #0]
	list->tail = node;
    805a:	4433      	add	r3, r6
    805c:	6094      	str	r4, [r2, #8]
    805e:	e7cd      	b.n	7ffc <z_sys_mem_pool_base_init+0x28>

00008060 <z_sys_mem_pool_block_alloc>:
	return block;
}

int z_sys_mem_pool_block_alloc(struct sys_mem_pool_base *p, size_t size,
			      u32_t *level_p, u32_t *block_p, void **data_p)
{
    8060:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8064:	b087      	sub	sp, #28
	int i, from_l, alloc_l = -1;
	unsigned int key;
	void *data = NULL;
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
    8066:	7a85      	ldrb	r5, [r0, #10]
{
    8068:	af00      	add	r7, sp, #0
    806a:	e9c7 3201 	strd	r3, r2, [r7, #4]
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
    806e:	00ab      	lsls	r3, r5, #2
    8070:	3307      	adds	r3, #7
    8072:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
    8076:	ebad 0d03 	sub.w	sp, sp, r3
    807a:	46ea      	mov	sl, sp
	 * want to allocate and the smallest one with a free entry
	 * from which we can split an allocation if needed.  Along the
	 * way, we populate an array of sizes for each level so we
	 * don't need to waste RAM storing it.
	 */
	lsizes[0] = p->max_sz;
    807c:	4653      	mov	r3, sl
    807e:	6842      	ldr	r2, [r0, #4]
    8080:	f843 2904 	str.w	r2, [r3], #-4
{
    8084:	4604      	mov	r4, r0
	for (i = 0; i < p->n_levels; i++) {
    8086:	2200      	movs	r2, #0
    8088:	4295      	cmp	r5, r2
    808a:	f102 39ff 	add.w	r9, r2, #4294967295	; 0xffffffff
    808e:	dd09      	ble.n	80a4 <z_sys_mem_pool_block_alloc+0x44>
		if (i > 0) {
    8090:	b122      	cbz	r2, 809c <z_sys_mem_pool_block_alloc+0x3c>
			lsizes[i] = WB_DN(lsizes[i-1] / 4);
    8092:	6818      	ldr	r0, [r3, #0]
    8094:	0880      	lsrs	r0, r0, #2
    8096:	f020 0003 	bic.w	r0, r0, #3
    809a:	6058      	str	r0, [r3, #4]
		}

		if (lsizes[i] < size) {
    809c:	f853 0f04 	ldr.w	r0, [r3, #4]!
    80a0:	4288      	cmp	r0, r1
    80a2:	d208      	bcs.n	80b6 <z_sys_mem_pool_block_alloc+0x56>
		}

		alloc_l = i;
	}

	if (alloc_l < 0) {
    80a4:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
    80a8:	d107      	bne.n	80ba <z_sys_mem_pool_block_alloc+0x5a>
		*data_p = NULL;
    80aa:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    80ac:	2300      	movs	r3, #0
    80ae:	6013      	str	r3, [r2, #0]
	pool_irq_unlock(p, key);

	*data_p = data;

	if (data == NULL) {
		return -ENOMEM;
    80b0:	f06f 000b 	mvn.w	r0, #11
    80b4:	e044      	b.n	8140 <z_sys_mem_pool_block_alloc+0xe0>
	for (i = 0; i < p->n_levels; i++) {
    80b6:	3201      	adds	r2, #1
    80b8:	e7e6      	b.n	8088 <z_sys_mem_pool_block_alloc+0x28>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    80ba:	7c20      	ldrb	r0, [r4, #16]
    80bc:	f010 0001 	ands.w	r0, r0, #1
    80c0:	d001      	beq.n	80c6 <z_sys_mem_pool_block_alloc+0x66>
    80c2:	f7ff ff77 	bl	7fb4 <pool_irq_lock.isra.2.part.3>
    80c6:	68e2      	ldr	r2, [r4, #12]
    80c8:	230c      	movs	r3, #12
	key = pool_irq_lock(p);
    80ca:	4680      	mov	r8, r0
	for (i = alloc_l; i >= 0; i--) {
    80cc:	fb03 2309 	mla	r3, r3, r9, r2
	block = sys_dlist_get(&p->levels[l].free_list);
    80d0:	464e      	mov	r6, r9
	return list->head == list;
    80d2:	461a      	mov	r2, r3
    80d4:	f852 5f04 	ldr.w	r5, [r2, #4]!

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
    80d8:	4295      	cmp	r5, r2
    80da:	d06d      	beq.n	81b8 <z_sys_mem_pool_block_alloc+0x158>
	node->prev->next = node->next;
    80dc:	e9d5 3200 	ldrd	r3, r2, [r5]
    80e0:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
    80e2:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    80e4:	2300      	movs	r3, #0
	node->prev = NULL;
    80e6:	e9c5 3300 	strd	r3, r3, [r5]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
    80ea:	6823      	ldr	r3, [r4, #0]
		data = block_alloc(p, i, lsizes[i]);
    80ec:	f85a 1026 	ldr.w	r1, [sl, r6, lsl #2]
	int bit = get_bit_ptr(p, level, bn, &word);
    80f0:	f107 0b14 	add.w	fp, r7, #20
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
    80f4:	1aea      	subs	r2, r5, r3
	int bit = get_bit_ptr(p, level, bn, &word);
    80f6:	4620      	mov	r0, r4
    80f8:	fb92 f2f1 	sdiv	r2, r2, r1
    80fc:	465b      	mov	r3, fp
    80fe:	4631      	mov	r1, r6
    8100:	f7ff ff41 	bl	7f86 <get_bit_ptr>
	*word |= (1<<bit);
    8104:	6979      	ldr	r1, [r7, #20]
    8106:	2201      	movs	r2, #1
    8108:	680b      	ldr	r3, [r1, #0]
    810a:	603a      	str	r2, [r7, #0]
    810c:	fa02 f000 	lsl.w	r0, r2, r0
    8110:	4303      	orrs	r3, r0
    8112:	600b      	str	r3, [r1, #0]
			for (from_l = i; from_l < alloc_l; from_l++) {
    8114:	454e      	cmp	r6, r9
    8116:	db17      	blt.n	8148 <z_sys_mem_pool_block_alloc+0xe8>
	pool_irq_unlock(p, key);
    8118:	4641      	mov	r1, r8
    811a:	7c20      	ldrb	r0, [r4, #16]
    811c:	f7ff ff53 	bl	7fc6 <pool_irq_unlock.isra.4>
	*data_p = data;
    8120:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    8122:	601d      	str	r5, [r3, #0]
	if (data == NULL) {
    8124:	2d00      	cmp	r5, #0
    8126:	d0c3      	beq.n	80b0 <z_sys_mem_pool_block_alloc+0x50>
	}

	*level_p = alloc_l;
    8128:	68bb      	ldr	r3, [r7, #8]
    812a:	f8c3 9000 	str.w	r9, [r3]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
    812e:	6823      	ldr	r3, [r4, #0]
    8130:	1aed      	subs	r5, r5, r3
    8132:	f85a 3029 	ldr.w	r3, [sl, r9, lsl #2]
    8136:	fb95 f5f3 	sdiv	r5, r5, r3
	*block_p = block_num(p, data, lsizes[alloc_l]);
    813a:	687b      	ldr	r3, [r7, #4]

	return 0;
    813c:	2000      	movs	r0, #0
	*block_p = block_num(p, data, lsizes[alloc_l]);
    813e:	601d      	str	r5, [r3, #0]
}
    8140:	371c      	adds	r7, #28
    8142:	46bd      	mov	sp, r7
    8144:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
    8148:	6822      	ldr	r2, [r4, #0]
    814a:	f85a 3026 	ldr.w	r3, [sl, r6, lsl #2]
	set_alloc_bit(p, l + 1, 4*bn);
    814e:	3601      	adds	r6, #1
	int bit = get_bit_ptr(p, level, bn, &word);
    8150:	4631      	mov	r1, r6
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
    8152:	1aaa      	subs	r2, r5, r2
	int bit = get_bit_ptr(p, level, bn, &word);
    8154:	4620      	mov	r0, r4
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
    8156:	fb92 f2f3 	sdiv	r2, r2, r3
	int bit = get_bit_ptr(p, level, bn, &word);
    815a:	465b      	mov	r3, fp
    815c:	0092      	lsls	r2, r2, #2
    815e:	f7ff ff12 	bl	7f86 <get_bit_ptr>
	*word |= (1<<bit);
    8162:	697a      	ldr	r2, [r7, #20]
    8164:	683b      	ldr	r3, [r7, #0]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
    8166:	68e1      	ldr	r1, [r4, #12]
	*word |= (1<<bit);
    8168:	fa03 f000 	lsl.w	r0, r3, r0
    816c:	6813      	ldr	r3, [r2, #0]
    816e:	4303      	orrs	r3, r0
    8170:	6013      	str	r3, [r2, #0]
		int lsz = lsizes[l + 1];
    8172:	f85a 0026 	ldr.w	r0, [sl, r6, lsl #2]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
    8176:	230c      	movs	r3, #12
    8178:	fb03 1106 	mla	r1, r3, r6, r1
    817c:	2203      	movs	r2, #3
    817e:	f101 0e04 	add.w	lr, r1, #4
    8182:	182b      	adds	r3, r5, r0
    8184:	60fa      	str	r2, [r7, #12]
	node->prev = list->tail;
    8186:	688a      	ldr	r2, [r1, #8]
    8188:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
    818a:	688a      	ldr	r2, [r1, #8]
	node->next = list;
    818c:	f8c3 e000 	str.w	lr, [r3]
	list->tail->next = node;
    8190:	6013      	str	r3, [r2, #0]
	for (i = 1; i < 4; i++) {
    8192:	68fa      	ldr	r2, [r7, #12]
	list->tail = node;
    8194:	608b      	str	r3, [r1, #8]
    8196:	3a01      	subs	r2, #1
    8198:	4403      	add	r3, r0
    819a:	60fa      	str	r2, [r7, #12]
    819c:	d1f3      	bne.n	8186 <z_sys_mem_pool_block_alloc+0x126>
				pool_irq_unlock(p, key);
    819e:	4641      	mov	r1, r8
    81a0:	7c20      	ldrb	r0, [r4, #16]
    81a2:	f7ff ff10 	bl	7fc6 <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    81a6:	7c23      	ldrb	r3, [r4, #16]
    81a8:	07d9      	lsls	r1, r3, #31
    81aa:	d503      	bpl.n	81b4 <z_sys_mem_pool_block_alloc+0x154>
    81ac:	f7ff ff02 	bl	7fb4 <pool_irq_lock.isra.2.part.3>
				key = pool_irq_lock(p);
    81b0:	4680      	mov	r8, r0
    81b2:	e7af      	b.n	8114 <z_sys_mem_pool_block_alloc+0xb4>
		return 0;
    81b4:	68f8      	ldr	r0, [r7, #12]
    81b6:	e7fb      	b.n	81b0 <z_sys_mem_pool_block_alloc+0x150>
	for (i = alloc_l; i >= 0; i--) {
    81b8:	3e01      	subs	r6, #1
    81ba:	1c72      	adds	r2, r6, #1
    81bc:	f1a3 030c 	sub.w	r3, r3, #12
    81c0:	d187      	bne.n	80d2 <z_sys_mem_pool_block_alloc+0x72>
    81c2:	2500      	movs	r5, #0
    81c4:	e7a8      	b.n	8118 <z_sys_mem_pool_block_alloc+0xb8>

000081c6 <z_sys_mem_pool_block_free>:

void z_sys_mem_pool_block_free(struct sys_mem_pool_base *p, u32_t level,
			      u32_t block)
{
    81c6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    81ca:	b085      	sub	sp, #20
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
    81cc:	7a83      	ldrb	r3, [r0, #10]
    81ce:	009b      	lsls	r3, r3, #2
    81d0:	3307      	adds	r3, #7
    81d2:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
{
    81d6:	af00      	add	r7, sp, #0
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
    81d8:	ebad 0d03 	sub.w	sp, sp, r3
    81dc:	46eb      	mov	fp, sp
	 * to avoid having to store it in precious RAM bytes.
	 * Overhead here is somewhat higher because block_free()
	 * doesn't inherently need to traverse all the larger
	 * sublevels.
	 */
	lsizes[0] = p->max_sz;
    81de:	6843      	ldr	r3, [r0, #4]
    81e0:	f8cb 3000 	str.w	r3, [fp]
{
    81e4:	4606      	mov	r6, r0
	for (i = 1; i <= level; i++) {
    81e6:	465c      	mov	r4, fp
    81e8:	2001      	movs	r0, #1
    81ea:	4281      	cmp	r1, r0
    81ec:	d215      	bcs.n	821a <z_sys_mem_pool_block_free+0x54>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    81ee:	7c30      	ldrb	r0, [r6, #16]
    81f0:	f010 0001 	ands.w	r0, r0, #1
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
	}

	block_free(p, level, lsizes, block);
    81f4:	4688      	mov	r8, r1
    81f6:	4615      	mov	r5, r2
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    81f8:	d001      	beq.n	81fe <z_sys_mem_pool_block_free+0x38>
    81fa:	f7ff fedb 	bl	7fb4 <pool_irq_lock.isra.2.part.3>
	unsigned int key = pool_irq_lock(p);
    81fe:	4604      	mov	r4, r0
	while (level >= 0) {
    8200:	f1b8 0f00 	cmp.w	r8, #0
    8204:	da11      	bge.n	822a <z_sys_mem_pool_block_free+0x64>
	return -1;
    8206:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	pool_irq_unlock(p, key);
    820a:	4621      	mov	r1, r4
    820c:	7c30      	ldrb	r0, [r6, #16]
    820e:	f7ff feda 	bl	7fc6 <pool_irq_unlock.isra.4>
}
    8212:	3714      	adds	r7, #20
    8214:	46bd      	mov	sp, r7
    8216:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
    821a:	6823      	ldr	r3, [r4, #0]
    821c:	089b      	lsrs	r3, r3, #2
    821e:	f023 0303 	bic.w	r3, r3, #3
    8222:	f844 3f04 	str.w	r3, [r4, #4]!
	for (i = 1; i <= level; i++) {
    8226:	3001      	adds	r0, #1
    8228:	e7df      	b.n	81ea <z_sys_mem_pool_block_free+0x24>
		int i, lsz = lsizes[level];
    822a:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
    822e:	607b      	str	r3, [r7, #4]
	return (u8_t *)p->buf + lsz * block;
    8230:	fb03 fa05 	mul.w	sl, r3, r5
    8234:	6833      	ldr	r3, [r6, #0]
    8236:	603b      	str	r3, [r7, #0]
    8238:	eb03 090a 	add.w	r9, r3, sl
	int bit = get_bit_ptr(p, level, bn, &word);
    823c:	462a      	mov	r2, r5
    823e:	f107 030c 	add.w	r3, r7, #12
    8242:	4641      	mov	r1, r8
    8244:	4630      	mov	r0, r6
    8246:	f7ff fe9e 	bl	7f86 <get_bit_ptr>
	*word &= ~(1<<bit);
    824a:	68fa      	ldr	r2, [r7, #12]
	node->next = list;
    824c:	6839      	ldr	r1, [r7, #0]
    824e:	2301      	movs	r3, #1
    8250:	fa03 f000 	lsl.w	r0, r3, r0
    8254:	6813      	ldr	r3, [r2, #0]
    8256:	ea23 0300 	bic.w	r3, r3, r0
    825a:	6013      	str	r3, [r2, #0]
		sys_dlist_append(&p->levels[level].free_list, block);
    825c:	68f3      	ldr	r3, [r6, #12]
    825e:	220c      	movs	r2, #12
    8260:	fb02 3308 	mla	r3, r2, r8, r3
    8264:	1d1a      	adds	r2, r3, #4
    8266:	f841 200a 	str.w	r2, [r1, sl]
	node->prev = list->tail;
    826a:	689a      	ldr	r2, [r3, #8]
    826c:	f8c9 2004 	str.w	r2, [r9, #4]
	list->tail->next = node;
    8270:	689a      	ldr	r2, [r3, #8]
    8272:	f8c2 9000 	str.w	r9, [r2]
	list->tail = node;
    8276:	f8c3 9008 	str.w	r9, [r3, #8]
		pool_irq_unlock(p, key);
    827a:	7c30      	ldrb	r0, [r6, #16]
    827c:	4621      	mov	r1, r4
    827e:	f7ff fea2 	bl	7fc6 <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    8282:	7c30      	ldrb	r0, [r6, #16]
    8284:	f010 0001 	ands.w	r0, r0, #1
    8288:	d001      	beq.n	828e <z_sys_mem_pool_block_free+0xc8>
    828a:	f7ff fe93 	bl	7fb4 <pool_irq_lock.isra.2.part.3>
		key = pool_irq_lock(p);
    828e:	4604      	mov	r4, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
    8290:	f1b8 0f00 	cmp.w	r8, #0
    8294:	d0b9      	beq.n	820a <z_sys_mem_pool_block_free+0x44>
	int bit = get_bit_ptr(p, level, bn, &word);
    8296:	f107 030c 	add.w	r3, r7, #12
    829a:	462a      	mov	r2, r5
    829c:	4641      	mov	r1, r8
    829e:	4630      	mov	r0, r6
    82a0:	f7ff fe71 	bl	7f86 <get_bit_ptr>
	return (*word >> (4*(bit / 4))) & 0xf;
    82a4:	68fb      	ldr	r3, [r7, #12]
    82a6:	2800      	cmp	r0, #0
    82a8:	bfb8      	it	lt
    82aa:	3003      	addlt	r0, #3
    82ac:	681b      	ldr	r3, [r3, #0]
    82ae:	f020 0003 	bic.w	r0, r0, #3
    82b2:	fa23 f000 	lsr.w	r0, r3, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
    82b6:	f010 000f 	ands.w	r0, r0, #15
    82ba:	d1a6      	bne.n	820a <z_sys_mem_pool_block_free+0x44>
			int b = (bn & ~3) + i;
    82bc:	f025 0a03 	bic.w	sl, r5, #3
	node->next = NULL;
    82c0:	4684      	mov	ip, r0
	return (u8_t *)p->buf + lsz * block;
    82c2:	687a      	ldr	r2, [r7, #4]
			int b = (bn & ~3) + i;
    82c4:	eb0a 0300 	add.w	r3, sl, r0
	return (u8_t *)p->buf + lsz * block;
    82c8:	4353      	muls	r3, r2
    82ca:	6832      	ldr	r2, [r6, #0]
    82cc:	18d1      	adds	r1, r2, r3
	node->prev->next = node->next;
    82ce:	f852 e003 	ldr.w	lr, [r2, r3]
    82d2:	f8d1 9004 	ldr.w	r9, [r1, #4]
		for (i = 0; i < 4; i++) {
    82d6:	3001      	adds	r0, #1
    82d8:	2804      	cmp	r0, #4
    82da:	f8c9 e000 	str.w	lr, [r9]
	node->next->prev = node->prev;
    82de:	f8ce 9004 	str.w	r9, [lr, #4]
	node->next = NULL;
    82e2:	f842 c003 	str.w	ip, [r2, r3]
	node->prev = NULL;
    82e6:	f8c1 c004 	str.w	ip, [r1, #4]
    82ea:	d1ea      	bne.n	82c2 <z_sys_mem_pool_block_free+0xfc>
		bn = bn / 4;
    82ec:	2d00      	cmp	r5, #0
    82ee:	bfb8      	it	lt
    82f0:	3503      	addlt	r5, #3
		level = level - 1;
    82f2:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
		bn = bn / 4;
    82f6:	10ad      	asrs	r5, r5, #2
    82f8:	e782      	b.n	8200 <z_sys_mem_pool_block_free+0x3a>

000082fa <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    82fa:	4604      	mov	r4, r0
    82fc:	b508      	push	{r3, lr}
    82fe:	4608      	mov	r0, r1
    8300:	4611      	mov	r1, r2
	entry(p1, p2, p3);
    8302:	461a      	mov	r2, r3
    8304:	47a0      	blx	r4
	return z_impl_k_current_get();
    8306:	f7ff fbbf 	bl	7a88 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
    830a:	f7f9 fb2d 	bl	1968 <z_impl_k_thread_abort>

0000830e <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    830e:	4770      	bx	lr

00008310 <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
    8310:	2300      	movs	r3, #0
	list->head = NULL;
    8312:	e9c0 3300 	strd	r3, r3, [r0]
}
    8316:	4770      	bx	lr

00008318 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
    8318:	6803      	ldr	r3, [r0, #0]
    831a:	b923      	cbnz	r3, 8326 <log_list_add_tail+0xe>
		list->head = msg;
    831c:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
    831e:	2300      	movs	r3, #0
	list->tail = msg;
    8320:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
    8322:	600b      	str	r3, [r1, #0]
}
    8324:	4770      	bx	lr
		list->tail->next = msg;
    8326:	6843      	ldr	r3, [r0, #4]
    8328:	6019      	str	r1, [r3, #0]
    832a:	e7f8      	b.n	831e <log_list_add_tail+0x6>

0000832c <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
    832c:	6800      	ldr	r0, [r0, #0]
    832e:	4770      	bx	lr

00008330 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
	struct log_msg *msg = list->head;
    8330:	6803      	ldr	r3, [r0, #0]

	if (list->head != NULL) {
    8332:	b10b      	cbz	r3, 8338 <log_list_head_get+0x8>
		list->head = list->head->next;
    8334:	681a      	ldr	r2, [r3, #0]
    8336:	6002      	str	r2, [r0, #0]
	}

	return msg;
}
    8338:	4618      	mov	r0, r3
    833a:	4770      	bx	lr

0000833c <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
    833c:	b508      	push	{r3, lr}
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    833e:	f7f8 fbcb 	bl	ad8 <log_msg_chunk_alloc>

	if (msg != NULL) {
    8342:	b118      	cbz	r0, 834c <z_log_msg_std_alloc+0x10>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
    8344:	2301      	movs	r3, #1
    8346:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    8348:	2300      	movs	r3, #0
    834a:	8103      	strh	r3, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
	}

	return msg;
}
    834c:	bd08      	pop	{r3, pc}

0000834e <k_cycle_get_32_wrapper>:
#ifndef _ASMLANGUAGE
extern u32_t z_timer_cycle_get_32(void);

static inline u32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
    834e:	f7f8 bed1 	b.w	10f4 <z_timer_cycle_get_32>

00008352 <dummy_timestamp>:
    8352:	2000      	movs	r0, #0
    8354:	4770      	bx	lr

00008356 <z_log_get_s_mask>:
	u32_t mask = 0;
    8356:	2300      	movs	r3, #0
{
    8358:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32_t arg = 0;
    835a:	461a      	mov	r2, r3
	bool arm = false;
    835c:	461c      	mov	r4, r3
				mask |= BIT(arg);
    835e:	2701      	movs	r7, #1
	while ((curr = *str++) && arg < nargs) {
    8360:	f810 5b01 	ldrb.w	r5, [r0], #1
    8364:	b10d      	cbz	r5, 836a <z_log_get_s_mask+0x14>
    8366:	428a      	cmp	r2, r1
    8368:	d301      	bcc.n	836e <z_log_get_s_mask+0x18>
}
    836a:	4618      	mov	r0, r3
    836c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (curr == '%') {
    836e:	2d25      	cmp	r5, #37	; 0x25
    8370:	d102      	bne.n	8378 <z_log_get_s_mask+0x22>
			arm = !arm;
    8372:	f084 0401 	eor.w	r4, r4, #1
    8376:	e7f3      	b.n	8360 <z_log_get_s_mask+0xa>
		} else if (arm && isalpha((int)curr)) {
    8378:	2c00      	cmp	r4, #0
    837a:	d0f1      	beq.n	8360 <z_log_get_s_mask+0xa>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    837c:	f045 0620 	orr.w	r6, r5, #32
    8380:	3e61      	subs	r6, #97	; 0x61
    8382:	2e19      	cmp	r6, #25
    8384:	d8ec      	bhi.n	8360 <z_log_get_s_mask+0xa>
			if (curr == 's') {
    8386:	2d73      	cmp	r5, #115	; 0x73
				mask |= BIT(arg);
    8388:	bf04      	itt	eq
    838a:	fa07 f402 	lsleq.w	r4, r7, r2
    838e:	4323      	orreq	r3, r4
			arg++;
    8390:	3201      	adds	r2, #1
			arm = false;
    8392:	2400      	movs	r4, #0
    8394:	e7e4      	b.n	8360 <z_log_get_s_mask+0xa>

00008396 <log_0>:
{
    8396:	b538      	push	{r3, r4, r5, lr}
    8398:	4605      	mov	r5, r0
    839a:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
    839c:	f7ff ffce 	bl	833c <z_log_msg_std_alloc>

	if (msg != NULL) {
    83a0:	b128      	cbz	r0, 83ae <log_0+0x18>
		msg->str = str;
    83a2:	6105      	str	r5, [r0, #16]
		msg_finalize(msg, src_level);
    83a4:	4621      	mov	r1, r4
}
    83a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		msg_finalize(msg, src_level);
    83aa:	f7f8 bab7 	b.w	91c <msg_finalize>
}
    83ae:	bd38      	pop	{r3, r4, r5, pc}

000083b0 <log_1>:
{
    83b0:	b570      	push	{r4, r5, r6, lr}
    83b2:	4604      	mov	r4, r0
    83b4:	460e      	mov	r6, r1
    83b6:	4615      	mov	r5, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    83b8:	f7ff ffc0 	bl	833c <z_log_msg_std_alloc>

	if (msg != NULL) {
    83bc:	b158      	cbz	r0, 83d6 <log_1+0x26>
		msg->str = str;
    83be:	6104      	str	r4, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
    83c0:	7a44      	ldrb	r4, [r0, #9]
		msg->payload.single.args[0] = arg1;
    83c2:	6146      	str	r6, [r0, #20]
		msg->hdr.params.std.nargs = 1U;
    83c4:	2201      	movs	r2, #1
    83c6:	f362 1407 	bfi	r4, r2, #4, #4
    83ca:	7244      	strb	r4, [r0, #9]
		msg_finalize(msg, src_level);
    83cc:	4629      	mov	r1, r5
}
    83ce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		msg_finalize(msg, src_level);
    83d2:	f7f8 baa3 	b.w	91c <msg_finalize>
}
    83d6:	bd70      	pop	{r4, r5, r6, pc}

000083d8 <log_2>:
{
    83d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    83dc:	4605      	mov	r5, r0
    83de:	4688      	mov	r8, r1
    83e0:	4617      	mov	r7, r2
    83e2:	461e      	mov	r6, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    83e4:	f7ff ffaa 	bl	833c <z_log_msg_std_alloc>

	if (msg != NULL) {
    83e8:	b160      	cbz	r0, 8404 <log_2+0x2c>
		msg->str = str;
    83ea:	6105      	str	r5, [r0, #16]
		msg->hdr.params.std.nargs = 2U;
    83ec:	7a45      	ldrb	r5, [r0, #9]
    83ee:	2302      	movs	r3, #2
    83f0:	f363 1507 	bfi	r5, r3, #4, #4
    83f4:	7245      	strb	r5, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
    83f6:	e9c0 8705 	strd	r8, r7, [r0, #20]
		msg_finalize(msg, src_level);
    83fa:	4631      	mov	r1, r6
}
    83fc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		msg_finalize(msg, src_level);
    8400:	f7f8 ba8c 	b.w	91c <msg_finalize>
}
    8404:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00008408 <log_3>:
{
    8408:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    840c:	4605      	mov	r5, r0
    840e:	4689      	mov	r9, r1
    8410:	4690      	mov	r8, r2
    8412:	461f      	mov	r7, r3
    8414:	f8bd 6020 	ldrh.w	r6, [sp, #32]
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    8418:	f7ff ff90 	bl	833c <z_log_msg_std_alloc>

	if (msg != NULL) {
    841c:	b168      	cbz	r0, 843a <log_3+0x32>
		msg->str = str;
    841e:	6105      	str	r5, [r0, #16]
		msg->hdr.params.std.nargs = 3U;
    8420:	7a45      	ldrb	r5, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
		msg->payload.single.args[2] = arg3;
    8422:	61c7      	str	r7, [r0, #28]
		msg->hdr.params.std.nargs = 3U;
    8424:	2303      	movs	r3, #3
    8426:	f363 1507 	bfi	r5, r3, #4, #4
    842a:	7245      	strb	r5, [r0, #9]
		msg->payload.single.args[1] = arg2;
    842c:	e9c0 9805 	strd	r9, r8, [r0, #20]
		msg_finalize(msg, src_level);
    8430:	4631      	mov	r1, r6
}
    8432:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		msg_finalize(msg, src_level);
    8436:	f7f8 ba71 	b.w	91c <msg_finalize>
}
    843a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0000843e <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
    843e:	7a40      	ldrb	r0, [r0, #9]
}
    8440:	0900      	lsrs	r0, r0, #4
    8442:	4770      	bx	lr

00008444 <log_msg_arg_get>:
log_arg_t log_msg_arg_get(struct log_msg *msg, u32_t arg_idx)
{
	log_arg_t arg;

	/* Return early if requested argument not present in the message. */
	if (arg_idx >= msg->hdr.params.std.nargs) {
    8444:	7a43      	ldrb	r3, [r0, #9]
    8446:	091b      	lsrs	r3, r3, #4
    8448:	428b      	cmp	r3, r1
    844a:	d916      	bls.n	847a <log_msg_arg_get+0x36>
		return 0;
	}

	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
    844c:	2b03      	cmp	r3, #3
    844e:	d803      	bhi.n	8458 <log_msg_arg_get+0x14>
		arg = msg->payload.single.args[arg_idx];
    8450:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    8454:	6948      	ldr	r0, [r1, #20]
    8456:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
    8458:	2901      	cmp	r1, #1
    845a:	d803      	bhi.n	8464 <log_msg_arg_get+0x20>
		return msg->payload.ext.data.args[arg_idx];
    845c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    8460:	6988      	ldr	r0, [r1, #24]
    8462:	4770      	bx	lr
	cont = msg->payload.ext.next;
    8464:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
    8466:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
    8468:	2906      	cmp	r1, #6
    846a:	d803      	bhi.n	8474 <log_msg_arg_get+0x30>
	return cont->payload.args[arg_idx];
    846c:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    8470:	6848      	ldr	r0, [r1, #4]
    8472:	4770      	bx	lr
		arg_idx -= ARGS_CONT_MSG;
    8474:	3907      	subs	r1, #7
		cont = cont->next;
    8476:	681b      	ldr	r3, [r3, #0]
    8478:	e7f6      	b.n	8468 <log_msg_arg_get+0x24>
		return 0;
    847a:	2000      	movs	r0, #0
	} else {
		arg = cont_arg_get(msg, arg_idx);
	}

	return arg;
}
    847c:	4770      	bx	lr

0000847e <log_msg_put>:
{
    847e:	4603      	mov	r3, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    8480:	1d02      	adds	r2, r0, #4
    8482:	f3bf 8f5b 	dmb	ish
    8486:	e852 1f00 	ldrex	r1, [r2]
    848a:	3901      	subs	r1, #1
    848c:	e842 1c00 	strex	ip, r1, [r2]
    8490:	f1bc 0f00 	cmp.w	ip, #0
    8494:	d1f7      	bne.n	8486 <log_msg_put+0x8>
    8496:	f3bf 8f5b 	dmb	ish
	if (msg->hdr.ref_cnt == 0) {
    849a:	685b      	ldr	r3, [r3, #4]
    849c:	b90b      	cbnz	r3, 84a2 <log_msg_put+0x24>
		msg_free(msg);
    849e:	f7f8 bb2d 	b.w	afc <msg_free>
}
    84a2:	4770      	bx	lr

000084a4 <log_msg_str_get>:

const char *log_msg_str_get(struct log_msg *msg)
{
	return msg->str;
}
    84a4:	6900      	ldr	r0, [r0, #16]
    84a6:	4770      	bx	lr

000084a8 <get_status>:
	data = get_sub_data(dev, type);
    84a8:	6883      	ldr	r3, [r0, #8]
	return &data->subsys[type];
    84aa:	b2c9      	uxtb	r1, r1
	if (data->started) {
    84ac:	220c      	movs	r2, #12
    84ae:	fb02 3101 	mla	r1, r2, r1, r3
    84b2:	7a4b      	ldrb	r3, [r1, #9]
    84b4:	b923      	cbnz	r3, 84c0 <get_status+0x18>
	if (data->ref > 0) {
    84b6:	7a08      	ldrb	r0, [r1, #8]
		return CLOCK_CONTROL_STATUS_ON;
    84b8:	fab0 f080 	clz	r0, r0
    84bc:	0940      	lsrs	r0, r0, #5
    84be:	4770      	bx	lr
    84c0:	2002      	movs	r0, #2
}
    84c2:	4770      	bx	lr

000084c4 <clkstarted_handle>:
{
    84c4:	b538      	push	{r3, r4, r5, lr}
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
    84c6:	6883      	ldr	r3, [r0, #8]
	sub_data->started = true;
    84c8:	240c      	movs	r4, #12
    84ca:	fb04 3401 	mla	r4, r4, r1, r3
    84ce:	2301      	movs	r3, #1
{
    84d0:	4605      	mov	r5, r0
	sub_data->started = true;
    84d2:	7263      	strb	r3, [r4, #9]
	__asm__ volatile(
    84d4:	f04f 0320 	mov.w	r3, #32
    84d8:	f3ef 8111 	mrs	r1, BASEPRI
    84dc:	f383 8811 	msr	BASEPRI, r3
    84e0:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
    84e4:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    84e6:	b12b      	cbz	r3, 84f4 <clkstarted_handle+0x30>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    84e8:	6860      	ldr	r0, [r4, #4]
    84ea:	681a      	ldr	r2, [r3, #0]
	list->head = node;
    84ec:	6022      	str	r2, [r4, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    84ee:	4283      	cmp	r3, r0
	list->tail = node;
    84f0:	bf08      	it	eq
    84f2:	6062      	streq	r2, [r4, #4]
	__asm__ volatile(
    84f4:	f381 8811 	msr	BASEPRI, r1
    84f8:	f3bf 8f6f 	isb	sy
	while ((async_data = list_get(&sub_data->list)) != NULL) {
    84fc:	b903      	cbnz	r3, 8500 <clkstarted_handle+0x3c>
}
    84fe:	bd38      	pop	{r3, r4, r5, pc}
		async_data->cb(dev, async_data->user_data);
    8500:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
    8504:	4628      	mov	r0, r5
    8506:	4790      	blx	r2
    8508:	e7e4      	b.n	84d4 <clkstarted_handle+0x10>

0000850a <clock_async_start>:
	const struct nrf_clock_control_config *config =
    850a:	6803      	ldr	r3, [r0, #0]
	clk_data = get_sub_data(dev, type);
    850c:	f8d0 c008 	ldr.w	ip, [r0, #8]
{
    8510:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8514:	4605      	mov	r5, r0
	const struct nrf_clock_control_config *config =
    8516:	689f      	ldr	r7, [r3, #8]
	return &config->subsys[type];
    8518:	b2ce      	uxtb	r6, r1
	if ((data != NULL)
    851a:	b14a      	cbz	r2, 8530 <clock_async_start+0x26>
	sys_snode_t *item = sys_slist_peek_head(list);
    851c:	230c      	movs	r3, #12
    851e:	4373      	muls	r3, r6
    8520:	f85c 3003 	ldr.w	r3, [ip, r3]
		if (item == node) {
    8524:	429a      	cmp	r2, r3
    8526:	d05b      	beq.n	85e0 <clock_async_start+0xd6>
Z_GENLIST_PEEK_NEXT(slist, snode)
    8528:	b113      	cbz	r3, 8530 <clock_async_start+0x26>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    852a:	681b      	ldr	r3, [r3, #0]
	} while (item);
    852c:	2b00      	cmp	r3, #0
    852e:	d1f9      	bne.n	8524 <clock_async_start+0x1a>
	__asm__ volatile(
    8530:	f04f 0320 	mov.w	r3, #32
    8534:	f3ef 8011 	mrs	r0, BASEPRI
    8538:	f383 8811 	msr	BASEPRI, r3
    853c:	f3bf 8f6f 	isb	sy
	ref = ++clk_data->ref;
    8540:	210c      	movs	r1, #12
    8542:	4371      	muls	r1, r6
    8544:	eb0c 0301 	add.w	r3, ip, r1
    8548:	7a1c      	ldrb	r4, [r3, #8]
    854a:	3401      	adds	r4, #1
    854c:	b2e4      	uxtb	r4, r4
    854e:	721c      	strb	r4, [r3, #8]
	__asm__ volatile(
    8550:	f380 8811 	msr	BASEPRI, r0
    8554:	f3bf 8f6f 	isb	sy
	if (data) {
    8558:	b332      	cbz	r2, 85a8 <clock_async_start+0x9e>
    p_reg->INTENCLR = mask;
    855a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
    855e:	f04f 0e03 	mov.w	lr, #3
    8562:	f8c0 e308 	str.w	lr, [r0, #776]	; 0x308
		already_started = clk_data->started;
    8566:	7a58      	ldrb	r0, [r3, #9]
		if (!already_started) {
    8568:	b9a0      	cbnz	r0, 8594 <clock_async_start+0x8a>
	__asm__ volatile(
    856a:	f04f 0e20 	mov.w	lr, #32
    856e:	f3ef 8811 	mrs	r8, BASEPRI
    8572:	f38e 8811 	msr	BASEPRI, lr
    8576:	f3bf 8f6f 	isb	sy
	parent->next = child;
    857a:	6010      	str	r0, [r2, #0]
Z_GENLIST_APPEND(slist, snode)
    857c:	f8d3 e004 	ldr.w	lr, [r3, #4]
    8580:	f1be 0f00 	cmp.w	lr, #0
    8584:	d11f      	bne.n	85c6 <clock_async_start+0xbc>
	list->tail = node;
    8586:	605a      	str	r2, [r3, #4]
	list->head = node;
    8588:	f84c 2001 	str.w	r2, [ip, r1]
	__asm__ volatile(
    858c:	f388 8811 	msr	BASEPRI, r8
    8590:	f3bf 8f6f 	isb	sy
    p_reg->INTENSET = mask;
    8594:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    8598:	2103      	movs	r1, #3
    859a:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304
		if (already_started) {
    859e:	b118      	cbz	r0, 85a8 <clock_async_start+0x9e>
			data->cb(dev, data->user_data);
    85a0:	e9d2 3101 	ldrd	r3, r1, [r2, #4]
    85a4:	4628      	mov	r0, r5
    85a6:	4798      	blx	r3
	if (ref == 1) {
    85a8:	2c01      	cmp	r4, #1
    85aa:	d10a      	bne.n	85c2 <clock_async_start+0xb8>
		do_start =  (config->start_handler) ?
    85ac:	ea4f 1806 	mov.w	r8, r6, lsl #4
    85b0:	f857 3008 	ldr.w	r3, [r7, r8]
				config->start_handler(dev) : true;
    85b4:	b95b      	cbnz	r3, 85ce <clock_async_start+0xc4>
			nrf_clock_task_trigger(NRF_CLOCK,
    85b6:	4447      	add	r7, r8
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    85b8:	2201      	movs	r2, #1
    85ba:	7abb      	ldrb	r3, [r7, #10]
    85bc:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    85c0:	601a      	str	r2, [r3, #0]
	return 0;
    85c2:	2000      	movs	r0, #0
    85c4:	e00e      	b.n	85e4 <clock_async_start+0xda>
	parent->next = child;
    85c6:	f8ce 2000 	str.w	r2, [lr]
	list->tail = node;
    85ca:	605a      	str	r2, [r3, #4]
    85cc:	e7de      	b.n	858c <clock_async_start+0x82>
				config->start_handler(dev) : true;
    85ce:	4628      	mov	r0, r5
    85d0:	4798      	blx	r3
    85d2:	2800      	cmp	r0, #0
    85d4:	d1ef      	bne.n	85b6 <clock_async_start+0xac>
			clkstarted_handle(dev, type);
    85d6:	4631      	mov	r1, r6
    85d8:	4628      	mov	r0, r5
    85da:	f7ff ff73 	bl	84c4 <clkstarted_handle>
    85de:	e7f0      	b.n	85c2 <clock_async_start+0xb8>
		return -EBUSY;
    85e0:	f06f 000f 	mvn.w	r0, #15
}
    85e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000085e8 <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
    85e8:	2200      	movs	r2, #0
    85ea:	f7ff bf8e 	b.w	850a <clock_async_start>

000085ee <clk_init>:
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
    85ee:	2200      	movs	r2, #0
{
    85f0:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
    85f2:	2101      	movs	r1, #1
{
    85f4:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
    85f6:	4610      	mov	r0, r2
    85f8:	f7f8 fe08 	bl	120c <z_arm_irq_priority_set>
	irq_enable(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0);
    85fc:	2000      	movs	r0, #0
    85fe:	f7f8 fdf5 	bl	11ec <arch_irq_enable>
}

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->LFCLKSRC = (uint32_t)(source);
    8602:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    8606:	2201      	movs	r2, #1
    8608:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    p_reg->INTENSET = mask;
    860c:	2203      	movs	r2, #3
    860e:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		sys_slist_init(&(get_sub_data(dev, i)->list));
    8612:	68a3      	ldr	r3, [r4, #8]
	list->head = NULL;
    8614:	2000      	movs	r0, #0
	list->tail = NULL;
    8616:	e9c3 0000 	strd	r0, r0, [r3]
    861a:	68a3      	ldr	r3, [r4, #8]
    861c:	e9c3 0003 	strd	r0, r0, [r3, #12]
}
    8620:	bd10      	pop	{r4, pc}

00008622 <clock_stop>:
	const struct nrf_clock_control_config *config =
    8622:	6802      	ldr	r2, [r0, #0]
{
    8624:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	const struct nrf_clock_control_config *config =
    8628:	f8d2 8008 	ldr.w	r8, [r2, #8]
	data = get_sub_data(dev, type);
    862c:	6887      	ldr	r7, [r0, #8]
    862e:	b2cc      	uxtb	r4, r1
	__asm__ volatile(
    8630:	f04f 0320 	mov.w	r3, #32
    8634:	f3ef 8611 	mrs	r6, BASEPRI
    8638:	f383 8811 	msr	BASEPRI, r3
    863c:	f3bf 8f6f 	isb	sy
	if (data->ref == 0) {
    8640:	220c      	movs	r2, #12
    8642:	4362      	muls	r2, r4
    8644:	18b9      	adds	r1, r7, r2
    8646:	7a0b      	ldrb	r3, [r1, #8]
    8648:	b343      	cbz	r3, 869c <clock_stop+0x7a>
	data->ref--;
    864a:	3b01      	subs	r3, #1
    864c:	b2db      	uxtb	r3, r3
    864e:	720b      	strb	r3, [r1, #8]
	if (data->ref == 0) {
    8650:	bb3b      	cbnz	r3, 86a2 <clock_stop+0x80>
		do_stop =  (config->stop_handler) ?
    8652:	0125      	lsls	r5, r4, #4
	list->head = NULL;
    8654:	50bb      	str	r3, [r7, r2]
	list->tail = NULL;
    8656:	604b      	str	r3, [r1, #4]
    8658:	eb08 0305 	add.w	r3, r8, r5
    865c:	685b      	ldr	r3, [r3, #4]
				config->stop_handler(dev) : true;
    865e:	b9cb      	cbnz	r3, 8694 <clock_stop+0x72>
			nrf_clock_task_trigger(NRF_CLOCK, config->stop_tsk);
    8660:	4445      	add	r5, r8
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    8662:	2201      	movs	r2, #1
    8664:	7aeb      	ldrb	r3, [r5, #11]
    8666:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    866a:	601a      	str	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    866c:	892b      	ldrh	r3, [r5, #8]
    866e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    8672:	2200      	movs	r2, #0
    8674:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    8676:	681b      	ldr	r3, [r3, #0]
    8678:	9301      	str	r3, [sp, #4]
    (void)dummy;
    867a:	9b01      	ldr	r3, [sp, #4]
		data->started = false;
    867c:	210c      	movs	r1, #12
    867e:	fb01 7404 	mla	r4, r1, r4, r7
    8682:	2000      	movs	r0, #0
    8684:	7260      	strb	r0, [r4, #9]
	__asm__ volatile(
    8686:	f386 8811 	msr	BASEPRI, r6
    868a:	f3bf 8f6f 	isb	sy
}
    868e:	b002      	add	sp, #8
    8690:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				config->stop_handler(dev) : true;
    8694:	4798      	blx	r3
    8696:	2800      	cmp	r0, #0
    8698:	d1e2      	bne.n	8660 <clock_stop+0x3e>
    869a:	e7ef      	b.n	867c <clock_stop+0x5a>
		err = -EALREADY;
    869c:	f06f 0044 	mvn.w	r0, #68	; 0x44
    86a0:	e7f1      	b.n	8686 <clock_stop+0x64>
	int err = 0;
    86a2:	2000      	movs	r0, #0
    86a4:	e7ef      	b.n	8686 <clock_stop+0x64>

000086a6 <st7789v_read>:
}
    86a6:	f06f 0022 	mvn.w	r0, #34	; 0x22
    86aa:	4770      	bx	lr

000086ac <st7789v_get_framebuffer>:
}
    86ac:	2000      	movs	r0, #0
    86ae:	4770      	bx	lr

000086b0 <st7789v_set_brightness>:
}
    86b0:	f06f 0022 	mvn.w	r0, #34	; 0x22
    86b4:	4770      	bx	lr

000086b6 <k_sleep>:
	return z_impl_k_sleep(ms);
    86b6:	f7ff b9bf 	b.w	7a38 <z_impl_k_sleep>

000086ba <st7789v_get_capabilities>:
{
    86ba:	b538      	push	{r3, r4, r5, lr}
    86bc:	460c      	mov	r4, r1
	struct st7789v_data *data = (struct st7789v_data *)dev->driver_data;
    86be:	6885      	ldr	r5, [r0, #8]
	memset(capabilities, 0, sizeof(struct display_capabilities));
    86c0:	2210      	movs	r2, #16
    86c2:	2100      	movs	r1, #0
    86c4:	4620      	mov	r0, r4
    86c6:	f000 f93d 	bl	8944 <memset>
	capabilities->x_resolution = data->width;
    86ca:	8ceb      	ldrh	r3, [r5, #38]	; 0x26
    86cc:	8023      	strh	r3, [r4, #0]
	capabilities->y_resolution = data->height;
    86ce:	8cab      	ldrh	r3, [r5, #36]	; 0x24
    86d0:	8063      	strh	r3, [r4, #2]
	capabilities->supported_pixel_formats = PIXEL_FORMAT_RGB_565;
    86d2:	2310      	movs	r3, #16
    86d4:	6063      	str	r3, [r4, #4]
	capabilities->current_pixel_format = PIXEL_FORMAT_RGB_565;
    86d6:	81a3      	strh	r3, [r4, #12]
}
    86d8:	bd38      	pop	{r3, r4, r5, pc}

000086da <gpio_pin_write>:
 * @param value Value set on the pin.
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_write(struct device *port, u32_t pin,
				 u32_t value)
{
    86da:	b410      	push	{r4}
    86dc:	4613      	mov	r3, r2
	return api->write(port, access_op, pin, value);
    86de:	6842      	ldr	r2, [r0, #4]
    86e0:	6854      	ldr	r4, [r2, #4]
    86e2:	460a      	mov	r2, r1
    86e4:	46a4      	mov	ip, r4
    86e6:	2100      	movs	r1, #0
	return gpio_write(port, GPIO_ACCESS_BY_PIN, pin, value);
}
    86e8:	bc10      	pop	{r4}
	return api->write(port, access_op, pin, value);
    86ea:	4760      	bx	ip

000086ec <st7789v_set_contrast>:
    86ec:	f06f 0022 	mvn.w	r0, #34	; 0x22
    86f0:	4770      	bx	lr

000086f2 <st7789v_transmit>:
{
    86f2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    86f6:	4605      	mov	r5, r0
    86f8:	b087      	sub	sp, #28
    86fa:	4698      	mov	r8, r3
	spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
    86fc:	462c      	mov	r4, r5
	struct spi_buf tx_buf = { .buf = &cmd, .len = 1 };
    86fe:	f10d 0307 	add.w	r3, sp, #7
{
    8702:	f88d 1007 	strb.w	r1, [sp, #7]
	struct spi_buf tx_buf = { .buf = &cmd, .len = 1 };
    8706:	9302      	str	r3, [sp, #8]
    8708:	2601      	movs	r6, #1
	struct spi_buf_set tx_bufs = { .buffers = &tx_buf, .count = 1 };
    870a:	ab02      	add	r3, sp, #8
{
    870c:	4617      	mov	r7, r2
	gpio_pin_write(data->cmd_data_gpio, ST7789V_CMD_DATA_PIN, !is_cmd);
    870e:	2112      	movs	r1, #18
    8710:	2200      	movs	r2, #0
    8712:	6a00      	ldr	r0, [r0, #32]
	struct spi_buf tx_buf = { .buf = &cmd, .len = 1 };
    8714:	9603      	str	r6, [sp, #12]
	struct spi_buf_set tx_bufs = { .buffers = &tx_buf, .count = 1 };
    8716:	e9cd 3604 	strd	r3, r6, [sp, #16]
	gpio_pin_write(data->cmd_data_gpio, ST7789V_CMD_DATA_PIN, !is_cmd);
    871a:	f7ff ffde 	bl	86da <gpio_pin_write>
	spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
    871e:	f854 0b04 	ldr.w	r0, [r4], #4
				       const struct spi_buf_set *rx_bufs)
{
	const struct spi_driver_api *api =
		(const struct spi_driver_api *)dev->driver_api;

	return api->transceive(dev, config, tx_bufs, rx_bufs);
    8722:	6843      	ldr	r3, [r0, #4]
    8724:	aa04      	add	r2, sp, #16
    8726:	f8d3 9000 	ldr.w	r9, [r3]
    872a:	4621      	mov	r1, r4
    872c:	2300      	movs	r3, #0
    872e:	47c8      	blx	r9
	if (tx_data != NULL) {
    8730:	b16f      	cbz	r7, 874e <st7789v_transmit+0x5c>
	gpio_pin_write(data->cmd_data_gpio, ST7789V_CMD_DATA_PIN, !is_cmd);
    8732:	4632      	mov	r2, r6
    8734:	2112      	movs	r1, #18
    8736:	6a28      	ldr	r0, [r5, #32]
		tx_buf.len = tx_count;
    8738:	e9cd 7802 	strd	r7, r8, [sp, #8]
	gpio_pin_write(data->cmd_data_gpio, ST7789V_CMD_DATA_PIN, !is_cmd);
    873c:	f7ff ffcd 	bl	86da <gpio_pin_write>
		spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
    8740:	6828      	ldr	r0, [r5, #0]
    8742:	6843      	ldr	r3, [r0, #4]
    8744:	aa04      	add	r2, sp, #16
    8746:	681d      	ldr	r5, [r3, #0]
    8748:	4621      	mov	r1, r4
    874a:	2300      	movs	r3, #0
    874c:	47a8      	blx	r5
}
    874e:	b007      	add	sp, #28
    8750:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00008754 <st7789v_blanking_on>:
{
    8754:	b508      	push	{r3, lr}
	st7789v_transmit(driver, ST7789V_CMD_DISP_OFF, NULL, 0);
    8756:	2300      	movs	r3, #0
    8758:	461a      	mov	r2, r3
    875a:	2128      	movs	r1, #40	; 0x28
    875c:	6880      	ldr	r0, [r0, #8]
    875e:	f7ff ffc8 	bl	86f2 <st7789v_transmit>
}
    8762:	2000      	movs	r0, #0
    8764:	bd08      	pop	{r3, pc}

00008766 <st7789v_blanking_off>:
{
    8766:	b508      	push	{r3, lr}
	st7789v_transmit(driver, ST7789V_CMD_DISP_ON, NULL, 0);
    8768:	2300      	movs	r3, #0
    876a:	461a      	mov	r2, r3
    876c:	2129      	movs	r1, #41	; 0x29
    876e:	6880      	ldr	r0, [r0, #8]
    8770:	f7ff ffbf 	bl	86f2 <st7789v_transmit>
}
    8774:	2000      	movs	r0, #0
    8776:	bd08      	pop	{r3, pc}

00008778 <st7789v_write>:
{
    8778:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct st7789v_data *data = (struct st7789v_data *)dev->driver_data;
    877c:	6885      	ldr	r5, [r0, #8]
	u16_t ram_x = x + data->x_offset;
    877e:	8d28      	ldrh	r0, [r5, #40]	; 0x28
	u16_t ram_y = y + data->y_offset;
    8780:	f8b5 802a 	ldrh.w	r8, [r5, #42]	; 0x2a
{
    8784:	461c      	mov	r4, r3
	st7789v_set_mem_area(data, x, y, desc->width, desc->height);
    8786:	889b      	ldrh	r3, [r3, #4]
    8788:	88e6      	ldrh	r6, [r4, #6]
	u16_t ram_x = x + data->x_offset;
    878a:	4401      	add	r1, r0
    878c:	b289      	uxth	r1, r1
	spi_data[1] = sys_cpu_to_be16(ram_x + w - 1);
    878e:	3b01      	subs	r3, #1
{
    8790:	b085      	sub	sp, #20
	spi_data[1] = sys_cpu_to_be16(ram_x + w - 1);
    8792:	440b      	add	r3, r1
	u16_t ram_y = y + data->y_offset;
    8794:	4490      	add	r8, r2
	spi_data[1] = sys_cpu_to_be16(ram_x + w - 1);
    8796:	ba5b      	rev16	r3, r3
	spi_data[0] = sys_cpu_to_be16(ram_x);
    8798:	ba4a      	rev16	r2, r1
	u16_t ram_y = y + data->y_offset;
    879a:	fa1f f888 	uxth.w	r8, r8
	spi_data[0] = sys_cpu_to_be16(ram_x);
    879e:	f8ad 2008 	strh.w	r2, [sp, #8]
	spi_data[1] = sys_cpu_to_be16(ram_x + w - 1);
    87a2:	f8ad 300a 	strh.w	r3, [sp, #10]
	st7789v_transmit(data, ST7789V_CMD_CASET, (u8_t *)&spi_data[0], 4);
    87a6:	aa02      	add	r2, sp, #8
    87a8:	2304      	movs	r3, #4
    87aa:	212a      	movs	r1, #42	; 0x2a
    87ac:	4628      	mov	r0, r5
	spi_data[1] = sys_cpu_to_be16(ram_y + h - 1);
    87ae:	3e01      	subs	r6, #1
{
    87b0:	9f0e      	ldr	r7, [sp, #56]	; 0x38
	spi_data[1] = sys_cpu_to_be16(ram_y + h - 1);
    87b2:	4446      	add	r6, r8
	st7789v_transmit(data, ST7789V_CMD_CASET, (u8_t *)&spi_data[0], 4);
    87b4:	f7ff ff9d 	bl	86f2 <st7789v_transmit>
	spi_data[0] = sys_cpu_to_be16(ram_y);
    87b8:	fa98 f398 	rev16.w	r3, r8
    87bc:	f8ad 3008 	strh.w	r3, [sp, #8]
	spi_data[1] = sys_cpu_to_be16(ram_y + h - 1);
    87c0:	ba76      	rev16	r6, r6
	st7789v_transmit(data, ST7789V_CMD_RASET, (u8_t *)&spi_data[0], 4);
    87c2:	2304      	movs	r3, #4
    87c4:	aa02      	add	r2, sp, #8
    87c6:	212b      	movs	r1, #43	; 0x2b
    87c8:	4628      	mov	r0, r5
	spi_data[1] = sys_cpu_to_be16(ram_y + h - 1);
    87ca:	f8ad 600a 	strh.w	r6, [sp, #10]
	st7789v_transmit(data, ST7789V_CMD_RASET, (u8_t *)&spi_data[0], 4);
    87ce:	f7ff ff90 	bl	86f2 <st7789v_transmit>
	if (desc->pitch > desc->width) {
    87d2:	88a3      	ldrh	r3, [r4, #4]
    87d4:	8922      	ldrh	r2, [r4, #8]
    87d6:	88e6      	ldrh	r6, [r4, #6]
		nbr_of_writes = desc->height;
    87d8:	429a      	cmp	r2, r3
    87da:	bf84      	itt	hi
    87dc:	46b1      	movhi	r9, r6
    87de:	2601      	movhi	r6, #1
	st7789v_transmit(data, ST7789V_CMD_RAMWR,
    87e0:	fb06 f303 	mul.w	r3, r6, r3
    87e4:	ea4f 0343 	mov.w	r3, r3, lsl #1
    87e8:	463a      	mov	r2, r7
    87ea:	f04f 012c 	mov.w	r1, #44	; 0x2c
    87ee:	4628      	mov	r0, r5
		nbr_of_writes = desc->height;
    87f0:	bf98      	it	ls
    87f2:	f04f 0901 	movls.w	r9, #1
	st7789v_transmit(data, ST7789V_CMD_RAMWR,
    87f6:	f7ff ff7c 	bl	86f2 <st7789v_transmit>
	tx_bufs.count = 1;
    87fa:	2301      	movs	r3, #1
    87fc:	9303      	str	r3, [sp, #12]
	write_data_start += (desc->pitch * ST7789V_PIXEL_SIZE);
    87fe:	8923      	ldrh	r3, [r4, #8]
	tx_bufs.buffers = &tx_buf;
    8800:	f8cd d008 	str.w	sp, [sp, #8]
	write_data_start += (desc->pitch * ST7789V_PIXEL_SIZE);
    8804:	eb07 0743 	add.w	r7, r7, r3, lsl #1
	for (write_cnt = 1U; write_cnt < nbr_of_writes; ++write_cnt) {
    8808:	f04f 0800 	mov.w	r8, #0
		spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
    880c:	f105 0a04 	add.w	sl, r5, #4
    8810:	f108 0801 	add.w	r8, r8, #1
	for (write_cnt = 1U; write_cnt < nbr_of_writes; ++write_cnt) {
    8814:	fa1f f388 	uxth.w	r3, r8
    8818:	4599      	cmp	r9, r3
    881a:	d803      	bhi.n	8824 <st7789v_write+0xac>
}
    881c:	2000      	movs	r0, #0
    881e:	b005      	add	sp, #20
    8820:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		tx_buf.len = desc->width * ST7789V_PIXEL_SIZE * write_h;
    8824:	88a3      	ldrh	r3, [r4, #4]
		tx_buf.buf = (void *)write_data_start;
    8826:	9700      	str	r7, [sp, #0]
		tx_buf.len = desc->width * ST7789V_PIXEL_SIZE * write_h;
    8828:	4373      	muls	r3, r6
    882a:	005b      	lsls	r3, r3, #1
    882c:	9301      	str	r3, [sp, #4]
		spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
    882e:	6828      	ldr	r0, [r5, #0]
    8830:	6843      	ldr	r3, [r0, #4]
    8832:	aa02      	add	r2, sp, #8
    8834:	f8d3 b000 	ldr.w	fp, [r3]
    8838:	4651      	mov	r1, sl
    883a:	2300      	movs	r3, #0
    883c:	47d8      	blx	fp
		write_data_start += (desc->pitch * ST7789V_PIXEL_SIZE);
    883e:	8923      	ldrh	r3, [r4, #8]
    8840:	eb07 0743 	add.w	r7, r7, r3, lsl #1
    8844:	e7e4      	b.n	8810 <st7789v_write+0x98>

00008846 <z_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
    8846:	4770      	bx	lr

00008848 <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
    8848:	4770      	bx	lr

0000884a <z_irq_spurious>:
 * @return N/A
 */
void z_irq_spurious(void *unused)
{
	ARG_UNUSED(unused);
	z_arm_reserved();
    884a:	f7f8 bd43 	b.w	12d4 <z_arm_bus_fault>

0000884e <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
    884e:	4601      	mov	r1, r0
			reason = K_ERR_KERNEL_OOPS;
		}
	}

#endif /* CONFIG_USERSPACE */
	z_arm_fatal_error(reason, esf);
    8850:	6800      	ldr	r0, [r0, #0]
    8852:	f7f8 bd49 	b.w	12e8 <z_arm_fatal_error>

00008856 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
    8856:	b508      	push	{r3, lr}
	handler();
    8858:	f7f8 fd98 	bl	138c <z_SysNmiOnReset>
	z_arm_exc_exit();
}
    885c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_exc_exit();
    8860:	f7f8 bc62 	b.w	1128 <z_arm_exc_exit>

00008864 <z_arm_configure_dynamic_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_dynamic_mpu_regions(struct k_thread *thread)
{
    8864:	b507      	push	{r0, r1, r2, lr}

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(
    8866:	2100      	movs	r1, #0
    8868:	a801      	add	r0, sp, #4
    886a:	f7f9 f971 	bl	1b50 <arm_core_mpu_configure_dynamic_mpu_regions>
		(const struct k_mem_partition **)dynamic_regions,
		region_num);
}
    886e:	b003      	add	sp, #12
    8870:	f85d fb04 	ldr.w	pc, [sp], #4

00008874 <strcpy>:

char *strcpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
    8874:	3901      	subs	r1, #1
    8876:	4603      	mov	r3, r0
    8878:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    887c:	b90a      	cbnz	r2, 8882 <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
    887e:	701a      	strb	r2, [r3, #0]

	return dest;
}
    8880:	4770      	bx	lr
		*d = *s;
    8882:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
    8886:	e7f7      	b.n	8878 <strcpy+0x4>

00008888 <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
    8888:	b570      	push	{r4, r5, r6, lr}
    888a:	3901      	subs	r1, #1
    888c:	4605      	mov	r5, r0
    888e:	462c      	mov	r4, r5
	char *dest = d;

	while ((n > 0) && *s != '\0') {
    8890:	b142      	cbz	r2, 88a4 <strncpy+0x1c>
    8892:	f811 3f01 	ldrb.w	r3, [r1, #1]!
    8896:	1e56      	subs	r6, r2, #1
    8898:	b92b      	cbnz	r3, 88a6 <strncpy+0x1e>
    889a:	442a      	add	r2, r5
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
    889c:	f804 3b01 	strb.w	r3, [r4], #1
	while (n > 0) {
    88a0:	42a2      	cmp	r2, r4
    88a2:	d1fb      	bne.n	889c <strncpy+0x14>
		d++;
		n--;
	}

	return dest;
}
    88a4:	bd70      	pop	{r4, r5, r6, pc}
		*d = *s;
    88a6:	f805 3b01 	strb.w	r3, [r5], #1
		n--;
    88aa:	4632      	mov	r2, r6
    88ac:	e7ef      	b.n	888e <strncpy+0x6>

000088ae <strchr>:
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
	char tmp = (char) c;
    88ae:	b2c9      	uxtb	r1, r1

	while ((*s != tmp) && (*s != '\0')) {
    88b0:	7802      	ldrb	r2, [r0, #0]
    88b2:	428a      	cmp	r2, r1
    88b4:	4603      	mov	r3, r0
    88b6:	f100 0001 	add.w	r0, r0, #1
    88ba:	d004      	beq.n	88c6 <strchr+0x18>
    88bc:	2a00      	cmp	r2, #0
    88be:	d1f7      	bne.n	88b0 <strchr+0x2>
		s++;
	}

	return (*s == tmp) ? (char *) s : NULL;
    88c0:	2900      	cmp	r1, #0
    88c2:	bf18      	it	ne
    88c4:	2300      	movne	r3, #0
}
    88c6:	4618      	mov	r0, r3
    88c8:	4770      	bx	lr

000088ca <strlen>:
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
	size_t n = 0;
    88ca:	2300      	movs	r3, #0

	while (*s != '\0') {
    88cc:	5cc2      	ldrb	r2, [r0, r3]
    88ce:	b90a      	cbnz	r2, 88d4 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
    88d0:	4618      	mov	r0, r3
    88d2:	4770      	bx	lr
		n++;
    88d4:	3301      	adds	r3, #1
    88d6:	e7f9      	b.n	88cc <strlen+0x2>

000088d8 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
    88d8:	3801      	subs	r0, #1
    88da:	3901      	subs	r1, #1
    88dc:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    88e0:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    88e4:	4293      	cmp	r3, r2
    88e6:	d101      	bne.n	88ec <strcmp+0x14>
    88e8:	2b00      	cmp	r3, #0
    88ea:	d1f7      	bne.n	88dc <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
    88ec:	1a98      	subs	r0, r3, r2
    88ee:	4770      	bx	lr

000088f0 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
    88f0:	b5f0      	push	{r4, r5, r6, r7, lr}

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
    88f2:	ea81 0400 	eor.w	r4, r1, r0
    88f6:	07a5      	lsls	r5, r4, #30
    88f8:	4603      	mov	r3, r0
    88fa:	d00b      	beq.n	8914 <memcpy+0x24>
    88fc:	3b01      	subs	r3, #1
    88fe:	440a      	add	r2, r1
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
    8900:	4291      	cmp	r1, r2
    8902:	d11a      	bne.n	893a <memcpy+0x4a>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
    8904:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (n == 0) {
    8906:	2a00      	cmp	r2, #0
    8908:	d0fc      	beq.n	8904 <memcpy+0x14>
			*(d_byte++) = *(s_byte++);
    890a:	f811 4b01 	ldrb.w	r4, [r1], #1
    890e:	f803 4b01 	strb.w	r4, [r3], #1
			n--;
    8912:	3a01      	subs	r2, #1
		while (((uintptr_t)d_byte) & mask) {
    8914:	079c      	lsls	r4, r3, #30
    8916:	d1f6      	bne.n	8906 <memcpy+0x16>
    8918:	0895      	lsrs	r5, r2, #2
    891a:	00ac      	lsls	r4, r5, #2
    891c:	1f1e      	subs	r6, r3, #4
    891e:	190f      	adds	r7, r1, r4
		while (n >= sizeof(mem_word_t)) {
    8920:	42b9      	cmp	r1, r7
    8922:	d105      	bne.n	8930 <memcpy+0x40>
    8924:	f06f 0603 	mvn.w	r6, #3
    8928:	fb06 2205 	mla	r2, r6, r5, r2
    892c:	4423      	add	r3, r4
    892e:	e7e5      	b.n	88fc <memcpy+0xc>
			*(d_word++) = *(s_word++);
    8930:	f851 cb04 	ldr.w	ip, [r1], #4
    8934:	f846 cf04 	str.w	ip, [r6, #4]!
			n -= sizeof(mem_word_t);
    8938:	e7f2      	b.n	8920 <memcpy+0x30>
		*(d_byte++) = *(s_byte++);
    893a:	f811 4b01 	ldrb.w	r4, [r1], #1
    893e:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
    8942:	e7dd      	b.n	8900 <memcpy+0x10>

00008944 <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
    8944:	b570      	push	{r4, r5, r6, lr}
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    8946:	b2c9      	uxtb	r1, r1
	unsigned char *d_byte = (unsigned char *)buf;
    8948:	4603      	mov	r3, r0

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
    894a:	079c      	lsls	r4, r3, #30
    894c:	d110      	bne.n	8970 <memset+0x2c>
	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;

	c_word |= c_word << 8;
    894e:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
	c_word |= c_word << 16;
    8952:	ea44 4504 	orr.w	r5, r4, r4, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
    8956:	0894      	lsrs	r4, r2, #2
    8958:	eb03 0684 	add.w	r6, r3, r4, lsl #2
    895c:	42b3      	cmp	r3, r6
    895e:	d10d      	bne.n	897c <memset+0x38>
    8960:	f06f 0503 	mvn.w	r5, #3
    8964:	fb05 2404 	mla	r4, r5, r4, r2
    8968:	441c      	add	r4, r3

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
    896a:	42a3      	cmp	r3, r4
    896c:	d109      	bne.n	8982 <memset+0x3e>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
    896e:	bd70      	pop	{r4, r5, r6, pc}
		if (n == 0) {
    8970:	2a00      	cmp	r2, #0
    8972:	d0fc      	beq.n	896e <memset+0x2a>
		*(d_byte++) = c_byte;
    8974:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
    8978:	3a01      	subs	r2, #1
    897a:	e7e6      	b.n	894a <memset+0x6>
		*(d_word++) = c_word;
    897c:	f843 5b04 	str.w	r5, [r3], #4
		n -= sizeof(mem_word_t);
    8980:	e7ec      	b.n	895c <memset+0x18>
		*(d_byte++) = c_byte;
    8982:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
    8986:	e7f0      	b.n	896a <memset+0x26>

00008988 <_to_x>:
{
    8988:	b5f0      	push	{r4, r5, r6, r7, lr}
    898a:	4603      	mov	r3, r0
		unsigned int d = n % base;
    898c:	fbb1 f7f2 	udiv	r7, r1, r2
    8990:	fb02 1517 	mls	r5, r2, r7, r1
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
    8994:	2d09      	cmp	r5, #9
    8996:	bf8c      	ite	hi
    8998:	2627      	movhi	r6, #39	; 0x27
    899a:	2600      	movls	r6, #0
    899c:	461c      	mov	r4, r3
    899e:	3530      	adds	r5, #48	; 0x30
    89a0:	4435      	add	r5, r6
	} while (n);
    89a2:	4291      	cmp	r1, r2
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
    89a4:	f804 5b01 	strb.w	r5, [r4], #1
	} while (n);
    89a8:	d206      	bcs.n	89b8 <_to_x+0x30>
	*buf = 0;
    89aa:	2200      	movs	r2, #0
    89ac:	7022      	strb	r2, [r4, #0]
	len = buf - start;
    89ae:	1a24      	subs	r4, r4, r0
	for (buf--; buf > start; buf--, start++) {
    89b0:	4283      	cmp	r3, r0
    89b2:	d804      	bhi.n	89be <_to_x+0x36>
}
    89b4:	4620      	mov	r0, r4
    89b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		n /= base;
    89b8:	4639      	mov	r1, r7
    89ba:	4623      	mov	r3, r4
    89bc:	e7e6      	b.n	898c <_to_x+0x4>
		char tmp = *buf;
    89be:	781a      	ldrb	r2, [r3, #0]
		*buf = *start;
    89c0:	7801      	ldrb	r1, [r0, #0]
    89c2:	f803 1901 	strb.w	r1, [r3], #-1
		*start = tmp;
    89c6:	f800 2b01 	strb.w	r2, [r0], #1
    89ca:	e7f1      	b.n	89b0 <_to_x+0x28>

000089cc <_rlrshift>:
{
    89cc:	b570      	push	{r4, r5, r6, lr}
	*v = (*v & 1) + (*v >> 1);
    89ce:	e9d0 6500 	ldrd	r6, r5, [r0]
    89d2:	0872      	lsrs	r2, r6, #1
    89d4:	f006 0301 	and.w	r3, r6, #1
    89d8:	ea42 72c5 	orr.w	r2, r2, r5, lsl #31
    89dc:	189b      	adds	r3, r3, r2
    89de:	f04f 0100 	mov.w	r1, #0
    89e2:	ea4f 0455 	mov.w	r4, r5, lsr #1
    89e6:	eb44 0101 	adc.w	r1, r4, r1
    89ea:	e9c0 3100 	strd	r3, r1, [r0]
}
    89ee:	bd70      	pop	{r4, r5, r6, pc}

000089f0 <_ldiv5>:
	uint64_t rem = *v, quot = 0U, q;
    89f0:	e9d0 3200 	ldrd	r3, r2, [r0]
{
    89f4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	rem += 2U;
    89f8:	3302      	adds	r3, #2
		q = (uint64_t)(hi / 5U) << shifts[i];
    89fa:	f04f 0705 	mov.w	r7, #5
    89fe:	f04f 0c00 	mov.w	ip, #0
	rem += 2U;
    8a02:	f142 0200 	adc.w	r2, r2, #0
		rem -= q * 5U;
    8a06:	ebb3 060c 	subs.w	r6, r3, ip
		q = (uint64_t)(hi / 5U) << shifts[i];
    8a0a:	fbb2 fef7 	udiv	lr, r2, r7
		rem -= q * 5U;
    8a0e:	fb07 f10e 	mul.w	r1, r7, lr
    8a12:	eb62 0101 	sbc.w	r1, r2, r1
		hi = rem >> shifts[i];
    8a16:	08f2      	lsrs	r2, r6, #3
    8a18:	ea42 7241 	orr.w	r2, r2, r1, lsl #29
		q = (uint64_t)(hi / 5U) << shifts[i];
    8a1c:	fbb2 f1f7 	udiv	r1, r2, r7
    8a20:	00ca      	lsls	r2, r1, #3
		quot += q;
    8a22:	eb1c 0802 	adds.w	r8, ip, r2
		q = (uint64_t)(hi / 5U) << shifts[i];
    8a26:	ea4f 7351 	mov.w	r3, r1, lsr #29
		quot += q;
    8a2a:	eb4e 0903 	adc.w	r9, lr, r3
		rem -= q * 5U;
    8a2e:	fba2 2307 	umull	r2, r3, r2, r7
    8a32:	1ab3      	subs	r3, r6, r2
		q = (uint64_t)(hi / 5U) << shifts[i];
    8a34:	fbb3 f3f7 	udiv	r3, r3, r7
		quot += q;
    8a38:	eb18 0403 	adds.w	r4, r8, r3
    8a3c:	f149 0500 	adc.w	r5, r9, #0
	*v = quot;
    8a40:	e9c0 4500 	strd	r4, r5, [r0]
}
    8a44:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00008a48 <_get_digit>:
	if (*digit_count > 0) {
    8a48:	680b      	ldr	r3, [r1, #0]
    8a4a:	2b00      	cmp	r3, #0
{
    8a4c:	b570      	push	{r4, r5, r6, lr}
	if (*digit_count > 0) {
    8a4e:	dd10      	ble.n	8a72 <_get_digit+0x2a>
		*digit_count -= 1;
    8a50:	3b01      	subs	r3, #1
		*fr = *fr * 10U;
    8a52:	6802      	ldr	r2, [r0, #0]
		*digit_count -= 1;
    8a54:	600b      	str	r3, [r1, #0]
		*fr = *fr * 10U;
    8a56:	6844      	ldr	r4, [r0, #4]
    8a58:	210a      	movs	r1, #10
    8a5a:	fba2 5601 	umull	r5, r6, r2, r1
    8a5e:	fb01 6604 	mla	r6, r1, r4, r6
		*fr &= 0x0FFFFFFFFFFFFFFFull;
    8a62:	f026 4370 	bic.w	r3, r6, #4026531840	; 0xf0000000
    8a66:	e9c0 5300 	strd	r5, r3, [r0]
		rval = ((*fr >> 60) & 0xF) + '0';
    8a6a:	0f31      	lsrs	r1, r6, #28
    8a6c:	3130      	adds	r1, #48	; 0x30
}
    8a6e:	4608      	mov	r0, r1
    8a70:	bd70      	pop	{r4, r5, r6, pc}
		rval = '0';
    8a72:	2130      	movs	r1, #48	; 0x30
    8a74:	e7fb      	b.n	8a6e <_get_digit+0x26>

00008a76 <sprintf_out>:
	if (p->len > 1) { /* need to reserve a byte for EOS */
    8a76:	684b      	ldr	r3, [r1, #4]
    8a78:	2b01      	cmp	r3, #1
    8a7a:	dd07      	ble.n	8a8c <sprintf_out+0x16>
		*(p->ptr) = c;
    8a7c:	680b      	ldr	r3, [r1, #0]
    8a7e:	7018      	strb	r0, [r3, #0]
		p->ptr += 1;
    8a80:	680b      	ldr	r3, [r1, #0]
    8a82:	3301      	adds	r3, #1
    8a84:	600b      	str	r3, [r1, #0]
		p->len -= 1;
    8a86:	684b      	ldr	r3, [r1, #4]
    8a88:	3b01      	subs	r3, #1
    8a8a:	604b      	str	r3, [r1, #4]
}
    8a8c:	2000      	movs	r0, #0
    8a8e:	4770      	bx	lr

00008a90 <display_get_capabilities>:
    8a90:	6843      	ldr	r3, [r0, #4]
    8a92:	69db      	ldr	r3, [r3, #28]
    8a94:	4718      	bx	r3

00008a96 <lvgl_flush_cb_mono>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_mono(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
    8a96:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u16_t w = area->x2 - area->x1 + 1;
    8a9a:	888c      	ldrh	r4, [r1, #4]
    8a9c:	880b      	ldrh	r3, [r1, #0]
	u16_t h = area->y2 - area->y1 + 1;
    8a9e:	88ce      	ldrh	r6, [r1, #6]
	struct device *display_dev = (struct device *)disp_drv->user_data;
    8aa0:	f8d0 9020 	ldr.w	r9, [r0, #32]
	u16_t w = area->x2 - area->x1 + 1;
    8aa4:	3401      	adds	r4, #1
    8aa6:	1ae4      	subs	r4, r4, r3
	u16_t h = area->y2 - area->y1 + 1;
    8aa8:	884b      	ldrh	r3, [r1, #2]
    8aaa:	3601      	adds	r6, #1
{
    8aac:	b08b      	sub	sp, #44	; 0x2c
	u16_t h = area->y2 - area->y1 + 1;
    8aae:	1af6      	subs	r6, r6, r3
	u16_t w = area->x2 - area->x1 + 1;
    8ab0:	b2a4      	uxth	r4, r4
{
    8ab2:	460d      	mov	r5, r1
	u16_t h = area->y2 - area->y1 + 1;
    8ab4:	b2b6      	uxth	r6, r6
	struct display_capabilities cap;
	struct display_buffer_descriptor desc;

	display_get_capabilities(display_dev, &cap);
    8ab6:	a906      	add	r1, sp, #24
{
    8ab8:	4607      	mov	r7, r0
	display_get_capabilities(display_dev, &cap);
    8aba:	4648      	mov	r0, r9
{
    8abc:	4690      	mov	r8, r2
	display_get_capabilities(display_dev, &cap);
    8abe:	f7ff ffe7 	bl	8a90 <display_get_capabilities>

	desc.buf_size = (w * h)/8U;
    8ac2:	fb06 f304 	mul.w	r3, r6, r4
    8ac6:	08db      	lsrs	r3, r3, #3
    8ac8:	9303      	str	r3, [sp, #12]
	return api->write(dev, x, y, desc, buf);
    8aca:	f8d9 3004 	ldr.w	r3, [r9, #4]
    8ace:	f8cd 8000 	str.w	r8, [sp]
	desc.width = w;
    8ad2:	f8ad 4010 	strh.w	r4, [sp, #16]
	desc.pitch = w;
    8ad6:	f8ad 4014 	strh.w	r4, [sp, #20]
	desc.height = h;
    8ada:	f8ad 6012 	strh.w	r6, [sp, #18]
    8ade:	689c      	ldr	r4, [r3, #8]
    8ae0:	886a      	ldrh	r2, [r5, #2]
    8ae2:	8829      	ldrh	r1, [r5, #0]
    8ae4:	ab03      	add	r3, sp, #12
    8ae6:	4648      	mov	r0, r9
    8ae8:	47a0      	blx	r4
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);
	if (cap.screen_info & SCREEN_INFO_DOUBLE_BUFFER) {
    8aea:	9b08      	ldr	r3, [sp, #32]
    8aec:	071b      	lsls	r3, r3, #28
    8aee:	d509      	bpl.n	8b04 <lvgl_flush_cb_mono+0x6e>
    8af0:	f8d9 3004 	ldr.w	r3, [r9, #4]
    8af4:	f8cd 8000 	str.w	r8, [sp]
    8af8:	689c      	ldr	r4, [r3, #8]
    8afa:	886a      	ldrh	r2, [r5, #2]
    8afc:	8829      	ldrh	r1, [r5, #0]
    8afe:	ab03      	add	r3, sp, #12
    8b00:	4648      	mov	r0, r9
    8b02:	47a0      	blx	r4
		display_write(display_dev, area->x1, area->y1, &desc,
				(void *) color_p);
	}

	lv_disp_flush_ready(disp_drv);
    8b04:	4638      	mov	r0, r7
    8b06:	f002 fb6a 	bl	b1de <lv_disp_flush_ready>
}
    8b0a:	b00b      	add	sp, #44	; 0x2c
    8b0c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00008b10 <lvgl_set_px_cb_mono>:


void lvgl_set_px_cb_mono(struct _disp_drv_t *disp_drv,
		u8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
    8b10:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	struct device *display_dev = (struct device *)disp_drv->user_data;
	u8_t *buf_xy;
	u8_t bit;
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);
    8b14:	6a00      	ldr	r0, [r0, #32]
{
    8b16:	f9bd 6028 	ldrsh.w	r6, [sp, #40]	; 0x28
    8b1a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    8b1c:	460f      	mov	r7, r1
	display_get_capabilities(display_dev, &cap);
    8b1e:	4669      	mov	r1, sp
{
    8b20:	4690      	mov	r8, r2
    8b22:	461c      	mov	r4, r3
	display_get_capabilities(display_dev, &cap);
    8b24:	f7ff ffb4 	bl	8a90 <display_get_capabilities>

	if (cap.screen_info & SCREEN_INFO_MONO_VTILED) {
    8b28:	9802      	ldr	r0, [sp, #8]
    8b2a:	f010 0f01 	tst.w	r0, #1
    8b2e:	f000 0002 	and.w	r0, r0, #2
    8b32:	d01f      	beq.n	8b74 <lvgl_set_px_cb_mono+0x64>
		buf_xy = buf + x + y/8 * buf_w;
    8b34:	2e00      	cmp	r6, #0
    8b36:	4631      	mov	r1, r6
    8b38:	bfb8      	it	lt
    8b3a:	1df1      	addlt	r1, r6, #7
    8b3c:	10c9      	asrs	r1, r1, #3
    8b3e:	fb11 4108 	smlabb	r1, r1, r8, r4
    8b42:	4439      	add	r1, r7

		if (cap.screen_info & SCREEN_INFO_MONO_MSB_FIRST) {
    8b44:	4273      	negs	r3, r6
    8b46:	f006 0407 	and.w	r4, r6, #7
    8b4a:	f003 0307 	and.w	r3, r3, #7
    8b4e:	bf58      	it	pl
    8b50:	425c      	negpl	r4, r3
			bit = y%8;
		}
	} else {
		buf_xy = buf + x/8 + y * buf_w/8;

		if (cap.screen_info & SCREEN_INFO_MONO_MSB_FIRST) {
    8b52:	b108      	cbz	r0, 8b58 <lvgl_set_px_cb_mono+0x48>
			bit = 7 - x%8;
    8b54:	f1c4 0407 	rsb	r4, r4, #7
		} else {
			bit = x%8;
    8b58:	2301      	movs	r3, #1
    8b5a:	b2e4      	uxtb	r4, r4
		}
	}

	if (cap.current_pixel_format == PIXEL_FORMAT_MONO10) {
    8b5c:	fa03 f404 	lsl.w	r4, r3, r4
    8b60:	f89d 300c 	ldrb.w	r3, [sp, #12]
    8b64:	7808      	ldrb	r0, [r1, #0]
    8b66:	2b04      	cmp	r3, #4
    8b68:	b2e4      	uxtb	r4, r4
    8b6a:	d115      	bne.n	8b98 <lvgl_set_px_cb_mono+0x88>
		if (color.full == 0) {
    8b6c:	b9b5      	cbnz	r5, 8b9c <lvgl_set_px_cb_mono+0x8c>
		}
	} else {
		if (color.full == 0) {
			*buf_xy |= BIT(bit);
		} else {
			*buf_xy &= ~BIT(bit);
    8b6e:	ea20 0004 	bic.w	r0, r0, r4
    8b72:	e014      	b.n	8b9e <lvgl_set_px_cb_mono+0x8e>
		buf_xy = buf + x/8 + y * buf_w/8;
    8b74:	4643      	mov	r3, r8
    8b76:	435e      	muls	r6, r3
    8b78:	bf48      	it	mi
    8b7a:	3607      	addmi	r6, #7
    8b7c:	2c00      	cmp	r4, #0
    8b7e:	4622      	mov	r2, r4
    8b80:	ea4f 06e6 	mov.w	r6, r6, asr #3
    8b84:	bfb8      	it	lt
    8b86:	1de2      	addlt	r2, r4, #7
    8b88:	eb06 06e2 	add.w	r6, r6, r2, asr #3
    8b8c:	4263      	negs	r3, r4
    8b8e:	eb07 0106 	add.w	r1, r7, r6
		if (cap.screen_info & SCREEN_INFO_MONO_MSB_FIRST) {
    8b92:	f004 0407 	and.w	r4, r4, #7
    8b96:	e7d8      	b.n	8b4a <lvgl_set_px_cb_mono+0x3a>
		if (color.full == 0) {
    8b98:	2d00      	cmp	r5, #0
    8b9a:	d1e8      	bne.n	8b6e <lvgl_set_px_cb_mono+0x5e>
			*buf_xy |= BIT(bit);
    8b9c:	4320      	orrs	r0, r4
			*buf_xy &= ~BIT(bit);
    8b9e:	7008      	strb	r0, [r1, #0]
		}
	}
}
    8ba0:	b004      	add	sp, #16
    8ba2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00008ba6 <lvgl_rounder_cb_mono>:

void lvgl_rounder_cb_mono(struct _disp_drv_t *disp_drv,
		lv_area_t *area)
{
    8ba6:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    8ba8:	460c      	mov	r4, r1
	struct device *display_dev = (struct device *)disp_drv->user_data;
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);
    8baa:	6a00      	ldr	r0, [r0, #32]
    8bac:	4669      	mov	r1, sp
    8bae:	f7ff ff6f 	bl	8a90 <display_get_capabilities>

	if (cap.screen_info & SCREEN_INFO_MONO_VTILED) {
    8bb2:	9b02      	ldr	r3, [sp, #8]
    8bb4:	07db      	lsls	r3, r3, #31
    8bb6:	d509      	bpl.n	8bcc <lvgl_rounder_cb_mono+0x26>
		area->y1 &= ~0x7;
    8bb8:	8863      	ldrh	r3, [r4, #2]
    8bba:	f023 0307 	bic.w	r3, r3, #7
    8bbe:	8063      	strh	r3, [r4, #2]
		area->y2 |= 0x7;
    8bc0:	88e3      	ldrh	r3, [r4, #6]
    8bc2:	f043 0307 	orr.w	r3, r3, #7
    8bc6:	80e3      	strh	r3, [r4, #6]
	} else {
		area->x1 &= ~0x7;
		area->x2 |= 0x7;
	}
}
    8bc8:	b004      	add	sp, #16
    8bca:	bd10      	pop	{r4, pc}
		area->x1 &= ~0x7;
    8bcc:	8823      	ldrh	r3, [r4, #0]
    8bce:	f023 0307 	bic.w	r3, r3, #7
    8bd2:	8023      	strh	r3, [r4, #0]
		area->x2 |= 0x7;
    8bd4:	88a3      	ldrh	r3, [r4, #4]
    8bd6:	f043 0307 	orr.w	r3, r3, #7
    8bda:	80a3      	strh	r3, [r4, #4]
}
    8bdc:	e7f4      	b.n	8bc8 <lvgl_rounder_cb_mono+0x22>

00008bde <lvgl_flush_cb_16bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_16bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
    8bde:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct device *display_dev = (struct device *)disp_drv->user_data;
	u16_t w = area->x2 - area->x1 + 1;
    8be0:	888b      	ldrh	r3, [r1, #4]
	u16_t h = area->y2 - area->y1 + 1;
    8be2:	88cc      	ldrh	r4, [r1, #6]
	u16_t w = area->x2 - area->x1 + 1;
    8be4:	f9b1 6000 	ldrsh.w	r6, [r1]
	u16_t h = area->y2 - area->y1 + 1;
    8be8:	f9b1 7002 	ldrsh.w	r7, [r1, #2]
	u16_t w = area->x2 - area->x1 + 1;
    8bec:	3301      	adds	r3, #1
	u16_t h = area->y2 - area->y1 + 1;
    8bee:	3401      	adds	r4, #1
{
    8bf0:	b087      	sub	sp, #28
    8bf2:	4605      	mov	r5, r0
	u16_t w = area->x2 - area->x1 + 1;
    8bf4:	1b9b      	subs	r3, r3, r6
	struct device *display_dev = (struct device *)disp_drv->user_data;
    8bf6:	6a00      	ldr	r0, [r0, #32]
	u16_t h = area->y2 - area->y1 + 1;
    8bf8:	1be4      	subs	r4, r4, r7
	u16_t w = area->x2 - area->x1 + 1;
    8bfa:	b29b      	uxth	r3, r3
	u16_t h = area->y2 - area->y1 + 1;
    8bfc:	b2a4      	uxth	r4, r4
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 2U * h;
    8bfe:	fb04 f103 	mul.w	r1, r4, r3
	desc.width = w;
    8c02:	f8ad 3010 	strh.w	r3, [sp, #16]
	desc.pitch = w;
    8c06:	f8ad 3014 	strh.w	r3, [sp, #20]
    8c0a:	6843      	ldr	r3, [r0, #4]
    8c0c:	9200      	str	r2, [sp, #0]
	desc.buf_size = w * 2U * h;
    8c0e:	0049      	lsls	r1, r1, #1
    8c10:	9103      	str	r1, [sp, #12]
	desc.height = h;
    8c12:	f8ad 4012 	strh.w	r4, [sp, #18]
    8c16:	b2ba      	uxth	r2, r7
    8c18:	689c      	ldr	r4, [r3, #8]
    8c1a:	b2b1      	uxth	r1, r6
    8c1c:	ab03      	add	r3, sp, #12
    8c1e:	47a0      	blx	r4
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);

	lv_disp_flush_ready(disp_drv);
    8c20:	4628      	mov	r0, r5
    8c22:	f002 fadc 	bl	b1de <lv_disp_flush_ready>
}
    8c26:	b007      	add	sp, #28
    8c28:	bdf0      	pop	{r4, r5, r6, r7, pc}

00008c2a <lvgl_set_px_cb_16bit>:

#ifndef CONFIG_LVGL_COLOR_DEPTH_16
void lvgl_set_px_cb_16bit(struct _disp_drv_t *disp_drv,
		u8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
    8c2a:	b530      	push	{r4, r5, lr}
    8c2c:	9804      	ldr	r0, [sp, #16]
    return ret.full;
#elif LV_COLOR_DEPTH == 16
    return color.full;
#elif LV_COLOR_DEPTH == 32
    lv_color16_t ret;
    LV_COLOR_SET_R16(ret, LV_COLOR_GET_R(color) >> 3);   /* 8 - 5  = 3*/
    8c2e:	f04f 0400 	mov.w	r4, #0
    8c32:	f3c0 45c4 	ubfx	r5, r0, #19, #5
    8c36:	f365 24cf 	bfi	r4, r5, #11, #5

#if LV_COLOR_16_SWAP == 0
    LV_COLOR_SET_G16(ret, LV_COLOR_GET_G(color) >> 2); /* 8 - 6  = 2*/
    8c3a:	f3c0 2585 	ubfx	r5, r0, #10, #6
    8c3e:	f365 144a 	bfi	r4, r5, #5, #6
#else
    LV_COLOR_SET_G16_SWAP(ret, ret.ch.green_h = (LV_COLOR_GET_G(color) >> 2); /*(2^6 - 1)/(2^3 - 1) = 63/7 = 9*/
#endif
    LV_COLOR_SET_B16(ret, LV_COLOR_GET_B(color) >> 3);  /* 8 - 5  = 3*/
    8c42:	f3c0 00c4 	ubfx	r0, r0, #3, #5
    8c46:	f360 0404 	bfi	r4, r0, #0, #5
	u16_t *buf_xy = (u16_t *)(buf + x * 2U + y * 2U * buf_w);
    8c4a:	f9bd 000c 	ldrsh.w	r0, [sp, #12]
    8c4e:	fb00 3302 	mla	r3, r0, r2, r3
	*buf_xy = lv_color_to16(color);
    8c52:	f821 4013 	strh.w	r4, [r1, r3, lsl #1]
}
    8c56:	bd30      	pop	{r4, r5, pc}

00008c58 <lvgl_flush_cb_24bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_24bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
    8c58:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct device *display_dev = (struct device *)disp_drv->user_data;
	u16_t w = area->x2 - area->x1 + 1;
    8c5a:	888b      	ldrh	r3, [r1, #4]
	u16_t h = area->y2 - area->y1 + 1;
    8c5c:	88cc      	ldrh	r4, [r1, #6]
    8c5e:	f9b1 c002 	ldrsh.w	ip, [r1, #2]
	u16_t w = area->x2 - area->x1 + 1;
    8c62:	f9b1 7000 	ldrsh.w	r7, [r1]
    8c66:	3301      	adds	r3, #1
	u16_t h = area->y2 - area->y1 + 1;
    8c68:	3401      	adds	r4, #1
{
    8c6a:	b087      	sub	sp, #28
	u16_t h = area->y2 - area->y1 + 1;
    8c6c:	eba4 040c 	sub.w	r4, r4, ip
{
    8c70:	4605      	mov	r5, r0
	u16_t w = area->x2 - area->x1 + 1;
    8c72:	1bdb      	subs	r3, r3, r7
	struct device *display_dev = (struct device *)disp_drv->user_data;
    8c74:	6a00      	ldr	r0, [r0, #32]
	u16_t w = area->x2 - area->x1 + 1;
    8c76:	b29b      	uxth	r3, r3
	u16_t h = area->y2 - area->y1 + 1;
    8c78:	b2a4      	uxth	r4, r4
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 3U * h;
    8c7a:	fb04 f603 	mul.w	r6, r4, r3
	desc.width = w;
    8c7e:	f8ad 3010 	strh.w	r3, [sp, #16]
	desc.pitch = w;
    8c82:	f8ad 3014 	strh.w	r3, [sp, #20]
    8c86:	6843      	ldr	r3, [r0, #4]
    8c88:	9200      	str	r2, [sp, #0]
	desc.buf_size = w * 3U * h;
    8c8a:	eb06 0646 	add.w	r6, r6, r6, lsl #1
	desc.height = h;
    8c8e:	f8ad 4012 	strh.w	r4, [sp, #18]
    8c92:	fa1f f28c 	uxth.w	r2, ip
    8c96:	689c      	ldr	r4, [r3, #8]
	desc.buf_size = w * 3U * h;
    8c98:	9603      	str	r6, [sp, #12]
    8c9a:	ab03      	add	r3, sp, #12
    8c9c:	b2b9      	uxth	r1, r7
    8c9e:	47a0      	blx	r4
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);

	lv_disp_flush_ready(disp_drv);
    8ca0:	4628      	mov	r0, r5
    8ca2:	f002 fa9c 	bl	b1de <lv_disp_flush_ready>
}
    8ca6:	b007      	add	sp, #28
    8ca8:	bdf0      	pop	{r4, r5, r6, r7, pc}

00008caa <lvgl_set_px_cb_24bit>:

void lvgl_set_px_cb_24bit(struct _disp_drv_t *disp_drv,
		u8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
    8caa:	b5f0      	push	{r4, r5, r6, r7, lr}
	u8_t *buf_xy = buf + x * 3U + y * 3U * buf_w;
    8cac:	f9bd 5014 	ldrsh.w	r5, [sp, #20]
{
    8cb0:	f89d 401c 	ldrb.w	r4, [sp, #28]
    8cb4:	9806      	ldr	r0, [sp, #24]
	u8_t *buf_xy = buf + x * 3U + y * 3U * buf_w;
    8cb6:	fb05 3302 	mla	r3, r5, r2, r3
    8cba:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	lv_color32_t converted_color;

#ifdef CONFIG_LVGL_COLOR_DEPTH_32
	if (opa != LV_OPA_COVER) {
    8cbe:	2cff      	cmp	r4, #255	; 0xff
	u8_t *buf_xy = buf + x * 3U + y * 3U * buf_w;
    8cc0:	eb01 0603 	add.w	r6, r1, r3
	if (opa != LV_OPA_COVER) {
    8cc4:	d027      	beq.n	8d16 <lvgl_set_px_cb_24bit+0x6c>
static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    8cc6:	5ccd      	ldrb	r5, [r1, r3]
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    8cc8:	f896 c001 	ldrb.w	ip, [r6, #1]
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    8ccc:	b2a2      	uxth	r2, r4
    8cce:	f1c4 04ff 	rsb	r4, r4, #255	; 0xff
    8cd2:	fb15 f504 	smulbb	r5, r5, r4
    8cd6:	f3c0 4707 	ubfx	r7, r0, #16, #8
    8cda:	fb07 5702 	mla	r7, r7, r2, r5
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    8cde:	fb1c fc04 	smulbb	ip, ip, r4
    8ce2:	f3c0 2507 	ubfx	r5, r0, #8, #8
    8ce6:	fb05 c502 	mla	r5, r5, r2, ip
    LV_COLOR_SET_B(ret, (uint16_t)((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) * (255 - mix)) >> 8);
    8cea:	f896 c002 	ldrb.w	ip, [r6, #2]
    8cee:	fa5f fe80 	uxtb.w	lr, r0
    8cf2:	fb1c f404 	smulbb	r4, ip, r4
    8cf6:	fb0e 4202 	mla	r2, lr, r2, r4
    8cfa:	f3c2 2207 	ubfx	r2, r2, #8, #8
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    8cfe:	f3c5 2507 	ubfx	r5, r5, #8, #8
    8d02:	f362 0007 	bfi	r0, r2, #0, #8
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    8d06:	f3c7 2707 	ubfx	r7, r7, #8, #8
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
    8d0a:	f365 200f 	bfi	r0, r5, #8, #8
    8d0e:	f367 4017 	bfi	r0, r7, #16, #8
    8d12:	f040 407f 	orr.w	r0, r0, #4278190080	; 0xff000000
		color = lv_color_mix(color, mix_color, opa);
	}
#endif

	converted_color.full = lv_color_to32(color);
	*buf_xy = converted_color.ch.red;
    8d16:	f3c0 4207 	ubfx	r2, r0, #16, #8
    8d1a:	54ca      	strb	r2, [r1, r3]
	*(buf_xy + 1) = converted_color.ch.green;
    8d1c:	f3c0 2307 	ubfx	r3, r0, #8, #8
    8d20:	7073      	strb	r3, [r6, #1]
	*(buf_xy + 2) = converted_color.ch.blue;
    8d22:	70b0      	strb	r0, [r6, #2]
}
    8d24:	bdf0      	pop	{r4, r5, r6, r7, pc}

00008d26 <lvgl_flush_cb_32bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_32bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
    8d26:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct device *display_dev = (struct device *)disp_drv->user_data;
	u16_t w = area->x2 - area->x1 + 1;
    8d28:	888b      	ldrh	r3, [r1, #4]
	u16_t h = area->y2 - area->y1 + 1;
    8d2a:	88cc      	ldrh	r4, [r1, #6]
	u16_t w = area->x2 - area->x1 + 1;
    8d2c:	f9b1 6000 	ldrsh.w	r6, [r1]
	u16_t h = area->y2 - area->y1 + 1;
    8d30:	f9b1 7002 	ldrsh.w	r7, [r1, #2]
	u16_t w = area->x2 - area->x1 + 1;
    8d34:	3301      	adds	r3, #1
	u16_t h = area->y2 - area->y1 + 1;
    8d36:	3401      	adds	r4, #1
{
    8d38:	b087      	sub	sp, #28
    8d3a:	4605      	mov	r5, r0
	u16_t w = area->x2 - area->x1 + 1;
    8d3c:	1b9b      	subs	r3, r3, r6
	struct device *display_dev = (struct device *)disp_drv->user_data;
    8d3e:	6a00      	ldr	r0, [r0, #32]
	u16_t h = area->y2 - area->y1 + 1;
    8d40:	1be4      	subs	r4, r4, r7
	u16_t w = area->x2 - area->x1 + 1;
    8d42:	b29b      	uxth	r3, r3
	u16_t h = area->y2 - area->y1 + 1;
    8d44:	b2a4      	uxth	r4, r4
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 4U * h;
    8d46:	fb04 f103 	mul.w	r1, r4, r3
	desc.width = w;
    8d4a:	f8ad 3010 	strh.w	r3, [sp, #16]
	desc.pitch = w;
    8d4e:	f8ad 3014 	strh.w	r3, [sp, #20]
    8d52:	6843      	ldr	r3, [r0, #4]
    8d54:	9200      	str	r2, [sp, #0]
	desc.buf_size = w * 4U * h;
    8d56:	0089      	lsls	r1, r1, #2
    8d58:	9103      	str	r1, [sp, #12]
	desc.height = h;
    8d5a:	f8ad 4012 	strh.w	r4, [sp, #18]
    8d5e:	b2ba      	uxth	r2, r7
    8d60:	689c      	ldr	r4, [r3, #8]
    8d62:	b2b1      	uxth	r1, r6
    8d64:	ab03      	add	r3, sp, #12
    8d66:	47a0      	blx	r4
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);

	lv_disp_flush_ready(disp_drv);
    8d68:	4628      	mov	r0, r5
    8d6a:	f002 fa38 	bl	b1de <lv_disp_flush_ready>
}
    8d6e:	b007      	add	sp, #28
    8d70:	bdf0      	pop	{r4, r5, r6, r7, pc}

00008d72 <z_platform_init>:

void z_platform_init(void)
{
	SystemInit();
    8d72:	f7fa b9d1 	b.w	3118 <SystemInit>

00008d76 <nrf_rtc_event_clear>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    8d76:	2300      	movs	r3, #0
    8d78:	5043      	str	r3, [r0, r1]
{
    8d7a:	b082      	sub	sp, #8
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    8d7c:	5843      	ldr	r3, [r0, r1]
    8d7e:	9301      	str	r3, [sp, #4]
    (void)dummy;
    8d80:	9b01      	ldr	r3, [sp, #4]
}
    8d82:	b002      	add	sp, #8
    8d84:	4770      	bx	lr

00008d86 <start>:
	return CONTAINER_OF(dev->config->config_info,
    8d86:	6803      	ldr	r3, [r0, #0]
	nrf_rtc_task_trigger(get_nrfx_config(dev)->rtc, NRF_RTC_TASK_START);
    8d88:	689b      	ldr	r3, [r3, #8]
    8d8a:	691b      	ldr	r3, [r3, #16]
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    8d8c:	2201      	movs	r2, #1
    8d8e:	601a      	str	r2, [r3, #0]
}
    8d90:	2000      	movs	r0, #0
    8d92:	4770      	bx	lr

00008d94 <stop>:
	return CONTAINER_OF(dev->config->config_info,
    8d94:	6803      	ldr	r3, [r0, #0]
	nrf_rtc_task_trigger(get_nrfx_config(dev)->rtc, NRF_RTC_TASK_STOP);
    8d96:	689b      	ldr	r3, [r3, #8]
    8d98:	691b      	ldr	r3, [r3, #16]
    8d9a:	2201      	movs	r2, #1
    8d9c:	605a      	str	r2, [r3, #4]
}
    8d9e:	2000      	movs	r0, #0
    8da0:	4770      	bx	lr

00008da2 <read>:
	return CONTAINER_OF(dev->config->config_info,
    8da2:	6803      	ldr	r3, [r0, #0]
	return nrf_rtc_counter_get(get_nrfx_config(dev)->rtc);
    8da4:	689b      	ldr	r3, [r3, #8]
    8da6:	691b      	ldr	r3, [r3, #16]
     return p_reg->COUNTER;
    8da8:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
}
    8dac:	4770      	bx	lr

00008dae <cancel_alarm>:
	return CONTAINER_OF(dev->config->config_info,
    8dae:	6803      	ldr	r3, [r0, #0]
{
    8db0:	b510      	push	{r4, lr}
	return CONTAINER_OF(dev->config->config_info,
    8db2:	689c      	ldr	r4, [r3, #8]
	nrf_rtc_int_disable(rtc, RTC_CHANNEL_INT_MASK(chan));
    8db4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
	NRF_RTC_Type *rtc = config->rtc;
    8db8:	6920      	ldr	r0, [r4, #16]
	nrf_rtc_int_disable(rtc, RTC_CHANNEL_INT_MASK(chan));
    8dba:	408b      	lsls	r3, r1
{
    8dbc:	460a      	mov	r2, r1
	nrf_rtc_event_t evt = RTC_CHANNEL_EVENT_ADDR(chan);
    8dbe:	3150      	adds	r1, #80	; 0x50
    p_reg->INTENCLR = mask;
    8dc0:	f8c0 3308 	str.w	r3, [r0, #776]	; 0x308
	nrf_rtc_event_clear(rtc, evt);
    8dc4:	0089      	lsls	r1, r1, #2
    p_reg->EVTENSET = mask;
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
    8dc6:	f8c0 3348 	str.w	r3, [r0, #840]	; 0x348
    8dca:	f7ff ffd4 	bl	8d76 <nrf_rtc_event_clear>
	config->ch_data[chan].callback = NULL;
    8dce:	68e3      	ldr	r3, [r4, #12]
    8dd0:	b212      	sxth	r2, r2
    8dd2:	2000      	movs	r0, #0
    8dd4:	f843 0032 	str.w	r0, [r3, r2, lsl #3]
}
    8dd8:	bd10      	pop	{r4, pc}

00008dda <set_top_value>:
{
    8dda:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return CONTAINER_OF(dev->config->config_info,
    8ddc:	6803      	ldr	r3, [r0, #0]
	struct counter_nrfx_data *dev_data = get_dev_data(dev);
    8dde:	6886      	ldr	r6, [r0, #8]
	return CONTAINER_OF(dev->config->config_info,
    8de0:	689d      	ldr	r5, [r3, #8]
	if (IS_FIXED_TOP(dev)) {
    8de2:	7d2b      	ldrb	r3, [r5, #20]
	NRF_RTC_Type *rtc = nrfx_config->rtc;
    8de4:	692a      	ldr	r2, [r5, #16]
{
    8de6:	4604      	mov	r4, r0
	if (IS_FIXED_TOP(dev)) {
    8de8:	bb13      	cbnz	r3, 8e30 <set_top_value+0x56>
	return config->channels;
    8dea:	7a68      	ldrb	r0, [r5, #9]
	for (int i = 0; i < counter_get_num_of_channels(dev); i++) {
    8dec:	4298      	cmp	r0, r3
    8dee:	dc37      	bgt.n	8e60 <set_top_value+0x86>
	nrf_rtc_int_disable(rtc, RTC_CHANNEL_INT_MASK(top_ch));
    8df0:	f44f 3580 	mov.w	r5, #65536	; 0x10000
	dev_data->top_cb = cfg->callback;
    8df4:	684b      	ldr	r3, [r1, #4]
	nrf_rtc_int_disable(rtc, RTC_CHANNEL_INT_MASK(top_ch));
    8df6:	4085      	lsls	r5, r0
    p_reg->INTENCLR = mask;
    8df8:	f8c2 5308 	str.w	r5, [r2, #776]	; 0x308
    p_reg->CC[ch] = cc_val;
    8dfc:	f500 70a8 	add.w	r0, r0, #336	; 0x150
	dev_data->top_cb = cfg->callback;
    8e00:	6033      	str	r3, [r6, #0]
	dev_data->top_user_data = cfg->user_data;
    8e02:	688b      	ldr	r3, [r1, #8]
    8e04:	6073      	str	r3, [r6, #4]
	dev_data->top = cfg->ticks;
    8e06:	680b      	ldr	r3, [r1, #0]
    8e08:	60b3      	str	r3, [r6, #8]
    8e0a:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
	if (!(cfg->flags & COUNTER_TOP_CFG_DONT_RESET)) {
    8e0e:	68c8      	ldr	r0, [r1, #12]
    8e10:	f010 0001 	ands.w	r0, r0, #1
    8e14:	d12a      	bne.n	8e6c <set_top_value+0x92>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    8e16:	2301      	movs	r3, #1
    8e18:	6093      	str	r3, [r2, #8]
	if (cfg->callback || sw_wrap_required(dev)) {
    8e1a:	684b      	ldr	r3, [r1, #4]
    8e1c:	b92b      	cbnz	r3, 8e2a <set_top_value+0x50>
	return (get_dev_data(dev)->top != COUNTER_MAX_TOP_VALUE)
    8e1e:	68a3      	ldr	r3, [r4, #8]
	if (cfg->callback || sw_wrap_required(dev)) {
    8e20:	6899      	ldr	r1, [r3, #8]
    8e22:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    8e26:	4299      	cmp	r1, r3
    8e28:	d019      	beq.n	8e5e <set_top_value+0x84>
    p_reg->INTENSET = mask;
    8e2a:	f8c2 5304 	str.w	r5, [r2, #772]	; 0x304
    8e2e:	e016      	b.n	8e5e <set_top_value+0x84>
	if (cfg->ticks != COUNTER_MAX_TOP_VALUE) {
    8e30:	6808      	ldr	r0, [r1, #0]
    8e32:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    8e36:	4298      	cmp	r0, r3
    8e38:	d128      	bne.n	8e8c <set_top_value+0xb2>
	get_dev_data(dev)->top_cb = cfg->callback;
    8e3a:	6848      	ldr	r0, [r1, #4]
    p_reg->INTENCLR = mask;
    8e3c:	2302      	movs	r3, #2
    8e3e:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
    8e42:	6030      	str	r0, [r6, #0]
	get_dev_data(dev)->top_user_data = cfg->user_data;
    8e44:	68a3      	ldr	r3, [r4, #8]
    8e46:	688c      	ldr	r4, [r1, #8]
    8e48:	605c      	str	r4, [r3, #4]
	if (!(cfg->flags & COUNTER_TOP_CFG_DONT_RESET)) {
    8e4a:	68cb      	ldr	r3, [r1, #12]
    8e4c:	07d9      	lsls	r1, r3, #31
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    8e4e:	bf5c      	itt	pl
    8e50:	2301      	movpl	r3, #1
    8e52:	6093      	strpl	r3, [r2, #8]
	if (cfg->callback) {
    8e54:	b118      	cbz	r0, 8e5e <set_top_value+0x84>
    p_reg->INTENSET = mask;
    8e56:	2302      	movs	r3, #2
    8e58:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return 0;
    8e5c:	2000      	movs	r0, #0
}
    8e5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (nrfx_config->ch_data[i].callback) {
    8e60:	68ef      	ldr	r7, [r5, #12]
    8e62:	f857 7033 	ldr.w	r7, [r7, r3, lsl #3]
    8e66:	b9a7      	cbnz	r7, 8e92 <set_top_value+0xb8>
	for (int i = 0; i < counter_get_num_of_channels(dev); i++) {
    8e68:	3301      	adds	r3, #1
    8e6a:	e7bf      	b.n	8dec <set_top_value+0x12>
	} else if (read(dev) >= cfg->ticks) {
    8e6c:	4620      	mov	r0, r4
    8e6e:	f7ff ff98 	bl	8da2 <read>
    8e72:	680b      	ldr	r3, [r1, #0]
    8e74:	4298      	cmp	r0, r3
    8e76:	d307      	bcc.n	8e88 <set_top_value+0xae>
		if (cfg->flags & COUNTER_TOP_CFG_RESET_WHEN_LATE) {
    8e78:	68cb      	ldr	r3, [r1, #12]
    8e7a:	079b      	lsls	r3, r3, #30
    8e7c:	d501      	bpl.n	8e82 <set_top_value+0xa8>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    8e7e:	2301      	movs	r3, #1
    8e80:	6093      	str	r3, [r2, #8]
		err = -ETIME;
    8e82:	f06f 004e 	mvn.w	r0, #78	; 0x4e
    8e86:	e7c8      	b.n	8e1a <set_top_value+0x40>
	int err = 0;
    8e88:	2000      	movs	r0, #0
    8e8a:	e7c6      	b.n	8e1a <set_top_value+0x40>
		return -EINVAL;
    8e8c:	f06f 0015 	mvn.w	r0, #21
    8e90:	e7e5      	b.n	8e5e <set_top_value+0x84>
			return -EBUSY;
    8e92:	f06f 000f 	mvn.w	r0, #15
    8e96:	e7e2      	b.n	8e5e <set_top_value+0x84>

00008e98 <get_pending_int>:
}
    8e98:	2000      	movs	r0, #0
    8e9a:	4770      	bx	lr

00008e9c <get_top_value>:
	return get_dev_data(dev)->top;
    8e9c:	6883      	ldr	r3, [r0, #8]
}
    8e9e:	6898      	ldr	r0, [r3, #8]
    8ea0:	4770      	bx	lr

00008ea2 <get_guard_period>:
	return get_dev_data(dev)->guard_period;
    8ea2:	6883      	ldr	r3, [r0, #8]
}
    8ea4:	68d8      	ldr	r0, [r3, #12]
    8ea6:	4770      	bx	lr

00008ea8 <set_guard_period>:
	get_dev_data(dev)->guard_period = guard;
    8ea8:	6883      	ldr	r3, [r0, #8]
}
    8eaa:	2000      	movs	r0, #0
	get_dev_data(dev)->guard_period = guard;
    8eac:	60d9      	str	r1, [r3, #12]
}
    8eae:	4770      	bx	lr

00008eb0 <ticks_sub>:
	return CONTAINER_OF(dev->config->config_info,
    8eb0:	6800      	ldr	r0, [r0, #0]
	if (IS_FIXED_TOP(dev)) {
    8eb2:	6880      	ldr	r0, [r0, #8]
{
    8eb4:	b510      	push	{r4, lr}
	if (IS_FIXED_TOP(dev)) {
    8eb6:	7d04      	ldrb	r4, [r0, #20]
    8eb8:	1a88      	subs	r0, r1, r2
    8eba:	b114      	cbz	r4, 8ec2 <ticks_sub+0x12>
		return (val - old) & COUNTER_MAX_TOP_VALUE;
    8ebc:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
}
    8ec0:	bd10      	pop	{r4, pc}
	return !(val & (val + 1));
    8ec2:	1c5c      	adds	r4, r3, #1
	} else if (likely(is_bit_mask(top))) {
    8ec4:	4223      	tst	r3, r4
    8ec6:	d101      	bne.n	8ecc <ticks_sub+0x1c>
		return (val - old) & top;
    8ec8:	4018      	ands	r0, r3
    8eca:	e7f9      	b.n	8ec0 <ticks_sub+0x10>
	return (val >= old) ? (val - old) : val + top + 1 - old;
    8ecc:	4291      	cmp	r1, r2
    8ece:	bf38      	it	cc
    8ed0:	1900      	addcc	r0, r0, r4
    8ed2:	e7f5      	b.n	8ec0 <ticks_sub+0x10>

00008ed4 <irq_handler>:
{
    8ed4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return CONTAINER_OF(dev->config->config_info,
    8ed8:	6803      	ldr	r3, [r0, #0]
    8eda:	689b      	ldr	r3, [r3, #8]
		  NRF_RTC_EVENT_OVERFLOW :
    8edc:	7d19      	ldrb	r1, [r3, #20]
	NRF_RTC_Type *rtc = get_nrfx_config(dev)->rtc;
    8ede:	691a      	ldr	r2, [r3, #16]
{
    8ee0:	4605      	mov	r5, r0
		  NRF_RTC_EVENT_OVERFLOW :
    8ee2:	b9e9      	cbnz	r1, 8f20 <irq_handler+0x4c>
		  RTC_CHANNEL_EVENT_ADDR(counter_get_num_of_channels(dev));
    8ee4:	7a59      	ldrb	r1, [r3, #9]
		  NRF_RTC_EVENT_OVERFLOW :
    8ee6:	3150      	adds	r1, #80	; 0x50
    8ee8:	0089      	lsls	r1, r1, #2
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8eea:	5853      	ldr	r3, [r2, r1]
	if (nrf_rtc_event_check(rtc, top_evt)) {
    8eec:	b17b      	cbz	r3, 8f0e <irq_handler+0x3a>
	counter_top_callback_t cb = get_dev_data(dev)->top_cb;
    8eee:	68ab      	ldr	r3, [r5, #8]
		nrf_rtc_event_clear(rtc, top_evt);
    8ef0:	4610      	mov	r0, r2
	counter_top_callback_t cb = get_dev_data(dev)->top_cb;
    8ef2:	681c      	ldr	r4, [r3, #0]
		nrf_rtc_event_clear(rtc, top_evt);
    8ef4:	f7ff ff3f 	bl	8d76 <nrf_rtc_event_clear>
	return CONTAINER_OF(dev->config->config_info,
    8ef8:	682b      	ldr	r3, [r5, #0]
		if (!IS_FIXED_TOP(dev) && !IS_PPI_WRAP(dev)) {
    8efa:	689b      	ldr	r3, [r3, #8]
    8efc:	7d1b      	ldrb	r3, [r3, #20]
    8efe:	b90b      	cbnz	r3, 8f04 <irq_handler+0x30>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    8f00:	2301      	movs	r3, #1
    8f02:	6093      	str	r3, [r2, #8]
		if (cb) {
    8f04:	b11c      	cbz	r4, 8f0e <irq_handler+0x3a>
			cb(dev, get_dev_data(dev)->top_user_data);
    8f06:	68ab      	ldr	r3, [r5, #8]
    8f08:	4628      	mov	r0, r5
    8f0a:	6859      	ldr	r1, [r3, #4]
    8f0c:	47a0      	blx	r4
	bool hw_irq_pending = nrf_rtc_event_check(rtc, evt) &&
    8f0e:	2400      	movs	r4, #0
    8f10:	f44f 76a0 	mov.w	r6, #320	; 0x140
	u32_t int_mask = RTC_CHANNEL_INT_MASK(chan);
    8f14:	f44f 3880 	mov.w	r8, #65536	; 0x10000
	bool hw_irq_pending = nrf_rtc_event_check(rtc, evt) &&
    8f18:	46a1      	mov	r9, r4
	bool sw_irq_pending = get_dev_data(dev)->ipend_adj & BIT(chan);
    8f1a:	f04f 0a01 	mov.w	sl, #1
    8f1e:	e04e      	b.n	8fbe <irq_handler+0xea>
		  NRF_RTC_EVENT_OVERFLOW :
    8f20:	f44f 7182 	mov.w	r1, #260	; 0x104
    8f24:	e7e1      	b.n	8eea <irq_handler+0x16>
	NRF_RTC_Type *rtc = get_nrfx_config(dev)->rtc;
    8f26:	691a      	ldr	r2, [r3, #16]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8f28:	5993      	ldr	r3, [r2, r6]
	nrf_rtc_event_t evt = RTC_CHANNEL_EVENT_ADDR(chan);
    8f2a:	b2b1      	uxth	r1, r6
	u32_t int_mask = RTC_CHANNEL_INT_MASK(chan);
    8f2c:	fa08 f704 	lsl.w	r7, r8, r4
	bool hw_irq_pending = nrf_rtc_event_check(rtc, evt) &&
    8f30:	b12b      	cbz	r3, 8f3e <irq_handler+0x6a>
    return p_reg->INTENSET & mask;
    8f32:	f8d2 3304 	ldr.w	r3, [r2, #772]	; 0x304
    8f36:	421f      	tst	r7, r3
    8f38:	bf14      	ite	ne
    8f3a:	2301      	movne	r3, #1
    8f3c:	2300      	moveq	r3, #0
	bool sw_irq_pending = get_dev_data(dev)->ipend_adj & BIT(chan);
    8f3e:	68a8      	ldr	r0, [r5, #8]
    8f40:	6900      	ldr	r0, [r0, #16]
    8f42:	fa0a fb04 	lsl.w	fp, sl, r4
    8f46:	ea0b 0000 	and.w	r0, fp, r0
	if (hw_irq_pending || sw_irq_pending) {
    8f4a:	4303      	orrs	r3, r0
    8f4c:	d035      	beq.n	8fba <irq_handler+0xe6>
		nrf_rtc_event_clear(rtc, evt);
    8f4e:	4610      	mov	r0, r2
    8f50:	f7ff ff11 	bl	8d76 <nrf_rtc_event_clear>
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    8f54:	68ab      	ldr	r3, [r5, #8]
    8f56:	f3bf 8f5b 	dmb	ish
		atomic_and(&get_dev_data(dev)->ipend_adj, ~BIT(chan));
    8f5a:	ea6f 0b0b 	mvn.w	fp, fp
    8f5e:	3310      	adds	r3, #16
    8f60:	e853 1f00 	ldrex	r1, [r3]
    8f64:	ea01 010b 	and.w	r1, r1, fp
    8f68:	e843 1000 	strex	r0, r1, [r3]
    8f6c:	2800      	cmp	r0, #0
    8f6e:	d1f7      	bne.n	8f60 <irq_handler+0x8c>
    8f70:	f3bf 8f5b 	dmb	ish
	return CONTAINER_OF(dev->config->config_info,
    8f74:	682b      	ldr	r3, [r5, #0]
    p_reg->INTENCLR = mask;
    8f76:	f8c2 7308 	str.w	r7, [r2, #776]	; 0x308
		chdata = &get_nrfx_config(dev)->ch_data[chan];
    8f7a:	689b      	ldr	r3, [r3, #8]
    8f7c:	68db      	ldr	r3, [r3, #12]
		cb = chdata->callback;
    8f7e:	f853 7034 	ldr.w	r7, [r3, r4, lsl #3]
		chdata->callback = NULL;
    8f82:	f843 9034 	str.w	r9, [r3, r4, lsl #3]
		chdata = &get_nrfx_config(dev)->ch_data[chan];
    8f86:	eb03 0bc4 	add.w	fp, r3, r4, lsl #3
		if (cb) {
    8f8a:	b1b7      	cbz	r7, 8fba <irq_handler+0xe6>
    return p_reg->CC[ch];
    8f8c:	f504 73a8 	add.w	r3, r4, #336	; 0x150
			if (get_dev_data(dev)->ipend_adj & CC_ADJ_MASK(chan)) {
    8f90:	68a8      	ldr	r0, [r5, #8]
    8f92:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    8f96:	6903      	ldr	r3, [r0, #16]
    8f98:	f104 0210 	add.w	r2, r4, #16
    8f9c:	40d3      	lsrs	r3, r2
    8f9e:	07db      	lsls	r3, r3, #31
    8fa0:	d505      	bpl.n	8fae <irq_handler+0xda>
				cc = ticks_sub(dev, cc, 1,
    8fa2:	6883      	ldr	r3, [r0, #8]
    8fa4:	2201      	movs	r2, #1
    8fa6:	4628      	mov	r0, r5
    8fa8:	f7ff ff82 	bl	8eb0 <ticks_sub>
    8fac:	4601      	mov	r1, r0
			cb(dev, chan, cc, chdata->user_data);
    8fae:	460a      	mov	r2, r1
    8fb0:	f8db 3004 	ldr.w	r3, [fp, #4]
    8fb4:	b2e1      	uxtb	r1, r4
    8fb6:	4628      	mov	r0, r5
    8fb8:	47b8      	blx	r7
	for (u32_t i = 0; i < counter_get_num_of_channels(dev); i++) {
    8fba:	3401      	adds	r4, #1
    8fbc:	3604      	adds	r6, #4
	const struct counter_config_info *config =
    8fbe:	682b      	ldr	r3, [r5, #0]
    8fc0:	689b      	ldr	r3, [r3, #8]
    8fc2:	7a5a      	ldrb	r2, [r3, #9]
    8fc4:	42a2      	cmp	r2, r4
    8fc6:	d8ae      	bhi.n	8f26 <irq_handler+0x52>
}
    8fc8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00008fcc <get_max_relative_alarm>:
    8fcc:	6883      	ldr	r3, [r0, #8]
    8fce:	6898      	ldr	r0, [r3, #8]
    8fd0:	4770      	bx	lr

00008fd2 <ticks_add>:
	u32_t sum = val1 + val2;
    8fd2:	440a      	add	r2, r1
	return CONTAINER_OF(dev->config->config_info,
    8fd4:	6801      	ldr	r1, [r0, #0]
	if (IS_FIXED_TOP(dev)) {
    8fd6:	6889      	ldr	r1, [r1, #8]
    8fd8:	7d09      	ldrb	r1, [r1, #20]
    8fda:	b119      	cbz	r1, 8fe4 <ticks_add+0x12>
		return sum & COUNTER_MAX_TOP_VALUE;
    8fdc:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
}
    8fe0:	4610      	mov	r0, r2
    8fe2:	4770      	bx	lr
	return !(val & (val + 1));
    8fe4:	1c59      	adds	r1, r3, #1
	if (likely(is_bit_mask(top))) {
    8fe6:	4219      	tst	r1, r3
    8fe8:	d108      	bne.n	8ffc <ticks_add+0x2a>
		sum = sum & top;
    8fea:	401a      	ands	r2, r3
	if (unlikely(val == 0) && (top != COUNTER_MAX_TOP_VALUE)) {
    8fec:	2a00      	cmp	r2, #0
    8fee:	d1f7      	bne.n	8fe0 <ticks_add+0xe>
    8ff0:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
    8ff4:	1a9a      	subs	r2, r3, r2
    8ff6:	bf18      	it	ne
    8ff8:	2201      	movne	r2, #1
    8ffa:	e7f1      	b.n	8fe0 <ticks_add+0xe>
		sum = sum > top ? sum - (top + 1) : sum;
    8ffc:	429a      	cmp	r2, r3
    8ffe:	bf84      	itt	hi
    9000:	43d9      	mvnhi	r1, r3
    9002:	1852      	addhi	r2, r2, r1
    9004:	e7f2      	b.n	8fec <ticks_add+0x1a>

00009006 <handle_next_tick_case>:
{
    9006:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	val = ticks_add(dev, val, 1, get_dev_data(dev)->top);
    9008:	6884      	ldr	r4, [r0, #8]
{
    900a:	4606      	mov	r6, r0
    900c:	460d      	mov	r5, r1
    900e:	4617      	mov	r7, r2
    9010:	4619      	mov	r1, r3
	val = ticks_add(dev, val, 1, get_dev_data(dev)->top);
    9012:	2201      	movs	r2, #1
    9014:	68a3      	ldr	r3, [r4, #8]
    9016:	f7ff ffdc 	bl	8fd2 <ticks_add>
	return CONTAINER_OF(dev->config->config_info,
    901a:	6833      	ldr	r3, [r6, #0]
	nrf_rtc_cc_set(get_nrfx_config(dev)->rtc, chan, val);
    901c:	689b      	ldr	r3, [r3, #8]
    p_reg->CC[ch] = cc_val;
    901e:	f505 72a8 	add.w	r2, r5, #336	; 0x150
    9022:	691b      	ldr	r3, [r3, #16]
    9024:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
	atomic_or(&get_dev_data(dev)->ipend_adj, CC_ADJ_MASK(chan));
    9028:	f105 0210 	add.w	r2, r5, #16
    902c:	2301      	movs	r3, #1
    902e:	4093      	lsls	r3, r2
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    9030:	3410      	adds	r4, #16
    9032:	f3bf 8f5b 	dmb	ish
    9036:	e854 2f00 	ldrex	r2, [r4]
    903a:	431a      	orrs	r2, r3
    903c:	e844 2100 	strex	r1, r2, [r4]
    9040:	2900      	cmp	r1, #0
    9042:	d1f8      	bne.n	9036 <handle_next_tick_case+0x30>
    9044:	f3bf 8f5b 	dmb	ish
	return CONTAINER_OF(dev->config->config_info,
    9048:	6833      	ldr	r3, [r6, #0]
	if (nrf_rtc_counter_get(get_nrfx_config(dev)->rtc) != now) {
    904a:	689b      	ldr	r3, [r3, #8]
    904c:	691a      	ldr	r2, [r3, #16]
     return p_reg->COUNTER;
    904e:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
    9052:	429f      	cmp	r7, r3
    9054:	d005      	beq.n	9062 <handle_next_tick_case+0x5c>
		set_cc_int_pending(dev, chan);
    9056:	4629      	mov	r1, r5
    9058:	4630      	mov	r0, r6
}
    905a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		set_cc_int_pending(dev, chan);
    905e:	f7f9 bb89 	b.w	2774 <set_cc_int_pending>
		nrf_rtc_int_enable(get_nrfx_config(dev)->rtc,
    9062:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    9066:	fa03 f505 	lsl.w	r5, r3, r5
    p_reg->INTENSET = mask;
    906a:	f8c2 5304 	str.w	r5, [r2, #772]	; 0x304
}
    906e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00009070 <set_channel_alarm>:
	return CONTAINER_OF(dev->config->config_info,
    9070:	6803      	ldr	r3, [r0, #0]
{
    9072:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9076:	4604      	mov	r4, r0
	if (alarm_cfg->ticks > get_dev_data(dev)->top) {
    9078:	6880      	ldr	r0, [r0, #8]
	struct counter_nrfx_ch_data *chdata = &nrfx_config->ch_data[chan];
    907a:	689b      	ldr	r3, [r3, #8]
	if (alarm_cfg->ticks > get_dev_data(dev)->top) {
    907c:	6855      	ldr	r5, [r2, #4]
    907e:	6880      	ldr	r0, [r0, #8]
	struct counter_nrfx_ch_data *chdata = &nrfx_config->ch_data[chan];
    9080:	68db      	ldr	r3, [r3, #12]
    9082:	fa0f f981 	sxth.w	r9, r1
	if (alarm_cfg->ticks > get_dev_data(dev)->top) {
    9086:	4285      	cmp	r5, r0
{
    9088:	4688      	mov	r8, r1
    908a:	b085      	sub	sp, #20
	struct counter_nrfx_ch_data *chdata = &nrfx_config->ch_data[chan];
    908c:	eb03 01c9 	add.w	r1, r3, r9, lsl #3
	if (alarm_cfg->ticks > get_dev_data(dev)->top) {
    9090:	f200 80b1 	bhi.w	91f6 <set_channel_alarm+0x186>
	if (chdata->callback) {
    9094:	f853 0039 	ldr.w	r0, [r3, r9, lsl #3]
    9098:	2800      	cmp	r0, #0
    909a:	f040 80af 	bne.w	91fc <set_channel_alarm+0x18c>
	chdata->callback = alarm_cfg->callback;
    909e:	6810      	ldr	r0, [r2, #0]
    90a0:	f843 0039 	str.w	r0, [r3, r9, lsl #3]
	chdata->user_data = alarm_cfg->user_data;
    90a4:	6893      	ldr	r3, [r2, #8]
    90a6:	604b      	str	r3, [r1, #4]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    90a8:	68a1      	ldr	r1, [r4, #8]
    90aa:	f3bf 8f5b 	dmb	ish
	atomic_and(&get_dev_data(dev)->ipend_adj, ~CC_ADJ_MASK(chan));
    90ae:	f108 0010 	add.w	r0, r8, #16
    90b2:	2301      	movs	r3, #1
    90b4:	4083      	lsls	r3, r0
    90b6:	43db      	mvns	r3, r3
    90b8:	3110      	adds	r1, #16
    90ba:	e851 0f00 	ldrex	r0, [r1]
    90be:	4018      	ands	r0, r3
    90c0:	e841 0500 	strex	r5, r0, [r1]
    90c4:	2d00      	cmp	r5, #0
    90c6:	d1f8      	bne.n	90ba <set_channel_alarm+0x4a>
    90c8:	f3bf 8f5b 	dmb	ish
	return CONTAINER_OF(dev->config->config_info,
    90cc:	6823      	ldr	r3, [r4, #0]
	return set_cc(dev, chan, alarm_cfg->ticks, alarm_cfg->flags);
    90ce:	f8d2 b00c 	ldr.w	fp, [r2, #12]
	NRF_RTC_Type  *rtc = get_nrfx_config(dev)->rtc;
    90d2:	689b      	ldr	r3, [r3, #8]
	return set_cc(dev, chan, alarm_cfg->ticks, alarm_cfg->flags);
    90d4:	6855      	ldr	r5, [r2, #4]
	NRF_RTC_Type  *rtc = get_nrfx_config(dev)->rtc;
    90d6:	691e      	ldr	r6, [r3, #16]
	u32_t int_mask = RTC_CHANNEL_INT_MASK(chan);
    90d8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    90dc:	fa03 f308 	lsl.w	r3, r3, r8
    90e0:	9302      	str	r3, [sp, #8]
	bool absolute = flags & COUNTER_ALARM_CFG_ABSOLUTE;
    90e2:	f00b 0301 	and.w	r3, fp, #1
    90e6:	9303      	str	r3, [sp, #12]
	top =  get_dev_data(dev)->top;
    90e8:	68a3      	ldr	r3, [r4, #8]
     return p_reg->COUNTER;
    90ea:	f8d6 2504 	ldr.w	r2, [r6, #1284]	; 0x504
    90ee:	689f      	ldr	r7, [r3, #8]
	evt = RTC_CHANNEL_EVENT_ADDR(chan);
    90f0:	f108 0a50 	add.w	sl, r8, #80	; 0x50
    90f4:	eb06 0389 	add.w	r3, r6, r9, lsl #2
    90f8:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
    return p_reg->CC[ch];
    90fc:	9301      	str	r3, [sp, #4]
	nrf_rtc_event_clear(rtc, evt);
    90fe:	4651      	mov	r1, sl
    9100:	f8d3 3540 	ldr.w	r3, [r3, #1344]	; 0x540
    9104:	9300      	str	r3, [sp, #0]
    9106:	4630      	mov	r0, r6
    9108:	f7ff fe35 	bl	8d76 <nrf_rtc_event_clear>
    p_reg->CC[ch] = cc_val;
    910c:	9b01      	ldr	r3, [sp, #4]
	if (ticks_sub(dev, prev_val, now, top) == 1) {
    910e:	9900      	ldr	r1, [sp, #0]
    9110:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    p_reg->EVTENSET = mask;
    9114:	9b02      	ldr	r3, [sp, #8]
    9116:	f8c6 3344 	str.w	r3, [r6, #836]	; 0x344
    911a:	4620      	mov	r0, r4
    911c:	463b      	mov	r3, r7
    911e:	f7ff fec7 	bl	8eb0 <ticks_sub>
    9122:	2801      	cmp	r0, #1
    9124:	d106      	bne.n	9134 <set_channel_alarm+0xc4>
		NRFX_DELAY_US(15);
    9126:	200f      	movs	r0, #15
    9128:	f000 f9f3 	bl	9512 <nrfx_busy_wait>
		nrf_rtc_event_clear(rtc, evt);
    912c:	4651      	mov	r1, sl
    912e:	4630      	mov	r0, r6
    9130:	f7ff fe21 	bl	8d76 <nrf_rtc_event_clear>
	if (absolute) {
    9134:	9b03      	ldr	r3, [sp, #12]
     return p_reg->COUNTER;
    9136:	f8d6 a504 	ldr.w	sl, [r6, #1284]	; 0x504
    913a:	b1db      	cbz	r3, 9174 <set_channel_alarm+0x104>
	if (unlikely(val == 0) && (top != COUNTER_MAX_TOP_VALUE)) {
    913c:	b925      	cbnz	r5, 9148 <set_channel_alarm+0xd8>
    913e:	f06f 457f 	mvn.w	r5, #4278190080	; 0xff000000
    9142:	1b7d      	subs	r5, r7, r5
    9144:	bf18      	it	ne
    9146:	2501      	movne	r5, #1
		irq_on_late = flags & COUNTER_ALARM_CFG_EXPIRE_WHEN_LATE;
    9148:	f3cb 0340 	ubfx	r3, fp, #1, #1
    914c:	9300      	str	r3, [sp, #0]
		max_rel_val = top - get_dev_data(dev)->guard_period;
    914e:	68a3      	ldr	r3, [r4, #8]
    9150:	68db      	ldr	r3, [r3, #12]
    9152:	eba7 0b03 	sub.w	fp, r7, r3
	diff = ticks_sub(dev, val, now, top);
    9156:	463b      	mov	r3, r7
    9158:	4652      	mov	r2, sl
    915a:	4629      	mov	r1, r5
    915c:	4620      	mov	r0, r4
    915e:	f7ff fea7 	bl	8eb0 <ticks_sub>
	if (diff == 1) {
    9162:	2801      	cmp	r0, #1
    9164:	d117      	bne.n	9196 <set_channel_alarm+0x126>
		handle_next_tick_case(dev, chan, now, val);
    9166:	462b      	mov	r3, r5
    9168:	4641      	mov	r1, r8
    916a:	4620      	mov	r0, r4
    916c:	f7ff ff4b 	bl	9006 <handle_next_tick_case>
	int err = 0;
    9170:	2700      	movs	r7, #0
    9172:	e02a      	b.n	91ca <set_channel_alarm+0x15a>
		irq_on_late = val < (top / 2);
    9174:	ea4f 0b57 	mov.w	fp, r7, lsr #1
    9178:	455d      	cmp	r5, fp
    917a:	bf34      	ite	cc
    917c:	2301      	movcc	r3, #1
    917e:	2300      	movcs	r3, #0
    9180:	9300      	str	r3, [sp, #0]
		val = ticks_add(dev, now, val, top);
    9182:	462a      	mov	r2, r5
    9184:	463b      	mov	r3, r7
    9186:	4651      	mov	r1, sl
    9188:	4620      	mov	r0, r4
	top =  get_dev_data(dev)->top;
    918a:	bf28      	it	cs
    918c:	46bb      	movcs	fp, r7
		val = ticks_add(dev, now, val, top);
    918e:	f7ff ff20 	bl	8fd2 <ticks_add>
    9192:	4605      	mov	r5, r0
    9194:	e7df      	b.n	9156 <set_channel_alarm+0xe6>
    p_reg->CC[ch] = cc_val;
    9196:	9b01      	ldr	r3, [sp, #4]
    9198:	f8c3 5540 	str.w	r5, [r3, #1344]	; 0x540
     return p_reg->COUNTER;
    919c:	f8d6 a504 	ldr.w	sl, [r6, #1284]	; 0x504
		diff = ticks_sub(dev, val - 1, now, top);
    91a0:	463b      	mov	r3, r7
    91a2:	4652      	mov	r2, sl
    91a4:	1e69      	subs	r1, r5, #1
    91a6:	4620      	mov	r0, r4
    91a8:	f7ff fe82 	bl	8eb0 <ticks_sub>
		if (diff > max_rel_val) {
    91ac:	4558      	cmp	r0, fp
		diff = ticks_sub(dev, val - 1, now, top);
    91ae:	4607      	mov	r7, r0
		if (diff > max_rel_val) {
    91b0:	d916      	bls.n	91e0 <set_channel_alarm+0x170>
			if (absolute) {
    91b2:	9b03      	ldr	r3, [sp, #12]
    91b4:	2b00      	cmp	r3, #0
			if (irq_on_late) {
    91b6:	9b00      	ldr	r3, [sp, #0]
				err = -ETIME;
    91b8:	bf0c      	ite	eq
    91ba:	2700      	moveq	r7, #0
    91bc:	f06f 074e 	mvnne.w	r7, #78	; 0x4e
			if (irq_on_late) {
    91c0:	b13b      	cbz	r3, 91d2 <set_channel_alarm+0x162>
				set_cc_int_pending(dev, chan);
    91c2:	4641      	mov	r1, r8
    91c4:	4620      	mov	r0, r4
    91c6:	f7f9 fad5 	bl	2774 <set_cc_int_pending>
}
    91ca:	4638      	mov	r0, r7
    91cc:	b005      	add	sp, #20
    91ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return CONTAINER_OF(dev->config->config_info,
    91d2:	6823      	ldr	r3, [r4, #0]
				get_nrfx_config(dev)->ch_data[chan].callback =
    91d4:	9a00      	ldr	r2, [sp, #0]
    91d6:	689b      	ldr	r3, [r3, #8]
    91d8:	68db      	ldr	r3, [r3, #12]
    91da:	f843 2039 	str.w	r2, [r3, r9, lsl #3]
    91de:	e7f4      	b.n	91ca <set_channel_alarm+0x15a>
		} else if (diff == 0) {
    91e0:	b928      	cbnz	r0, 91ee <set_channel_alarm+0x17e>
			handle_next_tick_case(dev, chan, now, val);
    91e2:	462b      	mov	r3, r5
    91e4:	4641      	mov	r1, r8
    91e6:	4620      	mov	r0, r4
    91e8:	f7ff ff0d 	bl	9006 <handle_next_tick_case>
    91ec:	e7ed      	b.n	91ca <set_channel_alarm+0x15a>
    p_reg->INTENSET = mask;
    91ee:	9b02      	ldr	r3, [sp, #8]
    91f0:	f8c6 3304 	str.w	r3, [r6, #772]	; 0x304
    91f4:	e7bc      	b.n	9170 <set_channel_alarm+0x100>
		return -EINVAL;
    91f6:	f06f 0715 	mvn.w	r7, #21
    91fa:	e7e6      	b.n	91ca <set_channel_alarm+0x15a>
		return -EBUSY;
    91fc:	f06f 070f 	mvn.w	r7, #15
    9200:	e7e3      	b.n	91ca <set_channel_alarm+0x15a>

00009202 <gpio_nrfx_write>:
{
    9202:	b510      	push	{r4, lr}
	return port->config->config_info;
    9204:	6804      	ldr	r4, [r0, #0]
    9206:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    9208:	68a4      	ldr	r4, [r4, #8]
    920a:	69c0      	ldr	r0, [r0, #28]
    920c:	6824      	ldr	r4, [r4, #0]
	if (access_op == GPIO_ACCESS_BY_PORT) {
    920e:	2901      	cmp	r1, #1
    9210:	d104      	bne.n	921c <gpio_nrfx_write+0x1a>
		nrf_gpio_port_out_write(reg, value ^ data->inverted);
    9212:	4058      	eors	r0, r3
    p_reg->OUT = value;
    9214:	f8c4 0504 	str.w	r0, [r4, #1284]	; 0x504
}
    9218:	2000      	movs	r0, #0
    921a:	bd10      	pop	{r4, pc}
		if ((value > 0) ^ ((BIT(pin) & data->inverted) != 0)) {
    921c:	3300      	adds	r3, #0
    921e:	fa20 f002 	lsr.w	r0, r0, r2
    9222:	f04f 0101 	mov.w	r1, #1
    9226:	bf18      	it	ne
    9228:	2301      	movne	r3, #1
    922a:	f000 0001 	and.w	r0, r0, #1
    922e:	4091      	lsls	r1, r2
    9230:	4283      	cmp	r3, r0
    p_reg->OUTSET = set_mask;
    9232:	bf14      	ite	ne
    9234:	f8c4 1508 	strne.w	r1, [r4, #1288]	; 0x508
    p_reg->OUTCLR = clr_mask;
    9238:	f8c4 150c 	streq.w	r1, [r4, #1292]	; 0x50c
    923c:	e7ec      	b.n	9218 <gpio_nrfx_write+0x16>

0000923e <gpio_nrfx_read>:
{
    923e:	b570      	push	{r4, r5, r6, lr}
	return port->config->config_info;
    9240:	6804      	ldr	r4, [r0, #0]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
    9242:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    9244:	68a4      	ldr	r4, [r4, #8]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
    9246:	69c0      	ldr	r0, [r0, #28]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    9248:	6825      	ldr	r5, [r4, #0]
    return p_reg->DIR;
    924a:	f8d5 6514 	ldr.w	r6, [r5, #1300]	; 0x514
    return p_reg->IN;
    924e:	f8d5 4510 	ldr.w	r4, [r5, #1296]	; 0x510
    return p_reg->OUT;
    9252:	f8d5 5504 	ldr.w	r5, [r5, #1284]	; 0x504
	u32_t port_val = (port_in | port_out) ^ data->inverted;
    9256:	4060      	eors	r0, r4
    9258:	406c      	eors	r4, r5
    925a:	4034      	ands	r4, r6
    925c:	4060      	eors	r0, r4
	if (access_op == GPIO_ACCESS_BY_PORT) {
    925e:	2901      	cmp	r1, #1
		*value = (port_val & BIT(pin)) ? 1 : 0;
    9260:	bf1c      	itt	ne
    9262:	40d0      	lsrne	r0, r2
    9264:	f000 0001 	andne.w	r0, r0, #1
    9268:	6018      	str	r0, [r3, #0]
}
    926a:	2000      	movs	r0, #0
    926c:	bd70      	pop	{r4, r5, r6, pc}

0000926e <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
    926e:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_IS_EMPTY(slist)
    9270:	6818      	ldr	r0, [r3, #0]
{
    9272:	b530      	push	{r4, r5, lr}
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
    9274:	b158      	cbz	r0, 928e <gpio_nrfx_manage_callback+0x20>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    9276:	2400      	movs	r4, #0
    9278:	4281      	cmp	r1, r0
    927a:	d113      	bne.n	92a4 <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
    927c:	6808      	ldr	r0, [r1, #0]
    927e:	b95c      	cbnz	r4, 9298 <gpio_nrfx_manage_callback+0x2a>
    9280:	685c      	ldr	r4, [r3, #4]
	list->head = node;
    9282:	6018      	str	r0, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
    9284:	42a1      	cmp	r1, r4
    9286:	d100      	bne.n	928a <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
    9288:	6058      	str	r0, [r3, #4]
	parent->next = child;
    928a:	2000      	movs	r0, #0
    928c:	6008      	str	r0, [r1, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
    928e:	b972      	cbnz	r2, 92ae <gpio_nrfx_manage_callback+0x40>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
    9290:	2000      	movs	r0, #0
}
    9292:	bd30      	pop	{r4, r5, pc}
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    9294:	4628      	mov	r0, r5
    9296:	e7ef      	b.n	9278 <gpio_nrfx_manage_callback+0xa>
	parent->next = child;
    9298:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
    929a:	6858      	ldr	r0, [r3, #4]
    929c:	4281      	cmp	r1, r0
	list->tail = node;
    929e:	bf08      	it	eq
    92a0:	605c      	streq	r4, [r3, #4]
    92a2:	e7f2      	b.n	928a <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    92a4:	6805      	ldr	r5, [r0, #0]
	return node->next;
    92a6:	4604      	mov	r4, r0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    92a8:	2d00      	cmp	r5, #0
    92aa:	d1f3      	bne.n	9294 <gpio_nrfx_manage_callback+0x26>
			if (!set) {
    92ac:	b13a      	cbz	r2, 92be <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
    92ae:	681a      	ldr	r2, [r3, #0]
	parent->next = child;
    92b0:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
    92b2:	6858      	ldr	r0, [r3, #4]
	list->head = node;
    92b4:	6019      	str	r1, [r3, #0]
Z_GENLIST_PREPEND(slist, snode)
    92b6:	2800      	cmp	r0, #0
    92b8:	d1ea      	bne.n	9290 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
    92ba:	6059      	str	r1, [r3, #4]
    92bc:	e7e9      	b.n	9292 <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
    92be:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
    92c2:	e7e6      	b.n	9292 <gpio_nrfx_manage_callback+0x24>

000092c4 <gpio_nrfx_config>:
{
    92c4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    92c8:	4680      	mov	r8, r0
	struct gpio_nrfx_data *data = get_port_data(port);
    92ca:	6885      	ldr	r5, [r0, #8]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
    92cc:	f403 4070 	and.w	r0, r3, #61440	; 0xf000
    92d0:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
{
    92d4:	461e      	mov	r6, r3
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
    92d6:	d041      	beq.n	935c <gpio_nrfx_config+0x98>
    92d8:	dc09      	bgt.n	92ee <gpio_nrfx_config+0x2a>
    92da:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
    92de:	d03f      	beq.n	9360 <gpio_nrfx_config+0x9c>
    92e0:	f5b0 5f40 	cmp.w	r0, #12288	; 0x3000
    92e4:	d03e      	beq.n	9364 <gpio_nrfx_config+0xa0>
    92e6:	b190      	cbz	r0, 930e <gpio_nrfx_config+0x4a>
		return -EINVAL;
    92e8:	f06f 0015 	mvn.w	r0, #21
    92ec:	e033      	b.n	9356 <gpio_nrfx_config+0x92>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
    92ee:	f5b0 4fe0 	cmp.w	r0, #28672	; 0x7000
    92f2:	d039      	beq.n	9368 <gpio_nrfx_config+0xa4>
    92f4:	dc04      	bgt.n	9300 <gpio_nrfx_config+0x3c>
    92f6:	f5b0 4fa0 	cmp.w	r0, #20480	; 0x5000
    92fa:	d1f5      	bne.n	92e8 <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0H1;
    92fc:	2003      	movs	r0, #3
    92fe:	e006      	b.n	930e <gpio_nrfx_config+0x4a>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
    9300:	f5b0 4f40 	cmp.w	r0, #49152	; 0xc000
    9304:	d032      	beq.n	936c <gpio_nrfx_config+0xa8>
    9306:	f5b0 4f50 	cmp.w	r0, #53248	; 0xd000
    930a:	d1ed      	bne.n	92e8 <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0D1;
    930c:	2007      	movs	r0, #7
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
    930e:	f406 7740 	and.w	r7, r6, #768	; 0x300
    9312:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
    9316:	d02b      	beq.n	9370 <gpio_nrfx_config+0xac>
		pull = NRF_GPIO_PIN_NOPULL;
    9318:	f5a7 7400 	sub.w	r4, r7, #512	; 0x200
    931c:	4263      	negs	r3, r4
    931e:	4163      	adcs	r3, r4
	dir = ((flags & GPIO_DIR_MASK) == GPIO_DIR_OUT)
    9320:	f006 0c01 	and.w	ip, r6, #1
                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
    9324:	ea4f 074c 	mov.w	r7, ip, lsl #1
	if (access_op == GPIO_ACCESS_BY_PORT) {
    9328:	2901      	cmp	r1, #1
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
    932a:	ea47 070c 	orr.w	r7, r7, ip
		from_pin = pin;
    932e:	bf18      	it	ne
    9330:	b2d4      	uxtbne	r4, r2
    9332:	ea47 2000 	orr.w	r0, r7, r0, lsl #8
    9336:	ea40 0783 	orr.w	r7, r0, r3, lsl #2
		to_pin   = pin;
    933a:	bf12      	itee	ne
    933c:	46a1      	movne	r9, r4
		to_pin   = 31U;
    933e:	f04f 091f 	moveq.w	r9, #31
		from_pin = 0U;
    9342:	2400      	moveq	r4, #0
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    9344:	f04f 4aa0 	mov.w	sl, #1342177280	; 0x50000000
    9348:	f04f 0b01 	mov.w	fp, #1
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
    934c:	f006 0302 	and.w	r3, r6, #2
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    9350:	45a1      	cmp	r9, r4
    9352:	d20f      	bcs.n	9374 <gpio_nrfx_config+0xb0>
	return 0;
    9354:	2000      	movs	r0, #0
}
    9356:	b003      	add	sp, #12
    9358:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		drive = NRF_GPIO_PIN_S0H1;
    935c:	2002      	movs	r0, #2
    935e:	e7d6      	b.n	930e <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_H0S1;
    9360:	2001      	movs	r0, #1
    9362:	e7d4      	b.n	930e <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0S1;
    9364:	2004      	movs	r0, #4
    9366:	e7d2      	b.n	930e <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0H1;
    9368:	2005      	movs	r0, #5
    936a:	e7d0      	b.n	930e <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_S0D1;
    936c:	2006      	movs	r0, #6
    936e:	e7ce      	b.n	930e <gpio_nrfx_config+0x4a>
		pull = NRF_GPIO_PIN_PULLUP;
    9370:	2303      	movs	r3, #3
    9372:	e7d5      	b.n	9320 <gpio_nrfx_config+0x5c>
	return port->config->config_info;
    9374:	f8d8 2000 	ldr.w	r2, [r8]
		nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num,
    9378:	6892      	ldr	r2, [r2, #8]
    937a:	7911      	ldrb	r1, [r2, #4]
    937c:	f004 021f 	and.w	r2, r4, #31
    9380:	ea42 1241 	orr.w	r2, r2, r1, lsl #5
    9384:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
    9388:	f84a 7022 	str.w	r7, [sl, r2, lsl #2]
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
    938c:	fa0b f204 	lsl.w	r2, fp, r4
    9390:	68a9      	ldr	r1, [r5, #8]
    9392:	2b00      	cmp	r3, #0
    9394:	d025      	beq.n	93e2 <gpio_nrfx_config+0x11e>
    9396:	4311      	orrs	r1, r2
    9398:	60a9      	str	r1, [r5, #8]
		WRITE_BIT(data->trig_edge, curr_pin, flags & GPIO_INT_EDGE);
    939a:	6969      	ldr	r1, [r5, #20]
    939c:	9301      	str	r3, [sp, #4]
    939e:	06b0      	lsls	r0, r6, #26
    93a0:	bf4c      	ite	mi
    93a2:	4311      	orrmi	r1, r2
    93a4:	4391      	bicpl	r1, r2
    93a6:	6169      	str	r1, [r5, #20]
		WRITE_BIT(data->double_edge, curr_pin,
    93a8:	69a9      	ldr	r1, [r5, #24]
    93aa:	0670      	lsls	r0, r6, #25
    93ac:	bf4c      	ite	mi
    93ae:	4311      	orrmi	r1, r2
    93b0:	4391      	bicpl	r1, r2
    93b2:	61a9      	str	r1, [r5, #24]
		WRITE_BIT(data->active_level, curr_pin,
    93b4:	6929      	ldr	r1, [r5, #16]
    93b6:	0770      	lsls	r0, r6, #29
    93b8:	bf4c      	ite	mi
    93ba:	4311      	orrmi	r1, r2
    93bc:	4391      	bicpl	r1, r2
    93be:	6129      	str	r1, [r5, #16]
		WRITE_BIT(data->inverted, curr_pin, flags & GPIO_POL_INV);
    93c0:	69e9      	ldr	r1, [r5, #28]
    93c2:	0630      	lsls	r0, r6, #24
    93c4:	bf4c      	ite	mi
    93c6:	430a      	orrmi	r2, r1
    93c8:	ea21 0202 	bicpl.w	r2, r1, r2
    93cc:	61ea      	str	r2, [r5, #28]
		res = gpiote_pin_int_cfg(port, curr_pin);
    93ce:	4621      	mov	r1, r4
    93d0:	4640      	mov	r0, r8
    93d2:	f7f9 fa0d 	bl	27f0 <gpiote_pin_int_cfg>
		if (res != 0) {
    93d6:	2800      	cmp	r0, #0
    93d8:	d1bd      	bne.n	9356 <gpio_nrfx_config+0x92>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    93da:	3401      	adds	r4, #1
    93dc:	b2e4      	uxtb	r4, r4
    93de:	9b01      	ldr	r3, [sp, #4]
    93e0:	e7b6      	b.n	9350 <gpio_nrfx_config+0x8c>
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
    93e2:	ea21 0102 	bic.w	r1, r1, r2
    93e6:	e7d7      	b.n	9398 <gpio_nrfx_config+0xd4>

000093e8 <gpio_nrfx_pin_disable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
    93e8:	2901      	cmp	r1, #1
{
    93ea:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
    93ee:	bf18      	it	ne
    93f0:	b2d4      	uxtbne	r4, r2
	struct gpio_nrfx_data *data = get_port_data(port);
    93f2:	6887      	ldr	r7, [r0, #8]
{
    93f4:	4606      	mov	r6, r0
		to_pin   = pin;
    93f6:	bf12      	itee	ne
    93f8:	4625      	movne	r5, r4
		to_pin   = 31U;
    93fa:	251f      	moveq	r5, #31
		from_pin = 0U;
    93fc:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
    93fe:	f04f 0801 	mov.w	r8, #1
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    9402:	42ac      	cmp	r4, r5
    9404:	d902      	bls.n	940c <gpio_nrfx_pin_disable_callback+0x24>
	return res;
    9406:	2000      	movs	r0, #0
}
    9408:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
    940c:	68fb      	ldr	r3, [r7, #12]
    940e:	fa08 f204 	lsl.w	r2, r8, r4
    9412:	ea23 0302 	bic.w	r3, r3, r2
    9416:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
    9418:	4621      	mov	r1, r4
    941a:	4630      	mov	r0, r6
    941c:	f7f9 f9e8 	bl	27f0 <gpiote_pin_int_cfg>
		if (res != 0) {
    9420:	2800      	cmp	r0, #0
    9422:	d1f1      	bne.n	9408 <gpio_nrfx_pin_disable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    9424:	3401      	adds	r4, #1
    9426:	b2e4      	uxtb	r4, r4
    9428:	e7eb      	b.n	9402 <gpio_nrfx_pin_disable_callback+0x1a>

0000942a <gpio_nrfx_pin_enable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
    942a:	2901      	cmp	r1, #1
{
    942c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
    9430:	bf18      	it	ne
    9432:	b2d4      	uxtbne	r4, r2
	struct gpio_nrfx_data *data = get_port_data(port);
    9434:	6887      	ldr	r7, [r0, #8]
{
    9436:	4606      	mov	r6, r0
		to_pin   = pin;
    9438:	bf12      	itee	ne
    943a:	4625      	movne	r5, r4
		to_pin   = 31U;
    943c:	251f      	moveq	r5, #31
		from_pin = 0U;
    943e:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
    9440:	f04f 0801 	mov.w	r8, #1
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    9444:	42ac      	cmp	r4, r5
    9446:	d902      	bls.n	944e <gpio_nrfx_pin_enable_callback+0x24>
	return res;
    9448:	2000      	movs	r0, #0
}
    944a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
    944e:	68fb      	ldr	r3, [r7, #12]
    9450:	fa08 f204 	lsl.w	r2, r8, r4
    9454:	4313      	orrs	r3, r2
    9456:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
    9458:	4621      	mov	r1, r4
    945a:	4630      	mov	r0, r6
    945c:	f7f9 f9c8 	bl	27f0 <gpiote_pin_int_cfg>
		if (res != 0) {
    9460:	2800      	cmp	r0, #0
    9462:	d1f2      	bne.n	944a <gpio_nrfx_pin_enable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    9464:	3401      	adds	r4, #1
    9466:	b2e4      	uxtb	r4, r4
    9468:	e7ec      	b.n	9444 <gpio_nrfx_pin_enable_callback+0x1a>

0000946a <gpio_pin_write>:
{
    946a:	b410      	push	{r4}
    946c:	4613      	mov	r3, r2
	return api->write(port, access_op, pin, value);
    946e:	6842      	ldr	r2, [r0, #4]
    9470:	6854      	ldr	r4, [r2, #4]
    9472:	460a      	mov	r2, r1
    9474:	46a4      	mov	ip, r4
    9476:	2100      	movs	r1, #0
}
    9478:	bc10      	pop	{r4}
	return api->write(port, access_op, pin, value);
    947a:	4760      	bx	ip

0000947c <_spi_context_cs_control.isra.7>:
static inline void _spi_context_cs_control(struct spi_context *ctx,
    947c:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
    947e:	6804      	ldr	r4, [r0, #0]
static inline void _spi_context_cs_control(struct spi_context *ctx,
    9480:	4605      	mov	r5, r0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
    9482:	b324      	cbz	r4, 94ce <_spi_context_cs_control.isra.7+0x52>
    9484:	68a3      	ldr	r3, [r4, #8]
    9486:	b313      	cbz	r3, 94ce <_spi_context_cs_control.isra.7+0x52>
    9488:	6818      	ldr	r0, [r3, #0]
    948a:	b300      	cbz	r0, 94ce <_spi_context_cs_control.isra.7+0x52>
		if (on) {
    948c:	b161      	cbz	r1, 94a8 <_spi_context_cs_control.isra.7+0x2c>
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
    948e:	f9b4 2004 	ldrsh.w	r2, [r4, #4]
			gpio_pin_write(ctx->config->cs->gpio_dev,
    9492:	6859      	ldr	r1, [r3, #4]
    9494:	0fd2      	lsrs	r2, r2, #31
    9496:	f7ff ffe8 	bl	946a <gpio_pin_write>
			k_busy_wait(ctx->config->cs->delay);
    949a:	682b      	ldr	r3, [r5, #0]
    949c:	689b      	ldr	r3, [r3, #8]
    949e:	6898      	ldr	r0, [r3, #8]
}
    94a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_busy_wait(usec_to_wait);
    94a4:	f002 bcdb 	b.w	be5e <z_impl_k_busy_wait>
			if (!force_off &&
    94a8:	b912      	cbnz	r2, 94b0 <_spi_context_cs_control.isra.7+0x34>
    94aa:	88a2      	ldrh	r2, [r4, #4]
    94ac:	0492      	lsls	r2, r2, #18
    94ae:	d40e      	bmi.n	94ce <_spi_context_cs_control.isra.7+0x52>
			k_busy_wait(ctx->config->cs->delay);
    94b0:	6898      	ldr	r0, [r3, #8]
    94b2:	f002 fcd4 	bl	be5e <z_impl_k_busy_wait>
			gpio_pin_write(ctx->config->cs->gpio_dev,
    94b6:	682a      	ldr	r2, [r5, #0]
    94b8:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
    94ba:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
			gpio_pin_write(ctx->config->cs->gpio_dev,
    94be:	43d2      	mvns	r2, r2
    94c0:	e9d3 0100 	ldrd	r0, r1, [r3]
    94c4:	0fd2      	lsrs	r2, r2, #31
}
    94c6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gpio_pin_write(ctx->config->cs->gpio_dev,
    94ca:	f7ff bfce 	b.w	946a <gpio_pin_write>
}
    94ce:	bd38      	pop	{r3, r4, r5, pc}

000094d0 <spi_context_unlock_unconditionally>:
{
    94d0:	b510      	push	{r4, lr}
	_spi_context_cs_control(ctx, false, true);
    94d2:	2201      	movs	r2, #1
    94d4:	2100      	movs	r1, #0
{
    94d6:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
    94d8:	f7ff ffd0 	bl	947c <_spi_context_cs_control.isra.7>
	if (!k_sem_count_get(&ctx->lock)) {
    94dc:	68e3      	ldr	r3, [r4, #12]
    94de:	b923      	cbnz	r3, 94ea <spi_context_unlock_unconditionally+0x1a>
	z_impl_k_sem_give(sem);
    94e0:	1d20      	adds	r0, r4, #4
}
    94e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    94e6:	f7fe bad5 	b.w	7a94 <z_impl_k_sem_give>
    94ea:	bd10      	pop	{r4, pc}

000094ec <spi_nrfx_release>:
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    94ec:	6880      	ldr	r0, [r0, #8]
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
    94ee:	6803      	ldr	r3, [r0, #0]
    94f0:	428b      	cmp	r3, r1
{
    94f2:	b510      	push	{r4, lr}
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
    94f4:	d106      	bne.n	9504 <spi_nrfx_release+0x18>
	if (dev_data->busy) {
    94f6:	f890 404c 	ldrb.w	r4, [r0, #76]	; 0x4c
    94fa:	b934      	cbnz	r4, 950a <spi_nrfx_release+0x1e>
	spi_context_unlock_unconditionally(&dev_data->ctx);
    94fc:	f7ff ffe8 	bl	94d0 <spi_context_unlock_unconditionally>
	return 0;
    9500:	4620      	mov	r0, r4
}
    9502:	bd10      	pop	{r4, pc}
		return -EINVAL;
    9504:	f06f 0015 	mvn.w	r0, #21
    9508:	e7fb      	b.n	9502 <spi_nrfx_release+0x16>
		return -EBUSY;
    950a:	f06f 000f 	mvn.w	r0, #15
    950e:	e7f8      	b.n	9502 <spi_nrfx_release+0x16>

00009510 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
    9510:	4700      	bx	r0

00009512 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
    9512:	f002 bca4 	b.w	be5e <z_impl_k_busy_wait>

00009516 <transfer_byte>:
{
    9516:	b537      	push	{r0, r1, r2, r4, r5, lr}
    return p_reg->RXD;
    9518:	f8d0 3518 	ldr.w	r3, [r0, #1304]	; 0x518
    if (p_cb->bytes_transferred < p_cb->evt.xfer_desc.rx_length)
    951c:	698a      	ldr	r2, [r1, #24]
    951e:	b2db      	uxtb	r3, r3
    volatile uint8_t rx_data = nrf_spi_rxd_get(p_spi);
    9520:	f88d 3007 	strb.w	r3, [sp, #7]
    if (p_cb->bytes_transferred < p_cb->evt.xfer_desc.rx_length)
    9524:	6a4b      	ldr	r3, [r1, #36]	; 0x24
    9526:	4293      	cmp	r3, r2
        p_cb->evt.xfer_desc.p_rx_buffer[p_cb->bytes_transferred] = rx_data;
    9528:	bf3e      	ittt	cc
    952a:	694a      	ldrcc	r2, [r1, #20]
    952c:	f89d 4007 	ldrbcc.w	r4, [sp, #7]
    9530:	54d4      	strbcc	r4, [r2, r3]
    ++p_cb->bytes_transferred;
    9532:	6a4a      	ldr	r2, [r1, #36]	; 0x24
    if (p_cb->abort)
    9534:	f891 4028 	ldrb.w	r4, [r1, #40]	; 0x28
    ++p_cb->bytes_transferred;
    9538:	1c53      	adds	r3, r2, #1
    953a:	624b      	str	r3, [r1, #36]	; 0x24
    size_t bytes_used = p_cb->bytes_transferred + 1;
    953c:	3202      	adds	r2, #2
    if (p_cb->abort)
    953e:	b13c      	cbz	r4, 9550 <transfer_byte+0x3a>
        if (bytes_used < p_cb->evt.xfer_desc.tx_length)
    9540:	690c      	ldr	r4, [r1, #16]
    9542:	42a2      	cmp	r2, r4
        if (bytes_used < p_cb->evt.xfer_desc.rx_length)
    9544:	698c      	ldr	r4, [r1, #24]
            p_cb->evt.xfer_desc.tx_length = bytes_used;
    9546:	bf38      	it	cc
    9548:	610a      	strcc	r2, [r1, #16]
        if (bytes_used < p_cb->evt.xfer_desc.rx_length)
    954a:	4294      	cmp	r4, r2
            p_cb->evt.xfer_desc.rx_length = bytes_used;
    954c:	bf88      	it	hi
    954e:	618a      	strhi	r2, [r1, #24]
    if (bytes_used < p_cb->evt.xfer_desc.tx_length)
    9550:	690d      	ldr	r5, [r1, #16]
    9552:	4295      	cmp	r5, r2
    9554:	d905      	bls.n	9562 <transfer_byte+0x4c>
        nrf_spi_txd_set(p_spi, p_cb->evt.xfer_desc.p_tx_buffer[bytes_used]);
    9556:	68cb      	ldr	r3, [r1, #12]
    p_reg->TXD = data;
    9558:	5c9b      	ldrb	r3, [r3, r2]
    955a:	f8c0 351c 	str.w	r3, [r0, #1308]	; 0x51c
    return (p_cb->bytes_transferred < p_cb->evt.xfer_desc.tx_length ||
    955e:	2001      	movs	r0, #1
    9560:	e00b      	b.n	957a <transfer_byte+0x64>
    else if (bytes_used < p_cb->evt.xfer_desc.rx_length)
    9562:	698c      	ldr	r4, [r1, #24]
    9564:	4294      	cmp	r4, r2
    9566:	d902      	bls.n	956e <transfer_byte+0x58>
    9568:	f891 3020 	ldrb.w	r3, [r1, #32]
    956c:	e7f5      	b.n	955a <transfer_byte+0x44>
    return (p_cb->bytes_transferred < p_cb->evt.xfer_desc.tx_length ||
    956e:	42ab      	cmp	r3, r5
    9570:	d3f5      	bcc.n	955e <transfer_byte+0x48>
    9572:	42a3      	cmp	r3, r4
    9574:	bf2c      	ite	cs
    9576:	2000      	movcs	r0, #0
    9578:	2001      	movcc	r0, #1
}
    957a:	b003      	add	sp, #12
    957c:	bd30      	pop	{r4, r5, pc}

0000957e <nrf_twi_event_clear>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    957e:	2300      	movs	r3, #0
    9580:	5043      	str	r3, [r0, r1]
{
    9582:	b082      	sub	sp, #8
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    9584:	5843      	ldr	r3, [r0, r1]
    9586:	9301      	str	r3, [sp, #4]
    (void)dummy;
    9588:	9b01      	ldr	r3, [sp, #4]
}
    958a:	b002      	add	sp, #8
    958c:	4770      	bx	lr

0000958e <twi_send_byte>:
    if (p_cb->bytes_transferred < p_cb->curr_length)
    958e:	6b4b      	ldr	r3, [r1, #52]	; 0x34
    9590:	6a8a      	ldr	r2, [r1, #40]	; 0x28
    9592:	4293      	cmp	r3, r2
    9594:	d208      	bcs.n	95a8 <twi_send_byte+0x1a>
        nrf_twi_txd_set(p_twi, p_cb->p_curr_buf[p_cb->bytes_transferred]);
    9596:	6a4a      	ldr	r2, [r1, #36]	; 0x24
    p_reg->TXD = data;
    9598:	5cd2      	ldrb	r2, [r2, r3]
    959a:	f8c0 251c 	str.w	r2, [r0, #1308]	; 0x51c
        ++(p_cb->bytes_transferred);
    959e:	3301      	adds	r3, #1
    95a0:	634b      	str	r3, [r1, #52]	; 0x34
    return true;
    95a2:	2301      	movs	r3, #1
}
    95a4:	4618      	mov	r0, r3
    95a6:	4770      	bx	lr
        if (p_cb->curr_tx_no_stop)
    95a8:	f891 302c 	ldrb.w	r3, [r1, #44]	; 0x2c
    95ac:	b11b      	cbz	r3, 95b6 <twi_send_byte+0x28>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    95ae:	2301      	movs	r3, #1
    95b0:	61c3      	str	r3, [r0, #28]
            return false;
    95b2:	2300      	movs	r3, #0
    95b4:	e7f6      	b.n	95a4 <twi_send_byte+0x16>
        else if(TWI_FLAG_SUSPEND(p_cb->flags))
    95b6:	6a0a      	ldr	r2, [r1, #32]
    95b8:	f012 0f40 	tst.w	r2, #64	; 0x40
    95bc:	f04f 0201 	mov.w	r2, #1
    95c0:	bf15      	itete	ne
    95c2:	61c2      	strne	r2, [r0, #28]
    95c4:	6142      	streq	r2, [r0, #20]
            p_cb->prev_suspend = TWI_SUSPEND_TX;
    95c6:	f881 202d 	strbne.w	r2, [r1, #45]	; 0x2d
    return true;
    95ca:	4613      	moveq	r3, r2
    95cc:	e7ea      	b.n	95a4 <twi_send_byte+0x16>

000095ce <twi_transfer>:
    bool do_stop_check = ((p_cb->error) || ((p_cb->bytes_transferred) == p_cb->curr_length));
    95ce:	f891 202f 	ldrb.w	r2, [r1, #47]	; 0x2f
{
    95d2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    95d4:	4604      	mov	r4, r0
    95d6:	460d      	mov	r5, r1
    bool do_stop_check = ((p_cb->error) || ((p_cb->bytes_transferred) == p_cb->curr_length));
    95d8:	2a00      	cmp	r2, #0
    95da:	d160      	bne.n	969e <twi_transfer+0xd0>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    95dc:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
    95e0:	6b4e      	ldr	r6, [r1, #52]	; 0x34
    95e2:	6a8f      	ldr	r7, [r1, #40]	; 0x28
    else if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_ERROR))
    95e4:	b1b3      	cbz	r3, 9614 <twi_transfer+0x46>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
    95e6:	f44f 7192 	mov.w	r1, #292	; 0x124
                nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
    95ea:	f7ff ffc8 	bl	957e <nrf_twi_event_clear>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    95ee:	2301      	movs	r3, #1
    95f0:	6163      	str	r3, [r4, #20]
                p_cb->error = true;
    95f2:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    if (do_stop_check && nrf_twi_event_check(p_twi, NRF_TWI_EVENT_STOPPED))
    95f6:	42be      	cmp	r6, r7
    95f8:	d14f      	bne.n	969a <twi_transfer+0xcc>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    95fa:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    95fe:	2b00      	cmp	r3, #0
    9600:	d04b      	beq.n	969a <twi_transfer+0xcc>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
    9602:	f44f 7182 	mov.w	r1, #260	; 0x104
    9606:	4620      	mov	r0, r4
    9608:	f7ff ffb9 	bl	957e <nrf_twi_event_clear>
        p_cb->prev_suspend = TWI_NO_SUSPEND;
    960c:	2200      	movs	r2, #0
    960e:	f885 202d 	strb.w	r2, [r5, #45]	; 0x2d
        return false;
    9612:	e013      	b.n	963c <twi_transfer+0x6e>
    9614:	f8d0 311c 	ldr.w	r3, [r0, #284]	; 0x11c
        if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_TXDSENT))
    9618:	b193      	cbz	r3, 9640 <twi_transfer+0x72>
            nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_TXDSENT);
    961a:	f44f 718e 	mov.w	r1, #284	; 0x11c
    961e:	f7ff ffae 	bl	957e <nrf_twi_event_clear>
    9622:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
            if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_ERROR))
    9626:	b11b      	cbz	r3, 9630 <twi_transfer+0x62>
                nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
    9628:	f44f 7192 	mov.w	r1, #292	; 0x124
    962c:	4620      	mov	r0, r4
    962e:	e7dc      	b.n	95ea <twi_transfer+0x1c>
                if (!twi_send_byte(p_twi, p_cb))
    9630:	4629      	mov	r1, r5
    9632:	f7ff ffac 	bl	958e <twi_send_byte>
    9636:	4602      	mov	r2, r0
    9638:	2800      	cmp	r0, #0
    963a:	d1dc      	bne.n	95f6 <twi_transfer+0x28>
}
    963c:	4610      	mov	r0, r2
    963e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9640:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
        else if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_RXDREADY))
    9644:	2b00      	cmp	r3, #0
    9646:	d0d6      	beq.n	95f6 <twi_transfer+0x28>
            nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_RXDREADY);
    9648:	f44f 7184 	mov.w	r1, #264	; 0x108
    964c:	f7ff ff97 	bl	957e <nrf_twi_event_clear>
    9650:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
            if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_ERROR))
    9654:	2b00      	cmp	r3, #0
    9656:	d1e7      	bne.n	9628 <twi_transfer+0x5a>
    if (p_cb->bytes_transferred < p_cb->curr_length)
    9658:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    965a:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    965c:	428b      	cmp	r3, r1
    965e:	d2ca      	bcs.n	95f6 <twi_transfer+0x28>
        p_cb->p_curr_buf[p_cb->bytes_transferred] = nrf_twi_rxd_get(p_twi);
    9660:	6a69      	ldr	r1, [r5, #36]	; 0x24
    return (uint8_t)p_reg->RXD;
    9662:	f8d0 0518 	ldr.w	r0, [r0, #1304]	; 0x518
    9666:	54c8      	strb	r0, [r1, r3]
        ++(p_cb->bytes_transferred);
    9668:	6b6b      	ldr	r3, [r5, #52]	; 0x34
        if ((p_cb->bytes_transferred == p_cb->curr_length - 1) && (!TWI_FLAG_SUSPEND(p_cb->flags)))
    966a:	6aa9      	ldr	r1, [r5, #40]	; 0x28
        ++(p_cb->bytes_transferred);
    966c:	3301      	adds	r3, #1
        if ((p_cb->bytes_transferred == p_cb->curr_length - 1) && (!TWI_FLAG_SUSPEND(p_cb->flags)))
    966e:	1e48      	subs	r0, r1, #1
    9670:	4283      	cmp	r3, r0
        ++(p_cb->bytes_transferred);
    9672:	636b      	str	r3, [r5, #52]	; 0x34
        if ((p_cb->bytes_transferred == p_cb->curr_length - 1) && (!TWI_FLAG_SUSPEND(p_cb->flags)))
    9674:	d108      	bne.n	9688 <twi_transfer+0xba>
    9676:	6a28      	ldr	r0, [r5, #32]
    9678:	0640      	lsls	r0, r0, #25
    967a:	d41d      	bmi.n	96b8 <twi_transfer+0xea>
    p_reg->SHORTS = mask;
    967c:	2302      	movs	r3, #2
    967e:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    9682:	2301      	movs	r3, #1
    9684:	6223      	str	r3, [r4, #32]
    9686:	e7b6      	b.n	95f6 <twi_transfer+0x28>
        else if (p_cb->bytes_transferred == p_cb->curr_length && (!TWI_FLAG_SUSPEND(p_cb->flags)))
    9688:	428b      	cmp	r3, r1
    968a:	d1fa      	bne.n	9682 <twi_transfer+0xb4>
    968c:	6a2b      	ldr	r3, [r5, #32]
    968e:	065b      	lsls	r3, r3, #25
    9690:	d5b1      	bpl.n	95f6 <twi_transfer+0x28>
            p_cb->prev_suspend = TWI_SUSPEND_RX;
    9692:	2302      	movs	r3, #2
    9694:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
            return false;
    9698:	e7d0      	b.n	963c <twi_transfer+0x6e>
    return true;
    969a:	2201      	movs	r2, #1
    969c:	e7ce      	b.n	963c <twi_transfer+0x6e>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
    969e:	f44f 7192 	mov.w	r1, #292	; 0x124
    96a2:	f7ff ff6c 	bl	957e <nrf_twi_event_clear>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_TXDSENT);
    96a6:	f44f 718e 	mov.w	r1, #284	; 0x11c
    96aa:	f7ff ff68 	bl	957e <nrf_twi_event_clear>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_RXDREADY);
    96ae:	f44f 7184 	mov.w	r1, #264	; 0x108
    96b2:	f7ff ff64 	bl	957e <nrf_twi_event_clear>
    if (do_stop_check && nrf_twi_event_check(p_twi, NRF_TWI_EVENT_STOPPED))
    96b6:	e7a0      	b.n	95fa <twi_transfer+0x2c>
        else if (p_cb->bytes_transferred == p_cb->curr_length && (!TWI_FLAG_SUSPEND(p_cb->flags)))
    96b8:	428b      	cmp	r3, r1
    96ba:	d1e2      	bne.n	9682 <twi_transfer+0xb4>
    96bc:	e7e9      	b.n	9692 <twi_transfer+0xc4>

000096be <lv_indev_reset.part.5>:
}
/**
 * Reset one or all input devices
 * @param indev pointer to an input device to reset or NULL to reset all of them
 */
void lv_indev_reset(lv_indev_t * indev)
    96be:	b508      	push	{r3, lr}
{
    if(indev)
        indev->proc.reset_query = 1;
    else {
        lv_indev_t * i = lv_indev_get_next(NULL);
    96c0:	2000      	movs	r0, #0
        while(i) {
            i->proc.reset_query = 1;

            i = lv_indev_get_next(i);
    96c2:	f7fc f947 	bl	5954 <lv_indev_get_next>
        while(i) {
    96c6:	b900      	cbnz	r0, 96ca <lv_indev_reset.part.5+0xc>
        }
    }
}
    96c8:	bd08      	pop	{r3, pc}
            i->proc.reset_query = 1;
    96ca:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
    96ce:	f043 0302 	orr.w	r3, r3, #2
    96d2:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50
    96d6:	e7f4      	b.n	96c2 <lv_indev_reset.part.5+0x4>

000096d8 <lv_indev_init>:
    if(indev)
    96d8:	f7ff bff1 	b.w	96be <lv_indev_reset.part.5>

000096dc <refresh_children_position>:
 * @param obj pointer to an object which children will be repositioned
 * @param x_diff x coordinate shift
 * @param y_diff y coordinate shift
 */
static void refresh_children_position(lv_obj_t * obj, lv_coord_t x_diff, lv_coord_t y_diff)
{
    96dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    lv_obj_t * i;
    LV_LL_READ(obj->child_ll, i)
    96de:	1d07      	adds	r7, r0, #4
    96e0:	4638      	mov	r0, r7
{
    96e2:	460d      	mov	r5, r1
    96e4:	4616      	mov	r6, r2
    LV_LL_READ(obj->child_ll, i)
    96e6:	f001 fef1 	bl	b4cc <lv_ll_get_head>
    96ea:	4604      	mov	r4, r0
    96ec:	b900      	cbnz	r0, 96f0 <refresh_children_position+0x14>
        i->coords.x2 += x_diff;
        i->coords.y2 += y_diff;

        refresh_children_position(i, x_diff, y_diff);
    }
}
    96ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        i->coords.x1 += x_diff;
    96f0:	8a23      	ldrh	r3, [r4, #16]
    96f2:	442b      	add	r3, r5
    96f4:	8223      	strh	r3, [r4, #16]
        i->coords.y1 += y_diff;
    96f6:	8a63      	ldrh	r3, [r4, #18]
    96f8:	4433      	add	r3, r6
    96fa:	8263      	strh	r3, [r4, #18]
        i->coords.x2 += x_diff;
    96fc:	8aa3      	ldrh	r3, [r4, #20]
    96fe:	442b      	add	r3, r5
    9700:	82a3      	strh	r3, [r4, #20]
        i->coords.y2 += y_diff;
    9702:	8ae3      	ldrh	r3, [r4, #22]
    9704:	4433      	add	r3, r6
        refresh_children_position(i, x_diff, y_diff);
    9706:	4629      	mov	r1, r5
    9708:	4620      	mov	r0, r4
        i->coords.y2 += y_diff;
    970a:	82e3      	strh	r3, [r4, #22]
        refresh_children_position(i, x_diff, y_diff);
    970c:	4632      	mov	r2, r6
    970e:	f7ff ffe5 	bl	96dc <refresh_children_position>
    LV_LL_READ(obj->child_ll, i)
    9712:	4621      	mov	r1, r4
    9714:	4638      	mov	r0, r7
    9716:	f001 fedf 	bl	b4d8 <lv_ll_get_next>
    971a:	e7e6      	b.n	96ea <refresh_children_position+0xe>

0000971c <lv_obj_set_click>:
    obj->click = (en == true ? 1 : 0);
    971c:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
    9720:	f361 0300 	bfi	r3, r1, #0, #1
    9724:	f880 302c 	strb.w	r3, [r0, #44]	; 0x2c
}
    9728:	4770      	bx	lr

0000972a <lv_obj_set_signal_cb>:
    obj->signal_cb = signal_cb;
    972a:	61c1      	str	r1, [r0, #28]
}
    972c:	4770      	bx	lr

0000972e <lv_obj_set_design_cb>:
    obj->design_cb = design_cb;
    972e:	6201      	str	r1, [r0, #32]
}
    9730:	4770      	bx	lr

00009732 <lv_obj_allocate_ext_attr>:
{
    9732:	b510      	push	{r4, lr}
    9734:	4604      	mov	r4, r0
    obj->ext_attr = lv_mem_realloc(obj->ext_attr, ext_size);
    9736:	6a40      	ldr	r0, [r0, #36]	; 0x24
    9738:	f7fc fa9a 	bl	5c70 <lv_mem_realloc>
    973c:	6260      	str	r0, [r4, #36]	; 0x24
}
    973e:	bd10      	pop	{r4, pc}

00009740 <lv_obj_invalidate>:
    return obj->hidden == 0 ? false : true;
    9740:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
{
    9744:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    if(lv_obj_get_hidden(obj)) return;
    9746:	06da      	lsls	r2, r3, #27
{
    9748:	4606      	mov	r6, r0
    if(lv_obj_get_hidden(obj)) return;
    974a:	d439      	bmi.n	97c0 <lv_obj_invalidate+0x80>
    974c:	4604      	mov	r4, r0
    return obj->par;
    974e:	6823      	ldr	r3, [r4, #0]
    } while(par != NULL);
    9750:	bb53      	cbnz	r3, 97a8 <lv_obj_invalidate+0x68>
    lv_disp_t * disp   = lv_obj_get_disp(obj_scr);
    9752:	4620      	mov	r0, r4
    9754:	f7fa f9f8 	bl	3b48 <lv_obj_get_disp>
    9758:	4607      	mov	r7, r0
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
    975a:	f7fa f97d 	bl	3a58 <lv_disp_get_scr_act>
    975e:	4284      	cmp	r4, r0
    9760:	d124      	bne.n	97ac <lv_obj_invalidate+0x6c>
    memcpy(dest, src, sizeof(lv_area_t));
    9762:	2208      	movs	r2, #8
    9764:	f106 0110 	add.w	r1, r6, #16
    9768:	4668      	mov	r0, sp
        lv_coord_t ext_size = obj->ext_draw_pad;
    976a:	f9b6 4030 	ldrsh.w	r4, [r6, #48]	; 0x30
    return obj->par;
    976e:	6835      	ldr	r5, [r6, #0]
    9770:	f7ff f8be 	bl	88f0 <memcpy>
        area_trunc.x1 -= ext_size;
    9774:	f8bd 3000 	ldrh.w	r3, [sp]
    9778:	1b1b      	subs	r3, r3, r4
    977a:	f8ad 3000 	strh.w	r3, [sp]
        area_trunc.y1 -= ext_size;
    977e:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    9782:	1b1b      	subs	r3, r3, r4
    9784:	f8ad 3002 	strh.w	r3, [sp, #2]
        area_trunc.x2 += ext_size;
    9788:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    978c:	4423      	add	r3, r4
    978e:	f8ad 3004 	strh.w	r3, [sp, #4]
        area_trunc.y2 += ext_size;
    9792:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    9796:	441c      	add	r4, r3
    9798:	f8ad 4006 	strh.w	r4, [sp, #6]
        while(par != NULL) {
    979c:	b995      	cbnz	r5, 97c4 <lv_obj_invalidate+0x84>
        if(union_ok) lv_inv_area(disp, &area_trunc);
    979e:	4669      	mov	r1, sp
    97a0:	4638      	mov	r0, r7
    97a2:	f000 fb44 	bl	9e2e <lv_inv_area>
    97a6:	e00b      	b.n	97c0 <lv_obj_invalidate+0x80>
    } while(par != NULL);
    97a8:	461c      	mov	r4, r3
    97aa:	e7d0      	b.n	974e <lv_obj_invalidate+0xe>
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
    97ac:	4638      	mov	r0, r7
    97ae:	f7fa f969 	bl	3a84 <lv_disp_get_layer_top>
    97b2:	4284      	cmp	r4, r0
    97b4:	d0d5      	beq.n	9762 <lv_obj_invalidate+0x22>
       obj_scr == lv_disp_get_layer_sys(disp)) {
    97b6:	4638      	mov	r0, r7
    97b8:	f7fa f97a 	bl	3ab0 <lv_disp_get_layer_sys>
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
    97bc:	4284      	cmp	r4, r0
    97be:	d0d0      	beq.n	9762 <lv_obj_invalidate+0x22>
}
    97c0:	b003      	add	sp, #12
    97c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
            union_ok = lv_area_intersect(&area_trunc, &area_trunc, &par->coords);
    97c4:	f105 0210 	add.w	r2, r5, #16
    97c8:	4669      	mov	r1, sp
    97ca:	4668      	mov	r0, sp
    97cc:	f001 fd6f 	bl	b2ae <lv_area_intersect>
            if(union_ok == false) break;       /*If no common parts with parent break;*/
    97d0:	2800      	cmp	r0, #0
    97d2:	d0f5      	beq.n	97c0 <lv_obj_invalidate+0x80>
    return obj->hidden == 0 ? false : true;
    97d4:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
            if(lv_obj_get_hidden(par)) return; /*If the parent is hidden then the child is hidden and won't be drawn*/
    97d8:	06db      	lsls	r3, r3, #27
    97da:	d4f1      	bmi.n	97c0 <lv_obj_invalidate+0x80>
    return obj->par;
    97dc:	682d      	ldr	r5, [r5, #0]
    97de:	e7dd      	b.n	979c <lv_obj_invalidate+0x5c>

000097e0 <lv_obj_set_pos>:
{
    97e0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    lv_obj_t * par = obj->par;
    97e2:	6807      	ldr	r7, [r0, #0]
    diff.x = x - obj->coords.x1;
    97e4:	8a03      	ldrh	r3, [r0, #16]
    97e6:	8a3d      	ldrh	r5, [r7, #16]
    diff.y = y - obj->coords.y1;
    97e8:	8a7e      	ldrh	r6, [r7, #18]
    diff.x = x - obj->coords.x1;
    97ea:	1aed      	subs	r5, r5, r3
    diff.y = y - obj->coords.y1;
    97ec:	8a43      	ldrh	r3, [r0, #18]
    97ee:	1af6      	subs	r6, r6, r3
    diff.x = x - obj->coords.x1;
    97f0:	440d      	add	r5, r1
    diff.y = y - obj->coords.y1;
    97f2:	4416      	add	r6, r2
    diff.x = x - obj->coords.x1;
    97f4:	b22d      	sxth	r5, r5
    diff.y = y - obj->coords.y1;
    97f6:	b236      	sxth	r6, r6
    if(diff.x == 0 && diff.y == 0) return;
    97f8:	ea55 0306 	orrs.w	r3, r5, r6
{
    97fc:	4604      	mov	r4, r0
    if(diff.x == 0 && diff.y == 0) return;
    97fe:	d025      	beq.n	984c <lv_obj_set_pos+0x6c>
    lv_obj_invalidate(obj);
    9800:	f7ff ff9e 	bl	9740 <lv_obj_invalidate>
    9804:	2208      	movs	r2, #8
    9806:	f104 0110 	add.w	r1, r4, #16
    980a:	4668      	mov	r0, sp
    980c:	f7ff f870 	bl	88f0 <memcpy>
    obj->coords.x1 += diff.x;
    9810:	8a23      	ldrh	r3, [r4, #16]
    9812:	442b      	add	r3, r5
    9814:	8223      	strh	r3, [r4, #16]
    obj->coords.y1 += diff.y;
    9816:	8a63      	ldrh	r3, [r4, #18]
    9818:	4433      	add	r3, r6
    981a:	8263      	strh	r3, [r4, #18]
    obj->coords.x2 += diff.x;
    981c:	8aa3      	ldrh	r3, [r4, #20]
    981e:	442b      	add	r3, r5
    9820:	82a3      	strh	r3, [r4, #20]
    obj->coords.y2 += diff.y;
    9822:	8ae3      	ldrh	r3, [r4, #22]
    9824:	4433      	add	r3, r6
    9826:	82e3      	strh	r3, [r4, #22]
    refresh_children_position(obj, diff.x, diff.y);
    9828:	4632      	mov	r2, r6
    982a:	4629      	mov	r1, r5
    982c:	4620      	mov	r0, r4
    982e:	f7ff ff55 	bl	96dc <refresh_children_position>
    obj->signal_cb(obj, LV_SIGNAL_CORD_CHG, &ori);
    9832:	69e3      	ldr	r3, [r4, #28]
    9834:	466a      	mov	r2, sp
    9836:	2102      	movs	r1, #2
    9838:	4620      	mov	r0, r4
    983a:	4798      	blx	r3
    par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
    983c:	69fb      	ldr	r3, [r7, #28]
    983e:	4622      	mov	r2, r4
    9840:	2101      	movs	r1, #1
    9842:	4638      	mov	r0, r7
    9844:	4798      	blx	r3
    lv_obj_invalidate(obj);
    9846:	4620      	mov	r0, r4
    9848:	f7ff ff7a 	bl	9740 <lv_obj_invalidate>
}
    984c:	b003      	add	sp, #12
    984e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00009850 <lv_obj_refresh_style>:
{
    9850:	b510      	push	{r4, lr}
    9852:	4604      	mov	r4, r0
    lv_obj_invalidate(obj);
    9854:	f7ff ff74 	bl	9740 <lv_obj_invalidate>
    obj->signal_cb(obj, LV_SIGNAL_STYLE_CHG, NULL);
    9858:	69e3      	ldr	r3, [r4, #28]
    985a:	4620      	mov	r0, r4
    985c:	2200      	movs	r2, #0
    985e:	2104      	movs	r1, #4
    9860:	4798      	blx	r3
    lv_obj_invalidate(obj);
    9862:	4620      	mov	r0, r4
}
    9864:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    lv_obj_invalidate(obj);
    9868:	f7ff bf6a 	b.w	9740 <lv_obj_invalidate>

0000986c <lv_obj_refresh_ext_draw_pad>:
{
    986c:	b510      	push	{r4, lr}
    obj->ext_draw_pad = 0;
    986e:	2200      	movs	r2, #0
{
    9870:	4604      	mov	r4, r0
    obj->ext_draw_pad = 0;
    9872:	8602      	strh	r2, [r0, #48]	; 0x30
    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);
    9874:	69c3      	ldr	r3, [r0, #28]
    9876:	2106      	movs	r1, #6
    9878:	4798      	blx	r3
    lv_obj_invalidate(obj);
    987a:	4620      	mov	r0, r4
}
    987c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    lv_obj_invalidate(obj);
    9880:	f7ff bf5e 	b.w	9740 <lv_obj_invalidate>

00009884 <lv_obj_set_size>:
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    9884:	8a83      	ldrh	r3, [r0, #20]
{
    9886:	b573      	push	{r0, r1, r4, r5, r6, lr}
    9888:	4616      	mov	r6, r2
    988a:	8a02      	ldrh	r2, [r0, #16]
    988c:	3301      	adds	r3, #1
    988e:	1a9b      	subs	r3, r3, r2
    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {
    9890:	b21b      	sxth	r3, r3
    9892:	428b      	cmp	r3, r1
{
    9894:	4604      	mov	r4, r0
    9896:	460d      	mov	r5, r1
    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {
    9898:	d106      	bne.n	98a8 <lv_obj_set_size+0x24>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    989a:	8ac3      	ldrh	r3, [r0, #22]
    989c:	8a42      	ldrh	r2, [r0, #18]
    989e:	3301      	adds	r3, #1
    98a0:	1a9b      	subs	r3, r3, r2
    98a2:	b21b      	sxth	r3, r3
    98a4:	429e      	cmp	r6, r3
    98a6:	d024      	beq.n	98f2 <lv_obj_set_size+0x6e>
    lv_obj_invalidate(obj);
    98a8:	4620      	mov	r0, r4
    98aa:	f7ff ff49 	bl	9740 <lv_obj_invalidate>
    memcpy(dest, src, sizeof(lv_area_t));
    98ae:	2208      	movs	r2, #8
    98b0:	f104 0110 	add.w	r1, r4, #16
    98b4:	4668      	mov	r0, sp
    98b6:	f7ff f81b 	bl	88f0 <memcpy>
    obj->coords.y2 = obj->coords.y1 + h - 1;
    98ba:	8a63      	ldrh	r3, [r4, #18]
    98bc:	3e01      	subs	r6, #1
    98be:	441e      	add	r6, r3
        obj->coords.x2 = obj->coords.x1 + w - 1;
    98c0:	8a23      	ldrh	r3, [r4, #16]
    obj->coords.y2 = obj->coords.y1 + h - 1;
    98c2:	82e6      	strh	r6, [r4, #22]
        obj->coords.x2 = obj->coords.x1 + w - 1;
    98c4:	3d01      	subs	r5, #1
    98c6:	441d      	add	r5, r3
    98c8:	82a5      	strh	r5, [r4, #20]
    obj->signal_cb(obj, LV_SIGNAL_CORD_CHG, &ori);
    98ca:	69e3      	ldr	r3, [r4, #28]
    98cc:	466a      	mov	r2, sp
    98ce:	2102      	movs	r1, #2
    98d0:	4620      	mov	r0, r4
    98d2:	4798      	blx	r3
    return obj->par;
    98d4:	6820      	ldr	r0, [r4, #0]
    if(par != NULL) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
    98d6:	b118      	cbz	r0, 98e0 <lv_obj_set_size+0x5c>
    98d8:	69c3      	ldr	r3, [r0, #28]
    98da:	4622      	mov	r2, r4
    98dc:	2101      	movs	r1, #1
    98de:	4798      	blx	r3
    LV_LL_READ(obj->child_ll, i)
    98e0:	1d26      	adds	r6, r4, #4
    98e2:	4630      	mov	r0, r6
    98e4:	f001 fdf2 	bl	b4cc <lv_ll_get_head>
    98e8:	4605      	mov	r5, r0
    98ea:	b920      	cbnz	r0, 98f6 <lv_obj_set_size+0x72>
    lv_obj_invalidate(obj);
    98ec:	4620      	mov	r0, r4
    98ee:	f7ff ff27 	bl	9740 <lv_obj_invalidate>
}
    98f2:	b002      	add	sp, #8
    98f4:	bd70      	pop	{r4, r5, r6, pc}
        i->signal_cb(i, LV_SIGNAL_PARENT_SIZE_CHG, NULL);
    98f6:	69eb      	ldr	r3, [r5, #28]
    98f8:	2200      	movs	r2, #0
    98fa:	2103      	movs	r1, #3
    98fc:	4628      	mov	r0, r5
    98fe:	4798      	blx	r3
    LV_LL_READ(obj->child_ll, i)
    9900:	4629      	mov	r1, r5
    9902:	4630      	mov	r0, r6
    9904:	f001 fde8 	bl	b4d8 <lv_ll_get_next>
    9908:	e7ee      	b.n	98e8 <lv_obj_set_size+0x64>

0000990a <lv_obj_set_width>:
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    990a:	8ac2      	ldrh	r2, [r0, #22]
    990c:	8a43      	ldrh	r3, [r0, #18]
    990e:	3201      	adds	r2, #1
    9910:	1ad2      	subs	r2, r2, r3
    lv_obj_set_size(obj, w, lv_obj_get_height(obj));
    9912:	b212      	sxth	r2, r2
    9914:	f7ff bfb6 	b.w	9884 <lv_obj_set_size>

00009918 <lv_obj_set_height>:
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    9918:	8a83      	ldrh	r3, [r0, #20]
    991a:	8a02      	ldrh	r2, [r0, #16]
    991c:	3301      	adds	r3, #1
    991e:	1a9b      	subs	r3, r3, r2
    lv_obj_set_size(obj, lv_obj_get_width(obj), h);
    9920:	460a      	mov	r2, r1
    9922:	b219      	sxth	r1, r3
    9924:	f7ff bfae 	b.w	9884 <lv_obj_set_size>

00009928 <lv_obj_get_parent>:
}
    9928:	6800      	ldr	r0, [r0, #0]
    992a:	4770      	bx	lr

0000992c <lv_obj_get_child>:
    if(child == NULL) {
    992c:	3004      	adds	r0, #4
    992e:	b909      	cbnz	r1, 9934 <lv_obj_get_child+0x8>
        result = lv_ll_get_head(&obj->child_ll);
    9930:	f001 bdcc 	b.w	b4cc <lv_ll_get_head>
        result = lv_ll_get_next(&obj->child_ll, child);
    9934:	f001 bdd0 	b.w	b4d8 <lv_ll_get_next>

00009938 <refresh_children_style>:
 * Recursively refresh the style of the children. Go deeper until a not NULL style is found
 * because the NULL styles are inherited from the parent
 * @param obj pointer to an object
 */
static void refresh_children_style(lv_obj_t * obj)
{
    9938:	b538      	push	{r3, r4, r5, lr}
    993a:	4605      	mov	r5, r0
        result = lv_ll_get_head(&obj->child_ll);
    993c:	3004      	adds	r0, #4
    993e:	f001 fdc5 	bl	b4cc <lv_ll_get_head>
            lv_obj_refresh_style(child);   /*Notify the child about the style change*/
        } else if(child->style_p->glass) {
            /*Children with 'glass' parent might be effected if their style == NULL*/
            refresh_children_style(child);
        }
        child = lv_obj_get_child(obj, child);
    9942:	4604      	mov	r4, r0
    while(child != NULL) {
    9944:	b900      	cbnz	r0, 9948 <refresh_children_style+0x10>
    }
}
    9946:	bd38      	pop	{r3, r4, r5, pc}
        if(child->style_p == NULL) {
    9948:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    994a:	b953      	cbnz	r3, 9962 <refresh_children_style+0x2a>
            refresh_children_style(child); /*Check children too*/
    994c:	4620      	mov	r0, r4
    994e:	f7ff fff3 	bl	9938 <refresh_children_style>
            lv_obj_refresh_style(child);   /*Notify the child about the style change*/
    9952:	4620      	mov	r0, r4
    9954:	f7ff ff7c 	bl	9850 <lv_obj_refresh_style>
        child = lv_obj_get_child(obj, child);
    9958:	4621      	mov	r1, r4
    995a:	4628      	mov	r0, r5
    995c:	f7ff ffe6 	bl	992c <lv_obj_get_child>
    9960:	e7ef      	b.n	9942 <refresh_children_style+0xa>
        } else if(child->style_p->glass) {
    9962:	781b      	ldrb	r3, [r3, #0]
    9964:	07db      	lsls	r3, r3, #31
    9966:	d5f7      	bpl.n	9958 <refresh_children_style+0x20>
            refresh_children_style(child);
    9968:	4620      	mov	r0, r4
    996a:	f7ff ffe5 	bl	9938 <refresh_children_style>
    996e:	e7f3      	b.n	9958 <refresh_children_style+0x20>

00009970 <lv_obj_set_style>:
{
    9970:	b510      	push	{r4, lr}
    9972:	4604      	mov	r4, r0
    obj->style_p = style;
    9974:	6281      	str	r1, [r0, #40]	; 0x28
    refresh_children_style(obj);
    9976:	f7ff ffdf 	bl	9938 <refresh_children_style>
    lv_obj_refresh_style(obj);
    997a:	4620      	mov	r0, r4
}
    997c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    lv_obj_refresh_style(obj);
    9980:	f7ff bf66 	b.w	9850 <lv_obj_refresh_style>

00009984 <lv_obj_get_coords>:
{
    9984:	460b      	mov	r3, r1
    memcpy(dest, src, sizeof(lv_area_t));
    9986:	2208      	movs	r2, #8
    9988:	f100 0110 	add.w	r1, r0, #16
    998c:	4618      	mov	r0, r3
    998e:	f7fe bfaf 	b.w	88f0 <memcpy>

00009992 <lv_obj_get_x>:
    return obj->par;
    9992:	6803      	ldr	r3, [r0, #0]
    if(parent) {
    9994:	f9b0 0010 	ldrsh.w	r0, [r0, #16]
    9998:	b113      	cbz	r3, 99a0 <lv_obj_get_x+0xe>
        rel_x             = obj->coords.x1 - parent->coords.x1;
    999a:	8a1b      	ldrh	r3, [r3, #16]
    999c:	1ac0      	subs	r0, r0, r3
    999e:	b200      	sxth	r0, r0
}
    99a0:	4770      	bx	lr

000099a2 <lv_obj_get_y>:
    return obj->par;
    99a2:	6803      	ldr	r3, [r0, #0]
   if(parent) {
    99a4:	f9b0 0012 	ldrsh.w	r0, [r0, #18]
    99a8:	b113      	cbz	r3, 99b0 <lv_obj_get_y+0xe>
       rel_y             = obj->coords.y1 - parent->coords.y1;
    99aa:	8a5b      	ldrh	r3, [r3, #18]
    99ac:	1ac0      	subs	r0, r0, r3
    99ae:	b200      	sxth	r0, r0
}
    99b0:	4770      	bx	lr

000099b2 <lv_obj_align>:
{
    99b2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    99b6:	4606      	mov	r6, r0
    99b8:	461f      	mov	r7, r3
    lv_coord_t new_x = lv_obj_get_x(obj);
    99ba:	f7ff ffea 	bl	9992 <lv_obj_get_x>
    99be:	4605      	mov	r5, r0
    lv_coord_t new_y = lv_obj_get_y(obj);
    99c0:	4630      	mov	r0, r6
    99c2:	f7ff ffee 	bl	99a2 <lv_obj_get_y>
    if(base == NULL) {
    99c6:	f8d6 e000 	ldr.w	lr, [r6]
{
    99ca:	f9bd 8018 	ldrsh.w	r8, [sp, #24]
    99ce:	2900      	cmp	r1, #0
    99d0:	bf08      	it	eq
    99d2:	4671      	moveq	r1, lr
    switch(align) {
    99d4:	f9b1 3012 	ldrsh.w	r3, [r1, #18]
    99d8:	f9b1 c010 	ldrsh.w	ip, [r1, #16]
    99dc:	2a14      	cmp	r2, #20
    99de:	d818      	bhi.n	9a12 <lv_obj_align+0x60>
    99e0:	e8df f012 	tbh	[pc, r2, lsl #1]
    99e4:	00150029 	.word	0x00150029
    99e8:	0060004c 	.word	0x0060004c
    99ec:	00700068 	.word	0x00700068
    99f0:	00900088 	.word	0x00900088
    99f4:	00a900a1 	.word	0x00a900a1
    99f8:	00c600ae 	.word	0x00c600ae
    99fc:	00d100ce 	.word	0x00d100ce
    9a00:	00ef00e7 	.word	0x00ef00e7
    9a04:	00f900f4 	.word	0x00f900f4
    9a08:	010100fe 	.word	0x010100fe
    9a0c:	0104      	.short	0x0104
            new_y = 0;
    9a0e:	2000      	movs	r0, #0
            new_x = 0;
    9a10:	2500      	movs	r5, #0
    new_y -= par_abs_y;
    9a12:	f8be 2012 	ldrh.w	r2, [lr, #18]
    new_x -= par_abs_x;
    9a16:	f8be 1010 	ldrh.w	r1, [lr, #16]
    new_y -= par_abs_y;
    9a1a:	eba8 0202 	sub.w	r2, r8, r2
    new_x -= par_abs_x;
    9a1e:	1a79      	subs	r1, r7, r1
    new_y -= par_abs_y;
    9a20:	441a      	add	r2, r3
    new_x -= par_abs_x;
    9a22:	4461      	add	r1, ip
    new_y -= par_abs_y;
    9a24:	4402      	add	r2, r0
    new_x -= par_abs_x;
    9a26:	4429      	add	r1, r5
    lv_obj_set_pos(obj, new_x, new_y);
    9a28:	4630      	mov	r0, r6
    9a2a:	b212      	sxth	r2, r2
    9a2c:	b209      	sxth	r1, r1
}
    9a2e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    lv_obj_set_pos(obj, new_x, new_y);
    9a32:	f7ff bed5 	b.w	97e0 <lv_obj_set_pos>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    9a36:	8ab5      	ldrh	r5, [r6, #20]
    9a38:	8a32      	ldrh	r2, [r6, #16]
    9a3a:	3501      	adds	r5, #1
    9a3c:	1aad      	subs	r5, r5, r2
    9a3e:	8a8a      	ldrh	r2, [r1, #20]
    9a40:	3201      	adds	r2, #1
    9a42:	eba2 020c 	sub.w	r2, r2, ip
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
    9a46:	b212      	sxth	r2, r2
    9a48:	b22d      	sxth	r5, r5
    9a4a:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
    9a4e:	eb05 70d5 	add.w	r0, r5, r5, lsr #31
    9a52:	1055      	asrs	r5, r2, #1
    9a54:	eba5 0560 	sub.w	r5, r5, r0, asr #1
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    9a58:	8acc      	ldrh	r4, [r1, #22]
    9a5a:	8af0      	ldrh	r0, [r6, #22]
    9a5c:	8a72      	ldrh	r2, [r6, #18]
    9a5e:	3401      	adds	r4, #1
    9a60:	3001      	adds	r0, #1
    9a62:	1ae4      	subs	r4, r4, r3
    9a64:	1a80      	subs	r0, r0, r2
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
    9a66:	b224      	sxth	r4, r4
    9a68:	b200      	sxth	r0, r0
    9a6a:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
    9a6e:	eb00 72d0 	add.w	r2, r0, r0, lsr #31
    9a72:	1060      	asrs	r0, r4, #1
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    9a74:	b22d      	sxth	r5, r5
    9a76:	eba0 0062 	sub.w	r0, r0, r2, asr #1
    9a7a:	e077      	b.n	9b6c <lv_obj_align+0x1ba>
    9a7c:	8ab5      	ldrh	r5, [r6, #20]
    9a7e:	8a32      	ldrh	r2, [r6, #16]
    9a80:	3501      	adds	r5, #1
    9a82:	1aad      	subs	r5, r5, r2
    9a84:	8a8a      	ldrh	r2, [r1, #20]
    9a86:	3201      	adds	r2, #1
    9a88:	eba2 020c 	sub.w	r2, r2, ip
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
    9a8c:	b212      	sxth	r2, r2
    9a8e:	b22d      	sxth	r5, r5
    9a90:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
    9a94:	eb05 70d5 	add.w	r0, r5, r5, lsr #31
    9a98:	1055      	asrs	r5, r2, #1
    9a9a:	eba5 0560 	sub.w	r5, r5, r0, asr #1
    9a9e:	b22d      	sxth	r5, r5
            new_y = 0;
    9aa0:	2000      	movs	r0, #0
            break;
    9aa2:	e7b6      	b.n	9a12 <lv_obj_align+0x60>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
    9aa4:	8a35      	ldrh	r5, [r6, #16]
    9aa6:	8ab2      	ldrh	r2, [r6, #20]
    9aa8:	8a89      	ldrh	r1, [r1, #20]
    9aaa:	1aad      	subs	r5, r5, r2
    9aac:	440d      	add	r5, r1
    9aae:	eba5 050c 	sub.w	r5, r5, ip
    9ab2:	e7f4      	b.n	9a9e <lv_obj_align+0xec>
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
    9ab4:	8af2      	ldrh	r2, [r6, #22]
    9ab6:	8a70      	ldrh	r0, [r6, #18]
    9ab8:	1a80      	subs	r0, r0, r2
    9aba:	8aca      	ldrh	r2, [r1, #22]
    9abc:	4410      	add	r0, r2
    9abe:	1ac0      	subs	r0, r0, r3
    9ac0:	b200      	sxth	r0, r0
    9ac2:	e7a5      	b.n	9a10 <lv_obj_align+0x5e>
    9ac4:	8ab5      	ldrh	r5, [r6, #20]
    9ac6:	8a32      	ldrh	r2, [r6, #16]
    9ac8:	3501      	adds	r5, #1
    9aca:	1aad      	subs	r5, r5, r2
    9acc:	8a8a      	ldrh	r2, [r1, #20]
    9ace:	3201      	adds	r2, #1
    9ad0:	eba2 020c 	sub.w	r2, r2, ip
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
    9ad4:	b212      	sxth	r2, r2
    9ad6:	b22d      	sxth	r5, r5
    9ad8:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
    9adc:	eb05 70d5 	add.w	r0, r5, r5, lsr #31
    9ae0:	1055      	asrs	r5, r2, #1
    9ae2:	eba5 0560 	sub.w	r5, r5, r0, asr #1
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
    9ae6:	8af2      	ldrh	r2, [r6, #22]
    9ae8:	8a70      	ldrh	r0, [r6, #18]
    9aea:	1a80      	subs	r0, r0, r2
    9aec:	8aca      	ldrh	r2, [r1, #22]
    9aee:	b22d      	sxth	r5, r5
    9af0:	4410      	add	r0, r2
    9af2:	e05c      	b.n	9bae <lv_obj_align+0x1fc>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
    9af4:	8ab2      	ldrh	r2, [r6, #20]
    9af6:	8a35      	ldrh	r5, [r6, #16]
    9af8:	1aad      	subs	r5, r5, r2
    9afa:	8a8a      	ldrh	r2, [r1, #20]
    9afc:	4415      	add	r5, r2
    9afe:	eba5 050c 	sub.w	r5, r5, ip
    9b02:	e7f0      	b.n	9ae6 <lv_obj_align+0x134>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    9b04:	8acc      	ldrh	r4, [r1, #22]
    9b06:	8af0      	ldrh	r0, [r6, #22]
    9b08:	8a72      	ldrh	r2, [r6, #18]
    9b0a:	3401      	adds	r4, #1
    9b0c:	3001      	adds	r0, #1
    9b0e:	1ae4      	subs	r4, r4, r3
    9b10:	1a80      	subs	r0, r0, r2
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
    9b12:	b224      	sxth	r4, r4
    9b14:	b200      	sxth	r0, r0
    9b16:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
    9b1a:	eb00 72d0 	add.w	r2, r0, r0, lsr #31
    9b1e:	1060      	asrs	r0, r4, #1
    9b20:	eba0 0062 	sub.w	r0, r0, r2, asr #1
    9b24:	e7cc      	b.n	9ac0 <lv_obj_align+0x10e>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
    9b26:	8ab2      	ldrh	r2, [r6, #20]
    9b28:	8a35      	ldrh	r5, [r6, #16]
    9b2a:	1aad      	subs	r5, r5, r2
    9b2c:	8a8a      	ldrh	r2, [r1, #20]
    9b2e:	4415      	add	r5, r2
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    9b30:	eba5 050c 	sub.w	r5, r5, ip
    9b34:	e790      	b.n	9a58 <lv_obj_align+0xa6>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    9b36:	8af0      	ldrh	r0, [r6, #22]
    9b38:	1c42      	adds	r2, r0, #1
    9b3a:	8a70      	ldrh	r0, [r6, #18]
            new_y = -lv_obj_get_height(obj);
    9b3c:	1a80      	subs	r0, r0, r2
    9b3e:	e7bf      	b.n	9ac0 <lv_obj_align+0x10e>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    9b40:	8ab5      	ldrh	r5, [r6, #20]
    9b42:	8a32      	ldrh	r2, [r6, #16]
    9b44:	3501      	adds	r5, #1
    9b46:	1aad      	subs	r5, r5, r2
    9b48:	8a8a      	ldrh	r2, [r1, #20]
    9b4a:	3201      	adds	r2, #1
    9b4c:	eba2 020c 	sub.w	r2, r2, ip
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
    9b50:	b212      	sxth	r2, r2
    9b52:	b22d      	sxth	r5, r5
    9b54:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
    9b58:	eb05 70d5 	add.w	r0, r5, r5, lsr #31
    9b5c:	1055      	asrs	r5, r2, #1
    9b5e:	eba5 0560 	sub.w	r5, r5, r0, asr #1
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    9b62:	8af0      	ldrh	r0, [r6, #22]
    9b64:	1c42      	adds	r2, r0, #1
    9b66:	8a70      	ldrh	r0, [r6, #18]
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
    9b68:	b22d      	sxth	r5, r5
            new_y = -lv_obj_get_height(obj);
    9b6a:	1a80      	subs	r0, r0, r2
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
    9b6c:	b200      	sxth	r0, r0
            break;
    9b6e:	e750      	b.n	9a12 <lv_obj_align+0x60>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
    9b70:	8a35      	ldrh	r5, [r6, #16]
    9b72:	8ab2      	ldrh	r2, [r6, #20]
    9b74:	8a89      	ldrh	r1, [r1, #20]
    9b76:	1aad      	subs	r5, r5, r2
    9b78:	440d      	add	r5, r1
    9b7a:	eba5 050c 	sub.w	r5, r5, ip
    9b7e:	e7f0      	b.n	9b62 <lv_obj_align+0x1b0>
    9b80:	8ac8      	ldrh	r0, [r1, #22]
    9b82:	3001      	adds	r0, #1
    9b84:	e79b      	b.n	9abe <lv_obj_align+0x10c>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    9b86:	8ab5      	ldrh	r5, [r6, #20]
    9b88:	8a32      	ldrh	r2, [r6, #16]
    9b8a:	3501      	adds	r5, #1
    9b8c:	1aad      	subs	r5, r5, r2
    9b8e:	8a8a      	ldrh	r2, [r1, #20]
    9b90:	3201      	adds	r2, #1
    9b92:	eba2 020c 	sub.w	r2, r2, ip
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
    9b96:	b212      	sxth	r2, r2
    9b98:	b22d      	sxth	r5, r5
    9b9a:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
    9b9e:	eb05 70d5 	add.w	r0, r5, r5, lsr #31
    9ba2:	1055      	asrs	r5, r2, #1
    9ba4:	eba5 0560 	sub.w	r5, r5, r0, asr #1
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    9ba8:	8ac8      	ldrh	r0, [r1, #22]
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
    9baa:	b22d      	sxth	r5, r5
    9bac:	3001      	adds	r0, #1
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
    9bae:	1ac0      	subs	r0, r0, r3
    9bb0:	e7dc      	b.n	9b6c <lv_obj_align+0x1ba>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
    9bb2:	8ab2      	ldrh	r2, [r6, #20]
    9bb4:	8a35      	ldrh	r5, [r6, #16]
    9bb6:	1aad      	subs	r5, r5, r2
    9bb8:	8a8a      	ldrh	r2, [r1, #20]
    9bba:	4415      	add	r5, r2
    9bbc:	eba5 050c 	sub.w	r5, r5, ip
    9bc0:	e7f2      	b.n	9ba8 <lv_obj_align+0x1f6>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    9bc2:	8ab5      	ldrh	r5, [r6, #20]
    9bc4:	1c69      	adds	r1, r5, #1
    9bc6:	8a35      	ldrh	r5, [r6, #16]
            new_x = -lv_obj_get_width(obj);
    9bc8:	1a6d      	subs	r5, r5, r1
    9bca:	e768      	b.n	9a9e <lv_obj_align+0xec>
    9bcc:	8ab5      	ldrh	r5, [r6, #20]
    9bce:	1c6a      	adds	r2, r5, #1
    9bd0:	8a35      	ldrh	r5, [r6, #16]
            new_x = -lv_obj_get_width(obj);
    9bd2:	1aad      	subs	r5, r5, r2
    9bd4:	e740      	b.n	9a58 <lv_obj_align+0xa6>
    9bd6:	8ab5      	ldrh	r5, [r6, #20]
    9bd8:	1c6a      	adds	r2, r5, #1
    9bda:	8a35      	ldrh	r5, [r6, #16]
            new_x = -lv_obj_get_width(obj);
    9bdc:	1aad      	subs	r5, r5, r2
    9bde:	e782      	b.n	9ae6 <lv_obj_align+0x134>
    9be0:	8a8d      	ldrh	r5, [r1, #20]
    9be2:	3501      	adds	r5, #1
    9be4:	e763      	b.n	9aae <lv_obj_align+0xfc>
    9be6:	8a8d      	ldrh	r5, [r1, #20]
    9be8:	3501      	adds	r5, #1
    9bea:	e7a1      	b.n	9b30 <lv_obj_align+0x17e>
    9bec:	8a8d      	ldrh	r5, [r1, #20]
    9bee:	3501      	adds	r5, #1
    9bf0:	e785      	b.n	9afe <lv_obj_align+0x14c>

00009bf2 <lv_obj_get_width>:
    9bf2:	8a83      	ldrh	r3, [r0, #20]
    9bf4:	8a00      	ldrh	r0, [r0, #16]
    9bf6:	3301      	adds	r3, #1
    9bf8:	1a18      	subs	r0, r3, r0
}
    9bfa:	b200      	sxth	r0, r0
    9bfc:	4770      	bx	lr

00009bfe <lv_obj_get_height>:
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    9bfe:	8ac3      	ldrh	r3, [r0, #22]
    9c00:	8a40      	ldrh	r0, [r0, #18]
    9c02:	3301      	adds	r3, #1
    9c04:	1a18      	subs	r0, r3, r0
}
    9c06:	b200      	sxth	r0, r0
    9c08:	4770      	bx	lr

00009c0a <lv_obj_get_base_dir>:
}
    9c0a:	2000      	movs	r0, #0
    9c0c:	4770      	bx	lr

00009c0e <lv_obj_get_opa_scale>:
    while(parent) {
    9c0e:	b908      	cbnz	r0, 9c14 <lv_obj_get_opa_scale+0x6>
    return LV_OPA_COVER;
    9c10:	20ff      	movs	r0, #255	; 0xff
}
    9c12:	4770      	bx	lr
        if(parent->opa_scale_en) return parent->opa_scale;
    9c14:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
    9c18:	065b      	lsls	r3, r3, #25
    9c1a:	d502      	bpl.n	9c22 <lv_obj_get_opa_scale+0x14>
    9c1c:	f890 002f 	ldrb.w	r0, [r0, #47]	; 0x2f
    9c20:	4770      	bx	lr
    return obj->par;
    9c22:	6800      	ldr	r0, [r0, #0]
    9c24:	e7f3      	b.n	9c0e <lv_obj_get_opa_scale>

00009c26 <lv_obj_design>:
    if(mode == LV_DESIGN_COVER_CHK) {
    9c26:	2a02      	cmp	r2, #2
{
    9c28:	b573      	push	{r0, r1, r4, r5, r6, lr}
    9c2a:	4604      	mov	r4, r0
    9c2c:	460d      	mov	r5, r1
    if(mode == LV_DESIGN_COVER_CHK) {
    9c2e:	d13d      	bne.n	9cac <lv_obj_design+0x86>
        if(lv_area_is_in(mask_p, &obj->coords) == false) return false;
    9c30:	f100 0610 	add.w	r6, r0, #16
    9c34:	4631      	mov	r1, r6
    9c36:	4628      	mov	r0, r5
    9c38:	f001 fba2 	bl	b380 <lv_area_is_in>
    9c3c:	b398      	cbz	r0, 9ca6 <lv_obj_design+0x80>
        const lv_style_t * style = lv_obj_get_style(obj);
    9c3e:	4620      	mov	r0, r4
    9c40:	f7fa f8e4 	bl	3e0c <lv_obj_get_style>
        if(style->body.opa < LV_OPA_MAX) return false;
    9c44:	7b83      	ldrb	r3, [r0, #14]
    9c46:	2bfa      	cmp	r3, #250	; 0xfa
    9c48:	d92d      	bls.n	9ca6 <lv_obj_design+0x80>
        lv_coord_t r = style->body.radius;
    9c4a:	f9b0 400c 	ldrsh.w	r4, [r0, #12]
        if(r == LV_RADIUS_CIRCLE) return false;
    9c4e:	f647 4318 	movw	r3, #31768	; 0x7c18
    9c52:	429c      	cmp	r4, r3
    9c54:	d027      	beq.n	9ca6 <lv_obj_design+0x80>
    memcpy(dest, src, sizeof(lv_area_t));
    9c56:	4631      	mov	r1, r6
    9c58:	2208      	movs	r2, #8
    9c5a:	4668      	mov	r0, sp
    9c5c:	f7fe fe48 	bl	88f0 <memcpy>
        area_tmp.x1 += r;
    9c60:	f8bd 3000 	ldrh.w	r3, [sp]
    9c64:	4423      	add	r3, r4
    9c66:	f8ad 3000 	strh.w	r3, [sp]
        area_tmp.x2 -= r;
    9c6a:	f8bd 3004 	ldrh.w	r3, [sp, #4]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
    9c6e:	4669      	mov	r1, sp
        area_tmp.x2 -= r;
    9c70:	1b1b      	subs	r3, r3, r4
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
    9c72:	4628      	mov	r0, r5
        area_tmp.x2 -= r;
    9c74:	f8ad 3004 	strh.w	r3, [sp, #4]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
    9c78:	f001 fb82 	bl	b380 <lv_area_is_in>
    9c7c:	b198      	cbz	r0, 9ca6 <lv_obj_design+0x80>
    9c7e:	4631      	mov	r1, r6
    9c80:	2208      	movs	r2, #8
    9c82:	4668      	mov	r0, sp
    9c84:	f7fe fe34 	bl	88f0 <memcpy>
        area_tmp.y1 += r;
    9c88:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    9c8c:	4423      	add	r3, r4
    9c8e:	f8ad 3002 	strh.w	r3, [sp, #2]
        area_tmp.y2 -= r;
    9c92:	f8bd 3006 	ldrh.w	r3, [sp, #6]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
    9c96:	4669      	mov	r1, sp
        area_tmp.y2 -= r;
    9c98:	1b1c      	subs	r4, r3, r4
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
    9c9a:	4628      	mov	r0, r5
        area_tmp.y2 -= r;
    9c9c:	f8ad 4006 	strh.w	r4, [sp, #6]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
    9ca0:	f001 fb6e 	bl	b380 <lv_area_is_in>
    9ca4:	b900      	cbnz	r0, 9ca8 <lv_obj_design+0x82>
        if(lv_area_is_in(mask_p, &obj->coords) == false) return false;
    9ca6:	2000      	movs	r0, #0
}
    9ca8:	b002      	add	sp, #8
    9caa:	bd70      	pop	{r4, r5, r6, pc}
    } else if(mode == LV_DESIGN_DRAW_MAIN) {
    9cac:	b95a      	cbnz	r2, 9cc6 <lv_obj_design+0xa0>
        const lv_style_t * style = lv_obj_get_style(obj);
    9cae:	f7fa f8ad 	bl	3e0c <lv_obj_get_style>
    9cb2:	4602      	mov	r2, r0
        lv_draw_rect(&obj->coords, mask_p, style, lv_obj_get_opa_scale(obj));
    9cb4:	4620      	mov	r0, r4
    9cb6:	f7ff ffaa 	bl	9c0e <lv_obj_get_opa_scale>
    9cba:	4629      	mov	r1, r5
    9cbc:	4603      	mov	r3, r0
    9cbe:	f104 0010 	add.w	r0, r4, #16
    9cc2:	f000 fbaa 	bl	a41a <lv_draw_rect>
    return true;
    9cc6:	2001      	movs	r0, #1
    9cc8:	e7ee      	b.n	9ca8 <lv_obj_design+0x82>

00009cca <lv_obj_get_signal_cb>:
}
    9cca:	69c0      	ldr	r0, [r0, #28]
    9ccc:	4770      	bx	lr

00009cce <lv_obj_get_ext_attr>:
}
    9cce:	6a40      	ldr	r0, [r0, #36]	; 0x24
    9cd0:	4770      	bx	lr

00009cd2 <lv_obj_handle_get_type_signal>:
{
    9cd2:	b510      	push	{r4, lr}
    9cd4:	2300      	movs	r3, #0
        if(buf->type[i] == NULL) break;
    9cd6:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
    9cda:	b2da      	uxtb	r2, r3
    9cdc:	b11c      	cbz	r4, 9ce6 <lv_obj_handle_get_type_signal+0x14>
    9cde:	3301      	adds	r3, #1
    for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
    9ce0:	2b07      	cmp	r3, #7
    9ce2:	d1f8      	bne.n	9cd6 <lv_obj_handle_get_type_signal+0x4>
    9ce4:	461a      	mov	r2, r3
    buf->type[i] = name;
    9ce6:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
}
    9cea:	2001      	movs	r0, #1
    9cec:	bd10      	pop	{r4, pc}

00009cee <lv_refr_get_top_obj>:
{
    9cee:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9cf0:	460c      	mov	r4, r1
    if(lv_area_is_in(area_p, &obj->coords) && obj->hidden == 0) {
    9cf2:	3110      	adds	r1, #16
{
    9cf4:	4606      	mov	r6, r0
    if(lv_area_is_in(area_p, &obj->coords) && obj->hidden == 0) {
    9cf6:	f001 fb43 	bl	b380 <lv_area_is_in>
    9cfa:	b908      	cbnz	r0, 9d00 <lv_refr_get_top_obj+0x12>
    lv_obj_t * found_p = NULL;
    9cfc:	2000      	movs	r0, #0
}
    9cfe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(lv_area_is_in(area_p, &obj->coords) && obj->hidden == 0) {
    9d00:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    9d04:	06db      	lsls	r3, r3, #27
    9d06:	d4f9      	bmi.n	9cfc <lv_refr_get_top_obj+0xe>
        LV_LL_READ(obj->child_ll, i)
    9d08:	1d27      	adds	r7, r4, #4
    9d0a:	4638      	mov	r0, r7
    9d0c:	f001 fbde 	bl	b4cc <lv_ll_get_head>
    9d10:	4605      	mov	r5, r0
    9d12:	b998      	cbnz	r0, 9d3c <lv_refr_get_top_obj+0x4e>
            const lv_style_t * style = lv_obj_get_style(obj);
    9d14:	4620      	mov	r0, r4
    9d16:	f7fa f879 	bl	3e0c <lv_obj_get_style>
            if(style->body.opa == LV_OPA_COVER && obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK) != false &&
    9d1a:	7b83      	ldrb	r3, [r0, #14]
    9d1c:	2bff      	cmp	r3, #255	; 0xff
    9d1e:	d1ed      	bne.n	9cfc <lv_refr_get_top_obj+0xe>
    9d20:	6a23      	ldr	r3, [r4, #32]
    9d22:	2202      	movs	r2, #2
    9d24:	4631      	mov	r1, r6
    9d26:	4620      	mov	r0, r4
    9d28:	4798      	blx	r3
    9d2a:	2800      	cmp	r0, #0
    9d2c:	d0e6      	beq.n	9cfc <lv_refr_get_top_obj+0xe>
               lv_obj_get_opa_scale(obj) == LV_OPA_COVER) {
    9d2e:	4620      	mov	r0, r4
    9d30:	f7ff ff6d 	bl	9c0e <lv_obj_get_opa_scale>
            if(style->body.opa == LV_OPA_COVER && obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK) != false &&
    9d34:	28ff      	cmp	r0, #255	; 0xff
    9d36:	d1e1      	bne.n	9cfc <lv_refr_get_top_obj+0xe>
    9d38:	4620      	mov	r0, r4
    return found_p;
    9d3a:	e7e0      	b.n	9cfe <lv_refr_get_top_obj+0x10>
            found_p = lv_refr_get_top_obj(area_p, i);
    9d3c:	4629      	mov	r1, r5
    9d3e:	4630      	mov	r0, r6
    9d40:	f7ff ffd5 	bl	9cee <lv_refr_get_top_obj>
            if(found_p != NULL) {
    9d44:	2800      	cmp	r0, #0
    9d46:	d1da      	bne.n	9cfe <lv_refr_get_top_obj+0x10>
        LV_LL_READ(obj->child_ll, i)
    9d48:	4629      	mov	r1, r5
    9d4a:	4638      	mov	r0, r7
    9d4c:	f001 fbc4 	bl	b4d8 <lv_ll_get_next>
    9d50:	e7de      	b.n	9d10 <lv_refr_get_top_obj+0x22>

00009d52 <lv_refr_obj>:
{
    9d52:	b5f0      	push	{r4, r5, r6, r7, lr}
    if(obj->hidden != 0) return;
    9d54:	f890 602c 	ldrb.w	r6, [r0, #44]	; 0x2c
    9d58:	f016 0610 	ands.w	r6, r6, #16
{
    9d5c:	b08b      	sub	sp, #44	; 0x2c
    9d5e:	4604      	mov	r4, r0
    9d60:	460f      	mov	r7, r1
    if(obj->hidden != 0) return;
    9d62:	d138      	bne.n	9dd6 <lv_refr_obj+0x84>
    lv_obj_get_coords(obj, &obj_area);
    9d64:	a904      	add	r1, sp, #16
    lv_coord_t ext_size = obj->ext_draw_pad;
    9d66:	f9b0 5030 	ldrsh.w	r5, [r0, #48]	; 0x30
    lv_obj_get_coords(obj, &obj_area);
    9d6a:	f7ff fe0b 	bl	9984 <lv_obj_get_coords>
    obj_area.x1 -= ext_size;
    9d6e:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    9d72:	1b5b      	subs	r3, r3, r5
    9d74:	f8ad 3010 	strh.w	r3, [sp, #16]
    obj_area.y1 -= ext_size;
    9d78:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    9d7c:	1b5b      	subs	r3, r3, r5
    9d7e:	f8ad 3012 	strh.w	r3, [sp, #18]
    obj_area.x2 += ext_size;
    9d82:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    9d86:	442b      	add	r3, r5
    9d88:	f8ad 3014 	strh.w	r3, [sp, #20]
    obj_area.y2 += ext_size;
    9d8c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    union_ok = lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
    9d90:	aa04      	add	r2, sp, #16
    obj_area.y2 += ext_size;
    9d92:	441d      	add	r5, r3
    union_ok = lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
    9d94:	4639      	mov	r1, r7
    9d96:	a802      	add	r0, sp, #8
    obj_area.y2 += ext_size;
    9d98:	f8ad 5016 	strh.w	r5, [sp, #22]
    union_ok = lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
    9d9c:	f001 fa87 	bl	b2ae <lv_area_intersect>
    if(union_ok != false) {
    9da0:	b1c8      	cbz	r0, 9dd6 <lv_refr_obj+0x84>
        obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_MAIN);
    9da2:	4632      	mov	r2, r6
    9da4:	6a23      	ldr	r3, [r4, #32]
    9da6:	a902      	add	r1, sp, #8
    9da8:	4620      	mov	r0, r4
    9daa:	4798      	blx	r3
        lv_obj_get_coords(obj, &obj_area);
    9dac:	a904      	add	r1, sp, #16
    9dae:	4620      	mov	r0, r4
    9db0:	f7ff fde8 	bl	9984 <lv_obj_get_coords>
        union_ok = lv_area_intersect(&obj_mask, mask_ori_p, &obj_area);
    9db4:	aa04      	add	r2, sp, #16
    9db6:	4639      	mov	r1, r7
    9db8:	4668      	mov	r0, sp
    9dba:	f001 fa78 	bl	b2ae <lv_area_intersect>
        if(union_ok != false) {
    9dbe:	b128      	cbz	r0, 9dcc <lv_refr_obj+0x7a>
            LV_LL_READ_BACK(obj->child_ll, child_p)
    9dc0:	1d26      	adds	r6, r4, #4
    9dc2:	4630      	mov	r0, r6
    9dc4:	f001 fb85 	bl	b4d2 <lv_ll_get_tail>
    9dc8:	4605      	mov	r5, r0
    9dca:	b930      	cbnz	r0, 9dda <lv_refr_obj+0x88>
        obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_POST);
    9dcc:	6a23      	ldr	r3, [r4, #32]
    9dce:	2201      	movs	r2, #1
    9dd0:	a902      	add	r1, sp, #8
    9dd2:	4620      	mov	r0, r4
    9dd4:	4798      	blx	r3
}
    9dd6:	b00b      	add	sp, #44	; 0x2c
    9dd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
                lv_obj_get_coords(child_p, &child_area);
    9dda:	a908      	add	r1, sp, #32
    9ddc:	4628      	mov	r0, r5
    9dde:	f7ff fdd1 	bl	9984 <lv_obj_get_coords>
                ext_size = child_p->ext_draw_pad;
    9de2:	f9b5 3030 	ldrsh.w	r3, [r5, #48]	; 0x30
                child_area.x1 -= ext_size;
    9de6:	f8bd 2020 	ldrh.w	r2, [sp, #32]
    9dea:	1ad2      	subs	r2, r2, r3
    9dec:	f8ad 2020 	strh.w	r2, [sp, #32]
                child_area.y1 -= ext_size;
    9df0:	f8bd 2022 	ldrh.w	r2, [sp, #34]	; 0x22
    9df4:	1ad2      	subs	r2, r2, r3
    9df6:	f8ad 2022 	strh.w	r2, [sp, #34]	; 0x22
                child_area.x2 += ext_size;
    9dfa:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
    9dfe:	441a      	add	r2, r3
    9e00:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
                child_area.y2 += ext_size;
    9e04:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
                union_ok = lv_area_intersect(&mask_child, &obj_mask, &child_area);
    9e08:	4669      	mov	r1, sp
                child_area.y2 += ext_size;
    9e0a:	4413      	add	r3, r2
                union_ok = lv_area_intersect(&mask_child, &obj_mask, &child_area);
    9e0c:	a806      	add	r0, sp, #24
    9e0e:	aa08      	add	r2, sp, #32
                child_area.y2 += ext_size;
    9e10:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
                union_ok = lv_area_intersect(&mask_child, &obj_mask, &child_area);
    9e14:	f001 fa4b 	bl	b2ae <lv_area_intersect>
                if(union_ok) {
    9e18:	b118      	cbz	r0, 9e22 <lv_refr_obj+0xd0>
                    lv_refr_obj(child_p, &mask_child);
    9e1a:	a906      	add	r1, sp, #24
    9e1c:	4628      	mov	r0, r5
    9e1e:	f7ff ff98 	bl	9d52 <lv_refr_obj>
            LV_LL_READ_BACK(obj->child_ll, child_p)
    9e22:	4629      	mov	r1, r5
    9e24:	4630      	mov	r0, r6
    9e26:	f001 fb67 	bl	b4f8 <lv_ll_get_prev>
    9e2a:	e7cd      	b.n	9dc8 <lv_refr_obj+0x76>

00009e2c <lv_refr_init>:
}
    9e2c:	4770      	bx	lr

00009e2e <lv_inv_area>:
{
    9e2e:	b5f0      	push	{r4, r5, r6, r7, lr}
    9e30:	460d      	mov	r5, r1
    9e32:	b085      	sub	sp, #20
    if(!disp) disp = lv_disp_get_default();
    9e34:	4604      	mov	r4, r0
    9e36:	b920      	cbnz	r0, 9e42 <lv_inv_area+0x14>
    9e38:	f7fb fd66 	bl	5908 <lv_disp_get_default>
    if(!disp) return;
    9e3c:	4604      	mov	r4, r0
    9e3e:	2800      	cmp	r0, #0
    9e40:	d043      	beq.n	9eca <lv_inv_area+0x9c>
    if(area_p == NULL) {
    9e42:	b935      	cbnz	r5, 9e52 <lv_inv_area+0x24>
        disp->inv_p = 0;
    9e44:	f8b4 3160 	ldrh.w	r3, [r4, #352]	; 0x160
    9e48:	f365 0309 	bfi	r3, r5, #0, #10
        disp->inv_p++;
    9e4c:	f8a4 3160 	strh.w	r3, [r4, #352]	; 0x160
    9e50:	e03b      	b.n	9eca <lv_inv_area+0x9c>
    scr_area.x1 = 0;
    9e52:	2300      	movs	r3, #0
    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;
    9e54:	4620      	mov	r0, r4
    scr_area.x1 = 0;
    9e56:	9300      	str	r3, [sp, #0]
    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;
    9e58:	f7fb fd5c 	bl	5914 <lv_disp_get_hor_res>
    9e5c:	3801      	subs	r0, #1
    9e5e:	f8ad 0004 	strh.w	r0, [sp, #4]
    scr_area.y2 = lv_disp_get_ver_res(disp) - 1;
    9e62:	4620      	mov	r0, r4
    9e64:	f7fb fd66 	bl	5934 <lv_disp_get_ver_res>
    9e68:	3801      	subs	r0, #1
    9e6a:	f8ad 0006 	strh.w	r0, [sp, #6]
    suc = lv_area_intersect(&com_area, area_p, &scr_area);
    9e6e:	466a      	mov	r2, sp
    9e70:	4629      	mov	r1, r5
    9e72:	a802      	add	r0, sp, #8
    9e74:	f001 fa1b 	bl	b2ae <lv_area_intersect>
    if(suc != false) {
    9e78:	b338      	cbz	r0, 9eca <lv_inv_area+0x9c>
        if(disp->driver.rounder_cb) disp->driver.rounder_cb(&disp->driver, &com_area);
    9e7a:	6923      	ldr	r3, [r4, #16]
    9e7c:	b113      	cbz	r3, 9e84 <lv_inv_area+0x56>
    9e7e:	a902      	add	r1, sp, #8
    9e80:	4620      	mov	r0, r4
    9e82:	4798      	blx	r3
    9e84:	f104 0540 	add.w	r5, r4, #64	; 0x40
{
    9e88:	2600      	movs	r6, #0
    9e8a:	462f      	mov	r7, r5
        for(i = 0; i < disp->inv_p; i++) {
    9e8c:	f8b4 3160 	ldrh.w	r3, [r4, #352]	; 0x160
    9e90:	b2b2      	uxth	r2, r6
    9e92:	f3c3 0009 	ubfx	r0, r3, #0, #10
    9e96:	4290      	cmp	r0, r2
    9e98:	d80f      	bhi.n	9eba <lv_inv_area+0x8c>
        if(disp->inv_p < LV_INV_BUF_SIZE) {
    9e9a:	281f      	cmp	r0, #31
    9e9c:	d817      	bhi.n	9ece <lv_inv_area+0xa0>
            lv_area_copy(&disp->inv_areas[disp->inv_p], &com_area);
    9e9e:	3008      	adds	r0, #8
    9ea0:	2208      	movs	r2, #8
    9ea2:	eb0d 0102 	add.w	r1, sp, r2
    9ea6:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
    9eaa:	f7fe fd21 	bl	88f0 <memcpy>
        disp->inv_p++;
    9eae:	f8b4 3160 	ldrh.w	r3, [r4, #352]	; 0x160
    9eb2:	1c5a      	adds	r2, r3, #1
    9eb4:	f362 0309 	bfi	r3, r2, #0, #10
    9eb8:	e7c8      	b.n	9e4c <lv_inv_area+0x1e>
            if(lv_area_is_in(&com_area, &disp->inv_areas[i]) != false) return;
    9eba:	4629      	mov	r1, r5
    9ebc:	a802      	add	r0, sp, #8
    9ebe:	f001 fa5f 	bl	b380 <lv_area_is_in>
    9ec2:	3601      	adds	r6, #1
    9ec4:	3508      	adds	r5, #8
    9ec6:	2800      	cmp	r0, #0
    9ec8:	d0e0      	beq.n	9e8c <lv_inv_area+0x5e>
}
    9eca:	b005      	add	sp, #20
    9ecc:	bdf0      	pop	{r4, r5, r6, r7, pc}
            disp->inv_p = 0;
    9ece:	f36f 0309 	bfc	r3, #0, #10
    9ed2:	f8a4 3160 	strh.w	r3, [r4, #352]	; 0x160
    9ed6:	2208      	movs	r2, #8
    9ed8:	4669      	mov	r1, sp
    9eda:	4638      	mov	r0, r7
    9edc:	e7e5      	b.n	9eaa <lv_inv_area+0x7c>

00009ede <lv_style_copy>:
 * @param dest pointer to the destination style
 * @param src pointer to the source style
 */
void lv_style_copy(lv_style_t * dest, const lv_style_t * src)
{
    memcpy(dest, src, sizeof(lv_style_t));
    9ede:	2250      	movs	r2, #80	; 0x50
    9ee0:	f7fe bd06 	b.w	88f0 <memcpy>

00009ee4 <lv_color_mix.isra.0>:
#elif LV_COLOR_DEPTH == 32
    return color.full;
#endif
}

static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
    9ee4:	b530      	push	{r4, r5, lr}
    9ee6:	f89d 5014 	ldrb.w	r5, [sp, #20]
{
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    9eea:	b2ac      	uxth	r4, r5
    9eec:	f1c5 05ff 	rsb	r5, r5, #255	; 0xff
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    LV_COLOR_SET_B(ret, (uint16_t)((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) * (255 - mix)) >> 8);
    9ef0:	436b      	muls	r3, r5
    9ef2:	fb00 3304 	mla	r3, r0, r4, r3
    9ef6:	f3c3 2307 	ubfx	r3, r3, #8, #8
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
    9efa:	2000      	movs	r0, #0
    9efc:	f363 0007 	bfi	r0, r3, #0, #8
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    9f00:	f89d 300c 	ldrb.w	r3, [sp, #12]
    9f04:	fb13 f305 	smulbb	r3, r3, r5
    9f08:	fb01 3104 	mla	r1, r1, r4, r3
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    9f0c:	f89d 3010 	ldrb.w	r3, [sp, #16]
    9f10:	fb13 f505 	smulbb	r5, r3, r5
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    9f14:	f3c1 2107 	ubfx	r1, r1, #8, #8
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    9f18:	fb02 5204 	mla	r2, r2, r4, r5
    return ret;
    9f1c:	f361 200f 	bfi	r0, r1, #8, #8
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    9f20:	f3c2 2207 	ubfx	r2, r2, #8, #8
    return ret;
    9f24:	f362 4017 	bfi	r0, r2, #16, #8
}
    9f28:	f040 407f 	orr.w	r0, r0, #4278190080	; 0xff000000
    9f2c:	bd30      	pop	{r4, r5, pc}

00009f2e <lv_draw_fill>:
{
    9f2e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(opa < LV_OPA_MIN) return;
    9f32:	2b0f      	cmp	r3, #15
{
    9f34:	b08d      	sub	sp, #52	; 0x34
    9f36:	4616      	mov	r6, r2
    9f38:	461f      	mov	r7, r3
    if(opa < LV_OPA_MIN) return;
    9f3a:	d973      	bls.n	a024 <lv_draw_fill+0xf6>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
    9f3c:	2bfc      	cmp	r3, #252	; 0xfc
    union_ok = lv_area_intersect(&res_a, cords_p, mask_p);
    9f3e:	460a      	mov	r2, r1
    9f40:	4601      	mov	r1, r0
    9f42:	a80a      	add	r0, sp, #40	; 0x28
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
    9f44:	bf28      	it	cs
    9f46:	27ff      	movcs	r7, #255	; 0xff
    union_ok = lv_area_intersect(&res_a, cords_p, mask_p);
    9f48:	f001 f9b1 	bl	b2ae <lv_area_intersect>
    if(union_ok == false) {
    9f4c:	2800      	cmp	r0, #0
    9f4e:	d069      	beq.n	a024 <lv_draw_fill+0xf6>
    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
    9f50:	f7fa f816 	bl	3f80 <lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
    9f54:	f001 f949 	bl	b1ea <lv_disp_get_buf>
    vdb_rel_a.y1 = res_a.y1 - vdb->area.y1;
    9f58:	f8bd 102a 	ldrh.w	r1, [sp, #42]	; 0x2a
    9f5c:	f9b0 5012 	ldrsh.w	r5, [r0, #18]
    vdb_rel_a.x1 = res_a.x1 - vdb->area.x1;
    9f60:	f9b0 3010 	ldrsh.w	r3, [r0, #16]
    9f64:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
    lv_color_t * vdb_buf_tmp = vdb->buf_act;
    9f68:	f8d0 a008 	ldr.w	sl, [r0, #8]
    vdb_rel_a.y1 = res_a.y1 - vdb->area.y1;
    9f6c:	1b49      	subs	r1, r1, r5
    9f6e:	fa0f fb81 	sxth.w	fp, r1
    vdb_rel_a.x2 = res_a.x2 - vdb->area.x1;
    9f72:	f8bd 102c 	ldrh.w	r1, [sp, #44]	; 0x2c
    9f76:	1ac9      	subs	r1, r1, r3
    9f78:	b20a      	sxth	r2, r1
    9f7a:	9204      	str	r2, [sp, #16]
    vdb_rel_a.y2 = res_a.y2 - vdb->area.y1;
    9f7c:	f8bd 202e 	ldrh.w	r2, [sp, #46]	; 0x2e
    9f80:	1b52      	subs	r2, r2, r5
    9f82:	8a85      	ldrh	r5, [r0, #20]
    9f84:	3501      	adds	r5, #1
    9f86:	1aed      	subs	r5, r5, r3
    vdb_rel_a.x1 = res_a.x1 - vdb->area.x1;
    9f88:	1ae4      	subs	r4, r4, r3
    9f8a:	b22b      	sxth	r3, r5
    9f8c:	9309      	str	r3, [sp, #36]	; 0x24
    9f8e:	b2f3      	uxtb	r3, r6
    9f90:	9305      	str	r3, [sp, #20]
    9f92:	f3c6 2307 	ubfx	r3, r6, #8, #8
    vdb_rel_a.y2 = res_a.y2 - vdb->area.y1;
    9f96:	b212      	sxth	r2, r2
    9f98:	9306      	str	r3, [sp, #24]
    9f9a:	f3c6 4307 	ubfx	r3, r6, #16, #8
    9f9e:	9307      	str	r3, [sp, #28]
    9fa0:	9208      	str	r2, [sp, #32]
{
    /*Set all row in vdb to the given color*/
    lv_coord_t row;
    lv_coord_t col;

    lv_disp_t * disp = lv_refr_get_disp_refreshing();
    9fa2:	f7f9 ffed 	bl	3f80 <lv_refr_get_disp_refreshing>
    if(disp->driver.set_px_cb) {
    9fa6:	6943      	ldr	r3, [r0, #20]
    vdb_rel_a.x1 = res_a.x1 - vdb->area.x1;
    9fa8:	b224      	sxth	r4, r4
    lv_disp_t * disp = lv_refr_get_disp_refreshing();
    9faa:	4681      	mov	r9, r0
    if(disp->driver.set_px_cb) {
    9fac:	2b00      	cmp	r3, #0
    9fae:	d136      	bne.n	a01e <lv_draw_fill+0xf0>
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
                disp->driver.set_px_cb(&disp->driver, (uint8_t *)mem, mem_width, col, row, color, opa);
            }
        }
    } else {
        mem += fill_area->y1 * mem_width; /*Go to the first row*/
    9fb0:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9fb2:	fb0b f202 	mul.w	r2, fp, r2
    9fb6:	eb0a 0a82 	add.w	sl, sl, r2, lsl #2

        /*Run simpler function without opacity*/
        if(opa == LV_OPA_COVER) {
    9fba:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9fbc:	2fff      	cmp	r7, #255	; 0xff
    9fbe:	ea4f 0582 	mov.w	r5, r2, lsl #2
    9fc2:	d05c      	beq.n	a07e <lv_draw_fill+0x150>
#if LV_COLOR_DEPTH == 32 && LV_COLOR_SCREEN_TRANSP
            scr_transp = disp->driver.screen_transp;
#endif

            lv_color_t bg_tmp  = LV_COLOR_BLACK;
            lv_color_t opa_tmp = lv_color_mix(color, bg_tmp, opa);
    9fc4:	e9cd 3701 	strd	r3, r7, [sp, #4]
    9fc8:	9300      	str	r3, [sp, #0]
    9fca:	e9dd 1206 	ldrd	r1, r2, [sp, #24]
    9fce:	9805      	ldr	r0, [sp, #20]
            lv_color_t bg_tmp  = LV_COLOR_BLACK;
    9fd0:	f04f 487f 	mov.w	r8, #4278190080	; 0xff000000
            lv_color_t opa_tmp = lv_color_mix(color, bg_tmp, opa);
    9fd4:	f7ff ff86 	bl	9ee4 <lv_color_mix.isra.0>
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
    9fd8:	9b08      	ldr	r3, [sp, #32]
    9fda:	455b      	cmp	r3, fp
    9fdc:	db22      	blt.n	a024 <lv_draw_fill+0xf6>
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
    9fde:	4626      	mov	r6, r4
    9fe0:	e068      	b.n	a0b4 <lv_draw_fill+0x186>
                disp->driver.set_px_cb(&disp->driver, (uint8_t *)mem, mem_width, col, row, color, opa);
    9fe2:	f8d9 3014 	ldr.w	r3, [r9, #20]
    9fe6:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9fe8:	f8cd 8000 	str.w	r8, [sp]
    9fec:	461d      	mov	r5, r3
    9fee:	9b05      	ldr	r3, [sp, #20]
    9ff0:	f363 0607 	bfi	r6, r3, #0, #8
    9ff4:	9b06      	ldr	r3, [sp, #24]
    9ff6:	f363 260f 	bfi	r6, r3, #8, #8
    9ffa:	9b07      	ldr	r3, [sp, #28]
    9ffc:	f363 4617 	bfi	r6, r3, #16, #8
    a000:	e9cd 6701 	strd	r6, r7, [sp, #4]
    a004:	4623      	mov	r3, r4
    a006:	4651      	mov	r1, sl
    a008:	4648      	mov	r0, r9
    a00a:	47a8      	blx	r5
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
    a00c:	f108 0801 	add.w	r8, r8, #1
    a010:	fa0f f888 	sxth.w	r8, r8
    a014:	9b08      	ldr	r3, [sp, #32]
    a016:	4543      	cmp	r3, r8
    a018:	dae3      	bge.n	9fe2 <lv_draw_fill+0xb4>
        for(col = fill_area->x1; col <= fill_area->x2; col++) {
    a01a:	3401      	adds	r4, #1
    a01c:	b224      	sxth	r4, r4
    a01e:	9b04      	ldr	r3, [sp, #16]
    a020:	42a3      	cmp	r3, r4
    a022:	da02      	bge.n	a02a <lv_draw_fill+0xfc>
}
    a024:	b00d      	add	sp, #52	; 0x34
    a026:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
    a02a:	46d8      	mov	r8, fp
    a02c:	e7f2      	b.n	a014 <lv_draw_fill+0xe6>
                mem[col] = color;
    a02e:	9a05      	ldr	r2, [sp, #20]
    a030:	f362 0607 	bfi	r6, r2, #0, #8
    a034:	9a06      	ldr	r2, [sp, #24]
    a036:	f362 260f 	bfi	r6, r2, #8, #8
    a03a:	9a07      	ldr	r2, [sp, #28]
    a03c:	f362 4617 	bfi	r6, r2, #16, #8
    a040:	f84a 6023 	str.w	r6, [sl, r3, lsl #2]
            for(col = fill_area->x1; col <= fill_area->x2; col++) {
    a044:	3301      	adds	r3, #1
    a046:	b21b      	sxth	r3, r3
    a048:	9a04      	ldr	r2, [sp, #16]
    a04a:	429a      	cmp	r2, r3
    a04c:	daef      	bge.n	a02e <lv_draw_fill+0x100>
            lv_coord_t copy_size   = (fill_area->x2 - fill_area->x1 + 1) * sizeof(lv_color_t);
    a04e:	3201      	adds	r2, #1
            lv_color_t * mem_first = &mem[fill_area->x1];
    a050:	00a3      	lsls	r3, r4, #2
            lv_coord_t copy_size   = (fill_area->x2 - fill_area->x1 + 1) * sizeof(lv_color_t);
    a052:	1b14      	subs	r4, r2, r4
            lv_color_t * mem_first = &mem[fill_area->x1];
    a054:	eb0a 0603 	add.w	r6, sl, r3
            lv_coord_t copy_size   = (fill_area->x2 - fill_area->x1 + 1) * sizeof(lv_color_t);
    a058:	00a4      	lsls	r4, r4, #2
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
    a05a:	f10b 0701 	add.w	r7, fp, #1
    a05e:	442b      	add	r3, r5
            lv_coord_t copy_size   = (fill_area->x2 - fill_area->x1 + 1) * sizeof(lv_color_t);
    a060:	b224      	sxth	r4, r4
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
    a062:	b23f      	sxth	r7, r7
    a064:	449a      	add	sl, r3
    a066:	9b08      	ldr	r3, [sp, #32]
    a068:	42bb      	cmp	r3, r7
    a06a:	dbdb      	blt.n	a024 <lv_draw_fill+0xf6>
                memcpy(&mem[fill_area->x1], mem_first, copy_size);
    a06c:	4650      	mov	r0, sl
    a06e:	4622      	mov	r2, r4
    a070:	4631      	mov	r1, r6
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
    a072:	3701      	adds	r7, #1
                memcpy(&mem[fill_area->x1], mem_first, copy_size);
    a074:	f7fe fc3c 	bl	88f0 <memcpy>
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
    a078:	b23f      	sxth	r7, r7
    a07a:	44aa      	add	sl, r5
    a07c:	e7f3      	b.n	a066 <lv_draw_fill+0x138>
            for(col = fill_area->x1; col <= fill_area->x2; col++) {
    a07e:	4623      	mov	r3, r4
    a080:	e7e2      	b.n	a048 <lv_draw_fill+0x11a>
                    if(scr_transp == false) {
                        /*If the bg color changed recalculate the result color*/
                        if(mem[col].full != bg_tmp.full) {
    a082:	f85a 3026 	ldr.w	r3, [sl, r6, lsl #2]
    a086:	4543      	cmp	r3, r8
    a088:	eb0a 0986 	add.w	r9, sl, r6, lsl #2
    a08c:	d00e      	beq.n	a0ac <lv_draw_fill+0x17e>
                            bg_tmp  = mem[col];
    a08e:	4698      	mov	r8, r3
                            opa_tmp = lv_color_mix(color, bg_tmp, opa);
    a090:	f3c3 4307 	ubfx	r3, r3, #16, #8
    a094:	9301      	str	r3, [sp, #4]
    a096:	f3c8 2307 	ubfx	r3, r8, #8, #8
    a09a:	9300      	str	r3, [sp, #0]
    a09c:	9702      	str	r7, [sp, #8]
    a09e:	fa5f f388 	uxtb.w	r3, r8
    a0a2:	e9dd 1206 	ldrd	r1, r2, [sp, #24]
    a0a6:	9805      	ldr	r0, [sp, #20]
    a0a8:	f7ff ff1c 	bl	9ee4 <lv_color_mix.isra.0>
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
    a0ac:	3601      	adds	r6, #1
                        }

                        mem[col] = opa_tmp;
    a0ae:	f8c9 0000 	str.w	r0, [r9]
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
    a0b2:	b236      	sxth	r6, r6
    a0b4:	9b04      	ldr	r3, [sp, #16]
    a0b6:	42b3      	cmp	r3, r6
    a0b8:	dae3      	bge.n	a082 <lv_draw_fill+0x154>
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
    a0ba:	f10b 0301 	add.w	r3, fp, #1
#if LV_COLOR_DEPTH == 32 && LV_COLOR_SCREEN_TRANSP
                        mem[col] = color_mix_2_alpha(mem[col], mem[col].ch.alpha, color, opa);
#endif
                    }
                }
                mem += mem_width;
    a0be:	44aa      	add	sl, r5
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
    a0c0:	fa0f fb83 	sxth.w	fp, r3
    a0c4:	e788      	b.n	9fd8 <lv_draw_fill+0xaa>

0000a0c6 <lv_draw_map>:
{
    a0c6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a0ca:	b097      	sub	sp, #92	; 0x5c
    a0cc:	461e      	mov	r6, r3
    a0ce:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
    a0d2:	9311      	str	r3, [sp, #68]	; 0x44
    a0d4:	4615      	mov	r5, r2
    a0d6:	f89d 3084 	ldrb.w	r3, [sp, #132]	; 0x84
    a0da:	f89d 208c 	ldrb.w	r2, [sp, #140]	; 0x8c
    a0de:	9312      	str	r3, [sp, #72]	; 0x48
    if(opa < LV_OPA_MIN) return;
    a0e0:	2e0f      	cmp	r6, #15
{
    a0e2:	4607      	mov	r7, r0
    a0e4:	9b22      	ldr	r3, [sp, #136]	; 0x88
    a0e6:	920a      	str	r2, [sp, #40]	; 0x28
    if(opa < LV_OPA_MIN) return;
    a0e8:	f240 80a6 	bls.w	a238 <lv_draw_map+0x172>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
    a0ec:	b2da      	uxtb	r2, r3
    a0ee:	920e      	str	r2, [sp, #56]	; 0x38
    a0f0:	f3c3 2207 	ubfx	r2, r3, #8, #8
    a0f4:	2efc      	cmp	r6, #252	; 0xfc
    a0f6:	9210      	str	r2, [sp, #64]	; 0x40
    a0f8:	f3c3 4307 	ubfx	r3, r3, #16, #8
    union_ok = lv_area_intersect(&masked_a, cords_p, mask_p);
    a0fc:	460a      	mov	r2, r1
    a0fe:	4601      	mov	r1, r0
    a100:	a814      	add	r0, sp, #80	; 0x50
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
    a102:	bf28      	it	cs
    a104:	26ff      	movcs	r6, #255	; 0xff
    a106:	930f      	str	r3, [sp, #60]	; 0x3c
    union_ok = lv_area_intersect(&masked_a, cords_p, mask_p);
    a108:	f001 f8d1 	bl	b2ae <lv_area_intersect>
    if(union_ok == false) return;
    a10c:	2800      	cmp	r0, #0
    a10e:	f000 8093 	beq.w	a238 <lv_draw_map+0x172>
    a112:	88bc      	ldrh	r4, [r7, #4]
    a114:	f9b7 2000 	ldrsh.w	r2, [r7]
    if(cords_p->y1 < masked_a.y1) {
    a118:	f9b7 1002 	ldrsh.w	r1, [r7, #2]
    a11c:	f9bd 3052 	ldrsh.w	r3, [sp, #82]	; 0x52
    a120:	3401      	adds	r4, #1
    a122:	4299      	cmp	r1, r3
    a124:	eba4 0402 	sub.w	r4, r4, r2
        map_p += (uint32_t)map_width * ((masked_a.y1 - cords_p->y1)) * px_size_byte;
    a128:	bfb8      	it	lt
    a12a:	1a5b      	sublt	r3, r3, r1
    a12c:	b224      	sxth	r4, r4
    a12e:	bfbc      	itt	lt
    a130:	4363      	mullt	r3, r4
    a132:	eb05 0583 	addlt.w	r5, r5, r3, lsl #2
    if(cords_p->x1 < masked_a.x1) {
    a136:	f9bd 3050 	ldrsh.w	r3, [sp, #80]	; 0x50
    a13a:	4293      	cmp	r3, r2
        map_p += (masked_a.x1 - cords_p->x1) * px_size_byte;
    a13c:	bfc4      	itt	gt
    a13e:	1a9a      	subgt	r2, r3, r2
    a140:	eb05 0582 	addgt.w	r5, r5, r2, lsl #2
    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
    a144:	f7f9 ff1c 	bl	3f80 <lv_refr_get_disp_refreshing>
    a148:	4680      	mov	r8, r0
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
    a14a:	f001 f84e 	bl	b1ea <lv_disp_get_buf>
    a14e:	4682      	mov	sl, r0
    masked_a.x2 = masked_a.x2 - vdb->area.x1;
    a150:	f9bd 3054 	ldrsh.w	r3, [sp, #84]	; 0x54
    masked_a.x1 = masked_a.x1 - vdb->area.x1;
    a154:	f9ba 1010 	ldrsh.w	r1, [sl, #16]
    masked_a.y1 = masked_a.y1 - vdb->area.y1;
    a158:	f9ba e012 	ldrsh.w	lr, [sl, #18]
    masked_a.x1 = masked_a.x1 - vdb->area.x1;
    a15c:	f9bd 0050 	ldrsh.w	r0, [sp, #80]	; 0x50
    masked_a.y1 = masked_a.y1 - vdb->area.y1;
    a160:	f8bd 7052 	ldrh.w	r7, [sp, #82]	; 0x52
    masked_a.x2 = masked_a.x2 - vdb->area.x1;
    a164:	eba3 0c01 	sub.w	ip, r3, r1
    a168:	f8ad c054 	strh.w	ip, [sp, #84]	; 0x54
    masked_a.y2 = masked_a.y2 - vdb->area.y1;
    a16c:	f8bd c056 	ldrh.w	ip, [sp, #86]	; 0x56
    a170:	ebac 0c0e 	sub.w	ip, ip, lr
    a174:	f8ad c056 	strh.w	ip, [sp, #86]	; 0x56
    a178:	f8ba c014 	ldrh.w	ip, [sl, #20]
    a17c:	f10c 0c01 	add.w	ip, ip, #1
    masked_a.x1 = masked_a.x1 - vdb->area.x1;
    a180:	1a42      	subs	r2, r0, r1
    a182:	ebac 0101 	sub.w	r1, ip, r1
    a186:	b209      	sxth	r1, r1
    a188:	3301      	adds	r3, #1
    a18a:	9105      	str	r1, [sp, #20]
    a18c:	1a18      	subs	r0, r3, r0
    lv_color_t * vdb_buf_tmp = vdb->buf_act;
    a18e:	f8da 1008 	ldr.w	r1, [sl, #8]
    a192:	9106      	str	r1, [sp, #24]
    a194:	b203      	sxth	r3, r0
    vdb_buf_tmp += (uint32_t)masked_a.x1;             /*Move to the first col*/
    a196:	9905      	ldr	r1, [sp, #20]
    a198:	930d      	str	r3, [sp, #52]	; 0x34
    masked_a.y1 = masked_a.y1 - vdb->area.y1;
    a19a:	eba7 070e 	sub.w	r7, r7, lr
    masked_a.x1 = masked_a.x1 - vdb->area.x1;
    a19e:	b212      	sxth	r2, r2
    masked_a.y1 = masked_a.y1 - vdb->area.y1;
    a1a0:	b23f      	sxth	r7, r7
    a1a2:	00a3      	lsls	r3, r4, #2
    masked_a.x1 = masked_a.x1 - vdb->area.x1;
    a1a4:	f8ad 2050 	strh.w	r2, [sp, #80]	; 0x50
    masked_a.y1 = masked_a.y1 - vdb->area.y1;
    a1a8:	930c      	str	r3, [sp, #48]	; 0x30
    vdb_buf_tmp += (uint32_t)masked_a.x1;             /*Move to the first col*/
    a1aa:	fb01 2207 	mla	r2, r1, r7, r2
    if(chroma_key == false && alpha_byte == false && opa == LV_OPA_COVER && recolor_opa == LV_OPA_TRANSP) {
    a1ae:	9b11      	ldr	r3, [sp, #68]	; 0x44
    vdb_buf_tmp += (uint32_t)masked_a.x1;             /*Move to the first col*/
    a1b0:	9906      	ldr	r1, [sp, #24]
    masked_a.y1 = masked_a.y1 - vdb->area.y1;
    a1b2:	f8ad 7052 	strh.w	r7, [sp, #82]	; 0x52
    vdb_buf_tmp += (uint32_t)masked_a.x1;             /*Move to the first col*/
    a1b6:	eb01 0b82 	add.w	fp, r1, r2, lsl #2
    if(chroma_key == false && alpha_byte == false && opa == LV_OPA_COVER && recolor_opa == LV_OPA_TRANSP) {
    a1ba:	2b00      	cmp	r3, #0
    a1bc:	d142      	bne.n	a244 <lv_draw_map+0x17e>
    a1be:	9b12      	ldr	r3, [sp, #72]	; 0x48
    a1c0:	2b00      	cmp	r3, #0
    a1c2:	d13f      	bne.n	a244 <lv_draw_map+0x17e>
    a1c4:	2eff      	cmp	r6, #255	; 0xff
    a1c6:	d13d      	bne.n	a244 <lv_draw_map+0x17e>
    a1c8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a1ca:	2b00      	cmp	r3, #0
    a1cc:	d13a      	bne.n	a244 <lv_draw_map+0x17e>
        if(disp->driver.set_px_cb) {
    a1ce:	f8d8 3014 	ldr.w	r3, [r8, #20]
    a1d2:	bb6b      	cbnz	r3, a230 <lv_draw_map+0x16a>
        memcpy(dest, src, length * sizeof(lv_color_t));
    a1d4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    a1d6:	009e      	lsls	r6, r3, #2
                vdb_buf_tmp += vdb_width;          /*Next row on the VDB*/
    a1d8:	9b05      	ldr	r3, [sp, #20]
    a1da:	009c      	lsls	r4, r3, #2
            for(row = masked_a.y1; row <= masked_a.y2; row++) {
    a1dc:	f9bd 3056 	ldrsh.w	r3, [sp, #86]	; 0x56
    a1e0:	42bb      	cmp	r3, r7
    a1e2:	db29      	blt.n	a238 <lv_draw_map+0x172>
        memcpy(dest, src, length * sizeof(lv_color_t));
    a1e4:	4629      	mov	r1, r5
    a1e6:	4658      	mov	r0, fp
    a1e8:	4632      	mov	r2, r6
    a1ea:	f7fe fb81 	bl	88f0 <memcpy>
                map_p += map_width * px_size_byte; /*Next row on the map*/
    a1ee:	9b0c      	ldr	r3, [sp, #48]	; 0x30
            for(row = masked_a.y1; row <= masked_a.y2; row++) {
    a1f0:	3701      	adds	r7, #1
                map_p += map_width * px_size_byte; /*Next row on the map*/
    a1f2:	441d      	add	r5, r3
                vdb_buf_tmp += vdb_width;          /*Next row on the VDB*/
    a1f4:	44a3      	add	fp, r4
            for(row = masked_a.y1; row <= masked_a.y2; row++) {
    a1f6:	b23f      	sxth	r7, r7
    a1f8:	e7f0      	b.n	a1dc <lv_draw_map+0x116>
                    lv_color_t px_color = *((lv_color_t *)&map_p[(uint32_t)col * px_size_byte]);
    a1fa:	f855 2029 	ldr.w	r2, [r5, r9, lsl #2]
                    disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width, col + masked_a.x1, row,
    a1fe:	f8bd 1050 	ldrh.w	r1, [sp, #80]	; 0x50
    a202:	9700      	str	r7, [sp, #0]
    a204:	e9cd 2601 	strd	r2, r6, [sp, #4]
    a208:	440b      	add	r3, r1
    a20a:	f8d8 4014 	ldr.w	r4, [r8, #20]
    a20e:	9a05      	ldr	r2, [sp, #20]
    a210:	f8da 1008 	ldr.w	r1, [sl, #8]
    a214:	b21b      	sxth	r3, r3
    a216:	4640      	mov	r0, r8
    a218:	47a0      	blx	r4
    a21a:	f109 0901 	add.w	r9, r9, #1
                for(col = 0; col < map_useful_w; col++) {
    a21e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    a220:	fa0f f389 	sxth.w	r3, r9
    a224:	4293      	cmp	r3, r2
    a226:	dbe8      	blt.n	a1fa <lv_draw_map+0x134>
                map_p += map_width * px_size_byte; /*Next row on the map*/
    a228:	9b0c      	ldr	r3, [sp, #48]	; 0x30
            for(row = masked_a.y1; row <= masked_a.y2; row++) {
    a22a:	3701      	adds	r7, #1
                map_p += map_width * px_size_byte; /*Next row on the map*/
    a22c:	441d      	add	r5, r3
            for(row = masked_a.y1; row <= masked_a.y2; row++) {
    a22e:	b23f      	sxth	r7, r7
    a230:	f9bd 3056 	ldrsh.w	r3, [sp, #86]	; 0x56
    a234:	42bb      	cmp	r3, r7
    a236:	da02      	bge.n	a23e <lv_draw_map+0x178>
}
    a238:	b017      	add	sp, #92	; 0x5c
    a23a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a23e:	f04f 0900 	mov.w	r9, #0
    a242:	e7ec      	b.n	a21e <lv_draw_map+0x158>
        lv_color_t last_img_px  = LV_COLOR_BLACK;
    a244:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
    a248:	9309      	str	r3, [sp, #36]	; 0x24
        lv_color_t recolored_px = lv_color_mix(recolor, last_img_px, recolor_opa);
    a24a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a24c:	9302      	str	r3, [sp, #8]
    a24e:	2300      	movs	r3, #0
    a250:	e9cd 3300 	strd	r3, r3, [sp]
    a254:	e9dd 210f 	ldrd	r2, r1, [sp, #60]	; 0x3c
    a258:	980e      	ldr	r0, [sp, #56]	; 0x38
    a25a:	f7ff fe43 	bl	9ee4 <lv_color_mix.isra.0>
        for(row = masked_a.y1; row <= masked_a.y2; row++) {
    a25e:	f9bd 3052 	ldrsh.w	r3, [sp, #82]	; 0x52
    a262:	9306      	str	r3, [sp, #24]
            vdb_buf_tmp += vdb_width;          /*Next row on the VDB*/
    a264:	9b05      	ldr	r3, [sp, #20]
    a266:	009b      	lsls	r3, r3, #2
        lv_color_t recolored_px = lv_color_mix(recolor, last_img_px, recolor_opa);
    a268:	4681      	mov	r9, r0
            vdb_buf_tmp += vdb_width;          /*Next row on the VDB*/
    a26a:	9313      	str	r3, [sp, #76]	; 0x4c
        for(row = masked_a.y1; row <= masked_a.y2; row++) {
    a26c:	f9bd 3056 	ldrsh.w	r3, [sp, #86]	; 0x56
    a270:	9a06      	ldr	r2, [sp, #24]
    a272:	4293      	cmp	r3, r2
    a274:	dbe0      	blt.n	a238 <lv_draw_map+0x172>
    a276:	2300      	movs	r3, #0
    a278:	9508      	str	r5, [sp, #32]
    a27a:	465f      	mov	r7, fp
    a27c:	9307      	str	r3, [sp, #28]
    a27e:	e04e      	b.n	a31e <lv_draw_map+0x258>
                if(alpha_byte) {
    a280:	9b12      	ldr	r3, [sp, #72]	; 0x48
    a282:	2b00      	cmp	r3, #0
    a284:	d03c      	beq.n	a300 <lv_draw_map+0x23a>
                    px_color = *((lv_color_t *)px_color_p);
    a286:	9b08      	ldr	r3, [sp, #32]
                    lv_opa_t px_opa = *(px_color_p + LV_IMG_PX_SIZE_ALPHA_BYTE - 1);
    a288:	78dc      	ldrb	r4, [r3, #3]
                    px_color = *((lv_color_t *)px_color_p);
    a28a:	6818      	ldr	r0, [r3, #0]
                    if(px_opa == LV_OPA_TRANSP)
    a28c:	2c00      	cmp	r4, #0
    a28e:	d03f      	beq.n	a310 <lv_draw_map+0x24a>
                    else if(px_opa != LV_OPA_COVER)
    a290:	2cff      	cmp	r4, #255	; 0xff
    a292:	d037      	beq.n	a304 <lv_draw_map+0x23e>
                        opa_result = (uint32_t)((uint32_t)px_opa * opa_result) >> 8;
    a294:	fb14 f406 	smulbb	r4, r4, r6
    a298:	f3c4 2407 	ubfx	r4, r4, #8, #8
                if(chroma_key && px_color.full == disp->driver.color_chroma_key.full) continue;
    a29c:	9b11      	ldr	r3, [sp, #68]	; 0x44
    a29e:	b11b      	cbz	r3, a2a8 <lv_draw_map+0x1e2>
    a2a0:	f8d8 301c 	ldr.w	r3, [r8, #28]
    a2a4:	4298      	cmp	r0, r3
    a2a6:	d033      	beq.n	a310 <lv_draw_map+0x24a>
                if(recolor_opa != LV_OPA_TRANSP) {
    a2a8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a2aa:	2b00      	cmp	r3, #0
    a2ac:	d059      	beq.n	a362 <lv_draw_map+0x29c>
                    if(last_img_px.full != px_color.full) { /*Minor acceleration: calculate only for
    a2ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a2b0:	4283      	cmp	r3, r0
    a2b2:	d010      	beq.n	a2d6 <lv_draw_map+0x210>
                        recolored_px = lv_color_mix(recolor, last_img_px, recolor_opa);
    a2b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a2b6:	9302      	str	r3, [sp, #8]
    a2b8:	f3c0 4307 	ubfx	r3, r0, #16, #8
                        last_img_px  = px_color;
    a2bc:	9009      	str	r0, [sp, #36]	; 0x24
                        recolored_px = lv_color_mix(recolor, last_img_px, recolor_opa);
    a2be:	9301      	str	r3, [sp, #4]
    a2c0:	f3c0 2307 	ubfx	r3, r0, #8, #8
    a2c4:	9300      	str	r3, [sp, #0]
    a2c6:	e9dd 210f 	ldrd	r2, r1, [sp, #60]	; 0x3c
    a2ca:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
    a2ce:	980e      	ldr	r0, [sp, #56]	; 0x38
    a2d0:	f7ff fe08 	bl	9ee4 <lv_color_mix.isra.0>
    a2d4:	4681      	mov	r9, r0
                    if(disp->driver.set_px_cb) {
    a2d6:	f8d8 3014 	ldr.w	r3, [r8, #20]
    a2da:	469c      	mov	ip, r3
    a2dc:	b1a3      	cbz	r3, a308 <lv_draw_map+0x242>
                        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width, col + masked_a.x1,
    a2de:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    a2e2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    a2e4:	e9cd 9401 	strd	r9, r4, [sp, #4]
    a2e8:	441a      	add	r2, r3
    a2ea:	4613      	mov	r3, r2
                        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width, col + masked_a.x1,
    a2ec:	9a06      	ldr	r2, [sp, #24]
    a2ee:	9200      	str	r2, [sp, #0]
    a2f0:	b21b      	sxth	r3, r3
    a2f2:	9a05      	ldr	r2, [sp, #20]
    a2f4:	f8da 1008 	ldr.w	r1, [sl, #8]
    a2f8:	4640      	mov	r0, r8
    a2fa:	4664      	mov	r4, ip
    a2fc:	47a0      	blx	r4
    a2fe:	e007      	b.n	a310 <lv_draw_map+0x24a>
                    px_color = *((lv_color_t *)px_color_p);
    a300:	9b08      	ldr	r3, [sp, #32]
    a302:	6818      	ldr	r0, [r3, #0]
    a304:	4634      	mov	r4, r6
    a306:	e7c9      	b.n	a29c <lv_draw_map+0x1d6>
                        if(opa_result == LV_OPA_COVER)
    a308:	2cff      	cmp	r4, #255	; 0xff
    a30a:	d118      	bne.n	a33e <lv_draw_map+0x278>
                            vdb_buf_tmp[col].full = recolored_px.full;
    a30c:	f8c7 9000 	str.w	r9, [r7]
                            }
    a310:	9b07      	ldr	r3, [sp, #28]
    a312:	3301      	adds	r3, #1
    a314:	9307      	str	r3, [sp, #28]
    a316:	9b08      	ldr	r3, [sp, #32]
    a318:	3304      	adds	r3, #4
    a31a:	3704      	adds	r7, #4
    a31c:	9308      	str	r3, [sp, #32]
    a31e:	f9bd 301c 	ldrsh.w	r3, [sp, #28]
    a322:	930b      	str	r3, [sp, #44]	; 0x2c
            for(col = 0; col < map_useful_w; col++) {
    a324:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    a326:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    a328:	4293      	cmp	r3, r2
    a32a:	dca9      	bgt.n	a280 <lv_draw_map+0x1ba>
            map_p += map_width * px_size_byte; /*Next row on the map*/
    a32c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a32e:	441d      	add	r5, r3
            vdb_buf_tmp += vdb_width;          /*Next row on the VDB*/
    a330:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    a332:	449b      	add	fp, r3
        for(row = masked_a.y1; row <= masked_a.y2; row++) {
    a334:	9b06      	ldr	r3, [sp, #24]
    a336:	3301      	adds	r3, #1
    a338:	b21b      	sxth	r3, r3
    a33a:	9306      	str	r3, [sp, #24]
    a33c:	e796      	b.n	a26c <lv_draw_map+0x1a6>
                            vdb_buf_tmp[col] = lv_color_mix(recolored_px, vdb_buf_tmp[col], opa_result);
    a33e:	783b      	ldrb	r3, [r7, #0]
    a340:	9402      	str	r4, [sp, #8]
    a342:	78ba      	ldrb	r2, [r7, #2]
    a344:	9201      	str	r2, [sp, #4]
    a346:	787a      	ldrb	r2, [r7, #1]
    a348:	9200      	str	r2, [sp, #0]
    a34a:	f3c9 2107 	ubfx	r1, r9, #8, #8
    a34e:	f3c9 4207 	ubfx	r2, r9, #16, #8
    a352:	fa5f f089 	uxtb.w	r0, r9
                                vdb_buf_tmp[col] = lv_color_mix(px_color, vdb_buf_tmp[col], opa_result);
    a356:	f7ff fdc5 	bl	9ee4 <lv_color_mix.isra.0>
    a35a:	9b07      	ldr	r3, [sp, #28]
    a35c:	f84b 0023 	str.w	r0, [fp, r3, lsl #2]
    a360:	e7d6      	b.n	a310 <lv_draw_map+0x24a>
                    if(disp->driver.set_px_cb) {
    a362:	f8d8 3014 	ldr.w	r3, [r8, #20]
    a366:	469c      	mov	ip, r3
    a368:	b13b      	cbz	r3, a37a <lv_draw_map+0x2b4>
                        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width, col + masked_a.x1,
    a36a:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    a36e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    a370:	441a      	add	r2, r3
    a372:	4613      	mov	r3, r2
    a374:	e9cd 0401 	strd	r0, r4, [sp, #4]
    a378:	e7b8      	b.n	a2ec <lv_draw_map+0x226>
                        if(opa_result == LV_OPA_COVER)
    a37a:	2cff      	cmp	r4, #255	; 0xff
    a37c:	d101      	bne.n	a382 <lv_draw_map+0x2bc>
                            vdb_buf_tmp[col] = px_color;
    a37e:	6038      	str	r0, [r7, #0]
    a380:	e7c6      	b.n	a310 <lv_draw_map+0x24a>
                                vdb_buf_tmp[col] = lv_color_mix(px_color, vdb_buf_tmp[col], opa_result);
    a382:	783b      	ldrb	r3, [r7, #0]
    a384:	9402      	str	r4, [sp, #8]
    a386:	78ba      	ldrb	r2, [r7, #2]
    a388:	9201      	str	r2, [sp, #4]
    a38a:	787a      	ldrb	r2, [r7, #1]
    a38c:	9200      	str	r2, [sp, #0]
    a38e:	f3c0 2107 	ubfx	r1, r0, #8, #8
    a392:	f3c0 4207 	ubfx	r2, r0, #16, #8
    a396:	b2c0      	uxtb	r0, r0
    a398:	e7dd      	b.n	a356 <lv_draw_map+0x290>

0000a39a <lv_draw_cont_radius_corr>:
}

#endif

static uint16_t lv_draw_cont_radius_corr(uint16_t r, lv_coord_t w, lv_coord_t h)
{
    a39a:	b570      	push	{r4, r5, r6, lr}
    a39c:	460e      	mov	r6, r1
    a39e:	4604      	mov	r4, r0
    a3a0:	4615      	mov	r5, r2
    bool aa = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    a3a2:	f7f9 fded 	bl	3f80 <lv_refr_get_disp_refreshing>
    a3a6:	f000 ff18 	bl	b1da <lv_disp_get_antialiasing>

    if(r >= (w >> 1)) {
    a3aa:	1071      	asrs	r1, r6, #1
    a3ac:	428c      	cmp	r4, r1
    a3ae:	db03      	blt.n	a3b8 <lv_draw_cont_radius_corr+0x1e>
        r = (w >> 1);
    a3b0:	b28c      	uxth	r4, r1
        if(r != 0) r--;
    a3b2:	b10c      	cbz	r4, a3b8 <lv_draw_cont_radius_corr+0x1e>
    a3b4:	3c01      	subs	r4, #1
    a3b6:	b2a4      	uxth	r4, r4
    }
    if(r >= (h >> 1)) {
    a3b8:	106a      	asrs	r2, r5, #1
    a3ba:	4294      	cmp	r4, r2
    a3bc:	db03      	blt.n	a3c6 <lv_draw_cont_radius_corr+0x2c>
        r = (h >> 1);
    a3be:	b294      	uxth	r4, r2
        if(r != 0) r--;
    a3c0:	b124      	cbz	r4, a3cc <lv_draw_cont_radius_corr+0x32>
    a3c2:	3c01      	subs	r4, #1
    a3c4:	b2a4      	uxth	r4, r4
    }

    if(r > 0) r -= aa;
    a3c6:	b10c      	cbz	r4, a3cc <lv_draw_cont_radius_corr+0x32>
    a3c8:	1a24      	subs	r4, r4, r0
    a3ca:	b2a4      	uxth	r4, r4

    return r;
}
    a3cc:	4620      	mov	r0, r4
    a3ce:	bd70      	pop	{r4, r5, r6, pc}

0000a3d0 <lv_color_mix.isra.0>:
#elif LV_COLOR_DEPTH == 32
    return color.full;
#endif
}

static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
    a3d0:	b530      	push	{r4, r5, lr}
    a3d2:	f89d 5014 	ldrb.w	r5, [sp, #20]
{
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    a3d6:	b2ac      	uxth	r4, r5
    a3d8:	f1c5 05ff 	rsb	r5, r5, #255	; 0xff
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    LV_COLOR_SET_B(ret, (uint16_t)((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) * (255 - mix)) >> 8);
    a3dc:	436b      	muls	r3, r5
    a3de:	fb00 3304 	mla	r3, r0, r4, r3
    a3e2:	f3c3 2307 	ubfx	r3, r3, #8, #8
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
    a3e6:	2000      	movs	r0, #0
    a3e8:	f363 0007 	bfi	r0, r3, #0, #8
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    a3ec:	f89d 300c 	ldrb.w	r3, [sp, #12]
    a3f0:	fb13 f305 	smulbb	r3, r3, r5
    a3f4:	fb01 3104 	mla	r1, r1, r4, r3
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    a3f8:	f89d 3010 	ldrb.w	r3, [sp, #16]
    a3fc:	fb13 f505 	smulbb	r5, r3, r5
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    a400:	f3c1 2107 	ubfx	r1, r1, #8, #8
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    a404:	fb02 5204 	mla	r2, r2, r4, r5
    return ret;
    a408:	f361 200f 	bfi	r0, r1, #8, #8
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    a40c:	f3c2 2207 	ubfx	r2, r2, #8, #8
    return ret;
    a410:	f362 4017 	bfi	r0, r2, #16, #8
}
    a414:	f040 407f 	orr.w	r0, r0, #4278190080	; 0xff000000
    a418:	bd30      	pop	{r4, r5, pc}

0000a41a <lv_draw_rect>:
{
    a41a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a41e:	b09d      	sub	sp, #116	; 0x74
    a420:	e9cd 1205 	strd	r1, r2, [sp, #20]
    a424:	9307      	str	r3, [sp, #28]
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    a426:	88c3      	ldrh	r3, [r0, #6]
    a428:	8842      	ldrh	r2, [r0, #2]
    a42a:	3301      	adds	r3, #1
    a42c:	1a9b      	subs	r3, r3, r2
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
    a42e:	b21b      	sxth	r3, r3
    a430:	2b00      	cmp	r3, #0
{
    a432:	4681      	mov	r9, r0
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
    a434:	f340 8236 	ble.w	a8a4 <lv_draw_rect+0x48a>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    a438:	8883      	ldrh	r3, [r0, #4]
    a43a:	8802      	ldrh	r2, [r0, #0]
    a43c:	3301      	adds	r3, #1
    a43e:	1a9b      	subs	r3, r3, r2
    a440:	b21b      	sxth	r3, r3
    a442:	2b00      	cmp	r3, #0
    a444:	f340 822e 	ble.w	a8a4 <lv_draw_rect+0x48a>
    if(lv_area_is_on(coords, mask) == false) return;
    a448:	f000 ff7d 	bl	b346 <lv_area_is_on>
    a44c:	2800      	cmp	r0, #0
    a44e:	f000 8229 	beq.w	a8a4 <lv_draw_rect+0x48a>
    if(style->body.opa > LV_OPA_MIN) {
    a452:	9b06      	ldr	r3, [sp, #24]
    a454:	7b9b      	ldrb	r3, [r3, #14]
    a456:	2b10      	cmp	r3, #16
    a458:	f240 80fd 	bls.w	a656 <lv_draw_rect+0x23c>
    uint16_t radius = style->body.radius;
    a45c:	9b06      	ldr	r3, [sp, #24]
    a45e:	899d      	ldrh	r5, [r3, #12]
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    a460:	f7f9 fd8e 	bl	3f80 <lv_refr_get_disp_refreshing>
    a464:	f000 feb9 	bl	b1da <lv_disp_get_antialiasing>
    lv_color_t mcolor = style->body.main_color;
    a468:	9b06      	ldr	r3, [sp, #24]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    a46a:	f8b9 6006 	ldrh.w	r6, [r9, #6]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    a46e:	f8b9 1004 	ldrh.w	r1, [r9, #4]
    lv_color_t gcolor = style->body.grad_color;
    a472:	e9d3 8a01 	ldrd	r8, sl, [r3, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    a476:	f8b9 3002 	ldrh.w	r3, [r9, #2]
    a47a:	3601      	adds	r6, #1
    a47c:	1af6      	subs	r6, r6, r3
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    a47e:	f8b9 3000 	ldrh.w	r3, [r9]
    a482:	3101      	adds	r1, #1
    a484:	1ac9      	subs	r1, r1, r3
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
    a486:	9b07      	ldr	r3, [sp, #28]
    a488:	2bff      	cmp	r3, #255	; 0xff
    a48a:	9b06      	ldr	r3, [sp, #24]
    a48c:	7b9f      	ldrb	r7, [r3, #14]
    a48e:	bf18      	it	ne
    a490:	9b07      	ldrne	r3, [sp, #28]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    a492:	b236      	sxth	r6, r6
    a494:	bf18      	it	ne
    a496:	435f      	mulne	r7, r3
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    a498:	4604      	mov	r4, r0
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    a49a:	b209      	sxth	r1, r1
    radius = lv_draw_cont_radius_corr(radius, width, height);
    a49c:	4632      	mov	r2, r6
    a49e:	4628      	mov	r0, r5
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
    a4a0:	bf18      	it	ne
    a4a2:	0a3f      	lsrne	r7, r7, #8
    radius = lv_draw_cont_radius_corr(radius, width, height);
    a4a4:	f7ff ff79 	bl	a39a <lv_draw_cont_radius_corr>
    if(radius > height / 2) return;
    a4a8:	eb06 73d6 	add.w	r3, r6, r6, lsr #31
    a4ac:	ebb0 0f63 	cmp.w	r0, r3, asr #1
    a4b0:	f340 81fb 	ble.w	a8aa <lv_draw_rect+0x490>
        if(style->body.radius != 0) {
    a4b4:	9b06      	ldr	r3, [sp, #24]
    a4b6:	f9b3 700c 	ldrsh.w	r7, [r3, #12]
    a4ba:	2f00      	cmp	r7, #0
    a4bc:	f000 80cb 	beq.w	a656 <lv_draw_rect+0x23c>
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    a4c0:	f7f9 fd5e 	bl	3f80 <lv_refr_get_disp_refreshing>
    a4c4:	f000 fe89 	bl	b1da <lv_disp_get_antialiasing>
    lv_color_t mcolor = style->body.main_color;
    a4c8:	9b06      	ldr	r3, [sp, #24]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    a4ca:	f8b9 a006 	ldrh.w	sl, [r9, #6]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    a4ce:	f8b9 1004 	ldrh.w	r1, [r9, #4]
    lv_color_t gcolor = style->body.grad_color;
    a4d2:	e9d3 4501 	ldrd	r4, r5, [r3, #4]
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
    a4d6:	9b07      	ldr	r3, [sp, #28]
    a4d8:	2bff      	cmp	r3, #255	; 0xff
    a4da:	9b06      	ldr	r3, [sp, #24]
    a4dc:	7b9e      	ldrb	r6, [r3, #14]
    a4de:	bf1c      	itt	ne
    a4e0:	9b07      	ldrne	r3, [sp, #28]
    a4e2:	435e      	mulne	r6, r3
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    a4e4:	f8b9 3002 	ldrh.w	r3, [r9, #2]
    a4e8:	f10a 0a01 	add.w	sl, sl, #1
    a4ec:	ebaa 0a03 	sub.w	sl, sl, r3
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    a4f0:	f8b9 3000 	ldrh.w	r3, [r9]
    a4f4:	f101 0101 	add.w	r1, r1, #1
    a4f8:	eba1 0103 	sub.w	r1, r1, r3
    uint16_t radius = style->body.radius;
    a4fc:	b2bf      	uxth	r7, r7
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    a4fe:	fa0f fa8a 	sxth.w	sl, sl
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    a502:	4683      	mov	fp, r0
    radius = lv_draw_cont_radius_corr(radius, width, height);
    a504:	4652      	mov	r2, sl
    a506:	b209      	sxth	r1, r1
    a508:	4638      	mov	r0, r7
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
    a50a:	bf18      	it	ne
    a50c:	0a36      	lsrne	r6, r6, #8
    radius = lv_draw_cont_radius_corr(radius, width, height);
    a50e:	f7ff ff44 	bl	a39a <lv_draw_cont_radius_corr>
    lt_origo.x = coords->x1 + radius + aa;
    a512:	f8b9 3000 	ldrh.w	r3, [r9]
    a516:	fa0f f18b 	sxth.w	r1, fp
    a51a:	b202      	sxth	r2, r0
    a51c:	440b      	add	r3, r1
    a51e:	4413      	add	r3, r2
    a520:	fa0f f883 	sxth.w	r8, r3
    lt_origo.y = coords->y1 + radius + aa;
    a524:	f8b9 3002 	ldrh.w	r3, [r9, #2]
    rt_origo.x = coords->x2 - radius - aa;
    a528:	f8b9 b004 	ldrh.w	fp, [r9, #4]
    lt_origo.y = coords->y1 + radius + aa;
    a52c:	440b      	add	r3, r1
    a52e:	4413      	add	r3, r2
    a530:	b21b      	sxth	r3, r3
    a532:	9308      	str	r3, [sp, #32]
    lb_origo.y = coords->y2 - radius - aa;
    a534:	f8b9 3006 	ldrh.w	r3, [r9, #6]
    a538:	1a5b      	subs	r3, r3, r1
    a53a:	1a9b      	subs	r3, r3, r2
    a53c:	b21b      	sxth	r3, r3
    rt_origo.x = coords->x2 - radius - aa;
    a53e:	ebab 0b01 	sub.w	fp, fp, r1
    lv_circ_init(&cir, &cir_tmp, radius);
    a542:	a813      	add	r0, sp, #76	; 0x4c
    a544:	f10d 014a 	add.w	r1, sp, #74	; 0x4a
    rt_origo.x = coords->x2 - radius - aa;
    a548:	ebab 0b02 	sub.w	fp, fp, r2
    lb_origo.y = coords->y2 - radius - aa;
    a54c:	9309      	str	r3, [sp, #36]	; 0x24
    lv_circ_init(&cir, &cir_tmp, radius);
    a54e:	f000 fe6f 	bl	b230 <lv_circ_init>
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
    a552:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a554:	f8bd 204e 	ldrh.w	r2, [sp, #78]	; 0x4e
    a558:	f9bd 104c 	ldrsh.w	r1, [sp, #76]	; 0x4c
    rt_origo.x = coords->x2 - radius - aa;
    a55c:	fa0f fb8b 	sxth.w	fp, fp
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
    a560:	441a      	add	r2, r3
    a562:	b212      	sxth	r2, r2
    a564:	eb0b 0301 	add.w	r3, fp, r1
    a568:	eba8 0101 	sub.w	r1, r8, r1
    a56c:	9200      	str	r2, [sp, #0]
    a56e:	b21b      	sxth	r3, r3
    a570:	b209      	sxth	r1, r1
    a572:	a818      	add	r0, sp, #96	; 0x60
    a574:	f000 fe81 	bl	b27a <lv_area_set>
    lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
    a578:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a57a:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
    a57e:	f9bd 104e 	ldrsh.w	r1, [sp, #78]	; 0x4e
    a582:	441a      	add	r2, r3
    a584:	b212      	sxth	r2, r2
    a586:	eb0b 0301 	add.w	r3, fp, r1
    a58a:	eba8 0101 	sub.w	r1, r8, r1
    a58e:	9200      	str	r2, [sp, #0]
    a590:	b21b      	sxth	r3, r3
    a592:	b209      	sxth	r1, r1
    a594:	a81a      	add	r0, sp, #104	; 0x68
    a596:	f000 fe70 	bl	b27a <lv_area_set>
    lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
    a59a:	9b08      	ldr	r3, [sp, #32]
    a59c:	f8bd 204e 	ldrh.w	r2, [sp, #78]	; 0x4e
    a5a0:	f9bd 104c 	ldrsh.w	r1, [sp, #76]	; 0x4c
    a5a4:	1a9a      	subs	r2, r3, r2
    a5a6:	b212      	sxth	r2, r2
    a5a8:	eb0b 0301 	add.w	r3, fp, r1
    a5ac:	eba8 0101 	sub.w	r1, r8, r1
    a5b0:	9200      	str	r2, [sp, #0]
    a5b2:	b21b      	sxth	r3, r3
    a5b4:	b209      	sxth	r1, r1
    a5b6:	a816      	add	r0, sp, #88	; 0x58
    a5b8:	f000 fe5f 	bl	b27a <lv_area_set>
    lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
    a5bc:	9b08      	ldr	r3, [sp, #32]
    a5be:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
    a5c2:	f9bd 104e 	ldrsh.w	r1, [sp, #78]	; 0x4e
    a5c6:	1a9a      	subs	r2, r3, r2
    a5c8:	b212      	sxth	r2, r2
    a5ca:	eb0b 0301 	add.w	r3, fp, r1
    a5ce:	af14      	add	r7, sp, #80	; 0x50
    a5d0:	eba8 0101 	sub.w	r1, r8, r1
    a5d4:	b21b      	sxth	r3, r3
    a5d6:	9200      	str	r2, [sp, #0]
    a5d8:	b209      	sxth	r1, r1
    a5da:	4638      	mov	r0, r7
    a5dc:	f000 fe4d 	bl	b27a <lv_area_set>
    while(lv_circ_cont(&cir)) {
    a5e0:	ab13      	add	r3, sp, #76	; 0x4c
            lv_draw_fill(&edge_top_area, mask, act_color, opa);
    a5e2:	e9cd 370b 	strd	r3, r7, [sp, #44]	; 0x2c
                act_color = lv_color_mix(mcolor, gcolor, mix);
    a5e6:	b2eb      	uxtb	r3, r5
    a5e8:	930a      	str	r3, [sp, #40]	; 0x28
    while(lv_circ_cont(&cir)) {
    a5ea:	980b      	ldr	r0, [sp, #44]	; 0x2c
    a5ec:	f000 fe27 	bl	b23e <lv_circ_cont>
    a5f0:	2800      	cmp	r0, #0
    a5f2:	f040 81c3 	bne.w	a97c <lv_draw_rect+0x562>
    if(mcolor.full == gcolor.full)
    a5f6:	42ac      	cmp	r4, r5
    a5f8:	f040 82bd 	bne.w	ab76 <lv_draw_rect+0x75c>
        act_color = mcolor;
    a5fc:	4622      	mov	r2, r4
    lv_draw_fill(&edge_top_area, mask, act_color, opa);
    a5fe:	4633      	mov	r3, r6
    a600:	9905      	ldr	r1, [sp, #20]
    a602:	a814      	add	r0, sp, #80	; 0x50
    a604:	f7ff fc93 	bl	9f2e <lv_draw_fill>
    if(edge_top_area.y1 != mid_top_area.y1) {
    a608:	f9bd 205a 	ldrsh.w	r2, [sp, #90]	; 0x5a
    a60c:	f9bd 3052 	ldrsh.w	r3, [sp, #82]	; 0x52
    a610:	4293      	cmp	r3, r2
    a612:	d008      	beq.n	a626 <lv_draw_rect+0x20c>
        if(mcolor.full == gcolor.full)
    a614:	42ac      	cmp	r4, r5
    a616:	f040 82c9 	bne.w	abac <lv_draw_rect+0x792>
            act_color = mcolor;
    a61a:	4622      	mov	r2, r4
        lv_draw_fill(&mid_top_area, mask, act_color, opa);
    a61c:	4633      	mov	r3, r6
    a61e:	9905      	ldr	r1, [sp, #20]
    a620:	a816      	add	r0, sp, #88	; 0x58
    a622:	f7ff fc84 	bl	9f2e <lv_draw_fill>
    if(mcolor.full == gcolor.full)
    a626:	42ac      	cmp	r4, r5
    a628:	f040 82d9 	bne.w	abde <lv_draw_rect+0x7c4>
        act_color = mcolor;
    a62c:	4622      	mov	r2, r4
    lv_draw_fill(&mid_bot_area, mask, act_color, opa);
    a62e:	4633      	mov	r3, r6
    a630:	9905      	ldr	r1, [sp, #20]
    a632:	a818      	add	r0, sp, #96	; 0x60
    a634:	f7ff fc7b 	bl	9f2e <lv_draw_fill>
    if(edge_bot_area.y1 != mid_bot_area.y1) {
    a638:	f9bd 206a 	ldrsh.w	r2, [sp, #106]	; 0x6a
    a63c:	f9bd 3062 	ldrsh.w	r3, [sp, #98]	; 0x62
    a640:	4293      	cmp	r3, r2
    a642:	d008      	beq.n	a656 <lv_draw_rect+0x23c>
        if(mcolor.full == gcolor.full)
    a644:	42ac      	cmp	r4, r5
    a646:	f040 82e5 	bne.w	ac14 <lv_draw_rect+0x7fa>
            act_color = mcolor;
    a64a:	4622      	mov	r2, r4
        lv_draw_fill(&edge_bot_area, mask, act_color, opa);
    a64c:	4633      	mov	r3, r6
    a64e:	9905      	ldr	r1, [sp, #20]
    a650:	a81a      	add	r0, sp, #104	; 0x68
    a652:	f7ff fc6c 	bl	9f2e <lv_draw_fill>
    if(style->body.border.width != 0 && style->body.border.part != LV_BORDER_NONE &&
    a656:	9b06      	ldr	r3, [sp, #24]
    a658:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
    a65c:	2b00      	cmp	r3, #0
    a65e:	f000 8121 	beq.w	a8a4 <lv_draw_rect+0x48a>
    a662:	9b06      	ldr	r3, [sp, #24]
    a664:	7d9b      	ldrb	r3, [r3, #22]
    a666:	2b00      	cmp	r3, #0
    a668:	f000 811c 	beq.w	a8a4 <lv_draw_rect+0x48a>
    a66c:	9b06      	ldr	r3, [sp, #24]
    a66e:	7ddb      	ldrb	r3, [r3, #23]
    a670:	2b0f      	cmp	r3, #15
    a672:	f240 8117 	bls.w	a8a4 <lv_draw_rect+0x48a>
    uint16_t radius = style->body.radius;
    a676:	9b06      	ldr	r3, [sp, #24]
    a678:	f8b3 a00c 	ldrh.w	sl, [r3, #12]
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    a67c:	f7f9 fc80 	bl	3f80 <lv_refr_get_disp_refreshing>
    a680:	f000 fdab 	bl	b1da <lv_disp_get_antialiasing>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    a684:	f8b9 1004 	ldrh.w	r1, [r9, #4]
    a688:	f8b9 3000 	ldrh.w	r3, [r9]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    a68c:	f8b9 2006 	ldrh.w	r2, [r9, #6]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    a690:	3101      	adds	r1, #1
    a692:	1ac9      	subs	r1, r1, r3
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    a694:	f8b9 3002 	ldrh.w	r3, [r9, #2]
    a698:	3201      	adds	r2, #1
    a69a:	1ad2      	subs	r2, r2, r3
    lv_coord_t bwidth = style->body.border.width;
    a69c:	9b06      	ldr	r3, [sp, #24]
    a69e:	f9b3 b014 	ldrsh.w	fp, [r3, #20]
    lv_opa_t opa      = opa_scale == LV_OPA_COVER ? style->body.border.opa
    a6a2:	9b07      	ldr	r3, [sp, #28]
    a6a4:	2bff      	cmp	r3, #255	; 0xff
    a6a6:	9b06      	ldr	r3, [sp, #24]
    a6a8:	7ddc      	ldrb	r4, [r3, #23]
    a6aa:	bf1c      	itt	ne
    a6ac:	9b07      	ldrne	r3, [sp, #28]
    a6ae:	435c      	mulne	r4, r3
    lv_border_part_t part = style->body.border.part;
    a6b0:	9b06      	ldr	r3, [sp, #24]
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    a6b2:	4680      	mov	r8, r0
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    a6b4:	b209      	sxth	r1, r1
    radius = lv_draw_cont_radius_corr(radius, width, height);
    a6b6:	4650      	mov	r0, sl
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    a6b8:	b212      	sxth	r2, r2
    lv_opa_t opa      = opa_scale == LV_OPA_COVER ? style->body.border.opa
    a6ba:	bf18      	it	ne
    a6bc:	0a24      	lsrne	r4, r4, #8
    lv_border_part_t part = style->body.border.part;
    a6be:	7d9e      	ldrb	r6, [r3, #22]
    lv_color_t color      = style->body.border.color;
    a6c0:	691f      	ldr	r7, [r3, #16]
    radius = lv_draw_cont_radius_corr(radius, width, height);
    a6c2:	f7ff fe6a 	bl	a39a <lv_draw_cont_radius_corr>
    bwidth--;
    a6c6:	f10b 35ff 	add.w	r5, fp, #4294967295	; 0xffffffff
    a6ca:	b22d      	sxth	r5, r5
    if(radius < bwidth) {
    a6cc:	42a8      	cmp	r0, r5
    radius = lv_draw_cont_radius_corr(radius, width, height);
    a6ce:	4682      	mov	sl, r0
    if(radius < bwidth) {
    a6d0:	f280 82b9 	bge.w	ac46 <lv_draw_rect+0x82c>
        length_corr = bwidth - radius - aa;
    a6d4:	eba5 0308 	sub.w	r3, r5, r8
    a6d8:	1a1b      	subs	r3, r3, r0
    a6da:	b21b      	sxth	r3, r3
    a6dc:	9309      	str	r3, [sp, #36]	; 0x24
        corner_size = bwidth;
    a6de:	462b      	mov	r3, r5
    if(style->body.radius == 0) {
    a6e0:	9a06      	ldr	r2, [sp, #24]
    a6e2:	f9b2 200c 	ldrsh.w	r2, [r2, #12]
    a6e6:	f006 0102 	and.w	r1, r6, #2
    a6ea:	9108      	str	r1, [sp, #32]
    a6ec:	2a00      	cmp	r2, #0
    a6ee:	f040 82b0 	bne.w	ac52 <lv_draw_rect+0x838>
        if(part & LV_BORDER_TOP) {
    a6f2:	b1a1      	cbz	r1, a71e <lv_draw_rect+0x304>
            work_area.x1 = coords->x1;
    a6f4:	f8b9 3000 	ldrh.w	r3, [r9]
    a6f8:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            work_area.x2 = coords->x2;
    a6fc:	f8b9 3004 	ldrh.w	r3, [r9, #4]
    a700:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.y1 = coords->y1;
    a704:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
    a708:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            work_area.y2 = coords->y1 + bwidth;
    a70c:	442b      	add	r3, r5
    a70e:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    a712:	463a      	mov	r2, r7
    a714:	4623      	mov	r3, r4
    a716:	9905      	ldr	r1, [sp, #20]
    a718:	a81a      	add	r0, sp, #104	; 0x68
    a71a:	f7ff fc08 	bl	9f2e <lv_draw_fill>
        if(part & LV_BORDER_RIGHT) {
    a71e:	0731      	lsls	r1, r6, #28
    a720:	d520      	bpl.n	a764 <lv_draw_rect+0x34a>
            work_area.x1 = coords->x2 - bwidth;
    a722:	f9b9 3004 	ldrsh.w	r3, [r9, #4]
            work_area.x2 = coords->x2;
    a726:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.x1 = coords->x2 - bwidth;
    a72a:	1b5a      	subs	r2, r3, r5
    a72c:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
    a730:	9a08      	ldr	r2, [sp, #32]
    a732:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
            lv_draw_fill(&work_area, mask, color, opa);
    a736:	9905      	ldr	r1, [sp, #20]
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
    a738:	2a00      	cmp	r2, #0
    a73a:	bf14      	ite	ne
    a73c:	465a      	movne	r2, fp
    a73e:	2200      	moveq	r2, #0
    a740:	4413      	add	r3, r2
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
    a742:	f016 0f01 	tst.w	r6, #1
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
    a746:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
    a74a:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    a74e:	bf14      	ite	ne
    a750:	465a      	movne	r2, fp
    a752:	2200      	moveq	r2, #0
    a754:	1a9b      	subs	r3, r3, r2
    a756:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    a75a:	463a      	mov	r2, r7
    a75c:	4623      	mov	r3, r4
    a75e:	a81a      	add	r0, sp, #104	; 0x68
    a760:	f7ff fbe5 	bl	9f2e <lv_draw_fill>
        if(part & LV_BORDER_LEFT) {
    a764:	f016 0f04 	tst.w	r6, #4
    a768:	f006 0601 	and.w	r6, r6, #1
    a76c:	d020      	beq.n	a7b0 <lv_draw_rect+0x396>
            work_area.x1 = coords->x1;
    a76e:	f9b9 3000 	ldrsh.w	r3, [r9]
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
    a772:	9a08      	ldr	r2, [sp, #32]
            work_area.x1 = coords->x1;
    a774:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            work_area.x2 = coords->x1 + bwidth;
    a778:	442b      	add	r3, r5
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
    a77a:	2a00      	cmp	r2, #0
            work_area.x2 = coords->x1 + bwidth;
    a77c:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
    a780:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
            lv_draw_fill(&work_area, mask, color, opa);
    a784:	9905      	ldr	r1, [sp, #20]
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
    a786:	bf14      	ite	ne
    a788:	465a      	movne	r2, fp
    a78a:	2200      	moveq	r2, #0
    a78c:	4413      	add	r3, r2
    a78e:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
    a792:	2e00      	cmp	r6, #0
    a794:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    a798:	bf08      	it	eq
    a79a:	f04f 0b00 	moveq.w	fp, #0
    a79e:	eba3 0b0b 	sub.w	fp, r3, fp
            lv_draw_fill(&work_area, mask, color, opa);
    a7a2:	463a      	mov	r2, r7
    a7a4:	4623      	mov	r3, r4
    a7a6:	a81a      	add	r0, sp, #104	; 0x68
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
    a7a8:	f8ad b06e 	strh.w	fp, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    a7ac:	f7ff fbbf 	bl	9f2e <lv_draw_fill>
        if(part & LV_BORDER_BOTTOM) {
    a7b0:	b1a6      	cbz	r6, a7dc <lv_draw_rect+0x3c2>
            work_area.x1 = coords->x1;
    a7b2:	f8b9 3000 	ldrh.w	r3, [r9]
    a7b6:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            work_area.x2 = coords->x2;
    a7ba:	f8b9 3004 	ldrh.w	r3, [r9, #4]
    a7be:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.y1 = coords->y2 - bwidth;
    a7c2:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    a7c6:	1b5d      	subs	r5, r3, r5
    a7c8:	f8ad 506a 	strh.w	r5, [sp, #106]	; 0x6a
            work_area.y2 = coords->y2;
    a7cc:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    a7d0:	463a      	mov	r2, r7
    a7d2:	4623      	mov	r3, r4
    a7d4:	9905      	ldr	r1, [sp, #20]
    a7d6:	a81a      	add	r0, sp, #104	; 0x68
    a7d8:	f7ff fba9 	bl	9f2e <lv_draw_fill>
        if(style->body.radius != 0) {
    a7dc:	9b06      	ldr	r3, [sp, #24]
    a7de:	f9b3 400c 	ldrsh.w	r4, [r3, #12]
    a7e2:	2c00      	cmp	r4, #0
    a7e4:	d05e      	beq.n	a8a4 <lv_draw_rect+0x48a>
    bool aa               = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    a7e6:	f7f9 fbcb 	bl	3f80 <lv_refr_get_disp_refreshing>
    a7ea:	f000 fcf6 	bl	b1da <lv_disp_get_antialiasing>
    lv_coord_t bwidth     = style->body.border.width;
    a7ee:	9b06      	ldr	r3, [sp, #24]
    a7f0:	f8b9 2006 	ldrh.w	r2, [r9, #6]
    a7f4:	f9b3 a014 	ldrsh.w	sl, [r3, #20]
    lv_color_t color      = style->body.border.color;
    a7f8:	f8d3 b010 	ldr.w	fp, [r3, #16]
    lv_border_part_t part = style->body.border.part;
    a7fc:	7d9b      	ldrb	r3, [r3, #22]
    a7fe:	9308      	str	r3, [sp, #32]
    lv_opa_t opa          = opa_scale == LV_OPA_COVER ? style->body.border.opa
    a800:	9b07      	ldr	r3, [sp, #28]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    a802:	f8b9 1004 	ldrh.w	r1, [r9, #4]
    a806:	2bff      	cmp	r3, #255	; 0xff
    a808:	9b06      	ldr	r3, [sp, #24]
    a80a:	7ddd      	ldrb	r5, [r3, #23]
    a80c:	bf1c      	itt	ne
    a80e:	9b07      	ldrne	r3, [sp, #28]
    a810:	435d      	mulne	r5, r3
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    a812:	f8b9 3002 	ldrh.w	r3, [r9, #2]
    a816:	f102 0201 	add.w	r2, r2, #1
    a81a:	eba2 0203 	sub.w	r2, r2, r3
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    a81e:	f8b9 3000 	ldrh.w	r3, [r9]
    a822:	f101 0101 	add.w	r1, r1, #1
    a826:	eba1 0103 	sub.w	r1, r1, r3
    uint16_t radius       = style->body.radius;
    a82a:	b2a4      	uxth	r4, r4
    bool aa               = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    a82c:	4606      	mov	r6, r0
    radius = lv_draw_cont_radius_corr(radius, width, height);
    a82e:	b212      	sxth	r2, r2
    a830:	b209      	sxth	r1, r1
    a832:	4620      	mov	r0, r4
    lv_opa_t opa          = opa_scale == LV_OPA_COVER ? style->body.border.opa
    a834:	bf18      	it	ne
    a836:	0a2d      	lsrne	r5, r5, #8
    radius = lv_draw_cont_radius_corr(radius, width, height);
    a838:	f7ff fdaf 	bl	a39a <lv_draw_cont_radius_corr>
    lb_origo.y = coords->y2 - radius - aa;
    a83c:	f8b9 3006 	ldrh.w	r3, [r9, #6]
    lt_origo.x = coords->x1 + radius + aa;
    a840:	f8b9 7000 	ldrh.w	r7, [r9]
    lt_origo.y = coords->y1 + radius + aa;
    a844:	f8b9 8002 	ldrh.w	r8, [r9, #2]
    rt_origo.x = coords->x2 - radius - aa;
    a848:	f8b9 9004 	ldrh.w	r9, [r9, #4]
    lt_origo.x = coords->x1 + radius + aa;
    a84c:	b232      	sxth	r2, r6
    a84e:	b204      	sxth	r4, r0
    lb_origo.y = coords->y2 - radius - aa;
    a850:	1a9b      	subs	r3, r3, r2
    a852:	1b1b      	subs	r3, r3, r4
    lt_origo.x = coords->x1 + radius + aa;
    a854:	4417      	add	r7, r2
    lt_origo.y = coords->y1 + radius + aa;
    a856:	4490      	add	r8, r2
    rt_origo.x = coords->x2 - radius - aa;
    a858:	eba9 0902 	sub.w	r9, r9, r2
    lv_circ_init(&cir_out, &tmp_out, radius);
    a85c:	a913      	add	r1, sp, #76	; 0x4c
    a85e:	4622      	mov	r2, r4
    a860:	a816      	add	r0, sp, #88	; 0x58
    lb_origo.y = coords->y2 - radius - aa;
    a862:	b21e      	sxth	r6, r3
    lv_circ_init(&cir_out, &tmp_out, radius);
    a864:	f000 fce4 	bl	b230 <lv_circ_init>
    lv_coord_t radius_in = radius - bwidth;
    a868:	f1ca 0201 	rsb	r2, sl, #1
    a86c:	4422      	add	r2, r4
    a86e:	b212      	sxth	r2, r2
    lv_circ_init(&cir_in, &tmp_in, radius_in);
    a870:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    a874:	a914      	add	r1, sp, #80	; 0x50
    a876:	a818      	add	r0, sp, #96	; 0x60
    a878:	f000 fcda 	bl	b230 <lv_circ_init>
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
    a87c:	9b08      	ldr	r3, [sp, #32]
    lt_origo.x = coords->x1 + radius + aa;
    a87e:	4427      	add	r7, r4
    lt_origo.y = coords->y1 + radius + aa;
    a880:	44a0      	add	r8, r4
    rt_origo.x = coords->x2 - radius - aa;
    a882:	eba9 0904 	sub.w	r9, r9, r4
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
    a886:	f003 0309 	and.w	r3, r3, #9
    lt_origo.x = coords->x1 + radius + aa;
    a88a:	b23f      	sxth	r7, r7
    lt_origo.y = coords->y1 + radius + aa;
    a88c:	fa0f f888 	sxth.w	r8, r8
    rt_origo.x = coords->x2 - radius - aa;
    a890:	fa0f f989 	sxth.w	r9, r9
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
    a894:	9306      	str	r3, [sp, #24]
    while(cir_out.y <= cir_out.x) {
    a896:	f9bd 305a 	ldrsh.w	r3, [sp, #90]	; 0x5a
    a89a:	f9bd 2058 	ldrsh.w	r2, [sp, #88]	; 0x58
    a89e:	429a      	cmp	r2, r3
    a8a0:	f280 8330 	bge.w	af04 <lv_draw_rect+0xaea>
}
    a8a4:	b01d      	add	sp, #116	; 0x74
    a8a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    work_area.x1 = coords->x1;
    a8aa:	f8b9 3000 	ldrh.w	r3, [r9]
    a8ae:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    work_area.x2 = coords->x2;
    a8b2:	f8b9 3004 	ldrh.w	r3, [r9, #4]
    a8b6:	f8b9 5006 	ldrh.w	r5, [r9, #6]
    a8ba:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
    if(mcolor.full == gcolor.full) {
    a8be:	f8b9 3002 	ldrh.w	r3, [r9, #2]
    a8c2:	9a06      	ldr	r2, [sp, #24]
    a8c4:	b200      	sxth	r0, r0
    a8c6:	4403      	add	r3, r0
    a8c8:	45d0      	cmp	r8, sl
    a8ca:	eba5 0000 	sub.w	r0, r5, r0
    a8ce:	b21b      	sxth	r3, r3
    a8d0:	b205      	sxth	r5, r0
    a8d2:	f9b2 200c 	ldrsh.w	r2, [r2, #12]
    a8d6:	d117      	bne.n	a908 <lv_draw_rect+0x4ee>
        work_area.y1 = coords->y1 + radius;
    a8d8:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
        work_area.y2 = coords->y2 - radius;
    a8dc:	f8ad 506e 	strh.w	r5, [sp, #110]	; 0x6e
        if(style->body.radius != 0) {
    a8e0:	b132      	cbz	r2, a8f0 <lv_draw_rect+0x4d6>
            if(aa) {
    a8e2:	b164      	cbz	r4, a8fe <lv_draw_rect+0x4e4>
                work_area.y1 += 2;
    a8e4:	1c9c      	adds	r4, r3, #2
    a8e6:	f8ad 406a 	strh.w	r4, [sp, #106]	; 0x6a
                work_area.y2 -= 2;
    a8ea:	3d02      	subs	r5, #2
                work_area.y2 -= 1;
    a8ec:	f8ad 506e 	strh.w	r5, [sp, #110]	; 0x6e
        lv_draw_fill(&work_area, mask, mcolor, opa);
    a8f0:	463b      	mov	r3, r7
    a8f2:	4642      	mov	r2, r8
    a8f4:	9905      	ldr	r1, [sp, #20]
    a8f6:	a81a      	add	r0, sp, #104	; 0x68
    a8f8:	f7ff fb19 	bl	9f2e <lv_draw_fill>
    a8fc:	e5da      	b.n	a4b4 <lv_draw_rect+0x9a>
                work_area.y1 += 1;
    a8fe:	1c5c      	adds	r4, r3, #1
    a900:	f8ad 406a 	strh.w	r4, [sp, #106]	; 0x6a
                work_area.y2 -= 1;
    a904:	3d01      	subs	r5, #1
    a906:	e7f1      	b.n	a8ec <lv_draw_rect+0x4d2>
        if(style->body.radius != 0) {
    a908:	b122      	cbz	r2, a914 <lv_draw_rect+0x4fa>
            if(aa) {
    a90a:	b39c      	cbz	r4, a974 <lv_draw_rect+0x55a>
                row_start += 2;
    a90c:	1c9c      	adds	r4, r3, #2
    a90e:	b223      	sxth	r3, r4
                row_end -= 2;
    a910:	3d02      	subs	r5, #2
                row_end -= 1;
    a912:	b22d      	sxth	r5, r5
        if(row_start < 0) row_start = 0;
    a914:	ea23 74e3 	bic.w	r4, r3, r3, asr #31
            act_color    = lv_color_mix(mcolor, gcolor, mix);
    a918:	fa5f f38a 	uxtb.w	r3, sl
    a91c:	9308      	str	r3, [sp, #32]
    a91e:	f3c8 4307 	ubfx	r3, r8, #16, #8
    a922:	9309      	str	r3, [sp, #36]	; 0x24
    a924:	f3c8 2b07 	ubfx	fp, r8, #8, #8
        for(row = row_start; row <= row_end; row++) {
    a928:	42ac      	cmp	r4, r5
    a92a:	f73f adc3 	bgt.w	a4b4 <lv_draw_rect+0x9a>
            mix          = (uint32_t)((uint32_t)(coords->y2 - work_area.y1) * 255) / height;
    a92e:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
            work_area.y1 = row;
    a932:	f8ad 406a 	strh.w	r4, [sp, #106]	; 0x6a
            mix          = (uint32_t)((uint32_t)(coords->y2 - work_area.y1) * 255) / height;
    a936:	1b1b      	subs	r3, r3, r4
    a938:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    a93c:	fbb3 f3f6 	udiv	r3, r3, r6
            act_color    = lv_color_mix(mcolor, gcolor, mix);
    a940:	b2db      	uxtb	r3, r3
    a942:	9302      	str	r3, [sp, #8]
    a944:	f3ca 4307 	ubfx	r3, sl, #16, #8
    a948:	9301      	str	r3, [sp, #4]
    a94a:	f3ca 2307 	ubfx	r3, sl, #8, #8
    a94e:	9300      	str	r3, [sp, #0]
    a950:	4659      	mov	r1, fp
    a952:	e9dd 3208 	ldrd	r3, r2, [sp, #32]
    a956:	fa5f f088 	uxtb.w	r0, r8
            work_area.y2 = row;
    a95a:	f8ad 406e 	strh.w	r4, [sp, #110]	; 0x6e
            act_color    = lv_color_mix(mcolor, gcolor, mix);
    a95e:	f7ff fd37 	bl	a3d0 <lv_color_mix.isra.0>
        for(row = row_start; row <= row_end; row++) {
    a962:	3401      	adds	r4, #1
            lv_draw_fill(&work_area, mask, act_color, opa);
    a964:	4602      	mov	r2, r0
    a966:	463b      	mov	r3, r7
    a968:	9905      	ldr	r1, [sp, #20]
    a96a:	a81a      	add	r0, sp, #104	; 0x68
    a96c:	f7ff fadf 	bl	9f2e <lv_draw_fill>
        for(row = row_start; row <= row_end; row++) {
    a970:	b224      	sxth	r4, r4
    a972:	e7d9      	b.n	a928 <lv_draw_rect+0x50e>
                row_start += 1;
    a974:	1c5c      	adds	r4, r3, #1
    a976:	b223      	sxth	r3, r4
                row_end -= 1;
    a978:	3d01      	subs	r5, #1
    a97a:	e7ca      	b.n	a912 <lv_draw_rect+0x4f8>
        if(mid_bot_area.y1 != LV_CIRC_OCT4_Y(cir) + lb_origo.y) mid_bot_refr = 1;
    a97c:	f9bd 3062 	ldrsh.w	r3, [sp, #98]	; 0x62
    a980:	f9bd 704e 	ldrsh.w	r7, [sp, #78]	; 0x4e
    a984:	930d      	str	r3, [sp, #52]	; 0x34
    a986:	9b09      	ldr	r3, [sp, #36]	; 0x24
        if(edge_bot_area.y1 != LV_CIRC_OCT2_Y(cir) + lb_origo.y) edge_bot_refr = 1;
    a988:	f9bd 204c 	ldrsh.w	r2, [sp, #76]	; 0x4c
        if(edge_top_area.y1 != LV_CIRC_OCT7_Y(cir) + lt_origo.y) edge_top_refr = 1;
    a98c:	f9bd 1052 	ldrsh.w	r1, [sp, #82]	; 0x52
        if(mid_bot_area.y1 != LV_CIRC_OCT4_Y(cir) + lb_origo.y) mid_bot_refr = 1;
    a990:	18fb      	adds	r3, r7, r3
    a992:	930e      	str	r3, [sp, #56]	; 0x38
        if(edge_bot_area.y1 != LV_CIRC_OCT2_Y(cir) + lb_origo.y) edge_bot_refr = 1;
    a994:	f9bd 306a 	ldrsh.w	r3, [sp, #106]	; 0x6a
    a998:	930f      	str	r3, [sp, #60]	; 0x3c
    a99a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a99c:	4413      	add	r3, r2
    a99e:	9310      	str	r3, [sp, #64]	; 0x40
        if(mid_top_area.y1 != LV_CIRC_OCT8_Y(cir) + lt_origo.y) mid_top_refr = 1;
    a9a0:	f9bd 305a 	ldrsh.w	r3, [sp, #90]	; 0x5a
    a9a4:	9311      	str	r3, [sp, #68]	; 0x44
    a9a6:	9b08      	ldr	r3, [sp, #32]
        if(edge_top_area.y1 != LV_CIRC_OCT7_Y(cir) + lt_origo.y) edge_top_refr = 1;
    a9a8:	1a9a      	subs	r2, r3, r2
    a9aa:	4291      	cmp	r1, r2
        if(mid_top_area.y1 != LV_CIRC_OCT8_Y(cir) + lt_origo.y) mid_top_refr = 1;
    a9ac:	eba3 0707 	sub.w	r7, r3, r7
        if(edge_top_area.y1 != LV_CIRC_OCT7_Y(cir) + lt_origo.y) edge_top_refr = 1;
    a9b0:	d007      	beq.n	a9c2 <lv_draw_rect+0x5a8>
            if(mcolor.full == gcolor.full)
    a9b2:	42ac      	cmp	r4, r5
    a9b4:	d175      	bne.n	aaa2 <lv_draw_rect+0x688>
                act_color = mcolor;
    a9b6:	4622      	mov	r2, r4
            lv_draw_fill(&edge_top_area, mask, act_color, opa);
    a9b8:	4633      	mov	r3, r6
    a9ba:	9905      	ldr	r1, [sp, #20]
    a9bc:	980c      	ldr	r0, [sp, #48]	; 0x30
    a9be:	f7ff fab6 	bl	9f2e <lv_draw_fill>
        if(mid_top_refr != 0) {
    a9c2:	9b11      	ldr	r3, [sp, #68]	; 0x44
    a9c4:	42bb      	cmp	r3, r7
    a9c6:	d008      	beq.n	a9da <lv_draw_rect+0x5c0>
            if(mcolor.full == gcolor.full)
    a9c8:	42ac      	cmp	r4, r5
    a9ca:	f040 8083 	bne.w	aad4 <lv_draw_rect+0x6ba>
                act_color = mcolor;
    a9ce:	4622      	mov	r2, r4
            lv_draw_fill(&mid_top_area, mask, act_color, opa);
    a9d0:	4633      	mov	r3, r6
    a9d2:	9905      	ldr	r1, [sp, #20]
    a9d4:	a816      	add	r0, sp, #88	; 0x58
    a9d6:	f7ff faaa 	bl	9f2e <lv_draw_fill>
        if(mid_bot_refr != 0) {
    a9da:	e9dd 320d 	ldrd	r3, r2, [sp, #52]	; 0x34
    a9de:	4293      	cmp	r3, r2
    a9e0:	d008      	beq.n	a9f4 <lv_draw_rect+0x5da>
            if(mcolor.full == gcolor.full)
    a9e2:	42ac      	cmp	r4, r5
    a9e4:	f040 8091 	bne.w	ab0a <lv_draw_rect+0x6f0>
                act_color = mcolor;
    a9e8:	4622      	mov	r2, r4
            lv_draw_fill(&mid_bot_area, mask, act_color, opa);
    a9ea:	4633      	mov	r3, r6
    a9ec:	9905      	ldr	r1, [sp, #20]
    a9ee:	a818      	add	r0, sp, #96	; 0x60
    a9f0:	f7ff fa9d 	bl	9f2e <lv_draw_fill>
        if(edge_bot_refr != 0) {
    a9f4:	e9dd 320f 	ldrd	r3, r2, [sp, #60]	; 0x3c
    a9f8:	4293      	cmp	r3, r2
    a9fa:	d008      	beq.n	aa0e <lv_draw_rect+0x5f4>
            if(mcolor.full == gcolor.full)
    a9fc:	42ac      	cmp	r4, r5
    a9fe:	f040 809f 	bne.w	ab40 <lv_draw_rect+0x726>
                act_color = mcolor;
    aa02:	4622      	mov	r2, r4
            lv_draw_fill(&edge_bot_area, mask, act_color, opa);
    aa04:	4633      	mov	r3, r6
    aa06:	9905      	ldr	r1, [sp, #20]
    aa08:	a81a      	add	r0, sp, #104	; 0x68
    aa0a:	f7ff fa90 	bl	9f2e <lv_draw_fill>
        lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
    aa0e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    aa10:	f8bd 204e 	ldrh.w	r2, [sp, #78]	; 0x4e
    aa14:	f9bd 104c 	ldrsh.w	r1, [sp, #76]	; 0x4c
    aa18:	441a      	add	r2, r3
    aa1a:	b212      	sxth	r2, r2
    aa1c:	eb0b 0301 	add.w	r3, fp, r1
    aa20:	eba8 0101 	sub.w	r1, r8, r1
    aa24:	9200      	str	r2, [sp, #0]
    aa26:	a818      	add	r0, sp, #96	; 0x60
    aa28:	b21b      	sxth	r3, r3
    aa2a:	b209      	sxth	r1, r1
    aa2c:	f000 fc25 	bl	b27a <lv_area_set>
        lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
    aa30:	9b09      	ldr	r3, [sp, #36]	; 0x24
    aa32:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
    aa36:	f9bd 104e 	ldrsh.w	r1, [sp, #78]	; 0x4e
    aa3a:	441a      	add	r2, r3
    aa3c:	b212      	sxth	r2, r2
    aa3e:	eb0b 0301 	add.w	r3, fp, r1
    aa42:	eba8 0101 	sub.w	r1, r8, r1
    aa46:	9200      	str	r2, [sp, #0]
    aa48:	a81a      	add	r0, sp, #104	; 0x68
    aa4a:	b21b      	sxth	r3, r3
    aa4c:	b209      	sxth	r1, r1
    aa4e:	f000 fc14 	bl	b27a <lv_area_set>
        lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
    aa52:	9b08      	ldr	r3, [sp, #32]
    aa54:	f8bd 204e 	ldrh.w	r2, [sp, #78]	; 0x4e
    aa58:	f9bd 104c 	ldrsh.w	r1, [sp, #76]	; 0x4c
    aa5c:	1a9a      	subs	r2, r3, r2
    aa5e:	b212      	sxth	r2, r2
    aa60:	eb0b 0301 	add.w	r3, fp, r1
    aa64:	eba8 0101 	sub.w	r1, r8, r1
    aa68:	9200      	str	r2, [sp, #0]
    aa6a:	a816      	add	r0, sp, #88	; 0x58
    aa6c:	b21b      	sxth	r3, r3
    aa6e:	b209      	sxth	r1, r1
    aa70:	f000 fc03 	bl	b27a <lv_area_set>
        lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
    aa74:	9b08      	ldr	r3, [sp, #32]
    aa76:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
    aa7a:	f9bd 104e 	ldrsh.w	r1, [sp, #78]	; 0x4e
    aa7e:	980c      	ldr	r0, [sp, #48]	; 0x30
    aa80:	1a9a      	subs	r2, r3, r2
    aa82:	b212      	sxth	r2, r2
    aa84:	eb0b 0301 	add.w	r3, fp, r1
    aa88:	eba8 0101 	sub.w	r1, r8, r1
    aa8c:	9200      	str	r2, [sp, #0]
    aa8e:	b21b      	sxth	r3, r3
    aa90:	b209      	sxth	r1, r1
    aa92:	f000 fbf2 	bl	b27a <lv_area_set>
        lv_circ_next(&cir, &cir_tmp);
    aa96:	f10d 014a 	add.w	r1, sp, #74	; 0x4a
    aa9a:	980b      	ldr	r0, [sp, #44]	; 0x2c
    aa9c:	f000 fbd8 	bl	b250 <lv_circ_next>
    aaa0:	e5a3      	b.n	a5ea <lv_draw_rect+0x1d0>
                mix       = (uint32_t)((uint32_t)(coords->y2 - edge_top_area.y1) * 255) / height;
    aaa2:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    aaa6:	1a5b      	subs	r3, r3, r1
    aaa8:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    aaac:	fbb3 f3fa 	udiv	r3, r3, sl
                act_color = lv_color_mix(mcolor, gcolor, mix);
    aab0:	b2db      	uxtb	r3, r3
    aab2:	9302      	str	r3, [sp, #8]
    aab4:	f3c5 4307 	ubfx	r3, r5, #16, #8
    aab8:	9301      	str	r3, [sp, #4]
    aaba:	f3c5 2307 	ubfx	r3, r5, #8, #8
    aabe:	9300      	str	r3, [sp, #0]
    aac0:	f3c4 4207 	ubfx	r2, r4, #16, #8
    aac4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    aac6:	f3c4 2107 	ubfx	r1, r4, #8, #8
    aaca:	b2e0      	uxtb	r0, r4
    aacc:	f7ff fc80 	bl	a3d0 <lv_color_mix.isra.0>
    aad0:	4602      	mov	r2, r0
    aad2:	e771      	b.n	a9b8 <lv_draw_rect+0x59e>
                mix       = (uint32_t)((uint32_t)(coords->y2 - mid_top_area.y1) * 255) / height;
    aad4:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    aad8:	f9bd 205a 	ldrsh.w	r2, [sp, #90]	; 0x5a
    aadc:	1a9b      	subs	r3, r3, r2
    aade:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    aae2:	fbb3 f3fa 	udiv	r3, r3, sl
                act_color = lv_color_mix(mcolor, gcolor, mix);
    aae6:	b2db      	uxtb	r3, r3
    aae8:	9302      	str	r3, [sp, #8]
    aaea:	f3c5 4307 	ubfx	r3, r5, #16, #8
    aaee:	9301      	str	r3, [sp, #4]
    aaf0:	f3c5 2307 	ubfx	r3, r5, #8, #8
    aaf4:	9300      	str	r3, [sp, #0]
    aaf6:	f3c4 4207 	ubfx	r2, r4, #16, #8
    aafa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    aafc:	f3c4 2107 	ubfx	r1, r4, #8, #8
    ab00:	b2e0      	uxtb	r0, r4
    ab02:	f7ff fc65 	bl	a3d0 <lv_color_mix.isra.0>
    ab06:	4602      	mov	r2, r0
    ab08:	e762      	b.n	a9d0 <lv_draw_rect+0x5b6>
                mix       = (uint32_t)((uint32_t)(coords->y2 - mid_bot_area.y1) * 255) / height;
    ab0a:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    ab0e:	f9bd 2062 	ldrsh.w	r2, [sp, #98]	; 0x62
    ab12:	1a9b      	subs	r3, r3, r2
    ab14:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    ab18:	fbb3 f3fa 	udiv	r3, r3, sl
                act_color = lv_color_mix(mcolor, gcolor, mix);
    ab1c:	b2db      	uxtb	r3, r3
    ab1e:	9302      	str	r3, [sp, #8]
    ab20:	f3c5 4307 	ubfx	r3, r5, #16, #8
    ab24:	9301      	str	r3, [sp, #4]
    ab26:	f3c5 2307 	ubfx	r3, r5, #8, #8
    ab2a:	9300      	str	r3, [sp, #0]
    ab2c:	f3c4 4207 	ubfx	r2, r4, #16, #8
    ab30:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ab32:	f3c4 2107 	ubfx	r1, r4, #8, #8
    ab36:	b2e0      	uxtb	r0, r4
    ab38:	f7ff fc4a 	bl	a3d0 <lv_color_mix.isra.0>
    ab3c:	4602      	mov	r2, r0
    ab3e:	e754      	b.n	a9ea <lv_draw_rect+0x5d0>
                mix       = (uint32_t)((uint32_t)(coords->y2 - edge_bot_area.y1) * 255) / height;
    ab40:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    ab44:	f9bd 206a 	ldrsh.w	r2, [sp, #106]	; 0x6a
    ab48:	1a9b      	subs	r3, r3, r2
    ab4a:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    ab4e:	fbb3 f3fa 	udiv	r3, r3, sl
                act_color = lv_color_mix(mcolor, gcolor, mix);
    ab52:	b2db      	uxtb	r3, r3
    ab54:	9302      	str	r3, [sp, #8]
    ab56:	f3c5 4307 	ubfx	r3, r5, #16, #8
    ab5a:	9301      	str	r3, [sp, #4]
    ab5c:	f3c5 2307 	ubfx	r3, r5, #8, #8
    ab60:	9300      	str	r3, [sp, #0]
    ab62:	f3c4 4207 	ubfx	r2, r4, #16, #8
    ab66:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ab68:	f3c4 2107 	ubfx	r1, r4, #8, #8
    ab6c:	b2e0      	uxtb	r0, r4
    ab6e:	f7ff fc2f 	bl	a3d0 <lv_color_mix.isra.0>
    ab72:	4602      	mov	r2, r0
    ab74:	e746      	b.n	aa04 <lv_draw_rect+0x5ea>
        mix       = (uint32_t)((uint32_t)(coords->y2 - edge_top_area.y1) * 255) / height;
    ab76:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    ab7a:	f9bd 2052 	ldrsh.w	r2, [sp, #82]	; 0x52
    ab7e:	1a9b      	subs	r3, r3, r2
    ab80:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    ab84:	fbb3 f3fa 	udiv	r3, r3, sl
        act_color = lv_color_mix(mcolor, gcolor, mix);
    ab88:	b2db      	uxtb	r3, r3
    ab8a:	9302      	str	r3, [sp, #8]
    ab8c:	f3c5 4307 	ubfx	r3, r5, #16, #8
    ab90:	9301      	str	r3, [sp, #4]
    ab92:	f3c5 2307 	ubfx	r3, r5, #8, #8
    ab96:	9300      	str	r3, [sp, #0]
    ab98:	f3c4 4207 	ubfx	r2, r4, #16, #8
    ab9c:	b2eb      	uxtb	r3, r5
    ab9e:	f3c4 2107 	ubfx	r1, r4, #8, #8
    aba2:	b2e0      	uxtb	r0, r4
    aba4:	f7ff fc14 	bl	a3d0 <lv_color_mix.isra.0>
    aba8:	4602      	mov	r2, r0
    abaa:	e528      	b.n	a5fe <lv_draw_rect+0x1e4>
            mix       = (uint32_t)((uint32_t)(coords->y2 - mid_top_area.y1) * 255) / height;
    abac:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    abb0:	1a9b      	subs	r3, r3, r2
    abb2:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    abb6:	fbb3 f3fa 	udiv	r3, r3, sl
            act_color = lv_color_mix(mcolor, gcolor, mix);
    abba:	b2db      	uxtb	r3, r3
    abbc:	9302      	str	r3, [sp, #8]
    abbe:	f3c5 4307 	ubfx	r3, r5, #16, #8
    abc2:	9301      	str	r3, [sp, #4]
    abc4:	f3c5 2307 	ubfx	r3, r5, #8, #8
    abc8:	9300      	str	r3, [sp, #0]
    abca:	f3c4 4207 	ubfx	r2, r4, #16, #8
    abce:	b2eb      	uxtb	r3, r5
    abd0:	f3c4 2107 	ubfx	r1, r4, #8, #8
    abd4:	b2e0      	uxtb	r0, r4
    abd6:	f7ff fbfb 	bl	a3d0 <lv_color_mix.isra.0>
    abda:	4602      	mov	r2, r0
    abdc:	e51e      	b.n	a61c <lv_draw_rect+0x202>
        mix       = (uint32_t)((uint32_t)(coords->y2 - mid_bot_area.y1) * 255) / height;
    abde:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    abe2:	f9bd 2062 	ldrsh.w	r2, [sp, #98]	; 0x62
    abe6:	1a9b      	subs	r3, r3, r2
    abe8:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    abec:	fbb3 f3fa 	udiv	r3, r3, sl
        act_color = lv_color_mix(mcolor, gcolor, mix);
    abf0:	b2db      	uxtb	r3, r3
    abf2:	9302      	str	r3, [sp, #8]
    abf4:	f3c5 4307 	ubfx	r3, r5, #16, #8
    abf8:	9301      	str	r3, [sp, #4]
    abfa:	f3c5 2307 	ubfx	r3, r5, #8, #8
    abfe:	9300      	str	r3, [sp, #0]
    ac00:	f3c4 4207 	ubfx	r2, r4, #16, #8
    ac04:	b2eb      	uxtb	r3, r5
    ac06:	f3c4 2107 	ubfx	r1, r4, #8, #8
    ac0a:	b2e0      	uxtb	r0, r4
    ac0c:	f7ff fbe0 	bl	a3d0 <lv_color_mix.isra.0>
    ac10:	4602      	mov	r2, r0
    ac12:	e50c      	b.n	a62e <lv_draw_rect+0x214>
            mix       = (uint32_t)((uint32_t)(coords->y2 - edge_bot_area.y1) * 255) / height;
    ac14:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    ac18:	1a9b      	subs	r3, r3, r2
    ac1a:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    ac1e:	fbb3 f3fa 	udiv	r3, r3, sl
            act_color = lv_color_mix(mcolor, gcolor, mix);
    ac22:	b2db      	uxtb	r3, r3
    ac24:	9302      	str	r3, [sp, #8]
    ac26:	f3c5 4307 	ubfx	r3, r5, #16, #8
    ac2a:	9301      	str	r3, [sp, #4]
    ac2c:	f3c5 2307 	ubfx	r3, r5, #8, #8
    ac30:	9300      	str	r3, [sp, #0]
    ac32:	f3c4 4207 	ubfx	r2, r4, #16, #8
    ac36:	b2eb      	uxtb	r3, r5
    ac38:	f3c4 2107 	ubfx	r1, r4, #8, #8
    ac3c:	b2e0      	uxtb	r0, r4
    ac3e:	f7ff fbc7 	bl	a3d0 <lv_color_mix.isra.0>
    ac42:	4602      	mov	r2, r0
    ac44:	e502      	b.n	a64c <lv_draw_rect+0x232>
        corner_size = radius + aa;
    ac46:	eb00 0308 	add.w	r3, r0, r8
    lv_coord_t length_corr = 0;
    ac4a:	2200      	movs	r2, #0
        corner_size = radius + aa;
    ac4c:	b21b      	sxth	r3, r3
    lv_coord_t length_corr = 0;
    ac4e:	9209      	str	r2, [sp, #36]	; 0x24
    ac50:	e546      	b.n	a6e0 <lv_draw_rect+0x2c6>
    if(part & LV_BORDER_TOP)
    ac52:	9a08      	ldr	r2, [sp, #32]
    corner_size++;
    ac54:	f103 0b01 	add.w	fp, r3, #1
    ac58:	fa0f fb8b 	sxth.w	fp, fp
    if(part & LV_BORDER_TOP)
    ac5c:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
    ac60:	2a00      	cmp	r2, #0
    ac62:	f000 814d 	beq.w	af00 <lv_draw_rect+0xae6>
        work_area.y1 = coords->y1 + corner_size;
    ac66:	445b      	add	r3, fp
        work_area.y1 = coords->y1 + radius;
    ac68:	b21b      	sxth	r3, r3
    ac6a:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
    if(part & LV_BORDER_BOTTOM)
    ac6e:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    ac72:	f016 0201 	ands.w	r2, r6, #1
        work_area.y2 = coords->y2 - corner_size;
    ac76:	bf14      	ite	ne
    ac78:	eba3 030b 	subne.w	r3, r3, fp
        work_area.y2 = coords->y2 - radius;
    ac7c:	eba3 030a 	subeq.w	r3, r3, sl
    if(part & LV_BORDER_BOTTOM)
    ac80:	920a      	str	r2, [sp, #40]	; 0x28
        work_area.y2 = coords->y2 - radius;
    ac82:	b21b      	sxth	r3, r3
    if(part & LV_BORDER_LEFT) {
    ac84:	0772      	lsls	r2, r6, #29
    ac86:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
    ac8a:	d50c      	bpl.n	aca6 <lv_draw_rect+0x88c>
        work_area.x1 = coords->x1;
    ac8c:	f9b9 3000 	ldrsh.w	r3, [r9]
    ac90:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
        work_area.x2 = work_area.x1 + bwidth;
    ac94:	442b      	add	r3, r5
    ac96:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
        lv_draw_fill(&work_area, mask, color, opa);
    ac9a:	463a      	mov	r2, r7
    ac9c:	4623      	mov	r3, r4
    ac9e:	9905      	ldr	r1, [sp, #20]
    aca0:	a81a      	add	r0, sp, #104	; 0x68
    aca2:	f7ff f944 	bl	9f2e <lv_draw_fill>
    if(part & LV_BORDER_RIGHT) {
    aca6:	0733      	lsls	r3, r6, #28
    aca8:	d50c      	bpl.n	acc4 <lv_draw_rect+0x8aa>
    acaa:	f9b9 3004 	ldrsh.w	r3, [r9, #4]
        work_area.x2 = coords->x2;
    acae:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
        work_area.x1 = work_area.x2 - bwidth;
    acb2:	1b5b      	subs	r3, r3, r5
    acb4:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
        lv_draw_fill(&work_area, mask, color, opa);
    acb8:	463a      	mov	r2, r7
    acba:	4623      	mov	r3, r4
    acbc:	9905      	ldr	r1, [sp, #20]
    acbe:	a81a      	add	r0, sp, #104	; 0x68
    acc0:	f7ff f935 	bl	9f2e <lv_draw_fill>
    work_area.x1 = coords->x1 + corner_size - length_corr;
    acc4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    acc6:	f8b9 2000 	ldrh.w	r2, [r9]
    acca:	ebab 0303 	sub.w	r3, fp, r3
    acce:	4413      	add	r3, r2
    acd0:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    work_area.x2 = coords->x2 - corner_size + length_corr;
    acd4:	9a09      	ldr	r2, [sp, #36]	; 0x24
    acd6:	f8b9 3004 	ldrh.w	r3, [r9, #4]
    acda:	4413      	add	r3, r2
    acdc:	eba3 0b0b 	sub.w	fp, r3, fp
    if(part & LV_BORDER_TOP) {
    ace0:	9b08      	ldr	r3, [sp, #32]
    work_area.x2 = coords->x2 - corner_size + length_corr;
    ace2:	f8ad b06c 	strh.w	fp, [sp, #108]	; 0x6c
    if(part & LV_BORDER_TOP) {
    ace6:	b163      	cbz	r3, ad02 <lv_draw_rect+0x8e8>
        work_area.y1 = coords->y1;
    ace8:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
    acec:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
        work_area.y2 = coords->y1 + bwidth;
    acf0:	442b      	add	r3, r5
    acf2:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
        lv_draw_fill(&work_area, mask, color, opa);
    acf6:	463a      	mov	r2, r7
    acf8:	4623      	mov	r3, r4
    acfa:	9905      	ldr	r1, [sp, #20]
    acfc:	a81a      	add	r0, sp, #104	; 0x68
    acfe:	f7ff f916 	bl	9f2e <lv_draw_fill>
    if(part & LV_BORDER_BOTTOM) {
    ad02:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ad04:	b163      	cbz	r3, ad20 <lv_draw_rect+0x906>
        work_area.y2 = coords->y2;
    ad06:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    ad0a:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
        work_area.y1 = work_area.y2 - bwidth;
    ad0e:	1b5b      	subs	r3, r3, r5
    ad10:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
        lv_draw_fill(&work_area, mask, color, opa);
    ad14:	463a      	mov	r2, r7
    ad16:	4623      	mov	r3, r4
    ad18:	9905      	ldr	r1, [sp, #20]
    ad1a:	a81a      	add	r0, sp, #104	; 0x68
    ad1c:	f7ff f907 	bl	9f2e <lv_draw_fill>
    if(length_corr != 0) {
    ad20:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ad22:	2b00      	cmp	r3, #0
    ad24:	f000 8086 	beq.w	ae34 <lv_draw_rect+0xa1a>
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
    ad28:	f006 0306 	and.w	r3, r6, #6
    ad2c:	2b06      	cmp	r3, #6
    ad2e:	d11c      	bne.n	ad6a <lv_draw_rect+0x950>
            work_area.x1 = coords->x1;
    ad30:	f9b9 3000 	ldrsh.w	r3, [r9]
    ad34:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            work_area.x2 = coords->x1 + radius + aa;
    ad38:	fa0f f188 	sxth.w	r1, r8
    ad3c:	fa0f f28a 	sxth.w	r2, sl
    ad40:	440b      	add	r3, r1
    ad42:	4413      	add	r3, r2
    ad44:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.y1 = coords->y1 + radius + 1 + aa;
    ad48:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
            work_area.x2 = coords->x1 + radius + aa;
    ad4c:	4610      	mov	r0, r2
            work_area.y1 = coords->y1 + radius + 1 + aa;
    ad4e:	1c5a      	adds	r2, r3, #1
    ad50:	4411      	add	r1, r2
    ad52:	1842      	adds	r2, r0, r1
            work_area.y2 = coords->y1 + bwidth;
    ad54:	442b      	add	r3, r5
            work_area.y1 = coords->y1 + radius + 1 + aa;
    ad56:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            work_area.y2 = coords->y1 + bwidth;
    ad5a:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    ad5e:	463a      	mov	r2, r7
    ad60:	4623      	mov	r3, r4
    ad62:	9905      	ldr	r1, [sp, #20]
    ad64:	a81a      	add	r0, sp, #104	; 0x68
    ad66:	f7ff f8e2 	bl	9f2e <lv_draw_fill>
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
    ad6a:	f006 030a 	and.w	r3, r6, #10
    ad6e:	2b0a      	cmp	r3, #10
    ad70:	d11d      	bne.n	adae <lv_draw_rect+0x994>
            work_area.x1 = coords->x2 - radius - aa;
    ad72:	f9b9 c004 	ldrsh.w	ip, [r9, #4]
            work_area.x2 = coords->x2;
    ad76:	f8ad c06c 	strh.w	ip, [sp, #108]	; 0x6c
            work_area.x1 = coords->x2 - radius - aa;
    ad7a:	fa0f f188 	sxth.w	r1, r8
    ad7e:	fa0f f28a 	sxth.w	r2, sl
    ad82:	ebac 0301 	sub.w	r3, ip, r1
    ad86:	1a9b      	subs	r3, r3, r2
    ad88:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            work_area.y1 = coords->y1 + radius + 1 + aa;
    ad8c:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
            work_area.x1 = coords->x2 - radius - aa;
    ad90:	4610      	mov	r0, r2
            work_area.y1 = coords->y1 + radius + 1 + aa;
    ad92:	1c5a      	adds	r2, r3, #1
    ad94:	4411      	add	r1, r2
    ad96:	1842      	adds	r2, r0, r1
            work_area.y2 = coords->y1 + bwidth;
    ad98:	442b      	add	r3, r5
            work_area.y1 = coords->y1 + radius + 1 + aa;
    ad9a:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            work_area.y2 = coords->y1 + bwidth;
    ad9e:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    ada2:	463a      	mov	r2, r7
    ada4:	4623      	mov	r3, r4
    ada6:	9905      	ldr	r1, [sp, #20]
    ada8:	a81a      	add	r0, sp, #104	; 0x68
    adaa:	f7ff f8c0 	bl	9f2e <lv_draw_fill>
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
    adae:	f006 0305 	and.w	r3, r6, #5
    adb2:	2b05      	cmp	r3, #5
    adb4:	d11c      	bne.n	adf0 <lv_draw_rect+0x9d6>
            work_area.x1 = coords->x1;
    adb6:	f9b9 2000 	ldrsh.w	r2, [r9]
    adba:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            work_area.x2 = coords->x1 + radius + aa;
    adbe:	fa0f f088 	sxth.w	r0, r8
    adc2:	fa0f f38a 	sxth.w	r3, sl
    adc6:	4402      	add	r2, r0
    adc8:	4619      	mov	r1, r3
    adca:	441a      	add	r2, r3
            work_area.y1 = coords->y2 - bwidth;
    adcc:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
            work_area.x2 = coords->x1 + radius + aa;
    add0:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
            work_area.y1 = coords->y2 - bwidth;
    add4:	1b5a      	subs	r2, r3, r5
            work_area.y2 = coords->y2 - radius - 1 - aa;
    add6:	3b01      	subs	r3, #1
    add8:	1a1b      	subs	r3, r3, r0
    adda:	1a5b      	subs	r3, r3, r1
            work_area.y1 = coords->y2 - bwidth;
    addc:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            work_area.y2 = coords->y2 - radius - 1 - aa;
    ade0:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    ade4:	463a      	mov	r2, r7
    ade6:	4623      	mov	r3, r4
    ade8:	9905      	ldr	r1, [sp, #20]
    adea:	a81a      	add	r0, sp, #104	; 0x68
    adec:	f7ff f89f 	bl	9f2e <lv_draw_fill>
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
    adf0:	f006 0309 	and.w	r3, r6, #9
    adf4:	2b09      	cmp	r3, #9
    adf6:	d11d      	bne.n	ae34 <lv_draw_rect+0xa1a>
            work_area.x1 = coords->x2 - radius - aa;
    adf8:	f9b9 3004 	ldrsh.w	r3, [r9, #4]
            work_area.x2 = coords->x2;
    adfc:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.x1 = coords->x2 - radius - aa;
    ae00:	fa0f f188 	sxth.w	r1, r8
    ae04:	1a5a      	subs	r2, r3, r1
            work_area.y1 = coords->y2 - bwidth;
    ae06:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
            work_area.x1 = coords->x2 - radius - aa;
    ae0a:	fa0f fa8a 	sxth.w	sl, sl
            work_area.y1 = coords->y2 - bwidth;
    ae0e:	1b5d      	subs	r5, r3, r5
            work_area.y2 = coords->y2 - radius - 1 - aa;
    ae10:	3b01      	subs	r3, #1
            work_area.x1 = coords->x2 - radius - aa;
    ae12:	eba2 020a 	sub.w	r2, r2, sl
            work_area.y2 = coords->y2 - radius - 1 - aa;
    ae16:	1a5b      	subs	r3, r3, r1
    ae18:	eba3 0a0a 	sub.w	sl, r3, sl
            work_area.x1 = coords->x2 - radius - aa;
    ae1c:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            lv_draw_fill(&work_area, mask, color, opa);
    ae20:	4623      	mov	r3, r4
    ae22:	463a      	mov	r2, r7
    ae24:	9905      	ldr	r1, [sp, #20]
            work_area.y1 = coords->y2 - bwidth;
    ae26:	f8ad 506a 	strh.w	r5, [sp, #106]	; 0x6a
            lv_draw_fill(&work_area, mask, color, opa);
    ae2a:	a81a      	add	r0, sp, #104	; 0x68
            work_area.y2 = coords->y2 - radius - 1 - aa;
    ae2c:	f8ad a06e 	strh.w	sl, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    ae30:	f7ff f87d 	bl	9f2e <lv_draw_fill>
    if(style->body.radius == 0) {
    ae34:	9b06      	ldr	r3, [sp, #24]
    ae36:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
    ae3a:	2b00      	cmp	r3, #0
    ae3c:	f47f acce 	bne.w	a7dc <lv_draw_rect+0x3c2>
        if(part & (LV_BORDER_TOP | LV_BORDER_LEFT)) {
    ae40:	f016 0f06 	tst.w	r6, #6
    ae44:	d015      	beq.n	ae72 <lv_draw_rect+0xa58>
            work_area.x1 = coords->x1;
    ae46:	f9b9 2000 	ldrsh.w	r2, [r9]
    ae4a:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            work_area.x2 = coords->x1 + aa;
    ae4e:	fa0f f388 	sxth.w	r3, r8
    ae52:	441a      	add	r2, r3
    ae54:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
            work_area.y1 = coords->y1;
    ae58:	f9b9 2002 	ldrsh.w	r2, [r9, #2]
    ae5c:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            work_area.y2 = coords->y1 + aa;
    ae60:	4413      	add	r3, r2
    ae62:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    ae66:	463a      	mov	r2, r7
    ae68:	4623      	mov	r3, r4
    ae6a:	9905      	ldr	r1, [sp, #20]
    ae6c:	a81a      	add	r0, sp, #104	; 0x68
    ae6e:	f7ff f85e 	bl	9f2e <lv_draw_fill>
        if(part & (LV_BORDER_TOP | LV_BORDER_RIGHT)) {
    ae72:	f016 0f0a 	tst.w	r6, #10
    ae76:	d015      	beq.n	aea4 <lv_draw_rect+0xa8a>
            work_area.x1 = coords->x2 - aa;
    ae78:	f9b9 2004 	ldrsh.w	r2, [r9, #4]
            work_area.x2 = coords->x2;
    ae7c:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
            work_area.x1 = coords->x2 - aa;
    ae80:	fa0f f388 	sxth.w	r3, r8
    ae84:	1ad1      	subs	r1, r2, r3
            work_area.y1 = coords->y1;
    ae86:	f9b9 2002 	ldrsh.w	r2, [r9, #2]
            work_area.x1 = coords->x2 - aa;
    ae8a:	f8ad 1068 	strh.w	r1, [sp, #104]	; 0x68
            work_area.y2 = coords->y1 + aa;
    ae8e:	4413      	add	r3, r2
            work_area.y1 = coords->y1;
    ae90:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            work_area.y2 = coords->y1 + aa;
    ae94:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    ae98:	463a      	mov	r2, r7
    ae9a:	4623      	mov	r3, r4
    ae9c:	9905      	ldr	r1, [sp, #20]
    ae9e:	a81a      	add	r0, sp, #104	; 0x68
    aea0:	f7ff f845 	bl	9f2e <lv_draw_fill>
        if(part & (LV_BORDER_BOTTOM | LV_BORDER_LEFT)) {
    aea4:	f016 0f05 	tst.w	r6, #5
    aea8:	d015      	beq.n	aed6 <lv_draw_rect+0xabc>
            work_area.x1 = coords->x1;
    aeaa:	f9b9 2000 	ldrsh.w	r2, [r9]
    aeae:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            work_area.x2 = coords->x1 + aa;
    aeb2:	fa0f f388 	sxth.w	r3, r8
    aeb6:	441a      	add	r2, r3
    aeb8:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
            work_area.y1 = coords->y2 - aa;
    aebc:	f9b9 2006 	ldrsh.w	r2, [r9, #6]
            work_area.y2 = coords->y2;
    aec0:	f8ad 206e 	strh.w	r2, [sp, #110]	; 0x6e
            work_area.y1 = coords->y2 - aa;
    aec4:	1ad3      	subs	r3, r2, r3
    aec6:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            lv_draw_fill(&work_area, mask, color, opa);
    aeca:	463a      	mov	r2, r7
    aecc:	4623      	mov	r3, r4
    aece:	9905      	ldr	r1, [sp, #20]
    aed0:	a81a      	add	r0, sp, #104	; 0x68
    aed2:	f7ff f82c 	bl	9f2e <lv_draw_fill>
        if(part & (LV_BORDER_BOTTOM | LV_BORDER_RIGHT)) {
    aed6:	f016 0f09 	tst.w	r6, #9
    aeda:	f43f ac7f 	beq.w	a7dc <lv_draw_rect+0x3c2>
            work_area.x1 = coords->x2 - aa;
    aede:	f9b9 3004 	ldrsh.w	r3, [r9, #4]
            work_area.x2 = coords->x2;
    aee2:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.x1 = coords->x2 - aa;
    aee6:	fa0f f888 	sxth.w	r8, r8
    aeea:	eba3 0208 	sub.w	r2, r3, r8
            work_area.y1 = coords->y2 - aa;
    aeee:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
            work_area.x1 = coords->x2 - aa;
    aef2:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            work_area.y1 = coords->y2 - aa;
    aef6:	eba3 0808 	sub.w	r8, r3, r8
    aefa:	f8ad 806a 	strh.w	r8, [sp, #106]	; 0x6a
            work_area.y2 = coords->y2;
    aefe:	e465      	b.n	a7cc <lv_draw_rect+0x3b2>
        work_area.y1 = coords->y1 + radius;
    af00:	4453      	add	r3, sl
    af02:	e6b1      	b.n	ac68 <lv_draw_rect+0x84e>
        if(cir_in.y < cir_in.x) {
    af04:	f9bd 4060 	ldrsh.w	r4, [sp, #96]	; 0x60
    af08:	f9bd 1062 	ldrsh.w	r1, [sp, #98]	; 0x62
    af0c:	42a1      	cmp	r1, r4
            act_w1 = cir_out.x - cir_out.y;
    af0e:	bfaa      	itet	ge
    af10:	1ad4      	subge	r4, r2, r3
            act_w1 = cir_out.x - cir_in.x;
    af12:	1b14      	sublt	r4, r2, r4
            act_w1 = cir_out.x - cir_out.y;
    af14:	b224      	sxthge	r4, r4
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
    af16:	9906      	ldr	r1, [sp, #24]
            act_w1 = cir_out.x - cir_in.x;
    af18:	bfb5      	itete	lt
    af1a:	b224      	sxthlt	r4, r4
            act_w2 = act_w1 - 1;
    af1c:	f104 3aff 	addge.w	sl, r4, #4294967295	; 0xffffffff
            act_w2 = act_w1;
    af20:	46a2      	movlt	sl, r4
            act_w2 = act_w1 - 1;
    af22:	fa0f fa8a 	sxthge.w	sl, sl
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
    af26:	2909      	cmp	r1, #9
    af28:	d12a      	bne.n	af80 <lv_draw_rect+0xb66>
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT1_X(cir_out) - act_w2;
    af2a:	444a      	add	r2, r9
    af2c:	b212      	sxth	r2, r2
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
    af2e:	4433      	add	r3, r6
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT1_X(cir_out) - act_w2;
    af30:	eba2 010a 	sub.w	r1, r2, sl
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
    af34:	b21b      	sxth	r3, r3
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT1_X(cir_out) - act_w2;
    af36:	f8ad 1068 	strh.w	r1, [sp, #104]	; 0x68
            circ_area.x2 = rb_origo.x + LV_CIRC_OCT1_X(cir_out);
    af3a:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
    af3e:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            circ_area.y2 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
    af42:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
    af46:	465a      	mov	r2, fp
    af48:	462b      	mov	r3, r5
    af4a:	9905      	ldr	r1, [sp, #20]
    af4c:	a81a      	add	r0, sp, #104	; 0x68
    af4e:	f7fe ffee 	bl	9f2e <lv_draw_fill>
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
    af52:	f8bd 305a 	ldrh.w	r3, [sp, #90]	; 0x5a
            lv_draw_fill(&circ_area, mask, color, opa);
    af56:	9905      	ldr	r1, [sp, #20]
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
    af58:	444b      	add	r3, r9
    af5a:	b21b      	sxth	r3, r3
    af5c:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            circ_area.x2 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
    af60:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT2_Y(cir_out) - act_w1;
    af64:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
    af68:	4433      	add	r3, r6
    af6a:	b21b      	sxth	r3, r3
    af6c:	1b1a      	subs	r2, r3, r4
    af6e:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            circ_area.y2 = rb_origo.y + LV_CIRC_OCT2_Y(cir_out);
    af72:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
    af76:	465a      	mov	r2, fp
    af78:	462b      	mov	r3, r5
    af7a:	a81a      	add	r0, sp, #104	; 0x68
    af7c:	f7fe ffd7 	bl	9f2e <lv_draw_fill>
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
    af80:	9b08      	ldr	r3, [sp, #32]
    af82:	f003 0305 	and.w	r3, r3, #5
    af86:	2b05      	cmp	r3, #5
    af88:	d12e      	bne.n	afe8 <lv_draw_rect+0xbce>
            circ_area.x1 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
    af8a:	f8bd 305a 	ldrh.w	r3, [sp, #90]	; 0x5a
            lv_draw_fill(&circ_area, mask, color, opa);
    af8e:	9905      	ldr	r1, [sp, #20]
            circ_area.x1 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
    af90:	1afb      	subs	r3, r7, r3
    af92:	b21b      	sxth	r3, r3
    af94:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            circ_area.x2 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
    af98:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            circ_area.y1 = lb_origo.y + LV_CIRC_OCT3_Y(cir_out) - act_w2;
    af9c:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
    afa0:	4433      	add	r3, r6
    afa2:	b21b      	sxth	r3, r3
    afa4:	eba3 020a 	sub.w	r2, r3, sl
    afa8:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            circ_area.y2 = lb_origo.y + LV_CIRC_OCT3_Y(cir_out);
    afac:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
    afb0:	465a      	mov	r2, fp
    afb2:	462b      	mov	r3, r5
    afb4:	a81a      	add	r0, sp, #104	; 0x68
    afb6:	f7fe ffba 	bl	9f2e <lv_draw_fill>
            circ_area.x1 = lb_origo.x + LV_CIRC_OCT4_X(cir_out);
    afba:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
            lv_draw_fill(&circ_area, mask, color, opa);
    afbe:	9905      	ldr	r1, [sp, #20]
            circ_area.x1 = lb_origo.x + LV_CIRC_OCT4_X(cir_out);
    afc0:	1afb      	subs	r3, r7, r3
    afc2:	b21b      	sxth	r3, r3
    afc4:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            circ_area.x2 = lb_origo.x + LV_CIRC_OCT4_X(cir_out) + act_w1;
    afc8:	4423      	add	r3, r4
    afca:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            circ_area.y1 = lb_origo.y + LV_CIRC_OCT4_Y(cir_out);
    afce:	f8bd 305a 	ldrh.w	r3, [sp, #90]	; 0x5a
    afd2:	4433      	add	r3, r6
    afd4:	b21b      	sxth	r3, r3
    afd6:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            circ_area.y2 = lb_origo.y + LV_CIRC_OCT4_Y(cir_out);
    afda:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
    afde:	465a      	mov	r2, fp
    afe0:	462b      	mov	r3, r5
    afe2:	a81a      	add	r0, sp, #104	; 0x68
    afe4:	f7fe ffa3 	bl	9f2e <lv_draw_fill>
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
    afe8:	9b08      	ldr	r3, [sp, #32]
    afea:	f003 0306 	and.w	r3, r3, #6
    afee:	2b06      	cmp	r3, #6
    aff0:	d132      	bne.n	b058 <lv_draw_rect+0xc3e>
            if(lb_origo.y + LV_CIRC_OCT4_Y(cir_out) > lt_origo.y + LV_CIRC_OCT5_Y(cir_out)) {
    aff2:	f9bd 305a 	ldrsh.w	r3, [sp, #90]	; 0x5a
    aff6:	18f2      	adds	r2, r6, r3
    aff8:	eba8 0303 	sub.w	r3, r8, r3
    affc:	429a      	cmp	r2, r3
    affe:	dd13      	ble.n	b028 <lv_draw_rect+0xc0e>
                circ_area.x1 = lt_origo.x + LV_CIRC_OCT5_X(cir_out);
    b000:	f8bd 2058 	ldrh.w	r2, [sp, #88]	; 0x58
                lv_draw_fill(&circ_area, mask, color, opa);
    b004:	9905      	ldr	r1, [sp, #20]
                circ_area.x1 = lt_origo.x + LV_CIRC_OCT5_X(cir_out);
    b006:	1aba      	subs	r2, r7, r2
    b008:	b212      	sxth	r2, r2
                circ_area.y1 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
    b00a:	b21b      	sxth	r3, r3
                circ_area.x1 = lt_origo.x + LV_CIRC_OCT5_X(cir_out);
    b00c:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
                circ_area.x2 = lt_origo.x + LV_CIRC_OCT5_X(cir_out) + act_w2;
    b010:	4452      	add	r2, sl
    b012:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
                circ_area.y1 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
    b016:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
                circ_area.y2 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
    b01a:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
                lv_draw_fill(&circ_area, mask, color, opa);
    b01e:	465a      	mov	r2, fp
    b020:	462b      	mov	r3, r5
    b022:	a81a      	add	r0, sp, #104	; 0x68
    b024:	f7fe ff83 	bl	9f2e <lv_draw_fill>
            circ_area.x1 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
    b028:	f8bd 305a 	ldrh.w	r3, [sp, #90]	; 0x5a
            lv_draw_fill(&circ_area, mask, color, opa);
    b02c:	9905      	ldr	r1, [sp, #20]
            circ_area.x1 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
    b02e:	1afb      	subs	r3, r7, r3
    b030:	b21b      	sxth	r3, r3
    b032:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            circ_area.x2 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
    b036:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            circ_area.y1 = lt_origo.y + LV_CIRC_OCT6_Y(cir_out);
    b03a:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
    b03e:	eba8 0303 	sub.w	r3, r8, r3
    b042:	b21b      	sxth	r3, r3
    b044:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            circ_area.y2 = lt_origo.y + LV_CIRC_OCT6_Y(cir_out) + act_w1;
    b048:	4423      	add	r3, r4
    b04a:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
    b04e:	465a      	mov	r2, fp
    b050:	462b      	mov	r3, r5
    b052:	a81a      	add	r0, sp, #104	; 0x68
    b054:	f7fe ff6b 	bl	9f2e <lv_draw_fill>
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
    b058:	9b08      	ldr	r3, [sp, #32]
    b05a:	f003 030a 	and.w	r3, r3, #10
    b05e:	2b0a      	cmp	r3, #10
    b060:	d132      	bne.n	b0c8 <lv_draw_rect+0xcae>
            circ_area.x1 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
    b062:	f8bd 305a 	ldrh.w	r3, [sp, #90]	; 0x5a
            lv_draw_fill(&circ_area, mask, color, opa);
    b066:	9905      	ldr	r1, [sp, #20]
            circ_area.x1 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
    b068:	444b      	add	r3, r9
    b06a:	b21b      	sxth	r3, r3
    b06c:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            circ_area.x2 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
    b070:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            circ_area.y1 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out);
    b074:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
    b078:	eba8 0303 	sub.w	r3, r8, r3
    b07c:	b21b      	sxth	r3, r3
    b07e:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            circ_area.y2 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out) + act_w2;
    b082:	449a      	add	sl, r3
            lv_draw_fill(&circ_area, mask, color, opa);
    b084:	465a      	mov	r2, fp
    b086:	462b      	mov	r3, r5
    b088:	a81a      	add	r0, sp, #104	; 0x68
            circ_area.y2 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out) + act_w2;
    b08a:	f8ad a06e 	strh.w	sl, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
    b08e:	f7fe ff4e 	bl	9f2e <lv_draw_fill>
            if(rb_origo.y + LV_CIRC_OCT1_Y(cir_out) > rt_origo.y + LV_CIRC_OCT8_Y(cir_out)) {
    b092:	f9bd 305a 	ldrsh.w	r3, [sp, #90]	; 0x5a
    b096:	18f2      	adds	r2, r6, r3
    b098:	eba8 0303 	sub.w	r3, r8, r3
    b09c:	429a      	cmp	r2, r3
    b09e:	dd13      	ble.n	b0c8 <lv_draw_rect+0xcae>
                circ_area.x1 = rt_origo.x + LV_CIRC_OCT8_X(cir_out) - act_w1;
    b0a0:	f8bd 2058 	ldrh.w	r2, [sp, #88]	; 0x58
                lv_draw_fill(&circ_area, mask, color, opa);
    b0a4:	9905      	ldr	r1, [sp, #20]
                circ_area.x1 = rt_origo.x + LV_CIRC_OCT8_X(cir_out) - act_w1;
    b0a6:	444a      	add	r2, r9
    b0a8:	b212      	sxth	r2, r2
                circ_area.y1 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
    b0aa:	b21b      	sxth	r3, r3
                circ_area.x1 = rt_origo.x + LV_CIRC_OCT8_X(cir_out) - act_w1;
    b0ac:	1b14      	subs	r4, r2, r4
                circ_area.x2 = rt_origo.x + LV_CIRC_OCT8_X(cir_out);
    b0ae:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
                circ_area.y1 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
    b0b2:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
                circ_area.y2 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
    b0b6:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
                lv_draw_fill(&circ_area, mask, color, opa);
    b0ba:	465a      	mov	r2, fp
    b0bc:	462b      	mov	r3, r5
    b0be:	a81a      	add	r0, sp, #104	; 0x68
                circ_area.x1 = rt_origo.x + LV_CIRC_OCT8_X(cir_out) - act_w1;
    b0c0:	f8ad 4068 	strh.w	r4, [sp, #104]	; 0x68
                lv_draw_fill(&circ_area, mask, color, opa);
    b0c4:	f7fe ff33 	bl	9f2e <lv_draw_fill>
        lv_circ_next(&cir_out, &tmp_out);
    b0c8:	a913      	add	r1, sp, #76	; 0x4c
    b0ca:	a816      	add	r0, sp, #88	; 0x58
    b0cc:	f000 f8c0 	bl	b250 <lv_circ_next>
        if(cir_in.y < cir_in.x) {
    b0d0:	f9bd 2062 	ldrsh.w	r2, [sp, #98]	; 0x62
    b0d4:	f9bd 3060 	ldrsh.w	r3, [sp, #96]	; 0x60
    b0d8:	429a      	cmp	r2, r3
    b0da:	f6bf abdc 	bge.w	a896 <lv_draw_rect+0x47c>
            lv_circ_next(&cir_in, &tmp_in);
    b0de:	a914      	add	r1, sp, #80	; 0x50
    b0e0:	a818      	add	r0, sp, #96	; 0x60
    b0e2:	f000 f8b5 	bl	b250 <lv_circ_next>
    b0e6:	f7ff bbd6 	b.w	a896 <lv_draw_rect+0x47c>

0000b0ea <lv_img_color_format_is_chroma_keyed>:
    switch(cf) {
    b0ea:	2803      	cmp	r0, #3
    b0ec:	d003      	beq.n	b0f6 <lv_img_color_format_is_chroma_keyed+0xc>
        default: is_chroma_keyed = false; break;
    b0ee:	1f83      	subs	r3, r0, #6
    b0f0:	4258      	negs	r0, r3
    b0f2:	4158      	adcs	r0, r3
    b0f4:	4770      	bx	lr
            is_chroma_keyed = true; break;
    b0f6:	2001      	movs	r0, #1
}
    b0f8:	4770      	bx	lr

0000b0fa <lv_img_color_format_has_alpha>:
    switch(cf) {
    b0fa:	280e      	cmp	r0, #14
    b0fc:	d808      	bhi.n	b110 <lv_img_color_format_has_alpha+0x16>
bool lv_img_color_format_has_alpha(lv_img_cf_t cf)
    b0fe:	2301      	movs	r3, #1
    b100:	4083      	lsls	r3, r0
    b102:	f647 72a4 	movw	r2, #32676	; 0x7fa4
    b106:	4213      	tst	r3, r2
    b108:	bf14      	ite	ne
    b10a:	2001      	movne	r0, #1
    b10c:	2000      	moveq	r0, #0
    b10e:	4770      	bx	lr
        default: has_alpha = false; break;
    b110:	2000      	movs	r0, #0
}
    b112:	4770      	bx	lr

0000b114 <lv_img_src_get_type>:
    if(src == NULL) return img_src_type;
    b114:	b150      	cbz	r0, b12c <lv_img_src_get_type+0x18>
    if(u8_p[0] >= 0x20 && u8_p[0] <= 0x7F) {
    b116:	7803      	ldrb	r3, [r0, #0]
    b118:	f1a3 0220 	sub.w	r2, r3, #32
    b11c:	2a5f      	cmp	r2, #95	; 0x5f
    b11e:	d907      	bls.n	b130 <lv_img_src_get_type+0x1c>
    } else if(u8_p[0] >= 0x80) {
    b120:	f013 0f80 	tst.w	r3, #128	; 0x80
        img_src_type = LV_IMG_SRC_SYMBOL; /*Symbols begins after 0x7F*/
    b124:	bf0c      	ite	eq
    b126:	2000      	moveq	r0, #0
    b128:	2002      	movne	r0, #2
    b12a:	4770      	bx	lr
    if(src == NULL) return img_src_type;
    b12c:	2003      	movs	r0, #3
    b12e:	4770      	bx	lr
        img_src_type = LV_IMG_SRC_FILE; /*If it's an ASCII character then it's file name*/
    b130:	2001      	movs	r0, #1
}
    b132:	4770      	bx	lr

0000b134 <lv_img_decoder_built_in_close>:
{
    b134:	b538      	push	{r3, r4, r5, lr}
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
    b136:	6a0c      	ldr	r4, [r1, #32]
{
    b138:	460d      	mov	r5, r1
    if(user_data) {
    b13a:	b144      	cbz	r4, b14e <lv_img_decoder_built_in_close+0x1a>
        if(user_data->palette) lv_mem_free(user_data->palette);
    b13c:	6820      	ldr	r0, [r4, #0]
    b13e:	b108      	cbz	r0, b144 <lv_img_decoder_built_in_close+0x10>
    b140:	f7fa fd78 	bl	5c34 <lv_mem_free>
        lv_mem_free(user_data);
    b144:	4620      	mov	r0, r4
    b146:	f7fa fd75 	bl	5c34 <lv_mem_free>
        dsc->user_data = NULL;
    b14a:	2300      	movs	r3, #0
    b14c:	622b      	str	r3, [r5, #32]
}
    b14e:	bd38      	pop	{r3, r4, r5, pc}

0000b150 <lv_img_decoder_read_line>:
{
    b150:	b573      	push	{r0, r1, r4, r5, r6, lr}
    b152:	4605      	mov	r5, r0
    if(dsc->decoder->read_line_cb) res = dsc->decoder->read_line_cb(dsc->decoder, dsc, x, y, len, buf);
    b154:	6800      	ldr	r0, [r0, #0]
    b156:	6884      	ldr	r4, [r0, #8]
    b158:	b144      	cbz	r4, b16c <lv_img_decoder_read_line+0x1c>
    b15a:	9e06      	ldr	r6, [sp, #24]
    b15c:	e9cd 3600 	strd	r3, r6, [sp]
    b160:	4613      	mov	r3, r2
    b162:	460a      	mov	r2, r1
    b164:	4629      	mov	r1, r5
    b166:	47a0      	blx	r4
}
    b168:	b002      	add	sp, #8
    b16a:	bd70      	pop	{r4, r5, r6, pc}
    lv_res_t res = LV_RES_INV;
    b16c:	4620      	mov	r0, r4
    b16e:	e7fb      	b.n	b168 <lv_img_decoder_read_line+0x18>

0000b170 <lv_img_decoder_close>:
{
    b170:	b510      	push	{r4, lr}
    b172:	4604      	mov	r4, r0
    if(dsc->decoder) {
    b174:	6800      	ldr	r0, [r0, #0]
    b176:	b158      	cbz	r0, b190 <lv_img_decoder_close+0x20>
        if(dsc->decoder->close_cb) dsc->decoder->close_cb(dsc->decoder, dsc);
    b178:	68c3      	ldr	r3, [r0, #12]
    b17a:	b10b      	cbz	r3, b180 <lv_img_decoder_close+0x10>
    b17c:	4621      	mov	r1, r4
    b17e:	4798      	blx	r3
        if(dsc->src_type == LV_IMG_SRC_FILE) {
    b180:	7b23      	ldrb	r3, [r4, #12]
    b182:	2b01      	cmp	r3, #1
    b184:	d104      	bne.n	b190 <lv_img_decoder_close+0x20>
            lv_mem_free(dsc->src);
    b186:	6860      	ldr	r0, [r4, #4]
    b188:	f7fa fd54 	bl	5c34 <lv_mem_free>
            dsc->src = NULL;
    b18c:	2300      	movs	r3, #0
    b18e:	6063      	str	r3, [r4, #4]
}
    b190:	bd10      	pop	{r4, pc}

0000b192 <lv_disp_drv_init>:
{
    b192:	b510      	push	{r4, lr}
    memset(driver, 0, sizeof(lv_disp_drv_t));
    b194:	2224      	movs	r2, #36	; 0x24
{
    b196:	4604      	mov	r4, r0
    memset(driver, 0, sizeof(lv_disp_drv_t));
    b198:	2100      	movs	r1, #0
    b19a:	f7fd fbd3 	bl	8944 <memset>
    driver->flush_cb         = NULL;
    b19e:	2300      	movs	r3, #0
    driver->hor_res          = LV_HOR_RES_MAX;
    b1a0:	f04f 12f0 	mov.w	r2, #15728880	; 0xf000f0
    driver->buffer           = NULL;
    b1a4:	e9c4 2300 	strd	r2, r3, [r4]
    driver->rotated          = 0;
    b1a8:	7a22      	ldrb	r2, [r4, #8]
    driver->flush_cb         = NULL;
    b1aa:	60e3      	str	r3, [r4, #12]
    driver->rotated          = 0;
    b1ac:	f363 0200 	bfi	r2, r3, #0, #1
    b1b0:	7222      	strb	r2, [r4, #8]
    driver->color_chroma_key = LV_COLOR_TRANSP;
    b1b2:	f04f 22ff 	mov.w	r2, #4278255360	; 0xff00ff00
    driver->user_data = NULL;
    b1b6:	e9c4 2307 	strd	r2, r3, [r4, #28]
    driver->set_px_cb = NULL;
    b1ba:	6163      	str	r3, [r4, #20]
}
    b1bc:	bd10      	pop	{r4, pc}

0000b1be <lv_disp_buf_init>:
{
    b1be:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b1c0:	4604      	mov	r4, r0
    b1c2:	460d      	mov	r5, r1
    b1c4:	4617      	mov	r7, r2
    b1c6:	461e      	mov	r6, r3
    memset(disp_buf, 0, sizeof(lv_disp_buf_t));
    b1c8:	221c      	movs	r2, #28
    b1ca:	2100      	movs	r1, #0
    b1cc:	f7fd fbba 	bl	8944 <memset>
    disp_buf->buf2    = buf2;
    b1d0:	e9c4 5700 	strd	r5, r7, [r4]
    disp_buf->size    = size_in_px_cnt;
    b1d4:	e9c4 5602 	strd	r5, r6, [r4, #8]
}
    b1d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000b1da <lv_disp_get_antialiasing>:
    if(disp == NULL) disp = lv_disp_get_default();
    if(disp == NULL) return false;

    return disp->driver.antialiasing ? true : false;
#endif
}
    b1da:	2000      	movs	r0, #0
    b1dc:	4770      	bx	lr

0000b1de <lv_disp_flush_ready>:
    if(disp_drv->screen_transp) {
        memset(disp_drv->buffer->buf_act, 0x00, disp_drv->buffer->size * sizeof(lv_color32_t));
    }
#endif

    disp_drv->buffer->flushing = 0;
    b1de:	6842      	ldr	r2, [r0, #4]
    b1e0:	7e13      	ldrb	r3, [r2, #24]
    b1e2:	f36f 0300 	bfc	r3, #0, #1
    b1e6:	7613      	strb	r3, [r2, #24]
}
    b1e8:	4770      	bx	lr

0000b1ea <lv_disp_get_buf>:
 * @return pointer to the internal buffers
 */
lv_disp_buf_t * lv_disp_get_buf(lv_disp_t * disp)
{
    return disp->driver.buffer;
}
    b1ea:	6840      	ldr	r0, [r0, #4]
    b1ec:	4770      	bx	lr

0000b1ee <lv_disp_is_double_buf>:
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_double_buf(lv_disp_t * disp)
{
    if(disp->driver.buffer->buf1 && disp->driver.buffer->buf2)
    b1ee:	6843      	ldr	r3, [r0, #4]
    b1f0:	6818      	ldr	r0, [r3, #0]
    b1f2:	b118      	cbz	r0, b1fc <lv_disp_is_double_buf+0xe>
    b1f4:	6858      	ldr	r0, [r3, #4]
    b1f6:	3000      	adds	r0, #0
    b1f8:	bf18      	it	ne
    b1fa:	2001      	movne	r0, #1
        return true;
    else
        return false;
}
    b1fc:	4770      	bx	lr

0000b1fe <lv_disp_is_true_double_buf>:
 * `size` is screen sized)
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_true_double_buf(lv_disp_t * disp)
{
    b1fe:	b508      	push	{r3, lr}
    b200:	4602      	mov	r2, r0
    uint32_t scr_size = disp->driver.hor_res * disp->driver.ver_res;

    if(lv_disp_is_double_buf(disp) && disp->driver.buffer->size == scr_size) {
    b202:	f7ff fff4 	bl	b1ee <lv_disp_is_double_buf>
    b206:	b140      	cbz	r0, b21a <lv_disp_is_true_double_buf+0x1c>
    uint32_t scr_size = disp->driver.hor_res * disp->driver.ver_res;
    b208:	8853      	ldrh	r3, [r2, #2]
    b20a:	8810      	ldrh	r0, [r2, #0]
    b20c:	fb10 f003 	smulbb	r0, r0, r3
    if(lv_disp_is_double_buf(disp) && disp->driver.buffer->size == scr_size) {
    b210:	6853      	ldr	r3, [r2, #4]
    b212:	68db      	ldr	r3, [r3, #12]
    b214:	1ac3      	subs	r3, r0, r3
    b216:	4258      	negs	r0, r3
    b218:	4158      	adcs	r0, r3
        return true;
    } else {
        return false;
    }
}
    b21a:	bd08      	pop	{r3, pc}

0000b21c <lv_tick_get>:
/**
 * Get the elapsed milliseconds since start up
 * @return the elapsed milliseconds
 */
uint32_t lv_tick_get(void)
{
    b21c:	b508      	push	{r3, lr}
	return z_impl_k_uptime_get();
    b21e:	f000 fe78 	bl	bf12 <z_impl_k_uptime_get>

    return result;
#else
    return LV_TICK_CUSTOM_SYS_TIME_EXPR;
#endif
}
    b222:	bd08      	pop	{r3, pc}

0000b224 <lv_tick_elaps>:
 * Get the elapsed milliseconds since a previous time stamp
 * @param prev_tick a previous time stamp (return value of systick_get() )
 * @return the elapsed milliseconds since 'prev_tick'
 */
uint32_t lv_tick_elaps(uint32_t prev_tick)
{
    b224:	b510      	push	{r4, lr}
    b226:	4604      	mov	r4, r0
    b228:	f000 fe73 	bl	bf12 <z_impl_k_uptime_get>
        prev_tick = UINT32_MAX - prev_tick + 1;
        prev_tick += act_time;
    }

    return prev_tick;
}
    b22c:	1b00      	subs	r0, r0, r4
    b22e:	bd10      	pop	{r4, pc}

0000b230 <lv_circ_init>:
 * @param tmp point to a variable. It will store temporary data
 * @param radius radius of the circle
 */
void lv_circ_init(lv_point_t * c, lv_coord_t * tmp, lv_coord_t radius)
{
    c->x = radius;
    b230:	8002      	strh	r2, [r0, #0]
    c->y = 0;
    b232:	2300      	movs	r3, #0
    *tmp = 1 - radius;
    b234:	f1c2 0201 	rsb	r2, r2, #1
    c->y = 0;
    b238:	8043      	strh	r3, [r0, #2]
    *tmp = 1 - radius;
    b23a:	800a      	strh	r2, [r1, #0]
}
    b23c:	4770      	bx	lr

0000b23e <lv_circ_cont>:
 * @param c same as in circ_init
 * @return true if the circle is not ready yet
 */
bool lv_circ_cont(lv_point_t * c)
{
    return c->y <= c->x ? true : false;
    b23e:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
    b242:	f9b0 0000 	ldrsh.w	r0, [r0]
}
    b246:	4282      	cmp	r2, r0
    b248:	bfcc      	ite	gt
    b24a:	2000      	movgt	r0, #0
    b24c:	2001      	movle	r0, #1
    b24e:	4770      	bx	lr

0000b250 <lv_circ_next>:
 * @param c same as in circ_init. The next point stored here.
 * @param tmp same as in circ_init.
 */
void lv_circ_next(lv_point_t * c, lv_coord_t * tmp)
{
    c->y++;
    b250:	8843      	ldrh	r3, [r0, #2]
    b252:	3301      	adds	r3, #1
    b254:	b21b      	sxth	r3, r3
    b256:	8043      	strh	r3, [r0, #2]

    if(*tmp <= 0) {
    b258:	f9b1 2000 	ldrsh.w	r2, [r1]
    b25c:	2a00      	cmp	r2, #0
        (*tmp) += 2 * c->y + 1; /*Change in decision criterion for y -> y+1*/
    } else {
        c->x--;
    b25e:	bfc1      	itttt	gt
    b260:	8802      	ldrhgt	r2, [r0, #0]
    b262:	f102 32ff 	addgt.w	r2, r2, #4294967295	; 0xffffffff
    b266:	b212      	sxthgt	r2, r2
    b268:	8002      	strhgt	r2, [r0, #0]
        (*tmp) += 2 * (c->y - c->x) + 1; /*Change for y -> y+1, x -> x-1*/
    b26a:	bfc4      	itt	gt
    b26c:	1a9b      	subgt	r3, r3, r2
    b26e:	880a      	ldrhgt	r2, [r1, #0]
    b270:	3201      	adds	r2, #1
    b272:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    b276:	800b      	strh	r3, [r1, #0]
    }
}
    b278:	4770      	bx	lr

0000b27a <lv_area_set>:
 */
void lv_area_set(lv_area_t * area_p, lv_coord_t x1, lv_coord_t y1, lv_coord_t x2, lv_coord_t y2)
{
    area_p->x1 = x1;
    area_p->y1 = y1;
    area_p->x2 = x2;
    b27a:	8083      	strh	r3, [r0, #4]
    area_p->y2 = y2;
    b27c:	f9bd 3000 	ldrsh.w	r3, [sp]
    area_p->x1 = x1;
    b280:	8001      	strh	r1, [r0, #0]
    area_p->y1 = y1;
    b282:	8042      	strh	r2, [r0, #2]
    area_p->y2 = y2;
    b284:	80c3      	strh	r3, [r0, #6]
}
    b286:	4770      	bx	lr

0000b288 <lv_area_set_height>:
 * @param area_p pointer to an area
 * @param h the new height of the area (h == 1 makes y1 == y2)
 */
void lv_area_set_height(lv_area_t * area_p, lv_coord_t h)
{
    area_p->y2 = area_p->y1 + h - 1;
    b288:	8843      	ldrh	r3, [r0, #2]
    b28a:	3901      	subs	r1, #1
    b28c:	4419      	add	r1, r3
    b28e:	80c1      	strh	r1, [r0, #6]
}
    b290:	4770      	bx	lr

0000b292 <lv_area_get_size>:
 */
uint32_t lv_area_get_size(const lv_area_t * area_p)
{
    uint32_t size;

    size = (uint32_t)(area_p->x2 - area_p->x1 + 1) * (area_p->y2 - area_p->y1 + 1);
    b292:	f9b0 3000 	ldrsh.w	r3, [r0]
    b296:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
    b29a:	1ad2      	subs	r2, r2, r3
    b29c:	f9b0 3006 	ldrsh.w	r3, [r0, #6]
    b2a0:	f9b0 0002 	ldrsh.w	r0, [r0, #2]
    b2a4:	3301      	adds	r3, #1
    b2a6:	1a18      	subs	r0, r3, r0

    return size;
}
    b2a8:	fb02 0000 	mla	r0, r2, r0, r0
    b2ac:	4770      	bx	lr

0000b2ae <lv_area_intersect>:
 * @return false: the two area has NO common parts, res_p is invalid
 */
bool lv_area_intersect(lv_area_t * res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
    /* Get the smaller area from 'a1_p' and 'a2_p' */
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
    b2ae:	f9b1 3000 	ldrsh.w	r3, [r1]
{
    b2b2:	b570      	push	{r4, r5, r6, lr}
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
    b2b4:	f9b2 5000 	ldrsh.w	r5, [r2]
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
    b2b8:	f9b1 4002 	ldrsh.w	r4, [r1, #2]
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
    b2bc:	f9b1 6004 	ldrsh.w	r6, [r1, #4]
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
    b2c0:	f9b1 1006 	ldrsh.w	r1, [r1, #6]
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
    b2c4:	429d      	cmp	r5, r3
    b2c6:	bfb8      	it	lt
    b2c8:	461d      	movlt	r5, r3
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
    b2ca:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
    b2ce:	8005      	strh	r5, [r0, #0]
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
    b2d0:	42a3      	cmp	r3, r4
    b2d2:	bfb8      	it	lt
    b2d4:	4623      	movlt	r3, r4
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
    b2d6:	f9b2 4004 	ldrsh.w	r4, [r2, #4]
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
    b2da:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
    b2de:	8043      	strh	r3, [r0, #2]
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
    b2e0:	42b4      	cmp	r4, r6
    b2e2:	bfa8      	it	ge
    b2e4:	4634      	movge	r4, r6
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
    b2e6:	428a      	cmp	r2, r1
    b2e8:	bfa8      	it	ge
    b2ea:	460a      	movge	r2, r1

    /*If x1 or y1 greater then x2 or y2 then the areas union is empty*/
    bool union_ok = true;
    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {
    b2ec:	42a5      	cmp	r5, r4
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
    b2ee:	8084      	strh	r4, [r0, #4]
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
    b2f0:	80c2      	strh	r2, [r0, #6]
    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {
    b2f2:	dc04      	bgt.n	b2fe <lv_area_intersect+0x50>
    b2f4:	4293      	cmp	r3, r2
    b2f6:	bfcc      	ite	gt
    b2f8:	2000      	movgt	r0, #0
    b2fa:	2001      	movle	r0, #1
        union_ok = false;
    }

    return union_ok;
}
    b2fc:	bd70      	pop	{r4, r5, r6, pc}
        union_ok = false;
    b2fe:	2000      	movs	r0, #0
    b300:	e7fc      	b.n	b2fc <lv_area_intersect+0x4e>

0000b302 <lv_area_join>:
 * @param a1_p pointer to the first area
 * @param a2_p pointer to the second area
 */
void lv_area_join(lv_area_t * a_res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
    a_res_p->x1 = LV_MATH_MIN(a1_p->x1, a2_p->x1);
    b302:	f9b2 3000 	ldrsh.w	r3, [r2]
{
    b306:	b510      	push	{r4, lr}
    a_res_p->x1 = LV_MATH_MIN(a1_p->x1, a2_p->x1);
    b308:	f9b1 4000 	ldrsh.w	r4, [r1]
    b30c:	42a3      	cmp	r3, r4
    b30e:	bfa8      	it	ge
    b310:	4623      	movge	r3, r4
    b312:	8003      	strh	r3, [r0, #0]
    a_res_p->y1 = LV_MATH_MIN(a1_p->y1, a2_p->y1);
    b314:	f9b1 4002 	ldrsh.w	r4, [r1, #2]
    b318:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
    b31c:	42a3      	cmp	r3, r4
    b31e:	bfa8      	it	ge
    b320:	4623      	movge	r3, r4
    b322:	8043      	strh	r3, [r0, #2]
    a_res_p->x2 = LV_MATH_MAX(a1_p->x2, a2_p->x2);
    b324:	f9b1 4004 	ldrsh.w	r4, [r1, #4]
    b328:	f9b2 3004 	ldrsh.w	r3, [r2, #4]
    b32c:	42a3      	cmp	r3, r4
    b32e:	bfb8      	it	lt
    b330:	4623      	movlt	r3, r4
    b332:	8083      	strh	r3, [r0, #4]
    a_res_p->y2 = LV_MATH_MAX(a1_p->y2, a2_p->y2);
    b334:	f9b2 3006 	ldrsh.w	r3, [r2, #6]
    b338:	f9b1 2006 	ldrsh.w	r2, [r1, #6]
    b33c:	4293      	cmp	r3, r2
    b33e:	bfb8      	it	lt
    b340:	4613      	movlt	r3, r2
    b342:	80c3      	strh	r3, [r0, #6]
}
    b344:	bd10      	pop	{r4, pc}

0000b346 <lv_area_is_on>:
 * @param a2_p pointer to an other area
 * @return false: a1_p and a2_p has no common parts
 */
bool lv_area_is_on(const lv_area_t * a1_p, const lv_area_t * a2_p)
{
    if((a1_p->x1 <= a2_p->x2) && (a1_p->x2 >= a2_p->x1) && (a1_p->y1 <= a2_p->y2) && (a1_p->y2 >= a2_p->y1)) {
    b346:	f9b0 2000 	ldrsh.w	r2, [r0]
    b34a:	f9b1 3004 	ldrsh.w	r3, [r1, #4]
    b34e:	429a      	cmp	r2, r3
    b350:	dc14      	bgt.n	b37c <lv_area_is_on+0x36>
    b352:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
    b356:	f9b1 3000 	ldrsh.w	r3, [r1]
    b35a:	429a      	cmp	r2, r3
    b35c:	db0e      	blt.n	b37c <lv_area_is_on+0x36>
    b35e:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
    b362:	f9b1 3006 	ldrsh.w	r3, [r1, #6]
    b366:	429a      	cmp	r2, r3
    b368:	dc08      	bgt.n	b37c <lv_area_is_on+0x36>
    b36a:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
    b36e:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
    b372:	4298      	cmp	r0, r3
    b374:	bfb4      	ite	lt
    b376:	2000      	movlt	r0, #0
    b378:	2001      	movge	r0, #1
    b37a:	4770      	bx	lr
        return true;
    } else {
        return false;
    b37c:	2000      	movs	r0, #0
    }
}
    b37e:	4770      	bx	lr

0000b380 <lv_area_is_in>:
 */
bool lv_area_is_in(const lv_area_t * ain_p, const lv_area_t * aholder_p)
{
    bool is_in = false;

    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
    b380:	f9b0 2000 	ldrsh.w	r2, [r0]
    b384:	f9b1 3000 	ldrsh.w	r3, [r1]
    b388:	429a      	cmp	r2, r3
    b38a:	db14      	blt.n	b3b6 <lv_area_is_in+0x36>
    b38c:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
    b390:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
    b394:	429a      	cmp	r2, r3
    b396:	db0e      	blt.n	b3b6 <lv_area_is_in+0x36>
    b398:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
    b39c:	f9b1 3004 	ldrsh.w	r3, [r1, #4]
    b3a0:	429a      	cmp	r2, r3
    b3a2:	dc08      	bgt.n	b3b6 <lv_area_is_in+0x36>
    b3a4:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
    b3a8:	f9b1 3006 	ldrsh.w	r3, [r1, #6]
    b3ac:	4298      	cmp	r0, r3
    b3ae:	bfcc      	ite	gt
    b3b0:	2000      	movgt	r0, #0
    b3b2:	2001      	movle	r0, #1
    b3b4:	4770      	bx	lr
    bool is_in = false;
    b3b6:	2000      	movs	r0, #0
       ain_p->y2 <= aholder_p->y2) {
        is_in = true;
    }

    return is_in;
}
    b3b8:	4770      	bx	lr

0000b3ba <lv_task_create>:
{
    b3ba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b3be:	4680      	mov	r8, r0
    b3c0:	460f      	mov	r7, r1
    b3c2:	4616      	mov	r6, r2
    b3c4:	461d      	mov	r5, r3
    lv_task_t * new_task = lv_task_create_basic();
    b3c6:	f7fa fadd 	bl	5984 <lv_task_create_basic>
    if(new_task == NULL) return NULL;
    b3ca:	4604      	mov	r4, r0
    b3cc:	b130      	cbz	r0, b3dc <lv_task_create+0x22>
    task->task_cb = task_cb;
    b3ce:	f8c0 8008 	str.w	r8, [r0, #8]
    task->period = period;
    b3d2:	6007      	str	r7, [r0, #0]
    lv_task_set_prio(new_task, prio);
    b3d4:	4631      	mov	r1, r6
    b3d6:	f7fa fbe1 	bl	5b9c <lv_task_set_prio>
    new_task->user_data = user_data;
    b3da:	60e5      	str	r5, [r4, #12]
}
    b3dc:	4620      	mov	r0, r4
    b3de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000b3e2 <lv_task_ready>:
{
    b3e2:	b510      	push	{r4, lr}
    b3e4:	4604      	mov	r4, r0
    task->last_run = lv_tick_get() - task->period - 1;
    b3e6:	f7ff ff19 	bl	b21c <lv_tick_get>
    b3ea:	6823      	ldr	r3, [r4, #0]
    b3ec:	43db      	mvns	r3, r3
    b3ee:	4403      	add	r3, r0
    b3f0:	6063      	str	r3, [r4, #4]
}
    b3f2:	bd10      	pop	{r4, pc}

0000b3f4 <lv_mem_init>:
}
    b3f4:	4770      	bx	lr

0000b3f6 <node_set_next.isra.0>:
 * Set the 'next node pointer' of a node
 * @param ll_p pointer to linked list
 * @param act pointer to a node which next node pointer should be set
 * @param next pointer to a node which should be the next node before 'act'
 */
static void node_set_next(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * next)
    b3f6:	b507      	push	{r0, r1, r2, lr}
    b3f8:	9201      	str	r2, [sp, #4]
{
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
    b3fa:	b149      	cbz	r1, b410 <node_set_next.isra.0+0x1a>

    uint32_t node_p_size = sizeof(lv_ll_node_t *);
    if(next)
    b3fc:	6800      	ldr	r0, [r0, #0]
    b3fe:	3004      	adds	r0, #4
    b400:	4408      	add	r0, r1
    b402:	4611      	mov	r1, r2
        memcpy(act + LL_NEXT_P_OFFSET(ll_p), &next, node_p_size);
    b404:	2204      	movs	r2, #4
    if(next)
    b406:	b131      	cbz	r1, b416 <node_set_next.isra.0+0x20>
        memcpy(act + LL_NEXT_P_OFFSET(ll_p), &next, node_p_size);
    b408:	eb0d 0102 	add.w	r1, sp, r2
    b40c:	f7fd fa70 	bl	88f0 <memcpy>
    else
        memset(act + LL_NEXT_P_OFFSET(ll_p), 0, node_p_size);
}
    b410:	b003      	add	sp, #12
    b412:	f85d fb04 	ldr.w	pc, [sp], #4
        memset(act + LL_NEXT_P_OFFSET(ll_p), 0, node_p_size);
    b416:	f7fd fa95 	bl	8944 <memset>
    b41a:	e7f9      	b.n	b410 <node_set_next.isra.0+0x1a>

0000b41c <node_set_prev.isra.2>:
static void node_set_prev(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * prev)
    b41c:	b507      	push	{r0, r1, r2, lr}
    b41e:	9201      	str	r2, [sp, #4]
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
    b420:	b141      	cbz	r1, b434 <node_set_prev.isra.2+0x18>
    if(prev)
    b422:	6800      	ldr	r0, [r0, #0]
    b424:	4408      	add	r0, r1
    b426:	4611      	mov	r1, r2
        memcpy(act + LL_PREV_P_OFFSET(ll_p), &prev, node_p_size);
    b428:	2204      	movs	r2, #4
    if(prev)
    b42a:	b131      	cbz	r1, b43a <node_set_prev.isra.2+0x1e>
        memcpy(act + LL_PREV_P_OFFSET(ll_p), &prev, node_p_size);
    b42c:	eb0d 0102 	add.w	r1, sp, r2
    b430:	f7fd fa5e 	bl	88f0 <memcpy>
}
    b434:	b003      	add	sp, #12
    b436:	f85d fb04 	ldr.w	pc, [sp], #4
        memset(act + LL_PREV_P_OFFSET(ll_p), 0, node_p_size);
    b43a:	f7fd fa83 	bl	8944 <memset>
    b43e:	e7f9      	b.n	b434 <node_set_prev.isra.2+0x18>

0000b440 <lv_ll_init>:
    ll_p->head = NULL;
    b440:	2300      	movs	r3, #0
    ll_p->tail = NULL;
    b442:	e9c0 3301 	strd	r3, r3, [r0, #4]
    if(node_size & 0x3) {
    b446:	078b      	lsls	r3, r1, #30
        node_size = node_size & (~0x3);
    b448:	bf1c      	itt	ne
    b44a:	f021 0103 	bicne.w	r1, r1, #3
        node_size += 4;
    b44e:	3104      	addne	r1, #4
    ll_p->n_size = node_size;
    b450:	6001      	str	r1, [r0, #0]
}
    b452:	4770      	bx	lr

0000b454 <lv_ll_ins_head>:
{
    b454:	b538      	push	{r3, r4, r5, lr}
    b456:	4604      	mov	r4, r0
    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
    b458:	6800      	ldr	r0, [r0, #0]
    b45a:	3008      	adds	r0, #8
    b45c:	f7fa fbc4 	bl	5be8 <lv_mem_alloc>
    if(n_new != NULL) {
    b460:	4605      	mov	r5, r0
    b462:	b198      	cbz	r0, b48c <lv_ll_ins_head+0x38>
        node_set_prev(ll_p, n_new, NULL);       /*No prev. before the new head*/
    b464:	4601      	mov	r1, r0
    b466:	2200      	movs	r2, #0
    b468:	4620      	mov	r0, r4
    b46a:	f7ff ffd7 	bl	b41c <node_set_prev.isra.2>
        node_set_next(ll_p, n_new, ll_p->head); /*After new comes the old head*/
    b46e:	4629      	mov	r1, r5
    b470:	6862      	ldr	r2, [r4, #4]
    b472:	4620      	mov	r0, r4
    b474:	f7ff ffbf 	bl	b3f6 <node_set_next.isra.0>
        if(ll_p->head != NULL) { /*If there is old head then before it goes the new*/
    b478:	6861      	ldr	r1, [r4, #4]
    b47a:	b119      	cbz	r1, b484 <lv_ll_ins_head+0x30>
            node_set_prev(ll_p, ll_p->head, n_new);
    b47c:	462a      	mov	r2, r5
    b47e:	4620      	mov	r0, r4
    b480:	f7ff ffcc 	bl	b41c <node_set_prev.isra.2>
        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/
    b484:	68a3      	ldr	r3, [r4, #8]
        ll_p->head = n_new;      /*Set the new head in the dsc.*/
    b486:	6065      	str	r5, [r4, #4]
        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/
    b488:	b903      	cbnz	r3, b48c <lv_ll_ins_head+0x38>
            ll_p->tail = n_new;
    b48a:	60a5      	str	r5, [r4, #8]
}
    b48c:	4628      	mov	r0, r5
    b48e:	bd38      	pop	{r3, r4, r5, pc}

0000b490 <lv_ll_ins_tail>:
{
    b490:	b538      	push	{r3, r4, r5, lr}
    b492:	4604      	mov	r4, r0
    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
    b494:	6800      	ldr	r0, [r0, #0]
    b496:	3008      	adds	r0, #8
    b498:	f7fa fba6 	bl	5be8 <lv_mem_alloc>
    if(n_new == NULL) return NULL;
    b49c:	4605      	mov	r5, r0
    b49e:	b198      	cbz	r0, b4c8 <lv_ll_ins_tail+0x38>
        node_set_next(ll_p, n_new, NULL);       /*No next after the new tail*/
    b4a0:	4601      	mov	r1, r0
    b4a2:	2200      	movs	r2, #0
    b4a4:	4620      	mov	r0, r4
    b4a6:	f7ff ffa6 	bl	b3f6 <node_set_next.isra.0>
        node_set_prev(ll_p, n_new, ll_p->tail); /*The prev. before new is tho old tail*/
    b4aa:	4629      	mov	r1, r5
    b4ac:	68a2      	ldr	r2, [r4, #8]
    b4ae:	4620      	mov	r0, r4
    b4b0:	f7ff ffb4 	bl	b41c <node_set_prev.isra.2>
        if(ll_p->tail != NULL) {                /*If there is old tail then the new comes after it*/
    b4b4:	68a1      	ldr	r1, [r4, #8]
    b4b6:	b119      	cbz	r1, b4c0 <lv_ll_ins_tail+0x30>
            node_set_next(ll_p, ll_p->tail, n_new);
    b4b8:	462a      	mov	r2, r5
    b4ba:	4620      	mov	r0, r4
    b4bc:	f7ff ff9b 	bl	b3f6 <node_set_next.isra.0>
        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/
    b4c0:	6863      	ldr	r3, [r4, #4]
        ll_p->tail = n_new;      /*Set the new tail in the dsc.*/
    b4c2:	60a5      	str	r5, [r4, #8]
        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/
    b4c4:	b903      	cbnz	r3, b4c8 <lv_ll_ins_tail+0x38>
            ll_p->head = n_new;
    b4c6:	6065      	str	r5, [r4, #4]
}
    b4c8:	4628      	mov	r0, r5
    b4ca:	bd38      	pop	{r3, r4, r5, pc}

0000b4cc <lv_ll_get_head>:
    if(ll_p != NULL) {
    b4cc:	b100      	cbz	r0, b4d0 <lv_ll_get_head+0x4>
        head = ll_p->head;
    b4ce:	6840      	ldr	r0, [r0, #4]
}
    b4d0:	4770      	bx	lr

0000b4d2 <lv_ll_get_tail>:
    if(ll_p != NULL) {
    b4d2:	b100      	cbz	r0, b4d6 <lv_ll_get_tail+0x4>
        tail = ll_p->tail;
    b4d4:	6880      	ldr	r0, [r0, #8]
}
    b4d6:	4770      	bx	lr

0000b4d8 <lv_ll_get_next>:
{
    b4d8:	b507      	push	{r0, r1, r2, lr}
    void * next = NULL;
    b4da:	2300      	movs	r3, #0
    b4dc:	9301      	str	r3, [sp, #4]
    if(ll_p != NULL) {
    b4de:	b138      	cbz	r0, b4f0 <lv_ll_get_next+0x18>
        memcpy(&next, n_act_d + LL_NEXT_P_OFFSET(ll_p), sizeof(void *));
    b4e0:	6803      	ldr	r3, [r0, #0]
    b4e2:	2204      	movs	r2, #4
    b4e4:	3304      	adds	r3, #4
    b4e6:	4419      	add	r1, r3
    b4e8:	eb0d 0002 	add.w	r0, sp, r2
    b4ec:	f7fd fa00 	bl	88f0 <memcpy>
}
    b4f0:	9801      	ldr	r0, [sp, #4]
    b4f2:	b003      	add	sp, #12
    b4f4:	f85d fb04 	ldr.w	pc, [sp], #4

0000b4f8 <lv_ll_get_prev>:
{
    b4f8:	b507      	push	{r0, r1, r2, lr}
    void * prev = NULL;
    b4fa:	2300      	movs	r3, #0
    b4fc:	9301      	str	r3, [sp, #4]
    if(ll_p != NULL) {
    b4fe:	b130      	cbz	r0, b50e <lv_ll_get_prev+0x16>
        memcpy(&prev, n_act_d + LL_PREV_P_OFFSET(ll_p), sizeof(void *));
    b500:	6803      	ldr	r3, [r0, #0]
    b502:	2204      	movs	r2, #4
    b504:	4419      	add	r1, r3
    b506:	eb0d 0002 	add.w	r0, sp, r2
    b50a:	f7fd f9f1 	bl	88f0 <memcpy>
}
    b50e:	9801      	ldr	r0, [sp, #4]
    b510:	b003      	add	sp, #12
    b512:	f85d fb04 	ldr.w	pc, [sp], #4

0000b516 <lv_ll_ins_prev>:
{
    b516:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b518:	460e      	mov	r6, r1
    if(NULL == ll_p || NULL == n_act) return NULL;
    b51a:	4605      	mov	r5, r0
    b51c:	b340      	cbz	r0, b570 <lv_ll_ins_prev+0x5a>
    b51e:	b349      	cbz	r1, b574 <lv_ll_ins_prev+0x5e>
    if(lv_ll_get_head(ll_p) == n_act) {
    b520:	6843      	ldr	r3, [r0, #4]
    b522:	4299      	cmp	r1, r3
    b524:	d103      	bne.n	b52e <lv_ll_ins_prev+0x18>
}
    b526:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        n_new = lv_ll_ins_head(ll_p);
    b52a:	f7ff bf93 	b.w	b454 <lv_ll_ins_head>
        n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
    b52e:	6800      	ldr	r0, [r0, #0]
    b530:	3008      	adds	r0, #8
    b532:	f7fa fb59 	bl	5be8 <lv_mem_alloc>
        if(n_new == NULL) return NULL;
    b536:	4604      	mov	r4, r0
    b538:	b1c0      	cbz	r0, b56c <lv_ll_ins_prev+0x56>
        n_prev = lv_ll_get_prev(ll_p, n_act);
    b53a:	4631      	mov	r1, r6
    b53c:	4628      	mov	r0, r5
    b53e:	f7ff ffdb 	bl	b4f8 <lv_ll_get_prev>
        node_set_next(ll_p, n_prev, n_new);
    b542:	4622      	mov	r2, r4
    b544:	4601      	mov	r1, r0
        n_prev = lv_ll_get_prev(ll_p, n_act);
    b546:	4607      	mov	r7, r0
        node_set_next(ll_p, n_prev, n_new);
    b548:	4628      	mov	r0, r5
    b54a:	f7ff ff54 	bl	b3f6 <node_set_next.isra.0>
        node_set_prev(ll_p, n_new, n_prev);
    b54e:	463a      	mov	r2, r7
    b550:	4621      	mov	r1, r4
    b552:	4628      	mov	r0, r5
    b554:	f7ff ff62 	bl	b41c <node_set_prev.isra.2>
        node_set_prev(ll_p, n_act, n_new);
    b558:	4622      	mov	r2, r4
    b55a:	4631      	mov	r1, r6
    b55c:	4628      	mov	r0, r5
    b55e:	f7ff ff5d 	bl	b41c <node_set_prev.isra.2>
        node_set_next(ll_p, n_new, n_act);
    b562:	4632      	mov	r2, r6
    b564:	4621      	mov	r1, r4
    b566:	4628      	mov	r0, r5
    b568:	f7ff ff45 	bl	b3f6 <node_set_next.isra.0>
}
    b56c:	4620      	mov	r0, r4
    b56e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(NULL == ll_p || NULL == n_act) return NULL;
    b570:	4604      	mov	r4, r0
    b572:	e7fb      	b.n	b56c <lv_ll_ins_prev+0x56>
    b574:	460c      	mov	r4, r1
    b576:	e7f9      	b.n	b56c <lv_ll_ins_prev+0x56>

0000b578 <lv_ll_rem>:
{
    b578:	b570      	push	{r4, r5, r6, lr}
    b57a:	460d      	mov	r5, r1
    if(ll_p != NULL) {
    b57c:	4604      	mov	r4, r0
    b57e:	b308      	cbz	r0, b5c4 <lv_ll_rem+0x4c>
    if(lv_ll_get_head(ll_p) == node_p) {
    b580:	6843      	ldr	r3, [r0, #4]
    b582:	4299      	cmp	r1, r3
    b584:	d10e      	bne.n	b5a4 <lv_ll_rem+0x2c>
        ll_p->head = lv_ll_get_next(ll_p, node_p);
    b586:	4629      	mov	r1, r5
    b588:	4620      	mov	r0, r4
    b58a:	f7ff ffa5 	bl	b4d8 <lv_ll_get_next>
    b58e:	4601      	mov	r1, r0
    b590:	6060      	str	r0, [r4, #4]
        if(ll_p->head == NULL) {
    b592:	b908      	cbnz	r0, b598 <lv_ll_rem+0x20>
            ll_p->tail = NULL;
    b594:	60a0      	str	r0, [r4, #8]
}
    b596:	bd70      	pop	{r4, r5, r6, pc}
            node_set_prev(ll_p, ll_p->head, NULL);
    b598:	2200      	movs	r2, #0
        node_set_prev(ll_p, n_next, n_prev);
    b59a:	4620      	mov	r0, r4
}
    b59c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        node_set_prev(ll_p, n_next, n_prev);
    b5a0:	f7ff bf3c 	b.w	b41c <node_set_prev.isra.2>
    } else if(lv_ll_get_tail(ll_p) == node_p) {
    b5a4:	6883      	ldr	r3, [r0, #8]
    b5a6:	4299      	cmp	r1, r3
    b5a8:	d10e      	bne.n	b5c8 <lv_ll_rem+0x50>
        ll_p->tail = lv_ll_get_prev(ll_p, node_p);
    b5aa:	f7ff ffa5 	bl	b4f8 <lv_ll_get_prev>
    b5ae:	4601      	mov	r1, r0
    b5b0:	60a0      	str	r0, [r4, #8]
        if(ll_p->tail == NULL) {
    b5b2:	b908      	cbnz	r0, b5b8 <lv_ll_rem+0x40>
            ll_p->head = NULL;
    b5b4:	6060      	str	r0, [r4, #4]
    b5b6:	e7ee      	b.n	b596 <lv_ll_rem+0x1e>
            node_set_next(ll_p, ll_p->tail, NULL);
    b5b8:	4620      	mov	r0, r4
    b5ba:	2200      	movs	r2, #0
}
    b5bc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            node_set_next(ll_p, ll_p->tail, NULL);
    b5c0:	f7ff bf19 	b.w	b3f6 <node_set_next.isra.0>
    if(lv_ll_get_head(ll_p) == node_p) {
    b5c4:	2900      	cmp	r1, #0
    b5c6:	d0de      	beq.n	b586 <lv_ll_rem+0xe>
        lv_ll_node_t * n_prev = lv_ll_get_prev(ll_p, node_p);
    b5c8:	4629      	mov	r1, r5
    b5ca:	4620      	mov	r0, r4
    b5cc:	f7ff ff94 	bl	b4f8 <lv_ll_get_prev>
        lv_ll_node_t * n_next = lv_ll_get_next(ll_p, node_p);
    b5d0:	4629      	mov	r1, r5
        lv_ll_node_t * n_prev = lv_ll_get_prev(ll_p, node_p);
    b5d2:	4606      	mov	r6, r0
        lv_ll_node_t * n_next = lv_ll_get_next(ll_p, node_p);
    b5d4:	4620      	mov	r0, r4
    b5d6:	f7ff ff7f 	bl	b4d8 <lv_ll_get_next>
        node_set_next(ll_p, n_prev, n_next);
    b5da:	4631      	mov	r1, r6
    b5dc:	4602      	mov	r2, r0
        lv_ll_node_t * n_next = lv_ll_get_next(ll_p, node_p);
    b5de:	4605      	mov	r5, r0
        node_set_next(ll_p, n_prev, n_next);
    b5e0:	4620      	mov	r0, r4
    b5e2:	f7ff ff08 	bl	b3f6 <node_set_next.isra.0>
        node_set_prev(ll_p, n_next, n_prev);
    b5e6:	4632      	mov	r2, r6
    b5e8:	4629      	mov	r1, r5
    b5ea:	e7d6      	b.n	b59a <lv_ll_rem+0x22>

0000b5ec <lv_ll_move_before>:
    if(n_act == n_after) return; /*Can't move before itself*/
    b5ec:	4291      	cmp	r1, r2
{
    b5ee:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b5f0:	4604      	mov	r4, r0
    b5f2:	460d      	mov	r5, r1
    b5f4:	4617      	mov	r7, r2
    if(n_act == n_after) return; /*Can't move before itself*/
    b5f6:	d022      	beq.n	b63e <lv_ll_move_before+0x52>
    if(n_after != NULL)
    b5f8:	b312      	cbz	r2, b640 <lv_ll_move_before+0x54>
        n_before = lv_ll_get_prev(ll_p, n_after);
    b5fa:	4611      	mov	r1, r2
    b5fc:	f7ff ff7c 	bl	b4f8 <lv_ll_get_prev>
    b600:	4606      	mov	r6, r0
    if(n_act == n_before) return; /*Already before `n_after`*/
    b602:	42ae      	cmp	r6, r5
    b604:	d01b      	beq.n	b63e <lv_ll_move_before+0x52>
    lv_ll_rem(ll_p, n_act);
    b606:	4629      	mov	r1, r5
    b608:	4620      	mov	r0, r4
    b60a:	f7ff ffb5 	bl	b578 <lv_ll_rem>
    node_set_next(ll_p, n_before, n_act);
    b60e:	462a      	mov	r2, r5
    b610:	4631      	mov	r1, r6
    b612:	4620      	mov	r0, r4
    b614:	f7ff feef 	bl	b3f6 <node_set_next.isra.0>
    node_set_prev(ll_p, n_act, n_before);
    b618:	4632      	mov	r2, r6
    b61a:	4629      	mov	r1, r5
    b61c:	4620      	mov	r0, r4
    b61e:	f7ff fefd 	bl	b41c <node_set_prev.isra.2>
    node_set_prev(ll_p, n_after, n_act);
    b622:	462a      	mov	r2, r5
    b624:	4639      	mov	r1, r7
    b626:	4620      	mov	r0, r4
    b628:	f7ff fef8 	bl	b41c <node_set_prev.isra.2>
    node_set_next(ll_p, n_act, n_after);
    b62c:	463a      	mov	r2, r7
    b62e:	4629      	mov	r1, r5
    b630:	4620      	mov	r0, r4
    b632:	f7ff fee0 	bl	b3f6 <node_set_next.isra.0>
    if(n_after == NULL) ll_p->tail = n_act;
    b636:	b907      	cbnz	r7, b63a <lv_ll_move_before+0x4e>
    b638:	60a5      	str	r5, [r4, #8]
    if(n_before == NULL) ll_p->head = n_act;
    b63a:	b906      	cbnz	r6, b63e <lv_ll_move_before+0x52>
    b63c:	6065      	str	r5, [r4, #4]
}
    b63e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(ll_p != NULL) {
    b640:	b108      	cbz	r0, b646 <lv_ll_move_before+0x5a>
        tail = ll_p->tail;
    b642:	6886      	ldr	r6, [r0, #8]
    b644:	e7dd      	b.n	b602 <lv_ll_move_before+0x16>
    void * tail = NULL;
    b646:	4606      	mov	r6, r0
    b648:	e7db      	b.n	b602 <lv_ll_move_before+0x16>

0000b64a <lv_txt_iso8859_1_size>:
}
    b64a:	2001      	movs	r0, #1
    b64c:	4770      	bx	lr

0000b64e <lv_txt_iso8859_1_next>:
    if(i == NULL) return txt[1]; /*Get the next char */
    b64e:	b909      	cbnz	r1, b654 <lv_txt_iso8859_1_next+0x6>
    b650:	7840      	ldrb	r0, [r0, #1]
    b652:	4770      	bx	lr
    uint8_t letter = txt[*i];
    b654:	680b      	ldr	r3, [r1, #0]
    b656:	5cc0      	ldrb	r0, [r0, r3]
    (*i)++;
    b658:	3301      	adds	r3, #1
    b65a:	600b      	str	r3, [r1, #0]
}
    b65c:	4770      	bx	lr

0000b65e <lv_txt_iso8859_1_prev>:
    if(i == NULL) return *(txt - 1); /*Get the prev. char */
    b65e:	b911      	cbnz	r1, b666 <lv_txt_iso8859_1_prev+0x8>
    b660:	f810 0c01 	ldrb.w	r0, [r0, #-1]
    b664:	4770      	bx	lr
    (*i)--;
    b666:	680b      	ldr	r3, [r1, #0]
    b668:	3b01      	subs	r3, #1
    b66a:	600b      	str	r3, [r1, #0]
    return letter;
    b66c:	5cc0      	ldrb	r0, [r0, r3]
}
    b66e:	4770      	bx	lr

0000b670 <lv_txt_iso8859_1_get_byte_id>:
}
    b670:	4608      	mov	r0, r1
    b672:	4770      	bx	lr

0000b674 <lv_txt_iso8859_1_get_length>:
    return strlen(txt);
    b674:	f7fd b929 	b.w	88ca <strlen>

0000b678 <lv_txt_iso8859_1_get_char_id>:
    b678:	4608      	mov	r0, r1
    b67a:	4770      	bx	lr

0000b67c <lv_txt_is_cmd>:
    if(c == (uint32_t)LV_TXT_COLOR_CMD[0]) {
    b67c:	2923      	cmp	r1, #35	; 0x23
{
    b67e:	4602      	mov	r2, r0
    if(c == (uint32_t)LV_TXT_COLOR_CMD[0]) {
    b680:	d117      	bne.n	b6b2 <lv_txt_is_cmd+0x36>
    b682:	7803      	ldrb	r3, [r0, #0]
        if(*state == LV_TXT_CMD_STATE_WAIT) { /*Start char*/
    b684:	b91b      	cbnz	r3, b68e <lv_txt_is_cmd+0x12>
            *state = LV_TXT_CMD_STATE_PAR;
    b686:	2301      	movs	r3, #1
    b688:	7003      	strb	r3, [r0, #0]
            ret    = true;
    b68a:	2001      	movs	r0, #1
    b68c:	e004      	b.n	b698 <lv_txt_is_cmd+0x1c>
        else if(*state == LV_TXT_CMD_STATE_PAR) {
    b68e:	2b01      	cmp	r3, #1
    b690:	f04f 0000 	mov.w	r0, #0
    b694:	d109      	bne.n	b6aa <lv_txt_is_cmd+0x2e>
            *state = LV_TXT_CMD_STATE_WAIT;
    b696:	7010      	strb	r0, [r2, #0]
    if(*state == LV_TXT_CMD_STATE_PAR) {
    b698:	7813      	ldrb	r3, [r2, #0]
    b69a:	2b01      	cmp	r3, #1
    b69c:	d104      	bne.n	b6a8 <lv_txt_is_cmd+0x2c>
        if(c == ' ') {
    b69e:	2920      	cmp	r1, #32
            *state = LV_TXT_CMD_STATE_IN; /*After the parameter the text is in the command*/
    b6a0:	bf04      	itt	eq
    b6a2:	2102      	moveq	r1, #2
    b6a4:	7011      	strbeq	r1, [r2, #0]
        ret = true;
    b6a6:	4618      	mov	r0, r3
}
    b6a8:	4770      	bx	lr
        else if(*state == LV_TXT_CMD_STATE_IN) {
    b6aa:	2b02      	cmp	r3, #2
    b6ac:	d1f4      	bne.n	b698 <lv_txt_is_cmd+0x1c>
            *state = LV_TXT_CMD_STATE_WAIT;
    b6ae:	7010      	strb	r0, [r2, #0]
    b6b0:	e7eb      	b.n	b68a <lv_txt_is_cmd+0xe>
    bool ret = false;
    b6b2:	2000      	movs	r0, #0
    b6b4:	e7f0      	b.n	b698 <lv_txt_is_cmd+0x1c>

0000b6b6 <lv_txt_get_size>:
{
    b6b6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b6ba:	b087      	sub	sp, #28
    size_res->x = 0;
    b6bc:	2500      	movs	r5, #0
{
    b6be:	9304      	str	r3, [sp, #16]
    b6c0:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
    b6c4:	f9bd b040 	ldrsh.w	fp, [sp, #64]	; 0x40
    b6c8:	f9bd a044 	ldrsh.w	sl, [sp, #68]	; 0x44
    b6cc:	9303      	str	r3, [sp, #12]
    b6ce:	4604      	mov	r4, r0
    b6d0:	4616      	mov	r6, r2
    size_res->x = 0;
    b6d2:	8005      	strh	r5, [r0, #0]
    size_res->y = 0;
    b6d4:	8045      	strh	r5, [r0, #2]
    if(text == NULL) return;
    b6d6:	4689      	mov	r9, r1
    b6d8:	b1f9      	cbz	r1, b71a <lv_txt_get_size+0x64>
    if(font == NULL) return;
    b6da:	b1f2      	cbz	r2, b71a <lv_txt_get_size+0x64>
    uint8_t letter_height = lv_font_get_line_height(font);
    b6dc:	7a17      	ldrb	r7, [r2, #8]
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
    b6de:	f013 0f02 	tst.w	r3, #2
    b6e2:	f647 4318 	movw	r3, #31768	; 0x7c18
    b6e6:	bf18      	it	ne
    b6e8:	469a      	movne	sl, r3
        size_res->y += line_space;
    b6ea:	eb0b 0307 	add.w	r3, fp, r7
    b6ee:	9305      	str	r3, [sp, #20]
    while(text[line_start] != '\0') {
    b6f0:	f819 3005 	ldrb.w	r3, [r9, r5]
    b6f4:	eb09 0805 	add.w	r8, r9, r5
    b6f8:	b993      	cbnz	r3, b720 <lv_txt_get_size+0x6a>
    if((line_start != 0) && (text[line_start - 1] == '\n' || text[line_start - 1] == '\r')) {
    b6fa:	b155      	cbz	r5, b712 <lv_txt_get_size+0x5c>
    b6fc:	f818 3c01 	ldrb.w	r3, [r8, #-1]
    b700:	2b0a      	cmp	r3, #10
    b702:	d001      	beq.n	b708 <lv_txt_get_size+0x52>
    b704:	2b0d      	cmp	r3, #13
    b706:	d104      	bne.n	b712 <lv_txt_get_size+0x5c>
        size_res->y += letter_height + line_space;
    b708:	8862      	ldrh	r2, [r4, #2]
    b70a:	eb0b 0307 	add.w	r3, fp, r7
    b70e:	4413      	add	r3, r2
    b710:	8063      	strh	r3, [r4, #2]
    if(size_res->y == 0)
    b712:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
    b716:	b9fb      	cbnz	r3, b758 <lv_txt_get_size+0xa2>
        size_res->y = letter_height;
    b718:	8067      	strh	r7, [r4, #2]
}
    b71a:	b007      	add	sp, #28
    b71c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        new_line_start += lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
    b720:	9b03      	ldr	r3, [sp, #12]
    b722:	9300      	str	r3, [sp, #0]
    b724:	9a04      	ldr	r2, [sp, #16]
    b726:	4653      	mov	r3, sl
    b728:	4631      	mov	r1, r6
    b72a:	4640      	mov	r0, r8
    b72c:	f7fa fb22 	bl	5d74 <lv_txt_get_next_line>
        size_res->y += line_space;
    b730:	8863      	ldrh	r3, [r4, #2]
    b732:	9a05      	ldr	r2, [sp, #20]
    b734:	4413      	add	r3, r2
    b736:	8063      	strh	r3, [r4, #2]
        act_line_length = lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space, flag);
    b738:	9b03      	ldr	r3, [sp, #12]
    b73a:	9300      	str	r3, [sp, #0]
        new_line_start += lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
    b73c:	4601      	mov	r1, r0
        act_line_length = lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space, flag);
    b73e:	9b04      	ldr	r3, [sp, #16]
        new_line_start += lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
    b740:	4405      	add	r5, r0
        act_line_length = lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space, flag);
    b742:	4632      	mov	r2, r6
    b744:	4640      	mov	r0, r8
    b746:	f7fa fac5 	bl	5cd4 <lv_txt_get_width>
        size_res->x = LV_MATH_MAX(act_line_length, size_res->x);
    b74a:	f9b4 3000 	ldrsh.w	r3, [r4]
    b74e:	4298      	cmp	r0, r3
    b750:	bfb8      	it	lt
    b752:	4618      	movlt	r0, r3
    b754:	8020      	strh	r0, [r4, #0]
        line_start  = new_line_start;
    b756:	e7cb      	b.n	b6f0 <lv_txt_get_size+0x3a>
        size_res->y -= line_space;
    b758:	eba3 030b 	sub.w	r3, r3, fp
    b75c:	8063      	strh	r3, [r4, #2]
    b75e:	e7dc      	b.n	b71a <lv_txt_get_size+0x64>

0000b760 <lv_utils_bsearch>:
 *
 * @return a pointer to a matching item, or NULL if none exists.
 */
void * lv_utils_bsearch(const void * key, const void * base, uint32_t n, uint32_t size,
                        int32_t (*cmp)(const void * pRef, const void * pElement))
{
    b760:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    b764:	9d08      	ldr	r5, [sp, #32]
    b766:	4681      	mov	r9, r0
    b768:	4688      	mov	r8, r1
    b76a:	4614      	mov	r4, r2
    b76c:	469a      	mov	sl, r3
    const char * middle;
    int32_t c;

    for(middle = base; n != 0;) {
    b76e:	b90c      	cbnz	r4, b774 <lv_utils_bsearch+0x14>
            middle = base;
        } else {
            return (char *)middle;
        }
    }
    return NULL;
    b770:	4626      	mov	r6, r4
    b772:	e010      	b.n	b796 <lv_utils_bsearch+0x36>
        middle += (n / 2) * size;
    b774:	0867      	lsrs	r7, r4, #1
    b776:	fb0a 8607 	mla	r6, sl, r7, r8
        if((c = (*cmp)(key, middle)) > 0) {
    b77a:	4631      	mov	r1, r6
    b77c:	4648      	mov	r0, r9
    b77e:	47a8      	blx	r5
    b780:	2800      	cmp	r0, #0
    b782:	dd07      	ble.n	b794 <lv_utils_bsearch+0x34>
            n    = (n / 2) - ((n & 1) == 0);
    b784:	43e4      	mvns	r4, r4
    b786:	f004 0401 	and.w	r4, r4, #1
    b78a:	1b3f      	subs	r7, r7, r4
            base = (middle += size);
    b78c:	eb06 080a 	add.w	r8, r6, sl
{
    b790:	463c      	mov	r4, r7
    b792:	e7ec      	b.n	b76e <lv_utils_bsearch+0xe>
        } else if(c < 0) {
    b794:	d1fc      	bne.n	b790 <lv_utils_bsearch+0x30>
}
    b796:	4630      	mov	r0, r6
    b798:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000b79c <lv_label_dot_tmp_free>:
 * Free the dot_tmp_ptr field if it was previously allocated.
 * Always clears the field
 * @param label pointer to label object.
 */
static void lv_label_dot_tmp_free(lv_obj_t * label)
{
    b79c:	b510      	push	{r4, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    b79e:	f7fe fa96 	bl	9cce <lv_obj_get_ext_attr>
    if(ext->dot_tmp_alloc && ext->dot.tmp_ptr) {
    b7a2:	7bc3      	ldrb	r3, [r0, #15]
    b7a4:	079b      	lsls	r3, r3, #30
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    b7a6:	4604      	mov	r4, r0
    if(ext->dot_tmp_alloc && ext->dot.tmp_ptr) {
    b7a8:	d503      	bpl.n	b7b2 <lv_label_dot_tmp_free+0x16>
    b7aa:	6840      	ldr	r0, [r0, #4]
    b7ac:	b108      	cbz	r0, b7b2 <lv_label_dot_tmp_free+0x16>
        lv_mem_free(ext->dot.tmp_ptr);
    b7ae:	f7fa fa41 	bl	5c34 <lv_mem_free>
    }
    ext->dot_tmp_alloc = false;
    b7b2:	7be3      	ldrb	r3, [r4, #15]
    b7b4:	f36f 0341 	bfc	r3, #1, #1
    b7b8:	73e3      	strb	r3, [r4, #15]
    ext->dot.tmp_ptr   = NULL;
    b7ba:	2300      	movs	r3, #0
    b7bc:	6063      	str	r3, [r4, #4]
}
    b7be:	bd10      	pop	{r4, pc}

0000b7c0 <lv_label_set_align>:
{
    b7c0:	b538      	push	{r3, r4, r5, lr}
    b7c2:	460c      	mov	r4, r1
    b7c4:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    b7c6:	f7fe fa82 	bl	9cce <lv_obj_get_ext_attr>
    if(ext->align == align) return;
    b7ca:	7b83      	ldrb	r3, [r0, #14]
    b7cc:	f3c3 1201 	ubfx	r2, r3, #4, #2
    b7d0:	42a2      	cmp	r2, r4
    b7d2:	d007      	beq.n	b7e4 <lv_label_set_align+0x24>
    ext->align = align;
    b7d4:	f364 1305 	bfi	r3, r4, #4, #2
    b7d8:	7383      	strb	r3, [r0, #14]
    lv_obj_invalidate(label); /*Enough to invalidate because alignment is only drawing related
    b7da:	4628      	mov	r0, r5
}
    b7dc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    lv_obj_invalidate(label); /*Enough to invalidate because alignment is only drawing related
    b7e0:	f7fd bfae 	b.w	9740 <lv_obj_invalidate>
}
    b7e4:	bd38      	pop	{r3, r4, r5, pc}

0000b7e6 <lv_label_set_body_draw>:
{
    b7e6:	b538      	push	{r3, r4, r5, lr}
    b7e8:	460d      	mov	r5, r1
    b7ea:	4604      	mov	r4, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    b7ec:	f7fe fa6f 	bl	9cce <lv_obj_get_ext_attr>
    if(ext->body_draw == en) return;
    b7f0:	7bc3      	ldrb	r3, [r0, #15]
    b7f2:	f003 0201 	and.w	r2, r3, #1
    b7f6:	42aa      	cmp	r2, r5
    b7f8:	d00a      	beq.n	b810 <lv_label_set_body_draw+0x2a>
    ext->body_draw = en == false ? 0 : 1;
    b7fa:	f365 0300 	bfi	r3, r5, #0, #1
    b7fe:	73c3      	strb	r3, [r0, #15]
    lv_obj_refresh_ext_draw_pad(label);
    b800:	4620      	mov	r0, r4
    b802:	f7fe f833 	bl	986c <lv_obj_refresh_ext_draw_pad>
    lv_obj_invalidate(label);
    b806:	4620      	mov	r0, r4
}
    b808:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    lv_obj_invalidate(label);
    b80c:	f7fd bf98 	b.w	9740 <lv_obj_invalidate>
}
    b810:	bd38      	pop	{r3, r4, r5, pc}

0000b812 <lv_label_get_text>:
{
    b812:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    b814:	f7fe fa5b 	bl	9cce <lv_obj_get_ext_attr>
}
    b818:	6800      	ldr	r0, [r0, #0]
    b81a:	bd08      	pop	{r3, pc}

0000b81c <lv_label_get_long_mode>:
{
    b81c:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    b81e:	f7fe fa56 	bl	9cce <lv_obj_get_ext_attr>
    return ext->long_mode;
    b822:	7b80      	ldrb	r0, [r0, #14]
}
    b824:	f000 0007 	and.w	r0, r0, #7
    b828:	bd08      	pop	{r3, pc}

0000b82a <lv_label_get_align>:
{
    b82a:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    b82c:	f7fe fa4f 	bl	9cce <lv_obj_get_ext_attr>
    lv_label_align_t align = ext->align;
    b830:	7b80      	ldrb	r0, [r0, #14]
    b832:	f3c0 1001 	ubfx	r0, r0, #4, #2
    if(align == LV_LABEL_ALIGN_AUTO) {
    b836:	2803      	cmp	r0, #3
}
    b838:	bf08      	it	eq
    b83a:	2000      	moveq	r0, #0
    b83c:	bd08      	pop	{r3, pc}

0000b83e <lv_label_design>:
{
    b83e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(mode == LV_DESIGN_COVER_CHK)
    b842:	2a02      	cmp	r2, #2
{
    b844:	b08f      	sub	sp, #60	; 0x3c
    b846:	4606      	mov	r6, r0
    b848:	4689      	mov	r9, r1
    if(mode == LV_DESIGN_COVER_CHK)
    b84a:	f000 8102 	beq.w	ba52 <lv_label_design+0x214>
    else if(mode == LV_DESIGN_DRAW_MAIN) {
    b84e:	2a00      	cmp	r2, #0
    b850:	f040 80f8 	bne.w	ba44 <lv_label_design+0x206>
        const lv_style_t * style = lv_obj_get_style(label);
    b854:	f7f8 fada 	bl	3e0c <lv_obj_get_style>
    b858:	4604      	mov	r4, r0
        lv_opa_t opa_scale       = lv_obj_get_opa_scale(label);
    b85a:	4630      	mov	r0, r6
    b85c:	f7fe f9d7 	bl	9c0e <lv_obj_get_opa_scale>
        lv_obj_get_coords(label, &coords);
    b860:	a90a      	add	r1, sp, #40	; 0x28
        lv_opa_t opa_scale       = lv_obj_get_opa_scale(label);
    b862:	4682      	mov	sl, r0
        lv_obj_get_coords(label, &coords);
    b864:	4630      	mov	r0, r6
    b866:	f7fe f88d 	bl	9984 <lv_obj_get_coords>
        lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    b86a:	4630      	mov	r0, r6
    b86c:	f7fe fa2f 	bl	9cce <lv_obj_get_ext_attr>
        if(ext->body_draw) {
    b870:	7bc3      	ldrb	r3, [r0, #15]
    b872:	07d9      	lsls	r1, r3, #31
        lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    b874:	4680      	mov	r8, r0
        if(ext->body_draw) {
    b876:	d524      	bpl.n	b8c2 <lv_label_design+0x84>
            lv_obj_get_coords(label, &bg);
    b878:	a90c      	add	r1, sp, #48	; 0x30
    b87a:	4630      	mov	r0, r6
    b87c:	f7fe f882 	bl	9984 <lv_obj_get_coords>
            bg.x1 -= style->body.padding.left;
    b880:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
    b882:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
    b886:	1a9b      	subs	r3, r3, r2
    b888:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
            bg.x2 += style->body.padding.right;
    b88c:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
    b88e:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
    b892:	4413      	add	r3, r2
    b894:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
            bg.y1 -= style->body.padding.top;
    b898:	8c22      	ldrh	r2, [r4, #32]
    b89a:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
    b89e:	1a9b      	subs	r3, r3, r2
    b8a0:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
            bg.y2 += style->body.padding.bottom;
    b8a4:	8c62      	ldrh	r2, [r4, #34]	; 0x22
    b8a6:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
            lv_draw_rect(&bg, mask, style, lv_obj_get_opa_scale(label));
    b8aa:	4630      	mov	r0, r6
            bg.y2 += style->body.padding.bottom;
    b8ac:	4413      	add	r3, r2
    b8ae:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
            lv_draw_rect(&bg, mask, style, lv_obj_get_opa_scale(label));
    b8b2:	f7fe f9ac 	bl	9c0e <lv_obj_get_opa_scale>
    b8b6:	4622      	mov	r2, r4
    b8b8:	4603      	mov	r3, r0
    b8ba:	4649      	mov	r1, r9
    b8bc:	a80c      	add	r0, sp, #48	; 0x30
    b8be:	f7fe fdac 	bl	a41a <lv_draw_rect>
        lv_label_align_t align = lv_label_get_align(label);
    b8c2:	4630      	mov	r0, r6
    b8c4:	f7ff ffb1 	bl	b82a <lv_label_get_align>
        if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
    b8c8:	f898 300e 	ldrb.w	r3, [r8, #14]
        if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
    b8cc:	061a      	lsls	r2, r3, #24
        if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
    b8ce:	f3c3 1580 	ubfx	r5, r3, #6, #1
        if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
    b8d2:	bf48      	it	mi
    b8d4:	f045 0502 	orrmi.w	r5, r5, #2
        if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
    b8d8:	2801      	cmp	r0, #1
    b8da:	f040 80b5 	bne.w	ba48 <lv_label_design+0x20a>
    b8de:	f045 0504 	orr.w	r5, r5, #4
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
    b8e2:	f003 0207 	and.w	r2, r3, #7
    b8e6:	3a03      	subs	r2, #3
    b8e8:	2a01      	cmp	r2, #1
    b8ea:	d81d      	bhi.n	b928 <lv_label_design+0xea>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
    b8ec:	f003 0330 	and.w	r3, r3, #48	; 0x30
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
    b8f0:	2b10      	cmp	r3, #16
    b8f2:	d001      	beq.n	b8f8 <lv_label_design+0xba>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
    b8f4:	2b20      	cmp	r3, #32
    b8f6:	d117      	bne.n	b928 <lv_label_design+0xea>
            lv_txt_get_size(&size, ext->text, style->text.font, style->text.letter_space, style->text.line_space,
    b8f8:	f647 4218 	movw	r2, #31768	; 0x7c18
    b8fc:	f9b4 3038 	ldrsh.w	r3, [r4, #56]	; 0x38
    b900:	9502      	str	r5, [sp, #8]
    b902:	9201      	str	r2, [sp, #4]
    b904:	f9b4 203a 	ldrsh.w	r2, [r4, #58]	; 0x3a
    b908:	9200      	str	r2, [sp, #0]
    b90a:	6b62      	ldr	r2, [r4, #52]	; 0x34
    b90c:	f8d8 1000 	ldr.w	r1, [r8]
    b910:	a80c      	add	r0, sp, #48	; 0x30
    b912:	f7ff fed0 	bl	b6b6 <lv_txt_get_size>
            if(size.x > lv_obj_get_width(label)) {
    b916:	4630      	mov	r0, r6
    b918:	f9bd 7030 	ldrsh.w	r7, [sp, #48]	; 0x30
    b91c:	f7fe f969 	bl	9bf2 <lv_obj_get_width>
    b920:	4287      	cmp	r7, r0
                flag &= ~LV_TXT_FLAG_CENTER;
    b922:	bfc8      	it	gt
    b924:	f005 05f3 	andgt.w	r5, r5, #243	; 0xf3
        sel.start = lv_label_get_text_sel_start(label);
    b928:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    b92c:	9308      	str	r3, [sp, #32]
        lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ext->offset, &sel, hint, lv_obj_get_base_dir(label));
    b92e:	4643      	mov	r3, r8
    b930:	4630      	mov	r0, r6
    b932:	f853 2b0a 	ldr.w	r2, [r3], #10
    b936:	e9cd 2306 	strd	r2, r3, [sp, #24]
    b93a:	f7fe f966 	bl	9c0a <lv_obj_get_base_dir>
    b93e:	9b07      	ldr	r3, [sp, #28]
    b940:	9a06      	ldr	r2, [sp, #24]
    b942:	9005      	str	r0, [sp, #20]
    b944:	f04f 0b00 	mov.w	fp, #0
    b948:	af08      	add	r7, sp, #32
    b94a:	e9cd 5301 	strd	r5, r3, [sp, #4]
    b94e:	9200      	str	r2, [sp, #0]
    b950:	4653      	mov	r3, sl
    b952:	f8cd b010 	str.w	fp, [sp, #16]
    b956:	9703      	str	r7, [sp, #12]
    b958:	4622      	mov	r2, r4
    b95a:	4649      	mov	r1, r9
    b95c:	a80a      	add	r0, sp, #40	; 0x28
    b95e:	f7f9 f873 	bl	4a48 <lv_draw_label>
        if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
    b962:	f898 300e 	ldrb.w	r3, [r8, #14]
    b966:	f003 0307 	and.w	r3, r3, #7
    b96a:	2b04      	cmp	r3, #4
    b96c:	d16a      	bne.n	ba44 <lv_label_design+0x206>
            lv_txt_get_size(&size, ext->text, style->text.font, style->text.letter_space, style->text.line_space,
    b96e:	f647 4218 	movw	r2, #31768	; 0x7c18
    b972:	f9b4 3038 	ldrsh.w	r3, [r4, #56]	; 0x38
    b976:	9502      	str	r5, [sp, #8]
    b978:	9201      	str	r2, [sp, #4]
    b97a:	f9b4 203a 	ldrsh.w	r2, [r4, #58]	; 0x3a
    b97e:	9200      	str	r2, [sp, #0]
    b980:	6b62      	ldr	r2, [r4, #52]	; 0x34
    b982:	f8d8 1000 	ldr.w	r1, [r8]
    b986:	a809      	add	r0, sp, #36	; 0x24
    b988:	f7ff fe95 	bl	b6b6 <lv_txt_get_size>
            if(size.x > lv_obj_get_width(label)) {
    b98c:	f9bd 3024 	ldrsh.w	r3, [sp, #36]	; 0x24
    b990:	9306      	str	r3, [sp, #24]
    b992:	4630      	mov	r0, r6
    b994:	f7fe f92d 	bl	9bf2 <lv_obj_get_width>
    b998:	9b06      	ldr	r3, [sp, #24]
    b99a:	4283      	cmp	r3, r0
    b99c:	dd29      	ble.n	b9f2 <lv_label_design+0x1b4>
                ofs.x = ext->offset.x + size.x +
    b99e:	f8bd 0024 	ldrh.w	r0, [sp, #36]	; 0x24
    b9a2:	f8b8 300a 	ldrh.w	r3, [r8, #10]
                        lv_font_get_glyph_width(style->text.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
    b9a6:	2220      	movs	r2, #32
                ofs.x = ext->offset.x + size.x +
    b9a8:	4403      	add	r3, r0
                        lv_font_get_glyph_width(style->text.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
    b9aa:	4611      	mov	r1, r2
                ofs.x = ext->offset.x + size.x +
    b9ac:	b21b      	sxth	r3, r3
                        lv_font_get_glyph_width(style->text.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
    b9ae:	6b60      	ldr	r0, [r4, #52]	; 0x34
                ofs.x = ext->offset.x + size.x +
    b9b0:	9306      	str	r3, [sp, #24]
                        lv_font_get_glyph_width(style->text.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
    b9b2:	f000 f8fd 	bl	bbb0 <lv_font_get_glyph_width>
                ofs.x = ext->offset.x + size.x +
    b9b6:	9b06      	ldr	r3, [sp, #24]
    b9b8:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    b9bc:	4403      	add	r3, r0
    b9be:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
                ofs.y = ext->offset.y;
    b9c2:	f8b8 300c 	ldrh.w	r3, [r8, #12]
    b9c6:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs, &sel, NULL, lv_obj_get_base_dir(label));
    b9ca:	4630      	mov	r0, r6
    b9cc:	f8d8 3000 	ldr.w	r3, [r8]
    b9d0:	9306      	str	r3, [sp, #24]
    b9d2:	f7fe f91a 	bl	9c0a <lv_obj_get_base_dir>
    b9d6:	aa0c      	add	r2, sp, #48	; 0x30
    b9d8:	9b06      	ldr	r3, [sp, #24]
    b9da:	9300      	str	r3, [sp, #0]
    b9dc:	e9cd b004 	strd	fp, r0, [sp, #16]
    b9e0:	e9cd 5201 	strd	r5, r2, [sp, #4]
    b9e4:	9703      	str	r7, [sp, #12]
    b9e6:	4653      	mov	r3, sl
    b9e8:	4622      	mov	r2, r4
    b9ea:	4649      	mov	r1, r9
    b9ec:	a80a      	add	r0, sp, #40	; 0x28
    b9ee:	f7f9 f82b 	bl	4a48 <lv_draw_label>
            if(size.y > lv_obj_get_height(label)) {
    b9f2:	4630      	mov	r0, r6
    b9f4:	f9bd 7026 	ldrsh.w	r7, [sp, #38]	; 0x26
    b9f8:	f7fe f901 	bl	9bfe <lv_obj_get_height>
    b9fc:	4287      	cmp	r7, r0
    b9fe:	dd21      	ble.n	ba44 <lv_label_design+0x206>
                ofs.x = ext->offset.x;
    ba00:	f8b8 300a 	ldrh.w	r3, [r8, #10]
    ba04:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
                ofs.y = ext->offset.y + size.y + lv_font_get_line_height(style->text.font);
    ba08:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
    ba0c:	f8b8 300c 	ldrh.w	r3, [r8, #12]
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs, &sel, NULL, lv_obj_get_base_dir(label));
    ba10:	f8d8 7000 	ldr.w	r7, [r8]
                ofs.y = ext->offset.y + size.y + lv_font_get_line_height(style->text.font);
    ba14:	441a      	add	r2, r3
    ba16:	6b63      	ldr	r3, [r4, #52]	; 0x34
    ba18:	7a1b      	ldrb	r3, [r3, #8]
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs, &sel, NULL, lv_obj_get_base_dir(label));
    ba1a:	4630      	mov	r0, r6
                ofs.y = ext->offset.y + size.y + lv_font_get_line_height(style->text.font);
    ba1c:	4413      	add	r3, r2
    ba1e:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs, &sel, NULL, lv_obj_get_base_dir(label));
    ba22:	f7fe f8f2 	bl	9c0a <lv_obj_get_base_dir>
    ba26:	2300      	movs	r3, #0
    ba28:	9304      	str	r3, [sp, #16]
    ba2a:	ab08      	add	r3, sp, #32
    ba2c:	9303      	str	r3, [sp, #12]
    ba2e:	ab0c      	add	r3, sp, #48	; 0x30
    ba30:	9005      	str	r0, [sp, #20]
    ba32:	e9cd 5301 	strd	r5, r3, [sp, #4]
    ba36:	9700      	str	r7, [sp, #0]
    ba38:	4653      	mov	r3, sl
    ba3a:	4622      	mov	r2, r4
    ba3c:	4649      	mov	r1, r9
    ba3e:	a80a      	add	r0, sp, #40	; 0x28
    ba40:	f7f9 f802 	bl	4a48 <lv_draw_label>
    return true;
    ba44:	2001      	movs	r0, #1
    ba46:	e005      	b.n	ba54 <lv_label_design+0x216>
        if(align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
    ba48:	2802      	cmp	r0, #2
    ba4a:	bf08      	it	eq
    ba4c:	f045 0508 	orreq.w	r5, r5, #8
    ba50:	e747      	b.n	b8e2 <lv_label_design+0xa4>
        return false;
    ba52:	2000      	movs	r0, #0
}
    ba54:	b00f      	add	sp, #60	; 0x3c
    ba56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000ba5a <lv_label_get_recolor>:
{
    ba5a:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    ba5c:	f7fe f937 	bl	9cce <lv_obj_get_ext_attr>
    return ext->recolor == 0 ? false : true;
    ba60:	7b80      	ldrb	r0, [r0, #14]
}
    ba62:	f3c0 1080 	ubfx	r0, r0, #6, #1
    ba66:	bd08      	pop	{r3, pc}

0000ba68 <lv_label_get_body_draw>:
{
    ba68:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    ba6a:	f7fe f930 	bl	9cce <lv_obj_get_ext_attr>
    return ext->body_draw == 0 ? false : true;
    ba6e:	7bc0      	ldrb	r0, [r0, #15]
}
    ba70:	f000 0001 	and.w	r0, r0, #1
    ba74:	bd08      	pop	{r3, pc}

0000ba76 <lv_label_set_text>:
{
    ba76:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ba7a:	4607      	mov	r7, r0
    ba7c:	460d      	mov	r5, r1
    lv_obj_invalidate(label);
    ba7e:	f7fd fe5f 	bl	9740 <lv_obj_invalidate>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    ba82:	4638      	mov	r0, r7
    ba84:	f7fe f923 	bl	9cce <lv_obj_get_ext_attr>
    ba88:	4604      	mov	r4, r0
    if(text == NULL) {
    ba8a:	b925      	cbnz	r5, ba96 <lv_label_set_text+0x20>
        lv_label_refr_text(label);
    ba8c:	4638      	mov	r0, r7
}
    ba8e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        lv_label_refr_text(label);
    ba92:	f7fa bbd7 	b.w	6244 <lv_label_refr_text>
    if(ext->text == text) {
    ba96:	6806      	ldr	r6, [r0, #0]
    ba98:	42ae      	cmp	r6, r5
    ba9a:	d10b      	bne.n	bab4 <lv_label_set_text+0x3e>
        ext->text = lv_mem_realloc(ext->text, strlen(ext->text) + 1);
    ba9c:	4630      	mov	r0, r6
    ba9e:	f7fc ff14 	bl	88ca <strlen>
    baa2:	1c41      	adds	r1, r0, #1
    baa4:	4630      	mov	r0, r6
    baa6:	f7fa f8e3 	bl	5c70 <lv_mem_realloc>
    baaa:	6020      	str	r0, [r4, #0]
        if(ext->text == NULL) return;
    baac:	2800      	cmp	r0, #0
    baae:	d1ed      	bne.n	ba8c <lv_label_set_text+0x16>
}
    bab0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        size_t len = strlen(text) + 1;
    bab4:	4628      	mov	r0, r5
    bab6:	f7fc ff08 	bl	88ca <strlen>
    baba:	f100 0801 	add.w	r8, r0, #1
        if(ext->text != NULL && ext->static_txt == 0) {
    babe:	6820      	ldr	r0, [r4, #0]
    bac0:	b130      	cbz	r0, bad0 <lv_label_set_text+0x5a>
    bac2:	7ba3      	ldrb	r3, [r4, #14]
    bac4:	f013 0608 	ands.w	r6, r3, #8
    bac8:	d102      	bne.n	bad0 <lv_label_set_text+0x5a>
            lv_mem_free(ext->text);
    baca:	f7fa f8b3 	bl	5c34 <lv_mem_free>
            ext->text = NULL;
    bace:	6026      	str	r6, [r4, #0]
        ext->text = lv_mem_alloc(len);
    bad0:	4640      	mov	r0, r8
    bad2:	f7fa f889 	bl	5be8 <lv_mem_alloc>
    bad6:	6020      	str	r0, [r4, #0]
        if(ext->text == NULL) return;
    bad8:	2800      	cmp	r0, #0
    bada:	d0e9      	beq.n	bab0 <lv_label_set_text+0x3a>
        strcpy(ext->text, text);
    badc:	4629      	mov	r1, r5
    bade:	f7fc fec9 	bl	8874 <strcpy>
        ext->static_txt = 0;
    bae2:	7ba3      	ldrb	r3, [r4, #14]
    bae4:	f36f 03c3 	bfc	r3, #3, #1
    bae8:	73a3      	strb	r3, [r4, #14]
    baea:	e7cf      	b.n	ba8c <lv_label_set_text+0x16>

0000baec <lv_label_set_static_text>:
{
    baec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    baee:	4607      	mov	r7, r0
    baf0:	460e      	mov	r6, r1
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    baf2:	f7fe f8ec 	bl	9cce <lv_obj_get_ext_attr>
    if(ext->static_txt == 0 && ext->text != NULL) {
    baf6:	7b83      	ldrb	r3, [r0, #14]
    baf8:	f013 0508 	ands.w	r5, r3, #8
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    bafc:	4604      	mov	r4, r0
    if(ext->static_txt == 0 && ext->text != NULL) {
    bafe:	d104      	bne.n	bb0a <lv_label_set_static_text+0x1e>
    bb00:	6800      	ldr	r0, [r0, #0]
    bb02:	b110      	cbz	r0, bb0a <lv_label_set_static_text+0x1e>
        lv_mem_free(ext->text);
    bb04:	f7fa f896 	bl	5c34 <lv_mem_free>
        ext->text = NULL;
    bb08:	6025      	str	r5, [r4, #0]
    if(text != NULL) {
    bb0a:	b126      	cbz	r6, bb16 <lv_label_set_static_text+0x2a>
        ext->static_txt = 1;
    bb0c:	7ba3      	ldrb	r3, [r4, #14]
        ext->text       = (char *)text;
    bb0e:	6026      	str	r6, [r4, #0]
        ext->static_txt = 1;
    bb10:	f043 0308 	orr.w	r3, r3, #8
    bb14:	73a3      	strb	r3, [r4, #14]
    lv_label_refr_text(label);
    bb16:	4638      	mov	r0, r7
}
    bb18:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    lv_label_refr_text(label);
    bb1c:	f7fa bb92 	b.w	6244 <lv_label_refr_text>

0000bb20 <lv_label_set_long_mode>:
{
    bb20:	b570      	push	{r4, r5, r6, lr}
    bb22:	460e      	mov	r6, r1
    bb24:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    bb26:	f7fe f8d2 	bl	9cce <lv_obj_get_ext_attr>
    if(long_mode == LV_LABEL_LONG_SROLL || long_mode == LV_LABEL_LONG_SROLL_CIRC || long_mode == LV_LABEL_LONG_CROP)
    bb2a:	1ef2      	subs	r2, r6, #3
    ext->offset.x = 0;
    bb2c:	2300      	movs	r3, #0
    if(long_mode == LV_LABEL_LONG_SROLL || long_mode == LV_LABEL_LONG_SROLL_CIRC || long_mode == LV_LABEL_LONG_CROP)
    bb2e:	2a02      	cmp	r2, #2
    ext->offset.x = 0;
    bb30:	8143      	strh	r3, [r0, #10]
    ext->offset.y = 0;
    bb32:	8183      	strh	r3, [r0, #12]
    bb34:	7b83      	ldrb	r3, [r0, #14]
    if(long_mode == LV_LABEL_LONG_SROLL || long_mode == LV_LABEL_LONG_SROLL_CIRC || long_mode == LV_LABEL_LONG_CROP)
    bb36:	bf8c      	ite	hi
    bb38:	2200      	movhi	r2, #0
    bb3a:	2201      	movls	r2, #1
    bb3c:	f362 13c7 	bfi	r3, r2, #7, #1
    bb40:	7383      	strb	r3, [r0, #14]
    if(ext->long_mode == LV_LABEL_LONG_DOT && ext->dot_end != LV_LABEL_DOT_END_INV) {
    bb42:	f003 0307 	and.w	r3, r3, #7
    bb46:	2b02      	cmp	r3, #2
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    bb48:	4604      	mov	r4, r0
    if(ext->long_mode == LV_LABEL_LONG_DOT && ext->dot_end != LV_LABEL_DOT_END_INV) {
    bb4a:	d107      	bne.n	bb5c <lv_label_set_long_mode+0x3c>
    bb4c:	8902      	ldrh	r2, [r0, #8]
    bb4e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    bb52:	429a      	cmp	r2, r3
    bb54:	d002      	beq.n	bb5c <lv_label_set_long_mode+0x3c>
        lv_label_revert_dots(label);
    bb56:	4628      	mov	r0, r5
    bb58:	f7fa fa18 	bl	5f8c <lv_label_revert_dots>
    ext->long_mode = long_mode;
    bb5c:	7ba3      	ldrb	r3, [r4, #14]
    bb5e:	f366 0302 	bfi	r3, r6, #0, #3
    bb62:	73a3      	strb	r3, [r4, #14]
    lv_label_refr_text(label);
    bb64:	4628      	mov	r0, r5
}
    bb66:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    lv_label_refr_text(label);
    bb6a:	f7fa bb6b 	b.w	6244 <lv_label_refr_text>

0000bb6e <lv_label_set_recolor>:
{
    bb6e:	b538      	push	{r3, r4, r5, lr}
    bb70:	460c      	mov	r4, r1
    bb72:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    bb74:	f7fe f8ab 	bl	9cce <lv_obj_get_ext_attr>
    if(ext->recolor == en) return;
    bb78:	7b83      	ldrb	r3, [r0, #14]
    bb7a:	f3c3 1280 	ubfx	r2, r3, #6, #1
    bb7e:	42a2      	cmp	r2, r4
    bb80:	d007      	beq.n	bb92 <lv_label_set_recolor+0x24>
    ext->recolor = en == false ? 0 : 1;
    bb82:	f364 1386 	bfi	r3, r4, #6, #1
    bb86:	7383      	strb	r3, [r0, #14]
    lv_label_refr_text(label); /*Refresh the text because the potential colo codes in text needs to
    bb88:	4628      	mov	r0, r5
}
    bb8a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    lv_label_refr_text(label); /*Refresh the text because the potential colo codes in text needs to
    bb8e:	f7fa bb59 	b.w	6244 <lv_label_refr_text>
}
    bb92:	bd38      	pop	{r3, r4, r5, pc}

0000bb94 <lv_img_get_auto_size>:
{
    bb94:	b508      	push	{r3, lr}
    lv_img_ext_t * ext = lv_obj_get_ext_attr(img);
    bb96:	f7fe f89a 	bl	9cce <lv_obj_get_ext_attr>
    return ext->auto_size == 0 ? false : true;
    bb9a:	7b00      	ldrb	r0, [r0, #12]
}
    bb9c:	f3c0 0080 	ubfx	r0, r0, #2, #1
    bba0:	bd08      	pop	{r3, pc}

0000bba2 <lv_font_get_glyph_bitmap>:
 * @param letter an UNICODE character code
 * @return  pointer to the bitmap of the letter
 */
const uint8_t * lv_font_get_glyph_bitmap(const lv_font_t * font_p, uint32_t letter)
{
    return font_p->get_glyph_bitmap(font_p, letter);
    bba2:	6843      	ldr	r3, [r0, #4]
    bba4:	4718      	bx	r3

0000bba6 <lv_font_get_glyph_dsc>:
 * @param letter an UNICODE letter code
 * @return true: descriptor is successfully loaded into `dsc_out`.
 *         false: the letter was not found, no data is loaded to `dsc_out`
 */
bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_out, uint32_t letter, uint32_t letter_next)
{
    bba6:	b410      	push	{r4}
    return font_p->get_glyph_dsc(font_p, dsc_out, letter, letter_next);
    bba8:	6804      	ldr	r4, [r0, #0]
    bbaa:	46a4      	mov	ip, r4
}
    bbac:	bc10      	pop	{r4}
    return font_p->get_glyph_dsc(font_p, dsc_out, letter, letter_next);
    bbae:	4760      	bx	ip

0000bbb0 <lv_font_get_glyph_width>:
 * @param letter an UNICODE letter
 * @param letter_next the next letter after `letter`. Used for kerning
 * @return the width of the glyph
 */
uint16_t lv_font_get_glyph_width(const lv_font_t * font, uint32_t letter, uint32_t letter_next)
{
    bbb0:	b507      	push	{r0, r1, r2, lr}
    lv_font_glyph_dsc_t g;
    bool ret;
    ret = lv_font_get_glyph_dsc(font, &g, letter, letter_next);
    bbb2:	4613      	mov	r3, r2
    bbb4:	460a      	mov	r2, r1
    bbb6:	4669      	mov	r1, sp
    bbb8:	f7ff fff5 	bl	bba6 <lv_font_get_glyph_dsc>
    if(ret) return g.adv_w;
    bbbc:	b108      	cbz	r0, bbc2 <lv_font_get_glyph_width+0x12>
    bbbe:	f8bd 0000 	ldrh.w	r0, [sp]
    else return 0;
}
    bbc2:	b003      	add	sp, #12
    bbc4:	f85d fb04 	ldr.w	pc, [sp], #4

0000bbc8 <kern_pair_8_compare>:
    if(ref8_p[0] != element8_p[0]) return (int32_t)ref8_p[0] - element8_p[0];
    bbc8:	7803      	ldrb	r3, [r0, #0]
    bbca:	780a      	ldrb	r2, [r1, #0]
    bbcc:	4293      	cmp	r3, r2
    bbce:	bf11      	iteee	ne
    bbd0:	1a98      	subne	r0, r3, r2
    else return (int32_t) ref8_p[1] - element8_p[1];
    bbd2:	784b      	ldrbeq	r3, [r1, #1]
    bbd4:	7840      	ldrbeq	r0, [r0, #1]
    bbd6:	1ac0      	subeq	r0, r0, r3
}
    bbd8:	4770      	bx	lr

0000bbda <kern_pair_16_compare>:
    if(ref16_p[0] != element16_p[0]) return (int32_t)ref16_p[0] - element16_p[0];
    bbda:	8803      	ldrh	r3, [r0, #0]
    bbdc:	880a      	ldrh	r2, [r1, #0]
    bbde:	4293      	cmp	r3, r2
    bbe0:	bf11      	iteee	ne
    bbe2:	1a98      	subne	r0, r3, r2
    else return (int32_t) ref16_p[1] - element16_p[1];
    bbe4:	884b      	ldrheq	r3, [r1, #2]
    bbe6:	8840      	ldrheq	r0, [r0, #2]
    bbe8:	1ac0      	subeq	r0, r0, r3
}
    bbea:	4770      	bx	lr

0000bbec <get_bits>:
{
    bbec:	b510      	push	{r4, lr}
    uint32_t byte_pos = bit_pos >> 3;
    bbee:	08cb      	lsrs	r3, r1, #3
    bit_pos = bit_pos & 0x7;
    bbf0:	f001 0107 	and.w	r1, r1, #7
    uint16_t in16 = (in[byte_pos] << 8) + in[byte_pos + 1];
    bbf4:	5cc4      	ldrb	r4, [r0, r3]
    bbf6:	4418      	add	r0, r3
    uint8_t bit_mask = (uint16_t)((uint16_t) 1 << len) - 1;
    bbf8:	2301      	movs	r3, #1
    uint16_t in16 = (in[byte_pos] << 8) + in[byte_pos + 1];
    bbfa:	7840      	ldrb	r0, [r0, #1]
    bbfc:	eb00 2004 	add.w	r0, r0, r4, lsl #8
    res = (in16 >> (16 - bit_pos - len)) & bit_mask;
    bc00:	f1c2 0410 	rsb	r4, r2, #16
    bc04:	1a61      	subs	r1, r4, r1
    uint8_t bit_mask = (uint16_t)((uint16_t) 1 << len) - 1;
    bc06:	4093      	lsls	r3, r2
    res = (in16 >> (16 - bit_pos - len)) & bit_mask;
    bc08:	b280      	uxth	r0, r0
    bc0a:	4108      	asrs	r0, r1
    uint8_t bit_mask = (uint16_t)((uint16_t) 1 << len) - 1;
    bc0c:	3b01      	subs	r3, #1
    res = (in16 >> (16 - bit_pos - len)) & bit_mask;
    bc0e:	4018      	ands	r0, r3
}
    bc10:	b2c0      	uxtb	r0, r0
    bc12:	bd10      	pop	{r4, pc}

0000bc14 <unicode_list_compare>:
 *  @retval > 0   Reference is less than element.
 *
 */
static int32_t unicode_list_compare(const void * ref, const void * element)
{
    return (*(uint16_t *)ref) - (*(uint16_t *)element);
    bc14:	8800      	ldrh	r0, [r0, #0]
    bc16:	880b      	ldrh	r3, [r1, #0]
}
    bc18:	1ac0      	subs	r0, r0, r3
    bc1a:	4770      	bx	lr

0000bc1c <arch_system_halt>:
	__asm__ volatile(
    bc1c:	f04f 0220 	mov.w	r2, #32
    bc20:	f3ef 8311 	mrs	r3, BASEPRI
    bc24:	f382 8811 	msr	BASEPRI, r2
    bc28:	f3bf 8f6f 	isb	sy
	}
    bc2c:	e7fe      	b.n	bc2c <arch_system_halt+0x10>

0000bc2e <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
    bc2e:	f7fc be0b 	b.w	8848 <z_clock_idle_exit>

0000bc32 <k_mem_slab_init>:
{
    bc32:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
    bc34:	2400      	movs	r4, #0
	slab->block_size = block_size;
    bc36:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->free_list = NULL;
    bc3a:	e9c0 4405 	strd	r4, r4, [r0, #20]
	slab->buffer = buffer;
    bc3e:	6101      	str	r1, [r0, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
    bc40:	42a3      	cmp	r3, r4
    bc42:	d102      	bne.n	bc4a <k_mem_slab_init+0x18>
	list->tail = (sys_dnode_t *)list;
    bc44:	e9c0 0000 	strd	r0, r0, [r0]
}
    bc48:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
    bc4a:	6945      	ldr	r5, [r0, #20]
    bc4c:	600d      	str	r5, [r1, #0]
	for (j = 0U; j < slab->num_blocks; j++) {
    bc4e:	3401      	adds	r4, #1
		slab->free_list = p;
    bc50:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
    bc52:	4411      	add	r1, r2
    bc54:	e7f4      	b.n	bc40 <k_mem_slab_init+0xe>

0000bc56 <k_mem_pool_malloc>:
{
    bc56:	b513      	push	{r0, r1, r4, lr}
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
    bc58:	2404      	movs	r4, #4
    bc5a:	190a      	adds	r2, r1, r4
    bc5c:	d204      	bcs.n	bc68 <k_mem_pool_malloc+0x12>
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
    bc5e:	2300      	movs	r3, #0
    bc60:	4669      	mov	r1, sp
    bc62:	f7fb fb79 	bl	7358 <k_mem_pool_alloc>
    bc66:	b110      	cbz	r0, bc6e <k_mem_pool_malloc+0x18>
		return NULL;
    bc68:	2000      	movs	r0, #0
}
    bc6a:	b002      	add	sp, #8
    bc6c:	bd10      	pop	{r4, pc}
	(void)memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));
    bc6e:	4622      	mov	r2, r4
    bc70:	a901      	add	r1, sp, #4
    bc72:	9800      	ldr	r0, [sp, #0]
    bc74:	f7fc fe3c 	bl	88f0 <memcpy>
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
    bc78:	9800      	ldr	r0, [sp, #0]
    bc7a:	3004      	adds	r0, #4
    bc7c:	e7f5      	b.n	bc6a <k_mem_pool_malloc+0x14>

0000bc7e <k_free>:
	if (ptr != NULL) {
    bc7e:	b110      	cbz	r0, bc86 <k_free+0x8>
		k_mem_pool_free_id(ptr);
    bc80:	3804      	subs	r0, #4
    bc82:	f7fb bbb5 	b.w	73f0 <k_mem_pool_free_id>
}
    bc86:	4770      	bx	lr

0000bc88 <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    bc88:	7b43      	ldrb	r3, [r0, #13]
    bc8a:	06db      	lsls	r3, r3, #27
    bc8c:	bf03      	ittte	eq
    bc8e:	6980      	ldreq	r0, [r0, #24]
    bc90:	fab0 f080 	clzeq	r0, r0
    bc94:	0940      	lsreq	r0, r0, #5
    bc96:	2000      	movne	r0, #0
}
    bc98:	4770      	bx	lr

0000bc9a <z_find_first_thread_to_unpend>:
{
    bc9a:	b510      	push	{r4, lr}
    bc9c:	f04f 0320 	mov.w	r3, #32
    bca0:	f3ef 8411 	mrs	r4, BASEPRI
    bca4:	f383 8811 	msr	BASEPRI, r3
    bca8:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
    bcac:	f000 f85d 	bl	bd6a <z_priq_dumb_best>
	__asm__ volatile(
    bcb0:	f384 8811 	msr	BASEPRI, r4
    bcb4:	f3bf 8f6f 	isb	sy
}
    bcb8:	bd10      	pop	{r4, pc}

0000bcba <z_unpend_thread_no_timeout>:
{
    bcba:	b538      	push	{r3, r4, r5, lr}
    bcbc:	4604      	mov	r4, r0
	__asm__ volatile(
    bcbe:	f04f 0320 	mov.w	r3, #32
    bcc2:	f3ef 8511 	mrs	r5, BASEPRI
    bcc6:	f383 8811 	msr	BASEPRI, r3
    bcca:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
    bcce:	4601      	mov	r1, r0
    bcd0:	6880      	ldr	r0, [r0, #8]
    bcd2:	f7fb fc15 	bl	7500 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    bcd6:	7b63      	ldrb	r3, [r4, #13]
    bcd8:	f023 0302 	bic.w	r3, r3, #2
    bcdc:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
    bcde:	f385 8811 	msr	BASEPRI, r5
    bce2:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
    bce6:	2300      	movs	r3, #0
    bce8:	60a3      	str	r3, [r4, #8]
}
    bcea:	bd38      	pop	{r3, r4, r5, pc}

0000bcec <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    bcec:	b921      	cbnz	r1, bcf8 <z_reschedule+0xc>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    bcee:	f3ef 8005 	mrs	r0, IPSR
    bcf2:	b908      	cbnz	r0, bcf8 <z_reschedule+0xc>
    bcf4:	f7f5 ba26 	b.w	1144 <arch_swap>
    bcf8:	f381 8811 	msr	BASEPRI, r1
    bcfc:	f3bf 8f6f 	isb	sy
}
    bd00:	4770      	bx	lr

0000bd02 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    bd02:	4603      	mov	r3, r0
    bd04:	b920      	cbnz	r0, bd10 <z_reschedule_irqlock+0xe>
    bd06:	f3ef 8205 	mrs	r2, IPSR
    bd0a:	b90a      	cbnz	r2, bd10 <z_reschedule_irqlock+0xe>
    bd0c:	f7f5 ba1a 	b.w	1144 <arch_swap>
    bd10:	f383 8811 	msr	BASEPRI, r3
    bd14:	f3bf 8f6f 	isb	sy
}
    bd18:	4770      	bx	lr

0000bd1a <z_reschedule_unlocked>:
	__asm__ volatile(
    bd1a:	f04f 0320 	mov.w	r3, #32
    bd1e:	f3ef 8011 	mrs	r0, BASEPRI
    bd22:	f383 8811 	msr	BASEPRI, r3
    bd26:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
    bd2a:	f7ff bfea 	b.w	bd02 <z_reschedule_irqlock>

0000bd2e <z_unpend_thread>:
{
    bd2e:	b538      	push	{r3, r4, r5, lr}
    bd30:	4604      	mov	r4, r0
    bd32:	f04f 0320 	mov.w	r3, #32
    bd36:	f3ef 8511 	mrs	r5, BASEPRI
    bd3a:	f383 8811 	msr	BASEPRI, r3
    bd3e:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
    bd42:	4601      	mov	r1, r0
    bd44:	6880      	ldr	r0, [r0, #8]
    bd46:	f7fb fbdb 	bl	7500 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    bd4a:	7b63      	ldrb	r3, [r4, #13]
    bd4c:	f023 0302 	bic.w	r3, r3, #2
    bd50:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
    bd52:	f385 8811 	msr	BASEPRI, r5
    bd56:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
    bd5a:	2300      	movs	r3, #0
    bd5c:	60a3      	str	r3, [r4, #8]
	return z_abort_timeout(&thread->base.timeout);
    bd5e:	f104 0018 	add.w	r0, r4, #24
}
    bd62:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    bd66:	f000 b890 	b.w	be8a <z_abort_timeout>

0000bd6a <z_priq_dumb_best>:
	return list->head == list;
    bd6a:	6803      	ldr	r3, [r0, #0]
}
    bd6c:	4298      	cmp	r0, r3
    bd6e:	bf14      	ite	ne
    bd70:	4618      	movne	r0, r3
    bd72:	2000      	moveq	r0, #0
    bd74:	4770      	bx	lr

0000bd76 <z_thread_timeout>:
	if (thread->base.pended_on != NULL) {
    bd76:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
    bd7a:	b570      	push	{r4, r5, r6, lr}
    bd7c:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
    bd7e:	f1a0 0518 	sub.w	r5, r0, #24
	if (thread->base.pended_on != NULL) {
    bd82:	b1cb      	cbz	r3, bdb8 <z_thread_timeout+0x42>
	__asm__ volatile(
    bd84:	f04f 0320 	mov.w	r3, #32
    bd88:	f3ef 8611 	mrs	r6, BASEPRI
    bd8c:	f383 8811 	msr	BASEPRI, r3
    bd90:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
    bd94:	4629      	mov	r1, r5
    bd96:	f850 0c10 	ldr.w	r0, [r0, #-16]
    bd9a:	f7fb fbb1 	bl	7500 <z_priq_dumb_remove>
    bd9e:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
    bda2:	f023 0302 	bic.w	r3, r3, #2
    bda6:	f804 3c0b 	strb.w	r3, [r4, #-11]
	__asm__ volatile(
    bdaa:	f386 8811 	msr	BASEPRI, r6
    bdae:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
    bdb2:	2300      	movs	r3, #0
    bdb4:	f844 3c10 	str.w	r3, [r4, #-16]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    bdb8:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
    bdbc:	f023 0314 	bic.w	r3, r3, #20
    bdc0:	f804 3c0b 	strb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
    bdc4:	4628      	mov	r0, r5
    bdc6:	f7ff ff5f 	bl	bc88 <z_is_thread_ready>
    bdca:	b120      	cbz	r0, bdd6 <z_thread_timeout+0x60>
		z_add_thread_to_ready_q(thread);
    bdcc:	4628      	mov	r0, r5
}
    bdce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    bdd2:	f7fb bbe5 	b.w	75a0 <z_add_thread_to_ready_q>
    bdd6:	bd70      	pop	{r4, r5, r6, pc}

0000bdd8 <z_unpend_first_thread>:
{
    bdd8:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
    bdda:	f04f 0320 	mov.w	r3, #32
    bdde:	f3ef 8211 	mrs	r2, BASEPRI
    bde2:	f383 8811 	msr	BASEPRI, r3
    bde6:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
    bdea:	f7ff ffbe 	bl	bd6a <z_priq_dumb_best>
    bdee:	4604      	mov	r4, r0
	__asm__ volatile(
    bdf0:	f382 8811 	msr	BASEPRI, r2
    bdf4:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
    bdf8:	b1c8      	cbz	r0, be2e <z_unpend_first_thread+0x56>
	__asm__ volatile(
    bdfa:	f04f 0320 	mov.w	r3, #32
    bdfe:	f3ef 8511 	mrs	r5, BASEPRI
    be02:	f383 8811 	msr	BASEPRI, r3
    be06:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
    be0a:	4601      	mov	r1, r0
    be0c:	6880      	ldr	r0, [r0, #8]
    be0e:	f7fb fb77 	bl	7500 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    be12:	7b63      	ldrb	r3, [r4, #13]
    be14:	f023 0302 	bic.w	r3, r3, #2
    be18:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
    be1a:	f385 8811 	msr	BASEPRI, r5
    be1e:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
    be22:	2300      	movs	r3, #0
    be24:	60a3      	str	r3, [r4, #8]
    be26:	f104 0018 	add.w	r0, r4, #24
    be2a:	f000 f82e 	bl	be8a <z_abort_timeout>
}
    be2e:	4620      	mov	r0, r4
    be30:	bd38      	pop	{r3, r4, r5, pc}

0000be32 <z_unpend_all>:
{
    be32:	b570      	push	{r4, r5, r6, lr}
    be34:	4606      	mov	r6, r0
	int need_sched = 0;
    be36:	2500      	movs	r5, #0
    be38:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    be3a:	42a6      	cmp	r6, r4
    be3c:	d000      	beq.n	be40 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    be3e:	b90c      	cbnz	r4, be44 <z_unpend_all+0x12>
}
    be40:	4628      	mov	r0, r5
    be42:	bd70      	pop	{r4, r5, r6, pc}
		z_unpend_thread(thread);
    be44:	4620      	mov	r0, r4
    be46:	f7ff ff72 	bl	bd2e <z_unpend_thread>
	if (z_is_thread_ready(thread)) {
    be4a:	4620      	mov	r0, r4
    be4c:	f7ff ff1c 	bl	bc88 <z_is_thread_ready>
		need_sched = 1;
    be50:	2501      	movs	r5, #1
    be52:	2800      	cmp	r0, #0
    be54:	d0f0      	beq.n	be38 <z_unpend_all+0x6>
		z_add_thread_to_ready_q(thread);
    be56:	4620      	mov	r0, r4
    be58:	f7fb fba2 	bl	75a0 <z_add_thread_to_ready_q>
    be5c:	e7ec      	b.n	be38 <z_unpend_all+0x6>

0000be5e <z_impl_k_busy_wait>:
	arch_busy_wait(usec_to_wait);
    be5e:	f7f6 bc51 	b.w	2704 <arch_busy_wait>

0000be62 <z_impl_k_thread_name_set>:
}
    be62:	f06f 0046 	mvn.w	r0, #70	; 0x46
    be66:	4770      	bx	lr

0000be68 <k_thread_name_get>:
}
    be68:	2000      	movs	r0, #0
    be6a:	4770      	bx	lr

0000be6c <z_new_thread_init>:
{
    be6c:	b510      	push	{r4, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
    be6e:	9c02      	ldr	r4, [sp, #8]
    be70:	7304      	strb	r4, [r0, #12]
	thread_base->thread_state = (u8_t)initial_state;

	thread_base->prio = priority;
    be72:	7383      	strb	r3, [r0, #14]
	thread_base->thread_state = (u8_t)initial_state;
    be74:	2404      	movs	r4, #4

	thread_base->sched_locked = 0U;
    be76:	2300      	movs	r3, #0
	thread_base->thread_state = (u8_t)initial_state;
    be78:	7344      	strb	r4, [r0, #13]
	thread_base->sched_locked = 0U;
    be7a:	73c3      	strb	r3, [r0, #15]
	node->prev = NULL;
    be7c:	e9c0 3306 	strd	r3, r3, [r0, #24]
	thread->fn_abort = NULL;
    be80:	e9c0 3313 	strd	r3, r3, [r0, #76]	; 0x4c
	thread->stack_info.size = (u32_t)stackSize;
    be84:	e9c0 1216 	strd	r1, r2, [r0, #88]	; 0x58
}
    be88:	bd10      	pop	{r4, pc}

0000be8a <z_abort_timeout>:
{
    be8a:	b510      	push	{r4, lr}
	__asm__ volatile(
    be8c:	f04f 0220 	mov.w	r2, #32
    be90:	f3ef 8411 	mrs	r4, BASEPRI
    be94:	f382 8811 	msr	BASEPRI, r2
    be98:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
    be9c:	6803      	ldr	r3, [r0, #0]
    be9e:	b13b      	cbz	r3, beb0 <z_abort_timeout+0x26>
			remove_timeout(to);
    bea0:	f7fb ff32 	bl	7d08 <remove_timeout>
			ret = 0;
    bea4:	2000      	movs	r0, #0
	__asm__ volatile(
    bea6:	f384 8811 	msr	BASEPRI, r4
    beaa:	f3bf 8f6f 	isb	sy
}
    beae:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
    beb0:	f06f 0015 	mvn.w	r0, #21
    beb4:	e7f7      	b.n	bea6 <z_abort_timeout+0x1c>

0000beb6 <z_get_next_timeout_expiry>:
{
    beb6:	b510      	push	{r4, lr}
	__asm__ volatile(
    beb8:	f04f 0320 	mov.w	r3, #32
    bebc:	f3ef 8411 	mrs	r4, BASEPRI
    bec0:	f383 8811 	msr	BASEPRI, r3
    bec4:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
    bec8:	f7fb ff32 	bl	7d30 <next_timeout>
	__asm__ volatile(
    becc:	f384 8811 	msr	BASEPRI, r4
    bed0:	f3bf 8f6f 	isb	sy
}
    bed4:	bd10      	pop	{r4, pc}

0000bed6 <z_set_timeout_expiry>:
{
    bed6:	b570      	push	{r4, r5, r6, lr}
    bed8:	4604      	mov	r4, r0
    beda:	460e      	mov	r6, r1
	__asm__ volatile(
    bedc:	f04f 0320 	mov.w	r3, #32
    bee0:	f3ef 8511 	mrs	r5, BASEPRI
    bee4:	f383 8811 	msr	BASEPRI, r3
    bee8:	f3bf 8f6f 	isb	sy
		int next = next_timeout();
    beec:	f7fb ff20 	bl	7d30 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    bef0:	2801      	cmp	r0, #1
    bef2:	dd05      	ble.n	bf00 <z_set_timeout_expiry+0x2a>
    bef4:	42a0      	cmp	r0, r4
    bef6:	dd03      	ble.n	bf00 <z_set_timeout_expiry+0x2a>
			z_clock_set_timeout(ticks, idle);
    bef8:	4631      	mov	r1, r6
    befa:	4620      	mov	r0, r4
    befc:	f7f5 f88a 	bl	1014 <z_clock_set_timeout>
	__asm__ volatile(
    bf00:	f385 8811 	msr	BASEPRI, r5
    bf04:	f3bf 8f6f 	isb	sy
}
    bf08:	bd70      	pop	{r4, r5, r6, pc}

0000bf0a <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
    bf0a:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
    bf0c:	f7fb ffc4 	bl	7e98 <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
    bf10:	bd08      	pop	{r3, pc}

0000bf12 <z_impl_k_uptime_get>:

s64_t z_impl_k_uptime_get(void)
{
    bf12:	b510      	push	{r4, lr}
	return k_ticks_to_ms_floor64(z_tick_get());
    bf14:	f7fb ffc0 	bl	7e98 <z_tick_get>
			return (t * to_hz + off) / from_hz;
    bf18:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
    bf1c:	fba0 2304 	umull	r2, r3, r0, r4
    bf20:	fb04 3301 	mla	r3, r4, r1, r3
    bf24:	0bd0      	lsrs	r0, r2, #15
}
    bf26:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
    bf2a:	0bd9      	lsrs	r1, r3, #15
    bf2c:	bd10      	pop	{r4, pc}

0000bf2e <k_timer_init>:
	timer->status = 0U;
    bf2e:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
    bf30:	e9c0 1206 	strd	r1, r2, [r0, #24]
    bf34:	f100 0210 	add.w	r2, r0, #16
	timer->status = 0U;
    bf38:	6243      	str	r3, [r0, #36]	; 0x24
	list->tail = (sys_dnode_t *)list;
    bf3a:	e9c0 2204 	strd	r2, r2, [r0, #16]
	node->prev = NULL;
    bf3e:	e9c0 3300 	strd	r3, r3, [r0]
	timer->user_data = NULL;
    bf42:	6283      	str	r3, [r0, #40]	; 0x28
}
    bf44:	4770      	bx	lr

0000bf46 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
    bf46:	b510      	push	{r4, lr}
    bf48:	4604      	mov	r4, r0
	int inactive = z_abort_timeout(&timer->timeout) != 0;
    bf4a:	f7ff ff9e 	bl	be8a <z_abort_timeout>

	if (inactive) {
    bf4e:	bb00      	cbnz	r0, bf92 <z_impl_k_timer_stop+0x4c>
		return;
	}

	if (timer->stop_fn != NULL) {
    bf50:	69e3      	ldr	r3, [r4, #28]
    bf52:	b10b      	cbz	r3, bf58 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
    bf54:	4620      	mov	r0, r4
    bf56:	4798      	blx	r3
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
    bf58:	f104 0010 	add.w	r0, r4, #16
    bf5c:	2100      	movs	r1, #0
    bf5e:	f7ff fe9c 	bl	bc9a <z_find_first_thread_to_unpend>
	if (thread != NULL) {
    bf62:	4604      	mov	r4, r0
    bf64:	b1a8      	cbz	r0, bf92 <z_impl_k_timer_stop+0x4c>
		z_unpend_thread_no_timeout(thread);
    bf66:	f7ff fea8 	bl	bcba <z_unpend_thread_no_timeout>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    bf6a:	7b63      	ldrb	r3, [r4, #13]
    bf6c:	06db      	lsls	r3, r3, #27
    bf6e:	d104      	bne.n	bf7a <z_impl_k_timer_stop+0x34>
	if (z_is_thread_ready(thread)) {
    bf70:	69a3      	ldr	r3, [r4, #24]
    bf72:	b913      	cbnz	r3, bf7a <z_impl_k_timer_stop+0x34>
		z_add_thread_to_ready_q(thread);
    bf74:	4620      	mov	r0, r4
    bf76:	f7fb fb13 	bl	75a0 <z_add_thread_to_ready_q>
	__asm__ volatile(
    bf7a:	f04f 0320 	mov.w	r3, #32
    bf7e:	f3ef 8011 	mrs	r0, BASEPRI
    bf82:	f383 8811 	msr	BASEPRI, r3
    bf86:	f3bf 8f6f 	isb	sy

	if (pending_thread != NULL) {
		z_ready_thread(pending_thread);
		z_reschedule_unlocked();
	}
}
    bf8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
    bf8e:	f7ff beb8 	b.w	bd02 <z_reschedule_irqlock>
    bf92:	bd10      	pop	{r4, pc}

0000bf94 <_OffsetAbsSyms>:
					    sizeof(struct _preempt_float));
#else
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF, sizeof(struct k_thread));
#endif

GEN_ABS_SYM_END
    bf94:	4770      	bx	lr
