
zephyr.elf:     file format elf32-littlearm


Disassembly of section text:

00000000 <_vector_table>:

	return fd_entry->obj;
}

int z_reserve_fd(void)
{
   0:	20005a28 	.word	0x20005a28
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&mutex, *(uintptr_t *)&timeout, K_SYSCALL_K_MUTEX_LOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_lock(mutex, timeout);
   4:	000013c1 	.word	0x000013c1
   8:	00008013 	.word	0x00008013
		if (fdtable[fd].obj == NULL) {
   c:	00001295 	.word	0x00001295
  10:	00001295 	.word	0x00001295
  14:	00001295 	.word	0x00001295
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
  18:	00001295 	.word	0x00001295
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
  1c:	00001295 	.word	0x00001295
	errno = ENFILE;
  20:	00001295 	.word	0x00001295
	return -1;
  24:	00001295 	.word	0x00001295
		arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_mutex_unlock(mutex);
  28:	00001295 	.word	0x00001295
  2c:	0000118d 	.word	0x0000118d
	}

	k_mutex_unlock(&fdtable_lock);

	return fd;
}
  30:	00001295 	.word	0x00001295
		fdtable[fd].obj = FD_OBJ_RESERVED;
  34:	00001295 	.word	0x00001295
  38:	00001139 	.word	0x00001139
  3c:	00008003 	.word	0x00008003

00000040 <_irq_vector_table>:
  40:	00001381 00001381 00001381 00001381     ................
		sys_pm_notify_power_state_exit(pm_state);
		_sys_pm_power_state_exit_post_ops(pm_state);
	}

	return pm_state;
}
  50:	00001381 00001381 00001381 00001381     ................
  60:	00001381 00001381 00001381 00001381     ................
  70:	00001381 00001381 00001381 00001381     ................
  80:	00001381 00001381 00001381 00001381     ................
  90:	00001381 00001381 00001381 00001381     ................
  a0:	00001381 00001381 00001381 00001381     ................
  b0:	00001381 00001381 00001381 00001381     ................
  c0:	00001381 00001381 00001381 00001381     ................
  d0:	00001381 00001381 00001381              ............

Disassembly of section _TEXT_SECTION_NAME_2:

000000dc <__aeabi_uldivmod>:
      dc:	b953      	cbnz	r3, f4 <CONFIG_LVGL_HOR_RES+0x4>
      de:	b94a      	cbnz	r2, f4 <CONFIG_LVGL_HOR_RES+0x4>
      e0:	2900      	cmp	r1, #0
      e2:	bf08      	it	eq
      e4:	2800      	cmpeq	r0, #0
      e6:	bf1c      	itt	ne
      e8:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
      ec:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
      f0:	f000 b80c 	b.w	10c <__aeabi_idiv0>
      f4:	f1ad 0c08 	sub.w	ip, sp, #8
      f8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
      fc:	f000 f808 	bl	110 <__udivmoddi4>
     100:	f8dd e004 	ldr.w	lr, [sp, #4]
     104:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     108:	b004      	add	sp, #16
     10a:	4770      	bx	lr

0000010c <__aeabi_idiv0>:
     10c:	4770      	bx	lr
     10e:	bf00      	nop

00000110 <__udivmoddi4>:
     110:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     114:	9f09      	ldr	r7, [sp, #36]	; 0x24
     116:	4615      	mov	r5, r2
     118:	4604      	mov	r4, r0
     11a:	468e      	mov	lr, r1
     11c:	461e      	mov	r6, r3
     11e:	2b00      	cmp	r3, #0
     120:	f040 80cc 	bne.w	2bc <CONFIG_FLASH_SIZE+0xbc>
     124:	428a      	cmp	r2, r1
     126:	fab2 fc82 	clz	ip, r2
     12a:	d94c      	bls.n	1c6 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x36>
     12c:	f1bc 0f00 	cmp.w	ip, #0
     130:	d00b      	beq.n	14a <CONFIG_IDLE_STACK_SIZE+0xa>
     132:	f1cc 0820 	rsb	r8, ip, #32
     136:	fa01 fe0c 	lsl.w	lr, r1, ip
     13a:	fa20 f808 	lsr.w	r8, r0, r8
     13e:	fa02 f50c 	lsl.w	r5, r2, ip
     142:	ea48 0e0e 	orr.w	lr, r8, lr
     146:	fa00 f40c 	lsl.w	r4, r0, ip
     14a:	ea4f 4915 	mov.w	r9, r5, lsr #16
     14e:	fa1f f885 	uxth.w	r8, r5
     152:	fbbe faf9 	udiv	sl, lr, r9
     156:	0c21      	lsrs	r1, r4, #16
     158:	fb09 e31a 	mls	r3, r9, sl, lr
     15c:	fb0a fb08 	mul.w	fp, sl, r8
     160:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
     164:	459b      	cmp	fp, r3
     166:	d92a      	bls.n	1be <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x2e>
     168:	18eb      	adds	r3, r5, r3
     16a:	f10a 30ff 	add.w	r0, sl, #4294967295	; 0xffffffff
     16e:	d204      	bcs.n	17a <CONFIG_IDLE_STACK_SIZE+0x3a>
     170:	459b      	cmp	fp, r3
     172:	d902      	bls.n	17a <CONFIG_IDLE_STACK_SIZE+0x3a>
     174:	f1aa 0002 	sub.w	r0, sl, #2
     178:	442b      	add	r3, r5
     17a:	eba3 030b 	sub.w	r3, r3, fp
     17e:	b2a4      	uxth	r4, r4
     180:	fbb3 f2f9 	udiv	r2, r3, r9
     184:	fb09 3312 	mls	r3, r9, r2, r3
     188:	fb02 f808 	mul.w	r8, r2, r8
     18c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     190:	45a0      	cmp	r8, r4
     192:	d916      	bls.n	1c2 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x32>
     194:	192c      	adds	r4, r5, r4
     196:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
     19a:	d203      	bcs.n	1a4 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x14>
     19c:	45a0      	cmp	r8, r4
     19e:	d901      	bls.n	1a4 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x14>
     1a0:	1e93      	subs	r3, r2, #2
     1a2:	442c      	add	r4, r5
     1a4:	eba4 0408 	sub.w	r4, r4, r8
     1a8:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
     1ac:	b127      	cbz	r7, 1b8 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x28>
     1ae:	fa24 f40c 	lsr.w	r4, r4, ip
     1b2:	2300      	movs	r3, #0
     1b4:	603c      	str	r4, [r7, #0]
     1b6:	607b      	str	r3, [r7, #4]
     1b8:	4631      	mov	r1, r6
     1ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     1be:	4650      	mov	r0, sl
     1c0:	e7db      	b.n	17a <CONFIG_IDLE_STACK_SIZE+0x3a>
     1c2:	4613      	mov	r3, r2
     1c4:	e7ee      	b.n	1a4 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x14>
     1c6:	b902      	cbnz	r2, 1ca <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x3a>
     1c8:	deff      	udf	#255	; 0xff
     1ca:	f1bc 0f00 	cmp.w	ip, #0
     1ce:	d12e      	bne.n	22e <CONFIG_FLASH_SIZE+0x2e>
     1d0:	1a8b      	subs	r3, r1, r2
     1d2:	2601      	movs	r6, #1
     1d4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
     1d8:	b2aa      	uxth	r2, r5
     1da:	fbb3 f8fe 	udiv	r8, r3, lr
     1de:	0c21      	lsrs	r1, r4, #16
     1e0:	fb0e 3318 	mls	r3, lr, r8, r3
     1e4:	fb08 f902 	mul.w	r9, r8, r2
     1e8:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
     1ec:	4599      	cmp	r9, r3
     1ee:	d961      	bls.n	2b4 <CONFIG_FLASH_SIZE+0xb4>
     1f0:	18eb      	adds	r3, r5, r3
     1f2:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
     1f6:	d204      	bcs.n	202 <CONFIG_FLASH_SIZE+0x2>
     1f8:	4599      	cmp	r9, r3
     1fa:	d902      	bls.n	202 <CONFIG_FLASH_SIZE+0x2>
     1fc:	f1a8 0002 	sub.w	r0, r8, #2
     200:	442b      	add	r3, r5
     202:	eba3 0309 	sub.w	r3, r3, r9
     206:	b2a4      	uxth	r4, r4
     208:	fbb3 f1fe 	udiv	r1, r3, lr
     20c:	fb0e 3311 	mls	r3, lr, r1, r3
     210:	434a      	muls	r2, r1
     212:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     216:	42a2      	cmp	r2, r4
     218:	d94e      	bls.n	2b8 <CONFIG_FLASH_SIZE+0xb8>
     21a:	192c      	adds	r4, r5, r4
     21c:	f101 33ff 	add.w	r3, r1, #4294967295	; 0xffffffff
     220:	d203      	bcs.n	22a <CONFIG_FLASH_SIZE+0x2a>
     222:	42a2      	cmp	r2, r4
     224:	d901      	bls.n	22a <CONFIG_FLASH_SIZE+0x2a>
     226:	1e8b      	subs	r3, r1, #2
     228:	442c      	add	r4, r5
     22a:	1aa4      	subs	r4, r4, r2
     22c:	e7bc      	b.n	1a8 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x18>
     22e:	f1cc 0e20 	rsb	lr, ip, #32
     232:	fa02 f50c 	lsl.w	r5, r2, ip
     236:	fa21 f90e 	lsr.w	r9, r1, lr
     23a:	fa01 f30c 	lsl.w	r3, r1, ip
     23e:	fa20 fe0e 	lsr.w	lr, r0, lr
     242:	ea4e 0303 	orr.w	r3, lr, r3
     246:	ea4f 4815 	mov.w	r8, r5, lsr #16
     24a:	fa00 f40c 	lsl.w	r4, r0, ip
     24e:	fbb9 f1f8 	udiv	r1, r9, r8
     252:	fa1f fe85 	uxth.w	lr, r5
     256:	fb08 9211 	mls	r2, r8, r1, r9
     25a:	0c18      	lsrs	r0, r3, #16
     25c:	fb01 f60e 	mul.w	r6, r1, lr
     260:	ea40 4202 	orr.w	r2, r0, r2, lsl #16
     264:	4296      	cmp	r6, r2
     266:	d921      	bls.n	2ac <CONFIG_FLASH_SIZE+0xac>
     268:	18aa      	adds	r2, r5, r2
     26a:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
     26e:	d203      	bcs.n	278 <CONFIG_FLASH_SIZE+0x78>
     270:	4296      	cmp	r6, r2
     272:	d901      	bls.n	278 <CONFIG_FLASH_SIZE+0x78>
     274:	1e88      	subs	r0, r1, #2
     276:	442a      	add	r2, r5
     278:	1b92      	subs	r2, r2, r6
     27a:	b29b      	uxth	r3, r3
     27c:	fbb2 f9f8 	udiv	r9, r2, r8
     280:	fb08 2219 	mls	r2, r8, r9, r2
     284:	fb09 fe0e 	mul.w	lr, r9, lr
     288:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
     28c:	459e      	cmp	lr, r3
     28e:	d90f      	bls.n	2b0 <CONFIG_FLASH_SIZE+0xb0>
     290:	18eb      	adds	r3, r5, r3
     292:	f109 36ff 	add.w	r6, r9, #4294967295	; 0xffffffff
     296:	d204      	bcs.n	2a2 <CONFIG_FLASH_SIZE+0xa2>
     298:	459e      	cmp	lr, r3
     29a:	d902      	bls.n	2a2 <CONFIG_FLASH_SIZE+0xa2>
     29c:	f1a9 0602 	sub.w	r6, r9, #2
     2a0:	442b      	add	r3, r5
     2a2:	eba3 030e 	sub.w	r3, r3, lr
     2a6:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     2aa:	e793      	b.n	1d4 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x44>
     2ac:	4608      	mov	r0, r1
     2ae:	e7e3      	b.n	278 <CONFIG_FLASH_SIZE+0x78>
     2b0:	464e      	mov	r6, r9
     2b2:	e7f6      	b.n	2a2 <CONFIG_FLASH_SIZE+0xa2>
     2b4:	4640      	mov	r0, r8
     2b6:	e7a4      	b.n	202 <CONFIG_FLASH_SIZE+0x2>
     2b8:	460b      	mov	r3, r1
     2ba:	e7b6      	b.n	22a <CONFIG_FLASH_SIZE+0x2a>
     2bc:	428b      	cmp	r3, r1
     2be:	d905      	bls.n	2cc <CONFIG_FLASH_SIZE+0xcc>
     2c0:	b10f      	cbz	r7, 2c6 <CONFIG_FLASH_SIZE+0xc6>
     2c2:	e9c7 0100 	strd	r0, r1, [r7]
     2c6:	2600      	movs	r6, #0
     2c8:	4630      	mov	r0, r6
     2ca:	e775      	b.n	1b8 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x28>
     2cc:	fab3 fc83 	clz	ip, r3
     2d0:	f1bc 0f00 	cmp.w	ip, #0
     2d4:	d10f      	bne.n	2f6 <CONFIG_FLASH_SIZE+0xf6>
     2d6:	428b      	cmp	r3, r1
     2d8:	d301      	bcc.n	2de <CONFIG_FLASH_SIZE+0xde>
     2da:	4282      	cmp	r2, r0
     2dc:	d809      	bhi.n	2f2 <CONFIG_FLASH_SIZE+0xf2>
     2de:	1a84      	subs	r4, r0, r2
     2e0:	eb61 0e03 	sbc.w	lr, r1, r3
     2e4:	2001      	movs	r0, #1
     2e6:	2f00      	cmp	r7, #0
     2e8:	d06a      	beq.n	3c0 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xc0>
     2ea:	e9c7 4e00 	strd	r4, lr, [r7]
     2ee:	2600      	movs	r6, #0
     2f0:	e762      	b.n	1b8 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x28>
     2f2:	4660      	mov	r0, ip
     2f4:	e7f7      	b.n	2e6 <CONFIG_FLASH_SIZE+0xe6>
     2f6:	f1cc 0e20 	rsb	lr, ip, #32
     2fa:	fa03 f30c 	lsl.w	r3, r3, ip
     2fe:	fa22 f50e 	lsr.w	r5, r2, lr
     302:	fa21 f40e 	lsr.w	r4, r1, lr
     306:	431d      	orrs	r5, r3
     308:	fa01 f30c 	lsl.w	r3, r1, ip
     30c:	fa20 f10e 	lsr.w	r1, r0, lr
     310:	430b      	orrs	r3, r1
     312:	ea4f 4a15 	mov.w	sl, r5, lsr #16
     316:	fa00 f60c 	lsl.w	r6, r0, ip
     31a:	fbb4 f9fa 	udiv	r9, r4, sl
     31e:	fa1f f885 	uxth.w	r8, r5
     322:	fb0a 4019 	mls	r0, sl, r9, r4
     326:	0c1c      	lsrs	r4, r3, #16
     328:	fb09 f108 	mul.w	r1, r9, r8
     32c:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
     330:	42a1      	cmp	r1, r4
     332:	fa02 f20c 	lsl.w	r2, r2, ip
     336:	d93f      	bls.n	3b8 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xb8>
     338:	192c      	adds	r4, r5, r4
     33a:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
     33e:	d204      	bcs.n	34a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x4a>
     340:	42a1      	cmp	r1, r4
     342:	d902      	bls.n	34a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x4a>
     344:	f1a9 0002 	sub.w	r0, r9, #2
     348:	442c      	add	r4, r5
     34a:	1a64      	subs	r4, r4, r1
     34c:	b29b      	uxth	r3, r3
     34e:	fbb4 f9fa 	udiv	r9, r4, sl
     352:	fb0a 4419 	mls	r4, sl, r9, r4
     356:	fb09 f808 	mul.w	r8, r9, r8
     35a:	ea43 4104 	orr.w	r1, r3, r4, lsl #16
     35e:	4588      	cmp	r8, r1
     360:	d92c      	bls.n	3bc <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xbc>
     362:	1869      	adds	r1, r5, r1
     364:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
     368:	d204      	bcs.n	374 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x74>
     36a:	4588      	cmp	r8, r1
     36c:	d902      	bls.n	374 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x74>
     36e:	f1a9 0302 	sub.w	r3, r9, #2
     372:	4429      	add	r1, r5
     374:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
     378:	eba1 0108 	sub.w	r1, r1, r8
     37c:	fba0 8902 	umull	r8, r9, r0, r2
     380:	4549      	cmp	r1, r9
     382:	46c2      	mov	sl, r8
     384:	464c      	mov	r4, r9
     386:	d302      	bcc.n	38e <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x8e>
     388:	d106      	bne.n	398 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x98>
     38a:	4546      	cmp	r6, r8
     38c:	d204      	bcs.n	398 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x98>
     38e:	ebb8 0a02 	subs.w	sl, r8, r2
     392:	eb69 0405 	sbc.w	r4, r9, r5
     396:	3801      	subs	r0, #1
     398:	b197      	cbz	r7, 3c0 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xc0>
     39a:	ebb6 030a 	subs.w	r3, r6, sl
     39e:	eb61 0604 	sbc.w	r6, r1, r4
     3a2:	fa06 fe0e 	lsl.w	lr, r6, lr
     3a6:	fa23 f30c 	lsr.w	r3, r3, ip
     3aa:	ea4e 0303 	orr.w	r3, lr, r3
     3ae:	fa26 f60c 	lsr.w	r6, r6, ip
     3b2:	e9c7 3600 	strd	r3, r6, [r7]
     3b6:	e79a      	b.n	2ee <CONFIG_FLASH_SIZE+0xee>
     3b8:	4648      	mov	r0, r9
     3ba:	e7c6      	b.n	34a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x4a>
     3bc:	464b      	mov	r3, r9
     3be:	e7d9      	b.n	374 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x74>
     3c0:	463e      	mov	r6, r7
     3c2:	e6f9      	b.n	1b8 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x28>

000003c4 <main>:
	//}
}


void main(void)
{
     3c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	MY_REGISTER1=0xcc;
     3c8:	f8df 8198 	ldr.w	r8, [pc, #408]	; 564 <CONFIG_LOG_BUFFER_SIZE+0x164>
	MY_REGISTER2=0xcc; //debugging
     3cc:	4e5b      	ldr	r6, [pc, #364]	; (53c <CONFIG_LOG_BUFFER_SIZE+0x13c>)
	MY_REGISTER1=0xcc;
     3ce:	23cc      	movs	r3, #204	; 0xcc
     3d0:	f888 3000 	strb.w	r3, [r8]
{
     3d4:	b08f      	sub	sp, #60	; 0x3c
	MY_REGISTER2=0xcc; //debugging
     3d6:	7033      	strb	r3, [r6, #0]
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
     3d8:	4859      	ldr	r0, [pc, #356]	; (540 <CONFIG_LOG_BUFFER_SIZE+0x140>)
     3da:	f006 f993 	bl	6704 <z_impl_device_get_binding>

	struct sensor_value touch[1];


	struct device *devtouch = device_get_binding(DT_INST_0_HYNITRON_CST816S_LABEL);
	if (devtouch == NULL) {
     3de:	4605      	mov	r5, r0
     3e0:	b948      	cbnz	r0, 3f6 <CONFIG_CST816S_ACTIVITY_THRESHOLD+0xe>
		MY_REGISTER1=0xe1;
     3e2:	23e1      	movs	r3, #225	; 0xe1
     3e4:	f888 3000 	strb.w	r3, [r8]
		printf("Could not get %s device\n", DT_INST_0_HYNITRON_CST816S_LABEL);
     3e8:	4955      	ldr	r1, [pc, #340]	; (540 <CONFIG_LOG_BUFFER_SIZE+0x140>)
     3ea:	4856      	ldr	r0, [pc, #344]	; (544 <CONFIG_LOG_BUFFER_SIZE+0x144>)
     3ec:	f002 f880 	bl	24f0 <printf>


		k_sleep(K_MSEC(100));

	}
}
     3f0:	b00f      	add	sp, #60	; 0x3c
     3f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	hello_world_label = lv_label_create(lv_scr_act(), NULL);
     3f6:	f007 f99d 	bl	7734 <lv_scr_act>
     3fa:	2100      	movs	r1, #0
     3fc:	f005 fe42 	bl	6084 <lv_label_create>
	char count_str[11] = {0};
     400:	2400      	movs	r4, #0
     402:	e9cd 4405 	strd	r4, r4, [sp, #20]
	char touch_strx[11] = {0};
     406:	e9cd 4408 	strd	r4, r4, [sp, #32]
	char touch_stry[11] = {0};
     40a:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
	hello_world_label = lv_label_create(lv_scr_act(), NULL);
     40e:	4681      	mov	r9, r0
	char count_str[11] = {0};
     410:	f8cd 401b 	str.w	r4, [sp, #27]
	char touch_strx[11] = {0};
     414:	f8cd 4027 	str.w	r4, [sp, #39]	; 0x27
	char touch_stry[11] = {0};
     418:	f8cd 4033 	str.w	r4, [sp, #51]	; 0x33
     41c:	484a      	ldr	r0, [pc, #296]	; (548 <CONFIG_LOG_BUFFER_SIZE+0x148>)
     41e:	f006 f971 	bl	6704 <z_impl_device_get_binding>
	if (display_dev == NULL) {
     422:	4607      	mov	r7, r0
     424:	b988      	cbnz	r0, 44a <CONFIG_LOG_BUFFER_SIZE+0x4a>
		LOG_ERR("device not found.  Aborting test.");
     426:	2301      	movs	r3, #1
     428:	f04f 0100 	mov.w	r1, #0
     42c:	f363 0107 	bfi	r1, r3, #0, #8
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
     430:	4a46      	ldr	r2, [pc, #280]	; (54c <CONFIG_LOG_BUFFER_SIZE+0x14c>)
     432:	4b47      	ldr	r3, [pc, #284]	; (550 <CONFIG_LOG_BUFFER_SIZE+0x150>)
     434:	4847      	ldr	r0, [pc, #284]	; (554 <CONFIG_LOG_BUFFER_SIZE+0x154>)
     436:	1a9b      	subs	r3, r3, r2
     438:	08db      	lsrs	r3, r3, #3
     43a:	f363 118f 	bfi	r1, r3, #6, #10
     43e:	f007 fb88 	bl	7b52 <log_0>
		MY_REGISTER1=0xEE;
     442:	23ee      	movs	r3, #238	; 0xee
     444:	f888 3000 	strb.w	r3, [r8]
		return;
     448:	e7d2      	b.n	3f0 <CONFIG_CST816S_ACTIVITY_THRESHOLD+0x8>
     44a:	4843      	ldr	r0, [pc, #268]	; (558 <CONFIG_LOG_BUFFER_SIZE+0x158>)
     44c:	f006 f95a 	bl	6704 <z_impl_device_get_binding>
     450:	4680      	mov	r8, r0
				    u32_t pin, int flags)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	return api->config(port, access_op, pin, flags);
     452:	6843      	ldr	r3, [r0, #4]
     454:	2216      	movs	r2, #22
     456:	f8d3 a000 	ldr.w	sl, [r3]
     45a:	4621      	mov	r1, r4
     45c:	2301      	movs	r3, #1
     45e:	47d0      	blx	sl
				   u32_t pin, u32_t value)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	return api->write(port, access_op, pin, value);
     460:	f8d8 3004 	ldr.w	r3, [r8, #4]
		sprintf(count_str, "%d", count);
     464:	f8df b100 	ldr.w	fp, [pc, #256]	; 568 <CONFIG_LOG_BUFFER_SIZE+0x168>
     468:	f8d3 a004 	ldr.w	sl, [r3, #4]
     46c:	2216      	movs	r2, #22
     46e:	4623      	mov	r3, r4
     470:	4621      	mov	r1, r4
     472:	4640      	mov	r0, r8
     474:	47d0      	blx	sl
	lv_obj_align(hello_world_label, NULL, LV_ALIGN_CENTER, 0, 0);
     476:	4623      	mov	r3, r4
     478:	4622      	mov	r2, r4
     47a:	4621      	mov	r1, r4
     47c:	4648      	mov	r0, r9
     47e:	9400      	str	r4, [sp, #0]
     480:	f008 fc36 	bl	8cf0 <lv_obj_align>
	count_label = lv_label_create(lv_scr_act(), NULL);
     484:	f007 f956 	bl	7734 <lv_scr_act>
     488:	4621      	mov	r1, r4
     48a:	f005 fdfb 	bl	6084 <lv_label_create>
	lv_obj_align(count_label, NULL, LV_ALIGN_IN_BOTTOM_MID, 0, 0);
     48e:	4623      	mov	r3, r4
     490:	2205      	movs	r2, #5
     492:	4621      	mov	r1, r4
     494:	9400      	str	r4, [sp, #0]
	count_label = lv_label_create(lv_scr_act(), NULL);
     496:	4682      	mov	sl, r0
	lv_obj_align(count_label, NULL, LV_ALIGN_IN_BOTTOM_MID, 0, 0);
     498:	f008 fc2a 	bl	8cf0 <lv_obj_align>
	touch_labelx = lv_label_create(lv_scr_act(), NULL);
     49c:	f007 f94a 	bl	7734 <lv_scr_act>
     4a0:	4621      	mov	r1, r4
     4a2:	f005 fdef 	bl	6084 <lv_label_create>
	lv_obj_align(touch_labelx, NULL, LV_ALIGN_IN_TOP_MID, 0, 0);
     4a6:	4623      	mov	r3, r4
     4a8:	2202      	movs	r2, #2
     4aa:	4621      	mov	r1, r4
     4ac:	9400      	str	r4, [sp, #0]
	touch_labelx = lv_label_create(lv_scr_act(), NULL);
     4ae:	4680      	mov	r8, r0
	lv_obj_align(touch_labelx, NULL, LV_ALIGN_IN_TOP_MID, 0, 0);
     4b0:	f008 fc1e 	bl	8cf0 <lv_obj_align>
	touch_labely = lv_label_create(lv_scr_act(), NULL);
     4b4:	f007 f93e 	bl	7734 <lv_scr_act>
     4b8:	4621      	mov	r1, r4
     4ba:	f005 fde3 	bl	6084 <lv_label_create>
	lv_obj_align(touch_labely, NULL, LV_ALIGN_IN_TOP_MID, 0, 25);
     4be:	2319      	movs	r3, #25
     4c0:	9300      	str	r3, [sp, #0]
     4c2:	2202      	movs	r2, #2
     4c4:	4623      	mov	r3, r4
     4c6:	4621      	mov	r1, r4
	touch_labely = lv_label_create(lv_scr_act(), NULL);
     4c8:	4681      	mov	r9, r0
	lv_obj_align(touch_labely, NULL, LV_ALIGN_IN_TOP_MID, 0, 25);
     4ca:	f008 fc11 	bl	8cf0 <lv_obj_align>
static inline int display_blanking_off(const struct device *dev)
{
	struct display_driver_api *api =
		(struct display_driver_api *)dev->driver_api;

	return api->blanking_off(dev);
     4ce:	687b      	ldr	r3, [r7, #4]
     4d0:	4638      	mov	r0, r7
     4d2:	685b      	ldr	r3, [r3, #4]
		sprintf(touch_stry, "Y: %d", touch[0].val1);
     4d4:	4f21      	ldr	r7, [pc, #132]	; (55c <CONFIG_LOG_BUFFER_SIZE+0x15c>)
     4d6:	4798      	blx	r3
		count++;
     4d8:	3401      	adds	r4, #1
		if (count > 200) count=0;
     4da:	2cc9      	cmp	r4, #201	; 0xc9
     4dc:	bf28      	it	cs
     4de:	2400      	movcs	r4, #0
		MY_REGISTER2=count;
     4e0:	b2e3      	uxtb	r3, r4
     4e2:	7033      	strb	r3, [r6, #0]
		sprintf(count_str, "%d", count);
     4e4:	4622      	mov	r2, r4
     4e6:	4659      	mov	r1, fp
     4e8:	a805      	add	r0, sp, #20
     4ea:	f001 ffe9 	bl	24c0 <sprintf>
		lv_label_set_text(count_label, count_str);  //this is just a counter that keeps track on number of executions
     4ee:	a905      	add	r1, sp, #20
     4f0:	4650      	mov	r0, sl
     4f2:	f00a facb 	bl	aa8c <lv_label_set_text>
		lv_task_handler();
     4f6:	f005 f8af 	bl	5658 <lv_task_handler>
static inline int z_impl_sensor_sample_fetch(struct device *dev)
{
	const struct sensor_driver_api *api =
		(const struct sensor_driver_api *)dev->driver_api;

	return api->sample_fetch(dev, SENSOR_CHAN_ALL);
     4fa:	686b      	ldr	r3, [r5, #4]
     4fc:	2125      	movs	r1, #37	; 0x25
     4fe:	689b      	ldr	r3, [r3, #8]
     500:	4628      	mov	r0, r5
     502:	4798      	blx	r3
					   struct sensor_value *val)
{
	const struct sensor_driver_api *api =
		(const struct sensor_driver_api *)dev->driver_api;

	return api->channel_get(dev, chan, val);
     504:	686b      	ldr	r3, [r5, #4]
     506:	aa03      	add	r2, sp, #12
     508:	68db      	ldr	r3, [r3, #12]
     50a:	2103      	movs	r1, #3
     50c:	4628      	mov	r0, r5
     50e:	4798      	blx	r3
		sprintf(touch_strx, "X: %d", touch[0].val2);
     510:	9a04      	ldr	r2, [sp, #16]
     512:	4913      	ldr	r1, [pc, #76]	; (560 <CONFIG_LOG_BUFFER_SIZE+0x160>)
     514:	a808      	add	r0, sp, #32
     516:	f001 ffd3 	bl	24c0 <sprintf>
		lv_label_set_text(touch_labelx, touch_strx);
     51a:	a908      	add	r1, sp, #32
     51c:	4640      	mov	r0, r8
     51e:	f00a fab5 	bl	aa8c <lv_label_set_text>
		sprintf(touch_stry, "Y: %d", touch[0].val1);
     522:	9a03      	ldr	r2, [sp, #12]
     524:	4639      	mov	r1, r7
     526:	a80b      	add	r0, sp, #44	; 0x2c
     528:	f001 ffca 	bl	24c0 <sprintf>
		lv_label_set_text(touch_labely, touch_stry);
     52c:	a90b      	add	r1, sp, #44	; 0x2c
     52e:	4648      	mov	r0, r9
     530:	f00a faac 	bl	aa8c <lv_label_set_text>
	return z_impl_k_sleep(ms);
     534:	2064      	movs	r0, #100	; 0x64
     536:	f006 fe5d 	bl	71f4 <z_impl_k_sleep>
     53a:	e7cd      	b.n	4d8 <CONFIG_LOG_BUFFER_SIZE+0xd8>
     53c:	2000f001 	.word	0x2000f001
     540:	0000b89e 	.word	0x0000b89e
     544:	0000b8a6 	.word	0x0000b8a6
     548:	0000b8bf 	.word	0x0000b8bf
     54c:	0000b17c 	.word	0x0000b17c
     550:	0000b184 	.word	0x0000b184
     554:	0000b8c7 	.word	0x0000b8c7
     558:	0000b8e9 	.word	0x0000b8e9
     55c:	0000b8f6 	.word	0x0000b8f6
     560:	0000b8f0 	.word	0x0000b8f0
     564:	2000f000 	.word	0x2000f000
     568:	0000b8f3 	.word	0x0000b8f3

0000056c <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
     56c:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
     56e:	2200      	movs	r2, #0
{
     570:	b087      	sub	sp, #28
		k_timer_init(&log_process_thread_timer,
     572:	490d      	ldr	r1, [pc, #52]	; (5a8 <enable_logger+0x3c>)
     574:	480d      	ldr	r0, [pc, #52]	; (5ac <enable_logger+0x40>)
     576:	f00a fcde 	bl	af36 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
     57a:	4d0d      	ldr	r5, [pc, #52]	; (5b0 <enable_logger+0x44>)
     57c:	490d      	ldr	r1, [pc, #52]	; (5b4 <enable_logger+0x48>)
     57e:	2400      	movs	r4, #0
     580:	230e      	movs	r3, #14
     582:	e9cd 4302 	strd	r4, r3, [sp, #8]
     586:	e9cd 4404 	strd	r4, r4, [sp, #16]
     58a:	e9cd 4400 	strd	r4, r4, [sp]
     58e:	4b0a      	ldr	r3, [pc, #40]	; (5b8 <enable_logger+0x4c>)
     590:	f44f 7240 	mov.w	r2, #768	; 0x300
     594:	4628      	mov	r0, r5
     596:	f006 fee1 	bl	735c <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
     59a:	4908      	ldr	r1, [pc, #32]	; (5bc <enable_logger+0x50>)
     59c:	4628      	mov	r0, r5
     59e:	f00a fc64 	bl	ae6a <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
     5a2:	4620      	mov	r0, r4
     5a4:	b007      	add	sp, #28
     5a6:	bd30      	pop	{r4, r5, pc}
     5a8:	000005c1 	.word	0x000005c1
     5ac:	2000001c 	.word	0x2000001c
     5b0:	20000064 	.word	0x20000064
     5b4:	20005328 	.word	0x20005328
     5b8:	00000995 	.word	0x00000995
     5bc:	0000b900 	.word	0x0000b900

000005c0 <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
     5c0:	4801      	ldr	r0, [pc, #4]	; (5c8 <log_process_thread_timer_expiry_fn+0x8>)
     5c2:	f006 be45 	b.w	7250 <z_impl_k_sem_give>
     5c6:	bf00      	nop
     5c8:	200069fc 	.word	0x200069fc

000005cc <log_core_init>:
{
     5cc:	b508      	push	{r3, lr}
		log_msg_pool_init();
     5ce:	f000 fa41 	bl	a54 <log_msg_pool_init>
		log_list_init(&list);
     5d2:	4809      	ldr	r0, [pc, #36]	; (5f8 <log_core_init+0x2c>)
     5d4:	f007 fa7a 	bl	7acc <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
     5d8:	2304      	movs	r3, #4
     5da:	2228      	movs	r2, #40	; 0x28
     5dc:	4807      	ldr	r0, [pc, #28]	; (5fc <log_core_init+0x30>)
     5de:	4908      	ldr	r1, [pc, #32]	; (600 <log_core_init+0x34>)
     5e0:	f00a fb2b 	bl	ac3a <k_mem_slab_init>
		timestamp_func = k_cycle_get_32_wrapper;
     5e4:	4b07      	ldr	r3, [pc, #28]	; (604 <log_core_init+0x38>)
     5e6:	4a08      	ldr	r2, [pc, #32]	; (608 <log_core_init+0x3c>)
     5e8:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
     5ea:	f44f 4000 	mov.w	r0, #32768	; 0x8000
}
     5ee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	log_output_timestamp_freq_set(freq);
     5f2:	f000 baa5 	b.w	b40 <log_output_timestamp_freq_set>
     5f6:	bf00      	nop
     5f8:	20000014 	.word	0x20000014
     5fc:	20000048 	.word	0x20000048
     600:	20006368 	.word	0x20006368
     604:	20006808 	.word	0x20006808
     608:	00007b0b 	.word	0x00007b0b

0000060c <dropped_notify>:
{
     60c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
     60e:	4b0f      	ldr	r3, [pc, #60]	; (64c <dropped_notify+0x40>)
     610:	f3bf 8f5b 	dmb	ish
     614:	2500      	movs	r5, #0
     616:	e853 7f00 	ldrex	r7, [r3]
     61a:	e843 5200 	strex	r2, r5, [r3]
     61e:	2a00      	cmp	r2, #0
     620:	d1f9      	bne.n	616 <dropped_notify+0xa>
     622:	f3bf 8f5b 	dmb	ish
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
     626:	4c0a      	ldr	r4, [pc, #40]	; (650 <dropped_notify+0x44>)
     628:	4e0a      	ldr	r6, [pc, #40]	; (654 <dropped_notify+0x48>)
     62a:	1b36      	subs	r6, r6, r4
     62c:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
     62e:	42b5      	cmp	r5, r6
     630:	db00      	blt.n	634 <dropped_notify+0x28>
}
     632:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
     634:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
     636:	795b      	ldrb	r3, [r3, #5]
     638:	b12b      	cbz	r3, 646 <dropped_notify+0x3a>
	if (backend->api->dropped != NULL) {
     63a:	6823      	ldr	r3, [r4, #0]
     63c:	68db      	ldr	r3, [r3, #12]
     63e:	b113      	cbz	r3, 646 <dropped_notify+0x3a>
		backend->api->dropped(backend, cnt);
     640:	4639      	mov	r1, r7
     642:	4620      	mov	r0, r4
     644:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
     646:	3501      	adds	r5, #1
     648:	3410      	adds	r4, #16
     64a:	e7f0      	b.n	62e <dropped_notify+0x22>
     64c:	2000000c 	.word	0x2000000c
     650:	0000b1dc 	.word	0x0000b1dc
     654:	0000b1dc 	.word	0x0000b1dc

00000658 <log_dropped>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
     658:	4b06      	ldr	r3, [pc, #24]	; (674 <log_dropped+0x1c>)
     65a:	f3bf 8f5b 	dmb	ish
     65e:	e853 2f00 	ldrex	r2, [r3]
     662:	3201      	adds	r2, #1
     664:	e843 2100 	strex	r1, r2, [r3]
     668:	2900      	cmp	r1, #0
     66a:	d1f8      	bne.n	65e <log_dropped+0x6>
     66c:	f3bf 8f5b 	dmb	ish
}
     670:	4770      	bx	lr
     672:	bf00      	nop
     674:	2000000c 	.word	0x2000000c

00000678 <log_backend_enable>:
	id += backend - log_backend_get(0);
     678:	4b09      	ldr	r3, [pc, #36]	; (6a0 <log_backend_enable+0x28>)
	log_backend_id_set(backend, id);
     67a:	6842      	ldr	r2, [r0, #4]
	id += backend - log_backend_get(0);
     67c:	1ac3      	subs	r3, r0, r3
     67e:	111b      	asrs	r3, r3, #4
     680:	3301      	adds	r3, #1
{
     682:	b510      	push	{r4, lr}
	log_backend_id_set(backend, id);
     684:	7113      	strb	r3, [r2, #4]
	log_backend_activate(backend, ctx);
     686:	6843      	ldr	r3, [r0, #4]
	if (!backend_attached) {
     688:	4c06      	ldr	r4, [pc, #24]	; (6a4 <log_backend_enable+0x2c>)
	backend->cb->ctx = ctx;
     68a:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
     68c:	2201      	movs	r2, #1
     68e:	715a      	strb	r2, [r3, #5]
     690:	7822      	ldrb	r2, [r4, #0]
     692:	b912      	cbnz	r2, 69a <log_backend_enable+0x22>
     694:	4804      	ldr	r0, [pc, #16]	; (6a8 <log_backend_enable+0x30>)
     696:	f006 fddb 	bl	7250 <z_impl_k_sem_give>
	backend_attached = true;
     69a:	2301      	movs	r3, #1
     69c:	7023      	strb	r3, [r4, #0]
}
     69e:	bd10      	pop	{r4, pc}
     6a0:	0000b1dc 	.word	0x0000b1dc
     6a4:	20000f96 	.word	0x20000f96
     6a8:	200069fc 	.word	0x200069fc

000006ac <log_init>:
{
     6ac:	b570      	push	{r4, r5, r6, lr}
     6ae:	4b11      	ldr	r3, [pc, #68]	; (6f4 <log_init+0x48>)
     6b0:	f3bf 8f5b 	dmb	ish
     6b4:	e853 5f00 	ldrex	r5, [r3]
     6b8:	1c6a      	adds	r2, r5, #1
     6ba:	e843 2100 	strex	r1, r2, [r3]
     6be:	2900      	cmp	r1, #0
     6c0:	d1f8      	bne.n	6b4 <log_init+0x8>
     6c2:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&initialized) != 0) {
     6c6:	b92d      	cbnz	r5, 6d4 <log_init+0x28>
	return __log_backends_end - __log_backends_start;
     6c8:	4c0b      	ldr	r4, [pc, #44]	; (6f8 <log_init+0x4c>)
     6ca:	4e0c      	ldr	r6, [pc, #48]	; (6fc <log_init+0x50>)
     6cc:	1b36      	subs	r6, r6, r4
     6ce:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
     6d0:	42b5      	cmp	r5, r6
     6d2:	db00      	blt.n	6d6 <log_init+0x2a>
}
     6d4:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
     6d6:	7b23      	ldrb	r3, [r4, #12]
     6d8:	b143      	cbz	r3, 6ec <log_init+0x40>
			if (backend->api->init != NULL) {
     6da:	6823      	ldr	r3, [r4, #0]
     6dc:	695b      	ldr	r3, [r3, #20]
     6de:	b103      	cbz	r3, 6e2 <log_init+0x36>
				backend->api->init();
     6e0:	4798      	blx	r3
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
     6e2:	2204      	movs	r2, #4
     6e4:	2100      	movs	r1, #0
     6e6:	4620      	mov	r0, r4
     6e8:	f7ff ffc6 	bl	678 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
     6ec:	3501      	adds	r5, #1
     6ee:	3410      	adds	r4, #16
     6f0:	e7ee      	b.n	6d0 <log_init+0x24>
     6f2:	bf00      	nop
     6f4:	20000010 	.word	0x20000010
     6f8:	0000b1dc 	.word	0x0000b1dc
     6fc:	0000b1dc 	.word	0x0000b1dc

00000700 <log_strdup>:
	return (((const char *)addr >= (const char *)RO_START) &&
     700:	4b16      	ldr	r3, [pc, #88]	; (75c <log_strdup+0x5c>)
     702:	4298      	cmp	r0, r3
{
     704:	b537      	push	{r0, r1, r2, r4, r5, lr}
     706:	4604      	mov	r4, r0
	return (((const char *)addr >= (const char *)RO_START) &&
     708:	d302      	bcc.n	710 <log_strdup+0x10>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
     70a:	4b15      	ldr	r3, [pc, #84]	; (760 <log_strdup+0x60>)
     70c:	4298      	cmp	r0, r3
     70e:	d31f      	bcc.n	750 <log_strdup+0x50>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
     710:	2200      	movs	r2, #0
     712:	a901      	add	r1, sp, #4
     714:	4813      	ldr	r0, [pc, #76]	; (764 <log_strdup+0x64>)
     716:	f006 f995 	bl	6a44 <k_mem_slab_alloc>
	if (err != 0) {
     71a:	4605      	mov	r5, r0
     71c:	b9d8      	cbnz	r0, 756 <log_strdup+0x56>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
     71e:	2201      	movs	r2, #1
     720:	9b01      	ldr	r3, [sp, #4]
     722:	f3bf 8f5b 	dmb	ish
     726:	e853 1f00 	ldrex	r1, [r3]
     72a:	e843 2000 	strex	r0, r2, [r3]
     72e:	2800      	cmp	r0, #0
     730:	d1f9      	bne.n	726 <log_strdup+0x26>
     732:	f3bf 8f5b 	dmb	ish
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
     736:	9801      	ldr	r0, [sp, #4]
     738:	4621      	mov	r1, r4
     73a:	221f      	movs	r2, #31
     73c:	3004      	adds	r0, #4
     73e:	f007 fc81 	bl	8044 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
     742:	9c01      	ldr	r4, [sp, #4]
     744:	237e      	movs	r3, #126	; 0x7e
     746:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
     74a:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
	return dup->buf;
     74e:	3404      	adds	r4, #4
}
     750:	4620      	mov	r0, r4
     752:	b003      	add	sp, #12
     754:	bd30      	pop	{r4, r5, pc}
		return (char *)log_strdup_fail_msg;
     756:	4c04      	ldr	r4, [pc, #16]	; (768 <log_strdup+0x68>)
     758:	e7fa      	b.n	750 <log_strdup+0x50>
     75a:	bf00      	nop
     75c:	0000afa8 	.word	0x0000afa8
     760:	000118ac 	.word	0x000118ac
     764:	20000048 	.word	0x20000048
     768:	0000b908 	.word	0x0000b908

0000076c <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (u8_t *)buf);
     76c:	b148      	cbz	r0, 782 <log_is_strdup+0x16>
     76e:	4b05      	ldr	r3, [pc, #20]	; (784 <log_is_strdup+0x18>)
     770:	4298      	cmp	r0, r3
     772:	d305      	bcc.n	780 <log_is_strdup+0x14>
     774:	33a0      	adds	r3, #160	; 0xa0
     776:	4298      	cmp	r0, r3
     778:	bf2c      	ite	cs
     77a:	2000      	movcs	r0, #0
     77c:	2001      	movcc	r0, #1
     77e:	4770      	bx	lr
     780:	2000      	movs	r0, #0
}
     782:	4770      	bx	lr
     784:	20006368 	.word	0x20006368

00000788 <z_impl_log_process>:
{
     788:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!backend_attached && !bypass) {
     78c:	4b46      	ldr	r3, [pc, #280]	; (8a8 <CONFIG_ISR_STACK_SIZE+0xa8>)
     78e:	781b      	ldrb	r3, [r3, #0]
{
     790:	4605      	mov	r5, r0
	if (!backend_attached && !bypass) {
     792:	b903      	cbnz	r3, 796 <z_impl_log_process+0xe>
     794:	b360      	cbz	r0, 7f0 <z_impl_log_process+0x68>
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
     796:	f04f 0320 	mov.w	r3, #32
     79a:	f3ef 8611 	mrs	r6, BASEPRI
     79e:	f383 8811 	msr	BASEPRI, r3
     7a2:	f3bf 8f6f 	isb	sy
	msg = log_list_head_get(&list);
     7a6:	4841      	ldr	r0, [pc, #260]	; (8ac <CONFIG_ISR_STACK_SIZE+0xac>)
     7a8:	f007 f9a0 	bl	7aec <log_list_head_get>
     7ac:	4604      	mov	r4, r0
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
     7ae:	f386 8811 	msr	BASEPRI, r6
     7b2:	f3bf 8f6f 	isb	sy
	if (msg != NULL) {
     7b6:	b178      	cbz	r0, 7d8 <z_impl_log_process+0x50>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
     7b8:	f3bf 8f5b 	dmb	ish
     7bc:	4b3c      	ldr	r3, [pc, #240]	; (8b0 <CONFIG_ISR_STACK_SIZE+0xb0>)
     7be:	e853 2f00 	ldrex	r2, [r3]
     7c2:	3a01      	subs	r2, #1
     7c4:	e843 2100 	strex	r1, r2, [r3]
     7c8:	2900      	cmp	r1, #0
     7ca:	d1f8      	bne.n	7be <z_impl_log_process+0x36>
     7cc:	f3bf 8f5b 	dmb	ish
	if (!bypass) {
     7d0:	b18d      	cbz	r5, 7f6 <z_impl_log_process+0x6e>
	log_msg_put(msg);
     7d2:	4620      	mov	r0, r4
     7d4:	f007 fa31 	bl	7c3a <log_msg_put>
	if (!bypass && dropped_cnt) {
     7d8:	b925      	cbnz	r5, 7e4 <z_impl_log_process+0x5c>
     7da:	4b36      	ldr	r3, [pc, #216]	; (8b4 <CONFIG_ISR_STACK_SIZE+0xb4>)
     7dc:	681b      	ldr	r3, [r3, #0]
     7de:	b10b      	cbz	r3, 7e4 <z_impl_log_process+0x5c>
		dropped_notify();
     7e0:	f7ff ff14 	bl	60c <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
     7e4:	4831      	ldr	r0, [pc, #196]	; (8ac <CONFIG_ISR_STACK_SIZE+0xac>)
     7e6:	f007 f97f 	bl	7ae8 <log_list_head_peek>
     7ea:	1c05      	adds	r5, r0, #0
     7ec:	bf18      	it	ne
     7ee:	2501      	movne	r5, #1
}
     7f0:	4628      	mov	r0, r5
     7f2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    !panic_mode) {
     7f6:	4b30      	ldr	r3, [pc, #192]	; (8b8 <CONFIG_ISR_STACK_SIZE+0xb8>)
		if (IS_ENABLED(CONFIG_LOG_DETECT_MISSED_STRDUP) &&
     7f8:	781b      	ldrb	r3, [r3, #0]
     7fa:	b9ab      	cbnz	r3, 828 <CONFIG_ISR_STACK_SIZE+0x28>
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
     7fc:	7a23      	ldrb	r3, [r4, #8]
	if (!log_msg_is_std(msg)) {
     7fe:	07db      	lsls	r3, r3, #31
     800:	d412      	bmi.n	828 <CONFIG_ISR_STACK_SIZE+0x28>
	msg_str = log_msg_str_get(msg);
     802:	f007 fa2d 	bl	7c60 <log_msg_str_get>
     806:	4681      	mov	r9, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
     808:	4620      	mov	r0, r4
     80a:	f007 f9f6 	bl	7bfa <log_msg_nargs_get>
     80e:	4601      	mov	r1, r0
     810:	4648      	mov	r0, r9
     812:	f007 f97e 	bl	7b12 <z_log_get_s_mask>
     816:	4b29      	ldr	r3, [pc, #164]	; (8bc <CONFIG_ISR_STACK_SIZE+0xbc>)
				LOG_ERR(ERR_MSG, idx, msg_str);
     818:	4a29      	ldr	r2, [pc, #164]	; (8c0 <CONFIG_ISR_STACK_SIZE+0xc0>)
     81a:	f8df b0bc 	ldr.w	fp, [pc, #188]	; 8d8 <CONFIG_ISR_STACK_SIZE+0xd8>
     81e:	1a9b      	subs	r3, r3, r2
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
     820:	4607      	mov	r7, r0
				LOG_ERR(ERR_MSG, idx, msg_str);
     822:	f3c3 0ac9 	ubfx	sl, r3, #3, #10
	while (mask) {
     826:	b937      	cbnz	r7, 836 <CONFIG_ISR_STACK_SIZE+0x36>
     828:	4e26      	ldr	r6, [pc, #152]	; (8c4 <CONFIG_ISR_STACK_SIZE+0xc4>)
     82a:	4f27      	ldr	r7, [pc, #156]	; (8c8 <CONFIG_ISR_STACK_SIZE+0xc8>)
     82c:	1bbf      	subs	r7, r7, r6
     82e:	113f      	asrs	r7, r7, #4
     830:	f04f 0800 	mov.w	r8, #0
     834:	e034      	b.n	8a0 <CONFIG_ISR_STACK_SIZE+0xa0>
		idx = 31 - __builtin_clz(mask);
     836:	fab7 f687 	clz	r6, r7
     83a:	f1c6 061f 	rsb	r6, r6, #31
		str = (const char *)log_msg_arg_get(msg, idx);
     83e:	4631      	mov	r1, r6
     840:	4620      	mov	r0, r4
     842:	f007 f9dd 	bl	7c00 <log_msg_arg_get>
	return (((const char *)addr >= (const char *)RO_START) &&
     846:	4b21      	ldr	r3, [pc, #132]	; (8cc <CONFIG_ISR_STACK_SIZE+0xcc>)
     848:	4298      	cmp	r0, r3
		str = (const char *)log_msg_arg_get(msg, idx);
     84a:	4602      	mov	r2, r0
	return (((const char *)addr >= (const char *)RO_START) &&
     84c:	d302      	bcc.n	854 <CONFIG_ISR_STACK_SIZE+0x54>
		if (!is_rodata(str) && !log_is_strdup(str) &&
     84e:	4b20      	ldr	r3, [pc, #128]	; (8d0 <CONFIG_ISR_STACK_SIZE+0xd0>)
     850:	4298      	cmp	r0, r3
     852:	d314      	bcc.n	87e <CONFIG_ISR_STACK_SIZE+0x7e>
     854:	4610      	mov	r0, r2
     856:	f7ff ff89 	bl	76c <log_is_strdup>
     85a:	b980      	cbnz	r0, 87e <CONFIG_ISR_STACK_SIZE+0x7e>
     85c:	4b1d      	ldr	r3, [pc, #116]	; (8d4 <CONFIG_ISR_STACK_SIZE+0xd4>)
     85e:	429a      	cmp	r2, r3
     860:	d00d      	beq.n	87e <CONFIG_ISR_STACK_SIZE+0x7e>
				LOG_ERR(ERR_MSG, idx, msg_str);
     862:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
     866:	f043 0301 	orr.w	r3, r3, #1
     86a:	f363 0807 	bfi	r8, r3, #0, #8
     86e:	f36a 188f 	bfi	r8, sl, #6, #10
     872:	4643      	mov	r3, r8
     874:	464a      	mov	r2, r9
     876:	4631      	mov	r1, r6
     878:	4658      	mov	r0, fp
     87a:	f007 f98b 	bl	7b94 <log_2>
		mask &= ~BIT(idx);
     87e:	2301      	movs	r3, #1
     880:	fa03 f606 	lsl.w	r6, r3, r6
     884:	ea27 0706 	bic.w	r7, r7, r6
     888:	e7cd      	b.n	826 <CONFIG_ISR_STACK_SIZE+0x26>
	return backend->cb->active;
     88a:	6873      	ldr	r3, [r6, #4]
			if (log_backend_is_active(backend) &&
     88c:	795b      	ldrb	r3, [r3, #5]
     88e:	b123      	cbz	r3, 89a <CONFIG_ISR_STACK_SIZE+0x9a>
	backend->api->put(backend, msg);
     890:	6833      	ldr	r3, [r6, #0]
     892:	4621      	mov	r1, r4
     894:	681b      	ldr	r3, [r3, #0]
     896:	4630      	mov	r0, r6
     898:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
     89a:	f108 0801 	add.w	r8, r8, #1
     89e:	3610      	adds	r6, #16
     8a0:	45b8      	cmp	r8, r7
     8a2:	dbf2      	blt.n	88a <CONFIG_ISR_STACK_SIZE+0x8a>
     8a4:	e795      	b.n	7d2 <z_impl_log_process+0x4a>
     8a6:	bf00      	nop
     8a8:	20000f96 	.word	0x20000f96
     8ac:	20000014 	.word	0x20000014
     8b0:	20000008 	.word	0x20000008
     8b4:	2000000c 	.word	0x2000000c
     8b8:	20000f97 	.word	0x20000f97
     8bc:	0000b1a4 	.word	0x0000b1a4
     8c0:	0000b17c 	.word	0x0000b17c
     8c4:	0000b1dc 	.word	0x0000b1dc
     8c8:	0000b1dc 	.word	0x0000b1dc
     8cc:	0000afa8 	.word	0x0000afa8
     8d0:	000118ac 	.word	0x000118ac
     8d4:	0000b908 	.word	0x0000b908
     8d8:	0000b926 	.word	0x0000b926

000008dc <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
     8dc:	4b26      	ldr	r3, [pc, #152]	; (978 <msg_finalize+0x9c>)
{
     8de:	b570      	push	{r4, r5, r6, lr}
	msg->hdr.timestamp = timestamp_func();
     8e0:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
     8e2:	8141      	strh	r1, [r0, #10]
{
     8e4:	4605      	mov	r5, r0
	msg->hdr.timestamp = timestamp_func();
     8e6:	4798      	blx	r3
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
     8e8:	4c24      	ldr	r4, [pc, #144]	; (97c <msg_finalize+0xa0>)
     8ea:	60e8      	str	r0, [r5, #12]
     8ec:	f3bf 8f5b 	dmb	ish
     8f0:	e854 3f00 	ldrex	r3, [r4]
     8f4:	3301      	adds	r3, #1
     8f6:	e844 3200 	strex	r2, r3, [r4]
     8fa:	2a00      	cmp	r2, #0
     8fc:	d1f8      	bne.n	8f0 <msg_finalize+0x14>
     8fe:	f3bf 8f5b 	dmb	ish
	__asm__ volatile(
     902:	f04f 0320 	mov.w	r3, #32
     906:	f3ef 8611 	mrs	r6, BASEPRI
     90a:	f383 8811 	msr	BASEPRI, r3
     90e:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
     912:	481b      	ldr	r0, [pc, #108]	; (980 <msg_finalize+0xa4>)
     914:	4629      	mov	r1, r5
     916:	f007 f8dd 	bl	7ad4 <log_list_add_tail>
	__asm__ volatile(
     91a:	f386 8811 	msr	BASEPRI, r6
     91e:	f3bf 8f6f 	isb	sy
	if (panic_mode) {
     922:	4b18      	ldr	r3, [pc, #96]	; (984 <msg_finalize+0xa8>)
     924:	781a      	ldrb	r2, [r3, #0]
     926:	b17a      	cbz	r2, 948 <msg_finalize+0x6c>
	__asm__ volatile(
     928:	f04f 0320 	mov.w	r3, #32
     92c:	f3ef 8411 	mrs	r4, BASEPRI
     930:	f383 8811 	msr	BASEPRI, r3
     934:	f3bf 8f6f 	isb	sy
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
     938:	2000      	movs	r0, #0
     93a:	f7ff ff25 	bl	788 <z_impl_log_process>
	__asm__ volatile(
     93e:	f384 8811 	msr	BASEPRI, r4
     942:	f3bf 8f6f 	isb	sy
}
     946:	bd70      	pop	{r4, r5, r6, pc}
	} else if (proc_tid != NULL && buffered_cnt == 1) {
     948:	490f      	ldr	r1, [pc, #60]	; (988 <msg_finalize+0xac>)
     94a:	6823      	ldr	r3, [r4, #0]
     94c:	6809      	ldr	r1, [r1, #0]
     94e:	2900      	cmp	r1, #0
     950:	d0f9      	beq.n	946 <msg_finalize+0x6a>
     952:	2b01      	cmp	r3, #1
     954:	d106      	bne.n	964 <msg_finalize+0x88>
	z_impl_k_timer_start(timer, duration, period);
     956:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
     95a:	480c      	ldr	r0, [pc, #48]	; (98c <msg_finalize+0xb0>)
}
     95c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
     960:	f006 beba 	b.w	76d8 <z_impl_k_timer_start>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
     964:	2b0a      	cmp	r3, #10
     966:	d1ee      	bne.n	946 <msg_finalize+0x6a>
	z_impl_k_timer_stop(timer);
     968:	4808      	ldr	r0, [pc, #32]	; (98c <msg_finalize+0xb0>)
     96a:	f00a faf0 	bl	af4e <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
     96e:	4808      	ldr	r0, [pc, #32]	; (990 <msg_finalize+0xb4>)
}
     970:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
     974:	f006 bc6c 	b.w	7250 <z_impl_k_sem_give>
     978:	20006808 	.word	0x20006808
     97c:	20000008 	.word	0x20000008
     980:	20000014 	.word	0x20000014
     984:	20000f97 	.word	0x20000f97
     988:	200000d0 	.word	0x200000d0
     98c:	2000001c 	.word	0x2000001c
     990:	200069fc 	.word	0x200069fc

00000994 <log_process_thread_func>:
{
     994:	b508      	push	{r3, lr}
	log_init();
     996:	f7ff fe89 	bl	6ac <log_init>
	return z_impl_k_current_get();
     99a:	f006 fc53 	bl	7244 <z_impl_k_current_get>
	proc_tid = process_tid;
     99e:	4b0b      	ldr	r3, [pc, #44]	; (9cc <log_process_thread_func+0x38>)
     9a0:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
     9a2:	b130      	cbz	r0, 9b2 <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
     9a4:	4b0a      	ldr	r3, [pc, #40]	; (9d0 <log_process_thread_func+0x3c>)
	    process_tid &&
     9a6:	681b      	ldr	r3, [r3, #0]
     9a8:	2b09      	cmp	r3, #9
     9aa:	dd02      	ble.n	9b2 <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
     9ac:	4809      	ldr	r0, [pc, #36]	; (9d4 <log_process_thread_func+0x40>)
     9ae:	f006 fc4f 	bl	7250 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
     9b2:	4c08      	ldr	r4, [pc, #32]	; (9d4 <log_process_thread_func+0x40>)
     9b4:	2000      	movs	r0, #0
     9b6:	f7ff fee7 	bl	788 <z_impl_log_process>
		if (log_process(false) == false) {
     9ba:	2800      	cmp	r0, #0
     9bc:	d1fa      	bne.n	9b4 <log_process_thread_func+0x20>
     9be:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
     9c2:	4620      	mov	r0, r4
     9c4:	f006 fc6a 	bl	729c <z_impl_k_sem_take>
     9c8:	e7f4      	b.n	9b4 <log_process_thread_func+0x20>
     9ca:	bf00      	nop
     9cc:	200000d0 	.word	0x200000d0
     9d0:	20000008 	.word	0x20000008
     9d4:	200069fc 	.word	0x200069fc

000009d8 <z_impl_log_panic>:
{
     9d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
     9da:	4f0e      	ldr	r7, [pc, #56]	; (a14 <z_impl_log_panic+0x3c>)
     9dc:	783d      	ldrb	r5, [r7, #0]
     9de:	b975      	cbnz	r5, 9fe <z_impl_log_panic+0x26>
	return __log_backends_end - __log_backends_start;
     9e0:	4c0d      	ldr	r4, [pc, #52]	; (a18 <z_impl_log_panic+0x40>)
     9e2:	4e0e      	ldr	r6, [pc, #56]	; (a1c <z_impl_log_panic+0x44>)
	log_init();
     9e4:	f7ff fe62 	bl	6ac <log_init>
     9e8:	1b36      	subs	r6, r6, r4
     9ea:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
     9ec:	42b5      	cmp	r5, r6
     9ee:	db07      	blt.n	a00 <z_impl_log_panic+0x28>
     9f0:	2000      	movs	r0, #0
     9f2:	f7ff fec9 	bl	788 <z_impl_log_process>
		while (log_process(false) == true) {
     9f6:	2800      	cmp	r0, #0
     9f8:	d1fa      	bne.n	9f0 <z_impl_log_panic+0x18>
	panic_mode = true;
     9fa:	2301      	movs	r3, #1
     9fc:	703b      	strb	r3, [r7, #0]
}
     9fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
     a00:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
     a02:	795b      	ldrb	r3, [r3, #5]
     a04:	b11b      	cbz	r3, a0e <z_impl_log_panic+0x36>
	backend->api->panic(backend);
     a06:	6823      	ldr	r3, [r4, #0]
     a08:	4620      	mov	r0, r4
     a0a:	691b      	ldr	r3, [r3, #16]
     a0c:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
     a0e:	3501      	adds	r5, #1
     a10:	3410      	adds	r4, #16
     a12:	e7eb      	b.n	9ec <z_impl_log_panic+0x14>
     a14:	20000f97 	.word	0x20000f97
     a18:	0000b1dc 	.word	0x0000b1dc
     a1c:	0000b1dc 	.word	0x0000b1dc

00000a20 <log_free>:
{
     a20:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
     a22:	3804      	subs	r0, #4
     a24:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
     a26:	f3bf 8f5b 	dmb	ish
     a2a:	e850 3f00 	ldrex	r3, [r0]
     a2e:	1e5a      	subs	r2, r3, #1
     a30:	e840 2100 	strex	r1, r2, [r0]
     a34:	2900      	cmp	r1, #0
     a36:	d1f8      	bne.n	a2a <log_free+0xa>
     a38:	f3bf 8f5b 	dmb	ish
	if (atomic_dec(&dup->refcount) == 1) {
     a3c:	2b01      	cmp	r3, #1
     a3e:	d103      	bne.n	a48 <log_free+0x28>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
     a40:	a901      	add	r1, sp, #4
     a42:	4803      	ldr	r0, [pc, #12]	; (a50 <log_free+0x30>)
     a44:	f006 f82a 	bl	6a9c <k_mem_slab_free>
}
     a48:	b003      	add	sp, #12
     a4a:	f85d fb04 	ldr.w	pc, [sp], #4
     a4e:	bf00      	nop
     a50:	20000048 	.word	0x20000048

00000a54 <log_msg_pool_init>:
static u8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
     a54:	2320      	movs	r3, #32
     a56:	461a      	mov	r2, r3
     a58:	4901      	ldr	r1, [pc, #4]	; (a60 <log_msg_pool_init+0xc>)
     a5a:	4802      	ldr	r0, [pc, #8]	; (a64 <log_msg_pool_init+0x10>)
     a5c:	f00a b8ed 	b.w	ac3a <k_mem_slab_init>
     a60:	20006408 	.word	0x20006408
     a64:	200000d4 	.word	0x200000d4

00000a68 <log_msg_no_space_handle>:

	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
     a68:	b537      	push	{r0, r1, r2, r4, r5, lr}
	union log_msg_chunk *msg = NULL;
     a6a:	2300      	movs	r3, #0

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
     a6c:	4d09      	ldr	r5, [pc, #36]	; (a94 <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
     a6e:	9301      	str	r3, [sp, #4]
     a70:	2001      	movs	r0, #1
     a72:	f7ff fe89 	bl	788 <z_impl_log_process>
     a76:	4604      	mov	r4, r0
			log_dropped();
     a78:	f7ff fdee 	bl	658 <log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
     a7c:	2200      	movs	r2, #0
     a7e:	a901      	add	r1, sp, #4
     a80:	4628      	mov	r0, r5
     a82:	f005 ffdf 	bl	6a44 <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
     a86:	b108      	cbz	r0, a8c <log_msg_no_space_handle+0x24>
     a88:	2c00      	cmp	r4, #0
     a8a:	d1f1      	bne.n	a70 <log_msg_no_space_handle+0x8>
	} else {
		log_dropped();
	}
	return msg;

}
     a8c:	9801      	ldr	r0, [sp, #4]
     a8e:	b003      	add	sp, #12
     a90:	bd30      	pop	{r4, r5, pc}
     a92:	bf00      	nop
     a94:	200000d4 	.word	0x200000d4

00000a98 <log_msg_chunk_alloc>:
{
     a98:	b507      	push	{r0, r1, r2, lr}
	union log_msg_chunk *msg = NULL;
     a9a:	2200      	movs	r2, #0
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
     a9c:	a901      	add	r1, sp, #4
     a9e:	4806      	ldr	r0, [pc, #24]	; (ab8 <log_msg_chunk_alloc+0x20>)
	union log_msg_chunk *msg = NULL;
     aa0:	9201      	str	r2, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
     aa2:	f005 ffcf 	bl	6a44 <k_mem_slab_alloc>
	if (err != 0) {
     aa6:	b110      	cbz	r0, aae <log_msg_chunk_alloc+0x16>
		msg = log_msg_no_space_handle();
     aa8:	f7ff ffde 	bl	a68 <log_msg_no_space_handle>
     aac:	9001      	str	r0, [sp, #4]
}
     aae:	9801      	ldr	r0, [sp, #4]
     ab0:	b003      	add	sp, #12
     ab2:	f85d fb04 	ldr.w	pc, [sp], #4
     ab6:	bf00      	nop
     ab8:	200000d4 	.word	0x200000d4

00000abc <msg_free>:
{
     abc:	b5f0      	push	{r4, r5, r6, r7, lr}
     abe:	7a04      	ldrb	r4, [r0, #8]
	}
}

u32_t log_msg_nargs_get(struct log_msg *msg)
{
	return msg->hdr.params.std.nargs;
     ac0:	7a46      	ldrb	r6, [r0, #9]
{
     ac2:	b085      	sub	sp, #20
	if (log_msg_is_std(msg) && nargs) {
     ac4:	f014 0401 	ands.w	r4, r4, #1
{
     ac8:	9001      	str	r0, [sp, #4]
	return msg->hdr.params.std.nargs;
     aca:	ea4f 1616 	mov.w	r6, r6, lsr #4
	if (log_msg_is_std(msg) && nargs) {
     ace:	d00e      	beq.n	aee <msg_free+0x32>
	if (msg->hdr.params.generic.ext == 1) {
     ad0:	9b01      	ldr	r3, [sp, #4]
     ad2:	7a1a      	ldrb	r2, [r3, #8]
     ad4:	0792      	lsls	r2, r2, #30
     ad6:	d504      	bpl.n	ae2 <msg_free+0x26>
		cont_free(msg->payload.ext.next);
     ad8:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
     ada:	4c18      	ldr	r4, [pc, #96]	; (b3c <msg_free+0x80>)
     adc:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
     ade:	9b03      	ldr	r3, [sp, #12]
     ae0:	bb2b      	cbnz	r3, b2e <msg_free+0x72>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
     ae2:	a901      	add	r1, sp, #4
     ae4:	4815      	ldr	r0, [pc, #84]	; (b3c <msg_free+0x80>)
     ae6:	f005 ffd9 	bl	6a9c <k_mem_slab_free>
}
     aea:	b005      	add	sp, #20
     aec:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (log_msg_is_std(msg) && nargs) {
     aee:	2e00      	cmp	r6, #0
     af0:	d0ee      	beq.n	ad0 <msg_free+0x14>
		for (i = 0; i < nargs; i++) {
     af2:	4625      	mov	r5, r4
     af4:	e017      	b.n	b26 <msg_free+0x6a>
			void *buf = (void *)log_msg_arg_get(msg, i);
     af6:	4629      	mov	r1, r5
     af8:	f007 f882 	bl	7c00 <log_msg_arg_get>
     afc:	4607      	mov	r7, r0
			if (log_is_strdup(buf)) {
     afe:	f7ff fe35 	bl	76c <log_is_strdup>
     b02:	b178      	cbz	r0, b24 <msg_free+0x68>
				if (smask == 0) {
     b04:	b93c      	cbnz	r4, b16 <msg_free+0x5a>
					smask = z_log_get_s_mask(
     b06:	9b01      	ldr	r3, [sp, #4]
     b08:	4631      	mov	r1, r6
     b0a:	6918      	ldr	r0, [r3, #16]
     b0c:	f007 f801 	bl	7b12 <z_log_get_s_mask>
					if (smask == 0) {
     b10:	4604      	mov	r4, r0
     b12:	2800      	cmp	r0, #0
     b14:	d0dc      	beq.n	ad0 <msg_free+0x14>
				if (smask & BIT(i)) {
     b16:	fa24 f305 	lsr.w	r3, r4, r5
     b1a:	07db      	lsls	r3, r3, #31
     b1c:	d502      	bpl.n	b24 <msg_free+0x68>
					log_free(buf);
     b1e:	4638      	mov	r0, r7
     b20:	f7ff ff7e 	bl	a20 <log_free>
		for (i = 0; i < nargs; i++) {
     b24:	3501      	adds	r5, #1
     b26:	42ae      	cmp	r6, r5
     b28:	9801      	ldr	r0, [sp, #4]
     b2a:	d8e4      	bhi.n	af6 <msg_free+0x3a>
     b2c:	e7d0      	b.n	ad0 <msg_free+0x14>
		next = cont->next;
     b2e:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
     b30:	a903      	add	r1, sp, #12
     b32:	4620      	mov	r0, r4
     b34:	f005 ffb2 	bl	6a9c <k_mem_slab_free>
		cont = next;
     b38:	9503      	str	r5, [sp, #12]
     b3a:	e7d0      	b.n	ade <msg_free+0x22>
     b3c:	200000d4 	.word	0x200000d4

00000b40 <log_output_timestamp_freq_set>:
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
}

void log_output_timestamp_freq_set(u32_t frequency)
{
	timestamp_div = 1U;
     b40:	4a08      	ldr	r2, [pc, #32]	; (b64 <log_output_timestamp_freq_set+0x24>)
{
     b42:	b510      	push	{r4, lr}
	timestamp_div = 1U;
     b44:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
     b46:	4c08      	ldr	r4, [pc, #32]	; (b68 <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
     b48:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
     b4a:	2100      	movs	r1, #0
     b4c:	42a0      	cmp	r0, r4
     b4e:	d804      	bhi.n	b5a <log_output_timestamp_freq_set+0x1a>
     b50:	b101      	cbz	r1, b54 <log_output_timestamp_freq_set+0x14>
     b52:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
     b54:	4b05      	ldr	r3, [pc, #20]	; (b6c <log_output_timestamp_freq_set+0x2c>)
     b56:	6018      	str	r0, [r3, #0]
}
     b58:	bd10      	pop	{r4, pc}
		frequency /= 2U;
     b5a:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
     b5c:	005b      	lsls	r3, r3, #1
     b5e:	2101      	movs	r1, #1
     b60:	e7f4      	b.n	b4c <log_output_timestamp_freq_set+0xc>
     b62:	bf00      	nop
     b64:	200000f4 	.word	0x200000f4
     b68:	000f4240 	.word	0x000f4240
     b6c:	200000f0 	.word	0x200000f0

00000b70 <nrf_power_clock_isr>:
#endif
}

NRF_STATIC_INLINE bool nrf_clock_event_check(NRF_CLOCK_Type const * p_reg, nrf_clock_event_t event)
{
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
     b70:	4b16      	ldr	r3, [pc, #88]	; (bcc <nrf_power_clock_isr+0x5c>)
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
     b72:	b507      	push	{r0, r1, r2, lr}
     b74:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
     b76:	b182      	cbz	r2, b9a <nrf_power_clock_isr+0x2a>
    return p_reg->INTENSET & mask;
     b78:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
     b7c:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
     b80:	07d1      	lsls	r1, r2, #31
     b82:	d50a      	bpl.n	b9a <nrf_power_clock_isr+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
     b84:	2200      	movs	r2, #0
     b86:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
     b88:	681b      	ldr	r3, [r3, #0]
	struct device *dev = DEVICE_GET(clock_nrf);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
     b8a:	4811      	ldr	r0, [pc, #68]	; (bd0 <nrf_power_clock_isr+0x60>)
     b8c:	9300      	str	r3, [sp, #0]
    (void)dummy;
     b8e:	9b00      	ldr	r3, [sp, #0]

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
     b90:	6883      	ldr	r3, [r0, #8]
     b92:	7a59      	ldrb	r1, [r3, #9]
     b94:	b909      	cbnz	r1, b9a <nrf_power_clock_isr+0x2a>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
     b96:	f007 f873 	bl	7c80 <clkstarted_handle>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
     b9a:	4b0e      	ldr	r3, [pc, #56]	; (bd4 <nrf_power_clock_isr+0x64>)
     b9c:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
     b9e:	b18a      	cbz	r2, bc4 <nrf_power_clock_isr+0x54>
    return p_reg->INTENSET & mask;
     ba0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
     ba4:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
     ba8:	0792      	lsls	r2, r2, #30
     baa:	d50b      	bpl.n	bc4 <nrf_power_clock_isr+0x54>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
     bac:	2200      	movs	r2, #0
     bae:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
     bb0:	681b      	ldr	r3, [r3, #0]
     bb2:	9301      	str	r3, [sp, #4]
    (void)dummy;
     bb4:	9b01      	ldr	r3, [sp, #4]
					NRF_CLOCK_INT_LF_STARTED_MASK)) {
		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started(dev);
		}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
     bb6:	4806      	ldr	r0, [pc, #24]	; (bd0 <nrf_power_clock_isr+0x60>)
     bb8:	2101      	movs	r1, #1
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
     bba:	b003      	add	sp, #12
     bbc:	f85d eb04 	ldr.w	lr, [sp], #4
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
     bc0:	f007 b85e 	b.w	7c80 <clkstarted_handle>
}
     bc4:	b003      	add	sp, #12
     bc6:	f85d fb04 	ldr.w	pc, [sp], #4
     bca:	bf00      	nop
     bcc:	40000100 	.word	0x40000100
     bd0:	20006964 	.word	0x20006964
     bd4:	40000104 	.word	0x40000104

00000bd8 <st7789v_set_orientation>:
	return -ENOTSUP;
}

static int st7789v_set_orientation(const struct device *dev,
			    const enum display_orientation orientation)
{
     bd8:	b508      	push	{r3, lr}
	if (orientation == DISPLAY_ORIENTATION_NORMAL) {
     bda:	b181      	cbz	r1, bfe <st7789v_set_orientation+0x26>
		return 0;
	}
	LOG_ERR("Changing display orientation not implemented");
     bdc:	2301      	movs	r3, #1
     bde:	f04f 0100 	mov.w	r1, #0
     be2:	f363 0107 	bfi	r1, r3, #0, #8
     be6:	4a07      	ldr	r2, [pc, #28]	; (c04 <st7789v_set_orientation+0x2c>)
     be8:	4b07      	ldr	r3, [pc, #28]	; (c08 <st7789v_set_orientation+0x30>)
     bea:	4808      	ldr	r0, [pc, #32]	; (c0c <st7789v_set_orientation+0x34>)
     bec:	1a9b      	subs	r3, r3, r2
     bee:	08db      	lsrs	r3, r3, #3
     bf0:	f363 118f 	bfi	r1, r3, #6, #10
     bf4:	f006 ffad 	bl	7b52 <log_0>
	return -ENOTSUP;
     bf8:	f06f 0022 	mvn.w	r0, #34	; 0x22
}
     bfc:	bd08      	pop	{r3, pc}
		return 0;
     bfe:	4608      	mov	r0, r1
     c00:	e7fc      	b.n	bfc <st7789v_set_orientation+0x24>
     c02:	bf00      	nop
     c04:	0000b17c 	.word	0x0000b17c
     c08:	0000b194 	.word	0x0000b194
     c0c:	0000ba3a 	.word	0x0000ba3a

00000c10 <st7789v_set_pixel_format>:
	if (pixel_format == PIXEL_FORMAT_RGB_565) {
     c10:	2910      	cmp	r1, #16
{
     c12:	b508      	push	{r3, lr}
	if (pixel_format == PIXEL_FORMAT_RGB_565) {
     c14:	d010      	beq.n	c38 <st7789v_set_pixel_format+0x28>
	LOG_ERR("Pixel format change not implemented");
     c16:	2301      	movs	r3, #1
     c18:	f04f 0100 	mov.w	r1, #0
     c1c:	f363 0107 	bfi	r1, r3, #0, #8
     c20:	4a06      	ldr	r2, [pc, #24]	; (c3c <st7789v_set_pixel_format+0x2c>)
     c22:	4b07      	ldr	r3, [pc, #28]	; (c40 <st7789v_set_pixel_format+0x30>)
     c24:	4807      	ldr	r0, [pc, #28]	; (c44 <st7789v_set_pixel_format+0x34>)
     c26:	1a9b      	subs	r3, r3, r2
     c28:	08db      	lsrs	r3, r3, #3
     c2a:	f363 118f 	bfi	r1, r3, #6, #10
     c2e:	f006 ff90 	bl	7b52 <log_0>
	return -ENOTSUP;
     c32:	f06f 0022 	mvn.w	r0, #34	; 0x22
}
     c36:	bd08      	pop	{r3, pc}
		return 0;
     c38:	2000      	movs	r0, #0
     c3a:	e7fc      	b.n	c36 <st7789v_set_pixel_format+0x26>
     c3c:	0000b17c 	.word	0x0000b17c
     c40:	0000b194 	.word	0x0000b194
     c44:	0000ba67 	.word	0x0000ba67

00000c48 <st7789v_init>:
	st7789v_transmit(p_st7789v, ST7789V_CMD_RGBCTRL, st7789v_rgb_param,
			 sizeof(st7789v_rgb_param));
}

static int st7789v_init(struct device *dev)
{
     c48:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
     c4c:	4607      	mov	r7, r0
	struct st7789v_data *data = (struct st7789v_data *)dev->driver_data;
     c4e:	6884      	ldr	r4, [r0, #8]
     c50:	489e      	ldr	r0, [pc, #632]	; (ecc <st7789v_init+0x284>)
     c52:	f005 fd57 	bl	6704 <z_impl_device_get_binding>

	data->spi_dev = device_get_binding(DT_INST_0_SITRONIX_ST7789V_BUS_NAME);
     c56:	6020      	str	r0, [r4, #0]
	if (data->spi_dev == NULL) {
     c58:	b998      	cbnz	r0, c82 <st7789v_init+0x3a>
		LOG_ERR("Could not get SPI device for LCD");
     c5a:	2301      	movs	r3, #1
     c5c:	f04f 0100 	mov.w	r1, #0
     c60:	f363 0107 	bfi	r1, r3, #0, #8
     c64:	4a9a      	ldr	r2, [pc, #616]	; (ed0 <st7789v_init+0x288>)
     c66:	4b9b      	ldr	r3, [pc, #620]	; (ed4 <st7789v_init+0x28c>)
     c68:	489b      	ldr	r0, [pc, #620]	; (ed8 <st7789v_init+0x290>)
     c6a:	1a9b      	subs	r3, r3, r2
     c6c:	08db      	lsrs	r3, r3, #3
     c6e:	f363 118f 	bfi	r1, r3, #6, #10
#endif

	data->cmd_data_gpio = device_get_binding(
			DT_INST_0_SITRONIX_ST7789V_CMD_DATA_GPIOS_CONTROLLER);
	if (data->cmd_data_gpio == NULL) {
		LOG_ERR("Could not get GPIO port for cmd/DATA port");
     c72:	f006 ff6e 	bl	7b52 <log_0>
		return -EPERM;
     c76:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
	st7789v_lcd_init(data);

	st7789v_exit_sleep(data);

	return 0;
}
     c7a:	4628      	mov	r0, r5
     c7c:	b002      	add	sp, #8
     c7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	data->spi_config.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
     c82:	4a96      	ldr	r2, [pc, #600]	; (edc <st7789v_init+0x294>)
     c84:	f44f 7380 	mov.w	r3, #256	; 0x100
     c88:	e9c4 2301 	strd	r2, r3, [r4, #4]
     c8c:	4894      	ldr	r0, [pc, #592]	; (ee0 <st7789v_init+0x298>)
     c8e:	f005 fd39 	bl	6704 <z_impl_device_get_binding>
	data->cs_ctrl.delay = 0U;
     c92:	2619      	movs	r6, #25
     c94:	2500      	movs	r5, #0
	data->spi_config.cs = &(data->cs_ctrl);
     c96:	f104 0310 	add.w	r3, r4, #16
	data->cs_ctrl.gpio_dev = device_get_binding(
     c9a:	6120      	str	r0, [r4, #16]
	data->cs_ctrl.delay = 0U;
     c9c:	e9c4 6505 	strd	r6, r5, [r4, #20]
	data->spi_config.cs = &(data->cs_ctrl);
     ca0:	60e3      	str	r3, [r4, #12]
     ca2:	488f      	ldr	r0, [pc, #572]	; (ee0 <st7789v_init+0x298>)
     ca4:	f005 fd2e 	bl	6704 <z_impl_device_get_binding>
	data->reset_gpio = device_get_binding(
     ca8:	61e0      	str	r0, [r4, #28]
	if (data->reset_gpio == NULL) {
     caa:	b960      	cbnz	r0, cc6 <st7789v_init+0x7e>
		LOG_ERR("Could not get GPIO port for display reset");
     cac:	2301      	movs	r3, #1
     cae:	f04f 0100 	mov.w	r1, #0
     cb2:	f363 0107 	bfi	r1, r3, #0, #8
     cb6:	4a86      	ldr	r2, [pc, #536]	; (ed0 <st7789v_init+0x288>)
     cb8:	4b86      	ldr	r3, [pc, #536]	; (ed4 <st7789v_init+0x28c>)
     cba:	488a      	ldr	r0, [pc, #552]	; (ee4 <st7789v_init+0x29c>)
     cbc:	1a9b      	subs	r3, r3, r2
     cbe:	08db      	lsrs	r3, r3, #3
     cc0:	f363 118f 	bfi	r1, r3, #6, #10
     cc4:	e7d5      	b.n	c72 <st7789v_init+0x2a>
	return api->config(port, access_op, pin, flags);
     cc6:	6843      	ldr	r3, [r0, #4]
     cc8:	4629      	mov	r1, r5
     cca:	f8d3 8000 	ldr.w	r8, [r3]
     cce:	221a      	movs	r2, #26
     cd0:	2301      	movs	r3, #1
     cd2:	47c0      	blx	r8
	if (gpio_pin_configure(data->reset_gpio, ST7789V_RESET_PIN,
     cd4:	4605      	mov	r5, r0
     cd6:	b180      	cbz	r0, cfa <st7789v_init+0xb2>
		LOG_ERR("Couldn't configure reset pin");
     cd8:	2301      	movs	r3, #1
     cda:	f04f 0100 	mov.w	r1, #0
     cde:	f363 0107 	bfi	r1, r3, #0, #8
     ce2:	4a7b      	ldr	r2, [pc, #492]	; (ed0 <st7789v_init+0x288>)
     ce4:	4b7b      	ldr	r3, [pc, #492]	; (ed4 <st7789v_init+0x28c>)
     ce6:	4880      	ldr	r0, [pc, #512]	; (ee8 <st7789v_init+0x2a0>)
     ce8:	1a9b      	subs	r3, r3, r2
     cea:	08db      	lsrs	r3, r3, #3
     cec:	f363 118f 	bfi	r1, r3, #6, #10
		LOG_ERR("Couldn't configure cmd/DATA pin");
     cf0:	f006 ff2f 	bl	7b52 <log_0>
		return -EIO;
     cf4:	f06f 0504 	mvn.w	r5, #4
     cf8:	e7bf      	b.n	c7a <st7789v_init+0x32>
     cfa:	4879      	ldr	r0, [pc, #484]	; (ee0 <st7789v_init+0x298>)
     cfc:	f005 fd02 	bl	6704 <z_impl_device_get_binding>
	data->cmd_data_gpio = device_get_binding(
     d00:	6220      	str	r0, [r4, #32]
	if (data->cmd_data_gpio == NULL) {
     d02:	b960      	cbnz	r0, d1e <st7789v_init+0xd6>
		LOG_ERR("Could not get GPIO port for cmd/DATA port");
     d04:	2301      	movs	r3, #1
     d06:	f04f 0100 	mov.w	r1, #0
     d0a:	f363 0107 	bfi	r1, r3, #0, #8
     d0e:	4a70      	ldr	r2, [pc, #448]	; (ed0 <st7789v_init+0x288>)
     d10:	4b70      	ldr	r3, [pc, #448]	; (ed4 <st7789v_init+0x28c>)
     d12:	4876      	ldr	r0, [pc, #472]	; (eec <st7789v_init+0x2a4>)
     d14:	1a9b      	subs	r3, r3, r2
     d16:	08db      	lsrs	r3, r3, #3
     d18:	f363 118f 	bfi	r1, r3, #6, #10
     d1c:	e7a9      	b.n	c72 <st7789v_init+0x2a>
     d1e:	6843      	ldr	r3, [r0, #4]
     d20:	4629      	mov	r1, r5
     d22:	f8d3 8000 	ldr.w	r8, [r3]
     d26:	2212      	movs	r2, #18
     d28:	2301      	movs	r3, #1
     d2a:	47c0      	blx	r8
	if (gpio_pin_configure(data->cmd_data_gpio, ST7789V_CMD_DATA_PIN,
     d2c:	4605      	mov	r5, r0
     d2e:	b160      	cbz	r0, d4a <st7789v_init+0x102>
		LOG_ERR("Couldn't configure cmd/DATA pin");
     d30:	2301      	movs	r3, #1
     d32:	f04f 0100 	mov.w	r1, #0
     d36:	f363 0107 	bfi	r1, r3, #0, #8
     d3a:	4a65      	ldr	r2, [pc, #404]	; (ed0 <st7789v_init+0x288>)
     d3c:	4b65      	ldr	r3, [pc, #404]	; (ed4 <st7789v_init+0x28c>)
     d3e:	486c      	ldr	r0, [pc, #432]	; (ef0 <st7789v_init+0x2a8>)
     d40:	1a9b      	subs	r3, r3, r2
     d42:	08db      	lsrs	r3, r3, #3
     d44:	f363 118f 	bfi	r1, r3, #6, #10
     d48:	e7d2      	b.n	cf0 <st7789v_init+0xa8>
	gpio_pin_write(data->reset_gpio, ST7789V_RESET_PIN, 1);
     d4a:	2201      	movs	r2, #1
     d4c:	211a      	movs	r1, #26
     d4e:	69e0      	ldr	r0, [r4, #28]
     d50:	f007 f8a1 	bl	7e96 <gpio_pin_write>
	k_sleep(K_MSEC(1));
     d54:	2001      	movs	r0, #1
     d56:	f007 f88c 	bl	7e72 <k_sleep>
	gpio_pin_write(data->reset_gpio, ST7789V_RESET_PIN, 0);
     d5a:	462a      	mov	r2, r5
     d5c:	211a      	movs	r1, #26
     d5e:	69e0      	ldr	r0, [r4, #28]
     d60:	f007 f899 	bl	7e96 <gpio_pin_write>
	k_sleep(K_MSEC(6));
     d64:	2006      	movs	r0, #6
     d66:	f007 f884 	bl	7e72 <k_sleep>
	gpio_pin_write(data->reset_gpio, ST7789V_RESET_PIN, 1);
     d6a:	2201      	movs	r2, #1
     d6c:	211a      	movs	r1, #26
     d6e:	69e0      	ldr	r0, [r4, #28]
     d70:	f007 f891 	bl	7e96 <gpio_pin_write>
	k_sleep(K_MSEC(20));
     d74:	2014      	movs	r0, #20
     d76:	f007 f87c 	bl	7e72 <k_sleep>
	st7789v_blanking_on(dev);
     d7a:	4638      	mov	r0, r7
     d7c:	f007 f8c8 	bl	7f10 <st7789v_blanking_on>
	st7789v_transmit(p_st7789v, ST7789V_CMD_PORCTRL, st7789v_porch_param,
     d80:	4620      	mov	r0, r4
	data->x_offset = x_offset;
     d82:	62a5      	str	r5, [r4, #40]	; 0x28
	st7789v_transmit(p_st7789v, ST7789V_CMD_PORCTRL, st7789v_porch_param,
     d84:	2305      	movs	r3, #5
     d86:	4a5b      	ldr	r2, [pc, #364]	; (ef4 <st7789v_init+0x2ac>)
     d88:	21b2      	movs	r1, #178	; 0xb2
     d8a:	f007 f890 	bl	7eae <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_CMD2EN, st7789v_cmd2en_param,
     d8e:	4620      	mov	r0, r4
     d90:	2304      	movs	r3, #4
     d92:	4a59      	ldr	r2, [pc, #356]	; (ef8 <st7789v_init+0x2b0>)
     d94:	21df      	movs	r1, #223	; 0xdf
     d96:	f007 f88a 	bl	7eae <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_DGMEN, &tmp, 1);
     d9a:	f10d 0207 	add.w	r2, sp, #7
     d9e:	4620      	mov	r0, r4
     da0:	2301      	movs	r3, #1
     da2:	21ba      	movs	r1, #186	; 0xba
	tmp = 0x00;
     da4:	f88d 5007 	strb.w	r5, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_DGMEN, &tmp, 1);
     da8:	f007 f881 	bl	7eae <st7789v_transmit>
	tmp = 0x0f;
     dac:	230f      	movs	r3, #15
     dae:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_FRCTRL2, &tmp, 1);
     db2:	f10d 0207 	add.w	r2, sp, #7
     db6:	4620      	mov	r0, r4
     db8:	2301      	movs	r3, #1
     dba:	21c6      	movs	r1, #198	; 0xc6
     dbc:	f007 f877 	bl	7eae <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_GCTRL;
     dc0:	2335      	movs	r3, #53	; 0x35
     dc2:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_GCTRL, &tmp, 1);
     dc6:	f10d 0207 	add.w	r2, sp, #7
     dca:	4620      	mov	r0, r4
     dcc:	2301      	movs	r3, #1
     dce:	21b7      	movs	r1, #183	; 0xb7
     dd0:	f007 f86d 	bl	7eae <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_VCOM;
     dd4:	f88d 6007 	strb.w	r6, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_VCOMS, &tmp, 1);
     dd8:	f10d 0207 	add.w	r2, sp, #7
	tmp = 0x01;
     ddc:	2601      	movs	r6, #1
	st7789v_transmit(p_st7789v, ST7789V_CMD_VCOMS, &tmp, 1);
     dde:	4620      	mov	r0, r4
     de0:	2301      	movs	r3, #1
     de2:	21bb      	movs	r1, #187	; 0xbb
     de4:	f007 f863 	bl	7eae <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_VDVVRHEN, &tmp, 1);
     de8:	4633      	mov	r3, r6
     dea:	f10d 0207 	add.w	r2, sp, #7
     dee:	4620      	mov	r0, r4
     df0:	21c2      	movs	r1, #194	; 0xc2
	tmp = 0x01;
     df2:	f88d 6007 	strb.w	r6, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_VDVVRHEN, &tmp, 1);
     df6:	f007 f85a 	bl	7eae <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_VRHS;
     dfa:	2312      	movs	r3, #18
     dfc:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_VRH, &tmp, 1);
     e00:	f10d 0207 	add.w	r2, sp, #7
     e04:	4633      	mov	r3, r6
     e06:	4620      	mov	r0, r4
     e08:	21c3      	movs	r1, #195	; 0xc3
     e0a:	f007 f850 	bl	7eae <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_VDVS;
     e0e:	2320      	movs	r3, #32
     e10:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_VDS, &tmp, 1);
     e14:	f10d 0207 	add.w	r2, sp, #7
     e18:	4633      	mov	r3, r6
     e1a:	4620      	mov	r0, r4
     e1c:	21c4      	movs	r1, #196	; 0xc4
     e1e:	f007 f846 	bl	7eae <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_PWCTRL1, st7789v_pwctrl1_param,
     e22:	4620      	mov	r0, r4
     e24:	2302      	movs	r3, #2
     e26:	4a35      	ldr	r2, [pc, #212]	; (efc <st7789v_init+0x2b4>)
     e28:	21d0      	movs	r1, #208	; 0xd0
     e2a:	f007 f840 	bl	7eae <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_MADCTL, &tmp, 1);
     e2e:	4633      	mov	r3, r6
     e30:	f10d 0207 	add.w	r2, sp, #7
     e34:	4620      	mov	r0, r4
     e36:	2136      	movs	r1, #54	; 0x36
	tmp = DT_INST_0_SITRONIX_ST7789V_MDAC;
     e38:	f88d 5007 	strb.w	r5, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_MADCTL, &tmp, 1);
     e3c:	f007 f837 	bl	7eae <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_COLMOD;
     e40:	2305      	movs	r3, #5
     e42:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_COLMOD, &tmp, 1);
     e46:	f10d 0207 	add.w	r2, sp, #7
     e4a:	4633      	mov	r3, r6
     e4c:	4620      	mov	r0, r4
     e4e:	213a      	movs	r1, #58	; 0x3a
     e50:	f007 f82d 	bl	7eae <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_LCM;
     e54:	232c      	movs	r3, #44	; 0x2c
     e56:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_LCMCTRL, &tmp, 1);
     e5a:	f10d 0207 	add.w	r2, sp, #7
     e5e:	4633      	mov	r3, r6
     e60:	4620      	mov	r0, r4
     e62:	21c0      	movs	r1, #192	; 0xc0
     e64:	f007 f823 	bl	7eae <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_GAMSET, &tmp, 1);
     e68:	4633      	mov	r3, r6
     e6a:	f10d 0207 	add.w	r2, sp, #7
     e6e:	4620      	mov	r0, r4
     e70:	2126      	movs	r1, #38	; 0x26
	tmp = DT_INST_0_SITRONIX_ST7789V_GAMMA;
     e72:	f88d 6007 	strb.w	r6, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_GAMSET, &tmp, 1);
     e76:	f007 f81a 	bl	7eae <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_INV_ON, NULL, 0);
     e7a:	462b      	mov	r3, r5
     e7c:	462a      	mov	r2, r5
     e7e:	4620      	mov	r0, r4
     e80:	2121      	movs	r1, #33	; 0x21
     e82:	f007 f814 	bl	7eae <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_PVGAMCTRL, st7789v_pvgam_param,
     e86:	4620      	mov	r0, r4
     e88:	230e      	movs	r3, #14
     e8a:	4a1d      	ldr	r2, [pc, #116]	; (f00 <st7789v_init+0x2b8>)
     e8c:	21e0      	movs	r1, #224	; 0xe0
     e8e:	f007 f80e 	bl	7eae <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_NVGAMCTRL, st7789v_nvgam_param,
     e92:	4620      	mov	r0, r4
     e94:	230e      	movs	r3, #14
     e96:	4a1b      	ldr	r2, [pc, #108]	; (f04 <st7789v_init+0x2bc>)
     e98:	21e1      	movs	r1, #225	; 0xe1
     e9a:	f007 f808 	bl	7eae <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_RAMCTRL, st7789v_ram_param,
     e9e:	4620      	mov	r0, r4
     ea0:	2302      	movs	r3, #2
     ea2:	4a19      	ldr	r2, [pc, #100]	; (f08 <st7789v_init+0x2c0>)
     ea4:	21b0      	movs	r1, #176	; 0xb0
     ea6:	f007 f802 	bl	7eae <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_RGBCTRL, st7789v_rgb_param,
     eaa:	4620      	mov	r0, r4
     eac:	2303      	movs	r3, #3
     eae:	4a17      	ldr	r2, [pc, #92]	; (f0c <st7789v_init+0x2c4>)
     eb0:	21b1      	movs	r1, #177	; 0xb1
     eb2:	f006 fffc 	bl	7eae <st7789v_transmit>
	st7789v_transmit(data, ST7789V_CMD_SLEEP_OUT, NULL, 0);
     eb6:	4620      	mov	r0, r4
     eb8:	462b      	mov	r3, r5
     eba:	462a      	mov	r2, r5
     ebc:	2111      	movs	r1, #17
     ebe:	f006 fff6 	bl	7eae <st7789v_transmit>
	k_sleep(K_MSEC(120));
     ec2:	2078      	movs	r0, #120	; 0x78
     ec4:	f006 ffd5 	bl	7e72 <k_sleep>
     ec8:	e6d7      	b.n	c7a <st7789v_init+0x32>
     eca:	bf00      	nop
     ecc:	0000b982 	.word	0x0000b982
     ed0:	0000b17c 	.word	0x0000b17c
     ed4:	0000b194 	.word	0x0000b194
     ed8:	0000b988 	.word	0x0000b988
     edc:	007a1200 	.word	0x007a1200
     ee0:	0000b8e9 	.word	0x0000b8e9
     ee4:	0000b9a9 	.word	0x0000b9a9
     ee8:	0000b9d3 	.word	0x0000b9d3
     eec:	0000b9f0 	.word	0x0000b9f0
     ef0:	0000ba1a 	.word	0x0000ba1a
     ef4:	2000691a 	.word	0x2000691a
     ef8:	20006908 	.word	0x20006908
     efc:	2000692d 	.word	0x2000692d
     f00:	2000691f 	.word	0x2000691f
     f04:	2000690c 	.word	0x2000690c
     f08:	2000692f 	.word	0x2000692f
     f0c:	20006931 	.word	0x20006931

00000f10 <rtc1_nrf_isr>:
 * symbol.
 */
void rtc1_nrf_isr(void *arg)
{
	ARG_UNUSED(arg);
	RTC->EVENTS_COMPARE[0] = 0;
     f10:	4b0d      	ldr	r3, [pc, #52]	; (f48 <rtc1_nrf_isr+0x38>)
     f12:	2200      	movs	r2, #0
     f14:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
	__asm__ volatile(
     f18:	f04f 0220 	mov.w	r2, #32
     f1c:	f3ef 8111 	mrs	r1, BASEPRI
     f20:	f382 8811 	msr	BASEPRI, r2
     f24:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t t = counter();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
     f28:	4a08      	ldr	r2, [pc, #32]	; (f4c <rtc1_nrf_isr+0x3c>)
#endif
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
     f2a:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
     f2e:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
     f30:	1ac0      	subs	r0, r0, r3
     f32:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
     f36:	4403      	add	r3, r0
     f38:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
     f3a:	f381 8811 	msr	BASEPRI, r1
     f3e:	f3bf 8f6f 	isb	sy
		}
		set_comparator(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
     f42:	f006 bb31 	b.w	75a8 <z_clock_announce>
     f46:	bf00      	nop
     f48:	40011000 	.word	0x40011000
     f4c:	20000110 	.word	0x20000110

00000f50 <z_clock_driver_init>:
}

int z_clock_driver_init(struct device *device)
{
     f50:	b573      	push	{r0, r1, r4, r5, r6, lr}
     f52:	481c      	ldr	r0, [pc, #112]	; (fc4 <z_clock_driver_init+0x74>)
     f54:	f005 fbd6 	bl	6704 <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_INST_0_NORDIC_NRF_CLOCK_LABEL);
	if (!clock) {
     f58:	b380      	cbz	r0, fbc <z_clock_driver_init+0x6c>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
     f5a:	6843      	ldr	r3, [r0, #4]
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
     f5c:	4d1a      	ldr	r5, [pc, #104]	; (fc8 <z_clock_driver_init+0x78>)
     f5e:	681b      	ldr	r3, [r3, #0]
     f60:	2101      	movs	r1, #1
     f62:	4798      	blx	r3
    p_reg->CC[ch] = cc_val;
     f64:	2601      	movs	r6, #1
    p_reg->PRESCALER = val;
     f66:	2400      	movs	r4, #0
    p_reg->INTENSET = mask;
     f68:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->PRESCALER = val;
     f6c:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
     f70:	f8c5 6540 	str.w	r6, [r5, #1344]	; 0x540
    p_reg->INTENSET = mask;
     f74:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
     f78:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
     f7c:	f503 538a 	add.w	r3, r3, #4416	; 0x1140
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     f80:	f44f 3200 	mov.w	r2, #131072	; 0x20000
     f84:	601c      	str	r4, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
     f86:	681b      	ldr	r3, [r3, #0]
     f88:	9301      	str	r3, [sp, #4]
    (void)dummy;
     f8a:	9b01      	ldr	r3, [sp, #4]
     f8c:	4b0f      	ldr	r3, [pc, #60]	; (fcc <z_clock_driver_init+0x7c>)

	/* Clear the event flag and possible pending interrupt */
	nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_COMPARE_0);
	NVIC_ClearPendingIRQ(RTC1_IRQn);

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
     f8e:	4631      	mov	r1, r6
     f90:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
     f94:	2011      	movs	r0, #17
     f96:	4622      	mov	r2, r4
     f98:	f000 f918 	bl	11cc <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
     f9c:	2011      	movs	r0, #17
     f9e:	f000 f905 	bl	11ac <arch_irq_enable>
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
     fa2:	4b0b      	ldr	r3, [pc, #44]	; (fd0 <z_clock_driver_init+0x80>)
     fa4:	601e      	str	r6, [r3, #0]
     fa6:	602e      	str	r6, [r5, #0]
     return p_reg->COUNTER;
     fa8:	f8d5 3504 	ldr.w	r3, [r5, #1284]	; 0x504

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	if (!IS_ENABLED(TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
     fac:	4433      	add	r3, r6
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
     fae:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
     fb2:	f8c5 3540 	str.w	r3, [r5, #1344]	; 0x540
	}

	return 0;
     fb6:	4620      	mov	r0, r4
}
     fb8:	b002      	add	sp, #8
     fba:	bd70      	pop	{r4, r5, r6, pc}
		return -1;
     fbc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     fc0:	e7fa      	b.n	fb8 <z_clock_driver_init+0x68>
     fc2:	bf00      	nop
     fc4:	0000b962 	.word	0x0000b962
     fc8:	40011000 	.word	0x40011000
     fcc:	e000e100 	.word	0xe000e100
     fd0:	40011008 	.word	0x40011008

00000fd4 <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
     fd4:	b5f0      	push	{r4, r5, r6, r7, lr}
	ARG_UNUSED(idle);

#ifdef CONFIG_TICKLESS_KERNEL
	ticks = (ticks == K_FOREVER) ? MAX_TICKS : ticks;
     fd6:	4e25      	ldr	r6, [pc, #148]	; (106c <z_clock_set_timeout+0x98>)
     fd8:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
     fdc:	bf08      	it	eq
     fde:	4630      	moveq	r0, r6
	__asm__ volatile(
     fe0:	f04f 0320 	mov.w	r3, #32
     fe4:	f3ef 8511 	mrs	r5, BASEPRI
     fe8:	f383 8811 	msr	BASEPRI, r3
     fec:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
     ff0:	491f      	ldr	r1, [pc, #124]	; (1070 <z_clock_set_timeout+0x9c>)
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t cyc, dt, t = counter();
	u32_t unannounced = counter_sub(t, last_count);
     ff2:	4b20      	ldr	r3, [pc, #128]	; (1074 <z_clock_set_timeout+0xa0>)
     ff4:	f8d1 4504 	ldr.w	r4, [r1, #1284]	; 0x504
     ff8:	681b      	ldr	r3, [r3, #0]
	return (a - b) & COUNTER_MAX;
     ffa:	1ae2      	subs	r2, r4, r3
     ffc:	f022 477f 	bic.w	r7, r2, #4278190080	; 0xff000000
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
    1000:	0212      	lsls	r2, r2, #8
    1002:	d419      	bmi.n	1038 <z_clock_set_timeout+0x64>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
    1004:	1e42      	subs	r2, r0, #1
    1006:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    100a:	42b2      	cmp	r2, r6
    100c:	bfa8      	it	ge
    100e:	4632      	movge	r2, r6
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    1010:	1c78      	adds	r0, r7, #1
    1012:	4410      	add	r0, r2
	 */
	if (cyc > MAX_CYCLES) {
		cyc = MAX_CYCLES;
	}

	cyc += last_count;
    1014:	42b0      	cmp	r0, r6
    1016:	bf94      	ite	ls
    1018:	1818      	addls	r0, r3, r0
    101a:	1998      	addhi	r0, r3, r6
	return (a - b) & COUNTER_MAX;
    101c:	1b04      	subs	r4, r0, r4
    101e:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
    1022:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
	 * least on nRF52.  Some experimentation on nrf52840 shows
	 * that you need to be early by about 400 processor cycles
	 * (about 1/5th of a RTC cycle) in order to reliably get the
	 * interrupt.  The docs say two cycles, they mean two cycles.
	 */
	if (counter_sub(cyc, t) > 2) {
    1026:	2c02      	cmp	r4, #2
    p_reg->CC[ch] = cc_val;
    1028:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
    102c:	d906      	bls.n	103c <z_clock_set_timeout+0x68>
	__asm__ volatile(
    102e:	f385 8811 	msr	BASEPRI, r5
    1032:	f3bf 8f6f 	isb	sy
	}
#endif

	k_spin_unlock(&lock, key);
#endif /* CONFIG_TICKLESS_KERNEL */
}
    1036:	bdf0      	pop	{r4, r5, r6, r7, pc}
		ticks = 0;
    1038:	2200      	movs	r2, #0
    103a:	e7e9      	b.n	1010 <z_clock_set_timeout+0x3c>
     return p_reg->COUNTER;
    103c:	f8d1 3504 	ldr.w	r3, [r1, #1284]	; 0x504
		if (dt == 0 || dt > 0x7fffff) {
    1040:	4a0d      	ldr	r2, [pc, #52]	; (1078 <z_clock_set_timeout+0xa4>)
	return (a - b) & COUNTER_MAX;
    1042:	1ac3      	subs	r3, r0, r3
    1044:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		if (dt == 0 || dt > 0x7fffff) {
    1048:	1e5c      	subs	r4, r3, #1
    104a:	4294      	cmp	r4, r2
    104c:	d905      	bls.n	105a <z_clock_set_timeout+0x86>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    104e:	4b0b      	ldr	r3, [pc, #44]	; (107c <z_clock_set_timeout+0xa8>)
    1050:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    1054:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    1058:	e7e9      	b.n	102e <z_clock_set_timeout+0x5a>
		} else if (dt == 1) {
    105a:	2b01      	cmp	r3, #1
			set_comparator(cyc + 2);
    105c:	bf02      	ittt	eq
    105e:	3002      	addeq	r0, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    1060:	f020 407f 	biceq.w	r0, r0, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    1064:	f8c1 0540 	streq.w	r0, [r1, #1344]	; 0x540
    1068:	e7e1      	b.n	102e <z_clock_set_timeout+0x5a>
    106a:	bf00      	nop
    106c:	00fffffe 	.word	0x00fffffe
    1070:	40011000 	.word	0x40011000
    1074:	20000110 	.word	0x20000110
    1078:	007ffffe 	.word	0x007ffffe
    107c:	e000e100 	.word	0xe000e100

00001080 <z_clock_elapsed>:
	__asm__ volatile(
    1080:	f04f 0220 	mov.w	r2, #32
    1084:	f3ef 8311 	mrs	r3, BASEPRI
    1088:	f382 8811 	msr	BASEPRI, r2
    108c:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
    1090:	4a06      	ldr	r2, [pc, #24]	; (10ac <z_clock_elapsed+0x2c>)
    1092:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
    1096:	4a06      	ldr	r2, [pc, #24]	; (10b0 <z_clock_elapsed+0x30>)
	return (a - b) & COUNTER_MAX;
    1098:	6812      	ldr	r2, [r2, #0]
    109a:	1a80      	subs	r0, r0, r2
    109c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	__asm__ volatile(
    10a0:	f383 8811 	msr	BASEPRI, r3
    10a4:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    10a8:	4770      	bx	lr
    10aa:	bf00      	nop
    10ac:	40011000 	.word	0x40011000
    10b0:	20000110 	.word	0x20000110

000010b4 <z_timer_cycle_get_32>:
	__asm__ volatile(
    10b4:	f04f 0320 	mov.w	r3, #32
    10b8:	f3ef 8211 	mrs	r2, BASEPRI
    10bc:	f383 8811 	msr	BASEPRI, r3
    10c0:	f3bf 8f6f 	isb	sy

u32_t z_timer_cycle_get_32(void)
{
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) + last_count;
    10c4:	4906      	ldr	r1, [pc, #24]	; (10e0 <z_timer_cycle_get_32+0x2c>)
    10c6:	4b07      	ldr	r3, [pc, #28]	; (10e4 <z_timer_cycle_get_32+0x30>)
    10c8:	6808      	ldr	r0, [r1, #0]
    10ca:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	__asm__ volatile(
    10ce:	f382 8811 	msr	BASEPRI, r2
    10d2:	f3bf 8f6f 	isb	sy
	return (a - b) & COUNTER_MAX;
    10d6:	1a1b      	subs	r3, r3, r0
    10d8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000

	k_spin_unlock(&lock, key);
	return ret;
}
    10dc:	4418      	add	r0, r3
    10de:	4770      	bx	lr
    10e0:	20000110 	.word	0x20000110
    10e4:	40011000 	.word	0x40011000

000010e8 <z_arm_exc_exit>:
    /* r0 contains the caller mode */
    push {r0, lr}
#endif

#ifdef CONFIG_PREEMPT_ENABLED
    ldr r0, =_kernel
    10e8:	4804      	ldr	r0, [pc, #16]	; (10fc <_EXIT_EXC+0x2>)

    ldr r1, [r0, #_kernel_offset_to_current]
    10ea:	6881      	ldr	r1, [r0, #8]

    ldr r0, [r0, #_kernel_offset_to_ready_q_cache]
    10ec:	6a40      	ldr	r0, [r0, #36]	; 0x24
    cmp r0, r1
    10ee:	4288      	cmp	r0, r1
    beq _EXIT_EXC
    10f0:	d003      	beq.n	10fa <_EXIT_EXC>

#if defined(CONFIG_CPU_CORTEX_M)
    /* context switch required, pend the PendSV exception */
    ldr r1, =_SCS_ICSR
    10f2:	4903      	ldr	r1, [pc, #12]	; (1100 <_EXIT_EXC+0x6>)
    ldr r2, =_SCS_ICSR_PENDSV
    10f4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    str r2, [r1]
    10f8:	600a      	str	r2, [r1, #0]

000010fa <_EXIT_EXC>:
    bl z_check_stack_sentinel
#endif /* CONFIG_CPU_CORTEX_M */
#endif /* CONFIG_STACK_SENTINEL */

#if defined(CONFIG_CPU_CORTEX_M)
    bx lr
    10fa:	4770      	bx	lr
    ldr r0, =_kernel
    10fc:	20000f54 	.word	0x20000f54
    ldr r1, =_SCS_ICSR
    1100:	e000ed04 	.word	0xe000ed04

00001104 <arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
    1104:	4a09      	ldr	r2, [pc, #36]	; (112c <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
    1106:	490a      	ldr	r1, [pc, #40]	; (1130 <arch_swap+0x2c>)
	_current->arch.basepri = key;
    1108:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    110a:	6809      	ldr	r1, [r1, #0]
    110c:	6699      	str	r1, [r3, #104]	; 0x68

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    110e:	4909      	ldr	r1, [pc, #36]	; (1134 <arch_swap+0x30>)
	_current->arch.basepri = key;
    1110:	6658      	str	r0, [r3, #100]	; 0x64
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    1112:	684b      	ldr	r3, [r1, #4]
    1114:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    1118:	604b      	str	r3, [r1, #4]
    111a:	2300      	movs	r3, #0
    111c:	f383 8811 	msr	BASEPRI, r3
    1120:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    1124:	6893      	ldr	r3, [r2, #8]
}
    1126:	6e98      	ldr	r0, [r3, #104]	; 0x68
    1128:	4770      	bx	lr
    112a:	bf00      	nop
    112c:	20000f54 	.word	0x20000f54
    1130:	0000b814 	.word	0x0000b814
    1134:	e000ed00 	.word	0xe000ed00

00001138 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    1138:	4912      	ldr	r1, [pc, #72]	; (1184 <z_arm_pendsv+0x4c>)
    ldr r2, [r1, #_kernel_offset_to_current]
    113a:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    113c:	f04f 0028 	mov.w	r0, #40	; 0x28
    add r0, r2
    1140:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    1142:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    1146:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    114a:	2020      	movs	r0, #32
    msr BASEPRI, r0
    114c:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    1150:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    1154:	4f0c      	ldr	r7, [pc, #48]	; (1188 <z_arm_pendsv+0x50>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    1156:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    115a:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
    115c:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    115e:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    1160:	6e50      	ldr	r0, [r2, #100]	; 0x64
    movs r3, #0
    1162:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    1164:	6653      	str	r3, [r2, #100]	; 0x64
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    1166:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined (CONFIG_ARM_MPU)
    /* Re-program dynamic memory map */
    push {r2,lr}
    116a:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
    116c:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
    116e:	f006 ff57 	bl	8020 <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
    1172:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    1176:	f102 0028 	add.w	r0, r2, #40	; 0x28
    ldmia r0, {v1-v8, ip}
    117a:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
    mov r0, #0
    msr PSPLIM, r0
#endif /* CONFIG_BUILTIN_STACK_GUARD */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    117e:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
    1182:	4770      	bx	lr
    ldr r1, =_kernel
    1184:	20000f54 	.word	0x20000f54
    ldr v4, =_SCS_ICSR
    1188:	e000ed04 	.word	0xe000ed04

0000118c <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
    118c:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    1190:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    1192:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    1196:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    119a:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    119c:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    11a0:	2902      	cmp	r1, #2
    beq _oops
    11a2:	d0ff      	beq.n	11a4 <_oops>

000011a4 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    11a4:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    11a6:	f006 ff30 	bl	800a <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    11aa:	bd01      	pop	{r0, pc}

000011ac <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    11ac:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    11ae:	2b00      	cmp	r3, #0
    11b0:	db08      	blt.n	11c4 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    11b2:	2201      	movs	r2, #1
    11b4:	f000 001f 	and.w	r0, r0, #31
    11b8:	fa02 f000 	lsl.w	r0, r2, r0
    11bc:	095b      	lsrs	r3, r3, #5
    11be:	4a02      	ldr	r2, [pc, #8]	; (11c8 <arch_irq_enable+0x1c>)
    11c0:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    11c4:	4770      	bx	lr
    11c6:	bf00      	nop
    11c8:	e000e100 	.word	0xe000e100

000011cc <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(DT_NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    11cc:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    11ce:	2b00      	cmp	r3, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    11d0:	bfa8      	it	ge
    11d2:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
	prio += _IRQ_PRIO_OFFSET;
    11d6:	f101 0101 	add.w	r1, r1, #1
    11da:	ea4f 1141 	mov.w	r1, r1, lsl #5
    11de:	bfae      	itee	ge
    11e0:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    11e4:	f000 000f 	andlt.w	r0, r0, #15
    11e8:	4b03      	ldrlt	r3, [pc, #12]	; (11f8 <z_arm_irq_priority_set+0x2c>)
    11ea:	b2c9      	uxtb	r1, r1
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    11ec:	bfac      	ite	ge
    11ee:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    11f2:	5419      	strblt	r1, [r3, r0]
}
    11f4:	4770      	bx	lr
    11f6:	bf00      	nop
    11f8:	e000ed14 	.word	0xe000ed14

000011fc <arch_new_thread>:
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     size_t stackSize, k_thread_entry_t pEntry,
		     void *parameter1, void *parameter2, void *parameter3,
		     int priority, unsigned int options)
{
    11fc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    11fe:	461e      	mov	r6, r3
#endif
	stackEnd = pStackMem + stackSize;

	struct __esf *pInitCtx;

	z_new_thread_init(thread, pStackMem, stackSize, priority,
    1200:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1202:	9300      	str	r3, [sp, #0]
	stackEnd = pStackMem + stackSize;
    1204:	188c      	adds	r4, r1, r2
	z_new_thread_init(thread, pStackMem, stackSize, priority,
    1206:	9b09      	ldr	r3, [sp, #36]	; 0x24
{
    1208:	4605      	mov	r5, r0
	z_new_thread_init(thread, pStackMem, stackSize, priority,
    120a:	f009 fe33 	bl	ae74 <z_new_thread_init>
	 *
	 * The initial carved stack frame only needs to contain the basic
	 * stack frame (state context), because no FP operations have been
	 * performed yet for this thread.
	 */
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
    120e:	f1a4 0320 	sub.w	r3, r4, #32
	pInitCtx->basic.pc = (u32_t)z_thread_entry;
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
    1212:	4a0a      	ldr	r2, [pc, #40]	; (123c <arch_new_thread+0x40>)
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
    1214:	f023 0307 	bic.w	r3, r3, #7
	pInitCtx->basic.pc &= 0xfffffffe;
    1218:	f022 0201 	bic.w	r2, r2, #1
    121c:	619a      	str	r2, [r3, #24]
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
	pInitCtx->basic.a2 = (u32_t)parameter1;
    121e:	9a06      	ldr	r2, [sp, #24]
    1220:	605a      	str	r2, [r3, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
    1222:	9a07      	ldr	r2, [sp, #28]
    1224:	609a      	str	r2, [r3, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
    1226:	9a08      	ldr	r2, [sp, #32]
    1228:	60da      	str	r2, [r3, #12]
	pInitCtx->basic.xpsr =
    122a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
	pInitCtx->basic.a1 = (u32_t)pEntry;
    122e:	601e      	str	r6, [r3, #0]
	pInitCtx->basic.xpsr =
    1230:	61da      	str	r2, [r3, #28]
		0x01000000UL; /* clear all, thumb bit is 1, even if RO */

	thread->callee_saved.psp = (u32_t)pInitCtx;
    1232:	64ab      	str	r3, [r5, #72]	; 0x48
#if defined(CONFIG_CPU_CORTEX_R)
	pInitCtx->basic.lr = (u32_t)pInitCtx->basic.pc;
	thread->callee_saved.spsr = A_BIT | T_BIT | MODE_SYS;
	thread->callee_saved.lr = (u32_t)pInitCtx->basic.pc;
#endif
	thread->arch.basepri = 0;
    1234:	2300      	movs	r3, #0
    1236:	666b      	str	r3, [r5, #100]	; 0x64

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    1238:	b002      	add	sp, #8
    123a:	bd70      	pop	{r4, r5, r6, pc}
    123c:	00007ab7 	.word	0x00007ab7

00001240 <arch_switch_to_main_thread>:

void arch_switch_to_main_thread(struct k_thread *main_thread,
				k_thread_stack_t *main_stack,
				size_t main_stack_size,
				k_thread_entry_t _main)
{
    1240:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1242:	4605      	mov	r5, r0
    1244:	460c      	mov	r4, r1
    1246:	4617      	mov	r7, r2
    1248:	461e      	mov	r6, r3
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    124a:	f000 fb93 	bl	1974 <z_arm_configure_static_mpu_regions>
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);

	_current = main_thread;
    124e:	4b0a      	ldr	r3, [pc, #40]	; (1278 <arch_switch_to_main_thread+0x38>)
	start_of_main_stack =
    1250:	443c      	add	r4, r7
#ifdef CONFIG_ARM_MPU
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
    1252:	4628      	mov	r0, r5
	_current = main_thread;
    1254:	609d      	str	r5, [r3, #8]
	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);
    1256:	f024 0407 	bic.w	r4, r4, #7
	z_arm_configure_dynamic_mpu_regions(main_thread);
    125a:	f006 fee1 	bl	8020 <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    125e:	4630      	mov	r0, r6
    1260:	f384 8809 	msr	PSP, r4
    1264:	2100      	movs	r1, #0
    1266:	b663      	cpsie	if
    1268:	f381 8811 	msr	BASEPRI, r1
    126c:	f3bf 8f6f 	isb	sy
    1270:	2200      	movs	r2, #0
    1272:	2300      	movs	r3, #0
    1274:	f006 fc1f 	bl	7ab6 <z_thread_entry>
	:
	: "r" (_main), "r" (start_of_main_stack)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    1278:	20000f54 	.word	0x20000f54

0000127c <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr r1, =_SCB_SCR
    127c:	4901      	ldr	r1, [pc, #4]	; (1284 <z_arm_cpu_idle_init+0x8>)
	movs.n r2, #_SCR_INIT_BITS
    127e:	2210      	movs	r2, #16
	str r2, [r1]
    1280:	600a      	str	r2, [r1, #0]
#endif
	bx lr
    1282:	4770      	bx	lr
	ldr r1, =_SCB_SCR
    1284:	e000ed10 	.word	0xe000ed10

00001288 <arch_cpu_idle>:
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	cpsie i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* clear BASEPRI so wfi is awakened by incoming interrupts */
	eors.n r0, r0
    1288:	4040      	eors	r0, r0
	msr BASEPRI, r0
    128a:	f380 8811 	msr	BASEPRI, r0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	wfi
    128e:	bf30      	wfi

	bx lr
    1290:	4770      	bx	lr
    1292:	bf00      	nop

00001294 <z_arm_bus_fault>:
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_reserved)

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) || \
	defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	mrs r0, MSP
    1294:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    1298:	f3ef 8109 	mrs	r1, PSP
	mov r2, lr /* EXC_RETURN */
    129c:	4672      	mov	r2, lr

	push {r0, lr}
    129e:	b501      	push	{r0, lr}
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE || CONFIG_ARMv7_M_ARMV8_M_MAINLINE */

	bl z_arm_fault
    12a0:	f000 fa46 	bl	1730 <z_arm_fault>

#if defined(CONFIG_CPU_CORTEX_M)
	pop {r0, pc}
    12a4:	bd01      	pop	{r0, pc}
    12a6:	bf00      	nop

000012a8 <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    12a8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    12aa:	4606      	mov	r6, r0

	if (esf != NULL) {
    12ac:	460c      	mov	r4, r1
    12ae:	2900      	cmp	r1, #0
    12b0:	d038      	beq.n	1324 <z_arm_fatal_error+0x7c>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
    12b2:	2201      	movs	r2, #1
    12b4:	f04f 0300 	mov.w	r3, #0
    12b8:	f362 0307 	bfi	r3, r2, #0, #8
    12bc:	4d1d      	ldr	r5, [pc, #116]	; (1334 <z_arm_fatal_error+0x8c>)
    12be:	4a1e      	ldr	r2, [pc, #120]	; (1338 <z_arm_fatal_error+0x90>)
    12c0:	481e      	ldr	r0, [pc, #120]	; (133c <z_arm_fatal_error+0x94>)
    12c2:	1aad      	subs	r5, r5, r2
    12c4:	f3c5 05c9 	ubfx	r5, r5, #3, #10
    12c8:	f365 138f 	bfi	r3, r5, #6, #10
    12cc:	f8ad 3000 	strh.w	r3, [sp]
    12d0:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
    12d4:	6809      	ldr	r1, [r1, #0]
    12d6:	f006 fc75 	bl	7bc4 <log_3>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
    12da:	2201      	movs	r2, #1
    12dc:	f04f 0300 	mov.w	r3, #0
    12e0:	f362 0307 	bfi	r3, r2, #0, #8
    12e4:	f365 138f 	bfi	r3, r5, #6, #10
    12e8:	f8ad 3000 	strh.w	r3, [sp]
    12ec:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    12f0:	68e1      	ldr	r1, [r4, #12]
    12f2:	4813      	ldr	r0, [pc, #76]	; (1340 <z_arm_fatal_error+0x98>)
    12f4:	f006 fc66 	bl	7bc4 <log_3>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
    12f8:	2301      	movs	r3, #1
    12fa:	f04f 0200 	mov.w	r2, #0
    12fe:	f363 0207 	bfi	r2, r3, #0, #8
    1302:	f365 128f 	bfi	r2, r5, #6, #10
    1306:	69e1      	ldr	r1, [r4, #28]
    1308:	480e      	ldr	r0, [pc, #56]	; (1344 <z_arm_fatal_error+0x9c>)
    130a:	f006 fc2f 	bl	7b6c <log_1>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    130e:	f04f 0200 	mov.w	r2, #0
    1312:	2301      	movs	r3, #1
    1314:	f363 0207 	bfi	r2, r3, #0, #8
    1318:	f365 128f 	bfi	r2, r5, #6, #10
    131c:	69a1      	ldr	r1, [r4, #24]
    131e:	480a      	ldr	r0, [pc, #40]	; (1348 <z_arm_fatal_error+0xa0>)
    1320:	f006 fc24 	bl	7b6c <log_1>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
    1324:	4621      	mov	r1, r4
    1326:	4630      	mov	r0, r6
}
    1328:	b002      	add	sp, #8
    132a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_fatal_error(reason, esf);
    132e:	f005 ba2b 	b.w	6788 <z_fatal_error>
    1332:	bf00      	nop
    1334:	0000b1bc 	.word	0x0000b1bc
    1338:	0000b17c 	.word	0x0000b17c
    133c:	0000baa5 	.word	0x0000baa5
    1340:	0000bad4 	.word	0x0000bad4
    1344:	0000bb03 	.word	0x0000bb03
    1348:	0000bb12 	.word	0x0000bb12

0000134c <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    134c:	bf30      	wfi
    b z_SysNmiOnReset
    134e:	f7ff bffd 	b.w	134c <z_SysNmiOnReset>
    1352:	bf00      	nop

00001354 <z_arm_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    1354:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    1356:	4b08      	ldr	r3, [pc, #32]	; (1378 <z_arm_prep_c+0x24>)
    1358:	4a08      	ldr	r2, [pc, #32]	; (137c <z_arm_prep_c+0x28>)
    135a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    135e:	6093      	str	r3, [r2, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    1360:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    1364:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
	enable_floating_point();
	z_bss_zero();
    1368:	f005 fa8c 	bl	6884 <z_bss_zero>
	z_data_copy();
    136c:	f005 fa94 	bl	6898 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_int_lib_init();
    1370:	f000 face 	bl	1910 <z_arm_int_lib_init>
	z_cstart();
    1374:	f005 fac2 	bl	68fc <z_cstart>
    1378:	00000000 	.word	0x00000000
    137c:	e000ed00 	.word	0xe000ed00

00001380 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    1380:	b501      	push	{r0, lr}
      * FIXME: Remove the Cortex-M conditional compilation checks for `cpsid i`
      *        and `cpsie i` after the Cortex-R port is updated to support
      *        interrupt nesting.  For more details, refer to the issue #21758.
      */
#if defined(CONFIG_CPU_CORTEX_M)
	cpsid i  /* PRIMASK = 1 */
    1382:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    1384:	4a0b      	ldr	r2, [pc, #44]	; (13b4 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    1386:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
    1388:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    138a:	bf1e      	ittt	ne
	movne	r1, #0
    138c:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    138e:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
    1390:	f009 fc51 	blne	ac36 <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    1394:	b662      	cpsie	i
#endif

#endif /* CONFIG_SYS_POWER_MANAGEMENT */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    1396:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    139a:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    139e:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 */
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldr r1, =_sw_isr_table
    13a2:	4905      	ldr	r1, [pc, #20]	; (13b8 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    13a4:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    13a6:	c909      	ldmia	r1!, {r0, r3}
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldm sp!,{r0-r3} /* Restore r0 to r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
    13a8:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    13aa:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    13ae:	4903      	ldr	r1, [pc, #12]	; (13bc <_isr_wrapper+0x3c>)
	bx r1
    13b0:	4708      	bx	r1
    13b2:	0000      	.short	0x0000
	ldr r2, =_kernel
    13b4:	20000f54 	.word	0x20000f54
	ldr r1, =_sw_isr_table
    13b8:	0000afa8 	.word	0x0000afa8
	ldr r1, =z_arm_int_exit
    13bc:	000010e9 	.word	0x000010e9

000013c0 <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
    13c0:	f007 f8bc 	bl	853c <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    13c4:	2020      	movs	r0, #32
    msr BASEPRI, r0
    13c6:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to _interrupt_stack during initialization.
     */
    ldr r0, =_interrupt_stack
    13ca:	4808      	ldr	r0, [pc, #32]	; (13ec <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
    13cc:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
    13d0:	1840      	adds	r0, r0, r1
    msr PSP, r0
    13d2:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    13d6:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    13da:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    13dc:	4308      	orrs	r0, r1
    msr CONTROL, r0
    13de:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    13e2:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    13e6:	f7ff ffb5 	bl	1354 <z_arm_prep_c>
    13ea:	0000      	.short	0x0000
    ldr r0, =_interrupt_stack
    13ec:	20005b68 	.word	0x20005b68

000013f0 <usage_fault.isra.2>:
 */
static u32_t usage_fault(const z_arch_esf_t *esf)
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
    13f0:	2301      	movs	r3, #1
    13f2:	f04f 0100 	mov.w	r1, #0
static u32_t usage_fault(const z_arch_esf_t *esf)
    13f6:	b510      	push	{r4, lr}
	PR_FAULT_INFO("***** USAGE FAULT *****");
    13f8:	f363 0107 	bfi	r1, r3, #0, #8
    13fc:	4c33      	ldr	r4, [pc, #204]	; (14cc <usage_fault.isra.2+0xdc>)
    13fe:	4b34      	ldr	r3, [pc, #208]	; (14d0 <usage_fault.isra.2+0xe0>)
    1400:	4834      	ldr	r0, [pc, #208]	; (14d4 <usage_fault.isra.2+0xe4>)
    1402:	1ae4      	subs	r4, r4, r3
    1404:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    1408:	f364 118f 	bfi	r1, r4, #6, #10
    140c:	f006 fba1 	bl	7b52 <log_0>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    1410:	4b31      	ldr	r3, [pc, #196]	; (14d8 <usage_fault.isra.2+0xe8>)
    1412:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1414:	019a      	lsls	r2, r3, #6
    1416:	d509      	bpl.n	142c <usage_fault.isra.2+0x3c>
		PR_FAULT_INFO("  Division by zero");
    1418:	f04f 0100 	mov.w	r1, #0
    141c:	2301      	movs	r3, #1
    141e:	f363 0107 	bfi	r1, r3, #0, #8
    1422:	f364 118f 	bfi	r1, r4, #6, #10
    1426:	482d      	ldr	r0, [pc, #180]	; (14dc <usage_fault.isra.2+0xec>)
    1428:	f006 fb93 	bl	7b52 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    142c:	4b2a      	ldr	r3, [pc, #168]	; (14d8 <usage_fault.isra.2+0xe8>)
    142e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1430:	01db      	lsls	r3, r3, #7
    1432:	d509      	bpl.n	1448 <usage_fault.isra.2+0x58>
		PR_FAULT_INFO("  Unaligned memory access");
    1434:	f04f 0100 	mov.w	r1, #0
    1438:	2301      	movs	r3, #1
    143a:	f363 0107 	bfi	r1, r3, #0, #8
    143e:	f364 118f 	bfi	r1, r4, #6, #10
    1442:	4827      	ldr	r0, [pc, #156]	; (14e0 <usage_fault.isra.2+0xf0>)
    1444:	f006 fb85 	bl	7b52 <log_0>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    1448:	4b23      	ldr	r3, [pc, #140]	; (14d8 <usage_fault.isra.2+0xe8>)
    144a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    144c:	0318      	lsls	r0, r3, #12
    144e:	d509      	bpl.n	1464 <usage_fault.isra.2+0x74>
		PR_FAULT_INFO("  No coprocessor instructions");
    1450:	f04f 0100 	mov.w	r1, #0
    1454:	2301      	movs	r3, #1
    1456:	f363 0107 	bfi	r1, r3, #0, #8
    145a:	f364 118f 	bfi	r1, r4, #6, #10
    145e:	4821      	ldr	r0, [pc, #132]	; (14e4 <usage_fault.isra.2+0xf4>)
    1460:	f006 fb77 	bl	7b52 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    1464:	4b1c      	ldr	r3, [pc, #112]	; (14d8 <usage_fault.isra.2+0xe8>)
    1466:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1468:	0359      	lsls	r1, r3, #13
    146a:	d509      	bpl.n	1480 <usage_fault.isra.2+0x90>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
    146c:	f04f 0100 	mov.w	r1, #0
    1470:	2301      	movs	r3, #1
    1472:	f363 0107 	bfi	r1, r3, #0, #8
    1476:	f364 118f 	bfi	r1, r4, #6, #10
    147a:	481b      	ldr	r0, [pc, #108]	; (14e8 <usage_fault.isra.2+0xf8>)
    147c:	f006 fb69 	bl	7b52 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    1480:	4b15      	ldr	r3, [pc, #84]	; (14d8 <usage_fault.isra.2+0xe8>)
    1482:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1484:	039a      	lsls	r2, r3, #14
    1486:	d509      	bpl.n	149c <usage_fault.isra.2+0xac>
		PR_FAULT_INFO("  Illegal use of the EPSR");
    1488:	f04f 0100 	mov.w	r1, #0
    148c:	2301      	movs	r3, #1
    148e:	f363 0107 	bfi	r1, r3, #0, #8
    1492:	f364 118f 	bfi	r1, r4, #6, #10
    1496:	4815      	ldr	r0, [pc, #84]	; (14ec <usage_fault.isra.2+0xfc>)
    1498:	f006 fb5b 	bl	7b52 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    149c:	4b0e      	ldr	r3, [pc, #56]	; (14d8 <usage_fault.isra.2+0xe8>)
    149e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    14a0:	03db      	lsls	r3, r3, #15
    14a2:	d509      	bpl.n	14b8 <usage_fault.isra.2+0xc8>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
    14a4:	f04f 0100 	mov.w	r1, #0
    14a8:	2301      	movs	r3, #1
    14aa:	f363 0107 	bfi	r1, r3, #0, #8
    14ae:	f364 118f 	bfi	r1, r4, #6, #10
    14b2:	480f      	ldr	r0, [pc, #60]	; (14f0 <usage_fault.isra.2+0x100>)
    14b4:	f006 fb4d 	bl	7b52 <log_0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    14b8:	4a07      	ldr	r2, [pc, #28]	; (14d8 <usage_fault.isra.2+0xe8>)
    14ba:	6a93      	ldr	r3, [r2, #40]	; 0x28
    14bc:	ea6f 4303 	mvn.w	r3, r3, lsl #16
    14c0:	ea6f 4313 	mvn.w	r3, r3, lsr #16
    14c4:	6293      	str	r3, [r2, #40]	; 0x28

	return reason;
}
    14c6:	2000      	movs	r0, #0
    14c8:	bd10      	pop	{r4, pc}
    14ca:	bf00      	nop
    14cc:	0000b1bc 	.word	0x0000b1bc
    14d0:	0000b17c 	.word	0x0000b17c
    14d4:	0000bca0 	.word	0x0000bca0
    14d8:	e000ed00 	.word	0xe000ed00
    14dc:	0000bcb8 	.word	0x0000bcb8
    14e0:	0000bccb 	.word	0x0000bccb
    14e4:	0000bce5 	.word	0x0000bce5
    14e8:	0000bd03 	.word	0x0000bd03
    14ec:	0000bd28 	.word	0x0000bd28
    14f0:	0000bd42 	.word	0x0000bd42

000014f4 <mem_manage_fault.isra.4>:
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
    14f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	PR_FAULT_INFO("***** MPU FAULT *****");
    14f6:	2301      	movs	r3, #1
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
    14f8:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
    14fa:	f04f 0100 	mov.w	r1, #0
    14fe:	f363 0107 	bfi	r1, r3, #0, #8
    1502:	4c36      	ldr	r4, [pc, #216]	; (15dc <mem_manage_fault.isra.4+0xe8>)
    1504:	4b36      	ldr	r3, [pc, #216]	; (15e0 <mem_manage_fault.isra.4+0xec>)
    1506:	1ae4      	subs	r4, r4, r3
    1508:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    150c:	f364 118f 	bfi	r1, r4, #6, #10
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
    1510:	4607      	mov	r7, r0
	PR_FAULT_INFO("***** MPU FAULT *****");
    1512:	4834      	ldr	r0, [pc, #208]	; (15e4 <mem_manage_fault.isra.4+0xf0>)
    1514:	f006 fb1d 	bl	7b52 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    1518:	4b33      	ldr	r3, [pc, #204]	; (15e8 <mem_manage_fault.isra.4+0xf4>)
    151a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    151c:	06d9      	lsls	r1, r3, #27
    151e:	d509      	bpl.n	1534 <mem_manage_fault.isra.4+0x40>
		PR_FAULT_INFO("  Stacking error (context area might be"
    1520:	f04f 0100 	mov.w	r1, #0
    1524:	2301      	movs	r3, #1
    1526:	f363 0107 	bfi	r1, r3, #0, #8
    152a:	f364 118f 	bfi	r1, r4, #6, #10
    152e:	482f      	ldr	r0, [pc, #188]	; (15ec <mem_manage_fault.isra.4+0xf8>)
    1530:	f006 fb0f 	bl	7b52 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    1534:	4b2c      	ldr	r3, [pc, #176]	; (15e8 <mem_manage_fault.isra.4+0xf4>)
    1536:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1538:	071a      	lsls	r2, r3, #28
    153a:	d509      	bpl.n	1550 <mem_manage_fault.isra.4+0x5c>
		PR_FAULT_INFO("  Unstacking error");
    153c:	f04f 0100 	mov.w	r1, #0
    1540:	2301      	movs	r3, #1
    1542:	f363 0107 	bfi	r1, r3, #0, #8
    1546:	f364 118f 	bfi	r1, r4, #6, #10
    154a:	4829      	ldr	r0, [pc, #164]	; (15f0 <mem_manage_fault.isra.4+0xfc>)
    154c:	f006 fb01 	bl	7b52 <log_0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    1550:	4d25      	ldr	r5, [pc, #148]	; (15e8 <mem_manage_fault.isra.4+0xf4>)
    1552:	6aab      	ldr	r3, [r5, #40]	; 0x28
    1554:	079b      	lsls	r3, r3, #30
    1556:	d51c      	bpl.n	1592 <mem_manage_fault.isra.4+0x9e>
		PR_FAULT_INFO("  Data Access Violation");
    1558:	2301      	movs	r3, #1
    155a:	f04f 0100 	mov.w	r1, #0
    155e:	f363 0107 	bfi	r1, r3, #0, #8
    1562:	f364 118f 	bfi	r1, r4, #6, #10
    1566:	4823      	ldr	r0, [pc, #140]	; (15f4 <mem_manage_fault.isra.4+0x100>)
    1568:	f006 faf3 	bl	7b52 <log_0>
		mmfar = SCB->MMFAR;
    156c:	6b69      	ldr	r1, [r5, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    156e:	6aab      	ldr	r3, [r5, #40]	; 0x28
    1570:	0618      	lsls	r0, r3, #24
    1572:	d50e      	bpl.n	1592 <mem_manage_fault.isra.4+0x9e>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
    1574:	f04f 0200 	mov.w	r2, #0
    1578:	2301      	movs	r3, #1
    157a:	f363 0207 	bfi	r2, r3, #0, #8
    157e:	f364 128f 	bfi	r2, r4, #6, #10
    1582:	481d      	ldr	r0, [pc, #116]	; (15f8 <mem_manage_fault.isra.4+0x104>)
    1584:	f006 faf2 	bl	7b6c <log_1>
			if (from_hard_fault) {
    1588:	b11f      	cbz	r7, 1592 <mem_manage_fault.isra.4+0x9e>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    158a:	6aab      	ldr	r3, [r5, #40]	; 0x28
    158c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    1590:	62ab      	str	r3, [r5, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    1592:	4b15      	ldr	r3, [pc, #84]	; (15e8 <mem_manage_fault.isra.4+0xf4>)
    1594:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1596:	07da      	lsls	r2, r3, #31
    1598:	d509      	bpl.n	15ae <mem_manage_fault.isra.4+0xba>
		PR_FAULT_INFO("  Instruction Access Violation");
    159a:	f04f 0100 	mov.w	r1, #0
    159e:	2301      	movs	r3, #1
    15a0:	f363 0107 	bfi	r1, r3, #0, #8
    15a4:	f364 118f 	bfi	r1, r4, #6, #10
    15a8:	4814      	ldr	r0, [pc, #80]	; (15fc <mem_manage_fault.isra.4+0x108>)
    15aa:	f006 fad2 	bl	7b52 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    15ae:	4b0e      	ldr	r3, [pc, #56]	; (15e8 <mem_manage_fault.isra.4+0xf4>)
    15b0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    15b2:	069b      	lsls	r3, r3, #26
    15b4:	d509      	bpl.n	15ca <mem_manage_fault.isra.4+0xd6>
		PR_FAULT_INFO(
    15b6:	f04f 0100 	mov.w	r1, #0
    15ba:	2301      	movs	r3, #1
    15bc:	f363 0107 	bfi	r1, r3, #0, #8
    15c0:	f364 118f 	bfi	r1, r4, #6, #10
    15c4:	480e      	ldr	r0, [pc, #56]	; (1600 <mem_manage_fault.isra.4+0x10c>)
    15c6:	f006 fac4 	bl	7b52 <log_0>
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
    15ca:	4b07      	ldr	r3, [pc, #28]	; (15e8 <mem_manage_fault.isra.4+0xf4>)
    15cc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    15ce:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    15d0:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    15d2:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
    15d6:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    15d8:	7030      	strb	r0, [r6, #0]
}
    15da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    15dc:	0000b1bc 	.word	0x0000b1bc
    15e0:	0000b17c 	.word	0x0000b17c
    15e4:	0000bbc8 	.word	0x0000bbc8
    15e8:	e000ed00 	.word	0xe000ed00
    15ec:	0000bbde 	.word	0x0000bbde
    15f0:	0000bc11 	.word	0x0000bc11
    15f4:	0000bc24 	.word	0x0000bc24
    15f8:	0000bc3c 	.word	0x0000bc3c
    15fc:	0000bc52 	.word	0x0000bc52
    1600:	0000bc71 	.word	0x0000bc71

00001604 <bus_fault.isra.5>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    1604:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	PR_FAULT_INFO("***** BUS FAULT *****");
    1606:	2301      	movs	r3, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    1608:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
    160a:	f04f 0100 	mov.w	r1, #0
    160e:	f363 0107 	bfi	r1, r3, #0, #8
    1612:	4c3c      	ldr	r4, [pc, #240]	; (1704 <bus_fault.isra.5+0x100>)
    1614:	4b3c      	ldr	r3, [pc, #240]	; (1708 <bus_fault.isra.5+0x104>)
    1616:	1ae4      	subs	r4, r4, r3
    1618:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    161c:	f364 118f 	bfi	r1, r4, #6, #10
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    1620:	4607      	mov	r7, r0
	PR_FAULT_INFO("***** BUS FAULT *****");
    1622:	483a      	ldr	r0, [pc, #232]	; (170c <bus_fault.isra.5+0x108>)
    1624:	f006 fa95 	bl	7b52 <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    1628:	4b39      	ldr	r3, [pc, #228]	; (1710 <bus_fault.isra.5+0x10c>)
    162a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    162c:	04d9      	lsls	r1, r3, #19
    162e:	d509      	bpl.n	1644 <bus_fault.isra.5+0x40>
		PR_FAULT_INFO("  Stacking error");
    1630:	f04f 0100 	mov.w	r1, #0
    1634:	2301      	movs	r3, #1
    1636:	f363 0107 	bfi	r1, r3, #0, #8
    163a:	f364 118f 	bfi	r1, r4, #6, #10
    163e:	4835      	ldr	r0, [pc, #212]	; (1714 <bus_fault.isra.5+0x110>)
    1640:	f006 fa87 	bl	7b52 <log_0>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    1644:	4b32      	ldr	r3, [pc, #200]	; (1710 <bus_fault.isra.5+0x10c>)
    1646:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1648:	051a      	lsls	r2, r3, #20
    164a:	d509      	bpl.n	1660 <bus_fault.isra.5+0x5c>
		PR_FAULT_INFO("  Unstacking error");
    164c:	f04f 0100 	mov.w	r1, #0
    1650:	2301      	movs	r3, #1
    1652:	f363 0107 	bfi	r1, r3, #0, #8
    1656:	f364 118f 	bfi	r1, r4, #6, #10
    165a:	482f      	ldr	r0, [pc, #188]	; (1718 <bus_fault.isra.5+0x114>)
    165c:	f006 fa79 	bl	7b52 <log_0>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    1660:	4d2b      	ldr	r5, [pc, #172]	; (1710 <bus_fault.isra.5+0x10c>)
    1662:	6aab      	ldr	r3, [r5, #40]	; 0x28
    1664:	059b      	lsls	r3, r3, #22
    1666:	d51c      	bpl.n	16a2 <bus_fault.isra.5+0x9e>
		PR_FAULT_INFO("  Precise data bus error");
    1668:	2301      	movs	r3, #1
    166a:	f04f 0100 	mov.w	r1, #0
    166e:	f363 0107 	bfi	r1, r3, #0, #8
    1672:	f364 118f 	bfi	r1, r4, #6, #10
    1676:	4829      	ldr	r0, [pc, #164]	; (171c <bus_fault.isra.5+0x118>)
    1678:	f006 fa6b 	bl	7b52 <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
    167c:	6ba9      	ldr	r1, [r5, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    167e:	6aab      	ldr	r3, [r5, #40]	; 0x28
    1680:	0418      	lsls	r0, r3, #16
    1682:	d50e      	bpl.n	16a2 <bus_fault.isra.5+0x9e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
    1684:	f04f 0200 	mov.w	r2, #0
    1688:	2301      	movs	r3, #1
    168a:	f363 0207 	bfi	r2, r3, #0, #8
    168e:	f364 128f 	bfi	r2, r4, #6, #10
    1692:	4823      	ldr	r0, [pc, #140]	; (1720 <bus_fault.isra.5+0x11c>)
    1694:	f006 fa6a 	bl	7b6c <log_1>
			if (from_hard_fault) {
    1698:	b11f      	cbz	r7, 16a2 <bus_fault.isra.5+0x9e>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    169a:	6aab      	ldr	r3, [r5, #40]	; 0x28
    169c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    16a0:	62ab      	str	r3, [r5, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    16a2:	4b1b      	ldr	r3, [pc, #108]	; (1710 <bus_fault.isra.5+0x10c>)
    16a4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    16a6:	0559      	lsls	r1, r3, #21
    16a8:	d509      	bpl.n	16be <bus_fault.isra.5+0xba>
		PR_FAULT_INFO("  Imprecise data bus error");
    16aa:	f04f 0100 	mov.w	r1, #0
    16ae:	2301      	movs	r3, #1
    16b0:	f363 0107 	bfi	r1, r3, #0, #8
    16b4:	f364 118f 	bfi	r1, r4, #6, #10
    16b8:	481a      	ldr	r0, [pc, #104]	; (1724 <bus_fault.isra.5+0x120>)
    16ba:	f006 fa4a 	bl	7b52 <log_0>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    16be:	4b14      	ldr	r3, [pc, #80]	; (1710 <bus_fault.isra.5+0x10c>)
    16c0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    16c2:	05d2      	lsls	r2, r2, #23
    16c4:	d511      	bpl.n	16ea <bus_fault.isra.5+0xe6>
		PR_FAULT_INFO("  Instruction bus error");
    16c6:	f04f 0100 	mov.w	r1, #0
    16ca:	2301      	movs	r3, #1
    16cc:	f363 0107 	bfi	r1, r3, #0, #8
    16d0:	4815      	ldr	r0, [pc, #84]	; (1728 <bus_fault.isra.5+0x124>)
    16d2:	f364 118f 	bfi	r1, r4, #6, #10
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    16d6:	f006 fa3c 	bl	7b52 <log_0>
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    16da:	4a0d      	ldr	r2, [pc, #52]	; (1710 <bus_fault.isra.5+0x10c>)
    16dc:	6a93      	ldr	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    16de:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    16e0:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
    16e4:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    16e6:	7030      	strb	r0, [r6, #0]
}
    16e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    16ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    16ec:	049b      	lsls	r3, r3, #18
    16ee:	d5f4      	bpl.n	16da <bus_fault.isra.5+0xd6>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    16f0:	f04f 0100 	mov.w	r1, #0
    16f4:	2301      	movs	r3, #1
    16f6:	f363 0107 	bfi	r1, r3, #0, #8
    16fa:	f364 118f 	bfi	r1, r4, #6, #10
    16fe:	480b      	ldr	r0, [pc, #44]	; (172c <bus_fault.isra.5+0x128>)
    1700:	e7e9      	b.n	16d6 <bus_fault.isra.5+0xd2>
    1702:	bf00      	nop
    1704:	0000b1bc 	.word	0x0000b1bc
    1708:	0000b17c 	.word	0x0000b17c
    170c:	0000bb40 	.word	0x0000bb40
    1710:	e000ed00 	.word	0xe000ed00
    1714:	0000bb56 	.word	0x0000bb56
    1718:	0000bc11 	.word	0x0000bc11
    171c:	0000bb67 	.word	0x0000bb67
    1720:	0000bb80 	.word	0x0000bb80
    1724:	0000bb95 	.word	0x0000bb95
    1728:	0000bbb0 	.word	0x0000bbb0
    172c:	0000bc71 	.word	0x0000bc71

00001730 <z_arm_fault>:
 * @param psp PSP value immediately after the exception occurred
 * @param exc_return EXC_RETURN value present in LR after exception entry.
 *
 */
void z_arm_fault(u32_t msp, u32_t psp, u32_t exc_return)
{
    1730:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    1734:	4b64      	ldr	r3, [pc, #400]	; (18c8 <z_arm_fault+0x198>)
    1736:	685e      	ldr	r6, [r3, #4]
{
    1738:	b08a      	sub	sp, #40	; 0x28
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    173a:	f3c6 0408 	ubfx	r4, r6, #0, #9
    173e:	2500      	movs	r5, #0
    1740:	f385 8811 	msr	BASEPRI, r5
    1744:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    1748:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
    174c:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
    1750:	d111      	bne.n	1776 <z_arm_fault+0x46>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    1752:	f002 030c 	and.w	r3, r2, #12
    1756:	2b08      	cmp	r3, #8
    1758:	d10f      	bne.n	177a <z_arm_fault+0x4a>
		PR_EXC("SPSEL in thread mode does not indicate PSP");
    175a:	2301      	movs	r3, #1
    175c:	f04f 0100 	mov.w	r1, #0
    1760:	f363 0107 	bfi	r1, r3, #0, #8
    1764:	4a59      	ldr	r2, [pc, #356]	; (18cc <z_arm_fault+0x19c>)
    1766:	4b5a      	ldr	r3, [pc, #360]	; (18d0 <z_arm_fault+0x1a0>)
    1768:	485a      	ldr	r0, [pc, #360]	; (18d4 <z_arm_fault+0x1a4>)
    176a:	1a9b      	subs	r3, r3, r2
    176c:	08db      	lsrs	r3, r3, #3
    176e:	f363 118f 	bfi	r1, r3, #6, #10
    1772:	f006 f9ee 	bl	7b52 <log_0>
		return NULL;
    1776:	462f      	mov	r7, r5
    1778:	e004      	b.n	1784 <z_arm_fault+0x54>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    177a:	0712      	lsls	r2, r2, #28
			ptr_esf =  (z_arch_esf_t *)psp;
    177c:	bf4e      	itee	mi
    177e:	460f      	movmi	r7, r1
			ptr_esf = (z_arch_esf_t *)msp;
    1780:	4607      	movpl	r7, r0
			*nested_exc = true;
    1782:	2501      	movpl	r5, #1
	*recoverable = false;
    1784:	2300      	movs	r3, #0
    1786:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
    178a:	1ee3      	subs	r3, r4, #3
    178c:	2b09      	cmp	r3, #9
    178e:	d87f      	bhi.n	1890 <z_arm_fault+0x160>
    1790:	e8df f003 	tbb	[pc, r3]
    1794:	4c6d6905 	.word	0x4c6d6905
    1798:	7e7e7e7e 	.word	0x7e7e7e7e
    179c:	717e      	.short	0x717e
	PR_FAULT_INFO("***** HARD FAULT *****");
    179e:	2301      	movs	r3, #1
    17a0:	f04f 0100 	mov.w	r1, #0
    17a4:	f363 0107 	bfi	r1, r3, #0, #8
    17a8:	4e49      	ldr	r6, [pc, #292]	; (18d0 <z_arm_fault+0x1a0>)
    17aa:	4b48      	ldr	r3, [pc, #288]	; (18cc <z_arm_fault+0x19c>)
    17ac:	484a      	ldr	r0, [pc, #296]	; (18d8 <z_arm_fault+0x1a8>)
    17ae:	1af6      	subs	r6, r6, r3
    17b0:	f3c6 06c9 	ubfx	r6, r6, #3, #10
    17b4:	f366 118f 	bfi	r1, r6, #6, #10
    17b8:	f006 f9cb 	bl	7b52 <log_0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    17bc:	4b42      	ldr	r3, [pc, #264]	; (18c8 <z_arm_fault+0x198>)
    17be:	6adc      	ldr	r4, [r3, #44]	; 0x2c
	*recoverable = false;
    17c0:	f04f 0800 	mov.w	r8, #0
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    17c4:	f014 0402 	ands.w	r4, r4, #2
	*recoverable = false;
    17c8:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    17cc:	d00b      	beq.n	17e6 <z_arm_fault+0xb6>
		PR_EXC("  Bus fault on vector table read");
    17ce:	f04f 0100 	mov.w	r1, #0
    17d2:	2301      	movs	r3, #1
    17d4:	f363 0107 	bfi	r1, r3, #0, #8
    17d8:	4840      	ldr	r0, [pc, #256]	; (18dc <z_arm_fault+0x1ac>)
    17da:	f366 118f 	bfi	r1, r6, #6, #10
	PR_FAULT_INFO(
    17de:	f006 f9b8 	bl	7b52 <log_0>
	u32_t reason = K_ERR_CPU_EXCEPTION;
    17e2:	2400      	movs	r4, #0
    17e4:	e025      	b.n	1832 <z_arm_fault+0x102>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    17e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    17e8:	005b      	lsls	r3, r3, #1
    17ea:	d522      	bpl.n	1832 <z_arm_fault+0x102>
		PR_EXC("  Fault escalation (see below)");
    17ec:	2301      	movs	r3, #1
    17ee:	f04f 0100 	mov.w	r1, #0
    17f2:	f363 0107 	bfi	r1, r3, #0, #8
    17f6:	f366 118f 	bfi	r1, r6, #6, #10
    17fa:	4839      	ldr	r0, [pc, #228]	; (18e0 <z_arm_fault+0x1b0>)
    17fc:	f006 f9a9 	bl	7b52 <log_0>
		if (SCB_MMFSR != 0) {
    1800:	4b38      	ldr	r3, [pc, #224]	; (18e4 <z_arm_fault+0x1b4>)
    1802:	781b      	ldrb	r3, [r3, #0]
    1804:	b12b      	cbz	r3, 1812 <z_arm_fault+0xe2>
			reason = mem_manage_fault(esf, 1, recoverable);
    1806:	f10d 0107 	add.w	r1, sp, #7
    180a:	2001      	movs	r0, #1
		reason = mem_manage_fault(esf, 0, recoverable);
    180c:	f7ff fe72 	bl	14f4 <mem_manage_fault.isra.4>
    1810:	e00e      	b.n	1830 <z_arm_fault+0x100>
		} else if (SCB_BFSR != 0) {
    1812:	4b35      	ldr	r3, [pc, #212]	; (18e8 <z_arm_fault+0x1b8>)
    1814:	781b      	ldrb	r3, [r3, #0]
    1816:	b12b      	cbz	r3, 1824 <z_arm_fault+0xf4>
			reason = bus_fault(esf, 1, recoverable);
    1818:	f10d 0107 	add.w	r1, sp, #7
    181c:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
    181e:	f7ff fef1 	bl	1604 <bus_fault.isra.5>
    1822:	e005      	b.n	1830 <z_arm_fault+0x100>
		} else if (SCB_UFSR != 0) {
    1824:	4b31      	ldr	r3, [pc, #196]	; (18ec <z_arm_fault+0x1bc>)
    1826:	881b      	ldrh	r3, [r3, #0]
    1828:	b29b      	uxth	r3, r3
    182a:	b113      	cbz	r3, 1832 <z_arm_fault+0x102>
			reason = usage_fault(esf);
    182c:	f7ff fde0 	bl	13f0 <usage_fault.isra.2>
    1830:	4604      	mov	r4, r0
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
		"ESF could not be retrieved successfully. Shall never occur.");

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
    1832:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1836:	b99b      	cbnz	r3, 1860 <z_arm_fault+0x130>
		return;
	}

	/* Copy ESF */
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    1838:	2220      	movs	r2, #32
    183a:	4639      	mov	r1, r7
    183c:	a802      	add	r0, sp, #8
    183e:	f006 fc35 	bl	80ac <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    1842:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1844:	2d00      	cmp	r5, #0
    1846:	d03a      	beq.n	18be <z_arm_fault+0x18e>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    1848:	f3c3 0208 	ubfx	r2, r3, #0, #9
    184c:	b922      	cbnz	r2, 1858 <z_arm_fault+0x128>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    184e:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    1852:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    1856:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
    1858:	a902      	add	r1, sp, #8
    185a:	4620      	mov	r0, r4
    185c:	f7ff fd24 	bl	12a8 <z_arm_fatal_error>
}
    1860:	b00a      	add	sp, #40	; 0x28
    1862:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
    1866:	f10d 0107 	add.w	r1, sp, #7
    186a:	2000      	movs	r0, #0
    186c:	e7ce      	b.n	180c <z_arm_fault+0xdc>
		reason = bus_fault(esf, 0, recoverable);
    186e:	f10d 0107 	add.w	r1, sp, #7
    1872:	2000      	movs	r0, #0
    1874:	e7d3      	b.n	181e <z_arm_fault+0xee>
	PR_FAULT_INFO(
    1876:	2301      	movs	r3, #1
    1878:	f04f 0100 	mov.w	r1, #0
    187c:	f363 0107 	bfi	r1, r3, #0, #8
    1880:	4a12      	ldr	r2, [pc, #72]	; (18cc <z_arm_fault+0x19c>)
    1882:	4b13      	ldr	r3, [pc, #76]	; (18d0 <z_arm_fault+0x1a0>)
    1884:	481a      	ldr	r0, [pc, #104]	; (18f0 <z_arm_fault+0x1c0>)
    1886:	1a9b      	subs	r3, r3, r2
    1888:	08db      	lsrs	r3, r3, #3
    188a:	f363 118f 	bfi	r1, r3, #6, #10
    188e:	e7a6      	b.n	17de <z_arm_fault+0xae>
	PR_FAULT_INFO("***** %s %d) *****",
    1890:	2201      	movs	r2, #1
    1892:	f04f 0300 	mov.w	r3, #0
    1896:	f362 0307 	bfi	r3, r2, #0, #8
    189a:	490d      	ldr	r1, [pc, #52]	; (18d0 <z_arm_fault+0x1a0>)
    189c:	4a0b      	ldr	r2, [pc, #44]	; (18cc <z_arm_fault+0x19c>)
    189e:	4815      	ldr	r0, [pc, #84]	; (18f4 <z_arm_fault+0x1c4>)
    18a0:	1a89      	subs	r1, r1, r2
    18a2:	08c9      	lsrs	r1, r1, #3
    18a4:	f416 7ff8 	tst.w	r6, #496	; 0x1f0
    18a8:	f361 138f 	bfi	r3, r1, #6, #10
    18ac:	f1a4 0210 	sub.w	r2, r4, #16
    18b0:	4911      	ldr	r1, [pc, #68]	; (18f8 <z_arm_fault+0x1c8>)
    18b2:	bf18      	it	ne
    18b4:	4601      	movne	r1, r0
    18b6:	4811      	ldr	r0, [pc, #68]	; (18fc <z_arm_fault+0x1cc>)
    18b8:	f006 f96c 	bl	7b94 <log_2>
    18bc:	e791      	b.n	17e2 <z_arm_fault+0xb2>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    18be:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    18c2:	f023 0301 	bic.w	r3, r3, #1
    18c6:	e7c6      	b.n	1856 <z_arm_fault+0x126>
    18c8:	e000ed00 	.word	0xe000ed00
    18cc:	0000b17c 	.word	0x0000b17c
    18d0:	0000b1bc 	.word	0x0000b1bc
    18d4:	0000bd6d 	.word	0x0000bd6d
    18d8:	0000bd98 	.word	0x0000bd98
    18dc:	0000bdaf 	.word	0x0000bdaf
    18e0:	0000bdd0 	.word	0x0000bdd0
    18e4:	e000ed28 	.word	0xe000ed28
    18e8:	e000ed29 	.word	0xe000ed29
    18ec:	e000ed2a 	.word	0xe000ed2a
    18f0:	0000bdef 	.word	0x0000bdef
    18f4:	0000be3a 	.word	0x0000be3a
    18f8:	0000be25 	.word	0x0000be25
    18fc:	0000be53 	.word	0x0000be53

00001900 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    1900:	4a02      	ldr	r2, [pc, #8]	; (190c <z_arm_fault_init+0xc>)
    1902:	6953      	ldr	r3, [r2, #20]
    1904:	f043 0310 	orr.w	r3, r3, #16
    1908:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    190a:	4770      	bx	lr
    190c:	e000ed00 	.word	0xe000ed00

00001910 <z_arm_int_lib_init>:
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    1910:	4804      	ldr	r0, [pc, #16]	; (1924 <z_arm_int_lib_init+0x14>)
 * @return N/A
 */

void z_arm_int_lib_init(void)
{
	int irq = 0;
    1912:	2300      	movs	r3, #0
    1914:	2120      	movs	r1, #32
    1916:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    1918:	3301      	adds	r3, #1
    191a:	2b27      	cmp	r3, #39	; 0x27
    191c:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    1920:	d1f9      	bne.n	1916 <z_arm_int_lib_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    1922:	4770      	bx	lr
    1924:	e000e100 	.word	0xe000e100

00001928 <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
    1928:	b538      	push	{r3, r4, r5, lr}
    192a:	4605      	mov	r5, r0
	__asm__ volatile(
    192c:	f04f 0320 	mov.w	r3, #32
    1930:	f3ef 8411 	mrs	r4, BASEPRI
    1934:	f383 8811 	msr	BASEPRI, r3
    1938:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
		 "essential thread aborted");

	z_thread_single_abort(thread);
    193c:	f005 faf0 	bl	6f20 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
    1940:	4b0a      	ldr	r3, [pc, #40]	; (196c <z_impl_k_thread_abort+0x44>)
    1942:	689b      	ldr	r3, [r3, #8]
    1944:	42ab      	cmp	r3, r5
    1946:	d10b      	bne.n	1960 <z_impl_k_thread_abort+0x38>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
    1948:	4b09      	ldr	r3, [pc, #36]	; (1970 <z_impl_k_thread_abort+0x48>)
    194a:	685a      	ldr	r2, [r3, #4]
    194c:	f3c2 0208 	ubfx	r2, r2, #0, #9
    1950:	b912      	cbnz	r2, 1958 <z_impl_k_thread_abort+0x30>
	int ret;
	z_check_stack_sentinel();
#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
    1952:	4620      	mov	r0, r4
    1954:	f7ff fbd6 	bl	1104 <arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    1958:	685a      	ldr	r2, [r3, #4]
    195a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    195e:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
    1960:	4620      	mov	r0, r4
}
    1962:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
    1966:	f009 b9d0 	b.w	ad0a <z_reschedule_irqlock>
    196a:	bf00      	nop
    196c:	20000f54 	.word	0x20000f54
    1970:	e000ed00 	.word	0xe000ed00

00001974 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    1974:	b51f      	push	{r0, r1, r2, r3, r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
    1976:	4b08      	ldr	r3, [pc, #32]	; (1998 <z_arm_configure_static_mpu_regions+0x24>)
    1978:	9301      	str	r3, [sp, #4]
    197a:	4b08      	ldr	r3, [pc, #32]	; (199c <z_arm_configure_static_mpu_regions+0x28>)
    197c:	9302      	str	r3, [sp, #8]
    197e:	4b08      	ldr	r3, [pc, #32]	; (19a0 <z_arm_configure_static_mpu_regions+0x2c>)
    1980:	9303      	str	r3, [sp, #12]

	/* Define a constant array of k_mem_partition objects
	 * to hold the configuration of the respective static
	 * MPU regions.
	 */
	const struct k_mem_partition *static_regions[] = {
    1982:	ab01      	add	r3, sp, #4
    1984:	9300      	str	r3, [sp, #0]
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    1986:	4a07      	ldr	r2, [pc, #28]	; (19a4 <z_arm_configure_static_mpu_regions+0x30>)
    1988:	4b07      	ldr	r3, [pc, #28]	; (19a8 <z_arm_configure_static_mpu_regions+0x34>)
    198a:	2101      	movs	r1, #1
    198c:	4668      	mov	r0, sp
    198e:	f000 f8b5 	bl	1afc <arm_core_mpu_configure_static_mpu_regions>
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    1992:	b005      	add	sp, #20
    1994:	f85d fb04 	ldr.w	pc, [sp], #4
    1998:	20000000 	.word	0x20000000
    199c:	00000000 	.word	0x00000000
    19a0:	060b0000 	.word	0x060b0000
    19a4:	20000000 	.word	0x20000000
    19a8:	20010000 	.word	0x20010000

000019ac <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct k_mem_partition
	*regions[], u8_t regions_num, u8_t start_reg_index,
	bool do_sanity_check)
{
    19ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Select the region you want to access */
	MPU->RNR = index;
    19ae:	4f2e      	ldr	r7, [pc, #184]	; (1a68 <mpu_configure_regions+0xbc>)
    19b0:	460e      	mov	r6, r1
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
    19b2:	2100      	movs	r1, #0
    19b4:	42b1      	cmp	r1, r6
    19b6:	da22      	bge.n	19fe <mpu_configure_regions+0x52>
		if (regions[i]->size == 0U) {
    19b8:	f850 c021 	ldr.w	ip, [r0, r1, lsl #2]
    19bc:	f8dc 4004 	ldr.w	r4, [ip, #4]
    19c0:	2c00      	cmp	r4, #0
    19c2:	d04f      	beq.n	1a64 <mpu_configure_regions+0xb8>
			continue;
		}
		/* Non-empty region. */

		if (do_sanity_check &&
    19c4:	b1eb      	cbz	r3, 1a02 <mpu_configure_regions+0x56>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1)) == 0U)
    19c6:	f104 3eff 	add.w	lr, r4, #4294967295	; 0xffffffff
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
    19ca:	ea14 0f0e 	tst.w	r4, lr
    19ce:	d106      	bne.n	19de <mpu_configure_regions+0x32>
		&&
    19d0:	2c1f      	cmp	r4, #31
    19d2:	d904      	bls.n	19de <mpu_configure_regions+0x32>
		((part->start & (part->size - 1)) == 0U);
    19d4:	f8dc 5000 	ldr.w	r5, [ip]
		&&
    19d8:	ea1e 0f05 	tst.w	lr, r5
    19dc:	d011      	beq.n	1a02 <mpu_configure_regions+0x56>
				(!mpu_partition_is_valid(regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
    19de:	2301      	movs	r3, #1
    19e0:	f04f 0200 	mov.w	r2, #0
    19e4:	f363 0207 	bfi	r2, r3, #0, #8
    19e8:	4820      	ldr	r0, [pc, #128]	; (1a6c <mpu_configure_regions+0xc0>)
    19ea:	4b21      	ldr	r3, [pc, #132]	; (1a70 <mpu_configure_regions+0xc4>)
    19ec:	1a1b      	subs	r3, r3, r0
    19ee:	08db      	lsrs	r3, r3, #3
    19f0:	4820      	ldr	r0, [pc, #128]	; (1a74 <mpu_configure_regions+0xc8>)
    19f2:	f363 128f 	bfi	r2, r3, #6, #10
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    19f6:	f006 f8b9 	bl	7b6c <log_1>
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, regions[i]);
    19fa:	f06f 0215 	mvn.w	r2, #21
		/* Increment number of programmed MPU indices. */
		reg_index++;
	}

	return reg_index;
}
    19fe:	4610      	mov	r0, r2
    1a00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * to that power-of-two value.
 */
static inline u32_t size_to_mpu_rasr_size(u32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
    1a02:	2c20      	cmp	r4, #32
		reg_index = mpu_configure_region(reg_index, regions[i]);
    1a04:	b2d5      	uxtb	r5, r2
	region_conf.base = new_region->start;
    1a06:	f8dc 2000 	ldr.w	r2, [ip]
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
    1a0a:	f8dc c008 	ldr.w	ip, [ip, #8]
    1a0e:	d91a      	bls.n	1a46 <mpu_configure_regions+0x9a>
	/*
	 * A size value greater than 2^31 could not be handled by
	 * round_up_to_next_power_of_two() properly. We handle
	 * it separately here.
	 */
	if (size > (1UL << 31)) {
    1a10:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
    1a14:	d819      	bhi.n	1a4a <mpu_configure_regions+0x9e>
		return REGION_4G;
	}

	return ((32 - __builtin_clz(size - 1) - 2 + 1) << MPU_RASR_SIZE_Pos) &
    1a16:	3c01      	subs	r4, #1
    1a18:	fab4 f484 	clz	r4, r4
    1a1c:	f1c4 041f 	rsb	r4, r4, #31
    1a20:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1)) {
    1a22:	2d07      	cmp	r5, #7
	/* in ARMv7-M MPU the base address is not required
	 * to determine region attributes
	 */
	(void) base;

	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    1a24:	ea4c 0404 	orr.w	r4, ip, r4
    1a28:	d911      	bls.n	1a4e <mpu_configure_regions+0xa2>
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    1a2a:	2301      	movs	r3, #1
    1a2c:	f04f 0200 	mov.w	r2, #0
    1a30:	f363 0207 	bfi	r2, r3, #0, #8
    1a34:	490d      	ldr	r1, [pc, #52]	; (1a6c <mpu_configure_regions+0xc0>)
    1a36:	4b0e      	ldr	r3, [pc, #56]	; (1a70 <mpu_configure_regions+0xc4>)
    1a38:	480f      	ldr	r0, [pc, #60]	; (1a78 <mpu_configure_regions+0xcc>)
    1a3a:	1a5b      	subs	r3, r3, r1
    1a3c:	08db      	lsrs	r3, r3, #3
    1a3e:	f363 128f 	bfi	r2, r3, #6, #10
    1a42:	4629      	mov	r1, r5
    1a44:	e7d7      	b.n	19f6 <mpu_configure_regions+0x4a>
		return REGION_32B;
    1a46:	2408      	movs	r4, #8
    1a48:	e7eb      	b.n	1a22 <mpu_configure_regions+0x76>
		return REGION_4G;
    1a4a:	243e      	movs	r4, #62	; 0x3e
    1a4c:	e7e9      	b.n	1a22 <mpu_configure_regions+0x76>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    1a4e:	f022 021f 	bic.w	r2, r2, #31
				| MPU_RBAR_VALID_Msk | index;
    1a52:	432a      	orrs	r2, r5
    1a54:	f042 0210 	orr.w	r2, r2, #16
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    1a58:	f044 0401 	orr.w	r4, r4, #1
	MPU->RNR = index;
    1a5c:	60bd      	str	r5, [r7, #8]
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    1a5e:	60fa      	str	r2, [r7, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    1a60:	613c      	str	r4, [r7, #16]
		reg_index++;
    1a62:	1c6a      	adds	r2, r5, #1
	for (i = 0; i < regions_num; i++) {
    1a64:	3101      	adds	r1, #1
    1a66:	e7a5      	b.n	19b4 <mpu_configure_regions+0x8>
    1a68:	e000ed90 	.word	0xe000ed90
    1a6c:	0000b17c 	.word	0x0000b17c
    1a70:	0000b1b4 	.word	0x0000b1b4
    1a74:	0000be6a 	.word	0x0000be6a
    1a78:	0000be8d 	.word	0x0000be8d

00001a7c <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    1a7c:	4b03      	ldr	r3, [pc, #12]	; (1a8c <arm_core_mpu_enable+0x10>)
    1a7e:	2205      	movs	r2, #5
    1a80:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    1a82:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    1a86:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    1a8a:	4770      	bx	lr
    1a8c:	e000ed90 	.word	0xe000ed90

00001a90 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    1a90:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    1a94:	4b01      	ldr	r3, [pc, #4]	; (1a9c <arm_core_mpu_disable+0xc>)
    1a96:	2200      	movs	r2, #0
    1a98:	605a      	str	r2, [r3, #4]
}
    1a9a:	4770      	bx	lr
    1a9c:	e000ed90 	.word	0xe000ed90

00001aa0 <arm_mpu_init>:
 */
static int arm_mpu_init(struct device *arg)
{
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    1aa0:	4913      	ldr	r1, [pc, #76]	; (1af0 <arm_mpu_init+0x50>)
    1aa2:	6808      	ldr	r0, [r1, #0]
    1aa4:	2808      	cmp	r0, #8
{
    1aa6:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
    1aa8:	d81e      	bhi.n	1ae8 <arm_mpu_init+0x48>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    1aaa:	f7ff fff1 	bl	1a90 <arm_core_mpu_disable>
	MPU->RNR = index;
    1aae:	4c11      	ldr	r4, [pc, #68]	; (1af4 <arm_mpu_init+0x54>)
    1ab0:	6849      	ldr	r1, [r1, #4]

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    1ab2:	2200      	movs	r2, #0
    1ab4:	4290      	cmp	r0, r2
    1ab6:	f101 010c 	add.w	r1, r1, #12
    1aba:	d105      	bne.n	1ac8 <arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    1abc:	4b0e      	ldr	r3, [pc, #56]	; (1af8 <arm_mpu_init+0x58>)
    1abe:	7018      	strb	r0, [r3, #0]


	arm_core_mpu_enable();
    1ac0:	f7ff ffdc 	bl	1a7c <arm_core_mpu_enable>
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		DT_NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
    1ac4:	2000      	movs	r0, #0
}
    1ac6:	bd10      	pop	{r4, pc}
    1ac8:	60a2      	str	r2, [r4, #8]
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    1aca:	f851 3c0c 	ldr.w	r3, [r1, #-12]
    1ace:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
    1ad2:	4313      	orrs	r3, r2
    1ad4:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    1ad8:	60e3      	str	r3, [r4, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    1ada:	f851 3c04 	ldr.w	r3, [r1, #-4]
    1ade:	f043 0301 	orr.w	r3, r3, #1
    1ae2:	6123      	str	r3, [r4, #16]
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    1ae4:	3201      	adds	r2, #1
    1ae6:	e7e5      	b.n	1ab4 <arm_mpu_init+0x14>
		return -1;
    1ae8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1aec:	e7eb      	b.n	1ac6 <arm_mpu_init+0x26>
    1aee:	bf00      	nop
    1af0:	0000b264 	.word	0x0000b264
    1af4:	e000ed90 	.word	0xe000ed90
    1af8:	20000f98 	.word	0x20000f98

00001afc <arm_core_mpu_configure_static_mpu_regions>:
{
    1afc:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    1afe:	4c03      	ldr	r4, [pc, #12]	; (1b0c <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    1b00:	2301      	movs	r3, #1
    1b02:	7822      	ldrb	r2, [r4, #0]
    1b04:	f7ff ff52 	bl	19ac <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    1b08:	7020      	strb	r0, [r4, #0]
}
    1b0a:	bd10      	pop	{r4, pc}
    1b0c:	20000f98 	.word	0x20000f98

00001b10 <arm_core_mpu_configure_dynamic_mpu_regions>:
{
    1b10:	b508      	push	{r3, lr}

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
    1b12:	4a08      	ldr	r2, [pc, #32]	; (1b34 <arm_core_mpu_configure_dynamic_mpu_regions+0x24>)
    1b14:	2300      	movs	r3, #0
    1b16:	7812      	ldrb	r2, [r2, #0]
    1b18:	f7ff ff48 	bl	19ac <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
    1b1c:	f110 0f16 	cmn.w	r0, #22
    1b20:	d003      	beq.n	1b2a <arm_core_mpu_configure_dynamic_mpu_regions+0x1a>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
    1b22:	4b05      	ldr	r3, [pc, #20]	; (1b38 <arm_core_mpu_configure_dynamic_mpu_regions+0x28>)
  MPU->RASR = 0U;
    1b24:	2200      	movs	r2, #0

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    1b26:	2807      	cmp	r0, #7
    1b28:	dd00      	ble.n	1b2c <arm_core_mpu_configure_dynamic_mpu_regions+0x1c>
}
    1b2a:	bd08      	pop	{r3, pc}
  MPU->RNR = rnr;
    1b2c:	6098      	str	r0, [r3, #8]
  MPU->RASR = 0U;
    1b2e:	611a      	str	r2, [r3, #16]
    1b30:	3001      	adds	r0, #1
    1b32:	e7f8      	b.n	1b26 <arm_core_mpu_configure_dynamic_mpu_regions+0x16>
    1b34:	20000f98 	.word	0x20000f98
    1b38:	e000ed90 	.word	0xe000ed90

00001b3c <z_prf>:
	*sptr = p;
	return i;
}

int z_prf(int (*func)(), void *dest, const char *format, va_list vargs)
{
    1b3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1b40:	b09f      	sub	sp, #124	; 0x7c
    1b42:	461e      	mov	r6, r3
	struct zero_padding zero;
	VALTYPE val;

#define PUTC(c)	do { if ((*func)(c, dest) == EOF) return EOF; } while (false)

	count = 0;
    1b44:	2300      	movs	r3, #0
{
    1b46:	9001      	str	r0, [sp, #4]
    1b48:	9104      	str	r1, [sp, #16]
	count = 0;
    1b4a:	9300      	str	r3, [sp, #0]

	while ((c = *format++)) {
    1b4c:	4613      	mov	r3, r2
    1b4e:	f813 0b01 	ldrb.w	r0, [r3], #1
    1b52:	9305      	str	r3, [sp, #20]
    1b54:	b158      	cbz	r0, 1b6e <z_prf+0x32>
		if (c != '%') {
    1b56:	2825      	cmp	r0, #37	; 0x25
    1b58:	f000 8085 	beq.w	1c66 <z_prf+0x12a>
			PUTC(c);
    1b5c:	9904      	ldr	r1, [sp, #16]
    1b5e:	9b01      	ldr	r3, [sp, #4]
    1b60:	4798      	blx	r3
    1b62:	3001      	adds	r0, #1
    1b64:	f040 840d 	bne.w	2382 <z_prf+0x846>
    1b68:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1b6c:	9300      	str	r3, [sp, #0]
		}
	}
	return count;

#undef PUTC
}
    1b6e:	9800      	ldr	r0, [sp, #0]
    1b70:	b01f      	add	sp, #124	; 0x7c
    1b72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				switch (c) {
    1b76:	2c23      	cmp	r4, #35	; 0x23
    1b78:	d06c      	beq.n	1c54 <z_prf+0x118>
    1b7a:	d861      	bhi.n	1c40 <z_prf+0x104>
    1b7c:	2c00      	cmp	r4, #0
    1b7e:	d0f6      	beq.n	1b6e <z_prf+0x32>
					fspace = true;
    1b80:	2c20      	cmp	r4, #32
    1b82:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1b84:	bf08      	it	eq
    1b86:	2301      	moveq	r3, #1
    1b88:	930a      	str	r3, [sp, #40]	; 0x28
					fminus = true;
    1b8a:	f8cd 8014 	str.w	r8, [sp, #20]
			while (strchr("-+ #0", (c = *format++)) != NULL) {
    1b8e:	f8dd 8014 	ldr.w	r8, [sp, #20]
    1b92:	48b9      	ldr	r0, [pc, #740]	; (1e78 <z_prf+0x33c>)
    1b94:	f818 4b01 	ldrb.w	r4, [r8], #1
    1b98:	4621      	mov	r1, r4
    1b9a:	f006 fa66 	bl	806a <strchr>
    1b9e:	2800      	cmp	r0, #0
    1ba0:	d1e9      	bne.n	1b76 <z_prf+0x3a>
			if (c == '*') {
    1ba2:	2c2a      	cmp	r4, #42	; 0x2a
    1ba4:	d166      	bne.n	1c74 <z_prf+0x138>
				width = va_arg(vargs, int);
    1ba6:	f856 3b04 	ldr.w	r3, [r6], #4
    1baa:	9307      	str	r3, [sp, #28]
				if (width < 0) {
    1bac:	2b00      	cmp	r3, #0
					width = -width;
    1bae:	bfbf      	itttt	lt
    1bb0:	425b      	neglt	r3, r3
    1bb2:	9307      	strlt	r3, [sp, #28]
					fminus = true;
    1bb4:	2301      	movlt	r3, #1
    1bb6:	930b      	strlt	r3, [sp, #44]	; 0x2c
				c = *format++;
    1bb8:	9b05      	ldr	r3, [sp, #20]
    1bba:	f898 4000 	ldrb.w	r4, [r8]
    1bbe:	f103 0802 	add.w	r8, r3, #2
			if (c == '.') {
    1bc2:	2c2e      	cmp	r4, #46	; 0x2e
    1bc4:	d17c      	bne.n	1cc0 <z_prf+0x184>
				if (c == '*') {
    1bc6:	f898 3000 	ldrb.w	r3, [r8]
    1bca:	2b2a      	cmp	r3, #42	; 0x2a
    1bcc:	d175      	bne.n	1cba <z_prf+0x17e>
					precision = va_arg(vargs, int);
    1bce:	f856 5b04 	ldr.w	r5, [r6], #4
				c = *format++;
    1bd2:	f108 0801 	add.w	r8, r8, #1
				c = *format++;
    1bd6:	f818 4b01 	ldrb.w	r4, [r8], #1
			if (strchr("hlz", c) != NULL) {
    1bda:	48a8      	ldr	r0, [pc, #672]	; (1e7c <z_prf+0x340>)
    1bdc:	4621      	mov	r1, r4
    1bde:	4627      	mov	r7, r4
    1be0:	f006 fa43 	bl	806a <strchr>
    1be4:	2800      	cmp	r0, #0
    1be6:	d06e      	beq.n	1cc6 <z_prf+0x18a>
				c = *format++;
    1be8:	4643      	mov	r3, r8
				} else if (i == 'h' && c == 'h') {
    1bea:	2f68      	cmp	r7, #104	; 0x68
				c = *format++;
    1bec:	f813 4b01 	ldrb.w	r4, [r3], #1
    1bf0:	9305      	str	r3, [sp, #20]
				} else if (i == 'h' && c == 'h') {
    1bf2:	d107      	bne.n	1c04 <z_prf+0xc8>
    1bf4:	2c68      	cmp	r4, #104	; 0x68
    1bf6:	d105      	bne.n	1c04 <z_prf+0xc8>
					c = *format++;
    1bf8:	f108 0302 	add.w	r3, r8, #2
    1bfc:	f898 4001 	ldrb.w	r4, [r8, #1]
    1c00:	9305      	str	r3, [sp, #20]
					i = 'H';
    1c02:	2748      	movs	r7, #72	; 0x48
			switch (c) {
    1c04:	2c67      	cmp	r4, #103	; 0x67
    1c06:	d87c      	bhi.n	1d02 <z_prf+0x1c6>
    1c08:	2c65      	cmp	r4, #101	; 0x65
    1c0a:	f080 8139 	bcs.w	1e80 <z_prf+0x344>
    1c0e:	2c47      	cmp	r4, #71	; 0x47
    1c10:	d85d      	bhi.n	1cce <z_prf+0x192>
    1c12:	2c45      	cmp	r4, #69	; 0x45
    1c14:	f080 8134 	bcs.w	1e80 <z_prf+0x344>
    1c18:	2c00      	cmp	r4, #0
    1c1a:	d0a8      	beq.n	1b6e <z_prf+0x32>
    1c1c:	2c25      	cmp	r4, #37	; 0x25
    1c1e:	f000 83ac 	beq.w	237a <z_prf+0x83e>
				PUTC('%');
    1c22:	9904      	ldr	r1, [sp, #16]
    1c24:	9b01      	ldr	r3, [sp, #4]
    1c26:	2025      	movs	r0, #37	; 0x25
    1c28:	4798      	blx	r3
    1c2a:	3001      	adds	r0, #1
    1c2c:	d09c      	beq.n	1b68 <z_prf+0x2c>
				PUTC(c);
    1c2e:	9904      	ldr	r1, [sp, #16]
    1c30:	9b01      	ldr	r3, [sp, #4]
    1c32:	4620      	mov	r0, r4
    1c34:	4798      	blx	r3
    1c36:	3001      	adds	r0, #1
    1c38:	d096      	beq.n	1b68 <z_prf+0x2c>
				count += 2;
    1c3a:	9b00      	ldr	r3, [sp, #0]
    1c3c:	3302      	adds	r3, #2
    1c3e:	e3a2      	b.n	2386 <z_prf+0x84a>
				switch (c) {
    1c40:	2c2d      	cmp	r4, #45	; 0x2d
    1c42:	d00a      	beq.n	1c5a <z_prf+0x11e>
    1c44:	2c30      	cmp	r4, #48	; 0x30
    1c46:	d00b      	beq.n	1c60 <z_prf+0x124>
					fplus = true;
    1c48:	2c2b      	cmp	r4, #43	; 0x2b
    1c4a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1c4c:	bf08      	it	eq
    1c4e:	2301      	moveq	r3, #1
    1c50:	9309      	str	r3, [sp, #36]	; 0x24
    1c52:	e79a      	b.n	1b8a <z_prf+0x4e>
					falt = true;
    1c54:	2301      	movs	r3, #1
    1c56:	9306      	str	r3, [sp, #24]
    1c58:	e797      	b.n	1b8a <z_prf+0x4e>
					fminus = true;
    1c5a:	2301      	movs	r3, #1
    1c5c:	930b      	str	r3, [sp, #44]	; 0x2c
    1c5e:	e794      	b.n	1b8a <z_prf+0x4e>
					fzero = true;
    1c60:	2301      	movs	r3, #1
    1c62:	9308      	str	r3, [sp, #32]
    1c64:	e791      	b.n	1b8a <z_prf+0x4e>
			fminus = fplus = fspace = falt = fzero = false;
    1c66:	2300      	movs	r3, #0
    1c68:	9308      	str	r3, [sp, #32]
    1c6a:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
    1c6e:	930b      	str	r3, [sp, #44]	; 0x2c
    1c70:	9306      	str	r3, [sp, #24]
    1c72:	e78c      	b.n	1b8e <z_prf+0x52>
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    1c74:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
			} else if (!isdigit(c)) {
    1c78:	2b09      	cmp	r3, #9
				width = 0;
    1c7a:	9007      	str	r0, [sp, #28]
			} else if (!isdigit(c)) {
    1c7c:	d8a1      	bhi.n	1bc2 <z_prf+0x86>
		i = 10 * i + *p++ - '0';
    1c7e:	220a      	movs	r2, #10
	while (isdigit(*p)) {
    1c80:	f8dd 8014 	ldr.w	r8, [sp, #20]
    1c84:	f818 4b01 	ldrb.w	r4, [r8], #1
    1c88:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
    1c8c:	2b09      	cmp	r3, #9
    1c8e:	d898      	bhi.n	1bc2 <z_prf+0x86>
		i = 10 * i + *p++ - '0';
    1c90:	9b07      	ldr	r3, [sp, #28]
    1c92:	f8cd 8014 	str.w	r8, [sp, #20]
    1c96:	fb02 4403 	mla	r4, r2, r3, r4
    1c9a:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
    1c9e:	9307      	str	r3, [sp, #28]
    1ca0:	e7ee      	b.n	1c80 <z_prf+0x144>
    1ca2:	fb01 3505 	mla	r5, r1, r5, r3
    1ca6:	3d30      	subs	r5, #48	; 0x30
    1ca8:	4690      	mov	r8, r2
	while (isdigit(*p)) {
    1caa:	4642      	mov	r2, r8
    1cac:	f812 3b01 	ldrb.w	r3, [r2], #1
    1cb0:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    1cb4:	2809      	cmp	r0, #9
    1cb6:	d9f4      	bls.n	1ca2 <z_prf+0x166>
    1cb8:	e78d      	b.n	1bd6 <z_prf+0x9a>
	int i = 0;
    1cba:	2500      	movs	r5, #0
		i = 10 * i + *p++ - '0';
    1cbc:	210a      	movs	r1, #10
    1cbe:	e7f4      	b.n	1caa <z_prf+0x16e>
			precision = -1;
    1cc0:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    1cc4:	e789      	b.n	1bda <z_prf+0x9e>
    1cc6:	f8cd 8014 	str.w	r8, [sp, #20]
			i = 0;
    1cca:	4607      	mov	r7, r0
    1ccc:	e79a      	b.n	1c04 <z_prf+0xc8>
			switch (c) {
    1cce:	2c63      	cmp	r4, #99	; 0x63
    1cd0:	d05a      	beq.n	1d88 <z_prf+0x24c>
    1cd2:	d820      	bhi.n	1d16 <z_prf+0x1da>
    1cd4:	2c58      	cmp	r4, #88	; 0x58
    1cd6:	d1a4      	bne.n	1c22 <z_prf+0xe6>
				if (c == 'o') {
    1cd8:	2c6f      	cmp	r4, #111	; 0x6f
    1cda:	f106 0904 	add.w	r9, r6, #4
    1cde:	6831      	ldr	r1, [r6, #0]
    1ce0:	f040 831c 	bne.w	231c <z_prf+0x7e0>
	if (alt_form) {
    1ce4:	9b06      	ldr	r3, [sp, #24]
    1ce6:	2b00      	cmp	r3, #0
    1ce8:	f000 830a 	beq.w	2300 <z_prf+0x7c4>
		*buf++ = '0';
    1cec:	2330      	movs	r3, #48	; 0x30
    1cee:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
		if (!value) {
    1cf2:	2900      	cmp	r1, #0
    1cf4:	f040 830f 	bne.w	2316 <z_prf+0x7da>
			*buf++ = 0;
    1cf8:	f88d 105d 	strb.w	r1, [sp, #93]	; 0x5d
			prefix = 0;
    1cfc:	4688      	mov	r8, r1
			return 1;
    1cfe:	2601      	movs	r6, #1
    1d00:	e026      	b.n	1d50 <z_prf+0x214>
			switch (c) {
    1d02:	2c70      	cmp	r4, #112	; 0x70
    1d04:	f000 82e7 	beq.w	22d6 <z_prf+0x79a>
    1d08:	d828      	bhi.n	1d5c <z_prf+0x220>
    1d0a:	2c6e      	cmp	r4, #110	; 0x6e
    1d0c:	f000 82d0 	beq.w	22b0 <z_prf+0x774>
    1d10:	d8e2      	bhi.n	1cd8 <z_prf+0x19c>
    1d12:	2c69      	cmp	r4, #105	; 0x69
    1d14:	d185      	bne.n	1c22 <z_prf+0xe6>
				switch (i) {
    1d16:	6834      	ldr	r4, [r6, #0]
	if (value < 0) {
    1d18:	2c00      	cmp	r4, #0
    1d1a:	f106 0904 	add.w	r9, r6, #4
    1d1e:	f280 809c 	bge.w	1e5a <z_prf+0x31e>
		*buf++ = '-';
    1d22:	232d      	movs	r3, #45	; 0x2d
    1d24:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
		value = -value;
    1d28:	4261      	negs	r1, r4
		*buf++ = ' ';
    1d2a:	f10d 065d 	add.w	r6, sp, #93	; 0x5d
	return _to_x(buf, value, 10);
    1d2e:	4630      	mov	r0, r6
    1d30:	220a      	movs	r2, #10
    1d32:	f006 fa07 	bl	8144 <_to_x>
				if (fplus || fspace || val < 0) {
    1d36:	9b09      	ldr	r3, [sp, #36]	; 0x24
	return (buf + _to_udec(buf, value)) - start;
    1d38:	4406      	add	r6, r0
    1d3a:	a817      	add	r0, sp, #92	; 0x5c
    1d3c:	1a36      	subs	r6, r6, r0
				if (fplus || fspace || val < 0) {
    1d3e:	2b00      	cmp	r3, #0
    1d40:	f040 8324 	bne.w	238c <z_prf+0x850>
    1d44:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1d46:	2b00      	cmp	r3, #0
    1d48:	f040 8320 	bne.w	238c <z_prf+0x850>
    1d4c:	ea4f 78d4 	mov.w	r8, r4, lsr #31
			if (precision >= 0) {
    1d50:	2d00      	cmp	r5, #0
    1d52:	da22      	bge.n	1d9a <z_prf+0x25e>
			zero.predot = zero.postdot = zero.trail = 0;
    1d54:	2500      	movs	r5, #0
    1d56:	462f      	mov	r7, r5
    1d58:	46aa      	mov	sl, r5
    1d5a:	e0e5      	b.n	1f28 <z_prf+0x3ec>
			switch (c) {
    1d5c:	2c75      	cmp	r4, #117	; 0x75
    1d5e:	d0bb      	beq.n	1cd8 <z_prf+0x19c>
    1d60:	2c78      	cmp	r4, #120	; 0x78
    1d62:	d0b9      	beq.n	1cd8 <z_prf+0x19c>
    1d64:	2c73      	cmp	r4, #115	; 0x73
    1d66:	f47f af5c 	bne.w	1c22 <z_prf+0xe6>
				cptr = va_arg(vargs, char *);
    1d6a:	46b1      	mov	r9, r6
					precision = INT_MAX;
    1d6c:	2d00      	cmp	r5, #0
				cptr = va_arg(vargs, char *);
    1d6e:	f859 3b04 	ldr.w	r3, [r9], #4
					precision = INT_MAX;
    1d72:	bfb8      	it	lt
    1d74:	f06f 4500 	mvnlt.w	r5, #2147483648	; 0x80000000
				for (clen = 0; clen < precision; clen++) {
    1d78:	2600      	movs	r6, #0
    1d7a:	42b5      	cmp	r5, r6
    1d7c:	f040 82bb 	bne.w	22f6 <z_prf+0x7ba>
    1d80:	462e      	mov	r6, r5
    1d82:	2500      	movs	r5, #0
    1d84:	46a8      	mov	r8, r5
    1d86:	e009      	b.n	1d9c <z_prf+0x260>
				buf[0] = va_arg(vargs, int);
    1d88:	46b1      	mov	r9, r6
				break;
    1d8a:	f04f 0800 	mov.w	r8, #0
				buf[0] = va_arg(vargs, int);
    1d8e:	f859 3b04 	ldr.w	r3, [r9], #4
    1d92:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
				clen = 1;
    1d96:	2601      	movs	r6, #1
				break;
    1d98:	4645      	mov	r5, r8
    1d9a:	ab17      	add	r3, sp, #92	; 0x5c
				zero_head = precision - clen + prefix;
    1d9c:	eb05 0208 	add.w	r2, r5, r8
			zero.predot = zero.postdot = zero.trail = 0;
    1da0:	2500      	movs	r5, #0
				zero_head = precision - clen + prefix;
    1da2:	1b92      	subs	r2, r2, r6
			zero.predot = zero.postdot = zero.trail = 0;
    1da4:	462f      	mov	r7, r5
    1da6:	46aa      	mov	sl, r5
			if (zero_head < 0) {
    1da8:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
			width -= clen + zero_head;
    1dac:	1991      	adds	r1, r2, r6
    1dae:	9106      	str	r1, [sp, #24]
    1db0:	9907      	ldr	r1, [sp, #28]
    1db2:	1990      	adds	r0, r2, r6
    1db4:	1a0c      	subs	r4, r1, r0
			if (!fminus && width > 0) {
    1db6:	990b      	ldr	r1, [sp, #44]	; 0x2c
    1db8:	b911      	cbnz	r1, 1dc0 <z_prf+0x284>
    1dba:	2c00      	cmp	r4, #0
    1dbc:	f300 8304 	bgt.w	23c8 <z_prf+0x88c>
			while (prefix-- > 0) {
    1dc0:	eb03 0b08 	add.w	fp, r3, r8
    1dc4:	455b      	cmp	r3, fp
    1dc6:	f040 8301 	bne.w	23cc <z_prf+0x890>
			while (zero_head-- > 0) {
    1dca:	f112 32ff 	adds.w	r2, r2, #4294967295	; 0xffffffff
    1dce:	f080 830d 	bcs.w	23ec <z_prf+0x8b0>
			clen -= prefix;
    1dd2:	eba6 0608 	sub.w	r6, r6, r8
			if (zero.predot) {
    1dd6:	f1ba 0f00 	cmp.w	sl, #0
    1dda:	d011      	beq.n	1e00 <z_prf+0x2c4>
				c = *cptr;
    1ddc:	f89b 0000 	ldrb.w	r0, [fp]
				while (isdigit(c)) {
    1de0:	eb0b 0806 	add.w	r8, fp, r6
    1de4:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    1de8:	2b09      	cmp	r3, #9
    1dea:	eba8 060b 	sub.w	r6, r8, fp
    1dee:	f240 8308 	bls.w	2402 <z_prf+0x8c6>
    1df2:	46d0      	mov	r8, sl
				while (zero.predot-- > 0) {
    1df4:	f118 38ff 	adds.w	r8, r8, #4294967295	; 0xffffffff
    1df8:	f080 830c 	bcs.w	2414 <z_prf+0x8d8>
				clen -= zero.predot;
    1dfc:	eba6 060a 	sub.w	r6, r6, sl
			if (zero.postdot) {
    1e00:	b1af      	cbz	r7, 1e2e <z_prf+0x2f2>
    1e02:	eb0b 0806 	add.w	r8, fp, r6
					c = *cptr++;
    1e06:	f81b ab01 	ldrb.w	sl, [fp], #1
					PUTC(c);
    1e0a:	9904      	ldr	r1, [sp, #16]
    1e0c:	9b01      	ldr	r3, [sp, #4]
    1e0e:	4650      	mov	r0, sl
    1e10:	4798      	blx	r3
    1e12:	3001      	adds	r0, #1
    1e14:	f43f aea8 	beq.w	1b68 <z_prf+0x2c>
				} while (c != '.');
    1e18:	f1ba 0f2e 	cmp.w	sl, #46	; 0x2e
    1e1c:	eba8 060b 	sub.w	r6, r8, fp
    1e20:	d1f1      	bne.n	1e06 <z_prf+0x2ca>
				while (zero.postdot-- > 0) {
    1e22:	46b8      	mov	r8, r7
    1e24:	f1b8 0f00 	cmp.w	r8, #0
    1e28:	f300 82fd 	bgt.w	2426 <z_prf+0x8ea>
				clen -= zero.postdot;
    1e2c:	1bf6      	subs	r6, r6, r7
			if (zero.trail) {
    1e2e:	b195      	cbz	r5, 1e56 <z_prf+0x31a>
				c = *cptr;
    1e30:	f89b 0000 	ldrb.w	r0, [fp]
				while (isdigit(c) || c == '.') {
    1e34:	eb0b 0806 	add.w	r8, fp, r6
    1e38:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    1e3c:	2b09      	cmp	r3, #9
    1e3e:	eba8 060b 	sub.w	r6, r8, fp
    1e42:	f240 82fb 	bls.w	243c <z_prf+0x900>
    1e46:	282e      	cmp	r0, #46	; 0x2e
    1e48:	f000 82f8 	beq.w	243c <z_prf+0x900>
				while (zero.trail-- > 0) {
    1e4c:	462f      	mov	r7, r5
    1e4e:	2f00      	cmp	r7, #0
    1e50:	f300 82fd 	bgt.w	244e <z_prf+0x912>
				clen -= zero.trail;
    1e54:	1b76      	subs	r6, r6, r5
    1e56:	445e      	add	r6, fp
    1e58:	e30c      	b.n	2474 <z_prf+0x938>
	} else if (fplus) {
    1e5a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1e5c:	b123      	cbz	r3, 1e68 <z_prf+0x32c>
		*buf++ = '+';
    1e5e:	232b      	movs	r3, #43	; 0x2b
		*buf++ = ' ';
    1e60:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
    1e64:	4621      	mov	r1, r4
    1e66:	e760      	b.n	1d2a <z_prf+0x1ee>
	} else if (fspace) {
    1e68:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1e6a:	b10b      	cbz	r3, 1e70 <z_prf+0x334>
		*buf++ = ' ';
    1e6c:	2320      	movs	r3, #32
    1e6e:	e7f7      	b.n	1e60 <z_prf+0x324>
	} else if (fspace) {
    1e70:	4621      	mov	r1, r4
    1e72:	ae17      	add	r6, sp, #92	; 0x5c
    1e74:	e75b      	b.n	1d2e <z_prf+0x1f2>
    1e76:	bf00      	nop
    1e78:	0000beb3 	.word	0x0000beb3
    1e7c:	0000beb9 	.word	0x0000beb9
				u.d = va_arg(vargs, double);
    1e80:	f106 0907 	add.w	r9, r6, #7
    1e84:	f029 0907 	bic.w	r9, r9, #7
    1e88:	e8f9 2302 	ldrd	r2, r3, [r9], #8
	fract = (double_temp << 11) & ~HIGHBIT64;
    1e8c:	02d8      	lsls	r0, r3, #11
    1e8e:	ea40 5052 	orr.w	r0, r0, r2, lsr #21
    1e92:	02d6      	lsls	r6, r2, #11
    1e94:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
    1e98:	9602      	str	r6, [sp, #8]
    1e9a:	9003      	str	r0, [sp, #12]
    1e9c:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
	if (sign) {
    1ea0:	2a00      	cmp	r2, #0
	exp = double_temp >> 52 & 0x7ff;
    1ea2:	f3c3 510a 	ubfx	r1, r3, #20, #11
	if (sign) {
    1ea6:	f173 0300 	sbcs.w	r3, r3, #0
	fract = (double_temp << 11) & ~HIGHBIT64;
    1eaa:	e9cd 6712 	strd	r6, r7, [sp, #72]	; 0x48
	if (sign) {
    1eae:	da43      	bge.n	1f38 <z_prf+0x3fc>
		*buf++ = '-';
    1eb0:	232d      	movs	r3, #45	; 0x2d
		*buf++ = ' ';
    1eb2:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
    1eb6:	f10d 075d 	add.w	r7, sp, #93	; 0x5d
	if (exp == 0x7ff) {
    1eba:	f240 73ff 	movw	r3, #2047	; 0x7ff
    1ebe:	4299      	cmp	r1, r3
    1ec0:	d155      	bne.n	1f6e <z_prf+0x432>
		if (!fract) {
    1ec2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    1ec6:	4313      	orrs	r3, r2
    1ec8:	f1a4 0441 	sub.w	r4, r4, #65	; 0x41
    1ecc:	f107 0b03 	add.w	fp, r7, #3
    1ed0:	d142      	bne.n	1f58 <z_prf+0x41c>
			if (isupper(c)) {
    1ed2:	2c19      	cmp	r4, #25
    1ed4:	d83a      	bhi.n	1f4c <z_prf+0x410>
				*buf++ = 'I';
    1ed6:	2349      	movs	r3, #73	; 0x49
    1ed8:	703b      	strb	r3, [r7, #0]
				*buf++ = 'N';
    1eda:	234e      	movs	r3, #78	; 0x4e
    1edc:	707b      	strb	r3, [r7, #1]
				*buf++ = 'F';
    1ede:	2346      	movs	r3, #70	; 0x46
		*buf = 0;
    1ee0:	2500      	movs	r5, #0
		return buf - start;
    1ee2:	ae17      	add	r6, sp, #92	; 0x5c
				*buf++ = 'n';
    1ee4:	70bb      	strb	r3, [r7, #2]
		*buf = 0;
    1ee6:	70fd      	strb	r5, [r7, #3]
		return buf - start;
    1ee8:	ebab 0b06 	sub.w	fp, fp, r6
			zero.predot = zero.postdot = zero.trail = 0;
    1eec:	462f      	mov	r7, r5
    1eee:	46aa      	mov	sl, r5
				if (fplus || fspace || (buf[0] == '-')) {
    1ef0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1ef2:	2b00      	cmp	r3, #0
    1ef4:	f040 81d9 	bne.w	22aa <z_prf+0x76e>
    1ef8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1efa:	2b00      	cmp	r3, #0
    1efc:	f040 81d5 	bne.w	22aa <z_prf+0x76e>
    1f00:	f89d 805c 	ldrb.w	r8, [sp, #92]	; 0x5c
    1f04:	f1a8 032d 	sub.w	r3, r8, #45	; 0x2d
    1f08:	f1d3 0800 	rsbs	r8, r3, #0
    1f0c:	eb48 0803 	adc.w	r8, r8, r3
				if (!isdigit(buf[prefix])) {
    1f10:	ab1e      	add	r3, sp, #120	; 0x78
    1f12:	4443      	add	r3, r8
				clen += zero.predot + zero.postdot + zero.trail;
    1f14:	44bb      	add	fp, r7
    1f16:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
    1f1a:	3b30      	subs	r3, #48	; 0x30
    1f1c:	eb0b 060a 	add.w	r6, fp, sl
				if (!isdigit(buf[prefix])) {
    1f20:	2b09      	cmp	r3, #9
				clen += zero.predot + zero.postdot + zero.trail;
    1f22:	442e      	add	r6, r5
				if (!isdigit(buf[prefix])) {
    1f24:	f200 8237 	bhi.w	2396 <z_prf+0x85a>
			} else if (fzero) {
    1f28:	9b08      	ldr	r3, [sp, #32]
    1f2a:	2b00      	cmp	r3, #0
    1f2c:	f000 8236 	beq.w	239c <z_prf+0x860>
    1f30:	9b07      	ldr	r3, [sp, #28]
    1f32:	1b9a      	subs	r2, r3, r6
    1f34:	ab17      	add	r3, sp, #92	; 0x5c
    1f36:	e737      	b.n	1da8 <z_prf+0x26c>
	} else if (fplus) {
    1f38:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1f3a:	b10b      	cbz	r3, 1f40 <z_prf+0x404>
		*buf++ = '+';
    1f3c:	232b      	movs	r3, #43	; 0x2b
    1f3e:	e7b8      	b.n	1eb2 <z_prf+0x376>
	} else if (fspace) {
    1f40:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1f42:	b10b      	cbz	r3, 1f48 <z_prf+0x40c>
		*buf++ = ' ';
    1f44:	2320      	movs	r3, #32
    1f46:	e7b4      	b.n	1eb2 <z_prf+0x376>
	} else if (fspace) {
    1f48:	af17      	add	r7, sp, #92	; 0x5c
    1f4a:	e7b6      	b.n	1eba <z_prf+0x37e>
				*buf++ = 'i';
    1f4c:	2369      	movs	r3, #105	; 0x69
    1f4e:	703b      	strb	r3, [r7, #0]
				*buf++ = 'n';
    1f50:	236e      	movs	r3, #110	; 0x6e
    1f52:	707b      	strb	r3, [r7, #1]
				*buf++ = 'f';
    1f54:	2366      	movs	r3, #102	; 0x66
    1f56:	e7c3      	b.n	1ee0 <z_prf+0x3a4>
			if (isupper(c)) {
    1f58:	2c19      	cmp	r4, #25
				*buf++ = 'N';
    1f5a:	bf99      	ittee	ls
    1f5c:	234e      	movls	r3, #78	; 0x4e
				*buf++ = 'A';
    1f5e:	2241      	movls	r2, #65	; 0x41
				*buf++ = 'n';
    1f60:	236e      	movhi	r3, #110	; 0x6e
				*buf++ = 'a';
    1f62:	2261      	movhi	r2, #97	; 0x61
				*buf++ = 'N';
    1f64:	bf94      	ite	ls
    1f66:	703b      	strbls	r3, [r7, #0]
				*buf++ = 'n';
    1f68:	703b      	strbhi	r3, [r7, #0]
				*buf++ = 'a';
    1f6a:	707a      	strb	r2, [r7, #1]
    1f6c:	e7b8      	b.n	1ee0 <z_prf+0x3a4>
	if ((exp | fract) != 0) {
    1f6e:	9b02      	ldr	r3, [sp, #8]
    1f70:	9803      	ldr	r0, [sp, #12]
    1f72:	430b      	orrs	r3, r1
    1f74:	930c      	str	r3, [sp, #48]	; 0x30
    1f76:	17cb      	asrs	r3, r1, #31
    1f78:	4303      	orrs	r3, r0
    1f7a:	930d      	str	r3, [sp, #52]	; 0x34
    1f7c:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
		c = 'f';
    1f80:	2c46      	cmp	r4, #70	; 0x46
    1f82:	bf08      	it	eq
    1f84:	2466      	moveq	r4, #102	; 0x66
	if ((exp | fract) != 0) {
    1f86:	4313      	orrs	r3, r2
    1f88:	f000 80ff 	beq.w	218a <z_prf+0x64e>
		if (exp == 0) {
    1f8c:	2900      	cmp	r1, #0
    1f8e:	f000 809f 	beq.w	20d0 <z_prf+0x594>
		fract |= HIGHBIT64;
    1f92:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    1f94:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
    1f98:	f2a1 38fe 	subw	r8, r1, #1022	; 0x3fe
		fract |= HIGHBIT64;
    1f9c:	9313      	str	r3, [sp, #76]	; 0x4c
    1f9e:	2600      	movs	r6, #0
	while (exp <= -3) {
    1fa0:	f118 0f02 	cmn.w	r8, #2
    1fa4:	f2c0 80a8 	blt.w	20f8 <z_prf+0x5bc>
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    1fa8:	f06f 4a00 	mvn.w	sl, #2147483648	; 0x80000000
    1fac:	f04f 0b00 	mov.w	fp, #0
	while (exp > 0) {
    1fb0:	f1b8 0f00 	cmp.w	r8, #0
    1fb4:	f300 80cc 	bgt.w	2150 <z_prf+0x614>
		_rlrshift(&fract);
    1fb8:	a812      	add	r0, sp, #72	; 0x48
		exp++;
    1fba:	f108 0801 	add.w	r8, r8, #1
		_rlrshift(&fract);
    1fbe:	f006 f8e3 	bl	8188 <_rlrshift>
	while (exp < (0 + 4)) {
    1fc2:	f1b8 0f04 	cmp.w	r8, #4
    1fc6:	d1f7      	bne.n	1fb8 <z_prf+0x47c>
		precision = 6;		/* Default precision if none given */
    1fc8:	2d00      	cmp	r5, #0
	if ((c == 'g') || (c == 'G')) {
    1fca:	f004 03df 	and.w	r3, r4, #223	; 0xdf
		precision = 6;		/* Default precision if none given */
    1fce:	bfb8      	it	lt
    1fd0:	2506      	movlt	r5, #6
	if ((c == 'g') || (c == 'G')) {
    1fd2:	2b47      	cmp	r3, #71	; 0x47
    1fd4:	f040 80e1 	bne.w	219a <z_prf+0x65e>
		if (decexp < (-4 + 1) || decexp > precision) {
    1fd8:	1cf2      	adds	r2, r6, #3
    1fda:	db02      	blt.n	1fe2 <z_prf+0x4a6>
    1fdc:	42ae      	cmp	r6, r5
    1fde:	f340 80d7 	ble.w	2190 <z_prf+0x654>
			c += 'e' - 'g';
    1fe2:	3c02      	subs	r4, #2
    1fe4:	b2e4      	uxtb	r4, r4
			if (precision > 0) {
    1fe6:	2d00      	cmp	r5, #0
    1fe8:	f000 80dd 	beq.w	21a6 <z_prf+0x66a>
		if (!falt && (precision > 0)) {
    1fec:	9b06      	ldr	r3, [sp, #24]
				precision--;
    1fee:	3d01      	subs	r5, #1
		if (!falt && (precision > 0)) {
    1ff0:	2b00      	cmp	r3, #0
    1ff2:	f040 80d8 	bne.w	21a6 <z_prf+0x66a>
    1ff6:	2d00      	cmp	r5, #0
    1ff8:	bfd4      	ite	le
    1ffa:	f04f 0800 	movle.w	r8, #0
    1ffe:	f04f 0801 	movgt.w	r8, #1
	if (c == 'f') {
    2002:	2c66      	cmp	r4, #102	; 0x66
    2004:	f040 80d1 	bne.w	21aa <z_prf+0x66e>
		if (exp < 0) {
    2008:	eb16 0a05 	adds.w	sl, r6, r5
    200c:	f140 80d5 	bpl.w	21ba <z_prf+0x67e>
	digit_count = 16;
    2010:	2310      	movs	r3, #16
    2012:	9311      	str	r3, [sp, #68]	; 0x44
    2014:	2466      	movs	r4, #102	; 0x66
			exp = 0;
    2016:	f04f 0a00 	mov.w	sl, #0
	ltemp = 0x0800000000000000;
    201a:	2200      	movs	r2, #0
    201c:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    2020:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
	while (exp--) {
    2024:	f11a 3aff 	adds.w	sl, sl, #4294967295	; 0xffffffff
    2028:	f080 80c9 	bcs.w	21be <z_prf+0x682>
	fract += ltemp;
    202c:	9b12      	ldr	r3, [sp, #72]	; 0x48
    202e:	9a14      	ldr	r2, [sp, #80]	; 0x50
    2030:	9915      	ldr	r1, [sp, #84]	; 0x54
    2032:	189b      	adds	r3, r3, r2
    2034:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    2036:	eb41 0202 	adc.w	r2, r1, r2
    203a:	e9cd 3212 	strd	r3, r2, [sp, #72]	; 0x48
	if ((fract >> 32) & 0xF0000000) {
    203e:	f002 4370 	and.w	r3, r2, #4026531840	; 0xf0000000
    2042:	930e      	str	r3, [sp, #56]	; 0x38
    2044:	2300      	movs	r3, #0
    2046:	930f      	str	r3, [sp, #60]	; 0x3c
    2048:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
    204c:	4313      	orrs	r3, r2
    204e:	d006      	beq.n	205e <z_prf+0x522>
		_ldiv5(&fract);
    2050:	a812      	add	r0, sp, #72	; 0x48
    2052:	f006 f8ab 	bl	81ac <_ldiv5>
		_rlrshift(&fract);
    2056:	a812      	add	r0, sp, #72	; 0x48
    2058:	f006 f896 	bl	8188 <_rlrshift>
		decexp++;
    205c:	3601      	adds	r6, #1
	if (c == 'f') {
    205e:	2c66      	cmp	r4, #102	; 0x66
    2060:	f040 80c7 	bne.w	21f2 <z_prf+0x6b6>
		if (decexp > 0) {
    2064:	2e00      	cmp	r6, #0
    2066:	f340 80b1 	ble.w	21cc <z_prf+0x690>
			while (decexp > 0 && digit_count > 0) {
    206a:	9b11      	ldr	r3, [sp, #68]	; 0x44
    206c:	2b00      	cmp	r3, #0
    206e:	dd07      	ble.n	2080 <z_prf+0x544>
				*buf++ = _get_digit(&fract, &digit_count);
    2070:	a911      	add	r1, sp, #68	; 0x44
    2072:	a812      	add	r0, sp, #72	; 0x48
    2074:	f006 f8c6 	bl	8204 <_get_digit>
			while (decexp > 0 && digit_count > 0) {
    2078:	3e01      	subs	r6, #1
				*buf++ = _get_digit(&fract, &digit_count);
    207a:	f807 0b01 	strb.w	r0, [r7], #1
			while (decexp > 0 && digit_count > 0) {
    207e:	d1f4      	bne.n	206a <z_prf+0x52e>
			zp->predot = decexp;
    2080:	46b2      	mov	sl, r6
    2082:	46bb      	mov	fp, r7
			decexp = 0;
    2084:	2600      	movs	r6, #0
		if (falt || (precision > 0)) {
    2086:	9b06      	ldr	r3, [sp, #24]
    2088:	b913      	cbnz	r3, 2090 <z_prf+0x554>
    208a:	2d00      	cmp	r5, #0
    208c:	f340 80af 	ble.w	21ee <z_prf+0x6b2>
			*buf++ = '.';
    2090:	232e      	movs	r3, #46	; 0x2e
    2092:	f80b 3b01 	strb.w	r3, [fp], #1
		if (decexp < 0 && precision > 0) {
    2096:	2e00      	cmp	r6, #0
    2098:	f000 80a7 	beq.w	21ea <z_prf+0x6ae>
    209c:	2d00      	cmp	r5, #0
    209e:	f340 80a6 	ble.w	21ee <z_prf+0x6b2>
			zp->postdot = -decexp;
    20a2:	4277      	negs	r7, r6
    20a4:	42af      	cmp	r7, r5
    20a6:	bfa8      	it	ge
    20a8:	462f      	movge	r7, r5
			precision -= zp->postdot;
    20aa:	1bed      	subs	r5, r5, r7
		while (precision > 0 && digit_count > 0) {
    20ac:	2d00      	cmp	r5, #0
    20ae:	dd03      	ble.n	20b8 <z_prf+0x57c>
    20b0:	9b11      	ldr	r3, [sp, #68]	; 0x44
    20b2:	2b00      	cmp	r3, #0
    20b4:	f300 8091 	bgt.w	21da <z_prf+0x69e>
	if (prune_zero) {
    20b8:	f1b8 0f00 	cmp.w	r8, #0
    20bc:	f040 80af 	bne.w	221e <z_prf+0x6e2>
	*buf = 0;
    20c0:	2300      	movs	r3, #0
	return buf - start;
    20c2:	ae17      	add	r6, sp, #92	; 0x5c
	*buf = 0;
    20c4:	f88b 3000 	strb.w	r3, [fp]
	return buf - start;
    20c8:	ebab 0b06 	sub.w	fp, fp, r6
    20cc:	e710      	b.n	1ef0 <z_prf+0x3b4>
				exp--;
    20ce:	3901      	subs	r1, #1
			while (((fract <<= 1) & HIGHBIT64) == 0) {
    20d0:	9b02      	ldr	r3, [sp, #8]
    20d2:	18db      	adds	r3, r3, r3
    20d4:	9302      	str	r3, [sp, #8]
    20d6:	9b03      	ldr	r3, [sp, #12]
    20d8:	415b      	adcs	r3, r3
    20da:	9303      	str	r3, [sp, #12]
    20dc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    20e0:	2a00      	cmp	r2, #0
    20e2:	f173 0300 	sbcs.w	r3, r3, #0
    20e6:	daf2      	bge.n	20ce <z_prf+0x592>
    20e8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    20ec:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
    20f0:	e74f      	b.n	1f92 <z_prf+0x456>
			_rlrshift(&fract);
    20f2:	a812      	add	r0, sp, #72	; 0x48
    20f4:	f006 f848 	bl	8188 <_rlrshift>
		while ((fract >> 32) >= (MAXFP1 / 5)) {
    20f8:	e9dd 2c12 	ldrd	r2, ip, [sp, #72]	; 0x48
    20fc:	f04f 0b00 	mov.w	fp, #0
    2100:	48b9      	ldr	r0, [pc, #740]	; (23e8 <z_prf+0x8ac>)
    2102:	2100      	movs	r1, #0
    2104:	4559      	cmp	r1, fp
    2106:	bf08      	it	eq
    2108:	4560      	cmpeq	r0, ip
    210a:	f108 0801 	add.w	r8, r8, #1
    210e:	d3f0      	bcc.n	20f2 <z_prf+0x5b6>
		fract *= 5U;
    2110:	2005      	movs	r0, #5
    2112:	fba2 2300 	umull	r2, r3, r2, r0
    2116:	fb00 330c 	mla	r3, r0, ip, r3
    211a:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
		decexp--;
    211e:	46dc      	mov	ip, fp
    2120:	3e01      	subs	r6, #1
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    2122:	f06f 4a00 	mvn.w	sl, #2147483648	; 0x80000000
    2126:	f04f 0b00 	mov.w	fp, #0
    212a:	2100      	movs	r1, #0
    212c:	458b      	cmp	fp, r1
    212e:	bf08      	it	eq
    2130:	459a      	cmpeq	sl, r3
    2132:	d206      	bcs.n	2142 <z_prf+0x606>
    2134:	f1bc 0f00 	cmp.w	ip, #0
    2138:	f43f af32 	beq.w	1fa0 <z_prf+0x464>
    213c:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
    2140:	e72e      	b.n	1fa0 <z_prf+0x464>
			fract <<= 1;
    2142:	1892      	adds	r2, r2, r2
    2144:	415b      	adcs	r3, r3
			exp--;
    2146:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    214a:	f04f 0c01 	mov.w	ip, #1
    214e:	e7ec      	b.n	212a <z_prf+0x5ee>
		_ldiv5(&fract);
    2150:	a812      	add	r0, sp, #72	; 0x48
    2152:	f006 f82b 	bl	81ac <_ldiv5>
		exp--;
    2156:	e9dd 1012 	ldrd	r1, r0, [sp, #72]	; 0x48
    215a:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
		decexp++;
    215e:	3601      	adds	r6, #1
    2160:	f04f 0c00 	mov.w	ip, #0
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    2164:	2300      	movs	r3, #0
    2166:	459b      	cmp	fp, r3
    2168:	bf08      	it	eq
    216a:	4582      	cmpeq	sl, r0
    216c:	d206      	bcs.n	217c <z_prf+0x640>
    216e:	f1bc 0f00 	cmp.w	ip, #0
    2172:	f43f af1d 	beq.w	1fb0 <z_prf+0x474>
    2176:	e9cd 1012 	strd	r1, r0, [sp, #72]	; 0x48
    217a:	e719      	b.n	1fb0 <z_prf+0x474>
			fract <<= 1;
    217c:	1849      	adds	r1, r1, r1
    217e:	4140      	adcs	r0, r0
			exp--;
    2180:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    2184:	f04f 0c01 	mov.w	ip, #1
    2188:	e7ec      	b.n	2164 <z_prf+0x628>
	if ((exp | fract) != 0) {
    218a:	2600      	movs	r6, #0
    218c:	46b0      	mov	r8, r6
    218e:	e713      	b.n	1fb8 <z_prf+0x47c>
		if (!falt && (precision > 0)) {
    2190:	9b06      	ldr	r3, [sp, #24]
			precision -= decexp;
    2192:	1bad      	subs	r5, r5, r6
		if (!falt && (precision > 0)) {
    2194:	b923      	cbnz	r3, 21a0 <z_prf+0x664>
			c = 'f';
    2196:	2466      	movs	r4, #102	; 0x66
    2198:	e72d      	b.n	1ff6 <z_prf+0x4ba>
	prune_zero = false;		/* Assume trailing 0's allowed     */
    219a:	f04f 0800 	mov.w	r8, #0
    219e:	e730      	b.n	2002 <z_prf+0x4c6>
    21a0:	f04f 0800 	mov.w	r8, #0
    21a4:	e730      	b.n	2008 <z_prf+0x4cc>
    21a6:	f04f 0800 	mov.w	r8, #0
		exp = precision + 1;
    21aa:	f105 0a01 	add.w	sl, r5, #1
	digit_count = 16;
    21ae:	2310      	movs	r3, #16
    21b0:	459a      	cmp	sl, r3
    21b2:	9311      	str	r3, [sp, #68]	; 0x44
	if (exp > 16) {
    21b4:	bfa8      	it	ge
    21b6:	469a      	movge	sl, r3
    21b8:	e72f      	b.n	201a <z_prf+0x4de>
		if (exp < 0) {
    21ba:	2466      	movs	r4, #102	; 0x66
    21bc:	e7f7      	b.n	21ae <z_prf+0x672>
		_ldiv5(&ltemp);
    21be:	a814      	add	r0, sp, #80	; 0x50
    21c0:	f005 fff4 	bl	81ac <_ldiv5>
		_rlrshift(&ltemp);
    21c4:	a814      	add	r0, sp, #80	; 0x50
    21c6:	f005 ffdf 	bl	8188 <_rlrshift>
    21ca:	e72b      	b.n	2024 <z_prf+0x4e8>
			*buf++ = '0';
    21cc:	46bb      	mov	fp, r7
    21ce:	2330      	movs	r3, #48	; 0x30
    21d0:	f80b 3b01 	strb.w	r3, [fp], #1
			zero.predot = zero.postdot = zero.trail = 0;
    21d4:	f04f 0a00 	mov.w	sl, #0
    21d8:	e755      	b.n	2086 <z_prf+0x54a>
			*buf++ = _get_digit(&fract, &digit_count);
    21da:	a911      	add	r1, sp, #68	; 0x44
    21dc:	a812      	add	r0, sp, #72	; 0x48
    21de:	f006 f811 	bl	8204 <_get_digit>
			precision--;
    21e2:	3d01      	subs	r5, #1
			*buf++ = _get_digit(&fract, &digit_count);
    21e4:	f80b 0b01 	strb.w	r0, [fp], #1
			precision--;
    21e8:	e760      	b.n	20ac <z_prf+0x570>
			zero.predot = zero.postdot = zero.trail = 0;
    21ea:	4637      	mov	r7, r6
    21ec:	e75e      	b.n	20ac <z_prf+0x570>
    21ee:	2700      	movs	r7, #0
    21f0:	e762      	b.n	20b8 <z_prf+0x57c>
		*buf = _get_digit(&fract, &digit_count);
    21f2:	a911      	add	r1, sp, #68	; 0x44
    21f4:	a812      	add	r0, sp, #72	; 0x48
    21f6:	f006 f805 	bl	8204 <_get_digit>
		if (falt || (precision > 0)) {
    21fa:	9b06      	ldr	r3, [sp, #24]
		*buf = _get_digit(&fract, &digit_count);
    21fc:	7038      	strb	r0, [r7, #0]
		if (*buf++ != '0') {
    21fe:	2830      	cmp	r0, #48	; 0x30
			decexp--;
    2200:	bf18      	it	ne
    2202:	f106 36ff 	addne.w	r6, r6, #4294967295	; 0xffffffff
		if (falt || (precision > 0)) {
    2206:	2b00      	cmp	r3, #0
    2208:	d13b      	bne.n	2282 <z_prf+0x746>
    220a:	2d00      	cmp	r5, #0
    220c:	dc39      	bgt.n	2282 <z_prf+0x746>
		if (*buf++ != '0') {
    220e:	f107 0b01 	add.w	fp, r7, #1
	if (prune_zero) {
    2212:	f1b8 0f00 	cmp.w	r8, #0
    2216:	d045      	beq.n	22a4 <z_prf+0x768>
			zero.predot = zero.postdot = zero.trail = 0;
    2218:	f04f 0a00 	mov.w	sl, #0
    221c:	4657      	mov	r7, sl
		while (*--buf == '0')
    221e:	465b      	mov	r3, fp
    2220:	f81b 2d01 	ldrb.w	r2, [fp, #-1]!
    2224:	2a30      	cmp	r2, #48	; 0x30
    2226:	d0fa      	beq.n	221e <z_prf+0x6e2>
		if (*buf != '.') {
    2228:	2a2e      	cmp	r2, #46	; 0x2e
    222a:	bf18      	it	ne
    222c:	469b      	movne	fp, r3
    222e:	2500      	movs	r5, #0
	if ((c == 'e') || (c == 'E')) {
    2230:	f004 03df 	and.w	r3, r4, #223	; 0xdf
    2234:	2b45      	cmp	r3, #69	; 0x45
    2236:	f47f af43 	bne.w	20c0 <z_prf+0x584>
		if (decexp < 0) {
    223a:	2e00      	cmp	r6, #0
		*buf++ = c;
    223c:	465a      	mov	r2, fp
			decexp = -decexp;
    223e:	bfba      	itte	lt
    2240:	4276      	neglt	r6, r6
			*buf++ = '-';
    2242:	232d      	movlt	r3, #45	; 0x2d
			*buf++ = '+';
    2244:	232b      	movge	r3, #43	; 0x2b
		if (decexp >= 100) {
    2246:	2e63      	cmp	r6, #99	; 0x63
		*buf++ = c;
    2248:	f802 4b02 	strb.w	r4, [r2], #2
			*buf++ = '-';
    224c:	f88b 3001 	strb.w	r3, [fp, #1]
		if (decexp >= 100) {
    2250:	dd0a      	ble.n	2268 <z_prf+0x72c>
			*buf++ = (decexp / 100) + '0';
    2252:	2164      	movs	r1, #100	; 0x64
    2254:	fb96 f3f1 	sdiv	r3, r6, r1
    2258:	f103 0030 	add.w	r0, r3, #48	; 0x30
    225c:	f10b 0203 	add.w	r2, fp, #3
    2260:	f88b 0002 	strb.w	r0, [fp, #2]
			decexp %= 100;
    2264:	fb01 6613 	mls	r6, r1, r3, r6
		*buf++ = (decexp / 10) + '0';
    2268:	210a      	movs	r1, #10
    226a:	4693      	mov	fp, r2
    226c:	fb96 f3f1 	sdiv	r3, r6, r1
		decexp %= 10;
    2270:	fb01 6613 	mls	r6, r1, r3, r6
		*buf++ = (decexp / 10) + '0';
    2274:	f103 0030 	add.w	r0, r3, #48	; 0x30
		*buf++ = decexp + '0';
    2278:	3630      	adds	r6, #48	; 0x30
		*buf++ = (decexp / 10) + '0';
    227a:	f80b 0b02 	strb.w	r0, [fp], #2
		*buf++ = decexp + '0';
    227e:	7056      	strb	r6, [r2, #1]
    2280:	e71e      	b.n	20c0 <z_prf+0x584>
			*buf++ = '.';
    2282:	232e      	movs	r3, #46	; 0x2e
    2284:	f107 0b02 	add.w	fp, r7, #2
    2288:	707b      	strb	r3, [r7, #1]
		while (precision > 0 && digit_count > 0) {
    228a:	2d00      	cmp	r5, #0
    228c:	ddc1      	ble.n	2212 <z_prf+0x6d6>
    228e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    2290:	2b00      	cmp	r3, #0
    2292:	ddbe      	ble.n	2212 <z_prf+0x6d6>
			*buf++ = _get_digit(&fract, &digit_count);
    2294:	a911      	add	r1, sp, #68	; 0x44
    2296:	a812      	add	r0, sp, #72	; 0x48
    2298:	f005 ffb4 	bl	8204 <_get_digit>
			precision--;
    229c:	3d01      	subs	r5, #1
			*buf++ = _get_digit(&fract, &digit_count);
    229e:	f80b 0b01 	strb.w	r0, [fp], #1
			precision--;
    22a2:	e7f2      	b.n	228a <z_prf+0x74e>
			zero.predot = zero.postdot = zero.trail = 0;
    22a4:	46c2      	mov	sl, r8
    22a6:	4647      	mov	r7, r8
    22a8:	e7c2      	b.n	2230 <z_prf+0x6f4>
					prefix = 1;
    22aa:	f04f 0801 	mov.w	r8, #1
    22ae:	e62f      	b.n	1f10 <z_prf+0x3d4>
				switch (i) {
    22b0:	46b1      	mov	r9, r6
    22b2:	2f68      	cmp	r7, #104	; 0x68
    22b4:	f859 3b04 	ldr.w	r3, [r9], #4
    22b8:	d005      	beq.n	22c6 <z_prf+0x78a>
    22ba:	dc01      	bgt.n	22c0 <z_prf+0x784>
    22bc:	2f48      	cmp	r7, #72	; 0x48
    22be:	d007      	beq.n	22d0 <z_prf+0x794>
					*va_arg(vargs, int *) = count;
    22c0:	9a00      	ldr	r2, [sp, #0]
    22c2:	601a      	str	r2, [r3, #0]
					break;
    22c4:	e001      	b.n	22ca <z_prf+0x78e>
					*va_arg(vargs, short *) = count;
    22c6:	9a00      	ldr	r2, [sp, #0]
    22c8:	801a      	strh	r2, [r3, #0]
				continue;
    22ca:	464e      	mov	r6, r9
    22cc:	9a05      	ldr	r2, [sp, #20]
    22ce:	e43d      	b.n	1b4c <z_prf+0x10>
					*va_arg(vargs, char *) = count;
    22d0:	9a00      	ldr	r2, [sp, #0]
    22d2:	701a      	strb	r2, [r3, #0]
					break;
    22d4:	e7f9      	b.n	22ca <z_prf+0x78e>
				val = (uintptr_t) va_arg(vargs, void *);
    22d6:	46b1      	mov	r9, r6
		*buf++ = '0';
    22d8:	f647 0330 	movw	r3, #30768	; 0x7830
	len = _to_x(buf, value, 16);
    22dc:	2210      	movs	r2, #16
    22de:	f859 1b04 	ldr.w	r1, [r9], #4
		*buf++ = '0';
    22e2:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
	len = _to_x(buf, value, 16);
    22e6:	f10d 005e 	add.w	r0, sp, #94	; 0x5e
    22ea:	f005 ff2b 	bl	8144 <_to_x>
				prefix = 2;
    22ee:	f04f 0802 	mov.w	r8, #2
	return len + (buf - buf0);
    22f2:	1c86      	adds	r6, r0, #2
				break;
    22f4:	e52c      	b.n	1d50 <z_prf+0x214>
					if (cptr[clen] == '\0') {
    22f6:	5d9a      	ldrb	r2, [r3, r6]
    22f8:	2a00      	cmp	r2, #0
    22fa:	d04a      	beq.n	2392 <z_prf+0x856>
				for (clen = 0; clen < precision; clen++) {
    22fc:	3601      	adds	r6, #1
    22fe:	e53c      	b.n	1d7a <z_prf+0x23e>
	if (alt_form) {
    2300:	ac17      	add	r4, sp, #92	; 0x5c
	return (buf - buf0) + _to_x(buf, value, 8);
    2302:	2208      	movs	r2, #8
    2304:	4620      	mov	r0, r4
    2306:	f005 ff1d 	bl	8144 <_to_x>
    230a:	ae17      	add	r6, sp, #92	; 0x5c
    230c:	1ba6      	subs	r6, r4, r6
    230e:	4406      	add	r6, r0
			prefix = 0;
    2310:	f04f 0800 	mov.w	r8, #0
    2314:	e51c      	b.n	1d50 <z_prf+0x214>
		*buf++ = '0';
    2316:	f10d 045d 	add.w	r4, sp, #93	; 0x5d
    231a:	e7f2      	b.n	2302 <z_prf+0x7c6>
				} else if (c == 'u') {
    231c:	2c75      	cmp	r4, #117	; 0x75
    231e:	d105      	bne.n	232c <z_prf+0x7f0>
	return _to_x(buf, value, 10);
    2320:	220a      	movs	r2, #10
    2322:	a817      	add	r0, sp, #92	; 0x5c
    2324:	f005 ff0e 	bl	8144 <_to_x>
    2328:	4606      	mov	r6, r0
    232a:	e7f1      	b.n	2310 <z_prf+0x7d4>
	if (alt_form) {
    232c:	9b06      	ldr	r3, [sp, #24]
    232e:	b193      	cbz	r3, 2356 <z_prf+0x81a>
		*buf++ = '0';
    2330:	f647 0330 	movw	r3, #30768	; 0x7830
    2334:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
		*buf++ = 'x';
    2338:	f10d 075e 	add.w	r7, sp, #94	; 0x5e
	len = _to_x(buf, value, 16);
    233c:	2210      	movs	r2, #16
    233e:	4638      	mov	r0, r7
    2340:	f005 ff00 	bl	8144 <_to_x>
	if (prefix == 'X') {
    2344:	2c58      	cmp	r4, #88	; 0x58
    2346:	d008      	beq.n	235a <z_prf+0x81e>
	return len + (buf - buf0);
    2348:	ae17      	add	r6, sp, #92	; 0x5c
						prefix = 2;
    234a:	9b06      	ldr	r3, [sp, #24]
	return len + (buf - buf0);
    234c:	1bbe      	subs	r6, r7, r6
    234e:	4406      	add	r6, r0
						prefix = 2;
    2350:	ea4f 0843 	mov.w	r8, r3, lsl #1
    2354:	e4fc      	b.n	1d50 <z_prf+0x214>
	if (alt_form) {
    2356:	af17      	add	r7, sp, #92	; 0x5c
    2358:	e7f0      	b.n	233c <z_prf+0x800>
    235a:	aa17      	add	r2, sp, #92	; 0x5c
		if (*buf >= 'a' && *buf <= 'z') {
    235c:	f812 3b01 	ldrb.w	r3, [r2], #1
    2360:	f1a3 0161 	sub.w	r1, r3, #97	; 0x61
    2364:	2919      	cmp	r1, #25
    2366:	d803      	bhi.n	2370 <z_prf+0x834>
			*buf += 'A' - 'a';
    2368:	3b20      	subs	r3, #32
    236a:	f802 3c01 	strb.w	r3, [r2, #-1]
    236e:	e7f5      	b.n	235c <z_prf+0x820>
	} while (*buf++);
    2370:	f812 3c01 	ldrb.w	r3, [r2, #-1]
    2374:	2b00      	cmp	r3, #0
    2376:	d1f1      	bne.n	235c <z_prf+0x820>
    2378:	e7e6      	b.n	2348 <z_prf+0x80c>
				PUTC('%');
    237a:	9904      	ldr	r1, [sp, #16]
    237c:	4620      	mov	r0, r4
    237e:	f7ff bbee 	b.w	1b5e <z_prf+0x22>
				count++;
    2382:	9b00      	ldr	r3, [sp, #0]
    2384:	3301      	adds	r3, #1
				count += 2;
    2386:	9300      	str	r3, [sp, #0]
				continue;
    2388:	46b1      	mov	r9, r6
    238a:	e79e      	b.n	22ca <z_prf+0x78e>
					prefix = 1;
    238c:	f04f 0801 	mov.w	r8, #1
    2390:	e4de      	b.n	1d50 <z_prf+0x214>
    2392:	4615      	mov	r5, r2
    2394:	e4f6      	b.n	1d84 <z_prf+0x248>
			cptr = buf;
    2396:	ab17      	add	r3, sp, #92	; 0x5c
				zero_head = 0;
    2398:	2200      	movs	r2, #0
    239a:	e507      	b.n	1dac <z_prf+0x270>
    239c:	ab17      	add	r3, sp, #92	; 0x5c
    239e:	9a08      	ldr	r2, [sp, #32]
    23a0:	e504      	b.n	1dac <z_prf+0x270>
    23a2:	e9cd 3207 	strd	r3, r2, [sp, #28]
					PUTC(' ');
    23a6:	9904      	ldr	r1, [sp, #16]
    23a8:	9b01      	ldr	r3, [sp, #4]
    23aa:	2020      	movs	r0, #32
    23ac:	4798      	blx	r3
    23ae:	3001      	adds	r0, #1
    23b0:	e9dd 3207 	ldrd	r3, r2, [sp, #28]
    23b4:	f43f abd8 	beq.w	1b68 <z_prf+0x2c>
				while (width-- > 0) {
    23b8:	f11b 3bff 	adds.w	fp, fp, #4294967295	; 0xffffffff
    23bc:	d2f1      	bcs.n	23a2 <z_prf+0x866>
				count += width;
    23be:	9900      	ldr	r1, [sp, #0]
    23c0:	4421      	add	r1, r4
    23c2:	9100      	str	r1, [sp, #0]
				while (width-- > 0) {
    23c4:	465c      	mov	r4, fp
    23c6:	e4fb      	b.n	1dc0 <z_prf+0x284>
    23c8:	46a3      	mov	fp, r4
    23ca:	e7f5      	b.n	23b8 <z_prf+0x87c>
				PUTC(*cptr++);
    23cc:	f813 0b01 	ldrb.w	r0, [r3], #1
    23d0:	9307      	str	r3, [sp, #28]
    23d2:	9904      	ldr	r1, [sp, #16]
    23d4:	9b01      	ldr	r3, [sp, #4]
    23d6:	9208      	str	r2, [sp, #32]
    23d8:	4798      	blx	r3
    23da:	3001      	adds	r0, #1
    23dc:	e9dd 3207 	ldrd	r3, r2, [sp, #28]
    23e0:	f47f acf0 	bne.w	1dc4 <z_prf+0x288>
    23e4:	f7ff bbc0 	b.w	1b68 <z_prf+0x2c>
    23e8:	33333332 	.word	0x33333332
				PUTC('0');
    23ec:	9904      	ldr	r1, [sp, #16]
    23ee:	9b01      	ldr	r3, [sp, #4]
    23f0:	9207      	str	r2, [sp, #28]
    23f2:	2030      	movs	r0, #48	; 0x30
    23f4:	4798      	blx	r3
    23f6:	3001      	adds	r0, #1
    23f8:	9a07      	ldr	r2, [sp, #28]
    23fa:	f47f ace6 	bne.w	1dca <z_prf+0x28e>
    23fe:	f7ff bbb3 	b.w	1b68 <z_prf+0x2c>
					PUTC(c);
    2402:	9904      	ldr	r1, [sp, #16]
    2404:	9b01      	ldr	r3, [sp, #4]
    2406:	4798      	blx	r3
    2408:	3001      	adds	r0, #1
    240a:	f43f abad 	beq.w	1b68 <z_prf+0x2c>
					c = *++cptr;
    240e:	f81b 0f01 	ldrb.w	r0, [fp, #1]!
    2412:	e4e7      	b.n	1de4 <z_prf+0x2a8>
					PUTC('0');
    2414:	9904      	ldr	r1, [sp, #16]
    2416:	9b01      	ldr	r3, [sp, #4]
    2418:	2030      	movs	r0, #48	; 0x30
    241a:	4798      	blx	r3
    241c:	3001      	adds	r0, #1
    241e:	f47f ace9 	bne.w	1df4 <z_prf+0x2b8>
    2422:	f7ff bba1 	b.w	1b68 <z_prf+0x2c>
					PUTC('0');
    2426:	9904      	ldr	r1, [sp, #16]
    2428:	9b01      	ldr	r3, [sp, #4]
    242a:	2030      	movs	r0, #48	; 0x30
    242c:	4798      	blx	r3
    242e:	3001      	adds	r0, #1
    2430:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    2434:	f47f acf6 	bne.w	1e24 <z_prf+0x2e8>
    2438:	f7ff bb96 	b.w	1b68 <z_prf+0x2c>
					PUTC(c);
    243c:	9904      	ldr	r1, [sp, #16]
    243e:	9b01      	ldr	r3, [sp, #4]
    2440:	4798      	blx	r3
    2442:	3001      	adds	r0, #1
    2444:	f43f ab90 	beq.w	1b68 <z_prf+0x2c>
					c = *++cptr;
    2448:	f81b 0f01 	ldrb.w	r0, [fp, #1]!
    244c:	e4f4      	b.n	1e38 <z_prf+0x2fc>
					PUTC('0');
    244e:	9904      	ldr	r1, [sp, #16]
    2450:	9b01      	ldr	r3, [sp, #4]
    2452:	2030      	movs	r0, #48	; 0x30
    2454:	4798      	blx	r3
    2456:	3001      	adds	r0, #1
    2458:	f107 37ff 	add.w	r7, r7, #4294967295	; 0xffffffff
    245c:	f47f acf7 	bne.w	1e4e <z_prf+0x312>
    2460:	f7ff bb82 	b.w	1b68 <z_prf+0x2c>
				PUTC(*cptr++);
    2464:	9904      	ldr	r1, [sp, #16]
    2466:	f81b 0b01 	ldrb.w	r0, [fp], #1
    246a:	9b01      	ldr	r3, [sp, #4]
    246c:	4798      	blx	r3
    246e:	3001      	adds	r0, #1
    2470:	f43f ab7a 	beq.w	1b68 <z_prf+0x2c>
    2474:	eba6 030b 	sub.w	r3, r6, fp
			while (clen-- > 0) {
    2478:	2b00      	cmp	r3, #0
    247a:	dcf3      	bgt.n	2464 <z_prf+0x928>
			count += clen;
    247c:	9b00      	ldr	r3, [sp, #0]
    247e:	9a06      	ldr	r2, [sp, #24]
			if (width > 0) {
    2480:	2c00      	cmp	r4, #0
			count += clen;
    2482:	4413      	add	r3, r2
    2484:	9300      	str	r3, [sp, #0]
			if (width > 0) {
    2486:	f77f af20 	ble.w	22ca <z_prf+0x78e>
    248a:	4625      	mov	r5, r4
    248c:	e006      	b.n	249c <z_prf+0x960>
					PUTC(' ');
    248e:	9904      	ldr	r1, [sp, #16]
    2490:	9b01      	ldr	r3, [sp, #4]
    2492:	2020      	movs	r0, #32
    2494:	4798      	blx	r3
    2496:	3001      	adds	r0, #1
    2498:	f43f ab66 	beq.w	1b68 <z_prf+0x2c>
				while (width-- > 0) {
    249c:	f115 35ff 	adds.w	r5, r5, #4294967295	; 0xffffffff
    24a0:	d2f5      	bcs.n	248e <z_prf+0x952>
				count += width;
    24a2:	9b00      	ldr	r3, [sp, #0]
    24a4:	4423      	add	r3, r4
    24a6:	9300      	str	r3, [sp, #0]
    24a8:	e70f      	b.n	22ca <z_prf+0x78e>
    24aa:	bf00      	nop

000024ac <z_impl_zephyr_fputc>:
	_stdout_hook = hook;
}

int z_impl_zephyr_fputc(int c, FILE *stream)
{
	return (stdout == stream) ? _stdout_hook(c) : EOF;
    24ac:	2902      	cmp	r1, #2
    24ae:	d102      	bne.n	24b6 <z_impl_zephyr_fputc+0xa>
    24b0:	4b02      	ldr	r3, [pc, #8]	; (24bc <z_impl_zephyr_fputc+0x10>)
    24b2:	681b      	ldr	r3, [r3, #0]
    24b4:	4718      	bx	r3
}
    24b6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    24ba:	4770      	bx	lr
    24bc:	20006838 	.word	0x20006838

000024c0 <sprintf>:
	*(p.ptr) = 0;
	return r;
}

int sprintf(char *_MLIBC_RESTRICT s, const char *_MLIBC_RESTRICT format, ...)
{
    24c0:	b40e      	push	{r1, r2, r3}
    24c2:	b50f      	push	{r0, r1, r2, r3, lr}
    24c4:	ab05      	add	r3, sp, #20

	struct emitter p;
	int     r;

	p.ptr = s;
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
    24c6:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
{
    24ca:	f853 2b04 	ldr.w	r2, [r3], #4
	p.ptr = s;
    24ce:	9002      	str	r0, [sp, #8]
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
    24d0:	9103      	str	r1, [sp, #12]

	va_start(vargs, format);
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
    24d2:	4806      	ldr	r0, [pc, #24]	; (24ec <sprintf+0x2c>)
	va_start(vargs, format);
    24d4:	9301      	str	r3, [sp, #4]
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
    24d6:	a902      	add	r1, sp, #8
    24d8:	f7ff fb30 	bl	1b3c <z_prf>
	va_end(vargs);

	*(p.ptr) = 0;
    24dc:	9b02      	ldr	r3, [sp, #8]
    24de:	2200      	movs	r2, #0
    24e0:	701a      	strb	r2, [r3, #0]
	return r;
}
    24e2:	b004      	add	sp, #16
    24e4:	f85d eb04 	ldr.w	lr, [sp], #4
    24e8:	b003      	add	sp, #12
    24ea:	4770      	bx	lr
    24ec:	0000823d 	.word	0x0000823d

000024f0 <printf>:

	return r;
}

int printf(const char *_MLIBC_RESTRICT format, ...)
{
    24f0:	b40f      	push	{r0, r1, r2, r3}
    24f2:	b507      	push	{r0, r1, r2, lr}
    24f4:	ab04      	add	r3, sp, #16
	va_list vargs;
	int     r;

	va_start(vargs, format);
	r = z_prf(fputc, DESC(stdout), format, vargs);
    24f6:	2102      	movs	r1, #2
{
    24f8:	f853 2b04 	ldr.w	r2, [r3], #4
	r = z_prf(fputc, DESC(stdout), format, vargs);
    24fc:	4804      	ldr	r0, [pc, #16]	; (2510 <printf+0x20>)
	va_start(vargs, format);
    24fe:	9301      	str	r3, [sp, #4]
	r = z_prf(fputc, DESC(stdout), format, vargs);
    2500:	f7ff fb1c 	bl	1b3c <z_prf>
	va_end(vargs);

	return r;
}
    2504:	b003      	add	sp, #12
    2506:	f85d eb04 	ldr.w	lr, [sp], #4
    250a:	b004      	add	sp, #16
    250c:	4770      	bx	lr
    250e:	bf00      	nop
    2510:	00008239 	.word	0x00008239

00002514 <set_lvgl_rendering_cb>:
 */

#include "lvgl_display.h"

int set_lvgl_rendering_cb(lv_disp_drv_t *disp_drv)
{
    2514:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    2516:	4604      	mov	r4, r0
	int err = 0;
	struct device *display_dev = (struct device *)disp_drv->user_data;
    2518:	6a00      	ldr	r0, [r0, #32]
					    capabilities)
{
	struct display_driver_api *api =
		(struct display_driver_api *)dev->driver_api;

	api->get_capabilities(dev, capabilities);
    251a:	6843      	ldr	r3, [r0, #4]
    251c:	4669      	mov	r1, sp
    251e:	69db      	ldr	r3, [r3, #28]
    2520:	4798      	blx	r3
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);

	switch (cap.current_pixel_format) {
    2522:	f89d 200c 	ldrb.w	r2, [sp, #12]
    2526:	3a01      	subs	r2, #1
    2528:	2300      	movs	r3, #0
    252a:	2a0f      	cmp	r2, #15
    252c:	d820      	bhi.n	2570 <set_lvgl_rendering_cb+0x5c>
    252e:	e8df f002 	tbb	[pc, r2]
    2532:	190f      	.short	0x190f
    2534:	1f1f191f 	.word	0x1f1f191f
    2538:	1f1f081f 	.word	0x1f1f081f
    253c:	1f1f1f1f 	.word	0x1f1f1f1f
    2540:	141f      	.short	0x141f
	case PIXEL_FORMAT_ARGB_8888:
		disp_drv->flush_cb = lvgl_flush_cb_32bit;
    2542:	4a0e      	ldr	r2, [pc, #56]	; (257c <set_lvgl_rendering_cb+0x68>)
		disp_drv->rounder_cb = NULL;
    2544:	e9c4 2303 	strd	r2, r3, [r4, #12]
		break;
	case PIXEL_FORMAT_MONO01:
	case PIXEL_FORMAT_MONO10:
		disp_drv->flush_cb = lvgl_flush_cb_mono;
		disp_drv->rounder_cb = lvgl_rounder_cb_mono;
		disp_drv->set_px_cb = lvgl_set_px_cb_mono;
    2548:	6163      	str	r3, [r4, #20]
	int err = 0;
    254a:	2000      	movs	r0, #0
		break;

	}

	return err;
}
    254c:	b004      	add	sp, #16
    254e:	bd10      	pop	{r4, pc}
		disp_drv->flush_cb = lvgl_flush_cb_24bit;
    2550:	4a0b      	ldr	r2, [pc, #44]	; (2580 <set_lvgl_rendering_cb+0x6c>)
		disp_drv->rounder_cb = NULL;
    2552:	e9c4 2303 	strd	r2, r3, [r4, #12]
		disp_drv->set_px_cb = lvgl_set_px_cb_24bit;
    2556:	4b0b      	ldr	r3, [pc, #44]	; (2584 <set_lvgl_rendering_cb+0x70>)
    2558:	e7f6      	b.n	2548 <set_lvgl_rendering_cb+0x34>
		disp_drv->flush_cb = lvgl_flush_cb_16bit;
    255a:	4a0b      	ldr	r2, [pc, #44]	; (2588 <set_lvgl_rendering_cb+0x74>)
		disp_drv->rounder_cb = NULL;
    255c:	e9c4 2303 	strd	r2, r3, [r4, #12]
		disp_drv->set_px_cb = lvgl_set_px_cb_16bit;
    2560:	4b0a      	ldr	r3, [pc, #40]	; (258c <set_lvgl_rendering_cb+0x78>)
    2562:	e7f1      	b.n	2548 <set_lvgl_rendering_cb+0x34>
		disp_drv->flush_cb = lvgl_flush_cb_mono;
    2564:	4b0a      	ldr	r3, [pc, #40]	; (2590 <set_lvgl_rendering_cb+0x7c>)
    2566:	60e3      	str	r3, [r4, #12]
		disp_drv->rounder_cb = lvgl_rounder_cb_mono;
    2568:	4b0a      	ldr	r3, [pc, #40]	; (2594 <set_lvgl_rendering_cb+0x80>)
    256a:	6123      	str	r3, [r4, #16]
		disp_drv->set_px_cb = lvgl_set_px_cb_mono;
    256c:	4b0a      	ldr	r3, [pc, #40]	; (2598 <set_lvgl_rendering_cb+0x84>)
    256e:	e7eb      	b.n	2548 <set_lvgl_rendering_cb+0x34>
		disp_drv->rounder_cb = NULL;
    2570:	e9c4 3303 	strd	r3, r3, [r4, #12]
		disp_drv->set_px_cb = NULL;
    2574:	6163      	str	r3, [r4, #20]
		err = -ENOTSUP;
    2576:	f06f 0022 	mvn.w	r0, #34	; 0x22
	return err;
    257a:	e7e7      	b.n	254c <set_lvgl_rendering_cb+0x38>
    257c:	000084ed 	.word	0x000084ed
    2580:	0000841f 	.word	0x0000841f
    2584:	00008471 	.word	0x00008471
    2588:	000083a5 	.word	0x000083a5
    258c:	000083f1 	.word	0x000083f1
    2590:	0000825d 	.word	0x0000825d
    2594:	0000836d 	.word	0x0000836d
    2598:	000082d7 	.word	0x000082d7

0000259c <lvgl_log>:
	 * * LOG_LEVEL_ERR 1
	 * * LOG_LEVEL_WRN 2
	 * * LOG_LEVEL_INF 3
	 * * LOG_LEVEL_DBG 4
	 */
	u8_t zephyr_level = LOG_LEVEL_DBG - level;
    259c:	f1c0 0004 	rsb	r0, r0, #4
    25a0:	b240      	sxtb	r0, r0
{
    25a2:	b410      	push	{r4}
	u8_t zephyr_level = LOG_LEVEL_DBG - level;
    25a4:	b2c4      	uxtb	r4, r0

	ARG_UNUSED(file);
	ARG_UNUSED(line);

	Z_LOG(zephyr_level, "%s", dsc);
    25a6:	2c03      	cmp	r4, #3
{
    25a8:	4619      	mov	r1, r3
	Z_LOG(zephyr_level, "%s", dsc);
    25aa:	d818      	bhi.n	25de <lvgl_log+0x42>
    25ac:	f04f 0300 	mov.w	r3, #0
    25b0:	f360 0302 	bfi	r3, r0, #0, #3
    25b4:	4a0b      	ldr	r2, [pc, #44]	; (25e4 <lvgl_log+0x48>)
    25b6:	480c      	ldr	r0, [pc, #48]	; (25e8 <lvgl_log+0x4c>)
    25b8:	1a12      	subs	r2, r2, r0
    25ba:	f36f 03c5 	bfc	r3, #3, #3
    25be:	08d2      	lsrs	r2, r2, #3
    25c0:	2c04      	cmp	r4, #4
    25c2:	f362 138f 	bfi	r3, r2, #6, #10
    25c6:	d105      	bne.n	25d4 <lvgl_log+0x38>
    25c8:	460a      	mov	r2, r1
    25ca:	4808      	ldr	r0, [pc, #32]	; (25ec <lvgl_log+0x50>)
    25cc:	4908      	ldr	r1, [pc, #32]	; (25f0 <lvgl_log+0x54>)
}
    25ce:	bc10      	pop	{r4}
	Z_LOG(zephyr_level, "%s", dsc);
    25d0:	f005 bae0 	b.w	7b94 <log_2>
    25d4:	461a      	mov	r2, r3
    25d6:	4807      	ldr	r0, [pc, #28]	; (25f4 <lvgl_log+0x58>)
}
    25d8:	bc10      	pop	{r4}
	Z_LOG(zephyr_level, "%s", dsc);
    25da:	f005 bac7 	b.w	7b6c <log_1>
}
    25de:	bc10      	pop	{r4}
    25e0:	4770      	bx	lr
    25e2:	bf00      	nop
    25e4:	0000b1ac 	.word	0x0000b1ac
    25e8:	0000b17c 	.word	0x0000b17c
    25ec:	0000bf1a 	.word	0x0000bf1a
    25f0:	0000bebd 	.word	0x0000bebd
    25f4:	0000bf9c 	.word	0x0000bf9c

000025f8 <lvgl_init>:
	return 0;
}
#endif /* CONFIG_LVGL_BUFFER_ALLOC_STATIC */

static int lvgl_init(struct device *dev)
{
    25f8:	b510      	push	{r4, lr}
    25fa:	b08a      	sub	sp, #40	; 0x28
    25fc:	482a      	ldr	r0, [pc, #168]	; (26a8 <lvgl_init+0xb0>)
    25fe:	f004 f881 	bl	6704 <z_impl_device_get_binding>

	struct device *display_dev =
		device_get_binding(CONFIG_LVGL_DISPLAY_DEV_NAME);
	lv_disp_drv_t disp_drv;

	if (display_dev == NULL) {
    2602:	4604      	mov	r4, r0
    2604:	b990      	cbnz	r0, 262c <lvgl_init+0x34>
		LOG_ERR("Display device not found.");
    2606:	2301      	movs	r3, #1
    2608:	f04f 0100 	mov.w	r1, #0
    260c:	f363 0107 	bfi	r1, r3, #0, #8
    2610:	4a26      	ldr	r2, [pc, #152]	; (26ac <lvgl_init+0xb4>)
    2612:	4b27      	ldr	r3, [pc, #156]	; (26b0 <lvgl_init+0xb8>)
    2614:	4827      	ldr	r0, [pc, #156]	; (26b4 <lvgl_init+0xbc>)
    2616:	1a9b      	subs	r3, r3, r2
    2618:	08db      	lsrs	r3, r3, #3
    261a:	f363 118f 	bfi	r1, r3, #6, #10
    261e:	f005 fa98 	bl	7b52 <log_0>
		return -ENODEV;
    2622:	f06f 0412 	mvn.w	r4, #18
		LOG_ERR("Failed to register display device.");
		return -EPERM;
	}

	return 0;
}
    2626:	4620      	mov	r0, r4
    2628:	b00a      	add	sp, #40	; 0x28
    262a:	bd10      	pop	{r4, pc}
	lv_log_register_print_cb(lvgl_log);
    262c:	4822      	ldr	r0, [pc, #136]	; (26b8 <lvgl_init+0xc0>)
    262e:	f003 fa89 	bl	5b44 <lv_log_register_print_cb>
	lv_init();
    2632:	f001 fa49 	bl	3ac8 <lv_init>
	lv_disp_drv_init(&disp_drv);
    2636:	a801      	add	r0, sp, #4
    2638:	f007 fdbb 	bl	a1b2 <lv_disp_drv_init>
	disp_drv->buffer = &disp_buf;
    263c:	481f      	ldr	r0, [pc, #124]	; (26bc <lvgl_init+0xc4>)
	lv_disp_buf_init(disp_drv->buffer, &buf0, NULL, NBR_PIXELS_IN_BUFFER);
    263e:	4920      	ldr	r1, [pc, #128]	; (26c0 <lvgl_init+0xc8>)
	disp_drv.user_data = (void *) display_dev;
    2640:	9409      	str	r4, [sp, #36]	; 0x24
	lv_disp_buf_init(disp_drv->buffer, &buf0, NULL, NBR_PIXELS_IN_BUFFER);
    2642:	f44f 53b4 	mov.w	r3, #5760	; 0x1680
    2646:	2200      	movs	r2, #0
	disp_drv->buffer = &disp_buf;
    2648:	9002      	str	r0, [sp, #8]
	lv_disp_buf_init(disp_drv->buffer, &buf0, NULL, NBR_PIXELS_IN_BUFFER);
    264a:	f007 fdc8 	bl	a1de <lv_disp_buf_init>
	if (set_lvgl_rendering_cb(&disp_drv) != 0) {
    264e:	a801      	add	r0, sp, #4
    2650:	f7ff ff60 	bl	2514 <set_lvgl_rendering_cb>
    2654:	4604      	mov	r4, r0
    2656:	b180      	cbz	r0, 267a <lvgl_init+0x82>
		LOG_ERR("Display not supported.");
    2658:	2301      	movs	r3, #1
    265a:	f04f 0100 	mov.w	r1, #0
    265e:	f363 0107 	bfi	r1, r3, #0, #8
    2662:	4a12      	ldr	r2, [pc, #72]	; (26ac <lvgl_init+0xb4>)
    2664:	4b12      	ldr	r3, [pc, #72]	; (26b0 <lvgl_init+0xb8>)
    2666:	4817      	ldr	r0, [pc, #92]	; (26c4 <lvgl_init+0xcc>)
    2668:	1a9b      	subs	r3, r3, r2
    266a:	08db      	lsrs	r3, r3, #3
    266c:	f363 118f 	bfi	r1, r3, #6, #10
    2670:	f005 fa6f 	bl	7b52 <log_0>
		return -ENOTSUP;
    2674:	f06f 0422 	mvn.w	r4, #34	; 0x22
    2678:	e7d5      	b.n	2626 <lvgl_init+0x2e>
	if (lv_disp_drv_register(&disp_drv) == NULL) {
    267a:	a801      	add	r0, sp, #4
    267c:	f002 feda 	bl	5434 <lv_disp_drv_register>
    2680:	2800      	cmp	r0, #0
    2682:	d1d0      	bne.n	2626 <lvgl_init+0x2e>
		LOG_ERR("Failed to register display device.");
    2684:	2301      	movs	r3, #1
    2686:	f04f 0100 	mov.w	r1, #0
    268a:	f363 0107 	bfi	r1, r3, #0, #8
    268e:	4a07      	ldr	r2, [pc, #28]	; (26ac <lvgl_init+0xb4>)
    2690:	4b07      	ldr	r3, [pc, #28]	; (26b0 <lvgl_init+0xb8>)
    2692:	480d      	ldr	r0, [pc, #52]	; (26c8 <lvgl_init+0xd0>)
    2694:	1a9b      	subs	r3, r3, r2
    2696:	08db      	lsrs	r3, r3, #3
    2698:	f363 118f 	bfi	r1, r3, #6, #10
    269c:	f005 fa59 	bl	7b52 <log_0>
		return -EPERM;
    26a0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    26a4:	e7bf      	b.n	2626 <lvgl_init+0x2e>
    26a6:	bf00      	nop
    26a8:	0000b8bf 	.word	0x0000b8bf
    26ac:	0000b17c 	.word	0x0000b17c
    26b0:	0000b1ac 	.word	0x0000b1ac
    26b4:	0000bec6 	.word	0x0000bec6
    26b8:	0000259d 	.word	0x0000259d
    26bc:	20000114 	.word	0x20000114
    26c0:	20000f99 	.word	0x20000f99
    26c4:	0000bee0 	.word	0x0000bee0
    26c8:	0000bef7 	.word	0x0000bef7

000026cc <lvgl_malloc>:
		CONFIG_LVGL_MEM_POOL_MAX_SIZE,
		CONFIG_LVGL_MEM_POOL_NUMBER_BLOCKS, 4);

void *lvgl_malloc(size_t size)
{
	return k_mem_pool_malloc(&lvgl_mem_pool, size);
    26cc:	4601      	mov	r1, r0
    26ce:	4801      	ldr	r0, [pc, #4]	; (26d4 <lvgl_malloc+0x8>)
    26d0:	f008 bac5 	b.w	ac5e <k_mem_pool_malloc>
    26d4:	200069d0 	.word	0x200069d0

000026d8 <nordicsemi_nrf52_init>:
    26d8:	f04f 0320 	mov.w	r3, #32
    26dc:	f3ef 8211 	mrs	r2, BASEPRI
    26e0:	f383 8811 	msr	BASEPRI, r3
    26e4:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    26e8:	4906      	ldr	r1, [pc, #24]	; (2704 <nordicsemi_nrf52_init+0x2c>)
    26ea:	2301      	movs	r3, #1
    26ec:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
#endif

#if NRF_POWER_HAS_DCDCEN
NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable)
{
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
    26f0:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    26f4:	f8c1 3578 	str.w	r3, [r1, #1400]	; 0x578
	__asm__ volatile(
    26f8:	f382 8811 	msr	BASEPRI, r2
    26fc:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    2700:	2000      	movs	r0, #0
    2702:	4770      	bx	lr
    2704:	4001e000 	.word	0x4001e000

00002708 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    2708:	b120      	cbz	r0, 2714 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    270a:	4b03      	ldr	r3, [pc, #12]	; (2718 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
    270c:	0180      	lsls	r0, r0, #6
    270e:	f043 0301 	orr.w	r3, r3, #1
    2712:	4718      	bx	r3

void arch_busy_wait(u32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
    2714:	4770      	bx	lr
    2716:	bf00      	nop
    2718:	0000b200 	.word	0x0000b200

0000271c <gpio_nrfx_init>:
#endif
	}
}

static int gpio_nrfx_init(struct device *port)
{
    271c:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
    271e:	4b09      	ldr	r3, [pc, #36]	; (2744 <gpio_nrfx_init+0x28>)
    2720:	781a      	ldrb	r2, [r3, #0]
    2722:	b96a      	cbnz	r2, 2740 <gpio_nrfx_init+0x24>
		gpio_initialized = true;
    2724:	2101      	movs	r1, #1
    2726:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0,
    2728:	2006      	movs	r0, #6
    272a:	2105      	movs	r1, #5
    272c:	f7fe fd4e 	bl	11cc <z_arm_irq_priority_set>
			    DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0_PRIORITY,
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0);
    2730:	2006      	movs	r0, #6
    2732:	f7fe fd3b 	bl	11ac <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
    2736:	4b04      	ldr	r3, [pc, #16]	; (2748 <gpio_nrfx_init+0x2c>)
    2738:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    273c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
    2740:	2000      	movs	r0, #0
    2742:	bd08      	pop	{r3, pc}
    2744:	20005319 	.word	0x20005319
    2748:	40006000 	.word	0x40006000

0000274c <gpiote_pin_int_cfg>:
{
    274c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return port->config->config_info;
    274e:	6803      	ldr	r3, [r0, #0]
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
    2750:	4d55      	ldr	r5, [pc, #340]	; (28a8 <gpiote_pin_int_cfg+0x15c>)
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    2752:	689b      	ldr	r3, [r3, #8]
	struct gpio_nrfx_data *data = get_port_data(port);
    2754:	6882      	ldr	r2, [r0, #8]
    2756:	f8d5 4304 	ldr.w	r4, [r5, #772]	; 0x304
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    275a:	7918      	ldrb	r0, [r3, #4]
    275c:	f001 031f 	and.w	r3, r1, #31
    2760:	ea43 1340 	orr.w	r3, r3, r0, lsl #5
    2764:	b2e4      	uxtb	r4, r4
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    2766:	2000      	movs	r0, #0
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    2768:	f500 76a2 	add.w	r6, r0, #324	; 0x144
    276c:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
    2770:	f3c6 2604 	ubfx	r6, r6, #8, #5
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
    2774:	42b3      	cmp	r3, r6
    2776:	d175      	bne.n	2864 <gpiote_pin_int_cfg+0x118>
		    && (intenset & BIT(i))) {
    2778:	fa24 f600 	lsr.w	r6, r4, r0
    277c:	07f6      	lsls	r6, r6, #31
    277e:	d571      	bpl.n	2864 <gpiote_pin_int_cfg+0x118>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
    2780:	0084      	lsls	r4, r0, #2
    2782:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
    2786:	f504 44c0 	add.w	r4, r4, #24576	; 0x6000
    278a:	f8d4 6510 	ldr.w	r6, [r4, #1296]	; 0x510
    278e:	f026 0601 	bic.w	r6, r6, #1
    2792:	f8c4 6510 	str.w	r6, [r4, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
    2796:	2401      	movs	r4, #1
    2798:	fa04 f000 	lsl.w	r0, r4, r0
    p_reg->INTENCLR = mask;
    279c:	f8c5 0308 	str.w	r0, [r5, #776]	; 0x308
NRF_STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t             pin_number,
                                              nrf_gpio_pin_sense_t sense_config)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    27a0:	009c      	lsls	r4, r3, #2
    27a2:	f104 44a0 	add.w	r4, r4, #1342177280	; 0x50000000
    27a6:	f8d4 0700 	ldr.w	r0, [r4, #1792]	; 0x700
    27aa:	f420 3040 	bic.w	r0, r0, #196608	; 0x30000

    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    27ae:	f8c4 0700 	str.w	r0, [r4, #1792]	; 0x700
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
    27b2:	6890      	ldr	r0, [r2, #8]
    27b4:	40c8      	lsrs	r0, r1
    27b6:	f010 0001 	ands.w	r0, r0, #1
    27ba:	d051      	beq.n	2860 <gpiote_pin_int_cfg+0x114>
    27bc:	68d0      	ldr	r0, [r2, #12]
    27be:	40c8      	lsrs	r0, r1
    27c0:	f010 0001 	ands.w	r0, r0, #1
    27c4:	d04c      	beq.n	2860 <gpiote_pin_int_cfg+0x114>
		if (data->trig_edge & BIT(pin)) {
    27c6:	6950      	ldr	r0, [r2, #20]
    27c8:	40c8      	lsrs	r0, r1
    27ca:	f010 0001 	ands.w	r0, r0, #1
    27ce:	d056      	beq.n	287e <gpiote_pin_int_cfg+0x132>
			if (data->double_edge & BIT(pin)) {
    27d0:	6990      	ldr	r0, [r2, #24]
    27d2:	40c8      	lsrs	r0, r1
    27d4:	07c0      	lsls	r0, r0, #31
    27d6:	d44a      	bmi.n	286e <gpiote_pin_int_cfg+0x122>
			} else if (((data->active_level & BIT(pin)) != 0U)
    27d8:	6910      	ldr	r0, [r2, #16]
				   ^ ((BIT(pin) & data->inverted) != 0)) {
    27da:	69d2      	ldr	r2, [r2, #28]
			} else if (((data->active_level & BIT(pin)) != 0U)
    27dc:	40c8      	lsrs	r0, r1
				   ^ ((BIT(pin) & data->inverted) != 0)) {
    27de:	fa22 f101 	lsr.w	r1, r2, r1
			} else if (((data->active_level & BIT(pin)) != 0U)
    27e2:	f000 0001 	and.w	r0, r0, #1
    27e6:	f001 0101 	and.w	r1, r1, #1
				pol = NRF_GPIOTE_POLARITY_HITOLO;
    27ea:	4288      	cmp	r0, r1
    27ec:	bf14      	ite	ne
    27ee:	2101      	movne	r1, #1
    27f0:	2102      	moveq	r1, #2
    p_reg->CONFIG[idx] = 0;
}

NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
    27f2:	4d2d      	ldr	r5, [pc, #180]	; (28a8 <gpiote_pin_int_cfg+0x15c>)
    27f4:	2400      	movs	r4, #0
    27f6:	f504 72a2 	add.w	r2, r4, #324	; 0x144
    27fa:	f855 0022 	ldr.w	r0, [r5, r2, lsl #2]
		if (!nrf_gpiote_te_is_enabled(NRF_GPIOTE, channel)) {
    27fe:	f010 0003 	ands.w	r0, r0, #3
    2802:	d136      	bne.n	2872 <gpiote_pin_int_cfg+0x126>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    2804:	00a2      	lsls	r2, r4, #2
    2806:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    280a:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    280e:	021b      	lsls	r3, r3, #8
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    2810:	f8d2 6510 	ldr.w	r6, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    2814:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
    2818:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    281c:	f426 3647 	bic.w	r6, r6, #203776	; 0x31c00
			nrf_gpiote_event_t evt =
    2820:	f104 0340 	add.w	r3, r4, #64	; 0x40
    2824:	f426 7640 	bic.w	r6, r6, #768	; 0x300
    2828:	009b      	lsls	r3, r3, #2
    282a:	f8c2 6510 	str.w	r6, [r2, #1296]	; 0x510
    return ((uint32_t)p_reg + event);
    282e:	b29b      	uxth	r3, r3
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    2830:	f8d2 6510 	ldr.w	r6, [r2, #1296]	; 0x510
    return ((uint32_t)p_reg + event);
    2834:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    2838:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    283c:	4331      	orrs	r1, r6
    283e:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    2842:	6018      	str	r0, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
    2844:	681b      	ldr	r3, [r3, #0]
    2846:	9301      	str	r3, [sp, #4]
    (void)dummy;
    2848:	9b01      	ldr	r3, [sp, #4]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    284a:	f8d2 3510 	ldr.w	r3, [r2, #1296]	; 0x510
    284e:	f043 0301 	orr.w	r3, r3, #1
    2852:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
    2856:	2301      	movs	r3, #1
    2858:	fa03 f404 	lsl.w	r4, r3, r4
    p_reg->INTENSET = mask;
    285c:	f8c5 4304 	str.w	r4, [r5, #772]	; 0x304
}
    2860:	b002      	add	sp, #8
    2862:	bd70      	pop	{r4, r5, r6, pc}
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    2864:	3001      	adds	r0, #1
    2866:	2808      	cmp	r0, #8
    2868:	f47f af7e 	bne.w	2768 <gpiote_pin_int_cfg+0x1c>
    286c:	e798      	b.n	27a0 <gpiote_pin_int_cfg+0x54>
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
    286e:	2103      	movs	r1, #3
    2870:	e7bf      	b.n	27f2 <gpiote_pin_int_cfg+0xa6>
    2872:	3401      	adds	r4, #1
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
    2874:	2c08      	cmp	r4, #8
    2876:	d1be      	bne.n	27f6 <gpiote_pin_int_cfg+0xaa>
	return -ENODEV;
    2878:	f06f 0012 	mvn.w	r0, #18
    287c:	e7f0      	b.n	2860 <gpiote_pin_int_cfg+0x114>
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
    287e:	6913      	ldr	r3, [r2, #16]
    2880:	69d2      	ldr	r2, [r2, #28]
    2882:	4053      	eors	r3, r2
    2884:	fa23 f101 	lsr.w	r1, r3, r1
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    2888:	f8d4 3700 	ldr.w	r3, [r4, #1792]	; 0x700
		return NRF_GPIO_PIN_SENSE_HIGH;
    288c:	f011 0f01 	tst.w	r1, #1
    2890:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    2894:	bf14      	ite	ne
    2896:	f44f 3200 	movne.w	r2, #131072	; 0x20000
    289a:	f44f 3240 	moveq.w	r2, #196608	; 0x30000
    289e:	4313      	orrs	r3, r2
    28a0:	f8c4 3700 	str.w	r3, [r4, #1792]	; 0x700
    28a4:	e7dc      	b.n	2860 <gpiote_pin_int_cfg+0x114>
    28a6:	bf00      	nop
    28a8:	40006000 	.word	0x40006000

000028ac <gpiote_event_handler>:
{
    28ac:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    28b0:	4953      	ldr	r1, [pc, #332]	; (2a00 <gpiote_event_handler+0x154>)
    28b2:	680d      	ldr	r5, [r1, #0]
	if (port_event) {
    28b4:	2d00      	cmp	r5, #0
    28b6:	d067      	beq.n	2988 <gpiote_event_handler+0xdc>
	struct gpio_nrfx_data *data = get_port_data(port);
    28b8:	4b52      	ldr	r3, [pc, #328]	; (2a04 <gpiote_event_handler+0x158>)
    28ba:	689a      	ldr	r2, [r3, #8]
	return port->config->config_info;
    28bc:	681b      	ldr	r3, [r3, #0]
    28be:	689e      	ldr	r6, [r3, #8]
	u32_t out = data->int_en & data->pin_int_en;
    28c0:	e9d2 0302 	ldrd	r0, r3, [r2, #8]
    28c4:	4003      	ands	r3, r0
	out &= ~data->trig_edge & ~data->double_edge;
    28c6:	e9d2 0405 	ldrd	r0, r4, [r2, #20]
    28ca:	4320      	orrs	r0, r4
    28cc:	ea23 0300 	bic.w	r3, r3, r0
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
    28d0:	6830      	ldr	r0, [r6, #0]
	u32_t pin_states = ~(port_in ^ data->inverted ^ data->active_level);
    28d2:	69d4      	ldr	r4, [r2, #28]
    28d4:	6912      	ldr	r2, [r2, #16]
}


NRF_STATIC_INLINE uint32_t nrf_gpio_port_in_read(NRF_GPIO_Type const * p_reg)
{
    return p_reg->IN;
    28d6:	f8d0 0510 	ldr.w	r0, [r0, #1296]	; 0x510
    28da:	4054      	eors	r4, r2
    28dc:	4044      	eors	r4, r0
	u32_t out = pin_states & level_pins;
    28de:	ea23 0404 	bic.w	r4, r3, r4
	u32_t bit = 1U << pin;
    28e2:	2001      	movs	r0, #1
	u32_t pin = 0U;
    28e4:	2700      	movs	r7, #0
	while (level_pins) {
    28e6:	2b00      	cmp	r3, #0
    28e8:	d138      	bne.n	295c <gpiote_event_handler+0xb0>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    28ea:	600b      	str	r3, [r1, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
    28ec:	680b      	ldr	r3, [r1, #0]
    28ee:	9300      	str	r3, [sp, #0]
    (void)dummy;
    28f0:	9b00      	ldr	r3, [sp, #0]
    return p_reg->INTENSET & mask;
    28f2:	4845      	ldr	r0, [pc, #276]	; (2a08 <gpiote_event_handler+0x15c>)
	u32_t fired_triggers[GPIO_COUNT] = {0};
    28f4:	2300      	movs	r3, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
    28f6:	2601      	movs	r6, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    28f8:	461f      	mov	r7, r3
    return p_reg->INTENSET & mask;
    28fa:	f8d0 2304 	ldr.w	r2, [r0, #772]	; 0x304
    28fe:	fa06 f103 	lsl.w	r1, r6, r3
    2902:	4211      	tst	r1, r2
    2904:	d013      	beq.n	292e <gpiote_event_handler+0x82>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    2906:	009a      	lsls	r2, r3, #2
    2908:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    290c:	f502 42c2 	add.w	r2, r2, #24832	; 0x6100
    2910:	6811      	ldr	r1, [r2, #0]
    2912:	b161      	cbz	r1, 292e <gpiote_event_handler+0x82>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    2914:	f503 71a2 	add.w	r1, r3, #324	; 0x144
    2918:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    291c:	6017      	str	r7, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
    291e:	6812      	ldr	r2, [r2, #0]
    2920:	9201      	str	r2, [sp, #4]
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    2922:	f3c1 2104 	ubfx	r1, r1, #8, #5
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
    2926:	fa06 f101 	lsl.w	r1, r6, r1
    (void)dummy;
    292a:	9a01      	ldr	r2, [sp, #4]
    292c:	430c      	orrs	r4, r1
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    292e:	3301      	adds	r3, #1
    2930:	2b08      	cmp	r3, #8
    2932:	d1e2      	bne.n	28fa <gpiote_event_handler+0x4e>
	if (fired_triggers[0]) {
    2934:	bb54      	cbnz	r4, 298c <gpiote_event_handler+0xe0>
	if (port_event) {
    2936:	b175      	cbz	r5, 2956 <gpiote_event_handler+0xaa>
	const struct gpio_nrfx_data *data = get_port_data(port);
    2938:	4b32      	ldr	r3, [pc, #200]	; (2a04 <gpiote_event_handler+0x158>)
    293a:	6899      	ldr	r1, [r3, #8]
	return port->config->config_info;
    293c:	681b      	ldr	r3, [r3, #0]
    293e:	689e      	ldr	r6, [r3, #8]
	u32_t out = data->int_en & data->pin_int_en;
    2940:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    2944:	4013      	ands	r3, r2
	out &= ~data->trig_edge & ~data->double_edge;
    2946:	e9d1 2005 	ldrd	r2, r0, [r1, #20]
    294a:	4302      	orrs	r2, r0
    294c:	ea23 0302 	bic.w	r3, r3, r2
	u32_t bit = 1U << pin;
    2950:	2401      	movs	r4, #1
	u32_t pin = 0U;
    2952:	2500      	movs	r5, #0
	while (level_pins) {
    2954:	bb8b      	cbnz	r3, 29ba <gpiote_event_handler+0x10e>
}
    2956:	b002      	add	sp, #8
    2958:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (level_pins & bit) {
    295c:	4203      	tst	r3, r0
    295e:	d010      	beq.n	2982 <gpiote_event_handler+0xd6>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    2960:	f896 c004 	ldrb.w	ip, [r6, #4]
    2964:	f007 021f 	and.w	r2, r7, #31
    2968:	ea42 124c 	orr.w	r2, r2, ip, lsl #5
    296c:	0092      	lsls	r2, r2, #2
    296e:	f102 42a0 	add.w	r2, r2, #1342177280	; 0x50000000
			level_pins &= ~bit;
    2972:	ea23 0300 	bic.w	r3, r3, r0
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    2976:	f8d2 c700 	ldr.w	ip, [r2, #1792]	; 0x700
    297a:	f42c 3c40 	bic.w	ip, ip, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    297e:	f8c2 c700 	str.w	ip, [r2, #1792]	; 0x700
		++pin;
    2982:	3701      	adds	r7, #1
		bit <<= 1;
    2984:	0040      	lsls	r0, r0, #1
    2986:	e7ae      	b.n	28e6 <gpiote_event_handler+0x3a>
	u32_t fired_triggers[GPIO_COUNT] = {0};
    2988:	462c      	mov	r4, r5
    298a:	e7b2      	b.n	28f2 <gpiote_event_handler+0x46>
	struct gpio_nrfx_data *data = get_port_data(port);
    298c:	4f1d      	ldr	r7, [pc, #116]	; (2a04 <gpiote_event_handler+0x158>)
    298e:	f8d7 8008 	ldr.w	r8, [r7, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    2992:	f8d8 1000 	ldr.w	r1, [r8]
    2996:	2900      	cmp	r1, #0
    2998:	d0cd      	beq.n	2936 <gpiote_event_handler+0x8a>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    299a:	680e      	ldr	r6, [r1, #0]
		if ((cb->pin_mask & pins) & data->int_en) {
    299c:	f8d8 300c 	ldr.w	r3, [r8, #12]
    29a0:	688a      	ldr	r2, [r1, #8]
    29a2:	4023      	ands	r3, r4
    29a4:	4213      	tst	r3, r2
    29a6:	d003      	beq.n	29b0 <gpiote_event_handler+0x104>
			cb->handler(port, cb, pins);
    29a8:	684b      	ldr	r3, [r1, #4]
    29aa:	4622      	mov	r2, r4
    29ac:	4638      	mov	r0, r7
    29ae:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    29b0:	2e00      	cmp	r6, #0
    29b2:	d0c0      	beq.n	2936 <gpiote_event_handler+0x8a>
    29b4:	4631      	mov	r1, r6
    29b6:	6836      	ldr	r6, [r6, #0]
    29b8:	e7f0      	b.n	299c <gpiote_event_handler+0xf0>
		if (level_pins & bit) {
    29ba:	421c      	tst	r4, r3
    29bc:	d01c      	beq.n	29f8 <gpiote_event_handler+0x14c>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    29be:	7930      	ldrb	r0, [r6, #4]
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
    29c0:	69cf      	ldr	r7, [r1, #28]
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    29c2:	f005 021f 	and.w	r2, r5, #31
    29c6:	ea42 1240 	orr.w	r2, r2, r0, lsl #5
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
    29ca:	6908      	ldr	r0, [r1, #16]
    29cc:	0092      	lsls	r2, r2, #2
    29ce:	4078      	eors	r0, r7
    29d0:	f102 42a0 	add.w	r2, r2, #1342177280	; 0x50000000
    29d4:	40e8      	lsrs	r0, r5
		return NRF_GPIO_PIN_SENSE_HIGH;
    29d6:	f010 0f01 	tst.w	r0, #1
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    29da:	f8d2 0700 	ldr.w	r0, [r2, #1792]	; 0x700
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    29de:	bf18      	it	ne
    29e0:	f44f 3700 	movne.w	r7, #131072	; 0x20000
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    29e4:	f420 3040 	bic.w	r0, r0, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    29e8:	bf08      	it	eq
    29ea:	f44f 3740 	moveq.w	r7, #196608	; 0x30000
    29ee:	4338      	orrs	r0, r7
    29f0:	f8c2 0700 	str.w	r0, [r2, #1792]	; 0x700
			level_pins &= ~bit;
    29f4:	ea23 0304 	bic.w	r3, r3, r4
		++pin;
    29f8:	3501      	adds	r5, #1
		bit <<= 1;
    29fa:	0064      	lsls	r4, r4, #1
    29fc:	e7aa      	b.n	2954 <gpiote_event_handler+0xa8>
    29fe:	bf00      	nop
    2a00:	4000617c 	.word	0x4000617c
    2a04:	20006988 	.word	0x20006988
    2a08:	40006000 	.word	0x40006000

00002a0c <twi_1_init>:
#ifdef CONFIG_I2C_0_NRF_TWI
I2C_NRFX_TWI_DEVICE(0);
#endif

#ifdef CONFIG_I2C_1_NRF_TWI
I2C_NRFX_TWI_DEVICE(1);
    2a0c:	b510      	push	{r4, lr}
    2a0e:	4604      	mov	r4, r0
    2a10:	2200      	movs	r2, #0
    2a12:	2101      	movs	r1, #1
    2a14:	2004      	movs	r0, #4
    2a16:	f7fe fbd9 	bl	11cc <z_arm_irq_priority_set>
	return dev->config->config_info;
    2a1a:	6823      	ldr	r3, [r4, #0]
	nrfx_err_t result = nrfx_twi_init(&get_dev_config(dev)->twi,
    2a1c:	4a0f      	ldr	r2, [pc, #60]	; (2a5c <twi_1_init+0x50>)
	return dev->config->config_info;
    2a1e:	6898      	ldr	r0, [r3, #8]
	nrfx_err_t result = nrfx_twi_init(&get_dev_config(dev)->twi,
    2a20:	4623      	mov	r3, r4
    2a22:	f100 0108 	add.w	r1, r0, #8
    2a26:	f000 fed7 	bl	37d8 <nrfx_twi_init>
	if (result != NRFX_SUCCESS) {
    2a2a:	4b0d      	ldr	r3, [pc, #52]	; (2a60 <twi_1_init+0x54>)
    2a2c:	4298      	cmp	r0, r3
    2a2e:	d012      	beq.n	2a56 <twi_1_init+0x4a>
		LOG_ERR("Failed to initialize device: %s",
    2a30:	2301      	movs	r3, #1
    2a32:	f04f 0200 	mov.w	r2, #0
    2a36:	f363 0207 	bfi	r2, r3, #0, #8
    2a3a:	490a      	ldr	r1, [pc, #40]	; (2a64 <twi_1_init+0x58>)
    2a3c:	4b0a      	ldr	r3, [pc, #40]	; (2a68 <twi_1_init+0x5c>)
    2a3e:	480b      	ldr	r0, [pc, #44]	; (2a6c <twi_1_init+0x60>)
    2a40:	1a5b      	subs	r3, r3, r1
    2a42:	08db      	lsrs	r3, r3, #3
    2a44:	f363 128f 	bfi	r2, r3, #6, #10
    2a48:	6823      	ldr	r3, [r4, #0]
    2a4a:	6819      	ldr	r1, [r3, #0]
    2a4c:	f005 f88e 	bl	7b6c <log_1>
		return -EBUSY;
    2a50:	f06f 000f 	mvn.w	r0, #15
I2C_NRFX_TWI_DEVICE(1);
    2a54:	bd10      	pop	{r4, pc}
	return 0;
    2a56:	2000      	movs	r0, #0
I2C_NRFX_TWI_DEVICE(1);
    2a58:	e7fc      	b.n	2a54 <twi_1_init+0x48>
    2a5a:	bf00      	nop
    2a5c:	00002bd5 	.word	0x00002bd5
    2a60:	0bad0000 	.word	0x0bad0000
    2a64:	0000b17c 	.word	0x0000b17c
    2a68:	0000b19c 	.word	0x0000b19c
    2a6c:	0000bf7f 	.word	0x0000bf7f

00002a70 <i2c_nrfx_twi_configure>:
{
    2a70:	b508      	push	{r3, lr}
	return dev->config->config_info;
    2a72:	6803      	ldr	r3, [r0, #0]
	if (I2C_ADDR_10_BITS & dev_config) {
    2a74:	07ca      	lsls	r2, r1, #31
	return dev->config->config_info;
    2a76:	689b      	ldr	r3, [r3, #8]
	if (I2C_ADDR_10_BITS & dev_config) {
    2a78:	d413      	bmi.n	2aa2 <i2c_nrfx_twi_configure+0x32>
	switch (I2C_SPEED_GET(dev_config)) {
    2a7a:	f3c1 0242 	ubfx	r2, r1, #1, #3
    2a7e:	2a01      	cmp	r2, #1
    2a80:	d012      	beq.n	2aa8 <i2c_nrfx_twi_configure+0x38>
    2a82:	2a02      	cmp	r2, #2
    2a84:	d019      	beq.n	2aba <i2c_nrfx_twi_configure+0x4a>
		LOG_ERR("unsupported speed");
    2a86:	2301      	movs	r3, #1
    2a88:	f04f 0100 	mov.w	r1, #0
    2a8c:	f363 0107 	bfi	r1, r3, #0, #8
    2a90:	4a0c      	ldr	r2, [pc, #48]	; (2ac4 <i2c_nrfx_twi_configure+0x54>)
    2a92:	4b0d      	ldr	r3, [pc, #52]	; (2ac8 <i2c_nrfx_twi_configure+0x58>)
    2a94:	480d      	ldr	r0, [pc, #52]	; (2acc <i2c_nrfx_twi_configure+0x5c>)
    2a96:	1a9b      	subs	r3, r3, r2
    2a98:	08db      	lsrs	r3, r3, #3
    2a9a:	f363 118f 	bfi	r1, r3, #6, #10
    2a9e:	f005 f858 	bl	7b52 <log_0>
		return -EINVAL;
    2aa2:	f06f 0015 	mvn.w	r0, #21
    2aa6:	e007      	b.n	2ab8 <i2c_nrfx_twi_configure+0x48>
		nrf_twi_frequency_set(inst->p_twi, NRF_TWI_FREQ_100K);
    2aa8:	681b      	ldr	r3, [r3, #0]
}

NRF_STATIC_INLINE void nrf_twi_frequency_set(NRF_TWI_Type *      p_reg,
                                             nrf_twi_frequency_t frequency)
{
    p_reg->FREQUENCY = frequency;
    2aaa:	f04f 72cc 	mov.w	r2, #26738688	; 0x1980000
    2aae:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	get_dev_data(dev)->dev_config = dev_config;
    2ab2:	6883      	ldr	r3, [r0, #8]
	return 0;
    2ab4:	2000      	movs	r0, #0
	get_dev_data(dev)->dev_config = dev_config;
    2ab6:	6259      	str	r1, [r3, #36]	; 0x24
}
    2ab8:	bd08      	pop	{r3, pc}
		nrf_twi_frequency_set(inst->p_twi, NRF_TWI_FREQ_400K);
    2aba:	681b      	ldr	r3, [r3, #0]
    2abc:	f04f 62cd 	mov.w	r2, #107479040	; 0x6680000
    2ac0:	e7f5      	b.n	2aae <i2c_nrfx_twi_configure+0x3e>
    2ac2:	bf00      	nop
    2ac4:	0000b17c 	.word	0x0000b17c
    2ac8:	0000b19c 	.word	0x0000b19c
    2acc:	0000bf39 	.word	0x0000bf39

00002ad0 <i2c_nrfx_twi_transfer>:
{
    2ad0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2ad4:	4605      	mov	r5, r0
    2ad6:	b087      	sub	sp, #28
    2ad8:	460c      	mov	r4, r1
    2ada:	4617      	mov	r7, r2
    2adc:	4699      	mov	r9, r3
	k_sem_take(&(get_dev_data(dev)->transfer_sync), K_FOREVER);
    2ade:	6880      	ldr	r0, [r0, #8]
    2ae0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2ae4:	f004 fbda 	bl	729c <z_impl_k_sem_take>
	return dev->config->config_info;
    2ae8:	682b      	ldr	r3, [r5, #0]
		if (res != NRFX_SUCCESS) {
    2aea:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 2bd0 <i2c_nrfx_twi_transfer+0x100>
	nrfx_twi_enable(&get_dev_config(dev)->twi);
    2aee:	6898      	ldr	r0, [r3, #8]
    2af0:	f000 feb6 	bl	3860 <nrfx_twi_enable>
	for (size_t i = 0; i < num_msgs; i++) {
    2af4:	2600      	movs	r6, #0
    2af6:	42be      	cmp	r6, r7
    2af8:	d301      	bcc.n	2afe <i2c_nrfx_twi_transfer+0x2e>
	int ret = 0;
    2afa:	2400      	movs	r4, #0
    2afc:	e02e      	b.n	2b5c <i2c_nrfx_twi_transfer+0x8c>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
    2afe:	f894 b008 	ldrb.w	fp, [r4, #8]
    2b02:	f01b 0a08 	ands.w	sl, fp, #8
    2b06:	d158      	bne.n	2bba <i2c_nrfx_twi_transfer+0xea>
		nrfx_twi_xfer_desc_t cur_xfer = {
    2b08:	2212      	movs	r2, #18
    2b0a:	4651      	mov	r1, sl
    2b0c:	f10d 0006 	add.w	r0, sp, #6
    2b10:	f005 faf6 	bl	8100 <memset>
    2b14:	6862      	ldr	r2, [r4, #4]
    2b16:	9202      	str	r2, [sp, #8]
					  NRFX_TWI_XFER_RX : NRFX_TWI_XFER_TX
    2b18:	f00b 0301 	and.w	r3, fp, #1
		nrfx_twi_xfer_desc_t cur_xfer = {
    2b1c:	6822      	ldr	r2, [r4, #0]
    2b1e:	f88d 3004 	strb.w	r3, [sp, #4]
		if (!(msgs[i].flags & I2C_MSG_STOP)) {
    2b22:	f01b 0f02 	tst.w	fp, #2
		nrfx_twi_xfer_desc_t cur_xfer = {
    2b26:	f88d 9005 	strb.w	r9, [sp, #5]
    2b2a:	9204      	str	r2, [sp, #16]
		if (!(msgs[i].flags & I2C_MSG_STOP)) {
    2b2c:	d121      	bne.n	2b72 <i2c_nrfx_twi_transfer+0xa2>
			if ((i < (num_msgs - 1)) &&
    2b2e:	1e7a      	subs	r2, r7, #1
    2b30:	42b2      	cmp	r2, r6
    2b32:	d902      	bls.n	2b3a <i2c_nrfx_twi_transfer+0x6a>
    2b34:	7d22      	ldrb	r2, [r4, #20]
    2b36:	0752      	lsls	r2, r2, #29
    2b38:	d51d      	bpl.n	2b76 <i2c_nrfx_twi_transfer+0xa6>
			} else if (msgs[i].flags & I2C_MSG_READ) {
    2b3a:	2b00      	cmp	r3, #0
    2b3c:	d13d      	bne.n	2bba <i2c_nrfx_twi_transfer+0xea>
				xfer_flags |= NRFX_TWI_FLAG_TX_NO_STOP;
    2b3e:	2220      	movs	r2, #32
	return dev->config->config_info;
    2b40:	682b      	ldr	r3, [r5, #0]
		res = nrfx_twi_xfer(&get_dev_config(dev)->twi,
    2b42:	a901      	add	r1, sp, #4
    2b44:	6898      	ldr	r0, [r3, #8]
    2b46:	f000 feb5 	bl	38b4 <nrfx_twi_xfer>
		if (res != NRFX_SUCCESS) {
    2b4a:	4540      	cmp	r0, r8
    2b4c:	d015      	beq.n	2b7a <i2c_nrfx_twi_transfer+0xaa>
			if (res == NRFX_ERROR_BUSY) {
    2b4e:	4b1c      	ldr	r3, [pc, #112]	; (2bc0 <i2c_nrfx_twi_transfer+0xf0>)
				ret = -EIO;
    2b50:	4298      	cmp	r0, r3
    2b52:	bf0c      	ite	eq
    2b54:	f06f 040f 	mvneq.w	r4, #15
    2b58:	f06f 0404 	mvnne.w	r4, #4
	return dev->config->config_info;
    2b5c:	682b      	ldr	r3, [r5, #0]
	nrfx_twi_disable(&get_dev_config(dev)->twi);
    2b5e:	6898      	ldr	r0, [r3, #8]
    2b60:	f000 fe8e 	bl	3880 <nrfx_twi_disable>
	k_sem_give(&(get_dev_data(dev)->transfer_sync));
    2b64:	68a8      	ldr	r0, [r5, #8]
	z_impl_k_sem_give(sem);
    2b66:	f004 fb73 	bl	7250 <z_impl_k_sem_give>
}
    2b6a:	4620      	mov	r0, r4
    2b6c:	b007      	add	sp, #28
    2b6e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		u32_t xfer_flags = 0;
    2b72:	4652      	mov	r2, sl
    2b74:	e7e4      	b.n	2b40 <i2c_nrfx_twi_transfer+0x70>
				xfer_flags |= NRFX_TWI_FLAG_SUSPEND;
    2b76:	2240      	movs	r2, #64	; 0x40
    2b78:	e7e2      	b.n	2b40 <i2c_nrfx_twi_transfer+0x70>
		k_sem_take(&(get_dev_data(dev)->completion_sync), K_FOREVER);
    2b7a:	68a8      	ldr	r0, [r5, #8]
    2b7c:	3010      	adds	r0, #16
	return z_impl_k_sem_take(sem, timeout);
    2b7e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2b82:	f004 fb8b 	bl	729c <z_impl_k_sem_take>
		res = get_dev_data(dev)->res;
    2b86:	68ab      	ldr	r3, [r5, #8]
    2b88:	6a19      	ldr	r1, [r3, #32]
		if (res != NRFX_SUCCESS) {
    2b8a:	4541      	cmp	r1, r8
    2b8c:	f104 040c 	add.w	r4, r4, #12
    2b90:	d011      	beq.n	2bb6 <i2c_nrfx_twi_transfer+0xe6>
			LOG_ERR("Error %d occurred for message %d", res, i);
    2b92:	2201      	movs	r2, #1
    2b94:	f04f 0300 	mov.w	r3, #0
    2b98:	f362 0307 	bfi	r3, r2, #0, #8
    2b9c:	4809      	ldr	r0, [pc, #36]	; (2bc4 <i2c_nrfx_twi_transfer+0xf4>)
    2b9e:	4a0a      	ldr	r2, [pc, #40]	; (2bc8 <i2c_nrfx_twi_transfer+0xf8>)
    2ba0:	1a12      	subs	r2, r2, r0
    2ba2:	08d2      	lsrs	r2, r2, #3
    2ba4:	f362 138f 	bfi	r3, r2, #6, #10
    2ba8:	4808      	ldr	r0, [pc, #32]	; (2bcc <i2c_nrfx_twi_transfer+0xfc>)
    2baa:	4632      	mov	r2, r6
    2bac:	f004 fff2 	bl	7b94 <log_2>
			ret = -EIO;
    2bb0:	f06f 0404 	mvn.w	r4, #4
			break;
    2bb4:	e7d2      	b.n	2b5c <i2c_nrfx_twi_transfer+0x8c>
	for (size_t i = 0; i < num_msgs; i++) {
    2bb6:	3601      	adds	r6, #1
    2bb8:	e79d      	b.n	2af6 <i2c_nrfx_twi_transfer+0x26>
			ret = -ENOTSUP;
    2bba:	f06f 0422 	mvn.w	r4, #34	; 0x22
    2bbe:	e7cd      	b.n	2b5c <i2c_nrfx_twi_transfer+0x8c>
    2bc0:	0bad000b 	.word	0x0bad000b
    2bc4:	0000b17c 	.word	0x0000b17c
    2bc8:	0000b19c 	.word	0x0000b19c
    2bcc:	0000bf4b 	.word	0x0000bf4b
    2bd0:	0bad0000 	.word	0x0bad0000

00002bd4 <event_handler>:
	switch (p_event->type) {
    2bd4:	7802      	ldrb	r2, [r0, #0]
	struct i2c_nrfx_twi_data *dev_data = get_dev_data(dev);
    2bd6:	688b      	ldr	r3, [r1, #8]
	switch (p_event->type) {
    2bd8:	2a01      	cmp	r2, #1
    2bda:	d00a      	beq.n	2bf2 <event_handler+0x1e>
    2bdc:	b11a      	cbz	r2, 2be6 <event_handler+0x12>
    2bde:	2a02      	cmp	r2, #2
    2be0:	d009      	beq.n	2bf6 <event_handler+0x22>
		dev_data->res = NRFX_ERROR_INTERNAL;
    2be2:	4a06      	ldr	r2, [pc, #24]	; (2bfc <event_handler+0x28>)
    2be4:	e000      	b.n	2be8 <event_handler+0x14>
		dev_data->res = NRFX_SUCCESS;
    2be6:	4a06      	ldr	r2, [pc, #24]	; (2c00 <event_handler+0x2c>)
		dev_data->res = NRFX_ERROR_INTERNAL;
    2be8:	621a      	str	r2, [r3, #32]
	z_impl_k_sem_give(sem);
    2bea:	f103 0010 	add.w	r0, r3, #16
    2bee:	f004 bb2f 	b.w	7250 <z_impl_k_sem_give>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
    2bf2:	4a04      	ldr	r2, [pc, #16]	; (2c04 <event_handler+0x30>)
    2bf4:	e7f8      	b.n	2be8 <event_handler+0x14>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
    2bf6:	4a04      	ldr	r2, [pc, #16]	; (2c08 <event_handler+0x34>)
    2bf8:	e7f6      	b.n	2be8 <event_handler+0x14>
    2bfa:	bf00      	nop
    2bfc:	0bad0001 	.word	0x0bad0001
    2c00:	0bad0000 	.word	0x0bad0000
    2c04:	0bae0001 	.word	0x0bae0001
    2c08:	0bae0002 	.word	0x0bae0002

00002c0c <spi_0_init>:
		      &spi_##idx##z_config,				       \
		      POST_KERNEL, CONFIG_SPI_INIT_PRIORITY,		       \
		      &spi_nrfx_driver_api)

#ifdef CONFIG_SPI_0_NRF_SPI
SPI_NRFX_SPI_DEVICE(0);
    2c0c:	b510      	push	{r4, lr}
    2c0e:	4604      	mov	r4, r0
    2c10:	2200      	movs	r2, #0
    2c12:	2101      	movs	r1, #1
    2c14:	2003      	movs	r0, #3
    2c16:	f7fe fad9 	bl	11cc <z_arm_irq_priority_set>
	return dev->config->config_info;
    2c1a:	6823      	ldr	r3, [r4, #0]
	nrfx_err_t result = nrfx_spi_init(&get_dev_config(dev)->spi,
    2c1c:	4a10      	ldr	r2, [pc, #64]	; (2c60 <spi_0_init+0x54>)
	return dev->config->config_info;
    2c1e:	6898      	ldr	r0, [r3, #8]
	nrfx_err_t result = nrfx_spi_init(&get_dev_config(dev)->spi,
    2c20:	4623      	mov	r3, r4
    2c22:	f100 0108 	add.w	r1, r0, #8
    2c26:	f000 fb97 	bl	3358 <nrfx_spi_init>
	if (result != NRFX_SUCCESS) {
    2c2a:	4b0e      	ldr	r3, [pc, #56]	; (2c64 <spi_0_init+0x58>)
    2c2c:	4298      	cmp	r0, r3
    2c2e:	d012      	beq.n	2c56 <spi_0_init+0x4a>
		LOG_ERR("Failed to initialize device: %s",
    2c30:	2301      	movs	r3, #1
    2c32:	f04f 0200 	mov.w	r2, #0
    2c36:	f363 0207 	bfi	r2, r3, #0, #8
    2c3a:	490b      	ldr	r1, [pc, #44]	; (2c68 <spi_0_init+0x5c>)
    2c3c:	4b0b      	ldr	r3, [pc, #44]	; (2c6c <spi_0_init+0x60>)
    2c3e:	480c      	ldr	r0, [pc, #48]	; (2c70 <spi_0_init+0x64>)
    2c40:	1a5b      	subs	r3, r3, r1
    2c42:	08db      	lsrs	r3, r3, #3
    2c44:	f363 128f 	bfi	r2, r3, #6, #10
    2c48:	6823      	ldr	r3, [r4, #0]
    2c4a:	6819      	ldr	r1, [r3, #0]
    2c4c:	f004 ff8e 	bl	7b6c <log_1>
		return -EBUSY;
    2c50:	f06f 000f 	mvn.w	r0, #15
SPI_NRFX_SPI_DEVICE(0);
    2c54:	bd10      	pop	{r4, pc}
	spi_context_unlock_unconditionally(&get_dev_data(dev)->ctx);
    2c56:	68a0      	ldr	r0, [r4, #8]
    2c58:	f005 fdd9 	bl	880e <spi_context_unlock_unconditionally>
	return 0;
    2c5c:	2000      	movs	r0, #0
SPI_NRFX_SPI_DEVICE(0);
    2c5e:	e7f9      	b.n	2c54 <spi_0_init+0x48>
    2c60:	00002cf5 	.word	0x00002cf5
    2c64:	0bad0000 	.word	0x0bad0000
    2c68:	0000b17c 	.word	0x0000b17c
    2c6c:	0000b1d4 	.word	0x0000b1d4
    2c70:	0000bf7f 	.word	0x0000bf7f

00002c74 <transfer_next_chunk>:
{
    2c74:	b530      	push	{r4, r5, lr}
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    2c76:	6885      	ldr	r5, [r0, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
}

static inline size_t spi_context_longest_current_buf(struct spi_context *ctx)
{
	if (!ctx->tx_len) {
    2c78:	6bea      	ldr	r2, [r5, #60]	; 0x3c
    2c7a:	6c6b      	ldr	r3, [r5, #68]	; 0x44
{
    2c7c:	b085      	sub	sp, #20
    2c7e:	b982      	cbnz	r2, 2ca2 <transfer_next_chunk+0x2e>
	if (chunk_len > 0) {
    2c80:	bb7b      	cbnz	r3, 2ce2 <transfer_next_chunk+0x6e>
	int error = 0;
    2c82:	461c      	mov	r4, r3
	_spi_context_cs_control(ctx, on, false);
    2c84:	2200      	movs	r2, #0
    2c86:	4611      	mov	r1, r2
    2c88:	4628      	mov	r0, r5
    2c8a:	f005 fd96 	bl	87ba <_spi_context_cs_control.isra.7>
	ctx->sync_status = status;
    2c8e:	626c      	str	r4, [r5, #36]	; 0x24
    2c90:	f105 0014 	add.w	r0, r5, #20
    2c94:	f004 fadc 	bl	7250 <z_impl_k_sem_give>
	dev_data->busy = false;
    2c98:	2300      	movs	r3, #0
    2c9a:	f885 304c 	strb.w	r3, [r5, #76]	; 0x4c
}
    2c9e:	b005      	add	sp, #20
    2ca0:	bd30      	pop	{r4, r5, pc}
		return ctx->rx_len;
	} else if (!ctx->rx_len) {
    2ca2:	4611      	mov	r1, r2
    2ca4:	b113      	cbz	r3, 2cac <transfer_next_chunk+0x38>
		return ctx->tx_len;
	} else if (ctx->tx_len < ctx->rx_len) {
    2ca6:	429a      	cmp	r2, r3
    2ca8:	bf28      	it	cs
    2caa:	4619      	movcs	r1, r3
		xfer.p_tx_buffer = ctx->tx_buf;
    2cac:	6bac      	ldr	r4, [r5, #56]	; 0x38
		dev_data->chunk_len = chunk_len;
    2cae:	64a9      	str	r1, [r5, #72]	; 0x48
		xfer.p_tx_buffer = ctx->tx_buf;
    2cb0:	9400      	str	r4, [sp, #0]
	return !!(ctx->tx_buf && ctx->tx_len);
    2cb2:	b1c4      	cbz	r4, 2ce6 <transfer_next_chunk+0x72>
    2cb4:	2a00      	cmp	r2, #0
    2cb6:	bf18      	it	ne
    2cb8:	460a      	movne	r2, r1
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    2cba:	9201      	str	r2, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
    2cbc:	6c2a      	ldr	r2, [r5, #64]	; 0x40
    2cbe:	9202      	str	r2, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
    2cc0:	b19a      	cbz	r2, 2cea <transfer_next_chunk+0x76>
    2cc2:	2b00      	cmp	r3, #0
    2cc4:	bf18      	it	ne
    2cc6:	460b      	movne	r3, r1
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    2cc8:	9303      	str	r3, [sp, #12]
	return dev->config->config_info;
    2cca:	6803      	ldr	r3, [r0, #0]
		result = nrfx_spi_xfer(&get_dev_config(dev)->spi, &xfer, 0);
    2ccc:	2200      	movs	r2, #0
    2cce:	6898      	ldr	r0, [r3, #8]
    2cd0:	4669      	mov	r1, sp
    2cd2:	f000 fbe7 	bl	34a4 <nrfx_spi_xfer>
		if (result == NRFX_SUCCESS) {
    2cd6:	4b06      	ldr	r3, [pc, #24]	; (2cf0 <transfer_next_chunk+0x7c>)
    2cd8:	4298      	cmp	r0, r3
    2cda:	d0e0      	beq.n	2c9e <transfer_next_chunk+0x2a>
		error = -EIO;
    2cdc:	f06f 0404 	mvn.w	r4, #4
    2ce0:	e7d0      	b.n	2c84 <transfer_next_chunk+0x10>
    2ce2:	4619      	mov	r1, r3
    2ce4:	e7e2      	b.n	2cac <transfer_next_chunk+0x38>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    2ce6:	4622      	mov	r2, r4
    2ce8:	e7e7      	b.n	2cba <transfer_next_chunk+0x46>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    2cea:	4613      	mov	r3, r2
    2cec:	e7ec      	b.n	2cc8 <transfer_next_chunk+0x54>
    2cee:	bf00      	nop
    2cf0:	0bad0000 	.word	0x0bad0000

00002cf4 <event_handler>:
{
    2cf4:	b538      	push	{r3, r4, r5, lr}
	if (p_event->type == NRFX_SPI_EVENT_DONE) {
    2cf6:	7803      	ldrb	r3, [r0, #0]
{
    2cf8:	460d      	mov	r5, r1
	if (p_event->type == NRFX_SPI_EVENT_DONE) {
    2cfa:	2b00      	cmp	r3, #0
    2cfc:	d157      	bne.n	2dae <event_handler+0xba>
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    2cfe:	688c      	ldr	r4, [r1, #8]
	if (!ctx->tx_len) {
    2d00:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    2d02:	b183      	cbz	r3, 2d26 <event_handler+0x32>
		spi_context_update_tx(&dev_data->ctx, 1, dev_data->chunk_len);
    2d04:	6ca2      	ldr	r2, [r4, #72]	; 0x48
	if (len > ctx->tx_len) {
    2d06:	429a      	cmp	r2, r3
    2d08:	d925      	bls.n	2d56 <event_handler+0x62>
		LOG_ERR("Update exceeds current buffer");
    2d0a:	2301      	movs	r3, #1
    2d0c:	f04f 0100 	mov.w	r1, #0
    2d10:	f363 0107 	bfi	r1, r3, #0, #8
    2d14:	4a26      	ldr	r2, [pc, #152]	; (2db0 <event_handler+0xbc>)
    2d16:	4b27      	ldr	r3, [pc, #156]	; (2db4 <event_handler+0xc0>)
    2d18:	4827      	ldr	r0, [pc, #156]	; (2db8 <event_handler+0xc4>)
    2d1a:	1a9b      	subs	r3, r3, r2
    2d1c:	08db      	lsrs	r3, r3, #3
    2d1e:	f363 118f 	bfi	r1, r3, #6, #10
    2d22:	f004 ff16 	bl	7b52 <log_0>
	if (!ctx->rx_len) {
    2d26:	6c63      	ldr	r3, [r4, #68]	; 0x44
    2d28:	b183      	cbz	r3, 2d4c <event_handler+0x58>
		spi_context_update_rx(&dev_data->ctx, 1, dev_data->chunk_len);
    2d2a:	6ca2      	ldr	r2, [r4, #72]	; 0x48
	if (len > ctx->rx_len) {
    2d2c:	429a      	cmp	r2, r3
    2d2e:	d928      	bls.n	2d82 <event_handler+0x8e>
		LOG_ERR("Update exceeds current buffer");
    2d30:	2301      	movs	r3, #1
    2d32:	f04f 0100 	mov.w	r1, #0
    2d36:	f363 0107 	bfi	r1, r3, #0, #8
    2d3a:	4a1d      	ldr	r2, [pc, #116]	; (2db0 <event_handler+0xbc>)
    2d3c:	4b1d      	ldr	r3, [pc, #116]	; (2db4 <event_handler+0xc0>)
    2d3e:	481e      	ldr	r0, [pc, #120]	; (2db8 <event_handler+0xc4>)
    2d40:	1a9b      	subs	r3, r3, r2
    2d42:	08db      	lsrs	r3, r3, #3
    2d44:	f363 118f 	bfi	r1, r3, #6, #10
    2d48:	f004 ff03 	bl	7b52 <log_0>
		transfer_next_chunk(dev);
    2d4c:	4628      	mov	r0, r5
}
    2d4e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		transfer_next_chunk(dev);
    2d52:	f7ff bf8f 	b.w	2c74 <transfer_next_chunk>
	ctx->tx_len -= len;
    2d56:	1a9b      	subs	r3, r3, r2
    2d58:	63e3      	str	r3, [r4, #60]	; 0x3c
	if (!ctx->tx_len) {
    2d5a:	b963      	cbnz	r3, 2d76 <event_handler+0x82>
		ctx->tx_count--;
    2d5c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2d5e:	3b01      	subs	r3, #1
    2d60:	62e3      	str	r3, [r4, #44]	; 0x2c
		if (ctx->tx_count) {
    2d62:	b163      	cbz	r3, 2d7e <event_handler+0x8a>
			ctx->current_tx++;
    2d64:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2d66:	f103 0208 	add.w	r2, r3, #8
    2d6a:	62a2      	str	r2, [r4, #40]	; 0x28
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    2d6c:	689a      	ldr	r2, [r3, #8]
			ctx->tx_len = ctx->current_tx->len / dfs;
    2d6e:	68db      	ldr	r3, [r3, #12]
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    2d70:	63a2      	str	r2, [r4, #56]	; 0x38
			ctx->tx_len = ctx->current_tx->len / dfs;
    2d72:	63e3      	str	r3, [r4, #60]	; 0x3c
    2d74:	e7d7      	b.n	2d26 <event_handler+0x32>
	} else if (ctx->tx_buf) {
    2d76:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    2d78:	2b00      	cmp	r3, #0
    2d7a:	d0d4      	beq.n	2d26 <event_handler+0x32>
		ctx->tx_buf += dfs * len;
    2d7c:	4413      	add	r3, r2
    2d7e:	63a3      	str	r3, [r4, #56]	; 0x38
    2d80:	e7d1      	b.n	2d26 <event_handler+0x32>
	ctx->rx_len -= len;
    2d82:	1a9b      	subs	r3, r3, r2
    2d84:	6463      	str	r3, [r4, #68]	; 0x44
	if (!ctx->rx_len) {
    2d86:	b963      	cbnz	r3, 2da2 <event_handler+0xae>
		ctx->rx_count--;
    2d88:	6b63      	ldr	r3, [r4, #52]	; 0x34
    2d8a:	3b01      	subs	r3, #1
    2d8c:	6363      	str	r3, [r4, #52]	; 0x34
		if (ctx->rx_count) {
    2d8e:	b163      	cbz	r3, 2daa <event_handler+0xb6>
			ctx->current_rx++;
    2d90:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2d92:	f103 0208 	add.w	r2, r3, #8
    2d96:	6322      	str	r2, [r4, #48]	; 0x30
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    2d98:	689a      	ldr	r2, [r3, #8]
			ctx->rx_len = ctx->current_rx->len / dfs;
    2d9a:	68db      	ldr	r3, [r3, #12]
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    2d9c:	6422      	str	r2, [r4, #64]	; 0x40
			ctx->rx_len = ctx->current_rx->len / dfs;
    2d9e:	6463      	str	r3, [r4, #68]	; 0x44
    2da0:	e7d4      	b.n	2d4c <event_handler+0x58>
	} else if (ctx->rx_buf) {
    2da2:	6c23      	ldr	r3, [r4, #64]	; 0x40
    2da4:	2b00      	cmp	r3, #0
    2da6:	d0d1      	beq.n	2d4c <event_handler+0x58>
		ctx->rx_buf += dfs * len;
    2da8:	4413      	add	r3, r2
    2daa:	6423      	str	r3, [r4, #64]	; 0x40
    2dac:	e7ce      	b.n	2d4c <event_handler+0x58>
}
    2dae:	bd38      	pop	{r3, r4, r5, pc}
    2db0:	0000b17c 	.word	0x0000b17c
    2db4:	0000b1d4 	.word	0x0000b1d4
    2db8:	0000bf9f 	.word	0x0000bf9f

00002dbc <spi_nrfx_transceive>:
{
    2dbc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2dc0:	4607      	mov	r7, r0
	k_sem_take(&ctx->lock, K_FOREVER);
    2dc2:	6880      	ldr	r0, [r0, #8]
    2dc4:	4688      	mov	r8, r1
    2dc6:	4616      	mov	r6, r2
    2dc8:	461d      	mov	r5, r3
    2dca:	3004      	adds	r0, #4
	return z_impl_k_sem_take(sem, timeout);
    2dcc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2dd0:	f004 fa64 	bl	729c <z_impl_k_sem_take>
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    2dd4:	68bc      	ldr	r4, [r7, #8]
	if (spi_context_configured(ctx, spi_cfg)) {
    2dd6:	6823      	ldr	r3, [r4, #0]
    2dd8:	4598      	cmp	r8, r3
    2dda:	f000 80b0 	beq.w	2f3e <spi_nrfx_transceive+0x182>
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
    2dde:	f8b8 3004 	ldrh.w	r3, [r8, #4]
	const nrfx_spi_t *spi = &get_dev_config(dev)->spi;
    2de2:	6838      	ldr	r0, [r7, #0]
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
    2de4:	07d9      	lsls	r1, r3, #31
    2de6:	d516      	bpl.n	2e16 <spi_nrfx_transceive+0x5a>
		LOG_ERR("Slave mode is not supported on %s",
    2de8:	2301      	movs	r3, #1
    2dea:	f04f 0200 	mov.w	r2, #0
    2dee:	f363 0207 	bfi	r2, r3, #0, #8
    2df2:	4980      	ldr	r1, [pc, #512]	; (2ff4 <spi_nrfx_transceive+0x238>)
    2df4:	4b80      	ldr	r3, [pc, #512]	; (2ff8 <spi_nrfx_transceive+0x23c>)
    2df6:	1a5b      	subs	r3, r3, r1
    2df8:	08db      	lsrs	r3, r3, #3
    2dfa:	6801      	ldr	r1, [r0, #0]
    2dfc:	487f      	ldr	r0, [pc, #508]	; (2ffc <spi_nrfx_transceive+0x240>)
    2dfe:	f363 128f 	bfi	r2, r3, #6, #10
    2e02:	f004 feb3 	bl	7b6c <log_1>
		return -EINVAL;
    2e06:	f06f 0515 	mvn.w	r5, #21
	z_impl_k_sem_give(sem);
    2e0a:	1d20      	adds	r0, r4, #4
    2e0c:	f004 fa20 	bl	7250 <z_impl_k_sem_give>
}
    2e10:	4628      	mov	r0, r5
    2e12:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (spi_cfg->operation & SPI_MODE_LOOP) {
    2e16:	071a      	lsls	r2, r3, #28
    2e18:	d50e      	bpl.n	2e38 <spi_nrfx_transceive+0x7c>
		LOG_ERR("Loopback mode is not supported");
    2e1a:	2301      	movs	r3, #1
    2e1c:	f04f 0100 	mov.w	r1, #0
    2e20:	f363 0107 	bfi	r1, r3, #0, #8
    2e24:	4a73      	ldr	r2, [pc, #460]	; (2ff4 <spi_nrfx_transceive+0x238>)
    2e26:	4b74      	ldr	r3, [pc, #464]	; (2ff8 <spi_nrfx_transceive+0x23c>)
    2e28:	4875      	ldr	r0, [pc, #468]	; (3000 <spi_nrfx_transceive+0x244>)
    2e2a:	1a9b      	subs	r3, r3, r2
    2e2c:	08db      	lsrs	r3, r3, #3
    2e2e:	f363 118f 	bfi	r1, r3, #6, #10
		LOG_ERR("Word sizes other than 8 bits"
    2e32:	f004 fe8e 	bl	7b52 <log_0>
    2e36:	e7e6      	b.n	2e06 <spi_nrfx_transceive+0x4a>
	if ((spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
    2e38:	f413 51c0 	ands.w	r1, r3, #6144	; 0x1800
    2e3c:	d00c      	beq.n	2e58 <spi_nrfx_transceive+0x9c>
		LOG_ERR("Only single line mode is supported");
    2e3e:	2301      	movs	r3, #1
    2e40:	f04f 0100 	mov.w	r1, #0
    2e44:	f363 0107 	bfi	r1, r3, #0, #8
    2e48:	4a6a      	ldr	r2, [pc, #424]	; (2ff4 <spi_nrfx_transceive+0x238>)
    2e4a:	4b6b      	ldr	r3, [pc, #428]	; (2ff8 <spi_nrfx_transceive+0x23c>)
    2e4c:	486d      	ldr	r0, [pc, #436]	; (3004 <spi_nrfx_transceive+0x248>)
    2e4e:	1a9b      	subs	r3, r3, r2
    2e50:	08db      	lsrs	r3, r3, #3
    2e52:	f363 118f 	bfi	r1, r3, #6, #10
    2e56:	e7ec      	b.n	2e32 <spi_nrfx_transceive+0x76>
	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
    2e58:	f3c3 1345 	ubfx	r3, r3, #5, #6
    2e5c:	2b08      	cmp	r3, #8
    2e5e:	d00c      	beq.n	2e7a <spi_nrfx_transceive+0xbe>
		LOG_ERR("Word sizes other than 8 bits"
    2e60:	2301      	movs	r3, #1
    2e62:	f04f 0100 	mov.w	r1, #0
    2e66:	f363 0107 	bfi	r1, r3, #0, #8
    2e6a:	4a62      	ldr	r2, [pc, #392]	; (2ff4 <spi_nrfx_transceive+0x238>)
    2e6c:	4b62      	ldr	r3, [pc, #392]	; (2ff8 <spi_nrfx_transceive+0x23c>)
    2e6e:	4866      	ldr	r0, [pc, #408]	; (3008 <spi_nrfx_transceive+0x24c>)
    2e70:	1a9b      	subs	r3, r3, r2
    2e72:	08db      	lsrs	r3, r3, #3
    2e74:	f363 118f 	bfi	r1, r3, #6, #10
    2e78:	e7db      	b.n	2e32 <spi_nrfx_transceive+0x76>
	if (spi_cfg->frequency < 125000) {
    2e7a:	f8d8 2000 	ldr.w	r2, [r8]
    2e7e:	4b63      	ldr	r3, [pc, #396]	; (300c <spi_nrfx_transceive+0x250>)
    2e80:	429a      	cmp	r2, r3
    2e82:	d80c      	bhi.n	2e9e <spi_nrfx_transceive+0xe2>
		LOG_ERR("Frequencies lower than 125 kHz are not supported");
    2e84:	2301      	movs	r3, #1
    2e86:	f04f 0100 	mov.w	r1, #0
    2e8a:	f363 0107 	bfi	r1, r3, #0, #8
    2e8e:	4a59      	ldr	r2, [pc, #356]	; (2ff4 <spi_nrfx_transceive+0x238>)
    2e90:	4b59      	ldr	r3, [pc, #356]	; (2ff8 <spi_nrfx_transceive+0x23c>)
    2e92:	485f      	ldr	r0, [pc, #380]	; (3010 <spi_nrfx_transceive+0x254>)
    2e94:	1a9b      	subs	r3, r3, r2
    2e96:	08db      	lsrs	r3, r3, #3
    2e98:	f363 118f 	bfi	r1, r3, #6, #10
    2e9c:	e7c9      	b.n	2e32 <spi_nrfx_transceive+0x76>
	if (ctx->config->cs && ctx->config->cs->gpio_dev) {
    2e9e:	f8d8 3008 	ldr.w	r3, [r8, #8]
	return dev->config->config_info;
    2ea2:	f8d0 9008 	ldr.w	r9, [r0, #8]
	ctx->config = spi_cfg;
    2ea6:	f8c4 8000 	str.w	r8, [r4]
    2eaa:	2b00      	cmp	r3, #0
    2eac:	d06f      	beq.n	2f8e <spi_nrfx_transceive+0x1d2>
    2eae:	6818      	ldr	r0, [r3, #0]
    2eb0:	2800      	cmp	r0, #0
    2eb2:	d06c      	beq.n	2f8e <spi_nrfx_transceive+0x1d2>
		gpio_pin_configure(ctx->config->cs->gpio_dev,
    2eb4:	685a      	ldr	r2, [r3, #4]
    2eb6:	6843      	ldr	r3, [r0, #4]
    2eb8:	f8d3 a000 	ldr.w	sl, [r3]
    2ebc:	2301      	movs	r3, #1
    2ebe:	47d0      	blx	sl
		gpio_pin_write(ctx->config->cs->gpio_dev,
    2ec0:	6822      	ldr	r2, [r4, #0]
    2ec2:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
    2ec4:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
		gpio_pin_write(ctx->config->cs->gpio_dev,
    2ec8:	43d2      	mvns	r2, r2
    2eca:	0fd2      	lsrs	r2, r2, #31
    2ecc:	e9d3 0100 	ldrd	r0, r1, [r3]
    2ed0:	f005 fc6a 	bl	87a8 <gpio_pin_write>
	nrf_spi_configure(spi->p_reg,
    2ed4:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    2ed8:	f8d9 1000 	ldr.w	r1, [r9]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
    2edc:	0798      	lsls	r0, r3, #30
    2ede:	f003 0204 	and.w	r2, r3, #4
    2ee2:	d563      	bpl.n	2fac <spi_nrfx_transceive+0x1f0>
			return NRF_SPI_MODE_2;
    2ee4:	2a00      	cmp	r2, #0
    2ee6:	bf14      	ite	ne
    2ee8:	2203      	movne	r2, #3
    2eea:	2202      	moveq	r2, #2
                                         nrf_spi_mode_t      spi_mode,
                                         nrf_spi_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPI_BIT_ORDER_MSB_FIRST ?
        SPI_CONFIG_ORDER_MsbFirst : SPI_CONFIG_ORDER_LsbFirst);
    switch (spi_mode)
    2eec:	2a02      	cmp	r2, #2
	if (operation & SPI_TRANSFER_LSB) {
    2eee:	f3c3 1300 	ubfx	r3, r3, #4, #1
    2ef2:	d05f      	beq.n	2fb4 <spi_nrfx_transceive+0x1f8>
    2ef4:	2a03      	cmp	r2, #3
    2ef6:	d060      	beq.n	2fba <spi_nrfx_transceive+0x1fe>
    2ef8:	2a01      	cmp	r2, #1
    2efa:	d101      	bne.n	2f00 <spi_nrfx_transceive+0x144>
        config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
                  (SPI_CONFIG_CPHA_Leading    << SPI_CONFIG_CPHA_Pos);
        break;

    case NRF_SPI_MODE_1:
        config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
    2efc:	f043 0302 	orr.w	r3, r3, #2
    case NRF_SPI_MODE_3:
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
                  (SPI_CONFIG_CPHA_Trailing   << SPI_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
    2f00:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
	if (frequency < 250000) {
    2f04:	4a43      	ldr	r2, [pc, #268]	; (3014 <spi_nrfx_transceive+0x258>)
	nrf_spi_frequency_set(spi->p_reg,
    2f06:	f8d8 3000 	ldr.w	r3, [r8]
	if (frequency < 250000) {
    2f0a:	4293      	cmp	r3, r2
    2f0c:	d958      	bls.n	2fc0 <spi_nrfx_transceive+0x204>
	} else if (frequency < 500000) {
    2f0e:	4a42      	ldr	r2, [pc, #264]	; (3018 <spi_nrfx_transceive+0x25c>)
    2f10:	4293      	cmp	r3, r2
    2f12:	d958      	bls.n	2fc6 <spi_nrfx_transceive+0x20a>
	} else if (frequency < 1000000) {
    2f14:	4a41      	ldr	r2, [pc, #260]	; (301c <spi_nrfx_transceive+0x260>)
    2f16:	4293      	cmp	r3, r2
    2f18:	d958      	bls.n	2fcc <spi_nrfx_transceive+0x210>
	} else if (frequency < 2000000) {
    2f1a:	4a41      	ldr	r2, [pc, #260]	; (3020 <spi_nrfx_transceive+0x264>)
    2f1c:	4293      	cmp	r3, r2
    2f1e:	d958      	bls.n	2fd2 <spi_nrfx_transceive+0x216>
	} else if (frequency < 4000000) {
    2f20:	4a40      	ldr	r2, [pc, #256]	; (3024 <spi_nrfx_transceive+0x268>)
    2f22:	4293      	cmp	r3, r2
    2f24:	d958      	bls.n	2fd8 <spi_nrfx_transceive+0x21c>
		return NRF_SPI_FREQ_8M;
    2f26:	f502 1274 	add.w	r2, r2, #3997696	; 0x3d0000
    2f2a:	f502 6210 	add.w	r2, r2, #2304	; 0x900
    2f2e:	4293      	cmp	r3, r2
    2f30:	bf94      	ite	ls
    2f32:	f04f 4380 	movls.w	r3, #1073741824	; 0x40000000
    2f36:	f04f 4300 	movhi.w	r3, #2147483648	; 0x80000000
    p_reg->FREQUENCY = (uint32_t)frequency;
    2f3a:	f8c1 3524 	str.w	r3, [r1, #1316]	; 0x524
		dev_data->busy = true;
    2f3e:	2301      	movs	r3, #1
    2f40:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
	if (tx_bufs) {
    2f44:	2e00      	cmp	r6, #0
    2f46:	d04a      	beq.n	2fde <spi_nrfx_transceive+0x222>
		ctx->current_tx = tx_bufs->buffers;
    2f48:	6833      	ldr	r3, [r6, #0]
		ctx->tx_count = tx_bufs->count;
    2f4a:	6872      	ldr	r2, [r6, #4]
		ctx->current_tx = tx_bufs->buffers;
    2f4c:	62a3      	str	r3, [r4, #40]	; 0x28
		ctx->tx_count = tx_bufs->count;
    2f4e:	62e2      	str	r2, [r4, #44]	; 0x2c
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    2f50:	681a      	ldr	r2, [r3, #0]
		ctx->tx_len = ctx->current_tx->len / dfs;
    2f52:	685b      	ldr	r3, [r3, #4]
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    2f54:	63a2      	str	r2, [r4, #56]	; 0x38
		ctx->tx_len = ctx->current_tx->len / dfs;
    2f56:	63e3      	str	r3, [r4, #60]	; 0x3c
	if (rx_bufs) {
    2f58:	2d00      	cmp	r5, #0
    2f5a:	d045      	beq.n	2fe8 <spi_nrfx_transceive+0x22c>
		ctx->current_rx = rx_bufs->buffers;
    2f5c:	682b      	ldr	r3, [r5, #0]
		ctx->rx_count = rx_bufs->count;
    2f5e:	686a      	ldr	r2, [r5, #4]
		ctx->current_rx = rx_bufs->buffers;
    2f60:	6323      	str	r3, [r4, #48]	; 0x30
		ctx->rx_count = rx_bufs->count;
    2f62:	6362      	str	r2, [r4, #52]	; 0x34
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    2f64:	681a      	ldr	r2, [r3, #0]
		ctx->rx_len = ctx->current_rx->len / dfs;
    2f66:	685b      	ldr	r3, [r3, #4]
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    2f68:	6422      	str	r2, [r4, #64]	; 0x40
		ctx->rx_len = ctx->current_rx->len / dfs;
    2f6a:	6463      	str	r3, [r4, #68]	; 0x44
	ctx->sync_status = 0;
    2f6c:	2200      	movs	r2, #0
    2f6e:	6262      	str	r2, [r4, #36]	; 0x24
	_spi_context_cs_control(ctx, on, false);
    2f70:	2101      	movs	r1, #1
    2f72:	4620      	mov	r0, r4
    2f74:	f005 fc21 	bl	87ba <_spi_context_cs_control.isra.7>
		transfer_next_chunk(dev);
    2f78:	4638      	mov	r0, r7
    2f7a:	f7ff fe7b 	bl	2c74 <transfer_next_chunk>
	return z_impl_k_sem_take(sem, timeout);
    2f7e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2f82:	f104 0014 	add.w	r0, r4, #20
    2f86:	f004 f989 	bl	729c <z_impl_k_sem_take>
	status = ctx->sync_status;
    2f8a:	6a65      	ldr	r5, [r4, #36]	; 0x24
	return status;
    2f8c:	e73d      	b.n	2e0a <spi_nrfx_transceive+0x4e>
		LOG_INF("CS control inhibited (no GPIO device)");
    2f8e:	2303      	movs	r3, #3
    2f90:	f04f 0100 	mov.w	r1, #0
    2f94:	f363 0107 	bfi	r1, r3, #0, #8
    2f98:	4a16      	ldr	r2, [pc, #88]	; (2ff4 <spi_nrfx_transceive+0x238>)
    2f9a:	4b17      	ldr	r3, [pc, #92]	; (2ff8 <spi_nrfx_transceive+0x23c>)
    2f9c:	4822      	ldr	r0, [pc, #136]	; (3028 <spi_nrfx_transceive+0x26c>)
    2f9e:	1a9b      	subs	r3, r3, r2
    2fa0:	08db      	lsrs	r3, r3, #3
    2fa2:	f363 118f 	bfi	r1, r3, #6, #10
    2fa6:	f004 fdd4 	bl	7b52 <log_0>
    2faa:	e793      	b.n	2ed4 <spi_nrfx_transceive+0x118>
			return NRF_SPI_MODE_0;
    2fac:	3200      	adds	r2, #0
    2fae:	bf18      	it	ne
    2fb0:	2201      	movne	r2, #1
    2fb2:	e79b      	b.n	2eec <spi_nrfx_transceive+0x130>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
    2fb4:	f043 0304 	orr.w	r3, r3, #4
        break;
    2fb8:	e7a2      	b.n	2f00 <spi_nrfx_transceive+0x144>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
    2fba:	f043 0306 	orr.w	r3, r3, #6
        break;
    2fbe:	e79f      	b.n	2f00 <spi_nrfx_transceive+0x144>
		return NRF_SPI_FREQ_125K;
    2fc0:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
    2fc4:	e7b9      	b.n	2f3a <spi_nrfx_transceive+0x17e>
		return NRF_SPI_FREQ_250K;
    2fc6:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    2fca:	e7b6      	b.n	2f3a <spi_nrfx_transceive+0x17e>
		return NRF_SPI_FREQ_500K;
    2fcc:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    2fd0:	e7b3      	b.n	2f3a <spi_nrfx_transceive+0x17e>
		return NRF_SPI_FREQ_1M;
    2fd2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    2fd6:	e7b0      	b.n	2f3a <spi_nrfx_transceive+0x17e>
		return NRF_SPI_FREQ_2M;
    2fd8:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
    2fdc:	e7ad      	b.n	2f3a <spi_nrfx_transceive+0x17e>
		ctx->tx_count = 0;
    2fde:	e9c4 660a 	strd	r6, r6, [r4, #40]	; 0x28
		ctx->tx_len = 0;
    2fe2:	e9c4 660e 	strd	r6, r6, [r4, #56]	; 0x38
    2fe6:	e7b7      	b.n	2f58 <spi_nrfx_transceive+0x19c>
		ctx->rx_count = 0;
    2fe8:	e9c4 550c 	strd	r5, r5, [r4, #48]	; 0x30
		ctx->rx_len = 0;
    2fec:	e9c4 5510 	strd	r5, r5, [r4, #64]	; 0x40
    2ff0:	e7bc      	b.n	2f6c <spi_nrfx_transceive+0x1b0>
    2ff2:	bf00      	nop
    2ff4:	0000b17c 	.word	0x0000b17c
    2ff8:	0000b1d4 	.word	0x0000b1d4
    2ffc:	0000bfbd 	.word	0x0000bfbd
    3000:	0000bfdf 	.word	0x0000bfdf
    3004:	0000bffe 	.word	0x0000bffe
    3008:	0000c021 	.word	0x0000c021
    300c:	0001e847 	.word	0x0001e847
    3010:	0000c050 	.word	0x0000c050
    3014:	0003d08f 	.word	0x0003d08f
    3018:	0007a11f 	.word	0x0007a11f
    301c:	000f423f 	.word	0x000f423f
    3020:	001e847f 	.word	0x001e847f
    3024:	003d08ff 	.word	0x003d08ff
    3028:	0000c081 	.word	0x0000c081

0000302c <cst816s_sample_fetch>:


LOG_MODULE_REGISTER(CST816S, CONFIG_SENSOR_LOG_LEVEL);

static int cst816s_sample_fetch(struct device *dev, enum sensor_channel chan)
{
    302c:	b570      	push	{r4, r5, r6, lr}
	struct cst816s_data *drv_data = dev->driver_data;
    302e:	6885      	ldr	r5, [r0, #8]
{
    3030:	b098      	sub	sp, #96	; 0x60
				 const void *write_buf, size_t num_write,
				 void *read_buf, size_t num_read)
{
	struct i2c_msg msg[2];

	msg[0].buf = (u8_t *)write_buf;
    3032:	f10d 0307 	add.w	r3, sp, #7
	/*
	 * since all accel data register addresses are consecutive,
	 * a burst read can be used to read all the samples
	 */
//	MY_REGISTER6=0x00;
	if (i2c_burst_read(drv_data->i2c, CST816S_I2C_ADDRESS,
    3036:	6828      	ldr	r0, [r5, #0]
    3038:	9302      	str	r3, [sp, #8]
	msg[0].len = num_write;
    303a:	2301      	movs	r3, #1
    303c:	9303      	str	r3, [sp, #12]
	msg[0].flags = I2C_MSG_WRITE;

	msg[1].buf = (u8_t *)read_buf;
    303e:	ab08      	add	r3, sp, #32
    3040:	9305      	str	r3, [sp, #20]
	msg[1].len = num_read;
    3042:	2340      	movs	r3, #64	; 0x40
    3044:	2400      	movs	r4, #0
    3046:	9306      	str	r3, [sp, #24]
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;
    3048:	2307      	movs	r3, #7
    304a:	f88d 4007 	strb.w	r4, [sp, #7]
	msg[0].flags = I2C_MSG_WRITE;
    304e:	f88d 4010 	strb.w	r4, [sp, #16]
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;
    3052:	f88d 301c 	strb.w	r3, [sp, #28]
	return api->transfer(dev, msgs, num_msgs, addr);
    3056:	6843      	ldr	r3, [r0, #4]
    3058:	2202      	movs	r2, #2
    305a:	685e      	ldr	r6, [r3, #4]
    305c:	a902      	add	r1, sp, #8
    305e:	2315      	movs	r3, #21
    3060:	47b0      	blx	r6
    3062:	42a0      	cmp	r0, r4
    3064:	da06      	bge.n	3074 <cst816s_sample_fetch+0x48>
				CST816S_REG_DATA, buf, 64) < 0) {
		LOG_DBG("Could not read data");
		MY_REGISTER2=0xEE;
    3066:	4b0d      	ldr	r3, [pc, #52]	; (309c <cst816s_sample_fetch+0x70>)
    3068:	22ee      	movs	r2, #238	; 0xee
    306a:	701a      	strb	r2, [r3, #0]
		return -EIO;
    306c:	f06f 0004 	mvn.w	r0, #4
        lsb = buf[6];
	drv_data->y_sample = (msb<<8)|lsb; // todo check if buf[5] is indeed Y


	return 0;
}
    3070:	b018      	add	sp, #96	; 0x60
    3072:	bd70      	pop	{r4, r5, r6, pc}
	msb = buf[3] & 0x0f;
    3074:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
	drv_data->x_sample = (msb<<8)|lsb; 
    3078:	f003 020f 	and.w	r2, r3, #15
    307c:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
    3080:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    3084:	80ab      	strh	r3, [r5, #4]
	msb = buf[5] & 0x0f;
    3086:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
	drv_data->y_sample = (msb<<8)|lsb; // todo check if buf[5] is indeed Y
    308a:	f003 020f 	and.w	r2, r3, #15
    308e:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    3092:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    3096:	80eb      	strh	r3, [r5, #6]
	return 0;
    3098:	4620      	mov	r0, r4
    309a:	e7e9      	b.n	3070 <cst816s_sample_fetch+0x44>
    309c:	2000f006 	.word	0x2000f006

000030a0 <cst816s_init>:




int cst816s_init(struct device *dev)
{
    30a0:	b510      	push	{r4, lr}
	struct cst816s_data *drv_data = dev->driver_data;
    30a2:	6884      	ldr	r4, [r0, #8]
    30a4:	4804      	ldr	r0, [pc, #16]	; (30b8 <cst816s_init+0x18>)
    30a6:	f003 fb2d 	bl	6704 <z_impl_device_get_binding>
	//u8_t id = 0U;
	drv_data->i2c = device_get_binding(CONFIG_CST816S_I2C_MASTER_DEV_NAME);
	if (drv_data->i2c == NULL) {
    30aa:	2800      	cmp	r0, #0
	drv_data->i2c = device_get_binding(CONFIG_CST816S_I2C_MASTER_DEV_NAME);
    30ac:	6020      	str	r0, [r4, #0]
	return -EIO;
}
#endif
//MY_REGISTER2=0x01;
return 0;
}
    30ae:	bf0c      	ite	eq
    30b0:	f06f 0015 	mvneq.w	r0, #21
    30b4:	2000      	movne	r0, #0
    30b6:	bd10      	pop	{r4, pc}
    30b8:	0000bf6c 	.word	0x0000bf6c

000030bc <errata_108>:
static bool errata_12(void)
{
    uint32_t var1;
    uint32_t var2;

    if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    30bc:	4b04      	ldr	r3, [pc, #16]	; (30d0 <errata_108+0x14>)
    30be:	6818      	ldr	r0, [r3, #0]
    30c0:	1c42      	adds	r2, r0, #1
    {
        var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    30c2:	bf04      	itt	eq
    30c4:	4b03      	ldreq	r3, [pc, #12]	; (30d4 <errata_108+0x18>)
    30c6:	7818      	ldrbeq	r0, [r3, #0]
        break;

    }

    return false;
}
    30c8:	1f83      	subs	r3, r0, #6
    30ca:	4258      	negs	r0, r3
    30cc:	4158      	adcs	r0, r3
    30ce:	4770      	bx	lr
    30d0:	10000130 	.word	0x10000130
    30d4:	f0000fe0 	.word	0xf0000fe0

000030d8 <errata_16>:
    return false;
}

static bool errata_16(void)
{
    uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    30d8:	4b07      	ldr	r3, [pc, #28]	; (30f8 <errata_16+0x20>)
    30da:	781b      	ldrb	r3, [r3, #0]
    uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;

    switch(var1)
    30dc:	2b06      	cmp	r3, #6
    30de:	d109      	bne.n	30f4 <errata_16+0x1c>
    uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    30e0:	4b06      	ldr	r3, [pc, #24]	; (30fc <errata_16+0x24>)
    30e2:	681b      	ldr	r3, [r3, #0]
    30e4:	f3c3 1303 	ubfx	r3, r3, #4, #4
    30e8:	3b03      	subs	r3, #3
    30ea:	2b03      	cmp	r3, #3
    30ec:	d802      	bhi.n	30f4 <errata_16+0x1c>
    30ee:	4a04      	ldr	r2, [pc, #16]	; (3100 <errata_16+0x28>)
    30f0:	5cd0      	ldrb	r0, [r2, r3]
    30f2:	4770      	bx	lr
            }
        break;

    }

    return false;
    30f4:	2000      	movs	r0, #0
}
    30f6:	4770      	bx	lr
    30f8:	f0000fe0 	.word	0xf0000fe0
    30fc:	f0000fe8 	.word	0xf0000fe8
    3100:	0000c0b4 	.word	0x0000c0b4

00003104 <SystemInit>:
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
}

void SystemInit(void)
{
    3104:	b508      	push	{r3, lr}
        NRF_P0->PIN_CNF[20] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
    #endif
    
    /* Workaround for Errata 12 "COMP: Reference ladder not correctly calibrated" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp */
    if (errata_12()){
    3106:	f7ff ffd9 	bl	30bc <errata_108>
    310a:	b128      	cbz	r0, 3118 <SystemInit+0x14>
        *(volatile uint32_t *)0x40013540 = (*(uint32_t *)0x10000324 & 0x00001F00) >> 8;
    310c:	4b7c      	ldr	r3, [pc, #496]	; (3300 <SystemInit+0x1fc>)
    310e:	4a7d      	ldr	r2, [pc, #500]	; (3304 <SystemInit+0x200>)
    3110:	681b      	ldr	r3, [r3, #0]
    3112:	f3c3 2304 	ubfx	r3, r3, #8, #5
    3116:	6013      	str	r3, [r2, #0]
    }
    
    /* Workaround for Errata 16 "System: RAM may be corrupt on wakeup from CPU IDLE" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp */
    if (errata_16()){
    3118:	f7ff ffde 	bl	30d8 <errata_16>
    311c:	b110      	cbz	r0, 3124 <SystemInit+0x20>
        *(volatile uint32_t *)0x4007C074 = 3131961357ul;
    311e:	4b7a      	ldr	r3, [pc, #488]	; (3308 <SystemInit+0x204>)
    3120:	4a7a      	ldr	r2, [pc, #488]	; (330c <SystemInit+0x208>)
    3122:	601a      	str	r2, [r3, #0]
    }

    /* Workaround for Errata 31 "CLOCK: Calibration values are not correctly loaded from FICR at reset" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp */
    if (errata_31()){
    3124:	f7ff ffca 	bl	30bc <errata_108>
    3128:	b128      	cbz	r0, 3136 <SystemInit+0x32>
        *(volatile uint32_t *)0x4000053C = ((*(volatile uint32_t *)0x10000244) & 0x0000E000) >> 13;
    312a:	4b79      	ldr	r3, [pc, #484]	; (3310 <SystemInit+0x20c>)
    312c:	4a79      	ldr	r2, [pc, #484]	; (3314 <SystemInit+0x210>)
    312e:	681b      	ldr	r3, [r3, #0]
    3130:	f3c3 3342 	ubfx	r3, r3, #13, #3
    3134:	6013      	str	r3, [r2, #0]
    }

    /* Workaround for Errata 32 "DIF: Debug session automatically enables TracePort pins" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp */
    if (errata_32()){
    3136:	f7ff ffcf 	bl	30d8 <errata_16>
    313a:	b120      	cbz	r0, 3146 <SystemInit+0x42>
        CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk;
    313c:	4a76      	ldr	r2, [pc, #472]	; (3318 <SystemInit+0x214>)
    313e:	68d3      	ldr	r3, [r2, #12]
    3140:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    3144:	60d3      	str	r3, [r2, #12]
    }

    /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_36()){
    3146:	f7ff ffb9 	bl	30bc <errata_108>
    314a:	b140      	cbz	r0, 315e <SystemInit+0x5a>
        NRF_CLOCK->EVENTS_DONE = 0;
    314c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3150:	2200      	movs	r2, #0
    3152:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
        NRF_CLOCK->EVENTS_CTTO = 0;
    3156:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
        NRF_CLOCK->CTIV = 0;
    315a:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    }

    /* Workaround for Errata 37 "RADIO: Encryption engine is slow by default" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_37()){
    315e:	f7ff ffbb 	bl	30d8 <errata_16>
    3162:	b110      	cbz	r0, 316a <SystemInit+0x66>
        *(volatile uint32_t *)0x400005A0 = 0x3;
    3164:	4b6d      	ldr	r3, [pc, #436]	; (331c <SystemInit+0x218>)
    3166:	2203      	movs	r2, #3
    3168:	601a      	str	r2, [r3, #0]
    }

    /* Workaround for Errata 57 "NFCT: NFC Modulation amplitude" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_57()){
    316a:	f7ff ffb5 	bl	30d8 <errata_16>
    316e:	b140      	cbz	r0, 3182 <SystemInit+0x7e>
        *(volatile uint32_t *)0x40005610 = 0x00000005;
    3170:	4b6b      	ldr	r3, [pc, #428]	; (3320 <SystemInit+0x21c>)
    3172:	2205      	movs	r2, #5
    3174:	601a      	str	r2, [r3, #0]
        *(volatile uint32_t *)0x40005688 = 0x00000001;
    3176:	2201      	movs	r2, #1
    3178:	679a      	str	r2, [r3, #120]	; 0x78
        *(volatile uint32_t *)0x40005618 = 0x00000000;
    317a:	2200      	movs	r2, #0
    317c:	609a      	str	r2, [r3, #8]
        *(volatile uint32_t *)0x40005614 = 0x0000003F;
    317e:	223f      	movs	r2, #63	; 0x3f
    3180:	605a      	str	r2, [r3, #4]
static bool errata_66(void)
{
    uint32_t var1;
    uint32_t var2;

    if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    3182:	4b68      	ldr	r3, [pc, #416]	; (3324 <SystemInit+0x220>)
    3184:	681a      	ldr	r2, [r3, #0]
    3186:	1c51      	adds	r1, r2, #1
    {
        var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    3188:	bf0b      	itete	eq
    318a:	4b67      	ldreq	r3, [pc, #412]	; (3328 <SystemInit+0x224>)
        var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    }
    else
    {
        var1 = *(uint32_t *)0x10000130ul;
        var2 = *(uint32_t *)0x10000134ul;
    318c:	4b67      	ldrne	r3, [pc, #412]	; (332c <SystemInit+0x228>)
        var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    318e:	781a      	ldrbeq	r2, [r3, #0]
        var2 = *(uint32_t *)0x10000134ul;
    3190:	681b      	ldrne	r3, [r3, #0]
        var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    3192:	bf02      	ittt	eq
    3194:	3308      	addeq	r3, #8
    3196:	681b      	ldreq	r3, [r3, #0]
    3198:	f3c3 1303 	ubfxeq	r3, r3, #4, #4
    }

    switch(var1)
    319c:	2a06      	cmp	r2, #6
    319e:	d14d      	bne.n	323c <SystemInit+0x138>
    {
        case 0x06:
            switch(var2)
    31a0:	3b03      	subs	r3, #3
    31a2:	2b03      	cmp	r3, #3
    31a4:	d803      	bhi.n	31ae <SystemInit+0xaa>
    }

    /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_66()){
    31a6:	4a62      	ldr	r2, [pc, #392]	; (3330 <SystemInit+0x22c>)
    31a8:	5cd3      	ldrb	r3, [r2, r3]
    31aa:	2b00      	cmp	r3, #0
    31ac:	d046      	beq.n	323c <SystemInit+0x138>
        NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
    31ae:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    31b2:	4b60      	ldr	r3, [pc, #384]	; (3334 <SystemInit+0x230>)
    31b4:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
    31b8:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
        NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
    31bc:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
    31c0:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
        NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
    31c4:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
    31c8:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
        NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
    31cc:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
    31d0:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
        NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
    31d4:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
    31d8:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
        NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
    31dc:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
    31e0:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
        NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
    31e4:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
    31e8:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
        NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
    31ec:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
    31f0:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
        NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
    31f4:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
    31f8:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
        NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
    31fc:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
    3200:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
        NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
    3204:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
    3208:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
        NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
    320c:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
    3210:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
        NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
    3214:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
    3218:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
        NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
    321c:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
    3220:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
        NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
    3224:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
    3228:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
        NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
    322c:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
    3230:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
        NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
    3234:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
    3238:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    }

    /* Workaround for Errata 108 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_108()){
    323c:	f7ff ff3e 	bl	30bc <errata_108>
    3240:	b128      	cbz	r0, 324e <SystemInit+0x14a>
        *(volatile uint32_t *)0x40000EE4ul = *(volatile uint32_t *)0x10000258ul & 0x0000004Ful;
    3242:	4b3d      	ldr	r3, [pc, #244]	; (3338 <SystemInit+0x234>)
    3244:	4a3d      	ldr	r2, [pc, #244]	; (333c <SystemInit+0x238>)
    3246:	681b      	ldr	r3, [r3, #0]
    3248:	f003 034f 	and.w	r3, r3, #79	; 0x4f
    324c:	6013      	str	r3, [r2, #0]
    }
    
    /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_136()){
    324e:	f7ff ff35 	bl	30bc <errata_108>
    3252:	b148      	cbz	r0, 3268 <SystemInit+0x164>
        if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
    3254:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3258:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    325c:	07d2      	lsls	r2, r2, #31
            NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
    325e:	bf44      	itt	mi
    3260:	f06f 0201 	mvnmi.w	r2, #1
    3264:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400
    return false;
}

static bool errata_182(void)
{
    uint32_t var1 = *(uint32_t *)0x10000130ul;
    3268:	4b2e      	ldr	r3, [pc, #184]	; (3324 <SystemInit+0x220>)
    uint32_t var2 = *(uint32_t *)0x10000134ul;

    switch(var1)
    326a:	681b      	ldr	r3, [r3, #0]
    326c:	2b06      	cmp	r3, #6
    326e:	d109      	bne.n	3284 <SystemInit+0x180>
    uint32_t var2 = *(uint32_t *)0x10000134ul;
    3270:	4b2e      	ldr	r3, [pc, #184]	; (332c <SystemInit+0x228>)
    {
        case 0x06:
            switch(var2)
    3272:	681b      	ldr	r3, [r3, #0]
    3274:	3b03      	subs	r3, #3
    3276:	2b02      	cmp	r3, #2
    }
    
    /* Workaround for Errata 182 "RADIO: Fixes for anomalies #102, #106, and #107 do not take effect" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_182()){
        *(volatile uint32_t *) 0x4000173C |= (0x1 << 10);
    3278:	bf81      	itttt	hi
    327a:	4a31      	ldrhi	r2, [pc, #196]	; (3340 <SystemInit+0x23c>)
    327c:	6813      	ldrhi	r3, [r2, #0]
    327e:	f443 6380 	orrhi.w	r3, r3, #1024	; 0x400
    3282:	6013      	strhi	r3, [r2, #0]

    /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
      defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
      reserved for PinReset and not available as normal GPIO. */
    #if defined (CONFIG_GPIO_AS_PINRESET)
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    3284:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    3288:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    328c:	2a00      	cmp	r2, #0
    328e:	db03      	blt.n	3298 <SystemInit+0x194>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
    3290:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    3294:	2b00      	cmp	r3, #0
    3296:	da2f      	bge.n	32f8 <SystemInit+0x1f4>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
    3298:	4b2a      	ldr	r3, [pc, #168]	; (3344 <SystemInit+0x240>)
    329a:	2201      	movs	r2, #1
    329c:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    32a0:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    32a4:	2a00      	cmp	r2, #0
    32a6:	d0fb      	beq.n	32a0 <SystemInit+0x19c>
            NRF_UICR->PSELRESET[0] = 21;
    32a8:	f04f 2210 	mov.w	r2, #268439552	; 0x10001000
    32ac:	2115      	movs	r1, #21
    32ae:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    32b2:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    32b6:	2a00      	cmp	r2, #0
    32b8:	d0fb      	beq.n	32b2 <SystemInit+0x1ae>
            NRF_UICR->PSELRESET[1] = 21;
    32ba:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    32be:	2215      	movs	r2, #21
    32c0:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    32c4:	4b1f      	ldr	r3, [pc, #124]	; (3344 <SystemInit+0x240>)
    32c6:	461a      	mov	r2, r3
    32c8:	f8d3 1400 	ldr.w	r1, [r3, #1024]	; 0x400
    32cc:	2900      	cmp	r1, #0
    32ce:	d0fb      	beq.n	32c8 <SystemInit+0x1c4>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
    32d0:	2100      	movs	r1, #0
    32d2:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    32d6:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
    32da:	2b00      	cmp	r3, #0
    32dc:	d0fb      	beq.n	32d6 <SystemInit+0x1d2>
  __ASM volatile ("dsb 0xF":::"memory");
    32de:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    32e2:	4919      	ldr	r1, [pc, #100]	; (3348 <SystemInit+0x244>)
    32e4:	4b19      	ldr	r3, [pc, #100]	; (334c <SystemInit+0x248>)
    32e6:	68ca      	ldr	r2, [r1, #12]
    32e8:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    32ec:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    32ee:	60cb      	str	r3, [r1, #12]
    32f0:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    32f4:	bf00      	nop
    32f6:	e7fd      	b.n	32f4 <SystemInit+0x1f0>
    SystemCoreClock = __SYSTEM_CLOCK_64M;
    32f8:	4b15      	ldr	r3, [pc, #84]	; (3350 <SystemInit+0x24c>)
    32fa:	4a16      	ldr	r2, [pc, #88]	; (3354 <SystemInit+0x250>)
    32fc:	601a      	str	r2, [r3, #0]
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
}
    32fe:	bd08      	pop	{r3, pc}
    3300:	10000324 	.word	0x10000324
    3304:	40013540 	.word	0x40013540
    3308:	4007c074 	.word	0x4007c074
    330c:	baadf00d 	.word	0xbaadf00d
    3310:	10000244 	.word	0x10000244
    3314:	4000053c 	.word	0x4000053c
    3318:	e000edf0 	.word	0xe000edf0
    331c:	400005a0 	.word	0x400005a0
    3320:	40005610 	.word	0x40005610
    3324:	10000130 	.word	0x10000130
    3328:	f0000fe0 	.word	0xf0000fe0
    332c:	10000134 	.word	0x10000134
    3330:	0000c0b8 	.word	0x0000c0b8
    3334:	4000c000 	.word	0x4000c000
    3338:	10000258 	.word	0x10000258
    333c:	40000ee4 	.word	0x40000ee4
    3340:	4000173c 	.word	0x4000173c
    3344:	4001e000 	.word	0x4001e000
    3348:	e000ed00 	.word	0xe000ed00
    334c:	05fa0004 	.word	0x05fa0004
    3350:	200068b4 	.word	0x200068b4
    3354:	03d09000 	.word	0x03d09000

00003358 <nrfx_spi_init>:

nrfx_err_t nrfx_spi_init(nrfx_spi_t const *        p_instance,
                         nrfx_spi_config_t const * p_config,
                         nrfx_spi_evt_handler_t    handler,
                         void *                    p_context)
{
    3358:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    NRFX_ASSERT(p_config);
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    335c:	7904      	ldrb	r4, [r0, #4]
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
    335e:	4d4e      	ldr	r5, [pc, #312]	; (3498 <nrfx_spi_init+0x140>)
    3360:	262c      	movs	r6, #44	; 0x2c
    3362:	4366      	muls	r6, r4
    3364:	19af      	adds	r7, r5, r6
    3366:	f897 c01c 	ldrb.w	ip, [r7, #28]
    336a:	f1bc 0f00 	cmp.w	ip, #0
    336e:	f040 8091 	bne.w	3494 <nrfx_spi_init+0x13c>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler = handler;
    3372:	51aa      	str	r2, [r5, r6]
    p_cb->p_context = p_context;
    3374:	607b      	str	r3, [r7, #4]
    // Configure pins used by the peripheral:
    // - SCK - output with initial value corresponding with the SPI mode used:
    //   0 - for modes 0 and 1 (CPOL = 0), 1 - for modes 2 and 3 (CPOL = 1);
    //   according to the reference manual guidelines this pin and its input
    //   buffer must always be connected for the SPI to work.
    if (p_config->mode <= NRF_SPI_MODE_1)
    3376:	f891 e000 	ldrb.w	lr, [r1]
    337a:	7b0f      	ldrb	r7, [r1, #12]
    337c:	f04f 46a0 	mov.w	r6, #1342177280	; 0x50000000
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
    3380:	2301      	movs	r3, #1
    3382:	fa03 f30e 	lsl.w	r3, r3, lr
    3386:	2f01      	cmp	r7, #1
    3388:	bf94      	ite	ls
    338a:	f8c6 350c 	strls.w	r3, [r6, #1292]	; 0x50c
    p_reg->OUTSET = set_mask;
    338e:	f8c6 3508 	strhi.w	r3, [r6, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    3392:	f50e 73e0 	add.w	r3, lr, #448	; 0x1c0
    3396:	f04f 0c01 	mov.w	ip, #1
    339a:	f846 c023 	str.w	ip, [r6, r3, lsl #2]
                 NRF_GPIO_PIN_INPUT_CONNECT,
                 NRF_GPIO_PIN_NOPULL,
                 NRF_GPIO_PIN_S0S1,
                 NRF_GPIO_PIN_NOSENSE);
    // - MOSI (optional) - output with initial value 0,
    if (p_config->mosi_pin != NRFX_SPI_PIN_NOT_USED)
    339e:	784b      	ldrb	r3, [r1, #1]
    33a0:	2bff      	cmp	r3, #255	; 0xff
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
    33a2:	bf1f      	itttt	ne
    33a4:	fa0c fc03 	lslne.w	ip, ip, r3
    p_reg->OUTCLR = clr_mask;
    33a8:	f8c6 c50c 	strne.w	ip, [r6, #1292]	; 0x50c
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    33ac:	f503 7ce0 	addne.w	ip, r3, #448	; 0x1c0
    33b0:	f04f 0803 	movne.w	r8, #3
    33b4:	bf18      	it	ne
    33b6:	f846 802c 	strne.w	r8, [r6, ip, lsl #2]
    else
    {
        mosi_pin = NRF_SPI_PIN_NOT_CONNECTED;
    }
    // - MISO (optional) - input,
    if (p_config->miso_pin != NRFX_SPI_PIN_NOT_USED)
    33ba:	788e      	ldrb	r6, [r1, #2]
        mosi_pin = NRF_SPI_PIN_NOT_CONNECTED;
    33bc:	bf08      	it	eq
    33be:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
    if (p_config->miso_pin != NRFX_SPI_PIN_NOT_USED)
    33c2:	2eff      	cmp	r6, #255	; 0xff
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
    33c4:	bf1f      	itttt	ne
    33c6:	f891 900e 	ldrbne.w	r9, [r1, #14]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    33ca:	f506 7ce0 	addne.w	ip, r6, #448	; 0x1c0
    33ce:	f04f 4aa0 	movne.w	sl, #1342177280	; 0x50000000
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
    33d2:	ea4f 0989 	movne.w	r9, r9, lsl #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    33d6:	bf18      	it	ne
    33d8:	f84a 902c 	strne.w	r9, [sl, ip, lsl #2]
    }
    else
    {
        miso_pin = NRF_SPI_PIN_NOT_CONNECTED;
    }
    m_cb[p_instance->drv_inst_idx].miso_pin = p_config->miso_pin;
    33dc:	f04f 0c2c 	mov.w	ip, #44	; 0x2c
    33e0:	fb0c 5c04 	mla	ip, ip, r4, r5
        miso_pin = p_config->miso_pin;
    33e4:	bf18      	it	ne
    33e6:	46b0      	movne	r8, r6
    m_cb[p_instance->drv_inst_idx].miso_pin = p_config->miso_pin;
    33e8:	f88c 601f 	strb.w	r6, [ip, #31]
    // - Slave Select (optional) - output with initial value 1 (inactive).
    if (p_config->ss_pin != NRFX_SPI_PIN_NOT_USED)
    33ec:	78ce      	ldrb	r6, [r1, #3]
        miso_pin = NRF_SPI_PIN_NOT_CONNECTED;
    33ee:	bf08      	it	eq
    33f0:	f04f 38ff 	moveq.w	r8, #4294967295	; 0xffffffff
    if (p_config->ss_pin != NRFX_SPI_PIN_NOT_USED)
    33f4:	2eff      	cmp	r6, #255	; 0xff
    33f6:	d00d      	beq.n	3414 <nrfx_spi_init+0xbc>
    p_reg->OUTSET = set_mask;
    33f8:	f04f 49a0 	mov.w	r9, #1342177280	; 0x50000000
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    33fc:	f04f 0c01 	mov.w	ip, #1
    3400:	fa0c fc06 	lsl.w	ip, ip, r6
    p_reg->OUTSET = set_mask;
    3404:	f8c9 c508 	str.w	ip, [r9, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    3408:	f506 7ce0 	add.w	ip, r6, #448	; 0x1c0
    340c:	f04f 0a03 	mov.w	sl, #3
    3410:	f849 a02c 	str.w	sl, [r9, ip, lsl #2]
    {
        nrf_gpio_pin_set(p_config->ss_pin);
        nrf_gpio_cfg_output(p_config->ss_pin);
    }
    m_cb[p_instance->drv_inst_idx].ss_pin = p_config->ss_pin;
    3414:	f04f 0c2c 	mov.w	ip, #44	; 0x2c
    3418:	fb0c 5c04 	mla	ip, ip, r4, r5
    341c:	f88c 601e 	strb.w	r6, [ip, #30]

    NRF_SPI_Type * p_spi = p_instance->p_reg;
    3420:	6800      	ldr	r0, [r0, #0]
    p_reg->PSELSCK  = sck_pin;
    3422:	f8c0 e508 	str.w	lr, [r0, #1288]	; 0x508
    p_reg->PSELMOSI = mosi_pin;
    3426:	f8c0 350c 	str.w	r3, [r0, #1292]	; 0x50c
    p_reg->FREQUENCY = (uint32_t)frequency;
    342a:	688b      	ldr	r3, [r1, #8]
    p_reg->PSELMISO = miso_pin;
    342c:	f8c0 8510 	str.w	r8, [r0, #1296]	; 0x510
    p_reg->FREQUENCY = (uint32_t)frequency;
    3430:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524
        SPI_CONFIG_ORDER_MsbFirst : SPI_CONFIG_ORDER_LsbFirst);
    3434:	7b4b      	ldrb	r3, [r1, #13]
    3436:	3300      	adds	r3, #0
    3438:	bf18      	it	ne
    343a:	2301      	movne	r3, #1
    switch (spi_mode)
    343c:	2f02      	cmp	r7, #2
    343e:	d023      	beq.n	3488 <nrfx_spi_init+0x130>
    3440:	2f03      	cmp	r7, #3
    3442:	d024      	beq.n	348e <nrfx_spi_init+0x136>
    3444:	2f01      	cmp	r7, #1
    3446:	d101      	bne.n	344c <nrfx_spi_init+0xf4>
        config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
    3448:	f043 0302 	orr.w	r3, r3, #2
    p_reg->CONFIG = config;
    344c:	f8c0 3554 	str.w	r3, [r0, #1364]	; 0x554
    nrf_spi_pins_set(p_spi, p_config->sck_pin, mosi_pin, miso_pin);
    nrf_spi_frequency_set(p_spi, p_config->frequency);
    nrf_spi_configure(p_spi, p_config->mode, p_config->bit_order);

    m_cb[p_instance->drv_inst_idx].orc = p_config->orc;
    3450:	232c      	movs	r3, #44	; 0x2c
    3452:	fb03 5304 	mla	r3, r3, r4, r5
    3456:	7949      	ldrb	r1, [r1, #5]
    3458:	f883 1020 	strb.w	r1, [r3, #32]

    if (p_cb->handler)
    345c:	b112      	cbz	r2, 3464 <nrfx_spi_init+0x10c>
    p_reg->INTENSET = mask;
    345e:	2304      	movs	r3, #4
    3460:	f8c0 3304 	str.w	r3, [r0, #772]	; 0x304
    p_reg->ENABLE = (SPI_ENABLE_ENABLE_Enabled << SPI_ENABLE_ENABLE_Pos);
    3464:	2301      	movs	r3, #1
    3466:	f8c0 3500 	str.w	r3, [r0, #1280]	; 0x500
        nrf_spi_int_enable(p_spi, NRF_SPI_INT_READY_MASK);
    }

    nrf_spi_enable(p_spi);

    if (p_cb->handler)
    346a:	b11a      	cbz	r2, 3474 <nrfx_spi_init+0x11c>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_reg),
            p_config->irq_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
    346c:	f340 3007 	sbfx	r0, r0, #12, #8
    3470:	f7fd fe9c 	bl	11ac <arch_irq_enable>
    }

    p_cb->transfer_in_progress = false;
    3474:	232c      	movs	r3, #44	; 0x2c
    3476:	fb03 5404 	mla	r4, r3, r4, r5
    347a:	2300      	movs	r3, #0
    347c:	7763      	strb	r3, [r4, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
    347e:	4807      	ldr	r0, [pc, #28]	; (349c <nrfx_spi_init+0x144>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    3480:	2301      	movs	r3, #1
    3482:	7723      	strb	r3, [r4, #28]
}
    3484:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
    3488:	f043 0304 	orr.w	r3, r3, #4
        break;
    348c:	e7de      	b.n	344c <nrfx_spi_init+0xf4>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
    348e:	f043 0306 	orr.w	r3, r3, #6
        break;
    3492:	e7db      	b.n	344c <nrfx_spi_init+0xf4>
        return err_code;
    3494:	4802      	ldr	r0, [pc, #8]	; (34a0 <nrfx_spi_init+0x148>)
    3496:	e7f5      	b.n	3484 <nrfx_spi_init+0x12c>
    3498:	20000990 	.word	0x20000990
    349c:	0bad0000 	.word	0x0bad0000
    34a0:	0bad0005 	.word	0x0bad0005

000034a4 <nrfx_spi_xfer>:
}

nrfx_err_t nrfx_spi_xfer(nrfx_spi_t const *           p_instance,
                         nrfx_spi_xfer_desc_t const * p_xfer_desc,
                         uint32_t                     flags)
{
    34a4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    34a8:	7906      	ldrb	r6, [r0, #4]
    NRFX_ASSERT(p_xfer_desc->p_tx_buffer != NULL || p_xfer_desc->tx_length == 0);
    NRFX_ASSERT(p_xfer_desc->p_rx_buffer != NULL || p_xfer_desc->rx_length == 0);

    nrfx_err_t err_code = NRFX_SUCCESS;

    if (p_cb->transfer_in_progress)
    34aa:	4d42      	ldr	r5, [pc, #264]	; (35b4 <nrfx_spi_xfer+0x110>)
    34ac:	232c      	movs	r3, #44	; 0x2c
    34ae:	4373      	muls	r3, r6
{
    34b0:	4696      	mov	lr, r2
    if (p_cb->transfer_in_progress)
    34b2:	18ea      	adds	r2, r5, r3
{
    34b4:	460f      	mov	r7, r1
    if (p_cb->transfer_in_progress)
    34b6:	7f51      	ldrb	r1, [r2, #29]
{
    34b8:	4681      	mov	r9, r0
    if (p_cb->transfer_in_progress)
    34ba:	2900      	cmp	r1, #0
    34bc:	d178      	bne.n	35b0 <nrfx_spi_xfer+0x10c>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    else
    {
        if (p_cb->handler)
    34be:	f855 c003 	ldr.w	ip, [r5, r3]
    34c2:	f1bc 0f00 	cmp.w	ip, #0
    34c6:	d001      	beq.n	34cc <nrfx_spi_xfer+0x28>
        {
            p_cb->transfer_in_progress = true;
    34c8:	2301      	movs	r3, #1
    34ca:	7753      	strb	r3, [r2, #29]
        }
    }

    p_cb->evt.xfer_desc = *p_xfer_desc;
    34cc:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
    34d0:	242c      	movs	r4, #44	; 0x2c
    34d2:	fb04 5406 	mla	r4, r4, r6, r5
    34d6:	f104 080c 	add.w	r8, r4, #12
    34da:	e888 000f 	stmia.w	r8, {r0, r1, r2, r3}
    p_cb->abort = false;

    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    34de:	7fa2      	ldrb	r2, [r4, #30]
    p_cb->abort = false;
    34e0:	2300      	movs	r3, #0
    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    34e2:	2aff      	cmp	r2, #255	; 0xff
    p_cb->abort = false;
    34e4:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
    34e8:	bf1f      	itttt	ne
    34ea:	2301      	movne	r3, #1
    34ec:	4093      	lslne	r3, r2
    p_reg->OUTCLR = clr_mask;
    34ee:	f04f 42a0 	movne.w	r2, #1342177280	; 0x50000000
    34f2:	f8c2 350c 	strne.w	r3, [r2, #1292]	; 0x50c
    {
        nrf_gpio_pin_clear(p_cb->ss_pin);
    }
    if (flags)
    34f6:	232c      	movs	r3, #44	; 0x2c
    34f8:	f1be 0f00 	cmp.w	lr, #0
    34fc:	d007      	beq.n	350e <nrfx_spi_xfer+0x6a>
    {
        p_cb->transfer_in_progress = false;
    34fe:	fb03 5306 	mla	r3, r3, r6, r5
    3502:	2200      	movs	r2, #0
        err_code = NRFX_ERROR_NOT_SUPPORTED;
    3504:	482c      	ldr	r0, [pc, #176]	; (35b8 <nrfx_spi_xfer+0x114>)
        p_cb->transfer_in_progress = false;
    3506:	775a      	strb	r2, [r3, #29]
    }
    NRFX_LOG_INFO("Function: %s, error code: %s.",
                  __func__,
                  NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    3508:	b003      	add	sp, #12
    350a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        spi_xfer(p_instance->p_reg, p_cb, p_xfer_desc);
    350e:	f8d9 4000 	ldr.w	r4, [r9]
    p_reg->INTENCLR = mask;
    3512:	2204      	movs	r2, #4
    3514:	f8c4 2308 	str.w	r2, [r4, #776]	; 0x308
    p_cb->bytes_transferred = 0;
    3518:	fb03 5306 	mla	r3, r3, r6, r5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    351c:	f8c4 e108 	str.w	lr, [r4, #264]	; 0x108
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    3520:	f8d4 2108 	ldr.w	r2, [r4, #264]	; 0x108
    3524:	f8c3 e024 	str.w	lr, [r3, #36]	; 0x24
    3528:	9200      	str	r2, [sp, #0]
    (void)dummy;
    352a:	9a00      	ldr	r2, [sp, #0]
        (p_xfer_desc->tx_length > 0 ? p_xfer_desc->p_tx_buffer[0] : p_cb->orc));
    352c:	687a      	ldr	r2, [r7, #4]
    nrf_spi_txd_set(p_spi,
    352e:	b18a      	cbz	r2, 3554 <nrfx_spi_xfer+0xb0>
    3530:	683b      	ldr	r3, [r7, #0]
    3532:	781b      	ldrb	r3, [r3, #0]
    p_reg->TXD = data;
    3534:	f8c4 351c 	str.w	r3, [r4, #1308]	; 0x51c
    if (p_xfer_desc->tx_length > 1)
    3538:	2a01      	cmp	r2, #1
    353a:	d90e      	bls.n	355a <nrfx_spi_xfer+0xb6>
        nrf_spi_txd_set(p_spi, p_xfer_desc->p_tx_buffer[1]);
    353c:	683b      	ldr	r3, [r7, #0]
    353e:	785b      	ldrb	r3, [r3, #1]
    3540:	f8c4 351c 	str.w	r3, [r4, #1308]	; 0x51c
    if (p_cb->handler)
    3544:	f1bc 0f00 	cmp.w	ip, #0
    3548:	d010      	beq.n	356c <nrfx_spi_xfer+0xc8>
    p_reg->INTENSET = mask;
    354a:	2304      	movs	r3, #4
    354c:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
    nrfx_err_t err_code = NRFX_SUCCESS;
    3550:	481a      	ldr	r0, [pc, #104]	; (35bc <nrfx_spi_xfer+0x118>)
    3552:	e7d9      	b.n	3508 <nrfx_spi_xfer+0x64>
    nrf_spi_txd_set(p_spi,
    3554:	f893 3020 	ldrb.w	r3, [r3, #32]
    3558:	e7ec      	b.n	3534 <nrfx_spi_xfer+0x90>
    else if (p_xfer_desc->rx_length > 1)
    355a:	68fb      	ldr	r3, [r7, #12]
    355c:	2b01      	cmp	r3, #1
    355e:	d9f1      	bls.n	3544 <nrfx_spi_xfer+0xa0>
        nrf_spi_txd_set(p_spi, p_cb->orc);
    3560:	232c      	movs	r3, #44	; 0x2c
    3562:	fb03 5306 	mla	r3, r3, r6, r5
    p_reg->TXD = data;
    3566:	f893 3020 	ldrb.w	r3, [r3, #32]
    356a:	e7e9      	b.n	3540 <nrfx_spi_xfer+0x9c>
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    356c:	f04f 082c 	mov.w	r8, #44	; 0x2c
    3570:	fb06 5808 	mla	r8, r6, r8, r5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    3574:	4667      	mov	r7, ip
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    3576:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
            while (!nrf_spi_event_check(p_spi, NRF_SPI_EVENT_READY)) {}
    357a:	2b00      	cmp	r3, #0
    357c:	d0fb      	beq.n	3576 <nrfx_spi_xfer+0xd2>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    357e:	f8c4 7108 	str.w	r7, [r4, #264]	; 0x108
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    3582:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
    3586:	9301      	str	r3, [sp, #4]
        } while (transfer_byte(p_spi, p_cb));
    3588:	4641      	mov	r1, r8
    358a:	4620      	mov	r0, r4
    (void)dummy;
    358c:	9b01      	ldr	r3, [sp, #4]
    358e:	f005 f968 	bl	8862 <transfer_byte>
    3592:	2800      	cmp	r0, #0
    3594:	d1ef      	bne.n	3576 <nrfx_spi_xfer+0xd2>
        if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    3596:	232c      	movs	r3, #44	; 0x2c
    3598:	fb03 5506 	mla	r5, r3, r6, r5
    359c:	7faa      	ldrb	r2, [r5, #30]
    359e:	2aff      	cmp	r2, #255	; 0xff
    35a0:	d0d6      	beq.n	3550 <nrfx_spi_xfer+0xac>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    35a2:	2301      	movs	r3, #1
    35a4:	4093      	lsls	r3, r2
    p_reg->OUTSET = set_mask;
    35a6:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    35aa:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    35ae:	e7cf      	b.n	3550 <nrfx_spi_xfer+0xac>
        return err_code;
    35b0:	4803      	ldr	r0, [pc, #12]	; (35c0 <nrfx_spi_xfer+0x11c>)
    35b2:	e7a9      	b.n	3508 <nrfx_spi_xfer+0x64>
    35b4:	20000990 	.word	0x20000990
    35b8:	0bad0003 	.word	0x0bad0003
    35bc:	0bad0000 	.word	0x0bad0000
    35c0:	0bad000b 	.word	0x0bad000b

000035c4 <nrfx_spi_0_irq_handler>:
    }
}

#if NRFX_CHECK(NRFX_SPI0_ENABLED)
void nrfx_spi_0_irq_handler(void)
{
    35c4:	b513      	push	{r0, r1, r4, lr}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    35c6:	4b10      	ldr	r3, [pc, #64]	; (3608 <nrfx_spi_0_irq_handler+0x44>)
    if (!transfer_byte(p_spi, p_cb))
    35c8:	4c10      	ldr	r4, [pc, #64]	; (360c <nrfx_spi_0_irq_handler+0x48>)
    35ca:	4811      	ldr	r0, [pc, #68]	; (3610 <nrfx_spi_0_irq_handler+0x4c>)
    35cc:	2200      	movs	r2, #0
    35ce:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    35d0:	681b      	ldr	r3, [r3, #0]
    35d2:	9301      	str	r3, [sp, #4]
    35d4:	4621      	mov	r1, r4
    (void)dummy;
    35d6:	9b01      	ldr	r3, [sp, #4]
    35d8:	f005 f943 	bl	8862 <transfer_byte>
    35dc:	b990      	cbnz	r0, 3604 <nrfx_spi_0_irq_handler+0x40>
    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    35de:	7fa2      	ldrb	r2, [r4, #30]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
    35e0:	480c      	ldr	r0, [pc, #48]	; (3614 <nrfx_spi_0_irq_handler+0x50>)
    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    35e2:	2aff      	cmp	r2, #255	; 0xff
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    35e4:	bf1f      	itttt	ne
    35e6:	2301      	movne	r3, #1
    35e8:	4093      	lslne	r3, r2
    p_reg->OUTSET = set_mask;
    35ea:	f04f 42a0 	movne.w	r2, #1342177280	; 0x50000000
    35ee:	f8c2 3508 	strne.w	r3, [r2, #1288]	; 0x508
    p_cb->transfer_in_progress = false;
    35f2:	2300      	movs	r3, #0
    35f4:	7763      	strb	r3, [r4, #29]
    p_cb->evt.type = NRFX_SPI_EVENT_DONE;
    35f6:	7223      	strb	r3, [r4, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
    35f8:	e9d4 3100 	ldrd	r3, r1, [r4]
    irq_handler(NRF_SPI0, &m_cb[NRFX_SPI0_INST_IDX]);
}
    35fc:	b002      	add	sp, #8
    35fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    p_cb->handler(&p_cb->evt, p_cb->p_context);
    3602:	4718      	bx	r3
}
    3604:	b002      	add	sp, #8
    3606:	bd10      	pop	{r4, pc}
    3608:	40003108 	.word	0x40003108
    360c:	20000990 	.word	0x20000990
    3610:	40003000 	.word	0x40003000
    3614:	20000998 	.word	0x20000998

00003618 <twi_rx_start_transfer>:
    return ret_code;
}

static nrfx_err_t twi_rx_start_transfer(NRF_TWI_Type        * p_twi,
                                        twi_control_block_t * p_cb)
{
    3618:	b537      	push	{r0, r1, r2, r4, r5, lr}
    nrfx_err_t ret_code = NRFX_SUCCESS;
    volatile int32_t hw_timeout;

    hw_timeout = HW_TIMEOUT;
    361a:	4b34      	ldr	r3, [pc, #208]	; (36ec <twi_rx_start_transfer+0xd4>)
    361c:	9301      	str	r3, [sp, #4]
{
    361e:	460d      	mov	r5, r1

    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
    3620:	f44f 7182 	mov.w	r1, #260	; 0x104
{
    3624:	4604      	mov	r4, r0
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
    3626:	f005 f950 	bl	88ca <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
    362a:	f44f 7192 	mov.w	r1, #292	; 0x124
    362e:	f005 f94c 	bl	88ca <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_TXDSENT);
    3632:	f44f 718e 	mov.w	r1, #284	; 0x11c
    3636:	f005 f948 	bl	88ca <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_RXDREADY);
    363a:	f44f 7184 	mov.w	r1, #264	; 0x108
    363e:	f005 f944 	bl	88ca <nrf_twi_event_clear>

    p_cb->bytes_transferred = 0;
    3642:	2300      	movs	r3, #0
    3644:	636b      	str	r3, [r5, #52]	; 0x34
    p_cb->error             = false;
    3646:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f

    if ((p_cb->curr_length == 1) && (!TWI_FLAG_SUSPEND(p_cb->flags)))
    364a:	6aab      	ldr	r3, [r5, #40]	; 0x28
    364c:	2b01      	cmp	r3, #1
    364e:	d118      	bne.n	3682 <twi_rx_start_transfer+0x6a>
    3650:	6a2b      	ldr	r3, [r5, #32]
    3652:	065b      	lsls	r3, r3, #25
    3654:	d415      	bmi.n	3682 <twi_rx_start_transfer+0x6a>
}

NRF_STATIC_INLINE void nrf_twi_shorts_set(NRF_TWI_Type * p_reg,
                                          uint32_t       mask)
{
    p_reg->SHORTS = mask;
    3656:	2302      	movs	r3, #2
        nrf_twi_shorts_set(p_twi, NRF_TWI_SHORT_BB_SUSPEND_MASK);
    }
    // In case TWI is suspended resume its operation.
    nrf_twi_task_trigger(p_twi, NRF_TWI_TASK_RESUME);

    if (p_cb->prev_suspend != TWI_SUSPEND_RX)
    3658:	f895 202d 	ldrb.w	r2, [r5, #45]	; 0x2d
    365c:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
    3660:	2a02      	cmp	r2, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    3662:	f04f 0301 	mov.w	r3, #1
    3666:	6223      	str	r3, [r4, #32]
    3668:	bf18      	it	ne
    366a:	6023      	strne	r3, [r4, #0]
    {
        nrf_twi_task_trigger(p_twi, NRF_TWI_TASK_STARTRX);
    }

    if (p_cb->handler)
    366c:	682b      	ldr	r3, [r5, #0]
    366e:	b193      	cbz	r3, 3696 <twi_rx_start_transfer+0x7e>
    {
        p_cb->int_mask = NRF_TWI_INT_STOPPED_MASK   |
    3670:	f240 2386 	movw	r3, #646	; 0x286
    3674:	60ab      	str	r3, [r5, #8]
                        NRF_TWI_INT_ERROR_MASK     |
                        NRF_TWI_INT_TXDSENT_MASK   |
                        NRF_TWI_INT_RXDREADY_MASK;
        nrf_twi_int_enable(p_twi, p_cb->int_mask);
    3676:	68ab      	ldr	r3, [r5, #8]
    nrfx_err_t ret_code = NRFX_SUCCESS;
    3678:	481d      	ldr	r0, [pc, #116]	; (36f0 <twi_rx_start_transfer+0xd8>)
    p_reg->INTENSET = mask;
    367a:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
            nrf_twi_enable(p_twi);
            ret_code = NRFX_ERROR_INTERNAL;
        }
    }
    return ret_code;
}
    367e:	b003      	add	sp, #12
    3680:	bd30      	pop	{r4, r5, pc}
    p_reg->SHORTS = mask;
    3682:	2301      	movs	r3, #1
    3684:	e7e8      	b.n	3658 <twi_rx_start_transfer+0x40>
               twi_transfer(p_twi, p_cb))
    3686:	4629      	mov	r1, r5
    3688:	4620      	mov	r0, r4
    368a:	f005 f946 	bl	891a <twi_transfer>
        while ((hw_timeout > 0) &&
    368e:	b128      	cbz	r0, 369c <twi_rx_start_transfer+0x84>
               hw_timeout--;
    3690:	9b01      	ldr	r3, [sp, #4]
    3692:	3b01      	subs	r3, #1
    3694:	9301      	str	r3, [sp, #4]
        while ((hw_timeout > 0) &&
    3696:	9b01      	ldr	r3, [sp, #4]
    3698:	2b00      	cmp	r3, #0
    369a:	dcf4      	bgt.n	3686 <twi_rx_start_transfer+0x6e>
        if (p_cb->error)
    369c:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
    36a0:	b95b      	cbnz	r3, 36ba <twi_rx_start_transfer+0xa2>
    nrfx_err_t ret_code = NRFX_SUCCESS;
    36a2:	4813      	ldr	r0, [pc, #76]	; (36f0 <twi_rx_start_transfer+0xd8>)
        if (hw_timeout <= 0)
    36a4:	9b01      	ldr	r3, [sp, #4]
    36a6:	2b00      	cmp	r3, #0
    36a8:	dce9      	bgt.n	367e <twi_rx_start_transfer+0x66>
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos);
    36aa:	2300      	movs	r3, #0
    36ac:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Enabled << TWI_ENABLE_ENABLE_Pos);
    36b0:	2305      	movs	r3, #5
    36b2:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
            ret_code = NRFX_ERROR_INTERNAL;
    36b6:	480f      	ldr	r0, [pc, #60]	; (36f4 <twi_rx_start_transfer+0xdc>)
    return ret_code;
    36b8:	e7e1      	b.n	367e <twi_rx_start_transfer+0x66>
    uint32_t error_source = p_reg->ERRORSRC;
    36ba:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
    36be:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
            if (errorsrc)
    36c2:	2b00      	cmp	r3, #0
    36c4:	d0ed      	beq.n	36a2 <twi_rx_start_transfer+0x8a>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
    36c6:	4a0c      	ldr	r2, [pc, #48]	; (36f8 <twi_rx_start_transfer+0xe0>)
    36c8:	480a      	ldr	r0, [pc, #40]	; (36f4 <twi_rx_start_transfer+0xdc>)
    36ca:	f013 0f01 	tst.w	r3, #1
    36ce:	bf18      	it	ne
    36d0:	4610      	movne	r0, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
    36d2:	f013 0f02 	tst.w	r3, #2
    36d6:	f102 0201 	add.w	r2, r2, #1
    36da:	bf18      	it	ne
    36dc:	4610      	movne	r0, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
    36de:	f013 0f04 	tst.w	r3, #4
    36e2:	4b06      	ldr	r3, [pc, #24]	; (36fc <twi_rx_start_transfer+0xe4>)
    36e4:	bf18      	it	ne
    36e6:	4618      	movne	r0, r3
    36e8:	e7dc      	b.n	36a4 <twi_rx_start_transfer+0x8c>
    36ea:	bf00      	nop
    36ec:	000186a0 	.word	0x000186a0
    36f0:	0bad0000 	.word	0x0bad0000
    36f4:	0bad0001 	.word	0x0bad0001
    36f8:	0bae0000 	.word	0x0bae0000
    36fc:	0bae0002 	.word	0x0bae0002

00003700 <twi_tx_start_transfer>:
{
    3700:	b537      	push	{r0, r1, r2, r4, r5, lr}
    hw_timeout = HW_TIMEOUT;
    3702:	4b30      	ldr	r3, [pc, #192]	; (37c4 <twi_tx_start_transfer+0xc4>)
    3704:	9301      	str	r3, [sp, #4]
{
    3706:	460d      	mov	r5, r1
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
    3708:	f44f 7182 	mov.w	r1, #260	; 0x104
{
    370c:	4604      	mov	r4, r0
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
    370e:	f005 f8dc 	bl	88ca <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
    3712:	f44f 7192 	mov.w	r1, #292	; 0x124
    3716:	f005 f8d8 	bl	88ca <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_TXDSENT);
    371a:	f44f 718e 	mov.w	r1, #284	; 0x11c
    371e:	f005 f8d4 	bl	88ca <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_RXDREADY);
    3722:	f44f 7184 	mov.w	r1, #264	; 0x108
    3726:	f005 f8d0 	bl	88ca <nrf_twi_event_clear>
    p_reg->SHORTS = mask;
    372a:	2300      	movs	r3, #0
    if (p_cb->prev_suspend != TWI_SUSPEND_TX)
    372c:	f895 202d 	ldrb.w	r2, [r5, #45]	; 0x2d
    3730:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
    p_cb->bytes_transferred = 0;
    3734:	636b      	str	r3, [r5, #52]	; 0x34
    p_cb->error             = false;
    3736:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    373a:	2301      	movs	r3, #1
    if (p_cb->prev_suspend != TWI_SUSPEND_TX)
    373c:	429a      	cmp	r2, r3
    373e:	6203      	str	r3, [r0, #32]
    (void)twi_send_byte(p_twi, p_cb);
    3740:	4629      	mov	r1, r5
    3742:	bf18      	it	ne
    3744:	6083      	strne	r3, [r0, #8]
    3746:	f005 f8c8 	bl	88da <twi_send_byte>
    if (p_cb->handler)
    374a:	682b      	ldr	r3, [r5, #0]
    374c:	b183      	cbz	r3, 3770 <twi_tx_start_transfer+0x70>
        p_cb->int_mask = NRF_TWI_INT_STOPPED_MASK   |
    374e:	f240 2386 	movw	r3, #646	; 0x286
    3752:	60ab      	str	r3, [r5, #8]
        nrf_twi_int_enable(p_twi, p_cb->int_mask);
    3754:	68ab      	ldr	r3, [r5, #8]
    nrfx_err_t ret_code = NRFX_SUCCESS;
    3756:	481c      	ldr	r0, [pc, #112]	; (37c8 <twi_tx_start_transfer+0xc8>)
    p_reg->INTENSET = mask;
    3758:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
    375c:	b003      	add	sp, #12
    375e:	bd30      	pop	{r4, r5, pc}
               twi_transfer(p_twi, p_cb))
    3760:	4629      	mov	r1, r5
    3762:	4620      	mov	r0, r4
    3764:	f005 f8d9 	bl	891a <twi_transfer>
        while ((hw_timeout > 0) &&
    3768:	b128      	cbz	r0, 3776 <twi_tx_start_transfer+0x76>
            hw_timeout--;
    376a:	9b01      	ldr	r3, [sp, #4]
    376c:	3b01      	subs	r3, #1
    376e:	9301      	str	r3, [sp, #4]
        while ((hw_timeout > 0) &&
    3770:	9b01      	ldr	r3, [sp, #4]
    3772:	2b00      	cmp	r3, #0
    3774:	dcf4      	bgt.n	3760 <twi_tx_start_transfer+0x60>
        if (p_cb->error)
    3776:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
    377a:	b95b      	cbnz	r3, 3794 <twi_tx_start_transfer+0x94>
    nrfx_err_t ret_code = NRFX_SUCCESS;
    377c:	4812      	ldr	r0, [pc, #72]	; (37c8 <twi_tx_start_transfer+0xc8>)
        if (hw_timeout <= 0)
    377e:	9b01      	ldr	r3, [sp, #4]
    3780:	2b00      	cmp	r3, #0
    3782:	dceb      	bgt.n	375c <twi_tx_start_transfer+0x5c>
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos);
    3784:	2300      	movs	r3, #0
    3786:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Enabled << TWI_ENABLE_ENABLE_Pos);
    378a:	2305      	movs	r3, #5
    378c:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
            ret_code = NRFX_ERROR_INTERNAL;
    3790:	480e      	ldr	r0, [pc, #56]	; (37cc <twi_tx_start_transfer+0xcc>)
    return ret_code;
    3792:	e7e3      	b.n	375c <twi_tx_start_transfer+0x5c>
    uint32_t error_source = p_reg->ERRORSRC;
    3794:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
    3798:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
            if (errorsrc)
    379c:	2b00      	cmp	r3, #0
    379e:	d0ed      	beq.n	377c <twi_tx_start_transfer+0x7c>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
    37a0:	4a0b      	ldr	r2, [pc, #44]	; (37d0 <twi_tx_start_transfer+0xd0>)
    37a2:	480a      	ldr	r0, [pc, #40]	; (37cc <twi_tx_start_transfer+0xcc>)
    37a4:	f013 0f01 	tst.w	r3, #1
    37a8:	bf18      	it	ne
    37aa:	4610      	movne	r0, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
    37ac:	f013 0f02 	tst.w	r3, #2
    37b0:	f102 0201 	add.w	r2, r2, #1
    37b4:	bf18      	it	ne
    37b6:	4610      	movne	r0, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
    37b8:	f013 0f04 	tst.w	r3, #4
    37bc:	4b05      	ldr	r3, [pc, #20]	; (37d4 <twi_tx_start_transfer+0xd4>)
    37be:	bf18      	it	ne
    37c0:	4618      	movne	r0, r3
    37c2:	e7dc      	b.n	377e <twi_tx_start_transfer+0x7e>
    37c4:	000186a0 	.word	0x000186a0
    37c8:	0bad0000 	.word	0x0bad0000
    37cc:	0bad0001 	.word	0x0bad0001
    37d0:	0bae0000 	.word	0x0bae0000
    37d4:	0bae0002 	.word	0x0bae0002

000037d8 <nrfx_twi_init>:
{
    37d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    twi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    37da:	7907      	ldrb	r7, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
    37dc:	4d1d      	ldr	r5, [pc, #116]	; (3854 <nrfx_twi_init+0x7c>)
    37de:	f04f 0c3c 	mov.w	ip, #60	; 0x3c
    37e2:	fb0c fc07 	mul.w	ip, ip, r7
    37e6:	eb05 040c 	add.w	r4, r5, ip
    37ea:	f894 602e 	ldrb.w	r6, [r4, #46]	; 0x2e
    37ee:	bb7e      	cbnz	r6, 3850 <nrfx_twi_init+0x78>
    p_cb->p_context       = p_context;
    37f0:	6063      	str	r3, [r4, #4]
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
    37f2:	7b4b      	ldrb	r3, [r1, #13]
    p_cb->int_mask        = 0;
    37f4:	60a6      	str	r6, [r4, #8]
    p_cb->prev_suspend    = TWI_NO_SUSPEND;
    37f6:	f884 602d 	strb.w	r6, [r4, #45]	; 0x2d
    p_cb->busy            = false;
    37fa:	f884 6030 	strb.w	r6, [r4, #48]	; 0x30
    p_cb->repeated        = false;
    37fe:	f884 6031 	strb.w	r6, [r4, #49]	; 0x31
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
    3802:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
    TWI_PIN_INIT(p_config->scl);
    3806:	680c      	ldr	r4, [r1, #0]
    p_cb->handler         = event_handler;
    3808:	f845 200c 	str.w	r2, [r5, ip]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    380c:	f04f 46a0 	mov.w	r6, #1342177280	; 0x50000000
    3810:	f504 73e0 	add.w	r3, r4, #448	; 0x1c0
    3814:	f240 6c0c 	movw	ip, #1548	; 0x60c
    3818:	f846 c023 	str.w	ip, [r6, r3, lsl #2]
    TWI_PIN_INIT(p_config->sda);
    381c:	684b      	ldr	r3, [r1, #4]
    NRF_TWI_Type * p_twi = p_instance->p_twi;
    381e:	6800      	ldr	r0, [r0, #0]
    3820:	f503 7ee0 	add.w	lr, r3, #448	; 0x1c0
    3824:	f846 c02e 	str.w	ip, [r6, lr, lsl #2]
    p_reg->PSELSCL = scl_pin;
    3828:	f8c0 4508 	str.w	r4, [r0, #1288]	; 0x508
    p_reg->PSELSDA = sda_pin;
    382c:	f8c0 350c 	str.w	r3, [r0, #1292]	; 0x50c
        (nrf_twi_frequency_t)p_config->frequency);
    3830:	688b      	ldr	r3, [r1, #8]
    p_reg->FREQUENCY = frequency;
    3832:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524
    if (p_cb->handler)
    3836:	b11a      	cbz	r2, 3840 <nrfx_twi_init+0x68>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twi));
    3838:	f340 3007 	sbfx	r0, r0, #12, #8
    383c:	f7fd fcb6 	bl	11ac <arch_irq_enable>
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    3840:	233c      	movs	r3, #60	; 0x3c
    3842:	fb03 5507 	mla	r5, r3, r7, r5
    return err_code;
    3846:	4804      	ldr	r0, [pc, #16]	; (3858 <nrfx_twi_init+0x80>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    3848:	2301      	movs	r3, #1
    384a:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e
}
    384e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return err_code;
    3850:	4802      	ldr	r0, [pc, #8]	; (385c <nrfx_twi_init+0x84>)
    3852:	e7fc      	b.n	384e <nrfx_twi_init+0x76>
    3854:	200009bc 	.word	0x200009bc
    3858:	0bad0000 	.word	0x0bad0000
    385c:	0bad0005 	.word	0x0bad0005

00003860 <nrfx_twi_enable>:
    NRF_TWI_Type * p_twi = p_instance->p_twi;
    3860:	6802      	ldr	r2, [r0, #0]
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    3862:	7903      	ldrb	r3, [r0, #4]
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Enabled << TWI_ENABLE_ENABLE_Pos);
    3864:	2105      	movs	r1, #5
    3866:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
    386a:	4a04      	ldr	r2, [pc, #16]	; (387c <nrfx_twi_enable+0x1c>)
    386c:	213c      	movs	r1, #60	; 0x3c
    386e:	fb01 2303 	mla	r3, r1, r3, r2
    3872:	2202      	movs	r2, #2
    3874:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
}
    3878:	4770      	bx	lr
    387a:	bf00      	nop
    387c:	200009bc 	.word	0x200009bc

00003880 <nrfx_twi_disable>:
    NRF_TWI_Type * p_twi = p_instance->p_twi;
    3880:	6803      	ldr	r3, [r0, #0]
    p_reg->INTENCLR = mask;
    3882:	490a      	ldr	r1, [pc, #40]	; (38ac <nrfx_twi_disable+0x2c>)
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    3884:	7902      	ldrb	r2, [r0, #4]
    3886:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
    388a:	f8d3 1200 	ldr.w	r1, [r3, #512]	; 0x200
    388e:	f021 0103 	bic.w	r1, r1, #3
    3892:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos);
    3896:	2100      	movs	r1, #0
    3898:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    389c:	4b04      	ldr	r3, [pc, #16]	; (38b0 <nrfx_twi_disable+0x30>)
    389e:	213c      	movs	r1, #60	; 0x3c
    38a0:	fb01 3202 	mla	r2, r1, r2, r3
    38a4:	2301      	movs	r3, #1
    38a6:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
}
    38aa:	4770      	bx	lr
    38ac:	00044286 	.word	0x00044286
    38b0:	200009bc 	.word	0x200009bc

000038b4 <nrfx_twi_xfer>:
}

nrfx_err_t nrfx_twi_xfer(nrfx_twi_t const *           p_instance,
                         nrfx_twi_xfer_desc_t const * p_xfer_desc,
                         uint32_t                     flags)
{
    38b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if ((p_cb->prev_suspend == TWI_SUSPEND_TX) && (p_xfer_desc->type == NRFX_TWI_XFER_RX))
    38b8:	4d32      	ldr	r5, [pc, #200]	; (3984 <nrfx_twi_xfer+0xd0>)

    nrfx_err_t err_code = NRFX_SUCCESS;
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    38ba:	f890 8004 	ldrb.w	r8, [r0, #4]
                           p_xfer_desc->primary_length * sizeof(p_xfer_desc->p_primary_buf[0]));
    NRFX_LOG_DEBUG("Secondary buffer data:");
    NRFX_LOG_HEXDUMP_DEBUG(p_xfer_desc->p_secondary_buf,
                           p_xfer_desc->secondary_length * sizeof(p_xfer_desc->p_secondary_buf[0]));

    err_code = twi_xfer((NRF_TWI_Type  *)p_instance->p_twi, p_cb, p_xfer_desc, flags);
    38be:	f8d0 9000 	ldr.w	r9, [r0]
    if ((p_cb->prev_suspend == TWI_SUSPEND_TX) && (p_xfer_desc->type == NRFX_TWI_XFER_RX))
    38c2:	233c      	movs	r3, #60	; 0x3c
    38c4:	fb03 5308 	mla	r3, r3, r8, r5
{
    38c8:	460e      	mov	r6, r1
    if ((p_cb->prev_suspend == TWI_SUSPEND_TX) && (p_xfer_desc->type == NRFX_TWI_XFER_RX))
    38ca:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
    38ce:	2b01      	cmp	r3, #1
{
    38d0:	4696      	mov	lr, r2
    if ((p_cb->prev_suspend == TWI_SUSPEND_TX) && (p_xfer_desc->type == NRFX_TWI_XFER_RX))
    38d2:	d104      	bne.n	38de <nrfx_twi_xfer+0x2a>
    38d4:	780b      	ldrb	r3, [r1, #0]
    38d6:	2b01      	cmp	r3, #1
    38d8:	d106      	bne.n	38e8 <nrfx_twi_xfer+0x34>
        return NRFX_ERROR_INVALID_STATE;
    38da:	482b      	ldr	r0, [pc, #172]	; (3988 <nrfx_twi_xfer+0xd4>)
    NRFX_LOG_WARNING("Function: %s, error code: %s.",
                     __func__,
                     NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
    38dc:	e011      	b.n	3902 <nrfx_twi_xfer+0x4e>
    else if ((p_cb->prev_suspend == TWI_SUSPEND_RX) && (p_xfer_desc->type != NRFX_TWI_XFER_RX))
    38de:	2b02      	cmp	r3, #2
    38e0:	d102      	bne.n	38e8 <nrfx_twi_xfer+0x34>
    38e2:	780b      	ldrb	r3, [r1, #0]
    38e4:	2b01      	cmp	r3, #1
    38e6:	d1f8      	bne.n	38da <nrfx_twi_xfer+0x26>
    if (p_cb->busy)
    38e8:	243c      	movs	r4, #60	; 0x3c
    p_reg->INTENCLR = mask;
    38ea:	4b28      	ldr	r3, [pc, #160]	; (398c <nrfx_twi_xfer+0xd8>)
    38ec:	f8c9 3308 	str.w	r3, [r9, #776]	; 0x308
    38f0:	fb04 5408 	mla	r4, r4, r8, r5
    38f4:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
    38f8:	b12b      	cbz	r3, 3906 <nrfx_twi_xfer+0x52>
        nrf_twi_int_enable(p_twi, p_cb->int_mask);
    38fa:	68a3      	ldr	r3, [r4, #8]
        return err_code;
    38fc:	4824      	ldr	r0, [pc, #144]	; (3990 <nrfx_twi_xfer+0xdc>)
    p_reg->INTENSET = mask;
    38fe:	f8c9 3304 	str.w	r3, [r9, #772]	; 0x304
}
    3902:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        p_cb->busy = (TWI_FLAG_NO_HANDLER_IN_USE(flags)) ? false : true;
    3906:	f08e 0304 	eor.w	r3, lr, #4
    390a:	f3c3 0380 	ubfx	r3, r3, #2, #1
    390e:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
    p_cb->flags       = flags;
    3912:	f8c4 e020 	str.w	lr, [r4, #32]
    p_cb->xfer_desc   = *p_xfer_desc;
    3916:	46b4      	mov	ip, r6
    3918:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    391c:	f104 070c 	add.w	r7, r4, #12
    3920:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    3922:	f8dc 3000 	ldr.w	r3, [ip]
    3926:	603b      	str	r3, [r7, #0]
    p_cb->curr_length = p_xfer_desc->primary_length;
    3928:	6873      	ldr	r3, [r6, #4]
    392a:	62a3      	str	r3, [r4, #40]	; 0x28
    p_cb->p_curr_buf  = p_xfer_desc->p_primary_buf;
    392c:	68f3      	ldr	r3, [r6, #12]
    392e:	6263      	str	r3, [r4, #36]	; 0x24
    p_reg->ADDRESS = address;
    3930:	7873      	ldrb	r3, [r6, #1]
    3932:	f8c9 3588 	str.w	r3, [r9, #1416]	; 0x588
    if (p_xfer_desc->type != NRFX_TWI_XFER_RX)
    3936:	7833      	ldrb	r3, [r6, #0]
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    3938:	ebc8 1a08 	rsb	sl, r8, r8, lsl #4
    if (p_xfer_desc->type != NRFX_TWI_XFER_RX)
    393c:	2b01      	cmp	r3, #1
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    393e:	eb05 0a8a 	add.w	sl, r5, sl, lsl #2
    if (p_xfer_desc->type != NRFX_TWI_XFER_RX)
    3942:	d01a      	beq.n	397a <nrfx_twi_xfer+0xc6>
                                 !(flags & NRFX_TWI_FLAG_TX_NO_STOP)) ? false : true;
    3944:	b9b3      	cbnz	r3, 3974 <nrfx_twi_xfer+0xc0>
    3946:	f3ce 1e40 	ubfx	lr, lr, #5, #1
        p_cb->curr_tx_no_stop = ((p_xfer_desc->type == NRFX_TWI_XFER_TX) &&
    394a:	233c      	movs	r3, #60	; 0x3c
    394c:	fb03 5308 	mla	r3, r3, r8, r5
        err_code = twi_tx_start_transfer(p_twi, p_cb);
    3950:	4651      	mov	r1, sl
                                 !(flags & NRFX_TWI_FLAG_TX_NO_STOP)) ? false : true;
    3952:	f883 e02c 	strb.w	lr, [r3, #44]	; 0x2c
        err_code = twi_tx_start_transfer(p_twi, p_cb);
    3956:	4648      	mov	r0, r9
    3958:	f7ff fed2 	bl	3700 <twi_tx_start_transfer>
    if (p_cb->handler == NULL)
    395c:	233c      	movs	r3, #60	; 0x3c
    395e:	fb03 f808 	mul.w	r8, r3, r8
    3962:	eb05 0208 	add.w	r2, r5, r8
    3966:	f855 3008 	ldr.w	r3, [r5, r8]
    396a:	2b00      	cmp	r3, #0
    396c:	d1c9      	bne.n	3902 <nrfx_twi_xfer+0x4e>
        p_cb->busy = false;
    396e:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
    3972:	e7c6      	b.n	3902 <nrfx_twi_xfer+0x4e>
                                 !(flags & NRFX_TWI_FLAG_TX_NO_STOP)) ? false : true;
    3974:	f04f 0e01 	mov.w	lr, #1
    3978:	e7e7      	b.n	394a <nrfx_twi_xfer+0x96>
        err_code = twi_rx_start_transfer(p_twi, p_cb);
    397a:	4651      	mov	r1, sl
    397c:	4648      	mov	r0, r9
    397e:	f7ff fe4b 	bl	3618 <twi_rx_start_transfer>
    3982:	e7eb      	b.n	395c <nrfx_twi_xfer+0xa8>
    3984:	200009bc 	.word	0x200009bc
    3988:	0bad0005 	.word	0x0bad0005
    398c:	00044286 	.word	0x00044286
    3990:	0bad000b 	.word	0x0bad000b

00003994 <nrfx_twi_1_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_TWI1_ENABLED)
void nrfx_twi_1_irq_handler(void)
{
    3994:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (twi_transfer(p_twi, p_cb))
    3996:	4c29      	ldr	r4, [pc, #164]	; (3a3c <nrfx_twi_1_irq_handler+0xa8>)
{
    3998:	b087      	sub	sp, #28
    if (twi_transfer(p_twi, p_cb))
    399a:	4621      	mov	r1, r4
    399c:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
    39a0:	f004 ffbb 	bl	891a <twi_transfer>
    39a4:	46a4      	mov	ip, r4
    39a6:	b9e0      	cbnz	r0, 39e2 <nrfx_twi_1_irq_handler+0x4e>
    if (!p_cb->error &&
    39a8:	f894 702f 	ldrb.w	r7, [r4, #47]	; 0x2f
    39ac:	6a26      	ldr	r6, [r4, #32]
    39ae:	b9ef      	cbnz	r7, 39ec <nrfx_twi_1_irq_handler+0x58>
        ((p_cb->xfer_desc.type == NRFX_TWI_XFER_TXRX) ||
    39b0:	7b23      	ldrb	r3, [r4, #12]
    if (!p_cb->error &&
    39b2:	1e9a      	subs	r2, r3, #2
    39b4:	2a01      	cmp	r2, #1
    39b6:	d819      	bhi.n	39ec <nrfx_twi_1_irq_handler+0x58>
         (p_cb->xfer_desc.type == NRFX_TWI_XFER_TXTX)) &&
    39b8:	6a61      	ldr	r1, [r4, #36]	; 0x24
    39ba:	69a2      	ldr	r2, [r4, #24]
    39bc:	4291      	cmp	r1, r2
    39be:	d115      	bne.n	39ec <nrfx_twi_1_irq_handler+0x58>
        p_cb->p_curr_buf      = p_cb->xfer_desc.p_secondary_buf;
    39c0:	69e2      	ldr	r2, [r4, #28]
    39c2:	6262      	str	r2, [r4, #36]	; 0x24
        p_cb->curr_tx_no_stop = (p_cb->flags & NRFX_TWI_FLAG_TX_NO_STOP);
    39c4:	f3c6 1640 	ubfx	r6, r6, #5, #1
        p_cb->curr_length     = p_cb->xfer_desc.secondary_length;
    39c8:	6962      	ldr	r2, [r4, #20]
    39ca:	62a2      	str	r2, [r4, #40]	; 0x28
        if (p_cb->xfer_desc.type == NRFX_TWI_XFER_TXTX)
    39cc:	2b03      	cmp	r3, #3
        p_cb->curr_tx_no_stop = (p_cb->flags & NRFX_TWI_FLAG_TX_NO_STOP);
    39ce:	f884 602c 	strb.w	r6, [r4, #44]	; 0x2c
        p_cb->prev_suspend    = TWI_NO_SUSPEND;
    39d2:	f884 702d 	strb.w	r7, [r4, #45]	; 0x2d
            (void)twi_tx_start_transfer(p_twi, p_cb);
    39d6:	4621      	mov	r1, r4
    39d8:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
        if (p_cb->xfer_desc.type == NRFX_TWI_XFER_TXTX)
    39dc:	d103      	bne.n	39e6 <nrfx_twi_1_irq_handler+0x52>
            (void)twi_tx_start_transfer(p_twi, p_cb);
    39de:	f7ff fe8f 	bl	3700 <twi_tx_start_transfer>
    twi_irq_handler(NRF_TWI1, &m_cb[NRFX_TWI1_INST_IDX]);
}
    39e2:	b007      	add	sp, #28
    39e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
            (void)twi_rx_start_transfer(p_twi, p_cb);
    39e6:	f7ff fe17 	bl	3618 <twi_rx_start_transfer>
    39ea:	e7fa      	b.n	39e2 <nrfx_twi_1_irq_handler+0x4e>
        event.xfer_desc = p_cb->xfer_desc;
    39ec:	4d14      	ldr	r5, [pc, #80]	; (3a40 <nrfx_twi_1_irq_handler+0xac>)
    39ee:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    39f0:	ac01      	add	r4, sp, #4
    39f2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    39f4:	682b      	ldr	r3, [r5, #0]
    39f6:	6023      	str	r3, [r4, #0]
        if (p_cb->error)
    39f8:	b1e7      	cbz	r7, 3a34 <nrfx_twi_1_irq_handler+0xa0>
    uint32_t error_source = p_reg->ERRORSRC;
    39fa:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    39fe:	f8d2 34c4 	ldr.w	r3, [r2, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
    3a02:	f8c2 34c4 	str.w	r3, [r2, #1220]	; 0x4c4
            if (errorsrc & NRF_TWI_ERROR_ADDRESS_NACK)
    3a06:	0798      	lsls	r0, r3, #30
    3a08:	d50c      	bpl.n	3a24 <nrfx_twi_1_irq_handler+0x90>
                event.type = NRFX_TWI_EVT_ADDRESS_NACK;
    3a0a:	2301      	movs	r3, #1
                event.type = NRFX_TWI_EVT_DATA_NACK;
    3a0c:	f88d 3000 	strb.w	r3, [sp]
        p_cb->busy = false;
    3a10:	2300      	movs	r3, #0
    3a12:	f88c 3030 	strb.w	r3, [ip, #48]	; 0x30
        if (!(TWI_FLAG_NO_HANDLER_IN_USE(p_cb->flags)))
    3a16:	0773      	lsls	r3, r6, #29
    3a18:	d4e3      	bmi.n	39e2 <nrfx_twi_1_irq_handler+0x4e>
            p_cb->handler(&event, p_cb->p_context);
    3a1a:	e9dc 3100 	ldrd	r3, r1, [ip]
    3a1e:	4668      	mov	r0, sp
    3a20:	4798      	blx	r3
}
    3a22:	e7de      	b.n	39e2 <nrfx_twi_1_irq_handler+0x4e>
            else if (errorsrc & NRF_TWI_ERROR_DATA_NACK)
    3a24:	0759      	lsls	r1, r3, #29
    3a26:	d501      	bpl.n	3a2c <nrfx_twi_1_irq_handler+0x98>
                event.type = NRFX_TWI_EVT_DATA_NACK;
    3a28:	2302      	movs	r3, #2
    3a2a:	e7ef      	b.n	3a0c <nrfx_twi_1_irq_handler+0x78>
            else if (errorsrc & NRF_TWI_ERROR_OVERRUN)
    3a2c:	07da      	lsls	r2, r3, #31
    3a2e:	d5ef      	bpl.n	3a10 <nrfx_twi_1_irq_handler+0x7c>
                event.type = NRFX_TWI_EVT_OVERRUN;
    3a30:	2303      	movs	r3, #3
    3a32:	e7eb      	b.n	3a0c <nrfx_twi_1_irq_handler+0x78>
            event.type = NRFX_TWI_EVT_DONE;
    3a34:	f88d 7000 	strb.w	r7, [sp]
    3a38:	e7ea      	b.n	3a10 <nrfx_twi_1_irq_handler+0x7c>
    3a3a:	bf00      	nop
    3a3c:	200009bc 	.word	0x200009bc
    3a40:	200009c8 	.word	0x200009c8

00003a44 <lv_disp_get_scr_act>:
 * @param disp pointer to display which active screen should be get. (NULL to use the default
 * screen)
 * @return pointer to the active screen object (loaded by 'lv_scr_load()')
 */
lv_obj_t * lv_disp_get_scr_act(lv_disp_t * disp)
{
    3a44:	b510      	push	{r4, lr}
    if(!disp) disp = lv_disp_get_default();
    3a46:	4604      	mov	r4, r0
    3a48:	b958      	cbnz	r0, 3a62 <lv_disp_get_scr_act+0x1e>
    3a4a:	f001 fd4f 	bl	54ec <lv_disp_get_default>
    if(!disp) {
    3a4e:	4604      	mov	r4, r0
    3a50:	b938      	cbnz	r0, 3a62 <lv_disp_get_scr_act+0x1e>
        LV_LOG_WARN("lv_scr_act: no display registered to get its top layer");
    3a52:	4b05      	ldr	r3, [pc, #20]	; (3a68 <lv_disp_get_scr_act+0x24>)
    3a54:	4905      	ldr	r1, [pc, #20]	; (3a6c <lv_disp_get_scr_act+0x28>)
    3a56:	222e      	movs	r2, #46	; 0x2e
    3a58:	2002      	movs	r0, #2
    3a5a:	f002 f879 	bl	5b50 <lv_log_add>
        return NULL;
    }

    return disp->act_scr;
}
    3a5e:	4620      	mov	r0, r4
    3a60:	bd10      	pop	{r4, pc}
    return disp->act_scr;
    3a62:	6b64      	ldr	r4, [r4, #52]	; 0x34
    3a64:	e7fb      	b.n	3a5e <lv_disp_get_scr_act+0x1a>
    3a66:	bf00      	nop
    3a68:	0000c12e 	.word	0x0000c12e
    3a6c:	0000c165 	.word	0x0000c165

00003a70 <lv_disp_get_layer_top>:
 * Return with the top layer. (Same on every screen and it is above the normal screen layer)
 * @param disp pointer to display which top layer should be get. (NULL to use the default screen)
 * @return pointer to the top layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_top(lv_disp_t * disp)
{
    3a70:	b510      	push	{r4, lr}
    if(!disp) disp = lv_disp_get_default();
    3a72:	4604      	mov	r4, r0
    3a74:	b958      	cbnz	r0, 3a8e <lv_disp_get_layer_top+0x1e>
    3a76:	f001 fd39 	bl	54ec <lv_disp_get_default>
    if(!disp) {
    3a7a:	4604      	mov	r4, r0
    3a7c:	b938      	cbnz	r0, 3a8e <lv_disp_get_layer_top+0x1e>
        LV_LOG_WARN("lv_layer_top: no display registered to get its top layer");
    3a7e:	4b05      	ldr	r3, [pc, #20]	; (3a94 <lv_disp_get_layer_top+0x24>)
    3a80:	4905      	ldr	r1, [pc, #20]	; (3a98 <lv_disp_get_layer_top+0x28>)
    3a82:	224b      	movs	r2, #75	; 0x4b
    3a84:	2002      	movs	r0, #2
    3a86:	f002 f863 	bl	5b50 <lv_log_add>
        return NULL;
    }

    return disp->top_layer;
}
    3a8a:	4620      	mov	r0, r4
    3a8c:	bd10      	pop	{r4, pc}
    return disp->top_layer;
    3a8e:	6ba4      	ldr	r4, [r4, #56]	; 0x38
    3a90:	e7fb      	b.n	3a8a <lv_disp_get_layer_top+0x1a>
    3a92:	bf00      	nop
    3a94:	0000c0f5 	.word	0x0000c0f5
    3a98:	0000c165 	.word	0x0000c165

00003a9c <lv_disp_get_layer_sys>:
 * layer)
 * @param disp pointer to display which sys. layer  should be get. (NULL to use the default screen)
 * @return pointer to the sys layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_sys(lv_disp_t * disp)
{
    3a9c:	b510      	push	{r4, lr}
    if(!disp) disp = lv_disp_get_default();
    3a9e:	4604      	mov	r4, r0
    3aa0:	b958      	cbnz	r0, 3aba <lv_disp_get_layer_sys+0x1e>
    3aa2:	f001 fd23 	bl	54ec <lv_disp_get_default>
    if(!disp) {
    3aa6:	4604      	mov	r4, r0
    3aa8:	b938      	cbnz	r0, 3aba <lv_disp_get_layer_sys+0x1e>
        LV_LOG_WARN("lv_layer_sys: no display registered to get its top layer");
    3aaa:	4b05      	ldr	r3, [pc, #20]	; (3ac0 <lv_disp_get_layer_sys+0x24>)
    3aac:	4905      	ldr	r1, [pc, #20]	; (3ac4 <lv_disp_get_layer_sys+0x28>)
    3aae:	225c      	movs	r2, #92	; 0x5c
    3ab0:	2002      	movs	r0, #2
    3ab2:	f002 f84d 	bl	5b50 <lv_log_add>
        return NULL;
    }

    return disp->sys_layer;
}
    3ab6:	4620      	mov	r0, r4
    3ab8:	bd10      	pop	{r4, pc}
    return disp->sys_layer;
    3aba:	6be4      	ldr	r4, [r4, #60]	; 0x3c
    3abc:	e7fb      	b.n	3ab6 <lv_disp_get_layer_sys+0x1a>
    3abe:	bf00      	nop
    3ac0:	0000c0bc 	.word	0x0000c0bc
    3ac4:	0000c165 	.word	0x0000c165

00003ac8 <lv_init>:

/**
 * Init. the 'lv' library.
 */
void lv_init(void)
{
    3ac8:	b510      	push	{r4, lr}
    /* Do nothing if already initialized */
    if(lv_initialized) {
    3aca:	4c14      	ldr	r4, [pc, #80]	; (3b1c <lv_init+0x54>)
    3acc:	7823      	ldrb	r3, [r4, #0]
    3ace:	b13b      	cbz	r3, 3ae0 <lv_init+0x18>
        LV_LOG_WARN("lv_init: already inited");
    3ad0:	4b13      	ldr	r3, [pc, #76]	; (3b20 <lv_init+0x58>)
    3ad2:	4914      	ldr	r1, [pc, #80]	; (3b24 <lv_init+0x5c>)
    3ad4:	2253      	movs	r2, #83	; 0x53
    3ad6:	2002      	movs	r0, #2
    lv_img_decoder_init();
    lv_img_cache_set_size(LV_IMG_CACHE_DEF_SIZE);

    lv_initialized = true;
    LV_LOG_INFO("lv_init ready");
}
    3ad8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LV_LOG_INFO("lv_init ready");
    3adc:	f002 b838 	b.w	5b50 <lv_log_add>
    lv_mem_init();
    3ae0:	f006 fc93 	bl	a40a <lv_mem_init>
    lv_task_core_init();
    3ae4:	f001 fd32 	bl	554c <lv_task_core_init>
    lv_style_init();
    3ae8:	f000 fbe6 	bl	42b8 <lv_style_init>
    lv_refr_init();
    3aec:	f005 fb3d 	bl	916a <lv_refr_init>
    lv_ll_init(&LV_GC_ROOT(_lv_disp_ll), sizeof(lv_disp_t));
    3af0:	f44f 71b4 	mov.w	r1, #360	; 0x168
    3af4:	480c      	ldr	r0, [pc, #48]	; (3b28 <lv_init+0x60>)
    3af6:	f006 fcae 	bl	a456 <lv_ll_init>
    lv_ll_init(&LV_GC_ROOT(_lv_indev_ll), sizeof(lv_indev_t));
    3afa:	2160      	movs	r1, #96	; 0x60
    3afc:	480b      	ldr	r0, [pc, #44]	; (3b2c <lv_init+0x64>)
    3afe:	f006 fcaa 	bl	a456 <lv_ll_init>
    lv_indev_init();
    3b02:	f004 ff8f 	bl	8a24 <lv_indev_init>
    lv_img_decoder_init();
    3b06:	f001 fc0b 	bl	5320 <lv_img_decoder_init>
    lv_img_cache_set_size(LV_IMG_CACHE_DEF_SIZE);
    3b0a:	2001      	movs	r0, #1
    3b0c:	f001 fc5c 	bl	53c8 <lv_img_cache_set_size>
    lv_initialized = true;
    3b10:	2001      	movs	r0, #1
    3b12:	7020      	strb	r0, [r4, #0]
    LV_LOG_INFO("lv_init ready");
    3b14:	4b06      	ldr	r3, [pc, #24]	; (3b30 <lv_init+0x68>)
    3b16:	4903      	ldr	r1, [pc, #12]	; (3b24 <lv_init+0x5c>)
    3b18:	2279      	movs	r2, #121	; 0x79
    3b1a:	e7dd      	b.n	3ad8 <lv_init+0x10>
    3b1c:	2000531a 	.word	0x2000531a
    3b20:	0000c19b 	.word	0x0000c19b
    3b24:	0000c1b3 	.word	0x0000c1b3
    3b28:	20000e2c 	.word	0x20000e2c
    3b2c:	20000e4c 	.word	0x20000e4c
    3b30:	0000c1e8 	.word	0x0000c1e8

00003b34 <lv_obj_get_disp>:
 * Get the display of an object
 * @param scr pointer to an object
 * @return pointer the object's display
 */
lv_disp_t * lv_obj_get_disp(const lv_obj_t * obj)
{
    3b34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);

    const lv_obj_t * scr;

    if(obj->par == NULL)
    3b36:	6803      	ldr	r3, [r0, #0]
{
    3b38:	4605      	mov	r5, r0
    if(obj->par == NULL)
    3b3a:	b97b      	cbnz	r3, 3b5c <lv_obj_get_disp+0x28>
        scr = obj; /*`obj` is a screen*/
    else
        scr = lv_obj_get_screen(obj); /*get the screen of `obj`*/

    lv_disp_t * d;
    LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d)
    3b3c:	4813      	ldr	r0, [pc, #76]	; (3b8c <lv_obj_get_disp+0x58>)
    3b3e:	4f13      	ldr	r7, [pc, #76]	; (3b8c <lv_obj_get_disp+0x58>)
    3b40:	f006 fccf 	bl	a4e2 <lv_ll_get_head>
    3b44:	4604      	mov	r4, r0
    3b46:	b96c      	cbnz	r4, 3b64 <lv_obj_get_disp+0x30>
        {
            if(s == scr) return d;
        }
    }

    LV_LOG_WARN("lv_scr_get_disp: screen not found")
    3b48:	4b11      	ldr	r3, [pc, #68]	; (3b90 <lv_obj_get_disp+0x5c>)
    3b4a:	4912      	ldr	r1, [pc, #72]	; (3b94 <lv_obj_get_disp+0x60>)
    3b4c:	f240 6267 	movw	r2, #1639	; 0x667
    3b50:	2002      	movs	r0, #2
    3b52:	f001 fffd 	bl	5b50 <lv_log_add>
    return NULL;
}
    3b56:	4620      	mov	r0, r4
    3b58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    } while(par != NULL);
    3b5a:	461d      	mov	r5, r3
 */
lv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)
{
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);

    return obj->par;
    3b5c:	682b      	ldr	r3, [r5, #0]
    } while(par != NULL);
    3b5e:	2b00      	cmp	r3, #0
    3b60:	d1fb      	bne.n	3b5a <lv_obj_get_disp+0x26>
    3b62:	e7eb      	b.n	3b3c <lv_obj_get_disp+0x8>
        LV_LL_READ(d->scr_ll, s)
    3b64:	f104 0628 	add.w	r6, r4, #40	; 0x28
    3b68:	4630      	mov	r0, r6
    3b6a:	f006 fcba 	bl	a4e2 <lv_ll_get_head>
    3b6e:	b928      	cbnz	r0, 3b7c <lv_obj_get_disp+0x48>
    LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d)
    3b70:	4621      	mov	r1, r4
    3b72:	4638      	mov	r0, r7
    3b74:	f006 fcbb 	bl	a4ee <lv_ll_get_next>
    3b78:	4604      	mov	r4, r0
    3b7a:	e7e4      	b.n	3b46 <lv_obj_get_disp+0x12>
            if(s == scr) return d;
    3b7c:	4285      	cmp	r5, r0
    3b7e:	d0ea      	beq.n	3b56 <lv_obj_get_disp+0x22>
        LV_LL_READ(d->scr_ll, s)
    3b80:	4601      	mov	r1, r0
    3b82:	4630      	mov	r0, r6
    3b84:	f006 fcb3 	bl	a4ee <lv_ll_get_next>
    3b88:	e7f1      	b.n	3b6e <lv_obj_get_disp+0x3a>
    3b8a:	bf00      	nop
    3b8c:	20000e2c 	.word	0x20000e2c
    3b90:	0000c26e 	.word	0x0000c26e
    3b94:	0000c1b3 	.word	0x0000c1b3

00003b98 <lv_obj_create>:
{
    3b98:	b570      	push	{r4, r5, r6, lr}
    3b9a:	460d      	mov	r5, r1
    if(parent == NULL) {
    3b9c:	4606      	mov	r6, r0
    3b9e:	2800      	cmp	r0, #0
    3ba0:	f040 80d9 	bne.w	3d56 <lv_obj_create+0x1be>
        lv_disp_t * disp = lv_disp_get_default();
    3ba4:	f001 fca2 	bl	54ec <lv_disp_get_default>
        if(!disp) {
    3ba8:	4604      	mov	r4, r0
    3baa:	b938      	cbnz	r0, 3bbc <lv_obj_create+0x24>
            LV_LOG_WARN("lv_obj_create: not display created to so far. No place to assign the new screen");
    3bac:	4b89      	ldr	r3, [pc, #548]	; (3dd4 <lv_obj_create+0x23c>)
    3bae:	498a      	ldr	r1, [pc, #552]	; (3dd8 <lv_obj_create+0x240>)
    3bb0:	2290      	movs	r2, #144	; 0x90
    3bb2:	2002      	movs	r0, #2
    3bb4:	f001 ffcc 	bl	5b50 <lv_log_add>
}
    3bb8:	4620      	mov	r0, r4
    3bba:	bd70      	pop	{r4, r5, r6, pc}
        new_obj = lv_ll_ins_head(&disp->scr_ll);
    3bbc:	3028      	adds	r0, #40	; 0x28
    3bbe:	f006 fc54 	bl	a46a <lv_ll_ins_head>
        if(new_obj == NULL) return NULL;
    3bc2:	4604      	mov	r4, r0
    3bc4:	b908      	cbnz	r0, 3bca <lv_obj_create+0x32>
    3bc6:	2400      	movs	r4, #0
    3bc8:	e7f6      	b.n	3bb8 <lv_obj_create+0x20>
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
    3bca:	2138      	movs	r1, #56	; 0x38
        new_obj->par = NULL; /*Screens has no a parent*/
    3bcc:	f840 6b04 	str.w	r6, [r0], #4
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
    3bd0:	f006 fc41 	bl	a456 <lv_ll_init>
        new_obj->signal_cb = lv_obj_signal;
    3bd4:	4b81      	ldr	r3, [pc, #516]	; (3ddc <lv_obj_create+0x244>)
    3bd6:	61e3      	str	r3, [r4, #28]
        new_obj->design_cb = lv_obj_design;
    3bd8:	4b81      	ldr	r3, [pc, #516]	; (3de0 <lv_obj_create+0x248>)
    3bda:	6223      	str	r3, [r4, #32]
        new_obj->event_cb = NULL;
    3bdc:	61a6      	str	r6, [r4, #24]
        new_obj->coords.x1    = 0;
    3bde:	6126      	str	r6, [r4, #16]
        new_obj->coords.x2    = lv_disp_get_hor_res(NULL) - 1;
    3be0:	4630      	mov	r0, r6
    3be2:	f001 fc89 	bl	54f8 <lv_disp_get_hor_res>
    3be6:	3801      	subs	r0, #1
    3be8:	82a0      	strh	r0, [r4, #20]
        new_obj->coords.y2    = lv_disp_get_ver_res(NULL) - 1;
    3bea:	4630      	mov	r0, r6
    3bec:	f001 fc94 	bl	5518 <lv_disp_get_ver_res>
    3bf0:	3801      	subs	r0, #1
    3bf2:	82e0      	strh	r0, [r4, #22]
        new_obj->ext_draw_pad = 0;
    3bf4:	8626      	strh	r6, [r4, #48]	; 0x30
        lv_theme_t * th = lv_theme_get_current();
    3bf6:	f002 fb05 	bl	6204 <lv_theme_get_current>
        if(th) {
    3bfa:	2800      	cmp	r0, #0
    3bfc:	f000 80a9 	beq.w	3d52 <lv_obj_create+0x1ba>
            new_obj->style_p = th->style.scr;
    3c00:	6803      	ldr	r3, [r0, #0]
    3c02:	62a3      	str	r3, [r4, #40]	; 0x28
        memset(&new_obj->user_data, 0, sizeof(lv_obj_user_data_t));
    3c04:	2204      	movs	r2, #4
    3c06:	2100      	movs	r1, #0
    3c08:	f104 0034 	add.w	r0, r4, #52	; 0x34
    3c0c:	f004 fa78 	bl	8100 <memset>
        new_obj->click        = 0;
    3c10:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
        LV_LOG_INFO("Screen create ready");
    3c12:	4971      	ldr	r1, [pc, #452]	; (3dd8 <lv_obj_create+0x240>)
        new_obj->click        = 0;
    3c14:	f403 4303 	and.w	r3, r3, #33536	; 0x8300
    3c18:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
    3c1c:	62e3      	str	r3, [r4, #44]	; 0x2c
        new_obj->ext_attr = NULL;
    3c1e:	2300      	movs	r3, #0
    3c20:	6263      	str	r3, [r4, #36]	; 0x24
        LV_LOG_INFO("Screen create ready");
    3c22:	22de      	movs	r2, #222	; 0xde
    3c24:	4b6f      	ldr	r3, [pc, #444]	; (3de4 <lv_obj_create+0x24c>)
    3c26:	2001      	movs	r0, #1
    3c28:	f001 ff92 	bl	5b50 <lv_log_add>
    if(copy != NULL) {
    3c2c:	2d00      	cmp	r5, #0
    3c2e:	f000 8084 	beq.w	3d3a <lv_obj_create+0x1a2>
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
    memcpy(dest, src, sizeof(lv_area_t));
    3c32:	2208      	movs	r2, #8
    3c34:	f105 0110 	add.w	r1, r5, #16
    3c38:	f104 0010 	add.w	r0, r4, #16
    3c3c:	f004 fa36 	bl	80ac <memcpy>
        new_obj->ext_draw_pad = copy->ext_draw_pad;
    3c40:	f9b5 3030 	ldrsh.w	r3, [r5, #48]	; 0x30
    3c44:	8623      	strh	r3, [r4, #48]	; 0x30
        memcpy(&new_obj->user_data, &copy->user_data, sizeof(lv_obj_user_data_t));
    3c46:	2204      	movs	r2, #4
    3c48:	f105 0134 	add.w	r1, r5, #52	; 0x34
    3c4c:	f104 0034 	add.w	r0, r4, #52	; 0x34
    3c50:	f004 fa2c 	bl	80ac <memcpy>
        new_obj->event_cb = copy->event_cb;
    3c54:	69ab      	ldr	r3, [r5, #24]
        new_obj->click        = copy->click;
    3c56:	f895 202c 	ldrb.w	r2, [r5, #44]	; 0x2c
        new_obj->event_cb = copy->event_cb;
    3c5a:	61a3      	str	r3, [r4, #24]
        new_obj->click        = copy->click;
    3c5c:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    3c60:	f362 0300 	bfi	r3, r2, #0, #1
    3c64:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
        new_obj->drag         = copy->drag;
    3c68:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    3c6c:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    3c70:	f3c3 0340 	ubfx	r3, r3, #1, #1
    3c74:	f363 0241 	bfi	r2, r3, #1, #1
    3c78:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->drag_dir     = copy->drag_dir;
    3c7c:	f895 202d 	ldrb.w	r2, [r5, #45]	; 0x2d
    3c80:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
    3c84:	f362 0301 	bfi	r3, r2, #0, #2
    3c88:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
        new_obj->drag_throw   = copy->drag_throw;
    3c8c:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    3c90:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    3c94:	f3c3 0380 	ubfx	r3, r3, #2, #1
    3c98:	f363 0282 	bfi	r2, r3, #2, #1
    3c9c:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->drag_parent  = copy->drag_parent;
    3ca0:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    3ca4:	b2d2      	uxtb	r2, r2
    3ca6:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    3caa:	f363 02c3 	bfi	r2, r3, #3, #1
    3cae:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->hidden       = copy->hidden;
    3cb2:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    3cb6:	b2d2      	uxtb	r2, r2
    3cb8:	f3c3 1300 	ubfx	r3, r3, #4, #1
    3cbc:	f363 1204 	bfi	r2, r3, #4, #1
    3cc0:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->top          = copy->top;
    3cc4:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    3cc8:	b2d2      	uxtb	r2, r2
    3cca:	f3c3 1340 	ubfx	r3, r3, #5, #1
    3cce:	f363 1245 	bfi	r2, r3, #5, #1
    3cd2:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->parent_event = copy->parent_event;
    3cd6:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    3cda:	b2d2      	uxtb	r2, r2
    3cdc:	09db      	lsrs	r3, r3, #7
    3cde:	f363 12c7 	bfi	r2, r3, #7, #1
    3ce2:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->opa_scale_en = copy->opa_scale_en;
    3ce6:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    3cea:	b2d2      	uxtb	r2, r2
    3cec:	f3c3 1380 	ubfx	r3, r3, #6, #1
    3cf0:	f363 1286 	bfi	r2, r3, #6, #1
    3cf4:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->protect      = copy->protect;
    3cf8:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
    3cfc:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
        new_obj->opa_scale    = copy->opa_scale;
    3d00:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
    3d04:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
        new_obj->style_p = copy->style_p;
    3d08:	6aab      	ldr	r3, [r5, #40]	; 0x28
    3d0a:	62a3      	str	r3, [r4, #40]	; 0x28
        if(lv_obj_get_parent(copy) != NULL && parent != NULL) {
    3d0c:	682b      	ldr	r3, [r5, #0]
    3d0e:	2b00      	cmp	r3, #0
    3d10:	d05c      	beq.n	3dcc <lv_obj_create+0x234>
    3d12:	2e00      	cmp	r6, #0
    3d14:	d05a      	beq.n	3dcc <lv_obj_create+0x234>
            lv_obj_set_pos(new_obj, lv_obj_get_x(copy), lv_obj_get_y(copy));
    3d16:	4628      	mov	r0, r5
    3d18:	f004 ffda 	bl	8cd0 <lv_obj_get_x>
    3d1c:	4601      	mov	r1, r0
    3d1e:	4628      	mov	r0, r5
    3d20:	f004 ffde 	bl	8ce0 <lv_obj_get_y>
    3d24:	4602      	mov	r2, r0
            lv_obj_set_pos(new_obj, 0, 0);
    3d26:	4620      	mov	r0, r4
    3d28:	f004 ff00 	bl	8b2c <lv_obj_set_pos>
        LV_LOG_INFO("Object create ready");
    3d2c:	4b2e      	ldr	r3, [pc, #184]	; (3de8 <lv_obj_create+0x250>)
    3d2e:	492a      	ldr	r1, [pc, #168]	; (3dd8 <lv_obj_create+0x240>)
    3d30:	f240 127d 	movw	r2, #381	; 0x17d
    3d34:	2001      	movs	r0, #1
    3d36:	f001 ff0b 	bl	5b50 <lv_log_add>
    if(parent != NULL) {
    3d3a:	2e00      	cmp	r6, #0
    3d3c:	f43f af3c 	beq.w	3bb8 <lv_obj_create+0x20>
        parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, new_obj);
    3d40:	69f3      	ldr	r3, [r6, #28]
    3d42:	4622      	mov	r2, r4
    3d44:	2101      	movs	r1, #1
    3d46:	4630      	mov	r0, r6
    3d48:	4798      	blx	r3
        lv_obj_invalidate(new_obj);
    3d4a:	4620      	mov	r0, r4
    3d4c:	f004 fe9e 	bl	8a8c <lv_obj_invalidate>
    3d50:	e732      	b.n	3bb8 <lv_obj_create+0x20>
            new_obj->style_p = &lv_style_scr;
    3d52:	4b26      	ldr	r3, [pc, #152]	; (3dec <lv_obj_create+0x254>)
    3d54:	e755      	b.n	3c02 <lv_obj_create+0x6a>
        new_obj = lv_ll_ins_head(&parent->child_ll);
    3d56:	3004      	adds	r0, #4
    3d58:	f006 fb87 	bl	a46a <lv_ll_ins_head>
        if(new_obj == NULL) return NULL;
    3d5c:	4604      	mov	r4, r0
    3d5e:	2800      	cmp	r0, #0
    3d60:	f43f af31 	beq.w	3bc6 <lv_obj_create+0x2e>
        new_obj->par = parent; /*Set the parent*/
    3d64:	f840 6b04 	str.w	r6, [r0], #4
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
    3d68:	2138      	movs	r1, #56	; 0x38
    3d6a:	f006 fb74 	bl	a456 <lv_ll_init>
        new_obj->signal_cb = lv_obj_signal;
    3d6e:	4b1b      	ldr	r3, [pc, #108]	; (3ddc <lv_obj_create+0x244>)
        new_obj->base_dir     = LV_BIDI_DIR_LTR;
    3d70:	f894 202d 	ldrb.w	r2, [r4, #45]	; 0x2d
        new_obj->signal_cb = lv_obj_signal;
    3d74:	61e3      	str	r3, [r4, #28]
        new_obj->design_cb = lv_obj_design;
    3d76:	4b1a      	ldr	r3, [pc, #104]	; (3de0 <lv_obj_create+0x248>)
    3d78:	6223      	str	r3, [r4, #32]
        new_obj->event_cb = NULL;
    3d7a:	2300      	movs	r3, #0
        new_obj->base_dir     = LV_BIDI_DIR_LTR;
    3d7c:	f363 0283 	bfi	r2, r3, #2, #2
    3d80:	f884 202d 	strb.w	r2, [r4, #45]	; 0x2d
        new_obj->coords.y1    = parent->coords.y1;
    3d84:	f9b6 2012 	ldrsh.w	r2, [r6, #18]
    3d88:	8262      	strh	r2, [r4, #18]
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
    3d8a:	8a72      	ldrh	r2, [r6, #18]
        new_obj->event_cb = NULL;
    3d8c:	61a3      	str	r3, [r4, #24]
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
    3d8e:	3242      	adds	r2, #66	; 0x42
    3d90:	82e2      	strh	r2, [r4, #22]
            new_obj->coords.x1    = parent->coords.x1;
    3d92:	f9b6 2010 	ldrsh.w	r2, [r6, #16]
    3d96:	8222      	strh	r2, [r4, #16]
            new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;
    3d98:	8a32      	ldrh	r2, [r6, #16]
        new_obj->ext_draw_pad = 0;
    3d9a:	8623      	strh	r3, [r4, #48]	; 0x30
            new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;
    3d9c:	3264      	adds	r2, #100	; 0x64
    3d9e:	82a2      	strh	r2, [r4, #20]
        lv_theme_t * th = lv_theme_get_current();
    3da0:	f002 fa30 	bl	6204 <lv_theme_get_current>
        if(th) {
    3da4:	b180      	cbz	r0, 3dc8 <lv_obj_create+0x230>
            new_obj->style_p = th->style.panel;
    3da6:	6883      	ldr	r3, [r0, #8]
    3da8:	62a3      	str	r3, [r4, #40]	; 0x28
        memset(&new_obj->user_data, 0, sizeof(lv_obj_user_data_t));
    3daa:	2204      	movs	r2, #4
    3dac:	2100      	movs	r1, #0
    3dae:	f104 0034 	add.w	r0, r4, #52	; 0x34
    3db2:	f004 f9a5 	bl	8100 <memset>
        new_obj->click        = 1;
    3db6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    3db8:	f403 420c 	and.w	r2, r3, #35840	; 0x8c00
    3dbc:	4b0c      	ldr	r3, [pc, #48]	; (3df0 <lv_obj_create+0x258>)
    3dbe:	4313      	orrs	r3, r2
    3dc0:	62e3      	str	r3, [r4, #44]	; 0x2c
        new_obj->ext_attr = NULL;
    3dc2:	2300      	movs	r3, #0
    3dc4:	6263      	str	r3, [r4, #36]	; 0x24
    3dc6:	e731      	b.n	3c2c <lv_obj_create+0x94>
            new_obj->style_p = &lv_style_plain_color;
    3dc8:	4b0a      	ldr	r3, [pc, #40]	; (3df4 <lv_obj_create+0x25c>)
    3dca:	e7ed      	b.n	3da8 <lv_obj_create+0x210>
            lv_obj_set_pos(new_obj, 0, 0);
    3dcc:	2200      	movs	r2, #0
    3dce:	4611      	mov	r1, r2
    3dd0:	e7a9      	b.n	3d26 <lv_obj_create+0x18e>
    3dd2:	bf00      	nop
    3dd4:	0000c1f6 	.word	0x0000c1f6
    3dd8:	0000c1b3 	.word	0x0000c1b3
    3ddc:	00003e19 	.word	0x00003e19
    3de0:	00008f65 	.word	0x00008f65
    3de4:	0000c246 	.word	0x0000c246
    3de8:	0000c25a 	.word	0x0000c25a
    3dec:	20000cd0 	.word	0x20000cd0
    3df0:	ff000301 	.word	0xff000301
    3df4:	20000be0 	.word	0x20000be0

00003df8 <lv_obj_get_style>:
 */
const lv_style_t * lv_obj_get_style(const lv_obj_t * obj)
{
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);

    const lv_style_t * style_act = obj->style_p;
    3df8:	6a83      	ldr	r3, [r0, #40]	; 0x28
    if(style_act == NULL) {
    3dfa:	b913      	cbnz	r3, 3e02 <lv_obj_get_style+0xa>
        lv_obj_t * par = obj->par;
    3dfc:	6802      	ldr	r2, [r0, #0]

        while(par) {
    3dfe:	b912      	cbnz	r2, 3e06 <lv_obj_get_style+0xe>
            style_act = lv_group_mod_style(obj->group_p, style_act);
        }
    }
#endif

    if(style_act == NULL) style_act = &lv_style_plain;
    3e00:	4b04      	ldr	r3, [pc, #16]	; (3e14 <lv_obj_get_style+0x1c>)

    return style_act;
}
    3e02:	4618      	mov	r0, r3
    3e04:	4770      	bx	lr
            if(par->style_p) {
    3e06:	6a93      	ldr	r3, [r2, #40]	; 0x28
    3e08:	b113      	cbz	r3, 3e10 <lv_obj_get_style+0x18>
                if(par->style_p->glass == 0) {
    3e0a:	7819      	ldrb	r1, [r3, #0]
    3e0c:	07c9      	lsls	r1, r1, #31
    3e0e:	d5f8      	bpl.n	3e02 <lv_obj_get_style+0xa>
            par = par->par;
    3e10:	6812      	ldr	r2, [r2, #0]
    3e12:	e7f4      	b.n	3dfe <lv_obj_get_style+0x6>
    3e14:	20000b90 	.word	0x20000b90

00003e18 <lv_obj_signal>:
 * @param param parameter for the signal (depends on signal type)
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_obj_signal(lv_obj_t * obj, lv_signal_t sign, void * param)
{
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    3e18:	2907      	cmp	r1, #7
{
    3e1a:	b510      	push	{r4, lr}
    3e1c:	4604      	mov	r4, r0
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    3e1e:	d105      	bne.n	3e2c <lv_obj_signal+0x14>
    3e20:	490f      	ldr	r1, [pc, #60]	; (3e60 <lv_obj_signal+0x48>)
    3e22:	4610      	mov	r0, r2
        if(style->body.shadow.width > obj->ext_draw_pad) obj->ext_draw_pad = style->body.shadow.width;
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
        lv_obj_refresh_ext_draw_pad(obj);
    }
    return res;
}
    3e24:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    3e28:	f005 b8f2 	b.w	9010 <lv_obj_handle_get_type_signal>
    if(sign == LV_SIGNAL_CHILD_CHG) {
    3e2c:	2901      	cmp	r1, #1
    3e2e:	d105      	bne.n	3e3c <lv_obj_signal+0x24>
    return (obj->protect & prot) == 0 ? false : true;
    3e30:	f890 002e 	ldrb.w	r0, [r0, #46]	; 0x2e
    3e34:	43c0      	mvns	r0, r0
    3e36:	f000 0001 	and.w	r0, r0, #1
}
    3e3a:	bd10      	pop	{r4, pc}
    } else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
    3e3c:	2906      	cmp	r1, #6
    3e3e:	d10a      	bne.n	3e56 <lv_obj_signal+0x3e>
        const lv_style_t * style = lv_obj_get_style(obj);
    3e40:	f7ff ffda 	bl	3df8 <lv_obj_get_style>
        if(style->body.shadow.width > obj->ext_draw_pad) obj->ext_draw_pad = style->body.shadow.width;
    3e44:	f9b4 2030 	ldrsh.w	r2, [r4, #48]	; 0x30
    3e48:	f9b0 301c 	ldrsh.w	r3, [r0, #28]
    3e4c:	429a      	cmp	r2, r3
    3e4e:	da00      	bge.n	3e52 <lv_obj_signal+0x3a>
    3e50:	8623      	strh	r3, [r4, #48]	; 0x30
    lv_res_t res = LV_RES_OK;
    3e52:	2001      	movs	r0, #1
    3e54:	e7f1      	b.n	3e3a <lv_obj_signal+0x22>
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
    3e56:	2904      	cmp	r1, #4
    3e58:	d1fb      	bne.n	3e52 <lv_obj_signal+0x3a>
        lv_obj_refresh_ext_draw_pad(obj);
    3e5a:	f004 fead 	bl	8bb8 <lv_obj_refresh_ext_draw_pad>
    3e5e:	e7f8      	b.n	3e52 <lv_obj_signal+0x3a>
    3e60:	0000c290 	.word	0x0000c290

00003e64 <lv_refr_vdb_flush>:

/**
 * Flush the content of the VDB
 */
static void lv_refr_vdb_flush(void)
{
    3e64:	b538      	push	{r3, r4, r5, lr}
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    3e66:	4d10      	ldr	r5, [pc, #64]	; (3ea8 <lv_refr_vdb_flush+0x44>)
    3e68:	6828      	ldr	r0, [r5, #0]
    3e6a:	f006 f9ce 	bl	a20a <lv_disp_get_buf>
    3e6e:	4604      	mov	r4, r0

    /*In double buffered mode wait until the other buffer is flushed before flushing the current
     * one*/
    if(lv_disp_is_double_buf(disp_refr)) {
    3e70:	6828      	ldr	r0, [r5, #0]
    3e72:	f006 f9cc 	bl	a20e <lv_disp_is_double_buf>
    3e76:	b110      	cbz	r0, 3e7e <lv_refr_vdb_flush+0x1a>
        while(vdb->flushing)
    3e78:	69a3      	ldr	r3, [r4, #24]
    3e7a:	07db      	lsls	r3, r3, #31
    3e7c:	d4fc      	bmi.n	3e78 <lv_refr_vdb_flush+0x14>
            ;
    }

    vdb->flushing = 1;
    3e7e:	7e23      	ldrb	r3, [r4, #24]
    return disp_refr;
    3e80:	6828      	ldr	r0, [r5, #0]
    vdb->flushing = 1;
    3e82:	f043 0301 	orr.w	r3, r3, #1
    3e86:	7623      	strb	r3, [r4, #24]

    /*Flush the rendered content to the display*/
    lv_disp_t * disp = lv_refr_get_disp_refreshing();
    if(disp->driver.flush_cb) disp->driver.flush_cb(&disp->driver, &vdb->area, vdb->buf_act);
    3e88:	68c3      	ldr	r3, [r0, #12]
    3e8a:	b11b      	cbz	r3, 3e94 <lv_refr_vdb_flush+0x30>
    3e8c:	68a2      	ldr	r2, [r4, #8]
    3e8e:	f104 0110 	add.w	r1, r4, #16
    3e92:	4798      	blx	r3

    if(vdb->buf1 && vdb->buf2) {
    3e94:	6823      	ldr	r3, [r4, #0]
    3e96:	b133      	cbz	r3, 3ea6 <lv_refr_vdb_flush+0x42>
    3e98:	6862      	ldr	r2, [r4, #4]
    3e9a:	b122      	cbz	r2, 3ea6 <lv_refr_vdb_flush+0x42>
        if(vdb->buf_act == vdb->buf1)
    3e9c:	68a1      	ldr	r1, [r4, #8]
            vdb->buf_act = vdb->buf2;
    3e9e:	428b      	cmp	r3, r1
    3ea0:	bf08      	it	eq
    3ea2:	4613      	moveq	r3, r2
    3ea4:	60a3      	str	r3, [r4, #8]
        else
            vdb->buf_act = vdb->buf1;
    }
}
    3ea6:	bd38      	pop	{r3, r4, r5, pc}
    3ea8:	200009f8 	.word	0x200009f8

00003eac <lv_refr_obj_and_children>:
{
    3eac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3eae:	460e      	mov	r6, r1
    if(top_p == NULL) top_p = lv_disp_get_scr_act(disp_refr);
    3eb0:	4605      	mov	r5, r0
    3eb2:	b920      	cbnz	r0, 3ebe <lv_refr_obj_and_children+0x12>
    3eb4:	4b12      	ldr	r3, [pc, #72]	; (3f00 <lv_refr_obj_and_children+0x54>)
    3eb6:	6818      	ldr	r0, [r3, #0]
    3eb8:	f7ff fdc4 	bl	3a44 <lv_disp_get_scr_act>
    3ebc:	4605      	mov	r5, r0
    lv_refr_obj(top_p, mask_p);
    3ebe:	4628      	mov	r0, r5
    3ec0:	4631      	mov	r1, r6
    3ec2:	f005 f8e5 	bl	9090 <lv_refr_obj>
    par = lv_obj_get_parent(top_p);
    3ec6:	4628      	mov	r0, r5
    3ec8:	f004 fecd 	bl	8c66 <lv_obj_get_parent>
        par = lv_obj_get_parent(par);
    3ecc:	4604      	mov	r4, r0
    while(par != NULL) {
    3ece:	b900      	cbnz	r0, 3ed2 <lv_refr_obj_and_children+0x26>
}
    3ed0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        lv_obj_t * i = lv_ll_get_prev(&(par->child_ll), border_p);
    3ed2:	1d27      	adds	r7, r4, #4
            i = lv_ll_get_prev(&(par->child_ll), i);
    3ed4:	4629      	mov	r1, r5
    3ed6:	4638      	mov	r0, r7
    3ed8:	f006 fb19 	bl	a50e <lv_ll_get_prev>
    3edc:	4605      	mov	r5, r0
        while(i != NULL) {
    3ede:	b948      	cbnz	r0, 3ef4 <lv_refr_obj_and_children+0x48>
        par->design_cb(par, mask_p, LV_DESIGN_DRAW_POST);
    3ee0:	6a23      	ldr	r3, [r4, #32]
    3ee2:	2201      	movs	r2, #1
    3ee4:	4631      	mov	r1, r6
    3ee6:	4620      	mov	r0, r4
    3ee8:	4798      	blx	r3
        par = lv_obj_get_parent(par);
    3eea:	4620      	mov	r0, r4
    3eec:	f004 febb 	bl	8c66 <lv_obj_get_parent>
    3ef0:	4625      	mov	r5, r4
    3ef2:	e7eb      	b.n	3ecc <lv_refr_obj_and_children+0x20>
            lv_refr_obj(i, mask_p);
    3ef4:	4631      	mov	r1, r6
    3ef6:	4628      	mov	r0, r5
    3ef8:	f005 f8ca 	bl	9090 <lv_refr_obj>
    3efc:	e7ea      	b.n	3ed4 <lv_refr_obj_and_children+0x28>
    3efe:	bf00      	nop
    3f00:	200009f8 	.word	0x200009f8

00003f04 <lv_refr_area_part>:
{
    3f04:	b573      	push	{r0, r1, r4, r5, r6, lr}
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    3f06:	4c18      	ldr	r4, [pc, #96]	; (3f68 <lv_refr_area_part+0x64>)
{
    3f08:	4606      	mov	r6, r0
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    3f0a:	6820      	ldr	r0, [r4, #0]
    3f0c:	f006 f97d 	bl	a20a <lv_disp_get_buf>
    3f10:	4605      	mov	r5, r0
    if(lv_disp_is_double_buf(disp_refr) == false) {
    3f12:	6820      	ldr	r0, [r4, #0]
    3f14:	f006 f97b 	bl	a20e <lv_disp_is_double_buf>
    3f18:	b910      	cbnz	r0, 3f20 <lv_refr_area_part+0x1c>
        while(vdb->flushing)
    3f1a:	69ab      	ldr	r3, [r5, #24]
    3f1c:	07db      	lsls	r3, r3, #31
    3f1e:	d4fc      	bmi.n	3f1a <lv_refr_area_part+0x16>
    lv_area_intersect(&start_mask, area_p, &vdb->area);
    3f20:	f105 0210 	add.w	r2, r5, #16
    3f24:	4631      	mov	r1, r6
    3f26:	4668      	mov	r0, sp
    3f28:	f006 f9cc 	bl	a2c4 <lv_area_intersect>
    top_p = lv_refr_get_top_obj(&start_mask, lv_disp_get_scr_act(disp_refr));
    3f2c:	6820      	ldr	r0, [r4, #0]
    3f2e:	f7ff fd89 	bl	3a44 <lv_disp_get_scr_act>
    3f32:	4601      	mov	r1, r0
    3f34:	4668      	mov	r0, sp
    3f36:	f005 f879 	bl	902c <lv_refr_get_top_obj>
    lv_refr_obj_and_children(top_p, &start_mask);
    3f3a:	4669      	mov	r1, sp
    3f3c:	f7ff ffb6 	bl	3eac <lv_refr_obj_and_children>
    lv_refr_obj_and_children(lv_disp_get_layer_top(disp_refr), &start_mask);
    3f40:	6820      	ldr	r0, [r4, #0]
    3f42:	f7ff fd95 	bl	3a70 <lv_disp_get_layer_top>
    3f46:	4669      	mov	r1, sp
    3f48:	f7ff ffb0 	bl	3eac <lv_refr_obj_and_children>
    lv_refr_obj_and_children(lv_disp_get_layer_sys(disp_refr), &start_mask);
    3f4c:	6820      	ldr	r0, [r4, #0]
    3f4e:	f7ff fda5 	bl	3a9c <lv_disp_get_layer_sys>
    3f52:	4669      	mov	r1, sp
    3f54:	f7ff ffaa 	bl	3eac <lv_refr_obj_and_children>
    if(lv_disp_is_true_double_buf(disp_refr) == false) {
    3f58:	6820      	ldr	r0, [r4, #0]
    3f5a:	f006 f960 	bl	a21e <lv_disp_is_true_double_buf>
    3f5e:	b908      	cbnz	r0, 3f64 <lv_refr_area_part+0x60>
        lv_refr_vdb_flush();
    3f60:	f7ff ff80 	bl	3e64 <lv_refr_vdb_flush>
}
    3f64:	b002      	add	sp, #8
    3f66:	bd70      	pop	{r4, r5, r6, pc}
    3f68:	200009f8 	.word	0x200009f8

00003f6c <lv_refr_get_disp_refreshing>:
}
    3f6c:	4b01      	ldr	r3, [pc, #4]	; (3f74 <lv_refr_get_disp_refreshing+0x8>)
    3f6e:	6818      	ldr	r0, [r3, #0]
    3f70:	4770      	bx	lr
    3f72:	bf00      	nop
    3f74:	200009f8 	.word	0x200009f8

00003f78 <lv_disp_refr_task>:
{
    3f78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3f7c:	b089      	sub	sp, #36	; 0x24
    3f7e:	4605      	mov	r5, r0
    uint32_t start = lv_tick_get();
    3f80:	f006 f95c 	bl	a23c <lv_tick_get>
    disp_refr = task->user_data;
    3f84:	4cae      	ldr	r4, [pc, #696]	; (4240 <lv_disp_refr_task+0x2c8>)
    3f86:	68eb      	ldr	r3, [r5, #12]
    uint32_t start = lv_tick_get();
    3f88:	9003      	str	r0, [sp, #12]
    disp_refr = task->user_data;
    3f8a:	6023      	str	r3, [r4, #0]
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
    3f8c:	2600      	movs	r6, #0
    3f8e:	6823      	ldr	r3, [r4, #0]
    3f90:	f8b3 2160 	ldrh.w	r2, [r3, #352]	; 0x160
    3f94:	f3c2 0209 	ubfx	r2, r2, #0, #10
    3f98:	4296      	cmp	r6, r2
    3f9a:	d330      	bcc.n	3ffe <lv_disp_refr_task+0x86>
    px_num = 0;
    3f9c:	4ba9      	ldr	r3, [pc, #676]	; (4244 <lv_disp_refr_task+0x2cc>)
            if(disp_refr->driver.monitor_cb) px_num += lv_area_get_size(&disp_refr->inv_areas[i]);
    3f9e:	9302      	str	r3, [sp, #8]
    px_num = 0;
    3fa0:	2200      	movs	r2, #0
    3fa2:	601a      	str	r2, [r3, #0]
    for(i = 0; i < disp_refr->inv_p; i++) {
    3fa4:	4690      	mov	r8, r2
    3fa6:	6827      	ldr	r7, [r4, #0]
    3fa8:	f8b7 3160 	ldrh.w	r3, [r7, #352]	; 0x160
    3fac:	f3c3 0209 	ubfx	r2, r3, #0, #10
    3fb0:	4590      	cmp	r8, r2
    3fb2:	d368      	bcc.n	4086 <lv_disp_refr_task+0x10e>
    if(disp_refr->inv_p != 0) {
    3fb4:	b1f2      	cbz	r2, 3ff4 <lv_disp_refr_task+0x7c>
        if(lv_disp_is_true_double_buf(disp_refr)) {
    3fb6:	4638      	mov	r0, r7
    3fb8:	f006 f931 	bl	a21e <lv_disp_is_true_double_buf>
    3fbc:	2800      	cmp	r0, #0
    3fbe:	f040 811a 	bne.w	41f6 <lv_disp_refr_task+0x27e>
        memset(disp_refr->inv_areas, 0, sizeof(disp_refr->inv_areas));
    3fc2:	6820      	ldr	r0, [r4, #0]
    3fc4:	f44f 7280 	mov.w	r2, #256	; 0x100
    3fc8:	2100      	movs	r1, #0
    3fca:	3040      	adds	r0, #64	; 0x40
    3fcc:	f004 f898 	bl	8100 <memset>
        memset(disp_refr->inv_area_joined, 0, sizeof(disp_refr->inv_area_joined));
    3fd0:	6820      	ldr	r0, [r4, #0]
    3fd2:	2220      	movs	r2, #32
    3fd4:	2100      	movs	r1, #0
    3fd6:	f500 70a0 	add.w	r0, r0, #320	; 0x140
    3fda:	f004 f891 	bl	8100 <memset>
        disp_refr->inv_p = 0;
    3fde:	6824      	ldr	r4, [r4, #0]
    3fe0:	f8b4 3160 	ldrh.w	r3, [r4, #352]	; 0x160
        if(disp_refr->driver.monitor_cb) {
    3fe4:	69a5      	ldr	r5, [r4, #24]
        disp_refr->inv_p = 0;
    3fe6:	f36f 0309 	bfc	r3, #0, #10
    3fea:	f8a4 3160 	strh.w	r3, [r4, #352]	; 0x160
        if(disp_refr->driver.monitor_cb) {
    3fee:	2d00      	cmp	r5, #0
    3ff0:	f040 8156 	bne.w	42a0 <lv_disp_refr_task+0x328>
    lv_draw_free_buf();
    3ff4:	f000 fcfa 	bl	49ec <lv_draw_free_buf>
}
    3ff8:	b009      	add	sp, #36	; 0x24
    3ffa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(disp_refr->inv_area_joined[join_in] != 0) continue;
    3ffe:	4433      	add	r3, r6
    4000:	f893 5140 	ldrb.w	r5, [r3, #320]	; 0x140
    4004:	b10d      	cbz	r5, 400a <lv_disp_refr_task+0x92>
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
    4006:	3601      	adds	r6, #1
    4008:	e7c1      	b.n	3f8e <lv_disp_refr_task+0x16>
    400a:	00f7      	lsls	r7, r6, #3
    400c:	3740      	adds	r7, #64	; 0x40
                disp_refr->inv_area_joined[join_from] = 1;
    400e:	f04f 0901 	mov.w	r9, #1
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
    4012:	6820      	ldr	r0, [r4, #0]
    4014:	f8b0 3160 	ldrh.w	r3, [r0, #352]	; 0x160
    4018:	f3c3 0309 	ubfx	r3, r3, #0, #10
    401c:	429d      	cmp	r5, r3
    401e:	d2f2      	bcs.n	4006 <lv_disp_refr_task+0x8e>
            if(disp_refr->inv_area_joined[join_from] != 0 || join_in == join_from) {
    4020:	1943      	adds	r3, r0, r5
    4022:	f893 3140 	ldrb.w	r3, [r3, #320]	; 0x140
    4026:	bb63      	cbnz	r3, 4082 <lv_disp_refr_task+0x10a>
    4028:	42ae      	cmp	r6, r5
    402a:	d02a      	beq.n	4082 <lv_disp_refr_task+0x10a>
            if(lv_area_is_on(&disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]) == false) {
    402c:	ea4f 08c5 	mov.w	r8, r5, lsl #3
    4030:	f108 0840 	add.w	r8, r8, #64	; 0x40
    4034:	eb00 0108 	add.w	r1, r0, r8
    4038:	4438      	add	r0, r7
    403a:	f006 f98f 	bl	a35c <lv_area_is_on>
    403e:	b300      	cbz	r0, 4082 <lv_disp_refr_task+0x10a>
            lv_area_join(&joined_area, &disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]);
    4040:	6821      	ldr	r1, [r4, #0]
    4042:	a806      	add	r0, sp, #24
    4044:	eb01 0208 	add.w	r2, r1, r8
    4048:	4439      	add	r1, r7
    404a:	f006 f965 	bl	a318 <lv_area_join>
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
    404e:	a806      	add	r0, sp, #24
    4050:	f006 f92a 	bl	a2a8 <lv_area_get_size>
    4054:	4683      	mov	fp, r0
    4056:	6820      	ldr	r0, [r4, #0]
    4058:	4438      	add	r0, r7
    405a:	f006 f925 	bl	a2a8 <lv_area_get_size>
    405e:	4682      	mov	sl, r0
                                                 lv_area_get_size(&disp_refr->inv_areas[join_from]))) {
    4060:	6820      	ldr	r0, [r4, #0]
    4062:	4440      	add	r0, r8
    4064:	f006 f920 	bl	a2a8 <lv_area_get_size>
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
    4068:	4450      	add	r0, sl
    406a:	4583      	cmp	fp, r0
    406c:	d209      	bcs.n	4082 <lv_disp_refr_task+0x10a>
                lv_area_copy(&disp_refr->inv_areas[join_in], &joined_area);
    406e:	6820      	ldr	r0, [r4, #0]
    4070:	2208      	movs	r2, #8
    4072:	a906      	add	r1, sp, #24
    4074:	4438      	add	r0, r7
    4076:	f004 f819 	bl	80ac <memcpy>
                disp_refr->inv_area_joined[join_from] = 1;
    407a:	6823      	ldr	r3, [r4, #0]
    407c:	442b      	add	r3, r5
    407e:	f883 9140 	strb.w	r9, [r3, #320]	; 0x140
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
    4082:	3501      	adds	r5, #1
    4084:	e7c5      	b.n	4012 <lv_disp_refr_task+0x9a>
        if(disp_refr->inv_area_joined[i] == 0) {
    4086:	eb07 0308 	add.w	r3, r7, r8
    408a:	f893 6140 	ldrb.w	r6, [r3, #320]	; 0x140
    408e:	2e00      	cmp	r6, #0
    4090:	d17a      	bne.n	4188 <lv_disp_refr_task+0x210>
            lv_refr_area(&disp_refr->inv_areas[i]);
    4092:	ea4f 05c8 	mov.w	r5, r8, lsl #3
    4096:	f105 0340 	add.w	r3, r5, #64	; 0x40
    if(lv_disp_is_true_double_buf(disp_refr)) {
    409a:	4638      	mov	r0, r7
    409c:	9301      	str	r3, [sp, #4]
            lv_refr_area(&disp_refr->inv_areas[i]);
    409e:	eb07 0b03 	add.w	fp, r7, r3
    if(lv_disp_is_true_double_buf(disp_refr)) {
    40a2:	f006 f8bc 	bl	a21e <lv_disp_is_true_double_buf>
    40a6:	b198      	cbz	r0, 40d0 <lv_disp_refr_task+0x158>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    40a8:	6820      	ldr	r0, [r4, #0]
    40aa:	f006 f8ae 	bl	a20a <lv_disp_get_buf>
    40ae:	4605      	mov	r5, r0
        vdb->area.x1        = 0;
    40b0:	8206      	strh	r6, [r0, #16]
        vdb->area.x2        = lv_disp_get_hor_res(disp_refr) - 1;
    40b2:	6820      	ldr	r0, [r4, #0]
    40b4:	f001 fa20 	bl	54f8 <lv_disp_get_hor_res>
    40b8:	3801      	subs	r0, #1
    40ba:	82a8      	strh	r0, [r5, #20]
        vdb->area.y1        = 0;
    40bc:	826e      	strh	r6, [r5, #18]
        vdb->area.y2        = lv_disp_get_ver_res(disp_refr) - 1;
    40be:	6820      	ldr	r0, [r4, #0]
    40c0:	f001 fa2a 	bl	5518 <lv_disp_get_ver_res>
    40c4:	3801      	subs	r0, #1
    40c6:	82e8      	strh	r0, [r5, #22]
            lv_refr_area_part(area_p);
    40c8:	4658      	mov	r0, fp
    40ca:	f7ff ff1b 	bl	3f04 <lv_refr_area_part>
    40ce:	e04f      	b.n	4170 <lv_disp_refr_task+0x1f8>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    40d0:	443d      	add	r5, r7
    40d2:	6820      	ldr	r0, [r4, #0]
    40d4:	f006 f899 	bl	a20a <lv_disp_get_buf>
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    40d8:	f8b5 a044 	ldrh.w	sl, [r5, #68]	; 0x44
    40dc:	f8b5 7040 	ldrh.w	r7, [r5, #64]	; 0x40
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    40e0:	f9b5 9046 	ldrsh.w	r9, [r5, #70]	; 0x46
    40e4:	f8b5 3042 	ldrh.w	r3, [r5, #66]	; 0x42
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    40e8:	f10a 0a01 	add.w	sl, sl, #1
    40ec:	ebaa 0a07 	sub.w	sl, sl, r7
    40f0:	4606      	mov	r6, r0
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    40f2:	f109 0701 	add.w	r7, r9, #1
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? y2 = lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
    40f6:	6820      	ldr	r0, [r4, #0]
    40f8:	1aff      	subs	r7, r7, r3
    40fa:	f001 fa0d 	bl	5518 <lv_disp_get_ver_res>
        lv_coord_t y2 =
    40fe:	4581      	cmp	r9, r0
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    4100:	fa0f fa8a 	sxth.w	sl, sl
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    4104:	b23f      	sxth	r7, r7
    4106:	db42      	blt.n	418e <lv_disp_refr_task+0x216>
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? y2 = lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
    4108:	6820      	ldr	r0, [r4, #0]
    410a:	f001 fa05 	bl	5518 <lv_disp_get_ver_res>
    410e:	3801      	subs	r0, #1
    4110:	fa0f f980 	sxth.w	r9, r0
        int32_t max_row = (uint32_t)vdb->size / w;
    4114:	68f3      	ldr	r3, [r6, #12]
    4116:	fbb3 f3fa 	udiv	r3, r3, sl
        if(max_row > h) max_row = h;
    411a:	429f      	cmp	r7, r3
    411c:	bfa8      	it	ge
    411e:	461f      	movge	r7, r3
        if(disp_refr->driver.rounder_cb) {
    4120:	6823      	ldr	r3, [r4, #0]
    4122:	691b      	ldr	r3, [r3, #16]
    4124:	2b00      	cmp	r3, #0
    4126:	d038      	beq.n	419a <lv_disp_refr_task+0x222>
            tmp.x1 = 0;
    4128:	2300      	movs	r3, #0
    412a:	9306      	str	r3, [sp, #24]
            tmp.x2 = 0;
    412c:	f8ad 301c 	strh.w	r3, [sp, #28]
            lv_coord_t h_tmp = max_row;
    4130:	b23b      	sxth	r3, r7
                tmp.y2 = h_tmp - 1;
    4132:	f103 3aff 	add.w	sl, r3, #4294967295	; 0xffffffff
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
    4136:	6820      	ldr	r0, [r4, #0]
                tmp.y2 = h_tmp - 1;
    4138:	9304      	str	r3, [sp, #16]
    413a:	fa0f fa8a 	sxth.w	sl, sl
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
    413e:	6902      	ldr	r2, [r0, #16]
                tmp.y2 = h_tmp - 1;
    4140:	f8ad a01e 	strh.w	sl, [sp, #30]
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
    4144:	a906      	add	r1, sp, #24
    4146:	4790      	blx	r2
    4148:	f9bd 101e 	ldrsh.w	r1, [sp, #30]
    414c:	f8bd 201a 	ldrh.w	r2, [sp, #26]
                if(lv_area_get_height(&tmp) <= max_row) break;
    4150:	9b04      	ldr	r3, [sp, #16]
    4152:	3101      	adds	r1, #1
    4154:	1a8a      	subs	r2, r1, r2
    4156:	b212      	sxth	r2, r2
    4158:	4297      	cmp	r7, r2
    415a:	da1b      	bge.n	4194 <lv_disp_refr_task+0x21c>
            } while(h_tmp > 0);
    415c:	f1ba 0300 	subs.w	r3, sl, #0
    4160:	dce7      	bgt.n	4132 <lv_disp_refr_task+0x1ba>
                LV_LOG_WARN("Can't set VDB height using the round function. (Wrong round_cb or to "
    4162:	4b39      	ldr	r3, [pc, #228]	; (4248 <lv_disp_refr_task+0x2d0>)
    4164:	4939      	ldr	r1, [pc, #228]	; (424c <lv_disp_refr_task+0x2d4>)
    4166:	f240 124f 	movw	r2, #335	; 0x14f
    416a:	2002      	movs	r0, #2
    416c:	f001 fcf0 	bl	5b50 <lv_log_add>
            if(disp_refr->driver.monitor_cb) px_num += lv_area_get_size(&disp_refr->inv_areas[i]);
    4170:	6820      	ldr	r0, [r4, #0]
    4172:	6983      	ldr	r3, [r0, #24]
    4174:	b143      	cbz	r3, 4188 <lv_disp_refr_task+0x210>
    4176:	9b01      	ldr	r3, [sp, #4]
    4178:	4418      	add	r0, r3
    417a:	f006 f895 	bl	a2a8 <lv_area_get_size>
    417e:	9b02      	ldr	r3, [sp, #8]
    4180:	681b      	ldr	r3, [r3, #0]
    4182:	4418      	add	r0, r3
    4184:	9b02      	ldr	r3, [sp, #8]
    4186:	6018      	str	r0, [r3, #0]
    for(i = 0; i < disp_refr->inv_p; i++) {
    4188:	f108 0801 	add.w	r8, r8, #1
    418c:	e70b      	b.n	3fa6 <lv_disp_refr_task+0x2e>
        lv_coord_t y2 =
    418e:	f9b5 9046 	ldrsh.w	r9, [r5, #70]	; 0x46
    4192:	e7bf      	b.n	4114 <lv_disp_refr_task+0x19c>
            if(h_tmp <= 0) {
    4194:	2b00      	cmp	r3, #0
    4196:	dde4      	ble.n	4162 <lv_disp_refr_task+0x1ea>
                max_row = tmp.y2 + 1;
    4198:	460f      	mov	r7, r1
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
    419a:	f9b5 3042 	ldrsh.w	r3, [r5, #66]	; 0x42
        lv_coord_t row_last = 0;
    419e:	f04f 0a00 	mov.w	sl, #0
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
    41a2:	1e7a      	subs	r2, r7, #1
    41a4:	18d1      	adds	r1, r2, r3
    41a6:	4549      	cmp	r1, r9
    41a8:	dd0b      	ble.n	41c2 <lv_disp_refr_task+0x24a>
        if(y2 != row_last) {
    41aa:	45d1      	cmp	r9, sl
    41ac:	d0e0      	beq.n	4170 <lv_disp_refr_task+0x1f8>
            vdb->area.x1 = area_p->x1;
    41ae:	f9b5 2040 	ldrsh.w	r2, [r5, #64]	; 0x40
    41b2:	8232      	strh	r2, [r6, #16]
            vdb->area.x2 = area_p->x2;
    41b4:	f9b5 2044 	ldrsh.w	r2, [r5, #68]	; 0x44
    41b8:	82b2      	strh	r2, [r6, #20]
            vdb->area.y1 = row;
    41ba:	8273      	strh	r3, [r6, #18]
            vdb->area.y2 = y2;
    41bc:	f8a6 9016 	strh.w	r9, [r6, #22]
    41c0:	e782      	b.n	40c8 <lv_disp_refr_task+0x150>
            vdb->area.x1 = area_p->x1;
    41c2:	f9b5 1040 	ldrsh.w	r1, [r5, #64]	; 0x40
    41c6:	8231      	strh	r1, [r6, #16]
            vdb->area.x2 = area_p->x2;
    41c8:	f9b5 1044 	ldrsh.w	r1, [r5, #68]	; 0x44
            vdb->area.y1 = row;
    41cc:	8273      	strh	r3, [r6, #18]
            vdb->area.y2 = row + max_row - 1;
    41ce:	443b      	add	r3, r7
    41d0:	b21b      	sxth	r3, r3
    41d2:	f103 3aff 	add.w	sl, r3, #4294967295	; 0xffffffff
    41d6:	fa0f fa8a 	sxth.w	sl, sl
    41da:	45ca      	cmp	sl, r9
    41dc:	bfa8      	it	ge
    41de:	46ca      	movge	sl, r9
            vdb->area.x2 = area_p->x2;
    41e0:	82b1      	strh	r1, [r6, #20]
            vdb->area.y2 = row + max_row - 1;
    41e2:	f8a6 a016 	strh.w	sl, [r6, #22]
            lv_refr_area_part(area_p);
    41e6:	4658      	mov	r0, fp
    41e8:	9205      	str	r2, [sp, #20]
    41ea:	9304      	str	r3, [sp, #16]
    41ec:	f7ff fe8a 	bl	3f04 <lv_refr_area_part>
    41f0:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
    41f4:	e7d6      	b.n	41a4 <lv_disp_refr_task+0x22c>
            lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    41f6:	6820      	ldr	r0, [r4, #0]
    41f8:	f006 f807 	bl	a20a <lv_disp_get_buf>
    41fc:	4605      	mov	r5, r0
            lv_refr_vdb_flush();
    41fe:	f7ff fe31 	bl	3e64 <lv_refr_vdb_flush>
            while(vdb->flushing)
    4202:	69ab      	ldr	r3, [r5, #24]
    4204:	07db      	lsls	r3, r3, #31
    4206:	d4fc      	bmi.n	4202 <lv_disp_refr_task+0x28a>
            uint8_t * buf_ina = (uint8_t *)vdb->buf_act == vdb->buf1 ? vdb->buf2 : vdb->buf1;
    4208:	f8d5 9000 	ldr.w	r9, [r5]
            uint8_t * buf_act = (uint8_t *)vdb->buf_act;
    420c:	f8d5 b008 	ldr.w	fp, [r5, #8]
            lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
    4210:	6820      	ldr	r0, [r4, #0]
            uint8_t * buf_ina = (uint8_t *)vdb->buf_act == vdb->buf1 ? vdb->buf2 : vdb->buf1;
    4212:	45d9      	cmp	r9, fp
    4214:	bf08      	it	eq
    4216:	f8d5 9004 	ldreq.w	r9, [r5, #4]
            lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
    421a:	f001 f96d 	bl	54f8 <lv_disp_get_hor_res>
            for(a = 0; a < disp_refr->inv_p; a++) {
    421e:	2600      	movs	r6, #0
            lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
    4220:	4603      	mov	r3, r0
            for(a = 0; a < disp_refr->inv_p; a++) {
    4222:	6822      	ldr	r2, [r4, #0]
    4224:	f8b2 1160 	ldrh.w	r1, [r2, #352]	; 0x160
    4228:	b2b0      	uxth	r0, r6
    422a:	f3c1 0109 	ubfx	r1, r1, #0, #10
    422e:	4281      	cmp	r1, r0
    4230:	f67f aec7 	bls.w	3fc2 <lv_disp_refr_task+0x4a>
                if(disp_refr->inv_area_joined[a] == 0) {
    4234:	1991      	adds	r1, r2, r6
    4236:	f891 1140 	ldrb.w	r1, [r1, #320]	; 0x140
    423a:	b149      	cbz	r1, 4250 <lv_disp_refr_task+0x2d8>
    423c:	3601      	adds	r6, #1
    423e:	e7f0      	b.n	4222 <lv_disp_refr_task+0x2aa>
    4240:	200009f8 	.word	0x200009f8
    4244:	200009fc 	.word	0x200009fc
    4248:	0000c297 	.word	0x0000c297
    424c:	0000c2e7 	.word	0x0000c2e7
                    uint32_t start_offs =
    4250:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
    4254:	f106 0a08 	add.w	sl, r6, #8
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    4258:	f8b2 5044 	ldrh.w	r5, [r2, #68]	; 0x44
                        (hres * disp_refr->inv_areas[a].y1 + disp_refr->inv_areas[a].x1) * sizeof(lv_color_t);
    425c:	f9b2 1040 	ldrsh.w	r1, [r2, #64]	; 0x40
    4260:	f9b2 7042 	ldrsh.w	r7, [r2, #66]	; 0x42
    4264:	3501      	adds	r5, #1
    4266:	1a6d      	subs	r5, r5, r1
    4268:	fb03 1807 	mla	r8, r3, r7, r1
                    uint32_t line_length = lv_area_get_width(&disp_refr->inv_areas[a]) * sizeof(lv_color_t);
    426c:	b22d      	sxth	r5, r5
                    uint32_t start_offs =
    426e:	ea4f 0888 	mov.w	r8, r8, lsl #2
                    uint32_t line_length = lv_area_get_width(&disp_refr->inv_areas[a]) * sizeof(lv_color_t);
    4272:	00ad      	lsls	r5, r5, #2
                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
    4274:	ea4f 0aca 	mov.w	sl, sl, lsl #3
    4278:	6822      	ldr	r2, [r4, #0]
    427a:	4452      	add	r2, sl
    427c:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
    4280:	42ba      	cmp	r2, r7
    4282:	dbdb      	blt.n	423c <lv_disp_refr_task+0x2c4>
                        memcpy(buf_act + start_offs, buf_ina + start_offs, line_length);
    4284:	eb09 0108 	add.w	r1, r9, r8
    4288:	eb0b 0008 	add.w	r0, fp, r8
    428c:	462a      	mov	r2, r5
    428e:	9301      	str	r3, [sp, #4]
    4290:	f003 ff0c 	bl	80ac <memcpy>
                        start_offs += hres * sizeof(lv_color_t);
    4294:	9b01      	ldr	r3, [sp, #4]
                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
    4296:	3701      	adds	r7, #1
                        start_offs += hres * sizeof(lv_color_t);
    4298:	eb08 0883 	add.w	r8, r8, r3, lsl #2
                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
    429c:	b23f      	sxth	r7, r7
    429e:	e7eb      	b.n	4278 <lv_disp_refr_task+0x300>
            disp_refr->driver.monitor_cb(&disp_refr->driver, lv_tick_elaps(start), px_num);
    42a0:	9803      	ldr	r0, [sp, #12]
    42a2:	f005 ffcf 	bl	a244 <lv_tick_elaps>
    42a6:	4b03      	ldr	r3, [pc, #12]	; (42b4 <lv_disp_refr_task+0x33c>)
    42a8:	4601      	mov	r1, r0
    42aa:	681a      	ldr	r2, [r3, #0]
    42ac:	4620      	mov	r0, r4
    42ae:	47a8      	blx	r5
    42b0:	e6a0      	b.n	3ff4 <lv_disp_refr_task+0x7c>
    42b2:	bf00      	nop
    42b4:	200009fc 	.word	0x200009fc

000042b8 <lv_style_init>:
{
    /* Not White/Black/Gray colors are created by HSV model with
     * HUE = 210*/

    /*Screen style*/
    lv_style_scr.glass               = 0;
    42b8:	4977      	ldr	r1, [pc, #476]	; (4498 <lv_style_init+0x1e0>)
{
    42ba:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    lv_style_scr.glass               = 0;
    42be:	780b      	ldrb	r3, [r1, #0]
    lv_style_scr.body.shadow.type  = LV_SHADOW_FULL;
    lv_style_scr.body.shadow.width = 0;

    lv_style_scr.text.opa          = LV_OPA_COVER;
    lv_style_scr.text.color        = lv_color_make(0x30, 0x30, 0x30);
    lv_style_scr.text.sel_color    = lv_color_make(0x55, 0x96, 0xd8);
    42c0:	4c76      	ldr	r4, [pc, #472]	; (449c <lv_style_init+0x1e4>)
    lv_style_scr.debug_sentinel = LV_STYLE_DEGUG_SENTINEL_VALUE;
#endif
#endif

    /*Plain style (by default near the same as the screen style)*/
    lv_style_copy(&lv_style_plain, &lv_style_scr);
    42c2:	4e77      	ldr	r6, [pc, #476]	; (44a0 <lv_style_init+0x1e8>)
    lv_style_scr.image.color   = lv_color_make(0x20, 0x20, 0x20);
    42c4:	4f77      	ldr	r7, [pc, #476]	; (44a4 <lv_style_init+0x1ec>)
    lv_style_scr.body.shadow.color = LV_COLOR_GRAY;
    42c6:	f8df 925c 	ldr.w	r9, [pc, #604]	; 4524 <lv_style_init+0x26c>
    lv_style_plain.body.padding.right  = LV_DPI / 20;
    lv_style_plain.body.padding.top    = LV_DPI / 20;
    lv_style_plain.body.padding.bottom = LV_DPI / 20;

    /*Plain color style*/
    lv_style_copy(&lv_style_plain_color, &lv_style_plain);
    42ca:	f8df a25c 	ldr.w	sl, [pc, #604]	; 4528 <lv_style_init+0x270>
    lv_style_scr.image.color   = lv_color_make(0x20, 0x20, 0x20);
    42ce:	640f      	str	r7, [r1, #64]	; 0x40
    lv_style_scr.glass               = 0;
    42d0:	f36f 0300 	bfc	r3, #0, #1
    42d4:	700b      	strb	r3, [r1, #0]
    lv_style_scr.body.padding.inner  = LV_DPI / 20;
    42d6:	2305      	movs	r3, #5
    42d8:	850b      	strh	r3, [r1, #40]	; 0x28
    lv_style_scr.body.border.color = LV_COLOR_BLACK;
    42da:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
    42de:	610b      	str	r3, [r1, #16]
    lv_style_scr.body.border.width = 0;
    42e0:	f503 2370 	add.w	r3, r3, #983040	; 0xf0000
    42e4:	614b      	str	r3, [r1, #20]
    lv_style_scr.body.shadow.type  = LV_SHADOW_FULL;
    42e6:	2301      	movs	r3, #1
    42e8:	778b      	strb	r3, [r1, #30]
    lv_style_scr.text.sel_color    = lv_color_make(0x55, 0x96, 0xd8);
    42ea:	4b6f      	ldr	r3, [pc, #444]	; (44a8 <lv_style_init+0x1f0>)
    lv_style_scr.line.color   = lv_color_make(0x20, 0x20, 0x20);
    42ec:	648f      	str	r7, [r1, #72]	; 0x48
    lv_style_scr.text.sel_color    = lv_color_make(0x55, 0x96, 0xd8);
    42ee:	e9c1 340b 	strd	r3, r4, [r1, #44]	; 0x2c
    lv_style_scr.text.font         = LV_FONT_DEFAULT;
    42f2:	4b6e      	ldr	r3, [pc, #440]	; (44ac <lv_style_init+0x1f4>)
    42f4:	634b      	str	r3, [r1, #52]	; 0x34
    lv_style_scr.text.letter_space = 0;
    42f6:	f44f 3300 	mov.w	r3, #131072	; 0x20000
    42fa:	638b      	str	r3, [r1, #56]	; 0x38
    lv_style_scr.text.opa          = LV_OPA_COVER;
    42fc:	23ff      	movs	r3, #255	; 0xff
    42fe:	f881 303c 	strb.w	r3, [r1, #60]	; 0x3c
    lv_style_scr.image.intense = LV_OPA_TRANSP;
    4302:	f44f 437f 	mov.w	r3, #65280	; 0xff00
    4306:	f8a1 3044 	strh.w	r3, [r1, #68]	; 0x44
    lv_style_scr.line.width   = 2;
    430a:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
    lv_style_scr.body.shadow.color = LV_COLOR_GRAY;
    430c:	f8c1 9018 	str.w	r9, [r1, #24]
    lv_style_scr.line.width   = 2;
    4310:	f003 437e 	and.w	r3, r3, #4261412864	; 0xfe000000
    4314:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
    lv_style_scr.body.radius         = 0;
    4318:	2500      	movs	r5, #0
    lv_style_scr.body.main_color     = LV_COLOR_WHITE;
    431a:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    lv_style_scr.line.width   = 2;
    431e:	f043 0302 	orr.w	r3, r3, #2
    lv_style_scr.body.grad_color     = LV_COLOR_WHITE;
    4322:	e9c1 8801 	strd	r8, r8, [r1, #4]
    lv_style_scr.body.padding.left   = 0;
    4326:	e9c1 5508 	strd	r5, r5, [r1, #32]
    lv_style_scr.line.width   = 2;
    432a:	64cb      	str	r3, [r1, #76]	; 0x4c
    lv_style_copy(&lv_style_plain, &lv_style_scr);
    432c:	4630      	mov	r0, r6
    lv_style_scr.body.radius         = 0;
    432e:	818d      	strh	r5, [r1, #12]
    lv_style_scr.body.opa            = LV_OPA_COVER;
    4330:	f881 800e 	strb.w	r8, [r1, #14]
    lv_style_scr.body.shadow.width = 0;
    4334:	838d      	strh	r5, [r1, #28]
    lv_style_copy(&lv_style_plain, &lv_style_scr);
    4336:	f004 ff71 	bl	921c <lv_style_copy>
    lv_style_plain.body.padding.top    = LV_DPI / 20;
    433a:	f04f 1305 	mov.w	r3, #327685	; 0x50005
    lv_style_plain.body.padding.left   = LV_DPI / 20;
    433e:	e9c6 3308 	strd	r3, r3, [r6, #32]
    lv_style_copy(&lv_style_plain_color, &lv_style_plain);
    4342:	4631      	mov	r1, r6
    4344:	4650      	mov	r0, sl
    4346:	f004 ff69 	bl	921c <lv_style_copy>
    lv_style_plain_color.text.color      = lv_color_make(0xf0, 0xf0, 0xf0);
    lv_style_plain_color.image.color     = lv_color_make(0xf0, 0xf0, 0xf0);
    lv_style_plain_color.line.color      = lv_color_make(0xf0, 0xf0, 0xf0);
    lv_style_plain_color.body.main_color = lv_color_make(0x55, 0x96, 0xd8);
    lv_style_plain_color.body.grad_color = lv_style_plain_color.body.main_color;
    434a:	e9ca 4401 	strd	r4, r4, [sl, #4]

    /*Pretty style */
    lv_style_copy(&lv_style_pretty, &lv_style_plain);
    434e:	4c58      	ldr	r4, [pc, #352]	; (44b0 <lv_style_init+0x1f8>)
    lv_style_plain_color.text.color      = lv_color_make(0xf0, 0xf0, 0xf0);
    4350:	4b58      	ldr	r3, [pc, #352]	; (44b4 <lv_style_init+0x1fc>)
    4352:	f8ca 302c 	str.w	r3, [sl, #44]	; 0x2c
    lv_style_plain_color.image.color     = lv_color_make(0xf0, 0xf0, 0xf0);
    4356:	f8ca 3040 	str.w	r3, [sl, #64]	; 0x40
    lv_style_plain_color.line.color      = lv_color_make(0xf0, 0xf0, 0xf0);
    435a:	f8ca 3048 	str.w	r3, [sl, #72]	; 0x48
    lv_style_copy(&lv_style_pretty, &lv_style_plain);
    435e:	4631      	mov	r1, r6
    4360:	4620      	mov	r0, r4
    4362:	f004 ff5b 	bl	921c <lv_style_copy>
    lv_style_pretty.text.color        = lv_color_make(0x20, 0x20, 0x20);
    4366:	62e7      	str	r7, [r4, #44]	; 0x2c
    lv_style_pretty.image.color       = lv_color_make(0x20, 0x20, 0x20);
    4368:	6427      	str	r7, [r4, #64]	; 0x40
    lv_style_pretty.line.color        = lv_color_make(0x20, 0x20, 0x20);
    436a:	64a7      	str	r7, [r4, #72]	; 0x48
    lv_style_pretty.body.border.color = lv_color_make(0x40, 0x40, 0x40);
    lv_style_pretty.body.border.width = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
    lv_style_pretty.body.border.opa   = LV_OPA_30;

    /*Pretty color style*/
    lv_style_copy(&lv_style_pretty_color, &lv_style_pretty);
    436c:	4f52      	ldr	r7, [pc, #328]	; (44b8 <lv_style_init+0x200>)
    lv_style_pretty.body.grad_color   = LV_COLOR_SILVER;
    436e:	4b53      	ldr	r3, [pc, #332]	; (44bc <lv_style_init+0x204>)
    lv_style_pretty.body.border.color = lv_color_make(0x40, 0x40, 0x40);
    4370:	4a53      	ldr	r2, [pc, #332]	; (44c0 <lv_style_init+0x208>)
    lv_style_pretty.body.main_color   = LV_COLOR_WHITE;
    4372:	f8c4 8004 	str.w	r8, [r4, #4]
    lv_style_pretty.body.grad_color   = LV_COLOR_SILVER;
    4376:	60a3      	str	r3, [r4, #8]
    lv_style_pretty.body.border.color = lv_color_make(0x40, 0x40, 0x40);
    4378:	6122      	str	r2, [r4, #16]
    lv_style_copy(&lv_style_pretty_color, &lv_style_pretty);
    437a:	4621      	mov	r1, r4
    lv_style_pretty.body.border.opa   = LV_OPA_30;
    437c:	224c      	movs	r2, #76	; 0x4c
    lv_style_copy(&lv_style_pretty_color, &lv_style_pretty);
    437e:	4638      	mov	r0, r7
    lv_style_pretty.body.radius       = LV_DPI / 15;
    4380:	f04f 0b06 	mov.w	fp, #6
    lv_style_pretty.body.border.width = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
    4384:	f04f 0a02 	mov.w	sl, #2
    lv_style_pretty.body.border.opa   = LV_OPA_30;
    4388:	75e2      	strb	r2, [r4, #23]
    lv_style_pretty.body.radius       = LV_DPI / 15;
    438a:	f8a4 b00c 	strh.w	fp, [r4, #12]
    lv_style_pretty.body.border.width = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
    438e:	f8a4 a014 	strh.w	sl, [r4, #20]
    lv_style_copy(&lv_style_pretty_color, &lv_style_pretty);
    4392:	f004 ff43 	bl	921c <lv_style_copy>
    lv_style_pretty_color.text.color        = lv_color_make(0xe0, 0xe0, 0xe0);
    lv_style_pretty_color.image.color       = lv_color_make(0xe0, 0xe0, 0xe0);
    lv_style_pretty_color.line.color        = lv_color_make(0xc0, 0xc0, 0xc0);
    4396:	4b49      	ldr	r3, [pc, #292]	; (44bc <lv_style_init+0x204>)
    4398:	64bb      	str	r3, [r7, #72]	; 0x48
    lv_style_pretty_color.body.main_color   = lv_color_make(0x6b, 0x9a, 0xc7);
    lv_style_pretty_color.body.grad_color   = lv_color_make(0x2b, 0x59, 0x8b);
    439a:	494a      	ldr	r1, [pc, #296]	; (44c4 <lv_style_init+0x20c>)
    439c:	4b4a      	ldr	r3, [pc, #296]	; (44c8 <lv_style_init+0x210>)
    lv_style_pretty_color.body.border.color = lv_color_make(0x15, 0x2c, 0x42);

    /*Transparent style*/
    lv_style_copy(&lv_style_transp, &lv_style_plain);
    439e:	4c4b      	ldr	r4, [pc, #300]	; (44cc <lv_style_init+0x214>)
    lv_style_pretty_color.text.color        = lv_color_make(0xe0, 0xe0, 0xe0);
    43a0:	4a4b      	ldr	r2, [pc, #300]	; (44d0 <lv_style_init+0x218>)
    43a2:	62fa      	str	r2, [r7, #44]	; 0x2c
    lv_style_pretty_color.body.grad_color   = lv_color_make(0x2b, 0x59, 0x8b);
    43a4:	e9c7 1301 	strd	r1, r3, [r7, #4]
    lv_style_pretty_color.body.border.color = lv_color_make(0x15, 0x2c, 0x42);
    43a8:	f5a3 13b1 	sub.w	r3, r3, #1449984	; 0x162000
    43ac:	f6a3 5349 	subw	r3, r3, #3401	; 0xd49
    lv_style_pretty_color.image.color       = lv_color_make(0xe0, 0xe0, 0xe0);
    43b0:	643a      	str	r2, [r7, #64]	; 0x40
    lv_style_pretty_color.body.border.color = lv_color_make(0x15, 0x2c, 0x42);
    43b2:	613b      	str	r3, [r7, #16]
    lv_style_copy(&lv_style_transp, &lv_style_plain);
    43b4:	4631      	mov	r1, r6
    43b6:	4620      	mov	r0, r4
    43b8:	f004 ff30 	bl	921c <lv_style_copy>
    lv_style_transp.glass             = 1;
    43bc:	7823      	ldrb	r3, [r4, #0]
    lv_style_transp.body.border.width = 0;
    lv_style_transp.body.opa          = LV_OPA_TRANSP;

    /*Transparent fitting size*/
    lv_style_copy(&lv_style_transp_fit, &lv_style_transp);
    43be:	4f45      	ldr	r7, [pc, #276]	; (44d4 <lv_style_init+0x21c>)
    lv_style_transp.body.border.width = 0;
    43c0:	82a5      	strh	r5, [r4, #20]
    lv_style_transp.glass             = 1;
    43c2:	f043 0301 	orr.w	r3, r3, #1
    43c6:	7023      	strb	r3, [r4, #0]
    lv_style_transp.body.opa          = LV_OPA_TRANSP;
    43c8:	73a5      	strb	r5, [r4, #14]
    lv_style_copy(&lv_style_transp_fit, &lv_style_transp);
    43ca:	4621      	mov	r1, r4
    lv_style_transp_fit.body.padding.right  = 0;
    lv_style_transp_fit.body.padding.top    = 0;
    lv_style_transp_fit.body.padding.bottom = 0;

    /*Transparent tight style*/
    lv_style_copy(&lv_style_transp_tight, &lv_style_transp_fit);
    43cc:	4c42      	ldr	r4, [pc, #264]	; (44d8 <lv_style_init+0x220>)
    lv_style_copy(&lv_style_transp_fit, &lv_style_transp);
    43ce:	4638      	mov	r0, r7
    43d0:	f004 ff24 	bl	921c <lv_style_copy>
    lv_style_transp_fit.body.padding.left   = 0;
    43d4:	e9c7 5508 	strd	r5, r5, [r7, #32]
    lv_style_copy(&lv_style_transp_tight, &lv_style_transp_fit);
    43d8:	4639      	mov	r1, r7
    43da:	4620      	mov	r0, r4
    43dc:	f004 ff1e 	bl	921c <lv_style_copy>
    lv_style_transp_tight.body.padding.inner = 0;
    43e0:	8525      	strh	r5, [r4, #40]	; 0x28

    /*Button released style*/
    lv_style_copy(&lv_style_btn_rel, &lv_style_plain);
    43e2:	4c3e      	ldr	r4, [pc, #248]	; (44dc <lv_style_init+0x224>)
    lv_style_btn_rel.image.color         = lv_color_make(0xff, 0xff, 0xff);

    /*Button pressed style*/
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
    lv_style_btn_pr.body.main_color = lv_color_make(0x33, 0x62, 0x94);
    lv_style_btn_pr.body.grad_color = lv_color_make(0x10, 0x26, 0x3c);
    43e4:	4f3e      	ldr	r7, [pc, #248]	; (44e0 <lv_style_init+0x228>)
    lv_style_copy(&lv_style_btn_rel, &lv_style_plain);
    43e6:	4631      	mov	r1, r6
    43e8:	4620      	mov	r0, r4
    43ea:	f004 ff17 	bl	921c <lv_style_copy>
    lv_style_btn_rel.body.grad_color     = lv_color_make(0x19, 0x3a, 0x5d);
    43ee:	483d      	ldr	r0, [pc, #244]	; (44e4 <lv_style_init+0x22c>)
    43f0:	4b3d      	ldr	r3, [pc, #244]	; (44e8 <lv_style_init+0x230>)
    lv_style_btn_rel.body.shadow.width   = 0;
    43f2:	83a5      	strh	r5, [r4, #28]
    lv_style_btn_rel.body.grad_color     = lv_color_make(0x19, 0x3a, 0x5d);
    43f4:	e9c4 0301 	strd	r0, r3, [r4, #4]
    lv_style_btn_rel.body.padding.left   = LV_DPI / 4;
    43f8:	f04f 1610 	mov.w	r6, #1048592	; 0x100010
    43fc:	f04f 1319 	mov.w	r3, #1638425	; 0x190019
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
    4400:	4d3a      	ldr	r5, [pc, #232]	; (44ec <lv_style_init+0x234>)
    lv_style_btn_rel.text.color          = lv_color_make(0xff, 0xff, 0xff);
    4402:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
    lv_style_btn_rel.body.padding.left   = LV_DPI / 4;
    4406:	e9c4 6308 	strd	r6, r3, [r4, #32]
    lv_style_btn_rel.body.padding.inner  = LV_DPI / 10;
    440a:	230a      	movs	r3, #10
    440c:	8523      	strh	r3, [r4, #40]	; 0x28
    lv_style_btn_rel.body.border.color   = lv_color_make(0x0b, 0x19, 0x28);
    440e:	4b38      	ldr	r3, [pc, #224]	; (44f0 <lv_style_init+0x238>)
    4410:	6123      	str	r3, [r4, #16]
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
    4412:	4628      	mov	r0, r5
    lv_style_btn_rel.body.border.opa     = LV_OPA_70;
    4414:	23b2      	movs	r3, #178	; 0xb2
    lv_style_btn_rel.image.color         = lv_color_make(0xff, 0xff, 0xff);
    4416:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
    441a:	4621      	mov	r1, r4
    lv_style_btn_rel.body.shadow.color   = LV_COLOR_GRAY;
    441c:	f8c4 9018 	str.w	r9, [r4, #24]
    lv_style_btn_rel.body.border.opa     = LV_OPA_70;
    4420:	75e3      	strb	r3, [r4, #23]
    lv_style_btn_rel.body.radius         = LV_DPI / 15;
    4422:	f8a4 b00c 	strh.w	fp, [r4, #12]
    lv_style_btn_rel.body.border.width   = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
    4426:	f8a4 a014 	strh.w	sl, [r4, #20]
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
    442a:	f004 fef7 	bl	921c <lv_style_copy>
    lv_style_btn_pr.body.grad_color = lv_color_make(0x10, 0x26, 0x3c);
    442e:	4b31      	ldr	r3, [pc, #196]	; (44f4 <lv_style_init+0x23c>)
    lv_style_btn_tgl_rel.text.color        = lv_color_make(0xc8, 0xdd, 0xf4);
    lv_style_btn_tgl_rel.image.color       = lv_color_make(0xc8, 0xdd, 0xf4);
    lv_style_btn_tgl_rel.line.color        = lv_color_make(0xc8, 0xdd, 0xf4);

    /*Button toggle pressed style*/
    lv_style_copy(&lv_style_btn_tgl_pr, &lv_style_btn_tgl_rel);
    4430:	4e31      	ldr	r6, [pc, #196]	; (44f8 <lv_style_init+0x240>)
    lv_style_btn_tgl_pr.body.main_color = lv_color_make(0x02, 0x14, 0x27);
    lv_style_btn_tgl_pr.body.grad_color = lv_color_make(0x2b, 0x4c, 0x70);
    4432:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 452c <lv_style_init+0x274>
    lv_style_btn_pr.body.grad_color = lv_color_make(0x10, 0x26, 0x3c);
    4436:	e9c5 7301 	strd	r7, r3, [r5, #4]
    lv_style_btn_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
    443a:	4f30      	ldr	r7, [pc, #192]	; (44fc <lv_style_init+0x244>)
    443c:	62ef      	str	r7, [r5, #44]	; 0x2c
    lv_style_btn_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
    443e:	642f      	str	r7, [r5, #64]	; 0x40
    lv_style_btn_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);
    4440:	64af      	str	r7, [r5, #72]	; 0x48
    lv_style_copy(&lv_style_btn_tgl_rel, &lv_style_btn_rel);
    4442:	4d2f      	ldr	r5, [pc, #188]	; (4500 <lv_style_init+0x248>)
    4444:	4621      	mov	r1, r4
    4446:	4628      	mov	r0, r5
    4448:	f004 fee8 	bl	921c <lv_style_copy>
    lv_style_btn_tgl_rel.body.grad_color   = lv_color_make(0x37, 0x62, 0x90);
    444c:	f8df c0e0 	ldr.w	ip, [pc, #224]	; 4530 <lv_style_init+0x278>
    4450:	4b2c      	ldr	r3, [pc, #176]	; (4504 <lv_style_init+0x24c>)
    4452:	e9c5 c301 	strd	ip, r3, [r5, #4]
    lv_style_btn_tgl_rel.body.border.color = lv_color_make(0x01, 0x07, 0x0d);
    4456:	4b2c      	ldr	r3, [pc, #176]	; (4508 <lv_style_init+0x250>)
    4458:	612b      	str	r3, [r5, #16]
    lv_style_btn_tgl_rel.text.color        = lv_color_make(0xc8, 0xdd, 0xf4);
    445a:	4b2c      	ldr	r3, [pc, #176]	; (450c <lv_style_init+0x254>)
    445c:	62eb      	str	r3, [r5, #44]	; 0x2c
    lv_style_btn_tgl_rel.image.color       = lv_color_make(0xc8, 0xdd, 0xf4);
    445e:	642b      	str	r3, [r5, #64]	; 0x40
    lv_style_btn_tgl_rel.line.color        = lv_color_make(0xc8, 0xdd, 0xf4);
    4460:	64ab      	str	r3, [r5, #72]	; 0x48
    lv_style_copy(&lv_style_btn_tgl_pr, &lv_style_btn_tgl_rel);
    4462:	4629      	mov	r1, r5
    4464:	4630      	mov	r0, r6
    4466:	f004 fed9 	bl	921c <lv_style_copy>
    lv_style_btn_tgl_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
    lv_style_btn_tgl_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
    lv_style_btn_tgl_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);

    /*Button inactive style*/
    lv_style_copy(&lv_style_btn_ina, &lv_style_btn_rel);
    446a:	4d29      	ldr	r5, [pc, #164]	; (4510 <lv_style_init+0x258>)
    lv_style_btn_tgl_pr.body.grad_color = lv_color_make(0x2b, 0x4c, 0x70);
    446c:	4b29      	ldr	r3, [pc, #164]	; (4514 <lv_style_init+0x25c>)
    lv_style_btn_tgl_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
    446e:	62f7      	str	r7, [r6, #44]	; 0x2c
    lv_style_btn_tgl_pr.body.grad_color = lv_color_make(0x2b, 0x4c, 0x70);
    4470:	e9c6 8301 	strd	r8, r3, [r6, #4]
    lv_style_btn_tgl_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
    4474:	6437      	str	r7, [r6, #64]	; 0x40
    lv_style_btn_tgl_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);
    4476:	64b7      	str	r7, [r6, #72]	; 0x48
    lv_style_copy(&lv_style_btn_ina, &lv_style_btn_rel);
    4478:	4621      	mov	r1, r4
    447a:	4628      	mov	r0, r5
    447c:	f004 fece 	bl	921c <lv_style_copy>
    lv_style_btn_ina.body.main_color   = lv_color_make(0xd8, 0xd8, 0xd8);
    4480:	4b25      	ldr	r3, [pc, #148]	; (4518 <lv_style_init+0x260>)
    lv_style_btn_ina.body.grad_color   = lv_color_make(0xd8, 0xd8, 0xd8);
    4482:	e9c5 3301 	strd	r3, r3, [r5, #4]
    lv_style_btn_ina.body.border.color = lv_color_make(0x90, 0x90, 0x90);
    4486:	4b25      	ldr	r3, [pc, #148]	; (451c <lv_style_init+0x264>)
    4488:	612b      	str	r3, [r5, #16]
    lv_style_btn_ina.text.color        = lv_color_make(0x70, 0x70, 0x70);
    448a:	4b25      	ldr	r3, [pc, #148]	; (4520 <lv_style_init+0x268>)
    448c:	62eb      	str	r3, [r5, #44]	; 0x2c
    lv_style_btn_ina.image.color       = lv_color_make(0x70, 0x70, 0x70);
    448e:	642b      	str	r3, [r5, #64]	; 0x40
    lv_style_btn_ina.line.color        = lv_color_make(0x70, 0x70, 0x70);
    4490:	64ab      	str	r3, [r5, #72]	; 0x48
}
    4492:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4496:	bf00      	nop
    4498:	20000cd0 	.word	0x20000cd0
    449c:	ff5596d8 	.word	0xff5596d8
    44a0:	20000b90 	.word	0x20000b90
    44a4:	ff202020 	.word	0xff202020
    44a8:	ff303030 	.word	0xff303030
    44ac:	200068ec 	.word	0x200068ec
    44b0:	20000c30 	.word	0x20000c30
    44b4:	fff0f0f0 	.word	0xfff0f0f0
    44b8:	20000c80 	.word	0x20000c80
    44bc:	ffc0c0c0 	.word	0xffc0c0c0
    44c0:	ff404040 	.word	0xff404040
    44c4:	ff6b9ac7 	.word	0xff6b9ac7
    44c8:	ff2b598b 	.word	0xff2b598b
    44cc:	20000d20 	.word	0x20000d20
    44d0:	ffe0e0e0 	.word	0xffe0e0e0
    44d4:	20000d70 	.word	0x20000d70
    44d8:	20000dc0 	.word	0x20000dc0
    44dc:	20000aa0 	.word	0x20000aa0
    44e0:	ff336294 	.word	0xff336294
    44e4:	ff76a2d0 	.word	0xff76a2d0
    44e8:	ff193a5d 	.word	0xff193a5d
    44ec:	20000a50 	.word	0x20000a50
    44f0:	ff0b1928 	.word	0xff0b1928
    44f4:	ff10263c 	.word	0xff10263c
    44f8:	20000af0 	.word	0x20000af0
    44fc:	ffa4b5c6 	.word	0xffa4b5c6
    4500:	20000b40 	.word	0x20000b40
    4504:	ff376290 	.word	0xff376290
    4508:	ff01070d 	.word	0xff01070d
    450c:	ffc8ddf4 	.word	0xffc8ddf4
    4510:	20000a00 	.word	0x20000a00
    4514:	ff2b4c70 	.word	0xff2b4c70
    4518:	ffd8d8d8 	.word	0xffd8d8d8
    451c:	ff909090 	.word	0xff909090
    4520:	ff707070 	.word	0xff707070
    4524:	ff808080 	.word	0xff808080
    4528:	20000be0 	.word	0x20000be0
    452c:	ff021427 	.word	0xff021427
    4530:	ff0a1122 	.word	0xff0a1122

00004534 <lv_draw_letter>:
 * @param color color of letter
 * @param opa opacity of letter (0..255)
 */
void lv_draw_letter(const lv_point_t * pos_p, const lv_area_t * mask_p, const lv_font_t * font_p, uint32_t letter,
                    lv_color_t color, lv_opa_t opa)
{
    4534:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4538:	b0a3      	sub	sp, #140	; 0x8c
    453a:	469a      	mov	sl, r3
    453c:	f89d 30b4 	ldrb.w	r3, [sp, #180]	; 0xb4
    4540:	9308      	str	r3, [sp, #32]
    /*clang-format off*/
    const uint8_t bpp1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
    4542:	f44f 437f 	mov.w	r3, #65280	; 0xff00
    4546:	f8ad 3064 	strh.w	r3, [sp, #100]	; 0x64
    const uint8_t bpp2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
    454a:	f5a3 03ad 	sub.w	r3, r3, #5668864	; 0x568000
    454e:	f5a3 5328 	sub.w	r3, r3, #10752	; 0x2a00
    4552:	931b      	str	r3, [sp, #108]	; 0x6c
    const uint8_t bpp4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
    4554:	4bb4      	ldr	r3, [pc, #720]	; (4828 <lv_draw_letter+0x2f4>)
{
    4556:	4617      	mov	r7, r2
    4558:	4604      	mov	r4, r0
    455a:	460d      	mov	r5, r1
    const uint8_t bpp4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
    455c:	aa1e      	add	r2, sp, #120	; 0x78
    455e:	f103 0c10 	add.w	ip, r3, #16
    4562:	6818      	ldr	r0, [r3, #0]
    4564:	6859      	ldr	r1, [r3, #4]
    4566:	4616      	mov	r6, r2
    4568:	c603      	stmia	r6!, {r0, r1}
    456a:	3308      	adds	r3, #8
    456c:	4563      	cmp	r3, ip
    456e:	4632      	mov	r2, r6
    4570:	d1f7      	bne.n	4562 <lv_draw_letter+0x2e>
                                        68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255};
    /*clang-format on*/

    if(opa < LV_OPA_MIN) return;
    4572:	9b08      	ldr	r3, [sp, #32]
    4574:	2b0f      	cmp	r3, #15
    4576:	d90a      	bls.n	458e <lv_draw_letter+0x5a>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
    4578:	2bfc      	cmp	r3, #252	; 0xfc
    457a:	bf28      	it	cs
    457c:	23ff      	movcs	r3, #255	; 0xff
    457e:	9308      	str	r3, [sp, #32]

    if(font_p == NULL) {
    4580:	b947      	cbnz	r7, 4594 <lv_draw_letter+0x60>
        LV_LOG_WARN("Font: character's bitmap not found");
    4582:	4baa      	ldr	r3, [pc, #680]	; (482c <lv_draw_letter+0x2f8>)
    4584:	49aa      	ldr	r1, [pc, #680]	; (4830 <lv_draw_letter+0x2fc>)
    4586:	22f7      	movs	r2, #247	; 0xf7
    4588:	2002      	movs	r0, #2
    458a:	f001 fae1 	bl	5b50 <lv_log_add>

        /*Next row in VDB*/
        if(subpx) vdb_buf_tmp += vdb_width - (col_end - col_start) / 3;
        else vdb_buf_tmp += vdb_width - (col_end - col_start);
    }
}
    458e:	b023      	add	sp, #140	; 0x8c
    4590:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bool g_ret = lv_font_get_glyph_dsc(font_p, &g, letter, '\0');
    4594:	2300      	movs	r3, #0
    4596:	4652      	mov	r2, sl
    4598:	a91c      	add	r1, sp, #112	; 0x70
    459a:	4638      	mov	r0, r7
    459c:	f006 fb07 	bl	abae <lv_font_get_glyph_dsc>
    if(g_ret == false) return;
    45a0:	2800      	cmp	r0, #0
    45a2:	d0f4      	beq.n	458e <lv_draw_letter+0x5a>
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
    45a4:	f99d 1075 	ldrsb.w	r1, [sp, #117]	; 0x75
    45a8:	9106      	str	r1, [sp, #24]
    if(g.bpp == 3) g.bpp = 4;
    45aa:	f89d 1076 	ldrb.w	r1, [sp, #118]	; 0x76
    lv_coord_t pos_x = pos_p->x + g.ofs_x;
    45ae:	f9b4 9000 	ldrsh.w	r9, [r4]
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
    45b2:	f9b4 6002 	ldrsh.w	r6, [r4, #2]
    lv_coord_t pos_x = pos_p->x + g.ofs_x;
    45b6:	f99d 2074 	ldrsb.w	r2, [sp, #116]	; 0x74
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
    45ba:	f897 8008 	ldrb.w	r8, [r7, #8]
    45be:	7a7b      	ldrb	r3, [r7, #9]
    45c0:	f89d 4073 	ldrb.w	r4, [sp, #115]	; 0x73
    if(g.bpp == 3) g.bpp = 4;
    45c4:	2903      	cmp	r1, #3
    45c6:	d106      	bne.n	45d6 <lv_draw_letter+0xa2>
    45c8:	2104      	movs	r1, #4
    45ca:	f88d 1076 	strb.w	r1, [sp, #118]	; 0x76
            bitmask_init  = 0xF0;
    45ce:	21f0      	movs	r1, #240	; 0xf0
    45d0:	9109      	str	r1, [sp, #36]	; 0x24
            bpp_opa_table = bpp4_opa_table;
    45d2:	a91e      	add	r1, sp, #120	; 0x78
    45d4:	e019      	b.n	460a <lv_draw_letter+0xd6>
    switch(g.bpp) {
    45d6:	3901      	subs	r1, #1
    45d8:	2907      	cmp	r1, #7
    45da:	d8d8      	bhi.n	458e <lv_draw_letter+0x5a>
    45dc:	a001      	add	r0, pc, #4	; (adr r0, 45e4 <lv_draw_letter+0xb0>)
    45de:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
    45e2:	bf00      	nop
    45e4:	000047d9 	.word	0x000047d9
    45e8:	00004605 	.word	0x00004605
    45ec:	0000458f 	.word	0x0000458f
    45f0:	000045cf 	.word	0x000045cf
    45f4:	0000458f 	.word	0x0000458f
    45f8:	0000458f 	.word	0x0000458f
    45fc:	0000458f 	.word	0x0000458f
    4600:	000047d1 	.word	0x000047d1
            bitmask_init  = 0xC0;
    4604:	21c0      	movs	r1, #192	; 0xc0
    4606:	9109      	str	r1, [sp, #36]	; 0x24
            bpp_opa_table = bpp2_opa_table;
    4608:	a91b      	add	r1, sp, #108	; 0x6c
            bpp_opa_table = bpp1_opa_table;
    460a:	9105      	str	r1, [sp, #20]
    const uint8_t * map_p = lv_font_get_glyph_bitmap(font_p, letter);
    460c:	4638      	mov	r0, r7
    460e:	4651      	mov	r1, sl
    4610:	930a      	str	r3, [sp, #40]	; 0x28
    4612:	9207      	str	r2, [sp, #28]
    4614:	f006 fac9 	bl	abaa <lv_font_get_glyph_bitmap>
    if(map_p == NULL) return;
    4618:	9004      	str	r0, [sp, #16]
    461a:	2800      	cmp	r0, #0
    461c:	d0b7      	beq.n	458e <lv_draw_letter+0x5a>
    lv_coord_t pos_x = pos_p->x + g.ofs_x;
    461e:	9a07      	ldr	r2, [sp, #28]
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
    4620:	f9b5 1000 	ldrsh.w	r1, [r5]
    lv_coord_t pos_x = pos_p->x + g.ofs_x;
    4624:	4491      	add	r9, r2
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
    4626:	f89d 2072 	ldrb.w	r2, [sp, #114]	; 0x72
    lv_coord_t pos_x = pos_p->x + g.ofs_x;
    462a:	fa0f f989 	sxth.w	r9, r9
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
    462e:	444a      	add	r2, r9
    4630:	428a      	cmp	r2, r1
    4632:	dbac      	blt.n	458e <lv_draw_letter+0x5a>
    4634:	f9b5 2004 	ldrsh.w	r2, [r5, #4]
    4638:	454a      	cmp	r2, r9
    463a:	dba8      	blt.n	458e <lv_draw_letter+0x5a>
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
    463c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
    463e:	f9b5 2002 	ldrsh.w	r2, [r5, #2]
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
    4642:	eba8 0803 	sub.w	r8, r8, r3
    4646:	9b06      	ldr	r3, [sp, #24]
    4648:	4446      	add	r6, r8
    464a:	b236      	sxth	r6, r6
    464c:	441c      	add	r4, r3
    464e:	1b33      	subs	r3, r6, r4
    4650:	fa0f f883 	sxth.w	r8, r3
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
    4654:	f89d 3073 	ldrb.w	r3, [sp, #115]	; 0x73
    4658:	4443      	add	r3, r8
    465a:	4293      	cmp	r3, r2
    465c:	db97      	blt.n	458e <lv_draw_letter+0x5a>
    465e:	f9b5 3006 	ldrsh.w	r3, [r5, #6]
    4662:	4543      	cmp	r3, r8
    4664:	db93      	blt.n	458e <lv_draw_letter+0x5a>
    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
    4666:	f7ff fc81 	bl	3f6c <lv_refr_get_disp_refreshing>
    466a:	9011      	str	r0, [sp, #68]	; 0x44
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
    466c:	f005 fdcd 	bl	a20a <lv_disp_get_buf>
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    4670:	8a83      	ldrh	r3, [r0, #20]
    4672:	f9b0 1010 	ldrsh.w	r1, [r0, #16]
    4676:	9007      	str	r0, [sp, #28]
    4678:	3301      	adds	r3, #1
    467a:	1a5b      	subs	r3, r3, r1
    467c:	b21b      	sxth	r3, r3
    467e:	930b      	str	r3, [sp, #44]	; 0x2c
    bool subpx = font_p->subpx == LV_FONT_SUBPX_NONE ? false : true;
    4680:	7abb      	ldrb	r3, [r7, #10]
    lv_color_t * vdb_buf_tmp = vdb->buf_act;
    4682:	f8d0 c008 	ldr.w	ip, [r0, #8]
    uint16_t width_bit = g.box_w * g.bpp; /*Letter width in bits*/
    4686:	f89d 2076 	ldrb.w	r2, [sp, #118]	; 0x76
    uint8_t width_byte_scr = g.box_w >> 3; /*Width in bytes (on the screen finally) (e.g. w = 11 -> 2 bytes wide)*/
    468a:	f89d 0072 	ldrb.w	r0, [sp, #114]	; 0x72
    uint16_t width_bit = g.box_w * g.bpp; /*Letter width in bits*/
    468e:	f9b5 a000 	ldrsh.w	sl, [r5]
    if(subpx == false) {
    4692:	f013 0303 	ands.w	r3, r3, #3
    uint16_t width_bit = g.box_w * g.bpp; /*Letter width in bits*/
    4696:	fb00 fe02 	mul.w	lr, r0, r2
    if(subpx == false) {
    469a:	930c      	str	r3, [sp, #48]	; 0x30
    469c:	f040 80a5 	bne.w	47ea <lv_draw_letter+0x2b6>
        col_start = pos_x >= mask_p->x1 ? 0 : mask_p->x1 - pos_x;
    46a0:	45ca      	cmp	sl, r9
        col_end   = pos_x + g.box_w <= mask_p->x2 ? g.box_w : mask_p->x2 - pos_x + 1;
    46a2:	f9b5 3004 	ldrsh.w	r3, [r5, #4]
        col_start = pos_x >= mask_p->x1 ? 0 : mask_p->x1 - pos_x;
    46a6:	bfd4      	ite	le
    46a8:	f8dd a030 	ldrle.w	sl, [sp, #48]	; 0x30
    46ac:	ebaa 0a09 	subgt.w	sl, sl, r9
        col_end   = pos_x + g.box_w <= mask_p->x2 ? g.box_w : mask_p->x2 - pos_x + 1;
    46b0:	eb00 0709 	add.w	r7, r0, r9
        col_start = pos_x >= mask_p->x1 ? 0 : mask_p->x1 - pos_x;
    46b4:	bfc8      	it	gt
    46b6:	fa0f fa8a 	sxthgt.w	sl, sl
        col_end   = pos_x + g.box_w <= mask_p->x2 ? g.box_w : mask_p->x2 - pos_x + 1;
    46ba:	429f      	cmp	r7, r3
    46bc:	f300 8090 	bgt.w	47e0 <lv_draw_letter+0x2ac>
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
    46c0:	b203      	sxth	r3, r0
        row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
    46c2:	f9b5 7002 	ldrsh.w	r7, [r5, #2]
        row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
    46c6:	f89d 0073 	ldrb.w	r0, [sp, #115]	; 0x73
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
    46ca:	9306      	str	r3, [sp, #24]
        row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
    46cc:	4547      	cmp	r7, r8
    46ce:	bfc8      	it	gt
    46d0:	193f      	addgt	r7, r7, r4
        row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
    46d2:	f9b5 3006 	ldrsh.w	r3, [r5, #6]
        row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
    46d6:	bfc8      	it	gt
    46d8:	1bbf      	subgt	r7, r7, r6
        row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
    46da:	eb00 0508 	add.w	r5, r0, r8
        row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
    46de:	bfcc      	ite	gt
    46e0:	b23f      	sxthgt	r7, r7
    46e2:	2700      	movle	r7, #0
        row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
    46e4:	429d      	cmp	r5, r3
    46e6:	bfc2      	ittt	gt
    46e8:	3401      	addgt	r4, #1
    46ea:	18e4      	addgt	r4, r4, r3
    46ec:	1ba0      	subgt	r0, r4, r6
    46ee:	b203      	sxth	r3, r0
    46f0:	930f      	str	r3, [sp, #60]	; 0x3c
    vdb_buf_tmp += ((pos_y - vdb->area.y1) * vdb_width) + pos_x - vdb->area.x1;
    46f2:	9b07      	ldr	r3, [sp, #28]
    46f4:	f9b3 4012 	ldrsh.w	r4, [r3, #18]
    46f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    46fa:	eba9 0101 	sub.w	r1, r9, r1
    46fe:	eba8 0404 	sub.w	r4, r8, r4
    4702:	fb03 1404 	mla	r4, r3, r4, r1
    4706:	fb03 f107 	mul.w	r1, r3, r7
    if(subpx) vdb_buf_tmp += (row_start * vdb_width) + col_start / 3;
    470a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    vdb_buf_tmp += ((pos_y - vdb->area.y1) * vdb_width) + pos_x - vdb->area.x1;
    470c:	eb0c 0484 	add.w	r4, ip, r4, lsl #2
    if(subpx) vdb_buf_tmp += (row_start * vdb_width) + col_start / 3;
    4710:	2b00      	cmp	r3, #0
    4712:	f000 8086 	beq.w	4822 <lv_draw_letter+0x2ee>
    4716:	2303      	movs	r3, #3
    4718:	fb9a f3f3 	sdiv	r3, sl, r3
    471c:	440b      	add	r3, r1
    uint32_t bit_ofs = (row_start * width_bit) + (col_start * g.bpp);
    471e:	fb12 f50a 	smulbb	r5, r2, sl
    else vdb_buf_tmp += (row_start * vdb_width) + col_start;
    4722:	eb04 0483 	add.w	r4, r4, r3, lsl #2
    map_p += bit_ofs >> 3;
    4726:	9b04      	ldr	r3, [sp, #16]
        else vdb_buf_tmp += vdb_width - (col_end - col_start);
    4728:	9a06      	ldr	r2, [sp, #24]
    uint32_t bit_ofs = (row_start * width_bit) + (col_start * g.bpp);
    472a:	fb07 550e 	mla	r5, r7, lr, r5
    map_p += bit_ofs >> 3;
    472e:	eb03 03d5 	add.w	r3, r3, r5, lsr #3
    4732:	930a      	str	r3, [sp, #40]	; 0x28
    col_bit = bit_ofs & 0x7; /* "& 0x7" equals to "% 8" just faster */
    4734:	f005 0307 	and.w	r3, r5, #7
    4738:	9304      	str	r3, [sp, #16]
    uint8_t txt_rgb[3] = {LV_COLOR_GET_R(color), LV_COLOR_GET_G(color), LV_COLOR_GET_B(color)};
    473a:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
    473c:	f3c3 4307 	ubfx	r3, r3, #16, #8
    4740:	9312      	str	r3, [sp, #72]	; 0x48
    4742:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
    4744:	f3c3 2307 	ubfx	r3, r3, #8, #8
    4748:	9313      	str	r3, [sp, #76]	; 0x4c
    474a:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
    474c:	b2db      	uxtb	r3, r3
    474e:	9314      	str	r3, [sp, #80]	; 0x50
        else vdb_buf_tmp += vdb_width - (col_end - col_start);
    4750:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    4752:	4453      	add	r3, sl
    4754:	1a9b      	subs	r3, r3, r2
    4756:	009b      	lsls	r3, r3, #2
    4758:	9316      	str	r3, [sp, #88]	; 0x58
        if(subpx) vdb_buf_tmp += vdb_width - (col_end - col_start) / 3;
    475a:	eba2 030a 	sub.w	r3, r2, sl
    475e:	f06f 0202 	mvn.w	r2, #2
    4762:	fb93 f3f2 	sdiv	r3, r3, r2
    4766:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    4768:	4413      	add	r3, r2
    476a:	009b      	lsls	r3, r3, #2
    476c:	9315      	str	r3, [sp, #84]	; 0x54
    for(row = row_start; row < row_end; row++) {
    476e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    4770:	429f      	cmp	r7, r3
    4772:	f6bf af0c 	bge.w	458e <lv_draw_letter+0x5a>
        bitmask = bitmask_init >> col_bit;
    4776:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4778:	9a04      	ldr	r2, [sp, #16]
    477a:	4113      	asrs	r3, r2
    477c:	b2db      	uxtb	r3, r3
        for(col = col_start; col < col_end; col++) {
    477e:	e9cd 3a0d 	strd	r3, sl, [sp, #52]	; 0x34
    4782:	f8bd 3020 	ldrh.w	r3, [sp, #32]
    4786:	9310      	str	r3, [sp, #64]	; 0x40
                                *vdb_buf_tmp = lv_color_mix(color, *vdb_buf_tmp, px_opa);
    4788:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
    478a:	f3c3 4307 	ubfx	r3, r3, #16, #8
        uint8_t sub_px_cnt = 0;
    478e:	2600      	movs	r6, #0
                                *vdb_buf_tmp = lv_color_mix(color, *vdb_buf_tmp, px_opa);
    4790:	9317      	str	r3, [sp, #92]	; 0x5c
        for(col = col_start; col < col_end; col++) {
    4792:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    4794:	9a06      	ldr	r2, [sp, #24]
    4796:	f89d 1076 	ldrb.w	r1, [sp, #118]	; 0x76
    479a:	4293      	cmp	r3, r2
    479c:	db4a      	blt.n	4834 <lv_draw_letter+0x300>
        col_bit += ((g.box_w - col_end) + col_start) * g.bpp;
    479e:	f89d 3072 	ldrb.w	r3, [sp, #114]	; 0x72
    47a2:	4453      	add	r3, sl
    47a4:	1a9b      	subs	r3, r3, r2
    47a6:	9a04      	ldr	r2, [sp, #16]
    47a8:	fb13 f301 	smulbb	r3, r3, r1
    47ac:	441a      	add	r2, r3
        map_p += (col_bit >> 3);
    47ae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        col_bit += ((g.box_w - col_end) + col_start) * g.bpp;
    47b0:	b295      	uxth	r5, r2
        map_p += (col_bit >> 3);
    47b2:	eb03 03d5 	add.w	r3, r3, r5, lsr #3
    47b6:	930a      	str	r3, [sp, #40]	; 0x28
        col_bit = col_bit & 0x7;
    47b8:	f005 0307 	and.w	r3, r5, #7
    47bc:	9304      	str	r3, [sp, #16]
        if(subpx) vdb_buf_tmp += vdb_width - (col_end - col_start) / 3;
    47be:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    47c0:	2b00      	cmp	r3, #0
    47c2:	f000 80f9 	beq.w	49b8 <lv_draw_letter+0x484>
    47c6:	9b15      	ldr	r3, [sp, #84]	; 0x54
    for(row = row_start; row < row_end; row++) {
    47c8:	3701      	adds	r7, #1
        else vdb_buf_tmp += vdb_width - (col_end - col_start);
    47ca:	441c      	add	r4, r3
    for(row = row_start; row < row_end; row++) {
    47cc:	b23f      	sxth	r7, r7
    47ce:	e7ce      	b.n	476e <lv_draw_letter+0x23a>
            bitmask_init  = 0xFF;
    47d0:	21ff      	movs	r1, #255	; 0xff
    47d2:	9109      	str	r1, [sp, #36]	; 0x24
            bpp_opa_table = NULL;
    47d4:	2100      	movs	r1, #0
    47d6:	e718      	b.n	460a <lv_draw_letter+0xd6>
            bitmask_init  = 0x80;
    47d8:	2180      	movs	r1, #128	; 0x80
    47da:	9109      	str	r1, [sp, #36]	; 0x24
            bpp_opa_table = bpp1_opa_table;
    47dc:	a919      	add	r1, sp, #100	; 0x64
    47de:	e714      	b.n	460a <lv_draw_letter+0xd6>
        col_end   = pos_x + g.box_w <= mask_p->x2 ? g.box_w : mask_p->x2 - pos_x + 1;
    47e0:	3301      	adds	r3, #1
    47e2:	eba3 0309 	sub.w	r3, r3, r9
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
    47e6:	b21b      	sxth	r3, r3
    47e8:	e76b      	b.n	46c2 <lv_draw_letter+0x18e>
        col_start = pos_x >= mask_p->x1 ? 0 : (mask_p->x1 - pos_x) * 3;
    47ea:	45ca      	cmp	sl, r9
    47ec:	bfc8      	it	gt
    47ee:	ebaa 0a09 	subgt.w	sl, sl, r9
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
    47f2:	f9b5 3004 	ldrsh.w	r3, [r5, #4]
        col_start = pos_x >= mask_p->x1 ? 0 : (mask_p->x1 - pos_x) * 3;
    47f6:	bfc8      	it	gt
    47f8:	eb0a 0a4a 	addgt.w	sl, sl, sl, lsl #1
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
    47fc:	f04f 0703 	mov.w	r7, #3
    4800:	fbb0 f7f7 	udiv	r7, r0, r7
    4804:	444f      	add	r7, r9
        col_start = pos_x >= mask_p->x1 ? 0 : (mask_p->x1 - pos_x) * 3;
    4806:	bfcc      	ite	gt
    4808:	fa0f fa8a 	sxthgt.w	sl, sl
    480c:	f04f 0a00 	movle.w	sl, #0
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
    4810:	429f      	cmp	r7, r3
    4812:	f77f af55 	ble.w	46c0 <lv_draw_letter+0x18c>
    4816:	3301      	adds	r3, #1
    4818:	eba3 0309 	sub.w	r3, r3, r9
    481c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    4820:	e7e1      	b.n	47e6 <lv_draw_letter+0x2b2>
    else vdb_buf_tmp += (row_start * vdb_width) + col_start;
    4822:	eb01 030a 	add.w	r3, r1, sl
    4826:	e77a      	b.n	471e <lv_draw_letter+0x1ea>
    4828:	0000b1e0 	.word	0x0000b1e0
    482c:	0000c31d 	.word	0x0000c31d
    4830:	0000c340 	.word	0x0000c340
            letter_px = (*map_p & bitmask) >> (8 - col_bit - g.bpp);
    4834:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4836:	9804      	ldr	r0, [sp, #16]
    4838:	781a      	ldrb	r2, [r3, #0]
    483a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    483c:	401a      	ands	r2, r3
    483e:	f1c1 0308 	rsb	r3, r1, #8
    4842:	1a1b      	subs	r3, r3, r0
    4844:	411a      	asrs	r2, r3
            if(subpx == false) {
    4846:	9b0c      	ldr	r3, [sp, #48]	; 0x30
            letter_px = (*map_p & bitmask) >> (8 - col_bit - g.bpp);
    4848:	b2d2      	uxtb	r2, r2
            if(subpx == false) {
    484a:	2b00      	cmp	r3, #0
    484c:	d15c      	bne.n	4908 <lv_draw_letter+0x3d4>
                if(letter_px != 0) {
    484e:	b30a      	cbz	r2, 4894 <lv_draw_letter+0x360>
                    if(opa == LV_OPA_COVER) {
    4850:	9b08      	ldr	r3, [sp, #32]
    4852:	2bff      	cmp	r3, #255	; 0xff
    4854:	d134      	bne.n	48c0 <lv_draw_letter+0x38c>
                        px_opa = g.bpp == 8 ? letter_px : bpp_opa_table[letter_px];
    4856:	2908      	cmp	r1, #8
    4858:	d001      	beq.n	485e <lv_draw_letter+0x32a>
    485a:	9b05      	ldr	r3, [sp, #20]
    485c:	5c9a      	ldrb	r2, [r3, r2]
                    if(disp->driver.set_px_cb) {
    485e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    4860:	695b      	ldr	r3, [r3, #20]
    4862:	461d      	mov	r5, r3
    4864:	2b00      	cmp	r3, #0
    4866:	d035      	beq.n	48d4 <lv_draw_letter+0x3a0>
                        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width,
    4868:	9b07      	ldr	r3, [sp, #28]
    486a:	990e      	ldr	r1, [sp, #56]	; 0x38
    486c:	8a1b      	ldrh	r3, [r3, #16]
    486e:	9202      	str	r2, [sp, #8]
    4870:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
    4872:	9201      	str	r2, [sp, #4]
    4874:	9a07      	ldr	r2, [sp, #28]
    4876:	9811      	ldr	r0, [sp, #68]	; 0x44
    4878:	8a52      	ldrh	r2, [r2, #18]
    487a:	eba8 0202 	sub.w	r2, r8, r2
    487e:	eba9 0303 	sub.w	r3, r9, r3
    4882:	443a      	add	r2, r7
    4884:	440b      	add	r3, r1
    4886:	b212      	sxth	r2, r2
    4888:	9907      	ldr	r1, [sp, #28]
    488a:	9200      	str	r2, [sp, #0]
    488c:	b21b      	sxth	r3, r3
    488e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    4890:	6889      	ldr	r1, [r1, #8]
    4892:	47a8      	blx	r5
                vdb_buf_tmp++;
    4894:	3404      	adds	r4, #4
            if(col_bit < 8 - g.bpp) {
    4896:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
    489a:	9904      	ldr	r1, [sp, #16]
    489c:	f1c3 0208 	rsb	r2, r3, #8
    48a0:	4291      	cmp	r1, r2
    48a2:	f280 8081 	bge.w	49a8 <lv_draw_letter+0x474>
                col_bit += g.bpp;
    48a6:	460a      	mov	r2, r1
    48a8:	441a      	add	r2, r3
    48aa:	b292      	uxth	r2, r2
    48ac:	9204      	str	r2, [sp, #16]
                bitmask = bitmask >> g.bpp;
    48ae:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    48b0:	411a      	asrs	r2, r3
    48b2:	b2d3      	uxtb	r3, r2
    48b4:	930d      	str	r3, [sp, #52]	; 0x34
        for(col = col_start; col < col_end; col++) {
    48b6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    48b8:	3301      	adds	r3, #1
    48ba:	b21b      	sxth	r3, r3
    48bc:	930e      	str	r3, [sp, #56]	; 0x38
    48be:	e768      	b.n	4792 <lv_draw_letter+0x25e>
                        px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
    48c0:	2908      	cmp	r1, #8
                                : (uint16_t)((uint16_t)bpp_opa_table[letter_px] * opa) >> 8;
    48c2:	bf1c      	itt	ne
    48c4:	9b05      	ldrne	r3, [sp, #20]
    48c6:	5c9a      	ldrbne	r2, [r3, r2]
    48c8:	9b10      	ldr	r3, [sp, #64]	; 0x40
    48ca:	fb12 f203 	smulbb	r2, r2, r3
                        px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
    48ce:	f3c2 2207 	ubfx	r2, r2, #8, #8
    48d2:	e7c4      	b.n	485e <lv_draw_letter+0x32a>
                    } else if(vdb_buf_tmp->full != color.full) {
    48d4:	6823      	ldr	r3, [r4, #0]
    48d6:	992c      	ldr	r1, [sp, #176]	; 0xb0
    48d8:	428b      	cmp	r3, r1
    48da:	d0db      	beq.n	4894 <lv_draw_letter+0x360>
                        if(px_opa > LV_OPA_MAX) {
    48dc:	2afb      	cmp	r2, #251	; 0xfb
    48de:	d901      	bls.n	48e4 <lv_draw_letter+0x3b0>
                            *vdb_buf_tmp = color;
    48e0:	6021      	str	r1, [r4, #0]
    48e2:	e7d7      	b.n	4894 <lv_draw_letter+0x360>
                        } else if(px_opa > LV_OPA_MIN) {
    48e4:	2a10      	cmp	r2, #16
    48e6:	d9d5      	bls.n	4894 <lv_draw_letter+0x360>
                                *vdb_buf_tmp = lv_color_mix(color, *vdb_buf_tmp, px_opa);
    48e8:	7823      	ldrb	r3, [r4, #0]
    48ea:	9202      	str	r2, [sp, #8]
    48ec:	78a2      	ldrb	r2, [r4, #2]
    48ee:	9201      	str	r2, [sp, #4]
    48f0:	992c      	ldr	r1, [sp, #176]	; 0xb0
    48f2:	982c      	ldr	r0, [sp, #176]	; 0xb0
    48f4:	7862      	ldrb	r2, [r4, #1]
    48f6:	9200      	str	r2, [sp, #0]
    48f8:	f3c1 2107 	ubfx	r1, r1, #8, #8
    48fc:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    48fe:	b2c0      	uxtb	r0, r0
    4900:	f004 fc8f 	bl	9222 <lv_color_mix.isra.0>
    4904:	6020      	str	r0, [r4, #0]
    4906:	e7c5      	b.n	4894 <lv_draw_letter+0x360>
                if(letter_px != 0) {
    4908:	b132      	cbz	r2, 4918 <lv_draw_letter+0x3e4>
                    if(opa == LV_OPA_COVER) {
    490a:	9b08      	ldr	r3, [sp, #32]
    490c:	2bff      	cmp	r3, #255	; 0xff
    490e:	d11b      	bne.n	4948 <lv_draw_letter+0x414>
                        px_opa = g.bpp == 8 ? letter_px : bpp_opa_table[letter_px];
    4910:	2908      	cmp	r1, #8
    4912:	d001      	beq.n	4918 <lv_draw_letter+0x3e4>
    4914:	9b05      	ldr	r3, [sp, #20]
    4916:	5c9a      	ldrb	r2, [r3, r2]
                    font_rgb[sub_px_cnt] = 0;
    4918:	ab22      	add	r3, sp, #136	; 0x88
    491a:	4433      	add	r3, r6
                sub_px_cnt ++;
    491c:	3601      	adds	r6, #1
    491e:	b2f6      	uxtb	r6, r6
                if(sub_px_cnt == 3) {
    4920:	2e03      	cmp	r6, #3
                    font_rgb[sub_px_cnt] = 0;
    4922:	f803 2c20 	strb.w	r2, [r3, #-32]
                if(sub_px_cnt == 3) {
    4926:	d1b6      	bne.n	4896 <lv_draw_letter+0x362>
                    if(font_rgb[0] == 0 && font_rgb[1] == 0 && font_rgb[2] == 0) {
    4928:	f89d c068 	ldrb.w	ip, [sp, #104]	; 0x68
    492c:	f89d 2069 	ldrb.w	r2, [sp, #105]	; 0x69
    4930:	f89d 006a 	ldrb.w	r0, [sp, #106]	; 0x6a
    4934:	ea4c 0302 	orr.w	r3, ip, r2
    4938:	4303      	orrs	r3, r0
    493a:	d10f      	bne.n	495c <lv_draw_letter+0x428>
                        res_color = *vdb_buf_tmp;
    493c:	f8d4 b000 	ldr.w	fp, [r4]
                        vdb_buf_tmp->full = res_color.full;
    4940:	f844 bb04 	str.w	fp, [r4], #4
                    sub_px_cnt = 0;
    4944:	2600      	movs	r6, #0
    4946:	e7a6      	b.n	4896 <lv_draw_letter+0x362>
                        px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
    4948:	2908      	cmp	r1, #8
                                : (uint16_t)((uint16_t)bpp_opa_table[letter_px] * opa) >> 8;
    494a:	bf1c      	itt	ne
    494c:	9b05      	ldrne	r3, [sp, #20]
    494e:	5c9a      	ldrbne	r2, [r3, r2]
    4950:	9b10      	ldr	r3, [sp, #64]	; 0x40
    4952:	fb12 f203 	smulbb	r2, r2, r3
                        px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
    4956:	f3c2 2207 	ubfx	r2, r2, #8, #8
                    font_rgb[sub_px_cnt] = px_opa;
    495a:	e7dd      	b.n	4918 <lv_draw_letter+0x3e4>
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8);
    495c:	9d12      	ldr	r5, [sp, #72]	; 0x48
    495e:	f894 e002 	ldrb.w	lr, [r4, #2]
                        uint8_t bg_rgb[3] = {LV_COLOR_GET_R(*vdb_buf_tmp), LV_COLOR_GET_G(*vdb_buf_tmp), LV_COLOR_GET_B(*vdb_buf_tmp)};
    4962:	7821      	ldrb	r1, [r4, #0]
    4964:	7863      	ldrb	r3, [r4, #1]
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8);
    4966:	f1cc 06ff 	rsb	r6, ip, #255	; 0xff
    496a:	fb15 fc0c 	smulbb	ip, r5, ip
                        LV_COLOR_SET_B(res_color, (uint16_t)((uint16_t)txt_rgb[2] * font_rgb[2] + (bg_rgb[2] * (255 - font_rgb[2]))) >> 8);
    496e:	9d14      	ldr	r5, [sp, #80]	; 0x50
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8);
    4970:	fb0e cc06 	mla	ip, lr, r6, ip
                        LV_COLOR_SET_B(res_color, (uint16_t)((uint16_t)txt_rgb[2] * font_rgb[2] + (bg_rgb[2] * (255 - font_rgb[2]))) >> 8);
    4974:	f1c0 06ff 	rsb	r6, r0, #255	; 0xff
    4978:	fb15 f000 	smulbb	r0, r5, r0
    497c:	fb06 0101 	mla	r1, r6, r1, r0
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8);
    4980:	f3cc 2c07 	ubfx	ip, ip, #8, #8
                        LV_COLOR_SET_G(res_color, (uint16_t)((uint16_t)txt_rgb[1] * font_rgb[1] + (bg_rgb[1] * (255 - font_rgb[1]))) >> 8);
    4984:	9813      	ldr	r0, [sp, #76]	; 0x4c
                        LV_COLOR_SET_B(res_color, (uint16_t)((uint16_t)txt_rgb[2] * font_rgb[2] + (bg_rgb[2] * (255 - font_rgb[2]))) >> 8);
    4986:	f3c1 2107 	ubfx	r1, r1, #8, #8
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8);
    498a:	f36c 4b17 	bfi	fp, ip, #16, #8
                        LV_COLOR_SET_B(res_color, (uint16_t)((uint16_t)txt_rgb[2] * font_rgb[2] + (bg_rgb[2] * (255 - font_rgb[2]))) >> 8);
    498e:	f361 0b07 	bfi	fp, r1, #0, #8
                        LV_COLOR_SET_G(res_color, (uint16_t)((uint16_t)txt_rgb[1] * font_rgb[1] + (bg_rgb[1] * (255 - font_rgb[1]))) >> 8);
    4992:	f1c2 01ff 	rsb	r1, r2, #255	; 0xff
    4996:	fb10 f202 	smulbb	r2, r0, r2
    499a:	fb01 2303 	mla	r3, r1, r3, r2
    499e:	f3c3 2307 	ubfx	r3, r3, #8, #8
    49a2:	f363 2b0f 	bfi	fp, r3, #8, #8
    49a6:	e7cb      	b.n	4940 <lv_draw_letter+0x40c>
                map_p++;
    49a8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    49aa:	3301      	adds	r3, #1
    49ac:	930a      	str	r3, [sp, #40]	; 0x28
                bitmask = bitmask_init;
    49ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
    49b0:	930d      	str	r3, [sp, #52]	; 0x34
                col_bit = 0;
    49b2:	2300      	movs	r3, #0
    49b4:	9304      	str	r3, [sp, #16]
    49b6:	e77e      	b.n	48b6 <lv_draw_letter+0x382>
        else vdb_buf_tmp += vdb_width - (col_end - col_start);
    49b8:	9b16      	ldr	r3, [sp, #88]	; 0x58
    49ba:	e705      	b.n	47c8 <lv_draw_letter+0x294>

000049bc <lv_draw_get_buf>:
 * Be careful to not use the buffer while other processes are using it.
 * @param size the required size
 */
void * lv_draw_get_buf(uint32_t size)
{
    if(size <= draw_buf_size) return LV_GC_ROOT(_lv_draw_buf);
    49bc:	4a09      	ldr	r2, [pc, #36]	; (49e4 <lv_draw_get_buf+0x28>)
{
    49be:	b538      	push	{r3, r4, r5, lr}
    if(size <= draw_buf_size) return LV_GC_ROOT(_lv_draw_buf);
    49c0:	6815      	ldr	r5, [r2, #0]
    49c2:	4c09      	ldr	r4, [pc, #36]	; (49e8 <lv_draw_get_buf+0x2c>)
    49c4:	4285      	cmp	r5, r0
{
    49c6:	4601      	mov	r1, r0
    49c8:	6823      	ldr	r3, [r4, #0]
    if(size <= draw_buf_size) return LV_GC_ROOT(_lv_draw_buf);
    49ca:	d205      	bcs.n	49d8 <lv_draw_get_buf+0x1c>

    LV_LOG_TRACE("lv_draw_get_buf: allocate");

    draw_buf_size = size;
    49cc:	6010      	str	r0, [r2, #0]

    if(LV_GC_ROOT(_lv_draw_buf) == NULL) {
    49ce:	b92b      	cbnz	r3, 49dc <lv_draw_get_buf+0x20>
        LV_GC_ROOT(_lv_draw_buf) = lv_mem_alloc(size);
    49d0:	f000 fefc 	bl	57cc <lv_mem_alloc>
        LV_ASSERT_MEM(LV_GC_ROOT(_lv_draw_buf));
        return LV_GC_ROOT(_lv_draw_buf);
    }

    LV_GC_ROOT(_lv_draw_buf) = lv_mem_realloc(LV_GC_ROOT(_lv_draw_buf), size);
    49d4:	4603      	mov	r3, r0
    49d6:	6020      	str	r0, [r4, #0]
    LV_ASSERT_MEM(LV_GC_ROOT(_lv_draw_buf));
    return LV_GC_ROOT(_lv_draw_buf);
}
    49d8:	4618      	mov	r0, r3
    49da:	bd38      	pop	{r3, r4, r5, pc}
    LV_GC_ROOT(_lv_draw_buf) = lv_mem_realloc(LV_GC_ROOT(_lv_draw_buf), size);
    49dc:	4618      	mov	r0, r3
    49de:	f000 ff39 	bl	5854 <lv_mem_realloc>
    49e2:	e7f7      	b.n	49d4 <lv_draw_get_buf+0x18>
    49e4:	20000e10 	.word	0x20000e10
    49e8:	20000e38 	.word	0x20000e38

000049ec <lv_draw_free_buf>:

/**
 * Free the draw buffer
 */
void lv_draw_free_buf(void)
{
    49ec:	b510      	push	{r4, lr}
    if(LV_GC_ROOT(_lv_draw_buf)) {
    49ee:	4c05      	ldr	r4, [pc, #20]	; (4a04 <lv_draw_free_buf+0x18>)
    49f0:	6820      	ldr	r0, [r4, #0]
    49f2:	b128      	cbz	r0, 4a00 <lv_draw_free_buf+0x14>
        lv_mem_free(LV_GC_ROOT(_lv_draw_buf));
    49f4:	f000 ff10 	bl	5818 <lv_mem_free>
        LV_GC_ROOT(_lv_draw_buf) = NULL;
        draw_buf_size = 0;
    49f8:	4a03      	ldr	r2, [pc, #12]	; (4a08 <lv_draw_free_buf+0x1c>)
        LV_GC_ROOT(_lv_draw_buf) = NULL;
    49fa:	2300      	movs	r3, #0
    49fc:	6023      	str	r3, [r4, #0]
        draw_buf_size = 0;
    49fe:	6013      	str	r3, [r2, #0]
    }
}
    4a00:	bd10      	pop	{r4, pc}
    4a02:	bf00      	nop
    4a04:	20000e38 	.word	0x20000e38
    4a08:	20000e10 	.word	0x20000e10

00004a0c <hex_char_to_num>:
 * Convert a hexadecimal characters to a number (0..15)
 * @param hex Pointer to a hexadecimal character (0..9, A..F)
 * @return the numerical value of `hex` or 0 on error
 */
static uint8_t hex_char_to_num(char hex)
{
    4a0c:	4603      	mov	r3, r0
    uint8_t result = 0;

    if(hex >= '0' && hex <= '9') {
    4a0e:	3830      	subs	r0, #48	; 0x30
    4a10:	b2c0      	uxtb	r0, r0
    4a12:	2809      	cmp	r0, #9
    4a14:	d90b      	bls.n	4a2e <hex_char_to_num+0x22>
        result = hex - '0';
    } else {
        if(hex >= 'a') hex -= 'a' - 'A'; /*Convert to upper case*/
    4a16:	2b60      	cmp	r3, #96	; 0x60
    4a18:	bf84      	itt	hi
    4a1a:	3b20      	subhi	r3, #32
    4a1c:	b2db      	uxtbhi	r3, r3

        switch(hex) {
    4a1e:	3b41      	subs	r3, #65	; 0x41
    4a20:	b2db      	uxtb	r3, r3
    4a22:	2b05      	cmp	r3, #5
    4a24:	d802      	bhi.n	4a2c <hex_char_to_num+0x20>
    4a26:	4a02      	ldr	r2, [pc, #8]	; (4a30 <hex_char_to_num+0x24>)
    4a28:	5cd0      	ldrb	r0, [r2, r3]
    4a2a:	4770      	bx	lr
{
    4a2c:	2000      	movs	r0, #0
        default: result = 0; break;
        }
    }

    return result;
}
    4a2e:	4770      	bx	lr
    4a30:	0000c37c 	.word	0x0000c37c

00004a34 <lv_draw_label>:
{
    4a34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4a38:	b0ad      	sub	sp, #180	; 0xb4
    4a3a:	4606      	mov	r6, r0
    4a3c:	9305      	str	r3, [sp, #20]
    if (txt[0] == '\0')  return;
    4a3e:	9b36      	ldr	r3, [sp, #216]	; 0xd8
{
    4a40:	910b      	str	r1, [sp, #44]	; 0x2c
    if (txt[0] == '\0')  return;
    4a42:	781b      	ldrb	r3, [r3, #0]
{
    4a44:	f89d b0dc 	ldrb.w	fp, [sp, #220]	; 0xdc
    4a48:	9f3a      	ldr	r7, [sp, #232]	; 0xe8
    4a4a:	4615      	mov	r5, r2
    if (txt[0] == '\0')  return;
    4a4c:	2b00      	cmp	r3, #0
    4a4e:	f000 80a7 	beq.w	4ba0 <lv_draw_label+0x16c>
    const lv_font_t * font = style->text.font;
    4a52:	6b53      	ldr	r3, [r2, #52]	; 0x34
    4a54:	9304      	str	r3, [sp, #16]
    if((flag & LV_TXT_FLAG_EXPAND) == 0) {
    4a56:	f01b 0f02 	tst.w	fp, #2
    4a5a:	f040 80a4 	bne.w	4ba6 <lv_draw_label+0x172>
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    4a5e:	8883      	ldrh	r3, [r0, #4]
    4a60:	8802      	ldrh	r2, [r0, #0]
    4a62:	3301      	adds	r3, #1
    4a64:	1a9b      	subs	r3, r3, r2
    4a66:	b21b      	sxth	r3, r3
        w = p.x;
    4a68:	9308      	str	r3, [sp, #32]
    lv_coord_t line_height = lv_font_get_line_height(font) + style->text.line_space;
    4a6a:	9b04      	ldr	r3, [sp, #16]
    4a6c:	8f6a      	ldrh	r2, [r5, #58]	; 0x3a
    4a6e:	7a1b      	ldrb	r3, [r3, #8]
    4a70:	4413      	add	r3, r2
    4a72:	b21b      	sxth	r3, r3
    4a74:	9307      	str	r3, [sp, #28]
    pos.x = coords->x1;
    4a76:	8833      	ldrh	r3, [r6, #0]
    4a78:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
    if(offset != NULL) {
    4a7c:	9b38      	ldr	r3, [sp, #224]	; 0xe0
    pos.y = coords->y1;
    4a7e:	f9b6 2002 	ldrsh.w	r2, [r6, #2]
    4a82:	f8ad 2052 	strh.w	r2, [sp, #82]	; 0x52
    if(offset != NULL) {
    4a86:	2b00      	cmp	r3, #0
    4a88:	f000 820e 	beq.w	4ea8 <lv_draw_label+0x474>
        x_ofs = offset->x;
    4a8c:	f9b3 3000 	ldrsh.w	r3, [r3]
    4a90:	930e      	str	r3, [sp, #56]	; 0x38
        y_ofs = offset->y;
    4a92:	9b38      	ldr	r3, [sp, #224]	; 0xe0
    4a94:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
        pos.y += y_ofs;
    4a98:	18d1      	adds	r1, r2, r3
    4a9a:	f8ad 1052 	strh.w	r1, [sp, #82]	; 0x52
    if(hint && y_ofs == 0 && coords->y1 < 0) {
    4a9e:	2f00      	cmp	r7, #0
    4aa0:	f000 8206 	beq.w	4eb0 <lv_draw_label+0x47c>
    4aa4:	2b00      	cmp	r3, #0
    4aa6:	f040 8203 	bne.w	4eb0 <lv_draw_label+0x47c>
    4aaa:	2a00      	cmp	r2, #0
    4aac:	f280 8200 	bge.w	4eb0 <lv_draw_label+0x47c>
        if(LV_MATH_ABS(hint->coord_y - coords->y1) > LV_LABEL_HINT_UPDATE_TH - 2 * line_height) {
    4ab0:	68bb      	ldr	r3, [r7, #8]
    4ab2:	1a9b      	subs	r3, r3, r2
    4ab4:	9a07      	ldr	r2, [sp, #28]
    4ab6:	2b00      	cmp	r3, #0
    4ab8:	bfb8      	it	lt
    4aba:	425b      	neglt	r3, r3
    4abc:	f5c2 7200 	rsb	r2, r2, #512	; 0x200
    4ac0:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
            hint->line_start = -1;
    4ac4:	bfc4      	itt	gt
    4ac6:	f04f 33ff 	movgt.w	r3, #4294967295	; 0xffffffff
    4aca:	603b      	strgt	r3, [r7, #0]
        last_line_start = hint->line_start;
    4acc:	683c      	ldr	r4, [r7, #0]
    if(hint && last_line_start >= 0) {
    4ace:	2c00      	cmp	r4, #0
    4ad0:	f2c0 81ee 	blt.w	4eb0 <lv_draw_label+0x47c>
        pos.y += hint->y;
    4ad4:	f8bd 2052 	ldrh.w	r2, [sp, #82]	; 0x52
    4ad8:	687b      	ldr	r3, [r7, #4]
    4ada:	4413      	add	r3, r2
    4adc:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
    uint32_t line_end = line_start + lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
    4ae0:	9836      	ldr	r0, [sp, #216]	; 0xd8
    4ae2:	f8cd b000 	str.w	fp, [sp]
    4ae6:	9b08      	ldr	r3, [sp, #32]
    4ae8:	f9b5 2038 	ldrsh.w	r2, [r5, #56]	; 0x38
    4aec:	9904      	ldr	r1, [sp, #16]
    4aee:	4420      	add	r0, r4
    4af0:	f000 ff32 	bl	5958 <lv_txt_get_next_line>
    4af4:	eb00 0804 	add.w	r8, r0, r4
    while(pos.y + line_height < mask->y1) {
    4af8:	9a07      	ldr	r2, [sp, #28]
    4afa:	f9bd 3052 	ldrsh.w	r3, [sp, #82]	; 0x52
    4afe:	4413      	add	r3, r2
    4b00:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    4b02:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
    4b06:	4293      	cmp	r3, r2
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
    4b08:	9b36      	ldr	r3, [sp, #216]	; 0xd8
    while(pos.y + line_height < mask->y1) {
    4b0a:	db61      	blt.n	4bd0 <lv_draw_label+0x19c>
    if(flag & LV_TXT_FLAG_CENTER) {
    4b0c:	1918      	adds	r0, r3, r4
    4b0e:	f01b 0304 	ands.w	r3, fp, #4
    4b12:	9312      	str	r3, [sp, #72]	; 0x48
    4b14:	f000 8084 	beq.w	4c20 <lv_draw_label+0x1ec>
        line_width = lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
    4b18:	eba8 0104 	sub.w	r1, r8, r4
    4b1c:	f9b5 3038 	ldrsh.w	r3, [r5, #56]	; 0x38
    4b20:	9a04      	ldr	r2, [sp, #16]
    4b22:	f8cd b000 	str.w	fp, [sp]
    4b26:	b289      	uxth	r1, r1
    4b28:	f000 fec6 	bl	58b8 <lv_txt_get_width>
    4b2c:	88b3      	ldrh	r3, [r6, #4]
    4b2e:	8832      	ldrh	r2, [r6, #0]
    4b30:	3301      	adds	r3, #1
    4b32:	1a9b      	subs	r3, r3, r2
        pos.x += (lv_area_get_width(coords) - line_width) / 2;
    4b34:	b21b      	sxth	r3, r3
    4b36:	1a18      	subs	r0, r3, r0
    4b38:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    4b3c:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
    4b40:	eb03 0060 	add.w	r0, r3, r0, asr #1
        pos.x += lv_area_get_width(coords) - line_width;
    4b44:	f8ad 0050 	strh.w	r0, [sp, #80]	; 0x50
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->text.opa : (uint16_t)((uint16_t)style->text.opa * opa_scale) >> 8;
    4b48:	f895 303c 	ldrb.w	r3, [r5, #60]	; 0x3c
    4b4c:	9309      	str	r3, [sp, #36]	; 0x24
    4b4e:	9b05      	ldr	r3, [sp, #20]
    4b50:	2bff      	cmp	r3, #255	; 0xff
    4b52:	d004      	beq.n	4b5e <lv_draw_label+0x12a>
    4b54:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4b56:	9a05      	ldr	r2, [sp, #20]
    4b58:	4353      	muls	r3, r2
    4b5a:	0a1b      	lsrs	r3, r3, #8
    4b5c:	9309      	str	r3, [sp, #36]	; 0x24
    if(sel) {
    4b5e:	9b39      	ldr	r3, [sp, #228]	; 0xe4
    4b60:	2b00      	cmp	r3, #0
    4b62:	d073      	beq.n	4c4c <lv_draw_label+0x218>
        sel_start = sel->start;
    4b64:	881b      	ldrh	r3, [r3, #0]
    4b66:	9306      	str	r3, [sp, #24]
        sel_end = sel->end;
    4b68:	9b39      	ldr	r3, [sp, #228]	; 0xe4
    4b6a:	885b      	ldrh	r3, [r3, #2]
    4b6c:	9305      	str	r3, [sp, #20]
        if(sel_start > sel_end) {
    4b6e:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    4b72:	4293      	cmp	r3, r2
    4b74:	d901      	bls.n	4b7a <lv_draw_label+0x146>
    4b76:	e9cd 3205 	strd	r3, r2, [sp, #20]
    lv_style_copy(&sel_style, &lv_style_plain_color);
    4b7a:	4999      	ldr	r1, [pc, #612]	; (4de0 <lv_draw_label+0x3ac>)
    4b7c:	a818      	add	r0, sp, #96	; 0x60
    4b7e:	f004 fb4d 	bl	921c <lv_style_copy>
    sel_style.body.main_color = sel_style.body.grad_color = style->text.sel_color;
    4b82:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    4b84:	e9cd 3319 	strd	r3, r3, [sp, #100]	; 0x64
    uint16_t par_start = 0;
    4b88:	2300      	movs	r3, #0
    4b8a:	930d      	str	r3, [sp, #52]	; 0x34
    4b8c:	f00b 0301 	and.w	r3, fp, #1
    4b90:	9311      	str	r3, [sp, #68]	; 0x44
    while(txt[line_start] != '\0') {
    4b92:	9b36      	ldr	r3, [sp, #216]	; 0xd8
    4b94:	4423      	add	r3, r4
    4b96:	930c      	str	r3, [sp, #48]	; 0x30
    4b98:	9b36      	ldr	r3, [sp, #216]	; 0xd8
    4b9a:	5d1b      	ldrb	r3, [r3, r4]
    4b9c:	2b00      	cmp	r3, #0
    4b9e:	d15a      	bne.n	4c56 <lv_draw_label+0x222>
}
    4ba0:	b02d      	add	sp, #180	; 0xb4
    4ba2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        lv_txt_get_size(&p, txt, style->text.font, style->text.letter_space, style->text.line_space, LV_COORD_MAX,
    4ba6:	f647 4318 	movw	r3, #31768	; 0x7c18
    4baa:	f8cd b008 	str.w	fp, [sp, #8]
    4bae:	9301      	str	r3, [sp, #4]
    4bb0:	f9b2 303a 	ldrsh.w	r3, [r2, #58]	; 0x3a
    4bb4:	9300      	str	r3, [sp, #0]
    4bb6:	f9b2 3038 	ldrsh.w	r3, [r2, #56]	; 0x38
    4bba:	9936      	ldr	r1, [sp, #216]	; 0xd8
    4bbc:	9a04      	ldr	r2, [sp, #16]
    4bbe:	a818      	add	r0, sp, #96	; 0x60
    4bc0:	f005 fd84 	bl	a6cc <lv_txt_get_size>
        w = p.x;
    4bc4:	f9bd 3060 	ldrsh.w	r3, [sp, #96]	; 0x60
    4bc8:	e74e      	b.n	4a68 <lv_draw_label+0x34>
    lv_coord_t x_ofs = 0;
    4bca:	9b38      	ldr	r3, [sp, #224]	; 0xe0
    4bcc:	930e      	str	r3, [sp, #56]	; 0x38
    4bce:	e76c      	b.n	4aaa <lv_draw_label+0x76>
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
    4bd0:	eb03 0908 	add.w	r9, r3, r8
    4bd4:	f9b5 2038 	ldrsh.w	r2, [r5, #56]	; 0x38
    4bd8:	9b08      	ldr	r3, [sp, #32]
    4bda:	f8cd b000 	str.w	fp, [sp]
    4bde:	9904      	ldr	r1, [sp, #16]
    4be0:	4648      	mov	r0, r9
    4be2:	f000 feb9 	bl	5958 <lv_txt_get_next_line>
        pos.y += line_height;
    4be6:	f8bd 3052 	ldrh.w	r3, [sp, #82]	; 0x52
    4bea:	9a07      	ldr	r2, [sp, #28]
    4bec:	4413      	add	r3, r2
    4bee:	b21b      	sxth	r3, r3
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
    4bf0:	4440      	add	r0, r8
        pos.y += line_height;
    4bf2:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
        if(hint && pos.y >= -LV_LABEL_HINT_UPDATE_TH && hint->line_start < 0) {
    4bf6:	b167      	cbz	r7, 4c12 <lv_draw_label+0x1de>
    4bf8:	f513 6f80 	cmn.w	r3, #1024	; 0x400
    4bfc:	db09      	blt.n	4c12 <lv_draw_label+0x1de>
    4bfe:	683a      	ldr	r2, [r7, #0]
    4c00:	2a00      	cmp	r2, #0
            hint->y          = pos.y - coords->y1;
    4c02:	bfbf      	itttt	lt
    4c04:	f9b6 2002 	ldrshlt.w	r2, [r6, #2]
            hint->line_start = line_start;
    4c08:	f8c7 8000 	strlt.w	r8, [r7]
            hint->y          = pos.y - coords->y1;
    4c0c:	1a9b      	sublt	r3, r3, r2
            hint->coord_y    = coords->y1;
    4c0e:	e9c7 3201 	strdlt	r3, r2, [r7, #4]
        if(txt[line_start] == '\0') return;
    4c12:	f899 3000 	ldrb.w	r3, [r9]
    4c16:	4644      	mov	r4, r8
    4c18:	2b00      	cmp	r3, #0
    4c1a:	d0c1      	beq.n	4ba0 <lv_draw_label+0x16c>
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
    4c1c:	4680      	mov	r8, r0
    4c1e:	e76b      	b.n	4af8 <lv_draw_label+0xc4>
    else if(flag & LV_TXT_FLAG_RIGHT) {
    4c20:	f01b 0f08 	tst.w	fp, #8
    4c24:	d090      	beq.n	4b48 <lv_draw_label+0x114>
        line_width = lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
    4c26:	eba8 0104 	sub.w	r1, r8, r4
    4c2a:	f9b5 3038 	ldrsh.w	r3, [r5, #56]	; 0x38
    4c2e:	9a04      	ldr	r2, [sp, #16]
    4c30:	f8cd b000 	str.w	fp, [sp]
    4c34:	b289      	uxth	r1, r1
    4c36:	f000 fe3f 	bl	58b8 <lv_txt_get_width>
        pos.x += lv_area_get_width(coords) - line_width;
    4c3a:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    4c3e:	88b2      	ldrh	r2, [r6, #4]
    4c40:	3301      	adds	r3, #1
    4c42:	4413      	add	r3, r2
    4c44:	8832      	ldrh	r2, [r6, #0]
    4c46:	1a9b      	subs	r3, r3, r2
    4c48:	1a18      	subs	r0, r3, r0
    4c4a:	e77b      	b.n	4b44 <lv_draw_label+0x110>
    uint16_t sel_end = 0xFFFF;
    4c4c:	f64f 73ff 	movw	r3, #65535	; 0xffff
    uint16_t sel_start = 0xFFFF;
    4c50:	e9cd 3305 	strd	r3, r3, [sp, #20]
    4c54:	e791      	b.n	4b7a <lv_draw_label+0x146>
        if(offset != NULL) {
    4c56:	9b38      	ldr	r3, [sp, #224]	; 0xe0
    4c58:	b12b      	cbz	r3, 4c66 <lv_draw_label+0x232>
            pos.x += x_ofs;
    4c5a:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    4c5e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    4c60:	4413      	add	r3, r2
    4c62:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
        i         = 0;
    4c66:	2700      	movs	r7, #0
    4c68:	9715      	str	r7, [sp, #84]	; 0x54
        while(i < line_end - line_start) {
    4c6a:	9915      	ldr	r1, [sp, #84]	; 0x54
    4c6c:	eba8 0304 	sub.w	r3, r8, r4
    4c70:	428b      	cmp	r3, r1
    4c72:	d83b      	bhi.n	4cec <lv_draw_label+0x2b8>
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
    4c74:	9b36      	ldr	r3, [sp, #216]	; 0xd8
    4c76:	9904      	ldr	r1, [sp, #16]
    4c78:	f8cd b000 	str.w	fp, [sp]
    4c7c:	eb03 0408 	add.w	r4, r3, r8
    4c80:	f9b5 2038 	ldrsh.w	r2, [r5, #56]	; 0x38
    4c84:	9b08      	ldr	r3, [sp, #32]
    4c86:	4620      	mov	r0, r4
    4c88:	f000 fe66 	bl	5958 <lv_txt_get_next_line>
        pos.x = coords->x1;
    4c8c:	8833      	ldrh	r3, [r6, #0]
    4c8e:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
        if(flag & LV_TXT_FLAG_CENTER) {
    4c92:	9b12      	ldr	r3, [sp, #72]	; 0x48
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
    4c94:	4601      	mov	r1, r0
    4c96:	eb00 0708 	add.w	r7, r0, r8
        if(flag & LV_TXT_FLAG_CENTER) {
    4c9a:	2b00      	cmp	r3, #0
    4c9c:	f000 80ef 	beq.w	4e7e <lv_draw_label+0x44a>
                    lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
    4ca0:	f9b5 3038 	ldrsh.w	r3, [r5, #56]	; 0x38
    4ca4:	9a04      	ldr	r2, [sp, #16]
    4ca6:	f8cd b000 	str.w	fp, [sp]
    4caa:	4620      	mov	r0, r4
    4cac:	f000 fe04 	bl	58b8 <lv_txt_get_width>
    4cb0:	88b3      	ldrh	r3, [r6, #4]
    4cb2:	8832      	ldrh	r2, [r6, #0]
    4cb4:	3301      	adds	r3, #1
    4cb6:	1a9b      	subs	r3, r3, r2
            pos.x += (lv_area_get_width(coords) - line_width) / 2;
    4cb8:	b21b      	sxth	r3, r3
    4cba:	1a18      	subs	r0, r3, r0
    4cbc:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    4cc0:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
    4cc4:	eb03 0060 	add.w	r0, r3, r0, asr #1
            pos.x += lv_area_get_width(coords) - line_width;
    4cc8:	f8ad 0050 	strh.w	r0, [sp, #80]	; 0x50
        pos.y += line_height;
    4ccc:	f8bd 3052 	ldrh.w	r3, [sp, #82]	; 0x52
    4cd0:	9a07      	ldr	r2, [sp, #28]
    4cd2:	4413      	add	r3, r2
        if(pos.y > mask->y2) return;
    4cd4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    4cd6:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
        pos.y += line_height;
    4cda:	b21b      	sxth	r3, r3
        if(pos.y > mask->y2) return;
    4cdc:	429a      	cmp	r2, r3
        pos.y += line_height;
    4cde:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
        line_start = line_end;
    4ce2:	4644      	mov	r4, r8
        if(pos.y > mask->y2) return;
    4ce4:	f6ff af5c 	blt.w	4ba0 <lv_draw_label+0x16c>
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
    4ce8:	46b8      	mov	r8, r7
    4cea:	e752      	b.n	4b92 <lv_draw_label+0x15e>
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
    4cec:	9a06      	ldr	r2, [sp, #24]
    4cee:	f64f 73ff 	movw	r3, #65535	; 0xffff
    4cf2:	429a      	cmp	r2, r3
    4cf4:	d026      	beq.n	4d44 <lv_draw_label+0x310>
    4cf6:	9a05      	ldr	r2, [sp, #20]
    4cf8:	429a      	cmp	r2, r3
    4cfa:	d023      	beq.n	4d44 <lv_draw_label+0x310>
                logical_char_pos = lv_txt_encoded_get_char_id(txt, line_start + i);
    4cfc:	4b39      	ldr	r3, [pc, #228]	; (4de4 <lv_draw_label+0x3b0>)
    4cfe:	9836      	ldr	r0, [sp, #216]	; 0xd8
    4d00:	681b      	ldr	r3, [r3, #0]
    4d02:	4421      	add	r1, r4
    4d04:	4798      	blx	r3
    4d06:	b283      	uxth	r3, r0
            letter      = lv_txt_encoded_next(bidi_txt, &i);
    4d08:	f8df 90dc 	ldr.w	r9, [pc, #220]	; 4de8 <lv_draw_label+0x3b4>
    4d0c:	980c      	ldr	r0, [sp, #48]	; 0x30
    4d0e:	f8d9 2000 	ldr.w	r2, [r9]
    4d12:	9310      	str	r3, [sp, #64]	; 0x40
    4d14:	a915      	add	r1, sp, #84	; 0x54
    4d16:	4790      	blx	r2
            letter_next = lv_txt_encoded_next(&bidi_txt[i], NULL);
    4d18:	9b0c      	ldr	r3, [sp, #48]	; 0x30
            letter      = lv_txt_encoded_next(bidi_txt, &i);
    4d1a:	900a      	str	r0, [sp, #40]	; 0x28
            letter_next = lv_txt_encoded_next(&bidi_txt[i], NULL);
    4d1c:	9815      	ldr	r0, [sp, #84]	; 0x54
    4d1e:	f8d9 2000 	ldr.w	r2, [r9]
    4d22:	2100      	movs	r1, #0
    4d24:	4418      	add	r0, r3
    4d26:	4790      	blx	r2
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    4d28:	e9dd 3110 	ldrd	r3, r1, [sp, #64]	; 0x40
            letter_next = lv_txt_encoded_next(&bidi_txt[i], NULL);
    4d2c:	4602      	mov	r2, r0
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    4d2e:	2900      	cmp	r1, #0
    4d30:	d051      	beq.n	4dd6 <lv_draw_label+0x3a2>
                if(letter == (uint32_t)LV_TXT_COLOR_CMD[0]) {
    4d32:	990a      	ldr	r1, [sp, #40]	; 0x28
    4d34:	2923      	cmp	r1, #35	; 0x23
    4d36:	d10d      	bne.n	4d54 <lv_draw_label+0x320>
                    if(cmd_state == CMD_STATE_WAIT) { /*Start char*/
    4d38:	b937      	cbnz	r7, 4d48 <lv_draw_label+0x314>
                        par_start = i;
    4d3a:	f8bd 3054 	ldrh.w	r3, [sp, #84]	; 0x54
    4d3e:	930d      	str	r3, [sp, #52]	; 0x34
                        cmd_state = CMD_STATE_PAR;
    4d40:	9f11      	ldr	r7, [sp, #68]	; 0x44
                        continue;
    4d42:	e792      	b.n	4c6a <lv_draw_label+0x236>
            uint16_t logical_char_pos = 0;
    4d44:	2300      	movs	r3, #0
    4d46:	e7df      	b.n	4d08 <lv_draw_label+0x2d4>
                    } else if(cmd_state == CMD_STATE_PAR) { /*Other start char in parameter escaped cmd. char */
    4d48:	2f01      	cmp	r7, #1
    4d4a:	d04f      	beq.n	4dec <lv_draw_label+0x3b8>
                    } else if(cmd_state == CMD_STATE_IN) { /*Command end */
    4d4c:	2f02      	cmp	r7, #2
    4d4e:	d14e      	bne.n	4dee <lv_draw_label+0x3ba>
                        cmd_state = CMD_STATE_WAIT;
    4d50:	2700      	movs	r7, #0
    4d52:	e78a      	b.n	4c6a <lv_draw_label+0x236>
                if(cmd_state == CMD_STATE_PAR) {
    4d54:	2f01      	cmp	r7, #1
    4d56:	d13e      	bne.n	4dd6 <lv_draw_label+0x3a2>
                    if(letter == ' ') {
    4d58:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4d5a:	2b20      	cmp	r3, #32
    4d5c:	d185      	bne.n	4c6a <lv_draw_label+0x236>
                        if(i - par_start == LABEL_RECOLOR_PAR_LENGTH + 1) {
    4d5e:	9b15      	ldr	r3, [sp, #84]	; 0x54
    4d60:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    4d62:	1a9b      	subs	r3, r3, r2
    4d64:	2b07      	cmp	r3, #7
    4d66:	d133      	bne.n	4dd0 <lv_draw_label+0x39c>
                            memcpy(buf, &bidi_txt[par_start], LABEL_RECOLOR_PAR_LENGTH);
    4d68:	e9dd 310c 	ldrd	r3, r1, [sp, #48]	; 0x30
    4d6c:	2206      	movs	r2, #6
    4d6e:	1859      	adds	r1, r3, r1
    4d70:	a816      	add	r0, sp, #88	; 0x58
    4d72:	f003 f99b 	bl	80ac <memcpy>
                            r       = (hex_char_to_num(buf[0]) << 4) + hex_char_to_num(buf[1]);
    4d76:	f89d 0058 	ldrb.w	r0, [sp, #88]	; 0x58
    4d7a:	f7ff fe47 	bl	4a0c <hex_char_to_num>
    4d7e:	4601      	mov	r1, r0
    4d80:	f89d 0059 	ldrb.w	r0, [sp, #89]	; 0x59
    4d84:	f7ff fe42 	bl	4a0c <hex_char_to_num>
    4d88:	eb00 1101 	add.w	r1, r0, r1, lsl #4
                            g       = (hex_char_to_num(buf[2]) << 4) + hex_char_to_num(buf[3]);
    4d8c:	f89d 005a 	ldrb.w	r0, [sp, #90]	; 0x5a
    4d90:	f7ff fe3c 	bl	4a0c <hex_char_to_num>
    4d94:	4607      	mov	r7, r0
    4d96:	f89d 005b 	ldrb.w	r0, [sp, #91]	; 0x5b
    4d9a:	f7ff fe37 	bl	4a0c <hex_char_to_num>
    4d9e:	eb00 1707 	add.w	r7, r0, r7, lsl #4
                            b       = (hex_char_to_num(buf[4]) << 4) + hex_char_to_num(buf[5]);
    4da2:	f89d 005c 	ldrb.w	r0, [sp, #92]	; 0x5c
    4da6:	f7ff fe31 	bl	4a0c <hex_char_to_num>
    4daa:	4681      	mov	r9, r0
    4dac:	f89d 005d 	ldrb.w	r0, [sp, #93]	; 0x5d
    4db0:	f7ff fe2c 	bl	4a0c <hex_char_to_num>
    4db4:	eb00 1009 	add.w	r0, r0, r9, lsl #4
    4db8:	f360 0a07 	bfi	sl, r0, #0, #8
    4dbc:	f367 2a0f 	bfi	sl, r7, #8, #8
    4dc0:	f361 4a17 	bfi	sl, r1, #16, #8
    4dc4:	f04a 4a7f 	orr.w	sl, sl, #4278190080	; 0xff000000
    4dc8:	f8cd a03c 	str.w	sl, [sp, #60]	; 0x3c
                        cmd_state = CMD_STATE_IN; /*After the parameter the text is in the command*/
    4dcc:	2702      	movs	r7, #2
    4dce:	e74c      	b.n	4c6a <lv_draw_label+0x236>
                            recolor.full = style->text.color.full;
    4dd0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    4dd2:	930f      	str	r3, [sp, #60]	; 0x3c
    4dd4:	e7fa      	b.n	4dcc <lv_draw_label+0x398>
            if(cmd_state == CMD_STATE_IN) color = recolor;
    4dd6:	2f02      	cmp	r7, #2
    4dd8:	d109      	bne.n	4dee <lv_draw_label+0x3ba>
    4dda:	990f      	ldr	r1, [sp, #60]	; 0x3c
    4ddc:	e008      	b.n	4df0 <lv_draw_label+0x3bc>
    4dde:	bf00      	nop
    4de0:	20000be0 	.word	0x20000be0
    4de4:	200068bc 	.word	0x200068bc
    4de8:	200068c0 	.word	0x200068c0
                        cmd_state = CMD_STATE_WAIT;
    4dec:	2700      	movs	r7, #0
            lv_color_t color = style->text.color;
    4dee:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
            if(cmd_state == CMD_STATE_IN) color = recolor;
    4df0:	9110      	str	r1, [sp, #64]	; 0x40
            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
    4df2:	9804      	ldr	r0, [sp, #16]
    4df4:	990a      	ldr	r1, [sp, #40]	; 0x28
    4df6:	9313      	str	r3, [sp, #76]	; 0x4c
    4df8:	f005 fede 	bl	abb8 <lv_font_get_glyph_width>
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
    4dfc:	9b06      	ldr	r3, [sp, #24]
    4dfe:	f64f 72ff 	movw	r2, #65535	; 0xffff
    4e02:	4293      	cmp	r3, r2
            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
    4e04:	fa0f f980 	sxth.w	r9, r0
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
    4e08:	d023      	beq.n	4e52 <lv_draw_label+0x41e>
    4e0a:	9b05      	ldr	r3, [sp, #20]
    4e0c:	4293      	cmp	r3, r2
    4e0e:	d020      	beq.n	4e52 <lv_draw_label+0x41e>
                if(logical_char_pos >= sel_start && logical_char_pos < sel_end) {
    4e10:	9b06      	ldr	r3, [sp, #24]
    4e12:	461a      	mov	r2, r3
    4e14:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4e16:	429a      	cmp	r2, r3
    4e18:	d81b      	bhi.n	4e52 <lv_draw_label+0x41e>
    4e1a:	9a05      	ldr	r2, [sp, #20]
    4e1c:	429a      	cmp	r2, r3
    4e1e:	d918      	bls.n	4e52 <lv_draw_label+0x41e>
                    sel_coords.x1 = pos.x;
    4e20:	f9bd 3050 	ldrsh.w	r3, [sp, #80]	; 0x50
                    sel_coords.x2 = pos.x + letter_w + style->text.letter_space - 1;
    4e24:	8f29      	ldrh	r1, [r5, #56]	; 0x38
                    sel_coords.x1 = pos.x;
    4e26:	f8ad 3058 	strh.w	r3, [sp, #88]	; 0x58
                    sel_coords.x2 = pos.x + letter_w + style->text.letter_space - 1;
    4e2a:	3b01      	subs	r3, #1
    4e2c:	440b      	add	r3, r1
                    sel_coords.y1 = pos.y;
    4e2e:	f9bd 2052 	ldrsh.w	r2, [sp, #82]	; 0x52
    4e32:	f8ad 205a 	strh.w	r2, [sp, #90]	; 0x5a
                    sel_coords.x2 = pos.x + letter_w + style->text.letter_space - 1;
    4e36:	444b      	add	r3, r9
    4e38:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
                    sel_coords.y2 = pos.y + line_height - 1;
    4e3c:	9b07      	ldr	r3, [sp, #28]
                    lv_draw_rect(&sel_coords, mask, &sel_style, opa);
    4e3e:	990b      	ldr	r1, [sp, #44]	; 0x2c
                    sel_coords.y2 = pos.y + line_height - 1;
    4e40:	3a01      	subs	r2, #1
    4e42:	441a      	add	r2, r3
    4e44:	f8ad 205e 	strh.w	r2, [sp, #94]	; 0x5e
                    lv_draw_rect(&sel_coords, mask, &sel_style, opa);
    4e48:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4e4a:	aa18      	add	r2, sp, #96	; 0x60
    4e4c:	a816      	add	r0, sp, #88	; 0x58
    4e4e:	f004 fb19 	bl	9484 <lv_draw_rect>
            lv_draw_letter(&pos, mask, font, letter, color, opa);
    4e52:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4e54:	9301      	str	r3, [sp, #4]
    4e56:	9b10      	ldr	r3, [sp, #64]	; 0x40
    4e58:	9300      	str	r3, [sp, #0]
    4e5a:	9a04      	ldr	r2, [sp, #16]
    4e5c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4e5e:	990b      	ldr	r1, [sp, #44]	; 0x2c
    4e60:	a814      	add	r0, sp, #80	; 0x50
    4e62:	f7ff fb67 	bl	4534 <lv_draw_letter>
            if(letter_w > 0) {
    4e66:	f1b9 0f00 	cmp.w	r9, #0
    4e6a:	f77f aefe 	ble.w	4c6a <lv_draw_label+0x236>
                pos.x += letter_w + style->text.letter_space;
    4e6e:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    4e72:	8f2a      	ldrh	r2, [r5, #56]	; 0x38
    4e74:	4413      	add	r3, r2
    4e76:	4499      	add	r9, r3
    4e78:	f8ad 9050 	strh.w	r9, [sp, #80]	; 0x50
    4e7c:	e6f5      	b.n	4c6a <lv_draw_label+0x236>
        else if(flag & LV_TXT_FLAG_RIGHT) {
    4e7e:	f01b 0f08 	tst.w	fp, #8
    4e82:	f43f af23 	beq.w	4ccc <lv_draw_label+0x298>
                    lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
    4e86:	f9b5 3038 	ldrsh.w	r3, [r5, #56]	; 0x38
    4e8a:	9a04      	ldr	r2, [sp, #16]
    4e8c:	f8cd b000 	str.w	fp, [sp]
    4e90:	4620      	mov	r0, r4
    4e92:	f000 fd11 	bl	58b8 <lv_txt_get_width>
            pos.x += lv_area_get_width(coords) - line_width;
    4e96:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    4e9a:	88b2      	ldrh	r2, [r6, #4]
    4e9c:	3301      	adds	r3, #1
    4e9e:	4413      	add	r3, r2
    4ea0:	8832      	ldrh	r2, [r6, #0]
    4ea2:	1a9b      	subs	r3, r3, r2
    4ea4:	1a18      	subs	r0, r3, r0
    4ea6:	e70f      	b.n	4cc8 <lv_draw_label+0x294>
    if(hint && y_ofs == 0 && coords->y1 < 0) {
    4ea8:	2f00      	cmp	r7, #0
    4eaa:	f47f ae8e 	bne.w	4bca <lv_draw_label+0x196>
    lv_coord_t x_ofs = 0;
    4eae:	970e      	str	r7, [sp, #56]	; 0x38
    uint32_t line_start     = 0;
    4eb0:	2400      	movs	r4, #0
    4eb2:	e615      	b.n	4ae0 <lv_draw_label+0xac>

00004eb4 <lv_img_color_format_get_px_size>:
 */
uint8_t lv_img_color_format_get_px_size(lv_img_cf_t cf)
{
    uint8_t px_size = 0;

    switch(cf) {
    4eb4:	3804      	subs	r0, #4
    4eb6:	b2c0      	uxtb	r0, r0
    4eb8:	280a      	cmp	r0, #10
    4eba:	bf9a      	itte	ls
    4ebc:	4b01      	ldrls	r3, [pc, #4]	; (4ec4 <lv_img_color_format_get_px_size+0x10>)
    4ebe:	5c18      	ldrbls	r0, [r3, r0]
{
    4ec0:	2000      	movhi	r0, #0
        case LV_IMG_CF_ALPHA_8BIT: px_size = 8; break;
        default: px_size = 0; break;
    }

    return px_size;
}
    4ec2:	4770      	bx	lr
    4ec4:	0000c382 	.word	0x0000c382

00004ec8 <lv_img_decoder_built_in_open>:
 * @param decoder the decoder where this function belongs
 * @param dsc pointer to decoder descriptor. `src`, `style` are already initialized in it.
 * @return LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error.
 */
lv_res_t lv_img_decoder_built_in_open(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)
{
    4ec8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    /*Open the file if it's a file*/
    if(dsc->src_type == LV_IMG_SRC_FILE) {
    4ecc:	7b0a      	ldrb	r2, [r1, #12]
    4ece:	2a01      	cmp	r2, #1
{
    4ed0:	460c      	mov	r4, r1
    if(dsc->src_type == LV_IMG_SRC_FILE) {
    4ed2:	d108      	bne.n	4ee6 <lv_img_decoder_built_in_open+0x1e>
        }

        memcpy(user_data->f, &f, sizeof(f));

#else
        LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
    4ed4:	4b3b      	ldr	r3, [pc, #236]	; (4fc4 <lv_img_decoder_built_in_open+0xfc>)
    4ed6:	f240 1261 	movw	r2, #353	; 0x161
    /*Unknown format. Can't decode it.*/
    else {
        /*Free the potentially allocated memories*/
        lv_img_decoder_built_in_close(decoder, dsc);

        LV_LOG_WARN("Image decoder open: unknown color format")
    4eda:	2002      	movs	r0, #2
    4edc:	493a      	ldr	r1, [pc, #232]	; (4fc8 <lv_img_decoder_built_in_open+0x100>)
    4ede:	f000 fe37 	bl	5b50 <lv_log_add>
        return LV_RES_INV;
    4ee2:	2000      	movs	r0, #0
    4ee4:	e00b      	b.n	4efe <lv_img_decoder_built_in_open+0x36>
    lv_img_cf_t cf = dsc->header.cf;
    4ee6:	7c0b      	ldrb	r3, [r1, #16]
    4ee8:	f003 031f 	and.w	r3, r3, #31
    if(cf == LV_IMG_CF_TRUE_COLOR || cf == LV_IMG_CF_TRUE_COLOR_ALPHA || cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
    4eec:	1f1d      	subs	r5, r3, #4
    4eee:	2d02      	cmp	r5, #2
    4ef0:	d807      	bhi.n	4f02 <lv_img_decoder_built_in_open+0x3a>
        if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
    4ef2:	2a00      	cmp	r2, #0
    4ef4:	d144      	bne.n	4f80 <lv_img_decoder_built_in_open+0xb8>
            dsc->img_data = ((lv_img_dsc_t *)dsc->src)->data;
    4ef6:	684b      	ldr	r3, [r1, #4]
    4ef8:	689b      	ldr	r3, [r3, #8]
            dsc->img_data = NULL;
    4efa:	6163      	str	r3, [r4, #20]
            return LV_RES_OK;
    4efc:	2001      	movs	r0, #1
    }
}
    4efe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if(cf == LV_IMG_CF_INDEXED_1BIT || cf == LV_IMG_CF_INDEXED_2BIT || cf == LV_IMG_CF_INDEXED_4BIT ||
    4f02:	1fda      	subs	r2, r3, #7
    4f04:	2a03      	cmp	r2, #3
    4f06:	d853      	bhi.n	4fb0 <lv_img_decoder_built_in_open+0xe8>
        uint8_t px_size       = lv_img_color_format_get_px_size(cf);
    4f08:	4618      	mov	r0, r3
    4f0a:	f7ff ffd3 	bl	4eb4 <lv_img_color_format_get_px_size>
        if(dsc->user_data == NULL) {
    4f0e:	6a23      	ldr	r3, [r4, #32]
        uint32_t palette_size = 1 << px_size;
    4f10:	2601      	movs	r6, #1
        uint8_t px_size       = lv_img_color_format_get_px_size(cf);
    4f12:	4607      	mov	r7, r0
        uint32_t palette_size = 1 << px_size;
    4f14:	4086      	lsls	r6, r0
        if(dsc->user_data == NULL) {
    4f16:	b983      	cbnz	r3, 4f3a <lv_img_decoder_built_in_open+0x72>
            dsc->user_data = lv_mem_alloc(sizeof(lv_img_decoder_built_in_data_t));
    4f18:	2008      	movs	r0, #8
    4f1a:	f000 fc57 	bl	57cc <lv_mem_alloc>
    4f1e:	6220      	str	r0, [r4, #32]
            if(dsc->user_data == NULL) {
    4f20:	b930      	cbnz	r0, 4f30 <lv_img_decoder_built_in_open+0x68>
                LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
    4f22:	4b2a      	ldr	r3, [pc, #168]	; (4fcc <lv_img_decoder_built_in_open+0x104>)
    4f24:	4928      	ldr	r1, [pc, #160]	; (4fc8 <lv_img_decoder_built_in_open+0x100>)
    4f26:	f44f 72c0 	mov.w	r2, #384	; 0x180
    4f2a:	2003      	movs	r0, #3
    4f2c:	f000 fe10 	bl	5b50 <lv_log_add>
            memset(dsc->user_data, 0, sizeof(lv_img_decoder_built_in_data_t));
    4f30:	2208      	movs	r2, #8
    4f32:	2100      	movs	r1, #0
    4f34:	6a20      	ldr	r0, [r4, #32]
    4f36:	f003 f8e3 	bl	8100 <memset>
        user_data->palette                         = lv_mem_alloc(palette_size * sizeof(lv_color_t));
    4f3a:	2004      	movs	r0, #4
    4f3c:	40b8      	lsls	r0, r7
        lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
    4f3e:	6a25      	ldr	r5, [r4, #32]
        user_data->palette                         = lv_mem_alloc(palette_size * sizeof(lv_color_t));
    4f40:	f000 fc44 	bl	57cc <lv_mem_alloc>
    4f44:	6028      	str	r0, [r5, #0]
        user_data->opa                             = lv_mem_alloc(palette_size * sizeof(lv_opa_t));
    4f46:	4630      	mov	r0, r6
    4f48:	f000 fc40 	bl	57cc <lv_mem_alloc>
        if(user_data->palette == NULL || user_data->opa == NULL) {
    4f4c:	682b      	ldr	r3, [r5, #0]
        user_data->opa                             = lv_mem_alloc(palette_size * sizeof(lv_opa_t));
    4f4e:	6068      	str	r0, [r5, #4]
        if(user_data->palette == NULL || user_data->opa == NULL) {
    4f50:	b103      	cbz	r3, 4f54 <lv_img_decoder_built_in_open+0x8c>
    4f52:	b930      	cbnz	r0, 4f62 <lv_img_decoder_built_in_open+0x9a>
            LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
    4f54:	4b1d      	ldr	r3, [pc, #116]	; (4fcc <lv_img_decoder_built_in_open+0x104>)
    4f56:	491c      	ldr	r1, [pc, #112]	; (4fc8 <lv_img_decoder_built_in_open+0x100>)
    4f58:	f44f 72c5 	mov.w	r2, #394	; 0x18a
    4f5c:	2003      	movs	r0, #3
    4f5e:	f000 fdf7 	bl	5b50 <lv_log_add>
        if(dsc->src_type == LV_IMG_SRC_FILE) {
    4f62:	7b23      	ldrb	r3, [r4, #12]
    4f64:	2b01      	cmp	r3, #1
    4f66:	d103      	bne.n	4f70 <lv_img_decoder_built_in_open+0xa8>
            LV_LOG_WARN("Image built-in decoder can read the palette because LV_USE_FILESYSTEM = 0");
    4f68:	4b19      	ldr	r3, [pc, #100]	; (4fd0 <lv_img_decoder_built_in_open+0x108>)
    4f6a:	f44f 72ce 	mov.w	r2, #412	; 0x19c
    4f6e:	e7b4      	b.n	4eda <lv_img_decoder_built_in_open+0x12>
            lv_color32_t * palette_p = (lv_color32_t *)((lv_img_dsc_t *)dsc->src)->data;
    4f70:	6863      	ldr	r3, [r4, #4]
                user_data->palette[i] = lv_color_make(palette_p[i].ch.red, palette_p[i].ch.green, palette_p[i].ch.blue);
    4f72:	27ff      	movs	r7, #255	; 0xff
    4f74:	689a      	ldr	r2, [r3, #8]
            for(i = 0; i < palette_size; i++) {
    4f76:	2300      	movs	r3, #0
    4f78:	42b3      	cmp	r3, r6
    4f7a:	f102 0204 	add.w	r2, r2, #4
    4f7e:	d101      	bne.n	4f84 <lv_img_decoder_built_in_open+0xbc>
            dsc->img_data = NULL;
    4f80:	2300      	movs	r3, #0
    4f82:	e7ba      	b.n	4efa <lv_img_decoder_built_in_open+0x32>
                user_data->palette[i] = lv_color_make(palette_p[i].ch.red, palette_p[i].ch.green, palette_p[i].ch.blue);
    4f84:	6828      	ldr	r0, [r5, #0]
    4f86:	f812 8c04 	ldrb.w	r8, [r2, #-4]
    4f8a:	f812 cc02 	ldrb.w	ip, [r2, #-2]
    4f8e:	f812 ec03 	ldrb.w	lr, [r2, #-3]
    4f92:	f800 8023 	strb.w	r8, [r0, r3, lsl #2]
    4f96:	eb00 0183 	add.w	r1, r0, r3, lsl #2
    4f9a:	f881 e001 	strb.w	lr, [r1, #1]
    4f9e:	f881 c002 	strb.w	ip, [r1, #2]
    4fa2:	70cf      	strb	r7, [r1, #3]
                user_data->opa[i]     = palette_p[i].ch.alpha;
    4fa4:	6869      	ldr	r1, [r5, #4]
    4fa6:	f812 0c01 	ldrb.w	r0, [r2, #-1]
    4faa:	54c8      	strb	r0, [r1, r3]
            for(i = 0; i < palette_size; i++) {
    4fac:	3301      	adds	r3, #1
    4fae:	e7e3      	b.n	4f78 <lv_img_decoder_built_in_open+0xb0>
    else if(cf == LV_IMG_CF_ALPHA_1BIT || cf == LV_IMG_CF_ALPHA_2BIT || cf == LV_IMG_CF_ALPHA_4BIT ||
    4fb0:	3b0b      	subs	r3, #11
    4fb2:	2b03      	cmp	r3, #3
    4fb4:	d9e4      	bls.n	4f80 <lv_img_decoder_built_in_open+0xb8>
        lv_img_decoder_built_in_close(decoder, dsc);
    4fb6:	f005 f8dd 	bl	a174 <lv_img_decoder_built_in_close>
        LV_LOG_WARN("Image decoder open: unknown color format")
    4fba:	4b06      	ldr	r3, [pc, #24]	; (4fd4 <lv_img_decoder_built_in_open+0x10c>)
    4fbc:	f240 12c1 	movw	r2, #449	; 0x1c1
    4fc0:	e78b      	b.n	4eda <lv_img_decoder_built_in_open+0x12>
    4fc2:	bf00      	nop
    4fc4:	0000c3b3 	.word	0x0000c3b3
    4fc8:	0000c3f9 	.word	0x0000c3f9
    4fcc:	0000c436 	.word	0x0000c436
    4fd0:	0000c45f 	.word	0x0000c45f
    4fd4:	0000c4a9 	.word	0x0000c4a9

00004fd8 <lv_img_decoder_built_in_info>:
{
    4fd8:	b538      	push	{r3, r4, r5, lr}
    lv_img_src_t src_type = lv_img_src_get_type(src);
    4fda:	4608      	mov	r0, r1
{
    4fdc:	460d      	mov	r5, r1
    4fde:	4614      	mov	r4, r2
    lv_img_src_t src_type = lv_img_src_get_type(src);
    4fe0:	f005 f8b8 	bl	a154 <lv_img_src_get_type>
    if(src_type == LV_IMG_SRC_VARIABLE) {
    4fe4:	b9c0      	cbnz	r0, 5018 <lv_img_decoder_built_in_info+0x40>
        lv_img_cf_t cf = ((lv_img_dsc_t *)src)->header.cf;
    4fe6:	782b      	ldrb	r3, [r5, #0]
    4fe8:	f3c3 0304 	ubfx	r3, r3, #0, #5
        if(cf < CF_BUILT_IN_FIRST || cf > CF_BUILT_IN_LAST) return LV_RES_INV;
    4fec:	3b04      	subs	r3, #4
    4fee:	b2db      	uxtb	r3, r3
    4ff0:	2b0a      	cmp	r3, #10
    4ff2:	d810      	bhi.n	5016 <lv_img_decoder_built_in_info+0x3e>
        header->h  = ((lv_img_dsc_t *)src)->header.h;
    4ff4:	886b      	ldrh	r3, [r5, #2]
    4ff6:	8862      	ldrh	r2, [r4, #2]
        lv_img_cf_t cf = ((lv_img_dsc_t *)src)->header.cf;
    4ff8:	6829      	ldr	r1, [r5, #0]
        header->h  = ((lv_img_dsc_t *)src)->header.h;
    4ffa:	095b      	lsrs	r3, r3, #5
    4ffc:	f363 124f 	bfi	r2, r3, #5, #11
    5000:	8062      	strh	r2, [r4, #2]
        header->cf = ((lv_img_dsc_t *)src)->header.cf;
    5002:	6823      	ldr	r3, [r4, #0]
    5004:	4a0c      	ldr	r2, [pc, #48]	; (5038 <lv_img_decoder_built_in_info+0x60>)
    5006:	f023 131f 	bic.w	r3, r3, #2031647	; 0x1f001f
    500a:	f423 437c 	bic.w	r3, r3, #64512	; 0xfc00
    500e:	400a      	ands	r2, r1
        header->cf = LV_IMG_CF_ALPHA_1BIT;
    5010:	4313      	orrs	r3, r2
    5012:	6023      	str	r3, [r4, #0]
    return LV_RES_OK;
    5014:	2001      	movs	r0, #1
}
    5016:	bd38      	pop	{r3, r4, r5, pc}
    else if(src_type == LV_IMG_SRC_SYMBOL) {
    5018:	2802      	cmp	r0, #2
    501a:	d104      	bne.n	5026 <lv_img_decoder_built_in_info+0x4e>
        header->cf = LV_IMG_CF_ALPHA_1BIT;
    501c:	6823      	ldr	r3, [r4, #0]
    501e:	f403 7278 	and.w	r2, r3, #992	; 0x3e0
    5022:	4b06      	ldr	r3, [pc, #24]	; (503c <lv_img_decoder_built_in_info+0x64>)
    5024:	e7f4      	b.n	5010 <lv_img_decoder_built_in_info+0x38>
        LV_LOG_WARN("Image get info found unknown src type");
    5026:	2002      	movs	r0, #2
    5028:	4b05      	ldr	r3, [pc, #20]	; (5040 <lv_img_decoder_built_in_info+0x68>)
    502a:	4906      	ldr	r1, [pc, #24]	; (5044 <lv_img_decoder_built_in_info+0x6c>)
    502c:	f240 1231 	movw	r2, #305	; 0x131
    5030:	f000 fd8e 	bl	5b50 <lv_log_add>
    5034:	2000      	movs	r0, #0
    5036:	e7ee      	b.n	5016 <lv_img_decoder_built_in_info+0x3e>
    5038:	001ffc1f 	.word	0x001ffc1f
    503c:	0020040b 	.word	0x0020040b
    5040:	0000c38d 	.word	0x0000c38d
    5044:	0000c3f9 	.word	0x0000c3f9

00005048 <lv_img_decoder_built_in_read_line>:
 * @param buf a buffer to store the decoded pixels
 * @return LV_RES_OK: ok; LV_RES_INV: failed
 */
lv_res_t lv_img_decoder_built_in_read_line(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc, lv_coord_t x,
                                                  lv_coord_t y, lv_coord_t len, uint8_t * buf)
{
    5048:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    (void)decoder; /*Unused*/

    lv_res_t res = LV_RES_INV;

    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
    504c:	7c08      	ldrb	r0, [r1, #16]
{
    504e:	b087      	sub	sp, #28
    5050:	461e      	mov	r6, r3
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
    5052:	f000 031e 	and.w	r3, r0, #30
    5056:	2b04      	cmp	r3, #4
{
    5058:	460d      	mov	r5, r1
    505a:	4614      	mov	r4, r2
    505c:	f9bd 7038 	ldrsh.w	r7, [sp, #56]	; 0x38
    5060:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
    5064:	d003      	beq.n	506e <lv_img_decoder_built_in_read_line+0x26>
       dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
    5066:	f000 031f 	and.w	r3, r0, #31
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
    506a:	2b06      	cmp	r3, #6
    506c:	d10b      	bne.n	5086 <lv_img_decoder_built_in_read_line+0x3e>
        /* For TRUE_COLOR images read line required only for files.
         * For variables the image data was returned in `open`*/
        if(dsc->src_type == LV_IMG_SRC_FILE) {
    506e:	7b2b      	ldrb	r3, [r5, #12]
    5070:	2b01      	cmp	r3, #1
    5072:	d106      	bne.n	5082 <lv_img_decoder_built_in_read_line+0x3a>
        return LV_RES_INV;
    }

    return LV_RES_OK;
#else
    LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
    5074:	4b9d      	ldr	r3, [pc, #628]	; (52ec <lv_img_decoder_built_in_read_line+0x2a4>)
    5076:	f240 2225 	movw	r2, #549	; 0x225
        LV_LOG_WARN("Built-in image decoder read not supports the color format");
    507a:	499d      	ldr	r1, [pc, #628]	; (52f0 <lv_img_decoder_built_in_read_line+0x2a8>)
    507c:	2002      	movs	r0, #2
    507e:	f000 fd67 	bl	5b50 <lv_log_add>
    lv_res_t res = LV_RES_INV;
    5082:	2000      	movs	r0, #0
    5084:	e05c      	b.n	5140 <lv_img_decoder_built_in_read_line+0xf8>
    } else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
    5086:	f1a3 020b 	sub.w	r2, r3, #11
    508a:	2a03      	cmp	r2, #3
    508c:	f200 80a7 	bhi.w	51de <lv_img_decoder_built_in_read_line+0x196>
static lv_res_t lv_img_decoder_built_in_line_alpha(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                   lv_coord_t len, uint8_t * buf)
{

#if LV_IMG_CF_ALPHA
    const lv_opa_t alpha1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
    5090:	f44f 437f 	mov.w	r3, #65280	; 0xff00
    5094:	f8ad 3000 	strh.w	r3, [sp]
    const lv_opa_t alpha2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
    5098:	f5a3 03ad 	sub.w	r3, r3, #5668864	; 0x568000
    509c:	f5a3 5328 	sub.w	r3, r3, #10752	; 0x2a00
    50a0:	9301      	str	r3, [sp, #4]
    const lv_opa_t alpha4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
    50a2:	4b94      	ldr	r3, [pc, #592]	; (52f4 <lv_img_decoder_built_in_read_line+0x2ac>)
    50a4:	aa02      	add	r2, sp, #8
    50a6:	f103 0e10 	add.w	lr, r3, #16
    50aa:	4691      	mov	r9, r2
    50ac:	6818      	ldr	r0, [r3, #0]
    50ae:	6859      	ldr	r1, [r3, #4]
    50b0:	4694      	mov	ip, r2
    50b2:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    50b6:	3308      	adds	r3, #8
    50b8:	4573      	cmp	r3, lr
    50ba:	4662      	mov	r2, ip
    50bc:	d1f6      	bne.n	50ac <lv_img_decoder_built_in_read_line+0x64>
                                           68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255};

    /*Simply fill the buffer with the color. Later only the alpha value will be modified.*/
    lv_color_t bg_color = dsc->style->image.color;
    50be:	68ab      	ldr	r3, [r5, #8]
    50c0:	6c19      	ldr	r1, [r3, #64]	; 0x40
    50c2:	2300      	movs	r3, #0
    lv_coord_t i;
    for(i = 0; i < len; i++) {
    50c4:	b21a      	sxth	r2, r3
    50c6:	4297      	cmp	r7, r2
    50c8:	dc16      	bgt.n	50f8 <lv_img_decoder_built_in_read_line+0xb0>
#error "Invalid LV_COLOR_DEPTH. Check it in lv_conf.h"
#endif
    }

    const lv_opa_t * opa_table = NULL;
    uint8_t px_size            = lv_img_color_format_get_px_size(dsc->header.cf);
    50ca:	7c28      	ldrb	r0, [r5, #16]
    50cc:	f000 001f 	and.w	r0, r0, #31
    50d0:	f7ff fef0 	bl	4eb4 <lv_img_color_format_get_px_size>
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/

    lv_coord_t w = 0;
    uint32_t ofs = 0;
    int8_t pos   = 0;
    switch(dsc->header.cf) {
    50d4:	7c2b      	ldrb	r3, [r5, #16]
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    50d6:	f04f 0c01 	mov.w	ip, #1
    50da:	fa0c fc00 	lsl.w	ip, ip, r0
    switch(dsc->header.cf) {
    50de:	f003 031f 	and.w	r3, r3, #31
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    50e2:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    switch(dsc->header.cf) {
    50e6:	3b0b      	subs	r3, #11
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    50e8:	fa1f fc8c 	uxth.w	ip, ip
    switch(dsc->header.cf) {
    50ec:	2b03      	cmp	r3, #3
    50ee:	d856      	bhi.n	519e <lv_img_decoder_built_in_read_line+0x156>
    50f0:	e8df f003 	tbb	[pc, r3]
    50f4:	4d3b2906 	.word	0x4d3b2906
        *((uint32_t *)&buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE]) = bg_color.full;
    50f8:	f848 1023 	str.w	r1, [r8, r3, lsl #2]
    50fc:	3301      	adds	r3, #1
    50fe:	e7e1      	b.n	50c4 <lv_img_decoder_built_in_read_line+0x7c>
        case LV_IMG_CF_ALPHA_1BIT:
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
    5100:	6929      	ldr	r1, [r5, #16]
    5102:	f3c1 218a 	ubfx	r1, r1, #10, #11
    5106:	08cb      	lsrs	r3, r1, #3
            if(dsc->header.w & 0x7) w++;
    5108:	0749      	lsls	r1, r1, #29
            ofs += w * y + (x >> 3); /*First pixel*/
    510a:	ea4f 02e4 	mov.w	r2, r4, asr #3
            if(dsc->header.w & 0x7) w++;
    510e:	bf18      	it	ne
    5110:	3301      	addne	r3, #1
            pos       = 7 - (x & 0x7);
    5112:	43e4      	mvns	r4, r4
            ofs += w * y + (x >> 3); /*First pixel*/
    5114:	fb03 2306 	mla	r3, r3, r6, r2
            pos       = 7 - (x & 0x7);
    5118:	f004 0407 	and.w	r4, r4, #7
            opa_table = alpha1_opa_table;
    511c:	466e      	mov	r6, sp
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
    uint8_t fs_buf[LV_HOR_RES_MAX];
#endif

    const uint8_t * data_tmp = NULL;
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
    511e:	7b29      	ldrb	r1, [r5, #12]
    5120:	2900      	cmp	r1, #0
    5122:	d13f      	bne.n	51a4 <lv_img_decoder_built_in_read_line+0x15c>
        const lv_img_dsc_t * img_dsc = dsc->src;

        data_tmp = img_dsc->data + ofs;
    5124:	686a      	ldr	r2, [r5, #4]
        val_act = (data_tmp[byte_act] & (mask << pos)) >> pos;

        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];

        pos -= px_size;
    5126:	b240      	sxtb	r0, r0
        data_tmp = img_dsc->data + ofs;
    5128:	6892      	ldr	r2, [r2, #8]
        if(pos < 0) {
            pos = 8 - px_size;
    512a:	f1c0 0e08 	rsb	lr, r0, #8
        data_tmp = img_dsc->data + ofs;
    512e:	4413      	add	r3, r2
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
    5130:	f108 0803 	add.w	r8, r8, #3
            pos = 8 - px_size;
    5134:	fa4f fe8e 	sxtb.w	lr, lr
    for(i = 0; i < len; i++) {
    5138:	b20a      	sxth	r2, r1
    513a:	4297      	cmp	r7, r2
    513c:	dc36      	bgt.n	51ac <lv_img_decoder_built_in_read_line+0x164>
            pos = 8 - px_size;
            data_tmp++;
        }
    }

    return LV_RES_OK;
    513e:	2001      	movs	r0, #1
}
    5140:	b007      	add	sp, #28
    5142:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
    5146:	6929      	ldr	r1, [r5, #16]
    5148:	f3c1 218a 	ubfx	r1, r1, #10, #11
    514c:	088b      	lsrs	r3, r1, #2
            if(dsc->header.w & 0x3) w++;
    514e:	078a      	lsls	r2, r1, #30
            ofs += w * y + (x >> 2); /*First pixel*/
    5150:	ea4f 02a4 	mov.w	r2, r4, asr #2
            pos       = 6 - ((x & 0x3) * 2);
    5154:	ea6f 0404 	mvn.w	r4, r4
            if(dsc->header.w & 0x3) w++;
    5158:	bf18      	it	ne
    515a:	3301      	addne	r3, #1
            pos       = 6 - ((x & 0x3) * 2);
    515c:	f004 0403 	and.w	r4, r4, #3
            ofs += w * y + (x >> 2); /*First pixel*/
    5160:	fb03 2306 	mla	r3, r3, r6, r2
            pos       = 6 - ((x & 0x3) * 2);
    5164:	0064      	lsls	r4, r4, #1
            opa_table = alpha2_opa_table;
    5166:	ae01      	add	r6, sp, #4
    5168:	e7d9      	b.n	511e <lv_img_decoder_built_in_read_line+0xd6>
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
    516a:	692b      	ldr	r3, [r5, #16]
    516c:	f3c3 218a 	ubfx	r1, r3, #10, #11
    5170:	084b      	lsrs	r3, r1, #1
            if(dsc->header.w & 0x1) w++;
    5172:	07c9      	lsls	r1, r1, #31
            ofs += w * y + (x >> 1); /*First pixel*/
    5174:	ea4f 0264 	mov.w	r2, r4, asr #1
            if(dsc->header.w & 0x1) w++;
    5178:	bf48      	it	mi
    517a:	3301      	addmi	r3, #1
            pos       = 4 - ((x & 0x1) * 4);
    517c:	f014 0f01 	tst.w	r4, #1
            ofs += w * y + (x >> 1); /*First pixel*/
    5180:	fb03 2306 	mla	r3, r3, r6, r2
            pos       = 4 - ((x & 0x1) * 4);
    5184:	bf0c      	ite	eq
    5186:	2404      	moveq	r4, #4
    5188:	2400      	movne	r4, #0
    518a:	464e      	mov	r6, r9
    518c:	e7c7      	b.n	511e <lv_img_decoder_built_in_read_line+0xd6>
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
    518e:	692b      	ldr	r3, [r5, #16]
    5190:	f3c3 238a 	ubfx	r3, r3, #10, #11
            ofs += w * y + x;  /*First pixel*/
    5194:	fb16 4303 	smlabb	r3, r6, r3, r4
            pos = 0;
    5198:	2400      	movs	r4, #0
    const lv_opa_t * opa_table = NULL;
    519a:	4626      	mov	r6, r4
    519c:	e7bf      	b.n	511e <lv_img_decoder_built_in_read_line+0xd6>
    int8_t pos   = 0;
    519e:	2400      	movs	r4, #0
    uint32_t ofs = 0;
    51a0:	4623      	mov	r3, r4
    51a2:	e7fa      	b.n	519a <lv_img_decoder_built_in_read_line+0x152>
        LV_LOG_WARN("Image built-in alpha line reader can't read file because LV_USE_FILESYSTEM = 0");
    51a4:	4b54      	ldr	r3, [pc, #336]	; (52f8 <lv_img_decoder_built_in_read_line+0x2b0>)
    51a6:	f240 2279 	movw	r2, #633	; 0x279
    51aa:	e766      	b.n	507a <lv_img_decoder_built_in_read_line+0x32>
        val_act = (data_tmp[byte_act] & (mask << pos)) >> pos;
    51ac:	781a      	ldrb	r2, [r3, #0]
    51ae:	fa0c f904 	lsl.w	r9, ip, r4
    51b2:	ea02 0209 	and.w	r2, r2, r9
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];
    51b6:	f895 9010 	ldrb.w	r9, [r5, #16]
        val_act = (data_tmp[byte_act] & (mask << pos)) >> pos;
    51ba:	4122      	asrs	r2, r4
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
    51bc:	b2d2      	uxtb	r2, r2
    51be:	f009 091f 	and.w	r9, r9, #31
        pos -= px_size;
    51c2:	1a24      	subs	r4, r4, r0
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
    51c4:	f1b9 0f0e 	cmp.w	r9, #14
        pos -= px_size;
    51c8:	b264      	sxtb	r4, r4
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
    51ca:	bf18      	it	ne
    51cc:	5cb2      	ldrbne	r2, [r6, r2]
    51ce:	f808 2021 	strb.w	r2, [r8, r1, lsl #2]
        if(pos < 0) {
    51d2:	2c00      	cmp	r4, #0
            pos = 8 - px_size;
    51d4:	bfbc      	itt	lt
    51d6:	4674      	movlt	r4, lr
            data_tmp++;
    51d8:	3301      	addlt	r3, #1
    51da:	3101      	adds	r1, #1
    51dc:	e7ac      	b.n	5138 <lv_img_decoder_built_in_read_line+0xf0>
    } else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT || dsc->header.cf == LV_IMG_CF_INDEXED_2BIT ||
    51de:	3b07      	subs	r3, #7
    51e0:	2b03      	cmp	r3, #3
    51e2:	d87f      	bhi.n	52e4 <lv_img_decoder_built_in_read_line+0x29c>
    uint8_t px_size = lv_img_color_format_get_px_size(dsc->header.cf);
    51e4:	f000 001f 	and.w	r0, r0, #31
    51e8:	f7ff fe64 	bl	4eb4 <lv_img_color_format_get_px_size>
    switch(dsc->header.cf) {
    51ec:	7c2b      	ldrb	r3, [r5, #16]
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    51ee:	f04f 0c01 	mov.w	ip, #1
    51f2:	fa0c fc00 	lsl.w	ip, ip, r0
    switch(dsc->header.cf) {
    51f6:	f003 031f 	and.w	r3, r3, #31
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    51fa:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    switch(dsc->header.cf) {
    51fe:	3b07      	subs	r3, #7
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    5200:	fa1f fc8c 	uxth.w	ip, ip
    switch(dsc->header.cf) {
    5204:	2b03      	cmp	r3, #3
    5206:	d866      	bhi.n	52d6 <lv_img_decoder_built_in_read_line+0x28e>
    5208:	e8df f003 	tbb	[pc, r3]
    520c:	5c4a3a02 	.word	0x5c4a3a02
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
    5210:	692a      	ldr	r2, [r5, #16]
    5212:	f3c2 228a 	ubfx	r2, r2, #10, #11
    5216:	08d3      	lsrs	r3, r2, #3
            if(dsc->header.w & 0x7) w++;
    5218:	0752      	lsls	r2, r2, #29
    521a:	bf18      	it	ne
    521c:	3301      	addne	r3, #1
            ofs += w * y + (x >> 3); /*First pixel*/
    521e:	10e2      	asrs	r2, r4, #3
    5220:	fb03 2306 	mla	r3, r3, r6, r2
            pos = 7 - (x & 0x7);
    5224:	43e2      	mvns	r2, r4
            ofs += 8;                /*Skip the palette*/
    5226:	3308      	adds	r3, #8
            pos = 7 - (x & 0x7);
    5228:	f002 0207 	and.w	r2, r2, #7
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
    522c:	7b29      	ldrb	r1, [r5, #12]
    522e:	2900      	cmp	r1, #0
    5230:	d154      	bne.n	52dc <lv_img_decoder_built_in_read_line+0x294>
        data_tmp                     = img_dsc->data + ofs;
    5232:	686c      	ldr	r4, [r5, #4]
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
    5234:	6a2e      	ldr	r6, [r5, #32]
        data_tmp                     = img_dsc->data + ofs;
    5236:	68a4      	ldr	r4, [r4, #8]
        pos -= px_size;
    5238:	b240      	sxtb	r0, r0
            pos = 8 - px_size;
    523a:	f1c0 0e08 	rsb	lr, r0, #8
        data_tmp                     = img_dsc->data + ofs;
    523e:	4423      	add	r3, r4
    for(i = 0; i < len; i++) {
    5240:	f1a8 0804 	sub.w	r8, r8, #4
        data_tmp                     = img_dsc->data + ofs;
    5244:	460d      	mov	r5, r1
            pos = 8 - px_size;
    5246:	fa4f fe8e 	sxtb.w	lr, lr
    for(i = 0; i < len; i++) {
    524a:	b229      	sxth	r1, r5
    524c:	428f      	cmp	r7, r1
    524e:	f77f af76 	ble.w	513e <lv_img_decoder_built_in_read_line+0xf6>
        val_act = (*data_tmp & (mask << pos)) >> pos;
    5252:	7819      	ldrb	r1, [r3, #0]
    5254:	fa0c f402 	lsl.w	r4, ip, r2
    5258:	4021      	ands	r1, r4
    525a:	4111      	asrs	r1, r2
        lv_color_t color = user_data->palette[val_act];
    525c:	6834      	ldr	r4, [r6, #0]
    525e:	b2c9      	uxtb	r1, r1
        pos -= px_size;
    5260:	1a12      	subs	r2, r2, r0
        lv_color_t color = user_data->palette[val_act];
    5262:	f854 4021 	ldr.w	r4, [r4, r1, lsl #2]
        *((uint32_t *)&buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE]) = color.full;
    5266:	f848 4f04 	str.w	r4, [r8, #4]!
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] = user_data->opa[val_act];
    526a:	6874      	ldr	r4, [r6, #4]
        pos -= px_size;
    526c:	b252      	sxtb	r2, r2
        if(pos < 0) {
    526e:	2a00      	cmp	r2, #0
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] = user_data->opa[val_act];
    5270:	5c61      	ldrb	r1, [r4, r1]
    5272:	f888 1003 	strb.w	r1, [r8, #3]
            pos = 8 - px_size;
    5276:	bfbc      	itt	lt
    5278:	4672      	movlt	r2, lr
            data_tmp++;
    527a:	3301      	addlt	r3, #1
    527c:	3501      	adds	r5, #1
    527e:	e7e4      	b.n	524a <lv_img_decoder_built_in_read_line+0x202>
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
    5280:	692a      	ldr	r2, [r5, #16]
    5282:	f3c2 228a 	ubfx	r2, r2, #10, #11
    5286:	0893      	lsrs	r3, r2, #2
            if(dsc->header.w & 0x3) w++;
    5288:	0791      	lsls	r1, r2, #30
    528a:	bf18      	it	ne
    528c:	3301      	addne	r3, #1
            ofs += w * y + (x >> 2); /*First pixel*/
    528e:	10a2      	asrs	r2, r4, #2
    5290:	fb03 2306 	mla	r3, r3, r6, r2
            pos = 6 - ((x & 0x3) * 2);
    5294:	43e2      	mvns	r2, r4
    5296:	f002 0203 	and.w	r2, r2, #3
            ofs += 16;               /*Skip the palette*/
    529a:	3310      	adds	r3, #16
            pos = 6 - ((x & 0x3) * 2);
    529c:	0052      	lsls	r2, r2, #1
            break;
    529e:	e7c5      	b.n	522c <lv_img_decoder_built_in_read_line+0x1e4>
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
    52a0:	692a      	ldr	r2, [r5, #16]
    52a2:	f3c2 228a 	ubfx	r2, r2, #10, #11
    52a6:	0853      	lsrs	r3, r2, #1
            if(dsc->header.w & 0x1) w++;
    52a8:	07d2      	lsls	r2, r2, #31
    52aa:	bf48      	it	mi
    52ac:	3301      	addmi	r3, #1
            ofs += w * y + (x >> 1); /*First pixel*/
    52ae:	1062      	asrs	r2, r4, #1
    52b0:	fb03 2306 	mla	r3, r3, r6, r2
            pos = 4 - ((x & 0x1) * 4);
    52b4:	f014 0f01 	tst.w	r4, #1
            ofs += 64;               /*Skip the palette*/
    52b8:	f103 0340 	add.w	r3, r3, #64	; 0x40
            pos = 4 - ((x & 0x1) * 4);
    52bc:	bf0c      	ite	eq
    52be:	2204      	moveq	r2, #4
    52c0:	2200      	movne	r2, #0
    52c2:	e7b3      	b.n	522c <lv_img_decoder_built_in_read_line+0x1e4>
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
    52c4:	692b      	ldr	r3, [r5, #16]
    52c6:	f3c3 238a 	ubfx	r3, r3, #10, #11
            ofs += w * y + x;  /*First pixel*/
    52ca:	fb16 4303 	smlabb	r3, r6, r3, r4
            ofs += 1024;       /*Skip the palette*/
    52ce:	f503 6380 	add.w	r3, r3, #1024	; 0x400
            pos = 0;
    52d2:	2200      	movs	r2, #0
    52d4:	e7aa      	b.n	522c <lv_img_decoder_built_in_read_line+0x1e4>
    uint32_t ofs = 0;
    52d6:	2300      	movs	r3, #0
    int8_t pos   = 0;
    52d8:	461a      	mov	r2, r3
    52da:	e7a7      	b.n	522c <lv_img_decoder_built_in_read_line+0x1e4>
        LV_LOG_WARN("Image built-in indexed line reader can't read file because LV_USE_FILESYSTEM = 0");
    52dc:	4b07      	ldr	r3, [pc, #28]	; (52fc <lv_img_decoder_built_in_read_line+0x2b4>)
    52de:	f240 22ce 	movw	r2, #718	; 0x2ce
    52e2:	e6ca      	b.n	507a <lv_img_decoder_built_in_read_line+0x32>
        LV_LOG_WARN("Built-in image decoder read not supports the color format");
    52e4:	4b06      	ldr	r3, [pc, #24]	; (5300 <lv_img_decoder_built_in_read_line+0x2b8>)
    52e6:	f240 12e7 	movw	r2, #487	; 0x1e7
    52ea:	e6c6      	b.n	507a <lv_img_decoder_built_in_read_line+0x32>
    52ec:	0000c3b3 	.word	0x0000c3b3
    52f0:	0000c3f9 	.word	0x0000c3f9
    52f4:	0000b1f0 	.word	0x0000b1f0
    52f8:	0000c4d2 	.word	0x0000c4d2
    52fc:	0000c521 	.word	0x0000c521
    5300:	0000c572 	.word	0x0000c572

00005304 <lv_img_decoder_create>:
{
    5304:	b510      	push	{r4, lr}
    decoder = lv_ll_ins_head(&LV_GC_ROOT(_lv_img_defoder_ll));
    5306:	4805      	ldr	r0, [pc, #20]	; (531c <lv_img_decoder_create+0x18>)
    5308:	f005 f8af 	bl	a46a <lv_ll_ins_head>
    if(decoder == NULL) return NULL;
    530c:	4604      	mov	r4, r0
    530e:	b118      	cbz	r0, 5318 <lv_img_decoder_create+0x14>
    memset(decoder, 0, sizeof(lv_img_decoder_t));
    5310:	2214      	movs	r2, #20
    5312:	2100      	movs	r1, #0
    5314:	f002 fef4 	bl	8100 <memset>
}
    5318:	4620      	mov	r0, r4
    531a:	bd10      	pop	{r4, pc}
    531c:	20000e40 	.word	0x20000e40

00005320 <lv_img_decoder_init>:
{
    5320:	b510      	push	{r4, lr}
    lv_ll_init(&LV_GC_ROOT(_lv_img_defoder_ll), sizeof(lv_img_decoder_t));
    5322:	2114      	movs	r1, #20
    5324:	480b      	ldr	r0, [pc, #44]	; (5354 <lv_img_decoder_init+0x34>)
    5326:	f005 f896 	bl	a456 <lv_ll_init>
    decoder = lv_img_decoder_create();
    532a:	f7ff ffeb 	bl	5304 <lv_img_decoder_create>
    if(decoder == NULL) {
    532e:	b938      	cbnz	r0, 5340 <lv_img_decoder_init+0x20>
        LV_LOG_WARN("lv_img_decoder_init: out of memory");
    5330:	4b09      	ldr	r3, [pc, #36]	; (5358 <lv_img_decoder_init+0x38>)
    5332:	490a      	ldr	r1, [pc, #40]	; (535c <lv_img_decoder_init+0x3c>)
    5334:	2248      	movs	r2, #72	; 0x48
    5336:	2002      	movs	r0, #2
}
    5338:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        LV_LOG_WARN("lv_img_decoder_init: out of memory");
    533c:	f000 bc08 	b.w	5b50 <lv_log_add>
    decoder->info_cb = info_cb;
    5340:	4b07      	ldr	r3, [pc, #28]	; (5360 <lv_img_decoder_init+0x40>)
    5342:	6003      	str	r3, [r0, #0]
    decoder->open_cb = open_cb;
    5344:	4b07      	ldr	r3, [pc, #28]	; (5364 <lv_img_decoder_init+0x44>)
    5346:	6043      	str	r3, [r0, #4]
    decoder->read_line_cb = read_line_cb;
    5348:	4b07      	ldr	r3, [pc, #28]	; (5368 <lv_img_decoder_init+0x48>)
    534a:	6083      	str	r3, [r0, #8]
    decoder->close_cb = close_cb;
    534c:	4b07      	ldr	r3, [pc, #28]	; (536c <lv_img_decoder_init+0x4c>)
    534e:	60c3      	str	r3, [r0, #12]
}
    5350:	bd10      	pop	{r4, pc}
    5352:	bf00      	nop
    5354:	20000e40 	.word	0x20000e40
    5358:	0000c5ac 	.word	0x0000c5ac
    535c:	0000c3f9 	.word	0x0000c3f9
    5360:	00004fd9 	.word	0x00004fd9
    5364:	00004ec9 	.word	0x00004ec9
    5368:	00005049 	.word	0x00005049
    536c:	0000a175 	.word	0x0000a175

00005370 <lv_img_cache_invalidate_src>:
 * Invalidate an image source in the cache.
 * Useful if the image source is updated therefore it needs to be cached again.
 * @param src an image source path to a file or pointer to an `lv_img_dsc_t` variable.
 */
void lv_img_cache_invalidate_src(const void * src)
{
    5370:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
    5374:	4b12      	ldr	r3, [pc, #72]	; (53c0 <lv_img_cache_invalidate_src+0x50>)

    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
    5376:	4f13      	ldr	r7, [pc, #76]	; (53c4 <lv_img_cache_invalidate_src+0x54>)
    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
    5378:	f8d3 8000 	ldr.w	r8, [r3]
{
    537c:	4606      	mov	r6, r0
    for(i = 0; i < entry_cnt; i++) {
    537e:	2500      	movs	r5, #0
        if(cache[i].dec_dsc.src == src || src == NULL) {
    5380:	f04f 0928 	mov.w	r9, #40	; 0x28
    for(i = 0; i < entry_cnt; i++) {
    5384:	883a      	ldrh	r2, [r7, #0]
    5386:	b2ab      	uxth	r3, r5
    5388:	429a      	cmp	r2, r3
    538a:	d801      	bhi.n	5390 <lv_img_cache_invalidate_src+0x20>

            memset(&cache[i].dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
            memset(&cache[i], 0, sizeof(lv_img_cache_entry_t));
        }
    }
}
    538c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if(cache[i].dec_dsc.src == src || src == NULL) {
    5390:	b2ac      	uxth	r4, r5
    5392:	fb09 8404 	mla	r4, r9, r4, r8
    5396:	6863      	ldr	r3, [r4, #4]
    5398:	42b3      	cmp	r3, r6
    539a:	d000      	beq.n	539e <lv_img_cache_invalidate_src+0x2e>
    539c:	b96e      	cbnz	r6, 53ba <lv_img_cache_invalidate_src+0x4a>
            if(cache[i].dec_dsc.src != NULL) {
    539e:	b113      	cbz	r3, 53a6 <lv_img_cache_invalidate_src+0x36>
                lv_img_decoder_close(&cache[i].dec_dsc);
    53a0:	4620      	mov	r0, r4
    53a2:	f004 fef5 	bl	a190 <lv_img_decoder_close>
            memset(&cache[i].dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
    53a6:	2224      	movs	r2, #36	; 0x24
    53a8:	2100      	movs	r1, #0
    53aa:	4620      	mov	r0, r4
    53ac:	f002 fea8 	bl	8100 <memset>
            memset(&cache[i], 0, sizeof(lv_img_cache_entry_t));
    53b0:	2228      	movs	r2, #40	; 0x28
    53b2:	2100      	movs	r1, #0
    53b4:	4620      	mov	r0, r4
    53b6:	f002 fea3 	bl	8100 <memset>
    53ba:	3501      	adds	r5, #1
    53bc:	e7e2      	b.n	5384 <lv_img_cache_invalidate_src+0x14>
    53be:	bf00      	nop
    53c0:	20000e3c 	.word	0x20000e3c
    53c4:	20000f94 	.word	0x20000f94

000053c8 <lv_img_cache_set_size>:
{
    53c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(LV_GC_ROOT(_lv_img_cache_array) != NULL) {
    53cc:	4c17      	ldr	r4, [pc, #92]	; (542c <lv_img_cache_set_size+0x64>)
    53ce:	6823      	ldr	r3, [r4, #0]
{
    53d0:	4605      	mov	r5, r0
    if(LV_GC_ROOT(_lv_img_cache_array) != NULL) {
    53d2:	b12b      	cbz	r3, 53e0 <lv_img_cache_set_size+0x18>
        lv_img_cache_invalidate_src(NULL);
    53d4:	2000      	movs	r0, #0
    53d6:	f7ff ffcb 	bl	5370 <lv_img_cache_invalidate_src>
        lv_mem_free(LV_GC_ROOT(_lv_img_cache_array));
    53da:	6820      	ldr	r0, [r4, #0]
    53dc:	f000 fa1c 	bl	5818 <lv_mem_free>
    LV_GC_ROOT(_lv_img_cache_array) = lv_mem_alloc(sizeof(lv_img_cache_entry_t) * new_entry_cnt);
    53e0:	2728      	movs	r7, #40	; 0x28
    53e2:	fb07 f005 	mul.w	r0, r7, r5
    53e6:	f000 f9f1 	bl	57cc <lv_mem_alloc>
    53ea:	f8df 8044 	ldr.w	r8, [pc, #68]	; 5430 <lv_img_cache_set_size+0x68>
    53ee:	6020      	str	r0, [r4, #0]
    if(LV_GC_ROOT(_lv_img_cache_array) == NULL) {
    53f0:	b918      	cbnz	r0, 53fa <lv_img_cache_set_size+0x32>
        entry_cnt = 0;
    53f2:	f8a8 0000 	strh.w	r0, [r8]
}
    53f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    entry_cnt = new_entry_cnt;
    53fa:	f8a8 5000 	strh.w	r5, [r8]
    for(i = 0; i < entry_cnt; i++) {
    53fe:	2500      	movs	r5, #0
    5400:	f8b8 2000 	ldrh.w	r2, [r8]
    5404:	b2ab      	uxth	r3, r5
    5406:	429a      	cmp	r2, r3
    5408:	d9f5      	bls.n	53f6 <lv_img_cache_set_size+0x2e>
        memset(&LV_GC_ROOT(_lv_img_cache_array)[i].dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
    540a:	b2ae      	uxth	r6, r5
    540c:	6820      	ldr	r0, [r4, #0]
    540e:	437e      	muls	r6, r7
    5410:	2224      	movs	r2, #36	; 0x24
    5412:	2100      	movs	r1, #0
    5414:	4430      	add	r0, r6
    5416:	f002 fe73 	bl	8100 <memset>
        memset(&LV_GC_ROOT(_lv_img_cache_array)[i], 0, sizeof(lv_img_cache_entry_t));
    541a:	6820      	ldr	r0, [r4, #0]
    541c:	2228      	movs	r2, #40	; 0x28
    541e:	2100      	movs	r1, #0
    5420:	4430      	add	r0, r6
    5422:	f002 fe6d 	bl	8100 <memset>
    5426:	3501      	adds	r5, #1
    5428:	e7ea      	b.n	5400 <lv_img_cache_set_size+0x38>
    542a:	bf00      	nop
    542c:	20000e3c 	.word	0x20000e3c
    5430:	20000f94 	.word	0x20000f94

00005434 <lv_disp_drv_register>:
 * Automatically set the first display as active.
 * @param driver pointer to an initialized 'lv_disp_drv_t' variable (can be local variable)
 * @return pointer to the new display or NULL on error
 */
lv_disp_t * lv_disp_drv_register(lv_disp_drv_t * driver)
{
    5434:	b570      	push	{r4, r5, r6, lr}
    5436:	4605      	mov	r5, r0
    lv_disp_t * disp = lv_ll_ins_head(&LV_GC_ROOT(_lv_disp_ll));
    5438:	4828      	ldr	r0, [pc, #160]	; (54dc <lv_disp_drv_register+0xa8>)
    543a:	f005 f816 	bl	a46a <lv_ll_ins_head>
    if(!disp) {
    543e:	4604      	mov	r4, r0
    5440:	b910      	cbnz	r0, 5448 <lv_disp_drv_register+0x14>
        LV_ASSERT_MEM(disp);
        return NULL;
    5442:	2400      	movs	r4, #0
    if(disp->refr_task == NULL) return NULL;

    lv_task_ready(disp->refr_task); /*Be sure the screen will be refreshed immediately on start up*/

    return disp;
}
    5444:	4620      	mov	r0, r4
    5446:	bd70      	pop	{r4, r5, r6, pc}
    memcpy(&disp->driver, driver, sizeof(lv_disp_drv_t));
    5448:	4629      	mov	r1, r5
    544a:	2224      	movs	r2, #36	; 0x24
    544c:	f002 fe2e 	bl	80ac <memcpy>
    memset(&disp->inv_area_joined, 0, sizeof(disp->inv_area_joined));
    5450:	2220      	movs	r2, #32
    5452:	2100      	movs	r1, #0
    5454:	f504 70a0 	add.w	r0, r4, #320	; 0x140
    5458:	f002 fe52 	bl	8100 <memset>
    if(disp_def == NULL) disp_def = disp;
    545c:	4d20      	ldr	r5, [pc, #128]	; (54e0 <lv_disp_drv_register+0xac>)
    memset(&disp->inv_areas, 0, sizeof(disp->inv_areas));
    545e:	f44f 7280 	mov.w	r2, #256	; 0x100
    5462:	2100      	movs	r1, #0
    5464:	f104 0040 	add.w	r0, r4, #64	; 0x40
    5468:	f002 fe4a 	bl	8100 <memset>
    lv_ll_init(&disp->scr_ll, sizeof(lv_obj_t));
    546c:	2138      	movs	r1, #56	; 0x38
    546e:	f104 0028 	add.w	r0, r4, #40	; 0x28
    5472:	f004 fff0 	bl	a456 <lv_ll_init>
    if(disp_def == NULL) disp_def = disp;
    5476:	682b      	ldr	r3, [r5, #0]
    5478:	b903      	cbnz	r3, 547c <lv_disp_drv_register+0x48>
    547a:	602c      	str	r4, [r5, #0]
    disp->inv_p = 0;
    547c:	f8b4 3160 	ldrh.w	r3, [r4, #352]	; 0x160
    lv_disp_t * disp_def_tmp = disp_def;
    5480:	682e      	ldr	r6, [r5, #0]
    disp_def                 = disp; /*Temporarily change the default screen to create the default screens on the
    5482:	602c      	str	r4, [r5, #0]
    disp->inv_p = 0;
    5484:	f36f 0309 	bfc	r3, #0, #10
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
    5488:	2100      	movs	r1, #0
    disp->inv_p = 0;
    548a:	f8a4 3160 	strh.w	r3, [r4, #352]	; 0x160
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
    548e:	4608      	mov	r0, r1
    5490:	f7fe fb82 	bl	3b98 <lv_obj_create>
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
    5494:	2100      	movs	r1, #0
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
    5496:	6360      	str	r0, [r4, #52]	; 0x34
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
    5498:	4608      	mov	r0, r1
    549a:	f7fe fb7d 	bl	3b98 <lv_obj_create>
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
    549e:	2100      	movs	r1, #0
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
    54a0:	63a0      	str	r0, [r4, #56]	; 0x38
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
    54a2:	4608      	mov	r0, r1
    54a4:	f7fe fb78 	bl	3b98 <lv_obj_create>
    lv_obj_set_style(disp->top_layer, &lv_style_transp);
    54a8:	490e      	ldr	r1, [pc, #56]	; (54e4 <lv_disp_drv_register+0xb0>)
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
    54aa:	63e0      	str	r0, [r4, #60]	; 0x3c
    lv_obj_set_style(disp->top_layer, &lv_style_transp);
    54ac:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    54ae:	f003 fbfe 	bl	8cae <lv_obj_set_style>
    lv_obj_set_style(disp->sys_layer, &lv_style_transp);
    54b2:	490c      	ldr	r1, [pc, #48]	; (54e4 <lv_disp_drv_register+0xb0>)
    54b4:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    54b6:	f003 fbfa 	bl	8cae <lv_obj_set_style>
    lv_obj_invalidate(disp->act_scr);
    54ba:	6b60      	ldr	r0, [r4, #52]	; 0x34
    54bc:	f003 fae6 	bl	8a8c <lv_obj_invalidate>
    disp->refr_task = lv_task_create(lv_disp_refr_task, LV_DISP_DEF_REFR_PERIOD, LV_TASK_PRIO_MID, disp);
    54c0:	4623      	mov	r3, r4
    54c2:	2203      	movs	r2, #3
    54c4:	2132      	movs	r1, #50	; 0x32
    54c6:	4808      	ldr	r0, [pc, #32]	; (54e8 <lv_disp_drv_register+0xb4>)
    disp_def = disp_def_tmp; /*Revert the default display*/
    54c8:	602e      	str	r6, [r5, #0]
    disp->refr_task = lv_task_create(lv_disp_refr_task, LV_DISP_DEF_REFR_PERIOD, LV_TASK_PRIO_MID, disp);
    54ca:	f004 ff81 	bl	a3d0 <lv_task_create>
    54ce:	6260      	str	r0, [r4, #36]	; 0x24
    if(disp->refr_task == NULL) return NULL;
    54d0:	2800      	cmp	r0, #0
    54d2:	d0b6      	beq.n	5442 <lv_disp_drv_register+0xe>
    lv_task_ready(disp->refr_task); /*Be sure the screen will be refreshed immediately on start up*/
    54d4:	f004 ff90 	bl	a3f8 <lv_task_ready>
    return disp;
    54d8:	e7b4      	b.n	5444 <lv_disp_drv_register+0x10>
    54da:	bf00      	nop
    54dc:	20000e2c 	.word	0x20000e2c
    54e0:	20000e14 	.word	0x20000e14
    54e4:	20000d20 	.word	0x20000d20
    54e8:	00003f79 	.word	0x00003f79

000054ec <lv_disp_get_default>:
 * @return pointer to the default display
 */
lv_disp_t * lv_disp_get_default(void)
{
    return disp_def;
}
    54ec:	4b01      	ldr	r3, [pc, #4]	; (54f4 <lv_disp_get_default+0x8>)
    54ee:	6818      	ldr	r0, [r3, #0]
    54f0:	4770      	bx	lr
    54f2:	bf00      	nop
    54f4:	20000e14 	.word	0x20000e14

000054f8 <lv_disp_get_hor_res>:
 * @param disp pointer to a display (NULL to use the default display)
 * @return the horizontal resolution of the display
 */
lv_coord_t lv_disp_get_hor_res(lv_disp_t * disp)
{
    if(disp == NULL) disp = lv_disp_get_default();
    54f8:	b910      	cbnz	r0, 5500 <lv_disp_get_hor_res+0x8>
    return disp_def;
    54fa:	4b06      	ldr	r3, [pc, #24]	; (5514 <lv_disp_get_hor_res+0x1c>)
    54fc:	6818      	ldr	r0, [r3, #0]

    if(disp == NULL)
    54fe:	b138      	cbz	r0, 5510 <lv_disp_get_hor_res+0x18>
        return LV_HOR_RES_MAX;
    else
        return disp->driver.rotated == 0 ? disp->driver.hor_res : disp->driver.ver_res;
    5500:	7a03      	ldrb	r3, [r0, #8]
    5502:	07db      	lsls	r3, r3, #31
    5504:	bf54      	ite	pl
    5506:	f9b0 0000 	ldrshpl.w	r0, [r0]
    550a:	f9b0 0002 	ldrshmi.w	r0, [r0, #2]
    550e:	4770      	bx	lr
        return LV_HOR_RES_MAX;
    5510:	20f0      	movs	r0, #240	; 0xf0
}
    5512:	4770      	bx	lr
    5514:	20000e14 	.word	0x20000e14

00005518 <lv_disp_get_ver_res>:
 * @param disp pointer to a display (NULL to use the default display)
 * @return the vertical resolution of the display
 */
lv_coord_t lv_disp_get_ver_res(lv_disp_t * disp)
{
    if(disp == NULL) disp = lv_disp_get_default();
    5518:	b910      	cbnz	r0, 5520 <lv_disp_get_ver_res+0x8>
    return disp_def;
    551a:	4b06      	ldr	r3, [pc, #24]	; (5534 <lv_disp_get_ver_res+0x1c>)
    551c:	6818      	ldr	r0, [r3, #0]

    if(disp == NULL)
    551e:	b138      	cbz	r0, 5530 <lv_disp_get_ver_res+0x18>
        return LV_VER_RES_MAX;
    else
        return disp->driver.rotated == 0 ? disp->driver.ver_res : disp->driver.hor_res;
    5520:	7a03      	ldrb	r3, [r0, #8]
    5522:	07db      	lsls	r3, r3, #31
    5524:	bf54      	ite	pl
    5526:	f9b0 0002 	ldrshpl.w	r0, [r0, #2]
    552a:	f9b0 0000 	ldrshmi.w	r0, [r0]
    552e:	4770      	bx	lr
        return LV_VER_RES_MAX;
    5530:	20f0      	movs	r0, #240	; 0xf0
}
    5532:	4770      	bx	lr
    5534:	20000e14 	.word	0x20000e14

00005538 <lv_indev_get_next>:
 * @return the next input devise or NULL if no more. Give the first input device when the parameter
 * is NULL
 */
lv_indev_t * lv_indev_get_next(lv_indev_t * indev)
{
    if(indev == NULL)
    5538:	4601      	mov	r1, r0
        return lv_ll_get_head(&LV_GC_ROOT(_lv_indev_ll));
    553a:	4803      	ldr	r0, [pc, #12]	; (5548 <lv_indev_get_next+0x10>)
    if(indev == NULL)
    553c:	b909      	cbnz	r1, 5542 <lv_indev_get_next+0xa>
        return lv_ll_get_head(&LV_GC_ROOT(_lv_indev_ll));
    553e:	f004 bfd0 	b.w	a4e2 <lv_ll_get_head>
    else
        return lv_ll_get_next(&LV_GC_ROOT(_lv_indev_ll), indev);
    5542:	f004 bfd4 	b.w	a4ee <lv_ll_get_next>
    5546:	bf00      	nop
    5548:	20000e4c 	.word	0x20000e4c

0000554c <lv_task_core_init>:

/**
 * Init the lv_task module
 */
void lv_task_core_init(void)
{
    554c:	b508      	push	{r3, lr}
    lv_ll_init(&LV_GC_ROOT(_lv_task_ll), sizeof(lv_task_t));
    554e:	2114      	movs	r1, #20
    5550:	4803      	ldr	r0, [pc, #12]	; (5560 <lv_task_core_init+0x14>)
    5552:	f004 ff80 	bl	a456 <lv_ll_init>
 * Enable or disable the whole lv_task handling
 * @param en: true: lv_task handling is running, false: lv_task handling is suspended
 */
void lv_task_enable(bool en)
{
    lv_task_run = en;
    5556:	4b03      	ldr	r3, [pc, #12]	; (5564 <lv_task_core_init+0x18>)
    5558:	2201      	movs	r2, #1
    555a:	701a      	strb	r2, [r3, #0]
}
    555c:	bd08      	pop	{r3, pc}
    555e:	bf00      	nop
    5560:	20000e5c 	.word	0x20000e5c
    5564:	2000531d 	.word	0x2000531d

00005568 <lv_task_create_basic>:
{
    5568:	b538      	push	{r3, r4, r5, lr}
    tmp = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
    556a:	481a      	ldr	r0, [pc, #104]	; (55d4 <lv_task_create_basic+0x6c>)
    556c:	f004 ffb9 	bl	a4e2 <lv_ll_get_head>
    if(NULL == tmp) {
    5570:	4601      	mov	r1, r0
    5572:	b148      	cbz	r0, 5588 <lv_task_create_basic+0x20>
            tmp = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), tmp);
    5574:	4c17      	ldr	r4, [pc, #92]	; (55d4 <lv_task_create_basic+0x6c>)
            if(tmp->prio <= DEF_PRIO) {
    5576:	7c0b      	ldrb	r3, [r1, #16]
    5578:	f003 0307 	and.w	r3, r3, #7
    557c:	2b03      	cmp	r3, #3
    557e:	d80b      	bhi.n	5598 <lv_task_create_basic+0x30>
                new_task = lv_ll_ins_prev(&LV_GC_ROOT(_lv_task_ll), tmp);
    5580:	4814      	ldr	r0, [pc, #80]	; (55d4 <lv_task_create_basic+0x6c>)
    5582:	f004 ffd3 	bl	a52c <lv_ll_ins_prev>
    5586:	e002      	b.n	558e <lv_task_create_basic+0x26>
        new_task = lv_ll_ins_head(&LV_GC_ROOT(_lv_task_ll));
    5588:	4812      	ldr	r0, [pc, #72]	; (55d4 <lv_task_create_basic+0x6c>)
    558a:	f004 ff6e 	bl	a46a <lv_ll_ins_head>
        if(new_task == NULL) return NULL;
    558e:	4604      	mov	r4, r0
    5590:	b960      	cbnz	r0, 55ac <lv_task_create_basic+0x44>
    5592:	2400      	movs	r4, #0
}
    5594:	4620      	mov	r0, r4
    5596:	bd38      	pop	{r3, r4, r5, pc}
            tmp = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), tmp);
    5598:	4620      	mov	r0, r4
    559a:	f004 ffa8 	bl	a4ee <lv_ll_get_next>
        } while(tmp != NULL);
    559e:	4601      	mov	r1, r0
    55a0:	2800      	cmp	r0, #0
    55a2:	d1e8      	bne.n	5576 <lv_task_create_basic+0xe>
            new_task = lv_ll_ins_tail(&LV_GC_ROOT(_lv_task_ll));
    55a4:	480b      	ldr	r0, [pc, #44]	; (55d4 <lv_task_create_basic+0x6c>)
    55a6:	f004 ff7e 	bl	a4a6 <lv_ll_ins_tail>
    55aa:	e7f0      	b.n	558e <lv_task_create_basic+0x26>
    new_task->period  = DEF_PERIOD;
    55ac:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    55b0:	6003      	str	r3, [r0, #0]
    new_task->prio    = DEF_PRIO;
    55b2:	7c03      	ldrb	r3, [r0, #16]
    55b4:	f023 030f 	bic.w	r3, r3, #15
    55b8:	f043 0303 	orr.w	r3, r3, #3
    new_task->task_cb = NULL;
    55bc:	2500      	movs	r5, #0
    new_task->prio    = DEF_PRIO;
    55be:	7403      	strb	r3, [r0, #16]
    new_task->task_cb = NULL;
    55c0:	6085      	str	r5, [r0, #8]
    new_task->last_run = lv_tick_get();
    55c2:	f004 fe3b 	bl	a23c <lv_tick_get>
    task_created = true;
    55c6:	4b04      	ldr	r3, [pc, #16]	; (55d8 <lv_task_create_basic+0x70>)
    new_task->last_run = lv_tick_get();
    55c8:	6060      	str	r0, [r4, #4]
    task_created = true;
    55ca:	2201      	movs	r2, #1
    new_task->user_data = NULL;
    55cc:	60e5      	str	r5, [r4, #12]
    task_created = true;
    55ce:	701a      	strb	r2, [r3, #0]
    return new_task;
    55d0:	e7e0      	b.n	5594 <lv_task_create_basic+0x2c>
    55d2:	bf00      	nop
    55d4:	20000e5c 	.word	0x20000e5c
    55d8:	2000531e 	.word	0x2000531e

000055dc <lv_task_del>:
{
    55dc:	b510      	push	{r4, lr}
    lv_ll_rem(&LV_GC_ROOT(_lv_task_ll), task);
    55de:	4601      	mov	r1, r0
{
    55e0:	4604      	mov	r4, r0
    lv_ll_rem(&LV_GC_ROOT(_lv_task_ll), task);
    55e2:	4807      	ldr	r0, [pc, #28]	; (5600 <lv_task_del+0x24>)
    55e4:	f004 ffd3 	bl	a58e <lv_ll_rem>
    lv_mem_free(task);
    55e8:	4620      	mov	r0, r4
    55ea:	f000 f915 	bl	5818 <lv_mem_free>
    if(LV_GC_ROOT(_lv_task_act) == task) task_deleted = true; /*The active task was deleted*/
    55ee:	4b05      	ldr	r3, [pc, #20]	; (5604 <lv_task_del+0x28>)
    55f0:	681b      	ldr	r3, [r3, #0]
    55f2:	42a3      	cmp	r3, r4
    55f4:	bf02      	ittt	eq
    55f6:	4b04      	ldreq	r3, [pc, #16]	; (5608 <lv_task_del+0x2c>)
    55f8:	2201      	moveq	r2, #1
    55fa:	701a      	strbeq	r2, [r3, #0]
}
    55fc:	bd10      	pop	{r4, pc}
    55fe:	bf00      	nop
    5600:	20000e5c 	.word	0x20000e5c
    5604:	20000e58 	.word	0x20000e58
    5608:	2000531f 	.word	0x2000531f

0000560c <lv_task_exec>:
 * Execute task if its the priority is appropriate
 * @param task pointer to lv_task
 * @return true: execute, false: not executed
 */
static bool lv_task_exec(lv_task_t * task)
{
    560c:	b538      	push	{r3, r4, r5, lr}
    560e:	4604      	mov	r4, r0
    bool exec = false;

    /*Execute if at least 'period' time elapsed*/
    uint32_t elp = lv_tick_elaps(task->last_run);
    5610:	6840      	ldr	r0, [r0, #4]
    5612:	f004 fe17 	bl	a244 <lv_tick_elaps>
    if(elp >= task->period) {
    5616:	6823      	ldr	r3, [r4, #0]
    5618:	4283      	cmp	r3, r0
    561a:	d817      	bhi.n	564c <lv_task_exec+0x40>
        task->last_run = lv_tick_get();
    561c:	f004 fe0e 	bl	a23c <lv_tick_get>
        task_deleted   = false;
    5620:	4d0b      	ldr	r5, [pc, #44]	; (5650 <lv_task_exec+0x44>)
        task_created   = false;
    5622:	4a0c      	ldr	r2, [pc, #48]	; (5654 <lv_task_exec+0x48>)
        task->last_run = lv_tick_get();
    5624:	6060      	str	r0, [r4, #4]
        task_deleted   = false;
    5626:	2300      	movs	r3, #0
    5628:	702b      	strb	r3, [r5, #0]
        task_created   = false;
    562a:	7013      	strb	r3, [r2, #0]
        if(task->task_cb) task->task_cb(task);
    562c:	68a3      	ldr	r3, [r4, #8]
    562e:	b933      	cbnz	r3, 563e <lv_task_exec+0x32>

        /*Delete if it was a one shot lv_task*/
        if(task_deleted == false) { /*The task might be deleted by itself as well*/
            if(task->once != 0) {
    5630:	7c23      	ldrb	r3, [r4, #16]
    5632:	071b      	lsls	r3, r3, #28
    5634:	d508      	bpl.n	5648 <lv_task_exec+0x3c>
                lv_task_del(task);
    5636:	4620      	mov	r0, r4
    5638:	f7ff ffd0 	bl	55dc <lv_task_del>
    563c:	e004      	b.n	5648 <lv_task_exec+0x3c>
        if(task->task_cb) task->task_cb(task);
    563e:	4620      	mov	r0, r4
    5640:	4798      	blx	r3
        if(task_deleted == false) { /*The task might be deleted by itself as well*/
    5642:	782b      	ldrb	r3, [r5, #0]
    5644:	2b00      	cmp	r3, #0
    5646:	d0f3      	beq.n	5630 <lv_task_exec+0x24>
                lv_task_del(task);
    5648:	2001      	movs	r0, #1
        }
        exec = true;
    }

    return exec;
}
    564a:	bd38      	pop	{r3, r4, r5, pc}
    bool exec = false;
    564c:	2000      	movs	r0, #0
    564e:	e7fc      	b.n	564a <lv_task_exec+0x3e>
    5650:	2000531f 	.word	0x2000531f
    5654:	2000531e 	.word	0x2000531e

00005658 <lv_task_handler>:
{
    5658:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(already_running) return;
    565c:	4d3e      	ldr	r5, [pc, #248]	; (5758 <lv_task_handler+0x100>)
    565e:	782c      	ldrb	r4, [r5, #0]
    5660:	b934      	cbnz	r4, 5670 <lv_task_handler+0x18>
    already_running = true;
    5662:	2301      	movs	r3, #1
    5664:	702b      	strb	r3, [r5, #0]
    if(lv_task_run == false) {
    5666:	4b3d      	ldr	r3, [pc, #244]	; (575c <lv_task_handler+0x104>)
    5668:	781b      	ldrb	r3, [r3, #0]
    566a:	b923      	cbnz	r3, 5676 <lv_task_handler+0x1e>
        already_running = false; /*Release mutex*/
    566c:	2300      	movs	r3, #0
    566e:	702b      	strb	r3, [r5, #0]
}
    5670:	b003      	add	sp, #12
    5672:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    handler_start = lv_tick_get();
    5676:	f004 fde1 	bl	a23c <lv_tick_get>
    567a:	4b39      	ldr	r3, [pc, #228]	; (5760 <lv_task_handler+0x108>)
        task_deleted             = false;
    567c:	4e39      	ldr	r6, [pc, #228]	; (5764 <lv_task_handler+0x10c>)
    handler_start = lv_tick_get();
    567e:	6018      	str	r0, [r3, #0]
    lv_task_t * task_interrupter = NULL;
    5680:	9301      	str	r3, [sp, #4]
        task_deleted             = false;
    5682:	46a3      	mov	fp, r4
        task_created             = false;
    5684:	4f38      	ldr	r7, [pc, #224]	; (5768 <lv_task_handler+0x110>)
        LV_GC_ROOT(_lv_task_act) = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
    5686:	4839      	ldr	r0, [pc, #228]	; (576c <lv_task_handler+0x114>)
        task_deleted             = false;
    5688:	f886 b000 	strb.w	fp, [r6]
        task_created             = false;
    568c:	f887 b000 	strb.w	fp, [r7]
        LV_GC_ROOT(_lv_task_act) = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
    5690:	f004 ff27 	bl	a4e2 <lv_ll_get_head>
    5694:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 577c <lv_task_handler+0x124>
    5698:	f8c8 0000 	str.w	r0, [r8]
        while(LV_GC_ROOT(_lv_task_act)) {
    569c:	46c1      	mov	r9, r8
    569e:	f8d9 1000 	ldr.w	r1, [r9]
    56a2:	b1b9      	cbz	r1, 56d4 <lv_task_handler+0x7c>
            next = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), LV_GC_ROOT(_lv_task_act));
    56a4:	4831      	ldr	r0, [pc, #196]	; (576c <lv_task_handler+0x114>)
    56a6:	f004 ff22 	bl	a4ee <lv_ll_get_next>
    56aa:	4682      	mov	sl, r0
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_OFF) {
    56ac:	f8d9 0000 	ldr.w	r0, [r9]
    56b0:	7c03      	ldrb	r3, [r0, #16]
    56b2:	f013 0207 	ands.w	r2, r3, #7
    56b6:	d00d      	beq.n	56d4 <lv_task_handler+0x7c>
            if(LV_GC_ROOT(_lv_task_act) == task_interrupter) {
    56b8:	42a0      	cmp	r0, r4
    56ba:	d103      	bne.n	56c4 <lv_task_handler+0x6c>
                LV_GC_ROOT(_lv_task_act) = next;
    56bc:	f8c9 a000 	str.w	sl, [r9]
                task_interrupter = NULL; /*From this point only task after the interrupter comes, so
    56c0:	2400      	movs	r4, #0
                continue; /*Load the next task*/
    56c2:	e7ec      	b.n	569e <lv_task_handler+0x46>
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_HIGHEST) {
    56c4:	2a05      	cmp	r2, #5
    56c6:	d12b      	bne.n	5720 <lv_task_handler+0xc8>
                lv_task_exec(LV_GC_ROOT(_lv_task_act));
    56c8:	f7ff ffa0 	bl	560c <lv_task_exec>
            if(task_created || task_deleted) {
    56cc:	4b26      	ldr	r3, [pc, #152]	; (5768 <lv_task_handler+0x110>)
    56ce:	781b      	ldrb	r3, [r3, #0]
    56d0:	2b00      	cmp	r3, #0
    56d2:	d03a      	beq.n	574a <lv_task_handler+0xf2>
    busy_time += lv_tick_elaps(handler_start);
    56d4:	9b01      	ldr	r3, [sp, #4]
    56d6:	4c26      	ldr	r4, [pc, #152]	; (5770 <lv_task_handler+0x118>)
    56d8:	6818      	ldr	r0, [r3, #0]
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
    56da:	4e26      	ldr	r6, [pc, #152]	; (5774 <lv_task_handler+0x11c>)
    busy_time += lv_tick_elaps(handler_start);
    56dc:	f004 fdb2 	bl	a244 <lv_tick_elaps>
    56e0:	6823      	ldr	r3, [r4, #0]
    56e2:	4418      	add	r0, r3
    56e4:	6020      	str	r0, [r4, #0]
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
    56e6:	6830      	ldr	r0, [r6, #0]
    56e8:	f004 fdac 	bl	a244 <lv_tick_elaps>
    if(idle_period_time >= IDLE_MEAS_PERIOD) {
    56ec:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
    56f0:	d3bc      	bcc.n	566c <lv_task_handler+0x14>
        idle_last         = (uint32_t)((uint32_t)busy_time * 100) / IDLE_MEAS_PERIOD; /*Calculate the busy percentage*/
    56f2:	6822      	ldr	r2, [r4, #0]
    56f4:	2364      	movs	r3, #100	; 0x64
    56f6:	4353      	muls	r3, r2
    56f8:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    56fc:	fbb3 f3f2 	udiv	r3, r3, r2
        idle_last         = idle_last > 100 ? 0 : 100 - idle_last;                    /*But we need idle time*/
    5700:	b2da      	uxtb	r2, r3
    5702:	2a64      	cmp	r2, #100	; 0x64
    5704:	bf98      	it	ls
    5706:	f1c3 0364 	rsbls	r3, r3, #100	; 0x64
    570a:	4a1b      	ldr	r2, [pc, #108]	; (5778 <lv_task_handler+0x120>)
    570c:	bf94      	ite	ls
    570e:	b2db      	uxtbls	r3, r3
    5710:	2300      	movhi	r3, #0
    5712:	7013      	strb	r3, [r2, #0]
        busy_time         = 0;
    5714:	2300      	movs	r3, #0
    5716:	6023      	str	r3, [r4, #0]
        idle_period_start = lv_tick_get();
    5718:	f004 fd90 	bl	a23c <lv_tick_get>
    571c:	6030      	str	r0, [r6, #0]
    571e:	e7a5      	b.n	566c <lv_task_handler+0x14>
            else if(task_interrupter) {
    5720:	b134      	cbz	r4, 5730 <lv_task_handler+0xd8>
                if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio > task_interrupter->prio) {
    5722:	7c22      	ldrb	r2, [r4, #16]
    5724:	f003 0307 	and.w	r3, r3, #7
    5728:	f002 0207 	and.w	r2, r2, #7
    572c:	4293      	cmp	r3, r2
    572e:	d9cd      	bls.n	56cc <lv_task_handler+0x74>
                if(lv_task_exec(LV_GC_ROOT(_lv_task_act))) {
    5730:	f7ff ff6c 	bl	560c <lv_task_exec>
    5734:	2800      	cmp	r0, #0
    5736:	d0c9      	beq.n	56cc <lv_task_handler+0x74>
                    if(!task_created && !task_deleted) {
    5738:	783b      	ldrb	r3, [r7, #0]
    573a:	2b00      	cmp	r3, #0
    573c:	d1ca      	bne.n	56d4 <lv_task_handler+0x7c>
    573e:	7833      	ldrb	r3, [r6, #0]
    5740:	2b00      	cmp	r3, #0
    5742:	d1c7      	bne.n	56d4 <lv_task_handler+0x7c>
                        task_interrupter = LV_GC_ROOT(_lv_task_act); /*Check all tasks again from the highest priority */
    5744:	f8d8 4000 	ldr.w	r4, [r8]
                        break;
    5748:	e79c      	b.n	5684 <lv_task_handler+0x2c>
            if(task_created || task_deleted) {
    574a:	7833      	ldrb	r3, [r6, #0]
    574c:	2b00      	cmp	r3, #0
    574e:	d1c1      	bne.n	56d4 <lv_task_handler+0x7c>
            LV_GC_ROOT(_lv_task_act) = next; /*Load the next task*/
    5750:	f8c9 a000 	str.w	sl, [r9]
    5754:	e7a3      	b.n	569e <lv_task_handler+0x46>
    5756:	bf00      	nop
    5758:	2000531b 	.word	0x2000531b
    575c:	2000531d 	.word	0x2000531d
    5760:	20000e1c 	.word	0x20000e1c
    5764:	2000531f 	.word	0x2000531f
    5768:	2000531e 	.word	0x2000531e
    576c:	20000e5c 	.word	0x20000e5c
    5770:	20000e18 	.word	0x20000e18
    5774:	20000e20 	.word	0x20000e20
    5778:	2000531c 	.word	0x2000531c
    577c:	20000e58 	.word	0x20000e58

00005780 <lv_task_set_prio>:
    if(task->prio == prio) return;
    5780:	7c03      	ldrb	r3, [r0, #16]
    5782:	f003 0307 	and.w	r3, r3, #7
    5786:	428b      	cmp	r3, r1
{
    5788:	b570      	push	{r4, r5, r6, lr}
    578a:	4604      	mov	r4, r0
    578c:	460d      	mov	r5, r1
    if(task->prio == prio) return;
    578e:	d014      	beq.n	57ba <lv_task_set_prio+0x3a>
    LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i)
    5790:	480d      	ldr	r0, [pc, #52]	; (57c8 <lv_task_set_prio+0x48>)
    5792:	4e0d      	ldr	r6, [pc, #52]	; (57c8 <lv_task_set_prio+0x48>)
    5794:	f004 fea5 	bl	a4e2 <lv_ll_get_head>
    5798:	4602      	mov	r2, r0
    579a:	b132      	cbz	r2, 57aa <lv_task_set_prio+0x2a>
        if(i->prio <= prio) {
    579c:	7c13      	ldrb	r3, [r2, #16]
    579e:	f003 0307 	and.w	r3, r3, #7
    57a2:	429d      	cmp	r5, r3
    57a4:	db0a      	blt.n	57bc <lv_task_set_prio+0x3c>
            if(i != task) lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, i);
    57a6:	42a2      	cmp	r2, r4
    57a8:	d003      	beq.n	57b2 <lv_task_set_prio+0x32>
        lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, NULL);
    57aa:	4621      	mov	r1, r4
    57ac:	4806      	ldr	r0, [pc, #24]	; (57c8 <lv_task_set_prio+0x48>)
    57ae:	f004 ff28 	bl	a602 <lv_ll_move_before>
    task->prio = prio;
    57b2:	7c23      	ldrb	r3, [r4, #16]
    57b4:	f365 0302 	bfi	r3, r5, #0, #3
    57b8:	7423      	strb	r3, [r4, #16]
}
    57ba:	bd70      	pop	{r4, r5, r6, pc}
    LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i)
    57bc:	4611      	mov	r1, r2
    57be:	4630      	mov	r0, r6
    57c0:	f004 fe95 	bl	a4ee <lv_ll_get_next>
    57c4:	4602      	mov	r2, r0
    57c6:	e7e8      	b.n	579a <lv_task_set_prio+0x1a>
    57c8:	20000e5c 	.word	0x20000e5c

000057cc <lv_mem_alloc>:
 * Allocate a memory dynamically
 * @param size size of the memory to allocate in bytes
 * @return pointer to the allocated memory
 */
void * lv_mem_alloc(size_t size)
{
    57cc:	b538      	push	{r3, r4, r5, lr}
    if(size == 0) {
    57ce:	4604      	mov	r4, r0
    57d0:	b198      	cbz	r0, 57fa <lv_mem_alloc+0x2e>
        size = size & (~0x7);
        size += 8;
    }
#else
    /*Round the size up to 4*/
    if(size & 0x3) {
    57d2:	0783      	lsls	r3, r0, #30
        size = size & (~0x3);
    57d4:	bf1c      	itt	ne
    57d6:	f020 0403 	bicne.w	r4, r0, #3
        size += 4;
    57da:	3404      	addne	r4, #4
/*Use custom, user defined malloc function*/
#if LV_ENABLE_GC == 1 /*gc must not include header*/
    alloc = LV_MEM_CUSTOM_ALLOC(size);
#else                 /* LV_ENABLE_GC */
    /*Allocate a header too to store the size*/
    alloc = LV_MEM_CUSTOM_ALLOC(size + sizeof(lv_mem_header_t));
    57dc:	1d20      	adds	r0, r4, #4
    57de:	f7fc ff75 	bl	26cc <lvgl_malloc>
    if(alloc != NULL) {
    57e2:	4605      	mov	r5, r0
    57e4:	b158      	cbz	r0, 57fe <lv_mem_alloc+0x32>
        ((lv_mem_ent_t *)alloc)->header.s.d_size = size;
    57e6:	6803      	ldr	r3, [r0, #0]
    57e8:	f364 035f 	bfi	r3, r4, #1, #31
    57ec:	6003      	str	r3, [r0, #0]
        ((lv_mem_ent_t *)alloc)->header.s.used   = 1;
    57ee:	f043 0301 	orr.w	r3, r3, #1
    57f2:	f805 3b04 	strb.w	r3, [r5], #4
#endif

    if(alloc == NULL) LV_LOG_WARN("Couldn't allocate memory");

    return alloc;
}
    57f6:	4628      	mov	r0, r5
    57f8:	bd38      	pop	{r3, r4, r5, pc}
        return &zero_mem;
    57fa:	4d04      	ldr	r5, [pc, #16]	; (580c <lv_mem_alloc+0x40>)
    57fc:	e7fb      	b.n	57f6 <lv_mem_alloc+0x2a>
    if(alloc == NULL) LV_LOG_WARN("Couldn't allocate memory");
    57fe:	4b04      	ldr	r3, [pc, #16]	; (5810 <lv_mem_alloc+0x44>)
    5800:	4904      	ldr	r1, [pc, #16]	; (5814 <lv_mem_alloc+0x48>)
    5802:	22a7      	movs	r2, #167	; 0xa7
    5804:	2002      	movs	r0, #2
    5806:	f000 f9a3 	bl	5b50 <lv_log_add>
    580a:	e7f4      	b.n	57f6 <lv_mem_alloc+0x2a>
    580c:	20000e24 	.word	0x20000e24
    5810:	0000c5cf 	.word	0x0000c5cf
    5814:	0000c5e8 	.word	0x0000c5e8

00005818 <lv_mem_free>:
 * Free an allocated data
 * @param data pointer to an allocated memory
 */
void lv_mem_free(const void * data)
{
    if(data == &zero_mem) return;
    5818:	4b06      	ldr	r3, [pc, #24]	; (5834 <lv_mem_free+0x1c>)
    581a:	4298      	cmp	r0, r3
    581c:	d008      	beq.n	5830 <lv_mem_free+0x18>
    if(data == NULL) return;
    581e:	b138      	cbz	r0, 5830 <lv_mem_free+0x18>
#endif

#if LV_ENABLE_GC == 0
    /*e points to the header*/
    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));
    e->header.s.used = 0;
    5820:	f810 3c04 	ldrb.w	r3, [r0, #-4]
    5824:	f36f 0300 	bfc	r3, #0, #1
    5828:	f800 3d04 	strb.w	r3, [r0, #-4]!
        e_next = ent_get_next(e_next);
    }
#endif
#else /*Use custom, user defined free function*/
#if LV_ENABLE_GC == 0
    LV_MEM_CUSTOM_FREE(e);
    582c:	f002 be84 	b.w	8538 <lvgl_free>
#else
    LV_MEM_CUSTOM_FREE((void *)data);
#endif /*LV_ENABLE_GC*/
#endif
}
    5830:	4770      	bx	lr
    5832:	bf00      	nop
    5834:	20000e24 	.word	0x20000e24

00005838 <lv_mem_get_size>:

#if LV_ENABLE_GC == 0

uint32_t lv_mem_get_size(const void * data)
{
    if(data == NULL) return 0;
    5838:	b140      	cbz	r0, 584c <lv_mem_get_size+0x14>
    if(data == &zero_mem) return 0;
    583a:	4b05      	ldr	r3, [pc, #20]	; (5850 <lv_mem_get_size+0x18>)
    583c:	4298      	cmp	r0, r3
    583e:	d004      	beq.n	584a <lv_mem_get_size+0x12>

    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));

    return e->header.s.d_size;
    5840:	f850 0c04 	ldr.w	r0, [r0, #-4]
    5844:	f3c0 005e 	ubfx	r0, r0, #1, #31
    5848:	4770      	bx	lr
    if(data == NULL) return 0;
    584a:	2000      	movs	r0, #0
}
    584c:	4770      	bx	lr
    584e:	bf00      	nop
    5850:	20000e24 	.word	0x20000e24

00005854 <lv_mem_realloc>:
{
    5854:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5856:	460d      	mov	r5, r1
    if(data_p != NULL) {
    5858:	4604      	mov	r4, r0
    585a:	b130      	cbz	r0, 586a <lv_mem_realloc+0x16>
        if(e->header.s.used == 0) {
    585c:	f810 3c04 	ldrb.w	r3, [r0, #-4]
            data_p = NULL;
    5860:	f013 0f01 	tst.w	r3, #1
    5864:	bf14      	ite	ne
    5866:	4604      	movne	r4, r0
    5868:	2400      	moveq	r4, #0
    uint32_t old_size = lv_mem_get_size(data_p);
    586a:	4620      	mov	r0, r4
    586c:	f7ff ffe4 	bl	5838 <lv_mem_get_size>
    if(old_size == new_size) return data_p; /*Also avoid reallocating the same memory*/
    5870:	42a8      	cmp	r0, r5
    uint32_t old_size = lv_mem_get_size(data_p);
    5872:	4606      	mov	r6, r0
    if(old_size == new_size) return data_p; /*Also avoid reallocating the same memory*/
    5874:	d012      	beq.n	589c <lv_mem_realloc+0x48>
    new_p = lv_mem_alloc(new_size);
    5876:	4628      	mov	r0, r5
    5878:	f7ff ffa8 	bl	57cc <lv_mem_alloc>
    if(new_p != NULL && data_p != NULL) {
    587c:	4607      	mov	r7, r0
    587e:	b178      	cbz	r0, 58a0 <lv_mem_realloc+0x4c>
    5880:	b154      	cbz	r4, 5898 <lv_mem_realloc+0x44>
        if(old_size != 0) {
    5882:	b14e      	cbz	r6, 5898 <lv_mem_realloc+0x44>
            memcpy(new_p, data_p, LV_MATH_MIN(new_size, old_size));
    5884:	42ae      	cmp	r6, r5
    5886:	4632      	mov	r2, r6
    5888:	4621      	mov	r1, r4
    588a:	bf28      	it	cs
    588c:	462a      	movcs	r2, r5
    588e:	f002 fc0d 	bl	80ac <memcpy>
            lv_mem_free(data_p);
    5892:	4620      	mov	r0, r4
    5894:	f7ff ffc0 	bl	5818 <lv_mem_free>
}
    5898:	4638      	mov	r0, r7
    589a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    589c:	4627      	mov	r7, r4
    589e:	e7fb      	b.n	5898 <lv_mem_realloc+0x44>
    if(new_p == NULL) LV_LOG_WARN("Couldn't allocate memory");
    58a0:	4b03      	ldr	r3, [pc, #12]	; (58b0 <lv_mem_realloc+0x5c>)
    58a2:	4904      	ldr	r1, [pc, #16]	; (58b4 <lv_mem_realloc+0x60>)
    58a4:	f44f 7281 	mov.w	r2, #258	; 0x102
    58a8:	2002      	movs	r0, #2
    58aa:	f000 f951 	bl	5b50 <lv_log_add>
    58ae:	e7f3      	b.n	5898 <lv_mem_realloc+0x44>
    58b0:	0000c5cf 	.word	0x0000c5cf
    58b4:	0000c5e8 	.word	0x0000c5e8

000058b8 <lv_txt_get_width>:
 * @param flags settings for the text from 'txt_flag_t' enum
 * @return length of a char_num long text
 */
lv_coord_t lv_txt_get_width(const char * txt, uint16_t length, const lv_font_t * font, lv_coord_t letter_space,
                            lv_txt_flag_t flag)
{
    58b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    58bc:	4688      	mov	r8, r1
    58be:	b085      	sub	sp, #20
    58c0:	4617      	mov	r7, r2
    58c2:	461e      	mov	r6, r3
    if(txt == NULL) return 0;
    58c4:	4605      	mov	r5, r0
    58c6:	2400      	movs	r4, #0
    58c8:	2800      	cmp	r0, #0
    58ca:	d03f      	beq.n	594c <lv_txt_get_width+0x94>
    if(font == NULL) return 0;
    58cc:	2a00      	cmp	r2, #0
    58ce:	d03f      	beq.n	5950 <lv_txt_get_width+0x98>

    uint32_t i                   = 0;
    58d0:	9403      	str	r4, [sp, #12]
    lv_coord_t width             = 0;
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
    58d2:	f88d 400b 	strb.w	r4, [sp, #11]
    uint32_t letter;
    uint32_t letter_next;

    if(length != 0) {
    58d6:	2900      	cmp	r1, #0
    58d8:	d036      	beq.n	5948 <lv_txt_get_width+0x90>
        while(i < length) {
            letter      = lv_txt_encoded_next(txt, &i);
            letter_next = lv_txt_encoded_next(&txt[i], NULL);
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    58da:	f89d 9038 	ldrb.w	r9, [sp, #56]	; 0x38
            letter      = lv_txt_encoded_next(txt, &i);
    58de:	f8df a074 	ldr.w	sl, [pc, #116]	; 5954 <lv_txt_get_width+0x9c>
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    58e2:	f009 0901 	and.w	r9, r9, #1
            letter      = lv_txt_encoded_next(txt, &i);
    58e6:	f8da 3000 	ldr.w	r3, [sl]
    58ea:	a903      	add	r1, sp, #12
    58ec:	4628      	mov	r0, r5
    58ee:	4798      	blx	r3
    58f0:	4683      	mov	fp, r0
            letter_next = lv_txt_encoded_next(&txt[i], NULL);
    58f2:	9803      	ldr	r0, [sp, #12]
    58f4:	f8da 3000 	ldr.w	r3, [sl]
    58f8:	2100      	movs	r1, #0
    58fa:	4428      	add	r0, r5
    58fc:	4798      	blx	r3
    58fe:	4602      	mov	r2, r0
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    5900:	f1b9 0f00 	cmp.w	r9, #0
    5904:	d111      	bne.n	592a <lv_txt_get_width+0x72>
                if(lv_txt_is_cmd(&cmd_state, letter) != false) {
                    continue;
                }
            }

            lv_coord_t char_width = lv_font_get_glyph_width(font, letter, letter_next);
    5906:	4659      	mov	r1, fp
    5908:	4638      	mov	r0, r7
    590a:	f005 f955 	bl	abb8 <lv_font_get_glyph_width>
    590e:	b200      	sxth	r0, r0
            if(char_width > 0) {
    5910:	2800      	cmp	r0, #0
    5912:	dc14      	bgt.n	593e <lv_txt_get_width+0x86>
        while(i < length) {
    5914:	9b03      	ldr	r3, [sp, #12]
    5916:	4598      	cmp	r8, r3
    5918:	d8e5      	bhi.n	58e6 <lv_txt_get_width+0x2e>
                width += char_width;
                width += letter_space;
            }
        }

        if(width > 0) {
    591a:	2c00      	cmp	r4, #0
    591c:	dd01      	ble.n	5922 <lv_txt_get_width+0x6a>
            width -= letter_space; /*Trim the last letter space. Important if the text is center
    591e:	1ba4      	subs	r4, r4, r6
    5920:	b224      	sxth	r4, r4
                                      aligned */
        }
    }

    return width;
}
    5922:	4620      	mov	r0, r4
    5924:	b005      	add	sp, #20
    5926:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    592a:	9001      	str	r0, [sp, #4]
                if(lv_txt_is_cmd(&cmd_state, letter) != false) {
    592c:	4659      	mov	r1, fp
    592e:	f10d 000b 	add.w	r0, sp, #11
    5932:	f004 feae 	bl	a692 <lv_txt_is_cmd>
    5936:	9a01      	ldr	r2, [sp, #4]
    5938:	2800      	cmp	r0, #0
    593a:	d0e4      	beq.n	5906 <lv_txt_get_width+0x4e>
    593c:	e7ea      	b.n	5914 <lv_txt_get_width+0x5c>
                width += letter_space;
    593e:	19a3      	adds	r3, r4, r6
    5940:	fa00 f483 	sxtah	r4, r0, r3
    5944:	b224      	sxth	r4, r4
    5946:	e7e5      	b.n	5914 <lv_txt_get_width+0x5c>
    lv_coord_t width             = 0;
    5948:	460c      	mov	r4, r1
    594a:	e7ea      	b.n	5922 <lv_txt_get_width+0x6a>
    if(txt == NULL) return 0;
    594c:	4604      	mov	r4, r0
    594e:	e7e8      	b.n	5922 <lv_txt_get_width+0x6a>
    5950:	4614      	mov	r4, r2
    5952:	e7e6      	b.n	5922 <lv_txt_get_width+0x6a>
    5954:	200068c0 	.word	0x200068c0

00005958 <lv_txt_get_next_line>:
{
    5958:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    595c:	b091      	sub	sp, #68	; 0x44
    595e:	4699      	mov	r9, r3
    5960:	f89d 3068 	ldrb.w	r3, [sp, #104]	; 0x68
    5964:	9102      	str	r1, [sp, #8]
    5966:	9207      	str	r2, [sp, #28]
    5968:	9303      	str	r3, [sp, #12]
    if(txt == NULL) return 0;
    596a:	4607      	mov	r7, r0
    596c:	2800      	cmp	r0, #0
    596e:	d05a      	beq.n	5a26 <lv_txt_get_next_line+0xce>
    if(font == NULL) return 0;
    5970:	2900      	cmp	r1, #0
    5972:	f000 80de 	beq.w	5b32 <lv_txt_get_next_line+0x1da>
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
    5976:	9b03      	ldr	r3, [sp, #12]
    5978:	f013 0302 	ands.w	r3, r3, #2
    597c:	9304      	str	r3, [sp, #16]
    597e:	f647 4318 	movw	r3, #31768	; 0x7c18
    5982:	bf18      	it	ne
    5984:	4699      	movne	r9, r3
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
    5986:	2300      	movs	r3, #0
    5988:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    uint32_t i = 0;                                        /* Iterating index into txt */
    598c:	930c      	str	r3, [sp, #48]	; 0x30
    while(txt[i] != '\0' && max_width > 0) {
    598e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5990:	9300      	str	r3, [sp, #0]
    5992:	eb07 0b03 	add.w	fp, r7, r3
    5996:	5cfb      	ldrb	r3, [r7, r3]
    5998:	2b00      	cmp	r3, #0
    599a:	d03b      	beq.n	5a14 <lv_txt_get_next_line+0xbc>
    599c:	f1b9 0f00 	cmp.w	r9, #0
    59a0:	dd38      	ble.n	5a14 <lv_txt_get_next_line+0xbc>
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
    59a2:	9a04      	ldr	r2, [sp, #16]
    59a4:	f647 4318 	movw	r3, #31768	; 0x7c18
    59a8:	2a00      	cmp	r2, #0
    59aa:	bf08      	it	eq
    59ac:	464b      	moveq	r3, r9
    59ae:	9306      	str	r3, [sp, #24]
    letter = lv_txt_encoded_next(txt, &i_next);
    59b0:	4b61      	ldr	r3, [pc, #388]	; (5b38 <lv_txt_get_next_line+0x1e0>)
    uint32_t i = 0, i_next = 0, i_next_next = 0;  /* Iterating index into txt */
    59b2:	2500      	movs	r5, #0
    letter = lv_txt_encoded_next(txt, &i_next);
    59b4:	681b      	ldr	r3, [r3, #0]
    uint32_t i = 0, i_next = 0, i_next_next = 0;  /* Iterating index into txt */
    59b6:	950f      	str	r5, [sp, #60]	; 0x3c
    59b8:	e9cd 550d 	strd	r5, r5, [sp, #52]	; 0x34
    letter = lv_txt_encoded_next(txt, &i_next);
    59bc:	a90e      	add	r1, sp, #56	; 0x38
    59be:	4658      	mov	r0, fp
    59c0:	4798      	blx	r3
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    59c2:	9a03      	ldr	r2, [sp, #12]
    i_next_next = i_next;
    59c4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    59c6:	930f      	str	r3, [sp, #60]	; 0x3c
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    59c8:	f002 0201 	and.w	r2, r2, #1
    letter = lv_txt_encoded_next(txt, &i_next);
    59cc:	4680      	mov	r8, r0
    uint32_t break_letter_count = 0; /* Number of characters up to the long word break point */
    59ce:	9501      	str	r5, [sp, #4]
    uint32_t break_index = NO_BREAK_FOUND; /* only used for "long" words */
    59d0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    uint32_t word_len = 0;   /* Number of characters in the transversed word */
    59d4:	46aa      	mov	sl, r5
    lv_coord_t cur_w = 0;  /* Pixel Width of transversed string */
    59d6:	462e      	mov	r6, r5
    uint32_t letter_next = 0; /* Letter at i_next */
    59d8:	462b      	mov	r3, r5
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    59da:	9208      	str	r2, [sp, #32]
    while(txt[i] != '\0') {
    59dc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    59de:	f81b 2002 	ldrb.w	r2, [fp, r2]
    59e2:	bb1a      	cbnz	r2, 5a2c <lv_txt_get_next_line+0xd4>
    if( break_index == NO_BREAK_FOUND ) {
    59e4:	1c62      	adds	r2, r4, #1
    59e6:	d06f      	beq.n	5ac8 <lv_txt_get_next_line+0x170>
    if(word_len < LV_TXT_LINE_BREAK_LONG_LEN) {
    59e8:	f1ba 0f0b 	cmp.w	sl, #11
    59ec:	d879      	bhi.n	5ae2 <lv_txt_get_next_line+0x18a>
        if( force ) return break_index;
    59ee:	9b00      	ldr	r3, [sp, #0]
    59f0:	2b00      	cmp	r3, #0
    59f2:	f040 8089 	bne.w	5b08 <lv_txt_get_next_line+0x1b0>
    59f6:	b2a4      	uxth	r4, r4
        max_width -= word_w;
    59f8:	eba9 0905 	sub.w	r9, r9, r5
    59fc:	fa0f f989 	sxth.w	r9, r9
        if( advance == 0 ){
    5a00:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5a02:	2c00      	cmp	r4, #0
    5a04:	f040 8083 	bne.w	5b0e <lv_txt_get_next_line+0x1b6>
            if(i == 0) lv_txt_encoded_next(txt, &i); // prevent inf loops
    5a08:	b95b      	cbnz	r3, 5a22 <lv_txt_get_next_line+0xca>
    5a0a:	4b4b      	ldr	r3, [pc, #300]	; (5b38 <lv_txt_get_next_line+0x1e0>)
    5a0c:	a90c      	add	r1, sp, #48	; 0x30
    5a0e:	681b      	ldr	r3, [r3, #0]
    5a10:	4638      	mov	r0, r7
    5a12:	4798      	blx	r3
    if(i == 0) {
    5a14:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5a16:	b923      	cbnz	r3, 5a22 <lv_txt_get_next_line+0xca>
        lv_txt_encoded_next(txt, &i);
    5a18:	4b47      	ldr	r3, [pc, #284]	; (5b38 <lv_txt_get_next_line+0x1e0>)
    5a1a:	a90c      	add	r1, sp, #48	; 0x30
    5a1c:	681b      	ldr	r3, [r3, #0]
    5a1e:	4638      	mov	r0, r7
    5a20:	4798      	blx	r3
    return i;
    5a22:	f8bd 0030 	ldrh.w	r0, [sp, #48]	; 0x30
}
    5a26:	b011      	add	sp, #68	; 0x44
    5a28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        letter_next = lv_txt_encoded_next(txt, &i_next_next);
    5a2c:	4b42      	ldr	r3, [pc, #264]	; (5b38 <lv_txt_get_next_line+0x1e0>)
    5a2e:	a90f      	add	r1, sp, #60	; 0x3c
    5a30:	681b      	ldr	r3, [r3, #0]
    5a32:	4658      	mov	r0, fp
    5a34:	4798      	blx	r3
        word_len++;
    5a36:	f10a 0201 	add.w	r2, sl, #1
    5a3a:	9205      	str	r2, [sp, #20]
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    5a3c:	9a08      	ldr	r2, [sp, #32]
        letter_next = lv_txt_encoded_next(txt, &i_next_next);
    5a3e:	4603      	mov	r3, r0
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    5a40:	b17a      	cbz	r2, 5a62 <lv_txt_get_next_line+0x10a>
    5a42:	9009      	str	r0, [sp, #36]	; 0x24
            if(lv_txt_is_cmd(cmd_state, letter) != false) {
    5a44:	4641      	mov	r1, r8
    5a46:	f10d 002f 	add.w	r0, sp, #47	; 0x2f
    5a4a:	f004 fe22 	bl	a692 <lv_txt_is_cmd>
    5a4e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5a50:	b138      	cbz	r0, 5a62 <lv_txt_get_next_line+0x10a>
        i = i_next;
    5a52:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    5a54:	920d      	str	r2, [sp, #52]	; 0x34
        i_next = i_next_next;
    5a56:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    5a58:	920e      	str	r2, [sp, #56]	; 0x38
        letter_next = lv_txt_encoded_next(txt, &i_next_next);
    5a5a:	f8dd a014 	ldr.w	sl, [sp, #20]
    5a5e:	4698      	mov	r8, r3
    5a60:	e7bc      	b.n	59dc <lv_txt_get_next_line+0x84>
        letter_w = lv_font_get_glyph_width(font, letter, letter_next);
    5a62:	461a      	mov	r2, r3
    5a64:	4641      	mov	r1, r8
    5a66:	9802      	ldr	r0, [sp, #8]
    5a68:	9309      	str	r3, [sp, #36]	; 0x24
    5a6a:	f005 f8a5 	bl	abb8 <lv_font_get_glyph_width>
    5a6e:	b200      	sxth	r0, r0
        cur_w += letter_w;
    5a70:	4406      	add	r6, r0
        if(break_index == NO_BREAK_FOUND && cur_w > max_width) {
    5a72:	1c63      	adds	r3, r4, #1
        cur_w += letter_w;
    5a74:	b236      	sxth	r6, r6
        if(break_index == NO_BREAK_FOUND && cur_w > max_width) {
    5a76:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5a78:	d105      	bne.n	5a86 <lv_txt_get_next_line+0x12e>
    5a7a:	9a06      	ldr	r2, [sp, #24]
    5a7c:	4296      	cmp	r6, r2
            break_index = i; 
    5a7e:	bfc4      	itt	gt
    5a80:	9c0d      	ldrgt	r4, [sp, #52]	; 0x34
    5a82:	f8cd a004 	strgt.w	sl, [sp, #4]
        if(letter == '\n' || letter == '\r' || is_break_char(letter)) {
    5a86:	f1b8 0f0a 	cmp.w	r8, #10
    5a8a:	d017      	beq.n	5abc <lv_txt_get_next_line+0x164>
    5a8c:	f1b8 0f0d 	cmp.w	r8, #13
    5a90:	d014      	beq.n	5abc <lv_txt_get_next_line+0x164>
{
    uint8_t i;
    bool ret = false;

    /*Compare the letter to TXT_BREAK_CHARS*/
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
    5a92:	f8df c0ac 	ldr.w	ip, [pc, #172]	; 5b40 <lv_txt_get_next_line+0x1e8>
        if(letter == '\n' || letter == '\r' || is_break_char(letter)) {
    5a96:	2200      	movs	r2, #0
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
    5a98:	b2d1      	uxtb	r1, r2
    5a9a:	f81c 1001 	ldrb.w	r1, [ip, r1]
    5a9e:	b949      	cbnz	r1, 5ab4 <lv_txt_get_next_line+0x15c>
        if( word_w_ptr != NULL && break_index == NO_BREAK_FOUND ) *word_w_ptr = cur_w;
    5aa0:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
    5aa4:	bf08      	it	eq
    5aa6:	4635      	moveq	r5, r6
        if(letter_w > 0) {
    5aa8:	2800      	cmp	r0, #0
    5aaa:	ddd2      	ble.n	5a52 <lv_txt_get_next_line+0xfa>
            cur_w += letter_space;
    5aac:	9a07      	ldr	r2, [sp, #28]
    5aae:	4416      	add	r6, r2
    5ab0:	b236      	sxth	r6, r6
    5ab2:	e7ce      	b.n	5a52 <lv_txt_get_next_line+0xfa>
        if(letter == (uint32_t)LV_TXT_BREAK_CHARS[i]) {
    5ab4:	4588      	cmp	r8, r1
    5ab6:	f102 0201 	add.w	r2, r2, #1
    5aba:	d1ed      	bne.n	5a98 <lv_txt_get_next_line+0x140>
            if(i == 0 && break_index == NO_BREAK_FOUND && word_w_ptr != NULL) *word_w_ptr = cur_w;
    5abc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    5abe:	2a00      	cmp	r2, #0
    5ac0:	d190      	bne.n	59e4 <lv_txt_get_next_line+0x8c>
    5ac2:	1c61      	adds	r1, r4, #1
    5ac4:	d190      	bne.n	59e8 <lv_txt_get_next_line+0x90>
    5ac6:	4635      	mov	r5, r6
        if( word_len == 0 || (letter == '\r' && letter_next == '\n') ) i = i_next;
    5ac8:	f1ba 0f00 	cmp.w	sl, #0
    5acc:	d004      	beq.n	5ad8 <lv_txt_get_next_line+0x180>
    5ace:	f1b8 0f0d 	cmp.w	r8, #13
    5ad2:	d103      	bne.n	5adc <lv_txt_get_next_line+0x184>
    5ad4:	2b0a      	cmp	r3, #10
    5ad6:	d101      	bne.n	5adc <lv_txt_get_next_line+0x184>
    5ad8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    5ada:	930d      	str	r3, [sp, #52]	; 0x34
    return i;
    5adc:	f8bd 4034 	ldrh.w	r4, [sp, #52]	; 0x34
    5ae0:	e78a      	b.n	59f8 <lv_txt_get_next_line+0xa0>
    if(break_letter_count < LV_TXT_LINE_BREAK_LONG_PRE_MIN_LEN) {
    5ae2:	9b01      	ldr	r3, [sp, #4]
    5ae4:	2b02      	cmp	r3, #2
    5ae6:	d982      	bls.n	59ee <lv_txt_get_next_line+0x96>
        int32_t n_move = LV_TXT_LINE_BREAK_LONG_POST_MIN_LEN - (word_len - break_letter_count);
    5ae8:	9b01      	ldr	r3, [sp, #4]
        i = break_index;
    5aea:	940d      	str	r4, [sp, #52]	; 0x34
        int32_t n_move = LV_TXT_LINE_BREAK_LONG_POST_MIN_LEN - (word_len - break_letter_count);
    5aec:	3303      	adds	r3, #3
    5aee:	eba3 0a0a 	sub.w	sl, r3, sl
        for(;n_move>0; n_move--){
    5af2:	f1ba 0f00 	cmp.w	sl, #0
    5af6:	ddf1      	ble.n	5adc <lv_txt_get_next_line+0x184>
            lv_txt_encoded_prev(txt, &i);
    5af8:	4b10      	ldr	r3, [pc, #64]	; (5b3c <lv_txt_get_next_line+0x1e4>)
    5afa:	a90d      	add	r1, sp, #52	; 0x34
    5afc:	681b      	ldr	r3, [r3, #0]
    5afe:	4658      	mov	r0, fp
    5b00:	4798      	blx	r3
        for(;n_move>0; n_move--){
    5b02:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
    5b06:	e7f4      	b.n	5af2 <lv_txt_get_next_line+0x19a>
        if(word_w_ptr != NULL) *word_w_ptr = 0; /* Return no word */
    5b08:	2500      	movs	r5, #0
        return 0;
    5b0a:	462c      	mov	r4, r5
    5b0c:	e774      	b.n	59f8 <lv_txt_get_next_line+0xa0>
        i += advance;
    5b0e:	441c      	add	r4, r3
        if(txt[0] == '\n' || txt[0] == '\r') break;
    5b10:	783b      	ldrb	r3, [r7, #0]
        i += advance;
    5b12:	940c      	str	r4, [sp, #48]	; 0x30
        if(txt[0] == '\n' || txt[0] == '\r') break;
    5b14:	2b0a      	cmp	r3, #10
    5b16:	f43f af7d 	beq.w	5a14 <lv_txt_get_next_line+0xbc>
    5b1a:	2b0d      	cmp	r3, #13
    5b1c:	f43f af7a 	beq.w	5a14 <lv_txt_get_next_line+0xbc>
        if(txt[i] == '\n' || txt[i] == '\r'){
    5b20:	5d3b      	ldrb	r3, [r7, r4]
    5b22:	2b0a      	cmp	r3, #10
    5b24:	d002      	beq.n	5b2c <lv_txt_get_next_line+0x1d4>
    5b26:	2b0d      	cmp	r3, #13
    5b28:	f47f af31 	bne.w	598e <lv_txt_get_next_line+0x36>
            i++;  /* Include the following newline in the current line */
    5b2c:	3401      	adds	r4, #1
    5b2e:	940c      	str	r4, [sp, #48]	; 0x30
            break;
    5b30:	e770      	b.n	5a14 <lv_txt_get_next_line+0xbc>
    if(txt == NULL) return 0;
    5b32:	9802      	ldr	r0, [sp, #8]
    5b34:	e777      	b.n	5a26 <lv_txt_get_next_line+0xce>
    5b36:	bf00      	nop
    5b38:	200068c0 	.word	0x200068c0
    5b3c:	200068c4 	.word	0x200068c4
    5b40:	0000c61d 	.word	0x0000c61d

00005b44 <lv_log_register_print_cb>:
 * and send the formatted log message to a consol or serial port.
 * @param print_cb a function pointer to print a log
 */
void lv_log_register_print_cb(lv_log_print_g_cb_t print_cb)
{
    custom_print_cb = print_cb;
    5b44:	4b01      	ldr	r3, [pc, #4]	; (5b4c <lv_log_register_print_cb+0x8>)
    5b46:	6018      	str	r0, [r3, #0]
}
    5b48:	4770      	bx	lr
    5b4a:	bf00      	nop
    5b4c:	20000e28 	.word	0x20000e28

00005b50 <lv_log_add>:
 * @param file name of the file when the log added
 * @param line line number in the source code where the log added
 * @param dsc description of the log
 */
void lv_log_add(lv_log_level_t level, const char * file, int line, const char * dsc)
{
    5b50:	b410      	push	{r4}
    if(level >= _LV_LOG_LEVEL_NUM) return; /*Invalid level*/

    if(level >= LV_LOG_LEVEL) {
    5b52:	1e44      	subs	r4, r0, #1
    5b54:	b2e4      	uxtb	r4, r4
    5b56:	2c03      	cmp	r4, #3
    5b58:	d805      	bhi.n	5b66 <lv_log_add+0x16>

#if LV_LOG_PRINTF
        static const char * lvl_prefix[] = {"Trace", "Info", "Warn", "Error"};
        printf("%s: %s \t(%s #%d)\n", lvl_prefix[level], dsc, file, line);
#else
        if(custom_print_cb) custom_print_cb(level, file, line, dsc);
    5b5a:	4c04      	ldr	r4, [pc, #16]	; (5b6c <lv_log_add+0x1c>)
    5b5c:	6824      	ldr	r4, [r4, #0]
    5b5e:	b114      	cbz	r4, 5b66 <lv_log_add+0x16>
    5b60:	46a4      	mov	ip, r4
#endif
    }
}
    5b62:	bc10      	pop	{r4}
        if(custom_print_cb) custom_print_cb(level, file, line, dsc);
    5b64:	4760      	bx	ip
}
    5b66:	bc10      	pop	{r4}
    5b68:	4770      	bx	lr
    5b6a:	bf00      	nop
    5b6c:	20000e28 	.word	0x20000e28

00005b70 <lv_label_revert_dots>:

    lv_obj_invalidate(label);
}

static void lv_label_revert_dots(lv_obj_t * label)
{
    5b70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5b74:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    5b76:	f003 fa49 	bl	900c <lv_obj_get_ext_attr>
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
    5b7a:	7b83      	ldrb	r3, [r0, #14]
    5b7c:	f003 0307 	and.w	r3, r3, #7
    5b80:	2b02      	cmp	r3, #2
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    5b82:	4604      	mov	r4, r0
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
    5b84:	d126      	bne.n	5bd4 <lv_label_revert_dots+0x64>
    if(ext->dot_end == LV_LABEL_DOT_END_INV) return;
    5b86:	8901      	ldrh	r1, [r0, #8]
    5b88:	f64f 73ff 	movw	r3, #65535	; 0xffff
    5b8c:	4299      	cmp	r1, r3
    5b8e:	d021      	beq.n	5bd4 <lv_label_revert_dots+0x64>
    uint32_t letter_i = ext->dot_end - LV_LABEL_DOT_NUM;
    uint32_t byte_i   = lv_txt_encoded_get_byte_id(ext->text, letter_i);
    5b90:	4b12      	ldr	r3, [pc, #72]	; (5bdc <lv_label_revert_dots+0x6c>)
    5b92:	6800      	ldr	r0, [r0, #0]
    5b94:	681b      	ldr	r3, [r3, #0]
    5b96:	3903      	subs	r1, #3
    5b98:	4798      	blx	r3
    5b9a:	4680      	mov	r8, r0
 * @param label pointer to label object
 * @return char pointer to a stored characters. Is *not* necessarily NULL-terminated.
 */
static char * lv_label_get_dot_tmp(lv_obj_t * label)
{
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    5b9c:	4628      	mov	r0, r5
    5b9e:	f003 fa35 	bl	900c <lv_obj_get_ext_attr>
    if(ext->dot_tmp_alloc) {
    5ba2:	7bc3      	ldrb	r3, [r0, #15]
    5ba4:	079b      	lsls	r3, r3, #30
        return ext->dot.tmp_ptr;
    5ba6:	bf4c      	ite	mi
    5ba8:	6840      	ldrmi	r0, [r0, #4]
    } else {
        return ext->dot.tmp;
    5baa:	3004      	addpl	r0, #4
    while(ext->text[byte_i + i] != '\0') {
    5bac:	2100      	movs	r1, #0
    5bae:	b2ce      	uxtb	r6, r1
    5bb0:	eb06 0308 	add.w	r3, r6, r8
    5bb4:	6822      	ldr	r2, [r4, #0]
    5bb6:	5d86      	ldrb	r6, [r0, r6]
    5bb8:	f812 c003 	ldrb.w	ip, [r2, r3]
    5bbc:	18d7      	adds	r7, r2, r3
    5bbe:	3101      	adds	r1, #1
    5bc0:	f1bc 0f00 	cmp.w	ip, #0
    5bc4:	d108      	bne.n	5bd8 <lv_label_revert_dots+0x68>
    ext->text[byte_i + i] = dot_tmp[i];
    5bc6:	703e      	strb	r6, [r7, #0]
    lv_label_dot_tmp_free(label);
    5bc8:	4628      	mov	r0, r5
    5bca:	f004 fdf2 	bl	a7b2 <lv_label_dot_tmp_free>
    ext->dot_end = LV_LABEL_DOT_END_INV;
    5bce:	f64f 73ff 	movw	r3, #65535	; 0xffff
    5bd2:	8123      	strh	r3, [r4, #8]
}
    5bd4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ext->text[byte_i + i] = dot_tmp[i];
    5bd8:	54d6      	strb	r6, [r2, r3]
        i++;
    5bda:	e7e8      	b.n	5bae <lv_label_revert_dots+0x3e>
    5bdc:	200068b8 	.word	0x200068b8

00005be0 <lv_label_set_dot_tmp>:
{
    5be0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5be2:	4616      	mov	r6, r2
    5be4:	4604      	mov	r4, r0
    5be6:	460f      	mov	r7, r1
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    5be8:	f003 fa10 	bl	900c <lv_obj_get_ext_attr>
    5bec:	4605      	mov	r5, r0
    lv_label_dot_tmp_free(label); /* Deallocate any existing space */
    5bee:	4620      	mov	r0, r4
    5bf0:	f004 fddf 	bl	a7b2 <lv_label_dot_tmp_free>
    if(len > sizeof(char *)) {
    5bf4:	2e04      	cmp	r6, #4
    5bf6:	d91b      	bls.n	5c30 <lv_label_set_dot_tmp+0x50>
        ext->dot.tmp_ptr = lv_mem_alloc(len + 1);
    5bf8:	1c70      	adds	r0, r6, #1
    5bfa:	f7ff fde7 	bl	57cc <lv_mem_alloc>
    5bfe:	4604      	mov	r4, r0
    5c00:	6068      	str	r0, [r5, #4]
        if(ext->dot.tmp_ptr == NULL) {
    5c02:	b940      	cbnz	r0, 5c16 <lv_label_set_dot_tmp+0x36>
            LV_LOG_ERROR("Failed to allocate memory for dot_tmp_ptr");
    5c04:	2003      	movs	r0, #3
    5c06:	4b0f      	ldr	r3, [pc, #60]	; (5c44 <lv_label_set_dot_tmp+0x64>)
    5c08:	490f      	ldr	r1, [pc, #60]	; (5c48 <lv_label_set_dot_tmp+0x68>)
    5c0a:	f240 526e 	movw	r2, #1390	; 0x56e
    5c0e:	f7ff ff9f 	bl	5b50 <lv_log_add>
    5c12:	4620      	mov	r0, r4
}
    5c14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        memcpy(ext->dot.tmp_ptr, data, len);
    5c16:	4632      	mov	r2, r6
    5c18:	4639      	mov	r1, r7
    5c1a:	f002 fa47 	bl	80ac <memcpy>
        ext->dot.tmp_ptr[len] = '\0';
    5c1e:	686b      	ldr	r3, [r5, #4]
    5c20:	2200      	movs	r2, #0
    5c22:	559a      	strb	r2, [r3, r6]
        ext->dot_tmp_alloc    = true;
    5c24:	7beb      	ldrb	r3, [r5, #15]
    5c26:	f043 0302 	orr.w	r3, r3, #2
    5c2a:	73eb      	strb	r3, [r5, #15]
    return true;
    5c2c:	2001      	movs	r0, #1
    5c2e:	e7f1      	b.n	5c14 <lv_label_set_dot_tmp+0x34>
        ext->dot_tmp_alloc = false;
    5c30:	7beb      	ldrb	r3, [r5, #15]
    5c32:	f36f 0341 	bfc	r3, #1, #1
    5c36:	73eb      	strb	r3, [r5, #15]
        memcpy(ext->dot.tmp, data, len);
    5c38:	4632      	mov	r2, r6
    5c3a:	4639      	mov	r1, r7
    5c3c:	1d28      	adds	r0, r5, #4
    5c3e:	f002 fa35 	bl	80ac <memcpy>
    5c42:	e7f3      	b.n	5c2c <lv_label_set_dot_tmp+0x4c>
    5c44:	0000c638 	.word	0x0000c638
    5c48:	0000c662 	.word	0x0000c662

00005c4c <lv_label_get_letter_on>:
{
    5c4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5c50:	b08b      	sub	sp, #44	; 0x2c
    5c52:	4680      	mov	r8, r0
    5c54:	9107      	str	r1, [sp, #28]
    const char * txt         = lv_label_get_text(label);
    5c56:	f004 fde7 	bl	a828 <lv_label_get_text>
    5c5a:	9003      	str	r0, [sp, #12]
    lv_label_ext_t * ext     = lv_obj_get_ext_attr(label);
    5c5c:	4640      	mov	r0, r8
    5c5e:	f003 f9d5 	bl	900c <lv_obj_get_ext_attr>
    5c62:	4604      	mov	r4, r0
    lv_coord_t max_w         = lv_obj_get_width(label);
    5c64:	4640      	mov	r0, r8
    5c66:	f003 f963 	bl	8f30 <lv_obj_get_width>
    5c6a:	9005      	str	r0, [sp, #20]
    const lv_style_t * style = lv_obj_get_style(label);
    5c6c:	4640      	mov	r0, r8
    5c6e:	f7fe f8c3 	bl	3df8 <lv_obj_get_style>
    const lv_font_t * font   = style->text.font;
    5c72:	6b43      	ldr	r3, [r0, #52]	; 0x34
    5c74:	9304      	str	r3, [sp, #16]
    uint8_t letter_height    = lv_font_get_line_height(font);
    5c76:	7a1b      	ldrb	r3, [r3, #8]
    5c78:	9306      	str	r3, [sp, #24]
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
    5c7a:	7ba3      	ldrb	r3, [r4, #14]
    const lv_style_t * style = lv_obj_get_style(label);
    5c7c:	4683      	mov	fp, r0
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
    5c7e:	f3c3 1680 	ubfx	r6, r3, #6, #1
    lv_label_align_t align = lv_label_get_align(label);
    5c82:	4640      	mov	r0, r8
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
    5c84:	061b      	lsls	r3, r3, #24
    5c86:	bf48      	it	mi
    5c88:	f046 0602 	orrmi.w	r6, r6, #2
    lv_label_align_t align = lv_label_get_align(label);
    5c8c:	f004 fdd8 	bl	a840 <lv_label_get_align>
    if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
    5c90:	2801      	cmp	r0, #1
    lv_label_align_t align = lv_label_get_align(label);
    5c92:	4681      	mov	r9, r0
    if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
    5c94:	d113      	bne.n	5cbe <lv_label_get_letter_on+0x72>
    5c96:	f046 0604 	orr.w	r6, r6, #4
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
    5c9a:	7ba3      	ldrb	r3, [r4, #14]
        max_w = LV_COORD_MAX;
    5c9c:	9a05      	ldr	r2, [sp, #20]
    5c9e:	f013 0f07 	tst.w	r3, #7
    5ca2:	f647 4318 	movw	r3, #31768	; 0x7c18
    5ca6:	bf08      	it	eq
    5ca8:	461a      	moveq	r2, r3
    5caa:	f04f 0a00 	mov.w	sl, #0
    5cae:	9205      	str	r2, [sp, #20]
    5cb0:	4655      	mov	r5, sl
    while(txt[line_start] != '\0') {
    5cb2:	9b03      	ldr	r3, [sp, #12]
    5cb4:	195f      	adds	r7, r3, r5
    5cb6:	5d5b      	ldrb	r3, [r3, r5]
    5cb8:	b933      	cbnz	r3, 5cc8 <lv_label_get_letter_on+0x7c>
    5cba:	462c      	mov	r4, r5
    5cbc:	e021      	b.n	5d02 <lv_label_get_letter_on+0xb6>
    if(align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
    5cbe:	2802      	cmp	r0, #2
    5cc0:	bf08      	it	eq
    5cc2:	f046 0608 	orreq.w	r6, r6, #8
    5cc6:	e7e8      	b.n	5c9a <lv_label_get_letter_on+0x4e>
        new_line_start += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, max_w, flag);
    5cc8:	f9bb 2038 	ldrsh.w	r2, [fp, #56]	; 0x38
    5ccc:	9600      	str	r6, [sp, #0]
    5cce:	e9dd 1304 	ldrd	r1, r3, [sp, #16]
    5cd2:	4638      	mov	r0, r7
    5cd4:	f7ff fe40 	bl	5958 <lv_txt_get_next_line>
        if(pos->y <= y + letter_height) {
    5cd8:	9b07      	ldr	r3, [sp, #28]
    5cda:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
    5cde:	9b06      	ldr	r3, [sp, #24]
    5ce0:	4453      	add	r3, sl
    5ce2:	429a      	cmp	r2, r3
        new_line_start += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, max_w, flag);
    5ce4:	eb00 0405 	add.w	r4, r0, r5
        if(pos->y <= y + letter_height) {
    5ce8:	dc3a      	bgt.n	5d60 <lv_label_get_letter_on+0x114>
            letter = lv_txt_encoded_prev(txt, &tmp);
    5cea:	4b4c      	ldr	r3, [pc, #304]	; (5e1c <lv_label_get_letter_on+0x1d0>)
            uint32_t tmp = new_line_start;
    5cec:	9409      	str	r4, [sp, #36]	; 0x24
            letter = lv_txt_encoded_prev(txt, &tmp);
    5cee:	681b      	ldr	r3, [r3, #0]
    5cf0:	9803      	ldr	r0, [sp, #12]
    5cf2:	a909      	add	r1, sp, #36	; 0x24
    5cf4:	4798      	blx	r3
            if(letter != '\n' && txt[new_line_start] == '\0' ) new_line_start++;
    5cf6:	280a      	cmp	r0, #10
    5cf8:	d003      	beq.n	5d02 <lv_label_get_letter_on+0xb6>
    5cfa:	9b03      	ldr	r3, [sp, #12]
    5cfc:	5d1b      	ldrb	r3, [r3, r4]
    5cfe:	b903      	cbnz	r3, 5d02 <lv_label_get_letter_on+0xb6>
    5d00:	3401      	adds	r4, #1
    if(align == LV_LABEL_ALIGN_CENTER) {
    5d02:	f1b9 0f01 	cmp.w	r9, #1
    5d06:	d134      	bne.n	5d72 <lv_label_get_letter_on+0x126>
        line_w = lv_txt_get_width(bidi_txt, new_line_start - line_start, font, style->text.letter_space, flag);
    5d08:	1b61      	subs	r1, r4, r5
    5d0a:	f9bb 3038 	ldrsh.w	r3, [fp, #56]	; 0x38
    5d0e:	9a04      	ldr	r2, [sp, #16]
    5d10:	9600      	str	r6, [sp, #0]
    5d12:	b289      	uxth	r1, r1
    5d14:	4638      	mov	r0, r7
    5d16:	f7ff fdcf 	bl	58b8 <lv_txt_get_width>
    5d1a:	4681      	mov	r9, r0
        x += lv_obj_get_width(label) / 2 - line_w / 2;
    5d1c:	4640      	mov	r0, r8
    5d1e:	f003 f907 	bl	8f30 <lv_obj_get_width>
    5d22:	eb09 79d9 	add.w	r9, r9, r9, lsr #31
    5d26:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
    5d2a:	ea4f 0969 	mov.w	r9, r9, asr #1
    5d2e:	ebc9 0960 	rsb	r9, r9, r0, asr #1
    5d32:	fa0f f889 	sxth.w	r8, r9
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
    5d36:	2300      	movs	r3, #0
    5d38:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    uint32_t i = 0;
    5d3c:	9309      	str	r3, [sp, #36]	; 0x24
    if(new_line_start > 0) {
    5d3e:	2c00      	cmp	r4, #0
    5d40:	d165      	bne.n	5e0e <lv_label_get_letter_on+0x1c2>
    logical_pos = lv_txt_encoded_get_char_id(bidi_txt, i);
    5d42:	4e37      	ldr	r6, [pc, #220]	; (5e20 <lv_label_get_letter_on+0x1d4>)
    5d44:	9909      	ldr	r1, [sp, #36]	; 0x24
    5d46:	6833      	ldr	r3, [r6, #0]
    5d48:	4638      	mov	r0, r7
    5d4a:	4798      	blx	r3
    return  logical_pos + lv_txt_encoded_get_char_id(txt, line_start);
    5d4c:	6833      	ldr	r3, [r6, #0]
    logical_pos = lv_txt_encoded_get_char_id(bidi_txt, i);
    5d4e:	4604      	mov	r4, r0
    return  logical_pos + lv_txt_encoded_get_char_id(txt, line_start);
    5d50:	4629      	mov	r1, r5
    5d52:	9803      	ldr	r0, [sp, #12]
    5d54:	4798      	blx	r3
    5d56:	4420      	add	r0, r4
}
    5d58:	b280      	uxth	r0, r0
    5d5a:	b00b      	add	sp, #44	; 0x2c
    5d5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        y += letter_height + style->text.line_space;
    5d60:	f8bb 303a 	ldrh.w	r3, [fp, #58]	; 0x3a
    5d64:	9a06      	ldr	r2, [sp, #24]
    5d66:	4413      	add	r3, r2
    5d68:	449a      	add	sl, r3
    5d6a:	fa0f fa8a 	sxth.w	sl, sl
        new_line_start += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, max_w, flag);
    5d6e:	4625      	mov	r5, r4
    5d70:	e79f      	b.n	5cb2 <lv_label_get_letter_on+0x66>
    else if(align == LV_LABEL_ALIGN_RIGHT) {
    5d72:	f1b9 0f02 	cmp.w	r9, #2
    5d76:	d111      	bne.n	5d9c <lv_label_get_letter_on+0x150>
        line_w = lv_txt_get_width(bidi_txt, new_line_start - line_start, font, style->text.letter_space, flag);
    5d78:	1b61      	subs	r1, r4, r5
    5d7a:	f9bb 3038 	ldrsh.w	r3, [fp, #56]	; 0x38
    5d7e:	9a04      	ldr	r2, [sp, #16]
    5d80:	9600      	str	r6, [sp, #0]
    5d82:	b289      	uxth	r1, r1
    5d84:	4638      	mov	r0, r7
    5d86:	f7ff fd97 	bl	58b8 <lv_txt_get_width>
    5d8a:	4681      	mov	r9, r0
        x += lv_obj_get_width(label) - line_w;
    5d8c:	4640      	mov	r0, r8
    5d8e:	f003 f8cf 	bl	8f30 <lv_obj_get_width>
    5d92:	eba0 0009 	sub.w	r0, r0, r9
    5d96:	fa0f f880 	sxth.w	r8, r0
    5d9a:	e7cc      	b.n	5d36 <lv_label_get_letter_on+0xea>
    lv_coord_t x = 0;
    5d9c:	f04f 0800 	mov.w	r8, #0
    5da0:	e7c9      	b.n	5d36 <lv_label_get_letter_on+0xea>
                if(lv_txt_is_cmd(&cmd_state, bidi_txt[i]) != false) {
    5da2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5da4:	9006      	str	r0, [sp, #24]
    5da6:	5cf9      	ldrb	r1, [r7, r3]
    5da8:	f10d 0023 	add.w	r0, sp, #35	; 0x23
    5dac:	f004 fc71 	bl	a692 <lv_txt_is_cmd>
    5db0:	9a06      	ldr	r2, [sp, #24]
    5db2:	b190      	cbz	r0, 5dda <lv_label_get_letter_on+0x18e>
        while(i + line_start < new_line_start) {
    5db4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5db6:	442b      	add	r3, r5
    5db8:	42a3      	cmp	r3, r4
    5dba:	d2c2      	bcs.n	5d42 <lv_label_get_letter_on+0xf6>
            letter = lv_txt_encoded_next(bidi_txt, &i);
    5dbc:	f8d9 3000 	ldr.w	r3, [r9]
    5dc0:	a909      	add	r1, sp, #36	; 0x24
    5dc2:	4638      	mov	r0, r7
    5dc4:	4798      	blx	r3
    5dc6:	9005      	str	r0, [sp, #20]
            letter_next = lv_txt_encoded_next(&bidi_txt[i], NULL);
    5dc8:	9809      	ldr	r0, [sp, #36]	; 0x24
    5dca:	f8d9 3000 	ldr.w	r3, [r9]
    5dce:	2100      	movs	r1, #0
    5dd0:	4438      	add	r0, r7
    5dd2:	4798      	blx	r3
    5dd4:	4602      	mov	r2, r0
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    5dd6:	2e00      	cmp	r6, #0
    5dd8:	d1e3      	bne.n	5da2 <lv_label_get_letter_on+0x156>
            x += lv_font_get_glyph_width(font, letter, letter_next);
    5dda:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    5dde:	f004 feeb 	bl	abb8 <lv_font_get_glyph_width>
            if(pos->x < x || i + line_start == new_line_start) {
    5de2:	9b07      	ldr	r3, [sp, #28]
            x += lv_font_get_glyph_width(font, letter, letter_next);
    5de4:	4480      	add	r8, r0
            if(pos->x < x || i + line_start == new_line_start) {
    5de6:	f9b3 3000 	ldrsh.w	r3, [r3]
            x += lv_font_get_glyph_width(font, letter, letter_next);
    5dea:	fa0f f888 	sxth.w	r8, r8
            if(pos->x < x || i + line_start == new_line_start) {
    5dee:	4543      	cmp	r3, r8
    5df0:	da02      	bge.n	5df8 <lv_label_get_letter_on+0x1ac>
                i = i_act;
    5df2:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
                break;
    5df6:	e7a4      	b.n	5d42 <lv_label_get_letter_on+0xf6>
            if(pos->x < x || i + line_start == new_line_start) {
    5df8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5dfa:	195a      	adds	r2, r3, r5
    5dfc:	42a2      	cmp	r2, r4
    5dfe:	d0f8      	beq.n	5df2 <lv_label_get_letter_on+0x1a6>
            x += style->text.letter_space;
    5e00:	f8bb 0038 	ldrh.w	r0, [fp, #56]	; 0x38
    5e04:	4480      	add	r8, r0
    5e06:	fa0f f888 	sxth.w	r8, r8
            i_act = i;
    5e0a:	469a      	mov	sl, r3
    5e0c:	e7d2      	b.n	5db4 <lv_label_get_letter_on+0x168>
    uint32_t i_act = i;
    5e0e:	469a      	mov	sl, r3
            letter = lv_txt_encoded_next(bidi_txt, &i);
    5e10:	f8df 9010 	ldr.w	r9, [pc, #16]	; 5e24 <lv_label_get_letter_on+0x1d8>
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    5e14:	f006 0601 	and.w	r6, r6, #1
    5e18:	e7cc      	b.n	5db4 <lv_label_get_letter_on+0x168>
    5e1a:	bf00      	nop
    5e1c:	200068c4 	.word	0x200068c4
    5e20:	200068bc 	.word	0x200068bc
    5e24:	200068c0 	.word	0x200068c0

00005e28 <lv_label_refr_text>:
{
    5e28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5e2c:	b089      	sub	sp, #36	; 0x24
    5e2e:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    5e30:	f003 f8ec 	bl	900c <lv_obj_get_ext_attr>
    if(ext->text == NULL) return;
    5e34:	6803      	ldr	r3, [r0, #0]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    5e36:	4604      	mov	r4, r0
    if(ext->text == NULL) return;
    5e38:	b373      	cbz	r3, 5e98 <lv_label_refr_text+0x70>
    lv_coord_t max_w         = lv_obj_get_width(label);
    5e3a:	4628      	mov	r0, r5
    5e3c:	f003 f878 	bl	8f30 <lv_obj_get_width>
    5e40:	4607      	mov	r7, r0
    const lv_style_t * style = lv_obj_get_style(label);
    5e42:	4628      	mov	r0, r5
    5e44:	f7fd ffd8 	bl	3df8 <lv_obj_get_style>
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
    5e48:	7ba3      	ldrb	r3, [r4, #14]
    const lv_font_t * font   = style->text.font;
    5e4a:	6b42      	ldr	r2, [r0, #52]	; 0x34
        max_w = LV_COORD_MAX;
    5e4c:	f013 0f07 	tst.w	r3, #7
    5e50:	f647 4118 	movw	r1, #31768	; 0x7c18
    5e54:	bf08      	it	eq
    5e56:	460f      	moveq	r7, r1
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
    5e58:	f3c3 1180 	ubfx	r1, r3, #6, #1
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
    5e5c:	061b      	lsls	r3, r3, #24
    5e5e:	bf48      	it	mi
    5e60:	f041 0102 	orrmi.w	r1, r1, #2
    lv_txt_get_size(&size, ext->text, font, style->text.letter_space, style->text.line_space, max_w, flag);
    5e64:	f9b0 3038 	ldrsh.w	r3, [r0, #56]	; 0x38
    5e68:	e9cd 7101 	strd	r7, r1, [sp, #4]
    5e6c:	f9b0 103a 	ldrsh.w	r1, [r0, #58]	; 0x3a
    5e70:	9100      	str	r1, [sp, #0]
    const lv_style_t * style = lv_obj_get_style(label);
    5e72:	4606      	mov	r6, r0
    lv_txt_get_size(&size, ext->text, font, style->text.letter_space, style->text.line_space, max_w, flag);
    5e74:	6821      	ldr	r1, [r4, #0]
    5e76:	a805      	add	r0, sp, #20
    5e78:	f004 fc28 	bl	a6cc <lv_txt_get_size>
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
    5e7c:	7ba3      	ldrb	r3, [r4, #14]
    5e7e:	f013 0307 	ands.w	r3, r3, #7
    5e82:	d10c      	bne.n	5e9e <lv_label_refr_text+0x76>
        lv_obj_set_size(label, size.x, size.y);
    5e84:	f9bd 2016 	ldrsh.w	r2, [sp, #22]
    5e88:	f9bd 1014 	ldrsh.w	r1, [sp, #20]
    5e8c:	4628      	mov	r0, r5
    5e8e:	f002 fe9f 	bl	8bd0 <lv_obj_set_size>
    lv_obj_invalidate(label);
    5e92:	4628      	mov	r0, r5
    5e94:	f002 fdfa 	bl	8a8c <lv_obj_invalidate>
}
    5e98:	b009      	add	sp, #36	; 0x24
    5e9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    else if(ext->long_mode == LV_LABEL_LONG_SROLL) {
    5e9e:	1eda      	subs	r2, r3, #3
    5ea0:	2a01      	cmp	r2, #1
    5ea2:	d9f6      	bls.n	5e92 <lv_label_refr_text+0x6a>
    } else if(ext->long_mode == LV_LABEL_LONG_DOT) {
    5ea4:	2b02      	cmp	r3, #2
    5ea6:	d16e      	bne.n	5f86 <lv_label_refr_text+0x15e>
        if(size.y <= lv_obj_get_height(label)) { /*No dots are required, the text is short enough*/
    5ea8:	4628      	mov	r0, r5
    5eaa:	f9bd 7016 	ldrsh.w	r7, [sp, #22]
    5eae:	f003 f845 	bl	8f3c <lv_obj_get_height>
    5eb2:	4287      	cmp	r7, r0
    5eb4:	dc03      	bgt.n	5ebe <lv_label_refr_text+0x96>
            ext->dot_end = LV_LABEL_DOT_END_INV;
    5eb6:	f64f 73ff 	movw	r3, #65535	; 0xffff
    5eba:	8123      	strh	r3, [r4, #8]
    5ebc:	e7e9      	b.n	5e92 <lv_label_refr_text+0x6a>
        } else if(lv_txt_get_encoded_length(ext->text) <= LV_LABEL_DOT_NUM) { /*Don't turn to dots all the characters*/
    5ebe:	4b36      	ldr	r3, [pc, #216]	; (5f98 <lv_label_refr_text+0x170>)
    5ec0:	6820      	ldr	r0, [r4, #0]
    5ec2:	681b      	ldr	r3, [r3, #0]
    5ec4:	4798      	blx	r3
    5ec6:	2803      	cmp	r0, #3
    5ec8:	d9f5      	bls.n	5eb6 <lv_label_refr_text+0x8e>
            p.x = lv_obj_get_width(label) -
    5eca:	4628      	mov	r0, r5
    5ecc:	f003 f830 	bl	8f30 <lv_obj_get_width>
                  (lv_font_get_glyph_width(style->text.font, '.', '.') + style->text.letter_space) *
    5ed0:	222e      	movs	r2, #46	; 0x2e
    5ed2:	4611      	mov	r1, r2
            p.x = lv_obj_get_width(label) -
    5ed4:	4607      	mov	r7, r0
                  (lv_font_get_glyph_width(style->text.font, '.', '.') + style->text.letter_space) *
    5ed6:	6b70      	ldr	r0, [r6, #52]	; 0x34
                len += lv_txt_encoded_size(&ext->text[byte_id]);
    5ed8:	f8df a0c4 	ldr.w	sl, [pc, #196]	; 5fa0 <lv_label_refr_text+0x178>
                lv_txt_encoded_next(ext->text, &byte_id);
    5edc:	f8df b0c4 	ldr.w	fp, [pc, #196]	; 5fa4 <lv_label_refr_text+0x17c>
                  (lv_font_get_glyph_width(style->text.font, '.', '.') + style->text.letter_space) *
    5ee0:	f004 fe6a 	bl	abb8 <lv_font_get_glyph_width>
    5ee4:	f9b6 3038 	ldrsh.w	r3, [r6, #56]	; 0x38
    5ee8:	4418      	add	r0, r3
            p.x = lv_obj_get_width(label) -
    5eea:	eba0 0080 	sub.w	r0, r0, r0, lsl #2
    5eee:	4438      	add	r0, r7
    5ef0:	f8ad 0018 	strh.w	r0, [sp, #24]
            p.y = lv_obj_get_height(label);
    5ef4:	4628      	mov	r0, r5
    5ef6:	f003 f821 	bl	8f3c <lv_obj_get_height>
                   (lv_font_get_line_height(style->text.font) + style->text.line_space); /*Round down to the last line*/
    5efa:	6b73      	ldr	r3, [r6, #52]	; 0x34
    5efc:	f9b6 103a 	ldrsh.w	r1, [r6, #58]	; 0x3a
    5f00:	7a1b      	ldrb	r3, [r3, #8]
    5f02:	440b      	add	r3, r1
            p.y -= style->text.line_space;                                               /*Trim the last line space*/
    5f04:	1a42      	subs	r2, r0, r1
            p.y -= p.y %
    5f06:	fb90 f1f3 	sdiv	r1, r0, r3
    5f0a:	fb03 0311 	mls	r3, r3, r1, r0
            p.y -= style->text.line_space;                                               /*Trim the last line space*/
    5f0e:	1ad2      	subs	r2, r2, r3
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
    5f10:	a906      	add	r1, sp, #24
    5f12:	4628      	mov	r0, r5
            p.y -= style->text.line_space;                                               /*Trim the last line space*/
    5f14:	f8ad 201a 	strh.w	r2, [sp, #26]
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
    5f18:	f7ff fe98 	bl	5c4c <lv_label_get_letter_on>
            uint32_t byte_id     = lv_txt_encoded_get_byte_id(ext->text, letter_id);
    5f1c:	4b1f      	ldr	r3, [pc, #124]	; (5f9c <lv_label_refr_text+0x174>)
    5f1e:	4601      	mov	r1, r0
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
    5f20:	4607      	mov	r7, r0
            uint32_t byte_id     = lv_txt_encoded_get_byte_id(ext->text, letter_id);
    5f22:	681b      	ldr	r3, [r3, #0]
    5f24:	6820      	ldr	r0, [r4, #0]
    5f26:	4798      	blx	r3
    5f28:	f04f 0804 	mov.w	r8, #4
    5f2c:	4606      	mov	r6, r0
    5f2e:	9007      	str	r0, [sp, #28]
            uint8_t len          = 0;
    5f30:	f04f 0900 	mov.w	r9, #0
                len += lv_txt_encoded_size(&ext->text[byte_id]);
    5f34:	9907      	ldr	r1, [sp, #28]
    5f36:	6820      	ldr	r0, [r4, #0]
    5f38:	f8da 3000 	ldr.w	r3, [sl]
    5f3c:	4408      	add	r0, r1
    5f3e:	4798      	blx	r3
                lv_txt_encoded_next(ext->text, &byte_id);
    5f40:	f8db 3000 	ldr.w	r3, [fp]
                len += lv_txt_encoded_size(&ext->text[byte_id]);
    5f44:	4481      	add	r9, r0
                lv_txt_encoded_next(ext->text, &byte_id);
    5f46:	a907      	add	r1, sp, #28
    5f48:	6820      	ldr	r0, [r4, #0]
    5f4a:	4798      	blx	r3
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
    5f4c:	f1b8 0801 	subs.w	r8, r8, #1
                len += lv_txt_encoded_size(&ext->text[byte_id]);
    5f50:	fa5f f989 	uxtb.w	r9, r9
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
    5f54:	d1ee      	bne.n	5f34 <lv_label_refr_text+0x10c>
            if(lv_label_set_dot_tmp(label, &ext->text[byte_id_ori], len)) {
    5f56:	6821      	ldr	r1, [r4, #0]
    5f58:	464a      	mov	r2, r9
    5f5a:	4431      	add	r1, r6
    5f5c:	4628      	mov	r0, r5
    5f5e:	f7ff fe3f 	bl	5be0 <lv_label_set_dot_tmp>
    5f62:	2800      	cmp	r0, #0
    5f64:	d095      	beq.n	5e92 <lv_label_refr_text+0x6a>
                    ext->text[byte_id_ori + i] = '.';
    5f66:	6823      	ldr	r3, [r4, #0]
    5f68:	222e      	movs	r2, #46	; 0x2e
    5f6a:	559a      	strb	r2, [r3, r6]
    5f6c:	6823      	ldr	r3, [r4, #0]
    5f6e:	4433      	add	r3, r6
                ext->dot_end                              = letter_id + LV_LABEL_DOT_NUM;
    5f70:	3703      	adds	r7, #3
                    ext->text[byte_id_ori + i] = '.';
    5f72:	705a      	strb	r2, [r3, #1]
    5f74:	6823      	ldr	r3, [r4, #0]
    5f76:	4433      	add	r3, r6
    5f78:	709a      	strb	r2, [r3, #2]
                ext->text[byte_id_ori + LV_LABEL_DOT_NUM] = '\0';
    5f7a:	6823      	ldr	r3, [r4, #0]
    5f7c:	441e      	add	r6, r3
    5f7e:	f886 8003 	strb.w	r8, [r6, #3]
                ext->dot_end                              = letter_id + LV_LABEL_DOT_NUM;
    5f82:	8127      	strh	r7, [r4, #8]
    5f84:	e785      	b.n	5e92 <lv_label_refr_text+0x6a>
    else if(ext->long_mode == LV_LABEL_LONG_BREAK) {
    5f86:	2b01      	cmp	r3, #1
    5f88:	d183      	bne.n	5e92 <lv_label_refr_text+0x6a>
        lv_obj_set_height(label, size.y);
    5f8a:	f9bd 1016 	ldrsh.w	r1, [sp, #22]
    5f8e:	4628      	mov	r0, r5
    5f90:	f002 fe61 	bl	8c56 <lv_obj_set_height>
    5f94:	e77d      	b.n	5e92 <lv_label_refr_text+0x6a>
    5f96:	bf00      	nop
    5f98:	200068cc 	.word	0x200068cc
    5f9c:	200068b8 	.word	0x200068b8
    5fa0:	200068c8 	.word	0x200068c8
    5fa4:	200068c0 	.word	0x200068c0

00005fa8 <lv_label_signal>:
    res = ancestor_signal(label, sign, param);
    5fa8:	4b34      	ldr	r3, [pc, #208]	; (607c <lv_label_signal+0xd4>)
{
    5faa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    res = ancestor_signal(label, sign, param);
    5fae:	681b      	ldr	r3, [r3, #0]
{
    5fb0:	4604      	mov	r4, r0
    5fb2:	460d      	mov	r5, r1
    5fb4:	4617      	mov	r7, r2
    res = ancestor_signal(label, sign, param);
    5fb6:	4798      	blx	r3
    if(res != LV_RES_OK) return res;
    5fb8:	2801      	cmp	r0, #1
    res = ancestor_signal(label, sign, param);
    5fba:	4606      	mov	r6, r0
    if(res != LV_RES_OK) return res;
    5fbc:	d118      	bne.n	5ff0 <lv_label_signal+0x48>
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    5fbe:	2d07      	cmp	r5, #7
    5fc0:	d105      	bne.n	5fce <lv_label_signal+0x26>
    5fc2:	4638      	mov	r0, r7
    5fc4:	492e      	ldr	r1, [pc, #184]	; (6080 <lv_label_signal+0xd8>)
}
    5fc6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    5fca:	f003 b821 	b.w	9010 <lv_obj_handle_get_type_signal>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    5fce:	4620      	mov	r0, r4
    5fd0:	f003 f81c 	bl	900c <lv_obj_get_ext_attr>
    5fd4:	4680      	mov	r8, r0
    if(sign == LV_SIGNAL_CLEANUP) {
    5fd6:	b975      	cbnz	r5, 5ff6 <lv_label_signal+0x4e>
        if(ext->static_txt == 0) {
    5fd8:	7b83      	ldrb	r3, [r0, #14]
    5fda:	f013 0508 	ands.w	r5, r3, #8
    5fde:	d104      	bne.n	5fea <lv_label_signal+0x42>
            lv_mem_free(ext->text);
    5fe0:	6800      	ldr	r0, [r0, #0]
    5fe2:	f7ff fc19 	bl	5818 <lv_mem_free>
            ext->text = NULL;
    5fe6:	f8c8 5000 	str.w	r5, [r8]
        lv_label_dot_tmp_free(label);
    5fea:	4620      	mov	r0, r4
    5fec:	f004 fbe1 	bl	a7b2 <lv_label_dot_tmp_free>
}
    5ff0:	4630      	mov	r0, r6
    5ff2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
    5ff6:	2d04      	cmp	r5, #4
    5ff8:	d106      	bne.n	6008 <lv_label_signal+0x60>
        lv_label_revert_dots(label);
    5ffa:	4620      	mov	r0, r4
    5ffc:	f7ff fdb8 	bl	5b70 <lv_label_revert_dots>
        lv_label_refr_text(label);
    6000:	4620      	mov	r0, r4
    6002:	f7ff ff11 	bl	5e28 <lv_label_refr_text>
    6006:	e7f3      	b.n	5ff0 <lv_label_signal+0x48>
    } else if(sign == LV_SIGNAL_CORD_CHG) {
    6008:	2d02      	cmp	r5, #2
    600a:	d114      	bne.n	6036 <lv_label_signal+0x8e>
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    600c:	8a23      	ldrh	r3, [r4, #16]
    600e:	8aa2      	ldrh	r2, [r4, #20]
    6010:	8839      	ldrh	r1, [r7, #0]
    6012:	1ad2      	subs	r2, r2, r3
    6014:	88bb      	ldrh	r3, [r7, #4]
    6016:	1a5b      	subs	r3, r3, r1
        if(lv_area_get_width(&label->coords) != lv_area_get_width(param) ||
    6018:	b212      	sxth	r2, r2
    601a:	b21b      	sxth	r3, r3
    601c:	429a      	cmp	r2, r3
    601e:	d1ec      	bne.n	5ffa <lv_label_signal+0x52>
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    6020:	8a63      	ldrh	r3, [r4, #18]
    6022:	8ae2      	ldrh	r2, [r4, #22]
    6024:	8879      	ldrh	r1, [r7, #2]
    6026:	1ad2      	subs	r2, r2, r3
    6028:	88fb      	ldrh	r3, [r7, #6]
    602a:	1a5b      	subs	r3, r3, r1
    602c:	b212      	sxth	r2, r2
    602e:	b21b      	sxth	r3, r3
    6030:	429a      	cmp	r2, r3
    6032:	d1e2      	bne.n	5ffa <lv_label_signal+0x52>
    6034:	e7dc      	b.n	5ff0 <lv_label_signal+0x48>
    } else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
    6036:	2d06      	cmp	r5, #6
    6038:	d1da      	bne.n	5ff0 <lv_label_signal+0x48>
        if(ext->body_draw) {
    603a:	7bc3      	ldrb	r3, [r0, #15]
    603c:	f013 0501 	ands.w	r5, r3, #1
    6040:	d0d6      	beq.n	5ff0 <lv_label_signal+0x48>
 * @return pointer to the label's style
 */
static inline const lv_style_t * lv_label_get_style(const lv_obj_t * label, lv_label_style_t type)
{
    (void)type; /*Unused*/
    return lv_obj_get_style(label);
    6042:	4620      	mov	r0, r4
    6044:	f7fd fed8 	bl	3df8 <lv_obj_get_style>
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.right);
    6048:	f9b0 3024 	ldrsh.w	r3, [r0, #36]	; 0x24
    604c:	f9b0 2026 	ldrsh.w	r2, [r0, #38]	; 0x26
    6050:	4293      	cmp	r3, r2
    6052:	bfb8      	it	lt
    6054:	4613      	movlt	r3, r2
    6056:	f9b4 2030 	ldrsh.w	r2, [r4, #48]	; 0x30
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.top);
    605a:	4293      	cmp	r3, r2
    605c:	bfb8      	it	lt
    605e:	4613      	movlt	r3, r2
    6060:	f9b0 2020 	ldrsh.w	r2, [r0, #32]
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.bottom);
    6064:	4293      	cmp	r3, r2
    6066:	bfb8      	it	lt
    6068:	4613      	movlt	r3, r2
    606a:	f9b0 2022 	ldrsh.w	r2, [r0, #34]	; 0x22
    606e:	4293      	cmp	r3, r2
    6070:	bfb8      	it	lt
    6072:	4613      	movlt	r3, r2
    6074:	8623      	strh	r3, [r4, #48]	; 0x30
    6076:	462e      	mov	r6, r5
    6078:	e7ba      	b.n	5ff0 <lv_label_signal+0x48>
    607a:	bf00      	nop
    607c:	20000e68 	.word	0x20000e68
    6080:	0000c699 	.word	0x0000c699

00006084 <lv_label_create>:
{
    6084:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6088:	460e      	mov	r6, r1
    lv_obj_t * new_label = lv_obj_create(par, copy);
    608a:	f7fd fd85 	bl	3b98 <lv_obj_create>
    if(new_label == NULL) return NULL;
    608e:	4604      	mov	r4, r0
    6090:	b918      	cbnz	r0, 609a <lv_label_create+0x16>
    6092:	2400      	movs	r4, #0
}
    6094:	4620      	mov	r0, r4
    6096:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_label);
    609a:	4d53      	ldr	r5, [pc, #332]	; (61e8 <lv_label_create+0x164>)
    609c:	682b      	ldr	r3, [r5, #0]
    609e:	b913      	cbnz	r3, 60a6 <lv_label_create+0x22>
    60a0:	f002 ffb2 	bl	9008 <lv_obj_get_signal_cb>
    60a4:	6028      	str	r0, [r5, #0]
    lv_obj_allocate_ext_attr(new_label, sizeof(lv_label_ext_t));
    60a6:	2110      	movs	r1, #16
    60a8:	4620      	mov	r0, r4
    60aa:	f002 fce8 	bl	8a7e <lv_obj_allocate_ext_attr>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(new_label);
    60ae:	4620      	mov	r0, r4
    60b0:	f002 ffac 	bl	900c <lv_obj_get_ext_attr>
    if(ext == NULL) return NULL;
    60b4:	4605      	mov	r5, r0
    60b6:	2800      	cmp	r0, #0
    60b8:	d0eb      	beq.n	6092 <lv_label_create+0xe>
    ext->text       = NULL;
    60ba:	2300      	movs	r3, #0
    ext->dot.tmp_ptr   = NULL;
    60bc:	e9c0 3300 	strd	r3, r3, [r0]
    ext->dot_end    = LV_LABEL_DOT_END_INV;
    60c0:	f64f 73ff 	movw	r3, #65535	; 0xffff
    ext->offset.y = 0;
    60c4:	68c2      	ldr	r2, [r0, #12]
    ext->dot_end    = LV_LABEL_DOT_END_INV;
    60c6:	6083      	str	r3, [r0, #8]
    ext->offset.y = 0;
    60c8:	4b48      	ldr	r3, [pc, #288]	; (61ec <lv_label_create+0x168>)
    lv_obj_set_design_cb(new_label, lv_label_design);
    60ca:	4949      	ldr	r1, [pc, #292]	; (61f0 <lv_label_create+0x16c>)
    ext->offset.y = 0;
    60cc:	4013      	ands	r3, r2
    60ce:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
    60d2:	60c3      	str	r3, [r0, #12]
    lv_obj_set_design_cb(new_label, lv_label_design);
    60d4:	4620      	mov	r0, r4
    60d6:	f002 fcd0 	bl	8a7a <lv_obj_set_design_cb>
    lv_obj_set_signal_cb(new_label, lv_label_signal);
    60da:	4946      	ldr	r1, [pc, #280]	; (61f4 <lv_label_create+0x170>)
    60dc:	4620      	mov	r0, r4
    60de:	f002 fcca 	bl	8a76 <lv_obj_set_signal_cb>
    if(copy == NULL) {
    60e2:	b9b6      	cbnz	r6, 6112 <lv_label_create+0x8e>
        lv_obj_set_click(new_label, false);
    60e4:	4631      	mov	r1, r6
    60e6:	4620      	mov	r0, r4
    60e8:	f002 fcbe 	bl	8a68 <lv_obj_set_click>
        lv_label_set_long_mode(new_label, LV_LABEL_LONG_EXPAND);
    60ec:	4631      	mov	r1, r6
    60ee:	4620      	mov	r0, r4
    60f0:	f004 fd21 	bl	ab36 <lv_label_set_long_mode>
        lv_label_set_text(new_label, "Text");
    60f4:	4940      	ldr	r1, [pc, #256]	; (61f8 <lv_label_create+0x174>)
    60f6:	4620      	mov	r0, r4
    60f8:	f004 fcc8 	bl	aa8c <lv_label_set_text>
    lv_obj_set_style(label, style);
    60fc:	4631      	mov	r1, r6
    60fe:	4620      	mov	r0, r4
    6100:	f002 fdd5 	bl	8cae <lv_obj_set_style>
    LV_LOG_INFO("label created");
    6104:	4b3d      	ldr	r3, [pc, #244]	; (61fc <lv_label_create+0x178>)
    6106:	493e      	ldr	r1, [pc, #248]	; (6200 <lv_label_create+0x17c>)
    6108:	22a1      	movs	r2, #161	; 0xa1
    610a:	2001      	movs	r0, #1
    610c:	f7ff fd20 	bl	5b50 <lv_log_add>
    return new_label;
    6110:	e7c0      	b.n	6094 <lv_label_create+0x10>
        lv_label_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
    6112:	4630      	mov	r0, r6
    6114:	f002 ff7a 	bl	900c <lv_obj_get_ext_attr>
    6118:	4607      	mov	r7, r0
        lv_label_set_long_mode(new_label, lv_label_get_long_mode(copy));
    611a:	4630      	mov	r0, r6
    611c:	f004 fb89 	bl	a832 <lv_label_get_long_mode>
    6120:	4601      	mov	r1, r0
    6122:	4620      	mov	r0, r4
    6124:	f004 fd07 	bl	ab36 <lv_label_set_long_mode>
        lv_label_set_recolor(new_label, lv_label_get_recolor(copy));
    6128:	4630      	mov	r0, r6
    612a:	f004 fca1 	bl	aa70 <lv_label_get_recolor>
    612e:	4601      	mov	r1, r0
    6130:	4620      	mov	r0, r4
    6132:	f004 fd27 	bl	ab84 <lv_label_set_recolor>
        lv_label_set_body_draw(new_label, lv_label_get_body_draw(copy));
    6136:	4630      	mov	r0, r6
    6138:	f004 fca1 	bl	aa7e <lv_label_get_body_draw>
    613c:	4601      	mov	r1, r0
    613e:	4620      	mov	r0, r4
    6140:	f004 fb5c 	bl	a7fc <lv_label_set_body_draw>
        lv_label_set_align(new_label, lv_label_get_align(copy));
    6144:	4630      	mov	r0, r6
    6146:	f004 fb7b 	bl	a840 <lv_label_get_align>
    614a:	4601      	mov	r1, r0
    614c:	4620      	mov	r0, r4
    614e:	f004 fb42 	bl	a7d6 <lv_label_set_align>
        if(copy_ext->static_txt == 0)
    6152:	7bbb      	ldrb	r3, [r7, #14]
    6154:	071a      	lsls	r2, r3, #28
            lv_label_set_text(new_label, lv_label_get_text(copy));
    6156:	4630      	mov	r0, r6
        if(copy_ext->static_txt == 0)
    6158:	d439      	bmi.n	61ce <lv_label_create+0x14a>
            lv_label_set_text(new_label, lv_label_get_text(copy));
    615a:	f004 fb65 	bl	a828 <lv_label_get_text>
    615e:	4601      	mov	r1, r0
    6160:	4620      	mov	r0, r4
    6162:	f004 fc93 	bl	aa8c <lv_label_set_text>
        if(copy_ext->long_mode == LV_LABEL_LONG_DOT) {
    6166:	7bbb      	ldrb	r3, [r7, #14]
    6168:	f003 0307 	and.w	r3, r3, #7
    616c:	2b02      	cmp	r3, #2
    616e:	d115      	bne.n	619c <lv_label_create+0x118>
            ext->text = lv_mem_realloc(ext->text, lv_mem_get_size(copy_ext->text));
    6170:	6838      	ldr	r0, [r7, #0]
    6172:	682e      	ldr	r6, [r5, #0]
    6174:	f7ff fb60 	bl	5838 <lv_mem_get_size>
    6178:	4601      	mov	r1, r0
    617a:	4630      	mov	r0, r6
    617c:	f7ff fb6a 	bl	5854 <lv_mem_realloc>
    6180:	4606      	mov	r6, r0
    6182:	6028      	str	r0, [r5, #0]
            if(ext->text == NULL) return NULL;
    6184:	2800      	cmp	r0, #0
    6186:	d084      	beq.n	6092 <lv_label_create+0xe>
            memcpy(ext->text, copy_ext->text, lv_mem_get_size(copy_ext->text));
    6188:	f8d7 8000 	ldr.w	r8, [r7]
    618c:	4640      	mov	r0, r8
    618e:	f7ff fb53 	bl	5838 <lv_mem_get_size>
    6192:	4641      	mov	r1, r8
    6194:	4602      	mov	r2, r0
    6196:	4630      	mov	r0, r6
    6198:	f001 ff88 	bl	80ac <memcpy>
        if(copy_ext->dot_tmp_alloc && copy_ext->dot.tmp_ptr) {
    619c:	7bfb      	ldrb	r3, [r7, #15]
    619e:	079b      	lsls	r3, r3, #30
    61a0:	d51c      	bpl.n	61dc <lv_label_create+0x158>
    61a2:	6878      	ldr	r0, [r7, #4]
    61a4:	b1d0      	cbz	r0, 61dc <lv_label_create+0x158>
            uint16_t len = (uint16_t    )strlen(copy_ext->dot.tmp_ptr);
    61a6:	f001 ff6e 	bl	8086 <strlen>
            lv_label_set_dot_tmp(new_label, ext->dot.tmp_ptr, len);
    61aa:	6869      	ldr	r1, [r5, #4]
    61ac:	b282      	uxth	r2, r0
    61ae:	4620      	mov	r0, r4
    61b0:	f7ff fd16 	bl	5be0 <lv_label_set_dot_tmp>
        ext->dot_tmp_alloc = copy_ext->dot_tmp_alloc;
    61b4:	7bfb      	ldrb	r3, [r7, #15]
    61b6:	7bea      	ldrb	r2, [r5, #15]
    61b8:	f3c3 0340 	ubfx	r3, r3, #1, #1
    61bc:	f363 0241 	bfi	r2, r3, #1, #1
    61c0:	73ea      	strb	r2, [r5, #15]
        ext->dot_end       = copy_ext->dot_end;
    61c2:	893b      	ldrh	r3, [r7, #8]
    61c4:	812b      	strh	r3, [r5, #8]
        lv_obj_refresh_style(new_label);
    61c6:	4620      	mov	r0, r4
    61c8:	f002 fce8 	bl	8b9c <lv_obj_refresh_style>
    61cc:	e79a      	b.n	6104 <lv_label_create+0x80>
            lv_label_set_static_text(new_label, lv_label_get_text(copy));
    61ce:	f004 fb2b 	bl	a828 <lv_label_get_text>
    61d2:	4601      	mov	r1, r0
    61d4:	4620      	mov	r0, r4
    61d6:	f004 fc94 	bl	ab02 <lv_label_set_static_text>
    61da:	e7c4      	b.n	6166 <lv_label_create+0xe2>
            memcpy(ext->dot.tmp, copy_ext->dot.tmp, sizeof(ext->dot.tmp));
    61dc:	2204      	movs	r2, #4
    61de:	18b9      	adds	r1, r7, r2
    61e0:	18a8      	adds	r0, r5, r2
    61e2:	f001 ff63 	bl	80ac <memcpy>
    61e6:	e7e5      	b.n	61b4 <lv_label_create+0x130>
    61e8:	20000e68 	.word	0x20000e68
    61ec:	fc800000 	.word	0xfc800000
    61f0:	0000a855 	.word	0x0000a855
    61f4:	00005fa9 	.word	0x00005fa9
    61f8:	0000c625 	.word	0x0000c625
    61fc:	0000c62a 	.word	0x0000c62a
    6200:	0000c662 	.word	0x0000c662

00006204 <lv_theme_get_current>:
    if(!inited)
        return NULL;
    else
        return &current_theme;
#endif
}
    6204:	4b01      	ldr	r3, [pc, #4]	; (620c <lv_theme_get_current+0x8>)
    6206:	6818      	ldr	r0, [r3, #0]
    6208:	4770      	bx	lr
    620a:	bf00      	nop
    620c:	20000e6c 	.word	0x20000e6c

00006210 <bits_write>:
 * @param len length of bits to write from `val`. (Counted from the LSB).
 * @note `len == 3` will be converted to `len = 4` and `val` will be upscaled too
 */
static void bits_write(uint8_t * out, uint32_t bit_pos, uint8_t val, uint8_t len)
{
    if(len == 3) {
    6210:	2b03      	cmp	r3, #3
{
    6212:	b530      	push	{r4, r5, lr}
    if(len == 3) {
    6214:	d104      	bne.n	6220 <bits_write+0x10>
        len = 4;
        switch(val) {
    6216:	2a07      	cmp	r2, #7
    6218:	bf9c      	itt	ls
    621a:	4b0a      	ldrls	r3, [pc, #40]	; (6244 <bits_write+0x34>)
    621c:	5c9a      	ldrbls	r2, [r3, r2]
        len = 4;
    621e:	2304      	movs	r3, #4
        case 7: val = 15; break;
        }
    }

    uint16_t byte_pos = bit_pos >> 3;
    bit_pos = bit_pos & 0x7;
    6220:	f001 0507 	and.w	r5, r1, #7
    bit_pos = 8 - bit_pos - len;

    uint8_t bit_mask = (uint16_t)((uint16_t) 1 << len) - 1;
    6224:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    out[byte_pos] &= ((~bit_mask) << bit_pos);
    6228:	f3c1 01cf 	ubfx	r1, r1, #3, #16
    622c:	409c      	lsls	r4, r3
    622e:	f1c5 0508 	rsb	r5, r5, #8
    bit_pos = 8 - bit_pos - len;
    6232:	1aed      	subs	r5, r5, r3
    out[byte_pos] &= ((~bit_mask) << bit_pos);
    6234:	b264      	sxtb	r4, r4
    6236:	5c43      	ldrb	r3, [r0, r1]
    6238:	40ac      	lsls	r4, r5
    623a:	401c      	ands	r4, r3
    out[byte_pos] |= (val << bit_pos);
    623c:	40aa      	lsls	r2, r5
    623e:	4314      	orrs	r4, r2
    6240:	5444      	strb	r4, [r0, r1]
}
    6242:	bd30      	pop	{r4, r5, pc}
    6244:	0000c6a2 	.word	0x0000c6a2

00006248 <rle_next>:
    rle_prev_v = 0;
    rle_cnt = 0;
}

static uint8_t rle_next(void)
{
    6248:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint8_t v = 0;
    uint8_t ret = 0;

    if(rle_state == RLE_STATE_SINGLE) {
    624c:	4e4a      	ldr	r6, [pc, #296]	; (6378 <rle_next+0x130>)
    624e:	f896 9000 	ldrb.w	r9, [r6]
    6252:	f1b9 0f00 	cmp.w	r9, #0
    6256:	d11d      	bne.n	6294 <rle_next+0x4c>
        ret = get_bits(rle_in, rle_rdp, rle_bpp);
    6258:	4b48      	ldr	r3, [pc, #288]	; (637c <rle_next+0x134>)
    625a:	4d49      	ldr	r5, [pc, #292]	; (6380 <rle_next+0x138>)
    625c:	781f      	ldrb	r7, [r3, #0]
    625e:	f8d5 8000 	ldr.w	r8, [r5]
    6262:	4b48      	ldr	r3, [pc, #288]	; (6384 <rle_next+0x13c>)
    6264:	463a      	mov	r2, r7
    6266:	6818      	ldr	r0, [r3, #0]
    6268:	4641      	mov	r1, r8
    626a:	f004 fcc3 	bl	abf4 <get_bits>
    626e:	4b46      	ldr	r3, [pc, #280]	; (6388 <rle_next+0x140>)
    6270:	4604      	mov	r4, r0
        if(rle_rdp != 0 && rle_prev_v == ret) {
    6272:	f1b8 0f00 	cmp.w	r8, #0
    6276:	d007      	beq.n	6288 <rle_next+0x40>
    6278:	781a      	ldrb	r2, [r3, #0]
    627a:	4282      	cmp	r2, r0
            rle_cnt = 0;
    627c:	bf01      	itttt	eq
    627e:	4a43      	ldreq	r2, [pc, #268]	; (638c <rle_next+0x144>)
    6280:	f882 9000 	strbeq.w	r9, [r2]
            rle_state = RLE_STATE_REPEATE;
    6284:	2201      	moveq	r2, #1
    6286:	7032      	strbeq	r2, [r6, #0]
        }

        rle_prev_v = ret;
        rle_rdp += rle_bpp;
    6288:	4447      	add	r7, r8
        rle_prev_v = ret;
    628a:	701c      	strb	r4, [r3, #0]
        rle_rdp += rle_bpp;
    628c:	602f      	str	r7, [r5, #0]
            rle_state = RLE_STATE_SINGLE;
        }
    }

    return ret;
}
    628e:	4620      	mov	r0, r4
    6290:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    else if(rle_state == RLE_STATE_REPEATE) {
    6294:	f1b9 0f01 	cmp.w	r9, #1
    6298:	d149      	bne.n	632e <rle_next+0xe6>
        v = get_bits(rle_in, rle_rdp, 1);
    629a:	4b3a      	ldr	r3, [pc, #232]	; (6384 <rle_next+0x13c>)
    629c:	4f38      	ldr	r7, [pc, #224]	; (6380 <rle_next+0x138>)
    629e:	f8d3 8000 	ldr.w	r8, [r3]
    62a2:	683d      	ldr	r5, [r7, #0]
        rle_cnt++;
    62a4:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 638c <rle_next+0x144>
        v = get_bits(rle_in, rle_rdp, 1);
    62a8:	464a      	mov	r2, r9
    62aa:	4629      	mov	r1, r5
    62ac:	4640      	mov	r0, r8
    62ae:	f004 fca1 	bl	abf4 <get_bits>
        rle_cnt++;
    62b2:	f89a 3000 	ldrb.w	r3, [sl]
    62b6:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 6388 <rle_next+0x140>
    62ba:	3301      	adds	r3, #1
    62bc:	b2db      	uxtb	r3, r3
        rle_rdp += 1;
    62be:	f105 0b01 	add.w	fp, r5, #1
        if(v == 1) {
    62c2:	2801      	cmp	r0, #1
        rle_cnt++;
    62c4:	f88a 3000 	strb.w	r3, [sl]
        rle_rdp += 1;
    62c8:	f8c7 b000 	str.w	fp, [r7]
        if(v == 1) {
    62cc:	d121      	bne.n	6312 <rle_next+0xca>
            if(rle_cnt == 11) {
    62ce:	2b0b      	cmp	r3, #11
            ret = rle_prev_v;
    62d0:	f899 4000 	ldrb.w	r4, [r9]
            if(rle_cnt == 11) {
    62d4:	d1db      	bne.n	628e <rle_next+0x46>
                rle_cnt = get_bits(rle_in, rle_rdp, 6);
    62d6:	4659      	mov	r1, fp
    62d8:	2206      	movs	r2, #6
    62da:	4640      	mov	r0, r8
    62dc:	f004 fc8a 	bl	abf4 <get_bits>
                rle_rdp += 6;
    62e0:	3507      	adds	r5, #7
                rle_cnt = get_bits(rle_in, rle_rdp, 6);
    62e2:	4683      	mov	fp, r0
    62e4:	f88a 0000 	strb.w	r0, [sl]
                rle_rdp += 6;
    62e8:	603d      	str	r5, [r7, #0]
                if(rle_cnt != 0) {
    62ea:	b110      	cbz	r0, 62f2 <rle_next+0xaa>
                    rle_state = RLE_STATE_COUNTER;
    62ec:	2302      	movs	r3, #2
            rle_state = RLE_STATE_SINGLE;
    62ee:	7033      	strb	r3, [r6, #0]
    62f0:	e7cd      	b.n	628e <rle_next+0x46>
                    ret = get_bits(rle_in, rle_rdp, rle_bpp);
    62f2:	4b22      	ldr	r3, [pc, #136]	; (637c <rle_next+0x134>)
    62f4:	f893 a000 	ldrb.w	sl, [r3]
    62f8:	4629      	mov	r1, r5
    62fa:	4652      	mov	r2, sl
    62fc:	4640      	mov	r0, r8
    62fe:	f004 fc79 	bl	abf4 <get_bits>
                    rle_rdp += rle_bpp;
    6302:	4455      	add	r5, sl
                    ret = get_bits(rle_in, rle_rdp, rle_bpp);
    6304:	4604      	mov	r4, r0
                    rle_prev_v = ret;
    6306:	f889 0000 	strb.w	r0, [r9]
                    rle_rdp += rle_bpp;
    630a:	603d      	str	r5, [r7, #0]
                    rle_state = RLE_STATE_SINGLE;
    630c:	f886 b000 	strb.w	fp, [r6]
    6310:	e7bd      	b.n	628e <rle_next+0x46>
            ret = get_bits(rle_in, rle_rdp, rle_bpp);
    6312:	4b1a      	ldr	r3, [pc, #104]	; (637c <rle_next+0x134>)
    6314:	781d      	ldrb	r5, [r3, #0]
    6316:	4659      	mov	r1, fp
    6318:	462a      	mov	r2, r5
    631a:	4640      	mov	r0, r8
    631c:	f004 fc6a 	bl	abf4 <get_bits>
            rle_rdp += rle_bpp;
    6320:	445d      	add	r5, fp
            ret = get_bits(rle_in, rle_rdp, rle_bpp);
    6322:	4604      	mov	r4, r0
            rle_prev_v = ret;
    6324:	f889 0000 	strb.w	r0, [r9]
            rle_rdp += rle_bpp;
    6328:	603d      	str	r5, [r7, #0]
            rle_state = RLE_STATE_SINGLE;
    632a:	2300      	movs	r3, #0
    632c:	e7df      	b.n	62ee <rle_next+0xa6>
    else if(rle_state == RLE_STATE_COUNTER) {
    632e:	f1b9 0f02 	cmp.w	r9, #2
    6332:	d11e      	bne.n	6372 <rle_next+0x12a>
        rle_cnt--;
    6334:	4b15      	ldr	r3, [pc, #84]	; (638c <rle_next+0x144>)
        ret = rle_prev_v;
    6336:	f8df a050 	ldr.w	sl, [pc, #80]	; 6388 <rle_next+0x140>
        rle_cnt--;
    633a:	781d      	ldrb	r5, [r3, #0]
        ret = rle_prev_v;
    633c:	f89a 4000 	ldrb.w	r4, [sl]
        rle_cnt--;
    6340:	3d01      	subs	r5, #1
    6342:	b2ed      	uxtb	r5, r5
    6344:	701d      	strb	r5, [r3, #0]
        if(rle_cnt == 0) {
    6346:	2d00      	cmp	r5, #0
    6348:	d1a1      	bne.n	628e <rle_next+0x46>
            ret = get_bits(rle_in, rle_rdp, rle_bpp);
    634a:	f8df 8034 	ldr.w	r8, [pc, #52]	; 6380 <rle_next+0x138>
    634e:	4b0b      	ldr	r3, [pc, #44]	; (637c <rle_next+0x134>)
    6350:	f8d8 9000 	ldr.w	r9, [r8]
    6354:	781f      	ldrb	r7, [r3, #0]
    6356:	4b0b      	ldr	r3, [pc, #44]	; (6384 <rle_next+0x13c>)
    6358:	463a      	mov	r2, r7
    635a:	4649      	mov	r1, r9
    635c:	6818      	ldr	r0, [r3, #0]
    635e:	f004 fc49 	bl	abf4 <get_bits>
            rle_rdp += rle_bpp;
    6362:	444f      	add	r7, r9
            ret = get_bits(rle_in, rle_rdp, rle_bpp);
    6364:	4604      	mov	r4, r0
            rle_prev_v = ret;
    6366:	f88a 0000 	strb.w	r0, [sl]
            rle_rdp += rle_bpp;
    636a:	f8c8 7000 	str.w	r7, [r8]
            rle_state = RLE_STATE_SINGLE;
    636e:	7035      	strb	r5, [r6, #0]
    6370:	e78d      	b.n	628e <rle_next+0x46>
    uint8_t ret = 0;
    6372:	2400      	movs	r4, #0
    6374:	e78b      	b.n	628e <rle_next+0x46>
    6376:	bf00      	nop
    6378:	20005323 	.word	0x20005323
    637c:	20005320 	.word	0x20005320
    6380:	20000e78 	.word	0x20000e78
    6384:	20000e74 	.word	0x20000e74
    6388:	20005322 	.word	0x20005322
    638c:	20005321 	.word	0x20005321

00006390 <get_glyph_dsc_id.isra.0.part.1>:
static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
    6390:	b5f0      	push	{r4, r5, r6, r7, lr}
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
    6392:	6804      	ldr	r4, [r0, #0]
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
    6394:	6963      	ldr	r3, [r4, #20]
    6396:	428b      	cmp	r3, r1
static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
    6398:	b085      	sub	sp, #20
    639a:	460d      	mov	r5, r1
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
    639c:	d145      	bne.n	642a <get_glyph_dsc_id.isra.0.part.1+0x9a>
    639e:	69a0      	ldr	r0, [r4, #24]
}
    63a0:	b005      	add	sp, #20
    63a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
    63a4:	68a2      	ldr	r2, [r4, #8]
    63a6:	fb07 f603 	mul.w	r6, r7, r3
    63aa:	1991      	adds	r1, r2, r6
    63ac:	5992      	ldr	r2, [r2, r6]
        if(rcp > fdsc->cmaps[i].range_length) continue;
    63ae:	8888      	ldrh	r0, [r1, #4]
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
    63b0:	1aaa      	subs	r2, r5, r2
        if(rcp > fdsc->cmaps[i].range_length) continue;
    63b2:	4282      	cmp	r2, r0
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
    63b4:	9203      	str	r2, [sp, #12]
        if(rcp > fdsc->cmaps[i].range_length) continue;
    63b6:	f103 0301 	add.w	r3, r3, #1
    63ba:	d838      	bhi.n	642e <get_glyph_dsc_id.isra.0.part.1+0x9e>
        if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY) {
    63bc:	7c8b      	ldrb	r3, [r1, #18]
    63be:	b923      	cbnz	r3, 63ca <get_glyph_dsc_id.isra.0.part.1+0x3a>
            glyph_id = fdsc->cmaps[i].glyph_id_start + rcp;
    63c0:	88c8      	ldrh	r0, [r1, #6]
    63c2:	4410      	add	r0, r2
        fdsc->last_letter = letter;
    63c4:	6165      	str	r5, [r4, #20]
    fdsc->last_glyph_id = 0;
    63c6:	61a0      	str	r0, [r4, #24]
    return 0;
    63c8:	e7ea      	b.n	63a0 <get_glyph_dsc_id.isra.0.part.1+0x10>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL) {
    63ca:	2b01      	cmp	r3, #1
    63cc:	d104      	bne.n	63d8 <get_glyph_dsc_id.isra.0.part.1+0x48>
            glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_8[rcp];
    63ce:	68cb      	ldr	r3, [r1, #12]
    63d0:	5c98      	ldrb	r0, [r3, r2]
    63d2:	88cb      	ldrh	r3, [r1, #6]
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
    63d4:	4418      	add	r0, r3
    63d6:	e7f5      	b.n	63c4 <get_glyph_dsc_id.isra.0.part.1+0x34>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_TINY) {
    63d8:	2b02      	cmp	r3, #2
    63da:	d111      	bne.n	6400 <get_glyph_dsc_id.isra.0.part.1+0x70>
            uint8_t * p = lv_utils_bsearch(&rcp, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length, sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);
    63dc:	4818      	ldr	r0, [pc, #96]	; (6440 <get_glyph_dsc_id.isra.0.part.1+0xb0>)
    63de:	8a0a      	ldrh	r2, [r1, #16]
    63e0:	9000      	str	r0, [sp, #0]
    63e2:	6889      	ldr	r1, [r1, #8]
    63e4:	a803      	add	r0, sp, #12
    63e6:	f004 f9c6 	bl	a776 <lv_utils_bsearch>
            if(p) {
    63ea:	b908      	cbnz	r0, 63f0 <get_glyph_dsc_id.isra.0.part.1+0x60>
        uint32_t glyph_id = 0;
    63ec:	2000      	movs	r0, #0
    63ee:	e7e9      	b.n	63c4 <get_glyph_dsc_id.isra.0.part.1+0x34>
                lv_uintptr_t ofs = (lv_uintptr_t)(p - (uint8_t *) fdsc->cmaps[i].unicode_list);
    63f0:	68a3      	ldr	r3, [r4, #8]
    63f2:	4433      	add	r3, r6
    63f4:	689a      	ldr	r2, [r3, #8]
    63f6:	1a82      	subs	r2, r0, r2
                glyph_id = fdsc->cmaps[i].glyph_id_start + ofs;
    63f8:	88d8      	ldrh	r0, [r3, #6]
    63fa:	eb00 0052 	add.w	r0, r0, r2, lsr #1
    63fe:	e7e1      	b.n	63c4 <get_glyph_dsc_id.isra.0.part.1+0x34>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_FULL) {
    6400:	2b03      	cmp	r3, #3
    6402:	d1f3      	bne.n	63ec <get_glyph_dsc_id.isra.0.part.1+0x5c>
            uint8_t * p = lv_utils_bsearch(&rcp, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length, sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);
    6404:	4b0e      	ldr	r3, [pc, #56]	; (6440 <get_glyph_dsc_id.isra.0.part.1+0xb0>)
    6406:	8a0a      	ldrh	r2, [r1, #16]
    6408:	9300      	str	r3, [sp, #0]
    640a:	6889      	ldr	r1, [r1, #8]
    640c:	2302      	movs	r3, #2
    640e:	a803      	add	r0, sp, #12
    6410:	f004 f9b1 	bl	a776 <lv_utils_bsearch>
            if(p) {
    6414:	2800      	cmp	r0, #0
    6416:	d0e9      	beq.n	63ec <get_glyph_dsc_id.isra.0.part.1+0x5c>
                lv_uintptr_t ofs = (lv_uintptr_t)(p - (uint8_t*) fdsc->cmaps[i].unicode_list);
    6418:	68a3      	ldr	r3, [r4, #8]
    641a:	4433      	add	r3, r6
    641c:	689a      	ldr	r2, [r3, #8]
    641e:	1a80      	subs	r0, r0, r2
                ofs = ofs >> 1;     /*The list stores `uint16_t` so the get the index divide by 2*/
    6420:	0840      	lsrs	r0, r0, #1
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
    6422:	68da      	ldr	r2, [r3, #12]
    6424:	88db      	ldrh	r3, [r3, #6]
    6426:	5c10      	ldrb	r0, [r2, r0]
    6428:	e7d4      	b.n	63d4 <get_glyph_dsc_id.isra.0.part.1+0x44>
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
    642a:	2300      	movs	r3, #0
    642c:	2714      	movs	r7, #20
    for(i = 0; i < fdsc->cmap_num; i++) {
    642e:	8a62      	ldrh	r2, [r4, #18]
    6430:	b299      	uxth	r1, r3
    6432:	f3c2 0209 	ubfx	r2, r2, #0, #10
    6436:	428a      	cmp	r2, r1
    6438:	d8b4      	bhi.n	63a4 <get_glyph_dsc_id.isra.0.part.1+0x14>
    fdsc->last_letter = letter;
    643a:	6165      	str	r5, [r4, #20]
    fdsc->last_glyph_id = 0;
    643c:	2000      	movs	r0, #0
    643e:	e7c2      	b.n	63c6 <get_glyph_dsc_id.isra.0.part.1+0x36>
    6440:	0000ac1d 	.word	0x0000ac1d

00006444 <lv_font_get_bitmap_fmt_txt>:
{
    6444:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6448:	b087      	sub	sp, #28
    if(letter == '\0') return 0;
    644a:	b919      	cbnz	r1, 6454 <lv_font_get_bitmap_fmt_txt+0x10>
    if(!gid) return NULL;
    644c:	2000      	movs	r0, #0
}
    644e:	b007      	add	sp, #28
    6450:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
    6454:	f850 6f0c 	ldr.w	r6, [r0, #12]!
    6458:	f7ff ff9a 	bl	6390 <get_glyph_dsc_id.isra.0.part.1>
    if(!gid) return NULL;
    645c:	4680      	mov	r8, r0
    645e:	2800      	cmp	r0, #0
    6460:	d0f4      	beq.n	644c <lv_font_get_bitmap_fmt_txt+0x8>
    if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {
    6462:	7cf3      	ldrb	r3, [r6, #19]
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
    6464:	f8d6 9004 	ldr.w	r9, [r6, #4]
    if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {
    6468:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
    646c:	eb09 07c0 	add.w	r7, r9, r0, lsl #3
    if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {
    6470:	d108      	bne.n	6484 <lv_font_get_bitmap_fmt_txt+0x40>
        if(gdsc) return &fdsc->glyph_bitmap[gdsc->bitmap_index];
    6472:	2f00      	cmp	r7, #0
    6474:	d0ea      	beq.n	644c <lv_font_get_bitmap_fmt_txt+0x8>
    6476:	f859 3030 	ldr.w	r3, [r9, r0, lsl #3]
    647a:	6830      	ldr	r0, [r6, #0]
    647c:	f3c3 0313 	ubfx	r3, r3, #0, #20
    6480:	4418      	add	r0, r3
    6482:	e7e4      	b.n	644e <lv_font_get_bitmap_fmt_txt+0xa>
        uint32_t gsize = gdsc->box_w * gdsc->box_h;
    6484:	793c      	ldrb	r4, [r7, #4]
    6486:	7979      	ldrb	r1, [r7, #5]
    6488:	fb14 f401 	smulbb	r4, r4, r1
        if(gsize == 0) return NULL;
    648c:	2c00      	cmp	r4, #0
    648e:	d0dd      	beq.n	644c <lv_font_get_bitmap_fmt_txt+0x8>
        switch(fdsc->bpp) {
    6490:	f3c3 0382 	ubfx	r3, r3, #2, #3
    6494:	3b01      	subs	r3, #1
    6496:	2b03      	cmp	r3, #3
    6498:	d804      	bhi.n	64a4 <lv_font_get_bitmap_fmt_txt+0x60>
    649a:	e8df f003 	tbb	[pc, r3]
    649e:	4502      	.short	0x4502
    64a0:	4747      	.short	0x4747
        case 1: buf_size = gsize >> 3;  break;
    64a2:	08e4      	lsrs	r4, r4, #3
        if(lv_mem_get_size(buf) < buf_size) {
    64a4:	4d41      	ldr	r5, [pc, #260]	; (65ac <lv_font_get_bitmap_fmt_txt+0x168>)
    64a6:	6828      	ldr	r0, [r5, #0]
    64a8:	f7ff f9c6 	bl	5838 <lv_mem_get_size>
    64ac:	42a0      	cmp	r0, r4
    64ae:	d33f      	bcc.n	6530 <lv_font_get_bitmap_fmt_txt+0xec>
        decompress(&fdsc->glyph_bitmap[gdsc->bitmap_index], buf, gdsc->box_w , gdsc->box_h, (uint8_t)fdsc->bpp);
    64b0:	f859 2038 	ldr.w	r2, [r9, r8, lsl #3]
    64b4:	6833      	ldr	r3, [r6, #0]
    64b6:	f3c2 0213 	ubfx	r2, r2, #0, #20
    64ba:	441a      	add	r2, r3
    64bc:	682b      	ldr	r3, [r5, #0]
    64be:	9302      	str	r3, [sp, #8]
    64c0:	797b      	ldrb	r3, [r7, #5]
    64c2:	9304      	str	r3, [sp, #16]
    64c4:	7cf3      	ldrb	r3, [r6, #19]
    64c6:	793d      	ldrb	r5, [r7, #4]
    64c8:	f3c3 0382 	ubfx	r3, r3, #2, #3
    64cc:	b2df      	uxtb	r7, r3
    if(bpp == 3) wr_size = 4;
    64ce:	2f03      	cmp	r7, #3
    64d0:	bf14      	ite	ne
    64d2:	4639      	movne	r1, r7
    64d4:	2104      	moveq	r1, #4
    64d6:	9100      	str	r1, [sp, #0]
    rle_in = in;
    64d8:	4935      	ldr	r1, [pc, #212]	; (65b0 <lv_font_get_bitmap_fmt_txt+0x16c>)
    64da:	600a      	str	r2, [r1, #0]
    rle_bpp = bpp;
    64dc:	4a35      	ldr	r2, [pc, #212]	; (65b4 <lv_font_get_bitmap_fmt_txt+0x170>)
    64de:	7013      	strb	r3, [r2, #0]
    rle_state = RLE_STATE_SINGLE;
    64e0:	4a35      	ldr	r2, [pc, #212]	; (65b8 <lv_font_get_bitmap_fmt_txt+0x174>)
    64e2:	2300      	movs	r3, #0
    64e4:	7013      	strb	r3, [r2, #0]
    rle_rdp = 0;
    64e6:	4a35      	ldr	r2, [pc, #212]	; (65bc <lv_font_get_bitmap_fmt_txt+0x178>)
    64e8:	6013      	str	r3, [r2, #0]
    rle_prev_v = 0;
    64ea:	4a35      	ldr	r2, [pc, #212]	; (65c0 <lv_font_get_bitmap_fmt_txt+0x17c>)
    64ec:	7013      	strb	r3, [r2, #0]
    rle_cnt = 0;
    64ee:	4a35      	ldr	r2, [pc, #212]	; (65c4 <lv_font_get_bitmap_fmt_txt+0x180>)
    uint8_t * line_buf = lv_draw_get_buf(w * 2);
    64f0:	0068      	lsls	r0, r5, #1
    rle_cnt = 0;
    64f2:	7013      	strb	r3, [r2, #0]
    uint8_t * line_buf = lv_draw_get_buf(w * 2);
    64f4:	f7fe fa62 	bl	49bc <lv_draw_get_buf>
    64f8:	4680      	mov	r8, r0
    uint8_t * line_buf2 = line_buf + w;
    64fa:	1946      	adds	r6, r0, r5
static void decompress_line(uint8_t * out, lv_coord_t w)
    64fc:	4681      	mov	r9, r0
    uint8_t * line_buf2 = line_buf + w;
    64fe:	4604      	mov	r4, r0
    for(i = 0; i < w; i++) {
    6500:	42b4      	cmp	r4, r6
    6502:	d11d      	bne.n	6540 <lv_font_get_bitmap_fmt_txt+0xfc>
    uint32_t wrp = 0;
    6504:	f04f 0a00 	mov.w	sl, #0
    for(x = 0; x < w; x++) {
    6508:	45a1      	cmp	r9, r4
    650a:	d11e      	bne.n	654a <lv_font_get_bitmap_fmt_txt+0x106>
    650c:	9b00      	ldr	r3, [sp, #0]
    650e:	fb15 f303 	smulbb	r3, r5, r3
    6512:	9303      	str	r3, [sp, #12]
    6514:	4699      	mov	r9, r3
    6516:	1973      	adds	r3, r6, r5
    for(y = 1; y < h; y++) {
    6518:	2401      	movs	r4, #1
    651a:	9305      	str	r3, [sp, #20]
    651c:	9b04      	ldr	r3, [sp, #16]
    651e:	42a3      	cmp	r3, r4
    6520:	dd40      	ble.n	65a4 <lv_font_get_bitmap_fmt_txt+0x160>
    6522:	9601      	str	r6, [sp, #4]
    6524:	4635      	mov	r5, r6
    6526:	e01e      	b.n	6566 <lv_font_get_bitmap_fmt_txt+0x122>
        case 2: buf_size = gsize >> 2;  break;
    6528:	08a4      	lsrs	r4, r4, #2
    652a:	e7bb      	b.n	64a4 <lv_font_get_bitmap_fmt_txt+0x60>
        case 4: buf_size = gsize >> 1;  break;
    652c:	0864      	lsrs	r4, r4, #1
    652e:	e7b9      	b.n	64a4 <lv_font_get_bitmap_fmt_txt+0x60>
            buf = lv_mem_realloc(buf, buf_size);
    6530:	4621      	mov	r1, r4
    6532:	6828      	ldr	r0, [r5, #0]
    6534:	f7ff f98e 	bl	5854 <lv_mem_realloc>
    6538:	6028      	str	r0, [r5, #0]
            if(buf == NULL) return NULL;
    653a:	2800      	cmp	r0, #0
    653c:	d1b8      	bne.n	64b0 <lv_font_get_bitmap_fmt_txt+0x6c>
    653e:	e785      	b.n	644c <lv_font_get_bitmap_fmt_txt+0x8>
        out[i] = rle_next();
    6540:	f7ff fe82 	bl	6248 <rle_next>
    6544:	f804 0b01 	strb.w	r0, [r4], #1
    6548:	e7da      	b.n	6500 <lv_font_get_bitmap_fmt_txt+0xbc>
        bits_write(out,wrp, line_buf1[x], bpp);
    654a:	463b      	mov	r3, r7
    654c:	4651      	mov	r1, sl
    654e:	f819 2b01 	ldrb.w	r2, [r9], #1
    6552:	9802      	ldr	r0, [sp, #8]
    6554:	f7ff fe5c 	bl	6210 <bits_write>
        wrp += wr_size;
    6558:	9b00      	ldr	r3, [sp, #0]
    655a:	449a      	add	sl, r3
    655c:	e7d4      	b.n	6508 <lv_font_get_bitmap_fmt_txt+0xc4>
        out[i] = rle_next();
    655e:	f7ff fe73 	bl	6248 <rle_next>
    6562:	f805 0b01 	strb.w	r0, [r5], #1
    for(i = 0; i < w; i++) {
    6566:	9b05      	ldr	r3, [sp, #20]
    6568:	429d      	cmp	r5, r3
    656a:	d1f8      	bne.n	655e <lv_font_get_bitmap_fmt_txt+0x11a>
    656c:	f108 3bff 	add.w	fp, r8, #4294967295	; 0xffffffff
    6570:	46ca      	mov	sl, r9
        for(x = 0; x < w; x++) {
    6572:	9b01      	ldr	r3, [sp, #4]
    6574:	42ab      	cmp	r3, r5
    6576:	d104      	bne.n	6582 <lv_font_get_bitmap_fmt_txt+0x13e>
    6578:	9b03      	ldr	r3, [sp, #12]
    for(y = 1; y < h; y++) {
    657a:	3401      	adds	r4, #1
    657c:	4499      	add	r9, r3
    657e:	b224      	sxth	r4, r4
    6580:	e7cc      	b.n	651c <lv_font_get_bitmap_fmt_txt+0xd8>
            line_buf1[x] = line_buf2[x] ^ line_buf1[x];
    6582:	9b01      	ldr	r3, [sp, #4]
            bits_write(out,wrp, line_buf1[x], bpp);
    6584:	9802      	ldr	r0, [sp, #8]
            line_buf1[x] = line_buf2[x] ^ line_buf1[x];
    6586:	f813 2b01 	ldrb.w	r2, [r3], #1
    658a:	9301      	str	r3, [sp, #4]
    658c:	f81b 3f01 	ldrb.w	r3, [fp, #1]!
    6590:	405a      	eors	r2, r3
            bits_write(out,wrp, line_buf1[x], bpp);
    6592:	4651      	mov	r1, sl
    6594:	463b      	mov	r3, r7
            line_buf1[x] = line_buf2[x] ^ line_buf1[x];
    6596:	f88b 2000 	strb.w	r2, [fp]
            bits_write(out,wrp, line_buf1[x], bpp);
    659a:	f7ff fe39 	bl	6210 <bits_write>
            wrp += wr_size;
    659e:	9b00      	ldr	r3, [sp, #0]
    65a0:	449a      	add	sl, r3
    65a2:	e7e6      	b.n	6572 <lv_font_get_bitmap_fmt_txt+0x12e>
        return buf;
    65a4:	4b01      	ldr	r3, [pc, #4]	; (65ac <lv_font_get_bitmap_fmt_txt+0x168>)
    65a6:	6818      	ldr	r0, [r3, #0]
    65a8:	e751      	b.n	644e <lv_font_get_bitmap_fmt_txt+0xa>
    65aa:	bf00      	nop
    65ac:	20000e70 	.word	0x20000e70
    65b0:	20000e74 	.word	0x20000e74
    65b4:	20005320 	.word	0x20005320
    65b8:	20005323 	.word	0x20005323
    65bc:	20000e78 	.word	0x20000e78
    65c0:	20005322 	.word	0x20005322
    65c4:	20005321 	.word	0x20005321

000065c8 <lv_font_get_glyph_dsc_fmt_txt>:
{
    65c8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    65cc:	4680      	mov	r8, r0
    65ce:	b085      	sub	sp, #20
    65d0:	460c      	mov	r4, r1
    65d2:	4699      	mov	r9, r3
    if(letter == '\0') return 0;
    65d4:	b91a      	cbnz	r2, 65de <lv_font_get_glyph_dsc_fmt_txt+0x16>
    if(!gid) return false;
    65d6:	2000      	movs	r0, #0
}
    65d8:	b005      	add	sp, #20
    65da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
    65de:	4607      	mov	r7, r0
    65e0:	4611      	mov	r1, r2
    65e2:	f857 5f0c 	ldr.w	r5, [r7, #12]!
    65e6:	4638      	mov	r0, r7
    65e8:	f7ff fed2 	bl	6390 <get_glyph_dsc_id.isra.0.part.1>
    if(!gid) return false;
    65ec:	4606      	mov	r6, r0
    65ee:	2800      	cmp	r0, #0
    65f0:	d0f1      	beq.n	65d6 <lv_font_get_glyph_dsc_fmt_txt+0xe>
    if(fdsc->kern_dsc) {
    65f2:	68eb      	ldr	r3, [r5, #12]
    65f4:	b9d3      	cbnz	r3, 662c <lv_font_get_glyph_dsc_fmt_txt+0x64>
    int8_t kvalue = 0;
    65f6:	2000      	movs	r0, #0
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
    65f8:	686b      	ldr	r3, [r5, #4]
    65fa:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
    int32_t kv = ((int32_t)((int32_t)kvalue * fdsc->kern_scale) >> 4);
    65fe:	8a2b      	ldrh	r3, [r5, #16]
    6600:	4358      	muls	r0, r3
    uint32_t adv_w = gdsc->adv_w + kv;
    6602:	8873      	ldrh	r3, [r6, #2]
    6604:	091b      	lsrs	r3, r3, #4
    6606:	eb03 1020 	add.w	r0, r3, r0, asr #4
    adv_w  = (adv_w + (1 << 3)) >> 4;
    660a:	3008      	adds	r0, #8
    660c:	0900      	lsrs	r0, r0, #4
    dsc_out->adv_w = adv_w;
    660e:	8020      	strh	r0, [r4, #0]
    dsc_out->box_h = gdsc->box_h;
    6610:	7973      	ldrb	r3, [r6, #5]
    6612:	70e3      	strb	r3, [r4, #3]
    dsc_out->box_w = gdsc->box_w;
    6614:	7933      	ldrb	r3, [r6, #4]
    6616:	70a3      	strb	r3, [r4, #2]
    dsc_out->ofs_x = gdsc->ofs_x;
    6618:	79b3      	ldrb	r3, [r6, #6]
    661a:	7123      	strb	r3, [r4, #4]
    dsc_out->ofs_y = gdsc->ofs_y;
    661c:	79f3      	ldrb	r3, [r6, #7]
    661e:	7163      	strb	r3, [r4, #5]
    dsc_out->bpp   = (uint8_t)fdsc->bpp;
    6620:	7ceb      	ldrb	r3, [r5, #19]
    6622:	f3c3 0382 	ubfx	r3, r3, #2, #3
    6626:	71a3      	strb	r3, [r4, #6]
    return true;
    6628:	2001      	movs	r0, #1
    662a:	e7d5      	b.n	65d8 <lv_font_get_glyph_dsc_fmt_txt+0x10>
    if(letter == '\0') return 0;
    662c:	f1b9 0f00 	cmp.w	r9, #0
    6630:	d0e1      	beq.n	65f6 <lv_font_get_glyph_dsc_fmt_txt+0x2e>
    6632:	4649      	mov	r1, r9
    6634:	4638      	mov	r0, r7
    6636:	f7ff feab 	bl	6390 <get_glyph_dsc_id.isra.0.part.1>
        if(gid_next) {
    663a:	2800      	cmp	r0, #0
    663c:	d0db      	beq.n	65f6 <lv_font_get_glyph_dsc_fmt_txt+0x2e>
            kvalue = get_kern_value(font, gid, gid_next);
    663e:	f8d8 300c 	ldr.w	r3, [r8, #12]
    if(fdsc->kern_classes == 0) {
    6642:	68df      	ldr	r7, [r3, #12]
    6644:	7cdb      	ldrb	r3, [r3, #19]
    6646:	069b      	lsls	r3, r3, #26
    6648:	d432      	bmi.n	66b0 <lv_font_get_glyph_dsc_fmt_txt+0xe8>
        if(kdsc->glyph_ids_size == 0) {
    664a:	7afb      	ldrb	r3, [r7, #11]
    664c:	f013 0303 	ands.w	r3, r3, #3
    6650:	d117      	bne.n	6682 <lv_font_get_glyph_dsc_fmt_txt+0xba>
            const uint8_t * g_ids = kdsc->glyph_ids;
    6652:	f8d7 8000 	ldr.w	r8, [r7]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
    6656:	68ba      	ldr	r2, [r7, #8]
    6658:	4b1d      	ldr	r3, [pc, #116]	; (66d0 <lv_font_get_glyph_dsc_fmt_txt+0x108>)
    665a:	9300      	str	r3, [sp, #0]
            uint16_t g_id_both = (gid_right << 8) + gid_left; /*Create one number from the ids*/
    665c:	eb06 2000 	add.w	r0, r6, r0, lsl #8
    6660:	f8ad 000c 	strh.w	r0, [sp, #12]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
    6664:	2302      	movs	r3, #2
    6666:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    666a:	4641      	mov	r1, r8
    666c:	a803      	add	r0, sp, #12
    666e:	f004 f882 	bl	a776 <lv_utils_bsearch>
            if(kid_p) {
    6672:	2800      	cmp	r0, #0
    6674:	d0c0      	beq.n	65f8 <lv_font_get_glyph_dsc_fmt_txt+0x30>
                lv_uintptr_t ofs = (lv_uintptr_t)(kid_p - g_ids);
    6676:	eba0 0008 	sub.w	r0, r0, r8
                ofs = ofs >> 1;     /*ofs is for pair, divide by 2 to refer as a single value*/
    667a:	0840      	lsrs	r0, r0, #1
                value = kdsc->values[ofs];
    667c:	687b      	ldr	r3, [r7, #4]
    667e:	5618      	ldrsb	r0, [r3, r0]
    6680:	e7ba      	b.n	65f8 <lv_font_get_glyph_dsc_fmt_txt+0x30>
        } else if(kdsc->glyph_ids_size == 1) {
    6682:	2b01      	cmp	r3, #1
    6684:	d1b7      	bne.n	65f6 <lv_font_get_glyph_dsc_fmt_txt+0x2e>
            const uint16_t * g_ids = kdsc->glyph_ids;
    6686:	f8d7 8000 	ldr.w	r8, [r7]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
    668a:	68ba      	ldr	r2, [r7, #8]
    668c:	4b11      	ldr	r3, [pc, #68]	; (66d4 <lv_font_get_glyph_dsc_fmt_txt+0x10c>)
    668e:	9300      	str	r3, [sp, #0]
            lv_uintptr_t g_id_both = (uint32_t)((uint32_t)gid_right << 8) + gid_left; /*Create one number from the ids*/
    6690:	eb06 2000 	add.w	r0, r6, r0, lsl #8
    6694:	9003      	str	r0, [sp, #12]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
    6696:	2304      	movs	r3, #4
    6698:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    669c:	4641      	mov	r1, r8
    669e:	a803      	add	r0, sp, #12
    66a0:	f004 f869 	bl	a776 <lv_utils_bsearch>
            if(kid_p) {
    66a4:	2800      	cmp	r0, #0
    66a6:	d0a7      	beq.n	65f8 <lv_font_get_glyph_dsc_fmt_txt+0x30>
                lv_uintptr_t ofs = (lv_uintptr_t) (kid_p - (const uint8_t *)g_ids);
    66a8:	eba0 0008 	sub.w	r0, r0, r8
                ofs = ofs >> 4;     /*ofs is 4 byte pairs, divide by 4 to refer as a single value*/
    66ac:	0900      	lsrs	r0, r0, #4
    66ae:	e7e5      	b.n	667c <lv_font_get_glyph_dsc_fmt_txt+0xb4>
        uint8_t left_class = kdsc->left_class_mapping[gid_left];
    66b0:	687a      	ldr	r2, [r7, #4]
    66b2:	5d93      	ldrb	r3, [r2, r6]
        if(left_class > 0 && right_class > 0) {
    66b4:	2b00      	cmp	r3, #0
    66b6:	d09e      	beq.n	65f6 <lv_font_get_glyph_dsc_fmt_txt+0x2e>
        uint8_t right_class = kdsc->left_class_mapping[gid_right];
    66b8:	5c11      	ldrb	r1, [r2, r0]
        if(left_class > 0 && right_class > 0) {
    66ba:	2900      	cmp	r1, #0
    66bc:	d09b      	beq.n	65f6 <lv_font_get_glyph_dsc_fmt_txt+0x2e>
            value = kdsc->class_pair_values[(left_class-1)* kdsc->right_class_cnt + (right_class-1)];
    66be:	683a      	ldr	r2, [r7, #0]
    66c0:	7b78      	ldrb	r0, [r7, #13]
    66c2:	3b01      	subs	r3, #1
    66c4:	440a      	add	r2, r1
    66c6:	fb00 2303 	mla	r3, r0, r3, r2
    66ca:	f913 0c01 	ldrsb.w	r0, [r3, #-1]
    66ce:	e793      	b.n	65f8 <lv_font_get_glyph_dsc_fmt_txt+0x30>
    66d0:	0000abd1 	.word	0x0000abd1
    66d4:	0000abe3 	.word	0x0000abe3

000066d8 <z_sys_device_do_config_level>:
		__device_APPLICATION_start,
		/* End marker */
		__device_init_end,
	};

	for (info = config_levels[level]; info < config_levels[level+1];
    66d8:	4b09      	ldr	r3, [pc, #36]	; (6700 <z_sys_device_do_config_level+0x28>)
{
    66da:	b570      	push	{r4, r5, r6, lr}
	for (info = config_levels[level]; info < config_levels[level+1];
    66dc:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    66e0:	3001      	adds	r0, #1
		retval = device_conf->init(info);
		if (retval != 0) {
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
    66e2:	2600      	movs	r6, #0
	for (info = config_levels[level]; info < config_levels[level+1];
    66e4:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
    66e8:	42a5      	cmp	r5, r4
    66ea:	d800      	bhi.n	66ee <z_sys_device_do_config_level+0x16>
		} else {
			z_object_init(info);
		}
	}
}
    66ec:	bd70      	pop	{r4, r5, r6, pc}
		retval = device_conf->init(info);
    66ee:	6823      	ldr	r3, [r4, #0]
    66f0:	4620      	mov	r0, r4
    66f2:	685b      	ldr	r3, [r3, #4]
    66f4:	4798      	blx	r3
		if (retval != 0) {
    66f6:	b100      	cbz	r0, 66fa <z_sys_device_do_config_level+0x22>
			info->driver_api = NULL;
    66f8:	6066      	str	r6, [r4, #4]
								info++) {
    66fa:	340c      	adds	r4, #12
    66fc:	e7f4      	b.n	66e8 <z_sys_device_do_config_level+0x10>
    66fe:	bf00      	nop
    6700:	0000b800 	.word	0x0000b800

00006704 <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
    6704:	4b10      	ldr	r3, [pc, #64]	; (6748 <z_impl_device_get_binding+0x44>)
{
    6706:	b570      	push	{r4, r5, r6, lr}
	for (info = __device_init_start; info != __device_init_end; info++) {
    6708:	4c10      	ldr	r4, [pc, #64]	; (674c <z_impl_device_get_binding+0x48>)
{
    670a:	4605      	mov	r5, r0
    670c:	461e      	mov	r6, r3
	for (info = __device_init_start; info != __device_init_end; info++) {
    670e:	429c      	cmp	r4, r3
    6710:	d104      	bne.n	671c <z_impl_device_get_binding+0x18>
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
    6712:	4c0e      	ldr	r4, [pc, #56]	; (674c <z_impl_device_get_binding+0x48>)
    6714:	42b4      	cmp	r4, r6
    6716:	d109      	bne.n	672c <z_impl_device_get_binding+0x28>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
    6718:	2400      	movs	r4, #0
    671a:	e012      	b.n	6742 <z_impl_device_get_binding+0x3e>
		if ((info->driver_api != NULL) &&
    671c:	6862      	ldr	r2, [r4, #4]
    671e:	b11a      	cbz	r2, 6728 <z_impl_device_get_binding+0x24>
		    (info->config->name == name)) {
    6720:	6822      	ldr	r2, [r4, #0]
		if ((info->driver_api != NULL) &&
    6722:	6812      	ldr	r2, [r2, #0]
    6724:	42aa      	cmp	r2, r5
    6726:	d00c      	beq.n	6742 <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
    6728:	340c      	adds	r4, #12
    672a:	e7f0      	b.n	670e <z_impl_device_get_binding+0xa>
		if (info->driver_api == NULL) {
    672c:	6863      	ldr	r3, [r4, #4]
    672e:	b90b      	cbnz	r3, 6734 <z_impl_device_get_binding+0x30>
	for (info = __device_init_start; info != __device_init_end; info++) {
    6730:	340c      	adds	r4, #12
    6732:	e7ef      	b.n	6714 <z_impl_device_get_binding+0x10>
		if (strcmp(name, info->config->name) == 0) {
    6734:	6823      	ldr	r3, [r4, #0]
    6736:	4628      	mov	r0, r5
    6738:	6819      	ldr	r1, [r3, #0]
    673a:	f001 fcab 	bl	8094 <strcmp>
    673e:	2800      	cmp	r0, #0
    6740:	d1f6      	bne.n	6730 <z_impl_device_get_binding+0x2c>
}
    6742:	4620      	mov	r0, r4
    6744:	bd70      	pop	{r4, r5, r6, pc}
    6746:	bf00      	nop
    6748:	200069d0 	.word	0x200069d0
    674c:	20006934 	.word	0x20006934

00006750 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
    6750:	b510      	push	{r4, lr}
    6752:	4604      	mov	r4, r0
	z_impl_log_panic();
    6754:	f7fa f940 	bl	9d8 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
    6758:	2301      	movs	r3, #1
    675a:	f04f 0100 	mov.w	r1, #0
    675e:	f363 0107 	bfi	r1, r3, #0, #8
    6762:	4a06      	ldr	r2, [pc, #24]	; (677c <k_sys_fatal_error_handler+0x2c>)
    6764:	4b06      	ldr	r3, [pc, #24]	; (6780 <k_sys_fatal_error_handler+0x30>)
    6766:	4807      	ldr	r0, [pc, #28]	; (6784 <k_sys_fatal_error_handler+0x34>)
    6768:	1a9b      	subs	r3, r3, r2
    676a:	08db      	lsrs	r3, r3, #3
    676c:	f363 118f 	bfi	r1, r3, #6, #10
    6770:	f001 f9ef 	bl	7b52 <log_0>
	arch_system_halt(reason);
    6774:	4620      	mov	r0, r4
    6776:	f004 fa55 	bl	ac24 <arch_system_halt>
    677a:	bf00      	nop
    677c:	0000b17c 	.word	0x0000b17c
    6780:	0000b1bc 	.word	0x0000b1bc
    6784:	000117cf 	.word	0x000117cf

00006788 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    6788:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    678c:	4605      	mov	r5, r0
    678e:	4688      	mov	r8, r1
	return z_impl_k_current_get();
    6790:	f000 fd58 	bl	7244 <z_impl_k_current_get>
	struct k_thread *thread = k_current_get();

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
    6794:	2201      	movs	r2, #1
    6796:	f04f 0300 	mov.w	r3, #0
    679a:	f362 0307 	bfi	r3, r2, #0, #8
    679e:	4c24      	ldr	r4, [pc, #144]	; (6830 <z_fatal_error+0xa8>)
    67a0:	4a24      	ldr	r2, [pc, #144]	; (6834 <z_fatal_error+0xac>)
    67a2:	2d04      	cmp	r5, #4
    67a4:	eba4 0402 	sub.w	r4, r4, r2
    67a8:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    67ac:	bf96      	itet	ls
    67ae:	4a22      	ldrls	r2, [pc, #136]	; (6838 <z_fatal_error+0xb0>)
    67b0:	4a22      	ldrhi	r2, [pc, #136]	; (683c <z_fatal_error+0xb4>)
    67b2:	f852 2025 	ldrls.w	r2, [r2, r5, lsl #2]
    67b6:	f364 138f 	bfi	r3, r4, #6, #10
    67ba:	f8ad 3000 	strh.w	r3, [sp]
    67be:	4606      	mov	r6, r0
    67c0:	2300      	movs	r3, #0
    67c2:	4629      	mov	r1, r5
    67c4:	481e      	ldr	r0, [pc, #120]	; (6840 <z_fatal_error+0xb8>)
    67c6:	f001 f9fd 	bl	7bc4 <log_3>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
    67ca:	f8d8 301c 	ldr.w	r3, [r8, #28]
    67ce:	f3c3 0308 	ubfx	r3, r3, #0, #9
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if (arch_is_in_nested_exception(esf)) {
    67d2:	b14b      	cbz	r3, 67e8 <z_fatal_error+0x60>
		LOG_ERR("Fault during interrupt handling\n");
    67d4:	f04f 0100 	mov.w	r1, #0
    67d8:	2301      	movs	r3, #1
    67da:	f363 0107 	bfi	r1, r3, #0, #8
    67de:	f364 118f 	bfi	r1, r4, #6, #10
    67e2:	4818      	ldr	r0, [pc, #96]	; (6844 <z_fatal_error+0xbc>)
    67e4:	f001 f9b5 	bl	7b52 <log_0>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
    67e8:	f04f 0700 	mov.w	r7, #0
    67ec:	2301      	movs	r3, #1
    67ee:	f363 0707 	bfi	r7, r3, #0, #8
	const char *thread_name = k_thread_name_get(thread);
    67f2:	4630      	mov	r0, r6
	LOG_ERR("Current thread: %p (%s)", thread,
    67f4:	f364 178f 	bfi	r7, r4, #6, #10
	const char *thread_name = k_thread_name_get(thread);
    67f8:	f004 fb3a 	bl	ae70 <k_thread_name_get>
	if (thread_name == NULL || thread_name[0] == '\0') {
    67fc:	b1b0      	cbz	r0, 682c <z_fatal_error+0xa4>
    67fe:	7802      	ldrb	r2, [r0, #0]
		thread_name = "unknown";
    6800:	4b11      	ldr	r3, [pc, #68]	; (6848 <z_fatal_error+0xc0>)
    6802:	2a00      	cmp	r2, #0
    6804:	bf08      	it	eq
    6806:	4618      	moveq	r0, r3
	LOG_ERR("Current thread: %p (%s)", thread,
    6808:	f7f9 ff7a 	bl	700 <log_strdup>
    680c:	463b      	mov	r3, r7
    680e:	4602      	mov	r2, r0
    6810:	4631      	mov	r1, r6
    6812:	480e      	ldr	r0, [pc, #56]	; (684c <z_fatal_error+0xc4>)
    6814:	f001 f9be 	bl	7b94 <log_2>
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
    6818:	4641      	mov	r1, r8
    681a:	4628      	mov	r0, r5
    681c:	f7ff ff98 	bl	6750 <k_sys_fatal_error_handler>
	z_impl_k_thread_abort(thread);
    6820:	4630      	mov	r0, r6
			}
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	k_thread_abort(thread);
}
    6822:	b002      	add	sp, #8
    6824:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    6828:	f7fb b87e 	b.w	1928 <z_impl_k_thread_abort>
		thread_name = "unknown";
    682c:	4806      	ldr	r0, [pc, #24]	; (6848 <z_fatal_error+0xc0>)
    682e:	e7eb      	b.n	6808 <z_fatal_error+0x80>
    6830:	0000b1bc 	.word	0x0000b1bc
    6834:	0000b17c 	.word	0x0000b17c
    6838:	0000b818 	.word	0x0000b818
    683c:	00011828 	.word	0x00011828
    6840:	0001183e 	.word	0x0001183e
    6844:	00011866 	.word	0x00011866
    6848:	00011836 	.word	0x00011836
    684c:	00011887 	.word	0x00011887

00006850 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
    6850:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
    6852:	4d0b      	ldr	r5, [pc, #44]	; (6880 <idle+0x30>)
	__asm__ volatile(
    6854:	f04f 0220 	mov.w	r2, #32
    6858:	f3ef 8311 	mrs	r3, BASEPRI
    685c:	f382 8811 	msr	BASEPRI, r2
    6860:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
    6864:	f004 fb2b 	bl	aebe <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    6868:	2101      	movs	r1, #1
    686a:	2802      	cmp	r0, #2
	s32_t ticks = z_get_next_timeout_expiry();
    686c:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    686e:	bfd8      	it	le
    6870:	4608      	movle	r0, r1
    6872:	f004 fb34 	bl	aede <z_set_timeout_expiry>
	_kernel.idle = ticks;
    6876:	622c      	str	r4, [r5, #32]
 * @return N/A
 * @req K-CPU-IDLE-001
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    6878:	f7fa fd06 	bl	1288 <arch_cpu_idle>
    687c:	e7ea      	b.n	6854 <idle+0x4>
    687e:	bf00      	nop
    6880:	20000f54 	.word	0x20000f54

00006884 <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    6884:	4802      	ldr	r0, [pc, #8]	; (6890 <z_bss_zero+0xc>)
    6886:	4a03      	ldr	r2, [pc, #12]	; (6894 <z_bss_zero+0x10>)
    6888:	2100      	movs	r1, #0
    688a:	1a12      	subs	r2, r2, r0
    688c:	f001 bc38 	b.w	8100 <memset>
    6890:	20000000 	.word	0x20000000
    6894:	20005328 	.word	0x20005328

00006898 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
    6898:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
    689a:	4806      	ldr	r0, [pc, #24]	; (68b4 <z_data_copy+0x1c>)
	(void)memcpy(&__data_ram_start, &__data_rom_start,
    689c:	4a06      	ldr	r2, [pc, #24]	; (68b8 <z_data_copy+0x20>)
    689e:	4907      	ldr	r1, [pc, #28]	; (68bc <z_data_copy+0x24>)
    68a0:	1a12      	subs	r2, r2, r0
    68a2:	f001 fc03 	bl	80ac <memcpy>
#ifdef CONFIG_ARCH_HAS_RAMFUNC_SUPPORT
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
    68a6:	4a06      	ldr	r2, [pc, #24]	; (68c0 <z_data_copy+0x28>)
    68a8:	4906      	ldr	r1, [pc, #24]	; (68c4 <z_data_copy+0x2c>)
    68aa:	4807      	ldr	r0, [pc, #28]	; (68c8 <z_data_copy+0x30>)
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    68ac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
    68b0:	f001 bbfc 	b.w	80ac <memcpy>
    68b4:	20006808 	.word	0x20006808
    68b8:	20006a20 	.word	0x20006a20
    68bc:	000118ac 	.word	0x000118ac
    68c0:	00000000 	.word	0x00000000
    68c4:	000118ac 	.word	0x000118ac
    68c8:	20000000 	.word	0x20000000

000068cc <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
    68cc:	b508      	push	{r3, lr}
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
    68ce:	4b09      	ldr	r3, [pc, #36]	; (68f4 <bg_thread_main+0x28>)
    68d0:	2201      	movs	r2, #1

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
    68d2:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
    68d4:	701a      	strb	r2, [r3, #0]
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
    68d6:	f7ff feff 	bl	66d8 <z_sys_device_do_config_level>
			KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
    68da:	2003      	movs	r0, #3
    68dc:	f7ff fefc 	bl	66d8 <z_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
    68e0:	f000 fd8c 	bl	73fc <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
    68e4:	f7f9 fd6e 	bl	3c4 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    68e8:	4a03      	ldr	r2, [pc, #12]	; (68f8 <bg_thread_main+0x2c>)
    68ea:	7b13      	ldrb	r3, [r2, #12]
    68ec:	f023 0301 	bic.w	r3, r3, #1
    68f0:	7313      	strb	r3, [r2, #12]

	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    68f2:	bd08      	pop	{r3, pc}
    68f4:	20005324 	.word	0x20005324
    68f8:	20000ee8 	.word	0x20000ee8

000068fc <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
    68fc:	b580      	push	{r7, lr}
    68fe:	b0a2      	sub	sp, #136	; 0x88
#endif	/* CONFIG_STACK_CANARIES */

	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
    6900:	f7f9 fe64 	bl	5cc <log_core_init>
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(_interrupt_stack)) +
    6904:	4b35      	ldr	r3, [pc, #212]	; (69dc <z_cstart+0xe0>)
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    6906:	f383 8808 	msr	MSP, r3
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
    690a:	4c35      	ldr	r4, [pc, #212]	; (69e0 <z_cstart+0xe4>)
	_kernel.ready_q.cache = &z_main_thread;
    690c:	4e35      	ldr	r6, [pc, #212]	; (69e4 <z_cstart+0xe8>)
    690e:	6963      	ldr	r3, [r4, #20]
    6910:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    6914:	6163      	str	r3, [r4, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    6916:	2500      	movs	r5, #0
    6918:	23e0      	movs	r3, #224	; 0xe0
    691a:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
    691e:	77e5      	strb	r5, [r4, #31]
    6920:	7625      	strb	r5, [r4, #24]
    6922:	7665      	strb	r5, [r4, #25]
    6924:	76a5      	strb	r5, [r4, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
    6926:	6a63      	ldr	r3, [r4, #36]	; 0x24
    6928:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    692c:	6263      	str	r3, [r4, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    692e:	f7fa ffe7 	bl	1900 <z_arm_fault_init>
	z_arm_cpu_idle_init();
    6932:	f7fa fca3 	bl	127c <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
    6936:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    693a:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
    693c:	62e3      	str	r3, [r4, #44]	; 0x2c

	/* perform any architecture-specific initialization */
	arch_kernel_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
    693e:	ab07      	add	r3, sp, #28
    6940:	226c      	movs	r2, #108	; 0x6c
    6942:	4629      	mov	r1, r5
    6944:	4618      	mov	r0, r3
    6946:	f001 fbdb 	bl	8100 <memset>
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
    694a:	4c27      	ldr	r4, [pc, #156]	; (69e8 <z_cstart+0xec>)
	struct k_thread dummy_thread = {
    694c:	2701      	movs	r7, #1
	_current = &dummy_thread;
    694e:	60a0      	str	r0, [r4, #8]
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    6950:	4628      	mov	r0, r5
	struct k_thread dummy_thread = {
    6952:	f88d 7029 	strb.w	r7, [sp, #41]	; 0x29
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    6956:	f7ff febf 	bl	66d8 <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    695a:	4638      	mov	r0, r7
    695c:	f7ff febc 	bl	66d8 <z_sys_device_do_config_level>
	z_sched_init();
    6960:	f000 fbf0 	bl	7144 <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
    6964:	4b21      	ldr	r3, [pc, #132]	; (69ec <z_cstart+0xf0>)
	_kernel.ready_q.cache = &z_main_thread;
    6966:	6266      	str	r6, [r4, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
    6968:	f44f 6280 	mov.w	r2, #1024	; 0x400
    696c:	e9cd 7304 	strd	r7, r3, [sp, #16]
    6970:	e9cd 5502 	strd	r5, r5, [sp, #8]
    6974:	4b1e      	ldr	r3, [pc, #120]	; (69f0 <z_cstart+0xf4>)
    6976:	491f      	ldr	r1, [pc, #124]	; (69f4 <z_cstart+0xf8>)
    6978:	e9cd 5500 	strd	r5, r5, [sp]
    697c:	4630      	mov	r0, r6
    697e:	f000 fcd5 	bl	732c <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    6982:	7b73      	ldrb	r3, [r6, #13]
    6984:	f023 0204 	bic.w	r2, r3, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    6988:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
    698c:	7372      	strb	r2, [r6, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    698e:	d104      	bne.n	699a <z_cstart+0x9e>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
    6990:	69b3      	ldr	r3, [r6, #24]
    6992:	b913      	cbnz	r3, 699a <z_cstart+0x9e>
		z_add_thread_to_ready_q(thread);
    6994:	4630      	mov	r0, r6
    6996:	f000 f9e1 	bl	6d5c <z_add_thread_to_ready_q>
	z_setup_new_thread(thread, stack,
    699a:	4b17      	ldr	r3, [pc, #92]	; (69f8 <z_cstart+0xfc>)
    699c:	4d17      	ldr	r5, [pc, #92]	; (69fc <z_cstart+0x100>)
    699e:	9305      	str	r3, [sp, #20]
    69a0:	2201      	movs	r2, #1
    69a2:	230f      	movs	r3, #15
    69a4:	e9cd 3203 	strd	r3, r2, [sp, #12]
    69a8:	2300      	movs	r3, #0
    69aa:	e9cd 3301 	strd	r3, r3, [sp, #4]
    69ae:	9300      	str	r3, [sp, #0]
    69b0:	f44f 72a0 	mov.w	r2, #320	; 0x140
    69b4:	4b12      	ldr	r3, [pc, #72]	; (6a00 <z_cstart+0x104>)
    69b6:	4913      	ldr	r1, [pc, #76]	; (6a04 <z_cstart+0x108>)
    69b8:	4628      	mov	r0, r5
    69ba:	f000 fcb7 	bl	732c <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_PRESTART;
    69be:	7b6b      	ldrb	r3, [r5, #13]
	_kernel.cpus[0].idle_thread = &z_idle_thread;
    69c0:	60e5      	str	r5, [r4, #12]
    69c2:	f023 0304 	bic.w	r3, r3, #4
    69c6:	736b      	strb	r3, [r5, #13]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    69c8:	4b0f      	ldr	r3, [pc, #60]	; (6a08 <z_cstart+0x10c>)
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
    69ca:	490a      	ldr	r1, [pc, #40]	; (69f4 <z_cstart+0xf8>)
    69cc:	4805      	ldr	r0, [pc, #20]	; (69e4 <z_cstart+0xe8>)
	list->tail = (sys_dnode_t *)list;
    69ce:	e9c4 3306 	strd	r3, r3, [r4, #24]
    69d2:	f44f 6280 	mov.w	r2, #1024	; 0x400
    69d6:	4b06      	ldr	r3, [pc, #24]	; (69f0 <z_cstart+0xf4>)
    69d8:	f7fa fc32 	bl	1240 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    69dc:	20006368 	.word	0x20006368
    69e0:	e000ed00 	.word	0xe000ed00
    69e4:	20000ee8 	.word	0x20000ee8
    69e8:	20000f54 	.word	0x20000f54
    69ec:	000118a2 	.word	0x000118a2
    69f0:	000068cd 	.word	0x000068cd
    69f4:	20005628 	.word	0x20005628
    69f8:	000118a7 	.word	0x000118a7
    69fc:	20000e7c 	.word	0x20000e7c
    6a00:	00006851 	.word	0x00006851
    6a04:	20005a28 	.word	0x20005a28
    6a08:	20000f6c 	.word	0x20000f6c

00006a0c <init_mem_slab_module>:
 */
static int init_mem_slab_module(struct device *dev)
{
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    6a0c:	4b0b      	ldr	r3, [pc, #44]	; (6a3c <init_mem_slab_module+0x30>)
    6a0e:	480c      	ldr	r0, [pc, #48]	; (6a40 <init_mem_slab_module+0x34>)
{
    6a10:	b570      	push	{r4, r5, r6, lr}
	slab->free_list = NULL;
    6a12:	2400      	movs	r4, #0
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    6a14:	4283      	cmp	r3, r0
    6a16:	d301      	bcc.n	6a1c <init_mem_slab_module+0x10>
		create_free_list(slab);
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}
	return 0;
}
    6a18:	2000      	movs	r0, #0
    6a1a:	bd70      	pop	{r4, r5, r6, pc}
	p = slab->buffer;
    6a1c:	691a      	ldr	r2, [r3, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
    6a1e:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
    6a20:	615c      	str	r4, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    6a22:	2100      	movs	r1, #0
    6a24:	42a9      	cmp	r1, r5
    6a26:	d101      	bne.n	6a2c <init_mem_slab_module+0x20>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    6a28:	331c      	adds	r3, #28
    6a2a:	e7f3      	b.n	6a14 <init_mem_slab_module+0x8>
		*(char **)p = slab->free_list;
    6a2c:	695e      	ldr	r6, [r3, #20]
    6a2e:	6016      	str	r6, [r2, #0]
		p += slab->block_size;
    6a30:	68de      	ldr	r6, [r3, #12]
		slab->free_list = p;
    6a32:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    6a34:	3101      	adds	r1, #1
		p += slab->block_size;
    6a36:	4432      	add	r2, r6
    6a38:	e7f4      	b.n	6a24 <init_mem_slab_module+0x18>
    6a3a:	bf00      	nop
    6a3c:	200069d0 	.word	0x200069d0
    6a40:	200069d0 	.word	0x200069d0

00006a44 <k_mem_slab_alloc>:

	z_object_init(slab);
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, s32_t timeout)
{
    6a44:	b510      	push	{r4, lr}
    6a46:	4613      	mov	r3, r2
    6a48:	460c      	mov	r4, r1
    6a4a:	f04f 0220 	mov.w	r2, #32
    6a4e:	f3ef 8111 	mrs	r1, BASEPRI
    6a52:	f382 8811 	msr	BASEPRI, r2
    6a56:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
    6a5a:	6942      	ldr	r2, [r0, #20]
    6a5c:	b15a      	cbz	r2, 6a76 <k_mem_slab_alloc+0x32>
		/* take a free block */
		*mem = slab->free_list;
    6a5e:	6022      	str	r2, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
    6a60:	6813      	ldr	r3, [r2, #0]
    6a62:	6143      	str	r3, [r0, #20]
		slab->num_used++;
    6a64:	6983      	ldr	r3, [r0, #24]
    6a66:	3301      	adds	r3, #1
    6a68:	6183      	str	r3, [r0, #24]
		result = 0;
    6a6a:	2000      	movs	r0, #0
	__asm__ volatile(
    6a6c:	f381 8811 	msr	BASEPRI, r1
    6a70:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
    6a74:	e00d      	b.n	6a92 <k_mem_slab_alloc+0x4e>
	} else if (timeout == K_NO_WAIT) {
    6a76:	b91b      	cbnz	r3, 6a80 <k_mem_slab_alloc+0x3c>
		*mem = NULL;
    6a78:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
    6a7a:	f06f 000b 	mvn.w	r0, #11
    6a7e:	e7f5      	b.n	6a6c <k_mem_slab_alloc+0x28>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
    6a80:	4602      	mov	r2, r0
    6a82:	4804      	ldr	r0, [pc, #16]	; (6a94 <k_mem_slab_alloc+0x50>)
    6a84:	f000 fb1c 	bl	70c0 <z_pend_curr>
		if (result == 0) {
    6a88:	b918      	cbnz	r0, 6a92 <k_mem_slab_alloc+0x4e>
			*mem = _current->base.swap_data;
    6a8a:	4b03      	ldr	r3, [pc, #12]	; (6a98 <k_mem_slab_alloc+0x54>)
    6a8c:	689b      	ldr	r3, [r3, #8]
    6a8e:	695b      	ldr	r3, [r3, #20]
    6a90:	6023      	str	r3, [r4, #0]
}
    6a92:	bd10      	pop	{r4, pc}
    6a94:	20005325 	.word	0x20005325
    6a98:	20000f54 	.word	0x20000f54

00006a9c <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
    6a9c:	b570      	push	{r4, r5, r6, lr}
    6a9e:	4604      	mov	r4, r0
    6aa0:	460d      	mov	r5, r1
	__asm__ volatile(
    6aa2:	f04f 0320 	mov.w	r3, #32
    6aa6:	f3ef 8611 	mrs	r6, BASEPRI
    6aaa:	f383 8811 	msr	BASEPRI, r3
    6aae:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
    6ab2:	f004 f995 	bl	ade0 <z_unpend_first_thread>

	if (pending_thread != NULL) {
    6ab6:	b180      	cbz	r0, 6ada <k_mem_slab_free+0x3e>
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
    6ab8:	682a      	ldr	r2, [r5, #0]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
    6aba:	6142      	str	r2, [r0, #20]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    6abc:	7b42      	ldrb	r2, [r0, #13]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
    6abe:	2100      	movs	r1, #0
    6ac0:	06d2      	lsls	r2, r2, #27
    6ac2:	6681      	str	r1, [r0, #104]	; 0x68
    6ac4:	d103      	bne.n	6ace <k_mem_slab_free+0x32>
	if (z_is_thread_ready(thread)) {
    6ac6:	6983      	ldr	r3, [r0, #24]
    6ac8:	b90b      	cbnz	r3, 6ace <k_mem_slab_free+0x32>
		z_add_thread_to_ready_q(thread);
    6aca:	f000 f947 	bl	6d5c <z_add_thread_to_ready_q>
		z_ready_thread(pending_thread);
		z_reschedule(&lock, key);
    6ace:	4631      	mov	r1, r6
    6ad0:	4808      	ldr	r0, [pc, #32]	; (6af4 <k_mem_slab_free+0x58>)
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
    6ad2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
    6ad6:	f004 b90d 	b.w	acf4 <z_reschedule>
		**(char ***)mem = slab->free_list;
    6ada:	682b      	ldr	r3, [r5, #0]
    6adc:	6962      	ldr	r2, [r4, #20]
    6ade:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
    6ae0:	682b      	ldr	r3, [r5, #0]
    6ae2:	6163      	str	r3, [r4, #20]
		slab->num_used--;
    6ae4:	69a3      	ldr	r3, [r4, #24]
    6ae6:	3b01      	subs	r3, #1
    6ae8:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
    6aea:	f386 8811 	msr	BASEPRI, r6
    6aee:	f3bf 8f6f 	isb	sy
}
    6af2:	bd70      	pop	{r4, r5, r6, pc}
    6af4:	20005325 	.word	0x20005325

00006af8 <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
    6af8:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);

	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
    6afa:	4c07      	ldr	r4, [pc, #28]	; (6b18 <init_static_pools+0x20>)
    6afc:	4d07      	ldr	r5, [pc, #28]	; (6b1c <init_static_pools+0x24>)
    6afe:	42ac      	cmp	r4, r5
    6b00:	d301      	bcc.n	6b06 <init_static_pools+0xe>
		k_mem_pool_init(p);
	}

	return 0;
}
    6b02:	2000      	movs	r0, #0
    6b04:	bd38      	pop	{r3, r4, r5, pc}
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    6b06:	f104 0314 	add.w	r3, r4, #20
	z_sys_mem_pool_base_init(&p->base);
    6b0a:	4620      	mov	r0, r4
    6b0c:	e9c4 3305 	strd	r3, r3, [r4, #20]
    6b10:	f000 fe3e 	bl	7790 <z_sys_mem_pool_base_init>
	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
    6b14:	341c      	adds	r4, #28
    6b16:	e7f2      	b.n	6afe <init_static_pools+0x6>
    6b18:	200069d0 	.word	0x200069d0
    6b1c:	200069ec 	.word	0x200069ec

00006b20 <k_mem_pool_alloc>:

SYS_INIT(init_static_pools, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, s32_t timeout)
{
    6b20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int ret;
	s64_t end = 0;

	__ASSERT(!(arch_is_in_isr() && timeout != K_NO_WAIT), "");

	if (timeout > 0) {
    6b24:	1e1c      	subs	r4, r3, #0
{
    6b26:	b085      	sub	sp, #20
    6b28:	4607      	mov	r7, r0
    6b2a:	460d      	mov	r5, r1
    6b2c:	4692      	mov	sl, r2
	if (timeout > 0) {
    6b2e:	dd3b      	ble.n	6ba8 <k_mem_pool_alloc+0x88>
	return z_impl_k_uptime_get();
    6b30:	f004 f9f3 	bl	af1a <z_impl_k_uptime_get>
		end = k_uptime_get() + timeout;
    6b34:	eb10 0804 	adds.w	r8, r0, r4
	return pool - &_k_mem_pool_list_start[0];
    6b38:	4b1d      	ldr	r3, [pc, #116]	; (6bb0 <k_mem_pool_alloc+0x90>)
    6b3a:	4e1e      	ldr	r6, [pc, #120]	; (6bb4 <k_mem_pool_alloc+0x94>)
    6b3c:	1afb      	subs	r3, r7, r3
    6b3e:	109b      	asrs	r3, r3, #2
    6b40:	435e      	muls	r6, r3
		u32_t level_num, block_num;

		ret = z_sys_mem_pool_block_alloc(&p->base, size,
						 &level_num, &block_num,
						 &block->data);
		block->id.pool = pool_id(p);
    6b42:	b2f6      	uxtb	r6, r6
		if (ret == 0 || timeout == K_NO_WAIT ||
		    ret != -ENOMEM) {
			return ret;
		}

		z_pend_curr_unlocked(&p->wait_q, timeout);
    6b44:	f107 0b14 	add.w	fp, r7, #20
		ret = z_sys_mem_pool_block_alloc(&p->base, size,
    6b48:	ab03      	add	r3, sp, #12
    6b4a:	aa02      	add	r2, sp, #8
    6b4c:	9500      	str	r5, [sp, #0]
    6b4e:	4651      	mov	r1, sl
    6b50:	4638      	mov	r0, r7
    6b52:	f000 fe63 	bl	781c <z_sys_mem_pool_block_alloc>
		block->id.level = level_num;
    6b56:	796b      	ldrb	r3, [r5, #5]
    6b58:	9a02      	ldr	r2, [sp, #8]
		block->id.pool = pool_id(p);
    6b5a:	712e      	strb	r6, [r5, #4]
		block->id.level = level_num;
    6b5c:	f362 0303 	bfi	r3, r2, #0, #4
    6b60:	716b      	strb	r3, [r5, #5]
		block->id.block = block_num;
    6b62:	686b      	ldr	r3, [r5, #4]
    6b64:	9a03      	ldr	r2, [sp, #12]
    6b66:	f362 331f 	bfi	r3, r2, #12, #20
    6b6a:	606b      	str	r3, [r5, #4]
		if (ret == 0 || timeout == K_NO_WAIT ||
    6b6c:	b1c8      	cbz	r0, 6ba2 <k_mem_pool_alloc+0x82>
    6b6e:	b1c4      	cbz	r4, 6ba2 <k_mem_pool_alloc+0x82>
    6b70:	f110 0f0c 	cmn.w	r0, #12
    6b74:	d115      	bne.n	6ba2 <k_mem_pool_alloc+0x82>
	__asm__ volatile(
    6b76:	f04f 0320 	mov.w	r3, #32
    6b7a:	f3ef 8011 	mrs	r0, BASEPRI
    6b7e:	f383 8811 	msr	BASEPRI, r3
    6b82:	f3bf 8f6f 	isb	sy
	(void) z_pend_curr_irqlock(arch_irq_lock(), wait_q, timeout);
    6b86:	4622      	mov	r2, r4
    6b88:	4659      	mov	r1, fp
    6b8a:	f000 fa75 	bl	7078 <z_pend_curr_irqlock>

		if (timeout != K_FOREVER) {
    6b8e:	1c63      	adds	r3, r4, #1
    6b90:	d0da      	beq.n	6b48 <k_mem_pool_alloc+0x28>
    6b92:	f004 f9c2 	bl	af1a <z_impl_k_uptime_get>
			timeout = end - k_uptime_get();
    6b96:	eba8 0400 	sub.w	r4, r8, r0
			if (timeout <= 0) {
    6b9a:	2c00      	cmp	r4, #0
    6b9c:	dcd4      	bgt.n	6b48 <k_mem_pool_alloc+0x28>
				break;
			}
		}
	}

	return -EAGAIN;
    6b9e:	f06f 000a 	mvn.w	r0, #10
}
    6ba2:	b005      	add	sp, #20
    6ba4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	s64_t end = 0;
    6ba8:	f04f 0800 	mov.w	r8, #0
    6bac:	e7c4      	b.n	6b38 <k_mem_pool_alloc+0x18>
    6bae:	bf00      	nop
    6bb0:	200069d0 	.word	0x200069d0
    6bb4:	b6db6db7 	.word	0xb6db6db7

00006bb8 <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
    6bb8:	b570      	push	{r4, r5, r6, lr}
    6bba:	7804      	ldrb	r4, [r0, #0]
	int need_sched = 0;
	struct k_mem_pool *p = get_pool(id->pool);

	z_sys_mem_pool_block_free(&p->base, id->level, id->block);
    6bbc:	6802      	ldr	r2, [r0, #0]
    6bbe:	7841      	ldrb	r1, [r0, #1]
    6bc0:	4e11      	ldr	r6, [pc, #68]	; (6c08 <k_mem_pool_free_id+0x50>)
    6bc2:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
    6bc6:	00a4      	lsls	r4, r4, #2
    6bc8:	0b12      	lsrs	r2, r2, #12
    6bca:	f001 010f 	and.w	r1, r1, #15
    6bce:	1930      	adds	r0, r6, r4
    6bd0:	f000 fed7 	bl	7982 <z_sys_mem_pool_block_free>
    6bd4:	f04f 0320 	mov.w	r3, #32
    6bd8:	f3ef 8511 	mrs	r5, BASEPRI
    6bdc:	f383 8811 	msr	BASEPRI, r3
    6be0:	f3bf 8f6f 	isb	sy
	 * is unsynchronized.  Maybe we want to put the lock into the
	 * wait_q instead and make the API safe?)
	 */
	k_spinlock_key_t key = k_spin_lock(&lock);

	need_sched = z_unpend_all(&p->wait_q);
    6be4:	f104 0014 	add.w	r0, r4, #20
    6be8:	4430      	add	r0, r6
    6bea:	f004 f926 	bl	ae3a <z_unpend_all>

	if (need_sched != 0) {
    6bee:	b128      	cbz	r0, 6bfc <k_mem_pool_free_id+0x44>
		z_reschedule(&lock, key);
    6bf0:	4629      	mov	r1, r5
    6bf2:	4806      	ldr	r0, [pc, #24]	; (6c0c <k_mem_pool_free_id+0x54>)
	} else {
		k_spin_unlock(&lock, key);
	}
}
    6bf4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
    6bf8:	f004 b87c 	b.w	acf4 <z_reschedule>
	__asm__ volatile(
    6bfc:	f385 8811 	msr	BASEPRI, r5
    6c00:	f3bf 8f6f 	isb	sy
}
    6c04:	bd70      	pop	{r4, r5, r6, pc}
    6c06:	bf00      	nop
    6c08:	200069d0 	.word	0x200069d0
    6c0c:	20005325 	.word	0x20005325

00006c10 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
    6c10:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
    6c12:	4c08      	ldr	r4, [pc, #32]	; (6c34 <z_reset_time_slice+0x24>)
    6c14:	6823      	ldr	r3, [r4, #0]
    6c16:	b15b      	cbz	r3, 6c30 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
    6c18:	f7fa fa32 	bl	1080 <z_clock_elapsed>
    6c1c:	6823      	ldr	r3, [r4, #0]
    6c1e:	4a06      	ldr	r2, [pc, #24]	; (6c38 <z_reset_time_slice+0x28>)
    6c20:	4418      	add	r0, r3
    6c22:	6110      	str	r0, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
    6c24:	2100      	movs	r1, #0
    6c26:	4618      	mov	r0, r3
	}
}
    6c28:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_set_timeout_expiry(slice_time, false);
    6c2c:	f004 b957 	b.w	aede <z_set_timeout_expiry>
}
    6c30:	bd10      	pop	{r4, pc}
    6c32:	bf00      	nop
    6c34:	20000f8c 	.word	0x20000f8c
    6c38:	20000f54 	.word	0x20000f54

00006c3c <k_sched_time_slice_set>:

void k_sched_time_slice_set(s32_t slice, int prio)
{
    6c3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6c3e:	460d      	mov	r5, r1
	__asm__ volatile(
    6c40:	f04f 0320 	mov.w	r3, #32
    6c44:	f3ef 8411 	mrs	r4, BASEPRI
    6c48:	f383 8811 	msr	BASEPRI, r3
    6c4c:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
    6c50:	4b0d      	ldr	r3, [pc, #52]	; (6c88 <k_sched_time_slice_set+0x4c>)
		} else {
			return t * (to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
    6c52:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    6c56:	f240 36e7 	movw	r6, #999	; 0x3e7
    6c5a:	2700      	movs	r7, #0
    6c5c:	fbe1 6700 	umlal	r6, r7, r1, r0
    6c60:	2200      	movs	r2, #0
    6c62:	611a      	str	r2, [r3, #16]
    6c64:	4630      	mov	r0, r6
    6c66:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    6c6a:	2300      	movs	r3, #0
    6c6c:	4639      	mov	r1, r7
    6c6e:	f7f9 fa35 	bl	dc <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
    6c72:	4b06      	ldr	r3, [pc, #24]	; (6c8c <k_sched_time_slice_set+0x50>)
    6c74:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
    6c76:	4b06      	ldr	r3, [pc, #24]	; (6c90 <k_sched_time_slice_set+0x54>)
    6c78:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
    6c7a:	f7ff ffc9 	bl	6c10 <z_reset_time_slice>
	__asm__ volatile(
    6c7e:	f384 8811 	msr	BASEPRI, r4
    6c82:	f3bf 8f6f 	isb	sy
	}
}
    6c86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6c88:	20000f54 	.word	0x20000f54
    6c8c:	20000f8c 	.word	0x20000f8c
    6c90:	20000f88 	.word	0x20000f88

00006c94 <k_sched_lock>:
	__asm__ volatile(
    6c94:	f04f 0320 	mov.w	r3, #32
    6c98:	f3ef 8111 	mrs	r1, BASEPRI
    6c9c:	f383 8811 	msr	BASEPRI, r3
    6ca0:	f3bf 8f6f 	isb	sy
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
    6ca4:	4b04      	ldr	r3, [pc, #16]	; (6cb8 <k_sched_lock+0x24>)
    6ca6:	689a      	ldr	r2, [r3, #8]
    6ca8:	7bd3      	ldrb	r3, [r2, #15]
    6caa:	3b01      	subs	r3, #1
    6cac:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
    6cae:	f381 8811 	msr	BASEPRI, r1
    6cb2:	f3bf 8f6f 	isb	sy
void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
    6cb6:	4770      	bx	lr
    6cb8:	20000f54 	.word	0x20000f54

00006cbc <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
    6cbc:	4b09      	ldr	r3, [pc, #36]	; (6ce4 <z_priq_dumb_remove+0x28>)
    6cbe:	f103 0228 	add.w	r2, r3, #40	; 0x28
    6cc2:	4282      	cmp	r2, r0
    6cc4:	d105      	bne.n	6cd2 <z_priq_dumb_remove+0x16>
    6cc6:	689b      	ldr	r3, [r3, #8]
    6cc8:	428b      	cmp	r3, r1
    6cca:	d102      	bne.n	6cd2 <z_priq_dumb_remove+0x16>
    6ccc:	7b4b      	ldrb	r3, [r1, #13]
    6cce:	06db      	lsls	r3, r3, #27
    6cd0:	d106      	bne.n	6ce0 <z_priq_dumb_remove+0x24>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
    6cd2:	e9d1 3200 	ldrd	r3, r2, [r1]
    6cd6:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
    6cd8:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    6cda:	2300      	movs	r3, #0
	node->prev = NULL;
    6cdc:	e9c1 3300 	strd	r3, r3, [r1]
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
    6ce0:	4770      	bx	lr
    6ce2:	bf00      	nop
    6ce4:	20000f54 	.word	0x20000f54

00006ce8 <update_cache>:
{
    6ce8:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
    6cea:	4c0d      	ldr	r4, [pc, #52]	; (6d20 <update_cache+0x38>)
{
    6cec:	4602      	mov	r2, r0
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
    6cee:	f104 0028 	add.w	r0, r4, #40	; 0x28
    6cf2:	f004 f83e 	bl	ad72 <z_priq_dumb_best>
	return thread ? thread : _current_cpu->idle_thread;
    6cf6:	4605      	mov	r5, r0
    6cf8:	b900      	cbnz	r0, 6cfc <update_cache+0x14>
    6cfa:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
    6cfc:	68a3      	ldr	r3, [r4, #8]
    6cfe:	b94a      	cbnz	r2, 6d14 <update_cache+0x2c>
	if (z_is_thread_prevented_from_running(_current)) {
    6d00:	7b5a      	ldrb	r2, [r3, #13]
    6d02:	06d2      	lsls	r2, r2, #27
    6d04:	d106      	bne.n	6d14 <update_cache+0x2c>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    6d06:	69aa      	ldr	r2, [r5, #24]
    6d08:	b922      	cbnz	r2, 6d14 <update_cache+0x2c>
	if (is_preempt(_current) || is_metairq(thread)) {
    6d0a:	89da      	ldrh	r2, [r3, #14]
    6d0c:	2a7f      	cmp	r2, #127	; 0x7f
    6d0e:	d901      	bls.n	6d14 <update_cache+0x2c>
		_kernel.ready_q.cache = _current;
    6d10:	6263      	str	r3, [r4, #36]	; 0x24
}
    6d12:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
    6d14:	429d      	cmp	r5, r3
    6d16:	d001      	beq.n	6d1c <update_cache+0x34>
			z_reset_time_slice();
    6d18:	f7ff ff7a 	bl	6c10 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    6d1c:	6265      	str	r5, [r4, #36]	; 0x24
}
    6d1e:	e7f8      	b.n	6d12 <update_cache+0x2a>
    6d20:	20000f54 	.word	0x20000f54

00006d24 <k_sched_unlock>:
{
    6d24:	b510      	push	{r4, lr}
	__asm__ volatile(
    6d26:	f04f 0320 	mov.w	r3, #32
    6d2a:	f3ef 8411 	mrs	r4, BASEPRI
    6d2e:	f383 8811 	msr	BASEPRI, r3
    6d32:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
    6d36:	4b08      	ldr	r3, [pc, #32]	; (6d58 <k_sched_unlock+0x34>)
    6d38:	689a      	ldr	r2, [r3, #8]
    6d3a:	7bd3      	ldrb	r3, [r2, #15]
    6d3c:	3301      	adds	r3, #1
    6d3e:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
    6d40:	2000      	movs	r0, #0
    6d42:	f7ff ffd1 	bl	6ce8 <update_cache>
	__asm__ volatile(
    6d46:	f384 8811 	msr	BASEPRI, r4
    6d4a:	f3bf 8f6f 	isb	sy
}
    6d4e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
    6d52:	f003 bfe6 	b.w	ad22 <z_reschedule_unlocked>
    6d56:	bf00      	nop
    6d58:	20000f54 	.word	0x20000f54

00006d5c <z_add_thread_to_ready_q>:
{
    6d5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
    6d5e:	f04f 0320 	mov.w	r3, #32
    6d62:	f3ef 8411 	mrs	r4, BASEPRI
    6d66:	f383 8811 	msr	BASEPRI, r3
    6d6a:	f3bf 8f6f 	isb	sy
	return list->head == list;
    6d6e:	4a15      	ldr	r2, [pc, #84]	; (6dc4 <z_add_thread_to_ready_q+0x68>)
    6d70:	4611      	mov	r1, r2
    6d72:	f851 3f28 	ldr.w	r3, [r1, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    6d76:	428b      	cmp	r3, r1
    6d78:	d01d      	beq.n	6db6 <z_add_thread_to_ready_q+0x5a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    6d7a:	b1e3      	cbz	r3, 6db6 <z_add_thread_to_ready_q+0x5a>
    6d7c:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
	if (thread_1->base.prio < thread_2->base.prio) {
    6d7e:	f990 500e 	ldrsb.w	r5, [r0, #14]
    6d82:	f993 700e 	ldrsb.w	r7, [r3, #14]
    6d86:	42af      	cmp	r7, r5
    6d88:	dd10      	ble.n	6dac <z_add_thread_to_ready_q+0x50>
	node->prev = successor->prev;
    6d8a:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    6d8c:	e9c0 3200 	strd	r3, r2, [r0]
	successor->prev->next = node;
    6d90:	6010      	str	r0, [r2, #0]
	successor->prev = node;
    6d92:	6058      	str	r0, [r3, #4]
	thread->base.thread_state |= states;
    6d94:	7b43      	ldrb	r3, [r0, #13]
    6d96:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    6d9a:	7343      	strb	r3, [r0, #13]
		update_cache(0);
    6d9c:	2000      	movs	r0, #0
    6d9e:	f7ff ffa3 	bl	6ce8 <update_cache>
	__asm__ volatile(
    6da2:	f384 8811 	msr	BASEPRI, r4
    6da6:	f3bf 8f6f 	isb	sy
}
    6daa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
    6dac:	42b3      	cmp	r3, r6
    6dae:	d002      	beq.n	6db6 <z_add_thread_to_ready_q+0x5a>
    6db0:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    6db2:	2b00      	cmp	r3, #0
    6db4:	d1e5      	bne.n	6d82 <z_add_thread_to_ready_q+0x26>
	node->prev = list->tail;
    6db6:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    6db8:	6043      	str	r3, [r0, #4]
	list->tail->next = node;
    6dba:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	node->next = list;
    6dbc:	6001      	str	r1, [r0, #0]
	list->tail->next = node;
    6dbe:	6018      	str	r0, [r3, #0]
	list->tail = node;
    6dc0:	62d0      	str	r0, [r2, #44]	; 0x2c
    6dc2:	e7e7      	b.n	6d94 <z_add_thread_to_ready_q+0x38>
    6dc4:	20000f54 	.word	0x20000f54

00006dc8 <z_move_thread_to_end_of_prio_q>:
{
    6dc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6dca:	4604      	mov	r4, r0
	__asm__ volatile(
    6dcc:	f04f 0320 	mov.w	r3, #32
    6dd0:	f3ef 8511 	mrs	r5, BASEPRI
    6dd4:	f383 8811 	msr	BASEPRI, r3
    6dd8:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
    6ddc:	7b43      	ldrb	r3, [r0, #13]
    6dde:	065a      	lsls	r2, r3, #25
    6de0:	d503      	bpl.n	6dea <z_move_thread_to_end_of_prio_q+0x22>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    6de2:	4601      	mov	r1, r0
    6de4:	4817      	ldr	r0, [pc, #92]	; (6e44 <z_move_thread_to_end_of_prio_q+0x7c>)
    6de6:	f7ff ff69 	bl	6cbc <z_priq_dumb_remove>
	return list->head == list;
    6dea:	4a17      	ldr	r2, [pc, #92]	; (6e48 <z_move_thread_to_end_of_prio_q+0x80>)
    6dec:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
    6df0:	f102 0128 	add.w	r1, r2, #40	; 0x28
    6df4:	428b      	cmp	r3, r1
    6df6:	d01f      	beq.n	6e38 <z_move_thread_to_end_of_prio_q+0x70>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    6df8:	b1f3      	cbz	r3, 6e38 <z_move_thread_to_end_of_prio_q+0x70>
	if (thread_1->base.prio < thread_2->base.prio) {
    6dfa:	f994 600e 	ldrsb.w	r6, [r4, #14]
    6dfe:	f993 700e 	ldrsb.w	r7, [r3, #14]
    6e02:	42b7      	cmp	r7, r6
    6e04:	dd13      	ble.n	6e2e <z_move_thread_to_end_of_prio_q+0x66>
	node->prev = successor->prev;
    6e06:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
    6e08:	e9c4 3100 	strd	r3, r1, [r4]
	successor->prev->next = node;
    6e0c:	600c      	str	r4, [r1, #0]
	successor->prev = node;
    6e0e:	605c      	str	r4, [r3, #4]
    6e10:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
    6e12:	6890      	ldr	r0, [r2, #8]
    6e14:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    6e18:	7363      	strb	r3, [r4, #13]
    6e1a:	1b03      	subs	r3, r0, r4
    6e1c:	4258      	negs	r0, r3
    6e1e:	4158      	adcs	r0, r3
    6e20:	f7ff ff62 	bl	6ce8 <update_cache>
	__asm__ volatile(
    6e24:	f385 8811 	msr	BASEPRI, r5
    6e28:	f3bf 8f6f 	isb	sy
}
    6e2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
    6e2e:	4283      	cmp	r3, r0
    6e30:	d002      	beq.n	6e38 <z_move_thread_to_end_of_prio_q+0x70>
    6e32:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    6e34:	2b00      	cmp	r3, #0
    6e36:	d1e2      	bne.n	6dfe <z_move_thread_to_end_of_prio_q+0x36>
	node->prev = list->tail;
    6e38:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
    6e3c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    6e3e:	601c      	str	r4, [r3, #0]
	list->tail = node;
    6e40:	62d4      	str	r4, [r2, #44]	; 0x2c
    6e42:	e7e5      	b.n	6e10 <z_move_thread_to_end_of_prio_q+0x48>
    6e44:	20000f7c 	.word	0x20000f7c
    6e48:	20000f54 	.word	0x20000f54

00006e4c <z_time_slice>:
	if (pending_current == _current) {
    6e4c:	4a15      	ldr	r2, [pc, #84]	; (6ea4 <z_time_slice+0x58>)
    6e4e:	4916      	ldr	r1, [pc, #88]	; (6ea8 <z_time_slice+0x5c>)
{
    6e50:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
    6e52:	680c      	ldr	r4, [r1, #0]
    6e54:	6893      	ldr	r3, [r2, #8]
    6e56:	42a3      	cmp	r3, r4
    6e58:	4614      	mov	r4, r2
    6e5a:	d103      	bne.n	6e64 <z_time_slice+0x18>
}
    6e5c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
    6e60:	f7ff bed6 	b.w	6c10 <z_reset_time_slice>
	pending_current = NULL;
    6e64:	2500      	movs	r5, #0
    6e66:	600d      	str	r5, [r1, #0]
	if (slice_time && sliceable(_current)) {
    6e68:	4910      	ldr	r1, [pc, #64]	; (6eac <z_time_slice+0x60>)
    6e6a:	6809      	ldr	r1, [r1, #0]
    6e6c:	b1b9      	cbz	r1, 6e9e <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
    6e6e:	89d9      	ldrh	r1, [r3, #14]
    6e70:	297f      	cmp	r1, #127	; 0x7f
    6e72:	d814      	bhi.n	6e9e <z_time_slice+0x52>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    6e74:	490e      	ldr	r1, [pc, #56]	; (6eb0 <z_time_slice+0x64>)
    6e76:	f993 500e 	ldrsb.w	r5, [r3, #14]
    6e7a:	6809      	ldr	r1, [r1, #0]
    6e7c:	428d      	cmp	r5, r1
    6e7e:	db0e      	blt.n	6e9e <z_time_slice+0x52>
		&& !z_is_idle_thread_object(thread)
    6e80:	490c      	ldr	r1, [pc, #48]	; (6eb4 <z_time_slice+0x68>)
    6e82:	428b      	cmp	r3, r1
    6e84:	d00b      	beq.n	6e9e <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
    6e86:	6999      	ldr	r1, [r3, #24]
    6e88:	b949      	cbnz	r1, 6e9e <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
    6e8a:	6911      	ldr	r1, [r2, #16]
    6e8c:	4281      	cmp	r1, r0
    6e8e:	dc03      	bgt.n	6e98 <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
    6e90:	4618      	mov	r0, r3
    6e92:	f7ff ff99 	bl	6dc8 <z_move_thread_to_end_of_prio_q>
    6e96:	e7e1      	b.n	6e5c <z_time_slice+0x10>
			_current_cpu->slice_ticks -= ticks;
    6e98:	1a09      	subs	r1, r1, r0
    6e9a:	6111      	str	r1, [r2, #16]
}
    6e9c:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
    6e9e:	2300      	movs	r3, #0
    6ea0:	6123      	str	r3, [r4, #16]
    6ea2:	e7fb      	b.n	6e9c <z_time_slice+0x50>
    6ea4:	20000f54 	.word	0x20000f54
    6ea8:	20000f84 	.word	0x20000f84
    6eac:	20000f8c 	.word	0x20000f8c
    6eb0:	20000f88 	.word	0x20000f88
    6eb4:	20000e7c 	.word	0x20000e7c

00006eb8 <z_thread_single_suspend>:
{
    6eb8:	b570      	push	{r4, r5, r6, lr}
    6eba:	4604      	mov	r4, r0
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    6ebc:	3018      	adds	r0, #24
    6ebe:	f003 ffe8 	bl	ae92 <z_abort_timeout>
	__asm__ volatile(
    6ec2:	f04f 0320 	mov.w	r3, #32
    6ec6:	f3ef 8611 	mrs	r6, BASEPRI
    6eca:	f383 8811 	msr	BASEPRI, r3
    6ece:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
    6ed2:	7b63      	ldrb	r3, [r4, #13]
    6ed4:	065a      	lsls	r2, r3, #25
    6ed6:	d507      	bpl.n	6ee8 <z_thread_single_suspend+0x30>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    6ed8:	4621      	mov	r1, r4
    6eda:	480f      	ldr	r0, [pc, #60]	; (6f18 <z_thread_single_suspend+0x60>)
    6edc:	f7ff feee 	bl	6cbc <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    6ee0:	7b63      	ldrb	r3, [r4, #13]
    6ee2:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    6ee6:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
    6ee8:	4d0c      	ldr	r5, [pc, #48]	; (6f1c <z_thread_single_suspend+0x64>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
    6eea:	7b63      	ldrb	r3, [r4, #13]
    6eec:	68a8      	ldr	r0, [r5, #8]
    6eee:	f043 0310 	orr.w	r3, r3, #16
    6ef2:	7363      	strb	r3, [r4, #13]
    6ef4:	1b03      	subs	r3, r0, r4
    6ef6:	4258      	negs	r0, r3
    6ef8:	4158      	adcs	r0, r3
    6efa:	f7ff fef5 	bl	6ce8 <update_cache>
	__asm__ volatile(
    6efe:	f386 8811 	msr	BASEPRI, r6
    6f02:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
    6f06:	68ab      	ldr	r3, [r5, #8]
    6f08:	42a3      	cmp	r3, r4
    6f0a:	d103      	bne.n	6f14 <z_thread_single_suspend+0x5c>
}
    6f0c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
    6f10:	f003 bf07 	b.w	ad22 <z_reschedule_unlocked>
}
    6f14:	bd70      	pop	{r4, r5, r6, pc}
    6f16:	bf00      	nop
    6f18:	20000f7c 	.word	0x20000f7c
    6f1c:	20000f54 	.word	0x20000f54

00006f20 <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
    6f20:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
    6f22:	b570      	push	{r4, r5, r6, lr}
    6f24:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
    6f26:	b103      	cbz	r3, 6f2a <z_thread_single_abort+0xa>
		thread->fn_abort();
    6f28:	4798      	blx	r3
    6f2a:	f104 0018 	add.w	r0, r4, #24
    6f2e:	f003 ffb0 	bl	ae92 <z_abort_timeout>
	__asm__ volatile(
    6f32:	f04f 0320 	mov.w	r3, #32
    6f36:	f3ef 8511 	mrs	r5, BASEPRI
    6f3a:	f383 8811 	msr	BASEPRI, r3
    6f3e:	f3bf 8f6f 	isb	sy
		if (z_is_thread_ready(thread)) {
    6f42:	4620      	mov	r0, r4
    6f44:	f003 fea4 	bl	ac90 <z_is_thread_ready>
    6f48:	7b63      	ldrb	r3, [r4, #13]
    6f4a:	4606      	mov	r6, r0
    6f4c:	b1c8      	cbz	r0, 6f82 <z_thread_single_abort+0x62>
			if (z_is_thread_queued(thread)) {
    6f4e:	0659      	lsls	r1, r3, #25
    6f50:	d507      	bpl.n	6f62 <z_thread_single_abort+0x42>
				_priq_run_remove(&_kernel.ready_q.runq,
    6f52:	4621      	mov	r1, r4
    6f54:	4811      	ldr	r0, [pc, #68]	; (6f9c <z_thread_single_abort+0x7c>)
    6f56:	f7ff feb1 	bl	6cbc <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    6f5a:	7b63      	ldrb	r3, [r4, #13]
    6f5c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    6f60:	7363      	strb	r3, [r4, #13]
			update_cache(thread == _current);
    6f62:	4b0f      	ldr	r3, [pc, #60]	; (6fa0 <z_thread_single_abort+0x80>)
    6f64:	6898      	ldr	r0, [r3, #8]
    6f66:	1b02      	subs	r2, r0, r4
    6f68:	4250      	negs	r0, r2
    6f6a:	4150      	adcs	r0, r2
    6f6c:	f7ff febc 	bl	6ce8 <update_cache>
		thread->base.thread_state |= _THREAD_DEAD;
    6f70:	7b63      	ldrb	r3, [r4, #13]
    6f72:	f043 0308 	orr.w	r3, r3, #8
    6f76:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
    6f78:	f385 8811 	msr	BASEPRI, r5
    6f7c:	f3bf 8f6f 	isb	sy
}
    6f80:	bd70      	pop	{r4, r5, r6, pc}
			if (z_is_thread_pending(thread)) {
    6f82:	079b      	lsls	r3, r3, #30
    6f84:	d5f4      	bpl.n	6f70 <z_thread_single_abort+0x50>
				_priq_wait_remove(&pended_on(thread)->waitq,
    6f86:	4621      	mov	r1, r4
    6f88:	68a0      	ldr	r0, [r4, #8]
    6f8a:	f7ff fe97 	bl	6cbc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    6f8e:	7b63      	ldrb	r3, [r4, #13]
				thread->base.pended_on = NULL;
    6f90:	60a6      	str	r6, [r4, #8]
    6f92:	f023 0302 	bic.w	r3, r3, #2
    6f96:	7363      	strb	r3, [r4, #13]
    6f98:	e7ea      	b.n	6f70 <z_thread_single_abort+0x50>
    6f9a:	bf00      	nop
    6f9c:	20000f7c 	.word	0x20000f7c
    6fa0:	20000f54 	.word	0x20000f54

00006fa4 <z_remove_thread_from_ready_q>:
{
    6fa4:	b538      	push	{r3, r4, r5, lr}
    6fa6:	4604      	mov	r4, r0
	__asm__ volatile(
    6fa8:	f04f 0320 	mov.w	r3, #32
    6fac:	f3ef 8511 	mrs	r5, BASEPRI
    6fb0:	f383 8811 	msr	BASEPRI, r3
    6fb4:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
    6fb8:	7b43      	ldrb	r3, [r0, #13]
    6fba:	065a      	lsls	r2, r3, #25
    6fbc:	d507      	bpl.n	6fce <z_remove_thread_from_ready_q+0x2a>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    6fbe:	4601      	mov	r1, r0
    6fc0:	4809      	ldr	r0, [pc, #36]	; (6fe8 <z_remove_thread_from_ready_q+0x44>)
    6fc2:	f7ff fe7b 	bl	6cbc <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    6fc6:	7b63      	ldrb	r3, [r4, #13]
    6fc8:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    6fcc:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
    6fce:	4b07      	ldr	r3, [pc, #28]	; (6fec <z_remove_thread_from_ready_q+0x48>)
    6fd0:	6898      	ldr	r0, [r3, #8]
    6fd2:	1b03      	subs	r3, r0, r4
    6fd4:	4258      	negs	r0, r3
    6fd6:	4158      	adcs	r0, r3
    6fd8:	f7ff fe86 	bl	6ce8 <update_cache>
	__asm__ volatile(
    6fdc:	f385 8811 	msr	BASEPRI, r5
    6fe0:	f3bf 8f6f 	isb	sy
}
    6fe4:	bd38      	pop	{r3, r4, r5, pc}
    6fe6:	bf00      	nop
    6fe8:	20000f7c 	.word	0x20000f7c
    6fec:	20000f54 	.word	0x20000f54

00006ff0 <pend>:
{
    6ff0:	b570      	push	{r4, r5, r6, lr}
    6ff2:	4604      	mov	r4, r0
    6ff4:	460d      	mov	r5, r1
    6ff6:	4616      	mov	r6, r2
	z_remove_thread_from_ready_q(thread);
    6ff8:	f7ff ffd4 	bl	6fa4 <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_PENDING;
    6ffc:	7b63      	ldrb	r3, [r4, #13]
    6ffe:	f043 0302 	orr.w	r3, r3, #2
    7002:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
    7004:	b17d      	cbz	r5, 7026 <pend+0x36>
	return list->head == list;
    7006:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
    7008:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    700a:	429d      	cmp	r5, r3
    700c:	d029      	beq.n	7062 <pend+0x72>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    700e:	b343      	cbz	r3, 7062 <pend+0x72>
	if (thread_1->base.prio < thread_2->base.prio) {
    7010:	f994 200e 	ldrsb.w	r2, [r4, #14]
    7014:	f993 100e 	ldrsb.w	r1, [r3, #14]
    7018:	4291      	cmp	r1, r2
    701a:	dd1c      	ble.n	7056 <pend+0x66>
	node->prev = successor->prev;
    701c:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    701e:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
    7022:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    7024:	605c      	str	r4, [r3, #4]
	if (timeout != K_FOREVER) {
    7026:	1c73      	adds	r3, r6, #1
    7028:	d022      	beq.n	7070 <pend+0x80>
    702a:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
    702e:	f44f 4500 	mov.w	r5, #32768	; 0x8000
    7032:	f240 30e7 	movw	r0, #999	; 0x3e7
    7036:	2100      	movs	r1, #0
    7038:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    703c:	fbc5 0106 	smlal	r0, r1, r5, r6
    7040:	2300      	movs	r3, #0
    7042:	f7f9 f84b 	bl	dc <__aeabi_uldivmod>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
    7046:	490b      	ldr	r1, [pc, #44]	; (7074 <pend+0x84>)
    7048:	1c42      	adds	r2, r0, #1
    704a:	f104 0018 	add.w	r0, r4, #24
}
    704e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    7052:	f000 ba67 	b.w	7524 <z_add_timeout>
	return (node == list->tail) ? NULL : node->next;
    7056:	6869      	ldr	r1, [r5, #4]
    7058:	428b      	cmp	r3, r1
    705a:	d002      	beq.n	7062 <pend+0x72>
    705c:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    705e:	2b00      	cmp	r3, #0
    7060:	d1d8      	bne.n	7014 <pend+0x24>
	node->prev = list->tail;
    7062:	686b      	ldr	r3, [r5, #4]
    7064:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
    7066:	686b      	ldr	r3, [r5, #4]
	node->next = list;
    7068:	6025      	str	r5, [r4, #0]
	list->tail->next = node;
    706a:	601c      	str	r4, [r3, #0]
	list->tail = node;
    706c:	606c      	str	r4, [r5, #4]
    706e:	e7da      	b.n	7026 <pend+0x36>
}
    7070:	bd70      	pop	{r4, r5, r6, pc}
    7072:	bf00      	nop
    7074:	0000ad7f 	.word	0x0000ad7f

00007078 <z_pend_curr_irqlock>:
{
    7078:	b570      	push	{r4, r5, r6, lr}
	pend(_current, wait_q, timeout);
    707a:	4d0f      	ldr	r5, [pc, #60]	; (70b8 <z_pend_curr_irqlock+0x40>)
	pending_current = _current;
    707c:	4c0f      	ldr	r4, [pc, #60]	; (70bc <z_pend_curr_irqlock+0x44>)
{
    707e:	4606      	mov	r6, r0
	pend(_current, wait_q, timeout);
    7080:	68a8      	ldr	r0, [r5, #8]
    7082:	f7ff ffb5 	bl	6ff0 <pend>
	pending_current = _current;
    7086:	68ab      	ldr	r3, [r5, #8]
    7088:	6023      	str	r3, [r4, #0]
    708a:	4630      	mov	r0, r6
    708c:	f7fa f83a 	bl	1104 <arch_swap>
	__asm__ volatile(
    7090:	f04f 0220 	mov.w	r2, #32
    7094:	f3ef 8311 	mrs	r3, BASEPRI
    7098:	f382 8811 	msr	BASEPRI, r2
    709c:	f3bf 8f6f 	isb	sy
		if (pending_current == _current) {
    70a0:	6822      	ldr	r2, [r4, #0]
    70a2:	68a9      	ldr	r1, [r5, #8]
    70a4:	4291      	cmp	r1, r2
			pending_current = NULL;
    70a6:	bf04      	itt	eq
    70a8:	2200      	moveq	r2, #0
    70aa:	6022      	streq	r2, [r4, #0]
	__asm__ volatile(
    70ac:	f383 8811 	msr	BASEPRI, r3
    70b0:	f3bf 8f6f 	isb	sy
}
    70b4:	bd70      	pop	{r4, r5, r6, pc}
    70b6:	bf00      	nop
    70b8:	20000f54 	.word	0x20000f54
    70bc:	20000f84 	.word	0x20000f84

000070c0 <z_pend_curr>:
{
    70c0:	b510      	push	{r4, lr}
    70c2:	460c      	mov	r4, r1
    70c4:	4611      	mov	r1, r2
	pending_current = _current;
    70c6:	4a06      	ldr	r2, [pc, #24]	; (70e0 <z_pend_curr+0x20>)
    70c8:	6890      	ldr	r0, [r2, #8]
    70ca:	4a06      	ldr	r2, [pc, #24]	; (70e4 <z_pend_curr+0x24>)
    70cc:	6010      	str	r0, [r2, #0]
	pend(_current, wait_q, timeout);
    70ce:	461a      	mov	r2, r3
    70d0:	f7ff ff8e 	bl	6ff0 <pend>
    70d4:	4620      	mov	r0, r4
}
    70d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    70da:	f7fa b813 	b.w	1104 <arch_swap>
    70de:	bf00      	nop
    70e0:	20000f54 	.word	0x20000f54
    70e4:	20000f84 	.word	0x20000f84

000070e8 <z_tick_sleep.part.19>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static s32_t z_tick_sleep(s32_t ticks)
    70e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (ticks == 0) {
		k_yield();
		return 0;
	}

	ticks += _TICK_ALIGN;
    70ea:	1c46      	adds	r6, r0, #1
	expected_wakeup_time = ticks + z_tick_get_32();
    70ec:	f003 ff11 	bl	af12 <z_tick_get_32>
    70f0:	1834      	adds	r4, r6, r0
	__asm__ volatile(
    70f2:	f04f 0320 	mov.w	r3, #32
    70f6:	f3ef 8711 	mrs	r7, BASEPRI
    70fa:	f383 8811 	msr	BASEPRI, r3
    70fe:	f3bf 8f6f 	isb	sy
	 */
	struct k_spinlock local_lock = {};
	k_spinlock_key_t key = k_spin_lock(&local_lock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
    7102:	4d0d      	ldr	r5, [pc, #52]	; (7138 <z_tick_sleep.part.19+0x50>)
    7104:	4b0d      	ldr	r3, [pc, #52]	; (713c <z_tick_sleep.part.19+0x54>)
    7106:	68a8      	ldr	r0, [r5, #8]
    7108:	6018      	str	r0, [r3, #0]
#endif
	z_remove_thread_from_ready_q(_current);
    710a:	f7ff ff4b 	bl	6fa4 <z_remove_thread_from_ready_q>
    710e:	68a8      	ldr	r0, [r5, #8]
    7110:	490b      	ldr	r1, [pc, #44]	; (7140 <z_tick_sleep.part.19+0x58>)
    7112:	4632      	mov	r2, r6
    7114:	3018      	adds	r0, #24
    7116:	f000 fa05 	bl	7524 <z_add_timeout>
	z_add_thread_timeout(_current, ticks);
	z_mark_thread_as_suspended(_current);
    711a:	68aa      	ldr	r2, [r5, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
    711c:	7b53      	ldrb	r3, [r2, #13]
    711e:	f043 0310 	orr.w	r3, r3, #16
    7122:	7353      	strb	r3, [r2, #13]
    7124:	4638      	mov	r0, r7
    7126:	f7f9 ffed 	bl	1104 <arch_swap>

	(void)z_swap(&local_lock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = expected_wakeup_time - z_tick_get_32();
    712a:	f003 fef2 	bl	af12 <z_tick_get_32>
    712e:	1a20      	subs	r0, r4, r0
		return ticks;
	}
#endif

	return 0;
}
    7130:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
    7134:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7136:	bf00      	nop
    7138:	20000f54 	.word	0x20000f54
    713c:	20000f84 	.word	0x20000f84
    7140:	0000ad7f 	.word	0x0000ad7f

00007144 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
    7144:	4b04      	ldr	r3, [pc, #16]	; (7158 <z_sched_init+0x14>)
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    7146:	2100      	movs	r1, #0
    7148:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
    714c:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
    7150:	4608      	mov	r0, r1
    7152:	f7ff bd73 	b.w	6c3c <k_sched_time_slice_set>
    7156:	bf00      	nop
    7158:	20000f54 	.word	0x20000f54

0000715c <z_impl_k_yield>:
{
    715c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!z_is_idle_thread_object(_current)) {
    715e:	4c23      	ldr	r4, [pc, #140]	; (71ec <z_impl_k_yield+0x90>)
    7160:	4b23      	ldr	r3, [pc, #140]	; (71f0 <z_impl_k_yield+0x94>)
    7162:	68a2      	ldr	r2, [r4, #8]
    7164:	429a      	cmp	r2, r3
    7166:	d029      	beq.n	71bc <z_impl_k_yield+0x60>
    7168:	f04f 0320 	mov.w	r3, #32
    716c:	f3ef 8611 	mrs	r6, BASEPRI
    7170:	f383 8811 	msr	BASEPRI, r3
    7174:	f3bf 8f6f 	isb	sy
				_priq_run_remove(&_kernel.ready_q.runq,
    7178:	f104 0528 	add.w	r5, r4, #40	; 0x28
    717c:	68a1      	ldr	r1, [r4, #8]
    717e:	4628      	mov	r0, r5
    7180:	f7ff fd9c 	bl	6cbc <z_priq_dumb_remove>
	return list->head == list;
    7184:	6aa2      	ldr	r2, [r4, #40]	; 0x28
			_priq_run_add(&_kernel.ready_q.runq, _current);
    7186:	68a3      	ldr	r3, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    7188:	42aa      	cmp	r2, r5
    718a:	d028      	beq.n	71de <z_impl_k_yield+0x82>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    718c:	b33a      	cbz	r2, 71de <z_impl_k_yield+0x82>
    718e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
	if (thread_1->base.prio < thread_2->base.prio) {
    7190:	f993 100e 	ldrsb.w	r1, [r3, #14]
    7194:	f992 700e 	ldrsb.w	r7, [r2, #14]
    7198:	428f      	cmp	r7, r1
    719a:	dd1b      	ble.n	71d4 <z_impl_k_yield+0x78>
	node->prev = successor->prev;
    719c:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
    719e:	e9c3 2100 	strd	r2, r1, [r3]
	successor->prev->next = node;
    71a2:	600b      	str	r3, [r1, #0]
	successor->prev = node;
    71a4:	6053      	str	r3, [r2, #4]
	thread->base.thread_state |= states;
    71a6:	7b5a      	ldrb	r2, [r3, #13]
    71a8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    71ac:	735a      	strb	r2, [r3, #13]
			update_cache(1);
    71ae:	2001      	movs	r0, #1
    71b0:	f7ff fd9a 	bl	6ce8 <update_cache>
	__asm__ volatile(
    71b4:	f386 8811 	msr	BASEPRI, r6
    71b8:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
    71bc:	f04f 0320 	mov.w	r3, #32
    71c0:	f3ef 8011 	mrs	r0, BASEPRI
    71c4:	f383 8811 	msr	BASEPRI, r3
    71c8:	f3bf 8f6f 	isb	sy
}
    71cc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    71d0:	f7f9 bf98 	b.w	1104 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
    71d4:	4282      	cmp	r2, r0
    71d6:	d002      	beq.n	71de <z_impl_k_yield+0x82>
    71d8:	6812      	ldr	r2, [r2, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    71da:	2a00      	cmp	r2, #0
    71dc:	d1da      	bne.n	7194 <z_impl_k_yield+0x38>
	node->prev = list->tail;
    71de:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    71e0:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
    71e2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
	node->next = list;
    71e4:	601d      	str	r5, [r3, #0]
	list->tail->next = node;
    71e6:	6013      	str	r3, [r2, #0]
	list->tail = node;
    71e8:	62e3      	str	r3, [r4, #44]	; 0x2c
    71ea:	e7dc      	b.n	71a6 <z_impl_k_yield+0x4a>
    71ec:	20000f54 	.word	0x20000f54
    71f0:	20000e7c 	.word	0x20000e7c

000071f4 <z_impl_k_sleep>:

s32_t z_impl_k_sleep(int ms)
{
    71f4:	b538      	push	{r3, r4, r5, lr}
	s32_t ticks;

	__ASSERT(!arch_is_in_isr(), "");

	if (ms == K_FOREVER) {
    71f6:	1c43      	adds	r3, r0, #1
{
    71f8:	4604      	mov	r4, r0
	if (ms == K_FOREVER) {
    71fa:	d105      	bne.n	7208 <z_impl_k_sleep+0x14>
		k_thread_suspend(_current);
    71fc:	4b10      	ldr	r3, [pc, #64]	; (7240 <z_impl_k_sleep+0x4c>)
    71fe:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
    7200:	f000 f8dc 	bl	73bc <z_impl_k_thread_suspend>
	}

	ticks = k_ms_to_ticks_ceil32(ms);
	ticks = z_tick_sleep(ticks);
	return k_ticks_to_ms_floor64(ticks);
}
    7204:	4620      	mov	r0, r4
    7206:	bd38      	pop	{r3, r4, r5, pc}
    7208:	f44f 4500 	mov.w	r5, #32768	; 0x8000
    720c:	f240 30e7 	movw	r0, #999	; 0x3e7
    7210:	2100      	movs	r1, #0
    7212:	fbe5 0104 	umlal	r0, r1, r5, r4
    7216:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    721a:	2300      	movs	r3, #0
    721c:	f7f8 ff5e 	bl	dc <__aeabi_uldivmod>
	if (ticks == 0) {
    7220:	4604      	mov	r4, r0
    7222:	b948      	cbnz	r0, 7238 <z_impl_k_sleep+0x44>
	z_impl_k_yield();
    7224:	f7ff ff9a 	bl	715c <z_impl_k_yield>
		} else {
			return (t * to_hz + off) / from_hz;
    7228:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    722c:	fb84 0100 	smull	r0, r1, r4, r0
    7230:	0bc4      	lsrs	r4, r0, #15
    7232:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
	return k_ticks_to_ms_floor64(ticks);
    7236:	e7e5      	b.n	7204 <z_impl_k_sleep+0x10>
    7238:	f7ff ff56 	bl	70e8 <z_tick_sleep.part.19>
    723c:	4604      	mov	r4, r0
    723e:	e7f3      	b.n	7228 <z_impl_k_sleep+0x34>
    7240:	20000f54 	.word	0x20000f54

00007244 <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
    7244:	4b01      	ldr	r3, [pc, #4]	; (724c <z_impl_k_current_get+0x8>)
    7246:	6898      	ldr	r0, [r3, #8]
    7248:	4770      	bx	lr
    724a:	bf00      	nop
    724c:	20000f54 	.word	0x20000f54

00007250 <z_impl_k_sem_give>:
		handle_poll_events(sem);
	}
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    7250:	b570      	push	{r4, r5, r6, lr}
    7252:	4604      	mov	r4, r0
    7254:	f04f 0320 	mov.w	r3, #32
    7258:	f3ef 8611 	mrs	r6, BASEPRI
    725c:	f383 8811 	msr	BASEPRI, r3
    7260:	f3bf 8f6f 	isb	sy
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
    7264:	f003 fdbc 	bl	ade0 <z_unpend_first_thread>
	if (thread != NULL) {
    7268:	4605      	mov	r5, r0
    726a:	b170      	cbz	r0, 728a <z_impl_k_sem_give+0x3a>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    726c:	7b43      	ldrb	r3, [r0, #13]
    726e:	06db      	lsls	r3, r3, #27
    7270:	d103      	bne.n	727a <z_impl_k_sem_give+0x2a>
	if (z_is_thread_ready(thread)) {
    7272:	6983      	ldr	r3, [r0, #24]
    7274:	b90b      	cbnz	r3, 727a <z_impl_k_sem_give+0x2a>
		z_add_thread_to_ready_q(thread);
    7276:	f7ff fd71 	bl	6d5c <z_add_thread_to_ready_q>
    727a:	2300      	movs	r3, #0
    727c:	66ab      	str	r3, [r5, #104]	; 0x68
	k_spinlock_key_t key = k_spin_lock(&lock);

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);
	do_sem_give(sem);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
    727e:	4631      	mov	r1, r6
    7280:	4805      	ldr	r0, [pc, #20]	; (7298 <z_impl_k_sem_give+0x48>)
}
    7282:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&lock, key);
    7286:	f003 bd35 	b.w	acf4 <z_reschedule>
	sem->count += (sem->count != sem->limit) ? 1U : 0U;
    728a:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
    728e:	429a      	cmp	r2, r3
    7290:	bf18      	it	ne
    7292:	3301      	addne	r3, #1
    7294:	60a3      	str	r3, [r4, #8]
    7296:	e7f2      	b.n	727e <z_impl_k_sem_give+0x2e>
    7298:	20005325 	.word	0x20005325

0000729c <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, s32_t timeout)
{
    729c:	b410      	push	{r4}
    729e:	4602      	mov	r2, r0
    72a0:	460b      	mov	r3, r1
    72a2:	f04f 0020 	mov.w	r0, #32
    72a6:	f3ef 8111 	mrs	r1, BASEPRI
    72aa:	f380 8811 	msr	BASEPRI, r0
    72ae:	f3bf 8f6f 	isb	sy
	__ASSERT(((arch_is_in_isr() == false) || (timeout == K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
    72b2:	6894      	ldr	r4, [r2, #8]
    72b4:	b144      	cbz	r4, 72c8 <z_impl_k_sem_take+0x2c>
		sem->count--;
    72b6:	3c01      	subs	r4, #1
    72b8:	6094      	str	r4, [r2, #8]
	__asm__ volatile(
    72ba:	f381 8811 	msr	BASEPRI, r1
    72be:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
		return 0;
    72c2:	2000      	movs	r0, #0

	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);

	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
	return ret;
}
    72c4:	bc10      	pop	{r4}
    72c6:	4770      	bx	lr
	if (timeout == K_NO_WAIT) {
    72c8:	b933      	cbnz	r3, 72d8 <z_impl_k_sem_take+0x3c>
    72ca:	f381 8811 	msr	BASEPRI, r1
    72ce:	f3bf 8f6f 	isb	sy
		return -EBUSY;
    72d2:	f06f 000f 	mvn.w	r0, #15
    72d6:	e7f5      	b.n	72c4 <z_impl_k_sem_take+0x28>
	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    72d8:	4801      	ldr	r0, [pc, #4]	; (72e0 <z_impl_k_sem_take+0x44>)
}
    72da:	bc10      	pop	{r4}
	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    72dc:	f7ff bef0 	b.w	70c0 <z_pend_curr>
    72e0:	20005325 	.word	0x20005325

000072e4 <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
    72e4:	b510      	push	{r4, lr}
	__asm__ volatile(
    72e6:	f04f 0220 	mov.w	r2, #32
    72ea:	f3ef 8411 	mrs	r4, BASEPRI
    72ee:	f382 8811 	msr	BASEPRI, r2
    72f2:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock); /* protect kernel queues */

	if (z_has_thread_started(thread)) {
    72f6:	7b42      	ldrb	r2, [r0, #13]
    72f8:	0751      	lsls	r1, r2, #29
    72fa:	d404      	bmi.n	7306 <z_impl_k_thread_start+0x22>
	__asm__ volatile(
    72fc:	f384 8811 	msr	BASEPRI, r4
    7300:	f3bf 8f6f 	isb	sy
	}

	z_mark_thread_as_started(thread);
	z_ready_thread(thread);
	z_reschedule(&lock, key);
}
    7304:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
    7306:	f022 0104 	bic.w	r1, r2, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    730a:	f012 0f1b 	tst.w	r2, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
    730e:	7341      	strb	r1, [r0, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    7310:	d103      	bne.n	731a <z_impl_k_thread_start+0x36>
	if (z_is_thread_ready(thread)) {
    7312:	6983      	ldr	r3, [r0, #24]
    7314:	b90b      	cbnz	r3, 731a <z_impl_k_thread_start+0x36>
		z_add_thread_to_ready_q(thread);
    7316:	f7ff fd21 	bl	6d5c <z_add_thread_to_ready_q>
	z_reschedule(&lock, key);
    731a:	4621      	mov	r1, r4
    731c:	4802      	ldr	r0, [pc, #8]	; (7328 <z_impl_k_thread_start+0x44>)
}
    731e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&lock, key);
    7322:	f003 bce7 	b.w	acf4 <z_reschedule>
    7326:	bf00      	nop
    7328:	20005325 	.word	0x20005325

0000732c <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
    732c:	b530      	push	{r4, r5, lr}
    732e:	b087      	sub	sp, #28
    7330:	4604      	mov	r4, r0
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    7332:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    7334:	9504      	str	r5, [sp, #16]
    7336:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    7338:	9503      	str	r5, [sp, #12]
    733a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    733c:	9502      	str	r5, [sp, #8]
    733e:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    7340:	9501      	str	r5, [sp, #4]
    7342:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    7344:	9500      	str	r5, [sp, #0]
    7346:	f7f9 ff59 	bl	11fc <arch_new_thread>
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
    734a:	4b03      	ldr	r3, [pc, #12]	; (7358 <z_setup_new_thread+0x2c>)
    734c:	689b      	ldr	r3, [r3, #8]
    734e:	b103      	cbz	r3, 7352 <z_setup_new_thread+0x26>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
    7350:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    7352:	6623      	str	r3, [r4, #96]	; 0x60
	sys_trace_thread_create(new_thread);
}
    7354:	b007      	add	sp, #28
    7356:	bd30      	pop	{r4, r5, pc}
    7358:	20000f54 	.word	0x20000f54

0000735c <z_impl_k_thread_create>:
k_tid_t z_impl_k_thread_create(struct k_thread *new_thread,
			      k_thread_stack_t *stack,
			      size_t stack_size, k_thread_entry_t entry,
			      void *p1, void *p2, void *p3,
			      int prio, u32_t options, s32_t delay)
{
    735c:	b570      	push	{r4, r5, r6, lr}
    735e:	b086      	sub	sp, #24
	__ASSERT((options & K_USER) == 0,
		 "Platform is capable of user mode, and test thread created with K_USER option,"
		 " but neither CONFIG_TEST_USERSPACE nor CONFIG_USERSPACE is set\n");
#endif

	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    7360:	2600      	movs	r6, #0
    7362:	9605      	str	r6, [sp, #20]
    7364:	9e0e      	ldr	r6, [sp, #56]	; 0x38
    7366:	9604      	str	r6, [sp, #16]
    7368:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    736a:	9603      	str	r6, [sp, #12]
    736c:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    736e:	9602      	str	r6, [sp, #8]
    7370:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
{
    7372:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    7374:	9601      	str	r6, [sp, #4]
    7376:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    7378:	9600      	str	r6, [sp, #0]
{
    737a:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    737c:	f7ff ffd6 	bl	732c <z_setup_new_thread>
			  prio, options, NULL);

	if (delay != K_FOREVER) {
    7380:	1c6b      	adds	r3, r5, #1
    7382:	d003      	beq.n	738c <z_impl_k_thread_create+0x30>
	if (delay == 0) {
    7384:	b92d      	cbnz	r5, 7392 <z_impl_k_thread_create+0x36>
	z_impl_k_thread_start(thread);
    7386:	4620      	mov	r0, r4
    7388:	f7ff ffac 	bl	72e4 <z_impl_k_thread_start>
		schedule_new_thread(new_thread, delay);
	}

	return new_thread;
}
    738c:	4620      	mov	r0, r4
    738e:	b006      	add	sp, #24
    7390:	bd70      	pop	{r4, r5, r6, pc}
			return (u32_t)((t * to_hz + off) / from_hz);
    7392:	f44f 4600 	mov.w	r6, #32768	; 0x8000
    7396:	f240 30e7 	movw	r0, #999	; 0x3e7
    739a:	2100      	movs	r1, #0
    739c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    73a0:	2300      	movs	r3, #0
    73a2:	fbe6 0105 	umlal	r0, r1, r6, r5
    73a6:	f7f8 fe99 	bl	dc <__aeabi_uldivmod>
    73aa:	4903      	ldr	r1, [pc, #12]	; (73b8 <z_impl_k_thread_create+0x5c>)
    73ac:	1c42      	adds	r2, r0, #1
    73ae:	f104 0018 	add.w	r0, r4, #24
    73b2:	f000 f8b7 	bl	7524 <z_add_timeout>
    73b6:	e7e9      	b.n	738c <z_impl_k_thread_create+0x30>
    73b8:	0000ad7f 	.word	0x0000ad7f

000073bc <z_impl_k_thread_suspend>:
#endif /* CONFIG_MULTITHREADING */

extern void z_thread_single_suspend(struct k_thread *thread);

void z_impl_k_thread_suspend(struct k_thread *thread)
{
    73bc:	b538      	push	{r3, r4, r5, lr}
    73be:	4605      	mov	r5, r0
	__asm__ volatile(
    73c0:	f04f 0320 	mov.w	r3, #32
    73c4:	f3ef 8411 	mrs	r4, BASEPRI
    73c8:	f383 8811 	msr	BASEPRI, r3
    73cc:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);

	z_thread_single_suspend(thread);
    73d0:	f7ff fd72 	bl	6eb8 <z_thread_single_suspend>

	if (thread == _current) {
    73d4:	4b07      	ldr	r3, [pc, #28]	; (73f4 <z_impl_k_thread_suspend+0x38>)
    73d6:	689b      	ldr	r3, [r3, #8]
    73d8:	42ab      	cmp	r3, r5
    73da:	d105      	bne.n	73e8 <z_impl_k_thread_suspend+0x2c>
		z_reschedule(&lock, key);
    73dc:	4621      	mov	r1, r4
    73de:	4806      	ldr	r0, [pc, #24]	; (73f8 <z_impl_k_thread_suspend+0x3c>)
	} else {
		k_spin_unlock(&lock, key);
	}
}
    73e0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&lock, key);
    73e4:	f003 bc86 	b.w	acf4 <z_reschedule>
	__asm__ volatile(
    73e8:	f384 8811 	msr	BASEPRI, r4
    73ec:	f3bf 8f6f 	isb	sy
}
    73f0:	bd38      	pop	{r3, r4, r5, pc}
    73f2:	bf00      	nop
    73f4:	20000f54 	.word	0x20000f54
    73f8:	20005325 	.word	0x20005325

000073fc <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
    73fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
    7400:	4e28      	ldr	r6, [pc, #160]	; (74a4 <z_init_static_threads+0xa8>)
    7402:	4d29      	ldr	r5, [pc, #164]	; (74a8 <z_init_static_threads+0xac>)
{
    7404:	b087      	sub	sp, #28
    7406:	46b0      	mov	r8, r6
	_FOREACH_STATIC_THREAD(thread_data) {
    7408:	42b5      	cmp	r5, r6
    740a:	f105 0430 	add.w	r4, r5, #48	; 0x30
    740e:	d310      	bcc.n	7432 <z_init_static_threads+0x36>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
    7410:	f7ff fc40 	bl	6c94 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    7414:	4c24      	ldr	r4, [pc, #144]	; (74a8 <z_init_static_threads+0xac>)
    7416:	f8df a094 	ldr.w	sl, [pc, #148]	; 74ac <z_init_static_threads+0xb0>
    741a:	f44f 4900 	mov.w	r9, #32768	; 0x8000
    741e:	f240 36e7 	movw	r6, #999	; 0x3e7
    7422:	2700      	movs	r7, #0
    7424:	4544      	cmp	r4, r8
    7426:	d321      	bcc.n	746c <z_init_static_threads+0x70>
			schedule_new_thread(thread_data->init_thread,
					    thread_data->init_delay);
		}
	}
	k_sched_unlock();
}
    7428:	b007      	add	sp, #28
    742a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	k_sched_unlock();
    742e:	f7ff bc79 	b.w	6d24 <k_sched_unlock>
		z_setup_new_thread(
    7432:	f854 3c04 	ldr.w	r3, [r4, #-4]
    7436:	9305      	str	r3, [sp, #20]
    7438:	f854 3c10 	ldr.w	r3, [r4, #-16]
    743c:	9304      	str	r3, [sp, #16]
    743e:	f854 3c14 	ldr.w	r3, [r4, #-20]
    7442:	9303      	str	r3, [sp, #12]
    7444:	f854 3c18 	ldr.w	r3, [r4, #-24]
    7448:	9302      	str	r3, [sp, #8]
    744a:	f854 3c1c 	ldr.w	r3, [r4, #-28]
    744e:	9301      	str	r3, [sp, #4]
    7450:	f854 3c20 	ldr.w	r3, [r4, #-32]
    7454:	9300      	str	r3, [sp, #0]
    7456:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
    745a:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
    745e:	f7ff ff65 	bl	732c <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    7462:	f854 3c30 	ldr.w	r3, [r4, #-48]
    7466:	64dd      	str	r5, [r3, #76]	; 0x4c
    7468:	4625      	mov	r5, r4
    746a:	e7cd      	b.n	7408 <z_init_static_threads+0xc>
		if (thread_data->init_delay != K_FOREVER) {
    746c:	6a61      	ldr	r1, [r4, #36]	; 0x24
    746e:	1c4b      	adds	r3, r1, #1
    7470:	d004      	beq.n	747c <z_init_static_threads+0x80>
			schedule_new_thread(thread_data->init_thread,
    7472:	6825      	ldr	r5, [r4, #0]
	if (delay == 0) {
    7474:	b921      	cbnz	r1, 7480 <z_init_static_threads+0x84>
    7476:	4628      	mov	r0, r5
    7478:	f7ff ff34 	bl	72e4 <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    747c:	3430      	adds	r4, #48	; 0x30
    747e:	e7d1      	b.n	7424 <z_init_static_threads+0x28>
    7480:	46b3      	mov	fp, r6
    7482:	46bc      	mov	ip, r7
    7484:	fbe9 bc01 	umlal	fp, ip, r9, r1
    7488:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    748c:	2300      	movs	r3, #0
    748e:	4658      	mov	r0, fp
    7490:	4661      	mov	r1, ip
    7492:	f7f8 fe23 	bl	dc <__aeabi_uldivmod>
    7496:	4651      	mov	r1, sl
    7498:	1c42      	adds	r2, r0, #1
    749a:	f105 0018 	add.w	r0, r5, #24
    749e:	f000 f841 	bl	7524 <z_add_timeout>
    74a2:	e7eb      	b.n	747c <z_init_static_threads+0x80>
    74a4:	200069d0 	.word	0x200069d0
    74a8:	200069d0 	.word	0x200069d0
    74ac:	0000ad7f 	.word	0x0000ad7f

000074b0 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
    74b0:	4b03      	ldr	r3, [pc, #12]	; (74c0 <elapsed+0x10>)
    74b2:	681b      	ldr	r3, [r3, #0]
    74b4:	b90b      	cbnz	r3, 74ba <elapsed+0xa>
    74b6:	f7f9 bde3 	b.w	1080 <z_clock_elapsed>
}
    74ba:	2000      	movs	r0, #0
    74bc:	4770      	bx	lr
    74be:	bf00      	nop
    74c0:	20000f90 	.word	0x20000f90

000074c4 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    74c4:	6803      	ldr	r3, [r0, #0]
    74c6:	b140      	cbz	r0, 74da <remove_timeout+0x16>
    74c8:	4a07      	ldr	r2, [pc, #28]	; (74e8 <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
    74ca:	6852      	ldr	r2, [r2, #4]
    74cc:	4290      	cmp	r0, r2
    74ce:	d004      	beq.n	74da <remove_timeout+0x16>
	if (next(t) != NULL) {
    74d0:	b11b      	cbz	r3, 74da <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
    74d2:	689a      	ldr	r2, [r3, #8]
    74d4:	6881      	ldr	r1, [r0, #8]
    74d6:	440a      	add	r2, r1
    74d8:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
    74da:	6842      	ldr	r2, [r0, #4]
    74dc:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
    74de:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    74e0:	2300      	movs	r3, #0
	node->prev = NULL;
    74e2:	e9c0 3300 	strd	r3, r3, [r0]
}
    74e6:	4770      	bx	lr
    74e8:	20006900 	.word	0x20006900

000074ec <next_timeout>:
	return list->head == list;
    74ec:	4b0b      	ldr	r3, [pc, #44]	; (751c <next_timeout+0x30>)

static s32_t next_timeout(void)
{
    74ee:	b510      	push	{r4, lr}
    74f0:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    74f2:	429c      	cmp	r4, r3
    74f4:	bf08      	it	eq
    74f6:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
    74f8:	f7ff ffda 	bl	74b0 <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
    74fc:	b154      	cbz	r4, 7514 <next_timeout+0x28>
    74fe:	68a3      	ldr	r3, [r4, #8]
    7500:	1a18      	subs	r0, r3, r0
    7502:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    7506:	4b06      	ldr	r3, [pc, #24]	; (7520 <next_timeout+0x34>)
    7508:	691b      	ldr	r3, [r3, #16]
    750a:	b113      	cbz	r3, 7512 <next_timeout+0x26>
    750c:	4298      	cmp	r0, r3
    750e:	bfa8      	it	ge
    7510:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    7512:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
    7514:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    7518:	e7f5      	b.n	7506 <next_timeout+0x1a>
    751a:	bf00      	nop
    751c:	20006900 	.word	0x20006900
    7520:	20000f54 	.word	0x20000f54

00007524 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
    7524:	b570      	push	{r4, r5, r6, lr}
    7526:	4604      	mov	r4, r0
    7528:	4616      	mov	r6, r2
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    752a:	60c1      	str	r1, [r0, #12]
	__asm__ volatile(
    752c:	f04f 0320 	mov.w	r3, #32
    7530:	f3ef 8511 	mrs	r5, BASEPRI
    7534:	f383 8811 	msr	BASEPRI, r3
    7538:	f3bf 8f6f 	isb	sy
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
    753c:	f7ff ffb8 	bl	74b0 <elapsed>
	return list->head == list;
    7540:	4b18      	ldr	r3, [pc, #96]	; (75a4 <z_add_timeout+0x80>)
    7542:	681a      	ldr	r2, [r3, #0]
    7544:	2e01      	cmp	r6, #1
    7546:	bfac      	ite	ge
    7548:	1980      	addge	r0, r0, r6
    754a:	3001      	addlt	r0, #1
	return sys_dlist_is_empty(list) ? NULL : list->head;
    754c:	429a      	cmp	r2, r3
    754e:	60a0      	str	r0, [r4, #8]
    7550:	d001      	beq.n	7556 <z_add_timeout+0x32>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    7552:	685e      	ldr	r6, [r3, #4]
		for (t = first(); t != NULL; t = next(t)) {
    7554:	b932      	cbnz	r2, 7564 <z_add_timeout+0x40>
	node->prev = list->tail;
    7556:	685a      	ldr	r2, [r3, #4]
    7558:	6062      	str	r2, [r4, #4]
	list->tail->next = node;
    755a:	685a      	ldr	r2, [r3, #4]
	node->next = list;
    755c:	6023      	str	r3, [r4, #0]
	list->tail->next = node;
    755e:	6014      	str	r4, [r2, #0]
	list->tail = node;
    7560:	605c      	str	r4, [r3, #4]
    7562:	e00a      	b.n	757a <z_add_timeout+0x56>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
    7564:	6890      	ldr	r0, [r2, #8]
    7566:	68a1      	ldr	r1, [r4, #8]
    7568:	4288      	cmp	r0, r1
    756a:	dd15      	ble.n	7598 <z_add_timeout+0x74>
				t->dticks -= to->dticks;
    756c:	1a41      	subs	r1, r0, r1
    756e:	6091      	str	r1, [r2, #8]
	node->prev = successor->prev;
    7570:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
    7572:	e9c4 2100 	strd	r2, r1, [r4]
	successor->prev->next = node;
    7576:	600c      	str	r4, [r1, #0]
	successor->prev = node;
    7578:	6054      	str	r4, [r2, #4]
	return list->head == list;
    757a:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    757c:	429a      	cmp	r2, r3
    757e:	d006      	beq.n	758e <z_add_timeout+0x6a>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    7580:	4294      	cmp	r4, r2
    7582:	d104      	bne.n	758e <z_add_timeout+0x6a>
			z_clock_set_timeout(next_timeout(), false);
    7584:	f7ff ffb2 	bl	74ec <next_timeout>
    7588:	2100      	movs	r1, #0
    758a:	f7f9 fd23 	bl	fd4 <z_clock_set_timeout>
	__asm__ volatile(
    758e:	f385 8811 	msr	BASEPRI, r5
    7592:	f3bf 8f6f 	isb	sy
		}
	}
}
    7596:	bd70      	pop	{r4, r5, r6, pc}
			to->dticks -= t->dticks;
    7598:	1a09      	subs	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
    759a:	42b2      	cmp	r2, r6
    759c:	60a1      	str	r1, [r4, #8]
    759e:	d0da      	beq.n	7556 <z_add_timeout+0x32>
    75a0:	6812      	ldr	r2, [r2, #0]
    75a2:	e7d7      	b.n	7554 <z_add_timeout+0x30>
    75a4:	20006900 	.word	0x20006900

000075a8 <z_clock_announce>:
		}
	}
}

void z_clock_announce(s32_t ticks)
{
    75a8:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
    75ac:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    75ae:	f7ff fc4d 	bl	6e4c <z_time_slice>
	__asm__ volatile(
    75b2:	f04f 0320 	mov.w	r3, #32
    75b6:	f3ef 8511 	mrs	r5, BASEPRI
    75ba:	f383 8811 	msr	BASEPRI, r3
    75be:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    75c2:	4e21      	ldr	r6, [pc, #132]	; (7648 <z_clock_announce+0xa0>)
    75c4:	4f21      	ldr	r7, [pc, #132]	; (764c <z_clock_announce+0xa4>)
	return list->head == list;
    75c6:	f8df 9088 	ldr.w	r9, [pc, #136]	; 7650 <z_clock_announce+0xa8>
    75ca:	6034      	str	r4, [r6, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
    75cc:	46b8      	mov	r8, r7
    75ce:	f8d9 4000 	ldr.w	r4, [r9]
    75d2:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    75d4:	454c      	cmp	r4, r9
    75d6:	e9d7 bc00 	ldrd	fp, ip, [r7]
    75da:	d005      	beq.n	75e8 <z_clock_announce+0x40>
    75dc:	b124      	cbz	r4, 75e8 <z_clock_announce+0x40>
    75de:	68a3      	ldr	r3, [r4, #8]
    75e0:	4293      	cmp	r3, r2
    75e2:	dd14      	ble.n	760e <z_clock_announce+0x66>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    75e4:	1a9b      	subs	r3, r3, r2
    75e6:	60a3      	str	r3, [r4, #8]
	}

	curr_tick += announce_remaining;
    75e8:	eb1b 0002 	adds.w	r0, fp, r2
    75ec:	eb4c 71e2 	adc.w	r1, ip, r2, asr #31
	announce_remaining = 0;
    75f0:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
    75f2:	e9c8 0100 	strd	r0, r1, [r8]
	announce_remaining = 0;
    75f6:	6034      	str	r4, [r6, #0]

	z_clock_set_timeout(next_timeout(), false);
    75f8:	f7ff ff78 	bl	74ec <next_timeout>
    75fc:	4621      	mov	r1, r4
    75fe:	f7f9 fce9 	bl	fd4 <z_clock_set_timeout>
	__asm__ volatile(
    7602:	f385 8811 	msr	BASEPRI, r5
    7606:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
    760a:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		curr_tick += dt;
    760e:	eb1b 0003 	adds.w	r0, fp, r3
    7612:	eb4c 71e3 	adc.w	r1, ip, r3, asr #31
		announce_remaining -= dt;
    7616:	1ad3      	subs	r3, r2, r3
    7618:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
    761a:	2300      	movs	r3, #0
		curr_tick += dt;
    761c:	e9c7 0100 	strd	r0, r1, [r7]
		t->dticks = 0;
    7620:	60a3      	str	r3, [r4, #8]
		remove_timeout(t);
    7622:	4620      	mov	r0, r4
    7624:	f7ff ff4e 	bl	74c4 <remove_timeout>
    7628:	f385 8811 	msr	BASEPRI, r5
    762c:	f3bf 8f6f 	isb	sy
		t->fn(t);
    7630:	68e3      	ldr	r3, [r4, #12]
    7632:	4798      	blx	r3
	__asm__ volatile(
    7634:	f04f 0320 	mov.w	r3, #32
    7638:	f3ef 8511 	mrs	r5, BASEPRI
    763c:	f383 8811 	msr	BASEPRI, r3
    7640:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    7644:	e7c3      	b.n	75ce <z_clock_announce+0x26>
    7646:	bf00      	nop
    7648:	20000f90 	.word	0x20000f90
    764c:	20000000 	.word	0x20000000
    7650:	20006900 	.word	0x20006900

00007654 <z_tick_get>:

s64_t z_tick_get(void)
{
    7654:	e92d 4818 	stmdb	sp!, {r3, r4, fp, lr}
    7658:	f04f 0320 	mov.w	r3, #32
    765c:	f3ef 8411 	mrs	r4, BASEPRI
    7660:	f383 8811 	msr	BASEPRI, r3
    7664:	f3bf 8f6f 	isb	sy
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
    7668:	f7f9 fd0a 	bl	1080 <z_clock_elapsed>
    766c:	4b07      	ldr	r3, [pc, #28]	; (768c <z_tick_get+0x38>)
    766e:	e9d3 2300 	ldrd	r2, r3, [r3]
    7672:	eb12 0b00 	adds.w	fp, r2, r0
    7676:	f143 0c00 	adc.w	ip, r3, #0
    767a:	4658      	mov	r0, fp
    767c:	4661      	mov	r1, ip
	__asm__ volatile(
    767e:	f384 8811 	msr	BASEPRI, r4
    7682:	f3bf 8f6f 	isb	sy
	}
	return t;
}
    7686:	e8bd 8818 	ldmia.w	sp!, {r3, r4, fp, pc}
    768a:	bf00      	nop
    768c:	20000000 	.word	0x20000000

00007690 <z_timer_expiration_handler>:

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
    7690:	6a02      	ldr	r2, [r0, #32]
    7692:	2a00      	cmp	r2, #0
{
    7694:	b538      	push	{r3, r4, r5, lr}
    7696:	4604      	mov	r4, r0
	if (timer->period > 0) {
    7698:	dd02      	ble.n	76a0 <z_timer_expiration_handler+0x10>
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    769a:	490e      	ldr	r1, [pc, #56]	; (76d4 <z_timer_expiration_handler+0x44>)
    769c:	f7ff ff42 	bl	7524 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
    76a0:	6a63      	ldr	r3, [r4, #36]	; 0x24
    76a2:	3301      	adds	r3, #1
    76a4:	6263      	str	r3, [r4, #36]	; 0x24

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
    76a6:	69a3      	ldr	r3, [r4, #24]
    76a8:	b10b      	cbz	r3, 76ae <z_timer_expiration_handler+0x1e>
		timer->expiry_fn(timer);
    76aa:	4620      	mov	r0, r4
    76ac:	4798      	blx	r3
	return list->head == list;
    76ae:	f854 5f10 	ldr.w	r5, [r4, #16]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    76b2:	42a5      	cmp	r5, r4
    76b4:	d00d      	beq.n	76d2 <z_timer_expiration_handler+0x42>
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
    76b6:	b165      	cbz	r5, 76d2 <z_timer_expiration_handler+0x42>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
    76b8:	4628      	mov	r0, r5
    76ba:	f003 fb02 	bl	acc2 <z_unpend_thread_no_timeout>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    76be:	7b6b      	ldrb	r3, [r5, #13]
    76c0:	06db      	lsls	r3, r3, #27
    76c2:	d104      	bne.n	76ce <z_timer_expiration_handler+0x3e>
	if (z_is_thread_ready(thread)) {
    76c4:	69ab      	ldr	r3, [r5, #24]
    76c6:	b913      	cbnz	r3, 76ce <z_timer_expiration_handler+0x3e>
		z_add_thread_to_ready_q(thread);
    76c8:	4628      	mov	r0, r5
    76ca:	f7ff fb47 	bl	6d5c <z_add_thread_to_ready_q>
    76ce:	2300      	movs	r3, #0
    76d0:	66ab      	str	r3, [r5, #104]	; 0x68

	z_ready_thread(thread);

	arch_thread_return_value_set(thread, 0);
}
    76d2:	bd38      	pop	{r3, r4, r5, pc}
    76d4:	00007691 	.word	0x00007691

000076d8 <z_impl_k_timer_start>:
	z_object_init(timer);
}


void z_impl_k_timer_start(struct k_timer *timer, s32_t duration, s32_t period)
{
    76d8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    76dc:	f240 36e7 	movw	r6, #999	; 0x3e7
    76e0:	2700      	movs	r7, #0
    76e2:	4604      	mov	r4, r0
    76e4:	4688      	mov	r8, r1
    76e6:	f44f 4500 	mov.w	r5, #32768	; 0x8000
    76ea:	4630      	mov	r0, r6
    76ec:	4639      	mov	r1, r7
    76ee:	fbe5 0102 	umlal	r0, r1, r5, r2
    76f2:	2300      	movs	r3, #0
    76f4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    76f8:	f7f8 fcf0 	bl	dc <__aeabi_uldivmod>
    76fc:	4639      	mov	r1, r7
	__ASSERT(duration >= 0 && period >= 0 &&
		 (duration != 0 || period != 0), "invalid parameters\n");

	volatile s32_t period_in_ticks, duration_in_ticks;

	period_in_ticks = k_ms_to_ticks_ceil32(period);
    76fe:	9000      	str	r0, [sp, #0]
    7700:	4630      	mov	r0, r6
    7702:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    7706:	2300      	movs	r3, #0
    7708:	fbe5 0108 	umlal	r0, r1, r5, r8
    770c:	f7f8 fce6 	bl	dc <__aeabi_uldivmod>
	duration_in_ticks = k_ms_to_ticks_ceil32(duration);
    7710:	9001      	str	r0, [sp, #4]

	(void)z_abort_timeout(&timer->timeout);
    7712:	4620      	mov	r0, r4
    7714:	f003 fbbd 	bl	ae92 <z_abort_timeout>
	timer->period = period_in_ticks;
    7718:	9b00      	ldr	r3, [sp, #0]
	timer->status = 0U;
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    771a:	4905      	ldr	r1, [pc, #20]	; (7730 <z_impl_k_timer_start+0x58>)
    771c:	9a01      	ldr	r2, [sp, #4]
	timer->period = period_in_ticks;
    771e:	6223      	str	r3, [r4, #32]
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    7720:	4620      	mov	r0, r4
	timer->status = 0U;
    7722:	2300      	movs	r3, #0
    7724:	6263      	str	r3, [r4, #36]	; 0x24
		     duration_in_ticks);
}
    7726:	b002      	add	sp, #8
    7728:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    772c:	f7ff befa 	b.w	7524 <z_add_timeout>
    7730:	00007691 	.word	0x00007691

00007734 <lv_scr_act>:
/**
 * Get the active screen of the default display
 * @return pointer to the active screen
 */
static inline lv_obj_t * lv_scr_act(void)
{
    7734:	b508      	push	{r3, lr}
    return lv_disp_get_scr_act(lv_disp_get_default());
    7736:	f7fd fed9 	bl	54ec <lv_disp_get_default>
}
    773a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return lv_disp_get_scr_act(lv_disp_get_default());
    773e:	f7fc b981 	b.w	3a44 <lv_disp_get_scr_act>

00007742 <get_bit_ptr>:
/* Places a 32 bit output pointer in word, and an integer bit index
 * within that word as the return value
 */
static int get_bit_ptr(struct sys_mem_pool_base *p, int level, int bn,
		       u32_t **word)
{
    7742:	b570      	push	{r4, r5, r6, lr}
    7744:	68c6      	ldr	r6, [r0, #12]
	u32_t *bitarray = level <= p->max_inline_level ?
    7746:	f990 000b 	ldrsb.w	r0, [r0, #11]
    774a:	250c      	movs	r5, #12
    774c:	434d      	muls	r5, r1
		p->levels[level].bits : p->levels[level].bits_p;
    774e:	4288      	cmp	r0, r1
    7750:	eb06 0405 	add.w	r4, r6, r5
    7754:	bfb8      	it	lt
    7756:	5974      	ldrlt	r4, [r6, r5]

	*word = &bitarray[bn / 32];
    7758:	2a00      	cmp	r2, #0
    775a:	4610      	mov	r0, r2
    775c:	bfb8      	it	lt
    775e:	f102 001f 	addlt.w	r0, r2, #31
    7762:	1140      	asrs	r0, r0, #5
    7764:	eb04 0180 	add.w	r1, r4, r0, lsl #2
    7768:	6019      	str	r1, [r3, #0]

	return bn & 0x1f;
}
    776a:	f002 001f 	and.w	r0, r2, #31
    776e:	bd70      	pop	{r4, r5, r6, pc}

00007770 <pool_irq_lock.isra.2.part.3>:
	__asm__ volatile(
    7770:	f04f 0320 	mov.w	r3, #32
    7774:	f3ef 8011 	mrs	r0, BASEPRI
    7778:	f383 8811 	msr	BASEPRI, r3
    777c:	f3bf 8f6f 	isb	sy
	if (p->flags & SYS_MEM_POOL_KERNEL) {
		return irq_lock();
	} else {
		return 0;
	}
}
    7780:	4770      	bx	lr

00007782 <pool_irq_unlock.isra.4>:

static inline void pool_irq_unlock(struct sys_mem_pool_base *p, int key)
{
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    7782:	07c3      	lsls	r3, r0, #31
    7784:	d503      	bpl.n	778e <pool_irq_unlock.isra.4+0xc>
	__asm__ volatile(
    7786:	f381 8811 	msr	BASEPRI, r1
    778a:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}
}
    778e:	4770      	bx	lr

00007790 <z_sys_mem_pool_base_init>:
{
    7790:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    7794:	6846      	ldr	r6, [r0, #4]
    7796:	8907      	ldrh	r7, [r0, #8]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
    7798:	6801      	ldr	r1, [r0, #0]
	for (i = 0; i < p->n_levels; i++) {
    779a:	f890 800a 	ldrb.w	r8, [r0, #10]
	p->max_inline_level = -1;
    779e:	23ff      	movs	r3, #255	; 0xff
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    77a0:	fb06 fc07 	mul.w	ip, r6, r7
	p->max_inline_level = -1;
    77a4:	72c3      	strb	r3, [r0, #11]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
    77a6:	4461      	add	r1, ip
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    77a8:	4632      	mov	r2, r6
	for (i = 0; i < p->n_levels; i++) {
    77aa:	2300      	movs	r3, #0
		sys_dlist_init(&p->levels[i].free_list);
    77ac:	f04f 090c 	mov.w	r9, #12
	for (i = 0; i < p->n_levels; i++) {
    77b0:	4598      	cmp	r8, r3
    77b2:	dc05      	bgt.n	77c0 <z_sys_mem_pool_base_init+0x30>
    77b4:	2300      	movs	r3, #0
	for (i = 0; i < p->n_max; i++) {
    77b6:	4619      	mov	r1, r3
    77b8:	428f      	cmp	r7, r1
    77ba:	dc20      	bgt.n	77fe <z_sys_mem_pool_base_init+0x6e>
}
    77bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		sys_dlist_init(&p->levels[i].free_list);
    77c0:	f8d0 a00c 	ldr.w	sl, [r0, #12]
		int nblocks = buflen / sz;
    77c4:	fbbc f5f2 	udiv	r5, ip, r2
		sys_dlist_init(&p->levels[i].free_list);
    77c8:	fb09 fe03 	mul.w	lr, r9, r3
    77cc:	eb0a 040e 	add.w	r4, sl, lr
    77d0:	f104 0b04 	add.w	fp, r4, #4
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
    77d4:	2d20      	cmp	r5, #32
	list->tail = (sys_dnode_t *)list;
    77d6:	e9c4 bb01 	strd	fp, fp, [r4, #4]
    77da:	d805      	bhi.n	77e8 <z_sys_mem_pool_base_init+0x58>
			p->max_inline_level = i;
    77dc:	72c3      	strb	r3, [r0, #11]
		sz = WB_DN(sz / 4);
    77de:	0892      	lsrs	r2, r2, #2
    77e0:	f022 0203 	bic.w	r2, r2, #3
	for (i = 0; i < p->n_levels; i++) {
    77e4:	3301      	adds	r3, #1
    77e6:	e7e3      	b.n	77b0 <z_sys_mem_pool_base_init+0x20>
			bits += (nblocks + 31)/32;
    77e8:	f115 041f 	adds.w	r4, r5, #31
    77ec:	bf48      	it	mi
    77ee:	f105 043e 	addmi.w	r4, r5, #62	; 0x3e
    77f2:	1164      	asrs	r4, r4, #5
			p->levels[i].bits_p = bits;
    77f4:	f84a 100e 	str.w	r1, [sl, lr]
			bits += (nblocks + 31)/32;
    77f8:	eb01 0184 	add.w	r1, r1, r4, lsl #2
    77fc:	e7ef      	b.n	77de <z_sys_mem_pool_base_init+0x4e>
		sys_dlist_append(&p->levels[0].free_list, block);
    77fe:	68c2      	ldr	r2, [r0, #12]
	return (u8_t *)p->buf + lsz * block;
    7800:	6805      	ldr	r5, [r0, #0]
		sys_dlist_append(&p->levels[0].free_list, block);
    7802:	f102 0c04 	add.w	ip, r2, #4
	return (u8_t *)p->buf + lsz * block;
    7806:	18ec      	adds	r4, r5, r3
	node->next = list;
    7808:	f845 c003 	str.w	ip, [r5, r3]
	node->prev = list->tail;
    780c:	6895      	ldr	r5, [r2, #8]
    780e:	6065      	str	r5, [r4, #4]
	list->tail->next = node;
    7810:	6895      	ldr	r5, [r2, #8]
	for (i = 0; i < p->n_max; i++) {
    7812:	3101      	adds	r1, #1
    7814:	602c      	str	r4, [r5, #0]
	list->tail = node;
    7816:	4433      	add	r3, r6
    7818:	6094      	str	r4, [r2, #8]
    781a:	e7cd      	b.n	77b8 <z_sys_mem_pool_base_init+0x28>

0000781c <z_sys_mem_pool_block_alloc>:
	return block;
}

int z_sys_mem_pool_block_alloc(struct sys_mem_pool_base *p, size_t size,
			      u32_t *level_p, u32_t *block_p, void **data_p)
{
    781c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7820:	b087      	sub	sp, #28
	int i, from_l, alloc_l = -1;
	unsigned int key;
	void *data = NULL;
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
    7822:	7a85      	ldrb	r5, [r0, #10]
{
    7824:	af00      	add	r7, sp, #0
    7826:	e9c7 3201 	strd	r3, r2, [r7, #4]
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
    782a:	00ab      	lsls	r3, r5, #2
    782c:	3307      	adds	r3, #7
    782e:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
    7832:	ebad 0d03 	sub.w	sp, sp, r3
    7836:	46ea      	mov	sl, sp
	 * want to allocate and the smallest one with a free entry
	 * from which we can split an allocation if needed.  Along the
	 * way, we populate an array of sizes for each level so we
	 * don't need to waste RAM storing it.
	 */
	lsizes[0] = p->max_sz;
    7838:	4653      	mov	r3, sl
    783a:	6842      	ldr	r2, [r0, #4]
    783c:	f843 2904 	str.w	r2, [r3], #-4
{
    7840:	4604      	mov	r4, r0
	for (i = 0; i < p->n_levels; i++) {
    7842:	2200      	movs	r2, #0
    7844:	4295      	cmp	r5, r2
    7846:	f102 39ff 	add.w	r9, r2, #4294967295	; 0xffffffff
    784a:	dd09      	ble.n	7860 <z_sys_mem_pool_block_alloc+0x44>
		if (i > 0) {
    784c:	b122      	cbz	r2, 7858 <z_sys_mem_pool_block_alloc+0x3c>
			lsizes[i] = WB_DN(lsizes[i-1] / 4);
    784e:	6818      	ldr	r0, [r3, #0]
    7850:	0880      	lsrs	r0, r0, #2
    7852:	f020 0003 	bic.w	r0, r0, #3
    7856:	6058      	str	r0, [r3, #4]
		}

		if (lsizes[i] < size) {
    7858:	f853 0f04 	ldr.w	r0, [r3, #4]!
    785c:	4288      	cmp	r0, r1
    785e:	d208      	bcs.n	7872 <z_sys_mem_pool_block_alloc+0x56>
		}

		alloc_l = i;
	}

	if (alloc_l < 0) {
    7860:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
    7864:	d107      	bne.n	7876 <z_sys_mem_pool_block_alloc+0x5a>
		*data_p = NULL;
    7866:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    7868:	2300      	movs	r3, #0
    786a:	6013      	str	r3, [r2, #0]
	pool_irq_unlock(p, key);

	*data_p = data;

	if (data == NULL) {
		return -ENOMEM;
    786c:	f06f 000b 	mvn.w	r0, #11
    7870:	e044      	b.n	78fc <z_sys_mem_pool_block_alloc+0xe0>
	for (i = 0; i < p->n_levels; i++) {
    7872:	3201      	adds	r2, #1
    7874:	e7e6      	b.n	7844 <z_sys_mem_pool_block_alloc+0x28>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    7876:	7c20      	ldrb	r0, [r4, #16]
    7878:	f010 0001 	ands.w	r0, r0, #1
    787c:	d001      	beq.n	7882 <z_sys_mem_pool_block_alloc+0x66>
    787e:	f7ff ff77 	bl	7770 <pool_irq_lock.isra.2.part.3>
    7882:	68e2      	ldr	r2, [r4, #12]
    7884:	230c      	movs	r3, #12
	key = pool_irq_lock(p);
    7886:	4680      	mov	r8, r0
	for (i = alloc_l; i >= 0; i--) {
    7888:	fb03 2309 	mla	r3, r3, r9, r2
	block = sys_dlist_get(&p->levels[l].free_list);
    788c:	464e      	mov	r6, r9
	return list->head == list;
    788e:	461a      	mov	r2, r3
    7890:	f852 5f04 	ldr.w	r5, [r2, #4]!

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
    7894:	4295      	cmp	r5, r2
    7896:	d06d      	beq.n	7974 <z_sys_mem_pool_block_alloc+0x158>
	node->prev->next = node->next;
    7898:	e9d5 3200 	ldrd	r3, r2, [r5]
    789c:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
    789e:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    78a0:	2300      	movs	r3, #0
	node->prev = NULL;
    78a2:	e9c5 3300 	strd	r3, r3, [r5]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
    78a6:	6823      	ldr	r3, [r4, #0]
		data = block_alloc(p, i, lsizes[i]);
    78a8:	f85a 1026 	ldr.w	r1, [sl, r6, lsl #2]
	int bit = get_bit_ptr(p, level, bn, &word);
    78ac:	f107 0b14 	add.w	fp, r7, #20
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
    78b0:	1aea      	subs	r2, r5, r3
	int bit = get_bit_ptr(p, level, bn, &word);
    78b2:	4620      	mov	r0, r4
    78b4:	fb92 f2f1 	sdiv	r2, r2, r1
    78b8:	465b      	mov	r3, fp
    78ba:	4631      	mov	r1, r6
    78bc:	f7ff ff41 	bl	7742 <get_bit_ptr>
	*word |= (1<<bit);
    78c0:	6979      	ldr	r1, [r7, #20]
    78c2:	2201      	movs	r2, #1
    78c4:	680b      	ldr	r3, [r1, #0]
    78c6:	603a      	str	r2, [r7, #0]
    78c8:	fa02 f000 	lsl.w	r0, r2, r0
    78cc:	4303      	orrs	r3, r0
    78ce:	600b      	str	r3, [r1, #0]
			for (from_l = i; from_l < alloc_l; from_l++) {
    78d0:	454e      	cmp	r6, r9
    78d2:	db17      	blt.n	7904 <z_sys_mem_pool_block_alloc+0xe8>
	pool_irq_unlock(p, key);
    78d4:	4641      	mov	r1, r8
    78d6:	7c20      	ldrb	r0, [r4, #16]
    78d8:	f7ff ff53 	bl	7782 <pool_irq_unlock.isra.4>
	*data_p = data;
    78dc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    78de:	601d      	str	r5, [r3, #0]
	if (data == NULL) {
    78e0:	2d00      	cmp	r5, #0
    78e2:	d0c3      	beq.n	786c <z_sys_mem_pool_block_alloc+0x50>
	}

	*level_p = alloc_l;
    78e4:	68bb      	ldr	r3, [r7, #8]
    78e6:	f8c3 9000 	str.w	r9, [r3]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
    78ea:	6823      	ldr	r3, [r4, #0]
    78ec:	1aed      	subs	r5, r5, r3
    78ee:	f85a 3029 	ldr.w	r3, [sl, r9, lsl #2]
    78f2:	fb95 f5f3 	sdiv	r5, r5, r3
	*block_p = block_num(p, data, lsizes[alloc_l]);
    78f6:	687b      	ldr	r3, [r7, #4]

	return 0;
    78f8:	2000      	movs	r0, #0
	*block_p = block_num(p, data, lsizes[alloc_l]);
    78fa:	601d      	str	r5, [r3, #0]
}
    78fc:	371c      	adds	r7, #28
    78fe:	46bd      	mov	sp, r7
    7900:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
    7904:	6822      	ldr	r2, [r4, #0]
    7906:	f85a 3026 	ldr.w	r3, [sl, r6, lsl #2]
	set_alloc_bit(p, l + 1, 4*bn);
    790a:	3601      	adds	r6, #1
	int bit = get_bit_ptr(p, level, bn, &word);
    790c:	4631      	mov	r1, r6
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
    790e:	1aaa      	subs	r2, r5, r2
	int bit = get_bit_ptr(p, level, bn, &word);
    7910:	4620      	mov	r0, r4
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
    7912:	fb92 f2f3 	sdiv	r2, r2, r3
	int bit = get_bit_ptr(p, level, bn, &word);
    7916:	465b      	mov	r3, fp
    7918:	0092      	lsls	r2, r2, #2
    791a:	f7ff ff12 	bl	7742 <get_bit_ptr>
	*word |= (1<<bit);
    791e:	697a      	ldr	r2, [r7, #20]
    7920:	683b      	ldr	r3, [r7, #0]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
    7922:	68e1      	ldr	r1, [r4, #12]
	*word |= (1<<bit);
    7924:	fa03 f000 	lsl.w	r0, r3, r0
    7928:	6813      	ldr	r3, [r2, #0]
    792a:	4303      	orrs	r3, r0
    792c:	6013      	str	r3, [r2, #0]
		int lsz = lsizes[l + 1];
    792e:	f85a 0026 	ldr.w	r0, [sl, r6, lsl #2]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
    7932:	230c      	movs	r3, #12
    7934:	fb03 1106 	mla	r1, r3, r6, r1
    7938:	2203      	movs	r2, #3
    793a:	f101 0e04 	add.w	lr, r1, #4
    793e:	182b      	adds	r3, r5, r0
    7940:	60fa      	str	r2, [r7, #12]
	node->prev = list->tail;
    7942:	688a      	ldr	r2, [r1, #8]
    7944:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
    7946:	688a      	ldr	r2, [r1, #8]
	node->next = list;
    7948:	f8c3 e000 	str.w	lr, [r3]
	list->tail->next = node;
    794c:	6013      	str	r3, [r2, #0]
	for (i = 1; i < 4; i++) {
    794e:	68fa      	ldr	r2, [r7, #12]
	list->tail = node;
    7950:	608b      	str	r3, [r1, #8]
    7952:	3a01      	subs	r2, #1
    7954:	4403      	add	r3, r0
    7956:	60fa      	str	r2, [r7, #12]
    7958:	d1f3      	bne.n	7942 <z_sys_mem_pool_block_alloc+0x126>
				pool_irq_unlock(p, key);
    795a:	4641      	mov	r1, r8
    795c:	7c20      	ldrb	r0, [r4, #16]
    795e:	f7ff ff10 	bl	7782 <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    7962:	7c23      	ldrb	r3, [r4, #16]
    7964:	07d9      	lsls	r1, r3, #31
    7966:	d503      	bpl.n	7970 <z_sys_mem_pool_block_alloc+0x154>
    7968:	f7ff ff02 	bl	7770 <pool_irq_lock.isra.2.part.3>
				key = pool_irq_lock(p);
    796c:	4680      	mov	r8, r0
    796e:	e7af      	b.n	78d0 <z_sys_mem_pool_block_alloc+0xb4>
		return 0;
    7970:	68f8      	ldr	r0, [r7, #12]
    7972:	e7fb      	b.n	796c <z_sys_mem_pool_block_alloc+0x150>
	for (i = alloc_l; i >= 0; i--) {
    7974:	3e01      	subs	r6, #1
    7976:	1c72      	adds	r2, r6, #1
    7978:	f1a3 030c 	sub.w	r3, r3, #12
    797c:	d187      	bne.n	788e <z_sys_mem_pool_block_alloc+0x72>
    797e:	2500      	movs	r5, #0
    7980:	e7a8      	b.n	78d4 <z_sys_mem_pool_block_alloc+0xb8>

00007982 <z_sys_mem_pool_block_free>:

void z_sys_mem_pool_block_free(struct sys_mem_pool_base *p, u32_t level,
			      u32_t block)
{
    7982:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7986:	b085      	sub	sp, #20
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
    7988:	7a83      	ldrb	r3, [r0, #10]
    798a:	009b      	lsls	r3, r3, #2
    798c:	3307      	adds	r3, #7
    798e:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
{
    7992:	af00      	add	r7, sp, #0
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
    7994:	ebad 0d03 	sub.w	sp, sp, r3
    7998:	46eb      	mov	fp, sp
	 * to avoid having to store it in precious RAM bytes.
	 * Overhead here is somewhat higher because block_free()
	 * doesn't inherently need to traverse all the larger
	 * sublevels.
	 */
	lsizes[0] = p->max_sz;
    799a:	6843      	ldr	r3, [r0, #4]
    799c:	f8cb 3000 	str.w	r3, [fp]
{
    79a0:	4606      	mov	r6, r0
	for (i = 1; i <= level; i++) {
    79a2:	465c      	mov	r4, fp
    79a4:	2001      	movs	r0, #1
    79a6:	4281      	cmp	r1, r0
    79a8:	d215      	bcs.n	79d6 <z_sys_mem_pool_block_free+0x54>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    79aa:	7c30      	ldrb	r0, [r6, #16]
    79ac:	f010 0001 	ands.w	r0, r0, #1
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
	}

	block_free(p, level, lsizes, block);
    79b0:	4688      	mov	r8, r1
    79b2:	4615      	mov	r5, r2
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    79b4:	d001      	beq.n	79ba <z_sys_mem_pool_block_free+0x38>
    79b6:	f7ff fedb 	bl	7770 <pool_irq_lock.isra.2.part.3>
	unsigned int key = pool_irq_lock(p);
    79ba:	4604      	mov	r4, r0
	while (level >= 0) {
    79bc:	f1b8 0f00 	cmp.w	r8, #0
    79c0:	da11      	bge.n	79e6 <z_sys_mem_pool_block_free+0x64>
	return -1;
    79c2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	pool_irq_unlock(p, key);
    79c6:	4621      	mov	r1, r4
    79c8:	7c30      	ldrb	r0, [r6, #16]
    79ca:	f7ff feda 	bl	7782 <pool_irq_unlock.isra.4>
}
    79ce:	3714      	adds	r7, #20
    79d0:	46bd      	mov	sp, r7
    79d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
    79d6:	6823      	ldr	r3, [r4, #0]
    79d8:	089b      	lsrs	r3, r3, #2
    79da:	f023 0303 	bic.w	r3, r3, #3
    79de:	f844 3f04 	str.w	r3, [r4, #4]!
	for (i = 1; i <= level; i++) {
    79e2:	3001      	adds	r0, #1
    79e4:	e7df      	b.n	79a6 <z_sys_mem_pool_block_free+0x24>
		int i, lsz = lsizes[level];
    79e6:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
    79ea:	607b      	str	r3, [r7, #4]
	return (u8_t *)p->buf + lsz * block;
    79ec:	fb03 fa05 	mul.w	sl, r3, r5
    79f0:	6833      	ldr	r3, [r6, #0]
    79f2:	603b      	str	r3, [r7, #0]
    79f4:	eb03 090a 	add.w	r9, r3, sl
	int bit = get_bit_ptr(p, level, bn, &word);
    79f8:	462a      	mov	r2, r5
    79fa:	f107 030c 	add.w	r3, r7, #12
    79fe:	4641      	mov	r1, r8
    7a00:	4630      	mov	r0, r6
    7a02:	f7ff fe9e 	bl	7742 <get_bit_ptr>
	*word &= ~(1<<bit);
    7a06:	68fa      	ldr	r2, [r7, #12]
	node->next = list;
    7a08:	6839      	ldr	r1, [r7, #0]
    7a0a:	2301      	movs	r3, #1
    7a0c:	fa03 f000 	lsl.w	r0, r3, r0
    7a10:	6813      	ldr	r3, [r2, #0]
    7a12:	ea23 0300 	bic.w	r3, r3, r0
    7a16:	6013      	str	r3, [r2, #0]
		sys_dlist_append(&p->levels[level].free_list, block);
    7a18:	68f3      	ldr	r3, [r6, #12]
    7a1a:	220c      	movs	r2, #12
    7a1c:	fb02 3308 	mla	r3, r2, r8, r3
    7a20:	1d1a      	adds	r2, r3, #4
    7a22:	f841 200a 	str.w	r2, [r1, sl]
	node->prev = list->tail;
    7a26:	689a      	ldr	r2, [r3, #8]
    7a28:	f8c9 2004 	str.w	r2, [r9, #4]
	list->tail->next = node;
    7a2c:	689a      	ldr	r2, [r3, #8]
    7a2e:	f8c2 9000 	str.w	r9, [r2]
	list->tail = node;
    7a32:	f8c3 9008 	str.w	r9, [r3, #8]
		pool_irq_unlock(p, key);
    7a36:	7c30      	ldrb	r0, [r6, #16]
    7a38:	4621      	mov	r1, r4
    7a3a:	f7ff fea2 	bl	7782 <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    7a3e:	7c30      	ldrb	r0, [r6, #16]
    7a40:	f010 0001 	ands.w	r0, r0, #1
    7a44:	d001      	beq.n	7a4a <z_sys_mem_pool_block_free+0xc8>
    7a46:	f7ff fe93 	bl	7770 <pool_irq_lock.isra.2.part.3>
		key = pool_irq_lock(p);
    7a4a:	4604      	mov	r4, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
    7a4c:	f1b8 0f00 	cmp.w	r8, #0
    7a50:	d0b9      	beq.n	79c6 <z_sys_mem_pool_block_free+0x44>
	int bit = get_bit_ptr(p, level, bn, &word);
    7a52:	f107 030c 	add.w	r3, r7, #12
    7a56:	462a      	mov	r2, r5
    7a58:	4641      	mov	r1, r8
    7a5a:	4630      	mov	r0, r6
    7a5c:	f7ff fe71 	bl	7742 <get_bit_ptr>
	return (*word >> (4*(bit / 4))) & 0xf;
    7a60:	68fb      	ldr	r3, [r7, #12]
    7a62:	2800      	cmp	r0, #0
    7a64:	bfb8      	it	lt
    7a66:	3003      	addlt	r0, #3
    7a68:	681b      	ldr	r3, [r3, #0]
    7a6a:	f020 0003 	bic.w	r0, r0, #3
    7a6e:	fa23 f000 	lsr.w	r0, r3, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
    7a72:	f010 000f 	ands.w	r0, r0, #15
    7a76:	d1a6      	bne.n	79c6 <z_sys_mem_pool_block_free+0x44>
			int b = (bn & ~3) + i;
    7a78:	f025 0a03 	bic.w	sl, r5, #3
	node->next = NULL;
    7a7c:	4684      	mov	ip, r0
	return (u8_t *)p->buf + lsz * block;
    7a7e:	687a      	ldr	r2, [r7, #4]
			int b = (bn & ~3) + i;
    7a80:	eb0a 0300 	add.w	r3, sl, r0
	return (u8_t *)p->buf + lsz * block;
    7a84:	4353      	muls	r3, r2
    7a86:	6832      	ldr	r2, [r6, #0]
    7a88:	18d1      	adds	r1, r2, r3
	node->prev->next = node->next;
    7a8a:	f852 e003 	ldr.w	lr, [r2, r3]
    7a8e:	f8d1 9004 	ldr.w	r9, [r1, #4]
		for (i = 0; i < 4; i++) {
    7a92:	3001      	adds	r0, #1
    7a94:	2804      	cmp	r0, #4
    7a96:	f8c9 e000 	str.w	lr, [r9]
	node->next->prev = node->prev;
    7a9a:	f8ce 9004 	str.w	r9, [lr, #4]
	node->next = NULL;
    7a9e:	f842 c003 	str.w	ip, [r2, r3]
	node->prev = NULL;
    7aa2:	f8c1 c004 	str.w	ip, [r1, #4]
    7aa6:	d1ea      	bne.n	7a7e <z_sys_mem_pool_block_free+0xfc>
		bn = bn / 4;
    7aa8:	2d00      	cmp	r5, #0
    7aaa:	bfb8      	it	lt
    7aac:	3503      	addlt	r5, #3
		level = level - 1;
    7aae:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
		bn = bn / 4;
    7ab2:	10ad      	asrs	r5, r5, #2
    7ab4:	e782      	b.n	79bc <z_sys_mem_pool_block_free+0x3a>

00007ab6 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    7ab6:	4604      	mov	r4, r0
    7ab8:	b508      	push	{r3, lr}
    7aba:	4608      	mov	r0, r1
    7abc:	4611      	mov	r1, r2
	entry(p1, p2, p3);
    7abe:	461a      	mov	r2, r3
    7ac0:	47a0      	blx	r4
	return z_impl_k_current_get();
    7ac2:	f7ff fbbf 	bl	7244 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
    7ac6:	f7f9 ff2f 	bl	1928 <z_impl_k_thread_abort>

00007aca <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    7aca:	4770      	bx	lr

00007acc <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
    7acc:	2300      	movs	r3, #0
	list->head = NULL;
    7ace:	e9c0 3300 	strd	r3, r3, [r0]
}
    7ad2:	4770      	bx	lr

00007ad4 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
    7ad4:	6803      	ldr	r3, [r0, #0]
    7ad6:	b923      	cbnz	r3, 7ae2 <log_list_add_tail+0xe>
		list->head = msg;
    7ad8:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
    7ada:	2300      	movs	r3, #0
	list->tail = msg;
    7adc:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
    7ade:	600b      	str	r3, [r1, #0]
}
    7ae0:	4770      	bx	lr
		list->tail->next = msg;
    7ae2:	6843      	ldr	r3, [r0, #4]
    7ae4:	6019      	str	r1, [r3, #0]
    7ae6:	e7f8      	b.n	7ada <log_list_add_tail+0x6>

00007ae8 <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
    7ae8:	6800      	ldr	r0, [r0, #0]
    7aea:	4770      	bx	lr

00007aec <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
	struct log_msg *msg = list->head;
    7aec:	6803      	ldr	r3, [r0, #0]

	if (list->head != NULL) {
    7aee:	b10b      	cbz	r3, 7af4 <log_list_head_get+0x8>
		list->head = list->head->next;
    7af0:	681a      	ldr	r2, [r3, #0]
    7af2:	6002      	str	r2, [r0, #0]
	}

	return msg;
}
    7af4:	4618      	mov	r0, r3
    7af6:	4770      	bx	lr

00007af8 <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
    7af8:	b508      	push	{r3, lr}
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    7afa:	f7f8 ffcd 	bl	a98 <log_msg_chunk_alloc>

	if (msg != NULL) {
    7afe:	b118      	cbz	r0, 7b08 <z_log_msg_std_alloc+0x10>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
    7b00:	2301      	movs	r3, #1
    7b02:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    7b04:	2300      	movs	r3, #0
    7b06:	8103      	strh	r3, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
	}

	return msg;
}
    7b08:	bd08      	pop	{r3, pc}

00007b0a <k_cycle_get_32_wrapper>:
#ifndef _ASMLANGUAGE
extern u32_t z_timer_cycle_get_32(void);

static inline u32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
    7b0a:	f7f9 bad3 	b.w	10b4 <z_timer_cycle_get_32>

00007b0e <dummy_timestamp>:
    7b0e:	2000      	movs	r0, #0
    7b10:	4770      	bx	lr

00007b12 <z_log_get_s_mask>:
	u32_t mask = 0;
    7b12:	2300      	movs	r3, #0
{
    7b14:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32_t arg = 0;
    7b16:	461a      	mov	r2, r3
	bool arm = false;
    7b18:	461c      	mov	r4, r3
				mask |= BIT(arg);
    7b1a:	2701      	movs	r7, #1
	while ((curr = *str++) && arg < nargs) {
    7b1c:	f810 5b01 	ldrb.w	r5, [r0], #1
    7b20:	b10d      	cbz	r5, 7b26 <z_log_get_s_mask+0x14>
    7b22:	428a      	cmp	r2, r1
    7b24:	d301      	bcc.n	7b2a <z_log_get_s_mask+0x18>
}
    7b26:	4618      	mov	r0, r3
    7b28:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (curr == '%') {
    7b2a:	2d25      	cmp	r5, #37	; 0x25
    7b2c:	d102      	bne.n	7b34 <z_log_get_s_mask+0x22>
			arm = !arm;
    7b2e:	f084 0401 	eor.w	r4, r4, #1
    7b32:	e7f3      	b.n	7b1c <z_log_get_s_mask+0xa>
		} else if (arm && isalpha((int)curr)) {
    7b34:	2c00      	cmp	r4, #0
    7b36:	d0f1      	beq.n	7b1c <z_log_get_s_mask+0xa>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    7b38:	f045 0620 	orr.w	r6, r5, #32
    7b3c:	3e61      	subs	r6, #97	; 0x61
    7b3e:	2e19      	cmp	r6, #25
    7b40:	d8ec      	bhi.n	7b1c <z_log_get_s_mask+0xa>
			if (curr == 's') {
    7b42:	2d73      	cmp	r5, #115	; 0x73
				mask |= BIT(arg);
    7b44:	bf04      	itt	eq
    7b46:	fa07 f402 	lsleq.w	r4, r7, r2
    7b4a:	4323      	orreq	r3, r4
			arg++;
    7b4c:	3201      	adds	r2, #1
			arm = false;
    7b4e:	2400      	movs	r4, #0
    7b50:	e7e4      	b.n	7b1c <z_log_get_s_mask+0xa>

00007b52 <log_0>:
{
    7b52:	b538      	push	{r3, r4, r5, lr}
    7b54:	4605      	mov	r5, r0
    7b56:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
    7b58:	f7ff ffce 	bl	7af8 <z_log_msg_std_alloc>

	if (msg != NULL) {
    7b5c:	b128      	cbz	r0, 7b6a <log_0+0x18>
		msg->str = str;
    7b5e:	6105      	str	r5, [r0, #16]
		msg_finalize(msg, src_level);
    7b60:	4621      	mov	r1, r4
}
    7b62:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		msg_finalize(msg, src_level);
    7b66:	f7f8 beb9 	b.w	8dc <msg_finalize>
}
    7b6a:	bd38      	pop	{r3, r4, r5, pc}

00007b6c <log_1>:
{
    7b6c:	b570      	push	{r4, r5, r6, lr}
    7b6e:	4604      	mov	r4, r0
    7b70:	460e      	mov	r6, r1
    7b72:	4615      	mov	r5, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    7b74:	f7ff ffc0 	bl	7af8 <z_log_msg_std_alloc>

	if (msg != NULL) {
    7b78:	b158      	cbz	r0, 7b92 <log_1+0x26>
		msg->str = str;
    7b7a:	6104      	str	r4, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
    7b7c:	7a44      	ldrb	r4, [r0, #9]
		msg->payload.single.args[0] = arg1;
    7b7e:	6146      	str	r6, [r0, #20]
		msg->hdr.params.std.nargs = 1U;
    7b80:	2201      	movs	r2, #1
    7b82:	f362 1407 	bfi	r4, r2, #4, #4
    7b86:	7244      	strb	r4, [r0, #9]
		msg_finalize(msg, src_level);
    7b88:	4629      	mov	r1, r5
}
    7b8a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		msg_finalize(msg, src_level);
    7b8e:	f7f8 bea5 	b.w	8dc <msg_finalize>
}
    7b92:	bd70      	pop	{r4, r5, r6, pc}

00007b94 <log_2>:
{
    7b94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7b98:	4605      	mov	r5, r0
    7b9a:	4688      	mov	r8, r1
    7b9c:	4617      	mov	r7, r2
    7b9e:	461e      	mov	r6, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    7ba0:	f7ff ffaa 	bl	7af8 <z_log_msg_std_alloc>

	if (msg != NULL) {
    7ba4:	b160      	cbz	r0, 7bc0 <log_2+0x2c>
		msg->str = str;
    7ba6:	6105      	str	r5, [r0, #16]
		msg->hdr.params.std.nargs = 2U;
    7ba8:	7a45      	ldrb	r5, [r0, #9]
    7baa:	2302      	movs	r3, #2
    7bac:	f363 1507 	bfi	r5, r3, #4, #4
    7bb0:	7245      	strb	r5, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
    7bb2:	e9c0 8705 	strd	r8, r7, [r0, #20]
		msg_finalize(msg, src_level);
    7bb6:	4631      	mov	r1, r6
}
    7bb8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		msg_finalize(msg, src_level);
    7bbc:	f7f8 be8e 	b.w	8dc <msg_finalize>
}
    7bc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007bc4 <log_3>:
{
    7bc4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    7bc8:	4605      	mov	r5, r0
    7bca:	4689      	mov	r9, r1
    7bcc:	4690      	mov	r8, r2
    7bce:	461f      	mov	r7, r3
    7bd0:	f8bd 6020 	ldrh.w	r6, [sp, #32]
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    7bd4:	f7ff ff90 	bl	7af8 <z_log_msg_std_alloc>

	if (msg != NULL) {
    7bd8:	b168      	cbz	r0, 7bf6 <log_3+0x32>
		msg->str = str;
    7bda:	6105      	str	r5, [r0, #16]
		msg->hdr.params.std.nargs = 3U;
    7bdc:	7a45      	ldrb	r5, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
		msg->payload.single.args[2] = arg3;
    7bde:	61c7      	str	r7, [r0, #28]
		msg->hdr.params.std.nargs = 3U;
    7be0:	2303      	movs	r3, #3
    7be2:	f363 1507 	bfi	r5, r3, #4, #4
    7be6:	7245      	strb	r5, [r0, #9]
		msg->payload.single.args[1] = arg2;
    7be8:	e9c0 9805 	strd	r9, r8, [r0, #20]
		msg_finalize(msg, src_level);
    7bec:	4631      	mov	r1, r6
}
    7bee:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		msg_finalize(msg, src_level);
    7bf2:	f7f8 be73 	b.w	8dc <msg_finalize>
}
    7bf6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00007bfa <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
    7bfa:	7a40      	ldrb	r0, [r0, #9]
}
    7bfc:	0900      	lsrs	r0, r0, #4
    7bfe:	4770      	bx	lr

00007c00 <log_msg_arg_get>:
log_arg_t log_msg_arg_get(struct log_msg *msg, u32_t arg_idx)
{
	log_arg_t arg;

	/* Return early if requested argument not present in the message. */
	if (arg_idx >= msg->hdr.params.std.nargs) {
    7c00:	7a43      	ldrb	r3, [r0, #9]
    7c02:	091b      	lsrs	r3, r3, #4
    7c04:	428b      	cmp	r3, r1
    7c06:	d916      	bls.n	7c36 <log_msg_arg_get+0x36>
		return 0;
	}

	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
    7c08:	2b03      	cmp	r3, #3
    7c0a:	d803      	bhi.n	7c14 <log_msg_arg_get+0x14>
		arg = msg->payload.single.args[arg_idx];
    7c0c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    7c10:	6948      	ldr	r0, [r1, #20]
    7c12:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
    7c14:	2901      	cmp	r1, #1
    7c16:	d803      	bhi.n	7c20 <log_msg_arg_get+0x20>
		return msg->payload.ext.data.args[arg_idx];
    7c18:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    7c1c:	6988      	ldr	r0, [r1, #24]
    7c1e:	4770      	bx	lr
	cont = msg->payload.ext.next;
    7c20:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
    7c22:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
    7c24:	2906      	cmp	r1, #6
    7c26:	d803      	bhi.n	7c30 <log_msg_arg_get+0x30>
	return cont->payload.args[arg_idx];
    7c28:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    7c2c:	6848      	ldr	r0, [r1, #4]
    7c2e:	4770      	bx	lr
		arg_idx -= ARGS_CONT_MSG;
    7c30:	3907      	subs	r1, #7
		cont = cont->next;
    7c32:	681b      	ldr	r3, [r3, #0]
    7c34:	e7f6      	b.n	7c24 <log_msg_arg_get+0x24>
		return 0;
    7c36:	2000      	movs	r0, #0
	} else {
		arg = cont_arg_get(msg, arg_idx);
	}

	return arg;
}
    7c38:	4770      	bx	lr

00007c3a <log_msg_put>:
{
    7c3a:	4603      	mov	r3, r0
    7c3c:	1d02      	adds	r2, r0, #4
    7c3e:	f3bf 8f5b 	dmb	ish
    7c42:	e852 1f00 	ldrex	r1, [r2]
    7c46:	3901      	subs	r1, #1
    7c48:	e842 1c00 	strex	ip, r1, [r2]
    7c4c:	f1bc 0f00 	cmp.w	ip, #0
    7c50:	d1f7      	bne.n	7c42 <log_msg_put+0x8>
    7c52:	f3bf 8f5b 	dmb	ish
	if (msg->hdr.ref_cnt == 0) {
    7c56:	685b      	ldr	r3, [r3, #4]
    7c58:	b90b      	cbnz	r3, 7c5e <log_msg_put+0x24>
		msg_free(msg);
    7c5a:	f7f8 bf2f 	b.w	abc <msg_free>
}
    7c5e:	4770      	bx	lr

00007c60 <log_msg_str_get>:

const char *log_msg_str_get(struct log_msg *msg)
{
	return msg->str;
}
    7c60:	6900      	ldr	r0, [r0, #16]
    7c62:	4770      	bx	lr

00007c64 <get_status>:
	data = get_sub_data(dev, type);
    7c64:	6883      	ldr	r3, [r0, #8]
	return &data->subsys[type];
    7c66:	b2c9      	uxtb	r1, r1
	if (data->started) {
    7c68:	220c      	movs	r2, #12
    7c6a:	fb02 3101 	mla	r1, r2, r1, r3
    7c6e:	7a4b      	ldrb	r3, [r1, #9]
    7c70:	b923      	cbnz	r3, 7c7c <get_status+0x18>
	if (data->ref > 0) {
    7c72:	7a08      	ldrb	r0, [r1, #8]
		return CLOCK_CONTROL_STATUS_ON;
    7c74:	fab0 f080 	clz	r0, r0
    7c78:	0940      	lsrs	r0, r0, #5
    7c7a:	4770      	bx	lr
    7c7c:	2002      	movs	r0, #2
}
    7c7e:	4770      	bx	lr

00007c80 <clkstarted_handle>:
{
    7c80:	b538      	push	{r3, r4, r5, lr}
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
    7c82:	6883      	ldr	r3, [r0, #8]
	sub_data->started = true;
    7c84:	240c      	movs	r4, #12
    7c86:	fb04 3401 	mla	r4, r4, r1, r3
    7c8a:	2301      	movs	r3, #1
{
    7c8c:	4605      	mov	r5, r0
	sub_data->started = true;
    7c8e:	7263      	strb	r3, [r4, #9]
	__asm__ volatile(
    7c90:	f04f 0320 	mov.w	r3, #32
    7c94:	f3ef 8111 	mrs	r1, BASEPRI
    7c98:	f383 8811 	msr	BASEPRI, r3
    7c9c:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
    7ca0:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    7ca2:	b12b      	cbz	r3, 7cb0 <clkstarted_handle+0x30>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    7ca4:	6860      	ldr	r0, [r4, #4]
    7ca6:	681a      	ldr	r2, [r3, #0]
	list->head = node;
    7ca8:	6022      	str	r2, [r4, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    7caa:	4283      	cmp	r3, r0
	list->tail = node;
    7cac:	bf08      	it	eq
    7cae:	6062      	streq	r2, [r4, #4]
	__asm__ volatile(
    7cb0:	f381 8811 	msr	BASEPRI, r1
    7cb4:	f3bf 8f6f 	isb	sy
	while ((async_data = list_get(&sub_data->list)) != NULL) {
    7cb8:	b903      	cbnz	r3, 7cbc <clkstarted_handle+0x3c>
}
    7cba:	bd38      	pop	{r3, r4, r5, pc}
		async_data->cb(dev, async_data->user_data);
    7cbc:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
    7cc0:	4628      	mov	r0, r5
    7cc2:	4790      	blx	r2
    7cc4:	e7e4      	b.n	7c90 <clkstarted_handle+0x10>

00007cc6 <clock_async_start>:
	const struct nrf_clock_control_config *config =
    7cc6:	6803      	ldr	r3, [r0, #0]
	clk_data = get_sub_data(dev, type);
    7cc8:	f8d0 c008 	ldr.w	ip, [r0, #8]
{
    7ccc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7cd0:	4605      	mov	r5, r0
	const struct nrf_clock_control_config *config =
    7cd2:	689f      	ldr	r7, [r3, #8]
	return &config->subsys[type];
    7cd4:	b2ce      	uxtb	r6, r1
	if ((data != NULL)
    7cd6:	b14a      	cbz	r2, 7cec <clock_async_start+0x26>
	sys_snode_t *item = sys_slist_peek_head(list);
    7cd8:	230c      	movs	r3, #12
    7cda:	4373      	muls	r3, r6
    7cdc:	f85c 3003 	ldr.w	r3, [ip, r3]
		if (item == node) {
    7ce0:	429a      	cmp	r2, r3
    7ce2:	d05b      	beq.n	7d9c <clock_async_start+0xd6>
Z_GENLIST_PEEK_NEXT(slist, snode)
    7ce4:	b113      	cbz	r3, 7cec <clock_async_start+0x26>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    7ce6:	681b      	ldr	r3, [r3, #0]
	} while (item);
    7ce8:	2b00      	cmp	r3, #0
    7cea:	d1f9      	bne.n	7ce0 <clock_async_start+0x1a>
	__asm__ volatile(
    7cec:	f04f 0320 	mov.w	r3, #32
    7cf0:	f3ef 8011 	mrs	r0, BASEPRI
    7cf4:	f383 8811 	msr	BASEPRI, r3
    7cf8:	f3bf 8f6f 	isb	sy
	ref = ++clk_data->ref;
    7cfc:	210c      	movs	r1, #12
    7cfe:	4371      	muls	r1, r6
    7d00:	eb0c 0301 	add.w	r3, ip, r1
    7d04:	7a1c      	ldrb	r4, [r3, #8]
    7d06:	3401      	adds	r4, #1
    7d08:	b2e4      	uxtb	r4, r4
    7d0a:	721c      	strb	r4, [r3, #8]
	__asm__ volatile(
    7d0c:	f380 8811 	msr	BASEPRI, r0
    7d10:	f3bf 8f6f 	isb	sy
	if (data) {
    7d14:	b332      	cbz	r2, 7d64 <clock_async_start+0x9e>
    p_reg->INTENCLR = mask;
    7d16:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
    7d1a:	f04f 0e03 	mov.w	lr, #3
    7d1e:	f8c0 e308 	str.w	lr, [r0, #776]	; 0x308
		already_started = clk_data->started;
    7d22:	7a58      	ldrb	r0, [r3, #9]
		if (!already_started) {
    7d24:	b9a0      	cbnz	r0, 7d50 <clock_async_start+0x8a>
	__asm__ volatile(
    7d26:	f04f 0e20 	mov.w	lr, #32
    7d2a:	f3ef 8811 	mrs	r8, BASEPRI
    7d2e:	f38e 8811 	msr	BASEPRI, lr
    7d32:	f3bf 8f6f 	isb	sy
	parent->next = child;
    7d36:	6010      	str	r0, [r2, #0]
Z_GENLIST_APPEND(slist, snode)
    7d38:	f8d3 e004 	ldr.w	lr, [r3, #4]
    7d3c:	f1be 0f00 	cmp.w	lr, #0
    7d40:	d11f      	bne.n	7d82 <clock_async_start+0xbc>
	list->tail = node;
    7d42:	605a      	str	r2, [r3, #4]
	list->head = node;
    7d44:	f84c 2001 	str.w	r2, [ip, r1]
	__asm__ volatile(
    7d48:	f388 8811 	msr	BASEPRI, r8
    7d4c:	f3bf 8f6f 	isb	sy
    p_reg->INTENSET = mask;
    7d50:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    7d54:	2103      	movs	r1, #3
    7d56:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304
		if (already_started) {
    7d5a:	b118      	cbz	r0, 7d64 <clock_async_start+0x9e>
			data->cb(dev, data->user_data);
    7d5c:	e9d2 3101 	ldrd	r3, r1, [r2, #4]
    7d60:	4628      	mov	r0, r5
    7d62:	4798      	blx	r3
	if (ref == 1) {
    7d64:	2c01      	cmp	r4, #1
    7d66:	d10a      	bne.n	7d7e <clock_async_start+0xb8>
		do_start =  (config->start_handler) ?
    7d68:	ea4f 1806 	mov.w	r8, r6, lsl #4
    7d6c:	f857 3008 	ldr.w	r3, [r7, r8]
				config->start_handler(dev) : true;
    7d70:	b95b      	cbnz	r3, 7d8a <clock_async_start+0xc4>
			nrf_clock_task_trigger(NRF_CLOCK,
    7d72:	4447      	add	r7, r8
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    7d74:	2201      	movs	r2, #1
    7d76:	7abb      	ldrb	r3, [r7, #10]
    7d78:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    7d7c:	601a      	str	r2, [r3, #0]
	return 0;
    7d7e:	2000      	movs	r0, #0
    7d80:	e00e      	b.n	7da0 <clock_async_start+0xda>
	parent->next = child;
    7d82:	f8ce 2000 	str.w	r2, [lr]
	list->tail = node;
    7d86:	605a      	str	r2, [r3, #4]
    7d88:	e7de      	b.n	7d48 <clock_async_start+0x82>
				config->start_handler(dev) : true;
    7d8a:	4628      	mov	r0, r5
    7d8c:	4798      	blx	r3
    7d8e:	2800      	cmp	r0, #0
    7d90:	d1ef      	bne.n	7d72 <clock_async_start+0xac>
			clkstarted_handle(dev, type);
    7d92:	4631      	mov	r1, r6
    7d94:	4628      	mov	r0, r5
    7d96:	f7ff ff73 	bl	7c80 <clkstarted_handle>
    7d9a:	e7f0      	b.n	7d7e <clock_async_start+0xb8>
		return -EBUSY;
    7d9c:	f06f 000f 	mvn.w	r0, #15
}
    7da0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007da4 <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
    7da4:	2200      	movs	r2, #0
    7da6:	f7ff bf8e 	b.w	7cc6 <clock_async_start>

00007daa <clk_init>:
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
    7daa:	2200      	movs	r2, #0
{
    7dac:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
    7dae:	2101      	movs	r1, #1
{
    7db0:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
    7db2:	4610      	mov	r0, r2
    7db4:	f7f9 fa0a 	bl	11cc <z_arm_irq_priority_set>
	irq_enable(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0);
    7db8:	2000      	movs	r0, #0
    7dba:	f7f9 f9f7 	bl	11ac <arch_irq_enable>
}

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->LFCLKSRC = (uint32_t)(source);
    7dbe:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    7dc2:	2201      	movs	r2, #1
    7dc4:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    p_reg->INTENSET = mask;
    7dc8:	2203      	movs	r2, #3
    7dca:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		sys_slist_init(&(get_sub_data(dev, i)->list));
    7dce:	68a3      	ldr	r3, [r4, #8]
	list->head = NULL;
    7dd0:	2000      	movs	r0, #0
	list->tail = NULL;
    7dd2:	e9c3 0000 	strd	r0, r0, [r3]
    7dd6:	68a3      	ldr	r3, [r4, #8]
    7dd8:	e9c3 0003 	strd	r0, r0, [r3, #12]
}
    7ddc:	bd10      	pop	{r4, pc}

00007dde <clock_stop>:
	const struct nrf_clock_control_config *config =
    7dde:	6802      	ldr	r2, [r0, #0]
{
    7de0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	const struct nrf_clock_control_config *config =
    7de4:	f8d2 8008 	ldr.w	r8, [r2, #8]
	data = get_sub_data(dev, type);
    7de8:	6887      	ldr	r7, [r0, #8]
    7dea:	b2cc      	uxtb	r4, r1
	__asm__ volatile(
    7dec:	f04f 0320 	mov.w	r3, #32
    7df0:	f3ef 8611 	mrs	r6, BASEPRI
    7df4:	f383 8811 	msr	BASEPRI, r3
    7df8:	f3bf 8f6f 	isb	sy
	if (data->ref == 0) {
    7dfc:	220c      	movs	r2, #12
    7dfe:	4362      	muls	r2, r4
    7e00:	18b9      	adds	r1, r7, r2
    7e02:	7a0b      	ldrb	r3, [r1, #8]
    7e04:	b343      	cbz	r3, 7e58 <clock_stop+0x7a>
	data->ref--;
    7e06:	3b01      	subs	r3, #1
    7e08:	b2db      	uxtb	r3, r3
    7e0a:	720b      	strb	r3, [r1, #8]
	if (data->ref == 0) {
    7e0c:	bb3b      	cbnz	r3, 7e5e <clock_stop+0x80>
		do_stop =  (config->stop_handler) ?
    7e0e:	0125      	lsls	r5, r4, #4
	list->head = NULL;
    7e10:	50bb      	str	r3, [r7, r2]
	list->tail = NULL;
    7e12:	604b      	str	r3, [r1, #4]
    7e14:	eb08 0305 	add.w	r3, r8, r5
    7e18:	685b      	ldr	r3, [r3, #4]
				config->stop_handler(dev) : true;
    7e1a:	b9cb      	cbnz	r3, 7e50 <clock_stop+0x72>
			nrf_clock_task_trigger(NRF_CLOCK, config->stop_tsk);
    7e1c:	4445      	add	r5, r8
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    7e1e:	2201      	movs	r2, #1
    7e20:	7aeb      	ldrb	r3, [r5, #11]
    7e22:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    7e26:	601a      	str	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    7e28:	892b      	ldrh	r3, [r5, #8]
    7e2a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    7e2e:	2200      	movs	r2, #0
    7e30:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    7e32:	681b      	ldr	r3, [r3, #0]
    7e34:	9301      	str	r3, [sp, #4]
    (void)dummy;
    7e36:	9b01      	ldr	r3, [sp, #4]
		data->started = false;
    7e38:	210c      	movs	r1, #12
    7e3a:	fb01 7404 	mla	r4, r1, r4, r7
    7e3e:	2000      	movs	r0, #0
    7e40:	7260      	strb	r0, [r4, #9]
	__asm__ volatile(
    7e42:	f386 8811 	msr	BASEPRI, r6
    7e46:	f3bf 8f6f 	isb	sy
}
    7e4a:	b002      	add	sp, #8
    7e4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				config->stop_handler(dev) : true;
    7e50:	4798      	blx	r3
    7e52:	2800      	cmp	r0, #0
    7e54:	d1e2      	bne.n	7e1c <clock_stop+0x3e>
    7e56:	e7ef      	b.n	7e38 <clock_stop+0x5a>
		err = -EALREADY;
    7e58:	f06f 0044 	mvn.w	r0, #68	; 0x44
    7e5c:	e7f1      	b.n	7e42 <clock_stop+0x64>
	int err = 0;
    7e5e:	2000      	movs	r0, #0
    7e60:	e7ef      	b.n	7e42 <clock_stop+0x64>

00007e62 <st7789v_read>:
}
    7e62:	f06f 0022 	mvn.w	r0, #34	; 0x22
    7e66:	4770      	bx	lr

00007e68 <st7789v_get_framebuffer>:
}
    7e68:	2000      	movs	r0, #0
    7e6a:	4770      	bx	lr

00007e6c <st7789v_set_brightness>:
}
    7e6c:	f06f 0022 	mvn.w	r0, #34	; 0x22
    7e70:	4770      	bx	lr

00007e72 <k_sleep>:
	return z_impl_k_sleep(ms);
    7e72:	f7ff b9bf 	b.w	71f4 <z_impl_k_sleep>

00007e76 <st7789v_get_capabilities>:
{
    7e76:	b538      	push	{r3, r4, r5, lr}
    7e78:	460c      	mov	r4, r1
	struct st7789v_data *data = (struct st7789v_data *)dev->driver_data;
    7e7a:	6885      	ldr	r5, [r0, #8]
	memset(capabilities, 0, sizeof(struct display_capabilities));
    7e7c:	2210      	movs	r2, #16
    7e7e:	2100      	movs	r1, #0
    7e80:	4620      	mov	r0, r4
    7e82:	f000 f93d 	bl	8100 <memset>
	capabilities->x_resolution = data->width;
    7e86:	8ceb      	ldrh	r3, [r5, #38]	; 0x26
    7e88:	8023      	strh	r3, [r4, #0]
	capabilities->y_resolution = data->height;
    7e8a:	8cab      	ldrh	r3, [r5, #36]	; 0x24
    7e8c:	8063      	strh	r3, [r4, #2]
	capabilities->supported_pixel_formats = PIXEL_FORMAT_RGB_565;
    7e8e:	2310      	movs	r3, #16
    7e90:	6063      	str	r3, [r4, #4]
	capabilities->current_pixel_format = PIXEL_FORMAT_RGB_565;
    7e92:	81a3      	strh	r3, [r4, #12]
}
    7e94:	bd38      	pop	{r3, r4, r5, pc}

00007e96 <gpio_pin_write>:
 * @param value Value set on the pin.
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_write(struct device *port, u32_t pin,
				 u32_t value)
{
    7e96:	b410      	push	{r4}
    7e98:	4613      	mov	r3, r2
	return api->write(port, access_op, pin, value);
    7e9a:	6842      	ldr	r2, [r0, #4]
    7e9c:	6854      	ldr	r4, [r2, #4]
    7e9e:	460a      	mov	r2, r1
    7ea0:	46a4      	mov	ip, r4
    7ea2:	2100      	movs	r1, #0
	return gpio_write(port, GPIO_ACCESS_BY_PIN, pin, value);
}
    7ea4:	bc10      	pop	{r4}
	return api->write(port, access_op, pin, value);
    7ea6:	4760      	bx	ip

00007ea8 <st7789v_set_contrast>:
    7ea8:	f06f 0022 	mvn.w	r0, #34	; 0x22
    7eac:	4770      	bx	lr

00007eae <st7789v_transmit>:
{
    7eae:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    7eb2:	4605      	mov	r5, r0
    7eb4:	b087      	sub	sp, #28
    7eb6:	4698      	mov	r8, r3
	spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
    7eb8:	462c      	mov	r4, r5
	struct spi_buf tx_buf = { .buf = &cmd, .len = 1 };
    7eba:	f10d 0307 	add.w	r3, sp, #7
{
    7ebe:	f88d 1007 	strb.w	r1, [sp, #7]
	struct spi_buf tx_buf = { .buf = &cmd, .len = 1 };
    7ec2:	9302      	str	r3, [sp, #8]
    7ec4:	2601      	movs	r6, #1
	struct spi_buf_set tx_bufs = { .buffers = &tx_buf, .count = 1 };
    7ec6:	ab02      	add	r3, sp, #8
{
    7ec8:	4617      	mov	r7, r2
	gpio_pin_write(data->cmd_data_gpio, ST7789V_CMD_DATA_PIN, !is_cmd);
    7eca:	2112      	movs	r1, #18
    7ecc:	2200      	movs	r2, #0
    7ece:	6a00      	ldr	r0, [r0, #32]
	struct spi_buf tx_buf = { .buf = &cmd, .len = 1 };
    7ed0:	9603      	str	r6, [sp, #12]
	struct spi_buf_set tx_bufs = { .buffers = &tx_buf, .count = 1 };
    7ed2:	e9cd 3604 	strd	r3, r6, [sp, #16]
	gpio_pin_write(data->cmd_data_gpio, ST7789V_CMD_DATA_PIN, !is_cmd);
    7ed6:	f7ff ffde 	bl	7e96 <gpio_pin_write>
	spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
    7eda:	f854 0b04 	ldr.w	r0, [r4], #4
				       const struct spi_buf_set *rx_bufs)
{
	const struct spi_driver_api *api =
		(const struct spi_driver_api *)dev->driver_api;

	return api->transceive(dev, config, tx_bufs, rx_bufs);
    7ede:	6843      	ldr	r3, [r0, #4]
    7ee0:	aa04      	add	r2, sp, #16
    7ee2:	f8d3 9000 	ldr.w	r9, [r3]
    7ee6:	4621      	mov	r1, r4
    7ee8:	2300      	movs	r3, #0
    7eea:	47c8      	blx	r9
	if (tx_data != NULL) {
    7eec:	b16f      	cbz	r7, 7f0a <st7789v_transmit+0x5c>
	gpio_pin_write(data->cmd_data_gpio, ST7789V_CMD_DATA_PIN, !is_cmd);
    7eee:	4632      	mov	r2, r6
    7ef0:	2112      	movs	r1, #18
    7ef2:	6a28      	ldr	r0, [r5, #32]
		tx_buf.len = tx_count;
    7ef4:	e9cd 7802 	strd	r7, r8, [sp, #8]
	gpio_pin_write(data->cmd_data_gpio, ST7789V_CMD_DATA_PIN, !is_cmd);
    7ef8:	f7ff ffcd 	bl	7e96 <gpio_pin_write>
		spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
    7efc:	6828      	ldr	r0, [r5, #0]
    7efe:	6843      	ldr	r3, [r0, #4]
    7f00:	aa04      	add	r2, sp, #16
    7f02:	681d      	ldr	r5, [r3, #0]
    7f04:	4621      	mov	r1, r4
    7f06:	2300      	movs	r3, #0
    7f08:	47a8      	blx	r5
}
    7f0a:	b007      	add	sp, #28
    7f0c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00007f10 <st7789v_blanking_on>:
{
    7f10:	b508      	push	{r3, lr}
	st7789v_transmit(driver, ST7789V_CMD_DISP_OFF, NULL, 0);
    7f12:	2300      	movs	r3, #0
    7f14:	461a      	mov	r2, r3
    7f16:	2128      	movs	r1, #40	; 0x28
    7f18:	6880      	ldr	r0, [r0, #8]
    7f1a:	f7ff ffc8 	bl	7eae <st7789v_transmit>
}
    7f1e:	2000      	movs	r0, #0
    7f20:	bd08      	pop	{r3, pc}

00007f22 <st7789v_blanking_off>:
{
    7f22:	b508      	push	{r3, lr}
	st7789v_transmit(driver, ST7789V_CMD_DISP_ON, NULL, 0);
    7f24:	2300      	movs	r3, #0
    7f26:	461a      	mov	r2, r3
    7f28:	2129      	movs	r1, #41	; 0x29
    7f2a:	6880      	ldr	r0, [r0, #8]
    7f2c:	f7ff ffbf 	bl	7eae <st7789v_transmit>
}
    7f30:	2000      	movs	r0, #0
    7f32:	bd08      	pop	{r3, pc}

00007f34 <st7789v_write>:
{
    7f34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct st7789v_data *data = (struct st7789v_data *)dev->driver_data;
    7f38:	6885      	ldr	r5, [r0, #8]
	u16_t ram_x = x + data->x_offset;
    7f3a:	8d28      	ldrh	r0, [r5, #40]	; 0x28
	u16_t ram_y = y + data->y_offset;
    7f3c:	f8b5 802a 	ldrh.w	r8, [r5, #42]	; 0x2a
{
    7f40:	461c      	mov	r4, r3
	st7789v_set_mem_area(data, x, y, desc->width, desc->height);
    7f42:	889b      	ldrh	r3, [r3, #4]
    7f44:	88e6      	ldrh	r6, [r4, #6]
	u16_t ram_x = x + data->x_offset;
    7f46:	4401      	add	r1, r0
    7f48:	b289      	uxth	r1, r1
	spi_data[1] = sys_cpu_to_be16(ram_x + w - 1);
    7f4a:	3b01      	subs	r3, #1
{
    7f4c:	b085      	sub	sp, #20
	spi_data[1] = sys_cpu_to_be16(ram_x + w - 1);
    7f4e:	440b      	add	r3, r1
	u16_t ram_y = y + data->y_offset;
    7f50:	4490      	add	r8, r2
	spi_data[1] = sys_cpu_to_be16(ram_x + w - 1);
    7f52:	ba5b      	rev16	r3, r3
	spi_data[0] = sys_cpu_to_be16(ram_x);
    7f54:	ba4a      	rev16	r2, r1
	u16_t ram_y = y + data->y_offset;
    7f56:	fa1f f888 	uxth.w	r8, r8
	spi_data[0] = sys_cpu_to_be16(ram_x);
    7f5a:	f8ad 2008 	strh.w	r2, [sp, #8]
	spi_data[1] = sys_cpu_to_be16(ram_x + w - 1);
    7f5e:	f8ad 300a 	strh.w	r3, [sp, #10]
	st7789v_transmit(data, ST7789V_CMD_CASET, (u8_t *)&spi_data[0], 4);
    7f62:	aa02      	add	r2, sp, #8
    7f64:	2304      	movs	r3, #4
    7f66:	212a      	movs	r1, #42	; 0x2a
    7f68:	4628      	mov	r0, r5
	spi_data[1] = sys_cpu_to_be16(ram_y + h - 1);
    7f6a:	3e01      	subs	r6, #1
{
    7f6c:	9f0e      	ldr	r7, [sp, #56]	; 0x38
	spi_data[1] = sys_cpu_to_be16(ram_y + h - 1);
    7f6e:	4446      	add	r6, r8
	st7789v_transmit(data, ST7789V_CMD_CASET, (u8_t *)&spi_data[0], 4);
    7f70:	f7ff ff9d 	bl	7eae <st7789v_transmit>
	spi_data[0] = sys_cpu_to_be16(ram_y);
    7f74:	fa98 f398 	rev16.w	r3, r8
    7f78:	f8ad 3008 	strh.w	r3, [sp, #8]
	spi_data[1] = sys_cpu_to_be16(ram_y + h - 1);
    7f7c:	ba76      	rev16	r6, r6
	st7789v_transmit(data, ST7789V_CMD_RASET, (u8_t *)&spi_data[0], 4);
    7f7e:	2304      	movs	r3, #4
    7f80:	aa02      	add	r2, sp, #8
    7f82:	212b      	movs	r1, #43	; 0x2b
    7f84:	4628      	mov	r0, r5
	spi_data[1] = sys_cpu_to_be16(ram_y + h - 1);
    7f86:	f8ad 600a 	strh.w	r6, [sp, #10]
	st7789v_transmit(data, ST7789V_CMD_RASET, (u8_t *)&spi_data[0], 4);
    7f8a:	f7ff ff90 	bl	7eae <st7789v_transmit>
	if (desc->pitch > desc->width) {
    7f8e:	88a3      	ldrh	r3, [r4, #4]
    7f90:	8922      	ldrh	r2, [r4, #8]
    7f92:	88e6      	ldrh	r6, [r4, #6]
		nbr_of_writes = desc->height;
    7f94:	429a      	cmp	r2, r3
    7f96:	bf84      	itt	hi
    7f98:	46b1      	movhi	r9, r6
    7f9a:	2601      	movhi	r6, #1
	st7789v_transmit(data, ST7789V_CMD_RAMWR,
    7f9c:	fb06 f303 	mul.w	r3, r6, r3
    7fa0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    7fa4:	463a      	mov	r2, r7
    7fa6:	f04f 012c 	mov.w	r1, #44	; 0x2c
    7faa:	4628      	mov	r0, r5
		nbr_of_writes = desc->height;
    7fac:	bf98      	it	ls
    7fae:	f04f 0901 	movls.w	r9, #1
	st7789v_transmit(data, ST7789V_CMD_RAMWR,
    7fb2:	f7ff ff7c 	bl	7eae <st7789v_transmit>
	tx_bufs.count = 1;
    7fb6:	2301      	movs	r3, #1
    7fb8:	9303      	str	r3, [sp, #12]
	write_data_start += (desc->pitch * ST7789V_PIXEL_SIZE);
    7fba:	8923      	ldrh	r3, [r4, #8]
	tx_bufs.buffers = &tx_buf;
    7fbc:	f8cd d008 	str.w	sp, [sp, #8]
	write_data_start += (desc->pitch * ST7789V_PIXEL_SIZE);
    7fc0:	eb07 0743 	add.w	r7, r7, r3, lsl #1
	for (write_cnt = 1U; write_cnt < nbr_of_writes; ++write_cnt) {
    7fc4:	f04f 0800 	mov.w	r8, #0
		spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
    7fc8:	f105 0a04 	add.w	sl, r5, #4
    7fcc:	f108 0801 	add.w	r8, r8, #1
	for (write_cnt = 1U; write_cnt < nbr_of_writes; ++write_cnt) {
    7fd0:	fa1f f388 	uxth.w	r3, r8
    7fd4:	4599      	cmp	r9, r3
    7fd6:	d803      	bhi.n	7fe0 <st7789v_write+0xac>
}
    7fd8:	2000      	movs	r0, #0
    7fda:	b005      	add	sp, #20
    7fdc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		tx_buf.len = desc->width * ST7789V_PIXEL_SIZE * write_h;
    7fe0:	88a3      	ldrh	r3, [r4, #4]
		tx_buf.buf = (void *)write_data_start;
    7fe2:	9700      	str	r7, [sp, #0]
		tx_buf.len = desc->width * ST7789V_PIXEL_SIZE * write_h;
    7fe4:	4373      	muls	r3, r6
    7fe6:	005b      	lsls	r3, r3, #1
    7fe8:	9301      	str	r3, [sp, #4]
		spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
    7fea:	6828      	ldr	r0, [r5, #0]
    7fec:	6843      	ldr	r3, [r0, #4]
    7fee:	aa02      	add	r2, sp, #8
    7ff0:	f8d3 b000 	ldr.w	fp, [r3]
    7ff4:	4651      	mov	r1, sl
    7ff6:	2300      	movs	r3, #0
    7ff8:	47d8      	blx	fp
		write_data_start += (desc->pitch * ST7789V_PIXEL_SIZE);
    7ffa:	8923      	ldrh	r3, [r4, #8]
    7ffc:	eb07 0743 	add.w	r7, r7, r3, lsl #1
    8000:	e7e4      	b.n	7fcc <st7789v_write+0x98>

00008002 <z_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
    8002:	4770      	bx	lr

00008004 <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
    8004:	4770      	bx	lr

00008006 <z_irq_spurious>:
 * @return N/A
 */
void z_irq_spurious(void *unused)
{
	ARG_UNUSED(unused);
	z_arm_reserved();
    8006:	f7f9 b945 	b.w	1294 <z_arm_bus_fault>

0000800a <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
    800a:	4601      	mov	r1, r0
			reason = K_ERR_KERNEL_OOPS;
		}
	}

#endif /* CONFIG_USERSPACE */
	z_arm_fatal_error(reason, esf);
    800c:	6800      	ldr	r0, [r0, #0]
    800e:	f7f9 b94b 	b.w	12a8 <z_arm_fatal_error>

00008012 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
    8012:	b508      	push	{r3, lr}
	handler();
    8014:	f7f9 f99a 	bl	134c <z_SysNmiOnReset>
	z_arm_exc_exit();
}
    8018:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_exc_exit();
    801c:	f7f9 b864 	b.w	10e8 <z_arm_exc_exit>

00008020 <z_arm_configure_dynamic_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_dynamic_mpu_regions(struct k_thread *thread)
{
    8020:	b507      	push	{r0, r1, r2, lr}

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(
    8022:	2100      	movs	r1, #0
    8024:	a801      	add	r0, sp, #4
    8026:	f7f9 fd73 	bl	1b10 <arm_core_mpu_configure_dynamic_mpu_regions>
		(const struct k_mem_partition **)dynamic_regions,
		region_num);
}
    802a:	b003      	add	sp, #12
    802c:	f85d fb04 	ldr.w	pc, [sp], #4

00008030 <strcpy>:

char *strcpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
    8030:	3901      	subs	r1, #1
    8032:	4603      	mov	r3, r0
    8034:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    8038:	b90a      	cbnz	r2, 803e <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
    803a:	701a      	strb	r2, [r3, #0]

	return dest;
}
    803c:	4770      	bx	lr
		*d = *s;
    803e:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
    8042:	e7f7      	b.n	8034 <strcpy+0x4>

00008044 <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
    8044:	b570      	push	{r4, r5, r6, lr}
    8046:	3901      	subs	r1, #1
    8048:	4605      	mov	r5, r0
    804a:	462c      	mov	r4, r5
	char *dest = d;

	while ((n > 0) && *s != '\0') {
    804c:	b142      	cbz	r2, 8060 <strncpy+0x1c>
    804e:	f811 3f01 	ldrb.w	r3, [r1, #1]!
    8052:	1e56      	subs	r6, r2, #1
    8054:	b92b      	cbnz	r3, 8062 <strncpy+0x1e>
    8056:	442a      	add	r2, r5
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
    8058:	f804 3b01 	strb.w	r3, [r4], #1
	while (n > 0) {
    805c:	42a2      	cmp	r2, r4
    805e:	d1fb      	bne.n	8058 <strncpy+0x14>
		d++;
		n--;
	}

	return dest;
}
    8060:	bd70      	pop	{r4, r5, r6, pc}
		*d = *s;
    8062:	f805 3b01 	strb.w	r3, [r5], #1
		n--;
    8066:	4632      	mov	r2, r6
    8068:	e7ef      	b.n	804a <strncpy+0x6>

0000806a <strchr>:
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
	char tmp = (char) c;
    806a:	b2c9      	uxtb	r1, r1

	while ((*s != tmp) && (*s != '\0')) {
    806c:	7802      	ldrb	r2, [r0, #0]
    806e:	428a      	cmp	r2, r1
    8070:	4603      	mov	r3, r0
    8072:	f100 0001 	add.w	r0, r0, #1
    8076:	d004      	beq.n	8082 <strchr+0x18>
    8078:	2a00      	cmp	r2, #0
    807a:	d1f7      	bne.n	806c <strchr+0x2>
		s++;
	}

	return (*s == tmp) ? (char *) s : NULL;
    807c:	2900      	cmp	r1, #0
    807e:	bf18      	it	ne
    8080:	2300      	movne	r3, #0
}
    8082:	4618      	mov	r0, r3
    8084:	4770      	bx	lr

00008086 <strlen>:
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
	size_t n = 0;
    8086:	2300      	movs	r3, #0

	while (*s != '\0') {
    8088:	5cc2      	ldrb	r2, [r0, r3]
    808a:	b90a      	cbnz	r2, 8090 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
    808c:	4618      	mov	r0, r3
    808e:	4770      	bx	lr
		n++;
    8090:	3301      	adds	r3, #1
    8092:	e7f9      	b.n	8088 <strlen+0x2>

00008094 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
    8094:	3801      	subs	r0, #1
    8096:	3901      	subs	r1, #1
    8098:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    809c:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    80a0:	4293      	cmp	r3, r2
    80a2:	d101      	bne.n	80a8 <strcmp+0x14>
    80a4:	2b00      	cmp	r3, #0
    80a6:	d1f7      	bne.n	8098 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
    80a8:	1a98      	subs	r0, r3, r2
    80aa:	4770      	bx	lr

000080ac <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
    80ac:	b5f0      	push	{r4, r5, r6, r7, lr}

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
    80ae:	ea81 0400 	eor.w	r4, r1, r0
    80b2:	07a5      	lsls	r5, r4, #30
    80b4:	4603      	mov	r3, r0
    80b6:	d00b      	beq.n	80d0 <memcpy+0x24>
    80b8:	3b01      	subs	r3, #1
    80ba:	440a      	add	r2, r1
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
    80bc:	4291      	cmp	r1, r2
    80be:	d11a      	bne.n	80f6 <memcpy+0x4a>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
    80c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (n == 0) {
    80c2:	2a00      	cmp	r2, #0
    80c4:	d0fc      	beq.n	80c0 <memcpy+0x14>
			*(d_byte++) = *(s_byte++);
    80c6:	f811 4b01 	ldrb.w	r4, [r1], #1
    80ca:	f803 4b01 	strb.w	r4, [r3], #1
			n--;
    80ce:	3a01      	subs	r2, #1
		while (((uintptr_t)d_byte) & mask) {
    80d0:	079c      	lsls	r4, r3, #30
    80d2:	d1f6      	bne.n	80c2 <memcpy+0x16>
    80d4:	0895      	lsrs	r5, r2, #2
    80d6:	00ac      	lsls	r4, r5, #2
    80d8:	1f1e      	subs	r6, r3, #4
    80da:	190f      	adds	r7, r1, r4
		while (n >= sizeof(mem_word_t)) {
    80dc:	42b9      	cmp	r1, r7
    80de:	d105      	bne.n	80ec <memcpy+0x40>
    80e0:	f06f 0603 	mvn.w	r6, #3
    80e4:	fb06 2205 	mla	r2, r6, r5, r2
    80e8:	4423      	add	r3, r4
    80ea:	e7e5      	b.n	80b8 <memcpy+0xc>
			*(d_word++) = *(s_word++);
    80ec:	f851 cb04 	ldr.w	ip, [r1], #4
    80f0:	f846 cf04 	str.w	ip, [r6, #4]!
			n -= sizeof(mem_word_t);
    80f4:	e7f2      	b.n	80dc <memcpy+0x30>
		*(d_byte++) = *(s_byte++);
    80f6:	f811 4b01 	ldrb.w	r4, [r1], #1
    80fa:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
    80fe:	e7dd      	b.n	80bc <memcpy+0x10>

00008100 <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
    8100:	b570      	push	{r4, r5, r6, lr}
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    8102:	b2c9      	uxtb	r1, r1
	unsigned char *d_byte = (unsigned char *)buf;
    8104:	4603      	mov	r3, r0

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
    8106:	079c      	lsls	r4, r3, #30
    8108:	d110      	bne.n	812c <memset+0x2c>
	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;

	c_word |= c_word << 8;
    810a:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
	c_word |= c_word << 16;
    810e:	ea44 4504 	orr.w	r5, r4, r4, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
    8112:	0894      	lsrs	r4, r2, #2
    8114:	eb03 0684 	add.w	r6, r3, r4, lsl #2
    8118:	42b3      	cmp	r3, r6
    811a:	d10d      	bne.n	8138 <memset+0x38>
    811c:	f06f 0503 	mvn.w	r5, #3
    8120:	fb05 2404 	mla	r4, r5, r4, r2
    8124:	441c      	add	r4, r3

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
    8126:	42a3      	cmp	r3, r4
    8128:	d109      	bne.n	813e <memset+0x3e>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
    812a:	bd70      	pop	{r4, r5, r6, pc}
		if (n == 0) {
    812c:	2a00      	cmp	r2, #0
    812e:	d0fc      	beq.n	812a <memset+0x2a>
		*(d_byte++) = c_byte;
    8130:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
    8134:	3a01      	subs	r2, #1
    8136:	e7e6      	b.n	8106 <memset+0x6>
		*(d_word++) = c_word;
    8138:	f843 5b04 	str.w	r5, [r3], #4
		n -= sizeof(mem_word_t);
    813c:	e7ec      	b.n	8118 <memset+0x18>
		*(d_byte++) = c_byte;
    813e:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
    8142:	e7f0      	b.n	8126 <memset+0x26>

00008144 <_to_x>:
{
    8144:	b5f0      	push	{r4, r5, r6, r7, lr}
    8146:	4603      	mov	r3, r0
		unsigned int d = n % base;
    8148:	fbb1 f7f2 	udiv	r7, r1, r2
    814c:	fb02 1517 	mls	r5, r2, r7, r1
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
    8150:	2d09      	cmp	r5, #9
    8152:	bf8c      	ite	hi
    8154:	2627      	movhi	r6, #39	; 0x27
    8156:	2600      	movls	r6, #0
    8158:	461c      	mov	r4, r3
    815a:	3530      	adds	r5, #48	; 0x30
    815c:	4435      	add	r5, r6
	} while (n);
    815e:	4291      	cmp	r1, r2
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
    8160:	f804 5b01 	strb.w	r5, [r4], #1
	} while (n);
    8164:	d206      	bcs.n	8174 <_to_x+0x30>
	*buf = 0;
    8166:	2200      	movs	r2, #0
    8168:	7022      	strb	r2, [r4, #0]
	len = buf - start;
    816a:	1a24      	subs	r4, r4, r0
	for (buf--; buf > start; buf--, start++) {
    816c:	4283      	cmp	r3, r0
    816e:	d804      	bhi.n	817a <_to_x+0x36>
}
    8170:	4620      	mov	r0, r4
    8172:	bdf0      	pop	{r4, r5, r6, r7, pc}
		n /= base;
    8174:	4639      	mov	r1, r7
    8176:	4623      	mov	r3, r4
    8178:	e7e6      	b.n	8148 <_to_x+0x4>
		char tmp = *buf;
    817a:	781a      	ldrb	r2, [r3, #0]
		*buf = *start;
    817c:	7801      	ldrb	r1, [r0, #0]
    817e:	f803 1901 	strb.w	r1, [r3], #-1
		*start = tmp;
    8182:	f800 2b01 	strb.w	r2, [r0], #1
    8186:	e7f1      	b.n	816c <_to_x+0x28>

00008188 <_rlrshift>:
{
    8188:	b570      	push	{r4, r5, r6, lr}
	*v = (*v & 1) + (*v >> 1);
    818a:	e9d0 6500 	ldrd	r6, r5, [r0]
    818e:	0872      	lsrs	r2, r6, #1
    8190:	f006 0301 	and.w	r3, r6, #1
    8194:	ea42 72c5 	orr.w	r2, r2, r5, lsl #31
    8198:	189b      	adds	r3, r3, r2
    819a:	f04f 0100 	mov.w	r1, #0
    819e:	ea4f 0455 	mov.w	r4, r5, lsr #1
    81a2:	eb44 0101 	adc.w	r1, r4, r1
    81a6:	e9c0 3100 	strd	r3, r1, [r0]
}
    81aa:	bd70      	pop	{r4, r5, r6, pc}

000081ac <_ldiv5>:
	uint64_t rem = *v, quot = 0U, q;
    81ac:	e9d0 3200 	ldrd	r3, r2, [r0]
{
    81b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	rem += 2U;
    81b4:	3302      	adds	r3, #2
		q = (uint64_t)(hi / 5U) << shifts[i];
    81b6:	f04f 0705 	mov.w	r7, #5
    81ba:	f04f 0c00 	mov.w	ip, #0
	rem += 2U;
    81be:	f142 0200 	adc.w	r2, r2, #0
		rem -= q * 5U;
    81c2:	ebb3 060c 	subs.w	r6, r3, ip
		q = (uint64_t)(hi / 5U) << shifts[i];
    81c6:	fbb2 fef7 	udiv	lr, r2, r7
		rem -= q * 5U;
    81ca:	fb07 f10e 	mul.w	r1, r7, lr
    81ce:	eb62 0101 	sbc.w	r1, r2, r1
		hi = rem >> shifts[i];
    81d2:	08f2      	lsrs	r2, r6, #3
    81d4:	ea42 7241 	orr.w	r2, r2, r1, lsl #29
		q = (uint64_t)(hi / 5U) << shifts[i];
    81d8:	fbb2 f1f7 	udiv	r1, r2, r7
    81dc:	00ca      	lsls	r2, r1, #3
		quot += q;
    81de:	eb1c 0802 	adds.w	r8, ip, r2
		q = (uint64_t)(hi / 5U) << shifts[i];
    81e2:	ea4f 7351 	mov.w	r3, r1, lsr #29
		quot += q;
    81e6:	eb4e 0903 	adc.w	r9, lr, r3
		rem -= q * 5U;
    81ea:	fba2 2307 	umull	r2, r3, r2, r7
    81ee:	1ab3      	subs	r3, r6, r2
		q = (uint64_t)(hi / 5U) << shifts[i];
    81f0:	fbb3 f3f7 	udiv	r3, r3, r7
		quot += q;
    81f4:	eb18 0403 	adds.w	r4, r8, r3
    81f8:	f149 0500 	adc.w	r5, r9, #0
	*v = quot;
    81fc:	e9c0 4500 	strd	r4, r5, [r0]
}
    8200:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00008204 <_get_digit>:
	if (*digit_count > 0) {
    8204:	680b      	ldr	r3, [r1, #0]
    8206:	2b00      	cmp	r3, #0
{
    8208:	b570      	push	{r4, r5, r6, lr}
	if (*digit_count > 0) {
    820a:	dd10      	ble.n	822e <_get_digit+0x2a>
		*digit_count -= 1;
    820c:	3b01      	subs	r3, #1
		*fr = *fr * 10U;
    820e:	6802      	ldr	r2, [r0, #0]
		*digit_count -= 1;
    8210:	600b      	str	r3, [r1, #0]
		*fr = *fr * 10U;
    8212:	6844      	ldr	r4, [r0, #4]
    8214:	210a      	movs	r1, #10
    8216:	fba2 5601 	umull	r5, r6, r2, r1
    821a:	fb01 6604 	mla	r6, r1, r4, r6
		*fr &= 0x0FFFFFFFFFFFFFFFull;
    821e:	f026 4370 	bic.w	r3, r6, #4026531840	; 0xf0000000
    8222:	e9c0 5300 	strd	r5, r3, [r0]
		rval = ((*fr >> 60) & 0xF) + '0';
    8226:	0f31      	lsrs	r1, r6, #28
    8228:	3130      	adds	r1, #48	; 0x30
}
    822a:	4608      	mov	r0, r1
    822c:	bd70      	pop	{r4, r5, r6, pc}
		rval = '0';
    822e:	2130      	movs	r1, #48	; 0x30
    8230:	e7fb      	b.n	822a <_get_digit+0x26>

00008232 <_stdout_hook_default>:
}
    8232:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    8236:	4770      	bx	lr

00008238 <fputc>:
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&c, *(uintptr_t *)&stream, K_SYSCALL_ZEPHYR_FPUTC);
	}
#endif
	compiler_barrier();
	return z_impl_zephyr_fputc(c, stream);
    8238:	f7fa b938 	b.w	24ac <z_impl_zephyr_fputc>

0000823c <sprintf_out>:
	if (p->len > 1) { /* need to reserve a byte for EOS */
    823c:	684b      	ldr	r3, [r1, #4]
    823e:	2b01      	cmp	r3, #1
    8240:	dd07      	ble.n	8252 <sprintf_out+0x16>
		*(p->ptr) = c;
    8242:	680b      	ldr	r3, [r1, #0]
    8244:	7018      	strb	r0, [r3, #0]
		p->ptr += 1;
    8246:	680b      	ldr	r3, [r1, #0]
    8248:	3301      	adds	r3, #1
    824a:	600b      	str	r3, [r1, #0]
		p->len -= 1;
    824c:	684b      	ldr	r3, [r1, #4]
    824e:	3b01      	subs	r3, #1
    8250:	604b      	str	r3, [r1, #4]
}
    8252:	2000      	movs	r0, #0
    8254:	4770      	bx	lr

00008256 <display_get_capabilities>:
    8256:	6843      	ldr	r3, [r0, #4]
    8258:	69db      	ldr	r3, [r3, #28]
    825a:	4718      	bx	r3

0000825c <lvgl_flush_cb_mono>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_mono(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
    825c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u16_t w = area->x2 - area->x1 + 1;
    8260:	888c      	ldrh	r4, [r1, #4]
    8262:	880b      	ldrh	r3, [r1, #0]
	u16_t h = area->y2 - area->y1 + 1;
    8264:	88ce      	ldrh	r6, [r1, #6]
	struct device *display_dev = (struct device *)disp_drv->user_data;
    8266:	f8d0 9020 	ldr.w	r9, [r0, #32]
	u16_t w = area->x2 - area->x1 + 1;
    826a:	3401      	adds	r4, #1
    826c:	1ae4      	subs	r4, r4, r3
	u16_t h = area->y2 - area->y1 + 1;
    826e:	884b      	ldrh	r3, [r1, #2]
    8270:	3601      	adds	r6, #1
{
    8272:	b08b      	sub	sp, #44	; 0x2c
	u16_t h = area->y2 - area->y1 + 1;
    8274:	1af6      	subs	r6, r6, r3
	u16_t w = area->x2 - area->x1 + 1;
    8276:	b2a4      	uxth	r4, r4
{
    8278:	460d      	mov	r5, r1
	u16_t h = area->y2 - area->y1 + 1;
    827a:	b2b6      	uxth	r6, r6
	struct display_capabilities cap;
	struct display_buffer_descriptor desc;

	display_get_capabilities(display_dev, &cap);
    827c:	a906      	add	r1, sp, #24
{
    827e:	4607      	mov	r7, r0
	display_get_capabilities(display_dev, &cap);
    8280:	4648      	mov	r0, r9
{
    8282:	4690      	mov	r8, r2
	display_get_capabilities(display_dev, &cap);
    8284:	f7ff ffe7 	bl	8256 <display_get_capabilities>

	desc.buf_size = (w * h)/8U;
    8288:	fb06 f304 	mul.w	r3, r6, r4
    828c:	08db      	lsrs	r3, r3, #3
    828e:	9303      	str	r3, [sp, #12]
	return api->write(dev, x, y, desc, buf);
    8290:	f8d9 3004 	ldr.w	r3, [r9, #4]
    8294:	f8cd 8000 	str.w	r8, [sp]
	desc.width = w;
    8298:	f8ad 4010 	strh.w	r4, [sp, #16]
	desc.pitch = w;
    829c:	f8ad 4014 	strh.w	r4, [sp, #20]
	desc.height = h;
    82a0:	f8ad 6012 	strh.w	r6, [sp, #18]
    82a4:	689c      	ldr	r4, [r3, #8]
    82a6:	886a      	ldrh	r2, [r5, #2]
    82a8:	8829      	ldrh	r1, [r5, #0]
    82aa:	ab03      	add	r3, sp, #12
    82ac:	4648      	mov	r0, r9
    82ae:	47a0      	blx	r4
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);
	if (cap.screen_info & SCREEN_INFO_DOUBLE_BUFFER) {
    82b0:	9b08      	ldr	r3, [sp, #32]
    82b2:	071b      	lsls	r3, r3, #28
    82b4:	d509      	bpl.n	82ca <lvgl_flush_cb_mono+0x6e>
    82b6:	f8d9 3004 	ldr.w	r3, [r9, #4]
    82ba:	f8cd 8000 	str.w	r8, [sp]
    82be:	689c      	ldr	r4, [r3, #8]
    82c0:	886a      	ldrh	r2, [r5, #2]
    82c2:	8829      	ldrh	r1, [r5, #0]
    82c4:	ab03      	add	r3, sp, #12
    82c6:	4648      	mov	r0, r9
    82c8:	47a0      	blx	r4
		display_write(display_dev, area->x1, area->y1, &desc,
				(void *) color_p);
	}

	lv_disp_flush_ready(disp_drv);
    82ca:	4638      	mov	r0, r7
    82cc:	f001 ff97 	bl	a1fe <lv_disp_flush_ready>
}
    82d0:	b00b      	add	sp, #44	; 0x2c
    82d2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

000082d6 <lvgl_set_px_cb_mono>:


void lvgl_set_px_cb_mono(struct _disp_drv_t *disp_drv,
		u8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
    82d6:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	struct device *display_dev = (struct device *)disp_drv->user_data;
	u8_t *buf_xy;
	u8_t bit;
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);
    82da:	6a00      	ldr	r0, [r0, #32]
{
    82dc:	f9bd 6028 	ldrsh.w	r6, [sp, #40]	; 0x28
    82e0:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    82e2:	460f      	mov	r7, r1
	display_get_capabilities(display_dev, &cap);
    82e4:	4669      	mov	r1, sp
{
    82e6:	4690      	mov	r8, r2
    82e8:	461c      	mov	r4, r3
	display_get_capabilities(display_dev, &cap);
    82ea:	f7ff ffb4 	bl	8256 <display_get_capabilities>

	if (cap.screen_info & SCREEN_INFO_MONO_VTILED) {
    82ee:	9802      	ldr	r0, [sp, #8]
    82f0:	f010 0f01 	tst.w	r0, #1
    82f4:	f000 0002 	and.w	r0, r0, #2
    82f8:	d01f      	beq.n	833a <lvgl_set_px_cb_mono+0x64>
		buf_xy = buf + x + y/8 * buf_w;
    82fa:	2e00      	cmp	r6, #0
    82fc:	4631      	mov	r1, r6
    82fe:	bfb8      	it	lt
    8300:	1df1      	addlt	r1, r6, #7
    8302:	10c9      	asrs	r1, r1, #3
    8304:	fb11 4108 	smlabb	r1, r1, r8, r4
    8308:	4439      	add	r1, r7

		if (cap.screen_info & SCREEN_INFO_MONO_MSB_FIRST) {
    830a:	4273      	negs	r3, r6
    830c:	f006 0407 	and.w	r4, r6, #7
    8310:	f003 0307 	and.w	r3, r3, #7
    8314:	bf58      	it	pl
    8316:	425c      	negpl	r4, r3
			bit = y%8;
		}
	} else {
		buf_xy = buf + x/8 + y * buf_w/8;

		if (cap.screen_info & SCREEN_INFO_MONO_MSB_FIRST) {
    8318:	b108      	cbz	r0, 831e <lvgl_set_px_cb_mono+0x48>
			bit = 7 - x%8;
    831a:	f1c4 0407 	rsb	r4, r4, #7
		} else {
			bit = x%8;
    831e:	2301      	movs	r3, #1
    8320:	b2e4      	uxtb	r4, r4
		}
	}

	if (cap.current_pixel_format == PIXEL_FORMAT_MONO10) {
    8322:	fa03 f404 	lsl.w	r4, r3, r4
    8326:	f89d 300c 	ldrb.w	r3, [sp, #12]
    832a:	7808      	ldrb	r0, [r1, #0]
    832c:	2b04      	cmp	r3, #4
    832e:	b2e4      	uxtb	r4, r4
    8330:	d115      	bne.n	835e <lvgl_set_px_cb_mono+0x88>
		if (color.full == 0) {
    8332:	b9b5      	cbnz	r5, 8362 <lvgl_set_px_cb_mono+0x8c>
		}
	} else {
		if (color.full == 0) {
			*buf_xy |= BIT(bit);
		} else {
			*buf_xy &= ~BIT(bit);
    8334:	ea20 0004 	bic.w	r0, r0, r4
    8338:	e014      	b.n	8364 <lvgl_set_px_cb_mono+0x8e>
		buf_xy = buf + x/8 + y * buf_w/8;
    833a:	4643      	mov	r3, r8
    833c:	435e      	muls	r6, r3
    833e:	bf48      	it	mi
    8340:	3607      	addmi	r6, #7
    8342:	2c00      	cmp	r4, #0
    8344:	4622      	mov	r2, r4
    8346:	ea4f 06e6 	mov.w	r6, r6, asr #3
    834a:	bfb8      	it	lt
    834c:	1de2      	addlt	r2, r4, #7
    834e:	eb06 06e2 	add.w	r6, r6, r2, asr #3
    8352:	4263      	negs	r3, r4
    8354:	eb07 0106 	add.w	r1, r7, r6
		if (cap.screen_info & SCREEN_INFO_MONO_MSB_FIRST) {
    8358:	f004 0407 	and.w	r4, r4, #7
    835c:	e7d8      	b.n	8310 <lvgl_set_px_cb_mono+0x3a>
		if (color.full == 0) {
    835e:	2d00      	cmp	r5, #0
    8360:	d1e8      	bne.n	8334 <lvgl_set_px_cb_mono+0x5e>
			*buf_xy |= BIT(bit);
    8362:	4320      	orrs	r0, r4
			*buf_xy &= ~BIT(bit);
    8364:	7008      	strb	r0, [r1, #0]
		}
	}
}
    8366:	b004      	add	sp, #16
    8368:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000836c <lvgl_rounder_cb_mono>:

void lvgl_rounder_cb_mono(struct _disp_drv_t *disp_drv,
		lv_area_t *area)
{
    836c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    836e:	460c      	mov	r4, r1
	struct device *display_dev = (struct device *)disp_drv->user_data;
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);
    8370:	6a00      	ldr	r0, [r0, #32]
    8372:	4669      	mov	r1, sp
    8374:	f7ff ff6f 	bl	8256 <display_get_capabilities>

	if (cap.screen_info & SCREEN_INFO_MONO_VTILED) {
    8378:	9b02      	ldr	r3, [sp, #8]
    837a:	07db      	lsls	r3, r3, #31
    837c:	d509      	bpl.n	8392 <lvgl_rounder_cb_mono+0x26>
		area->y1 &= ~0x7;
    837e:	8863      	ldrh	r3, [r4, #2]
    8380:	f023 0307 	bic.w	r3, r3, #7
    8384:	8063      	strh	r3, [r4, #2]
		area->y2 |= 0x7;
    8386:	88e3      	ldrh	r3, [r4, #6]
    8388:	f043 0307 	orr.w	r3, r3, #7
    838c:	80e3      	strh	r3, [r4, #6]
	} else {
		area->x1 &= ~0x7;
		area->x2 |= 0x7;
	}
}
    838e:	b004      	add	sp, #16
    8390:	bd10      	pop	{r4, pc}
		area->x1 &= ~0x7;
    8392:	8823      	ldrh	r3, [r4, #0]
    8394:	f023 0307 	bic.w	r3, r3, #7
    8398:	8023      	strh	r3, [r4, #0]
		area->x2 |= 0x7;
    839a:	88a3      	ldrh	r3, [r4, #4]
    839c:	f043 0307 	orr.w	r3, r3, #7
    83a0:	80a3      	strh	r3, [r4, #4]
}
    83a2:	e7f4      	b.n	838e <lvgl_rounder_cb_mono+0x22>

000083a4 <lvgl_flush_cb_16bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_16bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
    83a4:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct device *display_dev = (struct device *)disp_drv->user_data;
	u16_t w = area->x2 - area->x1 + 1;
    83a6:	888b      	ldrh	r3, [r1, #4]
	u16_t h = area->y2 - area->y1 + 1;
    83a8:	88cc      	ldrh	r4, [r1, #6]
	u16_t w = area->x2 - area->x1 + 1;
    83aa:	f9b1 6000 	ldrsh.w	r6, [r1]
	u16_t h = area->y2 - area->y1 + 1;
    83ae:	f9b1 7002 	ldrsh.w	r7, [r1, #2]
	u16_t w = area->x2 - area->x1 + 1;
    83b2:	3301      	adds	r3, #1
	u16_t h = area->y2 - area->y1 + 1;
    83b4:	3401      	adds	r4, #1
{
    83b6:	b087      	sub	sp, #28
    83b8:	4605      	mov	r5, r0
	u16_t w = area->x2 - area->x1 + 1;
    83ba:	1b9b      	subs	r3, r3, r6
	struct device *display_dev = (struct device *)disp_drv->user_data;
    83bc:	6a00      	ldr	r0, [r0, #32]
	u16_t h = area->y2 - area->y1 + 1;
    83be:	1be4      	subs	r4, r4, r7
	u16_t w = area->x2 - area->x1 + 1;
    83c0:	b29b      	uxth	r3, r3
	u16_t h = area->y2 - area->y1 + 1;
    83c2:	b2a4      	uxth	r4, r4
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 2U * h;
    83c4:	fb04 f103 	mul.w	r1, r4, r3
	desc.width = w;
    83c8:	f8ad 3010 	strh.w	r3, [sp, #16]
	desc.pitch = w;
    83cc:	f8ad 3014 	strh.w	r3, [sp, #20]
    83d0:	6843      	ldr	r3, [r0, #4]
    83d2:	9200      	str	r2, [sp, #0]
	desc.buf_size = w * 2U * h;
    83d4:	0049      	lsls	r1, r1, #1
    83d6:	9103      	str	r1, [sp, #12]
	desc.height = h;
    83d8:	f8ad 4012 	strh.w	r4, [sp, #18]
    83dc:	b2ba      	uxth	r2, r7
    83de:	689c      	ldr	r4, [r3, #8]
    83e0:	b2b1      	uxth	r1, r6
    83e2:	ab03      	add	r3, sp, #12
    83e4:	47a0      	blx	r4
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);

	lv_disp_flush_ready(disp_drv);
    83e6:	4628      	mov	r0, r5
    83e8:	f001 ff09 	bl	a1fe <lv_disp_flush_ready>
}
    83ec:	b007      	add	sp, #28
    83ee:	bdf0      	pop	{r4, r5, r6, r7, pc}

000083f0 <lvgl_set_px_cb_16bit>:

#ifndef CONFIG_LVGL_COLOR_DEPTH_16
void lvgl_set_px_cb_16bit(struct _disp_drv_t *disp_drv,
		u8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
    83f0:	b530      	push	{r4, r5, lr}
    83f2:	9804      	ldr	r0, [sp, #16]
    return ret.full;
#elif LV_COLOR_DEPTH == 16
    return color.full;
#elif LV_COLOR_DEPTH == 32
    lv_color16_t ret;
    LV_COLOR_SET_R16(ret, LV_COLOR_GET_R(color) >> 3);   /* 8 - 5  = 3*/
    83f4:	f04f 0400 	mov.w	r4, #0
    83f8:	f3c0 45c4 	ubfx	r5, r0, #19, #5
    83fc:	f365 24cf 	bfi	r4, r5, #11, #5

#if LV_COLOR_16_SWAP == 0
    LV_COLOR_SET_G16(ret, LV_COLOR_GET_G(color) >> 2); /* 8 - 6  = 2*/
    8400:	f3c0 2585 	ubfx	r5, r0, #10, #6
    8404:	f365 144a 	bfi	r4, r5, #5, #6
#else
    LV_COLOR_SET_G16_SWAP(ret, ret.ch.green_h = (LV_COLOR_GET_G(color) >> 2); /*(2^6 - 1)/(2^3 - 1) = 63/7 = 9*/
#endif
    LV_COLOR_SET_B16(ret, LV_COLOR_GET_B(color) >> 3);  /* 8 - 5  = 3*/
    8408:	f3c0 00c4 	ubfx	r0, r0, #3, #5
    840c:	f360 0404 	bfi	r4, r0, #0, #5
	u16_t *buf_xy = (u16_t *)(buf + x * 2U + y * 2U * buf_w);
    8410:	f9bd 000c 	ldrsh.w	r0, [sp, #12]
    8414:	fb00 3302 	mla	r3, r0, r2, r3
	*buf_xy = lv_color_to16(color);
    8418:	f821 4013 	strh.w	r4, [r1, r3, lsl #1]
}
    841c:	bd30      	pop	{r4, r5, pc}

0000841e <lvgl_flush_cb_24bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_24bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
    841e:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct device *display_dev = (struct device *)disp_drv->user_data;
	u16_t w = area->x2 - area->x1 + 1;
    8420:	888b      	ldrh	r3, [r1, #4]
	u16_t h = area->y2 - area->y1 + 1;
    8422:	88cc      	ldrh	r4, [r1, #6]
    8424:	f9b1 c002 	ldrsh.w	ip, [r1, #2]
	u16_t w = area->x2 - area->x1 + 1;
    8428:	f9b1 7000 	ldrsh.w	r7, [r1]
    842c:	3301      	adds	r3, #1
	u16_t h = area->y2 - area->y1 + 1;
    842e:	3401      	adds	r4, #1
{
    8430:	b087      	sub	sp, #28
	u16_t h = area->y2 - area->y1 + 1;
    8432:	eba4 040c 	sub.w	r4, r4, ip
{
    8436:	4605      	mov	r5, r0
	u16_t w = area->x2 - area->x1 + 1;
    8438:	1bdb      	subs	r3, r3, r7
	struct device *display_dev = (struct device *)disp_drv->user_data;
    843a:	6a00      	ldr	r0, [r0, #32]
	u16_t w = area->x2 - area->x1 + 1;
    843c:	b29b      	uxth	r3, r3
	u16_t h = area->y2 - area->y1 + 1;
    843e:	b2a4      	uxth	r4, r4
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 3U * h;
    8440:	fb04 f603 	mul.w	r6, r4, r3
	desc.width = w;
    8444:	f8ad 3010 	strh.w	r3, [sp, #16]
	desc.pitch = w;
    8448:	f8ad 3014 	strh.w	r3, [sp, #20]
    844c:	6843      	ldr	r3, [r0, #4]
    844e:	9200      	str	r2, [sp, #0]
	desc.buf_size = w * 3U * h;
    8450:	eb06 0646 	add.w	r6, r6, r6, lsl #1
	desc.height = h;
    8454:	f8ad 4012 	strh.w	r4, [sp, #18]
    8458:	fa1f f28c 	uxth.w	r2, ip
    845c:	689c      	ldr	r4, [r3, #8]
	desc.buf_size = w * 3U * h;
    845e:	9603      	str	r6, [sp, #12]
    8460:	ab03      	add	r3, sp, #12
    8462:	b2b9      	uxth	r1, r7
    8464:	47a0      	blx	r4
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);

	lv_disp_flush_ready(disp_drv);
    8466:	4628      	mov	r0, r5
    8468:	f001 fec9 	bl	a1fe <lv_disp_flush_ready>
}
    846c:	b007      	add	sp, #28
    846e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00008470 <lvgl_set_px_cb_24bit>:

void lvgl_set_px_cb_24bit(struct _disp_drv_t *disp_drv,
		u8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
    8470:	b5f0      	push	{r4, r5, r6, r7, lr}
	u8_t *buf_xy = buf + x * 3U + y * 3U * buf_w;
    8472:	f9bd 5014 	ldrsh.w	r5, [sp, #20]
{
    8476:	f89d 401c 	ldrb.w	r4, [sp, #28]
    847a:	9806      	ldr	r0, [sp, #24]
	u8_t *buf_xy = buf + x * 3U + y * 3U * buf_w;
    847c:	fb05 3302 	mla	r3, r5, r2, r3
    8480:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	lv_color32_t converted_color;

#ifdef CONFIG_LVGL_COLOR_DEPTH_32
	if (opa != LV_OPA_COVER) {
    8484:	2cff      	cmp	r4, #255	; 0xff
	u8_t *buf_xy = buf + x * 3U + y * 3U * buf_w;
    8486:	eb01 0603 	add.w	r6, r1, r3
	if (opa != LV_OPA_COVER) {
    848a:	d027      	beq.n	84dc <lvgl_set_px_cb_24bit+0x6c>
static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    848c:	5ccd      	ldrb	r5, [r1, r3]
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    848e:	f896 c001 	ldrb.w	ip, [r6, #1]
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    8492:	b2a2      	uxth	r2, r4
    8494:	f1c4 04ff 	rsb	r4, r4, #255	; 0xff
    8498:	fb15 f504 	smulbb	r5, r5, r4
    849c:	f3c0 4707 	ubfx	r7, r0, #16, #8
    84a0:	fb07 5702 	mla	r7, r7, r2, r5
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    84a4:	fb1c fc04 	smulbb	ip, ip, r4
    84a8:	f3c0 2507 	ubfx	r5, r0, #8, #8
    84ac:	fb05 c502 	mla	r5, r5, r2, ip
    LV_COLOR_SET_B(ret, (uint16_t)((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) * (255 - mix)) >> 8);
    84b0:	f896 c002 	ldrb.w	ip, [r6, #2]
    84b4:	fa5f fe80 	uxtb.w	lr, r0
    84b8:	fb1c f404 	smulbb	r4, ip, r4
    84bc:	fb0e 4202 	mla	r2, lr, r2, r4
    84c0:	f3c2 2207 	ubfx	r2, r2, #8, #8
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    84c4:	f3c5 2507 	ubfx	r5, r5, #8, #8
    84c8:	f362 0007 	bfi	r0, r2, #0, #8
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    84cc:	f3c7 2707 	ubfx	r7, r7, #8, #8
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
    84d0:	f365 200f 	bfi	r0, r5, #8, #8
    84d4:	f367 4017 	bfi	r0, r7, #16, #8
    84d8:	f040 407f 	orr.w	r0, r0, #4278190080	; 0xff000000
		color = lv_color_mix(color, mix_color, opa);
	}
#endif

	converted_color.full = lv_color_to32(color);
	*buf_xy = converted_color.ch.red;
    84dc:	f3c0 4207 	ubfx	r2, r0, #16, #8
    84e0:	54ca      	strb	r2, [r1, r3]
	*(buf_xy + 1) = converted_color.ch.green;
    84e2:	f3c0 2307 	ubfx	r3, r0, #8, #8
    84e6:	7073      	strb	r3, [r6, #1]
	*(buf_xy + 2) = converted_color.ch.blue;
    84e8:	70b0      	strb	r0, [r6, #2]
}
    84ea:	bdf0      	pop	{r4, r5, r6, r7, pc}

000084ec <lvgl_flush_cb_32bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_32bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
    84ec:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct device *display_dev = (struct device *)disp_drv->user_data;
	u16_t w = area->x2 - area->x1 + 1;
    84ee:	888b      	ldrh	r3, [r1, #4]
	u16_t h = area->y2 - area->y1 + 1;
    84f0:	88cc      	ldrh	r4, [r1, #6]
	u16_t w = area->x2 - area->x1 + 1;
    84f2:	f9b1 6000 	ldrsh.w	r6, [r1]
	u16_t h = area->y2 - area->y1 + 1;
    84f6:	f9b1 7002 	ldrsh.w	r7, [r1, #2]
	u16_t w = area->x2 - area->x1 + 1;
    84fa:	3301      	adds	r3, #1
	u16_t h = area->y2 - area->y1 + 1;
    84fc:	3401      	adds	r4, #1
{
    84fe:	b087      	sub	sp, #28
    8500:	4605      	mov	r5, r0
	u16_t w = area->x2 - area->x1 + 1;
    8502:	1b9b      	subs	r3, r3, r6
	struct device *display_dev = (struct device *)disp_drv->user_data;
    8504:	6a00      	ldr	r0, [r0, #32]
	u16_t h = area->y2 - area->y1 + 1;
    8506:	1be4      	subs	r4, r4, r7
	u16_t w = area->x2 - area->x1 + 1;
    8508:	b29b      	uxth	r3, r3
	u16_t h = area->y2 - area->y1 + 1;
    850a:	b2a4      	uxth	r4, r4
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 4U * h;
    850c:	fb04 f103 	mul.w	r1, r4, r3
	desc.width = w;
    8510:	f8ad 3010 	strh.w	r3, [sp, #16]
	desc.pitch = w;
    8514:	f8ad 3014 	strh.w	r3, [sp, #20]
    8518:	6843      	ldr	r3, [r0, #4]
    851a:	9200      	str	r2, [sp, #0]
	desc.buf_size = w * 4U * h;
    851c:	0089      	lsls	r1, r1, #2
    851e:	9103      	str	r1, [sp, #12]
	desc.height = h;
    8520:	f8ad 4012 	strh.w	r4, [sp, #18]
    8524:	b2ba      	uxth	r2, r7
    8526:	689c      	ldr	r4, [r3, #8]
    8528:	b2b1      	uxth	r1, r6
    852a:	ab03      	add	r3, sp, #12
    852c:	47a0      	blx	r4
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);

	lv_disp_flush_ready(disp_drv);
    852e:	4628      	mov	r0, r5
    8530:	f001 fe65 	bl	a1fe <lv_disp_flush_ready>
}
    8534:	b007      	add	sp, #28
    8536:	bdf0      	pop	{r4, r5, r6, r7, pc}

00008538 <lvgl_free>:
}

void lvgl_free(void *ptr)
{
	k_free(ptr);
    8538:	f002 bba5 	b.w	ac86 <k_free>

0000853c <z_platform_init>:

void z_platform_init(void)
{
	SystemInit();
    853c:	f7fa bde2 	b.w	3104 <SystemInit>

00008540 <gpio_nrfx_write>:
{
    8540:	b510      	push	{r4, lr}
	return port->config->config_info;
    8542:	6804      	ldr	r4, [r0, #0]
    8544:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    8546:	68a4      	ldr	r4, [r4, #8]
    8548:	69c0      	ldr	r0, [r0, #28]
    854a:	6824      	ldr	r4, [r4, #0]
	if (access_op == GPIO_ACCESS_BY_PORT) {
    854c:	2901      	cmp	r1, #1
    854e:	d104      	bne.n	855a <gpio_nrfx_write+0x1a>
		nrf_gpio_port_out_write(reg, value ^ data->inverted);
    8550:	4058      	eors	r0, r3
    p_reg->OUT = value;
    8552:	f8c4 0504 	str.w	r0, [r4, #1284]	; 0x504
}
    8556:	2000      	movs	r0, #0
    8558:	bd10      	pop	{r4, pc}
		if ((value > 0) ^ ((BIT(pin) & data->inverted) != 0)) {
    855a:	3300      	adds	r3, #0
    855c:	fa20 f002 	lsr.w	r0, r0, r2
    8560:	f04f 0101 	mov.w	r1, #1
    8564:	bf18      	it	ne
    8566:	2301      	movne	r3, #1
    8568:	f000 0001 	and.w	r0, r0, #1
    856c:	4091      	lsls	r1, r2
    856e:	4283      	cmp	r3, r0
    p_reg->OUTSET = set_mask;
    8570:	bf14      	ite	ne
    8572:	f8c4 1508 	strne.w	r1, [r4, #1288]	; 0x508
    p_reg->OUTCLR = clr_mask;
    8576:	f8c4 150c 	streq.w	r1, [r4, #1292]	; 0x50c
    857a:	e7ec      	b.n	8556 <gpio_nrfx_write+0x16>

0000857c <gpio_nrfx_read>:
{
    857c:	b570      	push	{r4, r5, r6, lr}
	return port->config->config_info;
    857e:	6804      	ldr	r4, [r0, #0]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
    8580:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    8582:	68a4      	ldr	r4, [r4, #8]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
    8584:	69c0      	ldr	r0, [r0, #28]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    8586:	6825      	ldr	r5, [r4, #0]
    return p_reg->DIR;
    8588:	f8d5 6514 	ldr.w	r6, [r5, #1300]	; 0x514
    return p_reg->IN;
    858c:	f8d5 4510 	ldr.w	r4, [r5, #1296]	; 0x510
    return p_reg->OUT;
    8590:	f8d5 5504 	ldr.w	r5, [r5, #1284]	; 0x504
	u32_t port_val = (port_in | port_out) ^ data->inverted;
    8594:	4060      	eors	r0, r4
    8596:	406c      	eors	r4, r5
    8598:	4034      	ands	r4, r6
    859a:	4060      	eors	r0, r4
	if (access_op == GPIO_ACCESS_BY_PORT) {
    859c:	2901      	cmp	r1, #1
		*value = (port_val & BIT(pin)) ? 1 : 0;
    859e:	bf1c      	itt	ne
    85a0:	40d0      	lsrne	r0, r2
    85a2:	f000 0001 	andne.w	r0, r0, #1
    85a6:	6018      	str	r0, [r3, #0]
}
    85a8:	2000      	movs	r0, #0
    85aa:	bd70      	pop	{r4, r5, r6, pc}

000085ac <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
    85ac:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_IS_EMPTY(slist)
    85ae:	6818      	ldr	r0, [r3, #0]
{
    85b0:	b530      	push	{r4, r5, lr}
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
    85b2:	b158      	cbz	r0, 85cc <gpio_nrfx_manage_callback+0x20>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    85b4:	2400      	movs	r4, #0
    85b6:	4281      	cmp	r1, r0
    85b8:	d113      	bne.n	85e2 <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
    85ba:	6808      	ldr	r0, [r1, #0]
    85bc:	b95c      	cbnz	r4, 85d6 <gpio_nrfx_manage_callback+0x2a>
    85be:	685c      	ldr	r4, [r3, #4]
	list->head = node;
    85c0:	6018      	str	r0, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
    85c2:	42a1      	cmp	r1, r4
    85c4:	d100      	bne.n	85c8 <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
    85c6:	6058      	str	r0, [r3, #4]
	parent->next = child;
    85c8:	2000      	movs	r0, #0
    85ca:	6008      	str	r0, [r1, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
    85cc:	b972      	cbnz	r2, 85ec <gpio_nrfx_manage_callback+0x40>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
    85ce:	2000      	movs	r0, #0
}
    85d0:	bd30      	pop	{r4, r5, pc}
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    85d2:	4628      	mov	r0, r5
    85d4:	e7ef      	b.n	85b6 <gpio_nrfx_manage_callback+0xa>
	parent->next = child;
    85d6:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
    85d8:	6858      	ldr	r0, [r3, #4]
    85da:	4281      	cmp	r1, r0
	list->tail = node;
    85dc:	bf08      	it	eq
    85de:	605c      	streq	r4, [r3, #4]
    85e0:	e7f2      	b.n	85c8 <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    85e2:	6805      	ldr	r5, [r0, #0]
	return node->next;
    85e4:	4604      	mov	r4, r0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    85e6:	2d00      	cmp	r5, #0
    85e8:	d1f3      	bne.n	85d2 <gpio_nrfx_manage_callback+0x26>
			if (!set) {
    85ea:	b13a      	cbz	r2, 85fc <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
    85ec:	681a      	ldr	r2, [r3, #0]
	parent->next = child;
    85ee:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
    85f0:	6858      	ldr	r0, [r3, #4]
	list->head = node;
    85f2:	6019      	str	r1, [r3, #0]
Z_GENLIST_PREPEND(slist, snode)
    85f4:	2800      	cmp	r0, #0
    85f6:	d1ea      	bne.n	85ce <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
    85f8:	6059      	str	r1, [r3, #4]
    85fa:	e7e9      	b.n	85d0 <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
    85fc:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
    8600:	e7e6      	b.n	85d0 <gpio_nrfx_manage_callback+0x24>

00008602 <gpio_nrfx_config>:
{
    8602:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8606:	4680      	mov	r8, r0
	struct gpio_nrfx_data *data = get_port_data(port);
    8608:	6885      	ldr	r5, [r0, #8]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
    860a:	f403 4070 	and.w	r0, r3, #61440	; 0xf000
    860e:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
{
    8612:	461e      	mov	r6, r3
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
    8614:	d041      	beq.n	869a <gpio_nrfx_config+0x98>
    8616:	dc09      	bgt.n	862c <gpio_nrfx_config+0x2a>
    8618:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
    861c:	d03f      	beq.n	869e <gpio_nrfx_config+0x9c>
    861e:	f5b0 5f40 	cmp.w	r0, #12288	; 0x3000
    8622:	d03e      	beq.n	86a2 <gpio_nrfx_config+0xa0>
    8624:	b190      	cbz	r0, 864c <gpio_nrfx_config+0x4a>
		return -EINVAL;
    8626:	f06f 0015 	mvn.w	r0, #21
    862a:	e033      	b.n	8694 <gpio_nrfx_config+0x92>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
    862c:	f5b0 4fe0 	cmp.w	r0, #28672	; 0x7000
    8630:	d039      	beq.n	86a6 <gpio_nrfx_config+0xa4>
    8632:	dc04      	bgt.n	863e <gpio_nrfx_config+0x3c>
    8634:	f5b0 4fa0 	cmp.w	r0, #20480	; 0x5000
    8638:	d1f5      	bne.n	8626 <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0H1;
    863a:	2003      	movs	r0, #3
    863c:	e006      	b.n	864c <gpio_nrfx_config+0x4a>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
    863e:	f5b0 4f40 	cmp.w	r0, #49152	; 0xc000
    8642:	d032      	beq.n	86aa <gpio_nrfx_config+0xa8>
    8644:	f5b0 4f50 	cmp.w	r0, #53248	; 0xd000
    8648:	d1ed      	bne.n	8626 <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0D1;
    864a:	2007      	movs	r0, #7
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
    864c:	f406 7740 	and.w	r7, r6, #768	; 0x300
    8650:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
    8654:	d02b      	beq.n	86ae <gpio_nrfx_config+0xac>
		pull = NRF_GPIO_PIN_NOPULL;
    8656:	f5a7 7400 	sub.w	r4, r7, #512	; 0x200
    865a:	4263      	negs	r3, r4
    865c:	4163      	adcs	r3, r4
	dir = ((flags & GPIO_DIR_MASK) == GPIO_DIR_OUT)
    865e:	f006 0c01 	and.w	ip, r6, #1
                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
    8662:	ea4f 074c 	mov.w	r7, ip, lsl #1
	if (access_op == GPIO_ACCESS_BY_PORT) {
    8666:	2901      	cmp	r1, #1
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
    8668:	ea47 070c 	orr.w	r7, r7, ip
		from_pin = pin;
    866c:	bf18      	it	ne
    866e:	b2d4      	uxtbne	r4, r2
    8670:	ea47 2000 	orr.w	r0, r7, r0, lsl #8
    8674:	ea40 0783 	orr.w	r7, r0, r3, lsl #2
		to_pin   = pin;
    8678:	bf12      	itee	ne
    867a:	46a1      	movne	r9, r4
		to_pin   = 31U;
    867c:	f04f 091f 	moveq.w	r9, #31
		from_pin = 0U;
    8680:	2400      	moveq	r4, #0
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    8682:	f04f 4aa0 	mov.w	sl, #1342177280	; 0x50000000
    8686:	f04f 0b01 	mov.w	fp, #1
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
    868a:	f006 0302 	and.w	r3, r6, #2
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    868e:	45a1      	cmp	r9, r4
    8690:	d20f      	bcs.n	86b2 <gpio_nrfx_config+0xb0>
	return 0;
    8692:	2000      	movs	r0, #0
}
    8694:	b003      	add	sp, #12
    8696:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		drive = NRF_GPIO_PIN_S0H1;
    869a:	2002      	movs	r0, #2
    869c:	e7d6      	b.n	864c <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_H0S1;
    869e:	2001      	movs	r0, #1
    86a0:	e7d4      	b.n	864c <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0S1;
    86a2:	2004      	movs	r0, #4
    86a4:	e7d2      	b.n	864c <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0H1;
    86a6:	2005      	movs	r0, #5
    86a8:	e7d0      	b.n	864c <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_S0D1;
    86aa:	2006      	movs	r0, #6
    86ac:	e7ce      	b.n	864c <gpio_nrfx_config+0x4a>
		pull = NRF_GPIO_PIN_PULLUP;
    86ae:	2303      	movs	r3, #3
    86b0:	e7d5      	b.n	865e <gpio_nrfx_config+0x5c>
	return port->config->config_info;
    86b2:	f8d8 2000 	ldr.w	r2, [r8]
		nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num,
    86b6:	6892      	ldr	r2, [r2, #8]
    86b8:	7911      	ldrb	r1, [r2, #4]
    86ba:	f004 021f 	and.w	r2, r4, #31
    86be:	ea42 1241 	orr.w	r2, r2, r1, lsl #5
    86c2:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
    86c6:	f84a 7022 	str.w	r7, [sl, r2, lsl #2]
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
    86ca:	fa0b f204 	lsl.w	r2, fp, r4
    86ce:	68a9      	ldr	r1, [r5, #8]
    86d0:	2b00      	cmp	r3, #0
    86d2:	d025      	beq.n	8720 <gpio_nrfx_config+0x11e>
    86d4:	4311      	orrs	r1, r2
    86d6:	60a9      	str	r1, [r5, #8]
		WRITE_BIT(data->trig_edge, curr_pin, flags & GPIO_INT_EDGE);
    86d8:	6969      	ldr	r1, [r5, #20]
    86da:	9301      	str	r3, [sp, #4]
    86dc:	06b0      	lsls	r0, r6, #26
    86de:	bf4c      	ite	mi
    86e0:	4311      	orrmi	r1, r2
    86e2:	4391      	bicpl	r1, r2
    86e4:	6169      	str	r1, [r5, #20]
		WRITE_BIT(data->double_edge, curr_pin,
    86e6:	69a9      	ldr	r1, [r5, #24]
    86e8:	0670      	lsls	r0, r6, #25
    86ea:	bf4c      	ite	mi
    86ec:	4311      	orrmi	r1, r2
    86ee:	4391      	bicpl	r1, r2
    86f0:	61a9      	str	r1, [r5, #24]
		WRITE_BIT(data->active_level, curr_pin,
    86f2:	6929      	ldr	r1, [r5, #16]
    86f4:	0770      	lsls	r0, r6, #29
    86f6:	bf4c      	ite	mi
    86f8:	4311      	orrmi	r1, r2
    86fa:	4391      	bicpl	r1, r2
    86fc:	6129      	str	r1, [r5, #16]
		WRITE_BIT(data->inverted, curr_pin, flags & GPIO_POL_INV);
    86fe:	69e9      	ldr	r1, [r5, #28]
    8700:	0630      	lsls	r0, r6, #24
    8702:	bf4c      	ite	mi
    8704:	430a      	orrmi	r2, r1
    8706:	ea21 0202 	bicpl.w	r2, r1, r2
    870a:	61ea      	str	r2, [r5, #28]
		res = gpiote_pin_int_cfg(port, curr_pin);
    870c:	4621      	mov	r1, r4
    870e:	4640      	mov	r0, r8
    8710:	f7fa f81c 	bl	274c <gpiote_pin_int_cfg>
		if (res != 0) {
    8714:	2800      	cmp	r0, #0
    8716:	d1bd      	bne.n	8694 <gpio_nrfx_config+0x92>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    8718:	3401      	adds	r4, #1
    871a:	b2e4      	uxtb	r4, r4
    871c:	9b01      	ldr	r3, [sp, #4]
    871e:	e7b6      	b.n	868e <gpio_nrfx_config+0x8c>
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
    8720:	ea21 0102 	bic.w	r1, r1, r2
    8724:	e7d7      	b.n	86d6 <gpio_nrfx_config+0xd4>

00008726 <gpio_nrfx_pin_disable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
    8726:	2901      	cmp	r1, #1
{
    8728:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
    872c:	bf18      	it	ne
    872e:	b2d4      	uxtbne	r4, r2
	struct gpio_nrfx_data *data = get_port_data(port);
    8730:	6887      	ldr	r7, [r0, #8]
{
    8732:	4606      	mov	r6, r0
		to_pin   = pin;
    8734:	bf12      	itee	ne
    8736:	4625      	movne	r5, r4
		to_pin   = 31U;
    8738:	251f      	moveq	r5, #31
		from_pin = 0U;
    873a:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
    873c:	f04f 0801 	mov.w	r8, #1
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    8740:	42ac      	cmp	r4, r5
    8742:	d902      	bls.n	874a <gpio_nrfx_pin_disable_callback+0x24>
	return res;
    8744:	2000      	movs	r0, #0
}
    8746:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
    874a:	68fb      	ldr	r3, [r7, #12]
    874c:	fa08 f204 	lsl.w	r2, r8, r4
    8750:	ea23 0302 	bic.w	r3, r3, r2
    8754:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
    8756:	4621      	mov	r1, r4
    8758:	4630      	mov	r0, r6
    875a:	f7f9 fff7 	bl	274c <gpiote_pin_int_cfg>
		if (res != 0) {
    875e:	2800      	cmp	r0, #0
    8760:	d1f1      	bne.n	8746 <gpio_nrfx_pin_disable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    8762:	3401      	adds	r4, #1
    8764:	b2e4      	uxtb	r4, r4
    8766:	e7eb      	b.n	8740 <gpio_nrfx_pin_disable_callback+0x1a>

00008768 <gpio_nrfx_pin_enable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
    8768:	2901      	cmp	r1, #1
{
    876a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
    876e:	bf18      	it	ne
    8770:	b2d4      	uxtbne	r4, r2
	struct gpio_nrfx_data *data = get_port_data(port);
    8772:	6887      	ldr	r7, [r0, #8]
{
    8774:	4606      	mov	r6, r0
		to_pin   = pin;
    8776:	bf12      	itee	ne
    8778:	4625      	movne	r5, r4
		to_pin   = 31U;
    877a:	251f      	moveq	r5, #31
		from_pin = 0U;
    877c:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
    877e:	f04f 0801 	mov.w	r8, #1
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    8782:	42ac      	cmp	r4, r5
    8784:	d902      	bls.n	878c <gpio_nrfx_pin_enable_callback+0x24>
	return res;
    8786:	2000      	movs	r0, #0
}
    8788:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
    878c:	68fb      	ldr	r3, [r7, #12]
    878e:	fa08 f204 	lsl.w	r2, r8, r4
    8792:	4313      	orrs	r3, r2
    8794:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
    8796:	4621      	mov	r1, r4
    8798:	4630      	mov	r0, r6
    879a:	f7f9 ffd7 	bl	274c <gpiote_pin_int_cfg>
		if (res != 0) {
    879e:	2800      	cmp	r0, #0
    87a0:	d1f2      	bne.n	8788 <gpio_nrfx_pin_enable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    87a2:	3401      	adds	r4, #1
    87a4:	b2e4      	uxtb	r4, r4
    87a6:	e7ec      	b.n	8782 <gpio_nrfx_pin_enable_callback+0x1a>

000087a8 <gpio_pin_write>:
{
    87a8:	b410      	push	{r4}
    87aa:	4613      	mov	r3, r2
	return api->write(port, access_op, pin, value);
    87ac:	6842      	ldr	r2, [r0, #4]
    87ae:	6854      	ldr	r4, [r2, #4]
    87b0:	460a      	mov	r2, r1
    87b2:	46a4      	mov	ip, r4
    87b4:	2100      	movs	r1, #0
}
    87b6:	bc10      	pop	{r4}
	return api->write(port, access_op, pin, value);
    87b8:	4760      	bx	ip

000087ba <_spi_context_cs_control.isra.7>:
static inline void _spi_context_cs_control(struct spi_context *ctx,
    87ba:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
    87bc:	6804      	ldr	r4, [r0, #0]
static inline void _spi_context_cs_control(struct spi_context *ctx,
    87be:	4605      	mov	r5, r0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
    87c0:	b324      	cbz	r4, 880c <_spi_context_cs_control.isra.7+0x52>
    87c2:	68a3      	ldr	r3, [r4, #8]
    87c4:	b313      	cbz	r3, 880c <_spi_context_cs_control.isra.7+0x52>
    87c6:	6818      	ldr	r0, [r3, #0]
    87c8:	b300      	cbz	r0, 880c <_spi_context_cs_control.isra.7+0x52>
		if (on) {
    87ca:	b161      	cbz	r1, 87e6 <_spi_context_cs_control.isra.7+0x2c>
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
    87cc:	f9b4 2004 	ldrsh.w	r2, [r4, #4]
			gpio_pin_write(ctx->config->cs->gpio_dev,
    87d0:	6859      	ldr	r1, [r3, #4]
    87d2:	0fd2      	lsrs	r2, r2, #31
    87d4:	f7ff ffe8 	bl	87a8 <gpio_pin_write>
			k_busy_wait(ctx->config->cs->delay);
    87d8:	682b      	ldr	r3, [r5, #0]
    87da:	689b      	ldr	r3, [r3, #8]
    87dc:	6898      	ldr	r0, [r3, #8]
}
    87de:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_busy_wait(usec_to_wait);
    87e2:	f002 bb40 	b.w	ae66 <z_impl_k_busy_wait>
			if (!force_off &&
    87e6:	b912      	cbnz	r2, 87ee <_spi_context_cs_control.isra.7+0x34>
    87e8:	88a2      	ldrh	r2, [r4, #4]
    87ea:	0492      	lsls	r2, r2, #18
    87ec:	d40e      	bmi.n	880c <_spi_context_cs_control.isra.7+0x52>
			k_busy_wait(ctx->config->cs->delay);
    87ee:	6898      	ldr	r0, [r3, #8]
    87f0:	f002 fb39 	bl	ae66 <z_impl_k_busy_wait>
			gpio_pin_write(ctx->config->cs->gpio_dev,
    87f4:	682a      	ldr	r2, [r5, #0]
    87f6:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
    87f8:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
			gpio_pin_write(ctx->config->cs->gpio_dev,
    87fc:	43d2      	mvns	r2, r2
    87fe:	e9d3 0100 	ldrd	r0, r1, [r3]
    8802:	0fd2      	lsrs	r2, r2, #31
}
    8804:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gpio_pin_write(ctx->config->cs->gpio_dev,
    8808:	f7ff bfce 	b.w	87a8 <gpio_pin_write>
}
    880c:	bd38      	pop	{r3, r4, r5, pc}

0000880e <spi_context_unlock_unconditionally>:
{
    880e:	b510      	push	{r4, lr}
	_spi_context_cs_control(ctx, false, true);
    8810:	2201      	movs	r2, #1
    8812:	2100      	movs	r1, #0
{
    8814:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
    8816:	f7ff ffd0 	bl	87ba <_spi_context_cs_control.isra.7>
	if (!k_sem_count_get(&ctx->lock)) {
    881a:	68e3      	ldr	r3, [r4, #12]
    881c:	b923      	cbnz	r3, 8828 <spi_context_unlock_unconditionally+0x1a>
	z_impl_k_sem_give(sem);
    881e:	1d20      	adds	r0, r4, #4
}
    8820:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    8824:	f7fe bd14 	b.w	7250 <z_impl_k_sem_give>
    8828:	bd10      	pop	{r4, pc}

0000882a <spi_nrfx_release>:
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    882a:	6880      	ldr	r0, [r0, #8]
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
    882c:	6803      	ldr	r3, [r0, #0]
    882e:	428b      	cmp	r3, r1
{
    8830:	b510      	push	{r4, lr}
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
    8832:	d106      	bne.n	8842 <spi_nrfx_release+0x18>
	if (dev_data->busy) {
    8834:	f890 404c 	ldrb.w	r4, [r0, #76]	; 0x4c
    8838:	b934      	cbnz	r4, 8848 <spi_nrfx_release+0x1e>
	spi_context_unlock_unconditionally(&dev_data->ctx);
    883a:	f7ff ffe8 	bl	880e <spi_context_unlock_unconditionally>
	return 0;
    883e:	4620      	mov	r0, r4
}
    8840:	bd10      	pop	{r4, pc}
		return -EINVAL;
    8842:	f06f 0015 	mvn.w	r0, #21
    8846:	e7fb      	b.n	8840 <spi_nrfx_release+0x16>
		return -EBUSY;
    8848:	f06f 000f 	mvn.w	r0, #15
    884c:	e7f8      	b.n	8840 <spi_nrfx_release+0x16>

0000884e <cst816s_channel_get>:
	struct cst816s_data *drv_data = dev->driver_data;
    884e:	6883      	ldr	r3, [r0, #8]
	 val->val1=drv_data->x_sample;
    8850:	f9b3 1004 	ldrsh.w	r1, [r3, #4]
	 val->val2=drv_data->y_sample;
    8854:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
	 val->val1=drv_data->x_sample;
    8858:	6011      	str	r1, [r2, #0]
	 val->val2=drv_data->y_sample;
    885a:	6053      	str	r3, [r2, #4]
}
    885c:	2000      	movs	r0, #0
    885e:	4770      	bx	lr

00008860 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
    8860:	4700      	bx	r0

00008862 <transfer_byte>:
{
    8862:	b537      	push	{r0, r1, r2, r4, r5, lr}
    return p_reg->RXD;
    8864:	f8d0 3518 	ldr.w	r3, [r0, #1304]	; 0x518
    if (p_cb->bytes_transferred < p_cb->evt.xfer_desc.rx_length)
    8868:	698a      	ldr	r2, [r1, #24]
    886a:	b2db      	uxtb	r3, r3
    volatile uint8_t rx_data = nrf_spi_rxd_get(p_spi);
    886c:	f88d 3007 	strb.w	r3, [sp, #7]
    if (p_cb->bytes_transferred < p_cb->evt.xfer_desc.rx_length)
    8870:	6a4b      	ldr	r3, [r1, #36]	; 0x24
    8872:	4293      	cmp	r3, r2
        p_cb->evt.xfer_desc.p_rx_buffer[p_cb->bytes_transferred] = rx_data;
    8874:	bf3e      	ittt	cc
    8876:	694a      	ldrcc	r2, [r1, #20]
    8878:	f89d 4007 	ldrbcc.w	r4, [sp, #7]
    887c:	54d4      	strbcc	r4, [r2, r3]
    ++p_cb->bytes_transferred;
    887e:	6a4a      	ldr	r2, [r1, #36]	; 0x24
    if (p_cb->abort)
    8880:	f891 4028 	ldrb.w	r4, [r1, #40]	; 0x28
    ++p_cb->bytes_transferred;
    8884:	1c53      	adds	r3, r2, #1
    8886:	624b      	str	r3, [r1, #36]	; 0x24
    size_t bytes_used = p_cb->bytes_transferred + 1;
    8888:	3202      	adds	r2, #2
    if (p_cb->abort)
    888a:	b13c      	cbz	r4, 889c <transfer_byte+0x3a>
        if (bytes_used < p_cb->evt.xfer_desc.tx_length)
    888c:	690c      	ldr	r4, [r1, #16]
    888e:	42a2      	cmp	r2, r4
        if (bytes_used < p_cb->evt.xfer_desc.rx_length)
    8890:	698c      	ldr	r4, [r1, #24]
            p_cb->evt.xfer_desc.tx_length = bytes_used;
    8892:	bf38      	it	cc
    8894:	610a      	strcc	r2, [r1, #16]
        if (bytes_used < p_cb->evt.xfer_desc.rx_length)
    8896:	4294      	cmp	r4, r2
            p_cb->evt.xfer_desc.rx_length = bytes_used;
    8898:	bf88      	it	hi
    889a:	618a      	strhi	r2, [r1, #24]
    if (bytes_used < p_cb->evt.xfer_desc.tx_length)
    889c:	690d      	ldr	r5, [r1, #16]
    889e:	4295      	cmp	r5, r2
    88a0:	d905      	bls.n	88ae <transfer_byte+0x4c>
        nrf_spi_txd_set(p_spi, p_cb->evt.xfer_desc.p_tx_buffer[bytes_used]);
    88a2:	68cb      	ldr	r3, [r1, #12]
    p_reg->TXD = data;
    88a4:	5c9b      	ldrb	r3, [r3, r2]
    88a6:	f8c0 351c 	str.w	r3, [r0, #1308]	; 0x51c
    return (p_cb->bytes_transferred < p_cb->evt.xfer_desc.tx_length ||
    88aa:	2001      	movs	r0, #1
    88ac:	e00b      	b.n	88c6 <transfer_byte+0x64>
    else if (bytes_used < p_cb->evt.xfer_desc.rx_length)
    88ae:	698c      	ldr	r4, [r1, #24]
    88b0:	4294      	cmp	r4, r2
    88b2:	d902      	bls.n	88ba <transfer_byte+0x58>
    88b4:	f891 3020 	ldrb.w	r3, [r1, #32]
    88b8:	e7f5      	b.n	88a6 <transfer_byte+0x44>
    return (p_cb->bytes_transferred < p_cb->evt.xfer_desc.tx_length ||
    88ba:	42ab      	cmp	r3, r5
    88bc:	d3f5      	bcc.n	88aa <transfer_byte+0x48>
    88be:	42a3      	cmp	r3, r4
    88c0:	bf2c      	ite	cs
    88c2:	2000      	movcs	r0, #0
    88c4:	2001      	movcc	r0, #1
}
    88c6:	b003      	add	sp, #12
    88c8:	bd30      	pop	{r4, r5, pc}

000088ca <nrf_twi_event_clear>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    88ca:	2300      	movs	r3, #0
    88cc:	5043      	str	r3, [r0, r1]
{
    88ce:	b082      	sub	sp, #8
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    88d0:	5843      	ldr	r3, [r0, r1]
    88d2:	9301      	str	r3, [sp, #4]
    (void)dummy;
    88d4:	9b01      	ldr	r3, [sp, #4]
}
    88d6:	b002      	add	sp, #8
    88d8:	4770      	bx	lr

000088da <twi_send_byte>:
    if (p_cb->bytes_transferred < p_cb->curr_length)
    88da:	6b4b      	ldr	r3, [r1, #52]	; 0x34
    88dc:	6a8a      	ldr	r2, [r1, #40]	; 0x28
    88de:	4293      	cmp	r3, r2
    88e0:	d208      	bcs.n	88f4 <twi_send_byte+0x1a>
        nrf_twi_txd_set(p_twi, p_cb->p_curr_buf[p_cb->bytes_transferred]);
    88e2:	6a4a      	ldr	r2, [r1, #36]	; 0x24
    p_reg->TXD = data;
    88e4:	5cd2      	ldrb	r2, [r2, r3]
    88e6:	f8c0 251c 	str.w	r2, [r0, #1308]	; 0x51c
        ++(p_cb->bytes_transferred);
    88ea:	3301      	adds	r3, #1
    88ec:	634b      	str	r3, [r1, #52]	; 0x34
    return true;
    88ee:	2301      	movs	r3, #1
}
    88f0:	4618      	mov	r0, r3
    88f2:	4770      	bx	lr
        if (p_cb->curr_tx_no_stop)
    88f4:	f891 302c 	ldrb.w	r3, [r1, #44]	; 0x2c
    88f8:	b11b      	cbz	r3, 8902 <twi_send_byte+0x28>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    88fa:	2301      	movs	r3, #1
    88fc:	61c3      	str	r3, [r0, #28]
            return false;
    88fe:	2300      	movs	r3, #0
    8900:	e7f6      	b.n	88f0 <twi_send_byte+0x16>
        else if(TWI_FLAG_SUSPEND(p_cb->flags))
    8902:	6a0a      	ldr	r2, [r1, #32]
    8904:	f012 0f40 	tst.w	r2, #64	; 0x40
    8908:	f04f 0201 	mov.w	r2, #1
    890c:	bf15      	itete	ne
    890e:	61c2      	strne	r2, [r0, #28]
    8910:	6142      	streq	r2, [r0, #20]
            p_cb->prev_suspend = TWI_SUSPEND_TX;
    8912:	f881 202d 	strbne.w	r2, [r1, #45]	; 0x2d
    return true;
    8916:	4613      	moveq	r3, r2
    8918:	e7ea      	b.n	88f0 <twi_send_byte+0x16>

0000891a <twi_transfer>:
    bool do_stop_check = ((p_cb->error) || ((p_cb->bytes_transferred) == p_cb->curr_length));
    891a:	f891 202f 	ldrb.w	r2, [r1, #47]	; 0x2f
{
    891e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8920:	4604      	mov	r4, r0
    8922:	460d      	mov	r5, r1
    bool do_stop_check = ((p_cb->error) || ((p_cb->bytes_transferred) == p_cb->curr_length));
    8924:	2a00      	cmp	r2, #0
    8926:	d160      	bne.n	89ea <twi_transfer+0xd0>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8928:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
    892c:	6b4e      	ldr	r6, [r1, #52]	; 0x34
    892e:	6a8f      	ldr	r7, [r1, #40]	; 0x28
    else if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_ERROR))
    8930:	b1b3      	cbz	r3, 8960 <twi_transfer+0x46>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
    8932:	f44f 7192 	mov.w	r1, #292	; 0x124
                nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
    8936:	f7ff ffc8 	bl	88ca <nrf_twi_event_clear>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    893a:	2301      	movs	r3, #1
    893c:	6163      	str	r3, [r4, #20]
                p_cb->error = true;
    893e:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    if (do_stop_check && nrf_twi_event_check(p_twi, NRF_TWI_EVENT_STOPPED))
    8942:	42be      	cmp	r6, r7
    8944:	d14f      	bne.n	89e6 <twi_transfer+0xcc>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8946:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    894a:	2b00      	cmp	r3, #0
    894c:	d04b      	beq.n	89e6 <twi_transfer+0xcc>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
    894e:	f44f 7182 	mov.w	r1, #260	; 0x104
    8952:	4620      	mov	r0, r4
    8954:	f7ff ffb9 	bl	88ca <nrf_twi_event_clear>
        p_cb->prev_suspend = TWI_NO_SUSPEND;
    8958:	2200      	movs	r2, #0
    895a:	f885 202d 	strb.w	r2, [r5, #45]	; 0x2d
        return false;
    895e:	e013      	b.n	8988 <twi_transfer+0x6e>
    8960:	f8d0 311c 	ldr.w	r3, [r0, #284]	; 0x11c
        if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_TXDSENT))
    8964:	b193      	cbz	r3, 898c <twi_transfer+0x72>
            nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_TXDSENT);
    8966:	f44f 718e 	mov.w	r1, #284	; 0x11c
    896a:	f7ff ffae 	bl	88ca <nrf_twi_event_clear>
    896e:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
            if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_ERROR))
    8972:	b11b      	cbz	r3, 897c <twi_transfer+0x62>
                nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
    8974:	f44f 7192 	mov.w	r1, #292	; 0x124
    8978:	4620      	mov	r0, r4
    897a:	e7dc      	b.n	8936 <twi_transfer+0x1c>
                if (!twi_send_byte(p_twi, p_cb))
    897c:	4629      	mov	r1, r5
    897e:	f7ff ffac 	bl	88da <twi_send_byte>
    8982:	4602      	mov	r2, r0
    8984:	2800      	cmp	r0, #0
    8986:	d1dc      	bne.n	8942 <twi_transfer+0x28>
}
    8988:	4610      	mov	r0, r2
    898a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    898c:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
        else if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_RXDREADY))
    8990:	2b00      	cmp	r3, #0
    8992:	d0d6      	beq.n	8942 <twi_transfer+0x28>
            nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_RXDREADY);
    8994:	f44f 7184 	mov.w	r1, #264	; 0x108
    8998:	f7ff ff97 	bl	88ca <nrf_twi_event_clear>
    899c:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
            if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_ERROR))
    89a0:	2b00      	cmp	r3, #0
    89a2:	d1e7      	bne.n	8974 <twi_transfer+0x5a>
    if (p_cb->bytes_transferred < p_cb->curr_length)
    89a4:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    89a6:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    89a8:	428b      	cmp	r3, r1
    89aa:	d2ca      	bcs.n	8942 <twi_transfer+0x28>
        p_cb->p_curr_buf[p_cb->bytes_transferred] = nrf_twi_rxd_get(p_twi);
    89ac:	6a69      	ldr	r1, [r5, #36]	; 0x24
    return (uint8_t)p_reg->RXD;
    89ae:	f8d0 0518 	ldr.w	r0, [r0, #1304]	; 0x518
    89b2:	54c8      	strb	r0, [r1, r3]
        ++(p_cb->bytes_transferred);
    89b4:	6b6b      	ldr	r3, [r5, #52]	; 0x34
        if ((p_cb->bytes_transferred == p_cb->curr_length - 1) && (!TWI_FLAG_SUSPEND(p_cb->flags)))
    89b6:	6aa9      	ldr	r1, [r5, #40]	; 0x28
        ++(p_cb->bytes_transferred);
    89b8:	3301      	adds	r3, #1
        if ((p_cb->bytes_transferred == p_cb->curr_length - 1) && (!TWI_FLAG_SUSPEND(p_cb->flags)))
    89ba:	1e48      	subs	r0, r1, #1
    89bc:	4283      	cmp	r3, r0
        ++(p_cb->bytes_transferred);
    89be:	636b      	str	r3, [r5, #52]	; 0x34
        if ((p_cb->bytes_transferred == p_cb->curr_length - 1) && (!TWI_FLAG_SUSPEND(p_cb->flags)))
    89c0:	d108      	bne.n	89d4 <twi_transfer+0xba>
    89c2:	6a28      	ldr	r0, [r5, #32]
    89c4:	0640      	lsls	r0, r0, #25
    89c6:	d41d      	bmi.n	8a04 <twi_transfer+0xea>
    p_reg->SHORTS = mask;
    89c8:	2302      	movs	r3, #2
    89ca:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    89ce:	2301      	movs	r3, #1
    89d0:	6223      	str	r3, [r4, #32]
    89d2:	e7b6      	b.n	8942 <twi_transfer+0x28>
        else if (p_cb->bytes_transferred == p_cb->curr_length && (!TWI_FLAG_SUSPEND(p_cb->flags)))
    89d4:	428b      	cmp	r3, r1
    89d6:	d1fa      	bne.n	89ce <twi_transfer+0xb4>
    89d8:	6a2b      	ldr	r3, [r5, #32]
    89da:	065b      	lsls	r3, r3, #25
    89dc:	d5b1      	bpl.n	8942 <twi_transfer+0x28>
            p_cb->prev_suspend = TWI_SUSPEND_RX;
    89de:	2302      	movs	r3, #2
    89e0:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
            return false;
    89e4:	e7d0      	b.n	8988 <twi_transfer+0x6e>
    return true;
    89e6:	2201      	movs	r2, #1
    89e8:	e7ce      	b.n	8988 <twi_transfer+0x6e>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
    89ea:	f44f 7192 	mov.w	r1, #292	; 0x124
    89ee:	f7ff ff6c 	bl	88ca <nrf_twi_event_clear>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_TXDSENT);
    89f2:	f44f 718e 	mov.w	r1, #284	; 0x11c
    89f6:	f7ff ff68 	bl	88ca <nrf_twi_event_clear>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_RXDREADY);
    89fa:	f44f 7184 	mov.w	r1, #264	; 0x108
    89fe:	f7ff ff64 	bl	88ca <nrf_twi_event_clear>
    if (do_stop_check && nrf_twi_event_check(p_twi, NRF_TWI_EVENT_STOPPED))
    8a02:	e7a0      	b.n	8946 <twi_transfer+0x2c>
        else if (p_cb->bytes_transferred == p_cb->curr_length && (!TWI_FLAG_SUSPEND(p_cb->flags)))
    8a04:	428b      	cmp	r3, r1
    8a06:	d1e2      	bne.n	89ce <twi_transfer+0xb4>
    8a08:	e7e9      	b.n	89de <twi_transfer+0xc4>

00008a0a <lv_indev_reset.part.5>:
}
/**
 * Reset one or all input devices
 * @param indev pointer to an input device to reset or NULL to reset all of them
 */
void lv_indev_reset(lv_indev_t * indev)
    8a0a:	b508      	push	{r3, lr}
{
    if(indev)
        indev->proc.reset_query = 1;
    else {
        lv_indev_t * i = lv_indev_get_next(NULL);
    8a0c:	2000      	movs	r0, #0
        while(i) {
            i->proc.reset_query = 1;

            i = lv_indev_get_next(i);
    8a0e:	f7fc fd93 	bl	5538 <lv_indev_get_next>
        while(i) {
    8a12:	b900      	cbnz	r0, 8a16 <lv_indev_reset.part.5+0xc>
        }
    }
}
    8a14:	bd08      	pop	{r3, pc}
            i->proc.reset_query = 1;
    8a16:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
    8a1a:	f043 0302 	orr.w	r3, r3, #2
    8a1e:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50
    8a22:	e7f4      	b.n	8a0e <lv_indev_reset.part.5+0x4>

00008a24 <lv_indev_init>:
    if(indev)
    8a24:	f7ff bff1 	b.w	8a0a <lv_indev_reset.part.5>

00008a28 <refresh_children_position>:
 * @param obj pointer to an object which children will be repositioned
 * @param x_diff x coordinate shift
 * @param y_diff y coordinate shift
 */
static void refresh_children_position(lv_obj_t * obj, lv_coord_t x_diff, lv_coord_t y_diff)
{
    8a28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    lv_obj_t * i;
    LV_LL_READ(obj->child_ll, i)
    8a2a:	1d07      	adds	r7, r0, #4
    8a2c:	4638      	mov	r0, r7
{
    8a2e:	460d      	mov	r5, r1
    8a30:	4616      	mov	r6, r2
    LV_LL_READ(obj->child_ll, i)
    8a32:	f001 fd56 	bl	a4e2 <lv_ll_get_head>
    8a36:	4604      	mov	r4, r0
    8a38:	b900      	cbnz	r0, 8a3c <refresh_children_position+0x14>
        i->coords.x2 += x_diff;
        i->coords.y2 += y_diff;

        refresh_children_position(i, x_diff, y_diff);
    }
}
    8a3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        i->coords.x1 += x_diff;
    8a3c:	8a23      	ldrh	r3, [r4, #16]
    8a3e:	442b      	add	r3, r5
    8a40:	8223      	strh	r3, [r4, #16]
        i->coords.y1 += y_diff;
    8a42:	8a63      	ldrh	r3, [r4, #18]
    8a44:	4433      	add	r3, r6
    8a46:	8263      	strh	r3, [r4, #18]
        i->coords.x2 += x_diff;
    8a48:	8aa3      	ldrh	r3, [r4, #20]
    8a4a:	442b      	add	r3, r5
    8a4c:	82a3      	strh	r3, [r4, #20]
        i->coords.y2 += y_diff;
    8a4e:	8ae3      	ldrh	r3, [r4, #22]
    8a50:	4433      	add	r3, r6
        refresh_children_position(i, x_diff, y_diff);
    8a52:	4629      	mov	r1, r5
    8a54:	4620      	mov	r0, r4
        i->coords.y2 += y_diff;
    8a56:	82e3      	strh	r3, [r4, #22]
        refresh_children_position(i, x_diff, y_diff);
    8a58:	4632      	mov	r2, r6
    8a5a:	f7ff ffe5 	bl	8a28 <refresh_children_position>
    LV_LL_READ(obj->child_ll, i)
    8a5e:	4621      	mov	r1, r4
    8a60:	4638      	mov	r0, r7
    8a62:	f001 fd44 	bl	a4ee <lv_ll_get_next>
    8a66:	e7e6      	b.n	8a36 <refresh_children_position+0xe>

00008a68 <lv_obj_set_click>:
    obj->click = (en == true ? 1 : 0);
    8a68:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
    8a6c:	f361 0300 	bfi	r3, r1, #0, #1
    8a70:	f880 302c 	strb.w	r3, [r0, #44]	; 0x2c
}
    8a74:	4770      	bx	lr

00008a76 <lv_obj_set_signal_cb>:
    obj->signal_cb = signal_cb;
    8a76:	61c1      	str	r1, [r0, #28]
}
    8a78:	4770      	bx	lr

00008a7a <lv_obj_set_design_cb>:
    obj->design_cb = design_cb;
    8a7a:	6201      	str	r1, [r0, #32]
}
    8a7c:	4770      	bx	lr

00008a7e <lv_obj_allocate_ext_attr>:
{
    8a7e:	b510      	push	{r4, lr}
    8a80:	4604      	mov	r4, r0
    obj->ext_attr = lv_mem_realloc(obj->ext_attr, ext_size);
    8a82:	6a40      	ldr	r0, [r0, #36]	; 0x24
    8a84:	f7fc fee6 	bl	5854 <lv_mem_realloc>
    8a88:	6260      	str	r0, [r4, #36]	; 0x24
}
    8a8a:	bd10      	pop	{r4, pc}

00008a8c <lv_obj_invalidate>:
    return obj->hidden == 0 ? false : true;
    8a8c:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
{
    8a90:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    if(lv_obj_get_hidden(obj)) return;
    8a92:	06da      	lsls	r2, r3, #27
{
    8a94:	4606      	mov	r6, r0
    if(lv_obj_get_hidden(obj)) return;
    8a96:	d439      	bmi.n	8b0c <lv_obj_invalidate+0x80>
    8a98:	4604      	mov	r4, r0
    return obj->par;
    8a9a:	6823      	ldr	r3, [r4, #0]
    } while(par != NULL);
    8a9c:	bb53      	cbnz	r3, 8af4 <lv_obj_invalidate+0x68>
    lv_disp_t * disp   = lv_obj_get_disp(obj_scr);
    8a9e:	4620      	mov	r0, r4
    8aa0:	f7fb f848 	bl	3b34 <lv_obj_get_disp>
    8aa4:	4607      	mov	r7, r0
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
    8aa6:	f7fa ffcd 	bl	3a44 <lv_disp_get_scr_act>
    8aaa:	4284      	cmp	r4, r0
    8aac:	d124      	bne.n	8af8 <lv_obj_invalidate+0x6c>
    memcpy(dest, src, sizeof(lv_area_t));
    8aae:	2208      	movs	r2, #8
    8ab0:	f106 0110 	add.w	r1, r6, #16
    8ab4:	4668      	mov	r0, sp
        lv_coord_t ext_size = obj->ext_draw_pad;
    8ab6:	f9b6 4030 	ldrsh.w	r4, [r6, #48]	; 0x30
    return obj->par;
    8aba:	6835      	ldr	r5, [r6, #0]
    8abc:	f7ff faf6 	bl	80ac <memcpy>
        area_trunc.x1 -= ext_size;
    8ac0:	f8bd 3000 	ldrh.w	r3, [sp]
    8ac4:	1b1b      	subs	r3, r3, r4
    8ac6:	f8ad 3000 	strh.w	r3, [sp]
        area_trunc.y1 -= ext_size;
    8aca:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    8ace:	1b1b      	subs	r3, r3, r4
    8ad0:	f8ad 3002 	strh.w	r3, [sp, #2]
        area_trunc.x2 += ext_size;
    8ad4:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    8ad8:	4423      	add	r3, r4
    8ada:	f8ad 3004 	strh.w	r3, [sp, #4]
        area_trunc.y2 += ext_size;
    8ade:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    8ae2:	441c      	add	r4, r3
    8ae4:	f8ad 4006 	strh.w	r4, [sp, #6]
        while(par != NULL) {
    8ae8:	b995      	cbnz	r5, 8b10 <lv_obj_invalidate+0x84>
        if(union_ok) lv_inv_area(disp, &area_trunc);
    8aea:	4669      	mov	r1, sp
    8aec:	4638      	mov	r0, r7
    8aee:	f000 fb3d 	bl	916c <lv_inv_area>
    8af2:	e00b      	b.n	8b0c <lv_obj_invalidate+0x80>
    } while(par != NULL);
    8af4:	461c      	mov	r4, r3
    8af6:	e7d0      	b.n	8a9a <lv_obj_invalidate+0xe>
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
    8af8:	4638      	mov	r0, r7
    8afa:	f7fa ffb9 	bl	3a70 <lv_disp_get_layer_top>
    8afe:	4284      	cmp	r4, r0
    8b00:	d0d5      	beq.n	8aae <lv_obj_invalidate+0x22>
       obj_scr == lv_disp_get_layer_sys(disp)) {
    8b02:	4638      	mov	r0, r7
    8b04:	f7fa ffca 	bl	3a9c <lv_disp_get_layer_sys>
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
    8b08:	4284      	cmp	r4, r0
    8b0a:	d0d0      	beq.n	8aae <lv_obj_invalidate+0x22>
}
    8b0c:	b003      	add	sp, #12
    8b0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
            union_ok = lv_area_intersect(&area_trunc, &area_trunc, &par->coords);
    8b10:	f105 0210 	add.w	r2, r5, #16
    8b14:	4669      	mov	r1, sp
    8b16:	4668      	mov	r0, sp
    8b18:	f001 fbd4 	bl	a2c4 <lv_area_intersect>
            if(union_ok == false) break;       /*If no common parts with parent break;*/
    8b1c:	2800      	cmp	r0, #0
    8b1e:	d0f5      	beq.n	8b0c <lv_obj_invalidate+0x80>
    return obj->hidden == 0 ? false : true;
    8b20:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
            if(lv_obj_get_hidden(par)) return; /*If the parent is hidden then the child is hidden and won't be drawn*/
    8b24:	06db      	lsls	r3, r3, #27
    8b26:	d4f1      	bmi.n	8b0c <lv_obj_invalidate+0x80>
    return obj->par;
    8b28:	682d      	ldr	r5, [r5, #0]
    8b2a:	e7dd      	b.n	8ae8 <lv_obj_invalidate+0x5c>

00008b2c <lv_obj_set_pos>:
{
    8b2c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    lv_obj_t * par = obj->par;
    8b2e:	6807      	ldr	r7, [r0, #0]
    diff.x = x - obj->coords.x1;
    8b30:	8a03      	ldrh	r3, [r0, #16]
    8b32:	8a3d      	ldrh	r5, [r7, #16]
    diff.y = y - obj->coords.y1;
    8b34:	8a7e      	ldrh	r6, [r7, #18]
    diff.x = x - obj->coords.x1;
    8b36:	1aed      	subs	r5, r5, r3
    diff.y = y - obj->coords.y1;
    8b38:	8a43      	ldrh	r3, [r0, #18]
    8b3a:	1af6      	subs	r6, r6, r3
    diff.x = x - obj->coords.x1;
    8b3c:	440d      	add	r5, r1
    diff.y = y - obj->coords.y1;
    8b3e:	4416      	add	r6, r2
    diff.x = x - obj->coords.x1;
    8b40:	b22d      	sxth	r5, r5
    diff.y = y - obj->coords.y1;
    8b42:	b236      	sxth	r6, r6
    if(diff.x == 0 && diff.y == 0) return;
    8b44:	ea55 0306 	orrs.w	r3, r5, r6
{
    8b48:	4604      	mov	r4, r0
    if(diff.x == 0 && diff.y == 0) return;
    8b4a:	d025      	beq.n	8b98 <lv_obj_set_pos+0x6c>
    lv_obj_invalidate(obj);
    8b4c:	f7ff ff9e 	bl	8a8c <lv_obj_invalidate>
    8b50:	2208      	movs	r2, #8
    8b52:	f104 0110 	add.w	r1, r4, #16
    8b56:	4668      	mov	r0, sp
    8b58:	f7ff faa8 	bl	80ac <memcpy>
    obj->coords.x1 += diff.x;
    8b5c:	8a23      	ldrh	r3, [r4, #16]
    8b5e:	442b      	add	r3, r5
    8b60:	8223      	strh	r3, [r4, #16]
    obj->coords.y1 += diff.y;
    8b62:	8a63      	ldrh	r3, [r4, #18]
    8b64:	4433      	add	r3, r6
    8b66:	8263      	strh	r3, [r4, #18]
    obj->coords.x2 += diff.x;
    8b68:	8aa3      	ldrh	r3, [r4, #20]
    8b6a:	442b      	add	r3, r5
    8b6c:	82a3      	strh	r3, [r4, #20]
    obj->coords.y2 += diff.y;
    8b6e:	8ae3      	ldrh	r3, [r4, #22]
    8b70:	4433      	add	r3, r6
    8b72:	82e3      	strh	r3, [r4, #22]
    refresh_children_position(obj, diff.x, diff.y);
    8b74:	4632      	mov	r2, r6
    8b76:	4629      	mov	r1, r5
    8b78:	4620      	mov	r0, r4
    8b7a:	f7ff ff55 	bl	8a28 <refresh_children_position>
    obj->signal_cb(obj, LV_SIGNAL_CORD_CHG, &ori);
    8b7e:	69e3      	ldr	r3, [r4, #28]
    8b80:	466a      	mov	r2, sp
    8b82:	2102      	movs	r1, #2
    8b84:	4620      	mov	r0, r4
    8b86:	4798      	blx	r3
    par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
    8b88:	69fb      	ldr	r3, [r7, #28]
    8b8a:	4622      	mov	r2, r4
    8b8c:	2101      	movs	r1, #1
    8b8e:	4638      	mov	r0, r7
    8b90:	4798      	blx	r3
    lv_obj_invalidate(obj);
    8b92:	4620      	mov	r0, r4
    8b94:	f7ff ff7a 	bl	8a8c <lv_obj_invalidate>
}
    8b98:	b003      	add	sp, #12
    8b9a:	bdf0      	pop	{r4, r5, r6, r7, pc}

00008b9c <lv_obj_refresh_style>:
{
    8b9c:	b510      	push	{r4, lr}
    8b9e:	4604      	mov	r4, r0
    lv_obj_invalidate(obj);
    8ba0:	f7ff ff74 	bl	8a8c <lv_obj_invalidate>
    obj->signal_cb(obj, LV_SIGNAL_STYLE_CHG, NULL);
    8ba4:	69e3      	ldr	r3, [r4, #28]
    8ba6:	4620      	mov	r0, r4
    8ba8:	2200      	movs	r2, #0
    8baa:	2104      	movs	r1, #4
    8bac:	4798      	blx	r3
    lv_obj_invalidate(obj);
    8bae:	4620      	mov	r0, r4
}
    8bb0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    lv_obj_invalidate(obj);
    8bb4:	f7ff bf6a 	b.w	8a8c <lv_obj_invalidate>

00008bb8 <lv_obj_refresh_ext_draw_pad>:
{
    8bb8:	b510      	push	{r4, lr}
    obj->ext_draw_pad = 0;
    8bba:	2200      	movs	r2, #0
{
    8bbc:	4604      	mov	r4, r0
    obj->ext_draw_pad = 0;
    8bbe:	8602      	strh	r2, [r0, #48]	; 0x30
    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);
    8bc0:	69c3      	ldr	r3, [r0, #28]
    8bc2:	2106      	movs	r1, #6
    8bc4:	4798      	blx	r3
    lv_obj_invalidate(obj);
    8bc6:	4620      	mov	r0, r4
}
    8bc8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    lv_obj_invalidate(obj);
    8bcc:	f7ff bf5e 	b.w	8a8c <lv_obj_invalidate>

00008bd0 <lv_obj_set_size>:
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    8bd0:	8a83      	ldrh	r3, [r0, #20]
{
    8bd2:	b573      	push	{r0, r1, r4, r5, r6, lr}
    8bd4:	4616      	mov	r6, r2
    8bd6:	8a02      	ldrh	r2, [r0, #16]
    8bd8:	3301      	adds	r3, #1
    8bda:	1a9b      	subs	r3, r3, r2
    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {
    8bdc:	b21b      	sxth	r3, r3
    8bde:	428b      	cmp	r3, r1
{
    8be0:	4604      	mov	r4, r0
    8be2:	460d      	mov	r5, r1
    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {
    8be4:	d106      	bne.n	8bf4 <lv_obj_set_size+0x24>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    8be6:	8ac3      	ldrh	r3, [r0, #22]
    8be8:	8a42      	ldrh	r2, [r0, #18]
    8bea:	3301      	adds	r3, #1
    8bec:	1a9b      	subs	r3, r3, r2
    8bee:	b21b      	sxth	r3, r3
    8bf0:	429e      	cmp	r6, r3
    8bf2:	d024      	beq.n	8c3e <lv_obj_set_size+0x6e>
    lv_obj_invalidate(obj);
    8bf4:	4620      	mov	r0, r4
    8bf6:	f7ff ff49 	bl	8a8c <lv_obj_invalidate>
    memcpy(dest, src, sizeof(lv_area_t));
    8bfa:	2208      	movs	r2, #8
    8bfc:	f104 0110 	add.w	r1, r4, #16
    8c00:	4668      	mov	r0, sp
    8c02:	f7ff fa53 	bl	80ac <memcpy>
    obj->coords.y2 = obj->coords.y1 + h - 1;
    8c06:	8a63      	ldrh	r3, [r4, #18]
    8c08:	3e01      	subs	r6, #1
    8c0a:	441e      	add	r6, r3
        obj->coords.x2 = obj->coords.x1 + w - 1;
    8c0c:	8a23      	ldrh	r3, [r4, #16]
    obj->coords.y2 = obj->coords.y1 + h - 1;
    8c0e:	82e6      	strh	r6, [r4, #22]
        obj->coords.x2 = obj->coords.x1 + w - 1;
    8c10:	3d01      	subs	r5, #1
    8c12:	441d      	add	r5, r3
    8c14:	82a5      	strh	r5, [r4, #20]
    obj->signal_cb(obj, LV_SIGNAL_CORD_CHG, &ori);
    8c16:	69e3      	ldr	r3, [r4, #28]
    8c18:	466a      	mov	r2, sp
    8c1a:	2102      	movs	r1, #2
    8c1c:	4620      	mov	r0, r4
    8c1e:	4798      	blx	r3
    return obj->par;
    8c20:	6820      	ldr	r0, [r4, #0]
    if(par != NULL) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
    8c22:	b118      	cbz	r0, 8c2c <lv_obj_set_size+0x5c>
    8c24:	69c3      	ldr	r3, [r0, #28]
    8c26:	4622      	mov	r2, r4
    8c28:	2101      	movs	r1, #1
    8c2a:	4798      	blx	r3
    LV_LL_READ(obj->child_ll, i)
    8c2c:	1d26      	adds	r6, r4, #4
    8c2e:	4630      	mov	r0, r6
    8c30:	f001 fc57 	bl	a4e2 <lv_ll_get_head>
    8c34:	4605      	mov	r5, r0
    8c36:	b920      	cbnz	r0, 8c42 <lv_obj_set_size+0x72>
    lv_obj_invalidate(obj);
    8c38:	4620      	mov	r0, r4
    8c3a:	f7ff ff27 	bl	8a8c <lv_obj_invalidate>
}
    8c3e:	b002      	add	sp, #8
    8c40:	bd70      	pop	{r4, r5, r6, pc}
        i->signal_cb(i, LV_SIGNAL_PARENT_SIZE_CHG, NULL);
    8c42:	69eb      	ldr	r3, [r5, #28]
    8c44:	2200      	movs	r2, #0
    8c46:	2103      	movs	r1, #3
    8c48:	4628      	mov	r0, r5
    8c4a:	4798      	blx	r3
    LV_LL_READ(obj->child_ll, i)
    8c4c:	4629      	mov	r1, r5
    8c4e:	4630      	mov	r0, r6
    8c50:	f001 fc4d 	bl	a4ee <lv_ll_get_next>
    8c54:	e7ee      	b.n	8c34 <lv_obj_set_size+0x64>

00008c56 <lv_obj_set_height>:
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    8c56:	8a83      	ldrh	r3, [r0, #20]
    8c58:	8a02      	ldrh	r2, [r0, #16]
    8c5a:	3301      	adds	r3, #1
    8c5c:	1a9b      	subs	r3, r3, r2
    lv_obj_set_size(obj, lv_obj_get_width(obj), h);
    8c5e:	460a      	mov	r2, r1
    8c60:	b219      	sxth	r1, r3
    8c62:	f7ff bfb5 	b.w	8bd0 <lv_obj_set_size>

00008c66 <lv_obj_get_parent>:
}
    8c66:	6800      	ldr	r0, [r0, #0]
    8c68:	4770      	bx	lr

00008c6a <lv_obj_get_child>:
    if(child == NULL) {
    8c6a:	3004      	adds	r0, #4
    8c6c:	b909      	cbnz	r1, 8c72 <lv_obj_get_child+0x8>
        result = lv_ll_get_head(&obj->child_ll);
    8c6e:	f001 bc38 	b.w	a4e2 <lv_ll_get_head>
        result = lv_ll_get_next(&obj->child_ll, child);
    8c72:	f001 bc3c 	b.w	a4ee <lv_ll_get_next>

00008c76 <refresh_children_style>:
 * Recursively refresh the style of the children. Go deeper until a not NULL style is found
 * because the NULL styles are inherited from the parent
 * @param obj pointer to an object
 */
static void refresh_children_style(lv_obj_t * obj)
{
    8c76:	b538      	push	{r3, r4, r5, lr}
    8c78:	4605      	mov	r5, r0
        result = lv_ll_get_head(&obj->child_ll);
    8c7a:	3004      	adds	r0, #4
    8c7c:	f001 fc31 	bl	a4e2 <lv_ll_get_head>
            lv_obj_refresh_style(child);   /*Notify the child about the style change*/
        } else if(child->style_p->glass) {
            /*Children with 'glass' parent might be effected if their style == NULL*/
            refresh_children_style(child);
        }
        child = lv_obj_get_child(obj, child);
    8c80:	4604      	mov	r4, r0
    while(child != NULL) {
    8c82:	b900      	cbnz	r0, 8c86 <refresh_children_style+0x10>
    }
}
    8c84:	bd38      	pop	{r3, r4, r5, pc}
        if(child->style_p == NULL) {
    8c86:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    8c88:	b953      	cbnz	r3, 8ca0 <refresh_children_style+0x2a>
            refresh_children_style(child); /*Check children too*/
    8c8a:	4620      	mov	r0, r4
    8c8c:	f7ff fff3 	bl	8c76 <refresh_children_style>
            lv_obj_refresh_style(child);   /*Notify the child about the style change*/
    8c90:	4620      	mov	r0, r4
    8c92:	f7ff ff83 	bl	8b9c <lv_obj_refresh_style>
        child = lv_obj_get_child(obj, child);
    8c96:	4621      	mov	r1, r4
    8c98:	4628      	mov	r0, r5
    8c9a:	f7ff ffe6 	bl	8c6a <lv_obj_get_child>
    8c9e:	e7ef      	b.n	8c80 <refresh_children_style+0xa>
        } else if(child->style_p->glass) {
    8ca0:	781b      	ldrb	r3, [r3, #0]
    8ca2:	07db      	lsls	r3, r3, #31
    8ca4:	d5f7      	bpl.n	8c96 <refresh_children_style+0x20>
            refresh_children_style(child);
    8ca6:	4620      	mov	r0, r4
    8ca8:	f7ff ffe5 	bl	8c76 <refresh_children_style>
    8cac:	e7f3      	b.n	8c96 <refresh_children_style+0x20>

00008cae <lv_obj_set_style>:
{
    8cae:	b510      	push	{r4, lr}
    8cb0:	4604      	mov	r4, r0
    obj->style_p = style;
    8cb2:	6281      	str	r1, [r0, #40]	; 0x28
    refresh_children_style(obj);
    8cb4:	f7ff ffdf 	bl	8c76 <refresh_children_style>
    lv_obj_refresh_style(obj);
    8cb8:	4620      	mov	r0, r4
}
    8cba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    lv_obj_refresh_style(obj);
    8cbe:	f7ff bf6d 	b.w	8b9c <lv_obj_refresh_style>

00008cc2 <lv_obj_get_coords>:
{
    8cc2:	460b      	mov	r3, r1
    memcpy(dest, src, sizeof(lv_area_t));
    8cc4:	2208      	movs	r2, #8
    8cc6:	f100 0110 	add.w	r1, r0, #16
    8cca:	4618      	mov	r0, r3
    8ccc:	f7ff b9ee 	b.w	80ac <memcpy>

00008cd0 <lv_obj_get_x>:
    return obj->par;
    8cd0:	6803      	ldr	r3, [r0, #0]
    if(parent) {
    8cd2:	f9b0 0010 	ldrsh.w	r0, [r0, #16]
    8cd6:	b113      	cbz	r3, 8cde <lv_obj_get_x+0xe>
        rel_x             = obj->coords.x1 - parent->coords.x1;
    8cd8:	8a1b      	ldrh	r3, [r3, #16]
    8cda:	1ac0      	subs	r0, r0, r3
    8cdc:	b200      	sxth	r0, r0
}
    8cde:	4770      	bx	lr

00008ce0 <lv_obj_get_y>:
    return obj->par;
    8ce0:	6803      	ldr	r3, [r0, #0]
   if(parent) {
    8ce2:	f9b0 0012 	ldrsh.w	r0, [r0, #18]
    8ce6:	b113      	cbz	r3, 8cee <lv_obj_get_y+0xe>
       rel_y             = obj->coords.y1 - parent->coords.y1;
    8ce8:	8a5b      	ldrh	r3, [r3, #18]
    8cea:	1ac0      	subs	r0, r0, r3
    8cec:	b200      	sxth	r0, r0
}
    8cee:	4770      	bx	lr

00008cf0 <lv_obj_align>:
{
    8cf0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8cf4:	4606      	mov	r6, r0
    8cf6:	461f      	mov	r7, r3
    lv_coord_t new_x = lv_obj_get_x(obj);
    8cf8:	f7ff ffea 	bl	8cd0 <lv_obj_get_x>
    8cfc:	4605      	mov	r5, r0
    lv_coord_t new_y = lv_obj_get_y(obj);
    8cfe:	4630      	mov	r0, r6
    8d00:	f7ff ffee 	bl	8ce0 <lv_obj_get_y>
    if(base == NULL) {
    8d04:	f8d6 e000 	ldr.w	lr, [r6]
{
    8d08:	f9bd 8018 	ldrsh.w	r8, [sp, #24]
    8d0c:	2900      	cmp	r1, #0
    8d0e:	bf08      	it	eq
    8d10:	4671      	moveq	r1, lr
    switch(align) {
    8d12:	f9b1 3012 	ldrsh.w	r3, [r1, #18]
    8d16:	f9b1 c010 	ldrsh.w	ip, [r1, #16]
    8d1a:	2a14      	cmp	r2, #20
    8d1c:	d818      	bhi.n	8d50 <lv_obj_align+0x60>
    8d1e:	e8df f012 	tbh	[pc, r2, lsl #1]
    8d22:	0029      	.short	0x0029
    8d24:	004c0015 	.word	0x004c0015
    8d28:	00680060 	.word	0x00680060
    8d2c:	00880070 	.word	0x00880070
    8d30:	00a10090 	.word	0x00a10090
    8d34:	00ae00a9 	.word	0x00ae00a9
    8d38:	00ce00c6 	.word	0x00ce00c6
    8d3c:	00e700d1 	.word	0x00e700d1
    8d40:	00f400ef 	.word	0x00f400ef
    8d44:	00fe00f9 	.word	0x00fe00f9
    8d48:	01040101 	.word	0x01040101
            new_y = 0;
    8d4c:	2000      	movs	r0, #0
            new_x = 0;
    8d4e:	2500      	movs	r5, #0
    new_y -= par_abs_y;
    8d50:	f8be 2012 	ldrh.w	r2, [lr, #18]
    new_x -= par_abs_x;
    8d54:	f8be 1010 	ldrh.w	r1, [lr, #16]
    new_y -= par_abs_y;
    8d58:	eba8 0202 	sub.w	r2, r8, r2
    new_x -= par_abs_x;
    8d5c:	1a79      	subs	r1, r7, r1
    new_y -= par_abs_y;
    8d5e:	441a      	add	r2, r3
    new_x -= par_abs_x;
    8d60:	4461      	add	r1, ip
    new_y -= par_abs_y;
    8d62:	4402      	add	r2, r0
    new_x -= par_abs_x;
    8d64:	4429      	add	r1, r5
    lv_obj_set_pos(obj, new_x, new_y);
    8d66:	4630      	mov	r0, r6
    8d68:	b212      	sxth	r2, r2
    8d6a:	b209      	sxth	r1, r1
}
    8d6c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    lv_obj_set_pos(obj, new_x, new_y);
    8d70:	f7ff bedc 	b.w	8b2c <lv_obj_set_pos>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    8d74:	8ab5      	ldrh	r5, [r6, #20]
    8d76:	8a32      	ldrh	r2, [r6, #16]
    8d78:	3501      	adds	r5, #1
    8d7a:	1aad      	subs	r5, r5, r2
    8d7c:	8a8a      	ldrh	r2, [r1, #20]
    8d7e:	3201      	adds	r2, #1
    8d80:	eba2 020c 	sub.w	r2, r2, ip
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
    8d84:	b212      	sxth	r2, r2
    8d86:	b22d      	sxth	r5, r5
    8d88:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
    8d8c:	eb05 70d5 	add.w	r0, r5, r5, lsr #31
    8d90:	1055      	asrs	r5, r2, #1
    8d92:	eba5 0560 	sub.w	r5, r5, r0, asr #1
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    8d96:	8acc      	ldrh	r4, [r1, #22]
    8d98:	8af0      	ldrh	r0, [r6, #22]
    8d9a:	8a72      	ldrh	r2, [r6, #18]
    8d9c:	3401      	adds	r4, #1
    8d9e:	3001      	adds	r0, #1
    8da0:	1ae4      	subs	r4, r4, r3
    8da2:	1a80      	subs	r0, r0, r2
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
    8da4:	b224      	sxth	r4, r4
    8da6:	b200      	sxth	r0, r0
    8da8:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
    8dac:	eb00 72d0 	add.w	r2, r0, r0, lsr #31
    8db0:	1060      	asrs	r0, r4, #1
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    8db2:	b22d      	sxth	r5, r5
    8db4:	eba0 0062 	sub.w	r0, r0, r2, asr #1
    8db8:	e077      	b.n	8eaa <lv_obj_align+0x1ba>
    8dba:	8ab5      	ldrh	r5, [r6, #20]
    8dbc:	8a32      	ldrh	r2, [r6, #16]
    8dbe:	3501      	adds	r5, #1
    8dc0:	1aad      	subs	r5, r5, r2
    8dc2:	8a8a      	ldrh	r2, [r1, #20]
    8dc4:	3201      	adds	r2, #1
    8dc6:	eba2 020c 	sub.w	r2, r2, ip
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
    8dca:	b212      	sxth	r2, r2
    8dcc:	b22d      	sxth	r5, r5
    8dce:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
    8dd2:	eb05 70d5 	add.w	r0, r5, r5, lsr #31
    8dd6:	1055      	asrs	r5, r2, #1
    8dd8:	eba5 0560 	sub.w	r5, r5, r0, asr #1
    8ddc:	b22d      	sxth	r5, r5
            new_y = 0;
    8dde:	2000      	movs	r0, #0
            break;
    8de0:	e7b6      	b.n	8d50 <lv_obj_align+0x60>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
    8de2:	8a35      	ldrh	r5, [r6, #16]
    8de4:	8ab2      	ldrh	r2, [r6, #20]
    8de6:	8a89      	ldrh	r1, [r1, #20]
    8de8:	1aad      	subs	r5, r5, r2
    8dea:	440d      	add	r5, r1
    8dec:	eba5 050c 	sub.w	r5, r5, ip
    8df0:	e7f4      	b.n	8ddc <lv_obj_align+0xec>
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
    8df2:	8af2      	ldrh	r2, [r6, #22]
    8df4:	8a70      	ldrh	r0, [r6, #18]
    8df6:	1a80      	subs	r0, r0, r2
    8df8:	8aca      	ldrh	r2, [r1, #22]
    8dfa:	4410      	add	r0, r2
    8dfc:	1ac0      	subs	r0, r0, r3
    8dfe:	b200      	sxth	r0, r0
    8e00:	e7a5      	b.n	8d4e <lv_obj_align+0x5e>
    8e02:	8ab5      	ldrh	r5, [r6, #20]
    8e04:	8a32      	ldrh	r2, [r6, #16]
    8e06:	3501      	adds	r5, #1
    8e08:	1aad      	subs	r5, r5, r2
    8e0a:	8a8a      	ldrh	r2, [r1, #20]
    8e0c:	3201      	adds	r2, #1
    8e0e:	eba2 020c 	sub.w	r2, r2, ip
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
    8e12:	b212      	sxth	r2, r2
    8e14:	b22d      	sxth	r5, r5
    8e16:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
    8e1a:	eb05 70d5 	add.w	r0, r5, r5, lsr #31
    8e1e:	1055      	asrs	r5, r2, #1
    8e20:	eba5 0560 	sub.w	r5, r5, r0, asr #1
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
    8e24:	8af2      	ldrh	r2, [r6, #22]
    8e26:	8a70      	ldrh	r0, [r6, #18]
    8e28:	1a80      	subs	r0, r0, r2
    8e2a:	8aca      	ldrh	r2, [r1, #22]
    8e2c:	b22d      	sxth	r5, r5
    8e2e:	4410      	add	r0, r2
    8e30:	e05c      	b.n	8eec <lv_obj_align+0x1fc>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
    8e32:	8ab2      	ldrh	r2, [r6, #20]
    8e34:	8a35      	ldrh	r5, [r6, #16]
    8e36:	1aad      	subs	r5, r5, r2
    8e38:	8a8a      	ldrh	r2, [r1, #20]
    8e3a:	4415      	add	r5, r2
    8e3c:	eba5 050c 	sub.w	r5, r5, ip
    8e40:	e7f0      	b.n	8e24 <lv_obj_align+0x134>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    8e42:	8acc      	ldrh	r4, [r1, #22]
    8e44:	8af0      	ldrh	r0, [r6, #22]
    8e46:	8a72      	ldrh	r2, [r6, #18]
    8e48:	3401      	adds	r4, #1
    8e4a:	3001      	adds	r0, #1
    8e4c:	1ae4      	subs	r4, r4, r3
    8e4e:	1a80      	subs	r0, r0, r2
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
    8e50:	b224      	sxth	r4, r4
    8e52:	b200      	sxth	r0, r0
    8e54:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
    8e58:	eb00 72d0 	add.w	r2, r0, r0, lsr #31
    8e5c:	1060      	asrs	r0, r4, #1
    8e5e:	eba0 0062 	sub.w	r0, r0, r2, asr #1
    8e62:	e7cc      	b.n	8dfe <lv_obj_align+0x10e>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
    8e64:	8ab2      	ldrh	r2, [r6, #20]
    8e66:	8a35      	ldrh	r5, [r6, #16]
    8e68:	1aad      	subs	r5, r5, r2
    8e6a:	8a8a      	ldrh	r2, [r1, #20]
    8e6c:	4415      	add	r5, r2
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    8e6e:	eba5 050c 	sub.w	r5, r5, ip
    8e72:	e790      	b.n	8d96 <lv_obj_align+0xa6>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    8e74:	8af0      	ldrh	r0, [r6, #22]
    8e76:	1c42      	adds	r2, r0, #1
    8e78:	8a70      	ldrh	r0, [r6, #18]
            new_y = -lv_obj_get_height(obj);
    8e7a:	1a80      	subs	r0, r0, r2
    8e7c:	e7bf      	b.n	8dfe <lv_obj_align+0x10e>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    8e7e:	8ab5      	ldrh	r5, [r6, #20]
    8e80:	8a32      	ldrh	r2, [r6, #16]
    8e82:	3501      	adds	r5, #1
    8e84:	1aad      	subs	r5, r5, r2
    8e86:	8a8a      	ldrh	r2, [r1, #20]
    8e88:	3201      	adds	r2, #1
    8e8a:	eba2 020c 	sub.w	r2, r2, ip
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
    8e8e:	b212      	sxth	r2, r2
    8e90:	b22d      	sxth	r5, r5
    8e92:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
    8e96:	eb05 70d5 	add.w	r0, r5, r5, lsr #31
    8e9a:	1055      	asrs	r5, r2, #1
    8e9c:	eba5 0560 	sub.w	r5, r5, r0, asr #1
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    8ea0:	8af0      	ldrh	r0, [r6, #22]
    8ea2:	1c42      	adds	r2, r0, #1
    8ea4:	8a70      	ldrh	r0, [r6, #18]
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
    8ea6:	b22d      	sxth	r5, r5
            new_y = -lv_obj_get_height(obj);
    8ea8:	1a80      	subs	r0, r0, r2
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
    8eaa:	b200      	sxth	r0, r0
            break;
    8eac:	e750      	b.n	8d50 <lv_obj_align+0x60>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
    8eae:	8a35      	ldrh	r5, [r6, #16]
    8eb0:	8ab2      	ldrh	r2, [r6, #20]
    8eb2:	8a89      	ldrh	r1, [r1, #20]
    8eb4:	1aad      	subs	r5, r5, r2
    8eb6:	440d      	add	r5, r1
    8eb8:	eba5 050c 	sub.w	r5, r5, ip
    8ebc:	e7f0      	b.n	8ea0 <lv_obj_align+0x1b0>
    8ebe:	8ac8      	ldrh	r0, [r1, #22]
    8ec0:	3001      	adds	r0, #1
    8ec2:	e79b      	b.n	8dfc <lv_obj_align+0x10c>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    8ec4:	8ab5      	ldrh	r5, [r6, #20]
    8ec6:	8a32      	ldrh	r2, [r6, #16]
    8ec8:	3501      	adds	r5, #1
    8eca:	1aad      	subs	r5, r5, r2
    8ecc:	8a8a      	ldrh	r2, [r1, #20]
    8ece:	3201      	adds	r2, #1
    8ed0:	eba2 020c 	sub.w	r2, r2, ip
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
    8ed4:	b212      	sxth	r2, r2
    8ed6:	b22d      	sxth	r5, r5
    8ed8:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
    8edc:	eb05 70d5 	add.w	r0, r5, r5, lsr #31
    8ee0:	1055      	asrs	r5, r2, #1
    8ee2:	eba5 0560 	sub.w	r5, r5, r0, asr #1
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    8ee6:	8ac8      	ldrh	r0, [r1, #22]
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
    8ee8:	b22d      	sxth	r5, r5
    8eea:	3001      	adds	r0, #1
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
    8eec:	1ac0      	subs	r0, r0, r3
    8eee:	e7dc      	b.n	8eaa <lv_obj_align+0x1ba>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
    8ef0:	8ab2      	ldrh	r2, [r6, #20]
    8ef2:	8a35      	ldrh	r5, [r6, #16]
    8ef4:	1aad      	subs	r5, r5, r2
    8ef6:	8a8a      	ldrh	r2, [r1, #20]
    8ef8:	4415      	add	r5, r2
    8efa:	eba5 050c 	sub.w	r5, r5, ip
    8efe:	e7f2      	b.n	8ee6 <lv_obj_align+0x1f6>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    8f00:	8ab5      	ldrh	r5, [r6, #20]
    8f02:	1c69      	adds	r1, r5, #1
    8f04:	8a35      	ldrh	r5, [r6, #16]
            new_x = -lv_obj_get_width(obj);
    8f06:	1a6d      	subs	r5, r5, r1
    8f08:	e768      	b.n	8ddc <lv_obj_align+0xec>
    8f0a:	8ab5      	ldrh	r5, [r6, #20]
    8f0c:	1c6a      	adds	r2, r5, #1
    8f0e:	8a35      	ldrh	r5, [r6, #16]
            new_x = -lv_obj_get_width(obj);
    8f10:	1aad      	subs	r5, r5, r2
    8f12:	e740      	b.n	8d96 <lv_obj_align+0xa6>
    8f14:	8ab5      	ldrh	r5, [r6, #20]
    8f16:	1c6a      	adds	r2, r5, #1
    8f18:	8a35      	ldrh	r5, [r6, #16]
            new_x = -lv_obj_get_width(obj);
    8f1a:	1aad      	subs	r5, r5, r2
    8f1c:	e782      	b.n	8e24 <lv_obj_align+0x134>
    8f1e:	8a8d      	ldrh	r5, [r1, #20]
    8f20:	3501      	adds	r5, #1
    8f22:	e763      	b.n	8dec <lv_obj_align+0xfc>
    8f24:	8a8d      	ldrh	r5, [r1, #20]
    8f26:	3501      	adds	r5, #1
    8f28:	e7a1      	b.n	8e6e <lv_obj_align+0x17e>
    8f2a:	8a8d      	ldrh	r5, [r1, #20]
    8f2c:	3501      	adds	r5, #1
    8f2e:	e785      	b.n	8e3c <lv_obj_align+0x14c>

00008f30 <lv_obj_get_width>:
    8f30:	8a83      	ldrh	r3, [r0, #20]
    8f32:	8a00      	ldrh	r0, [r0, #16]
    8f34:	3301      	adds	r3, #1
    8f36:	1a18      	subs	r0, r3, r0
}
    8f38:	b200      	sxth	r0, r0
    8f3a:	4770      	bx	lr

00008f3c <lv_obj_get_height>:
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    8f3c:	8ac3      	ldrh	r3, [r0, #22]
    8f3e:	8a40      	ldrh	r0, [r0, #18]
    8f40:	3301      	adds	r3, #1
    8f42:	1a18      	subs	r0, r3, r0
}
    8f44:	b200      	sxth	r0, r0
    8f46:	4770      	bx	lr

00008f48 <lv_obj_get_base_dir>:
}
    8f48:	2000      	movs	r0, #0
    8f4a:	4770      	bx	lr

00008f4c <lv_obj_get_opa_scale>:
    while(parent) {
    8f4c:	b908      	cbnz	r0, 8f52 <lv_obj_get_opa_scale+0x6>
    return LV_OPA_COVER;
    8f4e:	20ff      	movs	r0, #255	; 0xff
}
    8f50:	4770      	bx	lr
        if(parent->opa_scale_en) return parent->opa_scale;
    8f52:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
    8f56:	065b      	lsls	r3, r3, #25
    8f58:	d502      	bpl.n	8f60 <lv_obj_get_opa_scale+0x14>
    8f5a:	f890 002f 	ldrb.w	r0, [r0, #47]	; 0x2f
    8f5e:	4770      	bx	lr
    return obj->par;
    8f60:	6800      	ldr	r0, [r0, #0]
    8f62:	e7f3      	b.n	8f4c <lv_obj_get_opa_scale>

00008f64 <lv_obj_design>:
    if(mode == LV_DESIGN_COVER_CHK) {
    8f64:	2a02      	cmp	r2, #2
{
    8f66:	b573      	push	{r0, r1, r4, r5, r6, lr}
    8f68:	4604      	mov	r4, r0
    8f6a:	460d      	mov	r5, r1
    if(mode == LV_DESIGN_COVER_CHK) {
    8f6c:	d13d      	bne.n	8fea <lv_obj_design+0x86>
        if(lv_area_is_in(mask_p, &obj->coords) == false) return false;
    8f6e:	f100 0610 	add.w	r6, r0, #16
    8f72:	4631      	mov	r1, r6
    8f74:	4628      	mov	r0, r5
    8f76:	f001 fa0e 	bl	a396 <lv_area_is_in>
    8f7a:	b398      	cbz	r0, 8fe4 <lv_obj_design+0x80>
        const lv_style_t * style = lv_obj_get_style(obj);
    8f7c:	4620      	mov	r0, r4
    8f7e:	f7fa ff3b 	bl	3df8 <lv_obj_get_style>
        if(style->body.opa < LV_OPA_MAX) return false;
    8f82:	7b83      	ldrb	r3, [r0, #14]
    8f84:	2bfa      	cmp	r3, #250	; 0xfa
    8f86:	d92d      	bls.n	8fe4 <lv_obj_design+0x80>
        lv_coord_t r = style->body.radius;
    8f88:	f9b0 400c 	ldrsh.w	r4, [r0, #12]
        if(r == LV_RADIUS_CIRCLE) return false;
    8f8c:	f647 4318 	movw	r3, #31768	; 0x7c18
    8f90:	429c      	cmp	r4, r3
    8f92:	d027      	beq.n	8fe4 <lv_obj_design+0x80>
    memcpy(dest, src, sizeof(lv_area_t));
    8f94:	4631      	mov	r1, r6
    8f96:	2208      	movs	r2, #8
    8f98:	4668      	mov	r0, sp
    8f9a:	f7ff f887 	bl	80ac <memcpy>
        area_tmp.x1 += r;
    8f9e:	f8bd 3000 	ldrh.w	r3, [sp]
    8fa2:	4423      	add	r3, r4
    8fa4:	f8ad 3000 	strh.w	r3, [sp]
        area_tmp.x2 -= r;
    8fa8:	f8bd 3004 	ldrh.w	r3, [sp, #4]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
    8fac:	4669      	mov	r1, sp
        area_tmp.x2 -= r;
    8fae:	1b1b      	subs	r3, r3, r4
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
    8fb0:	4628      	mov	r0, r5
        area_tmp.x2 -= r;
    8fb2:	f8ad 3004 	strh.w	r3, [sp, #4]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
    8fb6:	f001 f9ee 	bl	a396 <lv_area_is_in>
    8fba:	b198      	cbz	r0, 8fe4 <lv_obj_design+0x80>
    8fbc:	4631      	mov	r1, r6
    8fbe:	2208      	movs	r2, #8
    8fc0:	4668      	mov	r0, sp
    8fc2:	f7ff f873 	bl	80ac <memcpy>
        area_tmp.y1 += r;
    8fc6:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    8fca:	4423      	add	r3, r4
    8fcc:	f8ad 3002 	strh.w	r3, [sp, #2]
        area_tmp.y2 -= r;
    8fd0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
    8fd4:	4669      	mov	r1, sp
        area_tmp.y2 -= r;
    8fd6:	1b1c      	subs	r4, r3, r4
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
    8fd8:	4628      	mov	r0, r5
        area_tmp.y2 -= r;
    8fda:	f8ad 4006 	strh.w	r4, [sp, #6]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
    8fde:	f001 f9da 	bl	a396 <lv_area_is_in>
    8fe2:	b900      	cbnz	r0, 8fe6 <lv_obj_design+0x82>
        if(lv_area_is_in(mask_p, &obj->coords) == false) return false;
    8fe4:	2000      	movs	r0, #0
}
    8fe6:	b002      	add	sp, #8
    8fe8:	bd70      	pop	{r4, r5, r6, pc}
    } else if(mode == LV_DESIGN_DRAW_MAIN) {
    8fea:	b95a      	cbnz	r2, 9004 <lv_obj_design+0xa0>
        const lv_style_t * style = lv_obj_get_style(obj);
    8fec:	f7fa ff04 	bl	3df8 <lv_obj_get_style>
    8ff0:	4602      	mov	r2, r0
        lv_draw_rect(&obj->coords, mask_p, style, lv_obj_get_opa_scale(obj));
    8ff2:	4620      	mov	r0, r4
    8ff4:	f7ff ffaa 	bl	8f4c <lv_obj_get_opa_scale>
    8ff8:	4629      	mov	r1, r5
    8ffa:	4603      	mov	r3, r0
    8ffc:	f104 0010 	add.w	r0, r4, #16
    9000:	f000 fa40 	bl	9484 <lv_draw_rect>
    return true;
    9004:	2001      	movs	r0, #1
    9006:	e7ee      	b.n	8fe6 <lv_obj_design+0x82>

00009008 <lv_obj_get_signal_cb>:
}
    9008:	69c0      	ldr	r0, [r0, #28]
    900a:	4770      	bx	lr

0000900c <lv_obj_get_ext_attr>:
}
    900c:	6a40      	ldr	r0, [r0, #36]	; 0x24
    900e:	4770      	bx	lr

00009010 <lv_obj_handle_get_type_signal>:
{
    9010:	b510      	push	{r4, lr}
    9012:	2300      	movs	r3, #0
        if(buf->type[i] == NULL) break;
    9014:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
    9018:	b2da      	uxtb	r2, r3
    901a:	b11c      	cbz	r4, 9024 <lv_obj_handle_get_type_signal+0x14>
    901c:	3301      	adds	r3, #1
    for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
    901e:	2b07      	cmp	r3, #7
    9020:	d1f8      	bne.n	9014 <lv_obj_handle_get_type_signal+0x4>
    9022:	461a      	mov	r2, r3
    buf->type[i] = name;
    9024:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
}
    9028:	2001      	movs	r0, #1
    902a:	bd10      	pop	{r4, pc}

0000902c <lv_refr_get_top_obj>:
{
    902c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    902e:	460c      	mov	r4, r1
    if(lv_area_is_in(area_p, &obj->coords) && obj->hidden == 0) {
    9030:	3110      	adds	r1, #16
{
    9032:	4606      	mov	r6, r0
    if(lv_area_is_in(area_p, &obj->coords) && obj->hidden == 0) {
    9034:	f001 f9af 	bl	a396 <lv_area_is_in>
    9038:	b908      	cbnz	r0, 903e <lv_refr_get_top_obj+0x12>
    lv_obj_t * found_p = NULL;
    903a:	2000      	movs	r0, #0
}
    903c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(lv_area_is_in(area_p, &obj->coords) && obj->hidden == 0) {
    903e:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    9042:	06db      	lsls	r3, r3, #27
    9044:	d4f9      	bmi.n	903a <lv_refr_get_top_obj+0xe>
        LV_LL_READ(obj->child_ll, i)
    9046:	1d27      	adds	r7, r4, #4
    9048:	4638      	mov	r0, r7
    904a:	f001 fa4a 	bl	a4e2 <lv_ll_get_head>
    904e:	4605      	mov	r5, r0
    9050:	b998      	cbnz	r0, 907a <lv_refr_get_top_obj+0x4e>
            const lv_style_t * style = lv_obj_get_style(obj);
    9052:	4620      	mov	r0, r4
    9054:	f7fa fed0 	bl	3df8 <lv_obj_get_style>
            if(style->body.opa == LV_OPA_COVER && obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK) != false &&
    9058:	7b83      	ldrb	r3, [r0, #14]
    905a:	2bff      	cmp	r3, #255	; 0xff
    905c:	d1ed      	bne.n	903a <lv_refr_get_top_obj+0xe>
    905e:	6a23      	ldr	r3, [r4, #32]
    9060:	2202      	movs	r2, #2
    9062:	4631      	mov	r1, r6
    9064:	4620      	mov	r0, r4
    9066:	4798      	blx	r3
    9068:	2800      	cmp	r0, #0
    906a:	d0e6      	beq.n	903a <lv_refr_get_top_obj+0xe>
               lv_obj_get_opa_scale(obj) == LV_OPA_COVER) {
    906c:	4620      	mov	r0, r4
    906e:	f7ff ff6d 	bl	8f4c <lv_obj_get_opa_scale>
            if(style->body.opa == LV_OPA_COVER && obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK) != false &&
    9072:	28ff      	cmp	r0, #255	; 0xff
    9074:	d1e1      	bne.n	903a <lv_refr_get_top_obj+0xe>
    9076:	4620      	mov	r0, r4
    return found_p;
    9078:	e7e0      	b.n	903c <lv_refr_get_top_obj+0x10>
            found_p = lv_refr_get_top_obj(area_p, i);
    907a:	4629      	mov	r1, r5
    907c:	4630      	mov	r0, r6
    907e:	f7ff ffd5 	bl	902c <lv_refr_get_top_obj>
            if(found_p != NULL) {
    9082:	2800      	cmp	r0, #0
    9084:	d1da      	bne.n	903c <lv_refr_get_top_obj+0x10>
        LV_LL_READ(obj->child_ll, i)
    9086:	4629      	mov	r1, r5
    9088:	4638      	mov	r0, r7
    908a:	f001 fa30 	bl	a4ee <lv_ll_get_next>
    908e:	e7de      	b.n	904e <lv_refr_get_top_obj+0x22>

00009090 <lv_refr_obj>:
{
    9090:	b5f0      	push	{r4, r5, r6, r7, lr}
    if(obj->hidden != 0) return;
    9092:	f890 602c 	ldrb.w	r6, [r0, #44]	; 0x2c
    9096:	f016 0610 	ands.w	r6, r6, #16
{
    909a:	b08b      	sub	sp, #44	; 0x2c
    909c:	4604      	mov	r4, r0
    909e:	460f      	mov	r7, r1
    if(obj->hidden != 0) return;
    90a0:	d138      	bne.n	9114 <lv_refr_obj+0x84>
    lv_obj_get_coords(obj, &obj_area);
    90a2:	a904      	add	r1, sp, #16
    lv_coord_t ext_size = obj->ext_draw_pad;
    90a4:	f9b0 5030 	ldrsh.w	r5, [r0, #48]	; 0x30
    lv_obj_get_coords(obj, &obj_area);
    90a8:	f7ff fe0b 	bl	8cc2 <lv_obj_get_coords>
    obj_area.x1 -= ext_size;
    90ac:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    90b0:	1b5b      	subs	r3, r3, r5
    90b2:	f8ad 3010 	strh.w	r3, [sp, #16]
    obj_area.y1 -= ext_size;
    90b6:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    90ba:	1b5b      	subs	r3, r3, r5
    90bc:	f8ad 3012 	strh.w	r3, [sp, #18]
    obj_area.x2 += ext_size;
    90c0:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    90c4:	442b      	add	r3, r5
    90c6:	f8ad 3014 	strh.w	r3, [sp, #20]
    obj_area.y2 += ext_size;
    90ca:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    union_ok = lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
    90ce:	aa04      	add	r2, sp, #16
    obj_area.y2 += ext_size;
    90d0:	441d      	add	r5, r3
    union_ok = lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
    90d2:	4639      	mov	r1, r7
    90d4:	a802      	add	r0, sp, #8
    obj_area.y2 += ext_size;
    90d6:	f8ad 5016 	strh.w	r5, [sp, #22]
    union_ok = lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
    90da:	f001 f8f3 	bl	a2c4 <lv_area_intersect>
    if(union_ok != false) {
    90de:	b1c8      	cbz	r0, 9114 <lv_refr_obj+0x84>
        obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_MAIN);
    90e0:	4632      	mov	r2, r6
    90e2:	6a23      	ldr	r3, [r4, #32]
    90e4:	a902      	add	r1, sp, #8
    90e6:	4620      	mov	r0, r4
    90e8:	4798      	blx	r3
        lv_obj_get_coords(obj, &obj_area);
    90ea:	a904      	add	r1, sp, #16
    90ec:	4620      	mov	r0, r4
    90ee:	f7ff fde8 	bl	8cc2 <lv_obj_get_coords>
        union_ok = lv_area_intersect(&obj_mask, mask_ori_p, &obj_area);
    90f2:	aa04      	add	r2, sp, #16
    90f4:	4639      	mov	r1, r7
    90f6:	4668      	mov	r0, sp
    90f8:	f001 f8e4 	bl	a2c4 <lv_area_intersect>
        if(union_ok != false) {
    90fc:	b128      	cbz	r0, 910a <lv_refr_obj+0x7a>
            LV_LL_READ_BACK(obj->child_ll, child_p)
    90fe:	1d26      	adds	r6, r4, #4
    9100:	4630      	mov	r0, r6
    9102:	f001 f9f1 	bl	a4e8 <lv_ll_get_tail>
    9106:	4605      	mov	r5, r0
    9108:	b930      	cbnz	r0, 9118 <lv_refr_obj+0x88>
        obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_POST);
    910a:	6a23      	ldr	r3, [r4, #32]
    910c:	2201      	movs	r2, #1
    910e:	a902      	add	r1, sp, #8
    9110:	4620      	mov	r0, r4
    9112:	4798      	blx	r3
}
    9114:	b00b      	add	sp, #44	; 0x2c
    9116:	bdf0      	pop	{r4, r5, r6, r7, pc}
                lv_obj_get_coords(child_p, &child_area);
    9118:	a908      	add	r1, sp, #32
    911a:	4628      	mov	r0, r5
    911c:	f7ff fdd1 	bl	8cc2 <lv_obj_get_coords>
                ext_size = child_p->ext_draw_pad;
    9120:	f9b5 3030 	ldrsh.w	r3, [r5, #48]	; 0x30
                child_area.x1 -= ext_size;
    9124:	f8bd 2020 	ldrh.w	r2, [sp, #32]
    9128:	1ad2      	subs	r2, r2, r3
    912a:	f8ad 2020 	strh.w	r2, [sp, #32]
                child_area.y1 -= ext_size;
    912e:	f8bd 2022 	ldrh.w	r2, [sp, #34]	; 0x22
    9132:	1ad2      	subs	r2, r2, r3
    9134:	f8ad 2022 	strh.w	r2, [sp, #34]	; 0x22
                child_area.x2 += ext_size;
    9138:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
    913c:	441a      	add	r2, r3
    913e:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
                child_area.y2 += ext_size;
    9142:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
                union_ok = lv_area_intersect(&mask_child, &obj_mask, &child_area);
    9146:	4669      	mov	r1, sp
                child_area.y2 += ext_size;
    9148:	4413      	add	r3, r2
                union_ok = lv_area_intersect(&mask_child, &obj_mask, &child_area);
    914a:	a806      	add	r0, sp, #24
    914c:	aa08      	add	r2, sp, #32
                child_area.y2 += ext_size;
    914e:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
                union_ok = lv_area_intersect(&mask_child, &obj_mask, &child_area);
    9152:	f001 f8b7 	bl	a2c4 <lv_area_intersect>
                if(union_ok) {
    9156:	b118      	cbz	r0, 9160 <lv_refr_obj+0xd0>
                    lv_refr_obj(child_p, &mask_child);
    9158:	a906      	add	r1, sp, #24
    915a:	4628      	mov	r0, r5
    915c:	f7ff ff98 	bl	9090 <lv_refr_obj>
            LV_LL_READ_BACK(obj->child_ll, child_p)
    9160:	4629      	mov	r1, r5
    9162:	4630      	mov	r0, r6
    9164:	f001 f9d3 	bl	a50e <lv_ll_get_prev>
    9168:	e7cd      	b.n	9106 <lv_refr_obj+0x76>

0000916a <lv_refr_init>:
}
    916a:	4770      	bx	lr

0000916c <lv_inv_area>:
{
    916c:	b5f0      	push	{r4, r5, r6, r7, lr}
    916e:	460d      	mov	r5, r1
    9170:	b085      	sub	sp, #20
    if(!disp) disp = lv_disp_get_default();
    9172:	4604      	mov	r4, r0
    9174:	b920      	cbnz	r0, 9180 <lv_inv_area+0x14>
    9176:	f7fc f9b9 	bl	54ec <lv_disp_get_default>
    if(!disp) return;
    917a:	4604      	mov	r4, r0
    917c:	2800      	cmp	r0, #0
    917e:	d043      	beq.n	9208 <lv_inv_area+0x9c>
    if(area_p == NULL) {
    9180:	b935      	cbnz	r5, 9190 <lv_inv_area+0x24>
        disp->inv_p = 0;
    9182:	f8b4 3160 	ldrh.w	r3, [r4, #352]	; 0x160
    9186:	f365 0309 	bfi	r3, r5, #0, #10
        disp->inv_p++;
    918a:	f8a4 3160 	strh.w	r3, [r4, #352]	; 0x160
    918e:	e03b      	b.n	9208 <lv_inv_area+0x9c>
    scr_area.x1 = 0;
    9190:	2300      	movs	r3, #0
    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;
    9192:	4620      	mov	r0, r4
    scr_area.x1 = 0;
    9194:	9300      	str	r3, [sp, #0]
    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;
    9196:	f7fc f9af 	bl	54f8 <lv_disp_get_hor_res>
    919a:	3801      	subs	r0, #1
    919c:	f8ad 0004 	strh.w	r0, [sp, #4]
    scr_area.y2 = lv_disp_get_ver_res(disp) - 1;
    91a0:	4620      	mov	r0, r4
    91a2:	f7fc f9b9 	bl	5518 <lv_disp_get_ver_res>
    91a6:	3801      	subs	r0, #1
    91a8:	f8ad 0006 	strh.w	r0, [sp, #6]
    suc = lv_area_intersect(&com_area, area_p, &scr_area);
    91ac:	466a      	mov	r2, sp
    91ae:	4629      	mov	r1, r5
    91b0:	a802      	add	r0, sp, #8
    91b2:	f001 f887 	bl	a2c4 <lv_area_intersect>
    if(suc != false) {
    91b6:	b338      	cbz	r0, 9208 <lv_inv_area+0x9c>
        if(disp->driver.rounder_cb) disp->driver.rounder_cb(&disp->driver, &com_area);
    91b8:	6923      	ldr	r3, [r4, #16]
    91ba:	b113      	cbz	r3, 91c2 <lv_inv_area+0x56>
    91bc:	a902      	add	r1, sp, #8
    91be:	4620      	mov	r0, r4
    91c0:	4798      	blx	r3
    91c2:	f104 0540 	add.w	r5, r4, #64	; 0x40
{
    91c6:	2600      	movs	r6, #0
    91c8:	462f      	mov	r7, r5
        for(i = 0; i < disp->inv_p; i++) {
    91ca:	f8b4 3160 	ldrh.w	r3, [r4, #352]	; 0x160
    91ce:	b2b2      	uxth	r2, r6
    91d0:	f3c3 0009 	ubfx	r0, r3, #0, #10
    91d4:	4290      	cmp	r0, r2
    91d6:	d80f      	bhi.n	91f8 <lv_inv_area+0x8c>
        if(disp->inv_p < LV_INV_BUF_SIZE) {
    91d8:	281f      	cmp	r0, #31
    91da:	d817      	bhi.n	920c <lv_inv_area+0xa0>
            lv_area_copy(&disp->inv_areas[disp->inv_p], &com_area);
    91dc:	3008      	adds	r0, #8
    91de:	2208      	movs	r2, #8
    91e0:	eb0d 0102 	add.w	r1, sp, r2
    91e4:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
    91e8:	f7fe ff60 	bl	80ac <memcpy>
        disp->inv_p++;
    91ec:	f8b4 3160 	ldrh.w	r3, [r4, #352]	; 0x160
    91f0:	1c5a      	adds	r2, r3, #1
    91f2:	f362 0309 	bfi	r3, r2, #0, #10
    91f6:	e7c8      	b.n	918a <lv_inv_area+0x1e>
            if(lv_area_is_in(&com_area, &disp->inv_areas[i]) != false) return;
    91f8:	4629      	mov	r1, r5
    91fa:	a802      	add	r0, sp, #8
    91fc:	f001 f8cb 	bl	a396 <lv_area_is_in>
    9200:	3601      	adds	r6, #1
    9202:	3508      	adds	r5, #8
    9204:	2800      	cmp	r0, #0
    9206:	d0e0      	beq.n	91ca <lv_inv_area+0x5e>
}
    9208:	b005      	add	sp, #20
    920a:	bdf0      	pop	{r4, r5, r6, r7, pc}
            disp->inv_p = 0;
    920c:	f36f 0309 	bfc	r3, #0, #10
    9210:	f8a4 3160 	strh.w	r3, [r4, #352]	; 0x160
    9214:	2208      	movs	r2, #8
    9216:	4669      	mov	r1, sp
    9218:	4638      	mov	r0, r7
    921a:	e7e5      	b.n	91e8 <lv_inv_area+0x7c>

0000921c <lv_style_copy>:
 * @param dest pointer to the destination style
 * @param src pointer to the source style
 */
void lv_style_copy(lv_style_t * dest, const lv_style_t * src)
{
    memcpy(dest, src, sizeof(lv_style_t));
    921c:	2250      	movs	r2, #80	; 0x50
    921e:	f7fe bf45 	b.w	80ac <memcpy>

00009222 <lv_color_mix.isra.0>:
#elif LV_COLOR_DEPTH == 32
    return color.full;
#endif
}

static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
    9222:	b530      	push	{r4, r5, lr}
    9224:	f89d 5014 	ldrb.w	r5, [sp, #20]
{
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    9228:	b2ac      	uxth	r4, r5
    922a:	f1c5 05ff 	rsb	r5, r5, #255	; 0xff
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    LV_COLOR_SET_B(ret, (uint16_t)((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) * (255 - mix)) >> 8);
    922e:	436b      	muls	r3, r5
    9230:	fb00 3304 	mla	r3, r0, r4, r3
    9234:	f3c3 2307 	ubfx	r3, r3, #8, #8
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
    9238:	2000      	movs	r0, #0
    923a:	f363 0007 	bfi	r0, r3, #0, #8
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    923e:	f89d 300c 	ldrb.w	r3, [sp, #12]
    9242:	fb13 f305 	smulbb	r3, r3, r5
    9246:	fb01 3104 	mla	r1, r1, r4, r3
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    924a:	f89d 3010 	ldrb.w	r3, [sp, #16]
    924e:	fb13 f505 	smulbb	r5, r3, r5
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    9252:	f3c1 2107 	ubfx	r1, r1, #8, #8
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    9256:	fb02 5204 	mla	r2, r2, r4, r5
    return ret;
    925a:	f361 200f 	bfi	r0, r1, #8, #8
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    925e:	f3c2 2207 	ubfx	r2, r2, #8, #8
    return ret;
    9262:	f362 4017 	bfi	r0, r2, #16, #8
}
    9266:	f040 407f 	orr.w	r0, r0, #4278190080	; 0xff000000
    926a:	bd30      	pop	{r4, r5, pc}

0000926c <lv_draw_fill>:
{
    926c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(opa < LV_OPA_MIN) return;
    9270:	2b0f      	cmp	r3, #15
{
    9272:	b08d      	sub	sp, #52	; 0x34
    9274:	4616      	mov	r6, r2
    9276:	461f      	mov	r7, r3
    if(opa < LV_OPA_MIN) return;
    9278:	d973      	bls.n	9362 <lv_draw_fill+0xf6>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
    927a:	2bfc      	cmp	r3, #252	; 0xfc
    union_ok = lv_area_intersect(&res_a, cords_p, mask_p);
    927c:	460a      	mov	r2, r1
    927e:	4601      	mov	r1, r0
    9280:	a80a      	add	r0, sp, #40	; 0x28
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
    9282:	bf28      	it	cs
    9284:	27ff      	movcs	r7, #255	; 0xff
    union_ok = lv_area_intersect(&res_a, cords_p, mask_p);
    9286:	f001 f81d 	bl	a2c4 <lv_area_intersect>
    if(union_ok == false) {
    928a:	2800      	cmp	r0, #0
    928c:	d069      	beq.n	9362 <lv_draw_fill+0xf6>
    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
    928e:	f7fa fe6d 	bl	3f6c <lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
    9292:	f000 ffba 	bl	a20a <lv_disp_get_buf>
    vdb_rel_a.y1 = res_a.y1 - vdb->area.y1;
    9296:	f8bd 102a 	ldrh.w	r1, [sp, #42]	; 0x2a
    929a:	f9b0 5012 	ldrsh.w	r5, [r0, #18]
    vdb_rel_a.x1 = res_a.x1 - vdb->area.x1;
    929e:	f9b0 3010 	ldrsh.w	r3, [r0, #16]
    92a2:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
    lv_color_t * vdb_buf_tmp = vdb->buf_act;
    92a6:	f8d0 a008 	ldr.w	sl, [r0, #8]
    vdb_rel_a.y1 = res_a.y1 - vdb->area.y1;
    92aa:	1b49      	subs	r1, r1, r5
    92ac:	fa0f fb81 	sxth.w	fp, r1
    vdb_rel_a.x2 = res_a.x2 - vdb->area.x1;
    92b0:	f8bd 102c 	ldrh.w	r1, [sp, #44]	; 0x2c
    92b4:	1ac9      	subs	r1, r1, r3
    92b6:	b20a      	sxth	r2, r1
    92b8:	9204      	str	r2, [sp, #16]
    vdb_rel_a.y2 = res_a.y2 - vdb->area.y1;
    92ba:	f8bd 202e 	ldrh.w	r2, [sp, #46]	; 0x2e
    92be:	1b52      	subs	r2, r2, r5
    92c0:	8a85      	ldrh	r5, [r0, #20]
    92c2:	3501      	adds	r5, #1
    92c4:	1aed      	subs	r5, r5, r3
    vdb_rel_a.x1 = res_a.x1 - vdb->area.x1;
    92c6:	1ae4      	subs	r4, r4, r3
    92c8:	b22b      	sxth	r3, r5
    92ca:	9309      	str	r3, [sp, #36]	; 0x24
    92cc:	b2f3      	uxtb	r3, r6
    92ce:	9305      	str	r3, [sp, #20]
    92d0:	f3c6 2307 	ubfx	r3, r6, #8, #8
    vdb_rel_a.y2 = res_a.y2 - vdb->area.y1;
    92d4:	b212      	sxth	r2, r2
    92d6:	9306      	str	r3, [sp, #24]
    92d8:	f3c6 4307 	ubfx	r3, r6, #16, #8
    92dc:	9307      	str	r3, [sp, #28]
    92de:	9208      	str	r2, [sp, #32]
{
    /*Set all row in vdb to the given color*/
    lv_coord_t row;
    lv_coord_t col;

    lv_disp_t * disp = lv_refr_get_disp_refreshing();
    92e0:	f7fa fe44 	bl	3f6c <lv_refr_get_disp_refreshing>
    if(disp->driver.set_px_cb) {
    92e4:	6943      	ldr	r3, [r0, #20]
    vdb_rel_a.x1 = res_a.x1 - vdb->area.x1;
    92e6:	b224      	sxth	r4, r4
    lv_disp_t * disp = lv_refr_get_disp_refreshing();
    92e8:	4681      	mov	r9, r0
    if(disp->driver.set_px_cb) {
    92ea:	2b00      	cmp	r3, #0
    92ec:	d136      	bne.n	935c <lv_draw_fill+0xf0>
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
                disp->driver.set_px_cb(&disp->driver, (uint8_t *)mem, mem_width, col, row, color, opa);
            }
        }
    } else {
        mem += fill_area->y1 * mem_width; /*Go to the first row*/
    92ee:	9a09      	ldr	r2, [sp, #36]	; 0x24
    92f0:	fb0b f202 	mul.w	r2, fp, r2
    92f4:	eb0a 0a82 	add.w	sl, sl, r2, lsl #2

        /*Run simpler function without opacity*/
        if(opa == LV_OPA_COVER) {
    92f8:	9a09      	ldr	r2, [sp, #36]	; 0x24
    92fa:	2fff      	cmp	r7, #255	; 0xff
    92fc:	ea4f 0582 	mov.w	r5, r2, lsl #2
    9300:	d05c      	beq.n	93bc <lv_draw_fill+0x150>
#if LV_COLOR_DEPTH == 32 && LV_COLOR_SCREEN_TRANSP
            scr_transp = disp->driver.screen_transp;
#endif

            lv_color_t bg_tmp  = LV_COLOR_BLACK;
            lv_color_t opa_tmp = lv_color_mix(color, bg_tmp, opa);
    9302:	e9cd 3701 	strd	r3, r7, [sp, #4]
    9306:	9300      	str	r3, [sp, #0]
    9308:	e9dd 1206 	ldrd	r1, r2, [sp, #24]
    930c:	9805      	ldr	r0, [sp, #20]
            lv_color_t bg_tmp  = LV_COLOR_BLACK;
    930e:	f04f 487f 	mov.w	r8, #4278190080	; 0xff000000
            lv_color_t opa_tmp = lv_color_mix(color, bg_tmp, opa);
    9312:	f7ff ff86 	bl	9222 <lv_color_mix.isra.0>
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
    9316:	9b08      	ldr	r3, [sp, #32]
    9318:	455b      	cmp	r3, fp
    931a:	db22      	blt.n	9362 <lv_draw_fill+0xf6>
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
    931c:	4626      	mov	r6, r4
    931e:	e068      	b.n	93f2 <lv_draw_fill+0x186>
                disp->driver.set_px_cb(&disp->driver, (uint8_t *)mem, mem_width, col, row, color, opa);
    9320:	f8d9 3014 	ldr.w	r3, [r9, #20]
    9324:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9326:	f8cd 8000 	str.w	r8, [sp]
    932a:	461d      	mov	r5, r3
    932c:	9b05      	ldr	r3, [sp, #20]
    932e:	f363 0607 	bfi	r6, r3, #0, #8
    9332:	9b06      	ldr	r3, [sp, #24]
    9334:	f363 260f 	bfi	r6, r3, #8, #8
    9338:	9b07      	ldr	r3, [sp, #28]
    933a:	f363 4617 	bfi	r6, r3, #16, #8
    933e:	e9cd 6701 	strd	r6, r7, [sp, #4]
    9342:	4623      	mov	r3, r4
    9344:	4651      	mov	r1, sl
    9346:	4648      	mov	r0, r9
    9348:	47a8      	blx	r5
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
    934a:	f108 0801 	add.w	r8, r8, #1
    934e:	fa0f f888 	sxth.w	r8, r8
    9352:	9b08      	ldr	r3, [sp, #32]
    9354:	4543      	cmp	r3, r8
    9356:	dae3      	bge.n	9320 <lv_draw_fill+0xb4>
        for(col = fill_area->x1; col <= fill_area->x2; col++) {
    9358:	3401      	adds	r4, #1
    935a:	b224      	sxth	r4, r4
    935c:	9b04      	ldr	r3, [sp, #16]
    935e:	42a3      	cmp	r3, r4
    9360:	da02      	bge.n	9368 <lv_draw_fill+0xfc>
}
    9362:	b00d      	add	sp, #52	; 0x34
    9364:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
    9368:	46d8      	mov	r8, fp
    936a:	e7f2      	b.n	9352 <lv_draw_fill+0xe6>
                mem[col] = color;
    936c:	9a05      	ldr	r2, [sp, #20]
    936e:	f362 0607 	bfi	r6, r2, #0, #8
    9372:	9a06      	ldr	r2, [sp, #24]
    9374:	f362 260f 	bfi	r6, r2, #8, #8
    9378:	9a07      	ldr	r2, [sp, #28]
    937a:	f362 4617 	bfi	r6, r2, #16, #8
    937e:	f84a 6023 	str.w	r6, [sl, r3, lsl #2]
            for(col = fill_area->x1; col <= fill_area->x2; col++) {
    9382:	3301      	adds	r3, #1
    9384:	b21b      	sxth	r3, r3
    9386:	9a04      	ldr	r2, [sp, #16]
    9388:	429a      	cmp	r2, r3
    938a:	daef      	bge.n	936c <lv_draw_fill+0x100>
            lv_coord_t copy_size   = (fill_area->x2 - fill_area->x1 + 1) * sizeof(lv_color_t);
    938c:	3201      	adds	r2, #1
            lv_color_t * mem_first = &mem[fill_area->x1];
    938e:	00a3      	lsls	r3, r4, #2
            lv_coord_t copy_size   = (fill_area->x2 - fill_area->x1 + 1) * sizeof(lv_color_t);
    9390:	1b14      	subs	r4, r2, r4
            lv_color_t * mem_first = &mem[fill_area->x1];
    9392:	eb0a 0603 	add.w	r6, sl, r3
            lv_coord_t copy_size   = (fill_area->x2 - fill_area->x1 + 1) * sizeof(lv_color_t);
    9396:	00a4      	lsls	r4, r4, #2
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
    9398:	f10b 0701 	add.w	r7, fp, #1
    939c:	442b      	add	r3, r5
            lv_coord_t copy_size   = (fill_area->x2 - fill_area->x1 + 1) * sizeof(lv_color_t);
    939e:	b224      	sxth	r4, r4
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
    93a0:	b23f      	sxth	r7, r7
    93a2:	449a      	add	sl, r3
    93a4:	9b08      	ldr	r3, [sp, #32]
    93a6:	42bb      	cmp	r3, r7
    93a8:	dbdb      	blt.n	9362 <lv_draw_fill+0xf6>
                memcpy(&mem[fill_area->x1], mem_first, copy_size);
    93aa:	4650      	mov	r0, sl
    93ac:	4622      	mov	r2, r4
    93ae:	4631      	mov	r1, r6
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
    93b0:	3701      	adds	r7, #1
                memcpy(&mem[fill_area->x1], mem_first, copy_size);
    93b2:	f7fe fe7b 	bl	80ac <memcpy>
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
    93b6:	b23f      	sxth	r7, r7
    93b8:	44aa      	add	sl, r5
    93ba:	e7f3      	b.n	93a4 <lv_draw_fill+0x138>
            for(col = fill_area->x1; col <= fill_area->x2; col++) {
    93bc:	4623      	mov	r3, r4
    93be:	e7e2      	b.n	9386 <lv_draw_fill+0x11a>
                    if(scr_transp == false) {
                        /*If the bg color changed recalculate the result color*/
                        if(mem[col].full != bg_tmp.full) {
    93c0:	f85a 3026 	ldr.w	r3, [sl, r6, lsl #2]
    93c4:	4543      	cmp	r3, r8
    93c6:	eb0a 0986 	add.w	r9, sl, r6, lsl #2
    93ca:	d00e      	beq.n	93ea <lv_draw_fill+0x17e>
                            bg_tmp  = mem[col];
    93cc:	4698      	mov	r8, r3
                            opa_tmp = lv_color_mix(color, bg_tmp, opa);
    93ce:	f3c3 4307 	ubfx	r3, r3, #16, #8
    93d2:	9301      	str	r3, [sp, #4]
    93d4:	f3c8 2307 	ubfx	r3, r8, #8, #8
    93d8:	9300      	str	r3, [sp, #0]
    93da:	9702      	str	r7, [sp, #8]
    93dc:	fa5f f388 	uxtb.w	r3, r8
    93e0:	e9dd 1206 	ldrd	r1, r2, [sp, #24]
    93e4:	9805      	ldr	r0, [sp, #20]
    93e6:	f7ff ff1c 	bl	9222 <lv_color_mix.isra.0>
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
    93ea:	3601      	adds	r6, #1
                        }

                        mem[col] = opa_tmp;
    93ec:	f8c9 0000 	str.w	r0, [r9]
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
    93f0:	b236      	sxth	r6, r6
    93f2:	9b04      	ldr	r3, [sp, #16]
    93f4:	42b3      	cmp	r3, r6
    93f6:	dae3      	bge.n	93c0 <lv_draw_fill+0x154>
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
    93f8:	f10b 0301 	add.w	r3, fp, #1
#if LV_COLOR_DEPTH == 32 && LV_COLOR_SCREEN_TRANSP
                        mem[col] = color_mix_2_alpha(mem[col], mem[col].ch.alpha, color, opa);
#endif
                    }
                }
                mem += mem_width;
    93fc:	44aa      	add	sl, r5
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
    93fe:	fa0f fb83 	sxth.w	fp, r3
    9402:	e788      	b.n	9316 <lv_draw_fill+0xaa>

00009404 <lv_draw_cont_radius_corr>:
}

#endif

static uint16_t lv_draw_cont_radius_corr(uint16_t r, lv_coord_t w, lv_coord_t h)
{
    9404:	b570      	push	{r4, r5, r6, lr}
    9406:	460e      	mov	r6, r1
    9408:	4604      	mov	r4, r0
    940a:	4615      	mov	r5, r2
    bool aa = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    940c:	f7fa fdae 	bl	3f6c <lv_refr_get_disp_refreshing>
    9410:	f000 fef3 	bl	a1fa <lv_disp_get_antialiasing>

    if(r >= (w >> 1)) {
    9414:	1071      	asrs	r1, r6, #1
    9416:	428c      	cmp	r4, r1
    9418:	db03      	blt.n	9422 <lv_draw_cont_radius_corr+0x1e>
        r = (w >> 1);
    941a:	b28c      	uxth	r4, r1
        if(r != 0) r--;
    941c:	b10c      	cbz	r4, 9422 <lv_draw_cont_radius_corr+0x1e>
    941e:	3c01      	subs	r4, #1
    9420:	b2a4      	uxth	r4, r4
    }
    if(r >= (h >> 1)) {
    9422:	106a      	asrs	r2, r5, #1
    9424:	4294      	cmp	r4, r2
    9426:	db03      	blt.n	9430 <lv_draw_cont_radius_corr+0x2c>
        r = (h >> 1);
    9428:	b294      	uxth	r4, r2
        if(r != 0) r--;
    942a:	b124      	cbz	r4, 9436 <lv_draw_cont_radius_corr+0x32>
    942c:	3c01      	subs	r4, #1
    942e:	b2a4      	uxth	r4, r4
    }

    if(r > 0) r -= aa;
    9430:	b10c      	cbz	r4, 9436 <lv_draw_cont_radius_corr+0x32>
    9432:	1a24      	subs	r4, r4, r0
    9434:	b2a4      	uxth	r4, r4

    return r;
}
    9436:	4620      	mov	r0, r4
    9438:	bd70      	pop	{r4, r5, r6, pc}

0000943a <lv_color_mix.isra.0>:
#elif LV_COLOR_DEPTH == 32
    return color.full;
#endif
}

static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
    943a:	b530      	push	{r4, r5, lr}
    943c:	f89d 5014 	ldrb.w	r5, [sp, #20]
{
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    9440:	b2ac      	uxth	r4, r5
    9442:	f1c5 05ff 	rsb	r5, r5, #255	; 0xff
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    LV_COLOR_SET_B(ret, (uint16_t)((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) * (255 - mix)) >> 8);
    9446:	436b      	muls	r3, r5
    9448:	fb00 3304 	mla	r3, r0, r4, r3
    944c:	f3c3 2307 	ubfx	r3, r3, #8, #8
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
    9450:	2000      	movs	r0, #0
    9452:	f363 0007 	bfi	r0, r3, #0, #8
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    9456:	f89d 300c 	ldrb.w	r3, [sp, #12]
    945a:	fb13 f305 	smulbb	r3, r3, r5
    945e:	fb01 3104 	mla	r1, r1, r4, r3
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    9462:	f89d 3010 	ldrb.w	r3, [sp, #16]
    9466:	fb13 f505 	smulbb	r5, r3, r5
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    946a:	f3c1 2107 	ubfx	r1, r1, #8, #8
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    946e:	fb02 5204 	mla	r2, r2, r4, r5
    return ret;
    9472:	f361 200f 	bfi	r0, r1, #8, #8
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
    9476:	f3c2 2207 	ubfx	r2, r2, #8, #8
    return ret;
    947a:	f362 4017 	bfi	r0, r2, #16, #8
}
    947e:	f040 407f 	orr.w	r0, r0, #4278190080	; 0xff000000
    9482:	bd30      	pop	{r4, r5, pc}

00009484 <lv_draw_rect>:
{
    9484:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9488:	b09d      	sub	sp, #116	; 0x74
    948a:	e9cd 1205 	strd	r1, r2, [sp, #20]
    948e:	9307      	str	r3, [sp, #28]
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    9490:	88c3      	ldrh	r3, [r0, #6]
    9492:	8842      	ldrh	r2, [r0, #2]
    9494:	3301      	adds	r3, #1
    9496:	1a9b      	subs	r3, r3, r2
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
    9498:	b21b      	sxth	r3, r3
    949a:	2b00      	cmp	r3, #0
{
    949c:	4681      	mov	r9, r0
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
    949e:	f340 8236 	ble.w	990e <lv_draw_rect+0x48a>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    94a2:	8883      	ldrh	r3, [r0, #4]
    94a4:	8802      	ldrh	r2, [r0, #0]
    94a6:	3301      	adds	r3, #1
    94a8:	1a9b      	subs	r3, r3, r2
    94aa:	b21b      	sxth	r3, r3
    94ac:	2b00      	cmp	r3, #0
    94ae:	f340 822e 	ble.w	990e <lv_draw_rect+0x48a>
    if(lv_area_is_on(coords, mask) == false) return;
    94b2:	f000 ff53 	bl	a35c <lv_area_is_on>
    94b6:	2800      	cmp	r0, #0
    94b8:	f000 8229 	beq.w	990e <lv_draw_rect+0x48a>
    if(style->body.opa > LV_OPA_MIN) {
    94bc:	9b06      	ldr	r3, [sp, #24]
    94be:	7b9b      	ldrb	r3, [r3, #14]
    94c0:	2b10      	cmp	r3, #16
    94c2:	f240 80fd 	bls.w	96c0 <lv_draw_rect+0x23c>
    uint16_t radius = style->body.radius;
    94c6:	9b06      	ldr	r3, [sp, #24]
    94c8:	899d      	ldrh	r5, [r3, #12]
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    94ca:	f7fa fd4f 	bl	3f6c <lv_refr_get_disp_refreshing>
    94ce:	f000 fe94 	bl	a1fa <lv_disp_get_antialiasing>
    lv_color_t mcolor = style->body.main_color;
    94d2:	9b06      	ldr	r3, [sp, #24]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    94d4:	f8b9 6006 	ldrh.w	r6, [r9, #6]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    94d8:	f8b9 1004 	ldrh.w	r1, [r9, #4]
    lv_color_t gcolor = style->body.grad_color;
    94dc:	e9d3 8a01 	ldrd	r8, sl, [r3, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    94e0:	f8b9 3002 	ldrh.w	r3, [r9, #2]
    94e4:	3601      	adds	r6, #1
    94e6:	1af6      	subs	r6, r6, r3
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    94e8:	f8b9 3000 	ldrh.w	r3, [r9]
    94ec:	3101      	adds	r1, #1
    94ee:	1ac9      	subs	r1, r1, r3
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
    94f0:	9b07      	ldr	r3, [sp, #28]
    94f2:	2bff      	cmp	r3, #255	; 0xff
    94f4:	9b06      	ldr	r3, [sp, #24]
    94f6:	7b9f      	ldrb	r7, [r3, #14]
    94f8:	bf18      	it	ne
    94fa:	9b07      	ldrne	r3, [sp, #28]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    94fc:	b236      	sxth	r6, r6
    94fe:	bf18      	it	ne
    9500:	435f      	mulne	r7, r3
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    9502:	4604      	mov	r4, r0
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    9504:	b209      	sxth	r1, r1
    radius = lv_draw_cont_radius_corr(radius, width, height);
    9506:	4632      	mov	r2, r6
    9508:	4628      	mov	r0, r5
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
    950a:	bf18      	it	ne
    950c:	0a3f      	lsrne	r7, r7, #8
    radius = lv_draw_cont_radius_corr(radius, width, height);
    950e:	f7ff ff79 	bl	9404 <lv_draw_cont_radius_corr>
    if(radius > height / 2) return;
    9512:	eb06 73d6 	add.w	r3, r6, r6, lsr #31
    9516:	ebb0 0f63 	cmp.w	r0, r3, asr #1
    951a:	f340 81fb 	ble.w	9914 <lv_draw_rect+0x490>
        if(style->body.radius != 0) {
    951e:	9b06      	ldr	r3, [sp, #24]
    9520:	f9b3 700c 	ldrsh.w	r7, [r3, #12]
    9524:	2f00      	cmp	r7, #0
    9526:	f000 80cb 	beq.w	96c0 <lv_draw_rect+0x23c>
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    952a:	f7fa fd1f 	bl	3f6c <lv_refr_get_disp_refreshing>
    952e:	f000 fe64 	bl	a1fa <lv_disp_get_antialiasing>
    lv_color_t mcolor = style->body.main_color;
    9532:	9b06      	ldr	r3, [sp, #24]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    9534:	f8b9 a006 	ldrh.w	sl, [r9, #6]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    9538:	f8b9 1004 	ldrh.w	r1, [r9, #4]
    lv_color_t gcolor = style->body.grad_color;
    953c:	e9d3 4501 	ldrd	r4, r5, [r3, #4]
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
    9540:	9b07      	ldr	r3, [sp, #28]
    9542:	2bff      	cmp	r3, #255	; 0xff
    9544:	9b06      	ldr	r3, [sp, #24]
    9546:	7b9e      	ldrb	r6, [r3, #14]
    9548:	bf1c      	itt	ne
    954a:	9b07      	ldrne	r3, [sp, #28]
    954c:	435e      	mulne	r6, r3
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    954e:	f8b9 3002 	ldrh.w	r3, [r9, #2]
    9552:	f10a 0a01 	add.w	sl, sl, #1
    9556:	ebaa 0a03 	sub.w	sl, sl, r3
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    955a:	f8b9 3000 	ldrh.w	r3, [r9]
    955e:	f101 0101 	add.w	r1, r1, #1
    9562:	eba1 0103 	sub.w	r1, r1, r3
    uint16_t radius = style->body.radius;
    9566:	b2bf      	uxth	r7, r7
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    9568:	fa0f fa8a 	sxth.w	sl, sl
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    956c:	4683      	mov	fp, r0
    radius = lv_draw_cont_radius_corr(radius, width, height);
    956e:	4652      	mov	r2, sl
    9570:	b209      	sxth	r1, r1
    9572:	4638      	mov	r0, r7
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
    9574:	bf18      	it	ne
    9576:	0a36      	lsrne	r6, r6, #8
    radius = lv_draw_cont_radius_corr(radius, width, height);
    9578:	f7ff ff44 	bl	9404 <lv_draw_cont_radius_corr>
    lt_origo.x = coords->x1 + radius + aa;
    957c:	f8b9 3000 	ldrh.w	r3, [r9]
    9580:	fa0f f18b 	sxth.w	r1, fp
    9584:	b202      	sxth	r2, r0
    9586:	440b      	add	r3, r1
    9588:	4413      	add	r3, r2
    958a:	fa0f f883 	sxth.w	r8, r3
    lt_origo.y = coords->y1 + radius + aa;
    958e:	f8b9 3002 	ldrh.w	r3, [r9, #2]
    rt_origo.x = coords->x2 - radius - aa;
    9592:	f8b9 b004 	ldrh.w	fp, [r9, #4]
    lt_origo.y = coords->y1 + radius + aa;
    9596:	440b      	add	r3, r1
    9598:	4413      	add	r3, r2
    959a:	b21b      	sxth	r3, r3
    959c:	9308      	str	r3, [sp, #32]
    lb_origo.y = coords->y2 - radius - aa;
    959e:	f8b9 3006 	ldrh.w	r3, [r9, #6]
    95a2:	1a5b      	subs	r3, r3, r1
    95a4:	1a9b      	subs	r3, r3, r2
    95a6:	b21b      	sxth	r3, r3
    rt_origo.x = coords->x2 - radius - aa;
    95a8:	ebab 0b01 	sub.w	fp, fp, r1
    lv_circ_init(&cir, &cir_tmp, radius);
    95ac:	a813      	add	r0, sp, #76	; 0x4c
    95ae:	f10d 014a 	add.w	r1, sp, #74	; 0x4a
    rt_origo.x = coords->x2 - radius - aa;
    95b2:	ebab 0b02 	sub.w	fp, fp, r2
    lb_origo.y = coords->y2 - radius - aa;
    95b6:	9309      	str	r3, [sp, #36]	; 0x24
    lv_circ_init(&cir, &cir_tmp, radius);
    95b8:	f000 fe4a 	bl	a250 <lv_circ_init>
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
    95bc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    95be:	f8bd 204e 	ldrh.w	r2, [sp, #78]	; 0x4e
    95c2:	f9bd 104c 	ldrsh.w	r1, [sp, #76]	; 0x4c
    rt_origo.x = coords->x2 - radius - aa;
    95c6:	fa0f fb8b 	sxth.w	fp, fp
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
    95ca:	441a      	add	r2, r3
    95cc:	b212      	sxth	r2, r2
    95ce:	eb0b 0301 	add.w	r3, fp, r1
    95d2:	eba8 0101 	sub.w	r1, r8, r1
    95d6:	9200      	str	r2, [sp, #0]
    95d8:	b21b      	sxth	r3, r3
    95da:	b209      	sxth	r1, r1
    95dc:	a818      	add	r0, sp, #96	; 0x60
    95de:	f000 fe5c 	bl	a29a <lv_area_set>
    lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
    95e2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    95e4:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
    95e8:	f9bd 104e 	ldrsh.w	r1, [sp, #78]	; 0x4e
    95ec:	441a      	add	r2, r3
    95ee:	b212      	sxth	r2, r2
    95f0:	eb0b 0301 	add.w	r3, fp, r1
    95f4:	eba8 0101 	sub.w	r1, r8, r1
    95f8:	9200      	str	r2, [sp, #0]
    95fa:	b21b      	sxth	r3, r3
    95fc:	b209      	sxth	r1, r1
    95fe:	a81a      	add	r0, sp, #104	; 0x68
    9600:	f000 fe4b 	bl	a29a <lv_area_set>
    lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
    9604:	9b08      	ldr	r3, [sp, #32]
    9606:	f8bd 204e 	ldrh.w	r2, [sp, #78]	; 0x4e
    960a:	f9bd 104c 	ldrsh.w	r1, [sp, #76]	; 0x4c
    960e:	1a9a      	subs	r2, r3, r2
    9610:	b212      	sxth	r2, r2
    9612:	eb0b 0301 	add.w	r3, fp, r1
    9616:	eba8 0101 	sub.w	r1, r8, r1
    961a:	9200      	str	r2, [sp, #0]
    961c:	b21b      	sxth	r3, r3
    961e:	b209      	sxth	r1, r1
    9620:	a816      	add	r0, sp, #88	; 0x58
    9622:	f000 fe3a 	bl	a29a <lv_area_set>
    lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
    9626:	9b08      	ldr	r3, [sp, #32]
    9628:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
    962c:	f9bd 104e 	ldrsh.w	r1, [sp, #78]	; 0x4e
    9630:	1a9a      	subs	r2, r3, r2
    9632:	b212      	sxth	r2, r2
    9634:	eb0b 0301 	add.w	r3, fp, r1
    9638:	af14      	add	r7, sp, #80	; 0x50
    963a:	eba8 0101 	sub.w	r1, r8, r1
    963e:	b21b      	sxth	r3, r3
    9640:	9200      	str	r2, [sp, #0]
    9642:	b209      	sxth	r1, r1
    9644:	4638      	mov	r0, r7
    9646:	f000 fe28 	bl	a29a <lv_area_set>
    while(lv_circ_cont(&cir)) {
    964a:	ab13      	add	r3, sp, #76	; 0x4c
            lv_draw_fill(&edge_top_area, mask, act_color, opa);
    964c:	e9cd 370b 	strd	r3, r7, [sp, #44]	; 0x2c
                act_color = lv_color_mix(mcolor, gcolor, mix);
    9650:	b2eb      	uxtb	r3, r5
    9652:	930a      	str	r3, [sp, #40]	; 0x28
    while(lv_circ_cont(&cir)) {
    9654:	980b      	ldr	r0, [sp, #44]	; 0x2c
    9656:	f000 fe02 	bl	a25e <lv_circ_cont>
    965a:	2800      	cmp	r0, #0
    965c:	f040 81c3 	bne.w	99e6 <lv_draw_rect+0x562>
    if(mcolor.full == gcolor.full)
    9660:	42ac      	cmp	r4, r5
    9662:	f040 82bd 	bne.w	9be0 <lv_draw_rect+0x75c>
        act_color = mcolor;
    9666:	4622      	mov	r2, r4
    lv_draw_fill(&edge_top_area, mask, act_color, opa);
    9668:	4633      	mov	r3, r6
    966a:	9905      	ldr	r1, [sp, #20]
    966c:	a814      	add	r0, sp, #80	; 0x50
    966e:	f7ff fdfd 	bl	926c <lv_draw_fill>
    if(edge_top_area.y1 != mid_top_area.y1) {
    9672:	f9bd 205a 	ldrsh.w	r2, [sp, #90]	; 0x5a
    9676:	f9bd 3052 	ldrsh.w	r3, [sp, #82]	; 0x52
    967a:	4293      	cmp	r3, r2
    967c:	d008      	beq.n	9690 <lv_draw_rect+0x20c>
        if(mcolor.full == gcolor.full)
    967e:	42ac      	cmp	r4, r5
    9680:	f040 82c9 	bne.w	9c16 <lv_draw_rect+0x792>
            act_color = mcolor;
    9684:	4622      	mov	r2, r4
        lv_draw_fill(&mid_top_area, mask, act_color, opa);
    9686:	4633      	mov	r3, r6
    9688:	9905      	ldr	r1, [sp, #20]
    968a:	a816      	add	r0, sp, #88	; 0x58
    968c:	f7ff fdee 	bl	926c <lv_draw_fill>
    if(mcolor.full == gcolor.full)
    9690:	42ac      	cmp	r4, r5
    9692:	f040 82d9 	bne.w	9c48 <lv_draw_rect+0x7c4>
        act_color = mcolor;
    9696:	4622      	mov	r2, r4
    lv_draw_fill(&mid_bot_area, mask, act_color, opa);
    9698:	4633      	mov	r3, r6
    969a:	9905      	ldr	r1, [sp, #20]
    969c:	a818      	add	r0, sp, #96	; 0x60
    969e:	f7ff fde5 	bl	926c <lv_draw_fill>
    if(edge_bot_area.y1 != mid_bot_area.y1) {
    96a2:	f9bd 206a 	ldrsh.w	r2, [sp, #106]	; 0x6a
    96a6:	f9bd 3062 	ldrsh.w	r3, [sp, #98]	; 0x62
    96aa:	4293      	cmp	r3, r2
    96ac:	d008      	beq.n	96c0 <lv_draw_rect+0x23c>
        if(mcolor.full == gcolor.full)
    96ae:	42ac      	cmp	r4, r5
    96b0:	f040 82e5 	bne.w	9c7e <lv_draw_rect+0x7fa>
            act_color = mcolor;
    96b4:	4622      	mov	r2, r4
        lv_draw_fill(&edge_bot_area, mask, act_color, opa);
    96b6:	4633      	mov	r3, r6
    96b8:	9905      	ldr	r1, [sp, #20]
    96ba:	a81a      	add	r0, sp, #104	; 0x68
    96bc:	f7ff fdd6 	bl	926c <lv_draw_fill>
    if(style->body.border.width != 0 && style->body.border.part != LV_BORDER_NONE &&
    96c0:	9b06      	ldr	r3, [sp, #24]
    96c2:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
    96c6:	2b00      	cmp	r3, #0
    96c8:	f000 8121 	beq.w	990e <lv_draw_rect+0x48a>
    96cc:	9b06      	ldr	r3, [sp, #24]
    96ce:	7d9b      	ldrb	r3, [r3, #22]
    96d0:	2b00      	cmp	r3, #0
    96d2:	f000 811c 	beq.w	990e <lv_draw_rect+0x48a>
    96d6:	9b06      	ldr	r3, [sp, #24]
    96d8:	7ddb      	ldrb	r3, [r3, #23]
    96da:	2b0f      	cmp	r3, #15
    96dc:	f240 8117 	bls.w	990e <lv_draw_rect+0x48a>
    uint16_t radius = style->body.radius;
    96e0:	9b06      	ldr	r3, [sp, #24]
    96e2:	f8b3 a00c 	ldrh.w	sl, [r3, #12]
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    96e6:	f7fa fc41 	bl	3f6c <lv_refr_get_disp_refreshing>
    96ea:	f000 fd86 	bl	a1fa <lv_disp_get_antialiasing>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    96ee:	f8b9 1004 	ldrh.w	r1, [r9, #4]
    96f2:	f8b9 3000 	ldrh.w	r3, [r9]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    96f6:	f8b9 2006 	ldrh.w	r2, [r9, #6]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    96fa:	3101      	adds	r1, #1
    96fc:	1ac9      	subs	r1, r1, r3
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    96fe:	f8b9 3002 	ldrh.w	r3, [r9, #2]
    9702:	3201      	adds	r2, #1
    9704:	1ad2      	subs	r2, r2, r3
    lv_coord_t bwidth = style->body.border.width;
    9706:	9b06      	ldr	r3, [sp, #24]
    9708:	f9b3 b014 	ldrsh.w	fp, [r3, #20]
    lv_opa_t opa      = opa_scale == LV_OPA_COVER ? style->body.border.opa
    970c:	9b07      	ldr	r3, [sp, #28]
    970e:	2bff      	cmp	r3, #255	; 0xff
    9710:	9b06      	ldr	r3, [sp, #24]
    9712:	7ddc      	ldrb	r4, [r3, #23]
    9714:	bf1c      	itt	ne
    9716:	9b07      	ldrne	r3, [sp, #28]
    9718:	435c      	mulne	r4, r3
    lv_border_part_t part = style->body.border.part;
    971a:	9b06      	ldr	r3, [sp, #24]
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    971c:	4680      	mov	r8, r0
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    971e:	b209      	sxth	r1, r1
    radius = lv_draw_cont_radius_corr(radius, width, height);
    9720:	4650      	mov	r0, sl
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    9722:	b212      	sxth	r2, r2
    lv_opa_t opa      = opa_scale == LV_OPA_COVER ? style->body.border.opa
    9724:	bf18      	it	ne
    9726:	0a24      	lsrne	r4, r4, #8
    lv_border_part_t part = style->body.border.part;
    9728:	7d9e      	ldrb	r6, [r3, #22]
    lv_color_t color      = style->body.border.color;
    972a:	691f      	ldr	r7, [r3, #16]
    radius = lv_draw_cont_radius_corr(radius, width, height);
    972c:	f7ff fe6a 	bl	9404 <lv_draw_cont_radius_corr>
    bwidth--;
    9730:	f10b 35ff 	add.w	r5, fp, #4294967295	; 0xffffffff
    9734:	b22d      	sxth	r5, r5
    if(radius < bwidth) {
    9736:	42a8      	cmp	r0, r5
    radius = lv_draw_cont_radius_corr(radius, width, height);
    9738:	4682      	mov	sl, r0
    if(radius < bwidth) {
    973a:	f280 82b9 	bge.w	9cb0 <lv_draw_rect+0x82c>
        length_corr = bwidth - radius - aa;
    973e:	eba5 0308 	sub.w	r3, r5, r8
    9742:	1a1b      	subs	r3, r3, r0
    9744:	b21b      	sxth	r3, r3
    9746:	9309      	str	r3, [sp, #36]	; 0x24
        corner_size = bwidth;
    9748:	462b      	mov	r3, r5
    if(style->body.radius == 0) {
    974a:	9a06      	ldr	r2, [sp, #24]
    974c:	f9b2 200c 	ldrsh.w	r2, [r2, #12]
    9750:	f006 0102 	and.w	r1, r6, #2
    9754:	9108      	str	r1, [sp, #32]
    9756:	2a00      	cmp	r2, #0
    9758:	f040 82b0 	bne.w	9cbc <lv_draw_rect+0x838>
        if(part & LV_BORDER_TOP) {
    975c:	b1a1      	cbz	r1, 9788 <lv_draw_rect+0x304>
            work_area.x1 = coords->x1;
    975e:	f8b9 3000 	ldrh.w	r3, [r9]
    9762:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            work_area.x2 = coords->x2;
    9766:	f8b9 3004 	ldrh.w	r3, [r9, #4]
    976a:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.y1 = coords->y1;
    976e:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
    9772:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            work_area.y2 = coords->y1 + bwidth;
    9776:	442b      	add	r3, r5
    9778:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    977c:	463a      	mov	r2, r7
    977e:	4623      	mov	r3, r4
    9780:	9905      	ldr	r1, [sp, #20]
    9782:	a81a      	add	r0, sp, #104	; 0x68
    9784:	f7ff fd72 	bl	926c <lv_draw_fill>
        if(part & LV_BORDER_RIGHT) {
    9788:	0731      	lsls	r1, r6, #28
    978a:	d520      	bpl.n	97ce <lv_draw_rect+0x34a>
            work_area.x1 = coords->x2 - bwidth;
    978c:	f9b9 3004 	ldrsh.w	r3, [r9, #4]
            work_area.x2 = coords->x2;
    9790:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.x1 = coords->x2 - bwidth;
    9794:	1b5a      	subs	r2, r3, r5
    9796:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
    979a:	9a08      	ldr	r2, [sp, #32]
    979c:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
            lv_draw_fill(&work_area, mask, color, opa);
    97a0:	9905      	ldr	r1, [sp, #20]
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
    97a2:	2a00      	cmp	r2, #0
    97a4:	bf14      	ite	ne
    97a6:	465a      	movne	r2, fp
    97a8:	2200      	moveq	r2, #0
    97aa:	4413      	add	r3, r2
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
    97ac:	f016 0f01 	tst.w	r6, #1
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
    97b0:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
    97b4:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    97b8:	bf14      	ite	ne
    97ba:	465a      	movne	r2, fp
    97bc:	2200      	moveq	r2, #0
    97be:	1a9b      	subs	r3, r3, r2
    97c0:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    97c4:	463a      	mov	r2, r7
    97c6:	4623      	mov	r3, r4
    97c8:	a81a      	add	r0, sp, #104	; 0x68
    97ca:	f7ff fd4f 	bl	926c <lv_draw_fill>
        if(part & LV_BORDER_LEFT) {
    97ce:	f016 0f04 	tst.w	r6, #4
    97d2:	f006 0601 	and.w	r6, r6, #1
    97d6:	d020      	beq.n	981a <lv_draw_rect+0x396>
            work_area.x1 = coords->x1;
    97d8:	f9b9 3000 	ldrsh.w	r3, [r9]
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
    97dc:	9a08      	ldr	r2, [sp, #32]
            work_area.x1 = coords->x1;
    97de:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            work_area.x2 = coords->x1 + bwidth;
    97e2:	442b      	add	r3, r5
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
    97e4:	2a00      	cmp	r2, #0
            work_area.x2 = coords->x1 + bwidth;
    97e6:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
    97ea:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
            lv_draw_fill(&work_area, mask, color, opa);
    97ee:	9905      	ldr	r1, [sp, #20]
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
    97f0:	bf14      	ite	ne
    97f2:	465a      	movne	r2, fp
    97f4:	2200      	moveq	r2, #0
    97f6:	4413      	add	r3, r2
    97f8:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
    97fc:	2e00      	cmp	r6, #0
    97fe:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    9802:	bf08      	it	eq
    9804:	f04f 0b00 	moveq.w	fp, #0
    9808:	eba3 0b0b 	sub.w	fp, r3, fp
            lv_draw_fill(&work_area, mask, color, opa);
    980c:	463a      	mov	r2, r7
    980e:	4623      	mov	r3, r4
    9810:	a81a      	add	r0, sp, #104	; 0x68
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
    9812:	f8ad b06e 	strh.w	fp, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    9816:	f7ff fd29 	bl	926c <lv_draw_fill>
        if(part & LV_BORDER_BOTTOM) {
    981a:	b1a6      	cbz	r6, 9846 <lv_draw_rect+0x3c2>
            work_area.x1 = coords->x1;
    981c:	f8b9 3000 	ldrh.w	r3, [r9]
    9820:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            work_area.x2 = coords->x2;
    9824:	f8b9 3004 	ldrh.w	r3, [r9, #4]
    9828:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.y1 = coords->y2 - bwidth;
    982c:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    9830:	1b5d      	subs	r5, r3, r5
    9832:	f8ad 506a 	strh.w	r5, [sp, #106]	; 0x6a
            work_area.y2 = coords->y2;
    9836:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    983a:	463a      	mov	r2, r7
    983c:	4623      	mov	r3, r4
    983e:	9905      	ldr	r1, [sp, #20]
    9840:	a81a      	add	r0, sp, #104	; 0x68
    9842:	f7ff fd13 	bl	926c <lv_draw_fill>
        if(style->body.radius != 0) {
    9846:	9b06      	ldr	r3, [sp, #24]
    9848:	f9b3 400c 	ldrsh.w	r4, [r3, #12]
    984c:	2c00      	cmp	r4, #0
    984e:	d05e      	beq.n	990e <lv_draw_rect+0x48a>
    bool aa               = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    9850:	f7fa fb8c 	bl	3f6c <lv_refr_get_disp_refreshing>
    9854:	f000 fcd1 	bl	a1fa <lv_disp_get_antialiasing>
    lv_coord_t bwidth     = style->body.border.width;
    9858:	9b06      	ldr	r3, [sp, #24]
    985a:	f8b9 2006 	ldrh.w	r2, [r9, #6]
    985e:	f9b3 a014 	ldrsh.w	sl, [r3, #20]
    lv_color_t color      = style->body.border.color;
    9862:	f8d3 b010 	ldr.w	fp, [r3, #16]
    lv_border_part_t part = style->body.border.part;
    9866:	7d9b      	ldrb	r3, [r3, #22]
    9868:	9308      	str	r3, [sp, #32]
    lv_opa_t opa          = opa_scale == LV_OPA_COVER ? style->body.border.opa
    986a:	9b07      	ldr	r3, [sp, #28]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    986c:	f8b9 1004 	ldrh.w	r1, [r9, #4]
    9870:	2bff      	cmp	r3, #255	; 0xff
    9872:	9b06      	ldr	r3, [sp, #24]
    9874:	7ddd      	ldrb	r5, [r3, #23]
    9876:	bf1c      	itt	ne
    9878:	9b07      	ldrne	r3, [sp, #28]
    987a:	435d      	mulne	r5, r3
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    987c:	f8b9 3002 	ldrh.w	r3, [r9, #2]
    9880:	f102 0201 	add.w	r2, r2, #1
    9884:	eba2 0203 	sub.w	r2, r2, r3
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    9888:	f8b9 3000 	ldrh.w	r3, [r9]
    988c:	f101 0101 	add.w	r1, r1, #1
    9890:	eba1 0103 	sub.w	r1, r1, r3
    uint16_t radius       = style->body.radius;
    9894:	b2a4      	uxth	r4, r4
    bool aa               = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
    9896:	4606      	mov	r6, r0
    radius = lv_draw_cont_radius_corr(radius, width, height);
    9898:	b212      	sxth	r2, r2
    989a:	b209      	sxth	r1, r1
    989c:	4620      	mov	r0, r4
    lv_opa_t opa          = opa_scale == LV_OPA_COVER ? style->body.border.opa
    989e:	bf18      	it	ne
    98a0:	0a2d      	lsrne	r5, r5, #8
    radius = lv_draw_cont_radius_corr(radius, width, height);
    98a2:	f7ff fdaf 	bl	9404 <lv_draw_cont_radius_corr>
    lb_origo.y = coords->y2 - radius - aa;
    98a6:	f8b9 3006 	ldrh.w	r3, [r9, #6]
    lt_origo.x = coords->x1 + radius + aa;
    98aa:	f8b9 7000 	ldrh.w	r7, [r9]
    lt_origo.y = coords->y1 + radius + aa;
    98ae:	f8b9 8002 	ldrh.w	r8, [r9, #2]
    rt_origo.x = coords->x2 - radius - aa;
    98b2:	f8b9 9004 	ldrh.w	r9, [r9, #4]
    lt_origo.x = coords->x1 + radius + aa;
    98b6:	b232      	sxth	r2, r6
    98b8:	b204      	sxth	r4, r0
    lb_origo.y = coords->y2 - radius - aa;
    98ba:	1a9b      	subs	r3, r3, r2
    98bc:	1b1b      	subs	r3, r3, r4
    lt_origo.x = coords->x1 + radius + aa;
    98be:	4417      	add	r7, r2
    lt_origo.y = coords->y1 + radius + aa;
    98c0:	4490      	add	r8, r2
    rt_origo.x = coords->x2 - radius - aa;
    98c2:	eba9 0902 	sub.w	r9, r9, r2
    lv_circ_init(&cir_out, &tmp_out, radius);
    98c6:	a913      	add	r1, sp, #76	; 0x4c
    98c8:	4622      	mov	r2, r4
    98ca:	a816      	add	r0, sp, #88	; 0x58
    lb_origo.y = coords->y2 - radius - aa;
    98cc:	b21e      	sxth	r6, r3
    lv_circ_init(&cir_out, &tmp_out, radius);
    98ce:	f000 fcbf 	bl	a250 <lv_circ_init>
    lv_coord_t radius_in = radius - bwidth;
    98d2:	f1ca 0201 	rsb	r2, sl, #1
    98d6:	4422      	add	r2, r4
    98d8:	b212      	sxth	r2, r2
    lv_circ_init(&cir_in, &tmp_in, radius_in);
    98da:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    98de:	a914      	add	r1, sp, #80	; 0x50
    98e0:	a818      	add	r0, sp, #96	; 0x60
    98e2:	f000 fcb5 	bl	a250 <lv_circ_init>
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
    98e6:	9b08      	ldr	r3, [sp, #32]
    lt_origo.x = coords->x1 + radius + aa;
    98e8:	4427      	add	r7, r4
    lt_origo.y = coords->y1 + radius + aa;
    98ea:	44a0      	add	r8, r4
    rt_origo.x = coords->x2 - radius - aa;
    98ec:	eba9 0904 	sub.w	r9, r9, r4
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
    98f0:	f003 0309 	and.w	r3, r3, #9
    lt_origo.x = coords->x1 + radius + aa;
    98f4:	b23f      	sxth	r7, r7
    lt_origo.y = coords->y1 + radius + aa;
    98f6:	fa0f f888 	sxth.w	r8, r8
    rt_origo.x = coords->x2 - radius - aa;
    98fa:	fa0f f989 	sxth.w	r9, r9
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
    98fe:	9306      	str	r3, [sp, #24]
    while(cir_out.y <= cir_out.x) {
    9900:	f9bd 305a 	ldrsh.w	r3, [sp, #90]	; 0x5a
    9904:	f9bd 2058 	ldrsh.w	r2, [sp, #88]	; 0x58
    9908:	429a      	cmp	r2, r3
    990a:	f280 8330 	bge.w	9f6e <lv_draw_rect+0xaea>
}
    990e:	b01d      	add	sp, #116	; 0x74
    9910:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    work_area.x1 = coords->x1;
    9914:	f8b9 3000 	ldrh.w	r3, [r9]
    9918:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    work_area.x2 = coords->x2;
    991c:	f8b9 3004 	ldrh.w	r3, [r9, #4]
    9920:	f8b9 5006 	ldrh.w	r5, [r9, #6]
    9924:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
    if(mcolor.full == gcolor.full) {
    9928:	f8b9 3002 	ldrh.w	r3, [r9, #2]
    992c:	9a06      	ldr	r2, [sp, #24]
    992e:	b200      	sxth	r0, r0
    9930:	4403      	add	r3, r0
    9932:	45d0      	cmp	r8, sl
    9934:	eba5 0000 	sub.w	r0, r5, r0
    9938:	b21b      	sxth	r3, r3
    993a:	b205      	sxth	r5, r0
    993c:	f9b2 200c 	ldrsh.w	r2, [r2, #12]
    9940:	d117      	bne.n	9972 <lv_draw_rect+0x4ee>
        work_area.y1 = coords->y1 + radius;
    9942:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
        work_area.y2 = coords->y2 - radius;
    9946:	f8ad 506e 	strh.w	r5, [sp, #110]	; 0x6e
        if(style->body.radius != 0) {
    994a:	b132      	cbz	r2, 995a <lv_draw_rect+0x4d6>
            if(aa) {
    994c:	b164      	cbz	r4, 9968 <lv_draw_rect+0x4e4>
                work_area.y1 += 2;
    994e:	1c9c      	adds	r4, r3, #2
    9950:	f8ad 406a 	strh.w	r4, [sp, #106]	; 0x6a
                work_area.y2 -= 2;
    9954:	3d02      	subs	r5, #2
                work_area.y2 -= 1;
    9956:	f8ad 506e 	strh.w	r5, [sp, #110]	; 0x6e
        lv_draw_fill(&work_area, mask, mcolor, opa);
    995a:	463b      	mov	r3, r7
    995c:	4642      	mov	r2, r8
    995e:	9905      	ldr	r1, [sp, #20]
    9960:	a81a      	add	r0, sp, #104	; 0x68
    9962:	f7ff fc83 	bl	926c <lv_draw_fill>
    9966:	e5da      	b.n	951e <lv_draw_rect+0x9a>
                work_area.y1 += 1;
    9968:	1c5c      	adds	r4, r3, #1
    996a:	f8ad 406a 	strh.w	r4, [sp, #106]	; 0x6a
                work_area.y2 -= 1;
    996e:	3d01      	subs	r5, #1
    9970:	e7f1      	b.n	9956 <lv_draw_rect+0x4d2>
        if(style->body.radius != 0) {
    9972:	b122      	cbz	r2, 997e <lv_draw_rect+0x4fa>
            if(aa) {
    9974:	b39c      	cbz	r4, 99de <lv_draw_rect+0x55a>
                row_start += 2;
    9976:	1c9c      	adds	r4, r3, #2
    9978:	b223      	sxth	r3, r4
                row_end -= 2;
    997a:	3d02      	subs	r5, #2
                row_end -= 1;
    997c:	b22d      	sxth	r5, r5
        if(row_start < 0) row_start = 0;
    997e:	ea23 74e3 	bic.w	r4, r3, r3, asr #31
            act_color    = lv_color_mix(mcolor, gcolor, mix);
    9982:	fa5f f38a 	uxtb.w	r3, sl
    9986:	9308      	str	r3, [sp, #32]
    9988:	f3c8 4307 	ubfx	r3, r8, #16, #8
    998c:	9309      	str	r3, [sp, #36]	; 0x24
    998e:	f3c8 2b07 	ubfx	fp, r8, #8, #8
        for(row = row_start; row <= row_end; row++) {
    9992:	42ac      	cmp	r4, r5
    9994:	f73f adc3 	bgt.w	951e <lv_draw_rect+0x9a>
            mix          = (uint32_t)((uint32_t)(coords->y2 - work_area.y1) * 255) / height;
    9998:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
            work_area.y1 = row;
    999c:	f8ad 406a 	strh.w	r4, [sp, #106]	; 0x6a
            mix          = (uint32_t)((uint32_t)(coords->y2 - work_area.y1) * 255) / height;
    99a0:	1b1b      	subs	r3, r3, r4
    99a2:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    99a6:	fbb3 f3f6 	udiv	r3, r3, r6
            act_color    = lv_color_mix(mcolor, gcolor, mix);
    99aa:	b2db      	uxtb	r3, r3
    99ac:	9302      	str	r3, [sp, #8]
    99ae:	f3ca 4307 	ubfx	r3, sl, #16, #8
    99b2:	9301      	str	r3, [sp, #4]
    99b4:	f3ca 2307 	ubfx	r3, sl, #8, #8
    99b8:	9300      	str	r3, [sp, #0]
    99ba:	4659      	mov	r1, fp
    99bc:	e9dd 3208 	ldrd	r3, r2, [sp, #32]
    99c0:	fa5f f088 	uxtb.w	r0, r8
            work_area.y2 = row;
    99c4:	f8ad 406e 	strh.w	r4, [sp, #110]	; 0x6e
            act_color    = lv_color_mix(mcolor, gcolor, mix);
    99c8:	f7ff fd37 	bl	943a <lv_color_mix.isra.0>
        for(row = row_start; row <= row_end; row++) {
    99cc:	3401      	adds	r4, #1
            lv_draw_fill(&work_area, mask, act_color, opa);
    99ce:	4602      	mov	r2, r0
    99d0:	463b      	mov	r3, r7
    99d2:	9905      	ldr	r1, [sp, #20]
    99d4:	a81a      	add	r0, sp, #104	; 0x68
    99d6:	f7ff fc49 	bl	926c <lv_draw_fill>
        for(row = row_start; row <= row_end; row++) {
    99da:	b224      	sxth	r4, r4
    99dc:	e7d9      	b.n	9992 <lv_draw_rect+0x50e>
                row_start += 1;
    99de:	1c5c      	adds	r4, r3, #1
    99e0:	b223      	sxth	r3, r4
                row_end -= 1;
    99e2:	3d01      	subs	r5, #1
    99e4:	e7ca      	b.n	997c <lv_draw_rect+0x4f8>
        if(mid_bot_area.y1 != LV_CIRC_OCT4_Y(cir) + lb_origo.y) mid_bot_refr = 1;
    99e6:	f9bd 3062 	ldrsh.w	r3, [sp, #98]	; 0x62
    99ea:	f9bd 704e 	ldrsh.w	r7, [sp, #78]	; 0x4e
    99ee:	930d      	str	r3, [sp, #52]	; 0x34
    99f0:	9b09      	ldr	r3, [sp, #36]	; 0x24
        if(edge_bot_area.y1 != LV_CIRC_OCT2_Y(cir) + lb_origo.y) edge_bot_refr = 1;
    99f2:	f9bd 204c 	ldrsh.w	r2, [sp, #76]	; 0x4c
        if(edge_top_area.y1 != LV_CIRC_OCT7_Y(cir) + lt_origo.y) edge_top_refr = 1;
    99f6:	f9bd 1052 	ldrsh.w	r1, [sp, #82]	; 0x52
        if(mid_bot_area.y1 != LV_CIRC_OCT4_Y(cir) + lb_origo.y) mid_bot_refr = 1;
    99fa:	18fb      	adds	r3, r7, r3
    99fc:	930e      	str	r3, [sp, #56]	; 0x38
        if(edge_bot_area.y1 != LV_CIRC_OCT2_Y(cir) + lb_origo.y) edge_bot_refr = 1;
    99fe:	f9bd 306a 	ldrsh.w	r3, [sp, #106]	; 0x6a
    9a02:	930f      	str	r3, [sp, #60]	; 0x3c
    9a04:	9b09      	ldr	r3, [sp, #36]	; 0x24
    9a06:	4413      	add	r3, r2
    9a08:	9310      	str	r3, [sp, #64]	; 0x40
        if(mid_top_area.y1 != LV_CIRC_OCT8_Y(cir) + lt_origo.y) mid_top_refr = 1;
    9a0a:	f9bd 305a 	ldrsh.w	r3, [sp, #90]	; 0x5a
    9a0e:	9311      	str	r3, [sp, #68]	; 0x44
    9a10:	9b08      	ldr	r3, [sp, #32]
        if(edge_top_area.y1 != LV_CIRC_OCT7_Y(cir) + lt_origo.y) edge_top_refr = 1;
    9a12:	1a9a      	subs	r2, r3, r2
    9a14:	4291      	cmp	r1, r2
        if(mid_top_area.y1 != LV_CIRC_OCT8_Y(cir) + lt_origo.y) mid_top_refr = 1;
    9a16:	eba3 0707 	sub.w	r7, r3, r7
        if(edge_top_area.y1 != LV_CIRC_OCT7_Y(cir) + lt_origo.y) edge_top_refr = 1;
    9a1a:	d007      	beq.n	9a2c <lv_draw_rect+0x5a8>
            if(mcolor.full == gcolor.full)
    9a1c:	42ac      	cmp	r4, r5
    9a1e:	d175      	bne.n	9b0c <lv_draw_rect+0x688>
                act_color = mcolor;
    9a20:	4622      	mov	r2, r4
            lv_draw_fill(&edge_top_area, mask, act_color, opa);
    9a22:	4633      	mov	r3, r6
    9a24:	9905      	ldr	r1, [sp, #20]
    9a26:	980c      	ldr	r0, [sp, #48]	; 0x30
    9a28:	f7ff fc20 	bl	926c <lv_draw_fill>
        if(mid_top_refr != 0) {
    9a2c:	9b11      	ldr	r3, [sp, #68]	; 0x44
    9a2e:	42bb      	cmp	r3, r7
    9a30:	d008      	beq.n	9a44 <lv_draw_rect+0x5c0>
            if(mcolor.full == gcolor.full)
    9a32:	42ac      	cmp	r4, r5
    9a34:	f040 8083 	bne.w	9b3e <lv_draw_rect+0x6ba>
                act_color = mcolor;
    9a38:	4622      	mov	r2, r4
            lv_draw_fill(&mid_top_area, mask, act_color, opa);
    9a3a:	4633      	mov	r3, r6
    9a3c:	9905      	ldr	r1, [sp, #20]
    9a3e:	a816      	add	r0, sp, #88	; 0x58
    9a40:	f7ff fc14 	bl	926c <lv_draw_fill>
        if(mid_bot_refr != 0) {
    9a44:	e9dd 320d 	ldrd	r3, r2, [sp, #52]	; 0x34
    9a48:	4293      	cmp	r3, r2
    9a4a:	d008      	beq.n	9a5e <lv_draw_rect+0x5da>
            if(mcolor.full == gcolor.full)
    9a4c:	42ac      	cmp	r4, r5
    9a4e:	f040 8091 	bne.w	9b74 <lv_draw_rect+0x6f0>
                act_color = mcolor;
    9a52:	4622      	mov	r2, r4
            lv_draw_fill(&mid_bot_area, mask, act_color, opa);
    9a54:	4633      	mov	r3, r6
    9a56:	9905      	ldr	r1, [sp, #20]
    9a58:	a818      	add	r0, sp, #96	; 0x60
    9a5a:	f7ff fc07 	bl	926c <lv_draw_fill>
        if(edge_bot_refr != 0) {
    9a5e:	e9dd 320f 	ldrd	r3, r2, [sp, #60]	; 0x3c
    9a62:	4293      	cmp	r3, r2
    9a64:	d008      	beq.n	9a78 <lv_draw_rect+0x5f4>
            if(mcolor.full == gcolor.full)
    9a66:	42ac      	cmp	r4, r5
    9a68:	f040 809f 	bne.w	9baa <lv_draw_rect+0x726>
                act_color = mcolor;
    9a6c:	4622      	mov	r2, r4
            lv_draw_fill(&edge_bot_area, mask, act_color, opa);
    9a6e:	4633      	mov	r3, r6
    9a70:	9905      	ldr	r1, [sp, #20]
    9a72:	a81a      	add	r0, sp, #104	; 0x68
    9a74:	f7ff fbfa 	bl	926c <lv_draw_fill>
        lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
    9a78:	9b09      	ldr	r3, [sp, #36]	; 0x24
    9a7a:	f8bd 204e 	ldrh.w	r2, [sp, #78]	; 0x4e
    9a7e:	f9bd 104c 	ldrsh.w	r1, [sp, #76]	; 0x4c
    9a82:	441a      	add	r2, r3
    9a84:	b212      	sxth	r2, r2
    9a86:	eb0b 0301 	add.w	r3, fp, r1
    9a8a:	eba8 0101 	sub.w	r1, r8, r1
    9a8e:	9200      	str	r2, [sp, #0]
    9a90:	a818      	add	r0, sp, #96	; 0x60
    9a92:	b21b      	sxth	r3, r3
    9a94:	b209      	sxth	r1, r1
    9a96:	f000 fc00 	bl	a29a <lv_area_set>
        lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
    9a9a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    9a9c:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
    9aa0:	f9bd 104e 	ldrsh.w	r1, [sp, #78]	; 0x4e
    9aa4:	441a      	add	r2, r3
    9aa6:	b212      	sxth	r2, r2
    9aa8:	eb0b 0301 	add.w	r3, fp, r1
    9aac:	eba8 0101 	sub.w	r1, r8, r1
    9ab0:	9200      	str	r2, [sp, #0]
    9ab2:	a81a      	add	r0, sp, #104	; 0x68
    9ab4:	b21b      	sxth	r3, r3
    9ab6:	b209      	sxth	r1, r1
    9ab8:	f000 fbef 	bl	a29a <lv_area_set>
        lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
    9abc:	9b08      	ldr	r3, [sp, #32]
    9abe:	f8bd 204e 	ldrh.w	r2, [sp, #78]	; 0x4e
    9ac2:	f9bd 104c 	ldrsh.w	r1, [sp, #76]	; 0x4c
    9ac6:	1a9a      	subs	r2, r3, r2
    9ac8:	b212      	sxth	r2, r2
    9aca:	eb0b 0301 	add.w	r3, fp, r1
    9ace:	eba8 0101 	sub.w	r1, r8, r1
    9ad2:	9200      	str	r2, [sp, #0]
    9ad4:	a816      	add	r0, sp, #88	; 0x58
    9ad6:	b21b      	sxth	r3, r3
    9ad8:	b209      	sxth	r1, r1
    9ada:	f000 fbde 	bl	a29a <lv_area_set>
        lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
    9ade:	9b08      	ldr	r3, [sp, #32]
    9ae0:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
    9ae4:	f9bd 104e 	ldrsh.w	r1, [sp, #78]	; 0x4e
    9ae8:	980c      	ldr	r0, [sp, #48]	; 0x30
    9aea:	1a9a      	subs	r2, r3, r2
    9aec:	b212      	sxth	r2, r2
    9aee:	eb0b 0301 	add.w	r3, fp, r1
    9af2:	eba8 0101 	sub.w	r1, r8, r1
    9af6:	9200      	str	r2, [sp, #0]
    9af8:	b21b      	sxth	r3, r3
    9afa:	b209      	sxth	r1, r1
    9afc:	f000 fbcd 	bl	a29a <lv_area_set>
        lv_circ_next(&cir, &cir_tmp);
    9b00:	f10d 014a 	add.w	r1, sp, #74	; 0x4a
    9b04:	980b      	ldr	r0, [sp, #44]	; 0x2c
    9b06:	f000 fbb3 	bl	a270 <lv_circ_next>
    9b0a:	e5a3      	b.n	9654 <lv_draw_rect+0x1d0>
                mix       = (uint32_t)((uint32_t)(coords->y2 - edge_top_area.y1) * 255) / height;
    9b0c:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    9b10:	1a5b      	subs	r3, r3, r1
    9b12:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    9b16:	fbb3 f3fa 	udiv	r3, r3, sl
                act_color = lv_color_mix(mcolor, gcolor, mix);
    9b1a:	b2db      	uxtb	r3, r3
    9b1c:	9302      	str	r3, [sp, #8]
    9b1e:	f3c5 4307 	ubfx	r3, r5, #16, #8
    9b22:	9301      	str	r3, [sp, #4]
    9b24:	f3c5 2307 	ubfx	r3, r5, #8, #8
    9b28:	9300      	str	r3, [sp, #0]
    9b2a:	f3c4 4207 	ubfx	r2, r4, #16, #8
    9b2e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9b30:	f3c4 2107 	ubfx	r1, r4, #8, #8
    9b34:	b2e0      	uxtb	r0, r4
    9b36:	f7ff fc80 	bl	943a <lv_color_mix.isra.0>
    9b3a:	4602      	mov	r2, r0
    9b3c:	e771      	b.n	9a22 <lv_draw_rect+0x59e>
                mix       = (uint32_t)((uint32_t)(coords->y2 - mid_top_area.y1) * 255) / height;
    9b3e:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    9b42:	f9bd 205a 	ldrsh.w	r2, [sp, #90]	; 0x5a
    9b46:	1a9b      	subs	r3, r3, r2
    9b48:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    9b4c:	fbb3 f3fa 	udiv	r3, r3, sl
                act_color = lv_color_mix(mcolor, gcolor, mix);
    9b50:	b2db      	uxtb	r3, r3
    9b52:	9302      	str	r3, [sp, #8]
    9b54:	f3c5 4307 	ubfx	r3, r5, #16, #8
    9b58:	9301      	str	r3, [sp, #4]
    9b5a:	f3c5 2307 	ubfx	r3, r5, #8, #8
    9b5e:	9300      	str	r3, [sp, #0]
    9b60:	f3c4 4207 	ubfx	r2, r4, #16, #8
    9b64:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9b66:	f3c4 2107 	ubfx	r1, r4, #8, #8
    9b6a:	b2e0      	uxtb	r0, r4
    9b6c:	f7ff fc65 	bl	943a <lv_color_mix.isra.0>
    9b70:	4602      	mov	r2, r0
    9b72:	e762      	b.n	9a3a <lv_draw_rect+0x5b6>
                mix       = (uint32_t)((uint32_t)(coords->y2 - mid_bot_area.y1) * 255) / height;
    9b74:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    9b78:	f9bd 2062 	ldrsh.w	r2, [sp, #98]	; 0x62
    9b7c:	1a9b      	subs	r3, r3, r2
    9b7e:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    9b82:	fbb3 f3fa 	udiv	r3, r3, sl
                act_color = lv_color_mix(mcolor, gcolor, mix);
    9b86:	b2db      	uxtb	r3, r3
    9b88:	9302      	str	r3, [sp, #8]
    9b8a:	f3c5 4307 	ubfx	r3, r5, #16, #8
    9b8e:	9301      	str	r3, [sp, #4]
    9b90:	f3c5 2307 	ubfx	r3, r5, #8, #8
    9b94:	9300      	str	r3, [sp, #0]
    9b96:	f3c4 4207 	ubfx	r2, r4, #16, #8
    9b9a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9b9c:	f3c4 2107 	ubfx	r1, r4, #8, #8
    9ba0:	b2e0      	uxtb	r0, r4
    9ba2:	f7ff fc4a 	bl	943a <lv_color_mix.isra.0>
    9ba6:	4602      	mov	r2, r0
    9ba8:	e754      	b.n	9a54 <lv_draw_rect+0x5d0>
                mix       = (uint32_t)((uint32_t)(coords->y2 - edge_bot_area.y1) * 255) / height;
    9baa:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    9bae:	f9bd 206a 	ldrsh.w	r2, [sp, #106]	; 0x6a
    9bb2:	1a9b      	subs	r3, r3, r2
    9bb4:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    9bb8:	fbb3 f3fa 	udiv	r3, r3, sl
                act_color = lv_color_mix(mcolor, gcolor, mix);
    9bbc:	b2db      	uxtb	r3, r3
    9bbe:	9302      	str	r3, [sp, #8]
    9bc0:	f3c5 4307 	ubfx	r3, r5, #16, #8
    9bc4:	9301      	str	r3, [sp, #4]
    9bc6:	f3c5 2307 	ubfx	r3, r5, #8, #8
    9bca:	9300      	str	r3, [sp, #0]
    9bcc:	f3c4 4207 	ubfx	r2, r4, #16, #8
    9bd0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9bd2:	f3c4 2107 	ubfx	r1, r4, #8, #8
    9bd6:	b2e0      	uxtb	r0, r4
    9bd8:	f7ff fc2f 	bl	943a <lv_color_mix.isra.0>
    9bdc:	4602      	mov	r2, r0
    9bde:	e746      	b.n	9a6e <lv_draw_rect+0x5ea>
        mix       = (uint32_t)((uint32_t)(coords->y2 - edge_top_area.y1) * 255) / height;
    9be0:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    9be4:	f9bd 2052 	ldrsh.w	r2, [sp, #82]	; 0x52
    9be8:	1a9b      	subs	r3, r3, r2
    9bea:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    9bee:	fbb3 f3fa 	udiv	r3, r3, sl
        act_color = lv_color_mix(mcolor, gcolor, mix);
    9bf2:	b2db      	uxtb	r3, r3
    9bf4:	9302      	str	r3, [sp, #8]
    9bf6:	f3c5 4307 	ubfx	r3, r5, #16, #8
    9bfa:	9301      	str	r3, [sp, #4]
    9bfc:	f3c5 2307 	ubfx	r3, r5, #8, #8
    9c00:	9300      	str	r3, [sp, #0]
    9c02:	f3c4 4207 	ubfx	r2, r4, #16, #8
    9c06:	b2eb      	uxtb	r3, r5
    9c08:	f3c4 2107 	ubfx	r1, r4, #8, #8
    9c0c:	b2e0      	uxtb	r0, r4
    9c0e:	f7ff fc14 	bl	943a <lv_color_mix.isra.0>
    9c12:	4602      	mov	r2, r0
    9c14:	e528      	b.n	9668 <lv_draw_rect+0x1e4>
            mix       = (uint32_t)((uint32_t)(coords->y2 - mid_top_area.y1) * 255) / height;
    9c16:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    9c1a:	1a9b      	subs	r3, r3, r2
    9c1c:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    9c20:	fbb3 f3fa 	udiv	r3, r3, sl
            act_color = lv_color_mix(mcolor, gcolor, mix);
    9c24:	b2db      	uxtb	r3, r3
    9c26:	9302      	str	r3, [sp, #8]
    9c28:	f3c5 4307 	ubfx	r3, r5, #16, #8
    9c2c:	9301      	str	r3, [sp, #4]
    9c2e:	f3c5 2307 	ubfx	r3, r5, #8, #8
    9c32:	9300      	str	r3, [sp, #0]
    9c34:	f3c4 4207 	ubfx	r2, r4, #16, #8
    9c38:	b2eb      	uxtb	r3, r5
    9c3a:	f3c4 2107 	ubfx	r1, r4, #8, #8
    9c3e:	b2e0      	uxtb	r0, r4
    9c40:	f7ff fbfb 	bl	943a <lv_color_mix.isra.0>
    9c44:	4602      	mov	r2, r0
    9c46:	e51e      	b.n	9686 <lv_draw_rect+0x202>
        mix       = (uint32_t)((uint32_t)(coords->y2 - mid_bot_area.y1) * 255) / height;
    9c48:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    9c4c:	f9bd 2062 	ldrsh.w	r2, [sp, #98]	; 0x62
    9c50:	1a9b      	subs	r3, r3, r2
    9c52:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    9c56:	fbb3 f3fa 	udiv	r3, r3, sl
        act_color = lv_color_mix(mcolor, gcolor, mix);
    9c5a:	b2db      	uxtb	r3, r3
    9c5c:	9302      	str	r3, [sp, #8]
    9c5e:	f3c5 4307 	ubfx	r3, r5, #16, #8
    9c62:	9301      	str	r3, [sp, #4]
    9c64:	f3c5 2307 	ubfx	r3, r5, #8, #8
    9c68:	9300      	str	r3, [sp, #0]
    9c6a:	f3c4 4207 	ubfx	r2, r4, #16, #8
    9c6e:	b2eb      	uxtb	r3, r5
    9c70:	f3c4 2107 	ubfx	r1, r4, #8, #8
    9c74:	b2e0      	uxtb	r0, r4
    9c76:	f7ff fbe0 	bl	943a <lv_color_mix.isra.0>
    9c7a:	4602      	mov	r2, r0
    9c7c:	e50c      	b.n	9698 <lv_draw_rect+0x214>
            mix       = (uint32_t)((uint32_t)(coords->y2 - edge_bot_area.y1) * 255) / height;
    9c7e:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    9c82:	1a9b      	subs	r3, r3, r2
    9c84:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    9c88:	fbb3 f3fa 	udiv	r3, r3, sl
            act_color = lv_color_mix(mcolor, gcolor, mix);
    9c8c:	b2db      	uxtb	r3, r3
    9c8e:	9302      	str	r3, [sp, #8]
    9c90:	f3c5 4307 	ubfx	r3, r5, #16, #8
    9c94:	9301      	str	r3, [sp, #4]
    9c96:	f3c5 2307 	ubfx	r3, r5, #8, #8
    9c9a:	9300      	str	r3, [sp, #0]
    9c9c:	f3c4 4207 	ubfx	r2, r4, #16, #8
    9ca0:	b2eb      	uxtb	r3, r5
    9ca2:	f3c4 2107 	ubfx	r1, r4, #8, #8
    9ca6:	b2e0      	uxtb	r0, r4
    9ca8:	f7ff fbc7 	bl	943a <lv_color_mix.isra.0>
    9cac:	4602      	mov	r2, r0
    9cae:	e502      	b.n	96b6 <lv_draw_rect+0x232>
        corner_size = radius + aa;
    9cb0:	eb00 0308 	add.w	r3, r0, r8
    lv_coord_t length_corr = 0;
    9cb4:	2200      	movs	r2, #0
        corner_size = radius + aa;
    9cb6:	b21b      	sxth	r3, r3
    lv_coord_t length_corr = 0;
    9cb8:	9209      	str	r2, [sp, #36]	; 0x24
    9cba:	e546      	b.n	974a <lv_draw_rect+0x2c6>
    if(part & LV_BORDER_TOP)
    9cbc:	9a08      	ldr	r2, [sp, #32]
    corner_size++;
    9cbe:	f103 0b01 	add.w	fp, r3, #1
    9cc2:	fa0f fb8b 	sxth.w	fp, fp
    if(part & LV_BORDER_TOP)
    9cc6:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
    9cca:	2a00      	cmp	r2, #0
    9ccc:	f000 814d 	beq.w	9f6a <lv_draw_rect+0xae6>
        work_area.y1 = coords->y1 + corner_size;
    9cd0:	445b      	add	r3, fp
        work_area.y1 = coords->y1 + radius;
    9cd2:	b21b      	sxth	r3, r3
    9cd4:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
    if(part & LV_BORDER_BOTTOM)
    9cd8:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    9cdc:	f016 0201 	ands.w	r2, r6, #1
        work_area.y2 = coords->y2 - corner_size;
    9ce0:	bf14      	ite	ne
    9ce2:	eba3 030b 	subne.w	r3, r3, fp
        work_area.y2 = coords->y2 - radius;
    9ce6:	eba3 030a 	subeq.w	r3, r3, sl
    if(part & LV_BORDER_BOTTOM)
    9cea:	920a      	str	r2, [sp, #40]	; 0x28
        work_area.y2 = coords->y2 - radius;
    9cec:	b21b      	sxth	r3, r3
    if(part & LV_BORDER_LEFT) {
    9cee:	0772      	lsls	r2, r6, #29
    9cf0:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
    9cf4:	d50c      	bpl.n	9d10 <lv_draw_rect+0x88c>
        work_area.x1 = coords->x1;
    9cf6:	f9b9 3000 	ldrsh.w	r3, [r9]
    9cfa:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
        work_area.x2 = work_area.x1 + bwidth;
    9cfe:	442b      	add	r3, r5
    9d00:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
        lv_draw_fill(&work_area, mask, color, opa);
    9d04:	463a      	mov	r2, r7
    9d06:	4623      	mov	r3, r4
    9d08:	9905      	ldr	r1, [sp, #20]
    9d0a:	a81a      	add	r0, sp, #104	; 0x68
    9d0c:	f7ff faae 	bl	926c <lv_draw_fill>
    if(part & LV_BORDER_RIGHT) {
    9d10:	0733      	lsls	r3, r6, #28
    9d12:	d50c      	bpl.n	9d2e <lv_draw_rect+0x8aa>
    9d14:	f9b9 3004 	ldrsh.w	r3, [r9, #4]
        work_area.x2 = coords->x2;
    9d18:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
        work_area.x1 = work_area.x2 - bwidth;
    9d1c:	1b5b      	subs	r3, r3, r5
    9d1e:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
        lv_draw_fill(&work_area, mask, color, opa);
    9d22:	463a      	mov	r2, r7
    9d24:	4623      	mov	r3, r4
    9d26:	9905      	ldr	r1, [sp, #20]
    9d28:	a81a      	add	r0, sp, #104	; 0x68
    9d2a:	f7ff fa9f 	bl	926c <lv_draw_fill>
    work_area.x1 = coords->x1 + corner_size - length_corr;
    9d2e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    9d30:	f8b9 2000 	ldrh.w	r2, [r9]
    9d34:	ebab 0303 	sub.w	r3, fp, r3
    9d38:	4413      	add	r3, r2
    9d3a:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    work_area.x2 = coords->x2 - corner_size + length_corr;
    9d3e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9d40:	f8b9 3004 	ldrh.w	r3, [r9, #4]
    9d44:	4413      	add	r3, r2
    9d46:	eba3 0b0b 	sub.w	fp, r3, fp
    if(part & LV_BORDER_TOP) {
    9d4a:	9b08      	ldr	r3, [sp, #32]
    work_area.x2 = coords->x2 - corner_size + length_corr;
    9d4c:	f8ad b06c 	strh.w	fp, [sp, #108]	; 0x6c
    if(part & LV_BORDER_TOP) {
    9d50:	b163      	cbz	r3, 9d6c <lv_draw_rect+0x8e8>
        work_area.y1 = coords->y1;
    9d52:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
    9d56:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
        work_area.y2 = coords->y1 + bwidth;
    9d5a:	442b      	add	r3, r5
    9d5c:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
        lv_draw_fill(&work_area, mask, color, opa);
    9d60:	463a      	mov	r2, r7
    9d62:	4623      	mov	r3, r4
    9d64:	9905      	ldr	r1, [sp, #20]
    9d66:	a81a      	add	r0, sp, #104	; 0x68
    9d68:	f7ff fa80 	bl	926c <lv_draw_fill>
    if(part & LV_BORDER_BOTTOM) {
    9d6c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9d6e:	b163      	cbz	r3, 9d8a <lv_draw_rect+0x906>
        work_area.y2 = coords->y2;
    9d70:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
    9d74:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
        work_area.y1 = work_area.y2 - bwidth;
    9d78:	1b5b      	subs	r3, r3, r5
    9d7a:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
        lv_draw_fill(&work_area, mask, color, opa);
    9d7e:	463a      	mov	r2, r7
    9d80:	4623      	mov	r3, r4
    9d82:	9905      	ldr	r1, [sp, #20]
    9d84:	a81a      	add	r0, sp, #104	; 0x68
    9d86:	f7ff fa71 	bl	926c <lv_draw_fill>
    if(length_corr != 0) {
    9d8a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    9d8c:	2b00      	cmp	r3, #0
    9d8e:	f000 8086 	beq.w	9e9e <lv_draw_rect+0xa1a>
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
    9d92:	f006 0306 	and.w	r3, r6, #6
    9d96:	2b06      	cmp	r3, #6
    9d98:	d11c      	bne.n	9dd4 <lv_draw_rect+0x950>
            work_area.x1 = coords->x1;
    9d9a:	f9b9 3000 	ldrsh.w	r3, [r9]
    9d9e:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            work_area.x2 = coords->x1 + radius + aa;
    9da2:	fa0f f188 	sxth.w	r1, r8
    9da6:	fa0f f28a 	sxth.w	r2, sl
    9daa:	440b      	add	r3, r1
    9dac:	4413      	add	r3, r2
    9dae:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.y1 = coords->y1 + radius + 1 + aa;
    9db2:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
            work_area.x2 = coords->x1 + radius + aa;
    9db6:	4610      	mov	r0, r2
            work_area.y1 = coords->y1 + radius + 1 + aa;
    9db8:	1c5a      	adds	r2, r3, #1
    9dba:	4411      	add	r1, r2
    9dbc:	1842      	adds	r2, r0, r1
            work_area.y2 = coords->y1 + bwidth;
    9dbe:	442b      	add	r3, r5
            work_area.y1 = coords->y1 + radius + 1 + aa;
    9dc0:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            work_area.y2 = coords->y1 + bwidth;
    9dc4:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    9dc8:	463a      	mov	r2, r7
    9dca:	4623      	mov	r3, r4
    9dcc:	9905      	ldr	r1, [sp, #20]
    9dce:	a81a      	add	r0, sp, #104	; 0x68
    9dd0:	f7ff fa4c 	bl	926c <lv_draw_fill>
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
    9dd4:	f006 030a 	and.w	r3, r6, #10
    9dd8:	2b0a      	cmp	r3, #10
    9dda:	d11d      	bne.n	9e18 <lv_draw_rect+0x994>
            work_area.x1 = coords->x2 - radius - aa;
    9ddc:	f9b9 c004 	ldrsh.w	ip, [r9, #4]
            work_area.x2 = coords->x2;
    9de0:	f8ad c06c 	strh.w	ip, [sp, #108]	; 0x6c
            work_area.x1 = coords->x2 - radius - aa;
    9de4:	fa0f f188 	sxth.w	r1, r8
    9de8:	fa0f f28a 	sxth.w	r2, sl
    9dec:	ebac 0301 	sub.w	r3, ip, r1
    9df0:	1a9b      	subs	r3, r3, r2
    9df2:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            work_area.y1 = coords->y1 + radius + 1 + aa;
    9df6:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
            work_area.x1 = coords->x2 - radius - aa;
    9dfa:	4610      	mov	r0, r2
            work_area.y1 = coords->y1 + radius + 1 + aa;
    9dfc:	1c5a      	adds	r2, r3, #1
    9dfe:	4411      	add	r1, r2
    9e00:	1842      	adds	r2, r0, r1
            work_area.y2 = coords->y1 + bwidth;
    9e02:	442b      	add	r3, r5
            work_area.y1 = coords->y1 + radius + 1 + aa;
    9e04:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            work_area.y2 = coords->y1 + bwidth;
    9e08:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    9e0c:	463a      	mov	r2, r7
    9e0e:	4623      	mov	r3, r4
    9e10:	9905      	ldr	r1, [sp, #20]
    9e12:	a81a      	add	r0, sp, #104	; 0x68
    9e14:	f7ff fa2a 	bl	926c <lv_draw_fill>
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
    9e18:	f006 0305 	and.w	r3, r6, #5
    9e1c:	2b05      	cmp	r3, #5
    9e1e:	d11c      	bne.n	9e5a <lv_draw_rect+0x9d6>
            work_area.x1 = coords->x1;
    9e20:	f9b9 2000 	ldrsh.w	r2, [r9]
    9e24:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            work_area.x2 = coords->x1 + radius + aa;
    9e28:	fa0f f088 	sxth.w	r0, r8
    9e2c:	fa0f f38a 	sxth.w	r3, sl
    9e30:	4402      	add	r2, r0
    9e32:	4619      	mov	r1, r3
    9e34:	441a      	add	r2, r3
            work_area.y1 = coords->y2 - bwidth;
    9e36:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
            work_area.x2 = coords->x1 + radius + aa;
    9e3a:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
            work_area.y1 = coords->y2 - bwidth;
    9e3e:	1b5a      	subs	r2, r3, r5
            work_area.y2 = coords->y2 - radius - 1 - aa;
    9e40:	3b01      	subs	r3, #1
    9e42:	1a1b      	subs	r3, r3, r0
    9e44:	1a5b      	subs	r3, r3, r1
            work_area.y1 = coords->y2 - bwidth;
    9e46:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            work_area.y2 = coords->y2 - radius - 1 - aa;
    9e4a:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    9e4e:	463a      	mov	r2, r7
    9e50:	4623      	mov	r3, r4
    9e52:	9905      	ldr	r1, [sp, #20]
    9e54:	a81a      	add	r0, sp, #104	; 0x68
    9e56:	f7ff fa09 	bl	926c <lv_draw_fill>
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
    9e5a:	f006 0309 	and.w	r3, r6, #9
    9e5e:	2b09      	cmp	r3, #9
    9e60:	d11d      	bne.n	9e9e <lv_draw_rect+0xa1a>
            work_area.x1 = coords->x2 - radius - aa;
    9e62:	f9b9 3004 	ldrsh.w	r3, [r9, #4]
            work_area.x2 = coords->x2;
    9e66:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.x1 = coords->x2 - radius - aa;
    9e6a:	fa0f f188 	sxth.w	r1, r8
    9e6e:	1a5a      	subs	r2, r3, r1
            work_area.y1 = coords->y2 - bwidth;
    9e70:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
            work_area.x1 = coords->x2 - radius - aa;
    9e74:	fa0f fa8a 	sxth.w	sl, sl
            work_area.y1 = coords->y2 - bwidth;
    9e78:	1b5d      	subs	r5, r3, r5
            work_area.y2 = coords->y2 - radius - 1 - aa;
    9e7a:	3b01      	subs	r3, #1
            work_area.x1 = coords->x2 - radius - aa;
    9e7c:	eba2 020a 	sub.w	r2, r2, sl
            work_area.y2 = coords->y2 - radius - 1 - aa;
    9e80:	1a5b      	subs	r3, r3, r1
    9e82:	eba3 0a0a 	sub.w	sl, r3, sl
            work_area.x1 = coords->x2 - radius - aa;
    9e86:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            lv_draw_fill(&work_area, mask, color, opa);
    9e8a:	4623      	mov	r3, r4
    9e8c:	463a      	mov	r2, r7
    9e8e:	9905      	ldr	r1, [sp, #20]
            work_area.y1 = coords->y2 - bwidth;
    9e90:	f8ad 506a 	strh.w	r5, [sp, #106]	; 0x6a
            lv_draw_fill(&work_area, mask, color, opa);
    9e94:	a81a      	add	r0, sp, #104	; 0x68
            work_area.y2 = coords->y2 - radius - 1 - aa;
    9e96:	f8ad a06e 	strh.w	sl, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    9e9a:	f7ff f9e7 	bl	926c <lv_draw_fill>
    if(style->body.radius == 0) {
    9e9e:	9b06      	ldr	r3, [sp, #24]
    9ea0:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
    9ea4:	2b00      	cmp	r3, #0
    9ea6:	f47f acce 	bne.w	9846 <lv_draw_rect+0x3c2>
        if(part & (LV_BORDER_TOP | LV_BORDER_LEFT)) {
    9eaa:	f016 0f06 	tst.w	r6, #6
    9eae:	d015      	beq.n	9edc <lv_draw_rect+0xa58>
            work_area.x1 = coords->x1;
    9eb0:	f9b9 2000 	ldrsh.w	r2, [r9]
    9eb4:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            work_area.x2 = coords->x1 + aa;
    9eb8:	fa0f f388 	sxth.w	r3, r8
    9ebc:	441a      	add	r2, r3
    9ebe:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
            work_area.y1 = coords->y1;
    9ec2:	f9b9 2002 	ldrsh.w	r2, [r9, #2]
    9ec6:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            work_area.y2 = coords->y1 + aa;
    9eca:	4413      	add	r3, r2
    9ecc:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    9ed0:	463a      	mov	r2, r7
    9ed2:	4623      	mov	r3, r4
    9ed4:	9905      	ldr	r1, [sp, #20]
    9ed6:	a81a      	add	r0, sp, #104	; 0x68
    9ed8:	f7ff f9c8 	bl	926c <lv_draw_fill>
        if(part & (LV_BORDER_TOP | LV_BORDER_RIGHT)) {
    9edc:	f016 0f0a 	tst.w	r6, #10
    9ee0:	d015      	beq.n	9f0e <lv_draw_rect+0xa8a>
            work_area.x1 = coords->x2 - aa;
    9ee2:	f9b9 2004 	ldrsh.w	r2, [r9, #4]
            work_area.x2 = coords->x2;
    9ee6:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
            work_area.x1 = coords->x2 - aa;
    9eea:	fa0f f388 	sxth.w	r3, r8
    9eee:	1ad1      	subs	r1, r2, r3
            work_area.y1 = coords->y1;
    9ef0:	f9b9 2002 	ldrsh.w	r2, [r9, #2]
            work_area.x1 = coords->x2 - aa;
    9ef4:	f8ad 1068 	strh.w	r1, [sp, #104]	; 0x68
            work_area.y2 = coords->y1 + aa;
    9ef8:	4413      	add	r3, r2
            work_area.y1 = coords->y1;
    9efa:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            work_area.y2 = coords->y1 + aa;
    9efe:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
    9f02:	463a      	mov	r2, r7
    9f04:	4623      	mov	r3, r4
    9f06:	9905      	ldr	r1, [sp, #20]
    9f08:	a81a      	add	r0, sp, #104	; 0x68
    9f0a:	f7ff f9af 	bl	926c <lv_draw_fill>
        if(part & (LV_BORDER_BOTTOM | LV_BORDER_LEFT)) {
    9f0e:	f016 0f05 	tst.w	r6, #5
    9f12:	d015      	beq.n	9f40 <lv_draw_rect+0xabc>
            work_area.x1 = coords->x1;
    9f14:	f9b9 2000 	ldrsh.w	r2, [r9]
    9f18:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            work_area.x2 = coords->x1 + aa;
    9f1c:	fa0f f388 	sxth.w	r3, r8
    9f20:	441a      	add	r2, r3
    9f22:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
            work_area.y1 = coords->y2 - aa;
    9f26:	f9b9 2006 	ldrsh.w	r2, [r9, #6]
            work_area.y2 = coords->y2;
    9f2a:	f8ad 206e 	strh.w	r2, [sp, #110]	; 0x6e
            work_area.y1 = coords->y2 - aa;
    9f2e:	1ad3      	subs	r3, r2, r3
    9f30:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            lv_draw_fill(&work_area, mask, color, opa);
    9f34:	463a      	mov	r2, r7
    9f36:	4623      	mov	r3, r4
    9f38:	9905      	ldr	r1, [sp, #20]
    9f3a:	a81a      	add	r0, sp, #104	; 0x68
    9f3c:	f7ff f996 	bl	926c <lv_draw_fill>
        if(part & (LV_BORDER_BOTTOM | LV_BORDER_RIGHT)) {
    9f40:	f016 0f09 	tst.w	r6, #9
    9f44:	f43f ac7f 	beq.w	9846 <lv_draw_rect+0x3c2>
            work_area.x1 = coords->x2 - aa;
    9f48:	f9b9 3004 	ldrsh.w	r3, [r9, #4]
            work_area.x2 = coords->x2;
    9f4c:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.x1 = coords->x2 - aa;
    9f50:	fa0f f888 	sxth.w	r8, r8
    9f54:	eba3 0208 	sub.w	r2, r3, r8
            work_area.y1 = coords->y2 - aa;
    9f58:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
            work_area.x1 = coords->x2 - aa;
    9f5c:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            work_area.y1 = coords->y2 - aa;
    9f60:	eba3 0808 	sub.w	r8, r3, r8
    9f64:	f8ad 806a 	strh.w	r8, [sp, #106]	; 0x6a
            work_area.y2 = coords->y2;
    9f68:	e465      	b.n	9836 <lv_draw_rect+0x3b2>
        work_area.y1 = coords->y1 + radius;
    9f6a:	4453      	add	r3, sl
    9f6c:	e6b1      	b.n	9cd2 <lv_draw_rect+0x84e>
        if(cir_in.y < cir_in.x) {
    9f6e:	f9bd 4060 	ldrsh.w	r4, [sp, #96]	; 0x60
    9f72:	f9bd 1062 	ldrsh.w	r1, [sp, #98]	; 0x62
    9f76:	42a1      	cmp	r1, r4
            act_w1 = cir_out.x - cir_out.y;
    9f78:	bfaa      	itet	ge
    9f7a:	1ad4      	subge	r4, r2, r3
            act_w1 = cir_out.x - cir_in.x;
    9f7c:	1b14      	sublt	r4, r2, r4
            act_w1 = cir_out.x - cir_out.y;
    9f7e:	b224      	sxthge	r4, r4
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
    9f80:	9906      	ldr	r1, [sp, #24]
            act_w1 = cir_out.x - cir_in.x;
    9f82:	bfb5      	itete	lt
    9f84:	b224      	sxthlt	r4, r4
            act_w2 = act_w1 - 1;
    9f86:	f104 3aff 	addge.w	sl, r4, #4294967295	; 0xffffffff
            act_w2 = act_w1;
    9f8a:	46a2      	movlt	sl, r4
            act_w2 = act_w1 - 1;
    9f8c:	fa0f fa8a 	sxthge.w	sl, sl
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
    9f90:	2909      	cmp	r1, #9
    9f92:	d12a      	bne.n	9fea <lv_draw_rect+0xb66>
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT1_X(cir_out) - act_w2;
    9f94:	444a      	add	r2, r9
    9f96:	b212      	sxth	r2, r2
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
    9f98:	4433      	add	r3, r6
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT1_X(cir_out) - act_w2;
    9f9a:	eba2 010a 	sub.w	r1, r2, sl
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
    9f9e:	b21b      	sxth	r3, r3
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT1_X(cir_out) - act_w2;
    9fa0:	f8ad 1068 	strh.w	r1, [sp, #104]	; 0x68
            circ_area.x2 = rb_origo.x + LV_CIRC_OCT1_X(cir_out);
    9fa4:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
    9fa8:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            circ_area.y2 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
    9fac:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
    9fb0:	465a      	mov	r2, fp
    9fb2:	462b      	mov	r3, r5
    9fb4:	9905      	ldr	r1, [sp, #20]
    9fb6:	a81a      	add	r0, sp, #104	; 0x68
    9fb8:	f7ff f958 	bl	926c <lv_draw_fill>
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
    9fbc:	f8bd 305a 	ldrh.w	r3, [sp, #90]	; 0x5a
            lv_draw_fill(&circ_area, mask, color, opa);
    9fc0:	9905      	ldr	r1, [sp, #20]
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
    9fc2:	444b      	add	r3, r9
    9fc4:	b21b      	sxth	r3, r3
    9fc6:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            circ_area.x2 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
    9fca:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT2_Y(cir_out) - act_w1;
    9fce:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
    9fd2:	4433      	add	r3, r6
    9fd4:	b21b      	sxth	r3, r3
    9fd6:	1b1a      	subs	r2, r3, r4
    9fd8:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            circ_area.y2 = rb_origo.y + LV_CIRC_OCT2_Y(cir_out);
    9fdc:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
    9fe0:	465a      	mov	r2, fp
    9fe2:	462b      	mov	r3, r5
    9fe4:	a81a      	add	r0, sp, #104	; 0x68
    9fe6:	f7ff f941 	bl	926c <lv_draw_fill>
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
    9fea:	9b08      	ldr	r3, [sp, #32]
    9fec:	f003 0305 	and.w	r3, r3, #5
    9ff0:	2b05      	cmp	r3, #5
    9ff2:	d12e      	bne.n	a052 <lv_draw_rect+0xbce>
            circ_area.x1 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
    9ff4:	f8bd 305a 	ldrh.w	r3, [sp, #90]	; 0x5a
            lv_draw_fill(&circ_area, mask, color, opa);
    9ff8:	9905      	ldr	r1, [sp, #20]
            circ_area.x1 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
    9ffa:	1afb      	subs	r3, r7, r3
    9ffc:	b21b      	sxth	r3, r3
    9ffe:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            circ_area.x2 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
    a002:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            circ_area.y1 = lb_origo.y + LV_CIRC_OCT3_Y(cir_out) - act_w2;
    a006:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
    a00a:	4433      	add	r3, r6
    a00c:	b21b      	sxth	r3, r3
    a00e:	eba3 020a 	sub.w	r2, r3, sl
    a012:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            circ_area.y2 = lb_origo.y + LV_CIRC_OCT3_Y(cir_out);
    a016:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
    a01a:	465a      	mov	r2, fp
    a01c:	462b      	mov	r3, r5
    a01e:	a81a      	add	r0, sp, #104	; 0x68
    a020:	f7ff f924 	bl	926c <lv_draw_fill>
            circ_area.x1 = lb_origo.x + LV_CIRC_OCT4_X(cir_out);
    a024:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
            lv_draw_fill(&circ_area, mask, color, opa);
    a028:	9905      	ldr	r1, [sp, #20]
            circ_area.x1 = lb_origo.x + LV_CIRC_OCT4_X(cir_out);
    a02a:	1afb      	subs	r3, r7, r3
    a02c:	b21b      	sxth	r3, r3
    a02e:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            circ_area.x2 = lb_origo.x + LV_CIRC_OCT4_X(cir_out) + act_w1;
    a032:	4423      	add	r3, r4
    a034:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            circ_area.y1 = lb_origo.y + LV_CIRC_OCT4_Y(cir_out);
    a038:	f8bd 305a 	ldrh.w	r3, [sp, #90]	; 0x5a
    a03c:	4433      	add	r3, r6
    a03e:	b21b      	sxth	r3, r3
    a040:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            circ_area.y2 = lb_origo.y + LV_CIRC_OCT4_Y(cir_out);
    a044:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
    a048:	465a      	mov	r2, fp
    a04a:	462b      	mov	r3, r5
    a04c:	a81a      	add	r0, sp, #104	; 0x68
    a04e:	f7ff f90d 	bl	926c <lv_draw_fill>
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
    a052:	9b08      	ldr	r3, [sp, #32]
    a054:	f003 0306 	and.w	r3, r3, #6
    a058:	2b06      	cmp	r3, #6
    a05a:	d132      	bne.n	a0c2 <lv_draw_rect+0xc3e>
            if(lb_origo.y + LV_CIRC_OCT4_Y(cir_out) > lt_origo.y + LV_CIRC_OCT5_Y(cir_out)) {
    a05c:	f9bd 305a 	ldrsh.w	r3, [sp, #90]	; 0x5a
    a060:	18f2      	adds	r2, r6, r3
    a062:	eba8 0303 	sub.w	r3, r8, r3
    a066:	429a      	cmp	r2, r3
    a068:	dd13      	ble.n	a092 <lv_draw_rect+0xc0e>
                circ_area.x1 = lt_origo.x + LV_CIRC_OCT5_X(cir_out);
    a06a:	f8bd 2058 	ldrh.w	r2, [sp, #88]	; 0x58
                lv_draw_fill(&circ_area, mask, color, opa);
    a06e:	9905      	ldr	r1, [sp, #20]
                circ_area.x1 = lt_origo.x + LV_CIRC_OCT5_X(cir_out);
    a070:	1aba      	subs	r2, r7, r2
    a072:	b212      	sxth	r2, r2
                circ_area.y1 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
    a074:	b21b      	sxth	r3, r3
                circ_area.x1 = lt_origo.x + LV_CIRC_OCT5_X(cir_out);
    a076:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
                circ_area.x2 = lt_origo.x + LV_CIRC_OCT5_X(cir_out) + act_w2;
    a07a:	4452      	add	r2, sl
    a07c:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
                circ_area.y1 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
    a080:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
                circ_area.y2 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
    a084:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
                lv_draw_fill(&circ_area, mask, color, opa);
    a088:	465a      	mov	r2, fp
    a08a:	462b      	mov	r3, r5
    a08c:	a81a      	add	r0, sp, #104	; 0x68
    a08e:	f7ff f8ed 	bl	926c <lv_draw_fill>
            circ_area.x1 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
    a092:	f8bd 305a 	ldrh.w	r3, [sp, #90]	; 0x5a
            lv_draw_fill(&circ_area, mask, color, opa);
    a096:	9905      	ldr	r1, [sp, #20]
            circ_area.x1 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
    a098:	1afb      	subs	r3, r7, r3
    a09a:	b21b      	sxth	r3, r3
    a09c:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            circ_area.x2 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
    a0a0:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            circ_area.y1 = lt_origo.y + LV_CIRC_OCT6_Y(cir_out);
    a0a4:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
    a0a8:	eba8 0303 	sub.w	r3, r8, r3
    a0ac:	b21b      	sxth	r3, r3
    a0ae:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            circ_area.y2 = lt_origo.y + LV_CIRC_OCT6_Y(cir_out) + act_w1;
    a0b2:	4423      	add	r3, r4
    a0b4:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
    a0b8:	465a      	mov	r2, fp
    a0ba:	462b      	mov	r3, r5
    a0bc:	a81a      	add	r0, sp, #104	; 0x68
    a0be:	f7ff f8d5 	bl	926c <lv_draw_fill>
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
    a0c2:	9b08      	ldr	r3, [sp, #32]
    a0c4:	f003 030a 	and.w	r3, r3, #10
    a0c8:	2b0a      	cmp	r3, #10
    a0ca:	d132      	bne.n	a132 <lv_draw_rect+0xcae>
            circ_area.x1 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
    a0cc:	f8bd 305a 	ldrh.w	r3, [sp, #90]	; 0x5a
            lv_draw_fill(&circ_area, mask, color, opa);
    a0d0:	9905      	ldr	r1, [sp, #20]
            circ_area.x1 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
    a0d2:	444b      	add	r3, r9
    a0d4:	b21b      	sxth	r3, r3
    a0d6:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            circ_area.x2 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
    a0da:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            circ_area.y1 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out);
    a0de:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
    a0e2:	eba8 0303 	sub.w	r3, r8, r3
    a0e6:	b21b      	sxth	r3, r3
    a0e8:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            circ_area.y2 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out) + act_w2;
    a0ec:	449a      	add	sl, r3
            lv_draw_fill(&circ_area, mask, color, opa);
    a0ee:	465a      	mov	r2, fp
    a0f0:	462b      	mov	r3, r5
    a0f2:	a81a      	add	r0, sp, #104	; 0x68
            circ_area.y2 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out) + act_w2;
    a0f4:	f8ad a06e 	strh.w	sl, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
    a0f8:	f7ff f8b8 	bl	926c <lv_draw_fill>
            if(rb_origo.y + LV_CIRC_OCT1_Y(cir_out) > rt_origo.y + LV_CIRC_OCT8_Y(cir_out)) {
    a0fc:	f9bd 305a 	ldrsh.w	r3, [sp, #90]	; 0x5a
    a100:	18f2      	adds	r2, r6, r3
    a102:	eba8 0303 	sub.w	r3, r8, r3
    a106:	429a      	cmp	r2, r3
    a108:	dd13      	ble.n	a132 <lv_draw_rect+0xcae>
                circ_area.x1 = rt_origo.x + LV_CIRC_OCT8_X(cir_out) - act_w1;
    a10a:	f8bd 2058 	ldrh.w	r2, [sp, #88]	; 0x58
                lv_draw_fill(&circ_area, mask, color, opa);
    a10e:	9905      	ldr	r1, [sp, #20]
                circ_area.x1 = rt_origo.x + LV_CIRC_OCT8_X(cir_out) - act_w1;
    a110:	444a      	add	r2, r9
    a112:	b212      	sxth	r2, r2
                circ_area.y1 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
    a114:	b21b      	sxth	r3, r3
                circ_area.x1 = rt_origo.x + LV_CIRC_OCT8_X(cir_out) - act_w1;
    a116:	1b14      	subs	r4, r2, r4
                circ_area.x2 = rt_origo.x + LV_CIRC_OCT8_X(cir_out);
    a118:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
                circ_area.y1 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
    a11c:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
                circ_area.y2 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
    a120:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
                lv_draw_fill(&circ_area, mask, color, opa);
    a124:	465a      	mov	r2, fp
    a126:	462b      	mov	r3, r5
    a128:	a81a      	add	r0, sp, #104	; 0x68
                circ_area.x1 = rt_origo.x + LV_CIRC_OCT8_X(cir_out) - act_w1;
    a12a:	f8ad 4068 	strh.w	r4, [sp, #104]	; 0x68
                lv_draw_fill(&circ_area, mask, color, opa);
    a12e:	f7ff f89d 	bl	926c <lv_draw_fill>
        lv_circ_next(&cir_out, &tmp_out);
    a132:	a913      	add	r1, sp, #76	; 0x4c
    a134:	a816      	add	r0, sp, #88	; 0x58
    a136:	f000 f89b 	bl	a270 <lv_circ_next>
        if(cir_in.y < cir_in.x) {
    a13a:	f9bd 2062 	ldrsh.w	r2, [sp, #98]	; 0x62
    a13e:	f9bd 3060 	ldrsh.w	r3, [sp, #96]	; 0x60
    a142:	429a      	cmp	r2, r3
    a144:	f6bf abdc 	bge.w	9900 <lv_draw_rect+0x47c>
            lv_circ_next(&cir_in, &tmp_in);
    a148:	a914      	add	r1, sp, #80	; 0x50
    a14a:	a818      	add	r0, sp, #96	; 0x60
    a14c:	f000 f890 	bl	a270 <lv_circ_next>
    a150:	f7ff bbd6 	b.w	9900 <lv_draw_rect+0x47c>

0000a154 <lv_img_src_get_type>:
 */
lv_img_src_t lv_img_src_get_type(const void * src)
{
    lv_img_src_t img_src_type = LV_IMG_SRC_UNKNOWN;

    if(src == NULL) return img_src_type;
    a154:	b150      	cbz	r0, a16c <lv_img_src_get_type+0x18>
    const uint8_t * u8_p = src;

    /*The first byte shows the type of the image source*/
    if(u8_p[0] >= 0x20 && u8_p[0] <= 0x7F) {
    a156:	7803      	ldrb	r3, [r0, #0]
    a158:	f1a3 0220 	sub.w	r2, r3, #32
    a15c:	2a5f      	cmp	r2, #95	; 0x5f
    a15e:	d907      	bls.n	a170 <lv_img_src_get_type+0x1c>
        img_src_type = LV_IMG_SRC_FILE; /*If it's an ASCII character then it's file name*/
    } else if(u8_p[0] >= 0x80) {
    a160:	f013 0f80 	tst.w	r3, #128	; 0x80
        img_src_type = LV_IMG_SRC_SYMBOL; /*Symbols begins after 0x7F*/
    a164:	bf0c      	ite	eq
    a166:	2000      	moveq	r0, #0
    a168:	2002      	movne	r0, #2
    a16a:	4770      	bx	lr
    if(src == NULL) return img_src_type;
    a16c:	2003      	movs	r0, #3
    a16e:	4770      	bx	lr
        img_src_type = LV_IMG_SRC_FILE; /*If it's an ASCII character then it's file name*/
    a170:	2001      	movs	r0, #1
    if(LV_IMG_SRC_UNKNOWN == img_src_type) {
        LV_LOG_WARN("lv_img_src_get_type: unknown image type");
    }

    return img_src_type;
}
    a172:	4770      	bx	lr

0000a174 <lv_img_decoder_built_in_close>:
{
    a174:	b538      	push	{r3, r4, r5, lr}
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
    a176:	6a0c      	ldr	r4, [r1, #32]
{
    a178:	460d      	mov	r5, r1
    if(user_data) {
    a17a:	b144      	cbz	r4, a18e <lv_img_decoder_built_in_close+0x1a>
        if(user_data->palette) lv_mem_free(user_data->palette);
    a17c:	6820      	ldr	r0, [r4, #0]
    a17e:	b108      	cbz	r0, a184 <lv_img_decoder_built_in_close+0x10>
    a180:	f7fb fb4a 	bl	5818 <lv_mem_free>
        lv_mem_free(user_data);
    a184:	4620      	mov	r0, r4
    a186:	f7fb fb47 	bl	5818 <lv_mem_free>
        dsc->user_data = NULL;
    a18a:	2300      	movs	r3, #0
    a18c:	622b      	str	r3, [r5, #32]
}
    a18e:	bd38      	pop	{r3, r4, r5, pc}

0000a190 <lv_img_decoder_close>:
{
    a190:	b510      	push	{r4, lr}
    a192:	4604      	mov	r4, r0
    if(dsc->decoder) {
    a194:	6800      	ldr	r0, [r0, #0]
    a196:	b158      	cbz	r0, a1b0 <lv_img_decoder_close+0x20>
        if(dsc->decoder->close_cb) dsc->decoder->close_cb(dsc->decoder, dsc);
    a198:	68c3      	ldr	r3, [r0, #12]
    a19a:	b10b      	cbz	r3, a1a0 <lv_img_decoder_close+0x10>
    a19c:	4621      	mov	r1, r4
    a19e:	4798      	blx	r3
        if(dsc->src_type == LV_IMG_SRC_FILE) {
    a1a0:	7b23      	ldrb	r3, [r4, #12]
    a1a2:	2b01      	cmp	r3, #1
    a1a4:	d104      	bne.n	a1b0 <lv_img_decoder_close+0x20>
            lv_mem_free(dsc->src);
    a1a6:	6860      	ldr	r0, [r4, #4]
    a1a8:	f7fb fb36 	bl	5818 <lv_mem_free>
            dsc->src = NULL;
    a1ac:	2300      	movs	r3, #0
    a1ae:	6063      	str	r3, [r4, #4]
}
    a1b0:	bd10      	pop	{r4, pc}

0000a1b2 <lv_disp_drv_init>:
{
    a1b2:	b510      	push	{r4, lr}
    memset(driver, 0, sizeof(lv_disp_drv_t));
    a1b4:	2224      	movs	r2, #36	; 0x24
{
    a1b6:	4604      	mov	r4, r0
    memset(driver, 0, sizeof(lv_disp_drv_t));
    a1b8:	2100      	movs	r1, #0
    a1ba:	f7fd ffa1 	bl	8100 <memset>
    driver->flush_cb         = NULL;
    a1be:	2300      	movs	r3, #0
    driver->hor_res          = LV_HOR_RES_MAX;
    a1c0:	f04f 12f0 	mov.w	r2, #15728880	; 0xf000f0
    driver->buffer           = NULL;
    a1c4:	e9c4 2300 	strd	r2, r3, [r4]
    driver->rotated          = 0;
    a1c8:	7a22      	ldrb	r2, [r4, #8]
    driver->flush_cb         = NULL;
    a1ca:	60e3      	str	r3, [r4, #12]
    driver->rotated          = 0;
    a1cc:	f363 0200 	bfi	r2, r3, #0, #1
    a1d0:	7222      	strb	r2, [r4, #8]
    driver->color_chroma_key = LV_COLOR_TRANSP;
    a1d2:	f04f 22ff 	mov.w	r2, #4278255360	; 0xff00ff00
    driver->user_data = NULL;
    a1d6:	e9c4 2307 	strd	r2, r3, [r4, #28]
    driver->set_px_cb = NULL;
    a1da:	6163      	str	r3, [r4, #20]
}
    a1dc:	bd10      	pop	{r4, pc}

0000a1de <lv_disp_buf_init>:
{
    a1de:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a1e0:	4604      	mov	r4, r0
    a1e2:	460d      	mov	r5, r1
    a1e4:	4617      	mov	r7, r2
    a1e6:	461e      	mov	r6, r3
    memset(disp_buf, 0, sizeof(lv_disp_buf_t));
    a1e8:	221c      	movs	r2, #28
    a1ea:	2100      	movs	r1, #0
    a1ec:	f7fd ff88 	bl	8100 <memset>
    disp_buf->buf2    = buf2;
    a1f0:	e9c4 5700 	strd	r5, r7, [r4]
    disp_buf->size    = size_in_px_cnt;
    a1f4:	e9c4 5602 	strd	r5, r6, [r4, #8]
}
    a1f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000a1fa <lv_disp_get_antialiasing>:
    if(disp == NULL) disp = lv_disp_get_default();
    if(disp == NULL) return false;

    return disp->driver.antialiasing ? true : false;
#endif
}
    a1fa:	2000      	movs	r0, #0
    a1fc:	4770      	bx	lr

0000a1fe <lv_disp_flush_ready>:
    if(disp_drv->screen_transp) {
        memset(disp_drv->buffer->buf_act, 0x00, disp_drv->buffer->size * sizeof(lv_color32_t));
    }
#endif

    disp_drv->buffer->flushing = 0;
    a1fe:	6842      	ldr	r2, [r0, #4]
    a200:	7e13      	ldrb	r3, [r2, #24]
    a202:	f36f 0300 	bfc	r3, #0, #1
    a206:	7613      	strb	r3, [r2, #24]
}
    a208:	4770      	bx	lr

0000a20a <lv_disp_get_buf>:
 * @return pointer to the internal buffers
 */
lv_disp_buf_t * lv_disp_get_buf(lv_disp_t * disp)
{
    return disp->driver.buffer;
}
    a20a:	6840      	ldr	r0, [r0, #4]
    a20c:	4770      	bx	lr

0000a20e <lv_disp_is_double_buf>:
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_double_buf(lv_disp_t * disp)
{
    if(disp->driver.buffer->buf1 && disp->driver.buffer->buf2)
    a20e:	6843      	ldr	r3, [r0, #4]
    a210:	6818      	ldr	r0, [r3, #0]
    a212:	b118      	cbz	r0, a21c <lv_disp_is_double_buf+0xe>
    a214:	6858      	ldr	r0, [r3, #4]
    a216:	3000      	adds	r0, #0
    a218:	bf18      	it	ne
    a21a:	2001      	movne	r0, #1
        return true;
    else
        return false;
}
    a21c:	4770      	bx	lr

0000a21e <lv_disp_is_true_double_buf>:
 * `size` is screen sized)
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_true_double_buf(lv_disp_t * disp)
{
    a21e:	b508      	push	{r3, lr}
    a220:	4602      	mov	r2, r0
    uint32_t scr_size = disp->driver.hor_res * disp->driver.ver_res;

    if(lv_disp_is_double_buf(disp) && disp->driver.buffer->size == scr_size) {
    a222:	f7ff fff4 	bl	a20e <lv_disp_is_double_buf>
    a226:	b140      	cbz	r0, a23a <lv_disp_is_true_double_buf+0x1c>
    uint32_t scr_size = disp->driver.hor_res * disp->driver.ver_res;
    a228:	8853      	ldrh	r3, [r2, #2]
    a22a:	8810      	ldrh	r0, [r2, #0]
    a22c:	fb10 f003 	smulbb	r0, r0, r3
    if(lv_disp_is_double_buf(disp) && disp->driver.buffer->size == scr_size) {
    a230:	6853      	ldr	r3, [r2, #4]
    a232:	68db      	ldr	r3, [r3, #12]
    a234:	1ac3      	subs	r3, r0, r3
    a236:	4258      	negs	r0, r3
    a238:	4158      	adcs	r0, r3
        return true;
    } else {
        return false;
    }
}
    a23a:	bd08      	pop	{r3, pc}

0000a23c <lv_tick_get>:
/**
 * Get the elapsed milliseconds since start up
 * @return the elapsed milliseconds
 */
uint32_t lv_tick_get(void)
{
    a23c:	b508      	push	{r3, lr}
	return z_impl_k_uptime_get();
    a23e:	f000 fe6c 	bl	af1a <z_impl_k_uptime_get>

    return result;
#else
    return LV_TICK_CUSTOM_SYS_TIME_EXPR;
#endif
}
    a242:	bd08      	pop	{r3, pc}

0000a244 <lv_tick_elaps>:
 * Get the elapsed milliseconds since a previous time stamp
 * @param prev_tick a previous time stamp (return value of systick_get() )
 * @return the elapsed milliseconds since 'prev_tick'
 */
uint32_t lv_tick_elaps(uint32_t prev_tick)
{
    a244:	b510      	push	{r4, lr}
    a246:	4604      	mov	r4, r0
    a248:	f000 fe67 	bl	af1a <z_impl_k_uptime_get>
        prev_tick = UINT32_MAX - prev_tick + 1;
        prev_tick += act_time;
    }

    return prev_tick;
}
    a24c:	1b00      	subs	r0, r0, r4
    a24e:	bd10      	pop	{r4, pc}

0000a250 <lv_circ_init>:
 * @param tmp point to a variable. It will store temporary data
 * @param radius radius of the circle
 */
void lv_circ_init(lv_point_t * c, lv_coord_t * tmp, lv_coord_t radius)
{
    c->x = radius;
    a250:	8002      	strh	r2, [r0, #0]
    c->y = 0;
    a252:	2300      	movs	r3, #0
    *tmp = 1 - radius;
    a254:	f1c2 0201 	rsb	r2, r2, #1
    c->y = 0;
    a258:	8043      	strh	r3, [r0, #2]
    *tmp = 1 - radius;
    a25a:	800a      	strh	r2, [r1, #0]
}
    a25c:	4770      	bx	lr

0000a25e <lv_circ_cont>:
 * @param c same as in circ_init
 * @return true if the circle is not ready yet
 */
bool lv_circ_cont(lv_point_t * c)
{
    return c->y <= c->x ? true : false;
    a25e:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
    a262:	f9b0 0000 	ldrsh.w	r0, [r0]
}
    a266:	4282      	cmp	r2, r0
    a268:	bfcc      	ite	gt
    a26a:	2000      	movgt	r0, #0
    a26c:	2001      	movle	r0, #1
    a26e:	4770      	bx	lr

0000a270 <lv_circ_next>:
 * @param c same as in circ_init. The next point stored here.
 * @param tmp same as in circ_init.
 */
void lv_circ_next(lv_point_t * c, lv_coord_t * tmp)
{
    c->y++;
    a270:	8843      	ldrh	r3, [r0, #2]
    a272:	3301      	adds	r3, #1
    a274:	b21b      	sxth	r3, r3
    a276:	8043      	strh	r3, [r0, #2]

    if(*tmp <= 0) {
    a278:	f9b1 2000 	ldrsh.w	r2, [r1]
    a27c:	2a00      	cmp	r2, #0
        (*tmp) += 2 * c->y + 1; /*Change in decision criterion for y -> y+1*/
    } else {
        c->x--;
    a27e:	bfc1      	itttt	gt
    a280:	8802      	ldrhgt	r2, [r0, #0]
    a282:	f102 32ff 	addgt.w	r2, r2, #4294967295	; 0xffffffff
    a286:	b212      	sxthgt	r2, r2
    a288:	8002      	strhgt	r2, [r0, #0]
        (*tmp) += 2 * (c->y - c->x) + 1; /*Change for y -> y+1, x -> x-1*/
    a28a:	bfc4      	itt	gt
    a28c:	1a9b      	subgt	r3, r3, r2
    a28e:	880a      	ldrhgt	r2, [r1, #0]
    a290:	3201      	adds	r2, #1
    a292:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    a296:	800b      	strh	r3, [r1, #0]
    }
}
    a298:	4770      	bx	lr

0000a29a <lv_area_set>:
 */
void lv_area_set(lv_area_t * area_p, lv_coord_t x1, lv_coord_t y1, lv_coord_t x2, lv_coord_t y2)
{
    area_p->x1 = x1;
    area_p->y1 = y1;
    area_p->x2 = x2;
    a29a:	8083      	strh	r3, [r0, #4]
    area_p->y2 = y2;
    a29c:	f9bd 3000 	ldrsh.w	r3, [sp]
    area_p->x1 = x1;
    a2a0:	8001      	strh	r1, [r0, #0]
    area_p->y1 = y1;
    a2a2:	8042      	strh	r2, [r0, #2]
    area_p->y2 = y2;
    a2a4:	80c3      	strh	r3, [r0, #6]
}
    a2a6:	4770      	bx	lr

0000a2a8 <lv_area_get_size>:
 */
uint32_t lv_area_get_size(const lv_area_t * area_p)
{
    uint32_t size;

    size = (uint32_t)(area_p->x2 - area_p->x1 + 1) * (area_p->y2 - area_p->y1 + 1);
    a2a8:	f9b0 3000 	ldrsh.w	r3, [r0]
    a2ac:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
    a2b0:	1ad2      	subs	r2, r2, r3
    a2b2:	f9b0 3006 	ldrsh.w	r3, [r0, #6]
    a2b6:	f9b0 0002 	ldrsh.w	r0, [r0, #2]
    a2ba:	3301      	adds	r3, #1
    a2bc:	1a18      	subs	r0, r3, r0

    return size;
}
    a2be:	fb02 0000 	mla	r0, r2, r0, r0
    a2c2:	4770      	bx	lr

0000a2c4 <lv_area_intersect>:
 * @return false: the two area has NO common parts, res_p is invalid
 */
bool lv_area_intersect(lv_area_t * res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
    /* Get the smaller area from 'a1_p' and 'a2_p' */
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
    a2c4:	f9b1 3000 	ldrsh.w	r3, [r1]
{
    a2c8:	b570      	push	{r4, r5, r6, lr}
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
    a2ca:	f9b2 5000 	ldrsh.w	r5, [r2]
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
    a2ce:	f9b1 4002 	ldrsh.w	r4, [r1, #2]
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
    a2d2:	f9b1 6004 	ldrsh.w	r6, [r1, #4]
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
    a2d6:	f9b1 1006 	ldrsh.w	r1, [r1, #6]
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
    a2da:	429d      	cmp	r5, r3
    a2dc:	bfb8      	it	lt
    a2de:	461d      	movlt	r5, r3
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
    a2e0:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
    a2e4:	8005      	strh	r5, [r0, #0]
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
    a2e6:	42a3      	cmp	r3, r4
    a2e8:	bfb8      	it	lt
    a2ea:	4623      	movlt	r3, r4
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
    a2ec:	f9b2 4004 	ldrsh.w	r4, [r2, #4]
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
    a2f0:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
    a2f4:	8043      	strh	r3, [r0, #2]
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
    a2f6:	42b4      	cmp	r4, r6
    a2f8:	bfa8      	it	ge
    a2fa:	4634      	movge	r4, r6
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
    a2fc:	428a      	cmp	r2, r1
    a2fe:	bfa8      	it	ge
    a300:	460a      	movge	r2, r1

    /*If x1 or y1 greater then x2 or y2 then the areas union is empty*/
    bool union_ok = true;
    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {
    a302:	42a5      	cmp	r5, r4
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
    a304:	8084      	strh	r4, [r0, #4]
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
    a306:	80c2      	strh	r2, [r0, #6]
    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {
    a308:	dc04      	bgt.n	a314 <lv_area_intersect+0x50>
    a30a:	4293      	cmp	r3, r2
    a30c:	bfcc      	ite	gt
    a30e:	2000      	movgt	r0, #0
    a310:	2001      	movle	r0, #1
        union_ok = false;
    }

    return union_ok;
}
    a312:	bd70      	pop	{r4, r5, r6, pc}
        union_ok = false;
    a314:	2000      	movs	r0, #0
    a316:	e7fc      	b.n	a312 <lv_area_intersect+0x4e>

0000a318 <lv_area_join>:
 * @param a1_p pointer to the first area
 * @param a2_p pointer to the second area
 */
void lv_area_join(lv_area_t * a_res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
    a_res_p->x1 = LV_MATH_MIN(a1_p->x1, a2_p->x1);
    a318:	f9b2 3000 	ldrsh.w	r3, [r2]
{
    a31c:	b510      	push	{r4, lr}
    a_res_p->x1 = LV_MATH_MIN(a1_p->x1, a2_p->x1);
    a31e:	f9b1 4000 	ldrsh.w	r4, [r1]
    a322:	42a3      	cmp	r3, r4
    a324:	bfa8      	it	ge
    a326:	4623      	movge	r3, r4
    a328:	8003      	strh	r3, [r0, #0]
    a_res_p->y1 = LV_MATH_MIN(a1_p->y1, a2_p->y1);
    a32a:	f9b1 4002 	ldrsh.w	r4, [r1, #2]
    a32e:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
    a332:	42a3      	cmp	r3, r4
    a334:	bfa8      	it	ge
    a336:	4623      	movge	r3, r4
    a338:	8043      	strh	r3, [r0, #2]
    a_res_p->x2 = LV_MATH_MAX(a1_p->x2, a2_p->x2);
    a33a:	f9b1 4004 	ldrsh.w	r4, [r1, #4]
    a33e:	f9b2 3004 	ldrsh.w	r3, [r2, #4]
    a342:	42a3      	cmp	r3, r4
    a344:	bfb8      	it	lt
    a346:	4623      	movlt	r3, r4
    a348:	8083      	strh	r3, [r0, #4]
    a_res_p->y2 = LV_MATH_MAX(a1_p->y2, a2_p->y2);
    a34a:	f9b2 3006 	ldrsh.w	r3, [r2, #6]
    a34e:	f9b1 2006 	ldrsh.w	r2, [r1, #6]
    a352:	4293      	cmp	r3, r2
    a354:	bfb8      	it	lt
    a356:	4613      	movlt	r3, r2
    a358:	80c3      	strh	r3, [r0, #6]
}
    a35a:	bd10      	pop	{r4, pc}

0000a35c <lv_area_is_on>:
 * @param a2_p pointer to an other area
 * @return false: a1_p and a2_p has no common parts
 */
bool lv_area_is_on(const lv_area_t * a1_p, const lv_area_t * a2_p)
{
    if((a1_p->x1 <= a2_p->x2) && (a1_p->x2 >= a2_p->x1) && (a1_p->y1 <= a2_p->y2) && (a1_p->y2 >= a2_p->y1)) {
    a35c:	f9b0 2000 	ldrsh.w	r2, [r0]
    a360:	f9b1 3004 	ldrsh.w	r3, [r1, #4]
    a364:	429a      	cmp	r2, r3
    a366:	dc14      	bgt.n	a392 <lv_area_is_on+0x36>
    a368:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
    a36c:	f9b1 3000 	ldrsh.w	r3, [r1]
    a370:	429a      	cmp	r2, r3
    a372:	db0e      	blt.n	a392 <lv_area_is_on+0x36>
    a374:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
    a378:	f9b1 3006 	ldrsh.w	r3, [r1, #6]
    a37c:	429a      	cmp	r2, r3
    a37e:	dc08      	bgt.n	a392 <lv_area_is_on+0x36>
    a380:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
    a384:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
    a388:	4298      	cmp	r0, r3
    a38a:	bfb4      	ite	lt
    a38c:	2000      	movlt	r0, #0
    a38e:	2001      	movge	r0, #1
    a390:	4770      	bx	lr
        return true;
    } else {
        return false;
    a392:	2000      	movs	r0, #0
    }
}
    a394:	4770      	bx	lr

0000a396 <lv_area_is_in>:
 */
bool lv_area_is_in(const lv_area_t * ain_p, const lv_area_t * aholder_p)
{
    bool is_in = false;

    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
    a396:	f9b0 2000 	ldrsh.w	r2, [r0]
    a39a:	f9b1 3000 	ldrsh.w	r3, [r1]
    a39e:	429a      	cmp	r2, r3
    a3a0:	db14      	blt.n	a3cc <lv_area_is_in+0x36>
    a3a2:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
    a3a6:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
    a3aa:	429a      	cmp	r2, r3
    a3ac:	db0e      	blt.n	a3cc <lv_area_is_in+0x36>
    a3ae:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
    a3b2:	f9b1 3004 	ldrsh.w	r3, [r1, #4]
    a3b6:	429a      	cmp	r2, r3
    a3b8:	dc08      	bgt.n	a3cc <lv_area_is_in+0x36>
    a3ba:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
    a3be:	f9b1 3006 	ldrsh.w	r3, [r1, #6]
    a3c2:	4298      	cmp	r0, r3
    a3c4:	bfcc      	ite	gt
    a3c6:	2000      	movgt	r0, #0
    a3c8:	2001      	movle	r0, #1
    a3ca:	4770      	bx	lr
    bool is_in = false;
    a3cc:	2000      	movs	r0, #0
       ain_p->y2 <= aholder_p->y2) {
        is_in = true;
    }

    return is_in;
}
    a3ce:	4770      	bx	lr

0000a3d0 <lv_task_create>:
{
    a3d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a3d4:	4680      	mov	r8, r0
    a3d6:	460f      	mov	r7, r1
    a3d8:	4616      	mov	r6, r2
    a3da:	461d      	mov	r5, r3
    lv_task_t * new_task = lv_task_create_basic();
    a3dc:	f7fb f8c4 	bl	5568 <lv_task_create_basic>
    if(new_task == NULL) return NULL;
    a3e0:	4604      	mov	r4, r0
    a3e2:	b130      	cbz	r0, a3f2 <lv_task_create+0x22>
    task->task_cb = task_cb;
    a3e4:	f8c0 8008 	str.w	r8, [r0, #8]
    task->period = period;
    a3e8:	6007      	str	r7, [r0, #0]
    lv_task_set_prio(new_task, prio);
    a3ea:	4631      	mov	r1, r6
    a3ec:	f7fb f9c8 	bl	5780 <lv_task_set_prio>
    new_task->user_data = user_data;
    a3f0:	60e5      	str	r5, [r4, #12]
}
    a3f2:	4620      	mov	r0, r4
    a3f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000a3f8 <lv_task_ready>:
{
    a3f8:	b510      	push	{r4, lr}
    a3fa:	4604      	mov	r4, r0
    task->last_run = lv_tick_get() - task->period - 1;
    a3fc:	f7ff ff1e 	bl	a23c <lv_tick_get>
    a400:	6823      	ldr	r3, [r4, #0]
    a402:	43db      	mvns	r3, r3
    a404:	4403      	add	r3, r0
    a406:	6063      	str	r3, [r4, #4]
}
    a408:	bd10      	pop	{r4, pc}

0000a40a <lv_mem_init>:
}
    a40a:	4770      	bx	lr

0000a40c <node_set_next.isra.0>:
 * Set the 'next node pointer' of a node
 * @param ll_p pointer to linked list
 * @param act pointer to a node which next node pointer should be set
 * @param next pointer to a node which should be the next node before 'act'
 */
static void node_set_next(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * next)
    a40c:	b507      	push	{r0, r1, r2, lr}
    a40e:	9201      	str	r2, [sp, #4]
{
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
    a410:	b149      	cbz	r1, a426 <node_set_next.isra.0+0x1a>

    uint32_t node_p_size = sizeof(lv_ll_node_t *);
    if(next)
    a412:	6800      	ldr	r0, [r0, #0]
    a414:	3004      	adds	r0, #4
    a416:	4408      	add	r0, r1
    a418:	4611      	mov	r1, r2
        memcpy(act + LL_NEXT_P_OFFSET(ll_p), &next, node_p_size);
    a41a:	2204      	movs	r2, #4
    if(next)
    a41c:	b131      	cbz	r1, a42c <node_set_next.isra.0+0x20>
        memcpy(act + LL_NEXT_P_OFFSET(ll_p), &next, node_p_size);
    a41e:	eb0d 0102 	add.w	r1, sp, r2
    a422:	f7fd fe43 	bl	80ac <memcpy>
    else
        memset(act + LL_NEXT_P_OFFSET(ll_p), 0, node_p_size);
}
    a426:	b003      	add	sp, #12
    a428:	f85d fb04 	ldr.w	pc, [sp], #4
        memset(act + LL_NEXT_P_OFFSET(ll_p), 0, node_p_size);
    a42c:	f7fd fe68 	bl	8100 <memset>
    a430:	e7f9      	b.n	a426 <node_set_next.isra.0+0x1a>

0000a432 <node_set_prev.isra.2>:
static void node_set_prev(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * prev)
    a432:	b507      	push	{r0, r1, r2, lr}
    a434:	9201      	str	r2, [sp, #4]
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
    a436:	b141      	cbz	r1, a44a <node_set_prev.isra.2+0x18>
    if(prev)
    a438:	6800      	ldr	r0, [r0, #0]
    a43a:	4408      	add	r0, r1
    a43c:	4611      	mov	r1, r2
        memcpy(act + LL_PREV_P_OFFSET(ll_p), &prev, node_p_size);
    a43e:	2204      	movs	r2, #4
    if(prev)
    a440:	b131      	cbz	r1, a450 <node_set_prev.isra.2+0x1e>
        memcpy(act + LL_PREV_P_OFFSET(ll_p), &prev, node_p_size);
    a442:	eb0d 0102 	add.w	r1, sp, r2
    a446:	f7fd fe31 	bl	80ac <memcpy>
}
    a44a:	b003      	add	sp, #12
    a44c:	f85d fb04 	ldr.w	pc, [sp], #4
        memset(act + LL_PREV_P_OFFSET(ll_p), 0, node_p_size);
    a450:	f7fd fe56 	bl	8100 <memset>
    a454:	e7f9      	b.n	a44a <node_set_prev.isra.2+0x18>

0000a456 <lv_ll_init>:
    ll_p->head = NULL;
    a456:	2300      	movs	r3, #0
    ll_p->tail = NULL;
    a458:	e9c0 3301 	strd	r3, r3, [r0, #4]
    if(node_size & 0x3) {
    a45c:	078b      	lsls	r3, r1, #30
        node_size = node_size & (~0x3);
    a45e:	bf1c      	itt	ne
    a460:	f021 0103 	bicne.w	r1, r1, #3
        node_size += 4;
    a464:	3104      	addne	r1, #4
    ll_p->n_size = node_size;
    a466:	6001      	str	r1, [r0, #0]
}
    a468:	4770      	bx	lr

0000a46a <lv_ll_ins_head>:
{
    a46a:	b538      	push	{r3, r4, r5, lr}
    a46c:	4604      	mov	r4, r0
    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
    a46e:	6800      	ldr	r0, [r0, #0]
    a470:	3008      	adds	r0, #8
    a472:	f7fb f9ab 	bl	57cc <lv_mem_alloc>
    if(n_new != NULL) {
    a476:	4605      	mov	r5, r0
    a478:	b198      	cbz	r0, a4a2 <lv_ll_ins_head+0x38>
        node_set_prev(ll_p, n_new, NULL);       /*No prev. before the new head*/
    a47a:	4601      	mov	r1, r0
    a47c:	2200      	movs	r2, #0
    a47e:	4620      	mov	r0, r4
    a480:	f7ff ffd7 	bl	a432 <node_set_prev.isra.2>
        node_set_next(ll_p, n_new, ll_p->head); /*After new comes the old head*/
    a484:	4629      	mov	r1, r5
    a486:	6862      	ldr	r2, [r4, #4]
    a488:	4620      	mov	r0, r4
    a48a:	f7ff ffbf 	bl	a40c <node_set_next.isra.0>
        if(ll_p->head != NULL) { /*If there is old head then before it goes the new*/
    a48e:	6861      	ldr	r1, [r4, #4]
    a490:	b119      	cbz	r1, a49a <lv_ll_ins_head+0x30>
            node_set_prev(ll_p, ll_p->head, n_new);
    a492:	462a      	mov	r2, r5
    a494:	4620      	mov	r0, r4
    a496:	f7ff ffcc 	bl	a432 <node_set_prev.isra.2>
        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/
    a49a:	68a3      	ldr	r3, [r4, #8]
        ll_p->head = n_new;      /*Set the new head in the dsc.*/
    a49c:	6065      	str	r5, [r4, #4]
        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/
    a49e:	b903      	cbnz	r3, a4a2 <lv_ll_ins_head+0x38>
            ll_p->tail = n_new;
    a4a0:	60a5      	str	r5, [r4, #8]
}
    a4a2:	4628      	mov	r0, r5
    a4a4:	bd38      	pop	{r3, r4, r5, pc}

0000a4a6 <lv_ll_ins_tail>:
{
    a4a6:	b538      	push	{r3, r4, r5, lr}
    a4a8:	4604      	mov	r4, r0
    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
    a4aa:	6800      	ldr	r0, [r0, #0]
    a4ac:	3008      	adds	r0, #8
    a4ae:	f7fb f98d 	bl	57cc <lv_mem_alloc>
    if(n_new == NULL) return NULL;
    a4b2:	4605      	mov	r5, r0
    a4b4:	b198      	cbz	r0, a4de <lv_ll_ins_tail+0x38>
        node_set_next(ll_p, n_new, NULL);       /*No next after the new tail*/
    a4b6:	4601      	mov	r1, r0
    a4b8:	2200      	movs	r2, #0
    a4ba:	4620      	mov	r0, r4
    a4bc:	f7ff ffa6 	bl	a40c <node_set_next.isra.0>
        node_set_prev(ll_p, n_new, ll_p->tail); /*The prev. before new is tho old tail*/
    a4c0:	4629      	mov	r1, r5
    a4c2:	68a2      	ldr	r2, [r4, #8]
    a4c4:	4620      	mov	r0, r4
    a4c6:	f7ff ffb4 	bl	a432 <node_set_prev.isra.2>
        if(ll_p->tail != NULL) {                /*If there is old tail then the new comes after it*/
    a4ca:	68a1      	ldr	r1, [r4, #8]
    a4cc:	b119      	cbz	r1, a4d6 <lv_ll_ins_tail+0x30>
            node_set_next(ll_p, ll_p->tail, n_new);
    a4ce:	462a      	mov	r2, r5
    a4d0:	4620      	mov	r0, r4
    a4d2:	f7ff ff9b 	bl	a40c <node_set_next.isra.0>
        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/
    a4d6:	6863      	ldr	r3, [r4, #4]
        ll_p->tail = n_new;      /*Set the new tail in the dsc.*/
    a4d8:	60a5      	str	r5, [r4, #8]
        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/
    a4da:	b903      	cbnz	r3, a4de <lv_ll_ins_tail+0x38>
            ll_p->head = n_new;
    a4dc:	6065      	str	r5, [r4, #4]
}
    a4de:	4628      	mov	r0, r5
    a4e0:	bd38      	pop	{r3, r4, r5, pc}

0000a4e2 <lv_ll_get_head>:
    if(ll_p != NULL) {
    a4e2:	b100      	cbz	r0, a4e6 <lv_ll_get_head+0x4>
        head = ll_p->head;
    a4e4:	6840      	ldr	r0, [r0, #4]
}
    a4e6:	4770      	bx	lr

0000a4e8 <lv_ll_get_tail>:
    if(ll_p != NULL) {
    a4e8:	b100      	cbz	r0, a4ec <lv_ll_get_tail+0x4>
        tail = ll_p->tail;
    a4ea:	6880      	ldr	r0, [r0, #8]
}
    a4ec:	4770      	bx	lr

0000a4ee <lv_ll_get_next>:
{
    a4ee:	b507      	push	{r0, r1, r2, lr}
    void * next = NULL;
    a4f0:	2300      	movs	r3, #0
    a4f2:	9301      	str	r3, [sp, #4]
    if(ll_p != NULL) {
    a4f4:	b138      	cbz	r0, a506 <lv_ll_get_next+0x18>
        memcpy(&next, n_act_d + LL_NEXT_P_OFFSET(ll_p), sizeof(void *));
    a4f6:	6803      	ldr	r3, [r0, #0]
    a4f8:	2204      	movs	r2, #4
    a4fa:	3304      	adds	r3, #4
    a4fc:	4419      	add	r1, r3
    a4fe:	eb0d 0002 	add.w	r0, sp, r2
    a502:	f7fd fdd3 	bl	80ac <memcpy>
}
    a506:	9801      	ldr	r0, [sp, #4]
    a508:	b003      	add	sp, #12
    a50a:	f85d fb04 	ldr.w	pc, [sp], #4

0000a50e <lv_ll_get_prev>:
{
    a50e:	b507      	push	{r0, r1, r2, lr}
    void * prev = NULL;
    a510:	2300      	movs	r3, #0
    a512:	9301      	str	r3, [sp, #4]
    if(ll_p != NULL) {
    a514:	b130      	cbz	r0, a524 <lv_ll_get_prev+0x16>
        memcpy(&prev, n_act_d + LL_PREV_P_OFFSET(ll_p), sizeof(void *));
    a516:	6803      	ldr	r3, [r0, #0]
    a518:	2204      	movs	r2, #4
    a51a:	4419      	add	r1, r3
    a51c:	eb0d 0002 	add.w	r0, sp, r2
    a520:	f7fd fdc4 	bl	80ac <memcpy>
}
    a524:	9801      	ldr	r0, [sp, #4]
    a526:	b003      	add	sp, #12
    a528:	f85d fb04 	ldr.w	pc, [sp], #4

0000a52c <lv_ll_ins_prev>:
{
    a52c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a52e:	460e      	mov	r6, r1
    if(NULL == ll_p || NULL == n_act) return NULL;
    a530:	4605      	mov	r5, r0
    a532:	b340      	cbz	r0, a586 <lv_ll_ins_prev+0x5a>
    a534:	b349      	cbz	r1, a58a <lv_ll_ins_prev+0x5e>
    if(lv_ll_get_head(ll_p) == n_act) {
    a536:	6843      	ldr	r3, [r0, #4]
    a538:	4299      	cmp	r1, r3
    a53a:	d103      	bne.n	a544 <lv_ll_ins_prev+0x18>
}
    a53c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        n_new = lv_ll_ins_head(ll_p);
    a540:	f7ff bf93 	b.w	a46a <lv_ll_ins_head>
        n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
    a544:	6800      	ldr	r0, [r0, #0]
    a546:	3008      	adds	r0, #8
    a548:	f7fb f940 	bl	57cc <lv_mem_alloc>
        if(n_new == NULL) return NULL;
    a54c:	4604      	mov	r4, r0
    a54e:	b1c0      	cbz	r0, a582 <lv_ll_ins_prev+0x56>
        n_prev = lv_ll_get_prev(ll_p, n_act);
    a550:	4631      	mov	r1, r6
    a552:	4628      	mov	r0, r5
    a554:	f7ff ffdb 	bl	a50e <lv_ll_get_prev>
        node_set_next(ll_p, n_prev, n_new);
    a558:	4622      	mov	r2, r4
    a55a:	4601      	mov	r1, r0
        n_prev = lv_ll_get_prev(ll_p, n_act);
    a55c:	4607      	mov	r7, r0
        node_set_next(ll_p, n_prev, n_new);
    a55e:	4628      	mov	r0, r5
    a560:	f7ff ff54 	bl	a40c <node_set_next.isra.0>
        node_set_prev(ll_p, n_new, n_prev);
    a564:	463a      	mov	r2, r7
    a566:	4621      	mov	r1, r4
    a568:	4628      	mov	r0, r5
    a56a:	f7ff ff62 	bl	a432 <node_set_prev.isra.2>
        node_set_prev(ll_p, n_act, n_new);
    a56e:	4622      	mov	r2, r4
    a570:	4631      	mov	r1, r6
    a572:	4628      	mov	r0, r5
    a574:	f7ff ff5d 	bl	a432 <node_set_prev.isra.2>
        node_set_next(ll_p, n_new, n_act);
    a578:	4632      	mov	r2, r6
    a57a:	4621      	mov	r1, r4
    a57c:	4628      	mov	r0, r5
    a57e:	f7ff ff45 	bl	a40c <node_set_next.isra.0>
}
    a582:	4620      	mov	r0, r4
    a584:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(NULL == ll_p || NULL == n_act) return NULL;
    a586:	4604      	mov	r4, r0
    a588:	e7fb      	b.n	a582 <lv_ll_ins_prev+0x56>
    a58a:	460c      	mov	r4, r1
    a58c:	e7f9      	b.n	a582 <lv_ll_ins_prev+0x56>

0000a58e <lv_ll_rem>:
{
    a58e:	b570      	push	{r4, r5, r6, lr}
    a590:	460d      	mov	r5, r1
    if(ll_p != NULL) {
    a592:	4604      	mov	r4, r0
    a594:	b308      	cbz	r0, a5da <lv_ll_rem+0x4c>
    if(lv_ll_get_head(ll_p) == node_p) {
    a596:	6843      	ldr	r3, [r0, #4]
    a598:	4299      	cmp	r1, r3
    a59a:	d10e      	bne.n	a5ba <lv_ll_rem+0x2c>
        ll_p->head = lv_ll_get_next(ll_p, node_p);
    a59c:	4629      	mov	r1, r5
    a59e:	4620      	mov	r0, r4
    a5a0:	f7ff ffa5 	bl	a4ee <lv_ll_get_next>
    a5a4:	4601      	mov	r1, r0
    a5a6:	6060      	str	r0, [r4, #4]
        if(ll_p->head == NULL) {
    a5a8:	b908      	cbnz	r0, a5ae <lv_ll_rem+0x20>
            ll_p->tail = NULL;
    a5aa:	60a0      	str	r0, [r4, #8]
}
    a5ac:	bd70      	pop	{r4, r5, r6, pc}
            node_set_prev(ll_p, ll_p->head, NULL);
    a5ae:	2200      	movs	r2, #0
        node_set_prev(ll_p, n_next, n_prev);
    a5b0:	4620      	mov	r0, r4
}
    a5b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        node_set_prev(ll_p, n_next, n_prev);
    a5b6:	f7ff bf3c 	b.w	a432 <node_set_prev.isra.2>
    } else if(lv_ll_get_tail(ll_p) == node_p) {
    a5ba:	6883      	ldr	r3, [r0, #8]
    a5bc:	4299      	cmp	r1, r3
    a5be:	d10e      	bne.n	a5de <lv_ll_rem+0x50>
        ll_p->tail = lv_ll_get_prev(ll_p, node_p);
    a5c0:	f7ff ffa5 	bl	a50e <lv_ll_get_prev>
    a5c4:	4601      	mov	r1, r0
    a5c6:	60a0      	str	r0, [r4, #8]
        if(ll_p->tail == NULL) {
    a5c8:	b908      	cbnz	r0, a5ce <lv_ll_rem+0x40>
            ll_p->head = NULL;
    a5ca:	6060      	str	r0, [r4, #4]
    a5cc:	e7ee      	b.n	a5ac <lv_ll_rem+0x1e>
            node_set_next(ll_p, ll_p->tail, NULL);
    a5ce:	4620      	mov	r0, r4
    a5d0:	2200      	movs	r2, #0
}
    a5d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            node_set_next(ll_p, ll_p->tail, NULL);
    a5d6:	f7ff bf19 	b.w	a40c <node_set_next.isra.0>
    if(lv_ll_get_head(ll_p) == node_p) {
    a5da:	2900      	cmp	r1, #0
    a5dc:	d0de      	beq.n	a59c <lv_ll_rem+0xe>
        lv_ll_node_t * n_prev = lv_ll_get_prev(ll_p, node_p);
    a5de:	4629      	mov	r1, r5
    a5e0:	4620      	mov	r0, r4
    a5e2:	f7ff ff94 	bl	a50e <lv_ll_get_prev>
        lv_ll_node_t * n_next = lv_ll_get_next(ll_p, node_p);
    a5e6:	4629      	mov	r1, r5
        lv_ll_node_t * n_prev = lv_ll_get_prev(ll_p, node_p);
    a5e8:	4606      	mov	r6, r0
        lv_ll_node_t * n_next = lv_ll_get_next(ll_p, node_p);
    a5ea:	4620      	mov	r0, r4
    a5ec:	f7ff ff7f 	bl	a4ee <lv_ll_get_next>
        node_set_next(ll_p, n_prev, n_next);
    a5f0:	4631      	mov	r1, r6
    a5f2:	4602      	mov	r2, r0
        lv_ll_node_t * n_next = lv_ll_get_next(ll_p, node_p);
    a5f4:	4605      	mov	r5, r0
        node_set_next(ll_p, n_prev, n_next);
    a5f6:	4620      	mov	r0, r4
    a5f8:	f7ff ff08 	bl	a40c <node_set_next.isra.0>
        node_set_prev(ll_p, n_next, n_prev);
    a5fc:	4632      	mov	r2, r6
    a5fe:	4629      	mov	r1, r5
    a600:	e7d6      	b.n	a5b0 <lv_ll_rem+0x22>

0000a602 <lv_ll_move_before>:
    if(n_act == n_after) return; /*Can't move before itself*/
    a602:	4291      	cmp	r1, r2
{
    a604:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a606:	4604      	mov	r4, r0
    a608:	460d      	mov	r5, r1
    a60a:	4617      	mov	r7, r2
    if(n_act == n_after) return; /*Can't move before itself*/
    a60c:	d022      	beq.n	a654 <lv_ll_move_before+0x52>
    if(n_after != NULL)
    a60e:	b312      	cbz	r2, a656 <lv_ll_move_before+0x54>
        n_before = lv_ll_get_prev(ll_p, n_after);
    a610:	4611      	mov	r1, r2
    a612:	f7ff ff7c 	bl	a50e <lv_ll_get_prev>
    a616:	4606      	mov	r6, r0
    if(n_act == n_before) return; /*Already before `n_after`*/
    a618:	42ae      	cmp	r6, r5
    a61a:	d01b      	beq.n	a654 <lv_ll_move_before+0x52>
    lv_ll_rem(ll_p, n_act);
    a61c:	4629      	mov	r1, r5
    a61e:	4620      	mov	r0, r4
    a620:	f7ff ffb5 	bl	a58e <lv_ll_rem>
    node_set_next(ll_p, n_before, n_act);
    a624:	462a      	mov	r2, r5
    a626:	4631      	mov	r1, r6
    a628:	4620      	mov	r0, r4
    a62a:	f7ff feef 	bl	a40c <node_set_next.isra.0>
    node_set_prev(ll_p, n_act, n_before);
    a62e:	4632      	mov	r2, r6
    a630:	4629      	mov	r1, r5
    a632:	4620      	mov	r0, r4
    a634:	f7ff fefd 	bl	a432 <node_set_prev.isra.2>
    node_set_prev(ll_p, n_after, n_act);
    a638:	462a      	mov	r2, r5
    a63a:	4639      	mov	r1, r7
    a63c:	4620      	mov	r0, r4
    a63e:	f7ff fef8 	bl	a432 <node_set_prev.isra.2>
    node_set_next(ll_p, n_act, n_after);
    a642:	463a      	mov	r2, r7
    a644:	4629      	mov	r1, r5
    a646:	4620      	mov	r0, r4
    a648:	f7ff fee0 	bl	a40c <node_set_next.isra.0>
    if(n_after == NULL) ll_p->tail = n_act;
    a64c:	b907      	cbnz	r7, a650 <lv_ll_move_before+0x4e>
    a64e:	60a5      	str	r5, [r4, #8]
    if(n_before == NULL) ll_p->head = n_act;
    a650:	b906      	cbnz	r6, a654 <lv_ll_move_before+0x52>
    a652:	6065      	str	r5, [r4, #4]
}
    a654:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(ll_p != NULL) {
    a656:	b108      	cbz	r0, a65c <lv_ll_move_before+0x5a>
        tail = ll_p->tail;
    a658:	6886      	ldr	r6, [r0, #8]
    a65a:	e7dd      	b.n	a618 <lv_ll_move_before+0x16>
    void * tail = NULL;
    a65c:	4606      	mov	r6, r0
    a65e:	e7db      	b.n	a618 <lv_ll_move_before+0x16>

0000a660 <lv_txt_iso8859_1_size>:
}
    a660:	2001      	movs	r0, #1
    a662:	4770      	bx	lr

0000a664 <lv_txt_iso8859_1_next>:
    if(i == NULL) return txt[1]; /*Get the next char */
    a664:	b909      	cbnz	r1, a66a <lv_txt_iso8859_1_next+0x6>
    a666:	7840      	ldrb	r0, [r0, #1]
    a668:	4770      	bx	lr
    uint8_t letter = txt[*i];
    a66a:	680b      	ldr	r3, [r1, #0]
    a66c:	5cc0      	ldrb	r0, [r0, r3]
    (*i)++;
    a66e:	3301      	adds	r3, #1
    a670:	600b      	str	r3, [r1, #0]
}
    a672:	4770      	bx	lr

0000a674 <lv_txt_iso8859_1_prev>:
    if(i == NULL) return *(txt - 1); /*Get the prev. char */
    a674:	b911      	cbnz	r1, a67c <lv_txt_iso8859_1_prev+0x8>
    a676:	f810 0c01 	ldrb.w	r0, [r0, #-1]
    a67a:	4770      	bx	lr
    (*i)--;
    a67c:	680b      	ldr	r3, [r1, #0]
    a67e:	3b01      	subs	r3, #1
    a680:	600b      	str	r3, [r1, #0]
    return letter;
    a682:	5cc0      	ldrb	r0, [r0, r3]
}
    a684:	4770      	bx	lr

0000a686 <lv_txt_iso8859_1_get_byte_id>:
}
    a686:	4608      	mov	r0, r1
    a688:	4770      	bx	lr

0000a68a <lv_txt_iso8859_1_get_length>:
    return strlen(txt);
    a68a:	f7fd bcfc 	b.w	8086 <strlen>

0000a68e <lv_txt_iso8859_1_get_char_id>:
    a68e:	4608      	mov	r0, r1
    a690:	4770      	bx	lr

0000a692 <lv_txt_is_cmd>:
    if(c == (uint32_t)LV_TXT_COLOR_CMD[0]) {
    a692:	2923      	cmp	r1, #35	; 0x23
{
    a694:	4602      	mov	r2, r0
    if(c == (uint32_t)LV_TXT_COLOR_CMD[0]) {
    a696:	d117      	bne.n	a6c8 <lv_txt_is_cmd+0x36>
    a698:	7803      	ldrb	r3, [r0, #0]
        if(*state == LV_TXT_CMD_STATE_WAIT) { /*Start char*/
    a69a:	b91b      	cbnz	r3, a6a4 <lv_txt_is_cmd+0x12>
            *state = LV_TXT_CMD_STATE_PAR;
    a69c:	2301      	movs	r3, #1
    a69e:	7003      	strb	r3, [r0, #0]
            ret    = true;
    a6a0:	2001      	movs	r0, #1
    a6a2:	e004      	b.n	a6ae <lv_txt_is_cmd+0x1c>
        else if(*state == LV_TXT_CMD_STATE_PAR) {
    a6a4:	2b01      	cmp	r3, #1
    a6a6:	f04f 0000 	mov.w	r0, #0
    a6aa:	d109      	bne.n	a6c0 <lv_txt_is_cmd+0x2e>
            *state = LV_TXT_CMD_STATE_WAIT;
    a6ac:	7010      	strb	r0, [r2, #0]
    if(*state == LV_TXT_CMD_STATE_PAR) {
    a6ae:	7813      	ldrb	r3, [r2, #0]
    a6b0:	2b01      	cmp	r3, #1
    a6b2:	d104      	bne.n	a6be <lv_txt_is_cmd+0x2c>
        if(c == ' ') {
    a6b4:	2920      	cmp	r1, #32
            *state = LV_TXT_CMD_STATE_IN; /*After the parameter the text is in the command*/
    a6b6:	bf04      	itt	eq
    a6b8:	2102      	moveq	r1, #2
    a6ba:	7011      	strbeq	r1, [r2, #0]
        ret = true;
    a6bc:	4618      	mov	r0, r3
}
    a6be:	4770      	bx	lr
        else if(*state == LV_TXT_CMD_STATE_IN) {
    a6c0:	2b02      	cmp	r3, #2
    a6c2:	d1f4      	bne.n	a6ae <lv_txt_is_cmd+0x1c>
            *state = LV_TXT_CMD_STATE_WAIT;
    a6c4:	7010      	strb	r0, [r2, #0]
    a6c6:	e7eb      	b.n	a6a0 <lv_txt_is_cmd+0xe>
    bool ret = false;
    a6c8:	2000      	movs	r0, #0
    a6ca:	e7f0      	b.n	a6ae <lv_txt_is_cmd+0x1c>

0000a6cc <lv_txt_get_size>:
{
    a6cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a6d0:	b087      	sub	sp, #28
    size_res->x = 0;
    a6d2:	2500      	movs	r5, #0
{
    a6d4:	9304      	str	r3, [sp, #16]
    a6d6:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
    a6da:	f9bd b040 	ldrsh.w	fp, [sp, #64]	; 0x40
    a6de:	f9bd a044 	ldrsh.w	sl, [sp, #68]	; 0x44
    a6e2:	9303      	str	r3, [sp, #12]
    a6e4:	4604      	mov	r4, r0
    a6e6:	4616      	mov	r6, r2
    size_res->x = 0;
    a6e8:	8005      	strh	r5, [r0, #0]
    size_res->y = 0;
    a6ea:	8045      	strh	r5, [r0, #2]
    if(text == NULL) return;
    a6ec:	4689      	mov	r9, r1
    a6ee:	b1f9      	cbz	r1, a730 <lv_txt_get_size+0x64>
    if(font == NULL) return;
    a6f0:	b1f2      	cbz	r2, a730 <lv_txt_get_size+0x64>
    uint8_t letter_height = lv_font_get_line_height(font);
    a6f2:	7a17      	ldrb	r7, [r2, #8]
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
    a6f4:	f013 0f02 	tst.w	r3, #2
    a6f8:	f647 4318 	movw	r3, #31768	; 0x7c18
    a6fc:	bf18      	it	ne
    a6fe:	469a      	movne	sl, r3
        size_res->y += line_space;
    a700:	eb0b 0307 	add.w	r3, fp, r7
    a704:	9305      	str	r3, [sp, #20]
    while(text[line_start] != '\0') {
    a706:	f819 3005 	ldrb.w	r3, [r9, r5]
    a70a:	eb09 0805 	add.w	r8, r9, r5
    a70e:	b993      	cbnz	r3, a736 <lv_txt_get_size+0x6a>
    if((line_start != 0) && (text[line_start - 1] == '\n' || text[line_start - 1] == '\r')) {
    a710:	b155      	cbz	r5, a728 <lv_txt_get_size+0x5c>
    a712:	f818 3c01 	ldrb.w	r3, [r8, #-1]
    a716:	2b0a      	cmp	r3, #10
    a718:	d001      	beq.n	a71e <lv_txt_get_size+0x52>
    a71a:	2b0d      	cmp	r3, #13
    a71c:	d104      	bne.n	a728 <lv_txt_get_size+0x5c>
        size_res->y += letter_height + line_space;
    a71e:	8862      	ldrh	r2, [r4, #2]
    a720:	eb0b 0307 	add.w	r3, fp, r7
    a724:	4413      	add	r3, r2
    a726:	8063      	strh	r3, [r4, #2]
    if(size_res->y == 0)
    a728:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
    a72c:	b9fb      	cbnz	r3, a76e <lv_txt_get_size+0xa2>
        size_res->y = letter_height;
    a72e:	8067      	strh	r7, [r4, #2]
}
    a730:	b007      	add	sp, #28
    a732:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        new_line_start += lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
    a736:	9b03      	ldr	r3, [sp, #12]
    a738:	9300      	str	r3, [sp, #0]
    a73a:	9a04      	ldr	r2, [sp, #16]
    a73c:	4653      	mov	r3, sl
    a73e:	4631      	mov	r1, r6
    a740:	4640      	mov	r0, r8
    a742:	f7fb f909 	bl	5958 <lv_txt_get_next_line>
        size_res->y += line_space;
    a746:	8863      	ldrh	r3, [r4, #2]
    a748:	9a05      	ldr	r2, [sp, #20]
    a74a:	4413      	add	r3, r2
    a74c:	8063      	strh	r3, [r4, #2]
        act_line_length = lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space, flag);
    a74e:	9b03      	ldr	r3, [sp, #12]
    a750:	9300      	str	r3, [sp, #0]
        new_line_start += lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
    a752:	4601      	mov	r1, r0
        act_line_length = lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space, flag);
    a754:	9b04      	ldr	r3, [sp, #16]
        new_line_start += lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
    a756:	4405      	add	r5, r0
        act_line_length = lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space, flag);
    a758:	4632      	mov	r2, r6
    a75a:	4640      	mov	r0, r8
    a75c:	f7fb f8ac 	bl	58b8 <lv_txt_get_width>
        size_res->x = LV_MATH_MAX(act_line_length, size_res->x);
    a760:	f9b4 3000 	ldrsh.w	r3, [r4]
    a764:	4298      	cmp	r0, r3
    a766:	bfb8      	it	lt
    a768:	4618      	movlt	r0, r3
    a76a:	8020      	strh	r0, [r4, #0]
        line_start  = new_line_start;
    a76c:	e7cb      	b.n	a706 <lv_txt_get_size+0x3a>
        size_res->y -= line_space;
    a76e:	eba3 030b 	sub.w	r3, r3, fp
    a772:	8063      	strh	r3, [r4, #2]
    a774:	e7dc      	b.n	a730 <lv_txt_get_size+0x64>

0000a776 <lv_utils_bsearch>:
 *
 * @return a pointer to a matching item, or NULL if none exists.
 */
void * lv_utils_bsearch(const void * key, const void * base, uint32_t n, uint32_t size,
                        int32_t (*cmp)(const void * pRef, const void * pElement))
{
    a776:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a77a:	9d08      	ldr	r5, [sp, #32]
    a77c:	4681      	mov	r9, r0
    a77e:	4688      	mov	r8, r1
    a780:	4614      	mov	r4, r2
    a782:	469a      	mov	sl, r3
    const char * middle;
    int32_t c;

    for(middle = base; n != 0;) {
    a784:	b90c      	cbnz	r4, a78a <lv_utils_bsearch+0x14>
            middle = base;
        } else {
            return (char *)middle;
        }
    }
    return NULL;
    a786:	4626      	mov	r6, r4
    a788:	e010      	b.n	a7ac <lv_utils_bsearch+0x36>
        middle += (n / 2) * size;
    a78a:	0867      	lsrs	r7, r4, #1
    a78c:	fb0a 8607 	mla	r6, sl, r7, r8
        if((c = (*cmp)(key, middle)) > 0) {
    a790:	4631      	mov	r1, r6
    a792:	4648      	mov	r0, r9
    a794:	47a8      	blx	r5
    a796:	2800      	cmp	r0, #0
    a798:	dd07      	ble.n	a7aa <lv_utils_bsearch+0x34>
            n    = (n / 2) - ((n & 1) == 0);
    a79a:	43e4      	mvns	r4, r4
    a79c:	f004 0401 	and.w	r4, r4, #1
    a7a0:	1b3f      	subs	r7, r7, r4
            base = (middle += size);
    a7a2:	eb06 080a 	add.w	r8, r6, sl
{
    a7a6:	463c      	mov	r4, r7
    a7a8:	e7ec      	b.n	a784 <lv_utils_bsearch+0xe>
        } else if(c < 0) {
    a7aa:	d1fc      	bne.n	a7a6 <lv_utils_bsearch+0x30>
}
    a7ac:	4630      	mov	r0, r6
    a7ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000a7b2 <lv_label_dot_tmp_free>:
 * Free the dot_tmp_ptr field if it was previously allocated.
 * Always clears the field
 * @param label pointer to label object.
 */
static void lv_label_dot_tmp_free(lv_obj_t * label)
{
    a7b2:	b510      	push	{r4, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    a7b4:	f7fe fc2a 	bl	900c <lv_obj_get_ext_attr>
    if(ext->dot_tmp_alloc && ext->dot.tmp_ptr) {
    a7b8:	7bc3      	ldrb	r3, [r0, #15]
    a7ba:	079b      	lsls	r3, r3, #30
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    a7bc:	4604      	mov	r4, r0
    if(ext->dot_tmp_alloc && ext->dot.tmp_ptr) {
    a7be:	d503      	bpl.n	a7c8 <lv_label_dot_tmp_free+0x16>
    a7c0:	6840      	ldr	r0, [r0, #4]
    a7c2:	b108      	cbz	r0, a7c8 <lv_label_dot_tmp_free+0x16>
        lv_mem_free(ext->dot.tmp_ptr);
    a7c4:	f7fb f828 	bl	5818 <lv_mem_free>
    }
    ext->dot_tmp_alloc = false;
    a7c8:	7be3      	ldrb	r3, [r4, #15]
    a7ca:	f36f 0341 	bfc	r3, #1, #1
    a7ce:	73e3      	strb	r3, [r4, #15]
    ext->dot.tmp_ptr   = NULL;
    a7d0:	2300      	movs	r3, #0
    a7d2:	6063      	str	r3, [r4, #4]
}
    a7d4:	bd10      	pop	{r4, pc}

0000a7d6 <lv_label_set_align>:
{
    a7d6:	b538      	push	{r3, r4, r5, lr}
    a7d8:	460c      	mov	r4, r1
    a7da:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    a7dc:	f7fe fc16 	bl	900c <lv_obj_get_ext_attr>
    if(ext->align == align) return;
    a7e0:	7b83      	ldrb	r3, [r0, #14]
    a7e2:	f3c3 1201 	ubfx	r2, r3, #4, #2
    a7e6:	42a2      	cmp	r2, r4
    a7e8:	d007      	beq.n	a7fa <lv_label_set_align+0x24>
    ext->align = align;
    a7ea:	f364 1305 	bfi	r3, r4, #4, #2
    a7ee:	7383      	strb	r3, [r0, #14]
    lv_obj_invalidate(label); /*Enough to invalidate because alignment is only drawing related
    a7f0:	4628      	mov	r0, r5
}
    a7f2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    lv_obj_invalidate(label); /*Enough to invalidate because alignment is only drawing related
    a7f6:	f7fe b949 	b.w	8a8c <lv_obj_invalidate>
}
    a7fa:	bd38      	pop	{r3, r4, r5, pc}

0000a7fc <lv_label_set_body_draw>:
{
    a7fc:	b538      	push	{r3, r4, r5, lr}
    a7fe:	460d      	mov	r5, r1
    a800:	4604      	mov	r4, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    a802:	f7fe fc03 	bl	900c <lv_obj_get_ext_attr>
    if(ext->body_draw == en) return;
    a806:	7bc3      	ldrb	r3, [r0, #15]
    a808:	f003 0201 	and.w	r2, r3, #1
    a80c:	42aa      	cmp	r2, r5
    a80e:	d00a      	beq.n	a826 <lv_label_set_body_draw+0x2a>
    ext->body_draw = en == false ? 0 : 1;
    a810:	f365 0300 	bfi	r3, r5, #0, #1
    a814:	73c3      	strb	r3, [r0, #15]
    lv_obj_refresh_ext_draw_pad(label);
    a816:	4620      	mov	r0, r4
    a818:	f7fe f9ce 	bl	8bb8 <lv_obj_refresh_ext_draw_pad>
    lv_obj_invalidate(label);
    a81c:	4620      	mov	r0, r4
}
    a81e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    lv_obj_invalidate(label);
    a822:	f7fe b933 	b.w	8a8c <lv_obj_invalidate>
}
    a826:	bd38      	pop	{r3, r4, r5, pc}

0000a828 <lv_label_get_text>:
{
    a828:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    a82a:	f7fe fbef 	bl	900c <lv_obj_get_ext_attr>
}
    a82e:	6800      	ldr	r0, [r0, #0]
    a830:	bd08      	pop	{r3, pc}

0000a832 <lv_label_get_long_mode>:
{
    a832:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    a834:	f7fe fbea 	bl	900c <lv_obj_get_ext_attr>
    return ext->long_mode;
    a838:	7b80      	ldrb	r0, [r0, #14]
}
    a83a:	f000 0007 	and.w	r0, r0, #7
    a83e:	bd08      	pop	{r3, pc}

0000a840 <lv_label_get_align>:
{
    a840:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    a842:	f7fe fbe3 	bl	900c <lv_obj_get_ext_attr>
    lv_label_align_t align = ext->align;
    a846:	7b80      	ldrb	r0, [r0, #14]
    a848:	f3c0 1001 	ubfx	r0, r0, #4, #2
    if(align == LV_LABEL_ALIGN_AUTO) {
    a84c:	2803      	cmp	r0, #3
}
    a84e:	bf08      	it	eq
    a850:	2000      	moveq	r0, #0
    a852:	bd08      	pop	{r3, pc}

0000a854 <lv_label_design>:
{
    a854:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(mode == LV_DESIGN_COVER_CHK)
    a858:	2a02      	cmp	r2, #2
{
    a85a:	b08f      	sub	sp, #60	; 0x3c
    a85c:	4606      	mov	r6, r0
    a85e:	4689      	mov	r9, r1
    if(mode == LV_DESIGN_COVER_CHK)
    a860:	f000 8102 	beq.w	aa68 <lv_label_design+0x214>
    else if(mode == LV_DESIGN_DRAW_MAIN) {
    a864:	2a00      	cmp	r2, #0
    a866:	f040 80f8 	bne.w	aa5a <lv_label_design+0x206>
        const lv_style_t * style = lv_obj_get_style(label);
    a86a:	f7f9 fac5 	bl	3df8 <lv_obj_get_style>
    a86e:	4604      	mov	r4, r0
        lv_opa_t opa_scale       = lv_obj_get_opa_scale(label);
    a870:	4630      	mov	r0, r6
    a872:	f7fe fb6b 	bl	8f4c <lv_obj_get_opa_scale>
        lv_obj_get_coords(label, &coords);
    a876:	a90a      	add	r1, sp, #40	; 0x28
        lv_opa_t opa_scale       = lv_obj_get_opa_scale(label);
    a878:	4682      	mov	sl, r0
        lv_obj_get_coords(label, &coords);
    a87a:	4630      	mov	r0, r6
    a87c:	f7fe fa21 	bl	8cc2 <lv_obj_get_coords>
        lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    a880:	4630      	mov	r0, r6
    a882:	f7fe fbc3 	bl	900c <lv_obj_get_ext_attr>
        if(ext->body_draw) {
    a886:	7bc3      	ldrb	r3, [r0, #15]
    a888:	07d9      	lsls	r1, r3, #31
        lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    a88a:	4680      	mov	r8, r0
        if(ext->body_draw) {
    a88c:	d524      	bpl.n	a8d8 <lv_label_design+0x84>
            lv_obj_get_coords(label, &bg);
    a88e:	a90c      	add	r1, sp, #48	; 0x30
    a890:	4630      	mov	r0, r6
    a892:	f7fe fa16 	bl	8cc2 <lv_obj_get_coords>
            bg.x1 -= style->body.padding.left;
    a896:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
    a898:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
    a89c:	1a9b      	subs	r3, r3, r2
    a89e:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
            bg.x2 += style->body.padding.right;
    a8a2:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
    a8a4:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
    a8a8:	4413      	add	r3, r2
    a8aa:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
            bg.y1 -= style->body.padding.top;
    a8ae:	8c22      	ldrh	r2, [r4, #32]
    a8b0:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
    a8b4:	1a9b      	subs	r3, r3, r2
    a8b6:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
            bg.y2 += style->body.padding.bottom;
    a8ba:	8c62      	ldrh	r2, [r4, #34]	; 0x22
    a8bc:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
            lv_draw_rect(&bg, mask, style, lv_obj_get_opa_scale(label));
    a8c0:	4630      	mov	r0, r6
            bg.y2 += style->body.padding.bottom;
    a8c2:	4413      	add	r3, r2
    a8c4:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
            lv_draw_rect(&bg, mask, style, lv_obj_get_opa_scale(label));
    a8c8:	f7fe fb40 	bl	8f4c <lv_obj_get_opa_scale>
    a8cc:	4622      	mov	r2, r4
    a8ce:	4603      	mov	r3, r0
    a8d0:	4649      	mov	r1, r9
    a8d2:	a80c      	add	r0, sp, #48	; 0x30
    a8d4:	f7fe fdd6 	bl	9484 <lv_draw_rect>
        lv_label_align_t align = lv_label_get_align(label);
    a8d8:	4630      	mov	r0, r6
    a8da:	f7ff ffb1 	bl	a840 <lv_label_get_align>
        if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
    a8de:	f898 300e 	ldrb.w	r3, [r8, #14]
        if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
    a8e2:	061a      	lsls	r2, r3, #24
        if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
    a8e4:	f3c3 1580 	ubfx	r5, r3, #6, #1
        if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
    a8e8:	bf48      	it	mi
    a8ea:	f045 0502 	orrmi.w	r5, r5, #2
        if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
    a8ee:	2801      	cmp	r0, #1
    a8f0:	f040 80b5 	bne.w	aa5e <lv_label_design+0x20a>
    a8f4:	f045 0504 	orr.w	r5, r5, #4
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
    a8f8:	f003 0207 	and.w	r2, r3, #7
    a8fc:	3a03      	subs	r2, #3
    a8fe:	2a01      	cmp	r2, #1
    a900:	d81d      	bhi.n	a93e <lv_label_design+0xea>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
    a902:	f003 0330 	and.w	r3, r3, #48	; 0x30
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
    a906:	2b10      	cmp	r3, #16
    a908:	d001      	beq.n	a90e <lv_label_design+0xba>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
    a90a:	2b20      	cmp	r3, #32
    a90c:	d117      	bne.n	a93e <lv_label_design+0xea>
            lv_txt_get_size(&size, ext->text, style->text.font, style->text.letter_space, style->text.line_space,
    a90e:	f647 4218 	movw	r2, #31768	; 0x7c18
    a912:	f9b4 3038 	ldrsh.w	r3, [r4, #56]	; 0x38
    a916:	9502      	str	r5, [sp, #8]
    a918:	9201      	str	r2, [sp, #4]
    a91a:	f9b4 203a 	ldrsh.w	r2, [r4, #58]	; 0x3a
    a91e:	9200      	str	r2, [sp, #0]
    a920:	6b62      	ldr	r2, [r4, #52]	; 0x34
    a922:	f8d8 1000 	ldr.w	r1, [r8]
    a926:	a80c      	add	r0, sp, #48	; 0x30
    a928:	f7ff fed0 	bl	a6cc <lv_txt_get_size>
            if(size.x > lv_obj_get_width(label)) {
    a92c:	4630      	mov	r0, r6
    a92e:	f9bd 7030 	ldrsh.w	r7, [sp, #48]	; 0x30
    a932:	f7fe fafd 	bl	8f30 <lv_obj_get_width>
    a936:	4287      	cmp	r7, r0
                flag &= ~LV_TXT_FLAG_CENTER;
    a938:	bfc8      	it	gt
    a93a:	f005 05f3 	andgt.w	r5, r5, #243	; 0xf3
        sel.start = lv_label_get_text_sel_start(label);
    a93e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    a942:	9308      	str	r3, [sp, #32]
        lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ext->offset, &sel, hint, lv_obj_get_base_dir(label));
    a944:	4643      	mov	r3, r8
    a946:	4630      	mov	r0, r6
    a948:	f853 2b0a 	ldr.w	r2, [r3], #10
    a94c:	e9cd 2306 	strd	r2, r3, [sp, #24]
    a950:	f7fe fafa 	bl	8f48 <lv_obj_get_base_dir>
    a954:	9b07      	ldr	r3, [sp, #28]
    a956:	9a06      	ldr	r2, [sp, #24]
    a958:	9005      	str	r0, [sp, #20]
    a95a:	f04f 0b00 	mov.w	fp, #0
    a95e:	af08      	add	r7, sp, #32
    a960:	e9cd 5301 	strd	r5, r3, [sp, #4]
    a964:	9200      	str	r2, [sp, #0]
    a966:	4653      	mov	r3, sl
    a968:	f8cd b010 	str.w	fp, [sp, #16]
    a96c:	9703      	str	r7, [sp, #12]
    a96e:	4622      	mov	r2, r4
    a970:	4649      	mov	r1, r9
    a972:	a80a      	add	r0, sp, #40	; 0x28
    a974:	f7fa f85e 	bl	4a34 <lv_draw_label>
        if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
    a978:	f898 300e 	ldrb.w	r3, [r8, #14]
    a97c:	f003 0307 	and.w	r3, r3, #7
    a980:	2b04      	cmp	r3, #4
    a982:	d16a      	bne.n	aa5a <lv_label_design+0x206>
            lv_txt_get_size(&size, ext->text, style->text.font, style->text.letter_space, style->text.line_space,
    a984:	f647 4218 	movw	r2, #31768	; 0x7c18
    a988:	f9b4 3038 	ldrsh.w	r3, [r4, #56]	; 0x38
    a98c:	9502      	str	r5, [sp, #8]
    a98e:	9201      	str	r2, [sp, #4]
    a990:	f9b4 203a 	ldrsh.w	r2, [r4, #58]	; 0x3a
    a994:	9200      	str	r2, [sp, #0]
    a996:	6b62      	ldr	r2, [r4, #52]	; 0x34
    a998:	f8d8 1000 	ldr.w	r1, [r8]
    a99c:	a809      	add	r0, sp, #36	; 0x24
    a99e:	f7ff fe95 	bl	a6cc <lv_txt_get_size>
            if(size.x > lv_obj_get_width(label)) {
    a9a2:	f9bd 3024 	ldrsh.w	r3, [sp, #36]	; 0x24
    a9a6:	9306      	str	r3, [sp, #24]
    a9a8:	4630      	mov	r0, r6
    a9aa:	f7fe fac1 	bl	8f30 <lv_obj_get_width>
    a9ae:	9b06      	ldr	r3, [sp, #24]
    a9b0:	4283      	cmp	r3, r0
    a9b2:	dd29      	ble.n	aa08 <lv_label_design+0x1b4>
                ofs.x = ext->offset.x + size.x +
    a9b4:	f8bd 0024 	ldrh.w	r0, [sp, #36]	; 0x24
    a9b8:	f8b8 300a 	ldrh.w	r3, [r8, #10]
                        lv_font_get_glyph_width(style->text.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
    a9bc:	2220      	movs	r2, #32
                ofs.x = ext->offset.x + size.x +
    a9be:	4403      	add	r3, r0
                        lv_font_get_glyph_width(style->text.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
    a9c0:	4611      	mov	r1, r2
                ofs.x = ext->offset.x + size.x +
    a9c2:	b21b      	sxth	r3, r3
                        lv_font_get_glyph_width(style->text.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
    a9c4:	6b60      	ldr	r0, [r4, #52]	; 0x34
                ofs.x = ext->offset.x + size.x +
    a9c6:	9306      	str	r3, [sp, #24]
                        lv_font_get_glyph_width(style->text.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
    a9c8:	f000 f8f6 	bl	abb8 <lv_font_get_glyph_width>
                ofs.x = ext->offset.x + size.x +
    a9cc:	9b06      	ldr	r3, [sp, #24]
    a9ce:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    a9d2:	4403      	add	r3, r0
    a9d4:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
                ofs.y = ext->offset.y;
    a9d8:	f8b8 300c 	ldrh.w	r3, [r8, #12]
    a9dc:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs, &sel, NULL, lv_obj_get_base_dir(label));
    a9e0:	4630      	mov	r0, r6
    a9e2:	f8d8 3000 	ldr.w	r3, [r8]
    a9e6:	9306      	str	r3, [sp, #24]
    a9e8:	f7fe faae 	bl	8f48 <lv_obj_get_base_dir>
    a9ec:	aa0c      	add	r2, sp, #48	; 0x30
    a9ee:	9b06      	ldr	r3, [sp, #24]
    a9f0:	9300      	str	r3, [sp, #0]
    a9f2:	e9cd b004 	strd	fp, r0, [sp, #16]
    a9f6:	e9cd 5201 	strd	r5, r2, [sp, #4]
    a9fa:	9703      	str	r7, [sp, #12]
    a9fc:	4653      	mov	r3, sl
    a9fe:	4622      	mov	r2, r4
    aa00:	4649      	mov	r1, r9
    aa02:	a80a      	add	r0, sp, #40	; 0x28
    aa04:	f7fa f816 	bl	4a34 <lv_draw_label>
            if(size.y > lv_obj_get_height(label)) {
    aa08:	4630      	mov	r0, r6
    aa0a:	f9bd 7026 	ldrsh.w	r7, [sp, #38]	; 0x26
    aa0e:	f7fe fa95 	bl	8f3c <lv_obj_get_height>
    aa12:	4287      	cmp	r7, r0
    aa14:	dd21      	ble.n	aa5a <lv_label_design+0x206>
                ofs.x = ext->offset.x;
    aa16:	f8b8 300a 	ldrh.w	r3, [r8, #10]
    aa1a:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
                ofs.y = ext->offset.y + size.y + lv_font_get_line_height(style->text.font);
    aa1e:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
    aa22:	f8b8 300c 	ldrh.w	r3, [r8, #12]
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs, &sel, NULL, lv_obj_get_base_dir(label));
    aa26:	f8d8 7000 	ldr.w	r7, [r8]
                ofs.y = ext->offset.y + size.y + lv_font_get_line_height(style->text.font);
    aa2a:	441a      	add	r2, r3
    aa2c:	6b63      	ldr	r3, [r4, #52]	; 0x34
    aa2e:	7a1b      	ldrb	r3, [r3, #8]
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs, &sel, NULL, lv_obj_get_base_dir(label));
    aa30:	4630      	mov	r0, r6
                ofs.y = ext->offset.y + size.y + lv_font_get_line_height(style->text.font);
    aa32:	4413      	add	r3, r2
    aa34:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs, &sel, NULL, lv_obj_get_base_dir(label));
    aa38:	f7fe fa86 	bl	8f48 <lv_obj_get_base_dir>
    aa3c:	2300      	movs	r3, #0
    aa3e:	9304      	str	r3, [sp, #16]
    aa40:	ab08      	add	r3, sp, #32
    aa42:	9303      	str	r3, [sp, #12]
    aa44:	ab0c      	add	r3, sp, #48	; 0x30
    aa46:	9005      	str	r0, [sp, #20]
    aa48:	e9cd 5301 	strd	r5, r3, [sp, #4]
    aa4c:	9700      	str	r7, [sp, #0]
    aa4e:	4653      	mov	r3, sl
    aa50:	4622      	mov	r2, r4
    aa52:	4649      	mov	r1, r9
    aa54:	a80a      	add	r0, sp, #40	; 0x28
    aa56:	f7f9 ffed 	bl	4a34 <lv_draw_label>
    return true;
    aa5a:	2001      	movs	r0, #1
    aa5c:	e005      	b.n	aa6a <lv_label_design+0x216>
        if(align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
    aa5e:	2802      	cmp	r0, #2
    aa60:	bf08      	it	eq
    aa62:	f045 0508 	orreq.w	r5, r5, #8
    aa66:	e747      	b.n	a8f8 <lv_label_design+0xa4>
        return false;
    aa68:	2000      	movs	r0, #0
}
    aa6a:	b00f      	add	sp, #60	; 0x3c
    aa6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000aa70 <lv_label_get_recolor>:
{
    aa70:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    aa72:	f7fe facb 	bl	900c <lv_obj_get_ext_attr>
    return ext->recolor == 0 ? false : true;
    aa76:	7b80      	ldrb	r0, [r0, #14]
}
    aa78:	f3c0 1080 	ubfx	r0, r0, #6, #1
    aa7c:	bd08      	pop	{r3, pc}

0000aa7e <lv_label_get_body_draw>:
{
    aa7e:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    aa80:	f7fe fac4 	bl	900c <lv_obj_get_ext_attr>
    return ext->body_draw == 0 ? false : true;
    aa84:	7bc0      	ldrb	r0, [r0, #15]
}
    aa86:	f000 0001 	and.w	r0, r0, #1
    aa8a:	bd08      	pop	{r3, pc}

0000aa8c <lv_label_set_text>:
{
    aa8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    aa90:	4607      	mov	r7, r0
    aa92:	460d      	mov	r5, r1
    lv_obj_invalidate(label);
    aa94:	f7fd fffa 	bl	8a8c <lv_obj_invalidate>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    aa98:	4638      	mov	r0, r7
    aa9a:	f7fe fab7 	bl	900c <lv_obj_get_ext_attr>
    aa9e:	4604      	mov	r4, r0
    if(text == NULL) {
    aaa0:	b925      	cbnz	r5, aaac <lv_label_set_text+0x20>
        lv_label_refr_text(label);
    aaa2:	4638      	mov	r0, r7
}
    aaa4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        lv_label_refr_text(label);
    aaa8:	f7fb b9be 	b.w	5e28 <lv_label_refr_text>
    if(ext->text == text) {
    aaac:	6806      	ldr	r6, [r0, #0]
    aaae:	42ae      	cmp	r6, r5
    aab0:	d10b      	bne.n	aaca <lv_label_set_text+0x3e>
        ext->text = lv_mem_realloc(ext->text, strlen(ext->text) + 1);
    aab2:	4630      	mov	r0, r6
    aab4:	f7fd fae7 	bl	8086 <strlen>
    aab8:	1c41      	adds	r1, r0, #1
    aaba:	4630      	mov	r0, r6
    aabc:	f7fa feca 	bl	5854 <lv_mem_realloc>
    aac0:	6020      	str	r0, [r4, #0]
        if(ext->text == NULL) return;
    aac2:	2800      	cmp	r0, #0
    aac4:	d1ed      	bne.n	aaa2 <lv_label_set_text+0x16>
}
    aac6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        size_t len = strlen(text) + 1;
    aaca:	4628      	mov	r0, r5
    aacc:	f7fd fadb 	bl	8086 <strlen>
    aad0:	f100 0801 	add.w	r8, r0, #1
        if(ext->text != NULL && ext->static_txt == 0) {
    aad4:	6820      	ldr	r0, [r4, #0]
    aad6:	b130      	cbz	r0, aae6 <lv_label_set_text+0x5a>
    aad8:	7ba3      	ldrb	r3, [r4, #14]
    aada:	f013 0608 	ands.w	r6, r3, #8
    aade:	d102      	bne.n	aae6 <lv_label_set_text+0x5a>
            lv_mem_free(ext->text);
    aae0:	f7fa fe9a 	bl	5818 <lv_mem_free>
            ext->text = NULL;
    aae4:	6026      	str	r6, [r4, #0]
        ext->text = lv_mem_alloc(len);
    aae6:	4640      	mov	r0, r8
    aae8:	f7fa fe70 	bl	57cc <lv_mem_alloc>
    aaec:	6020      	str	r0, [r4, #0]
        if(ext->text == NULL) return;
    aaee:	2800      	cmp	r0, #0
    aaf0:	d0e9      	beq.n	aac6 <lv_label_set_text+0x3a>
        strcpy(ext->text, text);
    aaf2:	4629      	mov	r1, r5
    aaf4:	f7fd fa9c 	bl	8030 <strcpy>
        ext->static_txt = 0;
    aaf8:	7ba3      	ldrb	r3, [r4, #14]
    aafa:	f36f 03c3 	bfc	r3, #3, #1
    aafe:	73a3      	strb	r3, [r4, #14]
    ab00:	e7cf      	b.n	aaa2 <lv_label_set_text+0x16>

0000ab02 <lv_label_set_static_text>:
{
    ab02:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ab04:	4607      	mov	r7, r0
    ab06:	460e      	mov	r6, r1
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    ab08:	f7fe fa80 	bl	900c <lv_obj_get_ext_attr>
    if(ext->static_txt == 0 && ext->text != NULL) {
    ab0c:	7b83      	ldrb	r3, [r0, #14]
    ab0e:	f013 0508 	ands.w	r5, r3, #8
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    ab12:	4604      	mov	r4, r0
    if(ext->static_txt == 0 && ext->text != NULL) {
    ab14:	d104      	bne.n	ab20 <lv_label_set_static_text+0x1e>
    ab16:	6800      	ldr	r0, [r0, #0]
    ab18:	b110      	cbz	r0, ab20 <lv_label_set_static_text+0x1e>
        lv_mem_free(ext->text);
    ab1a:	f7fa fe7d 	bl	5818 <lv_mem_free>
        ext->text = NULL;
    ab1e:	6025      	str	r5, [r4, #0]
    if(text != NULL) {
    ab20:	b126      	cbz	r6, ab2c <lv_label_set_static_text+0x2a>
        ext->static_txt = 1;
    ab22:	7ba3      	ldrb	r3, [r4, #14]
        ext->text       = (char *)text;
    ab24:	6026      	str	r6, [r4, #0]
        ext->static_txt = 1;
    ab26:	f043 0308 	orr.w	r3, r3, #8
    ab2a:	73a3      	strb	r3, [r4, #14]
    lv_label_refr_text(label);
    ab2c:	4638      	mov	r0, r7
}
    ab2e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    lv_label_refr_text(label);
    ab32:	f7fb b979 	b.w	5e28 <lv_label_refr_text>

0000ab36 <lv_label_set_long_mode>:
{
    ab36:	b570      	push	{r4, r5, r6, lr}
    ab38:	460e      	mov	r6, r1
    ab3a:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    ab3c:	f7fe fa66 	bl	900c <lv_obj_get_ext_attr>
    if(long_mode == LV_LABEL_LONG_SROLL || long_mode == LV_LABEL_LONG_SROLL_CIRC || long_mode == LV_LABEL_LONG_CROP)
    ab40:	1ef2      	subs	r2, r6, #3
    ext->offset.x = 0;
    ab42:	2300      	movs	r3, #0
    if(long_mode == LV_LABEL_LONG_SROLL || long_mode == LV_LABEL_LONG_SROLL_CIRC || long_mode == LV_LABEL_LONG_CROP)
    ab44:	2a02      	cmp	r2, #2
    ext->offset.x = 0;
    ab46:	8143      	strh	r3, [r0, #10]
    ext->offset.y = 0;
    ab48:	8183      	strh	r3, [r0, #12]
    ab4a:	7b83      	ldrb	r3, [r0, #14]
    if(long_mode == LV_LABEL_LONG_SROLL || long_mode == LV_LABEL_LONG_SROLL_CIRC || long_mode == LV_LABEL_LONG_CROP)
    ab4c:	bf8c      	ite	hi
    ab4e:	2200      	movhi	r2, #0
    ab50:	2201      	movls	r2, #1
    ab52:	f362 13c7 	bfi	r3, r2, #7, #1
    ab56:	7383      	strb	r3, [r0, #14]
    if(ext->long_mode == LV_LABEL_LONG_DOT && ext->dot_end != LV_LABEL_DOT_END_INV) {
    ab58:	f003 0307 	and.w	r3, r3, #7
    ab5c:	2b02      	cmp	r3, #2
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    ab5e:	4604      	mov	r4, r0
    if(ext->long_mode == LV_LABEL_LONG_DOT && ext->dot_end != LV_LABEL_DOT_END_INV) {
    ab60:	d107      	bne.n	ab72 <lv_label_set_long_mode+0x3c>
    ab62:	8902      	ldrh	r2, [r0, #8]
    ab64:	f64f 73ff 	movw	r3, #65535	; 0xffff
    ab68:	429a      	cmp	r2, r3
    ab6a:	d002      	beq.n	ab72 <lv_label_set_long_mode+0x3c>
        lv_label_revert_dots(label);
    ab6c:	4628      	mov	r0, r5
    ab6e:	f7fa ffff 	bl	5b70 <lv_label_revert_dots>
    ext->long_mode = long_mode;
    ab72:	7ba3      	ldrb	r3, [r4, #14]
    ab74:	f366 0302 	bfi	r3, r6, #0, #3
    ab78:	73a3      	strb	r3, [r4, #14]
    lv_label_refr_text(label);
    ab7a:	4628      	mov	r0, r5
}
    ab7c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    lv_label_refr_text(label);
    ab80:	f7fb b952 	b.w	5e28 <lv_label_refr_text>

0000ab84 <lv_label_set_recolor>:
{
    ab84:	b538      	push	{r3, r4, r5, lr}
    ab86:	460c      	mov	r4, r1
    ab88:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    ab8a:	f7fe fa3f 	bl	900c <lv_obj_get_ext_attr>
    if(ext->recolor == en) return;
    ab8e:	7b83      	ldrb	r3, [r0, #14]
    ab90:	f3c3 1280 	ubfx	r2, r3, #6, #1
    ab94:	42a2      	cmp	r2, r4
    ab96:	d007      	beq.n	aba8 <lv_label_set_recolor+0x24>
    ext->recolor = en == false ? 0 : 1;
    ab98:	f364 1386 	bfi	r3, r4, #6, #1
    ab9c:	7383      	strb	r3, [r0, #14]
    lv_label_refr_text(label); /*Refresh the text because the potential colo codes in text needs to
    ab9e:	4628      	mov	r0, r5
}
    aba0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    lv_label_refr_text(label); /*Refresh the text because the potential colo codes in text needs to
    aba4:	f7fb b940 	b.w	5e28 <lv_label_refr_text>
}
    aba8:	bd38      	pop	{r3, r4, r5, pc}

0000abaa <lv_font_get_glyph_bitmap>:
 * @param letter an UNICODE character code
 * @return  pointer to the bitmap of the letter
 */
const uint8_t * lv_font_get_glyph_bitmap(const lv_font_t * font_p, uint32_t letter)
{
    return font_p->get_glyph_bitmap(font_p, letter);
    abaa:	6843      	ldr	r3, [r0, #4]
    abac:	4718      	bx	r3

0000abae <lv_font_get_glyph_dsc>:
 * @param letter an UNICODE letter code
 * @return true: descriptor is successfully loaded into `dsc_out`.
 *         false: the letter was not found, no data is loaded to `dsc_out`
 */
bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_out, uint32_t letter, uint32_t letter_next)
{
    abae:	b410      	push	{r4}
    return font_p->get_glyph_dsc(font_p, dsc_out, letter, letter_next);
    abb0:	6804      	ldr	r4, [r0, #0]
    abb2:	46a4      	mov	ip, r4
}
    abb4:	bc10      	pop	{r4}
    return font_p->get_glyph_dsc(font_p, dsc_out, letter, letter_next);
    abb6:	4760      	bx	ip

0000abb8 <lv_font_get_glyph_width>:
 * @param letter an UNICODE letter
 * @param letter_next the next letter after `letter`. Used for kerning
 * @return the width of the glyph
 */
uint16_t lv_font_get_glyph_width(const lv_font_t * font, uint32_t letter, uint32_t letter_next)
{
    abb8:	b507      	push	{r0, r1, r2, lr}
    lv_font_glyph_dsc_t g;
    bool ret;
    ret = lv_font_get_glyph_dsc(font, &g, letter, letter_next);
    abba:	4613      	mov	r3, r2
    abbc:	460a      	mov	r2, r1
    abbe:	4669      	mov	r1, sp
    abc0:	f7ff fff5 	bl	abae <lv_font_get_glyph_dsc>
    if(ret) return g.adv_w;
    abc4:	b108      	cbz	r0, abca <lv_font_get_glyph_width+0x12>
    abc6:	f8bd 0000 	ldrh.w	r0, [sp]
    else return 0;
}
    abca:	b003      	add	sp, #12
    abcc:	f85d fb04 	ldr.w	pc, [sp], #4

0000abd0 <kern_pair_8_compare>:
    if(ref8_p[0] != element8_p[0]) return (int32_t)ref8_p[0] - element8_p[0];
    abd0:	7803      	ldrb	r3, [r0, #0]
    abd2:	780a      	ldrb	r2, [r1, #0]
    abd4:	4293      	cmp	r3, r2
    abd6:	bf11      	iteee	ne
    abd8:	1a98      	subne	r0, r3, r2
    else return (int32_t) ref8_p[1] - element8_p[1];
    abda:	784b      	ldrbeq	r3, [r1, #1]
    abdc:	7840      	ldrbeq	r0, [r0, #1]
    abde:	1ac0      	subeq	r0, r0, r3
}
    abe0:	4770      	bx	lr

0000abe2 <kern_pair_16_compare>:
    if(ref16_p[0] != element16_p[0]) return (int32_t)ref16_p[0] - element16_p[0];
    abe2:	8803      	ldrh	r3, [r0, #0]
    abe4:	880a      	ldrh	r2, [r1, #0]
    abe6:	4293      	cmp	r3, r2
    abe8:	bf11      	iteee	ne
    abea:	1a98      	subne	r0, r3, r2
    else return (int32_t) ref16_p[1] - element16_p[1];
    abec:	884b      	ldrheq	r3, [r1, #2]
    abee:	8840      	ldrheq	r0, [r0, #2]
    abf0:	1ac0      	subeq	r0, r0, r3
}
    abf2:	4770      	bx	lr

0000abf4 <get_bits>:
{
    abf4:	b510      	push	{r4, lr}
    uint32_t byte_pos = bit_pos >> 3;
    abf6:	08cb      	lsrs	r3, r1, #3
    bit_pos = bit_pos & 0x7;
    abf8:	f001 0107 	and.w	r1, r1, #7
    uint16_t in16 = (in[byte_pos] << 8) + in[byte_pos + 1];
    abfc:	5cc4      	ldrb	r4, [r0, r3]
    abfe:	4418      	add	r0, r3
    uint8_t bit_mask = (uint16_t)((uint16_t) 1 << len) - 1;
    ac00:	2301      	movs	r3, #1
    uint16_t in16 = (in[byte_pos] << 8) + in[byte_pos + 1];
    ac02:	7840      	ldrb	r0, [r0, #1]
    ac04:	eb00 2004 	add.w	r0, r0, r4, lsl #8
    res = (in16 >> (16 - bit_pos - len)) & bit_mask;
    ac08:	f1c2 0410 	rsb	r4, r2, #16
    ac0c:	1a61      	subs	r1, r4, r1
    uint8_t bit_mask = (uint16_t)((uint16_t) 1 << len) - 1;
    ac0e:	4093      	lsls	r3, r2
    res = (in16 >> (16 - bit_pos - len)) & bit_mask;
    ac10:	b280      	uxth	r0, r0
    ac12:	4108      	asrs	r0, r1
    uint8_t bit_mask = (uint16_t)((uint16_t) 1 << len) - 1;
    ac14:	3b01      	subs	r3, #1
    res = (in16 >> (16 - bit_pos - len)) & bit_mask;
    ac16:	4018      	ands	r0, r3
}
    ac18:	b2c0      	uxtb	r0, r0
    ac1a:	bd10      	pop	{r4, pc}

0000ac1c <unicode_list_compare>:
 *  @retval > 0   Reference is less than element.
 *
 */
static int32_t unicode_list_compare(const void * ref, const void * element)
{
    return (*(uint16_t *)ref) - (*(uint16_t *)element);
    ac1c:	8800      	ldrh	r0, [r0, #0]
    ac1e:	880b      	ldrh	r3, [r1, #0]
}
    ac20:	1ac0      	subs	r0, r0, r3
    ac22:	4770      	bx	lr

0000ac24 <arch_system_halt>:
	__asm__ volatile(
    ac24:	f04f 0220 	mov.w	r2, #32
    ac28:	f3ef 8311 	mrs	r3, BASEPRI
    ac2c:	f382 8811 	msr	BASEPRI, r2
    ac30:	f3bf 8f6f 	isb	sy
	}
    ac34:	e7fe      	b.n	ac34 <arch_system_halt+0x10>

0000ac36 <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
    ac36:	f7fd b9e5 	b.w	8004 <z_clock_idle_exit>

0000ac3a <k_mem_slab_init>:
{
    ac3a:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
    ac3c:	2400      	movs	r4, #0
	slab->block_size = block_size;
    ac3e:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->free_list = NULL;
    ac42:	e9c0 4405 	strd	r4, r4, [r0, #20]
	slab->buffer = buffer;
    ac46:	6101      	str	r1, [r0, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
    ac48:	42a3      	cmp	r3, r4
    ac4a:	d102      	bne.n	ac52 <k_mem_slab_init+0x18>
	list->tail = (sys_dnode_t *)list;
    ac4c:	e9c0 0000 	strd	r0, r0, [r0]
}
    ac50:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
    ac52:	6945      	ldr	r5, [r0, #20]
    ac54:	600d      	str	r5, [r1, #0]
	for (j = 0U; j < slab->num_blocks; j++) {
    ac56:	3401      	adds	r4, #1
		slab->free_list = p;
    ac58:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
    ac5a:	4411      	add	r1, r2
    ac5c:	e7f4      	b.n	ac48 <k_mem_slab_init+0xe>

0000ac5e <k_mem_pool_malloc>:
{
	k_mem_pool_free_id(&block->id);
}

void *k_mem_pool_malloc(struct k_mem_pool *pool, size_t size)
{
    ac5e:	b513      	push	{r0, r1, r4, lr}
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
    ac60:	2404      	movs	r4, #4
    ac62:	190a      	adds	r2, r1, r4
    ac64:	d204      	bcs.n	ac70 <k_mem_pool_malloc+0x12>
	 */
	if (size_add_overflow(size, WB_UP(sizeof(struct k_mem_block_id)),
			      &size)) {
		return NULL;
	}
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
    ac66:	2300      	movs	r3, #0
    ac68:	4669      	mov	r1, sp
    ac6a:	f7fb ff59 	bl	6b20 <k_mem_pool_alloc>
    ac6e:	b110      	cbz	r0, ac76 <k_mem_pool_malloc+0x18>
		return NULL;
    ac70:	2000      	movs	r0, #0
	/* save the block descriptor info at the start of the actual block */
	(void)memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));

	/* return address of the user area part of the block to the caller */
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
}
    ac72:	b002      	add	sp, #8
    ac74:	bd10      	pop	{r4, pc}
	(void)memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));
    ac76:	4622      	mov	r2, r4
    ac78:	a901      	add	r1, sp, #4
    ac7a:	9800      	ldr	r0, [sp, #0]
    ac7c:	f7fd fa16 	bl	80ac <memcpy>
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
    ac80:	9800      	ldr	r0, [sp, #0]
    ac82:	3004      	adds	r0, #4
    ac84:	e7f5      	b.n	ac72 <k_mem_pool_malloc+0x14>

0000ac86 <k_free>:

void k_free(void *ptr)
{
	if (ptr != NULL) {
    ac86:	b110      	cbz	r0, ac8e <k_free+0x8>
		/* point to hidden block descriptor at start of block */
		ptr = (char *)ptr - WB_UP(sizeof(struct k_mem_block_id));

		/* return block to the heap memory pool */
		k_mem_pool_free_id(ptr);
    ac88:	3804      	subs	r0, #4
    ac8a:	f7fb bf95 	b.w	6bb8 <k_mem_pool_free_id>
	}
}
    ac8e:	4770      	bx	lr

0000ac90 <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    ac90:	7b43      	ldrb	r3, [r0, #13]
    ac92:	06db      	lsls	r3, r3, #27
    ac94:	bf03      	ittte	eq
    ac96:	6980      	ldreq	r0, [r0, #24]
    ac98:	fab0 f080 	clzeq	r0, r0
    ac9c:	0940      	lsreq	r0, r0, #5
    ac9e:	2000      	movne	r0, #0
}
    aca0:	4770      	bx	lr

0000aca2 <z_find_first_thread_to_unpend>:
{
    aca2:	b510      	push	{r4, lr}
    aca4:	f04f 0320 	mov.w	r3, #32
    aca8:	f3ef 8411 	mrs	r4, BASEPRI
    acac:	f383 8811 	msr	BASEPRI, r3
    acb0:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
    acb4:	f000 f85d 	bl	ad72 <z_priq_dumb_best>
	__asm__ volatile(
    acb8:	f384 8811 	msr	BASEPRI, r4
    acbc:	f3bf 8f6f 	isb	sy
}
    acc0:	bd10      	pop	{r4, pc}

0000acc2 <z_unpend_thread_no_timeout>:
{
    acc2:	b538      	push	{r3, r4, r5, lr}
    acc4:	4604      	mov	r4, r0
	__asm__ volatile(
    acc6:	f04f 0320 	mov.w	r3, #32
    acca:	f3ef 8511 	mrs	r5, BASEPRI
    acce:	f383 8811 	msr	BASEPRI, r3
    acd2:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
    acd6:	4601      	mov	r1, r0
    acd8:	6880      	ldr	r0, [r0, #8]
    acda:	f7fb ffef 	bl	6cbc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    acde:	7b63      	ldrb	r3, [r4, #13]
    ace0:	f023 0302 	bic.w	r3, r3, #2
    ace4:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
    ace6:	f385 8811 	msr	BASEPRI, r5
    acea:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
    acee:	2300      	movs	r3, #0
    acf0:	60a3      	str	r3, [r4, #8]
}
    acf2:	bd38      	pop	{r3, r4, r5, pc}

0000acf4 <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    acf4:	b921      	cbnz	r1, ad00 <z_reschedule+0xc>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    acf6:	f3ef 8005 	mrs	r0, IPSR
    acfa:	b908      	cbnz	r0, ad00 <z_reschedule+0xc>
    acfc:	f7f6 ba02 	b.w	1104 <arch_swap>
    ad00:	f381 8811 	msr	BASEPRI, r1
    ad04:	f3bf 8f6f 	isb	sy
}
    ad08:	4770      	bx	lr

0000ad0a <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    ad0a:	4603      	mov	r3, r0
    ad0c:	b920      	cbnz	r0, ad18 <z_reschedule_irqlock+0xe>
    ad0e:	f3ef 8205 	mrs	r2, IPSR
    ad12:	b90a      	cbnz	r2, ad18 <z_reschedule_irqlock+0xe>
    ad14:	f7f6 b9f6 	b.w	1104 <arch_swap>
    ad18:	f383 8811 	msr	BASEPRI, r3
    ad1c:	f3bf 8f6f 	isb	sy
}
    ad20:	4770      	bx	lr

0000ad22 <z_reschedule_unlocked>:
	__asm__ volatile(
    ad22:	f04f 0320 	mov.w	r3, #32
    ad26:	f3ef 8011 	mrs	r0, BASEPRI
    ad2a:	f383 8811 	msr	BASEPRI, r3
    ad2e:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
    ad32:	f7ff bfea 	b.w	ad0a <z_reschedule_irqlock>

0000ad36 <z_unpend_thread>:
{
    ad36:	b538      	push	{r3, r4, r5, lr}
    ad38:	4604      	mov	r4, r0
    ad3a:	f04f 0320 	mov.w	r3, #32
    ad3e:	f3ef 8511 	mrs	r5, BASEPRI
    ad42:	f383 8811 	msr	BASEPRI, r3
    ad46:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
    ad4a:	4601      	mov	r1, r0
    ad4c:	6880      	ldr	r0, [r0, #8]
    ad4e:	f7fb ffb5 	bl	6cbc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    ad52:	7b63      	ldrb	r3, [r4, #13]
    ad54:	f023 0302 	bic.w	r3, r3, #2
    ad58:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
    ad5a:	f385 8811 	msr	BASEPRI, r5
    ad5e:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
    ad62:	2300      	movs	r3, #0
    ad64:	60a3      	str	r3, [r4, #8]
	return z_abort_timeout(&thread->base.timeout);
    ad66:	f104 0018 	add.w	r0, r4, #24
}
    ad6a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ad6e:	f000 b890 	b.w	ae92 <z_abort_timeout>

0000ad72 <z_priq_dumb_best>:
	return list->head == list;
    ad72:	6803      	ldr	r3, [r0, #0]
}
    ad74:	4298      	cmp	r0, r3
    ad76:	bf14      	ite	ne
    ad78:	4618      	movne	r0, r3
    ad7a:	2000      	moveq	r0, #0
    ad7c:	4770      	bx	lr

0000ad7e <z_thread_timeout>:
	if (thread->base.pended_on != NULL) {
    ad7e:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
    ad82:	b570      	push	{r4, r5, r6, lr}
    ad84:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
    ad86:	f1a0 0518 	sub.w	r5, r0, #24
	if (thread->base.pended_on != NULL) {
    ad8a:	b1cb      	cbz	r3, adc0 <z_thread_timeout+0x42>
	__asm__ volatile(
    ad8c:	f04f 0320 	mov.w	r3, #32
    ad90:	f3ef 8611 	mrs	r6, BASEPRI
    ad94:	f383 8811 	msr	BASEPRI, r3
    ad98:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
    ad9c:	4629      	mov	r1, r5
    ad9e:	f850 0c10 	ldr.w	r0, [r0, #-16]
    ada2:	f7fb ff8b 	bl	6cbc <z_priq_dumb_remove>
    ada6:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
    adaa:	f023 0302 	bic.w	r3, r3, #2
    adae:	f804 3c0b 	strb.w	r3, [r4, #-11]
	__asm__ volatile(
    adb2:	f386 8811 	msr	BASEPRI, r6
    adb6:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
    adba:	2300      	movs	r3, #0
    adbc:	f844 3c10 	str.w	r3, [r4, #-16]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    adc0:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
    adc4:	f023 0314 	bic.w	r3, r3, #20
    adc8:	f804 3c0b 	strb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
    adcc:	4628      	mov	r0, r5
    adce:	f7ff ff5f 	bl	ac90 <z_is_thread_ready>
    add2:	b120      	cbz	r0, adde <z_thread_timeout+0x60>
		z_add_thread_to_ready_q(thread);
    add4:	4628      	mov	r0, r5
}
    add6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    adda:	f7fb bfbf 	b.w	6d5c <z_add_thread_to_ready_q>
    adde:	bd70      	pop	{r4, r5, r6, pc}

0000ade0 <z_unpend_first_thread>:
{
    ade0:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
    ade2:	f04f 0320 	mov.w	r3, #32
    ade6:	f3ef 8211 	mrs	r2, BASEPRI
    adea:	f383 8811 	msr	BASEPRI, r3
    adee:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
    adf2:	f7ff ffbe 	bl	ad72 <z_priq_dumb_best>
    adf6:	4604      	mov	r4, r0
	__asm__ volatile(
    adf8:	f382 8811 	msr	BASEPRI, r2
    adfc:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
    ae00:	b1c8      	cbz	r0, ae36 <z_unpend_first_thread+0x56>
	__asm__ volatile(
    ae02:	f04f 0320 	mov.w	r3, #32
    ae06:	f3ef 8511 	mrs	r5, BASEPRI
    ae0a:	f383 8811 	msr	BASEPRI, r3
    ae0e:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
    ae12:	4601      	mov	r1, r0
    ae14:	6880      	ldr	r0, [r0, #8]
    ae16:	f7fb ff51 	bl	6cbc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    ae1a:	7b63      	ldrb	r3, [r4, #13]
    ae1c:	f023 0302 	bic.w	r3, r3, #2
    ae20:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
    ae22:	f385 8811 	msr	BASEPRI, r5
    ae26:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
    ae2a:	2300      	movs	r3, #0
    ae2c:	60a3      	str	r3, [r4, #8]
    ae2e:	f104 0018 	add.w	r0, r4, #24
    ae32:	f000 f82e 	bl	ae92 <z_abort_timeout>
}
    ae36:	4620      	mov	r0, r4
    ae38:	bd38      	pop	{r3, r4, r5, pc}

0000ae3a <z_unpend_all>:
{
    ae3a:	b570      	push	{r4, r5, r6, lr}
    ae3c:	4606      	mov	r6, r0
	int need_sched = 0;
    ae3e:	2500      	movs	r5, #0
    ae40:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    ae42:	42a6      	cmp	r6, r4
    ae44:	d000      	beq.n	ae48 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    ae46:	b90c      	cbnz	r4, ae4c <z_unpend_all+0x12>
}
    ae48:	4628      	mov	r0, r5
    ae4a:	bd70      	pop	{r4, r5, r6, pc}
		z_unpend_thread(thread);
    ae4c:	4620      	mov	r0, r4
    ae4e:	f7ff ff72 	bl	ad36 <z_unpend_thread>
	if (z_is_thread_ready(thread)) {
    ae52:	4620      	mov	r0, r4
    ae54:	f7ff ff1c 	bl	ac90 <z_is_thread_ready>
		need_sched = 1;
    ae58:	2501      	movs	r5, #1
    ae5a:	2800      	cmp	r0, #0
    ae5c:	d0f0      	beq.n	ae40 <z_unpend_all+0x6>
		z_add_thread_to_ready_q(thread);
    ae5e:	4620      	mov	r0, r4
    ae60:	f7fb ff7c 	bl	6d5c <z_add_thread_to_ready_q>
    ae64:	e7ec      	b.n	ae40 <z_unpend_all+0x6>

0000ae66 <z_impl_k_busy_wait>:
	arch_busy_wait(usec_to_wait);
    ae66:	f7f7 bc4f 	b.w	2708 <arch_busy_wait>

0000ae6a <z_impl_k_thread_name_set>:
}
    ae6a:	f06f 0046 	mvn.w	r0, #70	; 0x46
    ae6e:	4770      	bx	lr

0000ae70 <k_thread_name_get>:
}
    ae70:	2000      	movs	r0, #0
    ae72:	4770      	bx	lr

0000ae74 <z_new_thread_init>:
{
    ae74:	b510      	push	{r4, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
    ae76:	9c02      	ldr	r4, [sp, #8]
    ae78:	7304      	strb	r4, [r0, #12]
	thread_base->thread_state = (u8_t)initial_state;

	thread_base->prio = priority;
    ae7a:	7383      	strb	r3, [r0, #14]
	thread_base->thread_state = (u8_t)initial_state;
    ae7c:	2404      	movs	r4, #4

	thread_base->sched_locked = 0U;
    ae7e:	2300      	movs	r3, #0
	thread_base->thread_state = (u8_t)initial_state;
    ae80:	7344      	strb	r4, [r0, #13]
	thread_base->sched_locked = 0U;
    ae82:	73c3      	strb	r3, [r0, #15]
	node->prev = NULL;
    ae84:	e9c0 3306 	strd	r3, r3, [r0, #24]
	thread->fn_abort = NULL;
    ae88:	e9c0 3313 	strd	r3, r3, [r0, #76]	; 0x4c
	thread->stack_info.size = (u32_t)stackSize;
    ae8c:	e9c0 1216 	strd	r1, r2, [r0, #88]	; 0x58
}
    ae90:	bd10      	pop	{r4, pc}

0000ae92 <z_abort_timeout>:
{
    ae92:	b510      	push	{r4, lr}
	__asm__ volatile(
    ae94:	f04f 0220 	mov.w	r2, #32
    ae98:	f3ef 8411 	mrs	r4, BASEPRI
    ae9c:	f382 8811 	msr	BASEPRI, r2
    aea0:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
    aea4:	6803      	ldr	r3, [r0, #0]
    aea6:	b13b      	cbz	r3, aeb8 <z_abort_timeout+0x26>
			remove_timeout(to);
    aea8:	f7fc fb0c 	bl	74c4 <remove_timeout>
			ret = 0;
    aeac:	2000      	movs	r0, #0
	__asm__ volatile(
    aeae:	f384 8811 	msr	BASEPRI, r4
    aeb2:	f3bf 8f6f 	isb	sy
}
    aeb6:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
    aeb8:	f06f 0015 	mvn.w	r0, #21
    aebc:	e7f7      	b.n	aeae <z_abort_timeout+0x1c>

0000aebe <z_get_next_timeout_expiry>:
{
    aebe:	b510      	push	{r4, lr}
	__asm__ volatile(
    aec0:	f04f 0320 	mov.w	r3, #32
    aec4:	f3ef 8411 	mrs	r4, BASEPRI
    aec8:	f383 8811 	msr	BASEPRI, r3
    aecc:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
    aed0:	f7fc fb0c 	bl	74ec <next_timeout>
	__asm__ volatile(
    aed4:	f384 8811 	msr	BASEPRI, r4
    aed8:	f3bf 8f6f 	isb	sy
}
    aedc:	bd10      	pop	{r4, pc}

0000aede <z_set_timeout_expiry>:
{
    aede:	b570      	push	{r4, r5, r6, lr}
    aee0:	4604      	mov	r4, r0
    aee2:	460e      	mov	r6, r1
	__asm__ volatile(
    aee4:	f04f 0320 	mov.w	r3, #32
    aee8:	f3ef 8511 	mrs	r5, BASEPRI
    aeec:	f383 8811 	msr	BASEPRI, r3
    aef0:	f3bf 8f6f 	isb	sy
		int next = next_timeout();
    aef4:	f7fc fafa 	bl	74ec <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    aef8:	2801      	cmp	r0, #1
    aefa:	dd05      	ble.n	af08 <z_set_timeout_expiry+0x2a>
    aefc:	42a0      	cmp	r0, r4
    aefe:	dd03      	ble.n	af08 <z_set_timeout_expiry+0x2a>
			z_clock_set_timeout(ticks, idle);
    af00:	4631      	mov	r1, r6
    af02:	4620      	mov	r0, r4
    af04:	f7f6 f866 	bl	fd4 <z_clock_set_timeout>
	__asm__ volatile(
    af08:	f385 8811 	msr	BASEPRI, r5
    af0c:	f3bf 8f6f 	isb	sy
}
    af10:	bd70      	pop	{r4, r5, r6, pc}

0000af12 <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
    af12:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
    af14:	f7fc fb9e 	bl	7654 <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
    af18:	bd08      	pop	{r3, pc}

0000af1a <z_impl_k_uptime_get>:

s64_t z_impl_k_uptime_get(void)
{
    af1a:	b510      	push	{r4, lr}
	return k_ticks_to_ms_floor64(z_tick_get());
    af1c:	f7fc fb9a 	bl	7654 <z_tick_get>
			return (t * to_hz + off) / from_hz;
    af20:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
    af24:	fba0 2304 	umull	r2, r3, r0, r4
    af28:	fb04 3301 	mla	r3, r4, r1, r3
    af2c:	0bd0      	lsrs	r0, r2, #15
}
    af2e:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
    af32:	0bd9      	lsrs	r1, r3, #15
    af34:	bd10      	pop	{r4, pc}

0000af36 <k_timer_init>:
	timer->status = 0U;
    af36:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
    af38:	e9c0 1206 	strd	r1, r2, [r0, #24]
    af3c:	f100 0210 	add.w	r2, r0, #16
	timer->status = 0U;
    af40:	6243      	str	r3, [r0, #36]	; 0x24
	list->tail = (sys_dnode_t *)list;
    af42:	e9c0 2204 	strd	r2, r2, [r0, #16]
	node->prev = NULL;
    af46:	e9c0 3300 	strd	r3, r3, [r0]
	timer->user_data = NULL;
    af4a:	6283      	str	r3, [r0, #40]	; 0x28
}
    af4c:	4770      	bx	lr

0000af4e <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
    af4e:	b510      	push	{r4, lr}
    af50:	4604      	mov	r4, r0
	int inactive = z_abort_timeout(&timer->timeout) != 0;
    af52:	f7ff ff9e 	bl	ae92 <z_abort_timeout>

	if (inactive) {
    af56:	bb00      	cbnz	r0, af9a <z_impl_k_timer_stop+0x4c>
		return;
	}

	if (timer->stop_fn != NULL) {
    af58:	69e3      	ldr	r3, [r4, #28]
    af5a:	b10b      	cbz	r3, af60 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
    af5c:	4620      	mov	r0, r4
    af5e:	4798      	blx	r3
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
    af60:	f104 0010 	add.w	r0, r4, #16
    af64:	2100      	movs	r1, #0
    af66:	f7ff fe9c 	bl	aca2 <z_find_first_thread_to_unpend>
	if (thread != NULL) {
    af6a:	4604      	mov	r4, r0
    af6c:	b1a8      	cbz	r0, af9a <z_impl_k_timer_stop+0x4c>
		z_unpend_thread_no_timeout(thread);
    af6e:	f7ff fea8 	bl	acc2 <z_unpend_thread_no_timeout>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    af72:	7b63      	ldrb	r3, [r4, #13]
    af74:	06db      	lsls	r3, r3, #27
    af76:	d104      	bne.n	af82 <z_impl_k_timer_stop+0x34>
	if (z_is_thread_ready(thread)) {
    af78:	69a3      	ldr	r3, [r4, #24]
    af7a:	b913      	cbnz	r3, af82 <z_impl_k_timer_stop+0x34>
		z_add_thread_to_ready_q(thread);
    af7c:	4620      	mov	r0, r4
    af7e:	f7fb feed 	bl	6d5c <z_add_thread_to_ready_q>
	__asm__ volatile(
    af82:	f04f 0320 	mov.w	r3, #32
    af86:	f3ef 8011 	mrs	r0, BASEPRI
    af8a:	f383 8811 	msr	BASEPRI, r3
    af8e:	f3bf 8f6f 	isb	sy

	if (pending_thread != NULL) {
		z_ready_thread(pending_thread);
		z_reschedule_unlocked();
	}
}
    af92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
    af96:	f7ff beb8 	b.w	ad0a <z_reschedule_irqlock>
    af9a:	bd10      	pop	{r4, pc}

0000af9c <_OffsetAbsSyms>:
					    sizeof(struct _preempt_float));
#else
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF, sizeof(struct k_thread));
#endif

GEN_ABS_SYM_END
    af9c:	4770      	bx	lr
