
zephyr.elf:     file format elf32-littlearm


Disassembly of section text:

00000000 <_vector_table>:

	return fd_entry->obj;
}

int z_reserve_fd(void)
{
   0:	2000c580 	.word	0x2000c580
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&mutex, *(uintptr_t *)&timeout, K_SYSCALL_K_MUTEX_LOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_lock(mutex, timeout);
   4:	00006d75 	.word	0x00006d75
   8:	00021ea1 	.word	0x00021ea1
		if (fdtable[fd].obj == NULL) {
   c:	00006c49 	.word	0x00006c49
  10:	00006c49 	.word	0x00006c49
  14:	00006c49 	.word	0x00006c49
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
  18:	00006c49 	.word	0x00006c49
	errno = ENFILE;
  1c:	00006c49 	.word	0x00006c49
  20:	00006c49 	.word	0x00006c49
	return -1;
  24:	00006c49 	.word	0x00006c49
		arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_mutex_unlock(mutex);
  28:	00006c49 	.word	0x00006c49
  2c:	00006ae1 	.word	0x00006ae1
	}

	k_mutex_unlock(&fdtable_lock);

	return fd;
}
  30:	00006c49 	.word	0x00006c49
		fdtable[fd].obj = FD_OBJ_RESERVED;
  34:	00006c49 	.word	0x00006c49
  38:	00006a8d 	.word	0x00006a8d
  3c:	00021e83 	.word	0x00021e83

00000040 <_irq_vector_table>:
  40:	00006d35 000244e5 00006d35 00006d35     5m...D..5m..5m..
		sys_pm_notify_power_state_exit(pm_state);
		_sys_pm_power_state_exit_post_ops(pm_state);
	}

	return pm_state;
}
  50:	00006d35 00006d35 00006d35 00006d35     5m..5m..5m..5m..
  60:	00006d35 00006d35 00006d35 00006d35     5m..5m..5m..5m..
  70:	00006d35 00006d35 00006d35 00006d35     5m..5m..5m..5m..
  80:	00006d35 00006d35 00006d35 00006d35     5m..5m..5m..5m..
  90:	00006d35 00006d35 00006d35 00006d35     5m..5m..5m..5m..
  a0:	00006d35 00006d35 00006d35 00006d35     5m..5m..5m..5m..
  b0:	00006d35 00006d35 00006d35 00006d35     5m..5m..5m..5m..
  c0:	00006d35 00006d35 00006d35 00006d35     5m..5m..5m..5m..
  d0:	00006d35 00006d35 00006d35              5m..5m..5m..

Disassembly of section _TEXT_SECTION_NAME_2:

000000e0 <memchr>:
      e0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
      e4:	2a10      	cmp	r2, #16
      e6:	db2b      	blt.n	140 <CONFIG_IDLE_STACK_SIZE>
      e8:	f010 0f07 	tst.w	r0, #7
      ec:	d008      	beq.n	100 <CONFIG_KOBJECT_TEXT_AREA>
      ee:	f810 3b01 	ldrb.w	r3, [r0], #1
      f2:	3a01      	subs	r2, #1
      f4:	428b      	cmp	r3, r1
      f6:	d02d      	beq.n	154 <CONFIG_IDLE_STACK_SIZE+0x14>
      f8:	f010 0f07 	tst.w	r0, #7
      fc:	b342      	cbz	r2, 150 <CONFIG_IDLE_STACK_SIZE+0x10>
      fe:	d1f6      	bne.n	ee <memchr+0xe>
     100:	b4f0      	push	{r4, r5, r6, r7}
     102:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
     106:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
     10a:	f022 0407 	bic.w	r4, r2, #7
     10e:	f07f 0700 	mvns.w	r7, #0
     112:	2300      	movs	r3, #0
     114:	e8f0 5602 	ldrd	r5, r6, [r0], #8
     118:	3c08      	subs	r4, #8
     11a:	ea85 0501 	eor.w	r5, r5, r1
     11e:	ea86 0601 	eor.w	r6, r6, r1
     122:	fa85 f547 	uadd8	r5, r5, r7
     126:	faa3 f587 	sel	r5, r3, r7
     12a:	fa86 f647 	uadd8	r6, r6, r7
     12e:	faa5 f687 	sel	r6, r5, r7
     132:	b98e      	cbnz	r6, 158 <CONFIG_IDLE_STACK_SIZE+0x18>
     134:	d1ee      	bne.n	114 <CONFIG_KOBJECT_TEXT_AREA+0x14>
     136:	bcf0      	pop	{r4, r5, r6, r7}
     138:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     13c:	f002 0207 	and.w	r2, r2, #7
     140:	b132      	cbz	r2, 150 <CONFIG_IDLE_STACK_SIZE+0x10>
     142:	f810 3b01 	ldrb.w	r3, [r0], #1
     146:	3a01      	subs	r2, #1
     148:	ea83 0301 	eor.w	r3, r3, r1
     14c:	b113      	cbz	r3, 154 <CONFIG_IDLE_STACK_SIZE+0x14>
     14e:	d1f8      	bne.n	142 <CONFIG_IDLE_STACK_SIZE+0x2>
     150:	2000      	movs	r0, #0
     152:	4770      	bx	lr
     154:	3801      	subs	r0, #1
     156:	4770      	bx	lr
     158:	2d00      	cmp	r5, #0
     15a:	bf06      	itte	eq
     15c:	4635      	moveq	r5, r6
     15e:	3803      	subeq	r0, #3
     160:	3807      	subne	r0, #7
     162:	f015 0f01 	tst.w	r5, #1
     166:	d107      	bne.n	178 <CONFIG_IDLE_STACK_SIZE+0x38>
     168:	3001      	adds	r0, #1
     16a:	f415 7f80 	tst.w	r5, #256	; 0x100
     16e:	bf02      	ittt	eq
     170:	3001      	addeq	r0, #1
     172:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
     176:	3001      	addeq	r0, #1
     178:	bcf0      	pop	{r4, r5, r6, r7}
     17a:	3801      	subs	r0, #1
     17c:	4770      	bx	lr
     17e:	bf00      	nop

00000180 <__aeabi_uldivmod>:
     180:	b953      	cbnz	r3, 198 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x8>
     182:	b94a      	cbnz	r2, 198 <CONFIG_LVGL_INPUT_LONG_PRESS_TIME+0x8>
     184:	2900      	cmp	r1, #0
     186:	bf08      	it	eq
     188:	2800      	cmpeq	r0, #0
     18a:	bf1c      	itt	ne
     18c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
     190:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
     194:	f000 b80c 	b.w	1b0 <__aeabi_idiv0>
     198:	f1ad 0c08 	sub.w	ip, sp, #8
     19c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     1a0:	f001 fbbc 	bl	191c <__udivmoddi4>
     1a4:	f8dd e004 	ldr.w	lr, [sp, #4]
     1a8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     1ac:	b004      	add	sp, #16
     1ae:	4770      	bx	lr

000001b0 <__aeabi_idiv0>:
     1b0:	4770      	bx	lr
     1b2:	bf00      	nop

000001b4 <__assert_func>:
     1b4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
     1b6:	461c      	mov	r4, r3
     1b8:	4b09      	ldr	r3, [pc, #36]	; (1e0 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x20>)
     1ba:	681b      	ldr	r3, [r3, #0]
     1bc:	4605      	mov	r5, r0
     1be:	68d8      	ldr	r0, [r3, #12]
     1c0:	b152      	cbz	r2, 1d8 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x18>
     1c2:	4b08      	ldr	r3, [pc, #32]	; (1e4 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x24>)
     1c4:	9100      	str	r1, [sp, #0]
     1c6:	e9cd 3201 	strd	r3, r2, [sp, #4]
     1ca:	4907      	ldr	r1, [pc, #28]	; (1e8 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x28>)
     1cc:	462b      	mov	r3, r5
     1ce:	4622      	mov	r2, r4
     1d0:	f000 f821 	bl	216 <fiprintf>
     1d4:	f001 fd95 	bl	1d02 <abort>
     1d8:	4b04      	ldr	r3, [pc, #16]	; (1ec <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x2c>)
     1da:	461a      	mov	r2, r3
     1dc:	e7f2      	b.n	1c4 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x4>
     1de:	bf00      	nop
     1e0:	2000e248 	.word	0x2000e248
     1e4:	0006d94d 	.word	0x0006d94d
     1e8:	0006d95a 	.word	0x0006d95a
     1ec:	000620f5 	.word	0x000620f5

000001f0 <__assert>:
     1f0:	b508      	push	{r3, lr}
     1f2:	4613      	mov	r3, r2
     1f4:	2200      	movs	r2, #0
     1f6:	f7ff ffdd 	bl	1b4 <__assert_func>
     1fa:	bf00      	nop

000001fc <_fiprintf_r>:
     1fc:	b40c      	push	{r2, r3}
     1fe:	b507      	push	{r0, r1, r2, lr}
     200:	ab04      	add	r3, sp, #16
     202:	f853 2b04 	ldr.w	r2, [r3], #4
     206:	9301      	str	r3, [sp, #4]
     208:	f000 f8f0 	bl	3ec <_vfiprintf_r>
     20c:	b003      	add	sp, #12
     20e:	f85d eb04 	ldr.w	lr, [sp], #4
     212:	b002      	add	sp, #8
     214:	4770      	bx	lr

00000216 <fiprintf>:
     216:	b40e      	push	{r1, r2, r3}
     218:	b503      	push	{r0, r1, lr}
     21a:	4601      	mov	r1, r0
     21c:	ab03      	add	r3, sp, #12
     21e:	4806      	ldr	r0, [pc, #24]	; (238 <fiprintf+0x22>)
     220:	f853 2b04 	ldr.w	r2, [r3], #4
     224:	6800      	ldr	r0, [r0, #0]
     226:	9301      	str	r3, [sp, #4]
     228:	f000 f8e0 	bl	3ec <_vfiprintf_r>
     22c:	b002      	add	sp, #8
     22e:	f85d eb04 	ldr.w	lr, [sp], #4
     232:	b003      	add	sp, #12
     234:	4770      	bx	lr
     236:	bf00      	nop
     238:	2000e248 	.word	0x2000e248

0000023c <_free_r>:
     23c:	b538      	push	{r3, r4, r5, lr}
     23e:	4605      	mov	r5, r0
     240:	2900      	cmp	r1, #0
     242:	d045      	beq.n	2d0 <CONFIG_BT_HCI_TX_STACK_SIZE+0x50>
     244:	f851 3c04 	ldr.w	r3, [r1, #-4]
     248:	1f0c      	subs	r4, r1, #4
     24a:	2b00      	cmp	r3, #0
     24c:	bfb8      	it	lt
     24e:	18e4      	addlt	r4, r4, r3
     250:	f001 fdb2 	bl	1db8 <__malloc_lock>
     254:	4a1f      	ldr	r2, [pc, #124]	; (2d4 <CONFIG_BT_HCI_TX_STACK_SIZE+0x54>)
     256:	6813      	ldr	r3, [r2, #0]
     258:	4610      	mov	r0, r2
     25a:	b933      	cbnz	r3, 26a <_free_r+0x2e>
     25c:	6063      	str	r3, [r4, #4]
     25e:	6014      	str	r4, [r2, #0]
     260:	4628      	mov	r0, r5
     262:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     266:	f001 bda8 	b.w	1dba <__malloc_unlock>
     26a:	42a3      	cmp	r3, r4
     26c:	d90c      	bls.n	288 <CONFIG_BT_HCI_TX_STACK_SIZE+0x8>
     26e:	6821      	ldr	r1, [r4, #0]
     270:	1862      	adds	r2, r4, r1
     272:	4293      	cmp	r3, r2
     274:	bf04      	itt	eq
     276:	681a      	ldreq	r2, [r3, #0]
     278:	685b      	ldreq	r3, [r3, #4]
     27a:	6063      	str	r3, [r4, #4]
     27c:	bf04      	itt	eq
     27e:	1852      	addeq	r2, r2, r1
     280:	6022      	streq	r2, [r4, #0]
     282:	6004      	str	r4, [r0, #0]
     284:	e7ec      	b.n	260 <_free_r+0x24>
     286:	4613      	mov	r3, r2
     288:	685a      	ldr	r2, [r3, #4]
     28a:	b10a      	cbz	r2, 290 <CONFIG_BT_HCI_TX_STACK_SIZE+0x10>
     28c:	42a2      	cmp	r2, r4
     28e:	d9fa      	bls.n	286 <CONFIG_BT_HCI_TX_STACK_SIZE+0x6>
     290:	6819      	ldr	r1, [r3, #0]
     292:	1858      	adds	r0, r3, r1
     294:	42a0      	cmp	r0, r4
     296:	d10b      	bne.n	2b0 <CONFIG_BT_HCI_TX_STACK_SIZE+0x30>
     298:	6820      	ldr	r0, [r4, #0]
     29a:	4401      	add	r1, r0
     29c:	1858      	adds	r0, r3, r1
     29e:	4282      	cmp	r2, r0
     2a0:	6019      	str	r1, [r3, #0]
     2a2:	d1dd      	bne.n	260 <_free_r+0x24>
     2a4:	6810      	ldr	r0, [r2, #0]
     2a6:	6852      	ldr	r2, [r2, #4]
     2a8:	605a      	str	r2, [r3, #4]
     2aa:	4401      	add	r1, r0
     2ac:	6019      	str	r1, [r3, #0]
     2ae:	e7d7      	b.n	260 <_free_r+0x24>
     2b0:	d902      	bls.n	2b8 <CONFIG_BT_HCI_TX_STACK_SIZE+0x38>
     2b2:	230c      	movs	r3, #12
     2b4:	602b      	str	r3, [r5, #0]
     2b6:	e7d3      	b.n	260 <_free_r+0x24>
     2b8:	6820      	ldr	r0, [r4, #0]
     2ba:	1821      	adds	r1, r4, r0
     2bc:	428a      	cmp	r2, r1
     2be:	bf04      	itt	eq
     2c0:	6811      	ldreq	r1, [r2, #0]
     2c2:	6852      	ldreq	r2, [r2, #4]
     2c4:	6062      	str	r2, [r4, #4]
     2c6:	bf04      	itt	eq
     2c8:	1809      	addeq	r1, r1, r0
     2ca:	6021      	streq	r1, [r4, #0]
     2cc:	605c      	str	r4, [r3, #4]
     2ce:	e7c7      	b.n	260 <_free_r+0x24>
     2d0:	bd38      	pop	{r3, r4, r5, pc}
     2d2:	bf00      	nop
     2d4:	20000000 	.word	0x20000000

000002d8 <_malloc_r>:
     2d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     2da:	1cce      	adds	r6, r1, #3
     2dc:	f026 0603 	bic.w	r6, r6, #3
     2e0:	3608      	adds	r6, #8
     2e2:	2e0c      	cmp	r6, #12
     2e4:	bf38      	it	cc
     2e6:	260c      	movcc	r6, #12
     2e8:	2e00      	cmp	r6, #0
     2ea:	4607      	mov	r7, r0
     2ec:	db01      	blt.n	2f2 <_malloc_r+0x1a>
     2ee:	42b1      	cmp	r1, r6
     2f0:	d903      	bls.n	2fa <_malloc_r+0x22>
     2f2:	230c      	movs	r3, #12
     2f4:	603b      	str	r3, [r7, #0]
     2f6:	2000      	movs	r0, #0
     2f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     2fa:	4d21      	ldr	r5, [pc, #132]	; (380 <CONFIG_BT_DEVICE_APPEARANCE+0x3f>)
     2fc:	f001 fd5c 	bl	1db8 <__malloc_lock>
     300:	682a      	ldr	r2, [r5, #0]
     302:	4614      	mov	r4, r2
     304:	b994      	cbnz	r4, 32c <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x2c>
     306:	686b      	ldr	r3, [r5, #4]
     308:	b923      	cbnz	r3, 314 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x14>
     30a:	4621      	mov	r1, r4
     30c:	4638      	mov	r0, r7
     30e:	f000 faf9 	bl	904 <_sbrk_r>
     312:	6068      	str	r0, [r5, #4]
     314:	4631      	mov	r1, r6
     316:	4638      	mov	r0, r7
     318:	f000 faf4 	bl	904 <_sbrk_r>
     31c:	1c43      	adds	r3, r0, #1
     31e:	d123      	bne.n	368 <CONFIG_BT_DEVICE_APPEARANCE+0x27>
     320:	230c      	movs	r3, #12
     322:	603b      	str	r3, [r7, #0]
     324:	4638      	mov	r0, r7
     326:	f001 fd48 	bl	1dba <__malloc_unlock>
     32a:	e7e4      	b.n	2f6 <_malloc_r+0x1e>
     32c:	6823      	ldr	r3, [r4, #0]
     32e:	1b9b      	subs	r3, r3, r6
     330:	d417      	bmi.n	362 <CONFIG_BT_DEVICE_APPEARANCE+0x21>
     332:	2b0b      	cmp	r3, #11
     334:	d903      	bls.n	33e <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x3e>
     336:	6023      	str	r3, [r4, #0]
     338:	441c      	add	r4, r3
     33a:	6026      	str	r6, [r4, #0]
     33c:	e004      	b.n	348 <CONFIG_BT_DEVICE_APPEARANCE+0x7>
     33e:	6863      	ldr	r3, [r4, #4]
     340:	42a2      	cmp	r2, r4
     342:	bf0c      	ite	eq
     344:	602b      	streq	r3, [r5, #0]
     346:	6053      	strne	r3, [r2, #4]
     348:	4638      	mov	r0, r7
     34a:	f001 fd36 	bl	1dba <__malloc_unlock>
     34e:	f104 000b 	add.w	r0, r4, #11
     352:	1d23      	adds	r3, r4, #4
     354:	f020 0007 	bic.w	r0, r0, #7
     358:	1ac2      	subs	r2, r0, r3
     35a:	d0cd      	beq.n	2f8 <_malloc_r+0x20>
     35c:	1a1b      	subs	r3, r3, r0
     35e:	50a3      	str	r3, [r4, r2]
     360:	e7ca      	b.n	2f8 <_malloc_r+0x20>
     362:	4622      	mov	r2, r4
     364:	6864      	ldr	r4, [r4, #4]
     366:	e7cd      	b.n	304 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x4>
     368:	1cc4      	adds	r4, r0, #3
     36a:	f024 0403 	bic.w	r4, r4, #3
     36e:	42a0      	cmp	r0, r4
     370:	d0e3      	beq.n	33a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x3a>
     372:	1a21      	subs	r1, r4, r0
     374:	4638      	mov	r0, r7
     376:	f000 fac5 	bl	904 <_sbrk_r>
     37a:	3001      	adds	r0, #1
     37c:	d1dd      	bne.n	33a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x3a>
     37e:	e7cf      	b.n	320 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x20>
     380:	20000000 	.word	0x20000000

00000384 <__sfputc_r>:
     384:	6893      	ldr	r3, [r2, #8]
     386:	3b01      	subs	r3, #1
     388:	2b00      	cmp	r3, #0
     38a:	b410      	push	{r4}
     38c:	6093      	str	r3, [r2, #8]
     38e:	da07      	bge.n	3a0 <__sfputc_r+0x1c>
     390:	6994      	ldr	r4, [r2, #24]
     392:	42a3      	cmp	r3, r4
     394:	db01      	blt.n	39a <__sfputc_r+0x16>
     396:	290a      	cmp	r1, #10
     398:	d102      	bne.n	3a0 <__sfputc_r+0x1c>
     39a:	bc10      	pop	{r4}
     39c:	f000 bc08 	b.w	bb0 <__swbuf_r>
     3a0:	6813      	ldr	r3, [r2, #0]
     3a2:	1c58      	adds	r0, r3, #1
     3a4:	6010      	str	r0, [r2, #0]
     3a6:	7019      	strb	r1, [r3, #0]
     3a8:	4608      	mov	r0, r1
     3aa:	bc10      	pop	{r4}
     3ac:	4770      	bx	lr

000003ae <__sfputs_r>:
     3ae:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     3b0:	4606      	mov	r6, r0
     3b2:	460f      	mov	r7, r1
     3b4:	4614      	mov	r4, r2
     3b6:	18d5      	adds	r5, r2, r3
     3b8:	42ac      	cmp	r4, r5
     3ba:	d101      	bne.n	3c0 <__sfputs_r+0x12>
     3bc:	2000      	movs	r0, #0
     3be:	e007      	b.n	3d0 <__sfputs_r+0x22>
     3c0:	463a      	mov	r2, r7
     3c2:	f814 1b01 	ldrb.w	r1, [r4], #1
     3c6:	4630      	mov	r0, r6
     3c8:	f7ff ffdc 	bl	384 <__sfputc_r>
     3cc:	1c43      	adds	r3, r0, #1
     3ce:	d1f3      	bne.n	3b8 <__sfputs_r+0xa>
     3d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000003d2 <__sprint_r>:
     3d2:	b538      	push	{r3, r4, r5, lr}
     3d4:	6893      	ldr	r3, [r2, #8]
     3d6:	4614      	mov	r4, r2
     3d8:	2500      	movs	r5, #0
     3da:	b913      	cbnz	r3, 3e2 <__sprint_r+0x10>
     3dc:	6053      	str	r3, [r2, #4]
     3de:	4618      	mov	r0, r3
     3e0:	bd38      	pop	{r3, r4, r5, pc}
     3e2:	f000 fdfd 	bl	fe0 <__sfvwrite_r>
     3e6:	e9c4 5501 	strd	r5, r5, [r4, #4]
     3ea:	e7f9      	b.n	3e0 <__sprint_r+0xe>

000003ec <_vfiprintf_r>:
     3ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     3f0:	460e      	mov	r6, r1
     3f2:	b09d      	sub	sp, #116	; 0x74
     3f4:	4614      	mov	r4, r2
     3f6:	461d      	mov	r5, r3
     3f8:	4607      	mov	r7, r0
     3fa:	b118      	cbz	r0, 404 <CONFIG_LOG_BUFFER_SIZE+0x4>
     3fc:	6b83      	ldr	r3, [r0, #56]	; 0x38
     3fe:	b90b      	cbnz	r3, 404 <CONFIG_LOG_BUFFER_SIZE+0x4>
     400:	f000 fd90 	bl	f24 <__sinit>
     404:	89b3      	ldrh	r3, [r6, #12]
     406:	0718      	lsls	r0, r3, #28
     408:	d556      	bpl.n	4b8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x6c>
     40a:	6933      	ldr	r3, [r6, #16]
     40c:	2b00      	cmp	r3, #0
     40e:	d053      	beq.n	4b8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x6c>
     410:	2300      	movs	r3, #0
     412:	9309      	str	r3, [sp, #36]	; 0x24
     414:	2320      	movs	r3, #32
     416:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
     41a:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 5c8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x17c>
     41e:	9503      	str	r5, [sp, #12]
     420:	2330      	movs	r3, #48	; 0x30
     422:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
     426:	f04f 0a01 	mov.w	sl, #1
     42a:	4623      	mov	r3, r4
     42c:	461d      	mov	r5, r3
     42e:	f813 2b01 	ldrb.w	r2, [r3], #1
     432:	b10a      	cbz	r2, 438 <CONFIG_LOG_BUFFER_SIZE+0x38>
     434:	2a25      	cmp	r2, #37	; 0x25
     436:	d1f9      	bne.n	42c <CONFIG_LOG_BUFFER_SIZE+0x2c>
     438:	ebb5 0b04 	subs.w	fp, r5, r4
     43c:	d00b      	beq.n	456 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xa>
     43e:	465b      	mov	r3, fp
     440:	4622      	mov	r2, r4
     442:	4631      	mov	r1, r6
     444:	4638      	mov	r0, r7
     446:	f7ff ffb2 	bl	3ae <__sfputs_r>
     44a:	3001      	adds	r0, #1
     44c:	f000 80ae 	beq.w	5ac <CONFIG_BT_HCI_ECC_STACK_SIZE+0x160>
     450:	9b09      	ldr	r3, [sp, #36]	; 0x24
     452:	445b      	add	r3, fp
     454:	9309      	str	r3, [sp, #36]	; 0x24
     456:	782b      	ldrb	r3, [r5, #0]
     458:	2b00      	cmp	r3, #0
     45a:	f000 80a7 	beq.w	5ac <CONFIG_BT_HCI_ECC_STACK_SIZE+0x160>
     45e:	2300      	movs	r3, #0
     460:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     464:	e9cd 2305 	strd	r2, r3, [sp, #20]
     468:	3501      	adds	r5, #1
     46a:	9304      	str	r3, [sp, #16]
     46c:	9307      	str	r3, [sp, #28]
     46e:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
     472:	931a      	str	r3, [sp, #104]	; 0x68
     474:	462c      	mov	r4, r5
     476:	2205      	movs	r2, #5
     478:	f814 1b01 	ldrb.w	r1, [r4], #1
     47c:	4852      	ldr	r0, [pc, #328]	; (5c8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x17c>)
     47e:	f7ff fe2f 	bl	e0 <memchr>
     482:	9b04      	ldr	r3, [sp, #16]
     484:	bb18      	cbnz	r0, 4ce <CONFIG_BT_HCI_ECC_STACK_SIZE+0x82>
     486:	06d9      	lsls	r1, r3, #27
     488:	bf44      	itt	mi
     48a:	2220      	movmi	r2, #32
     48c:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
     490:	071a      	lsls	r2, r3, #28
     492:	bf44      	itt	mi
     494:	222b      	movmi	r2, #43	; 0x2b
     496:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
     49a:	782a      	ldrb	r2, [r5, #0]
     49c:	2a2a      	cmp	r2, #42	; 0x2a
     49e:	d01e      	beq.n	4de <CONFIG_BT_HCI_ECC_STACK_SIZE+0x92>
     4a0:	9a07      	ldr	r2, [sp, #28]
     4a2:	462c      	mov	r4, r5
     4a4:	2000      	movs	r0, #0
     4a6:	250a      	movs	r5, #10
     4a8:	4621      	mov	r1, r4
     4aa:	f811 3b01 	ldrb.w	r3, [r1], #1
     4ae:	3b30      	subs	r3, #48	; 0x30
     4b0:	2b09      	cmp	r3, #9
     4b2:	d956      	bls.n	562 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x116>
     4b4:	b9c8      	cbnz	r0, 4ea <CONFIG_BT_HCI_ECC_STACK_SIZE+0x9e>
     4b6:	e01f      	b.n	4f8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xac>
     4b8:	4631      	mov	r1, r6
     4ba:	4638      	mov	r0, r7
     4bc:	f000 fbbe 	bl	c3c <__swsetup_r>
     4c0:	2800      	cmp	r0, #0
     4c2:	d0a5      	beq.n	410 <CONFIG_LOG_BUFFER_SIZE+0x10>
     4c4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     4c8:	b01d      	add	sp, #116	; 0x74
     4ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     4ce:	eba0 0009 	sub.w	r0, r0, r9
     4d2:	fa0a f000 	lsl.w	r0, sl, r0
     4d6:	4318      	orrs	r0, r3
     4d8:	9004      	str	r0, [sp, #16]
     4da:	4625      	mov	r5, r4
     4dc:	e7ca      	b.n	474 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x28>
     4de:	9a03      	ldr	r2, [sp, #12]
     4e0:	1d11      	adds	r1, r2, #4
     4e2:	6812      	ldr	r2, [r2, #0]
     4e4:	9103      	str	r1, [sp, #12]
     4e6:	2a00      	cmp	r2, #0
     4e8:	db01      	blt.n	4ee <CONFIG_BT_HCI_ECC_STACK_SIZE+0xa2>
     4ea:	9207      	str	r2, [sp, #28]
     4ec:	e004      	b.n	4f8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xac>
     4ee:	4252      	negs	r2, r2
     4f0:	f043 0302 	orr.w	r3, r3, #2
     4f4:	9207      	str	r2, [sp, #28]
     4f6:	9304      	str	r3, [sp, #16]
     4f8:	7823      	ldrb	r3, [r4, #0]
     4fa:	2b2e      	cmp	r3, #46	; 0x2e
     4fc:	d10c      	bne.n	518 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xcc>
     4fe:	7863      	ldrb	r3, [r4, #1]
     500:	2b2a      	cmp	r3, #42	; 0x2a
     502:	d133      	bne.n	56c <CONFIG_BT_HCI_ECC_STACK_SIZE+0x120>
     504:	9b03      	ldr	r3, [sp, #12]
     506:	1d1a      	adds	r2, r3, #4
     508:	681b      	ldr	r3, [r3, #0]
     50a:	9203      	str	r2, [sp, #12]
     50c:	2b00      	cmp	r3, #0
     50e:	bfb8      	it	lt
     510:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
     514:	3402      	adds	r4, #2
     516:	9305      	str	r3, [sp, #20]
     518:	4d2c      	ldr	r5, [pc, #176]	; (5cc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x180>)
     51a:	7821      	ldrb	r1, [r4, #0]
     51c:	2203      	movs	r2, #3
     51e:	4628      	mov	r0, r5
     520:	f7ff fdde 	bl	e0 <memchr>
     524:	b138      	cbz	r0, 536 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xea>
     526:	2340      	movs	r3, #64	; 0x40
     528:	1b40      	subs	r0, r0, r5
     52a:	fa03 f000 	lsl.w	r0, r3, r0
     52e:	9b04      	ldr	r3, [sp, #16]
     530:	4303      	orrs	r3, r0
     532:	3401      	adds	r4, #1
     534:	9304      	str	r3, [sp, #16]
     536:	f814 1b01 	ldrb.w	r1, [r4], #1
     53a:	4825      	ldr	r0, [pc, #148]	; (5d0 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x184>)
     53c:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
     540:	2206      	movs	r2, #6
     542:	f7ff fdcd 	bl	e0 <memchr>
     546:	2800      	cmp	r0, #0
     548:	d035      	beq.n	5b6 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x16a>
     54a:	4b22      	ldr	r3, [pc, #136]	; (5d4 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x188>)
     54c:	bb13      	cbnz	r3, 594 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x148>
     54e:	9b03      	ldr	r3, [sp, #12]
     550:	3307      	adds	r3, #7
     552:	f023 0307 	bic.w	r3, r3, #7
     556:	3308      	adds	r3, #8
     558:	9303      	str	r3, [sp, #12]
     55a:	9b09      	ldr	r3, [sp, #36]	; 0x24
     55c:	4443      	add	r3, r8
     55e:	9309      	str	r3, [sp, #36]	; 0x24
     560:	e763      	b.n	42a <CONFIG_LOG_BUFFER_SIZE+0x2a>
     562:	fb05 3202 	mla	r2, r5, r2, r3
     566:	2001      	movs	r0, #1
     568:	460c      	mov	r4, r1
     56a:	e79d      	b.n	4a8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x5c>
     56c:	2300      	movs	r3, #0
     56e:	3401      	adds	r4, #1
     570:	9305      	str	r3, [sp, #20]
     572:	4619      	mov	r1, r3
     574:	250a      	movs	r5, #10
     576:	4620      	mov	r0, r4
     578:	f810 2b01 	ldrb.w	r2, [r0], #1
     57c:	3a30      	subs	r2, #48	; 0x30
     57e:	2a09      	cmp	r2, #9
     580:	d903      	bls.n	58a <CONFIG_BT_HCI_ECC_STACK_SIZE+0x13e>
     582:	2b00      	cmp	r3, #0
     584:	d0c8      	beq.n	518 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xcc>
     586:	9105      	str	r1, [sp, #20]
     588:	e7c6      	b.n	518 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xcc>
     58a:	fb05 2101 	mla	r1, r5, r1, r2
     58e:	2301      	movs	r3, #1
     590:	4604      	mov	r4, r0
     592:	e7f0      	b.n	576 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x12a>
     594:	ab03      	add	r3, sp, #12
     596:	9300      	str	r3, [sp, #0]
     598:	4632      	mov	r2, r6
     59a:	4b0f      	ldr	r3, [pc, #60]	; (5d8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x18c>)
     59c:	a904      	add	r1, sp, #16
     59e:	4638      	mov	r0, r7
     5a0:	f3af 8000 	nop.w
     5a4:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
     5a8:	4680      	mov	r8, r0
     5aa:	d1d6      	bne.n	55a <CONFIG_BT_HCI_ECC_STACK_SIZE+0x10e>
     5ac:	89b3      	ldrh	r3, [r6, #12]
     5ae:	065b      	lsls	r3, r3, #25
     5b0:	d488      	bmi.n	4c4 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x78>
     5b2:	9809      	ldr	r0, [sp, #36]	; 0x24
     5b4:	e788      	b.n	4c8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x7c>
     5b6:	ab03      	add	r3, sp, #12
     5b8:	9300      	str	r3, [sp, #0]
     5ba:	4632      	mov	r2, r6
     5bc:	4b06      	ldr	r3, [pc, #24]	; (5d8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x18c>)
     5be:	a904      	add	r1, sp, #16
     5c0:	4638      	mov	r0, r7
     5c2:	f000 f88a 	bl	6da <_printf_i>
     5c6:	e7ed      	b.n	5a4 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x158>
     5c8:	0006d989 	.word	0x0006d989
     5cc:	0006d98f 	.word	0x0006d98f
     5d0:	0006d993 	.word	0x0006d993
     5d4:	00000000 	.word	0x00000000
     5d8:	000003af 	.word	0x000003af

000005dc <vfiprintf>:
     5dc:	4613      	mov	r3, r2
     5de:	460a      	mov	r2, r1
     5e0:	4601      	mov	r1, r0
     5e2:	4802      	ldr	r0, [pc, #8]	; (5ec <CONFIG_BT_CTLR_XTAL_THRESHOLD+0x10>)
     5e4:	6800      	ldr	r0, [r0, #0]
     5e6:	f7ff bf01 	b.w	3ec <_vfiprintf_r>
     5ea:	bf00      	nop
     5ec:	2000e248 	.word	0x2000e248

000005f0 <_printf_common>:
     5f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     5f4:	4691      	mov	r9, r2
     5f6:	461f      	mov	r7, r3
     5f8:	688a      	ldr	r2, [r1, #8]
     5fa:	690b      	ldr	r3, [r1, #16]
     5fc:	f8dd 8020 	ldr.w	r8, [sp, #32]
     600:	4293      	cmp	r3, r2
     602:	bfb8      	it	lt
     604:	4613      	movlt	r3, r2
     606:	f8c9 3000 	str.w	r3, [r9]
     60a:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
     60e:	4606      	mov	r6, r0
     610:	460c      	mov	r4, r1
     612:	b112      	cbz	r2, 61a <CONFIG_BT_COMPANY_ID+0x29>
     614:	3301      	adds	r3, #1
     616:	f8c9 3000 	str.w	r3, [r9]
     61a:	6823      	ldr	r3, [r4, #0]
     61c:	0699      	lsls	r1, r3, #26
     61e:	bf42      	ittt	mi
     620:	f8d9 3000 	ldrmi.w	r3, [r9]
     624:	3302      	addmi	r3, #2
     626:	f8c9 3000 	strmi.w	r3, [r9]
     62a:	6825      	ldr	r5, [r4, #0]
     62c:	f015 0506 	ands.w	r5, r5, #6
     630:	d107      	bne.n	642 <CONFIG_BT_COMPANY_ID+0x51>
     632:	f104 0a19 	add.w	sl, r4, #25
     636:	68e3      	ldr	r3, [r4, #12]
     638:	f8d9 2000 	ldr.w	r2, [r9]
     63c:	1a9b      	subs	r3, r3, r2
     63e:	42ab      	cmp	r3, r5
     640:	dc28      	bgt.n	694 <CONFIG_BT_COMPANY_ID+0xa3>
     642:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
     646:	6822      	ldr	r2, [r4, #0]
     648:	3300      	adds	r3, #0
     64a:	bf18      	it	ne
     64c:	2301      	movne	r3, #1
     64e:	0692      	lsls	r2, r2, #26
     650:	d42d      	bmi.n	6ae <CONFIG_BT_COMPANY_ID+0xbd>
     652:	f104 0243 	add.w	r2, r4, #67	; 0x43
     656:	4639      	mov	r1, r7
     658:	4630      	mov	r0, r6
     65a:	47c0      	blx	r8
     65c:	3001      	adds	r0, #1
     65e:	d020      	beq.n	6a2 <CONFIG_BT_COMPANY_ID+0xb1>
     660:	6823      	ldr	r3, [r4, #0]
     662:	68e5      	ldr	r5, [r4, #12]
     664:	f8d9 2000 	ldr.w	r2, [r9]
     668:	f003 0306 	and.w	r3, r3, #6
     66c:	2b04      	cmp	r3, #4
     66e:	bf08      	it	eq
     670:	1aad      	subeq	r5, r5, r2
     672:	68a3      	ldr	r3, [r4, #8]
     674:	6922      	ldr	r2, [r4, #16]
     676:	bf0c      	ite	eq
     678:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
     67c:	2500      	movne	r5, #0
     67e:	4293      	cmp	r3, r2
     680:	bfc4      	itt	gt
     682:	1a9b      	subgt	r3, r3, r2
     684:	18ed      	addgt	r5, r5, r3
     686:	f04f 0900 	mov.w	r9, #0
     68a:	341a      	adds	r4, #26
     68c:	454d      	cmp	r5, r9
     68e:	d11a      	bne.n	6c6 <CONFIG_BT_COMPANY_ID+0xd5>
     690:	2000      	movs	r0, #0
     692:	e008      	b.n	6a6 <CONFIG_BT_COMPANY_ID+0xb5>
     694:	2301      	movs	r3, #1
     696:	4652      	mov	r2, sl
     698:	4639      	mov	r1, r7
     69a:	4630      	mov	r0, r6
     69c:	47c0      	blx	r8
     69e:	3001      	adds	r0, #1
     6a0:	d103      	bne.n	6aa <CONFIG_BT_COMPANY_ID+0xb9>
     6a2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     6a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     6aa:	3501      	adds	r5, #1
     6ac:	e7c3      	b.n	636 <CONFIG_BT_COMPANY_ID+0x45>
     6ae:	18e1      	adds	r1, r4, r3
     6b0:	1c5a      	adds	r2, r3, #1
     6b2:	2030      	movs	r0, #48	; 0x30
     6b4:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
     6b8:	4422      	add	r2, r4
     6ba:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
     6be:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
     6c2:	3302      	adds	r3, #2
     6c4:	e7c5      	b.n	652 <CONFIG_BT_COMPANY_ID+0x61>
     6c6:	2301      	movs	r3, #1
     6c8:	4622      	mov	r2, r4
     6ca:	4639      	mov	r1, r7
     6cc:	4630      	mov	r0, r6
     6ce:	47c0      	blx	r8
     6d0:	3001      	adds	r0, #1
     6d2:	d0e6      	beq.n	6a2 <CONFIG_BT_COMPANY_ID+0xb1>
     6d4:	f109 0901 	add.w	r9, r9, #1
     6d8:	e7d8      	b.n	68c <CONFIG_BT_COMPANY_ID+0x9b>

000006da <_printf_i>:
     6da:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     6de:	4606      	mov	r6, r0
     6e0:	460c      	mov	r4, r1
     6e2:	f101 0043 	add.w	r0, r1, #67	; 0x43
     6e6:	7e09      	ldrb	r1, [r1, #24]
     6e8:	b085      	sub	sp, #20
     6ea:	296e      	cmp	r1, #110	; 0x6e
     6ec:	4698      	mov	r8, r3
     6ee:	4617      	mov	r7, r2
     6f0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
     6f2:	f000 80ba 	beq.w	86a <CONFIG_ISR_STACK_SIZE+0x6a>
     6f6:	d824      	bhi.n	742 <_printf_i+0x68>
     6f8:	2963      	cmp	r1, #99	; 0x63
     6fa:	d039      	beq.n	770 <_printf_i+0x96>
     6fc:	d80a      	bhi.n	714 <_printf_i+0x3a>
     6fe:	2900      	cmp	r1, #0
     700:	f000 80c3 	beq.w	88a <CONFIG_ISR_STACK_SIZE+0x8a>
     704:	2958      	cmp	r1, #88	; 0x58
     706:	f000 8091 	beq.w	82c <CONFIG_ISR_STACK_SIZE+0x2c>
     70a:	f104 0542 	add.w	r5, r4, #66	; 0x42
     70e:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
     712:	e035      	b.n	780 <_printf_i+0xa6>
     714:	2964      	cmp	r1, #100	; 0x64
     716:	d001      	beq.n	71c <_printf_i+0x42>
     718:	2969      	cmp	r1, #105	; 0x69
     71a:	d1f6      	bne.n	70a <_printf_i+0x30>
     71c:	6825      	ldr	r5, [r4, #0]
     71e:	681a      	ldr	r2, [r3, #0]
     720:	f015 0f80 	tst.w	r5, #128	; 0x80
     724:	f102 0104 	add.w	r1, r2, #4
     728:	d02c      	beq.n	784 <_printf_i+0xaa>
     72a:	6812      	ldr	r2, [r2, #0]
     72c:	6019      	str	r1, [r3, #0]
     72e:	2a00      	cmp	r2, #0
     730:	da03      	bge.n	73a <_printf_i+0x60>
     732:	232d      	movs	r3, #45	; 0x2d
     734:	4252      	negs	r2, r2
     736:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
     73a:	f8df c1c0 	ldr.w	ip, [pc, #448]	; 8fc <CONFIG_BT_RX_STACK_SIZE+0x64>
     73e:	230a      	movs	r3, #10
     740:	e03f      	b.n	7c2 <_printf_i+0xe8>
     742:	2973      	cmp	r1, #115	; 0x73
     744:	f000 80a5 	beq.w	892 <CONFIG_ISR_STACK_SIZE+0x92>
     748:	d808      	bhi.n	75c <_printf_i+0x82>
     74a:	296f      	cmp	r1, #111	; 0x6f
     74c:	d021      	beq.n	792 <_printf_i+0xb8>
     74e:	2970      	cmp	r1, #112	; 0x70
     750:	d1db      	bne.n	70a <_printf_i+0x30>
     752:	6822      	ldr	r2, [r4, #0]
     754:	f042 0220 	orr.w	r2, r2, #32
     758:	6022      	str	r2, [r4, #0]
     75a:	e003      	b.n	764 <_printf_i+0x8a>
     75c:	2975      	cmp	r1, #117	; 0x75
     75e:	d018      	beq.n	792 <_printf_i+0xb8>
     760:	2978      	cmp	r1, #120	; 0x78
     762:	d1d2      	bne.n	70a <_printf_i+0x30>
     764:	2278      	movs	r2, #120	; 0x78
     766:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
     76a:	f8df c194 	ldr.w	ip, [pc, #404]	; 900 <CONFIG_BT_RX_STACK_SIZE+0x68>
     76e:	e061      	b.n	834 <CONFIG_ISR_STACK_SIZE+0x34>
     770:	681a      	ldr	r2, [r3, #0]
     772:	1d11      	adds	r1, r2, #4
     774:	6019      	str	r1, [r3, #0]
     776:	6813      	ldr	r3, [r2, #0]
     778:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
     77c:	f104 0542 	add.w	r5, r4, #66	; 0x42
     780:	2301      	movs	r3, #1
     782:	e093      	b.n	8ac <CONFIG_BT_RX_STACK_SIZE+0x14>
     784:	6812      	ldr	r2, [r2, #0]
     786:	6019      	str	r1, [r3, #0]
     788:	f015 0f40 	tst.w	r5, #64	; 0x40
     78c:	bf18      	it	ne
     78e:	b212      	sxthne	r2, r2
     790:	e7cd      	b.n	72e <_printf_i+0x54>
     792:	f8d4 c000 	ldr.w	ip, [r4]
     796:	681a      	ldr	r2, [r3, #0]
     798:	f01c 0f80 	tst.w	ip, #128	; 0x80
     79c:	f102 0504 	add.w	r5, r2, #4
     7a0:	601d      	str	r5, [r3, #0]
     7a2:	d001      	beq.n	7a8 <_printf_i+0xce>
     7a4:	6812      	ldr	r2, [r2, #0]
     7a6:	e003      	b.n	7b0 <_printf_i+0xd6>
     7a8:	f01c 0f40 	tst.w	ip, #64	; 0x40
     7ac:	d0fa      	beq.n	7a4 <_printf_i+0xca>
     7ae:	8812      	ldrh	r2, [r2, #0]
     7b0:	f8df c148 	ldr.w	ip, [pc, #328]	; 8fc <CONFIG_BT_RX_STACK_SIZE+0x64>
     7b4:	296f      	cmp	r1, #111	; 0x6f
     7b6:	bf0c      	ite	eq
     7b8:	2308      	moveq	r3, #8
     7ba:	230a      	movne	r3, #10
     7bc:	2100      	movs	r1, #0
     7be:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
     7c2:	6865      	ldr	r5, [r4, #4]
     7c4:	60a5      	str	r5, [r4, #8]
     7c6:	2d00      	cmp	r5, #0
     7c8:	bfa2      	ittt	ge
     7ca:	6821      	ldrge	r1, [r4, #0]
     7cc:	f021 0104 	bicge.w	r1, r1, #4
     7d0:	6021      	strge	r1, [r4, #0]
     7d2:	b90a      	cbnz	r2, 7d8 <_printf_i+0xfe>
     7d4:	2d00      	cmp	r5, #0
     7d6:	d046      	beq.n	866 <CONFIG_ISR_STACK_SIZE+0x66>
     7d8:	4605      	mov	r5, r0
     7da:	fbb2 f1f3 	udiv	r1, r2, r3
     7de:	fb03 2e11 	mls	lr, r3, r1, r2
     7e2:	4293      	cmp	r3, r2
     7e4:	f81c e00e 	ldrb.w	lr, [ip, lr]
     7e8:	f805 ed01 	strb.w	lr, [r5, #-1]!
     7ec:	d939      	bls.n	862 <CONFIG_ISR_STACK_SIZE+0x62>
     7ee:	2b08      	cmp	r3, #8
     7f0:	d10b      	bne.n	80a <CONFIG_ISR_STACK_SIZE+0xa>
     7f2:	6823      	ldr	r3, [r4, #0]
     7f4:	07da      	lsls	r2, r3, #31
     7f6:	d508      	bpl.n	80a <CONFIG_ISR_STACK_SIZE+0xa>
     7f8:	6923      	ldr	r3, [r4, #16]
     7fa:	6862      	ldr	r2, [r4, #4]
     7fc:	429a      	cmp	r2, r3
     7fe:	bfde      	ittt	le
     800:	2330      	movle	r3, #48	; 0x30
     802:	f805 3c01 	strble.w	r3, [r5, #-1]
     806:	f105 35ff 	addle.w	r5, r5, #4294967295	; 0xffffffff
     80a:	1b40      	subs	r0, r0, r5
     80c:	6120      	str	r0, [r4, #16]
     80e:	f8cd 8000 	str.w	r8, [sp]
     812:	463b      	mov	r3, r7
     814:	aa03      	add	r2, sp, #12
     816:	4621      	mov	r1, r4
     818:	4630      	mov	r0, r6
     81a:	f7ff fee9 	bl	5f0 <_printf_common>
     81e:	3001      	adds	r0, #1
     820:	d149      	bne.n	8b6 <CONFIG_BT_RX_STACK_SIZE+0x1e>
     822:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     826:	b005      	add	sp, #20
     828:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     82c:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 8fc <CONFIG_BT_RX_STACK_SIZE+0x64>
     830:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
     834:	681d      	ldr	r5, [r3, #0]
     836:	6821      	ldr	r1, [r4, #0]
     838:	f855 2b04 	ldr.w	r2, [r5], #4
     83c:	601d      	str	r5, [r3, #0]
     83e:	060d      	lsls	r5, r1, #24
     840:	d50b      	bpl.n	85a <CONFIG_ISR_STACK_SIZE+0x5a>
     842:	07cd      	lsls	r5, r1, #31
     844:	bf44      	itt	mi
     846:	f041 0120 	orrmi.w	r1, r1, #32
     84a:	6021      	strmi	r1, [r4, #0]
     84c:	b91a      	cbnz	r2, 856 <CONFIG_ISR_STACK_SIZE+0x56>
     84e:	6823      	ldr	r3, [r4, #0]
     850:	f023 0320 	bic.w	r3, r3, #32
     854:	6023      	str	r3, [r4, #0]
     856:	2310      	movs	r3, #16
     858:	e7b0      	b.n	7bc <_printf_i+0xe2>
     85a:	064b      	lsls	r3, r1, #25
     85c:	bf48      	it	mi
     85e:	b292      	uxthmi	r2, r2
     860:	e7ef      	b.n	842 <CONFIG_ISR_STACK_SIZE+0x42>
     862:	460a      	mov	r2, r1
     864:	e7b9      	b.n	7da <_printf_i+0x100>
     866:	4605      	mov	r5, r0
     868:	e7c1      	b.n	7ee <_printf_i+0x114>
     86a:	681a      	ldr	r2, [r3, #0]
     86c:	f8d4 c000 	ldr.w	ip, [r4]
     870:	6961      	ldr	r1, [r4, #20]
     872:	1d15      	adds	r5, r2, #4
     874:	601d      	str	r5, [r3, #0]
     876:	f01c 0f80 	tst.w	ip, #128	; 0x80
     87a:	6813      	ldr	r3, [r2, #0]
     87c:	d001      	beq.n	882 <CONFIG_ISR_STACK_SIZE+0x82>
     87e:	6019      	str	r1, [r3, #0]
     880:	e003      	b.n	88a <CONFIG_ISR_STACK_SIZE+0x8a>
     882:	f01c 0f40 	tst.w	ip, #64	; 0x40
     886:	d0fa      	beq.n	87e <CONFIG_ISR_STACK_SIZE+0x7e>
     888:	8019      	strh	r1, [r3, #0]
     88a:	2300      	movs	r3, #0
     88c:	6123      	str	r3, [r4, #16]
     88e:	4605      	mov	r5, r0
     890:	e7bd      	b.n	80e <CONFIG_ISR_STACK_SIZE+0xe>
     892:	681a      	ldr	r2, [r3, #0]
     894:	1d11      	adds	r1, r2, #4
     896:	6019      	str	r1, [r3, #0]
     898:	6815      	ldr	r5, [r2, #0]
     89a:	6862      	ldr	r2, [r4, #4]
     89c:	2100      	movs	r1, #0
     89e:	4628      	mov	r0, r5
     8a0:	f7ff fc1e 	bl	e0 <memchr>
     8a4:	b108      	cbz	r0, 8aa <CONFIG_BT_RX_STACK_SIZE+0x12>
     8a6:	1b40      	subs	r0, r0, r5
     8a8:	6060      	str	r0, [r4, #4]
     8aa:	6863      	ldr	r3, [r4, #4]
     8ac:	6123      	str	r3, [r4, #16]
     8ae:	2300      	movs	r3, #0
     8b0:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
     8b4:	e7ab      	b.n	80e <CONFIG_ISR_STACK_SIZE+0xe>
     8b6:	6923      	ldr	r3, [r4, #16]
     8b8:	462a      	mov	r2, r5
     8ba:	4639      	mov	r1, r7
     8bc:	4630      	mov	r0, r6
     8be:	47c0      	blx	r8
     8c0:	3001      	adds	r0, #1
     8c2:	d0ae      	beq.n	822 <CONFIG_ISR_STACK_SIZE+0x22>
     8c4:	6823      	ldr	r3, [r4, #0]
     8c6:	079b      	lsls	r3, r3, #30
     8c8:	d413      	bmi.n	8f2 <CONFIG_BT_RX_STACK_SIZE+0x5a>
     8ca:	68e0      	ldr	r0, [r4, #12]
     8cc:	9b03      	ldr	r3, [sp, #12]
     8ce:	4298      	cmp	r0, r3
     8d0:	bfb8      	it	lt
     8d2:	4618      	movlt	r0, r3
     8d4:	e7a7      	b.n	826 <CONFIG_ISR_STACK_SIZE+0x26>
     8d6:	2301      	movs	r3, #1
     8d8:	464a      	mov	r2, r9
     8da:	4639      	mov	r1, r7
     8dc:	4630      	mov	r0, r6
     8de:	47c0      	blx	r8
     8e0:	3001      	adds	r0, #1
     8e2:	d09e      	beq.n	822 <CONFIG_ISR_STACK_SIZE+0x22>
     8e4:	3501      	adds	r5, #1
     8e6:	68e3      	ldr	r3, [r4, #12]
     8e8:	9a03      	ldr	r2, [sp, #12]
     8ea:	1a9b      	subs	r3, r3, r2
     8ec:	42ab      	cmp	r3, r5
     8ee:	dcf2      	bgt.n	8d6 <CONFIG_BT_RX_STACK_SIZE+0x3e>
     8f0:	e7eb      	b.n	8ca <CONFIG_BT_RX_STACK_SIZE+0x32>
     8f2:	2500      	movs	r5, #0
     8f4:	f104 0919 	add.w	r9, r4, #25
     8f8:	e7f5      	b.n	8e6 <CONFIG_BT_RX_STACK_SIZE+0x4e>
     8fa:	bf00      	nop
     8fc:	0006d99a 	.word	0x0006d99a
     900:	0006d9ab 	.word	0x0006d9ab

00000904 <_sbrk_r>:
     904:	b538      	push	{r3, r4, r5, lr}
     906:	4c06      	ldr	r4, [pc, #24]	; (920 <_sbrk_r+0x1c>)
     908:	2300      	movs	r3, #0
     90a:	4605      	mov	r5, r0
     90c:	4608      	mov	r0, r1
     90e:	6023      	str	r3, [r4, #0]
     910:	f006 fe2a 	bl	7568 <_sbrk>
     914:	1c43      	adds	r3, r0, #1
     916:	d102      	bne.n	91e <_sbrk_r+0x1a>
     918:	6823      	ldr	r3, [r4, #0]
     91a:	b103      	cbz	r3, 91e <_sbrk_r+0x1a>
     91c:	602b      	str	r3, [r5, #0]
     91e:	bd38      	pop	{r3, r4, r5, pc}
     920:	2000abe8 	.word	0x2000abe8

00000924 <_sniprintf_r>:
     924:	b408      	push	{r3}
     926:	b530      	push	{r4, r5, lr}
     928:	1e14      	subs	r4, r2, #0
     92a:	b09a      	sub	sp, #104	; 0x68
     92c:	4605      	mov	r5, r0
     92e:	da08      	bge.n	942 <_sniprintf_r+0x1e>
     930:	238b      	movs	r3, #139	; 0x8b
     932:	6003      	str	r3, [r0, #0]
     934:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     938:	b01a      	add	sp, #104	; 0x68
     93a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
     93e:	b001      	add	sp, #4
     940:	4770      	bx	lr
     942:	f44f 7302 	mov.w	r3, #520	; 0x208
     946:	f8ad 3010 	strh.w	r3, [sp, #16]
     94a:	bf14      	ite	ne
     94c:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
     950:	4623      	moveq	r3, r4
     952:	9303      	str	r3, [sp, #12]
     954:	9306      	str	r3, [sp, #24]
     956:	f64f 73ff 	movw	r3, #65535	; 0xffff
     95a:	9101      	str	r1, [sp, #4]
     95c:	9105      	str	r1, [sp, #20]
     95e:	f8ad 3012 	strh.w	r3, [sp, #18]
     962:	9a1d      	ldr	r2, [sp, #116]	; 0x74
     964:	ab1e      	add	r3, sp, #120	; 0x78
     966:	a901      	add	r1, sp, #4
     968:	9300      	str	r3, [sp, #0]
     96a:	f000 fdc8 	bl	14fe <_svfiprintf_r>
     96e:	1c43      	adds	r3, r0, #1
     970:	bfbc      	itt	lt
     972:	238b      	movlt	r3, #139	; 0x8b
     974:	602b      	strlt	r3, [r5, #0]
     976:	2c00      	cmp	r4, #0
     978:	d0de      	beq.n	938 <_sniprintf_r+0x14>
     97a:	9b01      	ldr	r3, [sp, #4]
     97c:	2200      	movs	r2, #0
     97e:	701a      	strb	r2, [r3, #0]
     980:	e7da      	b.n	938 <_sniprintf_r+0x14>

00000982 <sniprintf>:
     982:	b40c      	push	{r2, r3}
     984:	b530      	push	{r4, r5, lr}
     986:	4b17      	ldr	r3, [pc, #92]	; (9e4 <sniprintf+0x62>)
     988:	1e0c      	subs	r4, r1, #0
     98a:	b09b      	sub	sp, #108	; 0x6c
     98c:	681d      	ldr	r5, [r3, #0]
     98e:	da08      	bge.n	9a2 <sniprintf+0x20>
     990:	238b      	movs	r3, #139	; 0x8b
     992:	602b      	str	r3, [r5, #0]
     994:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     998:	b01b      	add	sp, #108	; 0x6c
     99a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
     99e:	b002      	add	sp, #8
     9a0:	4770      	bx	lr
     9a2:	f44f 7302 	mov.w	r3, #520	; 0x208
     9a6:	f8ad 3010 	strh.w	r3, [sp, #16]
     9aa:	bf14      	ite	ne
     9ac:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
     9b0:	4623      	moveq	r3, r4
     9b2:	9303      	str	r3, [sp, #12]
     9b4:	9306      	str	r3, [sp, #24]
     9b6:	f64f 73ff 	movw	r3, #65535	; 0xffff
     9ba:	9001      	str	r0, [sp, #4]
     9bc:	9005      	str	r0, [sp, #20]
     9be:	f8ad 3012 	strh.w	r3, [sp, #18]
     9c2:	9a1e      	ldr	r2, [sp, #120]	; 0x78
     9c4:	ab1f      	add	r3, sp, #124	; 0x7c
     9c6:	a901      	add	r1, sp, #4
     9c8:	4628      	mov	r0, r5
     9ca:	9300      	str	r3, [sp, #0]
     9cc:	f000 fd97 	bl	14fe <_svfiprintf_r>
     9d0:	1c43      	adds	r3, r0, #1
     9d2:	bfbc      	itt	lt
     9d4:	238b      	movlt	r3, #139	; 0x8b
     9d6:	602b      	strlt	r3, [r5, #0]
     9d8:	2c00      	cmp	r4, #0
     9da:	d0dd      	beq.n	998 <sniprintf+0x16>
     9dc:	9b01      	ldr	r3, [sp, #4]
     9de:	2200      	movs	r2, #0
     9e0:	701a      	strb	r2, [r3, #0]
     9e2:	e7d9      	b.n	998 <sniprintf+0x16>
     9e4:	2000e248 	.word	0x2000e248

000009e8 <_strtol_l.isra.0>:
     9e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     9ec:	4f39      	ldr	r7, [pc, #228]	; (ad4 <_strtol_l.isra.0+0xec>)
     9ee:	4686      	mov	lr, r0
     9f0:	4608      	mov	r0, r1
     9f2:	4605      	mov	r5, r0
     9f4:	f815 4b01 	ldrb.w	r4, [r5], #1
     9f8:	5de6      	ldrb	r6, [r4, r7]
     9fa:	f016 0608 	ands.w	r6, r6, #8
     9fe:	d134      	bne.n	a6a <_strtol_l.isra.0+0x82>
     a00:	2c2d      	cmp	r4, #45	; 0x2d
     a02:	d134      	bne.n	a6e <_strtol_l.isra.0+0x86>
     a04:	782c      	ldrb	r4, [r5, #0]
     a06:	f04f 0801 	mov.w	r8, #1
     a0a:	1c85      	adds	r5, r0, #2
     a0c:	2b00      	cmp	r3, #0
     a0e:	d05c      	beq.n	aca <_strtol_l.isra.0+0xe2>
     a10:	2b10      	cmp	r3, #16
     a12:	d109      	bne.n	a28 <_strtol_l.isra.0+0x40>
     a14:	2c30      	cmp	r4, #48	; 0x30
     a16:	d107      	bne.n	a28 <_strtol_l.isra.0+0x40>
     a18:	7828      	ldrb	r0, [r5, #0]
     a1a:	f000 00df 	and.w	r0, r0, #223	; 0xdf
     a1e:	2858      	cmp	r0, #88	; 0x58
     a20:	d14e      	bne.n	ac0 <_strtol_l.isra.0+0xd8>
     a22:	786c      	ldrb	r4, [r5, #1]
     a24:	2310      	movs	r3, #16
     a26:	3502      	adds	r5, #2
     a28:	f1b8 0f00 	cmp.w	r8, #0
     a2c:	bf14      	ite	ne
     a2e:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
     a32:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
     a36:	2700      	movs	r7, #0
     a38:	fbbc f9f3 	udiv	r9, ip, r3
     a3c:	4638      	mov	r0, r7
     a3e:	fb03 ca19 	mls	sl, r3, r9, ip
     a42:	f1a4 0630 	sub.w	r6, r4, #48	; 0x30
     a46:	2e09      	cmp	r6, #9
     a48:	d818      	bhi.n	a7c <_strtol_l.isra.0+0x94>
     a4a:	4634      	mov	r4, r6
     a4c:	42a3      	cmp	r3, r4
     a4e:	dd24      	ble.n	a9a <_strtol_l.isra.0+0xb2>
     a50:	1c7e      	adds	r6, r7, #1
     a52:	d007      	beq.n	a64 <_strtol_l.isra.0+0x7c>
     a54:	4581      	cmp	r9, r0
     a56:	d31d      	bcc.n	a94 <_strtol_l.isra.0+0xac>
     a58:	d101      	bne.n	a5e <_strtol_l.isra.0+0x76>
     a5a:	45a2      	cmp	sl, r4
     a5c:	db1a      	blt.n	a94 <_strtol_l.isra.0+0xac>
     a5e:	fb00 4003 	mla	r0, r0, r3, r4
     a62:	2701      	movs	r7, #1
     a64:	f815 4b01 	ldrb.w	r4, [r5], #1
     a68:	e7eb      	b.n	a42 <_strtol_l.isra.0+0x5a>
     a6a:	4628      	mov	r0, r5
     a6c:	e7c1      	b.n	9f2 <_strtol_l.isra.0+0xa>
     a6e:	2c2b      	cmp	r4, #43	; 0x2b
     a70:	bf08      	it	eq
     a72:	782c      	ldrbeq	r4, [r5, #0]
     a74:	46b0      	mov	r8, r6
     a76:	bf08      	it	eq
     a78:	1c85      	addeq	r5, r0, #2
     a7a:	e7c7      	b.n	a0c <_strtol_l.isra.0+0x24>
     a7c:	f1a4 0641 	sub.w	r6, r4, #65	; 0x41
     a80:	2e19      	cmp	r6, #25
     a82:	d801      	bhi.n	a88 <_strtol_l.isra.0+0xa0>
     a84:	3c37      	subs	r4, #55	; 0x37
     a86:	e7e1      	b.n	a4c <_strtol_l.isra.0+0x64>
     a88:	f1a4 0661 	sub.w	r6, r4, #97	; 0x61
     a8c:	2e19      	cmp	r6, #25
     a8e:	d804      	bhi.n	a9a <_strtol_l.isra.0+0xb2>
     a90:	3c57      	subs	r4, #87	; 0x57
     a92:	e7db      	b.n	a4c <_strtol_l.isra.0+0x64>
     a94:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
     a98:	e7e4      	b.n	a64 <_strtol_l.isra.0+0x7c>
     a9a:	1c7b      	adds	r3, r7, #1
     a9c:	d106      	bne.n	aac <_strtol_l.isra.0+0xc4>
     a9e:	2322      	movs	r3, #34	; 0x22
     aa0:	f8ce 3000 	str.w	r3, [lr]
     aa4:	4660      	mov	r0, ip
     aa6:	b942      	cbnz	r2, aba <_strtol_l.isra.0+0xd2>
     aa8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     aac:	f1b8 0f00 	cmp.w	r8, #0
     ab0:	d000      	beq.n	ab4 <_strtol_l.isra.0+0xcc>
     ab2:	4240      	negs	r0, r0
     ab4:	2a00      	cmp	r2, #0
     ab6:	d0f7      	beq.n	aa8 <_strtol_l.isra.0+0xc0>
     ab8:	b107      	cbz	r7, abc <_strtol_l.isra.0+0xd4>
     aba:	1e69      	subs	r1, r5, #1
     abc:	6011      	str	r1, [r2, #0]
     abe:	e7f3      	b.n	aa8 <_strtol_l.isra.0+0xc0>
     ac0:	2430      	movs	r4, #48	; 0x30
     ac2:	2b00      	cmp	r3, #0
     ac4:	d1b0      	bne.n	a28 <_strtol_l.isra.0+0x40>
     ac6:	2308      	movs	r3, #8
     ac8:	e7ae      	b.n	a28 <_strtol_l.isra.0+0x40>
     aca:	2c30      	cmp	r4, #48	; 0x30
     acc:	d0a4      	beq.n	a18 <_strtol_l.isra.0+0x30>
     ace:	230a      	movs	r3, #10
     ad0:	e7aa      	b.n	a28 <_strtol_l.isra.0+0x40>
     ad2:	bf00      	nop
     ad4:	00028779 	.word	0x00028779

00000ad8 <_strtol_r>:
     ad8:	e786      	b.n	9e8 <_strtol_l.isra.0>

00000ada <strtol_l>:
     ada:	4613      	mov	r3, r2
     adc:	460a      	mov	r2, r1
     ade:	4601      	mov	r1, r0
     ae0:	4801      	ldr	r0, [pc, #4]	; (ae8 <strtol_l+0xe>)
     ae2:	6800      	ldr	r0, [r0, #0]
     ae4:	e780      	b.n	9e8 <_strtol_l.isra.0>
     ae6:	bf00      	nop
     ae8:	2000e248 	.word	0x2000e248

00000aec <strtol>:
     aec:	4613      	mov	r3, r2
     aee:	460a      	mov	r2, r1
     af0:	4601      	mov	r1, r0
     af2:	4801      	ldr	r0, [pc, #4]	; (af8 <strtol+0xc>)
     af4:	6800      	ldr	r0, [r0, #0]
     af6:	e777      	b.n	9e8 <_strtol_l.isra.0>
     af8:	2000e248 	.word	0x2000e248

00000afc <_vsniprintf_r>:
     afc:	b530      	push	{r4, r5, lr}
     afe:	1e14      	subs	r4, r2, #0
     b00:	4605      	mov	r5, r0
     b02:	b09b      	sub	sp, #108	; 0x6c
     b04:	4618      	mov	r0, r3
     b06:	da05      	bge.n	b14 <_vsniprintf_r+0x18>
     b08:	238b      	movs	r3, #139	; 0x8b
     b0a:	602b      	str	r3, [r5, #0]
     b0c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     b10:	b01b      	add	sp, #108	; 0x6c
     b12:	bd30      	pop	{r4, r5, pc}
     b14:	f44f 7302 	mov.w	r3, #520	; 0x208
     b18:	f8ad 3010 	strh.w	r3, [sp, #16]
     b1c:	bf14      	ite	ne
     b1e:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
     b22:	4623      	moveq	r3, r4
     b24:	9303      	str	r3, [sp, #12]
     b26:	9306      	str	r3, [sp, #24]
     b28:	f64f 73ff 	movw	r3, #65535	; 0xffff
     b2c:	9101      	str	r1, [sp, #4]
     b2e:	9105      	str	r1, [sp, #20]
     b30:	f8ad 3012 	strh.w	r3, [sp, #18]
     b34:	4602      	mov	r2, r0
     b36:	9b1e      	ldr	r3, [sp, #120]	; 0x78
     b38:	a901      	add	r1, sp, #4
     b3a:	4628      	mov	r0, r5
     b3c:	f000 fcdf 	bl	14fe <_svfiprintf_r>
     b40:	1c43      	adds	r3, r0, #1
     b42:	bfbc      	itt	lt
     b44:	238b      	movlt	r3, #139	; 0x8b
     b46:	602b      	strlt	r3, [r5, #0]
     b48:	2c00      	cmp	r4, #0
     b4a:	d0e1      	beq.n	b10 <_vsniprintf_r+0x14>
     b4c:	9b01      	ldr	r3, [sp, #4]
     b4e:	2200      	movs	r2, #0
     b50:	701a      	strb	r2, [r3, #0]
     b52:	e7dd      	b.n	b10 <_vsniprintf_r+0x14>

00000b54 <vsniprintf>:
     b54:	b507      	push	{r0, r1, r2, lr}
     b56:	9300      	str	r3, [sp, #0]
     b58:	4613      	mov	r3, r2
     b5a:	460a      	mov	r2, r1
     b5c:	4601      	mov	r1, r0
     b5e:	4803      	ldr	r0, [pc, #12]	; (b6c <vsniprintf+0x18>)
     b60:	6800      	ldr	r0, [r0, #0]
     b62:	f7ff ffcb 	bl	afc <_vsniprintf_r>
     b66:	b003      	add	sp, #12
     b68:	f85d fb04 	ldr.w	pc, [sp], #4
     b6c:	2000e248 	.word	0x2000e248

00000b70 <_vsiprintf_r>:
     b70:	b500      	push	{lr}
     b72:	b09b      	sub	sp, #108	; 0x6c
     b74:	9101      	str	r1, [sp, #4]
     b76:	9105      	str	r1, [sp, #20]
     b78:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
     b7c:	9106      	str	r1, [sp, #24]
     b7e:	9103      	str	r1, [sp, #12]
     b80:	4905      	ldr	r1, [pc, #20]	; (b98 <_vsiprintf_r+0x28>)
     b82:	9104      	str	r1, [sp, #16]
     b84:	a901      	add	r1, sp, #4
     b86:	f000 fcba 	bl	14fe <_svfiprintf_r>
     b8a:	9b01      	ldr	r3, [sp, #4]
     b8c:	2200      	movs	r2, #0
     b8e:	701a      	strb	r2, [r3, #0]
     b90:	b01b      	add	sp, #108	; 0x6c
     b92:	f85d fb04 	ldr.w	pc, [sp], #4
     b96:	bf00      	nop
     b98:	ffff0208 	.word	0xffff0208

00000b9c <vsiprintf>:
     b9c:	4613      	mov	r3, r2
     b9e:	460a      	mov	r2, r1
     ba0:	4601      	mov	r1, r0
     ba2:	4802      	ldr	r0, [pc, #8]	; (bac <vsiprintf+0x10>)
     ba4:	6800      	ldr	r0, [r0, #0]
     ba6:	f7ff bfe3 	b.w	b70 <_vsiprintf_r>
     baa:	bf00      	nop
     bac:	2000e248 	.word	0x2000e248

00000bb0 <__swbuf_r>:
     bb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     bb2:	460d      	mov	r5, r1
     bb4:	4614      	mov	r4, r2
     bb6:	4606      	mov	r6, r0
     bb8:	b118      	cbz	r0, bc2 <__swbuf_r+0x12>
     bba:	6b83      	ldr	r3, [r0, #56]	; 0x38
     bbc:	b90b      	cbnz	r3, bc2 <__swbuf_r+0x12>
     bbe:	f000 f9b1 	bl	f24 <__sinit>
     bc2:	69a3      	ldr	r3, [r4, #24]
     bc4:	60a3      	str	r3, [r4, #8]
     bc6:	89a3      	ldrh	r3, [r4, #12]
     bc8:	071a      	lsls	r2, r3, #28
     bca:	d525      	bpl.n	c18 <__swbuf_r+0x68>
     bcc:	6923      	ldr	r3, [r4, #16]
     bce:	b31b      	cbz	r3, c18 <__swbuf_r+0x68>
     bd0:	6923      	ldr	r3, [r4, #16]
     bd2:	6820      	ldr	r0, [r4, #0]
     bd4:	1ac0      	subs	r0, r0, r3
     bd6:	6963      	ldr	r3, [r4, #20]
     bd8:	b2ed      	uxtb	r5, r5
     bda:	4283      	cmp	r3, r0
     bdc:	462f      	mov	r7, r5
     bde:	dc04      	bgt.n	bea <__swbuf_r+0x3a>
     be0:	4621      	mov	r1, r4
     be2:	4630      	mov	r0, r6
     be4:	f000 f934 	bl	e50 <_fflush_r>
     be8:	b9e0      	cbnz	r0, c24 <__swbuf_r+0x74>
     bea:	68a3      	ldr	r3, [r4, #8]
     bec:	3b01      	subs	r3, #1
     bee:	60a3      	str	r3, [r4, #8]
     bf0:	6823      	ldr	r3, [r4, #0]
     bf2:	1c5a      	adds	r2, r3, #1
     bf4:	6022      	str	r2, [r4, #0]
     bf6:	701d      	strb	r5, [r3, #0]
     bf8:	6963      	ldr	r3, [r4, #20]
     bfa:	3001      	adds	r0, #1
     bfc:	4283      	cmp	r3, r0
     bfe:	d004      	beq.n	c0a <__swbuf_r+0x5a>
     c00:	89a3      	ldrh	r3, [r4, #12]
     c02:	07db      	lsls	r3, r3, #31
     c04:	d506      	bpl.n	c14 <__swbuf_r+0x64>
     c06:	2d0a      	cmp	r5, #10
     c08:	d104      	bne.n	c14 <__swbuf_r+0x64>
     c0a:	4621      	mov	r1, r4
     c0c:	4630      	mov	r0, r6
     c0e:	f000 f91f 	bl	e50 <_fflush_r>
     c12:	b938      	cbnz	r0, c24 <__swbuf_r+0x74>
     c14:	4638      	mov	r0, r7
     c16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     c18:	4621      	mov	r1, r4
     c1a:	4630      	mov	r0, r6
     c1c:	f000 f80e 	bl	c3c <__swsetup_r>
     c20:	2800      	cmp	r0, #0
     c22:	d0d5      	beq.n	bd0 <__swbuf_r+0x20>
     c24:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
     c28:	e7f4      	b.n	c14 <__swbuf_r+0x64>

00000c2a <__swbuf>:
     c2a:	4b03      	ldr	r3, [pc, #12]	; (c38 <__swbuf+0xe>)
     c2c:	460a      	mov	r2, r1
     c2e:	4601      	mov	r1, r0
     c30:	6818      	ldr	r0, [r3, #0]
     c32:	f7ff bfbd 	b.w	bb0 <__swbuf_r>
     c36:	bf00      	nop
     c38:	2000e248 	.word	0x2000e248

00000c3c <__swsetup_r>:
     c3c:	b538      	push	{r3, r4, r5, lr}
     c3e:	4b2a      	ldr	r3, [pc, #168]	; (ce8 <__swsetup_r+0xac>)
     c40:	4605      	mov	r5, r0
     c42:	6818      	ldr	r0, [r3, #0]
     c44:	460c      	mov	r4, r1
     c46:	b118      	cbz	r0, c50 <__swsetup_r+0x14>
     c48:	6b83      	ldr	r3, [r0, #56]	; 0x38
     c4a:	b90b      	cbnz	r3, c50 <__swsetup_r+0x14>
     c4c:	f000 f96a 	bl	f24 <__sinit>
     c50:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
     c54:	b29a      	uxth	r2, r3
     c56:	0711      	lsls	r1, r2, #28
     c58:	d422      	bmi.n	ca0 <__swsetup_r+0x64>
     c5a:	06d0      	lsls	r0, r2, #27
     c5c:	d407      	bmi.n	c6e <__swsetup_r+0x32>
     c5e:	2209      	movs	r2, #9
     c60:	602a      	str	r2, [r5, #0]
     c62:	f043 0340 	orr.w	r3, r3, #64	; 0x40
     c66:	81a3      	strh	r3, [r4, #12]
     c68:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     c6c:	e034      	b.n	cd8 <__swsetup_r+0x9c>
     c6e:	0751      	lsls	r1, r2, #29
     c70:	d512      	bpl.n	c98 <__swsetup_r+0x5c>
     c72:	6b21      	ldr	r1, [r4, #48]	; 0x30
     c74:	b141      	cbz	r1, c88 <__swsetup_r+0x4c>
     c76:	f104 0340 	add.w	r3, r4, #64	; 0x40
     c7a:	4299      	cmp	r1, r3
     c7c:	d002      	beq.n	c84 <__swsetup_r+0x48>
     c7e:	4628      	mov	r0, r5
     c80:	f7ff fadc 	bl	23c <_free_r>
     c84:	2300      	movs	r3, #0
     c86:	6323      	str	r3, [r4, #48]	; 0x30
     c88:	89a3      	ldrh	r3, [r4, #12]
     c8a:	f023 0324 	bic.w	r3, r3, #36	; 0x24
     c8e:	81a3      	strh	r3, [r4, #12]
     c90:	2300      	movs	r3, #0
     c92:	6063      	str	r3, [r4, #4]
     c94:	6923      	ldr	r3, [r4, #16]
     c96:	6023      	str	r3, [r4, #0]
     c98:	89a3      	ldrh	r3, [r4, #12]
     c9a:	f043 0308 	orr.w	r3, r3, #8
     c9e:	81a3      	strh	r3, [r4, #12]
     ca0:	6923      	ldr	r3, [r4, #16]
     ca2:	b94b      	cbnz	r3, cb8 <__swsetup_r+0x7c>
     ca4:	89a3      	ldrh	r3, [r4, #12]
     ca6:	f403 7320 	and.w	r3, r3, #640	; 0x280
     caa:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
     cae:	d003      	beq.n	cb8 <__swsetup_r+0x7c>
     cb0:	4621      	mov	r1, r4
     cb2:	4628      	mov	r0, r5
     cb4:	f000 fb0f 	bl	12d6 <__smakebuf_r>
     cb8:	89a2      	ldrh	r2, [r4, #12]
     cba:	f012 0301 	ands.w	r3, r2, #1
     cbe:	d00c      	beq.n	cda <__swsetup_r+0x9e>
     cc0:	2300      	movs	r3, #0
     cc2:	60a3      	str	r3, [r4, #8]
     cc4:	6963      	ldr	r3, [r4, #20]
     cc6:	425b      	negs	r3, r3
     cc8:	61a3      	str	r3, [r4, #24]
     cca:	6923      	ldr	r3, [r4, #16]
     ccc:	b953      	cbnz	r3, ce4 <__swsetup_r+0xa8>
     cce:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
     cd2:	f013 0080 	ands.w	r0, r3, #128	; 0x80
     cd6:	d1c4      	bne.n	c62 <__swsetup_r+0x26>
     cd8:	bd38      	pop	{r3, r4, r5, pc}
     cda:	0792      	lsls	r2, r2, #30
     cdc:	bf58      	it	pl
     cde:	6963      	ldrpl	r3, [r4, #20]
     ce0:	60a3      	str	r3, [r4, #8]
     ce2:	e7f2      	b.n	cca <__swsetup_r+0x8e>
     ce4:	2000      	movs	r0, #0
     ce6:	e7f7      	b.n	cd8 <__swsetup_r+0x9c>
     ce8:	2000e248 	.word	0x2000e248

00000cec <__chk_fail>:
     cec:	b500      	push	{lr}
     cee:	4b10      	ldr	r3, [pc, #64]	; (d30 <__chk_fail+0x44>)
     cf0:	b08d      	sub	sp, #52	; 0x34
     cf2:	466a      	mov	r2, sp
     cf4:	f103 0628 	add.w	r6, r3, #40	; 0x28
     cf8:	4615      	mov	r5, r2
     cfa:	6818      	ldr	r0, [r3, #0]
     cfc:	6859      	ldr	r1, [r3, #4]
     cfe:	4614      	mov	r4, r2
     d00:	c403      	stmia	r4!, {r0, r1}
     d02:	3308      	adds	r3, #8
     d04:	42b3      	cmp	r3, r6
     d06:	4622      	mov	r2, r4
     d08:	d1f7      	bne.n	cfa <__chk_fail+0xe>
     d0a:	6818      	ldr	r0, [r3, #0]
     d0c:	889b      	ldrh	r3, [r3, #4]
     d0e:	80a3      	strh	r3, [r4, #4]
     d10:	6020      	str	r0, [r4, #0]
     d12:	4628      	mov	r0, r5
     d14:	f000 ffc8 	bl	1ca8 <strlen>
     d18:	4629      	mov	r1, r5
     d1a:	4602      	mov	r2, r0
     d1c:	2002      	movs	r0, #2
     d1e:	f021 f8d7 	bl	21ed0 <_write>
     d22:	2006      	movs	r0, #6
     d24:	f000 fd61 	bl	17ea <raise>
     d28:	207f      	movs	r0, #127	; 0x7f
     d2a:	f006 fc15 	bl	7558 <_exit>
     d2e:	bf00      	nop
     d30:	0006d9bc 	.word	0x0006d9bc

00000d34 <__sflush_r>:
     d34:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
     d38:	b293      	uxth	r3, r2
     d3a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     d3e:	4605      	mov	r5, r0
     d40:	0718      	lsls	r0, r3, #28
     d42:	460c      	mov	r4, r1
     d44:	d45f      	bmi.n	e06 <__sflush_r+0xd2>
     d46:	684b      	ldr	r3, [r1, #4]
     d48:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
     d4c:	2b00      	cmp	r3, #0
     d4e:	818a      	strh	r2, [r1, #12]
     d50:	dc05      	bgt.n	d5e <__sflush_r+0x2a>
     d52:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
     d54:	2b00      	cmp	r3, #0
     d56:	dc02      	bgt.n	d5e <__sflush_r+0x2a>
     d58:	2000      	movs	r0, #0
     d5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     d5e:	6aa6      	ldr	r6, [r4, #40]	; 0x28
     d60:	2e00      	cmp	r6, #0
     d62:	d0f9      	beq.n	d58 <__sflush_r+0x24>
     d64:	2300      	movs	r3, #0
     d66:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
     d6a:	682f      	ldr	r7, [r5, #0]
     d6c:	602b      	str	r3, [r5, #0]
     d6e:	d036      	beq.n	dde <__sflush_r+0xaa>
     d70:	6d20      	ldr	r0, [r4, #80]	; 0x50
     d72:	89a3      	ldrh	r3, [r4, #12]
     d74:	075a      	lsls	r2, r3, #29
     d76:	d505      	bpl.n	d84 <__sflush_r+0x50>
     d78:	6863      	ldr	r3, [r4, #4]
     d7a:	1ac0      	subs	r0, r0, r3
     d7c:	6b23      	ldr	r3, [r4, #48]	; 0x30
     d7e:	b10b      	cbz	r3, d84 <__sflush_r+0x50>
     d80:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     d82:	1ac0      	subs	r0, r0, r3
     d84:	2300      	movs	r3, #0
     d86:	4602      	mov	r2, r0
     d88:	6aa6      	ldr	r6, [r4, #40]	; 0x28
     d8a:	69e1      	ldr	r1, [r4, #28]
     d8c:	4628      	mov	r0, r5
     d8e:	47b0      	blx	r6
     d90:	1c43      	adds	r3, r0, #1
     d92:	89a3      	ldrh	r3, [r4, #12]
     d94:	d106      	bne.n	da4 <__sflush_r+0x70>
     d96:	6829      	ldr	r1, [r5, #0]
     d98:	291d      	cmp	r1, #29
     d9a:	d830      	bhi.n	dfe <__sflush_r+0xca>
     d9c:	4a2b      	ldr	r2, [pc, #172]	; (e4c <__sflush_r+0x118>)
     d9e:	40ca      	lsrs	r2, r1
     da0:	07d6      	lsls	r6, r2, #31
     da2:	d52c      	bpl.n	dfe <__sflush_r+0xca>
     da4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
     da8:	b21b      	sxth	r3, r3
     daa:	2200      	movs	r2, #0
     dac:	6062      	str	r2, [r4, #4]
     dae:	04d9      	lsls	r1, r3, #19
     db0:	6922      	ldr	r2, [r4, #16]
     db2:	81a3      	strh	r3, [r4, #12]
     db4:	6022      	str	r2, [r4, #0]
     db6:	d504      	bpl.n	dc2 <__sflush_r+0x8e>
     db8:	1c42      	adds	r2, r0, #1
     dba:	d101      	bne.n	dc0 <__sflush_r+0x8c>
     dbc:	682b      	ldr	r3, [r5, #0]
     dbe:	b903      	cbnz	r3, dc2 <__sflush_r+0x8e>
     dc0:	6520      	str	r0, [r4, #80]	; 0x50
     dc2:	6b21      	ldr	r1, [r4, #48]	; 0x30
     dc4:	602f      	str	r7, [r5, #0]
     dc6:	2900      	cmp	r1, #0
     dc8:	d0c6      	beq.n	d58 <__sflush_r+0x24>
     dca:	f104 0340 	add.w	r3, r4, #64	; 0x40
     dce:	4299      	cmp	r1, r3
     dd0:	d002      	beq.n	dd8 <__sflush_r+0xa4>
     dd2:	4628      	mov	r0, r5
     dd4:	f7ff fa32 	bl	23c <_free_r>
     dd8:	2000      	movs	r0, #0
     dda:	6320      	str	r0, [r4, #48]	; 0x30
     ddc:	e7bd      	b.n	d5a <__sflush_r+0x26>
     dde:	69e1      	ldr	r1, [r4, #28]
     de0:	2301      	movs	r3, #1
     de2:	4628      	mov	r0, r5
     de4:	47b0      	blx	r6
     de6:	1c41      	adds	r1, r0, #1
     de8:	d1c3      	bne.n	d72 <__sflush_r+0x3e>
     dea:	682b      	ldr	r3, [r5, #0]
     dec:	2b00      	cmp	r3, #0
     dee:	d0c0      	beq.n	d72 <__sflush_r+0x3e>
     df0:	2b1d      	cmp	r3, #29
     df2:	d001      	beq.n	df8 <__sflush_r+0xc4>
     df4:	2b16      	cmp	r3, #22
     df6:	d101      	bne.n	dfc <__sflush_r+0xc8>
     df8:	602f      	str	r7, [r5, #0]
     dfa:	e7ad      	b.n	d58 <__sflush_r+0x24>
     dfc:	89a3      	ldrh	r3, [r4, #12]
     dfe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
     e02:	81a3      	strh	r3, [r4, #12]
     e04:	e7a9      	b.n	d5a <__sflush_r+0x26>
     e06:	690f      	ldr	r7, [r1, #16]
     e08:	2f00      	cmp	r7, #0
     e0a:	d0a5      	beq.n	d58 <__sflush_r+0x24>
     e0c:	079b      	lsls	r3, r3, #30
     e0e:	680e      	ldr	r6, [r1, #0]
     e10:	bf08      	it	eq
     e12:	694b      	ldreq	r3, [r1, #20]
     e14:	600f      	str	r7, [r1, #0]
     e16:	bf18      	it	ne
     e18:	2300      	movne	r3, #0
     e1a:	eba6 0807 	sub.w	r8, r6, r7
     e1e:	608b      	str	r3, [r1, #8]
     e20:	f1b8 0f00 	cmp.w	r8, #0
     e24:	dd98      	ble.n	d58 <__sflush_r+0x24>
     e26:	4643      	mov	r3, r8
     e28:	463a      	mov	r2, r7
     e2a:	69e1      	ldr	r1, [r4, #28]
     e2c:	6a66      	ldr	r6, [r4, #36]	; 0x24
     e2e:	4628      	mov	r0, r5
     e30:	47b0      	blx	r6
     e32:	2800      	cmp	r0, #0
     e34:	dc06      	bgt.n	e44 <__sflush_r+0x110>
     e36:	89a3      	ldrh	r3, [r4, #12]
     e38:	f043 0340 	orr.w	r3, r3, #64	; 0x40
     e3c:	81a3      	strh	r3, [r4, #12]
     e3e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     e42:	e78a      	b.n	d5a <__sflush_r+0x26>
     e44:	4407      	add	r7, r0
     e46:	eba8 0800 	sub.w	r8, r8, r0
     e4a:	e7e9      	b.n	e20 <__sflush_r+0xec>
     e4c:	20400001 	.word	0x20400001

00000e50 <_fflush_r>:
     e50:	b538      	push	{r3, r4, r5, lr}
     e52:	460d      	mov	r5, r1
     e54:	4604      	mov	r4, r0
     e56:	b118      	cbz	r0, e60 <_fflush_r+0x10>
     e58:	6b83      	ldr	r3, [r0, #56]	; 0x38
     e5a:	b90b      	cbnz	r3, e60 <_fflush_r+0x10>
     e5c:	f000 f862 	bl	f24 <__sinit>
     e60:	f9b5 000c 	ldrsh.w	r0, [r5, #12]
     e64:	b128      	cbz	r0, e72 <_fflush_r+0x22>
     e66:	4629      	mov	r1, r5
     e68:	4620      	mov	r0, r4
     e6a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     e6e:	f7ff bf61 	b.w	d34 <__sflush_r>
     e72:	bd38      	pop	{r3, r4, r5, pc}

00000e74 <fflush>:
     e74:	4601      	mov	r1, r0
     e76:	b920      	cbnz	r0, e82 <fflush+0xe>
     e78:	4b04      	ldr	r3, [pc, #16]	; (e8c <fflush+0x18>)
     e7a:	4905      	ldr	r1, [pc, #20]	; (e90 <fflush+0x1c>)
     e7c:	6818      	ldr	r0, [r3, #0]
     e7e:	f000 bf63 	b.w	1d48 <_fwalk_reent>
     e82:	4b04      	ldr	r3, [pc, #16]	; (e94 <fflush+0x20>)
     e84:	6818      	ldr	r0, [r3, #0]
     e86:	f7ff bfe3 	b.w	e50 <_fflush_r>
     e8a:	bf00      	nop
     e8c:	00028730 	.word	0x00028730
     e90:	00000e51 	.word	0x00000e51
     e94:	2000e248 	.word	0x2000e248

00000e98 <std>:
     e98:	2300      	movs	r3, #0
     e9a:	b510      	push	{r4, lr}
     e9c:	4604      	mov	r4, r0
     e9e:	e9c0 3300 	strd	r3, r3, [r0]
     ea2:	6083      	str	r3, [r0, #8]
     ea4:	8181      	strh	r1, [r0, #12]
     ea6:	6603      	str	r3, [r0, #96]	; 0x60
     ea8:	81c2      	strh	r2, [r0, #14]
     eaa:	e9c0 3304 	strd	r3, r3, [r0, #16]
     eae:	6183      	str	r3, [r0, #24]
     eb0:	4619      	mov	r1, r3
     eb2:	2208      	movs	r2, #8
     eb4:	3058      	adds	r0, #88	; 0x58
     eb6:	f000 feba 	bl	1c2e <memset>
     eba:	4b05      	ldr	r3, [pc, #20]	; (ed0 <std+0x38>)
     ebc:	6223      	str	r3, [r4, #32]
     ebe:	4b05      	ldr	r3, [pc, #20]	; (ed4 <std+0x3c>)
     ec0:	6263      	str	r3, [r4, #36]	; 0x24
     ec2:	4b05      	ldr	r3, [pc, #20]	; (ed8 <std+0x40>)
     ec4:	62a3      	str	r3, [r4, #40]	; 0x28
     ec6:	4b05      	ldr	r3, [pc, #20]	; (edc <std+0x44>)
     ec8:	61e4      	str	r4, [r4, #28]
     eca:	62e3      	str	r3, [r4, #44]	; 0x2c
     ecc:	bd10      	pop	{r4, pc}
     ece:	bf00      	nop
     ed0:	00001e09 	.word	0x00001e09
     ed4:	00001e2f 	.word	0x00001e2f
     ed8:	00001e67 	.word	0x00001e67
     edc:	00001e8b 	.word	0x00001e8b

00000ee0 <_cleanup_r>:
     ee0:	4901      	ldr	r1, [pc, #4]	; (ee8 <_cleanup_r+0x8>)
     ee2:	f000 bf31 	b.w	1d48 <_fwalk_reent>
     ee6:	bf00      	nop
     ee8:	00000e51 	.word	0x00000e51

00000eec <__sfmoreglue>:
     eec:	b570      	push	{r4, r5, r6, lr}
     eee:	1e4a      	subs	r2, r1, #1
     ef0:	2564      	movs	r5, #100	; 0x64
     ef2:	4355      	muls	r5, r2
     ef4:	460e      	mov	r6, r1
     ef6:	f105 0170 	add.w	r1, r5, #112	; 0x70
     efa:	f7ff f9ed 	bl	2d8 <_malloc_r>
     efe:	4604      	mov	r4, r0
     f00:	b140      	cbz	r0, f14 <__sfmoreglue+0x28>
     f02:	2100      	movs	r1, #0
     f04:	e9c0 1600 	strd	r1, r6, [r0]
     f08:	300c      	adds	r0, #12
     f0a:	60a0      	str	r0, [r4, #8]
     f0c:	f105 0264 	add.w	r2, r5, #100	; 0x64
     f10:	f000 fe8d 	bl	1c2e <memset>
     f14:	4620      	mov	r0, r4
     f16:	bd70      	pop	{r4, r5, r6, pc}

00000f18 <_cleanup>:
     f18:	4b01      	ldr	r3, [pc, #4]	; (f20 <_cleanup+0x8>)
     f1a:	6818      	ldr	r0, [r3, #0]
     f1c:	f7ff bfe0 	b.w	ee0 <_cleanup_r>
     f20:	00028730 	.word	0x00028730

00000f24 <__sinit>:
     f24:	6b82      	ldr	r2, [r0, #56]	; 0x38
     f26:	b510      	push	{r4, lr}
     f28:	4604      	mov	r4, r0
     f2a:	b9d2      	cbnz	r2, f62 <__sinit+0x3e>
     f2c:	4b0d      	ldr	r3, [pc, #52]	; (f64 <__sinit+0x40>)
     f2e:	63c3      	str	r3, [r0, #60]	; 0x3c
     f30:	2303      	movs	r3, #3
     f32:	f8c0 3150 	str.w	r3, [r0, #336]	; 0x150
     f36:	f500 73ac 	add.w	r3, r0, #344	; 0x158
     f3a:	f8c0 3154 	str.w	r3, [r0, #340]	; 0x154
     f3e:	f8c0 214c 	str.w	r2, [r0, #332]	; 0x14c
     f42:	2104      	movs	r1, #4
     f44:	6840      	ldr	r0, [r0, #4]
     f46:	f7ff ffa7 	bl	e98 <std>
     f4a:	2201      	movs	r2, #1
     f4c:	2109      	movs	r1, #9
     f4e:	68a0      	ldr	r0, [r4, #8]
     f50:	f7ff ffa2 	bl	e98 <std>
     f54:	2202      	movs	r2, #2
     f56:	2112      	movs	r1, #18
     f58:	68e0      	ldr	r0, [r4, #12]
     f5a:	f7ff ff9d 	bl	e98 <std>
     f5e:	2301      	movs	r3, #1
     f60:	63a3      	str	r3, [r4, #56]	; 0x38
     f62:	bd10      	pop	{r4, pc}
     f64:	00000ee1 	.word	0x00000ee1

00000f68 <__sfp>:
     f68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     f6a:	4b1b      	ldr	r3, [pc, #108]	; (fd8 <__sfp+0x70>)
     f6c:	681e      	ldr	r6, [r3, #0]
     f6e:	6bb3      	ldr	r3, [r6, #56]	; 0x38
     f70:	4607      	mov	r7, r0
     f72:	b913      	cbnz	r3, f7a <__sfp+0x12>
     f74:	4630      	mov	r0, r6
     f76:	f7ff ffd5 	bl	f24 <__sinit>
     f7a:	f506 76a6 	add.w	r6, r6, #332	; 0x14c
     f7e:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
     f82:	3b01      	subs	r3, #1
     f84:	d503      	bpl.n	f8e <__sfp+0x26>
     f86:	6833      	ldr	r3, [r6, #0]
     f88:	b1db      	cbz	r3, fc2 <__sfp+0x5a>
     f8a:	6836      	ldr	r6, [r6, #0]
     f8c:	e7f7      	b.n	f7e <__sfp+0x16>
     f8e:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
     f92:	b9a5      	cbnz	r5, fbe <__sfp+0x56>
     f94:	4b11      	ldr	r3, [pc, #68]	; (fdc <__sfp+0x74>)
     f96:	6625      	str	r5, [r4, #96]	; 0x60
     f98:	e9c4 5500 	strd	r5, r5, [r4]
     f9c:	60a5      	str	r5, [r4, #8]
     f9e:	e9c4 3503 	strd	r3, r5, [r4, #12]
     fa2:	e9c4 5505 	strd	r5, r5, [r4, #20]
     fa6:	2208      	movs	r2, #8
     fa8:	4629      	mov	r1, r5
     faa:	f104 0058 	add.w	r0, r4, #88	; 0x58
     fae:	f000 fe3e 	bl	1c2e <memset>
     fb2:	e9c4 550c 	strd	r5, r5, [r4, #48]	; 0x30
     fb6:	e9c4 5511 	strd	r5, r5, [r4, #68]	; 0x44
     fba:	4620      	mov	r0, r4
     fbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     fbe:	3464      	adds	r4, #100	; 0x64
     fc0:	e7df      	b.n	f82 <__sfp+0x1a>
     fc2:	2104      	movs	r1, #4
     fc4:	4638      	mov	r0, r7
     fc6:	f7ff ff91 	bl	eec <__sfmoreglue>
     fca:	4604      	mov	r4, r0
     fcc:	6030      	str	r0, [r6, #0]
     fce:	2800      	cmp	r0, #0
     fd0:	d1db      	bne.n	f8a <__sfp+0x22>
     fd2:	230c      	movs	r3, #12
     fd4:	603b      	str	r3, [r7, #0]
     fd6:	e7f0      	b.n	fba <__sfp+0x52>
     fd8:	00028730 	.word	0x00028730
     fdc:	ffff0001 	.word	0xffff0001

00000fe0 <__sfvwrite_r>:
     fe0:	6893      	ldr	r3, [r2, #8]
     fe2:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
     fe6:	4607      	mov	r7, r0
     fe8:	460c      	mov	r4, r1
     fea:	4690      	mov	r8, r2
     fec:	b91b      	cbnz	r3, ff6 <__sfvwrite_r+0x16>
     fee:	2000      	movs	r0, #0
     ff0:	b003      	add	sp, #12
     ff2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     ff6:	898b      	ldrh	r3, [r1, #12]
     ff8:	0718      	lsls	r0, r3, #28
     ffa:	d550      	bpl.n	109e <__sfvwrite_r+0xbe>
     ffc:	690b      	ldr	r3, [r1, #16]
     ffe:	2b00      	cmp	r3, #0
    1000:	d04d      	beq.n	109e <__sfvwrite_r+0xbe>
    1002:	89a3      	ldrh	r3, [r4, #12]
    1004:	f8d8 6000 	ldr.w	r6, [r8]
    1008:	f013 0902 	ands.w	r9, r3, #2
    100c:	d16c      	bne.n	10e8 <__sfvwrite_r+0x108>
    100e:	f013 0301 	ands.w	r3, r3, #1
    1012:	f000 809c 	beq.w	114e <__sfvwrite_r+0x16e>
    1016:	4648      	mov	r0, r9
    1018:	46ca      	mov	sl, r9
    101a:	46cb      	mov	fp, r9
    101c:	f1bb 0f00 	cmp.w	fp, #0
    1020:	f000 8106 	beq.w	1230 <__sfvwrite_r+0x250>
    1024:	b950      	cbnz	r0, 103c <__sfvwrite_r+0x5c>
    1026:	465a      	mov	r2, fp
    1028:	210a      	movs	r1, #10
    102a:	4650      	mov	r0, sl
    102c:	f7ff f858 	bl	e0 <memchr>
    1030:	2800      	cmp	r0, #0
    1032:	f000 8102 	beq.w	123a <__sfvwrite_r+0x25a>
    1036:	3001      	adds	r0, #1
    1038:	eba0 090a 	sub.w	r9, r0, sl
    103c:	6820      	ldr	r0, [r4, #0]
    103e:	6921      	ldr	r1, [r4, #16]
    1040:	6962      	ldr	r2, [r4, #20]
    1042:	45d9      	cmp	r9, fp
    1044:	464b      	mov	r3, r9
    1046:	bf28      	it	cs
    1048:	465b      	movcs	r3, fp
    104a:	4288      	cmp	r0, r1
    104c:	f240 80f8 	bls.w	1240 <__sfvwrite_r+0x260>
    1050:	68a5      	ldr	r5, [r4, #8]
    1052:	4415      	add	r5, r2
    1054:	42ab      	cmp	r3, r5
    1056:	f340 80f3 	ble.w	1240 <__sfvwrite_r+0x260>
    105a:	4651      	mov	r1, sl
    105c:	462a      	mov	r2, r5
    105e:	f000 fe91 	bl	1d84 <memmove>
    1062:	6823      	ldr	r3, [r4, #0]
    1064:	442b      	add	r3, r5
    1066:	6023      	str	r3, [r4, #0]
    1068:	4621      	mov	r1, r4
    106a:	4638      	mov	r0, r7
    106c:	f7ff fef0 	bl	e50 <_fflush_r>
    1070:	2800      	cmp	r0, #0
    1072:	d167      	bne.n	1144 <__sfvwrite_r+0x164>
    1074:	ebb9 0905 	subs.w	r9, r9, r5
    1078:	f040 80fc 	bne.w	1274 <__sfvwrite_r+0x294>
    107c:	4621      	mov	r1, r4
    107e:	4638      	mov	r0, r7
    1080:	f7ff fee6 	bl	e50 <_fflush_r>
    1084:	2800      	cmp	r0, #0
    1086:	d15d      	bne.n	1144 <__sfvwrite_r+0x164>
    1088:	f8d8 3008 	ldr.w	r3, [r8, #8]
    108c:	44aa      	add	sl, r5
    108e:	ebab 0b05 	sub.w	fp, fp, r5
    1092:	1b5d      	subs	r5, r3, r5
    1094:	f8c8 5008 	str.w	r5, [r8, #8]
    1098:	2d00      	cmp	r5, #0
    109a:	d1bf      	bne.n	101c <__sfvwrite_r+0x3c>
    109c:	e7a7      	b.n	fee <__sfvwrite_r+0xe>
    109e:	4621      	mov	r1, r4
    10a0:	4638      	mov	r0, r7
    10a2:	f7ff fdcb 	bl	c3c <__swsetup_r>
    10a6:	2800      	cmp	r0, #0
    10a8:	d0ab      	beq.n	1002 <__sfvwrite_r+0x22>
    10aa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    10ae:	e79f      	b.n	ff0 <__sfvwrite_r+0x10>
    10b0:	e9d6 a900 	ldrd	sl, r9, [r6]
    10b4:	3608      	adds	r6, #8
    10b6:	f1b9 0f00 	cmp.w	r9, #0
    10ba:	d0f9      	beq.n	10b0 <__sfvwrite_r+0xd0>
    10bc:	45d9      	cmp	r9, fp
    10be:	464b      	mov	r3, r9
    10c0:	4652      	mov	r2, sl
    10c2:	bf28      	it	cs
    10c4:	465b      	movcs	r3, fp
    10c6:	69e1      	ldr	r1, [r4, #28]
    10c8:	6a65      	ldr	r5, [r4, #36]	; 0x24
    10ca:	4638      	mov	r0, r7
    10cc:	47a8      	blx	r5
    10ce:	2800      	cmp	r0, #0
    10d0:	dd38      	ble.n	1144 <__sfvwrite_r+0x164>
    10d2:	f8d8 3008 	ldr.w	r3, [r8, #8]
    10d6:	4482      	add	sl, r0
    10d8:	eba9 0900 	sub.w	r9, r9, r0
    10dc:	1a18      	subs	r0, r3, r0
    10de:	f8c8 0008 	str.w	r0, [r8, #8]
    10e2:	2800      	cmp	r0, #0
    10e4:	d1e7      	bne.n	10b6 <__sfvwrite_r+0xd6>
    10e6:	e782      	b.n	fee <__sfvwrite_r+0xe>
    10e8:	f04f 0a00 	mov.w	sl, #0
    10ec:	46d1      	mov	r9, sl
    10ee:	f8df b18c 	ldr.w	fp, [pc, #396]	; 127c <__sfvwrite_r+0x29c>
    10f2:	e7e0      	b.n	10b6 <__sfvwrite_r+0xd6>
    10f4:	e9d6 9a00 	ldrd	r9, sl, [r6]
    10f8:	3608      	adds	r6, #8
    10fa:	f1ba 0f00 	cmp.w	sl, #0
    10fe:	d0f9      	beq.n	10f4 <__sfvwrite_r+0x114>
    1100:	89a2      	ldrh	r2, [r4, #12]
    1102:	68a3      	ldr	r3, [r4, #8]
    1104:	6820      	ldr	r0, [r4, #0]
    1106:	0591      	lsls	r1, r2, #22
    1108:	d564      	bpl.n	11d4 <__sfvwrite_r+0x1f4>
    110a:	4553      	cmp	r3, sl
    110c:	d836      	bhi.n	117c <__sfvwrite_r+0x19c>
    110e:	f412 6f90 	tst.w	r2, #1152	; 0x480
    1112:	d033      	beq.n	117c <__sfvwrite_r+0x19c>
    1114:	6921      	ldr	r1, [r4, #16]
    1116:	6965      	ldr	r5, [r4, #20]
    1118:	eba0 0b01 	sub.w	fp, r0, r1
    111c:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    1120:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
    1124:	f10b 0301 	add.w	r3, fp, #1
    1128:	4453      	add	r3, sl
    112a:	106d      	asrs	r5, r5, #1
    112c:	429d      	cmp	r5, r3
    112e:	bf38      	it	cc
    1130:	461d      	movcc	r5, r3
    1132:	0553      	lsls	r3, r2, #21
    1134:	d53e      	bpl.n	11b4 <__sfvwrite_r+0x1d4>
    1136:	4629      	mov	r1, r5
    1138:	4638      	mov	r0, r7
    113a:	f7ff f8cd 	bl	2d8 <_malloc_r>
    113e:	b948      	cbnz	r0, 1154 <__sfvwrite_r+0x174>
    1140:	230c      	movs	r3, #12
    1142:	603b      	str	r3, [r7, #0]
    1144:	89a3      	ldrh	r3, [r4, #12]
    1146:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    114a:	81a3      	strh	r3, [r4, #12]
    114c:	e7ad      	b.n	10aa <__sfvwrite_r+0xca>
    114e:	4699      	mov	r9, r3
    1150:	469a      	mov	sl, r3
    1152:	e7d2      	b.n	10fa <__sfvwrite_r+0x11a>
    1154:	465a      	mov	r2, fp
    1156:	6921      	ldr	r1, [r4, #16]
    1158:	9001      	str	r0, [sp, #4]
    115a:	f000 fd47 	bl	1bec <memcpy>
    115e:	89a2      	ldrh	r2, [r4, #12]
    1160:	9b01      	ldr	r3, [sp, #4]
    1162:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
    1166:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    116a:	81a2      	strh	r2, [r4, #12]
    116c:	6123      	str	r3, [r4, #16]
    116e:	6165      	str	r5, [r4, #20]
    1170:	445b      	add	r3, fp
    1172:	eba5 050b 	sub.w	r5, r5, fp
    1176:	6023      	str	r3, [r4, #0]
    1178:	60a5      	str	r5, [r4, #8]
    117a:	4653      	mov	r3, sl
    117c:	4553      	cmp	r3, sl
    117e:	bf28      	it	cs
    1180:	4653      	movcs	r3, sl
    1182:	461a      	mov	r2, r3
    1184:	4649      	mov	r1, r9
    1186:	6820      	ldr	r0, [r4, #0]
    1188:	9301      	str	r3, [sp, #4]
    118a:	f000 fdfb 	bl	1d84 <memmove>
    118e:	68a2      	ldr	r2, [r4, #8]
    1190:	9b01      	ldr	r3, [sp, #4]
    1192:	1ad2      	subs	r2, r2, r3
    1194:	60a2      	str	r2, [r4, #8]
    1196:	6822      	ldr	r2, [r4, #0]
    1198:	4413      	add	r3, r2
    119a:	4655      	mov	r5, sl
    119c:	6023      	str	r3, [r4, #0]
    119e:	f8d8 3008 	ldr.w	r3, [r8, #8]
    11a2:	44a9      	add	r9, r5
    11a4:	ebaa 0a05 	sub.w	sl, sl, r5
    11a8:	1b5d      	subs	r5, r3, r5
    11aa:	f8c8 5008 	str.w	r5, [r8, #8]
    11ae:	2d00      	cmp	r5, #0
    11b0:	d1a3      	bne.n	10fa <__sfvwrite_r+0x11a>
    11b2:	e71c      	b.n	fee <__sfvwrite_r+0xe>
    11b4:	462a      	mov	r2, r5
    11b6:	4638      	mov	r0, r7
    11b8:	f000 fe00 	bl	1dbc <_realloc_r>
    11bc:	4603      	mov	r3, r0
    11be:	2800      	cmp	r0, #0
    11c0:	d1d4      	bne.n	116c <__sfvwrite_r+0x18c>
    11c2:	6921      	ldr	r1, [r4, #16]
    11c4:	4638      	mov	r0, r7
    11c6:	f7ff f839 	bl	23c <_free_r>
    11ca:	89a3      	ldrh	r3, [r4, #12]
    11cc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    11d0:	81a3      	strh	r3, [r4, #12]
    11d2:	e7b5      	b.n	1140 <__sfvwrite_r+0x160>
    11d4:	6922      	ldr	r2, [r4, #16]
    11d6:	4282      	cmp	r2, r0
    11d8:	d302      	bcc.n	11e0 <__sfvwrite_r+0x200>
    11da:	6962      	ldr	r2, [r4, #20]
    11dc:	4552      	cmp	r2, sl
    11de:	d916      	bls.n	120e <__sfvwrite_r+0x22e>
    11e0:	4553      	cmp	r3, sl
    11e2:	bf28      	it	cs
    11e4:	4653      	movcs	r3, sl
    11e6:	461a      	mov	r2, r3
    11e8:	4649      	mov	r1, r9
    11ea:	461d      	mov	r5, r3
    11ec:	f000 fdca 	bl	1d84 <memmove>
    11f0:	68a3      	ldr	r3, [r4, #8]
    11f2:	6822      	ldr	r2, [r4, #0]
    11f4:	1b5b      	subs	r3, r3, r5
    11f6:	442a      	add	r2, r5
    11f8:	60a3      	str	r3, [r4, #8]
    11fa:	6022      	str	r2, [r4, #0]
    11fc:	2b00      	cmp	r3, #0
    11fe:	d1ce      	bne.n	119e <__sfvwrite_r+0x1be>
    1200:	4621      	mov	r1, r4
    1202:	4638      	mov	r0, r7
    1204:	f7ff fe24 	bl	e50 <_fflush_r>
    1208:	2800      	cmp	r0, #0
    120a:	d0c8      	beq.n	119e <__sfvwrite_r+0x1be>
    120c:	e79a      	b.n	1144 <__sfvwrite_r+0x164>
    120e:	4b1a      	ldr	r3, [pc, #104]	; (1278 <__sfvwrite_r+0x298>)
    1210:	6a65      	ldr	r5, [r4, #36]	; 0x24
    1212:	69e1      	ldr	r1, [r4, #28]
    1214:	459a      	cmp	sl, r3
    1216:	bf94      	ite	ls
    1218:	4653      	movls	r3, sl
    121a:	f06f 4300 	mvnhi.w	r3, #2147483648	; 0x80000000
    121e:	4638      	mov	r0, r7
    1220:	fb93 f3f2 	sdiv	r3, r3, r2
    1224:	4353      	muls	r3, r2
    1226:	464a      	mov	r2, r9
    1228:	47a8      	blx	r5
    122a:	1e05      	subs	r5, r0, #0
    122c:	dcb7      	bgt.n	119e <__sfvwrite_r+0x1be>
    122e:	e789      	b.n	1144 <__sfvwrite_r+0x164>
    1230:	e9d6 ab00 	ldrd	sl, fp, [r6]
    1234:	2000      	movs	r0, #0
    1236:	3608      	adds	r6, #8
    1238:	e6f0      	b.n	101c <__sfvwrite_r+0x3c>
    123a:	f10b 0901 	add.w	r9, fp, #1
    123e:	e6fd      	b.n	103c <__sfvwrite_r+0x5c>
    1240:	429a      	cmp	r2, r3
    1242:	dc09      	bgt.n	1258 <__sfvwrite_r+0x278>
    1244:	6a65      	ldr	r5, [r4, #36]	; 0x24
    1246:	69e1      	ldr	r1, [r4, #28]
    1248:	4613      	mov	r3, r2
    124a:	4638      	mov	r0, r7
    124c:	4652      	mov	r2, sl
    124e:	47a8      	blx	r5
    1250:	1e05      	subs	r5, r0, #0
    1252:	f73f af0f 	bgt.w	1074 <__sfvwrite_r+0x94>
    1256:	e775      	b.n	1144 <__sfvwrite_r+0x164>
    1258:	461a      	mov	r2, r3
    125a:	4651      	mov	r1, sl
    125c:	9301      	str	r3, [sp, #4]
    125e:	f000 fd91 	bl	1d84 <memmove>
    1262:	9b01      	ldr	r3, [sp, #4]
    1264:	68a2      	ldr	r2, [r4, #8]
    1266:	1ad2      	subs	r2, r2, r3
    1268:	60a2      	str	r2, [r4, #8]
    126a:	6822      	ldr	r2, [r4, #0]
    126c:	441a      	add	r2, r3
    126e:	6022      	str	r2, [r4, #0]
    1270:	461d      	mov	r5, r3
    1272:	e6ff      	b.n	1074 <__sfvwrite_r+0x94>
    1274:	2001      	movs	r0, #1
    1276:	e707      	b.n	1088 <__sfvwrite_r+0xa8>
    1278:	7ffffffe 	.word	0x7ffffffe
    127c:	7ffffc00 	.word	0x7ffffc00

00001280 <__swhatbuf_r>:
    1280:	b570      	push	{r4, r5, r6, lr}
    1282:	460e      	mov	r6, r1
    1284:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    1288:	2900      	cmp	r1, #0
    128a:	b096      	sub	sp, #88	; 0x58
    128c:	4614      	mov	r4, r2
    128e:	461d      	mov	r5, r3
    1290:	da09      	bge.n	12a6 <__swhatbuf_r+0x26>
    1292:	89b3      	ldrh	r3, [r6, #12]
    1294:	2200      	movs	r2, #0
    1296:	f013 0080 	ands.w	r0, r3, #128	; 0x80
    129a:	602a      	str	r2, [r5, #0]
    129c:	d116      	bne.n	12cc <__swhatbuf_r+0x4c>
    129e:	f44f 6380 	mov.w	r3, #1024	; 0x400
    12a2:	6023      	str	r3, [r4, #0]
    12a4:	e015      	b.n	12d2 <__swhatbuf_r+0x52>
    12a6:	466a      	mov	r2, sp
    12a8:	f000 faf2 	bl	1890 <_fstat_r>
    12ac:	2800      	cmp	r0, #0
    12ae:	dbf0      	blt.n	1292 <__swhatbuf_r+0x12>
    12b0:	9a01      	ldr	r2, [sp, #4]
    12b2:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
    12b6:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
    12ba:	425a      	negs	r2, r3
    12bc:	415a      	adcs	r2, r3
    12be:	f44f 6380 	mov.w	r3, #1024	; 0x400
    12c2:	602a      	str	r2, [r5, #0]
    12c4:	f44f 6000 	mov.w	r0, #2048	; 0x800
    12c8:	6023      	str	r3, [r4, #0]
    12ca:	e002      	b.n	12d2 <__swhatbuf_r+0x52>
    12cc:	2340      	movs	r3, #64	; 0x40
    12ce:	6023      	str	r3, [r4, #0]
    12d0:	4610      	mov	r0, r2
    12d2:	b016      	add	sp, #88	; 0x58
    12d4:	bd70      	pop	{r4, r5, r6, pc}

000012d6 <__smakebuf_r>:
    12d6:	898b      	ldrh	r3, [r1, #12]
    12d8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    12da:	079d      	lsls	r5, r3, #30
    12dc:	4606      	mov	r6, r0
    12de:	460c      	mov	r4, r1
    12e0:	d507      	bpl.n	12f2 <__smakebuf_r+0x1c>
    12e2:	f104 0343 	add.w	r3, r4, #67	; 0x43
    12e6:	6023      	str	r3, [r4, #0]
    12e8:	6123      	str	r3, [r4, #16]
    12ea:	2301      	movs	r3, #1
    12ec:	6163      	str	r3, [r4, #20]
    12ee:	b002      	add	sp, #8
    12f0:	bd70      	pop	{r4, r5, r6, pc}
    12f2:	ab01      	add	r3, sp, #4
    12f4:	466a      	mov	r2, sp
    12f6:	f7ff ffc3 	bl	1280 <__swhatbuf_r>
    12fa:	9900      	ldr	r1, [sp, #0]
    12fc:	4605      	mov	r5, r0
    12fe:	4630      	mov	r0, r6
    1300:	f7fe ffea 	bl	2d8 <_malloc_r>
    1304:	b948      	cbnz	r0, 131a <__smakebuf_r+0x44>
    1306:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    130a:	059a      	lsls	r2, r3, #22
    130c:	d4ef      	bmi.n	12ee <__smakebuf_r+0x18>
    130e:	f023 0303 	bic.w	r3, r3, #3
    1312:	f043 0302 	orr.w	r3, r3, #2
    1316:	81a3      	strh	r3, [r4, #12]
    1318:	e7e3      	b.n	12e2 <__smakebuf_r+0xc>
    131a:	4b0e      	ldr	r3, [pc, #56]	; (1354 <__smakebuf_r+0x7e>)
    131c:	63f3      	str	r3, [r6, #60]	; 0x3c
    131e:	89a3      	ldrh	r3, [r4, #12]
    1320:	6020      	str	r0, [r4, #0]
    1322:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    1326:	81a3      	strh	r3, [r4, #12]
    1328:	9b00      	ldr	r3, [sp, #0]
    132a:	6163      	str	r3, [r4, #20]
    132c:	9b01      	ldr	r3, [sp, #4]
    132e:	6120      	str	r0, [r4, #16]
    1330:	b15b      	cbz	r3, 134a <__smakebuf_r+0x74>
    1332:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    1336:	4630      	mov	r0, r6
    1338:	f000 fabc 	bl	18b4 <_isatty_r>
    133c:	b128      	cbz	r0, 134a <__smakebuf_r+0x74>
    133e:	89a3      	ldrh	r3, [r4, #12]
    1340:	f023 0303 	bic.w	r3, r3, #3
    1344:	f043 0301 	orr.w	r3, r3, #1
    1348:	81a3      	strh	r3, [r4, #12]
    134a:	89a3      	ldrh	r3, [r4, #12]
    134c:	431d      	orrs	r5, r3
    134e:	81a5      	strh	r5, [r4, #12]
    1350:	e7cd      	b.n	12ee <__smakebuf_r+0x18>
    1352:	bf00      	nop
    1354:	00000ee1 	.word	0x00000ee1

00001358 <__ssputs_r>:
    1358:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    135c:	688e      	ldr	r6, [r1, #8]
    135e:	429e      	cmp	r6, r3
    1360:	4682      	mov	sl, r0
    1362:	460c      	mov	r4, r1
    1364:	4691      	mov	r9, r2
    1366:	4698      	mov	r8, r3
    1368:	d838      	bhi.n	13dc <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x54>
    136a:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
    136e:	f41c 6f90 	tst.w	ip, #1152	; 0x480
    1372:	d031      	beq.n	13d8 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x50>
    1374:	6962      	ldr	r2, [r4, #20]
    1376:	6825      	ldr	r5, [r4, #0]
    1378:	6909      	ldr	r1, [r1, #16]
    137a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    137e:	1a6f      	subs	r7, r5, r1
    1380:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
    1384:	3301      	adds	r3, #1
    1386:	1055      	asrs	r5, r2, #1
    1388:	443b      	add	r3, r7
    138a:	429d      	cmp	r5, r3
    138c:	bf38      	it	cc
    138e:	461d      	movcc	r5, r3
    1390:	f41c 6f80 	tst.w	ip, #1024	; 0x400
    1394:	d030      	beq.n	13f8 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x70>
    1396:	4629      	mov	r1, r5
    1398:	f7fe ff9e 	bl	2d8 <_malloc_r>
    139c:	4606      	mov	r6, r0
    139e:	b950      	cbnz	r0, 13b6 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2e>
    13a0:	230c      	movs	r3, #12
    13a2:	f8ca 3000 	str.w	r3, [sl]
    13a6:	89a3      	ldrh	r3, [r4, #12]
    13a8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    13ac:	81a3      	strh	r3, [r4, #12]
    13ae:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    13b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    13b6:	463a      	mov	r2, r7
    13b8:	6921      	ldr	r1, [r4, #16]
    13ba:	f000 fc17 	bl	1bec <memcpy>
    13be:	89a3      	ldrh	r3, [r4, #12]
    13c0:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
    13c4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    13c8:	81a3      	strh	r3, [r4, #12]
    13ca:	6126      	str	r6, [r4, #16]
    13cc:	6165      	str	r5, [r4, #20]
    13ce:	443e      	add	r6, r7
    13d0:	1bed      	subs	r5, r5, r7
    13d2:	6026      	str	r6, [r4, #0]
    13d4:	60a5      	str	r5, [r4, #8]
    13d6:	4646      	mov	r6, r8
    13d8:	4546      	cmp	r6, r8
    13da:	d900      	bls.n	13de <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x56>
    13dc:	4646      	mov	r6, r8
    13de:	4632      	mov	r2, r6
    13e0:	4649      	mov	r1, r9
    13e2:	6820      	ldr	r0, [r4, #0]
    13e4:	f000 fcce 	bl	1d84 <memmove>
    13e8:	68a3      	ldr	r3, [r4, #8]
    13ea:	1b9b      	subs	r3, r3, r6
    13ec:	60a3      	str	r3, [r4, #8]
    13ee:	6823      	ldr	r3, [r4, #0]
    13f0:	441e      	add	r6, r3
    13f2:	6026      	str	r6, [r4, #0]
    13f4:	2000      	movs	r0, #0
    13f6:	e7dc      	b.n	13b2 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2a>
    13f8:	462a      	mov	r2, r5
    13fa:	f000 fcdf 	bl	1dbc <_realloc_r>
    13fe:	4606      	mov	r6, r0
    1400:	2800      	cmp	r0, #0
    1402:	d1e2      	bne.n	13ca <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x42>
    1404:	6921      	ldr	r1, [r4, #16]
    1406:	4650      	mov	r0, sl
    1408:	f7fe ff18 	bl	23c <_free_r>
    140c:	e7c8      	b.n	13a0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x18>

0000140e <__ssprint_r>:
    140e:	6893      	ldr	r3, [r2, #8]
    1410:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1414:	4681      	mov	r9, r0
    1416:	460c      	mov	r4, r1
    1418:	4616      	mov	r6, r2
    141a:	2b00      	cmp	r3, #0
    141c:	d05e      	beq.n	14dc <__ssprint_r+0xce>
    141e:	f04f 0b00 	mov.w	fp, #0
    1422:	f8d2 a000 	ldr.w	sl, [r2]
    1426:	465f      	mov	r7, fp
    1428:	b357      	cbz	r7, 1480 <__ssprint_r+0x72>
    142a:	68a3      	ldr	r3, [r4, #8]
    142c:	429f      	cmp	r7, r3
    142e:	d340      	bcc.n	14b2 <__ssprint_r+0xa4>
    1430:	89a2      	ldrh	r2, [r4, #12]
    1432:	f412 6f90 	tst.w	r2, #1152	; 0x480
    1436:	d03c      	beq.n	14b2 <__ssprint_r+0xa4>
    1438:	6825      	ldr	r5, [r4, #0]
    143a:	6921      	ldr	r1, [r4, #16]
    143c:	eba5 0801 	sub.w	r8, r5, r1
    1440:	6965      	ldr	r5, [r4, #20]
    1442:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    1446:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
    144a:	f108 0301 	add.w	r3, r8, #1
    144e:	443b      	add	r3, r7
    1450:	106d      	asrs	r5, r5, #1
    1452:	429d      	cmp	r5, r3
    1454:	bf38      	it	cc
    1456:	461d      	movcc	r5, r3
    1458:	0553      	lsls	r3, r2, #21
    145a:	d544      	bpl.n	14e6 <__ssprint_r+0xd8>
    145c:	4629      	mov	r1, r5
    145e:	4648      	mov	r0, r9
    1460:	f7fe ff3a 	bl	2d8 <_malloc_r>
    1464:	b988      	cbnz	r0, 148a <__ssprint_r+0x7c>
    1466:	230c      	movs	r3, #12
    1468:	f8c9 3000 	str.w	r3, [r9]
    146c:	89a3      	ldrh	r3, [r4, #12]
    146e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    1472:	81a3      	strh	r3, [r4, #12]
    1474:	2300      	movs	r3, #0
    1476:	e9c6 3301 	strd	r3, r3, [r6, #4]
    147a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    147e:	e02f      	b.n	14e0 <__ssprint_r+0xd2>
    1480:	e9da b700 	ldrd	fp, r7, [sl]
    1484:	f10a 0a08 	add.w	sl, sl, #8
    1488:	e7ce      	b.n	1428 <__ssprint_r+0x1a>
    148a:	4642      	mov	r2, r8
    148c:	6921      	ldr	r1, [r4, #16]
    148e:	9001      	str	r0, [sp, #4]
    1490:	f000 fbac 	bl	1bec <memcpy>
    1494:	89a2      	ldrh	r2, [r4, #12]
    1496:	9b01      	ldr	r3, [sp, #4]
    1498:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
    149c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    14a0:	81a2      	strh	r2, [r4, #12]
    14a2:	6123      	str	r3, [r4, #16]
    14a4:	6165      	str	r5, [r4, #20]
    14a6:	4443      	add	r3, r8
    14a8:	eba5 0508 	sub.w	r5, r5, r8
    14ac:	6023      	str	r3, [r4, #0]
    14ae:	60a5      	str	r5, [r4, #8]
    14b0:	463b      	mov	r3, r7
    14b2:	42bb      	cmp	r3, r7
    14b4:	bf28      	it	cs
    14b6:	463b      	movcs	r3, r7
    14b8:	461a      	mov	r2, r3
    14ba:	4659      	mov	r1, fp
    14bc:	6820      	ldr	r0, [r4, #0]
    14be:	9301      	str	r3, [sp, #4]
    14c0:	f000 fc60 	bl	1d84 <memmove>
    14c4:	68a2      	ldr	r2, [r4, #8]
    14c6:	9b01      	ldr	r3, [sp, #4]
    14c8:	1ad2      	subs	r2, r2, r3
    14ca:	60a2      	str	r2, [r4, #8]
    14cc:	6822      	ldr	r2, [r4, #0]
    14ce:	4413      	add	r3, r2
    14d0:	6023      	str	r3, [r4, #0]
    14d2:	68b3      	ldr	r3, [r6, #8]
    14d4:	1bdf      	subs	r7, r3, r7
    14d6:	60b7      	str	r7, [r6, #8]
    14d8:	2f00      	cmp	r7, #0
    14da:	d1d1      	bne.n	1480 <__ssprint_r+0x72>
    14dc:	2000      	movs	r0, #0
    14de:	6070      	str	r0, [r6, #4]
    14e0:	b003      	add	sp, #12
    14e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    14e6:	462a      	mov	r2, r5
    14e8:	4648      	mov	r0, r9
    14ea:	f000 fc67 	bl	1dbc <_realloc_r>
    14ee:	4603      	mov	r3, r0
    14f0:	2800      	cmp	r0, #0
    14f2:	d1d6      	bne.n	14a2 <__ssprint_r+0x94>
    14f4:	6921      	ldr	r1, [r4, #16]
    14f6:	4648      	mov	r0, r9
    14f8:	f7fe fea0 	bl	23c <_free_r>
    14fc:	e7b3      	b.n	1466 <__ssprint_r+0x58>

000014fe <_svfiprintf_r>:
    14fe:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1502:	461e      	mov	r6, r3
    1504:	898b      	ldrh	r3, [r1, #12]
    1506:	061b      	lsls	r3, r3, #24
    1508:	b09d      	sub	sp, #116	; 0x74
    150a:	4607      	mov	r7, r0
    150c:	460d      	mov	r5, r1
    150e:	4614      	mov	r4, r2
    1510:	d50e      	bpl.n	1530 <_svfiprintf_r+0x32>
    1512:	690b      	ldr	r3, [r1, #16]
    1514:	b963      	cbnz	r3, 1530 <_svfiprintf_r+0x32>
    1516:	2140      	movs	r1, #64	; 0x40
    1518:	f7fe fede 	bl	2d8 <_malloc_r>
    151c:	6028      	str	r0, [r5, #0]
    151e:	6128      	str	r0, [r5, #16]
    1520:	b920      	cbnz	r0, 152c <_svfiprintf_r+0x2e>
    1522:	230c      	movs	r3, #12
    1524:	603b      	str	r3, [r7, #0]
    1526:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    152a:	e0c9      	b.n	16c0 <_svfiprintf_r+0x1c2>
    152c:	2340      	movs	r3, #64	; 0x40
    152e:	616b      	str	r3, [r5, #20]
    1530:	2300      	movs	r3, #0
    1532:	9309      	str	r3, [sp, #36]	; 0x24
    1534:	2320      	movs	r3, #32
    1536:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    153a:	f8df 919c 	ldr.w	r9, [pc, #412]	; 16d8 <_svfiprintf_r+0x1da>
    153e:	9603      	str	r6, [sp, #12]
    1540:	2330      	movs	r3, #48	; 0x30
    1542:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    1546:	f04f 0a01 	mov.w	sl, #1
    154a:	4623      	mov	r3, r4
    154c:	461e      	mov	r6, r3
    154e:	f813 2b01 	ldrb.w	r2, [r3], #1
    1552:	b10a      	cbz	r2, 1558 <_svfiprintf_r+0x5a>
    1554:	2a25      	cmp	r2, #37	; 0x25
    1556:	d1f9      	bne.n	154c <_svfiprintf_r+0x4e>
    1558:	ebb6 0b04 	subs.w	fp, r6, r4
    155c:	d00b      	beq.n	1576 <_svfiprintf_r+0x78>
    155e:	465b      	mov	r3, fp
    1560:	4622      	mov	r2, r4
    1562:	4629      	mov	r1, r5
    1564:	4638      	mov	r0, r7
    1566:	f7ff fef7 	bl	1358 <__ssputs_r>
    156a:	3001      	adds	r0, #1
    156c:	f000 80a3 	beq.w	16b6 <_svfiprintf_r+0x1b8>
    1570:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1572:	445b      	add	r3, fp
    1574:	9309      	str	r3, [sp, #36]	; 0x24
    1576:	7833      	ldrb	r3, [r6, #0]
    1578:	2b00      	cmp	r3, #0
    157a:	f000 809c 	beq.w	16b6 <_svfiprintf_r+0x1b8>
    157e:	2300      	movs	r3, #0
    1580:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    1584:	e9cd 2305 	strd	r2, r3, [sp, #20]
    1588:	3601      	adds	r6, #1
    158a:	9304      	str	r3, [sp, #16]
    158c:	9307      	str	r3, [sp, #28]
    158e:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    1592:	931a      	str	r3, [sp, #104]	; 0x68
    1594:	4634      	mov	r4, r6
    1596:	2205      	movs	r2, #5
    1598:	f814 1b01 	ldrb.w	r1, [r4], #1
    159c:	484e      	ldr	r0, [pc, #312]	; (16d8 <_svfiprintf_r+0x1da>)
    159e:	f7fe fd9f 	bl	e0 <memchr>
    15a2:	9b04      	ldr	r3, [sp, #16]
    15a4:	b9c0      	cbnz	r0, 15d8 <_svfiprintf_r+0xda>
    15a6:	06d9      	lsls	r1, r3, #27
    15a8:	bf44      	itt	mi
    15aa:	2220      	movmi	r2, #32
    15ac:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    15b0:	071a      	lsls	r2, r3, #28
    15b2:	bf44      	itt	mi
    15b4:	222b      	movmi	r2, #43	; 0x2b
    15b6:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    15ba:	7832      	ldrb	r2, [r6, #0]
    15bc:	2a2a      	cmp	r2, #42	; 0x2a
    15be:	d013      	beq.n	15e8 <_svfiprintf_r+0xea>
    15c0:	9a07      	ldr	r2, [sp, #28]
    15c2:	4634      	mov	r4, r6
    15c4:	2000      	movs	r0, #0
    15c6:	260a      	movs	r6, #10
    15c8:	4621      	mov	r1, r4
    15ca:	f811 3b01 	ldrb.w	r3, [r1], #1
    15ce:	3b30      	subs	r3, #48	; 0x30
    15d0:	2b09      	cmp	r3, #9
    15d2:	d94b      	bls.n	166c <_svfiprintf_r+0x16e>
    15d4:	b970      	cbnz	r0, 15f4 <_svfiprintf_r+0xf6>
    15d6:	e014      	b.n	1602 <_svfiprintf_r+0x104>
    15d8:	eba0 0009 	sub.w	r0, r0, r9
    15dc:	fa0a f000 	lsl.w	r0, sl, r0
    15e0:	4318      	orrs	r0, r3
    15e2:	9004      	str	r0, [sp, #16]
    15e4:	4626      	mov	r6, r4
    15e6:	e7d5      	b.n	1594 <_svfiprintf_r+0x96>
    15e8:	9a03      	ldr	r2, [sp, #12]
    15ea:	1d11      	adds	r1, r2, #4
    15ec:	6812      	ldr	r2, [r2, #0]
    15ee:	9103      	str	r1, [sp, #12]
    15f0:	2a00      	cmp	r2, #0
    15f2:	db01      	blt.n	15f8 <_svfiprintf_r+0xfa>
    15f4:	9207      	str	r2, [sp, #28]
    15f6:	e004      	b.n	1602 <_svfiprintf_r+0x104>
    15f8:	4252      	negs	r2, r2
    15fa:	f043 0302 	orr.w	r3, r3, #2
    15fe:	9207      	str	r2, [sp, #28]
    1600:	9304      	str	r3, [sp, #16]
    1602:	7823      	ldrb	r3, [r4, #0]
    1604:	2b2e      	cmp	r3, #46	; 0x2e
    1606:	d10c      	bne.n	1622 <_svfiprintf_r+0x124>
    1608:	7863      	ldrb	r3, [r4, #1]
    160a:	2b2a      	cmp	r3, #42	; 0x2a
    160c:	d133      	bne.n	1676 <_svfiprintf_r+0x178>
    160e:	9b03      	ldr	r3, [sp, #12]
    1610:	1d1a      	adds	r2, r3, #4
    1612:	681b      	ldr	r3, [r3, #0]
    1614:	9203      	str	r2, [sp, #12]
    1616:	2b00      	cmp	r3, #0
    1618:	bfb8      	it	lt
    161a:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
    161e:	3402      	adds	r4, #2
    1620:	9305      	str	r3, [sp, #20]
    1622:	4e2e      	ldr	r6, [pc, #184]	; (16dc <_svfiprintf_r+0x1de>)
    1624:	7821      	ldrb	r1, [r4, #0]
    1626:	2203      	movs	r2, #3
    1628:	4630      	mov	r0, r6
    162a:	f7fe fd59 	bl	e0 <memchr>
    162e:	b138      	cbz	r0, 1640 <_svfiprintf_r+0x142>
    1630:	2340      	movs	r3, #64	; 0x40
    1632:	1b80      	subs	r0, r0, r6
    1634:	fa03 f000 	lsl.w	r0, r3, r0
    1638:	9b04      	ldr	r3, [sp, #16]
    163a:	4303      	orrs	r3, r0
    163c:	3401      	adds	r4, #1
    163e:	9304      	str	r3, [sp, #16]
    1640:	f814 1b01 	ldrb.w	r1, [r4], #1
    1644:	4826      	ldr	r0, [pc, #152]	; (16e0 <_svfiprintf_r+0x1e2>)
    1646:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    164a:	2206      	movs	r2, #6
    164c:	f7fe fd48 	bl	e0 <memchr>
    1650:	2800      	cmp	r0, #0
    1652:	d038      	beq.n	16c6 <_svfiprintf_r+0x1c8>
    1654:	4b23      	ldr	r3, [pc, #140]	; (16e4 <_svfiprintf_r+0x1e6>)
    1656:	bb13      	cbnz	r3, 169e <_svfiprintf_r+0x1a0>
    1658:	9b03      	ldr	r3, [sp, #12]
    165a:	3307      	adds	r3, #7
    165c:	f023 0307 	bic.w	r3, r3, #7
    1660:	3308      	adds	r3, #8
    1662:	9303      	str	r3, [sp, #12]
    1664:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1666:	4443      	add	r3, r8
    1668:	9309      	str	r3, [sp, #36]	; 0x24
    166a:	e76e      	b.n	154a <_svfiprintf_r+0x4c>
    166c:	fb06 3202 	mla	r2, r6, r2, r3
    1670:	2001      	movs	r0, #1
    1672:	460c      	mov	r4, r1
    1674:	e7a8      	b.n	15c8 <_svfiprintf_r+0xca>
    1676:	2300      	movs	r3, #0
    1678:	3401      	adds	r4, #1
    167a:	9305      	str	r3, [sp, #20]
    167c:	4619      	mov	r1, r3
    167e:	260a      	movs	r6, #10
    1680:	4620      	mov	r0, r4
    1682:	f810 2b01 	ldrb.w	r2, [r0], #1
    1686:	3a30      	subs	r2, #48	; 0x30
    1688:	2a09      	cmp	r2, #9
    168a:	d903      	bls.n	1694 <_svfiprintf_r+0x196>
    168c:	2b00      	cmp	r3, #0
    168e:	d0c8      	beq.n	1622 <_svfiprintf_r+0x124>
    1690:	9105      	str	r1, [sp, #20]
    1692:	e7c6      	b.n	1622 <_svfiprintf_r+0x124>
    1694:	fb06 2101 	mla	r1, r6, r1, r2
    1698:	2301      	movs	r3, #1
    169a:	4604      	mov	r4, r0
    169c:	e7f0      	b.n	1680 <_svfiprintf_r+0x182>
    169e:	ab03      	add	r3, sp, #12
    16a0:	9300      	str	r3, [sp, #0]
    16a2:	462a      	mov	r2, r5
    16a4:	4b10      	ldr	r3, [pc, #64]	; (16e8 <_svfiprintf_r+0x1ea>)
    16a6:	a904      	add	r1, sp, #16
    16a8:	4638      	mov	r0, r7
    16aa:	f3af 8000 	nop.w
    16ae:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    16b2:	4680      	mov	r8, r0
    16b4:	d1d6      	bne.n	1664 <_svfiprintf_r+0x166>
    16b6:	89ab      	ldrh	r3, [r5, #12]
    16b8:	065b      	lsls	r3, r3, #25
    16ba:	f53f af34 	bmi.w	1526 <_svfiprintf_r+0x28>
    16be:	9809      	ldr	r0, [sp, #36]	; 0x24
    16c0:	b01d      	add	sp, #116	; 0x74
    16c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    16c6:	ab03      	add	r3, sp, #12
    16c8:	9300      	str	r3, [sp, #0]
    16ca:	462a      	mov	r2, r5
    16cc:	4b06      	ldr	r3, [pc, #24]	; (16e8 <_svfiprintf_r+0x1ea>)
    16ce:	a904      	add	r1, sp, #16
    16d0:	4638      	mov	r0, r7
    16d2:	f7ff f802 	bl	6da <_printf_i>
    16d6:	e7ea      	b.n	16ae <_svfiprintf_r+0x1b0>
    16d8:	0006d989 	.word	0x0006d989
    16dc:	0006d98f 	.word	0x0006d98f
    16e0:	0006d993 	.word	0x0006d993
    16e4:	00000000 	.word	0x00000000
    16e8:	00001359 	.word	0x00001359

000016ec <_init_signal_r>:
    16ec:	b538      	push	{r3, r4, r5, lr}
    16ee:	f8d0 4148 	ldr.w	r4, [r0, #328]	; 0x148
    16f2:	4605      	mov	r5, r0
    16f4:	b95c      	cbnz	r4, 170e <_init_signal_r+0x22>
    16f6:	2180      	movs	r1, #128	; 0x80
    16f8:	f7fe fdee 	bl	2d8 <_malloc_r>
    16fc:	f8c5 0148 	str.w	r0, [r5, #328]	; 0x148
    1700:	b138      	cbz	r0, 1712 <_init_signal_r+0x26>
    1702:	1f03      	subs	r3, r0, #4
    1704:	307c      	adds	r0, #124	; 0x7c
    1706:	f843 4f04 	str.w	r4, [r3, #4]!
    170a:	4283      	cmp	r3, r0
    170c:	d1fb      	bne.n	1706 <_init_signal_r+0x1a>
    170e:	2000      	movs	r0, #0
    1710:	bd38      	pop	{r3, r4, r5, pc}
    1712:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1716:	e7fb      	b.n	1710 <_init_signal_r+0x24>

00001718 <_signal_r>:
    1718:	291f      	cmp	r1, #31
    171a:	b570      	push	{r4, r5, r6, lr}
    171c:	4604      	mov	r4, r0
    171e:	460d      	mov	r5, r1
    1720:	4616      	mov	r6, r2
    1722:	d904      	bls.n	172e <_signal_r+0x16>
    1724:	2316      	movs	r3, #22
    1726:	6003      	str	r3, [r0, #0]
    1728:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    172c:	e008      	b.n	1740 <_signal_r+0x28>
    172e:	f8d0 3148 	ldr.w	r3, [r0, #328]	; 0x148
    1732:	b133      	cbz	r3, 1742 <_signal_r+0x2a>
    1734:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
    1738:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
    173c:	f843 6025 	str.w	r6, [r3, r5, lsl #2]
    1740:	bd70      	pop	{r4, r5, r6, pc}
    1742:	f7ff ffd3 	bl	16ec <_init_signal_r>
    1746:	2800      	cmp	r0, #0
    1748:	d0f4      	beq.n	1734 <_signal_r+0x1c>
    174a:	e7ed      	b.n	1728 <_signal_r+0x10>

0000174c <_raise_r>:
    174c:	291f      	cmp	r1, #31
    174e:	b538      	push	{r3, r4, r5, lr}
    1750:	4604      	mov	r4, r0
    1752:	460d      	mov	r5, r1
    1754:	d904      	bls.n	1760 <_raise_r+0x14>
    1756:	2316      	movs	r3, #22
    1758:	6003      	str	r3, [r0, #0]
    175a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    175e:	bd38      	pop	{r3, r4, r5, pc}
    1760:	f8d0 2148 	ldr.w	r2, [r0, #328]	; 0x148
    1764:	b112      	cbz	r2, 176c <_raise_r+0x20>
    1766:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
    176a:	b94b      	cbnz	r3, 1780 <_raise_r+0x34>
    176c:	4620      	mov	r0, r4
    176e:	f000 f86b 	bl	1848 <_getpid_r>
    1772:	462a      	mov	r2, r5
    1774:	4601      	mov	r1, r0
    1776:	4620      	mov	r0, r4
    1778:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    177c:	f000 b852 	b.w	1824 <_kill_r>
    1780:	2b01      	cmp	r3, #1
    1782:	d00a      	beq.n	179a <_raise_r+0x4e>
    1784:	1c59      	adds	r1, r3, #1
    1786:	d103      	bne.n	1790 <_raise_r+0x44>
    1788:	2316      	movs	r3, #22
    178a:	6003      	str	r3, [r0, #0]
    178c:	2001      	movs	r0, #1
    178e:	e7e6      	b.n	175e <_raise_r+0x12>
    1790:	2400      	movs	r4, #0
    1792:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
    1796:	4628      	mov	r0, r5
    1798:	4798      	blx	r3
    179a:	2000      	movs	r0, #0
    179c:	e7df      	b.n	175e <_raise_r+0x12>

0000179e <__sigtramp_r>:
    179e:	291f      	cmp	r1, #31
    17a0:	b538      	push	{r3, r4, r5, lr}
    17a2:	4604      	mov	r4, r0
    17a4:	460d      	mov	r5, r1
    17a6:	d902      	bls.n	17ae <__sigtramp_r+0x10>
    17a8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    17ac:	bd38      	pop	{r3, r4, r5, pc}
    17ae:	f8d0 3148 	ldr.w	r3, [r0, #328]	; 0x148
    17b2:	b133      	cbz	r3, 17c2 <__sigtramp_r+0x24>
    17b4:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
    17b8:	f852 3025 	ldr.w	r3, [r2, r5, lsl #2]
    17bc:	b933      	cbnz	r3, 17cc <__sigtramp_r+0x2e>
    17be:	2001      	movs	r0, #1
    17c0:	e7f4      	b.n	17ac <__sigtramp_r+0xe>
    17c2:	f7ff ff93 	bl	16ec <_init_signal_r>
    17c6:	2800      	cmp	r0, #0
    17c8:	d0f4      	beq.n	17b4 <__sigtramp_r+0x16>
    17ca:	e7ed      	b.n	17a8 <__sigtramp_r+0xa>
    17cc:	1c59      	adds	r1, r3, #1
    17ce:	d008      	beq.n	17e2 <__sigtramp_r+0x44>
    17d0:	2b01      	cmp	r3, #1
    17d2:	d008      	beq.n	17e6 <__sigtramp_r+0x48>
    17d4:	2400      	movs	r4, #0
    17d6:	4628      	mov	r0, r5
    17d8:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
    17dc:	4798      	blx	r3
    17de:	4620      	mov	r0, r4
    17e0:	e7e4      	b.n	17ac <__sigtramp_r+0xe>
    17e2:	2002      	movs	r0, #2
    17e4:	e7e2      	b.n	17ac <__sigtramp_r+0xe>
    17e6:	2003      	movs	r0, #3
    17e8:	e7e0      	b.n	17ac <__sigtramp_r+0xe>

000017ea <raise>:
    17ea:	4b02      	ldr	r3, [pc, #8]	; (17f4 <raise+0xa>)
    17ec:	4601      	mov	r1, r0
    17ee:	6818      	ldr	r0, [r3, #0]
    17f0:	f7ff bfac 	b.w	174c <_raise_r>
    17f4:	2000e248 	.word	0x2000e248

000017f8 <signal>:
    17f8:	4b02      	ldr	r3, [pc, #8]	; (1804 <signal+0xc>)
    17fa:	460a      	mov	r2, r1
    17fc:	4601      	mov	r1, r0
    17fe:	6818      	ldr	r0, [r3, #0]
    1800:	f7ff bf8a 	b.w	1718 <_signal_r>
    1804:	2000e248 	.word	0x2000e248

00001808 <_init_signal>:
    1808:	4b01      	ldr	r3, [pc, #4]	; (1810 <_init_signal+0x8>)
    180a:	6818      	ldr	r0, [r3, #0]
    180c:	f7ff bf6e 	b.w	16ec <_init_signal_r>
    1810:	2000e248 	.word	0x2000e248

00001814 <__sigtramp>:
    1814:	4b02      	ldr	r3, [pc, #8]	; (1820 <__sigtramp+0xc>)
    1816:	4601      	mov	r1, r0
    1818:	6818      	ldr	r0, [r3, #0]
    181a:	f7ff bfc0 	b.w	179e <__sigtramp_r>
    181e:	bf00      	nop
    1820:	2000e248 	.word	0x2000e248

00001824 <_kill_r>:
    1824:	b538      	push	{r3, r4, r5, lr}
    1826:	4c07      	ldr	r4, [pc, #28]	; (1844 <_kill_r+0x20>)
    1828:	2300      	movs	r3, #0
    182a:	4605      	mov	r5, r0
    182c:	4608      	mov	r0, r1
    182e:	4611      	mov	r1, r2
    1830:	6023      	str	r3, [r4, #0]
    1832:	f020 fb58 	bl	21ee6 <_kill>
    1836:	1c43      	adds	r3, r0, #1
    1838:	d102      	bne.n	1840 <_kill_r+0x1c>
    183a:	6823      	ldr	r3, [r4, #0]
    183c:	b103      	cbz	r3, 1840 <_kill_r+0x1c>
    183e:	602b      	str	r3, [r5, #0]
    1840:	bd38      	pop	{r3, r4, r5, pc}
    1842:	bf00      	nop
    1844:	2000abe8 	.word	0x2000abe8

00001848 <_getpid_r>:
    1848:	f020 bb4f 	b.w	21eea <_getpid>

0000184c <_write_r>:
    184c:	b538      	push	{r3, r4, r5, lr}
    184e:	4c07      	ldr	r4, [pc, #28]	; (186c <_write_r+0x20>)
    1850:	4605      	mov	r5, r0
    1852:	4608      	mov	r0, r1
    1854:	4611      	mov	r1, r2
    1856:	2200      	movs	r2, #0
    1858:	6022      	str	r2, [r4, #0]
    185a:	461a      	mov	r2, r3
    185c:	f020 fb38 	bl	21ed0 <_write>
    1860:	1c43      	adds	r3, r0, #1
    1862:	d102      	bne.n	186a <_write_r+0x1e>
    1864:	6823      	ldr	r3, [r4, #0]
    1866:	b103      	cbz	r3, 186a <_write_r+0x1e>
    1868:	602b      	str	r3, [r5, #0]
    186a:	bd38      	pop	{r3, r4, r5, pc}
    186c:	2000abe8 	.word	0x2000abe8

00001870 <_close_r>:
    1870:	b538      	push	{r3, r4, r5, lr}
    1872:	4c06      	ldr	r4, [pc, #24]	; (188c <_close_r+0x1c>)
    1874:	2300      	movs	r3, #0
    1876:	4605      	mov	r5, r0
    1878:	4608      	mov	r0, r1
    187a:	6023      	str	r3, [r4, #0]
    187c:	f020 fb2c 	bl	21ed8 <_close>
    1880:	1c43      	adds	r3, r0, #1
    1882:	d102      	bne.n	188a <_close_r+0x1a>
    1884:	6823      	ldr	r3, [r4, #0]
    1886:	b103      	cbz	r3, 188a <_close_r+0x1a>
    1888:	602b      	str	r3, [r5, #0]
    188a:	bd38      	pop	{r3, r4, r5, pc}
    188c:	2000abe8 	.word	0x2000abe8

00001890 <_fstat_r>:
    1890:	b538      	push	{r3, r4, r5, lr}
    1892:	4c07      	ldr	r4, [pc, #28]	; (18b0 <_fstat_r+0x20>)
    1894:	2300      	movs	r3, #0
    1896:	4605      	mov	r5, r0
    1898:	4608      	mov	r0, r1
    189a:	4611      	mov	r1, r2
    189c:	6023      	str	r3, [r4, #0]
    189e:	f020 fb26 	bl	21eee <_fstat>
    18a2:	1c43      	adds	r3, r0, #1
    18a4:	d102      	bne.n	18ac <_fstat_r+0x1c>
    18a6:	6823      	ldr	r3, [r4, #0]
    18a8:	b103      	cbz	r3, 18ac <_fstat_r+0x1c>
    18aa:	602b      	str	r3, [r5, #0]
    18ac:	bd38      	pop	{r3, r4, r5, pc}
    18ae:	bf00      	nop
    18b0:	2000abe8 	.word	0x2000abe8

000018b4 <_isatty_r>:
    18b4:	b538      	push	{r3, r4, r5, lr}
    18b6:	4c06      	ldr	r4, [pc, #24]	; (18d0 <_isatty_r+0x1c>)
    18b8:	2300      	movs	r3, #0
    18ba:	4605      	mov	r5, r0
    18bc:	4608      	mov	r0, r1
    18be:	6023      	str	r3, [r4, #0]
    18c0:	f020 fb0f 	bl	21ee2 <_isatty>
    18c4:	1c43      	adds	r3, r0, #1
    18c6:	d102      	bne.n	18ce <_isatty_r+0x1a>
    18c8:	6823      	ldr	r3, [r4, #0]
    18ca:	b103      	cbz	r3, 18ce <_isatty_r+0x1a>
    18cc:	602b      	str	r3, [r5, #0]
    18ce:	bd38      	pop	{r3, r4, r5, pc}
    18d0:	2000abe8 	.word	0x2000abe8

000018d4 <_lseek_r>:
    18d4:	b538      	push	{r3, r4, r5, lr}
    18d6:	4c07      	ldr	r4, [pc, #28]	; (18f4 <_lseek_r+0x20>)
    18d8:	4605      	mov	r5, r0
    18da:	4608      	mov	r0, r1
    18dc:	4611      	mov	r1, r2
    18de:	2200      	movs	r2, #0
    18e0:	6022      	str	r2, [r4, #0]
    18e2:	461a      	mov	r2, r3
    18e4:	f020 fafb 	bl	21ede <_lseek>
    18e8:	1c43      	adds	r3, r0, #1
    18ea:	d102      	bne.n	18f2 <_lseek_r+0x1e>
    18ec:	6823      	ldr	r3, [r4, #0]
    18ee:	b103      	cbz	r3, 18f2 <_lseek_r+0x1e>
    18f0:	602b      	str	r3, [r5, #0]
    18f2:	bd38      	pop	{r3, r4, r5, pc}
    18f4:	2000abe8 	.word	0x2000abe8

000018f8 <_read_r>:
    18f8:	b538      	push	{r3, r4, r5, lr}
    18fa:	4c07      	ldr	r4, [pc, #28]	; (1918 <_read_r+0x20>)
    18fc:	4605      	mov	r5, r0
    18fe:	4608      	mov	r0, r1
    1900:	4611      	mov	r1, r2
    1902:	2200      	movs	r2, #0
    1904:	6022      	str	r2, [r4, #0]
    1906:	461a      	mov	r2, r3
    1908:	f020 fade 	bl	21ec8 <_read>
    190c:	1c43      	adds	r3, r0, #1
    190e:	d102      	bne.n	1916 <_read_r+0x1e>
    1910:	6823      	ldr	r3, [r4, #0]
    1912:	b103      	cbz	r3, 1916 <_read_r+0x1e>
    1914:	602b      	str	r3, [r5, #0]
    1916:	bd38      	pop	{r3, r4, r5, pc}
    1918:	2000abe8 	.word	0x2000abe8

0000191c <__udivmoddi4>:
    191c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1920:	9f09      	ldr	r7, [sp, #36]	; 0x24
    1922:	4615      	mov	r5, r2
    1924:	4604      	mov	r4, r0
    1926:	468e      	mov	lr, r1
    1928:	461e      	mov	r6, r3
    192a:	2b00      	cmp	r3, #0
    192c:	f040 80cc 	bne.w	1ac8 <__udivmoddi4+0x1ac>
    1930:	428a      	cmp	r2, r1
    1932:	fab2 fc82 	clz	ip, r2
    1936:	d94c      	bls.n	19d2 <__udivmoddi4+0xb6>
    1938:	f1bc 0f00 	cmp.w	ip, #0
    193c:	d00b      	beq.n	1956 <__udivmoddi4+0x3a>
    193e:	f1cc 0820 	rsb	r8, ip, #32
    1942:	fa01 fe0c 	lsl.w	lr, r1, ip
    1946:	fa20 f808 	lsr.w	r8, r0, r8
    194a:	fa02 f50c 	lsl.w	r5, r2, ip
    194e:	ea48 0e0e 	orr.w	lr, r8, lr
    1952:	fa00 f40c 	lsl.w	r4, r0, ip
    1956:	ea4f 4915 	mov.w	r9, r5, lsr #16
    195a:	fa1f f885 	uxth.w	r8, r5
    195e:	fbbe faf9 	udiv	sl, lr, r9
    1962:	0c21      	lsrs	r1, r4, #16
    1964:	fb09 e31a 	mls	r3, r9, sl, lr
    1968:	fb0a fb08 	mul.w	fp, sl, r8
    196c:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
    1970:	459b      	cmp	fp, r3
    1972:	d92a      	bls.n	19ca <__udivmoddi4+0xae>
    1974:	18eb      	adds	r3, r5, r3
    1976:	f10a 30ff 	add.w	r0, sl, #4294967295	; 0xffffffff
    197a:	d204      	bcs.n	1986 <__udivmoddi4+0x6a>
    197c:	459b      	cmp	fp, r3
    197e:	d902      	bls.n	1986 <__udivmoddi4+0x6a>
    1980:	f1aa 0002 	sub.w	r0, sl, #2
    1984:	442b      	add	r3, r5
    1986:	eba3 030b 	sub.w	r3, r3, fp
    198a:	b2a4      	uxth	r4, r4
    198c:	fbb3 f2f9 	udiv	r2, r3, r9
    1990:	fb09 3312 	mls	r3, r9, r2, r3
    1994:	fb02 f808 	mul.w	r8, r2, r8
    1998:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    199c:	45a0      	cmp	r8, r4
    199e:	d916      	bls.n	19ce <__udivmoddi4+0xb2>
    19a0:	192c      	adds	r4, r5, r4
    19a2:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
    19a6:	d203      	bcs.n	19b0 <__udivmoddi4+0x94>
    19a8:	45a0      	cmp	r8, r4
    19aa:	d901      	bls.n	19b0 <__udivmoddi4+0x94>
    19ac:	1e93      	subs	r3, r2, #2
    19ae:	442c      	add	r4, r5
    19b0:	eba4 0408 	sub.w	r4, r4, r8
    19b4:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    19b8:	b127      	cbz	r7, 19c4 <__udivmoddi4+0xa8>
    19ba:	fa24 f40c 	lsr.w	r4, r4, ip
    19be:	2300      	movs	r3, #0
    19c0:	603c      	str	r4, [r7, #0]
    19c2:	607b      	str	r3, [r7, #4]
    19c4:	4631      	mov	r1, r6
    19c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    19ca:	4650      	mov	r0, sl
    19cc:	e7db      	b.n	1986 <__udivmoddi4+0x6a>
    19ce:	4613      	mov	r3, r2
    19d0:	e7ee      	b.n	19b0 <__udivmoddi4+0x94>
    19d2:	b902      	cbnz	r2, 19d6 <__udivmoddi4+0xba>
    19d4:	deff      	udf	#255	; 0xff
    19d6:	f1bc 0f00 	cmp.w	ip, #0
    19da:	d12e      	bne.n	1a3a <__udivmoddi4+0x11e>
    19dc:	1a8b      	subs	r3, r1, r2
    19de:	2601      	movs	r6, #1
    19e0:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    19e4:	b2aa      	uxth	r2, r5
    19e6:	fbb3 f8fe 	udiv	r8, r3, lr
    19ea:	0c21      	lsrs	r1, r4, #16
    19ec:	fb0e 3318 	mls	r3, lr, r8, r3
    19f0:	fb08 f902 	mul.w	r9, r8, r2
    19f4:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
    19f8:	4599      	cmp	r9, r3
    19fa:	d961      	bls.n	1ac0 <__udivmoddi4+0x1a4>
    19fc:	18eb      	adds	r3, r5, r3
    19fe:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
    1a02:	d204      	bcs.n	1a0e <__udivmoddi4+0xf2>
    1a04:	4599      	cmp	r9, r3
    1a06:	d902      	bls.n	1a0e <__udivmoddi4+0xf2>
    1a08:	f1a8 0002 	sub.w	r0, r8, #2
    1a0c:	442b      	add	r3, r5
    1a0e:	eba3 0309 	sub.w	r3, r3, r9
    1a12:	b2a4      	uxth	r4, r4
    1a14:	fbb3 f1fe 	udiv	r1, r3, lr
    1a18:	fb0e 3311 	mls	r3, lr, r1, r3
    1a1c:	434a      	muls	r2, r1
    1a1e:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    1a22:	42a2      	cmp	r2, r4
    1a24:	d94e      	bls.n	1ac4 <__udivmoddi4+0x1a8>
    1a26:	192c      	adds	r4, r5, r4
    1a28:	f101 33ff 	add.w	r3, r1, #4294967295	; 0xffffffff
    1a2c:	d203      	bcs.n	1a36 <__udivmoddi4+0x11a>
    1a2e:	42a2      	cmp	r2, r4
    1a30:	d901      	bls.n	1a36 <__udivmoddi4+0x11a>
    1a32:	1e8b      	subs	r3, r1, #2
    1a34:	442c      	add	r4, r5
    1a36:	1aa4      	subs	r4, r4, r2
    1a38:	e7bc      	b.n	19b4 <__udivmoddi4+0x98>
    1a3a:	f1cc 0e20 	rsb	lr, ip, #32
    1a3e:	fa02 f50c 	lsl.w	r5, r2, ip
    1a42:	fa21 f90e 	lsr.w	r9, r1, lr
    1a46:	fa01 f30c 	lsl.w	r3, r1, ip
    1a4a:	fa20 fe0e 	lsr.w	lr, r0, lr
    1a4e:	ea4e 0303 	orr.w	r3, lr, r3
    1a52:	ea4f 4815 	mov.w	r8, r5, lsr #16
    1a56:	fa00 f40c 	lsl.w	r4, r0, ip
    1a5a:	fbb9 f1f8 	udiv	r1, r9, r8
    1a5e:	fa1f fe85 	uxth.w	lr, r5
    1a62:	fb08 9211 	mls	r2, r8, r1, r9
    1a66:	0c18      	lsrs	r0, r3, #16
    1a68:	fb01 f60e 	mul.w	r6, r1, lr
    1a6c:	ea40 4202 	orr.w	r2, r0, r2, lsl #16
    1a70:	4296      	cmp	r6, r2
    1a72:	d921      	bls.n	1ab8 <__udivmoddi4+0x19c>
    1a74:	18aa      	adds	r2, r5, r2
    1a76:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
    1a7a:	d203      	bcs.n	1a84 <__udivmoddi4+0x168>
    1a7c:	4296      	cmp	r6, r2
    1a7e:	d901      	bls.n	1a84 <__udivmoddi4+0x168>
    1a80:	1e88      	subs	r0, r1, #2
    1a82:	442a      	add	r2, r5
    1a84:	1b92      	subs	r2, r2, r6
    1a86:	b29b      	uxth	r3, r3
    1a88:	fbb2 f9f8 	udiv	r9, r2, r8
    1a8c:	fb08 2219 	mls	r2, r8, r9, r2
    1a90:	fb09 fe0e 	mul.w	lr, r9, lr
    1a94:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    1a98:	459e      	cmp	lr, r3
    1a9a:	d90f      	bls.n	1abc <__udivmoddi4+0x1a0>
    1a9c:	18eb      	adds	r3, r5, r3
    1a9e:	f109 36ff 	add.w	r6, r9, #4294967295	; 0xffffffff
    1aa2:	d204      	bcs.n	1aae <__udivmoddi4+0x192>
    1aa4:	459e      	cmp	lr, r3
    1aa6:	d902      	bls.n	1aae <__udivmoddi4+0x192>
    1aa8:	f1a9 0602 	sub.w	r6, r9, #2
    1aac:	442b      	add	r3, r5
    1aae:	eba3 030e 	sub.w	r3, r3, lr
    1ab2:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
    1ab6:	e793      	b.n	19e0 <__udivmoddi4+0xc4>
    1ab8:	4608      	mov	r0, r1
    1aba:	e7e3      	b.n	1a84 <__udivmoddi4+0x168>
    1abc:	464e      	mov	r6, r9
    1abe:	e7f6      	b.n	1aae <__udivmoddi4+0x192>
    1ac0:	4640      	mov	r0, r8
    1ac2:	e7a4      	b.n	1a0e <__udivmoddi4+0xf2>
    1ac4:	460b      	mov	r3, r1
    1ac6:	e7b6      	b.n	1a36 <__udivmoddi4+0x11a>
    1ac8:	428b      	cmp	r3, r1
    1aca:	d905      	bls.n	1ad8 <__udivmoddi4+0x1bc>
    1acc:	b10f      	cbz	r7, 1ad2 <__udivmoddi4+0x1b6>
    1ace:	e9c7 0100 	strd	r0, r1, [r7]
    1ad2:	2600      	movs	r6, #0
    1ad4:	4630      	mov	r0, r6
    1ad6:	e775      	b.n	19c4 <__udivmoddi4+0xa8>
    1ad8:	fab3 fc83 	clz	ip, r3
    1adc:	f1bc 0f00 	cmp.w	ip, #0
    1ae0:	d10f      	bne.n	1b02 <__udivmoddi4+0x1e6>
    1ae2:	428b      	cmp	r3, r1
    1ae4:	d301      	bcc.n	1aea <__udivmoddi4+0x1ce>
    1ae6:	4282      	cmp	r2, r0
    1ae8:	d809      	bhi.n	1afe <__udivmoddi4+0x1e2>
    1aea:	1a84      	subs	r4, r0, r2
    1aec:	eb61 0e03 	sbc.w	lr, r1, r3
    1af0:	2001      	movs	r0, #1
    1af2:	2f00      	cmp	r7, #0
    1af4:	d06a      	beq.n	1bcc <__udivmoddi4+0x2b0>
    1af6:	e9c7 4e00 	strd	r4, lr, [r7]
    1afa:	2600      	movs	r6, #0
    1afc:	e762      	b.n	19c4 <__udivmoddi4+0xa8>
    1afe:	4660      	mov	r0, ip
    1b00:	e7f7      	b.n	1af2 <__udivmoddi4+0x1d6>
    1b02:	f1cc 0e20 	rsb	lr, ip, #32
    1b06:	fa03 f30c 	lsl.w	r3, r3, ip
    1b0a:	fa22 f50e 	lsr.w	r5, r2, lr
    1b0e:	fa21 f40e 	lsr.w	r4, r1, lr
    1b12:	431d      	orrs	r5, r3
    1b14:	fa01 f30c 	lsl.w	r3, r1, ip
    1b18:	fa20 f10e 	lsr.w	r1, r0, lr
    1b1c:	430b      	orrs	r3, r1
    1b1e:	ea4f 4a15 	mov.w	sl, r5, lsr #16
    1b22:	fa00 f60c 	lsl.w	r6, r0, ip
    1b26:	fbb4 f9fa 	udiv	r9, r4, sl
    1b2a:	fa1f f885 	uxth.w	r8, r5
    1b2e:	fb0a 4019 	mls	r0, sl, r9, r4
    1b32:	0c1c      	lsrs	r4, r3, #16
    1b34:	fb09 f108 	mul.w	r1, r9, r8
    1b38:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
    1b3c:	42a1      	cmp	r1, r4
    1b3e:	fa02 f20c 	lsl.w	r2, r2, ip
    1b42:	d93f      	bls.n	1bc4 <__udivmoddi4+0x2a8>
    1b44:	192c      	adds	r4, r5, r4
    1b46:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
    1b4a:	d204      	bcs.n	1b56 <__udivmoddi4+0x23a>
    1b4c:	42a1      	cmp	r1, r4
    1b4e:	d902      	bls.n	1b56 <__udivmoddi4+0x23a>
    1b50:	f1a9 0002 	sub.w	r0, r9, #2
    1b54:	442c      	add	r4, r5
    1b56:	1a64      	subs	r4, r4, r1
    1b58:	b29b      	uxth	r3, r3
    1b5a:	fbb4 f9fa 	udiv	r9, r4, sl
    1b5e:	fb0a 4419 	mls	r4, sl, r9, r4
    1b62:	fb09 f808 	mul.w	r8, r9, r8
    1b66:	ea43 4104 	orr.w	r1, r3, r4, lsl #16
    1b6a:	4588      	cmp	r8, r1
    1b6c:	d92c      	bls.n	1bc8 <__udivmoddi4+0x2ac>
    1b6e:	1869      	adds	r1, r5, r1
    1b70:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
    1b74:	d204      	bcs.n	1b80 <__udivmoddi4+0x264>
    1b76:	4588      	cmp	r8, r1
    1b78:	d902      	bls.n	1b80 <__udivmoddi4+0x264>
    1b7a:	f1a9 0302 	sub.w	r3, r9, #2
    1b7e:	4429      	add	r1, r5
    1b80:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    1b84:	eba1 0108 	sub.w	r1, r1, r8
    1b88:	fba0 8902 	umull	r8, r9, r0, r2
    1b8c:	4549      	cmp	r1, r9
    1b8e:	46c2      	mov	sl, r8
    1b90:	464c      	mov	r4, r9
    1b92:	d302      	bcc.n	1b9a <__udivmoddi4+0x27e>
    1b94:	d106      	bne.n	1ba4 <__udivmoddi4+0x288>
    1b96:	4546      	cmp	r6, r8
    1b98:	d204      	bcs.n	1ba4 <__udivmoddi4+0x288>
    1b9a:	ebb8 0a02 	subs.w	sl, r8, r2
    1b9e:	eb69 0405 	sbc.w	r4, r9, r5
    1ba2:	3801      	subs	r0, #1
    1ba4:	b197      	cbz	r7, 1bcc <__udivmoddi4+0x2b0>
    1ba6:	ebb6 030a 	subs.w	r3, r6, sl
    1baa:	eb61 0604 	sbc.w	r6, r1, r4
    1bae:	fa06 fe0e 	lsl.w	lr, r6, lr
    1bb2:	fa23 f30c 	lsr.w	r3, r3, ip
    1bb6:	ea4e 0303 	orr.w	r3, lr, r3
    1bba:	fa26 f60c 	lsr.w	r6, r6, ip
    1bbe:	e9c7 3600 	strd	r3, r6, [r7]
    1bc2:	e79a      	b.n	1afa <__udivmoddi4+0x1de>
    1bc4:	4648      	mov	r0, r9
    1bc6:	e7c6      	b.n	1b56 <__udivmoddi4+0x23a>
    1bc8:	464b      	mov	r3, r9
    1bca:	e7d9      	b.n	1b80 <__udivmoddi4+0x264>
    1bcc:	463e      	mov	r6, r7
    1bce:	e6f9      	b.n	19c4 <__udivmoddi4+0xa8>

00001bd0 <memcmp>:
    1bd0:	b530      	push	{r4, r5, lr}
    1bd2:	3901      	subs	r1, #1
    1bd4:	2400      	movs	r4, #0
    1bd6:	42a2      	cmp	r2, r4
    1bd8:	d101      	bne.n	1bde <memcmp+0xe>
    1bda:	2000      	movs	r0, #0
    1bdc:	e005      	b.n	1bea <memcmp+0x1a>
    1bde:	5d03      	ldrb	r3, [r0, r4]
    1be0:	3401      	adds	r4, #1
    1be2:	5d0d      	ldrb	r5, [r1, r4]
    1be4:	42ab      	cmp	r3, r5
    1be6:	d0f6      	beq.n	1bd6 <memcmp+0x6>
    1be8:	1b58      	subs	r0, r3, r5
    1bea:	bd30      	pop	{r4, r5, pc}

00001bec <memcpy>:
    1bec:	440a      	add	r2, r1
    1bee:	4291      	cmp	r1, r2
    1bf0:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
    1bf4:	d100      	bne.n	1bf8 <memcpy+0xc>
    1bf6:	4770      	bx	lr
    1bf8:	b510      	push	{r4, lr}
    1bfa:	f811 4b01 	ldrb.w	r4, [r1], #1
    1bfe:	f803 4f01 	strb.w	r4, [r3, #1]!
    1c02:	4291      	cmp	r1, r2
    1c04:	d1f9      	bne.n	1bfa <memcpy+0xe>
    1c06:	bd10      	pop	{r4, pc}

00001c08 <__memcpy_chk>:
    1c08:	429a      	cmp	r2, r3
    1c0a:	b508      	push	{r3, lr}
    1c0c:	d901      	bls.n	1c12 <__memcpy_chk+0xa>
    1c0e:	f7ff f86d 	bl	cec <__chk_fail>
    1c12:	4281      	cmp	r1, r0
    1c14:	d804      	bhi.n	1c20 <__memcpy_chk+0x18>
    1c16:	188b      	adds	r3, r1, r2
    1c18:	4298      	cmp	r0, r3
    1c1a:	d3f8      	bcc.n	1c0e <__memcpy_chk+0x6>
    1c1c:	4281      	cmp	r1, r0
    1c1e:	d102      	bne.n	1c26 <__memcpy_chk+0x1e>
    1c20:	1883      	adds	r3, r0, r2
    1c22:	4299      	cmp	r1, r3
    1c24:	d3f3      	bcc.n	1c0e <__memcpy_chk+0x6>
    1c26:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    1c2a:	f7ff bfdf 	b.w	1bec <memcpy>

00001c2e <memset>:
    1c2e:	4402      	add	r2, r0
    1c30:	4603      	mov	r3, r0
    1c32:	4293      	cmp	r3, r2
    1c34:	d100      	bne.n	1c38 <memset+0xa>
    1c36:	4770      	bx	lr
    1c38:	f803 1b01 	strb.w	r1, [r3], #1
    1c3c:	e7f9      	b.n	1c32 <memset+0x4>

00001c3e <__memset_chk>:
    1c3e:	429a      	cmp	r2, r3
    1c40:	b508      	push	{r3, lr}
    1c42:	d901      	bls.n	1c48 <__memset_chk+0xa>
    1c44:	f7ff f852 	bl	cec <__chk_fail>
    1c48:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    1c4c:	f7ff bfef 	b.w	1c2e <memset>

00001c50 <__sprintf_chk>:
    1c50:	b408      	push	{r3}
    1c52:	b517      	push	{r0, r1, r2, r4, lr}
    1c54:	ab05      	add	r3, sp, #20
    1c56:	1e14      	subs	r4, r2, #0
    1c58:	f853 1b04 	ldr.w	r1, [r3], #4
    1c5c:	9301      	str	r3, [sp, #4]
    1c5e:	da07      	bge.n	1c70 <__sprintf_chk+0x20>
    1c60:	461a      	mov	r2, r3
    1c62:	f7fe ff9b 	bl	b9c <vsiprintf>
    1c66:	b003      	add	sp, #12
    1c68:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    1c6c:	b001      	add	sp, #4
    1c6e:	4770      	bx	lr
    1c70:	460a      	mov	r2, r1
    1c72:	4621      	mov	r1, r4
    1c74:	f7fe ff6e 	bl	b54 <vsniprintf>
    1c78:	2800      	cmp	r0, #0
    1c7a:	dbf4      	blt.n	1c66 <__sprintf_chk+0x16>
    1c7c:	42a0      	cmp	r0, r4
    1c7e:	d3f2      	bcc.n	1c66 <__sprintf_chk+0x16>
    1c80:	f7ff f834 	bl	cec <__chk_fail>

00001c84 <strcmp>:
    1c84:	f810 2b01 	ldrb.w	r2, [r0], #1
    1c88:	f811 3b01 	ldrb.w	r3, [r1], #1
    1c8c:	2a01      	cmp	r2, #1
    1c8e:	bf28      	it	cs
    1c90:	429a      	cmpcs	r2, r3
    1c92:	d0f7      	beq.n	1c84 <strcmp>
    1c94:	1ad0      	subs	r0, r2, r3
    1c96:	4770      	bx	lr

00001c98 <strcpy>:
    1c98:	4603      	mov	r3, r0
    1c9a:	f811 2b01 	ldrb.w	r2, [r1], #1
    1c9e:	f803 2b01 	strb.w	r2, [r3], #1
    1ca2:	2a00      	cmp	r2, #0
    1ca4:	d1f9      	bne.n	1c9a <strcpy+0x2>
    1ca6:	4770      	bx	lr

00001ca8 <strlen>:
    1ca8:	4603      	mov	r3, r0
    1caa:	f813 2b01 	ldrb.w	r2, [r3], #1
    1cae:	2a00      	cmp	r2, #0
    1cb0:	d1fb      	bne.n	1caa <strlen+0x2>
    1cb2:	1a18      	subs	r0, r3, r0
    1cb4:	3801      	subs	r0, #1
    1cb6:	4770      	bx	lr

00001cb8 <strncmp>:
    1cb8:	b510      	push	{r4, lr}
    1cba:	b16a      	cbz	r2, 1cd8 <strncmp+0x20>
    1cbc:	3901      	subs	r1, #1
    1cbe:	1884      	adds	r4, r0, r2
    1cc0:	f810 3b01 	ldrb.w	r3, [r0], #1
    1cc4:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    1cc8:	4293      	cmp	r3, r2
    1cca:	d103      	bne.n	1cd4 <strncmp+0x1c>
    1ccc:	42a0      	cmp	r0, r4
    1cce:	d001      	beq.n	1cd4 <strncmp+0x1c>
    1cd0:	2b00      	cmp	r3, #0
    1cd2:	d1f5      	bne.n	1cc0 <strncmp+0x8>
    1cd4:	1a98      	subs	r0, r3, r2
    1cd6:	bd10      	pop	{r4, pc}
    1cd8:	4610      	mov	r0, r2
    1cda:	e7fc      	b.n	1cd6 <strncmp+0x1e>

00001cdc <strncpy>:
    1cdc:	b510      	push	{r4, lr}
    1cde:	3901      	subs	r1, #1
    1ce0:	4603      	mov	r3, r0
    1ce2:	b132      	cbz	r2, 1cf2 <strncpy+0x16>
    1ce4:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    1ce8:	f803 4b01 	strb.w	r4, [r3], #1
    1cec:	3a01      	subs	r2, #1
    1cee:	2c00      	cmp	r4, #0
    1cf0:	d1f7      	bne.n	1ce2 <strncpy+0x6>
    1cf2:	441a      	add	r2, r3
    1cf4:	2100      	movs	r1, #0
    1cf6:	4293      	cmp	r3, r2
    1cf8:	d100      	bne.n	1cfc <strncpy+0x20>
    1cfa:	bd10      	pop	{r4, pc}
    1cfc:	f803 1b01 	strb.w	r1, [r3], #1
    1d00:	e7f9      	b.n	1cf6 <strncpy+0x1a>

00001d02 <abort>:
    1d02:	b508      	push	{r3, lr}
    1d04:	2006      	movs	r0, #6
    1d06:	f7ff fd70 	bl	17ea <raise>
    1d0a:	2001      	movs	r0, #1
    1d0c:	f005 fc24 	bl	7558 <_exit>

00001d10 <_fwalk>:
    1d10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1d14:	4688      	mov	r8, r1
    1d16:	f500 74a6 	add.w	r4, r0, #332	; 0x14c
    1d1a:	2600      	movs	r6, #0
    1d1c:	b914      	cbnz	r4, 1d24 <_fwalk+0x14>
    1d1e:	4630      	mov	r0, r6
    1d20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1d24:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
    1d28:	3f01      	subs	r7, #1
    1d2a:	d501      	bpl.n	1d30 <_fwalk+0x20>
    1d2c:	6824      	ldr	r4, [r4, #0]
    1d2e:	e7f5      	b.n	1d1c <_fwalk+0xc>
    1d30:	89ab      	ldrh	r3, [r5, #12]
    1d32:	2b01      	cmp	r3, #1
    1d34:	d906      	bls.n	1d44 <_fwalk+0x34>
    1d36:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
    1d3a:	3301      	adds	r3, #1
    1d3c:	d002      	beq.n	1d44 <_fwalk+0x34>
    1d3e:	4628      	mov	r0, r5
    1d40:	47c0      	blx	r8
    1d42:	4306      	orrs	r6, r0
    1d44:	3564      	adds	r5, #100	; 0x64
    1d46:	e7ef      	b.n	1d28 <_fwalk+0x18>

00001d48 <_fwalk_reent>:
    1d48:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    1d4c:	4680      	mov	r8, r0
    1d4e:	4689      	mov	r9, r1
    1d50:	f500 74a6 	add.w	r4, r0, #332	; 0x14c
    1d54:	2600      	movs	r6, #0
    1d56:	b914      	cbnz	r4, 1d5e <_fwalk_reent+0x16>
    1d58:	4630      	mov	r0, r6
    1d5a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    1d5e:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
    1d62:	3f01      	subs	r7, #1
    1d64:	d501      	bpl.n	1d6a <_fwalk_reent+0x22>
    1d66:	6824      	ldr	r4, [r4, #0]
    1d68:	e7f5      	b.n	1d56 <_fwalk_reent+0xe>
    1d6a:	89ab      	ldrh	r3, [r5, #12]
    1d6c:	2b01      	cmp	r3, #1
    1d6e:	d907      	bls.n	1d80 <_fwalk_reent+0x38>
    1d70:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
    1d74:	3301      	adds	r3, #1
    1d76:	d003      	beq.n	1d80 <_fwalk_reent+0x38>
    1d78:	4629      	mov	r1, r5
    1d7a:	4640      	mov	r0, r8
    1d7c:	47c8      	blx	r9
    1d7e:	4306      	orrs	r6, r0
    1d80:	3564      	adds	r5, #100	; 0x64
    1d82:	e7ee      	b.n	1d62 <_fwalk_reent+0x1a>

00001d84 <memmove>:
    1d84:	4288      	cmp	r0, r1
    1d86:	b510      	push	{r4, lr}
    1d88:	eb01 0302 	add.w	r3, r1, r2
    1d8c:	d902      	bls.n	1d94 <memmove+0x10>
    1d8e:	4283      	cmp	r3, r0
    1d90:	461c      	mov	r4, r3
    1d92:	d807      	bhi.n	1da4 <memmove+0x20>
    1d94:	1e42      	subs	r2, r0, #1
    1d96:	4299      	cmp	r1, r3
    1d98:	d008      	beq.n	1dac <memmove+0x28>
    1d9a:	f811 4b01 	ldrb.w	r4, [r1], #1
    1d9e:	f802 4f01 	strb.w	r4, [r2, #1]!
    1da2:	e7f8      	b.n	1d96 <memmove+0x12>
    1da4:	1883      	adds	r3, r0, r2
    1da6:	1a9a      	subs	r2, r3, r2
    1da8:	429a      	cmp	r2, r3
    1daa:	d100      	bne.n	1dae <memmove+0x2a>
    1dac:	bd10      	pop	{r4, pc}
    1dae:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
    1db2:	f803 1d01 	strb.w	r1, [r3, #-1]!
    1db6:	e7f7      	b.n	1da8 <memmove+0x24>

00001db8 <__malloc_lock>:
    1db8:	4770      	bx	lr

00001dba <__malloc_unlock>:
    1dba:	4770      	bx	lr

00001dbc <_realloc_r>:
    1dbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1dbe:	4607      	mov	r7, r0
    1dc0:	4614      	mov	r4, r2
    1dc2:	460e      	mov	r6, r1
    1dc4:	b921      	cbnz	r1, 1dd0 <_realloc_r+0x14>
    1dc6:	4611      	mov	r1, r2
    1dc8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    1dcc:	f7fe ba84 	b.w	2d8 <_malloc_r>
    1dd0:	b922      	cbnz	r2, 1ddc <_realloc_r+0x20>
    1dd2:	f7fe fa33 	bl	23c <_free_r>
    1dd6:	4625      	mov	r5, r4
    1dd8:	4628      	mov	r0, r5
    1dda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1ddc:	f000 f859 	bl	1e92 <_malloc_usable_size_r>
    1de0:	42a0      	cmp	r0, r4
    1de2:	d20f      	bcs.n	1e04 <_realloc_r+0x48>
    1de4:	4621      	mov	r1, r4
    1de6:	4638      	mov	r0, r7
    1de8:	f7fe fa76 	bl	2d8 <_malloc_r>
    1dec:	4605      	mov	r5, r0
    1dee:	2800      	cmp	r0, #0
    1df0:	d0f2      	beq.n	1dd8 <_realloc_r+0x1c>
    1df2:	4631      	mov	r1, r6
    1df4:	4622      	mov	r2, r4
    1df6:	f7ff fef9 	bl	1bec <memcpy>
    1dfa:	4631      	mov	r1, r6
    1dfc:	4638      	mov	r0, r7
    1dfe:	f7fe fa1d 	bl	23c <_free_r>
    1e02:	e7e9      	b.n	1dd8 <_realloc_r+0x1c>
    1e04:	4635      	mov	r5, r6
    1e06:	e7e7      	b.n	1dd8 <_realloc_r+0x1c>

00001e08 <__sread>:
    1e08:	b510      	push	{r4, lr}
    1e0a:	460c      	mov	r4, r1
    1e0c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    1e10:	f7ff fd72 	bl	18f8 <_read_r>
    1e14:	2800      	cmp	r0, #0
    1e16:	bfab      	itete	ge
    1e18:	6d23      	ldrge	r3, [r4, #80]	; 0x50
    1e1a:	89a3      	ldrhlt	r3, [r4, #12]
    1e1c:	181b      	addge	r3, r3, r0
    1e1e:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
    1e22:	bfac      	ite	ge
    1e24:	6523      	strge	r3, [r4, #80]	; 0x50
    1e26:	81a3      	strhlt	r3, [r4, #12]
    1e28:	bd10      	pop	{r4, pc}

00001e2a <__seofread>:
    1e2a:	2000      	movs	r0, #0
    1e2c:	4770      	bx	lr

00001e2e <__swrite>:
    1e2e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1e32:	461f      	mov	r7, r3
    1e34:	898b      	ldrh	r3, [r1, #12]
    1e36:	05db      	lsls	r3, r3, #23
    1e38:	4605      	mov	r5, r0
    1e3a:	460c      	mov	r4, r1
    1e3c:	4616      	mov	r6, r2
    1e3e:	d505      	bpl.n	1e4c <__swrite+0x1e>
    1e40:	2302      	movs	r3, #2
    1e42:	2200      	movs	r2, #0
    1e44:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    1e48:	f7ff fd44 	bl	18d4 <_lseek_r>
    1e4c:	89a3      	ldrh	r3, [r4, #12]
    1e4e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    1e52:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    1e56:	81a3      	strh	r3, [r4, #12]
    1e58:	4632      	mov	r2, r6
    1e5a:	463b      	mov	r3, r7
    1e5c:	4628      	mov	r0, r5
    1e5e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    1e62:	f7ff bcf3 	b.w	184c <_write_r>

00001e66 <__sseek>:
    1e66:	b510      	push	{r4, lr}
    1e68:	460c      	mov	r4, r1
    1e6a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    1e6e:	f7ff fd31 	bl	18d4 <_lseek_r>
    1e72:	1c43      	adds	r3, r0, #1
    1e74:	89a3      	ldrh	r3, [r4, #12]
    1e76:	bf15      	itete	ne
    1e78:	6520      	strne	r0, [r4, #80]	; 0x50
    1e7a:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
    1e7e:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
    1e82:	81a3      	strheq	r3, [r4, #12]
    1e84:	bf18      	it	ne
    1e86:	81a3      	strhne	r3, [r4, #12]
    1e88:	bd10      	pop	{r4, pc}

00001e8a <__sclose>:
    1e8a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    1e8e:	f7ff bcef 	b.w	1870 <_close_r>

00001e92 <_malloc_usable_size_r>:
    1e92:	f851 3c04 	ldr.w	r3, [r1, #-4]
    1e96:	1f18      	subs	r0, r3, #4
    1e98:	2b00      	cmp	r3, #0
    1e9a:	bfbc      	itt	lt
    1e9c:	580b      	ldrlt	r3, [r1, r0]
    1e9e:	18c0      	addlt	r0, r0, r3
    1ea0:	4770      	bx	lr
    1ea2:	0000      	movs	r0, r0
    1ea4:	0000      	movs	r0, r0
	...

00001ea8 <bt_init>:

	bt_dev_show_info();
}

static int bt_init(void)
{
    1ea8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
    1eac:	4d48      	ldr	r5, [pc, #288]	; (1fd0 <bt_init+0x128>)
    1eae:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
    1eb2:	6899      	ldr	r1, [r3, #8]
    1eb4:	f011 0101 	ands.w	r1, r1, #1
{
    1eb8:	b086      	sub	sp, #24
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
    1eba:	d121      	bne.n	1f00 <bt_init+0x58>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
    1ebc:	aa01      	add	r2, sp, #4
    1ebe:	f640 4003 	movw	r0, #3075	; 0xc03
    1ec2:	f006 fe51 	bl	8b68 <bt_hci_cmd_send_sync>
		if (err) {
    1ec6:	4604      	mov	r4, r0
    1ec8:	2800      	cmp	r0, #0
    1eca:	d17c      	bne.n	1fc6 <bt_init+0x11e>
		hci_reset_complete(rsp);
    1ecc:	9b01      	ldr	r3, [sp, #4]
	u8_t status = buf->data[0];
    1ece:	689b      	ldr	r3, [r3, #8]
	if (status) {
    1ed0:	781b      	ldrb	r3, [r3, #0]
    1ed2:	b993      	cbnz	r3, 1efa <bt_init+0x52>
 * @return Value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_get(const atomic_t *target)
{
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    1ed4:	f3bf 8f5b 	dmb	ish
    1ed8:	462b      	mov	r3, r5
    1eda:	f853 2f70 	ldr.w	r2, [r3, #112]!
    1ede:	f3bf 8f5b 	dmb	ish
	flags = (atomic_get(bt_dev.flags) & BT_DEV_PERSISTENT_FLAGS);
    1ee2:	f002 0205 	and.w	r2, r2, #5
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    1ee6:	f3bf 8f5b 	dmb	ish
    1eea:	e853 1f00 	ldrex	r1, [r3]
    1eee:	e843 2000 	strex	r0, r2, [r3]
    1ef2:	2800      	cmp	r0, #0
    1ef4:	d1f9      	bne.n	1eea <bt_init+0x42>
    1ef6:	f3bf 8f5b 	dmb	ish
		net_buf_unref(rsp);
    1efa:	9801      	ldr	r0, [sp, #4]
    1efc:	f017 f8ae 	bl	1905c <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
    1f00:	aa01      	add	r2, sp, #4
    1f02:	2100      	movs	r1, #0
    1f04:	f241 0003 	movw	r0, #4099	; 0x1003
    1f08:	f006 fe2e 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    1f0c:	4604      	mov	r4, r0
    1f0e:	2800      	cmp	r0, #0
    1f10:	d159      	bne.n	1fc6 <bt_init+0x11e>
	read_local_features_complete(rsp);
    1f12:	9a01      	ldr	r2, [sp, #4]
	memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
    1f14:	4e2f      	ldr	r6, [pc, #188]	; (1fd4 <bt_init+0x12c>)
    1f16:	6893      	ldr	r3, [r2, #8]
    1f18:	f853 0f01 	ldr.w	r0, [r3, #1]!
    1f1c:	6859      	ldr	r1, [r3, #4]
    1f1e:	c603      	stmia	r6!, {r0, r1}
	net_buf_unref(rsp);
    1f20:	4610      	mov	r0, r2
    1f22:	f017 f89b 	bl	1905c <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
    1f26:	4621      	mov	r1, r4
    1f28:	aa01      	add	r2, sp, #4
    1f2a:	f241 0001 	movw	r0, #4097	; 0x1001
    1f2e:	f006 fe1b 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    1f32:	4604      	mov	r4, r0
    1f34:	2800      	cmp	r0, #0
    1f36:	d146      	bne.n	1fc6 <bt_init+0x11e>
	read_local_ver_complete(rsp);
    1f38:	9801      	ldr	r0, [sp, #4]
    1f3a:	6883      	ldr	r3, [r0, #8]
	bt_dev.hci_version = rp->hci_version;
    1f3c:	785a      	ldrb	r2, [r3, #1]
    1f3e:	742a      	strb	r2, [r5, #16]
	bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
    1f40:	78d9      	ldrb	r1, [r3, #3]
    1f42:	789a      	ldrb	r2, [r3, #2]
    1f44:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    1f48:	826a      	strh	r2, [r5, #18]
	bt_dev.lmp_version = rp->lmp_version;
    1f4a:	791a      	ldrb	r2, [r3, #4]
    1f4c:	746a      	strb	r2, [r5, #17]
	bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
    1f4e:	7a19      	ldrb	r1, [r3, #8]
    1f50:	79da      	ldrb	r2, [r3, #7]
    1f52:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    1f56:	82aa      	strh	r2, [r5, #20]
	bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
    1f58:	795a      	ldrb	r2, [r3, #5]
    1f5a:	799b      	ldrb	r3, [r3, #6]
    1f5c:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    1f60:	82eb      	strh	r3, [r5, #22]
	net_buf_unref(rsp);
    1f62:	f017 f87b 	bl	1905c <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
    1f66:	4621      	mov	r1, r4
    1f68:	aa01      	add	r2, sp, #4
    1f6a:	f241 0002 	movw	r0, #4098	; 0x1002
    1f6e:	f006 fdfb 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    1f72:	4604      	mov	r4, r0
    1f74:	bb38      	cbnz	r0, 1fc6 <bt_init+0x11e>
	read_supported_commands_complete(rsp);
    1f76:	9f01      	ldr	r7, [sp, #4]
    1f78:	68ba      	ldr	r2, [r7, #8]
	memcpy(bt_dev.supported_commands, rp->commands,
    1f7a:	1c53      	adds	r3, r2, #1
    1f7c:	3241      	adds	r2, #65	; 0x41
    1f7e:	6818      	ldr	r0, [r3, #0]
    1f80:	6859      	ldr	r1, [r3, #4]
    1f82:	4634      	mov	r4, r6
    1f84:	c403      	stmia	r4!, {r0, r1}
    1f86:	3308      	adds	r3, #8
    1f88:	4293      	cmp	r3, r2
    1f8a:	4626      	mov	r6, r4
    1f8c:	d1f7      	bne.n	1f7e <bt_init+0xd6>
		bt_dev.supported_commands[34] |= 0x04;
    1f8e:	f895 3042 	ldrb.w	r3, [r5, #66]	; 0x42
	net_buf_unref(rsp);
    1f92:	4638      	mov	r0, r7
		bt_dev.supported_commands[34] |= 0x04;
    1f94:	f043 0306 	orr.w	r3, r3, #6
    1f98:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
	net_buf_unref(rsp);
    1f9c:	f017 f85e 	bl	1905c <net_buf_unref>
	if (!BT_FEAT_LE(bt_dev.features)) {
    1fa0:	7f2b      	ldrb	r3, [r5, #28]
    1fa2:	0659      	lsls	r1, r3, #25
    1fa4:	d41e      	bmi.n	1fe4 <bt_init+0x13c>
		BT_ERR("Non-LE capable controller detected!");
    1fa6:	2301      	movs	r3, #1
    1fa8:	f04f 0100 	mov.w	r1, #0
    1fac:	f363 0107 	bfi	r1, r3, #0, #8
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
    1fb0:	4a09      	ldr	r2, [pc, #36]	; (1fd8 <bt_init+0x130>)
    1fb2:	4b0a      	ldr	r3, [pc, #40]	; (1fdc <bt_init+0x134>)
    1fb4:	480a      	ldr	r0, [pc, #40]	; (1fe0 <bt_init+0x138>)
    1fb6:	1a9b      	subs	r3, r3, r2
    1fb8:	08db      	lsrs	r3, r3, #3
    1fba:	f363 118f 	bfi	r1, r3, #6, #10
    1fbe:	f01f f83c 	bl	2103a <log_0>
		return -ENODEV;
    1fc2:	f06f 0412 	mvn.w	r4, #18
		atomic_set_bit(bt_dev.flags, BT_DEV_PRESET_ID);
	}

	bt_finalize_init();
	return 0;
}
    1fc6:	4620      	mov	r0, r4
    1fc8:	b006      	add	sp, #24
    1fca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1fce:	bf00      	nop
    1fd0:	2000e4d8 	.word	0x2000e4d8
    1fd4:	2000e4f0 	.word	0x2000e4f0
    1fd8:	00028540 	.word	0x00028540
    1fdc:	00028610 	.word	0x00028610
    1fe0:	00062d9f 	.word	0x00062d9f
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
    1fe4:	aa01      	add	r2, sp, #4
    1fe6:	2100      	movs	r1, #0
    1fe8:	f242 0003 	movw	r0, #8195	; 0x2003
    1fec:	f006 fdbc 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    1ff0:	4604      	mov	r4, r0
    1ff2:	2800      	cmp	r0, #0
    1ff4:	d1e7      	bne.n	1fc6 <bt_init+0x11e>
	read_le_features_complete(rsp);
    1ff6:	9a01      	ldr	r2, [sp, #4]
	memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
    1ff8:	4ebd      	ldr	r6, [pc, #756]	; (22f0 <bt_init+0x448>)
    1ffa:	6893      	ldr	r3, [r2, #8]
    1ffc:	f853 0f01 	ldr.w	r0, [r3, #1]!
    2000:	6859      	ldr	r1, [r3, #4]
    2002:	c603      	stmia	r6!, {r0, r1}
	net_buf_unref(rsp);
    2004:	4610      	mov	r0, r2
    2006:	f017 f829 	bl	1905c <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE,
    200a:	4621      	mov	r1, r4
    200c:	aa01      	add	r2, sp, #4
    200e:	f242 0002 	movw	r0, #8194	; 0x2002
    2012:	f006 fda9 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    2016:	4604      	mov	r4, r0
    2018:	2800      	cmp	r0, #0
    201a:	d1d4      	bne.n	1fc6 <bt_init+0x11e>
	le_read_buffer_size_complete(rsp);
    201c:	9b01      	ldr	r3, [sp, #4]
    201e:	689b      	ldr	r3, [r3, #8]
	bt_dev.le.mtu = sys_le16_to_cpu(rp->le_max_len);
    2020:	f8b3 2001 	ldrh.w	r2, [r3, #1]
    2024:	f8a5 2088 	strh.w	r2, [r5, #136]	; 0x88
    2028:	b291      	uxth	r1, r2
	if (!bt_dev.le.mtu) {
    202a:	b129      	cbz	r1, 2038 <bt_init+0x190>
	k_sem_init(&bt_dev.le.pkts, rp->le_max_num, rp->le_max_num);
    202c:	78da      	ldrb	r2, [r3, #3]
		arch_syscall_invoke3(*(uintptr_t *)&sem, *(uintptr_t *)&initial_count, *(uintptr_t *)&limit, K_SYSCALL_K_SEM_INIT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_init(sem, initial_count, limit);
    202e:	4611      	mov	r1, r2
    2030:	f106 000c 	add.w	r0, r6, #12
    2034:	f025 fee9 	bl	27e0a <z_impl_k_sem_init>
	net_buf_unref(rsp);
    2038:	9801      	ldr	r0, [sp, #4]
    203a:	f017 f80f 	bl	1905c <net_buf_unref>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    203e:	7f2c      	ldrb	r4, [r5, #28]
    2040:	f014 0420 	ands.w	r4, r4, #32
    2044:	f000 80d5 	beq.w	21f2 <bt_init+0x34a>
	if (BT_CMD_LE_STATES(bt_dev.supported_commands)) {
    2048:	f895 303c 	ldrb.w	r3, [r5, #60]	; 0x3c
    204c:	071a      	lsls	r2, r3, #28
    204e:	d511      	bpl.n	2074 <bt_init+0x1cc>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
    2050:	aa01      	add	r2, sp, #4
    2052:	2100      	movs	r1, #0
    2054:	f242 001c 	movw	r0, #8220	; 0x201c
    2058:	f006 fd86 	bl	8b68 <bt_hci_cmd_send_sync>
		if (err) {
    205c:	4604      	mov	r4, r0
    205e:	2800      	cmp	r0, #0
    2060:	d1b1      	bne.n	1fc6 <bt_init+0x11e>
		le_read_supp_states_complete(rsp);
    2062:	9801      	ldr	r0, [sp, #4]
 *
 *  @return 64-bit integer in host endianness.
 */
static inline u64_t sys_get_le64(const u8_t src[8])
{
	return ((u64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
    2064:	6883      	ldr	r3, [r0, #8]
    2066:	f853 2f01 	ldr.w	r2, [r3, #1]!
    206a:	685b      	ldr	r3, [r3, #4]
	bt_dev.le.states = sys_get_le64(rp->le_states);
    206c:	e9c5 2320 	strd	r2, r3, [r5, #128]	; 0x80
		net_buf_unref(rsp);
    2070:	f016 fff4 	bl	1905c <net_buf_unref>
	if (IS_ENABLED(CONFIG_BT_CONN) &&
    2074:	f895 3078 	ldrb.w	r3, [r5, #120]	; 0x78
    2078:	069b      	lsls	r3, r3, #26
    207a:	f100 80d6 	bmi.w	222a <bt_init+0x382>
	if (BT_FEAT_LE_PRIVACY(bt_dev.le.features)) {
    207e:	f895 3078 	ldrb.w	r3, [r5, #120]	; 0x78
    2082:	065f      	lsls	r7, r3, #25
    2084:	f100 80fd 	bmi.w	2282 <bt_init+0x3da>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
    2088:	2108      	movs	r1, #8
    208a:	f242 0001 	movw	r0, #8193	; 0x2001
    208e:	f006 fbf5 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    2092:	4604      	mov	r4, r0
    2094:	2800      	cmp	r0, #0
    2096:	f000 80b3 	beq.w	2200 <bt_init+0x358>
	cp_mask = net_buf_add(buf, sizeof(*cp_mask));
    209a:	2108      	movs	r1, #8
    209c:	4408      	add	r0, r1
    209e:	f022 fe9b 	bl	24dd8 <net_buf_simple_add>
		    BT_FEAT_LE_PRIVACY(bt_dev.le.features)) {
    20a2:	f895 1078 	ldrb.w	r1, [r5, #120]	; 0x78
			mask |= BT_EVT_MASK_LE_CONN_COMPLETE;
    20a6:	f011 0f40 	tst.w	r1, #64	; 0x40
    20aa:	f240 2302 	movw	r3, #514	; 0x202
    20ae:	bf08      	it	eq
    20b0:	2303      	moveq	r3, #3
		if (BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features)) {
    20b2:	078e      	lsls	r6, r1, #30
			mask |= BT_EVT_MASK_LE_CONN_PARAM_REQ;
    20b4:	bf4c      	ite	mi
    20b6:	f043 032c 	orrmi.w	r3, r3, #44	; 0x2c
		mask |= BT_EVT_MASK_LE_REMOTE_FEAT_COMPLETE;
    20ba:	f043 030c 	orrpl.w	r3, r3, #12
	cp_mask = net_buf_add(buf, sizeof(*cp_mask));
    20be:	4602      	mov	r2, r0
		if (IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
    20c0:	0688      	lsls	r0, r1, #26
		if (IS_ENABLED(CONFIG_BT_PHY_UPDATE) &&
    20c2:	f895 0079 	ldrb.w	r0, [r5, #121]	; 0x79
			mask |= BT_EVT_MASK_LE_DATA_LEN_CHANGE;
    20c6:	bf48      	it	mi
    20c8:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
		if (IS_ENABLED(CONFIG_BT_PHY_UPDATE) &&
    20cc:	f010 0f09 	tst.w	r0, #9
			mask |= BT_EVT_MASK_LE_PHY_UPDATE_COMPLETE;
    20d0:	bf18      	it	ne
    20d2:	f443 6300 	orrne.w	r3, r3, #2048	; 0x800
	if (IS_ENABLED(CONFIG_BT_SMP) &&
    20d6:	07c9      	lsls	r1, r1, #31
	if (IS_ENABLED(CONFIG_BT_ECC) &&
    20d8:	f895 1042 	ldrb.w	r1, [r5, #66]	; 0x42
    20dc:	f001 0106 	and.w	r1, r1, #6
		mask |= BT_EVT_MASK_LE_LTK_REQUEST;
    20e0:	bf48      	it	mi
    20e2:	f043 0310 	orrmi.w	r3, r3, #16
	if (IS_ENABLED(CONFIG_BT_ECC) &&
    20e6:	2906      	cmp	r1, #6
		mask |= BT_EVT_MASK_LE_GENERATE_DHKEY_COMPLETE;
    20e8:	bf08      	it	eq
    20ea:	f443 73c0 	orreq.w	r3, r3, #384	; 0x180
	sys_put_le64(mask, cp_mask->events);
    20ee:	4618      	mov	r0, r3
    20f0:	2100      	movs	r1, #0
    20f2:	f020 f9df 	bl	224b4 <sys_put_le64>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
    20f6:	4621      	mov	r1, r4
    20f8:	2200      	movs	r2, #0
    20fa:	f242 0001 	movw	r0, #8193	; 0x2001
    20fe:	f006 fd33 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    2102:	4604      	mov	r4, r0
    2104:	2800      	cmp	r0, #0
    2106:	f47f af5e 	bne.w	1fc6 <bt_init+0x11e>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    210a:	7f2b      	ldrb	r3, [r5, #28]
    210c:	069a      	lsls	r2, r3, #26
    210e:	d41e      	bmi.n	214e <bt_init+0x2a6>
	if (bt_dev.le.mtu) {
    2110:	f8b5 1088 	ldrh.w	r1, [r5, #136]	; 0x88
    2114:	b9d9      	cbnz	r1, 214e <bt_init+0x2a6>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BUFFER_SIZE, NULL, &rsp);
    2116:	aa01      	add	r2, sp, #4
    2118:	f241 0005 	movw	r0, #4101	; 0x1005
    211c:	f006 fd24 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    2120:	4604      	mov	r4, r0
    2122:	2800      	cmp	r0, #0
    2124:	f47f af4f 	bne.w	1fc6 <bt_init+0x11e>
	if (bt_dev.le.mtu) {
    2128:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
    212c:	b963      	cbnz	r3, 2148 <bt_init+0x2a0>
	read_buffer_size_complete(rsp);
    212e:	9b01      	ldr	r3, [sp, #4]
    2130:	689b      	ldr	r3, [r3, #8]
	bt_dev.le.mtu = sys_le16_to_cpu(rp->acl_max_len);
    2132:	785a      	ldrb	r2, [r3, #1]
    2134:	7899      	ldrb	r1, [r3, #2]
    2136:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    213a:	f8a5 2088 	strh.w	r2, [r5, #136]	; 0x88
	k_sem_init(&bt_dev.le.pkts, pkts, pkts);
    213e:	889a      	ldrh	r2, [r3, #4]
    2140:	486c      	ldr	r0, [pc, #432]	; (22f4 <bt_init+0x44c>)
    2142:	4611      	mov	r1, r2
    2144:	f025 fe61 	bl	27e0a <z_impl_k_sem_init>
	net_buf_unref(rsp);
    2148:	9801      	ldr	r0, [sp, #4]
    214a:	f016 ff87 	bl	1905c <net_buf_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
    214e:	2108      	movs	r1, #8
    2150:	f640 4001 	movw	r0, #3073	; 0xc01
    2154:	f006 fb92 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    2158:	4604      	mov	r4, r0
    215a:	2800      	cmp	r0, #0
    215c:	d050      	beq.n	2200 <bt_init+0x358>
	ev = net_buf_add(buf, sizeof(*ev));
    215e:	2108      	movs	r1, #8
    2160:	4408      	add	r0, r1
    2162:	f022 fe39 	bl	24dd8 <net_buf_simple_add>
	if (IS_ENABLED(CONFIG_BT_SMP) &&
    2166:	f895 3078 	ldrb.w	r3, [r5, #120]	; 0x78
    216a:	07db      	lsls	r3, r3, #31
	ev = net_buf_add(buf, sizeof(*ev));
    216c:	4602      	mov	r2, r0
	if (IS_ENABLED(CONFIG_BT_SMP) &&
    216e:	f140 80b5 	bpl.w	22dc <bt_init+0x434>
		mask |= BT_EVT_MASK_ENCRYPT_KEY_REFRESH_COMPLETE;
    2172:	a15d      	add	r1, pc, #372	; (adr r1, 22e8 <bt_init+0x440>)
    2174:	e9d1 0100 	ldrd	r0, r1, [r1]
	sys_put_le64(mask, ev->events);
    2178:	f020 f99c 	bl	224b4 <sys_put_le64>
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
    217c:	4621      	mov	r1, r4
    217e:	2200      	movs	r2, #0
    2180:	f640 4001 	movw	r0, #3073	; 0xc01
    2184:	f006 fcf0 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    2188:	4604      	mov	r4, r0
    218a:	2800      	cmp	r0, #0
    218c:	f47f af1b 	bne.w	1fc6 <bt_init+0x11e>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_VERSION_INFO, NULL, &rsp);
    2190:	4601      	mov	r1, r0
    2192:	466a      	mov	r2, sp
    2194:	f64f 4001 	movw	r0, #64513	; 0xfc01
    2198:	f006 fce6 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    219c:	4e56      	ldr	r6, [pc, #344]	; (22f8 <bt_init+0x450>)
    219e:	4b57      	ldr	r3, [pc, #348]	; (22fc <bt_init+0x454>)
    21a0:	1af6      	subs	r6, r6, r3
    21a2:	f3c6 06c9 	ubfx	r6, r6, #3, #10
    21a6:	2800      	cmp	r0, #0
    21a8:	f000 80b4 	beq.w	2314 <bt_init+0x46c>
		BT_WARN("Vendor HCI extensions not available");
    21ac:	f04f 0100 	mov.w	r1, #0
    21b0:	2302      	movs	r3, #2
    21b2:	f363 0107 	bfi	r1, r3, #0, #8
    21b6:	4852      	ldr	r0, [pc, #328]	; (2300 <bt_init+0x458>)
    21b8:	f366 118f 	bfi	r1, r6, #6, #10
		BT_WARN("Failed to read supported vendor commands");
    21bc:	f01e ff3d 	bl	2103a <log_0>
		err = bt_conn_init();
    21c0:	f009 f80e 	bl	b1e0 <bt_conn_init>
		if (err) {
    21c4:	4604      	mov	r4, r0
    21c6:	2800      	cmp	r0, #0
    21c8:	f47f aefd 	bne.w	1fc6 <bt_init+0x11e>
	k_delayed_work_init(&bt_dev.rpa_update, rpa_timeout);
    21cc:	494d      	ldr	r1, [pc, #308]	; (2304 <bt_init+0x45c>)
    21ce:	484e      	ldr	r0, [pc, #312]	; (2308 <bt_init+0x460>)
    21d0:	f025 fe99 	bl	27f06 <k_delayed_work_init>
		if (!bt_dev.id_count) {
    21d4:	79eb      	ldrb	r3, [r5, #7]
    21d6:	2b00      	cmp	r3, #0
    21d8:	f040 8119 	bne.w	240e <bt_init+0x566>
			BT_INFO("No ID address. App must call settings_load()");
    21dc:	2303      	movs	r3, #3
    21de:	f04f 0100 	mov.w	r1, #0
    21e2:	f363 0107 	bfi	r1, r3, #0, #8
    21e6:	f366 118f 	bfi	r1, r6, #6, #10
    21ea:	4848      	ldr	r0, [pc, #288]	; (230c <bt_init+0x464>)
    21ec:	f01e ff25 	bl	2103a <log_0>
			return 0;
    21f0:	e6e9      	b.n	1fc6 <bt_init+0x11e>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
    21f2:	2102      	movs	r1, #2
    21f4:	f640 406d 	movw	r0, #3181	; 0xc6d
    21f8:	f006 fb40 	bl	887c <bt_hci_cmd_create>
		if (!buf) {
    21fc:	4606      	mov	r6, r0
    21fe:	b910      	cbnz	r0, 2206 <bt_init+0x35e>
		return -ENOBUFS;
    2200:	f06f 0468 	mvn.w	r4, #104	; 0x68
    2204:	e6df      	b.n	1fc6 <bt_init+0x11e>
		cp_le = net_buf_add(buf, sizeof(*cp_le));
    2206:	2102      	movs	r1, #2
    2208:	3008      	adds	r0, #8
    220a:	f022 fde5 	bl	24dd8 <net_buf_simple_add>
		cp_le->le = 0x01;
    220e:	2301      	movs	r3, #1
		cp_le->simul = 0x00;
    2210:	7044      	strb	r4, [r0, #1]
		cp_le->le = 0x01;
    2212:	7003      	strb	r3, [r0, #0]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
    2214:	4622      	mov	r2, r4
    2216:	4631      	mov	r1, r6
    2218:	f640 406d 	movw	r0, #3181	; 0xc6d
    221c:	f006 fca4 	bl	8b68 <bt_hci_cmd_send_sync>
		if (err) {
    2220:	4604      	mov	r4, r0
    2222:	2800      	cmp	r0, #0
    2224:	f43f af10 	beq.w	2048 <bt_init+0x1a0>
    2228:	e6cd      	b.n	1fc6 <bt_init+0x11e>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_MAX_DATA_LEN, NULL,
    222a:	aa01      	add	r2, sp, #4
    222c:	2100      	movs	r1, #0
    222e:	f242 002f 	movw	r0, #8239	; 0x202f
    2232:	f006 fc99 	bl	8b68 <bt_hci_cmd_send_sync>
		if (err) {
    2236:	4604      	mov	r4, r0
    2238:	2800      	cmp	r0, #0
    223a:	f47f aec4 	bne.w	1fc6 <bt_init+0x11e>
		rp = (void *)rsp->data;
    223e:	9801      	ldr	r0, [sp, #4]
    2240:	6883      	ldr	r3, [r0, #8]
		tx_octets = sys_le16_to_cpu(rp->max_tx_octets);
    2242:	f8b3 8001 	ldrh.w	r8, [r3, #1]
		tx_time = sys_le16_to_cpu(rp->max_tx_time);
    2246:	f8b3 7003 	ldrh.w	r7, [r3, #3]
		net_buf_unref(rsp);
    224a:	f016 ff07 	bl	1905c <net_buf_unref>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
    224e:	2104      	movs	r1, #4
    2250:	f242 0024 	movw	r0, #8228	; 0x2024
    2254:	f006 fb12 	bl	887c <bt_hci_cmd_create>
		if (!buf) {
    2258:	4606      	mov	r6, r0
    225a:	2800      	cmp	r0, #0
    225c:	d0d0      	beq.n	2200 <bt_init+0x358>
		cp = net_buf_add(buf, sizeof(*cp));
    225e:	2104      	movs	r1, #4
    2260:	3008      	adds	r0, #8
    2262:	f022 fdb9 	bl	24dd8 <net_buf_simple_add>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
    2266:	4622      	mov	r2, r4
		cp->max_tx_octets = sys_cpu_to_le16(tx_octets);
    2268:	f8a0 8000 	strh.w	r8, [r0]
		cp->max_tx_time = sys_cpu_to_le16(tx_time);
    226c:	8047      	strh	r7, [r0, #2]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
    226e:	4631      	mov	r1, r6
    2270:	f242 0024 	movw	r0, #8228	; 0x2024
    2274:	f006 fc78 	bl	8b68 <bt_hci_cmd_send_sync>
		if (err) {
    2278:	4604      	mov	r4, r0
    227a:	2800      	cmp	r0, #0
    227c:	f43f aeff 	beq.w	207e <bt_init+0x1d6>
    2280:	e6a1      	b.n	1fc6 <bt_init+0x11e>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RPA_TIMEOUT,
    2282:	2102      	movs	r1, #2
    2284:	f242 002e 	movw	r0, #8238	; 0x202e
    2288:	f006 faf8 	bl	887c <bt_hci_cmd_create>
		if (!buf) {
    228c:	4604      	mov	r4, r0
    228e:	2800      	cmp	r0, #0
    2290:	d0b6      	beq.n	2200 <bt_init+0x358>
		cp = net_buf_add(buf, sizeof(*cp));
    2292:	2102      	movs	r1, #2
    2294:	3008      	adds	r0, #8
    2296:	f022 fd9f 	bl	24dd8 <net_buf_simple_add>
		cp->rpa_timeout = sys_cpu_to_le16(CONFIG_BT_RPA_TIMEOUT);
    229a:	f06f 037b 	mvn.w	r3, #123	; 0x7b
    229e:	7003      	strb	r3, [r0, #0]
    22a0:	2303      	movs	r3, #3
    22a2:	7043      	strb	r3, [r0, #1]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RPA_TIMEOUT, buf,
    22a4:	4621      	mov	r1, r4
    22a6:	2200      	movs	r2, #0
    22a8:	f242 002e 	movw	r0, #8238	; 0x202e
    22ac:	f006 fc5c 	bl	8b68 <bt_hci_cmd_send_sync>
		if (err) {
    22b0:	4604      	mov	r4, r0
    22b2:	2800      	cmp	r0, #0
    22b4:	f47f ae87 	bne.w	1fc6 <bt_init+0x11e>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_RL_SIZE, NULL,
    22b8:	4601      	mov	r1, r0
    22ba:	aa01      	add	r2, sp, #4
    22bc:	f242 002a 	movw	r0, #8234	; 0x202a
    22c0:	f006 fc52 	bl	8b68 <bt_hci_cmd_send_sync>
		if (err) {
    22c4:	4604      	mov	r4, r0
    22c6:	2800      	cmp	r0, #0
    22c8:	f47f ae7d 	bne.w	1fc6 <bt_init+0x11e>
		le_read_resolving_list_size_complete(rsp);
    22cc:	9801      	ldr	r0, [sp, #4]
	bt_dev.le.rl_size = rp->rl_size;
    22ce:	6883      	ldr	r3, [r0, #8]
    22d0:	785b      	ldrb	r3, [r3, #1]
    22d2:	f885 30a4 	strb.w	r3, [r5, #164]	; 0xa4
		net_buf_unref(rsp);
    22d6:	f016 fec1 	bl	1905c <net_buf_unref>
    22da:	e6d5      	b.n	2088 <bt_init+0x1e0>
		mask |= BT_EVT_MASK_REMOTE_VERSION_INFO;
    22dc:	480c      	ldr	r0, [pc, #48]	; (2310 <bt_init+0x468>)
    22de:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
    22e2:	e749      	b.n	2178 <bt_init+0x2d0>
    22e4:	f3af 8000 	nop.w
    22e8:	02008890 	.word	0x02008890
    22ec:	20008000 	.word	0x20008000
    22f0:	2000e550 	.word	0x2000e550
    22f4:	2000e564 	.word	0x2000e564
    22f8:	00028610 	.word	0x00028610
    22fc:	00028540 	.word	0x00028540
    2300:	00062dc3 	.word	0x00062dc3
    2304:	00008d09 	.word	0x00008d09
    2308:	2000e5c4 	.word	0x2000e5c4
    230c:	00062e97 	.word	0x00062e97
    2310:	02008810 	.word	0x02008810
	rp.info = (void *)rsp->data;
    2314:	9b00      	ldr	r3, [sp, #0]
	BT_INFO("HW Platform: %s (0x%04x)",
    2316:	4841      	ldr	r0, [pc, #260]	; (241c <bt_init+0x574>)
	rp.info = (void *)rsp->data;
    2318:	689c      	ldr	r4, [r3, #8]
	BT_INFO("HW Platform: %s (0x%04x)",
    231a:	2203      	movs	r2, #3
    231c:	f04f 0300 	mov.w	r3, #0
    2320:	f362 0307 	bfi	r3, r2, #0, #8
    2324:	f8b4 2001 	ldrh.w	r2, [r4, #1]
	if (platform < ARRAY_SIZE(plat_str)) {
    2328:	2a03      	cmp	r2, #3
		return plat_str[platform];
    232a:	bf96      	itet	ls
    232c:	493c      	ldrls	r1, [pc, #240]	; (2420 <bt_init+0x578>)
	return "unknown";
    232e:	493d      	ldrhi	r1, [pc, #244]	; (2424 <bt_init+0x57c>)
		return plat_str[platform];
    2330:	f851 1022 	ldrls.w	r1, [r1, r2, lsl #2]
	BT_INFO("HW Platform: %s (0x%04x)",
    2334:	f366 138f 	bfi	r3, r6, #6, #10
    2338:	f01e fea0 	bl	2107c <log_2>
	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
    233c:	f8b4 1001 	ldrh.w	r1, [r4, #1]
	BT_INFO("HW Variant: %s (0x%04x)",
    2340:	2203      	movs	r2, #3
    2342:	f04f 0300 	mov.w	r3, #0
    2346:	f362 0307 	bfi	r3, r2, #0, #8
	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
    234a:	2902      	cmp	r1, #2
	BT_INFO("HW Variant: %s (0x%04x)",
    234c:	f366 138f 	bfi	r3, r6, #6, #10
    2350:	f8b4 2003 	ldrh.w	r2, [r4, #3]
	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
    2354:	d138      	bne.n	23c8 <bt_init+0x520>
	if (variant < ARRAY_SIZE(nordic_str)) {
    2356:	2a03      	cmp	r2, #3
    2358:	d836      	bhi.n	23c8 <bt_init+0x520>
		return nordic_str[variant];
    235a:	4933      	ldr	r1, [pc, #204]	; (2428 <bt_init+0x580>)
    235c:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
	BT_INFO("HW Variant: %s (0x%04x)",
    2360:	4832      	ldr	r0, [pc, #200]	; (242c <bt_init+0x584>)
    2362:	f01e fe8b 	bl	2107c <log_2>
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
    2366:	2203      	movs	r2, #3
    2368:	f04f 0300 	mov.w	r3, #0
    236c:	f362 0307 	bfi	r3, r2, #0, #8
    2370:	7962      	ldrb	r2, [r4, #5]
    2372:	482f      	ldr	r0, [pc, #188]	; (2430 <bt_init+0x588>)
	if (variant < ARRAY_SIZE(var_str)) {
    2374:	2a03      	cmp	r2, #3
		return var_str[variant];
    2376:	bf96      	itet	ls
    2378:	492e      	ldrls	r1, [pc, #184]	; (2434 <bt_init+0x58c>)
	return "unknown";
    237a:	492a      	ldrhi	r1, [pc, #168]	; (2424 <bt_init+0x57c>)
		return var_str[variant];
    237c:	f851 1022 	ldrls.w	r1, [r1, r2, lsl #2]
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
    2380:	e9cd 1201 	strd	r1, r2, [sp, #4]
    2384:	79a2      	ldrb	r2, [r4, #6]
    2386:	9203      	str	r2, [sp, #12]
    2388:	f8b4 2007 	ldrh.w	r2, [r4, #7]
    238c:	9204      	str	r2, [sp, #16]
    238e:	f8d4 2009 	ldr.w	r2, [r4, #9]
    2392:	9205      	str	r2, [sp, #20]
    2394:	f366 138f 	bfi	r3, r6, #6, #10
    2398:	2205      	movs	r2, #5
    239a:	a901      	add	r1, sp, #4
    239c:	f01e fea1 	bl	210e2 <log_n>
	net_buf_unref(rsp);
    23a0:	9800      	ldr	r0, [sp, #0]
    23a2:	f016 fe5b 	bl	1905c <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_COMMANDS,
    23a6:	466a      	mov	r2, sp
    23a8:	2100      	movs	r1, #0
    23aa:	f64f 4002 	movw	r0, #64514	; 0xfc02
    23ae:	f006 fbdb 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    23b2:	4607      	mov	r7, r0
    23b4:	b150      	cbz	r0, 23cc <bt_init+0x524>
		BT_WARN("Failed to read supported vendor features");
    23b6:	f04f 0100 	mov.w	r1, #0
    23ba:	2302      	movs	r3, #2
    23bc:	f363 0107 	bfi	r1, r3, #0, #8
    23c0:	f366 118f 	bfi	r1, r6, #6, #10
    23c4:	481c      	ldr	r0, [pc, #112]	; (2438 <bt_init+0x590>)
    23c6:	e6f9      	b.n	21bc <bt_init+0x314>
		return "unknown";
    23c8:	4916      	ldr	r1, [pc, #88]	; (2424 <bt_init+0x57c>)
    23ca:	e7c9      	b.n	2360 <bt_init+0x4b8>
	rp.cmds = (void *)rsp->data;
    23cc:	9800      	ldr	r0, [sp, #0]
	memcpy(bt_dev.vs_commands, rp.cmds->commands, BT_DEV_VS_CMDS_MAX);
    23ce:	4c1b      	ldr	r4, [pc, #108]	; (243c <bt_init+0x594>)
    23d0:	6883      	ldr	r3, [r0, #8]
    23d2:	f8b3 3001 	ldrh.w	r3, [r3, #1]
    23d6:	f8a4 3061 	strh.w	r3, [r4, #97]	; 0x61
	net_buf_unref(rsp);
    23da:	f016 fe3f 	bl	1905c <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_FEATURES,
    23de:	466a      	mov	r2, sp
    23e0:	4639      	mov	r1, r7
    23e2:	f64f 4003 	movw	r0, #64515	; 0xfc03
    23e6:	f006 fbbf 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    23ea:	b140      	cbz	r0, 23fe <bt_init+0x556>
		BT_WARN("Failed to read supported vendor commands");
    23ec:	f04f 0100 	mov.w	r1, #0
    23f0:	2302      	movs	r3, #2
    23f2:	f363 0107 	bfi	r1, r3, #0, #8
    23f6:	f366 118f 	bfi	r1, r6, #6, #10
    23fa:	4811      	ldr	r0, [pc, #68]	; (2440 <bt_init+0x598>)
    23fc:	e6de      	b.n	21bc <bt_init+0x314>
	rp.feat = (void *)rsp->data;
    23fe:	9800      	ldr	r0, [sp, #0]
	memcpy(bt_dev.vs_features, rp.feat->features, BT_DEV_VS_FEAT_MAX);
    2400:	6883      	ldr	r3, [r0, #8]
    2402:	785b      	ldrb	r3, [r3, #1]
    2404:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
	net_buf_unref(rsp);
    2408:	f016 fe28 	bl	1905c <net_buf_unref>
	if (err) {
    240c:	e6d8      	b.n	21c0 <bt_init+0x318>
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    240e:	2104      	movs	r1, #4
    2410:	480c      	ldr	r0, [pc, #48]	; (2444 <bt_init+0x59c>)
    2412:	f01f ffea 	bl	223ea <atomic_or>
	bt_finalize_init();
    2416:	f007 f9eb 	bl	97f0 <bt_finalize_init>
	return 0;
    241a:	e5d4      	b.n	1fc6 <bt_init+0x11e>
    241c:	00062de7 	.word	0x00062de7
    2420:	00028ee4 	.word	0x00028ee4
    2424:	00065beb 	.word	0x00065beb
    2428:	00028eac 	.word	0x00028eac
    242c:	00062e00 	.word	0x00062e00
    2430:	00062e18 	.word	0x00062e18
    2434:	00028f14 	.word	0x00028f14
    2438:	00062e45 	.word	0x00062e45
    243c:	2000e4d8 	.word	0x2000e4d8
    2440:	00062e6e 	.word	0x00062e6e
    2444:	2000e548 	.word	0x2000e548

00002448 <ll_adv_enable>:
{
	u32_t ticks_anchor;
#endif /* !CONFIG_BT_HCI_MESH_EXT */
#else /* !CONFIG_BT_CTLR_ADV_EXT || !CONFIG_BT_HCI_MESH_EXT */
u8_t ll_adv_enable(u8_t enable)
{
    2448:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    244c:	b091      	sub	sp, #68	; 0x44
	u16_t const handle = 0;
	u32_t ticks_anchor;
#endif /* !CONFIG_BT_CTLR_ADV_EXT || !CONFIG_BT_HCI_MESH_EXT */
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
    244e:	2302      	movs	r3, #2
    2450:	930f      	str	r3, [sp, #60]	; 0x3c
	u32_t ticks_slot_offset;
	struct ll_adv_set *adv;
	struct lll_adv *lll;
	u32_t ret;

	if (!enable) {
    2452:	b930      	cbnz	r0, 2462 <ll_adv_enable+0x1a>
		return disable(handle);
    2454:	f011 fe10 	bl	14078 <disable.constprop.5>
    2458:	4605      	mov	r5, r0
		conn_release(adv);
	}
#endif /* CONFIG_BT_PERIPHERAL */

	return BT_HCI_ERR_CMD_DISALLOWED;
}
    245a:	4628      	mov	r0, r5
    245c:	b011      	add	sp, #68	; 0x44
    245e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
static inline struct ll_adv_set *is_disabled_get(u16_t handle)
{
	struct ll_adv_set *adv;

	adv = ull_adv_set_get(handle);
	if (!adv || adv->is_enabled) {
    2462:	4e8b      	ldr	r6, [pc, #556]	; (2690 <ll_adv_enable+0x248>)
    2464:	f896 50cc 	ldrb.w	r5, [r6, #204]	; 0xcc
    2468:	f015 0501 	ands.w	r5, r5, #1
    246c:	4634      	mov	r4, r6
    246e:	d001      	beq.n	2474 <ll_adv_enable+0x2c>
	return BT_HCI_ERR_CMD_DISALLOWED;
    2470:	250c      	movs	r5, #12
    2472:	e7f2      	b.n	245a <ll_adv_enable+0x12>
	lll_adv_pdu_enqueue(&lll->scan_rsp, idx);
}

static inline struct pdu_adv *lll_adv_scan_rsp_peek(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
    2474:	f896 807c 	ldrb.w	r8, [r6, #124]	; 0x7c
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    2478:	f896 702c 	ldrb.w	r7, [r6, #44]	; 0x2c
		ull_filter_adv_update(lll->filter_policy);
    247c:	f896 0029 	ldrb.w	r0, [r6, #41]	; 0x29
    2480:	2327      	movs	r3, #39	; 0x27
    2482:	222d      	movs	r2, #45	; 0x2d
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
    2484:	fb03 6808 	mla	r8, r3, r8, r6
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    2488:	fb13 2707 	smlabb	r7, r3, r7, r2
    248c:	f000 0003 	and.w	r0, r0, #3
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
    2490:	f108 037d 	add.w	r3, r8, #125	; 0x7d
    2494:	930b      	str	r3, [sp, #44]	; 0x2c
    2496:	f015 faef 	bl	17a78 <ull_filter_adv_update>
		if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
    249a:	f896 00da 	ldrb.w	r0, [r6, #218]	; 0xda
    249e:	0783      	lsls	r3, r0, #30
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    24a0:	eb06 0907 	add.w	r9, r6, r7
    24a4:	f140 80b6 	bpl.w	2614 <ll_adv_enable+0x1cc>
			rl_idx = ull_filter_rl_find(adv->id_addr_type,
    24a8:	462a      	mov	r2, r5
    24aa:	f106 01dc 	add.w	r1, r6, #220	; 0xdc
    24ae:	f3c0 0080 	ubfx	r0, r0, #2, #1
    24b2:	f015 fb59 	bl	17b68 <ull_filter_rl_find>
			if (rl_idx != FILTER_IDX_NONE) {
    24b6:	28ff      	cmp	r0, #255	; 0xff
			rl_idx = ull_filter_rl_find(adv->id_addr_type,
    24b8:	4682      	mov	sl, r0
			if (rl_idx != FILTER_IDX_NONE) {
    24ba:	d002      	beq.n	24c2 <ll_adv_enable+0x7a>
				ull_filter_rpa_update(false);
    24bc:	4628      	mov	r0, r5
    24be:	f015 fd7d 	bl	17fbc <ull_filter_rpa_update>
			ull_filter_adv_pdu_update(adv, rl_idx, pdu_adv);
    24c2:	464a      	mov	r2, r9
    24c4:	4651      	mov	r1, sl
    24c6:	4872      	ldr	r0, [pc, #456]	; (2690 <ll_adv_enable+0x248>)
    24c8:	f015 fae2 	bl	17a90 <ull_filter_adv_pdu_update>
			ull_filter_adv_pdu_update(adv, rl_idx, pdu_scan);
    24cc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    24ce:	4870      	ldr	r0, [pc, #448]	; (2690 <ll_adv_enable+0x248>)
    24d0:	4651      	mov	r1, sl
    24d2:	f015 fadd 	bl	17a90 <ull_filter_adv_pdu_update>
		if (pdu_adv->tx_addr &&
    24d6:	5df3      	ldrb	r3, [r6, r7]
    24d8:	0658      	lsls	r0, r3, #25
    24da:	f100 80b0 	bmi.w	263e <ll_adv_enable+0x1f6>
	if ((pdu_adv->type == PDU_ADV_TYPE_ADV_IND) ||
    24de:	5df3      	ldrb	r3, [r6, r7]
    24e0:	f013 0f0e 	tst.w	r3, #14
    24e4:	f000 80b5 	beq.w	2652 <ll_adv_enable+0x20a>
	u8_t ch_map = lll->chan_map;
    24e8:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
	adv->rl_idx = rl_idx;
    24ec:	f884 a0db 	strb.w	sl, [r4, #219]	; 0xdb
	u8_t ch_map = lll->chan_map;
    24f0:	f3c3 0342 	ubfx	r3, r3, #1, #3
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
    24f4:	2101      	movs	r1, #1
    24f6:	f10d 003b 	add.w	r0, sp, #59	; 0x3b
	u8_t ch_map = lll->chan_map;
    24fa:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
    24fe:	f021 fdd6 	bl	240ae <util_ones_count_get>
	if (adv_chn_cnt == 0) {
    2502:	2800      	cmp	r0, #0
    2504:	f000 81bf 	beq.w	2886 <ll_adv_enable+0x43e>
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
    2508:	f816 c007 	ldrb.w	ip, [r6, r7]
		const u8_t rsp_data_len = pdu_scan->len;
    250c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
		const u8_t adv_data_len = pdu_adv->len;
    250e:	f899 3001 	ldrb.w	r3, [r9, #1]
		const u8_t rsp_data_len = pdu_scan->len;
    2512:	7852      	ldrb	r2, [r2, #1]
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
    2514:	f00c 0c0f 	and.w	ip, ip, #15
    2518:	f1bc 0f02 	cmp.w	ip, #2
    251c:	f100 31ff 	add.w	r1, r0, #4294967295	; 0xffffffff
    2520:	f040 817c 	bne.w	281c <ll_adv_enable+0x3d4>
			adv_size += adv_data_len;
    2524:	3310      	adds	r3, #16
			slot_us += BYTES2US(adv_size, phy) * adv_chn_cnt +
    2526:	00db      	lsls	r3, r3, #3
    2528:	4358      	muls	r0, r3
    252a:	f500 70aa 	add.w	r0, r0, #340	; 0x154
    252e:	2364      	movs	r3, #100	; 0x64
			slot_us += (BYTES2US(adv_size, phy) + EVENT_IFS_MAX_US
    2530:	fb01 0003 	mla	r0, r1, r3, r0
static inline void lll_hdr_init(void *lll, void *parent)
{
	struct lll_hdr *hdr = lll;

	hdr->parent = parent;
	hdr->is_stop = 0U;
    2534:	f894 3020 	ldrb.w	r3, [r4, #32]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
    2538:	4956      	ldr	r1, [pc, #344]	; (2694 <ll_adv_enable+0x24c>)
	hdr->parent = parent;
    253a:	61e4      	str	r4, [r4, #28]
	return hdr->ref--;
}

static inline void ull_hdr_init(struct ull_hdr *hdr)
{
	hdr->disabled_cb = hdr->disabled_param = NULL;
    253c:	f04f 0800 	mov.w	r8, #0
	hdr->is_stop = 0U;
    2540:	f368 0300 	bfi	r3, r8, #0, #1
    2544:	f884 3020 	strb.w	r3, [r4, #32]
	adv->evt.ticks_xtal_to_start =
    2548:	2331      	movs	r3, #49	; 0x31
    254a:	6023      	str	r3, [r4, #0]
    254c:	e9c4 8805 	strd	r8, r8, [r4, #20]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
    2550:	a34d      	add	r3, pc, #308	; (adr r3, 2688 <ll_adv_enable+0x240>)
    2552:	e9d3 2300 	ldrd	r2, r3, [r3]
	adv->evt.ticks_active_to_start = 0;
    2556:	f8c4 8004 	str.w	r8, [r4, #4]
	adv->evt.ticks_preempt_to_start =
    255a:	f8c4 8008 	str.w	r8, [r4, #8]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
    255e:	fba0 0101 	umull	r0, r1, r0, r1
    2562:	f7fd fe0d 	bl	180 <__aeabi_uldivmod>
    2566:	60e0      	str	r0, [r4, #12]
	u16_t interval = adv->interval;
    2568:	f8b4 90d8 	ldrh.w	r9, [r4, #216]	; 0xd8
	ticks_anchor = ticker_ticks_now_get();
    256c:	f021 fecc 	bl	24308 <ticker_ticks_now_get>
    2570:	4682      	mov	sl, r0
	lll->is_hdcd = !interval && (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND);
    2572:	f1b9 0f00 	cmp.w	r9, #0
    2576:	d109      	bne.n	258c <ll_adv_enable+0x144>
    2578:	f816 8007 	ldrb.w	r8, [r6, r7]
    257c:	f008 080f 	and.w	r8, r8, #15
    2580:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
    2584:	f1d3 0800 	rsbs	r8, r3, #0
    2588:	eb48 0803 	adc.w	r8, r8, r3
    258c:	f894 6028 	ldrb.w	r6, [r4, #40]	; 0x28
    2590:	4a41      	ldr	r2, [pc, #260]	; (2698 <ll_adv_enable+0x250>)
    2592:	68e3      	ldr	r3, [r4, #12]
    2594:	f368 0600 	bfi	r6, r8, #0, #1
    2598:	f8df 8104 	ldr.w	r8, [pc, #260]	; 26a0 <ll_adv_enable+0x258>
    259c:	f884 6028 	strb.w	r6, [r4, #40]	; 0x28
	if (lll->is_hdcd) {
    25a0:	af0f      	add	r7, sp, #60	; 0x3c
    25a2:	f016 0601 	ands.w	r6, r6, #1
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    25a6:	e9cd 8707 	strd	r8, r7, [sp, #28]
    25aa:	e9cd 2405 	strd	r2, r4, [sp, #20]
    25ae:	9304      	str	r3, [sp, #16]
	if (lll->is_hdcd) {
    25b0:	f000 8151 	beq.w	2856 <ll_adv_enable+0x40e>
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    25b4:	2000      	movs	r0, #0
    25b6:	e9cd 0300 	strd	r0, r3, [sp]
    25ba:	2103      	movs	r1, #3
    25bc:	e9cd 0002 	strd	r0, r0, [sp, #8]
    25c0:	4653      	mov	r3, sl
    25c2:	2202      	movs	r2, #2
    25c4:	f00e fcb4 	bl	10f30 <ticker_start>
		ret = ull_ticker_status_take(ret, &ret_cb);
    25c8:	4639      	mov	r1, r7
    25ca:	f010 fcd9 	bl	12f80 <ull_ticker_status_take>
		if (ret != TICKER_STATUS_SUCCESS) {
    25ce:	2800      	cmp	r0, #0
    25d0:	f040 8159 	bne.w	2886 <ll_adv_enable+0x43e>
		ret_cb = TICKER_STATUS_BUSY;
    25d4:	2202      	movs	r2, #2
    25d6:	920f      	str	r2, [sp, #60]	; 0x3c
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    25d8:	e9cd 8707 	strd	r8, r7, [sp, #28]
    25dc:	4a2f      	ldr	r2, [pc, #188]	; (269c <ll_adv_enable+0x254>)
    25de:	9406      	str	r4, [sp, #24]
    25e0:	e9cd 0002 	strd	r0, r0, [sp, #8]
    25e4:	f24a 33d8 	movw	r3, #41944	; 0xa3d8
    25e8:	e9cd 0204 	strd	r0, r2, [sp, #16]
    25ec:	9300      	str	r3, [sp, #0]
    25ee:	9001      	str	r0, [sp, #4]
    25f0:	4653      	mov	r3, sl
    25f2:	2201      	movs	r2, #1
    25f4:	2103      	movs	r1, #3
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    25f6:	f00e fc9b 	bl	10f30 <ticker_start>
	ret = ull_ticker_status_take(ret, &ret_cb);
    25fa:	4639      	mov	r1, r7
    25fc:	f010 fcc0 	bl	12f80 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
    2600:	2800      	cmp	r0, #0
    2602:	f040 8140 	bne.w	2886 <ll_adv_enable+0x43e>
	adv->is_enabled = 1;
    2606:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
    260a:	f043 0301 	orr.w	r3, r3, #1
    260e:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
	return 0;
    2612:	e722      	b.n	245a <ll_adv_enable+0x12>
			u8_t *tx_addr = ll_addr_get(pdu_adv->tx_addr, NULL);
    2614:	5df0      	ldrb	r0, [r6, r7]
    2616:	4629      	mov	r1, r5
    2618:	f3c0 1080 	ubfx	r0, r0, #6, #1
    261c:	f00e fd54 	bl	110c8 <ll_addr_get>
__ ## fun ## _ichk(type1 __restrict dst, type2 __restrict src) { \
	return __builtin___ ## fun ## _chk(dst, src, __ssp_bos0(dst)); \
}

__BEGIN_DECLS
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    2620:	6803      	ldr	r3, [r0, #0]
    2622:	f8c9 3002 	str.w	r3, [r9, #2]
    2626:	8883      	ldrh	r3, [r0, #4]
    2628:	f8a9 3006 	strh.w	r3, [r9, #6]
    262c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    262e:	6803      	ldr	r3, [r0, #0]
    2630:	f8c2 3002 	str.w	r3, [r2, #2]
    2634:	8883      	ldrh	r3, [r0, #4]
    2636:	80d3      	strh	r3, [r2, #6]
	u8_t   rl_idx = FILTER_IDX_NONE;
    2638:	f04f 0aff 	mov.w	sl, #255	; 0xff
    263c:	e74b      	b.n	24d6 <ll_adv_enable+0x8e>
		    !mem_nz(pdu_adv->adv_ind.addr, BDADDR_SIZE)) {
    263e:	2106      	movs	r1, #6
    2640:	f109 0002 	add.w	r0, r9, #2
    2644:	f021 fcfc 	bl	24040 <mem_nz>
		if (pdu_adv->tx_addr &&
    2648:	2800      	cmp	r0, #0
    264a:	f47f af48 	bne.w	24de <ll_adv_enable+0x96>
			return BT_HCI_ERR_INVALID_PARAM;
    264e:	2512      	movs	r5, #18
    2650:	e703      	b.n	245a <ll_adv_enable+0x12>
		if (lll->conn) {
    2652:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2654:	2b00      	cmp	r3, #0
    2656:	f47f af0b 	bne.w	2470 <ll_adv_enable+0x28>
		link = ll_rx_link_alloc();
    265a:	f010 fbe9 	bl	12e30 <ll_rx_link_alloc>
		if (!link) {
    265e:	4683      	mov	fp, r0
    2660:	b130      	cbz	r0, 2670 <ll_adv_enable+0x228>
		node_rx = ll_rx_alloc();
    2662:	f010 fbf1 	bl	12e48 <ll_rx_alloc>
		if (!node_rx) {
    2666:	900c      	str	r0, [sp, #48]	; 0x30
    2668:	b920      	cbnz	r0, 2674 <ll_adv_enable+0x22c>
			ll_rx_link_release(link);
    266a:	4658      	mov	r0, fp
    266c:	f010 fbe6 	bl	12e3c <ll_rx_link_release>
			return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
    2670:	2507      	movs	r5, #7
    2672:	e6f2      	b.n	245a <ll_adv_enable+0x12>
		conn = ll_conn_acquire();
    2674:	f012 fbc8 	bl	14e08 <ll_conn_acquire>
		if (!conn) {
    2678:	4680      	mov	r8, r0
    267a:	b998      	cbnz	r0, 26a4 <ll_adv_enable+0x25c>
			ll_rx_release(node_rx);
    267c:	980c      	ldr	r0, [sp, #48]	; 0x30
    267e:	f010 fbe9 	bl	12e54 <ll_rx_release>
    2682:	e7f2      	b.n	266a <ll_adv_enable+0x222>
    2684:	f3af 8000 	nop.w
    2688:	1afd498d 	.word	0x1afd498d
    268c:	00000007 	.word	0x00000007
    2690:	200011ac 	.word	0x200011ac
    2694:	3b9aca00 	.word	0x3b9aca00
    2698:	00013a75 	.word	0x00013a75
    269c:	00013d69 	.word	0x00013d69
    26a0:	00012f75 	.word	0x00012f75
		conn_lll->handle = 0xFFFF;
    26a4:	f64f 72ff 	movw	r2, #65535	; 0xffff
    26a8:	8582      	strh	r2, [r0, #44]	; 0x2c
		if (!conn_lll->link_tx_free) {
    26aa:	6f82      	ldr	r2, [r0, #120]	; 0x78
		conn_lll = &conn->lll;
    26ac:	f100 031c 	add.w	r3, r0, #28
    26b0:	930d      	str	r3, [sp, #52]	; 0x34
		if (!conn_lll->link_tx_free) {
    26b2:	b912      	cbnz	r2, 26ba <ll_adv_enable+0x272>
			conn_lll->link_tx_free = &conn_lll->link_tx;
    26b4:	f100 0270 	add.w	r2, r0, #112	; 0x70
    26b8:	6782      	str	r2, [r0, #120]	; 0x78
		memq_init(conn_lll->link_tx_free, &conn_lll->memq_tx.head,
    26ba:	f108 026c 	add.w	r2, r8, #108	; 0x6c
    26be:	f108 0168 	add.w	r1, r8, #104	; 0x68
    26c2:	f8d8 0078 	ldr.w	r0, [r8, #120]	; 0x78
    26c6:	f021 fcc6 	bl	24056 <memq_init>
		conn_lll->max_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0);
    26ca:	4a75      	ldr	r2, [pc, #468]	; (28a0 <ll_adv_enable+0x458>)
		conn->llcp_terminate.node_rx.hdr.link = link;
    26cc:	f8c8 b12c 	str.w	fp, [r8, #300]	; 0x12c
		conn_lll->max_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0);
    26d0:	f04f 111b 	mov.w	r1, #1769499	; 0x1b001b
    26d4:	e9c8 1217 	strd	r1, r2, [r8, #92]	; 0x5c
		conn_lll->phy_tx = BIT(0);
    26d8:	f8b8 2064 	ldrh.w	r2, [r8, #100]	; 0x64
		conn_lll->slave.latency_enabled = 0;
    26dc:	f898 1040 	ldrb.w	r1, [r8, #64]	; 0x40
		conn_lll->phy_tx = BIT(0);
    26e0:	f422 62ef 	bic.w	r2, r2, #1912	; 0x778
    26e4:	f022 0207 	bic.w	r2, r2, #7
    26e8:	f442 7288 	orr.w	r2, r2, #272	; 0x110
    26ec:	f042 0201 	orr.w	r2, r2, #1
    26f0:	f8a8 2064 	strh.w	r2, [r8, #100]	; 0x64
		conn_lll->data_chan_sel = 0;
    26f4:	f898 203d 	ldrb.w	r2, [r8, #61]	; 0x3d
    26f8:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    26fc:	f062 027f 	orn	r2, r2, #127	; 0x7f
    2700:	f888 203d 	strb.w	r2, [r8, #61]	; 0x3d
		conn_lll->data_chan_use = 0;
    2704:	2200      	movs	r2, #0
		conn_lll->slave.latency_enabled = 0;
    2706:	f362 0100 	bfi	r1, r2, #0, #1
    270a:	f888 1040 	strb.w	r1, [r8, #64]	; 0x40
		conn->connect_expire = 6;
    270e:	2106      	movs	r1, #6
    2710:	f8a8 10c4 	strh.w	r1, [r8, #196]	; 0xc4
		conn->common.fex_valid = 0;
    2714:	f898 10dc 	ldrb.w	r1, [r8, #220]	; 0xdc
		conn_lll->data_chan_use = 0;
    2718:	f888 203f 	strb.w	r2, [r8, #63]	; 0x3f
		conn->common.fex_valid = 0;
    271c:	f021 0103 	bic.w	r1, r1, #3
    2720:	f888 10dc 	strb.w	r1, [r8, #220]	; 0xdc
		conn->llcp_feature.features = LL_FEAT;
    2724:	495f      	ldr	r1, [pc, #380]	; (28a4 <ll_adv_enable+0x45c>)
    2726:	f8c8 111c 	str.w	r1, [r8, #284]	; 0x11c
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
    272a:	f898 1122 	ldrb.w	r1, [r8, #290]	; 0x122
		conn_lll->latency_prepare = 0;
    272e:	f8a8 2032 	strh.w	r2, [r8, #50]	; 0x32
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
    2732:	f021 0103 	bic.w	r1, r1, #3
		conn_lll->latency_event = 0;
    2736:	f8c8 2034 	str.w	r2, [r8, #52]	; 0x34
		conn_lll->slave.window_widening_event_us = 0;
    273a:	e9c8 2213 	strd	r2, r2, [r8, #76]	; 0x4c
		conn_lll->slave.window_size_prepare_us = 0;
    273e:	f8c8 2054 	str.w	r2, [r8, #84]	; 0x54
		conn->supervision_expire = 0;
    2742:	f8a8 20c8 	strh.w	r2, [r8, #200]	; 0xc8
		conn->procedure_expire = 0;
    2746:	f8a8 20cc 	strh.w	r2, [r8, #204]	; 0xcc
		conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0;
    274a:	f8a8 20e8 	strh.w	r2, [r8, #232]	; 0xe8
    274e:	f888 20ea 	strb.w	r2, [r8, #234]	; 0xea
		conn->llcp_rx = NULL;
    2752:	f8c8 2100 	str.w	r2, [r8, #256]	; 0x100
		conn->llcp_cu.req = conn->llcp_cu.ack = 0;
    2756:	f8a8 2104 	strh.w	r2, [r8, #260]	; 0x104
		conn->llcp_feature.req = conn->llcp_feature.ack = 0;
    275a:	f8a8 2118 	strh.w	r2, [r8, #280]	; 0x118
		conn->llcp_version.req = conn->llcp_version.ack = 0;
    275e:	f8a8 2120 	strh.w	r2, [r8, #288]	; 0x120
		conn->llcp_terminate.reason_peer = 0;
    2762:	f888 212b 	strb.w	r2, [r8, #299]	; 0x12b
		conn_lll->link_tx_free = NULL;
    2766:	f8c8 2078 	str.w	r2, [r8, #120]	; 0x78
		conn_lll->packet_tx_head_len = 0;
    276a:	f8a8 207c 	strh.w	r2, [r8, #124]	; 0x7c
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
    276e:	f888 1122 	strb.w	r1, [r8, #290]	; 0x122
		conn_lll->sn = 0;
    2772:	f898 107e 	ldrb.w	r1, [r8, #126]	; 0x7e
		conn->llcp_enc.req = conn->llcp_enc.ack = 0U;
    2776:	f8a8 2150 	strh.w	r2, [r8, #336]	; 0x150
		conn_lll->sn = 0;
    277a:	f021 011f 	bic.w	r1, r1, #31
    277e:	f888 107e 	strb.w	r1, [r8, #126]	; 0x7e
		conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
    2782:	f898 1152 	ldrb.w	r1, [r8, #338]	; 0x152
		conn->llcp_conn_param.req = 0;
    2786:	f8a8 2170 	strh.w	r2, [r8, #368]	; 0x170
		conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
    278a:	f021 0107 	bic.w	r1, r1, #7
    278e:	f888 1152 	strb.w	r1, [r8, #338]	; 0x152
		conn->llcp_conn_param.disabled = 0;
    2792:	f898 1172 	ldrb.w	r1, [r8, #370]	; 0x172
		conn->llcp_length.req = conn->llcp_length.ack = 0U;
    2796:	f8a8 2198 	strh.w	r2, [r8, #408]	; 0x198
		conn->llcp_conn_param.disabled = 0;
    279a:	f362 1104 	bfi	r1, r2, #4, #1
		conn->llcp_length.cache.tx_octets = 0U;
    279e:	f8a8 21a4 	strh.w	r2, [r8, #420]	; 0x1a4
		conn->llcp_conn_param.disabled = 0;
    27a2:	f888 1172 	strb.w	r1, [r8, #370]	; 0x172
		conn->default_tx_octets = ull_conn_default_tx_octets_get();
    27a6:	f012 fc63 	bl	15070 <ull_conn_default_tx_octets_get>
    27aa:	f8a8 00d6 	strh.w	r0, [r8, #214]	; 0xd6
		conn->default_tx_time = ull_conn_default_tx_time_get();
    27ae:	f012 fc65 	bl	1507c <ull_conn_default_tx_time_get>
		conn->llcp_phy.req = conn->llcp_phy.ack = 0;
    27b2:	493d      	ldr	r1, [pc, #244]	; (28a8 <ll_adv_enable+0x460>)
		conn->default_tx_time = ull_conn_default_tx_time_get();
    27b4:	f8a8 00d8 	strh.w	r0, [r8, #216]	; 0xd8
		conn->llcp_phy.req = conn->llcp_phy.ack = 0;
    27b8:	f8d8 01a8 	ldr.w	r0, [r8, #424]	; 0x1a8
    27bc:	4001      	ands	r1, r0
    27be:	f8c8 11a8 	str.w	r1, [r8, #424]	; 0x1a8
		conn->phy_pref_tx = ull_conn_default_phy_tx_get();
    27c2:	f012 fc61 	bl	15088 <ull_conn_default_phy_tx_get>
    27c6:	f898 11ac 	ldrb.w	r1, [r8, #428]	; 0x1ac
    27ca:	f360 0102 	bfi	r1, r0, #0, #3
    27ce:	f888 11ac 	strb.w	r1, [r8, #428]	; 0x1ac
		conn->phy_pref_rx = ull_conn_default_phy_rx_get();
    27d2:	f012 fc5f 	bl	15094 <ull_conn_default_phy_rx_get>
    27d6:	f898 11ac 	ldrb.w	r1, [r8, #428]	; 0x1ac
		adv->node_rx_cc_free = node_rx;
    27da:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    27dc:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4
		conn->phy_pref_flags = 0;
    27e0:	2200      	movs	r2, #0
		conn->phy_pref_rx = ull_conn_default_phy_rx_get();
    27e2:	f360 1106 	bfi	r1, r0, #4, #3
		lll->conn = conn_lll;
    27e6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
		adv->link_cc_free = link;
    27e8:	f8c4 b0d0 	str.w	fp, [r4, #208]	; 0xd0
		lll->conn = conn_lll;
    27ec:	6263      	str	r3, [r4, #36]	; 0x24
		conn->phy_pref_flags = 0;
    27ee:	f362 01c3 	bfi	r1, r2, #3, #1
    27f2:	f888 11ac 	strb.w	r1, [r8, #428]	; 0x1ac
    27f6:	f898 1020 	ldrb.w	r1, [r8, #32]
		conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
    27fa:	f8c8 21b0 	str.w	r2, [r8, #432]	; 0x1b0
    27fe:	f362 0100 	bfi	r1, r2, #0, #1
		conn->tx_data = conn->tx_data_last = 0;
    2802:	e9c8 226f 	strd	r2, r2, [r8, #444]	; 0x1bc
		conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
    2806:	e9c8 226d 	strd	r2, r2, [r8, #436]	; 0x1b4
    280a:	e9c8 2205 	strd	r2, r2, [r8, #20]
	hdr->parent = parent;
    280e:	f8c8 801c 	str.w	r8, [r8, #28]
	hdr->is_stop = 0U;
    2812:	f888 1020 	strb.w	r1, [r8, #32]
		lll_clock_wait();
    2816:	f014 faf9 	bl	16e0c <lll_clock_wait>
    281a:	e665      	b.n	24e8 <ll_adv_enable+0xa0>
			if (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND) {
    281c:	f1bc 0f01 	cmp.w	ip, #1
    2820:	d015      	beq.n	284e <ll_adv_enable+0x406>
					  BYTES2US(ADVA_SIZE + rsp_data_len,
    2822:	00d2      	lsls	r2, r2, #3
		const u16_t scan_rsp_us  = ll_hdr_us +
    2824:	3280      	adds	r2, #128	; 0x80
			} else if (pdu_adv->type == PDU_ADV_TYPE_ADV_IND) {
    2826:	f1bc 0f00 	cmp.w	ip, #0
    282a:	d109      	bne.n	2840 <ll_adv_enable+0x3f8>
				adv_size += adv_data_len;
    282c:	3310      	adds	r3, #16
				slot_us += scan_req_us + EVENT_IFS_MAX_US +
    282e:	f502 7227 	add.w	r2, r2, #668	; 0x29c
			slot_us += (BYTES2US(adv_size, phy) + EVENT_IFS_MAX_US
    2832:	00db      	lsls	r3, r3, #3
    2834:	f102 0098 	add.w	r0, r2, #152	; 0x98
    2838:	4418      	add	r0, r3
				  + rx_to_us + rxtx_turn_us) * (adv_chn_cnt-1)
    283a:	f503 739a 	add.w	r3, r3, #308	; 0x134
    283e:	e677      	b.n	2530 <ll_adv_enable+0xe8>
			} else if (pdu_adv->type == PDU_ADV_TYPE_SCAN_IND) {
    2840:	f1bc 0f06 	cmp.w	ip, #6
    2844:	d0f2      	beq.n	282c <ll_adv_enable+0x3e4>
		u32_t adv_size		= ll_hdr_size + ADVA_SIZE;
    2846:	2310      	movs	r3, #16
	u32_t slot_us	= EVENT_OVERHEAD_START_US + EVENT_OVERHEAD_END_US;
    2848:	f44f 72aa 	mov.w	r2, #340	; 0x154
    284c:	e7f1      	b.n	2832 <ll_adv_enable+0x3ea>
				adv_size += TARGETA_SIZE;
    284e:	2316      	movs	r3, #22
				slot_us += conn_ind_us;
    2850:	f44f 722d 	mov.w	r2, #692	; 0x2b4
    2854:	e7ed      	b.n	2832 <ll_adv_enable+0x3ea>
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
    2856:	4815      	ldr	r0, [pc, #84]	; (28ac <ll_adv_enable+0x464>)
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    2858:	f64f 73ff 	movw	r3, #65535	; 0xffff
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
    285c:	fa1f f889 	uxth.w	r8, r9
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    2860:	e9cd 6302 	strd	r6, r3, [sp, #8]
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
    2864:	fba8 0100 	umull	r0, r1, r8, r0
    2868:	2391      	movs	r3, #145	; 0x91
    286a:	fb03 1108 	mla	r1, r3, r8, r1
    286e:	a30a      	add	r3, pc, #40	; (adr r3, 2898 <ll_adv_enable+0x450>)
    2870:	e9d3 2300 	ldrd	r2, r3, [r3]
    2874:	f7fd fc84 	bl	180 <__aeabi_uldivmod>
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    2878:	4653      	mov	r3, sl
    287a:	e9cd 6000 	strd	r6, r0, [sp]
    287e:	2202      	movs	r2, #2
    2880:	2103      	movs	r1, #3
    2882:	4630      	mov	r0, r6
    2884:	e6b7      	b.n	25f6 <ll_adv_enable+0x1ae>
	if (adv->lll.conn) {
    2886:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2888:	2b00      	cmp	r3, #0
    288a:	f43f adf1 	beq.w	2470 <ll_adv_enable+0x28>
		conn_release(adv);
    288e:	4808      	ldr	r0, [pc, #32]	; (28b0 <ll_adv_enable+0x468>)
    2890:	f011 f972 	bl	13b78 <conn_release>
    2894:	e5ec      	b.n	2470 <ll_adv_enable+0x28>
    2896:	bf00      	nop
    2898:	1afd498d 	.word	0x1afd498d
    289c:	00000007 	.word	0x00000007
    28a0:	01480148 	.word	0x01480148
    28a4:	0001417f 	.word	0x0001417f
    28a8:	feff0000 	.word	0xfeff0000
    28ac:	84e72a00 	.word	0x84e72a00
    28b0:	200011ac 	.word	0x200011ac
    28b4:	00000000 	.word	0x00000000

000028b8 <ull_conn_llcp>:

	return 0;
}

int ull_conn_llcp(struct ll_conn *conn, u32_t ticks_at_expire, u16_t lazy)
{
    28b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    28bc:	4692      	mov	sl, r2
	LL_ASSERT(conn->lll.handle != 0xFFFF);
    28be:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
    28c0:	f64f 73ff 	movw	r3, #65535	; 0xffff
    28c4:	429a      	cmp	r2, r3
{
    28c6:	b08d      	sub	sp, #52	; 0x34
    28c8:	4604      	mov	r4, r0
    28ca:	4688      	mov	r8, r1
	LL_ASSERT(conn->lll.handle != 0xFFFF);
    28cc:	d10c      	bne.n	28e8 <ull_conn_llcp+0x30>
    28ce:	f240 3303 	movw	r3, #771	; 0x303
    28d2:	4ac6      	ldr	r2, [pc, #792]	; (2bec <ull_conn_llcp+0x334>)
    28d4:	49c6      	ldr	r1, [pc, #792]	; (2bf0 <ull_conn_llcp+0x338>)
    28d6:	48c7      	ldr	r0, [pc, #796]	; (2bf4 <ull_conn_llcp+0x33c>)
    28d8:	f01d fa6b 	bl	1fdb2 <printk>
    28dc:	4040      	eors	r0, r0
    28de:	f380 8811 	msr	BASEPRI, r0
    28e2:	f04f 0003 	mov.w	r0, #3
    28e6:	df02      	svc	2

	/* Check if no other procedure with instant is requested and not in
	 * Encryption setup.
	 */
	if ((conn->llcp_ack == conn->llcp_req) &&
    28e8:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
    28ec:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
    28f0:	4293      	cmp	r3, r2
    28f2:	d110      	bne.n	2916 <ull_conn_llcp+0x5e>
#if defined(CONFIG_BT_CTLR_LE_ENC)
	    !conn->llcp_enc.pause_rx) {
    28f4:	f894 0152 	ldrb.w	r0, [r4, #338]	; 0x152
	if ((conn->llcp_ack == conn->llcp_req) &&
    28f8:	f010 0601 	ands.w	r6, r0, #1
    28fc:	d10b      	bne.n	2916 <ull_conn_llcp+0x5e>
#endif /* !CONFIG_BT_CTLR_LE_ENC */

		/* TODO: Optimize the checks below, maybe have common flag */

		/* check if connection update procedure is requested */
		if (conn->llcp_cu.ack != conn->llcp_cu.req) {
    28fe:	f894 1105 	ldrb.w	r1, [r4, #261]	; 0x105
    2902:	f894 5104 	ldrb.w	r5, [r4, #260]	; 0x104
    2906:	428d      	cmp	r5, r1
    2908:	d01d      	beq.n	2946 <ull_conn_llcp+0x8e>
			/* switch to LLCP_CONN_UPD state machine */
			conn->llcp_type = LLCP_CONN_UPD;
    290a:	2201      	movs	r2, #1
			conn->llcp_ack -= 2U;
    290c:	3b02      	subs	r3, #2
			conn->llcp_type = LLCP_CONN_UPD;
    290e:	f884 20ea 	strb.w	r2, [r4, #234]	; 0xea
			conn->llcp_ack -= 2U;
    2912:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
#endif /* CONFIG_BT_CTLR_PHY */
		}
	}

	/* check if procedure is requested */
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
    2916:	f894 10e8 	ldrb.w	r1, [r4, #232]	; 0xe8
    291a:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
    291e:	1acb      	subs	r3, r1, r3
    2920:	f003 0303 	and.w	r3, r3, #3
    2924:	2b02      	cmp	r3, #2
    2926:	f040 85b1 	bne.w	348c <ull_conn_llcp+0xbd4>
		switch (conn->llcp_type) {
    292a:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
    292e:	3b01      	subs	r3, #1
    2930:	2b05      	cmp	r3, #5
    2932:	f201 8074 	bhi.w	3a1e <ull_conn_llcp+0x1166>
    2936:	e8df f013 	tbh	[pc, r3, lsl #1]
    293a:	035b      	.short	0x035b
    293c:	05d20579 	.word	0x05d20579
    2940:	06ff0872 	.word	0x06ff0872
    2944:	071f      	.short	0x071f
		} else if (conn->llcp_feature.ack != conn->llcp_feature.req) {
    2946:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
    294a:	f894 5118 	ldrb.w	r5, [r4, #280]	; 0x118
    294e:	42ab      	cmp	r3, r5
    2950:	d05b      	beq.n	2a0a <ull_conn_llcp+0x152>
static inline void event_fex_prep(struct ll_conn *conn)
{
	struct node_tx *tx;

	/* If waiting for response, do nothing */
	if (!((conn->llcp_feature.ack - conn->llcp_feature.req) & 0x01)) {
    2952:	1b5b      	subs	r3, r3, r5
    2954:	07d8      	lsls	r0, r3, #31
    2956:	d5de      	bpl.n	2916 <ull_conn_llcp+0x5e>
		return;
	}

	if (conn->common.fex_valid) {
    2958:	f894 50dc 	ldrb.w	r5, [r4, #220]	; 0xdc
    295c:	f015 0501 	ands.w	r5, r5, #1
    2960:	d02a      	beq.n	29b8 <ull_conn_llcp+0x100>
		struct node_rx_pdu *rx;
		struct pdu_data *pdu;

		/* get a rx node for ULL->LL */
		rx = ll_pdu_rx_alloc();
    2962:	f010 faa5 	bl	12eb0 <ll_pdu_rx_alloc>
		if (!rx) {
    2966:	4601      	mov	r1, r0
    2968:	2800      	cmp	r0, #0
    296a:	d0d4      	beq.n	2916 <ull_conn_llcp+0x5e>
			return;
		}

		/* procedure request acked */
		conn->llcp_feature.ack = conn->llcp_feature.req;
    296c:	f894 3118 	ldrb.w	r3, [r4, #280]	; 0x118
    2970:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119

		/* prepare feature rsp structure */
		rx->hdr.handle = conn->lll.handle;
    2974:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    2976:	80c3      	strh	r3, [r0, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    2978:	2302      	movs	r3, #2
    297a:	7103      	strb	r3, [r0, #4]
		pdu = (void *)rx->pdu;
		pdu->ll_id = PDU_DATA_LLID_CTRL;
    297c:	f890 3020 	ldrb.w	r3, [r0, #32]
__ssp_bos_icheck3(memmove, void *, const void *)
__ssp_bos_icheck3_restrict(mempcpy, void *, const void *)
__ssp_bos_icheck3(memset, void *, int)
    2980:	6246      	str	r6, [r0, #36]	; 0x24
    2982:	f043 0303 	orr.w	r3, r3, #3
    2986:	f880 3020 	strb.w	r3, [r0, #32]
		pdu->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
    298a:	2309      	movs	r3, #9
    298c:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
    2990:	6286      	str	r6, [r0, #40]	; 0x28
			   sizeof(struct pdu_data_llctrl_feature_rsp);
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
    2992:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
		(void)memset(&pdu->llctrl.feature_rsp.features[0], 0x00,
			sizeof(pdu->llctrl.feature_rsp.features));
		sys_put_le24(conn->llcp_feature.features,
    2996:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
	dst[0] = val;
    299a:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
	dst[1] = val >> 8;
    299e:	f3c3 2207 	ubfx	r2, r3, #8, #8
	dst[2] = val >> 16;
    29a2:	0c1b      	lsrs	r3, r3, #16
	dst[1] = val >> 8;
    29a4:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
	dst[2] = val >> 16;
    29a8:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
			sys_cpu_to_le16(conn->llcp_version.company_id);
		pdu->llctrl.version_ind.sub_version_number =
			sys_cpu_to_le16(conn->llcp_version.sub_version_number);

		/* enqueue version ind structure into rx queue */
		ll_rx_put(rx->hdr.link, rx);
    29ac:	6808      	ldr	r0, [r1, #0]
    29ae:	f010 fa57 	bl	12e60 <ll_rx_put>
		ll_rx_sched();
    29b2:	f010 fa5f 	bl	12e74 <ll_rx_sched>
    29b6:	e7ae      	b.n	2916 <ull_conn_llcp+0x5e>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    29b8:	488f      	ldr	r0, [pc, #572]	; (2bf8 <ull_conn_llcp+0x340>)
    29ba:	f021 fb08 	bl	23fce <mem_acquire>
	if (tx) {
    29be:	4601      	mov	r1, r0
    29c0:	2800      	cmp	r0, #0
    29c2:	d0a8      	beq.n	2916 <ull_conn_llcp+0x5e>
		conn->llcp_feature.ack--;
    29c4:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
    29c8:	3b01      	subs	r3, #1
    29ca:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
		conn->llcp_feature.features = LL_FEAT;
    29ce:	4b8b      	ldr	r3, [pc, #556]	; (2bfc <ull_conn_llcp+0x344>)
    29d0:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
		pdu->ll_id = PDU_DATA_LLID_CTRL;
    29d4:	7903      	ldrb	r3, [r0, #4]
    29d6:	f043 0303 	orr.w	r3, r3, #3
    29da:	7103      	strb	r3, [r0, #4]
		pdu->len = offsetof(struct pdu_data_llctrl, feature_req) +
    29dc:	2309      	movs	r3, #9
    29de:	7143      	strb	r3, [r0, #5]
		pdu->llctrl.opcode = !conn->lll.role ?
    29e0:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
    29e4:	6085      	str	r5, [r0, #8]
    29e6:	2b00      	cmp	r3, #0
    29e8:	bfac      	ite	ge
    29ea:	2308      	movge	r3, #8
    29ec:	230e      	movlt	r3, #14
    29ee:	60c5      	str	r5, [r0, #12]
    29f0:	71c3      	strb	r3, [r0, #7]
		sys_put_le24(conn->llcp_feature.features,
    29f2:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
	dst[0] = val;
    29f6:	7203      	strb	r3, [r0, #8]
	dst[1] = val >> 8;
    29f8:	f3c3 2207 	ubfx	r2, r3, #8, #8
	dst[2] = val >> 16;
    29fc:	0c1b      	lsrs	r3, r3, #16
	dst[1] = val >> 8;
    29fe:	7242      	strb	r2, [r0, #9]
	dst[2] = val >> 16;
    2a00:	7283      	strb	r3, [r0, #10]

		pr = &pdu_ctrl_tx->llctrl.phy_req;
		pr->tx_phys = conn->llcp_phy.tx;
		pr->rx_phys = conn->llcp_phy.rx;

		ctrl_tx_enqueue(conn, tx);
    2a02:	4620      	mov	r0, r4
    2a04:	f021 fea8 	bl	24758 <ctrl_tx_enqueue>
    2a08:	e0ca      	b.n	2ba0 <ull_conn_llcp+0x2e8>
		} else if (conn->llcp_version.ack != conn->llcp_version.req) {
    2a0a:	f894 3121 	ldrb.w	r3, [r4, #289]	; 0x121
    2a0e:	f894 5120 	ldrb.w	r5, [r4, #288]	; 0x120
    2a12:	42ab      	cmp	r3, r5
    2a14:	d064      	beq.n	2ae0 <ull_conn_llcp+0x228>
	if (!((conn->llcp_version.ack - conn->llcp_version.req) & 0x01)) {
    2a16:	1b5b      	subs	r3, r3, r5
    2a18:	07d9      	lsls	r1, r3, #31
    2a1a:	f57f af7c 	bpl.w	2916 <ull_conn_llcp+0x5e>
	if (conn->llcp_version.tx == 0U) {
    2a1e:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
    2a22:	07da      	lsls	r2, r3, #31
    2a24:	d425      	bmi.n	2a72 <ull_conn_llcp+0x1ba>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    2a26:	4874      	ldr	r0, [pc, #464]	; (2bf8 <ull_conn_llcp+0x340>)
    2a28:	f021 fad1 	bl	23fce <mem_acquire>
		if (tx) {
    2a2c:	4601      	mov	r1, r0
    2a2e:	2800      	cmp	r0, #0
    2a30:	f43f af71 	beq.w	2916 <ull_conn_llcp+0x5e>
			conn->llcp_version.ack--;
    2a34:	f894 3121 	ldrb.w	r3, [r4, #289]	; 0x121
    2a38:	3b01      	subs	r3, #1
    2a3a:	f884 3121 	strb.w	r3, [r4, #289]	; 0x121
			conn->llcp_version.tx = 1U;
    2a3e:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
    2a42:	f043 0301 	orr.w	r3, r3, #1
    2a46:	f884 3122 	strb.w	r3, [r4, #290]	; 0x122
			pdu->ll_id = PDU_DATA_LLID_CTRL;
    2a4a:	7903      	ldrb	r3, [r0, #4]
    2a4c:	f043 0303 	orr.w	r3, r3, #3
    2a50:	7103      	strb	r3, [r0, #4]
			pdu->len =
    2a52:	2306      	movs	r3, #6
    2a54:	7143      	strb	r3, [r0, #5]
			pdu->llctrl.opcode =
    2a56:	230c      	movs	r3, #12
    2a58:	71c3      	strb	r3, [r0, #7]
			pdu->llctrl.version_ind.version_number =
    2a5a:	230a      	movs	r3, #10
    2a5c:	7203      	strb	r3, [r0, #8]
			pdu->llctrl.version_ind.company_id = cid;
    2a5e:	f06f 030e 	mvn.w	r3, #14
    2a62:	7243      	strb	r3, [r0, #9]
    2a64:	2305      	movs	r3, #5
    2a66:	7283      	strb	r3, [r0, #10]
			pdu->llctrl.version_ind.sub_version_number = svn;
    2a68:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2a6c:	72c3      	strb	r3, [r0, #11]
    2a6e:	7303      	strb	r3, [r0, #12]
			ctrl_tx_enqueue(conn, tx);
    2a70:	e7c7      	b.n	2a02 <ull_conn_llcp+0x14a>
	} else if (conn->llcp_version.rx) {
    2a72:	079f      	lsls	r7, r3, #30
    2a74:	d526      	bpl.n	2ac4 <ull_conn_llcp+0x20c>
		rx = ll_pdu_rx_alloc();
    2a76:	f010 fa1b 	bl	12eb0 <ll_pdu_rx_alloc>
		if (!rx) {
    2a7a:	4601      	mov	r1, r0
    2a7c:	2800      	cmp	r0, #0
    2a7e:	f43f af4a 	beq.w	2916 <ull_conn_llcp+0x5e>
		conn->llcp_version.ack = conn->llcp_version.req;
    2a82:	f894 3120 	ldrb.w	r3, [r4, #288]	; 0x120
    2a86:	f884 3121 	strb.w	r3, [r4, #289]	; 0x121
		rx->hdr.handle = conn->lll.handle;
    2a8a:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    2a8c:	80c3      	strh	r3, [r0, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    2a8e:	2302      	movs	r3, #2
    2a90:	7103      	strb	r3, [r0, #4]
		pdu->ll_id = PDU_DATA_LLID_CTRL;
    2a92:	f890 3020 	ldrb.w	r3, [r0, #32]
    2a96:	f043 0303 	orr.w	r3, r3, #3
    2a9a:	f880 3020 	strb.w	r3, [r0, #32]
		pdu->len = offsetof(struct pdu_data_llctrl, version_ind) +
    2a9e:	2306      	movs	r3, #6
    2aa0:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
    2aa4:	230c      	movs	r3, #12
    2aa6:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
		pdu->llctrl.version_ind.version_number =
    2aaa:	f894 3123 	ldrb.w	r3, [r4, #291]	; 0x123
    2aae:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
		pdu->llctrl.version_ind.company_id =
    2ab2:	f8b4 3124 	ldrh.w	r3, [r4, #292]	; 0x124
    2ab6:	f8a0 3025 	strh.w	r3, [r0, #37]	; 0x25
		pdu->llctrl.version_ind.sub_version_number =
    2aba:	f8b4 3126 	ldrh.w	r3, [r4, #294]	; 0x126
    2abe:	f8a0 3027 	strh.w	r3, [r0, #39]	; 0x27
    2ac2:	e773      	b.n	29ac <ull_conn_llcp+0xf4>
		LL_ASSERT(0);
    2ac4:	f640 3302 	movw	r3, #2818	; 0xb02
	case LLCP_PHY_STATE_RSP_WAIT:
		/* no nothing */
		break;

	default:
		LL_ASSERT(0);
    2ac8:	4a48      	ldr	r2, [pc, #288]	; (2bec <ull_conn_llcp+0x334>)
    2aca:	494d      	ldr	r1, [pc, #308]	; (2c00 <ull_conn_llcp+0x348>)
    2acc:	4849      	ldr	r0, [pc, #292]	; (2bf4 <ull_conn_llcp+0x33c>)
    2ace:	f01d f970 	bl	1fdb2 <printk>
    2ad2:	4040      	eors	r0, r0
    2ad4:	f380 8811 	msr	BASEPRI, r0
    2ad8:	f04f 0003 	mov.w	r0, #3
    2adc:	df02      	svc	2
		break;
    2ade:	e71a      	b.n	2916 <ull_conn_llcp+0x5e>
		} else if (conn->llcp_conn_param.ack !=
    2ae0:	f894 5171 	ldrb.w	r5, [r4, #369]	; 0x171
    2ae4:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
    2ae8:	429d      	cmp	r5, r3
    2aea:	f000 8138 	beq.w	2d5e <ull_conn_llcp+0x4a6>
	conn_upd = conn_upd_curr;
    2aee:	4d45      	ldr	r5, [pc, #276]	; (2c04 <ull_conn_llcp+0x34c>)
    2af0:	682b      	ldr	r3, [r5, #0]
	if (conn_upd && (conn_upd != conn)) {
    2af2:	b113      	cbz	r3, 2afa <ull_conn_llcp+0x242>
    2af4:	429c      	cmp	r4, r3
    2af6:	f47f af0e 	bne.w	2916 <ull_conn_llcp+0x5e>
	switch (conn->llcp_conn_param.state) {
    2afa:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
    2afe:	f003 0307 	and.w	r3, r3, #7
    2b02:	2b05      	cmp	r3, #5
    2b04:	f200 8128 	bhi.w	2d58 <ull_conn_llcp+0x4a0>
    2b08:	a201      	add	r2, pc, #4	; (adr r2, 2b10 <ull_conn_llcp+0x258>)
    2b0a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    2b0e:	bf00      	nop
    2b10:	00002b29 	.word	0x00002b29
    2b14:	00002bab 	.word	0x00002bab
    2b18:	00002d01 	.word	0x00002d01
    2b1c:	00002917 	.word	0x00002917
    2b20:	00002917 	.word	0x00002917
    2b24:	00002917 	.word	0x00002917
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    2b28:	4833      	ldr	r0, [pc, #204]	; (2bf8 <ull_conn_llcp+0x340>)
			event_counter = lll->event_counter +
    2b2a:	8ee6      	ldrh	r6, [r4, #54]	; 0x36
					lll->latency_prepare + lazy;
    2b2c:	8e67      	ldrh	r7, [r4, #50]	; 0x32
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    2b2e:	f021 fa4e 	bl	23fce <mem_acquire>
	if (!tx) {
    2b32:	4601      	mov	r1, r0
    2b34:	2800      	cmp	r0, #0
    2b36:	f43f aeee 	beq.w	2916 <ull_conn_llcp+0x5e>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP_WAIT;
    2b3a:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
    2b3e:	2204      	movs	r2, #4
    2b40:	f362 0302 	bfi	r3, r2, #0, #3
    2b44:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    2b48:	7903      	ldrb	r3, [r0, #4]
    2b4a:	f043 0303 	orr.w	r3, r3, #3
    2b4e:	7103      	strb	r3, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
    2b50:	2318      	movs	r3, #24
    2b52:	7143      	strb	r3, [r0, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
    2b54:	230f      	movs	r3, #15
    2b56:	71c3      	strb	r3, [r0, #7]
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
    2b58:	f8b4 3174 	ldrh.w	r3, [r4, #372]	; 0x174
    2b5c:	8103      	strh	r3, [r0, #8]
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
    2b5e:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
    2b62:	8143      	strh	r3, [r0, #10]
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
    2b64:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
    2b68:	8183      	strh	r3, [r0, #12]
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
    2b6a:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
    2b6e:	81c3      	strh	r3, [r0, #14]
			event_counter = lll->event_counter +
    2b70:	443e      	add	r6, r7
	p->preferred_periodicity = 0U;
    2b72:	2300      	movs	r3, #0
    2b74:	7403      	strb	r3, [r0, #16]
	p->offset0 = sys_cpu_to_le16(0x0000);
    2b76:	74c3      	strb	r3, [r0, #19]
    2b78:	7503      	strb	r3, [r0, #20]
	p->reference_conn_event_count = sys_cpu_to_le16(event_counter);
    2b7a:	4456      	add	r6, sl
	p->offset1 = sys_cpu_to_le16(0xffff);
    2b7c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	p->reference_conn_event_count = sys_cpu_to_le16(event_counter);
    2b80:	f8a0 6011 	strh.w	r6, [r0, #17]
	p->offset1 = sys_cpu_to_le16(0xffff);
    2b84:	7543      	strb	r3, [r0, #21]
    2b86:	7583      	strb	r3, [r0, #22]
	p->offset2 = sys_cpu_to_le16(0xffff);
    2b88:	75c3      	strb	r3, [r0, #23]
    2b8a:	7603      	strb	r3, [r0, #24]
	p->offset3 = sys_cpu_to_le16(0xffff);
    2b8c:	7643      	strb	r3, [r0, #25]
    2b8e:	7683      	strb	r3, [r0, #26]
	p->offset4 = sys_cpu_to_le16(0xffff);
    2b90:	76c3      	strb	r3, [r0, #27]
    2b92:	7703      	strb	r3, [r0, #28]
	p->offset5 = sys_cpu_to_le16(0xffff);
    2b94:	7743      	strb	r3, [r0, #29]
    2b96:	7783      	strb	r3, [r0, #30]
	ctrl_tx_enqueue(conn, tx);
    2b98:	4620      	mov	r0, r4
    2b9a:	f021 fddd 	bl	24758 <ctrl_tx_enqueue>
	conn_upd_curr = conn;
    2b9e:	602c      	str	r4, [r5, #0]
		conn->procedure_expire = conn->procedure_reload;
    2ba0:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
    2ba4:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	break;
    2ba8:	e6b5      	b.n	2916 <ull_conn_llcp+0x5e>
	if (conn->llcp_conn_param.status) {
    2baa:	f894 6173 	ldrb.w	r6, [r4, #371]	; 0x173
    2bae:	b35e      	cbz	r6, 2c08 <ull_conn_llcp+0x350>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    2bb0:	4811      	ldr	r0, [pc, #68]	; (2bf8 <ull_conn_llcp+0x340>)
    2bb2:	f021 fa0c 	bl	23fce <mem_acquire>
		if (!tx) {
    2bb6:	4601      	mov	r1, r0
    2bb8:	2800      	cmp	r0, #0
    2bba:	f43f aeac 	beq.w	2916 <ull_conn_llcp+0x5e>
		pdu->ll_id = PDU_DATA_LLID_CTRL;
    2bbe:	7903      	ldrb	r3, [r0, #4]
    2bc0:	f043 0303 	orr.w	r3, r3, #3
    2bc4:	7103      	strb	r3, [r0, #4]
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
    2bc6:	2311      	movs	r3, #17
    2bc8:	71c3      	strb	r3, [r0, #7]
		pdu->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
    2bca:	2303      	movs	r3, #3
    2bcc:	7143      	strb	r3, [r0, #5]
		rej->reject_opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
    2bce:	230f      	movs	r3, #15
    2bd0:	7203      	strb	r3, [r0, #8]
		rej->error_code = conn->llcp_conn_param.status;
    2bd2:	f894 3173 	ldrb.w	r3, [r4, #371]	; 0x173
    2bd6:	7243      	strb	r3, [r0, #9]
		ctrl_tx_enqueue(conn, tx);
    2bd8:	4620      	mov	r0, r4
    2bda:	f021 fdbd 	bl	24758 <ctrl_tx_enqueue>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
    2bde:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
    2be2:	f884 3171 	strb.w	r3, [r4, #369]	; 0x171
		conn_upd_curr = NULL;
    2be6:	2300      	movs	r3, #0
    2be8:	602b      	str	r3, [r5, #0]
		return;
    2bea:	e694      	b.n	2916 <ull_conn_llcp+0x5e>
    2bec:	00064754 	.word	0x00064754
    2bf0:	00064800 	.word	0x00064800
    2bf4:	000632fe 	.word	0x000632fe
    2bf8:	200014ec 	.word	0x200014ec
    2bfc:	0001417f 	.word	0x0001417f
    2c00:	00065948 	.word	0x00065948
    2c04:	2000146c 	.word	0x2000146c
	if (!conn->lll.role) {
    2c08:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
    2c0c:	2b00      	cmp	r3, #0
    2c0e:	db34      	blt.n	2c7a <ull_conn_llcp+0x3c2>
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
    2c10:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
		conn->llcp_cu.win_offset_us = 0U;
    2c14:	f8c4 6110 	str.w	r6, [r4, #272]	; 0x110
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
    2c18:	2205      	movs	r2, #5
    2c1a:	f362 0302 	bfi	r3, r2, #0, #3
		if (conn->llcp_conn_param.preferred_periodicity) {
    2c1e:	f894 217c 	ldrb.w	r2, [r4, #380]	; 0x17c
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
    2c22:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
		conn->llcp_cu.win_size = 1U;
    2c26:	2301      	movs	r3, #1
    2c28:	f884 3114 	strb.w	r3, [r4, #276]	; 0x114
		if (conn->llcp_conn_param.preferred_periodicity) {
    2c2c:	b312      	cbz	r2, 2c74 <ull_conn_llcp+0x3bc>
				((conn->llcp_conn_param.interval_min /
    2c2e:	f8b4 3174 	ldrh.w	r3, [r4, #372]	; 0x174
    2c32:	fbb3 f3f2 	udiv	r3, r3, r2
				  conn->llcp_conn_param.preferred_periodicity) +
    2c36:	3301      	adds	r3, #1
			conn->llcp_cu.interval =
    2c38:	fb13 f302 	smulbb	r3, r3, r2
    2c3c:	b29b      	uxth	r3, r3
    2c3e:	f8a4 3108 	strh.w	r3, [r4, #264]	; 0x108
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
    2c42:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
    2c46:	f8a4 310a 	strh.w	r3, [r4, #266]	; 0x10a
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
    2c4a:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
    2c4e:	f8a4 310c 	strh.w	r3, [r4, #268]	; 0x10c
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
    2c52:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
    2c56:	2202      	movs	r2, #2
    2c58:	f362 0301 	bfi	r3, r2, #0, #2
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
    2c5c:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
    2c60:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    2c64:	f362 0382 	bfi	r3, r2, #2, #1
		conn->llcp_cu.ack--;
    2c68:	3901      	subs	r1, #1
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
    2c6a:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
		conn->llcp_cu.ack--;
    2c6e:	f884 1105 	strb.w	r1, [r4, #261]	; 0x105
		return;
    2c72:	e650      	b.n	2916 <ull_conn_llcp+0x5e>
				conn->llcp_conn_param.interval_max;
    2c74:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
    2c78:	e7e1      	b.n	2c3e <ull_conn_llcp+0x386>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    2c7a:	48d9      	ldr	r0, [pc, #868]	; (2fe0 <ull_conn_llcp+0x728>)
    2c7c:	f021 f9a7 	bl	23fce <mem_acquire>
	if (!tx) {
    2c80:	4601      	mov	r1, r0
    2c82:	2800      	cmp	r0, #0
    2c84:	f43f ae47 	beq.w	2916 <ull_conn_llcp+0x5e>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
    2c88:	7903      	ldrb	r3, [r0, #4]
    2c8a:	f043 0303 	orr.w	r3, r3, #3
    2c8e:	7103      	strb	r3, [r0, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_rsp) +
    2c90:	2318      	movs	r3, #24
    2c92:	7143      	strb	r3, [r0, #5]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_RSP;
    2c94:	2310      	movs	r3, #16
    2c96:	71c3      	strb	r3, [r0, #7]
	rsp->interval_min =
    2c98:	f8b4 3174 	ldrh.w	r3, [r4, #372]	; 0x174
    2c9c:	8103      	strh	r3, [r0, #8]
	rsp->interval_max =
    2c9e:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
    2ca2:	8143      	strh	r3, [r0, #10]
	rsp->latency =
    2ca4:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
    2ca8:	8183      	strh	r3, [r0, #12]
	rsp->timeout =
    2caa:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
    2cae:	81c3      	strh	r3, [r0, #14]
	rsp->preferred_periodicity =
    2cb0:	f894 317c 	ldrb.w	r3, [r4, #380]	; 0x17c
    2cb4:	7403      	strb	r3, [r0, #16]
	rsp->reference_conn_event_count =
    2cb6:	f8b4 317e 	ldrh.w	r3, [r4, #382]	; 0x17e
    2cba:	f8a0 3011 	strh.w	r3, [r0, #17]
	rsp->offset0 = sys_cpu_to_le16(conn->llcp_conn_param.offset0);
    2cbe:	f8b4 3180 	ldrh.w	r3, [r4, #384]	; 0x180
    2cc2:	f8a0 3013 	strh.w	r3, [r0, #19]
	rsp->offset1 = sys_cpu_to_le16(conn->llcp_conn_param.offset1);
    2cc6:	f8b4 3182 	ldrh.w	r3, [r4, #386]	; 0x182
    2cca:	f8a0 3015 	strh.w	r3, [r0, #21]
	rsp->offset2 = sys_cpu_to_le16(conn->llcp_conn_param.offset2);
    2cce:	f8b4 3184 	ldrh.w	r3, [r4, #388]	; 0x184
    2cd2:	f8a0 3017 	strh.w	r3, [r0, #23]
	rsp->offset3 = sys_cpu_to_le16(conn->llcp_conn_param.offset3);
    2cd6:	f8b4 3186 	ldrh.w	r3, [r4, #390]	; 0x186
    2cda:	f8a0 3019 	strh.w	r3, [r0, #25]
	rsp->offset4 = sys_cpu_to_le16(conn->llcp_conn_param.offset4);
    2cde:	f8b4 3188 	ldrh.w	r3, [r4, #392]	; 0x188
    2ce2:	f8a0 301b 	strh.w	r3, [r0, #27]
	rsp->offset5 = sys_cpu_to_le16(conn->llcp_conn_param.offset5);
    2ce6:	f8b4 318a 	ldrh.w	r3, [r4, #394]	; 0x18a
    2cea:	f8a0 301d 	strh.w	r3, [r0, #29]
	ctrl_tx_enqueue(conn, tx);
    2cee:	4620      	mov	r0, r4
    2cf0:	f021 fd32 	bl	24758 <ctrl_tx_enqueue>
	conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
    2cf4:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
    2cf8:	f884 3171 	strb.w	r3, [r4, #369]	; 0x171
	conn_upd_curr = NULL;
    2cfc:	602e      	str	r6, [r5, #0]
    2cfe:	e60a      	b.n	2916 <ull_conn_llcp+0x5e>
	if (conn->llcp_enc.pause_tx) {
    2d00:	0786      	lsls	r6, r0, #30
    2d02:	f53f ae08 	bmi.w	2916 <ull_conn_llcp+0x5e>
	rx = ll_pdu_rx_alloc();
    2d06:	f010 f8d3 	bl	12eb0 <ll_pdu_rx_alloc>
	if (!rx) {
    2d0a:	4601      	mov	r1, r0
    2d0c:	2800      	cmp	r0, #0
    2d0e:	f43f ae02 	beq.w	2916 <ull_conn_llcp+0x5e>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_APP_WAIT;
    2d12:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
    2d16:	2203      	movs	r2, #3
    2d18:	f362 0302 	bfi	r3, r2, #0, #3
    2d1c:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
	rx->hdr.handle = conn->lll.handle;
    2d20:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    2d22:	80c3      	strh	r3, [r0, #6]
	rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    2d24:	2302      	movs	r3, #2
    2d26:	7103      	strb	r3, [r0, #4]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
    2d28:	f890 3020 	ldrb.w	r3, [r0, #32]
    2d2c:	4313      	orrs	r3, r2
    2d2e:	f880 3020 	strb.w	r3, [r0, #32]
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
    2d32:	2318      	movs	r3, #24
    2d34:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
    2d38:	230f      	movs	r3, #15
    2d3a:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
    2d3e:	f8b4 3174 	ldrh.w	r3, [r4, #372]	; 0x174
    2d42:	8483      	strh	r3, [r0, #36]	; 0x24
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
    2d44:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
    2d48:	84c3      	strh	r3, [r0, #38]	; 0x26
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
    2d4a:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
    2d4e:	8503      	strh	r3, [r0, #40]	; 0x28
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
    2d50:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
    2d54:	8543      	strh	r3, [r0, #42]	; 0x2a
	ll_rx_put(rx->hdr.link, rx);
    2d56:	e629      	b.n	29ac <ull_conn_llcp+0xf4>
		LL_ASSERT(0);
    2d58:	f640 430f 	movw	r3, #3087	; 0xc0f
    2d5c:	e6b4      	b.n	2ac8 <ull_conn_llcp+0x210>
		} else if (conn->llcp_length.ack != conn->llcp_length.req) {
    2d5e:	f894 0198 	ldrb.w	r0, [r4, #408]	; 0x198
    2d62:	f894 3199 	ldrb.w	r3, [r4, #409]	; 0x199
    2d66:	4283      	cmp	r3, r0
    2d68:	f000 8099 	beq.w	2e9e <ull_conn_llcp+0x5e6>
	switch (conn->llcp_length.state) {
    2d6c:	f894 319a 	ldrb.w	r3, [r4, #410]	; 0x19a
    2d70:	f3c3 0502 	ubfx	r5, r3, #0, #3
    2d74:	b2e9      	uxtb	r1, r5
    2d76:	2907      	cmp	r1, #7
    2d78:	f000 808e 	beq.w	2e98 <ull_conn_llcp+0x5e0>
    2d7c:	2201      	movs	r2, #1
    2d7e:	408a      	lsls	r2, r1
    2d80:	f012 0f4e 	tst.w	r2, #78	; 0x4e
    2d84:	f47f adc7 	bne.w	2916 <ull_conn_llcp+0x5e>
    2d88:	f012 0f30 	tst.w	r2, #48	; 0x30
    2d8c:	d12d      	bne.n	2dea <ull_conn_llcp+0x532>
    2d8e:	2900      	cmp	r1, #0
    2d90:	f040 8082 	bne.w	2e98 <ull_conn_llcp+0x5e0>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    2d94:	4892      	ldr	r0, [pc, #584]	; (2fe0 <ull_conn_llcp+0x728>)
    2d96:	f021 f91a 	bl	23fce <mem_acquire>
		if (!tx) {
    2d9a:	4601      	mov	r1, r0
    2d9c:	2800      	cmp	r0, #0
    2d9e:	f43f adba 	beq.w	2916 <ull_conn_llcp+0x5e>
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
    2da2:	f894 319a 	ldrb.w	r3, [r4, #410]	; 0x19a
		conn->default_tx_time = conn->llcp_length.tx_time;
    2da6:	f8b4 01a2 	ldrh.w	r0, [r4, #418]	; 0x1a2
    2daa:	f8a4 00d8 	strh.w	r0, [r4, #216]	; 0xd8
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
    2dae:	2201      	movs	r2, #1
    2db0:	f362 0302 	bfi	r3, r2, #0, #3
    2db4:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
		conn->default_tx_octets = conn->llcp_length.tx_octets;
    2db8:	f8b4 319e 	ldrh.w	r3, [r4, #414]	; 0x19e
    2dbc:	f8a4 30d6 	strh.w	r3, [r4, #214]	; 0xd6
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    2dc0:	790a      	ldrb	r2, [r1, #4]
		lr->max_tx_octets = sys_cpu_to_le16(conn->default_tx_octets);
    2dc2:	818b      	strh	r3, [r1, #12]
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    2dc4:	f042 0203 	orr.w	r2, r2, #3
    2dc8:	710a      	strb	r2, [r1, #4]
		pdu_ctrl_tx->len =
    2dca:	2209      	movs	r2, #9
		lr->max_rx_time = sys_cpu_to_le16(rx_time);
    2dcc:	f045 0348 	orr.w	r3, r5, #72	; 0x48
		pdu_ctrl_tx->len =
    2dd0:	714a      	strb	r2, [r1, #5]
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_REQ;
    2dd2:	2214      	movs	r2, #20
    2dd4:	71ca      	strb	r2, [r1, #7]
		lr->max_rx_time = sys_cpu_to_le16(rx_time);
    2dd6:	728b      	strb	r3, [r1, #10]
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
    2dd8:	f045 021b 	orr.w	r2, r5, #27
		lr->max_rx_time = sys_cpu_to_le16(rx_time);
    2ddc:	f045 0301 	orr.w	r3, r5, #1
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
    2de0:	720a      	strb	r2, [r1, #8]
    2de2:	724d      	strb	r5, [r1, #9]
		lr->max_rx_time = sys_cpu_to_le16(rx_time);
    2de4:	72cb      	strb	r3, [r1, #11]
		lr->max_tx_time = sys_cpu_to_le16(tx_time);
    2de6:	81c8      	strh	r0, [r1, #14]
		ctrl_tx_enqueue(conn, tx);
    2de8:	e60b      	b.n	2a02 <ull_conn_llcp+0x14a>
		lll->max_rx_octets = conn->llcp_length.rx_octets;
    2dea:	f8b4 219c 	ldrh.w	r2, [r4, #412]	; 0x19c
    2dee:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
		lll->max_rx_time = conn->llcp_length.rx_time;
    2df2:	f8b4 21a0 	ldrh.w	r2, [r4, #416]	; 0x1a0
    2df6:	f8a4 2062 	strh.w	r2, [r4, #98]	; 0x62
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
    2dfa:	f003 0207 	and.w	r2, r3, #7
    2dfe:	2a04      	cmp	r2, #4
		tx_octets = conn->llcp_length.tx_octets;
    2e00:	f8b4 719e 	ldrh.w	r7, [r4, #414]	; 0x19e
		u16_t tx_time = conn->llcp_length.tx_time;
    2e04:	f8b4 61a2 	ldrh.w	r6, [r4, #418]	; 0x1a2
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
    2e08:	d144      	bne.n	2e94 <ull_conn_llcp+0x5dc>
			if (!conn->llcp_length.cache.tx_octets) {
    2e0a:	f8b4 21a4 	ldrh.w	r2, [r4, #420]	; 0x1a4
    2e0e:	bb9a      	cbnz	r2, 2e78 <ull_conn_llcp+0x5c0>
				conn->llcp_length.ack = conn->llcp_length.req;
    2e10:	f884 0199 	strb.w	r0, [r4, #409]	; 0x199
				conn->procedure_expire = 0U;
    2e14:	f8a4 20cc 	strh.w	r2, [r4, #204]	; 0xcc
		rx = conn->llcp_rx;
    2e18:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
		LL_ASSERT(rx && rx->hdr.link);
    2e1c:	b10d      	cbz	r5, 2e22 <ull_conn_llcp+0x56a>
    2e1e:	682b      	ldr	r3, [r5, #0]
    2e20:	b963      	cbnz	r3, 2e3c <ull_conn_llcp+0x584>
    2e22:	f640 43ce 	movw	r3, #3278	; 0xcce
    2e26:	4a6f      	ldr	r2, [pc, #444]	; (2fe4 <ull_conn_llcp+0x72c>)
    2e28:	496f      	ldr	r1, [pc, #444]	; (2fe8 <ull_conn_llcp+0x730>)
    2e2a:	4870      	ldr	r0, [pc, #448]	; (2fec <ull_conn_llcp+0x734>)
    2e2c:	f01c ffc1 	bl	1fdb2 <printk>
    2e30:	4040      	eors	r0, r0
    2e32:	f380 8811 	msr	BASEPRI, r0
    2e36:	f04f 0003 	mov.w	r0, #3
    2e3a:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
    2e3c:	6828      	ldr	r0, [r5, #0]
    2e3e:	6843      	ldr	r3, [r0, #4]
    2e40:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		rx->hdr.handle = conn->lll.handle;
    2e44:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    2e46:	80eb      	strh	r3, [r5, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    2e48:	2302      	movs	r3, #2
    2e4a:	712b      	strb	r3, [r5, #4]
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
    2e4c:	f895 3020 	ldrb.w	r3, [r5, #32]
    2e50:	f043 0303 	orr.w	r3, r3, #3
    2e54:	f885 3020 	strb.w	r3, [r5, #32]
		pdu_ctrl_rx->len =
    2e58:	2309      	movs	r3, #9
    2e5a:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
		pdu_ctrl_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
    2e5e:	2315      	movs	r3, #21
    2e60:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
    2e64:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
    2e68:	84ab      	strh	r3, [r5, #36]	; 0x24
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
    2e6a:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
		lr->max_tx_octets = sys_cpu_to_le16(tx_octets);
    2e6e:	852f      	strh	r7, [r5, #40]	; 0x28
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
    2e70:	84eb      	strh	r3, [r5, #38]	; 0x26
		lr->max_tx_time = sys_cpu_to_le16(tx_time);
    2e72:	856e      	strh	r6, [r5, #42]	; 0x2a
		ll_rx_put(rx->hdr.link, rx);
    2e74:	4629      	mov	r1, r5
    2e76:	e59a      	b.n	29ae <ull_conn_llcp+0xf6>
				conn->llcp_length.tx_octets =
    2e78:	f8a4 219e 	strh.w	r2, [r4, #414]	; 0x19e
				conn->llcp_length.tx_time =
    2e7c:	f8b4 11a6 	ldrh.w	r1, [r4, #422]	; 0x1a6
    2e80:	f8a4 11a2 	strh.w	r1, [r4, #418]	; 0x1a2
				conn->llcp_length.cache.tx_octets = 0;
    2e84:	2200      	movs	r2, #0
    2e86:	f8a4 21a4 	strh.w	r2, [r4, #420]	; 0x1a4
			conn->llcp_length.state =
    2e8a:	f362 0302 	bfi	r3, r2, #0, #3
    2e8e:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
    2e92:	e7c1      	b.n	2e18 <ull_conn_llcp+0x560>
    2e94:	2206      	movs	r2, #6
    2e96:	e7f8      	b.n	2e8a <ull_conn_llcp+0x5d2>
		LL_ASSERT(0);
    2e98:	f640 43f6 	movw	r3, #3318	; 0xcf6
    2e9c:	e614      	b.n	2ac8 <ull_conn_llcp+0x210>
		} else if (conn->llcp_phy.ack != conn->llcp_phy.req) {
    2e9e:	f894 11a8 	ldrb.w	r1, [r4, #424]	; 0x1a8
    2ea2:	f894 31a9 	ldrb.w	r3, [r4, #425]	; 0x1a9
    2ea6:	428b      	cmp	r3, r1
    2ea8:	f43f ad35 	beq.w	2916 <ull_conn_llcp+0x5e>
	switch (conn->llcp_phy.state) {
    2eac:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
    2eb0:	f003 0003 	and.w	r0, r3, #3
    2eb4:	2803      	cmp	r0, #3
    2eb6:	f200 808f 	bhi.w	2fd8 <ull_conn_llcp+0x720>
    2eba:	a501      	add	r5, pc, #4	; (adr r5, 2ec0 <ull_conn_llcp+0x608>)
    2ebc:	f855 f020 	ldr.w	pc, [r5, r0, lsl #2]
    2ec0:	00002ed1 	.word	0x00002ed1
    2ec4:	00002917 	.word	0x00002917
    2ec8:	00002917 	.word	0x00002917
    2ecc:	00002f35 	.word	0x00002f35
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    2ed0:	4843      	ldr	r0, [pc, #268]	; (2fe0 <ull_conn_llcp+0x728>)
    2ed2:	f021 f87c 	bl	23fce <mem_acquire>
		if (!tx) {
    2ed6:	4601      	mov	r1, r0
    2ed8:	2800      	cmp	r0, #0
    2eda:	f43f ad1c 	beq.w	2916 <ull_conn_llcp+0x5e>
		conn->phy_pref_tx = conn->llcp_phy.tx;
    2ede:	f894 21aa 	ldrb.w	r2, [r4, #426]	; 0x1aa
    2ee2:	f894 31ac 	ldrb.w	r3, [r4, #428]	; 0x1ac
		conn->phy_pref_flags = conn->llcp_phy.flags;
    2ee6:	f894 51ab 	ldrb.w	r5, [r4, #427]	; 0x1ab
		conn->phy_pref_tx = conn->llcp_phy.tx;
    2eea:	f3c2 0082 	ubfx	r0, r2, #2, #3
    2eee:	f360 0302 	bfi	r3, r0, #0, #3
		conn->phy_pref_rx = conn->llcp_phy.rx;
    2ef2:	f3c2 1242 	ubfx	r2, r2, #5, #3
    2ef6:	f362 1306 	bfi	r3, r2, #4, #3
		conn->phy_pref_flags = conn->llcp_phy.flags;
    2efa:	f3c5 0540 	ubfx	r5, r5, #1, #1
    2efe:	f365 03c3 	bfi	r3, r5, #3, #1
    2f02:	f884 31ac 	strb.w	r3, [r4, #428]	; 0x1ac
		conn->llcp_phy.state = LLCP_PHY_STATE_ACK_WAIT;
    2f06:	f8b4 31aa 	ldrh.w	r3, [r4, #426]	; 0x1aa
    2f0a:	f423 7381 	bic.w	r3, r3, #258	; 0x102
    2f0e:	f023 0301 	bic.w	r3, r3, #1
    2f12:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    2f16:	f043 0301 	orr.w	r3, r3, #1
    2f1a:	f8a4 31aa 	strh.w	r3, [r4, #426]	; 0x1aa
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    2f1e:	790b      	ldrb	r3, [r1, #4]
		pr->tx_phys = conn->llcp_phy.tx;
    2f20:	7208      	strb	r0, [r1, #8]
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    2f22:	f043 0303 	orr.w	r3, r3, #3
    2f26:	710b      	strb	r3, [r1, #4]
		pdu_ctrl_tx->len =
    2f28:	2303      	movs	r3, #3
    2f2a:	714b      	strb	r3, [r1, #5]
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_REQ;
    2f2c:	2316      	movs	r3, #22
    2f2e:	71cb      	strb	r3, [r1, #7]
		pr->rx_phys = conn->llcp_phy.rx;
    2f30:	724a      	strb	r2, [r1, #9]
    2f32:	e566      	b.n	2a02 <ull_conn_llcp+0x14a>
		conn->llcp_phy.ack = conn->llcp_phy.req;
    2f34:	f884 11a9 	strb.w	r1, [r4, #425]	; 0x1a9
		if (conn->llcp_phy.tx & BIT(1)) {
    2f38:	f3c3 0182 	ubfx	r1, r3, #2, #3
    2f3c:	078d      	lsls	r5, r1, #30
    2f3e:	d539      	bpl.n	2fb4 <ull_conn_llcp+0x6fc>
			conn->llcp_phy.tx = BIT(1);
    2f40:	2102      	movs	r1, #2
			conn->llcp_phy.tx = 0U;
    2f42:	f361 0384 	bfi	r3, r1, #2, #3
    2f46:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
		if (conn->llcp_phy.rx & BIT(1)) {
    2f4a:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
    2f4e:	0959      	lsrs	r1, r3, #5
    2f50:	078f      	lsls	r7, r1, #30
    2f52:	d538      	bpl.n	2fc6 <ull_conn_llcp+0x70e>
			conn->llcp_phy.rx = BIT(1);
    2f54:	2102      	movs	r1, #2
			conn->llcp_phy.rx = 0U;
    2f56:	f361 1347 	bfi	r3, r1, #5, #3
    2f5a:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
		if (conn->llcp_phy.tx != conn->lll.phy_tx) {
    2f5e:	f894 11aa 	ldrb.w	r1, [r4, #426]	; 0x1aa
    2f62:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
    2f66:	f3c1 0082 	ubfx	r0, r1, #2, #3
    2f6a:	f003 0307 	and.w	r3, r3, #7
			conn->llcp.phy_upd_ind.tx = 0U;
    2f6e:	4283      	cmp	r3, r0
    2f70:	bf08      	it	eq
    2f72:	2000      	moveq	r0, #0
    2f74:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    2f78:	f360 0384 	bfi	r3, r0, #2, #3
		if (conn->llcp_phy.rx != conn->lll.phy_rx) {
    2f7c:	f894 0065 	ldrb.w	r0, [r4, #101]	; 0x65
    2f80:	0949      	lsrs	r1, r1, #5
    2f82:	f000 0007 	and.w	r0, r0, #7
			conn->llcp.phy_upd_ind.rx = 0U;
    2f86:	4288      	cmp	r0, r1
    2f88:	bf08      	it	eq
    2f8a:	2100      	moveq	r1, #0
    2f8c:	f361 1347 	bfi	r3, r1, #5, #3
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
    2f90:	f894 11ab 	ldrb.w	r1, [r4, #427]	; 0x1ab
		conn->llcp.phy_upd_ind.initiate = 1U;
    2f94:	b2db      	uxtb	r3, r3
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
    2f96:	f3c1 0180 	ubfx	r1, r1, #2, #1
    2f9a:	f043 0301 	orr.w	r3, r3, #1
    2f9e:	f361 0341 	bfi	r3, r1, #1, #1
    2fa2:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
		conn->llcp_ack -= 2U;
    2fa6:	3a02      	subs	r2, #2
		conn->llcp_type = LLCP_PHY_UPD;
    2fa8:	2306      	movs	r3, #6
    2faa:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
		conn->llcp_ack -= 2U;
    2fae:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
	break;
    2fb2:	e4b0      	b.n	2916 <ull_conn_llcp+0x5e>
		} else if (conn->llcp_phy.tx & BIT(0)) {
    2fb4:	07c8      	lsls	r0, r1, #31
    2fb6:	d501      	bpl.n	2fbc <ull_conn_llcp+0x704>
			conn->llcp_phy.tx = BIT(0);
    2fb8:	2101      	movs	r1, #1
    2fba:	e7c2      	b.n	2f42 <ull_conn_llcp+0x68a>
		} else if (conn->llcp_phy.tx & BIT(2)) {
    2fbc:	f011 0104 	ands.w	r1, r1, #4
			conn->llcp_phy.tx = BIT(2);
    2fc0:	bf18      	it	ne
    2fc2:	2104      	movne	r1, #4
    2fc4:	e7bd      	b.n	2f42 <ull_conn_llcp+0x68a>
		} else if (conn->llcp_phy.rx & BIT(0)) {
    2fc6:	07ce      	lsls	r6, r1, #31
    2fc8:	d501      	bpl.n	2fce <ull_conn_llcp+0x716>
			conn->llcp_phy.rx = BIT(0);
    2fca:	2101      	movs	r1, #1
    2fcc:	e7c3      	b.n	2f56 <ull_conn_llcp+0x69e>
		} else if (conn->llcp_phy.rx & BIT(2)) {
    2fce:	f011 0104 	ands.w	r1, r1, #4
			conn->llcp_phy.rx = BIT(2);
    2fd2:	bf18      	it	ne
    2fd4:	2104      	movne	r1, #4
    2fd6:	e7be      	b.n	2f56 <ull_conn_llcp+0x69e>
		LL_ASSERT(0);
    2fd8:	f640 5377 	movw	r3, #3447	; 0xd77
    2fdc:	e574      	b.n	2ac8 <ull_conn_llcp+0x210>
    2fde:	bf00      	nop
    2fe0:	200014ec 	.word	0x200014ec
    2fe4:	00064754 	.word	0x00064754
    2fe8:	0006481b 	.word	0x0006481b
    2fec:	000632fe 	.word	0x000632fe
	conn_upd = conn_upd_curr;
    2ff0:	4b29      	ldr	r3, [pc, #164]	; (3098 <ull_conn_llcp+0x7e0>)
	if (!conn_upd) {
    2ff2:	681a      	ldr	r2, [r3, #0]
    2ff4:	b902      	cbnz	r2, 2ff8 <ull_conn_llcp+0x740>
		conn_upd_curr = conn;
    2ff6:	601c      	str	r4, [r3, #0]
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
    2ff8:	8e62      	ldrh	r2, [r4, #50]	; 0x32
    2ffa:	8ee6      	ldrh	r6, [r4, #54]	; 0x36
    2ffc:	4416      	add	r6, r2
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
    2ffe:	f894 2106 	ldrb.w	r2, [r4, #262]	; 0x106
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
    3002:	4456      	add	r6, sl
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
    3004:	f012 0003 	ands.w	r0, r2, #3
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
    3008:	b2b6      	uxth	r6, r6
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
    300a:	d049      	beq.n	30a0 <ull_conn_llcp+0x7e8>
		rx = ll_pdu_rx_alloc_peek(1);
    300c:	2001      	movs	r0, #1
    300e:	f00f ff37 	bl	12e80 <ll_pdu_rx_alloc_peek>
		if (!rx) {
    3012:	4607      	mov	r7, r0
    3014:	2800      	cmp	r0, #0
    3016:	f000 8239 	beq.w	348c <ull_conn_llcp+0xbd4>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    301a:	4820      	ldr	r0, [pc, #128]	; (309c <ull_conn_llcp+0x7e4>)
    301c:	f020 ffd7 	bl	23fce <mem_acquire>
		if (!tx) {
    3020:	4605      	mov	r5, r0
    3022:	2800      	cmp	r0, #0
    3024:	f000 8232 	beq.w	348c <ull_conn_llcp+0xbd4>
		(void)ll_pdu_rx_alloc();
    3028:	f00f ff42 	bl	12eb0 <ll_pdu_rx_alloc>
		rx->hdr.link->mem = conn->llcp_rx;
    302c:	683b      	ldr	r3, [r7, #0]
    302e:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
    3032:	605a      	str	r2, [r3, #4]
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
    3034:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
		conn->llcp_rx = rx;
    3038:	f8c4 7100 	str.w	r7, [r4, #256]	; 0x100
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
    303c:	f36f 0301 	bfc	r3, #0, #2
    3040:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
    3044:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    3046:	441e      	add	r6, r3
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    3048:	792b      	ldrb	r3, [r5, #4]
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
    304a:	3606      	adds	r6, #6
    304c:	b2b6      	uxth	r6, r6
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    304e:	f043 0303 	orr.w	r3, r3, #3
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
    3052:	f8a4 60ec 	strh.w	r6, [r4, #236]	; 0xec
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    3056:	712b      	strb	r3, [r5, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_update_ind) +
    3058:	230c      	movs	r3, #12
    305a:	716b      	strb	r3, [r5, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND;
    305c:	2300      	movs	r3, #0
    305e:	71eb      	strb	r3, [r5, #7]
	pdu_ctrl_tx->llctrl.conn_update_ind.win_size = conn->llcp_cu.win_size;
    3060:	f894 3114 	ldrb.w	r3, [r4, #276]	; 0x114
    3064:	722b      	strb	r3, [r5, #8]
	pdu_ctrl_tx->llctrl.conn_update_ind.win_offset =
    3066:	f240 42e2 	movw	r2, #1250	; 0x4e2
		sys_cpu_to_le16(conn->llcp_cu.win_offset_us / 1250U);
    306a:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
	pdu_ctrl_tx->llctrl.conn_update_ind.win_offset =
    306e:	fbb3 f3f2 	udiv	r3, r3, r2
    3072:	f8a5 3009 	strh.w	r3, [r5, #9]
	pdu_ctrl_tx->llctrl.conn_update_ind.interval =
    3076:	f8b4 3108 	ldrh.w	r3, [r4, #264]	; 0x108
    307a:	f8a5 300b 	strh.w	r3, [r5, #11]
	pdu_ctrl_tx->llctrl.conn_update_ind.latency =
    307e:	f8b4 310a 	ldrh.w	r3, [r4, #266]	; 0x10a
    3082:	f8a5 300d 	strh.w	r3, [r5, #13]
	pdu_ctrl_tx->llctrl.conn_update_ind.timeout =
    3086:	f8b4 310c 	ldrh.w	r3, [r4, #268]	; 0x10c
    308a:	f8a5 300f 	strh.w	r3, [r5, #15]
	pdu_ctrl_tx->llctrl.conn_update_ind.instant =
    308e:	f8a5 6011 	strh.w	r6, [r5, #17]
		ind = &pdu_ctrl_tx->llctrl.phy_upd_ind;
		ind->m_to_s_phy = conn->llcp.phy_upd_ind.tx;
		ind->s_to_m_phy = conn->llcp.phy_upd_ind.rx;
		ind->instant = sys_cpu_to_le16(conn->llcp.phy_upd_ind.instant);

		ctrl_tx_enqueue(conn, tx);
    3092:	4629      	mov	r1, r5
    3094:	e1f7      	b.n	3486 <ull_conn_llcp+0xbce>
    3096:	bf00      	nop
    3098:	2000146c 	.word	0x2000146c
    309c:	200014ec 	.word	0x200014ec
	instant_latency = (event_counter - conn->llcp.conn_upd.instant) &
    30a0:	f8b4 20ec 	ldrh.w	r2, [r4, #236]	; 0xec
    30a4:	920b      	str	r2, [sp, #44]	; 0x2c
    30a6:	1ab7      	subs	r7, r6, r2
    30a8:	b2bf      	uxth	r7, r7
	} else if (instant_latency <= 0x7FFF) {
    30aa:	043d      	lsls	r5, r7, #16
    30ac:	f100 81ee 	bmi.w	348c <ull_conn_llcp+0xbd4>
		conn->llcp_cu.ack = conn->llcp_cu.req;
    30b0:	f894 2104 	ldrb.w	r2, [r4, #260]	; 0x104
    30b4:	f884 2105 	strb.w	r2, [r4, #261]	; 0x105
		conn->llcp_ack = conn->llcp_req;
    30b8:	f884 10e9 	strb.w	r1, [r4, #233]	; 0xe9
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
    30bc:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
    30c0:	f894 1170 	ldrb.w	r1, [r4, #368]	; 0x170
    30c4:	428a      	cmp	r2, r1
    30c6:	d009      	beq.n	30dc <ull_conn_llcp+0x824>
		    (conn->llcp_conn_param.state == LLCP_CPR_STATE_UPD)) {
    30c8:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
    30cc:	f002 0207 	and.w	r2, r2, #7
    30d0:	2a05      	cmp	r2, #5
			conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
    30d2:	bf04      	itt	eq
    30d4:	f884 1171 	strbeq.w	r1, [r4, #369]	; 0x171
			conn->procedure_expire = 0U;
    30d8:	f8a4 00cc 	strheq.w	r0, [r4, #204]	; 0xcc
		if (conn_upd_curr == conn) {
    30dc:	681a      	ldr	r2, [r3, #0]
		rx = conn->llcp_rx;
    30de:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
		if (conn_upd_curr == conn) {
    30e2:	4294      	cmp	r4, r2
			conn_upd_curr = NULL;
    30e4:	bf04      	itt	eq
    30e6:	2200      	moveq	r2, #0
    30e8:	601a      	streq	r2, [r3, #0]
		LL_ASSERT(rx && rx->hdr.link);
    30ea:	b10d      	cbz	r5, 30f0 <ull_conn_llcp+0x838>
    30ec:	682b      	ldr	r3, [r5, #0]
    30ee:	b963      	cbnz	r3, 310a <ull_conn_llcp+0x852>
    30f0:	f640 039b 	movw	r3, #2203	; 0x89b
    30f4:	4ac0      	ldr	r2, [pc, #768]	; (33f8 <ull_conn_llcp+0xb40>)
    30f6:	49c1      	ldr	r1, [pc, #772]	; (33fc <ull_conn_llcp+0xb44>)
    30f8:	48c1      	ldr	r0, [pc, #772]	; (3400 <ull_conn_llcp+0xb48>)
    30fa:	f01c fe5a 	bl	1fdb2 <printk>
    30fe:	4040      	eors	r0, r0
    3100:	f380 8811 	msr	BASEPRI, r0
    3104:	f04f 0003 	mov.w	r0, #3
    3108:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
    310a:	6828      	ldr	r0, [r5, #0]
		if ((conn->llcp_cu.interval != lll->interval) ||
    310c:	f8b4 2108 	ldrh.w	r2, [r4, #264]	; 0x108
		conn->llcp_rx = rx->hdr.link->mem;
    3110:	6843      	ldr	r3, [r0, #4]
    3112:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		if ((conn->llcp_cu.interval != lll->interval) ||
    3116:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
    3118:	f8b4 c10a 	ldrh.w	ip, [r4, #266]	; 0x10a
    311c:	f8b4 110c 	ldrh.w	r1, [r4, #268]	; 0x10c
    3120:	429a      	cmp	r2, r3
    3122:	d113      	bne.n	314c <ull_conn_llcp+0x894>
    3124:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    3126:	4563      	cmp	r3, ip
    3128:	d110      	bne.n	314c <ull_conn_llcp+0x894>
		    (RADIO_CONN_EVENTS(conn->llcp_cu.timeout * 10000U,
    312a:	f240 43e2 	movw	r3, #1250	; 0x4e2
    312e:	fb03 fe02 	mul.w	lr, r3, r2
    3132:	f242 7310 	movw	r3, #10000	; 0x2710
    3136:	fb03 e301 	mla	r3, r3, r1, lr
    313a:	3b01      	subs	r3, #1
    313c:	fbb3 f3fe 	udiv	r3, r3, lr
		    (conn->llcp_cu.latency != lll->latency) ||
    3140:	f8b4 e0c6 	ldrh.w	lr, [r4, #198]	; 0xc6
    3144:	b29b      	uxth	r3, r3
    3146:	459e      	cmp	lr, r3
    3148:	f000 812e 	beq.w	33a8 <ull_conn_llcp+0xaf0>
			rx->hdr.handle = lll->handle;
    314c:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    314e:	80eb      	strh	r3, [r5, #6]
			rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
    3150:	230a      	movs	r3, #10
    3152:	712b      	strb	r3, [r5, #4]
			cu->status = 0x00;
    3154:	2300      	movs	r3, #0
    3156:	f885 3020 	strb.w	r3, [r5, #32]
			cu->interval = conn->llcp_cu.interval;
    315a:	846a      	strh	r2, [r5, #34]	; 0x22
			cu->latency = conn->llcp_cu.latency;
    315c:	f8a5 c024 	strh.w	ip, [r5, #36]	; 0x24
			cu->timeout = conn->llcp_cu.timeout;
    3160:	84e9      	strh	r1, [r5, #38]	; 0x26
		ll_rx_put(rx->hdr.link, rx);
    3162:	4629      	mov	r1, r5
    3164:	f00f fe7c 	bl	12e60 <ll_rx_put>
		ll_rx_sched();
    3168:	f00f fe84 	bl	12e74 <ll_rx_sched>
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
    316c:	6823      	ldr	r3, [r4, #0]
    316e:	2b00      	cmp	r3, #0
    3170:	da0a      	bge.n	3188 <ull_conn_llcp+0x8d0>
			u32_t ticks_prepare_to_start =
    3172:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
			conn->evt.ticks_xtal_to_start &= ~XON_BITMASK;
    3176:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
			ticks_at_expire -= (conn->evt.ticks_xtal_to_start -
    317a:	4290      	cmp	r0, r2
    317c:	bf2c      	ite	cs
    317e:	4480      	addcs	r8, r0
    3180:	4490      	addcc	r8, r2
			conn->evt.ticks_xtal_to_start &= ~XON_BITMASK;
    3182:	6023      	str	r3, [r4, #0]
			ticks_at_expire -= (conn->evt.ticks_xtal_to_start -
    3184:	eba8 0803 	sub.w	r8, r8, r3
		conn_interval_old = instant_latency * lll->interval;
    3188:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
		latency = conn_interval_old / conn->llcp_cu.interval;
    318a:	f8b4 5108 	ldrh.w	r5, [r4, #264]	; 0x108
    318e:	f8df b298 	ldr.w	fp, [pc, #664]	; 3428 <ull_conn_llcp+0xb70>
		conn_interval_old = instant_latency * lll->interval;
    3192:	fb13 f307 	smulbb	r3, r3, r7
    3196:	b29b      	uxth	r3, r3
		latency = conn_interval_old / conn->llcp_cu.interval;
    3198:	fbb3 f1f5 	udiv	r1, r3, r5
    319c:	fa1f f981 	uxth.w	r9, r1
		conn_interval_new = latency * conn->llcp_cu.interval;
    31a0:	fb15 f209 	smulbb	r2, r5, r9
    31a4:	b292      	uxth	r2, r2
		if (conn_interval_new > conn_interval_old) {
    31a6:	4293      	cmp	r3, r2
    31a8:	f240 40e2 	movw	r0, #1250	; 0x4e2
    31ac:	f080 80ff 	bcs.w	33ae <ull_conn_llcp+0xaf6>
			ticks_at_expire += HAL_TICKER_US_TO_TICKS(
    31b0:	1ad3      	subs	r3, r2, r3
    31b2:	4358      	muls	r0, r3
    31b4:	fba0 010b 	umull	r0, r1, r0, fp
    31b8:	a38d      	add	r3, pc, #564	; (adr r3, 33f0 <ull_conn_llcp+0xb38>)
    31ba:	e9d3 2300 	ldrd	r2, r3, [r3]
    31be:	f7fc ffdf 	bl	180 <__aeabi_uldivmod>
    31c2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    31c6:	4480      	add	r8, r0
		lll->latency_prepare += lazy;
    31c8:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    31ca:	449a      	add	sl, r3
		lll->latency_prepare -= (instant_latency - latency);
    31cc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    31ce:	1b9e      	subs	r6, r3, r6
		} else if (lll->role) {
    31d0:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
		lll->latency_prepare -= (instant_latency - latency);
    31d4:	444e      	add	r6, r9
    31d6:	4456      	add	r6, sl
		} else if (lll->role) {
    31d8:	2b00      	cmp	r3, #0
		conn_interval_us = conn->llcp_cu.interval * 1250U;
    31da:	f240 4ae2 	movw	sl, #1250	; 0x4e2
		lll->latency_prepare -= (instant_latency - latency);
    31de:	8666      	strh	r6, [r4, #50]	; 0x32
		conn_interval_us = conn->llcp_cu.interval * 1250U;
    31e0:	fb0a f505 	mul.w	r5, sl, r5
		} else if (lll->role) {
    31e4:	f280 80f1 	bge.w	33ca <ull_conn_llcp+0xb12>
			lll->slave.window_widening_prepare_us -=
    31e8:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
				lll->slave.window_widening_periodic_us *
    31ea:	6c63      	ldr	r3, [r4, #68]	; 0x44
			lll->slave.window_widening_prepare_us -=
    31ec:	fb03 2717 	mls	r7, r3, r7, r2
    31f0:	64e7      	str	r7, [r4, #76]	; 0x4c
				(((lll_conn_ppm_local_get() +
    31f2:	f021 fc78 	bl	24ae6 <lll_conn_ppm_local_get>
    31f6:	4606      	mov	r6, r0
				   lll_conn_ppm_get(conn->slave.sca)) *
    31f8:	f894 00dc 	ldrb.w	r0, [r4, #220]	; 0xdc
    31fc:	f3c0 0082 	ubfx	r0, r0, #2, #3
    3200:	f013 feb4 	bl	16f6c <lll_conn_ppm_get>
				conn->llcp_cu.win_size * 1250U;
    3204:	f894 2114 	ldrb.w	r2, [r4, #276]	; 0x114
				(((lll_conn_ppm_local_get() +
    3208:	4406      	add	r6, r0
				conn->llcp_cu.win_size * 1250U;
    320a:	fb0a f202 	mul.w	r2, sl, r2
			lll->slave.window_size_prepare_us =
    320e:	6562      	str	r2, [r4, #84]	; 0x54
				   lll_conn_ppm_get(conn->slave.sca)) *
    3210:	436e      	muls	r6, r5
			conn->slave.ticks_to_offset = 0U;
    3212:	2200      	movs	r2, #0
    3214:	f8c4 20e4 	str.w	r2, [r4, #228]	; 0xe4
				  conn_interval_us) + (1000000 - 1)) / 1000000U;
    3218:	f506 2674 	add.w	r6, r6, #999424	; 0xf4000
			lll->slave.window_widening_prepare_us +=
    321c:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
				  conn_interval_us) + (1000000 - 1)) / 1000000U;
    321e:	4879      	ldr	r0, [pc, #484]	; (3404 <ull_conn_llcp+0xb4c>)
    3220:	f206 263f 	addw	r6, r6, #575	; 0x23f
				(conn_interval_us >> 1) - EVENT_IFS_US;
    3224:	086b      	lsrs	r3, r5, #1
				  conn_interval_us) + (1000000 - 1)) / 1000000U;
    3226:	fbb6 f6f0 	udiv	r6, r6, r0
				lll->slave.window_widening_periodic_us *
    322a:	fb06 f009 	mul.w	r0, r6, r9
				(conn_interval_us >> 1) - EVENT_IFS_US;
    322e:	3b96      	subs	r3, #150	; 0x96
			lll->slave.window_widening_prepare_us +=
    3230:	4402      	add	r2, r0
			lll->slave.window_widening_periodic_us =
    3232:	6466      	str	r6, [r4, #68]	; 0x44
			lll->slave.window_widening_max_us =
    3234:	64a3      	str	r3, [r4, #72]	; 0x48
			lll->slave.window_widening_prepare_us +=
    3236:	429a      	cmp	r2, r3
    3238:	bf94      	ite	ls
    323a:	64e2      	strls	r2, [r4, #76]	; 0x4c
    323c:	64e3      	strhi	r3, [r4, #76]	; 0x4c
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
    323e:	fba0 010b 	umull	r0, r1, r0, fp
    3242:	a36b      	add	r3, pc, #428	; (adr r3, 33f0 <ull_conn_llcp+0xb38>)
    3244:	e9d3 2300 	ldrd	r2, r3, [r3]
    3248:	f7fc ff9a 	bl	180 <__aeabi_uldivmod>
    324c:	eba8 0800 	sub.w	r8, r8, r0
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
    3250:	f8d4 0110 	ldr.w	r0, [r4, #272]	; 0x110
    3254:	fbb0 f0fa 	udiv	r0, r0, sl
    3258:	fb0a f000 	mul.w	r0, sl, r0
    325c:	a364      	add	r3, pc, #400	; (adr r3, 33f0 <ull_conn_llcp+0xb38>)
    325e:	e9d3 2300 	ldrd	r2, r3, [r3]
    3262:	fba0 010b 	umull	r0, r1, r0, fp
    3266:	f7fc ff8b 	bl	180 <__aeabi_uldivmod>
			periodic_us -= lll->slave.window_widening_periodic_us;
    326a:	1bae      	subs	r6, r5, r6
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
    326c:	f020 497f 	bic.w	r9, r0, #4278190080	; 0xff000000
		lll->interval = conn->llcp_cu.interval;
    3270:	f8b4 3108 	ldrh.w	r3, [r4, #264]	; 0x108
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
    3274:	f8b4 210c 	ldrh.w	r2, [r4, #268]	; 0x10c
		lll->interval = conn->llcp_cu.interval;
    3278:	85e3      	strh	r3, [r4, #46]	; 0x2e
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
    327a:	f242 7310 	movw	r3, #10000	; 0x2710
    327e:	fb03 5202 	mla	r2, r3, r2, r5
		lll->latency = conn->llcp_cu.latency;
    3282:	f8b4 110a 	ldrh.w	r1, [r4, #266]	; 0x10a
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    3286:	4b60      	ldr	r3, [pc, #384]	; (3408 <ull_conn_llcp+0xb50>)
		lll->latency = conn->llcp_cu.latency;
    3288:	8621      	strh	r1, [r4, #48]	; 0x30
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
    328a:	3a01      	subs	r2, #1
    328c:	fbb2 f2f5 	udiv	r2, r2, r5
    3290:	f8a4 20c6 	strh.w	r2, [r4, #198]	; 0xc6
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    3294:	4a5d      	ldr	r2, [pc, #372]	; (340c <ull_conn_llcp+0xb54>)
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    3296:	442b      	add	r3, r5
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    3298:	442a      	add	r2, r5
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    329a:	fbb3 f3f5 	udiv	r3, r3, r5
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    329e:	fbb2 f5f5 	udiv	r5, r2, r5
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    32a2:	f8a4 30ca 	strh.w	r3, [r4, #202]	; 0xca
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    32a6:	1d8a      	adds	r2, r1, #6
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    32a8:	b2ab      	uxth	r3, r5
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    32aa:	4293      	cmp	r3, r2
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    32ac:	f8a4 30d2 	strh.w	r3, [r4, #210]	; 0xd2
				     (conn->apto_reload - (lll->latency + 6)) :
    32b0:	bfc2      	ittt	gt
    32b2:	1a5b      	subgt	r3, r3, r1
    32b4:	3b06      	subgt	r3, #6
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    32b6:	b29b      	uxthgt	r3, r3
    32b8:	f8a4 30ce 	strh.w	r3, [r4, #206]	; 0xce
		if (conn->llcp_cu.cmd) {
    32bc:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
    32c0:	0759      	lsls	r1, r3, #29
			conn->supervision_expire = 0U;
    32c2:	bf44      	itt	mi
    32c4:	2300      	movmi	r3, #0
    32c6:	f8a4 30c8 	strhmi.w	r3, [r4, #200]	; 0xc8
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
    32ca:	2102      	movs	r1, #2
    32cc:	2001      	movs	r0, #1
    32ce:	f015 fd49 	bl	18d64 <mayfly_is_enabled>
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW,
    32d2:	2200      	movs	r2, #0
    32d4:	2102      	movs	r1, #2
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
    32d6:	4682      	mov	sl, r0
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW,
    32d8:	2001      	movs	r0, #1
    32da:	f00d f983 	bl	105e4 <mayfly_enable>
		ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    32de:	4620      	mov	r0, r4
    32e0:	f011 fd9e 	bl	14e20 <ll_conn_handle_get>
    32e4:	3003      	adds	r0, #3
    32e6:	b2c5      	uxtb	r5, r0
		ticker_status =	ticker_stop(TICKER_INSTANCE_ID_CTLR,
    32e8:	4b49      	ldr	r3, [pc, #292]	; (3410 <ull_conn_llcp+0xb58>)
    32ea:	9400      	str	r4, [sp, #0]
    32ec:	462a      	mov	r2, r5
    32ee:	2101      	movs	r1, #1
    32f0:	2000      	movs	r0, #0
    32f2:	f00d feaf 	bl	11054 <ticker_stop>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    32f6:	f030 0302 	bics.w	r3, r0, #2
    32fa:	d00c      	beq.n	3316 <ull_conn_llcp+0xa5e>
    32fc:	f44f 6314 	mov.w	r3, #2368	; 0x940
    3300:	4a3d      	ldr	r2, [pc, #244]	; (33f8 <ull_conn_llcp+0xb40>)
    3302:	4944      	ldr	r1, [pc, #272]	; (3414 <ull_conn_llcp+0xb5c>)
    3304:	483e      	ldr	r0, [pc, #248]	; (3400 <ull_conn_llcp+0xb48>)
    3306:	f01c fd54 	bl	1fdb2 <printk>
    330a:	4040      	eors	r0, r0
    330c:	f380 8811 	msr	BASEPRI, r0
    3310:	f04f 0003 	mov.w	r0, #3
    3314:	df02      	svc	2
				     HAL_TICKER_US_TO_TICKS(periodic_us),
    3316:	fba6 670b 	umull	r6, r7, r6, fp
    331a:	a335      	add	r3, pc, #212	; (adr r3, 33f0 <ull_conn_llcp+0xb38>)
    331c:	e9d3 2300 	ldrd	r2, r3, [r3]
    3320:	4630      	mov	r0, r6
    3322:	4639      	mov	r1, r7
    3324:	f7fc ff2c 	bl	180 <__aeabi_uldivmod>
			ticker_start(TICKER_INSTANCE_ID_CTLR,
    3328:	4b3b      	ldr	r3, [pc, #236]	; (3418 <ull_conn_llcp+0xb60>)
    332a:	9408      	str	r4, [sp, #32]
    332c:	e9cd 4306 	strd	r4, r3, [sp, #24]
    3330:	4b3a      	ldr	r3, [pc, #232]	; (341c <ull_conn_llcp+0xb64>)
    3332:	9305      	str	r3, [sp, #20]
    3334:	68e3      	ldr	r3, [r4, #12]
    3336:	9304      	str	r3, [sp, #16]
    3338:	2300      	movs	r3, #0
    333a:	9303      	str	r3, [sp, #12]
				     HAL_TICKER_REMAINDER(periodic_us),
    333c:	4b38      	ldr	r3, [pc, #224]	; (3420 <ull_conn_llcp+0xb68>)
    333e:	f020 447f 	bic.w	r4, r0, #4278190080	; 0xff000000
    3342:	fba4 bc03 	umull	fp, ip, r4, r3
    3346:	2307      	movs	r3, #7
    3348:	fb03 cc04 	mla	ip, r3, r4, ip
    334c:	ebb6 000b 	subs.w	r0, r6, fp
    3350:	eb67 010c 	sbc.w	r1, r7, ip
    3354:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    3358:	2300      	movs	r3, #0
    335a:	f7fc ff11 	bl	180 <__aeabi_uldivmod>
			ticker_start(TICKER_INSTANCE_ID_CTLR,
    335e:	4643      	mov	r3, r8
    3360:	e9cd 4001 	strd	r4, r0, [sp, #4]
    3364:	f8cd 9000 	str.w	r9, [sp]
    3368:	462a      	mov	r2, r5
    336a:	2101      	movs	r1, #1
    336c:	2000      	movs	r0, #0
    336e:	f00d fddf 	bl	10f30 <ticker_start>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    3372:	f030 0302 	bics.w	r3, r0, #2
    3376:	d00c      	beq.n	3392 <ull_conn_llcp+0xada>
    3378:	f640 135a 	movw	r3, #2394	; 0x95a
    337c:	4a1e      	ldr	r2, [pc, #120]	; (33f8 <ull_conn_llcp+0xb40>)
    337e:	4925      	ldr	r1, [pc, #148]	; (3414 <ull_conn_llcp+0xb5c>)
    3380:	481f      	ldr	r0, [pc, #124]	; (3400 <ull_conn_llcp+0xb48>)
    3382:	f01c fd16 	bl	1fdb2 <printk>
    3386:	4040      	eors	r0, r0
    3388:	f380 8811 	msr	BASEPRI, r0
    338c:	f04f 0003 	mov.w	r0, #3
    3390:	df02      	svc	2
		if (mayfly_was_enabled) {
    3392:	f1ba 0f00 	cmp.w	sl, #0
    3396:	d004      	beq.n	33a2 <ull_conn_llcp+0xaea>
			mayfly_enable(TICKER_USER_ID_ULL_HIGH,
    3398:	2201      	movs	r2, #1
    339a:	2102      	movs	r1, #2
    339c:	4610      	mov	r0, r2
    339e:	f00d f921 	bl	105e4 <mayfly_enable>
				return -ECANCELED;
    33a2:	f06f 008b 	mvn.w	r0, #139	; 0x8b
    33a6:	e079      	b.n	349c <ull_conn_llcp+0xbe4>
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
    33a8:	2303      	movs	r3, #3
    33aa:	712b      	strb	r3, [r5, #4]
    33ac:	e6d9      	b.n	3162 <ull_conn_llcp+0x8aa>
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
    33ae:	fb05 3111 	mls	r1, r5, r1, r3
    33b2:	b289      	uxth	r1, r1
    33b4:	4348      	muls	r0, r1
    33b6:	a30e      	add	r3, pc, #56	; (adr r3, 33f0 <ull_conn_llcp+0xb38>)
    33b8:	e9d3 2300 	ldrd	r2, r3, [r3]
    33bc:	fba0 010b 	umull	r0, r1, r0, fp
    33c0:	f7fc fede 	bl	180 <__aeabi_uldivmod>
    33c4:	eba8 0800 	sub.w	r8, r8, r0
    33c8:	e6fe      	b.n	31c8 <ull_conn_llcp+0x910>
			LL_ASSERT(0);
    33ca:	f44f 6311 	mov.w	r3, #2320	; 0x910
    33ce:	4a0a      	ldr	r2, [pc, #40]	; (33f8 <ull_conn_llcp+0xb40>)
    33d0:	4914      	ldr	r1, [pc, #80]	; (3424 <ull_conn_llcp+0xb6c>)
    33d2:	480b      	ldr	r0, [pc, #44]	; (3400 <ull_conn_llcp+0xb48>)
    33d4:	f01c fced 	bl	1fdb2 <printk>
    33d8:	4040      	eors	r0, r0
    33da:	f380 8811 	msr	BASEPRI, r0
    33de:	f04f 0003 	mov.w	r0, #3
    33e2:	df02      	svc	2
		u32_t ticks_win_offset = 0;
    33e4:	f04f 0900 	mov.w	r9, #0
		periodic_us = conn_interval_us;
    33e8:	462e      	mov	r6, r5
    33ea:	e741      	b.n	3270 <ull_conn_llcp+0x9b8>
    33ec:	f3af 8000 	nop.w
    33f0:	1afd498d 	.word	0x1afd498d
    33f4:	00000007 	.word	0x00000007
    33f8:	00064754 	.word	0x00064754
    33fc:	0006481b 	.word	0x0006481b
    3400:	000632fe 	.word	0x000632fe
    3404:	000f4240 	.word	0x000f4240
    3408:	026259ff 	.word	0x026259ff
    340c:	01c9c37f 	.word	0x01c9c37f
    3410:	00014a0d 	.word	0x00014a0d
    3414:	000646b3 	.word	0x000646b3
    3418:	000149b5 	.word	0x000149b5
    341c:	0001750d 	.word	0x0001750d
    3420:	1afd498d 	.word	0x1afd498d
    3424:	00065948 	.word	0x00065948
    3428:	3b9aca00 	.word	0x3b9aca00
			event_counter = lll->event_counter +
    342c:	8e62      	ldrh	r2, [r4, #50]	; 0x32
    342e:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    3430:	4413      	add	r3, r2
					lll->latency_prepare + lazy;
    3432:	449a      	add	sl, r3
	if (conn->llcp.chan_map.initiate) {
    3434:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    3438:	07da      	lsls	r2, r3, #31
			event_counter = lll->event_counter +
    343a:	fa1f fa8a 	uxth.w	sl, sl
	if (conn->llcp.chan_map.initiate) {
    343e:	d530      	bpl.n	34a2 <ull_conn_llcp+0xbea>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    3440:	48cb      	ldr	r0, [pc, #812]	; (3770 <ull_conn_llcp+0xeb8>)
    3442:	f020 fdc4 	bl	23fce <mem_acquire>
		if (tx) {
    3446:	4601      	mov	r1, r0
    3448:	b300      	cbz	r0, 348c <ull_conn_llcp+0xbd4>
			conn->llcp.chan_map.initiate = 0U;
    344a:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    344e:	f36f 0300 	bfc	r3, #0, #1
    3452:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
			conn->llcp.chan_map.instant = event_counter +
    3456:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    3458:	449a      	add	sl, r3
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    345a:	7903      	ldrb	r3, [r0, #4]
						      conn->lll.latency + 6;
    345c:	f10a 0a06 	add.w	sl, sl, #6
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    3460:	f043 0303 	orr.w	r3, r3, #3
			conn->llcp.chan_map.instant = event_counter +
    3464:	f8a4 a0f2 	strh.w	sl, [r4, #242]	; 0xf2
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    3468:	7103      	strb	r3, [r0, #4]
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
    346a:	2308      	movs	r3, #8
    346c:	7143      	strb	r3, [r0, #5]
			pdu_ctrl_tx->llctrl.opcode =
    346e:	2301      	movs	r3, #1
    3470:	71c3      	strb	r3, [r0, #7]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    3472:	4623      	mov	r3, r4
    3474:	f853 0fed 	ldr.w	r0, [r3, #237]!
    3478:	6088      	str	r0, [r1, #8]
    347a:	791b      	ldrb	r3, [r3, #4]
    347c:	730b      	strb	r3, [r1, #12]
			pdu_ctrl_tx->llctrl.chan_map_ind.instant =
    347e:	f8b4 30f2 	ldrh.w	r3, [r4, #242]	; 0xf2
    3482:	f8a1 300d 	strh.w	r3, [r1, #13]
			ctrl_tx_enqueue(conn, tx);
    3486:	4620      	mov	r0, r4
    3488:	f021 f966 	bl	24758 <ctrl_tx_enqueue>
	if (conn->llcp_terminate.ack != conn->llcp_terminate.req) {
    348c:	f894 2129 	ldrb.w	r2, [r4, #297]	; 0x129
    3490:	f894 3128 	ldrb.w	r3, [r4, #296]	; 0x128
    3494:	429a      	cmp	r2, r3
    3496:	f040 82d0 	bne.w	3a3a <ull_conn_llcp+0x1182>
	return 0;
    349a:	2000      	movs	r0, #0
}
    349c:	b00d      	add	sp, #52	; 0x34
    349e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (((event_counter - conn->llcp.chan_map.instant) & 0xFFFF)
    34a2:	f8b4 30f2 	ldrh.w	r3, [r4, #242]	; 0xf2
    34a6:	ebaa 0a03 	sub.w	sl, sl, r3
    34aa:	f41a 4f00 	tst.w	sl, #32768	; 0x8000
    34ae:	d1ed      	bne.n	348c <ull_conn_llcp+0xbd4>
    34b0:	4623      	mov	r3, r4
		conn->llcp_ack = conn->llcp_req;
    34b2:	f884 10e9 	strb.w	r1, [r4, #233]	; 0xe9
    34b6:	f853 2fed 	ldr.w	r2, [r3, #237]!
    34ba:	63a2      	str	r2, [r4, #56]	; 0x38
		memcpy(&lll->data_chan_map[0],
    34bc:	f104 0038 	add.w	r0, r4, #56	; 0x38
    34c0:	791b      	ldrb	r3, [r3, #4]
    34c2:	7103      	strb	r3, [r0, #4]
			util_ones_count_get(&lll->data_chan_map[0],
    34c4:	2105      	movs	r1, #5
    34c6:	f020 fdf2 	bl	240ae <util_ones_count_get>
		lll->data_chan_count =
    34ca:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
    34ce:	f360 0305 	bfi	r3, r0, #0, #6
    34d2:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
		conn->chm_updated = 1U;
    34d6:	2301      	movs	r3, #1
    34d8:	f884 31c4 	strb.w	r3, [r4, #452]	; 0x1c4
    34dc:	e7d6      	b.n	348c <ull_conn_llcp+0xbd4>
	if (conn->llcp.encryption.state) {
    34de:	f894 70ec 	ldrb.w	r7, [r4, #236]	; 0xec
    34e2:	f017 0703 	ands.w	r7, r7, #3
    34e6:	d05a      	beq.n	359e <ull_conn_llcp+0xce6>
		if (lll->role &&
    34e8:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
    34ec:	2b00      	cmp	r3, #0
    34ee:	dacd      	bge.n	348c <ull_conn_llcp+0xbd4>
    34f0:	2f01      	cmp	r7, #1
    34f2:	d1cb      	bne.n	348c <ull_conn_llcp+0xbd4>
{
	struct pdu_data *pdu_ctrl_tx;
	struct node_tx *tx;

	/* acquire tx mem */
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    34f4:	489e      	ldr	r0, [pc, #632]	; (3770 <ull_conn_llcp+0xeb8>)
    34f6:	f020 fd6a 	bl	23fce <mem_acquire>
	if (!tx) {
    34fa:	4607      	mov	r7, r0
    34fc:	2800      	cmp	r0, #0
    34fe:	d0c5      	beq.n	348c <ull_conn_llcp+0xbd4>
		return -ENOBUFS;
	}

	pdu_ctrl_tx = (void *)tx->pdu;
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    3500:	7903      	ldrb	r3, [r0, #4]
    3502:	f043 0303 	orr.w	r3, r3, #3
    3506:	7103      	strb	r3, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp) +
    3508:	230d      	movs	r3, #13
    350a:	7143      	strb	r3, [r0, #5]
			   sizeof(struct pdu_data_llctrl_enc_rsp);
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_RSP;
    350c:	2304      	movs	r3, #4
    350e:	71c3      	strb	r3, [r0, #7]
	BUILD_ASSERT(offsetof(__typeof(pdu_ctrl_tx->llctrl.enc_rsp), ivs) ==
		     (offsetof(__typeof(pdu_ctrl_tx->llctrl.enc_rsp), skds) +
		     sizeof(pdu_ctrl_tx->llctrl.enc_rsp.skds)));

	/* NOTE: if not sufficient random numbers, ignore waiting */
	entropy_get_entropy_isr(entropy, pdu_ctrl_tx->llctrl.enc_rsp.skds,
    3510:	4b98      	ldr	r3, [pc, #608]	; (3774 <ull_conn_llcp+0xebc>)
    3512:	6818      	ldr	r0, [r3, #0]
					  u32_t flags)
{
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->driver_api;

	if (unlikely(!api->get_entropy_isr)) {
    3514:	6843      	ldr	r3, [r0, #4]
    3516:	685e      	ldr	r6, [r3, #4]
    3518:	f107 0508 	add.w	r5, r7, #8
    351c:	b11e      	cbz	r6, 3526 <ull_conn_llcp+0xc6e>
		return -ENOTSUP;
	}

	return api->get_entropy_isr(dev, buffer, length, flags);
    351e:	2300      	movs	r3, #0
    3520:	220c      	movs	r2, #12
    3522:	4629      	mov	r1, r5
    3524:	47b0      	blx	r6
    3526:	682b      	ldr	r3, [r5, #0]
    3528:	f8c4 30f6 	str.w	r3, [r4, #246]	; 0xf6
    352c:	686b      	ldr	r3, [r5, #4]
    352e:	f8c4 30fa 	str.w	r3, [r4, #250]	; 0xfa
    3532:	693b      	ldr	r3, [r7, #16]
    3534:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	memcpy(&conn->llcp.encryption.skd[8],
	       &pdu_ctrl_tx->llctrl.enc_rsp.skds[0], 8);
	memcpy(&conn->lll.ccm_rx.iv[4],
	       &pdu_ctrl_tx->llctrl.enc_rsp.ivs[0], 4);

	ctrl_tx_enqueue(conn, tx);
    3538:	4639      	mov	r1, r7
    353a:	4620      	mov	r0, r4
    353c:	f021 f90c 	bl	24758 <ctrl_tx_enqueue>
			rx = ll_pdu_rx_alloc();
    3540:	f00f fcb6 	bl	12eb0 <ll_pdu_rx_alloc>
			if (!rx) {
    3544:	4601      	mov	r1, r0
    3546:	2800      	cmp	r0, #0
    3548:	d0a0      	beq.n	348c <ull_conn_llcp+0xbd4>
			rx->hdr.handle = conn->lll.handle;
    354a:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    354c:	80c3      	strh	r3, [r0, #6]
			pdu->ll_id = PDU_DATA_LLID_CTRL;
    354e:	f890 3020 	ldrb.w	r3, [r0, #32]
    3552:	f043 0303 	orr.w	r3, r3, #3
    3556:	f880 3020 	strb.w	r3, [r0, #32]
			pdu->len = offsetof(struct pdu_data_llctrl, enc_req) +
    355a:	2317      	movs	r3, #23
    355c:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
			rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    3560:	2502      	movs	r5, #2
			pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
    3562:	2303      	movs	r3, #3
			rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    3564:	7105      	strb	r5, [r0, #4]
			pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
    3566:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
    356a:	f8d4 3155 	ldr.w	r3, [r4, #341]	; 0x155
    356e:	6243      	str	r3, [r0, #36]	; 0x24
    3570:	f8d4 3159 	ldr.w	r3, [r4, #345]	; 0x159
    3574:	6283      	str	r3, [r0, #40]	; 0x28
			pdu->llctrl.enc_req.ediv[0] = conn->llcp_enc.ediv[0];
    3576:	f894 3153 	ldrb.w	r3, [r4, #339]	; 0x153
    357a:	f880 302c 	strb.w	r3, [r0, #44]	; 0x2c
			pdu->llctrl.enc_req.ediv[1] = conn->llcp_enc.ediv[1];
    357e:	f894 3154 	ldrb.w	r3, [r4, #340]	; 0x154
    3582:	f880 302d 	strb.w	r3, [r0, #45]	; 0x2d
			ll_rx_put(rx->hdr.link, rx);
    3586:	6800      	ldr	r0, [r0, #0]
    3588:	f00f fc6a 	bl	12e60 <ll_rx_put>
			ll_rx_sched();
    358c:	f00f fc72 	bl	12e74 <ll_rx_sched>
			conn->llcp.encryption.state = LLCP_ENC_STATE_LTK_WAIT;
    3590:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    3594:	f365 0301 	bfi	r3, r5, #0, #2
    3598:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
    359c:	e776      	b.n	348c <ull_conn_llcp+0xbd4>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    359e:	4874      	ldr	r0, [pc, #464]	; (3770 <ull_conn_llcp+0xeb8>)
    35a0:	f020 fd15 	bl	23fce <mem_acquire>
	if (!tx) {
    35a4:	4605      	mov	r5, r0
    35a6:	2800      	cmp	r0, #0
    35a8:	f43f af70 	beq.w	348c <ull_conn_llcp+0xbd4>
	if (!lll->role) {
    35ac:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
    35b0:	2b00      	cmp	r3, #0
	pdu_ctrl_tx = (void *)tx->pdu;
    35b2:	f100 0804 	add.w	r8, r0, #4
	if (!lll->role) {
    35b6:	db47      	blt.n	3648 <ull_conn_llcp+0xd90>
		ecb_encrypt(&conn->llcp_enc.ltk[0],
    35b8:	f104 067f 	add.w	r6, r4, #127	; 0x7f
    35bc:	4633      	mov	r3, r6
    35be:	463a      	mov	r2, r7
    35c0:	f104 01ee 	add.w	r1, r4, #238	; 0xee
    35c4:	f204 105d 	addw	r0, r4, #349	; 0x15d
    35c8:	f021 fb7f 	bl	24cca <ecb_encrypt>
    35cc:	4633      	mov	r3, r6
    35ce:	f104 02a0 	add.w	r2, r4, #160	; 0xa0
    35d2:	f104 018f 	add.w	r1, r4, #143	; 0x8f
    35d6:	f853 0b04 	ldr.w	r0, [r3], #4
    35da:	f842 0b04 	str.w	r0, [r2], #4
    35de:	428b      	cmp	r3, r1
    35e0:	d1f9      	bne.n	35d6 <ull_conn_llcp+0xd1e>
    35e2:	4621      	mov	r1, r4
		start_enc_rsp_send(conn, pdu_ctrl_tx);
    35e4:	4620      	mov	r0, r4
    35e6:	f851 2f98 	ldr.w	r2, [r1, #152]!
    35ea:	f8c4 20b9 	str.w	r2, [r4, #185]	; 0xb9
    35ee:	684a      	ldr	r2, [r1, #4]
    35f0:	f8c4 20bd 	str.w	r2, [r4, #189]	; 0xbd
		lll->ccm_rx.counter = 0;
    35f4:	2200      	movs	r2, #0
    35f6:	f884 208f 	strb.w	r2, [r4, #143]	; 0x8f
    35fa:	705a      	strb	r2, [r3, #1]
    35fc:	709a      	strb	r2, [r3, #2]
    35fe:	70da      	strb	r2, [r3, #3]
    3600:	711a      	strb	r2, [r3, #4]
    3602:	715a      	strb	r2, [r3, #5]
    3604:	719a      	strb	r2, [r3, #6]
    3606:	71da      	strb	r2, [r3, #7]
		lll->ccm_rx.direction = 0;
    3608:	f894 3097 	ldrb.w	r3, [r4, #151]	; 0x97
    360c:	f362 0300 	bfi	r3, r2, #0, #1
    3610:	f884 3097 	strb.w	r3, [r4, #151]	; 0x97
		lll->ccm_tx.direction = 1;
    3614:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
    3618:	f043 0301 	orr.w	r3, r3, #1
    361c:	f884 30b8 	strb.w	r3, [r4, #184]	; 0xb8
		lll->enc_rx = 1;
    3620:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
    3624:	f043 0308 	orr.w	r3, r3, #8
		lll->ccm_tx.counter = 0;
    3628:	e9c4 222c 	strd	r2, r2, [r4, #176]	; 0xb0
		lll->enc_rx = 1;
    362c:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
		start_enc_rsp_send(conn, pdu_ctrl_tx);
    3630:	4641      	mov	r1, r8
    3632:	f021 f894 	bl	2475e <start_enc_rsp_send>
			ctrl_tx_enqueue(conn, tx);
    3636:	4629      	mov	r1, r5
    3638:	4620      	mov	r0, r4
    363a:	f021 f88d 	bl	24758 <ctrl_tx_enqueue>
	conn->llcp_ack = conn->llcp_req;
    363e:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
    3642:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
    3646:	e721      	b.n	348c <ull_conn_llcp+0xbd4>
	else if (!lll->enc_rx) {
    3648:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
    364c:	071b      	lsls	r3, r3, #28
    364e:	d464      	bmi.n	371a <ull_conn_llcp+0xe62>
		if (conn->llcp.encryption.error_code) {
    3650:	f894 20ed 	ldrb.w	r2, [r4, #237]	; 0xed
    3654:	b1f2      	cbz	r2, 3694 <ull_conn_llcp+0xddc>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
    3656:	7903      	ldrb	r3, [r0, #4]
    3658:	f043 0303 	orr.w	r3, r3, #3
    365c:	7103      	strb	r3, [r0, #4]
	if (conn->common.fex_valid &&
    365e:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
    3662:	07df      	lsls	r7, r3, #31
    3664:	d511      	bpl.n	368a <ull_conn_llcp+0xdd2>
	    (conn->llcp_feature.features & BIT(BT_LE_FEAT_BIT_EXT_REJ_IND))) {
    3666:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
	if (conn->common.fex_valid &&
    366a:	075e      	lsls	r6, r3, #29
    366c:	d50d      	bpl.n	368a <ull_conn_llcp+0xdd2>
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
    366e:	2311      	movs	r3, #17
    3670:	71c3      	strb	r3, [r0, #7]
		p->reject_opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
    3672:	2303      	movs	r3, #3
    3674:	7203      	strb	r3, [r0, #8]
		p->error_code = conn->llcp.encryption.error_code;
    3676:	7242      	strb	r2, [r0, #9]
		pdu->len = sizeof(struct pdu_data_llctrl_reject_ext_ind);
    3678:	2302      	movs	r3, #2
		pdu->len = sizeof(struct pdu_data_llctrl_reject_ind);
    367a:	716b      	strb	r3, [r5, #5]
	pdu->len += offsetof(struct pdu_data_llctrl, reject_ind);
    367c:	796b      	ldrb	r3, [r5, #5]
    367e:	3301      	adds	r3, #1
    3680:	716b      	strb	r3, [r5, #5]
	conn->llcp.encryption.error_code = 0U;
    3682:	2300      	movs	r3, #0
    3684:	f884 30ed 	strb.w	r3, [r4, #237]	; 0xed
    3688:	e7d5      	b.n	3636 <ull_conn_llcp+0xd7e>
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
    368a:	230d      	movs	r3, #13
    368c:	71eb      	strb	r3, [r5, #7]
		p->error_code =	conn->llcp.encryption.error_code;
    368e:	722a      	strb	r2, [r5, #8]
		pdu->len = sizeof(struct pdu_data_llctrl_reject_ind);
    3690:	2301      	movs	r3, #1
    3692:	e7f2      	b.n	367a <ull_conn_llcp+0xdc2>
			ecb_encrypt(&conn->llcp_enc.ltk[0],
    3694:	f104 067f 	add.w	r6, r4, #127	; 0x7f
    3698:	4633      	mov	r3, r6
    369a:	f104 01ee 	add.w	r1, r4, #238	; 0xee
    369e:	f204 105d 	addw	r0, r4, #349	; 0x15d
    36a2:	f021 fb12 	bl	24cca <ecb_encrypt>
    36a6:	4633      	mov	r3, r6
    36a8:	f104 02a0 	add.w	r2, r4, #160	; 0xa0
    36ac:	f104 018f 	add.w	r1, r4, #143	; 0x8f
    36b0:	f853 0b04 	ldr.w	r0, [r3], #4
    36b4:	f842 0b04 	str.w	r0, [r2], #4
    36b8:	428b      	cmp	r3, r1
    36ba:	d1f9      	bne.n	36b0 <ull_conn_llcp+0xdf8>
    36bc:	4621      	mov	r1, r4
    36be:	f851 2f98 	ldr.w	r2, [r1, #152]!
    36c2:	f8c4 20b9 	str.w	r2, [r4, #185]	; 0xb9
    36c6:	684a      	ldr	r2, [r1, #4]
    36c8:	f8c4 20bd 	str.w	r2, [r4, #189]	; 0xbd
			lll->ccm_rx.counter = 0U;
    36cc:	2200      	movs	r2, #0
    36ce:	f884 208f 	strb.w	r2, [r4, #143]	; 0x8f
    36d2:	705a      	strb	r2, [r3, #1]
    36d4:	709a      	strb	r2, [r3, #2]
    36d6:	70da      	strb	r2, [r3, #3]
    36d8:	711a      	strb	r2, [r3, #4]
    36da:	715a      	strb	r2, [r3, #5]
    36dc:	719a      	strb	r2, [r3, #6]
    36de:	71da      	strb	r2, [r3, #7]
			lll->ccm_rx.direction = 1U;
    36e0:	f894 3097 	ldrb.w	r3, [r4, #151]	; 0x97
    36e4:	f043 0301 	orr.w	r3, r3, #1
    36e8:	f884 3097 	strb.w	r3, [r4, #151]	; 0x97
			lll->ccm_tx.direction = 0U;
    36ec:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
    36f0:	f362 0300 	bfi	r3, r2, #0, #1
    36f4:	f884 30b8 	strb.w	r3, [r4, #184]	; 0xb8
			lll->enc_rx = 1U;
    36f8:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
    36fc:	f043 0308 	orr.w	r3, r3, #8
    3700:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    3704:	792b      	ldrb	r3, [r5, #4]
    3706:	f043 0303 	orr.w	r3, r3, #3
			lll->ccm_tx.counter = 0U;
    370a:	e9c4 222c 	strd	r2, r2, [r4, #176]	; 0xb0
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    370e:	712b      	strb	r3, [r5, #4]
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
    3710:	2301      	movs	r3, #1
    3712:	716b      	strb	r3, [r5, #5]
			pdu_ctrl_tx->llctrl.opcode =
    3714:	2305      	movs	r3, #5
    3716:	71eb      	strb	r3, [r5, #7]
			ctrl_tx_enqueue(conn, tx);
    3718:	e78d      	b.n	3636 <ull_conn_llcp+0xd7e>
		start_enc_rsp_send(conn, pdu_ctrl_tx);
    371a:	4641      	mov	r1, r8
    371c:	4620      	mov	r0, r4
    371e:	f021 f81e 	bl	2475e <start_enc_rsp_send>
		ctrl_tx_enqueue(conn, tx);
    3722:	4629      	mov	r1, r5
    3724:	4620      	mov	r0, r4
    3726:	f021 f817 	bl	24758 <ctrl_tx_enqueue>
		conn->llcp_enc.pause_rx = 0U;
    372a:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
    372e:	f023 0303 	bic.w	r3, r3, #3
    3732:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
    3736:	e782      	b.n	363e <ull_conn_llcp+0xd86>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    3738:	480d      	ldr	r0, [pc, #52]	; (3770 <ull_conn_llcp+0xeb8>)
    373a:	f020 fc48 	bl	23fce <mem_acquire>
	if (tx) {
    373e:	4601      	mov	r1, r0
    3740:	2800      	cmp	r0, #0
    3742:	f43f aea3 	beq.w	348c <ull_conn_llcp+0xbd4>
		conn->llcp_ack = conn->llcp_req;
    3746:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
    374a:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    374e:	7903      	ldrb	r3, [r0, #4]
    3750:	f043 0303 	orr.w	r3, r3, #3
    3754:	7103      	strb	r3, [r0, #4]
		pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, ping_req) +
    3756:	2301      	movs	r3, #1
    3758:	7143      	strb	r3, [r0, #5]
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_REQ;
    375a:	2312      	movs	r3, #18
    375c:	71c3      	strb	r3, [r0, #7]
		ctrl_tx_enqueue(conn, tx);
    375e:	4620      	mov	r0, r4
    3760:	f020 fffa 	bl	24758 <ctrl_tx_enqueue>
		conn->procedure_expire = conn->procedure_reload;
    3764:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
    3768:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
    376c:	e68e      	b.n	348c <ull_conn_llcp+0xbd4>
    376e:	bf00      	nop
    3770:	200014ec 	.word	0x200014ec
    3774:	20001470 	.word	0x20001470
			event_counter = lll->event_counter +
    3778:	8e62      	ldrh	r2, [r4, #50]	; 0x32
    377a:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    377c:	4413      	add	r3, r2
	if (conn->llcp.phy_upd_ind.initiate) {
    377e:	f894 20ec 	ldrb.w	r2, [r4, #236]	; 0xec
					lll->latency_prepare + lazy;
    3782:	449a      	add	sl, r3
	if (conn->llcp.phy_upd_ind.initiate) {
    3784:	07d0      	lsls	r0, r2, #31
			event_counter = lll->event_counter +
    3786:	fa1f fa8a 	uxth.w	sl, sl
	if (conn->llcp.phy_upd_ind.initiate) {
    378a:	d568      	bpl.n	385e <ull_conn_llcp+0xfa6>
		rx = ll_pdu_rx_alloc_peek(2);
    378c:	2002      	movs	r0, #2
    378e:	f00f fb77 	bl	12e80 <ll_pdu_rx_alloc_peek>
		if (!rx) {
    3792:	4606      	mov	r6, r0
    3794:	2800      	cmp	r0, #0
    3796:	f43f ae79 	beq.w	348c <ull_conn_llcp+0xbd4>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    379a:	48bb      	ldr	r0, [pc, #748]	; (3a88 <ull_conn_llcp+0x11d0>)
    379c:	f020 fc17 	bl	23fce <mem_acquire>
		if (!tx) {
    37a0:	4605      	mov	r5, r0
    37a2:	2800      	cmp	r0, #0
    37a4:	f43f ae72 	beq.w	348c <ull_conn_llcp+0xbd4>
		conn->llcp.phy_upd_ind.initiate = 0U;
    37a8:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    37ac:	f36f 0300 	bfc	r3, #0, #1
    37b0:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
		if (!((conn->llcp.phy_upd_ind.tx |
    37b4:	b2db      	uxtb	r3, r3
    37b6:	f3c3 0782 	ubfx	r7, r3, #2, #3
    37ba:	ea57 1753 	orrs.w	r7, r7, r3, lsr #5
    37be:	d137      	bne.n	3830 <ull_conn_llcp+0xf78>
			conn->llcp_ack = conn->llcp_req;
    37c0:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
    37c4:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
			if (conn->llcp.phy_upd_ind.cmd) {
    37c8:	079b      	lsls	r3, r3, #30
			conn->llcp.phy_upd_ind.instant = 0U;
    37ca:	f8a4 70ee 	strh.w	r7, [r4, #238]	; 0xee
			if (conn->llcp.phy_upd_ind.cmd) {
    37ce:	d519      	bpl.n	3804 <ull_conn_llcp+0xf4c>
				(void)ll_pdu_rx_alloc();
    37d0:	f00f fb6e 	bl	12eb0 <ll_pdu_rx_alloc>
				rx->hdr.handle = lll->handle;
    37d4:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    37d6:	80f3      	strh	r3, [r6, #6]
				upd->status = 0U;
    37d8:	f886 7020 	strb.w	r7, [r6, #32]
				rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
    37dc:	230e      	movs	r3, #14
    37de:	7133      	strb	r3, [r6, #4]
				upd->tx = lll->phy_tx;
    37e0:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
				ll_rx_put(rx->hdr.link, rx);
    37e4:	6830      	ldr	r0, [r6, #0]
				upd->tx = lll->phy_tx;
    37e6:	f3c3 0302 	ubfx	r3, r3, #0, #3
    37ea:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
				upd->rx = lll->phy_rx;
    37ee:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
    37f2:	f3c3 0302 	ubfx	r3, r3, #0, #3
    37f6:	f886 3022 	strb.w	r3, [r6, #34]	; 0x22
				ll_rx_put(rx->hdr.link, rx);
    37fa:	4631      	mov	r1, r6
    37fc:	f00f fb30 	bl	12e60 <ll_rx_put>
				ll_rx_sched();
    3800:	f00f fb38 	bl	12e74 <ll_rx_sched>
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    3804:	792b      	ldrb	r3, [r5, #4]
    3806:	f043 0303 	orr.w	r3, r3, #3
    380a:	712b      	strb	r3, [r5, #4]
		pdu_ctrl_tx->len =
    380c:	2305      	movs	r3, #5
    380e:	716b      	strb	r3, [r5, #5]
		pdu_ctrl_tx->llctrl.opcode =
    3810:	2318      	movs	r3, #24
    3812:	71eb      	strb	r3, [r5, #7]
		ind->m_to_s_phy = conn->llcp.phy_upd_ind.tx;
    3814:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    3818:	f3c3 0382 	ubfx	r3, r3, #2, #3
    381c:	722b      	strb	r3, [r5, #8]
		ind->s_to_m_phy = conn->llcp.phy_upd_ind.rx;
    381e:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    3822:	f3c3 1342 	ubfx	r3, r3, #5, #3
    3826:	726b      	strb	r3, [r5, #9]
		ind->instant = sys_cpu_to_le16(conn->llcp.phy_upd_ind.instant);
    3828:	f8b4 30ee 	ldrh.w	r3, [r4, #238]	; 0xee
    382c:	816b      	strh	r3, [r5, #10]
    382e:	e430      	b.n	3092 <ull_conn_llcp+0x7da>
			conn->llcp.phy_upd_ind.instant = event_counter +
    3830:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    3832:	449a      	add	sl, r3
							 lll->latency +
    3834:	f10a 0a06 	add.w	sl, sl, #6
			conn->llcp.phy_upd_ind.instant = event_counter +
    3838:	f8a4 a0ee 	strh.w	sl, [r4, #238]	; 0xee
			(void)ll_pdu_rx_alloc();
    383c:	f00f fb38 	bl	12eb0 <ll_pdu_rx_alloc>
			rx->hdr.link->mem = conn->llcp_rx;
    3840:	6833      	ldr	r3, [r6, #0]
    3842:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
    3846:	605a      	str	r2, [r3, #4]
			conn->llcp_rx = rx;
    3848:	f8c4 6100 	str.w	r6, [r4, #256]	; 0x100
			rx = ll_pdu_rx_alloc();
    384c:	f00f fb30 	bl	12eb0 <ll_pdu_rx_alloc>
			rx->hdr.link->mem = conn->llcp_rx;
    3850:	6803      	ldr	r3, [r0, #0]
    3852:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
    3856:	605a      	str	r2, [r3, #4]
			conn->llcp_rx = rx;
    3858:	f8c4 0100 	str.w	r0, [r4, #256]	; 0x100
    385c:	e7d2      	b.n	3804 <ull_conn_llcp+0xf4c>
	} else if (((event_counter - conn->llcp.phy_upd_ind.instant) &
    385e:	f8b4 30ee 	ldrh.w	r3, [r4, #238]	; 0xee
    3862:	ebaa 0a03 	sub.w	sl, sl, r3
    3866:	f41a 4f00 	tst.w	sl, #32768	; 0x8000
    386a:	f47f ae0f 	bne.w	348c <ull_conn_llcp+0xbd4>
		old_tx = lll->phy_tx;
    386e:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
		old_rx = lll->phy_rx;
    3872:	f894 7065 	ldrb.w	r7, [r4, #101]	; 0x65
		conn->llcp_ack = conn->llcp_req;
    3876:	f884 10e9 	strb.w	r1, [r4, #233]	; 0xe9
		if (conn->llcp.phy_upd_ind.tx) {
    387a:	f012 0f1c 	tst.w	r2, #28
		old_tx = lll->phy_tx;
    387e:	f003 0807 	and.w	r8, r3, #7
		old_rx = lll->phy_rx;
    3882:	f007 0707 	and.w	r7, r7, #7
		u16_t eff_rx_time = lll->max_rx_time;
    3886:	f8b4 6062 	ldrh.w	r6, [r4, #98]	; 0x62
		if (conn->llcp.phy_upd_ind.tx) {
    388a:	d164      	bne.n	3956 <ull_conn_llcp+0x109e>
		u16_t eff_tx_time = lll->max_tx_time;
    388c:	f8b4 9060 	ldrh.w	r9, [r4, #96]	; 0x60
		if (conn->llcp.phy_upd_ind.rx) {
    3890:	f012 0fe0 	tst.w	r2, #224	; 0xe0
    3894:	d008      	beq.n	38a8 <ull_conn_llcp+0xff0>
			lll->phy_rx = conn->llcp.phy_upd_ind.rx;
    3896:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
    389a:	0952      	lsrs	r2, r2, #5
    389c:	f362 0302 	bfi	r3, r2, #0, #3
    38a0:	f884 3065 	strb.w	r3, [r4, #101]	; 0x65
		eff_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0);
    38a4:	f44f 76a4 	mov.w	r6, #328	; 0x148
		lll->phy_flags = conn->phy_pref_flags;
    38a8:	f894 31ac 	ldrb.w	r3, [r4, #428]	; 0x1ac
    38ac:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
		rx = conn->llcp_rx;
    38b0:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
		lll->phy_flags = conn->phy_pref_flags;
    38b4:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    38b8:	f363 02c3 	bfi	r2, r3, #3, #1
    38bc:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
		LL_ASSERT(rx && rx->hdr.link);
    38c0:	b10d      	cbz	r5, 38c6 <ull_conn_llcp+0x100e>
    38c2:	682b      	ldr	r3, [r5, #0]
    38c4:	b963      	cbnz	r3, 38e0 <ull_conn_llcp+0x1028>
    38c6:	f44f 6360 	mov.w	r3, #3584	; 0xe00
    38ca:	4a70      	ldr	r2, [pc, #448]	; (3a8c <ull_conn_llcp+0x11d4>)
    38cc:	4970      	ldr	r1, [pc, #448]	; (3a90 <ull_conn_llcp+0x11d8>)
    38ce:	4871      	ldr	r0, [pc, #452]	; (3a94 <ull_conn_llcp+0x11dc>)
    38d0:	f01c fa6f 	bl	1fdb2 <printk>
    38d4:	4040      	eors	r0, r0
    38d6:	f380 8811 	msr	BASEPRI, r0
    38da:	f04f 0003 	mov.w	r0, #3
    38de:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
    38e0:	6828      	ldr	r0, [r5, #0]
    38e2:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
    38e6:	6843      	ldr	r3, [r0, #4]
    38e8:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		if (!conn->llcp.phy_upd_ind.cmd && (lll->phy_tx == old_tx) &&
    38ec:	f894 e0ec 	ldrb.w	lr, [r4, #236]	; 0xec
    38f0:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
    38f4:	f3c2 0202 	ubfx	r2, r2, #0, #3
    38f8:	f3c3 0302 	ubfx	r3, r3, #0, #3
    38fc:	f01e 0f02 	tst.w	lr, #2
    3900:	fa5f fc82 	uxtb.w	ip, r2
    3904:	b2d9      	uxtb	r1, r3
    3906:	d140      	bne.n	398a <ull_conn_llcp+0x10d2>
    3908:	45c4      	cmp	ip, r8
    390a:	d13e      	bne.n	398a <ull_conn_llcp+0x10d2>
    390c:	428f      	cmp	r7, r1
    390e:	d13c      	bne.n	398a <ull_conn_llcp+0x10d2>
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
    3910:	2303      	movs	r3, #3
    3912:	712b      	strb	r3, [r5, #4]
			ll_rx_put(rx->hdr.link, rx);
    3914:	4629      	mov	r1, r5
    3916:	f00f faa3 	bl	12e60 <ll_rx_put>
				rx = conn->llcp_rx;
    391a:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
				LL_ASSERT(rx && rx->hdr.link);
    391e:	b10d      	cbz	r5, 3924 <ull_conn_llcp+0x106c>
    3920:	682b      	ldr	r3, [r5, #0]
    3922:	b963      	cbnz	r3, 393e <ull_conn_llcp+0x1086>
    3924:	f640 630f 	movw	r3, #3599	; 0xe0f
    3928:	4a58      	ldr	r2, [pc, #352]	; (3a8c <ull_conn_llcp+0x11d4>)
    392a:	4959      	ldr	r1, [pc, #356]	; (3a90 <ull_conn_llcp+0x11d8>)
    392c:	4859      	ldr	r0, [pc, #356]	; (3a94 <ull_conn_llcp+0x11dc>)
    392e:	f01c fa40 	bl	1fdb2 <printk>
    3932:	4040      	eors	r0, r0
    3934:	f380 8811 	msr	BASEPRI, r0
    3938:	f04f 0003 	mov.w	r0, #3
    393c:	df02      	svc	2
				conn->llcp_rx = rx->hdr.link->mem;
    393e:	6828      	ldr	r0, [r5, #0]
    3940:	6843      	ldr	r3, [r0, #4]
    3942:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
    3946:	2303      	movs	r3, #3
    3948:	712b      	strb	r3, [r5, #4]
		ll_rx_put(rx->hdr.link, rx);
    394a:	4629      	mov	r1, r5
    394c:	f00f fa88 	bl	12e60 <ll_rx_put>
		ll_rx_sched();
    3950:	f00f fa90 	bl	12e74 <ll_rx_sched>
    3954:	e59a      	b.n	348c <ull_conn_llcp+0xbd4>
			lll->phy_tx = conn->llcp.phy_upd_ind.tx;
    3956:	f3c2 0182 	ubfx	r1, r2, #2, #3
    395a:	f361 0302 	bfi	r3, r1, #0, #3
    395e:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
	u16_t time = PKT_US(max_octets, phy);
    3962:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
    3966:	330e      	adds	r3, #14
    3968:	00db      	lsls	r3, r3, #3
    396a:	f3c1 0140 	ubfx	r1, r1, #1, #1
    396e:	40cb      	lsrs	r3, r1
	if (time >= PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0)) {
    3970:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
    3974:	d306      	bcc.n	3984 <ull_conn_llcp+0x10cc>
		eff_time = MIN(time, default_time);
    3976:	f8b4 90d8 	ldrh.w	r9, [r4, #216]	; 0xd8
    397a:	b29b      	uxth	r3, r3
    397c:	4599      	cmp	r9, r3
    397e:	bf28      	it	cs
    3980:	4699      	movcs	r9, r3
    3982:	e785      	b.n	3890 <ull_conn_llcp+0xfd8>
		eff_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0);
    3984:	f44f 79a4 	mov.w	r9, #328	; 0x148
    3988:	e782      	b.n	3890 <ull_conn_llcp+0xfd8>
		rx->hdr.handle = lll->handle;
    398a:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
    398c:	80e9      	strh	r1, [r5, #6]
		rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
    398e:	210e      	movs	r1, #14
    3990:	7129      	strb	r1, [r5, #4]
		upd->status = 0U;
    3992:	2100      	movs	r1, #0
    3994:	f885 1020 	strb.w	r1, [r5, #32]
		upd->tx = lll->phy_tx;
    3998:	f885 2021 	strb.w	r2, [r5, #33]	; 0x21
		upd->rx = lll->phy_rx;
    399c:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
		ll_rx_put(rx->hdr.link, rx);
    39a0:	4629      	mov	r1, r5
    39a2:	f00f fa5d 	bl	12e60 <ll_rx_put>
		rx = conn->llcp_rx;
    39a6:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
		LL_ASSERT(rx && rx->hdr.link);
    39aa:	b10d      	cbz	r5, 39b0 <ull_conn_llcp+0x10f8>
    39ac:	682b      	ldr	r3, [r5, #0]
    39ae:	b963      	cbnz	r3, 39ca <ull_conn_llcp+0x1112>
    39b0:	f640 632c 	movw	r3, #3628	; 0xe2c
    39b4:	4a35      	ldr	r2, [pc, #212]	; (3a8c <ull_conn_llcp+0x11d4>)
    39b6:	4936      	ldr	r1, [pc, #216]	; (3a90 <ull_conn_llcp+0x11d8>)
    39b8:	4836      	ldr	r0, [pc, #216]	; (3a94 <ull_conn_llcp+0x11dc>)
    39ba:	f01c f9fa 	bl	1fdb2 <printk>
    39be:	4040      	eors	r0, r0
    39c0:	f380 8811 	msr	BASEPRI, r0
    39c4:	f04f 0003 	mov.w	r0, #3
    39c8:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
    39ca:	6828      	ldr	r0, [r5, #0]
    39cc:	6843      	ldr	r3, [r0, #4]
    39ce:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		if ((eff_tx_time <= lll->max_tx_time) &&
    39d2:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
    39d6:	454b      	cmp	r3, r9
    39d8:	d303      	bcc.n	39e2 <ull_conn_llcp+0x112a>
    39da:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
    39de:	42b3      	cmp	r3, r6
    39e0:	d2b1      	bcs.n	3946 <ull_conn_llcp+0x108e>
		rx->hdr.handle = lll->handle;
    39e2:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
		lll->max_tx_time = eff_tx_time;
    39e4:	f8a4 9060 	strh.w	r9, [r4, #96]	; 0x60
		lll->max_rx_time = eff_rx_time;
    39e8:	f8a4 6062 	strh.w	r6, [r4, #98]	; 0x62
		rx->hdr.handle = lll->handle;
    39ec:	80eb      	strh	r3, [r5, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    39ee:	2302      	movs	r3, #2
    39f0:	712b      	strb	r3, [r5, #4]
		pdu_rx->ll_id = PDU_DATA_LLID_CTRL;
    39f2:	f895 3020 	ldrb.w	r3, [r5, #32]
    39f6:	f043 0303 	orr.w	r3, r3, #3
    39fa:	f885 3020 	strb.w	r3, [r5, #32]
		pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
    39fe:	2309      	movs	r3, #9
    3a00:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
		pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
    3a04:	2315      	movs	r3, #21
    3a06:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
    3a0a:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
    3a0e:	84ab      	strh	r3, [r5, #36]	; 0x24
		lr->max_tx_octets = sys_cpu_to_le16(lll->max_tx_octets);
    3a10:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
    3a14:	852b      	strh	r3, [r5, #40]	; 0x28
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
    3a16:	84ee      	strh	r6, [r5, #38]	; 0x26
		lr->max_tx_time = sys_cpu_to_le16(lll->max_tx_time);
    3a18:	f8a5 902a 	strh.w	r9, [r5, #42]	; 0x2a
    3a1c:	e795      	b.n	394a <ull_conn_llcp+0x1092>
			LL_ASSERT(0);
    3a1e:	f240 3376 	movw	r3, #886	; 0x376
    3a22:	4a1a      	ldr	r2, [pc, #104]	; (3a8c <ull_conn_llcp+0x11d4>)
    3a24:	491c      	ldr	r1, [pc, #112]	; (3a98 <ull_conn_llcp+0x11e0>)
    3a26:	481b      	ldr	r0, [pc, #108]	; (3a94 <ull_conn_llcp+0x11dc>)
    3a28:	f01c f9c3 	bl	1fdb2 <printk>
    3a2c:	4040      	eors	r0, r0
    3a2e:	f380 8811 	msr	BASEPRI, r0
    3a32:	f04f 0003 	mov.w	r0, #3
    3a36:	df02      	svc	2
			break;
    3a38:	e528      	b.n	348c <ull_conn_llcp+0xbd4>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    3a3a:	4813      	ldr	r0, [pc, #76]	; (3a88 <ull_conn_llcp+0x11d0>)
    3a3c:	f020 fac7 	bl	23fce <mem_acquire>
		if (tx) {
    3a40:	4601      	mov	r1, r0
    3a42:	b180      	cbz	r0, 3a66 <ull_conn_llcp+0x11ae>
			conn->llcp_terminate.ack = conn->llcp_terminate.req;
    3a44:	f894 3128 	ldrb.w	r3, [r4, #296]	; 0x128
    3a48:	f884 3129 	strb.w	r3, [r4, #297]	; 0x129
			pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
    3a4c:	7903      	ldrb	r3, [r0, #4]
    3a4e:	f043 0303 	orr.w	r3, r3, #3
    3a52:	7103      	strb	r3, [r0, #4]
			pdu_tx->len = offsetof(struct pdu_data_llctrl,
    3a54:	2302      	movs	r3, #2
    3a56:	7143      	strb	r3, [r0, #5]
			pdu_tx->llctrl.opcode =
    3a58:	71c3      	strb	r3, [r0, #7]
			pdu_tx->llctrl.terminate_ind.error_code =
    3a5a:	f894 312a 	ldrb.w	r3, [r4, #298]	; 0x12a
    3a5e:	7203      	strb	r3, [r0, #8]
			ctrl_tx_enqueue(conn, tx);
    3a60:	4620      	mov	r0, r4
    3a62:	f020 fe79 	bl	24758 <ctrl_tx_enqueue>
		if (!conn->procedure_expire) {
    3a66:	f8b4 00cc 	ldrh.w	r0, [r4, #204]	; 0xcc
    3a6a:	2800      	cmp	r0, #0
    3a6c:	f47f ad15 	bne.w	349a <ull_conn_llcp+0xbe2>
			conn->procedure_expire = conn->supervision_reload;
    3a70:	f8b4 30c6 	ldrh.w	r3, [r4, #198]	; 0xc6
			if (conn->procedure_expire <= 1U) {
    3a74:	2b01      	cmp	r3, #1
    3a76:	d902      	bls.n	3a7e <ull_conn_llcp+0x11c6>
			conn->procedure_expire = conn->supervision_reload;
    3a78:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
    3a7c:	e50d      	b.n	349a <ull_conn_llcp+0xbe2>
				conn->procedure_expire++;
    3a7e:	3301      	adds	r3, #1
    3a80:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
    3a84:	e50a      	b.n	349c <ull_conn_llcp+0xbe4>
    3a86:	bf00      	nop
    3a88:	200014ec 	.word	0x200014ec
    3a8c:	00064754 	.word	0x00064754
    3a90:	0006481b 	.word	0x0006481b
    3a94:	000632fe 	.word	0x000632fe
    3a98:	00065948 	.word	0x00065948
    3a9c:	00000000 	.word	0x00000000

00003aa0 <ull_slave_setup>:
static void ticker_op_stop_adv_cb(u32_t status, void *param);
static void ticker_op_cb(u32_t status, void *param);

void ull_slave_setup(memq_link_t *link, struct node_rx_hdr *rx,
		     struct node_rx_ftr *ftr, struct lll_conn *lll)
{
    3aa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3aa4:	461d      	mov	r5, r3
	u16_t win_offset;
	u16_t timeout;
	u16_t interval;
	u8_t chan_sel;

	((struct lll_adv *)ftr->param)->conn = NULL;
    3aa6:	6813      	ldr	r3, [r2, #0]
{
    3aa8:	4690      	mov	r8, r2
	((struct lll_adv *)ftr->param)->conn = NULL;
    3aaa:	2200      	movs	r2, #0
    3aac:	609a      	str	r2, [r3, #8]
    3aae:	460a      	mov	r2, r1

	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
    3ab0:	f8d3 a000 	ldr.w	sl, [r3]
	conn = lll->hdr.parent;
    3ab4:	462b      	mov	r3, r5
{
    3ab6:	460c      	mov	r4, r1
    3ab8:	f832 1f32 	ldrh.w	r1, [r2, #50]!
	conn = lll->hdr.parent;
    3abc:	f853 6b0c 	ldr.w	r6, [r3], #12
    3ac0:	81a9      	strh	r1, [r5, #12]
    3ac2:	7892      	ldrb	r2, [r2, #2]
    3ac4:	709a      	strb	r2, [r3, #2]
    3ac6:	f8d4 302e 	ldr.w	r3, [r4, #46]	; 0x2e
    3aca:	60ab      	str	r3, [r5, #8]
    3acc:	4623      	mov	r3, r4
{
    3ace:	b093      	sub	sp, #76	; 0x4c
    3ad0:	f853 2f3e 	ldr.w	r2, [r3, #62]!
    3ad4:	61ea      	str	r2, [r5, #28]
    3ad6:	900b      	str	r0, [sp, #44]	; 0x2c

	/* Populate the slave context */
	pdu_adv = (void *)((struct node_rx_pdu *)rx)->pdu;
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
    3ad8:	f105 001c 	add.w	r0, r5, #28
    3adc:	791b      	ldrb	r3, [r3, #4]
    3ade:	7103      	strb	r3, [r0, #4]
	       sizeof(lll->data_chan_map));
	lll->data_chan_count = util_ones_count_get(&lll->data_chan_map[0],
    3ae0:	2105      	movs	r1, #5
    3ae2:	f020 fae4 	bl	240ae <util_ones_count_get>
    3ae6:	f895 3021 	ldrb.w	r3, [r5, #33]	; 0x21
    3aea:	f360 0305 	bfi	r3, r0, #0, #6
    3aee:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
			       sizeof(lll->data_chan_map));
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
    3af2:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    3af6:	f3c3 0304 	ubfx	r3, r3, #0, #5
    3afa:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
	interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);
    3afe:	8f27      	ldrh	r7, [r4, #56]	; 0x38
	lll->interval = interval;
    3b00:	826f      	strh	r7, [r5, #18]
	lll->latency = sys_le16_to_cpu(pdu_adv->connect_ind.latency);
    3b02:	f894 203b 	ldrb.w	r2, [r4, #59]	; 0x3b
    3b06:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
    3b0a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    3b0e:	82ab      	strh	r3, [r5, #20]

	win_offset = sys_le16_to_cpu(pdu_adv->connect_ind.win_offset);
    3b10:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    3b12:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
	conn_interval_us = interval * 1250U;

	/* calculate the window widening */
	conn->slave.sca = pdu_adv->connect_ind.sca;
    3b16:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    3b1a:	f896 20dc 	ldrb.w	r2, [r6, #220]	; 0xdc
    3b1e:	095b      	lsrs	r3, r3, #5
    3b20:	f363 0284 	bfi	r2, r3, #2, #3
    3b24:	f886 20dc 	strb.w	r2, [r6, #220]	; 0xdc
	lll->slave.window_widening_periodic_us =
		(((lll_conn_ppm_local_get() +
    3b28:	f020 ffdd 	bl	24ae6 <lll_conn_ppm_local_get>
    3b2c:	4681      	mov	r9, r0
		   lll_conn_ppm_get(conn->slave.sca)) *
    3b2e:	f896 00dc 	ldrb.w	r0, [r6, #220]	; 0xdc
    3b32:	f3c0 0082 	ubfx	r0, r0, #2, #3
    3b36:	f013 fa19 	bl	16f6c <lll_conn_ppm_get>
	conn_interval_us = interval * 1250U;
    3b3a:	f240 4be2 	movw	fp, #1250	; 0x4e2
    3b3e:	fb0b f707 	mul.w	r7, fp, r7
		(((lll_conn_ppm_local_get() +
    3b42:	4448      	add	r0, r9
		   lll_conn_ppm_get(conn->slave.sca)) *
    3b44:	4378      	muls	r0, r7
		  conn_interval_us) + (1000000 - 1)) / 1000000U;
    3b46:	f500 2074 	add.w	r0, r0, #999424	; 0xf4000
    3b4a:	4bb1      	ldr	r3, [pc, #708]	; (3e10 <ull_slave_setup+0x370>)
					      conn_interval_us);
	/* Dispatch LE Ping PDU 6 connection events (that peer would
	 * listen to) before 30s timeout
	 * TODO: "peer listens to" is greater than 30s due to latency
	 */
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    3b4c:	8aa9      	ldrh	r1, [r5, #20]
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    3b4e:	4ab1      	ldr	r2, [pc, #708]	; (3e14 <ull_slave_setup+0x374>)
		  conn_interval_us) + (1000000 - 1)) / 1000000U;
    3b50:	f200 203f 	addw	r0, r0, #575	; 0x23f
    3b54:	fbb0 f0f3 	udiv	r0, r0, r3
	lll->slave.window_widening_max_us = (conn_interval_us >> 1) -
    3b58:	087b      	lsrs	r3, r7, #1
    3b5a:	3b96      	subs	r3, #150	; 0x96
    3b5c:	62eb      	str	r3, [r5, #44]	; 0x2c
	lll->slave.window_size_event_us = pdu_adv->connect_ind.win_size * 1250U;
    3b5e:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
	lll->slave.window_widening_periodic_us =
    3b62:	62a8      	str	r0, [r5, #40]	; 0x28
	lll->slave.window_size_event_us = pdu_adv->connect_ind.win_size * 1250U;
    3b64:	fb0b f303 	mul.w	r3, fp, r3
    3b68:	63eb      	str	r3, [r5, #60]	; 0x3c
	timeout = sys_le16_to_cpu(pdu_adv->connect_ind.timeout);
    3b6a:	f8b4 b03c 	ldrh.w	fp, [r4, #60]	; 0x3c
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
    3b6e:	f242 7310 	movw	r3, #10000	; 0x2710
    3b72:	fb03 730b 	mla	r3, r3, fp, r7
    3b76:	3b01      	subs	r3, #1
    3b78:	fbb3 f3f7 	udiv	r3, r3, r7
    3b7c:	f8a6 30c6 	strh.w	r3, [r6, #198]	; 0xc6
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    3b80:	4ba5      	ldr	r3, [pc, #660]	; (3e18 <ull_slave_setup+0x378>)
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    3b82:	1d88      	adds	r0, r1, #6
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    3b84:	443b      	add	r3, r7
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    3b86:	443a      	add	r2, r7
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    3b88:	fbb3 f3f7 	udiv	r3, r3, r7
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    3b8c:	fbb2 f2f7 	udiv	r2, r2, r7
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    3b90:	f8a6 30ca 	strh.w	r3, [r6, #202]	; 0xca
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    3b94:	b293      	uxth	r3, r2
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    3b96:	4283      	cmp	r3, r0
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    3b98:	f8a6 30d2 	strh.w	r3, [r6, #210]	; 0xd2
			     (conn->apto_reload - (lll->latency + 6)) :
    3b9c:	bfc2      	ittt	gt
    3b9e:	1a5b      	subgt	r3, r3, r1
    3ba0:	3b06      	subgt	r3, #6
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    3ba2:	b29b      	uxthgt	r3, r3
    3ba4:	f8a6 30ce 	strh.w	r3, [r6, #206]	; 0xce
    3ba8:	68ab      	ldr	r3, [r5, #8]
    3baa:	f8c6 30e0 	str.w	r3, [r6, #224]	; 0xe0
#if defined(CONFIG_BT_CTLR_PRIVACY)
	u8_t own_addr_type = pdu_adv->rx_addr;
	u8_t own_addr[BDADDR_SIZE];
	u8_t rl_idx = ftr->rl_idx;

	memcpy(own_addr, &pdu_adv->connect_ind.adv_addr[0], BDADDR_SIZE);
    3bae:	4621      	mov	r1, r4
	u8_t own_addr_type = pdu_adv->rx_addr;
    3bb0:	f894 9020 	ldrb.w	r9, [r4, #32]
	memcpy(own_addr, &pdu_adv->connect_ind.adv_addr[0], BDADDR_SIZE);
    3bb4:	f851 0f28 	ldr.w	r0, [r1, #40]!
    3bb8:	9010      	str	r0, [sp, #64]	; 0x40
    3bba:	8889      	ldrh	r1, [r1, #4]
    3bbc:	f8ad 1044 	strh.w	r1, [sp, #68]	; 0x44
#endif

	peer_addr_type = pdu_adv->tx_addr;
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
    3bc0:	4621      	mov	r1, r4
	memcpy(own_addr, &pdu_adv->connect_ind.adv_addr[0], BDADDR_SIZE);
    3bc2:	4603      	mov	r3, r0
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
    3bc4:	f851 0f22 	ldr.w	r0, [r1, #34]!
	u8_t rl_idx = ftr->rl_idx;
    3bc8:	f898 c015 	ldrb.w	ip, [r8, #21]
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
    3bcc:	900e      	str	r0, [sp, #56]	; 0x38
	u8_t own_addr_type = pdu_adv->rx_addr;
    3bce:	f3c9 12c0 	ubfx	r2, r9, #7, #1
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
    3bd2:	8888      	ldrh	r0, [r1, #4]
    3bd4:	f8ad 003c 	strh.w	r0, [sp, #60]	; 0x3c
	peer_addr_type = pdu_adv->tx_addr;
    3bd8:	f3c9 1e80 	ubfx	lr, r9, #6, #1

	chan_sel = pdu_adv->chan_sel;
    3bdc:	f3c9 1940 	ubfx	r9, r9, #5, #1
    3be0:	fa5f f089 	uxtb.w	r0, r9
    3be4:	900a      	str	r0, [sp, #40]	; 0x28
    3be6:	6323      	str	r3, [r4, #48]	; 0x30

	cc = (void *)pdu_adv;
	cc->status = 0U;
    3be8:	f44f 7080 	mov.w	r0, #256	; 0x100
    3bec:	f8bd 3044 	ldrh.w	r3, [sp, #68]	; 0x44
    3bf0:	86a3      	strh	r3, [r4, #52]	; 0x34

#if defined(CONFIG_BT_CTLR_PRIVACY)
	cc->own_addr_type = own_addr_type;
	memcpy(&cc->own_addr[0], &own_addr[0], BDADDR_SIZE);

	if (rl_idx != FILTER_IDX_NONE) {
    3bf2:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
	cc->status = 0U;
    3bf6:	8420      	strh	r0, [r4, #32]
	cc->own_addr_type = own_addr_type;
    3bf8:	f884 202f 	strb.w	r2, [r4, #47]	; 0x2f
	if (rl_idx != FILTER_IDX_NONE) {
    3bfc:	f104 0329 	add.w	r3, r4, #41	; 0x29
    3c00:	f000 80ee 	beq.w	3de0 <ull_slave_setup+0x340>
		/* TODO: store rl_idx instead if safe */
		/* Store identity address */
		ll_rl_id_addr_get(rl_idx, &cc->peer_addr_type,
    3c04:	f104 0223 	add.w	r2, r4, #35	; 0x23
    3c08:	4660      	mov	r0, ip
    3c0a:	930d      	str	r3, [sp, #52]	; 0x34
    3c0c:	f013 fe86 	bl	1791c <ll_rl_id_addr_get>
				  &cc->peer_addr[0]);
		/* Mark it as identity address from RPA (0x02, 0x03) */
		cc->peer_addr_type += 2;
    3c10:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
    3c14:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    3c16:	980e      	ldr	r0, [sp, #56]	; 0x38
    3c18:	f8c4 0029 	str.w	r0, [r4, #41]	; 0x29
    3c1c:	3202      	adds	r2, #2
    3c1e:	f884 2022 	strb.w	r2, [r4, #34]	; 0x22
    3c22:	f8bd 203c 	ldrh.w	r2, [sp, #60]	; 0x3c
    3c26:	809a      	strh	r2, [r3, #4]
#endif /* CONFIG_BT_CTLR_PRIVACY */
		cc->peer_addr_type = peer_addr_type;
		memcpy(cc->peer_addr, peer_addr, BDADDR_SIZE);
	}

	cc->interval = lll->interval;
    3c28:	8a6b      	ldrh	r3, [r5, #18]
    3c2a:	86e3      	strh	r3, [r4, #54]	; 0x36
	cc->latency = lll->latency;
    3c2c:	8aab      	ldrh	r3, [r5, #20]
    3c2e:	8723      	strh	r3, [r4, #56]	; 0x38
	cc->timeout = timeout;
	cc->sca = conn->slave.sca;
    3c30:	f896 30dc 	ldrb.w	r3, [r6, #220]	; 0xdc
	cc->timeout = timeout;
    3c34:	f8a4 b03a 	strh.w	fp, [r4, #58]	; 0x3a
	cc->sca = conn->slave.sca;
    3c38:	f3c3 0382 	ubfx	r3, r3, #2, #3
    3c3c:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c

	lll->handle = ll_conn_handle_get(conn);
    3c40:	4630      	mov	r0, r6
    3c42:	f011 f8ed 	bl	14e20 <ll_conn_handle_get>
		struct node_rx_cs *cs;

		/* pick the rx node instance stored within the connection
		 * rx node.
		 */
		rx_csa = (void *)ftr->extra;
    3c46:	f8d8 3004 	ldr.w	r3, [r8, #4]
	lll->handle = ll_conn_handle_get(conn);
    3c4a:	8228      	strh	r0, [r5, #16]

		/* Enqueue the connection event */
		ll_rx_put(link, rx);
    3c4c:	4621      	mov	r1, r4
	rx->handle = lll->handle;
    3c4e:	80e0      	strh	r0, [r4, #6]
		ll_rx_put(link, rx);
    3c50:	980b      	ldr	r0, [sp, #44]	; 0x2c
		rx_csa = (void *)ftr->extra;
    3c52:	930d      	str	r3, [sp, #52]	; 0x34
		ll_rx_put(link, rx);
    3c54:	f00f f904 	bl	12e60 <ll_rx_put>

		/* use the rx node for CSA event */
		rx = (void *)rx_csa;
		link = rx->link;
    3c58:	9b0d      	ldr	r3, [sp, #52]	; 0x34

		rx->handle = lll->handle;
    3c5a:	8a2a      	ldrh	r2, [r5, #16]
    3c5c:	80da      	strh	r2, [r3, #6]
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
    3c5e:	220d      	movs	r2, #13
    3c60:	711a      	strb	r2, [r3, #4]

		cs = (void *)rx_csa->pdu;

		if (chan_sel) {
    3c62:	9a0a      	ldr	r2, [sp, #40]	; 0x28
		link = rx->link;
    3c64:	6818      	ldr	r0, [r3, #0]
		if (chan_sel) {
    3c66:	2a00      	cmp	r2, #0
    3c68:	f000 80c8 	beq.w	3dfc <ull_slave_setup+0x35c>
			u16_t aa_ls = ((u16_t)lll->access_addr[1] << 8) |
    3c6c:	7a69      	ldrb	r1, [r5, #9]
				      lll->access_addr[0];
    3c6e:	7a2a      	ldrb	r2, [r5, #8]
			u16_t aa_ms = ((u16_t)lll->access_addr[3] << 8) |
    3c70:	7aec      	ldrb	r4, [r5, #11]
			u16_t aa_ls = ((u16_t)lll->access_addr[1] << 8) |
    3c72:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
				      lll->access_addr[2];
    3c76:	7aa9      	ldrb	r1, [r5, #10]
			u16_t aa_ms = ((u16_t)lll->access_addr[3] << 8) |
    3c78:	ea41 2104 	orr.w	r1, r1, r4, lsl #8

			lll->data_chan_sel = 1;
    3c7c:	f895 4021 	ldrb.w	r4, [r5, #33]	; 0x21
			lll->data_chan_id = aa_ms ^ aa_ls;
    3c80:	404a      	eors	r2, r1
    3c82:	846a      	strh	r2, [r5, #34]	; 0x22
			lll->data_chan_sel = 1;
    3c84:	f044 0440 	orr.w	r4, r4, #64	; 0x40

			cs->csa = 0x01;
    3c88:	2201      	movs	r2, #1
			lll->data_chan_sel = 1;
    3c8a:	f885 4021 	strb.w	r4, [r5, #33]	; 0x21
			cs->csa = 0x01;
    3c8e:	f883 2020 	strb.w	r2, [r3, #32]
		} else {
			cs->csa = 0x00;
		}
	}

	ll_rx_put(link, rx);
    3c92:	4619      	mov	r1, r3
    3c94:	f00f f8e4 	bl	12e60 <ll_rx_put>
	ll_rx_sched();
    3c98:	f00f f8ec 	bl	12e74 <ll_rx_sched>
	conn->evt.ticks_xtal_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US);
	conn->evt.ticks_preempt_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_PREEMPT_MIN_US);
	conn->evt.ticks_slot =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    3c9c:	f8d8 b010 	ldr.w	fp, [r8, #16]
    3ca0:	f8df 9194 	ldr.w	r9, [pc, #404]	; 3e38 <ull_slave_setup+0x398>
	conn->evt.ticks_xtal_to_start =
    3ca4:	2400      	movs	r4, #0
    3ca6:	2331      	movs	r3, #49	; 0x31
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    3ca8:	f20b 4052 	addw	r0, fp, #1106	; 0x452
	conn->evt.ticks_xtal_to_start =
    3cac:	e9c6 3400 	strd	r3, r4, [r6]
	conn->evt.ticks_preempt_to_start =
    3cb0:	60b4      	str	r4, [r6, #8]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    3cb2:	a355      	add	r3, pc, #340	; (adr r3, 3e08 <ull_slave_setup+0x368>)
    3cb4:	e9d3 2300 	ldrd	r2, r3, [r3]
    3cb8:	fba0 0109 	umull	r0, r1, r0, r9
    3cbc:	f7fc fa60 	bl	180 <__aeabi_uldivmod>
		ticks_slot_overhead = ticks_slot_offset;
	} else {
		ticks_slot_overhead = 0U;
	}

	conn_interval_us -= lll->slave.window_widening_periodic_us;
    3cc0:	6aab      	ldr	r3, [r5, #40]	; 0x28

	conn_offset_us = ftr->us_radio_end;
	conn_offset_us += ((u64_t)win_offset + 1) * 1250U;
    3cc2:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
	conn_interval_us -= lll->slave.window_widening_periodic_us;
    3cc6:	1aff      	subs	r7, r7, r3
    3cc8:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3ccc:	f5a3 73ae 	sub.w	r3, r3, #348	; 0x15c
    3cd0:	eba3 030b 	sub.w	r3, r3, fp
	conn_offset_us += ((u64_t)win_offset + 1) * 1250U;
    3cd4:	f240 4be2 	movw	fp, #1250	; 0x4e2
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    3cd8:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	conn_offset_us += ((u64_t)win_offset + 1) * 1250U;
    3cdc:	fb0b bb02 	mla	fp, fp, r2, fp
	conn_offset_us -= EVENT_OVERHEAD_START_US;
	conn_offset_us -= EVENT_TICKER_RES_MARGIN_US;
	conn_offset_us -= EVENT_JITTER_US;
	conn_offset_us -= ftr->us_radio_rdy;
    3ce0:	445b      	add	r3, fp

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	/* disable ticker job, in order to chain stop and start to avoid RTC
	 * being stopped if no tickers active.
	 */
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    3ce2:	4622      	mov	r2, r4
    3ce4:	2102      	movs	r1, #2
	conn->evt.ticks_slot =
    3ce6:	60f0      	str	r0, [r6, #12]
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    3ce8:	2001      	movs	r0, #1
	conn_offset_us -= ftr->us_radio_rdy;
    3cea:	930a      	str	r3, [sp, #40]	; 0x28
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    3cec:	f00c fc7a 	bl	105e4 <mayfly_enable>
#endif

	/* Stop Advertiser */
	ticker_id_adv = TICKER_ID_ADV_BASE + ull_adv_handle_get(adv);
    3cf0:	4650      	mov	r0, sl
    3cf2:	f010 f99f 	bl	14034 <ull_adv_handle_get>
    3cf6:	1c82      	adds	r2, r0, #2
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
    3cf8:	4b48      	ldr	r3, [pc, #288]	; (3e1c <ull_slave_setup+0x37c>)
    3cfa:	f8cd a000 	str.w	sl, [sp]
    3cfe:	b2d2      	uxtb	r2, r2
    3d00:	2101      	movs	r1, #1
    3d02:	4620      	mov	r0, r4
    3d04:	f00d f9a6 	bl	11054 <ticker_stop>
				    TICKER_USER_ID_ULL_HIGH,
				    ticker_id_adv, ticker_op_stop_adv_cb, adv);
	ticker_op_stop_adv_cb(ticker_status, adv);
    3d08:	4651      	mov	r1, sl
    3d0a:	f013 fbe3 	bl	174d4 <ticker_op_stop_adv_cb>

	/* Stop Direct Adv Stop */
	if (adv->lll.is_hdcd) {
    3d0e:	f89a 3028 	ldrb.w	r3, [sl, #40]	; 0x28
    3d12:	07db      	lsls	r3, r3, #31
    3d14:	d506      	bpl.n	3d24 <ull_slave_setup+0x284>
		/* Advertiser stop can expire while here in this ISR.
		 * Deferred attempt to stop can fail as it would have
		 * expired, hence ignore failure.
		 */
		ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
    3d16:	2201      	movs	r2, #1
    3d18:	9400      	str	r4, [sp, #0]
    3d1a:	4623      	mov	r3, r4
    3d1c:	4611      	mov	r1, r2
    3d1e:	4620      	mov	r0, r4
    3d20:	f00d f998 	bl	11054 <ticker_stop>
			    TICKER_ID_ADV_STOP, NULL, NULL);
	}

	/* Start Slave */
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    3d24:	4630      	mov	r0, r6
    3d26:	f011 f87b 	bl	14e20 <ll_conn_handle_get>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
				     TICKER_USER_ID_ULL_HIGH,
				     ticker_id_conn,
				     ftr->ticks_anchor - ticks_slot_offset,
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
    3d2a:	fba7 4509 	umull	r4, r5, r7, r9
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    3d2e:	4682      	mov	sl, r0
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
    3d30:	a335      	add	r3, pc, #212	; (adr r3, 3e08 <ull_slave_setup+0x368>)
    3d32:	e9d3 2300 	ldrd	r2, r3, [r3]
    3d36:	4620      	mov	r0, r4
    3d38:	4629      	mov	r1, r5
    3d3a:	f7fc fa21 	bl	180 <__aeabi_uldivmod>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    3d3e:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3d42:	f1a3 0831 	sub.w	r8, r3, #49	; 0x31
    3d46:	f240 131d 	movw	r3, #285	; 0x11d
    3d4a:	9308      	str	r3, [sp, #32]
    3d4c:	4b34      	ldr	r3, [pc, #208]	; (3e20 <ull_slave_setup+0x380>)
    3d4e:	e9cd 6306 	strd	r6, r3, [sp, #24]
    3d52:	4b34      	ldr	r3, [pc, #208]	; (3e24 <ull_slave_setup+0x384>)
    3d54:	9305      	str	r3, [sp, #20]
    3d56:	68f3      	ldr	r3, [r6, #12]
    3d58:	9304      	str	r3, [sp, #16]
				     HAL_TICKER_REMAINDER(conn_interval_us),
    3d5a:	4b33      	ldr	r3, [pc, #204]	; (3e28 <ull_slave_setup+0x388>)
    3d5c:	f020 467f 	bic.w	r6, r0, #4278190080	; 0xff000000
    3d60:	fba6 bc03 	umull	fp, ip, r6, r3
    3d64:	2307      	movs	r3, #7
    3d66:	fb03 cc06 	mla	ip, r3, r6, ip
    3d6a:	ebb4 000b 	subs.w	r0, r4, fp
    3d6e:	eb65 010c 	sbc.w	r1, r5, ip
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    3d72:	f10a 0703 	add.w	r7, sl, #3
				     HAL_TICKER_REMAINDER(conn_interval_us),
    3d76:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    3d7a:	f04f 0a00 	mov.w	sl, #0
				     HAL_TICKER_REMAINDER(conn_interval_us),
    3d7e:	2300      	movs	r3, #0
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    3d80:	f8cd a00c 	str.w	sl, [sp, #12]
				     HAL_TICKER_REMAINDER(conn_interval_us),
    3d84:	f7fc f9fc 	bl	180 <__aeabi_uldivmod>
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
    3d88:	990a      	ldr	r1, [sp, #40]	; 0x28
    3d8a:	a31f      	add	r3, pc, #124	; (adr r3, 3e08 <ull_slave_setup+0x368>)
    3d8c:	e9d3 2300 	ldrd	r2, r3, [r3]
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    3d90:	e9cd 6001 	strd	r6, r0, [sp, #4]
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
    3d94:	fba1 0109 	umull	r0, r1, r1, r9
    3d98:	f7fc f9f2 	bl	180 <__aeabi_uldivmod>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    3d9c:	b2ff      	uxtb	r7, r7
    3d9e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    3da2:	9000      	str	r0, [sp, #0]
    3da4:	4643      	mov	r3, r8
    3da6:	463a      	mov	r2, r7
    3da8:	2101      	movs	r1, #1
    3daa:	4650      	mov	r0, sl
    3dac:	f00d f8c0 	bl	10f30 <ticker_start>
#endif /* CONFIG_BT_CTLR_CONN_META */
				     (conn->evt.ticks_slot +
				      ticks_slot_overhead),
				     ull_slave_ticker_cb, conn, ticker_op_cb,
				     (void *)__LINE__);
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    3db0:	f030 0302 	bics.w	r3, r0, #2
    3db4:	d00c      	beq.n	3dd0 <ull_slave_setup+0x330>
    3db6:	f240 131f 	movw	r3, #287	; 0x11f
    3dba:	4a1c      	ldr	r2, [pc, #112]	; (3e2c <ull_slave_setup+0x38c>)
    3dbc:	491c      	ldr	r1, [pc, #112]	; (3e30 <ull_slave_setup+0x390>)
    3dbe:	481d      	ldr	r0, [pc, #116]	; (3e34 <ull_slave_setup+0x394>)
    3dc0:	f01b fff7 	bl	1fdb2 <printk>
    3dc4:	4040      	eors	r0, r0
    3dc6:	f380 8811 	msr	BASEPRI, r0
    3dca:	f04f 0003 	mov.w	r0, #3
    3dce:	df02      	svc	2

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	/* enable ticker job, irrespective of disabled in this function so
	 * first connection event can be scheduled as soon as possible.
	 */
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1);
    3dd0:	2201      	movs	r2, #1
    3dd2:	2102      	movs	r1, #2
    3dd4:	4610      	mov	r0, r2
#endif
}
    3dd6:	b013      	add	sp, #76	; 0x4c
    3dd8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1);
    3ddc:	f00c bc02 	b.w	105e4 <mayfly_enable>
__ssp_bos_icheck3(memset, void *, int)
    3de0:	2200      	movs	r2, #0
    3de2:	f8c4 2029 	str.w	r2, [r4, #41]	; 0x29
    3de6:	980e      	ldr	r0, [sp, #56]	; 0x38
    3de8:	809a      	strh	r2, [r3, #4]
		cc->peer_addr_type = peer_addr_type;
    3dea:	f8bd 303c 	ldrh.w	r3, [sp, #60]	; 0x3c
    3dee:	f884 e022 	strb.w	lr, [r4, #34]	; 0x22
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    3df2:	f8c4 0023 	str.w	r0, [r4, #35]	; 0x23
    3df6:	f8a4 3027 	strh.w	r3, [r4, #39]	; 0x27
    3dfa:	e715      	b.n	3c28 <ull_slave_setup+0x188>
			cs->csa = 0x00;
    3dfc:	f883 9020 	strb.w	r9, [r3, #32]
    3e00:	e747      	b.n	3c92 <ull_slave_setup+0x1f2>
    3e02:	bf00      	nop
    3e04:	f3af 8000 	nop.w
    3e08:	1afd498d 	.word	0x1afd498d
    3e0c:	00000007 	.word	0x00000007
    3e10:	000f4240 	.word	0x000f4240
    3e14:	01c9c37f 	.word	0x01c9c37f
    3e18:	026259ff 	.word	0x026259ff
    3e1c:	000174d5 	.word	0x000174d5
    3e20:	000174a9 	.word	0x000174a9
    3e24:	0001750d 	.word	0x0001750d
    3e28:	1afd498d 	.word	0x1afd498d
    3e2c:	000649ac 	.word	0x000649ac
    3e30:	000646b3 	.word	0x000646b3
    3e34:	000632fe 	.word	0x000632fe
    3e38:	3b9aca00 	.word	0x3b9aca00
    3e3c:	00000000 	.word	0x00000000

00003e40 <ull_slave_done>:
 * @param ticks_drift_plus[out]  Positive part of drift uncertainty window
 * @param ticks_drift_minus[out] Negative part of drift uncertainty window
 */
void ull_slave_done(struct node_rx_event_done *done, u32_t *ticks_drift_plus,
		    u32_t *ticks_drift_minus)
{
    3e40:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    3e44:	4689      	mov	r9, r1
	u32_t window_widening_event_us;
	u32_t preamble_to_addr_us;

	start_to_address_actual_us =
		done->extra.slave.start_to_address_actual_us;
	window_widening_event_us =
    3e46:	e9d0 710b 	ldrd	r7, r1, [r0, #44]	; 0x2c
		done->extra.slave.window_widening_event_us;
	preamble_to_addr_us =
    3e4a:	6b46      	ldr	r6, [r0, #52]	; 0x34
		done->extra.slave.preamble_to_addr_us;

	start_to_address_expected_us = EVENT_JITTER_US +
    3e4c:	4d16      	ldr	r5, [pc, #88]	; (3ea8 <ull_slave_done+0x68>)
				       EVENT_TICKER_RES_MARGIN_US +
				       window_widening_event_us +
    3e4e:	198c      	adds	r4, r1, r6
	start_to_address_expected_us = EVENT_JITTER_US +
    3e50:	3430      	adds	r4, #48	; 0x30
				       preamble_to_addr_us;

	if (start_to_address_actual_us <= start_to_address_expected_us) {
    3e52:	42a7      	cmp	r7, r4
{
    3e54:	4690      	mov	r8, r2
		*ticks_drift_plus =
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
    3e56:	a312      	add	r3, pc, #72	; (adr r3, 3ea0 <ull_slave_done+0x60>)
    3e58:	e9d3 2300 	ldrd	r2, r3, [r3]
	if (start_to_address_actual_us <= start_to_address_expected_us) {
    3e5c:	d815      	bhi.n	3e8a <ull_slave_done+0x4a>
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
    3e5e:	fba1 0105 	umull	r0, r1, r1, r5
    3e62:	f7fc f98d 	bl	180 <__aeabi_uldivmod>
    3e66:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_plus =
    3e6a:	f8c9 0000 	str.w	r0, [r9]
		*ticks_drift_minus =
			HAL_TICKER_US_TO_TICKS((start_to_address_expected_us -
    3e6e:	1be0      	subs	r0, r4, r7
					       start_to_address_actual_us));
	} else {
		*ticks_drift_plus =
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
		*ticks_drift_minus =
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
    3e70:	a30b      	add	r3, pc, #44	; (adr r3, 3ea0 <ull_slave_done+0x60>)
    3e72:	e9d3 2300 	ldrd	r2, r3, [r3]
    3e76:	fba0 0105 	umull	r0, r1, r0, r5
    3e7a:	f7fc f981 	bl	180 <__aeabi_uldivmod>
    3e7e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_minus =
    3e82:	f8c8 0000 	str.w	r0, [r8]
					       EVENT_TICKER_RES_MARGIN_US +
					       preamble_to_addr_us);
	}
}
    3e86:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
    3e8a:	fba7 0105 	umull	r0, r1, r7, r5
    3e8e:	f7fc f977 	bl	180 <__aeabi_uldivmod>
    3e92:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_plus =
    3e96:	f8c9 0000 	str.w	r0, [r9]
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
    3e9a:	f106 0030 	add.w	r0, r6, #48	; 0x30
    3e9e:	e7e7      	b.n	3e70 <ull_slave_done+0x30>
    3ea0:	1afd498d 	.word	0x1afd498d
    3ea4:	00000007 	.word	0x00000007
    3ea8:	3b9aca00 	.word	0x3b9aca00
    3eac:	00000000 	.word	0x00000000

00003eb0 <erase_op>:
}

#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

static int erase_op(void *context)
{
    3eb0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3eb4:	4604      	mov	r4, r0
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
    3eb6:	f021 fa1e 	bl	252f6 <nrfx_nvmc_flash_page_size_get>
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
	u32_t ticks_begin = 0U;
	u32_t ticks_diff;
	u32_t i = 0U;

	if (e_ctx->enable_time_limit) {
    3eba:	7b25      	ldrb	r5, [r4, #12]
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
    3ebc:	4682      	mov	sl, r0
	if (e_ctx->enable_time_limit) {
    3ebe:	b115      	cbz	r5, 3ec6 <erase_op+0x16>
		ticks_begin = ticker_ticks_now_get();
    3ec0:	f020 fa22 	bl	24308 <ticker_ticks_now_get>
    3ec4:	4605      	mov	r5, r0
		if (e_ctx->enable_time_limit) {
			ticks_diff =
				ticker_ticks_diff_get(ticker_ticks_now_get(),
						      ticks_begin);
			if (ticks_diff + ticks_diff/i >
			    HAL_TICKER_US_TO_TICKS(e_ctx->slot)) {
    3ec6:	f20f 0968 	addw	r9, pc, #104	; 0x68
    3eca:	e9d9 8900 	ldrd	r8, r9, [r9]
    3ece:	f8df b068 	ldr.w	fp, [pc, #104]	; 3f38 <erase_op+0x88>
	u32_t ticks_begin = 0U;
    3ed2:	2700      	movs	r7, #0
		(void)nrfx_nvmc_page_erase(e_ctx->flash_addr);
    3ed4:	6860      	ldr	r0, [r4, #4]
    3ed6:	f016 f965 	bl	1a1a4 <nrfx_nvmc_page_erase>
		e_ctx->len -= pg_size;
    3eda:	68a3      	ldr	r3, [r4, #8]
    3edc:	eba3 030a 	sub.w	r3, r3, sl
    3ee0:	60a3      	str	r3, [r4, #8]
		e_ctx->flash_addr += pg_size;
    3ee2:	6863      	ldr	r3, [r4, #4]
    3ee4:	4453      	add	r3, sl
    3ee6:	6063      	str	r3, [r4, #4]
		if (e_ctx->enable_time_limit) {
    3ee8:	7b23      	ldrb	r3, [r4, #12]
		i++;
    3eea:	3701      	adds	r7, #1
		if (e_ctx->enable_time_limit) {
    3eec:	b94b      	cbnz	r3, 3f02 <erase_op+0x52>
				break;
			}
		}
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

	} while (e_ctx->len > 0);
    3eee:	68a3      	ldr	r3, [r4, #8]
    3ef0:	2b00      	cmp	r3, #0
    3ef2:	d1ef      	bne.n	3ed4 <erase_op+0x24>

	return (e_ctx->len > 0) ? FLASH_OP_ONGOING : FLASH_OP_DONE;
    3ef4:	68a0      	ldr	r0, [r4, #8]
    3ef6:	3000      	adds	r0, #0
    3ef8:	bf18      	it	ne
    3efa:	2001      	movne	r0, #1
}
    3efc:	4240      	negs	r0, r0
    3efe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				ticker_ticks_diff_get(ticker_ticks_now_get(),
    3f02:	f020 fa01 	bl	24308 <ticker_ticks_now_get>
    3f06:	4629      	mov	r1, r5
    3f08:	f020 fa00 	bl	2430c <ticker_ticks_diff_get>
			if (ticks_diff + ticks_diff/i >
    3f0c:	fbb0 f6f7 	udiv	r6, r0, r7
    3f10:	4406      	add	r6, r0
			    HAL_TICKER_US_TO_TICKS(e_ctx->slot)) {
    3f12:	6960      	ldr	r0, [r4, #20]
    3f14:	4642      	mov	r2, r8
    3f16:	464b      	mov	r3, r9
    3f18:	fba0 010b 	umull	r0, r1, r0, fp
    3f1c:	f7fc f930 	bl	180 <__aeabi_uldivmod>
    3f20:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			if (ticks_diff + ticks_diff/i >
    3f24:	4286      	cmp	r6, r0
    3f26:	d9e2      	bls.n	3eee <erase_op+0x3e>
    3f28:	e7e4      	b.n	3ef4 <erase_op+0x44>
    3f2a:	bf00      	nop
    3f2c:	f3af 8000 	nop.w
    3f30:	1afd498d 	.word	0x1afd498d
    3f34:	00000007 	.word	0x00000007
    3f38:	3b9aca00 	.word	0x3b9aca00
    3f3c:	00000000 	.word	0x00000000

00003f40 <work_in_time_slice>:
{
    3f40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3f44:	b08f      	sub	sp, #60	; 0x3c
	struct flash_context *context = p_flash_op_desc->context;
    3f46:	f8d0 a004 	ldr.w	sl, [r0, #4]
			   HAL_TICKER_US_TO_TICKS(context->interval),
    3f4a:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 4024 <CONFIG_HEAP_MEM_POOL_SIZE+0x24>
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
    3f4e:	f10d 0137 	add.w	r1, sp, #55	; 0x37
{
    3f52:	4680      	mov	r8, r0
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
    3f54:	f10d 0036 	add.w	r0, sp, #54	; 0x36
    3f58:	f020 fa7e 	bl	24458 <ll_timeslice_ticker_id_get>
	err = ticker_start(instance_index,
    3f5c:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
    3f60:	930a      	str	r3, [sp, #40]	; 0x28
    3f62:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
    3f66:	930b      	str	r3, [sp, #44]	; 0x2c
    3f68:	f020 f9ce 	bl	24308 <ticker_ticks_now_get>
			   HAL_TICKER_US_TO_TICKS(context->interval),
    3f6c:	f8da 4010 	ldr.w	r4, [sl, #16]
    3f70:	fba4 4509 	umull	r4, r5, r4, r9
    3f74:	a326      	add	r3, pc, #152	; (adr r3, 4010 <CONFIG_HEAP_MEM_POOL_SIZE+0x10>)
    3f76:	e9d3 2300 	ldrd	r2, r3, [r3]
	err = ticker_start(instance_index,
    3f7a:	2700      	movs	r7, #0
    3f7c:	4683      	mov	fp, r0
			   HAL_TICKER_US_TO_TICKS(context->interval),
    3f7e:	4629      	mov	r1, r5
    3f80:	4620      	mov	r0, r4
    3f82:	f7fc f8fd 	bl	180 <__aeabi_uldivmod>
	err = ticker_start(instance_index,
    3f86:	e9cd 7707 	strd	r7, r7, [sp, #28]
    3f8a:	4b23      	ldr	r3, [pc, #140]	; (4018 <CONFIG_HEAP_MEM_POOL_SIZE+0x18>)
    3f8c:	9305      	str	r3, [sp, #20]
    3f8e:	f8cd 8018 	str.w	r8, [sp, #24]
			   HAL_TICKER_US_TO_TICKS(context->interval),
    3f92:	4606      	mov	r6, r0
			   HAL_TICKER_US_TO_TICKS(context->slot),
    3f94:	f8da 0014 	ldr.w	r0, [sl, #20]
    3f98:	a31d      	add	r3, pc, #116	; (adr r3, 4010 <CONFIG_HEAP_MEM_POOL_SIZE+0x10>)
    3f9a:	e9d3 2300 	ldrd	r2, r3, [r3]
    3f9e:	fba0 0109 	umull	r0, r1, r0, r9
    3fa2:	f7fc f8ed 	bl	180 <__aeabi_uldivmod>
			   HAL_TICKER_REMAINDER(context->interval),
    3fa6:	4b1d      	ldr	r3, [pc, #116]	; (401c <CONFIG_HEAP_MEM_POOL_SIZE+0x1c>)
    3fa8:	f026 467f 	bic.w	r6, r6, #4278190080	; 0xff000000
    3fac:	fba6 9a03 	umull	r9, sl, r6, r3
	err = ticker_start(instance_index,
    3fb0:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			   HAL_TICKER_REMAINDER(context->interval),
    3fb4:	2307      	movs	r3, #7
	err = ticker_start(instance_index,
    3fb6:	e9cd 7003 	strd	r7, r0, [sp, #12]
			   HAL_TICKER_REMAINDER(context->interval),
    3fba:	fb03 aa06 	mla	sl, r3, r6, sl
    3fbe:	ebb4 0009 	subs.w	r0, r4, r9
    3fc2:	eb65 010a 	sbc.w	r1, r5, sl
    3fc6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    3fca:	2300      	movs	r3, #0
    3fcc:	f7fc f8d8 	bl	180 <__aeabi_uldivmod>
	err = ticker_start(instance_index,
    3fd0:	465b      	mov	r3, fp
    3fd2:	e9cd 6001 	strd	r6, r0, [sp, #4]
    3fd6:	9700      	str	r7, [sp, #0]
    3fd8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    3fda:	980a      	ldr	r0, [sp, #40]	; 0x28
    3fdc:	2103      	movs	r1, #3
    3fde:	f00c ffa7 	bl	10f30 <ticker_start>
	if (err != TICKER_STATUS_SUCCESS && err != TICKER_STATUS_BUSY) {
    3fe2:	f030 0302 	bics.w	r3, r0, #2
    3fe6:	d10a      	bne.n	3ffe <work_in_time_slice+0xbe>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&sem, *(uintptr_t *)&timeout, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
    3fe8:	f645 11b3 	movw	r1, #22963	; 0x59b3
    3fec:	480c      	ldr	r0, [pc, #48]	; (4020 <CONFIG_HEAP_MEM_POOL_SIZE+0x20>)
    3fee:	f01a fef1 	bl	1edd4 <z_impl_k_sem_take>
	} else if (k_sem_take(&sem_sync, K_MSEC(FLASH_TIMEOUT_MS)) != 0) {
    3ff2:	b938      	cbnz	r0, 4004 <CONFIG_HEAP_MEM_POOL_SIZE+0x4>
		result = p_flash_op_desc->result;
    3ff4:	f8d8 0008 	ldr.w	r0, [r8, #8]
}
    3ff8:	b00f      	add	sp, #60	; 0x3c
    3ffa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		result = -ECANCELED;
    3ffe:	f06f 008b 	mvn.w	r0, #139	; 0x8b
    4002:	e7f9      	b.n	3ff8 <work_in_time_slice+0xb8>
		result = -ETIMEDOUT;
    4004:	f06f 0073 	mvn.w	r0, #115	; 0x73
	return result;
    4008:	e7f6      	b.n	3ff8 <work_in_time_slice+0xb8>
    400a:	bf00      	nop
    400c:	f3af 8000 	nop.w
    4010:	1afd498d 	.word	0x1afd498d
    4014:	00000007 	.word	0x00000007
    4018:	000199f1 	.word	0x000199f1
    401c:	1afd498d 	.word	0x1afd498d
    4020:	200019bc 	.word	0x200019bc
    4024:	3b9aca00 	.word	0x3b9aca00

00004028 <write_op>:
	w_ctx->data_addr += shift;
	w_ctx->len -= shift;
}

static int write_op(void *context)
{
    4028:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
	u32_t ticks_begin = 0U;
	u32_t ticks_diff;
	u32_t i = 1U;

	if (w_ctx->enable_time_limit) {
    402c:	7b06      	ldrb	r6, [r0, #12]
{
    402e:	4604      	mov	r4, r0
	if (w_ctx->enable_time_limit) {
    4030:	b116      	cbz	r6, 4038 <write_op+0x10>
		ticks_begin = ticker_ticks_now_get();
    4032:	f020 f969 	bl	24308 <ticker_ticks_now_get>
    4036:	4606      	mov	r6, r0
	}
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

	/* If not aligned, write unaligned beginning */
	if (!is_aligned_32(w_ctx->flash_addr)) {
    4038:	6860      	ldr	r0, [r4, #4]
    403a:	f010 0503 	ands.w	r5, r0, #3
    403e:	d067      	beq.n	4110 <write_op+0xe8>
		count = sizeof(u32_t) - (w_ctx->flash_addr & 0x3);
    4040:	68a3      	ldr	r3, [r4, #8]
		if (count > w_ctx->len) {
			count = w_ctx->len;
		}

		nrfx_nvmc_bytes_write(w_ctx->flash_addr,
    4042:	6821      	ldr	r1, [r4, #0]
		count = sizeof(u32_t) - (w_ctx->flash_addr & 0x3);
    4044:	f1c5 0504 	rsb	r5, r5, #4
		if (count > w_ctx->len) {
    4048:	429d      	cmp	r5, r3
    404a:	bf28      	it	cs
    404c:	461d      	movcs	r5, r3
		nrfx_nvmc_bytes_write(w_ctx->flash_addr,
    404e:	462a      	mov	r2, r5
    4050:	f016 f904 	bl	1a25c <nrfx_nvmc_bytes_write>
	w_ctx->flash_addr += shift;
    4054:	6863      	ldr	r3, [r4, #4]
    4056:	442b      	add	r3, r5
    4058:	6063      	str	r3, [r4, #4]
	w_ctx->data_addr += shift;
    405a:	6823      	ldr	r3, [r4, #0]
    405c:	442b      	add	r3, r5
    405e:	6023      	str	r3, [r4, #0]
	w_ctx->len -= shift;
    4060:	68a3      	ldr	r3, [r4, #8]
    4062:	1b5d      	subs	r5, r3, r5
				      count);

		shift_write_context(count, w_ctx);

#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
		if (w_ctx->enable_time_limit) {
    4064:	7b23      	ldrb	r3, [r4, #12]
	w_ctx->len -= shift;
    4066:	60a5      	str	r5, [r4, #8]
		if (w_ctx->enable_time_limit) {
    4068:	2b00      	cmp	r3, #0
    406a:	d051      	beq.n	4110 <write_op+0xe8>
			ticks_diff =
				ticker_ticks_diff_get(ticker_ticks_now_get(),
    406c:	f020 f94c 	bl	24308 <ticker_ticks_now_get>
    4070:	4631      	mov	r1, r6
    4072:	f020 f94b 	bl	2430c <ticker_ticks_diff_get>
						      ticks_begin);
			if (ticks_diff * 2U >
			    HAL_TICKER_US_TO_TICKS(w_ctx->slot)) {
    4076:	492c      	ldr	r1, [pc, #176]	; (4128 <write_op+0x100>)
			if (ticks_diff * 2U >
    4078:	0045      	lsls	r5, r0, #1
			    HAL_TICKER_US_TO_TICKS(w_ctx->slot)) {
    407a:	6960      	ldr	r0, [r4, #20]
    407c:	a328      	add	r3, pc, #160	; (adr r3, 4120 <write_op+0xf8>)
    407e:	e9d3 2300 	ldrd	r2, r3, [r3]
    4082:	fba0 0101 	umull	r0, r1, r0, r1
    4086:	f7fc f87b 	bl	180 <__aeabi_uldivmod>
    408a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			if (ticks_diff * 2U >
    408e:	4285      	cmp	r5, r0
    4090:	d93e      	bls.n	4110 <write_op+0xe8>
				nvmc_wait_ready();
    4092:	f015 fc9d 	bl	199d0 <nvmc_wait_ready>
				return FLASH_OP_ONGOING;
    4096:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}

	nvmc_wait_ready();

	return FLASH_OP_DONE;
}
    409a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				     UNALIGNED_GET((u32_t *)w_ctx->data_addr));
    409e:	6823      	ldr	r3, [r4, #0]
		nrfx_nvmc_word_write(w_ctx->flash_addr,
    40a0:	6860      	ldr	r0, [r4, #4]
    40a2:	6819      	ldr	r1, [r3, #0]
    40a4:	f016 f8b0 	bl	1a208 <nrfx_nvmc_word_write>
	w_ctx->flash_addr += shift;
    40a8:	6863      	ldr	r3, [r4, #4]
    40aa:	3304      	adds	r3, #4
    40ac:	6063      	str	r3, [r4, #4]
	w_ctx->data_addr += shift;
    40ae:	6823      	ldr	r3, [r4, #0]
    40b0:	3304      	adds	r3, #4
    40b2:	6023      	str	r3, [r4, #0]
	w_ctx->len -= shift;
    40b4:	68a3      	ldr	r3, [r4, #8]
    40b6:	3b04      	subs	r3, #4
    40b8:	60a3      	str	r3, [r4, #8]
		if (w_ctx->enable_time_limit) {
    40ba:	7b23      	ldrb	r3, [r4, #12]
		i++;
    40bc:	3501      	adds	r5, #1
		if (w_ctx->enable_time_limit) {
    40be:	b193      	cbz	r3, 40e6 <write_op+0xbe>
				ticker_ticks_diff_get(ticker_ticks_now_get(),
    40c0:	f020 f922 	bl	24308 <ticker_ticks_now_get>
    40c4:	4631      	mov	r1, r6
    40c6:	f020 f921 	bl	2430c <ticker_ticks_diff_get>
			if (ticks_diff + ticks_diff/i >
    40ca:	fbb0 f7f5 	udiv	r7, r0, r5
    40ce:	4407      	add	r7, r0
			    HAL_TICKER_US_TO_TICKS(w_ctx->slot)) {
    40d0:	6960      	ldr	r0, [r4, #20]
    40d2:	4642      	mov	r2, r8
    40d4:	464b      	mov	r3, r9
    40d6:	fba0 010a 	umull	r0, r1, r0, sl
    40da:	f7fc f851 	bl	180 <__aeabi_uldivmod>
    40de:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			if (ticks_diff + ticks_diff/i >
    40e2:	4287      	cmp	r7, r0
    40e4:	d8d5      	bhi.n	4092 <write_op+0x6a>
	while (w_ctx->len >= sizeof(u32_t)) {
    40e6:	68a2      	ldr	r2, [r4, #8]
    40e8:	2a03      	cmp	r2, #3
    40ea:	d8d8      	bhi.n	409e <write_op+0x76>
	if (w_ctx->len) {
    40ec:	b162      	cbz	r2, 4108 <write_op+0xe0>
		nrfx_nvmc_bytes_write(w_ctx->flash_addr,
    40ee:	e9d4 1000 	ldrd	r1, r0, [r4]
    40f2:	f016 f8b3 	bl	1a25c <nrfx_nvmc_bytes_write>
	w_ctx->flash_addr += shift;
    40f6:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
	w_ctx->data_addr += shift;
    40fa:	6823      	ldr	r3, [r4, #0]
    40fc:	440b      	add	r3, r1
	w_ctx->flash_addr += shift;
    40fe:	440a      	add	r2, r1
	w_ctx->data_addr += shift;
    4100:	6023      	str	r3, [r4, #0]
	w_ctx->len -= shift;
    4102:	2300      	movs	r3, #0
	w_ctx->flash_addr += shift;
    4104:	6062      	str	r2, [r4, #4]
	w_ctx->len -= shift;
    4106:	60a3      	str	r3, [r4, #8]
	nvmc_wait_ready();
    4108:	f015 fc62 	bl	199d0 <nvmc_wait_ready>
	return FLASH_OP_DONE;
    410c:	2000      	movs	r0, #0
    410e:	e7c4      	b.n	409a <write_op+0x72>
	u32_t ticks_begin = 0U;
    4110:	2501      	movs	r5, #1
			    HAL_TICKER_US_TO_TICKS(w_ctx->slot)) {
    4112:	f8df a014 	ldr.w	sl, [pc, #20]	; 4128 <write_op+0x100>
    4116:	f20f 0908 	addw	r9, pc, #8
    411a:	e9d9 8900 	ldrd	r8, r9, [r9]
    411e:	e7e2      	b.n	40e6 <write_op+0xbe>
    4120:	1afd498d 	.word	0x1afd498d
    4124:	00000007 	.word	0x00000007
    4128:	3b9aca00 	.word	0x3b9aca00

0000412c <vnd_ccc_cfg_changed>:
static u8_t indicating;
static struct bt_gatt_indicate_params ind_params;

static void vnd_ccc_cfg_changed(const struct bt_gatt_attr *attr, u16_t value)
{
	simulate_vnd = (value == BT_GATT_CCC_INDICATE) ? 1 : 0;
    412c:	1e8b      	subs	r3, r1, #2
    412e:	4259      	negs	r1, r3
    4130:	4159      	adcs	r1, r3
    4132:	4b01      	ldr	r3, [pc, #4]	; (4138 <vnd_ccc_cfg_changed+0xc>)
    4134:	7019      	strb	r1, [r3, #0]
}
    4136:	4770      	bx	lr
    4138:	20006147 	.word	0x20006147

0000413c <disconnected>:
		bt_connection_status = BT_STATUS_CONNECTED;
	}
}

static void disconnected(struct bt_conn *conn, u8_t reason)
{
    413c:	b508      	push	{r3, lr}
	LOG_INF("BT Disconnected (reason 0x%02x).", reason);
    413e:	f04f 0200 	mov.w	r2, #0
    4142:	2303      	movs	r3, #3
    4144:	f363 0207 	bfi	r2, r3, #0, #8
    4148:	4806      	ldr	r0, [pc, #24]	; (4164 <disconnected+0x28>)
    414a:	4b07      	ldr	r3, [pc, #28]	; (4168 <disconnected+0x2c>)
    414c:	1a1b      	subs	r3, r3, r0
    414e:	08db      	lsrs	r3, r3, #3
    4150:	f363 128f 	bfi	r2, r3, #6, #10
    4154:	4805      	ldr	r0, [pc, #20]	; (416c <disconnected+0x30>)
    4156:	f01c ff7d 	bl	21054 <log_1>
	bt_connection_status = BT_STATUS_DISCONNECTED;
    415a:	4b05      	ldr	r3, [pc, #20]	; (4170 <disconnected+0x34>)
    415c:	2200      	movs	r2, #0
    415e:	701a      	strb	r2, [r3, #0]
}
    4160:	bd08      	pop	{r3, pc}
    4162:	bf00      	nop
    4164:	00028540 	.word	0x00028540
    4168:	00028540 	.word	0x00028540
    416c:	000299d3 	.word	0x000299d3
    4170:	20006146 	.word	0x20006146

00004174 <connected>:
{
    4174:	b508      	push	{r3, lr}
    4176:	4a10      	ldr	r2, [pc, #64]	; (41b8 <connected+0x44>)
    4178:	4b10      	ldr	r3, [pc, #64]	; (41bc <connected+0x48>)
    417a:	1a9b      	subs	r3, r3, r2
    417c:	f3c3 03c9 	ubfx	r3, r3, #3, #10
	if (err) {
    4180:	b159      	cbz	r1, 419a <connected+0x26>
		LOG_WRN("BT Connection failed (err 0x%02x).", err);
    4182:	2002      	movs	r0, #2
    4184:	f04f 0200 	mov.w	r2, #0
    4188:	f360 0207 	bfi	r2, r0, #0, #8
    418c:	f363 128f 	bfi	r2, r3, #6, #10
    4190:	480b      	ldr	r0, [pc, #44]	; (41c0 <connected+0x4c>)
}
    4192:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		LOG_WRN("BT Connection failed (err 0x%02x).", err);
    4196:	f01c bf5d 	b.w	21054 <log_1>
		LOG_INF("BT Connected.");
    419a:	2203      	movs	r2, #3
    419c:	f04f 0100 	mov.w	r1, #0
    41a0:	f362 0107 	bfi	r1, r2, #0, #8
    41a4:	f363 118f 	bfi	r1, r3, #6, #10
    41a8:	4806      	ldr	r0, [pc, #24]	; (41c4 <connected+0x50>)
    41aa:	f01c ff46 	bl	2103a <log_0>
		bt_connection_status = BT_STATUS_CONNECTED;
    41ae:	4b06      	ldr	r3, [pc, #24]	; (41c8 <connected+0x54>)
    41b0:	2202      	movs	r2, #2
    41b2:	701a      	strb	r2, [r3, #0]
}
    41b4:	bd08      	pop	{r3, pc}
    41b6:	bf00      	nop
    41b8:	00028540 	.word	0x00028540
    41bc:	00028540 	.word	0x00028540
    41c0:	000299a2 	.word	0x000299a2
    41c4:	000299c5 	.word	0x000299c5
    41c8:	20006146 	.word	0x20006146

000041cc <bt_addr_le_to_str.constprop.1>:
 *  @param len Length of data to be copied to user string buffer. Refer to
 *  BT_ADDR_LE_STR_LEN about recommended value.
 *
 *  @return Number of successfully formatted bytes from binary address.
 */
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
    41cc:	b570      	push	{r4, r5, r6, lr}
				    size_t len)
{
	char type[10];

	switch (addr->type) {
    41ce:	7803      	ldrb	r3, [r0, #0]
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
    41d0:	b08a      	sub	sp, #40	; 0x28
    41d2:	4604      	mov	r4, r0
    41d4:	460e      	mov	r6, r1
    41d6:	ad07      	add	r5, sp, #28
	switch (addr->type) {
    41d8:	2b03      	cmp	r3, #3
    41da:	d820      	bhi.n	421e <bt_addr_le_to_str.constprop.1+0x52>
    41dc:	e8df f003 	tbb	[pc, r3]
    41e0:	1d1b1902 	.word	0x1d1b1902
	case BT_ADDR_LE_PUBLIC:
		strcpy(type, "public");
    41e4:	4911      	ldr	r1, [pc, #68]	; (422c <bt_addr_le_to_str.constprop.1+0x60>)
		break;
	case BT_ADDR_LE_RANDOM:
		strcpy(type, "random");
    41e6:	4628      	mov	r0, r5
    41e8:	f7fd fd56 	bl	1c98 <strcpy>
	default:
		snprintk(type, sizeof(type), "0x%02x", addr->type);
		break;
	}

	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
    41ec:	7863      	ldrb	r3, [r4, #1]
    41ee:	9304      	str	r3, [sp, #16]
    41f0:	78a3      	ldrb	r3, [r4, #2]
    41f2:	9303      	str	r3, [sp, #12]
    41f4:	78e3      	ldrb	r3, [r4, #3]
    41f6:	9302      	str	r3, [sp, #8]
    41f8:	7923      	ldrb	r3, [r4, #4]
    41fa:	9301      	str	r3, [sp, #4]
    41fc:	7963      	ldrb	r3, [r4, #5]
    41fe:	9300      	str	r3, [sp, #0]
    4200:	9505      	str	r5, [sp, #20]
    4202:	79a3      	ldrb	r3, [r4, #6]
    4204:	4a0a      	ldr	r2, [pc, #40]	; (4230 <bt_addr_le_to_str.constprop.1+0x64>)
    4206:	211e      	movs	r1, #30
    4208:	4630      	mov	r0, r6
    420a:	f01b fddf 	bl	1fdcc <snprintk>
			addr->a.val[5], addr->a.val[4], addr->a.val[3],
			addr->a.val[2], addr->a.val[1], addr->a.val[0], type);
}
    420e:	b00a      	add	sp, #40	; 0x28
    4210:	bd70      	pop	{r4, r5, r6, pc}
		strcpy(type, "random");
    4212:	4908      	ldr	r1, [pc, #32]	; (4234 <bt_addr_le_to_str.constprop.1+0x68>)
    4214:	e7e7      	b.n	41e6 <bt_addr_le_to_str.constprop.1+0x1a>
		strcpy(type, "public-id");
    4216:	4908      	ldr	r1, [pc, #32]	; (4238 <bt_addr_le_to_str.constprop.1+0x6c>)
    4218:	e7e5      	b.n	41e6 <bt_addr_le_to_str.constprop.1+0x1a>
		strcpy(type, "random-id");
    421a:	4908      	ldr	r1, [pc, #32]	; (423c <bt_addr_le_to_str.constprop.1+0x70>)
    421c:	e7e3      	b.n	41e6 <bt_addr_le_to_str.constprop.1+0x1a>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
    421e:	4a08      	ldr	r2, [pc, #32]	; (4240 <bt_addr_le_to_str.constprop.1+0x74>)
    4220:	210a      	movs	r1, #10
    4222:	4628      	mov	r0, r5
    4224:	f01b fdd2 	bl	1fdcc <snprintk>
		break;
    4228:	e7e0      	b.n	41ec <bt_addr_le_to_str.constprop.1+0x20>
    422a:	bf00      	nop
    422c:	000298cf 	.word	0x000298cf
    4230:	000298f1 	.word	0x000298f1
    4234:	000298d6 	.word	0x000298d6
    4238:	000298dd 	.word	0x000298dd
    423c:	000298e7 	.word	0x000298e7
    4240:	000642f2 	.word	0x000642f2

00004244 <auth_passkey_display>:

	printk("Bluetooth advertising successfully started\n");
}

static void auth_passkey_display(struct bt_conn *conn, unsigned int passkey)
{
    4244:	b510      	push	{r4, lr}
    4246:	b088      	sub	sp, #32
    4248:	460c      	mov	r4, r1
	char addr[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
    424a:	f01e fa6b 	bl	22724 <bt_conn_get_dst>
    424e:	4669      	mov	r1, sp
    4250:	f7ff ffbc 	bl	41cc <bt_addr_le_to_str.constprop.1>

	printk("Passkey for %s: %06u\n", addr, passkey);
    4254:	4622      	mov	r2, r4
    4256:	4669      	mov	r1, sp
    4258:	4802      	ldr	r0, [pc, #8]	; (4264 <auth_passkey_display+0x20>)
    425a:	f01b fdaa 	bl	1fdb2 <printk>
}
    425e:	b008      	add	sp, #32
    4260:	bd10      	pop	{r4, pc}
    4262:	bf00      	nop
    4264:	000298b9 	.word	0x000298b9

00004268 <auth_cancel>:

static void auth_cancel(struct bt_conn *conn)
{
    4268:	b500      	push	{lr}
    426a:	b089      	sub	sp, #36	; 0x24
	char addr[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
    426c:	f01e fa5a 	bl	22724 <bt_conn_get_dst>
    4270:	4669      	mov	r1, sp
    4272:	f7ff ffab 	bl	41cc <bt_addr_le_to_str.constprop.1>

	printk("Pairing cancelled: %s\n", addr);
    4276:	4669      	mov	r1, sp
    4278:	4802      	ldr	r0, [pc, #8]	; (4284 <auth_cancel+0x1c>)
    427a:	f01b fd9a 	bl	1fdb2 <printk>
}
    427e:	b009      	add	sp, #36	; 0x24
    4280:	f85d fb04 	ldr.w	pc, [sp], #4
    4284:	000298a2 	.word	0x000298a2

00004288 <bt_setup>:

	bt_gatt_hrs_notify(heartrate);
}

void bt_setup(void)
{
    4288:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	int err;

	err = bt_enable(NULL);
    428a:	2000      	movs	r0, #0
    428c:	f005 fb40 	bl	9910 <bt_enable>
	if (err) {
    4290:	4604      	mov	r4, r0
    4292:	b128      	cbz	r0, 42a0 <bt_setup+0x18>
		printk("Bluetooth init failed (err %d)\n", err);
    4294:	4601      	mov	r1, r0
    4296:	4816      	ldr	r0, [pc, #88]	; (42f0 <bt_setup+0x68>)
    4298:	f01b fd8b 	bl	1fdb2 <printk>

	bt_conn_cb_register(&conn_callbacks);
	bt_conn_auth_cb_register(&auth_cb_display);

	printk("Bluetooth inited.");
}
    429c:	b004      	add	sp, #16
    429e:	bd10      	pop	{r4, pc}
	cts_init();
    42a0:	f000 f84c 	bl	433c <cts_init>
	err = bt_le_adv_start(BT_LE_ADV_CONN_NAME, ad, ARRAY_SIZE(ad), NULL, 0);
    42a4:	2309      	movs	r3, #9
    42a6:	f8ad 4008 	strh.w	r4, [sp, #8]
    42aa:	f88d 3009 	strb.w	r3, [sp, #9]
    42ae:	23a0      	movs	r3, #160	; 0xa0
    42b0:	f8ad 300a 	strh.w	r3, [sp, #10]
    42b4:	23f0      	movs	r3, #240	; 0xf0
    42b6:	f8ad 300c 	strh.w	r3, [sp, #12]
    42ba:	490e      	ldr	r1, [pc, #56]	; (42f4 <bt_setup+0x6c>)
    42bc:	9400      	str	r4, [sp, #0]
    42be:	4623      	mov	r3, r4
    42c0:	2203      	movs	r2, #3
    42c2:	a802      	add	r0, sp, #8
    42c4:	f01e f974 	bl	225b0 <bt_le_adv_start>
	if (err) {
    42c8:	4601      	mov	r1, r0
    42ca:	b160      	cbz	r0, 42e6 <bt_setup+0x5e>
		printk("Bluetooth advertising failed to start (err %d)\n", err);
    42cc:	480a      	ldr	r0, [pc, #40]	; (42f8 <bt_setup+0x70>)
    42ce:	f01b fd70 	bl	1fdb2 <printk>
	bt_conn_cb_register(&conn_callbacks);
    42d2:	480a      	ldr	r0, [pc, #40]	; (42fc <bt_setup+0x74>)
    42d4:	f006 fb1a 	bl	a90c <bt_conn_cb_register>
	bt_conn_auth_cb_register(&auth_cb_display);
    42d8:	4809      	ldr	r0, [pc, #36]	; (4300 <bt_setup+0x78>)
    42da:	f006 ff59 	bl	b190 <bt_conn_auth_cb_register>
	printk("Bluetooth inited.");
    42de:	4809      	ldr	r0, [pc, #36]	; (4304 <bt_setup+0x7c>)
    42e0:	f01b fd67 	bl	1fdb2 <printk>
    42e4:	e7da      	b.n	429c <bt_setup+0x14>
	printk("Bluetooth advertising successfully started\n");
    42e6:	4808      	ldr	r0, [pc, #32]	; (4308 <bt_setup+0x80>)
    42e8:	f01b fd63 	bl	1fdb2 <printk>
    42ec:	e7f1      	b.n	42d2 <bt_setup+0x4a>
    42ee:	bf00      	nop
    42f0:	00029914 	.word	0x00029914
    42f4:	00028888 	.word	0x00028888
    42f8:	00029934 	.word	0x00029934
    42fc:	2000e698 	.word	0x2000e698
    4300:	2000e678 	.word	0x2000e678
    4304:	00029990 	.word	0x00029990
    4308:	00029964 	.word	0x00029964

0000430c <write_ct>:
}

static ssize_t write_ct(struct bt_conn *conn, const struct bt_gatt_attr *attr,
			const void *buf, u16_t len, u16_t offset,
			u8_t flags)
{
    430c:	b570      	push	{r4, r5, r6, lr}
    430e:	f8bd 0010 	ldrh.w	r0, [sp, #16]
	u8_t *value = attr->user_data;
    4312:	68cd      	ldr	r5, [r1, #12]

	if (offset + len > sizeof(ct)) {
    4314:	461c      	mov	r4, r3
    4316:	18c3      	adds	r3, r0, r3
    4318:	2b0a      	cmp	r3, #10
{
    431a:	4616      	mov	r6, r2
	if (offset + len > sizeof(ct)) {
    431c:	dc09      	bgt.n	4332 <write_ct+0x26>
    431e:	4622      	mov	r2, r4
    4320:	4631      	mov	r1, r6
    4322:	4428      	add	r0, r5
    4324:	f7fd fc62 	bl	1bec <memcpy>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
	}

	memcpy(value + offset, buf, len);
	ct_update = 1U;
    4328:	4b03      	ldr	r3, [pc, #12]	; (4338 <write_ct+0x2c>)
    432a:	2201      	movs	r2, #1
    432c:	701a      	strb	r2, [r3, #0]

	return len;
}
    432e:	4620      	mov	r0, r4
    4330:	bd70      	pop	{r4, r5, r6, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
    4332:	f06f 0406 	mvn.w	r4, #6
    4336:	e7fa      	b.n	432e <write_ct+0x22>
    4338:	20006152 	.word	0x20006152

0000433c <cts_init>:
	 * 'Date Time' - characteristic contains fields for:
	 * year, month, day, hours, minutes and seconds.
	 */

	year = sys_cpu_to_le16(2015);
	memcpy(buf,  &year, 2); /* year */
    433c:	4b09      	ldr	r3, [pc, #36]	; (4364 <cts_init+0x28>)
    433e:	f240 72df 	movw	r2, #2015	; 0x7df
    4342:	801a      	strh	r2, [r3, #0]
	buf[2] = 5U; /* months starting from 1 */
    4344:	2205      	movs	r2, #5
    4346:	709a      	strb	r2, [r3, #2]
	buf[3] = 30U; /* day */
    4348:	221e      	movs	r2, #30
	buf[4] = 12U; /* hours */
    434a:	210c      	movs	r1, #12
	buf[3] = 30U; /* day */
    434c:	70da      	strb	r2, [r3, #3]
	buf[5] = 45U; /* minutes */
	buf[6] = 30U; /* seconds */
    434e:	719a      	strb	r2, [r3, #6]

	/* 'Day of Week' part of 'Day Date Time' */
	buf[7] = 1U; /* day of week starting from 1 */
    4350:	2201      	movs	r2, #1
	buf[4] = 12U; /* hours */
    4352:	7119      	strb	r1, [r3, #4]
	buf[7] = 1U; /* day of week starting from 1 */
    4354:	71da      	strb	r2, [r3, #7]
	buf[5] = 45U; /* minutes */
    4356:	212d      	movs	r1, #45	; 0x2d

	/* 'Fractions 256 part of 'Exact Time 256' */
	buf[8] = 0U;
    4358:	2200      	movs	r2, #0
	buf[5] = 45U; /* minutes */
    435a:	7159      	strb	r1, [r3, #5]
	buf[8] = 0U;
    435c:	721a      	strb	r2, [r3, #8]

	/* Adjust reason */
	buf[9] = 0U; /* No update, change, etc */
    435e:	725a      	strb	r2, [r3, #9]

void cts_init(void)
{
	/* Simulate current time for Current Time Service */
	generate_current_time(ct);
}
    4360:	4770      	bx	lr
    4362:	bf00      	nop
    4364:	20006148 	.word	0x20006148

00004368 <sync_cts_to_clock.isra.0>:
int time_sync_timeout = TIME_SYNC_WAIT;
static struct bt_gatt_discover_params cts_discovery_params;
static struct bt_uuid_16 uuid = BT_UUID_INIT_16(0);
static struct bt_gatt_read_params read_params;

static void sync_cts_to_clock(cts_datetime_t* cts_datetime)
    4368:	b508      	push	{r3, lr}
    clock_datetime.tm_min = cts_datetime->minutes;
    clock_datetime.tm_sec = cts_datetime->seconds;

    //clock_set_datetime(&clock_datetime);

    LOG_INF("CTS sync to clock complete.");
    436a:	f04f 0100 	mov.w	r1, #0
    436e:	2303      	movs	r3, #3
    4370:	4a07      	ldr	r2, [pc, #28]	; (4390 <sync_cts_to_clock.isra.0+0x28>)
    4372:	4808      	ldr	r0, [pc, #32]	; (4394 <sync_cts_to_clock.isra.0+0x2c>)
    4374:	f363 0107 	bfi	r1, r3, #0, #8
    4378:	4b07      	ldr	r3, [pc, #28]	; (4398 <sync_cts_to_clock.isra.0+0x30>)
    437a:	1a9b      	subs	r3, r3, r2
    437c:	08db      	lsrs	r3, r3, #3
    437e:	f363 118f 	bfi	r1, r3, #6, #10
    4382:	f01c fe5a 	bl	2103a <log_0>

    time_sync_timeout = TIME_SYNC_WAIT;
    4386:	4b05      	ldr	r3, [pc, #20]	; (439c <sync_cts_to_clock.isra.0+0x34>)
    4388:	223c      	movs	r2, #60	; 0x3c
    438a:	601a      	str	r2, [r3, #0]
}
    438c:	bd08      	pop	{r3, pc}
    438e:	bf00      	nop
    4390:	00028540 	.word	0x00028540
    4394:	00029a6f 	.word	0x00029a6f
    4398:	00028540 	.word	0x00028540
    439c:	2000e6d4 	.word	0x2000e6d4

000043a0 <cts_sync_read>:
int offset = 0;
cts_datetime_t datetime_buf;
u8_t cts_sync_read(struct bt_conn *conn, u8_t err,
				    struct bt_gatt_read_params *params,
				    const void *data, u16_t length)
{
    43a0:	b570      	push	{r4, r5, r6, lr}
    43a2:	f8bd 4010 	ldrh.w	r4, [sp, #16]
    LOG_DBG("Reading CCC data: err %d, %d bytes, offset %d.", err, length, offset);

    if (!data || length <= 0) {
    43a6:	b103      	cbz	r3, 43aa <cts_sync_read+0xa>
    43a8:	b91c      	cbnz	r4, 43b2 <cts_sync_read+0x12>
        sync_cts_to_clock(&datetime_buf);
    43aa:	f7ff ffdd 	bl	4368 <sync_cts_to_clock.isra.0>
        return BT_GATT_ITER_STOP;
    43ae:	2000      	movs	r0, #0

    memcpy(&datetime_buf + offset, data, length);
    offset += length;

    return BT_GATT_ITER_CONTINUE;
}
    43b0:	bd70      	pop	{r4, r5, r6, pc}
    memcpy(&datetime_buf + offset, data, length);
    43b2:	4d07      	ldr	r5, [pc, #28]	; (43d0 <cts_sync_read+0x30>)
    43b4:	4619      	mov	r1, r3
    43b6:	682e      	ldr	r6, [r5, #0]
    43b8:	4b06      	ldr	r3, [pc, #24]	; (43d4 <cts_sync_read+0x34>)
    43ba:	200a      	movs	r0, #10
    43bc:	4622      	mov	r2, r4
    43be:	fb00 3006 	mla	r0, r0, r6, r3
    offset += length;
    43c2:	4434      	add	r4, r6
    43c4:	f7fd fc12 	bl	1bec <memcpy>
    43c8:	602c      	str	r4, [r5, #0]
    43ca:	2001      	movs	r0, #1
    43cc:	e7f0      	b.n	43b0 <cts_sync_read+0x10>
    43ce:	bf00      	nop
    43d0:	20000038 	.word	0x20000038
    43d4:	20006114 	.word	0x20006114

000043d8 <cts_sync_service_discovered>:

u8_t cts_sync_service_discovered(struct bt_conn* conn, const struct bt_gatt_attr* attr,
        struct bt_gatt_discover_params* params)
{
    43d8:	b510      	push	{r4, lr}
    if (!attr) {
    43da:	b301      	cbz	r1, 441e <cts_sync_service_discovered+0x46>
        LOG_DBG("CTS Service Discovery completed");
        return BT_GATT_ITER_STOP;
    }
    LOG_DBG("Discovered attribute, handle: %u\n", attr->handle);

    memset(&read_params, 0, sizeof(read_params));
    43dc:	4b11      	ldr	r3, [pc, #68]	; (4424 <cts_sync_service_discovered+0x4c>)
    read_params.func = cts_sync_read;
    read_params.by_uuid.uuid = &uuid;
    read_params.by_uuid.start_handle = attr->handle;
    43de:	8a09      	ldrh	r1, [r1, #16]
    43e0:	8119      	strh	r1, [r3, #8]
    read_params.by_uuid.end_handle = 0xffff;
    43e2:	f64f 71ff 	movw	r1, #65535	; 0xffff
    43e6:	8159      	strh	r1, [r3, #10]
    offset = 0;
    43e8:	490f      	ldr	r1, [pc, #60]	; (4428 <cts_sync_service_discovered+0x50>)
    read_params.func = cts_sync_read;
    43ea:	4c10      	ldr	r4, [pc, #64]	; (442c <cts_sync_service_discovered+0x54>)
    43ec:	601c      	str	r4, [r3, #0]
    memset(&read_params, 0, sizeof(read_params));
    43ee:	2200      	movs	r2, #0
    offset = 0;
    43f0:	600a      	str	r2, [r1, #0]
    memset(&read_params, 0, sizeof(read_params));
    43f2:	605a      	str	r2, [r3, #4]
    read_params.by_uuid.uuid = &uuid;
    43f4:	4c0e      	ldr	r4, [pc, #56]	; (4430 <cts_sync_service_discovered+0x58>)
    43f6:	60dc      	str	r4, [r3, #12]
    if (bt_gatt_read(conn, &read_params) < 0) {
    43f8:	4619      	mov	r1, r3
    43fa:	f009 fe25 	bl	e048 <bt_gatt_read>
    43fe:	2800      	cmp	r0, #0
    4400:	da0d      	bge.n	441e <cts_sync_service_discovered+0x46>
        LOG_WRN("Could not initiate read of CCC data.");
    4402:	2302      	movs	r3, #2
    4404:	f04f 0100 	mov.w	r1, #0
    4408:	f363 0107 	bfi	r1, r3, #0, #8
    440c:	4a09      	ldr	r2, [pc, #36]	; (4434 <cts_sync_service_discovered+0x5c>)
    440e:	4b0a      	ldr	r3, [pc, #40]	; (4438 <cts_sync_service_discovered+0x60>)
    4410:	480a      	ldr	r0, [pc, #40]	; (443c <cts_sync_service_discovered+0x64>)
    4412:	1a9b      	subs	r3, r3, r2
    4414:	08db      	lsrs	r3, r3, #3
    4416:	f363 118f 	bfi	r1, r3, #6, #10
    441a:	f01c fe0e 	bl	2103a <log_0>
    }

    return BT_GATT_ITER_STOP;
}
    441e:	2000      	movs	r0, #0
    4420:	bd10      	pop	{r4, pc}
    4422:	bf00      	nop
    4424:	2000003c 	.word	0x2000003c
    4428:	20000038 	.word	0x20000038
    442c:	000043a1 	.word	0x000043a1
    4430:	2000611e 	.word	0x2000611e
    4434:	00028540 	.word	0x00028540
    4438:	00028540 	.word	0x00028540
    443c:	00029a4a 	.word	0x00029a4a

00004440 <cts_sync_processor>:

static void cts_sync_processor(struct bt_conn *conn, void *data)
{
    4440:	b507      	push	{r0, r1, r2, lr}
    memcpy(&uuid, BT_UUID_CTS_CURRENT_TIME, sizeof(uuid));
    4442:	2300      	movs	r3, #0
    4444:	f88d 3004 	strb.w	r3, [sp, #4]
    4448:	f642 232b 	movw	r3, #10795	; 0x2a2b
    444c:	f8ad 3006 	strh.w	r3, [sp, #6]
    4450:	4b12      	ldr	r3, [pc, #72]	; (449c <cts_sync_processor+0x5c>)
    cts_discovery_params.func = cts_sync_service_discovered;
    4452:	4913      	ldr	r1, [pc, #76]	; (44a0 <cts_sync_processor+0x60>)
    memcpy(&uuid, BT_UUID_CTS_CURRENT_TIME, sizeof(uuid));
    4454:	9a01      	ldr	r2, [sp, #4]
    4456:	601a      	str	r2, [r3, #0]
    cts_discovery_params.func = cts_sync_service_discovered;
    4458:	4a12      	ldr	r2, [pc, #72]	; (44a4 <cts_sync_processor+0x64>)
    445a:	604a      	str	r2, [r1, #4]
    cts_discovery_params.start_handle = 0x0001;
    445c:	2201      	movs	r2, #1
    445e:	810a      	strh	r2, [r1, #8]
    cts_discovery_params.end_handle = 0xFFFF;
    4460:	f64f 72ff 	movw	r2, #65535	; 0xffff
    4464:	81ca      	strh	r2, [r1, #14]
    cts_discovery_params.type = BT_GATT_DISCOVER_CHARACTERISTIC;
    4466:	2203      	movs	r2, #3
    4468:	740a      	strb	r2, [r1, #16]
    cts_discovery_params.uuid = &uuid;
    446a:	600b      	str	r3, [r1, #0]

    if (bt_gatt_discover(conn, &cts_discovery_params) != 0) {
    446c:	f009 fa2c 	bl	d8c8 <bt_gatt_discover>
    4470:	b180      	cbz	r0, 4494 <cts_sync_processor+0x54>
        LOG_ERR("CTS Sync > GATT discovery FAILED.\n");
    4472:	2301      	movs	r3, #1
    4474:	f04f 0100 	mov.w	r1, #0
    4478:	f363 0107 	bfi	r1, r3, #0, #8
    447c:	4a0a      	ldr	r2, [pc, #40]	; (44a8 <cts_sync_processor+0x68>)
    447e:	4b0b      	ldr	r3, [pc, #44]	; (44ac <cts_sync_processor+0x6c>)
    4480:	480b      	ldr	r0, [pc, #44]	; (44b0 <cts_sync_processor+0x70>)
    4482:	1a9b      	subs	r3, r3, r2
    4484:	08db      	lsrs	r3, r3, #3
    4486:	f363 118f 	bfi	r1, r3, #6, #10
    }
}
    448a:	b003      	add	sp, #12
    448c:	f85d eb04 	ldr.w	lr, [sp], #4
        LOG_ERR("CTS Sync > GATT discovery FAILED.\n");
    4490:	f01c bdd3 	b.w	2103a <log_0>
}
    4494:	b003      	add	sp, #12
    4496:	f85d fb04 	ldr.w	pc, [sp], #4
    449a:	bf00      	nop
    449c:	2000611e 	.word	0x2000611e
    44a0:	20000024 	.word	0x20000024
    44a4:	000043d9 	.word	0x000043d9
    44a8:	00028540 	.word	0x00028540
    44ac:	00028540 	.word	0x00028540
    44b0:	00029a27 	.word	0x00029a27

000044b4 <cts_sync_loop>:
    cts_register_write_cb(cts_write_cb);
    sync_local_cts_to_clock();
}

void cts_sync_loop()
{
    44b4:	b510      	push	{r4, lr}
    if (time_sync_timeout > 0) {
    44b6:	4c07      	ldr	r4, [pc, #28]	; (44d4 <cts_sync_loop+0x20>)
    44b8:	6823      	ldr	r3, [r4, #0]
    44ba:	2b00      	cmp	r3, #0
    44bc:	dd02      	ble.n	44c4 <cts_sync_loop+0x10>
        time_sync_timeout--;
    44be:	3b01      	subs	r3, #1
    } else {
        bt_conn_foreach(BT_CONN_TYPE_ALL, cts_sync_processor, NULL);
        time_sync_timeout = TIME_SYNC_WAIT;
    44c0:	6023      	str	r3, [r4, #0]
    }
}
    44c2:	bd10      	pop	{r4, pc}
        bt_conn_foreach(BT_CONN_TYPE_ALL, cts_sync_processor, NULL);
    44c4:	2200      	movs	r2, #0
    44c6:	4904      	ldr	r1, [pc, #16]	; (44d8 <cts_sync_loop+0x24>)
    44c8:	2007      	movs	r0, #7
    44ca:	f006 fcf1 	bl	aeb0 <bt_conn_foreach>
        time_sync_timeout = TIME_SYNC_WAIT;
    44ce:	233c      	movs	r3, #60	; 0x3c
    44d0:	e7f6      	b.n	44c0 <cts_sync_loop+0xc>
    44d2:	bf00      	nop
    44d4:	2000e6d4 	.word	0x2000e6d4
    44d8:	00004441 	.word	0x00004441

000044dc <test_counter_interrupt_fn>:
struct counter_alarm_cfg alarm_cfg;

static void test_counter_interrupt_fn(struct device *counter_dev,
		u8_t chan_id, u32_t ticks,
		void *user_data)
{
    44dc:	b430      	push	{r4, r5}
	//u64_t now_usec = counter_ticks_to_us(counter_dev, now_ticks);
//	int now_sec = (int)(now_usec / USEC_PER_SEC);
//	struct counter_alarm_cfg *config = user_data;
int err;

	seconden++;
    44de:	4c0e      	ldr	r4, [pc, #56]	; (4518 <test_counter_interrupt_fn+0x3c>)
    44e0:	6822      	ldr	r2, [r4, #0]
    44e2:	3201      	adds	r2, #1
	if (seconden > 59) {
    44e4:	2a3b      	cmp	r2, #59	; 0x3b
    44e6:	dc04      	bgt.n	44f2 <test_counter_interrupt_fn+0x16>
	seconden++;
    44e8:	6022      	str	r2, [r4, #0]
	}




		err = counter_set_channel_alarm(counter_dev, ALARM_CHANNEL_ID,
    44ea:	4619      	mov	r1, r3
				user_data);


}
    44ec:	bc30      	pop	{r4, r5}
		err = counter_set_channel_alarm(counter_dev, ALARM_CHANNEL_ID,
    44ee:	f01b b897 	b.w	1f620 <counter_set_channel_alarm.constprop.2>
		minuten++;
    44f2:	4d0a      	ldr	r5, [pc, #40]	; (451c <test_counter_interrupt_fn+0x40>)
		seconden=0;
    44f4:	2200      	movs	r2, #0
    44f6:	6022      	str	r2, [r4, #0]
		minuten++;
    44f8:	682c      	ldr	r4, [r5, #0]
    44fa:	3401      	adds	r4, #1
		if (minuten > 59){
    44fc:	2c3b      	cmp	r4, #59	; 0x3b
    44fe:	dc01      	bgt.n	4504 <test_counter_interrupt_fn+0x28>
		minuten++;
    4500:	602c      	str	r4, [r5, #0]
    4502:	e7f2      	b.n	44ea <test_counter_interrupt_fn+0xe>
			minuten=0;
    4504:	602a      	str	r2, [r5, #0]
			uren++;
    4506:	4d06      	ldr	r5, [pc, #24]	; (4520 <test_counter_interrupt_fn+0x44>)
    4508:	682c      	ldr	r4, [r5, #0]
    450a:	3401      	adds	r4, #1
			if (uren > 23)
    450c:	2c17      	cmp	r4, #23
			uren++;
    450e:	bfd8      	it	le
    4510:	4622      	movle	r2, r4
    4512:	602a      	str	r2, [r5, #0]
    4514:	e7e9      	b.n	44ea <test_counter_interrupt_fn+0xe>
    4516:	bf00      	nop
    4518:	20000060 	.word	0x20000060
    451c:	2000005c 	.word	0x2000005c
    4520:	20000064 	.word	0x20000064

00004524 <main>:
}



void main(void)
{
    4524:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    4528:	b089      	sub	sp, #36	; 0x24
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    452a:	485a      	ldr	r0, [pc, #360]	; (4694 <main+0x170>)
    452c:	f019 fd78 	bl	1e020 <z_impl_device_get_binding>
    4530:	4606      	mov	r6, r0
static inline int z_impl_counter_start(struct device *dev)
{
	const struct counter_driver_api *api =
				(struct counter_driver_api *)dev->driver_api;

	return api->start(dev);
    4532:	6843      	ldr	r3, [r0, #4]
	int err;
	struct device *counter_dev;
	counter_dev = device_get_binding(DT_RTC_0_NAME);
	counter_start(counter_dev);

	alarm_cfg.flags = 0;
    4534:	4d58      	ldr	r5, [pc, #352]	; (4698 <main+0x174>)
    4536:	681b      	ldr	r3, [r3, #0]
    4538:	4798      	blx	r3
	const struct counter_config_info *config =
    453a:	6833      	ldr	r3, [r6, #0]
	u64_t ticks = (us * config->freq) / USEC_PER_SEC;
    453c:	4957      	ldr	r1, [pc, #348]	; (469c <main+0x178>)
    453e:	689b      	ldr	r3, [r3, #8]
    4540:	4a56      	ldr	r2, [pc, #344]	; (469c <main+0x178>)
    4542:	6858      	ldr	r0, [r3, #4]
    4544:	2400      	movs	r4, #0
    4546:	60ec      	str	r4, [r5, #12]
    4548:	2300      	movs	r3, #0
    454a:	fba0 0101 	umull	r0, r1, r0, r1
    454e:	f7fb fe17 	bl	180 <__aeabi_uldivmod>
	alarm_cfg.ticks = counter_us_to_ticks(counter_dev, DELAY);
	alarm_cfg.callback = test_counter_interrupt_fn;
    4552:	4b53      	ldr	r3, [pc, #332]	; (46a0 <main+0x17c>)
	return (ticks > (u64_t)UINT32_MAX) ? UINT32_MAX : ticks;
    4554:	6068      	str	r0, [r5, #4]
	alarm_cfg.user_data = &alarm_cfg;

	err=counter_set_channel_alarm(counter_dev, ALARM_CHANNEL_ID, &alarm_cfg);
    4556:	4629      	mov	r1, r5
    4558:	4630      	mov	r0, r6
	alarm_cfg.callback = test_counter_interrupt_fn;
    455a:	602b      	str	r3, [r5, #0]
	alarm_cfg.user_data = &alarm_cfg;
    455c:	60ad      	str	r5, [r5, #8]
	err=counter_set_channel_alarm(counter_dev, ALARM_CHANNEL_ID, &alarm_cfg);
    455e:	f01b f85f 	bl	1f620 <counter_set_channel_alarm.constprop.2>


bt_setup();
    4562:	f7ff fe91 	bl	4288 <bt_setup>


	//lv_obj_t *scr = lv_scr_act();
	lv_obj_t * img_bin = lv_img_create(lv_scr_act(), NULL);
    4566:	f01b f854 	bl	1f612 <lv_scr_act>
    456a:	4621      	mov	r1, r4
    456c:	f019 fa2e 	bl	1d9cc <lv_img_create>

	/*clock background*/
	lv_img_set_src(img_bin, &klokje);
    4570:	494c      	ldr	r1, [pc, #304]	; (46a4 <main+0x180>)
    4572:	f019 f975 	bl	1d860 <lv_img_set_src>

	//int year;
	//int buff[10];
	char snum[3];
	u32_t count = 0U;
	char count_str[11] = {0};
    4576:	e9cd 4405 	strd	r4, r4, [sp, #20]
    457a:	f8cd 401b 	str.w	r4, [sp, #27]
    457e:	484a      	ldr	r0, [pc, #296]	; (46a8 <main+0x184>)
    4580:	f019 fd4e 	bl	1e020 <z_impl_device_get_binding>

//	lv_style_copy(&style1, &lv_style_plain);        /*Copy a built-in style*/
//	style1.body.main_color = LV_COLOR_RED;          /*Main color*/


	if (display_dev == NULL) {
    4584:	4605      	mov	r5, r0
    4586:	b980      	cbnz	r0, 45aa <main+0x86>
		LOG_ERR("device not found.  Aborting test.");
    4588:	2301      	movs	r3, #1
    458a:	f04f 0100 	mov.w	r1, #0
    458e:	4a47      	ldr	r2, [pc, #284]	; (46ac <main+0x188>)
    4590:	4847      	ldr	r0, [pc, #284]	; (46b0 <main+0x18c>)
    4592:	f363 0107 	bfi	r1, r3, #0, #8
    4596:	4b47      	ldr	r3, [pc, #284]	; (46b4 <main+0x190>)
    4598:	1a9b      	subs	r3, r3, r2
    459a:	08db      	lsrs	r3, r3, #3
    459c:	f363 118f 	bfi	r1, r3, #6, #10
    45a0:	f01c fd4b 	bl	2103a <log_0>
		}
		lv_task_handler();
		k_sleep(K_MSEC(10));
		++count;
	}
}
    45a4:	b009      	add	sp, #36	; 0x24
    45a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    45aa:	4843      	ldr	r0, [pc, #268]	; (46b8 <main+0x194>)
    45ac:	f019 fd38 	bl	1e020 <z_impl_device_get_binding>
    45b0:	4606      	mov	r6, r0
				    u32_t pin, int flags)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	return api->config(port, access_op, pin, flags);
    45b2:	6843      	ldr	r3, [r0, #4]
    45b4:	2216      	movs	r2, #22
    45b6:	681f      	ldr	r7, [r3, #0]
    45b8:	4621      	mov	r1, r4
    45ba:	2301      	movs	r3, #1
    45bc:	47b8      	blx	r7
				   u32_t pin, u32_t value)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	return api->write(port, access_op, pin, value);
    45be:	6873      	ldr	r3, [r6, #4]
		sprintf(snum, "%2d:%2d:%2d", uren, minuten,seconden); //seconden gets updated by interrupt
    45c0:	f8df 8108 	ldr.w	r8, [pc, #264]	; 46cc <main+0x1a8>
    45c4:	685f      	ldr	r7, [r3, #4]
    45c6:	f8df 9108 	ldr.w	r9, [pc, #264]	; 46d0 <main+0x1ac>
    45ca:	4623      	mov	r3, r4
    45cc:	2216      	movs	r2, #22
    45ce:	4621      	mov	r1, r4
    45d0:	4630      	mov	r0, r6
    45d2:	47b8      	blx	r7
	hello_world_label = lv_label_create(lv_scr_act(), NULL);
    45d4:	f01b f81d 	bl	1f612 <lv_scr_act>
    45d8:	4621      	mov	r1, r4
    45da:	f018 ffd7 	bl	1d58c <lv_label_create>
	lv_label_set_long_mode(hello_world_label, LV_LABEL_LONG_BREAK);     //Break the long lines
    45de:	2101      	movs	r1, #1
	hello_world_label = lv_label_create(lv_scr_act(), NULL);
    45e0:	4606      	mov	r6, r0
	lv_label_set_long_mode(hello_world_label, LV_LABEL_LONG_BREAK);     //Break the long lines
    45e2:	f023 f970 	bl	278c6 <lv_label_set_long_mode>
	lv_label_set_recolor(hello_world_label, true);                      //Enable re-coloring by commands in the text
    45e6:	4630      	mov	r0, r6
    45e8:	2101      	movs	r1, #1
    45ea:	f023 f993 	bl	27914 <lv_label_set_recolor>
	lv_obj_set_width(hello_world_label, 240);
    45ee:	4630      	mov	r0, r6
    45f0:	21f0      	movs	r1, #240	; 0xf0
    45f2:	f021 f89c 	bl	2572e <lv_obj_set_width>
	lv_label_set_text(hello_world_label, "#0000ff Hello world! Still Space Here"); //recoloring should be blue ...
    45f6:	4931      	ldr	r1, [pc, #196]	; (46bc <main+0x198>)
    45f8:	4630      	mov	r0, r6
    45fa:	f023 f90f 	bl	2781c <lv_label_set_text>
	count_label = lv_label_create(lv_scr_act(), NULL);
    45fe:	f01b f808 	bl	1f612 <lv_scr_act>
    4602:	4621      	mov	r1, r4
    4604:	f018 ffc2 	bl	1d58c <lv_label_create>
    4608:	4606      	mov	r6, r0
	clock_label = lv_label_create(lv_scr_act(), NULL);
    460a:	f01b f802 	bl	1f612 <lv_scr_act>
    460e:	4621      	mov	r1, r4
    4610:	f018 ffbc 	bl	1d58c <lv_label_create>
	lv_obj_align(count_label, NULL, LV_ALIGN_IN_BOTTOM_MID, 0, 0);
    4614:	4623      	mov	r3, r4
	clock_label = lv_label_create(lv_scr_act(), NULL);
    4616:	4607      	mov	r7, r0
	lv_obj_align(count_label, NULL, LV_ALIGN_IN_BOTTOM_MID, 0, 0);
    4618:	2205      	movs	r2, #5
    461a:	4621      	mov	r1, r4
    461c:	4630      	mov	r0, r6
    461e:	9400      	str	r4, [sp, #0]
    4620:	f021 f8d8 	bl	257d4 <lv_obj_align>
	lv_obj_align(clock_label, NULL, LV_ALIGN_CENTER, 0, 0);
    4624:	4623      	mov	r3, r4
    4626:	4622      	mov	r2, r4
    4628:	4621      	mov	r1, r4
    462a:	4638      	mov	r0, r7
    462c:	9400      	str	r4, [sp, #0]
    462e:	f021 f8d1 	bl	257d4 <lv_obj_align>
static inline int display_blanking_off(const struct device *dev)
{
	struct display_driver_api *api =
		(struct display_driver_api *)dev->driver_api;

	return api->blanking_off(dev);
    4632:	686b      	ldr	r3, [r5, #4]
    4634:	4628      	mov	r0, r5
    4636:	685b      	ldr	r3, [r3, #4]
		sprintf(snum, "%2d:%2d:%2d", uren, minuten,seconden); //seconden gets updated by interrupt
    4638:	4d21      	ldr	r5, [pc, #132]	; (46c0 <main+0x19c>)
    463a:	4798      	blx	r3
 cts_sync_loop();
    463c:	f7ff ff3a 	bl	44b4 <cts_sync_loop>
		sprintf(snum, "%2d:%2d:%2d", uren, minuten,seconden); //seconden gets updated by interrupt
    4640:	682b      	ldr	r3, [r5, #0]
    4642:	9302      	str	r3, [sp, #8]
    4644:	f8d8 3000 	ldr.w	r3, [r8]
    4648:	9301      	str	r3, [sp, #4]
    464a:	f8d9 3000 	ldr.w	r3, [r9]
    464e:	9300      	str	r3, [sp, #0]
    4650:	2203      	movs	r2, #3
    4652:	4b1c      	ldr	r3, [pc, #112]	; (46c4 <main+0x1a0>)
    4654:	2100      	movs	r1, #0
    4656:	a804      	add	r0, sp, #16
    4658:	f7fd fafa 	bl	1c50 <__sprintf_chk>
		lv_label_set_text(clock_label, snum); 
    465c:	a904      	add	r1, sp, #16
    465e:	4638      	mov	r0, r7
    4660:	f023 f8dc 	bl	2781c <lv_label_set_text>
		if ((count % 100) == 0U) {
    4664:	2164      	movs	r1, #100	; 0x64
    4666:	fbb4 f3f1 	udiv	r3, r4, r1
    466a:	fb01 4113 	mls	r1, r1, r3, r4
    466e:	b949      	cbnz	r1, 4684 <main+0x160>
			sprintf(count_str, "%d", count/100U);
    4670:	9300      	str	r3, [sp, #0]
    4672:	220b      	movs	r2, #11
    4674:	4b14      	ldr	r3, [pc, #80]	; (46c8 <main+0x1a4>)
    4676:	a805      	add	r0, sp, #20
    4678:	f7fd faea 	bl	1c50 <__sprintf_chk>
			lv_label_set_text(count_label, count_str);
    467c:	a905      	add	r1, sp, #20
    467e:	4630      	mov	r0, r6
    4680:	f023 f8cc 	bl	2781c <lv_label_set_text>
		lv_task_handler();
    4684:	f018 fa6c 	bl	1cb60 <lv_task_handler>
	return z_impl_k_sleep(ms);
    4688:	200a      	movs	r0, #10
    468a:	f01a fb49 	bl	1ed20 <z_impl_k_sleep>
		++count;
    468e:	3401      	adds	r4, #1
 cts_sync_loop();
    4690:	e7d4      	b.n	463c <main+0x118>
    4692:	bf00      	nop
    4694:	00061e8b 	.word	0x00061e8b
    4698:	2000004c 	.word	0x2000004c
    469c:	000f4240 	.word	0x000f4240
    46a0:	000044dd 	.word	0x000044dd
    46a4:	000289f4 	.word	0x000289f4
    46a8:	00061e91 	.word	0x00061e91
    46ac:	00028540 	.word	0x00028540
    46b0:	00061e99 	.word	0x00061e99
    46b4:	00028540 	.word	0x00028540
    46b8:	00061ebb 	.word	0x00061ebb
    46bc:	00061ec2 	.word	0x00061ec2
    46c0:	20000060 	.word	0x20000060
    46c4:	00061ee8 	.word	0x00061ee8
    46c8:	00063bf2 	.word	0x00063bf2
    46cc:	2000005c 	.word	0x2000005c
    46d0:	20000064 	.word	0x20000064

000046d4 <crc8_ccitt>:
	0x00, 0x07, 0x0e, 0x09, 0x1c, 0x1b, 0x12, 0x15,
	0x38, 0x3f, 0x36, 0x31, 0x24, 0x23, 0x2a, 0x2d
};

u8_t crc8_ccitt(u8_t val, const void *buf, size_t cnt)
{
    46d4:	b510      	push	{r4, lr}
	int i;
	const u8_t *p = buf;

	for (i = 0; i < cnt; i++) {
		val ^= p[i];
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
    46d6:	4c09      	ldr	r4, [pc, #36]	; (46fc <crc8_ccitt+0x28>)
    46d8:	440a      	add	r2, r1
	for (i = 0; i < cnt; i++) {
    46da:	4291      	cmp	r1, r2
    46dc:	d100      	bne.n	46e0 <crc8_ccitt+0xc>
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
	}
	return val;
}
    46de:	bd10      	pop	{r4, pc}
		val ^= p[i];
    46e0:	f811 3b01 	ldrb.w	r3, [r1], #1
    46e4:	4043      	eors	r3, r0
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
    46e6:	0918      	lsrs	r0, r3, #4
    46e8:	5c20      	ldrb	r0, [r4, r0]
    46ea:	ea80 1003 	eor.w	r0, r0, r3, lsl #4
    46ee:	b2c3      	uxtb	r3, r0
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
    46f0:	0918      	lsrs	r0, r3, #4
    46f2:	5c20      	ldrb	r0, [r4, r0]
    46f4:	ea80 1003 	eor.w	r0, r0, r3, lsl #4
    46f8:	b2c0      	uxtb	r0, r0
    46fa:	e7ee      	b.n	46da <crc8_ccitt+0x6>
    46fc:	00061ef8 	.word	0x00061ef8

00004700 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
    4700:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4704:	b085      	sub	sp, #20
    4706:	469b      	mov	fp, r3
    4708:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    470a:	f8df 9088 	ldr.w	r9, [pc, #136]	; 4794 <_printk_dec_ulong+0x94>
    470e:	2c01      	cmp	r4, #1
    4710:	bfb8      	it	lt
    4712:	2401      	movlt	r4, #1
    4714:	2b01      	cmp	r3, #1
    4716:	bf0c      	ite	eq
    4718:	2330      	moveq	r3, #48	; 0x30
    471a:	2320      	movne	r3, #32
    471c:	4616      	mov	r6, r2
    471e:	4682      	mov	sl, r0
    4720:	4688      	mov	r8, r1
    4722:	9302      	str	r3, [sp, #8]
    4724:	2501      	movs	r5, #1
    4726:	270a      	movs	r7, #10
    4728:	2200      	movs	r2, #0
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
    472a:	fbb6 f3f9 	udiv	r3, r6, r9
    472e:	9301      	str	r3, [sp, #4]
    4730:	b90a      	cbnz	r2, 4736 <_printk_dec_ulong+0x36>
    4732:	45b1      	cmp	r9, r6
    4734:	d81d      	bhi.n	4772 <_printk_dec_ulong+0x72>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
    4736:	9b01      	ldr	r3, [sp, #4]
    4738:	4641      	mov	r1, r8
    473a:	f103 0030 	add.w	r0, r3, #48	; 0x30
    473e:	47d0      	blx	sl
			digits++;
    4740:	3501      	adds	r5, #1
			found_largest_digit = 1;
    4742:	2201      	movs	r2, #1
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= pos;
    4744:	9b01      	ldr	r3, [sp, #4]
		remaining--;
    4746:	3f01      	subs	r7, #1
	while (pos >= 10) {
    4748:	2f01      	cmp	r7, #1
		remainder %= pos;
    474a:	fb09 6613 	mls	r6, r9, r3, r6
		pos /= 10;
    474e:	f04f 030a 	mov.w	r3, #10
    4752:	fbb9 f9f3 	udiv	r9, r9, r3
	while (pos >= 10) {
    4756:	d1e8      	bne.n	472a <_printk_dec_ulong+0x2a>
	}
	out((int)(remainder + 48), ctx);
    4758:	4641      	mov	r1, r8
    475a:	f106 0030 	add.w	r0, r6, #48	; 0x30
    475e:	47d0      	blx	sl

	if (padding == PAD_SPACE_AFTER) {
    4760:	f1bb 0f03 	cmp.w	fp, #3
    4764:	d102      	bne.n	476c <_printk_dec_ulong+0x6c>
		remaining = min_width - digits;
    4766:	1b64      	subs	r4, r4, r5
		while (remaining-- > 0) {
    4768:	2c00      	cmp	r4, #0
    476a:	dc0e      	bgt.n	478a <_printk_dec_ulong+0x8a>
			out(' ', ctx);
		}
	}
}
    476c:	b005      	add	sp, #20
    476e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
    4772:	42bc      	cmp	r4, r7
    4774:	dbe6      	blt.n	4744 <_printk_dec_ulong+0x44>
				&& padding < PAD_SPACE_AFTER) {
    4776:	f1bb 0f02 	cmp.w	fp, #2
    477a:	d8e3      	bhi.n	4744 <_printk_dec_ulong+0x44>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    477c:	4641      	mov	r1, r8
    477e:	9802      	ldr	r0, [sp, #8]
    4780:	9203      	str	r2, [sp, #12]
			digits++;
    4782:	3501      	adds	r5, #1
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    4784:	47d0      	blx	sl
			digits++;
    4786:	9a03      	ldr	r2, [sp, #12]
    4788:	e7dc      	b.n	4744 <_printk_dec_ulong+0x44>
			out(' ', ctx);
    478a:	4641      	mov	r1, r8
    478c:	2020      	movs	r0, #32
    478e:	47d0      	blx	sl
    4790:	3c01      	subs	r4, #1
    4792:	e7e9      	b.n	4768 <_printk_dec_ulong+0x68>
    4794:	3b9aca00 	.word	0x3b9aca00

00004798 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
    4798:	b530      	push	{r4, r5, lr}
    479a:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
    479c:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
    47a0:	4604      	mov	r4, r0
	struct str_context ctx = { str, size, 0 };
    47a2:	2500      	movs	r5, #0

	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    47a4:	a901      	add	r1, sp, #4
    47a6:	4805      	ldr	r0, [pc, #20]	; (47bc <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
    47a8:	9503      	str	r5, [sp, #12]
	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    47aa:	f01b f992 	bl	1fad2 <z_vprintk>

	if (ctx.count < ctx.max) {
    47ae:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
    47b2:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
    47b4:	bfb8      	it	lt
    47b6:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
    47b8:	b005      	add	sp, #20
    47ba:	bd30      	pop	{r4, r5, pc}
    47bc:	0001faad 	.word	0x0001faad

000047c0 <uECC_get_rng>:
}

uECC_RNG_Function uECC_get_rng(void)
{
	return g_rng_function;
}
    47c0:	4b01      	ldr	r3, [pc, #4]	; (47c8 <uECC_get_rng+0x8>)
    47c2:	6818      	ldr	r0, [r3, #0]
    47c4:	4770      	bx	lr
    47c6:	bf00      	nop
    47c8:	2000e6d8 	.word	0x2000e6d8

000047cc <vli_mmod_fast_secp256r1>:
{
	return &curve_secp256r1;
}

void vli_mmod_fast_secp256r1(unsigned int *result, unsigned int*product)
{
    47cc:	b5f0      	push	{r4, r5, r6, r7, lr}
	unsigned int tmp[NUM_ECC_WORDS];
	int carry;

	/* t */
	uECC_vli_set(result, product, NUM_ECC_WORDS);
    47ce:	2208      	movs	r2, #8
{
    47d0:	b089      	sub	sp, #36	; 0x24
    47d2:	460c      	mov	r4, r1
    47d4:	4606      	mov	r6, r0
	uECC_vli_set(result, product, NUM_ECC_WORDS);
    47d6:	f01b fd04 	bl	201e2 <uECC_vli_set>

	/* s1 */
	tmp[0] = tmp[1] = tmp[2] = 0;
	tmp[3] = product[11];
    47da:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    47dc:	9303      	str	r3, [sp, #12]
	tmp[4] = product[12];
    47de:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    47e0:	9304      	str	r3, [sp, #16]
	tmp[5] = product[13];
    47e2:	6b4b      	ldr	r3, [r1, #52]	; 0x34
    47e4:	9305      	str	r3, [sp, #20]
	tmp[6] = product[14];
    47e6:	6b8b      	ldr	r3, [r1, #56]	; 0x38
    47e8:	9306      	str	r3, [sp, #24]
	tmp[7] = product[15];
    47ea:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
    47ec:	9307      	str	r3, [sp, #28]
	tmp[0] = tmp[1] = tmp[2] = 0;
    47ee:	2700      	movs	r7, #0
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    47f0:	2308      	movs	r3, #8
    47f2:	466a      	mov	r2, sp
    47f4:	4669      	mov	r1, sp
    47f6:	4668      	mov	r0, sp
	tmp[0] = tmp[1] = tmp[2] = 0;
    47f8:	e9cd 7701 	strd	r7, r7, [sp, #4]
    47fc:	9700      	str	r7, [sp, #0]
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    47fe:	f01b fbf5 	bl	1ffec <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    4802:	2308      	movs	r3, #8
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    4804:	4605      	mov	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    4806:	466a      	mov	r2, sp
    4808:	4631      	mov	r1, r6
    480a:	4630      	mov	r0, r6
    480c:	f01b fbee 	bl	1ffec <uECC_vli_add>

	/* s2 */
	tmp[3] = product[12];
    4810:	6b23      	ldr	r3, [r4, #48]	; 0x30
    4812:	9303      	str	r3, [sp, #12]
	tmp[4] = product[13];
    4814:	6b63      	ldr	r3, [r4, #52]	; 0x34
    4816:	9304      	str	r3, [sp, #16]
	tmp[5] = product[14];
    4818:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    481a:	9305      	str	r3, [sp, #20]
	tmp[6] = product[15];
    481c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    481e:	4405      	add	r5, r0
	tmp[7] = 0;
    4820:	e9cd 3706 	strd	r3, r7, [sp, #24]
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    4824:	466a      	mov	r2, sp
    4826:	2308      	movs	r3, #8
    4828:	4669      	mov	r1, sp
    482a:	4668      	mov	r0, sp
    482c:	f01b fbde 	bl	1ffec <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    4830:	4631      	mov	r1, r6
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    4832:	4405      	add	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    4834:	2308      	movs	r3, #8
    4836:	466a      	mov	r2, sp
    4838:	4630      	mov	r0, r6
    483a:	f01b fbd7 	bl	1ffec <uECC_vli_add>

	/* s3 */
	tmp[0] = product[8];
    483e:	6a23      	ldr	r3, [r4, #32]
    4840:	9300      	str	r3, [sp, #0]
	tmp[1] = product[9];
    4842:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4844:	9301      	str	r3, [sp, #4]
	tmp[2] = product[10];
    4846:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4848:	9302      	str	r3, [sp, #8]
	tmp[3] = tmp[4] = tmp[5] = 0;
	tmp[6] = product[14];
    484a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    484c:	9306      	str	r3, [sp, #24]
	tmp[7] = product[15];
    484e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    4850:	9307      	str	r3, [sp, #28]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    4852:	4405      	add	r5, r0
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    4854:	2308      	movs	r3, #8
    4856:	466a      	mov	r2, sp
    4858:	4630      	mov	r0, r6
	tmp[3] = tmp[4] = tmp[5] = 0;
    485a:	e9cd 7704 	strd	r7, r7, [sp, #16]
    485e:	9703      	str	r7, [sp, #12]
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    4860:	f01b fbc4 	bl	1ffec <uECC_vli_add>

	/* s4 */
	tmp[0] = product[9];
    4864:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4866:	9300      	str	r3, [sp, #0]
	tmp[1] = product[10];
    4868:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[2] = product[11];
	tmp[3] = product[13];
	tmp[4] = product[14];
    486a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
	tmp[1] = product[10];
    486c:	9301      	str	r3, [sp, #4]
	tmp[2] = product[11];
    486e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    4870:	9302      	str	r3, [sp, #8]
	tmp[4] = product[14];
    4872:	9204      	str	r2, [sp, #16]
	tmp[3] = product[13];
    4874:	6b63      	ldr	r3, [r4, #52]	; 0x34
	tmp[5] = product[15];
    4876:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	tmp[3] = product[13];
    4878:	9303      	str	r3, [sp, #12]
	tmp[6] = product[13];
    487a:	e9cd 2305 	strd	r2, r3, [sp, #20]
	tmp[7] = product[8];
    487e:	6a23      	ldr	r3, [r4, #32]
    4880:	9307      	str	r3, [sp, #28]
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    4882:	4405      	add	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    4884:	2308      	movs	r3, #8
    4886:	466a      	mov	r2, sp
    4888:	4630      	mov	r0, r6
    488a:	f01b fbaf 	bl	1ffec <uECC_vli_add>

	/* d1 */
	tmp[0] = product[11];
    488e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    4890:	9300      	str	r3, [sp, #0]
	tmp[1] = product[12];
    4892:	6b23      	ldr	r3, [r4, #48]	; 0x30
    4894:	9301      	str	r3, [sp, #4]
	tmp[2] = product[13];
    4896:	6b63      	ldr	r3, [r4, #52]	; 0x34
    4898:	9302      	str	r3, [sp, #8]
	tmp[3] = tmp[4] = tmp[5] = 0;
	tmp[6] = product[8];
    489a:	6a23      	ldr	r3, [r4, #32]
    489c:	9306      	str	r3, [sp, #24]
	tmp[7] = product[10];
    489e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    48a0:	9307      	str	r3, [sp, #28]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    48a2:	4405      	add	r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    48a4:	2308      	movs	r3, #8
    48a6:	466a      	mov	r2, sp
    48a8:	4630      	mov	r0, r6
	tmp[3] = tmp[4] = tmp[5] = 0;
    48aa:	e9cd 7704 	strd	r7, r7, [sp, #16]
    48ae:	9703      	str	r7, [sp, #12]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    48b0:	f01b fccd 	bl	2024e <uECC_vli_sub>

	/* d2 */
	tmp[0] = product[12];
    48b4:	6b23      	ldr	r3, [r4, #48]	; 0x30
    48b6:	9300      	str	r3, [sp, #0]
	tmp[1] = product[13];
    48b8:	6b63      	ldr	r3, [r4, #52]	; 0x34
    48ba:	9301      	str	r3, [sp, #4]
	tmp[2] = product[14];
    48bc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    48be:	9302      	str	r3, [sp, #8]
	tmp[3] = product[15];
    48c0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    48c2:	9303      	str	r3, [sp, #12]
	tmp[4] = tmp[5] = 0;
	tmp[6] = product[9];
    48c4:	6a63      	ldr	r3, [r4, #36]	; 0x24
    48c6:	9306      	str	r3, [sp, #24]
	tmp[7] = product[11];
    48c8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    48ca:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    48cc:	1a2d      	subs	r5, r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    48ce:	2308      	movs	r3, #8
    48d0:	466a      	mov	r2, sp
    48d2:	4630      	mov	r0, r6
	tmp[4] = tmp[5] = 0;
    48d4:	e9cd 7704 	strd	r7, r7, [sp, #16]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    48d8:	f01b fcb9 	bl	2024e <uECC_vli_sub>

	/* d3 */
	tmp[0] = product[13];
    48dc:	6b63      	ldr	r3, [r4, #52]	; 0x34
    48de:	9300      	str	r3, [sp, #0]
	tmp[1] = product[14];
    48e0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    48e2:	9301      	str	r3, [sp, #4]
	tmp[2] = product[15];
    48e4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    48e6:	9302      	str	r3, [sp, #8]
	tmp[3] = product[8];
    48e8:	6a23      	ldr	r3, [r4, #32]
    48ea:	9303      	str	r3, [sp, #12]
	tmp[4] = product[9];
    48ec:	6a63      	ldr	r3, [r4, #36]	; 0x24
    48ee:	9304      	str	r3, [sp, #16]
	tmp[5] = product[10];
    48f0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[6] = 0;
    48f2:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[12];
    48f6:	6b23      	ldr	r3, [r4, #48]	; 0x30
    48f8:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    48fa:	1a2d      	subs	r5, r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    48fc:	2308      	movs	r3, #8
    48fe:	466a      	mov	r2, sp
    4900:	4630      	mov	r0, r6
    4902:	f01b fca4 	bl	2024e <uECC_vli_sub>

	/* d4 */
	tmp[0] = product[14];
    4906:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    4908:	9300      	str	r3, [sp, #0]
	tmp[1] = product[15];
    490a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	tmp[2] = 0;
    490c:	e9cd 3701 	strd	r3, r7, [sp, #4]
	tmp[3] = product[9];
    4910:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4912:	9303      	str	r3, [sp, #12]
	tmp[4] = product[10];
    4914:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4916:	9304      	str	r3, [sp, #16]
	tmp[5] = product[11];
    4918:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	tmp[6] = 0;
    491a:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[13];
    491e:	6b63      	ldr	r3, [r4, #52]	; 0x34
    4920:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    4922:	1a2d      	subs	r5, r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    4924:	2308      	movs	r3, #8
    4926:	466a      	mov	r2, sp
    4928:	4630      	mov	r0, r6
    492a:	f01b fc90 	bl	2024e <uECC_vli_sub>

	if (carry < 0) {
    492e:	1a2d      	subs	r5, r5, r0
		do {
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
    4930:	4c0d      	ldr	r4, [pc, #52]	; (4968 <vli_mmod_fast_secp256r1+0x19c>)
	if (carry < 0) {
    4932:	d40f      	bmi.n	4954 <vli_mmod_fast_secp256r1+0x188>
		}
		while (carry < 0);
	} else  {
		while (carry || 
    4934:	b935      	cbnz	r5, 4944 <vli_mmod_fast_secp256r1+0x178>
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
    4936:	2208      	movs	r2, #8
    4938:	4631      	mov	r1, r6
    493a:	4620      	mov	r0, r4
    493c:	f01b fc5d 	bl	201fa <uECC_vli_cmp_unsafe>
		while (carry || 
    4940:	2801      	cmp	r0, #1
    4942:	d00f      	beq.n	4964 <vli_mmod_fast_secp256r1+0x198>
			carry -= uECC_vli_sub(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
    4944:	2308      	movs	r3, #8
    4946:	4622      	mov	r2, r4
    4948:	4631      	mov	r1, r6
    494a:	4630      	mov	r0, r6
    494c:	f01b fc7f 	bl	2024e <uECC_vli_sub>
    4950:	1a2d      	subs	r5, r5, r0
    4952:	e7ef      	b.n	4934 <vli_mmod_fast_secp256r1+0x168>
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
    4954:	2308      	movs	r3, #8
    4956:	4622      	mov	r2, r4
    4958:	4631      	mov	r1, r6
    495a:	4630      	mov	r0, r6
    495c:	f01b fb46 	bl	1ffec <uECC_vli_add>
		while (carry < 0);
    4960:	182d      	adds	r5, r5, r0
    4962:	d4f7      	bmi.n	4954 <vli_mmod_fast_secp256r1+0x188>
		}
	}
}
    4964:	b009      	add	sp, #36	; 0x24
    4966:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4968:	00028a04 	.word	0x00028a04

0000496c <tc_aes128_set_encrypt_key>:

#define subbyte(a, o)(sbox[((a) >> (o))&0xff] << (o))
#define subword(a)(subbyte(a, 24)|subbyte(a, 16)|subbyte(a, 8)|subbyte(a, 0))

int tc_aes128_set_encrypt_key(TCAesKeySched_t s, const uint8_t *k)
{
    496c:	b5f0      	push	{r4, r5, r6, r7, lr}
	const unsigned int rconst[11] = {
    496e:	4e28      	ldr	r6, [pc, #160]	; (4a10 <tc_aes128_set_encrypt_key+0xa4>)
{
    4970:	4607      	mov	r7, r0
    4972:	460c      	mov	r4, r1
	const unsigned int rconst[11] = {
    4974:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
{
    4976:	b08d      	sub	sp, #52	; 0x34
	const unsigned int rconst[11] = {
    4978:	ad01      	add	r5, sp, #4
    497a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    497c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    497e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    4980:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
    4984:	e885 0007 	stmia.w	r5, {r0, r1, r2}
		0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000
	};
	unsigned int i;
	unsigned int t;

	if (s == (TCAesKeySched_t) 0) {
    4988:	2f00      	cmp	r7, #0
    498a:	d03c      	beq.n	4a06 <tc_aes128_set_encrypt_key+0x9a>
		return TC_CRYPTO_FAIL;
	} else if (k == (const uint8_t *) 0) {
    498c:	2c00      	cmp	r4, #0
    498e:	d03c      	beq.n	4a0a <tc_aes128_set_encrypt_key+0x9e>
    4990:	1f38      	subs	r0, r7, #4
    4992:	4621      	mov	r1, r4
    4994:	4602      	mov	r2, r0
    4996:	3410      	adds	r4, #16
		return TC_CRYPTO_FAIL;
	}

	for (i = 0; i < Nk; ++i) {
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
    4998:	784b      	ldrb	r3, [r1, #1]
    499a:	780d      	ldrb	r5, [r1, #0]
    499c:	041b      	lsls	r3, r3, #16
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
    499e:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
    49a2:	78cd      	ldrb	r5, [r1, #3]
    49a4:	432b      	orrs	r3, r5
    49a6:	788d      	ldrb	r5, [r1, #2]
    49a8:	3104      	adds	r1, #4
    49aa:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
	for (i = 0; i < Nk; ++i) {
    49ae:	428c      	cmp	r4, r1
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
    49b0:	f842 3f04 	str.w	r3, [r2, #4]!
	for (i = 0; i < Nk; ++i) {
    49b4:	d1f0      	bne.n	4998 <tc_aes128_set_encrypt_key+0x2c>
	}

	for (; i < (Nb * (Nr + 1)); ++i) {
		t = s->words[i-1];
		if ((i % Nk) == 0) {
			t = subword(rotword(t)) ^ rconst[i/Nk];
    49b6:	4c17      	ldr	r4, [pc, #92]	; (4a14 <tc_aes128_set_encrypt_key+0xa8>)
    49b8:	2104      	movs	r1, #4
		if ((i % Nk) == 0) {
    49ba:	078a      	lsls	r2, r1, #30
		t = s->words[i-1];
    49bc:	6903      	ldr	r3, [r0, #16]
		if ((i % Nk) == 0) {
    49be:	d118      	bne.n	49f2 <tc_aes128_set_encrypt_key+0x86>
	return (((a) >> 24)|((a) << 8));
    49c0:	ea4f 6333 	mov.w	r3, r3, ror #24
			t = subword(rotword(t)) ^ rconst[i/Nk];
    49c4:	0e1a      	lsrs	r2, r3, #24
    49c6:	5ca5      	ldrb	r5, [r4, r2]
    49c8:	b2da      	uxtb	r2, r3
    49ca:	5ca2      	ldrb	r2, [r4, r2]
    49cc:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
    49d0:	f3c3 4507 	ubfx	r5, r3, #16, #8
    49d4:	f3c3 2307 	ubfx	r3, r3, #8, #8
    49d8:	5d65      	ldrb	r5, [r4, r5]
    49da:	5ce3      	ldrb	r3, [r4, r3]
    49dc:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    49e0:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
    49e4:	ad0c      	add	r5, sp, #48	; 0x30
    49e6:	f021 0303 	bic.w	r3, r1, #3
    49ea:	442b      	add	r3, r5
    49ec:	f853 3c2c 	ldr.w	r3, [r3, #-44]
    49f0:	4053      	eors	r3, r2
		}
		s->words[i] = s->words[i-Nk] ^ t;
    49f2:	f850 2f04 	ldr.w	r2, [r0, #4]!
	for (; i < (Nb * (Nr + 1)); ++i) {
    49f6:	3101      	adds	r1, #1
		s->words[i] = s->words[i-Nk] ^ t;
    49f8:	4053      	eors	r3, r2
	for (; i < (Nb * (Nr + 1)); ++i) {
    49fa:	292c      	cmp	r1, #44	; 0x2c
		s->words[i] = s->words[i-Nk] ^ t;
    49fc:	6103      	str	r3, [r0, #16]
	for (; i < (Nb * (Nr + 1)); ++i) {
    49fe:	d1dc      	bne.n	49ba <tc_aes128_set_encrypt_key+0x4e>
	}

	return TC_CRYPTO_SUCCESS;
    4a00:	2001      	movs	r0, #1
}
    4a02:	b00d      	add	sp, #52	; 0x34
    4a04:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return TC_CRYPTO_FAIL;
    4a06:	4638      	mov	r0, r7
    4a08:	e7fb      	b.n	4a02 <tc_aes128_set_encrypt_key+0x96>
    4a0a:	4620      	mov	r0, r4
    4a0c:	e7f9      	b.n	4a02 <tc_aes128_set_encrypt_key+0x96>
    4a0e:	bf00      	nop
    4a10:	000286d0 	.word	0x000286d0
    4a14:	00061f08 	.word	0x00061f08

00004a18 <tc_aes_encrypt>:
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
	(void) _copy(s, sizeof(t), t, sizeof(t));
}

int tc_aes_encrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
    4a18:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    4a1c:	4615      	mov	r5, r2
    4a1e:	b089      	sub	sp, #36	; 0x24
	uint8_t state[Nk*Nb];
	unsigned int i;

	if (out == (uint8_t *) 0) {
    4a20:	4607      	mov	r7, r0
    4a22:	2800      	cmp	r0, #0
    4a24:	d059      	beq.n	4ada <tc_aes_encrypt+0xc2>
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
    4a26:	2900      	cmp	r1, #0
    4a28:	d05a      	beq.n	4ae0 <tc_aes_encrypt+0xc8>
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
    4a2a:	2a00      	cmp	r2, #0
    4a2c:	d05a      	beq.n	4ae4 <tc_aes_encrypt+0xcc>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
    4a2e:	2310      	movs	r3, #16
    4a30:	460a      	mov	r2, r1
    4a32:	4668      	mov	r0, sp
    4a34:	4619      	mov	r1, r3
    4a36:	f01b fa14 	bl	1fe62 <_copy>
	add_round_key(state, s->words);
    4a3a:	4629      	mov	r1, r5
    4a3c:	4668      	mov	r0, sp
		s[i] = sbox[s[i]];
    4a3e:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 4ae8 <tc_aes_encrypt+0xd0>
	add_round_key(state, s->words);
    4a42:	f01c f91b 	bl	20c7c <add_round_key>

	for (i = 0; i < (Nr - 1); ++i) {
    4a46:	f105 0610 	add.w	r6, r5, #16
    4a4a:	46c8      	mov	r8, r9
    4a4c:	35a0      	adds	r5, #160	; 0xa0
    4a4e:	466c      	mov	r4, sp
{
    4a50:	466a      	mov	r2, sp
    4a52:	2310      	movs	r3, #16
		s[i] = sbox[s[i]];
    4a54:	7811      	ldrb	r1, [r2, #0]
	for (i = 0; i < (Nb * Nk); ++i) {
    4a56:	3b01      	subs	r3, #1
		s[i] = sbox[s[i]];
    4a58:	f819 1001 	ldrb.w	r1, [r9, r1]
    4a5c:	f802 1b01 	strb.w	r1, [r2], #1
	for (i = 0; i < (Nb * Nk); ++i) {
    4a60:	d1f8      	bne.n	4a54 <tc_aes_encrypt+0x3c>
		sub_bytes(state);
		shift_rows(state);
    4a62:	4668      	mov	r0, sp
    4a64:	f01c f94f 	bl	20d06 <shift_rows>
	mult_row_column(t, s);
    4a68:	4669      	mov	r1, sp
    4a6a:	a804      	add	r0, sp, #16
    4a6c:	f01c f984 	bl	20d78 <mult_row_column>
	mult_row_column(&t[Nb], s+Nb);
    4a70:	a901      	add	r1, sp, #4
    4a72:	a805      	add	r0, sp, #20
    4a74:	f01c f980 	bl	20d78 <mult_row_column>
	mult_row_column(&t[2 * Nb], s + (2 * Nb));
    4a78:	a902      	add	r1, sp, #8
    4a7a:	a806      	add	r0, sp, #24
    4a7c:	f01c f97c 	bl	20d78 <mult_row_column>
	mult_row_column(&t[3 * Nb], s + (3 * Nb));
    4a80:	a903      	add	r1, sp, #12
    4a82:	a807      	add	r0, sp, #28
    4a84:	f01c f978 	bl	20d78 <mult_row_column>
	(void) _copy(s, sizeof(t), t, sizeof(t));
    4a88:	2310      	movs	r3, #16
    4a8a:	4619      	mov	r1, r3
    4a8c:	eb0d 0203 	add.w	r2, sp, r3
    4a90:	4668      	mov	r0, sp
    4a92:	f01b f9e6 	bl	1fe62 <_copy>
		mix_columns(state);
		add_round_key(state, s->words + Nb*(i+1));
    4a96:	4631      	mov	r1, r6
    4a98:	4668      	mov	r0, sp
    4a9a:	3610      	adds	r6, #16
    4a9c:	f01c f8ee 	bl	20c7c <add_round_key>
	for (i = 0; i < (Nr - 1); ++i) {
    4aa0:	42ae      	cmp	r6, r5
    4aa2:	d1d4      	bne.n	4a4e <tc_aes_encrypt+0x36>
    4aa4:	2610      	movs	r6, #16
		s[i] = sbox[s[i]];
    4aa6:	7823      	ldrb	r3, [r4, #0]
	for (i = 0; i < (Nb * Nk); ++i) {
    4aa8:	3e01      	subs	r6, #1
		s[i] = sbox[s[i]];
    4aaa:	f818 3003 	ldrb.w	r3, [r8, r3]
    4aae:	f804 3b01 	strb.w	r3, [r4], #1
	for (i = 0; i < (Nb * Nk); ++i) {
    4ab2:	d1f8      	bne.n	4aa6 <tc_aes_encrypt+0x8e>
	}

	sub_bytes(state);
	shift_rows(state);
    4ab4:	4668      	mov	r0, sp
    4ab6:	f01c f926 	bl	20d06 <shift_rows>
	add_round_key(state, s->words + Nb*(i+1));
    4aba:	4629      	mov	r1, r5
    4abc:	4668      	mov	r0, sp
    4abe:	f01c f8dd 	bl	20c7c <add_round_key>

	(void)_copy(out, sizeof(state), state, sizeof(state));
    4ac2:	2310      	movs	r3, #16
    4ac4:	4619      	mov	r1, r3
    4ac6:	466a      	mov	r2, sp
    4ac8:	4638      	mov	r0, r7
    4aca:	f01b f9ca 	bl	1fe62 <_copy>

	/* zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
    4ace:	4668      	mov	r0, sp
    4ad0:	2210      	movs	r2, #16
    4ad2:	4631      	mov	r1, r6
    4ad4:	f01b f9d2 	bl	1fe7c <_set>

	return TC_CRYPTO_SUCCESS;
    4ad8:	2001      	movs	r0, #1
}
    4ada:	b009      	add	sp, #36	; 0x24
    4adc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return TC_CRYPTO_FAIL;
    4ae0:	4608      	mov	r0, r1
    4ae2:	e7fa      	b.n	4ada <tc_aes_encrypt+0xc2>
    4ae4:	4610      	mov	r0, r2
    4ae6:	e7f8      	b.n	4ada <tc_aes_encrypt+0xc2>
    4ae8:	00061f08 	.word	0x00061f08

00004aec <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
    4aec:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
    4aee:	2200      	movs	r2, #0
{
    4af0:	b087      	sub	sp, #28
		k_timer_init(&log_process_thread_timer,
    4af2:	490d      	ldr	r1, [pc, #52]	; (4b28 <enable_logger+0x3c>)
    4af4:	480d      	ldr	r0, [pc, #52]	; (4b2c <enable_logger+0x40>)
    4af6:	f023 fa75 	bl	27fe4 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    4afa:	4d0d      	ldr	r5, [pc, #52]	; (4b30 <enable_logger+0x44>)
    4afc:	490d      	ldr	r1, [pc, #52]	; (4b34 <enable_logger+0x48>)
    4afe:	2400      	movs	r4, #0
    4b00:	230e      	movs	r3, #14
    4b02:	e9cd 4302 	strd	r4, r3, [sp, #8]
    4b06:	e9cd 4404 	strd	r4, r4, [sp, #16]
    4b0a:	e9cd 4400 	strd	r4, r4, [sp]
    4b0e:	4b0a      	ldr	r3, [pc, #40]	; (4b38 <enable_logger+0x4c>)
    4b10:	f44f 7240 	mov.w	r2, #768	; 0x300
    4b14:	4628      	mov	r0, r5
    4b16:	f01a f9d5 	bl	1eec4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    4b1a:	4908      	ldr	r1, [pc, #32]	; (4b3c <enable_logger+0x50>)
    4b1c:	4628      	mov	r0, r5
    4b1e:	f023 f97f 	bl	27e20 <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
    4b22:	4620      	mov	r0, r4
    4b24:	b007      	add	sp, #28
    4b26:	bd30      	pop	{r4, r5, pc}
    4b28:	00004b41 	.word	0x00004b41
    4b2c:	2000007c 	.word	0x2000007c
    4b30:	200000c4 	.word	0x200000c4
    4b34:	2000ad58 	.word	0x2000ad58
    4b38:	00004f95 	.word	0x00004f95
    4b3c:	00062011 	.word	0x00062011

00004b40 <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    4b40:	4801      	ldr	r0, [pc, #4]	; (4b48 <log_process_thread_timer_expiry_fn+0x8>)
    4b42:	f01a b91b 	b.w	1ed7c <z_impl_k_sem_give>
    4b46:	bf00      	nop
    4b48:	2000ef2c 	.word	0x2000ef2c

00004b4c <z_log_get_s_mask>:
{
    4b4c:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32_t mask = 0;
    4b4e:	2300      	movs	r3, #0
		} else if (arm && isalpha((int)curr)) {
    4b50:	4e0f      	ldr	r6, [pc, #60]	; (4b90 <z_log_get_s_mask+0x44>)
	u32_t arg = 0;
    4b52:	461a      	mov	r2, r3
	bool arm = false;
    4b54:	461c      	mov	r4, r3
				mask |= BIT(arg);
    4b56:	2701      	movs	r7, #1
	while ((curr = *str++) && arg < nargs) {
    4b58:	f810 5b01 	ldrb.w	r5, [r0], #1
    4b5c:	b10d      	cbz	r5, 4b62 <z_log_get_s_mask+0x16>
    4b5e:	428a      	cmp	r2, r1
    4b60:	d301      	bcc.n	4b66 <z_log_get_s_mask+0x1a>
}
    4b62:	4618      	mov	r0, r3
    4b64:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (curr == '%') {
    4b66:	2d25      	cmp	r5, #37	; 0x25
    4b68:	d102      	bne.n	4b70 <z_log_get_s_mask+0x24>
			arm = !arm;
    4b6a:	f084 0401 	eor.w	r4, r4, #1
    4b6e:	e7f3      	b.n	4b58 <z_log_get_s_mask+0xc>
		} else if (arm && isalpha((int)curr)) {
    4b70:	2c00      	cmp	r4, #0
    4b72:	d0f1      	beq.n	4b58 <z_log_get_s_mask+0xc>
    4b74:	f815 c006 	ldrb.w	ip, [r5, r6]
    4b78:	f01c 0f03 	tst.w	ip, #3
    4b7c:	d0ec      	beq.n	4b58 <z_log_get_s_mask+0xc>
			if (curr == 's') {
    4b7e:	2d73      	cmp	r5, #115	; 0x73
				mask |= BIT(arg);
    4b80:	bf04      	itt	eq
    4b82:	fa07 f402 	lsleq.w	r4, r7, r2
    4b86:	4323      	orreq	r3, r4
			arg++;
    4b88:	3201      	adds	r2, #1
			arm = false;
    4b8a:	2400      	movs	r4, #0
    4b8c:	e7e4      	b.n	4b58 <z_log_get_s_mask+0xc>
    4b8e:	bf00      	nop
    4b90:	00028779 	.word	0x00028779

00004b94 <log_core_init>:
{
    4b94:	b508      	push	{r3, lr}
		log_msg_pool_init();
    4b96:	f000 fa5d 	bl	5054 <log_msg_pool_init>
		log_list_init(&list);
    4b9a:	4809      	ldr	r0, [pc, #36]	; (4bc0 <log_core_init+0x2c>)
    4b9c:	f01c fa2a 	bl	20ff4 <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
    4ba0:	2304      	movs	r3, #4
    4ba2:	2228      	movs	r2, #40	; 0x28
    4ba4:	4807      	ldr	r0, [pc, #28]	; (4bc4 <log_core_init+0x30>)
    4ba6:	4908      	ldr	r1, [pc, #32]	; (4bc8 <log_core_init+0x34>)
    4ba8:	f022 ff16 	bl	279d8 <k_mem_slab_init>
		timestamp_func = k_cycle_get_32_wrapper;
    4bac:	4b07      	ldr	r3, [pc, #28]	; (4bcc <log_core_init+0x38>)
    4bae:	4a08      	ldr	r2, [pc, #32]	; (4bd0 <log_core_init+0x3c>)
    4bb0:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
    4bb2:	f44f 4000 	mov.w	r0, #32768	; 0x8000
}
    4bb6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	log_output_timestamp_freq_set(freq);
    4bba:	f000 bc8f 	b.w	54dc <log_output_timestamp_freq_set>
    4bbe:	bf00      	nop
    4bc0:	20000074 	.word	0x20000074
    4bc4:	200000a8 	.word	0x200000a8
    4bc8:	2000d6c0 	.word	0x2000d6c0
    4bcc:	2000e6dc 	.word	0x2000e6dc
    4bd0:	00021033 	.word	0x00021033

00004bd4 <dropped_notify>:
{
    4bd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    4bd6:	4b0f      	ldr	r3, [pc, #60]	; (4c14 <dropped_notify+0x40>)
    4bd8:	f3bf 8f5b 	dmb	ish
    4bdc:	2500      	movs	r5, #0
    4bde:	e853 7f00 	ldrex	r7, [r3]
    4be2:	e843 5200 	strex	r2, r5, [r3]
    4be6:	2a00      	cmp	r2, #0
    4be8:	d1f9      	bne.n	4bde <dropped_notify+0xa>
    4bea:	f3bf 8f5b 	dmb	ish
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
    4bee:	4c0a      	ldr	r4, [pc, #40]	; (4c18 <dropped_notify+0x44>)
    4bf0:	4e0a      	ldr	r6, [pc, #40]	; (4c1c <dropped_notify+0x48>)
    4bf2:	1b36      	subs	r6, r6, r4
    4bf4:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
    4bf6:	42b5      	cmp	r5, r6
    4bf8:	db00      	blt.n	4bfc <dropped_notify+0x28>
}
    4bfa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
    4bfc:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
    4bfe:	795b      	ldrb	r3, [r3, #5]
    4c00:	b12b      	cbz	r3, 4c0e <dropped_notify+0x3a>
	if (backend->api->dropped != NULL) {
    4c02:	6823      	ldr	r3, [r4, #0]
    4c04:	68db      	ldr	r3, [r3, #12]
    4c06:	b113      	cbz	r3, 4c0e <dropped_notify+0x3a>
		backend->api->dropped(backend, cnt);
    4c08:	4639      	mov	r1, r7
    4c0a:	4620      	mov	r0, r4
    4c0c:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
    4c0e:	3501      	adds	r5, #1
    4c10:	3410      	adds	r4, #16
    4c12:	e7f0      	b.n	4bf6 <dropped_notify+0x22>
    4c14:	2000006c 	.word	0x2000006c
    4c18:	000286b8 	.word	0x000286b8
    4c1c:	000286c8 	.word	0x000286c8

00004c20 <log_dropped>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    4c20:	4b06      	ldr	r3, [pc, #24]	; (4c3c <log_dropped+0x1c>)
    4c22:	f3bf 8f5b 	dmb	ish
    4c26:	e853 2f00 	ldrex	r2, [r3]
    4c2a:	3201      	adds	r2, #1
    4c2c:	e843 2100 	strex	r1, r2, [r3]
    4c30:	2900      	cmp	r1, #0
    4c32:	d1f8      	bne.n	4c26 <log_dropped+0x6>
    4c34:	f3bf 8f5b 	dmb	ish
}
    4c38:	4770      	bx	lr
    4c3a:	bf00      	nop
    4c3c:	2000006c 	.word	0x2000006c

00004c40 <log_source_name_get>:
    4c40:	4a04      	ldr	r2, [pc, #16]	; (4c54 <log_source_name_get+0x14>)
    4c42:	4b05      	ldr	r3, [pc, #20]	; (4c58 <log_source_name_get+0x18>)
    4c44:	1a9b      	subs	r3, r3, r2
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
    4c46:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
    4c4a:	bf34      	ite	cc
    4c4c:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
    4c50:	2000      	movcs	r0, #0
}
    4c52:	4770      	bx	lr
    4c54:	00028540 	.word	0x00028540
    4c58:	000286b8 	.word	0x000286b8

00004c5c <log_backend_enable>:
	id += backend - log_backend_get(0);
    4c5c:	4b09      	ldr	r3, [pc, #36]	; (4c84 <log_backend_enable+0x28>)
	log_backend_id_set(backend, id);
    4c5e:	6842      	ldr	r2, [r0, #4]
	id += backend - log_backend_get(0);
    4c60:	1ac3      	subs	r3, r0, r3
    4c62:	111b      	asrs	r3, r3, #4
    4c64:	3301      	adds	r3, #1
{
    4c66:	b510      	push	{r4, lr}
	log_backend_id_set(backend, id);
    4c68:	7113      	strb	r3, [r2, #4]
	log_backend_activate(backend, ctx);
    4c6a:	6843      	ldr	r3, [r0, #4]
	if (!backend_attached) {
    4c6c:	4c06      	ldr	r4, [pc, #24]	; (4c88 <log_backend_enable+0x2c>)
	backend->cb->ctx = ctx;
    4c6e:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
    4c70:	2201      	movs	r2, #1
    4c72:	715a      	strb	r2, [r3, #5]
    4c74:	7822      	ldrb	r2, [r4, #0]
    4c76:	b912      	cbnz	r2, 4c7e <log_backend_enable+0x22>
    4c78:	4804      	ldr	r0, [pc, #16]	; (4c8c <log_backend_enable+0x30>)
    4c7a:	f01a f87f 	bl	1ed7c <z_impl_k_sem_give>
	backend_attached = true;
    4c7e:	2301      	movs	r3, #1
    4c80:	7023      	strb	r3, [r4, #0]
}
    4c82:	bd10      	pop	{r4, pc}
    4c84:	000286b8 	.word	0x000286b8
    4c88:	20006153 	.word	0x20006153
    4c8c:	2000ef2c 	.word	0x2000ef2c

00004c90 <log_init>:
{
    4c90:	b570      	push	{r4, r5, r6, lr}
	return __log_backends_end - __log_backends_start;
    4c92:	4b15      	ldr	r3, [pc, #84]	; (4ce8 <log_init+0x58>)
    4c94:	4c15      	ldr	r4, [pc, #84]	; (4cec <log_init+0x5c>)
    4c96:	1b1b      	subs	r3, r3, r4
	assert(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
    4c98:	2b90      	cmp	r3, #144	; 0x90
    4c9a:	dd06      	ble.n	4caa <log_init+0x1a>
    4c9c:	4b14      	ldr	r3, [pc, #80]	; (4cf0 <log_init+0x60>)
    4c9e:	4a15      	ldr	r2, [pc, #84]	; (4cf4 <log_init+0x64>)
    4ca0:	4815      	ldr	r0, [pc, #84]	; (4cf8 <log_init+0x68>)
    4ca2:	f240 11ed 	movw	r1, #493	; 0x1ed
    4ca6:	f7fb fa85 	bl	1b4 <__assert_func>
    4caa:	4a14      	ldr	r2, [pc, #80]	; (4cfc <log_init+0x6c>)
    4cac:	f3bf 8f5b 	dmb	ish
    4cb0:	e852 6f00 	ldrex	r6, [r2]
    4cb4:	1c71      	adds	r1, r6, #1
    4cb6:	e842 1000 	strex	r0, r1, [r2]
    4cba:	2800      	cmp	r0, #0
    4cbc:	d1f8      	bne.n	4cb0 <log_init+0x20>
    4cbe:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&initialized) != 0) {
    4cc2:	b916      	cbnz	r6, 4cca <log_init+0x3a>
    4cc4:	111d      	asrs	r5, r3, #4
	for (i = 0; i < log_backend_count_get(); i++) {
    4cc6:	42ae      	cmp	r6, r5
    4cc8:	db00      	blt.n	4ccc <log_init+0x3c>
}
    4cca:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
    4ccc:	7b23      	ldrb	r3, [r4, #12]
    4cce:	b143      	cbz	r3, 4ce2 <log_init+0x52>
			if (backend->api->init != NULL) {
    4cd0:	6823      	ldr	r3, [r4, #0]
    4cd2:	695b      	ldr	r3, [r3, #20]
    4cd4:	b103      	cbz	r3, 4cd8 <log_init+0x48>
				backend->api->init();
    4cd6:	4798      	blx	r3
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
    4cd8:	2204      	movs	r2, #4
    4cda:	2100      	movs	r1, #0
    4cdc:	4620      	mov	r0, r4
    4cde:	f7ff ffbd 	bl	4c5c <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
    4ce2:	3601      	adds	r6, #1
    4ce4:	3410      	adds	r4, #16
    4ce6:	e7ee      	b.n	4cc6 <log_init+0x36>
    4ce8:	000286c8 	.word	0x000286c8
    4cec:	000286b8 	.word	0x000286b8
    4cf0:	00062019 	.word	0x00062019
    4cf4:	00062008 	.word	0x00062008
    4cf8:	00062066 	.word	0x00062066
    4cfc:	20000070 	.word	0x20000070

00004d00 <log_strdup>:
	return (((const char *)addr >= (const char *)RO_START) &&
    4d00:	4b16      	ldr	r3, [pc, #88]	; (4d5c <log_strdup+0x5c>)
    4d02:	4298      	cmp	r0, r3
{
    4d04:	b573      	push	{r0, r1, r4, r5, r6, lr}
    4d06:	4604      	mov	r4, r0
	return (((const char *)addr >= (const char *)RO_START) &&
    4d08:	d302      	bcc.n	4d10 <log_strdup+0x10>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
    4d0a:	4b15      	ldr	r3, [pc, #84]	; (4d60 <log_strdup+0x60>)
    4d0c:	4298      	cmp	r0, r3
    4d0e:	d31f      	bcc.n	4d50 <log_strdup+0x50>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
    4d10:	2200      	movs	r2, #0
    4d12:	a901      	add	r1, sp, #4
    4d14:	4813      	ldr	r0, [pc, #76]	; (4d64 <log_strdup+0x64>)
    4d16:	f019 fb27 	bl	1e368 <k_mem_slab_alloc>
	if (err != 0) {
    4d1a:	4606      	mov	r6, r0
    4d1c:	b9d8      	cbnz	r0, 4d56 <log_strdup+0x56>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    4d1e:	2201      	movs	r2, #1
    4d20:	9b01      	ldr	r3, [sp, #4]
    4d22:	f3bf 8f5b 	dmb	ish
    4d26:	e853 1f00 	ldrex	r1, [r3]
    4d2a:	e843 2000 	strex	r0, r2, [r3]
    4d2e:	2800      	cmp	r0, #0
    4d30:	d1f9      	bne.n	4d26 <log_strdup+0x26>
    4d32:	f3bf 8f5b 	dmb	ish
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
    4d36:	9d01      	ldr	r5, [sp, #4]
    4d38:	1d2b      	adds	r3, r5, #4
#if __GNUC_PREREQ__(4,8) || defined(__clang__)
__ssp_bos_icheck3_restrict(stpncpy, char *, const char *)
#endif
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
__ssp_bos_icheck2_restrict(strcat, char *, const char *)
__ssp_bos_icheck3_restrict(strncpy, char *, const char *)
    4d3a:	221f      	movs	r2, #31
    4d3c:	4621      	mov	r1, r4
    4d3e:	4618      	mov	r0, r3
    4d40:	f7fc ffcc 	bl	1cdc <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
    4d44:	227e      	movs	r2, #126	; 0x7e
    4d46:	f885 2023 	strb.w	r2, [r5, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
    4d4a:	f885 6024 	strb.w	r6, [r5, #36]	; 0x24
	return dup->buf;
    4d4e:	4604      	mov	r4, r0
}
    4d50:	4620      	mov	r0, r4
    4d52:	b002      	add	sp, #8
    4d54:	bd70      	pop	{r4, r5, r6, pc}
		return (char *)log_strdup_fail_msg;
    4d56:	4c04      	ldr	r4, [pc, #16]	; (4d68 <log_strdup+0x68>)
    4d58:	e7fa      	b.n	4d50 <log_strdup+0x50>
    4d5a:	bf00      	nop
    4d5c:	00028254 	.word	0x00028254
    4d60:	0006d9ec 	.word	0x0006d9ec
    4d64:	200000a8 	.word	0x200000a8
    4d68:	0006204c 	.word	0x0006204c

00004d6c <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (u8_t *)buf);
    4d6c:	b148      	cbz	r0, 4d82 <log_is_strdup+0x16>
    4d6e:	4b05      	ldr	r3, [pc, #20]	; (4d84 <log_is_strdup+0x18>)
    4d70:	4298      	cmp	r0, r3
    4d72:	d305      	bcc.n	4d80 <log_is_strdup+0x14>
    4d74:	33a0      	adds	r3, #160	; 0xa0
    4d76:	4298      	cmp	r0, r3
    4d78:	bf2c      	ite	cs
    4d7a:	2000      	movcs	r0, #0
    4d7c:	2001      	movcc	r0, #1
    4d7e:	4770      	bx	lr
    4d80:	2000      	movs	r0, #0
}
    4d82:	4770      	bx	lr
    4d84:	2000d6c0 	.word	0x2000d6c0

00004d88 <z_impl_log_process>:
{
    4d88:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!backend_attached && !bypass) {
    4d8c:	4b46      	ldr	r3, [pc, #280]	; (4ea8 <z_impl_log_process+0x120>)
    4d8e:	781b      	ldrb	r3, [r3, #0]
{
    4d90:	4605      	mov	r5, r0
	if (!backend_attached && !bypass) {
    4d92:	b903      	cbnz	r3, 4d96 <z_impl_log_process+0xe>
    4d94:	b360      	cbz	r0, 4df0 <z_impl_log_process+0x68>
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
    4d96:	f04f 0320 	mov.w	r3, #32
    4d9a:	f3ef 8611 	mrs	r6, BASEPRI
    4d9e:	f383 8811 	msr	BASEPRI, r3
    4da2:	f3bf 8f6f 	isb	sy
	msg = log_list_head_get(&list);
    4da6:	4841      	ldr	r0, [pc, #260]	; (4eac <z_impl_log_process+0x124>)
    4da8:	f01c f934 	bl	21014 <log_list_head_get>
    4dac:	4604      	mov	r4, r0
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
    4dae:	f386 8811 	msr	BASEPRI, r6
    4db2:	f3bf 8f6f 	isb	sy
	if (msg != NULL) {
    4db6:	b178      	cbz	r0, 4dd8 <z_impl_log_process+0x50>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    4db8:	f3bf 8f5b 	dmb	ish
    4dbc:	4b3c      	ldr	r3, [pc, #240]	; (4eb0 <z_impl_log_process+0x128>)
    4dbe:	e853 2f00 	ldrex	r2, [r3]
    4dc2:	3a01      	subs	r2, #1
    4dc4:	e843 2100 	strex	r1, r2, [r3]
    4dc8:	2900      	cmp	r1, #0
    4dca:	d1f8      	bne.n	4dbe <z_impl_log_process+0x36>
    4dcc:	f3bf 8f5b 	dmb	ish
	if (!bypass) {
    4dd0:	b18d      	cbz	r5, 4df6 <z_impl_log_process+0x6e>
	log_msg_put(msg);
    4dd2:	4620      	mov	r0, r4
    4dd4:	f01c fa27 	bl	21226 <log_msg_put>
	if (!bypass && dropped_cnt) {
    4dd8:	b925      	cbnz	r5, 4de4 <z_impl_log_process+0x5c>
    4dda:	4b36      	ldr	r3, [pc, #216]	; (4eb4 <z_impl_log_process+0x12c>)
    4ddc:	681b      	ldr	r3, [r3, #0]
    4dde:	b10b      	cbz	r3, 4de4 <z_impl_log_process+0x5c>
		dropped_notify();
    4de0:	f7ff fef8 	bl	4bd4 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
    4de4:	4831      	ldr	r0, [pc, #196]	; (4eac <z_impl_log_process+0x124>)
    4de6:	f01c f913 	bl	21010 <log_list_head_peek>
    4dea:	1c05      	adds	r5, r0, #0
    4dec:	bf18      	it	ne
    4dee:	2501      	movne	r5, #1
}
    4df0:	4628      	mov	r0, r5
    4df2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    !panic_mode) {
    4df6:	4b30      	ldr	r3, [pc, #192]	; (4eb8 <z_impl_log_process+0x130>)
		if (IS_ENABLED(CONFIG_LOG_DETECT_MISSED_STRDUP) &&
    4df8:	781b      	ldrb	r3, [r3, #0]
    4dfa:	b9ab      	cbnz	r3, 4e28 <z_impl_log_process+0xa0>
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    4dfc:	7a23      	ldrb	r3, [r4, #8]
	if (!log_msg_is_std(msg)) {
    4dfe:	07db      	lsls	r3, r3, #31
    4e00:	d412      	bmi.n	4e28 <z_impl_log_process+0xa0>
	msg_str = log_msg_str_get(msg);
    4e02:	f01c fa23 	bl	2124c <log_msg_str_get>
    4e06:	4681      	mov	r9, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    4e08:	4620      	mov	r0, r4
    4e0a:	f01c f9ec 	bl	211e6 <log_msg_nargs_get>
    4e0e:	4601      	mov	r1, r0
    4e10:	4648      	mov	r0, r9
    4e12:	f7ff fe9b 	bl	4b4c <z_log_get_s_mask>
	return ((u8_t *)data - (u8_t *)__log_const_start)/
    4e16:	4b29      	ldr	r3, [pc, #164]	; (4ebc <z_impl_log_process+0x134>)
				LOG_ERR(ERR_MSG, idx, msg_str);
    4e18:	4a29      	ldr	r2, [pc, #164]	; (4ec0 <z_impl_log_process+0x138>)
    4e1a:	f8df b0bc 	ldr.w	fp, [pc, #188]	; 4ed8 <z_impl_log_process+0x150>
    4e1e:	1a9b      	subs	r3, r3, r2
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    4e20:	4607      	mov	r7, r0
				LOG_ERR(ERR_MSG, idx, msg_str);
    4e22:	f3c3 0ac9 	ubfx	sl, r3, #3, #10
	while (mask) {
    4e26:	b937      	cbnz	r7, 4e36 <z_impl_log_process+0xae>
    4e28:	4e26      	ldr	r6, [pc, #152]	; (4ec4 <z_impl_log_process+0x13c>)
    4e2a:	4f27      	ldr	r7, [pc, #156]	; (4ec8 <z_impl_log_process+0x140>)
    4e2c:	1bbf      	subs	r7, r7, r6
    4e2e:	113f      	asrs	r7, r7, #4
    4e30:	f04f 0800 	mov.w	r8, #0
    4e34:	e034      	b.n	4ea0 <z_impl_log_process+0x118>
		idx = 31 - __builtin_clz(mask);
    4e36:	fab7 f687 	clz	r6, r7
    4e3a:	f1c6 061f 	rsb	r6, r6, #31
		str = (const char *)log_msg_arg_get(msg, idx);
    4e3e:	4631      	mov	r1, r6
    4e40:	4620      	mov	r0, r4
    4e42:	f01c f9d3 	bl	211ec <log_msg_arg_get>
	return (((const char *)addr >= (const char *)RO_START) &&
    4e46:	4b21      	ldr	r3, [pc, #132]	; (4ecc <z_impl_log_process+0x144>)
    4e48:	4298      	cmp	r0, r3
		str = (const char *)log_msg_arg_get(msg, idx);
    4e4a:	4602      	mov	r2, r0
	return (((const char *)addr >= (const char *)RO_START) &&
    4e4c:	d302      	bcc.n	4e54 <z_impl_log_process+0xcc>
		if (!is_rodata(str) && !log_is_strdup(str) &&
    4e4e:	4b20      	ldr	r3, [pc, #128]	; (4ed0 <z_impl_log_process+0x148>)
    4e50:	4298      	cmp	r0, r3
    4e52:	d314      	bcc.n	4e7e <z_impl_log_process+0xf6>
    4e54:	4610      	mov	r0, r2
    4e56:	f7ff ff89 	bl	4d6c <log_is_strdup>
    4e5a:	b980      	cbnz	r0, 4e7e <z_impl_log_process+0xf6>
    4e5c:	4b1d      	ldr	r3, [pc, #116]	; (4ed4 <z_impl_log_process+0x14c>)
    4e5e:	429a      	cmp	r2, r3
    4e60:	d00d      	beq.n	4e7e <z_impl_log_process+0xf6>
				LOG_ERR(ERR_MSG, idx, msg_str);
    4e62:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
    4e66:	f043 0301 	orr.w	r3, r3, #1
    4e6a:	f363 0807 	bfi	r8, r3, #0, #8
    4e6e:	f36a 188f 	bfi	r8, sl, #6, #10
    4e72:	4643      	mov	r3, r8
    4e74:	464a      	mov	r2, r9
    4e76:	4631      	mov	r1, r6
    4e78:	4658      	mov	r0, fp
    4e7a:	f01c f8ff 	bl	2107c <log_2>
		mask &= ~BIT(idx);
    4e7e:	2301      	movs	r3, #1
    4e80:	fa03 f606 	lsl.w	r6, r3, r6
    4e84:	ea27 0706 	bic.w	r7, r7, r6
    4e88:	e7cd      	b.n	4e26 <z_impl_log_process+0x9e>
	return backend->cb->active;
    4e8a:	6873      	ldr	r3, [r6, #4]
			if (log_backend_is_active(backend) &&
    4e8c:	795b      	ldrb	r3, [r3, #5]
    4e8e:	b123      	cbz	r3, 4e9a <z_impl_log_process+0x112>
	backend->api->put(backend, msg);
    4e90:	6833      	ldr	r3, [r6, #0]
    4e92:	4621      	mov	r1, r4
    4e94:	681b      	ldr	r3, [r3, #0]
    4e96:	4630      	mov	r0, r6
    4e98:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
    4e9a:	f108 0801 	add.w	r8, r8, #1
    4e9e:	3610      	adds	r6, #16
    4ea0:	45b8      	cmp	r8, r7
    4ea2:	dbf2      	blt.n	4e8a <z_impl_log_process+0x102>
    4ea4:	e795      	b.n	4dd2 <z_impl_log_process+0x4a>
    4ea6:	bf00      	nop
    4ea8:	20006153 	.word	0x20006153
    4eac:	20000074 	.word	0x20000074
    4eb0:	20000068 	.word	0x20000068
    4eb4:	2000006c 	.word	0x2000006c
    4eb8:	20006154 	.word	0x20006154
    4ebc:	00028670 	.word	0x00028670
    4ec0:	00028540 	.word	0x00028540
    4ec4:	000286b8 	.word	0x000286b8
    4ec8:	000286c8 	.word	0x000286c8
    4ecc:	00028254 	.word	0x00028254
    4ed0:	0006d9ec 	.word	0x0006d9ec
    4ed4:	0006204c 	.word	0x0006204c
    4ed8:	00062090 	.word	0x00062090

00004edc <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
    4edc:	4b26      	ldr	r3, [pc, #152]	; (4f78 <msg_finalize+0x9c>)
{
    4ede:	b570      	push	{r4, r5, r6, lr}
	msg->hdr.timestamp = timestamp_func();
    4ee0:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
    4ee2:	8141      	strh	r1, [r0, #10]
{
    4ee4:	4605      	mov	r5, r0
	msg->hdr.timestamp = timestamp_func();
    4ee6:	4798      	blx	r3
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    4ee8:	4c24      	ldr	r4, [pc, #144]	; (4f7c <msg_finalize+0xa0>)
    4eea:	60e8      	str	r0, [r5, #12]
    4eec:	f3bf 8f5b 	dmb	ish
    4ef0:	e854 3f00 	ldrex	r3, [r4]
    4ef4:	3301      	adds	r3, #1
    4ef6:	e844 3200 	strex	r2, r3, [r4]
    4efa:	2a00      	cmp	r2, #0
    4efc:	d1f8      	bne.n	4ef0 <msg_finalize+0x14>
    4efe:	f3bf 8f5b 	dmb	ish
	__asm__ volatile(
    4f02:	f04f 0320 	mov.w	r3, #32
    4f06:	f3ef 8611 	mrs	r6, BASEPRI
    4f0a:	f383 8811 	msr	BASEPRI, r3
    4f0e:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    4f12:	481b      	ldr	r0, [pc, #108]	; (4f80 <msg_finalize+0xa4>)
    4f14:	4629      	mov	r1, r5
    4f16:	f01c f871 	bl	20ffc <log_list_add_tail>
	__asm__ volatile(
    4f1a:	f386 8811 	msr	BASEPRI, r6
    4f1e:	f3bf 8f6f 	isb	sy
	if (panic_mode) {
    4f22:	4b18      	ldr	r3, [pc, #96]	; (4f84 <msg_finalize+0xa8>)
    4f24:	781a      	ldrb	r2, [r3, #0]
    4f26:	b17a      	cbz	r2, 4f48 <msg_finalize+0x6c>
	__asm__ volatile(
    4f28:	f04f 0320 	mov.w	r3, #32
    4f2c:	f3ef 8411 	mrs	r4, BASEPRI
    4f30:	f383 8811 	msr	BASEPRI, r3
    4f34:	f3bf 8f6f 	isb	sy
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
    4f38:	2000      	movs	r0, #0
    4f3a:	f7ff ff25 	bl	4d88 <z_impl_log_process>
	__asm__ volatile(
    4f3e:	f384 8811 	msr	BASEPRI, r4
    4f42:	f3bf 8f6f 	isb	sy
}
    4f46:	bd70      	pop	{r4, r5, r6, pc}
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    4f48:	490f      	ldr	r1, [pc, #60]	; (4f88 <msg_finalize+0xac>)
    4f4a:	6823      	ldr	r3, [r4, #0]
    4f4c:	6809      	ldr	r1, [r1, #0]
    4f4e:	2900      	cmp	r1, #0
    4f50:	d0f9      	beq.n	4f46 <msg_finalize+0x6a>
    4f52:	2b01      	cmp	r3, #1
    4f54:	d106      	bne.n	4f64 <msg_finalize+0x88>
	z_impl_k_timer_start(timer, duration, period);
    4f56:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    4f5a:	480c      	ldr	r0, [pc, #48]	; (4f8c <msg_finalize+0xb0>)
}
    4f5c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    4f60:	f01a ba00 	b.w	1f364 <z_impl_k_timer_start>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    4f64:	2b0a      	cmp	r3, #10
    4f66:	d1ee      	bne.n	4f46 <msg_finalize+0x6a>
	z_impl_k_timer_stop(timer);
    4f68:	4808      	ldr	r0, [pc, #32]	; (4f8c <msg_finalize+0xb0>)
    4f6a:	f023 f847 	bl	27ffc <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
    4f6e:	4808      	ldr	r0, [pc, #32]	; (4f90 <msg_finalize+0xb4>)
}
    4f70:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    4f74:	f019 bf02 	b.w	1ed7c <z_impl_k_sem_give>
    4f78:	2000e6dc 	.word	0x2000e6dc
    4f7c:	20000068 	.word	0x20000068
    4f80:	20000074 	.word	0x20000074
    4f84:	20006154 	.word	0x20006154
    4f88:	20000130 	.word	0x20000130
    4f8c:	2000007c 	.word	0x2000007c
    4f90:	2000ef2c 	.word	0x2000ef2c

00004f94 <log_process_thread_func>:
{
    4f94:	b508      	push	{r3, lr}
	log_init();
    4f96:	f7ff fe7b 	bl	4c90 <log_init>
	return z_impl_k_current_get();
    4f9a:	f019 fee9 	bl	1ed70 <z_impl_k_current_get>
	proc_tid = process_tid;
    4f9e:	4b0b      	ldr	r3, [pc, #44]	; (4fcc <log_process_thread_func+0x38>)
    4fa0:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    4fa2:	b130      	cbz	r0, 4fb2 <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
    4fa4:	4b0a      	ldr	r3, [pc, #40]	; (4fd0 <log_process_thread_func+0x3c>)
	    process_tid &&
    4fa6:	681b      	ldr	r3, [r3, #0]
    4fa8:	2b09      	cmp	r3, #9
    4faa:	dd02      	ble.n	4fb2 <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
    4fac:	4809      	ldr	r0, [pc, #36]	; (4fd4 <log_process_thread_func+0x40>)
    4fae:	f019 fee5 	bl	1ed7c <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
    4fb2:	4c08      	ldr	r4, [pc, #32]	; (4fd4 <log_process_thread_func+0x40>)
    4fb4:	2000      	movs	r0, #0
    4fb6:	f7ff fee7 	bl	4d88 <z_impl_log_process>
		if (log_process(false) == false) {
    4fba:	2800      	cmp	r0, #0
    4fbc:	d1fa      	bne.n	4fb4 <log_process_thread_func+0x20>
    4fbe:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    4fc2:	4620      	mov	r0, r4
    4fc4:	f019 ff06 	bl	1edd4 <z_impl_k_sem_take>
    4fc8:	e7f4      	b.n	4fb4 <log_process_thread_func+0x20>
    4fca:	bf00      	nop
    4fcc:	20000130 	.word	0x20000130
    4fd0:	20000068 	.word	0x20000068
    4fd4:	2000ef2c 	.word	0x2000ef2c

00004fd8 <z_impl_log_panic>:
{
    4fd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
    4fda:	4f0e      	ldr	r7, [pc, #56]	; (5014 <z_impl_log_panic+0x3c>)
    4fdc:	783d      	ldrb	r5, [r7, #0]
    4fde:	b975      	cbnz	r5, 4ffe <z_impl_log_panic+0x26>
	return __log_backends_end - __log_backends_start;
    4fe0:	4c0d      	ldr	r4, [pc, #52]	; (5018 <z_impl_log_panic+0x40>)
    4fe2:	4e0e      	ldr	r6, [pc, #56]	; (501c <z_impl_log_panic+0x44>)
	log_init();
    4fe4:	f7ff fe54 	bl	4c90 <log_init>
    4fe8:	1b36      	subs	r6, r6, r4
    4fea:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
    4fec:	42b5      	cmp	r5, r6
    4fee:	db07      	blt.n	5000 <z_impl_log_panic+0x28>
    4ff0:	2000      	movs	r0, #0
    4ff2:	f7ff fec9 	bl	4d88 <z_impl_log_process>
		while (log_process(false) == true) {
    4ff6:	2800      	cmp	r0, #0
    4ff8:	d1fa      	bne.n	4ff0 <z_impl_log_panic+0x18>
	panic_mode = true;
    4ffa:	2301      	movs	r3, #1
    4ffc:	703b      	strb	r3, [r7, #0]
}
    4ffe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
    5000:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
    5002:	795b      	ldrb	r3, [r3, #5]
    5004:	b11b      	cbz	r3, 500e <z_impl_log_panic+0x36>
	backend->api->panic(backend);
    5006:	6823      	ldr	r3, [r4, #0]
    5008:	4620      	mov	r0, r4
    500a:	691b      	ldr	r3, [r3, #16]
    500c:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
    500e:	3501      	adds	r5, #1
    5010:	3410      	adds	r4, #16
    5012:	e7eb      	b.n	4fec <z_impl_log_panic+0x14>
    5014:	20006154 	.word	0x20006154
    5018:	000286b8 	.word	0x000286b8
    501c:	000286c8 	.word	0x000286c8

00005020 <log_free>:
{
    5020:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
    5022:	3804      	subs	r0, #4
    5024:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    5026:	f3bf 8f5b 	dmb	ish
    502a:	e850 3f00 	ldrex	r3, [r0]
    502e:	1e5a      	subs	r2, r3, #1
    5030:	e840 2100 	strex	r1, r2, [r0]
    5034:	2900      	cmp	r1, #0
    5036:	d1f8      	bne.n	502a <log_free+0xa>
    5038:	f3bf 8f5b 	dmb	ish
	if (atomic_dec(&dup->refcount) == 1) {
    503c:	2b01      	cmp	r3, #1
    503e:	d103      	bne.n	5048 <log_free+0x28>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
    5040:	a901      	add	r1, sp, #4
    5042:	4803      	ldr	r0, [pc, #12]	; (5050 <log_free+0x30>)
    5044:	f019 f9bc 	bl	1e3c0 <k_mem_slab_free>
}
    5048:	b003      	add	sp, #12
    504a:	f85d fb04 	ldr.w	pc, [sp], #4
    504e:	bf00      	nop
    5050:	200000a8 	.word	0x200000a8

00005054 <log_msg_pool_init>:
static u8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
    5054:	2320      	movs	r3, #32
    5056:	461a      	mov	r2, r3
    5058:	4901      	ldr	r1, [pc, #4]	; (5060 <log_msg_pool_init+0xc>)
    505a:	4802      	ldr	r0, [pc, #8]	; (5064 <log_msg_pool_init+0x10>)
    505c:	f022 bcbc 	b.w	279d8 <k_mem_slab_init>
    5060:	2000d760 	.word	0x2000d760
    5064:	20000134 	.word	0x20000134

00005068 <log_msg_no_space_handle>:

	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
    5068:	b537      	push	{r0, r1, r2, r4, r5, lr}
	union log_msg_chunk *msg = NULL;
    506a:	2300      	movs	r3, #0

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
    506c:	4d09      	ldr	r5, [pc, #36]	; (5094 <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
    506e:	9301      	str	r3, [sp, #4]
    5070:	2001      	movs	r0, #1
    5072:	f7ff fe89 	bl	4d88 <z_impl_log_process>
    5076:	4604      	mov	r4, r0
			log_dropped();
    5078:	f7ff fdd2 	bl	4c20 <log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
    507c:	2200      	movs	r2, #0
    507e:	a901      	add	r1, sp, #4
    5080:	4628      	mov	r0, r5
    5082:	f019 f971 	bl	1e368 <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
    5086:	b108      	cbz	r0, 508c <log_msg_no_space_handle+0x24>
    5088:	2c00      	cmp	r4, #0
    508a:	d1f1      	bne.n	5070 <log_msg_no_space_handle+0x8>
	} else {
		log_dropped();
	}
	return msg;

}
    508c:	9801      	ldr	r0, [sp, #4]
    508e:	b003      	add	sp, #12
    5090:	bd30      	pop	{r4, r5, pc}
    5092:	bf00      	nop
    5094:	20000134 	.word	0x20000134

00005098 <log_msg_chunk_alloc>:
{
    5098:	b507      	push	{r0, r1, r2, lr}
	union log_msg_chunk *msg = NULL;
    509a:	2200      	movs	r2, #0
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    509c:	a901      	add	r1, sp, #4
    509e:	4806      	ldr	r0, [pc, #24]	; (50b8 <log_msg_chunk_alloc+0x20>)
	union log_msg_chunk *msg = NULL;
    50a0:	9201      	str	r2, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    50a2:	f019 f961 	bl	1e368 <k_mem_slab_alloc>
	if (err != 0) {
    50a6:	b110      	cbz	r0, 50ae <log_msg_chunk_alloc+0x16>
		msg = log_msg_no_space_handle();
    50a8:	f7ff ffde 	bl	5068 <log_msg_no_space_handle>
    50ac:	9001      	str	r0, [sp, #4]
}
    50ae:	9801      	ldr	r0, [sp, #4]
    50b0:	b003      	add	sp, #12
    50b2:	f85d fb04 	ldr.w	pc, [sp], #4
    50b6:	bf00      	nop
    50b8:	20000134 	.word	0x20000134

000050bc <msg_free>:
{
    50bc:	b5f0      	push	{r4, r5, r6, r7, lr}
    50be:	7a04      	ldrb	r4, [r0, #8]
	}
}

u32_t log_msg_nargs_get(struct log_msg *msg)
{
	return msg->hdr.params.std.nargs;
    50c0:	7a46      	ldrb	r6, [r0, #9]
{
    50c2:	b085      	sub	sp, #20
	if (log_msg_is_std(msg) && nargs) {
    50c4:	f014 0401 	ands.w	r4, r4, #1
{
    50c8:	9001      	str	r0, [sp, #4]
	return msg->hdr.params.std.nargs;
    50ca:	ea4f 1616 	mov.w	r6, r6, lsr #4
	if (log_msg_is_std(msg) && nargs) {
    50ce:	d00e      	beq.n	50ee <msg_free+0x32>
	if (msg->hdr.params.generic.ext == 1) {
    50d0:	9b01      	ldr	r3, [sp, #4]
    50d2:	7a1a      	ldrb	r2, [r3, #8]
    50d4:	0792      	lsls	r2, r2, #30
    50d6:	d504      	bpl.n	50e2 <msg_free+0x26>
		cont_free(msg->payload.ext.next);
    50d8:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    50da:	4c18      	ldr	r4, [pc, #96]	; (513c <msg_free+0x80>)
    50dc:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
    50de:	9b03      	ldr	r3, [sp, #12]
    50e0:	bb2b      	cbnz	r3, 512e <msg_free+0x72>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
    50e2:	a901      	add	r1, sp, #4
    50e4:	4815      	ldr	r0, [pc, #84]	; (513c <msg_free+0x80>)
    50e6:	f019 f96b 	bl	1e3c0 <k_mem_slab_free>
}
    50ea:	b005      	add	sp, #20
    50ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (log_msg_is_std(msg) && nargs) {
    50ee:	2e00      	cmp	r6, #0
    50f0:	d0ee      	beq.n	50d0 <msg_free+0x14>
		for (i = 0; i < nargs; i++) {
    50f2:	4625      	mov	r5, r4
    50f4:	e017      	b.n	5126 <msg_free+0x6a>
			void *buf = (void *)log_msg_arg_get(msg, i);
    50f6:	4629      	mov	r1, r5
    50f8:	f01c f878 	bl	211ec <log_msg_arg_get>
    50fc:	4607      	mov	r7, r0
			if (log_is_strdup(buf)) {
    50fe:	f7ff fe35 	bl	4d6c <log_is_strdup>
    5102:	b178      	cbz	r0, 5124 <msg_free+0x68>
				if (smask == 0) {
    5104:	b93c      	cbnz	r4, 5116 <msg_free+0x5a>
					smask = z_log_get_s_mask(
    5106:	9b01      	ldr	r3, [sp, #4]
    5108:	4631      	mov	r1, r6
    510a:	6918      	ldr	r0, [r3, #16]
    510c:	f7ff fd1e 	bl	4b4c <z_log_get_s_mask>
					if (smask == 0) {
    5110:	4604      	mov	r4, r0
    5112:	2800      	cmp	r0, #0
    5114:	d0dc      	beq.n	50d0 <msg_free+0x14>
				if (smask & BIT(i)) {
    5116:	fa24 f305 	lsr.w	r3, r4, r5
    511a:	07db      	lsls	r3, r3, #31
    511c:	d502      	bpl.n	5124 <msg_free+0x68>
					log_free(buf);
    511e:	4638      	mov	r0, r7
    5120:	f7ff ff7e 	bl	5020 <log_free>
		for (i = 0; i < nargs; i++) {
    5124:	3501      	adds	r5, #1
    5126:	42ae      	cmp	r6, r5
    5128:	9801      	ldr	r0, [sp, #4]
    512a:	d8e4      	bhi.n	50f6 <msg_free+0x3a>
    512c:	e7d0      	b.n	50d0 <msg_free+0x14>
		next = cont->next;
    512e:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    5130:	a903      	add	r1, sp, #12
    5132:	4620      	mov	r0, r4
    5134:	f019 f944 	bl	1e3c0 <k_mem_slab_free>
		cont = next;
    5138:	9503      	str	r5, [sp, #12]
    513a:	e7d0      	b.n	50de <msg_free+0x22>
    513c:	20000134 	.word	0x20000134

00005140 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *log_output,
			   const char *fmt, ...)
{
    5140:	b40e      	push	{r1, r2, r3}
    5142:	b503      	push	{r0, r1, lr}
    5144:	ab03      	add	r3, sp, #12
	va_start(args, fmt);
#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX) && \
    defined(CONFIG_LOG_ENABLE_FANCY_OUTPUT_FORMATTING)
	length = z_prf(out_func, (void *)log_output, (char *)fmt, args);
#else
	z_vprintk(out_func, (void *)log_output, fmt, args);
    5146:	4601      	mov	r1, r0
{
    5148:	f853 2b04 	ldr.w	r2, [r3], #4
	z_vprintk(out_func, (void *)log_output, fmt, args);
    514c:	4804      	ldr	r0, [pc, #16]	; (5160 <print_formatted+0x20>)
	va_start(args, fmt);
    514e:	9301      	str	r3, [sp, #4]
	z_vprintk(out_func, (void *)log_output, fmt, args);
    5150:	f01a fcbf 	bl	1fad2 <z_vprintk>
#endif
	va_end(args);

	return length;
}
    5154:	2000      	movs	r0, #0
    5156:	b002      	add	sp, #8
    5158:	f85d eb04 	ldr.w	lr, [sp], #4
    515c:	b003      	add	sp, #12
    515e:	4770      	bx	lr
    5160:	00021699 	.word	0x00021699

00005164 <prefix_print>:
}

static u32_t prefix_print(const struct log_output *log_output,
			 u32_t flags, bool func_on, u32_t timestamp, u8_t level,
			 u8_t domain_id, u16_t source_id)
{
    5164:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5168:	b085      	sub	sp, #20
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
    516a:	f011 0402 	ands.w	r4, r1, #2
{
    516e:	4606      	mov	r6, r0
    5170:	4690      	mov	r8, r2
    5172:	f89d 7038 	ldrb.w	r7, [sp, #56]	; 0x38
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
    5176:	f001 0901 	and.w	r9, r1, #1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
    517a:	f001 0508 	and.w	r5, r1, #8
	if (stamp) {
    517e:	d007      	beq.n	5190 <prefix_print+0x2c>
	if (!format) {
    5180:	f011 0f44 	tst.w	r1, #68	; 0x44
    5184:	d137      	bne.n	51f6 <prefix_print+0x92>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
    5186:	461a      	mov	r2, r3
    5188:	4932      	ldr	r1, [pc, #200]	; (5254 <prefix_print+0xf0>)
    518a:	f7ff ffd9 	bl	5140 <print_formatted>
		length += timestamp_print(log_output, flags, timestamp);
    518e:	4604      	mov	r4, r0
	if (color) {
    5190:	f1b9 0f00 	cmp.w	r9, #0
    5194:	d00a      	beq.n	51ac <prefix_print+0x48>
		const char *color = start && (colors[level] != NULL) ?
    5196:	4b30      	ldr	r3, [pc, #192]	; (5258 <prefix_print+0xf4>)
		print_formatted(log_output, "%s", color);
    5198:	4930      	ldr	r1, [pc, #192]	; (525c <prefix_print+0xf8>)
		const char *color = start && (colors[level] != NULL) ?
    519a:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
		print_formatted(log_output, "%s", color);
    519e:	4b30      	ldr	r3, [pc, #192]	; (5260 <prefix_print+0xfc>)
    51a0:	4630      	mov	r0, r6
    51a2:	2a00      	cmp	r2, #0
    51a4:	bf08      	it	eq
    51a6:	461a      	moveq	r2, r3
    51a8:	f7ff ffca 	bl	5140 <print_formatted>
	if (level_on) {
    51ac:	b13d      	cbz	r5, 51be <prefix_print+0x5a>
		total += print_formatted(log_output, "<%s> ", severity[level]);
    51ae:	4b2d      	ldr	r3, [pc, #180]	; (5264 <prefix_print+0x100>)
    51b0:	492d      	ldr	r1, [pc, #180]	; (5268 <prefix_print+0x104>)
    51b2:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
    51b6:	4630      	mov	r0, r6
    51b8:	f7ff ffc2 	bl	5140 <print_formatted>
    51bc:	4605      	mov	r5, r0
	total += print_formatted(log_output,
    51be:	f1b8 0f00 	cmp.w	r8, #0
    51c2:	d044      	beq.n	524e <prefix_print+0xea>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    51c4:	2301      	movs	r3, #1
    51c6:	fa03 f707 	lsl.w	r7, r3, r7
	total += print_formatted(log_output,
    51ca:	4b28      	ldr	r3, [pc, #160]	; (526c <prefix_print+0x108>)
    51cc:	f017 0f10 	tst.w	r7, #16
    51d0:	4f27      	ldr	r7, [pc, #156]	; (5270 <prefix_print+0x10c>)
    51d2:	bf18      	it	ne
    51d4:	461f      	movne	r7, r3
    51d6:	f8bd 1040 	ldrh.w	r1, [sp, #64]	; 0x40
    51da:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
    51de:	f7ff fd2f 	bl	4c40 <log_source_name_get>
    51e2:	4639      	mov	r1, r7
    51e4:	4602      	mov	r2, r0
    51e6:	4630      	mov	r0, r6
    51e8:	f7ff ffaa 	bl	5140 <print_formatted>
    51ec:	4428      	add	r0, r5
		length += ids_print(log_output, level_on, func_on,
				    domain_id, source_id, level);
	}

	return length;
}
    51ee:	4420      	add	r0, r4
    51f0:	b005      	add	sp, #20
    51f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (freq != 0U) {
    51f6:	4a1f      	ldr	r2, [pc, #124]	; (5274 <prefix_print+0x110>)
    51f8:	6811      	ldr	r1, [r2, #0]
    51fa:	b331      	cbz	r1, 524a <prefix_print+0xe6>
		timestamp /= timestamp_div;
    51fc:	4a1e      	ldr	r2, [pc, #120]	; (5278 <prefix_print+0x114>)
    51fe:	f44f 6e61 	mov.w	lr, #3600	; 0xe10
    5202:	6814      	ldr	r4, [r2, #0]
    5204:	fbb3 f3f4 	udiv	r3, r3, r4
		ms = (remainder * 1000U) / freq;
    5208:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
		seconds = timestamp / freq;
    520c:	fbb3 f4f1 	udiv	r4, r3, r1
		seconds -= hours * 3600U;
    5210:	fbb4 f2fe 	udiv	r2, r4, lr
    5214:	fb0e 4e12 	mls	lr, lr, r2, r4
		remainder = timestamp % freq;
    5218:	fb01 3414 	mls	r4, r1, r4, r3
		ms = (remainder * 1000U) / freq;
    521c:	fb0c f404 	mul.w	r4, ip, r4
		mins = seconds / 60U;
    5220:	f04f 0a3c 	mov.w	sl, #60	; 0x3c
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    5224:	fbb4 fbf1 	udiv	fp, r4, r1
    5228:	fb01 441b 	mls	r4, r1, fp, r4
		mins = seconds / 60U;
    522c:	fbbe f3fa 	udiv	r3, lr, sl
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    5230:	fb0c f404 	mul.w	r4, ip, r4
    5234:	fbb4 f1f1 	udiv	r1, r4, r1
			length = print_formatted(log_output,
    5238:	e9cd b101 	strd	fp, r1, [sp, #4]
    523c:	fb0a e113 	mls	r1, sl, r3, lr
    5240:	9100      	str	r1, [sp, #0]
    5242:	490e      	ldr	r1, [pc, #56]	; (527c <prefix_print+0x118>)
    5244:	f7ff ff7c 	bl	5140 <print_formatted>
    5248:	e7a1      	b.n	518e <prefix_print+0x2a>
		length = 0;
    524a:	4608      	mov	r0, r1
    524c:	e79f      	b.n	518e <prefix_print+0x2a>
	total += print_formatted(log_output,
    524e:	4f08      	ldr	r7, [pc, #32]	; (5270 <prefix_print+0x10c>)
    5250:	e7c1      	b.n	51d6 <prefix_print+0x72>
    5252:	bf00      	nop
    5254:	00062110 	.word	0x00062110
    5258:	00028ab0 	.word	0x00028ab0
    525c:	00062bdc 	.word	0x00062bdc
    5260:	00062102 	.word	0x00062102
    5264:	00028ac4 	.word	0x00028ac4
    5268:	00062135 	.word	0x00062135
    526c:	0006210c 	.word	0x0006210c
    5270:	00062107 	.word	0x00062107
    5274:	20000150 	.word	0x20000150
    5278:	20000154 	.word	0x20000154
    527c:	00062119 	.word	0x00062119

00005280 <postfix_print>:

static void postfix_print(const struct log_output *log_output,
			  u32_t flags, u8_t level)
{
    5280:	b538      	push	{r3, r4, r5, lr}
    5282:	460c      	mov	r4, r1
	if (color) {
    5284:	07e1      	lsls	r1, r4, #31
{
    5286:	4605      	mov	r5, r0
	if (color) {
    5288:	d503      	bpl.n	5292 <postfix_print+0x12>
		print_formatted(log_output, "%s", color);
    528a:	4a08      	ldr	r2, [pc, #32]	; (52ac <postfix_print+0x2c>)
    528c:	4908      	ldr	r1, [pc, #32]	; (52b0 <postfix_print+0x30>)
    528e:	f7ff ff57 	bl	5140 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    5292:	06e2      	lsls	r2, r4, #27
    5294:	d408      	bmi.n	52a8 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    5296:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
    5298:	4628      	mov	r0, r5
		print_formatted(ctx, "\n");
    529a:	bf4c      	ite	mi
    529c:	4905      	ldrmi	r1, [pc, #20]	; (52b4 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
    529e:	4906      	ldrpl	r1, [pc, #24]	; (52b8 <postfix_print+0x38>)
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(log_output, flags);
}
    52a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\r\n");
    52a4:	f7ff bf4c 	b.w	5140 <print_formatted>
}
    52a8:	bd38      	pop	{r3, r4, r5, pc}
    52aa:	bf00      	nop
    52ac:	00062102 	.word	0x00062102
    52b0:	00062bdc 	.word	0x00062bdc
    52b4:	000620f4 	.word	0x000620f4
    52b8:	000620f3 	.word	0x000620f3

000052bc <hexdump_line_print>:
{
    52bc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    52c0:	4698      	mov	r8, r3
    52c2:	9b08      	ldr	r3, [sp, #32]
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    52c4:	06dd      	lsls	r5, r3, #27
{
    52c6:	4604      	mov	r4, r0
    52c8:	460e      	mov	r6, r1
    52ca:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    52cc:	d405      	bmi.n	52da <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    52ce:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
    52d0:	bf4c      	ite	mi
    52d2:	492a      	ldrmi	r1, [pc, #168]	; (537c <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
    52d4:	492a      	ldrpl	r1, [pc, #168]	; (5380 <hexdump_line_print+0xc4>)
    52d6:	f7ff ff33 	bl	5140 <print_formatted>
		print_formatted(log_output, " ");
    52da:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 5388 <hexdump_line_print+0xcc>
{
    52de:	2500      	movs	r5, #0
	for (int i = 0; i < prefix_offset; i++) {
    52e0:	4545      	cmp	r5, r8
    52e2:	db2d      	blt.n	5340 <hexdump_line_print+0x84>
			print_formatted(log_output, "   ");
    52e4:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 538c <hexdump_line_print+0xd0>
			print_formatted(log_output, "%02x ", data[i]);
    52e8:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 5390 <hexdump_line_print+0xd4>
			print_formatted(log_output, " ");
    52ec:	f8df a098 	ldr.w	sl, [pc, #152]	; 5388 <hexdump_line_print+0xcc>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    52f0:	2500      	movs	r5, #0
		if (i < length) {
    52f2:	42af      	cmp	r7, r5
    52f4:	d931      	bls.n	535a <hexdump_line_print+0x9e>
			print_formatted(log_output, "%02x ", data[i]);
    52f6:	5d72      	ldrb	r2, [r6, r5]
    52f8:	4649      	mov	r1, r9
    52fa:	4620      	mov	r0, r4
    52fc:	f7ff ff20 	bl	5140 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    5300:	3501      	adds	r5, #1
    5302:	2d10      	cmp	r5, #16
    5304:	d122      	bne.n	534c <hexdump_line_print+0x90>
	print_formatted(log_output, "|");
    5306:	491f      	ldr	r1, [pc, #124]	; (5384 <hexdump_line_print+0xc8>)
			print_formatted(log_output, " ");
    5308:	f8df 807c 	ldr.w	r8, [pc, #124]	; 5388 <hexdump_line_print+0xcc>
			      isprint((int)c) ? c : '.');
    530c:	f8df 9084 	ldr.w	r9, [pc, #132]	; 5394 <hexdump_line_print+0xd8>
			print_formatted(log_output, "%c",
    5310:	f8df a084 	ldr.w	sl, [pc, #132]	; 5398 <hexdump_line_print+0xdc>
	print_formatted(log_output, "|");
    5314:	4620      	mov	r0, r4
    5316:	f7ff ff13 	bl	5140 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    531a:	2500      	movs	r5, #0
		if (i < length) {
    531c:	42af      	cmp	r7, r5
    531e:	d928      	bls.n	5372 <hexdump_line_print+0xb6>
			char c = (char)data[i];
    5320:	5d72      	ldrb	r2, [r6, r5]
			print_formatted(log_output, "%c",
    5322:	f812 3009 	ldrb.w	r3, [r2, r9]
    5326:	f013 0f97 	tst.w	r3, #151	; 0x97
    532a:	bf08      	it	eq
    532c:	222e      	moveq	r2, #46	; 0x2e
    532e:	4651      	mov	r1, sl
    5330:	4620      	mov	r0, r4
    5332:	f7ff ff05 	bl	5140 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    5336:	3501      	adds	r5, #1
    5338:	2d10      	cmp	r5, #16
    533a:	d113      	bne.n	5364 <hexdump_line_print+0xa8>
}
    533c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, " ");
    5340:	4649      	mov	r1, r9
    5342:	4620      	mov	r0, r4
    5344:	f7ff fefc 	bl	5140 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
    5348:	3501      	adds	r5, #1
    534a:	e7c9      	b.n	52e0 <hexdump_line_print+0x24>
		if (i > 0 && !(i % 8)) {
    534c:	076a      	lsls	r2, r5, #29
    534e:	d1d0      	bne.n	52f2 <hexdump_line_print+0x36>
			print_formatted(log_output, " ");
    5350:	4651      	mov	r1, sl
    5352:	4620      	mov	r0, r4
    5354:	f7ff fef4 	bl	5140 <print_formatted>
    5358:	e7cb      	b.n	52f2 <hexdump_line_print+0x36>
			print_formatted(log_output, "   ");
    535a:	4641      	mov	r1, r8
    535c:	4620      	mov	r0, r4
    535e:	f7ff feef 	bl	5140 <print_formatted>
    5362:	e7cd      	b.n	5300 <hexdump_line_print+0x44>
		if (i > 0 && !(i % 8)) {
    5364:	076b      	lsls	r3, r5, #29
    5366:	d1d9      	bne.n	531c <hexdump_line_print+0x60>
			print_formatted(log_output, " ");
    5368:	4641      	mov	r1, r8
    536a:	4620      	mov	r0, r4
    536c:	f7ff fee8 	bl	5140 <print_formatted>
    5370:	e7d4      	b.n	531c <hexdump_line_print+0x60>
			print_formatted(log_output, " ");
    5372:	4641      	mov	r1, r8
    5374:	4620      	mov	r0, r4
    5376:	f7ff fee3 	bl	5140 <print_formatted>
    537a:	e7dc      	b.n	5336 <hexdump_line_print+0x7a>
    537c:	000620f4 	.word	0x000620f4
    5380:	000620f3 	.word	0x000620f3
    5384:	000620d0 	.word	0x000620d0
    5388:	000620ce 	.word	0x000620ce
    538c:	000620cc 	.word	0x000620cc
    5390:	000620c6 	.word	0x000620c6
    5394:	00028779 	.word	0x00028779
    5398:	000620d2 	.word	0x000620d2

0000539c <log_output_msg_process>:

void log_output_msg_process(const struct log_output *log_output,
			    struct log_msg *msg,
			    u32_t flags)
{
    539c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return msg->hdr.ids.level;
    53a0:	7a8b      	ldrb	r3, [r1, #10]
		log_output_msg_syst_process(log_output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    53a2:	f013 0407 	ands.w	r4, r3, #7
{
    53a6:	4617      	mov	r7, r2
    53a8:	b08a      	sub	sp, #40	; 0x28
    53aa:	4605      	mov	r5, r0
    53ac:	460e      	mov	r6, r1
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    53ae:	7a0a      	ldrb	r2, [r1, #8]
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    53b0:	d01c      	beq.n	53ec <log_output_msg_process+0x50>
	return msg->hdr.ids.source_id;
    53b2:	8949      	ldrh	r1, [r1, #10]
    53b4:	f3c3 03c2 	ubfx	r3, r3, #3, #3
    53b8:	0989      	lsrs	r1, r1, #6
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    53ba:	43d2      	mvns	r2, r2
    53bc:	9102      	str	r1, [sp, #8]
    53be:	e9cd 4300 	strd	r4, r3, [sp]
    53c2:	f002 0201 	and.w	r2, r2, #1
    53c6:	68f3      	ldr	r3, [r6, #12]
    53c8:	4639      	mov	r1, r7
    53ca:	f7ff fecb 	bl	5164 <prefix_print>
    53ce:	4681      	mov	r9, r0
    53d0:	7a33      	ldrb	r3, [r6, #8]
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
    53d2:	07da      	lsls	r2, r3, #31
    53d4:	d40c      	bmi.n	53f0 <log_output_msg_process+0x54>
		std_print(msg, log_output);
    53d6:	4629      	mov	r1, r5
    53d8:	4630      	mov	r0, r6
    53da:	f01b fff3 	bl	213c4 <std_print>
		raw_string_print(msg, log_output);
	} else {
		hexdump_print(msg, log_output, prefix_offset, flags);
	}

	if (!raw_string) {
    53de:	b34c      	cbz	r4, 5434 <log_output_msg_process+0x98>
		postfix_print(log_output, flags, level);
    53e0:	4622      	mov	r2, r4
    53e2:	4639      	mov	r1, r7
    53e4:	4628      	mov	r0, r5
    53e6:	f7ff ff4b 	bl	5280 <postfix_print>
    53ea:	e023      	b.n	5434 <log_output_msg_process+0x98>
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    53ec:	46a1      	mov	r9, r4
    53ee:	e7ef      	b.n	53d0 <log_output_msg_process+0x34>
	} else if (raw_string) {
    53f0:	bb34      	cbnz	r4, 5440 <log_output_msg_process+0xa4>
	size_t offset = 0;
    53f2:	4627      	mov	r7, r4
		length = log_output->size;
    53f4:	68eb      	ldr	r3, [r5, #12]
    53f6:	9306      	str	r3, [sp, #24]
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
    53f8:	aa06      	add	r2, sp, #24
    53fa:	463b      	mov	r3, r7
    53fc:	68a9      	ldr	r1, [r5, #8]
    53fe:	4630      	mov	r0, r6
    5400:	f01b ffcc 	bl	2139c <log_msg_hexdump_data_get>
		log_output->control_block->offset = length;
    5404:	9a06      	ldr	r2, [sp, #24]
    5406:	686b      	ldr	r3, [r5, #4]
    5408:	601a      	str	r2, [r3, #0]
		if (length != 0) {
    540a:	b13a      	cbz	r2, 541c <log_output_msg_process+0x80>
			eol = (log_output->buf[length - 1] == '\n');
    540c:	68ab      	ldr	r3, [r5, #8]
    540e:	4413      	add	r3, r2
    5410:	f813 4c01 	ldrb.w	r4, [r3, #-1]
    5414:	f1a4 030a 	sub.w	r3, r4, #10
    5418:	425c      	negs	r4, r3
    541a:	415c      	adcs	r4, r3
		log_output_flush(log_output);
    541c:	4628      	mov	r0, r5
    541e:	f01c f92e 	bl	2167e <log_output_flush>
		offset += length;
    5422:	9b06      	ldr	r3, [sp, #24]
    5424:	441f      	add	r7, r3
	} while (length > 0);
    5426:	2b00      	cmp	r3, #0
    5428:	d1e4      	bne.n	53f4 <log_output_msg_process+0x58>
	if (eol) {
    542a:	b11c      	cbz	r4, 5434 <log_output_msg_process+0x98>
		print_formatted(log_output, "\r");
    542c:	4914      	ldr	r1, [pc, #80]	; (5480 <log_output_msg_process+0xe4>)
    542e:	4628      	mov	r0, r5
    5430:	f7ff fe86 	bl	5140 <print_formatted>
	}

	log_output_flush(log_output);
    5434:	4628      	mov	r0, r5
    5436:	f01c f922 	bl	2167e <log_output_flush>
}
    543a:	b00a      	add	sp, #40	; 0x28
    543c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	print_formatted(log_output, "%s", log_msg_str_get(msg));
    5440:	4630      	mov	r0, r6
    5442:	f01b ff03 	bl	2124c <log_msg_str_get>
    5446:	490f      	ldr	r1, [pc, #60]	; (5484 <log_output_msg_process+0xe8>)
    5448:	4602      	mov	r2, r0
    544a:	4628      	mov	r0, r5
    544c:	f7ff fe78 	bl	5140 <print_formatted>
	u32_t offset = 0U;
    5450:	f04f 0800 	mov.w	r8, #0
		length = sizeof(buf);
    5454:	f04f 0a10 	mov.w	sl, #16
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    5458:	aa05      	add	r2, sp, #20
    545a:	4643      	mov	r3, r8
    545c:	a906      	add	r1, sp, #24
    545e:	4630      	mov	r0, r6
		length = sizeof(buf);
    5460:	f8cd a014 	str.w	sl, [sp, #20]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    5464:	f01b ff9a 	bl	2139c <log_msg_hexdump_data_get>
		if (length) {
    5468:	9a05      	ldr	r2, [sp, #20]
    546a:	2a00      	cmp	r2, #0
    546c:	d0b8      	beq.n	53e0 <log_output_msg_process+0x44>
			hexdump_line_print(log_output, buf, length,
    546e:	464b      	mov	r3, r9
    5470:	9700      	str	r7, [sp, #0]
    5472:	a906      	add	r1, sp, #24
    5474:	4628      	mov	r0, r5
    5476:	f7ff ff21 	bl	52bc <hexdump_line_print>
			offset += length;
    547a:	9b05      	ldr	r3, [sp, #20]
    547c:	4498      	add	r8, r3
    547e:	e7eb      	b.n	5458 <log_output_msg_process+0xbc>
    5480:	000620d5 	.word	0x000620d5
    5484:	00062bdc 	.word	0x00062bdc

00005488 <log_output_dropped_process>:
	postfix_print(log_output, flags, level);
	log_output_flush(log_output);
}

void log_output_dropped_process(const struct log_output *log_output, u32_t cnt)
{
    5488:	b573      	push	{r0, r1, r4, r5, r6, lr}
	int len;
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = log_output->func;
	struct device *dev = (struct device *)log_output->control_block->ctx;
    548a:	e9d0 4300 	ldrd	r4, r3, [r0]
    548e:	685d      	ldr	r5, [r3, #4]

	cnt = MIN(cnt, 9999);
	len = snprintf(buf, sizeof(buf), "%d", cnt);
    5490:	4a0f      	ldr	r2, [pc, #60]	; (54d0 <log_output_dropped_process+0x48>)
    5492:	f242 730f 	movw	r3, #9999	; 0x270f
    5496:	428b      	cmp	r3, r1
    5498:	bf28      	it	cs
    549a:	460b      	movcs	r3, r1
    549c:	4668      	mov	r0, sp
    549e:	2105      	movs	r1, #5
    54a0:	f7fb fa6f 	bl	982 <sniprintf>

	buffer_write(outf, (u8_t *)prefix, sizeof(prefix) - 1, dev);
    54a4:	462b      	mov	r3, r5
	len = snprintf(buf, sizeof(buf), "%d", cnt);
    54a6:	4606      	mov	r6, r0
	buffer_write(outf, (u8_t *)prefix, sizeof(prefix) - 1, dev);
    54a8:	220b      	movs	r2, #11
    54aa:	4620      	mov	r0, r4
    54ac:	4909      	ldr	r1, [pc, #36]	; (54d4 <log_output_dropped_process+0x4c>)
    54ae:	f01b ff7c 	bl	213aa <buffer_write>
	buffer_write(outf, buf, len, dev);
    54b2:	462b      	mov	r3, r5
    54b4:	4632      	mov	r2, r6
    54b6:	4669      	mov	r1, sp
    54b8:	4620      	mov	r0, r4
    54ba:	f01b ff76 	bl	213aa <buffer_write>
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
    54be:	462b      	mov	r3, r5
    54c0:	221b      	movs	r2, #27
    54c2:	4905      	ldr	r1, [pc, #20]	; (54d8 <log_output_dropped_process+0x50>)
    54c4:	4620      	mov	r0, r4
    54c6:	f01b ff70 	bl	213aa <buffer_write>
}
    54ca:	b002      	add	sp, #8
    54cc:	bd70      	pop	{r4, r5, r6, pc}
    54ce:	bf00      	nop
    54d0:	00063bf2 	.word	0x00063bf2
    54d4:	000620f6 	.word	0x000620f6
    54d8:	000620d7 	.word	0x000620d7

000054dc <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(u32_t frequency)
{
	timestamp_div = 1U;
    54dc:	4a08      	ldr	r2, [pc, #32]	; (5500 <log_output_timestamp_freq_set+0x24>)
{
    54de:	b510      	push	{r4, lr}
	timestamp_div = 1U;
    54e0:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
    54e2:	4c08      	ldr	r4, [pc, #32]	; (5504 <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
    54e4:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
    54e6:	2100      	movs	r1, #0
    54e8:	42a0      	cmp	r0, r4
    54ea:	d804      	bhi.n	54f6 <log_output_timestamp_freq_set+0x1a>
    54ec:	b101      	cbz	r1, 54f0 <log_output_timestamp_freq_set+0x14>
    54ee:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
    54f0:	4b05      	ldr	r3, [pc, #20]	; (5508 <log_output_timestamp_freq_set+0x2c>)
    54f2:	6018      	str	r0, [r3, #0]
}
    54f4:	bd10      	pop	{r4, pc}
		frequency /= 2U;
    54f6:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
    54f8:	005b      	lsls	r3, r3, #1
    54fa:	2101      	movs	r1, #1
    54fc:	e7f4      	b.n	54e8 <log_output_timestamp_freq_set+0xc>
    54fe:	bf00      	nop
    5500:	20000154 	.word	0x20000154
    5504:	000f4240 	.word	0x000f4240
    5508:	20000150 	.word	0x20000150

0000550c <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
    550c:	4b01      	ldr	r3, [pc, #4]	; (5514 <log_backend_rtt_init+0x8>)
    550e:	2201      	movs	r2, #1
    5510:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
    5512:	4770      	bx	lr
    5514:	20006165 	.word	0x20006165

00005518 <panic>:

static void panic(struct log_backend const *const backend)
{
    5518:	b508      	push	{r3, lr}
 * @param log_output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const log_output)
{
	log_output_flush(log_output);
    551a:	4803      	ldr	r0, [pc, #12]	; (5528 <panic+0x10>)
    551c:	f01c f8af 	bl	2167e <log_output_flush>
	log_backend_std_panic(&log_output);
	panic_mode = true;
    5520:	4b02      	ldr	r3, [pc, #8]	; (552c <panic+0x14>)
    5522:	2201      	movs	r2, #1
    5524:	701a      	strb	r2, [r3, #0]
}
    5526:	bd08      	pop	{r3, pc}
    5528:	00028af0 	.word	0x00028af0
    552c:	20006166 	.word	0x20006166

00005530 <dropped>:
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const log_output, u32_t cnt)
{
	log_output_dropped_process(log_output, cnt);
    5530:	4801      	ldr	r0, [pc, #4]	; (5538 <dropped+0x8>)
    5532:	f7ff bfa9 	b.w	5488 <log_output_dropped_process>
    5536:	bf00      	nop
    5538:	00028af0 	.word	0x00028af0

0000553c <put>:
{
    553c:	b510      	push	{r4, lr}
	log_msg_get(msg);
    553e:	4608      	mov	r0, r1
    5540:	460c      	mov	r4, r1
    5542:	f01b fe43 	bl	211cc <log_msg_get>
	log_output_msg_process(log_output, msg, flags);
    5546:	4621      	mov	r1, r4
    5548:	4804      	ldr	r0, [pc, #16]	; (555c <put+0x20>)
    554a:	220f      	movs	r2, #15
    554c:	f7ff ff26 	bl	539c <log_output_msg_process>
	log_msg_put(msg);
    5550:	4620      	mov	r0, r4
}
    5552:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    5556:	f01b be66 	b.w	21226 <log_msg_put>
    555a:	bf00      	nop
    555c:	00028af0 	.word	0x00028af0

00005560 <on_failed_write.part.0>:
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
    5560:	4b04      	ldr	r3, [pc, #16]	; (5574 <on_failed_write.part.0+0x14>)
	} else if (is_sync_mode()) {
    5562:	781b      	ldrb	r3, [r3, #0]
    5564:	b11b      	cbz	r3, 556e <on_failed_write.part.0+0xe>
	z_impl_k_busy_wait(usec_to_wait);
    5566:	f241 3088 	movw	r0, #5000	; 0x1388
    556a:	f022 bc57 	b.w	27e1c <z_impl_k_busy_wait>
	return z_impl_k_sleep(ms);
    556e:	2005      	movs	r0, #5
    5570:	f019 bbd6 	b.w	1ed20 <z_impl_k_sleep>
    5574:	20006166 	.word	0x20006166

00005578 <data_out_block_mode>:
{
    5578:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
    557c:	4f21      	ldr	r7, [pc, #132]	; (5604 <data_out_block_mode+0x8c>)
	return z_impl_k_mutex_lock(mutex, timeout);
    557e:	f8df 908c 	ldr.w	r9, [pc, #140]	; 560c <data_out_block_mode+0x94>
{
    5582:	4682      	mov	sl, r0
    5584:	460e      	mov	r6, r1
	int retry_cnt = CONFIG_LOG_BACKEND_RTT_RETRY_CNT;
    5586:	2404      	movs	r4, #4
    5588:	46b8      	mov	r8, r7
		if (!is_sync_mode()) {
    558a:	783b      	ldrb	r3, [r7, #0]
    558c:	b923      	cbnz	r3, 5598 <data_out_block_mode+0x20>
    558e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    5592:	4648      	mov	r0, r9
    5594:	f018 ffde 	bl	1e554 <z_impl_k_mutex_lock>
		ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
    5598:	4632      	mov	r2, r6
    559a:	4651      	mov	r1, sl
    559c:	2000      	movs	r0, #0
    559e:	f001 f9f7 	bl	6990 <SEGGER_RTT_WriteSkipNoLock>
		if (!is_sync_mode()) {
    55a2:	f898 3000 	ldrb.w	r3, [r8]
		ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
    55a6:	4683      	mov	fp, r0
		if (!is_sync_mode()) {
    55a8:	b913      	cbnz	r3, 55b0 <data_out_block_mode+0x38>
	z_impl_k_mutex_unlock(mutex);
    55aa:	4648      	mov	r0, r9
    55ac:	f019 f844 	bl	1e638 <z_impl_k_mutex_unlock>
		if (ret) {
    55b0:	4d15      	ldr	r5, [pc, #84]	; (5608 <data_out_block_mode+0x90>)
    55b2:	f1bb 0f00 	cmp.w	fp, #0
    55b6:	d018      	beq.n	55ea <data_out_block_mode+0x72>
	host_present = true;
    55b8:	2301      	movs	r3, #1
    55ba:	702b      	strb	r3, [r5, #0]
	if (is_panic_mode()) {
    55bc:	f898 3000 	ldrb.w	r3, [r8]
    55c0:	b933      	cbnz	r3, 55d0 <data_out_block_mode+0x58>
}
    55c2:	4630      	mov	r0, r6
    55c4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (retry_cnt == 0) {
    55c8:	b95c      	cbnz	r4, 55e2 <data_out_block_mode+0x6a>
		host_present = false;
    55ca:	702c      	strb	r4, [r5, #0]
    55cc:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
    55d0:	2000      	movs	r0, #0
    55d2:	f001 fa29 	bl	6a28 <SEGGER_RTT_HasDataUp>
    55d6:	2800      	cmp	r0, #0
    55d8:	d0f3      	beq.n	55c2 <data_out_block_mode+0x4a>
    55da:	782b      	ldrb	r3, [r5, #0]
    55dc:	2b00      	cmp	r3, #0
    55de:	d1f3      	bne.n	55c8 <data_out_block_mode+0x50>
    55e0:	e7ef      	b.n	55c2 <data_out_block_mode+0x4a>
			on_failed_write(retry_cnt--);
    55e2:	3c01      	subs	r4, #1
    55e4:	f7ff ffbc 	bl	5560 <on_failed_write.part.0>
    55e8:	e7f2      	b.n	55d0 <data_out_block_mode+0x58>
		} else if (host_present) {
    55ea:	782b      	ldrb	r3, [r5, #0]
    55ec:	b113      	cbz	r3, 55f4 <data_out_block_mode+0x7c>
	if (retry_cnt == 0) {
    55ee:	3c01      	subs	r4, #1
    55f0:	d104      	bne.n	55fc <data_out_block_mode+0x84>
		host_present = false;
    55f2:	702c      	strb	r4, [r5, #0]
	} while ((ret == 0) && host_present);
    55f4:	782b      	ldrb	r3, [r5, #0]
    55f6:	2b00      	cmp	r3, #0
    55f8:	d1c7      	bne.n	558a <data_out_block_mode+0x12>
    55fa:	e7e2      	b.n	55c2 <data_out_block_mode+0x4a>
    55fc:	f7ff ffb0 	bl	5560 <on_failed_write.part.0>
    5600:	e7f8      	b.n	55f4 <data_out_block_mode+0x7c>
    5602:	bf00      	nop
    5604:	20006166 	.word	0x20006166
    5608:	20006165 	.word	0x20006165
    560c:	2000efcc 	.word	0x2000efcc

00005610 <read_pnp_id>:

#if CONFIG_BT_GATT_DIS_PNP
static ssize_t read_pnp_id(struct bt_conn *conn,
			   const struct bt_gatt_attr *attr, void *buf,
			   u16_t len, u16_t offset)
{
    5610:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &dis_pnp_id,
    5612:	2407      	movs	r4, #7
    5614:	9402      	str	r4, [sp, #8]
    5616:	4c04      	ldr	r4, [pc, #16]	; (5628 <read_pnp_id+0x18>)
    5618:	9401      	str	r4, [sp, #4]
    561a:	f8bd 4018 	ldrh.w	r4, [sp, #24]
    561e:	9400      	str	r4, [sp, #0]
    5620:	f01d ff3e 	bl	234a0 <bt_gatt_attr_read>
				 sizeof(dis_pnp_id));
}
    5624:	b004      	add	sp, #16
    5626:	bd10      	pop	{r4, pc}
    5628:	2000edb8 	.word	0x2000edb8

0000562c <blvl_ccc_cfg_changed>:
{
	ARG_UNUSED(attr);

	bool notif_enabled = (value == BT_GATT_CCC_NOTIFY);

	LOG_INF("BAS Notifications %s", notif_enabled ? "enabled" : "disabled");
    562c:	2303      	movs	r3, #3
    562e:	f04f 0200 	mov.w	r2, #0
    5632:	f363 0207 	bfi	r2, r3, #0, #8
    5636:	4807      	ldr	r0, [pc, #28]	; (5654 <blvl_ccc_cfg_changed+0x28>)
    5638:	4b07      	ldr	r3, [pc, #28]	; (5658 <blvl_ccc_cfg_changed+0x2c>)
    563a:	1a1b      	subs	r3, r3, r0
    563c:	08db      	lsrs	r3, r3, #3
    563e:	4807      	ldr	r0, [pc, #28]	; (565c <blvl_ccc_cfg_changed+0x30>)
    5640:	f363 128f 	bfi	r2, r3, #6, #10
    5644:	4b06      	ldr	r3, [pc, #24]	; (5660 <blvl_ccc_cfg_changed+0x34>)
    5646:	2901      	cmp	r1, #1
    5648:	bf14      	ite	ne
    564a:	4601      	movne	r1, r0
    564c:	4619      	moveq	r1, r3
    564e:	4805      	ldr	r0, [pc, #20]	; (5664 <blvl_ccc_cfg_changed+0x38>)
    5650:	f01b bd00 	b.w	21054 <log_1>
    5654:	00028540 	.word	0x00028540
    5658:	00028548 	.word	0x00028548
    565c:	00062191 	.word	0x00062191
    5660:	00062189 	.word	0x00062189
    5664:	0006219a 	.word	0x0006219a

00005668 <read_blvl>:
}

static ssize_t read_blvl(struct bt_conn *conn,
			       const struct bt_gatt_attr *attr, void *buf,
			       u16_t len, u16_t offset)
{
    5668:	b510      	push	{r4, lr}
	u8_t lvl8 = battery_level;
    566a:	4c08      	ldr	r4, [pc, #32]	; (568c <read_blvl+0x24>)
{
    566c:	b086      	sub	sp, #24
	u8_t lvl8 = battery_level;
    566e:	7824      	ldrb	r4, [r4, #0]
    5670:	f88d 4017 	strb.w	r4, [sp, #23]

	return bt_gatt_attr_read(conn, attr, buf, len, offset, &lvl8,
    5674:	2401      	movs	r4, #1
    5676:	9402      	str	r4, [sp, #8]
    5678:	f10d 0417 	add.w	r4, sp, #23
    567c:	9401      	str	r4, [sp, #4]
    567e:	f8bd 4020 	ldrh.w	r4, [sp, #32]
    5682:	9400      	str	r4, [sp, #0]
    5684:	f01d ff0c 	bl	234a0 <bt_gatt_attr_read>
				 sizeof(lvl8));
}
    5688:	b006      	add	sp, #24
    568a:	bd10      	pop	{r4, pc}
    568c:	2000edbf 	.word	0x2000edbf

00005690 <hrs_init>:

static int hrs_init(struct device *dev)
{
	ARG_UNUSED(dev);

	hrs_blsc = 0x01;
    5690:	4b02      	ldr	r3, [pc, #8]	; (569c <hrs_init+0xc>)
    5692:	2201      	movs	r2, #1
    5694:	701a      	strb	r2, [r3, #0]

	return 0;
}
    5696:	2000      	movs	r0, #0
    5698:	4770      	bx	lr
    569a:	bf00      	nop
    569c:	20006167 	.word	0x20006167

000056a0 <read_blsc>:
{
    56a0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &hrs_blsc,
    56a2:	2401      	movs	r4, #1
    56a4:	9402      	str	r4, [sp, #8]
    56a6:	4c04      	ldr	r4, [pc, #16]	; (56b8 <read_blsc+0x18>)
    56a8:	9401      	str	r4, [sp, #4]
    56aa:	f8bd 4018 	ldrh.w	r4, [sp, #24]
    56ae:	9400      	str	r4, [sp, #0]
    56b0:	f01d fef6 	bl	234a0 <bt_gatt_attr_read>
}
    56b4:	b004      	add	sp, #16
    56b6:	bd10      	pop	{r4, pc}
    56b8:	20006167 	.word	0x20006167

000056bc <hrmc_ccc_cfg_changed>:
	LOG_INF("HRS notifications %s", notif_enabled ? "enabled" : "disabled");
    56bc:	2303      	movs	r3, #3
    56be:	f04f 0200 	mov.w	r2, #0
    56c2:	f363 0207 	bfi	r2, r3, #0, #8
    56c6:	4807      	ldr	r0, [pc, #28]	; (56e4 <hrmc_ccc_cfg_changed+0x28>)
    56c8:	4b07      	ldr	r3, [pc, #28]	; (56e8 <hrmc_ccc_cfg_changed+0x2c>)
    56ca:	1a1b      	subs	r3, r3, r0
    56cc:	08db      	lsrs	r3, r3, #3
    56ce:	4807      	ldr	r0, [pc, #28]	; (56ec <hrmc_ccc_cfg_changed+0x30>)
    56d0:	f363 128f 	bfi	r2, r3, #6, #10
    56d4:	4b06      	ldr	r3, [pc, #24]	; (56f0 <hrmc_ccc_cfg_changed+0x34>)
    56d6:	2901      	cmp	r1, #1
    56d8:	bf14      	ite	ne
    56da:	4601      	movne	r1, r0
    56dc:	4619      	moveq	r1, r3
    56de:	4805      	ldr	r0, [pc, #20]	; (56f4 <hrmc_ccc_cfg_changed+0x38>)
    56e0:	f01b bcb8 	b.w	21054 <log_1>
    56e4:	00028540 	.word	0x00028540
    56e8:	00028660 	.word	0x00028660
    56ec:	00062191 	.word	0x00062191
    56f0:	00062189 	.word	0x00062189
    56f4:	000621b3 	.word	0x000621b3

000056f8 <__do_init_array_aux>:
 * @brief Execute initialization routines referenced in .init_array section
 *
 * @return N/A
 */
void __do_init_array_aux(void)
{
    56f8:	b538      	push	{r3, r4, r5, lr}
	for (func_ptr *func = __init_array_start;
    56fa:	4c04      	ldr	r4, [pc, #16]	; (570c <__do_init_array_aux+0x14>)
    56fc:	4d04      	ldr	r5, [pc, #16]	; (5710 <__do_init_array_aux+0x18>)
    56fe:	42ac      	cmp	r4, r5
    5700:	d300      	bcc.n	5704 <__do_init_array_aux+0xc>
		func < __init_array_end;
		func++) {
		(*func)();
	}
}
    5702:	bd38      	pop	{r3, r4, r5, pc}
		(*func)();
    5704:	f854 3b04 	ldr.w	r3, [r4], #4
    5708:	4798      	blx	r3
    570a:	e7f8      	b.n	56fe <__do_init_array_aux+0x6>
    570c:	00028394 	.word	0x00028394
    5710:	00028394 	.word	0x00028394

00005714 <__do_global_ctors_aux>:
 *
 * This routine is invoked by the kernel prior to the execution of the
 * application's main().
 */
void __do_global_ctors_aux(void)
{
    5714:	b538      	push	{r3, r4, r5, lr}
	unsigned int nCtors;

	nCtors = (unsigned long)__CTOR_LIST__[0];
    5716:	4c05      	ldr	r4, [pc, #20]	; (572c <__do_global_ctors_aux+0x18>)
    5718:	6825      	ldr	r5, [r4, #0]

	while (nCtors >= 1U) {
    571a:	eb04 0485 	add.w	r4, r4, r5, lsl #2
    571e:	b905      	cbnz	r5, 5722 <__do_global_ctors_aux+0xe>
		__CTOR_LIST__[nCtors--]();
	}
}
    5720:	bd38      	pop	{r3, r4, r5, pc}
		__CTOR_LIST__[nCtors--]();
    5722:	f854 3904 	ldr.w	r3, [r4], #-4
    5726:	3d01      	subs	r5, #1
    5728:	4798      	blx	r3
    572a:	e7f8      	b.n	571e <__do_global_ctors_aux+0xa>
    572c:	0002838c 	.word	0x0002838c

00005730 <nvs_flash_erase_sector>:

/* erase a sector by first checking it is used and then erasing if required
 * return 0 if OK, errorcode on error.
 */
static int nvs_flash_erase_sector(struct nvs_fs *fs, u32_t addr)
{
    5730:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	int rc;
	off_t offset;

	addr &= ADDR_SECT_MASK;
    5734:	0c0c      	lsrs	r4, r1, #16
    5736:	0424      	lsls	r4, r4, #16
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
    5738:	8982      	ldrh	r2, [r0, #12]
    573a:	4621      	mov	r1, r4
{
    573c:	4605      	mov	r5, r0
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
    573e:	f01c f842 	bl	217c6 <nvs_flash_cmp_const.constprop.5>
	if (rc <= 0) {
    5742:	1e06      	subs	r6, r0, #0
    5744:	dd2a      	ble.n	579c <nvs_flash_erase_sector+0x6c>
	}

	offset = fs->offset;
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);

	rc = flash_write_protection_set(fs->flash_device, 0);
    5746:	2100      	movs	r1, #0
    5748:	6aa8      	ldr	r0, [r5, #40]	; 0x28
	offset = fs->offset;
    574a:	682f      	ldr	r7, [r5, #0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
    574c:	f8b5 800c 	ldrh.w	r8, [r5, #12]
	rc = flash_write_protection_set(fs->flash_device, 0);
    5750:	f01b ffd8 	bl	21704 <flash_write_protection_set>
	if (rc) {
    5754:	4606      	mov	r6, r0
    5756:	bb08      	cbnz	r0, 579c <nvs_flash_erase_sector+0x6c>
		/* flash protection set error */
		return rc;
	}
	LOG_DBG("Erasing flash at %lx, len %d", (long int) offset,
    5758:	2304      	movs	r3, #4
    575a:	f04f 0200 	mov.w	r2, #0
    575e:	f363 0207 	bfi	r2, r3, #0, #8
    5762:	4910      	ldr	r1, [pc, #64]	; (57a4 <nvs_flash_erase_sector+0x74>)
    5764:	4b10      	ldr	r3, [pc, #64]	; (57a8 <nvs_flash_erase_sector+0x78>)
    5766:	4811      	ldr	r0, [pc, #68]	; (57ac <nvs_flash_erase_sector+0x7c>)
    5768:	1a5b      	subs	r3, r3, r1
    576a:	08db      	lsrs	r3, r3, #3
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
    576c:	0c24      	lsrs	r4, r4, #16
	LOG_DBG("Erasing flash at %lx, len %d", (long int) offset,
    576e:	f363 128f 	bfi	r2, r3, #6, #10
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
    5772:	fb08 7404 	mla	r4, r8, r4, r7
	LOG_DBG("Erasing flash at %lx, len %d", (long int) offset,
    5776:	f8ad 2000 	strh.w	r2, [sp]
    577a:	89ab      	ldrh	r3, [r5, #12]
    577c:	490c      	ldr	r1, [pc, #48]	; (57b0 <nvs_flash_erase_sector+0x80>)
    577e:	4622      	mov	r2, r4
    5780:	f01b fc94 	bl	210ac <log_3>
		fs->sector_size);
	rc = flash_erase(fs->flash_device, offset, fs->sector_size);
    5784:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    5786:	89aa      	ldrh	r2, [r5, #12]
				    size_t size)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->driver_api;

	return api->erase(dev, offset, size);
    5788:	6843      	ldr	r3, [r0, #4]
    578a:	4621      	mov	r1, r4
    578c:	689b      	ldr	r3, [r3, #8]
    578e:	4798      	blx	r3
	if (rc) {
    5790:	4606      	mov	r6, r0
    5792:	b918      	cbnz	r0, 579c <nvs_flash_erase_sector+0x6c>
		/* flash erase error */
		return rc;
	}
	(void) flash_write_protection_set(fs->flash_device, 1);
    5794:	2101      	movs	r1, #1
    5796:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    5798:	f01b ffb4 	bl	21704 <flash_write_protection_set>
	return 0;
}
    579c:	4630      	mov	r0, r6
    579e:	b002      	add	sp, #8
    57a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    57a4:	00028540 	.word	0x00028540
    57a8:	00028658 	.word	0x00028658
    57ac:	000621fe 	.word	0x000621fe
    57b0:	000621cc 	.word	0x000621cc

000057b4 <nvs_prev_ate>:

/* walking through allocation entry list, from newest to oldest entries
 * read ate from addr, modify addr to the previous ate
 */
static int nvs_prev_ate(struct nvs_fs *fs, u32_t *addr, struct nvs_ate *ate)
{
    57b4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    57b8:	2308      	movs	r3, #8
{
    57ba:	b085      	sub	sp, #20
    57bc:	460d      	mov	r5, r1
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    57be:	6809      	ldr	r1, [r1, #0]
	int rc;
	struct nvs_ate close_ate, end_ate;
	u32_t data_end_addr, ate_end_addr;
	size_t ate_size;

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    57c0:	7c04      	ldrb	r4, [r0, #16]
{
    57c2:	4607      	mov	r7, r0
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    57c4:	f01b ffa1 	bl	2170a <nvs_flash_rd>

	rc = nvs_flash_ate_rd(fs, *addr, ate);
	if (rc) {
    57c8:	b968      	cbnz	r0, 57e6 <nvs_prev_ate+0x32>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    57ca:	2108      	movs	r1, #8
    57cc:	4620      	mov	r0, r4
    57ce:	f01b ffe7 	bl	217a0 <nvs_al_size.isra.1>
		return rc;
	}

	*addr += ate_size;
    57d2:	6829      	ldr	r1, [r5, #0]
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
    57d4:	89bb      	ldrh	r3, [r7, #12]
	*addr += ate_size;
    57d6:	4401      	add	r1, r0
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
    57d8:	b28a      	uxth	r2, r1
    57da:	1a1b      	subs	r3, r3, r0
    57dc:	429a      	cmp	r2, r3
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    57de:	4606      	mov	r6, r0
	*addr += ate_size;
    57e0:	6029      	str	r1, [r5, #0]
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
    57e2:	d003      	beq.n	57ec <nvs_prev_ate+0x38>
		return 0;
    57e4:	2000      	movs	r0, #0
	/* remark: if there was absolutely no valid data in the sector *addr
	 * is kept at sector_end - 2*ate_size, the next read will contain
	 * invalid data and continue with a sector jump
	 */
	return 0;
}
    57e6:	b005      	add	sp, #20
    57e8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (((*addr) >> ADDR_SECT_SHIFT) == 0U) {
    57ec:	0c0b      	lsrs	r3, r1, #16
		*addr += ((fs->sector_count - 1) << ADDR_SECT_SHIFT);
    57ee:	bf03      	ittte	eq
    57f0:	89fb      	ldrheq	r3, [r7, #14]
    57f2:	f103 33ff 	addeq.w	r3, r3, #4294967295	; 0xffffffff
    57f6:	eb01 4103 	addeq.w	r1, r1, r3, lsl #16
		*addr -= (1 << ADDR_SECT_SHIFT);
    57fa:	f5a1 3180 	subne.w	r1, r1, #65536	; 0x10000
    57fe:	6029      	str	r1, [r5, #0]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    5800:	2308      	movs	r3, #8
    5802:	466a      	mov	r2, sp
    5804:	4638      	mov	r0, r7
    5806:	f01b ff80 	bl	2170a <nvs_flash_rd>
	if (rc) {
    580a:	2800      	cmp	r0, #0
    580c:	d1eb      	bne.n	57e6 <nvs_prev_ate+0x32>
    580e:	466a      	mov	r2, sp
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
    5810:	4603      	mov	r3, r0
		if (data8[i] != value) {
    5812:	f812 1b01 	ldrb.w	r1, [r2], #1
    5816:	29ff      	cmp	r1, #255	; 0xff
    5818:	d115      	bne.n	5846 <nvs_prev_ate+0x92>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
    581a:	3301      	adds	r3, #1
    581c:	2b08      	cmp	r3, #8
    581e:	d1f8      	bne.n	5812 <nvs_prev_ate+0x5e>
		*addr = fs->ate_wra;
    5820:	687b      	ldr	r3, [r7, #4]
    5822:	602b      	str	r3, [r5, #0]
		return 0;
    5824:	e7df      	b.n	57e6 <nvs_prev_ate+0x32>
		if (close_ate.offset < (fs->sector_size - ate_size) &&
    5826:	89ba      	ldrh	r2, [r7, #12]
    5828:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    582c:	1b92      	subs	r2, r2, r6
    582e:	4293      	cmp	r3, r2
    5830:	d20f      	bcs.n	5852 <nvs_prev_ate+0x9e>
		    !(close_ate.offset % ate_size)) {
    5832:	fbb3 f2f6 	udiv	r2, r3, r6
    5836:	fb06 3212 	mls	r2, r6, r2, r3
		if (close_ate.offset < (fs->sector_size - ate_size) &&
    583a:	b952      	cbnz	r2, 5852 <nvs_prev_ate+0x9e>
			(*addr) &= ADDR_SECT_MASK;
    583c:	0c24      	lsrs	r4, r4, #16
    583e:	0424      	lsls	r4, r4, #16
			(*addr) += close_ate.offset;
    5840:	441c      	add	r4, r3
    5842:	602c      	str	r4, [r5, #0]
			return 0;
    5844:	e7cf      	b.n	57e6 <nvs_prev_ate+0x32>
	if (!nvs_ate_crc8_check(&close_ate)) {
    5846:	4668      	mov	r0, sp
    5848:	f01b ff95 	bl	21776 <nvs_ate_crc8_check>
    584c:	682c      	ldr	r4, [r5, #0]
    584e:	2800      	cmp	r0, #0
    5850:	d0e9      	beq.n	5826 <nvs_prev_ate+0x72>
	data_end_addr = *addr & ADDR_SECT_MASK;
    5852:	4b10      	ldr	r3, [pc, #64]	; (5894 <nvs_prev_ate+0xe0>)
	*addr -= ate_size;
    5854:	1ba4      	subs	r4, r4, r6
    5856:	602c      	str	r4, [r5, #0]
	data_end_addr = *addr & ADDR_SECT_MASK;
    5858:	ea04 0803 	and.w	r8, r4, r3
			data_end_addr &= ADDR_SECT_MASK;
    585c:	4699      	mov	r9, r3
	while (ate_end_addr > data_end_addr) {
    585e:	45a0      	cmp	r8, r4
    5860:	d2c0      	bcs.n	57e4 <nvs_prev_ate+0x30>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    5862:	2308      	movs	r3, #8
    5864:	eb0d 0203 	add.w	r2, sp, r3
    5868:	4621      	mov	r1, r4
    586a:	4638      	mov	r0, r7
    586c:	f01b ff4d 	bl	2170a <nvs_flash_rd>
		if (rc) {
    5870:	2800      	cmp	r0, #0
    5872:	d1b8      	bne.n	57e6 <nvs_prev_ate+0x32>
		if (!nvs_ate_crc8_check(&end_ate)) {
    5874:	a802      	add	r0, sp, #8
    5876:	f01b ff7e 	bl	21776 <nvs_ate_crc8_check>
    587a:	b940      	cbnz	r0, 588e <nvs_prev_ate+0xda>
			data_end_addr += end_ate.offset + end_ate.len;
    587c:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5880:	f8bd 200c 	ldrh.w	r2, [sp, #12]
			*addr = ate_end_addr;
    5884:	602c      	str	r4, [r5, #0]
			data_end_addr &= ADDR_SECT_MASK;
    5886:	ea08 0809 	and.w	r8, r8, r9
			data_end_addr += end_ate.offset + end_ate.len;
    588a:	4413      	add	r3, r2
    588c:	4498      	add	r8, r3
		ate_end_addr -= ate_size;
    588e:	1ba4      	subs	r4, r4, r6
    5890:	e7e5      	b.n	585e <nvs_prev_ate+0xaa>
    5892:	bf00      	nop
    5894:	ffff0000 	.word	0xffff0000

00005898 <nvs_gc>:
/* garbage collection: the address ate_wra has been updated to the new sector
 * that has just been started. The data to gc is in the sector after this new
 * sector.
 */
static int nvs_gc(struct nvs_fs *fs)
{
    5898:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    589c:	4604      	mov	r4, r0
    589e:	b097      	sub	sp, #92	; 0x5c
	struct nvs_ate close_ate, gc_ate, wlk_ate;
	u32_t sec_addr, gc_addr, gc_prev_addr, wlk_addr, wlk_prev_addr,
	      data_addr, stop_addr;
	size_t ate_size;

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    58a0:	2108      	movs	r1, #8
    58a2:	7c00      	ldrb	r0, [r0, #16]
    58a4:	f01b ff7c 	bl	217a0 <nvs_al_size.isra.1>

	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
    58a8:	6863      	ldr	r3, [r4, #4]
    58aa:	0c1b      	lsrs	r3, r3, #16
    58ac:	041b      	lsls	r3, r3, #16
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    58ae:	4680      	mov	r8, r0
	nvs_sector_advance(fs, &sec_addr);
    58b0:	a905      	add	r1, sp, #20
    58b2:	89e0      	ldrh	r0, [r4, #14]
	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
    58b4:	9305      	str	r3, [sp, #20]
	nvs_sector_advance(fs, &sec_addr);
    58b6:	f01b ff7c 	bl	217b2 <nvs_sector_advance.isra.2>
	gc_addr = sec_addr + fs->sector_size - ate_size;
    58ba:	9b05      	ldr	r3, [sp, #20]
    58bc:	89a1      	ldrh	r1, [r4, #12]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    58be:	ad08      	add	r5, sp, #32
	gc_addr = sec_addr + fs->sector_size - ate_size;
    58c0:	4419      	add	r1, r3
    58c2:	eba1 0108 	sub.w	r1, r1, r8
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    58c6:	462a      	mov	r2, r5
    58c8:	2308      	movs	r3, #8
    58ca:	4620      	mov	r0, r4
	gc_addr = sec_addr + fs->sector_size - ate_size;
    58cc:	9106      	str	r1, [sp, #24]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    58ce:	f01b ff1c 	bl	2170a <nvs_flash_rd>

	/* if the sector is not closed don't do gc */
	rc = nvs_flash_ate_rd(fs, gc_addr, &close_ate);
	if (rc < 0) {
    58d2:	1e02      	subs	r2, r0, #0
    58d4:	f2c0 8085 	blt.w	59e2 <nvs_gc+0x14a>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
    58d8:	2300      	movs	r3, #0
		if (data8[i] != value) {
    58da:	5cea      	ldrb	r2, [r5, r3]
    58dc:	2aff      	cmp	r2, #255	; 0xff
    58de:	f040 8084 	bne.w	59ea <nvs_gc+0x152>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
    58e2:	3301      	adds	r3, #1
    58e4:	2b08      	cmp	r3, #8
    58e6:	d1f8      	bne.n	58da <nvs_gc+0x42>
		return rc;
	}

	rc = nvs_ate_cmp_const(&close_ate, 0xff);
	if (!rc) {
		rc = nvs_flash_erase_sector(fs, sec_addr);
    58e8:	9905      	ldr	r1, [sp, #20]
    58ea:	4620      	mov	r0, r4
    58ec:	f7ff ff20 	bl	5730 <nvs_flash_erase_sector>
    58f0:	4602      	mov	r2, r0
		if (rc) {
    58f2:	e076      	b.n	59e2 <nvs_gc+0x14a>
		bytes_to_copy = MIN(block_size, len);
    58f4:	454e      	cmp	r6, r9
    58f6:	4635      	mov	r5, r6
    58f8:	bf28      	it	cs
    58fa:	464d      	movcs	r5, r9
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_copy);
    58fc:	aa0e      	add	r2, sp, #56	; 0x38
    58fe:	462b      	mov	r3, r5
    5900:	4639      	mov	r1, r7
    5902:	4620      	mov	r0, r4
    5904:	f01b ff01 	bl	2170a <nvs_flash_rd>
		if (rc) {
    5908:	4602      	mov	r2, r0
    590a:	2800      	cmp	r0, #0
    590c:	d169      	bne.n	59e2 <nvs_gc+0x14a>
	if (!len) {
    590e:	b135      	cbz	r5, 591e <nvs_gc+0x86>
    5910:	aa0e      	add	r2, sp, #56	; 0x38
    5912:	462b      	mov	r3, r5
    5914:	68a1      	ldr	r1, [r4, #8]
    5916:	4620      	mov	r0, r4
    5918:	f01b ff79 	bl	2180e <nvs_flash_al_wrt.part.3>
    591c:	4602      	mov	r2, r0
	fs->data_wra += nvs_al_size(fs, len);
    591e:	4629      	mov	r1, r5
    5920:	7c20      	ldrb	r0, [r4, #16]
    5922:	f01b ff3d 	bl	217a0 <nvs_al_size.isra.1>
    5926:	68a3      	ldr	r3, [r4, #8]
    5928:	4418      	add	r0, r3
    592a:	60a0      	str	r0, [r4, #8]
		if (rc) {
    592c:	2a00      	cmp	r2, #0
    592e:	d158      	bne.n	59e2 <nvs_gc+0x14a>
		len -= bytes_to_copy;
    5930:	eba9 0905 	sub.w	r9, r9, r5
		addr += bytes_to_copy;
    5934:	442f      	add	r7, r5
    5936:	e04a      	b.n	59ce <nvs_gc+0x136>
				return rc;
			}
		}

		/* stop gc at end of the sector */
		if (gc_prev_addr == stop_addr) {
    5938:	45d8      	cmp	r8, fp
    593a:	d0d5      	beq.n	58e8 <nvs_gc+0x50>
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
    593c:	aa0a      	add	r2, sp, #40	; 0x28
    593e:	a906      	add	r1, sp, #24
    5940:	4620      	mov	r0, r4
		gc_prev_addr = gc_addr;
    5942:	f8dd b018 	ldr.w	fp, [sp, #24]
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
    5946:	f7ff ff35 	bl	57b4 <nvs_prev_ate>
		if (rc) {
    594a:	4602      	mov	r2, r0
    594c:	2800      	cmp	r0, #0
    594e:	d148      	bne.n	59e2 <nvs_gc+0x14a>
		wlk_addr = fs->ate_wra;
    5950:	6863      	ldr	r3, [r4, #4]
    5952:	9307      	str	r3, [sp, #28]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    5954:	aa0c      	add	r2, sp, #48	; 0x30
    5956:	a907      	add	r1, sp, #28
    5958:	4620      	mov	r0, r4
			wlk_prev_addr = wlk_addr;
    595a:	9d07      	ldr	r5, [sp, #28]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    595c:	f7ff ff2a 	bl	57b4 <nvs_prev_ate>
			if (rc) {
    5960:	4602      	mov	r2, r0
    5962:	2800      	cmp	r0, #0
    5964:	d13d      	bne.n	59e2 <nvs_gc+0x14a>
			if ((wlk_ate.id == gc_ate.id) &&
    5966:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
    596a:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
    596e:	429a      	cmp	r2, r3
    5970:	d1f0      	bne.n	5954 <nvs_gc+0xbc>
			    (!nvs_ate_crc8_check(&wlk_ate))) {
    5972:	a80c      	add	r0, sp, #48	; 0x30
    5974:	f01b feff 	bl	21776 <nvs_ate_crc8_check>
			if ((wlk_ate.id == gc_ate.id) &&
    5978:	2800      	cmp	r0, #0
    597a:	d1eb      	bne.n	5954 <nvs_gc+0xbc>
		if ((wlk_prev_addr == gc_prev_addr) && gc_ate.len) {
    597c:	45ab      	cmp	fp, r5
    597e:	d1db      	bne.n	5938 <nvs_gc+0xa0>
    5980:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
    5984:	2b00      	cmp	r3, #0
    5986:	d0d7      	beq.n	5938 <nvs_gc+0xa0>
			LOG_DBG("Moving %d, len %d", gc_ate.id, gc_ate.len);
    5988:	f02a 023f 	bic.w	r2, sl, #63	; 0x3f
    598c:	f042 0204 	orr.w	r2, r2, #4
    5990:	f362 0a07 	bfi	sl, r2, #0, #8
    5994:	9a02      	ldr	r2, [sp, #8]
    5996:	491d      	ldr	r1, [pc, #116]	; (5a0c <nvs_gc+0x174>)
    5998:	481d      	ldr	r0, [pc, #116]	; (5a10 <nvs_gc+0x178>)
    599a:	f362 1a8f 	bfi	sl, r2, #6, #10
    599e:	f8ad a000 	strh.w	sl, [sp]
    59a2:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
    59a6:	f01b fb81 	bl	210ac <log_3>
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
    59aa:	9b03      	ldr	r3, [sp, #12]
    59ac:	ea0b 0703 	and.w	r7, fp, r3
			data_addr += gc_ate.offset;
    59b0:	f8bd 302a 	ldrh.w	r3, [sp, #42]	; 0x2a
			nvs_ate_crc8_update(&gc_ate);
    59b4:	a80a      	add	r0, sp, #40	; 0x28
			data_addr += gc_ate.offset;
    59b6:	441f      	add	r7, r3
			gc_ate.offset = (u16_t)(fs->data_wra & ADDR_OFFS_MASK);
    59b8:	68a3      	ldr	r3, [r4, #8]
    59ba:	f8ad 302a 	strh.w	r3, [sp, #42]	; 0x2a
			nvs_ate_crc8_update(&gc_ate);
    59be:	f01b fee6 	bl	2178e <nvs_ate_crc8_update>
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
    59c2:	7c26      	ldrb	r6, [r4, #16]
			rc = nvs_flash_block_move(fs, data_addr, gc_ate.len);
    59c4:	f8bd 902c 	ldrh.w	r9, [sp, #44]	; 0x2c
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
    59c8:	4276      	negs	r6, r6
    59ca:	f006 0620 	and.w	r6, r6, #32
	while (len) {
    59ce:	f1b9 0f00 	cmp.w	r9, #0
    59d2:	d18f      	bne.n	58f4 <nvs_gc+0x5c>
			rc = nvs_flash_ate_wrt(fs, &gc_ate);
    59d4:	a90a      	add	r1, sp, #40	; 0x28
    59d6:	4620      	mov	r0, r4
    59d8:	f01b ff5f 	bl	2189a <nvs_flash_ate_wrt>
			if (rc) {
    59dc:	4602      	mov	r2, r0
    59de:	2800      	cmp	r0, #0
    59e0:	d0aa      	beq.n	5938 <nvs_gc+0xa0>
	rc = nvs_flash_erase_sector(fs, sec_addr);
	if (rc) {
		return rc;
	}
	return 0;
}
    59e2:	4610      	mov	r0, r2
    59e4:	b017      	add	sp, #92	; 0x5c
    59e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	stop_addr = gc_addr - ate_size;
    59ea:	9b06      	ldr	r3, [sp, #24]
	gc_addr &= ADDR_SECT_MASK;
    59ec:	4a09      	ldr	r2, [pc, #36]	; (5a14 <nvs_gc+0x17c>)
	gc_addr += close_ate.offset;
    59ee:	f8bd 1022 	ldrh.w	r1, [sp, #34]	; 0x22
	stop_addr = gc_addr - ate_size;
    59f2:	eba3 0808 	sub.w	r8, r3, r8
	gc_addr &= ADDR_SECT_MASK;
    59f6:	4013      	ands	r3, r2
	gc_addr += close_ate.offset;
    59f8:	440b      	add	r3, r1
    59fa:	9306      	str	r3, [sp, #24]
			LOG_DBG("Moving %d, len %d", gc_ate.id, gc_ate.len);
    59fc:	4906      	ldr	r1, [pc, #24]	; (5a18 <nvs_gc+0x180>)
    59fe:	4b07      	ldr	r3, [pc, #28]	; (5a1c <nvs_gc+0x184>)
    5a00:	1a5b      	subs	r3, r3, r1
    5a02:	f3c3 03c9 	ubfx	r3, r3, #3, #10
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
    5a06:	e9cd 3202 	strd	r3, r2, [sp, #8]
    5a0a:	e797      	b.n	593c <nvs_gc+0xa4>
    5a0c:	000621e3 	.word	0x000621e3
    5a10:	0006221f 	.word	0x0006221f
    5a14:	ffff0000 	.word	0xffff0000
    5a18:	00028540 	.word	0x00028540
    5a1c:	00028658 	.word	0x00028658

00005a20 <nvs_init>:
	}
	return 0;
}

int nvs_init(struct nvs_fs *fs, const char *dev_name)
{
    5a20:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    5a24:	4604      	mov	r4, r0
    5a26:	b087      	sub	sp, #28
    5a28:	460d      	mov	r5, r1

	int rc;
	struct flash_pages_info info;

	k_mutex_init(&fs->nvs_lock);
    5a2a:	f100 0614 	add.w	r6, r0, #20
	z_impl_k_mutex_init(mutex);
    5a2e:	4630      	mov	r0, r6
    5a30:	f021 fffc 	bl	27a2c <z_impl_k_mutex_init>
    5a34:	4628      	mov	r0, r5
    5a36:	f018 faf3 	bl	1e020 <z_impl_device_get_binding>

	fs->flash_device = device_get_binding(dev_name);
    5a3a:	62a0      	str	r0, [r4, #40]	; 0x28
	if (!fs->flash_device) {
    5a3c:	b998      	cbnz	r0, 5a66 <nvs_init+0x46>
		LOG_ERR("No valid flash device found");
    5a3e:	2301      	movs	r3, #1
    5a40:	f04f 0100 	mov.w	r1, #0
    5a44:	f363 0107 	bfi	r1, r3, #0, #8
    5a48:	4aa0      	ldr	r2, [pc, #640]	; (5ccc <nvs_init+0x2ac>)
    5a4a:	4ba1      	ldr	r3, [pc, #644]	; (5cd0 <nvs_init+0x2b0>)
    5a4c:	48a1      	ldr	r0, [pc, #644]	; (5cd4 <nvs_init+0x2b4>)
    5a4e:	1a9b      	subs	r3, r3, r2
    5a50:	08db      	lsrs	r3, r3, #3
    5a52:	f363 118f 	bfi	r1, r3, #6, #10
    5a56:	f01b faf0 	bl	2103a <log_0>
		return -ENXIO;
    5a5a:	f06f 0505 	mvn.w	r5, #5
	LOG_INF("data wra: %d, %x",
		(fs->data_wra >> ADDR_SECT_SHIFT),
		(fs->data_wra & ADDR_OFFS_MASK));

	return 0;
}
    5a5e:	4628      	mov	r0, r5
    5a60:	b007      	add	sp, #28
    5a62:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
static inline size_t z_impl_flash_get_write_block_size(struct device *dev)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->driver_api;

	return api->write_block_size;
    5a66:	6843      	ldr	r3, [r0, #4]
	fs->write_block_size = flash_get_write_block_size(fs->flash_device);
    5a68:	7d1b      	ldrb	r3, [r3, #20]
    5a6a:	7423      	strb	r3, [r4, #16]
	if (fs->write_block_size > NVS_BLOCK_SIZE) {
    5a6c:	2b20      	cmp	r3, #32
    5a6e:	d910      	bls.n	5a92 <nvs_init+0x72>
		LOG_ERR("Unsupported write block size");
    5a70:	2301      	movs	r3, #1
    5a72:	f04f 0100 	mov.w	r1, #0
    5a76:	f363 0107 	bfi	r1, r3, #0, #8
    5a7a:	4a94      	ldr	r2, [pc, #592]	; (5ccc <nvs_init+0x2ac>)
    5a7c:	4b94      	ldr	r3, [pc, #592]	; (5cd0 <nvs_init+0x2b0>)
    5a7e:	4896      	ldr	r0, [pc, #600]	; (5cd8 <nvs_init+0x2b8>)
    5a80:	1a9b      	subs	r3, r3, r2
    5a82:	08db      	lsrs	r3, r3, #3
    5a84:	f363 118f 	bfi	r1, r3, #6, #10
		LOG_ERR("Unable to get page info");
    5a88:	f01b fad7 	bl	2103a <log_0>
		return -EINVAL;
    5a8c:	f06f 0515 	mvn.w	r5, #21
    5a90:	e7e5      	b.n	5a5e <nvs_init+0x3e>
	rc = flash_get_page_info_by_offs(fs->flash_device, fs->offset, &info);
    5a92:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    5a94:	6821      	ldr	r1, [r4, #0]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&dev, *(uintptr_t *)&offset, *(uintptr_t *)&info, K_SYSCALL_FLASH_GET_PAGE_INFO_BY_OFFS);
	}
#endif
	compiler_barrier();
	return z_impl_flash_get_page_info_by_offs(dev, offset, info);
    5a96:	aa03      	add	r2, sp, #12
    5a98:	f01f fbf4 	bl	25284 <z_impl_flash_get_page_info_by_offs>
	if (rc) {
    5a9c:	b160      	cbz	r0, 5ab8 <nvs_init+0x98>
		LOG_ERR("Unable to get page info");
    5a9e:	2301      	movs	r3, #1
    5aa0:	f04f 0100 	mov.w	r1, #0
    5aa4:	f363 0107 	bfi	r1, r3, #0, #8
    5aa8:	4a88      	ldr	r2, [pc, #544]	; (5ccc <nvs_init+0x2ac>)
    5aaa:	4b89      	ldr	r3, [pc, #548]	; (5cd0 <nvs_init+0x2b0>)
    5aac:	488b      	ldr	r0, [pc, #556]	; (5cdc <nvs_init+0x2bc>)
    5aae:	1a9b      	subs	r3, r3, r2
    5ab0:	08db      	lsrs	r3, r3, #3
    5ab2:	f363 118f 	bfi	r1, r3, #6, #10
    5ab6:	e7e7      	b.n	5a88 <nvs_init+0x68>
	if (!fs->sector_size || fs->sector_size % info.size) {
    5ab8:	89a3      	ldrh	r3, [r4, #12]
    5aba:	b12b      	cbz	r3, 5ac8 <nvs_init+0xa8>
    5abc:	9a04      	ldr	r2, [sp, #16]
    5abe:	fbb3 f5f2 	udiv	r5, r3, r2
    5ac2:	fb02 3515 	mls	r5, r2, r5, r3
    5ac6:	b165      	cbz	r5, 5ae2 <nvs_init+0xc2>
		LOG_ERR("Invalid sector size");
    5ac8:	2301      	movs	r3, #1
    5aca:	f04f 0100 	mov.w	r1, #0
    5ace:	f363 0107 	bfi	r1, r3, #0, #8
    5ad2:	4a7e      	ldr	r2, [pc, #504]	; (5ccc <nvs_init+0x2ac>)
    5ad4:	4b7e      	ldr	r3, [pc, #504]	; (5cd0 <nvs_init+0x2b0>)
    5ad6:	4882      	ldr	r0, [pc, #520]	; (5ce0 <nvs_init+0x2c0>)
    5ad8:	1a9b      	subs	r3, r3, r2
    5ada:	08db      	lsrs	r3, r3, #3
    5adc:	f363 118f 	bfi	r1, r3, #6, #10
    5ae0:	e7d2      	b.n	5a88 <nvs_init+0x68>
	if (fs->sector_count < 2) {
    5ae2:	89e3      	ldrh	r3, [r4, #14]
    5ae4:	2b01      	cmp	r3, #1
    5ae6:	d80c      	bhi.n	5b02 <nvs_init+0xe2>
		LOG_ERR("Configuration error - sector count");
    5ae8:	2301      	movs	r3, #1
    5aea:	f04f 0100 	mov.w	r1, #0
    5aee:	f363 0107 	bfi	r1, r3, #0, #8
    5af2:	4a76      	ldr	r2, [pc, #472]	; (5ccc <nvs_init+0x2ac>)
    5af4:	4b76      	ldr	r3, [pc, #472]	; (5cd0 <nvs_init+0x2b0>)
    5af6:	487b      	ldr	r0, [pc, #492]	; (5ce4 <nvs_init+0x2c4>)
    5af8:	1a9b      	subs	r3, r3, r2
    5afa:	08db      	lsrs	r3, r3, #3
    5afc:	f363 118f 	bfi	r1, r3, #6, #10
    5b00:	e7c2      	b.n	5a88 <nvs_init+0x68>
	u32_t addr = 0U;
    5b02:	9500      	str	r5, [sp, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
    5b04:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    5b08:	4630      	mov	r0, r6
    5b0a:	f018 fd23 	bl	1e554 <z_impl_k_mutex_lock>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    5b0e:	2108      	movs	r1, #8
    5b10:	7c20      	ldrb	r0, [r4, #16]
    5b12:	f01b fe45 	bl	217a0 <nvs_al_size.isra.1>
	u16_t i, closed_sectors = 0;
    5b16:	46a9      	mov	r9, r5
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    5b18:	4607      	mov	r7, r0
	for (i = 0; i < fs->sector_count; i++) {
    5b1a:	89e3      	ldrh	r3, [r4, #14]
    5b1c:	fa1f f885 	uxth.w	r8, r5
    5b20:	4543      	cmp	r3, r8
    5b22:	d805      	bhi.n	5b30 <nvs_init+0x110>
	if (closed_sectors == fs->sector_count) {
    5b24:	89e3      	ldrh	r3, [r4, #14]
    5b26:	454b      	cmp	r3, r9
    5b28:	d11e      	bne.n	5b68 <nvs_init+0x148>
		return -EDEADLK;
    5b2a:	f06f 052c 	mvn.w	r5, #44	; 0x2c
    5b2e:	e796      	b.n	5a5e <nvs_init+0x3e>
		       (u16_t)(fs->sector_size - ate_size);
    5b30:	89a1      	ldrh	r1, [r4, #12]
		addr = (i << ADDR_SECT_SHIFT) +
    5b32:	042b      	lsls	r3, r5, #16
		       (u16_t)(fs->sector_size - ate_size);
    5b34:	1bc9      	subs	r1, r1, r7
		addr = (i << ADDR_SECT_SHIFT) +
    5b36:	fa13 f181 	uxtah	r1, r3, r1
		rc = nvs_flash_cmp_const(fs, addr, 0xff,
    5b3a:	2208      	movs	r2, #8
    5b3c:	4620      	mov	r0, r4
		addr = (i << ADDR_SECT_SHIFT) +
    5b3e:	9100      	str	r1, [sp, #0]
		rc = nvs_flash_cmp_const(fs, addr, 0xff,
    5b40:	f01b fe41 	bl	217c6 <nvs_flash_cmp_const.constprop.5>
		if (rc) {
    5b44:	b170      	cbz	r0, 5b64 <nvs_init+0x144>
			nvs_sector_advance(fs, &addr);
    5b46:	4669      	mov	r1, sp
    5b48:	89e0      	ldrh	r0, [r4, #14]
    5b4a:	f01b fe32 	bl	217b2 <nvs_sector_advance.isra.2>
			closed_sectors++;
    5b4e:	f109 0901 	add.w	r9, r9, #1
			rc = nvs_flash_cmp_const(fs, addr, 0xff,
    5b52:	2208      	movs	r2, #8
    5b54:	9900      	ldr	r1, [sp, #0]
    5b56:	4620      	mov	r0, r4
			closed_sectors++;
    5b58:	fa1f f989 	uxth.w	r9, r9
			rc = nvs_flash_cmp_const(fs, addr, 0xff,
    5b5c:	f01b fe33 	bl	217c6 <nvs_flash_cmp_const.constprop.5>
			if (!rc) {
    5b60:	2800      	cmp	r0, #0
    5b62:	d0df      	beq.n	5b24 <nvs_init+0x104>
    5b64:	3501      	adds	r5, #1
    5b66:	e7d8      	b.n	5b1a <nvs_init+0xfa>
	if (i == fs->sector_count) {
    5b68:	4598      	cmp	r8, r3
    5b6a:	d10a      	bne.n	5b82 <nvs_init+0x162>
		rc = nvs_flash_cmp_const(fs, addr - ate_size, 0xff,
    5b6c:	9900      	ldr	r1, [sp, #0]
    5b6e:	2208      	movs	r2, #8
    5b70:	1bc9      	subs	r1, r1, r7
    5b72:	4620      	mov	r0, r4
    5b74:	f01b fe27 	bl	217c6 <nvs_flash_cmp_const.constprop.5>
		if (!rc) {
    5b78:	b918      	cbnz	r0, 5b82 <nvs_init+0x162>
			nvs_sector_advance(fs, &addr);
    5b7a:	4669      	mov	r1, sp
    5b7c:	89e0      	ldrh	r0, [r4, #14]
    5b7e:	f01b fe18 	bl	217b2 <nvs_sector_advance.isra.2>
	fs->ate_wra = addr - ate_size;
    5b82:	9b00      	ldr	r3, [sp, #0]
    5b84:	1bda      	subs	r2, r3, r7
    5b86:	6062      	str	r2, [r4, #4]
	fs->data_wra = addr & ADDR_SECT_MASK;
    5b88:	4a57      	ldr	r2, [pc, #348]	; (5ce8 <nvs_init+0x2c8>)
    5b8a:	4013      	ands	r3, r2
    5b8c:	60a3      	str	r3, [r4, #8]
			fs->data_wra = addr & ADDR_SECT_MASK;
    5b8e:	4690      	mov	r8, r2
	while (fs->ate_wra >= fs->data_wra) {
    5b90:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
    5b94:	4299      	cmp	r1, r3
    5b96:	d30e      	bcc.n	5bb6 <nvs_init+0x196>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    5b98:	2308      	movs	r3, #8
    5b9a:	aa01      	add	r2, sp, #4
    5b9c:	4620      	mov	r0, r4
    5b9e:	f01b fdb4 	bl	2170a <nvs_flash_rd>
		if (rc) {
    5ba2:	4605      	mov	r5, r0
    5ba4:	bb18      	cbnz	r0, 5bee <nvs_init+0x1ce>
    5ba6:	ab01      	add	r3, sp, #4
		if (data8[i] != value) {
    5ba8:	f813 2b01 	ldrb.w	r2, [r3], #1
    5bac:	2aff      	cmp	r2, #255	; 0xff
    5bae:	d175      	bne.n	5c9c <nvs_init+0x27c>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
    5bb0:	3501      	adds	r5, #1
    5bb2:	2d08      	cmp	r5, #8
    5bb4:	d1f8      	bne.n	5ba8 <nvs_init+0x188>
	while (fs->ate_wra > fs->data_wra) {
    5bb6:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
    5bba:	428a      	cmp	r2, r1
    5bbc:	d906      	bls.n	5bcc <nvs_init+0x1ac>
		rc = nvs_flash_cmp_const(fs, fs->data_wra, 0xff, empty_len);
    5bbe:	1a52      	subs	r2, r2, r1
    5bc0:	4620      	mov	r0, r4
    5bc2:	f01b fe00 	bl	217c6 <nvs_flash_cmp_const.constprop.5>
		if (rc < 0) {
    5bc6:	1e05      	subs	r5, r0, #0
    5bc8:	db11      	blt.n	5bee <nvs_init+0x1ce>
		if (!rc) {
    5bca:	d14a      	bne.n	5c62 <nvs_init+0x242>
	addr = fs->ate_wra & ADDR_SECT_MASK;
    5bcc:	6863      	ldr	r3, [r4, #4]
    5bce:	f8df 8118 	ldr.w	r8, [pc, #280]	; 5ce8 <nvs_init+0x2c8>
	nvs_sector_advance(fs, &addr);
    5bd2:	89e0      	ldrh	r0, [r4, #14]
	addr = fs->ate_wra & ADDR_SECT_MASK;
    5bd4:	ea03 0308 	and.w	r3, r3, r8
	nvs_sector_advance(fs, &addr);
    5bd8:	4669      	mov	r1, sp
	addr = fs->ate_wra & ADDR_SECT_MASK;
    5bda:	9300      	str	r3, [sp, #0]
	nvs_sector_advance(fs, &addr);
    5bdc:	f01b fde9 	bl	217b2 <nvs_sector_advance.isra.2>
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
    5be0:	89a2      	ldrh	r2, [r4, #12]
    5be2:	9900      	ldr	r1, [sp, #0]
    5be4:	4620      	mov	r0, r4
    5be6:	f01b fdee 	bl	217c6 <nvs_flash_cmp_const.constprop.5>
	if (rc < 0) {
    5bea:	1e05      	subs	r5, r0, #0
    5bec:	da3e      	bge.n	5c6c <nvs_init+0x24c>
	z_impl_k_mutex_unlock(mutex);
    5bee:	4630      	mov	r0, r6
    5bf0:	f018 fd22 	bl	1e638 <z_impl_k_mutex_unlock>
	if (rc) {
    5bf4:	2d00      	cmp	r5, #0
    5bf6:	f47f af32 	bne.w	5a5e <nvs_init+0x3e>
	fs->ready = true;
    5bfa:	2301      	movs	r3, #1
    5bfc:	7463      	strb	r3, [r4, #17]
	LOG_INF("%d Sectors of %d bytes", fs->sector_count, fs->sector_size);
    5bfe:	2203      	movs	r2, #3
    5c00:	f04f 0300 	mov.w	r3, #0
    5c04:	f362 0307 	bfi	r3, r2, #0, #8
    5c08:	4e31      	ldr	r6, [pc, #196]	; (5cd0 <nvs_init+0x2b0>)
    5c0a:	4a30      	ldr	r2, [pc, #192]	; (5ccc <nvs_init+0x2ac>)
    5c0c:	89e1      	ldrh	r1, [r4, #14]
    5c0e:	4837      	ldr	r0, [pc, #220]	; (5cec <nvs_init+0x2cc>)
    5c10:	1ab6      	subs	r6, r6, r2
    5c12:	f3c6 06c9 	ubfx	r6, r6, #3, #10
    5c16:	f366 138f 	bfi	r3, r6, #6, #10
    5c1a:	89a2      	ldrh	r2, [r4, #12]
    5c1c:	f01b fa2e 	bl	2107c <log_2>
	LOG_INF("alloc wra: %d, %x",
    5c20:	6861      	ldr	r1, [r4, #4]
    5c22:	4833      	ldr	r0, [pc, #204]	; (5cf0 <nvs_init+0x2d0>)
    5c24:	2203      	movs	r2, #3
    5c26:	f04f 0300 	mov.w	r3, #0
    5c2a:	f362 0307 	bfi	r3, r2, #0, #8
    5c2e:	f366 138f 	bfi	r3, r6, #6, #10
    5c32:	b28a      	uxth	r2, r1
    5c34:	0c09      	lsrs	r1, r1, #16
    5c36:	f01b fa21 	bl	2107c <log_2>
	LOG_INF("data wra: %d, %x",
    5c3a:	68a1      	ldr	r1, [r4, #8]
    5c3c:	482d      	ldr	r0, [pc, #180]	; (5cf4 <nvs_init+0x2d4>)
    5c3e:	2203      	movs	r2, #3
    5c40:	f04f 0300 	mov.w	r3, #0
    5c44:	f362 0307 	bfi	r3, r2, #0, #8
    5c48:	f366 138f 	bfi	r3, r6, #6, #10
    5c4c:	b28a      	uxth	r2, r1
    5c4e:	0c09      	lsrs	r1, r1, #16
    5c50:	f01b fa14 	bl	2107c <log_2>
	return 0;
    5c54:	e703      	b.n	5a5e <nvs_init+0x3e>
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
    5c56:	f1b9 0f00 	cmp.w	r9, #0
    5c5a:	d034      	beq.n	5cc6 <nvs_init+0x2a6>
				return -ESPIPE;
    5c5c:	f06f 051c 	mvn.w	r5, #28
    5c60:	e6fd      	b.n	5a5e <nvs_init+0x3e>
		fs->data_wra += fs->write_block_size;
    5c62:	68a3      	ldr	r3, [r4, #8]
    5c64:	7c22      	ldrb	r2, [r4, #16]
    5c66:	4413      	add	r3, r2
    5c68:	60a3      	str	r3, [r4, #8]
    5c6a:	e7a4      	b.n	5bb6 <nvs_init+0x196>
	if (rc) {
    5c6c:	d0bf      	beq.n	5bee <nvs_init+0x1ce>
		rc = nvs_flash_erase_sector(fs, fs->ate_wra);
    5c6e:	6861      	ldr	r1, [r4, #4]
    5c70:	4620      	mov	r0, r4
    5c72:	f7ff fd5d 	bl	5730 <nvs_flash_erase_sector>
		if (rc) {
    5c76:	4605      	mov	r5, r0
    5c78:	2800      	cmp	r0, #0
    5c7a:	d1b8      	bne.n	5bee <nvs_init+0x1ce>
		fs->ate_wra &= ADDR_SECT_MASK;
    5c7c:	6860      	ldr	r0, [r4, #4]
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
    5c7e:	89a3      	ldrh	r3, [r4, #12]
		fs->ate_wra &= ADDR_SECT_MASK;
    5c80:	ea00 0008 	and.w	r0, r0, r8
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
    5c84:	4418      	add	r0, r3
    5c86:	eba0 0047 	sub.w	r0, r0, r7, lsl #1
    5c8a:	6060      	str	r0, [r4, #4]
		fs->data_wra = (fs->ate_wra & ADDR_SECT_MASK);
    5c8c:	ea00 0008 	and.w	r0, r0, r8
    5c90:	60a0      	str	r0, [r4, #8]
		rc = nvs_gc(fs);
    5c92:	4620      	mov	r0, r4
    5c94:	f7ff fe00 	bl	5898 <nvs_gc>
    5c98:	4605      	mov	r5, r0
		if (rc) {
    5c9a:	e7a8      	b.n	5bee <nvs_init+0x1ce>
		if (!nvs_ate_crc8_check(&last_ate)) {
    5c9c:	a801      	add	r0, sp, #4
    5c9e:	f01b fd6a 	bl	21776 <nvs_ate_crc8_check>
    5ca2:	6865      	ldr	r5, [r4, #4]
    5ca4:	b978      	cbnz	r0, 5cc6 <nvs_init+0x2a6>
			fs->data_wra = addr & ADDR_SECT_MASK;
    5ca6:	9800      	ldr	r0, [sp, #0]
			fs->data_wra += last_ate.offset;
    5ca8:	f8bd 2006 	ldrh.w	r2, [sp, #6]
			fs->data_wra += nvs_al_size(fs, last_ate.len);
    5cac:	f8bd 9008 	ldrh.w	r9, [sp, #8]
			fs->data_wra = addr & ADDR_SECT_MASK;
    5cb0:	ea00 0008 	and.w	r0, r0, r8
			fs->data_wra += last_ate.offset;
    5cb4:	4402      	add	r2, r0
			fs->data_wra += nvs_al_size(fs, last_ate.len);
    5cb6:	4649      	mov	r1, r9
    5cb8:	7c20      	ldrb	r0, [r4, #16]
    5cba:	f01b fd71 	bl	217a0 <nvs_al_size.isra.1>
    5cbe:	4410      	add	r0, r2
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
    5cc0:	42a8      	cmp	r0, r5
			fs->data_wra += nvs_al_size(fs, last_ate.len);
    5cc2:	60a0      	str	r0, [r4, #8]
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
    5cc4:	d0c7      	beq.n	5c56 <nvs_init+0x236>
		fs->ate_wra -= ate_size;
    5cc6:	1bed      	subs	r5, r5, r7
    5cc8:	6065      	str	r5, [r4, #4]
    5cca:	e761      	b.n	5b90 <nvs_init+0x170>
    5ccc:	00028540 	.word	0x00028540
    5cd0:	00028658 	.word	0x00028658
    5cd4:	00062235 	.word	0x00062235
    5cd8:	00062251 	.word	0x00062251
    5cdc:	0006226e 	.word	0x0006226e
    5ce0:	00062286 	.word	0x00062286
    5ce4:	0006229a 	.word	0x0006229a
    5ce8:	ffff0000 	.word	0xffff0000
    5cec:	000622bd 	.word	0x000622bd
    5cf0:	000622d4 	.word	0x000622d4
    5cf4:	000622e6 	.word	0x000622e6

00005cf8 <nvs_write>:

ssize_t nvs_write(struct nvs_fs *fs, u16_t id, const void *data, size_t len)
{
    5cf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5cfc:	461e      	mov	r6, r3
	struct nvs_ate wlk_ate;
	u32_t wlk_addr, rd_addr;
	u16_t required_space = 0U; /* no space, appropriate for delete ate */
	bool prev_found = false;

	if (!fs->ready) {
    5cfe:	7c43      	ldrb	r3, [r0, #17]
{
    5d00:	b089      	sub	sp, #36	; 0x24
    5d02:	4604      	mov	r4, r0
    5d04:	4689      	mov	r9, r1
    5d06:	4690      	mov	r8, r2
	if (!fs->ready) {
    5d08:	b99b      	cbnz	r3, 5d32 <nvs_write+0x3a>
		LOG_ERR("NVS not initialized");
    5d0a:	2301      	movs	r3, #1
    5d0c:	f04f 0100 	mov.w	r1, #0
    5d10:	f363 0107 	bfi	r1, r3, #0, #8
    5d14:	4a67      	ldr	r2, [pc, #412]	; (5eb4 <nvs_write+0x1bc>)
    5d16:	4b68      	ldr	r3, [pc, #416]	; (5eb8 <nvs_write+0x1c0>)
    5d18:	4868      	ldr	r0, [pc, #416]	; (5ebc <nvs_write+0x1c4>)
    5d1a:	1a9b      	subs	r3, r3, r2
    5d1c:	08db      	lsrs	r3, r3, #3
    5d1e:	f363 118f 	bfi	r1, r3, #6, #10
    5d22:	f01b f98a 	bl	2103a <log_0>
		return -EACCES;
    5d26:	f06f 050c 	mvn.w	r5, #12
	}
	rc = len;
end:
	k_mutex_unlock(&fs->nvs_lock);
	return rc;
}
    5d2a:	4628      	mov	r0, r5
    5d2c:	b009      	add	sp, #36	; 0x24
    5d2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    5d32:	f890 a010 	ldrb.w	sl, [r0, #16]
    5d36:	2108      	movs	r1, #8
    5d38:	4650      	mov	r0, sl
    5d3a:	f01b fd31 	bl	217a0 <nvs_al_size.isra.1>
	if ((len > (fs->sector_size - 3 * ate_size)) ||
    5d3e:	89a3      	ldrh	r3, [r4, #12]
    5d40:	eb00 0240 	add.w	r2, r0, r0, lsl #1
    5d44:	1a9b      	subs	r3, r3, r2
    5d46:	42b3      	cmp	r3, r6
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    5d48:	4607      	mov	r7, r0
	if ((len > (fs->sector_size - 3 * ate_size)) ||
    5d4a:	f0c0 80ae 	bcc.w	5eaa <nvs_write+0x1b2>
    5d4e:	b11e      	cbz	r6, 5d58 <nvs_write+0x60>
	    ((len > 0) && (data == NULL))) {
    5d50:	f1b8 0f00 	cmp.w	r8, #0
    5d54:	f000 80a9 	beq.w	5eaa <nvs_write+0x1b2>
	wlk_addr = fs->ate_wra;
    5d58:	6863      	ldr	r3, [r4, #4]
    5d5a:	9303      	str	r3, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    5d5c:	aa04      	add	r2, sp, #16
    5d5e:	a903      	add	r1, sp, #12
    5d60:	4620      	mov	r0, r4
		rd_addr = wlk_addr;
    5d62:	f8dd b00c 	ldr.w	fp, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    5d66:	f7ff fd25 	bl	57b4 <nvs_prev_ate>
		if (rc) {
    5d6a:	4605      	mov	r5, r0
    5d6c:	2800      	cmp	r0, #0
    5d6e:	d1dc      	bne.n	5d2a <nvs_write+0x32>
		if ((wlk_ate.id == id) && (!nvs_ate_crc8_check(&wlk_ate))) {
    5d70:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    5d74:	454b      	cmp	r3, r9
    5d76:	d005      	beq.n	5d84 <nvs_write+0x8c>
		if (wlk_addr == fs->ate_wra) {
    5d78:	6862      	ldr	r2, [r4, #4]
    5d7a:	9b03      	ldr	r3, [sp, #12]
    5d7c:	429a      	cmp	r2, r3
    5d7e:	d1ed      	bne.n	5d5c <nvs_write+0x64>
		if (len == 0) {
    5d80:	b9de      	cbnz	r6, 5dba <nvs_write+0xc2>
    5d82:	e7d2      	b.n	5d2a <nvs_write+0x32>
		if ((wlk_ate.id == id) && (!nvs_ate_crc8_check(&wlk_ate))) {
    5d84:	a804      	add	r0, sp, #16
    5d86:	f01b fcf6 	bl	21776 <nvs_ate_crc8_check>
    5d8a:	2800      	cmp	r0, #0
    5d8c:	d1f4      	bne.n	5d78 <nvs_write+0x80>
		if (len == 0) {
    5d8e:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    5d92:	b186      	cbz	r6, 5db6 <nvs_write+0xbe>
		} else if (len == wlk_ate.len) {
    5d94:	42b3      	cmp	r3, r6
    5d96:	d110      	bne.n	5dba <nvs_write+0xc2>
		rd_addr += wlk_ate.offset;
    5d98:	f8bd 0012 	ldrh.w	r0, [sp, #18]
		rd_addr &= ADDR_SECT_MASK;
    5d9c:	ea4f 411b 	mov.w	r1, fp, lsr #16
    5da0:	0409      	lsls	r1, r1, #16
			rc = nvs_flash_block_cmp(fs, rd_addr, data, len);
    5da2:	4401      	add	r1, r0
    5da4:	4633      	mov	r3, r6
    5da6:	4642      	mov	r2, r8
    5da8:	4620      	mov	r0, r4
    5daa:	f01b fcbc 	bl	21726 <nvs_flash_block_cmp>
			if (rc <= 0) {
    5dae:	2800      	cmp	r0, #0
    5db0:	dc03      	bgt.n	5dba <nvs_write+0xc2>
    5db2:	4605      	mov	r5, r0
    5db4:	e7b9      	b.n	5d2a <nvs_write+0x32>
			if (wlk_ate.len == 0U) {
    5db6:	2b00      	cmp	r3, #0
    5db8:	d0b7      	beq.n	5d2a <nvs_write+0x32>
	data_size = nvs_al_size(fs, len);
    5dba:	4631      	mov	r1, r6
    5dbc:	4650      	mov	r0, sl
    5dbe:	f01b fcef 	bl	217a0 <nvs_al_size.isra.1>
	if (data_size) {
    5dc2:	2800      	cmp	r0, #0
    5dc4:	d13e      	bne.n	5e44 <nvs_write+0x14c>
	u16_t required_space = 0U; /* no space, appropriate for delete ate */
    5dc6:	4607      	mov	r7, r0
	k_mutex_lock(&fs->nvs_lock, K_FOREVER);
    5dc8:	f104 0a14 	add.w	sl, r4, #20
	return z_impl_k_mutex_lock(mutex, timeout);
    5dcc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    5dd0:	4650      	mov	r0, sl
	fs->ate_wra &= ADDR_SECT_MASK;
    5dd2:	f8df b0ec 	ldr.w	fp, [pc, #236]	; 5ec0 <nvs_write+0x1c8>
    5dd6:	f018 fbbd 	bl	1e554 <z_impl_k_mutex_lock>
	gc_count = 0;
    5dda:	2300      	movs	r3, #0
		if (gc_count == fs->sector_count) {
    5ddc:	89e2      	ldrh	r2, [r4, #14]
    5dde:	4293      	cmp	r3, r2
    5de0:	d060      	beq.n	5ea4 <nvs_write+0x1ac>
		if (fs->ate_wra >= fs->data_wra + required_space) {
    5de2:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
    5de6:	1878      	adds	r0, r7, r1
    5de8:	4282      	cmp	r2, r0
    5dea:	d32e      	bcc.n	5e4a <nvs_write+0x152>
	entry.part = 0xff;
    5dec:	23ff      	movs	r3, #255	; 0xff
	nvs_ate_crc8_update(&entry);
    5dee:	a806      	add	r0, sp, #24
	entry.id = id;
    5df0:	f8ad 9018 	strh.w	r9, [sp, #24]
	entry.offset = (u16_t)(fs->data_wra & ADDR_OFFS_MASK);
    5df4:	f8ad 101a 	strh.w	r1, [sp, #26]
	entry.len = (u16_t)len;
    5df8:	f8ad 601c 	strh.w	r6, [sp, #28]
	entry.part = 0xff;
    5dfc:	f88d 301e 	strb.w	r3, [sp, #30]
	nvs_ate_crc8_update(&entry);
    5e00:	f01b fcc5 	bl	2178e <nvs_ate_crc8_update>
	if (!len) {
    5e04:	b136      	cbz	r6, 5e14 <nvs_write+0x11c>
    5e06:	4633      	mov	r3, r6
    5e08:	4642      	mov	r2, r8
    5e0a:	68a1      	ldr	r1, [r4, #8]
    5e0c:	4620      	mov	r0, r4
    5e0e:	f01b fcfe 	bl	2180e <nvs_flash_al_wrt.part.3>
    5e12:	4605      	mov	r5, r0
	fs->data_wra += nvs_al_size(fs, len);
    5e14:	4631      	mov	r1, r6
    5e16:	7c20      	ldrb	r0, [r4, #16]
    5e18:	f01b fcc2 	bl	217a0 <nvs_al_size.isra.1>
    5e1c:	68a3      	ldr	r3, [r4, #8]
    5e1e:	4418      	add	r0, r3
    5e20:	60a0      	str	r0, [r4, #8]
	if (rc) {
    5e22:	2d00      	cmp	r5, #0
    5e24:	d144      	bne.n	5eb0 <nvs_write+0x1b8>
	rc = nvs_flash_ate_wrt(fs, &entry);
    5e26:	a906      	add	r1, sp, #24
    5e28:	4620      	mov	r0, r4
    5e2a:	f01b fd36 	bl	2189a <nvs_flash_ate_wrt>
	if (rc) {
    5e2e:	4605      	mov	r5, r0
    5e30:	2800      	cmp	r0, #0
    5e32:	d13d      	bne.n	5eb0 <nvs_write+0x1b8>
	rc = len;
    5e34:	4632      	mov	r2, r6
    5e36:	9201      	str	r2, [sp, #4]
	z_impl_k_mutex_unlock(mutex);
    5e38:	4650      	mov	r0, sl
    5e3a:	f018 fbfd 	bl	1e638 <z_impl_k_mutex_unlock>
	return rc;
    5e3e:	9a01      	ldr	r2, [sp, #4]
    5e40:	4615      	mov	r5, r2
    5e42:	e772      	b.n	5d2a <nvs_write+0x32>
		required_space = data_size + ate_size;
    5e44:	4407      	add	r7, r0
    5e46:	b2bf      	uxth	r7, r7
    5e48:	e7be      	b.n	5dc8 <nvs_write+0xd0>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    5e4a:	2108      	movs	r1, #8
    5e4c:	7c20      	ldrb	r0, [r4, #16]
    5e4e:	9301      	str	r3, [sp, #4]
    5e50:	f01b fca6 	bl	217a0 <nvs_al_size.isra.1>
	close_ate.id = 0xFFFF;
    5e54:	f64f 71ff 	movw	r1, #65535	; 0xffff
    5e58:	f8ad 1018 	strh.w	r1, [sp, #24]
	close_ate.len = 0U;
    5e5c:	2100      	movs	r1, #0
    5e5e:	f8ad 101c 	strh.w	r1, [sp, #28]
	close_ate.offset = (u16_t)((fs->ate_wra + ate_size) & ADDR_OFFS_MASK);
    5e62:	1811      	adds	r1, r2, r0
    5e64:	f8ad 101a 	strh.w	r1, [sp, #26]
	fs->ate_wra += (fs->sector_size - ate_size);
    5e68:	89a1      	ldrh	r1, [r4, #12]
	fs->ate_wra &= ADDR_SECT_MASK;
    5e6a:	ea02 020b 	and.w	r2, r2, fp
	fs->ate_wra += (fs->sector_size - ate_size);
    5e6e:	440a      	add	r2, r1
    5e70:	1a12      	subs	r2, r2, r0
    5e72:	6062      	str	r2, [r4, #4]
	nvs_ate_crc8_update(&close_ate);
    5e74:	a806      	add	r0, sp, #24
    5e76:	f01b fc8a 	bl	2178e <nvs_ate_crc8_update>
	rc = nvs_flash_ate_wrt(fs, &close_ate);
    5e7a:	a906      	add	r1, sp, #24
    5e7c:	4620      	mov	r0, r4
    5e7e:	f01b fd0c 	bl	2189a <nvs_flash_ate_wrt>
	nvs_sector_advance(fs, &fs->ate_wra);
    5e82:	1d21      	adds	r1, r4, #4
    5e84:	89e0      	ldrh	r0, [r4, #14]
    5e86:	f01b fc94 	bl	217b2 <nvs_sector_advance.isra.2>
	fs->data_wra = fs->ate_wra & ADDR_SECT_MASK;
    5e8a:	6862      	ldr	r2, [r4, #4]
    5e8c:	ea02 020b 	and.w	r2, r2, fp
    5e90:	60a2      	str	r2, [r4, #8]
		rc = nvs_gc(fs);
    5e92:	4620      	mov	r0, r4
    5e94:	f7ff fd00 	bl	5898 <nvs_gc>
		if (rc) {
    5e98:	4602      	mov	r2, r0
    5e9a:	2800      	cmp	r0, #0
    5e9c:	d1cb      	bne.n	5e36 <nvs_write+0x13e>
		gc_count++;
    5e9e:	9b01      	ldr	r3, [sp, #4]
    5ea0:	3301      	adds	r3, #1
		if (gc_count == fs->sector_count) {
    5ea2:	e79b      	b.n	5ddc <nvs_write+0xe4>
			rc = -ENOSPC;
    5ea4:	f06f 021b 	mvn.w	r2, #27
    5ea8:	e7c5      	b.n	5e36 <nvs_write+0x13e>
		return -EINVAL;
    5eaa:	f06f 0515 	mvn.w	r5, #21
    5eae:	e73c      	b.n	5d2a <nvs_write+0x32>
			if (rc) {
    5eb0:	462a      	mov	r2, r5
    5eb2:	e7c0      	b.n	5e36 <nvs_write+0x13e>
    5eb4:	00028540 	.word	0x00028540
    5eb8:	00028658 	.word	0x00028658
    5ebc:	000621ea 	.word	0x000621ea
    5ec0:	ffff0000 	.word	0xffff0000

00005ec4 <nvs_read_hist>:
	return nvs_write(fs, id, NULL, 0);
}

ssize_t nvs_read_hist(struct nvs_fs *fs, u16_t id, void *data, size_t len,
		      u16_t cnt)
{
    5ec4:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    5ec8:	461f      	mov	r7, r3
	u32_t wlk_addr, rd_addr;
	u16_t cnt_his;
	struct nvs_ate wlk_ate;
	size_t ate_size;

	if (!fs->ready) {
    5eca:	7c43      	ldrb	r3, [r0, #17]
{
    5ecc:	f8bd 8030 	ldrh.w	r8, [sp, #48]	; 0x30
    5ed0:	4604      	mov	r4, r0
    5ed2:	468a      	mov	sl, r1
    5ed4:	4691      	mov	r9, r2
	if (!fs->ready) {
    5ed6:	b993      	cbnz	r3, 5efe <nvs_read_hist+0x3a>
		LOG_ERR("NVS not initialized");
    5ed8:	2301      	movs	r3, #1
    5eda:	f04f 0100 	mov.w	r1, #0
    5ede:	f363 0107 	bfi	r1, r3, #0, #8
    5ee2:	4a29      	ldr	r2, [pc, #164]	; (5f88 <nvs_read_hist+0xc4>)
    5ee4:	4b29      	ldr	r3, [pc, #164]	; (5f8c <nvs_read_hist+0xc8>)
    5ee6:	482a      	ldr	r0, [pc, #168]	; (5f90 <nvs_read_hist+0xcc>)
    5ee8:	1a9b      	subs	r3, r3, r2
    5eea:	08db      	lsrs	r3, r3, #3
    5eec:	f363 118f 	bfi	r1, r3, #6, #10
    5ef0:	f01b f8a3 	bl	2103a <log_0>
		return -EACCES;
    5ef4:	f06f 000c 	mvn.w	r0, #12

	return wlk_ate.len;

err:
	return rc;
}
    5ef8:	b004      	add	sp, #16
    5efa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    5efe:	2108      	movs	r1, #8
    5f00:	7c00      	ldrb	r0, [r0, #16]
    5f02:	f01b fc4d 	bl	217a0 <nvs_al_size.isra.1>
	if (len > (fs->sector_size - 2 * ate_size)) {
    5f06:	89a3      	ldrh	r3, [r4, #12]
    5f08:	eba3 0040 	sub.w	r0, r3, r0, lsl #1
    5f0c:	42b8      	cmp	r0, r7
    5f0e:	d338      	bcc.n	5f82 <nvs_read_hist+0xbe>
	wlk_addr = fs->ate_wra;
    5f10:	6863      	ldr	r3, [r4, #4]
    5f12:	9301      	str	r3, [sp, #4]
	cnt_his = 0U;
    5f14:	2500      	movs	r5, #0
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    5f16:	aa02      	add	r2, sp, #8
    5f18:	a901      	add	r1, sp, #4
    5f1a:	4620      	mov	r0, r4
		rd_addr = wlk_addr;
    5f1c:	9e01      	ldr	r6, [sp, #4]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    5f1e:	f7ff fc49 	bl	57b4 <nvs_prev_ate>
		if (rc) {
    5f22:	2800      	cmp	r0, #0
    5f24:	d1e8      	bne.n	5ef8 <nvs_read_hist+0x34>
		if ((wlk_ate.id == id) &&  (!nvs_ate_crc8_check(&wlk_ate))) {
    5f26:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    5f2a:	4553      	cmp	r3, sl
    5f2c:	d105      	bne.n	5f3a <nvs_read_hist+0x76>
    5f2e:	a802      	add	r0, sp, #8
    5f30:	f01b fc21 	bl	21776 <nvs_ate_crc8_check>
    5f34:	b908      	cbnz	r0, 5f3a <nvs_read_hist+0x76>
			cnt_his++;
    5f36:	3501      	adds	r5, #1
    5f38:	b2ad      	uxth	r5, r5
		if (wlk_addr == fs->ate_wra) {
    5f3a:	6862      	ldr	r2, [r4, #4]
    5f3c:	9b01      	ldr	r3, [sp, #4]
    5f3e:	429a      	cmp	r2, r3
    5f40:	d018      	beq.n	5f74 <nvs_read_hist+0xb0>
	while (cnt_his <= cnt) {
    5f42:	4545      	cmp	r5, r8
    5f44:	d9e7      	bls.n	5f16 <nvs_read_hist+0x52>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
    5f46:	f8bd 300c 	ldrh.w	r3, [sp, #12]
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
    5f4a:	b1bb      	cbz	r3, 5f7c <nvs_read_hist+0xb8>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
    5f4c:	4545      	cmp	r5, r8
    5f4e:	d315      	bcc.n	5f7c <nvs_read_hist+0xb8>
	rd_addr += wlk_ate.offset;
    5f50:	f8bd 000a 	ldrh.w	r0, [sp, #10]
	rd_addr &= ADDR_SECT_MASK;
    5f54:	0c31      	lsrs	r1, r6, #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
    5f56:	42bb      	cmp	r3, r7
	rd_addr &= ADDR_SECT_MASK;
    5f58:	ea4f 4101 	mov.w	r1, r1, lsl #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
    5f5c:	bf28      	it	cs
    5f5e:	463b      	movcs	r3, r7
    5f60:	4401      	add	r1, r0
    5f62:	464a      	mov	r2, r9
    5f64:	4620      	mov	r0, r4
    5f66:	f01b fbd0 	bl	2170a <nvs_flash_rd>
	if (rc) {
    5f6a:	2800      	cmp	r0, #0
    5f6c:	d1c4      	bne.n	5ef8 <nvs_read_hist+0x34>
	return wlk_ate.len;
    5f6e:	f8bd 000c 	ldrh.w	r0, [sp, #12]
    5f72:	e7c1      	b.n	5ef8 <nvs_read_hist+0x34>
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
    5f74:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    5f78:	4553      	cmp	r3, sl
    5f7a:	d0e4      	beq.n	5f46 <nvs_read_hist+0x82>
		return -ENOENT;
    5f7c:	f06f 0001 	mvn.w	r0, #1
    5f80:	e7ba      	b.n	5ef8 <nvs_read_hist+0x34>
		return -EINVAL;
    5f82:	f06f 0015 	mvn.w	r0, #21
    5f86:	e7b7      	b.n	5ef8 <nvs_read_hist+0x34>
    5f88:	00028540 	.word	0x00028540
    5f8c:	00028658 	.word	0x00028658
    5f90:	000621ea 	.word	0x000621ea

00005f94 <get_flash_area_from_id>:
extern const struct flash_area *flash_map;
extern const int flash_map_entries;

static struct flash_area const *get_flash_area_from_id(int idx)
{
	for (int i = 0; i < flash_map_entries; i++) {
    5f94:	4b08      	ldr	r3, [pc, #32]	; (5fb8 <get_flash_area_from_id+0x24>)
{
    5f96:	b530      	push	{r4, r5, lr}
	for (int i = 0; i < flash_map_entries; i++) {
    5f98:	681d      	ldr	r5, [r3, #0]
		if (flash_map[i].fa_id == idx) {
    5f9a:	4b08      	ldr	r3, [pc, #32]	; (5fbc <get_flash_area_from_id+0x28>)
    5f9c:	6819      	ldr	r1, [r3, #0]
	for (int i = 0; i < flash_map_entries; i++) {
    5f9e:	2300      	movs	r3, #0
    5fa0:	429d      	cmp	r5, r3
    5fa2:	dc02      	bgt.n	5faa <get_flash_area_from_id+0x16>
			return &flash_map[i];
		}
	}

	return NULL;
    5fa4:	2200      	movs	r2, #0
}
    5fa6:	4610      	mov	r0, r2
    5fa8:	bd30      	pop	{r4, r5, pc}
		if (flash_map[i].fa_id == idx) {
    5faa:	011c      	lsls	r4, r3, #4
    5fac:	190a      	adds	r2, r1, r4
    5fae:	5d0c      	ldrb	r4, [r1, r4]
    5fb0:	4284      	cmp	r4, r0
    5fb2:	d0f8      	beq.n	5fa6 <get_flash_area_from_id+0x12>
	for (int i = 0; i < flash_map_entries; i++) {
    5fb4:	3301      	adds	r3, #1
    5fb6:	e7f3      	b.n	5fa0 <get_flash_area_from_id+0xc>
    5fb8:	00028ccc 	.word	0x00028ccc
    5fbc:	2000e748 	.word	0x2000e748

00005fc0 <flash_area_open>:

int flash_area_open(u8_t id, const struct flash_area **fap)
{
	const struct flash_area *area;

	if (flash_map == NULL) {
    5fc0:	4b08      	ldr	r3, [pc, #32]	; (5fe4 <flash_area_open+0x24>)
    5fc2:	681b      	ldr	r3, [r3, #0]
{
    5fc4:	b510      	push	{r4, lr}
    5fc6:	460c      	mov	r4, r1
	if (flash_map == NULL) {
    5fc8:	b12b      	cbz	r3, 5fd6 <flash_area_open+0x16>
		return -EACCES;
	}

	area = get_flash_area_from_id(id);
    5fca:	f7ff ffe3 	bl	5f94 <get_flash_area_from_id>
	if (area == NULL) {
    5fce:	b128      	cbz	r0, 5fdc <flash_area_open+0x1c>
		return -ENOENT;
	}

	*fap = area;
    5fd0:	6020      	str	r0, [r4, #0]
	return 0;
    5fd2:	2000      	movs	r0, #0
}
    5fd4:	bd10      	pop	{r4, pc}
		return -EACCES;
    5fd6:	f06f 000c 	mvn.w	r0, #12
    5fda:	e7fb      	b.n	5fd4 <flash_area_open+0x14>
		return -ENOENT;
    5fdc:	f06f 0001 	mvn.w	r0, #1
    5fe0:	e7f8      	b.n	5fd4 <flash_area_open+0x14>
    5fe2:	bf00      	nop
    5fe4:	2000e748 	.word	0x2000e748

00005fe8 <flash_area_get_sectors>:

	return true;
}

int flash_area_get_sectors(int idx, u32_t *cnt, struct flash_sector *ret)
{
    5fe8:	b530      	push	{r4, r5, lr}
    5fea:	b089      	sub	sp, #36	; 0x24
    5fec:	460c      	mov	r4, r1
    5fee:	4615      	mov	r5, r2
	cb_data->area_idx = idx;
    5ff0:	9001      	str	r0, [sp, #4]
	fa = get_flash_area_from_id(idx);
    5ff2:	f7ff ffcf 	bl	5f94 <get_flash_area_from_id>
	if (fa == NULL) {
    5ff6:	b1b8      	cbz	r0, 6028 <flash_area_get_sectors+0x40>
	cb_data->area_off = fa->fa_off;
    5ff8:	6843      	ldr	r3, [r0, #4]
    5ffa:	9302      	str	r3, [sp, #8]
	cb_data->area_len = fa->fa_size;
    5ffc:	6883      	ldr	r3, [r0, #8]
	cb_data->ret_len = *cnt;
    5ffe:	6822      	ldr	r2, [r4, #0]
	flash_dev = device_get_binding(fa->fa_dev_name);
    6000:	68c0      	ldr	r0, [r0, #12]
	cb_data->ret = ret;
    6002:	e9cd 3503 	strd	r3, r5, [sp, #12]
	cb_data->ret_idx = 0U;
    6006:	2300      	movs	r3, #0
    6008:	9305      	str	r3, [sp, #20]
	cb_data->status = 0;
    600a:	e9cd 2306 	strd	r2, r3, [sp, #24]
    600e:	f018 f807 	bl	1e020 <z_impl_device_get_binding>
	if (flash_dev == NULL) {
    6012:	b160      	cbz	r0, 602e <flash_area_get_sectors+0x46>
	flash_page_foreach(flash_dev, cb, cb_data);
    6014:	aa01      	add	r2, sp, #4
    6016:	4907      	ldr	r1, [pc, #28]	; (6034 <flash_area_get_sectors+0x4c>)
    6018:	f01f f938 	bl	2528c <flash_page_foreach>
	if (cb_data->status == 0) {
    601c:	9807      	ldr	r0, [sp, #28]
    601e:	b908      	cbnz	r0, 6024 <flash_area_get_sectors+0x3c>
		*cnt = cb_data->ret_idx;
    6020:	9b05      	ldr	r3, [sp, #20]
    6022:	6023      	str	r3, [r4, #0]
	struct layout_data data;

	return flash_area_layout(idx, cnt, ret, get_sectors_cb, &data);
}
    6024:	b009      	add	sp, #36	; 0x24
    6026:	bd30      	pop	{r4, r5, pc}
		return -EINVAL;
    6028:	f06f 0015 	mvn.w	r0, #21
    602c:	e7fa      	b.n	6024 <flash_area_get_sectors+0x3c>
		return -ENODEV;
    602e:	f06f 0012 	mvn.w	r0, #18
	return flash_area_layout(idx, cnt, ret, get_sectors_cb, &data);
    6032:	e7f7      	b.n	6024 <flash_area_get_sectors+0x3c>
    6034:	000218d3 	.word	0x000218d3

00006038 <settings_save_one>:
int settings_save_one(const char *name, const void *value, size_t val_len)
{
	int rc;
	struct settings_store *cs;

	cs = settings_save_dst;
    6038:	4b0e      	ldr	r3, [pc, #56]	; (6074 <settings_save_one+0x3c>)
{
    603a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	cs = settings_save_dst;
    603e:	681c      	ldr	r4, [r3, #0]
{
    6040:	4606      	mov	r6, r0
    6042:	460f      	mov	r7, r1
    6044:	4690      	mov	r8, r2
	if (!cs) {
    6046:	b194      	cbz	r4, 606e <settings_save_one+0x36>
	return z_impl_k_mutex_lock(mutex, timeout);
    6048:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    604c:	480a      	ldr	r0, [pc, #40]	; (6078 <settings_save_one+0x40>)
    604e:	f018 fa81 	bl	1e554 <z_impl_k_mutex_lock>
		return -ENOENT;
	}

	k_mutex_lock(&settings_lock, K_FOREVER);

	rc = cs->cs_itf->csi_save(cs, name, (char *)value, val_len);
    6052:	6863      	ldr	r3, [r4, #4]
    6054:	463a      	mov	r2, r7
    6056:	689d      	ldr	r5, [r3, #8]
    6058:	4631      	mov	r1, r6
    605a:	4643      	mov	r3, r8
    605c:	4620      	mov	r0, r4
    605e:	47a8      	blx	r5
    6060:	4604      	mov	r4, r0
	z_impl_k_mutex_unlock(mutex);
    6062:	4805      	ldr	r0, [pc, #20]	; (6078 <settings_save_one+0x40>)
    6064:	f018 fae8 	bl	1e638 <z_impl_k_mutex_unlock>

	k_mutex_unlock(&settings_lock);

	return rc;
}
    6068:	4620      	mov	r0, r4
    606a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENOENT;
    606e:	f06f 0401 	mvn.w	r4, #1
    6072:	e7f9      	b.n	6068 <settings_save_one+0x30>
    6074:	20000174 	.word	0x20000174
    6078:	2000efb8 	.word	0x2000efb8

0000607c <settings_src_register>:
	SYS_SLIST_FOR_EACH_NODE(&settings_load_srcs, cur) {
    607c:	4b0e      	ldr	r3, [pc, #56]	; (60b8 <settings_src_register+0x3c>)
{
    607e:	b510      	push	{r4, lr}
	SYS_SLIST_FOR_EACH_NODE(&settings_load_srcs, cur) {
    6080:	681c      	ldr	r4, [r3, #0]
	prev = NULL;
    6082:	2100      	movs	r1, #0
	SYS_SLIST_FOR_EACH_NODE(&settings_load_srcs, cur) {
    6084:	4622      	mov	r2, r4
    6086:	b932      	cbnz	r2, 6096 <settings_src_register+0x1a>
 */
static inline void sys_slist_insert(sys_slist_t *list,
				    sys_snode_t *prev,
				    sys_snode_t *node);

Z_GENLIST_INSERT(slist, snode)
    6088:	b941      	cbnz	r1, 609c <settings_src_register+0x20>
	parent->next = child;
    608a:	6004      	str	r4, [r0, #0]
Z_GENLIST_PREPEND(slist, snode)
    608c:	685a      	ldr	r2, [r3, #4]
	list->head = node;
    608e:	6018      	str	r0, [r3, #0]
Z_GENLIST_PREPEND(slist, snode)
    6090:	b95a      	cbnz	r2, 60aa <settings_src_register+0x2e>
	list->tail = node;
    6092:	6058      	str	r0, [r3, #4]
    6094:	e009      	b.n	60aa <settings_src_register+0x2e>
    6096:	4611      	mov	r1, r2
    6098:	6812      	ldr	r2, [r2, #0]
    609a:	e7f4      	b.n	6086 <settings_src_register+0xa>
Z_GENLIST_INSERT(slist, snode)
    609c:	680c      	ldr	r4, [r1, #0]
    609e:	b93c      	cbnz	r4, 60b0 <settings_src_register+0x34>
	parent->next = child;
    60a0:	6002      	str	r2, [r0, #0]
Z_GENLIST_APPEND(slist, snode)
    60a2:	685a      	ldr	r2, [r3, #4]
    60a4:	b912      	cbnz	r2, 60ac <settings_src_register+0x30>
	list->head = node;
    60a6:	e9c3 0000 	strd	r0, r0, [r3]
}
    60aa:	bd10      	pop	{r4, pc}
	parent->next = child;
    60ac:	6010      	str	r0, [r2, #0]
    60ae:	e7f0      	b.n	6092 <settings_src_register+0x16>
    60b0:	6004      	str	r4, [r0, #0]
    60b2:	6008      	str	r0, [r1, #0]
    60b4:	e7f9      	b.n	60aa <settings_src_register+0x2e>
    60b6:	bf00      	nop
    60b8:	2000016c 	.word	0x2000016c

000060bc <settings_dst_register>:
	settings_save_dst = cs;
    60bc:	4b01      	ldr	r3, [pc, #4]	; (60c4 <settings_dst_register+0x8>)
    60be:	6018      	str	r0, [r3, #0]
}
    60c0:	4770      	bx	lr
    60c2:	bf00      	nop
    60c4:	20000174 	.word	0x20000174

000060c8 <settings_load_subtree_direct>:
{
    60c8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	const struct settings_load_arg arg = {
    60ca:	e9cd 0101 	strd	r0, r1, [sp, #4]
    60ce:	9203      	str	r2, [sp, #12]
	return z_impl_k_mutex_lock(mutex, timeout);
    60d0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    60d4:	4809      	ldr	r0, [pc, #36]	; (60fc <settings_load_subtree_direct+0x34>)
    60d6:	f018 fa3d 	bl	1e554 <z_impl_k_mutex_lock>
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
    60da:	4b09      	ldr	r3, [pc, #36]	; (6100 <settings_load_subtree_direct+0x38>)
    60dc:	681c      	ldr	r4, [r3, #0]
    60de:	b134      	cbz	r4, 60ee <settings_load_subtree_direct+0x26>
		cs->cs_itf->csi_load(cs, &arg);
    60e0:	6863      	ldr	r3, [r4, #4]
    60e2:	4620      	mov	r0, r4
    60e4:	681b      	ldr	r3, [r3, #0]
    60e6:	a901      	add	r1, sp, #4
    60e8:	4798      	blx	r3
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    60ea:	6824      	ldr	r4, [r4, #0]
	return node->next;
    60ec:	e7f7      	b.n	60de <settings_load_subtree_direct+0x16>
	z_impl_k_mutex_unlock(mutex);
    60ee:	4803      	ldr	r0, [pc, #12]	; (60fc <settings_load_subtree_direct+0x34>)
    60f0:	f018 faa2 	bl	1e638 <z_impl_k_mutex_unlock>
}
    60f4:	2000      	movs	r0, #0
    60f6:	b004      	add	sp, #16
    60f8:	bd10      	pop	{r4, pc}
    60fa:	bf00      	nop
    60fc:	2000efb8 	.word	0x2000efb8
    6100:	2000016c 	.word	0x2000016c

00006104 <settings_store_init>:
	list->head = NULL;
    6104:	4b02      	ldr	r3, [pc, #8]	; (6110 <settings_store_init+0xc>)
    6106:	2200      	movs	r2, #0
	list->tail = NULL;
    6108:	e9c3 2200 	strd	r2, r2, [r3]
}

void settings_store_init(void)
{
	sys_slist_init(&settings_load_srcs);
}
    610c:	4770      	bx	lr
    610e:	bf00      	nop
    6110:	2000016c 	.word	0x2000016c

00006114 <settings_init>:
	list->head = NULL;
    6114:	4b02      	ldr	r3, [pc, #8]	; (6120 <settings_init+0xc>)
    6116:	2200      	movs	r2, #0
	list->tail = NULL;
    6118:	e9c3 2200 	strd	r2, r2, [r3]
void settings_init(void)
{
#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	sys_slist_init(&settings_handlers);
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */
	settings_store_init();
    611c:	f7ff bff2 	b.w	6104 <settings_store_init>
    6120:	20000178 	.word	0x20000178

00006124 <settings_parse_and_lookup>:
	return rc;
}

struct settings_handler_static *settings_parse_and_lookup(const char *name,
							const char **next)
{
    6124:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    6128:	4607      	mov	r7, r0
	struct settings_handler_static *bestmatch;
	const char *tmpnext;

	bestmatch = NULL;
	if (next) {
    612a:	460e      	mov	r6, r1
    612c:	b109      	cbz	r1, 6132 <settings_parse_and_lookup+0xe>
		*next = NULL;
    612e:	2300      	movs	r3, #0
    6130:	600b      	str	r3, [r1, #0]
    6132:	4c1c      	ldr	r4, [pc, #112]	; (61a4 <settings_parse_and_lookup+0x80>)
	}

	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    6134:	f8df 8074 	ldr.w	r8, [pc, #116]	; 61ac <settings_parse_and_lookup+0x88>
    6138:	2500      	movs	r5, #0
    613a:	4544      	cmp	r4, r8
    613c:	d308      	bcc.n	6150 <settings_parse_and_lookup+0x2c>
	}

#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	struct settings_handler *ch;

	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
    613e:	4b1a      	ldr	r3, [pc, #104]	; (61a8 <settings_parse_and_lookup+0x84>)
    6140:	681c      	ldr	r4, [r3, #0]
    6142:	b10c      	cbz	r4, 6148 <settings_parse_and_lookup+0x24>
    6144:	3c14      	subs	r4, #20
    6146:	b9c4      	cbnz	r4, 617a <settings_parse_and_lookup+0x56>
			}
		}
	}
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */
	return bestmatch;
}
    6148:	4628      	mov	r0, r5
    614a:	b002      	add	sp, #8
    614c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
    6150:	aa01      	add	r2, sp, #4
    6152:	6821      	ldr	r1, [r4, #0]
    6154:	4638      	mov	r0, r7
    6156:	f01b fbde 	bl	21916 <settings_name_steq>
    615a:	b160      	cbz	r0, 6176 <settings_parse_and_lookup+0x52>
		if (!bestmatch) {
    615c:	b925      	cbnz	r5, 6168 <settings_parse_and_lookup+0x44>
			if (next) {
    615e:	b10e      	cbz	r6, 6164 <settings_parse_and_lookup+0x40>
				*next = tmpnext;
    6160:	9b01      	ldr	r3, [sp, #4]
    6162:	6033      	str	r3, [r6, #0]
    6164:	4625      	mov	r5, r4
    6166:	e006      	b.n	6176 <settings_parse_and_lookup+0x52>
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
    6168:	2200      	movs	r2, #0
    616a:	6829      	ldr	r1, [r5, #0]
    616c:	6820      	ldr	r0, [r4, #0]
    616e:	f01b fbd2 	bl	21916 <settings_name_steq>
    6172:	2800      	cmp	r0, #0
    6174:	d1f3      	bne.n	615e <settings_parse_and_lookup+0x3a>
	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    6176:	3414      	adds	r4, #20
    6178:	e7df      	b.n	613a <settings_parse_and_lookup+0x16>
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
    617a:	aa01      	add	r2, sp, #4
    617c:	6821      	ldr	r1, [r4, #0]
    617e:	4638      	mov	r0, r7
    6180:	f01b fbc9 	bl	21916 <settings_name_steq>
    6184:	b160      	cbz	r0, 61a0 <settings_parse_and_lookup+0x7c>
		if (!bestmatch) {
    6186:	b925      	cbnz	r5, 6192 <settings_parse_and_lookup+0x6e>
			if (next) {
    6188:	b10e      	cbz	r6, 618e <settings_parse_and_lookup+0x6a>
				*next = tmpnext;
    618a:	9b01      	ldr	r3, [sp, #4]
    618c:	6033      	str	r3, [r6, #0]
    618e:	4625      	mov	r5, r4
    6190:	e006      	b.n	61a0 <settings_parse_and_lookup+0x7c>
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
    6192:	2200      	movs	r2, #0
    6194:	6829      	ldr	r1, [r5, #0]
    6196:	6820      	ldr	r0, [r4, #0]
    6198:	f01b fbbd 	bl	21916 <settings_name_steq>
    619c:	2800      	cmp	r0, #0
    619e:	d1f3      	bne.n	6188 <settings_parse_and_lookup+0x64>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    61a0:	6964      	ldr	r4, [r4, #20]
    61a2:	e7ce      	b.n	6142 <settings_parse_and_lookup+0x1e>
    61a4:	000284c8 	.word	0x000284c8
    61a8:	20000178 	.word	0x20000178
    61ac:	00028540 	.word	0x00028540

000061b0 <settings_call_set_handler>:
int settings_call_set_handler(const char *name,
			      size_t len,
			      settings_read_cb read_cb,
			      void *read_cb_arg,
			      const struct settings_load_arg *load_arg)
{
    61b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    61b4:	b085      	sub	sp, #20
    61b6:	4605      	mov	r5, r0
    61b8:	9c0c      	ldr	r4, [sp, #48]	; 0x30
	int rc;
	const char *name_key = name;
    61ba:	9003      	str	r0, [sp, #12]
{
    61bc:	460e      	mov	r6, r1
    61be:	4617      	mov	r7, r2
    61c0:	4698      	mov	r8, r3

	if (load_arg && load_arg->subtree &&
    61c2:	b1b4      	cbz	r4, 61f2 <settings_call_set_handler+0x42>
    61c4:	6821      	ldr	r1, [r4, #0]
    61c6:	b179      	cbz	r1, 61e8 <settings_call_set_handler+0x38>
	    !settings_name_steq(name, load_arg->subtree, &name_key)) {
    61c8:	aa03      	add	r2, sp, #12
    61ca:	f01b fba4 	bl	21916 <settings_name_steq>
	if (load_arg && load_arg->subtree &&
    61ce:	b958      	cbnz	r0, 61e8 <settings_call_set_handler+0x38>

		if (rc != 0) {
			LOG_ERR("set-value failure. key: %s error(%d)",
				log_strdup(name), rc);
			/* Ignoring the error */
			rc = 0;
    61d0:	2000      	movs	r0, #0
    61d2:	e006      	b.n	61e2 <settings_call_set_handler+0x32>
		rc = load_arg->cb(name_key, len, read_cb, read_cb_arg,
    61d4:	68a3      	ldr	r3, [r4, #8]
    61d6:	9300      	str	r3, [sp, #0]
    61d8:	463a      	mov	r2, r7
    61da:	4643      	mov	r3, r8
    61dc:	4631      	mov	r1, r6
    61de:	9803      	ldr	r0, [sp, #12]
    61e0:	47c8      	blx	r9
			LOG_DBG("set-value OK. key: %s",
				log_strdup(name));
		}
	}
	return rc;
}
    61e2:	b005      	add	sp, #20
    61e4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (load_arg && load_arg->cb) {
    61e8:	f8d4 9004 	ldr.w	r9, [r4, #4]
    61ec:	f1b9 0f00 	cmp.w	r9, #0
    61f0:	d1f0      	bne.n	61d4 <settings_call_set_handler+0x24>
		ch = settings_parse_and_lookup(name, &name_key);
    61f2:	a903      	add	r1, sp, #12
    61f4:	4628      	mov	r0, r5
    61f6:	f7ff ff95 	bl	6124 <settings_parse_and_lookup>
		if (!ch) {
    61fa:	2800      	cmp	r0, #0
    61fc:	d0e8      	beq.n	61d0 <settings_call_set_handler+0x20>
		rc = ch->h_set(name_key, len, read_cb, read_cb_arg);
    61fe:	6884      	ldr	r4, [r0, #8]
    6200:	9803      	ldr	r0, [sp, #12]
    6202:	4631      	mov	r1, r6
    6204:	4643      	mov	r3, r8
    6206:	463a      	mov	r2, r7
    6208:	47a0      	blx	r4
		if (rc != 0) {
    620a:	4606      	mov	r6, r0
    620c:	2800      	cmp	r0, #0
    620e:	d0df      	beq.n	61d0 <settings_call_set_handler+0x20>
			LOG_ERR("set-value failure. key: %s error(%d)",
    6210:	2301      	movs	r3, #1
    6212:	f04f 0400 	mov.w	r4, #0
    6216:	f363 0407 	bfi	r4, r3, #0, #8
    621a:	4908      	ldr	r1, [pc, #32]	; (623c <settings_call_set_handler+0x8c>)
    621c:	4b08      	ldr	r3, [pc, #32]	; (6240 <settings_call_set_handler+0x90>)
    621e:	1ac9      	subs	r1, r1, r3
    6220:	08c9      	lsrs	r1, r1, #3
    6222:	4628      	mov	r0, r5
    6224:	f361 148f 	bfi	r4, r1, #6, #10
    6228:	f7fe fd6a 	bl	4d00 <log_strdup>
    622c:	4623      	mov	r3, r4
    622e:	4601      	mov	r1, r0
    6230:	4632      	mov	r2, r6
    6232:	4804      	ldr	r0, [pc, #16]	; (6244 <settings_call_set_handler+0x94>)
    6234:	f01a ff22 	bl	2107c <log_2>
    6238:	e7ca      	b.n	61d0 <settings_call_set_handler+0x20>
    623a:	bf00      	nop
    623c:	000286a0 	.word	0x000286a0
    6240:	00028540 	.word	0x00028540
    6244:	00062311 	.word	0x00062311

00006248 <settings_subsys_init>:
void settings_init(void);

int settings_backend_init(void);

int settings_subsys_init(void)
{
    6248:	b510      	push	{r4, lr}

	int err = 0;

	if (settings_subsys_initialized) {
    624a:	4c06      	ldr	r4, [pc, #24]	; (6264 <settings_subsys_init+0x1c>)
    624c:	7823      	ldrb	r3, [r4, #0]
    624e:	b93b      	cbnz	r3, 6260 <settings_subsys_init+0x18>
		return 0;
	}

	settings_init();
    6250:	f7ff ff60 	bl	6114 <settings_init>

	err = settings_backend_init(); /* func rises kernel panic once error */
    6254:	f000 f864 	bl	6320 <settings_backend_init>

	if (!err) {
    6258:	b908      	cbnz	r0, 625e <settings_subsys_init+0x16>
		settings_subsys_initialized = true;
    625a:	2301      	movs	r3, #1
    625c:	7023      	strb	r3, [r4, #0]
	}

	return err;
}
    625e:	bd10      	pop	{r4, pc}
		return 0;
    6260:	2000      	movs	r0, #0
    6262:	e7fc      	b.n	625e <settings_subsys_init+0x16>
    6264:	20006168 	.word	0x20006168

00006268 <settings_nvs_load>:
	return 0;
}

static int settings_nvs_load(struct settings_store *cs,
			     const struct settings_load_arg *arg)
{
    6268:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	char name[SETTINGS_MAX_NAME_LEN + SETTINGS_EXTRA_LEN + 1];
	char buf;
	ssize_t rc1, rc2;
	u16_t name_id = NVS_NAMECNT_ID;

	name_id = cf->last_name_id + 1;
    626c:	8e84      	ldrh	r4, [r0, #52]	; 0x34
		/* Found a name, this might not include a trailing \0 */
		name[rc1] = '\0';
		read_fn_arg.fs = &cf->cf_nvs;
		read_fn_arg.id = name_id + NVS_NAME_ID_OFFSET;

		ret = settings_call_set_handler(
    626e:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 631c <settings_nvs_load+0xb4>
	name_id = cf->last_name_id + 1;
    6272:	3401      	adds	r4, #1
{
    6274:	b098      	sub	sp, #96	; 0x60
    6276:	4680      	mov	r8, r0
    6278:	468a      	mov	sl, r1
	name_id = cf->last_name_id + 1;
    627a:	b2a4      	uxth	r4, r4
		rc1 = nvs_read(&cf->cf_nvs, name_id, &name, sizeof(name));
    627c:	f100 0608 	add.w	r6, r0, #8
		name_id--;
    6280:	1e65      	subs	r5, r4, #1
    6282:	b2ad      	uxth	r5, r5
		if (name_id == NVS_NAMECNT_ID) {
    6284:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
    6288:	d045      	beq.n	6316 <settings_nvs_load+0xae>
		rc1 = nvs_read(&cf->cf_nvs, name_id, &name, sizeof(name));
    628a:	234a      	movs	r3, #74	; 0x4a
    628c:	aa05      	add	r2, sp, #20
    628e:	4629      	mov	r1, r5
    6290:	4630      	mov	r0, r6
    6292:	f01b fb17 	bl	218c4 <nvs_read>
    6296:	f504 547f 	add.w	r4, r4, #16320	; 0x3fc0
    629a:	343f      	adds	r4, #63	; 0x3f
    629c:	b2a4      	uxth	r4, r4
    629e:	4607      	mov	r7, r0
		rc2 = nvs_read(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET,
    62a0:	4621      	mov	r1, r4
    62a2:	2301      	movs	r3, #1
    62a4:	f10d 020b 	add.w	r2, sp, #11
    62a8:	4630      	mov	r0, r6
    62aa:	f01b fb0b 	bl	218c4 <nvs_read>
		if ((rc1 <= 0) && (rc2 <= 0)) {
    62ae:	2f00      	cmp	r7, #0
		rc2 = nvs_read(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET,
    62b0:	4601      	mov	r1, r0
		if ((rc1 <= 0) && (rc2 <= 0)) {
    62b2:	dc03      	bgt.n	62bc <settings_nvs_load+0x54>
    62b4:	2800      	cmp	r0, #0
    62b6:	dc03      	bgt.n	62c0 <settings_nvs_load+0x58>
{
    62b8:	462c      	mov	r4, r5
    62ba:	e7e1      	b.n	6280 <settings_nvs_load+0x18>
		if ((rc1 <= 0) || (rc2 <= 0)) {
    62bc:	2800      	cmp	r0, #0
    62be:	dc16      	bgt.n	62ee <settings_nvs_load+0x86>
			if (name_id == cf->last_name_id) {
    62c0:	f8b8 3034 	ldrh.w	r3, [r8, #52]	; 0x34
    62c4:	42ab      	cmp	r3, r5
    62c6:	d109      	bne.n	62dc <settings_nvs_load+0x74>
				cf->last_name_id--;
    62c8:	4642      	mov	r2, r8
    62ca:	1e6b      	subs	r3, r5, #1
    62cc:	f822 3f34 	strh.w	r3, [r2, #52]!
				nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID,
    62d0:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    62d4:	2302      	movs	r3, #2
    62d6:	4630      	mov	r0, r6
    62d8:	f7ff fd0e 	bl	5cf8 <nvs_write>
			nvs_delete(&cf->cf_nvs, name_id);
    62dc:	4629      	mov	r1, r5
    62de:	4630      	mov	r0, r6
    62e0:	f01b faec 	bl	218bc <nvs_delete>
			nvs_delete(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET);
    62e4:	4621      	mov	r1, r4
    62e6:	4630      	mov	r0, r6
    62e8:	f01b fae8 	bl	218bc <nvs_delete>
			continue;
    62ec:	e7e4      	b.n	62b8 <settings_nvs_load+0x50>
		name[rc1] = '\0';
    62ee:	ab18      	add	r3, sp, #96	; 0x60
    62f0:	441f      	add	r7, r3
    62f2:	2300      	movs	r3, #0
    62f4:	f807 3c4c 	strb.w	r3, [r7, #-76]
		ret = settings_call_set_handler(
    62f8:	464a      	mov	r2, r9
    62fa:	f8cd a000 	str.w	sl, [sp]
    62fe:	ab03      	add	r3, sp, #12
    6300:	a805      	add	r0, sp, #20
		read_fn_arg.fs = &cf->cf_nvs;
    6302:	9603      	str	r6, [sp, #12]
		read_fn_arg.id = name_id + NVS_NAME_ID_OFFSET;
    6304:	f8ad 4010 	strh.w	r4, [sp, #16]
		ret = settings_call_set_handler(
    6308:	f7ff ff52 	bl	61b0 <settings_call_set_handler>
			name, rc2,
			settings_nvs_read_fn, &read_fn_arg,
			(void *)arg);
		if (ret) {
    630c:	2800      	cmp	r0, #0
    630e:	d0d3      	beq.n	62b8 <settings_nvs_load+0x50>
			break;
		}
	}
	return ret;
}
    6310:	b018      	add	sp, #96	; 0x60
    6312:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6316:	2000      	movs	r0, #0
	return ret;
    6318:	e7fa      	b.n	6310 <settings_nvs_load+0xa8>
    631a:	bf00      	nop
    631c:	00021983 	.word	0x00021983

00006320 <settings_backend_init>:
	LOG_DBG("Initialized");
	return 0;
}

int settings_backend_init(void)
{
    6320:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	int rc;
	u16_t cnt = 0;
	size_t nvs_sector_size, nvs_size = 0;
	const struct flash_area *fa;
	struct flash_sector hw_flash_sector;
	u32_t sector_cnt = 1;
    6322:	2301      	movs	r3, #1

	rc = flash_area_open(DT_FLASH_AREA_STORAGE_ID, &fa);
    6324:	4669      	mov	r1, sp
    6326:	2004      	movs	r0, #4
	u32_t sector_cnt = 1;
    6328:	9301      	str	r3, [sp, #4]
	rc = flash_area_open(DT_FLASH_AREA_STORAGE_ID, &fa);
    632a:	f7ff fe49 	bl	5fc0 <flash_area_open>
	if (rc) {
    632e:	4604      	mov	r4, r0
    6330:	2800      	cmp	r0, #0
    6332:	d137      	bne.n	63a4 <settings_backend_init+0x84>
		return rc;
	}

	rc = flash_area_get_sectors(DT_FLASH_AREA_STORAGE_ID, &sector_cnt,
    6334:	aa02      	add	r2, sp, #8
    6336:	a901      	add	r1, sp, #4
    6338:	2004      	movs	r0, #4
    633a:	f7ff fe55 	bl	5fe8 <flash_area_get_sectors>
				    &hw_flash_sector);
	if (rc == -ENODEV) {
    633e:	f110 0f13 	cmn.w	r0, #19
	rc = flash_area_get_sectors(DT_FLASH_AREA_STORAGE_ID, &sector_cnt,
    6342:	4604      	mov	r4, r0
	if (rc == -ENODEV) {
    6344:	d02e      	beq.n	63a4 <settings_backend_init+0x84>
		return rc;
	} else if (rc != 0 && rc != -ENOMEM) {
    6346:	b140      	cbz	r0, 635a <settings_backend_init+0x3a>
    6348:	f110 040c 	adds.w	r4, r0, #12
    634c:	d005      	beq.n	635a <settings_backend_init+0x3a>
		k_panic();
    634e:	4040      	eors	r0, r0
    6350:	f380 8811 	msr	BASEPRI, r0
    6354:	f04f 0004 	mov.w	r0, #4
    6358:	df02      	svc	2
	}

	nvs_sector_size = CONFIG_SETTINGS_NVS_SECTOR_SIZE_MULT *
    635a:	9903      	ldr	r1, [sp, #12]
			  hw_flash_sector.fs_size;

	if (nvs_sector_size > UINT16_MAX) {
    635c:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
    6360:	d223      	bcs.n	63aa <settings_backend_init+0x8a>
		return -EDOM;
	}

	while (cnt < CONFIG_SETTINGS_NVS_SECTOR_COUNT) {
		nvs_size += nvs_sector_size;
		if (nvs_size > fa->fa_size) {
    6362:	9a00      	ldr	r2, [sp, #0]
    6364:	2300      	movs	r3, #0
    6366:	6895      	ldr	r5, [r2, #8]
	size_t nvs_sector_size, nvs_size = 0;
    6368:	4618      	mov	r0, r3
		nvs_size += nvs_sector_size;
    636a:	4408      	add	r0, r1
		if (nvs_size > fa->fa_size) {
    636c:	4285      	cmp	r5, r0
    636e:	b29c      	uxth	r4, r3
    6370:	d303      	bcc.n	637a <settings_backend_init+0x5a>
			break;
		}
		cnt++;
    6372:	3301      	adds	r3, #1
	while (cnt < CONFIG_SETTINGS_NVS_SECTOR_COUNT) {
    6374:	2b08      	cmp	r3, #8
    6376:	d1f8      	bne.n	636a <settings_backend_init+0x4a>
    6378:	461c      	mov	r4, r3
	}

	/* define the nvs file system using the page_info */
	default_settings_nvs.cf_nvs.sector_size = nvs_sector_size;
    637a:	4d0d      	ldr	r5, [pc, #52]	; (63b0 <settings_backend_init+0x90>)
	default_settings_nvs.cf_nvs.sector_count = cnt;
	default_settings_nvs.cf_nvs.offset = fa->fa_off;
    637c:	6853      	ldr	r3, [r2, #4]
    637e:	60ab      	str	r3, [r5, #8]
	default_settings_nvs.flash_dev_name = fa->fa_dev_name;

	rc = settings_nvs_backend_init(&default_settings_nvs);
    6380:	4628      	mov	r0, r5
	default_settings_nvs.flash_dev_name = fa->fa_dev_name;
    6382:	68d3      	ldr	r3, [r2, #12]
	default_settings_nvs.cf_nvs.sector_count = cnt;
    6384:	82ec      	strh	r4, [r5, #22]
	default_settings_nvs.cf_nvs.sector_size = nvs_sector_size;
    6386:	82a9      	strh	r1, [r5, #20]
	default_settings_nvs.flash_dev_name = fa->fa_dev_name;
    6388:	63ab      	str	r3, [r5, #56]	; 0x38
	rc = settings_nvs_backend_init(&default_settings_nvs);
    638a:	f01b fb8f 	bl	21aac <settings_nvs_backend_init>
	if (rc) {
    638e:	4604      	mov	r4, r0
    6390:	b940      	cbnz	r0, 63a4 <settings_backend_init+0x84>
	cf->cf_store.cs_itf = &settings_nvs_itf;
    6392:	4e08      	ldr	r6, [pc, #32]	; (63b4 <settings_backend_init+0x94>)
    6394:	606e      	str	r6, [r5, #4]
	settings_src_register(&cf->cf_store);
    6396:	4628      	mov	r0, r5
    6398:	f7ff fe70 	bl	607c <settings_src_register>
	settings_dst_register(&cf->cf_store);
    639c:	4628      	mov	r0, r5
	cf->cf_store.cs_itf = &settings_nvs_itf;
    639e:	606e      	str	r6, [r5, #4]
	settings_dst_register(&cf->cf_store);
    63a0:	f7ff fe8c 	bl	60bc <settings_dst_register>
	}

	rc = settings_nvs_dst(&default_settings_nvs);

	return rc;
}
    63a4:	4620      	mov	r0, r4
    63a6:	b004      	add	sp, #16
    63a8:	bd70      	pop	{r4, r5, r6, pc}
		return -EDOM;
    63aa:	f06f 0420 	mvn.w	r4, #32
    63ae:	e7f9      	b.n	63a4 <settings_backend_init+0x84>
    63b0:	20000180 	.word	0x20000180
    63b4:	2000e74c 	.word	0x2000e74c

000063b8 <nrf_power_clock_isr>:
#endif
}

NRF_STATIC_INLINE bool nrf_clock_event_check(NRF_CLOCK_Type const * p_reg, nrf_clock_event_t event)
{
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    63b8:	4b16      	ldr	r3, [pc, #88]	; (6414 <nrf_power_clock_isr+0x5c>)
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
    63ba:	b507      	push	{r0, r1, r2, lr}
    63bc:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
    63be:	b182      	cbz	r2, 63e2 <nrf_power_clock_isr+0x2a>
    return p_reg->INTENSET & mask;
    63c0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    63c4:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
    63c8:	07d1      	lsls	r1, r2, #31
    63ca:	d50a      	bpl.n	63e2 <nrf_power_clock_isr+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    63cc:	2200      	movs	r2, #0
    63ce:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    63d0:	681b      	ldr	r3, [r3, #0]
	struct device *dev = DEVICE_GET(clock_nrf);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    63d2:	4811      	ldr	r0, [pc, #68]	; (6418 <nrf_power_clock_isr+0x60>)
    63d4:	9300      	str	r3, [sp, #0]
    (void)dummy;
    63d6:	9b00      	ldr	r3, [sp, #0]

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
    63d8:	6883      	ldr	r3, [r0, #8]
    63da:	7a59      	ldrb	r1, [r3, #9]
    63dc:	b909      	cbnz	r1, 63e2 <nrf_power_clock_isr+0x2a>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    63de:	f01b fb8f 	bl	21b00 <clkstarted_handle>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    63e2:	4b0e      	ldr	r3, [pc, #56]	; (641c <nrf_power_clock_isr+0x64>)
    63e4:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
    63e6:	b18a      	cbz	r2, 640c <nrf_power_clock_isr+0x54>
    return p_reg->INTENSET & mask;
    63e8:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    63ec:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
    63f0:	0792      	lsls	r2, r2, #30
    63f2:	d50b      	bpl.n	640c <nrf_power_clock_isr+0x54>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    63f4:	2200      	movs	r2, #0
    63f6:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    63f8:	681b      	ldr	r3, [r3, #0]
    63fa:	9301      	str	r3, [sp, #4]
    (void)dummy;
    63fc:	9b01      	ldr	r3, [sp, #4]
					NRF_CLOCK_INT_LF_STARTED_MASK)) {
		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started(dev);
		}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    63fe:	4806      	ldr	r0, [pc, #24]	; (6418 <nrf_power_clock_isr+0x60>)
    6400:	2101      	movs	r1, #1
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
    6402:	b003      	add	sp, #12
    6404:	f85d eb04 	ldr.w	lr, [sp], #4
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    6408:	f01b bb7a 	b.w	21b00 <clkstarted_handle>
}
    640c:	b003      	add	sp, #12
    640e:	f85d fb04 	ldr.w	pc, [sp], #4
    6412:	bf00      	nop
    6414:	40000100 	.word	0x40000100
    6418:	2000ee30 	.word	0x2000ee30
    641c:	40000104 	.word	0x40000104

00006420 <st7789v_set_orientation>:
	return -ENOTSUP;
}

static int st7789v_set_orientation(const struct device *dev,
			    const enum display_orientation orientation)
{
    6420:	b508      	push	{r3, lr}
	if (orientation == DISPLAY_ORIENTATION_NORMAL) {
    6422:	b181      	cbz	r1, 6446 <st7789v_set_orientation+0x26>
		return 0;
	}
	LOG_ERR("Changing display orientation not implemented");
    6424:	2301      	movs	r3, #1
    6426:	f04f 0100 	mov.w	r1, #0
    642a:	f363 0107 	bfi	r1, r3, #0, #8
    642e:	4a07      	ldr	r2, [pc, #28]	; (644c <st7789v_set_orientation+0x2c>)
    6430:	4b07      	ldr	r3, [pc, #28]	; (6450 <st7789v_set_orientation+0x30>)
    6432:	4808      	ldr	r0, [pc, #32]	; (6454 <st7789v_set_orientation+0x34>)
    6434:	1a9b      	subs	r3, r3, r2
    6436:	08db      	lsrs	r3, r3, #3
    6438:	f363 118f 	bfi	r1, r3, #6, #10
    643c:	f01a fdfd 	bl	2103a <log_0>
	return -ENOTSUP;
    6440:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
    6444:	bd08      	pop	{r3, pc}
		return 0;
    6446:	4608      	mov	r0, r1
    6448:	e7fc      	b.n	6444 <st7789v_set_orientation+0x24>
    644a:	bf00      	nop
    644c:	00028540 	.word	0x00028540
    6450:	00028650 	.word	0x00028650
    6454:	00062414 	.word	0x00062414

00006458 <st7789v_set_pixel_format>:
	if (pixel_format == PIXEL_FORMAT_RGB_565) {
    6458:	2910      	cmp	r1, #16
{
    645a:	b508      	push	{r3, lr}
	if (pixel_format == PIXEL_FORMAT_RGB_565) {
    645c:	d010      	beq.n	6480 <st7789v_set_pixel_format+0x28>
	LOG_ERR("Pixel format change not implemented");
    645e:	2301      	movs	r3, #1
    6460:	f04f 0100 	mov.w	r1, #0
    6464:	f363 0107 	bfi	r1, r3, #0, #8
    6468:	4a06      	ldr	r2, [pc, #24]	; (6484 <st7789v_set_pixel_format+0x2c>)
    646a:	4b07      	ldr	r3, [pc, #28]	; (6488 <st7789v_set_pixel_format+0x30>)
    646c:	4807      	ldr	r0, [pc, #28]	; (648c <st7789v_set_pixel_format+0x34>)
    646e:	1a9b      	subs	r3, r3, r2
    6470:	08db      	lsrs	r3, r3, #3
    6472:	f363 118f 	bfi	r1, r3, #6, #10
    6476:	f01a fde0 	bl	2103a <log_0>
	return -ENOTSUP;
    647a:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
    647e:	bd08      	pop	{r3, pc}
		return 0;
    6480:	2000      	movs	r0, #0
    6482:	e7fc      	b.n	647e <st7789v_set_pixel_format+0x26>
    6484:	00028540 	.word	0x00028540
    6488:	00028650 	.word	0x00028650
    648c:	00062441 	.word	0x00062441

00006490 <st7789v_init>:
	st7789v_transmit(p_st7789v, ST7789V_CMD_RGBCTRL, st7789v_rgb_param,
			 sizeof(st7789v_rgb_param));
}

static int st7789v_init(struct device *dev)
{
    6490:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    6494:	4607      	mov	r7, r0
	struct st7789v_data *data = (struct st7789v_data *)dev->driver_data;
    6496:	6884      	ldr	r4, [r0, #8]
    6498:	489e      	ldr	r0, [pc, #632]	; (6714 <st7789v_init+0x284>)
    649a:	f017 fdc1 	bl	1e020 <z_impl_device_get_binding>

	data->spi_dev = device_get_binding(DT_INST_0_SITRONIX_ST7789V_BUS_NAME);
    649e:	6020      	str	r0, [r4, #0]
	if (data->spi_dev == NULL) {
    64a0:	b998      	cbnz	r0, 64ca <st7789v_init+0x3a>
		LOG_ERR("Could not get SPI device for LCD");
    64a2:	2301      	movs	r3, #1
    64a4:	f04f 0100 	mov.w	r1, #0
    64a8:	f363 0107 	bfi	r1, r3, #0, #8
    64ac:	4a9a      	ldr	r2, [pc, #616]	; (6718 <st7789v_init+0x288>)
    64ae:	4b9b      	ldr	r3, [pc, #620]	; (671c <st7789v_init+0x28c>)
    64b0:	489b      	ldr	r0, [pc, #620]	; (6720 <st7789v_init+0x290>)
    64b2:	1a9b      	subs	r3, r3, r2
    64b4:	08db      	lsrs	r3, r3, #3
    64b6:	f363 118f 	bfi	r1, r3, #6, #10
#endif

	data->cmd_data_gpio = device_get_binding(
			DT_INST_0_SITRONIX_ST7789V_CMD_DATA_GPIOS_CONTROLLER);
	if (data->cmd_data_gpio == NULL) {
		LOG_ERR("Could not get GPIO port for cmd/DATA port");
    64ba:	f01a fdbe 	bl	2103a <log_0>
		return -EPERM;
    64be:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
	st7789v_lcd_init(data);

	st7789v_exit_sleep(data);

	return 0;
}
    64c2:	4628      	mov	r0, r5
    64c4:	b002      	add	sp, #8
    64c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	data->spi_config.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
    64ca:	4a96      	ldr	r2, [pc, #600]	; (6724 <st7789v_init+0x294>)
    64cc:	f44f 7380 	mov.w	r3, #256	; 0x100
    64d0:	e9c4 2301 	strd	r2, r3, [r4, #4]
    64d4:	4894      	ldr	r0, [pc, #592]	; (6728 <st7789v_init+0x298>)
    64d6:	f017 fda3 	bl	1e020 <z_impl_device_get_binding>
	data->cs_ctrl.delay = 0U;
    64da:	2619      	movs	r6, #25
    64dc:	2500      	movs	r5, #0
	data->spi_config.cs = &(data->cs_ctrl);
    64de:	f104 0310 	add.w	r3, r4, #16
	data->cs_ctrl.gpio_dev = device_get_binding(
    64e2:	6120      	str	r0, [r4, #16]
	data->cs_ctrl.delay = 0U;
    64e4:	e9c4 6505 	strd	r6, r5, [r4, #20]
	data->spi_config.cs = &(data->cs_ctrl);
    64e8:	60e3      	str	r3, [r4, #12]
    64ea:	488f      	ldr	r0, [pc, #572]	; (6728 <st7789v_init+0x298>)
    64ec:	f017 fd98 	bl	1e020 <z_impl_device_get_binding>
	data->reset_gpio = device_get_binding(
    64f0:	61e0      	str	r0, [r4, #28]
	if (data->reset_gpio == NULL) {
    64f2:	b960      	cbnz	r0, 650e <st7789v_init+0x7e>
		LOG_ERR("Could not get GPIO port for display reset");
    64f4:	2301      	movs	r3, #1
    64f6:	f04f 0100 	mov.w	r1, #0
    64fa:	f363 0107 	bfi	r1, r3, #0, #8
    64fe:	4a86      	ldr	r2, [pc, #536]	; (6718 <st7789v_init+0x288>)
    6500:	4b86      	ldr	r3, [pc, #536]	; (671c <st7789v_init+0x28c>)
    6502:	488a      	ldr	r0, [pc, #552]	; (672c <st7789v_init+0x29c>)
    6504:	1a9b      	subs	r3, r3, r2
    6506:	08db      	lsrs	r3, r3, #3
    6508:	f363 118f 	bfi	r1, r3, #6, #10
    650c:	e7d5      	b.n	64ba <st7789v_init+0x2a>
	return api->config(port, access_op, pin, flags);
    650e:	6843      	ldr	r3, [r0, #4]
    6510:	4629      	mov	r1, r5
    6512:	f8d3 8000 	ldr.w	r8, [r3]
    6516:	221a      	movs	r2, #26
    6518:	2301      	movs	r3, #1
    651a:	47c0      	blx	r8
	if (gpio_pin_configure(data->reset_gpio, ST7789V_RESET_PIN,
    651c:	4605      	mov	r5, r0
    651e:	b180      	cbz	r0, 6542 <st7789v_init+0xb2>
		LOG_ERR("Couldn't configure reset pin");
    6520:	2301      	movs	r3, #1
    6522:	f04f 0100 	mov.w	r1, #0
    6526:	f363 0107 	bfi	r1, r3, #0, #8
    652a:	4a7b      	ldr	r2, [pc, #492]	; (6718 <st7789v_init+0x288>)
    652c:	4b7b      	ldr	r3, [pc, #492]	; (671c <st7789v_init+0x28c>)
    652e:	4880      	ldr	r0, [pc, #512]	; (6730 <st7789v_init+0x2a0>)
    6530:	1a9b      	subs	r3, r3, r2
    6532:	08db      	lsrs	r3, r3, #3
    6534:	f363 118f 	bfi	r1, r3, #6, #10
		LOG_ERR("Couldn't configure cmd/DATA pin");
    6538:	f01a fd7f 	bl	2103a <log_0>
		return -EIO;
    653c:	f06f 0504 	mvn.w	r5, #4
    6540:	e7bf      	b.n	64c2 <st7789v_init+0x32>
    6542:	4879      	ldr	r0, [pc, #484]	; (6728 <st7789v_init+0x298>)
    6544:	f017 fd6c 	bl	1e020 <z_impl_device_get_binding>
	data->cmd_data_gpio = device_get_binding(
    6548:	6220      	str	r0, [r4, #32]
	if (data->cmd_data_gpio == NULL) {
    654a:	b960      	cbnz	r0, 6566 <st7789v_init+0xd6>
		LOG_ERR("Could not get GPIO port for cmd/DATA port");
    654c:	2301      	movs	r3, #1
    654e:	f04f 0100 	mov.w	r1, #0
    6552:	f363 0107 	bfi	r1, r3, #0, #8
    6556:	4a70      	ldr	r2, [pc, #448]	; (6718 <st7789v_init+0x288>)
    6558:	4b70      	ldr	r3, [pc, #448]	; (671c <st7789v_init+0x28c>)
    655a:	4876      	ldr	r0, [pc, #472]	; (6734 <st7789v_init+0x2a4>)
    655c:	1a9b      	subs	r3, r3, r2
    655e:	08db      	lsrs	r3, r3, #3
    6560:	f363 118f 	bfi	r1, r3, #6, #10
    6564:	e7a9      	b.n	64ba <st7789v_init+0x2a>
    6566:	6843      	ldr	r3, [r0, #4]
    6568:	4629      	mov	r1, r5
    656a:	f8d3 8000 	ldr.w	r8, [r3]
    656e:	2212      	movs	r2, #18
    6570:	2301      	movs	r3, #1
    6572:	47c0      	blx	r8
	if (gpio_pin_configure(data->cmd_data_gpio, ST7789V_CMD_DATA_PIN,
    6574:	4605      	mov	r5, r0
    6576:	b160      	cbz	r0, 6592 <st7789v_init+0x102>
		LOG_ERR("Couldn't configure cmd/DATA pin");
    6578:	2301      	movs	r3, #1
    657a:	f04f 0100 	mov.w	r1, #0
    657e:	f363 0107 	bfi	r1, r3, #0, #8
    6582:	4a65      	ldr	r2, [pc, #404]	; (6718 <st7789v_init+0x288>)
    6584:	4b65      	ldr	r3, [pc, #404]	; (671c <st7789v_init+0x28c>)
    6586:	486c      	ldr	r0, [pc, #432]	; (6738 <st7789v_init+0x2a8>)
    6588:	1a9b      	subs	r3, r3, r2
    658a:	08db      	lsrs	r3, r3, #3
    658c:	f363 118f 	bfi	r1, r3, #6, #10
    6590:	e7d2      	b.n	6538 <st7789v_init+0xa8>
	gpio_pin_write(data->reset_gpio, ST7789V_RESET_PIN, 1);
    6592:	2201      	movs	r2, #1
    6594:	211a      	movs	r1, #26
    6596:	69e0      	ldr	r0, [r4, #28]
    6598:	f01b fbbd 	bl	21d16 <gpio_pin_write>
	k_sleep(K_MSEC(1));
    659c:	2001      	movs	r0, #1
    659e:	f01b fba8 	bl	21cf2 <k_sleep>
	gpio_pin_write(data->reset_gpio, ST7789V_RESET_PIN, 0);
    65a2:	462a      	mov	r2, r5
    65a4:	211a      	movs	r1, #26
    65a6:	69e0      	ldr	r0, [r4, #28]
    65a8:	f01b fbb5 	bl	21d16 <gpio_pin_write>
	k_sleep(K_MSEC(6));
    65ac:	2006      	movs	r0, #6
    65ae:	f01b fba0 	bl	21cf2 <k_sleep>
	gpio_pin_write(data->reset_gpio, ST7789V_RESET_PIN, 1);
    65b2:	2201      	movs	r2, #1
    65b4:	211a      	movs	r1, #26
    65b6:	69e0      	ldr	r0, [r4, #28]
    65b8:	f01b fbad 	bl	21d16 <gpio_pin_write>
	k_sleep(K_MSEC(20));
    65bc:	2014      	movs	r0, #20
    65be:	f01b fb98 	bl	21cf2 <k_sleep>
	st7789v_blanking_on(dev);
    65c2:	4638      	mov	r0, r7
    65c4:	f01b fbe4 	bl	21d90 <st7789v_blanking_on>
	st7789v_transmit(p_st7789v, ST7789V_CMD_PORCTRL, st7789v_porch_param,
    65c8:	4620      	mov	r0, r4
	data->x_offset = x_offset;
    65ca:	62a5      	str	r5, [r4, #40]	; 0x28
	st7789v_transmit(p_st7789v, ST7789V_CMD_PORCTRL, st7789v_porch_param,
    65cc:	2305      	movs	r3, #5
    65ce:	4a5b      	ldr	r2, [pc, #364]	; (673c <st7789v_init+0x2ac>)
    65d0:	21b2      	movs	r1, #178	; 0xb2
    65d2:	f01b fbac 	bl	21d2e <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_CMD2EN, st7789v_cmd2en_param,
    65d6:	4620      	mov	r0, r4
    65d8:	2304      	movs	r3, #4
    65da:	4a59      	ldr	r2, [pc, #356]	; (6740 <st7789v_init+0x2b0>)
    65dc:	21df      	movs	r1, #223	; 0xdf
    65de:	f01b fba6 	bl	21d2e <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_DGMEN, &tmp, 1);
    65e2:	f10d 0207 	add.w	r2, sp, #7
    65e6:	4620      	mov	r0, r4
    65e8:	2301      	movs	r3, #1
    65ea:	21ba      	movs	r1, #186	; 0xba
	tmp = 0x00;
    65ec:	f88d 5007 	strb.w	r5, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_DGMEN, &tmp, 1);
    65f0:	f01b fb9d 	bl	21d2e <st7789v_transmit>
	tmp = 0x0f;
    65f4:	230f      	movs	r3, #15
    65f6:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_FRCTRL2, &tmp, 1);
    65fa:	f10d 0207 	add.w	r2, sp, #7
    65fe:	4620      	mov	r0, r4
    6600:	2301      	movs	r3, #1
    6602:	21c6      	movs	r1, #198	; 0xc6
    6604:	f01b fb93 	bl	21d2e <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_GCTRL;
    6608:	2335      	movs	r3, #53	; 0x35
    660a:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_GCTRL, &tmp, 1);
    660e:	f10d 0207 	add.w	r2, sp, #7
    6612:	4620      	mov	r0, r4
    6614:	2301      	movs	r3, #1
    6616:	21b7      	movs	r1, #183	; 0xb7
    6618:	f01b fb89 	bl	21d2e <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_VCOM;
    661c:	f88d 6007 	strb.w	r6, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_VCOMS, &tmp, 1);
    6620:	f10d 0207 	add.w	r2, sp, #7
	tmp = 0x01;
    6624:	2601      	movs	r6, #1
	st7789v_transmit(p_st7789v, ST7789V_CMD_VCOMS, &tmp, 1);
    6626:	4620      	mov	r0, r4
    6628:	2301      	movs	r3, #1
    662a:	21bb      	movs	r1, #187	; 0xbb
    662c:	f01b fb7f 	bl	21d2e <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_VDVVRHEN, &tmp, 1);
    6630:	4633      	mov	r3, r6
    6632:	f10d 0207 	add.w	r2, sp, #7
    6636:	4620      	mov	r0, r4
    6638:	21c2      	movs	r1, #194	; 0xc2
	tmp = 0x01;
    663a:	f88d 6007 	strb.w	r6, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_VDVVRHEN, &tmp, 1);
    663e:	f01b fb76 	bl	21d2e <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_VRHS;
    6642:	2312      	movs	r3, #18
    6644:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_VRH, &tmp, 1);
    6648:	f10d 0207 	add.w	r2, sp, #7
    664c:	4633      	mov	r3, r6
    664e:	4620      	mov	r0, r4
    6650:	21c3      	movs	r1, #195	; 0xc3
    6652:	f01b fb6c 	bl	21d2e <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_VDVS;
    6656:	2320      	movs	r3, #32
    6658:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_VDS, &tmp, 1);
    665c:	f10d 0207 	add.w	r2, sp, #7
    6660:	4633      	mov	r3, r6
    6662:	4620      	mov	r0, r4
    6664:	21c4      	movs	r1, #196	; 0xc4
    6666:	f01b fb62 	bl	21d2e <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_PWCTRL1, st7789v_pwctrl1_param,
    666a:	4620      	mov	r0, r4
    666c:	2302      	movs	r3, #2
    666e:	4a35      	ldr	r2, [pc, #212]	; (6744 <st7789v_init+0x2b4>)
    6670:	21d0      	movs	r1, #208	; 0xd0
    6672:	f01b fb5c 	bl	21d2e <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_MADCTL, &tmp, 1);
    6676:	4633      	mov	r3, r6
    6678:	f10d 0207 	add.w	r2, sp, #7
    667c:	4620      	mov	r0, r4
    667e:	2136      	movs	r1, #54	; 0x36
	tmp = DT_INST_0_SITRONIX_ST7789V_MDAC;
    6680:	f88d 5007 	strb.w	r5, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_MADCTL, &tmp, 1);
    6684:	f01b fb53 	bl	21d2e <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_COLMOD;
    6688:	2305      	movs	r3, #5
    668a:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_COLMOD, &tmp, 1);
    668e:	f10d 0207 	add.w	r2, sp, #7
    6692:	4633      	mov	r3, r6
    6694:	4620      	mov	r0, r4
    6696:	213a      	movs	r1, #58	; 0x3a
    6698:	f01b fb49 	bl	21d2e <st7789v_transmit>
	tmp = DT_INST_0_SITRONIX_ST7789V_LCM;
    669c:	232c      	movs	r3, #44	; 0x2c
    669e:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_LCMCTRL, &tmp, 1);
    66a2:	f10d 0207 	add.w	r2, sp, #7
    66a6:	4633      	mov	r3, r6
    66a8:	4620      	mov	r0, r4
    66aa:	21c0      	movs	r1, #192	; 0xc0
    66ac:	f01b fb3f 	bl	21d2e <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_GAMSET, &tmp, 1);
    66b0:	4633      	mov	r3, r6
    66b2:	f10d 0207 	add.w	r2, sp, #7
    66b6:	4620      	mov	r0, r4
    66b8:	2126      	movs	r1, #38	; 0x26
	tmp = DT_INST_0_SITRONIX_ST7789V_GAMMA;
    66ba:	f88d 6007 	strb.w	r6, [sp, #7]
	st7789v_transmit(p_st7789v, ST7789V_CMD_GAMSET, &tmp, 1);
    66be:	f01b fb36 	bl	21d2e <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_INV_ON, NULL, 0);
    66c2:	462b      	mov	r3, r5
    66c4:	462a      	mov	r2, r5
    66c6:	4620      	mov	r0, r4
    66c8:	2121      	movs	r1, #33	; 0x21
    66ca:	f01b fb30 	bl	21d2e <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_PVGAMCTRL, st7789v_pvgam_param,
    66ce:	4620      	mov	r0, r4
    66d0:	230e      	movs	r3, #14
    66d2:	4a1d      	ldr	r2, [pc, #116]	; (6748 <st7789v_init+0x2b8>)
    66d4:	21e0      	movs	r1, #224	; 0xe0
    66d6:	f01b fb2a 	bl	21d2e <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_NVGAMCTRL, st7789v_nvgam_param,
    66da:	4620      	mov	r0, r4
    66dc:	230e      	movs	r3, #14
    66de:	4a1b      	ldr	r2, [pc, #108]	; (674c <st7789v_init+0x2bc>)
    66e0:	21e1      	movs	r1, #225	; 0xe1
    66e2:	f01b fb24 	bl	21d2e <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_RAMCTRL, st7789v_ram_param,
    66e6:	4620      	mov	r0, r4
    66e8:	2302      	movs	r3, #2
    66ea:	4a19      	ldr	r2, [pc, #100]	; (6750 <st7789v_init+0x2c0>)
    66ec:	21b0      	movs	r1, #176	; 0xb0
    66ee:	f01b fb1e 	bl	21d2e <st7789v_transmit>
	st7789v_transmit(p_st7789v, ST7789V_CMD_RGBCTRL, st7789v_rgb_param,
    66f2:	4620      	mov	r0, r4
    66f4:	2303      	movs	r3, #3
    66f6:	4a17      	ldr	r2, [pc, #92]	; (6754 <st7789v_init+0x2c4>)
    66f8:	21b1      	movs	r1, #177	; 0xb1
    66fa:	f01b fb18 	bl	21d2e <st7789v_transmit>
	st7789v_transmit(data, ST7789V_CMD_SLEEP_OUT, NULL, 0);
    66fe:	4620      	mov	r0, r4
    6700:	462b      	mov	r3, r5
    6702:	462a      	mov	r2, r5
    6704:	2111      	movs	r1, #17
    6706:	f01b fb12 	bl	21d2e <st7789v_transmit>
	k_sleep(K_MSEC(120));
    670a:	2078      	movs	r0, #120	; 0x78
    670c:	f01b faf1 	bl	21cf2 <k_sleep>
    6710:	e6d7      	b.n	64c2 <st7789v_init+0x32>
    6712:	bf00      	nop
    6714:	0006235c 	.word	0x0006235c
    6718:	00028540 	.word	0x00028540
    671c:	00028650 	.word	0x00028650
    6720:	00062362 	.word	0x00062362
    6724:	007a1200 	.word	0x007a1200
    6728:	00061ebb 	.word	0x00061ebb
    672c:	00062383 	.word	0x00062383
    6730:	000623ad 	.word	0x000623ad
    6734:	000623ca 	.word	0x000623ca
    6738:	000623f4 	.word	0x000623f4
    673c:	2000edd2 	.word	0x2000edd2
    6740:	2000edc0 	.word	0x2000edc0
    6744:	2000ede5 	.word	0x2000ede5
    6748:	2000edd7 	.word	0x2000edd7
    674c:	2000edc4 	.word	0x2000edc4
    6750:	2000ede7 	.word	0x2000ede7
    6754:	2000ede9 	.word	0x2000ede9

00006758 <rtc1_nrf_isr>:
 * symbol.
 */
void rtc1_nrf_isr(void *arg)
{
	ARG_UNUSED(arg);
	RTC->EVENTS_COMPARE[0] = 0;
    6758:	4b0d      	ldr	r3, [pc, #52]	; (6790 <rtc1_nrf_isr+0x38>)
    675a:	2200      	movs	r2, #0
    675c:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
	__asm__ volatile(
    6760:	f04f 0220 	mov.w	r2, #32
    6764:	f3ef 8111 	mrs	r1, BASEPRI
    6768:	f382 8811 	msr	BASEPRI, r2
    676c:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t t = counter();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
    6770:	4a08      	ldr	r2, [pc, #32]	; (6794 <rtc1_nrf_isr+0x3c>)
#endif
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
    6772:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
    6776:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
    6778:	1ac0      	subs	r0, r0, r3
    677a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
    677e:	4403      	add	r3, r0
    6780:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
    6782:	f381 8811 	msr	BASEPRI, r1
    6786:	f3bf 8f6f 	isb	sy
		}
		set_comparator(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    678a:	f018 bd53 	b.w	1f234 <z_clock_announce>
    678e:	bf00      	nop
    6790:	40011000 	.word	0x40011000
    6794:	200001d4 	.word	0x200001d4

00006798 <z_clock_driver_init>:
}

int z_clock_driver_init(struct device *device)
{
    6798:	b573      	push	{r0, r1, r4, r5, r6, lr}
    679a:	481c      	ldr	r0, [pc, #112]	; (680c <z_clock_driver_init+0x74>)
    679c:	f017 fc40 	bl	1e020 <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_INST_0_NORDIC_NRF_CLOCK_LABEL);
	if (!clock) {
    67a0:	b380      	cbz	r0, 6804 <z_clock_driver_init+0x6c>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
    67a2:	6843      	ldr	r3, [r0, #4]
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
    67a4:	4d1a      	ldr	r5, [pc, #104]	; (6810 <z_clock_driver_init+0x78>)
    67a6:	681b      	ldr	r3, [r3, #0]
    67a8:	2101      	movs	r1, #1
    67aa:	4798      	blx	r3
    p_reg->CC[ch] = cc_val;
    67ac:	2601      	movs	r6, #1
    p_reg->PRESCALER = val;
    67ae:	2400      	movs	r4, #0
    p_reg->INTENSET = mask;
    67b0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->PRESCALER = val;
    67b4:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
    67b8:	f8c5 6540 	str.w	r6, [r5, #1344]	; 0x540
    p_reg->INTENSET = mask;
    67bc:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    67c0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    67c4:	f503 538a 	add.w	r3, r3, #4416	; 0x1140
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    67c8:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    67cc:	601c      	str	r4, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    67ce:	681b      	ldr	r3, [r3, #0]
    67d0:	9301      	str	r3, [sp, #4]
    (void)dummy;
    67d2:	9b01      	ldr	r3, [sp, #4]
    67d4:	4b0f      	ldr	r3, [pc, #60]	; (6814 <z_clock_driver_init+0x7c>)

	/* Clear the event flag and possible pending interrupt */
	nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_COMPARE_0);
	NVIC_ClearPendingIRQ(RTC1_IRQn);

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
    67d6:	4631      	mov	r1, r6
    67d8:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    67dc:	2011      	movs	r0, #17
    67de:	4622      	mov	r2, r4
    67e0:	f000 f9c0 	bl	6b64 <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
    67e4:	2011      	movs	r0, #17
    67e6:	f000 f98b 	bl	6b00 <arch_irq_enable>
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    67ea:	4b0b      	ldr	r3, [pc, #44]	; (6818 <z_clock_driver_init+0x80>)
    67ec:	601e      	str	r6, [r3, #0]
    67ee:	602e      	str	r6, [r5, #0]
     return p_reg->COUNTER;
    67f0:	f8d5 3504 	ldr.w	r3, [r5, #1284]	; 0x504

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	if (!IS_ENABLED(TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
    67f4:	4433      	add	r3, r6
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    67f6:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    67fa:	f8c5 3540 	str.w	r3, [r5, #1344]	; 0x540
	}

	return 0;
    67fe:	4620      	mov	r0, r4
}
    6800:	b002      	add	sp, #8
    6802:	bd70      	pop	{r4, r5, r6, pc}
		return -1;
    6804:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    6808:	e7fa      	b.n	6800 <z_clock_driver_init+0x68>
    680a:	bf00      	nop
    680c:	0006233c 	.word	0x0006233c
    6810:	40011000 	.word	0x40011000
    6814:	e000e100 	.word	0xe000e100
    6818:	40011008 	.word	0x40011008

0000681c <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
    681c:	b5f0      	push	{r4, r5, r6, r7, lr}
	ARG_UNUSED(idle);

#ifdef CONFIG_TICKLESS_KERNEL
	ticks = (ticks == K_FOREVER) ? MAX_TICKS : ticks;
    681e:	4e25      	ldr	r6, [pc, #148]	; (68b4 <z_clock_set_timeout+0x98>)
    6820:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    6824:	bf08      	it	eq
    6826:	4630      	moveq	r0, r6
	__asm__ volatile(
    6828:	f04f 0320 	mov.w	r3, #32
    682c:	f3ef 8511 	mrs	r5, BASEPRI
    6830:	f383 8811 	msr	BASEPRI, r3
    6834:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
    6838:	491f      	ldr	r1, [pc, #124]	; (68b8 <z_clock_set_timeout+0x9c>)
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t cyc, dt, t = counter();
	u32_t unannounced = counter_sub(t, last_count);
    683a:	4b20      	ldr	r3, [pc, #128]	; (68bc <z_clock_set_timeout+0xa0>)
    683c:	f8d1 4504 	ldr.w	r4, [r1, #1284]	; 0x504
    6840:	681b      	ldr	r3, [r3, #0]
	return (a - b) & COUNTER_MAX;
    6842:	1ae2      	subs	r2, r4, r3
    6844:	f022 477f 	bic.w	r7, r2, #4278190080	; 0xff000000
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
    6848:	0212      	lsls	r2, r2, #8
    684a:	d419      	bmi.n	6880 <z_clock_set_timeout+0x64>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
    684c:	1e42      	subs	r2, r0, #1
    684e:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    6852:	42b2      	cmp	r2, r6
    6854:	bfa8      	it	ge
    6856:	4632      	movge	r2, r6
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    6858:	1c78      	adds	r0, r7, #1
    685a:	4410      	add	r0, r2
	 */
	if (cyc > MAX_CYCLES) {
		cyc = MAX_CYCLES;
	}

	cyc += last_count;
    685c:	42b0      	cmp	r0, r6
    685e:	bf94      	ite	ls
    6860:	1818      	addls	r0, r3, r0
    6862:	1998      	addhi	r0, r3, r6
	return (a - b) & COUNTER_MAX;
    6864:	1b04      	subs	r4, r0, r4
    6866:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
    686a:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
	 * least on nRF52.  Some experimentation on nrf52840 shows
	 * that you need to be early by about 400 processor cycles
	 * (about 1/5th of a RTC cycle) in order to reliably get the
	 * interrupt.  The docs say two cycles, they mean two cycles.
	 */
	if (counter_sub(cyc, t) > 2) {
    686e:	2c02      	cmp	r4, #2
    p_reg->CC[ch] = cc_val;
    6870:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
    6874:	d906      	bls.n	6884 <z_clock_set_timeout+0x68>
	__asm__ volatile(
    6876:	f385 8811 	msr	BASEPRI, r5
    687a:	f3bf 8f6f 	isb	sy
	}
#endif

	k_spin_unlock(&lock, key);
#endif /* CONFIG_TICKLESS_KERNEL */
}
    687e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		ticks = 0;
    6880:	2200      	movs	r2, #0
    6882:	e7e9      	b.n	6858 <z_clock_set_timeout+0x3c>
     return p_reg->COUNTER;
    6884:	f8d1 3504 	ldr.w	r3, [r1, #1284]	; 0x504
		if (dt == 0 || dt > 0x7fffff) {
    6888:	4a0d      	ldr	r2, [pc, #52]	; (68c0 <z_clock_set_timeout+0xa4>)
	return (a - b) & COUNTER_MAX;
    688a:	1ac3      	subs	r3, r0, r3
    688c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		if (dt == 0 || dt > 0x7fffff) {
    6890:	1e5c      	subs	r4, r3, #1
    6892:	4294      	cmp	r4, r2
    6894:	d905      	bls.n	68a2 <z_clock_set_timeout+0x86>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    6896:	4b0b      	ldr	r3, [pc, #44]	; (68c4 <z_clock_set_timeout+0xa8>)
    6898:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    689c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    68a0:	e7e9      	b.n	6876 <z_clock_set_timeout+0x5a>
		} else if (dt == 1) {
    68a2:	2b01      	cmp	r3, #1
			set_comparator(cyc + 2);
    68a4:	bf02      	ittt	eq
    68a6:	3002      	addeq	r0, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    68a8:	f020 407f 	biceq.w	r0, r0, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    68ac:	f8c1 0540 	streq.w	r0, [r1, #1344]	; 0x540
    68b0:	e7e1      	b.n	6876 <z_clock_set_timeout+0x5a>
    68b2:	bf00      	nop
    68b4:	00fffffe 	.word	0x00fffffe
    68b8:	40011000 	.word	0x40011000
    68bc:	200001d4 	.word	0x200001d4
    68c0:	007ffffe 	.word	0x007ffffe
    68c4:	e000e100 	.word	0xe000e100

000068c8 <z_clock_elapsed>:
	__asm__ volatile(
    68c8:	f04f 0220 	mov.w	r2, #32
    68cc:	f3ef 8311 	mrs	r3, BASEPRI
    68d0:	f382 8811 	msr	BASEPRI, r2
    68d4:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
    68d8:	4a06      	ldr	r2, [pc, #24]	; (68f4 <z_clock_elapsed+0x2c>)
    68da:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
    68de:	4a06      	ldr	r2, [pc, #24]	; (68f8 <z_clock_elapsed+0x30>)
	return (a - b) & COUNTER_MAX;
    68e0:	6812      	ldr	r2, [r2, #0]
    68e2:	1a80      	subs	r0, r0, r2
    68e4:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	__asm__ volatile(
    68e8:	f383 8811 	msr	BASEPRI, r3
    68ec:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    68f0:	4770      	bx	lr
    68f2:	bf00      	nop
    68f4:	40011000 	.word	0x40011000
    68f8:	200001d4 	.word	0x200001d4

000068fc <z_timer_cycle_get_32>:
	__asm__ volatile(
    68fc:	f04f 0320 	mov.w	r3, #32
    6900:	f3ef 8211 	mrs	r2, BASEPRI
    6904:	f383 8811 	msr	BASEPRI, r3
    6908:	f3bf 8f6f 	isb	sy

u32_t z_timer_cycle_get_32(void)
{
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) + last_count;
    690c:	4906      	ldr	r1, [pc, #24]	; (6928 <z_timer_cycle_get_32+0x2c>)
    690e:	4b07      	ldr	r3, [pc, #28]	; (692c <z_timer_cycle_get_32+0x30>)
    6910:	6808      	ldr	r0, [r1, #0]
    6912:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	__asm__ volatile(
    6916:	f382 8811 	msr	BASEPRI, r2
    691a:	f3bf 8f6f 	isb	sy
	return (a - b) & COUNTER_MAX;
    691e:	1a1b      	subs	r3, r3, r0
    6920:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000

	k_spin_unlock(&lock, key);
	return ret;
}
    6924:	4418      	add	r0, r3
    6926:	4770      	bx	lr
    6928:	200001d4 	.word	0x200001d4
    692c:	40011000 	.word	0x40011000

00006930 <_DoInit>:
*
*/
#define INIT()  do {                                            \
                  if (_SEGGER_RTT.acID[0] == '\0') { _DoInit(); }  \
                } while (0)
static void _DoInit(void) {
    6930:	b510      	push	{r4, lr}
  SEGGER_RTT_CB* p;
  //
  // Initialize control block
  //
  p = &_SEGGER_RTT;
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    6932:	4c11      	ldr	r4, [pc, #68]	; (6978 <_DoInit+0x48>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
    6934:	4a11      	ldr	r2, [pc, #68]	; (697c <_DoInit+0x4c>)
    6936:	61a2      	str	r2, [r4, #24]
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    6938:	2303      	movs	r3, #3
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    693a:	e9c4 3304 	strd	r3, r3, [r4, #16]
  p->aUp[0].pBuffer       = _acUpBuffer;
    693e:	4b10      	ldr	r3, [pc, #64]	; (6980 <_DoInit+0x50>)
    6940:	61e3      	str	r3, [r4, #28]
  p->aUp[0].WrOff         = 0u;
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
    6942:	6622      	str	r2, [r4, #96]	; 0x60
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
    6944:	f44f 6380 	mov.w	r3, #1024	; 0x400
  p->aDown[0].pBuffer       = _acDownBuffer;
    6948:	4a0e      	ldr	r2, [pc, #56]	; (6984 <_DoInit+0x54>)
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
    694a:	6223      	str	r3, [r4, #32]
  p->aDown[0].pBuffer       = _acDownBuffer;
    694c:	6662      	str	r2, [r4, #100]	; 0x64
  p->aUp[0].RdOff         = 0u;
    694e:	2300      	movs	r3, #0
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
    6950:	2210      	movs	r2, #16
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  strcpy(&p->acID[7], "RTT");
    6952:	490d      	ldr	r1, [pc, #52]	; (6988 <_DoInit+0x58>)
  p->aUp[0].RdOff         = 0u;
    6954:	62a3      	str	r3, [r4, #40]	; 0x28
  strcpy(&p->acID[7], "RTT");
    6956:	1de0      	adds	r0, r4, #7
  p->aUp[0].WrOff         = 0u;
    6958:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    695a:	62e3      	str	r3, [r4, #44]	; 0x2c
  p->aDown[0].RdOff         = 0u;
    695c:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    695e:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    6960:	6763      	str	r3, [r4, #116]	; 0x74
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
    6962:	66a2      	str	r2, [r4, #104]	; 0x68
  strcpy(&p->acID[7], "RTT");
    6964:	f7fb f998 	bl	1c98 <strcpy>
  strcpy(&p->acID[0], "SEGGER");
    6968:	4908      	ldr	r1, [pc, #32]	; (698c <_DoInit+0x5c>)
    696a:	4620      	mov	r0, r4
    696c:	f7fb f994 	bl	1c98 <strcpy>
  p->acID[6] = ' ';
    6970:	2320      	movs	r3, #32
    6972:	71a3      	strb	r3, [r4, #6]
}
    6974:	bd10      	pop	{r4, pc}
    6976:	bf00      	nop
    6978:	200001d8 	.word	0x200001d8
    697c:	0006247f 	.word	0x0006247f
    6980:	20006179 	.word	0x20006179
    6984:	20006169 	.word	0x20006169
    6988:	00062488 	.word	0x00062488
    698c:	0006248c 	.word	0x0006248c

00006990 <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    6990:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = &_SEGGER_RTT.aUp[BufferIndex];
  RdOff = pRing->RdOff;
    6994:	4e23      	ldr	r6, [pc, #140]	; (6a24 <SEGGER_RTT_WriteSkipNoLock+0x94>)
    6996:	f04f 0b18 	mov.w	fp, #24
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    699a:	4614      	mov	r4, r2
  RdOff = pRing->RdOff;
    699c:	fb0b 6200 	mla	r2, fp, r0, r6
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    69a0:	4607      	mov	r7, r0
  RdOff = pRing->RdOff;
    69a2:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
    69a4:	6a55      	ldr	r5, [r2, #36]	; 0x24
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
    69a6:	42ab      	cmp	r3, r5
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    69a8:	4688      	mov	r8, r1
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
    69aa:	d834      	bhi.n	6a16 <SEGGER_RTT_WriteSkipNoLock+0x86>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
    69ac:	f8d2 a020 	ldr.w	sl, [r2, #32]
    69b0:	ebaa 0905 	sub.w	r9, sl, r5
    69b4:	f109 32ff 	add.w	r2, r9, #4294967295	; 0xffffffff
    if (Avail >= NumBytes) {                            // Case 1)?
    69b8:	42a2      	cmp	r2, r4
    69ba:	d311      	bcc.n	69e0 <SEGGER_RTT_WriteSkipNoLock+0x50>
CopyStraight:
      memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
    69bc:	f04f 0918 	mov.w	r9, #24
    69c0:	fb07 9309 	mla	r3, r7, r9, r9
    69c4:	4433      	add	r3, r6
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    69c6:	4622      	mov	r2, r4
    69c8:	6858      	ldr	r0, [r3, #4]
    69ca:	4641      	mov	r1, r8
    69cc:	4428      	add	r0, r5
    69ce:	f7fb f90d 	bl	1bec <memcpy>
      pRing->WrOff = WrOff + NumBytes;
    69d2:	fb09 6607 	mla	r6, r9, r7, r6
    69d6:	442c      	add	r4, r5
      // Therefore, check if 2nd memcpy is necessary at all
      //
      if (NumBytes) {
        memcpy(pRing->pBuffer, pData + Rem, NumBytes);
      }
      pRing->WrOff = NumBytes;
    69d8:	6274      	str	r4, [r6, #36]	; 0x24
      return 1;
    69da:	2001      	movs	r0, #1
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
}
    69dc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Avail += RdOff;                                     // Space incl. wrap-around
    69e0:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
    69e2:	429c      	cmp	r4, r3
    69e4:	d81b      	bhi.n	6a1e <SEGGER_RTT_WriteSkipNoLock+0x8e>
      memcpy(pRing->pBuffer + WrOff, pData, Rem);       // Copy 1st chunk
    69e6:	fb00 bb0b 	mla	fp, r0, fp, fp
    69ea:	44b3      	add	fp, r6
    69ec:	464a      	mov	r2, r9
    69ee:	f8db 0004 	ldr.w	r0, [fp, #4]
    69f2:	442c      	add	r4, r5
    69f4:	4428      	add	r0, r5
    69f6:	f7fb f8f9 	bl	1bec <memcpy>
      if (NumBytes) {
    69fa:	ebb4 040a 	subs.w	r4, r4, sl
    69fe:	d006      	beq.n	6a0e <SEGGER_RTT_WriteSkipNoLock+0x7e>
    6a00:	4622      	mov	r2, r4
    6a02:	eb08 0109 	add.w	r1, r8, r9
    6a06:	f8db 0004 	ldr.w	r0, [fp, #4]
    6a0a:	f7fb f8ef 	bl	1bec <memcpy>
      pRing->WrOff = NumBytes;
    6a0e:	2318      	movs	r3, #24
    6a10:	fb03 6607 	mla	r6, r3, r7, r6
    6a14:	e7e0      	b.n	69d8 <SEGGER_RTT_WriteSkipNoLock+0x48>
    Avail = RdOff - WrOff - 1u;
    6a16:	3b01      	subs	r3, #1
    6a18:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
    6a1a:	429c      	cmp	r4, r3
    6a1c:	d9ce      	bls.n	69bc <SEGGER_RTT_WriteSkipNoLock+0x2c>
  return 0;     // No space in buffer
    6a1e:	2000      	movs	r0, #0
    6a20:	e7dc      	b.n	69dc <SEGGER_RTT_WriteSkipNoLock+0x4c>
    6a22:	bf00      	nop
    6a24:	200001d8 	.word	0x200001d8

00006a28 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = &_SEGGER_RTT.aUp[BufferIndex];
  v = pRing->RdOff;
    6a28:	4a03      	ldr	r2, [pc, #12]	; (6a38 <SEGGER_RTT_HasDataUp+0x10>)
    6a2a:	2318      	movs	r3, #24
    6a2c:	fb03 2300 	mla	r3, r3, r0, r2
    6a30:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  return pRing->WrOff - v;
    6a32:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
    6a34:	1a80      	subs	r0, r0, r2
    6a36:	4770      	bx	lr
    6a38:	200001d8 	.word	0x200001d8

00006a3c <z_arm_exc_exit>:
    /* r0 contains the caller mode */
    push {r0, lr}
#endif

#ifdef CONFIG_PREEMPT_ENABLED
    ldr r0, =_kernel
    6a3c:	4804      	ldr	r0, [pc, #16]	; (6a50 <_EXIT_EXC+0x2>)

    ldr r1, [r0, #_kernel_offset_to_current]
    6a3e:	6881      	ldr	r1, [r0, #8]

    ldr r0, [r0, #_kernel_offset_to_ready_q_cache]
    6a40:	6a40      	ldr	r0, [r0, #36]	; 0x24
    cmp r0, r1
    6a42:	4288      	cmp	r0, r1
    beq _EXIT_EXC
    6a44:	d003      	beq.n	6a4e <_EXIT_EXC>

#if defined(CONFIG_CPU_CORTEX_M)
    /* context switch required, pend the PendSV exception */
    ldr r1, =_SCS_ICSR
    6a46:	4903      	ldr	r1, [pc, #12]	; (6a54 <_EXIT_EXC+0x6>)
    ldr r2, =_SCS_ICSR_PENDSV
    6a48:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    str r2, [r1]
    6a4c:	600a      	str	r2, [r1, #0]

00006a4e <_EXIT_EXC>:
    bl z_check_stack_sentinel
#endif /* CONFIG_CPU_CORTEX_M */
#endif /* CONFIG_STACK_SENTINEL */

#if defined(CONFIG_CPU_CORTEX_M)
    bx lr
    6a4e:	4770      	bx	lr
    ldr r0, =_kernel
    6a50:	20006054 	.word	0x20006054
    ldr r1, =_SCS_ICSR
    6a54:	e000ed04 	.word	0xe000ed04

00006a58 <arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
    6a58:	4a09      	ldr	r2, [pc, #36]	; (6a80 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
    6a5a:	490a      	ldr	r1, [pc, #40]	; (6a84 <arch_swap+0x2c>)
	_current->arch.basepri = key;
    6a5c:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    6a5e:	6809      	ldr	r1, [r1, #0]
    6a60:	6699      	str	r1, [r3, #104]	; 0x68

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    6a62:	4909      	ldr	r1, [pc, #36]	; (6a88 <arch_swap+0x30>)
	_current->arch.basepri = key;
    6a64:	6658      	str	r0, [r3, #100]	; 0x64
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    6a66:	684b      	ldr	r3, [r1, #4]
    6a68:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    6a6c:	604b      	str	r3, [r1, #4]
    6a6e:	2300      	movs	r3, #0
    6a70:	f383 8811 	msr	BASEPRI, r3
    6a74:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    6a78:	6893      	ldr	r3, [r2, #8]
}
    6a7a:	6e98      	ldr	r0, [r3, #104]	; 0x68
    6a7c:	4770      	bx	lr
    6a7e:	bf00      	nop
    6a80:	20006054 	.word	0x20006054
    6a84:	00029808 	.word	0x00029808
    6a88:	e000ed00 	.word	0xe000ed00

00006a8c <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    6a8c:	4912      	ldr	r1, [pc, #72]	; (6ad8 <z_arm_pendsv+0x4c>)
    ldr r2, [r1, #_kernel_offset_to_current]
    6a8e:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    6a90:	f04f 0028 	mov.w	r0, #40	; 0x28
    add r0, r2
    6a94:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    6a96:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    6a9a:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    6a9e:	2020      	movs	r0, #32
    msr BASEPRI, r0
    6aa0:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    6aa4:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    6aa8:	4f0c      	ldr	r7, [pc, #48]	; (6adc <z_arm_pendsv+0x50>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    6aaa:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    6aae:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
    6ab0:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    6ab2:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    6ab4:	6e50      	ldr	r0, [r2, #100]	; 0x64
    movs r3, #0
    6ab6:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    6ab8:	6653      	str	r3, [r2, #100]	; 0x64
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    6aba:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined (CONFIG_ARM_MPU)
    /* Re-program dynamic memory map */
    push {r2,lr}
    6abe:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
    6ac0:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
    6ac2:	f01b f9f4 	bl	21eae <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
    6ac6:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    6aca:	f102 0028 	add.w	r0, r2, #40	; 0x28
    ldmia r0, {v1-v8, ip}
    6ace:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
    mov r0, #0
    msr PSPLIM, r0
#endif /* CONFIG_BUILTIN_STACK_GUARD */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    6ad2:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
    6ad6:	4770      	bx	lr
    ldr r1, =_kernel
    6ad8:	20006054 	.word	0x20006054
    ldr v4, =_SCS_ICSR
    6adc:	e000ed04 	.word	0xe000ed04

00006ae0 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
    6ae0:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    6ae4:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    6ae6:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    6aea:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    6aee:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    6af0:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    6af4:	2902      	cmp	r1, #2
    beq _oops
    6af6:	d0ff      	beq.n	6af8 <_oops>

00006af8 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    6af8:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    6afa:	f01b f9cd 	bl	21e98 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    6afe:	bd01      	pop	{r0, pc}

00006b00 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    6b00:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    6b02:	2b00      	cmp	r3, #0
    6b04:	db08      	blt.n	6b18 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    6b06:	2201      	movs	r2, #1
    6b08:	f000 001f 	and.w	r0, r0, #31
    6b0c:	fa02 f000 	lsl.w	r0, r2, r0
    6b10:	095b      	lsrs	r3, r3, #5
    6b12:	4a02      	ldr	r2, [pc, #8]	; (6b1c <arch_irq_enable+0x1c>)
    6b14:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    6b18:	4770      	bx	lr
    6b1a:	bf00      	nop
    6b1c:	e000e100 	.word	0xe000e100

00006b20 <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
    6b20:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    6b22:	2b00      	cmp	r3, #0
    6b24:	db0d      	blt.n	6b42 <arch_irq_disable+0x22>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    6b26:	2201      	movs	r2, #1
    6b28:	095b      	lsrs	r3, r3, #5
    6b2a:	f000 001f 	and.w	r0, r0, #31
    6b2e:	fa02 f000 	lsl.w	r0, r2, r0
    6b32:	3320      	adds	r3, #32
    6b34:	4a03      	ldr	r2, [pc, #12]	; (6b44 <arch_irq_disable+0x24>)
    6b36:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    6b3a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    6b3e:	f3bf 8f6f 	isb	sy
}
    6b42:	4770      	bx	lr
    6b44:	e000e100 	.word	0xe000e100

00006b48 <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    6b48:	0942      	lsrs	r2, r0, #5
    6b4a:	4b05      	ldr	r3, [pc, #20]	; (6b60 <arch_irq_is_enabled+0x18>)
    6b4c:	f000 001f 	and.w	r0, r0, #31
    6b50:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    6b54:	2301      	movs	r3, #1
    6b56:	fa03 f000 	lsl.w	r0, r3, r0
}
    6b5a:	4010      	ands	r0, r2
    6b5c:	4770      	bx	lr
    6b5e:	bf00      	nop
    6b60:	e000e100 	.word	0xe000e100

00006b64 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(DT_NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    6b64:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    6b66:	2b00      	cmp	r3, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    6b68:	bfa8      	it	ge
    6b6a:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
	prio += _IRQ_PRIO_OFFSET;
    6b6e:	f101 0101 	add.w	r1, r1, #1
    6b72:	ea4f 1141 	mov.w	r1, r1, lsl #5
    6b76:	bfae      	itee	ge
    6b78:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    6b7c:	f000 000f 	andlt.w	r0, r0, #15
    6b80:	4b03      	ldrlt	r3, [pc, #12]	; (6b90 <z_arm_irq_priority_set+0x2c>)
    6b82:	b2c9      	uxtb	r1, r1
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    6b84:	bfac      	ite	ge
    6b86:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    6b8a:	5419      	strblt	r1, [r3, r0]
}
    6b8c:	4770      	bx	lr
    6b8e:	bf00      	nop
    6b90:	e000ed14 	.word	0xe000ed14

00006b94 <_arch_isr_direct_pm>:
	z_arm_reserved();
}

#ifdef CONFIG_SYS_POWER_MANAGEMENT
void _arch_isr_direct_pm(void)
{
    6b94:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
    6b96:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
    6b98:	4b04      	ldr	r3, [pc, #16]	; (6bac <_arch_isr_direct_pm+0x18>)
    6b9a:	6a18      	ldr	r0, [r3, #32]
    6b9c:	b118      	cbz	r0, 6ba6 <_arch_isr_direct_pm+0x12>
		s32_t idle_val = _kernel.idle;

		_kernel.idle = 0;
    6b9e:	2200      	movs	r2, #0
    6ba0:	621a      	str	r2, [r3, #32]
		z_sys_power_save_idle_exit(idle_val);
    6ba2:	f020 ff17 	bl	279d4 <z_sys_power_save_idle_exit>

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
    6ba6:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
    6ba8:	bd08      	pop	{r3, pc}
    6baa:	bf00      	nop
    6bac:	20006054 	.word	0x20006054

00006bb0 <arch_new_thread>:
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     size_t stackSize, k_thread_entry_t pEntry,
		     void *parameter1, void *parameter2, void *parameter3,
		     int priority, unsigned int options)
{
    6bb0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    6bb2:	461e      	mov	r6, r3
#endif
	stackEnd = pStackMem + stackSize;

	struct __esf *pInitCtx;

	z_new_thread_init(thread, pStackMem, stackSize, priority,
    6bb4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6bb6:	9300      	str	r3, [sp, #0]
	stackEnd = pStackMem + stackSize;
    6bb8:	188c      	adds	r4, r1, r2
	z_new_thread_init(thread, pStackMem, stackSize, priority,
    6bba:	9b09      	ldr	r3, [sp, #36]	; 0x24
{
    6bbc:	4605      	mov	r5, r0
	z_new_thread_init(thread, pStackMem, stackSize, priority,
    6bbe:	f021 f934 	bl	27e2a <z_new_thread_init>
	 *
	 * The initial carved stack frame only needs to contain the basic
	 * stack frame (state context), because no FP operations have been
	 * performed yet for this thread.
	 */
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
    6bc2:	f1a4 0320 	sub.w	r3, r4, #32
	pInitCtx->basic.pc = (u32_t)z_thread_entry;
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
    6bc6:	4a0a      	ldr	r2, [pc, #40]	; (6bf0 <arch_new_thread+0x40>)
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
    6bc8:	f023 0307 	bic.w	r3, r3, #7
	pInitCtx->basic.pc &= 0xfffffffe;
    6bcc:	f022 0201 	bic.w	r2, r2, #1
    6bd0:	619a      	str	r2, [r3, #24]
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
	pInitCtx->basic.a2 = (u32_t)parameter1;
    6bd2:	9a06      	ldr	r2, [sp, #24]
    6bd4:	605a      	str	r2, [r3, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
    6bd6:	9a07      	ldr	r2, [sp, #28]
    6bd8:	609a      	str	r2, [r3, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
    6bda:	9a08      	ldr	r2, [sp, #32]
    6bdc:	60da      	str	r2, [r3, #12]
	pInitCtx->basic.xpsr =
    6bde:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
	pInitCtx->basic.a1 = (u32_t)pEntry;
    6be2:	601e      	str	r6, [r3, #0]
	pInitCtx->basic.xpsr =
    6be4:	61da      	str	r2, [r3, #28]
		0x01000000UL; /* clear all, thumb bit is 1, even if RO */

	thread->callee_saved.psp = (u32_t)pInitCtx;
    6be6:	64ab      	str	r3, [r5, #72]	; 0x48
#if defined(CONFIG_CPU_CORTEX_R)
	pInitCtx->basic.lr = (u32_t)pInitCtx->basic.pc;
	thread->callee_saved.spsr = A_BIT | T_BIT | MODE_SYS;
	thread->callee_saved.lr = (u32_t)pInitCtx->basic.pc;
#endif
	thread->arch.basepri = 0;
    6be8:	2300      	movs	r3, #0
    6bea:	666b      	str	r3, [r5, #100]	; 0x64

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    6bec:	b002      	add	sp, #8
    6bee:	bd70      	pop	{r4, r5, r6, pc}
    6bf0:	0001fe0f 	.word	0x0001fe0f

00006bf4 <arch_switch_to_main_thread>:

void arch_switch_to_main_thread(struct k_thread *main_thread,
				k_thread_stack_t *main_stack,
				size_t main_stack_size,
				k_thread_entry_t _main)
{
    6bf4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6bf6:	4605      	mov	r5, r0
    6bf8:	460c      	mov	r4, r1
    6bfa:	4617      	mov	r7, r2
    6bfc:	461e      	mov	r6, r3
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    6bfe:	f000 fb9b 	bl	7338 <z_arm_configure_static_mpu_regions>
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);

	_current = main_thread;
    6c02:	4b0a      	ldr	r3, [pc, #40]	; (6c2c <arch_switch_to_main_thread+0x38>)
	start_of_main_stack =
    6c04:	443c      	add	r4, r7
#ifdef CONFIG_ARM_MPU
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
    6c06:	4628      	mov	r0, r5
	_current = main_thread;
    6c08:	609d      	str	r5, [r3, #8]
	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);
    6c0a:	f024 0407 	bic.w	r4, r4, #7
	z_arm_configure_dynamic_mpu_regions(main_thread);
    6c0e:	f01b f94e 	bl	21eae <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    6c12:	4630      	mov	r0, r6
    6c14:	f384 8809 	msr	PSP, r4
    6c18:	2100      	movs	r1, #0
    6c1a:	b663      	cpsie	if
    6c1c:	f381 8811 	msr	BASEPRI, r1
    6c20:	f3bf 8f6f 	isb	sy
    6c24:	2200      	movs	r2, #0
    6c26:	2300      	movs	r3, #0
    6c28:	f019 f8f1 	bl	1fe0e <z_thread_entry>
	:
	: "r" (_main), "r" (start_of_main_stack)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    6c2c:	20006054 	.word	0x20006054

00006c30 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr r1, =_SCB_SCR
    6c30:	4901      	ldr	r1, [pc, #4]	; (6c38 <z_arm_cpu_idle_init+0x8>)
	movs.n r2, #_SCR_INIT_BITS
    6c32:	2210      	movs	r2, #16
	str r2, [r1]
    6c34:	600a      	str	r2, [r1, #0]
#endif
	bx lr
    6c36:	4770      	bx	lr
	ldr r1, =_SCB_SCR
    6c38:	e000ed10 	.word	0xe000ed10

00006c3c <arch_cpu_idle>:
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	cpsie i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* clear BASEPRI so wfi is awakened by incoming interrupts */
	eors.n r0, r0
    6c3c:	4040      	eors	r0, r0
	msr BASEPRI, r0
    6c3e:	f380 8811 	msr	BASEPRI, r0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	wfi
    6c42:	bf30      	wfi

	bx lr
    6c44:	4770      	bx	lr
    6c46:	bf00      	nop

00006c48 <z_arm_bus_fault>:
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_reserved)

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) || \
	defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	mrs r0, MSP
    6c48:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    6c4c:	f3ef 8109 	mrs	r1, PSP
	mov r2, lr /* EXC_RETURN */
    6c50:	4672      	mov	r2, lr

	push {r0, lr}
    6c52:	b501      	push	{r0, lr}
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE || CONFIG_ARMv7_M_ARMV8_M_MAINLINE */

	bl z_arm_fault
    6c54:	f000 fa46 	bl	70e4 <z_arm_fault>

#if defined(CONFIG_CPU_CORTEX_M)
	pop {r0, pc}
    6c58:	bd01      	pop	{r0, pc}
    6c5a:	bf00      	nop

00006c5c <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    6c5c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    6c5e:	4606      	mov	r6, r0

	if (esf != NULL) {
    6c60:	460c      	mov	r4, r1
    6c62:	2900      	cmp	r1, #0
    6c64:	d038      	beq.n	6cd8 <z_arm_fatal_error+0x7c>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
    6c66:	2201      	movs	r2, #1
    6c68:	f04f 0300 	mov.w	r3, #0
    6c6c:	f362 0307 	bfi	r3, r2, #0, #8
    6c70:	4d1d      	ldr	r5, [pc, #116]	; (6ce8 <z_arm_fatal_error+0x8c>)
    6c72:	4a1e      	ldr	r2, [pc, #120]	; (6cec <z_arm_fatal_error+0x90>)
    6c74:	481e      	ldr	r0, [pc, #120]	; (6cf0 <z_arm_fatal_error+0x94>)
    6c76:	1aad      	subs	r5, r5, r2
    6c78:	f3c5 05c9 	ubfx	r5, r5, #3, #10
    6c7c:	f365 138f 	bfi	r3, r5, #6, #10
    6c80:	f8ad 3000 	strh.w	r3, [sp]
    6c84:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
    6c88:	6809      	ldr	r1, [r1, #0]
    6c8a:	f01a fa0f 	bl	210ac <log_3>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
    6c8e:	2201      	movs	r2, #1
    6c90:	f04f 0300 	mov.w	r3, #0
    6c94:	f362 0307 	bfi	r3, r2, #0, #8
    6c98:	f365 138f 	bfi	r3, r5, #6, #10
    6c9c:	f8ad 3000 	strh.w	r3, [sp]
    6ca0:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    6ca4:	68e1      	ldr	r1, [r4, #12]
    6ca6:	4813      	ldr	r0, [pc, #76]	; (6cf4 <z_arm_fatal_error+0x98>)
    6ca8:	f01a fa00 	bl	210ac <log_3>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
    6cac:	2301      	movs	r3, #1
    6cae:	f04f 0200 	mov.w	r2, #0
    6cb2:	f363 0207 	bfi	r2, r3, #0, #8
    6cb6:	f365 128f 	bfi	r2, r5, #6, #10
    6cba:	69e1      	ldr	r1, [r4, #28]
    6cbc:	480e      	ldr	r0, [pc, #56]	; (6cf8 <z_arm_fatal_error+0x9c>)
    6cbe:	f01a f9c9 	bl	21054 <log_1>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    6cc2:	f04f 0200 	mov.w	r2, #0
    6cc6:	2301      	movs	r3, #1
    6cc8:	f363 0207 	bfi	r2, r3, #0, #8
    6ccc:	f365 128f 	bfi	r2, r5, #6, #10
    6cd0:	69a1      	ldr	r1, [r4, #24]
    6cd2:	480a      	ldr	r0, [pc, #40]	; (6cfc <z_arm_fatal_error+0xa0>)
    6cd4:	f01a f9be 	bl	21054 <log_1>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
    6cd8:	4621      	mov	r1, r4
    6cda:	4630      	mov	r0, r6
}
    6cdc:	b002      	add	sp, #8
    6cde:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_fatal_error(reason, esf);
    6ce2:	f017 b9df 	b.w	1e0a4 <z_fatal_error>
    6ce6:	bf00      	nop
    6ce8:	00028690 	.word	0x00028690
    6cec:	00028540 	.word	0x00028540
    6cf0:	00062493 	.word	0x00062493
    6cf4:	000624c2 	.word	0x000624c2
    6cf8:	000624f1 	.word	0x000624f1
    6cfc:	00062500 	.word	0x00062500

00006d00 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    6d00:	bf30      	wfi
    b z_SysNmiOnReset
    6d02:	f7ff bffd 	b.w	6d00 <z_SysNmiOnReset>
    6d06:	bf00      	nop

00006d08 <z_arm_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    6d08:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    6d0a:	4b08      	ldr	r3, [pc, #32]	; (6d2c <z_arm_prep_c+0x24>)
    6d0c:	4a08      	ldr	r2, [pc, #32]	; (6d30 <z_arm_prep_c+0x28>)
    6d0e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    6d12:	6093      	str	r3, [r2, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    6d14:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    6d18:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
	enable_floating_point();
	z_bss_zero();
    6d1c:	f017 fa40 	bl	1e1a0 <z_bss_zero>
	z_data_copy();
    6d20:	f017 fa48 	bl	1e1b4 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_int_lib_init();
    6d24:	f000 fad6 	bl	72d4 <z_arm_int_lib_init>
	z_cstart();
    6d28:	f017 fa7a 	bl	1e220 <z_cstart>
    6d2c:	00000000 	.word	0x00000000
    6d30:	e000ed00 	.word	0xe000ed00

00006d34 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    6d34:	b501      	push	{r0, lr}
      * FIXME: Remove the Cortex-M conditional compilation checks for `cpsid i`
      *        and `cpsie i` after the Cortex-R port is updated to support
      *        interrupt nesting.  For more details, refer to the issue #21758.
      */
#if defined(CONFIG_CPU_CORTEX_M)
	cpsid i  /* PRIMASK = 1 */
    6d36:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    6d38:	4a0b      	ldr	r2, [pc, #44]	; (6d68 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    6d3a:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
    6d3c:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    6d3e:	bf1e      	ittt	ne
	movne	r1, #0
    6d40:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    6d42:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
    6d44:	f020 fe46 	blne	279d4 <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    6d48:	b662      	cpsie	i
#endif

#endif /* CONFIG_SYS_POWER_MANAGEMENT */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    6d4a:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    6d4e:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    6d52:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 */
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldr r1, =_sw_isr_table
    6d56:	4905      	ldr	r1, [pc, #20]	; (6d6c <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    6d58:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    6d5a:	c909      	ldmia	r1!, {r0, r3}
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldm sp!,{r0-r3} /* Restore r0 to r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
    6d5c:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    6d5e:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    6d62:	4903      	ldr	r1, [pc, #12]	; (6d70 <_isr_wrapper+0x3c>)
	bx r1
    6d64:	4708      	bx	r1
    6d66:	0000      	.short	0x0000
	ldr r2, =_kernel
    6d68:	20006054 	.word	0x20006054
	ldr r1, =_sw_isr_table
    6d6c:	00028254 	.word	0x00028254
	ldr r1, =z_arm_int_exit
    6d70:	00006a3d 	.word	0x00006a3d

00006d74 <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
    6d74:	f01b fa31 	bl	221da <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    6d78:	2020      	movs	r0, #32
    msr BASEPRI, r0
    6d7a:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to _interrupt_stack during initialization.
     */
    ldr r0, =_interrupt_stack
    6d7e:	4808      	ldr	r0, [pc, #32]	; (6da0 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
    6d80:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
    6d84:	1840      	adds	r0, r0, r1
    msr PSP, r0
    6d86:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    6d8a:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    6d8e:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    6d90:	4308      	orrs	r0, r1
    msr CONTROL, r0
    6d92:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    6d96:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    6d9a:	f7ff ffb5 	bl	6d08 <z_arm_prep_c>
    6d9e:	0000      	.short	0x0000
    ldr r0, =_interrupt_stack
    6da0:	2000c6c0 	.word	0x2000c6c0

00006da4 <usage_fault.isra.2>:
 */
static u32_t usage_fault(const z_arch_esf_t *esf)
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
    6da4:	2301      	movs	r3, #1
    6da6:	f04f 0100 	mov.w	r1, #0
static u32_t usage_fault(const z_arch_esf_t *esf)
    6daa:	b510      	push	{r4, lr}
	PR_FAULT_INFO("***** USAGE FAULT *****");
    6dac:	f363 0107 	bfi	r1, r3, #0, #8
    6db0:	4c33      	ldr	r4, [pc, #204]	; (6e80 <usage_fault.isra.2+0xdc>)
    6db2:	4b34      	ldr	r3, [pc, #208]	; (6e84 <usage_fault.isra.2+0xe0>)
    6db4:	4834      	ldr	r0, [pc, #208]	; (6e88 <usage_fault.isra.2+0xe4>)
    6db6:	1ae4      	subs	r4, r4, r3
    6db8:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    6dbc:	f364 118f 	bfi	r1, r4, #6, #10
    6dc0:	f01a f93b 	bl	2103a <log_0>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    6dc4:	4b31      	ldr	r3, [pc, #196]	; (6e8c <usage_fault.isra.2+0xe8>)
    6dc6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6dc8:	019a      	lsls	r2, r3, #6
    6dca:	d509      	bpl.n	6de0 <usage_fault.isra.2+0x3c>
		PR_FAULT_INFO("  Division by zero");
    6dcc:	f04f 0100 	mov.w	r1, #0
    6dd0:	2301      	movs	r3, #1
    6dd2:	f363 0107 	bfi	r1, r3, #0, #8
    6dd6:	f364 118f 	bfi	r1, r4, #6, #10
    6dda:	482d      	ldr	r0, [pc, #180]	; (6e90 <usage_fault.isra.2+0xec>)
    6ddc:	f01a f92d 	bl	2103a <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    6de0:	4b2a      	ldr	r3, [pc, #168]	; (6e8c <usage_fault.isra.2+0xe8>)
    6de2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6de4:	01db      	lsls	r3, r3, #7
    6de6:	d509      	bpl.n	6dfc <usage_fault.isra.2+0x58>
		PR_FAULT_INFO("  Unaligned memory access");
    6de8:	f04f 0100 	mov.w	r1, #0
    6dec:	2301      	movs	r3, #1
    6dee:	f363 0107 	bfi	r1, r3, #0, #8
    6df2:	f364 118f 	bfi	r1, r4, #6, #10
    6df6:	4827      	ldr	r0, [pc, #156]	; (6e94 <usage_fault.isra.2+0xf0>)
    6df8:	f01a f91f 	bl	2103a <log_0>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    6dfc:	4b23      	ldr	r3, [pc, #140]	; (6e8c <usage_fault.isra.2+0xe8>)
    6dfe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6e00:	0318      	lsls	r0, r3, #12
    6e02:	d509      	bpl.n	6e18 <usage_fault.isra.2+0x74>
		PR_FAULT_INFO("  No coprocessor instructions");
    6e04:	f04f 0100 	mov.w	r1, #0
    6e08:	2301      	movs	r3, #1
    6e0a:	f363 0107 	bfi	r1, r3, #0, #8
    6e0e:	f364 118f 	bfi	r1, r4, #6, #10
    6e12:	4821      	ldr	r0, [pc, #132]	; (6e98 <usage_fault.isra.2+0xf4>)
    6e14:	f01a f911 	bl	2103a <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    6e18:	4b1c      	ldr	r3, [pc, #112]	; (6e8c <usage_fault.isra.2+0xe8>)
    6e1a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6e1c:	0359      	lsls	r1, r3, #13
    6e1e:	d509      	bpl.n	6e34 <usage_fault.isra.2+0x90>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
    6e20:	f04f 0100 	mov.w	r1, #0
    6e24:	2301      	movs	r3, #1
    6e26:	f363 0107 	bfi	r1, r3, #0, #8
    6e2a:	f364 118f 	bfi	r1, r4, #6, #10
    6e2e:	481b      	ldr	r0, [pc, #108]	; (6e9c <usage_fault.isra.2+0xf8>)
    6e30:	f01a f903 	bl	2103a <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    6e34:	4b15      	ldr	r3, [pc, #84]	; (6e8c <usage_fault.isra.2+0xe8>)
    6e36:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6e38:	039a      	lsls	r2, r3, #14
    6e3a:	d509      	bpl.n	6e50 <usage_fault.isra.2+0xac>
		PR_FAULT_INFO("  Illegal use of the EPSR");
    6e3c:	f04f 0100 	mov.w	r1, #0
    6e40:	2301      	movs	r3, #1
    6e42:	f363 0107 	bfi	r1, r3, #0, #8
    6e46:	f364 118f 	bfi	r1, r4, #6, #10
    6e4a:	4815      	ldr	r0, [pc, #84]	; (6ea0 <usage_fault.isra.2+0xfc>)
    6e4c:	f01a f8f5 	bl	2103a <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    6e50:	4b0e      	ldr	r3, [pc, #56]	; (6e8c <usage_fault.isra.2+0xe8>)
    6e52:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6e54:	03db      	lsls	r3, r3, #15
    6e56:	d509      	bpl.n	6e6c <usage_fault.isra.2+0xc8>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
    6e58:	f04f 0100 	mov.w	r1, #0
    6e5c:	2301      	movs	r3, #1
    6e5e:	f363 0107 	bfi	r1, r3, #0, #8
    6e62:	f364 118f 	bfi	r1, r4, #6, #10
    6e66:	480f      	ldr	r0, [pc, #60]	; (6ea4 <usage_fault.isra.2+0x100>)
    6e68:	f01a f8e7 	bl	2103a <log_0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    6e6c:	4a07      	ldr	r2, [pc, #28]	; (6e8c <usage_fault.isra.2+0xe8>)
    6e6e:	6a93      	ldr	r3, [r2, #40]	; 0x28
    6e70:	ea6f 4303 	mvn.w	r3, r3, lsl #16
    6e74:	ea6f 4313 	mvn.w	r3, r3, lsr #16
    6e78:	6293      	str	r3, [r2, #40]	; 0x28

	return reason;
}
    6e7a:	2000      	movs	r0, #0
    6e7c:	bd10      	pop	{r4, pc}
    6e7e:	bf00      	nop
    6e80:	00028690 	.word	0x00028690
    6e84:	00028540 	.word	0x00028540
    6e88:	0006268e 	.word	0x0006268e
    6e8c:	e000ed00 	.word	0xe000ed00
    6e90:	000626a6 	.word	0x000626a6
    6e94:	000626b9 	.word	0x000626b9
    6e98:	000626d3 	.word	0x000626d3
    6e9c:	000626f1 	.word	0x000626f1
    6ea0:	00062716 	.word	0x00062716
    6ea4:	00062730 	.word	0x00062730

00006ea8 <mem_manage_fault.isra.4>:
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
    6ea8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	PR_FAULT_INFO("***** MPU FAULT *****");
    6eaa:	2301      	movs	r3, #1
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
    6eac:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
    6eae:	f04f 0100 	mov.w	r1, #0
    6eb2:	f363 0107 	bfi	r1, r3, #0, #8
    6eb6:	4c36      	ldr	r4, [pc, #216]	; (6f90 <mem_manage_fault.isra.4+0xe8>)
    6eb8:	4b36      	ldr	r3, [pc, #216]	; (6f94 <mem_manage_fault.isra.4+0xec>)
    6eba:	1ae4      	subs	r4, r4, r3
    6ebc:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    6ec0:	f364 118f 	bfi	r1, r4, #6, #10
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
    6ec4:	4607      	mov	r7, r0
	PR_FAULT_INFO("***** MPU FAULT *****");
    6ec6:	4834      	ldr	r0, [pc, #208]	; (6f98 <mem_manage_fault.isra.4+0xf0>)
    6ec8:	f01a f8b7 	bl	2103a <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    6ecc:	4b33      	ldr	r3, [pc, #204]	; (6f9c <mem_manage_fault.isra.4+0xf4>)
    6ece:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6ed0:	06d9      	lsls	r1, r3, #27
    6ed2:	d509      	bpl.n	6ee8 <mem_manage_fault.isra.4+0x40>
		PR_FAULT_INFO("  Stacking error (context area might be"
    6ed4:	f04f 0100 	mov.w	r1, #0
    6ed8:	2301      	movs	r3, #1
    6eda:	f363 0107 	bfi	r1, r3, #0, #8
    6ede:	f364 118f 	bfi	r1, r4, #6, #10
    6ee2:	482f      	ldr	r0, [pc, #188]	; (6fa0 <mem_manage_fault.isra.4+0xf8>)
    6ee4:	f01a f8a9 	bl	2103a <log_0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    6ee8:	4b2c      	ldr	r3, [pc, #176]	; (6f9c <mem_manage_fault.isra.4+0xf4>)
    6eea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6eec:	071a      	lsls	r2, r3, #28
    6eee:	d509      	bpl.n	6f04 <mem_manage_fault.isra.4+0x5c>
		PR_FAULT_INFO("  Unstacking error");
    6ef0:	f04f 0100 	mov.w	r1, #0
    6ef4:	2301      	movs	r3, #1
    6ef6:	f363 0107 	bfi	r1, r3, #0, #8
    6efa:	f364 118f 	bfi	r1, r4, #6, #10
    6efe:	4829      	ldr	r0, [pc, #164]	; (6fa4 <mem_manage_fault.isra.4+0xfc>)
    6f00:	f01a f89b 	bl	2103a <log_0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    6f04:	4d25      	ldr	r5, [pc, #148]	; (6f9c <mem_manage_fault.isra.4+0xf4>)
    6f06:	6aab      	ldr	r3, [r5, #40]	; 0x28
    6f08:	079b      	lsls	r3, r3, #30
    6f0a:	d51c      	bpl.n	6f46 <mem_manage_fault.isra.4+0x9e>
		PR_FAULT_INFO("  Data Access Violation");
    6f0c:	2301      	movs	r3, #1
    6f0e:	f04f 0100 	mov.w	r1, #0
    6f12:	f363 0107 	bfi	r1, r3, #0, #8
    6f16:	f364 118f 	bfi	r1, r4, #6, #10
    6f1a:	4823      	ldr	r0, [pc, #140]	; (6fa8 <mem_manage_fault.isra.4+0x100>)
    6f1c:	f01a f88d 	bl	2103a <log_0>
		mmfar = SCB->MMFAR;
    6f20:	6b69      	ldr	r1, [r5, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    6f22:	6aab      	ldr	r3, [r5, #40]	; 0x28
    6f24:	0618      	lsls	r0, r3, #24
    6f26:	d50e      	bpl.n	6f46 <mem_manage_fault.isra.4+0x9e>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
    6f28:	f04f 0200 	mov.w	r2, #0
    6f2c:	2301      	movs	r3, #1
    6f2e:	f363 0207 	bfi	r2, r3, #0, #8
    6f32:	f364 128f 	bfi	r2, r4, #6, #10
    6f36:	481d      	ldr	r0, [pc, #116]	; (6fac <mem_manage_fault.isra.4+0x104>)
    6f38:	f01a f88c 	bl	21054 <log_1>
			if (from_hard_fault) {
    6f3c:	b11f      	cbz	r7, 6f46 <mem_manage_fault.isra.4+0x9e>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    6f3e:	6aab      	ldr	r3, [r5, #40]	; 0x28
    6f40:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    6f44:	62ab      	str	r3, [r5, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    6f46:	4b15      	ldr	r3, [pc, #84]	; (6f9c <mem_manage_fault.isra.4+0xf4>)
    6f48:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6f4a:	07da      	lsls	r2, r3, #31
    6f4c:	d509      	bpl.n	6f62 <mem_manage_fault.isra.4+0xba>
		PR_FAULT_INFO("  Instruction Access Violation");
    6f4e:	f04f 0100 	mov.w	r1, #0
    6f52:	2301      	movs	r3, #1
    6f54:	f363 0107 	bfi	r1, r3, #0, #8
    6f58:	f364 118f 	bfi	r1, r4, #6, #10
    6f5c:	4814      	ldr	r0, [pc, #80]	; (6fb0 <mem_manage_fault.isra.4+0x108>)
    6f5e:	f01a f86c 	bl	2103a <log_0>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    6f62:	4b0e      	ldr	r3, [pc, #56]	; (6f9c <mem_manage_fault.isra.4+0xf4>)
    6f64:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6f66:	069b      	lsls	r3, r3, #26
    6f68:	d509      	bpl.n	6f7e <mem_manage_fault.isra.4+0xd6>
		PR_FAULT_INFO(
    6f6a:	f04f 0100 	mov.w	r1, #0
    6f6e:	2301      	movs	r3, #1
    6f70:	f363 0107 	bfi	r1, r3, #0, #8
    6f74:	f364 118f 	bfi	r1, r4, #6, #10
    6f78:	480e      	ldr	r0, [pc, #56]	; (6fb4 <mem_manage_fault.isra.4+0x10c>)
    6f7a:	f01a f85e 	bl	2103a <log_0>
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
    6f7e:	4b07      	ldr	r3, [pc, #28]	; (6f9c <mem_manage_fault.isra.4+0xf4>)
    6f80:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    6f82:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    6f84:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    6f86:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
    6f8a:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    6f8c:	7030      	strb	r0, [r6, #0]
}
    6f8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6f90:	00028690 	.word	0x00028690
    6f94:	00028540 	.word	0x00028540
    6f98:	000625b6 	.word	0x000625b6
    6f9c:	e000ed00 	.word	0xe000ed00
    6fa0:	000625cc 	.word	0x000625cc
    6fa4:	000625ff 	.word	0x000625ff
    6fa8:	00062612 	.word	0x00062612
    6fac:	0006262a 	.word	0x0006262a
    6fb0:	00062640 	.word	0x00062640
    6fb4:	0006265f 	.word	0x0006265f

00006fb8 <bus_fault.isra.5>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    6fb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	PR_FAULT_INFO("***** BUS FAULT *****");
    6fba:	2301      	movs	r3, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    6fbc:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
    6fbe:	f04f 0100 	mov.w	r1, #0
    6fc2:	f363 0107 	bfi	r1, r3, #0, #8
    6fc6:	4c3c      	ldr	r4, [pc, #240]	; (70b8 <bus_fault.isra.5+0x100>)
    6fc8:	4b3c      	ldr	r3, [pc, #240]	; (70bc <bus_fault.isra.5+0x104>)
    6fca:	1ae4      	subs	r4, r4, r3
    6fcc:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    6fd0:	f364 118f 	bfi	r1, r4, #6, #10
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    6fd4:	4607      	mov	r7, r0
	PR_FAULT_INFO("***** BUS FAULT *****");
    6fd6:	483a      	ldr	r0, [pc, #232]	; (70c0 <bus_fault.isra.5+0x108>)
    6fd8:	f01a f82f 	bl	2103a <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    6fdc:	4b39      	ldr	r3, [pc, #228]	; (70c4 <bus_fault.isra.5+0x10c>)
    6fde:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6fe0:	04d9      	lsls	r1, r3, #19
    6fe2:	d509      	bpl.n	6ff8 <bus_fault.isra.5+0x40>
		PR_FAULT_INFO("  Stacking error");
    6fe4:	f04f 0100 	mov.w	r1, #0
    6fe8:	2301      	movs	r3, #1
    6fea:	f363 0107 	bfi	r1, r3, #0, #8
    6fee:	f364 118f 	bfi	r1, r4, #6, #10
    6ff2:	4835      	ldr	r0, [pc, #212]	; (70c8 <bus_fault.isra.5+0x110>)
    6ff4:	f01a f821 	bl	2103a <log_0>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    6ff8:	4b32      	ldr	r3, [pc, #200]	; (70c4 <bus_fault.isra.5+0x10c>)
    6ffa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6ffc:	051a      	lsls	r2, r3, #20
    6ffe:	d509      	bpl.n	7014 <bus_fault.isra.5+0x5c>
		PR_FAULT_INFO("  Unstacking error");
    7000:	f04f 0100 	mov.w	r1, #0
    7004:	2301      	movs	r3, #1
    7006:	f363 0107 	bfi	r1, r3, #0, #8
    700a:	f364 118f 	bfi	r1, r4, #6, #10
    700e:	482f      	ldr	r0, [pc, #188]	; (70cc <bus_fault.isra.5+0x114>)
    7010:	f01a f813 	bl	2103a <log_0>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    7014:	4d2b      	ldr	r5, [pc, #172]	; (70c4 <bus_fault.isra.5+0x10c>)
    7016:	6aab      	ldr	r3, [r5, #40]	; 0x28
    7018:	059b      	lsls	r3, r3, #22
    701a:	d51c      	bpl.n	7056 <bus_fault.isra.5+0x9e>
		PR_FAULT_INFO("  Precise data bus error");
    701c:	2301      	movs	r3, #1
    701e:	f04f 0100 	mov.w	r1, #0
    7022:	f363 0107 	bfi	r1, r3, #0, #8
    7026:	f364 118f 	bfi	r1, r4, #6, #10
    702a:	4829      	ldr	r0, [pc, #164]	; (70d0 <bus_fault.isra.5+0x118>)
    702c:	f01a f805 	bl	2103a <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
    7030:	6ba9      	ldr	r1, [r5, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    7032:	6aab      	ldr	r3, [r5, #40]	; 0x28
    7034:	0418      	lsls	r0, r3, #16
    7036:	d50e      	bpl.n	7056 <bus_fault.isra.5+0x9e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
    7038:	f04f 0200 	mov.w	r2, #0
    703c:	2301      	movs	r3, #1
    703e:	f363 0207 	bfi	r2, r3, #0, #8
    7042:	f364 128f 	bfi	r2, r4, #6, #10
    7046:	4823      	ldr	r0, [pc, #140]	; (70d4 <bus_fault.isra.5+0x11c>)
    7048:	f01a f804 	bl	21054 <log_1>
			if (from_hard_fault) {
    704c:	b11f      	cbz	r7, 7056 <bus_fault.isra.5+0x9e>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    704e:	6aab      	ldr	r3, [r5, #40]	; 0x28
    7050:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    7054:	62ab      	str	r3, [r5, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    7056:	4b1b      	ldr	r3, [pc, #108]	; (70c4 <bus_fault.isra.5+0x10c>)
    7058:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    705a:	0559      	lsls	r1, r3, #21
    705c:	d509      	bpl.n	7072 <bus_fault.isra.5+0xba>
		PR_FAULT_INFO("  Imprecise data bus error");
    705e:	f04f 0100 	mov.w	r1, #0
    7062:	2301      	movs	r3, #1
    7064:	f363 0107 	bfi	r1, r3, #0, #8
    7068:	f364 118f 	bfi	r1, r4, #6, #10
    706c:	481a      	ldr	r0, [pc, #104]	; (70d8 <bus_fault.isra.5+0x120>)
    706e:	f019 ffe4 	bl	2103a <log_0>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    7072:	4b14      	ldr	r3, [pc, #80]	; (70c4 <bus_fault.isra.5+0x10c>)
    7074:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    7076:	05d2      	lsls	r2, r2, #23
    7078:	d511      	bpl.n	709e <bus_fault.isra.5+0xe6>
		PR_FAULT_INFO("  Instruction bus error");
    707a:	f04f 0100 	mov.w	r1, #0
    707e:	2301      	movs	r3, #1
    7080:	f363 0107 	bfi	r1, r3, #0, #8
    7084:	4815      	ldr	r0, [pc, #84]	; (70dc <bus_fault.isra.5+0x124>)
    7086:	f364 118f 	bfi	r1, r4, #6, #10
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    708a:	f019 ffd6 	bl	2103a <log_0>
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    708e:	4a0d      	ldr	r2, [pc, #52]	; (70c4 <bus_fault.isra.5+0x10c>)
    7090:	6a93      	ldr	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    7092:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    7094:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
    7098:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    709a:	7030      	strb	r0, [r6, #0]
}
    709c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    709e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    70a0:	049b      	lsls	r3, r3, #18
    70a2:	d5f4      	bpl.n	708e <bus_fault.isra.5+0xd6>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    70a4:	f04f 0100 	mov.w	r1, #0
    70a8:	2301      	movs	r3, #1
    70aa:	f363 0107 	bfi	r1, r3, #0, #8
    70ae:	f364 118f 	bfi	r1, r4, #6, #10
    70b2:	480b      	ldr	r0, [pc, #44]	; (70e0 <bus_fault.isra.5+0x128>)
    70b4:	e7e9      	b.n	708a <bus_fault.isra.5+0xd2>
    70b6:	bf00      	nop
    70b8:	00028690 	.word	0x00028690
    70bc:	00028540 	.word	0x00028540
    70c0:	0006252e 	.word	0x0006252e
    70c4:	e000ed00 	.word	0xe000ed00
    70c8:	00062544 	.word	0x00062544
    70cc:	000625ff 	.word	0x000625ff
    70d0:	00062555 	.word	0x00062555
    70d4:	0006256e 	.word	0x0006256e
    70d8:	00062583 	.word	0x00062583
    70dc:	0006259e 	.word	0x0006259e
    70e0:	0006265f 	.word	0x0006265f

000070e4 <z_arm_fault>:
 * @param psp PSP value immediately after the exception occurred
 * @param exc_return EXC_RETURN value present in LR after exception entry.
 *
 */
void z_arm_fault(u32_t msp, u32_t psp, u32_t exc_return)
{
    70e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    70e8:	4b68      	ldr	r3, [pc, #416]	; (728c <z_arm_fault+0x1a8>)
    70ea:	685f      	ldr	r7, [r3, #4]
{
    70ec:	b08a      	sub	sp, #40	; 0x28
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    70ee:	f3c7 0408 	ubfx	r4, r7, #0, #9
    70f2:	2600      	movs	r6, #0
    70f4:	f386 8811 	msr	BASEPRI, r6
    70f8:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    70fc:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
    7100:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
    7104:	d111      	bne.n	712a <z_arm_fault+0x46>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    7106:	f002 030c 	and.w	r3, r2, #12
    710a:	2b08      	cmp	r3, #8
    710c:	d10f      	bne.n	712e <z_arm_fault+0x4a>
		PR_EXC("SPSEL in thread mode does not indicate PSP");
    710e:	2301      	movs	r3, #1
    7110:	f04f 0100 	mov.w	r1, #0
    7114:	f363 0107 	bfi	r1, r3, #0, #8
    7118:	4a5d      	ldr	r2, [pc, #372]	; (7290 <z_arm_fault+0x1ac>)
    711a:	4b5e      	ldr	r3, [pc, #376]	; (7294 <z_arm_fault+0x1b0>)
    711c:	485e      	ldr	r0, [pc, #376]	; (7298 <z_arm_fault+0x1b4>)
    711e:	1a9b      	subs	r3, r3, r2
    7120:	08db      	lsrs	r3, r3, #3
    7122:	f363 118f 	bfi	r1, r3, #6, #10
    7126:	f019 ff88 	bl	2103a <log_0>
		return NULL;
    712a:	4635      	mov	r5, r6
    712c:	e004      	b.n	7138 <z_arm_fault+0x54>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    712e:	0712      	lsls	r2, r2, #28
			ptr_esf =  (z_arch_esf_t *)psp;
    7130:	bf4e      	itee	mi
    7132:	460d      	movmi	r5, r1
			ptr_esf = (z_arch_esf_t *)msp;
    7134:	4605      	movpl	r5, r0
			*nested_exc = true;
    7136:	2601      	movpl	r6, #1
	*recoverable = false;
    7138:	2300      	movs	r3, #0
    713a:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
    713e:	1ee3      	subs	r3, r4, #3
    7140:	2b09      	cmp	r3, #9
    7142:	f200 8087 	bhi.w	7254 <z_arm_fault+0x170>
    7146:	e8df f003 	tbb	[pc, r3]
    714a:	7005      	.short	0x7005
    714c:	85854c74 	.word	0x85854c74
    7150:	78858585 	.word	0x78858585
	PR_FAULT_INFO("***** HARD FAULT *****");
    7154:	2301      	movs	r3, #1
    7156:	f04f 0100 	mov.w	r1, #0
    715a:	f363 0107 	bfi	r1, r3, #0, #8
    715e:	4f4d      	ldr	r7, [pc, #308]	; (7294 <z_arm_fault+0x1b0>)
    7160:	4b4b      	ldr	r3, [pc, #300]	; (7290 <z_arm_fault+0x1ac>)
    7162:	484e      	ldr	r0, [pc, #312]	; (729c <z_arm_fault+0x1b8>)
    7164:	1aff      	subs	r7, r7, r3
    7166:	f3c7 07c9 	ubfx	r7, r7, #3, #10
    716a:	f367 118f 	bfi	r1, r7, #6, #10
    716e:	f019 ff64 	bl	2103a <log_0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    7172:	4b46      	ldr	r3, [pc, #280]	; (728c <z_arm_fault+0x1a8>)
    7174:	6adc      	ldr	r4, [r3, #44]	; 0x2c
	*recoverable = false;
    7176:	f04f 0800 	mov.w	r8, #0
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    717a:	f014 0402 	ands.w	r4, r4, #2
	*recoverable = false;
    717e:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    7182:	d00b      	beq.n	719c <z_arm_fault+0xb8>
		PR_EXC("  Bus fault on vector table read");
    7184:	f04f 0100 	mov.w	r1, #0
    7188:	2301      	movs	r3, #1
    718a:	f363 0107 	bfi	r1, r3, #0, #8
    718e:	4844      	ldr	r0, [pc, #272]	; (72a0 <z_arm_fault+0x1bc>)
    7190:	f367 118f 	bfi	r1, r7, #6, #10
	PR_FAULT_INFO(
    7194:	f019 ff51 	bl	2103a <log_0>
	u32_t reason = K_ERR_CPU_EXCEPTION;
    7198:	2400      	movs	r4, #0
    719a:	e025      	b.n	71e8 <z_arm_fault+0x104>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    719c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    719e:	005b      	lsls	r3, r3, #1
    71a0:	d522      	bpl.n	71e8 <z_arm_fault+0x104>
		PR_EXC("  Fault escalation (see below)");
    71a2:	2301      	movs	r3, #1
    71a4:	f04f 0100 	mov.w	r1, #0
    71a8:	f363 0107 	bfi	r1, r3, #0, #8
    71ac:	f367 118f 	bfi	r1, r7, #6, #10
    71b0:	483c      	ldr	r0, [pc, #240]	; (72a4 <z_arm_fault+0x1c0>)
    71b2:	f019 ff42 	bl	2103a <log_0>
		if (SCB_MMFSR != 0) {
    71b6:	4b3c      	ldr	r3, [pc, #240]	; (72a8 <z_arm_fault+0x1c4>)
    71b8:	781b      	ldrb	r3, [r3, #0]
    71ba:	b12b      	cbz	r3, 71c8 <z_arm_fault+0xe4>
			reason = mem_manage_fault(esf, 1, recoverable);
    71bc:	f10d 0107 	add.w	r1, sp, #7
    71c0:	2001      	movs	r0, #1
		reason = mem_manage_fault(esf, 0, recoverable);
    71c2:	f7ff fe71 	bl	6ea8 <mem_manage_fault.isra.4>
    71c6:	e00e      	b.n	71e6 <z_arm_fault+0x102>
		} else if (SCB_BFSR != 0) {
    71c8:	4b38      	ldr	r3, [pc, #224]	; (72ac <z_arm_fault+0x1c8>)
    71ca:	781b      	ldrb	r3, [r3, #0]
    71cc:	b12b      	cbz	r3, 71da <z_arm_fault+0xf6>
			reason = bus_fault(esf, 1, recoverable);
    71ce:	f10d 0107 	add.w	r1, sp, #7
    71d2:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
    71d4:	f7ff fef0 	bl	6fb8 <bus_fault.isra.5>
    71d8:	e005      	b.n	71e6 <z_arm_fault+0x102>
		} else if (SCB_UFSR != 0) {
    71da:	4b35      	ldr	r3, [pc, #212]	; (72b0 <z_arm_fault+0x1cc>)
    71dc:	881b      	ldrh	r3, [r3, #0]
    71de:	b29b      	uxth	r3, r3
    71e0:	b113      	cbz	r3, 71e8 <z_arm_fault+0x104>
			reason = usage_fault(esf);
    71e2:	f7ff fddf 	bl	6da4 <usage_fault.isra.2>
    71e6:	4604      	mov	r4, r0
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
		"ESF could not be retrieved successfully. Shall never occur.");

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
    71e8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    71ec:	b9d3      	cbnz	r3, 7224 <z_arm_fault+0x140>
		return;
	}

	/* Copy ESF */
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    71ee:	462b      	mov	r3, r5
    71f0:	f103 0720 	add.w	r7, r3, #32
    71f4:	ad02      	add	r5, sp, #8
    71f6:	6818      	ldr	r0, [r3, #0]
    71f8:	6859      	ldr	r1, [r3, #4]
    71fa:	462a      	mov	r2, r5
    71fc:	c203      	stmia	r2!, {r0, r1}
    71fe:	3308      	adds	r3, #8
    7200:	42bb      	cmp	r3, r7
    7202:	4615      	mov	r5, r2
    7204:	d1f7      	bne.n	71f6 <z_arm_fault+0x112>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    7206:	9b09      	ldr	r3, [sp, #36]	; 0x24
    7208:	2e00      	cmp	r6, #0
    720a:	d03a      	beq.n	7282 <z_arm_fault+0x19e>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    720c:	f3c3 0208 	ubfx	r2, r3, #0, #9
    7210:	b922      	cbnz	r2, 721c <z_arm_fault+0x138>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    7212:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    7216:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    721a:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
    721c:	a902      	add	r1, sp, #8
    721e:	4620      	mov	r0, r4
    7220:	f7ff fd1c 	bl	6c5c <z_arm_fatal_error>
}
    7224:	b00a      	add	sp, #40	; 0x28
    7226:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
    722a:	f10d 0107 	add.w	r1, sp, #7
    722e:	2000      	movs	r0, #0
    7230:	e7c7      	b.n	71c2 <z_arm_fault+0xde>
		reason = bus_fault(esf, 0, recoverable);
    7232:	f10d 0107 	add.w	r1, sp, #7
    7236:	2000      	movs	r0, #0
    7238:	e7cc      	b.n	71d4 <z_arm_fault+0xf0>
	PR_FAULT_INFO(
    723a:	2301      	movs	r3, #1
    723c:	f04f 0100 	mov.w	r1, #0
    7240:	f363 0107 	bfi	r1, r3, #0, #8
    7244:	4a12      	ldr	r2, [pc, #72]	; (7290 <z_arm_fault+0x1ac>)
    7246:	4b13      	ldr	r3, [pc, #76]	; (7294 <z_arm_fault+0x1b0>)
    7248:	481a      	ldr	r0, [pc, #104]	; (72b4 <z_arm_fault+0x1d0>)
    724a:	1a9b      	subs	r3, r3, r2
    724c:	08db      	lsrs	r3, r3, #3
    724e:	f363 118f 	bfi	r1, r3, #6, #10
    7252:	e79f      	b.n	7194 <z_arm_fault+0xb0>
	PR_FAULT_INFO("***** %s %d) *****",
    7254:	2201      	movs	r2, #1
    7256:	f04f 0300 	mov.w	r3, #0
    725a:	f362 0307 	bfi	r3, r2, #0, #8
    725e:	490d      	ldr	r1, [pc, #52]	; (7294 <z_arm_fault+0x1b0>)
    7260:	4a0b      	ldr	r2, [pc, #44]	; (7290 <z_arm_fault+0x1ac>)
    7262:	4815      	ldr	r0, [pc, #84]	; (72b8 <z_arm_fault+0x1d4>)
    7264:	1a89      	subs	r1, r1, r2
    7266:	08c9      	lsrs	r1, r1, #3
    7268:	f417 7ff8 	tst.w	r7, #496	; 0x1f0
    726c:	f361 138f 	bfi	r3, r1, #6, #10
    7270:	f1a4 0210 	sub.w	r2, r4, #16
    7274:	4911      	ldr	r1, [pc, #68]	; (72bc <z_arm_fault+0x1d8>)
    7276:	bf18      	it	ne
    7278:	4601      	movne	r1, r0
    727a:	4811      	ldr	r0, [pc, #68]	; (72c0 <z_arm_fault+0x1dc>)
    727c:	f019 fefe 	bl	2107c <log_2>
    7280:	e78a      	b.n	7198 <z_arm_fault+0xb4>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    7282:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    7286:	f023 0301 	bic.w	r3, r3, #1
    728a:	e7c6      	b.n	721a <z_arm_fault+0x136>
    728c:	e000ed00 	.word	0xe000ed00
    7290:	00028540 	.word	0x00028540
    7294:	00028690 	.word	0x00028690
    7298:	0006275b 	.word	0x0006275b
    729c:	00062786 	.word	0x00062786
    72a0:	0006279d 	.word	0x0006279d
    72a4:	000627be 	.word	0x000627be
    72a8:	e000ed28 	.word	0xe000ed28
    72ac:	e000ed29 	.word	0xe000ed29
    72b0:	e000ed2a 	.word	0xe000ed2a
    72b4:	000627dd 	.word	0x000627dd
    72b8:	00062828 	.word	0x00062828
    72bc:	00062813 	.word	0x00062813
    72c0:	00062841 	.word	0x00062841

000072c4 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    72c4:	4a02      	ldr	r2, [pc, #8]	; (72d0 <z_arm_fault_init+0xc>)
    72c6:	6953      	ldr	r3, [r2, #20]
    72c8:	f043 0310 	orr.w	r3, r3, #16
    72cc:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    72ce:	4770      	bx	lr
    72d0:	e000ed00 	.word	0xe000ed00

000072d4 <z_arm_int_lib_init>:
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    72d4:	4804      	ldr	r0, [pc, #16]	; (72e8 <z_arm_int_lib_init+0x14>)
 * @return N/A
 */

void z_arm_int_lib_init(void)
{
	int irq = 0;
    72d6:	2300      	movs	r3, #0
    72d8:	2120      	movs	r1, #32
    72da:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    72dc:	3301      	adds	r3, #1
    72de:	2b27      	cmp	r3, #39	; 0x27
    72e0:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    72e4:	d1f9      	bne.n	72da <z_arm_int_lib_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    72e6:	4770      	bx	lr
    72e8:	e000e100 	.word	0xe000e100

000072ec <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
    72ec:	b538      	push	{r3, r4, r5, lr}
    72ee:	4605      	mov	r5, r0
	__asm__ volatile(
    72f0:	f04f 0320 	mov.w	r3, #32
    72f4:	f3ef 8411 	mrs	r4, BASEPRI
    72f8:	f383 8811 	msr	BASEPRI, r3
    72fc:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
		 "essential thread aborted");

	z_thread_single_abort(thread);
    7300:	f017 fb62 	bl	1e9c8 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
    7304:	4b0a      	ldr	r3, [pc, #40]	; (7330 <z_impl_k_thread_abort+0x44>)
    7306:	689b      	ldr	r3, [r3, #8]
    7308:	42ab      	cmp	r3, r5
    730a:	d10b      	bne.n	7324 <z_impl_k_thread_abort+0x38>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
    730c:	4b09      	ldr	r3, [pc, #36]	; (7334 <z_impl_k_thread_abort+0x48>)
    730e:	685a      	ldr	r2, [r3, #4]
    7310:	f3c2 0208 	ubfx	r2, r2, #0, #9
    7314:	b912      	cbnz	r2, 731c <z_impl_k_thread_abort+0x30>
	int ret;
	z_check_stack_sentinel();
#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
    7316:	4620      	mov	r0, r4
    7318:	f7ff fb9e 	bl	6a58 <arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    731c:	685a      	ldr	r2, [r3, #4]
    731e:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    7322:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
    7324:	4620      	mov	r0, r4
}
    7326:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
    732a:	f020 bcc0 	b.w	27cae <z_reschedule_irqlock>
    732e:	bf00      	nop
    7330:	20006054 	.word	0x20006054
    7334:	e000ed00 	.word	0xe000ed00

00007338 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    7338:	b51f      	push	{r0, r1, r2, r3, r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
    733a:	4b08      	ldr	r3, [pc, #32]	; (735c <z_arm_configure_static_mpu_regions+0x24>)
    733c:	9301      	str	r3, [sp, #4]
    733e:	4b08      	ldr	r3, [pc, #32]	; (7360 <z_arm_configure_static_mpu_regions+0x28>)
    7340:	9302      	str	r3, [sp, #8]
    7342:	4b08      	ldr	r3, [pc, #32]	; (7364 <z_arm_configure_static_mpu_regions+0x2c>)
    7344:	9303      	str	r3, [sp, #12]

	/* Define a constant array of k_mem_partition objects
	 * to hold the configuration of the respective static
	 * MPU regions.
	 */
	const struct k_mem_partition *static_regions[] = {
    7346:	ab01      	add	r3, sp, #4
    7348:	9300      	str	r3, [sp, #0]
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    734a:	4a07      	ldr	r2, [pc, #28]	; (7368 <z_arm_configure_static_mpu_regions+0x30>)
    734c:	4b07      	ldr	r3, [pc, #28]	; (736c <z_arm_configure_static_mpu_regions+0x34>)
    734e:	2101      	movs	r1, #1
    7350:	4668      	mov	r0, sp
    7352:	f000 f8b5 	bl	74c0 <arm_core_mpu_configure_static_mpu_regions>
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    7356:	b005      	add	sp, #20
    7358:	f85d fb04 	ldr.w	pc, [sp], #4
    735c:	20000000 	.word	0x20000000
    7360:	00000000 	.word	0x00000000
    7364:	060b0000 	.word	0x060b0000
    7368:	20000000 	.word	0x20000000
    736c:	20010000 	.word	0x20010000

00007370 <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct k_mem_partition
	*regions[], u8_t regions_num, u8_t start_reg_index,
	bool do_sanity_check)
{
    7370:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Select the region you want to access */
	MPU->RNR = index;
    7372:	4f2e      	ldr	r7, [pc, #184]	; (742c <mpu_configure_regions+0xbc>)
    7374:	460e      	mov	r6, r1
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
    7376:	2100      	movs	r1, #0
    7378:	42b1      	cmp	r1, r6
    737a:	da22      	bge.n	73c2 <mpu_configure_regions+0x52>
		if (regions[i]->size == 0U) {
    737c:	f850 c021 	ldr.w	ip, [r0, r1, lsl #2]
    7380:	f8dc 4004 	ldr.w	r4, [ip, #4]
    7384:	2c00      	cmp	r4, #0
    7386:	d04f      	beq.n	7428 <mpu_configure_regions+0xb8>
			continue;
		}
		/* Non-empty region. */

		if (do_sanity_check &&
    7388:	b1eb      	cbz	r3, 73c6 <mpu_configure_regions+0x56>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1)) == 0U)
    738a:	f104 3eff 	add.w	lr, r4, #4294967295	; 0xffffffff
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
    738e:	ea14 0f0e 	tst.w	r4, lr
    7392:	d106      	bne.n	73a2 <mpu_configure_regions+0x32>
		&&
    7394:	2c1f      	cmp	r4, #31
    7396:	d904      	bls.n	73a2 <mpu_configure_regions+0x32>
		((part->start & (part->size - 1)) == 0U);
    7398:	f8dc 5000 	ldr.w	r5, [ip]
		&&
    739c:	ea1e 0f05 	tst.w	lr, r5
    73a0:	d011      	beq.n	73c6 <mpu_configure_regions+0x56>
				(!mpu_partition_is_valid(regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
    73a2:	2301      	movs	r3, #1
    73a4:	f04f 0200 	mov.w	r2, #0
    73a8:	f363 0207 	bfi	r2, r3, #0, #8
    73ac:	4820      	ldr	r0, [pc, #128]	; (7430 <mpu_configure_regions+0xc0>)
    73ae:	4b21      	ldr	r3, [pc, #132]	; (7434 <mpu_configure_regions+0xc4>)
    73b0:	1a1b      	subs	r3, r3, r0
    73b2:	08db      	lsrs	r3, r3, #3
    73b4:	4820      	ldr	r0, [pc, #128]	; (7438 <mpu_configure_regions+0xc8>)
    73b6:	f363 128f 	bfi	r2, r3, #6, #10
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    73ba:	f019 fe4b 	bl	21054 <log_1>
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, regions[i]);
    73be:	f06f 0215 	mvn.w	r2, #21
		/* Increment number of programmed MPU indices. */
		reg_index++;
	}

	return reg_index;
}
    73c2:	4610      	mov	r0, r2
    73c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * to that power-of-two value.
 */
static inline u32_t size_to_mpu_rasr_size(u32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
    73c6:	2c20      	cmp	r4, #32
		reg_index = mpu_configure_region(reg_index, regions[i]);
    73c8:	b2d5      	uxtb	r5, r2
	region_conf.base = new_region->start;
    73ca:	f8dc 2000 	ldr.w	r2, [ip]
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
    73ce:	f8dc c008 	ldr.w	ip, [ip, #8]
    73d2:	d91a      	bls.n	740a <mpu_configure_regions+0x9a>
	/*
	 * A size value greater than 2^31 could not be handled by
	 * round_up_to_next_power_of_two() properly. We handle
	 * it separately here.
	 */
	if (size > (1UL << 31)) {
    73d4:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
    73d8:	d819      	bhi.n	740e <mpu_configure_regions+0x9e>
		return REGION_4G;
	}

	return ((32 - __builtin_clz(size - 1) - 2 + 1) << MPU_RASR_SIZE_Pos) &
    73da:	3c01      	subs	r4, #1
    73dc:	fab4 f484 	clz	r4, r4
    73e0:	f1c4 041f 	rsb	r4, r4, #31
    73e4:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1)) {
    73e6:	2d07      	cmp	r5, #7
	/* in ARMv7-M MPU the base address is not required
	 * to determine region attributes
	 */
	(void) base;

	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    73e8:	ea4c 0404 	orr.w	r4, ip, r4
    73ec:	d911      	bls.n	7412 <mpu_configure_regions+0xa2>
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    73ee:	2301      	movs	r3, #1
    73f0:	f04f 0200 	mov.w	r2, #0
    73f4:	f363 0207 	bfi	r2, r3, #0, #8
    73f8:	490d      	ldr	r1, [pc, #52]	; (7430 <mpu_configure_regions+0xc0>)
    73fa:	4b0e      	ldr	r3, [pc, #56]	; (7434 <mpu_configure_regions+0xc4>)
    73fc:	480f      	ldr	r0, [pc, #60]	; (743c <mpu_configure_regions+0xcc>)
    73fe:	1a5b      	subs	r3, r3, r1
    7400:	08db      	lsrs	r3, r3, #3
    7402:	f363 128f 	bfi	r2, r3, #6, #10
    7406:	4629      	mov	r1, r5
    7408:	e7d7      	b.n	73ba <mpu_configure_regions+0x4a>
		return REGION_32B;
    740a:	2408      	movs	r4, #8
    740c:	e7eb      	b.n	73e6 <mpu_configure_regions+0x76>
		return REGION_4G;
    740e:	243e      	movs	r4, #62	; 0x3e
    7410:	e7e9      	b.n	73e6 <mpu_configure_regions+0x76>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    7412:	f022 021f 	bic.w	r2, r2, #31
				| MPU_RBAR_VALID_Msk | index;
    7416:	432a      	orrs	r2, r5
    7418:	f042 0210 	orr.w	r2, r2, #16
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    741c:	f044 0401 	orr.w	r4, r4, #1
	MPU->RNR = index;
    7420:	60bd      	str	r5, [r7, #8]
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    7422:	60fa      	str	r2, [r7, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    7424:	613c      	str	r4, [r7, #16]
		reg_index++;
    7426:	1c6a      	adds	r2, r5, #1
	for (i = 0; i < regions_num; i++) {
    7428:	3101      	adds	r1, #1
    742a:	e7a5      	b.n	7378 <mpu_configure_regions+0x8>
    742c:	e000ed90 	.word	0xe000ed90
    7430:	00028540 	.word	0x00028540
    7434:	00028680 	.word	0x00028680
    7438:	00062858 	.word	0x00062858
    743c:	0006287b 	.word	0x0006287b

00007440 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    7440:	4b03      	ldr	r3, [pc, #12]	; (7450 <arm_core_mpu_enable+0x10>)
    7442:	2205      	movs	r2, #5
    7444:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    7446:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    744a:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    744e:	4770      	bx	lr
    7450:	e000ed90 	.word	0xe000ed90

00007454 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    7454:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    7458:	4b01      	ldr	r3, [pc, #4]	; (7460 <arm_core_mpu_disable+0xc>)
    745a:	2200      	movs	r2, #0
    745c:	605a      	str	r2, [r3, #4]
}
    745e:	4770      	bx	lr
    7460:	e000ed90 	.word	0xe000ed90

00007464 <arm_mpu_init>:
 */
static int arm_mpu_init(struct device *arg)
{
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    7464:	4913      	ldr	r1, [pc, #76]	; (74b4 <arm_mpu_init+0x50>)
    7466:	6808      	ldr	r0, [r1, #0]
    7468:	2808      	cmp	r0, #8
{
    746a:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
    746c:	d81e      	bhi.n	74ac <arm_mpu_init+0x48>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    746e:	f7ff fff1 	bl	7454 <arm_core_mpu_disable>
	MPU->RNR = index;
    7472:	4c11      	ldr	r4, [pc, #68]	; (74b8 <arm_mpu_init+0x54>)
    7474:	6849      	ldr	r1, [r1, #4]

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    7476:	2200      	movs	r2, #0
    7478:	4290      	cmp	r0, r2
    747a:	f101 010c 	add.w	r1, r1, #12
    747e:	d105      	bne.n	748c <arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    7480:	4b0e      	ldr	r3, [pc, #56]	; (74bc <arm_mpu_init+0x58>)
    7482:	7018      	strb	r0, [r3, #0]


	arm_core_mpu_enable();
    7484:	f7ff ffdc 	bl	7440 <arm_core_mpu_enable>
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		DT_NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
    7488:	2000      	movs	r0, #0
}
    748a:	bd10      	pop	{r4, pc}
    748c:	60a2      	str	r2, [r4, #8]
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    748e:	f851 3c0c 	ldr.w	r3, [r1, #-12]
    7492:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
    7496:	4313      	orrs	r3, r2
    7498:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    749c:	60e3      	str	r3, [r4, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    749e:	f851 3c04 	ldr.w	r3, [r1, #-4]
    74a2:	f043 0301 	orr.w	r3, r3, #1
    74a6:	6123      	str	r3, [r4, #16]
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    74a8:	3201      	adds	r2, #1
    74aa:	e7e5      	b.n	7478 <arm_mpu_init+0x14>
		return -1;
    74ac:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    74b0:	e7eb      	b.n	748a <arm_mpu_init+0x26>
    74b2:	bf00      	nop
    74b4:	00028d2c 	.word	0x00028d2c
    74b8:	e000ed90 	.word	0xe000ed90
    74bc:	20006579 	.word	0x20006579

000074c0 <arm_core_mpu_configure_static_mpu_regions>:
{
    74c0:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    74c2:	4c03      	ldr	r4, [pc, #12]	; (74d0 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    74c4:	2301      	movs	r3, #1
    74c6:	7822      	ldrb	r2, [r4, #0]
    74c8:	f7ff ff52 	bl	7370 <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    74cc:	7020      	strb	r0, [r4, #0]
}
    74ce:	bd10      	pop	{r4, pc}
    74d0:	20006579 	.word	0x20006579

000074d4 <arm_core_mpu_configure_dynamic_mpu_regions>:
{
    74d4:	b508      	push	{r3, lr}

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
    74d6:	4a08      	ldr	r2, [pc, #32]	; (74f8 <arm_core_mpu_configure_dynamic_mpu_regions+0x24>)
    74d8:	2300      	movs	r3, #0
    74da:	7812      	ldrb	r2, [r2, #0]
    74dc:	f7ff ff48 	bl	7370 <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
    74e0:	f110 0f16 	cmn.w	r0, #22
    74e4:	d003      	beq.n	74ee <arm_core_mpu_configure_dynamic_mpu_regions+0x1a>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
    74e6:	4b05      	ldr	r3, [pc, #20]	; (74fc <arm_core_mpu_configure_dynamic_mpu_regions+0x28>)
  MPU->RASR = 0U;
    74e8:	2200      	movs	r2, #0

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    74ea:	2807      	cmp	r0, #7
    74ec:	dd00      	ble.n	74f0 <arm_core_mpu_configure_dynamic_mpu_regions+0x1c>
}
    74ee:	bd08      	pop	{r3, pc}
  MPU->RNR = rnr;
    74f0:	6098      	str	r0, [r3, #8]
  MPU->RASR = 0U;
    74f2:	611a      	str	r2, [r3, #16]
    74f4:	3001      	adds	r0, #1
    74f6:	e7f8      	b.n	74ea <arm_core_mpu_configure_dynamic_mpu_regions+0x16>
    74f8:	20006579 	.word	0x20006579
    74fc:	e000ed90 	.word	0xe000ed90

00007500 <z_impl_zephyr_read_stdin>:
{
	_stdin_hook = hook;
}

int z_impl_zephyr_read_stdin(char *buf, int nbytes)
{
    7500:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int i = 0;

	for (i = 0; i < nbytes; i++) {
		*(buf + i) = _stdin_hook();
    7502:	4f08      	ldr	r7, [pc, #32]	; (7524 <z_impl_zephyr_read_stdin+0x24>)
{
    7504:	4606      	mov	r6, r0
    7506:	460d      	mov	r5, r1
	for (i = 0; i < nbytes; i++) {
    7508:	2400      	movs	r4, #0
    750a:	42ac      	cmp	r4, r5
    750c:	da08      	bge.n	7520 <z_impl_zephyr_read_stdin+0x20>
		*(buf + i) = _stdin_hook();
    750e:	683b      	ldr	r3, [r7, #0]
    7510:	4798      	blx	r3
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
    7512:	280a      	cmp	r0, #10
		*(buf + i) = _stdin_hook();
    7514:	5530      	strb	r0, [r6, r4]
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
    7516:	f104 0401 	add.w	r4, r4, #1
    751a:	d001      	beq.n	7520 <z_impl_zephyr_read_stdin+0x20>
    751c:	280d      	cmp	r0, #13
    751e:	d1f4      	bne.n	750a <z_impl_zephyr_read_stdin+0xa>
			i++;
			break;
		}
	}
	return i;
}
    7520:	4620      	mov	r0, r4
    7522:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7524:	2000e788 	.word	0x2000e788

00007528 <z_impl_zephyr_write_stdout>:
}
#include <syscalls/z_zephyr_read_stdin_mrsh.c>
#endif

int z_impl_zephyr_write_stdout(const void *buffer, int nbytes)
{
    7528:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    752a:	4f0a      	ldr	r7, [pc, #40]	; (7554 <z_impl_zephyr_write_stdout+0x2c>)
    752c:	460e      	mov	r6, r1
    752e:	1e44      	subs	r4, r0, #1
	const char *buf = buffer;
	int i;

	for (i = 0; i < nbytes; i++) {
    7530:	f1c0 0501 	rsb	r5, r0, #1
    7534:	192b      	adds	r3, r5, r4
    7536:	429e      	cmp	r6, r3
    7538:	dc01      	bgt.n	753e <z_impl_zephyr_write_stdout+0x16>
			_stdout_hook('\r');
		}
		_stdout_hook(*(buf + i));
	}
	return nbytes;
}
    753a:	4630      	mov	r0, r6
    753c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (*(buf + i) == '\n') {
    753e:	7863      	ldrb	r3, [r4, #1]
    7540:	2b0a      	cmp	r3, #10
    7542:	d102      	bne.n	754a <z_impl_zephyr_write_stdout+0x22>
			_stdout_hook('\r');
    7544:	683b      	ldr	r3, [r7, #0]
    7546:	200d      	movs	r0, #13
    7548:	4798      	blx	r3
		_stdout_hook(*(buf + i));
    754a:	683b      	ldr	r3, [r7, #0]
    754c:	f814 0f01 	ldrb.w	r0, [r4, #1]!
    7550:	4798      	blx	r3
    7552:	e7ef      	b.n	7534 <z_impl_zephyr_write_stdout+0xc>
    7554:	2000e78c 	.word	0x2000e78c

00007558 <_exit>:
	return 0;
}
__weak FUNC_ALIAS(_fstat, fstat, int);

__weak void _exit(int status)
{
    7558:	b508      	push	{r3, lr}
	return z_impl_zephyr_write_stdout(buf, nbytes);
    755a:	2105      	movs	r1, #5
    755c:	4801      	ldr	r0, [pc, #4]	; (7564 <_exit+0xc>)
    755e:	f7ff ffe3 	bl	7528 <z_impl_zephyr_write_stdout>
	_write(1, "exit\n", 5);
	while (1) {
		;
    7562:	e7fe      	b.n	7562 <_exit+0xa>
    7564:	000628a1 	.word	0x000628a1

00007568 <_sbrk>:
}

static LIBC_DATA SYS_SEM_DEFINE(heap_sem, 1, 1);

void *_sbrk(int count)
{
    7568:	b538      	push	{r3, r4, r5, lr}
	void *ret, *ptr;

	sys_sem_take(&heap_sem, K_FOREVER);
    756a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
{
    756e:	4605      	mov	r5, r0
	sys_sem_take(&heap_sem, K_FOREVER);
    7570:	480a      	ldr	r0, [pc, #40]	; (759c <_sbrk+0x34>)
    7572:	f018 fc3d 	bl	1fdf0 <sys_sem_take>

#if CONFIG_NEWLIB_LIBC_ALIGNED_HEAP_SIZE
	ptr = heap_base + heap_sz;
#else
	ptr = ((char *)HEAP_BASE) + heap_sz;
    7576:	4a0a      	ldr	r2, [pc, #40]	; (75a0 <_sbrk+0x38>)
#endif

	if ((heap_sz + count) < MAX_HEAP_SIZE) {
    7578:	490a      	ldr	r1, [pc, #40]	; (75a4 <_sbrk+0x3c>)
	ptr = ((char *)HEAP_BASE) + heap_sz;
    757a:	6814      	ldr	r4, [r2, #0]
		ret = ptr;
	} else {
		ret = (void *)-1;
	}

	sys_sem_give(&heap_sem);
    757c:	4807      	ldr	r0, [pc, #28]	; (759c <_sbrk+0x34>)
	if ((heap_sz + count) < MAX_HEAP_SIZE) {
    757e:	f1c1 5300 	rsb	r3, r1, #536870912	; 0x20000000
    7582:	4425      	add	r5, r4
    7584:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
    7588:	429d      	cmp	r5, r3
	ptr = ((char *)HEAP_BASE) + heap_sz;
    758a:	bf36      	itet	cc
    758c:	1864      	addcc	r4, r4, r1
		ret = (void *)-1;
    758e:	f04f 34ff 	movcs.w	r4, #4294967295	; 0xffffffff
		heap_sz += count;
    7592:	6015      	strcc	r5, [r2, #0]
	sys_sem_give(&heap_sem);
    7594:	f018 fc27 	bl	1fde6 <sys_sem_give>

	return ret;
}
    7598:	4620      	mov	r0, r4
    759a:	bd38      	pop	{r3, r4, r5, pc}
    759c:	2000ef8c 	.word	0x2000ef8c
    75a0:	20000280 	.word	0x20000280
    75a4:	2000f128 	.word	0x2000f128

000075a8 <set_lvgl_rendering_cb>:
 */

#include "lvgl_display.h"

int set_lvgl_rendering_cb(lv_disp_drv_t *disp_drv)
{
    75a8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    75aa:	4604      	mov	r4, r0
	int err = 0;
	struct device *display_dev = (struct device *)disp_drv->user_data;
    75ac:	6a00      	ldr	r0, [r0, #32]
					    capabilities)
{
	struct display_driver_api *api =
		(struct display_driver_api *)dev->driver_api;

	api->get_capabilities(dev, capabilities);
    75ae:	6843      	ldr	r3, [r0, #4]
    75b0:	4669      	mov	r1, sp
    75b2:	69db      	ldr	r3, [r3, #28]
    75b4:	4798      	blx	r3
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);

	switch (cap.current_pixel_format) {
    75b6:	f89d 200c 	ldrb.w	r2, [sp, #12]
    75ba:	3a01      	subs	r2, #1
    75bc:	2300      	movs	r3, #0
    75be:	2a0f      	cmp	r2, #15
    75c0:	d820      	bhi.n	7604 <set_lvgl_rendering_cb+0x5c>
    75c2:	e8df f002 	tbb	[pc, r2]
    75c6:	190f      	.short	0x190f
    75c8:	1f1f191f 	.word	0x1f1f191f
    75cc:	1f1f081f 	.word	0x1f1f081f
    75d0:	1f1f1f1f 	.word	0x1f1f1f1f
    75d4:	141f      	.short	0x141f
	case PIXEL_FORMAT_ARGB_8888:
		disp_drv->flush_cb = lvgl_flush_cb_32bit;
    75d6:	4a0e      	ldr	r2, [pc, #56]	; (7610 <set_lvgl_rendering_cb+0x68>)
		disp_drv->rounder_cb = NULL;
    75d8:	e9c4 2303 	strd	r2, r3, [r4, #12]
		break;
	case PIXEL_FORMAT_MONO01:
	case PIXEL_FORMAT_MONO10:
		disp_drv->flush_cb = lvgl_flush_cb_mono;
		disp_drv->rounder_cb = lvgl_rounder_cb_mono;
		disp_drv->set_px_cb = lvgl_set_px_cb_mono;
    75dc:	6163      	str	r3, [r4, #20]
	int err = 0;
    75de:	2000      	movs	r0, #0
		break;

	}

	return err;
}
    75e0:	b004      	add	sp, #16
    75e2:	bd10      	pop	{r4, pc}
		disp_drv->flush_cb = lvgl_flush_cb_24bit;
    75e4:	4a0b      	ldr	r2, [pc, #44]	; (7614 <set_lvgl_rendering_cb+0x6c>)
		disp_drv->rounder_cb = NULL;
    75e6:	e9c4 2303 	strd	r2, r3, [r4, #12]
		disp_drv->set_px_cb = lvgl_set_px_cb_24bit;
    75ea:	4b0b      	ldr	r3, [pc, #44]	; (7618 <set_lvgl_rendering_cb+0x70>)
    75ec:	e7f6      	b.n	75dc <set_lvgl_rendering_cb+0x34>
		disp_drv->flush_cb = lvgl_flush_cb_16bit;
    75ee:	4a0b      	ldr	r2, [pc, #44]	; (761c <set_lvgl_rendering_cb+0x74>)
		disp_drv->rounder_cb = NULL;
    75f0:	e9c4 2303 	strd	r2, r3, [r4, #12]
		disp_drv->set_px_cb = lvgl_set_px_cb_16bit;
    75f4:	4b0a      	ldr	r3, [pc, #40]	; (7620 <set_lvgl_rendering_cb+0x78>)
    75f6:	e7f1      	b.n	75dc <set_lvgl_rendering_cb+0x34>
		disp_drv->flush_cb = lvgl_flush_cb_mono;
    75f8:	4b0a      	ldr	r3, [pc, #40]	; (7624 <set_lvgl_rendering_cb+0x7c>)
    75fa:	60e3      	str	r3, [r4, #12]
		disp_drv->rounder_cb = lvgl_rounder_cb_mono;
    75fc:	4b0a      	ldr	r3, [pc, #40]	; (7628 <set_lvgl_rendering_cb+0x80>)
    75fe:	6123      	str	r3, [r4, #16]
		disp_drv->set_px_cb = lvgl_set_px_cb_mono;
    7600:	4b0a      	ldr	r3, [pc, #40]	; (762c <set_lvgl_rendering_cb+0x84>)
    7602:	e7eb      	b.n	75dc <set_lvgl_rendering_cb+0x34>
		disp_drv->rounder_cb = NULL;
    7604:	e9c4 3303 	strd	r3, r3, [r4, #12]
		disp_drv->set_px_cb = NULL;
    7608:	6163      	str	r3, [r4, #20]
		err = -ENOTSUP;
    760a:	f06f 0085 	mvn.w	r0, #133	; 0x85
	return err;
    760e:	e7e7      	b.n	75e0 <set_lvgl_rendering_cb+0x38>
    7610:	0002218f 	.word	0x0002218f
    7614:	000220c1 	.word	0x000220c1
    7618:	00022113 	.word	0x00022113
    761c:	00022047 	.word	0x00022047
    7620:	00022093 	.word	0x00022093
    7624:	00021eff 	.word	0x00021eff
    7628:	0002200f 	.word	0x0002200f
    762c:	00021f79 	.word	0x00021f79

00007630 <lvgl_log>:
	 * * LOG_LEVEL_ERR 1
	 * * LOG_LEVEL_WRN 2
	 * * LOG_LEVEL_INF 3
	 * * LOG_LEVEL_DBG 4
	 */
	u8_t zephyr_level = LOG_LEVEL_DBG - level;
    7630:	f1c0 0004 	rsb	r0, r0, #4
    7634:	b240      	sxtb	r0, r0
{
    7636:	b410      	push	{r4}
	u8_t zephyr_level = LOG_LEVEL_DBG - level;
    7638:	b2c4      	uxtb	r4, r0

	ARG_UNUSED(file);
	ARG_UNUSED(line);

	Z_LOG(zephyr_level, "%s", dsc);
    763a:	2c03      	cmp	r4, #3
{
    763c:	4619      	mov	r1, r3
	Z_LOG(zephyr_level, "%s", dsc);
    763e:	d818      	bhi.n	7672 <lvgl_log+0x42>
    7640:	f04f 0300 	mov.w	r3, #0
    7644:	f360 0302 	bfi	r3, r0, #0, #3
    7648:	4a0b      	ldr	r2, [pc, #44]	; (7678 <lvgl_log+0x48>)
    764a:	480c      	ldr	r0, [pc, #48]	; (767c <lvgl_log+0x4c>)
    764c:	1a12      	subs	r2, r2, r0
    764e:	f36f 03c5 	bfc	r3, #3, #3
    7652:	08d2      	lsrs	r2, r2, #3
    7654:	2c04      	cmp	r4, #4
    7656:	f362 138f 	bfi	r3, r2, #6, #10
    765a:	d105      	bne.n	7668 <lvgl_log+0x38>
    765c:	460a      	mov	r2, r1
    765e:	4808      	ldr	r0, [pc, #32]	; (7680 <lvgl_log+0x50>)
    7660:	4908      	ldr	r1, [pc, #32]	; (7684 <lvgl_log+0x54>)
}
    7662:	bc10      	pop	{r4}
	Z_LOG(zephyr_level, "%s", dsc);
    7664:	f019 bd0a 	b.w	2107c <log_2>
    7668:	461a      	mov	r2, r3
    766a:	4807      	ldr	r0, [pc, #28]	; (7688 <lvgl_log+0x58>)
}
    766c:	bc10      	pop	{r4}
	Z_LOG(zephyr_level, "%s", dsc);
    766e:	f019 bcf1 	b.w	21054 <log_1>
}
    7672:	bc10      	pop	{r4}
    7674:	4770      	bx	lr
    7676:	bf00      	nop
    7678:	00028678 	.word	0x00028678
    767c:	00028540 	.word	0x00028540
    7680:	00062bc7 	.word	0x00062bc7
    7684:	000628a7 	.word	0x000628a7
    7688:	00062bdc 	.word	0x00062bdc

0000768c <lvgl_init>:
	return 0;
}
#endif /* CONFIG_LVGL_BUFFER_ALLOC_STATIC */

static int lvgl_init(struct device *dev)
{
    768c:	b510      	push	{r4, lr}
    768e:	b08a      	sub	sp, #40	; 0x28
    7690:	482a      	ldr	r0, [pc, #168]	; (773c <lvgl_init+0xb0>)
    7692:	f016 fcc5 	bl	1e020 <z_impl_device_get_binding>

	struct device *display_dev =
		device_get_binding(CONFIG_LVGL_DISPLAY_DEV_NAME);
	lv_disp_drv_t disp_drv;

	if (display_dev == NULL) {
    7696:	4604      	mov	r4, r0
    7698:	b990      	cbnz	r0, 76c0 <lvgl_init+0x34>
		LOG_ERR("Display device not found.");
    769a:	2301      	movs	r3, #1
    769c:	f04f 0100 	mov.w	r1, #0
    76a0:	f363 0107 	bfi	r1, r3, #0, #8
    76a4:	4a26      	ldr	r2, [pc, #152]	; (7740 <lvgl_init+0xb4>)
    76a6:	4b27      	ldr	r3, [pc, #156]	; (7744 <lvgl_init+0xb8>)
    76a8:	4827      	ldr	r0, [pc, #156]	; (7748 <lvgl_init+0xbc>)
    76aa:	1a9b      	subs	r3, r3, r2
    76ac:	08db      	lsrs	r3, r3, #3
    76ae:	f363 118f 	bfi	r1, r3, #6, #10
    76b2:	f019 fcc2 	bl	2103a <log_0>
		return -ENODEV;
    76b6:	f06f 0412 	mvn.w	r4, #18
		LOG_ERR("Failed to register display device.");
		return -EPERM;
	}

	return 0;
}
    76ba:	4620      	mov	r0, r4
    76bc:	b00a      	add	sp, #40	; 0x28
    76be:	bd10      	pop	{r4, pc}
	lv_log_register_print_cb(lvgl_log);
    76c0:	4822      	ldr	r0, [pc, #136]	; (774c <lvgl_init+0xc0>)
    76c2:	f015 fcc3 	bl	1d04c <lv_log_register_print_cb>
	lv_init();
    76c6:	f013 fa9b 	bl	1ac00 <lv_init>
	lv_disp_drv_init(&disp_drv);
    76ca:	a801      	add	r0, sp, #4
    76cc:	f01f fc73 	bl	26fb6 <lv_disp_drv_init>
	disp_drv->buffer = &disp_buf;
    76d0:	481f      	ldr	r0, [pc, #124]	; (7750 <lvgl_init+0xc4>)
	lv_disp_buf_init(disp_drv->buffer, &buf0, NULL, NBR_PIXELS_IN_BUFFER);
    76d2:	4920      	ldr	r1, [pc, #128]	; (7754 <lvgl_init+0xc8>)
	disp_drv.user_data = (void *) display_dev;
    76d4:	9409      	str	r4, [sp, #36]	; 0x24
	lv_disp_buf_init(disp_drv->buffer, &buf0, NULL, NBR_PIXELS_IN_BUFFER);
    76d6:	f44f 53b4 	mov.w	r3, #5760	; 0x1680
    76da:	2200      	movs	r2, #0
	disp_drv->buffer = &disp_buf;
    76dc:	9002      	str	r0, [sp, #8]
	lv_disp_buf_init(disp_drv->buffer, &buf0, NULL, NBR_PIXELS_IN_BUFFER);
    76de:	f01f fc80 	bl	26fe2 <lv_disp_buf_init>
	if (set_lvgl_rendering_cb(&disp_drv) != 0) {
    76e2:	a801      	add	r0, sp, #4
    76e4:	f7ff ff60 	bl	75a8 <set_lvgl_rendering_cb>
    76e8:	4604      	mov	r4, r0
    76ea:	b180      	cbz	r0, 770e <lvgl_init+0x82>
		LOG_ERR("Display not supported.");
    76ec:	2301      	movs	r3, #1
    76ee:	f04f 0100 	mov.w	r1, #0
    76f2:	f363 0107 	bfi	r1, r3, #0, #8
    76f6:	4a12      	ldr	r2, [pc, #72]	; (7740 <lvgl_init+0xb4>)
    76f8:	4b12      	ldr	r3, [pc, #72]	; (7744 <lvgl_init+0xb8>)
    76fa:	4817      	ldr	r0, [pc, #92]	; (7758 <lvgl_init+0xcc>)
    76fc:	1a9b      	subs	r3, r3, r2
    76fe:	08db      	lsrs	r3, r3, #3
    7700:	f363 118f 	bfi	r1, r3, #6, #10
    7704:	f019 fc99 	bl	2103a <log_0>
		return -ENOTSUP;
    7708:	f06f 0485 	mvn.w	r4, #133	; 0x85
    770c:	e7d5      	b.n	76ba <lvgl_init+0x2e>
	if (lv_disp_drv_register(&disp_drv) == NULL) {
    770e:	a801      	add	r0, sp, #4
    7710:	f015 f90e 	bl	1c930 <lv_disp_drv_register>
    7714:	2800      	cmp	r0, #0
    7716:	d1d0      	bne.n	76ba <lvgl_init+0x2e>
		LOG_ERR("Failed to register display device.");
    7718:	2301      	movs	r3, #1
    771a:	f04f 0100 	mov.w	r1, #0
    771e:	f363 0107 	bfi	r1, r3, #0, #8
    7722:	4a07      	ldr	r2, [pc, #28]	; (7740 <lvgl_init+0xb4>)
    7724:	4b07      	ldr	r3, [pc, #28]	; (7744 <lvgl_init+0xb8>)
    7726:	480d      	ldr	r0, [pc, #52]	; (775c <lvgl_init+0xd0>)
    7728:	1a9b      	subs	r3, r3, r2
    772a:	08db      	lsrs	r3, r3, #3
    772c:	f363 118f 	bfi	r1, r3, #6, #10
    7730:	f019 fc83 	bl	2103a <log_0>
		return -EPERM;
    7734:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    7738:	e7bf      	b.n	76ba <lvgl_init+0x2e>
    773a:	bf00      	nop
    773c:	00061e91 	.word	0x00061e91
    7740:	00028540 	.word	0x00028540
    7744:	00028678 	.word	0x00028678
    7748:	000628b0 	.word	0x000628b0
    774c:	00007631 	.word	0x00007631
    7750:	20000284 	.word	0x20000284
    7754:	2000657a 	.word	0x2000657a
    7758:	000628ca 	.word	0x000628ca
    775c:	000628e1 	.word	0x000628e1

00007760 <nordicsemi_nrf52_init>:
    7760:	f04f 0320 	mov.w	r3, #32
    7764:	f3ef 8211 	mrs	r2, BASEPRI
    7768:	f383 8811 	msr	BASEPRI, r3
    776c:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    7770:	4906      	ldr	r1, [pc, #24]	; (778c <nordicsemi_nrf52_init+0x2c>)
    7772:	2301      	movs	r3, #1
    7774:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
#endif

#if NRF_POWER_HAS_DCDCEN
NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable)
{
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
    7778:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    777c:	f8c1 3578 	str.w	r3, [r1, #1400]	; 0x578
	__asm__ volatile(
    7780:	f382 8811 	msr	BASEPRI, r2
    7784:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    7788:	2000      	movs	r0, #0
    778a:	4770      	bx	lr
    778c:	4001e000 	.word	0x4001e000

00007790 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    7790:	b120      	cbz	r0, 779c <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    7792:	4b03      	ldr	r3, [pc, #12]	; (77a0 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
    7794:	0180      	lsls	r0, r0, #6
    7796:	f043 0301 	orr.w	r3, r3, #1
    779a:	4718      	bx	r3

void arch_busy_wait(u32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
    779c:	4770      	bx	lr
    779e:	bf00      	nop
    77a0:	00028880 	.word	0x00028880

000077a4 <bt_hex_real>:
	static const char hex[] = "0123456789abcdef";
	static char str[129];
	const u8_t *b = buf;
	int i;

	len = MIN(len, (sizeof(str) - 1) / 2);
    77a4:	2940      	cmp	r1, #64	; 0x40
    77a6:	4b0e      	ldr	r3, [pc, #56]	; (77e0 <bt_hex_real+0x3c>)
{
    77a8:	b570      	push	{r4, r5, r6, lr}
	len = MIN(len, (sizeof(str) - 1) / 2);
    77aa:	bf28      	it	cs
    77ac:	2140      	movcs	r1, #64	; 0x40

	for (i = 0; i < len; i++) {
		str[i * 2]     = hex[b[i] >> 4];
    77ae:	4c0d      	ldr	r4, [pc, #52]	; (77e4 <bt_hex_real+0x40>)
    77b0:	1846      	adds	r6, r0, r1
    77b2:	461d      	mov	r5, r3
	for (i = 0; i < len; i++) {
    77b4:	42b0      	cmp	r0, r6
    77b6:	f103 0302 	add.w	r3, r3, #2
    77ba:	d104      	bne.n	77c6 <bt_hex_real+0x22>
		str[i * 2 + 1] = hex[b[i] & 0xf];
	}

	str[i * 2] = '\0';
    77bc:	2300      	movs	r3, #0
    77be:	f805 3011 	strb.w	r3, [r5, r1, lsl #1]

	return str;
}
    77c2:	4807      	ldr	r0, [pc, #28]	; (77e0 <bt_hex_real+0x3c>)
    77c4:	bd70      	pop	{r4, r5, r6, pc}
		str[i * 2]     = hex[b[i] >> 4];
    77c6:	7802      	ldrb	r2, [r0, #0]
    77c8:	0912      	lsrs	r2, r2, #4
    77ca:	5ca2      	ldrb	r2, [r4, r2]
    77cc:	f803 2c02 	strb.w	r2, [r3, #-2]
		str[i * 2 + 1] = hex[b[i] & 0xf];
    77d0:	f810 2b01 	ldrb.w	r2, [r0], #1
    77d4:	f002 020f 	and.w	r2, r2, #15
    77d8:	5ca2      	ldrb	r2, [r4, r2]
    77da:	f803 2c01 	strb.w	r2, [r3, #-1]
    77de:	e7e9      	b.n	77b4 <bt_hex_real+0x10>
    77e0:	2000a8fa 	.word	0x2000a8fa
    77e4:	0006291c 	.word	0x0006291c

000077e8 <bt_addr_le_str_real>:

	return str;
}

const char *bt_addr_le_str_real(const bt_addr_le_t *addr)
{
    77e8:	b530      	push	{r4, r5, lr}
	switch (addr->type) {
    77ea:	7803      	ldrb	r3, [r0, #0]
    77ec:	b08b      	sub	sp, #44	; 0x2c
    77ee:	4604      	mov	r4, r0
    77f0:	ad07      	add	r5, sp, #28
    77f2:	2b03      	cmp	r3, #3
    77f4:	d821      	bhi.n	783a <bt_addr_le_str_real+0x52>
    77f6:	e8df f003 	tbb	[pc, r3]
    77fa:	1a02      	.short	0x1a02
    77fc:	1e1c      	.short	0x1e1c
		strcpy(type, "public");
    77fe:	4912      	ldr	r1, [pc, #72]	; (7848 <bt_addr_le_str_real+0x60>)
		strcpy(type, "random");
    7800:	4628      	mov	r0, r5
    7802:	f7fa fa49 	bl	1c98 <strcpy>
	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
    7806:	7863      	ldrb	r3, [r4, #1]
    7808:	9304      	str	r3, [sp, #16]
    780a:	78a3      	ldrb	r3, [r4, #2]
    780c:	9303      	str	r3, [sp, #12]
    780e:	78e3      	ldrb	r3, [r4, #3]
    7810:	9302      	str	r3, [sp, #8]
    7812:	7923      	ldrb	r3, [r4, #4]
    7814:	9301      	str	r3, [sp, #4]
    7816:	7963      	ldrb	r3, [r4, #5]
    7818:	9300      	str	r3, [sp, #0]
    781a:	9505      	str	r5, [sp, #20]
    781c:	79a3      	ldrb	r3, [r4, #6]
    781e:	4a0b      	ldr	r2, [pc, #44]	; (784c <bt_addr_le_str_real+0x64>)
    7820:	480b      	ldr	r0, [pc, #44]	; (7850 <bt_addr_le_str_real+0x68>)
    7822:	211e      	movs	r1, #30
    7824:	f018 fad2 	bl	1fdcc <snprintk>
	static char str[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(addr, str, sizeof(str));

	return str;
}
    7828:	4809      	ldr	r0, [pc, #36]	; (7850 <bt_addr_le_str_real+0x68>)
    782a:	b00b      	add	sp, #44	; 0x2c
    782c:	bd30      	pop	{r4, r5, pc}
		strcpy(type, "random");
    782e:	4909      	ldr	r1, [pc, #36]	; (7854 <bt_addr_le_str_real+0x6c>)
    7830:	e7e6      	b.n	7800 <bt_addr_le_str_real+0x18>
		strcpy(type, "public-id");
    7832:	4909      	ldr	r1, [pc, #36]	; (7858 <bt_addr_le_str_real+0x70>)
    7834:	e7e4      	b.n	7800 <bt_addr_le_str_real+0x18>
		strcpy(type, "random-id");
    7836:	4909      	ldr	r1, [pc, #36]	; (785c <bt_addr_le_str_real+0x74>)
    7838:	e7e2      	b.n	7800 <bt_addr_le_str_real+0x18>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
    783a:	4a09      	ldr	r2, [pc, #36]	; (7860 <bt_addr_le_str_real+0x78>)
    783c:	210a      	movs	r1, #10
    783e:	4628      	mov	r0, r5
    7840:	f018 fac4 	bl	1fdcc <snprintk>
		break;
    7844:	e7df      	b.n	7806 <bt_addr_le_str_real+0x1e>
    7846:	bf00      	nop
    7848:	000298cf 	.word	0x000298cf
    784c:	000298f1 	.word	0x000298f1
    7850:	2000a97b 	.word	0x2000a97b
    7854:	000298d6 	.word	0x000298d6
    7858:	000298dd 	.word	0x000298dd
    785c:	000298e7 	.word	0x000298e7
    7860:	000642f2 	.word	0x000642f2

00007864 <ecc_thread>:

	bt_recv(buf);
}

static void ecc_thread(void *p1, void *p2, void *p3)
{
    7864:	e92d 4888 	stmdb	sp!, {r3, r7, fp, lr}
    7868:	4c69      	ldr	r4, [pc, #420]	; (7a10 <ecc_thread+0x1ac>)
		BT_ERR("public key is not valid (ret %d)", ret);
    786a:	4b6a      	ldr	r3, [pc, #424]	; (7a14 <ecc_thread+0x1b0>)
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    786c:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 7a30 <ecc_thread+0x1cc>
    7870:	1ae4      	subs	r4, r4, r3
    7872:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    7876:	4645      	mov	r5, r8
	return z_impl_k_sem_take(sem, timeout);
    7878:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    787c:	4866      	ldr	r0, [pc, #408]	; (7a18 <ecc_thread+0x1b4>)
    787e:	f017 faa9 	bl	1edd4 <z_impl_k_sem_take>
    7882:	f3bf 8f5b 	dmb	ish
    7886:	f8d8 3000 	ldr.w	r3, [r8]
    788a:	f3bf 8f5b 	dmb	ish
	while (true) {
		k_sem_take(&cmd_sem, K_FOREVER);

		if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
    788e:	f013 0901 	ands.w	r9, r3, #1
    7892:	d061      	beq.n	7958 <ecc_thread+0xf4>
		rc = uECC_make_key(ecc.pk, ecc.private_key, &curve_secp256r1);
    7894:	f8df b190 	ldr.w	fp, [pc, #400]	; 7a28 <ecc_thread+0x1c4>
    7898:	f8df 9198 	ldr.w	r9, [pc, #408]	; 7a34 <ecc_thread+0x1d0>
	} while (memcmp(ecc.private_key, debug_private_key, 32) == 0);
    789c:	f8df a198 	ldr.w	sl, [pc, #408]	; 7a38 <ecc_thread+0x1d4>
		rc = uECC_make_key(ecc.pk, ecc.private_key, &curve_secp256r1);
    78a0:	485e      	ldr	r0, [pc, #376]	; (7a1c <ecc_thread+0x1b8>)
    78a2:	465a      	mov	r2, fp
    78a4:	4649      	mov	r1, r9
    78a6:	f018 fafa 	bl	1fe9e <uECC_make_key>
		if (rc == TC_CRYPTO_FAIL) {
    78aa:	2800      	cmp	r0, #0
    78ac:	d141      	bne.n	7932 <ecc_thread+0xce>
			BT_ERR("Failed to create ECC public/private pair");
    78ae:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
    78b2:	f043 0301 	orr.w	r3, r3, #1
    78b6:	f363 0707 	bfi	r7, r3, #0, #8
    78ba:	f364 178f 	bfi	r7, r4, #6, #10
    78be:	4639      	mov	r1, r7
    78c0:	4857      	ldr	r0, [pc, #348]	; (7a20 <ecc_thread+0x1bc>)
    78c2:	f019 fbba 	bl	2103a <log_0>
			return BT_HCI_ERR_UNSPECIFIED;
    78c6:	f04f 0a1f 	mov.w	sl, #31
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    78ca:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    78ce:	2001      	movs	r0, #1
    78d0:	f002 fdae 	bl	a430 <bt_buf_get_rx>
	hdr = net_buf_add(buf, sizeof(*hdr));
    78d4:	f100 0b08 	add.w	fp, r0, #8
    78d8:	2102      	movs	r1, #2
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    78da:	4681      	mov	r9, r0
	hdr = net_buf_add(buf, sizeof(*hdr));
    78dc:	4658      	mov	r0, fp
    78de:	f01d fa7b 	bl	24dd8 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
    78e2:	233e      	movs	r3, #62	; 0x3e
    78e4:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
    78e6:	2342      	movs	r3, #66	; 0x42
    78e8:	7043      	strb	r3, [r0, #1]
	meta = net_buf_add(buf, sizeof(*meta));
    78ea:	2101      	movs	r1, #1
    78ec:	4658      	mov	r0, fp
    78ee:	f01d fa73 	bl	24dd8 <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_P256_PUBLIC_KEY_COMPLETE;
    78f2:	2308      	movs	r3, #8
    78f4:	7003      	strb	r3, [r0, #0]
	evt = net_buf_add(buf, sizeof(*evt));
    78f6:	2141      	movs	r1, #65	; 0x41
    78f8:	4658      	mov	r0, fp
    78fa:	f01d fa6d 	bl	24dd8 <net_buf_simple_add>
    78fe:	4683      	mov	fp, r0
	evt->status = status;
    7900:	f800 ab01 	strb.w	sl, [r0], #1
	if (status) {
    7904:	f1ba 0f00 	cmp.w	sl, #0
    7908:	d01d      	beq.n	7946 <ecc_thread+0xe2>
__ssp_bos_icheck3(memset, void *, int)
    790a:	2240      	movs	r2, #64	; 0x40
    790c:	2100      	movs	r1, #0
    790e:	f7fa f98e 	bl	1c2e <memset>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    7912:	f3bf 8f5b 	dmb	ish
    7916:	e855 3f00 	ldrex	r3, [r5]
    791a:	f023 0301 	bic.w	r3, r3, #1
    791e:	e845 3200 	strex	r2, r3, [r5]
    7922:	2a00      	cmp	r2, #0
    7924:	d1f7      	bne.n	7916 <ecc_thread+0xb2>
    7926:	f3bf 8f5b 	dmb	ish
	bt_recv(buf);
    792a:	4648      	mov	r0, r9
	bt_recv(buf);
    792c:	f001 fe40 	bl	95b0 <bt_recv>
    7930:	e7a2      	b.n	7878 <ecc_thread+0x14>
	} while (memcmp(ecc.private_key, debug_private_key, 32) == 0);
    7932:	2220      	movs	r2, #32
    7934:	4651      	mov	r1, sl
    7936:	4648      	mov	r0, r9
    7938:	f7fa f94a 	bl	1bd0 <memcmp>
    793c:	2800      	cmp	r0, #0
    793e:	d0af      	beq.n	78a0 <ecc_thread+0x3c>
	return 0;
    7940:	f04f 0a00 	mov.w	sl, #0
    7944:	e7c1      	b.n	78ca <ecc_thread+0x66>
		sys_memcpy_swap(evt->key, ecc.pk, 32);
    7946:	4935      	ldr	r1, [pc, #212]	; (7a1c <ecc_thread+0x1b8>)
    7948:	f01a fcb4 	bl	222b4 <sys_memcpy_swap.constprop.2>
		sys_memcpy_swap(&evt->key[32], &ecc.pk[32], 32);
    794c:	4935      	ldr	r1, [pc, #212]	; (7a24 <ecc_thread+0x1c0>)
    794e:	f10b 0021 	add.w	r0, fp, #33	; 0x21
    7952:	f01a fcaf 	bl	222b4 <sys_memcpy_swap.constprop.2>
    7956:	e7dc      	b.n	7912 <ecc_thread+0xae>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    7958:	f3bf 8f5b 	dmb	ish
    795c:	f8d8 3000 	ldr.w	r3, [r8]
    7960:	f3bf 8f5b 	dmb	ish
			emulate_le_p256_public_key_cmd();
		} else if (atomic_test_bit(flags, PENDING_DHKEY)) {
    7964:	079b      	lsls	r3, r3, #30
    7966:	d587      	bpl.n	7878 <ecc_thread+0x14>
	ret = uECC_valid_public_key(ecc.pk, &curve_secp256r1);
    7968:	492f      	ldr	r1, [pc, #188]	; (7a28 <ecc_thread+0x1c4>)
    796a:	482c      	ldr	r0, [pc, #176]	; (7a1c <ecc_thread+0x1b8>)
    796c:	f019 f963 	bl	20c36 <uECC_valid_public_key>
	if (ret < 0) {
    7970:	1e01      	subs	r1, r0, #0
    7972:	da3e      	bge.n	79f2 <ecc_thread+0x18e>
		BT_ERR("public key is not valid (ret %d)", ret);
    7974:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
    7978:	f043 0301 	orr.w	r3, r3, #1
    797c:	f363 0607 	bfi	r6, r3, #0, #8
    7980:	f364 168f 	bfi	r6, r4, #6, #10
    7984:	4632      	mov	r2, r6
    7986:	4829      	ldr	r0, [pc, #164]	; (7a2c <ecc_thread+0x1c8>)
    7988:	f019 fb64 	bl	21054 <log_1>
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    798c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    7990:	2001      	movs	r0, #1
    7992:	f002 fd4d 	bl	a430 <bt_buf_get_rx>
	hdr = net_buf_add(buf, sizeof(*hdr));
    7996:	f100 0b08 	add.w	fp, r0, #8
    799a:	2102      	movs	r1, #2
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    799c:	4682      	mov	sl, r0
	hdr = net_buf_add(buf, sizeof(*hdr));
    799e:	4658      	mov	r0, fp
    79a0:	f01d fa1a 	bl	24dd8 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
    79a4:	233e      	movs	r3, #62	; 0x3e
    79a6:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
    79a8:	2322      	movs	r3, #34	; 0x22
    79aa:	7043      	strb	r3, [r0, #1]
	meta = net_buf_add(buf, sizeof(*meta));
    79ac:	2101      	movs	r1, #1
    79ae:	4658      	mov	r0, fp
    79b0:	f01d fa12 	bl	24dd8 <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_GENERATE_DHKEY_COMPLETE;
    79b4:	2309      	movs	r3, #9
    79b6:	7003      	strb	r3, [r0, #0]
	evt = net_buf_add(buf, sizeof(*evt));
    79b8:	2121      	movs	r1, #33	; 0x21
    79ba:	4658      	mov	r0, fp
    79bc:	f01d fa0c 	bl	24dd8 <net_buf_simple_add>
    79c0:	4603      	mov	r3, r0
	if (ret == TC_CRYPTO_FAIL) {
    79c2:	3001      	adds	r0, #1
    79c4:	f1b9 0f00 	cmp.w	r9, #0
    79c8:	d11c      	bne.n	7a04 <ecc_thread+0x1a0>
		evt->status = BT_HCI_ERR_UNSPECIFIED;
    79ca:	221f      	movs	r2, #31
    79cc:	701a      	strb	r2, [r3, #0]
    79ce:	4649      	mov	r1, r9
    79d0:	2220      	movs	r2, #32
    79d2:	f7fa f92c 	bl	1c2e <memset>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    79d6:	f3bf 8f5b 	dmb	ish
    79da:	e855 3f00 	ldrex	r3, [r5]
    79de:	f023 0302 	bic.w	r3, r3, #2
    79e2:	e845 3200 	strex	r2, r3, [r5]
    79e6:	2a00      	cmp	r2, #0
    79e8:	d1f7      	bne.n	79da <ecc_thread+0x176>
    79ea:	f3bf 8f5b 	dmb	ish
	bt_recv(buf);
    79ee:	4650      	mov	r0, sl
    79f0:	e79c      	b.n	792c <ecc_thread+0xc8>
		ret = uECC_shared_secret(ecc.pk, ecc.private_key, ecc.dhkey,
    79f2:	4a0a      	ldr	r2, [pc, #40]	; (7a1c <ecc_thread+0x1b8>)
    79f4:	4b0c      	ldr	r3, [pc, #48]	; (7a28 <ecc_thread+0x1c4>)
    79f6:	f1a2 0120 	sub.w	r1, r2, #32
    79fa:	4610      	mov	r0, r2
    79fc:	f018 fa9c 	bl	1ff38 <uECC_shared_secret>
    7a00:	4681      	mov	r9, r0
    7a02:	e7c3      	b.n	798c <ecc_thread+0x128>
		evt->status = 0U;
    7a04:	2200      	movs	r2, #0
    7a06:	701a      	strb	r2, [r3, #0]
		sys_memcpy_swap(evt->dhkey, ecc.dhkey, sizeof(ecc.dhkey));
    7a08:	4904      	ldr	r1, [pc, #16]	; (7a1c <ecc_thread+0x1b8>)
    7a0a:	f01a fc53 	bl	222b4 <sys_memcpy_swap.constprop.2>
    7a0e:	e7e2      	b.n	79d6 <ecc_thread+0x172>
    7a10:	00028618 	.word	0x00028618
    7a14:	00028540 	.word	0x00028540
    7a18:	2000ef44 	.word	0x2000ef44
    7a1c:	2000a9b9 	.word	0x2000a9b9
    7a20:	0006293b 	.word	0x0006293b
    7a24:	2000a9d9 	.word	0x2000a9d9
    7a28:	00028d4c 	.word	0x00028d4c
    7a2c:	00062964 	.word	0x00062964
    7a30:	2000030c 	.word	0x2000030c
    7a34:	2000a999 	.word	0x2000a999
    7a38:	00028dfc 	.word	0x00028dfc

00007a3c <bt_hci_ecc_send>:

	send_cmd_status(BT_HCI_OP_LE_P256_PUBLIC_KEY, status);
}

int bt_hci_ecc_send(struct net_buf *buf)
{
    7a3c:	b570      	push	{r4, r5, r6, lr}
	 * pointer to an enum causes issues on qemu_x86 because the true
	 * size is 8-bit, but the enum is 32-bit on qemu_x86. So we put in
	 * a temporary cast to 8-bit to ensure only 8 bits are read from
	 * the pointer.
	 */
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
    7a3e:	7d05      	ldrb	r5, [r0, #20]
    7a40:	4604      	mov	r4, r0
	if (bt_buf_get_type(buf) == BT_BUF_CMD) {
    7a42:	b9ad      	cbnz	r5, 7a70 <bt_hci_ecc_send+0x34>
		struct bt_hci_cmd_hdr *chdr = (void *)buf->data;
    7a44:	6883      	ldr	r3, [r0, #8]

		switch (sys_le16_to_cpu(chdr->opcode)) {
    7a46:	881a      	ldrh	r2, [r3, #0]
    7a48:	f242 0125 	movw	r1, #8229	; 0x2025
    7a4c:	428a      	cmp	r2, r1
    7a4e:	d017      	beq.n	7a80 <bt_hci_ecc_send+0x44>
    7a50:	f242 0126 	movw	r1, #8230	; 0x2026
    7a54:	428a      	cmp	r2, r1
    7a56:	d03c      	beq.n	7ad2 <bt_hci_ecc_send+0x96>
    7a58:	f242 0101 	movw	r1, #8193	; 0x2001
    7a5c:	428a      	cmp	r2, r1
    7a5e:	d107      	bne.n	7a70 <bt_hci_ecc_send+0x34>
	cmd->events[0] &= ~0x80; /* LE Read Local P-256 PKey Compl */
    7a60:	78da      	ldrb	r2, [r3, #3]
    7a62:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    7a66:	70da      	strb	r2, [r3, #3]
	cmd->events[1] &= ~0x01; /* LE Generate DHKey Compl Event */
    7a68:	791a      	ldrb	r2, [r3, #4]
    7a6a:	f022 0201 	bic.w	r2, r2, #1
    7a6e:	711a      	strb	r2, [r3, #4]
		default:
			break;
		}
	}

	return bt_dev.drv->send(buf);
    7a70:	4b32      	ldr	r3, [pc, #200]	; (7b3c <bt_hci_ecc_send+0x100>)
    7a72:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
    7a76:	4620      	mov	r0, r4
    7a78:	691b      	ldr	r3, [r3, #16]
}
    7a7a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_dev.drv->send(buf);
    7a7e:	4718      	bx	r3
			net_buf_pull(buf, sizeof(*chdr));
    7a80:	2103      	movs	r1, #3
    7a82:	3008      	adds	r0, #8
    7a84:	f01d f9d2 	bl	24e2c <net_buf_simple_pull>
	net_buf_unref(buf);
    7a88:	4620      	mov	r0, r4
    7a8a:	f011 fae7 	bl	1905c <net_buf_unref>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    7a8e:	f3bf 8f5b 	dmb	ish
    7a92:	4b2b      	ldr	r3, [pc, #172]	; (7b40 <bt_hci_ecc_send+0x104>)
    7a94:	681a      	ldr	r2, [r3, #0]
    7a96:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(flags, PENDING_DHKEY)) {
    7a9a:	0790      	lsls	r0, r2, #30
    7a9c:	d507      	bpl.n	7aae <bt_hci_ecc_send+0x72>
		status = BT_HCI_ERR_CMD_DISALLOWED;
    7a9e:	250c      	movs	r5, #12
	send_cmd_status(BT_HCI_OP_LE_P256_PUBLIC_KEY, status);
    7aa0:	4629      	mov	r1, r5
    7aa2:	f242 0025 	movw	r0, #8229	; 0x2025
	send_cmd_status(BT_HCI_OP_LE_GENERATE_DHKEY, status);
    7aa6:	f01a fbe2 	bl	2226e <send_cmd_status>
}
    7aaa:	2000      	movs	r0, #0
    7aac:	bd70      	pop	{r4, r5, r6, pc}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    7aae:	f3bf 8f5b 	dmb	ish
    7ab2:	e853 2f00 	ldrex	r2, [r3]
    7ab6:	f042 0101 	orr.w	r1, r2, #1
    7aba:	e843 1000 	strex	r0, r1, [r3]
    7abe:	2800      	cmp	r0, #0
    7ac0:	d1f7      	bne.n	7ab2 <bt_hci_ecc_send+0x76>
    7ac2:	f3bf 8f5b 	dmb	ish
	} else if (atomic_test_and_set_bit(flags, PENDING_PUB_KEY)) {
    7ac6:	07d1      	lsls	r1, r2, #31
    7ac8:	d4e9      	bmi.n	7a9e <bt_hci_ecc_send+0x62>
	z_impl_k_sem_give(sem);
    7aca:	481e      	ldr	r0, [pc, #120]	; (7b44 <bt_hci_ecc_send+0x108>)
    7acc:	f017 f956 	bl	1ed7c <z_impl_k_sem_give>
    7ad0:	e7e6      	b.n	7aa0 <bt_hci_ecc_send+0x64>
			net_buf_pull(buf, sizeof(*chdr));
    7ad2:	2103      	movs	r1, #3
    7ad4:	3008      	adds	r0, #8
    7ad6:	f01d f9a9 	bl	24e2c <net_buf_simple_pull>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    7ada:	f3bf 8f5b 	dmb	ish
    7ade:	4b18      	ldr	r3, [pc, #96]	; (7b40 <bt_hci_ecc_send+0x104>)
    7ae0:	681a      	ldr	r2, [r3, #0]
    7ae2:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
    7ae6:	07d2      	lsls	r2, r2, #31
    7ae8:	d507      	bpl.n	7afa <bt_hci_ecc_send+0xbe>
		status = BT_HCI_ERR_CMD_DISALLOWED;
    7aea:	250c      	movs	r5, #12
	net_buf_unref(buf);
    7aec:	4620      	mov	r0, r4
    7aee:	f011 fab5 	bl	1905c <net_buf_unref>
	send_cmd_status(BT_HCI_OP_LE_GENERATE_DHKEY, status);
    7af2:	4629      	mov	r1, r5
    7af4:	f242 0026 	movw	r0, #8230	; 0x2026
    7af8:	e7d5      	b.n	7aa6 <bt_hci_ecc_send+0x6a>
	if (buf->len < sizeof(struct bt_hci_cp_le_generate_dhkey)) {
    7afa:	89a2      	ldrh	r2, [r4, #12]
    7afc:	2a3f      	cmp	r2, #63	; 0x3f
    7afe:	d91b      	bls.n	7b38 <bt_hci_ecc_send+0xfc>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    7b00:	f3bf 8f5b 	dmb	ish
    7b04:	e853 2f00 	ldrex	r2, [r3]
    7b08:	f042 0102 	orr.w	r1, r2, #2
    7b0c:	e843 1000 	strex	r0, r1, [r3]
    7b10:	2800      	cmp	r0, #0
    7b12:	d1f7      	bne.n	7b04 <bt_hci_ecc_send+0xc8>
    7b14:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_set_bit(flags, PENDING_DHKEY)) {
    7b18:	0793      	lsls	r3, r2, #30
    7b1a:	d4e6      	bmi.n	7aea <bt_hci_ecc_send+0xae>
	cmd = (void *)buf->data;
    7b1c:	68a6      	ldr	r6, [r4, #8]
	sys_memcpy_swap(ecc.pk, cmd->key, 32);
    7b1e:	480a      	ldr	r0, [pc, #40]	; (7b48 <bt_hci_ecc_send+0x10c>)
    7b20:	4631      	mov	r1, r6
    7b22:	f01a fbc7 	bl	222b4 <sys_memcpy_swap.constprop.2>
	sys_memcpy_swap(&ecc.pk[32], &cmd->key[32], 32);
    7b26:	f106 0120 	add.w	r1, r6, #32
    7b2a:	4808      	ldr	r0, [pc, #32]	; (7b4c <bt_hci_ecc_send+0x110>)
    7b2c:	f01a fbc2 	bl	222b4 <sys_memcpy_swap.constprop.2>
    7b30:	4804      	ldr	r0, [pc, #16]	; (7b44 <bt_hci_ecc_send+0x108>)
    7b32:	f017 f923 	bl	1ed7c <z_impl_k_sem_give>
    7b36:	e7d9      	b.n	7aec <bt_hci_ecc_send+0xb0>
		status = BT_HCI_ERR_INVALID_PARAM;
    7b38:	2512      	movs	r5, #18
    7b3a:	e7d7      	b.n	7aec <bt_hci_ecc_send+0xb0>
    7b3c:	2000e4d8 	.word	0x2000e4d8
    7b40:	2000030c 	.word	0x2000030c
    7b44:	2000ef44 	.word	0x2000ef44
    7b48:	2000a9b9 	.word	0x2000a9b9
    7b4c:	2000a9d9 	.word	0x2000a9d9

00007b50 <bt_hci_ecc_init>:
{
	return !bt_rand(dst, len);
}

void bt_hci_ecc_init(void)
{
    7b50:	b510      	push	{r4, lr}
    7b52:	b086      	sub	sp, #24
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    7b54:	4c0b      	ldr	r4, [pc, #44]	; (7b84 <bt_hci_ecc_init+0x34>)
    7b56:	490c      	ldr	r1, [pc, #48]	; (7b88 <bt_hci_ecc_init+0x38>)
    7b58:	2300      	movs	r3, #0
    7b5a:	220a      	movs	r2, #10
    7b5c:	e9cd 3202 	strd	r3, r2, [sp, #8]
    7b60:	e9cd 3304 	strd	r3, r3, [sp, #16]
    7b64:	e9cd 3300 	strd	r3, r3, [sp]
    7b68:	f240 424c 	movw	r2, #1100	; 0x44c
    7b6c:	4b07      	ldr	r3, [pc, #28]	; (7b8c <bt_hci_ecc_init+0x3c>)
    7b6e:	4620      	mov	r0, r4
    7b70:	f017 f9a8 	bl	1eec4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    7b74:	4906      	ldr	r1, [pc, #24]	; (7b90 <bt_hci_ecc_init+0x40>)
    7b76:	4620      	mov	r0, r4
	k_thread_create(&ecc_thread_data, ecc_thread_stack,
			K_THREAD_STACK_SIZEOF(ecc_thread_stack), ecc_thread,
			NULL, NULL, NULL, K_PRIO_PREEMPT(10), 0, K_NO_WAIT);
	k_thread_name_set(&ecc_thread_data, "BT ECC");
}
    7b78:	b006      	add	sp, #24
    7b7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    7b7e:	f020 b94f 	b.w	27e20 <z_impl_k_thread_name_set>
    7b82:	bf00      	nop
    7b84:	200002a0 	.word	0x200002a0
    7b88:	2000b058 	.word	0x2000b058
    7b8c:	00007865 	.word	0x00007865
    7b90:	00062934 	.word	0x00062934

00007b94 <save_id>:
}

#define ID_DATA_LEN(array) (bt_dev.id_count * sizeof(array[0]))

static void save_id(struct k_work *work)
{
    7b94:	b538      	push	{r3, r4, r5, lr}
	int err;
	BT_INFO("Saving ID");
    7b96:	f04f 0100 	mov.w	r1, #0
    7b9a:	2303      	movs	r3, #3
    7b9c:	f363 0107 	bfi	r1, r3, #0, #8
    7ba0:	4c19      	ldr	r4, [pc, #100]	; (7c08 <save_id+0x74>)
    7ba2:	4b1a      	ldr	r3, [pc, #104]	; (7c0c <save_id+0x78>)
	err = settings_save_one("bt/id", &bt_dev.id_addr,
				ID_DATA_LEN(bt_dev.id_addr));
    7ba4:	4d1a      	ldr	r5, [pc, #104]	; (7c10 <save_id+0x7c>)
	BT_INFO("Saving ID");
    7ba6:	481b      	ldr	r0, [pc, #108]	; (7c14 <save_id+0x80>)
    7ba8:	1ae4      	subs	r4, r4, r3
    7baa:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    7bae:	f364 118f 	bfi	r1, r4, #6, #10
    7bb2:	f019 fa42 	bl	2103a <log_0>
	err = settings_save_one("bt/id", &bt_dev.id_addr,
    7bb6:	79ea      	ldrb	r2, [r5, #7]
    7bb8:	4817      	ldr	r0, [pc, #92]	; (7c18 <save_id+0x84>)
    7bba:	4629      	mov	r1, r5
    7bbc:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
    7bc0:	f7fe fa3a 	bl	6038 <settings_save_one>
	if (err) {
    7bc4:	4601      	mov	r1, r0
    7bc6:	b148      	cbz	r0, 7bdc <save_id+0x48>
		BT_ERR("Failed to save ID (err %d)", err);
    7bc8:	f04f 0200 	mov.w	r2, #0
    7bcc:	2301      	movs	r3, #1
    7bce:	f363 0207 	bfi	r2, r3, #0, #8
    7bd2:	f364 128f 	bfi	r2, r4, #6, #10
    7bd6:	4811      	ldr	r0, [pc, #68]	; (7c1c <save_id+0x88>)
    7bd8:	f019 fa3c 	bl	21054 <log_1>
	}

#if defined(CONFIG_BT_PRIVACY)
	err = settings_save_one("bt/irk", bt_dev.irk, ID_DATA_LEN(bt_dev.irk));
    7bdc:	79ea      	ldrb	r2, [r5, #7]
    7bde:	4910      	ldr	r1, [pc, #64]	; (7c20 <save_id+0x8c>)
    7be0:	4810      	ldr	r0, [pc, #64]	; (7c24 <save_id+0x90>)
    7be2:	0112      	lsls	r2, r2, #4
    7be4:	f7fe fa28 	bl	6038 <settings_save_one>
	if (err) {
    7be8:	4601      	mov	r1, r0
    7bea:	b158      	cbz	r0, 7c04 <save_id+0x70>
		BT_ERR("Failed to save IRK (err %d)", err);
    7bec:	2301      	movs	r3, #1
    7bee:	f04f 0200 	mov.w	r2, #0
    7bf2:	f363 0207 	bfi	r2, r3, #0, #8
    7bf6:	f364 128f 	bfi	r2, r4, #6, #10
    7bfa:	480b      	ldr	r0, [pc, #44]	; (7c28 <save_id+0x94>)
	}
#endif
}
    7bfc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		BT_ERR("Failed to save IRK (err %d)", err);
    7c00:	f019 ba28 	b.w	21054 <log_1>
}
    7c04:	bd38      	pop	{r3, r4, r5, pc}
    7c06:	bf00      	nop
    7c08:	00028638 	.word	0x00028638
    7c0c:	00028540 	.word	0x00028540
    7c10:	2000e4d8 	.word	0x2000e4d8
    7c14:	00062a2e 	.word	0x00062a2e
    7c18:	00062a38 	.word	0x00062a38
    7c1c:	00062a3e 	.word	0x00062a3e
    7c20:	2000e5b4 	.word	0x2000e5b4
    7c24:	00062a59 	.word	0x00062a59
    7c28:	00062a60 	.word	0x00062a60

00007c2c <set>:
{
    7c2c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    7c30:	4616      	mov	r6, r2
    7c32:	461f      	mov	r7, r3
	if (!name) {
    7c34:	4605      	mov	r5, r0
    7c36:	b980      	cbnz	r0, 7c5a <set+0x2e>
		BT_ERR("Insufficient number of arguments");
    7c38:	2301      	movs	r3, #1
    7c3a:	f04f 0100 	mov.w	r1, #0
    7c3e:	f363 0107 	bfi	r1, r3, #0, #8
    7c42:	4a4d      	ldr	r2, [pc, #308]	; (7d78 <set+0x14c>)
    7c44:	4b4d      	ldr	r3, [pc, #308]	; (7d7c <set+0x150>)
    7c46:	484e      	ldr	r0, [pc, #312]	; (7d80 <set+0x154>)
    7c48:	1a9b      	subs	r3, r3, r2
    7c4a:	08db      	lsrs	r3, r3, #3
    7c4c:	f363 118f 	bfi	r1, r3, #6, #10
    7c50:	f019 f9f3 	bl	2103a <log_0>
	return -ENOENT;
    7c54:	f06f 0401 	mvn.w	r4, #1
    7c58:	e025      	b.n	7ca6 <set+0x7a>
	len = settings_name_next(name, &next);
    7c5a:	a901      	add	r1, sp, #4
    7c5c:	f019 fe7b 	bl	21956 <settings_name_next>
	if (!strncmp(name, "id", len)) {
    7c60:	4948      	ldr	r1, [pc, #288]	; (7d84 <set+0x158>)
    7c62:	4602      	mov	r2, r0
	len = settings_name_next(name, &next);
    7c64:	4680      	mov	r8, r0
	if (!strncmp(name, "id", len)) {
    7c66:	4628      	mov	r0, r5
    7c68:	f7fa f826 	bl	1cb8 <strncmp>
    7c6c:	4681      	mov	r9, r0
    7c6e:	2800      	cmp	r0, #0
    7c70:	d13e      	bne.n	7cf0 <set+0xc4>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    7c72:	f3bf 8f5b 	dmb	ish
    7c76:	f8df 8134 	ldr.w	r8, [pc, #308]	; 7dac <set+0x180>
    7c7a:	f8d8 4000 	ldr.w	r4, [r8]
    7c7e:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    7c82:	f3c4 0480 	ubfx	r4, r4, #2, #1
		if (atomic_test_bit(bt_dev.flags, BT_DEV_PRESET_ID)) {
    7c86:	b194      	cbz	r4, 7cae <set+0x82>
			BT_WARN("Ignoring identities stored in flash");
    7c88:	2302      	movs	r3, #2
    7c8a:	f04f 0100 	mov.w	r1, #0
    7c8e:	f363 0107 	bfi	r1, r3, #0, #8
    7c92:	4a39      	ldr	r2, [pc, #228]	; (7d78 <set+0x14c>)
    7c94:	4b39      	ldr	r3, [pc, #228]	; (7d7c <set+0x150>)
    7c96:	483c      	ldr	r0, [pc, #240]	; (7d88 <set+0x15c>)
    7c98:	1a9b      	subs	r3, r3, r2
    7c9a:	08db      	lsrs	r3, r3, #3
    7c9c:	f363 118f 	bfi	r1, r3, #6, #10
    7ca0:	f019 f9cb 	bl	2103a <log_0>
			return 0;
    7ca4:	464c      	mov	r4, r9
}
    7ca6:	4620      	mov	r0, r4
    7ca8:	b003      	add	sp, #12
    7caa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		len = read_cb(cb_arg, &bt_dev.id_addr, sizeof(bt_dev.id_addr));
    7cae:	f1a8 0570 	sub.w	r5, r8, #112	; 0x70
    7cb2:	2207      	movs	r2, #7
    7cb4:	4629      	mov	r1, r5
    7cb6:	4638      	mov	r0, r7
    7cb8:	47b0      	blx	r6
		if (len < sizeof(bt_dev.id_addr[0])) {
    7cba:	2806      	cmp	r0, #6
    7cbc:	d813      	bhi.n	7ce6 <set+0xba>
				BT_ERR("Invalid length ID address in storage");
    7cbe:	2301      	movs	r3, #1
    7cc0:	f04f 0100 	mov.w	r1, #0
    7cc4:	f363 0107 	bfi	r1, r3, #0, #8
    7cc8:	4a2b      	ldr	r2, [pc, #172]	; (7d78 <set+0x14c>)
    7cca:	4b2c      	ldr	r3, [pc, #176]	; (7d7c <set+0x150>)
    7ccc:	482f      	ldr	r0, [pc, #188]	; (7d8c <set+0x160>)
    7cce:	1a9b      	subs	r3, r3, r2
    7cd0:	08db      	lsrs	r3, r3, #3
    7cd2:	f363 118f 	bfi	r1, r3, #6, #10
    7cd6:	f019 f9b0 	bl	2103a <log_0>
			(void)memset(bt_dev.id_addr, 0,
    7cda:	f848 4c70 	str.w	r4, [r8, #-112]
			bt_dev.id_count = 0U;
    7cde:	71ec      	strb	r4, [r5, #7]
			(void)memset(bt_dev.id_addr, 0,
    7ce0:	f8c5 4003 	str.w	r4, [r5, #3]
			bt_dev.id_count = 0U;
    7ce4:	e7df      	b.n	7ca6 <set+0x7a>
			bt_dev.id_count = len / sizeof(bt_dev.id_addr[0]);
    7ce6:	2307      	movs	r3, #7
    7ce8:	fbb0 f0f3 	udiv	r0, r0, r3
    7cec:	71e8      	strb	r0, [r5, #7]
			for (i = 0; i < bt_dev.id_count; i++) {
    7cee:	e7da      	b.n	7ca6 <set+0x7a>
	if (!strncmp(name, "name", len)) {
    7cf0:	4642      	mov	r2, r8
    7cf2:	4927      	ldr	r1, [pc, #156]	; (7d90 <set+0x164>)
    7cf4:	4628      	mov	r0, r5
    7cf6:	f7f9 ffdf 	bl	1cb8 <strncmp>
    7cfa:	4604      	mov	r4, r0
    7cfc:	b9c8      	cbnz	r0, 7d32 <set+0x106>
		len = read_cb(cb_arg, &bt_dev.name, sizeof(bt_dev.name) - 1);
    7cfe:	4925      	ldr	r1, [pc, #148]	; (7d94 <set+0x168>)
    7d00:	2241      	movs	r2, #65	; 0x41
    7d02:	4638      	mov	r0, r7
    7d04:	47b0      	blx	r6
		if (len < 0) {
    7d06:	1e01      	subs	r1, r0, #0
    7d08:	da0e      	bge.n	7d28 <set+0xfc>
			BT_ERR("Failed to read device name from storage"
    7d0a:	2301      	movs	r3, #1
    7d0c:	f04f 0200 	mov.w	r2, #0
    7d10:	f363 0207 	bfi	r2, r3, #0, #8
    7d14:	4818      	ldr	r0, [pc, #96]	; (7d78 <set+0x14c>)
    7d16:	4b19      	ldr	r3, [pc, #100]	; (7d7c <set+0x150>)
    7d18:	1a1b      	subs	r3, r3, r0
    7d1a:	08db      	lsrs	r3, r3, #3
    7d1c:	f363 128f 	bfi	r2, r3, #6, #10
    7d20:	481d      	ldr	r0, [pc, #116]	; (7d98 <set+0x16c>)
    7d22:	f019 f997 	bl	21054 <log_1>
    7d26:	e7be      	b.n	7ca6 <set+0x7a>
			bt_dev.name[len] = '\0';
    7d28:	4b1c      	ldr	r3, [pc, #112]	; (7d9c <set+0x170>)
    7d2a:	440b      	add	r3, r1
    7d2c:	f883 410c 	strb.w	r4, [r3, #268]	; 0x10c
			BT_DBG("Name set to %s", log_strdup(bt_dev.name));
    7d30:	e7b9      	b.n	7ca6 <set+0x7a>
	if (!strncmp(name, "irk", len)) {
    7d32:	4642      	mov	r2, r8
    7d34:	491a      	ldr	r1, [pc, #104]	; (7da0 <set+0x174>)
    7d36:	4628      	mov	r0, r5
    7d38:	f7f9 ffbe 	bl	1cb8 <strncmp>
    7d3c:	4604      	mov	r4, r0
    7d3e:	2800      	cmp	r0, #0
    7d40:	d188      	bne.n	7c54 <set+0x28>
		len = read_cb(cb_arg, bt_dev.irk, sizeof(bt_dev.irk));
    7d42:	2210      	movs	r2, #16
    7d44:	4917      	ldr	r1, [pc, #92]	; (7da4 <set+0x178>)
    7d46:	4638      	mov	r0, r7
    7d48:	47b0      	blx	r6
		if (len < sizeof(bt_dev.irk[0])) {
    7d4a:	280f      	cmp	r0, #15
    7d4c:	d8ab      	bhi.n	7ca6 <set+0x7a>
				BT_ERR("Invalid length IRK in storage");
    7d4e:	2301      	movs	r3, #1
    7d50:	f04f 0100 	mov.w	r1, #0
    7d54:	4a08      	ldr	r2, [pc, #32]	; (7d78 <set+0x14c>)
    7d56:	4814      	ldr	r0, [pc, #80]	; (7da8 <set+0x17c>)
    7d58:	f363 0107 	bfi	r1, r3, #0, #8
    7d5c:	4b07      	ldr	r3, [pc, #28]	; (7d7c <set+0x150>)
    7d5e:	1a9b      	subs	r3, r3, r2
    7d60:	08db      	lsrs	r3, r3, #3
    7d62:	f363 118f 	bfi	r1, r3, #6, #10
    7d66:	f019 f968 	bl	2103a <log_0>
				(void)memset(bt_dev.irk, 0, sizeof(bt_dev.irk));
    7d6a:	2210      	movs	r2, #16
    7d6c:	4621      	mov	r1, r4
    7d6e:	480d      	ldr	r0, [pc, #52]	; (7da4 <set+0x178>)
    7d70:	f7f9 ff5d 	bl	1c2e <memset>
    7d74:	e797      	b.n	7ca6 <set+0x7a>
    7d76:	bf00      	nop
    7d78:	00028540 	.word	0x00028540
    7d7c:	00028638 	.word	0x00028638
    7d80:	00062a7c 	.word	0x00062a7c
    7d84:	000298e4 	.word	0x000298e4
    7d88:	00062a9d 	.word	0x00062a9d
    7d8c:	00062ac1 	.word	0x00062ac1
    7d90:	00063032 	.word	0x00063032
    7d94:	2000e5e4 	.word	0x2000e5e4
    7d98:	00062ae6 	.word	0x00062ae6
    7d9c:	2000e4d8 	.word	0x2000e4d8
    7da0:	00062a5c 	.word	0x00062a5c
    7da4:	2000e5b4 	.word	0x2000e5b4
    7da8:	00062b18 	.word	0x00062b18
    7dac:	2000e548 	.word	0x2000e548

00007db0 <bt_settings_encode_key>:
{
    7db0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7db4:	b088      	sub	sp, #32
    7db6:	799c      	ldrb	r4, [r3, #6]
    7db8:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
    7dbc:	795d      	ldrb	r5, [r3, #5]
    7dbe:	791e      	ldrb	r6, [r3, #4]
    7dc0:	78df      	ldrb	r7, [r3, #3]
    7dc2:	f893 c002 	ldrb.w	ip, [r3, #2]
    7dc6:	f893 e001 	ldrb.w	lr, [r3, #1]
    7dca:	781b      	ldrb	r3, [r3, #0]
	if (key) {
    7dcc:	f1b8 0f00 	cmp.w	r8, #0
    7dd0:	d00e      	beq.n	7df0 <bt_settings_encode_key+0x40>
		snprintk(path, path_size,
    7dd2:	e9cd 3806 	strd	r3, r8, [sp, #24]
    7dd6:	e9cd ce04 	strd	ip, lr, [sp, #16]
    7dda:	4613      	mov	r3, r2
    7ddc:	e9cd 6702 	strd	r6, r7, [sp, #8]
    7de0:	e9cd 4500 	strd	r4, r5, [sp]
    7de4:	4a08      	ldr	r2, [pc, #32]	; (7e08 <bt_settings_encode_key+0x58>)
    7de6:	f017 fff1 	bl	1fdcc <snprintk>
}
    7dea:	b008      	add	sp, #32
    7dec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		snprintk(path, path_size,
    7df0:	e9cd e305 	strd	lr, r3, [sp, #20]
    7df4:	e9cd 7c03 	strd	r7, ip, [sp, #12]
    7df8:	4613      	mov	r3, r2
    7dfa:	e9cd 5601 	strd	r5, r6, [sp, #4]
    7dfe:	9400      	str	r4, [sp, #0]
    7e00:	4a02      	ldr	r2, [pc, #8]	; (7e0c <bt_settings_encode_key+0x5c>)
    7e02:	f017 ffe3 	bl	1fdcc <snprintk>
}
    7e06:	e7f0      	b.n	7dea <bt_settings_encode_key+0x3a>
    7e08:	00062990 	.word	0x00062990
    7e0c:	000629b4 	.word	0x000629b4

00007e10 <bt_settings_save_id>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    7e10:	4909      	ldr	r1, [pc, #36]	; (7e38 <bt_settings_save_id+0x28>)
    7e12:	f3bf 8f5b 	dmb	ish
    7e16:	e851 3f00 	ldrex	r3, [r1]
    7e1a:	f043 0201 	orr.w	r2, r3, #1
    7e1e:	e841 2000 	strex	r0, r2, [r1]
    7e22:	2800      	cmp	r0, #0
    7e24:	d1f7      	bne.n	7e16 <bt_settings_save_id+0x6>
    7e26:	f3bf 8f5b 	dmb	ish
 * @req K-WORK-001
 */
static inline void k_work_submit_to_queue(struct k_work_q *work_q,
					  struct k_work *work)
{
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    7e2a:	07db      	lsls	r3, r3, #31
    7e2c:	d403      	bmi.n	7e36 <bt_settings_save_id+0x26>
		k_queue_append(&work_q->queue, work);
    7e2e:	3908      	subs	r1, #8
    7e30:	4802      	ldr	r0, [pc, #8]	; (7e3c <bt_settings_save_id+0x2c>)
    7e32:	f01f be68 	b.w	27b06 <k_queue_append>
K_WORK_DEFINE(save_id_work, save_id);

void bt_settings_save_id(void)
{
	k_work_submit(&save_id_work);
}
    7e36:	4770      	bx	lr
    7e38:	2000e798 	.word	0x2000e798
    7e3c:	20006090 	.word	0x20006090

00007e40 <commit>:

static int commit(void)
{
    7e40:	b538      	push	{r3, r4, r5, lr}
	BT_DBG("");

#if defined(CONFIG_BT_DEVICE_NAME_DYNAMIC)
	if (bt_dev.name[0] == '\0') {
    7e42:	4c1f      	ldr	r4, [pc, #124]	; (7ec0 <commit+0x80>)
    7e44:	f894 310c 	ldrb.w	r3, [r4, #268]	; 0x10c
    7e48:	b913      	cbnz	r3, 7e50 <commit+0x10>
		bt_set_name(CONFIG_BT_DEVICE_NAME);
    7e4a:	481e      	ldr	r0, [pc, #120]	; (7ec4 <commit+0x84>)
    7e4c:	f001 fde0 	bl	9a10 <bt_set_name>
	}
#endif
	if (!bt_dev.id_count) {
    7e50:	79e3      	ldrb	r3, [r4, #7]
    7e52:	b9bb      	cbnz	r3, 7e84 <commit+0x44>
		bt_setup_public_id_addr();
    7e54:	f001 fe7a 	bl	9b4c <bt_setup_public_id_addr>
	}

	if (!bt_dev.id_count) {
    7e58:	79e3      	ldrb	r3, [r4, #7]
    7e5a:	b99b      	cbnz	r3, 7e84 <commit+0x44>
		int err;

		err = bt_setup_random_id_addr();
    7e5c:	f001 ff08 	bl	9c70 <bt_setup_random_id_addr>
		if (err) {
    7e60:	4604      	mov	r4, r0
    7e62:	b178      	cbz	r0, 7e84 <commit+0x44>
			BT_ERR("Unable to setup an identity address");
    7e64:	2301      	movs	r3, #1
    7e66:	f04f 0100 	mov.w	r1, #0
    7e6a:	f363 0107 	bfi	r1, r3, #0, #8
    7e6e:	4a16      	ldr	r2, [pc, #88]	; (7ec8 <commit+0x88>)
    7e70:	4b16      	ldr	r3, [pc, #88]	; (7ecc <commit+0x8c>)
    7e72:	4817      	ldr	r0, [pc, #92]	; (7ed0 <commit+0x90>)
    7e74:	1a9b      	subs	r3, r3, r2
    7e76:	08db      	lsrs	r3, r3, #3
    7e78:	f363 118f 	bfi	r1, r3, #6, #10
    7e7c:	f019 f8dd 	bl	2103a <log_0>
		BT_DBG("Storing Identity Information");
		bt_settings_save_id();
	}

	return 0;
}
    7e80:	4620      	mov	r0, r4
    7e82:	bd38      	pop	{r3, r4, r5, pc}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    7e84:	4d13      	ldr	r5, [pc, #76]	; (7ed4 <commit+0x94>)
    7e86:	f3bf 8f5b 	dmb	ish
    7e8a:	682b      	ldr	r3, [r5, #0]
    7e8c:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    7e90:	079b      	lsls	r3, r3, #30
    7e92:	d401      	bmi.n	7e98 <commit+0x58>
		bt_finalize_init();
    7e94:	f001 fcac 	bl	97f0 <bt_finalize_init>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    7e98:	f3bf 8f5b 	dmb	ish
    7e9c:	e855 4f00 	ldrex	r4, [r5]
    7ea0:	f424 3300 	bic.w	r3, r4, #131072	; 0x20000
    7ea4:	e845 3200 	strex	r2, r3, [r5]
    7ea8:	2a00      	cmp	r2, #0
    7eaa:	d1f7      	bne.n	7e9c <commit+0x5c>
    7eac:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_STORE_ID)) {
    7eb0:	f414 3400 	ands.w	r4, r4, #131072	; 0x20000
    7eb4:	d0e4      	beq.n	7e80 <commit+0x40>
		bt_settings_save_id();
    7eb6:	f7ff ffab 	bl	7e10 <bt_settings_save_id>
	return 0;
    7eba:	2400      	movs	r4, #0
    7ebc:	e7e0      	b.n	7e80 <commit+0x40>
    7ebe:	bf00      	nop
    7ec0:	2000e4d8 	.word	0x2000e4d8
    7ec4:	000629fa 	.word	0x000629fa
    7ec8:	00028540 	.word	0x00028540
    7ecc:	00028638 	.word	0x00028638
    7ed0:	00062a0a 	.word	0x00062a0a
    7ed4:	2000e548 	.word	0x2000e548

00007ed8 <bt_settings_init>:

SETTINGS_STATIC_HANDLER_DEFINE(bt, "bt", NULL, set, commit, NULL);

int bt_settings_init(void)
{
    7ed8:	b510      	push	{r4, lr}
	int err;

	BT_DBG("");

	err = settings_subsys_init();
    7eda:	f7fe f9b5 	bl	6248 <settings_subsys_init>
	if (err) {
    7ede:	4604      	mov	r4, r0
    7ee0:	b170      	cbz	r0, 7f00 <bt_settings_init+0x28>
		BT_ERR("settings_subsys_init failed (err %d)", err);
    7ee2:	2301      	movs	r3, #1
    7ee4:	f04f 0200 	mov.w	r2, #0
    7ee8:	f363 0207 	bfi	r2, r3, #0, #8
    7eec:	4905      	ldr	r1, [pc, #20]	; (7f04 <bt_settings_init+0x2c>)
    7eee:	4b06      	ldr	r3, [pc, #24]	; (7f08 <bt_settings_init+0x30>)
    7ef0:	1a5b      	subs	r3, r3, r1
    7ef2:	08db      	lsrs	r3, r3, #3
    7ef4:	4601      	mov	r1, r0
    7ef6:	f363 128f 	bfi	r2, r3, #6, #10
    7efa:	4804      	ldr	r0, [pc, #16]	; (7f0c <bt_settings_init+0x34>)
    7efc:	f019 f8aa 	bl	21054 <log_1>
		return err;
	}

	return 0;
}
    7f00:	4620      	mov	r0, r4
    7f02:	bd10      	pop	{r4, pc}
    7f04:	00028540 	.word	0x00028540
    7f08:	00028638 	.word	0x00028638
    7f0c:	000629d5 	.word	0x000629d5

00007f10 <uuid_to_uuid128>:
	.val = { BT_UUID_128_ENCODE(
		0x00000000, 0x0000, 0x1000, 0x8000, 0x00805F9B34FB) }
};

static void uuid_to_uuid128(const struct bt_uuid *src, struct bt_uuid_128 *dst)
{
    7f10:	b5f0      	push	{r4, r5, r6, r7, lr}
    7f12:	460b      	mov	r3, r1
	switch (src->type) {
    7f14:	7801      	ldrb	r1, [r0, #0]
    7f16:	2901      	cmp	r1, #1
{
    7f18:	4602      	mov	r2, r0
	switch (src->type) {
    7f1a:	d016      	beq.n	7f4a <uuid_to_uuid128+0x3a>
    7f1c:	b111      	cbz	r1, 7f24 <uuid_to_uuid128+0x14>
    7f1e:	2902      	cmp	r1, #2
    7f20:	d02b      	beq.n	7f7a <uuid_to_uuid128+0x6a>
		return;
	case BT_UUID_TYPE_128:
		memcpy(dst, src, sizeof(*dst));
		return;
	}
}
    7f22:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*dst = uuid128_base;
    7f24:	4c1b      	ldr	r4, [pc, #108]	; (7f94 <uuid_to_uuid128+0x84>)
    7f26:	461d      	mov	r5, r3
    7f28:	f104 0710 	add.w	r7, r4, #16
    7f2c:	6820      	ldr	r0, [r4, #0]
    7f2e:	6861      	ldr	r1, [r4, #4]
    7f30:	462e      	mov	r6, r5
    7f32:	c603      	stmia	r6!, {r0, r1}
    7f34:	3408      	adds	r4, #8
    7f36:	42bc      	cmp	r4, r7
    7f38:	4635      	mov	r5, r6
    7f3a:	d1f7      	bne.n	7f2c <uuid_to_uuid128+0x1c>
		sys_put_le16(BT_UUID_16(src)->val,
    7f3c:	8852      	ldrh	r2, [r2, #2]
		*dst = uuid128_base;
    7f3e:	7821      	ldrb	r1, [r4, #0]
    7f40:	7031      	strb	r1, [r6, #0]
	dst[0] = val;
    7f42:	735a      	strb	r2, [r3, #13]
	dst[1] = val >> 8;
    7f44:	0a12      	lsrs	r2, r2, #8
    7f46:	739a      	strb	r2, [r3, #14]
    7f48:	e7eb      	b.n	7f22 <uuid_to_uuid128+0x12>
		*dst = uuid128_base;
    7f4a:	4c12      	ldr	r4, [pc, #72]	; (7f94 <uuid_to_uuid128+0x84>)
    7f4c:	461d      	mov	r5, r3
    7f4e:	f104 0710 	add.w	r7, r4, #16
    7f52:	6820      	ldr	r0, [r4, #0]
    7f54:	6861      	ldr	r1, [r4, #4]
    7f56:	462e      	mov	r6, r5
    7f58:	c603      	stmia	r6!, {r0, r1}
    7f5a:	3408      	adds	r4, #8
    7f5c:	42bc      	cmp	r4, r7
    7f5e:	4635      	mov	r5, r6
    7f60:	d1f7      	bne.n	7f52 <uuid_to_uuid128+0x42>
		sys_put_le32(BT_UUID_32(src)->val,
    7f62:	6852      	ldr	r2, [r2, #4]
		*dst = uuid128_base;
    7f64:	7821      	ldrb	r1, [r4, #0]
    7f66:	7031      	strb	r1, [r6, #0]
    7f68:	f3c2 2107 	ubfx	r1, r2, #8, #8
	dst[0] = val;
    7f6c:	735a      	strb	r2, [r3, #13]
	sys_put_le16(val >> 16, &dst[2]);
    7f6e:	0c12      	lsrs	r2, r2, #16
	dst[0] = val;
    7f70:	73da      	strb	r2, [r3, #15]
	dst[1] = val >> 8;
    7f72:	0a12      	lsrs	r2, r2, #8
    7f74:	7399      	strb	r1, [r3, #14]
    7f76:	741a      	strb	r2, [r3, #16]
    7f78:	e7d3      	b.n	7f22 <uuid_to_uuid128+0x12>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    7f7a:	f100 0510 	add.w	r5, r0, #16
    7f7e:	6810      	ldr	r0, [r2, #0]
    7f80:	6851      	ldr	r1, [r2, #4]
    7f82:	461c      	mov	r4, r3
    7f84:	c403      	stmia	r4!, {r0, r1}
    7f86:	3208      	adds	r2, #8
    7f88:	42aa      	cmp	r2, r5
    7f8a:	4623      	mov	r3, r4
    7f8c:	d1f7      	bne.n	7f7e <uuid_to_uuid128+0x6e>
    7f8e:	7812      	ldrb	r2, [r2, #0]
    7f90:	7022      	strb	r2, [r4, #0]
    7f92:	e7c6      	b.n	7f22 <uuid_to_uuid128+0x12>
    7f94:	00062b45 	.word	0x00062b45

00007f98 <le_dhkey_complete>:
{
    7f98:	b510      	push	{r4, lr}
	if (dh_key_cb) {
    7f9a:	4c06      	ldr	r4, [pc, #24]	; (7fb4 <le_dhkey_complete+0x1c>)
    7f9c:	6822      	ldr	r2, [r4, #0]
    7f9e:	b132      	cbz	r2, 7fae <le_dhkey_complete+0x16>
	struct bt_hci_evt_le_generate_dhkey_complete *evt = (void *)buf->data;
    7fa0:	6880      	ldr	r0, [r0, #8]
		dh_key_cb(evt->status ? NULL : evt->dhkey);
    7fa2:	7803      	ldrb	r3, [r0, #0]
    7fa4:	b923      	cbnz	r3, 7fb0 <le_dhkey_complete+0x18>
    7fa6:	3001      	adds	r0, #1
    7fa8:	4790      	blx	r2
		dh_key_cb = NULL;
    7faa:	2300      	movs	r3, #0
    7fac:	6023      	str	r3, [r4, #0]
}
    7fae:	bd10      	pop	{r4, pc}
		dh_key_cb(evt->status ? NULL : evt->dhkey);
    7fb0:	2000      	movs	r0, #0
    7fb2:	e7f9      	b.n	7fa8 <le_dhkey_complete+0x10>
    7fb4:	20000328 	.word	0x20000328

00007fb8 <ver_str>:
{
    7fb8:	b570      	push	{r4, r5, r6, lr}
	const char * const str[] = {
    7fba:	4d0b      	ldr	r5, [pc, #44]	; (7fe8 <ver_str+0x30>)
{
    7fbc:	4606      	mov	r6, r0
	const char * const str[] = {
    7fbe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
    7fc0:	b08c      	sub	sp, #48	; 0x30
	const char * const str[] = {
    7fc2:	ac01      	add	r4, sp, #4
    7fc4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7fc6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    7fc8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7fca:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
	if (ver < ARRAY_SIZE(str)) {
    7fce:	2e0a      	cmp	r6, #10
	const char * const str[] = {
    7fd0:	e884 0007 	stmia.w	r4, {r0, r1, r2}
		return str[ver];
    7fd4:	bf9b      	ittet	ls
    7fd6:	ab0c      	addls	r3, sp, #48	; 0x30
    7fd8:	eb03 0686 	addls.w	r6, r3, r6, lsl #2
	return "unknown";
    7fdc:	4803      	ldrhi	r0, [pc, #12]	; (7fec <ver_str+0x34>)
		return str[ver];
    7fde:	f856 0c2c 	ldrls.w	r0, [r6, #-44]
}
    7fe2:	b00c      	add	sp, #48	; 0x30
    7fe4:	bd70      	pop	{r4, r5, r6, pc}
    7fe6:	bf00      	nop
    7fe8:	000286fc 	.word	0x000286fc
    7fec:	00065beb 	.word	0x00065beb

00007ff0 <le_pkey_complete>:
{
    7ff0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_hci_evt_le_p256_public_key_complete *evt = (void *)buf->data;
    7ff2:	6886      	ldr	r6, [r0, #8]
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    7ff4:	4811      	ldr	r0, [pc, #68]	; (803c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x3c>)
    7ff6:	f06f 0110 	mvn.w	r1, #16
    7ffa:	f01a f9e7 	bl	223cc <atomic_and>
	if (!evt->status) {
    7ffe:	7833      	ldrb	r3, [r6, #0]
    8000:	b96b      	cbnz	r3, 801e <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1e>
		memcpy(pub_key, evt->key, 64);
    8002:	4a0f      	ldr	r2, [pc, #60]	; (8040 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x40>)
    8004:	1c73      	adds	r3, r6, #1
    8006:	f106 0141 	add.w	r1, r6, #65	; 0x41
    800a:	f853 0b04 	ldr.w	r0, [r3], #4
    800e:	f842 0b04 	str.w	r0, [r2], #4
    8012:	428b      	cmp	r3, r1
    8014:	d1f9      	bne.n	800a <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xa>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    8016:	2108      	movs	r1, #8
    8018:	4808      	ldr	r0, [pc, #32]	; (803c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x3c>)
    801a:	f01a f9e6 	bl	223ea <atomic_or>
	for (cb = pub_key_cb; cb; cb = cb->_next) {
    801e:	4d09      	ldr	r5, [pc, #36]	; (8044 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x44>)
		cb->func(evt->status ? NULL : pub_key);
    8020:	4f07      	ldr	r7, [pc, #28]	; (8040 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x40>)
	for (cb = pub_key_cb; cb; cb = cb->_next) {
    8022:	682c      	ldr	r4, [r5, #0]
    8024:	b90c      	cbnz	r4, 802a <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2a>
	pub_key_cb = NULL;
    8026:	602c      	str	r4, [r5, #0]
}
    8028:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		cb->func(evt->status ? NULL : pub_key);
    802a:	7832      	ldrb	r2, [r6, #0]
    802c:	6823      	ldr	r3, [r4, #0]
    802e:	2a00      	cmp	r2, #0
    8030:	bf0c      	ite	eq
    8032:	4638      	moveq	r0, r7
    8034:	2000      	movne	r0, #0
    8036:	4798      	blx	r3
	for (cb = pub_key_cb; cb; cb = cb->_next) {
    8038:	6864      	ldr	r4, [r4, #4]
    803a:	e7f3      	b.n	8024 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x24>
    803c:	2000e548 	.word	0x2000e548
    8040:	2000a9f9 	.word	0x2000a9f9
    8044:	2000032c 	.word	0x2000032c

00008048 <hci_data_buf_overflow>:
	BT_WARN("Data buffer overflow (link type 0x%02x)", evt->link_type);
    8048:	2302      	movs	r3, #2
    804a:	f04f 0200 	mov.w	r2, #0
	struct bt_hci_evt_data_buf_overflow *evt = (void *)buf->data;
    804e:	6881      	ldr	r1, [r0, #8]
    8050:	4805      	ldr	r0, [pc, #20]	; (8068 <hci_data_buf_overflow+0x20>)
	BT_WARN("Data buffer overflow (link type 0x%02x)", evt->link_type);
    8052:	7809      	ldrb	r1, [r1, #0]
    8054:	f363 0207 	bfi	r2, r3, #0, #8
    8058:	4b04      	ldr	r3, [pc, #16]	; (806c <hci_data_buf_overflow+0x24>)
    805a:	1a1b      	subs	r3, r3, r0
    805c:	08db      	lsrs	r3, r3, #3
    805e:	f363 128f 	bfi	r2, r3, #6, #10
    8062:	4803      	ldr	r0, [pc, #12]	; (8070 <hci_data_buf_overflow+0x28>)
    8064:	f018 bff6 	b.w	21054 <log_1>
    8068:	00028540 	.word	0x00028540
    806c:	00028610 	.word	0x00028610
    8070:	00063247 	.word	0x00063247

00008074 <le_data_len_change>:
	u16_t handle = sys_le16_to_cpu(evt->handle);
    8074:	6883      	ldr	r3, [r0, #8]
{
    8076:	b510      	push	{r4, lr}
	u16_t handle = sys_le16_to_cpu(evt->handle);
    8078:	881c      	ldrh	r4, [r3, #0]
	conn = bt_conn_lookup_handle(handle);
    807a:	4620      	mov	r0, r4
    807c:	f002 febe 	bl	adfc <bt_conn_lookup_handle>
	if (!conn) {
    8080:	b980      	cbnz	r0, 80a4 <le_data_len_change+0x30>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    8082:	2301      	movs	r3, #1
    8084:	f04f 0200 	mov.w	r2, #0
    8088:	f363 0207 	bfi	r2, r3, #0, #8
    808c:	4907      	ldr	r1, [pc, #28]	; (80ac <le_data_len_change+0x38>)
    808e:	4b08      	ldr	r3, [pc, #32]	; (80b0 <le_data_len_change+0x3c>)
    8090:	4808      	ldr	r0, [pc, #32]	; (80b4 <le_data_len_change+0x40>)
    8092:	1a5b      	subs	r3, r3, r1
    8094:	08db      	lsrs	r3, r3, #3
    8096:	4621      	mov	r1, r4
    8098:	f363 128f 	bfi	r2, r3, #6, #10
}
    809c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		BT_ERR("Unable to lookup conn for handle %u", handle);
    80a0:	f018 bfd8 	b.w	21054 <log_1>
}
    80a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_conn_unref(conn);
    80a8:	f01a bb39 	b.w	2271e <bt_conn_unref>
    80ac:	00028540 	.word	0x00028540
    80b0:	00028610 	.word	0x00028610
    80b4:	000633b7 	.word	0x000633b7

000080b8 <le_conn_update_complete>:
{
    80b8:	b573      	push	{r0, r1, r4, r5, r6, lr}
	struct bt_hci_evt_le_conn_update_complete *evt = (void *)buf->data;
    80ba:	6885      	ldr	r5, [r0, #8]
	handle = sys_le16_to_cpu(evt->handle);
    80bc:	f8b5 6001 	ldrh.w	r6, [r5, #1]
	conn = bt_conn_lookup_handle(handle);
    80c0:	4630      	mov	r0, r6
    80c2:	f002 fe9b 	bl	adfc <bt_conn_lookup_handle>
	if (!conn) {
    80c6:	4604      	mov	r4, r0
    80c8:	b980      	cbnz	r0, 80ec <le_conn_update_complete+0x34>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    80ca:	2301      	movs	r3, #1
    80cc:	f04f 0200 	mov.w	r2, #0
    80d0:	f363 0207 	bfi	r2, r3, #0, #8
    80d4:	491e      	ldr	r1, [pc, #120]	; (8150 <le_conn_update_complete+0x98>)
    80d6:	4b1f      	ldr	r3, [pc, #124]	; (8154 <le_conn_update_complete+0x9c>)
    80d8:	481f      	ldr	r0, [pc, #124]	; (8158 <le_conn_update_complete+0xa0>)
    80da:	1a5b      	subs	r3, r3, r1
    80dc:	08db      	lsrs	r3, r3, #3
    80de:	f363 128f 	bfi	r2, r3, #6, #10
    80e2:	4631      	mov	r1, r6
    80e4:	f018 ffb6 	bl	21054 <log_1>
}
    80e8:	b002      	add	sp, #8
    80ea:	bd70      	pop	{r4, r5, r6, pc}
	if (!evt->status) {
    80ec:	782b      	ldrb	r3, [r5, #0]
    80ee:	b9bb      	cbnz	r3, 8120 <le_conn_update_complete+0x68>
		conn->le.interval = sys_le16_to_cpu(evt->interval);
    80f0:	792a      	ldrb	r2, [r5, #4]
    80f2:	78eb      	ldrb	r3, [r5, #3]
    80f4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    80f8:	f8a0 308a 	strh.w	r3, [r0, #138]	; 0x8a
		conn->le.latency = sys_le16_to_cpu(evt->latency);
    80fc:	79aa      	ldrb	r2, [r5, #6]
    80fe:	796b      	ldrb	r3, [r5, #5]
    8100:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    8104:	f8a0 3090 	strh.w	r3, [r0, #144]	; 0x90
		conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
    8108:	79eb      	ldrb	r3, [r5, #7]
    810a:	7a2a      	ldrb	r2, [r5, #8]
    810c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    8110:	f8a0 3092 	strh.w	r3, [r0, #146]	; 0x92
		notify_le_param_updated(conn);
    8114:	f002 fb70 	bl	a7f8 <notify_le_param_updated>
	bt_conn_unref(conn);
    8118:	4620      	mov	r0, r4
    811a:	f01a fb00 	bl	2271e <bt_conn_unref>
    811e:	e7e3      	b.n	80e8 <le_conn_update_complete+0x30>
	} else if (evt->status == BT_HCI_ERR_UNSUPP_REMOTE_FEATURE &&
    8120:	2b1a      	cmp	r3, #26
    8122:	d1f9      	bne.n	8118 <le_conn_update_complete+0x60>
    8124:	78c3      	ldrb	r3, [r0, #3]
    8126:	2b01      	cmp	r3, #1
    8128:	d1f6      	bne.n	8118 <le_conn_update_complete+0x60>
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    812a:	f44f 6180 	mov.w	r1, #1024	; 0x400
    812e:	3004      	adds	r0, #4
    8130:	f01a f95b 	bl	223ea <atomic_or>
		   conn->role == BT_HCI_ROLE_SLAVE &&
    8134:	0543      	lsls	r3, r0, #21
    8136:	d4ef      	bmi.n	8118 <le_conn_update_complete+0x60>
		param.interval_min = conn->le.interval_min;
    8138:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
    813c:	9300      	str	r3, [sp, #0]
		bt_l2cap_update_conn_param(conn, &param);
    813e:	4669      	mov	r1, sp
		param.latency = conn->le.pending_latency;
    8140:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    8144:	9301      	str	r3, [sp, #4]
		bt_l2cap_update_conn_param(conn, &param);
    8146:	4620      	mov	r0, r4
    8148:	f003 f9f4 	bl	b534 <bt_l2cap_update_conn_param>
    814c:	e7e4      	b.n	8118 <le_conn_update_complete+0x60>
    814e:	bf00      	nop
    8150:	00028540 	.word	0x00028540
    8154:	00028610 	.word	0x00028610
    8158:	000633b7 	.word	0x000633b7

0000815c <hci_vendor_event>:
{
    815c:	b510      	push	{r4, lr}
		BT_WARN("Unhandled vendor-specific event: %s",
    815e:	2302      	movs	r3, #2
    8160:	f04f 0400 	mov.w	r4, #0
    8164:	4a0a      	ldr	r2, [pc, #40]	; (8190 <hci_vendor_event+0x34>)
    8166:	8981      	ldrh	r1, [r0, #12]
    8168:	6880      	ldr	r0, [r0, #8]
    816a:	f363 0407 	bfi	r4, r3, #0, #8
    816e:	4b09      	ldr	r3, [pc, #36]	; (8194 <hci_vendor_event+0x38>)
    8170:	1a9b      	subs	r3, r3, r2
    8172:	08db      	lsrs	r3, r3, #3
    8174:	f363 148f 	bfi	r4, r3, #6, #10
    8178:	f7ff fb14 	bl	77a4 <bt_hex_real>
    817c:	f7fc fdc0 	bl	4d00 <log_strdup>
    8180:	4622      	mov	r2, r4
    8182:	4601      	mov	r1, r0
}
    8184:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		BT_WARN("Unhandled vendor-specific event: %s",
    8188:	4803      	ldr	r0, [pc, #12]	; (8198 <hci_vendor_event+0x3c>)
    818a:	f018 bf63 	b.w	21054 <log_1>
    818e:	bf00      	nop
    8190:	00028540 	.word	0x00028540
    8194:	00028610 	.word	0x00028610
    8198:	00063379 	.word	0x00063379

0000819c <update_sec_level>:
{
    819c:	b510      	push	{r4, lr}
	if (!conn->encrypt) {
    819e:	7ac3      	ldrb	r3, [r0, #11]
{
    81a0:	4604      	mov	r4, r0
	if (!conn->encrypt) {
    81a2:	b913      	cbnz	r3, 81aa <update_sec_level+0xe>
		conn->sec_level = BT_SECURITY_L1;
    81a4:	2301      	movs	r3, #1
    81a6:	7243      	strb	r3, [r0, #9]
}
    81a8:	bd10      	pop	{r4, pc}
	if (conn->le.keys && (conn->le.keys->flags & BT_KEYS_AUTHENTICATED)) {
    81aa:	f8d0 30a0 	ldr.w	r3, [r0, #160]	; 0xa0
    81ae:	b31b      	cbz	r3, 81f8 <update_sec_level+0x5c>
    81b0:	7a5a      	ldrb	r2, [r3, #9]
    81b2:	07d1      	lsls	r1, r2, #31
    81b4:	d520      	bpl.n	81f8 <update_sec_level+0x5c>
		if (conn->le.keys->flags & BT_KEYS_SC &&
    81b6:	06d2      	lsls	r2, r2, #27
    81b8:	d51c      	bpl.n	81f4 <update_sec_level+0x58>
    81ba:	7a1b      	ldrb	r3, [r3, #8]
    81bc:	2b10      	cmp	r3, #16
    81be:	d119      	bne.n	81f4 <update_sec_level+0x58>
			conn->sec_level = BT_SECURITY_L4;
    81c0:	2304      	movs	r3, #4
		conn->sec_level = BT_SECURITY_L2;
    81c2:	7263      	strb	r3, [r4, #9]
	if (conn->required_sec_level > conn->sec_level) {
    81c4:	7aa2      	ldrb	r2, [r4, #10]
    81c6:	7a63      	ldrb	r3, [r4, #9]
    81c8:	429a      	cmp	r2, r3
    81ca:	d9ed      	bls.n	81a8 <update_sec_level+0xc>
		BT_ERR("Failed to set required security level");
    81cc:	2301      	movs	r3, #1
    81ce:	f04f 0100 	mov.w	r1, #0
    81d2:	f363 0107 	bfi	r1, r3, #0, #8
    81d6:	4a09      	ldr	r2, [pc, #36]	; (81fc <update_sec_level+0x60>)
    81d8:	4b09      	ldr	r3, [pc, #36]	; (8200 <update_sec_level+0x64>)
    81da:	480a      	ldr	r0, [pc, #40]	; (8204 <update_sec_level+0x68>)
    81dc:	1a9b      	subs	r3, r3, r2
    81de:	08db      	lsrs	r3, r3, #3
    81e0:	f363 118f 	bfi	r1, r3, #6, #10
    81e4:	f018 ff29 	bl	2103a <log_0>
		bt_conn_disconnect(conn, BT_HCI_ERR_AUTH_FAIL);
    81e8:	4620      	mov	r0, r4
    81ea:	2105      	movs	r1, #5
}
    81ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		bt_conn_disconnect(conn, BT_HCI_ERR_AUTH_FAIL);
    81f0:	f01a ba9a 	b.w	22728 <bt_conn_disconnect>
			conn->sec_level = BT_SECURITY_L3;
    81f4:	2303      	movs	r3, #3
    81f6:	e7e4      	b.n	81c2 <update_sec_level+0x26>
		conn->sec_level = BT_SECURITY_L2;
    81f8:	2302      	movs	r3, #2
    81fa:	e7e2      	b.n	81c2 <update_sec_level+0x26>
    81fc:	00028540 	.word	0x00028540
    8200:	00028610 	.word	0x00028610
    8204:	000634f2 	.word	0x000634f2

00008208 <hci_encrypt_key_refresh_complete>:
{
    8208:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_encrypt_key_refresh_complete *evt = (void *)buf->data;
    820a:	6885      	ldr	r5, [r0, #8]
	handle = sys_le16_to_cpu(evt->handle);
    820c:	f8b5 6001 	ldrh.w	r6, [r5, #1]
	conn = bt_conn_lookup_handle(handle);
    8210:	4630      	mov	r0, r6
    8212:	f002 fdf3 	bl	adfc <bt_conn_lookup_handle>
	if (!conn) {
    8216:	4604      	mov	r4, r0
    8218:	b980      	cbnz	r0, 823c <hci_encrypt_key_refresh_complete+0x34>
		BT_ERR("Unable to look up conn with handle %u", handle);
    821a:	2301      	movs	r3, #1
    821c:	f04f 0200 	mov.w	r2, #0
    8220:	f363 0207 	bfi	r2, r3, #0, #8
    8224:	4917      	ldr	r1, [pc, #92]	; (8284 <hci_encrypt_key_refresh_complete+0x7c>)
    8226:	4b18      	ldr	r3, [pc, #96]	; (8288 <hci_encrypt_key_refresh_complete+0x80>)
    8228:	4818      	ldr	r0, [pc, #96]	; (828c <hci_encrypt_key_refresh_complete+0x84>)
    822a:	1a5b      	subs	r3, r3, r1
    822c:	08db      	lsrs	r3, r3, #3
    822e:	4631      	mov	r1, r6
    8230:	f363 128f 	bfi	r2, r3, #6, #10
}
    8234:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_ERR("Unable to look up conn with handle %u", handle);
    8238:	f018 bf0c 	b.w	21054 <log_1>
	if (evt->status) {
    823c:	7829      	ldrb	r1, [r5, #0]
    823e:	b189      	cbz	r1, 8264 <hci_encrypt_key_refresh_complete+0x5c>
	conn->required_sec_level = conn->sec_level;
    8240:	7a43      	ldrb	r3, [r0, #9]
    8242:	7283      	strb	r3, [r0, #10]
		bt_l2cap_encrypt_change(conn, evt->status);
    8244:	f01a fb24 	bl	22890 <bt_l2cap_encrypt_change>
		bt_conn_security_changed(conn, security_err_get(evt->status));
    8248:	782b      	ldrb	r3, [r5, #0]
	switch (hci_err) {
    824a:	2b29      	cmp	r3, #41	; 0x29
    824c:	bf9a      	itte	ls
    824e:	4a10      	ldrls	r2, [pc, #64]	; (8290 <hci_encrypt_key_refresh_complete+0x88>)
    8250:	5cd1      	ldrbls	r1, [r2, r3]
		bt_conn_security_changed(conn, security_err_get(evt->status));
    8252:	2108      	movhi	r1, #8
	bt_conn_security_changed(conn, BT_SECURITY_ERR_SUCCESS);
    8254:	4620      	mov	r0, r4
    8256:	f002 fb3d 	bl	a8d4 <bt_conn_security_changed>
	bt_conn_unref(conn);
    825a:	4620      	mov	r0, r4
}
    825c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_conn_unref(conn);
    8260:	f01a ba5d 	b.w	2271e <bt_conn_unref>
	if (conn->type == BT_CONN_TYPE_LE) {
    8264:	7883      	ldrb	r3, [r0, #2]
    8266:	2b01      	cmp	r3, #1
    8268:	d104      	bne.n	8274 <hci_encrypt_key_refresh_complete+0x6c>
		bt_smp_update_keys(conn);
    826a:	f007 fed9 	bl	10020 <bt_smp_update_keys>
		update_sec_level(conn);
    826e:	4620      	mov	r0, r4
    8270:	f7ff ff94 	bl	819c <update_sec_level>
	conn->required_sec_level = conn->sec_level;
    8274:	7a63      	ldrb	r3, [r4, #9]
    8276:	72a3      	strb	r3, [r4, #10]
	bt_l2cap_encrypt_change(conn, evt->status);
    8278:	7829      	ldrb	r1, [r5, #0]
    827a:	4620      	mov	r0, r4
    827c:	f01a fb08 	bl	22890 <bt_l2cap_encrypt_change>
	bt_conn_security_changed(conn, BT_SECURITY_ERR_SUCCESS);
    8280:	2100      	movs	r1, #0
    8282:	e7e7      	b.n	8254 <hci_encrypt_key_refresh_complete+0x4c>
    8284:	00028540 	.word	0x00028540
    8288:	00028610 	.word	0x00028610
    828c:	0006326f 	.word	0x0006326f
    8290:	00062b56 	.word	0x00062b56

00008294 <hci_encrypt_change>:
{
    8294:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_encrypt_change *evt = (void *)buf->data;
    8296:	6885      	ldr	r5, [r0, #8]
	u16_t handle = sys_le16_to_cpu(evt->handle);
    8298:	f8b5 6001 	ldrh.w	r6, [r5, #1]
	conn = bt_conn_lookup_handle(handle);
    829c:	4630      	mov	r0, r6
    829e:	f002 fdad 	bl	adfc <bt_conn_lookup_handle>
	if (!conn) {
    82a2:	4604      	mov	r4, r0
    82a4:	b980      	cbnz	r0, 82c8 <hci_encrypt_change+0x34>
		BT_ERR("Unable to look up conn with handle %u", handle);
    82a6:	2301      	movs	r3, #1
    82a8:	f04f 0200 	mov.w	r2, #0
    82ac:	f363 0207 	bfi	r2, r3, #0, #8
    82b0:	4919      	ldr	r1, [pc, #100]	; (8318 <hci_encrypt_change+0x84>)
    82b2:	4b1a      	ldr	r3, [pc, #104]	; (831c <hci_encrypt_change+0x88>)
    82b4:	481a      	ldr	r0, [pc, #104]	; (8320 <hci_encrypt_change+0x8c>)
    82b6:	1a5b      	subs	r3, r3, r1
    82b8:	08db      	lsrs	r3, r3, #3
    82ba:	4631      	mov	r1, r6
    82bc:	f363 128f 	bfi	r2, r3, #6, #10
}
    82c0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_ERR("Unable to look up conn with handle %u", handle);
    82c4:	f018 bec6 	b.w	21054 <log_1>
	if (evt->status) {
    82c8:	7829      	ldrb	r1, [r5, #0]
    82ca:	b189      	cbz	r1, 82f0 <hci_encrypt_change+0x5c>
	conn->required_sec_level = conn->sec_level;
    82cc:	7a43      	ldrb	r3, [r0, #9]
    82ce:	7283      	strb	r3, [r0, #10]
		bt_l2cap_encrypt_change(conn, evt->status);
    82d0:	f01a fade 	bl	22890 <bt_l2cap_encrypt_change>
		bt_conn_security_changed(conn, security_err_get(evt->status));
    82d4:	782b      	ldrb	r3, [r5, #0]
	switch (hci_err) {
    82d6:	2b29      	cmp	r3, #41	; 0x29
    82d8:	bf9a      	itte	ls
    82da:	4a12      	ldrls	r2, [pc, #72]	; (8324 <hci_encrypt_change+0x90>)
    82dc:	5cd1      	ldrbls	r1, [r2, r3]
		bt_conn_security_changed(conn, security_err_get(evt->status));
    82de:	2108      	movhi	r1, #8
	bt_conn_security_changed(conn, BT_SECURITY_ERR_SUCCESS);
    82e0:	4620      	mov	r0, r4
    82e2:	f002 faf7 	bl	a8d4 <bt_conn_security_changed>
	bt_conn_unref(conn);
    82e6:	4620      	mov	r0, r4
}
    82e8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_conn_unref(conn);
    82ec:	f01a ba17 	b.w	2271e <bt_conn_unref>
	if (conn->type == BT_CONN_TYPE_LE) {
    82f0:	7882      	ldrb	r2, [r0, #2]
	conn->encrypt = evt->encrypt;
    82f2:	78eb      	ldrb	r3, [r5, #3]
    82f4:	72c3      	strb	r3, [r0, #11]
	if (conn->type == BT_CONN_TYPE_LE) {
    82f6:	2a01      	cmp	r2, #1
    82f8:	d105      	bne.n	8306 <hci_encrypt_change+0x72>
		if (conn->encrypt) {
    82fa:	b10b      	cbz	r3, 8300 <hci_encrypt_change+0x6c>
			bt_smp_update_keys(conn);
    82fc:	f007 fe90 	bl	10020 <bt_smp_update_keys>
		update_sec_level(conn);
    8300:	4620      	mov	r0, r4
    8302:	f7ff ff4b 	bl	819c <update_sec_level>
	conn->required_sec_level = conn->sec_level;
    8306:	7a63      	ldrb	r3, [r4, #9]
    8308:	72a3      	strb	r3, [r4, #10]
	bt_l2cap_encrypt_change(conn, evt->status);
    830a:	7829      	ldrb	r1, [r5, #0]
    830c:	4620      	mov	r0, r4
    830e:	f01a fabf 	bl	22890 <bt_l2cap_encrypt_change>
	bt_conn_security_changed(conn, BT_SECURITY_ERR_SUCCESS);
    8312:	2100      	movs	r1, #0
    8314:	e7e4      	b.n	82e0 <hci_encrypt_change+0x4c>
    8316:	bf00      	nop
    8318:	00028540 	.word	0x00028540
    831c:	00028610 	.word	0x00028610
    8320:	0006326f 	.word	0x0006326f
    8324:	00062b56 	.word	0x00062b56

00008328 <find_pending_connect.part.18>:
static struct bt_conn *find_pending_connect(u8_t role, bt_addr_le_t *peer_addr)
    8328:	b507      	push	{r0, r1, r2, lr}
		conn = bt_conn_lookup_state_le(peer_addr,
    832a:	2104      	movs	r1, #4
    832c:	f002 fd9e 	bl	ae6c <bt_conn_lookup_state_le>
		if (!conn) {
    8330:	b960      	cbnz	r0, 834c <find_pending_connect.part.18+0x24>
			conn = bt_conn_lookup_state_le(BT_ADDR_LE_NONE,
    8332:	4b08      	ldr	r3, [pc, #32]	; (8354 <find_pending_connect.part.18+0x2c>)
    8334:	6818      	ldr	r0, [r3, #0]
    8336:	889a      	ldrh	r2, [r3, #4]
    8338:	9000      	str	r0, [sp, #0]
    833a:	799b      	ldrb	r3, [r3, #6]
    833c:	f8ad 2004 	strh.w	r2, [sp, #4]
    8340:	2103      	movs	r1, #3
    8342:	4668      	mov	r0, sp
    8344:	f88d 3006 	strb.w	r3, [sp, #6]
    8348:	f002 fd90 	bl	ae6c <bt_conn_lookup_state_le>
}
    834c:	b003      	add	sp, #12
    834e:	f85d fb04 	ldr.w	pc, [sp], #4
    8352:	bf00      	nop
    8354:	00028728 	.word	0x00028728

00008358 <handle_event>:
{
    8358:	b573      	push	{r0, r1, r4, r5, r6, lr}
    835a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    835e:	4604      	mov	r4, r0
    8360:	4608      	mov	r0, r1
		if (handler->event != event) {
    8362:	7811      	ldrb	r1, [r2, #0]
    8364:	42a1      	cmp	r1, r4
    8366:	d01e      	beq.n	83a6 <handle_event+0x4e>
			continue;
    8368:	3208      	adds	r2, #8
	for (i = 0; i < num_handlers; i++) {
    836a:	429a      	cmp	r2, r3
    836c:	d1f9      	bne.n	8362 <handle_event+0xa>
	BT_WARN("Unhandled event 0x%02x len %u: %s", event,
    836e:	2302      	movs	r3, #2
    8370:	f04f 0500 	mov.w	r5, #0
    8374:	4a19      	ldr	r2, [pc, #100]	; (83dc <handle_event+0x84>)
    8376:	8986      	ldrh	r6, [r0, #12]
    8378:	6880      	ldr	r0, [r0, #8]
    837a:	f363 0507 	bfi	r5, r3, #0, #8
    837e:	4b18      	ldr	r3, [pc, #96]	; (83e0 <handle_event+0x88>)
    8380:	1a9b      	subs	r3, r3, r2
    8382:	08db      	lsrs	r3, r3, #3
    8384:	4631      	mov	r1, r6
    8386:	f363 158f 	bfi	r5, r3, #6, #10
    838a:	f7ff fa0b 	bl	77a4 <bt_hex_real>
    838e:	f7fc fcb7 	bl	4d00 <log_strdup>
    8392:	f8ad 5000 	strh.w	r5, [sp]
    8396:	4603      	mov	r3, r0
    8398:	4632      	mov	r2, r6
    839a:	4621      	mov	r1, r4
    839c:	4811      	ldr	r0, [pc, #68]	; (83e4 <handle_event+0x8c>)
    839e:	f018 fe85 	bl	210ac <log_3>
}
    83a2:	b002      	add	sp, #8
    83a4:	bd70      	pop	{r4, r5, r6, pc}
		if (buf->len < handler->min_len) {
    83a6:	8981      	ldrh	r1, [r0, #12]
    83a8:	7853      	ldrb	r3, [r2, #1]
    83aa:	428b      	cmp	r3, r1
    83ac:	d911      	bls.n	83d2 <handle_event+0x7a>
			BT_ERR("Too small (%u bytes) event 0x%02x",
    83ae:	2201      	movs	r2, #1
    83b0:	f04f 0300 	mov.w	r3, #0
    83b4:	f362 0307 	bfi	r3, r2, #0, #8
    83b8:	4808      	ldr	r0, [pc, #32]	; (83dc <handle_event+0x84>)
    83ba:	4a09      	ldr	r2, [pc, #36]	; (83e0 <handle_event+0x88>)
    83bc:	1a12      	subs	r2, r2, r0
    83be:	08d2      	lsrs	r2, r2, #3
    83c0:	4809      	ldr	r0, [pc, #36]	; (83e8 <handle_event+0x90>)
    83c2:	f362 138f 	bfi	r3, r2, #6, #10
    83c6:	4622      	mov	r2, r4
}
    83c8:	b002      	add	sp, #8
    83ca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			BT_ERR("Too small (%u bytes) event 0x%02x",
    83ce:	f018 be55 	b.w	2107c <log_2>
		handler->handler(buf);
    83d2:	6853      	ldr	r3, [r2, #4]
}
    83d4:	b002      	add	sp, #8
    83d6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		handler->handler(buf);
    83da:	4718      	bx	r3
    83dc:	00028540 	.word	0x00028540
    83e0:	00028610 	.word	0x00028610
    83e4:	000631bd 	.word	0x000631bd
    83e8:	0006319b 	.word	0x0006319b

000083ec <hci_le_meta_event>:
{
    83ec:	b510      	push	{r4, lr}
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    83ee:	2101      	movs	r1, #1
{
    83f0:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    83f2:	3008      	adds	r0, #8
    83f4:	f01c fd22 	bl	24e3c <net_buf_simple_pull_mem>
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    83f8:	4621      	mov	r1, r4
    83fa:	230a      	movs	r3, #10
    83fc:	4a02      	ldr	r2, [pc, #8]	; (8408 <hci_le_meta_event+0x1c>)
    83fe:	7800      	ldrb	r0, [r0, #0]
}
    8400:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    8404:	f7ff bfa8 	b.w	8358 <handle_event>
    8408:	00028e1c 	.word	0x00028e1c

0000840c <hci_cmd_done>:
{
    840c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    8410:	4606      	mov	r6, r0
    8412:	b085      	sub	sp, #20
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    8414:	7990      	ldrb	r0, [r2, #6]
    8416:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 8508 <hci_cmd_done+0xfc>
{
    841a:	460f      	mov	r7, r1
    841c:	4615      	mov	r5, r2
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    841e:	f010 fd75 	bl	18f0c <net_buf_pool_get>
    8422:	4580      	cmp	r8, r0
    8424:	d01a      	beq.n	845c <hci_cmd_done+0x50>
		BT_WARN("opcode 0x%04x pool id %u pool %p != &hci_cmd_pool %p",
    8426:	2302      	movs	r3, #2
    8428:	f04f 0400 	mov.w	r4, #0
    842c:	f363 0407 	bfi	r4, r3, #0, #8
    8430:	4a30      	ldr	r2, [pc, #192]	; (84f4 <hci_cmd_done+0xe8>)
    8432:	4b31      	ldr	r3, [pc, #196]	; (84f8 <hci_cmd_done+0xec>)
    8434:	79a8      	ldrb	r0, [r5, #6]
    8436:	9600      	str	r6, [sp, #0]
    8438:	1ad2      	subs	r2, r2, r3
    843a:	08d2      	lsrs	r2, r2, #3
    843c:	f362 148f 	bfi	r4, r2, #6, #10
    8440:	9001      	str	r0, [sp, #4]
    8442:	f010 fd63 	bl	18f0c <net_buf_pool_get>
    8446:	4623      	mov	r3, r4
    8448:	e9cd 0802 	strd	r0, r8, [sp, #8]
    844c:	2204      	movs	r2, #4
    844e:	4669      	mov	r1, sp
    8450:	482a      	ldr	r0, [pc, #168]	; (84fc <hci_cmd_done+0xf0>)
    8452:	f018 fe46 	bl	210e2 <log_n>
}
    8456:	b005      	add	sp, #20
    8458:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (cmd(buf)->opcode != opcode) {
    845c:	4628      	mov	r0, r5
    845e:	f010 fd5d 	bl	18f1c <net_buf_id>
    8462:	4c27      	ldr	r4, [pc, #156]	; (8500 <hci_cmd_done+0xf4>)
    8464:	f04f 080c 	mov.w	r8, #12
    8468:	fb08 4000 	mla	r0, r8, r0, r4
    846c:	8843      	ldrh	r3, [r0, #2]
    846e:	42b3      	cmp	r3, r6
    8470:	d015      	beq.n	849e <hci_cmd_done+0x92>
		BT_WARN("OpCode 0x%04x completed instead of expected 0x%04x",
    8472:	2302      	movs	r3, #2
    8474:	f04f 0900 	mov.w	r9, #0
    8478:	f363 0907 	bfi	r9, r3, #0, #8
    847c:	4a1d      	ldr	r2, [pc, #116]	; (84f4 <hci_cmd_done+0xe8>)
    847e:	4b1e      	ldr	r3, [pc, #120]	; (84f8 <hci_cmd_done+0xec>)
    8480:	1ad2      	subs	r2, r2, r3
    8482:	08d2      	lsrs	r2, r2, #3
    8484:	4628      	mov	r0, r5
    8486:	f362 198f 	bfi	r9, r2, #6, #10
    848a:	f010 fd47 	bl	18f1c <net_buf_id>
    848e:	fb08 4000 	mla	r0, r8, r0, r4
    8492:	464b      	mov	r3, r9
    8494:	8842      	ldrh	r2, [r0, #2]
    8496:	481b      	ldr	r0, [pc, #108]	; (8504 <hci_cmd_done+0xf8>)
    8498:	4631      	mov	r1, r6
    849a:	f018 fdef 	bl	2107c <log_2>
	if (cmd(buf)->state && !status) {
    849e:	4628      	mov	r0, r5
    84a0:	f010 fd3c 	bl	18f1c <net_buf_id>
    84a4:	260c      	movs	r6, #12
    84a6:	fb06 4000 	mla	r0, r6, r0, r4
    84aa:	6843      	ldr	r3, [r0, #4]
    84ac:	b15b      	cbz	r3, 84c6 <hci_cmd_done+0xba>
    84ae:	b957      	cbnz	r7, 84c6 <hci_cmd_done+0xba>
		struct cmd_state_set *update = cmd(buf)->state;
    84b0:	4628      	mov	r0, r5
    84b2:	f010 fd33 	bl	18f1c <net_buf_id>
    84b6:	fb06 4000 	mla	r0, r6, r0, r4
    84ba:	6843      	ldr	r3, [r0, #4]
		atomic_set_bit_to(update->target, update->bit, update->val);
    84bc:	7a1a      	ldrb	r2, [r3, #8]
    84be:	e9d3 0100 	ldrd	r0, r1, [r3]
    84c2:	f019 ffa1 	bl	22408 <atomic_set_bit_to>
	if (cmd(buf)->sync) {
    84c6:	4628      	mov	r0, r5
    84c8:	f010 fd28 	bl	18f1c <net_buf_id>
    84cc:	260c      	movs	r6, #12
    84ce:	fb06 4000 	mla	r0, r6, r0, r4
    84d2:	6883      	ldr	r3, [r0, #8]
    84d4:	2b00      	cmp	r3, #0
    84d6:	d0be      	beq.n	8456 <hci_cmd_done+0x4a>
		cmd(buf)->status = status;
    84d8:	4628      	mov	r0, r5
    84da:	f010 fd1f 	bl	18f1c <net_buf_id>
    84de:	4370      	muls	r0, r6
    84e0:	5427      	strb	r7, [r4, r0]
		k_sem_give(cmd(buf)->sync);
    84e2:	4628      	mov	r0, r5
    84e4:	f010 fd1a 	bl	18f1c <net_buf_id>
    84e8:	fb06 4000 	mla	r0, r6, r0, r4
    84ec:	6880      	ldr	r0, [r0, #8]
	z_impl_k_sem_give(sem);
    84ee:	f016 fc45 	bl	1ed7c <z_impl_k_sem_give>
    84f2:	e7b0      	b.n	8456 <hci_cmd_done+0x4a>
    84f4:	00028610 	.word	0x00028610
    84f8:	00028540 	.word	0x00028540
    84fc:	000631df 	.word	0x000631df
    8500:	20000310 	.word	0x20000310
    8504:	00063214 	.word	0x00063214
    8508:	2000f098 	.word	0x2000f098

0000850c <id_find>:
	memcpy(addrs, bt_dev.id_addr, to_copy * sizeof(bt_addr_le_t));
	*count = to_copy;
}

static int id_find(const bt_addr_le_t *addr)
{
    850c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u8_t id;

	for (id = 0U; id < bt_dev.id_count; id++) {
    850e:	4e0b      	ldr	r6, [pc, #44]	; (853c <id_find+0x30>)
{
    8510:	4607      	mov	r7, r0
	for (id = 0U; id < bt_dev.id_count; id++) {
    8512:	2500      	movs	r5, #0
    8514:	79f3      	ldrb	r3, [r6, #7]
    8516:	b2ec      	uxtb	r4, r5
    8518:	42a3      	cmp	r3, r4
    851a:	d802      	bhi.n	8522 <id_find+0x16>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
			return id;
		}
	}

	return -ENOENT;
    851c:	f06f 0401 	mvn.w	r4, #1
    8520:	e009      	b.n	8536 <id_find+0x2a>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
    8522:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
	return memcmp(a, b, sizeof(*a));
}

static inline int bt_addr_le_cmp(const bt_addr_le_t *a, const bt_addr_le_t *b)
{
	return memcmp(a, b, sizeof(*a));
    8526:	2207      	movs	r2, #7
    8528:	4431      	add	r1, r6
    852a:	4638      	mov	r0, r7
    852c:	f7f9 fb50 	bl	1bd0 <memcmp>
    8530:	3501      	adds	r5, #1
    8532:	2800      	cmp	r0, #0
    8534:	d1ee      	bne.n	8514 <id_find+0x8>
}
    8536:	4620      	mov	r0, r4
    8538:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    853a:	bf00      	nop
    853c:	2000e4d8 	.word	0x2000e4d8

00008540 <hci_tx_thread>:
{
    8540:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		BT_ERR("Uncleared pending sent_cmd");
    8544:	4a52      	ldr	r2, [pc, #328]	; (8690 <hci_tx_thread+0x150>)
    8546:	4b53      	ldr	r3, [pc, #332]	; (8694 <hci_tx_thread+0x154>)
    8548:	1a9b      	subs	r3, r3, r2
    854a:	f3c3 0bc9 	ubfx	fp, r3, #3, #10
		events[0].state = K_POLL_STATE_NOT_READY;
    854e:	4a52      	ldr	r2, [pc, #328]	; (8698 <hci_tx_thread+0x158>)
    8550:	68d3      	ldr	r3, [r2, #12]
    8552:	f36f 3310 	bfc	r3, #12, #5
    8556:	60d3      	str	r3, [r2, #12]
			ev_count += bt_conn_prepare_events(&events[1]);
    8558:	f102 0014 	add.w	r0, r2, #20
    855c:	f002 fb06 	bl	ab6c <bt_conn_prepare_events>
    8560:	1c47      	adds	r7, r0, #1
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&events, *(uintptr_t *)&num_events, *(uintptr_t *)&timeout, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
    8562:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    8566:	4639      	mov	r1, r7
    8568:	484b      	ldr	r0, [pc, #300]	; (8698 <hci_tx_thread+0x158>)
    856a:	f016 ff3d 	bl	1f3e8 <z_impl_k_poll>
		BT_ASSERT(err == 0);
    856e:	b160      	cbz	r0, 858a <hci_tx_thread+0x4a>
    8570:	f640 73ab 	movw	r3, #4011	; 0xfab
    8574:	4a49      	ldr	r2, [pc, #292]	; (869c <hci_tx_thread+0x15c>)
    8576:	494a      	ldr	r1, [pc, #296]	; (86a0 <hci_tx_thread+0x160>)
    8578:	484a      	ldr	r0, [pc, #296]	; (86a4 <hci_tx_thread+0x164>)
    857a:	f017 fc1a 	bl	1fdb2 <printk>
    857e:	4040      	eors	r0, r0
    8580:	f380 8811 	msr	BASEPRI, r0
    8584:	f04f 0003 	mov.w	r0, #3
    8588:	df02      	svc	2
{
    858a:	4d43      	ldr	r5, [pc, #268]	; (8698 <hci_tx_thread+0x158>)
	return z_impl_k_sem_take(sem, timeout);
    858c:	4c46      	ldr	r4, [pc, #280]	; (86a8 <hci_tx_thread+0x168>)
	for (; count; ev++, count--) {
    858e:	b917      	cbnz	r7, 8596 <hci_tx_thread+0x56>
	z_impl_k_yield();
    8590:	f016 fb7a 	bl	1ec88 <z_impl_k_yield>
    8594:	e7db      	b.n	854e <hci_tx_thread+0xe>
		switch (ev->state) {
    8596:	68e9      	ldr	r1, [r5, #12]
    8598:	f3c1 3104 	ubfx	r1, r1, #12, #5
    859c:	2901      	cmp	r1, #1
    859e:	d960      	bls.n	8662 <hci_tx_thread+0x122>
    85a0:	2904      	cmp	r1, #4
    85a2:	d168      	bne.n	8676 <hci_tx_thread+0x136>
			if (ev->tag == BT_EVENT_CMD_TX) {
    85a4:	7b29      	ldrb	r1, [r5, #12]
    85a6:	2900      	cmp	r1, #0
    85a8:	d15e      	bne.n	8668 <hci_tx_thread+0x128>
	buf = net_buf_get(&bt_dev.cmd_tx_queue, K_NO_WAIT);
    85aa:	4840      	ldr	r0, [pc, #256]	; (86ac <hci_tx_thread+0x16c>)
    85ac:	f01c fbe6 	bl	24d7c <net_buf_get>
	BT_ASSERT(buf);
    85b0:	4606      	mov	r6, r0
    85b2:	b960      	cbnz	r0, 85ce <hci_tx_thread+0x8e>
    85b4:	f640 734c 	movw	r3, #3916	; 0xf4c
    85b8:	4a38      	ldr	r2, [pc, #224]	; (869c <hci_tx_thread+0x15c>)
    85ba:	493d      	ldr	r1, [pc, #244]	; (86b0 <hci_tx_thread+0x170>)
    85bc:	4839      	ldr	r0, [pc, #228]	; (86a4 <hci_tx_thread+0x164>)
    85be:	f017 fbf8 	bl	1fdb2 <printk>
    85c2:	4040      	eors	r0, r0
    85c4:	f380 8811 	msr	BASEPRI, r0
    85c8:	f04f 0003 	mov.w	r0, #3
    85cc:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
    85ce:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    85d2:	4838      	ldr	r0, [pc, #224]	; (86b4 <hci_tx_thread+0x174>)
    85d4:	f016 fbfe 	bl	1edd4 <z_impl_k_sem_take>
	if (bt_dev.sent_cmd) {
    85d8:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
    85dc:	b193      	cbz	r3, 8604 <hci_tx_thread+0xc4>
		BT_ERR("Uncleared pending sent_cmd");
    85de:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
    85e2:	f043 0301 	orr.w	r3, r3, #1
    85e6:	f363 0807 	bfi	r8, r3, #0, #8
    85ea:	f36b 188f 	bfi	r8, fp, #6, #10
    85ee:	4641      	mov	r1, r8
    85f0:	4831      	ldr	r0, [pc, #196]	; (86b8 <hci_tx_thread+0x178>)
    85f2:	f018 fd22 	bl	2103a <log_0>
		net_buf_unref(bt_dev.sent_cmd);
    85f6:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
    85fa:	f010 fd2f 	bl	1905c <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    85fe:	2300      	movs	r3, #0
    8600:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
	bt_dev.sent_cmd = net_buf_ref(buf);
    8604:	4630      	mov	r0, r6
    8606:	f01c fbe3 	bl	24dd0 <net_buf_ref>
    860a:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
		return bt_hci_ecc_send(buf);
    860e:	4630      	mov	r0, r6
    8610:	f7ff fa14 	bl	7a3c <bt_hci_ecc_send>
	if (err) {
    8614:	4601      	mov	r1, r0
    8616:	b320      	cbz	r0, 8662 <hci_tx_thread+0x122>
		BT_ERR("Unable to send to driver (err %d)", err);
    8618:	f029 033f 	bic.w	r3, r9, #63	; 0x3f
    861c:	f043 0301 	orr.w	r3, r3, #1
    8620:	f363 0907 	bfi	r9, r3, #0, #8
    8624:	f36b 198f 	bfi	r9, fp, #6, #10
    8628:	464a      	mov	r2, r9
    862a:	4824      	ldr	r0, [pc, #144]	; (86bc <hci_tx_thread+0x17c>)
    862c:	f018 fd12 	bl	21054 <log_1>
	z_impl_k_sem_give(sem);
    8630:	4820      	ldr	r0, [pc, #128]	; (86b4 <hci_tx_thread+0x174>)
    8632:	f016 fba3 	bl	1ed7c <z_impl_k_sem_give>
		hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED,
    8636:	4630      	mov	r0, r6
    8638:	f010 fc70 	bl	18f1c <net_buf_id>
    863c:	4a20      	ldr	r2, [pc, #128]	; (86c0 <hci_tx_thread+0x180>)
    863e:	230c      	movs	r3, #12
    8640:	fb03 2000 	mla	r0, r3, r0, r2
    8644:	211f      	movs	r1, #31
    8646:	2200      	movs	r2, #0
    8648:	8840      	ldrh	r0, [r0, #2]
    864a:	f7ff fedf 	bl	840c <hci_cmd_done>
		net_buf_unref(bt_dev.sent_cmd);
    864e:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
    8652:	f010 fd03 	bl	1905c <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    8656:	2300      	movs	r3, #0
		net_buf_unref(buf);
    8658:	4630      	mov	r0, r6
		bt_dev.sent_cmd = NULL;
    865a:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
		net_buf_unref(buf);
    865e:	f010 fcfd 	bl	1905c <net_buf_unref>
	for (; count; ev++, count--) {
    8662:	3514      	adds	r5, #20
    8664:	3f01      	subs	r7, #1
    8666:	e792      	b.n	858e <hci_tx_thread+0x4e>
				if (ev->tag == BT_EVENT_CONN_TX_QUEUE) {
    8668:	2901      	cmp	r1, #1
    866a:	d1fa      	bne.n	8662 <hci_tx_thread+0x122>
					conn = CONTAINER_OF(ev->fifo,
    866c:	6928      	ldr	r0, [r5, #16]
					bt_conn_process_tx(conn);
    866e:	3834      	subs	r0, #52	; 0x34
    8670:	f002 fd26 	bl	b0c0 <bt_conn_process_tx>
    8674:	e7f5      	b.n	8662 <hci_tx_thread+0x122>
			BT_WARN("Unexpected k_poll event state %u", ev->state);
    8676:	f02a 033f 	bic.w	r3, sl, #63	; 0x3f
    867a:	f043 0302 	orr.w	r3, r3, #2
    867e:	f363 0a07 	bfi	sl, r3, #0, #8
    8682:	f36b 1a8f 	bfi	sl, fp, #6, #10
    8686:	4652      	mov	r2, sl
    8688:	480e      	ldr	r0, [pc, #56]	; (86c4 <hci_tx_thread+0x184>)
    868a:	f018 fce3 	bl	21054 <log_1>
    868e:	e7e8      	b.n	8662 <hci_tx_thread+0x122>
    8690:	00028540 	.word	0x00028540
    8694:	00028610 	.word	0x00028610
    8698:	2000e79c 	.word	0x2000e79c
    869c:	000632c8 	.word	0x000632c8
    86a0:	000632f5 	.word	0x000632f5
    86a4:	000632fe 	.word	0x000632fe
    86a8:	2000e4d8 	.word	0x2000e4d8
    86ac:	2000e59c 	.word	0x2000e59c
    86b0:	00064dfa 	.word	0x00064dfa
    86b4:	2000e580 	.word	0x2000e580
    86b8:	0006331b 	.word	0x0006331b
    86bc:	00063336 	.word	0x00063336
    86c0:	20000310 	.word	0x20000310
    86c4:	00063358 	.word	0x00063358

000086c8 <hci_num_completed_packets>:
{
    86c8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
				BT_ERR("packets count mismatch");
    86cc:	4b4f      	ldr	r3, [pc, #316]	; (880c <hci_num_completed_packets+0x144>)
    86ce:	4c50      	ldr	r4, [pc, #320]	; (8810 <hci_num_completed_packets+0x148>)
	struct bt_hci_evt_num_completed_packets *evt = (void *)buf->data;
    86d0:	f8d0 9008 	ldr.w	r9, [r0, #8]
				BT_ERR("packets count mismatch");
    86d4:	1ae4      	subs	r4, r4, r3
    86d6:	f3c4 04c9 	ubfx	r4, r4, #3, #10
	for (i = 0; i < evt->num_handles; i++) {
    86da:	2500      	movs	r5, #0
    86dc:	f899 3000 	ldrb.w	r3, [r9]
    86e0:	429d      	cmp	r5, r3
    86e2:	db02      	blt.n	86ea <hci_num_completed_packets+0x22>
}
    86e4:	b003      	add	sp, #12
    86e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		handle = sys_le16_to_cpu(evt->h[i].handle);
    86ea:	eb09 0385 	add.w	r3, r9, r5, lsl #2
    86ee:	f8b3 b001 	ldrh.w	fp, [r3, #1]
		count = sys_le16_to_cpu(evt->h[i].count);
    86f2:	f8b3 6003 	ldrh.w	r6, [r3, #3]
	__asm__ volatile(
    86f6:	f04f 0320 	mov.w	r3, #32
    86fa:	f3ef 8211 	mrs	r2, BASEPRI
    86fe:	f383 8811 	msr	BASEPRI, r3
    8702:	f3bf 8f6f 	isb	sy
		conn = bt_conn_lookup_handle(handle);
    8706:	4658      	mov	r0, fp
    8708:	9201      	str	r2, [sp, #4]
    870a:	f002 fb77 	bl	adfc <bt_conn_lookup_handle>
		if (!conn) {
    870e:	9a01      	ldr	r2, [sp, #4]
    8710:	4682      	mov	sl, r0
    8712:	b990      	cbnz	r0, 873a <hci_num_completed_packets+0x72>
	__asm__ volatile(
    8714:	f382 8811 	msr	BASEPRI, r2
    8718:	f3bf 8f6f 	isb	sy
			BT_ERR("No connection for handle %u", handle);
    871c:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
    8720:	f043 0301 	orr.w	r3, r3, #1
    8724:	f363 0707 	bfi	r7, r3, #0, #8
    8728:	f364 178f 	bfi	r7, r4, #6, #10
    872c:	463a      	mov	r2, r7
    872e:	4659      	mov	r1, fp
    8730:	4838      	ldr	r0, [pc, #224]	; (8814 <hci_num_completed_packets+0x14c>)
    8732:	f018 fc8f 	bl	21054 <log_1>
	for (i = 0; i < evt->num_handles; i++) {
    8736:	3501      	adds	r5, #1
    8738:	e7d0      	b.n	86dc <hci_num_completed_packets+0x14>
    873a:	f382 8811 	msr	BASEPRI, r2
    873e:	f3bf 8f6f 	isb	sy
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    8742:	f100 0b28 	add.w	fp, r0, #40	; 0x28
		while (count--) {
    8746:	b3b6      	cbz	r6, 87b6 <hci_num_completed_packets+0xee>
	__asm__ volatile(
    8748:	f04f 0220 	mov.w	r2, #32
    874c:	f3ef 8111 	mrs	r1, BASEPRI
    8750:	f382 8811 	msr	BASEPRI, r2
    8754:	f3bf 8f6f 	isb	sy
			if (conn->pending_no_cb) {
    8758:	f8da 201c 	ldr.w	r2, [sl, #28]
    875c:	b172      	cbz	r2, 877c <hci_num_completed_packets+0xb4>
				conn->pending_no_cb--;
    875e:	3a01      	subs	r2, #1
    8760:	f8ca 201c 	str.w	r2, [sl, #28]
	__asm__ volatile(
    8764:	f381 8811 	msr	BASEPRI, r1
    8768:	f3bf 8f6f 	isb	sy
			k_sem_give(bt_conn_get_pkts(conn));
    876c:	4650      	mov	r0, sl
    876e:	f002 f83f 	bl	a7f0 <bt_conn_get_pkts>
    8772:	3e01      	subs	r6, #1
    8774:	f016 fb02 	bl	1ed7c <z_impl_k_sem_give>
    8778:	b2b6      	uxth	r6, r6
    877a:	e7e4      	b.n	8746 <hci_num_completed_packets+0x7e>
Z_GENLIST_IS_EMPTY(slist)
    877c:	f8da 2014 	ldr.w	r2, [sl, #20]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    8780:	b142      	cbz	r2, 8794 <hci_num_completed_packets+0xcc>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    8782:	f8da 0018 	ldr.w	r0, [sl, #24]
    8786:	6813      	ldr	r3, [r2, #0]
	list->head = node;
    8788:	f8ca 3014 	str.w	r3, [sl, #20]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    878c:	4282      	cmp	r2, r0
	list->tail = node;
    878e:	bf08      	it	eq
    8790:	f8ca 3018 	streq.w	r3, [sl, #24]
    8794:	f381 8811 	msr	BASEPRI, r1
    8798:	f3bf 8f6f 	isb	sy
			if (!node) {
    879c:	b97a      	cbnz	r2, 87be <hci_num_completed_packets+0xf6>
				BT_ERR("packets count mismatch");
    879e:	f028 023f 	bic.w	r2, r8, #63	; 0x3f
    87a2:	f042 0201 	orr.w	r2, r2, #1
    87a6:	f362 0807 	bfi	r8, r2, #0, #8
    87aa:	f364 188f 	bfi	r8, r4, #6, #10
    87ae:	4641      	mov	r1, r8
    87b0:	4819      	ldr	r0, [pc, #100]	; (8818 <hci_num_completed_packets+0x150>)
    87b2:	f018 fc42 	bl	2103a <log_0>
		bt_conn_unref(conn);
    87b6:	4650      	mov	r0, sl
    87b8:	f019 ffb1 	bl	2271e <bt_conn_unref>
    87bc:	e7bb      	b.n	8736 <hci_num_completed_packets+0x6e>
	__asm__ volatile(
    87be:	f04f 0120 	mov.w	r1, #32
    87c2:	f3ef 8011 	mrs	r0, BASEPRI
    87c6:	f381 8811 	msr	BASEPRI, r1
    87ca:	f3bf 8f6f 	isb	sy
			tx->pending_no_cb = 0U;
    87ce:	2300      	movs	r3, #0
			conn->pending_no_cb = tx->pending_no_cb;
    87d0:	68d1      	ldr	r1, [r2, #12]
    87d2:	f8ca 101c 	str.w	r1, [sl, #28]
	parent->next = child;
    87d6:	6013      	str	r3, [r2, #0]
Z_GENLIST_APPEND(slist, snode)
    87d8:	f8da 1024 	ldr.w	r1, [sl, #36]	; 0x24
			tx->pending_no_cb = 0U;
    87dc:	60d3      	str	r3, [r2, #12]
    87de:	b989      	cbnz	r1, 8804 <hci_num_completed_packets+0x13c>
	list->head = node;
    87e0:	e9ca 2208 	strd	r2, r2, [sl, #32]
	__asm__ volatile(
    87e4:	f380 8811 	msr	BASEPRI, r0
    87e8:	f3bf 8f6f 	isb	sy
    87ec:	2101      	movs	r1, #1
    87ee:	f10a 0030 	add.w	r0, sl, #48	; 0x30
    87f2:	f019 fdfa 	bl	223ea <atomic_or>
    87f6:	07c3      	lsls	r3, r0, #31
    87f8:	d4b8      	bmi.n	876c <hci_num_completed_packets+0xa4>
		k_queue_append(&work_q->queue, work);
    87fa:	4659      	mov	r1, fp
    87fc:	4807      	ldr	r0, [pc, #28]	; (881c <hci_num_completed_packets+0x154>)
    87fe:	f01f f982 	bl	27b06 <k_queue_append>
    8802:	e7b3      	b.n	876c <hci_num_completed_packets+0xa4>
	parent->next = child;
    8804:	600a      	str	r2, [r1, #0]
	list->tail = node;
    8806:	f8ca 2024 	str.w	r2, [sl, #36]	; 0x24
    880a:	e7eb      	b.n	87e4 <hci_num_completed_packets+0x11c>
    880c:	00028540 	.word	0x00028540
    8810:	00028610 	.word	0x00028610
    8814:	00063295 	.word	0x00063295
    8818:	000632b1 	.word	0x000632b1
    881c:	20006090 	.word	0x20006090

00008820 <hci_cmd_status>:
{
    8820:	b538      	push	{r3, r4, r5, lr}
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    8822:	2104      	movs	r1, #4
{
    8824:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    8826:	3008      	adds	r0, #8
    8828:	f01c fb08 	bl	24e3c <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
    882c:	7845      	ldrb	r5, [r0, #1]
	hci_cmd_done(opcode, evt->status, buf);
    882e:	7801      	ldrb	r1, [r0, #0]
    8830:	8840      	ldrh	r0, [r0, #2]
    8832:	4622      	mov	r2, r4
    8834:	f7ff fdea 	bl	840c <hci_cmd_done>
	if (ncmd) {
    8838:	b125      	cbz	r5, 8844 <hci_cmd_status+0x24>
    883a:	4803      	ldr	r0, [pc, #12]	; (8848 <hci_cmd_status+0x28>)
}
    883c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    8840:	f016 ba9c 	b.w	1ed7c <z_impl_k_sem_give>
    8844:	bd38      	pop	{r3, r4, r5, pc}
    8846:	bf00      	nop
    8848:	2000e580 	.word	0x2000e580

0000884c <hci_cmd_complete>:
{
    884c:	b538      	push	{r3, r4, r5, lr}
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    884e:	2103      	movs	r1, #3
{
    8850:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    8852:	3008      	adds	r0, #8
    8854:	f01c faf2 	bl	24e3c <net_buf_simple_pull_mem>
	status = buf->data[0];
    8858:	68a3      	ldr	r3, [r4, #8]
	ncmd = evt->ncmd;
    885a:	7805      	ldrb	r5, [r0, #0]
	hci_cmd_done(opcode, status, buf);
    885c:	7819      	ldrb	r1, [r3, #0]
    885e:	f8b0 0001 	ldrh.w	r0, [r0, #1]
    8862:	4622      	mov	r2, r4
    8864:	f7ff fdd2 	bl	840c <hci_cmd_done>
	if (ncmd) {
    8868:	b125      	cbz	r5, 8874 <hci_cmd_complete+0x28>
    886a:	4803      	ldr	r0, [pc, #12]	; (8878 <hci_cmd_complete+0x2c>)
}
    886c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    8870:	f016 ba84 	b.w	1ed7c <z_impl_k_sem_give>
    8874:	bd38      	pop	{r3, r4, r5, pc}
    8876:	bf00      	nop
    8878:	2000e580 	.word	0x2000e580

0000887c <bt_hci_cmd_create>:
{
    887c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8880:	4681      	mov	r9, r0
    8882:	468a      	mov	sl, r1
	buf = net_buf_alloc(&hci_cmd_pool, K_FOREVER);
    8884:	4816      	ldr	r0, [pc, #88]	; (88e0 <bt_hci_cmd_create+0x64>)
	cmd(buf)->opcode = opcode;
    8886:	4f17      	ldr	r7, [pc, #92]	; (88e4 <bt_hci_cmd_create+0x68>)
	buf = net_buf_alloc(&hci_cmd_pool, K_FOREVER);
    8888:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    888c:	f01c fa70 	bl	24d70 <net_buf_alloc_fixed>
    8890:	4604      	mov	r4, r0
	net_buf_reserve(buf, BT_BUF_RESERVE);
    8892:	f100 0808 	add.w	r8, r0, #8
    8896:	2100      	movs	r1, #0
	*(u8_t *)net_buf_user_data(buf) = type;
    8898:	2600      	movs	r6, #0
    889a:	4640      	mov	r0, r8
    889c:	f01c fa87 	bl	24dae <net_buf_simple_reserve>
    88a0:	7526      	strb	r6, [r4, #20]
	cmd(buf)->opcode = opcode;
    88a2:	4620      	mov	r0, r4
    88a4:	f010 fb3a 	bl	18f1c <net_buf_id>
    88a8:	250c      	movs	r5, #12
    88aa:	fb05 7000 	mla	r0, r5, r0, r7
    88ae:	f8a0 9002 	strh.w	r9, [r0, #2]
	cmd(buf)->sync = NULL;
    88b2:	4620      	mov	r0, r4
    88b4:	f010 fb32 	bl	18f1c <net_buf_id>
    88b8:	fb05 7000 	mla	r0, r5, r0, r7
    88bc:	6086      	str	r6, [r0, #8]
	cmd(buf)->state = NULL;
    88be:	4620      	mov	r0, r4
    88c0:	f010 fb2c 	bl	18f1c <net_buf_id>
    88c4:	fb05 7000 	mla	r0, r5, r0, r7
	hdr = net_buf_add(buf, sizeof(*hdr));
    88c8:	2103      	movs	r1, #3
	cmd(buf)->state = NULL;
    88ca:	6046      	str	r6, [r0, #4]
	hdr = net_buf_add(buf, sizeof(*hdr));
    88cc:	4640      	mov	r0, r8
    88ce:	f01c fa83 	bl	24dd8 <net_buf_simple_add>
	hdr->param_len = param_len;
    88d2:	f880 a002 	strb.w	sl, [r0, #2]
	hdr->opcode = sys_cpu_to_le16(opcode);
    88d6:	f8a0 9000 	strh.w	r9, [r0]
}
    88da:	4620      	mov	r0, r4
    88dc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    88e0:	2000f098 	.word	0x2000f098
    88e4:	20000310 	.word	0x20000310

000088e8 <bt_hci_cmd_send>:
{
    88e8:	b538      	push	{r3, r4, r5, lr}
    88ea:	4604      	mov	r4, r0
	if (!buf) {
    88ec:	460d      	mov	r5, r1
    88ee:	b919      	cbnz	r1, 88f8 <bt_hci_cmd_send+0x10>
		buf = bt_hci_cmd_create(opcode, 0);
    88f0:	f7ff ffc4 	bl	887c <bt_hci_cmd_create>
		if (!buf) {
    88f4:	4605      	mov	r5, r0
    88f6:	b310      	cbz	r0, 893e <bt_hci_cmd_send+0x56>
	if (opcode == BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS) {
    88f8:	f640 4335 	movw	r3, #3125	; 0xc35
    88fc:	429c      	cmp	r4, r3
    88fe:	d118      	bne.n	8932 <bt_hci_cmd_send+0x4a>
		return bt_hci_ecc_send(buf);
    8900:	4628      	mov	r0, r5
    8902:	f7ff f89b 	bl	7a3c <bt_hci_ecc_send>
		if (err) {
    8906:	4604      	mov	r4, r0
    8908:	b188      	cbz	r0, 892e <bt_hci_cmd_send+0x46>
			BT_ERR("Unable to send to driver (err %d)", err);
    890a:	2301      	movs	r3, #1
    890c:	f04f 0200 	mov.w	r2, #0
    8910:	f363 0207 	bfi	r2, r3, #0, #8
    8914:	490b      	ldr	r1, [pc, #44]	; (8944 <bt_hci_cmd_send+0x5c>)
    8916:	4b0c      	ldr	r3, [pc, #48]	; (8948 <bt_hci_cmd_send+0x60>)
    8918:	1a5b      	subs	r3, r3, r1
    891a:	08db      	lsrs	r3, r3, #3
    891c:	4601      	mov	r1, r0
    891e:	f363 128f 	bfi	r2, r3, #6, #10
    8922:	480a      	ldr	r0, [pc, #40]	; (894c <bt_hci_cmd_send+0x64>)
    8924:	f018 fb96 	bl	21054 <log_1>
			net_buf_unref(buf);
    8928:	4628      	mov	r0, r5
    892a:	f010 fb97 	bl	1905c <net_buf_unref>
}
    892e:	4620      	mov	r0, r4
    8930:	bd38      	pop	{r3, r4, r5, pc}
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
    8932:	4629      	mov	r1, r5
    8934:	4806      	ldr	r0, [pc, #24]	; (8950 <bt_hci_cmd_send+0x68>)
    8936:	f01c fa3e 	bl	24db6 <net_buf_put>
	return 0;
    893a:	2400      	movs	r4, #0
    893c:	e7f7      	b.n	892e <bt_hci_cmd_send+0x46>
			return -ENOBUFS;
    893e:	f06f 0468 	mvn.w	r4, #104	; 0x68
    8942:	e7f4      	b.n	892e <bt_hci_cmd_send+0x46>
    8944:	00028540 	.word	0x00028540
    8948:	00028610 	.word	0x00028610
    894c:	00063336 	.word	0x00063336
    8950:	2000e59c 	.word	0x2000e59c

00008954 <le_ltk_request>:
{
    8954:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_hci_evt_le_ltk_request *evt = (void *)buf->data;
    8956:	6886      	ldr	r6, [r0, #8]
	handle = sys_le16_to_cpu(evt->handle);
    8958:	8837      	ldrh	r7, [r6, #0]
    895a:	b2bc      	uxth	r4, r7
{
    895c:	b087      	sub	sp, #28
	conn = bt_conn_lookup_handle(handle);
    895e:	4620      	mov	r0, r4
    8960:	f002 fa4c 	bl	adfc <bt_conn_lookup_handle>
	if (!conn) {
    8964:	4605      	mov	r5, r0
    8966:	b980      	cbnz	r0, 898a <le_ltk_request+0x36>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    8968:	2301      	movs	r3, #1
    896a:	f04f 0200 	mov.w	r2, #0
    896e:	f363 0207 	bfi	r2, r3, #0, #8
    8972:	492c      	ldr	r1, [pc, #176]	; (8a24 <le_ltk_request+0xd0>)
    8974:	4b2c      	ldr	r3, [pc, #176]	; (8a28 <le_ltk_request+0xd4>)
    8976:	482d      	ldr	r0, [pc, #180]	; (8a2c <le_ltk_request+0xd8>)
    8978:	1a5b      	subs	r3, r3, r1
    897a:	08db      	lsrs	r3, r3, #3
    897c:	f363 128f 	bfi	r2, r3, #6, #10
    8980:	4621      	mov	r1, r4
    8982:	f018 fb67 	bl	21054 <log_1>
}
    8986:	b007      	add	sp, #28
    8988:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (bt_smp_request_ltk(conn, evt->rand, evt->ediv, ltk)) {
    898a:	ac02      	add	r4, sp, #8
    898c:	f8d6 2002 	ldr.w	r2, [r6, #2]
    8990:	f8d6 3006 	ldr.w	r3, [r6, #6]
    8994:	9401      	str	r4, [sp, #4]
    8996:	8971      	ldrh	r1, [r6, #10]
    8998:	9100      	str	r1, [sp, #0]
    899a:	f01b fa16 	bl	23dca <bt_smp_request_ltk>
    899e:	b380      	cbz	r0, 8a02 <le_ltk_request+0xae>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_LTK_REQ_REPLY,
    89a0:	2112      	movs	r1, #18
    89a2:	f242 001a 	movw	r0, #8218	; 0x201a
    89a6:	f7ff ff69 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    89aa:	4606      	mov	r6, r0
    89ac:	b988      	cbnz	r0, 89d2 <le_ltk_request+0x7e>
		BT_ERR("Out of command buffers");
    89ae:	2301      	movs	r3, #1
    89b0:	f04f 0100 	mov.w	r1, #0
    89b4:	f363 0107 	bfi	r1, r3, #0, #8
    89b8:	4a1a      	ldr	r2, [pc, #104]	; (8a24 <le_ltk_request+0xd0>)
    89ba:	4b1b      	ldr	r3, [pc, #108]	; (8a28 <le_ltk_request+0xd4>)
    89bc:	481c      	ldr	r0, [pc, #112]	; (8a30 <le_ltk_request+0xdc>)
    89be:	1a9b      	subs	r3, r3, r2
    89c0:	08db      	lsrs	r3, r3, #3
    89c2:	f363 118f 	bfi	r1, r3, #6, #10
    89c6:	f018 fb38 	bl	2103a <log_0>
	bt_conn_unref(conn);
    89ca:	4628      	mov	r0, r5
    89cc:	f019 fea7 	bl	2271e <bt_conn_unref>
    89d0:	e7d9      	b.n	8986 <le_ltk_request+0x32>
	cp = net_buf_add(buf, sizeof(*cp));
    89d2:	2112      	movs	r1, #18
    89d4:	3008      	adds	r0, #8
    89d6:	f01c f9ff 	bl	24dd8 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(handle);
    89da:	4603      	mov	r3, r0
    89dc:	4622      	mov	r2, r4
    89de:	f823 7b02 	strh.w	r7, [r3], #2
    89e2:	af06      	add	r7, sp, #24
    89e4:	4614      	mov	r4, r2
    89e6:	cc03      	ldmia	r4!, {r0, r1}
    89e8:	42bc      	cmp	r4, r7
    89ea:	6018      	str	r0, [r3, #0]
    89ec:	6059      	str	r1, [r3, #4]
    89ee:	4622      	mov	r2, r4
    89f0:	f103 0308 	add.w	r3, r3, #8
    89f4:	d1f6      	bne.n	89e4 <le_ltk_request+0x90>
	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_REPLY, buf);
    89f6:	4631      	mov	r1, r6
    89f8:	f242 001a 	movw	r0, #8218	; 0x201a
	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_NEG_REPLY, buf);
    89fc:	f7ff ff74 	bl	88e8 <bt_hci_cmd_send>
    8a00:	e7e3      	b.n	89ca <le_ltk_request+0x76>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_LTK_REQ_NEG_REPLY, sizeof(*cp));
    8a02:	2102      	movs	r1, #2
    8a04:	f242 001b 	movw	r0, #8219	; 0x201b
    8a08:	f7ff ff38 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    8a0c:	4604      	mov	r4, r0
    8a0e:	2800      	cmp	r0, #0
    8a10:	d0cd      	beq.n	89ae <le_ltk_request+0x5a>
	cp = net_buf_add(buf, sizeof(*cp));
    8a12:	2102      	movs	r1, #2
    8a14:	3008      	adds	r0, #8
    8a16:	f01c f9df 	bl	24dd8 <net_buf_simple_add>
	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_NEG_REPLY, buf);
    8a1a:	4621      	mov	r1, r4
	cp->handle = sys_cpu_to_le16(handle);
    8a1c:	8007      	strh	r7, [r0, #0]
	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_NEG_REPLY, buf);
    8a1e:	f242 001b 	movw	r0, #8219	; 0x201b
    8a22:	e7eb      	b.n	89fc <le_ltk_request+0xa8>
    8a24:	00028540 	.word	0x00028540
    8a28:	00028610 	.word	0x00028610
    8a2c:	000633b7 	.word	0x000633b7
    8a30:	000633db 	.word	0x000633db

00008a34 <le_conn_param_neg_reply>:
{
    8a34:	b570      	push	{r4, r5, r6, lr}
    8a36:	4606      	mov	r6, r0
    8a38:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY,
    8a3a:	f242 0021 	movw	r0, #8225	; 0x2021
    8a3e:	2103      	movs	r1, #3
    8a40:	f7ff ff1c 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    8a44:	4604      	mov	r4, r0
    8a46:	b978      	cbnz	r0, 8a68 <le_conn_param_neg_reply+0x34>
		BT_ERR("Unable to allocate buffer");
    8a48:	2301      	movs	r3, #1
    8a4a:	f04f 0100 	mov.w	r1, #0
    8a4e:	f363 0107 	bfi	r1, r3, #0, #8
    8a52:	4a0c      	ldr	r2, [pc, #48]	; (8a84 <le_conn_param_neg_reply+0x50>)
    8a54:	4b0c      	ldr	r3, [pc, #48]	; (8a88 <le_conn_param_neg_reply+0x54>)
    8a56:	480d      	ldr	r0, [pc, #52]	; (8a8c <le_conn_param_neg_reply+0x58>)
    8a58:	1a9b      	subs	r3, r3, r2
    8a5a:	08db      	lsrs	r3, r3, #3
    8a5c:	f363 118f 	bfi	r1, r3, #6, #10
}
    8a60:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_ERR("Unable to allocate buffer");
    8a64:	f018 bae9 	b.w	2103a <log_0>
	cp = net_buf_add(buf, sizeof(*cp));
    8a68:	2103      	movs	r1, #3
    8a6a:	3008      	adds	r0, #8
    8a6c:	f01c f9b4 	bl	24dd8 <net_buf_simple_add>
	cp->reason = sys_cpu_to_le16(reason);
    8a70:	7085      	strb	r5, [r0, #2]
	cp->handle = sys_cpu_to_le16(handle);
    8a72:	8006      	strh	r6, [r0, #0]
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
    8a74:	4621      	mov	r1, r4
    8a76:	f242 0021 	movw	r0, #8225	; 0x2021
}
    8a7a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
    8a7e:	f7ff bf33 	b.w	88e8 <bt_hci_cmd_send>
    8a82:	bf00      	nop
    8a84:	00028540 	.word	0x00028540
    8a88:	00028610 	.word	0x00028610
    8a8c:	0006339d 	.word	0x0006339d

00008a90 <le_conn_param_req>:
{
    8a90:	b573      	push	{r0, r1, r4, r5, r6, lr}
	struct bt_hci_evt_le_conn_param_req *evt = (void *)buf->data;
    8a92:	6883      	ldr	r3, [r0, #8]
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
    8a94:	78d9      	ldrb	r1, [r3, #3]
    8a96:	789a      	ldrb	r2, [r3, #2]
	handle = sys_le16_to_cpu(evt->handle);
    8a98:	881d      	ldrh	r5, [r3, #0]
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
    8a9a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    8a9e:	f8ad 2000 	strh.w	r2, [sp]
	param.interval_max = sys_le16_to_cpu(evt->interval_max);
    8aa2:	7959      	ldrb	r1, [r3, #5]
    8aa4:	791a      	ldrb	r2, [r3, #4]
    8aa6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    8aaa:	f8ad 2002 	strh.w	r2, [sp, #2]
	param.latency = sys_le16_to_cpu(evt->latency);
    8aae:	799a      	ldrb	r2, [r3, #6]
    8ab0:	79d9      	ldrb	r1, [r3, #7]
    8ab2:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    8ab6:	f8ad 2004 	strh.w	r2, [sp, #4]
	param.timeout = sys_le16_to_cpu(evt->timeout);
    8aba:	7a1a      	ldrb	r2, [r3, #8]
    8abc:	7a5b      	ldrb	r3, [r3, #9]
	handle = sys_le16_to_cpu(evt->handle);
    8abe:	b2ac      	uxth	r4, r5
	param.timeout = sys_le16_to_cpu(evt->timeout);
    8ac0:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
	conn = bt_conn_lookup_handle(handle);
    8ac4:	4620      	mov	r0, r4
	param.timeout = sys_le16_to_cpu(evt->timeout);
    8ac6:	f8ad 3006 	strh.w	r3, [sp, #6]
	conn = bt_conn_lookup_handle(handle);
    8aca:	f002 f997 	bl	adfc <bt_conn_lookup_handle>
	if (!conn) {
    8ace:	4606      	mov	r6, r0
    8ad0:	b9a0      	cbnz	r0, 8afc <le_conn_param_req+0x6c>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    8ad2:	2301      	movs	r3, #1
    8ad4:	f04f 0200 	mov.w	r2, #0
    8ad8:	f363 0207 	bfi	r2, r3, #0, #8
    8adc:	491f      	ldr	r1, [pc, #124]	; (8b5c <le_conn_param_req+0xcc>)
    8ade:	4b20      	ldr	r3, [pc, #128]	; (8b60 <le_conn_param_req+0xd0>)
    8ae0:	4820      	ldr	r0, [pc, #128]	; (8b64 <le_conn_param_req+0xd4>)
    8ae2:	1a5b      	subs	r3, r3, r1
    8ae4:	08db      	lsrs	r3, r3, #3
    8ae6:	4621      	mov	r1, r4
    8ae8:	f363 128f 	bfi	r2, r3, #6, #10
    8aec:	f018 fab2 	bl	21054 <log_1>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_UNKNOWN_CONN_ID);
    8af0:	2102      	movs	r1, #2
    8af2:	4620      	mov	r0, r4
    8af4:	f7ff ff9e 	bl	8a34 <le_conn_param_neg_reply>
}
    8af8:	b002      	add	sp, #8
    8afa:	bd70      	pop	{r4, r5, r6, pc}
	if (!le_param_req(conn, &param)) {
    8afc:	4669      	mov	r1, sp
    8afe:	f001 feaf 	bl	a860 <le_param_req>
    8b02:	b938      	cbnz	r0, 8b14 <le_conn_param_req+0x84>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_INVALID_LL_PARAM);
    8b04:	211e      	movs	r1, #30
    8b06:	4620      	mov	r0, r4
    8b08:	f7ff ff94 	bl	8a34 <le_conn_param_neg_reply>
	bt_conn_unref(conn);
    8b0c:	4630      	mov	r0, r6
    8b0e:	f019 fe06 	bl	2271e <bt_conn_unref>
    8b12:	e7f1      	b.n	8af8 <le_conn_param_req+0x68>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, sizeof(*cp));
    8b14:	210e      	movs	r1, #14
    8b16:	f242 0020 	movw	r0, #8224	; 0x2020
    8b1a:	f7ff feaf 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    8b1e:	4604      	mov	r4, r0
    8b20:	2800      	cmp	r0, #0
    8b22:	d0f3      	beq.n	8b0c <le_conn_param_req+0x7c>
	cp = net_buf_add(buf, sizeof(*cp));
    8b24:	210e      	movs	r1, #14
    8b26:	3008      	adds	r0, #8
    8b28:	f01c f956 	bl	24dd8 <net_buf_simple_add>
__ssp_bos_icheck3(memset, void *, int)
    8b2c:	2300      	movs	r3, #0
    8b2e:	6043      	str	r3, [r0, #4]
    8b30:	6083      	str	r3, [r0, #8]
    8b32:	8183      	strh	r3, [r0, #12]
	cp->interval_min = sys_cpu_to_le16(param->interval_min);
    8b34:	f8bd 3000 	ldrh.w	r3, [sp]
    8b38:	8043      	strh	r3, [r0, #2]
	cp->interval_max = sys_cpu_to_le16(param->interval_max);
    8b3a:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    8b3e:	8083      	strh	r3, [r0, #4]
	cp->latency = sys_cpu_to_le16(param->latency);
    8b40:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    8b44:	80c3      	strh	r3, [r0, #6]
	cp->timeout = sys_cpu_to_le16(param->timeout);
    8b46:	f8bd 3006 	ldrh.w	r3, [sp, #6]
	cp->handle = sys_cpu_to_le16(handle);
    8b4a:	8005      	strh	r5, [r0, #0]
	cp->timeout = sys_cpu_to_le16(param->timeout);
    8b4c:	8103      	strh	r3, [r0, #8]
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
    8b4e:	4621      	mov	r1, r4
    8b50:	f242 0020 	movw	r0, #8224	; 0x2020
    8b54:	f7ff fec8 	bl	88e8 <bt_hci_cmd_send>
    8b58:	e7d8      	b.n	8b0c <le_conn_param_req+0x7c>
    8b5a:	bf00      	nop
    8b5c:	00028540 	.word	0x00028540
    8b60:	00028610 	.word	0x00028610
    8b64:	000633b7 	.word	0x000633b7

00008b68 <bt_hci_cmd_send_sync>:
{
    8b68:	b5f0      	push	{r4, r5, r6, r7, lr}
    8b6a:	4615      	mov	r5, r2
    8b6c:	b087      	sub	sp, #28
	if (!buf) {
    8b6e:	460c      	mov	r4, r1
    8b70:	b919      	cbnz	r1, 8b7a <bt_hci_cmd_send_sync+0x12>
		buf = bt_hci_cmd_create(opcode, 0);
    8b72:	f7ff fe83 	bl	887c <bt_hci_cmd_create>
		if (!buf) {
    8b76:	4604      	mov	r4, r0
    8b78:	b3a8      	cbz	r0, 8be6 <bt_hci_cmd_send_sync+0x7e>
	z_impl_k_sem_init(sem, initial_count, limit);
    8b7a:	2201      	movs	r2, #1
    8b7c:	2100      	movs	r1, #0
    8b7e:	4668      	mov	r0, sp
    8b80:	f01f f943 	bl	27e0a <z_impl_k_sem_init>
	cmd(buf)->sync = &sync_sem;
    8b84:	4620      	mov	r0, r4
    8b86:	f010 f9c9 	bl	18f1c <net_buf_id>
    8b8a:	4f18      	ldr	r7, [pc, #96]	; (8bec <bt_hci_cmd_send_sync+0x84>)
    8b8c:	260c      	movs	r6, #12
    8b8e:	fb06 7000 	mla	r0, r6, r0, r7
    8b92:	f8c0 d008 	str.w	sp, [r0, #8]
	net_buf_ref(buf);
    8b96:	4620      	mov	r0, r4
    8b98:	f01c f91a 	bl	24dd0 <net_buf_ref>
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
    8b9c:	4621      	mov	r1, r4
    8b9e:	4814      	ldr	r0, [pc, #80]	; (8bf0 <bt_hci_cmd_send_sync+0x88>)
    8ba0:	f01c f909 	bl	24db6 <net_buf_put>
	return z_impl_k_sem_take(sem, timeout);
    8ba4:	f242 7110 	movw	r1, #10000	; 0x2710
    8ba8:	4668      	mov	r0, sp
    8baa:	f016 f913 	bl	1edd4 <z_impl_k_sem_take>
	if (cmd(buf)->status) {
    8bae:	4620      	mov	r0, r4
    8bb0:	f010 f9b4 	bl	18f1c <net_buf_id>
    8bb4:	4370      	muls	r0, r6
    8bb6:	5c3b      	ldrb	r3, [r7, r0]
    8bb8:	b173      	cbz	r3, 8bd8 <bt_hci_cmd_send_sync+0x70>
		switch (cmd(buf)->status) {
    8bba:	4620      	mov	r0, r4
    8bbc:	f010 f9ae 	bl	18f1c <net_buf_id>
    8bc0:	4370      	muls	r0, r6
    8bc2:	5c3b      	ldrb	r3, [r7, r0]
    8bc4:	2b09      	cmp	r3, #9
			err = -EIO;
    8bc6:	bf0c      	ite	eq
    8bc8:	f06f 056e 	mvneq.w	r5, #110	; 0x6e
    8bcc:	f06f 0504 	mvnne.w	r5, #4
			net_buf_unref(buf);
    8bd0:	4620      	mov	r0, r4
    8bd2:	f010 fa43 	bl	1905c <net_buf_unref>
    8bd6:	e003      	b.n	8be0 <bt_hci_cmd_send_sync+0x78>
		if (rsp) {
    8bd8:	2d00      	cmp	r5, #0
    8bda:	d0f9      	beq.n	8bd0 <bt_hci_cmd_send_sync+0x68>
			*rsp = buf;
    8bdc:	602c      	str	r4, [r5, #0]
		err = 0;
    8bde:	461d      	mov	r5, r3
}
    8be0:	4628      	mov	r0, r5
    8be2:	b007      	add	sp, #28
    8be4:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return -ENOBUFS;
    8be6:	f06f 0568 	mvn.w	r5, #104	; 0x68
    8bea:	e7f9      	b.n	8be0 <bt_hci_cmd_send_sync+0x78>
    8bec:	20000310 	.word	0x20000310
    8bf0:	2000e59c 	.word	0x2000e59c

00008bf4 <set_advertise_enable>:
{
    8bf4:	b530      	push	{r4, r5, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
    8bf6:	2101      	movs	r1, #1
{
    8bf8:	b085      	sub	sp, #20
    8bfa:	4605      	mov	r5, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
    8bfc:	f242 000a 	movw	r0, #8202	; 0x200a
    8c00:	f7ff fe3c 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    8c04:	4604      	mov	r4, r0
    8c06:	b1e8      	cbz	r0, 8c44 <set_advertise_enable+0x50>
	if (enable) {
    8c08:	3008      	adds	r0, #8
    8c0a:	b1cd      	cbz	r5, 8c40 <set_advertise_enable+0x4c>
		net_buf_add_u8(buf, BT_HCI_LE_ADV_ENABLE);
    8c0c:	2101      	movs	r1, #1
		net_buf_add_u8(buf, BT_HCI_LE_ADV_DISABLE);
    8c0e:	f01c f8f3 	bl	24df8 <net_buf_simple_add_u8>
	state->target = target;
    8c12:	4b0e      	ldr	r3, [pc, #56]	; (8c4c <set_advertise_enable+0x58>)
    8c14:	9301      	str	r3, [sp, #4]
	cmd(buf)->state = &state;
    8c16:	4620      	mov	r0, r4
	state->bit = bit;
    8c18:	2305      	movs	r3, #5
    8c1a:	9302      	str	r3, [sp, #8]
	state->val = val;
    8c1c:	f88d 500c 	strb.w	r5, [sp, #12]
	cmd(buf)->state = &state;
    8c20:	f010 f97c 	bl	18f1c <net_buf_id>
    8c24:	4a0a      	ldr	r2, [pc, #40]	; (8c50 <set_advertise_enable+0x5c>)
    8c26:	230c      	movs	r3, #12
    8c28:	fb03 2000 	mla	r0, r3, r0, r2
    8c2c:	ab01      	add	r3, sp, #4
    8c2e:	6043      	str	r3, [r0, #4]
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
    8c30:	2200      	movs	r2, #0
    8c32:	4621      	mov	r1, r4
    8c34:	f242 000a 	movw	r0, #8202	; 0x200a
    8c38:	f7ff ff96 	bl	8b68 <bt_hci_cmd_send_sync>
}
    8c3c:	b005      	add	sp, #20
    8c3e:	bd30      	pop	{r4, r5, pc}
		net_buf_add_u8(buf, BT_HCI_LE_ADV_DISABLE);
    8c40:	4629      	mov	r1, r5
    8c42:	e7e4      	b.n	8c0e <set_advertise_enable+0x1a>
		return -ENOBUFS;
    8c44:	f06f 0068 	mvn.w	r0, #104	; 0x68
    8c48:	e7f8      	b.n	8c3c <set_advertise_enable+0x48>
    8c4a:	bf00      	nop
    8c4c:	2000e548 	.word	0x2000e548
    8c50:	20000310 	.word	0x20000310

00008c54 <set_random_address>:
{
    8c54:	b570      	push	{r4, r5, r6, lr}
	return memcmp(a, b, sizeof(*a));
    8c56:	4c14      	ldr	r4, [pc, #80]	; (8ca8 <set_random_address+0x54>)
    8c58:	2206      	movs	r2, #6
    8c5a:	f104 010a 	add.w	r1, r4, #10
    8c5e:	4606      	mov	r6, r0
    8c60:	f7f8 ffb6 	bl	1bd0 <memcmp>
	if (!bt_addr_cmp(addr, &bt_dev.random_addr.a)) {
    8c64:	4602      	mov	r2, r0
    8c66:	b1d0      	cbz	r0, 8c9e <set_random_address+0x4a>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, sizeof(*addr));
    8c68:	2106      	movs	r1, #6
    8c6a:	f242 0005 	movw	r0, #8197	; 0x2005
    8c6e:	f7ff fe05 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    8c72:	4605      	mov	r5, r0
    8c74:	b1a8      	cbz	r0, 8ca2 <set_random_address+0x4e>
	net_buf_add_mem(buf, addr, sizeof(*addr));
    8c76:	2206      	movs	r2, #6
    8c78:	4631      	mov	r1, r6
    8c7a:	3008      	adds	r0, #8
    8c7c:	f01c f8b2 	bl	24de4 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
    8c80:	2200      	movs	r2, #0
    8c82:	4629      	mov	r1, r5
    8c84:	f242 0005 	movw	r0, #8197	; 0x2005
    8c88:	f7ff ff6e 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    8c8c:	4602      	mov	r2, r0
    8c8e:	b930      	cbnz	r0, 8c9e <set_random_address+0x4a>
	bt_addr_copy(&bt_dev.random_addr.a, addr);
    8c90:	4631      	mov	r1, r6
    8c92:	f104 000a 	add.w	r0, r4, #10
    8c96:	f019 fbf8 	bl	2248a <bt_addr_copy>
	bt_dev.random_addr.type = BT_ADDR_LE_RANDOM;
    8c9a:	2301      	movs	r3, #1
    8c9c:	7263      	strb	r3, [r4, #9]
}
    8c9e:	4610      	mov	r0, r2
    8ca0:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOBUFS;
    8ca2:	f06f 0268 	mvn.w	r2, #104	; 0x68
    8ca6:	e7fa      	b.n	8c9e <set_random_address+0x4a>
    8ca8:	2000e4d8 	.word	0x2000e4d8

00008cac <le_set_private_addr>:
{
    8cac:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (atomic_test_bit(bt_dev.flags, BT_DEV_RPA_VALID)) {
    8cae:	4d12      	ldr	r5, [pc, #72]	; (8cf8 <le_set_private_addr+0x4c>)
{
    8cb0:	4603      	mov	r3, r0
	if (atomic_test_bit(bt_dev.flags, BT_DEV_RPA_VALID)) {
    8cb2:	210f      	movs	r1, #15
    8cb4:	f105 0070 	add.w	r0, r5, #112	; 0x70
    8cb8:	f019 fbf3 	bl	224a2 <atomic_test_bit>
    8cbc:	b9d0      	cbnz	r0, 8cf4 <le_set_private_addr+0x48>
	err = bt_rpa_create(bt_dev.irk[id], &rpa);
    8cbe:	eb05 1003 	add.w	r0, r5, r3, lsl #4
    8cc2:	4669      	mov	r1, sp
    8cc4:	30dc      	adds	r0, #220	; 0xdc
    8cc6:	f019 fabb 	bl	22240 <bt_rpa_create>
	if (!err) {
    8cca:	4604      	mov	r4, r0
    8ccc:	b950      	cbnz	r0, 8ce4 <le_set_private_addr+0x38>
		err = set_random_address(&rpa);
    8cce:	4668      	mov	r0, sp
    8cd0:	f7ff ffc0 	bl	8c54 <set_random_address>
		if (!err) {
    8cd4:	4604      	mov	r4, r0
    8cd6:	b928      	cbnz	r0, 8ce4 <le_set_private_addr+0x38>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    8cd8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    8cdc:	f105 0070 	add.w	r0, r5, #112	; 0x70
    8ce0:	f019 fb83 	bl	223ea <atomic_or>
 * @req K-DWORK-001
 */
static inline int k_delayed_work_submit(struct k_delayed_work *work,
					s32_t delay)
{
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    8ce4:	4a05      	ldr	r2, [pc, #20]	; (8cfc <le_set_private_addr+0x50>)
    8ce6:	4906      	ldr	r1, [pc, #24]	; (8d00 <le_set_private_addr+0x54>)
    8ce8:	4806      	ldr	r0, [pc, #24]	; (8d04 <le_set_private_addr+0x58>)
    8cea:	f016 f9b9 	bl	1f060 <k_delayed_work_submit_to_queue>
}
    8cee:	4620      	mov	r0, r4
    8cf0:	b003      	add	sp, #12
    8cf2:	bd30      	pop	{r4, r5, pc}
		return 0;
    8cf4:	2400      	movs	r4, #0
    8cf6:	e7fa      	b.n	8cee <le_set_private_addr+0x42>
    8cf8:	2000e4d8 	.word	0x2000e4d8
    8cfc:	000dbba0 	.word	0x000dbba0
    8d00:	2000e5c4 	.word	0x2000e5c4
    8d04:	20006090 	.word	0x20006090

00008d08 <rpa_timeout>:
{
    8d08:	b510      	push	{r4, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    8d0a:	4c17      	ldr	r4, [pc, #92]	; (8d68 <rpa_timeout+0x60>)
    8d0c:	f46f 4100 	mvn.w	r1, #32768	; 0x8000
    8d10:	f104 0070 	add.w	r0, r4, #112	; 0x70
    8d14:	f019 fb5a 	bl	223cc <atomic_and>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING)) {
    8d18:	2105      	movs	r1, #5
    8d1a:	f104 0070 	add.w	r0, r4, #112	; 0x70
    8d1e:	f019 fbc0 	bl	224a2 <atomic_test_bit>
    8d22:	b1d8      	cbz	r0, 8d5c <rpa_timeout+0x54>
		set_advertise_enable(false);
    8d24:	2000      	movs	r0, #0
    8d26:	f7ff ff65 	bl	8bf4 <set_advertise_enable>
		err_adv = le_set_private_addr(bt_dev.adv_id);
    8d2a:	7a20      	ldrb	r0, [r4, #8]
    8d2c:	f7ff ffbe 	bl	8cac <le_set_private_addr>
    8d30:	4604      	mov	r4, r0
		set_advertise_enable(true);
    8d32:	2001      	movs	r0, #1
    8d34:	f7ff ff5e 	bl	8bf4 <set_advertise_enable>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_ACTIVE_SCAN)) {
    8d38:	210b      	movs	r1, #11
    8d3a:	480c      	ldr	r0, [pc, #48]	; (8d6c <rpa_timeout+0x64>)
    8d3c:	f019 fbb1 	bl	224a2 <atomic_test_bit>
    8d40:	b170      	cbz	r0, 8d60 <rpa_timeout+0x58>
		err_scan = le_set_private_addr(BT_ID_DEFAULT);
    8d42:	2000      	movs	r0, #0
    8d44:	f7ff ffb2 	bl	8cac <le_set_private_addr>
	if (err_adv || err_scan) {
    8d48:	ea54 0300 	orrs.w	r3, r4, r0
    8d4c:	d00a      	beq.n	8d64 <rpa_timeout+0x5c>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    8d4e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    8d52:	4806      	ldr	r0, [pc, #24]	; (8d6c <rpa_timeout+0x64>)
}
    8d54:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    8d58:	f019 bb47 	b.w	223ea <atomic_or>
	int err_adv = 0, err_scan = 0;
    8d5c:	4604      	mov	r4, r0
    8d5e:	e7eb      	b.n	8d38 <rpa_timeout+0x30>
	if (err_adv || err_scan) {
    8d60:	2c00      	cmp	r4, #0
    8d62:	d1f4      	bne.n	8d4e <rpa_timeout+0x46>
}
    8d64:	bd10      	pop	{r4, pc}
    8d66:	bf00      	nop
    8d68:	2000e4d8 	.word	0x2000e4d8
    8d6c:	2000e548 	.word	0x2000e548

00008d70 <hci_id_add>:
{
    8d70:	b570      	push	{r4, r5, r6, lr}
    8d72:	4606      	mov	r6, r0
    8d74:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_ADD_DEV_TO_RL, sizeof(*cp));
    8d76:	f242 0027 	movw	r0, #8231	; 0x2027
    8d7a:	2127      	movs	r1, #39	; 0x27
    8d7c:	f7ff fd7e 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    8d80:	4605      	mov	r5, r0
    8d82:	b338      	cbz	r0, 8dd4 <hci_id_add+0x64>
	cp = net_buf_add(buf, sizeof(*cp));
    8d84:	2127      	movs	r1, #39	; 0x27
    8d86:	3008      	adds	r0, #8
    8d88:	f01c f826 	bl	24dd8 <net_buf_simple_add>
	bt_addr_le_copy(&cp->peer_id_addr, addr);
    8d8c:	4631      	mov	r1, r6
	cp = net_buf_add(buf, sizeof(*cp));
    8d8e:	4602      	mov	r2, r0
	bt_addr_le_copy(&cp->peer_id_addr, addr);
    8d90:	f019 fb80 	bl	22494 <bt_addr_le_copy>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    8d94:	4621      	mov	r1, r4
    8d96:	1dc3      	adds	r3, r0, #7
    8d98:	f104 0010 	add.w	r0, r4, #16
    8d9c:	f851 4b04 	ldr.w	r4, [r1], #4
    8da0:	f843 4b04 	str.w	r4, [r3], #4
    8da4:	4281      	cmp	r1, r0
    8da6:	d1f9      	bne.n	8d9c <hci_id_add+0x2c>
    8da8:	4c0c      	ldr	r4, [pc, #48]	; (8ddc <hci_id_add+0x6c>)
    8daa:	f102 0317 	add.w	r3, r2, #23
    8dae:	f104 0610 	add.w	r6, r4, #16
    8db2:	4622      	mov	r2, r4
    8db4:	ca03      	ldmia	r2!, {r0, r1}
    8db6:	42b2      	cmp	r2, r6
    8db8:	6018      	str	r0, [r3, #0]
    8dba:	6059      	str	r1, [r3, #4]
    8dbc:	4614      	mov	r4, r2
    8dbe:	f103 0308 	add.w	r3, r3, #8
    8dc2:	d1f6      	bne.n	8db2 <hci_id_add+0x42>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_ADD_DEV_TO_RL, buf, NULL);
    8dc4:	4629      	mov	r1, r5
    8dc6:	2200      	movs	r2, #0
    8dc8:	f242 0027 	movw	r0, #8231	; 0x2027
}
    8dcc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_ADD_DEV_TO_RL, buf, NULL);
    8dd0:	f7ff beca 	b.w	8b68 <bt_hci_cmd_send_sync>
}
    8dd4:	f06f 0068 	mvn.w	r0, #104	; 0x68
    8dd8:	bd70      	pop	{r4, r5, r6, pc}
    8dda:	bf00      	nop
    8ddc:	2000e5b4 	.word	0x2000e5b4

00008de0 <set_ad>:
{
    8de0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8de4:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
    8de6:	2120      	movs	r1, #32
{
    8de8:	4682      	mov	sl, r0
    8dea:	4691      	mov	r9, r2
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
    8dec:	f7ff fd46 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    8df0:	4607      	mov	r7, r0
    8df2:	2800      	cmp	r0, #0
    8df4:	d05a      	beq.n	8eac <set_ad+0xcc>
	set_data = net_buf_add(buf, sizeof(*set_data));
    8df6:	2120      	movs	r1, #32
    8df8:	3008      	adds	r0, #8
    8dfa:	f01b ffed 	bl	24dd8 <net_buf_simple_add>
__ssp_bos_icheck3(memset, void *, int)
    8dfe:	2220      	movs	r2, #32
    8e00:	2100      	movs	r1, #0
    8e02:	4605      	mov	r5, r0
    8e04:	f7f8 ff13 	bl	1c2e <memset>
    8e08:	eb04 09c9 	add.w	r9, r4, r9, lsl #3
	for (c = 0; c < ad_len; c++) {
    8e0c:	454c      	cmp	r4, r9
    8e0e:	d106      	bne.n	8e1e <set_ad+0x3e>
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
    8e10:	4639      	mov	r1, r7
    8e12:	4650      	mov	r0, sl
    8e14:	2200      	movs	r2, #0
}
    8e16:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
    8e1a:	f7ff bea5 	b.w	8b68 <bt_hci_cmd_send_sync>
		for (i = 0; i < ad[c].len; i++) {
    8e1e:	6826      	ldr	r6, [r4, #0]
    8e20:	f04f 0b00 	mov.w	fp, #0
    8e24:	6863      	ldr	r3, [r4, #4]
    8e26:	459b      	cmp	fp, r3
    8e28:	d301      	bcc.n	8e2e <set_ad+0x4e>
    8e2a:	3408      	adds	r4, #8
    8e2c:	e7ee      	b.n	8e0c <set_ad+0x2c>
			if (set_data->len + len + 2 > 31) {
    8e2e:	782b      	ldrb	r3, [r5, #0]
			int len = data[i].data_len;
    8e30:	7872      	ldrb	r2, [r6, #1]
			u8_t type = data[i].type;
    8e32:	7831      	ldrb	r1, [r6, #0]
			if (set_data->len + len + 2 > 31) {
    8e34:	1c98      	adds	r0, r3, #2
    8e36:	eb00 0c02 	add.w	ip, r0, r2
    8e3a:	f1bc 0f1f 	cmp.w	ip, #31
    8e3e:	dd1a      	ble.n	8e76 <set_ad+0x96>
				if (type != BT_DATA_NAME_COMPLETE || !len) {
    8e40:	2909      	cmp	r1, #9
				len = 31 - (set_data->len + 2);
    8e42:	f1c3 021d 	rsb	r2, r3, #29
				if (type != BT_DATA_NAME_COMPLETE || !len) {
    8e46:	d100      	bne.n	8e4a <set_ad+0x6a>
    8e48:	b9a2      	cbnz	r2, 8e74 <set_ad+0x94>
					net_buf_unref(buf);
    8e4a:	4638      	mov	r0, r7
    8e4c:	f010 f906 	bl	1905c <net_buf_unref>
					BT_ERR("Too big advertising data");
    8e50:	2301      	movs	r3, #1
    8e52:	f04f 0100 	mov.w	r1, #0
    8e56:	f363 0107 	bfi	r1, r3, #0, #8
    8e5a:	4a16      	ldr	r2, [pc, #88]	; (8eb4 <set_ad+0xd4>)
    8e5c:	4b16      	ldr	r3, [pc, #88]	; (8eb8 <set_ad+0xd8>)
    8e5e:	4817      	ldr	r0, [pc, #92]	; (8ebc <set_ad+0xdc>)
    8e60:	1a9b      	subs	r3, r3, r2
    8e62:	08db      	lsrs	r3, r3, #3
    8e64:	f363 118f 	bfi	r1, r3, #6, #10
    8e68:	f018 f8e7 	bl	2103a <log_0>
					return -EINVAL;
    8e6c:	f06f 0015 	mvn.w	r0, #21
}
    8e70:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				type = BT_DATA_NAME_SHORTENED;
    8e74:	2108      	movs	r1, #8
			set_data->data[set_data->len++] = len + 1;
    8e76:	eb05 0c03 	add.w	ip, r5, r3
    8e7a:	3301      	adds	r3, #1
    8e7c:	fa4f f882 	sxtb.w	r8, r2
			set_data->data[set_data->len++] = type;
    8e80:	fa55 f383 	uxtab	r3, r5, r3
			set_data->data[set_data->len++] = len + 1;
    8e84:	f108 0e01 	add.w	lr, r8, #1
			set_data->data[set_data->len++] = type;
    8e88:	b2c0      	uxtb	r0, r0
			set_data->data[set_data->len++] = len + 1;
    8e8a:	f88c e001 	strb.w	lr, [ip, #1]
			set_data->data[set_data->len++] = type;
    8e8e:	7028      	strb	r0, [r5, #0]
    8e90:	7059      	strb	r1, [r3, #1]
			memcpy(&set_data->data[set_data->len], data[i].data,
    8e92:	3001      	adds	r0, #1
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    8e94:	6871      	ldr	r1, [r6, #4]
    8e96:	4428      	add	r0, r5
    8e98:	f7f8 fea8 	bl	1bec <memcpy>
			set_data->len += len;
    8e9c:	782b      	ldrb	r3, [r5, #0]
    8e9e:	4498      	add	r8, r3
    8ea0:	f885 8000 	strb.w	r8, [r5]
		for (i = 0; i < ad[c].len; i++) {
    8ea4:	f10b 0b01 	add.w	fp, fp, #1
    8ea8:	3608      	adds	r6, #8
    8eaa:	e7bb      	b.n	8e24 <set_ad+0x44>
		return -ENOBUFS;
    8eac:	f06f 0068 	mvn.w	r0, #104	; 0x68
    8eb0:	e7de      	b.n	8e70 <set_ad+0x90>
    8eb2:	bf00      	nop
    8eb4:	00028540 	.word	0x00028540
    8eb8:	00028610 	.word	0x00028610
    8ebc:	000633f2 	.word	0x000633f2

00008ec0 <le_adv_update>:
}

static int le_adv_update(const struct bt_data *ad, size_t ad_len,
			 const struct bt_data *sd, size_t sd_len,
			 bool connectable, bool use_name)
{
    8ec0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8ec4:	b086      	sub	sp, #24
	struct bt_ad d[2] = {};
	struct bt_data data;
	int err;

	d[0].data = ad;
	d[0].len = ad_len;
    8ec6:	e9cd 0102 	strd	r0, r1, [sp, #8]
{
    8eca:	4615      	mov	r5, r2
    8ecc:	461e      	mov	r6, r3

	err = set_ad(BT_HCI_OP_LE_SET_ADV_DATA, d, 1);
    8ece:	2201      	movs	r2, #1
	struct bt_ad d[2] = {};
    8ed0:	2300      	movs	r3, #0
	err = set_ad(BT_HCI_OP_LE_SET_ADV_DATA, d, 1);
    8ed2:	a902      	add	r1, sp, #8
    8ed4:	f242 0008 	movw	r0, #8200	; 0x2008
{
    8ed8:	f89d 7030 	ldrb.w	r7, [sp, #48]	; 0x30
    8edc:	f89d 8034 	ldrb.w	r8, [sp, #52]	; 0x34
	struct bt_ad d[2] = {};
    8ee0:	e9cd 3304 	strd	r3, r3, [sp, #16]
	err = set_ad(BT_HCI_OP_LE_SET_ADV_DATA, d, 1);
    8ee4:	f7ff ff7c 	bl	8de0 <set_ad>
	if (err) {
    8ee8:	4604      	mov	r4, r0
    8eea:	bb10      	cbnz	r0, 8f32 <le_adv_update+0x72>
		return err;
	}

	d[0].data = sd;
	d[0].len = sd_len;
    8eec:	e9cd 5602 	strd	r5, r6, [sp, #8]

	if (use_name) {
    8ef0:	f1b8 0f00 	cmp.w	r8, #0
    8ef4:	d011      	beq.n	8f1a <le_adv_update+0x5a>
		const char *name;

		if (sd) {
    8ef6:	b115      	cbz	r5, 8efe <le_adv_update+0x3e>
	for (i = 0; i < ad_len; i++) {
    8ef8:	4602      	mov	r2, r0
    8efa:	42b2      	cmp	r2, r6
    8efc:	d11d      	bne.n	8f3a <le_adv_update+0x7a>
				return -EINVAL;
			}
		}

		name = bt_get_name();
		data = (struct bt_data)BT_DATA(
    8efe:	4d14      	ldr	r5, [pc, #80]	; (8f50 <le_adv_update+0x90>)
    8f00:	4628      	mov	r0, r5
    8f02:	f7f8 fed1 	bl	1ca8 <strlen>
    8f06:	2309      	movs	r3, #9
    8f08:	f88d 3000 	strb.w	r3, [sp]
			BT_DATA_NAME_COMPLETE,
			name, strlen(name));

		d[1].data = &data;
		d[1].len = 1;
    8f0c:	2301      	movs	r3, #1
		data = (struct bt_data)BT_DATA(
    8f0e:	f88d 0001 	strb.w	r0, [sp, #1]
    8f12:	9501      	str	r5, [sp, #4]
		d[1].data = &data;
    8f14:	f8cd d010 	str.w	sp, [sp, #16]
		d[1].len = 1;
    8f18:	9305      	str	r3, [sp, #20]
	 * by previous calls.
	 * Clearing sd is done by calling set_ad() with NULL data and
	 * zero len.
	 * So following condition check is unusual but correct.
	 */
	if (d[0].data || d[1].data || connectable) {
    8f1a:	9b02      	ldr	r3, [sp, #8]
    8f1c:	b913      	cbnz	r3, 8f24 <le_adv_update+0x64>
    8f1e:	9b04      	ldr	r3, [sp, #16]
    8f20:	b903      	cbnz	r3, 8f24 <le_adv_update+0x64>
    8f22:	b137      	cbz	r7, 8f32 <le_adv_update+0x72>
		err = set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, d, 2);
    8f24:	2202      	movs	r2, #2
    8f26:	a902      	add	r1, sp, #8
    8f28:	f242 0009 	movw	r0, #8201	; 0x2009
    8f2c:	f7ff ff58 	bl	8de0 <set_ad>
    8f30:	4604      	mov	r4, r0
			return err;
		}
	}

	return 0;
}
    8f32:	4620      	mov	r0, r4
    8f34:	b006      	add	sp, #24
    8f36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
    8f3a:	f815 1032 	ldrb.w	r1, [r5, r2, lsl #3]
    8f3e:	3908      	subs	r1, #8
    8f40:	2901      	cmp	r1, #1
    8f42:	d901      	bls.n	8f48 <le_adv_update+0x88>
	for (i = 0; i < ad_len; i++) {
    8f44:	3201      	adds	r2, #1
    8f46:	e7d8      	b.n	8efa <le_adv_update+0x3a>
				return -EINVAL;
    8f48:	f06f 0415 	mvn.w	r4, #21
    8f4c:	e7f1      	b.n	8f32 <le_adv_update+0x72>
    8f4e:	bf00      	nop
    8f50:	2000e5e4 	.word	0x2000e5e4

00008f54 <conn_auto_initiate>:
	if (conn->state != BT_CONN_CONNECTED) {
    8f54:	7b43      	ldrb	r3, [r0, #13]
    8f56:	2b06      	cmp	r3, #6
{
    8f58:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    8f5c:	4604      	mov	r4, r0
	if (conn->state != BT_CONN_CONNECTED) {
    8f5e:	d11e      	bne.n	8f9e <conn_auto_initiate+0x4a>
	if (!atomic_test_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH) &&
    8f60:	1d05      	adds	r5, r0, #4
    8f62:	210d      	movs	r1, #13
    8f64:	4628      	mov	r0, r5
    8f66:	f019 fa9c 	bl	224a2 <atomic_test_bit>
    8f6a:	b9d8      	cbnz	r0, 8fa4 <conn_auto_initiate+0x50>
    8f6c:	78e3      	ldrb	r3, [r4, #3]
    8f6e:	b123      	cbz	r3, 8f7a <conn_auto_initiate+0x26>
	     BT_FEAT_LE_SLAVE_FEATURE_XCHG(bt_dev.le.features))) {
    8f70:	4b52      	ldr	r3, [pc, #328]	; (90bc <conn_auto_initiate+0x168>)
	    ((conn->role == BT_HCI_ROLE_MASTER) ||
    8f72:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
    8f76:	0719      	lsls	r1, r3, #28
    8f78:	d514      	bpl.n	8fa4 <conn_auto_initiate+0x50>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_READ_REMOTE_FEATURES,
    8f7a:	2102      	movs	r1, #2
    8f7c:	f242 0016 	movw	r0, #8214	; 0x2016
    8f80:	f7ff fc7c 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    8f84:	4606      	mov	r6, r0
    8f86:	b168      	cbz	r0, 8fa4 <conn_auto_initiate+0x50>
	cp = net_buf_add(buf, sizeof(*cp));
    8f88:	2102      	movs	r1, #2
    8f8a:	3008      	adds	r0, #8
    8f8c:	f01b ff24 	bl	24dd8 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
    8f90:	8823      	ldrh	r3, [r4, #0]
    8f92:	8003      	strh	r3, [r0, #0]
	bt_hci_cmd_send(BT_HCI_OP_LE_READ_REMOTE_FEATURES, buf);
    8f94:	4631      	mov	r1, r6
    8f96:	f242 0016 	movw	r0, #8214	; 0x2016
    8f9a:	f7ff fca5 	bl	88e8 <bt_hci_cmd_send>
}
    8f9e:	b002      	add	sp, #8
    8fa0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	    !atomic_test_bit(conn->flags, BT_CONN_AUTO_PHY_COMPLETE) &&
    8fa4:	210c      	movs	r1, #12
    8fa6:	4628      	mov	r0, r5
    8fa8:	f019 fa7b 	bl	224a2 <atomic_test_bit>
    8fac:	f8df 810c 	ldr.w	r8, [pc, #268]	; 90bc <conn_auto_initiate+0x168>
	if (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) &&
    8fb0:	4606      	mov	r6, r0
    8fb2:	bb00      	cbnz	r0, 8ff6 <conn_auto_initiate+0xa2>
	    !atomic_test_bit(conn->flags, BT_CONN_AUTO_PHY_COMPLETE) &&
    8fb4:	f898 3079 	ldrb.w	r3, [r8, #121]	; 0x79
    8fb8:	07da      	lsls	r2, r3, #31
    8fba:	d51c      	bpl.n	8ff6 <conn_auto_initiate+0xa2>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PHY, sizeof(*cp));
    8fbc:	2107      	movs	r1, #7
    8fbe:	f242 0032 	movw	r0, #8242	; 0x2032
    8fc2:	f7ff fc5b 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    8fc6:	4607      	mov	r7, r0
    8fc8:	b1a8      	cbz	r0, 8ff6 <conn_auto_initiate+0xa2>
	cp = net_buf_add(buf, sizeof(*cp));
    8fca:	2107      	movs	r1, #7
    8fcc:	3008      	adds	r0, #8
    8fce:	f01b ff03 	bl	24dd8 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
    8fd2:	8823      	ldrh	r3, [r4, #0]
    8fd4:	8003      	strh	r3, [r0, #0]
	cp->tx_phys = BT_HCI_LE_PHY_PREFER_2M;
    8fd6:	2302      	movs	r3, #2
	cp->all_phys = 0U;
    8fd8:	7086      	strb	r6, [r0, #2]
	cp->tx_phys = BT_HCI_LE_PHY_PREFER_2M;
    8fda:	70c3      	strb	r3, [r0, #3]
	cp->rx_phys = BT_HCI_LE_PHY_PREFER_2M;
    8fdc:	7103      	strb	r3, [r0, #4]
	cp->phy_opts = BT_HCI_LE_PHY_CODED_ANY;
    8fde:	7146      	strb	r6, [r0, #5]
    8fe0:	7186      	strb	r6, [r0, #6]
	bt_hci_cmd_send(BT_HCI_OP_LE_SET_PHY, buf);
    8fe2:	4639      	mov	r1, r7
    8fe4:	f242 0032 	movw	r0, #8242	; 0x2032
    8fe8:	f7ff fc7e 	bl	88e8 <bt_hci_cmd_send>
    8fec:	2180      	movs	r1, #128	; 0x80
    8fee:	4628      	mov	r0, r5
    8ff0:	f019 f9fb 	bl	223ea <atomic_or>
			return;
    8ff4:	e7d3      	b.n	8f9e <conn_auto_initiate+0x4a>
	if (IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
    8ff6:	f898 3078 	ldrb.w	r3, [r8, #120]	; 0x78
    8ffa:	069b      	lsls	r3, r3, #26
    8ffc:	d514      	bpl.n	9028 <conn_auto_initiate+0xd4>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_MAX_DATA_LEN, NULL, &rsp);
    8ffe:	aa01      	add	r2, sp, #4
    9000:	2100      	movs	r1, #0
    9002:	f242 002f 	movw	r0, #8239	; 0x202f
    9006:	f7ff fdaf 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    900a:	b1f0      	cbz	r0, 904a <conn_auto_initiate+0xf6>
		BT_ERR("Failed to read DLE max data len");
    900c:	2301      	movs	r3, #1
    900e:	f04f 0100 	mov.w	r1, #0
    9012:	f363 0107 	bfi	r1, r3, #0, #8
    9016:	4a2a      	ldr	r2, [pc, #168]	; (90c0 <conn_auto_initiate+0x16c>)
    9018:	4b2a      	ldr	r3, [pc, #168]	; (90c4 <conn_auto_initiate+0x170>)
    901a:	482b      	ldr	r0, [pc, #172]	; (90c8 <conn_auto_initiate+0x174>)
    901c:	1a9b      	subs	r3, r3, r2
    901e:	08db      	lsrs	r3, r3, #3
    9020:	f363 118f 	bfi	r1, r3, #6, #10
		BT_ERR("Failed to send LE Set Data Length Command");
    9024:	f018 f809 	bl	2103a <log_0>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    9028:	78e3      	ldrb	r3, [r4, #3]
    902a:	2b01      	cmp	r3, #1
    902c:	d1b7      	bne.n	8f9e <conn_auto_initiate+0x4a>
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_UPDATE)) {
    902e:	2108      	movs	r1, #8
    9030:	4628      	mov	r0, r5
    9032:	f019 fa36 	bl	224a2 <atomic_test_bit>
    9036:	2800      	cmp	r0, #0
    9038:	d1b1      	bne.n	8f9e <conn_auto_initiate+0x4a>
    903a:	f241 3288 	movw	r2, #5000	; 0x1388
    903e:	f104 0154 	add.w	r1, r4, #84	; 0x54
    9042:	4822      	ldr	r0, [pc, #136]	; (90cc <conn_auto_initiate+0x178>)
    9044:	f016 f80c 	bl	1f060 <k_delayed_work_submit_to_queue>
    9048:	e7a9      	b.n	8f9e <conn_auto_initiate+0x4a>
	rp = (void *)rsp->data;
    904a:	9801      	ldr	r0, [sp, #4]
    904c:	6883      	ldr	r3, [r0, #8]
	tx_octets = sys_le16_to_cpu(rp->max_tx_octets);
    904e:	f8b3 8001 	ldrh.w	r8, [r3, #1]
	tx_time = sys_le16_to_cpu(rp->max_tx_time);
    9052:	f8b3 7003 	ldrh.w	r7, [r3, #3]
	net_buf_unref(rsp);
    9056:	f010 f801 	bl	1905c <net_buf_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_DATA_LEN, sizeof(*cp));
    905a:	2106      	movs	r1, #6
    905c:	f242 0022 	movw	r0, #8226	; 0x2022
    9060:	f7ff fc0c 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    9064:	4606      	mov	r6, r0
    9066:	b960      	cbnz	r0, 9082 <conn_auto_initiate+0x12e>
		BT_ERR("Failed to create LE Set Data Length Command");
    9068:	2301      	movs	r3, #1
    906a:	f04f 0100 	mov.w	r1, #0
    906e:	f363 0107 	bfi	r1, r3, #0, #8
    9072:	4a13      	ldr	r2, [pc, #76]	; (90c0 <conn_auto_initiate+0x16c>)
    9074:	4b13      	ldr	r3, [pc, #76]	; (90c4 <conn_auto_initiate+0x170>)
    9076:	4816      	ldr	r0, [pc, #88]	; (90d0 <conn_auto_initiate+0x17c>)
    9078:	1a9b      	subs	r3, r3, r2
    907a:	08db      	lsrs	r3, r3, #3
    907c:	f363 118f 	bfi	r1, r3, #6, #10
    9080:	e7d0      	b.n	9024 <conn_auto_initiate+0xd0>
	cp = net_buf_add(buf, sizeof(*cp));
    9082:	2106      	movs	r1, #6
    9084:	3008      	adds	r0, #8
    9086:	f01b fea7 	bl	24dd8 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
    908a:	8823      	ldrh	r3, [r4, #0]
    908c:	8003      	strh	r3, [r0, #0]
	cp->tx_octets = sys_cpu_to_le16(tx_octets);
    908e:	f8a0 8002 	strh.w	r8, [r0, #2]
	cp->tx_time = sys_cpu_to_le16(tx_time);
    9092:	8087      	strh	r7, [r0, #4]
	err = bt_hci_cmd_send(BT_HCI_OP_LE_SET_DATA_LEN, buf);
    9094:	4631      	mov	r1, r6
    9096:	f242 0022 	movw	r0, #8226	; 0x2022
    909a:	f7ff fc25 	bl	88e8 <bt_hci_cmd_send>
	if (err) {
    909e:	2800      	cmp	r0, #0
    90a0:	d0c2      	beq.n	9028 <conn_auto_initiate+0xd4>
		BT_ERR("Failed to send LE Set Data Length Command");
    90a2:	2301      	movs	r3, #1
    90a4:	f04f 0100 	mov.w	r1, #0
    90a8:	f363 0107 	bfi	r1, r3, #0, #8
    90ac:	4a04      	ldr	r2, [pc, #16]	; (90c0 <conn_auto_initiate+0x16c>)
    90ae:	4b05      	ldr	r3, [pc, #20]	; (90c4 <conn_auto_initiate+0x170>)
    90b0:	4808      	ldr	r0, [pc, #32]	; (90d4 <conn_auto_initiate+0x180>)
    90b2:	1a9b      	subs	r3, r3, r2
    90b4:	08db      	lsrs	r3, r3, #3
    90b6:	f363 118f 	bfi	r1, r3, #6, #10
    90ba:	e7b3      	b.n	9024 <conn_auto_initiate+0xd0>
    90bc:	2000e4d8 	.word	0x2000e4d8
    90c0:	00028540 	.word	0x00028540
    90c4:	00028610 	.word	0x00028610
    90c8:	000630e7 	.word	0x000630e7
    90cc:	20006090 	.word	0x20006090
    90d0:	00063107 	.word	0x00063107
    90d4:	00063133 	.word	0x00063133

000090d8 <le_phy_update_complete>:
{
    90d8:	b538      	push	{r3, r4, r5, lr}
	u16_t handle = sys_le16_to_cpu(evt->handle);
    90da:	6883      	ldr	r3, [r0, #8]
    90dc:	f8b3 5001 	ldrh.w	r5, [r3, #1]
	conn = bt_conn_lookup_handle(handle);
    90e0:	4628      	mov	r0, r5
    90e2:	f001 fe8b 	bl	adfc <bt_conn_lookup_handle>
	if (!conn) {
    90e6:	4604      	mov	r4, r0
    90e8:	b980      	cbnz	r0, 910c <le_phy_update_complete+0x34>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    90ea:	2301      	movs	r3, #1
    90ec:	f04f 0200 	mov.w	r2, #0
    90f0:	f363 0207 	bfi	r2, r3, #0, #8
    90f4:	4910      	ldr	r1, [pc, #64]	; (9138 <le_phy_update_complete+0x60>)
    90f6:	4b11      	ldr	r3, [pc, #68]	; (913c <le_phy_update_complete+0x64>)
    90f8:	4811      	ldr	r0, [pc, #68]	; (9140 <le_phy_update_complete+0x68>)
    90fa:	1a5b      	subs	r3, r3, r1
    90fc:	08db      	lsrs	r3, r3, #3
    90fe:	f363 128f 	bfi	r2, r3, #6, #10
    9102:	4629      	mov	r1, r5
}
    9104:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		BT_ERR("Unable to lookup conn for handle %u", handle);
    9108:	f017 bfa4 	b.w	21054 <log_1>
	    !atomic_test_and_clear_bit(conn->flags, BT_CONN_AUTO_PHY_UPDATE)) {
    910c:	1d05      	adds	r5, r0, #4
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    910e:	f06f 0180 	mvn.w	r1, #128	; 0x80
    9112:	4628      	mov	r0, r5
    9114:	f019 f95a 	bl	223cc <atomic_and>
	if (!IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) ||
    9118:	0603      	lsls	r3, r0, #24
    911a:	d507      	bpl.n	912c <le_phy_update_complete+0x54>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    911c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    9120:	4628      	mov	r0, r5
    9122:	f019 f962 	bl	223ea <atomic_or>
	conn_auto_initiate(conn);
    9126:	4620      	mov	r0, r4
    9128:	f7ff ff14 	bl	8f54 <conn_auto_initiate>
	bt_conn_unref(conn);
    912c:	4620      	mov	r0, r4
}
    912e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_conn_unref(conn);
    9132:	f019 baf4 	b.w	2271e <bt_conn_unref>
    9136:	bf00      	nop
    9138:	00028540 	.word	0x00028540
    913c:	00028610 	.word	0x00028610
    9140:	000633b7 	.word	0x000633b7

00009144 <le_remote_feat_complete>:
{
    9144:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_le_remote_feat_complete *evt = (void *)buf->data;
    9146:	6884      	ldr	r4, [r0, #8]
	u16_t handle = sys_le16_to_cpu(evt->handle);
    9148:	f8b4 6001 	ldrh.w	r6, [r4, #1]
	conn = bt_conn_lookup_handle(handle);
    914c:	4630      	mov	r0, r6
    914e:	f001 fe55 	bl	adfc <bt_conn_lookup_handle>
	if (!conn) {
    9152:	4605      	mov	r5, r0
    9154:	b980      	cbnz	r0, 9178 <le_remote_feat_complete+0x34>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    9156:	2301      	movs	r3, #1
    9158:	f04f 0200 	mov.w	r2, #0
    915c:	f363 0207 	bfi	r2, r3, #0, #8
    9160:	4910      	ldr	r1, [pc, #64]	; (91a4 <le_remote_feat_complete+0x60>)
    9162:	4b11      	ldr	r3, [pc, #68]	; (91a8 <le_remote_feat_complete+0x64>)
    9164:	4811      	ldr	r0, [pc, #68]	; (91ac <le_remote_feat_complete+0x68>)
    9166:	1a5b      	subs	r3, r3, r1
    9168:	08db      	lsrs	r3, r3, #3
    916a:	4631      	mov	r1, r6
    916c:	f363 128f 	bfi	r2, r3, #6, #10
}
    9170:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_ERR("Unable to lookup conn for handle %u", handle);
    9174:	f017 bf6e 	b.w	21054 <log_1>
	if (!evt->status) {
    9178:	7823      	ldrb	r3, [r4, #0]
    917a:	b933      	cbnz	r3, 918a <le_remote_feat_complete+0x46>
    917c:	f854 3f03 	ldr.w	r3, [r4, #3]!
    9180:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
    9184:	6863      	ldr	r3, [r4, #4]
    9186:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
    918a:	f44f 5100 	mov.w	r1, #8192	; 0x2000
    918e:	1d28      	adds	r0, r5, #4
    9190:	f019 f92b 	bl	223ea <atomic_or>
	conn_auto_initiate(conn);
    9194:	4628      	mov	r0, r5
    9196:	f7ff fedd 	bl	8f54 <conn_auto_initiate>
	bt_conn_unref(conn);
    919a:	4628      	mov	r0, r5
}
    919c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_conn_unref(conn);
    91a0:	f019 babd 	b.w	2271e <bt_conn_unref>
    91a4:	00028540 	.word	0x00028540
    91a8:	00028610 	.word	0x00028610
    91ac:	000633b7 	.word	0x000633b7

000091b0 <bt_unpair>:
{
    91b0:	b530      	push	{r4, r5, lr}
    91b2:	b085      	sub	sp, #20
    91b4:	460d      	mov	r5, r1
    91b6:	f88d 0007 	strb.w	r0, [sp, #7]
	if (id >= CONFIG_BT_ID_MAX) {
    91ba:	b9d0      	cbnz	r0, 91f2 <bt_unpair+0x42>
	if (!addr || !bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    91bc:	b949      	cbnz	r1, 91d2 <bt_unpair+0x22>
		bt_foreach_bond(id, unpair_remote, &id);
    91be:	f10d 0207 	add.w	r2, sp, #7
    91c2:	490d      	ldr	r1, [pc, #52]	; (91f8 <bt_unpair+0x48>)
    91c4:	f89d 0007 	ldrb.w	r0, [sp, #7]
    91c8:	f007 f814 	bl	101f4 <bt_foreach_bond>
		return 0;
    91cc:	2000      	movs	r0, #0
}
    91ce:	b005      	add	sp, #20
    91d0:	bd30      	pop	{r4, r5, pc}
	if (!addr || !bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    91d2:	9002      	str	r0, [sp, #8]
	return memcmp(a, b, sizeof(*a));
    91d4:	2207      	movs	r2, #7
    91d6:	f8cd 000b 	str.w	r0, [sp, #11]
    91da:	a902      	add	r1, sp, #8
    91dc:	4628      	mov	r0, r5
    91de:	f7f8 fcf7 	bl	1bd0 <memcmp>
    91e2:	2800      	cmp	r0, #0
    91e4:	d0eb      	beq.n	91be <bt_unpair+0xe>
	unpair(id, addr);
    91e6:	4629      	mov	r1, r5
    91e8:	f89d 0007 	ldrb.w	r0, [sp, #7]
    91ec:	f019 f91d 	bl	2242a <unpair>
	return 0;
    91f0:	e7ec      	b.n	91cc <bt_unpair+0x1c>
		return -EINVAL;
    91f2:	f06f 0015 	mvn.w	r0, #21
    91f6:	e7ea      	b.n	91ce <bt_unpair+0x1e>
    91f8:	00022481 	.word	0x00022481

000091fc <bt_id_add>:
{
    91fc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (!bt_dev.le.rl_size || bt_dev.le.rl_entries > bt_dev.le.rl_size) {
    91fe:	4e65      	ldr	r6, [pc, #404]	; (9394 <bt_id_add+0x198>)
    9200:	f896 20a4 	ldrb.w	r2, [r6, #164]	; 0xa4
    9204:	f896 30a5 	ldrb.w	r3, [r6, #165]	; 0xa5
{
    9208:	4605      	mov	r5, r0
    920a:	4634      	mov	r4, r6
	if (!bt_dev.le.rl_size || bt_dev.le.rl_entries > bt_dev.le.rl_size) {
    920c:	b10a      	cbz	r2, 9212 <bt_id_add+0x16>
    920e:	429a      	cmp	r2, r3
    9210:	d204      	bcs.n	921c <bt_id_add+0x20>
		bt_dev.le.rl_entries++;
    9212:	3301      	adds	r3, #1
    9214:	f884 30a5 	strb.w	r3, [r4, #165]	; 0xa5
}
    9218:	b003      	add	sp, #12
    921a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	conn = bt_conn_lookup_state_le(NULL, BT_CONN_CONNECT);
    921c:	2105      	movs	r1, #5
    921e:	2000      	movs	r0, #0
    9220:	f001 fe24 	bl	ae6c <bt_conn_lookup_state_le>
	if (conn) {
    9224:	4607      	mov	r7, r0
    9226:	b168      	cbz	r0, 9244 <bt_id_add+0x48>
    9228:	f44f 3180 	mov.w	r1, #65536	; 0x10000
    922c:	f106 0070 	add.w	r0, r6, #112	; 0x70
    9230:	f019 f8db 	bl	223ea <atomic_or>
		keys->flags |= BT_KEYS_ID_PENDING_ADD;
    9234:	7a6b      	ldrb	r3, [r5, #9]
    9236:	f043 0304 	orr.w	r3, r3, #4
    923a:	726b      	strb	r3, [r5, #9]
		bt_conn_unref(conn);
    923c:	4638      	mov	r0, r7
    923e:	f019 fa6e 	bl	2271e <bt_conn_unref>
		return;
    9242:	e7e9      	b.n	9218 <bt_id_add+0x1c>
	adv_enabled = atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING);
    9244:	f106 0070 	add.w	r0, r6, #112	; 0x70
    9248:	2105      	movs	r1, #5
    924a:	f019 f92a 	bl	224a2 <atomic_test_bit>
	if (adv_enabled) {
    924e:	4606      	mov	r6, r0
    9250:	b110      	cbz	r0, 9258 <bt_id_add+0x5c>
		set_advertise_enable(false);
    9252:	4638      	mov	r0, r7
    9254:	f7ff fcce 	bl	8bf4 <set_advertise_enable>
	if (bt_dev.le.rl_entries) {
    9258:	f894 30a5 	ldrb.w	r3, [r4, #165]	; 0xa5
    925c:	b193      	cbz	r3, 9284 <bt_id_add+0x88>
		err = addr_res_enable(BT_HCI_ADDR_RES_DISABLE);
    925e:	2000      	movs	r0, #0
    9260:	f019 f93d 	bl	224de <addr_res_enable>
		if (err) {
    9264:	b170      	cbz	r0, 9284 <bt_id_add+0x88>
			BT_WARN("Failed to disable address resolution");
    9266:	2302      	movs	r3, #2
    9268:	f04f 0100 	mov.w	r1, #0
    926c:	f363 0107 	bfi	r1, r3, #0, #8
    9270:	4a49      	ldr	r2, [pc, #292]	; (9398 <bt_id_add+0x19c>)
    9272:	4b4a      	ldr	r3, [pc, #296]	; (939c <bt_id_add+0x1a0>)
    9274:	484a      	ldr	r0, [pc, #296]	; (93a0 <bt_id_add+0x1a4>)
    9276:	1a9b      	subs	r3, r3, r2
    9278:	08db      	lsrs	r3, r3, #3
    927a:	f363 118f 	bfi	r1, r3, #6, #10
		BT_WARN("Set privacy mode command is not supported");
    927e:	f017 fedc 	bl	2103a <log_0>
	if (err) {
    9282:	e029      	b.n	92d8 <bt_id_add+0xdc>
	if (bt_dev.le.rl_entries == bt_dev.le.rl_size) {
    9284:	f894 20a5 	ldrb.w	r2, [r4, #165]	; 0xa5
    9288:	f894 30a4 	ldrb.w	r3, [r4, #164]	; 0xa4
    928c:	429a      	cmp	r2, r3
    928e:	d12c      	bne.n	92ea <bt_id_add+0xee>
		BT_WARN("Resolving list size exceeded. Switching to host.");
    9290:	2302      	movs	r3, #2
    9292:	f04f 0100 	mov.w	r1, #0
    9296:	f363 0107 	bfi	r1, r3, #0, #8
    929a:	4d40      	ldr	r5, [pc, #256]	; (939c <bt_id_add+0x1a0>)
    929c:	4b3e      	ldr	r3, [pc, #248]	; (9398 <bt_id_add+0x19c>)
    929e:	4841      	ldr	r0, [pc, #260]	; (93a4 <bt_id_add+0x1a8>)
    92a0:	1aed      	subs	r5, r5, r3
    92a2:	f3c5 05c9 	ubfx	r5, r5, #3, #10
    92a6:	f365 118f 	bfi	r1, r5, #6, #10
    92aa:	f017 fec6 	bl	2103a <log_0>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_CLEAR_RL, NULL, NULL);
    92ae:	2200      	movs	r2, #0
    92b0:	4611      	mov	r1, r2
    92b2:	f242 0029 	movw	r0, #8233	; 0x2029
    92b6:	f7ff fc57 	bl	8b68 <bt_hci_cmd_send_sync>
		if (err) {
    92ba:	b140      	cbz	r0, 92ce <bt_id_add+0xd2>
			BT_ERR("Failed to clear resolution list");
    92bc:	f04f 0100 	mov.w	r1, #0
    92c0:	2301      	movs	r3, #1
    92c2:	f363 0107 	bfi	r1, r3, #0, #8
    92c6:	f365 118f 	bfi	r1, r5, #6, #10
    92ca:	4837      	ldr	r0, [pc, #220]	; (93a8 <bt_id_add+0x1ac>)
    92cc:	e7d7      	b.n	927e <bt_id_add+0x82>
		bt_dev.le.rl_entries++;
    92ce:	f894 30a5 	ldrb.w	r3, [r4, #165]	; 0xa5
    92d2:	3301      	adds	r3, #1
    92d4:	f884 30a5 	strb.w	r3, [r4, #165]	; 0xa5
	addr_res_enable(BT_HCI_ADDR_RES_ENABLE);
    92d8:	2001      	movs	r0, #1
    92da:	f019 f900 	bl	224de <addr_res_enable>
	if (adv_enabled) {
    92de:	2e00      	cmp	r6, #0
    92e0:	d09a      	beq.n	9218 <bt_id_add+0x1c>
		set_advertise_enable(true);
    92e2:	2001      	movs	r0, #1
    92e4:	f7ff fc86 	bl	8bf4 <set_advertise_enable>
    92e8:	e796      	b.n	9218 <bt_id_add+0x1c>
	err = hci_id_add(&keys->addr, keys->irk.val);
    92ea:	1c6f      	adds	r7, r5, #1
    92ec:	f105 0126 	add.w	r1, r5, #38	; 0x26
    92f0:	4638      	mov	r0, r7
    92f2:	f7ff fd3d 	bl	8d70 <hci_id_add>
	if (err) {
    92f6:	4605      	mov	r5, r0
    92f8:	b160      	cbz	r0, 9314 <bt_id_add+0x118>
		BT_ERR("Failed to add IRK to controller");
    92fa:	2301      	movs	r3, #1
    92fc:	f04f 0100 	mov.w	r1, #0
    9300:	f363 0107 	bfi	r1, r3, #0, #8
    9304:	4a24      	ldr	r2, [pc, #144]	; (9398 <bt_id_add+0x19c>)
    9306:	4b25      	ldr	r3, [pc, #148]	; (939c <bt_id_add+0x1a0>)
    9308:	4828      	ldr	r0, [pc, #160]	; (93ac <bt_id_add+0x1b0>)
    930a:	1a9b      	subs	r3, r3, r2
    930c:	08db      	lsrs	r3, r3, #3
    930e:	f363 118f 	bfi	r1, r3, #6, #10
    9312:	e7b4      	b.n	927e <bt_id_add+0x82>
	bt_dev.le.rl_entries++;
    9314:	f894 30a5 	ldrb.w	r3, [r4, #165]	; 0xa5
    9318:	3301      	adds	r3, #1
    931a:	f884 30a5 	strb.w	r3, [r4, #165]	; 0xa5
	if (!BT_CMD_TEST(bt_dev.supported_commands, 39, 2)) {
    931e:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
    9322:	075b      	lsls	r3, r3, #29
    9324:	d40c      	bmi.n	9340 <bt_id_add+0x144>
		BT_WARN("Set privacy mode command is not supported");
    9326:	2302      	movs	r3, #2
    9328:	f04f 0100 	mov.w	r1, #0
    932c:	f363 0107 	bfi	r1, r3, #0, #8
    9330:	4a19      	ldr	r2, [pc, #100]	; (9398 <bt_id_add+0x19c>)
    9332:	4b1a      	ldr	r3, [pc, #104]	; (939c <bt_id_add+0x1a0>)
    9334:	481e      	ldr	r0, [pc, #120]	; (93b0 <bt_id_add+0x1b4>)
    9336:	1a9b      	subs	r3, r3, r2
    9338:	08db      	lsrs	r3, r3, #3
    933a:	f363 118f 	bfi	r1, r3, #6, #10
    933e:	e79e      	b.n	927e <bt_id_add+0x82>
	bt_addr_le_copy(&cp.id_addr, addr);
    9340:	4639      	mov	r1, r7
    9342:	4668      	mov	r0, sp
    9344:	f019 f8a6 	bl	22494 <bt_addr_le_copy>
	cp.mode = mode;
    9348:	2301      	movs	r3, #1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PRIVACY_MODE, sizeof(cp));
    934a:	2108      	movs	r1, #8
    934c:	f242 004e 	movw	r0, #8270	; 0x204e
	cp.mode = mode;
    9350:	f88d 3007 	strb.w	r3, [sp, #7]
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PRIVACY_MODE, sizeof(cp));
    9354:	f7ff fa92 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    9358:	4604      	mov	r4, r0
    935a:	b960      	cbnz	r0, 9376 <bt_id_add+0x17a>
		BT_ERR("Failed to set privacy mode");
    935c:	2301      	movs	r3, #1
    935e:	f04f 0100 	mov.w	r1, #0
    9362:	f363 0107 	bfi	r1, r3, #0, #8
    9366:	4a0c      	ldr	r2, [pc, #48]	; (9398 <bt_id_add+0x19c>)
    9368:	4b0c      	ldr	r3, [pc, #48]	; (939c <bt_id_add+0x1a0>)
    936a:	4812      	ldr	r0, [pc, #72]	; (93b4 <bt_id_add+0x1b8>)
    936c:	1a9b      	subs	r3, r3, r2
    936e:	08db      	lsrs	r3, r3, #3
    9370:	f363 118f 	bfi	r1, r3, #6, #10
    9374:	e783      	b.n	927e <bt_id_add+0x82>
	net_buf_add_mem(buf, &cp, sizeof(cp));
    9376:	2208      	movs	r2, #8
    9378:	4669      	mov	r1, sp
    937a:	4410      	add	r0, r2
    937c:	f01b fd32 	bl	24de4 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_PRIVACY_MODE, buf, NULL);
    9380:	462a      	mov	r2, r5
    9382:	4621      	mov	r1, r4
    9384:	f242 004e 	movw	r0, #8270	; 0x204e
    9388:	f7ff fbee 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    938c:	2800      	cmp	r0, #0
    938e:	d0a3      	beq.n	92d8 <bt_id_add+0xdc>
    9390:	e7e4      	b.n	935c <bt_id_add+0x160>
    9392:	bf00      	nop
    9394:	2000e4d8 	.word	0x2000e4d8
    9398:	00028540 	.word	0x00028540
    939c:	00028610 	.word	0x00028610
    93a0:	00062c44 	.word	0x00062c44
    93a4:	00062c69 	.word	0x00062c69
    93a8:	00062c9a 	.word	0x00062c9a
    93ac:	00062cba 	.word	0x00062cba
    93b0:	00062cda 	.word	0x00062cda
    93b4:	00062d04 	.word	0x00062d04

000093b8 <bt_id_del>:
{
    93b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!bt_dev.le.rl_size ||
    93bc:	4e46      	ldr	r6, [pc, #280]	; (94d8 <bt_id_del+0x120>)
    93be:	f896 20a4 	ldrb.w	r2, [r6, #164]	; 0xa4
    93c2:	f896 30a5 	ldrb.w	r3, [r6, #165]	; 0xa5
{
    93c6:	4605      	mov	r5, r0
    93c8:	4634      	mov	r4, r6
	if (!bt_dev.le.rl_size ||
    93ca:	b112      	cbz	r2, 93d2 <bt_id_del+0x1a>
	    bt_dev.le.rl_entries > bt_dev.le.rl_size + 1) {
    93cc:	3201      	adds	r2, #1
	if (!bt_dev.le.rl_size ||
    93ce:	4293      	cmp	r3, r2
    93d0:	dd04      	ble.n	93dc <bt_id_del+0x24>
		bt_dev.le.rl_entries--;
    93d2:	3b01      	subs	r3, #1
    93d4:	f884 30a5 	strb.w	r3, [r4, #165]	; 0xa5
}
    93d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	conn = bt_conn_lookup_state_le(NULL, BT_CONN_CONNECT);
    93dc:	2105      	movs	r1, #5
    93de:	2000      	movs	r0, #0
    93e0:	f001 fd44 	bl	ae6c <bt_conn_lookup_state_le>
	if (conn) {
    93e4:	4607      	mov	r7, r0
    93e6:	b170      	cbz	r0, 9406 <bt_id_del+0x4e>
    93e8:	f106 0070 	add.w	r0, r6, #112	; 0x70
    93ec:	f44f 3180 	mov.w	r1, #65536	; 0x10000
    93f0:	f018 fffb 	bl	223ea <atomic_or>
		keys->flags |= BT_KEYS_ID_PENDING_DEL;
    93f4:	7a6b      	ldrb	r3, [r5, #9]
    93f6:	f043 0308 	orr.w	r3, r3, #8
    93fa:	726b      	strb	r3, [r5, #9]
		bt_conn_unref(conn);
    93fc:	4638      	mov	r0, r7
}
    93fe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		bt_conn_unref(conn);
    9402:	f019 b98c 	b.w	2271e <bt_conn_unref>
	adv_enabled = atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING);
    9406:	f106 0070 	add.w	r0, r6, #112	; 0x70
    940a:	2105      	movs	r1, #5
    940c:	f019 f849 	bl	224a2 <atomic_test_bit>
	if (adv_enabled) {
    9410:	4606      	mov	r6, r0
    9412:	b110      	cbz	r0, 941a <bt_id_del+0x62>
		set_advertise_enable(false);
    9414:	4638      	mov	r0, r7
    9416:	f7ff fbed 	bl	8bf4 <set_advertise_enable>
	err = addr_res_enable(BT_HCI_ADDR_RES_DISABLE);
    941a:	2000      	movs	r0, #0
    941c:	f019 f85f 	bl	224de <addr_res_enable>
	if (err) {
    9420:	4607      	mov	r7, r0
    9422:	b1d8      	cbz	r0, 945c <bt_id_del+0xa4>
		BT_ERR("Disabling address resolution failed (err %d)", err);
    9424:	2301      	movs	r3, #1
    9426:	f04f 0200 	mov.w	r2, #0
    942a:	f363 0207 	bfi	r2, r3, #0, #8
    942e:	492b      	ldr	r1, [pc, #172]	; (94dc <bt_id_del+0x124>)
    9430:	4b2b      	ldr	r3, [pc, #172]	; (94e0 <bt_id_del+0x128>)
    9432:	1a5b      	subs	r3, r3, r1
    9434:	08db      	lsrs	r3, r3, #3
    9436:	4601      	mov	r1, r0
    9438:	f363 128f 	bfi	r2, r3, #6, #10
    943c:	4829      	ldr	r0, [pc, #164]	; (94e4 <bt_id_del+0x12c>)
    943e:	f017 fe09 	bl	21054 <log_1>
	if (bt_dev.le.rl_entries) {
    9442:	f894 30a5 	ldrb.w	r3, [r4, #165]	; 0xa5
    9446:	b113      	cbz	r3, 944e <bt_id_del+0x96>
		addr_res_enable(BT_HCI_ADDR_RES_ENABLE);
    9448:	2001      	movs	r0, #1
    944a:	f019 f848 	bl	224de <addr_res_enable>
	if (adv_enabled) {
    944e:	2e00      	cmp	r6, #0
    9450:	d0c2      	beq.n	93d8 <bt_id_del+0x20>
		set_advertise_enable(true);
    9452:	2001      	movs	r0, #1
}
    9454:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		set_advertise_enable(true);
    9458:	f7ff bbcc 	b.w	8bf4 <set_advertise_enable>
	if (bt_dev.le.rl_entries > bt_dev.le.rl_size) {
    945c:	f894 30a5 	ldrb.w	r3, [r4, #165]	; 0xa5
    9460:	f894 20a4 	ldrb.w	r2, [r4, #164]	; 0xa4
    9464:	429a      	cmp	r2, r3
    9466:	d20c      	bcs.n	9482 <bt_id_del+0xca>
		bt_dev.le.rl_entries--;
    9468:	3b01      	subs	r3, #1
    946a:	f884 30a5 	strb.w	r3, [r4, #165]	; 0xa5
		keys->keys &= ~BT_KEYS_IRK;
    946e:	896b      	ldrh	r3, [r5, #10]
		bt_keys_foreach(BT_KEYS_IRK, keys_add_id, NULL);
    9470:	491d      	ldr	r1, [pc, #116]	; (94e8 <bt_id_del+0x130>)
		keys->keys &= ~BT_KEYS_IRK;
    9472:	f023 0302 	bic.w	r3, r3, #2
		bt_keys_foreach(BT_KEYS_IRK, keys_add_id, NULL);
    9476:	4602      	mov	r2, r0
		keys->keys &= ~BT_KEYS_IRK;
    9478:	816b      	strh	r3, [r5, #10]
		bt_keys_foreach(BT_KEYS_IRK, keys_add_id, NULL);
    947a:	2002      	movs	r0, #2
    947c:	f006 fece 	bl	1021c <bt_keys_foreach>
		goto done;
    9480:	e7df      	b.n	9442 <bt_id_del+0x8a>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_REM_DEV_FROM_RL, sizeof(*cp));
    9482:	2107      	movs	r1, #7
    9484:	f242 0028 	movw	r0, #8232	; 0x2028
    9488:	f7ff f9f8 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    948c:	4680      	mov	r8, r0
    948e:	2800      	cmp	r0, #0
    9490:	d0d7      	beq.n	9442 <bt_id_del+0x8a>
	cp = net_buf_add(buf, sizeof(*cp));
    9492:	2107      	movs	r1, #7
    9494:	3008      	adds	r0, #8
    9496:	f01b fc9f 	bl	24dd8 <net_buf_simple_add>
	bt_addr_le_copy(&cp->peer_id_addr, &keys->addr);
    949a:	1c69      	adds	r1, r5, #1
    949c:	f018 fffa 	bl	22494 <bt_addr_le_copy>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_REM_DEV_FROM_RL, buf, NULL);
    94a0:	463a      	mov	r2, r7
    94a2:	4641      	mov	r1, r8
    94a4:	f242 0028 	movw	r0, #8232	; 0x2028
    94a8:	f7ff fb5e 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    94ac:	b170      	cbz	r0, 94cc <bt_id_del+0x114>
		BT_ERR("Failed to remove IRK from controller");
    94ae:	2301      	movs	r3, #1
    94b0:	f04f 0100 	mov.w	r1, #0
    94b4:	f363 0107 	bfi	r1, r3, #0, #8
    94b8:	4a08      	ldr	r2, [pc, #32]	; (94dc <bt_id_del+0x124>)
    94ba:	4b09      	ldr	r3, [pc, #36]	; (94e0 <bt_id_del+0x128>)
    94bc:	480b      	ldr	r0, [pc, #44]	; (94ec <bt_id_del+0x134>)
    94be:	1a9b      	subs	r3, r3, r2
    94c0:	08db      	lsrs	r3, r3, #3
    94c2:	f363 118f 	bfi	r1, r3, #6, #10
    94c6:	f017 fdb8 	bl	2103a <log_0>
		goto done;
    94ca:	e7ba      	b.n	9442 <bt_id_del+0x8a>
	bt_dev.le.rl_entries--;
    94cc:	f894 30a5 	ldrb.w	r3, [r4, #165]	; 0xa5
    94d0:	3b01      	subs	r3, #1
    94d2:	f884 30a5 	strb.w	r3, [r4, #165]	; 0xa5
    94d6:	e7b4      	b.n	9442 <bt_id_del+0x8a>
    94d8:	2000e4d8 	.word	0x2000e4d8
    94dc:	00028540 	.word	0x00028540
    94e0:	00028610 	.word	0x00028610
    94e4:	00062d4d 	.word	0x00062d4d
    94e8:	000224d5 	.word	0x000224d5
    94ec:	00062d7a 	.word	0x00062d7a

000094f0 <id_create>:
{
    94f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    94f4:	4604      	mov	r4, r0
    94f6:	482c      	ldr	r0, [pc, #176]	; (95a8 <id_create+0xb8>)
    94f8:	ebc4 07c4 	rsb	r7, r4, r4, lsl #3
    94fc:	b086      	sub	sp, #24
    94fe:	4615      	mov	r5, r2
    9500:	4407      	add	r7, r0
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    9502:	460e      	mov	r6, r1
    9504:	4680      	mov	r8, r0
    9506:	b371      	cbz	r1, 9566 <id_create+0x76>
    9508:	2300      	movs	r3, #0
    950a:	2207      	movs	r2, #7
    950c:	4669      	mov	r1, sp
    950e:	4630      	mov	r0, r6
    9510:	9300      	str	r3, [sp, #0]
    9512:	f8cd 3003 	str.w	r3, [sp, #3]
    9516:	f7f8 fb5b 	bl	1bd0 <memcmp>
    951a:	b320      	cbz	r0, 9566 <id_create+0x76>
		bt_addr_le_copy(&bt_dev.id_addr[id], addr);
    951c:	4631      	mov	r1, r6
    951e:	4638      	mov	r0, r7
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
    9520:	f018 ffb8 	bl	22494 <bt_addr_le_copy>
		u8_t zero_irk[16] = { 0 };
    9524:	2610      	movs	r6, #16
    9526:	4632      	mov	r2, r6
    9528:	2100      	movs	r1, #0
    952a:	a802      	add	r0, sp, #8
    952c:	fb06 8404 	mla	r4, r6, r4, r8
    9530:	f7f8 fb7d 	bl	1c2e <memset>
		if (irk && memcmp(irk, zero_irk, 16)) {
    9534:	34dc      	adds	r4, #220	; 0xdc
    9536:	b33d      	cbz	r5, 9588 <id_create+0x98>
    9538:	4632      	mov	r2, r6
    953a:	a902      	add	r1, sp, #8
    953c:	4628      	mov	r0, r5
    953e:	f7f8 fb47 	bl	1bd0 <memcmp>
    9542:	b308      	cbz	r0, 9588 <id_create+0x98>
    9544:	19ab      	adds	r3, r5, r6
    9546:	f855 2b04 	ldr.w	r2, [r5], #4
    954a:	f844 2b04 	str.w	r2, [r4], #4
    954e:	429d      	cmp	r5, r3
    9550:	d1f9      	bne.n	9546 <id_create+0x56>
	    atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    9552:	2101      	movs	r1, #1
    9554:	4815      	ldr	r0, [pc, #84]	; (95ac <id_create+0xbc>)
    9556:	f018 ffa4 	bl	224a2 <atomic_test_bit>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
    955a:	b108      	cbz	r0, 9560 <id_create+0x70>
		bt_settings_save_id();
    955c:	f7fe fc58 	bl	7e10 <bt_settings_save_id>
}
    9560:	b006      	add	sp, #24
    9562:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			bt_addr_le_create_static(&new_addr);
    9566:	a802      	add	r0, sp, #8
    9568:	f019 f809 	bl	2257e <bt_addr_le_create_static>
		} while (id_find(&new_addr) >= 0);
    956c:	a802      	add	r0, sp, #8
    956e:	f7fe ffcd 	bl	850c <id_find>
    9572:	2800      	cmp	r0, #0
    9574:	daf7      	bge.n	9566 <id_create+0x76>
		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);
    9576:	a902      	add	r1, sp, #8
    9578:	4638      	mov	r0, r7
    957a:	f018 ff8b 	bl	22494 <bt_addr_le_copy>
		if (addr) {
    957e:	2e00      	cmp	r6, #0
    9580:	d0d0      	beq.n	9524 <id_create+0x34>
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
    9582:	4639      	mov	r1, r7
    9584:	4630      	mov	r0, r6
    9586:	e7cb      	b.n	9520 <id_create+0x30>
			bt_rand(&bt_dev.irk[id], 16);
    9588:	2110      	movs	r1, #16
    958a:	4620      	mov	r0, r4
    958c:	f008 fff6 	bl	1257c <bt_rand>
			if (irk) {
    9590:	2d00      	cmp	r5, #0
    9592:	d0de      	beq.n	9552 <id_create+0x62>
    9594:	4620      	mov	r0, r4
    9596:	f104 0310 	add.w	r3, r4, #16
    959a:	f850 2b04 	ldr.w	r2, [r0], #4
    959e:	f845 2b04 	str.w	r2, [r5], #4
    95a2:	4298      	cmp	r0, r3
    95a4:	d1f9      	bne.n	959a <id_create+0xaa>
    95a6:	e7d4      	b.n	9552 <id_create+0x62>
    95a8:	2000e4d8 	.word	0x2000e4d8
    95ac:	2000e548 	.word	0x2000e548

000095b0 <bt_recv>:
{
    95b0:	b570      	push	{r4, r5, r6, lr}
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
    95b2:	7d01      	ldrb	r1, [r0, #20]
	switch (bt_buf_get_type(buf)) {
    95b4:	2901      	cmp	r1, #1
{
    95b6:	4604      	mov	r4, r0
	switch (bt_buf_get_type(buf)) {
    95b8:	d054      	beq.n	9664 <bt_recv+0xb4>
    95ba:	2903      	cmp	r1, #3
    95bc:	f040 8084 	bne.w	96c8 <bt_recv+0x118>
	BT_ASSERT(buf->len >= sizeof(*hdr));
    95c0:	8983      	ldrh	r3, [r0, #12]
    95c2:	2b03      	cmp	r3, #3
    95c4:	d80c      	bhi.n	95e0 <bt_recv+0x30>
    95c6:	f240 237f 	movw	r3, #639	; 0x27f
    95ca:	4a49      	ldr	r2, [pc, #292]	; (96f0 <bt_recv+0x140>)
    95cc:	4949      	ldr	r1, [pc, #292]	; (96f4 <bt_recv+0x144>)
    95ce:	484a      	ldr	r0, [pc, #296]	; (96f8 <bt_recv+0x148>)
    95d0:	f016 fbef 	bl	1fdb2 <printk>
    95d4:	4040      	eors	r0, r0
    95d6:	f380 8811 	msr	BASEPRI, r0
    95da:	f04f 0003 	mov.w	r0, #3
    95de:	df02      	svc	2
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    95e0:	2104      	movs	r1, #4
    95e2:	f104 0008 	add.w	r0, r4, #8
    95e6:	f01b fc29 	bl	24e3c <net_buf_simple_pull_mem>
	if (buf->len != len) {
    95ea:	89a1      	ldrh	r1, [r4, #12]
	len = sys_le16_to_cpu(hdr->len);
    95ec:	8842      	ldrh	r2, [r0, #2]
	handle = sys_le16_to_cpu(hdr->handle);
    95ee:	8806      	ldrh	r6, [r0, #0]
	acl(buf)->id = BT_CONN_ID_INVALID;
    95f0:	23ff      	movs	r3, #255	; 0xff
	acl(buf)->handle = bt_acl_handle(handle);
    95f2:	f3c6 000b 	ubfx	r0, r6, #0, #12
	if (buf->len != len) {
    95f6:	428a      	cmp	r2, r1
	acl(buf)->handle = bt_acl_handle(handle);
    95f8:	82e0      	strh	r0, [r4, #22]
	acl(buf)->id = BT_CONN_ID_INVALID;
    95fa:	7563      	strb	r3, [r4, #21]
	if (buf->len != len) {
    95fc:	d011      	beq.n	9622 <bt_recv+0x72>
		BT_ERR("ACL data length mismatch (%u != %u)", buf->len, len);
    95fe:	2001      	movs	r0, #1
    9600:	f04f 0300 	mov.w	r3, #0
    9604:	f360 0307 	bfi	r3, r0, #0, #8
    9608:	4d3c      	ldr	r5, [pc, #240]	; (96fc <bt_recv+0x14c>)
    960a:	483d      	ldr	r0, [pc, #244]	; (9700 <bt_recv+0x150>)
    960c:	1b40      	subs	r0, r0, r5
    960e:	08c0      	lsrs	r0, r0, #3
    9610:	f360 138f 	bfi	r3, r0, #6, #10
    9614:	483b      	ldr	r0, [pc, #236]	; (9704 <bt_recv+0x154>)
    9616:	f017 fd31 	bl	2107c <log_2>
	net_buf_unref(buf);
    961a:	4620      	mov	r0, r4
    961c:	f00f fd1e 	bl	1905c <net_buf_unref>
    9620:	e01e      	b.n	9660 <bt_recv+0xb0>
	conn = bt_conn_lookup_handle(acl(buf)->handle);
    9622:	f001 fbeb 	bl	adfc <bt_conn_lookup_handle>
	if (!conn) {
    9626:	4605      	mov	r5, r0
    9628:	b978      	cbnz	r0, 964a <bt_recv+0x9a>
		BT_ERR("Unable to find conn for handle %u", acl(buf)->handle);
    962a:	2301      	movs	r3, #1
    962c:	f04f 0200 	mov.w	r2, #0
    9630:	f363 0207 	bfi	r2, r3, #0, #8
    9634:	4931      	ldr	r1, [pc, #196]	; (96fc <bt_recv+0x14c>)
    9636:	4b32      	ldr	r3, [pc, #200]	; (9700 <bt_recv+0x150>)
    9638:	4833      	ldr	r0, [pc, #204]	; (9708 <bt_recv+0x158>)
    963a:	1a5b      	subs	r3, r3, r1
    963c:	08db      	lsrs	r3, r3, #3
    963e:	f363 128f 	bfi	r2, r3, #6, #10
    9642:	8ae1      	ldrh	r1, [r4, #22]
    9644:	f017 fd06 	bl	21054 <log_1>
		net_buf_unref(buf);
    9648:	e7e7      	b.n	961a <bt_recv+0x6a>
	acl(buf)->id = bt_conn_index(conn);
    964a:	f001 fdbd 	bl	b1c8 <bt_conn_index>
	bt_conn_recv(conn, buf, flags);
    964e:	0b32      	lsrs	r2, r6, #12
	acl(buf)->id = bt_conn_index(conn);
    9650:	7560      	strb	r0, [r4, #21]
	bt_conn_recv(conn, buf, flags);
    9652:	4621      	mov	r1, r4
    9654:	4628      	mov	r0, r5
    9656:	f001 f961 	bl	a91c <bt_conn_recv>
	bt_conn_unref(conn);
    965a:	4628      	mov	r0, r5
    965c:	f019 f85f 	bl	2271e <bt_conn_unref>
		return 0;
    9660:	2000      	movs	r0, #0
}
    9662:	bd70      	pop	{r4, r5, r6, pc}
	BT_ASSERT(buf->len >= sizeof(*hdr));
    9664:	8983      	ldrh	r3, [r0, #12]
    9666:	2b01      	cmp	r3, #1
    9668:	d80c      	bhi.n	9684 <bt_recv+0xd4>
    966a:	f640 7339 	movw	r3, #3897	; 0xf39
    966e:	4a20      	ldr	r2, [pc, #128]	; (96f0 <bt_recv+0x140>)
    9670:	4920      	ldr	r1, [pc, #128]	; (96f4 <bt_recv+0x144>)
    9672:	4821      	ldr	r0, [pc, #132]	; (96f8 <bt_recv+0x148>)
    9674:	f016 fb9d 	bl	1fdb2 <printk>
    9678:	4040      	eors	r0, r0
    967a:	f380 8811 	msr	BASEPRI, r0
    967e:	f04f 0003 	mov.w	r0, #3
    9682:	df02      	svc	2
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    9684:	2102      	movs	r1, #2
    9686:	f104 0008 	add.w	r0, r4, #8
    968a:	f01b fbd7 	bl	24e3c <net_buf_simple_pull_mem>
	BT_ASSERT(!bt_hci_evt_is_prio(hdr->evt));
    968e:	7802      	ldrb	r2, [r0, #0]
    9690:	2a1a      	cmp	r2, #26
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    9692:	4605      	mov	r5, r0
 * @return true if the event can be processed in the RX thread, false
 *         if it cannot.
 */
static inline bool bt_hci_evt_is_prio(u8_t evt)
{
	switch (evt) {
    9694:	d811      	bhi.n	96ba <bt_recv+0x10a>
    9696:	2301      	movs	r3, #1
    9698:	4093      	lsls	r3, r2
    969a:	4a1c      	ldr	r2, [pc, #112]	; (970c <bt_recv+0x15c>)
    969c:	4213      	tst	r3, r2
    969e:	d00c      	beq.n	96ba <bt_recv+0x10a>
	BT_ASSERT(!bt_hci_evt_is_prio(hdr->evt));
    96a0:	f640 733d 	movw	r3, #3901	; 0xf3d
    96a4:	4a12      	ldr	r2, [pc, #72]	; (96f0 <bt_recv+0x140>)
    96a6:	491a      	ldr	r1, [pc, #104]	; (9710 <bt_recv+0x160>)
    96a8:	4813      	ldr	r0, [pc, #76]	; (96f8 <bt_recv+0x148>)
    96aa:	f016 fb82 	bl	1fdb2 <printk>
    96ae:	4040      	eors	r0, r0
    96b0:	f380 8811 	msr	BASEPRI, r0
    96b4:	f04f 0003 	mov.w	r0, #3
    96b8:	df02      	svc	2
	handle_event(hdr->evt, buf, normal_events, ARRAY_SIZE(normal_events));
    96ba:	2305      	movs	r3, #5
    96bc:	4a15      	ldr	r2, [pc, #84]	; (9714 <bt_recv+0x164>)
    96be:	7828      	ldrb	r0, [r5, #0]
    96c0:	4621      	mov	r1, r4
    96c2:	f7fe fe49 	bl	8358 <handle_event>
    96c6:	e7a8      	b.n	961a <bt_recv+0x6a>
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
    96c8:	2301      	movs	r3, #1
    96ca:	f04f 0200 	mov.w	r2, #0
    96ce:	f363 0207 	bfi	r2, r3, #0, #8
    96d2:	480a      	ldr	r0, [pc, #40]	; (96fc <bt_recv+0x14c>)
    96d4:	4b0a      	ldr	r3, [pc, #40]	; (9700 <bt_recv+0x150>)
    96d6:	1a1b      	subs	r3, r3, r0
    96d8:	08db      	lsrs	r3, r3, #3
    96da:	f363 128f 	bfi	r2, r3, #6, #10
    96de:	480e      	ldr	r0, [pc, #56]	; (9718 <bt_recv+0x168>)
    96e0:	f017 fcb8 	bl	21054 <log_1>
		net_buf_unref(buf);
    96e4:	4620      	mov	r0, r4
    96e6:	f00f fcb9 	bl	1905c <net_buf_unref>
		return -EINVAL;
    96ea:	f06f 0015 	mvn.w	r0, #21
    96ee:	e7b8      	b.n	9662 <bt_recv+0xb2>
    96f0:	000632c8 	.word	0x000632c8
    96f4:	00062f66 	.word	0x00062f66
    96f8:	000632fe 	.word	0x000632fe
    96fc:	00028540 	.word	0x00028540
    9700:	00028610 	.word	0x00028610
    9704:	00062f7f 	.word	0x00062f7f
    9708:	00062fa3 	.word	0x00062fa3
    970c:	0408c000 	.word	0x0408c000
    9710:	00062fc5 	.word	0x00062fc5
    9714:	00028ebc 	.word	0x00028ebc
    9718:	00062fe3 	.word	0x00062fe3

0000971c <bt_recv_prio>:
{
    971c:	b538      	push	{r3, r4, r5, lr}
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
    971e:	7d03      	ldrb	r3, [r0, #20]
    9720:	2b01      	cmp	r3, #1
{
    9722:	4604      	mov	r4, r0
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
    9724:	d00c      	beq.n	9740 <bt_recv_prio+0x24>
    9726:	f241 33a6 	movw	r3, #5030	; 0x13a6
    972a:	4a20      	ldr	r2, [pc, #128]	; (97ac <bt_recv_prio+0x90>)
    972c:	4920      	ldr	r1, [pc, #128]	; (97b0 <bt_recv_prio+0x94>)
    972e:	4821      	ldr	r0, [pc, #132]	; (97b4 <bt_recv_prio+0x98>)
    9730:	f016 fb3f 	bl	1fdb2 <printk>
    9734:	4040      	eors	r0, r0
    9736:	f380 8811 	msr	BASEPRI, r0
    973a:	f04f 0003 	mov.w	r0, #3
    973e:	df02      	svc	2
	BT_ASSERT(buf->len >= sizeof(*hdr));
    9740:	89a3      	ldrh	r3, [r4, #12]
    9742:	2b01      	cmp	r3, #1
    9744:	d80c      	bhi.n	9760 <bt_recv_prio+0x44>
    9746:	f241 33a7 	movw	r3, #5031	; 0x13a7
    974a:	4a18      	ldr	r2, [pc, #96]	; (97ac <bt_recv_prio+0x90>)
    974c:	491a      	ldr	r1, [pc, #104]	; (97b8 <bt_recv_prio+0x9c>)
    974e:	4819      	ldr	r0, [pc, #100]	; (97b4 <bt_recv_prio+0x98>)
    9750:	f016 fb2f 	bl	1fdb2 <printk>
    9754:	4040      	eors	r0, r0
    9756:	f380 8811 	msr	BASEPRI, r0
    975a:	f04f 0003 	mov.w	r0, #3
    975e:	df02      	svc	2
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    9760:	2102      	movs	r1, #2
    9762:	f104 0008 	add.w	r0, r4, #8
    9766:	f01b fb69 	bl	24e3c <net_buf_simple_pull_mem>
	BT_ASSERT(bt_hci_evt_is_prio(hdr->evt));
    976a:	7802      	ldrb	r2, [r0, #0]
    976c:	2a1a      	cmp	r2, #26
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    976e:	4605      	mov	r5, r0
    9770:	d804      	bhi.n	977c <bt_recv_prio+0x60>
    9772:	2301      	movs	r3, #1
    9774:	4093      	lsls	r3, r2
    9776:	4a11      	ldr	r2, [pc, #68]	; (97bc <bt_recv_prio+0xa0>)
    9778:	4213      	tst	r3, r2
    977a:	d10c      	bne.n	9796 <bt_recv_prio+0x7a>
	BT_ASSERT(bt_hci_evt_is_prio(hdr->evt));
    977c:	f241 33aa 	movw	r3, #5034	; 0x13aa
    9780:	4a0a      	ldr	r2, [pc, #40]	; (97ac <bt_recv_prio+0x90>)
    9782:	490f      	ldr	r1, [pc, #60]	; (97c0 <bt_recv_prio+0xa4>)
    9784:	480b      	ldr	r0, [pc, #44]	; (97b4 <bt_recv_prio+0x98>)
    9786:	f016 fb14 	bl	1fdb2 <printk>
    978a:	4040      	eors	r0, r0
    978c:	f380 8811 	msr	BASEPRI, r0
    9790:	f04f 0003 	mov.w	r0, #3
    9794:	df02      	svc	2
	handle_event(hdr->evt, buf, prio_events, ARRAY_SIZE(prio_events));
    9796:	2304      	movs	r3, #4
    9798:	4a0a      	ldr	r2, [pc, #40]	; (97c4 <bt_recv_prio+0xa8>)
    979a:	7828      	ldrb	r0, [r5, #0]
    979c:	4621      	mov	r1, r4
    979e:	f7fe fddb 	bl	8358 <handle_event>
	net_buf_unref(buf);
    97a2:	4620      	mov	r0, r4
    97a4:	f00f fc5a 	bl	1905c <net_buf_unref>
}
    97a8:	2000      	movs	r0, #0
    97aa:	bd38      	pop	{r3, r4, r5, pc}
    97ac:	000632c8 	.word	0x000632c8
    97b0:	00062ff7 	.word	0x00062ff7
    97b4:	000632fe 	.word	0x000632fe
    97b8:	00062f66 	.word	0x00062f66
    97bc:	0408c000 	.word	0x0408c000
    97c0:	00062fc6 	.word	0x00062fc6
    97c4:	00028ef4 	.word	0x00028ef4

000097c8 <bt_hci_driver_register>:
	if (bt_dev.drv) {
    97c8:	4a08      	ldr	r2, [pc, #32]	; (97ec <bt_hci_driver_register+0x24>)
    97ca:	f8d2 30d8 	ldr.w	r3, [r2, #216]	; 0xd8
    97ce:	b93b      	cbnz	r3, 97e0 <bt_hci_driver_register+0x18>
	if (!drv->open || !drv->send) {
    97d0:	68c1      	ldr	r1, [r0, #12]
    97d2:	b141      	cbz	r1, 97e6 <bt_hci_driver_register+0x1e>
    97d4:	6901      	ldr	r1, [r0, #16]
    97d6:	b131      	cbz	r1, 97e6 <bt_hci_driver_register+0x1e>
	bt_dev.drv = drv;
    97d8:	f8c2 00d8 	str.w	r0, [r2, #216]	; 0xd8
	return 0;
    97dc:	4618      	mov	r0, r3
    97de:	4770      	bx	lr
		return -EALREADY;
    97e0:	f06f 0077 	mvn.w	r0, #119	; 0x77
    97e4:	4770      	bx	lr
		return -EINVAL;
    97e6:	f06f 0015 	mvn.w	r0, #21
}
    97ea:	4770      	bx	lr
    97ec:	2000e4d8 	.word	0x2000e4d8

000097f0 <bt_finalize_init>:
{
    97f0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    97f4:	4c37      	ldr	r4, [pc, #220]	; (98d4 <bt_finalize_init+0xe4>)
    97f6:	4d38      	ldr	r5, [pc, #224]	; (98d8 <bt_finalize_init+0xe8>)
	BT_INFO("Identity%s: %s", bt_dev.id_count > 1 ? "[0]" : "",
    97f8:	4e38      	ldr	r6, [pc, #224]	; (98dc <bt_finalize_init+0xec>)
		BT_INFO("Identity[%d]: %s",
    97fa:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 98f4 <bt_finalize_init+0x104>
{
    97fe:	b087      	sub	sp, #28
    9800:	2102      	movs	r1, #2
    9802:	f104 0070 	add.w	r0, r4, #112	; 0x70
    9806:	f018 fdf0 	bl	223ea <atomic_or>
	BT_INFO("Identity%s: %s", bt_dev.id_count > 1 ? "[0]" : "",
    980a:	f04f 0700 	mov.w	r7, #0
    980e:	2303      	movs	r3, #3
    9810:	f363 0707 	bfi	r7, r3, #0, #8
    9814:	4b32      	ldr	r3, [pc, #200]	; (98e0 <bt_finalize_init+0xf0>)
    9816:	4933      	ldr	r1, [pc, #204]	; (98e4 <bt_finalize_init+0xf4>)
    9818:	1aed      	subs	r5, r5, r3
    981a:	79e3      	ldrb	r3, [r4, #7]
    981c:	4620      	mov	r0, r4
    981e:	2b01      	cmp	r3, #1
    9820:	bf88      	it	hi
    9822:	460e      	movhi	r6, r1
    9824:	f7fd ffe0 	bl	77e8 <bt_addr_le_str_real>
    9828:	f7fb fa6a 	bl	4d00 <log_strdup>
    982c:	f3c5 05c9 	ubfx	r5, r5, #3, #10
    9830:	f365 178f 	bfi	r7, r5, #6, #10
    9834:	463b      	mov	r3, r7
    9836:	4602      	mov	r2, r0
    9838:	4631      	mov	r1, r6
    983a:	482b      	ldr	r0, [pc, #172]	; (98e8 <bt_finalize_init+0xf8>)
    983c:	f017 fc1e 	bl	2107c <log_2>
	for (i = 1; i < bt_dev.id_count; i++) {
    9840:	4627      	mov	r7, r4
    9842:	2601      	movs	r6, #1
    9844:	79e3      	ldrb	r3, [r4, #7]
    9846:	429e      	cmp	r6, r3
    9848:	f107 0707 	add.w	r7, r7, #7
    984c:	db2c      	blt.n	98a8 <bt_finalize_init+0xb8>
	BT_INFO("HCI: version %s (0x%02x) revision 0x%04x, manufacturer 0x%04x",
    984e:	7c27      	ldrb	r7, [r4, #16]
    9850:	2303      	movs	r3, #3
    9852:	4638      	mov	r0, r7
    9854:	f04f 0600 	mov.w	r6, #0
    9858:	f363 0607 	bfi	r6, r3, #0, #8
    985c:	f7fe fbac 	bl	7fb8 <ver_str>
    9860:	8a63      	ldrh	r3, [r4, #18]
    9862:	9304      	str	r3, [sp, #16]
    9864:	f365 168f 	bfi	r6, r5, #6, #10
    9868:	8ae3      	ldrh	r3, [r4, #22]
    986a:	9305      	str	r3, [sp, #20]
    986c:	a902      	add	r1, sp, #8
    986e:	e9cd 0702 	strd	r0, r7, [sp, #8]
    9872:	4633      	mov	r3, r6
    9874:	2204      	movs	r2, #4
    9876:	481d      	ldr	r0, [pc, #116]	; (98ec <bt_finalize_init+0xfc>)
    9878:	f017 fc33 	bl	210e2 <log_n>
	BT_INFO("LMP: version %s (0x%02x) subver 0x%04x",
    987c:	f04f 0600 	mov.w	r6, #0
    9880:	2303      	movs	r3, #3
    9882:	f363 0607 	bfi	r6, r3, #0, #8
    9886:	f365 168f 	bfi	r6, r5, #6, #10
    988a:	7c65      	ldrb	r5, [r4, #17]
    988c:	4628      	mov	r0, r5
    988e:	f7fe fb93 	bl	7fb8 <ver_str>
    9892:	f8ad 6000 	strh.w	r6, [sp]
    9896:	4601      	mov	r1, r0
    9898:	8aa3      	ldrh	r3, [r4, #20]
    989a:	4815      	ldr	r0, [pc, #84]	; (98f0 <bt_finalize_init+0x100>)
    989c:	462a      	mov	r2, r5
    989e:	f017 fc05 	bl	210ac <log_3>
}
    98a2:	b007      	add	sp, #28
    98a4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		BT_INFO("Identity[%d]: %s",
    98a8:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
    98ac:	f043 0303 	orr.w	r3, r3, #3
    98b0:	4638      	mov	r0, r7
    98b2:	f363 0807 	bfi	r8, r3, #0, #8
    98b6:	f7fd ff97 	bl	77e8 <bt_addr_le_str_real>
    98ba:	f7fb fa21 	bl	4d00 <log_strdup>
    98be:	f365 188f 	bfi	r8, r5, #6, #10
    98c2:	4602      	mov	r2, r0
    98c4:	4631      	mov	r1, r6
    98c6:	4643      	mov	r3, r8
    98c8:	4648      	mov	r0, r9
    98ca:	f017 fbd7 	bl	2107c <log_2>
	for (i = 1; i < bt_dev.id_count; i++) {
    98ce:	3601      	adds	r6, #1
    98d0:	e7b8      	b.n	9844 <bt_finalize_init+0x54>
    98d2:	bf00      	nop
    98d4:	2000e4d8 	.word	0x2000e4d8
    98d8:	00028610 	.word	0x00028610
    98dc:	000620f5 	.word	0x000620f5
    98e0:	00028540 	.word	0x00028540
    98e4:	00062bbb 	.word	0x00062bbb
    98e8:	00062bbf 	.word	0x00062bbf
    98ec:	00062bdf 	.word	0x00062bdf
    98f0:	00062c1d 	.word	0x00062c1d
    98f4:	00062bce 	.word	0x00062bce

000098f8 <init_work>:
{
    98f8:	b510      	push	{r4, lr}
	err = bt_init();
    98fa:	f7f8 fad5 	bl	1ea8 <bt_init>
	if (ready_cb) {
    98fe:	4b03      	ldr	r3, [pc, #12]	; (990c <init_work+0x14>)
    9900:	681b      	ldr	r3, [r3, #0]
    9902:	b113      	cbz	r3, 990a <init_work+0x12>
}
    9904:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ready_cb(err);
    9908:	4718      	bx	r3
}
    990a:	bd10      	pop	{r4, pc}
    990c:	20000330 	.word	0x20000330

00009910 <bt_enable>:
{
    9910:	b570      	push	{r4, r5, r6, lr}
	if (!bt_dev.drv) {
    9912:	4d34      	ldr	r5, [pc, #208]	; (99e4 <bt_enable+0xd4>)
    9914:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
{
    9918:	b086      	sub	sp, #24
    991a:	4606      	mov	r6, r0
	if (!bt_dev.drv) {
    991c:	b993      	cbnz	r3, 9944 <bt_enable+0x34>
		BT_ERR("No HCI driver registered");
    991e:	2301      	movs	r3, #1
    9920:	f04f 0100 	mov.w	r1, #0
    9924:	f363 0107 	bfi	r1, r3, #0, #8
    9928:	4a2f      	ldr	r2, [pc, #188]	; (99e8 <bt_enable+0xd8>)
    992a:	4b30      	ldr	r3, [pc, #192]	; (99ec <bt_enable+0xdc>)
    992c:	4830      	ldr	r0, [pc, #192]	; (99f0 <bt_enable+0xe0>)
    992e:	1a9b      	subs	r3, r3, r2
    9930:	08db      	lsrs	r3, r3, #3
    9932:	f363 118f 	bfi	r1, r3, #6, #10
    9936:	f017 fb80 	bl	2103a <log_0>
		return -ENODEV;
    993a:	f06f 0412 	mvn.w	r4, #18
}
    993e:	4620      	mov	r0, r4
    9940:	b006      	add	sp, #24
    9942:	bd70      	pop	{r4, r5, r6, pc}
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    9944:	2101      	movs	r1, #1
    9946:	f105 0070 	add.w	r0, r5, #112	; 0x70
    994a:	f018 fd4e 	bl	223ea <atomic_or>
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_ENABLE)) {
    994e:	07c2      	lsls	r2, r0, #31
    9950:	d444      	bmi.n	99dc <bt_enable+0xcc>
		err = bt_settings_init();
    9952:	f7fe fac1 	bl	7ed8 <bt_settings_init>
		if (err) {
    9956:	4604      	mov	r4, r0
    9958:	2800      	cmp	r0, #0
    995a:	d1f0      	bne.n	993e <bt_enable+0x2e>
	ready_cb = cb;
    995c:	4b25      	ldr	r3, [pc, #148]	; (99f4 <bt_enable+0xe4>)
    995e:	601e      	str	r6, [r3, #0]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    9960:	f06f 0308 	mvn.w	r3, #8
    9964:	e9cd 0302 	strd	r0, r3, [sp, #8]
    9968:	e9cd 0004 	strd	r0, r0, [sp, #16]
    996c:	e9cd 0000 	strd	r0, r0, [sp]
    9970:	4b21      	ldr	r3, [pc, #132]	; (99f8 <bt_enable+0xe8>)
    9972:	4922      	ldr	r1, [pc, #136]	; (99fc <bt_enable+0xec>)
    9974:	4822      	ldr	r0, [pc, #136]	; (9a00 <bt_enable+0xf0>)
    9976:	f44f 7220 	mov.w	r2, #640	; 0x280
    997a:	f015 faa3 	bl	1eec4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    997e:	4921      	ldr	r1, [pc, #132]	; (9a04 <bt_enable+0xf4>)
    9980:	481f      	ldr	r0, [pc, #124]	; (9a00 <bt_enable+0xf0>)
    9982:	f01e fa4d 	bl	27e20 <z_impl_k_thread_name_set>
		bt_hci_ecc_init();
    9986:	f7fe f8e3 	bl	7b50 <bt_hci_ecc_init>
	err = bt_dev.drv->open();
    998a:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
    998e:	68db      	ldr	r3, [r3, #12]
    9990:	4798      	blx	r3
	if (err) {
    9992:	4604      	mov	r4, r0
    9994:	b178      	cbz	r0, 99b6 <bt_enable+0xa6>
		BT_ERR("HCI driver open failed (%d)", err);
    9996:	2301      	movs	r3, #1
    9998:	f04f 0200 	mov.w	r2, #0
    999c:	f363 0207 	bfi	r2, r3, #0, #8
    99a0:	4911      	ldr	r1, [pc, #68]	; (99e8 <bt_enable+0xd8>)
    99a2:	4b12      	ldr	r3, [pc, #72]	; (99ec <bt_enable+0xdc>)
    99a4:	1a5b      	subs	r3, r3, r1
    99a6:	08db      	lsrs	r3, r3, #3
    99a8:	4601      	mov	r1, r0
    99aa:	f363 128f 	bfi	r2, r3, #6, #10
    99ae:	4816      	ldr	r0, [pc, #88]	; (9a08 <bt_enable+0xf8>)
    99b0:	f017 fb50 	bl	21054 <log_1>
		return err;
    99b4:	e7c3      	b.n	993e <bt_enable+0x2e>
	if (!cb) {
    99b6:	b926      	cbnz	r6, 99c2 <bt_enable+0xb2>
}
    99b8:	b006      	add	sp, #24
    99ba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_init();
    99be:	f7f8 ba73 	b.w	1ea8 <bt_init>
    99c2:	2101      	movs	r1, #1
    99c4:	f105 006c 	add.w	r0, r5, #108	; 0x6c
    99c8:	f018 fd0f 	bl	223ea <atomic_or>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    99cc:	07c3      	lsls	r3, r0, #31
    99ce:	d4b6      	bmi.n	993e <bt_enable+0x2e>
		k_queue_append(&work_q->queue, work);
    99d0:	f105 0164 	add.w	r1, r5, #100	; 0x64
    99d4:	480d      	ldr	r0, [pc, #52]	; (9a0c <bt_enable+0xfc>)
    99d6:	f01e f896 	bl	27b06 <k_queue_append>
    99da:	e7b0      	b.n	993e <bt_enable+0x2e>
		return -EALREADY;
    99dc:	f06f 0477 	mvn.w	r4, #119	; 0x77
    99e0:	e7ad      	b.n	993e <bt_enable+0x2e>
    99e2:	bf00      	nop
    99e4:	2000e4d8 	.word	0x2000e4d8
    99e8:	00028540 	.word	0x00028540
    99ec:	00028610 	.word	0x00028610
    99f0:	00062b80 	.word	0x00062b80
    99f4:	20000330 	.word	0x20000330
    99f8:	00008541 	.word	0x00008541
    99fc:	2000b4a8 	.word	0x2000b4a8
    9a00:	20000334 	.word	0x20000334
    9a04:	00062b99 	.word	0x00062b99
    9a08:	00062b9f 	.word	0x00062b9f
    9a0c:	20006090 	.word	0x20006090

00009a10 <bt_set_name>:
{
    9a10:	b530      	push	{r4, r5, lr}
    9a12:	b085      	sub	sp, #20
    9a14:	4604      	mov	r4, r0
	size_t len = strlen(name);
    9a16:	f7f8 f947 	bl	1ca8 <strlen>
	if (len >= sizeof(bt_dev.name)) {
    9a1a:	2841      	cmp	r0, #65	; 0x41
	size_t len = strlen(name);
    9a1c:	4605      	mov	r5, r0
	if (len >= sizeof(bt_dev.name)) {
    9a1e:	d839      	bhi.n	9a94 <bt_set_name+0x84>
	if (!strcmp(bt_dev.name, name)) {
    9a20:	4621      	mov	r1, r4
    9a22:	481e      	ldr	r0, [pc, #120]	; (9a9c <bt_set_name+0x8c>)
    9a24:	f7f8 f92e 	bl	1c84 <strcmp>
    9a28:	b910      	cbnz	r0, 9a30 <bt_set_name+0x20>
	return 0;
    9a2a:	2000      	movs	r0, #0
}
    9a2c:	b005      	add	sp, #20
    9a2e:	bd30      	pop	{r4, r5, pc}
	strncpy(bt_dev.name, name, sizeof(bt_dev.name));
    9a30:	4621      	mov	r1, r4
    9a32:	2242      	movs	r2, #66	; 0x42
    9a34:	4819      	ldr	r0, [pc, #100]	; (9a9c <bt_set_name+0x8c>)
    9a36:	f7f8 f951 	bl	1cdc <strncpy>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING_NAME)) {
    9a3a:	2106      	movs	r1, #6
    9a3c:	4818      	ldr	r0, [pc, #96]	; (9aa0 <bt_set_name+0x90>)
    9a3e:	f018 fd30 	bl	224a2 <atomic_test_bit>
    9a42:	b188      	cbz	r0, 9a68 <bt_set_name+0x58>
		struct bt_data data[] = { BT_DATA(BT_DATA_NAME_COMPLETE, name,
    9a44:	2309      	movs	r3, #9
    9a46:	4620      	mov	r0, r4
    9a48:	f88d 3000 	strb.w	r3, [sp]
    9a4c:	f7f8 f92c 	bl	1ca8 <strlen>
		struct bt_ad sd = { data, ARRAY_SIZE(data) };
    9a50:	2201      	movs	r2, #1
		struct bt_data data[] = { BT_DATA(BT_DATA_NAME_COMPLETE, name,
    9a52:	f88d 0001 	strb.w	r0, [sp, #1]
		set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, &sd, 1);
    9a56:	a902      	add	r1, sp, #8
    9a58:	f242 0009 	movw	r0, #8201	; 0x2009
		struct bt_data data[] = { BT_DATA(BT_DATA_NAME_COMPLETE, name,
    9a5c:	9401      	str	r4, [sp, #4]
		struct bt_ad sd = { data, ARRAY_SIZE(data) };
    9a5e:	f8cd d008 	str.w	sp, [sp, #8]
    9a62:	9203      	str	r2, [sp, #12]
		set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, &sd, 1);
    9a64:	f7ff f9bc 	bl	8de0 <set_ad>
		err = settings_save_one("bt/name", bt_dev.name, len);
    9a68:	462a      	mov	r2, r5
    9a6a:	490c      	ldr	r1, [pc, #48]	; (9a9c <bt_set_name+0x8c>)
    9a6c:	480d      	ldr	r0, [pc, #52]	; (9aa4 <bt_set_name+0x94>)
    9a6e:	f7fc fae3 	bl	6038 <settings_save_one>
		if (err) {
    9a72:	2800      	cmp	r0, #0
    9a74:	d0d9      	beq.n	9a2a <bt_set_name+0x1a>
			BT_WARN("Unable to store name");
    9a76:	2302      	movs	r3, #2
    9a78:	f04f 0100 	mov.w	r1, #0
    9a7c:	f363 0107 	bfi	r1, r3, #0, #8
    9a80:	4a09      	ldr	r2, [pc, #36]	; (9aa8 <bt_set_name+0x98>)
    9a82:	4b0a      	ldr	r3, [pc, #40]	; (9aac <bt_set_name+0x9c>)
    9a84:	480a      	ldr	r0, [pc, #40]	; (9ab0 <bt_set_name+0xa0>)
    9a86:	1a9b      	subs	r3, r3, r2
    9a88:	08db      	lsrs	r3, r3, #3
    9a8a:	f363 118f 	bfi	r1, r3, #6, #10
    9a8e:	f017 fad4 	bl	2103a <log_0>
    9a92:	e7ca      	b.n	9a2a <bt_set_name+0x1a>
		return -ENOMEM;
    9a94:	f06f 000b 	mvn.w	r0, #11
    9a98:	e7c8      	b.n	9a2c <bt_set_name+0x1c>
    9a9a:	bf00      	nop
    9a9c:	2000e5e4 	.word	0x2000e5e4
    9aa0:	2000e548 	.word	0x2000e548
    9aa4:	0006301a 	.word	0x0006301a
    9aa8:	00028540 	.word	0x00028540
    9aac:	00028610 	.word	0x00028610
    9ab0:	00063022 	.word	0x00063022

00009ab4 <bt_get_name>:
}
    9ab4:	4800      	ldr	r0, [pc, #0]	; (9ab8 <bt_get_name+0x4>)
    9ab6:	4770      	bx	lr
    9ab8:	2000e5e4 	.word	0x2000e5e4

00009abc <bt_id_create>:
{
    9abc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    9abe:	460e      	mov	r6, r1
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    9ac0:	4605      	mov	r5, r0
    9ac2:	b930      	cbnz	r0, 9ad2 <bt_id_create+0x16>
	if (bt_dev.id_count == ARRAY_SIZE(bt_dev.id_addr)) {
    9ac4:	4b1d      	ldr	r3, [pc, #116]	; (9b3c <bt_id_create+0x80>)
    9ac6:	79dc      	ldrb	r4, [r3, #7]
    9ac8:	2c01      	cmp	r4, #1
    9aca:	d12f      	bne.n	9b2c <bt_id_create+0x70>
		return -ENOMEM;
    9acc:	f06f 040b 	mvn.w	r4, #11
    9ad0:	e021      	b.n	9b16 <bt_id_create+0x5a>
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    9ad2:	2300      	movs	r3, #0
    9ad4:	2207      	movs	r2, #7
    9ad6:	4669      	mov	r1, sp
    9ad8:	9300      	str	r3, [sp, #0]
    9ada:	f8cd 3003 	str.w	r3, [sp, #3]
    9ade:	f7f8 f877 	bl	1bd0 <memcmp>
    9ae2:	2800      	cmp	r0, #0
    9ae4:	d0ee      	beq.n	9ac4 <bt_id_create+0x8>
		if (addr->type != BT_ADDR_LE_RANDOM ||
    9ae6:	782b      	ldrb	r3, [r5, #0]
    9ae8:	2b01      	cmp	r3, #1
    9aea:	d104      	bne.n	9af6 <bt_id_create+0x3a>
    9aec:	79ab      	ldrb	r3, [r5, #6]
    9aee:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    9af2:	2bc0      	cmp	r3, #192	; 0xc0
    9af4:	d012      	beq.n	9b1c <bt_id_create+0x60>
			BT_ERR("Only static random identity address supported");
    9af6:	2301      	movs	r3, #1
    9af8:	f04f 0100 	mov.w	r1, #0
    9afc:	f363 0107 	bfi	r1, r3, #0, #8
    9b00:	4a0f      	ldr	r2, [pc, #60]	; (9b40 <bt_id_create+0x84>)
    9b02:	4b10      	ldr	r3, [pc, #64]	; (9b44 <bt_id_create+0x88>)
    9b04:	4810      	ldr	r0, [pc, #64]	; (9b48 <bt_id_create+0x8c>)
    9b06:	1a9b      	subs	r3, r3, r2
    9b08:	08db      	lsrs	r3, r3, #3
    9b0a:	f363 118f 	bfi	r1, r3, #6, #10
    9b0e:	f017 fa94 	bl	2103a <log_0>
			return -EINVAL;
    9b12:	f06f 0415 	mvn.w	r4, #21
}
    9b16:	4620      	mov	r0, r4
    9b18:	b002      	add	sp, #8
    9b1a:	bd70      	pop	{r4, r5, r6, pc}
		if (id_find(addr) >= 0) {
    9b1c:	4628      	mov	r0, r5
    9b1e:	f7fe fcf5 	bl	850c <id_find>
    9b22:	2800      	cmp	r0, #0
    9b24:	dbce      	blt.n	9ac4 <bt_id_create+0x8>
			return -EALREADY;
    9b26:	f06f 0477 	mvn.w	r4, #119	; 0x77
    9b2a:	e7f4      	b.n	9b16 <bt_id_create+0x5a>
	new_id = bt_dev.id_count++;
    9b2c:	1c62      	adds	r2, r4, #1
    9b2e:	71da      	strb	r2, [r3, #7]
	id_create(new_id, addr, irk);
    9b30:	4629      	mov	r1, r5
    9b32:	4632      	mov	r2, r6
    9b34:	4620      	mov	r0, r4
    9b36:	f7ff fcdb 	bl	94f0 <id_create>
	return new_id;
    9b3a:	e7ec      	b.n	9b16 <bt_id_create+0x5a>
    9b3c:	2000e4d8 	.word	0x2000e4d8
    9b40:	00028540 	.word	0x00028540
    9b44:	00028610 	.word	0x00028610
    9b48:	00062d1f 	.word	0x00062d1f

00009b4c <bt_setup_public_id_addr>:
{
    9b4c:	b570      	push	{r4, r5, r6, lr}
    9b4e:	b08e      	sub	sp, #56	; 0x38
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
    9b50:	aa0a      	add	r2, sp, #40	; 0x28
    9b52:	2100      	movs	r1, #0
    9b54:	f241 0009 	movw	r0, #4105	; 0x1009
    9b58:	f7ff f806 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    9b5c:	4e3e      	ldr	r6, [pc, #248]	; (9c58 <bt_setup_public_id_addr+0x10c>)
    9b5e:	4604      	mov	r4, r0
    9b60:	b188      	cbz	r0, 9b86 <bt_setup_public_id_addr+0x3a>
		BT_WARN("Failed to read public address");
    9b62:	2302      	movs	r3, #2
    9b64:	f04f 0100 	mov.w	r1, #0
    9b68:	f363 0107 	bfi	r1, r3, #0, #8
    9b6c:	4a3b      	ldr	r2, [pc, #236]	; (9c5c <bt_setup_public_id_addr+0x110>)
    9b6e:	4b3c      	ldr	r3, [pc, #240]	; (9c60 <bt_setup_public_id_addr+0x114>)
    9b70:	483c      	ldr	r0, [pc, #240]	; (9c64 <bt_setup_public_id_addr+0x118>)
    9b72:	1a9b      	subs	r3, r3, r2
    9b74:	08db      	lsrs	r3, r3, #3
    9b76:	f363 118f 	bfi	r1, r3, #6, #10
    9b7a:	f017 fa5e 	bl	2103a <log_0>
	bt_dev.id_count = bt_read_public_addr(&addr);
    9b7e:	2300      	movs	r3, #0
    9b80:	71f3      	strb	r3, [r6, #7]
}
    9b82:	b00e      	add	sp, #56	; 0x38
    9b84:	bd70      	pop	{r4, r5, r6, pc}
	rp = (void *)rsp->data;
    9b86:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    9b88:	9002      	str	r0, [sp, #8]
    9b8a:	689d      	ldr	r5, [r3, #8]
    9b8c:	f8ad 000c 	strh.w	r0, [sp, #12]
    9b90:	3501      	adds	r5, #1
	return memcmp(a, b, sizeof(*a));
    9b92:	2206      	movs	r2, #6
    9b94:	a902      	add	r1, sp, #8
    9b96:	4628      	mov	r0, r5
    9b98:	f7f8 f81a 	bl	1bd0 <memcmp>
    9b9c:	b918      	cbnz	r0, 9ba6 <bt_setup_public_id_addr+0x5a>
		net_buf_unref(rsp);
    9b9e:	980a      	ldr	r0, [sp, #40]	; 0x28
    9ba0:	f00f fa5c 	bl	1905c <net_buf_unref>
    9ba4:	e7eb      	b.n	9b7e <bt_setup_public_id_addr+0x32>
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
    9ba6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    9baa:	2206      	movs	r2, #6
    9bac:	4669      	mov	r1, sp
    9bae:	4628      	mov	r0, r5
    9bb0:	9300      	str	r3, [sp, #0]
    9bb2:	f8ad 3004 	strh.w	r3, [sp, #4]
    9bb6:	f7f8 f80b 	bl	1bd0 <memcmp>
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    9bba:	2800      	cmp	r0, #0
    9bbc:	d0ef      	beq.n	9b9e <bt_setup_public_id_addr+0x52>
	bt_addr_copy(&addr->a, &rp->bdaddr);
    9bbe:	4629      	mov	r1, r5
    9bc0:	f10d 0011 	add.w	r0, sp, #17
    9bc4:	f018 fc61 	bl	2248a <bt_addr_copy>
	net_buf_unref(rsp);
    9bc8:	980a      	ldr	r0, [sp, #40]	; 0x28
	addr->type = BT_ADDR_LE_PUBLIC;
    9bca:	f88d 4010 	strb.w	r4, [sp, #16]
	net_buf_unref(rsp);
    9bce:	f00f fa45 	bl	1905c <net_buf_unref>
	bt_dev.id_count = bt_read_public_addr(&addr);
    9bd2:	2301      	movs	r3, #1
	memset(ir, 0, 16);
    9bd4:	2210      	movs	r2, #16
    9bd6:	4621      	mov	r1, r4
    9bd8:	a80a      	add	r0, sp, #40	; 0x28
	bt_dev.id_count = bt_read_public_addr(&addr);
    9bda:	71f3      	strb	r3, [r6, #7]
	memset(ir, 0, 16);
    9bdc:	f7f8 f827 	bl	1c2e <memset>
	if (!(bt_dev.vs_commands[1] & BIT(1))) {
    9be0:	f896 3062 	ldrb.w	r3, [r6, #98]	; 0x62
    9be4:	079b      	lsls	r3, r3, #30
    9be6:	d514      	bpl.n	9c12 <bt_setup_public_id_addr+0xc6>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_KEY_HIERARCHY_ROOTS, NULL,
    9be8:	aa06      	add	r2, sp, #24
    9bea:	4621      	mov	r1, r4
    9bec:	f64f 400a 	movw	r0, #64522	; 0xfc0a
    9bf0:	f7fe ffba 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    9bf4:	b1e8      	cbz	r0, 9c32 <bt_setup_public_id_addr+0xe6>
		BT_WARN("Failed to read identity root");
    9bf6:	2302      	movs	r3, #2
    9bf8:	f04f 0100 	mov.w	r1, #0
    9bfc:	f363 0107 	bfi	r1, r3, #0, #8
    9c00:	4a16      	ldr	r2, [pc, #88]	; (9c5c <bt_setup_public_id_addr+0x110>)
    9c02:	4b17      	ldr	r3, [pc, #92]	; (9c60 <bt_setup_public_id_addr+0x114>)
    9c04:	4818      	ldr	r0, [pc, #96]	; (9c68 <bt_setup_public_id_addr+0x11c>)
    9c06:	1a9b      	subs	r3, r3, r2
    9c08:	08db      	lsrs	r3, r3, #3
    9c0a:	f363 118f 	bfi	r1, r3, #6, #10
    9c0e:	f017 fa14 	bl	2103a <log_0>
	if (!bt_smp_irk_get(ir, ir_irk)) {
    9c12:	a906      	add	r1, sp, #24
    9c14:	a80a      	add	r0, sp, #40	; 0x28
    9c16:	f01a f982 	bl	23f1e <bt_smp_irk_get>
    9c1a:	b1d8      	cbz	r0, 9c54 <bt_setup_public_id_addr+0x108>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    9c1c:	f44f 3100 	mov.w	r1, #131072	; 0x20000
    9c20:	4812      	ldr	r0, [pc, #72]	; (9c6c <bt_setup_public_id_addr+0x120>)
    9c22:	f018 fbe2 	bl	223ea <atomic_or>
	u8_t *irk = NULL;
    9c26:	2200      	movs	r2, #0
	id_create(BT_ID_DEFAULT, &addr, irk);
    9c28:	a904      	add	r1, sp, #16
    9c2a:	2000      	movs	r0, #0
    9c2c:	f7ff fc60 	bl	94f0 <id_create>
    9c30:	e7a7      	b.n	9b82 <bt_setup_public_id_addr+0x36>
	rp = (void *)rsp->data;
    9c32:	9e06      	ldr	r6, [sp, #24]
	memcpy(ir, rp->ir, 16);
    9c34:	68b2      	ldr	r2, [r6, #8]
    9c36:	ad0a      	add	r5, sp, #40	; 0x28
    9c38:	1c53      	adds	r3, r2, #1
    9c3a:	3211      	adds	r2, #17
    9c3c:	6818      	ldr	r0, [r3, #0]
    9c3e:	6859      	ldr	r1, [r3, #4]
    9c40:	462c      	mov	r4, r5
    9c42:	c403      	stmia	r4!, {r0, r1}
    9c44:	3308      	adds	r3, #8
    9c46:	4293      	cmp	r3, r2
    9c48:	4625      	mov	r5, r4
    9c4a:	d1f7      	bne.n	9c3c <bt_setup_public_id_addr+0xf0>
	net_buf_unref(rsp);
    9c4c:	4630      	mov	r0, r6
    9c4e:	f00f fa05 	bl	1905c <net_buf_unref>
    9c52:	e7de      	b.n	9c12 <bt_setup_public_id_addr+0xc6>
		irk = ir_irk;
    9c54:	aa06      	add	r2, sp, #24
    9c56:	e7e7      	b.n	9c28 <bt_setup_public_id_addr+0xdc>
    9c58:	2000e4d8 	.word	0x2000e4d8
    9c5c:	00028540 	.word	0x00028540
    9c60:	00028610 	.word	0x00028610
    9c64:	00063037 	.word	0x00063037
    9c68:	00063055 	.word	0x00063055
    9c6c:	2000e548 	.word	0x2000e548

00009c70 <bt_setup_random_id_addr>:
{
    9c70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!bt_dev.id_count) {
    9c74:	4c4d      	ldr	r4, [pc, #308]	; (9dac <bt_setup_random_id_addr+0x13c>)
    9c76:	79e7      	ldrb	r7, [r4, #7]
{
    9c78:	b08c      	sub	sp, #48	; 0x30
    9c7a:	4625      	mov	r5, r4
	if (!bt_dev.id_count) {
    9c7c:	b99f      	cbnz	r7, 9ca6 <bt_setup_random_id_addr+0x36>
	if (!(bt_dev.vs_commands[1] & BIT(0))) {
    9c7e:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
    9c82:	f013 0601 	ands.w	r6, r3, #1
    9c86:	d118      	bne.n	9cba <bt_setup_random_id_addr+0x4a>
		BT_WARN("Read Static Addresses command not available");
    9c88:	2302      	movs	r3, #2
    9c8a:	f04f 0100 	mov.w	r1, #0
    9c8e:	f363 0107 	bfi	r1, r3, #0, #8
    9c92:	4a47      	ldr	r2, [pc, #284]	; (9db0 <bt_setup_random_id_addr+0x140>)
    9c94:	4b47      	ldr	r3, [pc, #284]	; (9db4 <bt_setup_random_id_addr+0x144>)
    9c96:	4848      	ldr	r0, [pc, #288]	; (9db8 <bt_setup_random_id_addr+0x148>)
    9c98:	1a9b      	subs	r3, r3, r2
    9c9a:	08db      	lsrs	r3, r3, #3
    9c9c:	f363 118f 	bfi	r1, r3, #6, #10
    9ca0:	f017 f9cb 	bl	2103a <log_0>
		bt_dev.id_count = bt_read_static_addr(addrs);
    9ca4:	71e6      	strb	r6, [r4, #7]
    9ca6:	f44f 3100 	mov.w	r1, #131072	; 0x20000
    9caa:	4844      	ldr	r0, [pc, #272]	; (9dbc <bt_setup_random_id_addr+0x14c>)
    9cac:	f018 fb9d 	bl	223ea <atomic_or>
	return bt_id_create(NULL, NULL);
    9cb0:	2100      	movs	r1, #0
    9cb2:	4608      	mov	r0, r1
    9cb4:	f7ff ff02 	bl	9abc <bt_id_create>
    9cb8:	e060      	b.n	9d7c <bt_setup_random_id_addr+0x10c>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_STATIC_ADDRS, NULL, &rsp);
    9cba:	aa02      	add	r2, sp, #8
    9cbc:	4639      	mov	r1, r7
    9cbe:	f64f 4009 	movw	r0, #64521	; 0xfc09
    9cc2:	f7fe ff51 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    9cc6:	b178      	cbz	r0, 9ce8 <bt_setup_random_id_addr+0x78>
		BT_WARN("Failed to read static addresses");
    9cc8:	2302      	movs	r3, #2
    9cca:	f04f 0100 	mov.w	r1, #0
    9cce:	f363 0107 	bfi	r1, r3, #0, #8
    9cd2:	4a37      	ldr	r2, [pc, #220]	; (9db0 <bt_setup_random_id_addr+0x140>)
    9cd4:	4b37      	ldr	r3, [pc, #220]	; (9db4 <bt_setup_random_id_addr+0x144>)
    9cd6:	483a      	ldr	r0, [pc, #232]	; (9dc0 <bt_setup_random_id_addr+0x150>)
    9cd8:	1a9b      	subs	r3, r3, r2
    9cda:	08db      	lsrs	r3, r3, #3
    9cdc:	f363 118f 	bfi	r1, r3, #6, #10
    9ce0:	f017 f9ab 	bl	2103a <log_0>
		bt_dev.id_count = bt_read_static_addr(addrs);
    9ce4:	71e7      	strb	r7, [r4, #7]
		if (bt_dev.id_count) {
    9ce6:	e7de      	b.n	9ca6 <bt_setup_random_id_addr+0x36>
	rp = (void *)rsp->data;
    9ce8:	f8dd 8008 	ldr.w	r8, [sp, #8]
    9cec:	f8d8 c008 	ldr.w	ip, [r8, #8]
	cnt = MIN(rp->num_addrs, CONFIG_BT_ID_MAX);
    9cf0:	f89c 7001 	ldrb.w	r7, [ip, #1]
    9cf4:	1c3e      	adds	r6, r7, #0
    9cf6:	bf18      	it	ne
    9cf8:	2601      	movne	r6, #1
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
    9cfa:	f10c 0e12 	add.w	lr, ip, #18
	for (i = 0; i < cnt; i++) {
    9cfe:	4286      	cmp	r6, r0
    9d00:	dc3f      	bgt.n	9d82 <bt_setup_random_id_addr+0x112>
	net_buf_unref(rsp);
    9d02:	4640      	mov	r0, r8
    9d04:	f00f f9aa 	bl	1905c <net_buf_unref>
	if (!cnt) {
    9d08:	b96f      	cbnz	r7, 9d26 <bt_setup_random_id_addr+0xb6>
		BT_WARN("No static addresses stored in controller");
    9d0a:	2302      	movs	r3, #2
    9d0c:	f04f 0100 	mov.w	r1, #0
    9d10:	f363 0107 	bfi	r1, r3, #0, #8
    9d14:	4a26      	ldr	r2, [pc, #152]	; (9db0 <bt_setup_random_id_addr+0x140>)
    9d16:	4b27      	ldr	r3, [pc, #156]	; (9db4 <bt_setup_random_id_addr+0x144>)
    9d18:	482a      	ldr	r0, [pc, #168]	; (9dc4 <bt_setup_random_id_addr+0x154>)
    9d1a:	1a9b      	subs	r3, r3, r2
    9d1c:	08db      	lsrs	r3, r3, #3
    9d1e:	f363 118f 	bfi	r1, r3, #6, #10
    9d22:	f017 f98a 	bl	2103a <log_0>
		bt_dev.id_count = bt_read_static_addr(addrs);
    9d26:	71ee      	strb	r6, [r5, #7]
		if (bt_dev.id_count) {
    9d28:	2f00      	cmp	r7, #0
    9d2a:	d0bc      	beq.n	9ca6 <bt_setup_random_id_addr+0x36>
    9d2c:	f8df 808c 	ldr.w	r8, [pc, #140]	; 9dbc <bt_setup_random_id_addr+0x14c>
    9d30:	2400      	movs	r4, #0
    9d32:	b2e7      	uxtb	r7, r4
				if (!bt_smp_irk_get(addrs[i].ir, ir_irk)) {
    9d34:	2616      	movs	r6, #22
    9d36:	437e      	muls	r6, r7
    9d38:	1db0      	adds	r0, r6, #6
    9d3a:	ab06      	add	r3, sp, #24
    9d3c:	a902      	add	r1, sp, #8
    9d3e:	4418      	add	r0, r3
    9d40:	f01a f8ed 	bl	23f1e <bt_smp_irk_get>
    9d44:	b380      	cbz	r0, 9da8 <bt_setup_random_id_addr+0x138>
    9d46:	f44f 3100 	mov.w	r1, #131072	; 0x20000
    9d4a:	4640      	mov	r0, r8
    9d4c:	f018 fb4d 	bl	223ea <atomic_or>
				u8_t *irk = NULL;
    9d50:	2200      	movs	r2, #0
				bt_addr_copy(&addr.a, &addrs[i].bdaddr);
    9d52:	ab06      	add	r3, sp, #24
    9d54:	1999      	adds	r1, r3, r6
    9d56:	f10d 0001 	add.w	r0, sp, #1
    9d5a:	f018 fb96 	bl	2248a <bt_addr_copy>
				addr.type = BT_ADDR_LE_RANDOM;
    9d5e:	2301      	movs	r3, #1
				id_create(i, &addr, irk);
    9d60:	4669      	mov	r1, sp
    9d62:	4638      	mov	r0, r7
				addr.type = BT_ADDR_LE_RANDOM;
    9d64:	f88d 3000 	strb.w	r3, [sp]
				id_create(i, &addr, irk);
    9d68:	3401      	adds	r4, #1
    9d6a:	f7ff fbc1 	bl	94f0 <id_create>
			for (u8_t i = 0; i < bt_dev.id_count; i++) {
    9d6e:	79ea      	ldrb	r2, [r5, #7]
    9d70:	b2e3      	uxtb	r3, r4
    9d72:	429a      	cmp	r2, r3
    9d74:	d8dd      	bhi.n	9d32 <bt_setup_random_id_addr+0xc2>
			return set_random_address(&bt_dev.id_addr[0].a);
    9d76:	4814      	ldr	r0, [pc, #80]	; (9dc8 <bt_setup_random_id_addr+0x158>)
    9d78:	f7fe ff6c 	bl	8c54 <set_random_address>
}
    9d7c:	b00c      	add	sp, #48	; 0x30
    9d7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
    9d82:	f10c 0202 	add.w	r2, ip, #2
    9d86:	ab06      	add	r3, sp, #24
    9d88:	6810      	ldr	r0, [r2, #0]
    9d8a:	6851      	ldr	r1, [r2, #4]
    9d8c:	461c      	mov	r4, r3
    9d8e:	c403      	stmia	r4!, {r0, r1}
    9d90:	3208      	adds	r2, #8
    9d92:	4572      	cmp	r2, lr
    9d94:	4623      	mov	r3, r4
    9d96:	d1f7      	bne.n	9d88 <bt_setup_random_id_addr+0x118>
    9d98:	f8de 0000 	ldr.w	r0, [lr]
    9d9c:	6020      	str	r0, [r4, #0]
    9d9e:	f8be 2004 	ldrh.w	r2, [lr, #4]
    9da2:	80a2      	strh	r2, [r4, #4]
    9da4:	2001      	movs	r0, #1
    9da6:	e7aa      	b.n	9cfe <bt_setup_random_id_addr+0x8e>
					irk = ir_irk;
    9da8:	aa02      	add	r2, sp, #8
    9daa:	e7d2      	b.n	9d52 <bt_setup_random_id_addr+0xe2>
    9dac:	2000e4d8 	.word	0x2000e4d8
    9db0:	00028540 	.word	0x00028540
    9db4:	00028610 	.word	0x00028610
    9db8:	00063072 	.word	0x00063072
    9dbc:	2000e548 	.word	0x2000e548
    9dc0:	0006309e 	.word	0x0006309e
    9dc4:	000630be 	.word	0x000630be
    9dc8:	2000e4d9 	.word	0x2000e4d9

00009dcc <bt_le_adv_start_internal>:

int bt_le_adv_start_internal(const struct bt_le_adv_param *param,
			     const struct bt_data *ad, size_t ad_len,
			     const struct bt_data *sd, size_t sd_len,
			     const bt_addr_le_t *peer)
{
    9dcc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct bt_conn *conn = NULL;
	struct net_buf *buf;
	bool dir_adv = (peer != NULL);
	int err = 0;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    9dd0:	4ea6      	ldr	r6, [pc, #664]	; (a06c <bt_le_adv_start_internal+0x2a0>)
{
    9dd2:	b08d      	sub	sp, #52	; 0x34
    9dd4:	4605      	mov	r5, r0
    9dd6:	9102      	str	r1, [sp, #8]
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    9dd8:	f106 0070 	add.w	r0, r6, #112	; 0x70
    9ddc:	2101      	movs	r1, #1
{
    9dde:	4693      	mov	fp, r2
    9de0:	4699      	mov	r9, r3
    9de2:	f8dd 805c 	ldr.w	r8, [sp, #92]	; 0x5c
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    9de6:	f018 fb5c 	bl	224a2 <atomic_test_bit>
    9dea:	2800      	cmp	r0, #0
    9dec:	f000 8132 	beq.w	a054 <bt_le_adv_start_internal+0x288>
	if (param->id >= bt_dev.id_count ||
    9df0:	7828      	ldrb	r0, [r5, #0]
    9df2:	79f3      	ldrb	r3, [r6, #7]
    9df4:	4283      	cmp	r3, r0
    9df6:	d805      	bhi.n	9e04 <bt_le_adv_start_internal+0x38>
		return -EAGAIN;
	}

	if (!valid_adv_param(param, dir_adv)) {
		return -EINVAL;
    9df8:	f06f 0415 	mvn.w	r4, #21

	atomic_set_bit_to(bt_dev.flags, BT_DEV_ADVERTISING_CONNECTABLE,
			  param->options & BT_LE_ADV_OPT_CONNECTABLE);

	return 0;
}
    9dfc:	4620      	mov	r0, r4
    9dfe:	b00d      	add	sp, #52	; 0x34
    9e00:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    !bt_addr_le_cmp(&bt_dev.id_addr[param->id], BT_ADDR_LE_ANY)) {
    9e04:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    9e08:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
    9e0a:	2207      	movs	r2, #7
    9e0c:	a906      	add	r1, sp, #24
    9e0e:	4430      	add	r0, r6
    9e10:	9306      	str	r3, [sp, #24]
    9e12:	f8cd 301b 	str.w	r3, [sp, #27]
    9e16:	f7f7 fedb 	bl	1bd0 <memcmp>
	if (param->id >= bt_dev.id_count ||
    9e1a:	2800      	cmp	r0, #0
    9e1c:	d0ec      	beq.n	9df8 <bt_le_adv_start_internal+0x2c>
	if (!(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    9e1e:	786b      	ldrb	r3, [r5, #1]
    9e20:	07d8      	lsls	r0, r3, #31
    9e22:	d405      	bmi.n	9e30 <bt_le_adv_start_internal+0x64>
		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
    9e24:	7c32      	ldrb	r2, [r6, #16]
    9e26:	2a08      	cmp	r2, #8
    9e28:	d802      	bhi.n	9e30 <bt_le_adv_start_internal+0x64>
    9e2a:	886a      	ldrh	r2, [r5, #2]
    9e2c:	2a9f      	cmp	r2, #159	; 0x9f
    9e2e:	d9e3      	bls.n	9df8 <bt_le_adv_start_internal+0x2c>
	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) || !dir_adv) {
    9e30:	06d9      	lsls	r1, r3, #27
    9e32:	d402      	bmi.n	9e3a <bt_le_adv_start_internal+0x6e>
    9e34:	f1b8 0f00 	cmp.w	r8, #0
    9e38:	d108      	bne.n	9e4c <bt_le_adv_start_internal+0x80>
		if (param->interval_min > param->interval_max ||
    9e3a:	886a      	ldrh	r2, [r5, #2]
    9e3c:	88ab      	ldrh	r3, [r5, #4]
    9e3e:	429a      	cmp	r2, r3
    9e40:	d8da      	bhi.n	9df8 <bt_le_adv_start_internal+0x2c>
    9e42:	2a1f      	cmp	r2, #31
    9e44:	d9d8      	bls.n	9df8 <bt_le_adv_start_internal+0x2c>
		    param->interval_min < 0x0020 ||
    9e46:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    9e4a:	d8d5      	bhi.n	9df8 <bt_le_adv_start_internal+0x2c>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING)) {
    9e4c:	2105      	movs	r1, #5
    9e4e:	4888      	ldr	r0, [pc, #544]	; (a070 <bt_le_adv_start_internal+0x2a4>)
    9e50:	f018 fb27 	bl	224a2 <atomic_test_bit>
    9e54:	2800      	cmp	r0, #0
    9e56:	f040 8100 	bne.w	a05a <bt_le_adv_start_internal+0x28e>
	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
    9e5a:	886b      	ldrh	r3, [r5, #2]
    9e5c:	f8ad 3020 	strh.w	r3, [sp, #32]
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
    9e60:	88ab      	ldrh	r3, [r5, #4]
    9e62:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
	set_param.channel_map  = 0x07;
    9e66:	2307      	movs	r3, #7
	(void)memset(&set_param, 0, sizeof(set_param));
    9e68:	e9cd 0009 	strd	r0, r0, [sp, #36]	; 0x24
	if (bt_dev.adv_id != param->id) {
    9e6c:	7a32      	ldrb	r2, [r6, #8]
	(void)memset(&set_param, 0, sizeof(set_param));
    9e6e:	f8cd 002b 	str.w	r0, [sp, #43]	; 0x2b
	set_param.channel_map  = 0x07;
    9e72:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
	if (bt_dev.adv_id != param->id) {
    9e76:	782b      	ldrb	r3, [r5, #0]
    9e78:	429a      	cmp	r2, r3
    9e7a:	d004      	beq.n	9e86 <bt_le_adv_start_internal+0xba>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    9e7c:	f46f 4100 	mvn.w	r1, #32768	; 0x8000
    9e80:	487b      	ldr	r0, [pc, #492]	; (a070 <bt_le_adv_start_internal+0x2a4>)
    9e82:	f018 faa3 	bl	223cc <atomic_and>
	bt_dev.adv_id = param->id;
    9e86:	782f      	ldrb	r7, [r5, #0]
    9e88:	7237      	strb	r7, [r6, #8]
		set_param.filter_policy = BT_LE_ADV_FP_NO_WHITELIST;
    9e8a:	2300      	movs	r3, #0
    9e8c:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
    9e90:	786b      	ldrb	r3, [r5, #1]
    9e92:	f013 0a01 	ands.w	sl, r3, #1
    9e96:	f003 0204 	and.w	r2, r3, #4
    9e9a:	d071      	beq.n	9f80 <bt_le_adv_start_internal+0x1b4>
		if (IS_ENABLED(CONFIG_BT_PRIVACY) &&
    9e9c:	2a00      	cmp	r2, #0
    9e9e:	d158      	bne.n	9f52 <bt_le_adv_start_internal+0x186>
			err = le_set_private_addr(param->id);
    9ea0:	4638      	mov	r0, r7
    9ea2:	f7fe ff03 	bl	8cac <le_set_private_addr>
			if (err) {
    9ea6:	4604      	mov	r4, r0
    9ea8:	2800      	cmp	r0, #0
    9eaa:	d1a7      	bne.n	9dfc <bt_le_adv_start_internal+0x30>
			if (BT_FEAT_LE_PRIVACY(bt_dev.le.features)) {
    9eac:	f896 2078 	ldrb.w	r2, [r6, #120]	; 0x78
    9eb0:	0652      	lsls	r2, r2, #25
				set_param.own_addr_type =
    9eb2:	bf4c      	ite	mi
    9eb4:	2203      	movmi	r2, #3
				set_param.own_addr_type = BT_ADDR_LE_RANDOM;
    9eb6:	2201      	movpl	r2, #1
    9eb8:	f88d 2025 	strb.w	r2, [sp, #37]	; 0x25
		if (dir_adv) {
    9ebc:	f1b8 0f00 	cmp.w	r8, #0
    9ec0:	d05b      	beq.n	9f7a <bt_le_adv_start_internal+0x1ae>
			if (param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) {
    9ec2:	786a      	ldrb	r2, [r5, #1]
				set_param.type = BT_LE_ADV_DIRECT_IND_LOW_DUTY;
    9ec4:	f012 0f10 	tst.w	r2, #16
    9ec8:	bf18      	it	ne
    9eca:	f04f 0a04 	movne.w	sl, #4
			bt_addr_le_copy(&set_param.direct_addr, peer);
    9ece:	4641      	mov	r1, r8
    9ed0:	f10d 0026 	add.w	r0, sp, #38	; 0x26
    9ed4:	f88d a024 	strb.w	sl, [sp, #36]	; 0x24
    9ed8:	f018 fadc 	bl	22494 <bt_addr_le_copy>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_PARAM, sizeof(set_param));
    9edc:	210f      	movs	r1, #15
    9ede:	f242 0006 	movw	r0, #8198	; 0x2006
    9ee2:	f7fe fccb 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    9ee6:	4604      	mov	r4, r0
    9ee8:	2800      	cmp	r0, #0
    9eea:	f000 80b9 	beq.w	a060 <bt_le_adv_start_internal+0x294>
	net_buf_add_mem(buf, &set_param, sizeof(set_param));
    9eee:	220f      	movs	r2, #15
    9ef0:	a908      	add	r1, sp, #32
    9ef2:	3008      	adds	r0, #8
    9ef4:	f01a ff76 	bl	24de4 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_PARAM, buf, NULL);
    9ef8:	4621      	mov	r1, r4
    9efa:	2200      	movs	r2, #0
    9efc:	f242 0006 	movw	r0, #8198	; 0x2006
    9f00:	f7fe fe32 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    9f04:	4604      	mov	r4, r0
    9f06:	2800      	cmp	r0, #0
    9f08:	f47f af78 	bne.w	9dfc <bt_le_adv_start_internal+0x30>
	if (!dir_adv) {
    9f0c:	f1b8 0f00 	cmp.w	r8, #0
    9f10:	d05d      	beq.n	9fce <bt_le_adv_start_internal+0x202>
	struct bt_conn *conn = NULL;
    9f12:	2600      	movs	r6, #0
	err = set_advertise_enable(true);
    9f14:	2001      	movs	r0, #1
    9f16:	f7fe fe6d 	bl	8bf4 <set_advertise_enable>
	if (err) {
    9f1a:	4604      	mov	r4, r0
    9f1c:	2800      	cmp	r0, #0
    9f1e:	d07d      	beq.n	a01c <bt_le_adv_start_internal+0x250>
		BT_ERR("Failed to start advertiser");
    9f20:	2301      	movs	r3, #1
    9f22:	f04f 0100 	mov.w	r1, #0
    9f26:	f363 0107 	bfi	r1, r3, #0, #8
    9f2a:	4a52      	ldr	r2, [pc, #328]	; (a074 <bt_le_adv_start_internal+0x2a8>)
    9f2c:	4b52      	ldr	r3, [pc, #328]	; (a078 <bt_le_adv_start_internal+0x2ac>)
    9f2e:	4853      	ldr	r0, [pc, #332]	; (a07c <bt_le_adv_start_internal+0x2b0>)
    9f30:	1a9b      	subs	r3, r3, r2
    9f32:	08db      	lsrs	r3, r3, #3
    9f34:	f363 118f 	bfi	r1, r3, #6, #10
    9f38:	f017 f87f 	bl	2103a <log_0>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
    9f3c:	2e00      	cmp	r6, #0
    9f3e:	f43f af5d 	beq.w	9dfc <bt_le_adv_start_internal+0x30>
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    9f42:	4630      	mov	r0, r6
    9f44:	2100      	movs	r1, #0
    9f46:	f000 fe8f 	bl	ac68 <bt_conn_set_state>
			bt_conn_unref(conn);
    9f4a:	4630      	mov	r0, r6
    9f4c:	f018 fbe7 	bl	2271e <bt_conn_unref>
    9f50:	e754      	b.n	9dfc <bt_le_adv_start_internal+0x30>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    9f52:	00fa      	lsls	r2, r7, #3
    9f54:	1bd1      	subs	r1, r2, r7
    9f56:	5c71      	ldrb	r1, [r6, r1]
    9f58:	2901      	cmp	r1, #1
    9f5a:	d002      	beq.n	9f62 <bt_le_adv_start_internal+0x196>
			set_param.own_addr_type = id_addr->type;
    9f5c:	1bd7      	subs	r7, r2, r7
    9f5e:	5df2      	ldrb	r2, [r6, r7]
    9f60:	e7aa      	b.n	9eb8 <bt_le_adv_start_internal+0xec>
				err = set_random_address(&id_addr->a);
    9f62:	2007      	movs	r0, #7
    9f64:	fb10 1007 	smlabb	r0, r0, r7, r1
    9f68:	4430      	add	r0, r6
    9f6a:	9203      	str	r2, [sp, #12]
    9f6c:	f7fe fe72 	bl	8c54 <set_random_address>
				if (err) {
    9f70:	9a03      	ldr	r2, [sp, #12]
    9f72:	4604      	mov	r4, r0
    9f74:	2800      	cmp	r0, #0
    9f76:	d0f1      	beq.n	9f5c <bt_le_adv_start_internal+0x190>
    9f78:	e740      	b.n	9dfc <bt_le_adv_start_internal+0x30>
			set_param.type = BT_LE_ADV_IND;
    9f7a:	f88d 8024 	strb.w	r8, [sp, #36]	; 0x24
    9f7e:	e7ad      	b.n	9edc <bt_le_adv_start_internal+0x110>
		if (param->options & BT_LE_ADV_OPT_USE_IDENTITY) {
    9f80:	b1ea      	cbz	r2, 9fbe <bt_le_adv_start_internal+0x1f2>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    9f82:	00fa      	lsls	r2, r7, #3
    9f84:	1bd1      	subs	r1, r2, r7
    9f86:	5c71      	ldrb	r1, [r6, r1]
    9f88:	2901      	cmp	r1, #1
    9f8a:	d116      	bne.n	9fba <bt_le_adv_start_internal+0x1ee>
				err = set_random_address(&id_addr->a);
    9f8c:	2007      	movs	r0, #7
    9f8e:	fb10 1007 	smlabb	r0, r0, r7, r1
    9f92:	4430      	add	r0, r6
    9f94:	9203      	str	r2, [sp, #12]
    9f96:	f7fe fe5d 	bl	8c54 <set_random_address>
    9f9a:	9a03      	ldr	r2, [sp, #12]
    9f9c:	4604      	mov	r4, r0
			set_param.own_addr_type = id_addr->type;
    9f9e:	1bd7      	subs	r7, r2, r7
    9fa0:	5df3      	ldrb	r3, [r6, r7]
			set_param.own_addr_type = BT_ADDR_LE_RANDOM;
    9fa2:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
		if (err) {
    9fa6:	2c00      	cmp	r4, #0
    9fa8:	f47f af28 	bne.w	9dfc <bt_le_adv_start_internal+0x30>
		if (sd) {
    9fac:	f1b9 0f00 	cmp.w	r9, #0
    9fb0:	d00b      	beq.n	9fca <bt_le_adv_start_internal+0x1fe>
			set_param.type = BT_LE_ADV_SCAN_IND;
    9fb2:	2302      	movs	r3, #2
			set_param.type = BT_LE_ADV_NONCONN_IND;
    9fb4:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    9fb8:	e790      	b.n	9edc <bt_le_adv_start_internal+0x110>
	int err = 0;
    9fba:	4654      	mov	r4, sl
    9fbc:	e7ef      	b.n	9f9e <bt_le_adv_start_internal+0x1d2>
			err = le_set_private_addr(param->id);
    9fbe:	4638      	mov	r0, r7
    9fc0:	f7fe fe74 	bl	8cac <le_set_private_addr>
			set_param.own_addr_type = BT_ADDR_LE_RANDOM;
    9fc4:	2301      	movs	r3, #1
			err = le_set_private_addr(param->id);
    9fc6:	4604      	mov	r4, r0
			set_param.own_addr_type = BT_ADDR_LE_RANDOM;
    9fc8:	e7eb      	b.n	9fa2 <bt_le_adv_start_internal+0x1d6>
			set_param.type = BT_LE_ADV_NONCONN_IND;
    9fca:	2303      	movs	r3, #3
    9fcc:	e7f2      	b.n	9fb4 <bt_le_adv_start_internal+0x1e8>
				    param->options & BT_LE_ADV_OPT_CONNECTABLE,
    9fce:	786b      	ldrb	r3, [r5, #1]
		err = le_adv_update(ad, ad_len, sd, sd_len,
    9fd0:	9802      	ldr	r0, [sp, #8]
    9fd2:	f3c3 02c0 	ubfx	r2, r3, #3, #1
    9fd6:	f003 0301 	and.w	r3, r3, #1
    9fda:	9201      	str	r2, [sp, #4]
    9fdc:	9300      	str	r3, [sp, #0]
    9fde:	464a      	mov	r2, r9
    9fe0:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9fe2:	4659      	mov	r1, fp
    9fe4:	f7fe ff6c 	bl	8ec0 <le_adv_update>
		if (err) {
    9fe8:	4604      	mov	r4, r0
    9fea:	2800      	cmp	r0, #0
    9fec:	f47f af06 	bne.w	9dfc <bt_le_adv_start_internal+0x30>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    9ff0:	786b      	ldrb	r3, [r5, #1]
    9ff2:	07db      	lsls	r3, r3, #31
    9ff4:	d58d      	bpl.n	9f12 <bt_le_adv_start_internal+0x146>
			conn = bt_conn_add_le(param->id, BT_ADDR_LE_NONE);
    9ff6:	f06f 03ff 	mvn.w	r3, #255	; 0xff
    9ffa:	9304      	str	r3, [sp, #16]
    9ffc:	a904      	add	r1, sp, #16
    9ffe:	f64f 73ff 	movw	r3, #65535	; 0xffff
    a002:	7828      	ldrb	r0, [r5, #0]
    a004:	f8ad 3014 	strh.w	r3, [sp, #20]
    a008:	f88d 3016 	strb.w	r3, [sp, #22]
    a00c:	f000 fdea 	bl	abe4 <bt_conn_add_le>
			if (!conn) {
    a010:	4606      	mov	r6, r0
    a012:	b340      	cbz	r0, a066 <bt_le_adv_start_internal+0x29a>
			bt_conn_set_state(conn, BT_CONN_CONNECT_ADV);
    a014:	2103      	movs	r1, #3
    a016:	f000 fe27 	bl	ac68 <bt_conn_set_state>
    a01a:	e77b      	b.n	9f14 <bt_le_adv_start_internal+0x148>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
    a01c:	b116      	cbz	r6, a024 <bt_le_adv_start_internal+0x258>
		bt_conn_unref(conn);
    a01e:	4630      	mov	r0, r6
    a020:	f018 fb7d 	bl	2271e <bt_conn_unref>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_KEEP_ADVERTISING,
    a024:	786a      	ldrb	r2, [r5, #1]
    a026:	4812      	ldr	r0, [pc, #72]	; (a070 <bt_le_adv_start_internal+0x2a4>)
    a028:	f082 0202 	eor.w	r2, r2, #2
    a02c:	f3c2 0240 	ubfx	r2, r2, #1, #1
    a030:	2108      	movs	r1, #8
    a032:	f018 f9e9 	bl	22408 <atomic_set_bit_to>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_ADVERTISING_NAME,
    a036:	786a      	ldrb	r2, [r5, #1]
    a038:	480d      	ldr	r0, [pc, #52]	; (a070 <bt_le_adv_start_internal+0x2a4>)
    a03a:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    a03e:	2106      	movs	r1, #6
    a040:	f018 f9e2 	bl	22408 <atomic_set_bit_to>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_ADVERTISING_CONNECTABLE,
    a044:	786a      	ldrb	r2, [r5, #1]
    a046:	480a      	ldr	r0, [pc, #40]	; (a070 <bt_le_adv_start_internal+0x2a4>)
    a048:	f002 0201 	and.w	r2, r2, #1
    a04c:	2107      	movs	r1, #7
    a04e:	f018 f9db 	bl	22408 <atomic_set_bit_to>
	return 0;
    a052:	e6d3      	b.n	9dfc <bt_le_adv_start_internal+0x30>
		return -EAGAIN;
    a054:	f06f 040a 	mvn.w	r4, #10
    a058:	e6d0      	b.n	9dfc <bt_le_adv_start_internal+0x30>
		return -EALREADY;
    a05a:	f06f 0477 	mvn.w	r4, #119	; 0x77
    a05e:	e6cd      	b.n	9dfc <bt_le_adv_start_internal+0x30>
		return -ENOBUFS;
    a060:	f06f 0468 	mvn.w	r4, #104	; 0x68
    a064:	e6ca      	b.n	9dfc <bt_le_adv_start_internal+0x30>
				return -ENOMEM;
    a066:	f06f 040b 	mvn.w	r4, #11
    a06a:	e6c7      	b.n	9dfc <bt_le_adv_start_internal+0x30>
    a06c:	2000e4d8 	.word	0x2000e4d8
    a070:	2000e548 	.word	0x2000e548
    a074:	00028540 	.word	0x00028540
    a078:	00028610 	.word	0x00028610
    a07c:	00062f02 	.word	0x00062f02

0000a080 <bt_le_adv_stop>:

	return bt_le_adv_start_internal(param, ad, ad_len, sd, sd_len, NULL);
}

int bt_le_adv_stop(void)
{
    a080:	b513      	push	{r0, r1, r4, lr}
    a082:	f46f 7180 	mvn.w	r1, #256	; 0x100
    a086:	4817      	ldr	r0, [pc, #92]	; (a0e4 <bt_le_adv_stop+0x64>)
    a088:	f018 f9a0 	bl	223cc <atomic_and>
	/* Make sure advertising is not re-enabled later even if it's not
	 * currently enabled (i.e. BT_DEV_ADVERTISING is not set).
	 */
	atomic_clear_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING);

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING)) {
    a08c:	2105      	movs	r1, #5
    a08e:	4815      	ldr	r0, [pc, #84]	; (a0e4 <bt_le_adv_stop+0x64>)
    a090:	f018 fa07 	bl	224a2 <atomic_test_bit>
    a094:	b318      	cbz	r0, a0de <bt_le_adv_stop+0x5e>
	}

	if (IS_ENABLED(CONFIG_BT_PERIPHERAL)) {
		struct bt_conn *conn;

		conn = bt_conn_lookup_state_le(BT_ADDR_LE_NONE,
    a096:	4b14      	ldr	r3, [pc, #80]	; (a0e8 <bt_le_adv_stop+0x68>)
    a098:	6818      	ldr	r0, [r3, #0]
    a09a:	889a      	ldrh	r2, [r3, #4]
    a09c:	9000      	str	r0, [sp, #0]
    a09e:	799b      	ldrb	r3, [r3, #6]
    a0a0:	f8ad 2004 	strh.w	r2, [sp, #4]
    a0a4:	2103      	movs	r1, #3
    a0a6:	4668      	mov	r0, sp
    a0a8:	f88d 3006 	strb.w	r3, [sp, #6]
    a0ac:	f000 fede 	bl	ae6c <bt_conn_lookup_state_le>
					       BT_CONN_CONNECT_ADV);
		if (conn) {
    a0b0:	4604      	mov	r4, r0
    a0b2:	b128      	cbz	r0, a0c0 <bt_le_adv_stop+0x40>
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    a0b4:	2100      	movs	r1, #0
    a0b6:	f000 fdd7 	bl	ac68 <bt_conn_set_state>
			bt_conn_unref(conn);
    a0ba:	4620      	mov	r0, r4
    a0bc:	f018 fb2f 	bl	2271e <bt_conn_unref>
		}

		conn = bt_conn_lookup_state_le(NULL, BT_CONN_CONNECT_DIR_ADV);
    a0c0:	2104      	movs	r1, #4
    a0c2:	2000      	movs	r0, #0
    a0c4:	f000 fed2 	bl	ae6c <bt_conn_lookup_state_le>
		if (conn) {
    a0c8:	4604      	mov	r4, r0
    a0ca:	b128      	cbz	r0, a0d8 <bt_le_adv_stop+0x58>
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    a0cc:	2100      	movs	r1, #0
    a0ce:	f000 fdcb 	bl	ac68 <bt_conn_set_state>
			bt_conn_unref(conn);
    a0d2:	4620      	mov	r0, r4
    a0d4:	f018 fb23 	bl	2271e <bt_conn_unref>
		}
	}

	err = set_advertise_enable(false);
    a0d8:	2000      	movs	r0, #0
    a0da:	f7fe fd8b 	bl	8bf4 <set_advertise_enable>
			le_set_private_addr(bt_dev.adv_id);
		}
	}

	return 0;
}
    a0de:	b002      	add	sp, #8
    a0e0:	bd10      	pop	{r4, pc}
    a0e2:	bf00      	nop
    a0e4:	2000e548 	.word	0x2000e548
    a0e8:	00028728 	.word	0x00028728

0000a0ec <bt_le_adv_resume>:

#if defined(CONFIG_BT_PERIPHERAL)
void bt_le_adv_resume(void)
{
    a0ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct bt_conn *adv_conn;
	int err;

	BT_ASSERT(atomic_test_bit(bt_dev.flags,
    a0ee:	2107      	movs	r1, #7
    a0f0:	4819      	ldr	r0, [pc, #100]	; (a158 <bt_le_adv_resume+0x6c>)
    a0f2:	f018 f9d6 	bl	224a2 <atomic_test_bit>
    a0f6:	b960      	cbnz	r0, a112 <bt_le_adv_resume+0x26>
    a0f8:	f241 73a4 	movw	r3, #6052	; 0x17a4
    a0fc:	4a17      	ldr	r2, [pc, #92]	; (a15c <bt_le_adv_resume+0x70>)
    a0fe:	4918      	ldr	r1, [pc, #96]	; (a160 <bt_le_adv_resume+0x74>)
    a100:	4818      	ldr	r0, [pc, #96]	; (a164 <bt_le_adv_resume+0x78>)
    a102:	f015 fe56 	bl	1fdb2 <printk>
    a106:	4040      	eors	r0, r0
    a108:	f380 8811 	msr	BASEPRI, r0
    a10c:	f04f 0003 	mov.w	r0, #3
    a110:	df02      	svc	2
				  BT_DEV_ADVERTISING_CONNECTABLE));

	adv_conn = bt_conn_add_le(bt_dev.adv_id, BT_ADDR_LE_NONE);
    a112:	4b15      	ldr	r3, [pc, #84]	; (a168 <bt_le_adv_resume+0x7c>)
    a114:	4d15      	ldr	r5, [pc, #84]	; (a16c <bt_le_adv_resume+0x80>)
    a116:	6818      	ldr	r0, [r3, #0]
    a118:	889a      	ldrh	r2, [r3, #4]
    a11a:	9000      	str	r0, [sp, #0]
    a11c:	799b      	ldrb	r3, [r3, #6]
    a11e:	7a28      	ldrb	r0, [r5, #8]
    a120:	f8ad 2004 	strh.w	r2, [sp, #4]
    a124:	4669      	mov	r1, sp
    a126:	f88d 3006 	strb.w	r3, [sp, #6]
    a12a:	f000 fd5b 	bl	abe4 <bt_conn_add_le>
	if (!adv_conn) {
    a12e:	4604      	mov	r4, r0
    a130:	b180      	cbz	r0, a154 <bt_le_adv_resume+0x68>
		return;
	}

	bt_conn_set_state(adv_conn, BT_CONN_CONNECT_ADV);
    a132:	2103      	movs	r1, #3
    a134:	f000 fd98 	bl	ac68 <bt_conn_set_state>

	if (IS_ENABLED(CONFIG_BT_PRIVACY)) {
		le_set_private_addr(bt_dev.adv_id);
    a138:	7a28      	ldrb	r0, [r5, #8]
    a13a:	f7fe fdb7 	bl	8cac <le_set_private_addr>
	}

	err = set_advertise_enable(true);
    a13e:	2001      	movs	r0, #1
    a140:	f7fe fd58 	bl	8bf4 <set_advertise_enable>
	if (err) {
    a144:	b118      	cbz	r0, a14e <bt_le_adv_resume+0x62>
		bt_conn_set_state(adv_conn, BT_CONN_DISCONNECTED);
    a146:	2100      	movs	r1, #0
    a148:	4620      	mov	r0, r4
    a14a:	f000 fd8d 	bl	ac68 <bt_conn_set_state>
	}

	/* Since we don't give the application a reference to manage in
	 * this case, we need to release this reference here.
	 */
	bt_conn_unref(adv_conn);
    a14e:	4620      	mov	r0, r4
    a150:	f018 fae5 	bl	2271e <bt_conn_unref>
}
    a154:	b003      	add	sp, #12
    a156:	bd30      	pop	{r4, r5, pc}
    a158:	2000e548 	.word	0x2000e548
    a15c:	000632c8 	.word	0x000632c8
    a160:	00062ec4 	.word	0x00062ec4
    a164:	000632fe 	.word	0x000632fe
    a168:	00028728 	.word	0x00028728
    a16c:	2000e4d8 	.word	0x2000e4d8

0000a170 <hci_disconn_complete>:
{
    a170:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
    a172:	6886      	ldr	r6, [r0, #8]
	if (evt->status) {
    a174:	7835      	ldrb	r5, [r6, #0]
    a176:	bba5      	cbnz	r5, a1e2 <hci_disconn_complete+0x72>
	u16_t handle = sys_le16_to_cpu(evt->handle);
    a178:	f8b6 7001 	ldrh.w	r7, [r6, #1]
	conn = bt_conn_lookup_handle(handle);
    a17c:	4638      	mov	r0, r7
    a17e:	f000 fe3d 	bl	adfc <bt_conn_lookup_handle>
	if (!conn) {
    a182:	4604      	mov	r4, r0
    a184:	b9e0      	cbnz	r0, a1c0 <hci_disconn_complete+0x50>
		BT_ERR("Unable to look up conn with handle %u", handle);
    a186:	2301      	movs	r3, #1
    a188:	f04f 0200 	mov.w	r2, #0
    a18c:	f363 0207 	bfi	r2, r3, #0, #8
    a190:	4914      	ldr	r1, [pc, #80]	; (a1e4 <hci_disconn_complete+0x74>)
    a192:	4b15      	ldr	r3, [pc, #84]	; (a1e8 <hci_disconn_complete+0x78>)
    a194:	4815      	ldr	r0, [pc, #84]	; (a1ec <hci_disconn_complete+0x7c>)
    a196:	1a5b      	subs	r3, r3, r1
    a198:	08db      	lsrs	r3, r3, #3
    a19a:	f363 128f 	bfi	r2, r3, #6, #10
    a19e:	4639      	mov	r1, r7
    a1a0:	f016 ff58 	bl	21054 <log_1>
	    atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    a1a4:	2108      	movs	r1, #8
    a1a6:	4812      	ldr	r0, [pc, #72]	; (a1f0 <hci_disconn_complete+0x80>)
    a1a8:	f018 f97b 	bl	224a2 <atomic_test_bit>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    a1ac:	b1c8      	cbz	r0, a1e2 <hci_disconn_complete+0x72>
	    !atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING)) {
    a1ae:	2105      	movs	r1, #5
    a1b0:	480f      	ldr	r0, [pc, #60]	; (a1f0 <hci_disconn_complete+0x80>)
    a1b2:	f018 f976 	bl	224a2 <atomic_test_bit>
	    atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    a1b6:	b9a0      	cbnz	r0, a1e2 <hci_disconn_complete+0x72>
}
    a1b8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		bt_le_adv_resume();
    a1bc:	f7ff bf96 	b.w	a0ec <bt_le_adv_resume>
	conn->err = evt->reason;
    a1c0:	78f3      	ldrb	r3, [r6, #3]
    a1c2:	7303      	strb	r3, [r0, #12]
	bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    a1c4:	4629      	mov	r1, r5
    a1c6:	f000 fd4f 	bl	ac68 <bt_conn_set_state>
	if (conn->type != BT_CONN_TYPE_LE) {
    a1ca:	78a3      	ldrb	r3, [r4, #2]
	conn->handle = 0U;
    a1cc:	8025      	strh	r5, [r4, #0]
	if (conn->type != BT_CONN_TYPE_LE) {
    a1ce:	2b01      	cmp	r3, #1
		bt_conn_unref(conn);
    a1d0:	4620      	mov	r0, r4
	if (conn->type != BT_CONN_TYPE_LE) {
    a1d2:	d003      	beq.n	a1dc <hci_disconn_complete+0x6c>
}
    a1d4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		bt_conn_unref(conn);
    a1d8:	f018 baa1 	b.w	2271e <bt_conn_unref>
	bt_conn_unref(conn);
    a1dc:	f018 fa9f 	bl	2271e <bt_conn_unref>
    a1e0:	e7e0      	b.n	a1a4 <hci_disconn_complete+0x34>
}
    a1e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a1e4:	00028540 	.word	0x00028540
    a1e8:	00028610 	.word	0x00028610
    a1ec:	0006326f 	.word	0x0006326f
    a1f0:	2000e548 	.word	0x2000e548

0000a1f4 <enh_conn_complete>:
{
    a1f4:	b5f0      	push	{r4, r5, r6, r7, lr}
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    a1f6:	f46f 3180 	mvn.w	r1, #65536	; 0x10000
	u16_t handle = sys_le16_to_cpu(evt->handle);
    a1fa:	f8b0 7001 	ldrh.w	r7, [r0, #1]
{
    a1fe:	b085      	sub	sp, #20
    a200:	4605      	mov	r5, r0
    a202:	485a      	ldr	r0, [pc, #360]	; (a36c <enh_conn_complete+0x178>)
    a204:	f018 f8e2 	bl	223cc <atomic_and>
	if (atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_ID_PENDING)) {
    a208:	03c3      	lsls	r3, r0, #15
	u16_t handle = sys_le16_to_cpu(evt->handle);
    a20a:	b2be      	uxth	r6, r7
	if (atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_ID_PENDING)) {
    a20c:	d504      	bpl.n	a218 <enh_conn_complete+0x24>
		bt_keys_foreach(BT_KEYS_IRK, update_pending_id, NULL);
    a20e:	2200      	movs	r2, #0
    a210:	4957      	ldr	r1, [pc, #348]	; (a370 <enh_conn_complete+0x17c>)
    a212:	2002      	movs	r0, #2
    a214:	f006 f802 	bl	1021c <bt_keys_foreach>
	if (evt->status) {
    a218:	782b      	ldrb	r3, [r5, #0]
    a21a:	b343      	cbz	r3, a26e <enh_conn_complete+0x7a>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_SLAVE) {
    a21c:	78eb      	ldrb	r3, [r5, #3]
    a21e:	2b01      	cmp	r3, #1
    a220:	d15a      	bne.n	a2d8 <enh_conn_complete+0xe4>
    a222:	2000      	movs	r0, #0
    a224:	f7fe f880 	bl	8328 <find_pending_connect.part.18>
		if (!conn) {
    a228:	4604      	mov	r4, r0
    a22a:	2800      	cmp	r0, #0
    a22c:	d054      	beq.n	a2d8 <enh_conn_complete+0xe4>
		conn->err = evt->status;
    a22e:	7829      	ldrb	r1, [r5, #0]
    a230:	7301      	strb	r1, [r0, #12]
			if (conn->err == BT_HCI_ERR_ADV_TIMEOUT) {
    a232:	293c      	cmp	r1, #60	; 0x3c
    a234:	d10c      	bne.n	a250 <enh_conn_complete+0x5c>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    a236:	f06f 0120 	mvn.w	r1, #32
    a23a:	484c      	ldr	r0, [pc, #304]	; (a36c <enh_conn_complete+0x178>)
    a23c:	f018 f8c6 	bl	223cc <atomic_and>
				bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    a240:	2100      	movs	r1, #0
    a242:	4620      	mov	r0, r4
    a244:	f000 fd10 	bl	ac68 <bt_conn_set_state>
	bt_conn_unref(conn);
    a248:	4620      	mov	r0, r4
    a24a:	f018 fa68 	bl	2271e <bt_conn_unref>
	if (IS_ENABLED(CONFIG_BT_CENTRAL)) {
    a24e:	e043      	b.n	a2d8 <enh_conn_complete+0xe4>
		BT_WARN("Unexpected status 0x%02x", evt->status);
    a250:	2302      	movs	r3, #2
    a252:	f04f 0200 	mov.w	r2, #0
    a256:	f363 0207 	bfi	r2, r3, #0, #8
    a25a:	4846      	ldr	r0, [pc, #280]	; (a374 <enh_conn_complete+0x180>)
    a25c:	4b46      	ldr	r3, [pc, #280]	; (a378 <enh_conn_complete+0x184>)
    a25e:	1a1b      	subs	r3, r3, r0
    a260:	08db      	lsrs	r3, r3, #3
    a262:	f363 128f 	bfi	r2, r3, #6, #10
    a266:	4845      	ldr	r0, [pc, #276]	; (a37c <enh_conn_complete+0x188>)
    a268:	f016 fef4 	bl	21054 <log_1>
		bt_conn_unref(conn);
    a26c:	e7ec      	b.n	a248 <enh_conn_complete+0x54>
	bt_addr_le_copy(&id_addr, &evt->peer_addr);
    a26e:	1d2a      	adds	r2, r5, #4
    a270:	4611      	mov	r1, r2
    a272:	a802      	add	r0, sp, #8
    a274:	f018 f90e 	bl	22494 <bt_addr_le_copy>
	if (id_addr.type == BT_ADDR_LE_PUBLIC_ID ||
    a278:	f89d 3008 	ldrb.w	r3, [sp, #8]
    a27c:	3b02      	subs	r3, #2
    a27e:	b2db      	uxtb	r3, r3
    a280:	2b01      	cmp	r3, #1
    a282:	d82b      	bhi.n	a2dc <enh_conn_complete+0xe8>
		bt_addr_copy(&peer_addr.a, &evt->peer_rpa);
    a284:	f105 0111 	add.w	r1, r5, #17
    a288:	f10d 0001 	add.w	r0, sp, #1
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
    a28c:	f88d 3008 	strb.w	r3, [sp, #8]
		bt_addr_copy(&peer_addr.a, &evt->peer_rpa);
    a290:	f018 f8fb 	bl	2248a <bt_addr_copy>
		peer_addr.type = BT_ADDR_LE_RANDOM;
    a294:	2301      	movs	r3, #1
    a296:	f88d 3000 	strb.w	r3, [sp]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_SLAVE) {
    a29a:	78eb      	ldrb	r3, [r5, #3]
    a29c:	2b01      	cmp	r3, #1
    a29e:	d10c      	bne.n	a2ba <enh_conn_complete+0xc6>
    a2a0:	a802      	add	r0, sp, #8
    a2a2:	f7fe f841 	bl	8328 <find_pending_connect.part.18>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    a2a6:	78eb      	ldrb	r3, [r5, #3]
    a2a8:	2b01      	cmp	r3, #1
    a2aa:	4604      	mov	r4, r0
    a2ac:	d104      	bne.n	a2b8 <enh_conn_complete+0xc4>
    a2ae:	f06f 0120 	mvn.w	r1, #32
    a2b2:	482e      	ldr	r0, [pc, #184]	; (a36c <enh_conn_complete+0x178>)
    a2b4:	f018 f88a 	bl	223cc <atomic_and>
	if (!conn) {
    a2b8:	b9a4      	cbnz	r4, a2e4 <enh_conn_complete+0xf0>
		BT_ERR("Unable to add new conn for handle %u", handle);
    a2ba:	2301      	movs	r3, #1
    a2bc:	f04f 0200 	mov.w	r2, #0
    a2c0:	f363 0207 	bfi	r2, r3, #0, #8
    a2c4:	492b      	ldr	r1, [pc, #172]	; (a374 <enh_conn_complete+0x180>)
    a2c6:	4b2c      	ldr	r3, [pc, #176]	; (a378 <enh_conn_complete+0x184>)
    a2c8:	482d      	ldr	r0, [pc, #180]	; (a380 <enh_conn_complete+0x18c>)
    a2ca:	1a5b      	subs	r3, r3, r1
    a2cc:	08db      	lsrs	r3, r3, #3
    a2ce:	f363 128f 	bfi	r2, r3, #6, #10
    a2d2:	4631      	mov	r1, r6
    a2d4:	f016 febe 	bl	21054 <log_1>
}
    a2d8:	b005      	add	sp, #20
    a2da:	bdf0      	pop	{r4, r5, r6, r7, pc}
		bt_addr_le_copy(&peer_addr, &evt->peer_addr);
    a2dc:	4668      	mov	r0, sp
    a2de:	f018 f8d9 	bl	22494 <bt_addr_le_copy>
    a2e2:	e7da      	b.n	a29a <enh_conn_complete+0xa6>
	conn->handle = handle;
    a2e4:	4620      	mov	r0, r4
	bt_addr_le_copy(&conn->le.dst, &id_addr);
    a2e6:	a902      	add	r1, sp, #8
	conn->handle = handle;
    a2e8:	f820 7b74 	strh.w	r7, [r0], #116
	bt_addr_le_copy(&conn->le.dst, &id_addr);
    a2ec:	f018 f8d2 	bl	22494 <bt_addr_le_copy>
	conn->le.interval = sys_le16_to_cpu(evt->interval);
    a2f0:	7e2a      	ldrb	r2, [r5, #24]
    a2f2:	7deb      	ldrb	r3, [r5, #23]
    a2f4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    a2f8:	f8a4 308a 	strh.w	r3, [r4, #138]	; 0x8a
	conn->le.latency = sys_le16_to_cpu(evt->latency);
    a2fc:	7eaa      	ldrb	r2, [r5, #26]
    a2fe:	7e6b      	ldrb	r3, [r5, #25]
    a300:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    a304:	f8a4 3090 	strh.w	r3, [r4, #144]	; 0x90
	conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
    a308:	7f2a      	ldrb	r2, [r5, #28]
    a30a:	7eeb      	ldrb	r3, [r5, #27]
    a30c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    a310:	f8a4 3092 	strh.w	r3, [r4, #146]	; 0x92
	conn->role = evt->role;
    a314:	78ea      	ldrb	r2, [r5, #3]
    a316:	70e2      	strb	r2, [r4, #3]
	conn->err = 0U;
    a318:	2600      	movs	r6, #0
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    a31a:	2a01      	cmp	r2, #1
	conn->err = 0U;
    a31c:	7326      	strb	r6, [r4, #12]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    a31e:	d11c      	bne.n	a35a <enh_conn_complete+0x166>
		bt_addr_le_copy(&conn->le.init_addr, &peer_addr);
    a320:	4669      	mov	r1, sp
    a322:	f104 007b 	add.w	r0, r4, #123	; 0x7b
    a326:	f018 f8b5 	bl	22494 <bt_addr_le_copy>
			bt_addr_copy(&conn->le.resp_addr.a, &evt->local_rpa);
    a32a:	f105 010b 	add.w	r1, r5, #11
    a32e:	f104 0083 	add.w	r0, r4, #131	; 0x83
    a332:	f018 f8aa 	bl	2248a <bt_addr_copy>
		if (atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    a336:	4b13      	ldr	r3, [pc, #76]	; (a384 <enh_conn_complete+0x190>)
			conn->le.resp_addr.type = BT_ADDR_LE_RANDOM;
    a338:	f884 2082 	strb.w	r2, [r4, #130]	; 0x82
		if (atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    a33c:	2108      	movs	r1, #8
    a33e:	f103 0070 	add.w	r0, r3, #112	; 0x70
    a342:	f018 f8ae 	bl	224a2 <atomic_test_bit>
    a346:	b140      	cbz	r0, a35a <enh_conn_complete+0x166>
		    BT_LE_STATES_SLAVE_CONN_ADV(bt_dev.le.states)) {
    a348:	f8d3 1084 	ldr.w	r1, [r3, #132]	; 0x84
    a34c:	4632      	mov	r2, r6
    a34e:	f001 0340 	and.w	r3, r1, #64	; 0x40
		if (atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    a352:	4313      	orrs	r3, r2
    a354:	d001      	beq.n	a35a <enh_conn_complete+0x166>
			bt_le_adv_resume();
    a356:	f7ff fec9 	bl	a0ec <bt_le_adv_resume>
	bt_conn_set_state(conn, BT_CONN_CONNECTED);
    a35a:	4620      	mov	r0, r4
    a35c:	2106      	movs	r1, #6
    a35e:	f000 fc83 	bl	ac68 <bt_conn_set_state>
	conn_auto_initiate(conn);
    a362:	4620      	mov	r0, r4
    a364:	f7fe fdf6 	bl	8f54 <conn_auto_initiate>
    a368:	e76e      	b.n	a248 <enh_conn_complete+0x54>
    a36a:	bf00      	nop
    a36c:	2000e548 	.word	0x2000e548
    a370:	0002255f 	.word	0x0002255f
    a374:	00028540 	.word	0x00028540
    a378:	00028610 	.word	0x00028610
    a37c:	0006315d 	.word	0x0006315d
    a380:	00063176 	.word	0x00063176
    a384:	2000e4d8 	.word	0x2000e4d8

0000a388 <le_legacy_conn_complete>:
{
    a388:	b530      	push	{r4, r5, lr}
	struct bt_hci_evt_le_conn_complete *evt = (void *)buf->data;
    a38a:	6882      	ldr	r2, [r0, #8]
		bt_addr_copy(&enh.local_rpa, &bt_dev.random_addr.a);
    a38c:	4d27      	ldr	r5, [pc, #156]	; (a42c <le_legacy_conn_complete+0xa4>)
	enh.status         = evt->status;
    a38e:	7813      	ldrb	r3, [r2, #0]
{
    a390:	b08b      	sub	sp, #44	; 0x2c
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
    a392:	ac03      	add	r4, sp, #12
	enh.status         = evt->status;
    a394:	f88d 3008 	strb.w	r3, [sp, #8]
	enh.handle         = evt->handle;
    a398:	f8b2 3001 	ldrh.w	r3, [r2, #1]
    a39c:	f8ad 3009 	strh.w	r3, [sp, #9]
	enh.role           = evt->role;
    a3a0:	78d3      	ldrb	r3, [r2, #3]
    a3a2:	f88d 300b 	strb.w	r3, [sp, #11]
	enh.interval       = evt->interval;
    a3a6:	f8b2 300b 	ldrh.w	r3, [r2, #11]
    a3aa:	f8ad 301f 	strh.w	r3, [sp, #31]
	enh.latency        = evt->latency;
    a3ae:	f8b2 300d 	ldrh.w	r3, [r2, #13]
    a3b2:	f8ad 3021 	strh.w	r3, [sp, #33]	; 0x21
	enh.supv_timeout   = evt->supv_timeout;
    a3b6:	f8b2 300f 	ldrh.w	r3, [r2, #15]
    a3ba:	f8ad 3023 	strh.w	r3, [sp, #35]	; 0x23
	enh.clock_accuracy = evt->clock_accuracy;
    a3be:	7c53      	ldrb	r3, [r2, #17]
    a3c0:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
    a3c4:	1d11      	adds	r1, r2, #4
    a3c6:	4620      	mov	r0, r4
    a3c8:	f018 f864 	bl	22494 <bt_addr_le_copy>
		bt_addr_copy(&enh.local_rpa, &bt_dev.random_addr.a);
    a3cc:	f10d 0013 	add.w	r0, sp, #19
    a3d0:	f105 010a 	add.w	r1, r5, #10
    a3d4:	f018 f859 	bl	2248a <bt_addr_copy>
	if (evt->role == BT_HCI_ROLE_SLAVE) {
    a3d8:	78d3      	ldrb	r3, [r2, #3]
    a3da:	2b01      	cmp	r3, #1
		id_addr = bt_lookup_id_addr(bt_dev.adv_id, &enh.peer_addr);
    a3dc:	bf0c      	ite	eq
    a3de:	7a28      	ldrbeq	r0, [r5, #8]
		id_addr = bt_lookup_id_addr(BT_ID_DEFAULT, &enh.peer_addr);
    a3e0:	2000      	movne	r0, #0
		id_addr = bt_lookup_id_addr(bt_dev.adv_id, &enh.peer_addr);
    a3e2:	4621      	mov	r1, r4
		id_addr = bt_lookup_id_addr(BT_ID_DEFAULT, &enh.peer_addr);
    a3e4:	f018 f893 	bl	2250e <bt_lookup_id_addr>
	if (id_addr != &enh.peer_addr) {
    a3e8:	42a0      	cmp	r0, r4
		id_addr = bt_lookup_id_addr(BT_ID_DEFAULT, &enh.peer_addr);
    a3ea:	4602      	mov	r2, r0
	if (id_addr != &enh.peer_addr) {
    a3ec:	d013      	beq.n	a416 <le_legacy_conn_complete+0x8e>
		bt_addr_copy(&enh.peer_rpa, &enh.peer_addr.a);
    a3ee:	f10d 010d 	add.w	r1, sp, #13
    a3f2:	f10d 0019 	add.w	r0, sp, #25
    a3f6:	f018 f848 	bl	2248a <bt_addr_copy>
		bt_addr_le_copy(&enh.peer_addr, id_addr);
    a3fa:	4620      	mov	r0, r4
    a3fc:	4611      	mov	r1, r2
    a3fe:	f018 f849 	bl	22494 <bt_addr_le_copy>
		enh.peer_addr.type += BT_ADDR_LE_PUBLIC_ID;
    a402:	f89d 300c 	ldrb.w	r3, [sp, #12]
    a406:	3302      	adds	r3, #2
    a408:	f88d 300c 	strb.w	r3, [sp, #12]
	enh_conn_complete(&enh);
    a40c:	a802      	add	r0, sp, #8
    a40e:	f7ff fef1 	bl	a1f4 <enh_conn_complete>
}
    a412:	b00b      	add	sp, #44	; 0x2c
    a414:	bd30      	pop	{r4, r5, pc}
		bt_addr_copy(&enh.peer_rpa, BT_ADDR_ANY);
    a416:	2300      	movs	r3, #0
    a418:	4669      	mov	r1, sp
    a41a:	f10d 0019 	add.w	r0, sp, #25
    a41e:	9300      	str	r3, [sp, #0]
    a420:	f8ad 3004 	strh.w	r3, [sp, #4]
    a424:	f018 f831 	bl	2248a <bt_addr_copy>
    a428:	e7f0      	b.n	a40c <le_legacy_conn_complete+0x84>
    a42a:	bf00      	nop
    a42c:	2000e4d8 	.word	0x2000e4d8

0000a430 <bt_buf_get_rx>:
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_HOST_CHAN_CLASSIF,
				    buf, NULL);
}

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, s32_t timeout)
{
    a430:	b538      	push	{r3, r4, r5, lr}
    a432:	4605      	mov	r5, r0
		buf = net_buf_alloc(&hci_rx_pool, timeout);
	} else {
		buf = net_buf_alloc(&acl_in_pool, timeout);
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
    a434:	4805      	ldr	r0, [pc, #20]	; (a44c <bt_buf_get_rx+0x1c>)
    a436:	f01a fc9b 	bl	24d70 <net_buf_alloc_fixed>
#endif

	if (buf) {
    a43a:	4604      	mov	r4, r0
    a43c:	b120      	cbz	r0, a448 <bt_buf_get_rx+0x18>
		net_buf_reserve(buf, BT_BUF_RESERVE);
    a43e:	2100      	movs	r1, #0
    a440:	3008      	adds	r0, #8
    a442:	f01a fcb4 	bl	24dae <net_buf_simple_reserve>
	*(u8_t *)net_buf_user_data(buf) = type;
    a446:	7525      	strb	r5, [r4, #20]
		bt_buf_set_type(buf, type);
	}

	return buf;
}
    a448:	4620      	mov	r0, r4
    a44a:	bd38      	pop	{r3, r4, r5, pc}
    a44c:	2000f0bc 	.word	0x2000f0bc

0000a450 <bt_buf_get_cmd_complete>:

struct net_buf *bt_buf_get_cmd_complete(s32_t timeout)
{
    a450:	b510      	push	{r4, lr}
    a452:	4601      	mov	r1, r0
	__asm__ volatile(
    a454:	f04f 0320 	mov.w	r3, #32
    a458:	f3ef 8011 	mrs	r0, BASEPRI
    a45c:	f383 8811 	msr	BASEPRI, r3
    a460:	f3bf 8f6f 	isb	sy
	struct net_buf *buf;
	unsigned int key;

	key = irq_lock();
	buf = bt_dev.sent_cmd;
    a464:	4a0c      	ldr	r2, [pc, #48]	; (a498 <bt_buf_get_cmd_complete+0x48>)
	bt_dev.sent_cmd = NULL;
    a466:	2300      	movs	r3, #0
	buf = bt_dev.sent_cmd;
    a468:	f8d2 40c0 	ldr.w	r4, [r2, #192]	; 0xc0
	bt_dev.sent_cmd = NULL;
    a46c:	f8c2 30c0 	str.w	r3, [r2, #192]	; 0xc0
	__asm__ volatile(
    a470:	f380 8811 	msr	BASEPRI, r0
    a474:	f3bf 8f6f 	isb	sy
	irq_unlock(key);

	BT_DBG("sent_cmd %p", buf);

	if (buf) {
    a478:	b924      	cbnz	r4, a484 <bt_buf_get_cmd_complete+0x34>
		net_buf_reserve(buf, BT_BUF_RESERVE);

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
    a47a:	2001      	movs	r0, #1
}
    a47c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
    a480:	f7ff bfd6 	b.w	a430 <bt_buf_get_rx>
    a484:	2201      	movs	r2, #1
		net_buf_reserve(buf, BT_BUF_RESERVE);
    a486:	f104 0008 	add.w	r0, r4, #8
    a48a:	7522      	strb	r2, [r4, #20]
		buf->len = 0U;
    a48c:	81a3      	strh	r3, [r4, #12]
		net_buf_reserve(buf, BT_BUF_RESERVE);
    a48e:	4619      	mov	r1, r3
    a490:	f01a fc8d 	bl	24dae <net_buf_simple_reserve>
}
    a494:	4620      	mov	r0, r4
    a496:	bd10      	pop	{r4, pc}
    a498:	2000e4d8 	.word	0x2000e4d8

0000a49c <bt_buf_get_evt>:

struct net_buf *bt_buf_get_evt(u8_t evt, bool discardable, s32_t timeout)
{
	switch (evt) {
    a49c:	280e      	cmp	r0, #14
{
    a49e:	460b      	mov	r3, r1
    a4a0:	b510      	push	{r4, lr}
    a4a2:	4611      	mov	r1, r2
	switch (evt) {
    a4a4:	d315      	bcc.n	a4d2 <bt_buf_get_evt+0x36>
    a4a6:	280f      	cmp	r0, #15
    a4a8:	d90e      	bls.n	a4c8 <bt_buf_get_evt+0x2c>
    a4aa:	2813      	cmp	r0, #19
    a4ac:	d111      	bne.n	a4d2 <bt_buf_get_evt+0x36>
#if defined(CONFIG_BT_CONN)
	case BT_HCI_EVT_NUM_COMPLETED_PACKETS:
		{
			struct net_buf *buf;

			buf = net_buf_alloc(&num_complete_pool, timeout);
    a4ae:	480d      	ldr	r0, [pc, #52]	; (a4e4 <bt_buf_get_evt+0x48>)
	default:
#if defined(CONFIG_BT_DISCARDABLE_BUF_COUNT)
		if (discardable) {
			struct net_buf *buf;

			buf = net_buf_alloc(&discardable_pool, timeout);
    a4b0:	f01a fc5e 	bl	24d70 <net_buf_alloc_fixed>
			if (buf) {
    a4b4:	4604      	mov	r4, r0
    a4b6:	b128      	cbz	r0, a4c4 <bt_buf_get_evt+0x28>
				net_buf_reserve(buf, BT_BUF_RESERVE);
    a4b8:	2100      	movs	r1, #0
    a4ba:	3008      	adds	r0, #8
    a4bc:	f01a fc77 	bl	24dae <net_buf_simple_reserve>
    a4c0:	2301      	movs	r3, #1
    a4c2:	7523      	strb	r3, [r4, #20]
		}
#endif /* CONFIG_BT_DISCARDABLE_BUF_COUNT */

		return bt_buf_get_rx(BT_BUF_EVT, timeout);
	}
}
    a4c4:	4620      	mov	r0, r4
    a4c6:	bd10      	pop	{r4, pc}
		return bt_buf_get_cmd_complete(timeout);
    a4c8:	4610      	mov	r0, r2
}
    a4ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return bt_buf_get_cmd_complete(timeout);
    a4ce:	f7ff bfbf 	b.w	a450 <bt_buf_get_cmd_complete>
		if (discardable) {
    a4d2:	b10b      	cbz	r3, a4d8 <bt_buf_get_evt+0x3c>
			buf = net_buf_alloc(&discardable_pool, timeout);
    a4d4:	4804      	ldr	r0, [pc, #16]	; (a4e8 <bt_buf_get_evt+0x4c>)
    a4d6:	e7eb      	b.n	a4b0 <bt_buf_get_evt+0x14>
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
    a4d8:	2001      	movs	r0, #1
}
    a4da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
    a4de:	f7ff bfa7 	b.w	a430 <bt_buf_get_rx>
    a4e2:	bf00      	nop
    a4e4:	2000f0e0 	.word	0x2000f0e0
    a4e8:	2000f050 	.word	0x2000f050

0000a4ec <bt_pub_key_gen>:
}
#endif /* CONFIG_BT_BREDR */

#if defined(CONFIG_BT_ECC)
int bt_pub_key_gen(struct bt_pub_key_cb *new_cb)
{
    a4ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	 * We check for both "LE Read Local P-256 Public Key" and
	 * "LE Generate DH Key" support here since both commands are needed for
	 * ECC support. If "LE Generate DH Key" is not supported then there
	 * is no point in reading local public key.
	 */
	if (!BT_CMD_TEST(bt_dev.supported_commands, 34, 1) ||
    a4ee:	4d26      	ldr	r5, [pc, #152]	; (a588 <bt_pub_key_gen+0x9c>)
    a4f0:	f895 3042 	ldrb.w	r3, [r5, #66]	; 0x42
    a4f4:	f003 0306 	and.w	r3, r3, #6
    a4f8:	2b06      	cmp	r3, #6
    a4fa:	d011      	beq.n	a520 <bt_pub_key_gen+0x34>
	    !BT_CMD_TEST(bt_dev.supported_commands, 34, 2)) {
		BT_WARN("ECC HCI commands not available");
    a4fc:	2302      	movs	r3, #2
    a4fe:	f04f 0100 	mov.w	r1, #0
    a502:	f363 0107 	bfi	r1, r3, #0, #8
    a506:	4a21      	ldr	r2, [pc, #132]	; (a58c <bt_pub_key_gen+0xa0>)
    a508:	4b21      	ldr	r3, [pc, #132]	; (a590 <bt_pub_key_gen+0xa4>)
    a50a:	4822      	ldr	r0, [pc, #136]	; (a594 <bt_pub_key_gen+0xa8>)
    a50c:	1a9b      	subs	r3, r3, r2
    a50e:	08db      	lsrs	r3, r3, #3
    a510:	f363 118f 	bfi	r1, r3, #6, #10
    a514:	f016 fd91 	bl	2103a <log_0>
		return -ENOTSUP;
    a518:	f06f 0485 	mvn.w	r4, #133	; 0x85
		pub_key_cb = NULL;
		return err;
	}

	return 0;
}
    a51c:	4620      	mov	r0, r4
    a51e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	new_cb->_next = pub_key_cb;
    a520:	4e1d      	ldr	r6, [pc, #116]	; (a598 <bt_pub_key_gen+0xac>)
    a522:	6833      	ldr	r3, [r6, #0]
    a524:	6043      	str	r3, [r0, #4]
	pub_key_cb = new_cb;
    a526:	6030      	str	r0, [r6, #0]
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    a528:	2110      	movs	r1, #16
    a52a:	f105 0070 	add.w	r0, r5, #112	; 0x70
    a52e:	f017 ff5c 	bl	223ea <atomic_or>
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
    a532:	f010 0710 	ands.w	r7, r0, #16
    a536:	d124      	bne.n	a582 <bt_pub_key_gen+0x96>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    a538:	f06f 0108 	mvn.w	r1, #8
    a53c:	f105 0070 	add.w	r0, r5, #112	; 0x70
    a540:	f017 ff44 	bl	223cc <atomic_and>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_P256_PUBLIC_KEY, NULL, NULL);
    a544:	463a      	mov	r2, r7
    a546:	4639      	mov	r1, r7
    a548:	f242 0025 	movw	r0, #8229	; 0x2025
    a54c:	f7fe fb0c 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    a550:	4604      	mov	r4, r0
    a552:	2800      	cmp	r0, #0
    a554:	d0e2      	beq.n	a51c <bt_pub_key_gen+0x30>
		BT_ERR("Sending LE P256 Public Key command failed");
    a556:	2301      	movs	r3, #1
    a558:	f04f 0100 	mov.w	r1, #0
    a55c:	4a0b      	ldr	r2, [pc, #44]	; (a58c <bt_pub_key_gen+0xa0>)
    a55e:	480f      	ldr	r0, [pc, #60]	; (a59c <bt_pub_key_gen+0xb0>)
    a560:	f363 0107 	bfi	r1, r3, #0, #8
    a564:	4b0a      	ldr	r3, [pc, #40]	; (a590 <bt_pub_key_gen+0xa4>)
    a566:	1a9b      	subs	r3, r3, r2
    a568:	08db      	lsrs	r3, r3, #3
    a56a:	f363 118f 	bfi	r1, r3, #6, #10
    a56e:	f016 fd64 	bl	2103a <log_0>
    a572:	f06f 0110 	mvn.w	r1, #16
    a576:	f105 0070 	add.w	r0, r5, #112	; 0x70
    a57a:	f017 ff27 	bl	223cc <atomic_and>
		pub_key_cb = NULL;
    a57e:	6037      	str	r7, [r6, #0]
		return err;
    a580:	e7cc      	b.n	a51c <bt_pub_key_gen+0x30>
		return 0;
    a582:	2400      	movs	r4, #0
    a584:	e7ca      	b.n	a51c <bt_pub_key_gen+0x30>
    a586:	bf00      	nop
    a588:	2000e4d8 	.word	0x2000e4d8
    a58c:	00028540 	.word	0x00028540
    a590:	00028610 	.word	0x00028610
    a594:	00062f1d 	.word	0x00062f1d
    a598:	2000032c 	.word	0x2000032c
    a59c:	00062f3c 	.word	0x00062f3c

0000a5a0 <bt_pub_key_get>:

const u8_t *bt_pub_key_get(void)
{
    a5a0:	b508      	push	{r3, lr}
	if (atomic_test_bit(bt_dev.flags, BT_DEV_HAS_PUB_KEY)) {
    a5a2:	2103      	movs	r1, #3
    a5a4:	4803      	ldr	r0, [pc, #12]	; (a5b4 <bt_pub_key_get+0x14>)
    a5a6:	f017 ff7c 	bl	224a2 <atomic_test_bit>
    a5aa:	2800      	cmp	r0, #0
		return pub_key;
	}

	return NULL;
}
    a5ac:	4802      	ldr	r0, [pc, #8]	; (a5b8 <bt_pub_key_get+0x18>)
    a5ae:	bf08      	it	eq
    a5b0:	2000      	moveq	r0, #0
    a5b2:	bd08      	pop	{r3, pc}
    a5b4:	2000e548 	.word	0x2000e548
    a5b8:	2000a9f9 	.word	0x2000a9f9

0000a5bc <bt_dh_key_gen>:

int bt_dh_key_gen(const u8_t remote_pk[64], bt_dh_key_cb_t cb)
{
    a5bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_hci_cp_le_generate_dhkey *cp;
	struct net_buf *buf;
	int err;

	if (dh_key_cb || atomic_test_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
    a5be:	4e1d      	ldr	r6, [pc, #116]	; (a634 <bt_dh_key_gen+0x78>)
    a5c0:	6832      	ldr	r2, [r6, #0]
{
    a5c2:	4604      	mov	r4, r0
    a5c4:	460b      	mov	r3, r1
    a5c6:	4637      	mov	r7, r6
	if (dh_key_cb || atomic_test_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
    a5c8:	b112      	cbz	r2, a5d0 <bt_dh_key_gen+0x14>
		return -EBUSY;
    a5ca:	f06f 000f 	mvn.w	r0, #15
		dh_key_cb = NULL;
		return err;
	}

	return 0;
}
    a5ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (dh_key_cb || atomic_test_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
    a5d0:	2104      	movs	r1, #4
    a5d2:	4819      	ldr	r0, [pc, #100]	; (a638 <bt_dh_key_gen+0x7c>)
    a5d4:	f017 ff65 	bl	224a2 <atomic_test_bit>
    a5d8:	2800      	cmp	r0, #0
    a5da:	d1f6      	bne.n	a5ca <bt_dh_key_gen+0xe>
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_HAS_PUB_KEY)) {
    a5dc:	2103      	movs	r1, #3
    a5de:	4816      	ldr	r0, [pc, #88]	; (a638 <bt_dh_key_gen+0x7c>)
    a5e0:	f017 ff5f 	bl	224a2 <atomic_test_bit>
    a5e4:	b318      	cbz	r0, a62e <bt_dh_key_gen+0x72>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_GENERATE_DHKEY, sizeof(*cp));
    a5e6:	2140      	movs	r1, #64	; 0x40
    a5e8:	f242 0026 	movw	r0, #8230	; 0x2026
	dh_key_cb = cb;
    a5ec:	6033      	str	r3, [r6, #0]
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_GENERATE_DHKEY, sizeof(*cp));
    a5ee:	f7fe f945 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
    a5f2:	4605      	mov	r5, r0
    a5f4:	b918      	cbnz	r0, a5fe <bt_dh_key_gen+0x42>
		dh_key_cb = NULL;
    a5f6:	6030      	str	r0, [r6, #0]
		return -ENOBUFS;
    a5f8:	f06f 0068 	mvn.w	r0, #104	; 0x68
    a5fc:	e7e7      	b.n	a5ce <bt_dh_key_gen+0x12>
	cp = net_buf_add(buf, sizeof(*cp));
    a5fe:	2140      	movs	r1, #64	; 0x40
    a600:	3008      	adds	r0, #8
    a602:	f01a fbe9 	bl	24dd8 <net_buf_simple_add>
    a606:	4623      	mov	r3, r4
    a608:	f104 0240 	add.w	r2, r4, #64	; 0x40
    a60c:	f853 1b04 	ldr.w	r1, [r3], #4
    a610:	f840 1b04 	str.w	r1, [r0], #4
    a614:	4293      	cmp	r3, r2
    a616:	d1f9      	bne.n	a60c <bt_dh_key_gen+0x50>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_GENERATE_DHKEY, buf, NULL);
    a618:	2200      	movs	r2, #0
    a61a:	4629      	mov	r1, r5
    a61c:	f242 0026 	movw	r0, #8230	; 0x2026
    a620:	f7fe faa2 	bl	8b68 <bt_hci_cmd_send_sync>
	if (err) {
    a624:	2800      	cmp	r0, #0
    a626:	d0d2      	beq.n	a5ce <bt_dh_key_gen+0x12>
		dh_key_cb = NULL;
    a628:	2300      	movs	r3, #0
    a62a:	603b      	str	r3, [r7, #0]
		return err;
    a62c:	e7cf      	b.n	a5ce <bt_dh_key_gen+0x12>
		return -EADDRNOTAVAIL;
    a62e:	f06f 007c 	mvn.w	r0, #124	; 0x7c
    a632:	e7cc      	b.n	a5ce <bt_dh_key_gen+0x12>
    a634:	20000328 	.word	0x20000328
    a638:	2000e548 	.word	0x2000e548

0000a63c <tx_free>:
	return bt_l2cap_update_conn_param(conn, param);
}

static void tx_free(struct bt_conn_tx *tx)
{
	tx->cb = NULL;
    a63c:	2300      	movs	r3, #0
{
    a63e:	4601      	mov	r1, r0
	tx->user_data = NULL;
    a640:	e9c0 3301 	strd	r3, r3, [r0, #4]
	tx->pending_no_cb = 0U;
    a644:	60c3      	str	r3, [r0, #12]
	k_fifo_put(&free_tx, tx);
    a646:	4801      	ldr	r0, [pc, #4]	; (a64c <tx_free+0x10>)
    a648:	f01d ba5d 	b.w	27b06 <k_queue_append>
    a64c:	2000efe0 	.word	0x2000efe0

0000a650 <notify_connected>:
{
    a650:	b538      	push	{r3, r4, r5, lr}
	for (cb = callback_list; cb; cb = cb->_next) {
    a652:	4b09      	ldr	r3, [pc, #36]	; (a678 <notify_connected+0x28>)
    a654:	681c      	ldr	r4, [r3, #0]
{
    a656:	4605      	mov	r5, r0
    a658:	7b29      	ldrb	r1, [r5, #12]
	for (cb = callback_list; cb; cb = cb->_next) {
    a65a:	b92c      	cbnz	r4, a668 <notify_connected+0x18>
	if (!conn->err) {
    a65c:	b951      	cbnz	r1, a674 <notify_connected+0x24>
		bt_gatt_connected(conn);
    a65e:	4628      	mov	r0, r5
}
    a660:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		bt_gatt_connected(conn);
    a664:	f003 bdf4 	b.w	e250 <bt_gatt_connected>
		if (cb->connected) {
    a668:	6823      	ldr	r3, [r4, #0]
    a66a:	b10b      	cbz	r3, a670 <notify_connected+0x20>
			cb->connected(conn, conn->err);
    a66c:	4628      	mov	r0, r5
    a66e:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
    a670:	69a4      	ldr	r4, [r4, #24]
    a672:	e7f1      	b.n	a658 <notify_connected+0x8>
}
    a674:	bd38      	pop	{r3, r4, r5, pc}
    a676:	bf00      	nop
    a678:	200003a4 	.word	0x200003a4

0000a67c <send_frag>:
	return 0;
}

static bool send_frag(struct bt_conn *conn, struct net_buf *buf, u8_t flags,
		      bool always_consume)
{
    a67c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    a680:	4604      	mov	r4, r0
    a682:	460e      	mov	r6, r1
    a684:	4691      	mov	r9, r2
    a686:	461f      	mov	r7, r3
	struct bt_conn_tx *tx = tx_data(buf)->tx;
    a688:	694d      	ldr	r5, [r1, #20]
	return z_impl_k_sem_take(sem, timeout);
    a68a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    a68e:	4844      	ldr	r0, [pc, #272]	; (a7a0 <send_frag+0x124>)
    a690:	f014 fba0 	bl	1edd4 <z_impl_k_sem_take>

	/* Wait until the controller can accept ACL packets */
	k_sem_take(bt_conn_get_pkts(conn), K_FOREVER);

	/* Check for disconnection while waiting for pkts_sem */
	if (conn->state != BT_CONN_CONNECTED) {
    a694:	7b63      	ldrb	r3, [r4, #13]
    a696:	2b06      	cmp	r3, #6
    a698:	d152      	bne.n	a740 <send_frag+0xc4>
		goto fail;
	}

	hdr = net_buf_push(buf, sizeof(*hdr));
    a69a:	2104      	movs	r1, #4
    a69c:	f106 0008 	add.w	r0, r6, #8
    a6a0:	f01a fbbc 	bl	24e1c <net_buf_simple_push>
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
    a6a4:	8822      	ldrh	r2, [r4, #0]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
    a6a6:	89b3      	ldrh	r3, [r6, #12]
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
    a6a8:	ea42 3209 	orr.w	r2, r2, r9, lsl #12
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
    a6ac:	3b04      	subs	r3, #4
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
    a6ae:	8002      	strh	r2, [r0, #0]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
    a6b0:	8043      	strh	r3, [r0, #2]
	__asm__ volatile(
    a6b2:	f04f 0320 	mov.w	r3, #32
    a6b6:	f3ef 8211 	mrs	r2, BASEPRI
    a6ba:	f383 8811 	msr	BASEPRI, r3
    a6be:	f3bf 8f6f 	isb	sy

	/* Add to pending, it must be done before bt_buf_set_type */
	key = irq_lock();
	if (tx) {
    a6c2:	2d00      	cmp	r5, #0
    a6c4:	d04e      	beq.n	a764 <send_frag+0xe8>
	parent->next = child;
    a6c6:	2300      	movs	r3, #0
    a6c8:	602b      	str	r3, [r5, #0]
Z_GENLIST_APPEND(slist, snode)
    a6ca:	69a3      	ldr	r3, [r4, #24]
    a6cc:	2b00      	cmp	r3, #0
    a6ce:	d146      	bne.n	a75e <send_frag+0xe2>
	list->head = node;
    a6d0:	e9c4 5505 	strd	r5, r5, [r4, #20]
	__asm__ volatile(
    a6d4:	f382 8811 	msr	BASEPRI, r2
    a6d8:	f3bf 8f6f 	isb	sy
    a6dc:	2302      	movs	r3, #2
    a6de:	7533      	strb	r3, [r6, #20]
	}
	irq_unlock(key);

	bt_buf_set_type(buf, BT_BUF_ACL_OUT);

	err = bt_send(buf);
    a6e0:	4630      	mov	r0, r6
    a6e2:	f017 ff5a 	bl	2259a <bt_send>
	if (err) {
    a6e6:	4601      	mov	r1, r0
    a6e8:	2800      	cmp	r0, #0
    a6ea:	d057      	beq.n	a79c <send_frag+0x120>
		BT_ERR("Unable to send to driver (err %d)", err);
    a6ec:	2301      	movs	r3, #1
    a6ee:	f04f 0200 	mov.w	r2, #0
    a6f2:	f363 0207 	bfi	r2, r3, #0, #8
    a6f6:	482b      	ldr	r0, [pc, #172]	; (a7a4 <send_frag+0x128>)
    a6f8:	4b2b      	ldr	r3, [pc, #172]	; (a7a8 <send_frag+0x12c>)
    a6fa:	1a1b      	subs	r3, r3, r0
    a6fc:	08db      	lsrs	r3, r3, #3
    a6fe:	f363 128f 	bfi	r2, r3, #6, #10
    a702:	482a      	ldr	r0, [pc, #168]	; (a7ac <send_frag+0x130>)
    a704:	f016 fca6 	bl	21054 <log_1>
	__asm__ volatile(
    a708:	f04f 0320 	mov.w	r3, #32
    a70c:	f3ef 8111 	mrs	r1, BASEPRI
    a710:	f383 8811 	msr	BASEPRI, r3
    a714:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		/* Roll back the pending TX info */
		if (tx) {
    a718:	2d00      	cmp	r5, #0
    a71a:	d039      	beq.n	a790 <send_frag+0x114>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    a71c:	6963      	ldr	r3, [r4, #20]
    a71e:	2200      	movs	r2, #0
    a720:	b153      	cbz	r3, a738 <send_frag+0xbc>
    a722:	429d      	cmp	r5, r3
    a724:	d131      	bne.n	a78a <send_frag+0x10e>
Z_GENLIST_REMOVE(slist, snode)
    a726:	682b      	ldr	r3, [r5, #0]
    a728:	bb4a      	cbnz	r2, a77e <send_frag+0x102>
    a72a:	69a2      	ldr	r2, [r4, #24]
	list->head = node;
    a72c:	6163      	str	r3, [r4, #20]
Z_GENLIST_REMOVE(slist, snode)
    a72e:	4295      	cmp	r5, r2
    a730:	d100      	bne.n	a734 <send_frag+0xb8>
	list->tail = node;
    a732:	61a3      	str	r3, [r4, #24]
	parent->next = child;
    a734:	2300      	movs	r3, #0
    a736:	602b      	str	r3, [r5, #0]
	__asm__ volatile(
    a738:	f381 8811 	msr	BASEPRI, r1
    a73c:	f3bf 8f6f 	isb	sy
	z_impl_k_sem_give(sem);
    a740:	4817      	ldr	r0, [pc, #92]	; (a7a0 <send_frag+0x124>)
    a742:	f014 fb1b 	bl	1ed7c <z_impl_k_sem_give>

	return true;

fail:
	k_sem_give(bt_conn_get_pkts(conn));
	if (tx) {
    a746:	b115      	cbz	r5, a74e <send_frag+0xd2>
		tx_free(tx);
    a748:	4628      	mov	r0, r5
    a74a:	f7ff ff77 	bl	a63c <tx_free>
	}

	if (always_consume) {
    a74e:	b11f      	cbz	r7, a758 <send_frag+0xdc>
		net_buf_unref(buf);
    a750:	4630      	mov	r0, r6
    a752:	f00e fc83 	bl	1905c <net_buf_unref>
	}
	return false;
    a756:	2700      	movs	r7, #0
}
    a758:	4638      	mov	r0, r7
    a75a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a75e:	601d      	str	r5, [r3, #0]
	list->tail = node;
    a760:	61a5      	str	r5, [r4, #24]
    a762:	e7b7      	b.n	a6d4 <send_frag+0x58>
		tail_tx = (void *)sys_slist_peek_tail(&conn->tx_pending);
    a764:	69a3      	ldr	r3, [r4, #24]
		if (tail_tx) {
    a766:	b133      	cbz	r3, a776 <send_frag+0xfa>
			pending_no_cb = &tail_tx->pending_no_cb;
    a768:	f103 080c 	add.w	r8, r3, #12
    a76c:	68db      	ldr	r3, [r3, #12]
		(*pending_no_cb)++;
    a76e:	3301      	adds	r3, #1
    a770:	f8c8 3000 	str.w	r3, [r8]
    a774:	e7ae      	b.n	a6d4 <send_frag+0x58>
			pending_no_cb = &conn->pending_no_cb;
    a776:	f104 081c 	add.w	r8, r4, #28
    a77a:	69e3      	ldr	r3, [r4, #28]
    a77c:	e7f7      	b.n	a76e <send_frag+0xf2>
	parent->next = child;
    a77e:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
    a780:	69a3      	ldr	r3, [r4, #24]
    a782:	429d      	cmp	r5, r3
	list->tail = node;
    a784:	bf08      	it	eq
    a786:	61a2      	streq	r2, [r4, #24]
    a788:	e7d4      	b.n	a734 <send_frag+0xb8>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    a78a:	461a      	mov	r2, r3
    a78c:	681b      	ldr	r3, [r3, #0]
    a78e:	e7c7      	b.n	a720 <send_frag+0xa4>
			(*pending_no_cb)--;
    a790:	f8d8 3000 	ldr.w	r3, [r8]
    a794:	3b01      	subs	r3, #1
    a796:	f8c8 3000 	str.w	r3, [r8]
    a79a:	e7cd      	b.n	a738 <send_frag+0xbc>
	return true;
    a79c:	2701      	movs	r7, #1
    a79e:	e7db      	b.n	a758 <send_frag+0xdc>
    a7a0:	2000e564 	.word	0x2000e564
    a7a4:	00028540 	.word	0x00028540
    a7a8:	00028558 	.word	0x00028558
    a7ac:	00063336 	.word	0x00063336

0000a7b0 <conn_cleanup>:

static struct k_poll_signal conn_change =
		K_POLL_SIGNAL_INITIALIZER(conn_change);

static void conn_cleanup(struct bt_conn *conn)
{
    a7b0:	b570      	push	{r4, r5, r6, lr}
    a7b2:	4605      	mov	r5, r0
	struct net_buf *buf;

	/* Give back any allocated buffers */
	while ((buf = net_buf_get(&conn->tx_queue, K_NO_WAIT))) {
    a7b4:	f100 0634 	add.w	r6, r0, #52	; 0x34
    a7b8:	2100      	movs	r1, #0
    a7ba:	4630      	mov	r0, r6
    a7bc:	f01a fade 	bl	24d7c <net_buf_get>
    a7c0:	4604      	mov	r4, r0
    a7c2:	b950      	cbnz	r0, a7da <conn_cleanup+0x2a>
	}

	__ASSERT(sys_slist_is_empty(&conn->tx_pending), "Pending TX packets");
	__ASSERT_NO_MSG(conn->pending_no_cb == 0);

	bt_conn_reset_rx_state(conn);
    a7c4:	4628      	mov	r0, r5
    a7c6:	f017 ff12 	bl	225ee <bt_conn_reset_rx_state>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    a7ca:	4622      	mov	r2, r4
    a7cc:	f105 0154 	add.w	r1, r5, #84	; 0x54
    a7d0:	4806      	ldr	r0, [pc, #24]	; (a7ec <conn_cleanup+0x3c>)

	k_delayed_work_submit(&conn->update_work, K_NO_WAIT);
}
    a7d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    a7d6:	f014 bc43 	b.w	1f060 <k_delayed_work_submit_to_queue>
		if (tx_data(buf)->tx) {
    a7da:	6960      	ldr	r0, [r4, #20]
    a7dc:	b108      	cbz	r0, a7e2 <conn_cleanup+0x32>
			tx_free(tx_data(buf)->tx);
    a7de:	f7ff ff2d 	bl	a63c <tx_free>
		net_buf_unref(buf);
    a7e2:	4620      	mov	r0, r4
    a7e4:	f00e fc3a 	bl	1905c <net_buf_unref>
    a7e8:	e7e6      	b.n	a7b8 <conn_cleanup+0x8>
    a7ea:	bf00      	nop
    a7ec:	20006090 	.word	0x20006090

0000a7f0 <bt_conn_get_pkts>:
}
    a7f0:	4800      	ldr	r0, [pc, #0]	; (a7f4 <bt_conn_get_pkts+0x4>)
    a7f2:	4770      	bx	lr
    a7f4:	2000e564 	.word	0x2000e564

0000a7f8 <notify_le_param_updated>:
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
    a7f8:	1d02      	adds	r2, r0, #4
{
    a7fa:	b570      	push	{r4, r5, r6, lr}
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
    a7fc:	2109      	movs	r1, #9
{
    a7fe:	4604      	mov	r4, r0
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
    a800:	4610      	mov	r0, r2
    a802:	f017 feed 	bl	225e0 <atomic_test_bit>
    a806:	b1c8      	cbz	r0, a83c <notify_le_param_updated+0x44>
	    conn->le.interval >= conn->le.interval_min &&
    a808:	f8b4 308a 	ldrh.w	r3, [r4, #138]	; 0x8a
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
    a80c:	f8b4 108c 	ldrh.w	r1, [r4, #140]	; 0x8c
    a810:	4299      	cmp	r1, r3
    a812:	d813      	bhi.n	a83c <notify_le_param_updated+0x44>
	    conn->le.interval >= conn->le.interval_min &&
    a814:	f8b4 108e 	ldrh.w	r1, [r4, #142]	; 0x8e
    a818:	4299      	cmp	r1, r3
    a81a:	d30f      	bcc.n	a83c <notify_le_param_updated+0x44>
	    conn->le.latency == conn->le.pending_latency &&
    a81c:	e9d4 1324 	ldrd	r1, r3, [r4, #144]	; 0x90
    a820:	4299      	cmp	r1, r3
    a822:	d10b      	bne.n	a83c <notify_le_param_updated+0x44>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    a824:	f3bf 8f5b 	dmb	ish
    a828:	e852 3f00 	ldrex	r3, [r2]
    a82c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    a830:	e842 3100 	strex	r1, r3, [r2]
    a834:	2900      	cmp	r1, #0
    a836:	d1f7      	bne.n	a828 <notify_le_param_updated+0x30>
    a838:	f3bf 8f5b 	dmb	ish
	for (cb = callback_list; cb; cb = cb->_next) {
    a83c:	4b07      	ldr	r3, [pc, #28]	; (a85c <notify_le_param_updated+0x64>)
    a83e:	681d      	ldr	r5, [r3, #0]
    a840:	b905      	cbnz	r5, a844 <notify_le_param_updated+0x4c>
}
    a842:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->le_param_updated) {
    a844:	68ee      	ldr	r6, [r5, #12]
    a846:	b13e      	cbz	r6, a858 <notify_le_param_updated+0x60>
			cb->le_param_updated(conn, conn->le.interval,
    a848:	f8b4 3092 	ldrh.w	r3, [r4, #146]	; 0x92
    a84c:	f8b4 2090 	ldrh.w	r2, [r4, #144]	; 0x90
    a850:	f8b4 108a 	ldrh.w	r1, [r4, #138]	; 0x8a
    a854:	4620      	mov	r0, r4
    a856:	47b0      	blx	r6
	for (cb = callback_list; cb; cb = cb->_next) {
    a858:	69ad      	ldr	r5, [r5, #24]
    a85a:	e7f1      	b.n	a840 <notify_le_param_updated+0x48>
    a85c:	200003a4 	.word	0x200003a4

0000a860 <le_param_req>:
{
    a860:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a862:	4607      	mov	r7, r0
	if (!bt_le_conn_params_valid(param)) {
    a864:	4608      	mov	r0, r1
{
    a866:	460e      	mov	r6, r1
	if (!bt_le_conn_params_valid(param)) {
    a868:	f017 fe59 	bl	2251e <bt_le_conn_params_valid>
    a86c:	4605      	mov	r5, r0
    a86e:	b910      	cbnz	r0, a876 <le_param_req+0x16>
		return false;
    a870:	2500      	movs	r5, #0
}
    a872:	4628      	mov	r0, r5
    a874:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (cb = callback_list; cb; cb = cb->_next) {
    a876:	4b09      	ldr	r3, [pc, #36]	; (a89c <le_param_req+0x3c>)
    a878:	681c      	ldr	r4, [r3, #0]
    a87a:	2c00      	cmp	r4, #0
    a87c:	d0f9      	beq.n	a872 <le_param_req+0x12>
		if (!cb->le_param_req) {
    a87e:	68a3      	ldr	r3, [r4, #8]
    a880:	b90b      	cbnz	r3, a886 <le_param_req+0x26>
	for (cb = callback_list; cb; cb = cb->_next) {
    a882:	69a4      	ldr	r4, [r4, #24]
    a884:	e7f9      	b.n	a87a <le_param_req+0x1a>
		if (!cb->le_param_req(conn, param)) {
    a886:	4631      	mov	r1, r6
    a888:	4638      	mov	r0, r7
    a88a:	4798      	blx	r3
    a88c:	2800      	cmp	r0, #0
    a88e:	d0ef      	beq.n	a870 <le_param_req+0x10>
		if (!bt_le_conn_params_valid(param)) {
    a890:	4630      	mov	r0, r6
    a892:	f017 fe44 	bl	2251e <bt_le_conn_params_valid>
    a896:	2800      	cmp	r0, #0
    a898:	d1f3      	bne.n	a882 <le_param_req+0x22>
    a89a:	e7e9      	b.n	a870 <le_param_req+0x10>
    a89c:	200003a4 	.word	0x200003a4

0000a8a0 <bt_conn_identity_resolved>:
{
    a8a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (conn->role == BT_HCI_ROLE_MASTER) {
    a8a2:	78c3      	ldrb	r3, [r0, #3]
{
    a8a4:	4604      	mov	r4, r0
	if (conn->role == BT_HCI_ROLE_MASTER) {
    a8a6:	b93b      	cbnz	r3, a8b8 <bt_conn_identity_resolved+0x18>
		rpa = &conn->le.resp_addr;
    a8a8:	f100 0682 	add.w	r6, r0, #130	; 0x82
	for (cb = callback_list; cb; cb = cb->_next) {
    a8ac:	4b08      	ldr	r3, [pc, #32]	; (a8d0 <bt_conn_identity_resolved+0x30>)
    a8ae:	681d      	ldr	r5, [r3, #0]
			cb->identity_resolved(conn, rpa, &conn->le.dst);
    a8b0:	f104 0774 	add.w	r7, r4, #116	; 0x74
	for (cb = callback_list; cb; cb = cb->_next) {
    a8b4:	b91d      	cbnz	r5, a8be <bt_conn_identity_resolved+0x1e>
}
    a8b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		rpa = &conn->le.init_addr;
    a8b8:	f100 067b 	add.w	r6, r0, #123	; 0x7b
    a8bc:	e7f6      	b.n	a8ac <bt_conn_identity_resolved+0xc>
		if (cb->identity_resolved) {
    a8be:	692b      	ldr	r3, [r5, #16]
    a8c0:	b11b      	cbz	r3, a8ca <bt_conn_identity_resolved+0x2a>
			cb->identity_resolved(conn, rpa, &conn->le.dst);
    a8c2:	463a      	mov	r2, r7
    a8c4:	4631      	mov	r1, r6
    a8c6:	4620      	mov	r0, r4
    a8c8:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
    a8ca:	69ad      	ldr	r5, [r5, #24]
    a8cc:	e7f2      	b.n	a8b4 <bt_conn_identity_resolved+0x14>
    a8ce:	bf00      	nop
    a8d0:	200003a4 	.word	0x200003a4

0000a8d4 <bt_conn_security_changed>:
	for (cb = callback_list; cb; cb = cb->_next) {
    a8d4:	4b0c      	ldr	r3, [pc, #48]	; (a908 <bt_conn_security_changed+0x34>)
{
    a8d6:	b570      	push	{r4, r5, r6, lr}
	for (cb = callback_list; cb; cb = cb->_next) {
    a8d8:	681d      	ldr	r5, [r3, #0]
{
    a8da:	4604      	mov	r4, r0
    a8dc:	460e      	mov	r6, r1
	for (cb = callback_list; cb; cb = cb->_next) {
    a8de:	b955      	cbnz	r5, a8f6 <bt_conn_security_changed+0x22>
	if (!err && conn->sec_level >= BT_SECURITY_L2) {
    a8e0:	b98e      	cbnz	r6, a906 <bt_conn_security_changed+0x32>
    a8e2:	7a63      	ldrb	r3, [r4, #9]
    a8e4:	2b01      	cmp	r3, #1
    a8e6:	d90e      	bls.n	a906 <bt_conn_security_changed+0x32>
		bt_keys_update_usage(conn->id, bt_conn_get_dst(conn));
    a8e8:	f104 0174 	add.w	r1, r4, #116	; 0x74
    a8ec:	7a20      	ldrb	r0, [r4, #8]
}
    a8ee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		bt_keys_update_usage(conn->id, bt_conn_get_dst(conn));
    a8f2:	f005 be39 	b.w	10568 <bt_keys_update_usage>
		if (cb->security_changed) {
    a8f6:	696b      	ldr	r3, [r5, #20]
    a8f8:	b11b      	cbz	r3, a902 <bt_conn_security_changed+0x2e>
			cb->security_changed(conn, conn->sec_level, err);
    a8fa:	4632      	mov	r2, r6
    a8fc:	7a61      	ldrb	r1, [r4, #9]
    a8fe:	4620      	mov	r0, r4
    a900:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
    a902:	69ad      	ldr	r5, [r5, #24]
    a904:	e7eb      	b.n	a8de <bt_conn_security_changed+0xa>
}
    a906:	bd70      	pop	{r4, r5, r6, pc}
    a908:	200003a4 	.word	0x200003a4

0000a90c <bt_conn_cb_register>:
	cb->_next = callback_list;
    a90c:	4b02      	ldr	r3, [pc, #8]	; (a918 <bt_conn_cb_register+0xc>)
    a90e:	681a      	ldr	r2, [r3, #0]
    a910:	6182      	str	r2, [r0, #24]
	callback_list = cb;
    a912:	6018      	str	r0, [r3, #0]
}
    a914:	4770      	bx	lr
    a916:	bf00      	nop
    a918:	200003a4 	.word	0x200003a4

0000a91c <bt_conn_recv>:
{
    a91c:	b570      	push	{r4, r5, r6, lr}
    a91e:	4616      	mov	r6, r2
    a920:	4604      	mov	r4, r0
    a922:	460d      	mov	r5, r1
	tx_notify(conn);
    a924:	f017 fe88 	bl	22638 <tx_notify>
	switch (flags) {
    a928:	2e01      	cmp	r6, #1
    a92a:	d020      	beq.n	a96e <bt_conn_recv+0x52>
    a92c:	2e02      	cmp	r6, #2
    a92e:	f040 8081 	bne.w	aa34 <bt_conn_recv+0x118>
		len = sys_le16_to_cpu(hdr->len);
    a932:	68ab      	ldr	r3, [r5, #8]
    a934:	881e      	ldrh	r6, [r3, #0]
		if (conn->rx_len) {
    a936:	89e3      	ldrh	r3, [r4, #14]
    a938:	b183      	cbz	r3, a95c <bt_conn_recv+0x40>
			BT_ERR("Unexpected first L2CAP frame");
    a93a:	2301      	movs	r3, #1
    a93c:	f04f 0100 	mov.w	r1, #0
    a940:	f363 0107 	bfi	r1, r3, #0, #8
    a944:	4a46      	ldr	r2, [pc, #280]	; (aa60 <bt_conn_recv+0x144>)
    a946:	4b47      	ldr	r3, [pc, #284]	; (aa64 <bt_conn_recv+0x148>)
    a948:	4847      	ldr	r0, [pc, #284]	; (aa68 <bt_conn_recv+0x14c>)
    a94a:	1a9b      	subs	r3, r3, r2
    a94c:	08db      	lsrs	r3, r3, #3
    a94e:	f363 118f 	bfi	r1, r3, #6, #10
    a952:	f016 fb72 	bl	2103a <log_0>
			bt_conn_reset_rx_state(conn);
    a956:	4620      	mov	r0, r4
    a958:	f017 fe49 	bl	225ee <bt_conn_reset_rx_state>
		conn->rx_len = (sizeof(*hdr) + len) - buf->len;
    a95c:	89ab      	ldrh	r3, [r5, #12]
    a95e:	1af3      	subs	r3, r6, r3
    a960:	3304      	adds	r3, #4
    a962:	b29b      	uxth	r3, r3
    a964:	81e3      	strh	r3, [r4, #14]
		if (conn->rx_len) {
    a966:	2b00      	cmp	r3, #0
    a968:	d04f      	beq.n	aa0a <bt_conn_recv+0xee>
			conn->rx = buf;
    a96a:	6125      	str	r5, [r4, #16]
}
    a96c:	bd70      	pop	{r4, r5, r6, pc}
		if (!conn->rx_len) {
    a96e:	89e3      	ldrh	r3, [r4, #14]
    a970:	b9ab      	cbnz	r3, a99e <bt_conn_recv+0x82>
			BT_ERR("Unexpected L2CAP continuation");
    a972:	2301      	movs	r3, #1
    a974:	f04f 0100 	mov.w	r1, #0
    a978:	f363 0107 	bfi	r1, r3, #0, #8
    a97c:	4a38      	ldr	r2, [pc, #224]	; (aa60 <bt_conn_recv+0x144>)
    a97e:	4b39      	ldr	r3, [pc, #228]	; (aa64 <bt_conn_recv+0x148>)
    a980:	483a      	ldr	r0, [pc, #232]	; (aa6c <bt_conn_recv+0x150>)
    a982:	1a9b      	subs	r3, r3, r2
    a984:	08db      	lsrs	r3, r3, #3
    a986:	f363 118f 	bfi	r1, r3, #6, #10
			BT_ERR("L2CAP data overflow");
    a98a:	f016 fb56 	bl	2103a <log_0>
			bt_conn_reset_rx_state(conn);
    a98e:	4620      	mov	r0, r4
    a990:	f017 fe2d 	bl	225ee <bt_conn_reset_rx_state>
			net_buf_unref(buf);
    a994:	4628      	mov	r0, r5
}
    a996:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			net_buf_unref(buf);
    a99a:	f00e bb5f 	b.w	1905c <net_buf_unref>
		if (buf->len > conn->rx_len) {
    a99e:	89ae      	ldrh	r6, [r5, #12]
    a9a0:	42b3      	cmp	r3, r6
    a9a2:	d20c      	bcs.n	a9be <bt_conn_recv+0xa2>
			BT_ERR("L2CAP data overflow");
    a9a4:	2301      	movs	r3, #1
    a9a6:	f04f 0100 	mov.w	r1, #0
    a9aa:	f363 0107 	bfi	r1, r3, #0, #8
    a9ae:	4a2c      	ldr	r2, [pc, #176]	; (aa60 <bt_conn_recv+0x144>)
    a9b0:	4b2c      	ldr	r3, [pc, #176]	; (aa64 <bt_conn_recv+0x148>)
    a9b2:	482f      	ldr	r0, [pc, #188]	; (aa70 <bt_conn_recv+0x154>)
    a9b4:	1a9b      	subs	r3, r3, r2
    a9b6:	08db      	lsrs	r3, r3, #3
    a9b8:	f363 118f 	bfi	r1, r3, #6, #10
    a9bc:	e7e5      	b.n	a98a <bt_conn_recv+0x6e>
		if (buf->len > net_buf_tailroom(conn->rx)) {
    a9be:	6920      	ldr	r0, [r4, #16]
    a9c0:	3008      	adds	r0, #8
    a9c2:	f01a fa4f 	bl	24e64 <net_buf_simple_tailroom>
    a9c6:	4286      	cmp	r6, r0
    a9c8:	d90c      	bls.n	a9e4 <bt_conn_recv+0xc8>
			BT_ERR("Not enough buffer space for L2CAP data");
    a9ca:	2301      	movs	r3, #1
    a9cc:	f04f 0100 	mov.w	r1, #0
    a9d0:	f363 0107 	bfi	r1, r3, #0, #8
    a9d4:	4a22      	ldr	r2, [pc, #136]	; (aa60 <bt_conn_recv+0x144>)
    a9d6:	4b23      	ldr	r3, [pc, #140]	; (aa64 <bt_conn_recv+0x148>)
    a9d8:	4826      	ldr	r0, [pc, #152]	; (aa74 <bt_conn_recv+0x158>)
    a9da:	1a9b      	subs	r3, r3, r2
    a9dc:	08db      	lsrs	r3, r3, #3
    a9de:	f363 118f 	bfi	r1, r3, #6, #10
    a9e2:	e7d2      	b.n	a98a <bt_conn_recv+0x6e>
		net_buf_add_mem(conn->rx, buf->data, buf->len);
    a9e4:	6920      	ldr	r0, [r4, #16]
    a9e6:	89aa      	ldrh	r2, [r5, #12]
    a9e8:	68a9      	ldr	r1, [r5, #8]
    a9ea:	3008      	adds	r0, #8
    a9ec:	f01a f9fa 	bl	24de4 <net_buf_simple_add_mem>
		conn->rx_len -= buf->len;
    a9f0:	89e3      	ldrh	r3, [r4, #14]
    a9f2:	89aa      	ldrh	r2, [r5, #12]
    a9f4:	1a9b      	subs	r3, r3, r2
    a9f6:	81e3      	strh	r3, [r4, #14]
		net_buf_unref(buf);
    a9f8:	4628      	mov	r0, r5
    a9fa:	f00e fb2f 	bl	1905c <net_buf_unref>
		if (conn->rx_len) {
    a9fe:	89e3      	ldrh	r3, [r4, #14]
    aa00:	2b00      	cmp	r3, #0
    aa02:	d1b3      	bne.n	a96c <bt_conn_recv+0x50>
		buf = conn->rx;
    aa04:	6925      	ldr	r5, [r4, #16]
		conn->rx_len = 0U;
    aa06:	81e3      	strh	r3, [r4, #14]
		conn->rx = NULL;
    aa08:	6123      	str	r3, [r4, #16]
	len = sys_le16_to_cpu(hdr->len);
    aa0a:	68ab      	ldr	r3, [r5, #8]
	if (sizeof(*hdr) + len != buf->len) {
    aa0c:	89aa      	ldrh	r2, [r5, #12]
    aa0e:	8819      	ldrh	r1, [r3, #0]
    aa10:	1d0b      	adds	r3, r1, #4
    aa12:	4293      	cmp	r3, r2
    aa14:	d01e      	beq.n	aa54 <bt_conn_recv+0x138>
		BT_ERR("ACL len mismatch (%u != %u)", len, buf->len);
    aa16:	2001      	movs	r0, #1
    aa18:	f04f 0300 	mov.w	r3, #0
    aa1c:	f360 0307 	bfi	r3, r0, #0, #8
    aa20:	4c0f      	ldr	r4, [pc, #60]	; (aa60 <bt_conn_recv+0x144>)
    aa22:	4810      	ldr	r0, [pc, #64]	; (aa64 <bt_conn_recv+0x148>)
    aa24:	1b00      	subs	r0, r0, r4
    aa26:	08c0      	lsrs	r0, r0, #3
    aa28:	f360 138f 	bfi	r3, r0, #6, #10
    aa2c:	4812      	ldr	r0, [pc, #72]	; (aa78 <bt_conn_recv+0x15c>)
    aa2e:	f016 fb25 	bl	2107c <log_2>
		net_buf_unref(buf);
    aa32:	e7af      	b.n	a994 <bt_conn_recv+0x78>
		BT_ERR("Unexpected ACL flags (0x%02x)", flags);
    aa34:	2301      	movs	r3, #1
    aa36:	f04f 0200 	mov.w	r2, #0
    aa3a:	f363 0207 	bfi	r2, r3, #0, #8
    aa3e:	4908      	ldr	r1, [pc, #32]	; (aa60 <bt_conn_recv+0x144>)
    aa40:	4b08      	ldr	r3, [pc, #32]	; (aa64 <bt_conn_recv+0x148>)
    aa42:	480e      	ldr	r0, [pc, #56]	; (aa7c <bt_conn_recv+0x160>)
    aa44:	1a5b      	subs	r3, r3, r1
    aa46:	08db      	lsrs	r3, r3, #3
    aa48:	f363 128f 	bfi	r2, r3, #6, #10
    aa4c:	4631      	mov	r1, r6
    aa4e:	f016 fb01 	bl	21054 <log_1>
		bt_conn_reset_rx_state(conn);
    aa52:	e79c      	b.n	a98e <bt_conn_recv+0x72>
	bt_l2cap_recv(conn, buf);
    aa54:	4629      	mov	r1, r5
    aa56:	4620      	mov	r0, r4
}
    aa58:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_l2cap_recv(conn, buf);
    aa5c:	f000 bd28 	b.w	b4b0 <bt_l2cap_recv>
    aa60:	00028540 	.word	0x00028540
    aa64:	00028558 	.word	0x00028558
    aa68:	00063567 	.word	0x00063567
    aa6c:	00063584 	.word	0x00063584
    aa70:	000635a2 	.word	0x000635a2
    aa74:	000635b6 	.word	0x000635b6
    aa78:	000635fb 	.word	0x000635fb
    aa7c:	000635dd 	.word	0x000635dd

0000aa80 <bt_conn_send_cb>:
{
    aa80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    aa84:	4698      	mov	r8, r3
	if (conn->state != BT_CONN_CONNECTED) {
    aa86:	7b43      	ldrb	r3, [r0, #13]
    aa88:	2b06      	cmp	r3, #6
{
    aa8a:	4606      	mov	r6, r0
    aa8c:	460d      	mov	r5, r1
    aa8e:	4617      	mov	r7, r2
	if (conn->state != BT_CONN_CONNECTED) {
    aa90:	d013      	beq.n	aaba <bt_conn_send_cb+0x3a>
		BT_ERR("not connected!");
    aa92:	2301      	movs	r3, #1
    aa94:	f04f 0100 	mov.w	r1, #0
    aa98:	f363 0107 	bfi	r1, r3, #0, #8
    aa9c:	4a2c      	ldr	r2, [pc, #176]	; (ab50 <bt_conn_send_cb+0xd0>)
    aa9e:	4b2d      	ldr	r3, [pc, #180]	; (ab54 <bt_conn_send_cb+0xd4>)
    aaa0:	482d      	ldr	r0, [pc, #180]	; (ab58 <bt_conn_send_cb+0xd8>)
    aaa2:	1a9b      	subs	r3, r3, r2
    aaa4:	08db      	lsrs	r3, r3, #3
    aaa6:	f363 118f 	bfi	r1, r3, #6, #10
    aaaa:	f016 fac6 	bl	2103a <log_0>
		net_buf_unref(buf);
    aaae:	4628      	mov	r0, r5
    aab0:	f00e fad4 	bl	1905c <net_buf_unref>
			return -ENOTCONN;
    aab4:	f06f 007f 	mvn.w	r0, #127	; 0x7f
    aab8:	e021      	b.n	aafe <bt_conn_send_cb+0x7e>
	if (cb) {
    aaba:	2a00      	cmp	r2, #0
    aabc:	d045      	beq.n	ab4a <bt_conn_send_cb+0xca>
	return z_impl_k_current_get();
    aabe:	f014 f957 	bl	1ed70 <z_impl_k_current_get>
	if (k_current_get() == &k_sys_work_q.thread) {
    aac2:	4b26      	ldr	r3, [pc, #152]	; (ab5c <bt_conn_send_cb+0xdc>)
    aac4:	4283      	cmp	r3, r0
	return z_impl_k_queue_get(queue, timeout);
    aac6:	4826      	ldr	r0, [pc, #152]	; (ab60 <bt_conn_send_cb+0xe0>)
    aac8:	bf0c      	ite	eq
    aaca:	2100      	moveq	r1, #0
    aacc:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
    aad0:	f01d f842 	bl	27b58 <z_impl_k_queue_get>
    aad4:	4604      	mov	r4, r0
		if (!tx) {
    aad6:	b9a0      	cbnz	r0, ab02 <bt_conn_send_cb+0x82>
			BT_ERR("Unable to allocate TX context");
    aad8:	2301      	movs	r3, #1
    aada:	f04f 0100 	mov.w	r1, #0
    aade:	4a1c      	ldr	r2, [pc, #112]	; (ab50 <bt_conn_send_cb+0xd0>)
    aae0:	4820      	ldr	r0, [pc, #128]	; (ab64 <bt_conn_send_cb+0xe4>)
    aae2:	f363 0107 	bfi	r1, r3, #0, #8
    aae6:	4b1b      	ldr	r3, [pc, #108]	; (ab54 <bt_conn_send_cb+0xd4>)
    aae8:	1a9b      	subs	r3, r3, r2
    aaea:	08db      	lsrs	r3, r3, #3
    aaec:	f363 118f 	bfi	r1, r3, #6, #10
    aaf0:	f016 faa3 	bl	2103a <log_0>
			net_buf_unref(buf);
    aaf4:	4628      	mov	r0, r5
    aaf6:	f00e fab1 	bl	1905c <net_buf_unref>
			return -ENOBUFS;
    aafa:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
    aafe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (conn->state != BT_CONN_CONNECTED) {
    ab02:	7b73      	ldrb	r3, [r6, #13]
    ab04:	2b06      	cmp	r3, #6
    ab06:	d014      	beq.n	ab32 <bt_conn_send_cb+0xb2>
			BT_WARN("Disconnected while allocating context");
    ab08:	2302      	movs	r3, #2
    ab0a:	f04f 0100 	mov.w	r1, #0
    ab0e:	4a10      	ldr	r2, [pc, #64]	; (ab50 <bt_conn_send_cb+0xd0>)
    ab10:	4815      	ldr	r0, [pc, #84]	; (ab68 <bt_conn_send_cb+0xe8>)
    ab12:	f363 0107 	bfi	r1, r3, #0, #8
    ab16:	4b0f      	ldr	r3, [pc, #60]	; (ab54 <bt_conn_send_cb+0xd4>)
    ab18:	1a9b      	subs	r3, r3, r2
    ab1a:	08db      	lsrs	r3, r3, #3
    ab1c:	f363 118f 	bfi	r1, r3, #6, #10
    ab20:	f016 fa8b 	bl	2103a <log_0>
			net_buf_unref(buf);
    ab24:	4628      	mov	r0, r5
    ab26:	f00e fa99 	bl	1905c <net_buf_unref>
			tx_free(tx);
    ab2a:	4620      	mov	r0, r4
    ab2c:	f7ff fd86 	bl	a63c <tx_free>
    ab30:	e7c0      	b.n	aab4 <bt_conn_send_cb+0x34>
		tx->pending_no_cb = 0U;
    ab32:	2300      	movs	r3, #0
		tx->user_data = user_data;
    ab34:	e9c0 7801 	strd	r7, r8, [r0, #4]
		tx->pending_no_cb = 0U;
    ab38:	60c3      	str	r3, [r0, #12]
		tx_data(buf)->tx = tx;
    ab3a:	6168      	str	r0, [r5, #20]
	net_buf_put(&conn->tx_queue, buf);
    ab3c:	f106 0034 	add.w	r0, r6, #52	; 0x34
    ab40:	4629      	mov	r1, r5
    ab42:	f01a f938 	bl	24db6 <net_buf_put>
	return 0;
    ab46:	2000      	movs	r0, #0
    ab48:	e7d9      	b.n	aafe <bt_conn_send_cb+0x7e>
		tx_data(buf)->tx = NULL;
    ab4a:	616a      	str	r2, [r5, #20]
    ab4c:	e7f6      	b.n	ab3c <bt_conn_send_cb+0xbc>
    ab4e:	bf00      	nop
    ab50:	00028540 	.word	0x00028540
    ab54:	00028558 	.word	0x00028558
    ab58:	00063617 	.word	0x00063617
    ab5c:	200060a4 	.word	0x200060a4
    ab60:	2000efe0 	.word	0x2000efe0
    ab64:	00063626 	.word	0x00063626
    ab68:	00063644 	.word	0x00063644

0000ab6c <bt_conn_prepare_events>:
{
	int i, ev_count = 0;

	BT_DBG("");

	conn_change.signaled = 0U;
    ab6c:	4b1a      	ldr	r3, [pc, #104]	; (abd8 <bt_conn_prepare_events+0x6c>)
{
    ab6e:	b510      	push	{r4, lr}
	conn_change.signaled = 0U;
    ab70:	2200      	movs	r2, #0
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
    ab72:	2101      	movs	r1, #1
	conn_change.signaled = 0U;
    ab74:	609a      	str	r2, [r3, #8]
{
    ab76:	4604      	mov	r4, r0
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
    ab78:	f014 fc22 	bl	1f3c0 <k_poll_event_init>
			  K_POLL_MODE_NOTIFY_ONLY, &conn_change);

	for (i = 0; i < ARRAY_SIZE(conns); i++) {
		struct bt_conn *conn = &conns[i];

		if (!atomic_get(&conn->ref)) {
    ab7c:	4b17      	ldr	r3, [pc, #92]	; (abdc <bt_conn_prepare_events+0x70>)
    ab7e:	f103 0050 	add.w	r0, r3, #80	; 0x50
    ab82:	f017 fd27 	bl	225d4 <atomic_get>
    ab86:	4619      	mov	r1, r3
    ab88:	b908      	cbnz	r0, ab8e <bt_conn_prepare_events+0x22>
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
    ab8a:	2001      	movs	r0, #1
				  &conn->tx_queue);
		events[ev_count++].tag = BT_EVENT_CONN_TX_QUEUE;
	}

	return ev_count;
}
    ab8c:	bd10      	pop	{r4, pc}
		if (conn->state == BT_CONN_DISCONNECTED &&
    ab8e:	7b5a      	ldrb	r2, [r3, #13]
    ab90:	b99a      	cbnz	r2, abba <bt_conn_prepare_events+0x4e>
    ab92:	f3bf 8f5b 	dmb	ish
    ab96:	1d1a      	adds	r2, r3, #4
    ab98:	e852 0f00 	ldrex	r0, [r2]
    ab9c:	f020 0c40 	bic.w	ip, r0, #64	; 0x40
    aba0:	e842 ce00 	strex	lr, ip, [r2]
    aba4:	f1be 0f00 	cmp.w	lr, #0
    aba8:	d1f6      	bne.n	ab98 <bt_conn_prepare_events+0x2c>
    abaa:	f3bf 8f5b 	dmb	ish
    abae:	0642      	lsls	r2, r0, #25
    abb0:	d503      	bpl.n	abba <bt_conn_prepare_events+0x4e>
			conn_cleanup(conn);
    abb2:	4618      	mov	r0, r3
    abb4:	f7ff fdfc 	bl	a7b0 <conn_cleanup>
    abb8:	e7e7      	b.n	ab8a <bt_conn_prepare_events+0x1e>
		if (conn->state != BT_CONN_CONNECTED) {
    abba:	7b4b      	ldrb	r3, [r1, #13]
    abbc:	2b06      	cmp	r3, #6
    abbe:	d1e4      	bne.n	ab8a <bt_conn_prepare_events+0x1e>
		k_poll_event_init(&events[ev_count],
    abc0:	4b07      	ldr	r3, [pc, #28]	; (abe0 <bt_conn_prepare_events+0x74>)
    abc2:	f104 0014 	add.w	r0, r4, #20
    abc6:	2200      	movs	r2, #0
    abc8:	2104      	movs	r1, #4
    abca:	f014 fbf9 	bl	1f3c0 <k_poll_event_init>
		events[ev_count++].tag = BT_EVENT_CONN_TX_QUEUE;
    abce:	2301      	movs	r3, #1
    abd0:	f884 3020 	strb.w	r3, [r4, #32]
    abd4:	2002      	movs	r0, #2
	return ev_count;
    abd6:	e7d9      	b.n	ab8c <bt_conn_prepare_events+0x20>
    abd8:	2000e7d8 	.word	0x2000e7d8
    abdc:	200003d8 	.word	0x200003d8
    abe0:	2000040c 	.word	0x2000040c

0000abe4 <bt_conn_add_le>:
		net_buf_unref(buf);
	}
}

struct bt_conn *bt_conn_add_le(u8_t id, const bt_addr_le_t *peer)
{
    abe4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if (!atomic_get(&conns[i].ref)) {
    abe8:	4c1b      	ldr	r4, [pc, #108]	; (ac58 <bt_conn_add_le+0x74>)
    abea:	f104 0750 	add.w	r7, r4, #80	; 0x50
{
    abee:	4680      	mov	r8, r0
		if (!atomic_get(&conns[i].ref)) {
    abf0:	4638      	mov	r0, r7
{
    abf2:	460e      	mov	r6, r1
		if (!atomic_get(&conns[i].ref)) {
    abf4:	f017 fcee 	bl	225d4 <atomic_get>
    abf8:	4605      	mov	r5, r0
    abfa:	b110      	cbz	r0, ac02 <bt_conn_add_le+0x1e>
	struct bt_conn *conn = conn_new();

	if (!conn) {
		return NULL;
    abfc:	2000      	movs	r0, #0
	conn->type = BT_CONN_TYPE_LE;
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
	conn->le.interval_max = BT_GAP_INIT_CONN_INT_MAX;

	return conn;
}
    abfe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
__ssp_bos_icheck3(memset, void *, int)
    ac02:	4601      	mov	r1, r0
    ac04:	22a4      	movs	r2, #164	; 0xa4
    ac06:	4620      	mov	r0, r4
    ac08:	f7f7 f811 	bl	1c2e <memset>
	k_delayed_work_init(&conn->update_work, conn_update_timeout);
    ac0c:	4913      	ldr	r1, [pc, #76]	; (ac5c <bt_conn_add_le+0x78>)
    ac0e:	f104 0054 	add.w	r0, r4, #84	; 0x54
    ac12:	f01d f978 	bl	27f06 <k_delayed_work_init>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    ac16:	4b12      	ldr	r3, [pc, #72]	; (ac60 <bt_conn_add_le+0x7c>)
    ac18:	62a5      	str	r5, [r4, #40]	; 0x28
    ac1a:	e9c4 350b 	strd	r3, r5, [r4, #44]	; 0x2c
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    ac1e:	2301      	movs	r3, #1
    ac20:	f3bf 8f5b 	dmb	ish
    ac24:	e857 2f00 	ldrex	r2, [r7]
    ac28:	e847 3100 	strex	r1, r3, [r7]
    ac2c:	2900      	cmp	r1, #0
    ac2e:	d1f9      	bne.n	ac24 <bt_conn_add_le+0x40>
    ac30:	f3bf 8f5b 	dmb	ish
	conn->id = id;
    ac34:	f884 8008 	strb.w	r8, [r4, #8]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    ac38:	6830      	ldr	r0, [r6, #0]
    ac3a:	6760      	str	r0, [r4, #116]	; 0x74
    ac3c:	88b0      	ldrh	r0, [r6, #4]
    ac3e:	79b1      	ldrb	r1, [r6, #6]
	conn->type = BT_CONN_TYPE_LE;
    ac40:	70a3      	strb	r3, [r4, #2]
	conn->sec_level = BT_SECURITY_L1;
    ac42:	7263      	strb	r3, [r4, #9]
	conn->required_sec_level = BT_SECURITY_L1;
    ac44:	72a3      	strb	r3, [r4, #10]
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
    ac46:	4b07      	ldr	r3, [pc, #28]	; (ac64 <bt_conn_add_le+0x80>)
    ac48:	f8a4 0078 	strh.w	r0, [r4, #120]	; 0x78
    ac4c:	f884 107a 	strb.w	r1, [r4, #122]	; 0x7a
    ac50:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
			conn = &conns[i];
    ac54:	4620      	mov	r0, r4
	return conn;
    ac56:	e7d2      	b.n	abfe <bt_conn_add_le+0x1a>
    ac58:	200003d8 	.word	0x200003d8
    ac5c:	0000af3d 	.word	0x0000af3d
    ac60:	0002267f 	.word	0x0002267f
    ac64:	00280018 	.word	0x00280018

0000ac68 <bt_conn_set_state>:
		k_sem_give(bt_conn_get_pkts(conn));
	}
}

void bt_conn_set_state(struct bt_conn *conn, bt_conn_state_t state)
{
    ac68:	b570      	push	{r4, r5, r6, lr}
	bt_conn_state_t old_state;

	BT_DBG("%s -> %s", state2str(conn->state), state2str(state));

	if (conn->state == state) {
    ac6a:	7b45      	ldrb	r5, [r0, #13]
    ac6c:	428d      	cmp	r5, r1
{
    ac6e:	4604      	mov	r4, r0
    ac70:	460e      	mov	r6, r1
	if (conn->state == state) {
    ac72:	d10f      	bne.n	ac94 <bt_conn_set_state+0x2c>
		BT_WARN("no transition");
    ac74:	2302      	movs	r3, #2
    ac76:	f04f 0100 	mov.w	r1, #0
    ac7a:	f363 0107 	bfi	r1, r3, #0, #8
    ac7e:	4a59      	ldr	r2, [pc, #356]	; (ade4 <bt_conn_set_state+0x17c>)
    ac80:	4b59      	ldr	r3, [pc, #356]	; (ade8 <bt_conn_set_state+0x180>)
    ac82:	485a      	ldr	r0, [pc, #360]	; (adec <bt_conn_set_state+0x184>)
    ac84:	1a9b      	subs	r3, r3, r2
    ac86:	08db      	lsrs	r3, r3, #3
    ac88:	f363 118f 	bfi	r1, r3, #6, #10
	default:
		BT_WARN("no valid (%u) state was set", state);

		break;
	}
}
    ac8c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_WARN("no transition");
    ac90:	f016 b9d3 	b.w	2103a <log_0>
	conn->state = state;
    ac94:	7361      	strb	r1, [r4, #13]
	switch (old_state) {
    ac96:	b915      	cbnz	r5, ac9e <bt_conn_set_state+0x36>
#endif /* defined(CONFIG_BT_BREDR) */
}

struct bt_conn *bt_conn_ref(struct bt_conn *conn)
{
	atomic_inc(&conn->ref);
    ac98:	3050      	adds	r0, #80	; 0x50
    ac9a:	f017 fcc0 	bl	2261e <atomic_inc>
	switch (conn->state) {
    ac9e:	7b63      	ldrb	r3, [r4, #13]
    aca0:	2b07      	cmp	r3, #7
    aca2:	f200 808d 	bhi.w	adc0 <bt_conn_set_state+0x158>
    aca6:	e8df f003 	tbb	[pc, r3]
    acaa:	8a1b      	.short	0x8a1b
    acac:	8a8a8a8a 	.word	0x8a8a8a8a
    acb0:	8a04      	.short	0x8a04
		if (conn->type == BT_CONN_TYPE_SCO) {
    acb2:	78a3      	ldrb	r3, [r4, #2]
    acb4:	2b04      	cmp	r3, #4
    acb6:	f000 8082 	beq.w	adbe <bt_conn_set_state+0x156>
	z_impl_k_queue_init(queue);
    acba:	f104 0034 	add.w	r0, r4, #52	; 0x34
    acbe:	f01c ff19 	bl	27af4 <z_impl_k_queue_init>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&signal, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(signal, result);
    acc2:	2100      	movs	r1, #0
    acc4:	484a      	ldr	r0, [pc, #296]	; (adf0 <bt_conn_set_state+0x188>)
    acc6:	f014 fbe3 	bl	1f490 <z_impl_k_poll_signal_raise>
	list->head = NULL;
    acca:	2300      	movs	r3, #0
		bt_l2cap_connected(conn);
    accc:	4620      	mov	r0, r4
	list->tail = NULL;
    acce:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
    acd2:	f000 fb1b 	bl	b30c <bt_l2cap_connected>
		notify_connected(conn);
    acd6:	4620      	mov	r0, r4
}
    acd8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		notify_connected(conn);
    acdc:	f7ff bcb8 	b.w	a650 <notify_connected>
		if (conn->type == BT_CONN_TYPE_SCO) {
    ace0:	78a3      	ldrb	r3, [r4, #2]
    ace2:	2b04      	cmp	r3, #4
    ace4:	d105      	bne.n	acf2 <bt_conn_set_state+0x8a>
	return conn;
}

void bt_conn_unref(struct bt_conn *conn)
{
	atomic_dec(&conn->ref);
    ace6:	f104 0050 	add.w	r0, r4, #80	; 0x50
}
    acea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	atomic_dec(&conn->ref);
    acee:	f017 bc89 	b.w	22604 <atomic_dec>
		if (old_state == BT_CONN_CONNECTED ||
    acf2:	1fab      	subs	r3, r5, #6
    acf4:	2b01      	cmp	r3, #1
    acf6:	d851      	bhi.n	ad9c <bt_conn_set_state+0x134>
	z_impl_k_sem_give(sem);
    acf8:	4d3e      	ldr	r5, [pc, #248]	; (adf4 <bt_conn_set_state+0x18c>)
		tx->pending_no_cb = 0U;
    acfa:	2600      	movs	r6, #0
	__asm__ volatile(
    acfc:	f04f 0320 	mov.w	r3, #32
    ad00:	f3ef 8211 	mrs	r2, BASEPRI
    ad04:	f383 8811 	msr	BASEPRI, r3
    ad08:	f3bf 8f6f 	isb	sy
		if (conn->pending_no_cb) {
    ad0c:	69e3      	ldr	r3, [r4, #28]
    ad0e:	b14b      	cbz	r3, ad24 <bt_conn_set_state+0xbc>
			conn->pending_no_cb--;
    ad10:	3b01      	subs	r3, #1
    ad12:	61e3      	str	r3, [r4, #28]
	__asm__ volatile(
    ad14:	f382 8811 	msr	BASEPRI, r2
    ad18:	f3bf 8f6f 	isb	sy
    ad1c:	4628      	mov	r0, r5
    ad1e:	f014 f82d 	bl	1ed7c <z_impl_k_sem_give>
    ad22:	e7eb      	b.n	acfc <bt_conn_set_state+0x94>
Z_GENLIST_IS_EMPTY(slist)
    ad24:	6960      	ldr	r0, [r4, #20]
Z_GENLIST_GET(slist, snode)
    ad26:	b128      	cbz	r0, ad34 <bt_conn_set_state+0xcc>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    ad28:	69a1      	ldr	r1, [r4, #24]
    ad2a:	6803      	ldr	r3, [r0, #0]
	list->head = node;
    ad2c:	6163      	str	r3, [r4, #20]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    ad2e:	4288      	cmp	r0, r1
	list->tail = node;
    ad30:	bf08      	it	eq
    ad32:	61a3      	streq	r3, [r4, #24]
    ad34:	f382 8811 	msr	BASEPRI, r2
    ad38:	f3bf 8f6f 	isb	sy
		if (!node) {
    ad3c:	b188      	cbz	r0, ad62 <bt_conn_set_state+0xfa>
	__asm__ volatile(
    ad3e:	f04f 0220 	mov.w	r2, #32
    ad42:	f3ef 8311 	mrs	r3, BASEPRI
    ad46:	f382 8811 	msr	BASEPRI, r2
    ad4a:	f3bf 8f6f 	isb	sy
		conn->pending_no_cb = tx->pending_no_cb;
    ad4e:	68c2      	ldr	r2, [r0, #12]
    ad50:	61e2      	str	r2, [r4, #28]
		tx->pending_no_cb = 0U;
    ad52:	60c6      	str	r6, [r0, #12]
	__asm__ volatile(
    ad54:	f383 8811 	msr	BASEPRI, r3
    ad58:	f3bf 8f6f 	isb	sy
		tx_free(tx);
    ad5c:	f7ff fc6e 	bl	a63c <tx_free>
    ad60:	e7dc      	b.n	ad1c <bt_conn_set_state+0xb4>
			tx_notify(conn);
    ad62:	4620      	mov	r0, r4
    ad64:	f017 fc68 	bl	22638 <tx_notify>
			if (conn->type == BT_CONN_TYPE_LE) {
    ad68:	78a3      	ldrb	r3, [r4, #2]
    ad6a:	2b01      	cmp	r3, #1
    ad6c:	d103      	bne.n	ad76 <bt_conn_set_state+0x10e>
				k_delayed_work_cancel(&conn->update_work);
    ad6e:	f104 0054 	add.w	r0, r4, #84	; 0x54
    ad72:	f01d f8d0 	bl	27f16 <k_delayed_work_cancel>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    ad76:	f3bf 8f5b 	dmb	ish
    ad7a:	3404      	adds	r4, #4
    ad7c:	e854 3f00 	ldrex	r3, [r4]
    ad80:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    ad84:	e844 3200 	strex	r2, r3, [r4]
    ad88:	2a00      	cmp	r2, #0
    ad8a:	d1f7      	bne.n	ad7c <bt_conn_set_state+0x114>
    ad8c:	f3bf 8f5b 	dmb	ish
	return z_impl_k_poll_signal_raise(signal, result);
    ad90:	2100      	movs	r1, #0
    ad92:	4817      	ldr	r0, [pc, #92]	; (adf0 <bt_conn_set_state+0x188>)
}
    ad94:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    ad98:	f014 bb7a 	b.w	1f490 <z_impl_k_poll_signal_raise>
		} else if (old_state == BT_CONN_CONNECT) {
    ad9c:	2d05      	cmp	r5, #5
    ad9e:	d103      	bne.n	ada8 <bt_conn_set_state+0x140>
			notify_connected(conn);
    ada0:	4620      	mov	r0, r4
    ada2:	f7ff fc55 	bl	a650 <notify_connected>
    ada6:	e79e      	b.n	ace6 <bt_conn_set_state+0x7e>
		} else if (old_state == BT_CONN_CONNECT_SCAN) {
    ada8:	2d01      	cmp	r5, #1
    adaa:	d103      	bne.n	adb4 <bt_conn_set_state+0x14c>
			if (conn->err) {
    adac:	7b23      	ldrb	r3, [r4, #12]
    adae:	2b00      	cmp	r3, #0
    adb0:	d099      	beq.n	ace6 <bt_conn_set_state+0x7e>
    adb2:	e7f5      	b.n	ada0 <bt_conn_set_state+0x138>
		} else if (old_state == BT_CONN_CONNECT_DIR_ADV) {
    adb4:	2d04      	cmp	r5, #4
    adb6:	d0f9      	beq.n	adac <bt_conn_set_state+0x144>
		} else if (old_state == BT_CONN_CONNECT_AUTO) {
    adb8:	3d02      	subs	r5, #2
    adba:	2d01      	cmp	r5, #1
    adbc:	d993      	bls.n	ace6 <bt_conn_set_state+0x7e>
}
    adbe:	bd70      	pop	{r4, r5, r6, pc}
		BT_WARN("no valid (%u) state was set", state);
    adc0:	2302      	movs	r3, #2
    adc2:	f04f 0200 	mov.w	r2, #0
    adc6:	f363 0207 	bfi	r2, r3, #0, #8
    adca:	4906      	ldr	r1, [pc, #24]	; (ade4 <bt_conn_set_state+0x17c>)
    adcc:	4b06      	ldr	r3, [pc, #24]	; (ade8 <bt_conn_set_state+0x180>)
    adce:	480a      	ldr	r0, [pc, #40]	; (adf8 <bt_conn_set_state+0x190>)
    add0:	1a5b      	subs	r3, r3, r1
    add2:	08db      	lsrs	r3, r3, #3
    add4:	4631      	mov	r1, r6
    add6:	f363 128f 	bfi	r2, r3, #6, #10
}
    adda:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_WARN("no valid (%u) state was set", state);
    adde:	f016 b939 	b.w	21054 <log_1>
    ade2:	bf00      	nop
    ade4:	00028540 	.word	0x00028540
    ade8:	00028558 	.word	0x00028558
    adec:	0006366a 	.word	0x0006366a
    adf0:	2000e7d8 	.word	0x2000e7d8
    adf4:	2000e564 	.word	0x2000e564
    adf8:	00063678 	.word	0x00063678

0000adfc <bt_conn_lookup_handle>:
{
    adfc:	b510      	push	{r4, lr}
		if (!atomic_get(&conns[i].ref)) {
    adfe:	4c0b      	ldr	r4, [pc, #44]	; (ae2c <bt_conn_lookup_handle+0x30>)
{
    ae00:	4602      	mov	r2, r0
		if (!atomic_get(&conns[i].ref)) {
    ae02:	f104 0050 	add.w	r0, r4, #80	; 0x50
    ae06:	f017 fbe5 	bl	225d4 <atomic_get>
    ae0a:	b158      	cbz	r0, ae24 <bt_conn_lookup_handle+0x28>
		if (conns[i].state != BT_CONN_CONNECTED &&
    ae0c:	7b63      	ldrb	r3, [r4, #13]
    ae0e:	3b06      	subs	r3, #6
    ae10:	2b01      	cmp	r3, #1
    ae12:	d808      	bhi.n	ae26 <bt_conn_lookup_handle+0x2a>
		if (conns[i].handle == handle) {
    ae14:	8823      	ldrh	r3, [r4, #0]
    ae16:	4293      	cmp	r3, r2
    ae18:	d105      	bne.n	ae26 <bt_conn_lookup_handle+0x2a>
	atomic_inc(&conn->ref);
    ae1a:	f104 0050 	add.w	r0, r4, #80	; 0x50
    ae1e:	f017 fbfe 	bl	2261e <atomic_inc>
			return bt_conn_ref(&conns[i]);
    ae22:	4620      	mov	r0, r4
}
    ae24:	bd10      	pop	{r4, pc}
	return NULL;
    ae26:	2000      	movs	r0, #0
    ae28:	e7fc      	b.n	ae24 <bt_conn_lookup_handle+0x28>
    ae2a:	bf00      	nop
    ae2c:	200003d8 	.word	0x200003d8

0000ae30 <bt_conn_lookup_addr_le>:
{
    ae30:	b510      	push	{r4, lr}
		if (!atomic_get(&conns[i].ref)) {
    ae32:	4c0d      	ldr	r4, [pc, #52]	; (ae68 <bt_conn_lookup_addr_le+0x38>)
{
    ae34:	4603      	mov	r3, r0
		if (!atomic_get(&conns[i].ref)) {
    ae36:	f104 0050 	add.w	r0, r4, #80	; 0x50
    ae3a:	f017 fbcb 	bl	225d4 <atomic_get>
    ae3e:	b908      	cbnz	r0, ae44 <bt_conn_lookup_addr_le+0x14>
	return NULL;
    ae40:	2000      	movs	r0, #0
}
    ae42:	bd10      	pop	{r4, pc}
		if (conns[i].type != BT_CONN_TYPE_LE) {
    ae44:	78a2      	ldrb	r2, [r4, #2]
    ae46:	2a01      	cmp	r2, #1
    ae48:	d1fa      	bne.n	ae40 <bt_conn_lookup_addr_le+0x10>
		if (conns[i].id == id &&
    ae4a:	7a22      	ldrb	r2, [r4, #8]
    ae4c:	429a      	cmp	r2, r3
    ae4e:	d1f7      	bne.n	ae40 <bt_conn_lookup_addr_le+0x10>
		    !bt_conn_addr_le_cmp(&conns[i], peer)) {
    ae50:	4620      	mov	r0, r4
    ae52:	f017 fc4c 	bl	226ee <bt_conn_addr_le_cmp>
		if (conns[i].id == id &&
    ae56:	2800      	cmp	r0, #0
    ae58:	d1f2      	bne.n	ae40 <bt_conn_lookup_addr_le+0x10>
	atomic_inc(&conn->ref);
    ae5a:	f104 0050 	add.w	r0, r4, #80	; 0x50
    ae5e:	f017 fbde 	bl	2261e <atomic_inc>
		    !bt_conn_addr_le_cmp(&conns[i], peer)) {
    ae62:	4620      	mov	r0, r4
			return bt_conn_ref(&conns[i]);
    ae64:	e7ed      	b.n	ae42 <bt_conn_lookup_addr_le+0x12>
    ae66:	bf00      	nop
    ae68:	200003d8 	.word	0x200003d8

0000ae6c <bt_conn_lookup_state_le>:
{
    ae6c:	b538      	push	{r3, r4, r5, lr}
		if (!atomic_get(&conns[i].ref)) {
    ae6e:	4c0e      	ldr	r4, [pc, #56]	; (aea8 <bt_conn_lookup_state_le+0x3c>)
{
    ae70:	4603      	mov	r3, r0
		if (!atomic_get(&conns[i].ref)) {
    ae72:	f104 0050 	add.w	r0, r4, #80	; 0x50
{
    ae76:	460d      	mov	r5, r1
		if (!atomic_get(&conns[i].ref)) {
    ae78:	f017 fbac 	bl	225d4 <atomic_get>
    ae7c:	b908      	cbnz	r0, ae82 <bt_conn_lookup_state_le+0x16>
	return NULL;
    ae7e:	2000      	movs	r0, #0
}
    ae80:	bd38      	pop	{r3, r4, r5, pc}
		if (conns[i].type != BT_CONN_TYPE_LE) {
    ae82:	78a2      	ldrb	r2, [r4, #2]
    ae84:	2a01      	cmp	r2, #1
    ae86:	d1fa      	bne.n	ae7e <bt_conn_lookup_state_le+0x12>
		if (peer && bt_conn_addr_le_cmp(&conns[i], peer)) {
    ae88:	b93b      	cbnz	r3, ae9a <bt_conn_lookup_state_le+0x2e>
		if (conns[i].state == state) {
    ae8a:	7b63      	ldrb	r3, [r4, #13]
    ae8c:	42ab      	cmp	r3, r5
    ae8e:	d1f6      	bne.n	ae7e <bt_conn_lookup_state_le+0x12>
	atomic_inc(&conn->ref);
    ae90:	4806      	ldr	r0, [pc, #24]	; (aeac <bt_conn_lookup_state_le+0x40>)
    ae92:	f017 fbc4 	bl	2261e <atomic_inc>
			return bt_conn_ref(&conns[i]);
    ae96:	4804      	ldr	r0, [pc, #16]	; (aea8 <bt_conn_lookup_state_le+0x3c>)
    ae98:	e7f2      	b.n	ae80 <bt_conn_lookup_state_le+0x14>
		if (peer && bt_conn_addr_le_cmp(&conns[i], peer)) {
    ae9a:	4619      	mov	r1, r3
    ae9c:	4620      	mov	r0, r4
    ae9e:	f017 fc26 	bl	226ee <bt_conn_addr_le_cmp>
    aea2:	2800      	cmp	r0, #0
    aea4:	d0f1      	beq.n	ae8a <bt_conn_lookup_state_le+0x1e>
    aea6:	e7ea      	b.n	ae7e <bt_conn_lookup_state_le+0x12>
    aea8:	200003d8 	.word	0x200003d8
    aeac:	20000428 	.word	0x20000428

0000aeb0 <bt_conn_foreach>:
		if (!atomic_get(&conns[i].ref)) {
    aeb0:	4b09      	ldr	r3, [pc, #36]	; (aed8 <bt_conn_foreach+0x28>)
{
    aeb2:	b570      	push	{r4, r5, r6, lr}
    aeb4:	4605      	mov	r5, r0
		if (!atomic_get(&conns[i].ref)) {
    aeb6:	f103 0050 	add.w	r0, r3, #80	; 0x50
{
    aeba:	460c      	mov	r4, r1
		if (!atomic_get(&conns[i].ref)) {
    aebc:	f017 fb8a 	bl	225d4 <atomic_get>
    aec0:	b140      	cbz	r0, aed4 <bt_conn_foreach+0x24>
		if (!(conns[i].type & type)) {
    aec2:	7899      	ldrb	r1, [r3, #2]
    aec4:	4229      	tst	r1, r5
    aec6:	d005      	beq.n	aed4 <bt_conn_foreach+0x24>
		func(&conns[i], data);
    aec8:	4618      	mov	r0, r3
    aeca:	4611      	mov	r1, r2
    aecc:	4623      	mov	r3, r4
}
    aece:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		func(&conns[i], data);
    aed2:	4718      	bx	r3
}
    aed4:	bd70      	pop	{r4, r5, r6, pc}
    aed6:	bf00      	nop
    aed8:	200003d8 	.word	0x200003d8

0000aedc <send_conn_le_param_update>:
{
    aedc:	b538      	push	{r3, r4, r5, lr}
    aede:	4604      	mov	r4, r0
	if (!bt_le_conn_params_valid(param)) {
    aee0:	4608      	mov	r0, r1
{
    aee2:	460d      	mov	r5, r1
	if (!bt_le_conn_params_valid(param)) {
    aee4:	f017 fb1b 	bl	2251e <bt_le_conn_params_valid>
    aee8:	b310      	cbz	r0, af30 <send_conn_le_param_update+0x54>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
    aeea:	4b13      	ldr	r3, [pc, #76]	; (af38 <send_conn_le_param_update+0x5c>)
    aeec:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
    aef0:	079a      	lsls	r2, r3, #30
    aef2:	d407      	bmi.n	af04 <send_conn_le_param_update+0x28>
	     !atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_L2CAP)) ||
    aef4:	78e3      	ldrb	r3, [r4, #3]
    aef6:	b17b      	cbz	r3, af18 <send_conn_le_param_update+0x3c>
	return bt_l2cap_update_conn_param(conn, param);
    aef8:	4629      	mov	r1, r5
    aefa:	4620      	mov	r0, r4
}
    aefc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return bt_l2cap_update_conn_param(conn, param);
    af00:	f000 bb18 	b.w	b534 <bt_l2cap_update_conn_param>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
    af04:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
    af08:	079b      	lsls	r3, r3, #30
    af0a:	d5f3      	bpl.n	aef4 <send_conn_le_param_update+0x18>
	     !atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_L2CAP)) ||
    af0c:	210a      	movs	r1, #10
    af0e:	1d20      	adds	r0, r4, #4
    af10:	f017 fb66 	bl	225e0 <atomic_test_bit>
	     BT_FEAT_LE_CONN_PARAM_REQ_PROC(conn->le.features) &&
    af14:	2800      	cmp	r0, #0
    af16:	d1ed      	bne.n	aef4 <send_conn_le_param_update+0x18>
		rc = bt_conn_le_conn_update(conn, param);
    af18:	4629      	mov	r1, r5
    af1a:	4620      	mov	r0, r4
    af1c:	f017 fc41 	bl	227a2 <bt_conn_le_conn_update>
		if (rc == 0) {
    af20:	b928      	cbnz	r0, af2e <send_conn_le_param_update+0x52>
			conn->le.pending_latency = param->latency;
    af22:	88ab      	ldrh	r3, [r5, #4]
    af24:	f8a4 3094 	strh.w	r3, [r4, #148]	; 0x94
			conn->le.pending_timeout = param->timeout;
    af28:	88eb      	ldrh	r3, [r5, #6]
    af2a:	f8a4 3096 	strh.w	r3, [r4, #150]	; 0x96
}
    af2e:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
    af30:	f06f 0015 	mvn.w	r0, #21
    af34:	e7fb      	b.n	af2e <send_conn_le_param_update+0x52>
    af36:	bf00      	nop
    af38:	2000e4d8 	.word	0x2000e4d8

0000af3c <conn_update_timeout>:
{
    af3c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	if (conn->state == BT_CONN_DISCONNECTED) {
    af3e:	f810 3c47 	ldrb.w	r3, [r0, #-71]
{
    af42:	4604      	mov	r4, r0
	struct bt_conn *conn = CONTAINER_OF(work, struct bt_conn, update_work);
    af44:	f1a0 0654 	sub.w	r6, r0, #84	; 0x54
	if (conn->state == BT_CONN_DISCONNECTED) {
    af48:	b9f3      	cbnz	r3, af88 <conn_update_timeout+0x4c>
		bt_l2cap_disconnected(conn);
    af4a:	4630      	mov	r0, r6
    af4c:	f017 fc8d 	bl	2286a <bt_l2cap_disconnected>
	for (cb = callback_list; cb; cb = cb->_next) {
    af50:	4b25      	ldr	r3, [pc, #148]	; (afe8 <conn_update_timeout+0xac>)
    af52:	681d      	ldr	r5, [r3, #0]
    af54:	b985      	cbnz	r5, af78 <conn_update_timeout+0x3c>
	atomic_dec(&conn->ref);
    af56:	1f20      	subs	r0, r4, #4
    af58:	f017 fb54 	bl	22604 <atomic_dec>
		    atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    af5c:	2108      	movs	r1, #8
    af5e:	4823      	ldr	r0, [pc, #140]	; (afec <conn_update_timeout+0xb0>)
    af60:	f017 fb3e 	bl	225e0 <atomic_test_bit>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    af64:	b130      	cbz	r0, af74 <conn_update_timeout+0x38>
		    !atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING)) {
    af66:	2105      	movs	r1, #5
    af68:	4820      	ldr	r0, [pc, #128]	; (afec <conn_update_timeout+0xb0>)
    af6a:	f017 fb39 	bl	225e0 <atomic_test_bit>
		    atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    af6e:	b908      	cbnz	r0, af74 <conn_update_timeout+0x38>
			bt_le_adv_resume();
    af70:	f7ff f8bc 	bl	a0ec <bt_le_adv_resume>
}
    af74:	b004      	add	sp, #16
    af76:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->disconnected) {
    af78:	686b      	ldr	r3, [r5, #4]
    af7a:	b11b      	cbz	r3, af84 <conn_update_timeout+0x48>
			cb->disconnected(conn, conn->err);
    af7c:	f814 1c48 	ldrb.w	r1, [r4, #-72]
    af80:	4630      	mov	r0, r6
    af82:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
    af84:	69ad      	ldr	r5, [r5, #24]
    af86:	e7e5      	b.n	af54 <conn_update_timeout+0x18>
	if (conn->type != BT_CONN_TYPE_LE) {
    af88:	f810 3c52 	ldrb.w	r3, [r0, #-82]
    af8c:	2b01      	cmp	r3, #1
    af8e:	d1f1      	bne.n	af74 <conn_update_timeout+0x38>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    af90:	f3bf 8f5b 	dmb	ish
		if (atomic_test_and_clear_bit(conn->flags,
    af94:	f1a0 0550 	sub.w	r5, r0, #80	; 0x50
    af98:	e855 3f00 	ldrex	r3, [r5]
    af9c:	f423 7200 	bic.w	r2, r3, #512	; 0x200
    afa0:	e845 2100 	strex	r1, r2, [r5]
    afa4:	2900      	cmp	r1, #0
    afa6:	d1f7      	bne.n	af98 <conn_update_timeout+0x5c>
    afa8:	f3bf 8f5b 	dmb	ish
    afac:	059b      	lsls	r3, r3, #22
    afae:	d514      	bpl.n	afda <conn_update_timeout+0x9e>
			param = BT_LE_CONN_PARAM(conn->le.interval_min,
    afb0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    afb2:	9300      	str	r3, [sp, #0]
    afb4:	6c23      	ldr	r3, [r4, #64]	; 0x40
    afb6:	9301      	str	r3, [sp, #4]
			send_conn_le_param_update(conn, param);
    afb8:	4669      	mov	r1, sp
			send_conn_le_param_update(conn, param);
    afba:	4630      	mov	r0, r6
    afbc:	f7ff ff8e 	bl	aedc <send_conn_le_param_update>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    afc0:	f3bf 8f5b 	dmb	ish
    afc4:	e855 3f00 	ldrex	r3, [r5]
    afc8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    afcc:	e845 3200 	strex	r2, r3, [r5]
    afd0:	2a00      	cmp	r2, #0
    afd2:	d1f7      	bne.n	afc4 <conn_update_timeout+0x88>
    afd4:	f3bf 8f5b 	dmb	ish
    afd8:	e7cc      	b.n	af74 <conn_update_timeout+0x38>
			param = BT_LE_CONN_PARAM(
    afda:	4a05      	ldr	r2, [pc, #20]	; (aff0 <conn_update_timeout+0xb4>)
    afdc:	6851      	ldr	r1, [r2, #4]
    afde:	6810      	ldr	r0, [r2, #0]
    afe0:	ab02      	add	r3, sp, #8
    afe2:	c303      	stmia	r3!, {r0, r1}
			send_conn_le_param_update(conn, param);
    afe4:	a902      	add	r1, sp, #8
    afe6:	e7e8      	b.n	afba <conn_update_timeout+0x7e>
    afe8:	200003a4 	.word	0x200003a4
    afec:	2000e548 	.word	0x2000e548
    aff0:	00028734 	.word	0x00028734

0000aff4 <bt_conn_create_pdu_timeout>:
	} else {
#if defined(CONFIG_NET_BUF_LOG)
		buf = net_buf_alloc_fixed_debug(pool, timeout, func,
							line);
#else
		buf = net_buf_alloc(pool, timeout);
    aff4:	4b10      	ldr	r3, [pc, #64]	; (b038 <bt_conn_create_pdu_timeout+0x44>)
{
    aff6:	b570      	push	{r4, r5, r6, lr}
		buf = net_buf_alloc(pool, timeout);
    aff8:	2800      	cmp	r0, #0
    affa:	bf08      	it	eq
    affc:	4618      	moveq	r0, r3
{
    affe:	460e      	mov	r6, r1
		buf = net_buf_alloc(pool, timeout);
    b000:	4611      	mov	r1, r2
{
    b002:	4615      	mov	r5, r2
		buf = net_buf_alloc(pool, timeout);
    b004:	f019 feb4 	bl	24d70 <net_buf_alloc_fixed>
#endif
	}

	if (!buf) {
    b008:	4604      	mov	r4, r0
    b00a:	b980      	cbnz	r0, b02e <bt_conn_create_pdu_timeout+0x3a>
		BT_WARN("Unable to allocate buffer: timeout %d", timeout);
    b00c:	2302      	movs	r3, #2
    b00e:	f04f 0200 	mov.w	r2, #0
    b012:	f363 0207 	bfi	r2, r3, #0, #8
    b016:	4909      	ldr	r1, [pc, #36]	; (b03c <bt_conn_create_pdu_timeout+0x48>)
    b018:	4b09      	ldr	r3, [pc, #36]	; (b040 <bt_conn_create_pdu_timeout+0x4c>)
    b01a:	480a      	ldr	r0, [pc, #40]	; (b044 <bt_conn_create_pdu_timeout+0x50>)
    b01c:	1a5b      	subs	r3, r3, r1
    b01e:	08db      	lsrs	r3, r3, #3
    b020:	f363 128f 	bfi	r2, r3, #6, #10
    b024:	4629      	mov	r1, r5
    b026:	f016 f815 	bl	21054 <log_1>

	reserve += sizeof(struct bt_hci_acl_hdr) + BT_BUF_RESERVE;
	net_buf_reserve(buf, reserve);

	return buf;
}
    b02a:	4620      	mov	r0, r4
    b02c:	bd70      	pop	{r4, r5, r6, pc}
	net_buf_reserve(buf, reserve);
    b02e:	1d31      	adds	r1, r6, #4
    b030:	3008      	adds	r0, #8
    b032:	f019 febc 	bl	24dae <net_buf_simple_reserve>
	return buf;
    b036:	e7f8      	b.n	b02a <bt_conn_create_pdu_timeout+0x36>
    b038:	2000f008 	.word	0x2000f008
    b03c:	00028540 	.word	0x00028540
    b040:	00028558 	.word	0x00028558
    b044:	00063518 	.word	0x00063518

0000b048 <bt_conn_create_frag_timeout>:
	return bt_conn_create_pdu_timeout(pool, reserve, timeout);
    b048:	460a      	mov	r2, r1
    b04a:	4601      	mov	r1, r0
    b04c:	4801      	ldr	r0, [pc, #4]	; (b054 <bt_conn_create_frag_timeout+0xc>)
    b04e:	f7ff bfd1 	b.w	aff4 <bt_conn_create_pdu_timeout>
    b052:	bf00      	nop
    b054:	2000f074 	.word	0x2000f074

0000b058 <create_frag.isra.11>:
static struct net_buf *create_frag(struct bt_conn *conn, struct net_buf *buf)
    b058:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b05c:	4606      	mov	r6, r0
    b05e:	460c      	mov	r4, r1
	frag = bt_conn_create_frag(0);
    b060:	2000      	movs	r0, #0
    b062:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    b066:	f7ff ffef 	bl	b048 <bt_conn_create_frag_timeout>
	if (conn->state != BT_CONN_CONNECTED) {
    b06a:	7833      	ldrb	r3, [r6, #0]
    b06c:	2b06      	cmp	r3, #6
	frag = bt_conn_create_frag(0);
    b06e:	4605      	mov	r5, r0
	if (conn->state != BT_CONN_CONNECTED) {
    b070:	f04f 0600 	mov.w	r6, #0
    b074:	d005      	beq.n	b082 <create_frag.isra.11+0x2a>
		net_buf_unref(frag);
    b076:	f00d fff1 	bl	1905c <net_buf_unref>
		return NULL;
    b07a:	4635      	mov	r5, r6
}
    b07c:	4628      	mov	r0, r5
    b07e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	tx_data(frag)->tx = NULL;
    b082:	6146      	str	r6, [r0, #20]
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
    b084:	f100 0708 	add.w	r7, r0, #8
	return bt_dev.le.mtu;
    b088:	4e0c      	ldr	r6, [pc, #48]	; (b0bc <create_frag.isra.11+0x64>)
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
    b08a:	4638      	mov	r0, r7
    b08c:	f8b6 8088 	ldrh.w	r8, [r6, #136]	; 0x88
    b090:	f019 fee8 	bl	24e64 <net_buf_simple_tailroom>
    b094:	4580      	cmp	r8, r0
    b096:	d20c      	bcs.n	b0b2 <create_frag.isra.11+0x5a>
	return bt_dev.le.mtu;
    b098:	f8b6 6088 	ldrh.w	r6, [r6, #136]	; 0x88
	net_buf_add_mem(frag, buf->data, frag_len);
    b09c:	f854 1f08 	ldr.w	r1, [r4, #8]!
    b0a0:	4632      	mov	r2, r6
    b0a2:	4638      	mov	r0, r7
    b0a4:	f019 fe9e 	bl	24de4 <net_buf_simple_add_mem>
	net_buf_pull(buf, frag_len);
    b0a8:	4631      	mov	r1, r6
    b0aa:	4620      	mov	r0, r4
    b0ac:	f019 febe 	bl	24e2c <net_buf_simple_pull>
	return frag;
    b0b0:	e7e4      	b.n	b07c <create_frag.isra.11+0x24>
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
    b0b2:	4638      	mov	r0, r7
    b0b4:	f019 fed6 	bl	24e64 <net_buf_simple_tailroom>
    b0b8:	b286      	uxth	r6, r0
    b0ba:	e7ef      	b.n	b09c <create_frag.isra.11+0x44>
    b0bc:	2000e4d8 	.word	0x2000e4d8

0000b0c0 <bt_conn_process_tx>:
{
    b0c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (conn->state == BT_CONN_DISCONNECTED &&
    b0c2:	7b43      	ldrb	r3, [r0, #13]
{
    b0c4:	4605      	mov	r5, r0
	if (conn->state == BT_CONN_DISCONNECTED &&
    b0c6:	b993      	cbnz	r3, b0ee <bt_conn_process_tx+0x2e>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    b0c8:	f3bf 8f5b 	dmb	ish
    b0cc:	1d03      	adds	r3, r0, #4
    b0ce:	e853 2f00 	ldrex	r2, [r3]
    b0d2:	f022 0140 	bic.w	r1, r2, #64	; 0x40
    b0d6:	e843 1400 	strex	r4, r1, [r3]
    b0da:	2c00      	cmp	r4, #0
    b0dc:	d1f7      	bne.n	b0ce <bt_conn_process_tx+0xe>
    b0de:	f3bf 8f5b 	dmb	ish
    b0e2:	0653      	lsls	r3, r2, #25
    b0e4:	d503      	bpl.n	b0ee <bt_conn_process_tx+0x2e>
}
    b0e6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		conn_cleanup(conn);
    b0ea:	f7ff bb61 	b.w	a7b0 <conn_cleanup>
	buf = net_buf_get(&conn->tx_queue, K_NO_WAIT);
    b0ee:	2100      	movs	r1, #0
    b0f0:	f105 0034 	add.w	r0, r5, #52	; 0x34
    b0f4:	f019 fe42 	bl	24d7c <net_buf_get>
	BT_ASSERT(buf);
    b0f8:	4604      	mov	r4, r0
    b0fa:	b960      	cbnz	r0, b116 <bt_conn_process_tx+0x56>
    b0fc:	f240 6316 	movw	r3, #1558	; 0x616
    b100:	4a1f      	ldr	r2, [pc, #124]	; (b180 <bt_conn_process_tx+0xc0>)
    b102:	4920      	ldr	r1, [pc, #128]	; (b184 <bt_conn_process_tx+0xc4>)
    b104:	4820      	ldr	r0, [pc, #128]	; (b188 <bt_conn_process_tx+0xc8>)
    b106:	f014 fe54 	bl	1fdb2 <printk>
    b10a:	4040      	eors	r0, r0
    b10c:	f380 8811 	msr	BASEPRI, r0
    b110:	f04f 0003 	mov.w	r0, #3
    b114:	df02      	svc	2
	return bt_dev.le.mtu;
    b116:	4e1d      	ldr	r6, [pc, #116]	; (b18c <bt_conn_process_tx+0xcc>)
	if (buf->len <= conn_mtu(conn)) {
    b118:	89a1      	ldrh	r1, [r4, #12]
    b11a:	f8b6 2088 	ldrh.w	r2, [r6, #136]	; 0x88
    b11e:	4291      	cmp	r1, r2
    b120:	d807      	bhi.n	b132 <bt_conn_process_tx+0x72>
		return send_frag(conn, buf, BT_ACL_START_NO_FLUSH, false);
    b122:	2300      	movs	r3, #0
    b124:	461a      	mov	r2, r3
	return send_frag(conn, buf, BT_ACL_CONT, false);
    b126:	4621      	mov	r1, r4
    b128:	4628      	mov	r0, r5
    b12a:	f7ff faa7 	bl	a67c <send_frag>
	if (!send_buf(conn, buf)) {
    b12e:	b140      	cbz	r0, b142 <bt_conn_process_tx+0x82>
}
    b130:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	frag = create_frag(conn, buf);
    b132:	f105 070d 	add.w	r7, r5, #13
    b136:	4621      	mov	r1, r4
    b138:	4638      	mov	r0, r7
    b13a:	f7ff ff8d 	bl	b058 <create_frag.isra.11>
	if (!frag) {
    b13e:	4601      	mov	r1, r0
    b140:	b920      	cbnz	r0, b14c <bt_conn_process_tx+0x8c>
		net_buf_unref(buf);
    b142:	4620      	mov	r0, r4
}
    b144:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		net_buf_unref(buf);
    b148:	f00d bf88 	b.w	1905c <net_buf_unref>
	if (!send_frag(conn, frag, BT_ACL_START_NO_FLUSH, true)) {
    b14c:	2301      	movs	r3, #1
    b14e:	2200      	movs	r2, #0
		if (!send_frag(conn, frag, BT_ACL_CONT, true)) {
    b150:	4628      	mov	r0, r5
    b152:	f7ff fa93 	bl	a67c <send_frag>
    b156:	2800      	cmp	r0, #0
    b158:	d0f3      	beq.n	b142 <bt_conn_process_tx+0x82>
	while (buf->len > conn_mtu(conn)) {
    b15a:	89a2      	ldrh	r2, [r4, #12]
    b15c:	f8b6 3088 	ldrh.w	r3, [r6, #136]	; 0x88
    b160:	429a      	cmp	r2, r3
    b162:	d802      	bhi.n	b16a <bt_conn_process_tx+0xaa>
	return send_frag(conn, buf, BT_ACL_CONT, false);
    b164:	2300      	movs	r3, #0
    b166:	2201      	movs	r2, #1
    b168:	e7dd      	b.n	b126 <bt_conn_process_tx+0x66>
		frag = create_frag(conn, buf);
    b16a:	4621      	mov	r1, r4
    b16c:	4638      	mov	r0, r7
    b16e:	f7ff ff73 	bl	b058 <create_frag.isra.11>
		if (!frag) {
    b172:	4601      	mov	r1, r0
    b174:	2800      	cmp	r0, #0
    b176:	d0e4      	beq.n	b142 <bt_conn_process_tx+0x82>
		if (!send_frag(conn, frag, BT_ACL_CONT, true)) {
    b178:	2301      	movs	r3, #1
    b17a:	461a      	mov	r2, r3
    b17c:	e7e8      	b.n	b150 <bt_conn_process_tx+0x90>
    b17e:	bf00      	nop
    b180:	0006353e 	.word	0x0006353e
    b184:	00064dfa 	.word	0x00064dfa
    b188:	000632fe 	.word	0x000632fe
    b18c:	2000e4d8 	.word	0x2000e4d8

0000b190 <bt_conn_auth_cb_register>:

#if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_BREDR)
int bt_conn_auth_cb_register(const struct bt_conn_auth_cb *cb)
{
	if (!cb) {
    b190:	4b0c      	ldr	r3, [pc, #48]	; (b1c4 <bt_conn_auth_cb_register+0x34>)
    b192:	b908      	cbnz	r0, b198 <bt_conn_auth_cb_register+0x8>
		bt_auth = NULL;
    b194:	6018      	str	r0, [r3, #0]
		return 0;
    b196:	4770      	bx	lr
	}

	if (bt_auth) {
    b198:	681a      	ldr	r2, [r3, #0]
    b19a:	b962      	cbnz	r2, b1b6 <bt_conn_auth_cb_register+0x26>
	}

	/* The cancel callback must always be provided if the app provides
	 * interactive callbacks.
	 */
	if (!cb->cancel &&
    b19c:	6902      	ldr	r2, [r0, #16]
    b19e:	b93a      	cbnz	r2, b1b0 <bt_conn_auth_cb_register+0x20>
    b1a0:	6802      	ldr	r2, [r0, #0]
    b1a2:	b95a      	cbnz	r2, b1bc <bt_conn_auth_cb_register+0x2c>
	    (cb->passkey_display || cb->passkey_entry || cb->passkey_confirm ||
    b1a4:	6842      	ldr	r2, [r0, #4]
    b1a6:	b94a      	cbnz	r2, b1bc <bt_conn_auth_cb_register+0x2c>
    b1a8:	6882      	ldr	r2, [r0, #8]
    b1aa:	b93a      	cbnz	r2, b1bc <bt_conn_auth_cb_register+0x2c>
    b1ac:	6942      	ldr	r2, [r0, #20]
    b1ae:	b92a      	cbnz	r2, b1bc <bt_conn_auth_cb_register+0x2c>
#endif
	     cb->pairing_confirm)) {
		return -EINVAL;
	}

	bt_auth = cb;
    b1b0:	6018      	str	r0, [r3, #0]
	return 0;
    b1b2:	2000      	movs	r0, #0
    b1b4:	4770      	bx	lr
		return -EALREADY;
    b1b6:	f06f 0077 	mvn.w	r0, #119	; 0x77
    b1ba:	4770      	bx	lr
		return -EINVAL;
    b1bc:	f06f 0015 	mvn.w	r0, #21
}
    b1c0:	4770      	bx	lr
    b1c2:	bf00      	nop
    b1c4:	200003a0 	.word	0x200003a0

0000b1c8 <bt_conn_index>:
}
#endif /* CONFIG_BT_SMP || CONFIG_BT_BREDR */

u8_t bt_conn_index(struct bt_conn *conn)
{
	u8_t index = conn - conns;
    b1c8:	4b03      	ldr	r3, [pc, #12]	; (b1d8 <bt_conn_index+0x10>)
    b1ca:	1ac0      	subs	r0, r0, r3
    b1cc:	4b03      	ldr	r3, [pc, #12]	; (b1dc <bt_conn_index+0x14>)
    b1ce:	1080      	asrs	r0, r0, #2
    b1d0:	4358      	muls	r0, r3

	__ASSERT(index < CONFIG_BT_MAX_CONN, "Invalid bt_conn pointer");
	return index;
}
    b1d2:	b2c0      	uxtb	r0, r0
    b1d4:	4770      	bx	lr
    b1d6:	bf00      	nop
    b1d8:	200003d8 	.word	0x200003d8
    b1dc:	c18f9c19 	.word	0xc18f9c19

0000b1e0 <bt_conn_init>:

	return bt_conn_ref(conn);
}

int bt_conn_init(void)
{
    b1e0:	b510      	push	{r4, lr}
	int err, i;

	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
		k_fifo_put(&free_tx, &conn_tx[i]);
    b1e2:	490b      	ldr	r1, [pc, #44]	; (b210 <bt_conn_init+0x30>)
    b1e4:	480b      	ldr	r0, [pc, #44]	; (b214 <bt_conn_init+0x34>)
    b1e6:	f01c fc8e 	bl	27b06 <k_queue_append>
    b1ea:	490b      	ldr	r1, [pc, #44]	; (b218 <bt_conn_init+0x38>)
    b1ec:	4809      	ldr	r0, [pc, #36]	; (b214 <bt_conn_init+0x34>)
    b1ee:	f01c fc8a 	bl	27b06 <k_queue_append>
    b1f2:	490a      	ldr	r1, [pc, #40]	; (b21c <bt_conn_init+0x3c>)
    b1f4:	4807      	ldr	r0, [pc, #28]	; (b214 <bt_conn_init+0x34>)
    b1f6:	f01c fc86 	bl	27b06 <k_queue_append>
	}

	bt_att_init();
    b1fa:	f017 fe44 	bl	22e86 <bt_att_init>

	err = bt_smp_init();
    b1fe:	f004 ffa1 	bl	10144 <bt_smp_init>
	if (err) {
    b202:	4604      	mov	r4, r0
    b204:	b908      	cbnz	r0, b20a <bt_conn_init+0x2a>
		return err;
	}

	bt_l2cap_init();
    b206:	f017 fb83 	bl	22910 <bt_l2cap_init>
			}
		}
	}

	return 0;
}
    b20a:	4620      	mov	r0, r4
    b20c:	bd10      	pop	{r4, pc}
    b20e:	bf00      	nop
    b210:	200003a8 	.word	0x200003a8
    b214:	2000efe0 	.word	0x2000efe0
    b218:	200003b8 	.word	0x200003b8
    b21c:	200003c8 	.word	0x200003c8

0000b220 <l2cap_accept>:
	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
		struct bt_l2cap *l2cap = &bt_l2cap_pool[i];

		if (l2cap->chan.chan.conn) {
    b220:	4a0d      	ldr	r2, [pc, #52]	; (b258 <l2cap_accept+0x38>)
{
    b222:	b508      	push	{r3, lr}
		if (l2cap->chan.chan.conn) {
    b224:	6813      	ldr	r3, [r2, #0]
    b226:	b923      	cbnz	r3, b232 <l2cap_accept+0x12>
			continue;
		}

		l2cap->chan.chan.ops = &ops;
    b228:	480c      	ldr	r0, [pc, #48]	; (b25c <l2cap_accept+0x3c>)
    b22a:	6050      	str	r0, [r2, #4]
		*chan = &l2cap->chan.chan;
    b22c:	600a      	str	r2, [r1, #0]

		return 0;
    b22e:	4618      	mov	r0, r3
	}

	BT_ERR("No available L2CAP context for conn %p", conn);

	return -ENOMEM;
}
    b230:	bd08      	pop	{r3, pc}
	BT_ERR("No available L2CAP context for conn %p", conn);
    b232:	2301      	movs	r3, #1
    b234:	f04f 0200 	mov.w	r2, #0
    b238:	f363 0207 	bfi	r2, r3, #0, #8
    b23c:	4908      	ldr	r1, [pc, #32]	; (b260 <l2cap_accept+0x40>)
    b23e:	4b09      	ldr	r3, [pc, #36]	; (b264 <l2cap_accept+0x44>)
    b240:	1a5b      	subs	r3, r3, r1
    b242:	08db      	lsrs	r3, r3, #3
    b244:	4601      	mov	r1, r0
    b246:	f363 128f 	bfi	r2, r3, #6, #10
    b24a:	4807      	ldr	r0, [pc, #28]	; (b268 <l2cap_accept+0x48>)
    b24c:	f015 ff02 	bl	21054 <log_1>
	return -ENOMEM;
    b250:	f06f 000b 	mvn.w	r0, #11
    b254:	e7ec      	b.n	b230 <l2cap_accept+0x10>
    b256:	bf00      	nop
    b258:	2000047c 	.word	0x2000047c
    b25c:	00028f54 	.word	0x00028f54
    b260:	00028540 	.word	0x00028540
    b264:	00028628 	.word	0x00028628
    b268:	0006371f 	.word	0x0006371f

0000b26c <l2cap_create_le_sig_pdu.isra.8>:
static struct net_buf *l2cap_create_le_sig_pdu(struct net_buf *buf,
    b26c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b26e:	4605      	mov	r5, r0
    b270:	460f      	mov	r7, r1
    b272:	4616      	mov	r6, r2
	return bt_conn_create_pdu_timeout(pool,
    b274:	2104      	movs	r1, #4
    b276:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
    b27a:	2000      	movs	r0, #0
    b27c:	f7ff feba 	bl	aff4 <bt_conn_create_pdu_timeout>
	if (!buf) {
    b280:	4604      	mov	r4, r0
    b282:	b980      	cbnz	r0, b2a6 <l2cap_create_le_sig_pdu.isra.8+0x3a>
		BT_ERR("Unable to allocate buffer for op 0x%02x", code);
    b284:	2301      	movs	r3, #1
    b286:	f04f 0200 	mov.w	r2, #0
    b28a:	f363 0207 	bfi	r2, r3, #0, #8
    b28e:	490a      	ldr	r1, [pc, #40]	; (b2b8 <l2cap_create_le_sig_pdu.isra.8+0x4c>)
    b290:	4b0a      	ldr	r3, [pc, #40]	; (b2bc <l2cap_create_le_sig_pdu.isra.8+0x50>)
    b292:	480b      	ldr	r0, [pc, #44]	; (b2c0 <l2cap_create_le_sig_pdu.isra.8+0x54>)
    b294:	1a5b      	subs	r3, r3, r1
    b296:	08db      	lsrs	r3, r3, #3
    b298:	f363 128f 	bfi	r2, r3, #6, #10
    b29c:	4629      	mov	r1, r5
    b29e:	f015 fed9 	bl	21054 <log_1>
}
    b2a2:	4620      	mov	r0, r4
    b2a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	hdr = net_buf_add(buf, sizeof(*hdr));
    b2a6:	2104      	movs	r1, #4
    b2a8:	3008      	adds	r0, #8
    b2aa:	f019 fd95 	bl	24dd8 <net_buf_simple_add>
	hdr->code = code;
    b2ae:	7005      	strb	r5, [r0, #0]
	hdr->ident = ident;
    b2b0:	7047      	strb	r7, [r0, #1]
	hdr->len = sys_cpu_to_le16(len);
    b2b2:	8046      	strh	r6, [r0, #2]
	return buf;
    b2b4:	e7f5      	b.n	b2a2 <l2cap_create_le_sig_pdu.isra.8+0x36>
    b2b6:	bf00      	nop
    b2b8:	00028540 	.word	0x00028540
    b2bc:	00028628 	.word	0x00028628
    b2c0:	00063746 	.word	0x00063746

0000b2c4 <l2cap_rtx_timeout>:
{
    b2c4:	b538      	push	{r3, r4, r5, lr}
	BT_ERR("chan %p timeout", chan);
    b2c6:	f04f 0200 	mov.w	r2, #0
    b2ca:	2301      	movs	r3, #1
    b2cc:	f363 0207 	bfi	r2, r3, #0, #8
    b2d0:	490b      	ldr	r1, [pc, #44]	; (b300 <l2cap_rtx_timeout+0x3c>)
    b2d2:	4b0c      	ldr	r3, [pc, #48]	; (b304 <l2cap_rtx_timeout+0x40>)
    b2d4:	1a5b      	subs	r3, r3, r1
	struct bt_l2cap_le_chan *chan = LE_CHAN_RTX(work);
    b2d6:	f1a0 0410 	sub.w	r4, r0, #16
    b2da:	08db      	lsrs	r3, r3, #3
{
    b2dc:	4605      	mov	r5, r0
	BT_ERR("chan %p timeout", chan);
    b2de:	f363 128f 	bfi	r2, r3, #6, #10
    b2e2:	4621      	mov	r1, r4
    b2e4:	4808      	ldr	r0, [pc, #32]	; (b308 <l2cap_rtx_timeout+0x44>)
    b2e6:	f015 feb5 	bl	21054 <log_1>
	bt_l2cap_chan_remove(chan->chan.conn, &chan->chan);
    b2ea:	f855 0c10 	ldr.w	r0, [r5, #-16]
    b2ee:	4621      	mov	r1, r4
    b2f0:	f017 fa80 	bl	227f4 <bt_l2cap_chan_remove>
	bt_l2cap_chan_del(&chan->chan);
    b2f4:	4620      	mov	r0, r4
}
    b2f6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_l2cap_chan_del(&chan->chan);
    b2fa:	f017 ba9b 	b.w	22834 <bt_l2cap_chan_del>
    b2fe:	bf00      	nop
    b300:	00028540 	.word	0x00028540
    b304:	00028628 	.word	0x00028628
    b308:	00063808 	.word	0x00063808

0000b30c <bt_l2cap_connected>:
{
    b30c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
    b310:	4e21      	ldr	r6, [pc, #132]	; (b398 <bt_l2cap_connected+0x8c>)
    b312:	4f22      	ldr	r7, [pc, #136]	; (b39c <bt_l2cap_connected+0x90>)
	k_delayed_work_init(&chan->rtx_work, l2cap_rtx_timeout);
    b314:	f8df 8088 	ldr.w	r8, [pc, #136]	; b3a0 <bt_l2cap_connected+0x94>
{
    b318:	4605      	mov	r5, r0
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
    b31a:	42be      	cmp	r6, r7
    b31c:	d302      	bcc.n	b324 <bt_l2cap_connected+0x18>
}
    b31e:	b002      	add	sp, #8
    b320:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (fchan->accept(conn, &chan) < 0) {
    b324:	6873      	ldr	r3, [r6, #4]
    b326:	a901      	add	r1, sp, #4
    b328:	4628      	mov	r0, r5
    b32a:	4798      	blx	r3
    b32c:	2800      	cmp	r0, #0
    b32e:	db2d      	blt.n	b38c <bt_l2cap_connected+0x80>
		ch = BT_L2CAP_LE_CHAN(chan);
    b330:	9c01      	ldr	r4, [sp, #4]
		ch->rx.cid = fchan->cid;
    b332:	8833      	ldrh	r3, [r6, #0]
    b334:	86a3      	strh	r3, [r4, #52]	; 0x34
		ch->tx.cid = fchan->cid;
    b336:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
	k_delayed_work_init(&chan->rtx_work, l2cap_rtx_timeout);
    b33a:	4641      	mov	r1, r8
    b33c:	f104 0010 	add.w	r0, r4, #16
    b340:	f01c fde1 	bl	27f06 <k_delayed_work_init>
	parent->next = child;
    b344:	2300      	movs	r3, #0
    b346:	60a3      	str	r3, [r4, #8]
Z_GENLIST_APPEND(slist, snode)
    b348:	6ce9      	ldr	r1, [r5, #76]	; 0x4c
	sys_slist_append(&conn->channels, &chan->node);
    b34a:	f104 0208 	add.w	r2, r4, #8
    b34e:	b9f9      	cbnz	r1, b390 <bt_l2cap_connected+0x84>
	list->head = node;
    b350:	e9c5 2212 	strd	r2, r2, [r5, #72]	; 0x48
		if (chan->ops->connected) {
    b354:	9801      	ldr	r0, [sp, #4]
	chan->destroy = destroy;
    b356:	60e3      	str	r3, [r4, #12]
		if (chan->ops->connected) {
    b358:	6843      	ldr	r3, [r0, #4]
	chan->conn = conn;
    b35a:	6025      	str	r5, [r4, #0]
		if (chan->ops->connected) {
    b35c:	681b      	ldr	r3, [r3, #0]
    b35e:	b103      	cbz	r3, b362 <bt_l2cap_connected+0x56>
			chan->ops->connected(chan);
    b360:	4798      	blx	r3
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    b362:	9b01      	ldr	r3, [sp, #4]
    b364:	f3bf 8f5b 	dmb	ish
    b368:	3330      	adds	r3, #48	; 0x30
    b36a:	e853 2f00 	ldrex	r2, [r3]
    b36e:	f042 0201 	orr.w	r2, r2, #1
    b372:	e843 2100 	strex	r1, r2, [r3]
    b376:	2900      	cmp	r1, #0
    b378:	d1f7      	bne.n	b36a <bt_l2cap_connected+0x5e>
    b37a:	f3bf 8f5b 	dmb	ish
		if (chan->ops->status) {
    b37e:	9801      	ldr	r0, [sp, #4]
    b380:	6843      	ldr	r3, [r0, #4]
    b382:	699b      	ldr	r3, [r3, #24]
    b384:	b113      	cbz	r3, b38c <bt_l2cap_connected+0x80>
			chan->ops->status(chan, chan->status);
    b386:	f100 0130 	add.w	r1, r0, #48	; 0x30
    b38a:	4798      	blx	r3
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
    b38c:	3608      	adds	r6, #8
    b38e:	e7c4      	b.n	b31a <bt_l2cap_connected+0xe>
	parent->next = child;
    b390:	600a      	str	r2, [r1, #0]
	list->tail = node;
    b392:	64ea      	str	r2, [r5, #76]	; 0x4c
    b394:	e7de      	b.n	b354 <bt_l2cap_connected+0x48>
    b396:	bf00      	nop
    b398:	00028478 	.word	0x00028478
    b39c:	00028490 	.word	0x00028490
    b3a0:	0000b2c5 	.word	0x0000b2c5

0000b3a4 <l2cap_recv>:
	if (buf->len < sizeof(*hdr)) {
    b3a4:	898b      	ldrh	r3, [r1, #12]
    b3a6:	2b03      	cmp	r3, #3
{
    b3a8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    b3aa:	4605      	mov	r5, r0
    b3ac:	460e      	mov	r6, r1
	if (buf->len < sizeof(*hdr)) {
    b3ae:	d80e      	bhi.n	b3ce <l2cap_recv+0x2a>
		BT_ERR("Too small L2CAP signaling PDU");
    b3b0:	2301      	movs	r3, #1
    b3b2:	f04f 0100 	mov.w	r1, #0
    b3b6:	f363 0107 	bfi	r1, r3, #0, #8
    b3ba:	4a36      	ldr	r2, [pc, #216]	; (b494 <l2cap_recv+0xf0>)
    b3bc:	4b36      	ldr	r3, [pc, #216]	; (b498 <l2cap_recv+0xf4>)
    b3be:	4837      	ldr	r0, [pc, #220]	; (b49c <l2cap_recv+0xf8>)
    b3c0:	1a9b      	subs	r3, r3, r2
    b3c2:	08db      	lsrs	r3, r3, #3
    b3c4:	f363 118f 	bfi	r1, r3, #6, #10
		BT_ERR("Invalid ident value in L2CAP PDU");
    b3c8:	f015 fe37 	bl	2103a <log_0>
		return 0;
    b3cc:	e017      	b.n	b3fe <l2cap_recv+0x5a>
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    b3ce:	2104      	movs	r1, #4
    b3d0:	f106 0008 	add.w	r0, r6, #8
    b3d4:	f019 fd32 	bl	24e3c <net_buf_simple_pull_mem>
	if (buf->len != len) {
    b3d8:	89b1      	ldrh	r1, [r6, #12]
	len = sys_le16_to_cpu(hdr->len);
    b3da:	8842      	ldrh	r2, [r0, #2]
	if (buf->len != len) {
    b3dc:	428a      	cmp	r2, r1
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    b3de:	4604      	mov	r4, r0
	if (buf->len != len) {
    b3e0:	d010      	beq.n	b404 <l2cap_recv+0x60>
		BT_ERR("L2CAP length mismatch (%u != %u)", buf->len, len);
    b3e2:	2001      	movs	r0, #1
    b3e4:	f04f 0300 	mov.w	r3, #0
    b3e8:	f360 0307 	bfi	r3, r0, #0, #8
    b3ec:	4c29      	ldr	r4, [pc, #164]	; (b494 <l2cap_recv+0xf0>)
    b3ee:	482a      	ldr	r0, [pc, #168]	; (b498 <l2cap_recv+0xf4>)
    b3f0:	1b00      	subs	r0, r0, r4
    b3f2:	08c0      	lsrs	r0, r0, #3
    b3f4:	f360 138f 	bfi	r3, r0, #6, #10
    b3f8:	4829      	ldr	r0, [pc, #164]	; (b4a0 <l2cap_recv+0xfc>)
    b3fa:	f015 fe3f 	bl	2107c <log_2>
}
    b3fe:	2000      	movs	r0, #0
    b400:	b002      	add	sp, #8
    b402:	bd70      	pop	{r4, r5, r6, pc}
	if (!hdr->ident) {
    b404:	7843      	ldrb	r3, [r0, #1]
    b406:	b963      	cbnz	r3, b422 <l2cap_recv+0x7e>
		BT_ERR("Invalid ident value in L2CAP PDU");
    b408:	2301      	movs	r3, #1
    b40a:	f04f 0100 	mov.w	r1, #0
    b40e:	f363 0107 	bfi	r1, r3, #0, #8
    b412:	4a20      	ldr	r2, [pc, #128]	; (b494 <l2cap_recv+0xf0>)
    b414:	4b20      	ldr	r3, [pc, #128]	; (b498 <l2cap_recv+0xf4>)
    b416:	4823      	ldr	r0, [pc, #140]	; (b4a4 <l2cap_recv+0x100>)
    b418:	1a9b      	subs	r3, r3, r2
    b41a:	08db      	lsrs	r3, r3, #3
    b41c:	f363 118f 	bfi	r1, r3, #6, #10
    b420:	e7d2      	b.n	b3c8 <l2cap_recv+0x24>
	switch (hdr->code) {
    b422:	7801      	ldrb	r1, [r0, #0]
    b424:	2901      	cmp	r1, #1
    b426:	d0ea      	beq.n	b3fe <l2cap_recv+0x5a>
    b428:	2913      	cmp	r1, #19
    b42a:	d10e      	bne.n	b44a <l2cap_recv+0xa6>
	if (buf->len < sizeof(*rsp)) {
    b42c:	2a01      	cmp	r2, #1
    b42e:	d8e6      	bhi.n	b3fe <l2cap_recv+0x5a>
		BT_ERR("Too small LE conn param rsp");
    b430:	2301      	movs	r3, #1
    b432:	f04f 0100 	mov.w	r1, #0
    b436:	f363 0107 	bfi	r1, r3, #0, #8
    b43a:	4a16      	ldr	r2, [pc, #88]	; (b494 <l2cap_recv+0xf0>)
    b43c:	4b16      	ldr	r3, [pc, #88]	; (b498 <l2cap_recv+0xf4>)
    b43e:	481a      	ldr	r0, [pc, #104]	; (b4a8 <l2cap_recv+0x104>)
    b440:	1a9b      	subs	r3, r3, r2
    b442:	08db      	lsrs	r3, r3, #3
    b444:	f363 118f 	bfi	r1, r3, #6, #10
    b448:	e7be      	b.n	b3c8 <l2cap_recv+0x24>
		BT_WARN("Unknown L2CAP PDU code 0x%02x", hdr->code);
    b44a:	2302      	movs	r3, #2
    b44c:	f04f 0200 	mov.w	r2, #0
    b450:	f363 0207 	bfi	r2, r3, #0, #8
    b454:	480f      	ldr	r0, [pc, #60]	; (b494 <l2cap_recv+0xf0>)
    b456:	4b10      	ldr	r3, [pc, #64]	; (b498 <l2cap_recv+0xf4>)
    b458:	1a1b      	subs	r3, r3, r0
    b45a:	08db      	lsrs	r3, r3, #3
    b45c:	f363 128f 	bfi	r2, r3, #6, #10
    b460:	4812      	ldr	r0, [pc, #72]	; (b4ac <l2cap_recv+0x108>)
    b462:	f015 fdf7 	bl	21054 <log_1>
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
    b466:	7861      	ldrb	r1, [r4, #1]
		l2cap_send_reject(chan->conn, hdr->ident,
    b468:	682d      	ldr	r5, [r5, #0]
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
    b46a:	2202      	movs	r2, #2
    b46c:	2001      	movs	r0, #1
    b46e:	f7ff fefd 	bl	b26c <l2cap_create_le_sig_pdu.isra.8>
	if (!buf) {
    b472:	4604      	mov	r4, r0
    b474:	2800      	cmp	r0, #0
    b476:	d0c2      	beq.n	b3fe <l2cap_recv+0x5a>
	rej = net_buf_add(buf, sizeof(*rej));
    b478:	2102      	movs	r1, #2
    b47a:	3008      	adds	r0, #8
    b47c:	f019 fcac 	bl	24dd8 <net_buf_simple_add>
	rej->reason = sys_cpu_to_le16(reason);
    b480:	2300      	movs	r3, #0
    b482:	7003      	strb	r3, [r0, #0]
    b484:	7043      	strb	r3, [r0, #1]
		     bt_conn_tx_cb_t cb, void *user_data);

static inline void bt_l2cap_send(struct bt_conn *conn, u16_t cid,
				 struct net_buf *buf)
{
	bt_l2cap_send_cb(conn, cid, buf, NULL, NULL);
    b486:	4622      	mov	r2, r4
    b488:	9300      	str	r3, [sp, #0]
    b48a:	2105      	movs	r1, #5
    b48c:	4628      	mov	r0, r5
    b48e:	f017 fa11 	bl	228b4 <bt_l2cap_send_cb>
    b492:	e7b4      	b.n	b3fe <l2cap_recv+0x5a>
    b494:	00028540 	.word	0x00028540
    b498:	00028628 	.word	0x00028628
    b49c:	0006376e 	.word	0x0006376e
    b4a0:	0006378c 	.word	0x0006378c
    b4a4:	000637ad 	.word	0x000637ad
    b4a8:	000637ce 	.word	0x000637ce
    b4ac:	000637ea 	.word	0x000637ea

0000b4b0 <bt_l2cap_recv>:
	if (buf->len < sizeof(*hdr)) {
    b4b0:	898b      	ldrh	r3, [r1, #12]
    b4b2:	2b03      	cmp	r3, #3
{
    b4b4:	b570      	push	{r4, r5, r6, lr}
    b4b6:	4606      	mov	r6, r0
    b4b8:	460c      	mov	r4, r1
	if (buf->len < sizeof(*hdr)) {
    b4ba:	d812      	bhi.n	b4e2 <bt_l2cap_recv+0x32>
		BT_ERR("Too small L2CAP PDU received");
    b4bc:	2301      	movs	r3, #1
    b4be:	f04f 0100 	mov.w	r1, #0
    b4c2:	f363 0107 	bfi	r1, r3, #0, #8
    b4c6:	4a17      	ldr	r2, [pc, #92]	; (b524 <bt_l2cap_recv+0x74>)
    b4c8:	4b17      	ldr	r3, [pc, #92]	; (b528 <bt_l2cap_recv+0x78>)
    b4ca:	4818      	ldr	r0, [pc, #96]	; (b52c <bt_l2cap_recv+0x7c>)
    b4cc:	1a9b      	subs	r3, r3, r2
    b4ce:	08db      	lsrs	r3, r3, #3
    b4d0:	f363 118f 	bfi	r1, r3, #6, #10
    b4d4:	f015 fdb1 	bl	2103a <log_0>
	net_buf_unref(buf);
    b4d8:	4620      	mov	r0, r4
}
    b4da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	net_buf_unref(buf);
    b4de:	f00d bdbd 	b.w	1905c <net_buf_unref>
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    b4e2:	2104      	movs	r1, #4
    b4e4:	f104 0008 	add.w	r0, r4, #8
    b4e8:	f019 fca8 	bl	24e3c <net_buf_simple_pull_mem>
	cid = sys_le16_to_cpu(hdr->cid);
    b4ec:	8845      	ldrh	r5, [r0, #2]
	chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
    b4ee:	4630      	mov	r0, r6
    b4f0:	4629      	mov	r1, r5
    b4f2:	f017 fa03 	bl	228fc <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
    b4f6:	b978      	cbnz	r0, b518 <bt_l2cap_recv+0x68>
		BT_WARN("Ignoring data for unknown CID 0x%04x", cid);
    b4f8:	2302      	movs	r3, #2
    b4fa:	f04f 0200 	mov.w	r2, #0
    b4fe:	f363 0207 	bfi	r2, r3, #0, #8
    b502:	4908      	ldr	r1, [pc, #32]	; (b524 <bt_l2cap_recv+0x74>)
    b504:	4b08      	ldr	r3, [pc, #32]	; (b528 <bt_l2cap_recv+0x78>)
    b506:	480a      	ldr	r0, [pc, #40]	; (b530 <bt_l2cap_recv+0x80>)
    b508:	1a5b      	subs	r3, r3, r1
    b50a:	08db      	lsrs	r3, r3, #3
    b50c:	f363 128f 	bfi	r2, r3, #6, #10
    b510:	4629      	mov	r1, r5
    b512:	f015 fd9f 	bl	21054 <log_1>
		net_buf_unref(buf);
    b516:	e7df      	b.n	b4d8 <bt_l2cap_recv+0x28>
	chan->ops->recv(chan, buf);
    b518:	6843      	ldr	r3, [r0, #4]
    b51a:	4621      	mov	r1, r4
    b51c:	691b      	ldr	r3, [r3, #16]
    b51e:	4798      	blx	r3
    b520:	e7da      	b.n	b4d8 <bt_l2cap_recv+0x28>
    b522:	bf00      	nop
    b524:	00028540 	.word	0x00028540
    b528:	00028628 	.word	0x00028628
    b52c:	000636dd 	.word	0x000636dd
    b530:	000636fa 	.word	0x000636fa

0000b534 <bt_l2cap_update_conn_param>:
{
    b534:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ident++;
    b536:	4b15      	ldr	r3, [pc, #84]	; (b58c <bt_l2cap_update_conn_param+0x58>)
    b538:	781a      	ldrb	r2, [r3, #0]
    b53a:	3201      	adds	r2, #1
	if (!ident) {
    b53c:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
		ident++;
    b540:	bf08      	it	eq
    b542:	2201      	moveq	r2, #1
    b544:	701a      	strb	r2, [r3, #0]
{
    b546:	4605      	mov	r5, r0
    b548:	460c      	mov	r4, r1
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CONN_PARAM_REQ,
    b54a:	2208      	movs	r2, #8
    b54c:	7819      	ldrb	r1, [r3, #0]
    b54e:	2012      	movs	r0, #18
    b550:	f7ff fe8c 	bl	b26c <l2cap_create_le_sig_pdu.isra.8>
	if (!buf) {
    b554:	4606      	mov	r6, r0
    b556:	b1b0      	cbz	r0, b586 <bt_l2cap_update_conn_param+0x52>
	req = net_buf_add(buf, sizeof(*req));
    b558:	2108      	movs	r1, #8
    b55a:	4408      	add	r0, r1
    b55c:	f019 fc3c 	bl	24dd8 <net_buf_simple_add>
	req->min_interval = sys_cpu_to_le16(param->interval_min);
    b560:	8823      	ldrh	r3, [r4, #0]
    b562:	8003      	strh	r3, [r0, #0]
	req->max_interval = sys_cpu_to_le16(param->interval_max);
    b564:	8863      	ldrh	r3, [r4, #2]
    b566:	8043      	strh	r3, [r0, #2]
	req->latency = sys_cpu_to_le16(param->latency);
    b568:	88a3      	ldrh	r3, [r4, #4]
    b56a:	8083      	strh	r3, [r0, #4]
	req->timeout = sys_cpu_to_le16(param->timeout);
    b56c:	88e3      	ldrh	r3, [r4, #6]
    b56e:	80c3      	strh	r3, [r0, #6]
    b570:	2400      	movs	r4, #0
    b572:	9400      	str	r4, [sp, #0]
    b574:	4623      	mov	r3, r4
    b576:	4632      	mov	r2, r6
    b578:	2105      	movs	r1, #5
    b57a:	4628      	mov	r0, r5
    b57c:	f017 f99a 	bl	228b4 <bt_l2cap_send_cb>
	return 0;
    b580:	4620      	mov	r0, r4
}
    b582:	b002      	add	sp, #8
    b584:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOMEM;
    b586:	f06f 000b 	mvn.w	r0, #11
    b58a:	e7fa      	b.n	b582 <bt_l2cap_update_conn_param+0x4e>
    b58c:	2000aa39 	.word	0x2000aa39

0000b590 <find_type_cb>:
	u8_t value_len;
	u8_t err;
};

static u8_t find_type_cb(const struct bt_gatt_attr *attr, void *user_data)
{
    b590:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct find_type_data *data = user_data;
	struct bt_att *att = data->att;
    b594:	680e      	ldr	r6, [r1, #0]
{
    b596:	b092      	sub	sp, #72	; 0x48
    b598:	4605      	mov	r5, r0
    b59a:	460c      	mov	r4, r1
	struct bt_conn *conn = att->chan.chan.conn;
	int read;
	u8_t uuid[16];

	/* Skip secondary services */
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
    b59c:	2700      	movs	r7, #0
    b59e:	f642 0301 	movw	r3, #10241	; 0x2801
    b5a2:	a902      	add	r1, sp, #8
    b5a4:	6800      	ldr	r0, [r0, #0]
	struct bt_conn *conn = att->chan.chan.conn;
    b5a6:	f8d6 8000 	ldr.w	r8, [r6]
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
    b5aa:	f88d 7008 	strb.w	r7, [sp, #8]
    b5ae:	f8ad 300a 	strh.w	r3, [sp, #10]
    b5b2:	f016 feb4 	bl	2231e <bt_uuid_cmp>
    b5b6:	2800      	cmp	r0, #0
    b5b8:	d03e      	beq.n	b638 <find_type_cb+0xa8>
		goto skip;
	}

	/* Update group end_handle if not a primary service */
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY)) {
    b5ba:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    b5be:	a903      	add	r1, sp, #12
    b5c0:	6828      	ldr	r0, [r5, #0]
    b5c2:	f88d 700c 	strb.w	r7, [sp, #12]
    b5c6:	f8ad 300e 	strh.w	r3, [sp, #14]
    b5ca:	f016 fea8 	bl	2231e <bt_uuid_cmp>
    b5ce:	b150      	cbz	r0, b5e6 <find_type_cb+0x56>
		if (data->group &&
    b5d0:	68a3      	ldr	r3, [r4, #8]
    b5d2:	b123      	cbz	r3, b5de <find_type_cb+0x4e>
		    attr->handle > sys_le16_to_cpu(data->group->end_handle)) {
    b5d4:	8a2a      	ldrh	r2, [r5, #16]
		if (data->group &&
    b5d6:	8859      	ldrh	r1, [r3, #2]
    b5d8:	4291      	cmp	r1, r2
    b5da:	d200      	bcs.n	b5de <find_type_cb+0x4e>
			data->group->end_handle = sys_cpu_to_le16(attr->handle);
    b5dc:	805a      	strh	r2, [r3, #2]
		}
		return BT_GATT_ITER_CONTINUE;
    b5de:	2001      	movs	r0, #1
	return BT_GATT_ITER_CONTINUE;

skip:
	data->group = NULL;
	return BT_GATT_ITER_CONTINUE;
}
    b5e0:	b012      	add	sp, #72	; 0x48
    b5e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (att->chan.tx.mtu - data->buf->len < sizeof(*data->group)) {
    b5e6:	6862      	ldr	r2, [r4, #4]
    b5e8:	f8b6 3042 	ldrh.w	r3, [r6, #66]	; 0x42
    b5ec:	8992      	ldrh	r2, [r2, #12]
    b5ee:	1a9b      	subs	r3, r3, r2
    b5f0:	2b03      	cmp	r3, #3
    b5f2:	d9f5      	bls.n	b5e0 <find_type_cb+0x50>
	read = attr->read(conn, attr, uuid, sizeof(uuid), 0);
    b5f4:	2310      	movs	r3, #16
    b5f6:	9000      	str	r0, [sp, #0]
    b5f8:	686e      	ldr	r6, [r5, #4]
    b5fa:	eb0d 0203 	add.w	r2, sp, r3
    b5fe:	4629      	mov	r1, r5
    b600:	4640      	mov	r0, r8
    b602:	47b0      	blx	r6
	if (read < 0) {
    b604:	1e06      	subs	r6, r0, #0
    b606:	db17      	blt.n	b638 <find_type_cb+0xa8>
	if (read != data->value_len) {
    b608:	7c22      	ldrb	r2, [r4, #16]
    b60a:	68e0      	ldr	r0, [r4, #12]
    b60c:	4296      	cmp	r6, r2
    b60e:	d03c      	beq.n	b68a <find_type_cb+0xfa>
		if (!bt_uuid_create(&recvd_uuid.uuid, data->value, data->value_len)) {
    b610:	4601      	mov	r1, r0
    b612:	a80d      	add	r0, sp, #52	; 0x34
    b614:	f016 fead 	bl	22372 <bt_uuid_create>
    b618:	b988      	cbnz	r0, b63e <find_type_cb+0xae>
			BT_WARN("Unable to create UUID: size %u", data->value_len);
    b61a:	2302      	movs	r3, #2
    b61c:	f04f 0200 	mov.w	r2, #0
    b620:	f363 0207 	bfi	r2, r3, #0, #8
    b624:	491b      	ldr	r1, [pc, #108]	; (b694 <find_type_cb+0x104>)
    b626:	4b1c      	ldr	r3, [pc, #112]	; (b698 <find_type_cb+0x108>)
    b628:	481c      	ldr	r0, [pc, #112]	; (b69c <find_type_cb+0x10c>)
    b62a:	1a5b      	subs	r3, r3, r1
    b62c:	08db      	lsrs	r3, r3, #3
    b62e:	7c21      	ldrb	r1, [r4, #16]
    b630:	f363 128f 	bfi	r2, r3, #6, #10
			BT_WARN("Unable to create UUID: size %d", read);
    b634:	f015 fd0e 	bl	21054 <log_1>
	data->group = NULL;
    b638:	2300      	movs	r3, #0
    b63a:	60a3      	str	r3, [r4, #8]
	return BT_GATT_ITER_CONTINUE;
    b63c:	e7cf      	b.n	b5de <find_type_cb+0x4e>
		if (!bt_uuid_create(&ref_uuid.uuid, uuid, read)) {
    b63e:	b2f2      	uxtb	r2, r6
    b640:	a904      	add	r1, sp, #16
    b642:	a808      	add	r0, sp, #32
    b644:	f016 fe95 	bl	22372 <bt_uuid_create>
    b648:	b968      	cbnz	r0, b666 <find_type_cb+0xd6>
			BT_WARN("Unable to create UUID: size %d", read);
    b64a:	2302      	movs	r3, #2
    b64c:	f04f 0200 	mov.w	r2, #0
    b650:	f363 0207 	bfi	r2, r3, #0, #8
    b654:	490f      	ldr	r1, [pc, #60]	; (b694 <find_type_cb+0x104>)
    b656:	4b10      	ldr	r3, [pc, #64]	; (b698 <find_type_cb+0x108>)
    b658:	4811      	ldr	r0, [pc, #68]	; (b6a0 <find_type_cb+0x110>)
    b65a:	1a5b      	subs	r3, r3, r1
    b65c:	08db      	lsrs	r3, r3, #3
    b65e:	f363 128f 	bfi	r2, r3, #6, #10
    b662:	4631      	mov	r1, r6
    b664:	e7e6      	b.n	b634 <find_type_cb+0xa4>
		if (bt_uuid_cmp(&recvd_uuid.uuid, &ref_uuid.uuid)) {
    b666:	a908      	add	r1, sp, #32
    b668:	a80d      	add	r0, sp, #52	; 0x34
    b66a:	f016 fe58 	bl	2231e <bt_uuid_cmp>
	} else if (memcmp(data->value, uuid, read)) {
    b66e:	2800      	cmp	r0, #0
    b670:	d1e2      	bne.n	b638 <find_type_cb+0xa8>
	data->group = net_buf_add(data->buf, sizeof(*data->group));
    b672:	6860      	ldr	r0, [r4, #4]
	data->err = 0x00;
    b674:	2300      	movs	r3, #0
    b676:	7463      	strb	r3, [r4, #17]
	data->group = net_buf_add(data->buf, sizeof(*data->group));
    b678:	2104      	movs	r1, #4
    b67a:	3008      	adds	r0, #8
    b67c:	f019 fbac 	bl	24dd8 <net_buf_simple_add>
	data->group->start_handle = sys_cpu_to_le16(attr->handle);
    b680:	8a2b      	ldrh	r3, [r5, #16]
	data->group = net_buf_add(data->buf, sizeof(*data->group));
    b682:	60a0      	str	r0, [r4, #8]
	data->group->start_handle = sys_cpu_to_le16(attr->handle);
    b684:	8003      	strh	r3, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(attr->handle);
    b686:	8043      	strh	r3, [r0, #2]
	return BT_GATT_ITER_CONTINUE;
    b688:	e7a9      	b.n	b5de <find_type_cb+0x4e>
	} else if (memcmp(data->value, uuid, read)) {
    b68a:	4632      	mov	r2, r6
    b68c:	a904      	add	r1, sp, #16
    b68e:	f7f6 fa9f 	bl	1bd0 <memcmp>
    b692:	e7ec      	b.n	b66e <find_type_cb+0xde>
    b694:	00028540 	.word	0x00028540
    b698:	00028550 	.word	0x00028550
    b69c:	0006399f 	.word	0x0006399f
    b6a0:	000639be 	.word	0x000639be

0000b6a4 <att_cb.isra.6>:
static bt_conn_tx_cb_t att_cb(struct net_buf *buf)
    b6a4:	b508      	push	{r3, lr}
	switch (att_op_get_type(buf->data[0])) {
    b6a6:	7800      	ldrb	r0, [r0, #0]
    b6a8:	f017 f933 	bl	22912 <att_op_get_type>
    b6ac:	3801      	subs	r0, #1
    b6ae:	b2c0      	uxtb	r0, r0
    b6b0:	2804      	cmp	r0, #4
    b6b2:	bf96      	itet	ls
    b6b4:	4b02      	ldrls	r3, [pc, #8]	; (b6c0 <att_cb.isra.6+0x1c>)
    b6b6:	4803      	ldrhi	r0, [pc, #12]	; (b6c4 <att_cb.isra.6+0x20>)
    b6b8:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
}
    b6bc:	bd08      	pop	{r3, pc}
    b6be:	bf00      	nop
    b6c0:	00028f70 	.word	0x00028f70
    b6c4:	00022c73 	.word	0x00022c73

0000b6c8 <att_send>:
{
    b6c8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    b6cc:	4698      	mov	r8, r3
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
    b6ce:	688b      	ldr	r3, [r1, #8]
    b6d0:	781b      	ldrb	r3, [r3, #0]
    b6d2:	2bd2      	cmp	r3, #210	; 0xd2
{
    b6d4:	4607      	mov	r7, r0
    b6d6:	460c      	mov	r4, r1
    b6d8:	4616      	mov	r6, r2
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
    b6da:	d118      	bne.n	b70e <att_send+0x46>
		err = bt_smp_sign(conn, buf);
    b6dc:	f004 fb86 	bl	fdec <bt_smp_sign>
		if (err) {
    b6e0:	4605      	mov	r5, r0
    b6e2:	b1a0      	cbz	r0, b70e <att_send+0x46>
			BT_ERR("Error signing data");
    b6e4:	2301      	movs	r3, #1
    b6e6:	f04f 0100 	mov.w	r1, #0
    b6ea:	f363 0107 	bfi	r1, r3, #0, #8
    b6ee:	4a0f      	ldr	r2, [pc, #60]	; (b72c <att_send+0x64>)
    b6f0:	4b0f      	ldr	r3, [pc, #60]	; (b730 <att_send+0x68>)
    b6f2:	4810      	ldr	r0, [pc, #64]	; (b734 <att_send+0x6c>)
    b6f4:	1a9b      	subs	r3, r3, r2
    b6f6:	08db      	lsrs	r3, r3, #3
    b6f8:	f363 118f 	bfi	r1, r3, #6, #10
    b6fc:	f015 fc9d 	bl	2103a <log_0>
			net_buf_unref(buf);
    b700:	4620      	mov	r0, r4
    b702:	f00d fcab 	bl	1905c <net_buf_unref>
}
    b706:	4628      	mov	r0, r5
    b708:	b002      	add	sp, #8
    b70a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf,
    b70e:	b91e      	cbnz	r6, b718 <att_send+0x50>
				cb ? cb : att_cb(buf),
    b710:	68a0      	ldr	r0, [r4, #8]
    b712:	f7ff ffc7 	bl	b6a4 <att_cb.isra.6>
    b716:	4606      	mov	r6, r0
	return bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf,
    b718:	f8cd 8000 	str.w	r8, [sp]
    b71c:	4633      	mov	r3, r6
    b71e:	4622      	mov	r2, r4
    b720:	2104      	movs	r1, #4
    b722:	4638      	mov	r0, r7
    b724:	f017 f8c6 	bl	228b4 <bt_l2cap_send_cb>
    b728:	4605      	mov	r5, r0
    b72a:	e7ec      	b.n	b706 <att_send+0x3e>
    b72c:	00028540 	.word	0x00028540
    b730:	00028550 	.word	0x00028550
    b734:	00063885 	.word	0x00063885

0000b738 <bt_att_accept>:
	att->req->buf = NULL;
}
#endif /* CONFIG_BT_SMP */

static int bt_att_accept(struct bt_conn *conn, struct bt_l2cap_chan **chan)
{
    b738:	b573      	push	{r0, r1, r4, r5, r6, lr}
	};
	struct bt_att *att;

	BT_DBG("conn %p handle %u", conn, conn->handle);

	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
    b73a:	2200      	movs	r2, #0
{
    b73c:	4606      	mov	r6, r0
    b73e:	460d      	mov	r5, r1
	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
    b740:	4815      	ldr	r0, [pc, #84]	; (b798 <bt_att_accept+0x60>)
    b742:	a901      	add	r1, sp, #4
    b744:	f012 fe10 	bl	1e368 <k_mem_slab_alloc>
    b748:	4604      	mov	r4, r0
    b74a:	b198      	cbz	r0, b774 <bt_att_accept+0x3c>
		BT_ERR("No available ATT context for conn %p", conn);
    b74c:	2301      	movs	r3, #1
    b74e:	f04f 0200 	mov.w	r2, #0
    b752:	f363 0207 	bfi	r2, r3, #0, #8
    b756:	4911      	ldr	r1, [pc, #68]	; (b79c <bt_att_accept+0x64>)
    b758:	4b11      	ldr	r3, [pc, #68]	; (b7a0 <bt_att_accept+0x68>)
    b75a:	4812      	ldr	r0, [pc, #72]	; (b7a4 <bt_att_accept+0x6c>)
    b75c:	1a5b      	subs	r3, r3, r1
    b75e:	08db      	lsrs	r3, r3, #3
    b760:	f363 128f 	bfi	r2, r3, #6, #10
    b764:	4631      	mov	r1, r6
    b766:	f015 fc75 	bl	21054 <log_1>
		return -ENOMEM;
    b76a:	f06f 040b 	mvn.w	r4, #11
	att->chan.chan.ops = &ops;
	k_sem_init(&att->tx_sem, CONFIG_BT_ATT_TX_MAX, CONFIG_BT_ATT_TX_MAX);
	*chan = &att->chan.chan;

	return 0;
}
    b76e:	4620      	mov	r0, r4
    b770:	b002      	add	sp, #8
    b772:	bd70      	pop	{r4, r5, r6, pc}
__ssp_bos_icheck3(memset, void *, int)
    b774:	4601      	mov	r1, r0
    b776:	f44f 7284 	mov.w	r2, #264	; 0x108
    b77a:	9801      	ldr	r0, [sp, #4]
    b77c:	f7f6 fa57 	bl	1c2e <memset>
	att->chan.chan.ops = &ops;
    b780:	9801      	ldr	r0, [sp, #4]
    b782:	4b09      	ldr	r3, [pc, #36]	; (b7a8 <bt_att_accept+0x70>)
    b784:	6043      	str	r3, [r0, #4]
	z_impl_k_sem_init(sem, initial_count, limit);
    b786:	2203      	movs	r2, #3
    b788:	4611      	mov	r1, r2
    b78a:	30c8      	adds	r0, #200	; 0xc8
    b78c:	f01c fb3d 	bl	27e0a <z_impl_k_sem_init>
	*chan = &att->chan.chan;
    b790:	9b01      	ldr	r3, [sp, #4]
    b792:	602b      	str	r3, [r5, #0]
	return 0;
    b794:	e7eb      	b.n	b76e <bt_att_accept+0x36>
    b796:	bf00      	nop
    b798:	2000eed8 	.word	0x2000eed8
    b79c:	00028540 	.word	0x00028540
    b7a0:	00028550 	.word	0x00028550
    b7a4:	000638b9 	.word	0x000638b9
    b7a8:	00029074 	.word	0x00029074

0000b7ac <bt_att_connected>:
{
    b7ac:	b510      	push	{r4, lr}
    b7ae:	4604      	mov	r4, r0
	z_impl_k_queue_init(queue);
    b7b0:	30e0      	adds	r0, #224	; 0xe0
    b7b2:	f01c f99f 	bl	27af4 <z_impl_k_queue_init>
    b7b6:	f104 00f4 	add.w	r0, r4, #244	; 0xf4
    b7ba:	f01c f99b 	bl	27af4 <z_impl_k_queue_init>
	ch->tx.mtu = BT_ATT_DEFAULT_LE_MTU;
    b7be:	2317      	movs	r3, #23
    b7c0:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
	ch->rx.mtu = BT_ATT_DEFAULT_LE_MTU;
    b7c4:	86e3      	strh	r3, [r4, #54]	; 0x36
	k_delayed_work_init(&att->timeout_work, att_timeout);
    b7c6:	4904      	ldr	r1, [pc, #16]	; (b7d8 <bt_att_connected+0x2c>)
    b7c8:	f104 00a8 	add.w	r0, r4, #168	; 0xa8
    b7cc:	f01c fb9b 	bl	27f06 <k_delayed_work_init>
	list->head = NULL;
    b7d0:	2300      	movs	r3, #0
	list->tail = NULL;
    b7d2:	e9c4 3328 	strd	r3, r3, [r4, #160]	; 0xa0
}
    b7d6:	bd10      	pop	{r4, pc}
    b7d8:	0000c56d 	.word	0x0000c56d

0000b7dc <att_req_sent>:
{
    b7dc:	b538      	push	{r3, r4, r5, lr}
    b7de:	460d      	mov	r5, r1
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
    b7e0:	2104      	movs	r1, #4
{
    b7e2:	4604      	mov	r4, r0
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
    b7e4:	f017 f87f 	bl	228e6 <bt_l2cap_le_lookup_tx_cid>
	if (att->req) {
    b7e8:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
    b7ec:	b133      	cbz	r3, b7fc <att_req_sent+0x20>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    b7ee:	f100 01a8 	add.w	r1, r0, #168	; 0xa8
    b7f2:	f247 5230 	movw	r2, #30000	; 0x7530
    b7f6:	4804      	ldr	r0, [pc, #16]	; (b808 <att_req_sent+0x2c>)
    b7f8:	f013 fc32 	bl	1f060 <k_delayed_work_submit_to_queue>
	att_pdu_sent(conn, user_data);
    b7fc:	4629      	mov	r1, r5
    b7fe:	4620      	mov	r0, r4
}
    b800:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	att_pdu_sent(conn, user_data);
    b804:	f017 ba35 	b.w	22c72 <att_pdu_sent>
    b808:	20006090 	.word	0x20006090

0000b80c <att_chan_get>:
	if (conn->state != BT_CONN_CONNECTED) {
    b80c:	7b43      	ldrb	r3, [r0, #13]
    b80e:	2b06      	cmp	r3, #6
{
    b810:	b510      	push	{r4, lr}
	if (conn->state != BT_CONN_CONNECTED) {
    b812:	d00f      	beq.n	b834 <att_chan_get+0x28>
		BT_WARN("Not connected");
    b814:	2302      	movs	r3, #2
    b816:	f04f 0100 	mov.w	r1, #0
    b81a:	f363 0107 	bfi	r1, r3, #0, #8
    b81e:	4a1a      	ldr	r2, [pc, #104]	; (b888 <att_chan_get+0x7c>)
    b820:	4b1a      	ldr	r3, [pc, #104]	; (b88c <att_chan_get+0x80>)
    b822:	481b      	ldr	r0, [pc, #108]	; (b890 <att_chan_get+0x84>)
    b824:	1a9b      	subs	r3, r3, r2
    b826:	08db      	lsrs	r3, r3, #3
    b828:	f363 118f 	bfi	r1, r3, #6, #10
		BT_WARN("ATT context flagged as disconnected");
    b82c:	f015 fc05 	bl	2103a <log_0>
		return NULL;
    b830:	2400      	movs	r4, #0
    b832:	e012      	b.n	b85a <att_chan_get+0x4e>
	chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_ATT);
    b834:	2104      	movs	r1, #4
    b836:	f017 f861 	bl	228fc <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
    b83a:	4604      	mov	r4, r0
    b83c:	b978      	cbnz	r0, b85e <att_chan_get+0x52>
		BT_ERR("Unable to find ATT channel");
    b83e:	2301      	movs	r3, #1
    b840:	f04f 0100 	mov.w	r1, #0
    b844:	f363 0107 	bfi	r1, r3, #0, #8
    b848:	4a0f      	ldr	r2, [pc, #60]	; (b888 <att_chan_get+0x7c>)
    b84a:	4b10      	ldr	r3, [pc, #64]	; (b88c <att_chan_get+0x80>)
    b84c:	4811      	ldr	r0, [pc, #68]	; (b894 <att_chan_get+0x88>)
    b84e:	1a9b      	subs	r3, r3, r2
    b850:	08db      	lsrs	r3, r3, #3
    b852:	f363 118f 	bfi	r1, r3, #6, #10
    b856:	f015 fbf0 	bl	2103a <log_0>
}
    b85a:	4620      	mov	r0, r4
    b85c:	bd10      	pop	{r4, pc}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    b85e:	f3bf 8f5b 	dmb	ish
    b862:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
    b866:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(att->flags, ATT_DISCONNECTED)) {
    b86a:	075b      	lsls	r3, r3, #29
    b86c:	d5f5      	bpl.n	b85a <att_chan_get+0x4e>
		BT_WARN("ATT context flagged as disconnected");
    b86e:	2302      	movs	r3, #2
    b870:	f04f 0100 	mov.w	r1, #0
    b874:	f363 0107 	bfi	r1, r3, #0, #8
    b878:	4a03      	ldr	r2, [pc, #12]	; (b888 <att_chan_get+0x7c>)
    b87a:	4b04      	ldr	r3, [pc, #16]	; (b88c <att_chan_get+0x80>)
    b87c:	4806      	ldr	r0, [pc, #24]	; (b898 <att_chan_get+0x8c>)
    b87e:	1a9b      	subs	r3, r3, r2
    b880:	08db      	lsrs	r3, r3, #3
    b882:	f363 118f 	bfi	r1, r3, #6, #10
    b886:	e7d1      	b.n	b82c <att_chan_get+0x20>
    b888:	00028540 	.word	0x00028540
    b88c:	00028550 	.word	0x00028550
    b890:	00063821 	.word	0x00063821
    b894:	0006382f 	.word	0x0006382f
    b898:	0006384a 	.word	0x0006384a

0000b89c <prep_write_cb>:
{
    b89c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    b89e:	460c      	mov	r4, r1
    b8a0:	4606      	mov	r6, r0
	data->err = bt_gatt_check_perm(data->conn, attr,
    b8a2:	4601      	mov	r1, r0
    b8a4:	222a      	movs	r2, #42	; 0x2a
    b8a6:	6820      	ldr	r0, [r4, #0]
    b8a8:	f017 fe5b 	bl	23562 <bt_gatt_check_perm>
    b8ac:	4605      	mov	r5, r0
    b8ae:	7420      	strb	r0, [r4, #16]
	if (data->err) {
    b8b0:	2800      	cmp	r0, #0
    b8b2:	d12d      	bne.n	b910 <prep_write_cb+0x74>
	if (!(attr->perm & BT_GATT_PERM_PREPARE_WRITE)) {
    b8b4:	7cb3      	ldrb	r3, [r6, #18]
    b8b6:	065b      	lsls	r3, r3, #25
    b8b8:	d514      	bpl.n	b8e4 <prep_write_cb+0x48>
	write = attr->write(data->conn, attr, data->value, data->len,
    b8ba:	2301      	movs	r3, #1
    b8bc:	9301      	str	r3, [sp, #4]
    b8be:	89e3      	ldrh	r3, [r4, #14]
    b8c0:	9300      	str	r3, [sp, #0]
    b8c2:	68b7      	ldr	r7, [r6, #8]
    b8c4:	89a3      	ldrh	r3, [r4, #12]
    b8c6:	68a2      	ldr	r2, [r4, #8]
    b8c8:	6820      	ldr	r0, [r4, #0]
    b8ca:	4631      	mov	r1, r6
    b8cc:	47b8      	blx	r7
	if (write != 0) {
    b8ce:	b148      	cbz	r0, b8e4 <prep_write_cb+0x48>
	if (err < 0 && err >= -0xff) {
    b8d0:	f110 0fff 	cmn.w	r0, #255	; 0xff
		return -err;
    b8d4:	bf26      	itte	cs
    b8d6:	4240      	negcs	r0, r0
    b8d8:	b2c0      	uxtbcs	r0, r0
	return BT_ATT_ERR_UNLIKELY;
    b8da:	200e      	movcc	r0, #14
		data->err = err_to_att(write);
    b8dc:	7420      	strb	r0, [r4, #16]
}
    b8de:	4628      	mov	r0, r5
    b8e0:	b003      	add	sp, #12
    b8e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	data->buf = net_buf_alloc(&prep_pool, K_NO_WAIT);
    b8e4:	2100      	movs	r1, #0
    b8e6:	480b      	ldr	r0, [pc, #44]	; (b914 <prep_write_cb+0x78>)
    b8e8:	f019 fa42 	bl	24d70 <net_buf_alloc_fixed>
    b8ec:	6060      	str	r0, [r4, #4]
	if (!data->buf) {
    b8ee:	b910      	cbnz	r0, b8f6 <prep_write_cb+0x5a>
		data->err = BT_ATT_ERR_PREPARE_QUEUE_FULL;
    b8f0:	2309      	movs	r3, #9
    b8f2:	7423      	strb	r3, [r4, #16]
		return BT_GATT_ITER_STOP;
    b8f4:	e7f3      	b.n	b8de <prep_write_cb+0x42>
	attr_data->handle = attr->handle;
    b8f6:	8a33      	ldrh	r3, [r6, #16]
    b8f8:	8283      	strh	r3, [r0, #20]
	attr_data->offset = data->offset;
    b8fa:	89e3      	ldrh	r3, [r4, #14]
    b8fc:	82c3      	strh	r3, [r0, #22]
	net_buf_add_mem(data->buf, data->value, data->len);
    b8fe:	89a2      	ldrh	r2, [r4, #12]
    b900:	68a1      	ldr	r1, [r4, #8]
    b902:	3008      	adds	r0, #8
    b904:	f019 fa6e 	bl	24de4 <net_buf_simple_add_mem>
	data->err = 0U;
    b908:	2300      	movs	r3, #0
    b90a:	7423      	strb	r3, [r4, #16]
	return BT_GATT_ITER_CONTINUE;
    b90c:	2501      	movs	r5, #1
    b90e:	e7e6      	b.n	b8de <prep_write_cb+0x42>
		return BT_GATT_ITER_STOP;
    b910:	2500      	movs	r5, #0
    b912:	e7e4      	b.n	b8de <prep_write_cb+0x42>
    b914:	2000f104 	.word	0x2000f104

0000b918 <bt_att_create_pdu>:
{
    b918:	b570      	push	{r4, r5, r6, lr}
    b91a:	460e      	mov	r6, r1
    b91c:	4615      	mov	r5, r2
	att = att_chan_get(conn);
    b91e:	f7ff ff75 	bl	b80c <att_chan_get>
	if (!att) {
    b922:	4604      	mov	r4, r0
    b924:	b198      	cbz	r0, b94e <bt_att_create_pdu+0x36>
	if (len + sizeof(op) > att->chan.tx.mtu) {
    b926:	f8b0 1042 	ldrh.w	r1, [r0, #66]	; 0x42
    b92a:	1c6a      	adds	r2, r5, #1
    b92c:	428a      	cmp	r2, r1
    b92e:	d910      	bls.n	b952 <bt_att_create_pdu+0x3a>
		BT_WARN("ATT MTU exceeded, max %u, wanted %zu",
    b930:	2002      	movs	r0, #2
    b932:	f04f 0300 	mov.w	r3, #0
    b936:	f360 0307 	bfi	r3, r0, #0, #8
    b93a:	4c1a      	ldr	r4, [pc, #104]	; (b9a4 <bt_att_create_pdu+0x8c>)
    b93c:	481a      	ldr	r0, [pc, #104]	; (b9a8 <bt_att_create_pdu+0x90>)
    b93e:	1b00      	subs	r0, r0, r4
    b940:	08c0      	lsrs	r0, r0, #3
    b942:	f360 138f 	bfi	r3, r0, #6, #10
    b946:	4819      	ldr	r0, [pc, #100]	; (b9ac <bt_att_create_pdu+0x94>)
    b948:	f015 fb98 	bl	2107c <log_2>
		return NULL;
    b94c:	2400      	movs	r4, #0
}
    b94e:	4620      	mov	r0, r4
    b950:	bd70      	pop	{r4, r5, r6, pc}
	switch (att_op_get_type(op)) {
    b952:	4630      	mov	r0, r6
    b954:	f016 ffdd 	bl	22912 <att_op_get_type>
    b958:	2802      	cmp	r0, #2
    b95a:	d001      	beq.n	b960 <bt_att_create_pdu+0x48>
    b95c:	2804      	cmp	r0, #4
    b95e:	d117      	bne.n	b990 <bt_att_create_pdu+0x78>
		buf = bt_l2cap_create_pdu_timeout(NULL, 0, BT_ATT_TIMEOUT);
    b960:	f247 5230 	movw	r2, #30000	; 0x7530
		buf = bt_l2cap_create_pdu(NULL, 0);
    b964:	2100      	movs	r1, #0
    b966:	4608      	mov	r0, r1
    b968:	f016 ffa1 	bl	228ae <bt_l2cap_create_pdu_timeout>
    b96c:	4604      	mov	r4, r0
	if (!buf) {
    b96e:	b990      	cbnz	r0, b996 <bt_att_create_pdu+0x7e>
		BT_ERR("Unable to allocate buffer for op 0x%02x", op);
    b970:	2301      	movs	r3, #1
    b972:	f04f 0200 	mov.w	r2, #0
    b976:	f363 0207 	bfi	r2, r3, #0, #8
    b97a:	490a      	ldr	r1, [pc, #40]	; (b9a4 <bt_att_create_pdu+0x8c>)
    b97c:	4b0a      	ldr	r3, [pc, #40]	; (b9a8 <bt_att_create_pdu+0x90>)
    b97e:	480c      	ldr	r0, [pc, #48]	; (b9b0 <bt_att_create_pdu+0x98>)
    b980:	1a5b      	subs	r3, r3, r1
    b982:	08db      	lsrs	r3, r3, #3
    b984:	f363 128f 	bfi	r2, r3, #6, #10
    b988:	4631      	mov	r1, r6
    b98a:	f015 fb63 	bl	21054 <log_1>
		return NULL;
    b98e:	e7de      	b.n	b94e <bt_att_create_pdu+0x36>
		buf = bt_l2cap_create_pdu(NULL, 0);
    b990:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    b994:	e7e6      	b.n	b964 <bt_att_create_pdu+0x4c>
	hdr = net_buf_add(buf, sizeof(*hdr));
    b996:	2101      	movs	r1, #1
    b998:	3008      	adds	r0, #8
    b99a:	f019 fa1d 	bl	24dd8 <net_buf_simple_add>
	hdr->code = op;
    b99e:	7006      	strb	r6, [r0, #0]
	return buf;
    b9a0:	e7d5      	b.n	b94e <bt_att_create_pdu+0x36>
    b9a2:	bf00      	nop
    b9a4:	00028540 	.word	0x00028540
    b9a8:	00028550 	.word	0x00028550
    b9ac:	000638de 	.word	0x000638de
    b9b0:	00063746 	.word	0x00063746

0000b9b4 <att_indicate>:
{
    b9b4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct bt_conn *conn = att->chan.chan.conn;
    b9b6:	6804      	ldr	r4, [r0, #0]
	handle = net_buf_pull_le16(buf);
    b9b8:	f101 0008 	add.w	r0, r1, #8
{
    b9bc:	460d      	mov	r5, r1
	handle = net_buf_pull_le16(buf);
    b9be:	f019 fa45 	bl	24e4c <net_buf_simple_pull_le16>
	bt_gatt_notification(conn, handle, buf->data, buf->len);
    b9c2:	89ab      	ldrh	r3, [r5, #12]
    b9c4:	68aa      	ldr	r2, [r5, #8]
    b9c6:	4601      	mov	r1, r0
    b9c8:	4620      	mov	r0, r4
    b9ca:	f017 fed0 	bl	2376e <bt_gatt_notification>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_CONFIRM, 0);
    b9ce:	2200      	movs	r2, #0
    b9d0:	211e      	movs	r1, #30
    b9d2:	4620      	mov	r0, r4
    b9d4:	f7ff ffa0 	bl	b918 <bt_att_create_pdu>
	if (!buf) {
    b9d8:	4602      	mov	r2, r0
    b9da:	b130      	cbz	r0, b9ea <att_indicate+0x36>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, att_cfm_sent, NULL);
    b9dc:	2300      	movs	r3, #0
    b9de:	9300      	str	r3, [sp, #0]
    b9e0:	2104      	movs	r1, #4
    b9e2:	4b03      	ldr	r3, [pc, #12]	; (b9f0 <att_indicate+0x3c>)
    b9e4:	4620      	mov	r0, r4
    b9e6:	f016 ff65 	bl	228b4 <bt_l2cap_send_cb>
}
    b9ea:	2000      	movs	r0, #0
    b9ec:	b003      	add	sp, #12
    b9ee:	bd30      	pop	{r4, r5, pc}
    b9f0:	00022ccb 	.word	0x00022ccb

0000b9f4 <att_mtu_req>:
	mtu_client = sys_le16_to_cpu(req->mtu);
    b9f4:	688b      	ldr	r3, [r1, #8]
{
    b9f6:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	mtu_client = sys_le16_to_cpu(req->mtu);
    b9fa:	881d      	ldrh	r5, [r3, #0]
	if (mtu_client < BT_ATT_DEFAULT_LE_MTU) {
    b9fc:	2d16      	cmp	r5, #22
{
    b9fe:	4606      	mov	r6, r0
	if (mtu_client < BT_ATT_DEFAULT_LE_MTU) {
    ba00:	d921      	bls.n	ba46 <att_mtu_req+0x52>
	struct bt_conn *conn = att->chan.chan.conn;
    ba02:	f8d0 8000 	ldr.w	r8, [r0]
	pdu = bt_att_create_pdu(conn, BT_ATT_OP_MTU_RSP, sizeof(*rsp));
    ba06:	2202      	movs	r2, #2
    ba08:	2103      	movs	r1, #3
    ba0a:	4640      	mov	r0, r8
    ba0c:	f7ff ff84 	bl	b918 <bt_att_create_pdu>
	if (!pdu) {
    ba10:	4607      	mov	r7, r0
    ba12:	b1d0      	cbz	r0, ba4a <att_mtu_req+0x56>
	rsp = net_buf_add(pdu, sizeof(*rsp));
    ba14:	2102      	movs	r1, #2
    ba16:	3008      	adds	r0, #8
    ba18:	f019 f9de 	bl	24dd8 <net_buf_simple_add>
	rsp->mtu = sys_cpu_to_le16(mtu_server);
    ba1c:	2400      	movs	r4, #0
    ba1e:	2341      	movs	r3, #65	; 0x41
    ba20:	7003      	strb	r3, [r0, #0]
    ba22:	7044      	strb	r4, [r0, #1]
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, pdu, att_rsp_sent, NULL);
    ba24:	4b0a      	ldr	r3, [pc, #40]	; (ba50 <att_mtu_req+0x5c>)
    ba26:	9400      	str	r4, [sp, #0]
    ba28:	463a      	mov	r2, r7
    ba2a:	2104      	movs	r1, #4
    ba2c:	4640      	mov	r0, r8
    ba2e:	f016 ff41 	bl	228b4 <bt_l2cap_send_cb>
	att->chan.rx.mtu = MIN(mtu_client, mtu_server);
    ba32:	2d41      	cmp	r5, #65	; 0x41
    ba34:	bf28      	it	cs
    ba36:	2541      	movcs	r5, #65	; 0x41
    ba38:	86f5      	strh	r5, [r6, #54]	; 0x36
	att->chan.tx.mtu = att->chan.rx.mtu;
    ba3a:	f8a6 5042 	strh.w	r5, [r6, #66]	; 0x42
	return 0;
    ba3e:	4620      	mov	r0, r4
}
    ba40:	b002      	add	sp, #8
    ba42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_ATT_ERR_INVALID_PDU;
    ba46:	2004      	movs	r0, #4
    ba48:	e7fa      	b.n	ba40 <att_mtu_req+0x4c>
		return BT_ATT_ERR_UNLIKELY;
    ba4a:	200e      	movs	r0, #14
    ba4c:	e7f8      	b.n	ba40 <att_mtu_req+0x4c>
    ba4e:	bf00      	nop
    ba50:	00022cfd 	.word	0x00022cfd

0000ba54 <send_err_rsp.part.11>:
static void send_err_rsp(struct bt_conn *conn, u8_t req, u16_t handle,
    ba54:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    ba58:	4688      	mov	r8, r1
    ba5a:	4617      	mov	r7, r2
	buf = bt_att_create_pdu(conn, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
    ba5c:	2101      	movs	r1, #1
    ba5e:	2204      	movs	r2, #4
static void send_err_rsp(struct bt_conn *conn, u8_t req, u16_t handle,
    ba60:	4605      	mov	r5, r0
    ba62:	461e      	mov	r6, r3
	buf = bt_att_create_pdu(conn, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
    ba64:	f7ff ff58 	bl	b918 <bt_att_create_pdu>
	if (!buf) {
    ba68:	4604      	mov	r4, r0
    ba6a:	b180      	cbz	r0, ba8e <send_err_rsp.part.11+0x3a>
	rsp = net_buf_add(buf, sizeof(*rsp));
    ba6c:	2104      	movs	r1, #4
    ba6e:	3008      	adds	r0, #8
    ba70:	f019 f9b2 	bl	24dd8 <net_buf_simple_add>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, att_rsp_sent, NULL);
    ba74:	2300      	movs	r3, #0
	rsp->request = req;
    ba76:	f880 8000 	strb.w	r8, [r0]
	rsp->handle = sys_cpu_to_le16(handle);
    ba7a:	f8a0 7001 	strh.w	r7, [r0, #1]
	rsp->error = err;
    ba7e:	70c6      	strb	r6, [r0, #3]
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, att_rsp_sent, NULL);
    ba80:	4622      	mov	r2, r4
    ba82:	9300      	str	r3, [sp, #0]
    ba84:	2104      	movs	r1, #4
    ba86:	4b03      	ldr	r3, [pc, #12]	; (ba94 <send_err_rsp.part.11+0x40>)
    ba88:	4628      	mov	r0, r5
    ba8a:	f016 ff13 	bl	228b4 <bt_l2cap_send_cb>
}
    ba8e:	b002      	add	sp, #8
    ba90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ba94:	00022cfd 	.word	0x00022cfd

0000ba98 <bt_att_recv>:
{
    ba98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (buf->len < sizeof(*hdr)) {
    ba9a:	898b      	ldrh	r3, [r1, #12]
{
    ba9c:	4604      	mov	r4, r0
    ba9e:	460f      	mov	r7, r1
	if (buf->len < sizeof(*hdr)) {
    baa0:	b97b      	cbnz	r3, bac2 <bt_att_recv+0x2a>
		BT_ERR("Too small ATT PDU received");
    baa2:	2301      	movs	r3, #1
    baa4:	f04f 0100 	mov.w	r1, #0
    baa8:	f363 0107 	bfi	r1, r3, #0, #8
    baac:	4a51      	ldr	r2, [pc, #324]	; (bbf4 <bt_att_recv+0x15c>)
    baae:	4b52      	ldr	r3, [pc, #328]	; (bbf8 <bt_att_recv+0x160>)
    bab0:	4852      	ldr	r0, [pc, #328]	; (bbfc <bt_att_recv+0x164>)
    bab2:	1a9b      	subs	r3, r3, r2
    bab4:	08db      	lsrs	r3, r3, #3
    bab6:	f363 118f 	bfi	r1, r3, #6, #10
			BT_WARN("Ignoring unexpected indication");
    baba:	f015 fabe 	bl	2103a <log_0>
}
    babe:	2000      	movs	r0, #0
    bac0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    bac2:	2101      	movs	r1, #1
    bac4:	f107 0008 	add.w	r0, r7, #8
    bac8:	f019 f9b8 	bl	24e3c <net_buf_simple_pull_mem>
		if (hdr->code == handlers[i].op) {
    bacc:	4a4c      	ldr	r2, [pc, #304]	; (bc00 <bt_att_recv+0x168>)
    bace:	7801      	ldrb	r1, [r0, #0]
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    bad0:	4605      	mov	r5, r0
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
    bad2:	2300      	movs	r3, #0
    bad4:	4610      	mov	r0, r2
		if (hdr->code == handlers[i].op) {
    bad6:	f812 6033 	ldrb.w	r6, [r2, r3, lsl #3]
    bada:	428e      	cmp	r6, r1
    badc:	d122      	bne.n	bb24 <bt_att_recv+0x8c>
		if (handler->type == ATT_REQUEST &&
    bade:	00db      	lsls	r3, r3, #3
    bae0:	441a      	add	r2, r3
    bae2:	7896      	ldrb	r6, [r2, #2]
    bae4:	2e01      	cmp	r6, #1
    bae6:	d13c      	bne.n	bb62 <bt_att_recv+0xca>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    bae8:	f3bf 8f5b 	dmb	ish
    baec:	f104 0298 	add.w	r2, r4, #152	; 0x98
    baf0:	e852 1f00 	ldrex	r1, [r2]
    baf4:	f041 0c01 	orr.w	ip, r1, #1
    baf8:	e842 ce00 	strex	lr, ip, [r2]
    bafc:	f1be 0f00 	cmp.w	lr, #0
    bb00:	d1f6      	bne.n	baf0 <bt_att_recv+0x58>
    bb02:	f3bf 8f5b 	dmb	ish
    bb06:	07c9      	lsls	r1, r1, #31
    bb08:	d54b      	bpl.n	bba2 <bt_att_recv+0x10a>
			BT_WARN("Ignoring unexpected request");
    bb0a:	2302      	movs	r3, #2
    bb0c:	f04f 0100 	mov.w	r1, #0
    bb10:	f363 0107 	bfi	r1, r3, #0, #8
    bb14:	4a37      	ldr	r2, [pc, #220]	; (bbf4 <bt_att_recv+0x15c>)
    bb16:	4b38      	ldr	r3, [pc, #224]	; (bbf8 <bt_att_recv+0x160>)
    bb18:	483a      	ldr	r0, [pc, #232]	; (bc04 <bt_att_recv+0x16c>)
    bb1a:	1a9b      	subs	r3, r3, r2
    bb1c:	08db      	lsrs	r3, r3, #3
    bb1e:	f363 118f 	bfi	r1, r3, #6, #10
    bb22:	e7ca      	b.n	baba <bt_att_recv+0x22>
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
    bb24:	3301      	adds	r3, #1
    bb26:	2b1c      	cmp	r3, #28
    bb28:	d1d5      	bne.n	bad6 <bt_att_recv+0x3e>
		BT_WARN("Unhandled ATT code 0x%02x", hdr->code);
    bb2a:	2302      	movs	r3, #2
    bb2c:	f04f 0200 	mov.w	r2, #0
    bb30:	f363 0207 	bfi	r2, r3, #0, #8
    bb34:	482f      	ldr	r0, [pc, #188]	; (bbf4 <bt_att_recv+0x15c>)
    bb36:	4b30      	ldr	r3, [pc, #192]	; (bbf8 <bt_att_recv+0x160>)
    bb38:	1a1b      	subs	r3, r3, r0
    bb3a:	08db      	lsrs	r3, r3, #3
    bb3c:	4832      	ldr	r0, [pc, #200]	; (bc08 <bt_att_recv+0x170>)
    bb3e:	f363 128f 	bfi	r2, r3, #6, #10
    bb42:	f015 fa87 	bl	21054 <log_1>
		if (att_op_get_type(hdr->code) != ATT_COMMAND) {
    bb46:	7829      	ldrb	r1, [r5, #0]
    bb48:	4608      	mov	r0, r1
    bb4a:	f016 fee2 	bl	22912 <att_op_get_type>
    bb4e:	2800      	cmp	r0, #0
    bb50:	d0b5      	beq.n	babe <bt_att_recv+0x26>
	if (!req) {
    bb52:	2900      	cmp	r1, #0
    bb54:	d0b3      	beq.n	babe <bt_att_recv+0x26>
    bb56:	2306      	movs	r3, #6
    bb58:	2200      	movs	r2, #0
    bb5a:	6820      	ldr	r0, [r4, #0]
    bb5c:	f7ff ff7a 	bl	ba54 <send_err_rsp.part.11>
    bb60:	e7ad      	b.n	babe <bt_att_recv+0x26>
		} else if (handler->type == ATT_INDICATION &&
    bb62:	2e05      	cmp	r6, #5
    bb64:	d11d      	bne.n	bba2 <bt_att_recv+0x10a>
    bb66:	f3bf 8f5b 	dmb	ish
    bb6a:	f104 0298 	add.w	r2, r4, #152	; 0x98
    bb6e:	e852 1f00 	ldrex	r1, [r2]
    bb72:	f041 0c02 	orr.w	ip, r1, #2
    bb76:	e842 ce00 	strex	lr, ip, [r2]
    bb7a:	f1be 0f00 	cmp.w	lr, #0
    bb7e:	d1f6      	bne.n	bb6e <bt_att_recv+0xd6>
    bb80:	f3bf 8f5b 	dmb	ish
    bb84:	078a      	lsls	r2, r1, #30
    bb86:	d50c      	bpl.n	bba2 <bt_att_recv+0x10a>
			BT_WARN("Ignoring unexpected indication");
    bb88:	2302      	movs	r3, #2
    bb8a:	f04f 0100 	mov.w	r1, #0
    bb8e:	f363 0107 	bfi	r1, r3, #0, #8
    bb92:	4a18      	ldr	r2, [pc, #96]	; (bbf4 <bt_att_recv+0x15c>)
    bb94:	4b18      	ldr	r3, [pc, #96]	; (bbf8 <bt_att_recv+0x160>)
    bb96:	481d      	ldr	r0, [pc, #116]	; (bc0c <bt_att_recv+0x174>)
    bb98:	1a9b      	subs	r3, r3, r2
    bb9a:	08db      	lsrs	r3, r3, #3
    bb9c:	f363 118f 	bfi	r1, r3, #6, #10
    bba0:	e78b      	b.n	baba <bt_att_recv+0x22>
	if (buf->len < handler->expect_len) {
    bba2:	4403      	add	r3, r0
    bba4:	89b9      	ldrh	r1, [r7, #12]
    bba6:	785a      	ldrb	r2, [r3, #1]
    bba8:	428a      	cmp	r2, r1
    bbaa:	d913      	bls.n	bbd4 <bt_att_recv+0x13c>
		BT_ERR("Invalid len %u for code 0x%02x", buf->len, hdr->code);
    bbac:	2201      	movs	r2, #1
    bbae:	f04f 0300 	mov.w	r3, #0
    bbb2:	f362 0307 	bfi	r3, r2, #0, #8
    bbb6:	480f      	ldr	r0, [pc, #60]	; (bbf4 <bt_att_recv+0x15c>)
    bbb8:	4a0f      	ldr	r2, [pc, #60]	; (bbf8 <bt_att_recv+0x160>)
    bbba:	1a12      	subs	r2, r2, r0
    bbbc:	08d2      	lsrs	r2, r2, #3
    bbbe:	f362 138f 	bfi	r3, r2, #6, #10
    bbc2:	4813      	ldr	r0, [pc, #76]	; (bc10 <bt_att_recv+0x178>)
    bbc4:	782a      	ldrb	r2, [r5, #0]
    bbc6:	f015 fa59 	bl	2107c <log_2>
	if (handler->type == ATT_REQUEST && err) {
    bbca:	2e01      	cmp	r6, #1
    bbcc:	f47f af77 	bne.w	babe <bt_att_recv+0x26>
		err = BT_ATT_ERR_INVALID_PDU;
    bbd0:	2304      	movs	r3, #4
    bbd2:	e00a      	b.n	bbea <bt_att_recv+0x152>
		err = handler->func(att, buf);
    bbd4:	685b      	ldr	r3, [r3, #4]
    bbd6:	4639      	mov	r1, r7
    bbd8:	4620      	mov	r0, r4
    bbda:	4798      	blx	r3
	if (handler->type == ATT_REQUEST && err) {
    bbdc:	2e01      	cmp	r6, #1
		err = handler->func(att, buf);
    bbde:	4603      	mov	r3, r0
	if (handler->type == ATT_REQUEST && err) {
    bbe0:	f47f af6d 	bne.w	babe <bt_att_recv+0x26>
    bbe4:	2800      	cmp	r0, #0
    bbe6:	f43f af6a 	beq.w	babe <bt_att_recv+0x26>
		send_err_rsp(chan->conn, hdr->code, 0, err);
    bbea:	7829      	ldrb	r1, [r5, #0]
	if (!req) {
    bbec:	2900      	cmp	r1, #0
    bbee:	f43f af66 	beq.w	babe <bt_att_recv+0x26>
    bbf2:	e7b1      	b.n	bb58 <bt_att_recv+0xc0>
    bbf4:	00028540 	.word	0x00028540
    bbf8:	00028550 	.word	0x00028550
    bbfc:	00063910 	.word	0x00063910
    bc00:	00028f84 	.word	0x00028f84
    bc04:	0006392b 	.word	0x0006392b
    bc08:	00063985 	.word	0x00063985
    bc0c:	00063947 	.word	0x00063947
    bc10:	00063966 	.word	0x00063966

0000bc14 <att_write_rsp>:
{
    bc14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
    bc18:	460e      	mov	r6, r1
    bc1a:	3100      	adds	r1, #0
{
    bc1c:	b088      	sub	sp, #32
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
    bc1e:	bf18      	it	ne
    bc20:	2101      	movne	r1, #1
{
    bc22:	4605      	mov	r5, r0
    bc24:	4690      	mov	r8, r2
    bc26:	461f      	mov	r7, r3
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
    bc28:	f017 fdca 	bl	237c0 <bt_gatt_change_aware>
    bc2c:	2800      	cmp	r0, #0
    bc2e:	d04e      	beq.n	bcce <att_write_rsp+0xba>
	if (!handle) {
    bc30:	2f00      	cmp	r7, #0
    bc32:	d04e      	beq.n	bcd2 <att_write_rsp+0xbe>
	(void)memset(&data, 0, sizeof(data));
    bc34:	2218      	movs	r2, #24
    bc36:	2100      	movs	r1, #0
    bc38:	a802      	add	r0, sp, #8
    bc3a:	f7f5 fff8 	bl	1c2e <memset>
	if (rsp) {
    bc3e:	f1b8 0f00 	cmp.w	r8, #0
    bc42:	d124      	bne.n	bc8e <att_write_rsp+0x7a>
	data.offset = offset;
    bc44:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
    bc48:	f8ad 301a 	strh.w	r3, [sp, #26]
	data.value = value;
    bc4c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    bc4e:	9305      	str	r3, [sp, #20]
	data.len = len;
    bc50:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
    bc54:	f8ad 3018 	strh.w	r3, [sp, #24]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    bc58:	2301      	movs	r3, #1
    bc5a:	f88d 301c 	strb.w	r3, [sp, #28]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    bc5e:	4a1e      	ldr	r2, [pc, #120]	; (bcd8 <att_write_rsp+0xc4>)
	data.conn = conn;
    bc60:	9502      	str	r5, [sp, #8]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    bc62:	ab02      	add	r3, sp, #8
    bc64:	4639      	mov	r1, r7
    bc66:	4638      	mov	r0, r7
	data.req = req;
    bc68:	f88d 6010 	strb.w	r6, [sp, #16]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    bc6c:	f016 fead 	bl	229ca <bt_gatt_foreach_attr>
	if (data.err) {
    bc70:	f89d 401c 	ldrb.w	r4, [sp, #28]
    bc74:	b30c      	cbz	r4, bcba <att_write_rsp+0xa6>
		if (rsp) {
    bc76:	f1b8 0f00 	cmp.w	r8, #0
    bc7a:	d019      	beq.n	bcb0 <att_write_rsp+0x9c>
			net_buf_unref(data.buf);
    bc7c:	9803      	ldr	r0, [sp, #12]
    bc7e:	f00d f9ed 	bl	1905c <net_buf_unref>
	if (!req) {
    bc82:	b976      	cbnz	r6, bca2 <att_write_rsp+0x8e>
		return req == BT_ATT_OP_EXEC_WRITE_REQ ? data.err : 0;
    bc84:	2400      	movs	r4, #0
}
    bc86:	4620      	mov	r0, r4
    bc88:	b008      	add	sp, #32
    bc8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		data.buf = bt_att_create_pdu(conn, rsp, 0);
    bc8e:	2200      	movs	r2, #0
    bc90:	4641      	mov	r1, r8
    bc92:	4628      	mov	r0, r5
    bc94:	f7ff fe40 	bl	b918 <bt_att_create_pdu>
    bc98:	9003      	str	r0, [sp, #12]
		if (!data.buf) {
    bc9a:	2800      	cmp	r0, #0
    bc9c:	d1d2      	bne.n	bc44 <att_write_rsp+0x30>
			return BT_ATT_ERR_UNLIKELY;
    bc9e:	240e      	movs	r4, #14
    bca0:	e7f1      	b.n	bc86 <att_write_rsp+0x72>
    bca2:	f89d 301c 	ldrb.w	r3, [sp, #28]
    bca6:	463a      	mov	r2, r7
    bca8:	4631      	mov	r1, r6
    bcaa:	4628      	mov	r0, r5
    bcac:	f7ff fed2 	bl	ba54 <send_err_rsp.part.11>
		return req == BT_ATT_OP_EXEC_WRITE_REQ ? data.err : 0;
    bcb0:	2e18      	cmp	r6, #24
    bcb2:	d1e7      	bne.n	bc84 <att_write_rsp+0x70>
    bcb4:	f89d 401c 	ldrb.w	r4, [sp, #28]
    bcb8:	e7e5      	b.n	bc86 <att_write_rsp+0x72>
	if (data.buf) {
    bcba:	9a03      	ldr	r2, [sp, #12]
    bcbc:	2a00      	cmp	r2, #0
    bcbe:	d0e1      	beq.n	bc84 <att_write_rsp+0x70>
		(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf,
    bcc0:	9400      	str	r4, [sp, #0]
    bcc2:	4b06      	ldr	r3, [pc, #24]	; (bcdc <att_write_rsp+0xc8>)
    bcc4:	2104      	movs	r1, #4
    bcc6:	4628      	mov	r0, r5
    bcc8:	f016 fdf4 	bl	228b4 <bt_l2cap_send_cb>
    bccc:	e7db      	b.n	bc86 <att_write_rsp+0x72>
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
    bcce:	2412      	movs	r4, #18
    bcd0:	e7d9      	b.n	bc86 <att_write_rsp+0x72>
		return BT_ATT_ERR_INVALID_HANDLE;
    bcd2:	2401      	movs	r4, #1
    bcd4:	e7d7      	b.n	bc86 <att_write_rsp+0x72>
    bcd6:	bf00      	nop
    bcd8:	00022d2f 	.word	0x00022d2f
    bcdc:	00022cfd 	.word	0x00022cfd

0000bce0 <att_signed_write_cmd>:
{
    bce0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	handle = sys_le16_to_cpu(req->handle);
    bce4:	460c      	mov	r4, r1
	struct bt_conn *conn = att->chan.chan.conn;
    bce6:	6807      	ldr	r7, [r0, #0]
	handle = sys_le16_to_cpu(req->handle);
    bce8:	f854 3f08 	ldr.w	r3, [r4, #8]!
{
    bcec:	460d      	mov	r5, r1
	net_buf_push(buf, sizeof(struct bt_att_hdr));
    bcee:	4620      	mov	r0, r4
    bcf0:	2101      	movs	r1, #1
	handle = sys_le16_to_cpu(req->handle);
    bcf2:	f8b3 8000 	ldrh.w	r8, [r3]
	net_buf_push(buf, sizeof(struct bt_att_hdr));
    bcf6:	f019 f891 	bl	24e1c <net_buf_simple_push>
	err = bt_smp_sign_verify(conn, buf);
    bcfa:	4629      	mov	r1, r5
    bcfc:	4638      	mov	r0, r7
    bcfe:	f003 fff1 	bl	fce4 <bt_smp_sign_verify>
	if (err) {
    bd02:	4606      	mov	r6, r0
    bd04:	b188      	cbz	r0, bd2a <att_signed_write_cmd+0x4a>
		BT_ERR("Error verifying data");
    bd06:	2301      	movs	r3, #1
    bd08:	f04f 0100 	mov.w	r1, #0
    bd0c:	f363 0107 	bfi	r1, r3, #0, #8
    bd10:	4a11      	ldr	r2, [pc, #68]	; (bd58 <att_signed_write_cmd+0x78>)
    bd12:	4b12      	ldr	r3, [pc, #72]	; (bd5c <att_signed_write_cmd+0x7c>)
    bd14:	4812      	ldr	r0, [pc, #72]	; (bd60 <att_signed_write_cmd+0x80>)
    bd16:	1a9b      	subs	r3, r3, r2
    bd18:	08db      	lsrs	r3, r3, #3
    bd1a:	f363 118f 	bfi	r1, r3, #6, #10
    bd1e:	f015 f98c 	bl	2103a <log_0>
		return 0;
    bd22:	2000      	movs	r0, #0
}
    bd24:	b004      	add	sp, #16
    bd26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	net_buf_pull(buf, sizeof(struct bt_att_hdr));
    bd2a:	2101      	movs	r1, #1
    bd2c:	4620      	mov	r0, r4
    bd2e:	f019 f87d 	bl	24e2c <net_buf_simple_pull>
	net_buf_pull(buf, sizeof(*req));
    bd32:	2102      	movs	r1, #2
    bd34:	4620      	mov	r0, r4
    bd36:	f019 f879 	bl	24e2c <net_buf_simple_pull>
	return att_write_rsp(conn, 0, 0, handle, 0, buf->data,
    bd3a:	89ab      	ldrh	r3, [r5, #12]
    bd3c:	3b0c      	subs	r3, #12
    bd3e:	b29b      	uxth	r3, r3
    bd40:	9302      	str	r3, [sp, #8]
    bd42:	68ab      	ldr	r3, [r5, #8]
    bd44:	4632      	mov	r2, r6
    bd46:	e9cd 6300 	strd	r6, r3, [sp]
    bd4a:	4631      	mov	r1, r6
    bd4c:	4643      	mov	r3, r8
    bd4e:	4638      	mov	r0, r7
    bd50:	f7ff ff60 	bl	bc14 <att_write_rsp>
    bd54:	e7e6      	b.n	bd24 <att_signed_write_cmd+0x44>
    bd56:	bf00      	nop
    bd58:	00028540 	.word	0x00028540
    bd5c:	00028550 	.word	0x00028550
    bd60:	00063898 	.word	0x00063898

0000bd64 <att_exec_write_req>:
{
    bd64:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	return att_exec_write_rsp(att, req->flags);
    bd68:	688b      	ldr	r3, [r1, #8]
	struct bt_conn *conn = att->chan.chan.conn;
    bd6a:	4607      	mov	r7, r0
	return att_exec_write_rsp(att, req->flags);
    bd6c:	f893 8000 	ldrb.w	r8, [r3]
	struct bt_conn *conn = att->chan.chan.conn;
    bd70:	f857 6bf4 	ldr.w	r6, [r7], #244
	u8_t err = 0U;
    bd74:	2400      	movs	r4, #0
	while ((buf = net_buf_get(&att->prep_queue, K_NO_WAIT))) {
    bd76:	2100      	movs	r1, #0
    bd78:	4638      	mov	r0, r7
    bd7a:	f018 ffff 	bl	24d7c <net_buf_get>
    bd7e:	4605      	mov	r5, r0
    bd80:	b988      	cbnz	r0, bda6 <att_exec_write_req+0x42>
	if (err) {
    bd82:	bb64      	cbnz	r4, bdde <att_exec_write_req+0x7a>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_EXEC_WRITE_RSP, 0);
    bd84:	4622      	mov	r2, r4
    bd86:	2119      	movs	r1, #25
    bd88:	4630      	mov	r0, r6
    bd8a:	f7ff fdc5 	bl	b918 <bt_att_create_pdu>
	if (!buf) {
    bd8e:	4602      	mov	r2, r0
    bd90:	b338      	cbz	r0, bde2 <att_exec_write_req+0x7e>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, att_rsp_sent, NULL);
    bd92:	9400      	str	r4, [sp, #0]
    bd94:	4b14      	ldr	r3, [pc, #80]	; (bde8 <att_exec_write_req+0x84>)
    bd96:	2104      	movs	r1, #4
    bd98:	4630      	mov	r0, r6
    bd9a:	f016 fd8b 	bl	228b4 <bt_l2cap_send_cb>
}
    bd9e:	4620      	mov	r0, r4
    bda0:	b004      	add	sp, #16
    bda2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!err && flags == BT_ATT_FLAG_EXEC) {
    bda6:	b9b4      	cbnz	r4, bdd6 <att_exec_write_req+0x72>
    bda8:	f1b8 0f01 	cmp.w	r8, #1
    bdac:	d113      	bne.n	bdd6 <att_exec_write_req+0x72>
			err = att_write_rsp(conn, BT_ATT_OP_EXEC_WRITE_REQ, 0,
    bdae:	89aa      	ldrh	r2, [r5, #12]
    bdb0:	8aab      	ldrh	r3, [r5, #20]
    bdb2:	9202      	str	r2, [sp, #8]
    bdb4:	68aa      	ldr	r2, [r5, #8]
    bdb6:	9201      	str	r2, [sp, #4]
    bdb8:	8aea      	ldrh	r2, [r5, #22]
    bdba:	9200      	str	r2, [sp, #0]
    bdbc:	2118      	movs	r1, #24
    bdbe:	4622      	mov	r2, r4
    bdc0:	4630      	mov	r0, r6
    bdc2:	f7ff ff27 	bl	bc14 <att_write_rsp>
			if (err) {
    bdc6:	4604      	mov	r4, r0
    bdc8:	b128      	cbz	r0, bdd6 <att_exec_write_req+0x72>
	if (!req) {
    bdca:	4603      	mov	r3, r0
    bdcc:	8aaa      	ldrh	r2, [r5, #20]
    bdce:	2118      	movs	r1, #24
    bdd0:	4630      	mov	r0, r6
    bdd2:	f7ff fe3f 	bl	ba54 <send_err_rsp.part.11>
		net_buf_unref(buf);
    bdd6:	4628      	mov	r0, r5
    bdd8:	f00d f940 	bl	1905c <net_buf_unref>
    bddc:	e7cb      	b.n	bd76 <att_exec_write_req+0x12>
		return 0;
    bdde:	4604      	mov	r4, r0
    bde0:	e7dd      	b.n	bd9e <att_exec_write_req+0x3a>
		return BT_ATT_ERR_UNLIKELY;
    bde2:	240e      	movs	r4, #14
    bde4:	e7db      	b.n	bd9e <att_exec_write_req+0x3a>
    bde6:	bf00      	nop
    bde8:	00022cfd 	.word	0x00022cfd

0000bdec <att_prepare_write_req>:
{
    bdec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bdf0:	460c      	mov	r4, r1
    bdf2:	b089      	sub	sp, #36	; 0x24
    bdf4:	4683      	mov	fp, r0
	req = net_buf_pull_mem(buf, sizeof(*req));
    bdf6:	2104      	movs	r1, #4
    bdf8:	f104 0008 	add.w	r0, r4, #8
    bdfc:	f019 f81e 	bl	24e3c <net_buf_simple_pull_mem>
	struct bt_conn *conn = att->chan.chan.conn;
    be00:	f8db 5000 	ldr.w	r5, [fp]
	handle = sys_le16_to_cpu(req->handle);
    be04:	f8b0 a000 	ldrh.w	sl, [r0]
	offset = sys_le16_to_cpu(req->offset);
    be08:	f8b0 9002 	ldrh.w	r9, [r0, #2]
	return att_prep_write_rsp(att, handle, offset, buf->data, buf->len);
    be0c:	f8d4 8008 	ldr.w	r8, [r4, #8]
    be10:	89a7      	ldrh	r7, [r4, #12]
	if (!bt_gatt_change_aware(conn, true)) {
    be12:	2101      	movs	r1, #1
    be14:	4628      	mov	r0, r5
	handle = sys_le16_to_cpu(req->handle);
    be16:	fa1f f68a 	uxth.w	r6, sl
	if (!bt_gatt_change_aware(conn, true)) {
    be1a:	f017 fcd1 	bl	237c0 <bt_gatt_change_aware>
    be1e:	2800      	cmp	r0, #0
    be20:	d04c      	beq.n	bebc <att_prepare_write_req+0xd0>
	if (!handle) {
    be22:	2e00      	cmp	r6, #0
    be24:	d04c      	beq.n	bec0 <att_prepare_write_req+0xd4>
	(void)memset(&data, 0, sizeof(data));
    be26:	2210      	movs	r2, #16
    be28:	2100      	movs	r1, #0
    be2a:	eb0d 0002 	add.w	r0, sp, r2
    be2e:	f7f5 fefe 	bl	1c2e <memset>
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    be32:	2301      	movs	r3, #1
    be34:	f88d 301c 	strb.w	r3, [sp, #28]
	bt_gatt_foreach_attr(handle, handle, prep_write_cb, &data);
    be38:	4a23      	ldr	r2, [pc, #140]	; (bec8 <att_prepare_write_req+0xdc>)
	data.conn = conn;
    be3a:	9503      	str	r5, [sp, #12]
	bt_gatt_foreach_attr(handle, handle, prep_write_cb, &data);
    be3c:	ab03      	add	r3, sp, #12
    be3e:	4631      	mov	r1, r6
    be40:	4630      	mov	r0, r6
	data.offset = offset;
    be42:	f8ad 901a 	strh.w	r9, [sp, #26]
	data.value = value;
    be46:	f8cd 8014 	str.w	r8, [sp, #20]
	data.len = len;
    be4a:	f8ad 7018 	strh.w	r7, [sp, #24]
	bt_gatt_foreach_attr(handle, handle, prep_write_cb, &data);
    be4e:	f016 fdbc 	bl	229ca <bt_gatt_foreach_attr>
	if (data.err) {
    be52:	f89d 401c 	ldrb.w	r4, [sp, #28]
    be56:	b154      	cbz	r4, be6e <att_prepare_write_req+0x82>
	if (!req) {
    be58:	4623      	mov	r3, r4
    be5a:	4632      	mov	r2, r6
    be5c:	2116      	movs	r1, #22
    be5e:	4628      	mov	r0, r5
    be60:	f7ff fdf8 	bl	ba54 <send_err_rsp.part.11>
		return 0;
    be64:	2400      	movs	r4, #0
}
    be66:	4620      	mov	r0, r4
    be68:	b009      	add	sp, #36	; 0x24
    be6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	net_buf_put(&att->prep_queue, data.buf);
    be6e:	9904      	ldr	r1, [sp, #16]
    be70:	f10b 00f4 	add.w	r0, fp, #244	; 0xf4
    be74:	f018 ff9f 	bl	24db6 <net_buf_put>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_PREPARE_WRITE_RSP, 0);
    be78:	4622      	mov	r2, r4
    be7a:	2117      	movs	r1, #23
    be7c:	4628      	mov	r0, r5
    be7e:	f7ff fd4b 	bl	b918 <bt_att_create_pdu>
    be82:	9004      	str	r0, [sp, #16]
	if (!data.buf) {
    be84:	b1f0      	cbz	r0, bec4 <att_prepare_write_req+0xd8>
	rsp = net_buf_add(data.buf, sizeof(*rsp));
    be86:	2104      	movs	r1, #4
    be88:	3008      	adds	r0, #8
    be8a:	f018 ffa5 	bl	24dd8 <net_buf_simple_add>
    be8e:	4606      	mov	r6, r0
	rsp->handle = sys_cpu_to_le16(handle);
    be90:	f8a0 a000 	strh.w	sl, [r0]
	rsp->offset = sys_cpu_to_le16(offset);
    be94:	f8a0 9002 	strh.w	r9, [r0, #2]
	net_buf_add(data.buf, len);
    be98:	9804      	ldr	r0, [sp, #16]
    be9a:	4639      	mov	r1, r7
    be9c:	3008      	adds	r0, #8
    be9e:	f018 ff9b 	bl	24dd8 <net_buf_simple_add>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    bea2:	463a      	mov	r2, r7
    bea4:	4641      	mov	r1, r8
    bea6:	1d30      	adds	r0, r6, #4
    bea8:	f7f5 fea0 	bl	1bec <memcpy>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    beac:	9400      	str	r4, [sp, #0]
    beae:	4b07      	ldr	r3, [pc, #28]	; (becc <att_prepare_write_req+0xe0>)
    beb0:	9a04      	ldr	r2, [sp, #16]
    beb2:	2104      	movs	r1, #4
    beb4:	4628      	mov	r0, r5
    beb6:	f016 fcfd 	bl	228b4 <bt_l2cap_send_cb>
	return 0;
    beba:	e7d4      	b.n	be66 <att_prepare_write_req+0x7a>
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
    bebc:	2412      	movs	r4, #18
    bebe:	e7d2      	b.n	be66 <att_prepare_write_req+0x7a>
		return BT_ATT_ERR_INVALID_HANDLE;
    bec0:	2401      	movs	r4, #1
    bec2:	e7d0      	b.n	be66 <att_prepare_write_req+0x7a>
		return BT_ATT_ERR_UNLIKELY;
    bec4:	240e      	movs	r4, #14
    bec6:	e7ce      	b.n	be66 <att_prepare_write_req+0x7a>
    bec8:	0000b89d 	.word	0x0000b89d
    becc:	00022cfd 	.word	0x00022cfd

0000bed0 <att_read_group_req>:
{
    bed0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u8_t uuid_len = buf->len - sizeof(*req);
    bed4:	7b0c      	ldrb	r4, [r1, #12]
    bed6:	3c04      	subs	r4, #4
    bed8:	b2e4      	uxtb	r4, r4
	if (uuid_len != 2 && uuid_len != 16) {
    beda:	2c02      	cmp	r4, #2
{
    bedc:	4680      	mov	r8, r0
    bede:	b08f      	sub	sp, #60	; 0x3c
    bee0:	4608      	mov	r0, r1
	if (uuid_len != 2 && uuid_len != 16) {
    bee2:	d001      	beq.n	bee8 <att_read_group_req+0x18>
    bee4:	2c10      	cmp	r4, #16
    bee6:	d16e      	bne.n	bfc6 <att_read_group_req+0xf6>
	req = net_buf_pull_mem(buf, sizeof(*req));
    bee8:	2104      	movs	r1, #4
    beea:	3008      	adds	r0, #8
	struct bt_conn *conn = att->chan.chan.conn;
    beec:	f8d8 9000 	ldr.w	r9, [r8]
	req = net_buf_pull_mem(buf, sizeof(*req));
    bef0:	f018 ffa4 	bl	24e3c <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    bef4:	ae04      	add	r6, sp, #16
	start_handle = sys_le16_to_cpu(req->start_handle);
    bef6:	8805      	ldrh	r5, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
    bef8:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    befa:	1d01      	adds	r1, r0, #4
    befc:	4622      	mov	r2, r4
    befe:	4630      	mov	r0, r6
    bf00:	f016 fa37 	bl	22372 <bt_uuid_create>
    bf04:	2800      	cmp	r0, #0
    bf06:	d060      	beq.n	bfca <att_read_group_req+0xfa>
	if (!start || !end) {
    bf08:	2d00      	cmp	r5, #0
    bf0a:	d036      	beq.n	bf7a <att_read_group_req+0xaa>
    bf0c:	2400      	movs	r4, #0
    bf0e:	b39f      	cbz	r7, bf78 <att_read_group_req+0xa8>
	if (start > end) {
    bf10:	42bd      	cmp	r5, r7
    bf12:	d832      	bhi.n	bf7a <att_read_group_req+0xaa>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
    bf14:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    bf18:	a902      	add	r1, sp, #8
    bf1a:	4630      	mov	r0, r6
    bf1c:	f88d 4008 	strb.w	r4, [sp, #8]
    bf20:	f8ad 300a 	strh.w	r3, [sp, #10]
    bf24:	f016 f9fb 	bl	2231e <bt_uuid_cmp>
    bf28:	bb90      	cbnz	r0, bf90 <att_read_group_req+0xc0>
	struct bt_conn *conn = att->chan.chan.conn;
    bf2a:	f8d8 9000 	ldr.w	r9, [r8]
	(void)memset(&data, 0, sizeof(data));
    bf2e:	2214      	movs	r2, #20
    bf30:	2100      	movs	r1, #0
    bf32:	a809      	add	r0, sp, #36	; 0x24
    bf34:	f7f5 fe7b 	bl	1c2e <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_RSP,
    bf38:	2201      	movs	r2, #1
    bf3a:	2111      	movs	r1, #17
    bf3c:	4648      	mov	r0, r9
    bf3e:	f7ff fceb 	bl	b918 <bt_att_create_pdu>
    bf42:	900b      	str	r0, [sp, #44]	; 0x2c
	if (!data.buf) {
    bf44:	2800      	cmp	r0, #0
    bf46:	d040      	beq.n	bfca <att_read_group_req+0xfa>
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    bf48:	2101      	movs	r1, #1
    bf4a:	3008      	adds	r0, #8
	data.uuid = uuid;
    bf4c:	e9cd 8609 	strd	r8, r6, [sp, #36]	; 0x24
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    bf50:	f018 ff42 	bl	24dd8 <net_buf_simple_add>
	data.rsp->len = 0U;
    bf54:	2600      	movs	r6, #0
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    bf56:	900c      	str	r0, [sp, #48]	; 0x30
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
    bf58:	ab09      	add	r3, sp, #36	; 0x24
	data.rsp->len = 0U;
    bf5a:	7006      	strb	r6, [r0, #0]
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
    bf5c:	4a1c      	ldr	r2, [pc, #112]	; (bfd0 <att_read_group_req+0x100>)
	data.group = NULL;
    bf5e:	960d      	str	r6, [sp, #52]	; 0x34
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
    bf60:	4639      	mov	r1, r7
    bf62:	4628      	mov	r0, r5
    bf64:	f016 fd31 	bl	229ca <bt_gatt_foreach_attr>
	if (!data.rsp->len) {
    bf68:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    bf6a:	781c      	ldrb	r4, [r3, #0]
    bf6c:	bb1c      	cbnz	r4, bfb6 <att_read_group_req+0xe6>
		net_buf_unref(data.buf);
    bf6e:	980b      	ldr	r0, [sp, #44]	; 0x2c
    bf70:	f00d f874 	bl	1905c <net_buf_unref>
	if (!req) {
    bf74:	230a      	movs	r3, #10
    bf76:	e018      	b.n	bfaa <att_read_group_req+0xda>
			*err = 0U;
    bf78:	463d      	mov	r5, r7
	if (!req) {
    bf7a:	2301      	movs	r3, #1
    bf7c:	462a      	mov	r2, r5
    bf7e:	2110      	movs	r1, #16
    bf80:	4648      	mov	r0, r9
    bf82:	f7ff fd67 	bl	ba54 <send_err_rsp.part.11>
		return 0;
    bf86:	2400      	movs	r4, #0
}
    bf88:	4620      	mov	r0, r4
    bf8a:	b00f      	add	sp, #60	; 0x3c
    bf8c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	    bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY)) {
    bf90:	f642 0301 	movw	r3, #10241	; 0x2801
    bf94:	a903      	add	r1, sp, #12
    bf96:	4630      	mov	r0, r6
    bf98:	f88d 400c 	strb.w	r4, [sp, #12]
    bf9c:	f8ad 300e 	strh.w	r3, [sp, #14]
    bfa0:	f016 f9bd 	bl	2231e <bt_uuid_cmp>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
    bfa4:	2800      	cmp	r0, #0
    bfa6:	d0c0      	beq.n	bf2a <att_read_group_req+0x5a>
	if (!req) {
    bfa8:	2310      	movs	r3, #16
    bfaa:	462a      	mov	r2, r5
    bfac:	2110      	movs	r1, #16
    bfae:	4648      	mov	r0, r9
    bfb0:	f7ff fd50 	bl	ba54 <send_err_rsp.part.11>
		return 0;
    bfb4:	e7e8      	b.n	bf88 <att_read_group_req+0xb8>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    bfb6:	9600      	str	r6, [sp, #0]
    bfb8:	4b06      	ldr	r3, [pc, #24]	; (bfd4 <att_read_group_req+0x104>)
    bfba:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    bfbc:	2104      	movs	r1, #4
    bfbe:	4648      	mov	r0, r9
    bfc0:	f016 fc78 	bl	228b4 <bt_l2cap_send_cb>
	return 0;
    bfc4:	e7df      	b.n	bf86 <att_read_group_req+0xb6>
		return BT_ATT_ERR_INVALID_PDU;
    bfc6:	2404      	movs	r4, #4
    bfc8:	e7de      	b.n	bf88 <att_read_group_req+0xb8>
		return BT_ATT_ERR_UNLIKELY;
    bfca:	240e      	movs	r4, #14
    bfcc:	e7dc      	b.n	bf88 <att_read_group_req+0xb8>
    bfce:	bf00      	nop
    bfd0:	000229e1 	.word	0x000229e1
    bfd4:	00022cfd 	.word	0x00022cfd

0000bfd8 <att_read_mult_req>:
{
    bfd8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct bt_conn *conn = att->chan.chan.conn;
    bfdc:	6805      	ldr	r5, [r0, #0]
{
    bfde:	b089      	sub	sp, #36	; 0x24
	(void)memset(&data, 0, sizeof(data));
    bfe0:	2214      	movs	r2, #20
{
    bfe2:	4606      	mov	r6, r0
    bfe4:	460c      	mov	r4, r1
	(void)memset(&data, 0, sizeof(data));
    bfe6:	a803      	add	r0, sp, #12
    bfe8:	2100      	movs	r1, #0
    bfea:	f7f5 fe20 	bl	1c2e <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_RSP, 0);
    bfee:	2200      	movs	r2, #0
    bff0:	210f      	movs	r1, #15
    bff2:	4628      	mov	r0, r5
    bff4:	f7ff fc90 	bl	b918 <bt_att_create_pdu>
    bff8:	9005      	str	r0, [sp, #20]
	if (!data.buf) {
    bffa:	b378      	cbz	r0, c05c <att_read_mult_req+0x84>
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    bffc:	f8df 9064 	ldr.w	r9, [pc, #100]	; c064 <att_read_mult_req+0x8c>
	data.att = att;
    c000:	9603      	str	r6, [sp, #12]
		handle = net_buf_pull_le16(buf);
    c002:	f104 0708 	add.w	r7, r4, #8
		data.err = BT_ATT_ERR_INVALID_HANDLE;
    c006:	f04f 0801 	mov.w	r8, #1
	while (buf->len >= sizeof(u16_t)) {
    c00a:	89a3      	ldrh	r3, [r4, #12]
    c00c:	2b01      	cmp	r3, #1
    c00e:	d808      	bhi.n	c022 <att_read_mult_req+0x4a>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    c010:	2400      	movs	r4, #0
    c012:	9400      	str	r4, [sp, #0]
    c014:	4b12      	ldr	r3, [pc, #72]	; (c060 <att_read_mult_req+0x88>)
    c016:	9a05      	ldr	r2, [sp, #20]
    c018:	2104      	movs	r1, #4
    c01a:	4628      	mov	r0, r5
    c01c:	f016 fc4a 	bl	228b4 <bt_l2cap_send_cb>
	return 0;
    c020:	e018      	b.n	c054 <att_read_mult_req+0x7c>
		handle = net_buf_pull_le16(buf);
    c022:	4638      	mov	r0, r7
    c024:	f018 ff12 	bl	24e4c <net_buf_simple_pull_le16>
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    c028:	ab03      	add	r3, sp, #12
    c02a:	464a      	mov	r2, r9
    c02c:	4601      	mov	r1, r0
		handle = net_buf_pull_le16(buf);
    c02e:	4606      	mov	r6, r0
		data.err = BT_ATT_ERR_INVALID_HANDLE;
    c030:	f88d 801c 	strb.w	r8, [sp, #28]
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    c034:	f016 fcc9 	bl	229ca <bt_gatt_foreach_attr>
		if (data.err) {
    c038:	f89d 301c 	ldrb.w	r3, [sp, #28]
    c03c:	2b00      	cmp	r3, #0
    c03e:	d0e4      	beq.n	c00a <att_read_mult_req+0x32>
			net_buf_unref(data.buf);
    c040:	9805      	ldr	r0, [sp, #20]
    c042:	f00d f80b 	bl	1905c <net_buf_unref>
	if (!req) {
    c046:	f89d 301c 	ldrb.w	r3, [sp, #28]
    c04a:	4632      	mov	r2, r6
    c04c:	210e      	movs	r1, #14
    c04e:	4628      	mov	r0, r5
    c050:	f7ff fd00 	bl	ba54 <send_err_rsp.part.11>
			return 0;
    c054:	2000      	movs	r0, #0
}
    c056:	b009      	add	sp, #36	; 0x24
    c058:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return BT_ATT_ERR_UNLIKELY;
    c05c:	200e      	movs	r0, #14
    c05e:	e7fa      	b.n	c056 <att_read_mult_req+0x7e>
    c060:	00022cfd 	.word	0x00022cfd
    c064:	00022d8b 	.word	0x00022d8b

0000c068 <att_read_rsp>:
{
    c068:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct bt_conn *conn = att->chan.chan.conn;
    c06c:	6805      	ldr	r5, [r0, #0]
{
    c06e:	b088      	sub	sp, #32
    c070:	4604      	mov	r4, r0
    c072:	460f      	mov	r7, r1
	if (!bt_gatt_change_aware(conn, true)) {
    c074:	4628      	mov	r0, r5
    c076:	2101      	movs	r1, #1
{
    c078:	4690      	mov	r8, r2
    c07a:	461e      	mov	r6, r3
	if (!bt_gatt_change_aware(conn, true)) {
    c07c:	f017 fba0 	bl	237c0 <bt_gatt_change_aware>
    c080:	b3a0      	cbz	r0, c0ec <att_read_rsp+0x84>
	if (!handle) {
    c082:	b3ae      	cbz	r6, c0f0 <att_read_rsp+0x88>
	(void)memset(&data, 0, sizeof(data));
    c084:	2214      	movs	r2, #20
    c086:	2100      	movs	r1, #0
    c088:	a803      	add	r0, sp, #12
    c08a:	f7f5 fdd0 	bl	1c2e <memset>
	data.buf = bt_att_create_pdu(conn, rsp, 0);
    c08e:	2200      	movs	r2, #0
    c090:	4641      	mov	r1, r8
    c092:	4628      	mov	r0, r5
    c094:	f7ff fc40 	bl	b918 <bt_att_create_pdu>
    c098:	9005      	str	r0, [sp, #20]
	if (!data.buf) {
    c09a:	b358      	cbz	r0, c0f4 <att_read_rsp+0x8c>
	data.offset = offset;
    c09c:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
    c0a0:	f8ad 3010 	strh.w	r3, [sp, #16]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    c0a4:	2301      	movs	r3, #1
    c0a6:	f88d 301c 	strb.w	r3, [sp, #28]
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    c0aa:	4a13      	ldr	r2, [pc, #76]	; (c0f8 <att_read_rsp+0x90>)
	data.att = att;
    c0ac:	9403      	str	r4, [sp, #12]
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    c0ae:	ab03      	add	r3, sp, #12
    c0b0:	4631      	mov	r1, r6
    c0b2:	4630      	mov	r0, r6
    c0b4:	f016 fc89 	bl	229ca <bt_gatt_foreach_attr>
	if (data.err) {
    c0b8:	f89d 401c 	ldrb.w	r4, [sp, #28]
    c0bc:	b174      	cbz	r4, c0dc <att_read_rsp+0x74>
		net_buf_unref(data.buf);
    c0be:	9805      	ldr	r0, [sp, #20]
    c0c0:	f00c ffcc 	bl	1905c <net_buf_unref>
	if (!req) {
    c0c4:	f89d 301c 	ldrb.w	r3, [sp, #28]
    c0c8:	4632      	mov	r2, r6
    c0ca:	4639      	mov	r1, r7
    c0cc:	4628      	mov	r0, r5
    c0ce:	f7ff fcc1 	bl	ba54 <send_err_rsp.part.11>
		return 0;
    c0d2:	2400      	movs	r4, #0
}
    c0d4:	4620      	mov	r0, r4
    c0d6:	b008      	add	sp, #32
    c0d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    c0dc:	9400      	str	r4, [sp, #0]
    c0de:	4b07      	ldr	r3, [pc, #28]	; (c0fc <att_read_rsp+0x94>)
    c0e0:	9a05      	ldr	r2, [sp, #20]
    c0e2:	2104      	movs	r1, #4
    c0e4:	4628      	mov	r0, r5
    c0e6:	f016 fbe5 	bl	228b4 <bt_l2cap_send_cb>
	return 0;
    c0ea:	e7f3      	b.n	c0d4 <att_read_rsp+0x6c>
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
    c0ec:	2412      	movs	r4, #18
    c0ee:	e7f1      	b.n	c0d4 <att_read_rsp+0x6c>
		return BT_ATT_ERR_INVALID_HANDLE;
    c0f0:	2401      	movs	r4, #1
    c0f2:	e7ef      	b.n	c0d4 <att_read_rsp+0x6c>
		return BT_ATT_ERR_UNLIKELY;
    c0f4:	240e      	movs	r4, #14
    c0f6:	e7ed      	b.n	c0d4 <att_read_rsp+0x6c>
    c0f8:	00022d8b 	.word	0x00022d8b
    c0fc:	00022cfd 	.word	0x00022cfd

0000c100 <att_read_type_req>:
{
    c100:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u8_t uuid_len = buf->len - sizeof(*req);
    c104:	7b0c      	ldrb	r4, [r1, #12]
    c106:	3c04      	subs	r4, #4
    c108:	b2e4      	uxtb	r4, r4
	if (uuid_len != 2 && uuid_len != 16) {
    c10a:	2c02      	cmp	r4, #2
{
    c10c:	4680      	mov	r8, r0
    c10e:	b08f      	sub	sp, #60	; 0x3c
    c110:	4608      	mov	r0, r1
	if (uuid_len != 2 && uuid_len != 16) {
    c112:	d001      	beq.n	c118 <att_read_type_req+0x18>
    c114:	2c10      	cmp	r4, #16
    c116:	d154      	bne.n	c1c2 <att_read_type_req+0xc2>
	req = net_buf_pull_mem(buf, sizeof(*req));
    c118:	2104      	movs	r1, #4
    c11a:	3008      	adds	r0, #8
	struct bt_conn *conn = att->chan.chan.conn;
    c11c:	f8d8 7000 	ldr.w	r7, [r8]
	req = net_buf_pull_mem(buf, sizeof(*req));
    c120:	f018 fe8c 	bl	24e3c <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    c124:	f10d 090c 	add.w	r9, sp, #12
	start_handle = sys_le16_to_cpu(req->start_handle);
    c128:	8805      	ldrh	r5, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
    c12a:	8846      	ldrh	r6, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    c12c:	1d01      	adds	r1, r0, #4
    c12e:	4622      	mov	r2, r4
    c130:	4648      	mov	r0, r9
    c132:	f016 f91e 	bl	22372 <bt_uuid_create>
    c136:	b188      	cbz	r0, c15c <att_read_type_req+0x5c>
	if (!start || !end) {
    c138:	b19d      	cbz	r5, c162 <att_read_type_req+0x62>
    c13a:	b18e      	cbz	r6, c160 <att_read_type_req+0x60>
	if (start > end) {
    c13c:	42b5      	cmp	r5, r6
    c13e:	d810      	bhi.n	c162 <att_read_type_req+0x62>
	struct bt_conn *conn = att->chan.chan.conn;
    c140:	f8d8 7000 	ldr.w	r7, [r8]
	(void)memset(&data, 0, sizeof(data));
    c144:	2218      	movs	r2, #24
    c146:	2100      	movs	r1, #0
    c148:	a808      	add	r0, sp, #32
    c14a:	f7f5 fd70 	bl	1c2e <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_RSP,
    c14e:	2201      	movs	r2, #1
    c150:	2109      	movs	r1, #9
    c152:	4638      	mov	r0, r7
    c154:	f7ff fbe0 	bl	b918 <bt_att_create_pdu>
    c158:	900a      	str	r0, [sp, #40]	; 0x28
	if (!data.buf) {
    c15a:	b968      	cbnz	r0, c178 <att_read_type_req+0x78>
		return BT_ATT_ERR_UNLIKELY;
    c15c:	240e      	movs	r4, #14
    c15e:	e007      	b.n	c170 <att_read_type_req+0x70>
			*err = 0U;
    c160:	4635      	mov	r5, r6
	if (!req) {
    c162:	2301      	movs	r3, #1
    c164:	462a      	mov	r2, r5
    c166:	2108      	movs	r1, #8
    c168:	4638      	mov	r0, r7
    c16a:	f7ff fc73 	bl	ba54 <send_err_rsp.part.11>
		return 0;
    c16e:	2400      	movs	r4, #0
}
    c170:	4620      	mov	r0, r4
    c172:	b00f      	add	sp, #60	; 0x3c
    c174:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    c178:	2101      	movs	r1, #1
    c17a:	3008      	adds	r0, #8
	data.uuid = uuid;
    c17c:	e9cd 8908 	strd	r8, r9, [sp, #32]
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    c180:	f018 fe2a 	bl	24dd8 <net_buf_simple_add>
	data.rsp->len = 0U;
    c184:	f04f 0800 	mov.w	r8, #0
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    c188:	230a      	movs	r3, #10
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    c18a:	900b      	str	r0, [sp, #44]	; 0x2c
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
    c18c:	4a0e      	ldr	r2, [pc, #56]	; (c1c8 <att_read_type_req+0xc8>)
	data.rsp->len = 0U;
    c18e:	f880 8000 	strb.w	r8, [r0]
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
    c192:	4631      	mov	r1, r6
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    c194:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
    c198:	4628      	mov	r0, r5
    c19a:	ab08      	add	r3, sp, #32
    c19c:	f016 fc15 	bl	229ca <bt_gatt_foreach_attr>
	if (data.err) {
    c1a0:	f89d 4034 	ldrb.w	r4, [sp, #52]	; 0x34
    c1a4:	b12c      	cbz	r4, c1b2 <att_read_type_req+0xb2>
		net_buf_unref(data.buf);
    c1a6:	980a      	ldr	r0, [sp, #40]	; 0x28
    c1a8:	f00c ff58 	bl	1905c <net_buf_unref>
	if (!req) {
    c1ac:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
    c1b0:	e7d8      	b.n	c164 <att_read_type_req+0x64>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    c1b2:	9400      	str	r4, [sp, #0]
    c1b4:	4b05      	ldr	r3, [pc, #20]	; (c1cc <att_read_type_req+0xcc>)
    c1b6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    c1b8:	2104      	movs	r1, #4
    c1ba:	4638      	mov	r0, r7
    c1bc:	f016 fb7a 	bl	228b4 <bt_l2cap_send_cb>
	return 0;
    c1c0:	e7d6      	b.n	c170 <att_read_type_req+0x70>
		return BT_ATT_ERR_INVALID_PDU;
    c1c2:	2404      	movs	r4, #4
    c1c4:	e7d4      	b.n	c170 <att_read_type_req+0x70>
    c1c6:	bf00      	nop
    c1c8:	00022aaf 	.word	0x00022aaf
    c1cc:	00022cfd 	.word	0x00022cfd

0000c1d0 <att_find_type_req>:
{
    c1d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c1d4:	4688      	mov	r8, r1
	struct bt_conn *conn = att->chan.chan.conn;
    c1d6:	f8d0 b000 	ldr.w	fp, [r0]
{
    c1da:	b08b      	sub	sp, #44	; 0x2c
    c1dc:	4681      	mov	r9, r0
	req = net_buf_pull_mem(buf, sizeof(*req));
    c1de:	2106      	movs	r1, #6
    c1e0:	f108 0008 	add.w	r0, r8, #8
    c1e4:	f018 fe2a 	bl	24e3c <net_buf_simple_pull_mem>
	start_handle = sys_le16_to_cpu(req->start_handle);
    c1e8:	8805      	ldrh	r5, [r0, #0]
	if (!start || !end) {
    c1ea:	b1fd      	cbz	r5, c22c <att_find_type_req+0x5c>
	end_handle = sys_le16_to_cpu(req->end_handle);
    c1ec:	8847      	ldrh	r7, [r0, #2]
	if (!start || !end) {
    c1ee:	b1e7      	cbz	r7, c22a <att_find_type_req+0x5a>
	if (start > end) {
    c1f0:	42bd      	cmp	r5, r7
    c1f2:	d81b      	bhi.n	c22c <att_find_type_req+0x5c>
	type = sys_le16_to_cpu(req->type);
    c1f4:	8883      	ldrh	r3, [r0, #4]
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
    c1f6:	f8ad 300e 	strh.w	r3, [sp, #14]
    c1fa:	2400      	movs	r4, #0
    c1fc:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    c200:	a904      	add	r1, sp, #16
    c202:	a803      	add	r0, sp, #12
	value = buf->data;
    c204:	f8d8 a008 	ldr.w	sl, [r8, #8]
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
    c208:	f88d 400c 	strb.w	r4, [sp, #12]
    c20c:	f88d 4010 	strb.w	r4, [sp, #16]
    c210:	f8ad 3012 	strh.w	r3, [sp, #18]
    c214:	f016 f883 	bl	2231e <bt_uuid_cmp>
    c218:	4606      	mov	r6, r0
    c21a:	b190      	cbz	r0, c242 <att_find_type_req+0x72>
	if (!req) {
    c21c:	230a      	movs	r3, #10
    c21e:	462a      	mov	r2, r5
    c220:	2106      	movs	r1, #6
    c222:	4658      	mov	r0, fp
    c224:	f7ff fc16 	bl	ba54 <send_err_rsp.part.11>
		return 0;
    c228:	e007      	b.n	c23a <att_find_type_req+0x6a>
			*err = 0U;
    c22a:	463d      	mov	r5, r7
	if (!req) {
    c22c:	2301      	movs	r3, #1
    c22e:	462a      	mov	r2, r5
    c230:	2106      	movs	r1, #6
    c232:	4658      	mov	r0, fp
    c234:	f7ff fc0e 	bl	ba54 <send_err_rsp.part.11>
		return 0;
    c238:	2400      	movs	r4, #0
}
    c23a:	4620      	mov	r0, r4
    c23c:	b00b      	add	sp, #44	; 0x2c
    c23e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	(void)memset(&data, 0, sizeof(data));
    c242:	2214      	movs	r2, #20
	return att_find_type_rsp(att, start_handle, end_handle, value,
    c244:	f898 400c 	ldrb.w	r4, [r8, #12]
	struct bt_conn *conn = att->chan.chan.conn;
    c248:	f8d9 8000 	ldr.w	r8, [r9]
	(void)memset(&data, 0, sizeof(data));
    c24c:	4601      	mov	r1, r0
    c24e:	eb0d 0002 	add.w	r0, sp, r2
    c252:	f7f5 fcec 	bl	1c2e <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_RSP, 0);
    c256:	4632      	mov	r2, r6
    c258:	2107      	movs	r1, #7
    c25a:	4640      	mov	r0, r8
    c25c:	f7ff fb5c 	bl	b918 <bt_att_create_pdu>
    c260:	9006      	str	r0, [sp, #24]
	if (!data.buf) {
    c262:	b310      	cbz	r0, c2aa <att_find_type_req+0xda>
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    c264:	230a      	movs	r3, #10
    c266:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
    c26a:	4a11      	ldr	r2, [pc, #68]	; (c2b0 <att_find_type_req+0xe0>)
	data.value_len = value_len;
    c26c:	f88d 4024 	strb.w	r4, [sp, #36]	; 0x24
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
    c270:	ab05      	add	r3, sp, #20
    c272:	4639      	mov	r1, r7
    c274:	4628      	mov	r0, r5
	data.att = att;
    c276:	f8cd 9014 	str.w	r9, [sp, #20]
	data.value = value;
    c27a:	e9cd 6a07 	strd	r6, sl, [sp, #28]
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
    c27e:	f016 fba4 	bl	229ca <bt_gatt_foreach_attr>
	if (data.err) {
    c282:	f89d 4025 	ldrb.w	r4, [sp, #37]	; 0x25
    c286:	b144      	cbz	r4, c29a <att_find_type_req+0xca>
		net_buf_unref(data.buf);
    c288:	9806      	ldr	r0, [sp, #24]
    c28a:	f00c fee7 	bl	1905c <net_buf_unref>
	if (!req) {
    c28e:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
    c292:	462a      	mov	r2, r5
    c294:	2106      	movs	r1, #6
    c296:	4640      	mov	r0, r8
    c298:	e7cc      	b.n	c234 <att_find_type_req+0x64>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    c29a:	9400      	str	r4, [sp, #0]
    c29c:	4b05      	ldr	r3, [pc, #20]	; (c2b4 <att_find_type_req+0xe4>)
    c29e:	9a06      	ldr	r2, [sp, #24]
    c2a0:	2104      	movs	r1, #4
    c2a2:	4640      	mov	r0, r8
    c2a4:	f016 fb06 	bl	228b4 <bt_l2cap_send_cb>
	return 0;
    c2a8:	e7c7      	b.n	c23a <att_find_type_req+0x6a>
		return BT_ATT_ERR_UNLIKELY;
    c2aa:	240e      	movs	r4, #14
	return att_find_type_rsp(att, start_handle, end_handle, value,
    c2ac:	e7c5      	b.n	c23a <att_find_type_req+0x6a>
    c2ae:	bf00      	nop
    c2b0:	0000b591 	.word	0x0000b591
    c2b4:	00022cfd 	.word	0x00022cfd

0000c2b8 <att_find_info_req>:
{
    c2b8:	b5f0      	push	{r4, r5, r6, r7, lr}
	req = (void *)buf->data;
    c2ba:	688b      	ldr	r3, [r1, #8]
	struct bt_conn *conn = att->chan.chan.conn;
    c2bc:	6806      	ldr	r6, [r0, #0]
	start_handle = sys_le16_to_cpu(req->start_handle);
    c2be:	881d      	ldrh	r5, [r3, #0]
{
    c2c0:	b087      	sub	sp, #28
    c2c2:	4607      	mov	r7, r0
	if (!start || !end) {
    c2c4:	b195      	cbz	r5, c2ec <att_find_info_req+0x34>
	end_handle = sys_le16_to_cpu(req->end_handle);
    c2c6:	885c      	ldrh	r4, [r3, #2]
	if (!start || !end) {
    c2c8:	b17c      	cbz	r4, c2ea <att_find_info_req+0x32>
	if (start > end) {
    c2ca:	42a5      	cmp	r5, r4
    c2cc:	d80e      	bhi.n	c2ec <att_find_info_req+0x34>
	(void)memset(&data, 0, sizeof(data));
    c2ce:	2210      	movs	r2, #16
    c2d0:	2100      	movs	r1, #0
    c2d2:	a802      	add	r0, sp, #8
    c2d4:	f7f5 fcab 	bl	1c2e <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_RSP, 0);
    c2d8:	2200      	movs	r2, #0
    c2da:	2105      	movs	r1, #5
    c2dc:	4630      	mov	r0, r6
    c2de:	f7ff fb1b 	bl	b918 <bt_att_create_pdu>
    c2e2:	9003      	str	r0, [sp, #12]
	if (!data.buf) {
    c2e4:	b958      	cbnz	r0, c2fe <att_find_info_req+0x46>
		return BT_ATT_ERR_UNLIKELY;
    c2e6:	200e      	movs	r0, #14
	return att_find_info_rsp(att, start_handle, end_handle);
    c2e8:	e007      	b.n	c2fa <att_find_info_req+0x42>
			*err = 0U;
    c2ea:	4625      	mov	r5, r4
	if (!req) {
    c2ec:	2301      	movs	r3, #1
    c2ee:	462a      	mov	r2, r5
    c2f0:	2104      	movs	r1, #4
    c2f2:	4630      	mov	r0, r6
    c2f4:	f7ff fbae 	bl	ba54 <send_err_rsp.part.11>
		return 0;
    c2f8:	2000      	movs	r0, #0
}
    c2fa:	b007      	add	sp, #28
    c2fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
    c2fe:	4621      	mov	r1, r4
    c300:	ab02      	add	r3, sp, #8
    c302:	4a0a      	ldr	r2, [pc, #40]	; (c32c <att_find_info_req+0x74>)
	data.att = att;
    c304:	9702      	str	r7, [sp, #8]
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
    c306:	4628      	mov	r0, r5
    c308:	f016 fb5f 	bl	229ca <bt_gatt_foreach_attr>
	if (!data.rsp) {
    c30c:	9c04      	ldr	r4, [sp, #16]
    c30e:	b924      	cbnz	r4, c31a <att_find_info_req+0x62>
		net_buf_unref(data.buf);
    c310:	9803      	ldr	r0, [sp, #12]
    c312:	f00c fea3 	bl	1905c <net_buf_unref>
	if (!req) {
    c316:	230a      	movs	r3, #10
    c318:	e7e9      	b.n	c2ee <att_find_info_req+0x36>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    c31a:	2400      	movs	r4, #0
    c31c:	9400      	str	r4, [sp, #0]
    c31e:	4b04      	ldr	r3, [pc, #16]	; (c330 <att_find_info_req+0x78>)
    c320:	9a03      	ldr	r2, [sp, #12]
    c322:	2104      	movs	r1, #4
    c324:	4630      	mov	r0, r6
    c326:	f016 fac5 	bl	228b4 <bt_l2cap_send_cb>
	return 0;
    c32a:	e7e5      	b.n	c2f8 <att_find_info_req+0x40>
    c32c:	00022b69 	.word	0x00022b69
    c330:	00022cfd 	.word	0x00022cfd

0000c334 <bt_att_req_alloc>:
	/* tx and rx MTU shall be symmetric */
	return att->chan.tx.mtu;
}

struct bt_att_req *bt_att_req_alloc(s32_t timeout)
{
    c334:	b513      	push	{r0, r1, r4, lr}
	struct bt_att_req *req = NULL;

	/* Reserve space for request */
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
    c336:	4602      	mov	r2, r0
	struct bt_att_req *req = NULL;
    c338:	2400      	movs	r4, #0
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
    c33a:	a901      	add	r1, sp, #4
    c33c:	4806      	ldr	r0, [pc, #24]	; (c358 <bt_att_req_alloc+0x24>)
	struct bt_att_req *req = NULL;
    c33e:	9401      	str	r4, [sp, #4]
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
    c340:	f012 f812 	bl	1e368 <k_mem_slab_alloc>
    c344:	4603      	mov	r3, r0
    c346:	b928      	cbnz	r0, c354 <bt_att_req_alloc+0x20>
		return NULL;
	}

	BT_DBG("req %p", req);

	req->func = NULL;
    c348:	9801      	ldr	r0, [sp, #4]
	req->destroy = NULL;
    c34a:	e9c0 3301 	strd	r3, r3, [r0, #4]
	req->user_data = NULL;
    c34e:	6183      	str	r3, [r0, #24]

	return req;
}
    c350:	b002      	add	sp, #8
    c352:	bd10      	pop	{r4, pc}
		return NULL;
    c354:	4620      	mov	r0, r4
    c356:	e7fb      	b.n	c350 <bt_att_req_alloc+0x1c>
    c358:	2000eef4 	.word	0x2000eef4

0000c35c <bt_att_req_free>:

void bt_att_req_free(struct bt_att_req *req)
{
    c35c:	b507      	push	{r0, r1, r2, lr}
    c35e:	9001      	str	r0, [sp, #4]
	BT_DBG("req %p", req);

	k_mem_slab_free(&req_slab, (void **)&req);
    c360:	a901      	add	r1, sp, #4
    c362:	4803      	ldr	r0, [pc, #12]	; (c370 <bt_att_req_free+0x14>)
    c364:	f012 f82c 	bl	1e3c0 <k_mem_slab_free>
}
    c368:	b003      	add	sp, #12
    c36a:	f85d fb04 	ldr.w	pc, [sp], #4
    c36e:	bf00      	nop
    c370:	2000eef4 	.word	0x2000eef4

0000c374 <att_handle_rsp>:
{
    c374:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    c378:	4604      	mov	r4, r0
	k_delayed_work_cancel(&att->timeout_work);
    c37a:	30a8      	adds	r0, #168	; 0xa8
{
    c37c:	461e      	mov	r6, r3
    c37e:	460f      	mov	r7, r1
    c380:	4690      	mov	r8, r2
	k_delayed_work_cancel(&att->timeout_work);
    c382:	f01b fdc8 	bl	27f16 <k_delayed_work_cancel>
	if (!att->req) {
    c386:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
    c38a:	bb03      	cbnz	r3, c3ce <att_handle_rsp+0x5a>
		BT_WARN("No pending ATT request");
    c38c:	2302      	movs	r3, #2
    c38e:	f04f 0100 	mov.w	r1, #0
    c392:	f363 0107 	bfi	r1, r3, #0, #8
    c396:	4a1f      	ldr	r2, [pc, #124]	; (c414 <att_handle_rsp+0xa0>)
    c398:	4b1f      	ldr	r3, [pc, #124]	; (c418 <att_handle_rsp+0xa4>)
    c39a:	4820      	ldr	r0, [pc, #128]	; (c41c <att_handle_rsp+0xa8>)
    c39c:	1a9b      	subs	r3, r3, r2
    c39e:	08db      	lsrs	r3, r3, #3
    c3a0:	f363 118f 	bfi	r1, r3, #6, #10
    c3a4:	f014 fe49 	bl	2103a <log_0>
Z_GENLIST_IS_EMPTY(slist)
    c3a8:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
Z_GENLIST_GET(slist, snode)
    c3ac:	b159      	cbz	r1, c3c6 <att_handle_rsp+0x52>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    c3ae:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
    c3b2:	680b      	ldr	r3, [r1, #0]
	list->head = node;
    c3b4:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    c3b8:	4291      	cmp	r1, r2
	list->tail = node;
    c3ba:	bf08      	it	eq
    c3bc:	f8c4 30a4 	streq.w	r3, [r4, #164]	; 0xa4
	att_send_req(att, ATT_REQ(node));
    c3c0:	4620      	mov	r0, r4
    c3c2:	f016 fc22 	bl	22c0a <att_send_req>
}
    c3c6:	2000      	movs	r0, #0
    c3c8:	b002      	add	sp, #8
    c3ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (att->req == &cancel) {
    c3ce:	4a14      	ldr	r2, [pc, #80]	; (c420 <att_handle_rsp+0xac>)
    c3d0:	4293      	cmp	r3, r2
    c3d2:	d103      	bne.n	c3dc <att_handle_rsp+0x68>
		att->req = NULL;
    c3d4:	2300      	movs	r3, #0
    c3d6:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
		goto process;
    c3da:	e7e5      	b.n	c3a8 <att_handle_rsp+0x34>
	if (att->req->buf) {
    c3dc:	6918      	ldr	r0, [r3, #16]
    c3de:	b128      	cbz	r0, c3ec <att_handle_rsp+0x78>
		net_buf_unref(att->req->buf);
    c3e0:	f00c fe3c 	bl	1905c <net_buf_unref>
		att->req->buf = NULL;
    c3e4:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
    c3e8:	2200      	movs	r2, #0
    c3ea:	611a      	str	r2, [r3, #16]
	func = att->req->func;
    c3ec:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
	att->req->func = NULL;
    c3f0:	2500      	movs	r5, #0
	func = att->req->func;
    c3f2:	f8d0 9004 	ldr.w	r9, [r0, #4]
	params = att->req->user_data;
    c3f6:	f8d0 a018 	ldr.w	sl, [r0, #24]
	att->req->func = NULL;
    c3fa:	6045      	str	r5, [r0, #4]
	att_req_destroy(att->req);
    c3fc:	f016 fd4c 	bl	22e98 <att_req_destroy>
	att->req = NULL;
    c400:	f8c4 509c 	str.w	r5, [r4, #156]	; 0x9c
	func(att->chan.chan.conn, err, pdu, len, params);
    c404:	f8cd a000 	str.w	sl, [sp]
    c408:	4643      	mov	r3, r8
    c40a:	463a      	mov	r2, r7
    c40c:	4631      	mov	r1, r6
    c40e:	6820      	ldr	r0, [r4, #0]
    c410:	47c8      	blx	r9
    c412:	e7c9      	b.n	c3a8 <att_handle_rsp+0x34>
    c414:	00028540 	.word	0x00028540
    c418:	00028550 	.word	0x00028550
    c41c:	0006386e 	.word	0x0006386e
    c420:	20000514 	.word	0x20000514

0000c424 <att_error_rsp>:
	if (!att->req || att->req == &cancel) {
    c424:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
{
    c428:	b570      	push	{r4, r5, r6, lr}
    c42a:	4605      	mov	r5, r0
	if (!att->req || att->req == &cancel) {
    c42c:	b352      	cbz	r2, c484 <att_error_rsp+0x60>
    c42e:	4b1a      	ldr	r3, [pc, #104]	; (c498 <att_error_rsp+0x74>)
    c430:	429a      	cmp	r2, r3
    c432:	d027      	beq.n	c484 <att_error_rsp+0x60>
	if (att->req->buf) {
    c434:	6913      	ldr	r3, [r2, #16]
	rsp = (void *)buf->data;
    c436:	6888      	ldr	r0, [r1, #8]
	if (att->req->buf) {
    c438:	b12b      	cbz	r3, c446 <att_error_rsp+0x22>
 * @param state Stored state.
 */
static inline void net_buf_simple_restore(struct net_buf_simple *buf,
					  struct net_buf_simple_state *state)
{
	buf->data = buf->__buf + state->offset;
    c43a:	8994      	ldrh	r4, [r2, #12]
    c43c:	6919      	ldr	r1, [r3, #16]
    c43e:	4421      	add	r1, r4
    c440:	6099      	str	r1, [r3, #8]
	buf->len = state->len;
    c442:	89d1      	ldrh	r1, [r2, #14]
    c444:	8199      	strh	r1, [r3, #12]
	if (att->req->retrying) {
    c446:	7d13      	ldrb	r3, [r2, #20]
	err = rsp->error;
    c448:	78c4      	ldrb	r4, [r0, #3]
	if (att->req->retrying) {
    c44a:	b9e3      	cbnz	r3, c486 <att_error_rsp+0x62>
	switch (err) {
    c44c:	2c05      	cmp	r4, #5
	if (!att_change_security(att->chan.chan.conn, err)) {
    c44e:	6828      	ldr	r0, [r5, #0]
	switch (err) {
    c450:	d006      	beq.n	c460 <att_error_rsp+0x3c>
    c452:	2c0f      	cmp	r4, #15
    c454:	d117      	bne.n	c486 <att_error_rsp+0x62>
		if (conn->sec_level >= BT_SECURITY_L2)
    c456:	7a43      	ldrb	r3, [r0, #9]
    c458:	2b01      	cmp	r3, #1
    c45a:	d814      	bhi.n	c486 <att_error_rsp+0x62>
		sec = BT_SECURITY_L2;
    c45c:	2102      	movs	r1, #2
    c45e:	e007      	b.n	c470 <att_error_rsp+0x4c>
		if (conn->sec_level < BT_SECURITY_L2) {
    c460:	7a43      	ldrb	r3, [r0, #9]
    c462:	2b01      	cmp	r3, #1
    c464:	d9fa      	bls.n	c45c <att_error_rsp+0x38>
		} else if (conn->sec_level < BT_SECURITY_L3) {
    c466:	2b02      	cmp	r3, #2
    c468:	d00a      	beq.n	c480 <att_error_rsp+0x5c>
		} else if (conn->sec_level < BT_SECURITY_L4) {
    c46a:	2b03      	cmp	r3, #3
    c46c:	d10b      	bne.n	c486 <att_error_rsp+0x62>
			sec = BT_SECURITY_L4;
    c46e:	2104      	movs	r1, #4
	return bt_conn_set_security(conn, sec);
    c470:	f016 f908 	bl	22684 <bt_conn_set_security>
	if (!att_change_security(att->chan.chan.conn, err)) {
    c474:	b938      	cbnz	r0, c486 <att_error_rsp+0x62>
		att->req->retrying = true;
    c476:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
    c47a:	2201      	movs	r2, #1
    c47c:	751a      	strb	r2, [r3, #20]
}
    c47e:	bd70      	pop	{r4, r5, r6, pc}
			sec = BT_SECURITY_L3;
    c480:	2103      	movs	r1, #3
    c482:	e7f5      	b.n	c470 <att_error_rsp+0x4c>
		err = BT_ATT_ERR_UNLIKELY;
    c484:	240e      	movs	r4, #14
	return att_handle_rsp(att, NULL, 0, err);
    c486:	2200      	movs	r2, #0
    c488:	4623      	mov	r3, r4
    c48a:	4628      	mov	r0, r5
    c48c:	4611      	mov	r1, r2
}
    c48e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return att_handle_rsp(att, NULL, 0, err);
    c492:	f7ff bf6f 	b.w	c374 <att_handle_rsp>
    c496:	bf00      	nop
    c498:	20000514 	.word	0x20000514

0000c49c <bt_att_encrypt_change>:
{
    c49c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    c49e:	4604      	mov	r4, r0
	if (hci_status) {
    c4a0:	b139      	cbz	r1, c4b2 <bt_att_encrypt_change+0x16>
		att_handle_rsp(att, NULL, 0, BT_ATT_ERR_AUTHENTICATION);
    c4a2:	2200      	movs	r2, #0
    c4a4:	2305      	movs	r3, #5
    c4a6:	4611      	mov	r1, r2
}
    c4a8:	b002      	add	sp, #8
    c4aa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		att_handle_rsp(att, NULL, 0, BT_ATT_ERR_AUTHENTICATION);
    c4ae:	f7ff bf61 	b.w	c374 <att_handle_rsp>
	struct bt_conn *conn = ch->chan.conn;
    c4b2:	6805      	ldr	r5, [r0, #0]
	bt_gatt_encrypt_change(conn);
    c4b4:	4628      	mov	r0, r5
    c4b6:	f001 ff23 	bl	e300 <bt_gatt_encrypt_change>
	if (conn->sec_level == BT_SECURITY_L1) {
    c4ba:	7a6b      	ldrb	r3, [r5, #9]
    c4bc:	2b01      	cmp	r3, #1
    c4be:	d03d      	beq.n	c53c <bt_att_encrypt_change+0xa0>
	if (!att->req || !att->req->retrying) {
    c4c0:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
    c4c4:	2b00      	cmp	r3, #0
    c4c6:	d039      	beq.n	c53c <bt_att_encrypt_change+0xa0>
    c4c8:	7d1b      	ldrb	r3, [r3, #20]
    c4ca:	2b00      	cmp	r3, #0
    c4cc:	d036      	beq.n	c53c <bt_att_encrypt_change+0xa0>
	k_sem_take(&att->tx_sem, K_FOREVER);
    c4ce:	f104 06c8 	add.w	r6, r4, #200	; 0xc8
	return z_impl_k_sem_take(sem, timeout);
    c4d2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    c4d6:	4630      	mov	r0, r6
    c4d8:	f012 fc7c 	bl	1edd4 <z_impl_k_sem_take>
	return (att->chan.chan.conn->state != BT_CONN_CONNECTED ||
    c4dc:	6823      	ldr	r3, [r4, #0]
    c4de:	7b5b      	ldrb	r3, [r3, #13]
    c4e0:	2b06      	cmp	r3, #6
    c4e2:	d11b      	bne.n	c51c <bt_att_encrypt_change+0x80>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    c4e4:	f3bf 8f5b 	dmb	ish
    c4e8:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
    c4ec:	f3bf 8f5b 	dmb	ish
	if (!att_is_connected(att)) {
    c4f0:	075b      	lsls	r3, r3, #29
    c4f2:	d513      	bpl.n	c51c <bt_att_encrypt_change+0x80>
		BT_WARN("Disconnected");
    c4f4:	2302      	movs	r3, #2
    c4f6:	f04f 0100 	mov.w	r1, #0
    c4fa:	4a11      	ldr	r2, [pc, #68]	; (c540 <bt_att_encrypt_change+0xa4>)
    c4fc:	4811      	ldr	r0, [pc, #68]	; (c544 <bt_att_encrypt_change+0xa8>)
    c4fe:	f363 0107 	bfi	r1, r3, #0, #8
    c502:	4b11      	ldr	r3, [pc, #68]	; (c548 <bt_att_encrypt_change+0xac>)
    c504:	1a9b      	subs	r3, r3, r2
    c506:	08db      	lsrs	r3, r3, #3
    c508:	f363 118f 	bfi	r1, r3, #6, #10
    c50c:	f014 fd95 	bl	2103a <log_0>
	z_impl_k_sem_give(sem);
    c510:	4630      	mov	r0, r6
}
    c512:	b002      	add	sp, #8
    c514:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    c518:	f012 bc30 	b.w	1ed7c <z_impl_k_sem_give>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, att->req->buf,
    c51c:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
    c520:	691a      	ldr	r2, [r3, #16]
    c522:	6890      	ldr	r0, [r2, #8]
    c524:	f7ff f8be 	bl	b6a4 <att_cb.isra.6>
    c528:	2600      	movs	r6, #0
    c52a:	4603      	mov	r3, r0
    c52c:	9600      	str	r6, [sp, #0]
    c52e:	2104      	movs	r1, #4
    c530:	4628      	mov	r0, r5
    c532:	f016 f9bf 	bl	228b4 <bt_l2cap_send_cb>
	att->req->buf = NULL;
    c536:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
    c53a:	611e      	str	r6, [r3, #16]
}
    c53c:	b002      	add	sp, #8
    c53e:	bd70      	pop	{r4, r5, r6, pc}
    c540:	00028540 	.word	0x00028540
    c544:	00063903 	.word	0x00063903
    c548:	00028550 	.word	0x00028550

0000c54c <bt_att_disconnected>:
{
    c54c:	b513      	push	{r0, r1, r4, lr}
    c54e:	4604      	mov	r4, r0
	struct bt_att *att = ATT_CHAN(chan);
    c550:	9001      	str	r0, [sp, #4]
	att_reset(att);
    c552:	f016 fce1 	bl	22f18 <att_reset>
	bt_gatt_disconnected(ch->chan.conn);
    c556:	6820      	ldr	r0, [r4, #0]
    c558:	f001 ff56 	bl	e408 <bt_gatt_disconnected>
	k_mem_slab_free(&att_slab, (void **)&att);
    c55c:	a901      	add	r1, sp, #4
    c55e:	4802      	ldr	r0, [pc, #8]	; (c568 <bt_att_disconnected+0x1c>)
    c560:	f011 ff2e 	bl	1e3c0 <k_mem_slab_free>
}
    c564:	b002      	add	sp, #8
    c566:	bd10      	pop	{r4, pc}
    c568:	2000eed8 	.word	0x2000eed8

0000c56c <att_timeout>:
{
    c56c:	b513      	push	{r0, r1, r4, lr}
	struct bt_att *att = CONTAINER_OF(work, struct bt_att, timeout_work);
    c56e:	f1a0 03a8 	sub.w	r3, r0, #168	; 0xa8
    c572:	9301      	str	r3, [sp, #4]
	BT_ERR("ATT Timeout");
    c574:	f04f 0100 	mov.w	r1, #0
    c578:	2301      	movs	r3, #1
    c57a:	4a0e      	ldr	r2, [pc, #56]	; (c5b4 <att_timeout+0x48>)
    c57c:	f363 0107 	bfi	r1, r3, #0, #8
    c580:	4b0d      	ldr	r3, [pc, #52]	; (c5b8 <att_timeout+0x4c>)
    c582:	1a9b      	subs	r3, r3, r2
    c584:	08db      	lsrs	r3, r3, #3
    c586:	f363 118f 	bfi	r1, r3, #6, #10
{
    c58a:	4604      	mov	r4, r0
	BT_ERR("ATT Timeout");
    c58c:	480b      	ldr	r0, [pc, #44]	; (c5bc <att_timeout+0x50>)
    c58e:	f014 fd54 	bl	2103a <log_0>
	att_reset(att);
    c592:	9801      	ldr	r0, [sp, #4]
    c594:	f016 fcc0 	bl	22f18 <att_reset>
	bt_gatt_disconnected(ch->chan.conn);
    c598:	f854 0ca8 	ldr.w	r0, [r4, #-168]
    c59c:	f001 ff34 	bl	e408 <bt_gatt_disconnected>
	ch->chan.conn = NULL;
    c5a0:	2300      	movs	r3, #0
    c5a2:	f844 3ca8 	str.w	r3, [r4, #-168]
	k_mem_slab_free(&att_slab, (void **)&att);
    c5a6:	a901      	add	r1, sp, #4
    c5a8:	4805      	ldr	r0, [pc, #20]	; (c5c0 <att_timeout+0x54>)
    c5aa:	f011 ff09 	bl	1e3c0 <k_mem_slab_free>
}
    c5ae:	b002      	add	sp, #8
    c5b0:	bd10      	pop	{r4, pc}
    c5b2:	bf00      	nop
    c5b4:	00028540 	.word	0x00028540
    c5b8:	00028550 	.word	0x00028550
    c5bc:	000638ad 	.word	0x000638ad
    c5c0:	2000eed8 	.word	0x2000eed8

0000c5c4 <bt_att_req_cancel>:

	return att_send_req(att, req);
}

void bt_att_req_cancel(struct bt_conn *conn, struct bt_att_req *req)
{
    c5c4:	b510      	push	{r4, lr}
    c5c6:	460c      	mov	r4, r1
	struct bt_att *att;

	BT_DBG("req %p", req);

	if (!conn || !req) {
    c5c8:	b370      	cbz	r0, c628 <bt_att_req_cancel+0x64>
    c5ca:	b369      	cbz	r1, c628 <bt_att_req_cancel+0x64>
		return;
	}

	att = att_chan_get(conn);
    c5cc:	f7ff f91e 	bl	b80c <att_chan_get>
	if (!att) {
    c5d0:	b350      	cbz	r0, c628 <bt_att_req_cancel+0x64>
		return;
	}

	/* Check if request is outstanding */
	if (att->req == req) {
    c5d2:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
    c5d6:	429c      	cmp	r4, r3
    c5d8:	d107      	bne.n	c5ea <bt_att_req_cancel+0x26>
		att->req = &cancel;
    c5da:	4b14      	ldr	r3, [pc, #80]	; (c62c <bt_att_req_cancel+0x68>)
    c5dc:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
	} else {
		/* Remove request from the list */
		sys_slist_find_and_remove(&att->reqs, &req->node);
	}

	att_req_destroy(req);
    c5e0:	4620      	mov	r0, r4
}
    c5e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	att_req_destroy(req);
    c5e6:	f016 bc57 	b.w	22e98 <att_req_destroy>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    c5ea:	f8d0 30a0 	ldr.w	r3, [r0, #160]	; 0xa0
    c5ee:	2200      	movs	r2, #0
    c5f0:	2b00      	cmp	r3, #0
    c5f2:	d0f5      	beq.n	c5e0 <bt_att_req_cancel+0x1c>
    c5f4:	429c      	cmp	r4, r3
    c5f6:	d114      	bne.n	c622 <bt_att_req_cancel+0x5e>
Z_GENLIST_REMOVE(slist, snode)
    c5f8:	6823      	ldr	r3, [r4, #0]
    c5fa:	b952      	cbnz	r2, c612 <bt_att_req_cancel+0x4e>
    c5fc:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
	list->head = node;
    c600:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
Z_GENLIST_REMOVE(slist, snode)
    c604:	4294      	cmp	r4, r2
    c606:	d101      	bne.n	c60c <bt_att_req_cancel+0x48>
	list->tail = node;
    c608:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
	parent->next = child;
    c60c:	2300      	movs	r3, #0
    c60e:	6023      	str	r3, [r4, #0]
    c610:	e7e6      	b.n	c5e0 <bt_att_req_cancel+0x1c>
    c612:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
    c614:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
    c618:	429c      	cmp	r4, r3
	list->tail = node;
    c61a:	bf08      	it	eq
    c61c:	f8c0 20a4 	streq.w	r2, [r0, #164]	; 0xa4
    c620:	e7f4      	b.n	c60c <bt_att_req_cancel+0x48>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    c622:	461a      	mov	r2, r3
    c624:	681b      	ldr	r3, [r3, #0]
    c626:	e7e3      	b.n	c5f0 <bt_att_req_cancel+0x2c>
}
    c628:	bd10      	pop	{r4, pc}
    c62a:	bf00      	nop
    c62c:	20000514 	.word	0x20000514

0000c630 <find_static_attr>:

	return BT_GATT_ITER_CONTINUE;
}

static u16_t find_static_attr(const struct bt_gatt_attr *attr)
{
    c630:	b5f0      	push	{r4, r5, r6, r7, lr}
    c632:	490f      	ldr	r1, [pc, #60]	; (c670 <find_static_attr+0x40>)
	u16_t handle = 1;

	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    c634:	4f0f      	ldr	r7, [pc, #60]	; (c674 <find_static_attr+0x44>)
	u16_t handle = 1;
    c636:	2501      	movs	r5, #1
		for (int i = 0; i < static_svc->attr_count; i++, handle++) {
			if (attr == &static_svc->attrs[i]) {
    c638:	f04f 0c14 	mov.w	ip, #20
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    c63c:	f1a1 0308 	sub.w	r3, r1, #8
    c640:	42bb      	cmp	r3, r7
    c642:	d211      	bcs.n	c668 <find_static_attr+0x38>
    c644:	f851 6c04 	ldr.w	r6, [r1, #-4]
		for (int i = 0; i < static_svc->attr_count; i++, handle++) {
    c648:	2200      	movs	r2, #0
    c64a:	e006      	b.n	c65a <find_static_attr+0x2a>
			if (attr == &static_svc->attrs[i]) {
    c64c:	f851 4c08 	ldr.w	r4, [r1, #-8]
    c650:	fb0c 4402 	mla	r4, ip, r2, r4
    c654:	42a0      	cmp	r0, r4
    c656:	d008      	beq.n	c66a <find_static_attr+0x3a>
		for (int i = 0; i < static_svc->attr_count; i++, handle++) {
    c658:	3201      	adds	r2, #1
    c65a:	18ab      	adds	r3, r5, r2
    c65c:	42b2      	cmp	r2, r6
    c65e:	b29b      	uxth	r3, r3
    c660:	d1f4      	bne.n	c64c <find_static_attr+0x1c>
    c662:	3108      	adds	r1, #8
    c664:	461d      	mov	r5, r3
    c666:	e7e9      	b.n	c63c <find_static_attr+0xc>
				return handle;
			}
		}
	}

	return 0;
    c668:	2300      	movs	r3, #0
}
    c66a:	4618      	mov	r0, r3
    c66c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c66e:	bf00      	nop
    c670:	00028498 	.word	0x00028498
    c674:	000284c8 	.word	0x000284c8

0000c678 <db_hash_store>:
	err = settings_save_one("bt/hash", &db_hash, sizeof(db_hash));
    c678:	490c      	ldr	r1, [pc, #48]	; (c6ac <db_hash_store+0x34>)
    c67a:	480d      	ldr	r0, [pc, #52]	; (c6b0 <db_hash_store+0x38>)
{
    c67c:	b508      	push	{r3, lr}
	err = settings_save_one("bt/hash", &db_hash, sizeof(db_hash));
    c67e:	2210      	movs	r2, #16
    c680:	f7f9 fcda 	bl	6038 <settings_save_one>
	if (err) {
    c684:	4601      	mov	r1, r0
    c686:	b178      	cbz	r0, c6a8 <db_hash_store+0x30>
		BT_ERR("Failed to save Database Hash (err %d)", err);
    c688:	2301      	movs	r3, #1
    c68a:	f04f 0200 	mov.w	r2, #0
    c68e:	f363 0207 	bfi	r2, r3, #0, #8
    c692:	4808      	ldr	r0, [pc, #32]	; (c6b4 <db_hash_store+0x3c>)
    c694:	4b08      	ldr	r3, [pc, #32]	; (c6b8 <db_hash_store+0x40>)
    c696:	1a1b      	subs	r3, r3, r0
    c698:	08db      	lsrs	r3, r3, #3
    c69a:	f363 128f 	bfi	r2, r3, #6, #10
    c69e:	4807      	ldr	r0, [pc, #28]	; (c6bc <db_hash_store+0x44>)
}
    c6a0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		BT_ERR("Failed to save Database Hash (err %d)", err);
    c6a4:	f014 bcd6 	b.w	21054 <log_1>
}
    c6a8:	bd08      	pop	{r3, pc}
    c6aa:	bf00      	nop
    c6ac:	2000aa3a 	.word	0x2000aa3a
    c6b0:	00063b28 	.word	0x00063b28
    c6b4:	00028540 	.word	0x00028540
    c6b8:	00028608 	.word	0x00028608
    c6bc:	00063b30 	.word	0x00063b30

0000c6c0 <db_hash_set>:

static u8_t stored_hash[16];

static int db_hash_set(const char *name, size_t len_rd,
		       settings_read_cb read_cb, void *cb_arg)
{
    c6c0:	b510      	push	{r4, lr}
	int len;

	len = read_cb(cb_arg, stored_hash, sizeof(stored_hash));
    c6c2:	490d      	ldr	r1, [pc, #52]	; (c6f8 <db_hash_set+0x38>)
{
    c6c4:	4614      	mov	r4, r2
	len = read_cb(cb_arg, stored_hash, sizeof(stored_hash));
    c6c6:	4618      	mov	r0, r3
    c6c8:	2210      	movs	r2, #16
    c6ca:	47a0      	blx	r4
	if (len < 0) {
    c6cc:	1e04      	subs	r4, r0, #0
    c6ce:	da10      	bge.n	c6f2 <db_hash_set+0x32>
		BT_ERR("Failed to decode value (err %d)", len);
    c6d0:	2301      	movs	r3, #1
    c6d2:	f04f 0200 	mov.w	r2, #0
    c6d6:	f363 0207 	bfi	r2, r3, #0, #8
    c6da:	4908      	ldr	r1, [pc, #32]	; (c6fc <db_hash_set+0x3c>)
    c6dc:	4b08      	ldr	r3, [pc, #32]	; (c700 <db_hash_set+0x40>)
    c6de:	4809      	ldr	r0, [pc, #36]	; (c704 <db_hash_set+0x44>)
    c6e0:	1a5b      	subs	r3, r3, r1
    c6e2:	08db      	lsrs	r3, r3, #3
    c6e4:	f363 128f 	bfi	r2, r3, #6, #10
    c6e8:	4621      	mov	r1, r4
    c6ea:	f014 fcb3 	bl	21054 <log_1>
	}

	BT_HEXDUMP_DBG(stored_hash, sizeof(stored_hash), "Stored Hash: ");

	return 0;
}
    c6ee:	4620      	mov	r0, r4
    c6f0:	bd10      	pop	{r4, pc}
	return 0;
    c6f2:	2400      	movs	r4, #0
    c6f4:	e7fb      	b.n	c6ee <db_hash_set+0x2e>
    c6f6:	bf00      	nop
    c6f8:	2000aa4a 	.word	0x2000aa4a
    c6fc:	00028540 	.word	0x00028540
    c700:	00028608 	.word	0x00028608
    c704:	00063b08 	.word	0x00063b08

0000c708 <sc_store>:
{
    c708:	b570      	push	{r4, r5, r6, lr}
	if (cfg->id) {
    c70a:	4604      	mov	r4, r0
{
    c70c:	b08c      	sub	sp, #48	; 0x30
	if (cfg->id) {
    c70e:	f814 2b01 	ldrb.w	r2, [r4], #1
{
    c712:	4605      	mov	r5, r0
	if (cfg->id) {
    c714:	b31a      	cbz	r2, c75e <sc_store+0x56>
		u8_to_dec(id_str, sizeof(id_str), cfg->id);
    c716:	ae02      	add	r6, sp, #8
    c718:	2104      	movs	r1, #4
    c71a:	4630      	mov	r0, r6
    c71c:	f012 ff8c 	bl	1f638 <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "sc",
    c720:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "sc",
    c722:	4623      	mov	r3, r4
    c724:	4a0f      	ldr	r2, [pc, #60]	; (c764 <sc_store+0x5c>)
    c726:	2124      	movs	r1, #36	; 0x24
    c728:	a803      	add	r0, sp, #12
    c72a:	f7fb fb41 	bl	7db0 <bt_settings_encode_key>
	err = settings_save_one(key, (char *)&cfg->data, sizeof(cfg->data));
    c72e:	f105 0108 	add.w	r1, r5, #8
    c732:	2204      	movs	r2, #4
    c734:	a803      	add	r0, sp, #12
    c736:	f7f9 fc7f 	bl	6038 <settings_save_one>
	if (err) {
    c73a:	4601      	mov	r1, r0
    c73c:	b168      	cbz	r0, c75a <sc_store+0x52>
		BT_ERR("failed to store SC (err %d)", err);
    c73e:	2301      	movs	r3, #1
    c740:	f04f 0200 	mov.w	r2, #0
    c744:	f363 0207 	bfi	r2, r3, #0, #8
    c748:	4807      	ldr	r0, [pc, #28]	; (c768 <sc_store+0x60>)
    c74a:	4b08      	ldr	r3, [pc, #32]	; (c76c <sc_store+0x64>)
    c74c:	1a1b      	subs	r3, r3, r0
    c74e:	08db      	lsrs	r3, r3, #3
    c750:	f363 128f 	bfi	r2, r3, #6, #10
    c754:	4806      	ldr	r0, [pc, #24]	; (c770 <sc_store+0x68>)
    c756:	f014 fc7d 	bl	21054 <log_1>
}
    c75a:	b00c      	add	sp, #48	; 0x30
    c75c:	bd70      	pop	{r4, r5, r6, pc}
		bt_settings_encode_key(key, sizeof(key), "sc",
    c75e:	9200      	str	r2, [sp, #0]
    c760:	e7df      	b.n	c722 <sc_store+0x1a>
    c762:	bf00      	nop
    c764:	00063c94 	.word	0x00063c94
    c768:	00028540 	.word	0x00028540
    c76c:	00028608 	.word	0x00028608
    c770:	00063c6f 	.word	0x00063c6f

0000c774 <gatt_notify>:
{
    c774:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c778:	4614      	mov	r4, r2
				sizeof(*nfy) + params->len);
    c77a:	8992      	ldrh	r2, [r2, #12]
{
    c77c:	4689      	mov	r9, r1
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
    c77e:	3202      	adds	r2, #2
    c780:	211b      	movs	r1, #27
{
    c782:	4680      	mov	r8, r0
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
    c784:	f7ff f8c8 	bl	b918 <bt_att_create_pdu>
	if (!buf) {
    c788:	4605      	mov	r5, r0
    c78a:	b1c8      	cbz	r0, c7c0 <gatt_notify+0x4c>
	nfy = net_buf_add(buf, sizeof(*nfy));
    c78c:	f100 0708 	add.w	r7, r0, #8
    c790:	2102      	movs	r1, #2
    c792:	4638      	mov	r0, r7
    c794:	f018 fb20 	bl	24dd8 <net_buf_simple_add>
	nfy->handle = sys_cpu_to_le16(handle);
    c798:	4606      	mov	r6, r0
	net_buf_add(buf, params->len);
    c79a:	89a1      	ldrh	r1, [r4, #12]
	nfy->handle = sys_cpu_to_le16(handle);
    c79c:	f826 9b02 	strh.w	r9, [r6], #2
	net_buf_add(buf, params->len);
    c7a0:	4638      	mov	r0, r7
    c7a2:	f018 fb19 	bl	24dd8 <net_buf_simple_add>
    c7a6:	89a2      	ldrh	r2, [r4, #12]
    c7a8:	68a1      	ldr	r1, [r4, #8]
    c7aa:	4630      	mov	r0, r6
    c7ac:	f7f5 fa1e 	bl	1bec <memcpy>
	return bt_att_send(conn, buf, params->func, params->user_data);
    c7b0:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    c7b4:	4629      	mov	r1, r5
    c7b6:	4640      	mov	r0, r8
}
    c7b8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return bt_att_send(conn, buf, params->func, params->user_data);
    c7bc:	f016 bbff 	b.w	22fbe <bt_att_send>
		BT_WARN("No buffer available to send notification");
    c7c0:	2302      	movs	r3, #2
    c7c2:	f04f 0100 	mov.w	r1, #0
    c7c6:	4a07      	ldr	r2, [pc, #28]	; (c7e4 <gatt_notify+0x70>)
    c7c8:	4807      	ldr	r0, [pc, #28]	; (c7e8 <gatt_notify+0x74>)
    c7ca:	f363 0107 	bfi	r1, r3, #0, #8
    c7ce:	4b07      	ldr	r3, [pc, #28]	; (c7ec <gatt_notify+0x78>)
    c7d0:	1a9b      	subs	r3, r3, r2
    c7d2:	08db      	lsrs	r3, r3, #3
    c7d4:	f363 118f 	bfi	r1, r3, #6, #10
    c7d8:	f014 fc2f 	bl	2103a <log_0>
}
    c7dc:	f06f 000b 	mvn.w	r0, #11
    c7e0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    c7e4:	00028540 	.word	0x00028540
    c7e8:	00063b8f 	.word	0x00063b8f
    c7ec:	00028608 	.word	0x00028608

0000c7f0 <sc_clear>:
{
    c7f0:	b570      	push	{r4, r5, r6, lr}
		if (cfg->data.start || cfg->data.end) {
    c7f2:	8903      	ldrh	r3, [r0, #8]
{
    c7f4:	b08c      	sub	sp, #48	; 0x30
    c7f6:	4604      	mov	r4, r0
		if (cfg->data.start || cfg->data.end) {
    c7f8:	b90b      	cbnz	r3, c7fe <sc_clear+0xe>
    c7fa:	8943      	ldrh	r3, [r0, #10]
    c7fc:	b33b      	cbz	r3, c84e <sc_clear+0x5e>
		if (modified && bt_addr_le_is_bonded(cfg->id, &cfg->peer)) {
    c7fe:	4625      	mov	r5, r4
    c800:	f815 0b01 	ldrb.w	r0, [r5], #1
    c804:	4629      	mov	r1, r5
    c806:	f015 feca 	bl	2259e <bt_addr_le_is_bonded>
    c80a:	b300      	cbz	r0, c84e <sc_clear+0x5e>
			if (cfg->id) {
    c80c:	7822      	ldrb	r2, [r4, #0]
    c80e:	b322      	cbz	r2, c85a <sc_clear+0x6a>
				u8_to_dec(id_str, sizeof(id_str), cfg->id);
    c810:	ae02      	add	r6, sp, #8
    c812:	2104      	movs	r1, #4
    c814:	4630      	mov	r0, r6
    c816:	f012 ff0f 	bl	1f638 <u8_to_dec>
				bt_settings_encode_key(key, sizeof(key), "sc",
    c81a:	9600      	str	r6, [sp, #0]
				bt_settings_encode_key(key, sizeof(key), "sc",
    c81c:	2124      	movs	r1, #36	; 0x24
    c81e:	462b      	mov	r3, r5
    c820:	4a0f      	ldr	r2, [pc, #60]	; (c860 <sc_clear+0x70>)
    c822:	a803      	add	r0, sp, #12
    c824:	f7fb fac4 	bl	7db0 <bt_settings_encode_key>
			err = settings_delete(key);
    c828:	a803      	add	r0, sp, #12
    c82a:	f015 f870 	bl	2190e <settings_delete>
			if (err) {
    c82e:	4601      	mov	r1, r0
    c830:	b168      	cbz	r0, c84e <sc_clear+0x5e>
				BT_ERR("failed to delete SC (err %d)", err);
    c832:	2301      	movs	r3, #1
    c834:	f04f 0200 	mov.w	r2, #0
    c838:	f363 0207 	bfi	r2, r3, #0, #8
    c83c:	4809      	ldr	r0, [pc, #36]	; (c864 <sc_clear+0x74>)
    c83e:	4b0a      	ldr	r3, [pc, #40]	; (c868 <sc_clear+0x78>)
    c840:	1a1b      	subs	r3, r3, r0
    c842:	08db      	lsrs	r3, r3, #3
    c844:	f363 128f 	bfi	r2, r3, #6, #10
    c848:	4808      	ldr	r0, [pc, #32]	; (c86c <sc_clear+0x7c>)
    c84a:	f014 fc03 	bl	21054 <log_1>
__ssp_bos_icheck3(memset, void *, int)
    c84e:	2300      	movs	r3, #0
    c850:	6023      	str	r3, [r4, #0]
    c852:	6063      	str	r3, [r4, #4]
    c854:	60a3      	str	r3, [r4, #8]
}
    c856:	b00c      	add	sp, #48	; 0x30
    c858:	bd70      	pop	{r4, r5, r6, pc}
				bt_settings_encode_key(key, sizeof(key), "sc",
    c85a:	9200      	str	r2, [sp, #0]
    c85c:	e7de      	b.n	c81c <sc_clear+0x2c>
    c85e:	bf00      	nop
    c860:	00063c94 	.word	0x00063c94
    c864:	00028540 	.word	0x00028540
    c868:	00028608 	.word	0x00028608
    c86c:	00063bf5 	.word	0x00063bf5

0000c870 <disconnected_cb>:
	if (attr->write != bt_gatt_attr_write_ccc) {
    c870:	6882      	ldr	r2, [r0, #8]
    c872:	4b1f      	ldr	r3, [pc, #124]	; (c8f0 <disconnected_cb+0x80>)
    c874:	429a      	cmp	r2, r3
{
    c876:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c87a:	4607      	mov	r7, r0
    c87c:	460e      	mov	r6, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
    c87e:	d102      	bne.n	c886 <disconnected_cb+0x16>
	ccc = attr->user_data;
    c880:	68c4      	ldr	r4, [r0, #12]
	if (!ccc->value) {
    c882:	8963      	ldrh	r3, [r4, #10]
    c884:	b9eb      	cbnz	r3, c8c2 <disconnected_cb+0x52>
}
    c886:	2001      	movs	r0, #1
    c888:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		    bt_conn_addr_le_cmp(conn, &cfg->peer)) {
    c88c:	4629      	mov	r1, r5
    c88e:	4630      	mov	r0, r6
    c890:	f015 ff2d 	bl	226ee <bt_conn_addr_le_cmp>
		if (conn->id != cfg->id ||
    c894:	b9e8      	cbnz	r0, c8d2 <disconnected_cb+0x62>
			if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    c896:	f106 0874 	add.w	r8, r6, #116	; 0x74
    c89a:	4641      	mov	r1, r8
    c89c:	7a30      	ldrb	r0, [r6, #8]
    c89e:	f015 fe7e 	bl	2259e <bt_addr_le_is_bonded>
    c8a2:	b948      	cbnz	r0, c8b8 <disconnected_cb+0x48>
				clear_ccc_cfg(cfg);
    c8a4:	4620      	mov	r0, r4
    c8a6:	f016 fc83 	bl	231b0 <clear_ccc_cfg>
    c8aa:	e018      	b.n	c8de <disconnected_cb+0x6e>
				if (tmp->state == BT_CONN_CONNECTED) {
    c8ac:	7b45      	ldrb	r5, [r0, #13]
				bt_conn_unref(tmp);
    c8ae:	f015 ff36 	bl	2271e <bt_conn_unref>
	if (!value_used) {
    c8b2:	2d06      	cmp	r5, #6
    c8b4:	d0e7      	beq.n	c886 <disconnected_cb+0x16>
    c8b6:	e012      	b.n	c8de <disconnected_cb+0x6e>
				bt_addr_le_copy(&cfg->peer, &conn->le.dst);
    c8b8:	4641      	mov	r1, r8
    c8ba:	4628      	mov	r0, r5
    c8bc:	f016 fc71 	bl	231a2 <bt_addr_le_copy>
    c8c0:	e00d      	b.n	c8de <disconnected_cb+0x6e>
		if (!cfg->value) {
    c8c2:	8923      	ldrh	r3, [r4, #8]
    c8c4:	b15b      	cbz	r3, c8de <disconnected_cb+0x6e>
		if (conn->id != cfg->id ||
    c8c6:	4625      	mov	r5, r4
    c8c8:	7a32      	ldrb	r2, [r6, #8]
    c8ca:	f815 3b01 	ldrb.w	r3, [r5], #1
    c8ce:	429a      	cmp	r2, r3
    c8d0:	d0dc      	beq.n	c88c <disconnected_cb+0x1c>
			tmp = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
    c8d2:	4629      	mov	r1, r5
    c8d4:	7820      	ldrb	r0, [r4, #0]
    c8d6:	f7fe faab 	bl	ae30 <bt_conn_lookup_addr_le>
			if (tmp) {
    c8da:	2800      	cmp	r0, #0
    c8dc:	d1e6      	bne.n	c8ac <disconnected_cb+0x3c>
		if (ccc->cfg_changed) {
    c8de:	68e3      	ldr	r3, [r4, #12]
		ccc->value = 0U;
    c8e0:	2100      	movs	r1, #0
    c8e2:	8161      	strh	r1, [r4, #10]
		if (ccc->cfg_changed) {
    c8e4:	2b00      	cmp	r3, #0
    c8e6:	d0ce      	beq.n	c886 <disconnected_cb+0x16>
			ccc->cfg_changed(attr, ccc->value);
    c8e8:	4638      	mov	r0, r7
    c8ea:	4798      	blx	r3
    c8ec:	e7cb      	b.n	c886 <disconnected_cb+0x16>
    c8ee:	bf00      	nop
    c8f0:	0000cb45 	.word	0x0000cb45

0000c8f4 <read_ppcp>:
{
    c8f4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    c8f6:	4610      	mov	r0, r2
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_SLAVE_LATENCY);
    c8f8:	4a07      	ldr	r2, [pc, #28]	; (c918 <read_ppcp+0x24>)
{
    c8fa:	4619      	mov	r1, r3
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_SLAVE_LATENCY);
    c8fc:	f44f 1328 	mov.w	r3, #2752512	; 0x2a0000
    c900:	e9cd 2302 	strd	r2, r3, [sp, #8]
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &ppcp,
    c904:	2308      	movs	r3, #8
    c906:	9300      	str	r3, [sp, #0]
    c908:	f8bd 2018 	ldrh.w	r2, [sp, #24]
    c90c:	446b      	add	r3, sp
    c90e:	f016 fc83 	bl	23218 <bt_gatt_attr_read.constprop.33>
}
    c912:	b005      	add	sp, #20
    c914:	f85d fb04 	ldr.w	pc, [sp], #4
    c918:	00280018 	.word	0x00280018

0000c91c <gatt_send.constprop.36>:
static int gatt_send(struct bt_conn *conn, struct net_buf *buf,
    c91c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c920:	4606      	mov	r6, r0
    c922:	4688      	mov	r8, r1
    c924:	4617      	mov	r7, r2
	if (params) {
    c926:	461c      	mov	r4, r3
    c928:	b343      	cbz	r3, c97c <gatt_send.constprop.36+0x60>
		req = bt_att_req_alloc(BT_ATT_TIMEOUT);
    c92a:	f247 5030 	movw	r0, #30000	; 0x7530
    c92e:	f7ff fd01 	bl	c334 <bt_att_req_alloc>
		if (!req) {
    c932:	4605      	mov	r5, r0
    c934:	b348      	cbz	r0, c98a <gatt_send.constprop.36+0x6e>
		req->destroy = destroy;
    c936:	2300      	movs	r3, #0
		req->user_data = params;
    c938:	6184      	str	r4, [r0, #24]
		req->buf = buf;
    c93a:	f8c0 8010 	str.w	r8, [r0, #16]
		req->func = func;
    c93e:	6047      	str	r7, [r0, #4]
		req->destroy = destroy;
    c940:	6083      	str	r3, [r0, #8]
		err = bt_att_req_send(conn, req);
    c942:	4601      	mov	r1, r0
    c944:	4630      	mov	r0, r6
    c946:	f016 fb6a 	bl	2301e <bt_att_req_send>
		if (err) {
    c94a:	4604      	mov	r4, r0
    c94c:	b918      	cbnz	r0, c956 <gatt_send.constprop.36+0x3a>
static int gatt_send(struct bt_conn *conn, struct net_buf *buf,
    c94e:	2400      	movs	r4, #0
}
    c950:	4620      	mov	r0, r4
    c952:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			bt_att_req_free(req);
    c956:	4628      	mov	r0, r5
    c958:	f7ff fd00 	bl	c35c <bt_att_req_free>
		BT_ERR("Error sending ATT PDU: %d", err);
    c95c:	2301      	movs	r3, #1
    c95e:	f04f 0200 	mov.w	r2, #0
    c962:	f363 0207 	bfi	r2, r3, #0, #8
    c966:	490a      	ldr	r1, [pc, #40]	; (c990 <gatt_send.constprop.36+0x74>)
    c968:	4b0a      	ldr	r3, [pc, #40]	; (c994 <gatt_send.constprop.36+0x78>)
    c96a:	480b      	ldr	r0, [pc, #44]	; (c998 <gatt_send.constprop.36+0x7c>)
    c96c:	1a5b      	subs	r3, r3, r1
    c96e:	08db      	lsrs	r3, r3, #3
    c970:	f363 128f 	bfi	r2, r3, #6, #10
    c974:	4621      	mov	r1, r4
    c976:	f014 fb6d 	bl	21054 <log_1>
    c97a:	e7e9      	b.n	c950 <gatt_send.constprop.36+0x34>
		err = bt_att_send(conn, buf, NULL, NULL);
    c97c:	461a      	mov	r2, r3
    c97e:	f016 fb1e 	bl	22fbe <bt_att_send>
	if (err) {
    c982:	4604      	mov	r4, r0
    c984:	2800      	cmp	r0, #0
    c986:	d0e2      	beq.n	c94e <gatt_send.constprop.36+0x32>
    c988:	e7e8      	b.n	c95c <gatt_send.constprop.36+0x40>
			return -ENOMEM;
    c98a:	f06f 040b 	mvn.w	r4, #11
    c98e:	e7df      	b.n	c950 <gatt_send.constprop.36+0x34>
    c990:	00028540 	.word	0x00028540
    c994:	00028608 	.word	0x00028608
    c998:	00063bdb 	.word	0x00063bdb

0000c99c <gatt_indicate>:
{
    c99c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c9a0:	4614      	mov	r4, r2
				sizeof(*ind) + params->len);
    c9a2:	8a12      	ldrh	r2, [r2, #16]
{
    c9a4:	4689      	mov	r9, r1
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE,
    c9a6:	3202      	adds	r2, #2
    c9a8:	211d      	movs	r1, #29
{
    c9aa:	4680      	mov	r8, r0
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE,
    c9ac:	f7fe ffb4 	bl	b918 <bt_att_create_pdu>
	if (!buf) {
    c9b0:	4605      	mov	r5, r0
    c9b2:	b1e8      	cbz	r0, c9f0 <gatt_indicate+0x54>
	ind = net_buf_add(buf, sizeof(*ind));
    c9b4:	f100 0608 	add.w	r6, r0, #8
    c9b8:	2102      	movs	r1, #2
    c9ba:	4630      	mov	r0, r6
    c9bc:	f018 fa0c 	bl	24dd8 <net_buf_simple_add>
	ind->handle = sys_cpu_to_le16(handle);
    c9c0:	4607      	mov	r7, r0
	net_buf_add(buf, params->len);
    c9c2:	8a21      	ldrh	r1, [r4, #16]
	ind->handle = sys_cpu_to_le16(handle);
    c9c4:	f827 9b02 	strh.w	r9, [r7], #2
	net_buf_add(buf, params->len);
    c9c8:	4630      	mov	r0, r6
    c9ca:	f018 fa05 	bl	24dd8 <net_buf_simple_add>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    c9ce:	8a22      	ldrh	r2, [r4, #16]
    c9d0:	68e1      	ldr	r1, [r4, #12]
    c9d2:	4638      	mov	r0, r7
    c9d4:	f7f5 f90a 	bl	1bec <memcpy>
	if (!params->func) {
    c9d8:	68a3      	ldr	r3, [r4, #8]
    c9da:	b933      	cbnz	r3, c9ea <gatt_indicate+0x4e>
		return gatt_send(conn, buf, NULL, NULL, NULL);
    c9dc:	461a      	mov	r2, r3
	return gatt_send(conn, buf, gatt_indicate_rsp, params, NULL);
    c9de:	4629      	mov	r1, r5
    c9e0:	4640      	mov	r0, r8
}
    c9e2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return gatt_send(conn, buf, gatt_indicate_rsp, params, NULL);
    c9e6:	f7ff bf99 	b.w	c91c <gatt_send.constprop.36>
    c9ea:	4623      	mov	r3, r4
    c9ec:	4a09      	ldr	r2, [pc, #36]	; (ca14 <gatt_indicate+0x78>)
    c9ee:	e7f6      	b.n	c9de <gatt_indicate+0x42>
		BT_WARN("No buffer available to send indication");
    c9f0:	2302      	movs	r3, #2
    c9f2:	f04f 0100 	mov.w	r1, #0
    c9f6:	4a08      	ldr	r2, [pc, #32]	; (ca18 <gatt_indicate+0x7c>)
    c9f8:	4808      	ldr	r0, [pc, #32]	; (ca1c <gatt_indicate+0x80>)
    c9fa:	f363 0107 	bfi	r1, r3, #0, #8
    c9fe:	4b08      	ldr	r3, [pc, #32]	; (ca20 <gatt_indicate+0x84>)
    ca00:	1a9b      	subs	r3, r3, r2
    ca02:	08db      	lsrs	r3, r3, #3
    ca04:	f363 118f 	bfi	r1, r3, #6, #10
    ca08:	f014 fb17 	bl	2103a <log_0>
}
    ca0c:	f06f 000b 	mvn.w	r0, #11
    ca10:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ca14:	00023077 	.word	0x00023077
    ca18:	00028540 	.word	0x00028540
    ca1c:	00063b68 	.word	0x00063b68
    ca20:	00028608 	.word	0x00028608

0000ca24 <ccc_save>:
{
    ca24:	b538      	push	{r3, r4, r5, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
    ca26:	6882      	ldr	r2, [r0, #8]
    ca28:	4b0b      	ldr	r3, [pc, #44]	; (ca58 <ccc_save+0x34>)
    ca2a:	429a      	cmp	r2, r3
{
    ca2c:	4605      	mov	r5, r0
    ca2e:	460c      	mov	r4, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
    ca30:	d110      	bne.n	ca54 <ccc_save+0x30>
	cfg = ccc_find_cfg(ccc, save->addr_with_id.addr, save->addr_with_id.id);
    ca32:	790a      	ldrb	r2, [r1, #4]
    ca34:	68c0      	ldr	r0, [r0, #12]
    ca36:	6809      	ldr	r1, [r1, #0]
    ca38:	f016 fc5c 	bl	232f4 <ccc_find_cfg>
	if (!cfg) {
    ca3c:	b150      	cbz	r0, ca54 <ccc_save+0x30>
	save->store[save->count].handle = attr->handle;
    ca3e:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
    ca42:	8a29      	ldrh	r1, [r5, #16]
    ca44:	eb04 0283 	add.w	r2, r4, r3, lsl #2
	save->count++;
    ca48:	3301      	adds	r3, #1
	save->store[save->count].handle = attr->handle;
    ca4a:	8111      	strh	r1, [r2, #8]
	save->store[save->count].value = cfg->value;
    ca4c:	8901      	ldrh	r1, [r0, #8]
    ca4e:	8151      	strh	r1, [r2, #10]
	save->count++;
    ca50:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
}
    ca54:	2001      	movs	r0, #1
    ca56:	bd38      	pop	{r3, r4, r5, pc}
    ca58:	0000cb45 	.word	0x0000cb45

0000ca5c <ccc_load>:
{
    ca5c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
    ca5e:	4b21      	ldr	r3, [pc, #132]	; (cae4 <ccc_load+0x88>)
    ca60:	6882      	ldr	r2, [r0, #8]
    ca62:	429a      	cmp	r2, r3
{
    ca64:	460c      	mov	r4, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
    ca66:	d002      	beq.n	ca6e <ccc_load+0x12>
		return BT_GATT_ITER_CONTINUE;
    ca68:	2001      	movs	r0, #1
}
    ca6a:	b003      	add	sp, #12
    ca6c:	bd30      	pop	{r4, r5, pc}
	if (!load->entry) {
    ca6e:	688a      	ldr	r2, [r1, #8]
	ccc = attr->user_data;
    ca70:	68c5      	ldr	r5, [r0, #12]
	if (!load->entry) {
    ca72:	b94a      	cbnz	r2, ca88 <ccc_load+0x2c>
	cfg = ccc_find_cfg(ccc, addr, id);
    ca74:	790a      	ldrb	r2, [r1, #4]
    ca76:	6809      	ldr	r1, [r1, #0]
    ca78:	4628      	mov	r0, r5
    ca7a:	f016 fc3b 	bl	232f4 <ccc_find_cfg>
	if (!cfg) {
    ca7e:	2800      	cmp	r0, #0
    ca80:	d0f2      	beq.n	ca68 <ccc_load+0xc>
	clear_ccc_cfg(cfg);
    ca82:	f016 fb95 	bl	231b0 <clear_ccc_cfg>
    ca86:	e7ef      	b.n	ca68 <ccc_load+0xc>
	} else if (!load->count) {
    ca88:	68cb      	ldr	r3, [r1, #12]
    ca8a:	b34b      	cbz	r3, cae0 <ccc_load+0x84>
	if (load->entry->handle != attr->handle) {
    ca8c:	8812      	ldrh	r2, [r2, #0]
    ca8e:	8a03      	ldrh	r3, [r0, #16]
    ca90:	429a      	cmp	r2, r3
    ca92:	d00a      	beq.n	caaa <ccc_load+0x4e>
		if (load->entry->handle < attr->handle) {
    ca94:	d2e8      	bcs.n	ca68 <ccc_load+0xc>
	load->count--;
    ca96:	68e0      	ldr	r0, [r4, #12]
	load->entry++;
    ca98:	68a3      	ldr	r3, [r4, #8]
	load->count--;
    ca9a:	3801      	subs	r0, #1
	load->entry++;
    ca9c:	3304      	adds	r3, #4
	load->count--;
    ca9e:	60e0      	str	r0, [r4, #12]
	return load->count ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
    caa0:	3000      	adds	r0, #0
	load->entry++;
    caa2:	60a3      	str	r3, [r4, #8]
	return load->count ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
    caa4:	bf18      	it	ne
    caa6:	2001      	movne	r0, #1
    caa8:	e7df      	b.n	ca6a <ccc_load+0xe>
	cfg = ccc_find_cfg(ccc, load->addr_with_id.addr, load->addr_with_id.id);
    caaa:	790a      	ldrb	r2, [r1, #4]
    caac:	6809      	ldr	r1, [r1, #0]
    caae:	4628      	mov	r0, r5
    cab0:	f016 fc20 	bl	232f4 <ccc_find_cfg>
	if (!cfg) {
    cab4:	4602      	mov	r2, r0
    cab6:	b978      	cbnz	r0, cad8 <ccc_load+0x7c>
		cfg = ccc_find_cfg(ccc, BT_ADDR_LE_ANY, 0);
    cab8:	9000      	str	r0, [sp, #0]
    caba:	4669      	mov	r1, sp
    cabc:	f8cd 0003 	str.w	r0, [sp, #3]
    cac0:	4628      	mov	r0, r5
    cac2:	f016 fc17 	bl	232f4 <ccc_find_cfg>
		if (!cfg) {
    cac6:	4602      	mov	r2, r0
    cac8:	2800      	cmp	r0, #0
    caca:	d0e4      	beq.n	ca96 <ccc_load+0x3a>
		bt_addr_le_copy(&cfg->peer, load->addr_with_id.addr);
    cacc:	6821      	ldr	r1, [r4, #0]
    cace:	3001      	adds	r0, #1
    cad0:	f016 fb67 	bl	231a2 <bt_addr_le_copy>
		cfg->id = load->addr_with_id.id;
    cad4:	7923      	ldrb	r3, [r4, #4]
    cad6:	7013      	strb	r3, [r2, #0]
	cfg->value = load->entry->value;
    cad8:	68a3      	ldr	r3, [r4, #8]
    cada:	885b      	ldrh	r3, [r3, #2]
    cadc:	8113      	strh	r3, [r2, #8]
    cade:	e7da      	b.n	ca96 <ccc_load+0x3a>
		return BT_GATT_ITER_STOP;
    cae0:	4618      	mov	r0, r3
    cae2:	e7c2      	b.n	ca6a <ccc_load+0xe>
    cae4:	0000cb45 	.word	0x0000cb45

0000cae8 <remove_peer_from_attr>:
{
    cae8:	b508      	push	{r3, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
    caea:	6882      	ldr	r2, [r0, #8]
    caec:	4b07      	ldr	r3, [pc, #28]	; (cb0c <remove_peer_from_attr+0x24>)
    caee:	429a      	cmp	r2, r3
    caf0:	d109      	bne.n	cb06 <remove_peer_from_attr+0x1e>
	cfg = ccc_find_cfg(ccc, addr_with_id->addr, addr_with_id->id);
    caf2:	790a      	ldrb	r2, [r1, #4]
    caf4:	68c0      	ldr	r0, [r0, #12]
    caf6:	6809      	ldr	r1, [r1, #0]
    caf8:	f016 fbfc 	bl	232f4 <ccc_find_cfg>
	if (cfg) {
    cafc:	b118      	cbz	r0, cb06 <remove_peer_from_attr+0x1e>
__ssp_bos_icheck3(memset, void *, int)
    cafe:	2300      	movs	r3, #0
    cb00:	6003      	str	r3, [r0, #0]
    cb02:	6043      	str	r3, [r0, #4]
    cb04:	8103      	strh	r3, [r0, #8]
}
    cb06:	2001      	movs	r0, #1
    cb08:	bd08      	pop	{r3, pc}
    cb0a:	bf00      	nop
    cb0c:	0000cb45 	.word	0x0000cb45

0000cb10 <find_cf_cfg_by_addr.part.12>:
static struct gatt_cf_cfg *find_cf_cfg_by_addr(const bt_addr_le_t *addr)
    cb10:	b538      	push	{r3, r4, r5, lr}
    cb12:	2207      	movs	r2, #7
    cb14:	4909      	ldr	r1, [pc, #36]	; (cb3c <find_cf_cfg_by_addr.part.12+0x2c>)
    cb16:	4c0a      	ldr	r4, [pc, #40]	; (cb40 <find_cf_cfg_by_addr.part.12+0x30>)
    cb18:	4605      	mov	r5, r0
    cb1a:	f7f5 f859 	bl	1bd0 <memcmp>
		if (!bt_addr_le_cmp(addr, &cf_cfg[i].peer)) {
    cb1e:	b138      	cbz	r0, cb30 <find_cf_cfg_by_addr.part.12+0x20>
    cb20:	2207      	movs	r2, #7
    cb22:	f104 0111 	add.w	r1, r4, #17
    cb26:	4628      	mov	r0, r5
    cb28:	f7f5 f852 	bl	1bd0 <memcmp>
    cb2c:	b918      	cbnz	r0, cb36 <find_cf_cfg_by_addr.part.12+0x26>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    cb2e:	2001      	movs	r0, #1
			return &cf_cfg[i];
    cb30:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}
    cb34:	bd38      	pop	{r3, r4, r5, pc}
	return NULL;
    cb36:	2000      	movs	r0, #0
    cb38:	e7fc      	b.n	cb34 <find_cf_cfg_by_addr.part.12+0x24>
    cb3a:	bf00      	nop
    cb3c:	20000531 	.word	0x20000531
    cb40:	20000530 	.word	0x20000530

0000cb44 <bt_gatt_attr_write_ccc>:
{
    cb44:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    cb48:	4698      	mov	r8, r3
    cb4a:	f8bd 3020 	ldrh.w	r3, [sp, #32]
	struct _bt_gatt_ccc *ccc = attr->user_data;
    cb4e:	68ce      	ldr	r6, [r1, #12]
{
    cb50:	4607      	mov	r7, r0
    cb52:	4689      	mov	r9, r1
	if (offset) {
    cb54:	2b00      	cmp	r3, #0
    cb56:	d14e      	bne.n	cbf6 <bt_gatt_attr_write_ccc+0xb2>
	if (!len || len > sizeof(u16_t)) {
    cb58:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
    cb5c:	2b01      	cmp	r3, #1
    cb5e:	d84d      	bhi.n	cbfc <bt_gatt_attr_write_ccc+0xb8>
	if (len < sizeof(u16_t)) {
    cb60:	f1b8 0f01 	cmp.w	r8, #1
		value = *(u8_t *)buf;
    cb64:	7814      	ldrb	r4, [r2, #0]
	return ((u16_t)src[1] << 8) | src[0];
    cb66:	bf18      	it	ne
    cb68:	7853      	ldrbne	r3, [r2, #1]
	cfg = find_ccc_cfg(conn, ccc);
    cb6a:	4631      	mov	r1, r6
		value = *(u8_t *)buf;
    cb6c:	bf0c      	ite	eq
    cb6e:	b2a4      	uxtheq	r4, r4
    cb70:	ea44 2403 	orrne.w	r4, r4, r3, lsl #8
	cfg = find_ccc_cfg(conn, ccc);
    cb74:	f016 fbcd 	bl	23312 <find_ccc_cfg>
	if (!cfg) {
    cb78:	4605      	mov	r5, r0
    cb7a:	bb00      	cbnz	r0, cbbe <bt_gatt_attr_write_ccc+0x7a>
		if (!value) {
    cb7c:	b914      	cbnz	r4, cb84 <bt_gatt_attr_write_ccc+0x40>
			return len;
    cb7e:	4640      	mov	r0, r8
}
    cb80:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		cfg = find_ccc_cfg(NULL, ccc);
    cb84:	4631      	mov	r1, r6
    cb86:	f016 fbc4 	bl	23312 <find_ccc_cfg>
		if (!cfg) {
    cb8a:	4605      	mov	r5, r0
    cb8c:	b980      	cbnz	r0, cbb0 <bt_gatt_attr_write_ccc+0x6c>
			BT_WARN("No space to store CCC cfg");
    cb8e:	2302      	movs	r3, #2
    cb90:	f04f 0100 	mov.w	r1, #0
    cb94:	f363 0107 	bfi	r1, r3, #0, #8
    cb98:	4a1a      	ldr	r2, [pc, #104]	; (cc04 <bt_gatt_attr_write_ccc+0xc0>)
    cb9a:	4b1b      	ldr	r3, [pc, #108]	; (cc08 <bt_gatt_attr_write_ccc+0xc4>)
    cb9c:	481b      	ldr	r0, [pc, #108]	; (cc0c <bt_gatt_attr_write_ccc+0xc8>)
    cb9e:	1a9b      	subs	r3, r3, r2
    cba0:	08db      	lsrs	r3, r3, #3
    cba2:	f363 118f 	bfi	r1, r3, #6, #10
    cba6:	f014 fa48 	bl	2103a <log_0>
			return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
    cbaa:	f06f 0010 	mvn.w	r0, #16
    cbae:	e7e7      	b.n	cb80 <bt_gatt_attr_write_ccc+0x3c>
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
    cbb0:	f107 0174 	add.w	r1, r7, #116	; 0x74
    cbb4:	3001      	adds	r0, #1
    cbb6:	f016 faf4 	bl	231a2 <bt_addr_le_copy>
		cfg->id = conn->id;
    cbba:	7a3b      	ldrb	r3, [r7, #8]
    cbbc:	702b      	strb	r3, [r5, #0]
	if (ccc->cfg_write) {
    cbbe:	6933      	ldr	r3, [r6, #16]
    cbc0:	b96b      	cbnz	r3, cbde <bt_gatt_attr_write_ccc+0x9a>
	if (cfg->value != ccc->value) {
    cbc2:	8973      	ldrh	r3, [r6, #10]
	cfg->value = value;
    cbc4:	812c      	strh	r4, [r5, #8]
	if (cfg->value != ccc->value) {
    cbc6:	42a3      	cmp	r3, r4
    cbc8:	d003      	beq.n	cbd2 <bt_gatt_attr_write_ccc+0x8e>
		gatt_ccc_changed(attr, ccc);
    cbca:	4631      	mov	r1, r6
    cbcc:	4648      	mov	r0, r9
    cbce:	f016 fa48 	bl	23062 <gatt_ccc_changed>
	if (!value) {
    cbd2:	2c00      	cmp	r4, #0
    cbd4:	d1d3      	bne.n	cb7e <bt_gatt_attr_write_ccc+0x3a>
		clear_ccc_cfg(cfg);
    cbd6:	4628      	mov	r0, r5
    cbd8:	f016 faea 	bl	231b0 <clear_ccc_cfg>
    cbdc:	e7cf      	b.n	cb7e <bt_gatt_attr_write_ccc+0x3a>
		ssize_t write = ccc->cfg_write(conn, attr, value);
    cbde:	4622      	mov	r2, r4
    cbe0:	4649      	mov	r1, r9
    cbe2:	4638      	mov	r0, r7
    cbe4:	4798      	blx	r3
		if (write < 0) {
    cbe6:	2800      	cmp	r0, #0
    cbe8:	dbca      	blt.n	cb80 <bt_gatt_attr_write_ccc+0x3c>
		if (write != sizeof(value) && write != 1) {
    cbea:	3801      	subs	r0, #1
    cbec:	2801      	cmp	r0, #1
    cbee:	d9e8      	bls.n	cbc2 <bt_gatt_attr_write_ccc+0x7e>
			return BT_GATT_ERR(BT_ATT_ERR_UNLIKELY);
    cbf0:	f06f 000d 	mvn.w	r0, #13
    cbf4:	e7c4      	b.n	cb80 <bt_gatt_attr_write_ccc+0x3c>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
    cbf6:	f06f 0006 	mvn.w	r0, #6
    cbfa:	e7c1      	b.n	cb80 <bt_gatt_attr_write_ccc+0x3c>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
    cbfc:	f06f 000c 	mvn.w	r0, #12
    cc00:	e7be      	b.n	cb80 <bt_gatt_attr_write_ccc+0x3c>
    cc02:	bf00      	nop
    cc04:	00028540 	.word	0x00028540
    cc08:	00028608 	.word	0x00028608
    cc0c:	000639e4 	.word	0x000639e4

0000cc10 <sc_commit>:
{
    cc10:	b508      	push	{r3, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    cc12:	f06f 0102 	mvn.w	r1, #2
    cc16:	4807      	ldr	r0, [pc, #28]	; (cc34 <sc_commit+0x24>)
    cc18:	f016 fab4 	bl	23184 <atomic_and>
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
    cc1c:	2100      	movs	r1, #0
    cc1e:	4805      	ldr	r0, [pc, #20]	; (cc34 <sc_commit+0x24>)
    cc20:	f016 faa7 	bl	23172 <atomic_test_bit>
    cc24:	b120      	cbz	r0, cc30 <sc_commit+0x20>
    cc26:	220a      	movs	r2, #10
    cc28:	4903      	ldr	r1, [pc, #12]	; (cc38 <sc_commit+0x28>)
    cc2a:	4804      	ldr	r0, [pc, #16]	; (cc3c <sc_commit+0x2c>)
    cc2c:	f012 fa18 	bl	1f060 <k_delayed_work_submit_to_queue>
}
    cc30:	2000      	movs	r0, #0
    cc32:	bd08      	pop	{r3, pc}
    cc34:	200005a8 	.word	0x200005a8
    cc38:	20000588 	.word	0x20000588
    cc3c:	20006090 	.word	0x20006090

0000cc40 <gatt_write_ccc.constprop.32>:
static int gatt_write_ccc(struct bt_conn *conn, u16_t handle, u16_t value,
    cc40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    cc44:	4689      	mov	r9, r1
    cc46:	4690      	mov	r8, r2
	buf = bt_att_create_pdu(conn, BT_ATT_OP_WRITE_REQ,
    cc48:	2112      	movs	r1, #18
    cc4a:	2204      	movs	r2, #4
static int gatt_write_ccc(struct bt_conn *conn, u16_t handle, u16_t value,
    cc4c:	4607      	mov	r7, r0
    cc4e:	461d      	mov	r5, r3
	buf = bt_att_create_pdu(conn, BT_ATT_OP_WRITE_REQ,
    cc50:	f7fe fe62 	bl	b918 <bt_att_create_pdu>
	if (!buf) {
    cc54:	4604      	mov	r4, r0
    cc56:	b308      	cbz	r0, cc9c <gatt_write_ccc.constprop.32+0x5c>
	req = net_buf_add(buf, sizeof(*req));
    cc58:	f100 0608 	add.w	r6, r0, #8
    cc5c:	2102      	movs	r1, #2
    cc5e:	4630      	mov	r0, r6
    cc60:	f018 f8ba 	bl	24dd8 <net_buf_simple_add>
	net_buf_add_le16(buf, value);
    cc64:	4641      	mov	r1, r8
	req->handle = sys_cpu_to_le16(handle);
    cc66:	f8a0 9000 	strh.w	r9, [r0]
	net_buf_add_le16(buf, value);
    cc6a:	4630      	mov	r0, r6
    cc6c:	f018 f8cc 	bl	24e08 <net_buf_simple_add_le16>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    cc70:	f3bf 8f5b 	dmb	ish
    cc74:	f105 030c 	add.w	r3, r5, #12
    cc78:	e853 2f00 	ldrex	r2, [r3]
    cc7c:	f042 0204 	orr.w	r2, r2, #4
    cc80:	e843 2100 	strex	r1, r2, [r3]
    cc84:	2900      	cmp	r1, #0
    cc86:	d1f7      	bne.n	cc78 <gatt_write_ccc.constprop.32+0x38>
    cc88:	f3bf 8f5b 	dmb	ish
	return gatt_send(conn, buf, func, params, NULL);
    cc8c:	462b      	mov	r3, r5
    cc8e:	4621      	mov	r1, r4
    cc90:	4638      	mov	r0, r7
    cc92:	4a04      	ldr	r2, [pc, #16]	; (cca4 <gatt_write_ccc.constprop.32+0x64>)
}
    cc94:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return gatt_send(conn, buf, func, params, NULL);
    cc98:	f7ff be40 	b.w	c91c <gatt_send.constprop.36>
}
    cc9c:	f06f 000b 	mvn.w	r0, #11
    cca0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    cca4:	00023447 	.word	0x00023447

0000cca8 <gatt_sub_find_free>:
{
    cca8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    ccaa:	4606      	mov	r6, r0
	if (free_sub) {
    ccac:	460d      	mov	r5, r1
    ccae:	b109      	cbz	r1, ccb4 <gatt_sub_find_free+0xc>
		*free_sub = NULL;
    ccb0:	2300      	movs	r3, #0
    ccb2:	600b      	str	r3, [r1, #0]
		if (!bt_conn_addr_le_cmp(conn, &sub->peer)) {
    ccb4:	4c14      	ldr	r4, [pc, #80]	; (cd08 <gatt_sub_find_free+0x60>)
    ccb6:	4630      	mov	r0, r6
    ccb8:	4621      	mov	r1, r4
    ccba:	f015 fd18 	bl	226ee <bt_conn_addr_le_cmp>
    ccbe:	b300      	cbz	r0, cd02 <gatt_sub_find_free+0x5a>
		} else if (free_sub &&
    ccc0:	b155      	cbz	r5, ccd8 <gatt_sub_find_free+0x30>
			   !bt_addr_le_cmp(BT_ADDR_LE_ANY, &sub->peer)) {
    ccc2:	2300      	movs	r3, #0
    ccc4:	2207      	movs	r2, #7
    ccc6:	4621      	mov	r1, r4
    ccc8:	4668      	mov	r0, sp
    ccca:	9300      	str	r3, [sp, #0]
    cccc:	f8cd 3003 	str.w	r3, [sp, #3]
    ccd0:	f7f4 ff7e 	bl	1bd0 <memcmp>
		} else if (free_sub &&
    ccd4:	b900      	cbnz	r0, ccd8 <gatt_sub_find_free+0x30>
			*free_sub = sub;
    ccd6:	602c      	str	r4, [r5, #0]
		if (!bt_conn_addr_le_cmp(conn, &sub->peer)) {
    ccd8:	4c0c      	ldr	r4, [pc, #48]	; (cd0c <gatt_sub_find_free+0x64>)
    ccda:	4630      	mov	r0, r6
    ccdc:	4621      	mov	r1, r4
    ccde:	f015 fd06 	bl	226ee <bt_conn_addr_le_cmp>
    cce2:	b170      	cbz	r0, cd02 <gatt_sub_find_free+0x5a>
		} else if (free_sub &&
    cce4:	b155      	cbz	r5, ccfc <gatt_sub_find_free+0x54>
			   !bt_addr_le_cmp(BT_ADDR_LE_ANY, &sub->peer)) {
    cce6:	2300      	movs	r3, #0
    cce8:	2207      	movs	r2, #7
    ccea:	4621      	mov	r1, r4
    ccec:	4668      	mov	r0, sp
    ccee:	9300      	str	r3, [sp, #0]
    ccf0:	f8cd 3003 	str.w	r3, [sp, #3]
    ccf4:	f7f4 ff6c 	bl	1bd0 <memcmp>
		} else if (free_sub &&
    ccf8:	b900      	cbnz	r0, ccfc <gatt_sub_find_free+0x54>
			*free_sub = sub;
    ccfa:	602c      	str	r4, [r5, #0]
	return NULL;
    ccfc:	2000      	movs	r0, #0
}
    ccfe:	b002      	add	sp, #8
    cd00:	bd70      	pop	{r4, r5, r6, pc}
		struct gatt_sub *sub = &subscriptions[i];
    cd02:	4620      	mov	r0, r4
    cd04:	e7fb      	b.n	ccfe <gatt_sub_find_free+0x56>
    cd06:	bf00      	nop
    cd08:	200005c4 	.word	0x200005c4
    cd0c:	200005d4 	.word	0x200005d4

0000cd10 <find_sc_cfg.part.10>:
static struct gatt_sc_cfg *find_sc_cfg(u8_t id, bt_addr_le_t *addr)
    cd10:	b570      	push	{r4, r5, r6, lr}
		if (id == sc_cfg[i].id &&
    cd12:	4c0e      	ldr	r4, [pc, #56]	; (cd4c <find_sc_cfg.part.10+0x3c>)
    cd14:	7823      	ldrb	r3, [r4, #0]
    cd16:	4283      	cmp	r3, r0
static struct gatt_sc_cfg *find_sc_cfg(u8_t id, bt_addr_le_t *addr)
    cd18:	4605      	mov	r5, r0
    cd1a:	460e      	mov	r6, r1
		if (id == sc_cfg[i].id &&
    cd1c:	d00a      	beq.n	cd34 <find_sc_cfg.part.10+0x24>
    cd1e:	7b23      	ldrb	r3, [r4, #12]
    cd20:	42ab      	cmp	r3, r5
    cd22:	d111      	bne.n	cd48 <find_sc_cfg.part.10+0x38>
    cd24:	2207      	movs	r2, #7
    cd26:	4631      	mov	r1, r6
    cd28:	4809      	ldr	r0, [pc, #36]	; (cd50 <find_sc_cfg.part.10+0x40>)
    cd2a:	f7f4 ff51 	bl	1bd0 <memcmp>
    cd2e:	b958      	cbnz	r0, cd48 <find_sc_cfg.part.10+0x38>
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    cd30:	2001      	movs	r0, #1
    cd32:	e005      	b.n	cd40 <find_sc_cfg.part.10+0x30>
    cd34:	2207      	movs	r2, #7
    cd36:	1c60      	adds	r0, r4, #1
    cd38:	f7f4 ff4a 	bl	1bd0 <memcmp>
		if (id == sc_cfg[i].id &&
    cd3c:	2800      	cmp	r0, #0
    cd3e:	d1ee      	bne.n	cd1e <find_sc_cfg.part.10+0xe>
			return &sc_cfg[i];
    cd40:	230c      	movs	r3, #12
    cd42:	fb03 4000 	mla	r0, r3, r0, r4
    cd46:	e000      	b.n	cd4a <find_sc_cfg.part.10+0x3a>
	return NULL;
    cd48:	2000      	movs	r0, #0
}
    cd4a:	bd70      	pop	{r4, r5, r6, pc}
    cd4c:	20006124 	.word	0x20006124
    cd50:	20006131 	.word	0x20006131

0000cd54 <sc_save>:
{
    cd54:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    cd58:	4680      	mov	r8, r0
    cd5a:	460f      	mov	r7, r1
    cd5c:	4616      	mov	r6, r2
    cd5e:	461d      	mov	r5, r3
    cd60:	f7ff ffd6 	bl	cd10 <find_sc_cfg.part.10>
	if (!cfg) {
    cd64:	4604      	mov	r4, r0
    cd66:	b9e8      	cbnz	r0, cda4 <sc_save+0x50>
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
    cd68:	4669      	mov	r1, sp
    cd6a:	9000      	str	r0, [sp, #0]
    cd6c:	f8cd 0003 	str.w	r0, [sp, #3]
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    cd70:	f7ff ffce 	bl	cd10 <find_sc_cfg.part.10>
		if (!cfg) {
    cd74:	4604      	mov	r4, r0
    cd76:	b980      	cbnz	r0, cd9a <sc_save+0x46>
			BT_ERR("unable to save SC: no cfg left");
    cd78:	2301      	movs	r3, #1
    cd7a:	f04f 0100 	mov.w	r1, #0
    cd7e:	f363 0107 	bfi	r1, r3, #0, #8
    cd82:	4a15      	ldr	r2, [pc, #84]	; (cdd8 <sc_save+0x84>)
    cd84:	4b15      	ldr	r3, [pc, #84]	; (cddc <sc_save+0x88>)
    cd86:	4816      	ldr	r0, [pc, #88]	; (cde0 <sc_save+0x8c>)
    cd88:	1a9b      	subs	r3, r3, r2
    cd8a:	08db      	lsrs	r3, r3, #3
    cd8c:	f363 118f 	bfi	r1, r3, #6, #10
    cd90:	f014 f953 	bl	2103a <log_0>
}
    cd94:	b002      	add	sp, #8
    cd96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cfg->id = id;
    cd9a:	f800 8b01 	strb.w	r8, [r0], #1
		bt_addr_le_copy(&cfg->peer, peer);
    cd9e:	4639      	mov	r1, r7
    cda0:	f016 f9ff 	bl	231a2 <bt_addr_le_copy>
	if (!(cfg->data.start || cfg->data.end)) {
    cda4:	8922      	ldrh	r2, [r4, #8]
    cda6:	8963      	ldrh	r3, [r4, #10]
    cda8:	b96a      	cbnz	r2, cdc6 <sc_save+0x72>
    cdaa:	b973      	cbnz	r3, cdca <sc_save+0x76>
		cfg->data.start = start;
    cdac:	8126      	strh	r6, [r4, #8]
		*end = new_end;
    cdae:	8165      	strh	r5, [r4, #10]
	    modified && bt_addr_le_is_bonded(cfg->id, &cfg->peer)) {
    cdb0:	4621      	mov	r1, r4
    cdb2:	f811 0b01 	ldrb.w	r0, [r1], #1
    cdb6:	f015 fbf2 	bl	2259e <bt_addr_le_is_bonded>
    cdba:	2800      	cmp	r0, #0
    cdbc:	d0ea      	beq.n	cd94 <sc_save+0x40>
		sc_store(cfg);
    cdbe:	4620      	mov	r0, r4
    cdc0:	f7ff fca2 	bl	c708 <sc_store>
    cdc4:	e7e6      	b.n	cd94 <sc_save+0x40>
	if (new_start >= *start && new_end <= *end) {
    cdc6:	4296      	cmp	r6, r2
    cdc8:	d302      	bcc.n	cdd0 <sc_save+0x7c>
    cdca:	429d      	cmp	r5, r3
    cdcc:	d8ef      	bhi.n	cdae <sc_save+0x5a>
    cdce:	e7e1      	b.n	cd94 <sc_save+0x40>
	if (*end < new_end) {
    cdd0:	429d      	cmp	r5, r3
		*start = new_start;
    cdd2:	8126      	strh	r6, [r4, #8]
	if (*end < new_end) {
    cdd4:	d9ec      	bls.n	cdb0 <sc_save+0x5c>
    cdd6:	e7ea      	b.n	cdae <sc_save+0x5a>
    cdd8:	00028540 	.word	0x00028540
    cddc:	00028608 	.word	0x00028608
    cde0:	00063c12 	.word	0x00063c12

0000cde4 <notify_cb>:
	if (attr->write != bt_gatt_attr_write_ccc) {
    cde4:	6882      	ldr	r2, [r0, #8]
    cde6:	4b33      	ldr	r3, [pc, #204]	; (ceb4 <notify_cb+0xd0>)
    cde8:	429a      	cmp	r2, r3
{
    cdea:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    cdee:	4607      	mov	r7, r0
    cdf0:	460c      	mov	r4, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
    cdf2:	d003      	beq.n	cdfc <notify_cb+0x18>
		return BT_GATT_ITER_CONTINUE;
    cdf4:	2001      	movs	r0, #1
}
    cdf6:	b002      	add	sp, #8
    cdf8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ccc = attr->user_data;
    cdfc:	68c6      	ldr	r6, [r0, #12]
	if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) && ccc == &sc_ccc) {
    cdfe:	4b2e      	ldr	r3, [pc, #184]	; (ceb8 <notify_cb+0xd4>)
    ce00:	429e      	cmp	r6, r3
    ce02:	d02f      	beq.n	ce64 <notify_cb+0x80>
		if (cfg->value != data->type) {
    ce04:	88a2      	ldrh	r2, [r4, #4]
    ce06:	8933      	ldrh	r3, [r6, #8]
    ce08:	429a      	cmp	r2, r3
    ce0a:	d1f3      	bne.n	cdf4 <notify_cb+0x10>
		conn = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
    ce0c:	4631      	mov	r1, r6
    ce0e:	f811 0b01 	ldrb.w	r0, [r1], #1
    ce12:	f7fe f80d 	bl	ae30 <bt_conn_lookup_addr_le>
		if (!conn) {
    ce16:	4605      	mov	r5, r0
    ce18:	2800      	cmp	r0, #0
    ce1a:	d0eb      	beq.n	cdf4 <notify_cb+0x10>
		if (conn->state != BT_CONN_CONNECTED) {
    ce1c:	7b43      	ldrb	r3, [r0, #13]
    ce1e:	2b06      	cmp	r3, #6
    ce20:	d11d      	bne.n	ce5e <notify_cb+0x7a>
		if (ccc->cfg_match && !ccc->cfg_match(conn, attr)) {
    ce22:	6973      	ldr	r3, [r6, #20]
    ce24:	b9b3      	cbnz	r3, ce54 <notify_cb+0x70>
		if (data->type == BT_GATT_CCC_INDICATE) {
    ce26:	8a39      	ldrh	r1, [r7, #16]
    ce28:	88a3      	ldrh	r3, [r4, #4]
    ce2a:	68a2      	ldr	r2, [r4, #8]
    ce2c:	3901      	subs	r1, #1
    ce2e:	2b02      	cmp	r3, #2
    ce30:	b289      	uxth	r1, r1
			err = gatt_indicate(conn, attr->handle - 1,
    ce32:	4628      	mov	r0, r5
		if (data->type == BT_GATT_CCC_INDICATE) {
    ce34:	d10b      	bne.n	ce4e <notify_cb+0x6a>
			err = gatt_indicate(conn, attr->handle - 1,
    ce36:	f7ff fdb1 	bl	c99c <gatt_indicate>
			err = gatt_notify(conn, attr->handle - 1,
    ce3a:	4606      	mov	r6, r0
		bt_conn_unref(conn);
    ce3c:	4628      	mov	r0, r5
    ce3e:	f015 fc6e 	bl	2271e <bt_conn_unref>
		if (err < 0) {
    ce42:	2e00      	cmp	r6, #0
    ce44:	f04f 0000 	mov.w	r0, #0
    ce48:	dbd5      	blt.n	cdf6 <notify_cb+0x12>
		data->err = 0;
    ce4a:	6020      	str	r0, [r4, #0]
    ce4c:	e7d2      	b.n	cdf4 <notify_cb+0x10>
			err = gatt_notify(conn, attr->handle - 1,
    ce4e:	f7ff fc91 	bl	c774 <gatt_notify>
    ce52:	e7f2      	b.n	ce3a <notify_cb+0x56>
		if (ccc->cfg_match && !ccc->cfg_match(conn, attr)) {
    ce54:	4639      	mov	r1, r7
    ce56:	4798      	blx	r3
    ce58:	2800      	cmp	r0, #0
    ce5a:	d1e4      	bne.n	ce26 <notify_cb+0x42>
			bt_conn_unref(conn);
    ce5c:	4628      	mov	r0, r5
			bt_conn_unref(conn);
    ce5e:	f015 fc5e 	bl	2271e <bt_conn_unref>
			continue;
    ce62:	e7c7      	b.n	cdf4 <notify_cb+0x10>
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    ce64:	f04f 0800 	mov.w	r8, #0
    ce68:	4d14      	ldr	r5, [pc, #80]	; (cebc <notify_cb+0xd8>)
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
    ce6a:	46c2      	mov	sl, r8
    ce6c:	f105 0901 	add.w	r9, r5, #1
    ce70:	2207      	movs	r2, #7
    ce72:	4669      	mov	r1, sp
    ce74:	4648      	mov	r0, r9
    ce76:	f8cd a000 	str.w	sl, [sp]
    ce7a:	f8cd a003 	str.w	sl, [sp, #3]
    ce7e:	f7f4 fea7 	bl	1bd0 <memcmp>
    ce82:	b160      	cbz	r0, ce9e <notify_cb+0xba>
			conn = bt_conn_lookup_state_le(&cfg->peer,
    ce84:	2106      	movs	r1, #6
    ce86:	4648      	mov	r0, r9
    ce88:	f7fd fff0 	bl	ae6c <bt_conn_lookup_state_le>
			if (!conn) {
    ce8c:	b970      	cbnz	r0, ceac <notify_cb+0xc8>
				sc = (struct sc_data *)data->ind_params->data;
    ce8e:	68a3      	ldr	r3, [r4, #8]
				sc_save(cfg->id, &cfg->peer,
    ce90:	7828      	ldrb	r0, [r5, #0]
				sc = (struct sc_data *)data->ind_params->data;
    ce92:	68da      	ldr	r2, [r3, #12]
				sc_save(cfg->id, &cfg->peer,
    ce94:	4649      	mov	r1, r9
    ce96:	8853      	ldrh	r3, [r2, #2]
    ce98:	8812      	ldrh	r2, [r2, #0]
    ce9a:	f7ff ff5b 	bl	cd54 <sc_save>
				continue;
    ce9e:	350c      	adds	r5, #12
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    cea0:	f1b8 0f00 	cmp.w	r8, #0
    cea4:	d1ae      	bne.n	ce04 <notify_cb+0x20>
    cea6:	f04f 0801 	mov.w	r8, #1
    ceaa:	e7df      	b.n	ce6c <notify_cb+0x88>
			bt_conn_unref(conn);
    ceac:	f015 fc37 	bl	2271e <bt_conn_unref>
    ceb0:	e7f5      	b.n	ce9e <notify_cb+0xba>
    ceb2:	bf00      	nop
    ceb4:	0000cb45 	.word	0x0000cb45
    ceb8:	2000e818 	.word	0x2000e818
    cebc:	20006124 	.word	0x20006124

0000cec0 <sc_set>:
{
    cec0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    cec4:	460e      	mov	r6, r1
    cec6:	b087      	sub	sp, #28
    cec8:	4690      	mov	r8, r2
    ceca:	4699      	mov	r9, r3
	if (!name) {
    cecc:	4607      	mov	r7, r0
    cece:	b998      	cbnz	r0, cef8 <sc_set+0x38>
		BT_ERR("Insufficient number of arguments");
    ced0:	2301      	movs	r3, #1
    ced2:	f04f 0100 	mov.w	r1, #0
    ced6:	f363 0107 	bfi	r1, r3, #0, #8
    ceda:	4a3d      	ldr	r2, [pc, #244]	; (cfd0 <sc_set+0x110>)
    cedc:	4b3d      	ldr	r3, [pc, #244]	; (cfd4 <sc_set+0x114>)
    cede:	483e      	ldr	r0, [pc, #248]	; (cfd8 <sc_set+0x118>)
    cee0:	1a9b      	subs	r3, r3, r2
    cee2:	08db      	lsrs	r3, r3, #3
    cee4:	f363 118f 	bfi	r1, r3, #6, #10
    cee8:	f014 f8a7 	bl	2103a <log_0>
		return -EINVAL;
    ceec:	f06f 0515 	mvn.w	r5, #21
}
    cef0:	4628      	mov	r0, r5
    cef2:	b007      	add	sp, #28
    cef4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	err = bt_settings_decode_key(name, &addr);
    cef8:	a902      	add	r1, sp, #8
    cefa:	f015 f9ec 	bl	222d6 <bt_settings_decode_key>
	if (err) {
    cefe:	4605      	mov	r5, r0
    cf00:	b198      	cbz	r0, cf2a <sc_set+0x6a>
		BT_ERR("Unable to decode address %s", log_strdup(name));
    cf02:	2301      	movs	r3, #1
    cf04:	f04f 0400 	mov.w	r4, #0
    cf08:	4a31      	ldr	r2, [pc, #196]	; (cfd0 <sc_set+0x110>)
    cf0a:	f363 0407 	bfi	r4, r3, #0, #8
    cf0e:	4b31      	ldr	r3, [pc, #196]	; (cfd4 <sc_set+0x114>)
    cf10:	1a9b      	subs	r3, r3, r2
    cf12:	08db      	lsrs	r3, r3, #3
    cf14:	4638      	mov	r0, r7
    cf16:	f363 148f 	bfi	r4, r3, #6, #10
    cf1a:	f7f7 fef1 	bl	4d00 <log_strdup>
    cf1e:	4622      	mov	r2, r4
    cf20:	4601      	mov	r1, r0
    cf22:	482e      	ldr	r0, [pc, #184]	; (cfdc <sc_set+0x11c>)
    cf24:	f014 f896 	bl	21054 <log_1>
    cf28:	e7e0      	b.n	ceec <sc_set+0x2c>
	settings_name_next(name, &next);
    cf2a:	a901      	add	r1, sp, #4
    cf2c:	4638      	mov	r0, r7
    cf2e:	f014 fd12 	bl	21956 <settings_name_next>
	if (!next) {
    cf32:	9801      	ldr	r0, [sp, #4]
    cf34:	b330      	cbz	r0, cf84 <sc_set+0xc4>
		id = strtol(next, NULL, 10);
    cf36:	220a      	movs	r2, #10
    cf38:	4629      	mov	r1, r5
    cf3a:	f7f3 fdd7 	bl	aec <strtol>
    cf3e:	b2c7      	uxtb	r7, r0
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    cf40:	a902      	add	r1, sp, #8
    cf42:	4638      	mov	r0, r7
    cf44:	f7ff fee4 	bl	cd10 <find_sc_cfg.part.10>
	if (!cfg && len_rd) {
    cf48:	4604      	mov	r4, r0
    cf4a:	2800      	cmp	r0, #0
    cf4c:	d139      	bne.n	cfc2 <sc_set+0x102>
    cf4e:	2e00      	cmp	r6, #0
    cf50:	d0ce      	beq.n	cef0 <sc_set+0x30>
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
    cf52:	a904      	add	r1, sp, #16
    cf54:	9004      	str	r0, [sp, #16]
    cf56:	f8cd 0013 	str.w	r0, [sp, #19]
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    cf5a:	f7ff fed9 	bl	cd10 <find_sc_cfg.part.10>
		if (!cfg) {
    cf5e:	4604      	mov	r4, r0
    cf60:	b990      	cbnz	r0, cf88 <sc_set+0xc8>
			BT_ERR("Unable to restore SC: no cfg left");
    cf62:	2301      	movs	r3, #1
    cf64:	f04f 0100 	mov.w	r1, #0
    cf68:	f363 0107 	bfi	r1, r3, #0, #8
    cf6c:	4a18      	ldr	r2, [pc, #96]	; (cfd0 <sc_set+0x110>)
    cf6e:	4b19      	ldr	r3, [pc, #100]	; (cfd4 <sc_set+0x114>)
    cf70:	481b      	ldr	r0, [pc, #108]	; (cfe0 <sc_set+0x120>)
    cf72:	1a9b      	subs	r3, r3, r2
    cf74:	08db      	lsrs	r3, r3, #3
    cf76:	f363 118f 	bfi	r1, r3, #6, #10
    cf7a:	f014 f85e 	bl	2103a <log_0>
			return -ENOMEM;
    cf7e:	f06f 050b 	mvn.w	r5, #11
    cf82:	e7b5      	b.n	cef0 <sc_set+0x30>
		id = BT_ID_DEFAULT;
    cf84:	462f      	mov	r7, r5
    cf86:	e7db      	b.n	cf40 <sc_set+0x80>
		cfg->id = id;
    cf88:	f800 7b01 	strb.w	r7, [r0], #1
		bt_addr_le_copy(&cfg->peer, &addr);
    cf8c:	a902      	add	r1, sp, #8
    cf8e:	f016 f908 	bl	231a2 <bt_addr_le_copy>
		len = read_cb(cb_arg, &cfg->data, sizeof(cfg->data));
    cf92:	f104 0108 	add.w	r1, r4, #8
    cf96:	2204      	movs	r2, #4
    cf98:	4648      	mov	r0, r9
    cf9a:	47c0      	blx	r8
		if (len < 0) {
    cf9c:	1e04      	subs	r4, r0, #0
    cf9e:	daa7      	bge.n	cef0 <sc_set+0x30>
			BT_ERR("Failed to decode value (err %d)", len);
    cfa0:	2301      	movs	r3, #1
    cfa2:	f04f 0200 	mov.w	r2, #0
    cfa6:	f363 0207 	bfi	r2, r3, #0, #8
    cfaa:	4909      	ldr	r1, [pc, #36]	; (cfd0 <sc_set+0x110>)
    cfac:	4b09      	ldr	r3, [pc, #36]	; (cfd4 <sc_set+0x114>)
    cfae:	480d      	ldr	r0, [pc, #52]	; (cfe4 <sc_set+0x124>)
    cfb0:	1a5b      	subs	r3, r3, r1
    cfb2:	08db      	lsrs	r3, r3, #3
    cfb4:	f363 128f 	bfi	r2, r3, #6, #10
    cfb8:	4621      	mov	r1, r4
    cfba:	f014 f84b 	bl	21054 <log_1>
			return len;
    cfbe:	4625      	mov	r5, r4
    cfc0:	e796      	b.n	cef0 <sc_set+0x30>
	if (len_rd) {
    cfc2:	2e00      	cmp	r6, #0
    cfc4:	d1e5      	bne.n	cf92 <sc_set+0xd2>
    cfc6:	6026      	str	r6, [r4, #0]
    cfc8:	6066      	str	r6, [r4, #4]
    cfca:	60a6      	str	r6, [r4, #8]
    cfcc:	e790      	b.n	cef0 <sc_set+0x30>
    cfce:	bf00      	nop
    cfd0:	00028540 	.word	0x00028540
    cfd4:	00028608 	.word	0x00028608
    cfd8:	00062a7c 	.word	0x00062a7c
    cfdc:	00063c31 	.word	0x00063c31
    cfe0:	00063c4d 	.word	0x00063c4d
    cfe4:	00063b08 	.word	0x00063b08

0000cfe8 <find_cf_cfg.part.9>:
static struct gatt_cf_cfg *find_cf_cfg(struct bt_conn *conn)
    cfe8:	b537      	push	{r0, r1, r2, r4, r5, lr}
		if (!conn) {
    cfea:	4605      	mov	r5, r0
    cfec:	4c13      	ldr	r4, [pc, #76]	; (d03c <find_cf_cfg.part.9+0x54>)
    cfee:	b130      	cbz	r0, cffe <find_cf_cfg.part.9+0x16>
		} else if (!bt_conn_addr_le_cmp(conn, &cf_cfg[i].peer)) {
    cff0:	1c61      	adds	r1, r4, #1
    cff2:	f015 fb7c 	bl	226ee <bt_conn_addr_le_cmp>
    cff6:	b9c0      	cbnz	r0, d02a <find_cf_cfg.part.9+0x42>
			return &cf_cfg[i];
    cff8:	4420      	add	r0, r4
}
    cffa:	b003      	add	sp, #12
    cffc:	bd30      	pop	{r4, r5, pc}
			if (!bt_addr_le_cmp(&cf_cfg[i].peer, BT_ADDR_LE_ANY)) {
    cffe:	9000      	str	r0, [sp, #0]
    d000:	2207      	movs	r2, #7
    d002:	f8cd 0003 	str.w	r0, [sp, #3]
    d006:	4669      	mov	r1, sp
    d008:	1c60      	adds	r0, r4, #1
    d00a:	f7f4 fde1 	bl	1bd0 <memcmp>
    d00e:	2800      	cmp	r0, #0
    d010:	d0f2      	beq.n	cff8 <find_cf_cfg.part.9+0x10>
    d012:	2207      	movs	r2, #7
    d014:	4669      	mov	r1, sp
    d016:	f104 0011 	add.w	r0, r4, #17
    d01a:	9500      	str	r5, [sp, #0]
    d01c:	f8cd 5003 	str.w	r5, [sp, #3]
    d020:	f7f4 fdd6 	bl	1bd0 <memcmp>
    d024:	e006      	b.n	d034 <find_cf_cfg.part.9+0x4c>
	return NULL;
    d026:	2000      	movs	r0, #0
    d028:	e7e7      	b.n	cffa <find_cf_cfg.part.9+0x12>
		} else if (!bt_conn_addr_le_cmp(conn, &cf_cfg[i].peer)) {
    d02a:	f104 0111 	add.w	r1, r4, #17
    d02e:	4628      	mov	r0, r5
    d030:	f015 fb5d 	bl	226ee <bt_conn_addr_le_cmp>
			if (!bt_addr_le_cmp(&cf_cfg[i].peer, BT_ADDR_LE_ANY)) {
    d034:	2800      	cmp	r0, #0
    d036:	d1f6      	bne.n	d026 <find_cf_cfg.part.9+0x3e>
		} else if (!bt_conn_addr_le_cmp(conn, &cf_cfg[i].peer)) {
    d038:	2010      	movs	r0, #16
    d03a:	e7dd      	b.n	cff8 <find_cf_cfg.part.9+0x10>
    d03c:	20000530 	.word	0x20000530

0000d040 <cf_write>:
{
    d040:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d042:	4617      	mov	r7, r2
    d044:	f8bd 2018 	ldrh.w	r2, [sp, #24]
	if (offset > sizeof(cfg->data)) {
    d048:	2a01      	cmp	r2, #1
{
    d04a:	4605      	mov	r5, r0
    d04c:	461e      	mov	r6, r3
	if (offset > sizeof(cfg->data)) {
    d04e:	d841      	bhi.n	d0d4 <cf_write+0x94>
	if (offset + len > sizeof(cfg->data)) {
    d050:	441a      	add	r2, r3
    d052:	2a01      	cmp	r2, #1
    d054:	461c      	mov	r4, r3
    d056:	dc40      	bgt.n	d0da <cf_write+0x9a>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    d058:	f7ff ffc6 	bl	cfe8 <find_cf_cfg.part.9>
	if (!cfg) {
    d05c:	4602      	mov	r2, r0
    d05e:	b9a8      	cbnz	r0, d08c <cf_write+0x4c>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    d060:	f7ff ffc2 	bl	cfe8 <find_cf_cfg.part.9>
	if (!cfg) {
    d064:	4602      	mov	r2, r0
    d066:	b988      	cbnz	r0, d08c <cf_write+0x4c>
		BT_WARN("No space to store Client Supported Features");
    d068:	2302      	movs	r3, #2
    d06a:	f04f 0100 	mov.w	r1, #0
    d06e:	f363 0107 	bfi	r1, r3, #0, #8
    d072:	4a1b      	ldr	r2, [pc, #108]	; (d0e0 <cf_write+0xa0>)
    d074:	4b1b      	ldr	r3, [pc, #108]	; (d0e4 <cf_write+0xa4>)
    d076:	481c      	ldr	r0, [pc, #112]	; (d0e8 <cf_write+0xa8>)
    d078:	1a9b      	subs	r3, r3, r2
    d07a:	08db      	lsrs	r3, r3, #3
    d07c:	f363 118f 	bfi	r1, r3, #6, #10
    d080:	f013 ffdb 	bl	2103a <log_0>
		return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
    d084:	f06f 0410 	mvn.w	r4, #16
}
    d088:	4620      	mov	r0, r4
    d08a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (i = 0U; i < len && i < last_byte; i++) {
    d08c:	2300      	movs	r3, #0
    d08e:	429e      	cmp	r6, r3
    d090:	d913      	bls.n	d0ba <cf_write+0x7a>
    d092:	b133      	cbz	r3, d0a2 <cf_write+0x62>
		cfg->data[i] |= value[i] & ((1 << last_bit) - 1);
    d094:	783b      	ldrb	r3, [r7, #0]
    d096:	7a11      	ldrb	r1, [r2, #8]
    d098:	f003 0301 	and.w	r3, r3, #1
    d09c:	430b      	orrs	r3, r1
    d09e:	7213      	strb	r3, [r2, #8]
		BT_DBG("byte %u: data 0x%02x value 0x%02x", i, cfg->data[i],
    d0a0:	e00d      	b.n	d0be <cf_write+0x7e>
    d0a2:	7a10      	ldrb	r0, [r2, #8]
		u8_t chg_bits = value[i] ^ cfg->data[i];
    d0a4:	7839      	ldrb	r1, [r7, #0]
    d0a6:	4041      	eors	r1, r0
			if ((BIT(bit) & chg_bits) &&
    d0a8:	07c9      	lsls	r1, r1, #31
	for (i = 0U; i < len && i < last_byte; i++) {
    d0aa:	f04f 0301 	mov.w	r3, #1
			if ((BIT(bit) & chg_bits) &&
    d0ae:	d5ee      	bpl.n	d08e <cf_write+0x4e>
    d0b0:	07c1      	lsls	r1, r0, #31
    d0b2:	d5ec      	bpl.n	d08e <cf_write+0x4e>
		return BT_GATT_ERR(BT_ATT_ERR_VALUE_NOT_ALLOWED);
    d0b4:	f06f 0412 	mvn.w	r4, #18
    d0b8:	e7e6      	b.n	d088 <cf_write+0x48>
	for (i = 0U; i < len && i < last_byte; i++) {
    d0ba:	2e00      	cmp	r6, #0
    d0bc:	d1ea      	bne.n	d094 <cf_write+0x54>
	bt_addr_le_copy(&cfg->peer, &conn->le.dst);
    d0be:	f105 0174 	add.w	r1, r5, #116	; 0x74
    d0c2:	1c50      	adds	r0, r2, #1
    d0c4:	f016 f86d 	bl	231a2 <bt_addr_le_copy>
	atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
    d0c8:	2100      	movs	r1, #0
    d0ca:	f102 000c 	add.w	r0, r2, #12
    d0ce:	f016 f951 	bl	23374 <atomic_set_bit>
	return len;
    d0d2:	e7d9      	b.n	d088 <cf_write+0x48>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
    d0d4:	f06f 0406 	mvn.w	r4, #6
    d0d8:	e7d6      	b.n	d088 <cf_write+0x48>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
    d0da:	f06f 040c 	mvn.w	r4, #12
    d0de:	e7d3      	b.n	d088 <cf_write+0x48>
    d0e0:	00028540 	.word	0x00028540
    d0e4:	00028608 	.word	0x00028608
    d0e8:	00063aaa 	.word	0x00063aaa

0000d0ec <sc_indicate_rsp>:
{
    d0ec:	b510      	push	{r4, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    d0ee:	f06f 0102 	mvn.w	r1, #2
    d0f2:	4604      	mov	r4, r0
    d0f4:	480d      	ldr	r0, [pc, #52]	; (d12c <sc_indicate_rsp+0x40>)
    d0f6:	f016 f845 	bl	23184 <atomic_and>
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
    d0fa:	2100      	movs	r1, #0
    d0fc:	480b      	ldr	r0, [pc, #44]	; (d12c <sc_indicate_rsp+0x40>)
    d0fe:	f016 f838 	bl	23172 <atomic_test_bit>
    d102:	b120      	cbz	r0, d10e <sc_indicate_rsp+0x22>
    d104:	2200      	movs	r2, #0
    d106:	490a      	ldr	r1, [pc, #40]	; (d130 <sc_indicate_rsp+0x44>)
    d108:	480a      	ldr	r0, [pc, #40]	; (d134 <sc_indicate_rsp+0x48>)
    d10a:	f011 ffa9 	bl	1f060 <k_delayed_work_submit_to_queue>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    d10e:	4620      	mov	r0, r4
    d110:	f7ff ff6a 	bl	cfe8 <find_cf_cfg.part.9>
	if (cfg && CF_ROBUST_CACHING(cfg)) {
    d114:	b140      	cbz	r0, d128 <sc_indicate_rsp+0x3c>
    d116:	7a03      	ldrb	r3, [r0, #8]
    d118:	07db      	lsls	r3, r3, #31
    d11a:	d505      	bpl.n	d128 <sc_indicate_rsp+0x3c>
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
    d11c:	2100      	movs	r1, #0
    d11e:	300c      	adds	r0, #12
}
    d120:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
    d124:	f016 b926 	b.w	23374 <atomic_set_bit>
}
    d128:	bd10      	pop	{r4, pc}
    d12a:	bf00      	nop
    d12c:	200005a8 	.word	0x200005a8
    d130:	20000588 	.word	0x20000588
    d134:	20006090 	.word	0x20006090

0000d138 <cf_set>:
{
    d138:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    d13c:	460f      	mov	r7, r1
    d13e:	4615      	mov	r5, r2
    d140:	461e      	mov	r6, r3
	if (!name) {
    d142:	4680      	mov	r8, r0
    d144:	b998      	cbnz	r0, d16e <cf_set+0x36>
		BT_ERR("Insufficient number of arguments");
    d146:	2301      	movs	r3, #1
    d148:	f04f 0100 	mov.w	r1, #0
    d14c:	f363 0107 	bfi	r1, r3, #0, #8
    d150:	4a2c      	ldr	r2, [pc, #176]	; (d204 <cf_set+0xcc>)
    d152:	4b2d      	ldr	r3, [pc, #180]	; (d208 <cf_set+0xd0>)
    d154:	482d      	ldr	r0, [pc, #180]	; (d20c <cf_set+0xd4>)
    d156:	1a9b      	subs	r3, r3, r2
    d158:	08db      	lsrs	r3, r3, #3
    d15a:	f363 118f 	bfi	r1, r3, #6, #10
    d15e:	f013 ff6c 	bl	2103a <log_0>
		return -EINVAL;
    d162:	f06f 0415 	mvn.w	r4, #21
}
    d166:	4620      	mov	r0, r4
    d168:	b002      	add	sp, #8
    d16a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	err = bt_settings_decode_key(name, &addr);
    d16e:	4669      	mov	r1, sp
    d170:	f015 f8b1 	bl	222d6 <bt_settings_decode_key>
	if (err) {
    d174:	4604      	mov	r4, r0
    d176:	b198      	cbz	r0, d1a0 <cf_set+0x68>
		BT_ERR("Unable to decode address %s", log_strdup(name));
    d178:	2301      	movs	r3, #1
    d17a:	f04f 0400 	mov.w	r4, #0
    d17e:	4a21      	ldr	r2, [pc, #132]	; (d204 <cf_set+0xcc>)
    d180:	f363 0407 	bfi	r4, r3, #0, #8
    d184:	4b20      	ldr	r3, [pc, #128]	; (d208 <cf_set+0xd0>)
    d186:	1a9b      	subs	r3, r3, r2
    d188:	08db      	lsrs	r3, r3, #3
    d18a:	4640      	mov	r0, r8
    d18c:	f363 148f 	bfi	r4, r3, #6, #10
    d190:	f7f7 fdb6 	bl	4d00 <log_strdup>
    d194:	4622      	mov	r2, r4
    d196:	4601      	mov	r1, r0
    d198:	481d      	ldr	r0, [pc, #116]	; (d210 <cf_set+0xd8>)
    d19a:	f013 ff5b 	bl	21054 <log_1>
    d19e:	e7e0      	b.n	d162 <cf_set+0x2a>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    d1a0:	4668      	mov	r0, sp
    d1a2:	f7ff fcb5 	bl	cb10 <find_cf_cfg_by_addr.part.12>
	if (!cfg) {
    d1a6:	4601      	mov	r1, r0
    d1a8:	b980      	cbnz	r0, d1cc <cf_set+0x94>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    d1aa:	f7ff ff1d 	bl	cfe8 <find_cf_cfg.part.9>
		if (!cfg) {
    d1ae:	4601      	mov	r1, r0
    d1b0:	b960      	cbnz	r0, d1cc <cf_set+0x94>
			BT_ERR("Unable to restore CF: no cfg left");
    d1b2:	2301      	movs	r3, #1
    d1b4:	f363 0107 	bfi	r1, r3, #0, #8
    d1b8:	4a12      	ldr	r2, [pc, #72]	; (d204 <cf_set+0xcc>)
    d1ba:	4b13      	ldr	r3, [pc, #76]	; (d208 <cf_set+0xd0>)
    d1bc:	4815      	ldr	r0, [pc, #84]	; (d214 <cf_set+0xdc>)
    d1be:	1a9b      	subs	r3, r3, r2
    d1c0:	08db      	lsrs	r3, r3, #3
    d1c2:	f363 118f 	bfi	r1, r3, #6, #10
    d1c6:	f013 ff38 	bl	2103a <log_0>
			return 0;
    d1ca:	e7cc      	b.n	d166 <cf_set+0x2e>
	if (len_rd) {
    d1cc:	b1b7      	cbz	r7, d1fc <cf_set+0xc4>
		len = read_cb(cb_arg, cfg->data, sizeof(cfg->data));
    d1ce:	2201      	movs	r2, #1
    d1d0:	3108      	adds	r1, #8
    d1d2:	4630      	mov	r0, r6
    d1d4:	47a8      	blx	r5
		if (len < 0) {
    d1d6:	1e05      	subs	r5, r0, #0
    d1d8:	dac5      	bge.n	d166 <cf_set+0x2e>
			BT_ERR("Failed to decode value (err %d)", len);
    d1da:	2301      	movs	r3, #1
    d1dc:	f04f 0200 	mov.w	r2, #0
    d1e0:	f363 0207 	bfi	r2, r3, #0, #8
    d1e4:	4907      	ldr	r1, [pc, #28]	; (d204 <cf_set+0xcc>)
    d1e6:	4b08      	ldr	r3, [pc, #32]	; (d208 <cf_set+0xd0>)
    d1e8:	480b      	ldr	r0, [pc, #44]	; (d218 <cf_set+0xe0>)
    d1ea:	1a5b      	subs	r3, r3, r1
    d1ec:	08db      	lsrs	r3, r3, #3
    d1ee:	f363 128f 	bfi	r2, r3, #6, #10
    d1f2:	4629      	mov	r1, r5
    d1f4:	f013 ff2e 	bl	21054 <log_1>
			return len;
    d1f8:	462c      	mov	r4, r5
    d1fa:	e7b4      	b.n	d166 <cf_set+0x2e>
		clear_cf_cfg(cfg);
    d1fc:	4608      	mov	r0, r1
    d1fe:	f016 f85e 	bl	232be <clear_cf_cfg>
    d202:	e7b0      	b.n	d166 <cf_set+0x2e>
    d204:	00028540 	.word	0x00028540
    d208:	00028608 	.word	0x00028608
    d20c:	00062a7c 	.word	0x00062a7c
    d210:	00063c31 	.word	0x00063c31
    d214:	00063a88 	.word	0x00063a88
    d218:	00063b08 	.word	0x00063b08

0000d21c <bt_gatt_init>:
{
    d21c:	b510      	push	{r4, lr}
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    d21e:	4b1c      	ldr	r3, [pc, #112]	; (d290 <bt_gatt_init+0x74>)
    d220:	f3bf 8f5b 	dmb	ish
    d224:	2201      	movs	r2, #1
    d226:	e853 1f00 	ldrex	r1, [r3]
    d22a:	2900      	cmp	r1, #0
    d22c:	d103      	bne.n	d236 <bt_gatt_init+0x1a>
    d22e:	e843 2000 	strex	r0, r2, [r3]
    d232:	2800      	cmp	r0, #0
    d234:	d1f7      	bne.n	d226 <bt_gatt_init+0xa>
    d236:	f3bf 8f5b 	dmb	ish
	if (!atomic_cas(&init, 0, 1)) {
    d23a:	d122      	bne.n	d282 <bt_gatt_init+0x66>
    d23c:	4a15      	ldr	r2, [pc, #84]	; (d294 <bt_gatt_init+0x78>)
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
    d23e:	4916      	ldr	r1, [pc, #88]	; (d298 <bt_gatt_init+0x7c>)
    d240:	8813      	ldrh	r3, [r2, #0]
    d242:	4c16      	ldr	r4, [pc, #88]	; (d29c <bt_gatt_init+0x80>)
	if (!atomic_cas(&init, 0, 1)) {
    d244:	2000      	movs	r0, #0
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
    d246:	42a1      	cmp	r1, r4
    d248:	d31c      	bcc.n	d284 <bt_gatt_init+0x68>
    d24a:	b100      	cbz	r0, d24e <bt_gatt_init+0x32>
    d24c:	8013      	strh	r3, [r2, #0]
	k_delayed_work_init(&db_hash_work, db_hash_process);
    d24e:	4914      	ldr	r1, [pc, #80]	; (d2a0 <bt_gatt_init+0x84>)
    d250:	4814      	ldr	r0, [pc, #80]	; (d2a4 <bt_gatt_init+0x88>)
    d252:	f01a fe58 	bl	27f06 <k_delayed_work_init>
    d256:	220a      	movs	r2, #10
    d258:	4912      	ldr	r1, [pc, #72]	; (d2a4 <bt_gatt_init+0x88>)
    d25a:	4813      	ldr	r0, [pc, #76]	; (d2a8 <bt_gatt_init+0x8c>)
    d25c:	f011 ff00 	bl	1f060 <k_delayed_work_submit_to_queue>
		k_delayed_work_init(&gatt_sc.work, sc_process);
    d260:	4912      	ldr	r1, [pc, #72]	; (d2ac <bt_gatt_init+0x90>)
    d262:	4813      	ldr	r0, [pc, #76]	; (d2b0 <bt_gatt_init+0x94>)
    d264:	f01a fe4f 	bl	27f06 <k_delayed_work_init>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    d268:	f3bf 8f5b 	dmb	ish
    d26c:	4b11      	ldr	r3, [pc, #68]	; (d2b4 <bt_gatt_init+0x98>)
    d26e:	e853 2f00 	ldrex	r2, [r3]
    d272:	f042 0202 	orr.w	r2, r2, #2
    d276:	e843 2100 	strex	r1, r2, [r3]
    d27a:	2900      	cmp	r1, #0
    d27c:	d1f7      	bne.n	d26e <bt_gatt_init+0x52>
    d27e:	f3bf 8f5b 	dmb	ish
}
    d282:	bd10      	pop	{r4, pc}
		last_static_handle += svc->attr_count;
    d284:	6848      	ldr	r0, [r1, #4]
    d286:	4403      	add	r3, r0
    d288:	b29b      	uxth	r3, r3
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
    d28a:	3108      	adds	r1, #8
    d28c:	2001      	movs	r0, #1
    d28e:	e7da      	b.n	d246 <bt_gatt_init+0x2a>
    d290:	200005ac 	.word	0x200005ac
    d294:	20006122 	.word	0x20006122
    d298:	00028490 	.word	0x00028490
    d29c:	000284c8 	.word	0x000284c8
    d2a0:	00023539 	.word	0x00023539
    d2a4:	20000550 	.word	0x20000550
    d2a8:	20006090 	.word	0x20006090
    d2ac:	0000d749 	.word	0x0000d749
    d2b0:	20000588 	.word	0x20000588
    d2b4:	200005a8 	.word	0x200005a8

0000d2b8 <bt_gatt_attr_value_handle>:
{
    d2b8:	b508      	push	{r3, lr}
	if ((attr != NULL)
    d2ba:	b188      	cbz	r0, d2e0 <bt_gatt_attr_value_handle+0x28>
	    && (attr->read == bt_gatt_attr_read_chrc)) {
    d2bc:	6841      	ldr	r1, [r0, #4]
    d2be:	4b09      	ldr	r3, [pc, #36]	; (d2e4 <bt_gatt_attr_value_handle+0x2c>)
    d2c0:	4299      	cmp	r1, r3
    d2c2:	d10d      	bne.n	d2e0 <bt_gatt_attr_value_handle+0x28>
		handle = chrc->value_handle;
    d2c4:	68c3      	ldr	r3, [r0, #12]
    d2c6:	889b      	ldrh	r3, [r3, #4]
		if (handle == 0) {
    d2c8:	b91b      	cbnz	r3, d2d2 <bt_gatt_attr_value_handle+0x1a>
			handle = (attr->handle ? : find_static_attr(attr)) + 1U;
    d2ca:	8a03      	ldrh	r3, [r0, #16]
    d2cc:	b11b      	cbz	r3, d2d6 <bt_gatt_attr_value_handle+0x1e>
    d2ce:	3301      	adds	r3, #1
    d2d0:	b29b      	uxth	r3, r3
}
    d2d2:	4618      	mov	r0, r3
    d2d4:	bd08      	pop	{r3, pc}
			handle = (attr->handle ? : find_static_attr(attr)) + 1U;
    d2d6:	f7ff f9ab 	bl	c630 <find_static_attr>
    d2da:	3001      	adds	r0, #1
    d2dc:	b283      	uxth	r3, r0
	return handle;
    d2de:	e7f8      	b.n	d2d2 <bt_gatt_attr_value_handle+0x1a>
	u16_t handle = 0;
    d2e0:	2300      	movs	r3, #0
    d2e2:	e7f6      	b.n	d2d2 <bt_gatt_attr_value_handle+0x1a>
    d2e4:	000234cf 	.word	0x000234cf

0000d2e8 <bt_gatt_foreach_attr_type>:
{
    d2e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d2ec:	b087      	sub	sp, #28
    d2ee:	4699      	mov	r9, r3
    d2f0:	f8bd 5040 	ldrh.w	r5, [sp, #64]	; 0x40
		num_matches = UINT16_MAX;
    d2f4:	f64f 73ff 	movw	r3, #65535	; 0xffff
    d2f8:	2d00      	cmp	r5, #0
    d2fa:	bf08      	it	eq
    d2fc:	461d      	moveq	r5, r3
	if (start_handle <= last_static_handle) {
    d2fe:	4b2b      	ldr	r3, [pc, #172]	; (d3ac <bt_gatt_foreach_attr_type+0xc4>)
    d300:	881b      	ldrh	r3, [r3, #0]
    d302:	4283      	cmp	r3, r0
{
    d304:	4607      	mov	r7, r0
    d306:	468a      	mov	sl, r1
    d308:	4690      	mov	r8, r2
	if (start_handle <= last_static_handle) {
    d30a:	d344      	bcc.n	d396 <bt_gatt_foreach_attr_type+0xae>
    d30c:	4e28      	ldr	r6, [pc, #160]	; (d3b0 <bt_gatt_foreach_attr_type+0xc8>)
		u16_t handle = 1;
    d30e:	2401      	movs	r4, #1
		Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    d310:	4a28      	ldr	r2, [pc, #160]	; (d3b4 <bt_gatt_foreach_attr_type+0xcc>)
    d312:	f1a6 0308 	sub.w	r3, r6, #8
    d316:	4293      	cmp	r3, r2
    d318:	d23d      	bcs.n	d396 <bt_gatt_foreach_attr_type+0xae>
			if (handle + static_svc->attr_count < start_handle) {
    d31a:	f856 3c04 	ldr.w	r3, [r6, #-4]
    d31e:	4423      	add	r3, r4
    d320:	42bb      	cmp	r3, r7
    d322:	d23f      	bcs.n	d3a4 <bt_gatt_foreach_attr_type+0xbc>
				handle += static_svc->attr_count;
    d324:	b29c      	uxth	r4, r3
				continue;
    d326:	3608      	adds	r6, #8
    d328:	e7f2      	b.n	d310 <bt_gatt_foreach_attr_type+0x28>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
    d32a:	9901      	ldr	r1, [sp, #4]
    d32c:	4640      	mov	r0, r8
    d32e:	f014 fff6 	bl	2231e <bt_uuid_cmp>
    d332:	b320      	cbz	r0, d37e <bt_gatt_foreach_attr_type+0x96>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
    d334:	3401      	adds	r4, #1
    d336:	f10b 0b01 	add.w	fp, fp, #1
    d33a:	b2a4      	uxth	r4, r4
    d33c:	f856 3c04 	ldr.w	r3, [r6, #-4]
    d340:	455b      	cmp	r3, fp
    d342:	d9f0      	bls.n	d326 <bt_gatt_foreach_attr_type+0x3e>
				memcpy(&attr, &static_svc->attrs[i],
    d344:	f856 3c08 	ldr.w	r3, [r6, #-8]
    d348:	2214      	movs	r2, #20
    d34a:	fb02 330b 	mla	r3, r2, fp, r3
    d34e:	f103 0e10 	add.w	lr, r3, #16
    d352:	aa01      	add	r2, sp, #4
    d354:	6818      	ldr	r0, [r3, #0]
    d356:	6859      	ldr	r1, [r3, #4]
    d358:	4694      	mov	ip, r2
    d35a:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    d35e:	3308      	adds	r3, #8
    d360:	4573      	cmp	r3, lr
    d362:	4662      	mov	r2, ip
    d364:	d1f6      	bne.n	d354 <bt_gatt_foreach_attr_type+0x6c>
    d366:	6818      	ldr	r0, [r3, #0]
    d368:	f8cc 0000 	str.w	r0, [ip]
	if (attr->handle > end_handle) {
    d36c:	4554      	cmp	r4, sl
				attr.handle = handle;
    d36e:	f8ad 4014 	strh.w	r4, [sp, #20]
	if (attr->handle > end_handle) {
    d372:	d810      	bhi.n	d396 <bt_gatt_foreach_attr_type+0xae>
	if (attr->handle < start_handle) {
    d374:	42bc      	cmp	r4, r7
    d376:	d3dd      	bcc.n	d334 <bt_gatt_foreach_attr_type+0x4c>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
    d378:	f1b8 0f00 	cmp.w	r8, #0
    d37c:	d1d5      	bne.n	d32a <bt_gatt_foreach_attr_type+0x42>
	if (attr_data && attr_data != attr->user_data) {
    d37e:	f1b9 0f00 	cmp.w	r9, #0
    d382:	d10b      	bne.n	d39c <bt_gatt_foreach_attr_type+0xb4>
	*num_matches -= 1;
    d384:	3d01      	subs	r5, #1
    d386:	b2ad      	uxth	r5, r5
	result = func(attr, user_data);
    d388:	9912      	ldr	r1, [sp, #72]	; 0x48
    d38a:	9b11      	ldr	r3, [sp, #68]	; 0x44
    d38c:	a801      	add	r0, sp, #4
    d38e:	4798      	blx	r3
	if (!*num_matches) {
    d390:	b10d      	cbz	r5, d396 <bt_gatt_foreach_attr_type+0xae>
				if (gatt_foreach_iter(&attr, start_handle,
    d392:	2800      	cmp	r0, #0
    d394:	d1ce      	bne.n	d334 <bt_gatt_foreach_attr_type+0x4c>
}
    d396:	b007      	add	sp, #28
    d398:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (attr_data && attr_data != attr->user_data) {
    d39c:	9b04      	ldr	r3, [sp, #16]
    d39e:	4599      	cmp	r9, r3
    d3a0:	d1c8      	bne.n	d334 <bt_gatt_foreach_attr_type+0x4c>
    d3a2:	e7ef      	b.n	d384 <bt_gatt_foreach_attr_type+0x9c>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
    d3a4:	f04f 0b00 	mov.w	fp, #0
    d3a8:	e7c8      	b.n	d33c <bt_gatt_foreach_attr_type+0x54>
    d3aa:	bf00      	nop
    d3ac:	20006122 	.word	0x20006122
    d3b0:	00028498 	.word	0x00028498
    d3b4:	000284c8 	.word	0x000284c8

0000d3b8 <db_hash_gen>:
{
    d3b8:	b530      	push	{r4, r5, lr}
    d3ba:	b0c9      	sub	sp, #292	; 0x124
	u8_t key[16] = {};
    d3bc:	2210      	movs	r2, #16
    d3be:	2100      	movs	r1, #0
{
    d3c0:	4604      	mov	r4, r0
	u8_t key[16] = {};
    d3c2:	4668      	mov	r0, sp
    d3c4:	f7f4 fc33 	bl	1c2e <memset>
	if (tc_cmac_setup(&state.state, key, &sched) == TC_CRYPTO_FAIL) {
    d3c8:	aa1c      	add	r2, sp, #112	; 0x70
    d3ca:	4669      	mov	r1, sp
    d3cc:	a804      	add	r0, sp, #16
    d3ce:	f013 fd46 	bl	20e5e <tc_cmac_setup>
    d3d2:	b978      	cbnz	r0, d3f4 <db_hash_gen+0x3c>
		BT_ERR("Unable to setup AES CMAC");
    d3d4:	2301      	movs	r3, #1
    d3d6:	f04f 0100 	mov.w	r1, #0
    d3da:	f363 0107 	bfi	r1, r3, #0, #8
    d3de:	4a1a      	ldr	r2, [pc, #104]	; (d448 <db_hash_gen+0x90>)
    d3e0:	4b1a      	ldr	r3, [pc, #104]	; (d44c <db_hash_gen+0x94>)
    d3e2:	481b      	ldr	r0, [pc, #108]	; (d450 <db_hash_gen+0x98>)
    d3e4:	1a9b      	subs	r3, r3, r2
    d3e6:	08db      	lsrs	r3, r3, #3
    d3e8:	f363 118f 	bfi	r1, r3, #6, #10
		BT_ERR("Unable to calculate hash");
    d3ec:	f013 fe25 	bl	2103a <log_0>
}
    d3f0:	b049      	add	sp, #292	; 0x124
    d3f2:	bd30      	pop	{r4, r5, pc}
	bt_gatt_foreach_attr(0x0001, 0xffff, gen_hash_m, &state);
    d3f4:	f64f 71ff 	movw	r1, #65535	; 0xffff
    d3f8:	2001      	movs	r0, #1
    d3fa:	ab04      	add	r3, sp, #16
    d3fc:	4a15      	ldr	r2, [pc, #84]	; (d454 <db_hash_gen+0x9c>)
    d3fe:	f016 f890 	bl	23522 <bt_gatt_foreach_attr>
	if (tc_cmac_final(db_hash, &state.state) == TC_CRYPTO_FAIL) {
    d402:	a904      	add	r1, sp, #16
    d404:	4814      	ldr	r0, [pc, #80]	; (d458 <db_hash_gen+0xa0>)
    d406:	f013 fdc0 	bl	20f8a <tc_cmac_final>
    d40a:	b960      	cbnz	r0, d426 <db_hash_gen+0x6e>
		BT_ERR("Unable to calculate hash");
    d40c:	2301      	movs	r3, #1
    d40e:	f04f 0100 	mov.w	r1, #0
    d412:	f363 0107 	bfi	r1, r3, #0, #8
    d416:	4a0c      	ldr	r2, [pc, #48]	; (d448 <db_hash_gen+0x90>)
    d418:	4b0c      	ldr	r3, [pc, #48]	; (d44c <db_hash_gen+0x94>)
    d41a:	4810      	ldr	r0, [pc, #64]	; (d45c <db_hash_gen+0xa4>)
    d41c:	1a9b      	subs	r3, r3, r2
    d41e:	08db      	lsrs	r3, r3, #3
    d420:	f363 118f 	bfi	r1, r3, #6, #10
    d424:	e7e2      	b.n	d3ec <db_hash_gen+0x34>
    d426:	4b0c      	ldr	r3, [pc, #48]	; (d458 <db_hash_gen+0xa0>)
	if (tc_cmac_final(db_hash, &state.state) == TC_CRYPTO_FAIL) {
    d428:	2208      	movs	r2, #8
    d42a:	f103 0110 	add.w	r1, r3, #16
static inline void sys_mem_swap(void *buf, size_t length)
{
	size_t i;

	for (i = 0; i < (length/2); i++) {
		u8_t tmp = ((u8_t *)buf)[i];
    d42e:	7818      	ldrb	r0, [r3, #0]

		((u8_t *)buf)[i] = ((u8_t *)buf)[length - 1 - i];
    d430:	f811 5d01 	ldrb.w	r5, [r1, #-1]!
    d434:	f803 5b01 	strb.w	r5, [r3], #1
	for (i = 0; i < (length/2); i++) {
    d438:	3a01      	subs	r2, #1
		((u8_t *)buf)[length - 1 - i] = tmp;
    d43a:	7008      	strb	r0, [r1, #0]
	for (i = 0; i < (length/2); i++) {
    d43c:	d1f7      	bne.n	d42e <db_hash_gen+0x76>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) && store) {
    d43e:	2c00      	cmp	r4, #0
    d440:	d0d6      	beq.n	d3f0 <db_hash_gen+0x38>
		db_hash_store();
    d442:	f7ff f919 	bl	c678 <db_hash_store>
    d446:	e7d3      	b.n	d3f0 <db_hash_gen+0x38>
    d448:	00028540 	.word	0x00028540
    d44c:	00028608 	.word	0x00028608
    d450:	00063ad6 	.word	0x00063ad6
    d454:	000230c7 	.word	0x000230c7
    d458:	2000aa3a 	.word	0x2000aa3a
    d45c:	00063aef 	.word	0x00063aef

0000d460 <db_hash_commit>:

static int db_hash_commit(void)
{
    d460:	b508      	push	{r3, lr}
 * @return Remaining time (in milliseconds).
 * @req K-DWORK-001
 */
static inline s32_t k_delayed_work_remaining_get(struct k_delayed_work *work)
{
	return k_ticks_to_ms_floor64(z_timeout_remaining(&work->timeout));
    d462:	4828      	ldr	r0, [pc, #160]	; (d504 <db_hash_commit+0xa4>)
    d464:	f011 febc 	bl	1f1e0 <z_timeout_remaining>
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
    d468:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    d46c:	fb80 0103 	smull	r0, r1, r0, r3
    d470:	0bc3      	lsrs	r3, r0, #15
	/* Stop work and generate the hash */
	if (k_delayed_work_remaining_get(&db_hash_work)) {
    d472:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
    d476:	d005      	beq.n	d484 <db_hash_commit+0x24>
		k_delayed_work_cancel(&db_hash_work);
    d478:	4823      	ldr	r0, [pc, #140]	; (d508 <db_hash_commit+0xa8>)
    d47a:	f01a fd4c 	bl	27f16 <k_delayed_work_cancel>
		db_hash_gen(false);
    d47e:	2000      	movs	r0, #0
    d480:	f7ff ff9a 	bl	d3b8 <db_hash_gen>
	}

	/* Check if hash matches then skip SC update */
	if (!memcmp(stored_hash, db_hash, sizeof(stored_hash))) {
    d484:	2210      	movs	r2, #16
    d486:	4921      	ldr	r1, [pc, #132]	; (d50c <db_hash_commit+0xac>)
    d488:	4821      	ldr	r0, [pc, #132]	; (d510 <db_hash_commit+0xb0>)
    d48a:	f7f4 fba1 	bl	1bd0 <memcmp>
    d48e:	b920      	cbnz	r0, d49a <db_hash_commit+0x3a>
		BT_DBG("Database Hash matches");
		k_delayed_work_cancel(&gatt_sc.work);
    d490:	4820      	ldr	r0, [pc, #128]	; (d514 <db_hash_commit+0xb4>)
    d492:	f01a fd40 	bl	27f16 <k_delayed_work_cancel>

	/* Hash did not match overwrite with current hash */
	db_hash_store();

	return 0;
}
    d496:	2000      	movs	r0, #0
    d498:	bd08      	pop	{r3, pc}
    d49a:	4a1f      	ldr	r2, [pc, #124]	; (d518 <db_hash_commit+0xb8>)
    d49c:	f3bf 8f5b 	dmb	ish
    d4a0:	f102 0338 	add.w	r3, r2, #56	; 0x38
    d4a4:	e853 1f00 	ldrex	r1, [r3]
    d4a8:	f041 0001 	orr.w	r0, r1, #1
    d4ac:	e843 0c00 	strex	ip, r0, [r3]
    d4b0:	f1bc 0f00 	cmp.w	ip, #0
    d4b4:	d1f6      	bne.n	d4a4 <db_hash_commit+0x44>
    d4b6:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
    d4ba:	f011 0f01 	tst.w	r1, #1
    d4be:	4613      	mov	r3, r2
    d4c0:	d10e      	bne.n	d4e0 <db_hash_commit+0x80>
		gatt_sc.start = start;
    d4c2:	4b16      	ldr	r3, [pc, #88]	; (d51c <db_hash_commit+0xbc>)
    d4c4:	6153      	str	r3, [r2, #20]
	if (atomic_test_bit(gatt_sc.flags, SC_INDICATE_PENDING)) {
    d4c6:	2101      	movs	r1, #1
    d4c8:	4815      	ldr	r0, [pc, #84]	; (d520 <db_hash_commit+0xc0>)
    d4ca:	f015 fe52 	bl	23172 <atomic_test_bit>
    d4ce:	b920      	cbnz	r0, d4da <db_hash_commit+0x7a>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    d4d0:	220a      	movs	r2, #10
    d4d2:	4910      	ldr	r1, [pc, #64]	; (d514 <db_hash_commit+0xb4>)
    d4d4:	4813      	ldr	r0, [pc, #76]	; (d524 <db_hash_commit+0xc4>)
    d4d6:	f011 fdc3 	bl	1f060 <k_delayed_work_submit_to_queue>
	db_hash_store();
    d4da:	f7ff f8cd 	bl	c678 <db_hash_store>
	return 0;
    d4de:	e7da      	b.n	d496 <db_hash_commit+0x36>
	if (new_start >= *start && new_end <= *end) {
    d4e0:	8ad1      	ldrh	r1, [r2, #22]
    d4e2:	8a92      	ldrh	r2, [r2, #20]
    d4e4:	2a01      	cmp	r2, #1
    d4e6:	f64f 72ff 	movw	r2, #65535	; 0xffff
    d4ea:	d805      	bhi.n	d4f8 <db_hash_commit+0x98>
    d4ec:	4291      	cmp	r1, r2
    d4ee:	d0f4      	beq.n	d4da <db_hash_commit+0x7a>
		*end = new_end;
    d4f0:	f64f 72ff 	movw	r2, #65535	; 0xffff
    d4f4:	82da      	strh	r2, [r3, #22]
    d4f6:	e7e6      	b.n	d4c6 <db_hash_commit+0x66>
		*start = new_start;
    d4f8:	2001      	movs	r0, #1
	if (*end < new_end) {
    d4fa:	4291      	cmp	r1, r2
		*start = new_start;
    d4fc:	8298      	strh	r0, [r3, #20]
	if (*end < new_end) {
    d4fe:	d0e2      	beq.n	d4c6 <db_hash_commit+0x66>
    d500:	e7f6      	b.n	d4f0 <db_hash_commit+0x90>
    d502:	bf00      	nop
    d504:	2000055c 	.word	0x2000055c
    d508:	20000550 	.word	0x20000550
    d50c:	2000aa3a 	.word	0x2000aa3a
    d510:	2000aa4a 	.word	0x2000aa4a
    d514:	20000588 	.word	0x20000588
    d518:	20000570 	.word	0x20000570
    d51c:	ffff0001 	.word	0xffff0001
    d520:	200005a8 	.word	0x200005a8
    d524:	20006090 	.word	0x20006090

0000d528 <ccc_set_direct>:
{
    d528:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    d52c:	b0b9      	sub	sp, #228	; 0xe4
    d52e:	4689      	mov	r9, r1
    d530:	4617      	mov	r7, r2
		if (!settings_name_steq((const char *)param, "bt/ccc", &name)) {
    d532:	4940      	ldr	r1, [pc, #256]	; (d634 <ccc_set_direct+0x10c>)
    d534:	9840      	ldr	r0, [sp, #256]	; 0x100
    d536:	466a      	mov	r2, sp
{
    d538:	4698      	mov	r8, r3
		if (!settings_name_steq((const char *)param, "bt/ccc", &name)) {
    d53a:	f014 f9ec 	bl	21916 <settings_name_steq>
    d53e:	b998      	cbnz	r0, d568 <ccc_set_direct+0x40>
			BT_ERR("Invalid key");
    d540:	2301      	movs	r3, #1
    d542:	f04f 0100 	mov.w	r1, #0
    d546:	f363 0107 	bfi	r1, r3, #0, #8
    d54a:	4a3b      	ldr	r2, [pc, #236]	; (d638 <ccc_set_direct+0x110>)
    d54c:	4b3b      	ldr	r3, [pc, #236]	; (d63c <ccc_set_direct+0x114>)
    d54e:	483c      	ldr	r0, [pc, #240]	; (d640 <ccc_set_direct+0x118>)
    d550:	1a9b      	subs	r3, r3, r2
    d552:	08db      	lsrs	r3, r3, #3
    d554:	f363 118f 	bfi	r1, r3, #6, #10
    d558:	f013 fd6f 	bl	2103a <log_0>
			return -EINVAL;
    d55c:	f06f 0515 	mvn.w	r5, #21
}
    d560:	4628      	mov	r0, r5
    d562:	b039      	add	sp, #228	; 0xe4
    d564:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return ccc_set(name, len, read_cb, cb_arg);
    d568:	9c00      	ldr	r4, [sp, #0]
		settings_name_next(name, &next);
    d56a:	a901      	add	r1, sp, #4
    d56c:	4620      	mov	r0, r4
    d56e:	f014 f9f2 	bl	21956 <settings_name_next>
		if (!name) {
    d572:	b98c      	cbnz	r4, d598 <ccc_set_direct+0x70>
			BT_ERR("Insufficient number of arguments");
    d574:	2301      	movs	r3, #1
    d576:	f04f 0100 	mov.w	r1, #0
    d57a:	f363 0107 	bfi	r1, r3, #0, #8
    d57e:	4a2e      	ldr	r2, [pc, #184]	; (d638 <ccc_set_direct+0x110>)
    d580:	4b2e      	ldr	r3, [pc, #184]	; (d63c <ccc_set_direct+0x114>)
    d582:	4830      	ldr	r0, [pc, #192]	; (d644 <ccc_set_direct+0x11c>)
    d584:	1a9b      	subs	r3, r3, r2
    d586:	08db      	lsrs	r3, r3, #3
    d588:	f363 118f 	bfi	r1, r3, #6, #10
    d58c:	f013 fd55 	bl	2103a <log_0>
			return -EINVAL;
    d590:	f06f 0415 	mvn.w	r4, #21
			return -EINVAL;
    d594:	4625      	mov	r5, r4
    d596:	e7e3      	b.n	d560 <ccc_set_direct+0x38>
		} else if (!next) {
    d598:	9801      	ldr	r0, [sp, #4]
    d59a:	b9e0      	cbnz	r0, d5d6 <ccc_set_direct+0xae>
		err = bt_settings_decode_key(name, &addr);
    d59c:	ae02      	add	r6, sp, #8
			load.addr_with_id.id = strtol(next, NULL, 10);
    d59e:	f88d 0014 	strb.w	r0, [sp, #20]
		err = bt_settings_decode_key(name, &addr);
    d5a2:	4631      	mov	r1, r6
    d5a4:	4620      	mov	r0, r4
    d5a6:	f014 fe96 	bl	222d6 <bt_settings_decode_key>
		if (err) {
    d5aa:	4605      	mov	r5, r0
    d5ac:	b1c0      	cbz	r0, d5e0 <ccc_set_direct+0xb8>
			BT_ERR("Unable to decode address %s", log_strdup(name));
    d5ae:	2301      	movs	r3, #1
    d5b0:	f04f 0500 	mov.w	r5, #0
    d5b4:	4a20      	ldr	r2, [pc, #128]	; (d638 <ccc_set_direct+0x110>)
    d5b6:	f363 0507 	bfi	r5, r3, #0, #8
    d5ba:	4b20      	ldr	r3, [pc, #128]	; (d63c <ccc_set_direct+0x114>)
    d5bc:	1a9b      	subs	r3, r3, r2
    d5be:	08db      	lsrs	r3, r3, #3
    d5c0:	4620      	mov	r0, r4
    d5c2:	f363 158f 	bfi	r5, r3, #6, #10
    d5c6:	f7f7 fb9b 	bl	4d00 <log_strdup>
    d5ca:	462a      	mov	r2, r5
    d5cc:	4601      	mov	r1, r0
    d5ce:	481e      	ldr	r0, [pc, #120]	; (d648 <ccc_set_direct+0x120>)
    d5d0:	f013 fd40 	bl	21054 <log_1>
    d5d4:	e7dc      	b.n	d590 <ccc_set_direct+0x68>
			load.addr_with_id.id = strtol(next, NULL, 10);
    d5d6:	220a      	movs	r2, #10
    d5d8:	2100      	movs	r1, #0
    d5da:	f7f3 fa87 	bl	aec <strtol>
    d5de:	e7dd      	b.n	d59c <ccc_set_direct+0x74>
		load.addr_with_id.addr = &addr;
    d5e0:	9604      	str	r6, [sp, #16]
		if (len_rd) {
    d5e2:	f1b9 0f00 	cmp.w	r9, #0
    d5e6:	d021      	beq.n	d62c <ccc_set_direct+0x104>
			len = read_cb(cb_arg, ccc_store, sizeof(ccc_store));
    d5e8:	ae08      	add	r6, sp, #32
    d5ea:	22c0      	movs	r2, #192	; 0xc0
    d5ec:	4631      	mov	r1, r6
    d5ee:	4640      	mov	r0, r8
    d5f0:	47b8      	blx	r7
			if (len < 0) {
    d5f2:	1e04      	subs	r4, r0, #0
    d5f4:	da0f      	bge.n	d616 <ccc_set_direct+0xee>
				BT_ERR("Failed to decode value (err %d)", len);
    d5f6:	2301      	movs	r3, #1
    d5f8:	f04f 0200 	mov.w	r2, #0
    d5fc:	f363 0207 	bfi	r2, r3, #0, #8
    d600:	490d      	ldr	r1, [pc, #52]	; (d638 <ccc_set_direct+0x110>)
    d602:	4b0e      	ldr	r3, [pc, #56]	; (d63c <ccc_set_direct+0x114>)
    d604:	4811      	ldr	r0, [pc, #68]	; (d64c <ccc_set_direct+0x124>)
    d606:	1a5b      	subs	r3, r3, r1
    d608:	08db      	lsrs	r3, r3, #3
    d60a:	f363 128f 	bfi	r2, r3, #6, #10
    d60e:	4621      	mov	r1, r4
    d610:	f013 fd20 	bl	21054 <log_1>
				return len;
    d614:	e7be      	b.n	d594 <ccc_set_direct+0x6c>
			load.count = len / sizeof(*ccc_store);
    d616:	08a4      	lsrs	r4, r4, #2
			load.entry = ccc_store;
    d618:	9606      	str	r6, [sp, #24]
			load.count = len / sizeof(*ccc_store);
    d61a:	9407      	str	r4, [sp, #28]
		bt_gatt_foreach_attr(0x0001, 0xffff, ccc_load, &load);
    d61c:	ab04      	add	r3, sp, #16
    d61e:	4a0c      	ldr	r2, [pc, #48]	; (d650 <ccc_set_direct+0x128>)
    d620:	f64f 71ff 	movw	r1, #65535	; 0xffff
    d624:	2001      	movs	r0, #1
    d626:	f015 ff7c 	bl	23522 <bt_gatt_foreach_attr>
	return 0;
    d62a:	e799      	b.n	d560 <ccc_set_direct+0x38>
			load.count = 0;
    d62c:	e9cd 0006 	strd	r0, r0, [sp, #24]
    d630:	e7f4      	b.n	d61c <ccc_set_direct+0xf4>
    d632:	bf00      	nop
    d634:	00063a75 	.word	0x00063a75
    d638:	00028540 	.word	0x00028540
    d63c:	00028608 	.word	0x00028608
    d640:	00063a7c 	.word	0x00063a7c
    d644:	00062a7c 	.word	0x00062a7c
    d648:	00063c31 	.word	0x00063c31
    d64c:	00063b08 	.word	0x00063b08
    d650:	0000ca5d 	.word	0x0000ca5d

0000d654 <bt_gatt_indicate>:
{
    d654:	b570      	push	{r4, r5, r6, lr}
    d656:	4605      	mov	r5, r0
    d658:	b08a      	sub	sp, #40	; 0x28
    d65a:	460e      	mov	r6, r1
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    d65c:	4837      	ldr	r0, [pc, #220]	; (d73c <bt_gatt_indicate+0xe8>)
    d65e:	2101      	movs	r1, #1
    d660:	f015 fd87 	bl	23172 <atomic_test_bit>
    d664:	2800      	cmp	r0, #0
    d666:	d060      	beq.n	d72a <bt_gatt_indicate+0xd6>
	attr = params->attr;
    d668:	6870      	ldr	r0, [r6, #4]
    d66a:	9004      	str	r0, [sp, #16]
	if (conn && conn->state != BT_CONN_CONNECTED) {
    d66c:	b115      	cbz	r5, d674 <bt_gatt_indicate+0x20>
    d66e:	7b6b      	ldrb	r3, [r5, #13]
    d670:	2b06      	cmp	r3, #6
    d672:	d15d      	bne.n	d730 <bt_gatt_indicate+0xdc>
	handle = attr->handle ? : find_static_attr(attr);
    d674:	8a04      	ldrh	r4, [r0, #16]
    d676:	b93c      	cbnz	r4, d688 <bt_gatt_indicate+0x34>
    d678:	f7fe ffda 	bl	c630 <find_static_attr>
	if (!handle) {
    d67c:	4604      	mov	r4, r0
    d67e:	b918      	cbnz	r0, d688 <bt_gatt_indicate+0x34>
		return -ENOENT;
    d680:	f06f 0001 	mvn.w	r0, #1
}
    d684:	b00a      	add	sp, #40	; 0x28
    d686:	bd70      	pop	{r4, r5, r6, pc}
	if (params->uuid) {
    d688:	6832      	ldr	r2, [r6, #0]
    d68a:	b1b2      	cbz	r2, d6ba <bt_gatt_indicate+0x66>
		bt_gatt_foreach_attr_type(handle, 0xffff, params->uuid,
    d68c:	a904      	add	r1, sp, #16
    d68e:	9102      	str	r1, [sp, #8]
    d690:	492b      	ldr	r1, [pc, #172]	; (d740 <bt_gatt_indicate+0xec>)
    d692:	9101      	str	r1, [sp, #4]
    d694:	2101      	movs	r1, #1
		attr = NULL;
    d696:	2300      	movs	r3, #0
		bt_gatt_foreach_attr_type(handle, 0xffff, params->uuid,
    d698:	9100      	str	r1, [sp, #0]
    d69a:	4620      	mov	r0, r4
    d69c:	f64f 71ff 	movw	r1, #65535	; 0xffff
		attr = NULL;
    d6a0:	9304      	str	r3, [sp, #16]
		bt_gatt_foreach_attr_type(handle, 0xffff, params->uuid,
    d6a2:	f7ff fe21 	bl	d2e8 <bt_gatt_foreach_attr_type>
		if (!attr) {
    d6a6:	9804      	ldr	r0, [sp, #16]
    d6a8:	2800      	cmp	r0, #0
    d6aa:	d0e9      	beq.n	d680 <bt_gatt_indicate+0x2c>
		handle = attr->handle ? : find_static_attr(attr);
    d6ac:	8a04      	ldrh	r4, [r0, #16]
    d6ae:	b924      	cbnz	r4, d6ba <bt_gatt_indicate+0x66>
    d6b0:	f7fe ffbe 	bl	c630 <find_static_attr>
		if (!handle) {
    d6b4:	4604      	mov	r4, r0
    d6b6:	2800      	cmp	r0, #0
    d6b8:	d0e2      	beq.n	d680 <bt_gatt_indicate+0x2c>
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC)) {
    d6ba:	9b04      	ldr	r3, [sp, #16]
    d6bc:	6818      	ldr	r0, [r3, #0]
    d6be:	2300      	movs	r3, #0
    d6c0:	f88d 3014 	strb.w	r3, [sp, #20]
    d6c4:	a905      	add	r1, sp, #20
    d6c6:	f642 0303 	movw	r3, #10243	; 0x2803
    d6ca:	f8ad 3016 	strh.w	r3, [sp, #22]
    d6ce:	f014 fe26 	bl	2231e <bt_uuid_cmp>
    d6d2:	b938      	cbnz	r0, d6e4 <bt_gatt_indicate+0x90>
		struct bt_gatt_chrc *chrc = params->attr->user_data;
    d6d4:	6870      	ldr	r0, [r6, #4]
		if (!(chrc->properties & BT_GATT_CHRC_INDICATE)) {
    d6d6:	68c3      	ldr	r3, [r0, #12]
    d6d8:	799b      	ldrb	r3, [r3, #6]
    d6da:	069b      	lsls	r3, r3, #26
    d6dc:	d52b      	bpl.n	d736 <bt_gatt_indicate+0xe2>
		handle = bt_gatt_attr_value_handle(params->attr);
    d6de:	f7ff fdeb 	bl	d2b8 <bt_gatt_attr_value_handle>
    d6e2:	4604      	mov	r4, r0
	if (conn) {
    d6e4:	b12d      	cbz	r5, d6f2 <bt_gatt_indicate+0x9e>
		return gatt_indicate(conn, handle, params);
    d6e6:	4632      	mov	r2, r6
    d6e8:	4621      	mov	r1, r4
    d6ea:	4628      	mov	r0, r5
    d6ec:	f7ff f956 	bl	c99c <gatt_indicate>
    d6f0:	e7c8      	b.n	d684 <bt_gatt_indicate+0x30>
	data.err = -ENOTCONN;
    d6f2:	f06f 037f 	mvn.w	r3, #127	; 0x7f
    d6f6:	9307      	str	r3, [sp, #28]
	data.type = BT_GATT_CCC_INDICATE;
    d6f8:	2302      	movs	r3, #2
    d6fa:	f8ad 3020 	strh.w	r3, [sp, #32]
	bt_gatt_foreach_attr_type(handle, 0xffff, BT_UUID_GATT_CCC, NULL, 1,
    d6fe:	f642 1302 	movw	r3, #10498	; 0x2902
    d702:	f8ad 301a 	strh.w	r3, [sp, #26]
    d706:	ab07      	add	r3, sp, #28
    d708:	9302      	str	r3, [sp, #8]
    d70a:	4b0e      	ldr	r3, [pc, #56]	; (d744 <bt_gatt_indicate+0xf0>)
    d70c:	9301      	str	r3, [sp, #4]
    d70e:	2301      	movs	r3, #1
    d710:	9300      	str	r3, [sp, #0]
    d712:	4620      	mov	r0, r4
    d714:	462b      	mov	r3, r5
    d716:	aa06      	add	r2, sp, #24
    d718:	f64f 71ff 	movw	r1, #65535	; 0xffff
	data.ind_params = params;
    d71c:	9609      	str	r6, [sp, #36]	; 0x24
	bt_gatt_foreach_attr_type(handle, 0xffff, BT_UUID_GATT_CCC, NULL, 1,
    d71e:	f88d 5018 	strb.w	r5, [sp, #24]
    d722:	f7ff fde1 	bl	d2e8 <bt_gatt_foreach_attr_type>
	return data.err;
    d726:	9807      	ldr	r0, [sp, #28]
    d728:	e7ac      	b.n	d684 <bt_gatt_indicate+0x30>
		return -EAGAIN;
    d72a:	f06f 000a 	mvn.w	r0, #10
    d72e:	e7a9      	b.n	d684 <bt_gatt_indicate+0x30>
		return -ENOTCONN;
    d730:	f06f 007f 	mvn.w	r0, #127	; 0x7f
    d734:	e7a6      	b.n	d684 <bt_gatt_indicate+0x30>
			return -EINVAL;
    d736:	f06f 0015 	mvn.w	r0, #21
    d73a:	e7a3      	b.n	d684 <bt_gatt_indicate+0x30>
    d73c:	2000e548 	.word	0x2000e548
    d740:	000232ef 	.word	0x000232ef
    d744:	0000cde5 	.word	0x0000cde5

0000d748 <sc_process>:
{
    d748:	b573      	push	{r0, r1, r4, r5, r6, lr}
	atomic_clear_bit(sc->flags, SC_RANGE_CHANGED);
    d74a:	f100 0520 	add.w	r5, r0, #32
{
    d74e:	4604      	mov	r4, r0
	sc_range[0] = sys_cpu_to_le16(sc->start);
    d750:	f850 3c04 	ldr.w	r3, [r0, #-4]
    d754:	9301      	str	r3, [sp, #4]
	atomic_clear_bit(sc->flags, SC_RANGE_CHANGED);
    d756:	f1a0 0618 	sub.w	r6, r0, #24
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    d75a:	f06f 0101 	mvn.w	r1, #1
    d75e:	4628      	mov	r0, r5
    d760:	f015 fd10 	bl	23184 <atomic_and>
	sc->params.attr = &_1_gatt_svc.attrs[2];
    d764:	4b0d      	ldr	r3, [pc, #52]	; (d79c <sc_process+0x54>)
    d766:	f844 3c14 	str.w	r3, [r4, #-20]
	sc->params.func = sc_indicate_rsp;
    d76a:	4b0d      	ldr	r3, [pc, #52]	; (d7a0 <sc_process+0x58>)
    d76c:	f844 3c10 	str.w	r3, [r4, #-16]
	sc->params.data = &sc_range[0];
    d770:	ab01      	add	r3, sp, #4
	sc->start = 0U;
    d772:	2000      	movs	r0, #0
	sc->params.data = &sc_range[0];
    d774:	f844 3c0c 	str.w	r3, [r4, #-12]
	sc->params.len = sizeof(sc_range);
    d778:	2304      	movs	r3, #4
	sc->start = 0U;
    d77a:	f824 0c04 	strh.w	r0, [r4, #-4]
	sc->end = 0U;
    d77e:	f824 0c02 	strh.w	r0, [r4, #-2]
	sc->params.len = sizeof(sc_range);
    d782:	f824 3c08 	strh.w	r3, [r4, #-8]
	if (bt_gatt_indicate(NULL, &sc->params)) {
    d786:	4631      	mov	r1, r6
    d788:	f7ff ff64 	bl	d654 <bt_gatt_indicate>
    d78c:	b918      	cbnz	r0, d796 <sc_process+0x4e>
	atomic_set_bit(sc->flags, SC_INDICATE_PENDING);
    d78e:	2101      	movs	r1, #1
    d790:	4628      	mov	r0, r5
    d792:	f015 fdef 	bl	23374 <atomic_set_bit>
}
    d796:	b002      	add	sp, #8
    d798:	bd70      	pop	{r4, r5, r6, pc}
    d79a:	bf00      	nop
    d79c:	000290b8 	.word	0x000290b8
    d7a0:	0000d0ed 	.word	0x0000d0ed

0000d7a4 <update_ccc>:
{
    d7a4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
    d7a8:	4b3e      	ldr	r3, [pc, #248]	; (d8a4 <update_ccc+0x100>)
    d7aa:	6882      	ldr	r2, [r0, #8]
    d7ac:	429a      	cmp	r2, r3
{
    d7ae:	4606      	mov	r6, r0
    d7b0:	4688      	mov	r8, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
    d7b2:	d126      	bne.n	d802 <update_ccc+0x5e>
				BT_WARN("CCC %p not writable", attr);
    d7b4:	4b3c      	ldr	r3, [pc, #240]	; (d8a8 <update_ccc+0x104>)
	ccc = attr->user_data;
    d7b6:	68c7      	ldr	r7, [r0, #12]
    d7b8:	4d3c      	ldr	r5, [pc, #240]	; (d8ac <update_ccc+0x108>)
	struct bt_conn *conn = data->conn;
    d7ba:	680c      	ldr	r4, [r1, #0]
				BT_WARN("CCC %p not writable", attr);
    d7bc:	1aed      	subs	r5, r5, r3
		if (!ccc->cfg[i].value ||
    d7be:	893b      	ldrh	r3, [r7, #8]
				BT_WARN("CCC %p not writable", attr);
    d7c0:	f3c5 05c9 	ubfx	r5, r5, #3, #10
		if (!ccc->cfg[i].value ||
    d7c4:	b1eb      	cbz	r3, d802 <update_ccc+0x5e>
		    bt_conn_addr_le_cmp(conn, &ccc->cfg[i].peer)) {
    d7c6:	1c79      	adds	r1, r7, #1
    d7c8:	4620      	mov	r0, r4
    d7ca:	f014 ff90 	bl	226ee <bt_conn_addr_le_cmp>
		if (!ccc->cfg[i].value ||
    d7ce:	b9c0      	cbnz	r0, d802 <update_ccc+0x5e>
		err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_WRITE_MASK);
    d7d0:	222a      	movs	r2, #42	; 0x2a
    d7d2:	4631      	mov	r1, r6
    d7d4:	4620      	mov	r0, r4
    d7d6:	f015 fec4 	bl	23562 <bt_gatt_check_perm>
		if (err) {
    d7da:	b310      	cbz	r0, d822 <update_ccc+0x7e>
			if (err == BT_ATT_ERR_WRITE_NOT_PERMITTED) {
    d7dc:	2803      	cmp	r0, #3
    d7de:	d014      	beq.n	d80a <update_ccc+0x66>
				sec = BT_SECURITY_L3;
    d7e0:	2805      	cmp	r0, #5
			    bt_conn_get_security(conn) < sec) {
    d7e2:	4620      	mov	r0, r4
				sec = BT_SECURITY_L3;
    d7e4:	bf14      	ite	ne
    d7e6:	f04f 0902 	movne.w	r9, #2
    d7ea:	f04f 0903 	moveq.w	r9, #3
			    bt_conn_get_security(conn) < sec) {
    d7ee:	f014 ff7c 	bl	226ea <bt_conn_get_security>
			if (IS_ENABLED(CONFIG_BT_SMP) &&
    d7f2:	4548      	cmp	r0, r9
    d7f4:	d215      	bcs.n	d822 <update_ccc+0x7e>
				if (data->sec < sec) {
    d7f6:	f898 3004 	ldrb.w	r3, [r8, #4]
    d7fa:	454b      	cmp	r3, r9
    d7fc:	d201      	bcs.n	d802 <update_ccc+0x5e>
					data->sec = sec;
    d7fe:	f888 9004 	strb.w	r9, [r8, #4]
}
    d802:	2001      	movs	r0, #1
    d804:	b003      	add	sp, #12
    d806:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
				BT_WARN("CCC %p not writable", attr);
    d80a:	2302      	movs	r3, #2
    d80c:	f04f 0200 	mov.w	r2, #0
    d810:	f363 0207 	bfi	r2, r3, #0, #8
    d814:	f365 128f 	bfi	r2, r5, #6, #10
    d818:	4631      	mov	r1, r6
    d81a:	4825      	ldr	r0, [pc, #148]	; (d8b0 <update_ccc+0x10c>)
    d81c:	f013 fc1a 	bl	21054 <log_1>
				continue;
    d820:	e7ef      	b.n	d802 <update_ccc+0x5e>
		gatt_ccc_changed(attr, ccc);
    d822:	4639      	mov	r1, r7
    d824:	4630      	mov	r0, r6
    d826:	f015 fc1c 	bl	23062 <gatt_ccc_changed>
		if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) &&
    d82a:	4b22      	ldr	r3, [pc, #136]	; (d8b4 <update_ccc+0x110>)
    d82c:	429f      	cmp	r7, r3
    d82e:	d1e8      	bne.n	d802 <update_ccc+0x5e>
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    d830:	f104 0174 	add.w	r1, r4, #116	; 0x74
    d834:	7a20      	ldrb	r0, [r4, #8]
    d836:	f7ff fa6b 	bl	cd10 <find_sc_cfg.part.10>
	if (!cfg) {
    d83a:	4606      	mov	r6, r0
    d83c:	2800      	cmp	r0, #0
    d83e:	d0e0      	beq.n	d802 <update_ccc+0x5e>
	if (!(cfg->data.start || cfg->data.end)) {
    d840:	8902      	ldrh	r2, [r0, #8]
    d842:	8943      	ldrh	r3, [r0, #10]
    d844:	ea53 0102 	orrs.w	r1, r3, r2
    d848:	d0db      	beq.n	d802 <update_ccc+0x5e>
	index = bt_conn_index(conn);
    d84a:	4620      	mov	r0, r4
	sc_range[0] = sys_cpu_to_le16(cfg->data.start);
    d84c:	f8ad 2004 	strh.w	r2, [sp, #4]
	sc_range[1] = sys_cpu_to_le16(cfg->data.end);
    d850:	f8ad 3006 	strh.w	r3, [sp, #6]
	index = bt_conn_index(conn);
    d854:	f7fd fcb8 	bl	b1c8 <bt_conn_index>
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
    d858:	4917      	ldr	r1, [pc, #92]	; (d8b8 <update_ccc+0x114>)
    d85a:	4a18      	ldr	r2, [pc, #96]	; (d8bc <update_ccc+0x118>)
    d85c:	2314      	movs	r3, #20
    d85e:	fb03 1300 	mla	r3, r3, r0, r1
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
    d862:	b200      	sxth	r0, r0
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
    d864:	605a      	str	r2, [r3, #4]
	sc_restore_params[index].func = sc_restore_rsp;
    d866:	4a16      	ldr	r2, [pc, #88]	; (d8c0 <update_ccc+0x11c>)
    d868:	609a      	str	r2, [r3, #8]
	sc_restore_params[index].data = &sc_range[0];
    d86a:	aa01      	add	r2, sp, #4
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
    d86c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
	sc_restore_params[index].data = &sc_range[0];
    d870:	60da      	str	r2, [r3, #12]
	sc_restore_params[index].len = sizeof(sc_range);
    d872:	2204      	movs	r2, #4
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
    d874:	eb01 0180 	add.w	r1, r1, r0, lsl #2
	sc_restore_params[index].len = sizeof(sc_range);
    d878:	821a      	strh	r2, [r3, #16]
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
    d87a:	4620      	mov	r0, r4
    d87c:	f7ff feea 	bl	d654 <bt_gatt_indicate>
    d880:	b148      	cbz	r0, d896 <update_ccc+0xf2>
		BT_ERR("SC restore indication failed");
    d882:	f04f 0100 	mov.w	r1, #0
    d886:	2301      	movs	r3, #1
    d888:	f363 0107 	bfi	r1, r3, #0, #8
    d88c:	f365 118f 	bfi	r1, r5, #6, #10
    d890:	480c      	ldr	r0, [pc, #48]	; (d8c4 <update_ccc+0x120>)
    d892:	f013 fbd2 	bl	2103a <log_0>
    d896:	2300      	movs	r3, #0
    d898:	60b3      	str	r3, [r6, #8]
		sc_store(cfg);
    d89a:	4630      	mov	r0, r6
    d89c:	f7fe ff34 	bl	c708 <sc_store>
    d8a0:	e7af      	b.n	d802 <update_ccc+0x5e>
    d8a2:	bf00      	nop
    d8a4:	0000cb45 	.word	0x0000cb45
    d8a8:	00028540 	.word	0x00028540
    d8ac:	00028608 	.word	0x00028608
    d8b0:	00063c9f 	.word	0x00063c9f
    d8b4:	2000e818 	.word	0x2000e818
    d8b8:	200005b0 	.word	0x200005b0
    d8bc:	000290b8 	.word	0x000290b8
    d8c0:	000233bb 	.word	0x000233bb
    d8c4:	00063cb3 	.word	0x00063cb3

0000d8c8 <bt_gatt_discover>:
{
    d8c8:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (conn->state != BT_CONN_CONNECTED) {
    d8ca:	7b43      	ldrb	r3, [r0, #13]
    d8cc:	2b06      	cmp	r3, #6
{
    d8ce:	b085      	sub	sp, #20
    d8d0:	4605      	mov	r5, r0
    d8d2:	460c      	mov	r4, r1
	if (conn->state != BT_CONN_CONNECTED) {
    d8d4:	f040 80e4 	bne.w	daa0 <bt_gatt_discover+0x1d8>
	switch (params->type) {
    d8d8:	7c09      	ldrb	r1, [r1, #16]
    d8da:	2905      	cmp	r1, #5
    d8dc:	f200 80d1 	bhi.w	da82 <bt_gatt_discover+0x1ba>
    d8e0:	e8df f001 	tbb	[pc, r1]
    d8e4:	6a6a0303 	.word	0x6a6a0303
    d8e8:	bb88      	.short	0xbb88
		if (params->uuid) {
    d8ea:	6823      	ldr	r3, [r4, #0]
    d8ec:	2b00      	cmp	r3, #0
    d8ee:	d045      	beq.n	d97c <bt_gatt_discover+0xb4>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_REQ, sizeof(*req));
    d8f0:	2206      	movs	r2, #6
    d8f2:	4611      	mov	r1, r2
    d8f4:	f7fe f810 	bl	b918 <bt_att_create_pdu>
	if (!buf) {
    d8f8:	4606      	mov	r6, r0
    d8fa:	b918      	cbnz	r0, d904 <bt_gatt_discover+0x3c>
		return -ENOMEM;
    d8fc:	f06f 000b 	mvn.w	r0, #11
}
    d900:	b005      	add	sp, #20
    d902:	bdf0      	pop	{r4, r5, r6, r7, pc}
	req = net_buf_add(buf, sizeof(*req));
    d904:	f100 0708 	add.w	r7, r0, #8
    d908:	2106      	movs	r1, #6
    d90a:	4638      	mov	r0, r7
    d90c:	f017 fa64 	bl	24dd8 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
    d910:	8923      	ldrh	r3, [r4, #8]
    d912:	8003      	strh	r3, [r0, #0]
	req->end_handle = sys_cpu_to_le16(params->end_handle);
    d914:	89e3      	ldrh	r3, [r4, #14]
    d916:	8043      	strh	r3, [r0, #2]
	if (params->type == BT_GATT_DISCOVER_PRIMARY) {
    d918:	7c23      	ldrb	r3, [r4, #16]
		uuid_val = BT_UUID_16(BT_UUID_GATT_SECONDARY)->val;
    d91a:	2b00      	cmp	r3, #0
	req->type = sys_cpu_to_le16(uuid_val);
    d91c:	f642 0301 	movw	r3, #10241	; 0x2801
    d920:	bf08      	it	eq
    d922:	f44f 5320 	moveq.w	r3, #10240	; 0x2800
    d926:	8083      	strh	r3, [r0, #4]
	switch (params->uuid->type) {
    d928:	6823      	ldr	r3, [r4, #0]
    d92a:	7819      	ldrb	r1, [r3, #0]
    d92c:	b1a9      	cbz	r1, d95a <bt_gatt_discover+0x92>
    d92e:	2902      	cmp	r1, #2
    d930:	d01e      	beq.n	d970 <bt_gatt_discover+0xa8>
		BT_ERR("Unknown UUID type %u", params->uuid->type);
    d932:	2301      	movs	r3, #1
    d934:	f04f 0200 	mov.w	r2, #0
    d938:	f363 0207 	bfi	r2, r3, #0, #8
    d93c:	485a      	ldr	r0, [pc, #360]	; (daa8 <bt_gatt_discover+0x1e0>)
    d93e:	4b5b      	ldr	r3, [pc, #364]	; (daac <bt_gatt_discover+0x1e4>)
    d940:	1a1b      	subs	r3, r3, r0
    d942:	08db      	lsrs	r3, r3, #3
    d944:	485a      	ldr	r0, [pc, #360]	; (dab0 <bt_gatt_discover+0x1e8>)
    d946:	f363 128f 	bfi	r2, r3, #6, #10
    d94a:	f013 fb83 	bl	21054 <log_1>
		net_buf_unref(buf);
    d94e:	4630      	mov	r0, r6
    d950:	f00b fb84 	bl	1905c <net_buf_unref>
	return -EINVAL;
    d954:	f06f 0015 	mvn.w	r0, #21
    d958:	e7d2      	b.n	d900 <bt_gatt_discover+0x38>
		net_buf_add_le16(buf, BT_UUID_16(params->uuid)->val);
    d95a:	8859      	ldrh	r1, [r3, #2]
    d95c:	4638      	mov	r0, r7
    d95e:	f017 fa53 	bl	24e08 <net_buf_simple_add_le16>
	return gatt_send(conn, buf, gatt_find_type_rsp, params, NULL);
    d962:	4a54      	ldr	r2, [pc, #336]	; (dab4 <bt_gatt_discover+0x1ec>)
    d964:	4623      	mov	r3, r4
	return gatt_send(conn, buf, gatt_find_info_rsp, params, NULL);
    d966:	4631      	mov	r1, r6
    d968:	4628      	mov	r0, r5
    d96a:	f7fe ffd7 	bl	c91c <gatt_send.constprop.36>
    d96e:	e7c7      	b.n	d900 <bt_gatt_discover+0x38>
		net_buf_add_mem(buf, BT_UUID_128(params->uuid)->val, 16);
    d970:	2210      	movs	r2, #16
    d972:	1c59      	adds	r1, r3, #1
    d974:	4638      	mov	r0, r7
    d976:	f017 fa35 	bl	24de4 <net_buf_simple_add_mem>
		break;
    d97a:	e7f2      	b.n	d962 <bt_gatt_discover+0x9a>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_REQ, sizeof(*req));
    d97c:	2204      	movs	r2, #4
    d97e:	2110      	movs	r1, #16
    d980:	f7fd ffca 	bl	b918 <bt_att_create_pdu>
	if (!buf) {
    d984:	4606      	mov	r6, r0
    d986:	2800      	cmp	r0, #0
    d988:	d0b8      	beq.n	d8fc <bt_gatt_discover+0x34>
	req = net_buf_add(buf, sizeof(*req));
    d98a:	f100 0708 	add.w	r7, r0, #8
    d98e:	2104      	movs	r1, #4
    d990:	4638      	mov	r0, r7
    d992:	f017 fa21 	bl	24dd8 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
    d996:	8923      	ldrh	r3, [r4, #8]
    d998:	8003      	strh	r3, [r0, #0]
	req->end_handle = sys_cpu_to_le16(params->end_handle);
    d99a:	89e3      	ldrh	r3, [r4, #14]
    d99c:	8043      	strh	r3, [r0, #2]
	if (params->type == BT_GATT_DISCOVER_PRIMARY) {
    d99e:	7c23      	ldrb	r3, [r4, #16]
    d9a0:	b93b      	cbnz	r3, d9b2 <bt_gatt_discover+0xea>
		net_buf_add_le16(buf, BT_UUID_16(BT_UUID_GATT_PRIMARY)->val);
    d9a2:	f44f 5120 	mov.w	r1, #10240	; 0x2800
		net_buf_add_le16(buf, BT_UUID_16(BT_UUID_GATT_SECONDARY)->val);
    d9a6:	4638      	mov	r0, r7
    d9a8:	f017 fa2e 	bl	24e08 <net_buf_simple_add_le16>
	return gatt_send(conn, buf, gatt_read_group_rsp, params, NULL);
    d9ac:	4623      	mov	r3, r4
    d9ae:	4a42      	ldr	r2, [pc, #264]	; (dab8 <bt_gatt_discover+0x1f0>)
    d9b0:	e7d9      	b.n	d966 <bt_gatt_discover+0x9e>
		net_buf_add_le16(buf, BT_UUID_16(BT_UUID_GATT_SECONDARY)->val);
    d9b2:	f642 0101 	movw	r1, #10241	; 0x2801
    d9b6:	e7f6      	b.n	d9a6 <bt_gatt_discover+0xde>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_REQ, sizeof(*req));
    d9b8:	2204      	movs	r2, #4
    d9ba:	2108      	movs	r1, #8
    d9bc:	f7fd ffac 	bl	b918 <bt_att_create_pdu>
	if (!buf) {
    d9c0:	4606      	mov	r6, r0
    d9c2:	2800      	cmp	r0, #0
    d9c4:	d09a      	beq.n	d8fc <bt_gatt_discover+0x34>
	req = net_buf_add(buf, sizeof(*req));
    d9c6:	f100 0708 	add.w	r7, r0, #8
    d9ca:	2104      	movs	r1, #4
    d9cc:	4638      	mov	r0, r7
    d9ce:	f017 fa03 	bl	24dd8 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
    d9d2:	8923      	ldrh	r3, [r4, #8]
    d9d4:	8003      	strh	r3, [r0, #0]
	req->end_handle = sys_cpu_to_le16(params->end_handle);
    d9d6:	89e3      	ldrh	r3, [r4, #14]
    d9d8:	8043      	strh	r3, [r0, #2]
	if (params->type == BT_GATT_DISCOVER_INCLUDE) {
    d9da:	7c23      	ldrb	r3, [r4, #16]
    d9dc:	2b02      	cmp	r3, #2
		net_buf_add_le16(buf, BT_UUID_16(BT_UUID_GATT_INCLUDE)->val);
    d9de:	bf0c      	ite	eq
    d9e0:	f642 0102 	movweq	r1, #10242	; 0x2802
		net_buf_add_le16(buf, BT_UUID_16(BT_UUID_GATT_CHRC)->val);
    d9e4:	f642 0103 	movwne	r1, #10243	; 0x2803
    d9e8:	4638      	mov	r0, r7
    d9ea:	f017 fa0d 	bl	24e08 <net_buf_simple_add_le16>
	return gatt_send(conn, buf, gatt_read_type_rsp, params, NULL);
    d9ee:	4623      	mov	r3, r4
    d9f0:	4a32      	ldr	r2, [pc, #200]	; (dabc <bt_gatt_discover+0x1f4>)
    d9f2:	e7b8      	b.n	d966 <bt_gatt_discover+0x9e>
		if (params->uuid &&
    d9f4:	6820      	ldr	r0, [r4, #0]
    d9f6:	b380      	cbz	r0, da5a <bt_gatt_discover+0x192>
		    (!bt_uuid_cmp(params->uuid, BT_UUID_GATT_PRIMARY) ||
    d9f8:	2600      	movs	r6, #0
    d9fa:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    d9fe:	4669      	mov	r1, sp
    da00:	f88d 6000 	strb.w	r6, [sp]
    da04:	f8ad 3002 	strh.w	r3, [sp, #2]
    da08:	f014 fc89 	bl	2231e <bt_uuid_cmp>
		if (params->uuid &&
    da0c:	2800      	cmp	r0, #0
    da0e:	d0a1      	beq.n	d954 <bt_gatt_discover+0x8c>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_SECONDARY) ||
    da10:	f642 0301 	movw	r3, #10241	; 0x2801
    da14:	a901      	add	r1, sp, #4
    da16:	6820      	ldr	r0, [r4, #0]
    da18:	f88d 6004 	strb.w	r6, [sp, #4]
    da1c:	f8ad 3006 	strh.w	r3, [sp, #6]
    da20:	f014 fc7d 	bl	2231e <bt_uuid_cmp>
		    (!bt_uuid_cmp(params->uuid, BT_UUID_GATT_PRIMARY) ||
    da24:	2800      	cmp	r0, #0
    da26:	d095      	beq.n	d954 <bt_gatt_discover+0x8c>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_INCLUDE) ||
    da28:	f642 0302 	movw	r3, #10242	; 0x2802
    da2c:	a902      	add	r1, sp, #8
    da2e:	6820      	ldr	r0, [r4, #0]
    da30:	f88d 6008 	strb.w	r6, [sp, #8]
    da34:	f8ad 300a 	strh.w	r3, [sp, #10]
    da38:	f014 fc71 	bl	2231e <bt_uuid_cmp>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_SECONDARY) ||
    da3c:	2800      	cmp	r0, #0
    da3e:	d089      	beq.n	d954 <bt_gatt_discover+0x8c>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_CHRC))) {
    da40:	f642 0303 	movw	r3, #10243	; 0x2803
    da44:	a903      	add	r1, sp, #12
    da46:	6820      	ldr	r0, [r4, #0]
    da48:	f88d 600c 	strb.w	r6, [sp, #12]
    da4c:	f8ad 300e 	strh.w	r3, [sp, #14]
    da50:	f014 fc65 	bl	2231e <bt_uuid_cmp>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_INCLUDE) ||
    da54:	2800      	cmp	r0, #0
    da56:	f43f af7d 	beq.w	d954 <bt_gatt_discover+0x8c>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_REQ, sizeof(*req));
    da5a:	2204      	movs	r2, #4
    da5c:	4611      	mov	r1, r2
    da5e:	4628      	mov	r0, r5
    da60:	f7fd ff5a 	bl	b918 <bt_att_create_pdu>
	if (!buf) {
    da64:	4606      	mov	r6, r0
    da66:	2800      	cmp	r0, #0
    da68:	f43f af48 	beq.w	d8fc <bt_gatt_discover+0x34>
	req = net_buf_add(buf, sizeof(*req));
    da6c:	2104      	movs	r1, #4
    da6e:	3008      	adds	r0, #8
    da70:	f017 f9b2 	bl	24dd8 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
    da74:	8923      	ldrh	r3, [r4, #8]
    da76:	8003      	strh	r3, [r0, #0]
	req->end_handle = sys_cpu_to_le16(params->end_handle);
    da78:	89e3      	ldrh	r3, [r4, #14]
    da7a:	8043      	strh	r3, [r0, #2]
	return gatt_send(conn, buf, gatt_find_info_rsp, params, NULL);
    da7c:	4a10      	ldr	r2, [pc, #64]	; (dac0 <bt_gatt_discover+0x1f8>)
    da7e:	4623      	mov	r3, r4
    da80:	e771      	b.n	d966 <bt_gatt_discover+0x9e>
		BT_ERR("Invalid discovery type: %u", params->type);
    da82:	2301      	movs	r3, #1
    da84:	f04f 0200 	mov.w	r2, #0
    da88:	f363 0207 	bfi	r2, r3, #0, #8
    da8c:	4806      	ldr	r0, [pc, #24]	; (daa8 <bt_gatt_discover+0x1e0>)
    da8e:	4b07      	ldr	r3, [pc, #28]	; (daac <bt_gatt_discover+0x1e4>)
    da90:	1a1b      	subs	r3, r3, r0
    da92:	08db      	lsrs	r3, r3, #3
    da94:	f363 128f 	bfi	r2, r3, #6, #10
    da98:	480a      	ldr	r0, [pc, #40]	; (dac4 <bt_gatt_discover+0x1fc>)
    da9a:	f013 fadb 	bl	21054 <log_1>
    da9e:	e759      	b.n	d954 <bt_gatt_discover+0x8c>
		return -ENOTCONN;
    daa0:	f06f 007f 	mvn.w	r0, #127	; 0x7f
    daa4:	e72c      	b.n	d900 <bt_gatt_discover+0x38>
    daa6:	bf00      	nop
    daa8:	00028540 	.word	0x00028540
    daac:	00028608 	.word	0x00028608
    dab0:	00063a27 	.word	0x00063a27
    dab4:	000235f3 	.word	0x000235f3
    dab8:	0000dac9 	.word	0x0000dac9
    dabc:	0000dbe1 	.word	0x0000dbe1
    dac0:	0000dee1 	.word	0x0000dee1
    dac4:	00063a3c 	.word	0x00063a3c

0000dac8 <gatt_read_group_rsp>:
{
    dac8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    dacc:	b08e      	sub	sp, #56	; 0x38
    dace:	4691      	mov	r9, r2
    dad0:	4680      	mov	r8, r0
    dad2:	9d16      	ldr	r5, [sp, #88]	; 0x58
	if (err) {
    dad4:	460a      	mov	r2, r1
    dad6:	b131      	cbz	r1, dae6 <gatt_read_group_rsp+0x1e>
		params->func(conn, NULL, params);
    dad8:	686b      	ldr	r3, [r5, #4]
    dada:	462a      	mov	r2, r5
    dadc:	2100      	movs	r1, #0
	params->func(conn, NULL, params);
    dade:	4798      	blx	r3
}
    dae0:	b00e      	add	sp, #56	; 0x38
    dae2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	switch (rsp->len) {
    dae6:	f899 1000 	ldrb.w	r1, [r9]
    daea:	2906      	cmp	r1, #6
    daec:	d015      	beq.n	db1a <gatt_read_group_rsp+0x52>
    daee:	2914      	cmp	r1, #20
    daf0:	d012      	beq.n	db18 <gatt_read_group_rsp+0x50>
		BT_ERR("Invalid data len %u", rsp->len);
    daf2:	2301      	movs	r3, #1
    daf4:	f04f 0200 	mov.w	r2, #0
    daf8:	f363 0207 	bfi	r2, r3, #0, #8
    dafc:	4835      	ldr	r0, [pc, #212]	; (dbd4 <gatt_read_group_rsp+0x10c>)
    dafe:	4b36      	ldr	r3, [pc, #216]	; (dbd8 <gatt_read_group_rsp+0x110>)
    db00:	1a1b      	subs	r3, r3, r0
    db02:	08db      	lsrs	r3, r3, #3
    db04:	f363 128f 	bfi	r2, r3, #6, #10
    db08:	4834      	ldr	r0, [pc, #208]	; (dbdc <gatt_read_group_rsp+0x114>)
    db0a:	f013 faa3 	bl	21054 <log_1>
	params->func(conn, NULL, params);
    db0e:	686b      	ldr	r3, [r5, #4]
    db10:	462a      	mov	r2, r5
    db12:	2100      	movs	r1, #0
    db14:	4640      	mov	r0, r8
    db16:	e7e2      	b.n	dade <gatt_read_group_rsp+0x16>
		u.uuid.type = BT_UUID_TYPE_128;
    db18:	2202      	movs	r2, #2
	for (length--, pdu = rsp->data; length >= rsp->len;
    db1a:	3b01      	subs	r3, #1
	u16_t start_handle, end_handle = 0U;
    db1c:	2700      	movs	r7, #0
		u.uuid.type = BT_UUID_TYPE_128;
    db1e:	f88d 2010 	strb.w	r2, [sp, #16]
	for (length--, pdu = rsp->data; length >= rsp->len;
    db22:	b29c      	uxth	r4, r3
    db24:	f109 0601 	add.w	r6, r9, #1
		struct bt_gatt_attr attr = {};
    db28:	46ba      	mov	sl, r7
	for (length--, pdu = rsp->data; length >= rsp->len;
    db2a:	f899 3000 	ldrb.w	r3, [r9]
    db2e:	42a3      	cmp	r3, r4
    db30:	d909      	bls.n	db46 <gatt_read_group_rsp+0x7e>
	if (length == 0U && end_handle) {
    db32:	2c00      	cmp	r4, #0
    db34:	d1eb      	bne.n	db0e <gatt_read_group_rsp+0x46>
    db36:	2f00      	cmp	r7, #0
    db38:	d0e9      	beq.n	db0e <gatt_read_group_rsp+0x46>
	gatt_discover_next(conn, handle, params);
    db3a:	462a      	mov	r2, r5
    db3c:	4639      	mov	r1, r7
    db3e:	4640      	mov	r0, r8
    db40:	f015 fd3a 	bl	235b8 <gatt_discover_next>
    db44:	e7cc      	b.n	dae0 <gatt_read_group_rsp+0x18>
		struct bt_gatt_attr attr = {};
    db46:	2214      	movs	r2, #20
    db48:	2100      	movs	r1, #0
    db4a:	a809      	add	r0, sp, #36	; 0x24
    db4c:	f7f4 f86f 	bl	1c2e <memset>
		start_handle = sys_le16_to_cpu(data->start_handle);
    db50:	8832      	ldrh	r2, [r6, #0]
    db52:	b293      	uxth	r3, r2
		if (!start_handle) {
    db54:	2b00      	cmp	r3, #0
    db56:	d0da      	beq.n	db0e <gatt_read_group_rsp+0x46>
		end_handle = sys_le16_to_cpu(data->end_handle);
    db58:	8871      	ldrh	r1, [r6, #2]
    db5a:	b28f      	uxth	r7, r1
		if (!end_handle || end_handle < start_handle) {
    db5c:	2f00      	cmp	r7, #0
    db5e:	d0d6      	beq.n	db0e <gatt_read_group_rsp+0x46>
    db60:	42bb      	cmp	r3, r7
    db62:	d8d4      	bhi.n	db0e <gatt_read_group_rsp+0x46>
		switch (u.uuid.type) {
    db64:	f89d 3010 	ldrb.w	r3, [sp, #16]
    db68:	b31b      	cbz	r3, dbb2 <gatt_read_group_rsp+0xea>
    db6a:	2b02      	cmp	r3, #2
    db6c:	d025      	beq.n	dbba <gatt_read_group_rsp+0xf2>
		if (params->type == BT_GATT_DISCOVER_PRIMARY) {
    db6e:	7c2b      	ldrb	r3, [r5, #16]
		value.end_handle = end_handle;
    db70:	f8ad 100c 	strh.w	r1, [sp, #12]
			uuid_svc.val = BT_UUID_16(BT_UUID_GATT_SECONDARY)->val;
    db74:	2b00      	cmp	r3, #0
    db76:	f642 0301 	movw	r3, #10241	; 0x2801
    db7a:	bf08      	it	eq
    db7c:	f44f 5320 	moveq.w	r3, #10240	; 0x2800
    db80:	f8ad 3006 	strh.w	r3, [sp, #6]
		value.uuid = &u.uuid;
    db84:	ab04      	add	r3, sp, #16
    db86:	9302      	str	r3, [sp, #8]
		attr.uuid = &uuid_svc.uuid;
    db88:	ab01      	add	r3, sp, #4
    db8a:	9309      	str	r3, [sp, #36]	; 0x24
		attr.user_data = &value;
    db8c:	ab02      	add	r3, sp, #8
		attr.handle = start_handle;
    db8e:	f8ad 2034 	strh.w	r2, [sp, #52]	; 0x34
		attr.user_data = &value;
    db92:	930c      	str	r3, [sp, #48]	; 0x30
		uuid_svc.uuid.type = BT_UUID_TYPE_16;
    db94:	f88d a004 	strb.w	sl, [sp, #4]
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
    db98:	686b      	ldr	r3, [r5, #4]
    db9a:	462a      	mov	r2, r5
    db9c:	a909      	add	r1, sp, #36	; 0x24
    db9e:	4640      	mov	r0, r8
    dba0:	4798      	blx	r3
    dba2:	2800      	cmp	r0, #0
    dba4:	d09c      	beq.n	dae0 <gatt_read_group_rsp+0x18>
	     length -= rsp->len, pdu = (const u8_t *)pdu + rsp->len) {
    dba6:	f899 2000 	ldrb.w	r2, [r9]
    dbaa:	1aa4      	subs	r4, r4, r2
    dbac:	b2a4      	uxth	r4, r4
    dbae:	4416      	add	r6, r2
    dbb0:	e7bb      	b.n	db2a <gatt_read_group_rsp+0x62>
			memcpy(&u.u16.val, data->value, sizeof(u.u16.val));
    dbb2:	88b3      	ldrh	r3, [r6, #4]
    dbb4:	f8ad 3012 	strh.w	r3, [sp, #18]
			break;
    dbb8:	e7d9      	b.n	db6e <gatt_read_group_rsp+0xa6>
			memcpy(u.u128.val, data->value, sizeof(u.u128.val));
    dbba:	1d33      	adds	r3, r6, #4
    dbbc:	f10d 0011 	add.w	r0, sp, #17
    dbc0:	f106 0c14 	add.w	ip, r6, #20
    dbc4:	f853 eb04 	ldr.w	lr, [r3], #4
    dbc8:	f840 eb04 	str.w	lr, [r0], #4
    dbcc:	4563      	cmp	r3, ip
    dbce:	d1f9      	bne.n	dbc4 <gatt_read_group_rsp+0xfc>
    dbd0:	e7cd      	b.n	db6e <gatt_read_group_rsp+0xa6>
    dbd2:	bf00      	nop
    dbd4:	00028540 	.word	0x00028540
    dbd8:	00028608 	.word	0x00028608
    dbdc:	00063bb8 	.word	0x00063bb8

0000dbe0 <gatt_read_type_rsp>:
{
    dbe0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dbe4:	b091      	sub	sp, #68	; 0x44
    dbe6:	4691      	mov	r9, r2
    dbe8:	4680      	mov	r8, r0
    dbea:	9d1a      	ldr	r5, [sp, #104]	; 0x68
	if (err) {
    dbec:	460a      	mov	r2, r1
    dbee:	b121      	cbz	r1, dbfa <gatt_read_type_rsp+0x1a>
		params->func(conn, NULL, params);
    dbf0:	686b      	ldr	r3, [r5, #4]
    dbf2:	462a      	mov	r2, r5
    dbf4:	2100      	movs	r1, #0
	params->func(conn, NULL, params);
    dbf6:	4798      	blx	r3
	if (!handle) {
    dbf8:	e081      	b.n	dcfe <gatt_read_type_rsp+0x11e>
	if (params->type == BT_GATT_DISCOVER_INCLUDE) {
    dbfa:	7c28      	ldrb	r0, [r5, #16]
    dbfc:	f899 1000 	ldrb.w	r1, [r9]
    dc00:	2802      	cmp	r0, #2
    dc02:	f040 8088 	bne.w	dd16 <gatt_read_type_rsp+0x136>
	switch (rsp->len) {
    dc06:	2906      	cmp	r1, #6
    dc08:	d01b      	beq.n	dc42 <gatt_read_type_rsp+0x62>
    dc0a:	2908      	cmp	r1, #8
    dc0c:	f040 8087 	bne.w	dd1e <gatt_read_type_rsp+0x13e>
		u.uuid.type = BT_UUID_TYPE_16;
    dc10:	f88d 202c 	strb.w	r2, [sp, #44]	; 0x2c
	for (length--, pdu = rsp->data; length >= rsp->len;
    dc14:	1e5c      	subs	r4, r3, #1
    dc16:	b2a4      	uxth	r4, r4
    dc18:	f109 0a01 	add.w	sl, r9, #1
	u16_t handle = 0U;
    dc1c:	2600      	movs	r6, #0
			value.uuid = &u.uuid;
    dc1e:	f10d 0b2c 	add.w	fp, sp, #44	; 0x2c
	for (length--, pdu = rsp->data; length >= rsp->len;
    dc22:	f899 3000 	ldrb.w	r3, [r9]
    dc26:	42a3      	cmp	r3, r4
    dc28:	d90e      	bls.n	dc48 <gatt_read_type_rsp+0x68>
	if (length == 0U && handle) {
    dc2a:	2c00      	cmp	r4, #0
    dc2c:	f040 8085 	bne.w	dd3a <gatt_read_type_rsp+0x15a>
    dc30:	2e00      	cmp	r6, #0
    dc32:	f000 8082 	beq.w	dd3a <gatt_read_type_rsp+0x15a>
	gatt_discover_next(conn, handle, params);
    dc36:	462a      	mov	r2, r5
    dc38:	4631      	mov	r1, r6
    dc3a:	4640      	mov	r0, r8
    dc3c:	f015 fcbc 	bl	235b8 <gatt_discover_next>
    dc40:	e05d      	b.n	dcfe <gatt_read_type_rsp+0x11e>
		u.uuid.type = BT_UUID_TYPE_128;
    dc42:	f88d 002c 	strb.w	r0, [sp, #44]	; 0x2c
		break;
    dc46:	e7e5      	b.n	dc14 <gatt_read_type_rsp+0x34>
		handle = sys_le16_to_cpu(data->handle);
    dc48:	f8ba 7000 	ldrh.w	r7, [sl]
    dc4c:	b2be      	uxth	r6, r7
		if (!handle) {
    dc4e:	2e00      	cmp	r6, #0
    dc50:	d073      	beq.n	dd3a <gatt_read_type_rsp+0x15a>
		value.start_handle = sys_le16_to_cpu(incl->start_handle);
    dc52:	f8ba 3002 	ldrh.w	r3, [sl, #2]
    dc56:	f8ad 3014 	strh.w	r3, [sp, #20]
    dc5a:	b299      	uxth	r1, r3
		value.end_handle = sys_le16_to_cpu(incl->end_handle);
    dc5c:	f8ba 3004 	ldrh.w	r3, [sl, #4]
    dc60:	f8ad 3016 	strh.w	r3, [sp, #22]
    dc64:	b29a      	uxth	r2, r3
		switch (u.uuid.type) {
    dc66:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    dc6a:	b313      	cbz	r3, dcb2 <gatt_read_type_rsp+0xd2>
    dc6c:	2b02      	cmp	r3, #2
    dc6e:	d02b      	beq.n	dcc8 <gatt_read_type_rsp+0xe8>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
    dc70:	6829      	ldr	r1, [r5, #0]
    dc72:	2900      	cmp	r1, #0
    dc74:	d149      	bne.n	dd0a <gatt_read_type_rsp+0x12a>
		attr = (&(struct bt_gatt_attr) {
    dc76:	2210      	movs	r2, #16
    dc78:	2100      	movs	r1, #0
    dc7a:	a807      	add	r0, sp, #28
    dc7c:	f7f3 ffd7 	bl	1c2e <memset>
			.uuid = BT_UUID_GATT_INCLUDE,
    dc80:	2300      	movs	r3, #0
    dc82:	f88d 3008 	strb.w	r3, [sp, #8]
    dc86:	f642 0302 	movw	r3, #10242	; 0x2802
    dc8a:	f8ad 300a 	strh.w	r3, [sp, #10]
		attr = (&(struct bt_gatt_attr) {
    dc8e:	ab02      	add	r3, sp, #8
    dc90:	9306      	str	r3, [sp, #24]
    dc92:	ab04      	add	r3, sp, #16
		attr->handle = handle;
    dc94:	f8ad 7028 	strh.w	r7, [sp, #40]	; 0x28
		attr = (&(struct bt_gatt_attr) {
    dc98:	9309      	str	r3, [sp, #36]	; 0x24
		if (params->func(conn, attr, params) == BT_GATT_ITER_STOP) {
    dc9a:	686f      	ldr	r7, [r5, #4]
    dc9c:	462a      	mov	r2, r5
    dc9e:	a906      	add	r1, sp, #24
    dca0:	4640      	mov	r0, r8
    dca2:	47b8      	blx	r7
    dca4:	b358      	cbz	r0, dcfe <gatt_read_type_rsp+0x11e>
	     length -= rsp->len, pdu = (const u8_t *)pdu + rsp->len) {
    dca6:	f899 2000 	ldrb.w	r2, [r9]
    dcaa:	1aa4      	subs	r4, r4, r2
    dcac:	b2a4      	uxth	r4, r4
    dcae:	4492      	add	sl, r2
    dcb0:	e7b7      	b.n	dc22 <gatt_read_type_rsp+0x42>
			value.uuid = &u.uuid;
    dcb2:	f8cd b010 	str.w	fp, [sp, #16]
			u.u16.val = sys_le16_to_cpu(incl->uuid16);
    dcb6:	f89a 3006 	ldrb.w	r3, [sl, #6]
    dcba:	f89a 2007 	ldrb.w	r2, [sl, #7]
    dcbe:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    dcc2:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
			break;
    dcc6:	e7d3      	b.n	dc70 <gatt_read_type_rsp+0x90>
			params->_included.start_handle = value.start_handle;
    dcc8:	8169      	strh	r1, [r5, #10]
			params->_included.end_handle = value.end_handle;
    dcca:	81aa      	strh	r2, [r5, #12]
			params->_included.attr_handle = handle;
    dccc:	812e      	strh	r6, [r5, #8]
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_REQ, sizeof(*req));
    dcce:	461a      	mov	r2, r3
    dcd0:	210a      	movs	r1, #10
    dcd2:	4640      	mov	r0, r8
    dcd4:	9301      	str	r3, [sp, #4]
    dcd6:	f7fd fe1f 	bl	b918 <bt_att_create_pdu>
	if (!buf) {
    dcda:	4604      	mov	r4, r0
    dcdc:	b190      	cbz	r0, dd04 <gatt_read_type_rsp+0x124>
	req = net_buf_add(buf, sizeof(*req));
    dcde:	9b01      	ldr	r3, [sp, #4]
    dce0:	3008      	adds	r0, #8
    dce2:	4619      	mov	r1, r3
    dce4:	f017 f878 	bl	24dd8 <net_buf_simple_add>
	req->handle = sys_cpu_to_le16(params->_included.start_handle);
    dce8:	896b      	ldrh	r3, [r5, #10]
    dcea:	8003      	strh	r3, [r0, #0]
	return gatt_send(conn, buf, read_included_uuid_cb, params, NULL);
    dcec:	4a48      	ldr	r2, [pc, #288]	; (de10 <gatt_read_type_rsp+0x230>)
    dcee:	462b      	mov	r3, r5
    dcf0:	4621      	mov	r1, r4
    dcf2:	4640      	mov	r0, r8
    dcf4:	f7fe fe12 	bl	c91c <gatt_send.constprop.36>
			return read_included_uuid(conn, params);
    dcf8:	b286      	uxth	r6, r0
	if (!handle) {
    dcfa:	2e00      	cmp	r6, #0
    dcfc:	d19b      	bne.n	dc36 <gatt_read_type_rsp+0x56>
}
    dcfe:	b011      	add	sp, #68	; 0x44
    dd00:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return -ENOMEM;
    dd04:	f06f 000b 	mvn.w	r0, #11
    dd08:	e7f6      	b.n	dcf8 <gatt_read_type_rsp+0x118>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
    dd0a:	4658      	mov	r0, fp
    dd0c:	f014 fb07 	bl	2231e <bt_uuid_cmp>
    dd10:	2800      	cmp	r0, #0
    dd12:	d0b0      	beq.n	dc76 <gatt_read_type_rsp+0x96>
    dd14:	e7c7      	b.n	dca6 <gatt_read_type_rsp+0xc6>
	switch (rsp->len) {
    dd16:	2907      	cmp	r1, #7
    dd18:	d015      	beq.n	dd46 <gatt_read_type_rsp+0x166>
    dd1a:	2915      	cmp	r1, #21
    dd1c:	d012      	beq.n	dd44 <gatt_read_type_rsp+0x164>
		BT_ERR("Invalid data len %u", rsp->len);
    dd1e:	2301      	movs	r3, #1
    dd20:	f04f 0200 	mov.w	r2, #0
    dd24:	f363 0207 	bfi	r2, r3, #0, #8
    dd28:	483a      	ldr	r0, [pc, #232]	; (de14 <gatt_read_type_rsp+0x234>)
    dd2a:	4b3b      	ldr	r3, [pc, #236]	; (de18 <gatt_read_type_rsp+0x238>)
    dd2c:	1a1b      	subs	r3, r3, r0
    dd2e:	08db      	lsrs	r3, r3, #3
    dd30:	f363 128f 	bfi	r2, r3, #6, #10
    dd34:	4839      	ldr	r0, [pc, #228]	; (de1c <gatt_read_type_rsp+0x23c>)
    dd36:	f013 f98d 	bl	21054 <log_1>
	params->func(conn, NULL, params);
    dd3a:	686b      	ldr	r3, [r5, #4]
    dd3c:	462a      	mov	r2, r5
    dd3e:	2100      	movs	r1, #0
    dd40:	4640      	mov	r0, r8
    dd42:	e758      	b.n	dbf6 <gatt_read_type_rsp+0x16>
		u.uuid.type = BT_UUID_TYPE_128;
    dd44:	2202      	movs	r2, #2
	for (length--, pdu = rsp->data; length >= rsp->len;
    dd46:	1e5c      	subs	r4, r3, #1
	u16_t handle = 0U;
    dd48:	2600      	movs	r6, #0
		u.uuid.type = BT_UUID_TYPE_128;
    dd4a:	f88d 2018 	strb.w	r2, [sp, #24]
	for (length--, pdu = rsp->data; length >= rsp->len;
    dd4e:	b2a4      	uxth	r4, r4
    dd50:	f109 0701 	add.w	r7, r9, #1
    dd54:	f10d 0a18 	add.w	sl, sp, #24
		attr = (&(struct bt_gatt_attr)BT_GATT_CHRC(&u.uuid,
    dd58:	46b3      	mov	fp, r6
	for (length--, pdu = rsp->data; length >= rsp->len;
    dd5a:	f899 3000 	ldrb.w	r3, [r9]
    dd5e:	42a3      	cmp	r3, r4
    dd60:	f63f af63 	bhi.w	dc2a <gatt_read_type_rsp+0x4a>
		handle = sys_le16_to_cpu(data->handle);
    dd64:	883b      	ldrh	r3, [r7, #0]
    dd66:	b29e      	uxth	r6, r3
		if (!handle) {
    dd68:	2e00      	cmp	r6, #0
    dd6a:	d0e6      	beq.n	dd3a <gatt_read_type_rsp+0x15a>
		switch (u.uuid.type) {
    dd6c:	f89d 2018 	ldrb.w	r2, [sp, #24]
    dd70:	2a00      	cmp	r2, #0
    dd72:	d031      	beq.n	ddd8 <gatt_read_type_rsp+0x1f8>
    dd74:	2a02      	cmp	r2, #2
    dd76:	d036      	beq.n	dde6 <gatt_read_type_rsp+0x206>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
    dd78:	6829      	ldr	r1, [r5, #0]
    dd7a:	2900      	cmp	r1, #0
    dd7c:	d13f      	bne.n	ddfe <gatt_read_type_rsp+0x21e>
		attr = (&(struct bt_gatt_attr)BT_GATT_CHRC(&u.uuid,
    dd7e:	f642 0203 	movw	r2, #10243	; 0x2803
    dd82:	f8ad 200e 	strh.w	r2, [sp, #14]
    dd86:	aa03      	add	r2, sp, #12
    dd88:	920b      	str	r2, [sp, #44]	; 0x2c
    dd8a:	4a25      	ldr	r2, [pc, #148]	; (de20 <gatt_read_type_rsp+0x240>)
    dd8c:	f8cd b03c 	str.w	fp, [sp, #60]	; 0x3c
    dd90:	920c      	str	r2, [sp, #48]	; 0x30
    dd92:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
    dd96:	f88d b00c 	strb.w	fp, [sp, #12]
    dd9a:	f8cd a010 	str.w	sl, [sp, #16]
    dd9e:	7939      	ldrb	r1, [r7, #4]
    dda0:	78fa      	ldrb	r2, [r7, #3]
		attr->handle = handle;
    dda2:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
		attr = (&(struct bt_gatt_attr)BT_GATT_CHRC(&u.uuid,
    dda6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    ddaa:	f8ad 2014 	strh.w	r2, [sp, #20]
    ddae:	78ba      	ldrb	r2, [r7, #2]
    ddb0:	f88d 2016 	strb.w	r2, [sp, #22]
    ddb4:	aa04      	add	r2, sp, #16
    ddb6:	920e      	str	r2, [sp, #56]	; 0x38
    ddb8:	2201      	movs	r2, #1
    ddba:	f88d 203e 	strb.w	r2, [sp, #62]	; 0x3e
		if (params->func(conn, attr, params) == BT_GATT_ITER_STOP) {
    ddbe:	686b      	ldr	r3, [r5, #4]
    ddc0:	462a      	mov	r2, r5
    ddc2:	a90b      	add	r1, sp, #44	; 0x2c
    ddc4:	4640      	mov	r0, r8
    ddc6:	4798      	blx	r3
    ddc8:	2800      	cmp	r0, #0
    ddca:	d098      	beq.n	dcfe <gatt_read_type_rsp+0x11e>
	     length -= rsp->len, pdu = (const u8_t *)pdu + rsp->len) {
    ddcc:	f899 2000 	ldrb.w	r2, [r9]
    ddd0:	1aa4      	subs	r4, r4, r2
    ddd2:	b2a4      	uxth	r4, r4
    ddd4:	4417      	add	r7, r2
    ddd6:	e7c0      	b.n	dd5a <gatt_read_type_rsp+0x17a>
			u.u16.val = sys_le16_to_cpu(chrc->uuid16);
    ddd8:	797a      	ldrb	r2, [r7, #5]
    ddda:	79b9      	ldrb	r1, [r7, #6]
    dddc:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    dde0:	f8ad 201a 	strh.w	r2, [sp, #26]
			break;
    dde4:	e7c8      	b.n	dd78 <gatt_read_type_rsp+0x198>
			memcpy(u.u128.val, chrc->uuid, sizeof(chrc->uuid));
    dde6:	1d7a      	adds	r2, r7, #5
    dde8:	f10d 0119 	add.w	r1, sp, #25
    ddec:	f107 0015 	add.w	r0, r7, #21
    ddf0:	f852 cb04 	ldr.w	ip, [r2], #4
    ddf4:	f841 cb04 	str.w	ip, [r1], #4
    ddf8:	4282      	cmp	r2, r0
    ddfa:	d1f9      	bne.n	ddf0 <gatt_read_type_rsp+0x210>
    ddfc:	e7bc      	b.n	dd78 <gatt_read_type_rsp+0x198>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
    ddfe:	4650      	mov	r0, sl
    de00:	9301      	str	r3, [sp, #4]
    de02:	f014 fa8c 	bl	2231e <bt_uuid_cmp>
    de06:	9b01      	ldr	r3, [sp, #4]
    de08:	2800      	cmp	r0, #0
    de0a:	d0b8      	beq.n	dd7e <gatt_read_type_rsp+0x19e>
    de0c:	e7de      	b.n	ddcc <gatt_read_type_rsp+0x1ec>
    de0e:	bf00      	nop
    de10:	0000de25 	.word	0x0000de25
    de14:	00028540 	.word	0x00028540
    de18:	00028608 	.word	0x00028608
    de1c:	00063bb8 	.word	0x00063bb8
    de20:	000234cf 	.word	0x000234cf

0000de24 <read_included_uuid_cb>:
{
    de24:	b570      	push	{r4, r5, r6, lr}
    de26:	b08e      	sub	sp, #56	; 0x38
	if (length != 16U) {
    de28:	2b10      	cmp	r3, #16
{
    de2a:	4605      	mov	r5, r0
    de2c:	9c12      	ldr	r4, [sp, #72]	; 0x48
	if (length != 16U) {
    de2e:	d015      	beq.n	de5c <read_included_uuid_cb+0x38>
		BT_ERR("Invalid data len %u", length);
    de30:	2101      	movs	r1, #1
    de32:	f04f 0200 	mov.w	r2, #0
    de36:	f361 0207 	bfi	r2, r1, #0, #8
    de3a:	4826      	ldr	r0, [pc, #152]	; (ded4 <read_included_uuid_cb+0xb0>)
    de3c:	4926      	ldr	r1, [pc, #152]	; (ded8 <read_included_uuid_cb+0xb4>)
    de3e:	1a40      	subs	r0, r0, r1
    de40:	08c0      	lsrs	r0, r0, #3
    de42:	f360 128f 	bfi	r2, r0, #6, #10
    de46:	4619      	mov	r1, r3
    de48:	4824      	ldr	r0, [pc, #144]	; (dedc <read_included_uuid_cb+0xb8>)
    de4a:	f013 f903 	bl	21054 <log_1>
		params->func(conn, NULL, params);
    de4e:	6863      	ldr	r3, [r4, #4]
    de50:	4622      	mov	r2, r4
    de52:	2100      	movs	r1, #0
    de54:	4628      	mov	r0, r5
    de56:	4798      	blx	r3
}
    de58:	b00e      	add	sp, #56	; 0x38
    de5a:	bd70      	pop	{r4, r5, r6, pc}
	value.start_handle = params->_included.start_handle;
    de5c:	8963      	ldrh	r3, [r4, #10]
    de5e:	f8ad 300c 	strh.w	r3, [sp, #12]
	value.end_handle = params->_included.end_handle;
    de62:	89a3      	ldrh	r3, [r4, #12]
    de64:	f8ad 300e 	strh.w	r3, [sp, #14]
	value.uuid = &u.uuid;
    de68:	a804      	add	r0, sp, #16
	u.uuid.type = BT_UUID_TYPE_128;
    de6a:	2302      	movs	r3, #2
    de6c:	f88d 3010 	strb.w	r3, [sp, #16]
	value.uuid = &u.uuid;
    de70:	9002      	str	r0, [sp, #8]
	memcpy(u.u128.val, pdu, length);
    de72:	f10d 0311 	add.w	r3, sp, #17
    de76:	f102 0110 	add.w	r1, r2, #16
    de7a:	f852 6b04 	ldr.w	r6, [r2], #4
    de7e:	f843 6b04 	str.w	r6, [r3], #4
    de82:	428a      	cmp	r2, r1
    de84:	d1f9      	bne.n	de7a <read_included_uuid_cb+0x56>
	if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
    de86:	6821      	ldr	r1, [r4, #0]
    de88:	b9f9      	cbnz	r1, deca <read_included_uuid_cb+0xa6>
	attr = (&(struct bt_gatt_attr) {
    de8a:	2210      	movs	r2, #16
    de8c:	2100      	movs	r1, #0
    de8e:	a80a      	add	r0, sp, #40	; 0x28
    de90:	f7f3 fecd 	bl	1c2e <memset>
		.uuid = BT_UUID_GATT_INCLUDE,
    de94:	2300      	movs	r3, #0
    de96:	f88d 3004 	strb.w	r3, [sp, #4]
    de9a:	f642 0302 	movw	r3, #10242	; 0x2802
    de9e:	f8ad 3006 	strh.w	r3, [sp, #6]
	attr = (&(struct bt_gatt_attr) {
    dea2:	ab01      	add	r3, sp, #4
    dea4:	9309      	str	r3, [sp, #36]	; 0x24
    dea6:	ab02      	add	r3, sp, #8
    dea8:	930c      	str	r3, [sp, #48]	; 0x30
	attr->handle = params->_included.attr_handle;
    deaa:	8923      	ldrh	r3, [r4, #8]
    deac:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
	if (params->func(conn, attr, params) == BT_GATT_ITER_STOP) {
    deb0:	4622      	mov	r2, r4
    deb2:	6863      	ldr	r3, [r4, #4]
    deb4:	a909      	add	r1, sp, #36	; 0x24
    deb6:	4628      	mov	r0, r5
    deb8:	4798      	blx	r3
    deba:	2800      	cmp	r0, #0
    debc:	d0cc      	beq.n	de58 <read_included_uuid_cb+0x34>
	gatt_discover_next(conn, params->start_handle, params);
    debe:	4622      	mov	r2, r4
    dec0:	8921      	ldrh	r1, [r4, #8]
    dec2:	4628      	mov	r0, r5
    dec4:	f015 fb78 	bl	235b8 <gatt_discover_next>
	return;
    dec8:	e7c6      	b.n	de58 <read_included_uuid_cb+0x34>
	if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
    deca:	f014 fa28 	bl	2231e <bt_uuid_cmp>
    dece:	2800      	cmp	r0, #0
    ded0:	d0db      	beq.n	de8a <read_included_uuid_cb+0x66>
    ded2:	e7f4      	b.n	debe <read_included_uuid_cb+0x9a>
    ded4:	00028608 	.word	0x00028608
    ded8:	00028540 	.word	0x00028540
    dedc:	00063bb8 	.word	0x00063bb8

0000dee0 <gatt_find_info_rsp>:
{
    dee0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dee4:	b091      	sub	sp, #68	; 0x44
    dee6:	4682      	mov	sl, r0
    dee8:	9e1a      	ldr	r6, [sp, #104]	; 0x68
	if (err) {
    deea:	4608      	mov	r0, r1
    deec:	b991      	cbnz	r1, df14 <gatt_find_info_rsp+0x34>
	switch (rsp->format) {
    deee:	7811      	ldrb	r1, [r2, #0]
    def0:	2901      	cmp	r1, #1
    def2:	d015      	beq.n	df20 <gatt_find_info_rsp+0x40>
    def4:	2902      	cmp	r1, #2
    def6:	d029      	beq.n	df4c <gatt_find_info_rsp+0x6c>
		BT_ERR("Invalid format %u", rsp->format);
    def8:	2301      	movs	r3, #1
    defa:	f04f 0200 	mov.w	r2, #0
    defe:	f363 0207 	bfi	r2, r3, #0, #8
    df02:	484e      	ldr	r0, [pc, #312]	; (e03c <gatt_find_info_rsp+0x15c>)
    df04:	4b4e      	ldr	r3, [pc, #312]	; (e040 <gatt_find_info_rsp+0x160>)
    df06:	1a1b      	subs	r3, r3, r0
    df08:	08db      	lsrs	r3, r3, #3
    df0a:	f363 128f 	bfi	r2, r3, #6, #10
    df0e:	484d      	ldr	r0, [pc, #308]	; (e044 <gatt_find_info_rsp+0x164>)
    df10:	f013 f8a0 	bl	21054 <log_1>
	params->func(conn, NULL, params);
    df14:	6873      	ldr	r3, [r6, #4]
    df16:	4632      	mov	r2, r6
    df18:	2100      	movs	r1, #0
    df1a:	4650      	mov	r0, sl
    df1c:	4798      	blx	r3
    df1e:	e089      	b.n	e034 <gatt_find_info_rsp+0x154>
		u.uuid.type = BT_UUID_TYPE_16;
    df20:	f88d 0018 	strb.w	r0, [sp, #24]
		len = sizeof(*info.i16);
    df24:	f04f 0804 	mov.w	r8, #4
	length--;
    df28:	1e5c      	subs	r4, r3, #1
    df2a:	b2a4      	uxth	r4, r4
	if (length < len) {
    df2c:	4544      	cmp	r4, r8
    df2e:	d3f1      	bcc.n	df14 <gatt_find_info_rsp+0x34>
	for (i = length / len, pdu = rsp->info; i != 0;
    df30:	fbb4 f4f8 	udiv	r4, r4, r8
	bool skip = false;
    df34:	2300      	movs	r3, #0
	for (i = length / len, pdu = rsp->info; i != 0;
    df36:	1c55      	adds	r5, r2, #1
	u16_t handle = 0U;
    df38:	9301      	str	r3, [sp, #4]
    df3a:	af06      	add	r7, sp, #24
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) ||
    df3c:	4699      	mov	r9, r3
	for (i = length / len, pdu = rsp->info; i != 0;
    df3e:	b954      	cbnz	r4, df56 <gatt_find_info_rsp+0x76>
	gatt_discover_next(conn, handle, params);
    df40:	4632      	mov	r2, r6
    df42:	9901      	ldr	r1, [sp, #4]
    df44:	4650      	mov	r0, sl
    df46:	f015 fb37 	bl	235b8 <gatt_discover_next>
	return;
    df4a:	e073      	b.n	e034 <gatt_find_info_rsp+0x154>
		u.uuid.type = BT_UUID_TYPE_128;
    df4c:	f88d 1018 	strb.w	r1, [sp, #24]
		len = sizeof(*info.i128);
    df50:	f04f 0812 	mov.w	r8, #18
		break;
    df54:	e7e8      	b.n	df28 <gatt_find_info_rsp+0x48>
		handle = sys_le16_to_cpu(info.i16->handle);
    df56:	f8b5 b000 	ldrh.w	fp, [r5]
    df5a:	fa1f f28b 	uxth.w	r2, fp
    df5e:	9201      	str	r2, [sp, #4]
		if (skip) {
    df60:	b11b      	cbz	r3, df6a <gatt_find_info_rsp+0x8a>
			skip = false;
    df62:	2300      	movs	r3, #0
	     i--, pdu = (const u8_t *)pdu + len) {
    df64:	3c01      	subs	r4, #1
    df66:	4445      	add	r5, r8
    df68:	e7e9      	b.n	df3e <gatt_find_info_rsp+0x5e>
		switch (u.uuid.type) {
    df6a:	f89d 3018 	ldrb.w	r3, [sp, #24]
    df6e:	2b00      	cmp	r3, #0
    df70:	d038      	beq.n	dfe4 <gatt_find_info_rsp+0x104>
    df72:	2b02      	cmp	r3, #2
    df74:	d03d      	beq.n	dff2 <gatt_find_info_rsp+0x112>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
    df76:	6831      	ldr	r1, [r6, #0]
    df78:	2900      	cmp	r1, #0
    df7a:	d146      	bne.n	e00a <gatt_find_info_rsp+0x12a>
		if (params->type == BT_GATT_DISCOVER_DESCRIPTOR) {
    df7c:	7c33      	ldrb	r3, [r6, #16]
    df7e:	2b04      	cmp	r3, #4
    df80:	d149      	bne.n	e016 <gatt_find_info_rsp+0x136>
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) ||
    df82:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    df86:	a902      	add	r1, sp, #8
    df88:	4638      	mov	r0, r7
    df8a:	f88d 9008 	strb.w	r9, [sp, #8]
    df8e:	f8ad 300a 	strh.w	r3, [sp, #10]
    df92:	f014 f9c4 	bl	2231e <bt_uuid_cmp>
    df96:	2800      	cmp	r0, #0
    df98:	d0e3      	beq.n	df62 <gatt_find_info_rsp+0x82>
			    !bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY) ||
    df9a:	f642 0301 	movw	r3, #10241	; 0x2801
    df9e:	a903      	add	r1, sp, #12
    dfa0:	4638      	mov	r0, r7
    dfa2:	f88d 900c 	strb.w	r9, [sp, #12]
    dfa6:	f8ad 300e 	strh.w	r3, [sp, #14]
    dfaa:	f014 f9b8 	bl	2231e <bt_uuid_cmp>
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) ||
    dfae:	2800      	cmp	r0, #0
    dfb0:	d0d7      	beq.n	df62 <gatt_find_info_rsp+0x82>
			    !bt_uuid_cmp(&u.uuid, BT_UUID_GATT_INCLUDE)) {
    dfb2:	f642 0302 	movw	r3, #10242	; 0x2802
    dfb6:	a904      	add	r1, sp, #16
    dfb8:	4638      	mov	r0, r7
    dfba:	f88d 9010 	strb.w	r9, [sp, #16]
    dfbe:	f8ad 3012 	strh.w	r3, [sp, #18]
    dfc2:	f014 f9ac 	bl	2231e <bt_uuid_cmp>
			    !bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY) ||
    dfc6:	2800      	cmp	r0, #0
    dfc8:	d0cb      	beq.n	df62 <gatt_find_info_rsp+0x82>
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_CHRC)) {
    dfca:	f642 0303 	movw	r3, #10243	; 0x2803
    dfce:	a905      	add	r1, sp, #20
    dfd0:	4638      	mov	r0, r7
    dfd2:	f88d 9014 	strb.w	r9, [sp, #20]
    dfd6:	f8ad 3016 	strh.w	r3, [sp, #22]
    dfda:	f014 f9a0 	bl	2231e <bt_uuid_cmp>
    dfde:	b9d0      	cbnz	r0, e016 <gatt_find_info_rsp+0x136>
				skip = true;
    dfe0:	2301      	movs	r3, #1
    dfe2:	e7bf      	b.n	df64 <gatt_find_info_rsp+0x84>
			u.u16.val = sys_le16_to_cpu(info.i16->uuid);
    dfe4:	78ab      	ldrb	r3, [r5, #2]
    dfe6:	78ea      	ldrb	r2, [r5, #3]
    dfe8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    dfec:	f8ad 301a 	strh.w	r3, [sp, #26]
			break;
    dff0:	e7c1      	b.n	df76 <gatt_find_info_rsp+0x96>
			memcpy(u.u128.val, info.i128->uuid, 16);
    dff2:	1cab      	adds	r3, r5, #2
    dff4:	f10d 0219 	add.w	r2, sp, #25
    dff8:	f105 0112 	add.w	r1, r5, #18
    dffc:	f853 0b04 	ldr.w	r0, [r3], #4
    e000:	f842 0b04 	str.w	r0, [r2], #4
    e004:	428b      	cmp	r3, r1
    e006:	d1f9      	bne.n	dffc <gatt_find_info_rsp+0x11c>
    e008:	e7b5      	b.n	df76 <gatt_find_info_rsp+0x96>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
    e00a:	4638      	mov	r0, r7
    e00c:	f014 f987 	bl	2231e <bt_uuid_cmp>
    e010:	2800      	cmp	r0, #0
    e012:	d0b3      	beq.n	df7c <gatt_find_info_rsp+0x9c>
    e014:	e7a5      	b.n	df62 <gatt_find_info_rsp+0x82>
			BT_GATT_DESCRIPTOR(&u.uuid, 0, NULL, NULL, NULL));
    e016:	2210      	movs	r2, #16
    e018:	2100      	movs	r1, #0
    e01a:	a80c      	add	r0, sp, #48	; 0x30
    e01c:	f7f3 fe07 	bl	1c2e <memset>
    e020:	970b      	str	r7, [sp, #44]	; 0x2c
		attr->handle = handle;
    e022:	f8ad b03c 	strh.w	fp, [sp, #60]	; 0x3c
		if (params->func(conn, attr, params) == BT_GATT_ITER_STOP) {
    e026:	6873      	ldr	r3, [r6, #4]
    e028:	4632      	mov	r2, r6
    e02a:	a90b      	add	r1, sp, #44	; 0x2c
    e02c:	4650      	mov	r0, sl
    e02e:	4798      	blx	r3
    e030:	2800      	cmp	r0, #0
    e032:	d196      	bne.n	df62 <gatt_find_info_rsp+0x82>
}
    e034:	b011      	add	sp, #68	; 0x44
    e036:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e03a:	bf00      	nop
    e03c:	00028540 	.word	0x00028540
    e040:	00028608 	.word	0x00028608
    e044:	00063b56 	.word	0x00063b56

0000e048 <bt_gatt_read>:
	if (conn->state != BT_CONN_CONNECTED) {
    e048:	7b43      	ldrb	r3, [r0, #13]
    e04a:	2b06      	cmp	r3, #6
{
    e04c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e050:	4605      	mov	r5, r0
    e052:	460c      	mov	r4, r1
	if (conn->state != BT_CONN_CONNECTED) {
    e054:	d166      	bne.n	e124 <bt_gatt_read+0xdc>
	if (params->handle_count == 0) {
    e056:	684a      	ldr	r2, [r1, #4]
    e058:	bb1a      	cbnz	r2, e0a2 <bt_gatt_read+0x5a>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_REQ, sizeof(*req));
    e05a:	2204      	movs	r2, #4
    e05c:	2108      	movs	r1, #8
    e05e:	f7fd fc5b 	bl	b918 <bt_att_create_pdu>
	if (!buf) {
    e062:	4606      	mov	r6, r0
    e064:	b918      	cbnz	r0, e06e <bt_gatt_read+0x26>
		return -ENOMEM;
    e066:	f06f 000b 	mvn.w	r0, #11
}
    e06a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	req = net_buf_add(buf, sizeof(*req));
    e06e:	f100 0708 	add.w	r7, r0, #8
    e072:	2104      	movs	r1, #4
    e074:	4638      	mov	r0, r7
    e076:	f016 feaf 	bl	24dd8 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->by_uuid.start_handle);
    e07a:	8923      	ldrh	r3, [r4, #8]
    e07c:	8003      	strh	r3, [r0, #0]
	if (params->by_uuid.uuid->type == BT_UUID_TYPE_16) {
    e07e:	68e1      	ldr	r1, [r4, #12]
	req->end_handle = sys_cpu_to_le16(params->by_uuid.end_handle);
    e080:	8963      	ldrh	r3, [r4, #10]
    e082:	8043      	strh	r3, [r0, #2]
	if (params->by_uuid.uuid->type == BT_UUID_TYPE_16) {
    e084:	780b      	ldrb	r3, [r1, #0]
    e086:	b933      	cbnz	r3, e096 <bt_gatt_read+0x4e>
		net_buf_add_le16(buf, BT_UUID_16(params->by_uuid.uuid)->val);
    e088:	8849      	ldrh	r1, [r1, #2]
    e08a:	4638      	mov	r0, r7
    e08c:	f016 febc 	bl	24e08 <net_buf_simple_add_le16>
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
    e090:	4623      	mov	r3, r4
    e092:	4a26      	ldr	r2, [pc, #152]	; (e12c <bt_gatt_read+0xe4>)
    e094:	e019      	b.n	e0ca <bt_gatt_read+0x82>
		net_buf_add_mem(buf, BT_UUID_128(params->by_uuid.uuid)->val, 16);
    e096:	2210      	movs	r2, #16
    e098:	3101      	adds	r1, #1
    e09a:	4638      	mov	r0, r7
    e09c:	f016 fea2 	bl	24de4 <net_buf_simple_add_mem>
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
    e0a0:	e7f6      	b.n	e090 <bt_gatt_read+0x48>
	if (params->handle_count > 1) {
    e0a2:	2a01      	cmp	r2, #1
    e0a4:	d91e      	bls.n	e0e4 <bt_gatt_read+0x9c>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_REQ,
    e0a6:	0052      	lsls	r2, r2, #1
    e0a8:	210e      	movs	r1, #14
    e0aa:	f7fd fc35 	bl	b918 <bt_att_create_pdu>
	if (!buf) {
    e0ae:	4606      	mov	r6, r0
    e0b0:	2800      	cmp	r0, #0
    e0b2:	d0d8      	beq.n	e066 <bt_gatt_read+0x1e>
    e0b4:	2700      	movs	r7, #0
		net_buf_add_le16(buf, params->handles[i]);
    e0b6:	f100 0808 	add.w	r8, r0, #8
	for (i = 0U; i < params->handle_count; i++) {
    e0ba:	6862      	ldr	r2, [r4, #4]
    e0bc:	b2fb      	uxtb	r3, r7
    e0be:	429a      	cmp	r2, r3
    e0c0:	f107 0701 	add.w	r7, r7, #1
    e0c4:	d807      	bhi.n	e0d6 <bt_gatt_read+0x8e>
	return gatt_send(conn, buf, gatt_read_multiple_rsp, params, NULL);
    e0c6:	4a1a      	ldr	r2, [pc, #104]	; (e130 <bt_gatt_read+0xe8>)
    e0c8:	4623      	mov	r3, r4
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
    e0ca:	4631      	mov	r1, r6
    e0cc:	4628      	mov	r0, r5
}
    e0ce:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
    e0d2:	f7fe bc23 	b.w	c91c <gatt_send.constprop.36>
		net_buf_add_le16(buf, params->handles[i]);
    e0d6:	68a2      	ldr	r2, [r4, #8]
    e0d8:	4640      	mov	r0, r8
    e0da:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
    e0de:	f016 fe93 	bl	24e08 <net_buf_simple_add_le16>
    e0e2:	e7ea      	b.n	e0ba <bt_gatt_read+0x72>
	if (params->single.offset) {
    e0e4:	894b      	ldrh	r3, [r1, #10]
    e0e6:	b17b      	cbz	r3, e108 <bt_gatt_read+0xc0>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_BLOB_REQ, sizeof(*req));
    e0e8:	2204      	movs	r2, #4
    e0ea:	210c      	movs	r1, #12
    e0ec:	f7fd fc14 	bl	b918 <bt_att_create_pdu>
	if (!buf) {
    e0f0:	4606      	mov	r6, r0
    e0f2:	2800      	cmp	r0, #0
    e0f4:	d0b7      	beq.n	e066 <bt_gatt_read+0x1e>
	req = net_buf_add(buf, sizeof(*req));
    e0f6:	2104      	movs	r1, #4
    e0f8:	3008      	adds	r0, #8
    e0fa:	f016 fe6d 	bl	24dd8 <net_buf_simple_add>
	req->handle = sys_cpu_to_le16(params->single.handle);
    e0fe:	8923      	ldrh	r3, [r4, #8]
    e100:	8003      	strh	r3, [r0, #0]
	req->offset = sys_cpu_to_le16(params->single.offset);
    e102:	8963      	ldrh	r3, [r4, #10]
    e104:	8043      	strh	r3, [r0, #2]
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
    e106:	e7c3      	b.n	e090 <bt_gatt_read+0x48>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_REQ, sizeof(*req));
    e108:	2202      	movs	r2, #2
    e10a:	210a      	movs	r1, #10
    e10c:	f7fd fc04 	bl	b918 <bt_att_create_pdu>
	if (!buf) {
    e110:	4606      	mov	r6, r0
    e112:	2800      	cmp	r0, #0
    e114:	d0a7      	beq.n	e066 <bt_gatt_read+0x1e>
	req = net_buf_add(buf, sizeof(*req));
    e116:	2102      	movs	r1, #2
    e118:	3008      	adds	r0, #8
    e11a:	f016 fe5d 	bl	24dd8 <net_buf_simple_add>
	req->handle = sys_cpu_to_le16(params->single.handle);
    e11e:	8923      	ldrh	r3, [r4, #8]
    e120:	8003      	strh	r3, [r0, #0]
    e122:	e7b5      	b.n	e090 <bt_gatt_read+0x48>
		return -ENOTCONN;
    e124:	f06f 007f 	mvn.w	r0, #127	; 0x7f
    e128:	e79f      	b.n	e06a <bt_gatt_read+0x22>
    e12a:	bf00      	nop
    e12c:	0000e135 	.word	0x0000e135
    e130:	000231cd 	.word	0x000231cd

0000e134 <gatt_read_rsp>:
{
    e134:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    e138:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    e13a:	4606      	mov	r6, r0
    e13c:	4690      	mov	r8, r2
    e13e:	4699      	mov	r9, r3
	if (err || !length) {
    e140:	460f      	mov	r7, r1
    e142:	b901      	cbnz	r1, e146 <gatt_read_rsp+0x12>
    e144:	b953      	cbnz	r3, e15c <gatt_read_rsp+0x28>
		params->func(conn, err, params, NULL, 0);
    e146:	2300      	movs	r3, #0
    e148:	930a      	str	r3, [sp, #40]	; 0x28
    e14a:	6825      	ldr	r5, [r4, #0]
    e14c:	4622      	mov	r2, r4
    e14e:	4639      	mov	r1, r7
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
    e150:	4630      	mov	r0, r6
    e152:	46ac      	mov	ip, r5
}
    e154:	b003      	add	sp, #12
    e156:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
    e15a:	4760      	bx	ip
	if (!params->handle_count) {
    e15c:	6863      	ldr	r3, [r4, #4]
    e15e:	2b00      	cmp	r3, #0
    e160:	d14d      	bne.n	e1fe <gatt_read_rsp+0xca>
	for (length--, pdu = rsp->data; length;
    e162:	f109 35ff 	add.w	r5, r9, #4294967295	; 0xffffffff
    e166:	b2ad      	uxth	r5, r5
    e168:	f102 0901 	add.w	r9, r2, #1
    e16c:	b35d      	cbz	r5, e1c6 <gatt_read_rsp+0x92>
		handle = sys_le16_to_cpu(data->handle);
    e16e:	f8b9 2000 	ldrh.w	r2, [r9]
    e172:	b293      	uxth	r3, r2
		if (!handle) {
    e174:	b983      	cbnz	r3, e198 <gatt_read_rsp+0x64>
			BT_ERR("Invalid handle");
    e176:	2301      	movs	r3, #1
    e178:	f04f 0100 	mov.w	r1, #0
    e17c:	f363 0107 	bfi	r1, r3, #0, #8
    e180:	4a30      	ldr	r2, [pc, #192]	; (e244 <gatt_read_rsp+0x110>)
    e182:	4b31      	ldr	r3, [pc, #196]	; (e248 <gatt_read_rsp+0x114>)
    e184:	4831      	ldr	r0, [pc, #196]	; (e24c <gatt_read_rsp+0x118>)
    e186:	1a9b      	subs	r3, r3, r2
    e188:	08db      	lsrs	r3, r3, #3
    e18a:	f363 118f 	bfi	r1, r3, #6, #10
}
    e18e:	b003      	add	sp, #12
    e190:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
			BT_ERR("Invalid handle");
    e194:	f012 bf51 	b.w	2103a <log_0>
		len = rsp->len > length ? length - 2 : rsp->len - 2;
    e198:	f898 3000 	ldrb.w	r3, [r8]
		params->by_uuid.start_handle = handle;
    e19c:	8122      	strh	r2, [r4, #8]
		len = rsp->len > length ? length - 2 : rsp->len - 2;
    e19e:	42ab      	cmp	r3, r5
    e1a0:	bf8c      	ite	hi
    e1a2:	1eab      	subhi	r3, r5, #2
    e1a4:	3b02      	subls	r3, #2
    e1a6:	b29b      	uxth	r3, r3
		if (params->func(conn, 0, params, data->value, len) ==
    e1a8:	9300      	str	r3, [sp, #0]
    e1aa:	6827      	ldr	r7, [r4, #0]
    e1ac:	f109 0302 	add.w	r3, r9, #2
    e1b0:	4622      	mov	r2, r4
    e1b2:	2100      	movs	r1, #0
    e1b4:	4630      	mov	r0, r6
    e1b6:	47b8      	blx	r7
    e1b8:	2800      	cmp	r0, #0
    e1ba:	d03f      	beq.n	e23c <gatt_read_rsp+0x108>
		if (rsp->len > length) {
    e1bc:	f898 1000 	ldrb.w	r1, [r8]
    e1c0:	b28b      	uxth	r3, r1
    e1c2:	429d      	cmp	r5, r3
    e1c4:	d20b      	bcs.n	e1de <gatt_read_rsp+0xaa>
	if (bt_gatt_read(conn, params) < 0) {
    e1c6:	4621      	mov	r1, r4
    e1c8:	4630      	mov	r0, r6
    e1ca:	f7ff ff3d 	bl	e048 <bt_gatt_read>
    e1ce:	2800      	cmp	r0, #0
    e1d0:	da34      	bge.n	e23c <gatt_read_rsp+0x108>
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
    e1d2:	2300      	movs	r3, #0
    e1d4:	930a      	str	r3, [sp, #40]	; 0x28
    e1d6:	6825      	ldr	r5, [r4, #0]
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
    e1d8:	4622      	mov	r2, r4
    e1da:	210e      	movs	r1, #14
    e1dc:	e7b8      	b.n	e150 <gatt_read_rsp+0x1c>
		if (params->by_uuid.start_handle == params->by_uuid.end_handle) {
    e1de:	8922      	ldrh	r2, [r4, #8]
    e1e0:	8960      	ldrh	r0, [r4, #10]
    e1e2:	4290      	cmp	r0, r2
    e1e4:	d105      	bne.n	e1f2 <gatt_read_rsp+0xbe>
			params->func(conn, 0, params, NULL, 0);
    e1e6:	2300      	movs	r3, #0
    e1e8:	930a      	str	r3, [sp, #40]	; 0x28
    e1ea:	6825      	ldr	r5, [r4, #0]
		params->func(conn, 0, params, NULL, 0);
    e1ec:	4622      	mov	r2, r4
    e1ee:	4619      	mov	r1, r3
    e1f0:	e7ae      	b.n	e150 <gatt_read_rsp+0x1c>
		params->by_uuid.start_handle++;
    e1f2:	3201      	adds	r2, #1
	     length -= rsp->len, pdu = (const u8_t *)pdu + rsp->len) {
    e1f4:	1aed      	subs	r5, r5, r3
		params->by_uuid.start_handle++;
    e1f6:	8122      	strh	r2, [r4, #8]
	     length -= rsp->len, pdu = (const u8_t *)pdu + rsp->len) {
    e1f8:	b2ad      	uxth	r5, r5
    e1fa:	4489      	add	r9, r1
    e1fc:	e7b6      	b.n	e16c <gatt_read_rsp+0x38>
	if (params->func(conn, 0, params, pdu, length) == BT_GATT_ITER_STOP) {
    e1fe:	f8cd 9000 	str.w	r9, [sp]
    e202:	4613      	mov	r3, r2
    e204:	6825      	ldr	r5, [r4, #0]
    e206:	4622      	mov	r2, r4
    e208:	47a8      	blx	r5
    e20a:	b1b8      	cbz	r0, e23c <gatt_read_rsp+0x108>
	if (length < (bt_att_get_mtu(conn) - 1)) {
    e20c:	4630      	mov	r0, r6
    e20e:	f014 fe3c 	bl	22e8a <bt_att_get_mtu>
    e212:	3801      	subs	r0, #1
    e214:	4581      	cmp	r9, r0
    e216:	da03      	bge.n	e220 <gatt_read_rsp+0xec>
		params->func(conn, 0, params, NULL, 0);
    e218:	970a      	str	r7, [sp, #40]	; 0x28
    e21a:	6825      	ldr	r5, [r4, #0]
    e21c:	463b      	mov	r3, r7
    e21e:	e7e5      	b.n	e1ec <gatt_read_rsp+0xb8>
	params->single.offset += length;
    e220:	8963      	ldrh	r3, [r4, #10]
    e222:	eb09 0503 	add.w	r5, r9, r3
    e226:	8165      	strh	r5, [r4, #10]
	if (bt_gatt_read(conn, params) < 0) {
    e228:	4621      	mov	r1, r4
    e22a:	4630      	mov	r0, r6
    e22c:	f7ff ff0c 	bl	e048 <bt_gatt_read>
    e230:	2800      	cmp	r0, #0
    e232:	da03      	bge.n	e23c <gatt_read_rsp+0x108>
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
    e234:	970a      	str	r7, [sp, #40]	; 0x28
    e236:	6825      	ldr	r5, [r4, #0]
    e238:	463b      	mov	r3, r7
    e23a:	e7cd      	b.n	e1d8 <gatt_read_rsp+0xa4>
}
    e23c:	b003      	add	sp, #12
    e23e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    e242:	bf00      	nop
    e244:	00028540 	.word	0x00028540
    e248:	00028608 	.word	0x00028608
    e24c:	00063bcc 	.word	0x00063bcc

0000e250 <bt_gatt_connected>:
{
    e250:	b570      	push	{r4, r5, r6, lr}
    e252:	b08e      	sub	sp, #56	; 0x38
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    e254:	f100 0674 	add.w	r6, r0, #116	; 0x74
{
    e258:	4605      	mov	r5, r0
	data.conn = conn;
    e25a:	9003      	str	r0, [sp, #12]
	data.sec = BT_SECURITY_L1;
    e25c:	2301      	movs	r3, #1
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    e25e:	4631      	mov	r1, r6
    e260:	7a00      	ldrb	r0, [r0, #8]
	data.sec = BT_SECURITY_L1;
    e262:	f88d 3010 	strb.w	r3, [sp, #16]
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    e266:	f014 f99a 	bl	2259e <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS_CCC_LAZY_LOADING) &&
    e26a:	b190      	cbz	r0, e292 <bt_gatt_connected+0x42>
		if (conn->id) {
    e26c:	7a2a      	ldrb	r2, [r5, #8]
    e26e:	b362      	cbz	r2, e2ca <bt_gatt_connected+0x7a>
			u8_to_dec(id_str, sizeof(id_str), conn->id);
    e270:	ac02      	add	r4, sp, #8
    e272:	2104      	movs	r1, #4
    e274:	4620      	mov	r0, r4
    e276:	f011 f9df 	bl	1f638 <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "ccc",
    e27a:	9400      	str	r4, [sp, #0]
			bt_settings_encode_key(key, sizeof(key), "ccc",
    e27c:	4a1d      	ldr	r2, [pc, #116]	; (e2f4 <bt_gatt_connected+0xa4>)
    e27e:	2124      	movs	r1, #36	; 0x24
    e280:	a805      	add	r0, sp, #20
    e282:	4633      	mov	r3, r6
    e284:	f7f9 fd94 	bl	7db0 <bt_settings_encode_key>
		settings_load_subtree_direct(key, ccc_set_direct, (void *)key);
    e288:	aa05      	add	r2, sp, #20
    e28a:	491b      	ldr	r1, [pc, #108]	; (e2f8 <bt_gatt_connected+0xa8>)
    e28c:	4610      	mov	r0, r2
    e28e:	f7f7 ff1b 	bl	60c8 <settings_load_subtree_direct>
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
    e292:	f64f 71ff 	movw	r1, #65535	; 0xffff
    e296:	ab03      	add	r3, sp, #12
    e298:	4a18      	ldr	r2, [pc, #96]	; (e2fc <bt_gatt_connected+0xac>)
    e29a:	2001      	movs	r0, #1
    e29c:	f015 f941 	bl	23522 <bt_gatt_foreach_attr>
	    bt_conn_get_security(conn) < data.sec) {
    e2a0:	4628      	mov	r0, r5
    e2a2:	f014 fa22 	bl	226ea <bt_conn_get_security>
    e2a6:	f89d 1010 	ldrb.w	r1, [sp, #16]
	if (IS_ENABLED(CONFIG_BT_SMP) &&
    e2aa:	4288      	cmp	r0, r1
    e2ac:	d202      	bcs.n	e2b4 <bt_gatt_connected+0x64>
		bt_conn_set_security(conn, data.sec);
    e2ae:	4628      	mov	r0, r5
    e2b0:	f014 f9e8 	bl	22684 <bt_conn_set_security>
	sub = gatt_sub_find(conn);
    e2b4:	2100      	movs	r1, #0
    e2b6:	4628      	mov	r0, r5
    e2b8:	f7fe fcf6 	bl	cca8 <gatt_sub_find_free>
	if (!sub) {
    e2bc:	b118      	cbz	r0, e2c6 <bt_gatt_connected+0x76>
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, params, node) {
    e2be:	6884      	ldr	r4, [r0, #8]
    e2c0:	b10c      	cbz	r4, e2c6 <bt_gatt_connected+0x76>
    e2c2:	3c10      	subs	r4, #16
    e2c4:	b91c      	cbnz	r4, e2ce <bt_gatt_connected+0x7e>
}
    e2c6:	b00e      	add	sp, #56	; 0x38
    e2c8:	bd70      	pop	{r4, r5, r6, pc}
			bt_settings_encode_key(key, sizeof(key), "ccc",
    e2ca:	9200      	str	r2, [sp, #0]
    e2cc:	e7d6      	b.n	e27c <bt_gatt_connected+0x2c>
		if (bt_addr_le_is_bonded(conn->id, &conn->le.dst) &&
    e2ce:	4631      	mov	r1, r6
    e2d0:	7a28      	ldrb	r0, [r5, #8]
    e2d2:	f014 f964 	bl	2259e <bt_addr_le_is_bonded>
    e2d6:	b158      	cbz	r0, e2f0 <bt_gatt_connected+0xa0>
		    !atomic_test_bit(params->flags,
    e2d8:	2101      	movs	r1, #1
    e2da:	f104 000c 	add.w	r0, r4, #12
    e2de:	f014 ff48 	bl	23172 <atomic_test_bit>
		if (bt_addr_le_is_bonded(conn->id, &conn->le.dst) &&
    e2e2:	b928      	cbnz	r0, e2f0 <bt_gatt_connected+0xa0>
			gatt_write_ccc(conn, params->ccc_handle, params->value,
    e2e4:	4623      	mov	r3, r4
    e2e6:	8922      	ldrh	r2, [r4, #8]
    e2e8:	88e1      	ldrh	r1, [r4, #6]
    e2ea:	4628      	mov	r0, r5
    e2ec:	f7fe fca8 	bl	cc40 <gatt_write_ccc.constprop.32>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    e2f0:	6924      	ldr	r4, [r4, #16]
    e2f2:	e7e5      	b.n	e2c0 <bt_gatt_connected+0x70>
    e2f4:	00063a78 	.word	0x00063a78
    e2f8:	0000d529 	.word	0x0000d529
    e2fc:	0000d7a5 	.word	0x0000d7a5

0000e300 <bt_gatt_encrypt_change>:
{
    e300:	b507      	push	{r0, r1, r2, lr}
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
    e302:	4a06      	ldr	r2, [pc, #24]	; (e31c <bt_gatt_encrypt_change+0x1c>)
	data.conn = conn;
    e304:	9000      	str	r0, [sp, #0]
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
    e306:	466b      	mov	r3, sp
	data.sec = BT_SECURITY_L1;
    e308:	2001      	movs	r0, #1
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
    e30a:	f64f 71ff 	movw	r1, #65535	; 0xffff
	data.sec = BT_SECURITY_L1;
    e30e:	f88d 0004 	strb.w	r0, [sp, #4]
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
    e312:	f015 f906 	bl	23522 <bt_gatt_foreach_attr>
}
    e316:	b003      	add	sp, #12
    e318:	f85d fb04 	ldr.w	pc, [sp], #4
    e31c:	0000d7a5 	.word	0x0000d7a5

0000e320 <db_hash_read>:
{
    e320:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e324:	4607      	mov	r7, r0
	return k_ticks_to_ms_floor64(z_timeout_remaining(&work->timeout));
    e326:	4811      	ldr	r0, [pc, #68]	; (e36c <db_hash_read+0x4c>)
    e328:	f8bd 6018 	ldrh.w	r6, [sp, #24]
    e32c:	461d      	mov	r5, r3
    e32e:	4614      	mov	r4, r2
    e330:	f010 ff56 	bl	1f1e0 <z_timeout_remaining>
    e334:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    e338:	fb80 0103 	smull	r0, r1, r0, r3
    e33c:	0bc3      	lsrs	r3, r0, #15
	if (k_delayed_work_remaining_get(&db_hash_work)) {
    e33e:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
    e342:	d005      	beq.n	e350 <db_hash_read+0x30>
		k_delayed_work_cancel(&db_hash_work);
    e344:	480a      	ldr	r0, [pc, #40]	; (e370 <db_hash_read+0x50>)
    e346:	f019 fde6 	bl	27f16 <k_delayed_work_cancel>
		db_hash_gen(true);
    e34a:	2001      	movs	r0, #1
    e34c:	f7ff f834 	bl	d3b8 <db_hash_gen>
	bt_gatt_change_aware(conn, true);
    e350:	2101      	movs	r1, #1
    e352:	4638      	mov	r0, r7
    e354:	f015 fa34 	bl	237c0 <bt_gatt_change_aware>
	return bt_gatt_attr_read(conn, attr, buf, len, offset, db_hash,
    e358:	2310      	movs	r3, #16
    e35a:	9306      	str	r3, [sp, #24]
    e35c:	4632      	mov	r2, r6
    e35e:	4629      	mov	r1, r5
    e360:	4620      	mov	r0, r4
    e362:	4b04      	ldr	r3, [pc, #16]	; (e374 <db_hash_read+0x54>)
}
    e364:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_gatt_attr_read(conn, attr, buf, len, offset, db_hash,
    e368:	f014 bf56 	b.w	23218 <bt_gatt_attr_read.constprop.33>
    e36c:	2000055c 	.word	0x2000055c
    e370:	20000550 	.word	0x20000550
    e374:	2000aa3a 	.word	0x2000aa3a

0000e378 <bt_gatt_store_ccc>:
{
    e378:	b570      	push	{r4, r5, r6, lr}
    e37a:	b0c0      	sub	sp, #256	; 0x100
	save.count = 0;
    e37c:	2300      	movs	r3, #0
{
    e37e:	4604      	mov	r4, r0
    e380:	460d      	mov	r5, r1
	save.addr_with_id.addr = addr;
    e382:	910d      	str	r1, [sp, #52]	; 0x34
	save.addr_with_id.id = id;
    e384:	f88d 0038 	strb.w	r0, [sp, #56]	; 0x38
	save.count = 0;
    e388:	933f      	str	r3, [sp, #252]	; 0xfc
	bt_gatt_foreach_attr(0x0001, 0xffff, ccc_save, &save);
    e38a:	4a1a      	ldr	r2, [pc, #104]	; (e3f4 <bt_gatt_store_ccc+0x7c>)
    e38c:	ab0d      	add	r3, sp, #52	; 0x34
    e38e:	f64f 71ff 	movw	r1, #65535	; 0xffff
    e392:	2001      	movs	r0, #1
    e394:	f015 f8c5 	bl	23522 <bt_gatt_foreach_attr>
	if (id) {
    e398:	b33c      	cbz	r4, e3ea <bt_gatt_store_ccc+0x72>
		u8_to_dec(id_str, sizeof(id_str), id);
    e39a:	ae03      	add	r6, sp, #12
    e39c:	4622      	mov	r2, r4
    e39e:	2104      	movs	r1, #4
    e3a0:	4630      	mov	r0, r6
    e3a2:	f011 f949 	bl	1f638 <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "ccc",
    e3a6:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "ccc",
    e3a8:	4a13      	ldr	r2, [pc, #76]	; (e3f8 <bt_gatt_store_ccc+0x80>)
    e3aa:	462b      	mov	r3, r5
    e3ac:	2124      	movs	r1, #36	; 0x24
    e3ae:	a804      	add	r0, sp, #16
    e3b0:	f7f9 fcfe 	bl	7db0 <bt_settings_encode_key>
	if (save.count) {
    e3b4:	9a3f      	ldr	r2, [sp, #252]	; 0xfc
    e3b6:	b1d2      	cbz	r2, e3ee <bt_gatt_store_ccc+0x76>
		len = save.count * sizeof(*save.store);
    e3b8:	0092      	lsls	r2, r2, #2
		str = (char *)save.store;
    e3ba:	a90f      	add	r1, sp, #60	; 0x3c
	err = settings_save_one(key, str, len);
    e3bc:	a804      	add	r0, sp, #16
    e3be:	f7f7 fe3b 	bl	6038 <settings_save_one>
	if (err) {
    e3c2:	4604      	mov	r4, r0
    e3c4:	b170      	cbz	r0, e3e4 <bt_gatt_store_ccc+0x6c>
		BT_ERR("Failed to store CCCs (err %d)", err);
    e3c6:	2301      	movs	r3, #1
    e3c8:	f04f 0200 	mov.w	r2, #0
    e3cc:	f363 0207 	bfi	r2, r3, #0, #8
    e3d0:	490a      	ldr	r1, [pc, #40]	; (e3fc <bt_gatt_store_ccc+0x84>)
    e3d2:	4b0b      	ldr	r3, [pc, #44]	; (e400 <bt_gatt_store_ccc+0x88>)
    e3d4:	1a5b      	subs	r3, r3, r1
    e3d6:	08db      	lsrs	r3, r3, #3
    e3d8:	4601      	mov	r1, r0
    e3da:	f363 128f 	bfi	r2, r3, #6, #10
    e3de:	4809      	ldr	r0, [pc, #36]	; (e404 <bt_gatt_store_ccc+0x8c>)
    e3e0:	f012 fe38 	bl	21054 <log_1>
}
    e3e4:	4620      	mov	r0, r4
    e3e6:	b040      	add	sp, #256	; 0x100
    e3e8:	bd70      	pop	{r4, r5, r6, pc}
		bt_settings_encode_key(key, sizeof(key), "ccc",
    e3ea:	9400      	str	r4, [sp, #0]
    e3ec:	e7dc      	b.n	e3a8 <bt_gatt_store_ccc+0x30>
		str = NULL;
    e3ee:	4611      	mov	r1, r2
    e3f0:	e7e4      	b.n	e3bc <bt_gatt_store_ccc+0x44>
    e3f2:	bf00      	nop
    e3f4:	0000ca25 	.word	0x0000ca25
    e3f8:	00063a78 	.word	0x00063a78
    e3fc:	00028540 	.word	0x00028540
    e400:	00028608 	.word	0x00028608
    e404:	00063a57 	.word	0x00063a57

0000e408 <bt_gatt_disconnected>:
{
    e408:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e40c:	4604      	mov	r4, r0
    e40e:	b08c      	sub	sp, #48	; 0x30
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
    e410:	4603      	mov	r3, r0
    e412:	f64f 71ff 	movw	r1, #65535	; 0xffff
    e416:	2001      	movs	r0, #1
    e418:	4a49      	ldr	r2, [pc, #292]	; (e540 <bt_gatt_disconnected+0x138>)
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    e41a:	f104 0574 	add.w	r5, r4, #116	; 0x74
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
    e41e:	f015 f880 	bl	23522 <bt_gatt_foreach_attr>
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    e422:	4629      	mov	r1, r5
    e424:	7a20      	ldrb	r0, [r4, #8]
    e426:	f014 f8ba 	bl	2259e <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
    e42a:	2800      	cmp	r0, #0
    e42c:	d039      	beq.n	e4a2 <bt_gatt_disconnected+0x9a>
		bt_gatt_store_ccc(conn->id, &conn->le.dst);
    e42e:	4629      	mov	r1, r5
    e430:	7a20      	ldrb	r0, [r4, #8]
    e432:	f7ff ffa1 	bl	e378 <bt_gatt_store_ccc>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    e436:	4620      	mov	r0, r4
    e438:	f7fe fdd6 	bl	cfe8 <find_cf_cfg.part.9>
	if (!cfg) {
    e43c:	4606      	mov	r6, r0
    e43e:	2800      	cmp	r0, #0
    e440:	d054      	beq.n	e4ec <bt_gatt_disconnected+0xe4>
		if (conn->id) {
    e442:	7a22      	ldrb	r2, [r4, #8]
		str = (char *)cfg->data;
    e444:	3608      	adds	r6, #8
		if (conn->id) {
    e446:	2a00      	cmp	r2, #0
    e448:	d052      	beq.n	e4f0 <bt_gatt_disconnected+0xe8>
			u8_to_dec(id_str, sizeof(id_str), conn->id);
    e44a:	af02      	add	r7, sp, #8
    e44c:	2104      	movs	r1, #4
    e44e:	4638      	mov	r0, r7
    e450:	f011 f8f2 	bl	1f638 <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "cf",
    e454:	9700      	str	r7, [sp, #0]
    e456:	462b      	mov	r3, r5
    e458:	4a3a      	ldr	r2, [pc, #232]	; (e544 <bt_gatt_disconnected+0x13c>)
    e45a:	2124      	movs	r1, #36	; 0x24
    e45c:	a803      	add	r0, sp, #12
    e45e:	f7f9 fca7 	bl	7db0 <bt_settings_encode_key>
	if (!cfg || !conn->id) {
    e462:	7a23      	ldrb	r3, [r4, #8]
    e464:	2701      	movs	r7, #1
    e466:	b93b      	cbnz	r3, e478 <bt_gatt_disconnected+0x70>
		bt_settings_encode_key(key, sizeof(key), "cf",
    e468:	2300      	movs	r3, #0
    e46a:	9300      	str	r3, [sp, #0]
    e46c:	4a35      	ldr	r2, [pc, #212]	; (e544 <bt_gatt_disconnected+0x13c>)
    e46e:	462b      	mov	r3, r5
    e470:	2124      	movs	r1, #36	; 0x24
    e472:	a803      	add	r0, sp, #12
    e474:	f7f9 fc9c 	bl	7db0 <bt_settings_encode_key>
	err = settings_save_one(key, str, len);
    e478:	4631      	mov	r1, r6
    e47a:	463a      	mov	r2, r7
    e47c:	a803      	add	r0, sp, #12
    e47e:	f7f7 fddb 	bl	6038 <settings_save_one>
	if (err) {
    e482:	4601      	mov	r1, r0
    e484:	b168      	cbz	r0, e4a2 <bt_gatt_disconnected+0x9a>
		BT_ERR("Failed to store Client Features (err %d)", err);
    e486:	2301      	movs	r3, #1
    e488:	f04f 0200 	mov.w	r2, #0
    e48c:	f363 0207 	bfi	r2, r3, #0, #8
    e490:	482d      	ldr	r0, [pc, #180]	; (e548 <bt_gatt_disconnected+0x140>)
    e492:	4b2e      	ldr	r3, [pc, #184]	; (e54c <bt_gatt_disconnected+0x144>)
    e494:	1a1b      	subs	r3, r3, r0
    e496:	08db      	lsrs	r3, r3, #3
    e498:	f363 128f 	bfi	r2, r3, #6, #10
    e49c:	482c      	ldr	r0, [pc, #176]	; (e550 <bt_gatt_disconnected+0x148>)
    e49e:	f012 fdd9 	bl	21054 <log_1>
	sub = gatt_sub_find(conn);
    e4a2:	2100      	movs	r1, #0
    e4a4:	4620      	mov	r0, r4
    e4a6:	f7fe fbff 	bl	cca8 <gatt_sub_find_free>
	if (!sub) {
    e4aa:	4680      	mov	r8, r0
    e4ac:	b398      	cbz	r0, e516 <bt_gatt_disconnected+0x10e>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
    e4ae:	6883      	ldr	r3, [r0, #8]
    e4b0:	b38b      	cbz	r3, e516 <bt_gatt_disconnected+0x10e>
    e4b2:	f1b3 0710 	subs.w	r7, r3, #16
    e4b6:	d02e      	beq.n	e516 <bt_gatt_disconnected+0x10e>
    e4b8:	681e      	ldr	r6, [r3, #0]
    e4ba:	b106      	cbz	r6, e4be <bt_gatt_disconnected+0xb6>
    e4bc:	3e10      	subs	r6, #16
	if (!cfg || !conn->id) {
    e4be:	f04f 0900 	mov.w	r9, #0
		    (atomic_test_bit(params->flags,
    e4c2:	46ca      	mov	sl, r9
		if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst) ||
    e4c4:	4629      	mov	r1, r5
    e4c6:	7a20      	ldrb	r0, [r4, #8]
    e4c8:	f014 f869 	bl	2259e <bt_addr_le_is_bonded>
    e4cc:	b990      	cbnz	r0, e4f4 <bt_gatt_disconnected+0xec>
			params->value = 0U;
    e4ce:	f8a7 a008 	strh.w	sl, [r7, #8]
			gatt_sub_remove(conn, sub, prev, params);
    e4d2:	463b      	mov	r3, r7
    e4d4:	464a      	mov	r2, r9
    e4d6:	4641      	mov	r1, r8
    e4d8:	4620      	mov	r0, r4
    e4da:	f014 ff94 	bl	23406 <gatt_sub_remove>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
    e4de:	b1d6      	cbz	r6, e516 <bt_gatt_disconnected+0x10e>
    e4e0:	6933      	ldr	r3, [r6, #16]
    e4e2:	b103      	cbz	r3, e4e6 <bt_gatt_disconnected+0xde>
    e4e4:	3b10      	subs	r3, #16
	if (!cfg || !conn->id) {
    e4e6:	4637      	mov	r7, r6
    e4e8:	461e      	mov	r6, r3
    e4ea:	e7eb      	b.n	e4c4 <bt_gatt_disconnected+0xbc>
		len = 0;
    e4ec:	4607      	mov	r7, r0
    e4ee:	e7bb      	b.n	e468 <bt_gatt_disconnected+0x60>
		if (conn->id) {
    e4f0:	2701      	movs	r7, #1
    e4f2:	e7b9      	b.n	e468 <bt_gatt_disconnected+0x60>
		    (atomic_test_bit(params->flags,
    e4f4:	2100      	movs	r1, #0
    e4f6:	f107 000c 	add.w	r0, r7, #12
    e4fa:	f014 fe3a 	bl	23172 <atomic_test_bit>
		if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst) ||
    e4fe:	2800      	cmp	r0, #0
    e500:	d1e5      	bne.n	e4ce <bt_gatt_disconnected+0xc6>
	if (sub->peer.type == BT_ADDR_LE_PUBLIC) {
    e502:	f898 3000 	ldrb.w	r3, [r8]
    e506:	b11b      	cbz	r3, e510 <bt_gatt_disconnected+0x108>
	bt_addr_le_copy(&sub->peer, &conn->le.dst);
    e508:	4629      	mov	r1, r5
    e50a:	4640      	mov	r0, r8
    e50c:	f014 fe49 	bl	231a2 <bt_addr_le_copy>
			prev = &params->node;
    e510:	f107 0910 	add.w	r9, r7, #16
    e514:	e7e3      	b.n	e4de <bt_gatt_disconnected+0xd6>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    e516:	4620      	mov	r0, r4
    e518:	f7fe fd66 	bl	cfe8 <find_cf_cfg.part.9>
	if (!cfg) {
    e51c:	4606      	mov	r6, r0
    e51e:	b138      	cbz	r0, e530 <bt_gatt_disconnected+0x128>
	if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    e520:	4629      	mov	r1, r5
    e522:	7a20      	ldrb	r0, [r4, #8]
    e524:	f014 f83b 	bl	2259e <bt_addr_le_is_bonded>
    e528:	b928      	cbnz	r0, e536 <bt_gatt_disconnected+0x12e>
		clear_cf_cfg(cfg);
    e52a:	4630      	mov	r0, r6
    e52c:	f014 fec7 	bl	232be <clear_cf_cfg>
}
    e530:	b00c      	add	sp, #48	; 0x30
    e532:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
    e536:	4629      	mov	r1, r5
    e538:	1c70      	adds	r0, r6, #1
    e53a:	f014 fe32 	bl	231a2 <bt_addr_le_copy>
}
    e53e:	e7f7      	b.n	e530 <bt_gatt_disconnected+0x128>
    e540:	0000c871 	.word	0x0000c871
    e544:	00063c8e 	.word	0x00063c8e
    e548:	00028540 	.word	0x00028540
    e54c:	00028608 	.word	0x00028608
    e550:	000639fe 	.word	0x000639fe

0000e554 <bt_gatt_clear>:
{
    e554:	b570      	push	{r4, r5, r6, lr}
    e556:	b08e      	sub	sp, #56	; 0x38
    e558:	4605      	mov	r5, r0
    e55a:	460c      	mov	r4, r1
	struct addr_with_id addr_with_id = {
    e55c:	9103      	str	r1, [sp, #12]
    e55e:	f88d 0010 	strb.w	r0, [sp, #16]
	if (id) {
    e562:	2800      	cmp	r0, #0
    e564:	d049      	beq.n	e5fa <bt_gatt_clear+0xa6>
		u8_to_dec(id_str, sizeof(id_str), id);
    e566:	ae02      	add	r6, sp, #8
    e568:	4602      	mov	r2, r0
    e56a:	2104      	movs	r1, #4
    e56c:	4630      	mov	r0, r6
    e56e:	f011 f863 	bl	1f638 <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "ccc",
    e572:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "ccc",
    e574:	4623      	mov	r3, r4
    e576:	4a30      	ldr	r2, [pc, #192]	; (e638 <bt_gatt_clear+0xe4>)
    e578:	2124      	movs	r1, #36	; 0x24
    e57a:	a805      	add	r0, sp, #20
	bt_gatt_foreach_attr(0x0001, 0xffff, remove_peer_from_attr,
    e57c:	ae03      	add	r6, sp, #12
		bt_settings_encode_key(key, sizeof(key), "ccc",
    e57e:	f7f9 fc17 	bl	7db0 <bt_settings_encode_key>
	bt_gatt_foreach_attr(0x0001, 0xffff, remove_peer_from_attr,
    e582:	4633      	mov	r3, r6
    e584:	4a2d      	ldr	r2, [pc, #180]	; (e63c <bt_gatt_clear+0xe8>)
    e586:	f64f 71ff 	movw	r1, #65535	; 0xffff
    e58a:	2001      	movs	r0, #1
    e58c:	f014 ffc9 	bl	23522 <bt_gatt_foreach_attr>
	return settings_delete(key);
    e590:	a805      	add	r0, sp, #20
    e592:	f013 f9bc 	bl	2190e <settings_delete>
	if (err < 0) {
    e596:	2800      	cmp	r0, #0
    e598:	db2d      	blt.n	e5f6 <bt_gatt_clear+0xa2>
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    e59a:	4621      	mov	r1, r4
    e59c:	4628      	mov	r0, r5
    e59e:	f7fe fbb7 	bl	cd10 <find_sc_cfg.part.10>
		if (cfg) {
    e5a2:	b108      	cbz	r0, e5a8 <bt_gatt_clear+0x54>
			sc_clear(cfg);
    e5a4:	f7fe f924 	bl	c7f0 <sc_clear>
	if (id) {
    e5a8:	b34d      	cbz	r5, e5fe <bt_gatt_clear+0xaa>
		u8_to_dec(id_str, sizeof(id_str), id);
    e5aa:	462a      	mov	r2, r5
    e5ac:	2104      	movs	r1, #4
    e5ae:	4630      	mov	r0, r6
    e5b0:	f011 f842 	bl	1f638 <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "cf",
    e5b4:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "cf",
    e5b6:	a805      	add	r0, sp, #20
    e5b8:	4623      	mov	r3, r4
    e5ba:	4a21      	ldr	r2, [pc, #132]	; (e640 <bt_gatt_clear+0xec>)
    e5bc:	2124      	movs	r1, #36	; 0x24
    e5be:	f7f9 fbf7 	bl	7db0 <bt_settings_encode_key>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    e5c2:	4620      	mov	r0, r4
    e5c4:	f7fe faa4 	bl	cb10 <find_cf_cfg_by_addr.part.12>
	if (cfg) {
    e5c8:	b108      	cbz	r0, e5ce <bt_gatt_clear+0x7a>
		clear_cf_cfg(cfg);
    e5ca:	f014 fe78 	bl	232be <clear_cf_cfg>
	return settings_delete(key);
    e5ce:	a805      	add	r0, sp, #20
    e5d0:	f013 f99d 	bl	2190e <settings_delete>
	if (err < 0) {
    e5d4:	2800      	cmp	r0, #0
    e5d6:	db0e      	blt.n	e5f6 <bt_gatt_clear+0xa2>
    e5d8:	2207      	movs	r2, #7
    e5da:	491a      	ldr	r1, [pc, #104]	; (e644 <bt_gatt_clear+0xf0>)
    e5dc:	4d19      	ldr	r5, [pc, #100]	; (e644 <bt_gatt_clear+0xf0>)
    e5de:	4620      	mov	r0, r4
    e5e0:	f7f3 faf6 	bl	1bd0 <memcmp>
		if (!bt_addr_le_cmp(addr, &subscriptions[i].peer)) {
    e5e4:	b170      	cbz	r0, e604 <bt_gatt_clear+0xb0>
    e5e6:	2207      	movs	r2, #7
    e5e8:	f105 0110 	add.w	r1, r5, #16
    e5ec:	4620      	mov	r0, r4
    e5ee:	f7f3 faef 	bl	1bd0 <memcmp>
    e5f2:	b130      	cbz	r0, e602 <bt_gatt_clear+0xae>
	return 0;
    e5f4:	2000      	movs	r0, #0
}
    e5f6:	b00e      	add	sp, #56	; 0x38
    e5f8:	bd70      	pop	{r4, r5, r6, pc}
		bt_settings_encode_key(key, sizeof(key), "ccc",
    e5fa:	9000      	str	r0, [sp, #0]
    e5fc:	e7ba      	b.n	e574 <bt_gatt_clear+0x20>
		bt_settings_encode_key(key, sizeof(key), "cf",
    e5fe:	9500      	str	r5, [sp, #0]
    e600:	e7d9      	b.n	e5b6 <bt_gatt_clear+0x62>
	for (i = 0; i < ARRAY_SIZE(subscriptions); i++) {
    e602:	2001      	movs	r0, #1
			sub = &subscriptions[i];
    e604:	eb05 1500 	add.w	r5, r5, r0, lsl #4
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
    e608:	68aa      	ldr	r2, [r5, #8]
    e60a:	2a00      	cmp	r2, #0
    e60c:	d0f2      	beq.n	e5f4 <bt_gatt_clear+0xa0>
    e60e:	f1b2 0310 	subs.w	r3, r2, #16
    e612:	d0ef      	beq.n	e5f4 <bt_gatt_clear+0xa0>
    e614:	6814      	ldr	r4, [r2, #0]
    e616:	b104      	cbz	r4, e61a <bt_gatt_clear+0xc6>
    e618:	3c10      	subs	r4, #16
		params->value = 0U;
    e61a:	2600      	movs	r6, #0
		gatt_sub_remove(NULL, sub, prev, params);
    e61c:	2200      	movs	r2, #0
		params->value = 0U;
    e61e:	811e      	strh	r6, [r3, #8]
		gatt_sub_remove(NULL, sub, prev, params);
    e620:	4629      	mov	r1, r5
    e622:	4610      	mov	r0, r2
    e624:	f014 feef 	bl	23406 <gatt_sub_remove>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
    e628:	2c00      	cmp	r4, #0
    e62a:	d0e3      	beq.n	e5f4 <bt_gatt_clear+0xa0>
    e62c:	6922      	ldr	r2, [r4, #16]
    e62e:	b102      	cbz	r2, e632 <bt_gatt_clear+0xde>
    e630:	3a10      	subs	r2, #16
	for (i = 0; i < ARRAY_SIZE(subscriptions); i++) {
    e632:	4623      	mov	r3, r4
    e634:	4614      	mov	r4, r2
    e636:	e7f1      	b.n	e61c <bt_gatt_clear+0xc8>
    e638:	00063a78 	.word	0x00063a78
    e63c:	0000cae9 	.word	0x0000cae9
    e640:	00063c8e 	.word	0x00063c8e
    e644:	200005c4 	.word	0x200005c4

0000e648 <get_io_capa>:
static const u8_t *sc_public_key;
static K_SEM_DEFINE(sc_local_pkey_ready, 0, 1);

static u8_t get_io_capa(void)
{
	if (!bt_auth) {
    e648:	4b10      	ldr	r3, [pc, #64]	; (e68c <get_io_capa+0x44>)
    e64a:	681b      	ldr	r3, [r3, #0]
    e64c:	b1bb      	cbz	r3, e67e <get_io_capa+0x36>
		goto no_callbacks;
	}

	/* Passkey Confirmation is valid only for LE SC */
	if (bt_auth->passkey_display && bt_auth->passkey_entry &&
    e64e:	681a      	ldr	r2, [r3, #0]
    e650:	b142      	cbz	r2, e664 <get_io_capa+0x1c>
    e652:	6859      	ldr	r1, [r3, #4]
    e654:	b131      	cbz	r1, e664 <get_io_capa+0x1c>
    e656:	6899      	ldr	r1, [r3, #8]
    e658:	b911      	cbnz	r1, e660 <get_io_capa+0x18>
	    (bt_auth->passkey_confirm || !sc_supported)) {
    e65a:	490d      	ldr	r1, [pc, #52]	; (e690 <get_io_capa+0x48>)
    e65c:	7809      	ldrb	r1, [r1, #0]
    e65e:	b939      	cbnz	r1, e670 <get_io_capa+0x28>
		return BT_SMP_IO_KEYBOARD_DISPLAY;
    e660:	2004      	movs	r0, #4
    e662:	4770      	bx	lr
	}

	/* DisplayYesNo is useful only for LE SC */
	if (sc_supported && bt_auth->passkey_display &&
    e664:	490a      	ldr	r1, [pc, #40]	; (e690 <get_io_capa+0x48>)
    e666:	7809      	ldrb	r1, [r1, #0]
    e668:	b111      	cbz	r1, e670 <get_io_capa+0x28>
    e66a:	b10a      	cbz	r2, e670 <get_io_capa+0x28>
    e66c:	6899      	ldr	r1, [r3, #8]
    e66e:	b941      	cbnz	r1, e682 <get_io_capa+0x3a>
	    bt_auth->passkey_confirm) {
		return BT_SMP_IO_DISPLAY_YESNO;
	}

	if (bt_auth->passkey_entry) {
    e670:	685b      	ldr	r3, [r3, #4]
    e672:	b943      	cbnz	r3, e686 <get_io_capa+0x3e>
			return BT_SMP_IO_KEYBOARD_ONLY;
		}
	}

	if (bt_auth->passkey_display) {
		return BT_SMP_IO_DISPLAY_ONLY;
    e674:	2a00      	cmp	r2, #0
    e676:	bf0c      	ite	eq
    e678:	2003      	moveq	r0, #3
    e67a:	2000      	movne	r0, #0
    e67c:	4770      	bx	lr
no_callbacks:
	if (IS_ENABLED(CONFIG_BT_FIXED_PASSKEY) &&
	    fixed_passkey != BT_PASSKEY_INVALID) {
		return BT_SMP_IO_DISPLAY_ONLY;
	} else {
		return BT_SMP_IO_NO_INPUT_OUTPUT;
    e67e:	2003      	movs	r0, #3
    e680:	4770      	bx	lr
		return BT_SMP_IO_DISPLAY_YESNO;
    e682:	2001      	movs	r0, #1
    e684:	4770      	bx	lr
			return BT_SMP_IO_KEYBOARD_ONLY;
    e686:	2002      	movs	r0, #2
	}
}
    e688:	4770      	bx	lr
    e68a:	bf00      	nop
    e68c:	200003a0 	.word	0x200003a0
    e690:	2000aa5b 	.word	0x2000aa5b

0000e694 <smp_sign_buf>:
 * msg buffer contains message itself, 32 bit count and signature,
 * so total buffer size is len + 4 + 8 octets.
 * API is Little Endian to make it suitable for Bluetooth.
 */
static int smp_sign_buf(const u8_t *key, u8_t *msg, u16_t len)
{
    e694:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u8_t *m = msg;
	u32_t cnt = UNALIGNED_GET((u32_t *)&msg[len]);
    e698:	188d      	adds	r5, r1, r2
	int err;

	BT_DBG("Signing msg %s len %u key %s", bt_hex(msg, len), len,
	       bt_hex(key, 16));

	sys_mem_swap(m, len + sizeof(cnt));
    e69a:	f102 0804 	add.w	r8, r2, #4
{
    e69e:	460c      	mov	r4, r1
    e6a0:	b089      	sub	sp, #36	; 0x24
    e6a2:	4607      	mov	r7, r0
	sys_mem_swap(m, len + sizeof(cnt));
    e6a4:	4641      	mov	r1, r8
    e6a6:	4620      	mov	r0, r4
{
    e6a8:	4616      	mov	r6, r2
	u32_t cnt = UNALIGNED_GET((u32_t *)&msg[len]);
    e6aa:	f8d5 9000 	ldr.w	r9, [r5]
	sys_mem_swap(m, len + sizeof(cnt));
    e6ae:	f015 f8b9 	bl	23824 <sys_mem_swap>
	sys_memcpy_swap(key_s, key, 16);
    e6b2:	4639      	mov	r1, r7
    e6b4:	2210      	movs	r2, #16
    e6b6:	4668      	mov	r0, sp
    e6b8:	f015 f8aa 	bl	23810 <sys_memcpy_swap>

	err = bt_smp_aes_cmac(key_s, m, len + sizeof(cnt), tmp);
    e6bc:	ab04      	add	r3, sp, #16
    e6be:	4642      	mov	r2, r8
    e6c0:	4621      	mov	r1, r4
    e6c2:	4668      	mov	r0, sp
    e6c4:	f015 f8d5 	bl	23872 <bt_smp_aes_cmac>
	if (err) {
    e6c8:	4607      	mov	r7, r0
    e6ca:	b188      	cbz	r0, e6f0 <smp_sign_buf+0x5c>
		BT_ERR("Data signing failed");
    e6cc:	2301      	movs	r3, #1
    e6ce:	f04f 0100 	mov.w	r1, #0
    e6d2:	f363 0107 	bfi	r1, r3, #0, #8
    e6d6:	4a0f      	ldr	r2, [pc, #60]	; (e714 <smp_sign_buf+0x80>)
    e6d8:	4b0f      	ldr	r3, [pc, #60]	; (e718 <smp_sign_buf+0x84>)
    e6da:	4810      	ldr	r0, [pc, #64]	; (e71c <smp_sign_buf+0x88>)
    e6dc:	1a9b      	subs	r3, r3, r2
    e6de:	08db      	lsrs	r3, r3, #3
    e6e0:	f363 118f 	bfi	r1, r3, #6, #10
    e6e4:	f012 fca9 	bl	2103a <log_0>
	memcpy(sig, tmp + 4, 12);

	BT_DBG("sig %s", bt_hex(sig, 12));

	return 0;
}
    e6e8:	4638      	mov	r0, r7
    e6ea:	b009      	add	sp, #36	; 0x24
    e6ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	sys_mem_swap(tmp, sizeof(tmp));
    e6f0:	2110      	movs	r1, #16
    e6f2:	eb0d 0001 	add.w	r0, sp, r1
    e6f6:	f015 f895 	bl	23824 <sys_mem_swap>
	sys_mem_swap(m, len + sizeof(cnt));
    e6fa:	4641      	mov	r1, r8
    e6fc:	4620      	mov	r0, r4
    e6fe:	f8cd 9014 	str.w	r9, [sp, #20]
    e702:	f015 f88f 	bl	23824 <sys_mem_swap>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    e706:	ab05      	add	r3, sp, #20
    e708:	cb03      	ldmia	r3!, {r0, r1}
    e70a:	51a0      	str	r0, [r4, r6]
    e70c:	6818      	ldr	r0, [r3, #0]
    e70e:	6069      	str	r1, [r5, #4]
    e710:	60a8      	str	r0, [r5, #8]
    e712:	e7e9      	b.n	e6e8 <smp_sign_buf+0x54>
    e714:	00028540 	.word	0x00028540
    e718:	00028640 	.word	0x00028640
    e71c:	0006403e 	.word	0x0006403e

0000e720 <smp_ident_info>:
{
    e720:	b570      	push	{r4, r5, r6, lr}
    e722:	460b      	mov	r3, r1
    e724:	4605      	mov	r5, r0
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    e726:	210c      	movs	r1, #12
    e728:	309c      	adds	r0, #156	; 0x9c
    e72a:	f015 f899 	bl	23860 <atomic_test_bit>
    e72e:	b350      	cbz	r0, e786 <smp_ident_info+0x66>
		struct bt_smp_ident_info *req = (void *)buf->data;
    e730:	689c      	ldr	r4, [r3, #8]
		struct bt_conn *conn = smp->chan.chan.conn;
    e732:	682b      	ldr	r3, [r5, #0]
		keys = bt_keys_get_type(BT_KEYS_IRK, conn->id, &conn->le.dst);
    e734:	f103 0674 	add.w	r6, r3, #116	; 0x74
    e738:	4632      	mov	r2, r6
    e73a:	7a19      	ldrb	r1, [r3, #8]
    e73c:	2002      	movs	r0, #2
    e73e:	f015 fc19 	bl	23f74 <bt_keys_get_type>
		if (!keys) {
    e742:	b9b0      	cbnz	r0, e772 <smp_ident_info+0x52>
			BT_ERR("Unable to get keys for %s",
    e744:	2301      	movs	r3, #1
    e746:	f04f 0400 	mov.w	r4, #0
    e74a:	4a12      	ldr	r2, [pc, #72]	; (e794 <smp_ident_info+0x74>)
    e74c:	f363 0407 	bfi	r4, r3, #0, #8
    e750:	4b11      	ldr	r3, [pc, #68]	; (e798 <smp_ident_info+0x78>)
    e752:	1a9b      	subs	r3, r3, r2
    e754:	08db      	lsrs	r3, r3, #3
    e756:	4630      	mov	r0, r6
    e758:	f363 148f 	bfi	r4, r3, #6, #10
    e75c:	f7f9 f844 	bl	77e8 <bt_addr_le_str_real>
    e760:	f7f6 face 	bl	4d00 <log_strdup>
    e764:	4622      	mov	r2, r4
    e766:	4601      	mov	r1, r0
    e768:	480c      	ldr	r0, [pc, #48]	; (e79c <smp_ident_info+0x7c>)
    e76a:	f012 fc73 	bl	21054 <log_1>
			return BT_SMP_ERR_UNSPECIFIED;
    e76e:	2008      	movs	r0, #8
}
    e770:	bd70      	pop	{r4, r5, r6, pc}
    e772:	4623      	mov	r3, r4
    e774:	3026      	adds	r0, #38	; 0x26
    e776:	f104 0210 	add.w	r2, r4, #16
    e77a:	f853 1b04 	ldr.w	r1, [r3], #4
    e77e:	f840 1b04 	str.w	r1, [r0], #4
    e782:	4293      	cmp	r3, r2
    e784:	d1f9      	bne.n	e77a <smp_ident_info+0x5a>
	atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_IDENT_ADDR_INFO);
    e786:	f105 0098 	add.w	r0, r5, #152	; 0x98
    e78a:	2109      	movs	r1, #9
    e78c:	f015 f859 	bl	23842 <atomic_set_bit>
	return 0;
    e790:	2000      	movs	r0, #0
    e792:	e7ed      	b.n	e770 <smp_ident_info+0x50>
    e794:	00028540 	.word	0x00028540
    e798:	00028640 	.word	0x00028640
    e79c:	00063fae 	.word	0x00063fae

0000e7a0 <smp_encrypt_info>:
{
    e7a0:	b570      	push	{r4, r5, r6, lr}
    e7a2:	460b      	mov	r3, r1
    e7a4:	4605      	mov	r5, r0
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    e7a6:	210c      	movs	r1, #12
    e7a8:	309c      	adds	r0, #156	; 0x9c
    e7aa:	f015 f859 	bl	23860 <atomic_test_bit>
    e7ae:	b350      	cbz	r0, e806 <smp_encrypt_info+0x66>
		struct bt_smp_encrypt_info *req = (void *)buf->data;
    e7b0:	689c      	ldr	r4, [r3, #8]
		struct bt_conn *conn = smp->chan.chan.conn;
    e7b2:	682b      	ldr	r3, [r5, #0]
		keys = bt_keys_get_type(BT_KEYS_LTK, conn->id, &conn->le.dst);
    e7b4:	f103 0674 	add.w	r6, r3, #116	; 0x74
    e7b8:	4632      	mov	r2, r6
    e7ba:	7a19      	ldrb	r1, [r3, #8]
    e7bc:	2004      	movs	r0, #4
    e7be:	f015 fbd9 	bl	23f74 <bt_keys_get_type>
		if (!keys) {
    e7c2:	b9b0      	cbnz	r0, e7f2 <smp_encrypt_info+0x52>
			BT_ERR("Unable to get keys for %s",
    e7c4:	2301      	movs	r3, #1
    e7c6:	f04f 0400 	mov.w	r4, #0
    e7ca:	4a12      	ldr	r2, [pc, #72]	; (e814 <smp_encrypt_info+0x74>)
    e7cc:	f363 0407 	bfi	r4, r3, #0, #8
    e7d0:	4b11      	ldr	r3, [pc, #68]	; (e818 <smp_encrypt_info+0x78>)
    e7d2:	1a9b      	subs	r3, r3, r2
    e7d4:	08db      	lsrs	r3, r3, #3
    e7d6:	4630      	mov	r0, r6
    e7d8:	f363 148f 	bfi	r4, r3, #6, #10
    e7dc:	f7f9 f804 	bl	77e8 <bt_addr_le_str_real>
    e7e0:	f7f6 fa8e 	bl	4d00 <log_strdup>
    e7e4:	4622      	mov	r2, r4
    e7e6:	4601      	mov	r1, r0
    e7e8:	480c      	ldr	r0, [pc, #48]	; (e81c <smp_encrypt_info+0x7c>)
    e7ea:	f012 fc33 	bl	21054 <log_1>
			return BT_SMP_ERR_UNSPECIFIED;
    e7ee:	2008      	movs	r0, #8
}
    e7f0:	bd70      	pop	{r4, r5, r6, pc}
    e7f2:	4623      	mov	r3, r4
    e7f4:	3016      	adds	r0, #22
    e7f6:	f104 0210 	add.w	r2, r4, #16
    e7fa:	f853 1b04 	ldr.w	r1, [r3], #4
    e7fe:	f840 1b04 	str.w	r1, [r0], #4
    e802:	4293      	cmp	r3, r2
    e804:	d1f9      	bne.n	e7fa <smp_encrypt_info+0x5a>
	atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_MASTER_IDENT);
    e806:	f105 0098 	add.w	r0, r5, #152	; 0x98
    e80a:	2107      	movs	r1, #7
    e80c:	f015 f819 	bl	23842 <atomic_set_bit>
	return 0;
    e810:	2000      	movs	r0, #0
    e812:	e7ed      	b.n	e7f0 <smp_encrypt_info+0x50>
    e814:	00028540 	.word	0x00028540
    e818:	00028640 	.word	0x00028640
    e81c:	00063fae 	.word	0x00063fae

0000e820 <get_auth.isra.0>:
	if (sc_supported) {
    e820:	4b0c      	ldr	r3, [pc, #48]	; (e854 <get_auth.isra.0+0x34>)
    e822:	781b      	ldrb	r3, [r3, #0]
static u8_t get_auth(struct bt_conn *conn, u8_t auth)
    e824:	b510      	push	{r4, lr}
	if (sc_supported) {
    e826:	b17b      	cbz	r3, e848 <get_auth.isra.0+0x28>
		auth &= BT_SMP_AUTH_MASK_SC;
    e828:	f000 040f 	and.w	r4, r0, #15
	if ((get_io_capa() == BT_SMP_IO_NO_INPUT_OUTPUT) ||
    e82c:	f7ff ff0c 	bl	e648 <get_io_capa>
	if (bondable) {
    e830:	4b09      	ldr	r3, [pc, #36]	; (e858 <get_auth.isra.0+0x38>)
    e832:	781b      	ldrb	r3, [r3, #0]
	if ((get_io_capa() == BT_SMP_IO_NO_INPUT_OUTPUT) ||
    e834:	2803      	cmp	r0, #3
		auth &= ~(BT_SMP_AUTH_MITM);
    e836:	bf0c      	ite	eq
    e838:	f004 040b 	andeq.w	r4, r4, #11
		auth |= BT_SMP_AUTH_MITM;
    e83c:	f044 0404 	orrne.w	r4, r4, #4
	if (bondable) {
    e840:	b12b      	cbz	r3, e84e <get_auth.isra.0+0x2e>
		auth |= BT_SMP_AUTH_BONDING;
    e842:	f044 0001 	orr.w	r0, r4, #1
}
    e846:	bd10      	pop	{r4, pc}
		auth &= BT_SMP_AUTH_MASK;
    e848:	f000 0407 	and.w	r4, r0, #7
    e84c:	e7ee      	b.n	e82c <get_auth.isra.0+0xc>
		auth &= ~BT_SMP_AUTH_BONDING;
    e84e:	f004 00fe 	and.w	r0, r4, #254	; 0xfe
    e852:	e7f8      	b.n	e846 <get_auth.isra.0+0x26>
    e854:	2000aa5b 	.word	0x2000aa5b
    e858:	2000edec 	.word	0x2000edec

0000e85c <smp_chan_get>:
{
    e85c:	b510      	push	{r4, lr}
	chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_SMP);
    e85e:	2106      	movs	r1, #6
    e860:	f014 f84c 	bl	228fc <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
    e864:	4604      	mov	r4, r0
    e866:	b968      	cbnz	r0, e884 <smp_chan_get+0x28>
		BT_ERR("Unable to find SMP channel");
    e868:	2301      	movs	r3, #1
    e86a:	f04f 0100 	mov.w	r1, #0
    e86e:	f363 0107 	bfi	r1, r3, #0, #8
    e872:	4a05      	ldr	r2, [pc, #20]	; (e888 <smp_chan_get+0x2c>)
    e874:	4b05      	ldr	r3, [pc, #20]	; (e88c <smp_chan_get+0x30>)
    e876:	4806      	ldr	r0, [pc, #24]	; (e890 <smp_chan_get+0x34>)
    e878:	1a9b      	subs	r3, r3, r2
    e87a:	08db      	lsrs	r3, r3, #3
    e87c:	f363 118f 	bfi	r1, r3, #6, #10
    e880:	f012 fbdb 	bl	2103a <log_0>
}
    e884:	4620      	mov	r0, r4
    e886:	bd10      	pop	{r4, pc}
    e888:	00028540 	.word	0x00028540
    e88c:	00028640 	.word	0x00028640
    e890:	00063f7f 	.word	0x00063f7f

0000e894 <bt_smp_accept>:
	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
		struct bt_smp *smp = &bt_smp_pool[i];

		if (smp->chan.chan.conn) {
    e894:	4a0d      	ldr	r2, [pc, #52]	; (e8cc <bt_smp_accept+0x38>)
{
    e896:	b508      	push	{r3, lr}
		if (smp->chan.chan.conn) {
    e898:	6813      	ldr	r3, [r2, #0]
    e89a:	b923      	cbnz	r3, e8a6 <bt_smp_accept+0x12>
			continue;
		}

		smp->chan.chan.ops = &ops;
    e89c:	480c      	ldr	r0, [pc, #48]	; (e8d0 <bt_smp_accept+0x3c>)
    e89e:	6050      	str	r0, [r2, #4]

		*chan = &smp->chan.chan;
    e8a0:	600a      	str	r2, [r1, #0]

		return 0;
    e8a2:	4618      	mov	r0, r3
	}

	BT_ERR("No available SMP context for conn %p", conn);

	return -ENOMEM;
}
    e8a4:	bd08      	pop	{r3, pc}
	BT_ERR("No available SMP context for conn %p", conn);
    e8a6:	2301      	movs	r3, #1
    e8a8:	f04f 0200 	mov.w	r2, #0
    e8ac:	f363 0207 	bfi	r2, r3, #0, #8
    e8b0:	4908      	ldr	r1, [pc, #32]	; (e8d4 <bt_smp_accept+0x40>)
    e8b2:	4b09      	ldr	r3, [pc, #36]	; (e8d8 <bt_smp_accept+0x44>)
    e8b4:	1a5b      	subs	r3, r3, r1
    e8b6:	08db      	lsrs	r3, r3, #3
    e8b8:	4601      	mov	r1, r0
    e8ba:	f363 128f 	bfi	r2, r3, #6, #10
    e8be:	4807      	ldr	r0, [pc, #28]	; (e8dc <bt_smp_accept+0x48>)
    e8c0:	f012 fbc8 	bl	21054 <log_1>
	return -ENOMEM;
    e8c4:	f06f 000b 	mvn.w	r0, #11
    e8c8:	e7ec      	b.n	e8a4 <bt_smp_accept+0x10>
    e8ca:	bf00      	nop
    e8cc:	200005e4 	.word	0x200005e4
    e8d0:	0002922c 	.word	0x0002922c
    e8d4:	00028540 	.word	0x00028540
    e8d8:	00028640 	.word	0x00028640
    e8dc:	00063cde 	.word	0x00063cde

0000e8e0 <smp_init>:
{
    e8e0:	b538      	push	{r3, r4, r5, lr}
	(void)memset((u8_t *)smp + sizeof(smp->chan), 0,
    e8e2:	f100 0598 	add.w	r5, r0, #152	; 0x98
{
    e8e6:	4604      	mov	r4, r0
__ssp_bos_icheck3(memset, void *, int)
    e8e8:	22ec      	movs	r2, #236	; 0xec
    e8ea:	2100      	movs	r1, #0
    e8ec:	4628      	mov	r0, r5
    e8ee:	f7f3 f99e 	bl	1c2e <memset>
	if (bt_rand(smp->prnd, 16)) {
    e8f2:	f104 00bf 	add.w	r0, r4, #191	; 0xbf
    e8f6:	2110      	movs	r1, #16
    e8f8:	f003 fe40 	bl	1257c <bt_rand>
    e8fc:	4604      	mov	r4, r0
    e8fe:	b948      	cbnz	r0, e914 <smp_init+0x34>
	atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_FAIL);
    e900:	2105      	movs	r1, #5
    e902:	4628      	mov	r0, r5
    e904:	f014 ff9d 	bl	23842 <atomic_set_bit>
	sc_public_key = bt_pub_key_get();
    e908:	f7fb fe4a 	bl	a5a0 <bt_pub_key_get>
    e90c:	4b02      	ldr	r3, [pc, #8]	; (e918 <smp_init+0x38>)
    e90e:	6018      	str	r0, [r3, #0]
}
    e910:	4620      	mov	r0, r4
    e912:	bd38      	pop	{r3, r4, r5, pc}
		return BT_SMP_ERR_UNSPECIFIED;
    e914:	2408      	movs	r4, #8
    e916:	e7fb      	b.n	e910 <smp_init+0x30>
    e918:	20000788 	.word	0x20000788

0000e91c <smp_send.isra.7>:
static void smp_send(struct bt_smp *smp, struct net_buf *buf,
    e91c:	b513      	push	{r0, r1, r4, lr}
	bt_l2cap_send_cb(smp->chan.chan.conn, BT_L2CAP_CID_SMP, buf, cb, NULL);
    e91e:	2300      	movs	r3, #0
    e920:	9300      	str	r3, [sp, #0]
static void smp_send(struct bt_smp *smp, struct net_buf *buf,
    e922:	4604      	mov	r4, r0
	bt_l2cap_send_cb(smp->chan.chan.conn, BT_L2CAP_CID_SMP, buf, cb, NULL);
    e924:	4613      	mov	r3, r2
    e926:	6800      	ldr	r0, [r0, #0]
    e928:	460a      	mov	r2, r1
    e92a:	2106      	movs	r1, #6
    e92c:	f013 ffc2 	bl	228b4 <bt_l2cap_send_cb>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    e930:	4804      	ldr	r0, [pc, #16]	; (e944 <smp_send.isra.7+0x28>)
    e932:	f247 5230 	movw	r2, #30000	; 0x7530
    e936:	f504 71c2 	add.w	r1, r4, #388	; 0x184
}
    e93a:	b002      	add	sp, #8
    e93c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    e940:	f010 bb8e 	b.w	1f060 <k_delayed_work_submit_to_queue>
    e944:	20006090 	.word	0x20006090

0000e948 <smp_send_pairing_confirm>:
{
    e948:	b573      	push	{r0, r1, r4, r5, r6, lr}
	switch (smp->method) {
    e94a:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
{
    e94e:	4605      	mov	r5, r0
	switch (smp->method) {
    e950:	2b03      	cmp	r3, #3
    e952:	d826      	bhi.n	e9a2 <smp_send_pairing_confirm+0x5a>
    e954:	e8df f003 	tbb	[pc, r3]
    e958:	27020227 	.word	0x27020227
		r = (smp->passkey >> smp->passkey_round) & 0x01;
    e95c:	f890 3174 	ldrb.w	r3, [r0, #372]	; 0x174
    e960:	f8d0 4170 	ldr.w	r4, [r0, #368]	; 0x170
    e964:	40dc      	lsrs	r4, r3
    e966:	f004 0401 	and.w	r4, r4, #1
		r |= 0x80;
    e96a:	f064 047f 	orn	r4, r4, #127	; 0x7f
    e96e:	b2e4      	uxtb	r4, r4
	buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_CONFIRM, sizeof(*req));
    e970:	2103      	movs	r1, #3
    e972:	4628      	mov	r0, r5
    e974:	f015 f823 	bl	239be <smp_create_pdu.isra.5>
	if (!buf) {
    e978:	4606      	mov	r6, r0
    e97a:	b190      	cbz	r0, e9a2 <smp_send_pairing_confirm+0x5a>
	req = net_buf_add(buf, sizeof(*req));
    e97c:	2110      	movs	r1, #16
    e97e:	3008      	adds	r0, #8
    e980:	f016 fa2a 	bl	24dd8 <net_buf_simple_add>
	if (smp_f4(sc_public_key, smp->pkey, smp->prnd, r, req->val)) {
    e984:	9000      	str	r0, [sp, #0]
    e986:	480f      	ldr	r0, [pc, #60]	; (e9c4 <smp_send_pairing_confirm+0x7c>)
    e988:	4623      	mov	r3, r4
    e98a:	f105 02bf 	add.w	r2, r5, #191	; 0xbf
    e98e:	f105 01ef 	add.w	r1, r5, #239	; 0xef
    e992:	6800      	ldr	r0, [r0, #0]
    e994:	f014 ff89 	bl	238aa <smp_f4>
    e998:	4604      	mov	r4, r0
    e99a:	b130      	cbz	r0, e9aa <smp_send_pairing_confirm+0x62>
		net_buf_unref(buf);
    e99c:	4630      	mov	r0, r6
    e99e:	f00a fb5d 	bl	1905c <net_buf_unref>
		return BT_SMP_ERR_UNSPECIFIED;
    e9a2:	2008      	movs	r0, #8
    e9a4:	e00c      	b.n	e9c0 <smp_send_pairing_confirm+0x78>
		r = 0U;
    e9a6:	2400      	movs	r4, #0
    e9a8:	e7e2      	b.n	e970 <smp_send_pairing_confirm+0x28>
	smp_send(smp, buf, NULL, NULL);
    e9aa:	4602      	mov	r2, r0
    e9ac:	4631      	mov	r1, r6
    e9ae:	4628      	mov	r0, r5
    e9b0:	f7ff ffb4 	bl	e91c <smp_send.isra.7>
	atomic_clear_bit(smp->flags, SMP_FLAG_CFM_DELAYED);
    e9b4:	f105 009c 	add.w	r0, r5, #156	; 0x9c
    e9b8:	4621      	mov	r1, r4
    e9ba:	f014 ff9b 	bl	238f4 <atomic_clear_bit>
	return 0;
    e9be:	4620      	mov	r0, r4
}
    e9c0:	b002      	add	sp, #8
    e9c2:	bd70      	pop	{r4, r5, r6, pc}
    e9c4:	20000788 	.word	0x20000788

0000e9c8 <smp_public_key_slave.part.14>:
static u8_t smp_public_key_slave(struct bt_smp *smp)
    e9c8:	b538      	push	{r3, r4, r5, lr}
	switch (smp->method) {
    e9ca:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
static u8_t smp_public_key_slave(struct bt_smp *smp)
    e9ce:	4604      	mov	r4, r0
	switch (smp->method) {
    e9d0:	2b05      	cmp	r3, #5
    e9d2:	d814      	bhi.n	e9fe <smp_public_key_slave.part.14+0x36>
    e9d4:	e8df f003 	tbb	[pc, r3]
    e9d8:	030d3603 	.word	0x030d3603
    e9dc:	5313      	.short	0x5313
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
    e9de:	3098      	adds	r0, #152	; 0x98
    e9e0:	2104      	movs	r1, #4
    e9e2:	f014 ff2e 	bl	23842 <atomic_set_bit>
		err = smp_send_pairing_confirm(smp);
    e9e6:	4620      	mov	r0, r4
    e9e8:	f7ff ffae 	bl	e948 <smp_send_pairing_confirm>
		if (err) {
    e9ec:	2800      	cmp	r0, #0
    e9ee:	d037      	beq.n	ea60 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1>
}
    e9f0:	bd38      	pop	{r3, r4, r5, pc}
		if (bt_rand(&smp->passkey, sizeof(smp->passkey))) {
    e9f2:	2104      	movs	r1, #4
    e9f4:	f500 70b8 	add.w	r0, r0, #368	; 0x170
    e9f8:	f003 fdc0 	bl	1257c <bt_rand>
    e9fc:	b108      	cbz	r0, ea02 <smp_public_key_slave.part.14+0x3a>
		return BT_SMP_ERR_UNSPECIFIED;
    e9fe:	2008      	movs	r0, #8
    ea00:	e7f6      	b.n	e9f0 <smp_public_key_slave.part.14+0x28>
		smp->passkey %= 1000000;
    ea02:	f8d4 1170 	ldr.w	r1, [r4, #368]	; 0x170
    ea06:	4a1f      	ldr	r2, [pc, #124]	; (ea84 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x24>)
	if (bt_auth && bt_auth->passkey_display) {
    ea08:	4d1f      	ldr	r5, [pc, #124]	; (ea88 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x28>)
		smp->passkey %= 1000000;
    ea0a:	fbb1 f3f2 	udiv	r3, r1, r2
    ea0e:	fb02 1313 	mls	r3, r2, r3, r1
    ea12:	f8c4 3170 	str.w	r3, [r4, #368]	; 0x170
	if (bt_auth && bt_auth->passkey_display) {
    ea16:	682b      	ldr	r3, [r5, #0]
	smp->passkey_round = 0U;
    ea18:	f884 0174 	strb.w	r0, [r4, #372]	; 0x174
	if (bt_auth && bt_auth->passkey_display) {
    ea1c:	b163      	cbz	r3, ea38 <smp_public_key_slave.part.14+0x70>
    ea1e:	681b      	ldr	r3, [r3, #0]
    ea20:	b153      	cbz	r3, ea38 <smp_public_key_slave.part.14+0x70>
		atomic_set_bit(smp->flags, SMP_FLAG_DISPLAY);
    ea22:	210a      	movs	r1, #10
    ea24:	f104 009c 	add.w	r0, r4, #156	; 0x9c
    ea28:	f014 ff0b 	bl	23842 <atomic_set_bit>
		bt_auth->passkey_display(smp->chan.chan.conn, smp->passkey);
    ea2c:	682b      	ldr	r3, [r5, #0]
    ea2e:	f8d4 1170 	ldr.w	r1, [r4, #368]	; 0x170
    ea32:	681b      	ldr	r3, [r3, #0]
    ea34:	6820      	ldr	r0, [r4, #0]
    ea36:	4798      	blx	r3
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
    ea38:	2103      	movs	r1, #3
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
    ea3a:	f104 0098 	add.w	r0, r4, #152	; 0x98
    ea3e:	f014 ff00 	bl	23842 <atomic_set_bit>
		break;
    ea42:	e00d      	b.n	ea60 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
    ea44:	2103      	movs	r1, #3
    ea46:	3098      	adds	r0, #152	; 0x98
    ea48:	f014 fefb 	bl	23842 <atomic_set_bit>
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
    ea4c:	f104 009c 	add.w	r0, r4, #156	; 0x9c
    ea50:	2109      	movs	r1, #9
    ea52:	f014 fef6 	bl	23842 <atomic_set_bit>
		bt_auth->passkey_entry(smp->chan.chan.conn);
    ea56:	4b0c      	ldr	r3, [pc, #48]	; (ea88 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x28>)
    ea58:	6820      	ldr	r0, [r4, #0]
    ea5a:	681b      	ldr	r3, [r3, #0]
    ea5c:	685b      	ldr	r3, [r3, #4]
    ea5e:	4798      	blx	r3
	if (bt_dh_key_gen(smp->pkey, bt_smp_dhkey_ready)) {
    ea60:	490a      	ldr	r1, [pc, #40]	; (ea8c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2c>)
    ea62:	f104 00ef 	add.w	r0, r4, #239	; 0xef
    ea66:	f7fb fda9 	bl	a5bc <bt_dh_key_gen>
    ea6a:	4605      	mov	r5, r0
    ea6c:	2800      	cmp	r0, #0
    ea6e:	d1c6      	bne.n	e9fe <smp_public_key_slave.part.14+0x36>
	atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_PENDING);
    ea70:	f104 009c 	add.w	r0, r4, #156	; 0x9c
    ea74:	2107      	movs	r1, #7
    ea76:	f014 fee4 	bl	23842 <atomic_set_bit>
	return 0;
    ea7a:	4628      	mov	r0, r5
    ea7c:	e7b8      	b.n	e9f0 <smp_public_key_slave.part.14+0x28>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
    ea7e:	2104      	movs	r1, #4
    ea80:	e7db      	b.n	ea3a <smp_public_key_slave.part.14+0x72>
    ea82:	bf00      	nop
    ea84:	000f4240 	.word	0x000f4240
    ea88:	200003a0 	.word	0x200003a0
    ea8c:	0000f1b1 	.word	0x0000f1b1

0000ea90 <compute_and_check_and_send_slave_dhcheck>:
{
    ea90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	(void)memset(r, 0, sizeof(r));
    ea94:	2210      	movs	r2, #16
{
    ea96:	b0a3      	sub	sp, #140	; 0x8c
    ea98:	4604      	mov	r4, r0
	(void)memset(r, 0, sizeof(r));
    ea9a:	2100      	movs	r1, #0
    ea9c:	eb0d 0002 	add.w	r0, sp, r2
    eaa0:	f7f3 f8c5 	bl	1c2e <memset>
	switch (smp->method) {
    eaa4:	f894 30a0 	ldrb.w	r3, [r4, #160]	; 0xa0
    eaa8:	2b05      	cmp	r3, #5
    eaaa:	d87f      	bhi.n	ebac <compute_and_check_and_send_slave_dhcheck+0x11c>
    eaac:	e8df f003 	tbb	[pc, r3]
    eab0:	06030306 	.word	0x06030306
    eab4:	807e      	.short	0x807e
		memcpy(r, &smp->passkey, sizeof(smp->passkey));
    eab6:	f8d4 3170 	ldr.w	r3, [r4, #368]	; 0x170
    eaba:	9304      	str	r3, [sp, #16]
	u8_t m[53] = { 0x00, /* counter */
    eabc:	ad14      	add	r5, sp, #80	; 0x50
    eabe:	2235      	movs	r2, #53	; 0x35
    eac0:	2100      	movs	r1, #0
    eac2:	4628      	mov	r0, r5
		   &smp->chan.chan.conn->le.init_addr,
    eac4:	f8d4 a000 	ldr.w	sl, [r4]
	u8_t m[53] = { 0x00, /* counter */
    eac8:	f7f3 f8b1 	bl	1c2e <memset>
    eacc:	2362      	movs	r3, #98	; 0x62
    eace:	f88d 3051 	strb.w	r3, [sp, #81]	; 0x51
	sys_memcpy_swap(ws, w, 32);
    ead2:	ae0c      	add	r6, sp, #48	; 0x30
	u8_t m[53] = { 0x00, /* counter */
    ead4:	f646 4374 	movw	r3, #27764	; 0x6c74
    ead8:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
	sys_memcpy_swap(ws, w, 32);
    eadc:	2220      	movs	r2, #32
	u8_t m[53] = { 0x00, /* counter */
    eade:	2365      	movs	r3, #101	; 0x65
	sys_memcpy_swap(ws, w, 32);
    eae0:	f204 112f 	addw	r1, r4, #303	; 0x12f
    eae4:	4630      	mov	r0, r6
	u8_t m[53] = { 0x00, /* counter */
    eae6:	f04f 0b01 	mov.w	fp, #1
    eaea:	f88d 3054 	strb.w	r3, [sp, #84]	; 0x54
    eaee:	f88d b083 	strb.w	fp, [sp, #131]	; 0x83
	sys_memcpy_swap(ws, w, 32);
    eaf2:	f014 fe8d 	bl	23810 <sys_memcpy_swap>
	err = bt_smp_aes_cmac(salt, ws, 32, t);
    eaf6:	ab08      	add	r3, sp, #32
    eaf8:	2220      	movs	r2, #32
    eafa:	4631      	mov	r1, r6
    eafc:	4861      	ldr	r0, [pc, #388]	; (ec84 <compute_and_check_and_send_slave_dhcheck+0x1f4>)
    eafe:	f014 feb8 	bl	23872 <bt_smp_aes_cmac>
	if (err) {
    eb02:	2800      	cmp	r0, #0
    eb04:	d152      	bne.n	ebac <compute_and_check_and_send_slave_dhcheck+0x11c>
	if (smp_f5(smp->dhkey, smp->rrnd, smp->prnd,
    eb06:	f104 08cf 	add.w	r8, r4, #207	; 0xcf
	sys_memcpy_swap(m + 5, n1, 16);
    eb0a:	2210      	movs	r2, #16
    eb0c:	4641      	mov	r1, r8
    eb0e:	f10d 0055 	add.w	r0, sp, #85	; 0x55
	if (smp_f5(smp->dhkey, smp->rrnd, smp->prnd,
    eb12:	f104 09bf 	add.w	r9, r4, #191	; 0xbf
	sys_memcpy_swap(m + 5, n1, 16);
    eb16:	f014 fe7b 	bl	23810 <sys_memcpy_swap>
	sys_memcpy_swap(m + 21, n2, 16);
    eb1a:	2210      	movs	r2, #16
    eb1c:	4649      	mov	r1, r9
    eb1e:	f10d 0065 	add.w	r0, sp, #101	; 0x65
    eb22:	f014 fe75 	bl	23810 <sys_memcpy_swap>
	m[37] = a1->type;
    eb26:	f89a 307b 	ldrb.w	r3, [sl, #123]	; 0x7b
    eb2a:	f88d 3075 	strb.w	r3, [sp, #117]	; 0x75
	sys_memcpy_swap(m + 38, a1->a.val, 6);
    eb2e:	2206      	movs	r2, #6
    eb30:	f10a 017c 	add.w	r1, sl, #124	; 0x7c
    eb34:	f10d 0076 	add.w	r0, sp, #118	; 0x76
    eb38:	f014 fe6a 	bl	23810 <sys_memcpy_swap>
		   &smp->chan.chan.conn->le.resp_addr, smp->mackey,
    eb3c:	f204 175f 	addw	r7, r4, #351	; 0x15f
	m[44] = a2->type;
    eb40:	f89a 3082 	ldrb.w	r3, [sl, #130]	; 0x82
    eb44:	f88d 307c 	strb.w	r3, [sp, #124]	; 0x7c
	sys_memcpy_swap(m + 45, a2->a.val, 6);
    eb48:	2206      	movs	r2, #6
    eb4a:	f10a 0183 	add.w	r1, sl, #131	; 0x83
    eb4e:	f10d 007d 	add.w	r0, sp, #125	; 0x7d
    eb52:	f014 fe5d 	bl	23810 <sys_memcpy_swap>
	err = bt_smp_aes_cmac(t, m, sizeof(m), mackey);
    eb56:	463b      	mov	r3, r7
    eb58:	2235      	movs	r2, #53	; 0x35
    eb5a:	4629      	mov	r1, r5
    eb5c:	a808      	add	r0, sp, #32
    eb5e:	f014 fe88 	bl	23872 <bt_smp_aes_cmac>
	if (err) {
    eb62:	bb18      	cbnz	r0, ebac <compute_and_check_and_send_slave_dhcheck+0x11c>
	sys_mem_swap(mackey, 16);
    eb64:	2110      	movs	r1, #16
    eb66:	4638      	mov	r0, r7
		   smp->tk)) {
    eb68:	f104 0adf 	add.w	sl, r4, #223	; 0xdf
	sys_mem_swap(mackey, 16);
    eb6c:	f014 fe5a 	bl	23824 <sys_mem_swap>
	err = bt_smp_aes_cmac(t, m, sizeof(m), ltk);
    eb70:	4653      	mov	r3, sl
    eb72:	2235      	movs	r2, #53	; 0x35
    eb74:	4629      	mov	r1, r5
    eb76:	a808      	add	r0, sp, #32
	m[0] = 0x01;
    eb78:	f88d b050 	strb.w	fp, [sp, #80]	; 0x50
	err = bt_smp_aes_cmac(t, m, sizeof(m), ltk);
    eb7c:	f014 fe79 	bl	23872 <bt_smp_aes_cmac>
	if (err) {
    eb80:	b9a0      	cbnz	r0, ebac <compute_and_check_and_send_slave_dhcheck+0x11c>
	sys_mem_swap(ltk, 16);
    eb82:	2110      	movs	r1, #16
    eb84:	4650      	mov	r0, sl
    eb86:	f014 fe4d 	bl	23824 <sys_mem_swap>
		   &smp->chan.chan.conn->le.resp_addr,
    eb8a:	4622      	mov	r2, r4
	if (smp_f6(smp->mackey, smp->prnd, smp->rrnd, r, &smp->prsp[1],
    eb8c:	4638      	mov	r0, r7
		   &smp->chan.chan.conn->le.resp_addr,
    eb8e:	f852 3ba9 	ldr.w	r3, [r2], #169
	if (smp_f6(smp->mackey, smp->prnd, smp->rrnd, r, &smp->prsp[1],
    eb92:	9503      	str	r5, [sp, #12]
		   &smp->chan.chan.conn->le.init_addr, e)) {
    eb94:	f103 017b 	add.w	r1, r3, #123	; 0x7b
		   &smp->chan.chan.conn->le.resp_addr,
    eb98:	3382      	adds	r3, #130	; 0x82
	if (smp_f6(smp->mackey, smp->prnd, smp->rrnd, r, &smp->prsp[1],
    eb9a:	e9cd 2300 	strd	r2, r3, [sp]
    eb9e:	9102      	str	r1, [sp, #8]
    eba0:	ab04      	add	r3, sp, #16
    eba2:	4642      	mov	r2, r8
    eba4:	4649      	mov	r1, r9
    eba6:	f014 febc 	bl	23922 <smp_f6>
    ebaa:	b188      	cbz	r0, ebd0 <compute_and_check_and_send_slave_dhcheck+0x140>
		return BT_SMP_ERR_UNSPECIFIED;
    ebac:	2008      	movs	r0, #8
    ebae:	e05e      	b.n	ec6e <compute_and_check_and_send_slave_dhcheck+0x1de>
		if (smp->oobd_remote) {
    ebb0:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
    ebb4:	2b00      	cmp	r3, #0
    ebb6:	d081      	beq.n	eabc <compute_and_check_and_send_slave_dhcheck+0x2c>
			memcpy(r, smp->oobd_remote->r, sizeof(r));
    ebb8:	ad04      	add	r5, sp, #16
    ebba:	f103 0610 	add.w	r6, r3, #16
    ebbe:	6818      	ldr	r0, [r3, #0]
    ebc0:	6859      	ldr	r1, [r3, #4]
    ebc2:	462a      	mov	r2, r5
    ebc4:	c203      	stmia	r2!, {r0, r1}
    ebc6:	3308      	adds	r3, #8
    ebc8:	42b3      	cmp	r3, r6
    ebca:	4615      	mov	r5, r2
    ebcc:	d1f7      	bne.n	ebbe <compute_and_check_and_send_slave_dhcheck+0x12e>
    ebce:	e775      	b.n	eabc <compute_and_check_and_send_slave_dhcheck+0x2c>
	if (smp->method == LE_SC_OOB) {
    ebd0:	f894 30a0 	ldrb.w	r3, [r4, #160]	; 0xa0
    ebd4:	2b05      	cmp	r3, #5
    ebd6:	d110      	bne.n	ebfa <compute_and_check_and_send_slave_dhcheck+0x16a>
		if (smp->oobd_local) {
    ebd8:	f8d4 1178 	ldr.w	r1, [r4, #376]	; 0x178
    ebdc:	2900      	cmp	r1, #0
    ebde:	d049      	beq.n	ec74 <compute_and_check_and_send_slave_dhcheck+0x1e4>
			memcpy(r, smp->oobd_local->r, sizeof(r));
    ebe0:	460b      	mov	r3, r1
    ebe2:	f10d 0c10 	add.w	ip, sp, #16
    ebe6:	f101 0e10 	add.w	lr, r1, #16
    ebea:	6818      	ldr	r0, [r3, #0]
    ebec:	6859      	ldr	r1, [r3, #4]
    ebee:	4662      	mov	r2, ip
    ebf0:	c203      	stmia	r2!, {r0, r1}
    ebf2:	3308      	adds	r3, #8
    ebf4:	4573      	cmp	r3, lr
    ebf6:	4694      	mov	ip, r2
    ebf8:	d1f7      	bne.n	ebea <compute_and_check_and_send_slave_dhcheck+0x15a>
		   &smp->chan.chan.conn->le.init_addr,
    ebfa:	4622      	mov	r2, r4
	if (smp_f6(smp->mackey, smp->rrnd, smp->prnd, r, &smp->preq[1],
    ebfc:	4638      	mov	r0, r7
		   &smp->chan.chan.conn->le.init_addr,
    ebfe:	f852 3ba2 	ldr.w	r3, [r2], #162
	if (smp_f6(smp->mackey, smp->rrnd, smp->prnd, r, &smp->preq[1],
    ec02:	9603      	str	r6, [sp, #12]
		   &smp->chan.chan.conn->le.resp_addr, re)) {
    ec04:	f103 0182 	add.w	r1, r3, #130	; 0x82
		   &smp->chan.chan.conn->le.init_addr,
    ec08:	337b      	adds	r3, #123	; 0x7b
	if (smp_f6(smp->mackey, smp->rrnd, smp->prnd, r, &smp->preq[1],
    ec0a:	e9cd 2300 	strd	r2, r3, [sp]
    ec0e:	9102      	str	r1, [sp, #8]
    ec10:	ab04      	add	r3, sp, #16
    ec12:	464a      	mov	r2, r9
    ec14:	4641      	mov	r1, r8
    ec16:	f014 fe84 	bl	23922 <smp_f6>
    ec1a:	2800      	cmp	r0, #0
    ec1c:	d1c6      	bne.n	ebac <compute_and_check_and_send_slave_dhcheck+0x11c>
	if (memcmp(smp->e, re, 16)) {
    ec1e:	2210      	movs	r2, #16
    ec20:	4631      	mov	r1, r6
    ec22:	f204 104f 	addw	r0, r4, #335	; 0x14f
    ec26:	f7f2 ffd3 	bl	1bd0 <memcmp>
    ec2a:	bb48      	cbnz	r0, ec80 <compute_and_check_and_send_slave_dhcheck+0x1f0>
	buf = smp_create_pdu(smp, BT_SMP_DHKEY_CHECK, sizeof(*req));
    ec2c:	210d      	movs	r1, #13
    ec2e:	4620      	mov	r0, r4
    ec30:	f014 fec5 	bl	239be <smp_create_pdu.isra.5>
	if (!buf) {
    ec34:	4606      	mov	r6, r0
    ec36:	2800      	cmp	r0, #0
    ec38:	d0b8      	beq.n	ebac <compute_and_check_and_send_slave_dhcheck+0x11c>
	req = net_buf_add(buf, sizeof(*req));
    ec3a:	2110      	movs	r1, #16
    ec3c:	3008      	adds	r0, #8
    ec3e:	f016 f8cb 	bl	24dd8 <net_buf_simple_add>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    ec42:	af18      	add	r7, sp, #96	; 0x60
    ec44:	4602      	mov	r2, r0
    ec46:	462b      	mov	r3, r5
    ec48:	cb03      	ldmia	r3!, {r0, r1}
    ec4a:	42bb      	cmp	r3, r7
    ec4c:	6010      	str	r0, [r2, #0]
    ec4e:	6051      	str	r1, [r2, #4]
    ec50:	461d      	mov	r5, r3
    ec52:	f102 0208 	add.w	r2, r2, #8
    ec56:	d1f6      	bne.n	ec46 <compute_and_check_and_send_slave_dhcheck+0x1b6>
	smp_send(smp, buf, NULL, NULL);
    ec58:	2200      	movs	r2, #0
    ec5a:	4631      	mov	r1, r6
    ec5c:	4620      	mov	r0, r4
    ec5e:	f7ff fe5d 	bl	e91c <smp_send.isra.7>
	atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
    ec62:	f104 009c 	add.w	r0, r4, #156	; 0x9c
    ec66:	2101      	movs	r1, #1
    ec68:	f014 fdeb 	bl	23842 <atomic_set_bit>
	return 0;
    ec6c:	2000      	movs	r0, #0
}
    ec6e:	b023      	add	sp, #140	; 0x8c
    ec70:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			memset(r, 0, sizeof(r));
    ec74:	2210      	movs	r2, #16
    ec76:	eb0d 0002 	add.w	r0, sp, r2
    ec7a:	f7f2 ffd8 	bl	1c2e <memset>
    ec7e:	e7bc      	b.n	ebfa <compute_and_check_and_send_slave_dhcheck+0x16a>
		return BT_SMP_ERR_DHKEY_CHECK_FAILED;
    ec80:	200b      	movs	r0, #11
    ec82:	e7f4      	b.n	ec6e <compute_and_check_and_send_slave_dhcheck+0x1de>
    ec84:	00063f2f 	.word	0x00063f2f

0000ec88 <smp_pairing_req>:
{
    ec88:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	struct bt_smp_pairing *req = (void *)buf->data;
    ec8c:	688d      	ldr	r5, [r1, #8]
	if ((req->max_key_size > BT_SMP_MAX_ENC_KEY_SIZE) ||
    ec8e:	78eb      	ldrb	r3, [r5, #3]
    ec90:	3b07      	subs	r3, #7
    ec92:	2b09      	cmp	r3, #9
{
    ec94:	4604      	mov	r4, r0
	if ((req->max_key_size > BT_SMP_MAX_ENC_KEY_SIZE) ||
    ec96:	d904      	bls.n	eca2 <smp_pairing_req+0x1a>
		return BT_SMP_ERR_ENC_KEY_SIZE;
    ec98:	2506      	movs	r5, #6
}
    ec9a:	4628      	mov	r0, r5
    ec9c:	b002      	add	sp, #8
    ec9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	struct bt_conn *conn = smp->chan.chan.conn;
    eca2:	6807      	ldr	r7, [r0, #0]
	if (!conn->le.keys) {
    eca4:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
    eca8:	b163      	cbz	r3, ecc4 <smp_pairing_req+0x3c>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ)) {
    ecaa:	f104 069c 	add.w	r6, r4, #156	; 0x9c
    ecae:	210e      	movs	r1, #14
    ecb0:	4630      	mov	r0, r6
    ecb2:	f014 fdd5 	bl	23860 <atomic_test_bit>
    ecb6:	b980      	cbnz	r0, ecda <smp_pairing_req+0x52>
		int ret = smp_init(smp);
    ecb8:	4620      	mov	r0, r4
    ecba:	f7ff fe11 	bl	e8e0 <smp_init>
		if (ret) {
    ecbe:	b160      	cbz	r0, ecda <smp_pairing_req+0x52>
			return ret;
    ecc0:	b2c5      	uxtb	r5, r0
    ecc2:	e7ea      	b.n	ec9a <smp_pairing_req+0x12>
		conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
    ecc4:	f107 0174 	add.w	r1, r7, #116	; 0x74
    ecc8:	7a38      	ldrb	r0, [r7, #8]
    ecca:	f001 fa51 	bl	10170 <bt_keys_get_addr>
    ecce:	f8c7 00a0 	str.w	r0, [r7, #160]	; 0xa0
		if (!conn->le.keys) {
    ecd2:	2800      	cmp	r0, #0
    ecd4:	d1e9      	bne.n	ecaa <smp_pairing_req+0x22>
			return BT_SMP_ERR_UNSPECIFIED;
    ecd6:	2508      	movs	r5, #8
    ecd8:	e7df      	b.n	ec9a <smp_pairing_req+0x12>
	smp->preq[0] = BT_SMP_CMD_PAIRING_REQ;
    ecda:	2301      	movs	r3, #1
    ecdc:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1
    ece0:	682b      	ldr	r3, [r5, #0]
    ece2:	f8c4 30a2 	str.w	r3, [r4, #162]	; 0xa2
    ece6:	88ab      	ldrh	r3, [r5, #4]
    ece8:	f8a4 30a6 	strh.w	r3, [r4, #166]	; 0xa6
	smp->prsp[0] = BT_SMP_CMD_PAIRING_RSP;
    ecec:	2302      	movs	r3, #2
    ecee:	f884 30a8 	strb.w	r3, [r4, #168]	; 0xa8
	rsp->auth_req = get_auth(conn, req->auth_req);
    ecf2:	78a8      	ldrb	r0, [r5, #2]
    ecf4:	f7ff fd94 	bl	e820 <get_auth.isra.0>
    ecf8:	f884 00ab 	strb.w	r0, [r4, #171]	; 0xab
    ecfc:	4680      	mov	r8, r0
	rsp->io_capability = get_io_capa();
    ecfe:	f7ff fca3 	bl	e648 <get_io_capa>
	rsp->oob_flag = oobd_present ? BT_SMP_OOB_PRESENT :
    ed02:	4bb6      	ldr	r3, [pc, #728]	; (efdc <smp_pairing_req+0x354>)
	rsp->io_capability = get_io_capa();
    ed04:	f884 00a9 	strb.w	r0, [r4, #169]	; 0xa9
	rsp->oob_flag = oobd_present ? BT_SMP_OOB_PRESENT :
    ed08:	781b      	ldrb	r3, [r3, #0]
    ed0a:	f884 30aa 	strb.w	r3, [r4, #170]	; 0xaa
	rsp->max_key_size = BT_SMP_MAX_ENC_KEY_SIZE;
    ed0e:	2310      	movs	r3, #16
    ed10:	f884 30ac 	strb.w	r3, [r4, #172]	; 0xac
	rsp->init_key_dist = (req->init_key_dist & RECV_KEYS);
    ed14:	792b      	ldrb	r3, [r5, #4]
    ed16:	f003 0307 	and.w	r3, r3, #7
    ed1a:	f884 30ad 	strb.w	r3, [r4, #173]	; 0xad
	rsp->resp_key_dist = (req->resp_key_dist & SEND_KEYS);
    ed1e:	796b      	ldrb	r3, [r5, #5]
	if ((rsp->auth_req & BT_SMP_AUTH_SC) &&
    ed20:	f018 0f08 	tst.w	r8, #8
	rsp->resp_key_dist = (req->resp_key_dist & SEND_KEYS);
    ed24:	f003 0307 	and.w	r3, r3, #7
    ed28:	f884 30ae 	strb.w	r3, [r4, #174]	; 0xae
	if ((rsp->auth_req & BT_SMP_AUTH_SC) &&
    ed2c:	d012      	beq.n	ed54 <smp_pairing_req+0xcc>
    ed2e:	78ab      	ldrb	r3, [r5, #2]
    ed30:	0718      	lsls	r0, r3, #28
    ed32:	d50f      	bpl.n	ed54 <smp_pairing_req+0xcc>
		atomic_set_bit(smp->flags, SMP_FLAG_SC);
    ed34:	2105      	movs	r1, #5
    ed36:	4630      	mov	r0, r6
    ed38:	f014 fd83 	bl	23842 <atomic_set_bit>
		rsp->init_key_dist &= RECV_KEYS_SC;
    ed3c:	f894 30ad 	ldrb.w	r3, [r4, #173]	; 0xad
    ed40:	f003 0306 	and.w	r3, r3, #6
    ed44:	f884 30ad 	strb.w	r3, [r4, #173]	; 0xad
		rsp->resp_key_dist &= SEND_KEYS_SC;
    ed48:	f894 30ae 	ldrb.w	r3, [r4, #174]	; 0xae
    ed4c:	f003 0306 	and.w	r3, r3, #6
    ed50:	f884 30ae 	strb.w	r3, [r4, #174]	; 0xae
	if ((rsp->auth_req & BT_SMP_AUTH_CT2) &&
    ed54:	f894 30ab 	ldrb.w	r3, [r4, #171]	; 0xab
    ed58:	0699      	lsls	r1, r3, #26
    ed5a:	d506      	bpl.n	ed6a <smp_pairing_req+0xe2>
    ed5c:	78ab      	ldrb	r3, [r5, #2]
    ed5e:	069a      	lsls	r2, r3, #26
    ed60:	d503      	bpl.n	ed6a <smp_pairing_req+0xe2>
		atomic_set_bit(smp->flags, SMP_FLAG_CT2);
    ed62:	2113      	movs	r1, #19
    ed64:	4630      	mov	r0, r6
    ed66:	f014 fd6c 	bl	23842 <atomic_set_bit>
	smp->local_dist = rsp->resp_key_dist;
    ed6a:	f894 30ae 	ldrb.w	r3, [r4, #174]	; 0xae
    ed6e:	f884 3180 	strb.w	r3, [r4, #384]	; 0x180
	smp->remote_dist = rsp->init_key_dist;
    ed72:	f894 30ad 	ldrb.w	r3, [r4, #173]	; 0xad
    ed76:	f884 3181 	strb.w	r3, [r4, #385]	; 0x181
	if ((rsp->auth_req & BT_SMP_AUTH_BONDING) &&
    ed7a:	f894 30ab 	ldrb.w	r3, [r4, #171]	; 0xab
    ed7e:	07db      	lsls	r3, r3, #31
    ed80:	d506      	bpl.n	ed90 <smp_pairing_req+0x108>
    ed82:	78ab      	ldrb	r3, [r5, #2]
    ed84:	07d8      	lsls	r0, r3, #31
    ed86:	d503      	bpl.n	ed90 <smp_pairing_req+0x108>
		atomic_set_bit(smp->flags, SMP_FLAG_BOND);
    ed88:	210c      	movs	r1, #12
    ed8a:	4630      	mov	r0, r6
    ed8c:	f014 fd59 	bl	23842 <atomic_set_bit>
	atomic_set_bit(smp->flags, SMP_FLAG_PAIRING);
    ed90:	2103      	movs	r1, #3
    ed92:	4630      	mov	r0, r6
    ed94:	f014 fd55 	bl	23842 <atomic_set_bit>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    ed98:	2105      	movs	r1, #5
	smp->method = get_pair_method(smp, req->io_capability);
    ed9a:	782d      	ldrb	r5, [r5, #0]
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    ed9c:	f014 fd60 	bl	23860 <atomic_test_bit>
    eda0:	f8d4 8000 	ldr.w	r8, [r4]
    eda4:	2800      	cmp	r0, #0
    eda6:	d14b      	bne.n	ee40 <smp_pairing_req+0x1b8>
	if (remote_io > BT_SMP_IO_KEYBOARD_DISPLAY) {
    eda8:	2d04      	cmp	r5, #4
    edaa:	d816      	bhi.n	edda <smp_pairing_req+0x152>
	if (!((req->auth_req | rsp->auth_req) & BT_SMP_AUTH_MITM)) {
    edac:	f894 00a4 	ldrb.w	r0, [r4, #164]	; 0xa4
    edb0:	f894 30ab 	ldrb.w	r3, [r4, #171]	; 0xab
    edb4:	4318      	orrs	r0, r3
    edb6:	f010 0004 	ands.w	r0, r0, #4
    edba:	d00e      	beq.n	edda <smp_pairing_req+0x152>
	method = gen_method_legacy[remote_io][get_io_capa()];
    edbc:	f7ff fc44 	bl	e648 <get_io_capa>
    edc0:	4b87      	ldr	r3, [pc, #540]	; (efe0 <smp_pairing_req+0x358>)
    edc2:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    edc6:	441d      	add	r5, r3
    edc8:	5c28      	ldrb	r0, [r5, r0]
	if (method == PASSKEY_ROLE) {
    edca:	2804      	cmp	r0, #4
    edcc:	d105      	bne.n	edda <smp_pairing_req+0x152>
		if (smp->chan.chan.conn->role == BT_HCI_ROLE_MASTER) {
    edce:	f898 3003 	ldrb.w	r3, [r8, #3]
			method = PASSKEY_INPUT;
    edd2:	2b00      	cmp	r3, #0
    edd4:	bf0c      	ite	eq
    edd6:	2002      	moveq	r0, #2
    edd8:	2001      	movne	r0, #1
	smp->method = get_pair_method(smp, req->io_capability);
    edda:	f884 00a0 	strb.w	r0, [r4, #160]	; 0xa0
	if (!conn->le.keys) {
    edde:	f8d8 30a0 	ldr.w	r3, [r8, #160]	; 0xa0
    ede2:	b93b      	cbnz	r3, edf4 <smp_pairing_req+0x16c>
		conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
    ede4:	f108 0174 	add.w	r1, r8, #116	; 0x74
    ede8:	f898 0008 	ldrb.w	r0, [r8, #8]
    edec:	f001 f9c0 	bl	10170 <bt_keys_get_addr>
    edf0:	f8c8 00a0 	str.w	r0, [r8, #160]	; 0xa0
	if (!conn->le.keys ||
    edf4:	f8d8 20a0 	ldr.w	r2, [r8, #160]	; 0xa0
    edf8:	2a00      	cmp	r2, #0
    edfa:	d142      	bne.n	ee82 <smp_pairing_req+0x1fa>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    edfc:	2105      	movs	r1, #5
    edfe:	4630      	mov	r0, r6
    ee00:	f014 fd2e 	bl	23860 <atomic_test_bit>
    ee04:	f894 30a0 	ldrb.w	r3, [r4, #160]	; 0xa0
    ee08:	2800      	cmp	r0, #0
    ee0a:	f040 80cc 	bne.w	efa6 <smp_pairing_req+0x31e>
	if ((DISPLAY_FIXED(smp) || smp->method == JUST_WORKS) &&
    ee0e:	461d      	mov	r5, r3
    ee10:	2b00      	cmp	r3, #0
    ee12:	d154      	bne.n	eebe <smp_pairing_req+0x236>
	    !atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) &&
    ee14:	210e      	movs	r1, #14
    ee16:	4630      	mov	r0, r6
    ee18:	f014 fd22 	bl	23860 <atomic_test_bit>
	if ((DISPLAY_FIXED(smp) || smp->method == JUST_WORKS) &&
    ee1c:	2800      	cmp	r0, #0
    ee1e:	d14e      	bne.n	eebe <smp_pairing_req+0x236>
	    !atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) &&
    ee20:	4f70      	ldr	r7, [pc, #448]	; (efe4 <smp_pairing_req+0x35c>)
    ee22:	683b      	ldr	r3, [r7, #0]
    ee24:	2b00      	cmp	r3, #0
    ee26:	d04a      	beq.n	eebe <smp_pairing_req+0x236>
	    bt_auth && bt_auth->pairing_confirm) {
    ee28:	695b      	ldr	r3, [r3, #20]
    ee2a:	2b00      	cmp	r3, #0
    ee2c:	d047      	beq.n	eebe <smp_pairing_req+0x236>
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
    ee2e:	4630      	mov	r0, r6
    ee30:	2109      	movs	r1, #9
    ee32:	f014 fd06 	bl	23842 <atomic_set_bit>
		bt_auth->pairing_confirm(smp->chan.chan.conn);
    ee36:	683b      	ldr	r3, [r7, #0]
    ee38:	6820      	ldr	r0, [r4, #0]
    ee3a:	695b      	ldr	r3, [r3, #20]
    ee3c:	4798      	blx	r3
		return 0;
    ee3e:	e72c      	b.n	ec9a <smp_pairing_req+0x12>
	if ((req->auth_req & rsp->auth_req) & BT_SMP_AUTH_SC) {
    ee40:	f894 00a4 	ldrb.w	r0, [r4, #164]	; 0xa4
    ee44:	f894 20ab 	ldrb.w	r2, [r4, #171]	; 0xab
    ee48:	ea00 0302 	and.w	r3, r0, r2
    ee4c:	0719      	lsls	r1, r3, #28
    ee4e:	d506      	bpl.n	ee5e <smp_pairing_req+0x1d6>
		if ((req->oob_flag | rsp->oob_flag) & BT_SMP_OOB_DATA_MASK) {
    ee50:	f894 30a3 	ldrb.w	r3, [r4, #163]	; 0xa3
    ee54:	f894 10aa 	ldrb.w	r1, [r4, #170]	; 0xaa
    ee58:	430b      	orrs	r3, r1
    ee5a:	07db      	lsls	r3, r3, #31
    ee5c:	d40d      	bmi.n	ee7a <smp_pairing_req+0x1f2>
	if (remote_io > BT_SMP_IO_KEYBOARD_DISPLAY) {
    ee5e:	2d04      	cmp	r5, #4
    ee60:	d80d      	bhi.n	ee7e <smp_pairing_req+0x1f6>
	if (!((req->auth_req | rsp->auth_req) & BT_SMP_AUTH_MITM)) {
    ee62:	4310      	orrs	r0, r2
    ee64:	f010 0004 	ands.w	r0, r0, #4
    ee68:	d0b7      	beq.n	edda <smp_pairing_req+0x152>
	return gen_method_sc[remote_io][get_io_capa()];
    ee6a:	f7ff fbed 	bl	e648 <get_io_capa>
    ee6e:	4b5e      	ldr	r3, [pc, #376]	; (efe8 <smp_pairing_req+0x360>)
    ee70:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    ee74:	441d      	add	r5, r3
    ee76:	5c28      	ldrb	r0, [r5, r0]
    ee78:	e7af      	b.n	edda <smp_pairing_req+0x152>
			return LE_SC_OOB;
    ee7a:	2005      	movs	r0, #5
    ee7c:	e7ad      	b.n	edda <smp_pairing_req+0x152>
		return JUST_WORKS;
    ee7e:	2000      	movs	r0, #0
    ee80:	e7ab      	b.n	edda <smp_pairing_req+0x152>
	    !(conn->le.keys->keys & (BT_KEYS_LTK_P256 | BT_KEYS_LTK))) {
    ee82:	8951      	ldrh	r1, [r2, #10]
	if (!conn->le.keys ||
    ee84:	f011 0f24 	tst.w	r1, #36	; 0x24
    ee88:	d0b8      	beq.n	edfc <smp_pairing_req+0x174>
	return MIN(req->max_key_size, rsp->max_key_size);
    ee8a:	f894 30ac 	ldrb.w	r3, [r4, #172]	; 0xac
    ee8e:	f894 00a5 	ldrb.w	r0, [r4, #165]	; 0xa5
	if (conn->le.keys->enc_size > get_encryption_key_size(smp)) {
    ee92:	7a12      	ldrb	r2, [r2, #8]
    ee94:	4283      	cmp	r3, r0
    ee96:	bf28      	it	cs
    ee98:	4603      	movcs	r3, r0
    ee9a:	429a      	cmp	r2, r3
    ee9c:	d901      	bls.n	eea2 <smp_pairing_req+0x21a>
		return BT_SMP_ERR_AUTH_REQUIREMENTS;
    ee9e:	2503      	movs	r5, #3
    eea0:	e6fb      	b.n	ec9a <smp_pairing_req+0x12>
	if ((conn->le.keys->keys & BT_KEYS_LTK_P256) &&
    eea2:	0689      	lsls	r1, r1, #26
    eea4:	d404      	bmi.n	eeb0 <smp_pairing_req+0x228>
	if (!IS_ENABLED(CONFIG_BT_SMP_ALLOW_UNAUTH_OVERWRITE) &&
    eea6:	f894 30a0 	ldrb.w	r3, [r4, #160]	; 0xa0
    eeaa:	2b00      	cmp	r3, #0
    eeac:	d1a6      	bne.n	edfc <smp_pairing_req+0x174>
    eeae:	e7f6      	b.n	ee9e <smp_pairing_req+0x216>
	    !atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    eeb0:	2105      	movs	r1, #5
    eeb2:	4630      	mov	r0, r6
    eeb4:	f014 fcd4 	bl	23860 <atomic_test_bit>
	if ((conn->le.keys->keys & BT_KEYS_LTK_P256) &&
    eeb8:	2800      	cmp	r0, #0
    eeba:	d1f4      	bne.n	eea6 <smp_pairing_req+0x21e>
    eebc:	e7ef      	b.n	ee9e <smp_pairing_req+0x216>
	ret = send_pairing_rsp(smp);
    eebe:	4620      	mov	r0, r4
    eec0:	f014 fe02 	bl	23ac8 <send_pairing_rsp>
	if (ret) {
    eec4:	4605      	mov	r5, r0
    eec6:	2800      	cmp	r0, #0
    eec8:	f47f aee7 	bne.w	ec9a <smp_pairing_req+0x12>
	atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
    eecc:	2103      	movs	r1, #3
    eece:	f104 0098 	add.w	r0, r4, #152	; 0x98
    eed2:	f014 fcb6 	bl	23842 <atomic_set_bit>
	struct bt_conn *conn = smp->chan.chan.conn;
    eed6:	6825      	ldr	r5, [r4, #0]
	keys = bt_keys_find_addr(conn->id, &conn->le.dst);
    eed8:	f105 0174 	add.w	r1, r5, #116	; 0x74
    eedc:	7a28      	ldrb	r0, [r5, #8]
    eede:	f001 fa09 	bl	102f4 <bt_keys_find_addr>
	if (keys && (keys->flags & BT_KEYS_AUTHENTICATED) &&
    eee2:	f894 30a0 	ldrb.w	r3, [r4, #160]	; 0xa0
    eee6:	b198      	cbz	r0, ef10 <smp_pairing_req+0x288>
    eee8:	7a42      	ldrb	r2, [r0, #9]
    eeea:	07d2      	lsls	r2, r2, #31
    eeec:	d510      	bpl.n	ef10 <smp_pairing_req+0x288>
    eeee:	b97b      	cbnz	r3, ef10 <smp_pairing_req+0x288>
		BT_ERR("JustWorks failed, authenticated keys present");
    eef0:	2301      	movs	r3, #1
    eef2:	f04f 0100 	mov.w	r1, #0
    eef6:	f363 0107 	bfi	r1, r3, #0, #8
    eefa:	4a3c      	ldr	r2, [pc, #240]	; (efec <smp_pairing_req+0x364>)
    eefc:	4b3c      	ldr	r3, [pc, #240]	; (eff0 <smp_pairing_req+0x368>)
    eefe:	483d      	ldr	r0, [pc, #244]	; (eff4 <smp_pairing_req+0x36c>)
    ef00:	1a9b      	subs	r3, r3, r2
    ef02:	08db      	lsrs	r3, r3, #3
    ef04:	f363 118f 	bfi	r1, r3, #6, #10
    ef08:	f012 f897 	bl	2103a <log_0>
				return BT_SMP_ERR_UNSPECIFIED;
    ef0c:	2108      	movs	r1, #8
    ef0e:	e02f      	b.n	ef70 <smp_pairing_req+0x2e8>
	switch (smp->method) {
    ef10:	2b01      	cmp	r3, #1
    ef12:	4619      	mov	r1, r3
    ef14:	d02e      	beq.n	ef74 <smp_pairing_req+0x2ec>
    ef16:	b35b      	cbz	r3, ef70 <smp_pairing_req+0x2e8>
    ef18:	2b02      	cmp	r3, #2
    ef1a:	d135      	bne.n	ef88 <smp_pairing_req+0x300>
			if (bt_rand(&passkey, sizeof(passkey))) {
    ef1c:	2104      	movs	r1, #4
    ef1e:	eb0d 0001 	add.w	r0, sp, r1
    ef22:	f003 fb2b 	bl	1257c <bt_rand>
    ef26:	2800      	cmp	r0, #0
    ef28:	d1f0      	bne.n	ef0c <smp_pairing_req+0x284>
			passkey %= 1000000;
    ef2a:	9901      	ldr	r1, [sp, #4]
    ef2c:	4a32      	ldr	r2, [pc, #200]	; (eff8 <smp_pairing_req+0x370>)
		if (bt_auth && bt_auth->passkey_display) {
    ef2e:	4f2d      	ldr	r7, [pc, #180]	; (efe4 <smp_pairing_req+0x35c>)
			passkey %= 1000000;
    ef30:	fbb1 f3f2 	udiv	r3, r1, r2
    ef34:	fb02 1313 	mls	r3, r2, r3, r1
    ef38:	9301      	str	r3, [sp, #4]
		if (bt_auth && bt_auth->passkey_display) {
    ef3a:	683b      	ldr	r3, [r7, #0]
    ef3c:	b153      	cbz	r3, ef54 <smp_pairing_req+0x2cc>
    ef3e:	681b      	ldr	r3, [r3, #0]
    ef40:	b143      	cbz	r3, ef54 <smp_pairing_req+0x2cc>
			atomic_set_bit(smp->flags, SMP_FLAG_DISPLAY);
    ef42:	210a      	movs	r1, #10
    ef44:	4630      	mov	r0, r6
    ef46:	f014 fc7c 	bl	23842 <atomic_set_bit>
			bt_auth->passkey_display(conn, passkey);
    ef4a:	683b      	ldr	r3, [r7, #0]
    ef4c:	9901      	ldr	r1, [sp, #4]
    ef4e:	681b      	ldr	r3, [r3, #0]
    ef50:	4628      	mov	r0, r5
    ef52:	4798      	blx	r3
		sys_put_le32(passkey, smp->tk);
    ef54:	9b01      	ldr	r3, [sp, #4]
	dst[0] = val;
    ef56:	f884 30df 	strb.w	r3, [r4, #223]	; 0xdf
	dst[1] = val >> 8;
    ef5a:	f3c3 2207 	ubfx	r2, r3, #8, #8
	sys_put_le16(val >> 16, &dst[2]);
    ef5e:	0c1b      	lsrs	r3, r3, #16
	dst[0] = val;
    ef60:	f884 30e1 	strb.w	r3, [r4, #225]	; 0xe1
	dst[1] = val >> 8;
    ef64:	0a1b      	lsrs	r3, r3, #8
    ef66:	f884 20e0 	strb.w	r2, [r4, #224]	; 0xe0
    ef6a:	f884 30e2 	strb.w	r3, [r4, #226]	; 0xe2
	return 0;
    ef6e:	2100      	movs	r1, #0
	return legacy_request_tk(smp);
    ef70:	460d      	mov	r5, r1
    ef72:	e692      	b.n	ec9a <smp_pairing_req+0x12>
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
    ef74:	4630      	mov	r0, r6
    ef76:	2109      	movs	r1, #9
    ef78:	f014 fc63 	bl	23842 <atomic_set_bit>
		bt_auth->passkey_entry(conn);
    ef7c:	4b19      	ldr	r3, [pc, #100]	; (efe4 <smp_pairing_req+0x35c>)
    ef7e:	681b      	ldr	r3, [r3, #0]
    ef80:	4628      	mov	r0, r5
    ef82:	685b      	ldr	r3, [r3, #4]
    ef84:	4798      	blx	r3
    ef86:	e7f2      	b.n	ef6e <smp_pairing_req+0x2e6>
		BT_ERR("Unknown pairing method (%u)", smp->method);
    ef88:	2301      	movs	r3, #1
    ef8a:	f04f 0200 	mov.w	r2, #0
    ef8e:	f363 0207 	bfi	r2, r3, #0, #8
    ef92:	4816      	ldr	r0, [pc, #88]	; (efec <smp_pairing_req+0x364>)
    ef94:	4b16      	ldr	r3, [pc, #88]	; (eff0 <smp_pairing_req+0x368>)
    ef96:	1a1b      	subs	r3, r3, r0
    ef98:	08db      	lsrs	r3, r3, #3
    ef9a:	f363 128f 	bfi	r2, r3, #6, #10
    ef9e:	4817      	ldr	r0, [pc, #92]	; (effc <smp_pairing_req+0x374>)
    efa0:	f012 f858 	bl	21054 <log_1>
		return BT_SMP_ERR_UNSPECIFIED;
    efa4:	e7b2      	b.n	ef0c <smp_pairing_req+0x284>
	if ((IS_ENABLED(CONFIG_BT_SMP_SC_ONLY) ||
    efa6:	7aba      	ldrb	r2, [r7, #10]
    efa8:	2a04      	cmp	r2, #4
    efaa:	461d      	mov	r5, r3
    efac:	d128      	bne.n	f000 <smp_pairing_req+0x378>
	     conn->required_sec_level == BT_SECURITY_L4) &&
    efae:	2b00      	cmp	r3, #0
    efb0:	f43f af75 	beq.w	ee9e <smp_pairing_req+0x216>
	return MIN(req->max_key_size, rsp->max_key_size);
    efb4:	f894 30a5 	ldrb.w	r3, [r4, #165]	; 0xa5
    efb8:	f894 20ac 	ldrb.w	r2, [r4, #172]	; 0xac
	     conn->required_sec_level == BT_SECURITY_L4) &&
    efbc:	4293      	cmp	r3, r2
    efbe:	bf28      	it	cs
    efc0:	4613      	movcs	r3, r2
    efc2:	2b10      	cmp	r3, #16
    efc4:	f47f ae68 	bne.w	ec98 <smp_pairing_req+0x10>
	atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PUBLIC_KEY);
    efc8:	210c      	movs	r1, #12
    efca:	f104 0098 	add.w	r0, r4, #152	; 0x98
    efce:	f014 fc38 	bl	23842 <atomic_set_bit>
	return send_pairing_rsp(smp);
    efd2:	4620      	mov	r0, r4
    efd4:	f014 fd78 	bl	23ac8 <send_pairing_rsp>
    efd8:	4605      	mov	r5, r0
    efda:	e65e      	b.n	ec9a <smp_pairing_req+0x12>
    efdc:	2000aa5a 	.word	0x2000aa5a
    efe0:	00063efd 	.word	0x00063efd
    efe4:	200003a0 	.word	0x200003a0
    efe8:	00063f16 	.word	0x00063f16
    efec:	00028540 	.word	0x00028540
    eff0:	00028640 	.word	0x00028640
    eff4:	00063fd4 	.word	0x00063fd4
    eff8:	000f4240 	.word	0x000f4240
    effc:	00064001 	.word	0x00064001
	if ((DISPLAY_FIXED(smp) || smp->method == JUST_WORKS) &&
    f000:	2b00      	cmp	r3, #0
    f002:	d1e1      	bne.n	efc8 <smp_pairing_req+0x340>
	    !atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) &&
    f004:	210e      	movs	r1, #14
    f006:	4630      	mov	r0, r6
    f008:	f014 fc2a 	bl	23860 <atomic_test_bit>
	if ((DISPLAY_FIXED(smp) || smp->method == JUST_WORKS) &&
    f00c:	2800      	cmp	r0, #0
    f00e:	d1db      	bne.n	efc8 <smp_pairing_req+0x340>
	    !atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) &&
    f010:	4f03      	ldr	r7, [pc, #12]	; (f020 <smp_pairing_req+0x398>)
    f012:	683b      	ldr	r3, [r7, #0]
    f014:	2b00      	cmp	r3, #0
    f016:	d0d7      	beq.n	efc8 <smp_pairing_req+0x340>
	    bt_auth && bt_auth->pairing_confirm) {
    f018:	695b      	ldr	r3, [r3, #20]
    f01a:	2b00      	cmp	r3, #0
    f01c:	d0d4      	beq.n	efc8 <smp_pairing_req+0x340>
    f01e:	e706      	b.n	ee2e <smp_pairing_req+0x1a6>
    f020:	200003a0 	.word	0x200003a0

0000f024 <sc_send_public_key>:
{
    f024:	b570      	push	{r4, r5, r6, lr}
	req_buf = smp_create_pdu(smp, BT_SMP_CMD_PUBLIC_KEY, sizeof(*req));
    f026:	210c      	movs	r1, #12
{
    f028:	4605      	mov	r5, r0
	req_buf = smp_create_pdu(smp, BT_SMP_CMD_PUBLIC_KEY, sizeof(*req));
    f02a:	f014 fcc8 	bl	239be <smp_create_pdu.isra.5>
	if (!req_buf) {
    f02e:	4604      	mov	r4, r0
    f030:	b1f0      	cbz	r0, f070 <sc_send_public_key+0x4c>
	req = net_buf_add(req_buf, sizeof(*req));
    f032:	2140      	movs	r1, #64	; 0x40
    f034:	3008      	adds	r0, #8
    f036:	f015 fecf 	bl	24dd8 <net_buf_simple_add>
	memcpy(req->x, sc_public_key, sizeof(req->x));
    f03a:	4b0e      	ldr	r3, [pc, #56]	; (f074 <sc_send_public_key+0x50>)
    f03c:	681b      	ldr	r3, [r3, #0]
    f03e:	4602      	mov	r2, r0
    f040:	f103 0120 	add.w	r1, r3, #32
    f044:	f853 6b04 	ldr.w	r6, [r3], #4
    f048:	f842 6b04 	str.w	r6, [r2], #4
    f04c:	428b      	cmp	r3, r1
    f04e:	d1f9      	bne.n	f044 <sc_send_public_key+0x20>
    f050:	3020      	adds	r0, #32
    f052:	f103 0220 	add.w	r2, r3, #32
    f056:	f853 1b04 	ldr.w	r1, [r3], #4
    f05a:	f840 1b04 	str.w	r1, [r0], #4
    f05e:	4293      	cmp	r3, r2
    f060:	d1f9      	bne.n	f056 <sc_send_public_key+0x32>
	smp_send(smp, req_buf, NULL, NULL);
    f062:	4628      	mov	r0, r5
    f064:	2200      	movs	r2, #0
    f066:	4621      	mov	r1, r4
    f068:	f7ff fc58 	bl	e91c <smp_send.isra.7>
	return 0;
    f06c:	2000      	movs	r0, #0
}
    f06e:	bd70      	pop	{r4, r5, r6, pc}
		return BT_SMP_ERR_UNSPECIFIED;
    f070:	2008      	movs	r0, #8
    f072:	e7fc      	b.n	f06e <sc_send_public_key+0x4a>
    f074:	20000788 	.word	0x20000788

0000f078 <smp_public_key>:
{
    f078:	b538      	push	{r3, r4, r5, lr}
    f07a:	688b      	ldr	r3, [r1, #8]
    f07c:	4605      	mov	r5, r0
	memcpy(smp->pkey, req->x, 32);
    f07e:	30ef      	adds	r0, #239	; 0xef
    f080:	4602      	mov	r2, r0
    f082:	f103 0120 	add.w	r1, r3, #32
    f086:	f853 4b04 	ldr.w	r4, [r3], #4
    f08a:	f842 4b04 	str.w	r4, [r2], #4
    f08e:	428b      	cmp	r3, r1
    f090:	d1f9      	bne.n	f086 <smp_public_key+0xe>
    f092:	f205 120f 	addw	r2, r5, #271	; 0x10f
    f096:	f103 0120 	add.w	r1, r3, #32
    f09a:	f853 4b04 	ldr.w	r4, [r3], #4
    f09e:	f842 4b04 	str.w	r4, [r2], #4
    f0a2:	428b      	cmp	r3, r1
    f0a4:	d1f9      	bne.n	f09a <smp_public_key+0x22>
	if (memcmp(smp->pkey, sc_debug_public_key, 64) == 0) {
    f0a6:	2240      	movs	r2, #64	; 0x40
    f0a8:	4921      	ldr	r1, [pc, #132]	; (f130 <smp_public_key+0xb8>)
    f0aa:	f7f2 fd91 	bl	1bd0 <memcmp>
    f0ae:	b148      	cbz	r0, f0c4 <smp_public_key+0x4c>
	if (!sc_public_key) {
    f0b0:	4b20      	ldr	r3, [pc, #128]	; (f134 <smp_public_key+0xbc>)
    f0b2:	681c      	ldr	r4, [r3, #0]
    f0b4:	bb94      	cbnz	r4, f11c <smp_public_key+0xa4>
		atomic_set_bit(smp->flags, SMP_FLAG_PKEY_SEND);
    f0b6:	f105 009c 	add.w	r0, r5, #156	; 0x9c
    f0ba:	2106      	movs	r1, #6
    f0bc:	f014 fbc1 	bl	23842 <atomic_set_bit>
		return 0;
    f0c0:	4620      	mov	r0, r4
}
    f0c2:	bd38      	pop	{r3, r4, r5, pc}
		BT_INFO("Remote is using Debug Public key");
    f0c4:	2303      	movs	r3, #3
    f0c6:	f04f 0100 	mov.w	r1, #0
    f0ca:	4a1b      	ldr	r2, [pc, #108]	; (f138 <smp_public_key+0xc0>)
    f0cc:	481b      	ldr	r0, [pc, #108]	; (f13c <smp_public_key+0xc4>)
    f0ce:	f363 0107 	bfi	r1, r3, #0, #8
    f0d2:	4b1b      	ldr	r3, [pc, #108]	; (f140 <smp_public_key+0xc8>)
    f0d4:	1a9b      	subs	r3, r3, r2
    f0d6:	08db      	lsrs	r3, r3, #3
    f0d8:	f363 118f 	bfi	r1, r3, #6, #10
    f0dc:	f011 ffad 	bl	2103a <log_0>
		atomic_set_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY);
    f0e0:	210d      	movs	r1, #13
    f0e2:	f105 009c 	add.w	r0, r5, #156	; 0x9c
    f0e6:	f014 fbac 	bl	23842 <atomic_set_bit>
		if (!update_debug_keys_check(smp)) {
    f0ea:	682c      	ldr	r4, [r5, #0]
	if (!conn->le.keys) {
    f0ec:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    f0f0:	b933      	cbnz	r3, f100 <smp_public_key+0x88>
		conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
    f0f2:	f104 0174 	add.w	r1, r4, #116	; 0x74
    f0f6:	7a20      	ldrb	r0, [r4, #8]
    f0f8:	f001 f83a 	bl	10170 <bt_keys_get_addr>
    f0fc:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
	if (!conn->le.keys ||
    f100:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    f104:	2b00      	cmp	r3, #0
    f106:	d0d3      	beq.n	f0b0 <smp_public_key+0x38>
    f108:	895a      	ldrh	r2, [r3, #10]
    f10a:	f002 0224 	and.w	r2, r2, #36	; 0x24
    f10e:	2a00      	cmp	r2, #0
    f110:	d0ce      	beq.n	f0b0 <smp_public_key+0x38>
	if (conn->le.keys->flags & BT_KEYS_DEBUG) {
    f112:	7a5b      	ldrb	r3, [r3, #9]
    f114:	079b      	lsls	r3, r3, #30
    f116:	d5cb      	bpl.n	f0b0 <smp_public_key+0x38>
			return BT_SMP_ERR_AUTH_REQUIREMENTS;
    f118:	2003      	movs	r0, #3
    f11a:	e7d2      	b.n	f0c2 <smp_public_key+0x4a>
	err = sc_send_public_key(smp);
    f11c:	4628      	mov	r0, r5
    f11e:	f7ff ff81 	bl	f024 <sc_send_public_key>
	if (err) {
    f122:	2800      	cmp	r0, #0
    f124:	d1cd      	bne.n	f0c2 <smp_public_key+0x4a>
    f126:	4628      	mov	r0, r5
}
    f128:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    f12c:	f7ff bc4c 	b.w	e9c8 <smp_public_key_slave.part.14>
    f130:	00063f3f 	.word	0x00063f3f
    f134:	20000788 	.word	0x20000788
    f138:	00028540 	.word	0x00028540
    f13c:	0006401d 	.word	0x0006401d
    f140:	00028640 	.word	0x00028640

0000f144 <smp_pairing_complete>:
{
    f144:	b570      	push	{r4, r5, r6, lr}
    f146:	4604      	mov	r4, r0
    f148:	4e17      	ldr	r6, [pc, #92]	; (f1a8 <smp_pairing_complete+0x64>)
    f14a:	309c      	adds	r0, #156	; 0x9c
	if (!status) {
    f14c:	b9a9      	cbnz	r1, f17a <smp_pairing_complete+0x36>
		bool bond_flag = atomic_test_bit(smp->flags, SMP_FLAG_BOND);
    f14e:	210c      	movs	r1, #12
    f150:	f014 fb86 	bl	23860 <atomic_test_bit>
		if (bond_flag) {
    f154:	4605      	mov	r5, r0
    f156:	b120      	cbz	r0, f162 <smp_pairing_complete+0x1e>
			bt_keys_store(smp->chan.chan.conn->le.keys);
    f158:	6823      	ldr	r3, [r4, #0]
    f15a:	f8d3 00a0 	ldr.w	r0, [r3, #160]	; 0xa0
    f15e:	f001 f9cb 	bl	104f8 <bt_keys_store>
		if (bt_auth && bt_auth->pairing_complete) {
    f162:	6833      	ldr	r3, [r6, #0]
    f164:	b123      	cbz	r3, f170 <smp_pairing_complete+0x2c>
    f166:	699b      	ldr	r3, [r3, #24]
		if (bt_auth && bt_auth->pairing_failed) {
    f168:	b113      	cbz	r3, f170 <smp_pairing_complete+0x2c>
			bt_auth->pairing_failed(smp->chan.chan.conn, auth_err);
    f16a:	4629      	mov	r1, r5
    f16c:	6820      	ldr	r0, [r4, #0]
    f16e:	4798      	blx	r3
	smp_reset(smp);
    f170:	4620      	mov	r0, r4
}
    f172:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	smp_reset(smp);
    f176:	f014 bcde 	b.w	23b36 <smp_reset>
	switch (smp_err) {
    f17a:	3901      	subs	r1, #1
    f17c:	b2c9      	uxtb	r1, r1
    f17e:	290d      	cmp	r1, #13
    f180:	bf9c      	itt	ls
    f182:	4b0a      	ldrls	r3, [pc, #40]	; (f1ac <smp_pairing_complete+0x68>)
    f184:	5c5d      	ldrbls	r5, [r3, r1]
		if (!atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR)) {
    f186:	f04f 0102 	mov.w	r1, #2
	if (!status) {
    f18a:	bf88      	it	hi
    f18c:	2508      	movhi	r5, #8
		if (!atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR)) {
    f18e:	f014 fb67 	bl	23860 <atomic_test_bit>
    f192:	b918      	cbnz	r0, f19c <smp_pairing_complete+0x58>
			bt_conn_security_changed(smp->chan.chan.conn, auth_err);
    f194:	4629      	mov	r1, r5
    f196:	6820      	ldr	r0, [r4, #0]
    f198:	f7fb fb9c 	bl	a8d4 <bt_conn_security_changed>
		if (bt_auth && bt_auth->pairing_failed) {
    f19c:	6833      	ldr	r3, [r6, #0]
    f19e:	2b00      	cmp	r3, #0
    f1a0:	d0e6      	beq.n	f170 <smp_pairing_complete+0x2c>
    f1a2:	69db      	ldr	r3, [r3, #28]
    f1a4:	e7e0      	b.n	f168 <smp_pairing_complete+0x24>
    f1a6:	bf00      	nop
    f1a8:	200003a0 	.word	0x200003a0
    f1ac:	00063cd0 	.word	0x00063cd0

0000f1b0 <bt_smp_dhkey_ready>:
{
    f1b0:	b510      	push	{r4, lr}
		if (atomic_test_and_clear_bit(bt_smp_pool[i].flags,
    f1b2:	2107      	movs	r1, #7
{
    f1b4:	4604      	mov	r4, r0
		if (atomic_test_and_clear_bit(bt_smp_pool[i].flags,
    f1b6:	4819      	ldr	r0, [pc, #100]	; (f21c <bt_smp_dhkey_ready+0x6c>)
    f1b8:	f014 fca2 	bl	23b00 <atomic_test_and_clear_bit>
    f1bc:	b360      	cbz	r0, f218 <bt_smp_dhkey_ready+0x68>
	if (!dhkey) {
    f1be:	b92c      	cbnz	r4, f1cc <bt_smp_dhkey_ready+0x1c>
		smp_error(smp, BT_SMP_ERR_DHKEY_CHECK_FAILED);
    f1c0:	210b      	movs	r1, #11
			smp_error(smp, err);
    f1c2:	4817      	ldr	r0, [pc, #92]	; (f220 <bt_smp_dhkey_ready+0x70>)
}
    f1c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			smp_error(smp, err);
    f1c8:	f014 bce0 	b.w	23b8c <smp_error>
    f1cc:	4b15      	ldr	r3, [pc, #84]	; (f224 <bt_smp_dhkey_ready+0x74>)
    f1ce:	4620      	mov	r0, r4
    f1d0:	f104 0220 	add.w	r2, r4, #32
    f1d4:	f850 1b04 	ldr.w	r1, [r0], #4
    f1d8:	f843 1b04 	str.w	r1, [r3], #4
    f1dc:	4290      	cmp	r0, r2
    f1de:	d1f9      	bne.n	f1d4 <bt_smp_dhkey_ready+0x24>
	if (atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
    f1e0:	2109      	movs	r1, #9
    f1e2:	480e      	ldr	r0, [pc, #56]	; (f21c <bt_smp_dhkey_ready+0x6c>)
    f1e4:	f014 fb3c 	bl	23860 <atomic_test_bit>
    f1e8:	b128      	cbz	r0, f1f6 <bt_smp_dhkey_ready+0x46>
		atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_SEND);
    f1ea:	2108      	movs	r1, #8
    f1ec:	480b      	ldr	r0, [pc, #44]	; (f21c <bt_smp_dhkey_ready+0x6c>)
}
    f1ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_SEND);
    f1f2:	f014 bb26 	b.w	23842 <atomic_set_bit>
	if (atomic_test_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT)) {
    f1f6:	210f      	movs	r1, #15
    f1f8:	4808      	ldr	r0, [pc, #32]	; (f21c <bt_smp_dhkey_ready+0x6c>)
    f1fa:	f014 fb31 	bl	23860 <atomic_test_bit>
    f1fe:	2800      	cmp	r0, #0
    f200:	d1f3      	bne.n	f1ea <bt_smp_dhkey_ready+0x3a>
	if (atomic_test_bit(smp->flags, SMP_FLAG_DHKEY_SEND)) {
    f202:	2108      	movs	r1, #8
    f204:	4805      	ldr	r0, [pc, #20]	; (f21c <bt_smp_dhkey_ready+0x6c>)
    f206:	f014 fb2b 	bl	23860 <atomic_test_bit>
    f20a:	b128      	cbz	r0, f218 <bt_smp_dhkey_ready+0x68>
		err = compute_and_check_and_send_slave_dhcheck(smp);
    f20c:	4804      	ldr	r0, [pc, #16]	; (f220 <bt_smp_dhkey_ready+0x70>)
    f20e:	f7ff fc3f 	bl	ea90 <compute_and_check_and_send_slave_dhcheck>
		if (err) {
    f212:	4601      	mov	r1, r0
    f214:	2800      	cmp	r0, #0
    f216:	d1d4      	bne.n	f1c2 <bt_smp_dhkey_ready+0x12>
}
    f218:	bd10      	pop	{r4, pc}
    f21a:	bf00      	nop
    f21c:	20000680 	.word	0x20000680
    f220:	200005e4 	.word	0x200005e4
    f224:	20000713 	.word	0x20000713

0000f228 <bt_smp_recv>:
{
    f228:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (buf->len < sizeof(*hdr)) {
    f22a:	898b      	ldrh	r3, [r1, #12]
{
    f22c:	4604      	mov	r4, r0
    f22e:	460d      	mov	r5, r1
	if (buf->len < sizeof(*hdr)) {
    f230:	b97b      	cbnz	r3, f252 <bt_smp_recv+0x2a>
		BT_ERR("Too small SMP PDU received");
    f232:	2301      	movs	r3, #1
    f234:	f04f 0100 	mov.w	r1, #0
    f238:	f363 0107 	bfi	r1, r3, #0, #8
    f23c:	4a3c      	ldr	r2, [pc, #240]	; (f330 <bt_smp_recv+0x108>)
    f23e:	4b3d      	ldr	r3, [pc, #244]	; (f334 <bt_smp_recv+0x10c>)
    f240:	483d      	ldr	r0, [pc, #244]	; (f338 <bt_smp_recv+0x110>)
    f242:	1a9b      	subs	r3, r3, r2
    f244:	08db      	lsrs	r3, r3, #3
    f246:	f363 118f 	bfi	r1, r3, #6, #10
    f24a:	f011 fef6 	bl	2103a <log_0>
}
    f24e:	2000      	movs	r0, #0
    f250:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    f252:	2101      	movs	r1, #1
    f254:	f105 0008 	add.w	r0, r5, #8
    f258:	f015 fdf0 	bl	24e3c <net_buf_simple_pull_mem>
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
    f25c:	2104      	movs	r1, #4
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    f25e:	4606      	mov	r6, r0
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
    f260:	f104 009c 	add.w	r0, r4, #156	; 0x9c
    f264:	f014 fafc 	bl	23860 <atomic_test_bit>
    f268:	7831      	ldrb	r1, [r6, #0]
    f26a:	b170      	cbz	r0, f28a <bt_smp_recv+0x62>
		BT_WARN("SMP command (code 0x%02x) received after timeout",
    f26c:	2302      	movs	r3, #2
    f26e:	f04f 0200 	mov.w	r2, #0
    f272:	f363 0207 	bfi	r2, r3, #0, #8
    f276:	482e      	ldr	r0, [pc, #184]	; (f330 <bt_smp_recv+0x108>)
    f278:	4b2e      	ldr	r3, [pc, #184]	; (f334 <bt_smp_recv+0x10c>)
    f27a:	1a1b      	subs	r3, r3, r0
    f27c:	08db      	lsrs	r3, r3, #3
    f27e:	f363 128f 	bfi	r2, r3, #6, #10
    f282:	482e      	ldr	r0, [pc, #184]	; (f33c <bt_smp_recv+0x114>)
    f284:	f011 fee6 	bl	21054 <log_1>
		return 0;
    f288:	e7e1      	b.n	f24e <bt_smp_recv+0x26>
	if (hdr->code >= ARRAY_SIZE(handlers) || !handlers[hdr->code].func) {
    f28a:	290d      	cmp	r1, #13
    f28c:	d803      	bhi.n	f296 <bt_smp_recv+0x6e>
    f28e:	4f2c      	ldr	r7, [pc, #176]	; (f340 <bt_smp_recv+0x118>)
    f290:	f857 3031 	ldr.w	r3, [r7, r1, lsl #3]
    f294:	b993      	cbnz	r3, f2bc <bt_smp_recv+0x94>
		BT_WARN("Unhandled SMP code 0x%02x", hdr->code);
    f296:	2302      	movs	r3, #2
    f298:	f04f 0200 	mov.w	r2, #0
    f29c:	f363 0207 	bfi	r2, r3, #0, #8
    f2a0:	4823      	ldr	r0, [pc, #140]	; (f330 <bt_smp_recv+0x108>)
    f2a2:	4b24      	ldr	r3, [pc, #144]	; (f334 <bt_smp_recv+0x10c>)
    f2a4:	1a1b      	subs	r3, r3, r0
    f2a6:	08db      	lsrs	r3, r3, #3
    f2a8:	f363 128f 	bfi	r2, r3, #6, #10
    f2ac:	4825      	ldr	r0, [pc, #148]	; (f344 <bt_smp_recv+0x11c>)
    f2ae:	f011 fed1 	bl	21054 <log_1>
		smp_error(smp, BT_SMP_ERR_CMD_NOTSUPP);
    f2b2:	2107      	movs	r1, #7
		smp_error(smp, err);
    f2b4:	4620      	mov	r0, r4
    f2b6:	f014 fc69 	bl	23b8c <smp_error>
    f2ba:	e7c8      	b.n	f24e <bt_smp_recv+0x26>
	if (!atomic_test_and_clear_bit(&smp->allowed_cmds, hdr->code)) {
    f2bc:	f104 0098 	add.w	r0, r4, #152	; 0x98
    f2c0:	f014 fc1e 	bl	23b00 <atomic_test_and_clear_bit>
    f2c4:	7831      	ldrb	r1, [r6, #0]
    f2c6:	b990      	cbnz	r0, f2ee <bt_smp_recv+0xc6>
		BT_WARN("Unexpected SMP code 0x%02x", hdr->code);
    f2c8:	2302      	movs	r3, #2
    f2ca:	f04f 0200 	mov.w	r2, #0
    f2ce:	f363 0207 	bfi	r2, r3, #0, #8
    f2d2:	4817      	ldr	r0, [pc, #92]	; (f330 <bt_smp_recv+0x108>)
    f2d4:	4b17      	ldr	r3, [pc, #92]	; (f334 <bt_smp_recv+0x10c>)
    f2d6:	1a1b      	subs	r3, r3, r0
    f2d8:	08db      	lsrs	r3, r3, #3
    f2da:	f363 128f 	bfi	r2, r3, #6, #10
    f2de:	481a      	ldr	r0, [pc, #104]	; (f348 <bt_smp_recv+0x120>)
    f2e0:	f011 feb8 	bl	21054 <log_1>
		if (hdr->code != BT_SMP_CMD_PAIRING_FAIL) {
    f2e4:	7833      	ldrb	r3, [r6, #0]
    f2e6:	2b05      	cmp	r3, #5
    f2e8:	d0b1      	beq.n	f24e <bt_smp_recv+0x26>
			smp_error(smp, BT_SMP_ERR_UNSPECIFIED);
    f2ea:	2108      	movs	r1, #8
    f2ec:	e7e2      	b.n	f2b4 <bt_smp_recv+0x8c>
	if (buf->len != handlers[hdr->code].expect_len) {
    f2ee:	eb07 03c1 	add.w	r3, r7, r1, lsl #3
    f2f2:	89a8      	ldrh	r0, [r5, #12]
    f2f4:	791b      	ldrb	r3, [r3, #4]
    f2f6:	4283      	cmp	r3, r0
    f2f8:	d011      	beq.n	f31e <bt_smp_recv+0xf6>
		BT_ERR("Invalid len %u for code 0x%02x", buf->len, hdr->code);
    f2fa:	2201      	movs	r2, #1
    f2fc:	f04f 0300 	mov.w	r3, #0
    f300:	f362 0307 	bfi	r3, r2, #0, #8
    f304:	4d0a      	ldr	r5, [pc, #40]	; (f330 <bt_smp_recv+0x108>)
    f306:	4a0b      	ldr	r2, [pc, #44]	; (f334 <bt_smp_recv+0x10c>)
    f308:	1b52      	subs	r2, r2, r5
    f30a:	08d2      	lsrs	r2, r2, #3
    f30c:	f362 138f 	bfi	r3, r2, #6, #10
    f310:	460a      	mov	r2, r1
    f312:	4601      	mov	r1, r0
    f314:	480d      	ldr	r0, [pc, #52]	; (f34c <bt_smp_recv+0x124>)
    f316:	f011 feb1 	bl	2107c <log_2>
		smp_error(smp, BT_SMP_ERR_INVALID_PARAMS);
    f31a:	210a      	movs	r1, #10
    f31c:	e7ca      	b.n	f2b4 <bt_smp_recv+0x8c>
	err = handlers[hdr->code].func(smp, buf);
    f31e:	f857 3031 	ldr.w	r3, [r7, r1, lsl #3]
    f322:	4620      	mov	r0, r4
    f324:	4629      	mov	r1, r5
    f326:	4798      	blx	r3
	if (err) {
    f328:	4601      	mov	r1, r0
    f32a:	2800      	cmp	r0, #0
    f32c:	d08f      	beq.n	f24e <bt_smp_recv+0x26>
    f32e:	e7c1      	b.n	f2b4 <bt_smp_recv+0x8c>
    f330:	00028540 	.word	0x00028540
    f334:	00028640 	.word	0x00028640
    f338:	00063df5 	.word	0x00063df5
    f33c:	00063e10 	.word	0x00063e10
    f340:	000291bc 	.word	0x000291bc
    f344:	00063e41 	.word	0x00063e41
    f348:	00063e5b 	.word	0x00063e5b
    f34c:	00063966 	.word	0x00063966

0000f350 <smp_pairing_failed>:
{
    f350:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	BT_ERR("reason 0x%x", req->reason);
    f352:	f04f 0200 	mov.w	r2, #0
    f356:	2301      	movs	r3, #1
	struct bt_smp_pairing_fail *req = (void *)buf->data;
    f358:	688e      	ldr	r6, [r1, #8]
    f35a:	491b      	ldr	r1, [pc, #108]	; (f3c8 <smp_pairing_failed+0x78>)
	BT_ERR("reason 0x%x", req->reason);
    f35c:	f363 0207 	bfi	r2, r3, #0, #8
    f360:	4b1a      	ldr	r3, [pc, #104]	; (f3cc <smp_pairing_failed+0x7c>)
	struct bt_conn *conn = smp->chan.chan.conn;
    f362:	4604      	mov	r4, r0
    f364:	1a5b      	subs	r3, r3, r1
    f366:	f854 7b9c 	ldr.w	r7, [r4], #156
	BT_ERR("reason 0x%x", req->reason);
    f36a:	7831      	ldrb	r1, [r6, #0]
    f36c:	08db      	lsrs	r3, r3, #3
{
    f36e:	4605      	mov	r5, r0
	BT_ERR("reason 0x%x", req->reason);
    f370:	f363 128f 	bfi	r2, r3, #6, #10
    f374:	4816      	ldr	r0, [pc, #88]	; (f3d0 <smp_pairing_failed+0x80>)
    f376:	f011 fe6d 	bl	21054 <log_1>
	if (atomic_test_and_clear_bit(smp->flags, SMP_FLAG_USER) ||
    f37a:	2109      	movs	r1, #9
    f37c:	4620      	mov	r0, r4
    f37e:	f014 fbbf 	bl	23b00 <atomic_test_and_clear_bit>
    f382:	b198      	cbz	r0, f3ac <smp_pairing_failed+0x5c>
		if (bt_auth && bt_auth->cancel) {
    f384:	4b13      	ldr	r3, [pc, #76]	; (f3d4 <smp_pairing_failed+0x84>)
    f386:	681b      	ldr	r3, [r3, #0]
    f388:	b9bb      	cbnz	r3, f3ba <smp_pairing_failed+0x6a>
	if (atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR) &&
    f38a:	2102      	movs	r1, #2
    f38c:	4620      	mov	r0, r4
    f38e:	f014 fa67 	bl	23860 <atomic_test_bit>
    f392:	b128      	cbz	r0, f3a0 <smp_pairing_failed+0x50>
	    smp->chan.chan.conn->le.keys) {
    f394:	682b      	ldr	r3, [r5, #0]
    f396:	f8d3 00a0 	ldr.w	r0, [r3, #160]	; 0xa0
	if (atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR) &&
    f39a:	b108      	cbz	r0, f3a0 <smp_pairing_failed+0x50>
		bt_keys_clear(smp->chan.chan.conn->le.keys);
    f39c:	f000 ffba 	bl	10314 <bt_keys_clear>
	smp_pairing_complete(smp, req->reason);
    f3a0:	4628      	mov	r0, r5
    f3a2:	7831      	ldrb	r1, [r6, #0]
    f3a4:	f7ff fece 	bl	f144 <smp_pairing_complete>
}
    f3a8:	2000      	movs	r0, #0
    f3aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	    atomic_test_and_clear_bit(smp->flags, SMP_FLAG_DISPLAY)) {
    f3ac:	210a      	movs	r1, #10
    f3ae:	4620      	mov	r0, r4
    f3b0:	f014 fba6 	bl	23b00 <atomic_test_and_clear_bit>
	if (atomic_test_and_clear_bit(smp->flags, SMP_FLAG_USER) ||
    f3b4:	2800      	cmp	r0, #0
    f3b6:	d1e5      	bne.n	f384 <smp_pairing_failed+0x34>
    f3b8:	e7e7      	b.n	f38a <smp_pairing_failed+0x3a>
		if (bt_auth && bt_auth->cancel) {
    f3ba:	691b      	ldr	r3, [r3, #16]
    f3bc:	2b00      	cmp	r3, #0
    f3be:	d0e4      	beq.n	f38a <smp_pairing_failed+0x3a>
			bt_auth->cancel(conn);
    f3c0:	4638      	mov	r0, r7
    f3c2:	4798      	blx	r3
    f3c4:	e7e1      	b.n	f38a <smp_pairing_failed+0x3a>
    f3c6:	bf00      	nop
    f3c8:	00028540 	.word	0x00028540
    f3cc:	00028640 	.word	0x00028640
    f3d0:	00063fc8 	.word	0x00063fc8
    f3d4:	200003a0 	.word	0x200003a0

0000f3d8 <smp_timeout>:
{
    f3d8:	b538      	push	{r3, r4, r5, lr}
	BT_ERR("SMP Timeout");
    f3da:	f04f 0100 	mov.w	r1, #0
    f3de:	2301      	movs	r3, #1
    f3e0:	f363 0107 	bfi	r1, r3, #0, #8
    f3e4:	4a10      	ldr	r2, [pc, #64]	; (f428 <smp_timeout+0x50>)
    f3e6:	4b11      	ldr	r3, [pc, #68]	; (f42c <smp_timeout+0x54>)
    f3e8:	1a9b      	subs	r3, r3, r2
{
    f3ea:	4604      	mov	r4, r0
    f3ec:	08db      	lsrs	r3, r3, #3
	BT_ERR("SMP Timeout");
    f3ee:	f363 118f 	bfi	r1, r3, #6, #10
	struct bt_smp *smp = CONTAINER_OF(work, struct bt_smp, work);
    f3f2:	f5a0 75c2 	sub.w	r5, r0, #388	; 0x184
	if (atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR) &&
    f3f6:	3ce8      	subs	r4, #232	; 0xe8
	BT_ERR("SMP Timeout");
    f3f8:	480d      	ldr	r0, [pc, #52]	; (f430 <smp_timeout+0x58>)
    f3fa:	f011 fe1e 	bl	2103a <log_0>
	if (atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR) &&
    f3fe:	2102      	movs	r1, #2
    f400:	4620      	mov	r0, r4
    f402:	f014 fa2d 	bl	23860 <atomic_test_bit>
    f406:	b128      	cbz	r0, f414 <smp_timeout+0x3c>
	    smp->chan.chan.conn->le.keys) {
    f408:	682b      	ldr	r3, [r5, #0]
    f40a:	f8d3 00a0 	ldr.w	r0, [r3, #160]	; 0xa0
	if (atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR) &&
    f40e:	b108      	cbz	r0, f414 <smp_timeout+0x3c>
		bt_keys_clear(smp->chan.chan.conn->le.keys);
    f410:	f000 ff80 	bl	10314 <bt_keys_clear>
	atomic_set_bit(smp->flags, SMP_FLAG_TIMEOUT);
    f414:	4620      	mov	r0, r4
    f416:	2104      	movs	r1, #4
    f418:	f014 fa13 	bl	23842 <atomic_set_bit>
	smp_pairing_complete(smp, BT_SMP_ERR_UNSPECIFIED);
    f41c:	4628      	mov	r0, r5
    f41e:	2108      	movs	r1, #8
}
    f420:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	smp_pairing_complete(smp, BT_SMP_ERR_UNSPECIFIED);
    f424:	f7ff be8e 	b.w	f144 <smp_pairing_complete>
    f428:	00028540 	.word	0x00028540
    f42c:	00028640 	.word	0x00028640
    f430:	00064052 	.word	0x00064052

0000f434 <smp_signing_info>:
{
    f434:	b570      	push	{r4, r5, r6, lr}
    f436:	460a      	mov	r2, r1
    f438:	4605      	mov	r5, r0
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    f43a:	210c      	movs	r1, #12
	struct bt_conn *conn = smp->chan.chan.conn;
    f43c:	f850 3b9c 	ldr.w	r3, [r0], #156
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    f440:	f014 fa0e 	bl	23860 <atomic_test_bit>
    f444:	b348      	cbz	r0, f49a <smp_signing_info+0x66>
					&conn->le.dst);
    f446:	f103 0674 	add.w	r6, r3, #116	; 0x74
		struct bt_smp_signing_info *req = (void *)buf->data;
    f44a:	6894      	ldr	r4, [r2, #8]
		keys = bt_keys_get_type(BT_KEYS_REMOTE_CSRK, conn->id,
    f44c:	7a19      	ldrb	r1, [r3, #8]
    f44e:	4632      	mov	r2, r6
    f450:	2010      	movs	r0, #16
    f452:	f014 fd8f 	bl	23f74 <bt_keys_get_type>
		if (!keys) {
    f456:	b9b0      	cbnz	r0, f486 <smp_signing_info+0x52>
			BT_ERR("Unable to get keys for %s",
    f458:	2301      	movs	r3, #1
    f45a:	f04f 0400 	mov.w	r4, #0
    f45e:	4a16      	ldr	r2, [pc, #88]	; (f4b8 <smp_signing_info+0x84>)
    f460:	f363 0407 	bfi	r4, r3, #0, #8
    f464:	4b15      	ldr	r3, [pc, #84]	; (f4bc <smp_signing_info+0x88>)
    f466:	1a9b      	subs	r3, r3, r2
    f468:	08db      	lsrs	r3, r3, #3
    f46a:	4630      	mov	r0, r6
    f46c:	f363 148f 	bfi	r4, r3, #6, #10
    f470:	f7f8 f9ba 	bl	77e8 <bt_addr_le_str_real>
    f474:	f7f5 fc44 	bl	4d00 <log_strdup>
    f478:	4622      	mov	r2, r4
    f47a:	4601      	mov	r1, r0
    f47c:	4810      	ldr	r0, [pc, #64]	; (f4c0 <smp_signing_info+0x8c>)
    f47e:	f011 fde9 	bl	21054 <log_1>
			return BT_SMP_ERR_UNSPECIFIED;
    f482:	2008      	movs	r0, #8
}
    f484:	bd70      	pop	{r4, r5, r6, pc}
    f486:	4623      	mov	r3, r4
    f488:	3050      	adds	r0, #80	; 0x50
    f48a:	f104 0210 	add.w	r2, r4, #16
    f48e:	f853 1b04 	ldr.w	r1, [r3], #4
    f492:	f840 1b04 	str.w	r1, [r0], #4
    f496:	4293      	cmp	r3, r2
    f498:	d1f9      	bne.n	f48e <smp_signing_info+0x5a>
	smp->remote_dist &= ~BT_SMP_DIST_SIGN;
    f49a:	f895 3181 	ldrb.w	r3, [r5, #385]	; 0x181
    f49e:	f023 0304 	bic.w	r3, r3, #4
    f4a2:	f885 3181 	strb.w	r3, [r5, #385]	; 0x181
	if (!smp->local_dist && !smp->remote_dist) {
    f4a6:	f8b5 4180 	ldrh.w	r4, [r5, #384]	; 0x180
    f4aa:	b91c      	cbnz	r4, f4b4 <smp_signing_info+0x80>
		smp_pairing_complete(smp, 0);
    f4ac:	4621      	mov	r1, r4
    f4ae:	4628      	mov	r0, r5
    f4b0:	f7ff fe48 	bl	f144 <smp_pairing_complete>
	return 0;
    f4b4:	2000      	movs	r0, #0
    f4b6:	e7e5      	b.n	f484 <smp_signing_info+0x50>
    f4b8:	00028540 	.word	0x00028540
    f4bc:	00028640 	.word	0x00028640
    f4c0:	00063fae 	.word	0x00063fae

0000f4c4 <smp_master_ident>:
{
    f4c4:	b570      	push	{r4, r5, r6, lr}
    f4c6:	460a      	mov	r2, r1
    f4c8:	4604      	mov	r4, r0
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    f4ca:	210c      	movs	r1, #12
	struct bt_conn *conn = smp->chan.chan.conn;
    f4cc:	f850 3b9c 	ldr.w	r3, [r0], #156
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    f4d0:	f014 f9c6 	bl	23860 <atomic_test_bit>
    f4d4:	b368      	cbz	r0, f532 <smp_master_ident+0x6e>
		keys = bt_keys_get_type(BT_KEYS_LTK, conn->id, &conn->le.dst);
    f4d6:	f103 0674 	add.w	r6, r3, #116	; 0x74
		struct bt_smp_master_ident *req = (void *)buf->data;
    f4da:	6895      	ldr	r5, [r2, #8]
		keys = bt_keys_get_type(BT_KEYS_LTK, conn->id, &conn->le.dst);
    f4dc:	7a19      	ldrb	r1, [r3, #8]
    f4de:	4632      	mov	r2, r6
    f4e0:	2004      	movs	r0, #4
    f4e2:	f014 fd47 	bl	23f74 <bt_keys_get_type>
		if (!keys) {
    f4e6:	b9b0      	cbnz	r0, f516 <smp_master_ident+0x52>
			BT_ERR("Unable to get keys for %s",
    f4e8:	2301      	movs	r3, #1
    f4ea:	f04f 0400 	mov.w	r4, #0
    f4ee:	4a1c      	ldr	r2, [pc, #112]	; (f560 <smp_master_ident+0x9c>)
    f4f0:	f363 0407 	bfi	r4, r3, #0, #8
    f4f4:	4b1b      	ldr	r3, [pc, #108]	; (f564 <smp_master_ident+0xa0>)
    f4f6:	1a9b      	subs	r3, r3, r2
    f4f8:	08db      	lsrs	r3, r3, #3
    f4fa:	4630      	mov	r0, r6
    f4fc:	f363 148f 	bfi	r4, r3, #6, #10
    f500:	f7f8 f972 	bl	77e8 <bt_addr_le_str_real>
    f504:	f7f5 fbfc 	bl	4d00 <log_strdup>
    f508:	4622      	mov	r2, r4
    f50a:	4601      	mov	r1, r0
    f50c:	4816      	ldr	r0, [pc, #88]	; (f568 <smp_master_ident+0xa4>)
    f50e:	f011 fda1 	bl	21054 <log_1>
			return BT_SMP_ERR_UNSPECIFIED;
    f512:	2008      	movs	r0, #8
}
    f514:	bd70      	pop	{r4, r5, r6, pc}
    f516:	882b      	ldrh	r3, [r5, #0]
    f518:	8283      	strh	r3, [r0, #20]
    f51a:	462b      	mov	r3, r5
    f51c:	f853 2f02 	ldr.w	r2, [r3, #2]!
    f520:	60c2      	str	r2, [r0, #12]
    f522:	685a      	ldr	r2, [r3, #4]
    f524:	6102      	str	r2, [r0, #16]
		smp->remote_dist &= ~BT_SMP_DIST_ENC_KEY;
    f526:	f894 3181 	ldrb.w	r3, [r4, #385]	; 0x181
    f52a:	f023 0301 	bic.w	r3, r3, #1
    f52e:	f884 3181 	strb.w	r3, [r4, #385]	; 0x181
	if (smp->remote_dist & BT_SMP_DIST_ID_KEY) {
    f532:	f894 3181 	ldrb.w	r3, [r4, #385]	; 0x181
    f536:	079a      	lsls	r2, r3, #30
    f538:	d50d      	bpl.n	f556 <smp_master_ident+0x92>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_IDENT_INFO);
    f53a:	2108      	movs	r1, #8
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
    f53c:	f104 0098 	add.w	r0, r4, #152	; 0x98
    f540:	f014 f97f 	bl	23842 <atomic_set_bit>
	if (!smp->local_dist && !smp->remote_dist) {
    f544:	f8b4 5180 	ldrh.w	r5, [r4, #384]	; 0x180
    f548:	b91d      	cbnz	r5, f552 <smp_master_ident+0x8e>
		smp_pairing_complete(smp, 0);
    f54a:	4629      	mov	r1, r5
    f54c:	4620      	mov	r0, r4
    f54e:	f7ff fdf9 	bl	f144 <smp_pairing_complete>
	return 0;
    f552:	2000      	movs	r0, #0
    f554:	e7de      	b.n	f514 <smp_master_ident+0x50>
	} else if (smp->remote_dist & BT_SMP_DIST_SIGN) {
    f556:	075b      	lsls	r3, r3, #29
    f558:	d5f4      	bpl.n	f544 <smp_master_ident+0x80>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
    f55a:	210a      	movs	r1, #10
    f55c:	e7ee      	b.n	f53c <smp_master_ident+0x78>
    f55e:	bf00      	nop
    f560:	00028540 	.word	0x00028540
    f564:	00028640 	.word	0x00028640
    f568:	00063fae 	.word	0x00063fae

0000f56c <bt_smp_encrypt_change>:
{
    f56c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct bt_conn *conn = chan->conn;
    f570:	4605      	mov	r5, r0
{
    f572:	460f      	mov	r7, r1
	struct bt_conn *conn = chan->conn;
    f574:	f855 6b9c 	ldr.w	r6, [r5], #156
{
    f578:	b088      	sub	sp, #32
    f57a:	4604      	mov	r4, r0
	atomic_clear_bit(smp->flags, SMP_FLAG_ENC_PENDING);
    f57c:	2101      	movs	r1, #1
    f57e:	4628      	mov	r0, r5
    f580:	f014 f9b8 	bl	238f4 <atomic_clear_bit>
	if (hci_status) {
    f584:	b947      	cbnz	r7, f598 <bt_smp_encrypt_change+0x2c>
	if (!conn->encrypt) {
    f586:	7af3      	ldrb	r3, [r6, #11]
    f588:	b133      	cbz	r3, f598 <bt_smp_encrypt_change+0x2c>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
    f58a:	2103      	movs	r1, #3
    f58c:	f014 f968 	bl	23860 <atomic_test_bit>
    f590:	b928      	cbnz	r0, f59e <bt_smp_encrypt_change+0x32>
		smp_reset(smp);
    f592:	4620      	mov	r0, r4
    f594:	f014 facf 	bl	23b36 <smp_reset>
}
    f598:	b008      	add	sp, #32
    f59a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    f59e:	2105      	movs	r1, #5
    f5a0:	4628      	mov	r0, r5
    f5a2:	f014 f95d 	bl	23860 <atomic_test_bit>
    f5a6:	b198      	cbz	r0, f5d0 <bt_smp_encrypt_change+0x64>
		if ((smp->local_dist & BT_SMP_DIST_LINK_KEY) &&
    f5a8:	f894 3180 	ldrb.w	r3, [r4, #384]	; 0x180
    f5ac:	071a      	lsls	r2, r3, #28
    f5ae:	d507      	bpl.n	f5c0 <bt_smp_encrypt_change+0x54>
    f5b0:	f894 3181 	ldrb.w	r3, [r4, #385]	; 0x181
    f5b4:	071b      	lsls	r3, r3, #28
    f5b6:	d503      	bpl.n	f5c0 <bt_smp_encrypt_change+0x54>
			atomic_set_bit(smp->flags, SMP_FLAG_DERIVE_LK);
    f5b8:	2110      	movs	r1, #16
    f5ba:	4628      	mov	r0, r5
    f5bc:	f014 f941 	bl	23842 <atomic_set_bit>
		smp->local_dist &= ~BT_SMP_DIST_LINK_KEY;
    f5c0:	f8b4 3180 	ldrh.w	r3, [r4, #384]	; 0x180
    f5c4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    f5c8:	f023 0308 	bic.w	r3, r3, #8
    f5cc:	f8a4 3180 	strh.w	r3, [r4, #384]	; 0x180
	if (smp->remote_dist & BT_SMP_DIST_ENC_KEY) {
    f5d0:	f894 3181 	ldrb.w	r3, [r4, #385]	; 0x181
    f5d4:	07df      	lsls	r7, r3, #31
    f5d6:	d524      	bpl.n	f622 <bt_smp_encrypt_change+0xb6>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_ENCRYPT_INFO);
    f5d8:	2106      	movs	r1, #6
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
    f5da:	f104 0098 	add.w	r0, r4, #152	; 0x98
    f5de:	f014 f930 	bl	23842 <atomic_set_bit>
	atomic_set_bit(smp->flags, SMP_FLAG_KEYS_DISTR);
    f5e2:	2102      	movs	r1, #2
    f5e4:	4628      	mov	r0, r5
    f5e6:	f014 f92c 	bl	23842 <atomic_set_bit>
	struct bt_conn *conn = smp->chan.chan.conn;
    f5ea:	f8d4 8000 	ldr.w	r8, [r4]
	struct bt_keys *keys = conn->le.keys;
    f5ee:	f8d8 70a0 	ldr.w	r7, [r8, #160]	; 0xa0
	if (!keys) {
    f5f2:	b9f7      	cbnz	r7, f632 <bt_smp_encrypt_change+0xc6>
		BT_ERR("No keys space for %s", bt_addr_le_str(&conn->le.dst));
    f5f4:	2301      	movs	r3, #1
    f5f6:	f04f 0400 	mov.w	r4, #0
    f5fa:	4aa0      	ldr	r2, [pc, #640]	; (f87c <bt_smp_encrypt_change+0x310>)
    f5fc:	f363 0407 	bfi	r4, r3, #0, #8
    f600:	4b9f      	ldr	r3, [pc, #636]	; (f880 <bt_smp_encrypt_change+0x314>)
    f602:	1a9b      	subs	r3, r3, r2
    f604:	08db      	lsrs	r3, r3, #3
    f606:	f108 0074 	add.w	r0, r8, #116	; 0x74
    f60a:	f363 148f 	bfi	r4, r3, #6, #10
    f60e:	f7f8 f8eb 	bl	77e8 <bt_addr_le_str_real>
    f612:	f7f5 fb75 	bl	4d00 <log_strdup>
    f616:	4622      	mov	r2, r4
    f618:	4601      	mov	r1, r0
    f61a:	489a      	ldr	r0, [pc, #616]	; (f884 <bt_smp_encrypt_change+0x318>)
    f61c:	f011 fd1a 	bl	21054 <log_1>
		return BT_SMP_ERR_UNSPECIFIED;
    f620:	e7ba      	b.n	f598 <bt_smp_encrypt_change+0x2c>
	} else if (smp->remote_dist & BT_SMP_DIST_ID_KEY) {
    f622:	079e      	lsls	r6, r3, #30
    f624:	d501      	bpl.n	f62a <bt_smp_encrypt_change+0xbe>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_IDENT_INFO);
    f626:	2108      	movs	r1, #8
    f628:	e7d7      	b.n	f5da <bt_smp_encrypt_change+0x6e>
	} else if (smp->remote_dist & BT_SMP_DIST_SIGN) {
    f62a:	0758      	lsls	r0, r3, #29
    f62c:	d5d9      	bpl.n	f5e2 <bt_smp_encrypt_change+0x76>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
    f62e:	210a      	movs	r1, #10
    f630:	e7d3      	b.n	f5da <bt_smp_encrypt_change+0x6e>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    f632:	2105      	movs	r1, #5
    f634:	f014 f914 	bl	23860 <atomic_test_bit>
    f638:	4682      	mov	sl, r0
    f63a:	b9f0      	cbnz	r0, f67a <bt_smp_encrypt_change+0x10e>
	if (smp->local_dist & BT_SMP_DIST_ENC_KEY) {
    f63c:	f894 3180 	ldrb.w	r3, [r4, #384]	; 0x180
    f640:	07d9      	lsls	r1, r3, #31
    f642:	d51a      	bpl.n	f67a <bt_smp_encrypt_change+0x10e>
	struct bt_keys *keys = conn->le.keys;
    f644:	6823      	ldr	r3, [r4, #0]
		bt_rand((void *)&rand, sizeof(rand));
    f646:	211a      	movs	r1, #26
    f648:	a801      	add	r0, sp, #4
	struct bt_keys *keys = conn->le.keys;
    f64a:	f8d3 60a0 	ldr.w	r6, [r3, #160]	; 0xa0
		bt_rand((void *)&rand, sizeof(rand));
    f64e:	f002 ff95 	bl	1257c <bt_rand>
		buf = smp_create_pdu(smp, BT_SMP_CMD_ENCRYPT_INFO,
    f652:	2106      	movs	r1, #6
    f654:	4620      	mov	r0, r4
    f656:	f014 f9b2 	bl	239be <smp_create_pdu.isra.5>
		if (!buf) {
    f65a:	4681      	mov	r9, r0
    f65c:	bb40      	cbnz	r0, f6b0 <bt_smp_encrypt_change+0x144>
			BT_ERR("Unable to allocate Encrypt Info buffer");
    f65e:	2301      	movs	r3, #1
    f660:	f04f 0100 	mov.w	r1, #0
    f664:	f363 0107 	bfi	r1, r3, #0, #8
    f668:	4a84      	ldr	r2, [pc, #528]	; (f87c <bt_smp_encrypt_change+0x310>)
    f66a:	4b85      	ldr	r3, [pc, #532]	; (f880 <bt_smp_encrypt_change+0x314>)
    f66c:	4886      	ldr	r0, [pc, #536]	; (f888 <bt_smp_encrypt_change+0x31c>)
    f66e:	1a9b      	subs	r3, r3, r2
    f670:	08db      	lsrs	r3, r3, #3
    f672:	f363 118f 	bfi	r1, r3, #6, #10
			BT_ERR("Unable to allocate Master Ident buffer");
    f676:	f011 fce0 	bl	2103a <log_0>
	if (smp->local_dist & BT_SMP_DIST_ID_KEY) {
    f67a:	f894 3180 	ldrb.w	r3, [r4, #384]	; 0x180
    f67e:	079a      	lsls	r2, r3, #30
    f680:	f140 80b8 	bpl.w	f7f4 <bt_smp_encrypt_change+0x288>
		buf = smp_create_pdu(smp, BT_SMP_CMD_IDENT_INFO,
    f684:	2108      	movs	r1, #8
    f686:	4620      	mov	r0, r4
    f688:	f014 f999 	bl	239be <smp_create_pdu.isra.5>
		if (!buf) {
    f68c:	4606      	mov	r6, r0
    f68e:	2800      	cmp	r0, #0
    f690:	d16e      	bne.n	f770 <bt_smp_encrypt_change+0x204>
			BT_ERR("Unable to allocate Ident Info buffer");
    f692:	2301      	movs	r3, #1
    f694:	f04f 0100 	mov.w	r1, #0
    f698:	f363 0107 	bfi	r1, r3, #0, #8
    f69c:	4a77      	ldr	r2, [pc, #476]	; (f87c <bt_smp_encrypt_change+0x310>)
    f69e:	4b78      	ldr	r3, [pc, #480]	; (f880 <bt_smp_encrypt_change+0x314>)
    f6a0:	487a      	ldr	r0, [pc, #488]	; (f88c <bt_smp_encrypt_change+0x320>)
    f6a2:	1a9b      	subs	r3, r3, r2
    f6a4:	08db      	lsrs	r3, r3, #3
    f6a6:	f363 118f 	bfi	r1, r3, #6, #10
			BT_ERR("Unable to allocate Ident Addr Info buffer");
    f6aa:	f011 fcc6 	bl	2103a <log_0>
			return BT_SMP_ERR_UNSPECIFIED;
    f6ae:	e773      	b.n	f598 <bt_smp_encrypt_change+0x2c>
		info = net_buf_add(buf, sizeof(*info));
    f6b0:	2110      	movs	r1, #16
    f6b2:	3008      	adds	r0, #8
    f6b4:	f015 fb90 	bl	24dd8 <net_buf_simple_add>
    f6b8:	7a32      	ldrb	r2, [r6, #8]
    f6ba:	a901      	add	r1, sp, #4
    f6bc:	f7f2 fa96 	bl	1bec <memcpy>
    f6c0:	4603      	mov	r3, r0
		if (keys->enc_size < sizeof(info->ltk)) {
    f6c2:	7a30      	ldrb	r0, [r6, #8]
    f6c4:	280f      	cmp	r0, #15
    f6c6:	d805      	bhi.n	f6d4 <bt_smp_encrypt_change+0x168>
__ssp_bos_icheck3(memset, void *, int)
    f6c8:	f1c0 0210 	rsb	r2, r0, #16
    f6cc:	4651      	mov	r1, sl
    f6ce:	4418      	add	r0, r3
    f6d0:	f7f2 faad 	bl	1c2e <memset>
		smp_send(smp, buf, NULL, NULL);
    f6d4:	4649      	mov	r1, r9
    f6d6:	2200      	movs	r2, #0
    f6d8:	4620      	mov	r0, r4
    f6da:	f7ff f91f 	bl	e91c <smp_send.isra.7>
		buf = smp_create_pdu(smp, BT_SMP_CMD_MASTER_IDENT,
    f6de:	2107      	movs	r1, #7
    f6e0:	4620      	mov	r0, r4
    f6e2:	f014 f96c 	bl	239be <smp_create_pdu.isra.5>
		if (!buf) {
    f6e6:	4681      	mov	r9, r0
    f6e8:	b960      	cbnz	r0, f704 <bt_smp_encrypt_change+0x198>
			BT_ERR("Unable to allocate Master Ident buffer");
    f6ea:	2301      	movs	r3, #1
    f6ec:	f04f 0100 	mov.w	r1, #0
    f6f0:	f363 0107 	bfi	r1, r3, #0, #8
    f6f4:	4a61      	ldr	r2, [pc, #388]	; (f87c <bt_smp_encrypt_change+0x310>)
    f6f6:	4b62      	ldr	r3, [pc, #392]	; (f880 <bt_smp_encrypt_change+0x314>)
    f6f8:	4865      	ldr	r0, [pc, #404]	; (f890 <bt_smp_encrypt_change+0x324>)
    f6fa:	1a9b      	subs	r3, r3, r2
    f6fc:	08db      	lsrs	r3, r3, #3
    f6fe:	f363 118f 	bfi	r1, r3, #6, #10
    f702:	e7b8      	b.n	f676 <bt_smp_encrypt_change+0x10a>
		ident = net_buf_add(buf, sizeof(*ident));
    f704:	210a      	movs	r1, #10
    f706:	3008      	adds	r0, #8
    f708:	f015 fb66 	bl	24dd8 <net_buf_simple_add>
    f70c:	ab05      	add	r3, sp, #20
    f70e:	4602      	mov	r2, r0
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    f710:	cb03      	ldmia	r3!, {r0, r1}
    f712:	f8c2 0002 	str.w	r0, [r2, #2]
    f716:	f8c2 1006 	str.w	r1, [r2, #6]
    f71a:	f8bd 301c 	ldrh.w	r3, [sp, #28]
    f71e:	8013      	strh	r3, [r2, #0]
		smp_send(smp, buf, smp_ident_sent, NULL);
    f720:	4649      	mov	r1, r9
    f722:	4a5c      	ldr	r2, [pc, #368]	; (f894 <bt_smp_encrypt_change+0x328>)
    f724:	4620      	mov	r0, r4
    f726:	f7ff f8f9 	bl	e91c <smp_send.isra.7>
		if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    f72a:	210c      	movs	r1, #12
    f72c:	4628      	mov	r0, r5
    f72e:	f014 f897 	bl	23860 <atomic_test_bit>
    f732:	f10d 0914 	add.w	r9, sp, #20
    f736:	2800      	cmp	r0, #0
    f738:	d09f      	beq.n	f67a <bt_smp_encrypt_change+0x10e>
			bt_keys_add_type(keys, BT_KEYS_SLAVE_LTK);
    f73a:	2101      	movs	r1, #1
    f73c:	4630      	mov	r0, r6
    f73e:	f014 fc29 	bl	23f94 <bt_keys_add_type>
    f742:	ab01      	add	r3, sp, #4
    f744:	f106 0c6e 	add.w	ip, r6, #110	; 0x6e
    f748:	461a      	mov	r2, r3
    f74a:	ca03      	ldmia	r2!, {r0, r1}
    f74c:	454a      	cmp	r2, r9
    f74e:	f8cc 0000 	str.w	r0, [ip]
    f752:	f8cc 1004 	str.w	r1, [ip, #4]
    f756:	4613      	mov	r3, r2
    f758:	f10c 0c08 	add.w	ip, ip, #8
    f75c:	d1f4      	bne.n	f748 <bt_smp_encrypt_change+0x1dc>
    f75e:	464b      	mov	r3, r9
    f760:	cb03      	ldmia	r3!, {r0, r1}
    f762:	f8bd 301c 	ldrh.w	r3, [sp, #28]
    f766:	6670      	str	r0, [r6, #100]	; 0x64
    f768:	66b1      	str	r1, [r6, #104]	; 0x68
    f76a:	f8a6 306c 	strh.w	r3, [r6, #108]	; 0x6c
    f76e:	e784      	b.n	f67a <bt_smp_encrypt_change+0x10e>
		id_info = net_buf_add(buf, sizeof(*id_info));
    f770:	2110      	movs	r1, #16
    f772:	3008      	adds	r0, #8
    f774:	f015 fb30 	bl	24dd8 <net_buf_simple_add>
		memcpy(id_info->irk, bt_dev.irk[conn->id], 16);
    f778:	f898 2008 	ldrb.w	r2, [r8, #8]
    f77c:	23dc      	movs	r3, #220	; 0xdc
    f77e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    f782:	4a45      	ldr	r2, [pc, #276]	; (f898 <bt_smp_encrypt_change+0x32c>)
    f784:	4413      	add	r3, r2
    f786:	4684      	mov	ip, r0
    f788:	f103 0e10 	add.w	lr, r3, #16
    f78c:	4691      	mov	r9, r2
    f78e:	461a      	mov	r2, r3
    f790:	ca03      	ldmia	r2!, {r0, r1}
    f792:	4572      	cmp	r2, lr
    f794:	f8cc 0000 	str.w	r0, [ip]
    f798:	f8cc 1004 	str.w	r1, [ip, #4]
    f79c:	4613      	mov	r3, r2
    f79e:	f10c 0c08 	add.w	ip, ip, #8
    f7a2:	d1f4      	bne.n	f78e <bt_smp_encrypt_change+0x222>
		smp_send(smp, buf, NULL, NULL);
    f7a4:	4631      	mov	r1, r6
    f7a6:	2200      	movs	r2, #0
    f7a8:	4620      	mov	r0, r4
    f7aa:	f7ff f8b7 	bl	e91c <smp_send.isra.7>
		buf = smp_create_pdu(smp, BT_SMP_CMD_IDENT_ADDR_INFO,
    f7ae:	2109      	movs	r1, #9
    f7b0:	4620      	mov	r0, r4
    f7b2:	f014 f904 	bl	239be <smp_create_pdu.isra.5>
		if (!buf) {
    f7b6:	4606      	mov	r6, r0
    f7b8:	b960      	cbnz	r0, f7d4 <bt_smp_encrypt_change+0x268>
			BT_ERR("Unable to allocate Ident Addr Info buffer");
    f7ba:	2301      	movs	r3, #1
    f7bc:	f04f 0100 	mov.w	r1, #0
    f7c0:	f363 0107 	bfi	r1, r3, #0, #8
    f7c4:	4a2d      	ldr	r2, [pc, #180]	; (f87c <bt_smp_encrypt_change+0x310>)
    f7c6:	4b2e      	ldr	r3, [pc, #184]	; (f880 <bt_smp_encrypt_change+0x314>)
    f7c8:	4834      	ldr	r0, [pc, #208]	; (f89c <bt_smp_encrypt_change+0x330>)
    f7ca:	1a9b      	subs	r3, r3, r2
    f7cc:	08db      	lsrs	r3, r3, #3
    f7ce:	f363 118f 	bfi	r1, r3, #6, #10
    f7d2:	e76a      	b.n	f6aa <bt_smp_encrypt_change+0x13e>
		id_addr_info = net_buf_add(buf, sizeof(*id_addr_info));
    f7d4:	2107      	movs	r1, #7
    f7d6:	3008      	adds	r0, #8
    f7d8:	f015 fafe 	bl	24dd8 <net_buf_simple_add>
		bt_addr_le_copy(&id_addr_info->addr, &bt_dev.id_addr[conn->id]);
    f7dc:	f898 1008 	ldrb.w	r1, [r8, #8]
    f7e0:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
    f7e4:	4449      	add	r1, r9
    f7e6:	f014 f895 	bl	23914 <bt_addr_le_copy>
		smp_send(smp, buf, smp_id_sent, NULL);
    f7ea:	4a2d      	ldr	r2, [pc, #180]	; (f8a0 <bt_smp_encrypt_change+0x334>)
    f7ec:	4631      	mov	r1, r6
    f7ee:	4620      	mov	r0, r4
    f7f0:	f7ff f894 	bl	e91c <smp_send.isra.7>
	if (smp->local_dist & BT_SMP_DIST_SIGN) {
    f7f4:	f894 3180 	ldrb.w	r3, [r4, #384]	; 0x180
    f7f8:	075b      	lsls	r3, r3, #29
    f7fa:	d535      	bpl.n	f868 <bt_smp_encrypt_change+0x2fc>
		buf = smp_create_pdu(smp, BT_SMP_CMD_SIGNING_INFO,
    f7fc:	210a      	movs	r1, #10
    f7fe:	4620      	mov	r0, r4
    f800:	f014 f8dd 	bl	239be <smp_create_pdu.isra.5>
		if (!buf) {
    f804:	4680      	mov	r8, r0
    f806:	b960      	cbnz	r0, f822 <bt_smp_encrypt_change+0x2b6>
			BT_ERR("Unable to allocate Signing Info buffer");
    f808:	2301      	movs	r3, #1
    f80a:	f04f 0100 	mov.w	r1, #0
    f80e:	f363 0107 	bfi	r1, r3, #0, #8
    f812:	4a1a      	ldr	r2, [pc, #104]	; (f87c <bt_smp_encrypt_change+0x310>)
    f814:	4b1a      	ldr	r3, [pc, #104]	; (f880 <bt_smp_encrypt_change+0x314>)
    f816:	4823      	ldr	r0, [pc, #140]	; (f8a4 <bt_smp_encrypt_change+0x338>)
    f818:	1a9b      	subs	r3, r3, r2
    f81a:	08db      	lsrs	r3, r3, #3
    f81c:	f363 118f 	bfi	r1, r3, #6, #10
    f820:	e743      	b.n	f6aa <bt_smp_encrypt_change+0x13e>
		info = net_buf_add(buf, sizeof(*info));
    f822:	2110      	movs	r1, #16
    f824:	3008      	adds	r0, #8
    f826:	f015 fad7 	bl	24dd8 <net_buf_simple_add>
		bt_rand(info->csrk, sizeof(info->csrk));
    f82a:	2110      	movs	r1, #16
		info = net_buf_add(buf, sizeof(*info));
    f82c:	4606      	mov	r6, r0
		bt_rand(info->csrk, sizeof(info->csrk));
    f82e:	f002 fea5 	bl	1257c <bt_rand>
		if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    f832:	210c      	movs	r1, #12
    f834:	4628      	mov	r0, r5
    f836:	f014 f813 	bl	23860 <atomic_test_bit>
    f83a:	b180      	cbz	r0, f85e <bt_smp_encrypt_change+0x2f2>
			bt_keys_add_type(keys, BT_KEYS_LOCAL_CSRK);
    f83c:	4638      	mov	r0, r7
    f83e:	2108      	movs	r1, #8
    f840:	f014 fba8 	bl	23f94 <bt_keys_add_type>
    f844:	4630      	mov	r0, r6
    f846:	f107 033c 	add.w	r3, r7, #60	; 0x3c
    f84a:	f106 0210 	add.w	r2, r6, #16
    f84e:	f850 1b04 	ldr.w	r1, [r0], #4
    f852:	f843 1b04 	str.w	r1, [r3], #4
    f856:	4290      	cmp	r0, r2
    f858:	d1f9      	bne.n	f84e <bt_smp_encrypt_change+0x2e2>
			keys->local_csrk.cnt = 0U;
    f85a:	2300      	movs	r3, #0
    f85c:	64fb      	str	r3, [r7, #76]	; 0x4c
		smp_send(smp, buf, smp_sign_info_sent, NULL);
    f85e:	4a12      	ldr	r2, [pc, #72]	; (f8a8 <bt_smp_encrypt_change+0x33c>)
    f860:	4641      	mov	r1, r8
    f862:	4620      	mov	r0, r4
    f864:	f7ff f85a 	bl	e91c <smp_send.isra.7>
	if (!smp->local_dist && !smp->remote_dist) {
    f868:	f8b4 1180 	ldrh.w	r1, [r4, #384]	; 0x180
    f86c:	2900      	cmp	r1, #0
    f86e:	f47f ae93 	bne.w	f598 <bt_smp_encrypt_change+0x2c>
		smp_pairing_complete(smp, 0);
    f872:	4620      	mov	r0, r4
    f874:	f7ff fc66 	bl	f144 <smp_pairing_complete>
    f878:	e68e      	b.n	f598 <bt_smp_encrypt_change+0x2c>
    f87a:	bf00      	nop
    f87c:	00028540 	.word	0x00028540
    f880:	00028640 	.word	0x00028640
    f884:	00063d03 	.word	0x00063d03
    f888:	00063d18 	.word	0x00063d18
    f88c:	00063d66 	.word	0x00063d66
    f890:	00063d3f 	.word	0x00063d3f
    f894:	00023bfd 	.word	0x00023bfd
    f898:	2000e4d8 	.word	0x2000e4d8
    f89c:	00063d8b 	.word	0x00063d8b
    f8a0:	00023c09 	.word	0x00023c09
    f8a4:	00063db5 	.word	0x00063db5
    f8a8:	00023bef 	.word	0x00023bef

0000f8ac <bt_smp_connected>:
{
    f8ac:	b510      	push	{r4, lr}
	k_delayed_work_init(&smp->work, smp_timeout);
    f8ae:	4905      	ldr	r1, [pc, #20]	; (f8c4 <bt_smp_connected+0x18>)
{
    f8b0:	4604      	mov	r4, r0
	k_delayed_work_init(&smp->work, smp_timeout);
    f8b2:	f500 70c2 	add.w	r0, r0, #388	; 0x184
    f8b6:	f018 fb26 	bl	27f06 <k_delayed_work_init>
	smp_reset(smp);
    f8ba:	4620      	mov	r0, r4
}
    f8bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	smp_reset(smp);
    f8c0:	f014 b939 	b.w	23b36 <smp_reset>
    f8c4:	0000f3d9 	.word	0x0000f3d9

0000f8c8 <smp_ident_addr_info>:
{
    f8c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct bt_smp_ident_addr_info *req = (void *)buf->data;
    f8cc:	688f      	ldr	r7, [r1, #8]
	struct bt_conn *conn = smp->chan.chan.conn;
    f8ce:	6804      	ldr	r4, [r0, #0]
	return BT_ADDR_IS_RPA(&addr->a);
}

static inline bool bt_addr_le_is_identity(const bt_addr_le_t *addr)
{
	if (addr->type == BT_ADDR_LE_PUBLIC) {
    f8d0:	783b      	ldrb	r3, [r7, #0]
{
    f8d2:	4605      	mov	r5, r0
    f8d4:	b37b      	cbz	r3, f936 <smp_ident_addr_info+0x6e>
	if (!bt_addr_le_is_identity(&req->addr)) {
    f8d6:	79bb      	ldrb	r3, [r7, #6]
    f8d8:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    f8dc:	2bc0      	cmp	r3, #192	; 0xc0
    f8de:	d02a      	beq.n	f936 <smp_ident_addr_info+0x6e>
		BT_ERR("Invalid identity %s", bt_addr_le_str(&req->addr));
    f8e0:	2301      	movs	r3, #1
    f8e2:	f04f 0600 	mov.w	r6, #0
    f8e6:	f363 0607 	bfi	r6, r3, #0, #8
    f8ea:	4d47      	ldr	r5, [pc, #284]	; (fa08 <smp_ident_addr_info+0x140>)
    f8ec:	4b47      	ldr	r3, [pc, #284]	; (fa0c <smp_ident_addr_info+0x144>)
    f8ee:	4638      	mov	r0, r7
    f8f0:	1aed      	subs	r5, r5, r3
    f8f2:	f7f7 ff79 	bl	77e8 <bt_addr_le_str_real>
    f8f6:	f7f5 fa03 	bl	4d00 <log_strdup>
    f8fa:	f3c5 05c9 	ubfx	r5, r5, #3, #10
    f8fe:	f365 168f 	bfi	r6, r5, #6, #10
    f902:	4632      	mov	r2, r6
    f904:	4601      	mov	r1, r0
    f906:	4842      	ldr	r0, [pc, #264]	; (fa10 <smp_ident_addr_info+0x148>)
    f908:	f011 fba4 	bl	21054 <log_1>
		BT_ERR(" for %s", bt_addr_le_str(&conn->le.dst));
    f90c:	f04f 0600 	mov.w	r6, #0
    f910:	2301      	movs	r3, #1
    f912:	f104 0074 	add.w	r0, r4, #116	; 0x74
    f916:	f363 0607 	bfi	r6, r3, #0, #8
    f91a:	f7f7 ff65 	bl	77e8 <bt_addr_le_str_real>
    f91e:	f7f5 f9ef 	bl	4d00 <log_strdup>
    f922:	f365 168f 	bfi	r6, r5, #6, #10
    f926:	4601      	mov	r1, r0
    f928:	4632      	mov	r2, r6
    f92a:	483a      	ldr	r0, [pc, #232]	; (fa14 <smp_ident_addr_info+0x14c>)
    f92c:	f011 fb92 	bl	21054 <log_1>
		return BT_SMP_ERR_INVALID_PARAMS;
    f930:	200a      	movs	r0, #10
}
    f932:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    f936:	210c      	movs	r1, #12
    f938:	f105 009c 	add.w	r0, r5, #156	; 0x9c
    f93c:	f013 ff90 	bl	23860 <atomic_test_bit>
    f940:	2800      	cmp	r0, #0
    f942:	d047      	beq.n	f9d4 <smp_ident_addr_info+0x10c>
		keys = bt_keys_get_type(BT_KEYS_IRK, conn->id, &conn->le.dst);
    f944:	f104 0874 	add.w	r8, r4, #116	; 0x74
    f948:	4642      	mov	r2, r8
    f94a:	7a21      	ldrb	r1, [r4, #8]
    f94c:	2002      	movs	r0, #2
    f94e:	f014 fb11 	bl	23f74 <bt_keys_get_type>
		if (!keys) {
    f952:	4606      	mov	r6, r0
    f954:	b9b0      	cbnz	r0, f984 <smp_ident_addr_info+0xbc>
			BT_ERR("Unable to get keys for %s",
    f956:	2301      	movs	r3, #1
    f958:	f04f 0400 	mov.w	r4, #0
    f95c:	4a2b      	ldr	r2, [pc, #172]	; (fa0c <smp_ident_addr_info+0x144>)
    f95e:	f363 0407 	bfi	r4, r3, #0, #8
    f962:	4b29      	ldr	r3, [pc, #164]	; (fa08 <smp_ident_addr_info+0x140>)
    f964:	1a9b      	subs	r3, r3, r2
    f966:	08db      	lsrs	r3, r3, #3
    f968:	4640      	mov	r0, r8
    f96a:	f363 148f 	bfi	r4, r3, #6, #10
    f96e:	f7f7 ff3b 	bl	77e8 <bt_addr_le_str_real>
    f972:	f7f5 f9c5 	bl	4d00 <log_strdup>
    f976:	4622      	mov	r2, r4
    f978:	4601      	mov	r1, r0
    f97a:	4827      	ldr	r0, [pc, #156]	; (fa18 <smp_ident_addr_info+0x150>)
    f97c:	f011 fb6a 	bl	21054 <log_1>
			return BT_SMP_ERR_UNSPECIFIED;
    f980:	2008      	movs	r0, #8
    f982:	e7d6      	b.n	f932 <smp_ident_addr_info+0x6a>
		if (conn->role == BT_HCI_ROLE_MASTER) {
    f984:	78e3      	ldrb	r3, [r4, #3]
    f986:	bbdb      	cbnz	r3, fa00 <smp_ident_addr_info+0x138>
			dst = &conn->le.resp_addr;
    f988:	f104 0382 	add.w	r3, r4, #130	; 0x82
	if (addr->type != BT_ADDR_LE_RANDOM) {
    f98c:	781a      	ldrb	r2, [r3, #0]
    f98e:	2a01      	cmp	r2, #1
    f990:	d11d      	bne.n	f9ce <smp_ident_addr_info+0x106>
		if (bt_addr_le_is_rpa(dst)) {
    f992:	799a      	ldrb	r2, [r3, #6]
    f994:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
    f998:	2a40      	cmp	r2, #64	; 0x40
    f99a:	d118      	bne.n	f9ce <smp_ident_addr_info+0x106>
    f99c:	f853 2f01 	ldr.w	r2, [r3, #1]!
    f9a0:	f8c6 2036 	str.w	r2, [r6, #54]	; 0x36
    f9a4:	889b      	ldrh	r3, [r3, #4]
    f9a6:	8773      	strh	r3, [r6, #58]	; 0x3a
	if (addr->type == BT_ADDR_LE_PUBLIC) {
    f9a8:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
    f9ac:	b17b      	cbz	r3, f9ce <smp_ident_addr_info+0x106>
			if (!bt_addr_le_is_identity(&conn->le.dst)) {
    f9ae:	f894 307a 	ldrb.w	r3, [r4, #122]	; 0x7a
    f9b2:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    f9b6:	2bc0      	cmp	r3, #192	; 0xc0
    f9b8:	d009      	beq.n	f9ce <smp_ident_addr_info+0x106>
				bt_addr_le_copy(&keys->addr, &req->addr);
    f9ba:	4639      	mov	r1, r7
    f9bc:	1c70      	adds	r0, r6, #1
    f9be:	f013 ffa9 	bl	23914 <bt_addr_le_copy>
				bt_addr_le_copy(&conn->le.dst, &req->addr);
    f9c2:	4640      	mov	r0, r8
    f9c4:	f013 ffa6 	bl	23914 <bt_addr_le_copy>
				bt_conn_identity_resolved(conn);
    f9c8:	4620      	mov	r0, r4
    f9ca:	f7fa ff69 	bl	a8a0 <bt_conn_identity_resolved>
		bt_id_add(keys);
    f9ce:	4630      	mov	r0, r6
    f9d0:	f7f9 fc14 	bl	91fc <bt_id_add>
	smp->remote_dist &= ~BT_SMP_DIST_ID_KEY;
    f9d4:	f895 3181 	ldrb.w	r3, [r5, #385]	; 0x181
    f9d8:	f023 0202 	bic.w	r2, r3, #2
	if (smp->remote_dist & BT_SMP_DIST_SIGN) {
    f9dc:	075b      	lsls	r3, r3, #29
	smp->remote_dist &= ~BT_SMP_DIST_ID_KEY;
    f9de:	f885 2181 	strb.w	r2, [r5, #385]	; 0x181
	if (smp->remote_dist & BT_SMP_DIST_SIGN) {
    f9e2:	d504      	bpl.n	f9ee <smp_ident_addr_info+0x126>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
    f9e4:	210a      	movs	r1, #10
    f9e6:	f105 0098 	add.w	r0, r5, #152	; 0x98
    f9ea:	f013 ff2a 	bl	23842 <atomic_set_bit>
	if (!smp->local_dist && !smp->remote_dist) {
    f9ee:	f8b5 4180 	ldrh.w	r4, [r5, #384]	; 0x180
    f9f2:	b91c      	cbnz	r4, f9fc <smp_ident_addr_info+0x134>
		smp_pairing_complete(smp, 0);
    f9f4:	4621      	mov	r1, r4
    f9f6:	4628      	mov	r0, r5
    f9f8:	f7ff fba4 	bl	f144 <smp_pairing_complete>
	return 0;
    f9fc:	2000      	movs	r0, #0
    f9fe:	e798      	b.n	f932 <smp_ident_addr_info+0x6a>
			dst = &conn->le.init_addr;
    fa00:	f104 037b 	add.w	r3, r4, #123	; 0x7b
    fa04:	e7c2      	b.n	f98c <smp_ident_addr_info+0xc4>
    fa06:	bf00      	nop
    fa08:	00028640 	.word	0x00028640
    fa0c:	00028540 	.word	0x00028540
    fa10:	00063f9a 	.word	0x00063f9a
    fa14:	00063eb1 	.word	0x00063eb1
    fa18:	00063fae 	.word	0x00063fae

0000fa1c <smp_pairing_random>:
{
    fa1c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    fa20:	688b      	ldr	r3, [r1, #8]
	memcpy(smp->rrnd, req->val, sizeof(smp->rrnd));
    fa22:	f100 08cf 	add.w	r8, r0, #207	; 0xcf
{
    fa26:	b09c      	sub	sp, #112	; 0x70
    fa28:	4604      	mov	r4, r0
    fa2a:	4642      	mov	r2, r8
    fa2c:	f103 0110 	add.w	r1, r3, #16
    fa30:	f853 0b04 	ldr.w	r0, [r3], #4
    fa34:	f842 0b04 	str.w	r0, [r2], #4
    fa38:	428b      	cmp	r3, r1
    fa3a:	d1f9      	bne.n	fa30 <smp_pairing_random+0x14>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    fa3c:	f104 079c 	add.w	r7, r4, #156	; 0x9c
    fa40:	2105      	movs	r1, #5
    fa42:	4638      	mov	r0, r7
    fa44:	f013 ff0c 	bl	23860 <atomic_test_bit>
    fa48:	2800      	cmp	r0, #0
    fa4a:	d143      	bne.n	fad4 <smp_pairing_random+0xb8>
	struct bt_conn *conn = smp->chan.chan.conn;
    fa4c:	4625      	mov	r5, r4
	err = smp_c1(smp->tk, smp->rrnd, smp->preq, smp->prsp,
    fa4e:	ae08      	add	r6, sp, #32
	struct bt_conn *conn = smp->chan.chan.conn;
    fa50:	f855 3bdf 	ldr.w	r3, [r5], #223
	err = smp_c1(smp->tk, smp->rrnd, smp->preq, smp->prsp,
    fa54:	9602      	str	r6, [sp, #8]
		     &conn->le.init_addr, &conn->le.resp_addr, tmp);
    fa56:	f103 0282 	add.w	r2, r3, #130	; 0x82
    fa5a:	337b      	adds	r3, #123	; 0x7b
	err = smp_c1(smp->tk, smp->rrnd, smp->preq, smp->prsp,
    fa5c:	9201      	str	r2, [sp, #4]
    fa5e:	9300      	str	r3, [sp, #0]
    fa60:	f104 02a1 	add.w	r2, r4, #161	; 0xa1
    fa64:	f104 03a8 	add.w	r3, r4, #168	; 0xa8
    fa68:	4641      	mov	r1, r8
    fa6a:	4628      	mov	r0, r5
    fa6c:	f014 f8d3 	bl	23c16 <smp_c1>
	if (err) {
    fa70:	b108      	cbz	r0, fa76 <smp_pairing_random+0x5a>
		return BT_SMP_ERR_UNSPECIFIED;
    fa72:	2508      	movs	r5, #8
    fa74:	e098      	b.n	fba8 <smp_pairing_random+0x18c>
	if (memcmp(smp->pcnf, tmp, sizeof(smp->pcnf))) {
    fa76:	2210      	movs	r2, #16
    fa78:	4631      	mov	r1, r6
    fa7a:	f104 00af 	add.w	r0, r4, #175	; 0xaf
    fa7e:	f7f2 f8a7 	bl	1bd0 <memcmp>
    fa82:	2800      	cmp	r0, #0
    fa84:	f040 808f 	bne.w	fba6 <smp_pairing_random+0x18a>
	memcpy(out + 8, r1, 8);
    fa88:	4622      	mov	r2, r4
	memcpy(out, r2, 8);
    fa8a:	f8d8 0000 	ldr.w	r0, [r8]
    fa8e:	f8d8 1004 	ldr.w	r1, [r8, #4]
    fa92:	4633      	mov	r3, r6
    fa94:	c303      	stmia	r3!, {r0, r1}
	memcpy(out + 8, r1, 8);
    fa96:	f852 0fbf 	ldr.w	r0, [r2, #191]!
    fa9a:	6851      	ldr	r1, [r2, #4]
    fa9c:	ab0a      	add	r3, sp, #40	; 0x28
    fa9e:	c303      	stmia	r3!, {r0, r1}
	return bt_encrypt_le(k, out, out);
    faa0:	4632      	mov	r2, r6
    faa2:	4631      	mov	r1, r6
    faa4:	4628      	mov	r0, r5
    faa6:	f014 fca8 	bl	243fa <bt_encrypt_le>
		if (err) {
    faaa:	2800      	cmp	r0, #0
    faac:	d1e1      	bne.n	fa72 <smp_pairing_random+0x56>
    faae:	aa0c      	add	r2, sp, #48	; 0x30
    fab0:	4633      	mov	r3, r6
    fab2:	cb03      	ldmia	r3!, {r0, r1}
    fab4:	4293      	cmp	r3, r2
    fab6:	6028      	str	r0, [r5, #0]
    fab8:	6069      	str	r1, [r5, #4]
    faba:	461e      	mov	r6, r3
    fabc:	f105 0508 	add.w	r5, r5, #8
    fac0:	d1f6      	bne.n	fab0 <smp_pairing_random+0x94>
		atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
    fac2:	2101      	movs	r1, #1
	atomic_set_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT);
    fac4:	4638      	mov	r0, r7
    fac6:	f013 febc 	bl	23842 <atomic_set_bit>
	return smp_send_pairing_random(smp);
    faca:	4620      	mov	r0, r4
    facc:	f013 ffde 	bl	23a8c <smp_send_pairing_random>
    fad0:	4605      	mov	r5, r0
    fad2:	e069      	b.n	fba8 <smp_pairing_random+0x18c>
	switch (smp->method) {
    fad4:	f894 30a0 	ldrb.w	r3, [r4, #160]	; 0xa0
    fad8:	2b05      	cmp	r3, #5
    fada:	d8ca      	bhi.n	fa72 <smp_pairing_random+0x56>
    fadc:	a201      	add	r2, pc, #4	; (adr r2, fae4 <smp_pairing_random+0xc8>)
    fade:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    fae2:	bf00      	nop
    fae4:	0000fb61 	.word	0x0000fb61
    fae8:	0000fb6f 	.word	0x0000fb6f
    faec:	0000fb6f 	.word	0x0000fb6f
    faf0:	0000fafd 	.word	0x0000fafd
    faf4:	0000fa73 	.word	0x0000fa73
    faf8:	0000fbfb 	.word	0x0000fbfb
		if (smp_g2(smp->pkey, sc_public_key, smp->rrnd, smp->prnd,
    fafc:	4b58      	ldr	r3, [pc, #352]	; (fc60 <smp_pairing_random+0x244>)
	sys_memcpy_swap(m, u, 32);
    fafe:	2220      	movs	r2, #32
		if (smp_g2(smp->pkey, sc_public_key, smp->rrnd, smp->prnd,
    fb00:	681d      	ldr	r5, [r3, #0]
	sys_memcpy_swap(m, u, 32);
    fb02:	eb0d 0002 	add.w	r0, sp, r2
    fb06:	f104 01ef 	add.w	r1, r4, #239	; 0xef
    fb0a:	f013 fe81 	bl	23810 <sys_memcpy_swap>
	sys_memcpy_swap(m + 32, v, 32);
    fb0e:	2220      	movs	r2, #32
    fb10:	4629      	mov	r1, r5
    fb12:	a810      	add	r0, sp, #64	; 0x40
    fb14:	f013 fe7c 	bl	23810 <sys_memcpy_swap>
	sys_memcpy_swap(m + 64, y, 16);
    fb18:	2210      	movs	r2, #16
    fb1a:	f104 01bf 	add.w	r1, r4, #191	; 0xbf
    fb1e:	a818      	add	r0, sp, #96	; 0x60
    fb20:	f013 fe76 	bl	23810 <sys_memcpy_swap>
	sys_memcpy_swap(xs, x, 16);
    fb24:	2210      	movs	r2, #16
    fb26:	eb0d 0002 	add.w	r0, sp, r2
    fb2a:	4641      	mov	r1, r8
    fb2c:	f013 fe70 	bl	23810 <sys_memcpy_swap>
	err = bt_smp_aes_cmac(xs, m, sizeof(m), xs);
    fb30:	ab04      	add	r3, sp, #16
    fb32:	2250      	movs	r2, #80	; 0x50
    fb34:	a908      	add	r1, sp, #32
    fb36:	4618      	mov	r0, r3
    fb38:	f013 fe9b 	bl	23872 <bt_smp_aes_cmac>
	if (err) {
    fb3c:	2800      	cmp	r0, #0
    fb3e:	d198      	bne.n	fa72 <smp_pairing_random+0x56>
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
    fb40:	2109      	movs	r1, #9
    fb42:	4638      	mov	r0, r7
    fb44:	9d07      	ldr	r5, [sp, #28]
    fb46:	f013 fe7c 	bl	23842 <atomic_set_bit>
		bt_auth->passkey_confirm(smp->chan.chan.conn, passkey);
    fb4a:	4a46      	ldr	r2, [pc, #280]	; (fc64 <smp_pairing_random+0x248>)
	*passkey = sys_be32_to_cpu(*passkey) % 1000000;
    fb4c:	4b46      	ldr	r3, [pc, #280]	; (fc68 <smp_pairing_random+0x24c>)
		bt_auth->passkey_confirm(smp->chan.chan.conn, passkey);
    fb4e:	6812      	ldr	r2, [r2, #0]
    fb50:	6820      	ldr	r0, [r4, #0]
    fb52:	6892      	ldr	r2, [r2, #8]
    fb54:	ba2d      	rev	r5, r5
	*passkey = sys_be32_to_cpu(*passkey) % 1000000;
    fb56:	fbb5 f1f3 	udiv	r1, r5, r3
		bt_auth->passkey_confirm(smp->chan.chan.conn, passkey);
    fb5a:	fb03 5111 	mls	r1, r3, r1, r5
    fb5e:	4790      	blx	r2
	atomic_set_bit(&smp->allowed_cmds, BT_SMP_DHKEY_CHECK);
    fb60:	210d      	movs	r1, #13
    fb62:	f104 0098 	add.w	r0, r4, #152	; 0x98
    fb66:	f013 fe6c 	bl	23842 <atomic_set_bit>
	atomic_set_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT);
    fb6a:	210f      	movs	r1, #15
    fb6c:	e7aa      	b.n	fac4 <smp_pairing_random+0xa8>
		r = (smp->passkey >> smp->passkey_round) & 0x01;
    fb6e:	f894 2174 	ldrb.w	r2, [r4, #372]	; 0x174
    fb72:	f8d4 3170 	ldr.w	r3, [r4, #368]	; 0x170
	if (smp_f4(smp->pkey, sc_public_key, smp->rrnd, r, cfm)) {
    fb76:	493a      	ldr	r1, [pc, #232]	; (fc60 <smp_pairing_random+0x244>)
		r = (smp->passkey >> smp->passkey_round) & 0x01;
    fb78:	40d3      	lsrs	r3, r2
	if (smp_f4(smp->pkey, sc_public_key, smp->rrnd, r, cfm)) {
    fb7a:	ad08      	add	r5, sp, #32
		r = (smp->passkey >> smp->passkey_round) & 0x01;
    fb7c:	f003 0301 	and.w	r3, r3, #1
	if (smp_f4(smp->pkey, sc_public_key, smp->rrnd, r, cfm)) {
    fb80:	9500      	str	r5, [sp, #0]
    fb82:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    fb86:	4642      	mov	r2, r8
    fb88:	6809      	ldr	r1, [r1, #0]
    fb8a:	f104 00ef 	add.w	r0, r4, #239	; 0xef
    fb8e:	f013 fe8c 	bl	238aa <smp_f4>
    fb92:	2800      	cmp	r0, #0
    fb94:	f47f af6d 	bne.w	fa72 <smp_pairing_random+0x56>
	if (memcmp(smp->pcnf, cfm, 16)) {
    fb98:	2210      	movs	r2, #16
    fb9a:	4629      	mov	r1, r5
    fb9c:	f104 00af 	add.w	r0, r4, #175	; 0xaf
    fba0:	f7f2 f816 	bl	1bd0 <memcmp>
    fba4:	b120      	cbz	r0, fbb0 <smp_pairing_random+0x194>
		return BT_SMP_ERR_CONFIRM_FAILED;
    fba6:	2504      	movs	r5, #4
}
    fba8:	4628      	mov	r0, r5
    fbaa:	b01c      	add	sp, #112	; 0x70
    fbac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		atomic_set_bit(&smp->allowed_cmds,
    fbb0:	f104 0698 	add.w	r6, r4, #152	; 0x98
    fbb4:	2103      	movs	r1, #3
    fbb6:	4630      	mov	r0, r6
    fbb8:	f013 fe43 	bl	23842 <atomic_set_bit>
		err = smp_send_pairing_random(smp);
    fbbc:	4620      	mov	r0, r4
    fbbe:	f013 ff65 	bl	23a8c <smp_send_pairing_random>
		if (err) {
    fbc2:	4605      	mov	r5, r0
    fbc4:	2800      	cmp	r0, #0
    fbc6:	d1ef      	bne.n	fba8 <smp_pairing_random+0x18c>
		smp->passkey_round++;
    fbc8:	f894 3174 	ldrb.w	r3, [r4, #372]	; 0x174
    fbcc:	3301      	adds	r3, #1
    fbce:	b2db      	uxtb	r3, r3
		if (smp->passkey_round == 20U) {
    fbd0:	2b14      	cmp	r3, #20
		smp->passkey_round++;
    fbd2:	f884 3174 	strb.w	r3, [r4, #372]	; 0x174
		if (smp->passkey_round == 20U) {
    fbd6:	d108      	bne.n	fbea <smp_pairing_random+0x1ce>
			atomic_set_bit(&smp->allowed_cmds, BT_SMP_DHKEY_CHECK);
    fbd8:	4630      	mov	r0, r6
    fbda:	210d      	movs	r1, #13
    fbdc:	f013 fe31 	bl	23842 <atomic_set_bit>
			atomic_set_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT);
    fbe0:	210f      	movs	r1, #15
    fbe2:	4638      	mov	r0, r7
    fbe4:	f013 fe2d 	bl	23842 <atomic_set_bit>
			return 0;
    fbe8:	e7de      	b.n	fba8 <smp_pairing_random+0x18c>
		if (bt_rand(smp->prnd, 16)) {
    fbea:	2110      	movs	r1, #16
    fbec:	f104 00bf 	add.w	r0, r4, #191	; 0xbf
    fbf0:	f002 fcc4 	bl	1257c <bt_rand>
    fbf4:	2800      	cmp	r0, #0
    fbf6:	d0d7      	beq.n	fba8 <smp_pairing_random+0x18c>
    fbf8:	e73b      	b.n	fa72 <smp_pairing_random+0x56>
		if (bt_rand(smp->prnd, 16)) {
    fbfa:	2110      	movs	r1, #16
    fbfc:	f104 00bf 	add.w	r0, r4, #191	; 0xbf
    fc00:	f002 fcbc 	bl	1257c <bt_rand>
    fc04:	2800      	cmp	r0, #0
    fc06:	f47f af34 	bne.w	fa72 <smp_pairing_random+0x56>
		if (bt_auth && bt_auth->oob_data_request) {
    fc0a:	4e16      	ldr	r6, [pc, #88]	; (fc64 <smp_pairing_random+0x248>)
    fc0c:	6833      	ldr	r3, [r6, #0]
    fc0e:	b303      	cbz	r3, fc52 <smp_pairing_random+0x236>
    fc10:	68db      	ldr	r3, [r3, #12]
    fc12:	b1f3      	cbz	r3, fc52 <smp_pairing_random+0x236>
			struct bt_conn_oob_info info = {
    fc14:	4b15      	ldr	r3, [pc, #84]	; (fc6c <smp_pairing_random+0x250>)
		oob_config = req_oob_present ? BT_CONN_OOB_LOCAL_ONLY :
    fc16:	f894 20a3 	ldrb.w	r2, [r4, #163]	; 0xa3
			struct bt_conn_oob_info info = {
    fc1a:	881b      	ldrh	r3, [r3, #0]
    fc1c:	f8ad 3020 	strh.w	r3, [sp, #32]
	return ((rsp->oob_flag & BT_SMP_OOB_DATA_MASK) == BT_SMP_OOB_PRESENT);
    fc20:	f894 30aa 	ldrb.w	r3, [r4, #170]	; 0xaa
		oob_config = req_oob_present ? BT_CONN_OOB_LOCAL_ONLY :
    fc24:	07d2      	lsls	r2, r2, #31
    fc26:	f003 0301 	and.w	r3, r3, #1
    fc2a:	d414      	bmi.n	fc56 <smp_pairing_random+0x23a>
    fc2c:	2b00      	cmp	r3, #0
    fc2e:	bf14      	ite	ne
    fc30:	2001      	movne	r0, #1
    fc32:	2003      	moveq	r0, #3
			smp->oobd_local = NULL;
    fc34:	2500      	movs	r5, #0
	info->lesc.oob_config = oob_config;
    fc36:	f88d 0021 	strb.w	r0, [sp, #33]	; 0x21
			smp->oobd_remote = NULL;
    fc3a:	e9c4 555e 	strd	r5, r5, [r4, #376]	; 0x178
			atomic_set_bit(smp->flags, SMP_FLAG_OOB_PENDING);
    fc3e:	4638      	mov	r0, r7
    fc40:	210b      	movs	r1, #11
    fc42:	f013 fdfe 	bl	23842 <atomic_set_bit>
			bt_auth->oob_data_request(smp->chan.chan.conn, &info);
    fc46:	6833      	ldr	r3, [r6, #0]
    fc48:	6820      	ldr	r0, [r4, #0]
    fc4a:	68db      	ldr	r3, [r3, #12]
    fc4c:	a908      	add	r1, sp, #32
    fc4e:	4798      	blx	r3
			return 0;
    fc50:	e7aa      	b.n	fba8 <smp_pairing_random+0x18c>
			return BT_SMP_ERR_OOB_NOT_AVAIL;
    fc52:	2502      	movs	r5, #2
    fc54:	e7a8      	b.n	fba8 <smp_pairing_random+0x18c>
				     BT_CONN_OOB_BOTH_PEERS :
    fc56:	2b00      	cmp	r3, #0
    fc58:	bf18      	it	ne
    fc5a:	2002      	movne	r0, #2
    fc5c:	e7ea      	b.n	fc34 <smp_pairing_random+0x218>
    fc5e:	bf00      	nop
    fc60:	20000788 	.word	0x20000788
    fc64:	200003a0 	.word	0x200003a0
    fc68:	000f4240 	.word	0x000f4240
    fc6c:	0002873c 	.word	0x0002873c

0000fc70 <bt_smp_pkey_ready>:
{
    fc70:	b508      	push	{r3, lr}
	sc_public_key = pkey;
    fc72:	4b15      	ldr	r3, [pc, #84]	; (fcc8 <bt_smp_pkey_ready+0x58>)
    fc74:	6018      	str	r0, [r3, #0]
	if (!pkey) {
    fc76:	b978      	cbnz	r0, fc98 <bt_smp_pkey_ready+0x28>
		BT_WARN("Public key not available");
    fc78:	2302      	movs	r3, #2
    fc7a:	f04f 0100 	mov.w	r1, #0
    fc7e:	f363 0107 	bfi	r1, r3, #0, #8
    fc82:	4a12      	ldr	r2, [pc, #72]	; (fccc <bt_smp_pkey_ready+0x5c>)
    fc84:	4b12      	ldr	r3, [pc, #72]	; (fcd0 <bt_smp_pkey_ready+0x60>)
    fc86:	4813      	ldr	r0, [pc, #76]	; (fcd4 <bt_smp_pkey_ready+0x64>)
    fc88:	1a9b      	subs	r3, r3, r2
    fc8a:	08db      	lsrs	r3, r3, #3
    fc8c:	f363 118f 	bfi	r1, r3, #6, #10
}
    fc90:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		BT_WARN("Public key not available");
    fc94:	f011 b9d1 	b.w	2103a <log_0>
    fc98:	480f      	ldr	r0, [pc, #60]	; (fcd8 <bt_smp_pkey_ready+0x68>)
    fc9a:	f00f f86f 	bl	1ed7c <z_impl_k_sem_give>
		if (!atomic_test_bit(smp->flags, SMP_FLAG_PKEY_SEND)) {
    fc9e:	2106      	movs	r1, #6
    fca0:	480e      	ldr	r0, [pc, #56]	; (fcdc <bt_smp_pkey_ready+0x6c>)
    fca2:	f013 fddd 	bl	23860 <atomic_test_bit>
    fca6:	b168      	cbz	r0, fcc4 <bt_smp_pkey_ready+0x54>
	err = sc_send_public_key(smp);
    fca8:	480d      	ldr	r0, [pc, #52]	; (fce0 <bt_smp_pkey_ready+0x70>)
    fcaa:	f7ff f9bb 	bl	f024 <sc_send_public_key>
	if (err) {
    fcae:	b918      	cbnz	r0, fcb8 <bt_smp_pkey_ready+0x48>
    fcb0:	480b      	ldr	r0, [pc, #44]	; (fce0 <bt_smp_pkey_ready+0x70>)
    fcb2:	f7fe fe89 	bl	e9c8 <smp_public_key_slave.part.14>
		if (err) {
    fcb6:	b128      	cbz	r0, fcc4 <bt_smp_pkey_ready+0x54>
			smp_error(smp, err);
    fcb8:	4601      	mov	r1, r0
}
    fcba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
			smp_error(smp, err);
    fcbe:	4808      	ldr	r0, [pc, #32]	; (fce0 <bt_smp_pkey_ready+0x70>)
    fcc0:	f013 bf64 	b.w	23b8c <smp_error>
}
    fcc4:	bd08      	pop	{r3, pc}
    fcc6:	bf00      	nop
    fcc8:	20000788 	.word	0x20000788
    fccc:	00028540 	.word	0x00028540
    fcd0:	00028640 	.word	0x00028640
    fcd4:	00063ddc 	.word	0x00063ddc
    fcd8:	2000ef5c 	.word	0x2000ef5c
    fcdc:	20000680 	.word	0x20000680
    fce0:	200005e4 	.word	0x200005e4

0000fce4 <bt_smp_sign_verify>:
{
    fce4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    fce6:	460c      	mov	r4, r1
	return buf->data + buf->len;
    fce8:	8989      	ldrh	r1, [r1, #12]
	memcpy(sig, net_buf_tail(buf) - sizeof(sig), sizeof(sig));
    fcea:	68a3      	ldr	r3, [r4, #8]
    fcec:	440b      	add	r3, r1
{
    fcee:	4605      	mov	r5, r0
	memcpy(sig, net_buf_tail(buf) - sizeof(sig), sizeof(sig));
    fcf0:	f853 0d0c 	ldr.w	r0, [r3, #-12]!
    fcf4:	6859      	ldr	r1, [r3, #4]
    fcf6:	aa01      	add	r2, sp, #4
    fcf8:	c203      	stmia	r2!, {r0, r1}
	keys = bt_keys_find(BT_KEYS_REMOTE_CSRK, conn->id, &conn->le.dst);
    fcfa:	f105 0674 	add.w	r6, r5, #116	; 0x74
	memcpy(sig, net_buf_tail(buf) - sizeof(sig), sizeof(sig));
    fcfe:	6898      	ldr	r0, [r3, #8]
    fd00:	6010      	str	r0, [r2, #0]
	keys = bt_keys_find(BT_KEYS_REMOTE_CSRK, conn->id, &conn->le.dst);
    fd02:	7a29      	ldrb	r1, [r5, #8]
    fd04:	4632      	mov	r2, r6
    fd06:	2010      	movs	r0, #16
    fd08:	f000 faa2 	bl	10250 <bt_keys_find>
	if (!keys) {
    fd0c:	4605      	mov	r5, r0
    fd0e:	b9c0      	cbnz	r0, fd42 <bt_smp_sign_verify+0x5e>
		BT_ERR("Unable to find Remote CSRK for %s",
    fd10:	2301      	movs	r3, #1
    fd12:	f04f 0400 	mov.w	r4, #0
    fd16:	4a30      	ldr	r2, [pc, #192]	; (fdd8 <bt_smp_sign_verify+0xf4>)
    fd18:	f363 0407 	bfi	r4, r3, #0, #8
    fd1c:	4b2f      	ldr	r3, [pc, #188]	; (fddc <bt_smp_sign_verify+0xf8>)
    fd1e:	1a9b      	subs	r3, r3, r2
    fd20:	08db      	lsrs	r3, r3, #3
    fd22:	4630      	mov	r0, r6
    fd24:	f363 148f 	bfi	r4, r3, #6, #10
    fd28:	f7f7 fd5e 	bl	77e8 <bt_addr_le_str_real>
    fd2c:	f7f4 ffe8 	bl	4d00 <log_strdup>
    fd30:	4622      	mov	r2, r4
    fd32:	4601      	mov	r1, r0
    fd34:	482a      	ldr	r0, [pc, #168]	; (fde0 <bt_smp_sign_verify+0xfc>)
    fd36:	f011 f98d 	bl	21054 <log_1>
		return -ENOENT;
    fd3a:	f06f 0001 	mvn.w	r0, #1
}
    fd3e:	b004      	add	sp, #16
    fd40:	bd70      	pop	{r4, r5, r6, pc}
    fd42:	89a1      	ldrh	r1, [r4, #12]
    fd44:	68a3      	ldr	r3, [r4, #8]
	cnt = sys_cpu_to_le32(keys->remote_csrk.cnt);
    fd46:	6e02      	ldr	r2, [r0, #96]	; 0x60
    fd48:	440b      	add	r3, r1
	err = smp_sign_buf(keys->remote_csrk.val, buf->data,
    fd4a:	3050      	adds	r0, #80	; 0x50
    fd4c:	f843 2c0c 	str.w	r2, [r3, #-12]
    fd50:	89a2      	ldrh	r2, [r4, #12]
    fd52:	68a1      	ldr	r1, [r4, #8]
    fd54:	3a0c      	subs	r2, #12
    fd56:	b292      	uxth	r2, r2
    fd58:	f7fe fc9c 	bl	e694 <smp_sign_buf>
	if (err) {
    fd5c:	b1b8      	cbz	r0, fd8e <bt_smp_sign_verify+0xaa>
		BT_ERR("Unable to create signature for %s",
    fd5e:	2301      	movs	r3, #1
    fd60:	f04f 0400 	mov.w	r4, #0
    fd64:	4a1c      	ldr	r2, [pc, #112]	; (fdd8 <bt_smp_sign_verify+0xf4>)
    fd66:	f363 0407 	bfi	r4, r3, #0, #8
    fd6a:	4b1c      	ldr	r3, [pc, #112]	; (fddc <bt_smp_sign_verify+0xf8>)
    fd6c:	1a9b      	subs	r3, r3, r2
    fd6e:	08db      	lsrs	r3, r3, #3
    fd70:	4630      	mov	r0, r6
    fd72:	f363 148f 	bfi	r4, r3, #6, #10
    fd76:	f7f7 fd37 	bl	77e8 <bt_addr_le_str_real>
    fd7a:	f7f4 ffc1 	bl	4d00 <log_strdup>
    fd7e:	4622      	mov	r2, r4
    fd80:	4601      	mov	r1, r0
    fd82:	4818      	ldr	r0, [pc, #96]	; (fde4 <bt_smp_sign_verify+0x100>)
    fd84:	f011 f966 	bl	21054 <log_1>
		return -EIO;
    fd88:	f06f 0004 	mvn.w	r0, #4
    fd8c:	e7d7      	b.n	fd3e <bt_smp_sign_verify+0x5a>
    fd8e:	89a3      	ldrh	r3, [r4, #12]
	if (memcmp(sig, net_buf_tail(buf) - sizeof(sig), sizeof(sig))) {
    fd90:	68a1      	ldr	r1, [r4, #8]
    fd92:	3b0c      	subs	r3, #12
    fd94:	220c      	movs	r2, #12
    fd96:	4419      	add	r1, r3
    fd98:	a801      	add	r0, sp, #4
    fd9a:	f7f1 ff19 	bl	1bd0 <memcmp>
    fd9e:	b1b8      	cbz	r0, fdd0 <bt_smp_sign_verify+0xec>
		BT_ERR("Unable to verify signature for %s",
    fda0:	2301      	movs	r3, #1
    fda2:	f04f 0400 	mov.w	r4, #0
    fda6:	4a0c      	ldr	r2, [pc, #48]	; (fdd8 <bt_smp_sign_verify+0xf4>)
    fda8:	f363 0407 	bfi	r4, r3, #0, #8
    fdac:	4b0b      	ldr	r3, [pc, #44]	; (fddc <bt_smp_sign_verify+0xf8>)
    fdae:	1a9b      	subs	r3, r3, r2
    fdb0:	08db      	lsrs	r3, r3, #3
    fdb2:	4630      	mov	r0, r6
    fdb4:	f363 148f 	bfi	r4, r3, #6, #10
    fdb8:	f7f7 fd16 	bl	77e8 <bt_addr_le_str_real>
    fdbc:	f7f4 ffa0 	bl	4d00 <log_strdup>
    fdc0:	4622      	mov	r2, r4
    fdc2:	4601      	mov	r1, r0
    fdc4:	4808      	ldr	r0, [pc, #32]	; (fde8 <bt_smp_sign_verify+0x104>)
    fdc6:	f011 f945 	bl	21054 <log_1>
		return -EBADMSG;
    fdca:	f06f 004c 	mvn.w	r0, #76	; 0x4c
    fdce:	e7b6      	b.n	fd3e <bt_smp_sign_verify+0x5a>
	keys->remote_csrk.cnt++;
    fdd0:	6e2b      	ldr	r3, [r5, #96]	; 0x60
    fdd2:	3301      	adds	r3, #1
    fdd4:	662b      	str	r3, [r5, #96]	; 0x60
	return 0;
    fdd6:	e7b2      	b.n	fd3e <bt_smp_sign_verify+0x5a>
    fdd8:	00028540 	.word	0x00028540
    fddc:	00028640 	.word	0x00028640
    fde0:	00063e97 	.word	0x00063e97
    fde4:	00063eb9 	.word	0x00063eb9
    fde8:	00063edb 	.word	0x00063edb

0000fdec <bt_smp_sign>:
{
    fdec:	b570      	push	{r4, r5, r6, lr}
	keys = bt_keys_find(BT_KEYS_LOCAL_CSRK, conn->id, &conn->le.dst);
    fdee:	f100 0674 	add.w	r6, r0, #116	; 0x74
{
    fdf2:	460d      	mov	r5, r1
	keys = bt_keys_find(BT_KEYS_LOCAL_CSRK, conn->id, &conn->le.dst);
    fdf4:	4632      	mov	r2, r6
    fdf6:	7a01      	ldrb	r1, [r0, #8]
    fdf8:	2008      	movs	r0, #8
    fdfa:	f000 fa29 	bl	10250 <bt_keys_find>
	if (!keys) {
    fdfe:	4604      	mov	r4, r0
    fe00:	b9a8      	cbnz	r0, fe2e <bt_smp_sign+0x42>
		BT_ERR("Unable to find local CSRK for %s",
    fe02:	2301      	movs	r3, #1
    fe04:	4a22      	ldr	r2, [pc, #136]	; (fe90 <bt_smp_sign+0xa4>)
    fe06:	f363 0407 	bfi	r4, r3, #0, #8
    fe0a:	4b22      	ldr	r3, [pc, #136]	; (fe94 <bt_smp_sign+0xa8>)
    fe0c:	1a9b      	subs	r3, r3, r2
    fe0e:	08db      	lsrs	r3, r3, #3
    fe10:	4630      	mov	r0, r6
    fe12:	f363 148f 	bfi	r4, r3, #6, #10
    fe16:	f7f7 fce7 	bl	77e8 <bt_addr_le_str_real>
    fe1a:	f7f4 ff71 	bl	4d00 <log_strdup>
    fe1e:	4622      	mov	r2, r4
    fe20:	4601      	mov	r1, r0
    fe22:	481d      	ldr	r0, [pc, #116]	; (fe98 <bt_smp_sign+0xac>)
    fe24:	f011 f916 	bl	21054 <log_1>
		return -ENOENT;
    fe28:	f06f 0001 	mvn.w	r0, #1
}
    fe2c:	bd70      	pop	{r4, r5, r6, pc}
	net_buf_add(buf, 12);
    fe2e:	210c      	movs	r1, #12
    fe30:	f105 0008 	add.w	r0, r5, #8
    fe34:	f014 ffd0 	bl	24dd8 <net_buf_simple_add>
    fe38:	89a9      	ldrh	r1, [r5, #12]
    fe3a:	68ab      	ldr	r3, [r5, #8]
	cnt = sys_cpu_to_le32(keys->local_csrk.cnt);
    fe3c:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
    fe3e:	440b      	add	r3, r1
	err = smp_sign_buf(keys->local_csrk.val, buf->data, buf->len - 12);
    fe40:	f104 003c 	add.w	r0, r4, #60	; 0x3c
    fe44:	f843 2c0c 	str.w	r2, [r3, #-12]
    fe48:	89aa      	ldrh	r2, [r5, #12]
    fe4a:	68a9      	ldr	r1, [r5, #8]
    fe4c:	3a0c      	subs	r2, #12
    fe4e:	b292      	uxth	r2, r2
    fe50:	f7fe fc20 	bl	e694 <smp_sign_buf>
	if (err) {
    fe54:	b1b8      	cbz	r0, fe86 <bt_smp_sign+0x9a>
		BT_ERR("Unable to create signature for %s",
    fe56:	2301      	movs	r3, #1
    fe58:	f04f 0400 	mov.w	r4, #0
    fe5c:	4a0c      	ldr	r2, [pc, #48]	; (fe90 <bt_smp_sign+0xa4>)
    fe5e:	f363 0407 	bfi	r4, r3, #0, #8
    fe62:	4b0c      	ldr	r3, [pc, #48]	; (fe94 <bt_smp_sign+0xa8>)
    fe64:	1a9b      	subs	r3, r3, r2
    fe66:	08db      	lsrs	r3, r3, #3
    fe68:	4630      	mov	r0, r6
    fe6a:	f363 148f 	bfi	r4, r3, #6, #10
    fe6e:	f7f7 fcbb 	bl	77e8 <bt_addr_le_str_real>
    fe72:	f7f4 ff45 	bl	4d00 <log_strdup>
    fe76:	4622      	mov	r2, r4
    fe78:	4601      	mov	r1, r0
    fe7a:	4808      	ldr	r0, [pc, #32]	; (fe9c <bt_smp_sign+0xb0>)
    fe7c:	f011 f8ea 	bl	21054 <log_1>
		return -EIO;
    fe80:	f06f 0004 	mvn.w	r0, #4
    fe84:	e7d2      	b.n	fe2c <bt_smp_sign+0x40>
	keys->local_csrk.cnt++;
    fe86:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    fe88:	3301      	adds	r3, #1
    fe8a:	64e3      	str	r3, [r4, #76]	; 0x4c
	return 0;
    fe8c:	e7ce      	b.n	fe2c <bt_smp_sign+0x40>
    fe8e:	bf00      	nop
    fe90:	00028540 	.word	0x00028540
    fe94:	00028640 	.word	0x00028640
    fe98:	00063e76 	.word	0x00063e76
    fe9c:	00063eb9 	.word	0x00063eb9

0000fea0 <bt_smp_start_security>:
{
    fea0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	switch (conn->role) {
    fea4:	78c7      	ldrb	r7, [r0, #3]
    fea6:	2f01      	cmp	r7, #1
{
    fea8:	4604      	mov	r4, r0
	switch (conn->role) {
    feaa:	d005      	beq.n	feb8 <bt_smp_start_security+0x18>
		return -EINVAL;
    feac:	f06f 0715 	mvn.w	r7, #21
}
    feb0:	4638      	mov	r0, r7
    feb2:	b003      	add	sp, #12
    feb4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	smp = smp_chan_get(conn);
    feb8:	f7fe fcd0 	bl	e85c <smp_chan_get>
	if (!smp) {
    febc:	4605      	mov	r5, r0
    febe:	2800      	cmp	r0, #0
    fec0:	f000 80a2 	beq.w	10008 <__kernel_ram_size+0x8>
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
    fec4:	f100 069c 	add.w	r6, r0, #156	; 0x9c
    fec8:	2104      	movs	r1, #4
    feca:	4630      	mov	r0, r6
    fecc:	f013 fcc8 	bl	23860 <atomic_test_bit>
    fed0:	2800      	cmp	r0, #0
    fed2:	f040 809c 	bne.w	1000e <__kernel_ram_size+0xe>
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
    fed6:	2103      	movs	r1, #3
    fed8:	4630      	mov	r0, r6
    feda:	f013 fcc1 	bl	23860 <atomic_test_bit>
    fede:	b110      	cbz	r0, fee6 <bt_smp_start_security+0x46>
		return -EBUSY;
    fee0:	f06f 070f 	mvn.w	r7, #15
    fee4:	e7e4      	b.n	feb0 <bt_smp_start_security+0x10>
	if (atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
    fee6:	4639      	mov	r1, r7
    fee8:	4630      	mov	r0, r6
    feea:	f013 fcb9 	bl	23860 <atomic_test_bit>
    feee:	2800      	cmp	r0, #0
    fef0:	d1f6      	bne.n	fee0 <bt_smp_start_security+0x40>
	switch (conn->required_sec_level) {
    fef2:	7aa3      	ldrb	r3, [r4, #10]
    fef4:	3b01      	subs	r3, #1
    fef6:	2b03      	cmp	r3, #3
    fef8:	d813      	bhi.n	ff22 <bt_smp_start_security+0x82>
    fefa:	e8df f003 	tbb	[pc, r3]
    fefe:	3b3b      	.short	0x3b3b
    ff00:	4602      	.short	0x4602
		return get_io_capa() != BT_SMP_IO_NO_INPUT_OUTPUT ||
    ff02:	f7fe fba1 	bl	e648 <get_io_capa>
    ff06:	2803      	cmp	r0, #3
    ff08:	d107      	bne.n	ff1a <bt_smp_start_security+0x7a>
		       (bt_auth && bt_auth->oob_data_request && oobd_present);
    ff0a:	4b42      	ldr	r3, [pc, #264]	; (10014 <__kernel_ram_size+0x14>)
    ff0c:	681b      	ldr	r3, [r3, #0]
		return get_io_capa() != BT_SMP_IO_NO_INPUT_OUTPUT ||
    ff0e:	b12b      	cbz	r3, ff1c <bt_smp_start_security+0x7c>
		       (bt_auth && bt_auth->oob_data_request && oobd_present);
    ff10:	68db      	ldr	r3, [r3, #12]
    ff12:	b11b      	cbz	r3, ff1c <bt_smp_start_security+0x7c>
    ff14:	4b40      	ldr	r3, [pc, #256]	; (10018 <__kernel_ram_size+0x18>)
			 oobd_present)) &&
    ff16:	781b      	ldrb	r3, [r3, #0]
    ff18:	e000      	b.n	ff1c <bt_smp_start_security+0x7c>
		return get_io_capa() != BT_SMP_IO_NO_INPUT_OUTPUT ||
    ff1a:	2301      	movs	r3, #1
			 oobd_present)) &&
    ff1c:	f003 0301 	and.w	r3, r3, #1
	if (!(sec_level_reachable(conn) || smp_keys_check(conn))) {
    ff20:	bb43      	cbnz	r3, ff74 <bt_smp_start_security+0xd4>
	if (atomic_test_bit(conn->flags, BT_CONN_FORCE_PAIR)) {
    ff22:	210b      	movs	r1, #11
    ff24:	1d20      	adds	r0, r4, #4
    ff26:	f013 fc9b 	bl	23860 <atomic_test_bit>
    ff2a:	2800      	cmp	r0, #0
    ff2c:	d1be      	bne.n	feac <bt_smp_start_security+0xc>
	if (!conn->le.keys) {
    ff2e:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    ff32:	b983      	cbnz	r3, ff56 <bt_smp_start_security+0xb6>
						     conn->id, &conn->le.dst);
    ff34:	f104 0774 	add.w	r7, r4, #116	; 0x74
		conn->le.keys = bt_keys_find(BT_KEYS_LTK_P256,
    ff38:	463a      	mov	r2, r7
    ff3a:	7a21      	ldrb	r1, [r4, #8]
    ff3c:	2020      	movs	r0, #32
    ff3e:	f000 f987 	bl	10250 <bt_keys_find>
    ff42:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
		if (!conn->le.keys) {
    ff46:	b930      	cbnz	r0, ff56 <bt_smp_start_security+0xb6>
			conn->le.keys = bt_keys_find(BT_KEYS_LTK,
    ff48:	463a      	mov	r2, r7
    ff4a:	7a21      	ldrb	r1, [r4, #8]
    ff4c:	2004      	movs	r0, #4
    ff4e:	f000 f97f 	bl	10250 <bt_keys_find>
    ff52:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
	if (!conn->le.keys ||
    ff56:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    ff5a:	2b00      	cmp	r3, #0
    ff5c:	d0a6      	beq.n	feac <bt_smp_start_security+0xc>
    ff5e:	895a      	ldrh	r2, [r3, #10]
    ff60:	f002 0224 	and.w	r2, r2, #36	; 0x24
    ff64:	2a00      	cmp	r2, #0
    ff66:	d0a1      	beq.n	feac <bt_smp_start_security+0xc>
	if (conn->required_sec_level > BT_SECURITY_L2 &&
    ff68:	7aa2      	ldrb	r2, [r4, #10]
    ff6a:	2a02      	cmp	r2, #2
    ff6c:	d902      	bls.n	ff74 <bt_smp_start_security+0xd4>
    ff6e:	7a5b      	ldrb	r3, [r3, #9]
    ff70:	07db      	lsls	r3, r3, #31
    ff72:	d59b      	bpl.n	feac <bt_smp_start_security+0xc>
	if (!conn->le.keys) {
    ff74:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    ff78:	b1c3      	cbz	r3, ffac <bt_smp_start_security+0x10c>
	if (smp_init(smp) != 0) {
    ff7a:	4628      	mov	r0, r5
    ff7c:	f7fe fcb0 	bl	e8e0 <smp_init>
    ff80:	4607      	mov	r7, r0
    ff82:	b1f8      	cbz	r0, ffc4 <bt_smp_start_security+0x124>
		return -ENOBUFS;
    ff84:	f06f 0768 	mvn.w	r7, #104	; 0x68
    ff88:	e792      	b.n	feb0 <bt_smp_start_security+0x10>
		return (get_io_capa() != BT_SMP_IO_NO_INPUT_OUTPUT ||
    ff8a:	f7fe fb5d 	bl	e648 <get_io_capa>
			 oobd_present)) &&
    ff8e:	2803      	cmp	r0, #3
    ff90:	d10a      	bne.n	ffa8 <bt_smp_start_security+0x108>
			(bt_auth && bt_auth->oob_data_request &&
    ff92:	4b20      	ldr	r3, [pc, #128]	; (10014 <__kernel_ram_size+0x14>)
    ff94:	681b      	ldr	r3, [r3, #0]
		return (get_io_capa() != BT_SMP_IO_NO_INPUT_OUTPUT ||
    ff96:	2b00      	cmp	r3, #0
    ff98:	d0c0      	beq.n	ff1c <bt_smp_start_security+0x7c>
			(bt_auth && bt_auth->oob_data_request &&
    ff9a:	68db      	ldr	r3, [r3, #12]
    ff9c:	2b00      	cmp	r3, #0
    ff9e:	d0bd      	beq.n	ff1c <bt_smp_start_security+0x7c>
    ffa0:	4b1d      	ldr	r3, [pc, #116]	; (10018 <__kernel_ram_size+0x18>)
    ffa2:	781b      	ldrb	r3, [r3, #0]
    ffa4:	2b00      	cmp	r3, #0
    ffa6:	d0b9      	beq.n	ff1c <bt_smp_start_security+0x7c>
			 oobd_present)) &&
    ffa8:	4b1c      	ldr	r3, [pc, #112]	; (1001c <__kernel_ram_size+0x1c>)
    ffaa:	e7b4      	b.n	ff16 <bt_smp_start_security+0x76>
		conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
    ffac:	f104 0174 	add.w	r1, r4, #116	; 0x74
    ffb0:	7a20      	ldrb	r0, [r4, #8]
    ffb2:	f000 f8dd 	bl	10170 <bt_keys_get_addr>
    ffb6:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
		if (!conn->le.keys) {
    ffba:	2800      	cmp	r0, #0
    ffbc:	d1dd      	bne.n	ff7a <bt_smp_start_security+0xda>
			return -ENOMEM;
    ffbe:	f06f 070b 	mvn.w	r7, #11
    ffc2:	e775      	b.n	feb0 <bt_smp_start_security+0x10>
	req_buf = smp_create_pdu(smp, BT_SMP_CMD_SECURITY_REQUEST,
    ffc4:	210b      	movs	r1, #11
    ffc6:	4628      	mov	r0, r5
    ffc8:	f013 fcf9 	bl	239be <smp_create_pdu.isra.5>
	if (!req_buf) {
    ffcc:	4680      	mov	r8, r0
    ffce:	2800      	cmp	r0, #0
    ffd0:	d0d8      	beq.n	ff84 <bt_smp_start_security+0xe4>
	req = net_buf_add(req_buf, sizeof(*req));
    ffd2:	2101      	movs	r1, #1
    ffd4:	3008      	adds	r0, #8
    ffd6:	f014 feff 	bl	24dd8 <net_buf_simple_add>
    ffda:	4681      	mov	r9, r0
	req->auth_req = get_auth(conn, BT_SMP_AUTH_DEFAULT);
    ffdc:	2009      	movs	r0, #9
    ffde:	f7fe fc1f 	bl	e820 <get_auth.isra.0>
    ffe2:	463b      	mov	r3, r7
    ffe4:	f889 0000 	strb.w	r0, [r9]
    ffe8:	4642      	mov	r2, r8
    ffea:	9700      	str	r7, [sp, #0]
    ffec:	2106      	movs	r1, #6
    ffee:	4620      	mov	r0, r4
    fff0:	f012 fc60 	bl	228b4 <bt_l2cap_send_cb>
	atomic_set_bit(smp->flags, SMP_FLAG_SEC_REQ);
    fff4:	4630      	mov	r0, r6
    fff6:	210e      	movs	r1, #14
    fff8:	f013 fc23 	bl	23842 <atomic_set_bit>
	atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_REQ);
    fffc:	2101      	movs	r1, #1
    fffe:	f105 0098 	add.w	r0, r5, #152	; 0x98
   10002:	f013 fc1e 	bl	23842 <atomic_set_bit>
	return 0;
   10006:	e753      	b.n	feb0 <bt_smp_start_security+0x10>
		return -ENOTCONN;
   10008:	f06f 077f 	mvn.w	r7, #127	; 0x7f
   1000c:	e750      	b.n	feb0 <bt_smp_start_security+0x10>
		return -EIO;
   1000e:	f06f 0704 	mvn.w	r7, #4
   10012:	e74d      	b.n	feb0 <bt_smp_start_security+0x10>
   10014:	200003a0 	.word	0x200003a0
   10018:	2000aa5a 	.word	0x2000aa5a
   1001c:	2000aa5b 	.word	0x2000aa5b

00010020 <bt_smp_update_keys>:
{
   10020:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10022:	4604      	mov	r4, r0
	smp = smp_chan_get(conn);
   10024:	f7fe fc1a 	bl	e85c <smp_chan_get>
	if (!smp) {
   10028:	4605      	mov	r5, r0
   1002a:	2800      	cmp	r0, #0
   1002c:	d07b      	beq.n	10126 <bt_smp_update_keys+0x106>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
   1002e:	f100 069c 	add.w	r6, r0, #156	; 0x9c
   10032:	2103      	movs	r1, #3
   10034:	4630      	mov	r0, r6
   10036:	f013 fc13 	bl	23860 <atomic_test_bit>
   1003a:	2800      	cmp	r0, #0
   1003c:	d073      	beq.n	10126 <bt_smp_update_keys+0x106>
	if (conn->le.keys) {
   1003e:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
   10042:	b108      	cbz	r0, 10048 <bt_smp_update_keys+0x28>
		bt_keys_clear(conn->le.keys);
   10044:	f000 f966 	bl	10314 <bt_keys_clear>
	conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
   10048:	f104 0774 	add.w	r7, r4, #116	; 0x74
   1004c:	4639      	mov	r1, r7
   1004e:	7a20      	ldrb	r0, [r4, #8]
   10050:	f000 f88e 	bl	10170 <bt_keys_get_addr>
   10054:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
	if (!conn->le.keys) {
   10058:	b9d0      	cbnz	r0, 10090 <bt_smp_update_keys+0x70>
		BT_ERR("Unable to get keys for %s",
   1005a:	2301      	movs	r3, #1
   1005c:	f04f 0400 	mov.w	r4, #0
   10060:	4a35      	ldr	r2, [pc, #212]	; (10138 <bt_smp_update_keys+0x118>)
   10062:	f363 0407 	bfi	r4, r3, #0, #8
   10066:	4b35      	ldr	r3, [pc, #212]	; (1013c <bt_smp_update_keys+0x11c>)
   10068:	1a9b      	subs	r3, r3, r2
   1006a:	08db      	lsrs	r3, r3, #3
   1006c:	4638      	mov	r0, r7
   1006e:	f363 148f 	bfi	r4, r3, #6, #10
   10072:	f7f7 fbb9 	bl	77e8 <bt_addr_le_str_real>
   10076:	f7f4 fe43 	bl	4d00 <log_strdup>
   1007a:	4622      	mov	r2, r4
   1007c:	4601      	mov	r1, r0
   1007e:	4830      	ldr	r0, [pc, #192]	; (10140 <bt_smp_update_keys+0x120>)
   10080:	f010 ffe8 	bl	21054 <log_1>
		smp_error(smp, BT_SMP_ERR_UNSPECIFIED);
   10084:	4628      	mov	r0, r5
   10086:	2108      	movs	r1, #8
}
   10088:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		smp_error(smp, BT_SMP_ERR_UNSPECIFIED);
   1008c:	f013 bd7e 	b.w	23b8c <smp_error>
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY)) {
   10090:	210d      	movs	r1, #13
   10092:	4630      	mov	r0, r6
   10094:	f013 fbe4 	bl	23860 <atomic_test_bit>
   10098:	b128      	cbz	r0, 100a6 <bt_smp_update_keys+0x86>
		conn->le.keys->flags |= BT_KEYS_DEBUG;
   1009a:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
   1009e:	7a53      	ldrb	r3, [r2, #9]
   100a0:	f043 0302 	orr.w	r3, r3, #2
   100a4:	7253      	strb	r3, [r2, #9]
	switch (smp->method) {
   100a6:	f895 00a0 	ldrb.w	r0, [r5, #160]	; 0xa0
   100aa:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
   100ae:	2805      	cmp	r0, #5
   100b0:	7a53      	ldrb	r3, [r2, #9]
   100b2:	d839      	bhi.n	10128 <bt_smp_update_keys+0x108>
   100b4:	2101      	movs	r1, #1
   100b6:	4081      	lsls	r1, r0
   100b8:	f011 0f2e 	tst.w	r1, #46	; 0x2e
   100bc:	d034      	beq.n	10128 <bt_smp_update_keys+0x108>
		conn->le.keys->flags |= BT_KEYS_AUTHENTICATED;
   100be:	f043 0301 	orr.w	r3, r3, #1
		conn->le.keys->flags &= ~BT_KEYS_AUTHENTICATED;
   100c2:	7253      	strb	r3, [r2, #9]
	return MIN(req->max_key_size, rsp->max_key_size);
   100c4:	f895 30ac 	ldrb.w	r3, [r5, #172]	; 0xac
   100c8:	f895 10a5 	ldrb.w	r1, [r5, #165]	; 0xa5
   100cc:	428b      	cmp	r3, r1
   100ce:	bf28      	it	cs
   100d0:	460b      	movcs	r3, r1
	conn->le.keys->enc_size = get_encryption_key_size(smp);
   100d2:	7213      	strb	r3, [r2, #8]
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
   100d4:	2105      	movs	r1, #5
   100d6:	4630      	mov	r0, r6
   100d8:	f013 fbc2 	bl	23860 <atomic_test_bit>
   100dc:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
		conn->le.keys->flags |= BT_KEYS_SC;
   100e0:	7a5a      	ldrb	r2, [r3, #9]
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
   100e2:	b320      	cbz	r0, 1012e <bt_smp_update_keys+0x10e>
		conn->le.keys->flags |= BT_KEYS_SC;
   100e4:	f042 0210 	orr.w	r2, r2, #16
   100e8:	725a      	strb	r2, [r3, #9]
		if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
   100ea:	210c      	movs	r1, #12
   100ec:	4630      	mov	r0, r6
   100ee:	f013 fbb7 	bl	23860 <atomic_test_bit>
   100f2:	b1c0      	cbz	r0, 10126 <bt_smp_update_keys+0x106>
			bt_keys_add_type(conn->le.keys, BT_KEYS_LTK_P256);
   100f4:	2120      	movs	r1, #32
   100f6:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
   100fa:	f013 ff4b 	bl	23f94 <bt_keys_add_type>
   100fe:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
   10102:	f105 02df 	add.w	r2, r5, #223	; 0xdf
   10106:	3316      	adds	r3, #22
   10108:	35ef      	adds	r5, #239	; 0xef
   1010a:	f852 1b04 	ldr.w	r1, [r2], #4
   1010e:	f843 1b04 	str.w	r1, [r3], #4
   10112:	42aa      	cmp	r2, r5
   10114:	d1f9      	bne.n	1010a <bt_smp_update_keys+0xea>
__ssp_bos_icheck3(memset, void *, int)
   10116:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
   1011a:	2300      	movs	r3, #0
   1011c:	60d3      	str	r3, [r2, #12]
   1011e:	6113      	str	r3, [r2, #16]
   10120:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
   10124:	8293      	strh	r3, [r2, #20]
}
   10126:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		conn->le.keys->flags &= ~BT_KEYS_AUTHENTICATED;
   10128:	f023 0301 	bic.w	r3, r3, #1
   1012c:	e7c9      	b.n	100c2 <bt_smp_update_keys+0xa2>
		conn->le.keys->flags &= ~BT_KEYS_SC;
   1012e:	f022 0210 	bic.w	r2, r2, #16
   10132:	725a      	strb	r2, [r3, #9]
   10134:	e7f7      	b.n	10126 <bt_smp_update_keys+0x106>
   10136:	bf00      	nop
   10138:	00028540 	.word	0x00028540
   1013c:	00028640 	.word	0x00028640
   10140:	00063fae 	.word	0x00063fae

00010144 <bt_smp_init>:
BT_L2CAP_CHANNEL_DEFINE(smp_br_fixed_chan, BT_L2CAP_CID_BR_SMP,
			bt_smp_br_accept);
#endif /* CONFIG_BT_BREDR */

int bt_smp_init(void)
{
   10144:	b508      	push	{r3, lr}
	return BT_CMD_TEST(bt_dev.supported_commands, 34, 1) &&
   10146:	4b07      	ldr	r3, [pc, #28]	; (10164 <bt_smp_init+0x20>)
		return -ENOENT;
	}

	BT_DBG("LE SC %s", sc_supported ? "enabled" : "disabled");

	bt_pub_key_gen(&pub_key_cb);
   10148:	4807      	ldr	r0, [pc, #28]	; (10168 <bt_smp_init+0x24>)
	return BT_CMD_TEST(bt_dev.supported_commands, 34, 1) &&
   1014a:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
   1014e:	f003 0306 	and.w	r3, r3, #6
   10152:	1f9a      	subs	r2, r3, #6
   10154:	4253      	negs	r3, r2
   10156:	4153      	adcs	r3, r2
   10158:	4a04      	ldr	r2, [pc, #16]	; (1016c <bt_smp_init+0x28>)
   1015a:	7013      	strb	r3, [r2, #0]
	bt_pub_key_gen(&pub_key_cb);
   1015c:	f7fa f9c6 	bl	a4ec <bt_pub_key_gen>

	return smp_self_test();
}
   10160:	2000      	movs	r0, #0
   10162:	bd08      	pop	{r3, pc}
   10164:	2000e4d8 	.word	0x2000e4d8
   10168:	2000e830 	.word	0x2000e830
   1016c:	2000aa5b 	.word	0x2000aa5b

00010170 <bt_keys_get_addr>:
static u32_t aging_counter_val;
static struct bt_keys *last_keys_updated;
#endif /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */

struct bt_keys *bt_keys_get_addr(u8_t id, const bt_addr_le_t *addr)
{
   10170:	b5f0      	push	{r4, r5, r6, r7, lr}
	BT_DBG("%s", bt_addr_le_str(addr));

	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
		keys = &key_pool[i];

		if (keys->id == id && !bt_addr_le_cmp(&keys->addr, addr)) {
   10172:	4c1c      	ldr	r4, [pc, #112]	; (101e4 <bt_keys_get_addr+0x74>)
   10174:	7823      	ldrb	r3, [r4, #0]
   10176:	4283      	cmp	r3, r0
{
   10178:	b085      	sub	sp, #20
   1017a:	4606      	mov	r6, r0
   1017c:	460f      	mov	r7, r1
   1017e:	4625      	mov	r5, r4
		if (keys->id == id && !bt_addr_le_cmp(&keys->addr, addr)) {
   10180:	d028      	beq.n	101d4 <bt_keys_get_addr+0x64>
			return keys;
		}

		if (first_free_slot == ARRAY_SIZE(key_pool) &&
		    (!bt_addr_le_cmp(&keys->addr, BT_ADDR_LE_ANY) ||
   10182:	2400      	movs	r4, #0
	return memcmp(a, b, sizeof(*a));
   10184:	2207      	movs	r2, #7
   10186:	4669      	mov	r1, sp
   10188:	4817      	ldr	r0, [pc, #92]	; (101e8 <bt_keys_get_addr+0x78>)
   1018a:	9400      	str	r4, [sp, #0]
   1018c:	f8cd 4003 	str.w	r4, [sp, #3]
   10190:	f7f1 fd1e 	bl	1bd0 <memcmp>
		if (first_free_slot == ARRAY_SIZE(key_pool) &&
   10194:	b170      	cbz	r0, 101b4 <bt_keys_get_addr+0x44>
		    (!bt_addr_le_cmp(&keys->addr, BT_ADDR_LE_ANY) ||
   10196:	7a2b      	ldrb	r3, [r5, #8]
   10198:	b163      	cbz	r3, 101b4 <bt_keys_get_addr+0x44>
			if (current->aging_counter < oldest->aging_counter) {
				oldest = current;
			}
		}

		bt_unpair(oldest->id, &oldest->addr);
   1019a:	4913      	ldr	r1, [pc, #76]	; (101e8 <bt_keys_get_addr+0x78>)
   1019c:	7828      	ldrb	r0, [r5, #0]
   1019e:	f7f9 f807 	bl	91b0 <bt_unpair>
   101a2:	2207      	movs	r2, #7
   101a4:	a902      	add	r1, sp, #8
   101a6:	4810      	ldr	r0, [pc, #64]	; (101e8 <bt_keys_get_addr+0x78>)
		if (!bt_addr_le_cmp(&oldest->addr, BT_ADDR_LE_ANY)) {
   101a8:	9402      	str	r4, [sp, #8]
   101aa:	f8cd 400b 	str.w	r4, [sp, #11]
   101ae:	f7f1 fd0f 	bl	1bd0 <memcmp>
   101b2:	b9a8      	cbnz	r0, 101e0 <bt_keys_get_addr+0x70>

#endif  /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
	if (first_free_slot < ARRAY_SIZE(key_pool)) {
		keys = &key_pool[first_free_slot];
		keys->id = id;
		bt_addr_le_copy(&keys->addr, addr);
   101b4:	480c      	ldr	r0, [pc, #48]	; (101e8 <bt_keys_get_addr+0x78>)
		keys->id = id;
   101b6:	702e      	strb	r6, [r5, #0]
		bt_addr_le_copy(&keys->addr, addr);
   101b8:	4639      	mov	r1, r7
   101ba:	f013 fed4 	bl	23f66 <bt_addr_le_copy>
#if IS_ENABLED(CONFIG_BT_KEYS_OVERWRITE_OLDEST)
		keys->aging_counter = ++aging_counter_val;
   101be:	4a0b      	ldr	r2, [pc, #44]	; (101ec <bt_keys_get_addr+0x7c>)
		last_keys_updated = keys;
#endif  /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
		BT_DBG("created %p for %s", keys, bt_addr_le_str(addr));
		return keys;
   101c0:	4808      	ldr	r0, [pc, #32]	; (101e4 <bt_keys_get_addr+0x74>)
		keys->aging_counter = ++aging_counter_val;
   101c2:	6813      	ldr	r3, [r2, #0]
   101c4:	3301      	adds	r3, #1
   101c6:	6013      	str	r3, [r2, #0]
   101c8:	f8c5 3080 	str.w	r3, [r5, #128]	; 0x80
		last_keys_updated = keys;
   101cc:	4b08      	ldr	r3, [pc, #32]	; (101f0 <bt_keys_get_addr+0x80>)
   101ce:	601d      	str	r5, [r3, #0]
	}

	BT_DBG("unable to create keys for %s", bt_addr_le_str(addr));

	return NULL;
}
   101d0:	b005      	add	sp, #20
   101d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   101d4:	2207      	movs	r2, #7
   101d6:	1c60      	adds	r0, r4, #1
   101d8:	f7f1 fcfa 	bl	1bd0 <memcmp>
		if (keys->id == id && !bt_addr_le_cmp(&keys->addr, addr)) {
   101dc:	2800      	cmp	r0, #0
   101de:	d1d0      	bne.n	10182 <bt_keys_get_addr+0x12>
	return NULL;
   101e0:	4620      	mov	r0, r4
   101e2:	e7f5      	b.n	101d0 <bt_keys_get_addr+0x60>
   101e4:	20000790 	.word	0x20000790
   101e8:	20000791 	.word	0x20000791
   101ec:	2000078c 	.word	0x2000078c
   101f0:	20000814 	.word	0x20000814

000101f4 <bt_foreach_bond>:

void bt_foreach_bond(u8_t id, void (*func)(const struct bt_bond_info *info,
					   void *user_data),
		     void *user_data)
{
   101f4:	b513      	push	{r0, r1, r4, lr}
   101f6:	460c      	mov	r4, r1
	int i;

	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
		struct bt_keys *keys = &key_pool[i];

		if (keys->keys && keys->id == id) {
   101f8:	4907      	ldr	r1, [pc, #28]	; (10218 <bt_foreach_bond+0x24>)
   101fa:	894b      	ldrh	r3, [r1, #10]
   101fc:	b14b      	cbz	r3, 10212 <bt_foreach_bond+0x1e>
   101fe:	780b      	ldrb	r3, [r1, #0]
   10200:	4283      	cmp	r3, r0
   10202:	d106      	bne.n	10212 <bt_foreach_bond+0x1e>
			struct bt_bond_info info;

			bt_addr_le_copy(&info.addr, &keys->addr);
   10204:	3101      	adds	r1, #1
   10206:	4668      	mov	r0, sp
   10208:	f013 fead 	bl	23f66 <bt_addr_le_copy>
			func(&info, user_data);
   1020c:	4668      	mov	r0, sp
   1020e:	4611      	mov	r1, r2
   10210:	47a0      	blx	r4
		}
	}
}
   10212:	b002      	add	sp, #8
   10214:	bd10      	pop	{r4, pc}
   10216:	bf00      	nop
   10218:	20000790 	.word	0x20000790

0001021c <bt_keys_foreach>:
		     void *data)
{
	int i;

	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
		if ((key_pool[i].keys & type)) {
   1021c:	4b06      	ldr	r3, [pc, #24]	; (10238 <bt_keys_foreach+0x1c>)
{
   1021e:	b410      	push	{r4}
   10220:	460c      	mov	r4, r1
		if ((key_pool[i].keys & type)) {
   10222:	8959      	ldrh	r1, [r3, #10]
   10224:	4201      	tst	r1, r0
   10226:	d004      	beq.n	10232 <bt_keys_foreach+0x16>
			func(&key_pool[i], data);
   10228:	4618      	mov	r0, r3
   1022a:	4611      	mov	r1, r2
   1022c:	4623      	mov	r3, r4
		}
	}
}
   1022e:	bc10      	pop	{r4}
			func(&key_pool[i], data);
   10230:	4718      	bx	r3
}
   10232:	bc10      	pop	{r4}
   10234:	4770      	bx	lr
   10236:	bf00      	nop
   10238:	20000790 	.word	0x20000790

0001023c <keys_commit>:
{
	bt_id_add(keys);
}

static int keys_commit(void)
{
   1023c:	b508      	push	{r3, lr}

	/* We do this in commit() rather than add() since add() may get
	 * called multiple times for the same address, especially if
	 * the keys were already removed.
	 */
	bt_keys_foreach(BT_KEYS_IRK, id_add, NULL);
   1023e:	2200      	movs	r2, #0
   10240:	4902      	ldr	r1, [pc, #8]	; (1024c <keys_commit+0x10>)
   10242:	2002      	movs	r0, #2
   10244:	f7ff ffea 	bl	1021c <bt_keys_foreach>

	return 0;
}
   10248:	2000      	movs	r0, #0
   1024a:	bd08      	pop	{r3, pc}
   1024c:	00023f63 	.word	0x00023f63

00010250 <bt_keys_find>:
{
   10250:	b538      	push	{r3, r4, r5, lr}
		if ((key_pool[i].keys & type) && key_pool[i].id == id &&
   10252:	4c0a      	ldr	r4, [pc, #40]	; (1027c <bt_keys_find+0x2c>)
   10254:	8963      	ldrh	r3, [r4, #10]
   10256:	4018      	ands	r0, r3
{
   10258:	460d      	mov	r5, r1
   1025a:	4611      	mov	r1, r2
		if ((key_pool[i].keys & type) && key_pool[i].id == id &&
   1025c:	d00a      	beq.n	10274 <bt_keys_find+0x24>
   1025e:	7823      	ldrb	r3, [r4, #0]
   10260:	42ab      	cmp	r3, r5
   10262:	d108      	bne.n	10276 <bt_keys_find+0x26>
   10264:	2207      	movs	r2, #7
   10266:	1c60      	adds	r0, r4, #1
   10268:	f7f1 fcb2 	bl	1bd0 <memcmp>
   1026c:	2800      	cmp	r0, #0
			return &key_pool[i];
   1026e:	bf0c      	ite	eq
   10270:	4620      	moveq	r0, r4
   10272:	2000      	movne	r0, #0
}
   10274:	bd38      	pop	{r3, r4, r5, pc}
	return NULL;
   10276:	2000      	movs	r0, #0
   10278:	e7fc      	b.n	10274 <bt_keys_find+0x24>
   1027a:	bf00      	nop
   1027c:	20000790 	.word	0x20000790

00010280 <bt_keys_find_irk>:
{
   10280:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (addr->type != BT_ADDR_LE_RANDOM) {
   10282:	780b      	ldrb	r3, [r1, #0]
   10284:	2b01      	cmp	r3, #1
   10286:	4607      	mov	r7, r0
   10288:	460d      	mov	r5, r1
   1028a:	d001      	beq.n	10290 <bt_keys_find_irk+0x10>
		return NULL;
   1028c:	2000      	movs	r0, #0
}
   1028e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!bt_addr_le_is_rpa(addr)) {
   10290:	798b      	ldrb	r3, [r1, #6]
   10292:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   10296:	2b40      	cmp	r3, #64	; 0x40
   10298:	d1f8      	bne.n	1028c <bt_keys_find_irk+0xc>
		if (!(key_pool[i].keys & BT_KEYS_IRK)) {
   1029a:	4c13      	ldr	r4, [pc, #76]	; (102e8 <bt_keys_find_irk+0x68>)
   1029c:	8963      	ldrh	r3, [r4, #10]
   1029e:	f013 0f02 	tst.w	r3, #2
   102a2:	4626      	mov	r6, r4
   102a4:	d00b      	beq.n	102be <bt_keys_find_irk+0x3e>
		if (key_pool[i].id == id &&
   102a6:	7823      	ldrb	r3, [r4, #0]
   102a8:	4283      	cmp	r3, r0
   102aa:	d108      	bne.n	102be <bt_keys_find_irk+0x3e>
	return memcmp(a, b, sizeof(*a));
   102ac:	2206      	movs	r2, #6
   102ae:	f104 0136 	add.w	r1, r4, #54	; 0x36
   102b2:	1c68      	adds	r0, r5, #1
   102b4:	f7f1 fc8c 	bl	1bd0 <memcmp>
   102b8:	b908      	cbnz	r0, 102be <bt_keys_find_irk+0x3e>
			return &key_pool[i];
   102ba:	4620      	mov	r0, r4
   102bc:	e7e7      	b.n	1028e <bt_keys_find_irk+0xe>
		if (!(key_pool[i].keys & BT_KEYS_IRK)) {
   102be:	8973      	ldrh	r3, [r6, #10]
   102c0:	079b      	lsls	r3, r3, #30
   102c2:	d5e3      	bpl.n	1028c <bt_keys_find_irk+0xc>
		if (key_pool[i].id != id) {
   102c4:	7833      	ldrb	r3, [r6, #0]
   102c6:	42bb      	cmp	r3, r7
   102c8:	d1e0      	bne.n	1028c <bt_keys_find_irk+0xc>
		if (bt_rpa_irk_matches(key_pool[i].irk.val, &addr->a)) {
   102ca:	3501      	adds	r5, #1
   102cc:	4629      	mov	r1, r5
   102ce:	4807      	ldr	r0, [pc, #28]	; (102ec <bt_keys_find_irk+0x6c>)
   102d0:	f011 ffa3 	bl	2221a <bt_rpa_irk_matches>
   102d4:	2800      	cmp	r0, #0
   102d6:	d0d9      	beq.n	1028c <bt_keys_find_irk+0xc>
	memcpy(dst, src, sizeof(*dst));
   102d8:	682b      	ldr	r3, [r5, #0]
   102da:	4805      	ldr	r0, [pc, #20]	; (102f0 <bt_keys_find_irk+0x70>)
   102dc:	f8c6 3036 	str.w	r3, [r6, #54]	; 0x36
   102e0:	88ab      	ldrh	r3, [r5, #4]
   102e2:	8083      	strh	r3, [r0, #4]
			return &key_pool[i];
   102e4:	3836      	subs	r0, #54	; 0x36
   102e6:	e7d2      	b.n	1028e <bt_keys_find_irk+0xe>
   102e8:	20000790 	.word	0x20000790
   102ec:	200007b6 	.word	0x200007b6
   102f0:	200007c6 	.word	0x200007c6

000102f4 <bt_keys_find_addr>:
{
   102f4:	b510      	push	{r4, lr}
		if (key_pool[i].id == id &&
   102f6:	4c06      	ldr	r4, [pc, #24]	; (10310 <bt_keys_find_addr+0x1c>)
   102f8:	7823      	ldrb	r3, [r4, #0]
   102fa:	4283      	cmp	r3, r0
   102fc:	d104      	bne.n	10308 <bt_keys_find_addr+0x14>
	return memcmp(a, b, sizeof(*a));
   102fe:	2207      	movs	r2, #7
   10300:	1c60      	adds	r0, r4, #1
   10302:	f7f1 fc65 	bl	1bd0 <memcmp>
   10306:	b108      	cbz	r0, 1030c <bt_keys_find_addr+0x18>
	return NULL;
   10308:	2000      	movs	r0, #0
}
   1030a:	bd10      	pop	{r4, pc}
			return &key_pool[i];
   1030c:	4620      	mov	r0, r4
   1030e:	e7fc      	b.n	1030a <bt_keys_find_addr+0x16>
   10310:	20000790 	.word	0x20000790

00010314 <bt_keys_clear>:
{
   10314:	b570      	push	{r4, r5, r6, lr}
	if (keys->keys & BT_KEYS_IRK) {
   10316:	8943      	ldrh	r3, [r0, #10]
   10318:	079b      	lsls	r3, r3, #30
{
   1031a:	b08c      	sub	sp, #48	; 0x30
   1031c:	4605      	mov	r5, r0
	if (keys->keys & BT_KEYS_IRK) {
   1031e:	d501      	bpl.n	10324 <bt_keys_clear+0x10>
		bt_id_del(keys);
   10320:	f7f9 f84a 	bl	93b8 <bt_id_del>
		if (keys->id) {
   10324:	462c      	mov	r4, r5
   10326:	f814 2b01 	ldrb.w	r2, [r4], #1
   1032a:	b1b2      	cbz	r2, 1035a <bt_keys_clear+0x46>
			u8_to_dec(id, sizeof(id), keys->id);
   1032c:	ae02      	add	r6, sp, #8
   1032e:	2104      	movs	r1, #4
   10330:	4630      	mov	r0, r6
   10332:	f00f f981 	bl	1f638 <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "keys",
   10336:	9600      	str	r6, [sp, #0]
			bt_settings_encode_key(key, sizeof(key), "keys",
   10338:	4623      	mov	r3, r4
   1033a:	4a09      	ldr	r2, [pc, #36]	; (10360 <bt_keys_clear+0x4c>)
   1033c:	2124      	movs	r1, #36	; 0x24
   1033e:	a803      	add	r0, sp, #12
   10340:	f7f7 fd36 	bl	7db0 <bt_settings_encode_key>
		settings_delete(key);
   10344:	a803      	add	r0, sp, #12
   10346:	f011 fae2 	bl	2190e <settings_delete>
   1034a:	2284      	movs	r2, #132	; 0x84
   1034c:	2100      	movs	r1, #0
   1034e:	4628      	mov	r0, r5
}
   10350:	b00c      	add	sp, #48	; 0x30
   10352:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   10356:	f7f1 bc6a 	b.w	1c2e <memset>
			bt_settings_encode_key(key, sizeof(key), "keys",
   1035a:	9200      	str	r2, [sp, #0]
   1035c:	e7ec      	b.n	10338 <bt_keys_clear+0x24>
   1035e:	bf00      	nop
   10360:	00064107 	.word	0x00064107

00010364 <keys_set>:
{
   10364:	b5f0      	push	{r4, r5, r6, r7, lr}
   10366:	4614      	mov	r4, r2
   10368:	b0a3      	sub	sp, #140	; 0x8c
	if (!name) {
   1036a:	4606      	mov	r6, r0
   1036c:	b990      	cbnz	r0, 10394 <keys_set+0x30>
		BT_ERR("Insufficient number of arguments");
   1036e:	2301      	movs	r3, #1
   10370:	f04f 0100 	mov.w	r1, #0
   10374:	f363 0107 	bfi	r1, r3, #0, #8
   10378:	4a56      	ldr	r2, [pc, #344]	; (104d4 <keys_set+0x170>)
   1037a:	4b57      	ldr	r3, [pc, #348]	; (104d8 <keys_set+0x174>)
   1037c:	4857      	ldr	r0, [pc, #348]	; (104dc <keys_set+0x178>)
   1037e:	1a9b      	subs	r3, r3, r2
   10380:	08db      	lsrs	r3, r3, #3
   10382:	f363 118f 	bfi	r1, r3, #6, #10
   10386:	f010 fe58 	bl	2103a <log_0>
		return -EINVAL;
   1038a:	f06f 0415 	mvn.w	r4, #21
}
   1038e:	4620      	mov	r0, r4
   10390:	b023      	add	sp, #140	; 0x8c
   10392:	bdf0      	pop	{r4, r5, r6, r7, pc}
	len = read_cb(cb_arg, val, sizeof(val));
   10394:	227c      	movs	r2, #124	; 0x7c
   10396:	a903      	add	r1, sp, #12
   10398:	4618      	mov	r0, r3
   1039a:	47a0      	blx	r4
	err = bt_settings_decode_key(name, &addr);
   1039c:	a901      	add	r1, sp, #4
	len = read_cb(cb_arg, val, sizeof(val));
   1039e:	4605      	mov	r5, r0
	err = bt_settings_decode_key(name, &addr);
   103a0:	4630      	mov	r0, r6
   103a2:	f011 ff98 	bl	222d6 <bt_settings_decode_key>
	if (err) {
   103a6:	4604      	mov	r4, r0
   103a8:	b178      	cbz	r0, 103ca <keys_set+0x66>
		BT_ERR("Unable to decode address %s", name);
   103aa:	2301      	movs	r3, #1
   103ac:	f04f 0200 	mov.w	r2, #0
   103b0:	f363 0207 	bfi	r2, r3, #0, #8
   103b4:	4947      	ldr	r1, [pc, #284]	; (104d4 <keys_set+0x170>)
   103b6:	4b48      	ldr	r3, [pc, #288]	; (104d8 <keys_set+0x174>)
   103b8:	4849      	ldr	r0, [pc, #292]	; (104e0 <keys_set+0x17c>)
   103ba:	1a5b      	subs	r3, r3, r1
   103bc:	08db      	lsrs	r3, r3, #3
   103be:	f363 128f 	bfi	r2, r3, #6, #10
   103c2:	4631      	mov	r1, r6
   103c4:	f010 fe46 	bl	21054 <log_1>
   103c8:	e7df      	b.n	1038a <keys_set+0x26>
	settings_name_next(name, &next);
   103ca:	4669      	mov	r1, sp
   103cc:	4630      	mov	r0, r6
   103ce:	f011 fac2 	bl	21956 <settings_name_next>
	if (!next) {
   103d2:	9800      	ldr	r0, [sp, #0]
   103d4:	b180      	cbz	r0, 103f8 <keys_set+0x94>
		id = strtol(next, NULL, 10);
   103d6:	220a      	movs	r2, #10
   103d8:	4621      	mov	r1, r4
   103da:	f7f0 fb87 	bl	aec <strtol>
   103de:	b2c0      	uxtb	r0, r0
	if (!len) {
   103e0:	bb15      	cbnz	r5, 10428 <keys_set+0xc4>
		keys = bt_keys_find(BT_KEYS_ALL, id, &addr);
   103e2:	4601      	mov	r1, r0
   103e4:	aa01      	add	r2, sp, #4
   103e6:	203f      	movs	r0, #63	; 0x3f
   103e8:	f7ff ff32 	bl	10250 <bt_keys_find>
		if (keys) {
   103ec:	b130      	cbz	r0, 103fc <keys_set+0x98>
   103ee:	2284      	movs	r2, #132	; 0x84
   103f0:	4629      	mov	r1, r5
   103f2:	f7f1 fc1c 	bl	1c2e <memset>
   103f6:	e7ca      	b.n	1038e <keys_set+0x2a>
		id = BT_ID_DEFAULT;
   103f8:	4620      	mov	r0, r4
   103fa:	e7f1      	b.n	103e0 <keys_set+0x7c>
			BT_WARN("Unable to find deleted keys for %s",
   103fc:	2302      	movs	r3, #2
   103fe:	f04f 0500 	mov.w	r5, #0
   10402:	4a34      	ldr	r2, [pc, #208]	; (104d4 <keys_set+0x170>)
   10404:	f363 0507 	bfi	r5, r3, #0, #8
   10408:	4b33      	ldr	r3, [pc, #204]	; (104d8 <keys_set+0x174>)
   1040a:	1a9b      	subs	r3, r3, r2
   1040c:	08db      	lsrs	r3, r3, #3
   1040e:	a801      	add	r0, sp, #4
   10410:	f363 158f 	bfi	r5, r3, #6, #10
   10414:	f7f7 f9e8 	bl	77e8 <bt_addr_le_str_real>
   10418:	f7f4 fc72 	bl	4d00 <log_strdup>
   1041c:	462a      	mov	r2, r5
   1041e:	4601      	mov	r1, r0
   10420:	4830      	ldr	r0, [pc, #192]	; (104e4 <keys_set+0x180>)
   10422:	f010 fe17 	bl	21054 <log_1>
   10426:	e7b2      	b.n	1038e <keys_set+0x2a>
	keys = bt_keys_get_addr(id, &addr);
   10428:	a901      	add	r1, sp, #4
   1042a:	f7ff fea1 	bl	10170 <bt_keys_get_addr>
	if (!keys) {
   1042e:	4606      	mov	r6, r0
   10430:	b9b8      	cbnz	r0, 10462 <keys_set+0xfe>
		BT_ERR("Failed to allocate keys for %s", bt_addr_le_str(&addr));
   10432:	2301      	movs	r3, #1
   10434:	f04f 0400 	mov.w	r4, #0
   10438:	4a26      	ldr	r2, [pc, #152]	; (104d4 <keys_set+0x170>)
   1043a:	f363 0407 	bfi	r4, r3, #0, #8
   1043e:	4b26      	ldr	r3, [pc, #152]	; (104d8 <keys_set+0x174>)
   10440:	1a9b      	subs	r3, r3, r2
   10442:	08db      	lsrs	r3, r3, #3
   10444:	a801      	add	r0, sp, #4
   10446:	f363 148f 	bfi	r4, r3, #6, #10
   1044a:	f7f7 f9cd 	bl	77e8 <bt_addr_le_str_real>
   1044e:	f7f4 fc57 	bl	4d00 <log_strdup>
   10452:	4622      	mov	r2, r4
   10454:	4601      	mov	r1, r0
   10456:	4824      	ldr	r0, [pc, #144]	; (104e8 <keys_set+0x184>)
   10458:	f010 fdfc 	bl	21054 <log_1>
		return -ENOMEM;
   1045c:	f06f 040b 	mvn.w	r4, #11
   10460:	e795      	b.n	1038e <keys_set+0x2a>
	if (len != BT_KEYS_STORAGE_LEN) {
   10462:	2d7c      	cmp	r5, #124	; 0x7c
   10464:	d018      	beq.n	10498 <keys_set+0x134>
			if (IS_ENABLED(CONFIG_BT_KEYS_OVERWRITE_OLDEST) &&
   10466:	491c      	ldr	r1, [pc, #112]	; (104d8 <keys_set+0x174>)
   10468:	4b1a      	ldr	r3, [pc, #104]	; (104d4 <keys_set+0x170>)
   1046a:	2d78      	cmp	r5, #120	; 0x78
   1046c:	eba1 0103 	sub.w	r1, r1, r3
   10470:	f3c1 01c9 	ubfx	r1, r1, #3, #10
   10474:	d11e      	bne.n	104b4 <keys_set+0x150>
				BT_WARN("Keys for %s have no aging counter",
   10476:	2302      	movs	r3, #2
   10478:	f04f 0700 	mov.w	r7, #0
   1047c:	f363 0707 	bfi	r7, r3, #0, #8
   10480:	a801      	add	r0, sp, #4
   10482:	f361 178f 	bfi	r7, r1, #6, #10
   10486:	f7f7 f9af 	bl	77e8 <bt_addr_le_str_real>
   1048a:	f7f4 fc39 	bl	4d00 <log_strdup>
   1048e:	463a      	mov	r2, r7
   10490:	4601      	mov	r1, r0
   10492:	4816      	ldr	r0, [pc, #88]	; (104ec <keys_set+0x188>)
   10494:	f010 fdde 	bl	21054 <log_1>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   10498:	462a      	mov	r2, r5
   1049a:	a903      	add	r1, sp, #12
   1049c:	f106 0008 	add.w	r0, r6, #8
   104a0:	f7f1 fba4 	bl	1bec <memcpy>
	if (aging_counter_val < keys->aging_counter) {
   104a4:	4b12      	ldr	r3, [pc, #72]	; (104f0 <keys_set+0x18c>)
   104a6:	f8d6 2080 	ldr.w	r2, [r6, #128]	; 0x80
   104aa:	6819      	ldr	r1, [r3, #0]
   104ac:	428a      	cmp	r2, r1
		aging_counter_val = keys->aging_counter;
   104ae:	bf88      	it	hi
   104b0:	601a      	strhi	r2, [r3, #0]
   104b2:	e76c      	b.n	1038e <keys_set+0x2a>
			BT_ERR("Invalid key length %zu != %zu", len,
   104b4:	2201      	movs	r2, #1
   104b6:	f04f 0300 	mov.w	r3, #0
   104ba:	f362 0307 	bfi	r3, r2, #0, #8
   104be:	f361 138f 	bfi	r3, r1, #6, #10
   104c2:	227c      	movs	r2, #124	; 0x7c
   104c4:	4629      	mov	r1, r5
   104c6:	480b      	ldr	r0, [pc, #44]	; (104f4 <keys_set+0x190>)
   104c8:	f010 fdd8 	bl	2107c <log_2>
			bt_keys_clear(keys);
   104cc:	4630      	mov	r0, r6
   104ce:	f7ff ff21 	bl	10314 <bt_keys_clear>
			return -EINVAL;
   104d2:	e75a      	b.n	1038a <keys_set+0x26>
   104d4:	00028540 	.word	0x00028540
   104d8:	00028620 	.word	0x00028620
   104dc:	00062a7c 	.word	0x00062a7c
   104e0:	00063c31 	.word	0x00063c31
   104e4:	00064082 	.word	0x00064082
   104e8:	000640a5 	.word	0x000640a5
   104ec:	000640c4 	.word	0x000640c4
   104f0:	2000078c 	.word	0x2000078c
   104f4:	000640e6 	.word	0x000640e6

000104f8 <bt_keys_store>:
{
   104f8:	b570      	push	{r4, r5, r6, lr}
	if (keys->id) {
   104fa:	4604      	mov	r4, r0
{
   104fc:	b08c      	sub	sp, #48	; 0x30
	if (keys->id) {
   104fe:	f814 2b01 	ldrb.w	r2, [r4], #1
{
   10502:	4605      	mov	r5, r0
	if (keys->id) {
   10504:	b32a      	cbz	r2, 10552 <bt_keys_store+0x5a>
		u8_to_dec(id, sizeof(id), keys->id);
   10506:	ae02      	add	r6, sp, #8
   10508:	2104      	movs	r1, #4
   1050a:	4630      	mov	r0, r6
   1050c:	f00f f894 	bl	1f638 <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "keys", &keys->addr,
   10510:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "keys", &keys->addr,
   10512:	4623      	mov	r3, r4
   10514:	4a10      	ldr	r2, [pc, #64]	; (10558 <bt_keys_store+0x60>)
   10516:	2124      	movs	r1, #36	; 0x24
   10518:	a803      	add	r0, sp, #12
   1051a:	f7f7 fc49 	bl	7db0 <bt_settings_encode_key>
	err = settings_save_one(key, keys->storage_start, BT_KEYS_STORAGE_LEN);
   1051e:	227c      	movs	r2, #124	; 0x7c
   10520:	f105 0108 	add.w	r1, r5, #8
   10524:	a803      	add	r0, sp, #12
   10526:	f7f5 fd87 	bl	6038 <settings_save_one>
	if (err) {
   1052a:	4604      	mov	r4, r0
   1052c:	b170      	cbz	r0, 1054c <bt_keys_store+0x54>
		BT_ERR("Failed to save keys (err %d)", err);
   1052e:	2301      	movs	r3, #1
   10530:	f04f 0200 	mov.w	r2, #0
   10534:	f363 0207 	bfi	r2, r3, #0, #8
   10538:	4908      	ldr	r1, [pc, #32]	; (1055c <bt_keys_store+0x64>)
   1053a:	4b09      	ldr	r3, [pc, #36]	; (10560 <bt_keys_store+0x68>)
   1053c:	1a5b      	subs	r3, r3, r1
   1053e:	08db      	lsrs	r3, r3, #3
   10540:	4601      	mov	r1, r0
   10542:	f363 128f 	bfi	r2, r3, #6, #10
   10546:	4807      	ldr	r0, [pc, #28]	; (10564 <bt_keys_store+0x6c>)
   10548:	f010 fd84 	bl	21054 <log_1>
}
   1054c:	4620      	mov	r0, r4
   1054e:	b00c      	add	sp, #48	; 0x30
   10550:	bd70      	pop	{r4, r5, r6, pc}
		bt_settings_encode_key(key, sizeof(key), "keys", &keys->addr,
   10552:	9200      	str	r2, [sp, #0]
   10554:	e7dd      	b.n	10512 <bt_keys_store+0x1a>
   10556:	bf00      	nop
   10558:	00064107 	.word	0x00064107
   1055c:	00028540 	.word	0x00028540
   10560:	00028620 	.word	0x00028620
   10564:	00064065 	.word	0x00064065

00010568 <bt_keys_update_usage>:

#endif /* CONFIG_BT_SETTINGS */

#if IS_ENABLED(CONFIG_BT_KEYS_OVERWRITE_OLDEST)
void bt_keys_update_usage(u8_t id, const bt_addr_le_t *addr)
{
   10568:	b508      	push	{r3, lr}
	struct bt_keys *keys = bt_keys_find_addr(id, addr);
   1056a:	f7ff fec3 	bl	102f4 <bt_keys_find_addr>

	if (!keys) {
   1056e:	b150      	cbz	r0, 10586 <bt_keys_update_usage+0x1e>
		return;
	}

	if (last_keys_updated == keys) {
   10570:	4a05      	ldr	r2, [pc, #20]	; (10588 <bt_keys_update_usage+0x20>)
   10572:	6813      	ldr	r3, [r2, #0]
   10574:	4283      	cmp	r3, r0
   10576:	d006      	beq.n	10586 <bt_keys_update_usage+0x1e>
		return;
	}

	keys->aging_counter = ++aging_counter_val;
   10578:	4904      	ldr	r1, [pc, #16]	; (1058c <bt_keys_update_usage+0x24>)
	last_keys_updated = keys;
   1057a:	6010      	str	r0, [r2, #0]
	keys->aging_counter = ++aging_counter_val;
   1057c:	680b      	ldr	r3, [r1, #0]
   1057e:	3301      	adds	r3, #1
   10580:	600b      	str	r3, [r1, #0]
   10582:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
	       keys->aging_counter);

	if (IS_ENABLED(CONFIG_BT_KEYS_SAVE_AGING_COUNTER_ON_PAIRING)) {
		bt_keys_store(keys);
	}
}
   10586:	bd08      	pop	{r3, pc}
   10588:	20000814 	.word	0x20000814
   1058c:	2000078c 	.word	0x2000078c

00010590 <mayfly_init>:
#if defined(MAYFLY_UT)
static u8_t _state;
#endif /* MAYFLY_UT */

void mayfly_init(void)
{
   10590:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	while (callee_id--) {
		u8_t caller_id;

		caller_id = MAYFLY_CALLER_COUNT;
		while (caller_id--) {
			memq_init(&mfl[callee_id][caller_id],
   10594:	4f11      	ldr	r7, [pc, #68]	; (105dc <mayfly_init+0x4c>)
   10596:	f8df 9048 	ldr.w	r9, [pc, #72]	; 105e0 <mayfly_init+0x50>
	callee_id = MAYFLY_CALLEE_COUNT;
   1059a:	2604      	movs	r6, #4
	while (callee_id--) {
   1059c:	3e01      	subs	r6, #1
   1059e:	b2f6      	uxtb	r6, r6
   105a0:	2eff      	cmp	r6, #255	; 0xff
   105a2:	d019      	beq.n	105d8 <mayfly_init+0x48>
   105a4:	b233      	sxth	r3, r6
   105a6:	ea4f 0883 	mov.w	r8, r3, lsl #2
   105aa:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   105ae:	011d      	lsls	r5, r3, #4
		caller_id = MAYFLY_CALLER_COUNT;
   105b0:	2404      	movs	r4, #4
   105b2:	f04f 0a0c 	mov.w	sl, #12
   105b6:	e00a      	b.n	105ce <mayfly_init+0x3e>
			memq_init(&mfl[callee_id][caller_id],
   105b8:	fb1a 5104 	smlabb	r1, sl, r4, r5
   105bc:	1d0a      	adds	r2, r1, #4
   105be:	eb04 0008 	add.w	r0, r4, r8
   105c2:	443a      	add	r2, r7
   105c4:	4439      	add	r1, r7
   105c6:	eb09 00c0 	add.w	r0, r9, r0, lsl #3
   105ca:	f013 fd44 	bl	24056 <memq_init>
		while (caller_id--) {
   105ce:	3c01      	subs	r4, #1
   105d0:	b2e4      	uxtb	r4, r4
   105d2:	2cff      	cmp	r4, #255	; 0xff
   105d4:	d1f0      	bne.n	105b8 <mayfly_init+0x28>
   105d6:	e7e1      	b.n	1059c <mayfly_init+0xc>
				  &mft[callee_id][caller_id].head,
				  &mft[callee_id][caller_id].tail);
		}
	}
}
   105d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   105dc:	20000898 	.word	0x20000898
   105e0:	20000818 	.word	0x20000818

000105e4 <mayfly_enable>:

void mayfly_enable(u8_t caller_id, u8_t callee_id, u8_t enable)
{
   105e4:	b4f0      	push	{r4, r5, r6, r7}
   105e6:	2430      	movs	r4, #48	; 0x30
   105e8:	4b10      	ldr	r3, [pc, #64]	; (1062c <mayfly_enable+0x48>)
   105ea:	270c      	movs	r7, #12
	if (enable) {
		if (mft[callee_id][caller_id].enable_req ==
   105ec:	434c      	muls	r4, r1
   105ee:	fb07 4400 	mla	r4, r7, r0, r4
{
   105f2:	4605      	mov	r5, r0
   105f4:	460e      	mov	r6, r1
		if (mft[callee_id][caller_id].enable_req ==
   105f6:	4423      	add	r3, r4
	if (enable) {
   105f8:	b152      	cbz	r2, 10610 <mayfly_enable+0x2c>
		if (mft[callee_id][caller_id].enable_req ==
   105fa:	7a59      	ldrb	r1, [r3, #9]
   105fc:	7a18      	ldrb	r0, [r3, #8]
   105fe:	4281      	cmp	r1, r0
		    mft[callee_id][caller_id].enable_ack) {
			mft[callee_id][caller_id].enable_req++;
   10600:	bf04      	itt	eq
   10602:	3101      	addeq	r1, #1
   10604:	7219      	strbeq	r1, [r3, #8]
		}

		mayfly_enable_cb(caller_id, callee_id, enable);
   10606:	4628      	mov	r0, r5
   10608:	4631      	mov	r1, r6

			/* pend the callee for execution */
			mayfly_pend(caller_id, callee_id);
		}
	}
}
   1060a:	bcf0      	pop	{r4, r5, r6, r7}
		mayfly_enable_cb(caller_id, callee_id, enable);
   1060c:	f008 bb8a 	b.w	18d24 <mayfly_enable_cb>
		if (mft[callee_id][caller_id].disable_req ==
   10610:	7a9c      	ldrb	r4, [r3, #10]
   10612:	7ada      	ldrb	r2, [r3, #11]
   10614:	42a2      	cmp	r2, r4
   10616:	d107      	bne.n	10628 <mayfly_enable+0x44>
			mft[callee_id][caller_id].disable_req++;
   10618:	3201      	adds	r2, #1
   1061a:	729a      	strb	r2, [r3, #10]
			mfp[callee_id] = 1U;
   1061c:	4b04      	ldr	r3, [pc, #16]	; (10630 <mayfly_enable+0x4c>)
   1061e:	2201      	movs	r2, #1
   10620:	545a      	strb	r2, [r3, r1]
}
   10622:	bcf0      	pop	{r4, r5, r6, r7}
			mayfly_pend(caller_id, callee_id);
   10624:	f008 bbc0 	b.w	18da8 <mayfly_pend>
}
   10628:	bcf0      	pop	{r4, r5, r6, r7}
   1062a:	4770      	bx	lr
   1062c:	20000898 	.word	0x20000898
   10630:	2000aa5c 	.word	0x2000aa5c

00010634 <mayfly_enqueue>:

u32_t mayfly_enqueue(u8_t caller_id, u8_t callee_id, u8_t chain,
			struct mayfly *m)
{
   10634:	b570      	push	{r4, r5, r6, lr}
   10636:	4606      	mov	r6, r0
   10638:	460d      	mov	r5, r1
   1063a:	461c      	mov	r4, r3
	u8_t state;
	u8_t ack;

	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
		!mayfly_is_enabled(caller_id, callee_id) ||
   1063c:	b1a2      	cbz	r2, 10668 <mayfly_enqueue+0x34>
   1063e:	2301      	movs	r3, #1
		(mft[callee_id][caller_id].disable_req !=
		 mft[callee_id][caller_id].disable_ack);

	/* shadow the ack */
	ack = m->_ack;
   10640:	7862      	ldrb	r2, [r4, #1]

	/* already in queue */
	state = (m->_req - ack) & 0x03;
   10642:	7820      	ldrb	r0, [r4, #0]
   10644:	1a80      	subs	r0, r0, r2
	if (state != 0U) {
   10646:	f010 0003 	ands.w	r0, r0, #3
   1064a:	d02c      	beq.n	106a6 <mayfly_enqueue+0x72>
		if (chain) {
   1064c:	b31b      	cbz	r3, 10696 <mayfly_enqueue+0x62>
			if (state != 1U) {
   1064e:	2801      	cmp	r0, #1
   10650:	d028      	beq.n	106a4 <mayfly_enqueue+0x70>
				/* mark as ready in queue */
				m->_req = ack + 1;
   10652:	3201      	adds	r2, #1
   10654:	b2d2      	uxtb	r2, r2
   10656:	7022      	strb	r2, [r4, #0]
	m->_req = ack + 1;
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);

mayfly_enqueue_pend:
	/* set mayfly callee pending */
	mfp[callee_id] = 1U;
   10658:	4b1c      	ldr	r3, [pc, #112]	; (106cc <mayfly_enqueue+0x98>)
   1065a:	2201      	movs	r2, #1

	/* pend the callee for execution */
	mayfly_pend(caller_id, callee_id);
   1065c:	4629      	mov	r1, r5
   1065e:	4630      	mov	r0, r6
	mfp[callee_id] = 1U;
   10660:	555a      	strb	r2, [r3, r5]
	mayfly_pend(caller_id, callee_id);
   10662:	f008 fba1 	bl	18da8 <mayfly_pend>
   10666:	e01c      	b.n	106a2 <mayfly_enqueue+0x6e>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
   10668:	f014 fb60 	bl	24d2c <mayfly_prio_is_equal>
   1066c:	2800      	cmp	r0, #0
   1066e:	d0e6      	beq.n	1063e <mayfly_enqueue+0xa>
		!mayfly_is_enabled(caller_id, callee_id) ||
   10670:	4629      	mov	r1, r5
   10672:	4630      	mov	r0, r6
   10674:	f008 fb76 	bl	18d64 <mayfly_is_enabled>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
   10678:	2800      	cmp	r0, #0
   1067a:	d0e0      	beq.n	1063e <mayfly_enqueue+0xa>
		(mft[callee_id][caller_id].disable_req !=
   1067c:	2330      	movs	r3, #48	; 0x30
   1067e:	220c      	movs	r2, #12
   10680:	436b      	muls	r3, r5
   10682:	fb02 3306 	mla	r3, r2, r6, r3
   10686:	4a12      	ldr	r2, [pc, #72]	; (106d0 <mayfly_enqueue+0x9c>)
   10688:	441a      	add	r2, r3
		!mayfly_is_enabled(caller_id, callee_id) ||
   1068a:	7a93      	ldrb	r3, [r2, #10]
   1068c:	7ad2      	ldrb	r2, [r2, #11]
   1068e:	1a9b      	subs	r3, r3, r2
   10690:	bf18      	it	ne
   10692:	2301      	movne	r3, #1
   10694:	e7d4      	b.n	10640 <mayfly_enqueue+0xc>
		m->_req = ack + 2;
   10696:	3202      	adds	r2, #2
   10698:	b2d2      	uxtb	r2, r2
   1069a:	7022      	strb	r2, [r4, #0]
		m->fp(m->param);
   1069c:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
   106a0:	4798      	blx	r3

	return 0;
   106a2:	2000      	movs	r0, #0
}
   106a4:	bd70      	pop	{r4, r5, r6, pc}
	if (!chain) {
   106a6:	2b00      	cmp	r3, #0
   106a8:	d0f8      	beq.n	1069c <mayfly_enqueue+0x68>
	m->_req = ack + 1;
   106aa:	3201      	adds	r2, #1
   106ac:	b2d2      	uxtb	r2, r2
   106ae:	7022      	strb	r2, [r4, #0]
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
   106b0:	2304      	movs	r3, #4
   106b2:	2230      	movs	r2, #48	; 0x30
   106b4:	fb12 3205 	smlabb	r2, r2, r5, r3
   106b8:	230c      	movs	r3, #12
   106ba:	fb13 2306 	smlabb	r3, r3, r6, r2
   106be:	4a04      	ldr	r2, [pc, #16]	; (106d0 <mayfly_enqueue+0x9c>)
   106c0:	6860      	ldr	r0, [r4, #4]
   106c2:	441a      	add	r2, r3
   106c4:	4621      	mov	r1, r4
   106c6:	f013 fcd4 	bl	24072 <memq_enqueue>
   106ca:	e7c5      	b.n	10658 <mayfly_enqueue+0x24>
   106cc:	2000aa5c 	.word	0x2000aa5c
   106d0:	20000898 	.word	0x20000898

000106d4 <mayfly_run>:
		}
	}
}

void mayfly_run(u8_t callee_id)
{
   106d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8_t disable = 0U;
	u8_t enable = 0U;
	u8_t caller_id;

	if (!mfp[callee_id]) {
   106d8:	4b57      	ldr	r3, [pc, #348]	; (10838 <mayfly_run+0x164>)
   106da:	5c1a      	ldrb	r2, [r3, r0]
{
   106dc:	b089      	sub	sp, #36	; 0x24
   106de:	4605      	mov	r5, r0
	if (!mfp[callee_id]) {
   106e0:	2a00      	cmp	r2, #0
   106e2:	f000 80a2 	beq.w	1082a <mayfly_run+0x156>
		return;
	}
	mfp[callee_id] = 0U;
   106e6:	2600      	movs	r6, #0
   106e8:	541e      	strb	r6, [r3, r0]

	/* iterate through each caller queue to this callee_id */
	caller_id = MAYFLY_CALLER_COUNT;
	while (caller_id--) {
   106ea:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   106ee:	011b      	lsls	r3, r3, #4
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
   106f0:	f8df b148 	ldr.w	fp, [pc, #328]	; 1083c <mayfly_run+0x168>
   106f4:	9304      	str	r3, [sp, #16]
   106f6:	2404      	movs	r4, #4
   106f8:	233c      	movs	r3, #60	; 0x3c
   106fa:	fb13 4300 	smlabb	r3, r3, r0, r4
   106fe:	445b      	add	r3, fp
   10700:	9303      	str	r3, [sp, #12]
	u8_t disable = 0U;
   10702:	9600      	str	r6, [sp, #0]
   10704:	46d9      	mov	r9, fp
	while (caller_id--) {
   10706:	3c01      	subs	r4, #1
   10708:	b2e4      	uxtb	r4, r4
   1070a:	2cff      	cmp	r4, #255	; 0xff
   1070c:	d10c      	bne.n	10728 <mayfly_run+0x54>
			mft[callee_id][caller_id].enable_ack =
				mft[callee_id][caller_id].enable_req;
		}
	}

	if (disable && !enable) {
   1070e:	9b00      	ldr	r3, [sp, #0]
   10710:	2b00      	cmp	r3, #0
   10712:	f000 808a 	beq.w	1082a <mayfly_run+0x156>
   10716:	2e00      	cmp	r6, #0
   10718:	f040 8087 	bne.w	1082a <mayfly_run+0x156>
		mayfly_enable_cb(callee_id, callee_id, 0);
   1071c:	4632      	mov	r2, r6
   1071e:	4629      	mov	r1, r5
   10720:	4628      	mov	r0, r5
   10722:	f008 faff 	bl	18d24 <mayfly_enable_cb>
   10726:	e080      	b.n	1082a <mayfly_run+0x156>
		struct mayfly *m = 0;
   10728:	2300      	movs	r3, #0
		link = memq_peek(mft[callee_id][caller_id].head,
   1072a:	270c      	movs	r7, #12
		struct mayfly *m = 0;
   1072c:	9307      	str	r3, [sp, #28]
		link = memq_peek(mft[callee_id][caller_id].head,
   1072e:	4367      	muls	r7, r4
   10730:	2330      	movs	r3, #48	; 0x30
   10732:	fb03 7305 	mla	r3, r3, r5, r7
   10736:	eb09 0103 	add.w	r1, r9, r3
   1073a:	aa07      	add	r2, sp, #28
   1073c:	f859 0003 	ldr.w	r0, [r9, r3]
   10740:	6849      	ldr	r1, [r1, #4]
   10742:	f013 fc9d 	bl	24080 <memq_peek>
		memq_dequeue(mft[callee_id][caller_id].tail,
   10746:	9a04      	ldr	r2, [sp, #16]
   10748:	eb04 0344 	add.w	r3, r4, r4, lsl #1
   1074c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   10750:	444b      	add	r3, r9
   10752:	e9cd 7301 	strd	r7, r3, [sp, #4]
		link = memq_peek(mft[callee_id][caller_id].head,
   10756:	4682      	mov	sl, r0
		while (link) {
   10758:	f1ba 0f00 	cmp.w	sl, #0
   1075c:	d047      	beq.n	107ee <mayfly_run+0x11a>
			state = (m->_req - m->_ack) & 0x03;
   1075e:	9b07      	ldr	r3, [sp, #28]
   10760:	f893 8000 	ldrb.w	r8, [r3]
   10764:	785a      	ldrb	r2, [r3, #1]
   10766:	eba8 0802 	sub.w	r8, r8, r2
   1076a:	f008 0803 	and.w	r8, r8, #3
			if (state == 1U) {
   1076e:	f1b8 0f01 	cmp.w	r8, #1
   10772:	d104      	bne.n	1077e <mayfly_run+0xaa>
				m->_ack--;
   10774:	3a01      	subs	r2, #1
   10776:	705a      	strb	r2, [r3, #1]
				m->fp(m->param);
   10778:	e9d3 0202 	ldrd	r0, r2, [r3, #8]
   1077c:	4790      	blx	r2
			dequeue(callee_id, caller_id, link, m);
   1077e:	9f07      	ldr	r7, [sp, #28]
	req = m->_req;
   10780:	783b      	ldrb	r3, [r7, #0]
	if (((req - m->_ack) & 0x03) != 1U) {
   10782:	787a      	ldrb	r2, [r7, #1]
	req = m->_req;
   10784:	b2db      	uxtb	r3, r3
	if (((req - m->_ack) & 0x03) != 1U) {
   10786:	1a9a      	subs	r2, r3, r2
   10788:	f002 0203 	and.w	r2, r2, #3
   1078c:	2a01      	cmp	r2, #1
   1078e:	9305      	str	r3, [sp, #20]
   10790:	d01b      	beq.n	107ca <mayfly_run+0xf6>
		memq_dequeue(mft[callee_id][caller_id].tail,
   10792:	9b01      	ldr	r3, [sp, #4]
   10794:	9902      	ldr	r1, [sp, #8]
   10796:	2030      	movs	r0, #48	; 0x30
   10798:	fb00 3005 	mla	r0, r0, r5, r3
   1079c:	4b27      	ldr	r3, [pc, #156]	; (1083c <mayfly_run+0x168>)
   1079e:	4418      	add	r0, r3
   107a0:	2200      	movs	r2, #0
   107a2:	6840      	ldr	r0, [r0, #4]
   107a4:	f013 fc74 	bl	24090 <memq_dequeue>
		m->_ack = req;
   107a8:	9b05      	ldr	r3, [sp, #20]
		ack = m->_ack;
   107aa:	787a      	ldrb	r2, [r7, #1]
		m->_ack = req;
   107ac:	707b      	strb	r3, [r7, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
   107ae:	783b      	ldrb	r3, [r7, #0]
		m->_link = link;
   107b0:	f8c7 a004 	str.w	sl, [r7, #4]
		if (((m->_req - ack) & 0x03) == 1U) {
   107b4:	1a9b      	subs	r3, r3, r2
   107b6:	f003 0303 	and.w	r3, r3, #3
   107ba:	2b01      	cmp	r3, #1
   107bc:	d105      	bne.n	107ca <mayfly_run+0xf6>
			m->_ack = ack;
   107be:	707a      	strb	r2, [r7, #1]
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
   107c0:	4639      	mov	r1, r7
   107c2:	9a03      	ldr	r2, [sp, #12]
   107c4:	4650      	mov	r0, sl
   107c6:	f013 fc54 	bl	24072 <memq_enqueue>
			link = memq_peek(mft[callee_id][caller_id].head,
   107ca:	9a01      	ldr	r2, [sp, #4]
   107cc:	2330      	movs	r3, #48	; 0x30
   107ce:	fb03 2305 	mla	r3, r3, r5, r2
   107d2:	eb09 0103 	add.w	r1, r9, r3
   107d6:	aa07      	add	r2, sp, #28
   107d8:	6849      	ldr	r1, [r1, #4]
   107da:	f859 0003 	ldr.w	r0, [r9, r3]
   107de:	f013 fc4f 	bl	24080 <memq_peek>
			if (state == 1U) {
   107e2:	f1b8 0f01 	cmp.w	r8, #1
			link = memq_peek(mft[callee_id][caller_id].head,
   107e6:	4682      	mov	sl, r0
			if (state == 1U) {
   107e8:	d1b6      	bne.n	10758 <mayfly_run+0x84>
				if (caller_id || link) {
   107ea:	b9bc      	cbnz	r4, 1081c <mayfly_run+0x148>
   107ec:	b9b0      	cbnz	r0, 1081c <mayfly_run+0x148>
		if (mft[callee_id][caller_id].disable_req !=
   107ee:	2230      	movs	r2, #48	; 0x30
   107f0:	4912      	ldr	r1, [pc, #72]	; (1083c <mayfly_run+0x168>)
   107f2:	230c      	movs	r3, #12
   107f4:	436a      	muls	r2, r5
   107f6:	fb03 2204 	mla	r2, r3, r4, r2
   107fa:	440a      	add	r2, r1
   107fc:	7a91      	ldrb	r1, [r2, #10]
   107fe:	7ad0      	ldrb	r0, [r2, #11]
   10800:	4288      	cmp	r0, r1
   10802:	d115      	bne.n	10830 <mayfly_run+0x15c>
		if (mft[callee_id][caller_id].enable_req !=
   10804:	2230      	movs	r2, #48	; 0x30
   10806:	436a      	muls	r2, r5
   10808:	fb03 2304 	mla	r3, r3, r4, r2
   1080c:	445b      	add	r3, fp
   1080e:	7a1a      	ldrb	r2, [r3, #8]
   10810:	7a59      	ldrb	r1, [r3, #9]
   10812:	4291      	cmp	r1, r2
			mft[callee_id][caller_id].enable_ack =
   10814:	bf1c      	itt	ne
   10816:	725a      	strbne	r2, [r3, #9]
			enable = 1U;
   10818:	2601      	movne	r6, #1
   1081a:	e774      	b.n	10706 <mayfly_run+0x32>
					mfp[callee_id] = 1U;
   1081c:	4b06      	ldr	r3, [pc, #24]	; (10838 <mayfly_run+0x164>)
   1081e:	2201      	movs	r2, #1
					mayfly_pend(callee_id, callee_id);
   10820:	4629      	mov	r1, r5
   10822:	4628      	mov	r0, r5
					mfp[callee_id] = 1U;
   10824:	555a      	strb	r2, [r3, r5]
					mayfly_pend(callee_id, callee_id);
   10826:	f008 fabf 	bl	18da8 <mayfly_pend>
	}
}
   1082a:	b009      	add	sp, #36	; 0x24
   1082c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mft[callee_id][caller_id].disable_ack =
   10830:	72d1      	strb	r1, [r2, #11]
			disable = 1U;
   10832:	2201      	movs	r2, #1
   10834:	9200      	str	r2, [sp, #0]
   10836:	e7e5      	b.n	10804 <mayfly_run+0x130>
   10838:	2000aa5c 	.word	0x2000aa5c
   1083c:	20000898 	.word	0x20000898

00010840 <ticker_job>:
 * @param param Pointer to ticker instance
 *
 * @internal
 */
void ticker_job(void *param)
{
   10840:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8_t flag_compare_update;

	DEBUG_TICKER_JOB(1);

	/* Defer worker, as job is now running */
	if (instance->worker_trigger) {
   10844:	7fc2      	ldrb	r2, [r0, #31]
{
   10846:	b08f      	sub	sp, #60	; 0x3c
   10848:	4604      	mov	r4, r0
	if (instance->worker_trigger) {
   1084a:	2a00      	cmp	r2, #0
   1084c:	f040 830c 	bne.w	10e68 <ticker_job+0x628>
		return;
	}
	instance->job_guard = 1U;

	/* Back up the previous known tick */
	ticks_previous = instance->ticks_current;
   10850:	6943      	ldr	r3, [r0, #20]
   10852:	9304      	str	r3, [sp, #16]
	instance->job_guard = 1U;
   10854:	2101      	movs	r1, #1

	/* Update current tick with the elapsed value from queue, and dequeue */
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
   10856:	7a83      	ldrb	r3, [r0, #10]
	instance->job_guard = 1U;
   10858:	7781      	strb	r1, [r0, #30]
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
   1085a:	7ac0      	ldrb	r0, [r0, #11]
   1085c:	4298      	cmp	r0, r3
   1085e:	d077      	beq.n	10950 <ticker_job+0x110>
	u8_t idx = *ticks_elapsed_index + 1;
   10860:	440b      	add	r3, r1
   10862:	b2db      	uxtb	r3, r3
		idx = 0U;
   10864:	2b02      	cmp	r3, #2
   10866:	bf08      	it	eq
   10868:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
   1086a:	72a3      	strb	r3, [r4, #10]
		ticker_next_elapsed(&instance->ticks_elapsed_first);

		ticks_elapsed =
   1086c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
		    instance->ticks_elapsed[instance->ticks_elapsed_first];

		instance->ticks_current += ticks_elapsed;
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;

		flag_elapsed = 1U;
   10870:	9101      	str	r1, [sp, #4]
		ticks_elapsed =
   10872:	f8d3 a00c 	ldr.w	sl, [r3, #12]
		instance->ticks_current += ticks_elapsed;
   10876:	9b04      	ldr	r3, [sp, #16]
   10878:	4453      	add	r3, sl
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;
   1087a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   1087e:	6163      	str	r3, [r4, #20]
	flag_compare_update = 0U;

	/* Remember the old head, so as to decide if new compare needs to be
	 * set.
	 */
	ticker_id_old_head = instance->ticker_id_head;
   10880:	7f63      	ldrb	r3, [r4, #29]
   10882:	9303      	str	r3, [sp, #12]
	node = &instance->nodes[0];
   10884:	6823      	ldr	r3, [r4, #0]
   10886:	9305      	str	r3, [sp, #20]
	users = &instance->users[0];
   10888:	6863      	ldr	r3, [r4, #4]
   1088a:	930c      	str	r3, [sp, #48]	; 0x30
	count_user = instance->count_user;
   1088c:	7a63      	ldrb	r3, [r4, #9]
   1088e:	9302      	str	r3, [sp, #8]
	pending = 0U;
   10890:	2300      	movs	r3, #0
   10892:	9308      	str	r3, [sp, #32]
	insert_head = TICKER_NULL;
   10894:	f04f 0bff 	mov.w	fp, #255	; 0xff
	while (count_user--) {
   10898:	9b02      	ldr	r3, [sp, #8]
   1089a:	3b01      	subs	r3, #1
   1089c:	b2db      	uxtb	r3, r3
   1089e:	2bff      	cmp	r3, #255	; 0xff
   108a0:	9302      	str	r3, [sp, #8]
   108a2:	d158      	bne.n	10956 <ticker_job+0x116>

	/* Manage user operations (updates and deletions) in ticker list */
	pending = ticker_job_list_manage(instance, ticks_elapsed, &insert_head);

	/* Detect change in head of the list */
	if (instance->ticker_id_head != ticker_id_old_head) {
   108a4:	7f63      	ldrb	r3, [r4, #29]
		flag_compare_update = 1U;
   108a6:	9a03      	ldr	r2, [sp, #12]
   108a8:	1a9b      	subs	r3, r3, r2
   108aa:	bf18      	it	ne
   108ac:	2301      	movne	r3, #1
   108ae:	9302      	str	r3, [sp, #8]
	}

	/* Handle expired tickers */
	if (flag_elapsed) {
   108b0:	9b01      	ldr	r3, [sp, #4]
   108b2:	b1cb      	cbz	r3, 108e8 <ticker_job+0xa8>
   108b4:	f8d4 9000 	ldr.w	r9, [r4]
	ticks_expired = 0U;
   108b8:	f04f 0800 	mov.w	r8, #0
	while (instance->ticker_id_head != TICKER_NULL) {
   108bc:	7f66      	ldrb	r6, [r4, #29]
   108be:	2eff      	cmp	r6, #255	; 0xff
   108c0:	d00b      	beq.n	108da <ticker_job+0x9a>
		ticker = &node[id_expired];
   108c2:	272c      	movs	r7, #44	; 0x2c
   108c4:	fb16 f707 	smulbb	r7, r6, r7
   108c8:	eb09 0507 	add.w	r5, r9, r7
		ticks_to_expire = ticker->ticks_to_expire;
   108cc:	68aa      	ldr	r2, [r5, #8]
		if (ticks_elapsed < ticks_to_expire) {
   108ce:	4552      	cmp	r2, sl
   108d0:	f240 8105 	bls.w	10ade <ticker_job+0x29e>
			ticker->ticks_to_expire -= ticks_elapsed;
   108d4:	eba2 020a 	sub.w	r2, r2, sl
   108d8:	60aa      	str	r2, [r5, #8]
		ticker_job_worker_bh(instance, ticks_previous, ticks_elapsed,
				     &insert_head);

		/* detect change in head of the list */
		if (instance->ticker_id_head != ticker_id_old_head) {
			flag_compare_update = 1U;
   108da:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
   108de:	9903      	ldr	r1, [sp, #12]
   108e0:	42b1      	cmp	r1, r6
   108e2:	bf18      	it	ne
   108e4:	4613      	movne	r3, r2
   108e6:	9302      	str	r3, [sp, #8]
	node = &instance->nodes[0];
   108e8:	6823      	ldr	r3, [r4, #0]
   108ea:	9305      	str	r3, [sp, #20]
	users = &instance->users[0];
   108ec:	6863      	ldr	r3, [r4, #4]
   108ee:	930b      	str	r3, [sp, #44]	; 0x2c
	count_user = instance->count_user;
   108f0:	7a63      	ldrb	r3, [r4, #9]
   108f2:	9301      	str	r3, [sp, #4]
				ticker = &node[id_insert];
   108f4:	f04f 092c 	mov.w	r9, #44	; 0x2c
	while (count_user--) {
   108f8:	9b01      	ldr	r3, [sp, #4]
   108fa:	3b01      	subs	r3, #1
   108fc:	b2db      	uxtb	r3, r3
   108fe:	2bff      	cmp	r3, #255	; 0xff
   10900:	9301      	str	r3, [sp, #4]
   10902:	f040 8137 	bne.w	10b74 <ticker_job+0x334>
	/* Handle insertions */
	ticker_job_list_insert(instance, insert_head);

	/* detect change in head of the list */
	if (instance->ticker_id_head != ticker_id_old_head) {
		flag_compare_update = 1U;
   10906:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
	if (instance->ticker_id_head != ticker_id_old_head) {
   1090a:	7f63      	ldrb	r3, [r4, #29]
		flag_compare_update = 1U;
   1090c:	428b      	cmp	r3, r1
   1090e:	bf18      	it	ne
   10910:	2201      	movne	r2, #1
	}

	/* Process any list inquiries */
	if (!pending) {
   10912:	9b08      	ldr	r3, [sp, #32]
		flag_compare_update = 1U;
   10914:	9202      	str	r2, [sp, #8]
	if (!pending) {
   10916:	2b00      	cmp	r3, #0
   10918:	f000 81d7 	beq.w	10cca <ticker_job+0x48a>
		/* Handle inquiries */
		ticker_job_list_inquire(instance);
	}

	/* Permit worker job to run */
	instance->job_guard = 0U;
   1091c:	2300      	movs	r3, #0
   1091e:	77a3      	strb	r3, [r4, #30]

	/* update compare if head changed */
	if (flag_compare_update) {
   10920:	9b02      	ldr	r3, [sp, #8]
   10922:	b13b      	cbz	r3, 10934 <ticker_job+0xf4>
	if (instance->ticker_id_head == TICKER_NULL) {
   10924:	7f63      	ldrb	r3, [r4, #29]
   10926:	2bff      	cmp	r3, #255	; 0xff
   10928:	f040 823c 	bne.w	10da4 <ticker_job+0x564>
		if (cntr_stop() == 0) {
   1092c:	f007 fdba 	bl	184a4 <cntr_stop>
   10930:	b900      	cbnz	r0, 10934 <ticker_job+0xf4>
			instance->ticks_slot_previous = 0U;
   10932:	61a0      	str	r0, [r4, #24]
		ticker_job_compare_update(instance, ticker_id_old_head);
	}

	/* trigger worker if deferred */
	if (instance->worker_trigger) {
   10934:	7fe3      	ldrb	r3, [r4, #31]
   10936:	2b00      	cmp	r3, #0
   10938:	f000 8296 	beq.w	10e68 <ticker_job+0x628>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
   1093c:	6a65      	ldr	r5, [r4, #36]	; 0x24
   1093e:	4623      	mov	r3, r4
   10940:	2201      	movs	r2, #1
   10942:	2103      	movs	r1, #3
   10944:	2004      	movs	r0, #4
   10946:	46ac      	mov	ip, r5
				   instance);
	}

	DEBUG_TICKER_JOB(0);
}
   10948:	b00f      	add	sp, #60	; 0x3c
   1094a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
   1094e:	4760      	bx	ip
		flag_elapsed = 0U;
   10950:	9201      	str	r2, [sp, #4]
		ticks_elapsed = 0U;
   10952:	4692      	mov	sl, r2
   10954:	e794      	b.n	10880 <ticker_job+0x40>
		user = &users[count_user];
   10956:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   10958:	9a02      	ldr	r2, [sp, #8]
   1095a:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
		user_ops = &user->user_op[0];
   1095e:	687b      	ldr	r3, [r7, #4]
   10960:	9306      	str	r3, [sp, #24]
		while (user->middle != user->last) {
   10962:	78f9      	ldrb	r1, [r7, #3]
   10964:	f897 8002 	ldrb.w	r8, [r7, #2]
   10968:	4588      	cmp	r8, r1
   1096a:	d095      	beq.n	10898 <ticker_job+0x58>
			user_op = &user_ops[user->middle];
   1096c:	9b06      	ldr	r3, [sp, #24]
			if (middle == user->count_user_op) {
   1096e:	7838      	ldrb	r0, [r7, #0]
			user_op = &user_ops[user->middle];
   10970:	eb08 0248 	add.w	r2, r8, r8, lsl #1
   10974:	0112      	lsls	r2, r2, #4
   10976:	189e      	adds	r6, r3, r2
			middle = user->middle + 1;
   10978:	f108 0301 	add.w	r3, r8, #1
   1097c:	b2db      	uxtb	r3, r3
				middle = 0U;
   1097e:	4298      	cmp	r0, r3
   10980:	bf08      	it	eq
   10982:	2300      	moveq	r3, #0
			user->middle = middle;
   10984:	70bb      	strb	r3, [r7, #2]
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
   10986:	9b06      	ldr	r3, [sp, #24]
   10988:	5c9a      	ldrb	r2, [r3, r2]
   1098a:	2a04      	cmp	r2, #4
   1098c:	d9ea      	bls.n	10964 <ticker_job+0x124>
			ticker = &node[user_op->id];
   1098e:	7873      	ldrb	r3, [r6, #1]
   10990:	212c      	movs	r1, #44	; 0x2c
   10992:	fb13 f101 	smulbb	r1, r3, r1
   10996:	910b      	str	r1, [sp, #44]	; 0x2c
   10998:	980b      	ldr	r0, [sp, #44]	; 0x2c
   1099a:	9905      	ldr	r1, [sp, #20]
   1099c:	180d      	adds	r5, r1, r0
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP) ||
   1099e:	2a06      	cmp	r2, #6
			state = (ticker->req - ticker->ack) & 0xff;
   109a0:	78a9      	ldrb	r1, [r5, #2]
   109a2:	f895 c001 	ldrb.w	ip, [r5, #1]
   109a6:	9107      	str	r1, [sp, #28]
   109a8:	ebac 0c01 	sub.w	ip, ip, r1
   109ac:	fa5f f18c 	uxtb.w	r1, ip
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP) ||
   109b0:	d80e      	bhi.n	109d0 <ticker_job+0x190>
   109b2:	b169      	cbz	r1, 109d0 <ticker_job+0x190>
			    (state == 0U) ||
   109b4:	2a05      	cmp	r2, #5
   109b6:	d110      	bne.n	109da <ticker_job+0x19a>
			    ((user_op->op == TICKER_USER_OP_TYPE_UPDATE) &&
   109b8:	6870      	ldr	r0, [r6, #4]
   109ba:	b970      	cbnz	r0, 109da <ticker_job+0x19a>
			     (user_op->params.update.ticks_drift_plus == 0U) &&
   109bc:	68b0      	ldr	r0, [r6, #8]
   109be:	b960      	cbnz	r0, 109da <ticker_job+0x19a>
			     (user_op->params.update.ticks_drift_minus == 0U) &&
   109c0:	68f0      	ldr	r0, [r6, #12]
   109c2:	b950      	cbnz	r0, 109da <ticker_job+0x19a>
			     (user_op->params.update.ticks_slot_plus == 0U) &&
   109c4:	6930      	ldr	r0, [r6, #16]
   109c6:	b940      	cbnz	r0, 109da <ticker_job+0x19a>
			     (user_op->params.update.lazy == 0U) &&
   109c8:	6970      	ldr	r0, [r6, #20]
   109ca:	f030 407f 	bics.w	r0, r0, #4278190080	; 0xff000000
   109ce:	d104      	bne.n	109da <ticker_job+0x19a>
				ticker_job_op_cb(user_op,
   109d0:	2101      	movs	r1, #1
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
   109d2:	4630      	mov	r0, r6
   109d4:	f013 fb9c 	bl	24110 <ticker_job_op_cb>
   109d8:	e7c3      	b.n	10962 <ticker_job+0x122>
			if (state == 1U) {
   109da:	2901      	cmp	r1, #1
   109dc:	d174      	bne.n	10ac8 <ticker_job+0x288>
	previous = instance->ticker_id_head;
   109de:	f894 c01d 	ldrb.w	ip, [r4, #29]
	node = &instance->nodes[0];
   109e2:	6821      	ldr	r1, [r4, #0]
	previous = instance->ticker_id_head;
   109e4:	46e6      	mov	lr, ip
	total = 0U;
   109e6:	f04f 0800 	mov.w	r8, #0
	while (current != TICKER_NULL) {
   109ea:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
   109ee:	d146      	bne.n	10a7e <ticker_job+0x23e>
		return 0;
   109f0:	f04f 0800 	mov.w	r8, #0
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
   109f4:	2a05      	cmp	r2, #5
	ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
   109f6:	f8c5 8008 	str.w	r8, [r5, #8]
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
   109fa:	d151      	bne.n	10aa0 <ticker_job+0x260>
		ticker_job_node_update(ticker, user_op, instance->ticks_current,
   109fc:	f8d4 9014 	ldr.w	r9, [r4, #20]
	ticks_now = cntr_cnt_get();
   10a00:	f007 fd76 	bl	184f0 <cntr_cnt_get>
 * @param ticks_now Highest tick count (now)
 * @param ticks_old Tick count to subtract from ticks_now
 */
u32_t ticker_ticks_diff_get(u32_t ticks_now, u32_t ticks_old)
{
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   10a04:	eba0 0109 	sub.w	r1, r0, r9
   10a08:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
   10a0c:	4451      	add	r1, sl
	if (ticks_to_expire > ticks_elapsed) {
   10a0e:	4588      	cmp	r8, r1
		ticker->ticks_to_expire_minus += ticks_elapsed -
   10a10:	bf98      	it	ls
   10a12:	696b      	ldrls	r3, [r5, #20]
	ticks_now = cntr_cnt_get();
   10a14:	4602      	mov	r2, r0
		ticker->ticks_to_expire_minus += ticks_elapsed -
   10a16:	bf98      	it	ls
   10a18:	eba3 0808 	subls.w	r8, r3, r8
	if ((ticker->ticks_periodic != 0U) &&
   10a1c:	6868      	ldr	r0, [r5, #4]
		ticker->ticks_to_expire_minus += ticks_elapsed -
   10a1e:	bf97      	itett	ls
   10a20:	4441      	addls	r1, r8
		ticks_to_expire -= ticks_elapsed;
   10a22:	eba8 0801 	subhi.w	r8, r8, r1
		ticker->ticks_to_expire_minus += ticks_elapsed -
   10a26:	6169      	strls	r1, [r5, #20]
		ticks_to_expire = 0U;
   10a28:	f04f 0800 	movls.w	r8, #0
	if ((ticker->ticks_periodic != 0U) &&
   10a2c:	b128      	cbz	r0, 10a3a <ticker_job+0x1fa>
	    (user_op->params.update.lazy != 0U)) {
   10a2e:	8ab3      	ldrh	r3, [r6, #20]
	if ((ticker->ticks_periodic != 0U) &&
   10a30:	b11b      	cbz	r3, 10a3a <ticker_job+0x1fa>
		user_op->params.update.lazy--;
   10a32:	3b01      	subs	r3, #1
   10a34:	b29b      	uxth	r3, r3
   10a36:	82b3      	strh	r3, [r6, #20]
		ticker->lazy_periodic = user_op->params.update.lazy;
   10a38:	83ab      	strh	r3, [r5, #28]
	ticker->ticks_to_expire = ticks_to_expire +
   10a3a:	6871      	ldr	r1, [r6, #4]
	ticker->ticks_to_expire_minus +=
   10a3c:	696b      	ldr	r3, [r5, #20]
	ticker->ticks_to_expire = ticks_to_expire +
   10a3e:	4441      	add	r1, r8
   10a40:	60a9      	str	r1, [r5, #8]
	ticker->ticks_to_expire_minus +=
   10a42:	68b1      	ldr	r1, [r6, #8]
   10a44:	440b      	add	r3, r1
   10a46:	616b      	str	r3, [r5, #20]
	ticks_to_expire_prep(ticker, ticks_current, ticks_now);
   10a48:	4649      	mov	r1, r9
   10a4a:	4628      	mov	r0, r5
   10a4c:	f013 fb42 	bl	240d4 <ticks_to_expire_prep>
	ticker->ticks_slot += user_op->params.update.ticks_slot_plus;
   10a50:	68f2      	ldr	r2, [r6, #12]
   10a52:	69ab      	ldr	r3, [r5, #24]
   10a54:	4413      	add	r3, r2
	if (ticker->ticks_slot > user_op->params.update.ticks_slot_minus) {
   10a56:	6932      	ldr	r2, [r6, #16]
   10a58:	4293      	cmp	r3, r2
		ticker->ticks_slot -= user_op->params.update.ticks_slot_minus;
   10a5a:	bf8c      	ite	hi
   10a5c:	1a9b      	subhi	r3, r3, r2
		ticker->ticks_slot = 0U;
   10a5e:	2300      	movls	r3, #0
   10a60:	61ab      	str	r3, [r5, #24]
	if (user_op->params.update.force != 0U) {
   10a62:	7db3      	ldrb	r3, [r6, #22]
   10a64:	b103      	cbz	r3, 10a68 <ticker_job+0x228>
		ticker->force = user_op->params.update.force;
   10a66:	70eb      	strb	r3, [r5, #3]
	ticker->next = *insert_head;
   10a68:	9b05      	ldr	r3, [sp, #20]
   10a6a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   10a6c:	f803 b002 	strb.w	fp, [r3, r2]
		ticker->req++;
   10a70:	786b      	ldrb	r3, [r5, #1]
	*insert_head = user_op->id;
   10a72:	f896 b001 	ldrb.w	fp, [r6, #1]
		ticker->req++;
   10a76:	3301      	adds	r3, #1
   10a78:	706b      	strb	r3, [r5, #1]
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
   10a7a:	2100      	movs	r1, #0
   10a7c:	e7a9      	b.n	109d2 <ticker_job+0x192>
		ticker_current = &node[current];
   10a7e:	202c      	movs	r0, #44	; 0x2c
   10a80:	fb1c f900 	smulbb	r9, ip, r0
   10a84:	eb01 0009 	add.w	r0, r1, r9
   10a88:	9009      	str	r0, [sp, #36]	; 0x24
		if (current == id) {
   10a8a:	6880      	ldr	r0, [r0, #8]
   10a8c:	900a      	str	r0, [sp, #40]	; 0x28
   10a8e:	4563      	cmp	r3, ip
   10a90:	4480      	add	r8, r0
   10a92:	f811 9009 	ldrb.w	r9, [r1, r9]
   10a96:	f000 81cd 	beq.w	10e34 <ticker_job+0x5f4>
   10a9a:	46e6      	mov	lr, ip
   10a9c:	46cc      	mov	ip, r9
   10a9e:	e7a4      	b.n	109ea <ticker_job+0x1aa>
		ticker->req = ticker->ack;
   10aa0:	9a07      	ldr	r2, [sp, #28]
   10aa2:	706a      	strb	r2, [r5, #1]
		if (instance->ticker_id_slot_previous == user_op->id) {
   10aa4:	7f22      	ldrb	r2, [r4, #28]
   10aa6:	429a      	cmp	r2, r3
   10aa8:	d1e7      	bne.n	10a7a <ticker_job+0x23a>
			u32_t ticks_now = cntr_cnt_get();
   10aaa:	f007 fd21 	bl	184f0 <cntr_cnt_get>
			instance->ticker_id_slot_previous = TICKER_NULL;
   10aae:	23ff      	movs	r3, #255	; 0xff
   10ab0:	7723      	strb	r3, [r4, #28]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   10ab2:	6963      	ldr	r3, [r4, #20]
   10ab4:	1ac0      	subs	r0, r0, r3
   10ab6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticks_used = ticks_elapsed +
   10aba:	4450      	add	r0, sl
			instance->ticks_slot_previous =	MIN(ticker->ticks_slot,
   10abc:	69ab      	ldr	r3, [r5, #24]
   10abe:	4298      	cmp	r0, r3
   10ac0:	bf94      	ite	ls
   10ac2:	61a0      	strls	r0, [r4, #24]
   10ac4:	61a3      	strhi	r3, [r4, #24]
   10ac6:	e7d8      	b.n	10a7a <ticker_job+0x23a>
				instance->sched_cb(TICKER_CALL_ID_JOB,
   10ac8:	2104      	movs	r1, #4
   10aca:	4623      	mov	r3, r4
   10acc:	6a65      	ldr	r5, [r4, #36]	; 0x24
   10ace:	2201      	movs	r2, #1
   10ad0:	4608      	mov	r0, r1
   10ad2:	47a8      	blx	r5
				pending = 1U;
   10ad4:	2301      	movs	r3, #1
				user->middle = prev;
   10ad6:	f887 8002 	strb.w	r8, [r7, #2]
				pending = 1U;
   10ada:	9308      	str	r3, [sp, #32]
   10adc:	e6dc      	b.n	10898 <ticker_job+0x58>
		if (ticker->lazy_current != 0U) {
   10ade:	8be8      	ldrh	r0, [r5, #30]
		ticks_elapsed -= ticks_to_expire;
   10ae0:	ebaa 0a02 	sub.w	sl, sl, r2
		ticks_expired += ticks_to_expire;
   10ae4:	4490      	add	r8, r2
		if (ticker->lazy_current != 0U) {
   10ae6:	2800      	cmp	r0, #0
   10ae8:	d032      	beq.n	10b50 <ticker_job+0x310>
			instance->ticker_id_slot_previous = TICKER_NULL;
   10aea:	22ff      	movs	r2, #255	; 0xff
   10aec:	7722      	strb	r2, [r4, #28]
			instance->ticks_slot_previous = 0U;
   10aee:	2200      	movs	r2, #0
				instance->ticks_slot_previous =
   10af0:	61a2      	str	r2, [r4, #24]
		ticker->ticks_to_expire = 0U;
   10af2:	f04f 0c00 	mov.w	ip, #0
   10af6:	f8c5 c008 	str.w	ip, [r5, #8]
		instance->ticker_id_head = ticker->next;
   10afa:	f819 1007 	ldrb.w	r1, [r9, r7]
   10afe:	7761      	strb	r1, [r4, #29]
		if (ticker->ticks_periodic != 0U) {
   10b00:	686b      	ldr	r3, [r5, #4]
   10b02:	2b00      	cmp	r3, #0
   10b04:	d032      	beq.n	10b6c <ticker_job+0x32c>
	ticker->remainder_current += ticker->remainder_periodic;
   10b06:	e9d5 0108 	ldrd	r0, r1, [r5, #32]
   10b0a:	4401      	add	r1, r0
	if ((ticker->remainder_current < BIT(31)) &&
   10b0c:	48a3      	ldr	r0, [pc, #652]	; (10d9c <ticker_job+0x55c>)
   10b0e:	4aa4      	ldr	r2, [pc, #656]	; (10da0 <ticker_job+0x560>)
			ticker->ticks_to_expire  = ticker->ticks_periodic;
   10b10:	60ab      	str	r3, [r5, #8]
	if ((ticker->remainder_current < BIT(31)) &&
   10b12:	1808      	adds	r0, r1, r0
   10b14:	4290      	cmp	r0, r2
		return 1;
   10b16:	bf95      	itete	ls
   10b18:	9a01      	ldrls	r2, [sp, #4]
	ticker->remainder_current += ticker->remainder_periodic;
   10b1a:	6269      	strhi	r1, [r5, #36]	; 0x24
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   10b1c:	f1a1 71e8 	subls.w	r1, r1, #30408704	; 0x1d00000
	return 0;
   10b20:	4662      	movhi	r2, ip
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   10b22:	bf98      	it	ls
   10b24:	f5a1 31d4 	subls.w	r1, r1, #108544	; 0x1a800
			ticker->ticks_to_expire += ticker_remainder_inc(ticker);
   10b28:	441a      	add	r2, r3
			ticks_to_expire_prep(ticker, instance->ticks_current,
   10b2a:	9b04      	ldr	r3, [sp, #16]
			ticker->ticks_to_expire += ticker_remainder_inc(ticker);
   10b2c:	60aa      	str	r2, [r5, #8]
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   10b2e:	bf9c      	itt	ls
   10b30:	f5a1 71a5 	subls.w	r1, r1, #330	; 0x14a
   10b34:	6269      	strls	r1, [r5, #36]	; 0x24
			ticks_to_expire_prep(ticker, instance->ticks_current,
   10b36:	eb03 0208 	add.w	r2, r3, r8
   10b3a:	6961      	ldr	r1, [r4, #20]
   10b3c:	4628      	mov	r0, r5
   10b3e:	f013 fac9 	bl	240d4 <ticks_to_expire_prep>
			ticker->next = *insert_head;
   10b42:	f809 b007 	strb.w	fp, [r9, r7]
			ticker->req++;
   10b46:	786a      	ldrb	r2, [r5, #1]
   10b48:	3201      	adds	r2, #1
   10b4a:	706a      	strb	r2, [r5, #1]
			ticker->req = ticker->ack;
   10b4c:	46b3      	mov	fp, r6
   10b4e:	e6b5      	b.n	108bc <ticker_job+0x7c>
			if (instance->ticks_slot_previous > ticks_to_expire) {
   10b50:	69a1      	ldr	r1, [r4, #24]
   10b52:	428a      	cmp	r2, r1
				instance->ticker_id_slot_previous = TICKER_NULL;
   10b54:	bf2b      	itete	cs
   10b56:	22ff      	movcs	r2, #255	; 0xff
				instance->ticks_slot_previous -=
   10b58:	1a8a      	subcc	r2, r1, r2
				instance->ticker_id_slot_previous = TICKER_NULL;
   10b5a:	7722      	strbcs	r2, [r4, #28]
				instance->ticks_slot_previous -=
   10b5c:	61a2      	strcc	r2, [r4, #24]
			if (ticker->ticks_slot != 0U) {
   10b5e:	69aa      	ldr	r2, [r5, #24]
				instance->ticks_slot_previous = 0U;
   10b60:	bf28      	it	cs
   10b62:	61a0      	strcs	r0, [r4, #24]
			if (ticker->ticks_slot != 0U) {
   10b64:	2a00      	cmp	r2, #0
   10b66:	d0c4      	beq.n	10af2 <ticker_job+0x2b2>
				instance->ticker_id_slot_previous = id_expired;
   10b68:	7726      	strb	r6, [r4, #28]
   10b6a:	e7c1      	b.n	10af0 <ticker_job+0x2b0>
			ticker->req = ticker->ack;
   10b6c:	78aa      	ldrb	r2, [r5, #2]
   10b6e:	706a      	strb	r2, [r5, #1]
   10b70:	465e      	mov	r6, fp
   10b72:	e7eb      	b.n	10b4c <ticker_job+0x30c>
		user = &users[count_user];
   10b74:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   10b76:	9a01      	ldr	r2, [sp, #4]
   10b78:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   10b7c:	9304      	str	r3, [sp, #16]
		user_ops = (void *)&user->user_op[0];
   10b7e:	685b      	ldr	r3, [r3, #4]
   10b80:	9307      	str	r3, [sp, #28]
		user_ops_first = user->first;
   10b82:	9b04      	ldr	r3, [sp, #16]
   10b84:	785f      	ldrb	r7, [r3, #1]
		while ((insert_head != TICKER_NULL) ||
   10b86:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
   10b8a:	d05e      	beq.n	10c4a <ticker_job+0x40a>
				ticker = &node[id_insert];
   10b8c:	fb1b f309 	smulbb	r3, fp, r9
   10b90:	9a05      	ldr	r2, [sp, #20]
				insert_head = ticker->next;
   10b92:	46da      	mov	sl, fp
   10b94:	f812 b003 	ldrb.w	fp, [r2, r3]
				ticker = &node[id_insert];
   10b98:	18d5      	adds	r5, r2, r3
				user_op = NULL;
   10b9a:	2600      	movs	r6, #0
	ticker->next = TICKER_NULL;
   10b9c:	22ff      	movs	r2, #255	; 0xff
   10b9e:	702a      	strb	r2, [r5, #0]
	node = &instance->nodes[0];
   10ba0:	6820      	ldr	r0, [r4, #0]
	previous = TICKER_NULL;
   10ba2:	9206      	str	r2, [sp, #24]
	ticker_new = &node[id];
   10ba4:	fb1a f309 	smulbb	r3, sl, r9
   10ba8:	eb00 0e03 	add.w	lr, r0, r3
   10bac:	9309      	str	r3, [sp, #36]	; 0x24
	ticks_to_expire = ticker_new->ticks_to_expire;
   10bae:	f8de 1008 	ldr.w	r1, [lr, #8]
	current = instance->ticker_id_head;
   10bb2:	7f63      	ldrb	r3, [r4, #29]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
   10bb4:	2bff      	cmp	r3, #255	; 0xff
   10bb6:	d008      	beq.n	10bca <ticker_job+0x38a>
		(ticker_current = &node[current])->ticks_to_expire))) {
   10bb8:	fb13 f209 	smulbb	r2, r3, r9
   10bbc:	920a      	str	r2, [sp, #40]	; 0x28
   10bbe:	1882      	adds	r2, r0, r2
   10bc0:	4690      	mov	r8, r2
		(ticks_to_expire_current =
   10bc2:	f8d2 c008 	ldr.w	ip, [r2, #8]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
   10bc6:	4561      	cmp	r1, ip
   10bc8:	d26b      	bcs.n	10ca2 <ticker_job+0x462>
	ticker_new->next = current;
   10bca:	9a09      	ldr	r2, [sp, #36]	; 0x24
	ticker_new->ticks_to_expire = ticks_to_expire;
   10bcc:	f8ce 1008 	str.w	r1, [lr, #8]
	ticker_new->next = current;
   10bd0:	5483      	strb	r3, [r0, r2]
	if (previous == TICKER_NULL) {
   10bd2:	9a06      	ldr	r2, [sp, #24]
   10bd4:	2aff      	cmp	r2, #255	; 0xff
		node[previous].next = id;
   10bd6:	bf17      	itett	ne
   10bd8:	9a06      	ldrne	r2, [sp, #24]
		instance->ticker_id_head = id;
   10bda:	f884 a01d 	strbeq.w	sl, [r4, #29]
		node[previous].next = id;
   10bde:	fb12 f209 	smulbbne	r2, r2, r9
   10be2:	f800 a002 	strbne.w	sl, [r0, r2]
	if (current != TICKER_NULL) {
   10be6:	2bff      	cmp	r3, #255	; 0xff
		node[current].ticks_to_expire -= ticks_to_expire;
   10be8:	bf1f      	itttt	ne
   10bea:	fb03 0309 	mlane	r3, r3, r9, r0
   10bee:	689a      	ldrne	r2, [r3, #8]
   10bf0:	1a51      	subne	r1, r2, r1
   10bf2:	6099      	strne	r1, [r3, #8]
	ticker->req = ticker->ack + 1;
   10bf4:	78ab      	ldrb	r3, [r5, #2]
   10bf6:	3301      	adds	r3, #1
   10bf8:	706b      	strb	r3, [r5, #1]
			if (user_op) {
   10bfa:	2e00      	cmp	r6, #0
   10bfc:	d0c3      	beq.n	10b86 <ticker_job+0x346>
				ticker_job_op_cb(user_op, status);
   10bfe:	2100      	movs	r1, #0
   10c00:	4630      	mov	r0, r6
   10c02:	f013 fa85 	bl	24110 <ticker_job_op_cb>
   10c06:	e7be      	b.n	10b86 <ticker_job+0x346>
				user_op = &user_ops[user_ops_first];
   10c08:	eb07 0347 	add.w	r3, r7, r7, lsl #1
   10c0c:	9a07      	ldr	r2, [sp, #28]
   10c0e:	011b      	lsls	r3, r3, #4
   10c10:	18d6      	adds	r6, r2, r3
				if (first == user->count_user_op) {
   10c12:	9a04      	ldr	r2, [sp, #16]
				first = user_ops_first + 1;
   10c14:	3701      	adds	r7, #1
				if (first == user->count_user_op) {
   10c16:	7812      	ldrb	r2, [r2, #0]
				first = user_ops_first + 1;
   10c18:	b2ff      	uxtb	r7, r7
					first = 0U;
   10c1a:	42ba      	cmp	r2, r7
   10c1c:	bf08      	it	eq
   10c1e:	2700      	moveq	r7, #0
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
   10c20:	9a07      	ldr	r2, [sp, #28]
   10c22:	5cd3      	ldrb	r3, [r2, r3]
   10c24:	2b04      	cmp	r3, #4
   10c26:	d110      	bne.n	10c4a <ticker_job+0x40a>
				ticker = &node[id_insert];
   10c28:	9b05      	ldr	r3, [sp, #20]
				id_insert = user_op->id;
   10c2a:	f896 a001 	ldrb.w	sl, [r6, #1]
				ticker = &node[id_insert];
   10c2e:	fb0a 3509 	mla	r5, sl, r9, r3
				if (((ticker->req -
   10c32:	f895 8001 	ldrb.w	r8, [r5, #1]
				      ticker->ack) & 0xff) != 0U) {
   10c36:	78ab      	ldrb	r3, [r5, #2]
				if (((ticker->req -
   10c38:	eba8 0803 	sub.w	r8, r8, r3
   10c3c:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
   10c40:	d008      	beq.n	10c54 <ticker_job+0x414>
					ticker_job_op_cb(user_op,
   10c42:	2101      	movs	r1, #1
   10c44:	4630      	mov	r0, r6
   10c46:	f013 fa63 	bl	24110 <ticker_job_op_cb>
		while ((insert_head != TICKER_NULL) ||
   10c4a:	9b04      	ldr	r3, [sp, #16]
   10c4c:	789b      	ldrb	r3, [r3, #2]
   10c4e:	42bb      	cmp	r3, r7
   10c50:	d1da      	bne.n	10c08 <ticker_job+0x3c8>
   10c52:	e651      	b.n	108f8 <ticker_job+0xb8>
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
   10c54:	8ab3      	ldrh	r3, [r6, #20]
				ticker_job_op_start(ticker, user_op,
   10c56:	6961      	ldr	r1, [r4, #20]
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
   10c58:	f64f 72ff 	movw	r2, #65535	; 0xffff
   10c5c:	4293      	cmp	r3, r2
   10c5e:	bf0c      	ite	eq
   10c60:	2201      	moveq	r2, #1
   10c62:	2200      	movne	r2, #0
   10c64:	f885 2028 	strb.w	r2, [r5, #40]	; 0x28
	ticker->ticks_periodic = start->ticks_periodic;
   10c68:	68f2      	ldr	r2, [r6, #12]
   10c6a:	606a      	str	r2, [r5, #4]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
   10c6c:	bf08      	it	eq
   10c6e:	2300      	moveq	r3, #0
	ticker->remainder_periodic = start->remainder_periodic;
   10c70:	6932      	ldr	r2, [r6, #16]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
   10c72:	83ab      	strh	r3, [r5, #28]
	ticker->ticks_slot = start->ticks_slot;
   10c74:	69b3      	ldr	r3, [r6, #24]
   10c76:	61ab      	str	r3, [r5, #24]
	ticker->timeout_func = start->fp_timeout_func;
   10c78:	69f3      	ldr	r3, [r6, #28]
   10c7a:	60eb      	str	r3, [r5, #12]
	ticker->context = start->context;
   10c7c:	6a33      	ldr	r3, [r6, #32]
   10c7e:	612b      	str	r3, [r5, #16]
	ticker->ticks_to_expire = start->ticks_first;
   10c80:	68b3      	ldr	r3, [r6, #8]
	ticker->remainder_periodic = start->remainder_periodic;
   10c82:	622a      	str	r2, [r5, #32]
	ticker->ticks_to_expire = start->ticks_first;
   10c84:	60ab      	str	r3, [r5, #8]
	ticker->ticks_to_expire_minus = 0U;
   10c86:	f8c5 8014 	str.w	r8, [r5, #20]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
   10c8a:	6872      	ldr	r2, [r6, #4]
   10c8c:	4628      	mov	r0, r5
   10c8e:	f013 fa21 	bl	240d4 <ticks_to_expire_prep>
	ticker->force = 1U;
   10c92:	f04f 0301 	mov.w	r3, #1
	ticker->remainder_current = 0U;
   10c96:	f8c5 8024 	str.w	r8, [r5, #36]	; 0x24
	ticker->lazy_current = 0U;
   10c9a:	f8a5 801e 	strh.w	r8, [r5, #30]
	ticker->force = 1U;
   10c9e:	70eb      	strb	r3, [r5, #3]
   10ca0:	e77c      	b.n	10b9c <ticker_job+0x35c>
		if (ticks_to_expire == 0 && (ticker_new->lazy_current >
   10ca2:	ebb1 010c 	subs.w	r1, r1, ip
   10ca6:	d10a      	bne.n	10cbe <ticker_job+0x47e>
   10ca8:	f8be 201e 	ldrh.w	r2, [lr, #30]
   10cac:	920c      	str	r2, [sp, #48]	; 0x30
   10cae:	f8b8 201e 	ldrh.w	r2, [r8, #30]
   10cb2:	920d      	str	r2, [sp, #52]	; 0x34
   10cb4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   10cb6:	4690      	mov	r8, r2
   10cb8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   10cba:	4590      	cmp	r8, r2
   10cbc:	d803      	bhi.n	10cc6 <ticker_job+0x486>
		current = ticker_current->next;
   10cbe:	9306      	str	r3, [sp, #24]
   10cc0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   10cc2:	5cc3      	ldrb	r3, [r0, r3]
   10cc4:	e776      	b.n	10bb4 <ticker_job+0x374>
		(ticks_to_expire_current =
   10cc6:	4661      	mov	r1, ip
   10cc8:	e77f      	b.n	10bca <ticker_job+0x38a>
	users = &instance->users[0];
   10cca:	6863      	ldr	r3, [r4, #4]
	count_user = instance->count_user;
   10ccc:	7a65      	ldrb	r5, [r4, #9]
	users = &instance->users[0];
   10cce:	9301      	str	r3, [sp, #4]
	       ((ticker = &node[_ticker_id_head])->ticks_slot == 0U)) {
   10cd0:	272c      	movs	r7, #44	; 0x2c
	while (count_user--) {
   10cd2:	3d01      	subs	r5, #1
   10cd4:	b2ed      	uxtb	r5, r5
   10cd6:	2dff      	cmp	r5, #255	; 0xff
   10cd8:	f43f ae20 	beq.w	1091c <ticker_job+0xdc>
		user = &users[count_user];
   10cdc:	9b01      	ldr	r3, [sp, #4]
   10cde:	eb03 06c5 	add.w	r6, r3, r5, lsl #3
		user_op = &user->user_op[0];
   10ce2:	f8d6 8004 	ldr.w	r8, [r6, #4]
		while (user->first != user->last) {
   10ce6:	7873      	ldrb	r3, [r6, #1]
   10ce8:	78f2      	ldrb	r2, [r6, #3]
   10cea:	429a      	cmp	r2, r3
   10cec:	d0f1      	beq.n	10cd2 <ticker_job+0x492>
			ticker_job_op_inquire(instance, &user_op[user->first]);
   10cee:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   10cf2:	011a      	lsls	r2, r3, #4
   10cf4:	eb08 0302 	add.w	r3, r8, r2
	switch (uop->op) {
   10cf8:	f818 2002 	ldrb.w	r2, [r8, r2]
   10cfc:	2a02      	cmp	r2, #2
   10cfe:	d013      	beq.n	10d28 <ticker_job+0x4e8>
   10d00:	2a03      	cmp	r2, #3
   10d02:	d03e      	beq.n	10d82 <ticker_job+0x542>
   10d04:	2a01      	cmp	r2, #1
   10d06:	d106      	bne.n	10d16 <ticker_job+0x4d6>
			uop->status = TICKER_STATUS_SUCCESS;
   10d08:	2200      	movs	r2, #0
			uop->status = TICKER_STATUS_FAILURE;
   10d0a:	625a      	str	r2, [r3, #36]	; 0x24
		fp_op_func = uop->fp_op_func;
   10d0c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if (fp_op_func) {
   10d0e:	b112      	cbz	r2, 10d16 <ticker_job+0x4d6>
		fp_op_func(uop->status, uop->op_context);
   10d10:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
   10d12:	6a58      	ldr	r0, [r3, #36]	; 0x24
   10d14:	4790      	blx	r2
			first = user->first + 1;
   10d16:	7873      	ldrb	r3, [r6, #1]
			if (first == user->count_user_op) {
   10d18:	7832      	ldrb	r2, [r6, #0]
			first = user->first + 1;
   10d1a:	3301      	adds	r3, #1
   10d1c:	b2db      	uxtb	r3, r3
				first = 0U;
   10d1e:	429a      	cmp	r2, r3
   10d20:	bf08      	it	eq
   10d22:	2300      	moveq	r3, #0
			user->first = first;
   10d24:	7073      	strb	r3, [r6, #1]
   10d26:	e7de      	b.n	10ce6 <ticker_job+0x4a6>
		ticker_by_next_slot_get(instance,
   10d28:	e9d3 9001 	ldrd	r9, r0, [r3, #4]
	_ticker_id_head = *ticker_id_head;
   10d2c:	f899 a000 	ldrb.w	sl, [r9]
		ticker_by_next_slot_get(instance,
   10d30:	f8d3 e00c 	ldr.w	lr, [r3, #12]
	node = instance->nodes;
   10d34:	f8d4 c000 	ldr.w	ip, [r4]
	if ((_ticker_id_head == TICKER_NULL) ||
   10d38:	6961      	ldr	r1, [r4, #20]
   10d3a:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
   10d3e:	d002      	beq.n	10d46 <ticker_job+0x506>
   10d40:	6802      	ldr	r2, [r0, #0]
   10d42:	428a      	cmp	r2, r1
   10d44:	d013      	beq.n	10d6e <ticker_job+0x52e>
		_ticker_id_head = instance->ticker_id_head;
   10d46:	7f62      	ldrb	r2, [r4, #29]
		*ticks_current = instance->ticks_current;
   10d48:	6001      	str	r1, [r0, #0]
		_ticks_to_expire = 0U;
   10d4a:	2100      	movs	r1, #0
	while ((_ticker_id_head != TICKER_NULL) &&
   10d4c:	2aff      	cmp	r2, #255	; 0xff
   10d4e:	d009      	beq.n	10d64 <ticker_job+0x524>
	       ((ticker = &node[_ticker_id_head])->ticks_slot == 0U)) {
   10d50:	fb12 fb07 	smulbb	fp, r2, r7
   10d54:	eb0c 0a0b 	add.w	sl, ip, fp
   10d58:	f8da 0008 	ldr.w	r0, [sl, #8]
   10d5c:	4401      	add	r1, r0
	while ((_ticker_id_head != TICKER_NULL) &&
   10d5e:	f8da 0018 	ldr.w	r0, [sl, #24]
   10d62:	b158      	cbz	r0, 10d7c <ticker_job+0x53c>
	*ticker_id_head = _ticker_id_head;
   10d64:	f889 2000 	strb.w	r2, [r9]
	*ticks_to_expire = _ticks_to_expire;
   10d68:	f8ce 1000 	str.w	r1, [lr]
		uop->status = TICKER_STATUS_SUCCESS;
   10d6c:	e7cc      	b.n	10d08 <ticker_job+0x4c8>
		ticker = &node[_ticker_id_head];
   10d6e:	fb1a f207 	smulbb	r2, sl, r7
	_ticks_to_expire = *ticks_to_expire;
   10d72:	f8de 1000 	ldr.w	r1, [lr]
		_ticker_id_head = ticker->next;
   10d76:	f81c 2002 	ldrb.w	r2, [ip, r2]
   10d7a:	e7e7      	b.n	10d4c <ticker_job+0x50c>
		_ticker_id_head = ticker->next;
   10d7c:	f81c 200b 	ldrb.w	r2, [ip, fp]
   10d80:	e7e4      	b.n	10d4c <ticker_job+0x50c>
		if (uop->id < instance->count_node) {
   10d82:	7859      	ldrb	r1, [r3, #1]
   10d84:	7a22      	ldrb	r2, [r4, #8]
   10d86:	428a      	cmp	r2, r1
   10d88:	d906      	bls.n	10d98 <ticker_job+0x558>
			node[uop->id].priority =
   10d8a:	6822      	ldr	r2, [r4, #0]
   10d8c:	fb01 2207 	mla	r2, r1, r7, r2
   10d90:	7919      	ldrb	r1, [r3, #4]
   10d92:	f882 1029 	strb.w	r1, [r2, #41]	; 0x29
   10d96:	e7b7      	b.n	10d08 <ticker_job+0x4c8>
			uop->status = TICKER_STATUS_FAILURE;
   10d98:	2201      	movs	r2, #1
   10d9a:	e7b6      	b.n	10d0a <ticker_job+0x4ca>
   10d9c:	ff172b5a 	.word	0xff172b5a
   10da0:	7f172b59 	.word	0x7f172b59
	if (ticker_id_old_head == TICKER_NULL) {
   10da4:	9b03      	ldr	r3, [sp, #12]
   10da6:	2bff      	cmp	r3, #255	; 0xff
   10da8:	d106      	bne.n	10db8 <ticker_job+0x578>
		ticks_current = cntr_cnt_get();
   10daa:	f007 fba1 	bl	184f0 <cntr_cnt_get>
   10dae:	4605      	mov	r5, r0
		if (cntr_start() == 0) {
   10db0:	f007 fb6a 	bl	18488 <cntr_start>
   10db4:	b900      	cbnz	r0, 10db8 <ticker_job+0x578>
			instance->ticks_current = ticks_current;
   10db6:	6165      	str	r5, [r4, #20]
	ticker = &instance->nodes[instance->ticker_id_head];
   10db8:	7f61      	ldrb	r1, [r4, #29]
	ticks_to_expire = ticker->ticks_to_expire;
   10dba:	6822      	ldr	r2, [r4, #0]
		LL_ASSERT(i);
   10dbc:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 10e70 <ticker_job+0x630>
   10dc0:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 10e74 <ticker_job+0x634>
   10dc4:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 10e78 <ticker_job+0x638>
	ticks_to_expire = ticker->ticks_to_expire;
   10dc8:	232c      	movs	r3, #44	; 0x2c
   10dca:	fb01 2303 	mla	r3, r1, r3, r2
	i = 10U;
   10dce:	260a      	movs	r6, #10
	ticks_to_expire = ticker->ticks_to_expire;
   10dd0:	689f      	ldr	r7, [r3, #8]
		ctr = cntr_cnt_get();
   10dd2:	f007 fb8d 	bl	184f0 <cntr_cnt_get>
		cc = instance->ticks_current;
   10dd6:	6965      	ldr	r5, [r4, #20]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   10dd8:	1b43      	subs	r3, r0, r5
   10dda:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		ticks_elapsed = ticker_ticks_diff_get(ctr, cc) +
   10dde:	3303      	adds	r3, #3
		cc += MAX(ticks_elapsed, ticks_to_expire);
   10de0:	42bb      	cmp	r3, r7
   10de2:	bf2c      	ite	cs
   10de4:	18ed      	addcs	r5, r5, r3
   10de6:	19ed      	addcc	r5, r5, r7
		cc &= HAL_TICKER_CNTR_MASK;
   10de8:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		ctr = cntr_cnt_get();
   10dec:	4683      	mov	fp, r0
		instance->trigger_set_cb(cc);
   10dee:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   10df0:	4628      	mov	r0, r5
   10df2:	4798      	blx	r3
		ctr_post = cntr_cnt_get();
   10df4:	f007 fb7c 	bl	184f0 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   10df8:	eba0 000b 	sub.w	r0, r0, fp
   10dfc:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   10e00:	eba5 050b 	sub.w	r5, r5, fp
	} while ((ticker_ticks_diff_get(ctr_post, ctr) +
   10e04:	3003      	adds	r0, #3
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   10e06:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		  ticker_ticks_diff_get(cc, ctr));
   10e0a:	42a8      	cmp	r0, r5
		i--;
   10e0c:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
		  ticker_ticks_diff_get(cc, ctr));
   10e10:	f67f ad90 	bls.w	10934 <ticker_job+0xf4>
		LL_ASSERT(i);
   10e14:	2e00      	cmp	r6, #0
   10e16:	d1dc      	bne.n	10dd2 <ticker_job+0x592>
   10e18:	f240 63f4 	movw	r3, #1780	; 0x6f4
   10e1c:	4642      	mov	r2, r8
   10e1e:	4649      	mov	r1, r9
   10e20:	4650      	mov	r0, sl
   10e22:	f00e ffc6 	bl	1fdb2 <printk>
   10e26:	4040      	eors	r0, r0
   10e28:	f380 8811 	msr	BASEPRI, r0
   10e2c:	f04f 0003 	mov.w	r0, #3
   10e30:	df02      	svc	2
   10e32:	e7ce      	b.n	10dd2 <ticker_job+0x592>
	if (previous == current) {
   10e34:	4573      	cmp	r3, lr
   10e36:	d101      	bne.n	10e3c <ticker_job+0x5fc>
		instance->ticker_id_head = ticker_current->next;
   10e38:	f884 901d 	strb.w	r9, [r4, #29]
	node[previous].next = ticker_current->next;
   10e3c:	202c      	movs	r0, #44	; 0x2c
   10e3e:	fb1e fe00 	smulbb	lr, lr, r0
	if (ticker_current->next != TICKER_NULL) {
   10e42:	9809      	ldr	r0, [sp, #36]	; 0x24
	node[previous].next = ticker_current->next;
   10e44:	f801 900e 	strb.w	r9, [r1, lr]
	if (ticker_current->next != TICKER_NULL) {
   10e48:	f890 c000 	ldrb.w	ip, [r0]
   10e4c:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
   10e50:	f43f add0 	beq.w	109f4 <ticker_job+0x1b4>
		node[ticker_current->next].ticks_to_expire += timeout;
   10e54:	202c      	movs	r0, #44	; 0x2c
   10e56:	fb0c 1c00 	mla	ip, ip, r0, r1
   10e5a:	980a      	ldr	r0, [sp, #40]	; 0x28
   10e5c:	f8dc 1008 	ldr.w	r1, [ip, #8]
   10e60:	4401      	add	r1, r0
   10e62:	f8cc 1008 	str.w	r1, [ip, #8]
	return (total + timeout);
   10e66:	e5c5      	b.n	109f4 <ticker_job+0x1b4>
}
   10e68:	b00f      	add	sp, #60	; 0x3c
   10e6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10e6e:	bf00      	nop
   10e70:	00064123 	.word	0x00064123
   10e74:	00064315 	.word	0x00064315
   10e78:	000632fe 	.word	0x000632fe

00010e7c <ticker_init>:
{
   10e7c:	b5f0      	push	{r4, r5, r6, r7, lr}
   10e7e:	9e05      	ldr	r6, [sp, #20]
   10e80:	f89d 5018 	ldrb.w	r5, [sp, #24]
   10e84:	9f07      	ldr	r7, [sp, #28]
	if (instance_index >= TICKER_INSTANCE_MAX) {
   10e86:	b108      	cbz	r0, 10e8c <ticker_init+0x10>
		return TICKER_STATUS_FAILURE;
   10e88:	2001      	movs	r0, #1
}
   10e8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	instance->count_node = count_node;
   10e8c:	4c18      	ldr	r4, [pc, #96]	; (10ef0 <ticker_init+0x74>)
		instance->nodes[count_node].priority = 0;
   10e8e:	f04f 0c2c 	mov.w	ip, #44	; 0x2c
	instance->count_node = count_node;
   10e92:	7221      	strb	r1, [r4, #8]
	instance->nodes = node;
   10e94:	6022      	str	r2, [r4, #0]
	while (count_node--) {
   10e96:	3901      	subs	r1, #1
   10e98:	b2c9      	uxtb	r1, r1
   10e9a:	29ff      	cmp	r1, #255	; 0xff
   10e9c:	d115      	bne.n	10eca <ticker_init+0x4e>
	instance->count_user = count_user;
   10e9e:	7263      	strb	r3, [r4, #9]
	instance->users = user;
   10ea0:	6066      	str	r6, [r4, #4]
	while (count_user--) {
   10ea2:	3b01      	subs	r3, #1
   10ea4:	b2db      	uxtb	r3, r3
   10ea6:	2bff      	cmp	r3, #255	; 0xff
   10ea8:	d114      	bne.n	10ed4 <ticker_init+0x58>
	if (count_op) {
   10eaa:	2d00      	cmp	r5, #0
   10eac:	d1ec      	bne.n	10e88 <ticker_init+0xc>
	instance->caller_id_get_cb = caller_id_get_cb;
   10eae:	9b08      	ldr	r3, [sp, #32]
   10eb0:	6223      	str	r3, [r4, #32]
	instance->sched_cb = sched_cb;
   10eb2:	9b09      	ldr	r3, [sp, #36]	; 0x24
   10eb4:	6263      	str	r3, [r4, #36]	; 0x24
	instance->trigger_set_cb = trigger_set_cb;
   10eb6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   10eb8:	62a3      	str	r3, [r4, #40]	; 0x28
	instance->ticker_id_slot_previous = TICKER_NULL;
   10eba:	f64f 73ff 	movw	r3, #65535	; 0xffff
	instance->ticks_slot_previous = 0U;
   10ebe:	e9c4 5505 	strd	r5, r5, [r4, #20]
	instance->ticker_id_slot_previous = TICKER_NULL;
   10ec2:	83a3      	strh	r3, [r4, #28]
	instance->ticks_elapsed_first = 0U;
   10ec4:	8165      	strh	r5, [r4, #10]
	return TICKER_STATUS_SUCCESS;
   10ec6:	4628      	mov	r0, r5
   10ec8:	e7df      	b.n	10e8a <ticker_init+0xe>
		instance->nodes[count_node].priority = 0;
   10eca:	fb01 2e0c 	mla	lr, r1, ip, r2
   10ece:	f88e 0029 	strb.w	r0, [lr, #41]	; 0x29
   10ed2:	e7e0      	b.n	10e96 <ticker_init+0x1a>
		users[count_user].user_op = user_op_;
   10ed4:	b21a      	sxth	r2, r3
   10ed6:	eb06 01c2 	add.w	r1, r6, r2, lsl #3
   10eda:	604f      	str	r7, [r1, #4]
		user_op_ += users[count_user].count_user_op;
   10edc:	f816 0032 	ldrb.w	r0, [r6, r2, lsl #3]
   10ee0:	eb00 0240 	add.w	r2, r0, r0, lsl #1
		count_op -= users[count_user].count_user_op;
   10ee4:	1a28      	subs	r0, r5, r0
		user_op_ += users[count_user].count_user_op;
   10ee6:	eb07 1702 	add.w	r7, r7, r2, lsl #4
		count_op -= users[count_user].count_user_op;
   10eea:	b2c5      	uxtb	r5, r0
   10eec:	e7d9      	b.n	10ea2 <ticker_init+0x26>
   10eee:	bf00      	nop
   10ef0:	20000958 	.word	0x20000958

00010ef4 <ticker_is_initialized>:
	return !!(_instance[instance_index].count_node);
   10ef4:	4a04      	ldr	r2, [pc, #16]	; (10f08 <ticker_is_initialized+0x14>)
   10ef6:	232c      	movs	r3, #44	; 0x2c
   10ef8:	fb03 2000 	mla	r0, r3, r0, r2
   10efc:	7a00      	ldrb	r0, [r0, #8]
}
   10efe:	3000      	adds	r0, #0
   10f00:	bf18      	it	ne
   10f02:	2001      	movne	r0, #1
   10f04:	4770      	bx	lr
   10f06:	bf00      	nop
   10f08:	20000958 	.word	0x20000958

00010f0c <ticker_trigger>:
	if (instance->sched_cb) {
   10f0c:	4a07      	ldr	r2, [pc, #28]	; (10f2c <ticker_trigger+0x20>)
   10f0e:	232c      	movs	r3, #44	; 0x2c
   10f10:	fb03 2100 	mla	r1, r3, r0, r2
{
   10f14:	b410      	push	{r4}
	if (instance->sched_cb) {
   10f16:	6a4c      	ldr	r4, [r1, #36]	; 0x24
   10f18:	b134      	cbz	r4, 10f28 <ticker_trigger+0x1c>
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
   10f1a:	460b      	mov	r3, r1
   10f1c:	46a4      	mov	ip, r4
   10f1e:	2201      	movs	r2, #1
   10f20:	2103      	movs	r1, #3
   10f22:	2002      	movs	r0, #2
}
   10f24:	bc10      	pop	{r4}
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
   10f26:	4760      	bx	ip
}
   10f28:	bc10      	pop	{r4}
   10f2a:	4770      	bx	lr
   10f2c:	20000958 	.word	0x20000958

00010f30 <ticker_start>:
{
   10f30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct ticker_instance *instance = &_instance[instance_index];
   10f34:	4c22      	ldr	r4, [pc, #136]	; (10fc0 <ticker_start+0x90>)
   10f36:	272c      	movs	r7, #44	; 0x2c
   10f38:	fb00 4907 	mla	r9, r0, r7, r4
	user = &instance->users[user_id];
   10f3c:	b20d      	sxth	r5, r1
   10f3e:	f8d9 0004 	ldr.w	r0, [r9, #4]
   10f42:	eb00 0cc5 	add.w	ip, r0, r5, lsl #3
	if (last >= user->count_user_op) {
   10f46:	f810 0035 	ldrb.w	r0, [r0, r5, lsl #3]
	last = user->last + 1;
   10f4a:	f89c 4003 	ldrb.w	r4, [ip, #3]
   10f4e:	1c66      	adds	r6, r4, #1
   10f50:	b2f6      	uxtb	r6, r6
		last = 0U;
   10f52:	42b0      	cmp	r0, r6
   10f54:	bf98      	it	ls
   10f56:	2600      	movls	r6, #0
	if (last == user->first) {
   10f58:	f89c 0001 	ldrb.w	r0, [ip, #1]
   10f5c:	42b0      	cmp	r0, r6
   10f5e:	d02d      	beq.n	10fbc <ticker_start+0x8c>
	user_op = &user->user_op[user->last];
   10f60:	f8dc 0004 	ldr.w	r0, [ip, #4]
   10f64:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   10f68:	0125      	lsls	r5, r4, #4
   10f6a:	1944      	adds	r4, r0, r5
	user_op->op = TICKER_USER_OP_TYPE_START;
   10f6c:	f04f 0804 	mov.w	r8, #4
   10f70:	f800 8005 	strb.w	r8, [r0, r5]
	user_op->params.start.ticks_at_start = ticks_anchor;
   10f74:	6063      	str	r3, [r4, #4]
	user_op->params.start.ticks_first = ticks_first;
   10f76:	9b08      	ldr	r3, [sp, #32]
   10f78:	60a3      	str	r3, [r4, #8]
	user_op->params.start.ticks_periodic = ticks_periodic;
   10f7a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   10f7c:	60e3      	str	r3, [r4, #12]
	user_op->params.start.remainder_periodic = remainder_periodic;
   10f7e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   10f80:	6123      	str	r3, [r4, #16]
	user_op->params.start.ticks_slot = ticks_slot;
   10f82:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   10f84:	61a3      	str	r3, [r4, #24]
	user_op->params.start.lazy = lazy;
   10f86:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
   10f8a:	82a3      	strh	r3, [r4, #20]
	user_op->params.start.fp_timeout_func = fp_timeout_func;
   10f8c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   10f8e:	61e3      	str	r3, [r4, #28]
	user_op->params.start.context = context;
   10f90:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   10f92:	6223      	str	r3, [r4, #32]
	user_op->status = TICKER_STATUS_BUSY;
   10f94:	2302      	movs	r3, #2
   10f96:	6263      	str	r3, [r4, #36]	; 0x24
	user_op->fp_op_func = fp_op_func;
   10f98:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   10f9a:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->op_context = op_context;
   10f9c:	9b10      	ldr	r3, [sp, #64]	; 0x40
	user_op->id = ticker_id;
   10f9e:	7062      	strb	r2, [r4, #1]
	user_op->op_context = op_context;
   10fa0:	62e3      	str	r3, [r4, #44]	; 0x2c
	user->last = last;
   10fa2:	f88c 6003 	strb.w	r6, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   10fa6:	e9d9 3508 	ldrd	r3, r5, [r9, #32]
   10faa:	4608      	mov	r0, r1
   10fac:	4798      	blx	r3
   10fae:	464b      	mov	r3, r9
   10fb0:	2200      	movs	r2, #0
   10fb2:	4641      	mov	r1, r8
   10fb4:	47a8      	blx	r5
	return user_op->status;
   10fb6:	6a60      	ldr	r0, [r4, #36]	; 0x24
}
   10fb8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return TICKER_STATUS_FAILURE;
   10fbc:	2001      	movs	r0, #1
   10fbe:	e7fb      	b.n	10fb8 <ticker_start+0x88>
   10fc0:	20000958 	.word	0x20000958

00010fc4 <ticker_update>:
{
   10fc4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct ticker_instance *instance = &_instance[instance_index];
   10fc8:	4c21      	ldr	r4, [pc, #132]	; (11050 <ticker_update+0x8c>)
   10fca:	272c      	movs	r7, #44	; 0x2c
   10fcc:	fb00 4807 	mla	r8, r0, r7, r4
	user = &instance->users[user_id];
   10fd0:	b20d      	sxth	r5, r1
   10fd2:	f8d8 0004 	ldr.w	r0, [r8, #4]
   10fd6:	eb00 0cc5 	add.w	ip, r0, r5, lsl #3
	if (last >= user->count_user_op) {
   10fda:	f810 0035 	ldrb.w	r0, [r0, r5, lsl #3]
	last = user->last + 1;
   10fde:	f89c 4003 	ldrb.w	r4, [ip, #3]
   10fe2:	1c66      	adds	r6, r4, #1
   10fe4:	b2f6      	uxtb	r6, r6
		last = 0U;
   10fe6:	42b0      	cmp	r0, r6
   10fe8:	bf98      	it	ls
   10fea:	2600      	movls	r6, #0
	if (last == user->first) {
   10fec:	f89c 0001 	ldrb.w	r0, [ip, #1]
   10ff0:	42b0      	cmp	r0, r6
   10ff2:	d02a      	beq.n	1104a <ticker_update+0x86>
	user_op = &user->user_op[user->last];
   10ff4:	f8dc 0004 	ldr.w	r0, [ip, #4]
   10ff8:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   10ffc:	0125      	lsls	r5, r4, #4
   10ffe:	1944      	adds	r4, r0, r5
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
   11000:	f04f 0e05 	mov.w	lr, #5
   11004:	f800 e005 	strb.w	lr, [r0, r5]
	user_op->params.update.ticks_drift_plus = ticks_drift_plus;
   11008:	6063      	str	r3, [r4, #4]
	user_op->params.update.ticks_drift_minus = ticks_drift_minus;
   1100a:	9b06      	ldr	r3, [sp, #24]
   1100c:	60a3      	str	r3, [r4, #8]
	user_op->params.update.ticks_slot_plus = ticks_slot_plus;
   1100e:	9b07      	ldr	r3, [sp, #28]
   11010:	60e3      	str	r3, [r4, #12]
	user_op->params.update.ticks_slot_minus = ticks_slot_minus;
   11012:	9b08      	ldr	r3, [sp, #32]
   11014:	6123      	str	r3, [r4, #16]
	user_op->params.update.lazy = lazy;
   11016:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
   1101a:	82a3      	strh	r3, [r4, #20]
	user_op->params.update.force = force;
   1101c:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
   11020:	75a3      	strb	r3, [r4, #22]
	user_op->status = TICKER_STATUS_BUSY;
   11022:	2302      	movs	r3, #2
   11024:	6263      	str	r3, [r4, #36]	; 0x24
	user_op->fp_op_func = fp_op_func;
   11026:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   11028:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->op_context = op_context;
   1102a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	user_op->id = ticker_id;
   1102c:	7062      	strb	r2, [r4, #1]
	user_op->op_context = op_context;
   1102e:	62e3      	str	r3, [r4, #44]	; 0x2c
	user->last = last;
   11030:	f88c 6003 	strb.w	r6, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   11034:	e9d8 3508 	ldrd	r3, r5, [r8, #32]
   11038:	4608      	mov	r0, r1
   1103a:	4798      	blx	r3
   1103c:	4643      	mov	r3, r8
   1103e:	2200      	movs	r2, #0
   11040:	2104      	movs	r1, #4
   11042:	47a8      	blx	r5
	return user_op->status;
   11044:	6a60      	ldr	r0, [r4, #36]	; 0x24
}
   11046:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
   1104a:	2001      	movs	r0, #1
   1104c:	e7fb      	b.n	11046 <ticker_update+0x82>
   1104e:	bf00      	nop
   11050:	20000958 	.word	0x20000958

00011054 <ticker_stop>:
{
   11054:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct ticker_instance *instance = &_instance[instance_index];
   11058:	4c1a      	ldr	r4, [pc, #104]	; (110c4 <ticker_stop+0x70>)
   1105a:	262c      	movs	r6, #44	; 0x2c
   1105c:	fb00 4806 	mla	r8, r0, r6, r4
	user = &instance->users[user_id];
   11060:	b20f      	sxth	r7, r1
   11062:	f8d8 0004 	ldr.w	r0, [r8, #4]
   11066:	eb00 0cc7 	add.w	ip, r0, r7, lsl #3
	if (last >= user->count_user_op) {
   1106a:	f810 0037 	ldrb.w	r0, [r0, r7, lsl #3]
	last = user->last + 1;
   1106e:	f89c 4003 	ldrb.w	r4, [ip, #3]
   11072:	1c65      	adds	r5, r4, #1
   11074:	b2ed      	uxtb	r5, r5
		last = 0U;
   11076:	42a8      	cmp	r0, r5
   11078:	bf98      	it	ls
   1107a:	2500      	movls	r5, #0
	if (last == user->first) {
   1107c:	f89c 0001 	ldrb.w	r0, [ip, #1]
   11080:	42a8      	cmp	r0, r5
   11082:	d01c      	beq.n	110be <ticker_stop+0x6a>
	user_op = &user->user_op[user->last];
   11084:	f8dc 0004 	ldr.w	r0, [ip, #4]
   11088:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   1108c:	0124      	lsls	r4, r4, #4
   1108e:	1907      	adds	r7, r0, r4
	user_op->op = TICKER_USER_OP_TYPE_STOP;
   11090:	f04f 0e06 	mov.w	lr, #6
   11094:	f800 e004 	strb.w	lr, [r0, r4]
	user_op->id = ticker_id;
   11098:	707a      	strb	r2, [r7, #1]
	user_op->status = TICKER_STATUS_BUSY;
   1109a:	2202      	movs	r2, #2
	user_op->fp_op_func = fp_op_func;
   1109c:	e9c7 2309 	strd	r2, r3, [r7, #36]	; 0x24
	user_op->op_context = op_context;
   110a0:	9b06      	ldr	r3, [sp, #24]
   110a2:	62fb      	str	r3, [r7, #44]	; 0x2c
	user->last = last;
   110a4:	f88c 5003 	strb.w	r5, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   110a8:	e9d8 3408 	ldrd	r3, r4, [r8, #32]
   110ac:	4608      	mov	r0, r1
   110ae:	4798      	blx	r3
   110b0:	4643      	mov	r3, r8
   110b2:	2200      	movs	r2, #0
   110b4:	2104      	movs	r1, #4
   110b6:	47a0      	blx	r4
	return user_op->status;
   110b8:	6a78      	ldr	r0, [r7, #36]	; 0x24
}
   110ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
   110be:	2001      	movs	r0, #1
   110c0:	e7fb      	b.n	110ba <ticker_stop+0x66>
   110c2:	bf00      	nop
   110c4:	20000958 	.word	0x20000958

000110c8 <ll_addr_get>:
static u8_t pub_addr[BDADDR_SIZE];
static u8_t rnd_addr[BDADDR_SIZE];

u8_t *ll_addr_get(u8_t addr_type, u8_t *bdaddr)
{
	if (addr_type > 1) {
   110c8:	2801      	cmp	r0, #1
   110ca:	d809      	bhi.n	110e0 <ll_addr_get+0x18>
		return NULL;
	}

	if (addr_type) {
   110cc:	b130      	cbz	r0, 110dc <ll_addr_get+0x14>
		if (bdaddr) {
   110ce:	4805      	ldr	r0, [pc, #20]	; (110e4 <ll_addr_get+0x1c>)
		}

		return rnd_addr;
	}

	if (bdaddr) {
   110d0:	b139      	cbz	r1, 110e2 <ll_addr_get+0x1a>
   110d2:	6803      	ldr	r3, [r0, #0]
   110d4:	600b      	str	r3, [r1, #0]
   110d6:	8883      	ldrh	r3, [r0, #4]
   110d8:	808b      	strh	r3, [r1, #4]
   110da:	4770      	bx	lr
   110dc:	4802      	ldr	r0, [pc, #8]	; (110e8 <ll_addr_get+0x20>)
   110de:	e7f7      	b.n	110d0 <ll_addr_get+0x8>
		return NULL;
   110e0:	2000      	movs	r0, #0
		memcpy(bdaddr, pub_addr, BDADDR_SIZE);
	}

	return pub_addr;
}
   110e2:	4770      	bx	lr
   110e4:	2000aa66 	.word	0x2000aa66
   110e8:	2000aa60 	.word	0x2000aa60

000110ec <ll_addr_set>:

u32_t ll_addr_set(u8_t addr_type, u8_t const *const bdaddr)
{
   110ec:	b538      	push	{r3, r4, r5, lr}
   110ee:	4605      	mov	r5, r0
	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
	    ull_adv_is_enabled(0)) {
   110f0:	2000      	movs	r0, #0
{
   110f2:	460c      	mov	r4, r1
	    ull_adv_is_enabled(0)) {
   110f4:	f013 fa38 	bl	24568 <ull_adv_is_enabled>
	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
   110f8:	b940      	cbnz	r0, 1110c <ll_addr_set+0x20>
	if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
	    (ull_scan_is_enabled(0) & (BIT(1) | BIT(2)))) {
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	if (addr_type) {
   110fa:	6822      	ldr	r2, [r4, #0]
   110fc:	b125      	cbz	r5, 11108 <ll_addr_set+0x1c>
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
   110fe:	4b04      	ldr	r3, [pc, #16]	; (11110 <ll_addr_set+0x24>)
	} else {
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
   11100:	601a      	str	r2, [r3, #0]
   11102:	88a2      	ldrh	r2, [r4, #4]
   11104:	809a      	strh	r2, [r3, #4]
	}

	return 0;
}
   11106:	bd38      	pop	{r3, r4, r5, pc}
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
   11108:	4b02      	ldr	r3, [pc, #8]	; (11114 <ll_addr_set+0x28>)
   1110a:	e7f9      	b.n	11100 <ll_addr_set+0x14>
		return BT_HCI_ERR_CMD_DISALLOWED;
   1110c:	200c      	movs	r0, #12
   1110e:	e7fa      	b.n	11106 <ll_addr_set+0x1a>
   11110:	2000aa66 	.word	0x2000aa66
   11114:	2000aa60 	.word	0x2000aa60

00011118 <hci_driver_init>:
	.open	= hci_driver_open,
	.send	= hci_driver_send,
};

static int hci_driver_init(struct device *unused)
{
   11118:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	bt_hci_driver_register(&drv);
   1111a:	4802      	ldr	r0, [pc, #8]	; (11124 <hci_driver_init+0xc>)
   1111c:	f7f8 fb54 	bl	97c8 <bt_hci_driver_register>

	return 0;
}
   11120:	2000      	movs	r0, #0
   11122:	bd08      	pop	{r3, pc}
   11124:	00029248 	.word	0x00029248

00011128 <hci_driver_send>:
	if (!buf->len) {
   11128:	8983      	ldrh	r3, [r0, #12]
{
   1112a:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1112c:	4605      	mov	r5, r0
	if (!buf->len) {
   1112e:	b993      	cbnz	r3, 11156 <hci_driver_send+0x2e>
		BT_ERR("Empty HCI packet");
   11130:	2301      	movs	r3, #1
   11132:	f04f 0100 	mov.w	r1, #0
   11136:	f363 0107 	bfi	r1, r3, #0, #8
   1113a:	4a22      	ldr	r2, [pc, #136]	; (111c4 <hci_driver_send+0x9c>)
   1113c:	4b22      	ldr	r3, [pc, #136]	; (111c8 <hci_driver_send+0xa0>)
   1113e:	4823      	ldr	r0, [pc, #140]	; (111cc <hci_driver_send+0xa4>)
   11140:	1a9b      	subs	r3, r3, r2
   11142:	08db      	lsrs	r3, r3, #3
   11144:	f363 118f 	bfi	r1, r3, #6, #10
   11148:	f00f ff77 	bl	2103a <log_0>
		return -EINVAL;
   1114c:	f06f 0415 	mvn.w	r4, #21
}
   11150:	4620      	mov	r0, r4
   11152:	b003      	add	sp, #12
   11154:	bd30      	pop	{r4, r5, pc}
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
   11156:	7d01      	ldrb	r1, [r0, #20]
	switch (type) {
   11158:	b181      	cbz	r1, 1117c <hci_driver_send+0x54>
   1115a:	2902      	cmp	r1, #2
   1115c:	d122      	bne.n	111a4 <hci_driver_send+0x7c>
	err = hci_acl_handle(buf, &evt);
   1115e:	a901      	add	r1, sp, #4
   11160:	f000 feae 	bl	11ec0 <hci_acl_handle>
   11164:	4604      	mov	r4, r0
	if (evt) {
   11166:	9801      	ldr	r0, [sp, #4]
   11168:	b108      	cbz	r0, 1116e <hci_driver_send+0x46>
		bt_recv_prio(evt);
   1116a:	f7f8 fad7 	bl	971c <bt_recv_prio>
	if (!err) {
   1116e:	2c00      	cmp	r4, #0
   11170:	d1ee      	bne.n	11150 <hci_driver_send+0x28>
		net_buf_unref(buf);
   11172:	4628      	mov	r0, r5
   11174:	f007 ff72 	bl	1905c <net_buf_unref>
   11178:	2400      	movs	r4, #0
   1117a:	e7e9      	b.n	11150 <hci_driver_send+0x28>
	struct node_rx_pdu *node_rx = NULL;
   1117c:	9101      	str	r1, [sp, #4]
	evt = hci_cmd_handle(buf, (void **) &node_rx);
   1117e:	a901      	add	r1, sp, #4
   11180:	f000 fab4 	bl	116ec <hci_cmd_handle>
	if (evt) {
   11184:	2800      	cmp	r0, #0
   11186:	d0f4      	beq.n	11172 <hci_driver_send+0x4a>
		bt_recv_prio(evt);
   11188:	f7f8 fac8 	bl	971c <bt_recv_prio>
		if (node_rx) {
   1118c:	9c01      	ldr	r4, [sp, #4]
   1118e:	2c00      	cmp	r4, #0
   11190:	d0ef      	beq.n	11172 <hci_driver_send+0x4a>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
   11192:	4620      	mov	r0, r4
   11194:	f013 f919 	bl	243ca <hci_get_class>
   11198:	7160      	strb	r0, [r4, #5]
			k_fifo_put(&recv_fifo, node_rx);
   1119a:	9901      	ldr	r1, [sp, #4]
   1119c:	480c      	ldr	r0, [pc, #48]	; (111d0 <hci_driver_send+0xa8>)
   1119e:	f016 fcb2 	bl	27b06 <k_queue_append>
	if (!err) {
   111a2:	e7e6      	b.n	11172 <hci_driver_send+0x4a>
		BT_ERR("Unknown HCI type %u", type);
   111a4:	2301      	movs	r3, #1
   111a6:	f04f 0200 	mov.w	r2, #0
   111aa:	f363 0207 	bfi	r2, r3, #0, #8
   111ae:	4805      	ldr	r0, [pc, #20]	; (111c4 <hci_driver_send+0x9c>)
   111b0:	4b05      	ldr	r3, [pc, #20]	; (111c8 <hci_driver_send+0xa0>)
   111b2:	1a1b      	subs	r3, r3, r0
   111b4:	08db      	lsrs	r3, r3, #3
   111b6:	f363 128f 	bfi	r2, r3, #6, #10
   111ba:	4806      	ldr	r0, [pc, #24]	; (111d4 <hci_driver_send+0xac>)
   111bc:	f00f ff4a 	bl	21054 <log_1>
   111c0:	e7c4      	b.n	1114c <hci_driver_send+0x24>
   111c2:	bf00      	nop
   111c4:	00028540 	.word	0x00028540
   111c8:	00028590 	.word	0x00028590
   111cc:	00064188 	.word	0x00064188
   111d0:	2000eff4 	.word	0x2000eff4
   111d4:	00064199 	.word	0x00064199

000111d8 <recv_thread>:
{
   111d8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return z_impl_k_queue_get(queue, timeout);
   111da:	4d27      	ldr	r5, [pc, #156]	; (11278 <recv_thread+0xa0>)
		LL_ASSERT(0);
   111dc:	4e27      	ldr	r6, [pc, #156]	; (1127c <recv_thread+0xa4>)
   111de:	4f28      	ldr	r7, [pc, #160]	; (11280 <recv_thread+0xa8>)
   111e0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   111e4:	4628      	mov	r0, r5
   111e6:	f016 fcb7 	bl	27b58 <z_impl_k_queue_get>
		if (node_rx && !buf) {
   111ea:	b368      	cbz	r0, 11248 <recv_thread+0x70>
	u8_t class = node_rx->hdr.user_meta;
   111ec:	7943      	ldrb	r3, [r0, #5]
	buf = encode_node(node_rx, class);
   111ee:	9001      	str	r0, [sp, #4]
	switch (class) {
   111f0:	b11b      	cbz	r3, 111fa <recv_thread+0x22>
   111f2:	2b04      	cmp	r3, #4
   111f4:	d90f      	bls.n	11216 <recv_thread+0x3e>
   111f6:	2b05      	cmp	r3, #5
   111f8:	d02f      	beq.n	1125a <recv_thread+0x82>
		LL_ASSERT(0);
   111fa:	23c4      	movs	r3, #196	; 0xc4
   111fc:	4632      	mov	r2, r6
   111fe:	4639      	mov	r1, r7
   11200:	4820      	ldr	r0, [pc, #128]	; (11284 <recv_thread+0xac>)
   11202:	f00e fdd6 	bl	1fdb2 <printk>
   11206:	4040      	eors	r0, r0
   11208:	f380 8811 	msr	BASEPRI, r0
   1120c:	f04f 0003 	mov.w	r0, #3
   11210:	df02      	svc	2
	struct net_buf *buf = NULL;
   11212:	2400      	movs	r4, #0
   11214:	e00c      	b.n	11230 <recv_thread+0x58>
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
   11216:	2b02      	cmp	r3, #2
   11218:	d119      	bne.n	1124e <recv_thread+0x76>
			buf = bt_buf_get_evt(BT_HCI_EVT_UNKNOWN, true,
   1121a:	2200      	movs	r2, #0
   1121c:	2101      	movs	r1, #1
   1121e:	4610      	mov	r0, r2
   11220:	f7f9 f93c 	bl	a49c <bt_buf_get_evt>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   11224:	4604      	mov	r4, r0
		if (buf) {
   11226:	b118      	cbz	r0, 11230 <recv_thread+0x58>
			hci_evt_encode(node_rx, buf);
   11228:	4601      	mov	r1, r0
   1122a:	9801      	ldr	r0, [sp, #4]
   1122c:	f000 ff24 	bl	12078 <hci_evt_encode>
	node_rx->hdr.next = NULL;
   11230:	9b01      	ldr	r3, [sp, #4]
   11232:	2200      	movs	r2, #0
   11234:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
   11236:	a801      	add	r0, sp, #4
   11238:	f001 fd5e 	bl	12cf8 <ll_rx_mem_release>
		if (buf) {
   1123c:	b124      	cbz	r4, 11248 <recv_thread+0x70>
			if (buf->len) {
   1123e:	89a3      	ldrh	r3, [r4, #12]
				bt_recv(buf);
   11240:	4620      	mov	r0, r4
			if (buf->len) {
   11242:	b1ab      	cbz	r3, 11270 <recv_thread+0x98>
				bt_recv(buf);
   11244:	f7f8 f9b4 	bl	95b0 <bt_recv>
	z_impl_k_yield();
   11248:	f00d fd1e 	bl	1ec88 <z_impl_k_yield>
   1124c:	e7c8      	b.n	111e0 <recv_thread+0x8>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   1124e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   11252:	2001      	movs	r0, #1
   11254:	f7f9 f8ec 	bl	a430 <bt_buf_get_rx>
   11258:	e7e4      	b.n	11224 <recv_thread+0x4c>
		buf = bt_buf_get_rx(BT_BUF_ACL_IN, K_FOREVER);
   1125a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1125e:	2003      	movs	r0, #3
   11260:	f7f9 f8e6 	bl	a430 <bt_buf_get_rx>
   11264:	4604      	mov	r4, r0
		hci_acl_encode(node_rx, buf);
   11266:	4601      	mov	r1, r0
   11268:	9801      	ldr	r0, [sp, #4]
   1126a:	f000 fec7 	bl	11ffc <hci_acl_encode>
		break;
   1126e:	e7df      	b.n	11230 <recv_thread+0x58>
				net_buf_unref(buf);
   11270:	f007 fef4 	bl	1905c <net_buf_unref>
   11274:	e7e8      	b.n	11248 <recv_thread+0x70>
   11276:	bf00      	nop
   11278:	2000eff4 	.word	0x2000eff4
   1127c:	000641ad 	.word	0x000641ad
   11280:	00065948 	.word	0x00065948
   11284:	000632fe 	.word	0x000632fe

00011288 <prio_recv_thread>:
{
   11288:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return z_impl_k_sem_take(sem, timeout);
   1128a:	4d17      	ldr	r5, [pc, #92]	; (112e8 <prio_recv_thread+0x60>)
				k_fifo_put(&recv_fifo, node_rx);
   1128c:	4e17      	ldr	r6, [pc, #92]	; (112ec <prio_recv_thread+0x64>)
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
   1128e:	f10d 0102 	add.w	r1, sp, #2
   11292:	a801      	add	r0, sp, #4
   11294:	f001 fc1a 	bl	12acc <ll_rx_get>
   11298:	4604      	mov	r4, r0
   1129a:	b968      	cbnz	r0, 112b8 <prio_recv_thread+0x30>
		if (node_rx) {
   1129c:	9b01      	ldr	r3, [sp, #4]
   1129e:	b1eb      	cbz	r3, 112dc <prio_recv_thread+0x54>
			ll_rx_dequeue();
   112a0:	f001 fc6c 	bl	12b7c <ll_rx_dequeue>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
   112a4:	9c01      	ldr	r4, [sp, #4]
   112a6:	4620      	mov	r0, r4
   112a8:	f013 f88f 	bl	243ca <hci_get_class>
				k_fifo_put(&recv_fifo, node_rx);
   112ac:	9901      	ldr	r1, [sp, #4]
			node_rx->hdr.user_meta = hci_get_class(node_rx);
   112ae:	7160      	strb	r0, [r4, #5]
				k_fifo_put(&recv_fifo, node_rx);
   112b0:	4630      	mov	r0, r6
   112b2:	f016 fc28 	bl	27b06 <k_queue_append>
			continue;
   112b6:	e7ea      	b.n	1128e <prio_recv_thread+0x6>
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
   112b8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   112bc:	2100      	movs	r1, #0
   112be:	2013      	movs	r0, #19
   112c0:	f7f9 f8ec 	bl	a49c <bt_buf_get_evt>
			hci_num_cmplt_encode(buf, handle, num_cmplt);
   112c4:	4622      	mov	r2, r4
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
   112c6:	4607      	mov	r7, r0
			hci_num_cmplt_encode(buf, handle, num_cmplt);
   112c8:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   112cc:	f013 f869 	bl	243a2 <hci_num_cmplt_encode>
			bt_recv_prio(buf);
   112d0:	4638      	mov	r0, r7
   112d2:	f7f8 fa23 	bl	971c <bt_recv_prio>
	z_impl_k_yield();
   112d6:	f00d fcd7 	bl	1ec88 <z_impl_k_yield>
   112da:	e7d8      	b.n	1128e <prio_recv_thread+0x6>
	return z_impl_k_sem_take(sem, timeout);
   112dc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   112e0:	4628      	mov	r0, r5
   112e2:	f00d fd77 	bl	1edd4 <z_impl_k_sem_take>
		BT_DBG("sem taken");
   112e6:	e7d2      	b.n	1128e <prio_recv_thread+0x6>
   112e8:	2000ef74 	.word	0x2000ef74
   112ec:	2000eff4 	.word	0x2000eff4

000112f0 <hci_driver_open>:
{
   112f0:	b510      	push	{r4, lr}
	err = ll_init(&sem_prio_recv);
   112f2:	4820      	ldr	r0, [pc, #128]	; (11374 <hci_driver_open+0x84>)
{
   112f4:	b086      	sub	sp, #24
	err = ll_init(&sem_prio_recv);
   112f6:	f001 fb0b 	bl	12910 <ll_init>
	if (err) {
   112fa:	4604      	mov	r4, r0
   112fc:	b188      	cbz	r0, 11322 <hci_driver_open+0x32>
		BT_ERR("LL initialization failed: %u", err);
   112fe:	2301      	movs	r3, #1
   11300:	f04f 0200 	mov.w	r2, #0
   11304:	f363 0207 	bfi	r2, r3, #0, #8
   11308:	491b      	ldr	r1, [pc, #108]	; (11378 <hci_driver_open+0x88>)
   1130a:	4b1c      	ldr	r3, [pc, #112]	; (1137c <hci_driver_open+0x8c>)
   1130c:	1a5b      	subs	r3, r3, r1
   1130e:	08db      	lsrs	r3, r3, #3
   11310:	4601      	mov	r1, r0
   11312:	f363 128f 	bfi	r2, r3, #6, #10
   11316:	481a      	ldr	r0, [pc, #104]	; (11380 <hci_driver_open+0x90>)
   11318:	f00f fe9c 	bl	21054 <log_1>
}
   1131c:	4620      	mov	r0, r4
   1131e:	b006      	add	sp, #24
   11320:	bd10      	pop	{r4, pc}
	hci_init(NULL);
   11322:	f001 f913 	bl	1254c <hci_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   11326:	f06f 0309 	mvn.w	r3, #9
   1132a:	e9cd 4302 	strd	r4, r3, [sp, #8]
   1132e:	e9cd 4404 	strd	r4, r4, [sp, #16]
   11332:	e9cd 4400 	strd	r4, r4, [sp]
   11336:	4b13      	ldr	r3, [pc, #76]	; (11384 <hci_driver_open+0x94>)
   11338:	4913      	ldr	r1, [pc, #76]	; (11388 <hci_driver_open+0x98>)
   1133a:	4814      	ldr	r0, [pc, #80]	; (1138c <hci_driver_open+0x9c>)
   1133c:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
   11340:	f00d fdc0 	bl	1eec4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   11344:	4912      	ldr	r1, [pc, #72]	; (11390 <hci_driver_open+0xa0>)
   11346:	4811      	ldr	r0, [pc, #68]	; (1138c <hci_driver_open+0x9c>)
   11348:	f016 fd6a 	bl	27e20 <z_impl_k_thread_name_set>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   1134c:	f06f 0307 	mvn.w	r3, #7
   11350:	e9cd 4302 	strd	r4, r3, [sp, #8]
   11354:	e9cd 4404 	strd	r4, r4, [sp, #16]
   11358:	e9cd 4400 	strd	r4, r4, [sp]
   1135c:	4b0d      	ldr	r3, [pc, #52]	; (11394 <hci_driver_open+0xa4>)
   1135e:	490e      	ldr	r1, [pc, #56]	; (11398 <hci_driver_open+0xa8>)
   11360:	480e      	ldr	r0, [pc, #56]	; (1139c <hci_driver_open+0xac>)
   11362:	f640 0298 	movw	r2, #2200	; 0x898
   11366:	f00d fdad 	bl	1eec4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   1136a:	490d      	ldr	r1, [pc, #52]	; (113a0 <hci_driver_open+0xb0>)
   1136c:	480b      	ldr	r0, [pc, #44]	; (1139c <hci_driver_open+0xac>)
   1136e:	f016 fd57 	bl	27e20 <z_impl_k_thread_name_set>
	return 0;
   11372:	e7d3      	b.n	1131c <hci_driver_open+0x2c>
   11374:	2000ef74 	.word	0x2000ef74
   11378:	00028540 	.word	0x00028540
   1137c:	00028590 	.word	0x00028590
   11380:	0006415b 	.word	0x0006415b
   11384:	00011289 	.word	0x00011289
   11388:	2000b728 	.word	0x2000b728
   1138c:	20000984 	.word	0x20000984
   11390:	00064178 	.word	0x00064178
   11394:	000111d9 	.word	0x000111d9
   11398:	2000b8e8 	.word	0x2000b8e8
   1139c:	200009f0 	.word	0x200009f0
   113a0:	00064182 	.word	0x00064182

000113a4 <cmd_status>:
	return net_buf_add(*buf, plen);
}

#if defined(CONFIG_BT_CONN)
static struct net_buf *cmd_status(u8_t status)
{
   113a4:	b538      	push	{r3, r4, r5, lr}
	struct bt_hci_evt_cmd_status *cs;
	struct net_buf *buf;

	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   113a6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
   113aa:	4605      	mov	r5, r0
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   113ac:	2100      	movs	r1, #0
   113ae:	200f      	movs	r0, #15
   113b0:	f7f9 f874 	bl	a49c <bt_buf_get_evt>
	hci_evt_create(buf, BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
   113b4:	2204      	movs	r2, #4
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   113b6:	4604      	mov	r4, r0
	hci_evt_create(buf, BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
   113b8:	210f      	movs	r1, #15
   113ba:	f012 ffd3 	bl	24364 <hci_evt_create>

	cs = net_buf_add(buf, sizeof(*cs));
   113be:	2104      	movs	r1, #4
   113c0:	f104 0008 	add.w	r0, r4, #8
   113c4:	f013 fd08 	bl	24dd8 <net_buf_simple_add>
	cs->status = status;
	cs->ncmd = 1U;
   113c8:	2301      	movs	r3, #1
   113ca:	7043      	strb	r3, [r0, #1]
	cs->opcode = sys_cpu_to_le16(_opcode);
   113cc:	4b02      	ldr	r3, [pc, #8]	; (113d8 <cmd_status+0x34>)
	cs->status = status;
   113ce:	7005      	strb	r5, [r0, #0]
	cs->opcode = sys_cpu_to_le16(_opcode);
   113d0:	881b      	ldrh	r3, [r3, #0]
   113d2:	8043      	strh	r3, [r0, #2]

	return buf;
}
   113d4:	4620      	mov	r0, r4
   113d6:	bd38      	pop	{r3, r4, r5, pc}
   113d8:	2000613c 	.word	0x2000613c

000113dc <le_remote_feat_complete>:
}
#endif /* CONFIG_BT_CTLR_LE_ENC */

static void le_remote_feat_complete(u8_t status, struct pdu_data *pdu_data,
				    u16_t handle, struct net_buf *buf)
{
   113dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   113de:	4606      	mov	r6, r0
   113e0:	4618      	mov	r0, r3
	struct bt_hci_evt_le_remote_feat_complete *sep;

	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   113e2:	4b13      	ldr	r3, [pc, #76]	; (11430 <le_remote_feat_complete+0x54>)
{
   113e4:	460c      	mov	r4, r1
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   113e6:	6859      	ldr	r1, [r3, #4]
   113e8:	2500      	movs	r5, #0
{
   113ea:	4617      	mov	r7, r2
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   113ec:	f001 5300 	and.w	r3, r1, #536870912	; 0x20000000
   113f0:	462a      	mov	r2, r5
   113f2:	4313      	orrs	r3, r2
   113f4:	d016      	beq.n	11424 <le_remote_feat_complete+0x48>
	    !(le_event_mask & BT_EVT_MASK_LE_REMOTE_FEAT_COMPLETE)) {
   113f6:	4b0f      	ldr	r3, [pc, #60]	; (11434 <le_remote_feat_complete+0x58>)
   113f8:	6819      	ldr	r1, [r3, #0]
   113fa:	462b      	mov	r3, r5
   113fc:	f001 0208 	and.w	r2, r1, #8
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   11400:	4313      	orrs	r3, r2
   11402:	d00f      	beq.n	11424 <le_remote_feat_complete+0x48>
		return;
	}

	sep = meta_evt(buf, BT_HCI_EV_LE_REMOTE_FEAT_COMPLETE, sizeof(*sep));
   11404:	220b      	movs	r2, #11
   11406:	2104      	movs	r1, #4
   11408:	f012 ffb6 	bl	24378 <meta_evt>

	sep->status = status;
   1140c:	7006      	strb	r6, [r0, #0]
	sep->handle = sys_cpu_to_le16(handle);
   1140e:	f8a0 7001 	strh.w	r7, [r0, #1]
	if (!status) {
   11412:	1cc2      	adds	r2, r0, #3
   11414:	b93e      	cbnz	r6, 11426 <le_remote_feat_complete+0x4a>
   11416:	4621      	mov	r1, r4
   11418:	f851 3f04 	ldr.w	r3, [r1, #4]!
   1141c:	f8c0 3003 	str.w	r3, [r0, #3]
   11420:	684b      	ldr	r3, [r1, #4]
   11422:	6053      	str	r3, [r2, #4]
		       &pdu_data->llctrl.feature_rsp.features[0],
		       sizeof(sep->features));
	} else {
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
	}
}
   11424:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
__ssp_bos_icheck3(memset, void *, int)
   11426:	f8c0 5003 	str.w	r5, [r0, #3]
   1142a:	6055      	str	r5, [r2, #4]
   1142c:	e7fa      	b.n	11424 <le_remote_feat_complete+0x48>
   1142e:	bf00      	nop
   11430:	2000e628 	.word	0x2000e628
   11434:	2000e630 	.word	0x2000e630

00011438 <encrypt_change>:
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
   11438:	4b0e      	ldr	r3, [pc, #56]	; (11474 <encrypt_change+0x3c>)
{
   1143a:	b570      	push	{r4, r5, r6, lr}
   1143c:	460e      	mov	r6, r1
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
   1143e:	6819      	ldr	r1, [r3, #0]
{
   11440:	4615      	mov	r5, r2
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
   11442:	2300      	movs	r3, #0
   11444:	f001 0280 	and.w	r2, r1, #128	; 0x80
   11448:	4313      	orrs	r3, r2
{
   1144a:	4604      	mov	r4, r0
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
   1144c:	d010      	beq.n	11470 <encrypt_change+0x38>
	hci_evt_create(buf, BT_HCI_EVT_ENCRYPT_CHANGE, sizeof(*ep));
   1144e:	2204      	movs	r2, #4
   11450:	2108      	movs	r1, #8
   11452:	4628      	mov	r0, r5
   11454:	f012 ff86 	bl	24364 <hci_evt_create>
	ep = net_buf_add(buf, sizeof(*ep));
   11458:	2104      	movs	r1, #4
   1145a:	f105 0008 	add.w	r0, r5, #8
   1145e:	f013 fcbb 	bl	24dd8 <net_buf_simple_add>
	ep->encrypt = !err ? 1 : 0;
   11462:	fab4 f384 	clz	r3, r4
   11466:	095b      	lsrs	r3, r3, #5
	ep->status = err;
   11468:	7004      	strb	r4, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
   1146a:	f8a0 6001 	strh.w	r6, [r0, #1]
	ep->encrypt = !err ? 1 : 0;
   1146e:	70c3      	strb	r3, [r0, #3]
}
   11470:	bd70      	pop	{r4, r5, r6, pc}
   11472:	bf00      	nop
   11474:	2000e628 	.word	0x2000e628

00011478 <hci_cmd_complete>:
{
   11478:	b538      	push	{r3, r4, r5, lr}
	*buf = bt_buf_get_evt(BT_HCI_EVT_CMD_COMPLETE, false, K_FOREVER);
   1147a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
   1147e:	4604      	mov	r4, r0
   11480:	460d      	mov	r5, r1
	*buf = bt_buf_get_evt(BT_HCI_EVT_CMD_COMPLETE, false, K_FOREVER);
   11482:	200e      	movs	r0, #14
   11484:	2100      	movs	r1, #0
   11486:	f7f9 f809 	bl	a49c <bt_buf_get_evt>
	hci_evt_create(*buf, BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
   1148a:	1cea      	adds	r2, r5, #3
	*buf = bt_buf_get_evt(BT_HCI_EVT_CMD_COMPLETE, false, K_FOREVER);
   1148c:	6020      	str	r0, [r4, #0]
	hci_evt_create(*buf, BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
   1148e:	b2d2      	uxtb	r2, r2
   11490:	210e      	movs	r1, #14
   11492:	f012 ff67 	bl	24364 <hci_evt_create>
	cc = net_buf_add(*buf, sizeof(*cc));
   11496:	6820      	ldr	r0, [r4, #0]
   11498:	2103      	movs	r1, #3
   1149a:	3008      	adds	r0, #8
   1149c:	f013 fc9c 	bl	24dd8 <net_buf_simple_add>
	cc->ncmd = 1U;
   114a0:	2301      	movs	r3, #1
   114a2:	7003      	strb	r3, [r0, #0]
	cc->opcode = sys_cpu_to_le16(_opcode);
   114a4:	4b05      	ldr	r3, [pc, #20]	; (114bc <hci_cmd_complete+0x44>)
   114a6:	881b      	ldrh	r3, [r3, #0]
   114a8:	f8a0 3001 	strh.w	r3, [r0, #1]
	return net_buf_add(*buf, plen);
   114ac:	6820      	ldr	r0, [r4, #0]
   114ae:	4629      	mov	r1, r5
   114b0:	3008      	adds	r0, #8
}
   114b2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return net_buf_add(*buf, plen);
   114b6:	f013 bc8f 	b.w	24dd8 <net_buf_simple_add>
   114ba:	bf00      	nop
   114bc:	2000613c 	.word	0x2000613c

000114c0 <hci_vendor_cmd_handle_common>:
{
   114c0:	b5f0      	push	{r4, r5, r6, r7, lr}
	switch (ocf) {
   114c2:	3801      	subs	r0, #1
{
   114c4:	b087      	sub	sp, #28
   114c6:	4615      	mov	r5, r2
	switch (ocf) {
   114c8:	2809      	cmp	r0, #9
   114ca:	f200 810a 	bhi.w	116e2 <hci_vendor_cmd_handle_common+0x222>
   114ce:	e8df f010 	tbh	[pc, r0, lsl #1]
   114d2:	000a      	.short	0x000a
   114d4:	00350022 	.word	0x00350022
   114d8:	01080108 	.word	0x01080108
   114dc:	01080066 	.word	0x01080066
   114e0:	00710041 	.word	0x00710041
   114e4:	00cc      	.short	0x00cc
	rp = hci_cmd_complete(evt, sizeof(*rp));
   114e6:	4610      	mov	r0, r2
   114e8:	210d      	movs	r1, #13
   114ea:	f7ff ffc5 	bl	11478 <hci_cmd_complete>
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
   114ee:	2202      	movs	r2, #2
   114f0:	7042      	strb	r2, [r0, #1]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
   114f2:	70c2      	strb	r2, [r0, #3]
	rp->fw_version = (KERNEL_VERSION_MAJOR & 0xff);
   114f4:	7182      	strb	r2, [r0, #6]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
   114f6:	2201      	movs	r2, #1
	rp->status = 0x00;
   114f8:	2300      	movs	r3, #0
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
   114fa:	71c2      	strb	r2, [r0, #7]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
   114fc:	2263      	movs	r2, #99	; 0x63
	rp->status = 0x00;
   114fe:	7003      	strb	r3, [r0, #0]
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
   11500:	7083      	strb	r3, [r0, #2]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
   11502:	7103      	strb	r3, [r0, #4]
	rp->fw_variant = 0U;
   11504:	7143      	strb	r3, [r0, #5]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
   11506:	7203      	strb	r3, [r0, #8]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
   11508:	7242      	strb	r2, [r0, #9]
   1150a:	7283      	strb	r3, [r0, #10]
   1150c:	72c3      	strb	r3, [r0, #11]
   1150e:	7303      	strb	r3, [r0, #12]
}
   11510:	4618      	mov	r0, r3
   11512:	b007      	add	sp, #28
   11514:	bdf0      	pop	{r4, r5, r6, r7, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11516:	2141      	movs	r1, #65	; 0x41
   11518:	4610      	mov	r0, r2
   1151a:	f7ff ffad 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   1151e:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11520:	4605      	mov	r5, r0
   11522:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
   11524:	f800 4b01 	strb.w	r4, [r0], #1
   11528:	4621      	mov	r1, r4
   1152a:	f7f0 fb80 	bl	1c2e <memset>
	rp->commands[0] |= BIT(5) | BIT(7);
   1152e:	f06f 0358 	mvn.w	r3, #88	; 0x58
   11532:	706b      	strb	r3, [r5, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
   11534:	2303      	movs	r3, #3
   11536:	70ab      	strb	r3, [r5, #2]
	return 0;
   11538:	2300      	movs	r3, #0
   1153a:	e7e9      	b.n	11510 <hci_vendor_cmd_handle_common+0x50>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1153c:	4610      	mov	r0, r2
   1153e:	2109      	movs	r1, #9
   11540:	f7ff ff9a 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   11544:	4602      	mov	r2, r0
   11546:	2300      	movs	r3, #0
   11548:	f802 3b01 	strb.w	r3, [r2], #1
   1154c:	f8c0 3001 	str.w	r3, [r0, #1]
   11550:	6053      	str	r3, [r2, #4]
   11552:	e7dd      	b.n	11510 <hci_vendor_cmd_handle_common+0x50>
	const char build_info[] = HCI_VS_BUILD_INFO;
   11554:	4b64      	ldr	r3, [pc, #400]	; (116e8 <hci_vendor_cmd_handle_common+0x228>)
   11556:	aa01      	add	r2, sp, #4
   11558:	f103 0710 	add.w	r7, r3, #16
   1155c:	4614      	mov	r4, r2
   1155e:	6818      	ldr	r0, [r3, #0]
   11560:	6859      	ldr	r1, [r3, #4]
   11562:	4616      	mov	r6, r2
   11564:	c603      	stmia	r6!, {r0, r1}
   11566:	3308      	adds	r3, #8
   11568:	42bb      	cmp	r3, r7
   1156a:	4632      	mov	r2, r6
   1156c:	d1f7      	bne.n	1155e <hci_vendor_cmd_handle_common+0x9e>
   1156e:	881b      	ldrh	r3, [r3, #0]
   11570:	8033      	strh	r3, [r6, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(build_info));
   11572:	4628      	mov	r0, r5
   11574:	2113      	movs	r1, #19
   11576:	f7ff ff7f 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   1157a:	4603      	mov	r3, r0
   1157c:	2200      	movs	r2, #0
   1157e:	f803 2b01 	strb.w	r2, [r3], #1
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   11582:	ad05      	add	r5, sp, #20
   11584:	4622      	mov	r2, r4
   11586:	4614      	mov	r4, r2
   11588:	cc03      	ldmia	r4!, {r0, r1}
   1158a:	42ac      	cmp	r4, r5
   1158c:	6018      	str	r0, [r3, #0]
   1158e:	6059      	str	r1, [r3, #4]
   11590:	4622      	mov	r2, r4
   11592:	f103 0308 	add.w	r3, r3, #8
   11596:	d1f6      	bne.n	11586 <hci_vendor_cmd_handle_common+0xc6>
   11598:	8822      	ldrh	r2, [r4, #0]
   1159a:	801a      	strh	r2, [r3, #0]
   1159c:	e7cc      	b.n	11538 <hci_vendor_cmd_handle_common+0x78>
	ll_addr_set(0, &cmd->bdaddr.val[0]);
   1159e:	6889      	ldr	r1, [r1, #8]
   115a0:	2000      	movs	r0, #0
   115a2:	f7ff fda3 	bl	110ec <ll_addr_set>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   115a6:	2101      	movs	r1, #1
   115a8:	4628      	mov	r0, r5
   115aa:	f7ff ff65 	bl	11478 <hci_cmd_complete>
	ccst->status = 0x00;
   115ae:	2300      	movs	r3, #0
   115b0:	7003      	strb	r3, [r0, #0]
   115b2:	e7ad      	b.n	11510 <hci_vendor_cmd_handle_common+0x50>
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   115b4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   115b8:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
   115bc:	3201      	adds	r2, #1
   115be:	d106      	bne.n	115ce <hci_vendor_cmd_handle_common+0x10e>
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   115c0:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   115c4:	f64f 72ff 	movw	r2, #65535	; 0xffff
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   115c8:	b29b      	uxth	r3, r3
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   115ca:	4293      	cmp	r3, r2
   115cc:	d045      	beq.n	1165a <hci_vendor_cmd_handle_common+0x19a>
	      (NRF_FICR->DEVICEADDRTYPE & 0x01)) {
   115ce:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
   115d2:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   115d6:	07db      	lsls	r3, r3, #31
   115d8:	d53f      	bpl.n	1165a <hci_vendor_cmd_handle_common+0x19a>
		rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(*addr));
   115da:	2118      	movs	r1, #24
   115dc:	4628      	mov	r0, r5
   115de:	f7ff ff4b 	bl	11478 <hci_cmd_complete>
		rp->num_addrs = 1U;
   115e2:	2301      	movs	r3, #1
		rp->status = 0x00;
   115e4:	2200      	movs	r2, #0
		rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(*addr));
   115e6:	4605      	mov	r5, r0
		rp->num_addrs = 1U;
   115e8:	7043      	strb	r3, [r0, #1]
		rp->status = 0x00;
   115ea:	7002      	strb	r2, [r0, #0]
		sys_put_le32(NRF_FICR->DEVICEADDR[0], &addr->bdaddr.val[0]);
   115ec:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
   115f0:	1ca9      	adds	r1, r5, #2
   115f2:	f012 fea2 	bl	2433a <sys_put_le32>
		sys_put_le16(NRF_FICR->DEVICEADDR[1], &addr->bdaddr.val[4]);
   115f6:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
	dst[0] = val;
   115fa:	71ab      	strb	r3, [r5, #6]
	dst[1] = val >> 8;
   115fc:	f3c3 2307 	ubfx	r3, r3, #8, #8
		BT_ADDR_SET_STATIC(&addr->bdaddr);
   11600:	f063 033f 	orn	r3, r3, #63	; 0x3f
   11604:	71eb      	strb	r3, [r5, #7]
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   11606:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
   1160a:	3301      	adds	r3, #1
   1160c:	f105 0308 	add.w	r3, r5, #8
   11610:	d061      	beq.n	116d6 <hci_vendor_cmd_handle_common+0x216>
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
   11612:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   11616:	3101      	adds	r1, #1
   11618:	d05d      	beq.n	116d6 <hci_vendor_cmd_handle_common+0x216>
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
   1161a:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
   1161e:	3101      	adds	r1, #1
   11620:	d059      	beq.n	116d6 <hci_vendor_cmd_handle_common+0x216>
		    (NRF_FICR->IR[3] != UINT32_MAX)) {
   11622:	f8d4 109c 	ldr.w	r1, [r4, #156]	; 0x9c
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
   11626:	3101      	adds	r1, #1
   11628:	d055      	beq.n	116d6 <hci_vendor_cmd_handle_common+0x216>
			sys_put_le32(NRF_FICR->IR[0], &addr->ir[0]);
   1162a:	4619      	mov	r1, r3
   1162c:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
   11630:	f012 fe83 	bl	2433a <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[1], &addr->ir[4]);
   11634:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
   11638:	f105 010c 	add.w	r1, r5, #12
   1163c:	f012 fe7d 	bl	2433a <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[2], &addr->ir[8]);
   11640:	f8d4 0098 	ldr.w	r0, [r4, #152]	; 0x98
   11644:	f105 0110 	add.w	r1, r5, #16
   11648:	f012 fe77 	bl	2433a <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[3], &addr->ir[12]);
   1164c:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
   11650:	f105 0114 	add.w	r1, r5, #20
		sys_put_le32(NRF_FICR->ER[3], &rp->er[12]);
   11654:	f012 fe71 	bl	2433a <sys_put_le32>
   11658:	e76e      	b.n	11538 <hci_vendor_cmd_handle_common+0x78>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1165a:	2102      	movs	r1, #2
   1165c:	4628      	mov	r0, r5
   1165e:	f7ff ff0b 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   11662:	2300      	movs	r3, #0
   11664:	7003      	strb	r3, [r0, #0]
	rp->num_addrs = 0U;
   11666:	7043      	strb	r3, [r0, #1]
   11668:	e752      	b.n	11510 <hci_vendor_cmd_handle_common+0x50>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1166a:	2121      	movs	r1, #33	; 0x21
   1166c:	4610      	mov	r0, r2
   1166e:	f7ff ff03 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   11672:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11674:	4605      	mov	r5, r0
__ssp_bos_icheck3(memset, void *, int)
   11676:	2210      	movs	r2, #16
	rp->status = 0x00;
   11678:	f800 4b01 	strb.w	r4, [r0], #1
   1167c:	4621      	mov	r1, r4
   1167e:	f7f0 fad6 	bl	1c2e <memset>
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
   11682:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   11686:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
   1168a:	3301      	adds	r3, #1
   1168c:	f105 0311 	add.w	r3, r5, #17
   11690:	d021      	beq.n	116d6 <hci_vendor_cmd_handle_common+0x216>
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
   11692:	f8d2 1084 	ldr.w	r1, [r2, #132]	; 0x84
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
   11696:	3101      	adds	r1, #1
   11698:	d01d      	beq.n	116d6 <hci_vendor_cmd_handle_common+0x216>
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
   1169a:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
   1169e:	3101      	adds	r1, #1
   116a0:	d019      	beq.n	116d6 <hci_vendor_cmd_handle_common+0x216>
	    (NRF_FICR->ER[3] != UINT32_MAX)) {
   116a2:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
   116a6:	3101      	adds	r1, #1
   116a8:	d015      	beq.n	116d6 <hci_vendor_cmd_handle_common+0x216>
		sys_put_le32(NRF_FICR->ER[0], &rp->er[0]);
   116aa:	f8d2 0080 	ldr.w	r0, [r2, #128]	; 0x80
   116ae:	4619      	mov	r1, r3
   116b0:	f012 fe43 	bl	2433a <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[1], &rp->er[4]);
   116b4:	f105 0115 	add.w	r1, r5, #21
   116b8:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
   116bc:	f012 fe3d 	bl	2433a <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[2], &rp->er[8]);
   116c0:	f105 0119 	add.w	r1, r5, #25
   116c4:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88
   116c8:	f012 fe37 	bl	2433a <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[3], &rp->er[12]);
   116cc:	f105 011d 	add.w	r1, r5, #29
   116d0:	f8d2 008c 	ldr.w	r0, [r2, #140]	; 0x8c
   116d4:	e7be      	b.n	11654 <hci_vendor_cmd_handle_common+0x194>
   116d6:	2210      	movs	r2, #16
   116d8:	2100      	movs	r1, #0
   116da:	4618      	mov	r0, r3
   116dc:	f7f0 faa7 	bl	1c2e <memset>
   116e0:	e72a      	b.n	11538 <hci_vendor_cmd_handle_common+0x78>
		return -EINVAL;
   116e2:	f06f 0315 	mvn.w	r3, #21
   116e6:	e713      	b.n	11510 <hci_vendor_cmd_handle_common+0x50>
   116e8:	000642f9 	.word	0x000642f9

000116ec <hci_cmd_handle>:
{
   116ec:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (cmd->len < sizeof(*chdr)) {
   116ee:	8983      	ldrh	r3, [r0, #12]
{
   116f0:	b08d      	sub	sp, #52	; 0x34
	struct net_buf *evt = NULL;
   116f2:	2600      	movs	r6, #0
	if (cmd->len < sizeof(*chdr)) {
   116f4:	2b02      	cmp	r3, #2
{
   116f6:	4604      	mov	r4, r0
	struct net_buf *evt = NULL;
   116f8:	9607      	str	r6, [sp, #28]
	if (cmd->len < sizeof(*chdr)) {
   116fa:	d810      	bhi.n	1171e <hci_cmd_handle+0x32>
		BT_ERR("No HCI Command header");
   116fc:	2301      	movs	r3, #1
   116fe:	f04f 0100 	mov.w	r1, #0
   11702:	f363 0107 	bfi	r1, r3, #0, #8
   11706:	4aa3      	ldr	r2, [pc, #652]	; (11994 <hci_cmd_handle+0x2a8>)
   11708:	4ba3      	ldr	r3, [pc, #652]	; (11998 <hci_cmd_handle+0x2ac>)
   1170a:	48a4      	ldr	r0, [pc, #656]	; (1199c <hci_cmd_handle+0x2b0>)
   1170c:	1a9b      	subs	r3, r3, r2
   1170e:	08db      	lsrs	r3, r3, #3
   11710:	f363 118f 	bfi	r1, r3, #6, #10
		BT_ERR("Invalid HCI CMD packet length");
   11714:	f00f fc91 	bl	2103a <log_0>
		return NULL;
   11718:	4630      	mov	r0, r6
}
   1171a:	b00d      	add	sp, #52	; 0x34
   1171c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	chdr = net_buf_pull_mem(cmd, sizeof(*chdr));
   1171e:	2103      	movs	r1, #3
   11720:	3008      	adds	r0, #8
   11722:	f013 fb8b 	bl	24e3c <net_buf_simple_pull_mem>
	if (cmd->len < chdr->param_len) {
   11726:	89a2      	ldrh	r2, [r4, #12]
   11728:	7883      	ldrb	r3, [r0, #2]
   1172a:	429a      	cmp	r2, r3
   1172c:	d20c      	bcs.n	11748 <hci_cmd_handle+0x5c>
		BT_ERR("Invalid HCI CMD packet length");
   1172e:	2301      	movs	r3, #1
   11730:	f04f 0100 	mov.w	r1, #0
   11734:	f363 0107 	bfi	r1, r3, #0, #8
   11738:	4a96      	ldr	r2, [pc, #600]	; (11994 <hci_cmd_handle+0x2a8>)
   1173a:	4b97      	ldr	r3, [pc, #604]	; (11998 <hci_cmd_handle+0x2ac>)
   1173c:	4898      	ldr	r0, [pc, #608]	; (119a0 <hci_cmd_handle+0x2b4>)
   1173e:	1a9b      	subs	r3, r3, r2
   11740:	08db      	lsrs	r3, r3, #3
   11742:	f363 118f 	bfi	r1, r3, #6, #10
   11746:	e7e5      	b.n	11714 <hci_cmd_handle+0x28>
	_opcode = sys_le16_to_cpu(chdr->opcode);
   11748:	8802      	ldrh	r2, [r0, #0]
   1174a:	4996      	ldr	r1, [pc, #600]	; (119a4 <hci_cmd_handle+0x2b8>)
   1174c:	b293      	uxth	r3, r2
	ocf = BT_OCF(_opcode);
   1174e:	f3c3 0509 	ubfx	r5, r3, #0, #10
	switch (BT_OGF(_opcode)) {
   11752:	0a9b      	lsrs	r3, r3, #10
   11754:	2b04      	cmp	r3, #4
	_opcode = sys_le16_to_cpu(chdr->opcode);
   11756:	800a      	strh	r2, [r1, #0]
	switch (BT_OGF(_opcode)) {
   11758:	f000 809a 	beq.w	11890 <hci_cmd_handle+0x1a4>
   1175c:	d809      	bhi.n	11772 <hci_cmd_handle+0x86>
   1175e:	2b01      	cmp	r3, #1
   11760:	d014      	beq.n	1178c <hci_cmd_handle+0xa0>
   11762:	2b03      	cmp	r3, #3
   11764:	d024      	beq.n	117b0 <hci_cmd_handle+0xc4>
		ccst = hci_cmd_complete(&evt, sizeof(*ccst));
   11766:	2101      	movs	r1, #1
   11768:	a807      	add	r0, sp, #28
   1176a:	f7ff fe85 	bl	11478 <hci_cmd_complete>
		ccst->status = BT_HCI_ERR_UNKNOWN_CMD;
   1176e:	2301      	movs	r3, #1
   11770:	e03d      	b.n	117ee <hci_cmd_handle+0x102>
	switch (BT_OGF(_opcode)) {
   11772:	2b08      	cmp	r3, #8
   11774:	f000 811e 	beq.w	119b4 <hci_cmd_handle+0x2c8>
   11778:	2b3f      	cmp	r3, #63	; 0x3f
   1177a:	d1f4      	bne.n	11766 <hci_cmd_handle+0x7a>

/* Map vendor command handler directly to common implementation */
inline int hci_vendor_cmd_handle(u16_t ocf, struct net_buf *cmd,
				 struct net_buf **evt)
{
	return hci_vendor_cmd_handle_common(ocf, cmd, evt);
   1177c:	aa07      	add	r2, sp, #28
   1177e:	4621      	mov	r1, r4
   11780:	4628      	mov	r0, r5
   11782:	f7ff fe9d 	bl	114c0 <hci_vendor_cmd_handle_common>
	if (err == -EINVAL) {
   11786:	3016      	adds	r0, #22
   11788:	d0ed      	beq.n	11766 <hci_cmd_handle+0x7a>
   1178a:	e04a      	b.n	11822 <hci_cmd_handle+0x136>
	switch (ocf) {
   1178c:	2d06      	cmp	r5, #6
   1178e:	d006      	beq.n	1179e <hci_cmd_handle+0xb2>
   11790:	2d1d      	cmp	r5, #29
   11792:	d1e8      	bne.n	11766 <hci_cmd_handle+0x7a>
	handle = sys_le16_to_cpu(cmd->handle);
   11794:	68a3      	ldr	r3, [r4, #8]
	status = ll_version_ind_send(handle);
   11796:	8818      	ldrh	r0, [r3, #0]
   11798:	f013 f8a8 	bl	248ec <ll_version_ind_send>
	*evt = cmd_status(status);
   1179c:	e004      	b.n	117a8 <hci_cmd_handle+0xbc>
		disconnect(cmd, evt);
   1179e:	68a3      	ldr	r3, [r4, #8]
	status = ll_terminate_ind_send(handle, cmd->reason);
   117a0:	7899      	ldrb	r1, [r3, #2]
   117a2:	8818      	ldrh	r0, [r3, #0]
   117a4:	f013 f881 	bl	248aa <ll_terminate_ind_send>
	*evt = cmd_status(status);
   117a8:	f7ff fdfc 	bl	113a4 <cmd_status>
   117ac:	9007      	str	r0, [sp, #28]
	if (err == -EINVAL) {
   117ae:	e038      	b.n	11822 <hci_cmd_handle+0x136>
	switch (ocf) {
   117b0:	2d2d      	cmp	r5, #45	; 0x2d
   117b2:	d038      	beq.n	11826 <hci_cmd_handle+0x13a>
   117b4:	d81d      	bhi.n	117f2 <hci_cmd_handle+0x106>
   117b6:	2d01      	cmp	r5, #1
   117b8:	d028      	beq.n	1180c <hci_cmd_handle+0x120>
   117ba:	2d03      	cmp	r5, #3
   117bc:	d1d3      	bne.n	11766 <hci_cmd_handle+0x7a>
	event_mask = DEFAULT_EVENT_MASK;
   117be:	4b7a      	ldr	r3, [pc, #488]	; (119a8 <hci_cmd_handle+0x2bc>)
   117c0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   117c4:	f641 71ff 	movw	r1, #8191	; 0x1fff
   117c8:	e9c3 0100 	strd	r0, r1, [r3]
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
   117cc:	4b77      	ldr	r3, [pc, #476]	; (119ac <hci_cmd_handle+0x2c0>)
   117ce:	2000      	movs	r0, #0
   117d0:	2100      	movs	r1, #0
   117d2:	e9c3 0100 	strd	r0, r1, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
   117d6:	4b76      	ldr	r3, [pc, #472]	; (119b0 <hci_cmd_handle+0x2c4>)
   117d8:	201f      	movs	r0, #31
   117da:	2100      	movs	r1, #0
   117dc:	e9c3 0100 	strd	r0, r1, [r3]
		ll_reset();
   117e0:	f001 f8fe 	bl	129e0 <ll_reset>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   117e4:	2101      	movs	r1, #1
   117e6:	a807      	add	r0, sp, #28
   117e8:	f7ff fe46 	bl	11478 <hci_cmd_complete>
	ccst->status = 0x00;
   117ec:	2300      	movs	r3, #0
		ccst->status = BT_HCI_ERR_UNKNOWN_CMD;
   117ee:	7003      	strb	r3, [r0, #0]
   117f0:	e017      	b.n	11822 <hci_cmd_handle+0x136>
	switch (ocf) {
   117f2:	2d7b      	cmp	r5, #123	; 0x7b
   117f4:	d02a      	beq.n	1184c <hci_cmd_handle+0x160>
   117f6:	2d7c      	cmp	r5, #124	; 0x7c
   117f8:	d03b      	beq.n	11872 <hci_cmd_handle+0x186>
   117fa:	2d63      	cmp	r5, #99	; 0x63
   117fc:	d1b3      	bne.n	11766 <hci_cmd_handle+0x7a>
	event_mask_page_2 = sys_get_le64(cmd->events_page_2);
   117fe:	68a0      	ldr	r0, [r4, #8]
   11800:	f012 fdac 	bl	2435c <sys_get_le64>
   11804:	4b69      	ldr	r3, [pc, #420]	; (119ac <hci_cmd_handle+0x2c0>)
	le_event_mask = sys_get_le64(cmd->events);
   11806:	e9c3 0100 	strd	r0, r1, [r3]
   1180a:	e7eb      	b.n	117e4 <hci_cmd_handle+0xf8>
	event_mask = sys_get_le64(cmd->events);
   1180c:	68a0      	ldr	r0, [r4, #8]
   1180e:	f012 fda5 	bl	2435c <sys_get_le64>
   11812:	4b65      	ldr	r3, [pc, #404]	; (119a8 <hci_cmd_handle+0x2bc>)
   11814:	e9c3 0100 	strd	r0, r1, [r3]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   11818:	4629      	mov	r1, r5
   1181a:	a807      	add	r0, sp, #28
   1181c:	f7ff fe2c 	bl	11478 <hci_cmd_complete>
	ccst->status = 0x00;
   11820:	7006      	strb	r6, [r0, #0]
	return evt;
   11822:	9807      	ldr	r0, [sp, #28]
   11824:	e779      	b.n	1171a <hci_cmd_handle+0x2e>
		read_tx_power_level(cmd, evt);
   11826:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11828:	2104      	movs	r1, #4
   1182a:	a807      	add	r0, sp, #28
	handle = sys_le16_to_cpu(cmd->handle);
   1182c:	881d      	ldrh	r5, [r3, #0]
	type = cmd->type;
   1182e:	789f      	ldrb	r7, [r3, #2]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11830:	f7ff fe22 	bl	11478 <hci_cmd_complete>
	handle = sys_le16_to_cpu(cmd->handle);
   11834:	b2ae      	uxth	r6, r5
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11836:	4604      	mov	r4, r0
	status = ll_tx_pwr_lvl_get(BT_HCI_VS_LL_HANDLE_TYPE_CONN,
   11838:	1cc3      	adds	r3, r0, #3
   1183a:	463a      	mov	r2, r7
   1183c:	4631      	mov	r1, r6
   1183e:	2002      	movs	r0, #2
   11840:	f012 fd68 	bl	24314 <ll_tx_pwr_lvl_get>
	rp->status = status;
   11844:	7020      	strb	r0, [r4, #0]
	rp->handle = sys_le16_to_cpu(handle);
   11846:	f8a4 5001 	strh.w	r5, [r4, #1]
	if (err == -EINVAL) {
   1184a:	e7ea      	b.n	11822 <hci_cmd_handle+0x136>
	handle = sys_le16_to_cpu(cmd->handle);
   1184c:	68a3      	ldr	r3, [r4, #8]
   1184e:	881c      	ldrh	r4, [r3, #0]
	status = ll_apto_get(handle, &auth_payload_timeout);
   11850:	a908      	add	r1, sp, #32
   11852:	4620      	mov	r0, r4
   11854:	f013 f8de 	bl	24a14 <ll_apto_get>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11858:	2105      	movs	r1, #5
	status = ll_apto_get(handle, &auth_payload_timeout);
   1185a:	4605      	mov	r5, r0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1185c:	a807      	add	r0, sp, #28
   1185e:	f7ff fe0b 	bl	11478 <hci_cmd_complete>
	rp->status = status;
   11862:	7005      	strb	r5, [r0, #0]
	rp->handle = sys_cpu_to_le16(handle);
   11864:	f8a0 4001 	strh.w	r4, [r0, #1]
	rp->auth_payload_timeout = sys_cpu_to_le16(auth_payload_timeout);
   11868:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   1186c:	f8a0 3003 	strh.w	r3, [r0, #3]
   11870:	e7d7      	b.n	11822 <hci_cmd_handle+0x136>
		write_auth_payload_timeout(cmd, evt);
   11872:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
   11874:	881c      	ldrh	r4, [r3, #0]
	status = ll_apto_set(handle, auth_payload_timeout);
   11876:	8859      	ldrh	r1, [r3, #2]
   11878:	4620      	mov	r0, r4
   1187a:	f013 f8df 	bl	24a3c <ll_apto_set>
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
   1187e:	4605      	mov	r5, r0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11880:	2103      	movs	r1, #3
   11882:	a807      	add	r0, sp, #28
   11884:	f7ff fdf8 	bl	11478 <hci_cmd_complete>
	rp->status = status;
   11888:	7005      	strb	r5, [r0, #0]
	rp->handle = sys_cpu_to_le16(handle);
   1188a:	f8a0 4001 	strh.w	r4, [r0, #1]
	if (err == -EINVAL) {
   1188e:	e7c8      	b.n	11822 <hci_cmd_handle+0x136>
	switch (ocf) {
   11890:	3d01      	subs	r5, #1
   11892:	2d08      	cmp	r5, #8
   11894:	f63f af67 	bhi.w	11766 <hci_cmd_handle+0x7a>
   11898:	a301      	add	r3, pc, #4	; (adr r3, 118a0 <hci_cmd_handle+0x1b4>)
   1189a:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
   1189e:	bf00      	nop
   118a0:	000118c5 	.word	0x000118c5
   118a4:	000118ef 	.word	0x000118ef
   118a8:	00011961 	.word	0x00011961
   118ac:	00011767 	.word	0x00011767
   118b0:	00011767 	.word	0x00011767
   118b4:	00011767 	.word	0x00011767
   118b8:	00011767 	.word	0x00011767
   118bc:	00011767 	.word	0x00011767
   118c0:	0001197d 	.word	0x0001197d
	rp = hci_cmd_complete(evt, sizeof(*rp));
   118c4:	2109      	movs	r1, #9
   118c6:	a807      	add	r0, sp, #28
   118c8:	f7ff fdd6 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   118cc:	2300      	movs	r3, #0
   118ce:	7003      	strb	r3, [r0, #0]
	rp->hci_revision = sys_cpu_to_le16(0);
   118d0:	7083      	strb	r3, [r0, #2]
   118d2:	70c3      	strb	r3, [r0, #3]
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
   118d4:	f06f 030e 	mvn.w	r3, #14
   118d8:	7143      	strb	r3, [r0, #5]
   118da:	2305      	movs	r3, #5
	rp->hci_version = LL_VERSION_NUMBER;
   118dc:	220a      	movs	r2, #10
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
   118de:	7183      	strb	r3, [r0, #6]
	rp->lmp_subversion = sys_cpu_to_le16(ll_settings_subversion_number());
   118e0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	rp->hci_version = LL_VERSION_NUMBER;
   118e4:	7042      	strb	r2, [r0, #1]
	rp->lmp_version = LL_VERSION_NUMBER;
   118e6:	7102      	strb	r2, [r0, #4]
	rp->lmp_subversion = sys_cpu_to_le16(ll_settings_subversion_number());
   118e8:	71c3      	strb	r3, [r0, #7]
   118ea:	7203      	strb	r3, [r0, #8]
	if (err == -EINVAL) {
   118ec:	e799      	b.n	11822 <hci_cmd_handle+0x136>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   118ee:	2141      	movs	r1, #65	; 0x41
   118f0:	a807      	add	r0, sp, #28
   118f2:	f7ff fdc1 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   118f6:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   118f8:	4604      	mov	r4, r0
   118fa:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
   118fc:	f800 1b01 	strb.w	r1, [r0], #1
   11900:	f7f0 f995 	bl	1c2e <memset>
	rp->commands[5] |= BIT(6) | BIT(7);
   11904:	f06f 033f 	mvn.w	r3, #63	; 0x3f
   11908:	71a3      	strb	r3, [r4, #6]
	rp->commands[10] |= BIT(2);
   1190a:	2304      	movs	r3, #4
   1190c:	72e3      	strb	r3, [r4, #11]
	rp->commands[14] |= BIT(3) | BIT(5);
   1190e:	2328      	movs	r3, #40	; 0x28
   11910:	73e3      	strb	r3, [r4, #15]
	rp->commands[15] |= BIT(1);
   11912:	2302      	movs	r3, #2
   11914:	7423      	strb	r3, [r4, #16]
	rp->commands[22] |= BIT(2);
   11916:	2304      	movs	r3, #4
   11918:	75e3      	strb	r3, [r4, #23]
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
   1191a:	f06f 0308 	mvn.w	r3, #8
   1191e:	76a3      	strb	r3, [r4, #26]
	rp->commands[26] |= BIT(0) | BIT(1);
   11920:	f06f 033c 	mvn.w	r3, #60	; 0x3c
   11924:	76e3      	strb	r3, [r4, #27]
	rp->commands[28] |= BIT(1) | BIT(2);
   11926:	230e      	movs	r3, #14
   11928:	7763      	strb	r3, [r4, #29]
	rp->commands[0] |= BIT(5);
   1192a:	2320      	movs	r3, #32
   1192c:	7063      	strb	r3, [r4, #1]
	rp->commands[27] |= BIT(2) | BIT(4) | BIT(5);
   1192e:	f06f 0308 	mvn.w	r3, #8
   11932:	7723      	strb	r3, [r4, #28]
	rp->commands[32] |= BIT(4) | BIT(5);
   11934:	2330      	movs	r3, #48	; 0x30
   11936:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
	rp->commands[33] |= BIT(6) | BIT(7);
   1193a:	f06f 030f 	mvn.w	r3, #15
   1193e:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	rp->commands[34] |= BIT(3) | BIT(4) | BIT(5) | BIT(6) | BIT(7);
   11942:	f06f 0306 	mvn.w	r3, #6
   11946:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	rp->commands[35] |= BIT(0) | BIT(1) | BIT(2);
   1194a:	237f      	movs	r3, #127	; 0x7f
   1194c:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
	rp->commands[39] |= BIT(2);
   11950:	2304      	movs	r3, #4
   11952:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	rp->commands[38] |= BIT(7);
   11956:	f06f 037f 	mvn.w	r3, #127	; 0x7f
   1195a:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
	if (err == -EINVAL) {
   1195e:	e760      	b.n	11822 <hci_cmd_handle+0x136>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11960:	2109      	movs	r1, #9
   11962:	a807      	add	r0, sp, #28
   11964:	f7ff fd88 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   11968:	4603      	mov	r3, r0
   1196a:	2200      	movs	r2, #0
   1196c:	f803 2b01 	strb.w	r2, [r3], #1
   11970:	f8c0 2001 	str.w	r2, [r0, #1]
   11974:	605a      	str	r2, [r3, #4]
	rp->features[4] = (1 << 5) | (1 << 6);
   11976:	2360      	movs	r3, #96	; 0x60
   11978:	7143      	strb	r3, [r0, #5]
	if (err == -EINVAL) {
   1197a:	e752      	b.n	11822 <hci_cmd_handle+0x136>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1197c:	2107      	movs	r1, #7
   1197e:	a807      	add	r0, sp, #28
   11980:	f7ff fd7a 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   11984:	4601      	mov	r1, r0
   11986:	2300      	movs	r3, #0
   11988:	f801 3b01 	strb.w	r3, [r1], #1
	ll_addr_get(0, &rp->bdaddr.val[0]);
   1198c:	4618      	mov	r0, r3
   1198e:	f7ff fb9b 	bl	110c8 <ll_addr_get>
	if (err == -EINVAL) {
   11992:	e746      	b.n	11822 <hci_cmd_handle+0x136>
   11994:	00028540 	.word	0x00028540
   11998:	00028588 	.word	0x00028588
   1199c:	0006428c 	.word	0x0006428c
   119a0:	000642a2 	.word	0x000642a2
   119a4:	2000613c 	.word	0x2000613c
   119a8:	2000e628 	.word	0x2000e628
   119ac:	20000008 	.word	0x20000008
   119b0:	2000e630 	.word	0x2000e630
	switch (ocf) {
   119b4:	3d01      	subs	r5, #1
   119b6:	2d4d      	cmp	r5, #77	; 0x4d
   119b8:	f63f aed5 	bhi.w	11766 <hci_cmd_handle+0x7a>
   119bc:	a301      	add	r3, pc, #4	; (adr r3, 119c4 <hci_cmd_handle+0x2d8>)
   119be:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
   119c2:	bf00      	nop
   119c4:	00011afd 	.word	0x00011afd
   119c8:	00011b07 	.word	0x00011b07
   119cc:	00011b1f 	.word	0x00011b1f
   119d0:	00011767 	.word	0x00011767
   119d4:	00011b41 	.word	0x00011b41
   119d8:	00011bff 	.word	0x00011bff
   119dc:	00011c1b 	.word	0x00011c1b
   119e0:	00011c2b 	.word	0x00011c2b
   119e4:	00011c37 	.word	0x00011c37
   119e8:	00011c43 	.word	0x00011c43
   119ec:	00011767 	.word	0x00011767
   119f0:	00011767 	.word	0x00011767
   119f4:	00011767 	.word	0x00011767
   119f8:	00011767 	.word	0x00011767
   119fc:	00011b57 	.word	0x00011b57
   11a00:	00011b6d 	.word	0x00011b6d
   11a04:	00011b7f 	.word	0x00011b7f
   11a08:	00011b87 	.word	0x00011b87
   11a0c:	00011c8b 	.word	0x00011c8b
   11a10:	00011767 	.word	0x00011767
   11a14:	00011c67 	.word	0x00011c67
   11a18:	00011c81 	.word	0x00011c81
   11a1c:	00011b8f 	.word	0x00011b8f
   11a20:	00011bc5 	.word	0x00011bc5
   11a24:	00011767 	.word	0x00011767
   11a28:	00011c4d 	.word	0x00011c4d
   11a2c:	00011c5d 	.word	0x00011c5d
   11a30:	00011bdb 	.word	0x00011bdb
   11a34:	00011767 	.word	0x00011767
   11a38:	00011767 	.word	0x00011767
   11a3c:	00011767 	.word	0x00011767
   11a40:	00011ca7 	.word	0x00011ca7
   11a44:	00011cc5 	.word	0x00011cc5
   11a48:	00011cd5 	.word	0x00011cd5
   11a4c:	00011ce5 	.word	0x00011ce5
   11a50:	00011d0f 	.word	0x00011d0f
   11a54:	00011767 	.word	0x00011767
   11a58:	00011767 	.word	0x00011767
   11a5c:	00011e0d 	.word	0x00011e0d
   11a60:	00011e1b 	.word	0x00011e1b
   11a64:	00011e23 	.word	0x00011e23
   11a68:	00011e33 	.word	0x00011e33
   11a6c:	00011e45 	.word	0x00011e45
   11a70:	00011e61 	.word	0x00011e61
   11a74:	00011e7d 	.word	0x00011e7d
   11a78:	00011e93 	.word	0x00011e93
   11a7c:	00011d1b 	.word	0x00011d1b
   11a80:	00011d43 	.word	0x00011d43
   11a84:	00011d91 	.word	0x00011d91
   11a88:	00011daf 	.word	0x00011daf
   11a8c:	00011767 	.word	0x00011767
   11a90:	00011767 	.word	0x00011767
   11a94:	00011767 	.word	0x00011767
   11a98:	00011767 	.word	0x00011767
   11a9c:	00011767 	.word	0x00011767
   11aa0:	00011767 	.word	0x00011767
   11aa4:	00011767 	.word	0x00011767
   11aa8:	00011767 	.word	0x00011767
   11aac:	00011767 	.word	0x00011767
   11ab0:	00011767 	.word	0x00011767
   11ab4:	00011767 	.word	0x00011767
   11ab8:	00011767 	.word	0x00011767
   11abc:	00011767 	.word	0x00011767
   11ac0:	00011767 	.word	0x00011767
   11ac4:	00011767 	.word	0x00011767
   11ac8:	00011767 	.word	0x00011767
   11acc:	00011767 	.word	0x00011767
   11ad0:	00011767 	.word	0x00011767
   11ad4:	00011767 	.word	0x00011767
   11ad8:	00011767 	.word	0x00011767
   11adc:	00011767 	.word	0x00011767
   11ae0:	00011767 	.word	0x00011767
   11ae4:	00011767 	.word	0x00011767
   11ae8:	00011767 	.word	0x00011767
   11aec:	00011ea7 	.word	0x00011ea7
   11af0:	00011767 	.word	0x00011767
   11af4:	00011767 	.word	0x00011767
   11af8:	00011e9d 	.word	0x00011e9d
	le_event_mask = sys_get_le64(cmd->events);
   11afc:	68a0      	ldr	r0, [r4, #8]
   11afe:	f012 fc2d 	bl	2435c <sys_get_le64>
   11b02:	4bc0      	ldr	r3, [pc, #768]	; (11e04 <hci_cmd_handle+0x718>)
   11b04:	e67f      	b.n	11806 <hci_cmd_handle+0x11a>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11b06:	2104      	movs	r1, #4
   11b08:	a807      	add	r0, sp, #28
   11b0a:	f7ff fcb5 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   11b0e:	2300      	movs	r3, #0
	rp->le_max_len = sys_cpu_to_le16(CONFIG_BT_CTLR_TX_BUFFER_SIZE);
   11b10:	221b      	movs	r2, #27
	rp->status = 0x00;
   11b12:	7003      	strb	r3, [r0, #0]
	rp->le_max_len = sys_cpu_to_le16(CONFIG_BT_CTLR_TX_BUFFER_SIZE);
   11b14:	7083      	strb	r3, [r0, #2]
   11b16:	7042      	strb	r2, [r0, #1]
	rp->le_max_num = CONFIG_BT_CTLR_TX_BUFFERS;
   11b18:	2303      	movs	r3, #3
	dst[2] = val >> 16;
   11b1a:	70c3      	strb	r3, [r0, #3]
	if (err == -EINVAL) {
   11b1c:	e681      	b.n	11822 <hci_cmd_handle+0x136>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11b1e:	2109      	movs	r1, #9
   11b20:	a807      	add	r0, sp, #28
   11b22:	f7ff fca9 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   11b26:	4603      	mov	r3, r0
   11b28:	2200      	movs	r2, #0
   11b2a:	f803 2b01 	strb.w	r2, [r3], #1
   11b2e:	f8c0 2001 	str.w	r2, [r0, #1]
   11b32:	605a      	str	r2, [r3, #4]
	dst[0] = val;
   11b34:	237f      	movs	r3, #127	; 0x7f
   11b36:	7043      	strb	r3, [r0, #1]
	dst[1] = val >> 8;
   11b38:	2341      	movs	r3, #65	; 0x41
   11b3a:	7083      	strb	r3, [r0, #2]
	dst[2] = val >> 16;
   11b3c:	2301      	movs	r3, #1
   11b3e:	e7ec      	b.n	11b1a <hci_cmd_handle+0x42e>
	status = ll_addr_set(1, &cmd->bdaddr.val[0]);
   11b40:	68a1      	ldr	r1, [r4, #8]
   11b42:	2001      	movs	r0, #1
   11b44:	f7ff fad2 	bl	110ec <ll_addr_set>
	status = ll_wl_add(&cmd->addr);
   11b48:	4604      	mov	r4, r0
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   11b4a:	2101      	movs	r1, #1
   11b4c:	a807      	add	r0, sp, #28
   11b4e:	f7ff fc93 	bl	11478 <hci_cmd_complete>
	ccst->status = status;
   11b52:	7004      	strb	r4, [r0, #0]
	if (err == -EINVAL) {
   11b54:	e665      	b.n	11822 <hci_cmd_handle+0x136>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11b56:	2102      	movs	r1, #2
   11b58:	a807      	add	r0, sp, #28
   11b5a:	f7ff fc8d 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   11b5e:	2300      	movs	r3, #0
   11b60:	7003      	strb	r3, [r0, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11b62:	4604      	mov	r4, r0
	rp->wl_size = ll_wl_size_get();
   11b64:	f013 f8a5 	bl	24cb2 <ll_wl_size_get>
   11b68:	7060      	strb	r0, [r4, #1]
	if (err == -EINVAL) {
   11b6a:	e65a      	b.n	11822 <hci_cmd_handle+0x136>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   11b6c:	2101      	movs	r1, #1
   11b6e:	a807      	add	r0, sp, #28
   11b70:	f7ff fc82 	bl	11478 <hci_cmd_complete>
   11b74:	4604      	mov	r4, r0
	ccst->status = ll_wl_clear();
   11b76:	f005 fe65 	bl	17844 <ll_wl_clear>
	ccst->status = ll_rl_clear();
   11b7a:	7020      	strb	r0, [r4, #0]
	if (err == -EINVAL) {
   11b7c:	e651      	b.n	11822 <hci_cmd_handle+0x136>
	status = ll_wl_add(&cmd->addr);
   11b7e:	68a0      	ldr	r0, [r4, #8]
   11b80:	f006 f828 	bl	17bd4 <ll_wl_add>
   11b84:	e7e0      	b.n	11b48 <hci_cmd_handle+0x45c>
	status = ll_wl_remove(&cmd->addr);
   11b86:	68a0      	ldr	r0, [r4, #8]
   11b88:	f005 fe94 	bl	178b4 <ll_wl_remove>
   11b8c:	e7dc      	b.n	11b48 <hci_cmd_handle+0x45c>
		le_encrypt(cmd, evt);
   11b8e:	68a0      	ldr	r0, [r4, #8]
	ecb_encrypt(cmd->key, cmd->plaintext, enc_data, NULL);
   11b90:	2300      	movs	r3, #0
   11b92:	aa08      	add	r2, sp, #32
   11b94:	f100 0110 	add.w	r1, r0, #16
   11b98:	f013 f897 	bl	24cca <ecb_encrypt>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11b9c:	2111      	movs	r1, #17
   11b9e:	a807      	add	r0, sp, #28
   11ba0:	f7ff fc6a 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   11ba4:	4603      	mov	r3, r0
   11ba6:	2200      	movs	r2, #0
   11ba8:	f803 2b01 	strb.w	r2, [r3], #1
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   11bac:	ad0c      	add	r5, sp, #48	; 0x30
   11bae:	aa08      	add	r2, sp, #32
   11bb0:	4614      	mov	r4, r2
   11bb2:	cc03      	ldmia	r4!, {r0, r1}
   11bb4:	42ac      	cmp	r4, r5
   11bb6:	6018      	str	r0, [r3, #0]
   11bb8:	6059      	str	r1, [r3, #4]
   11bba:	4622      	mov	r2, r4
   11bbc:	f103 0308 	add.w	r3, r3, #8
   11bc0:	d1f6      	bne.n	11bb0 <hci_cmd_handle+0x4c4>
   11bc2:	e62e      	b.n	11822 <hci_cmd_handle+0x136>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11bc4:	2109      	movs	r1, #9
   11bc6:	a807      	add	r0, sp, #28
   11bc8:	f7ff fc56 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   11bcc:	2300      	movs	r3, #0
   11bce:	f800 3b01 	strb.w	r3, [r0], #1
	bt_rand(rp->rand, count);
   11bd2:	2108      	movs	r1, #8
   11bd4:	f000 fcd2 	bl	1257c <bt_rand>
	if (err == -EINVAL) {
   11bd8:	e623      	b.n	11822 <hci_cmd_handle+0x136>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11bda:	2109      	movs	r1, #9
   11bdc:	a807      	add	r0, sp, #28
   11bde:	f7ff fc4b 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   11be2:	4601      	mov	r1, r0
   11be4:	2300      	movs	r3, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11be6:	4602      	mov	r2, r0
	rp->status = 0x00;
   11be8:	f801 3b01 	strb.w	r3, [r1], #1
	sys_put_le32(val, dst);
   11bec:	4886      	ldr	r0, [pc, #536]	; (11e08 <hci_cmd_handle+0x71c>)
   11bee:	f012 fba4 	bl	2433a <sys_put_le32>
	sys_put_le32(val >> 32, &dst[4]);
   11bf2:	f44f 70e0 	mov.w	r0, #448	; 0x1c0
   11bf6:	1d51      	adds	r1, r2, #5
   11bf8:	f012 fb9f 	bl	2433a <sys_put_le32>
	if (err == -EINVAL) {
   11bfc:	e611      	b.n	11822 <hci_cmd_handle+0x136>
		le_set_adv_param(cmd, evt);
   11bfe:	68a4      	ldr	r4, [r4, #8]
	status = ll_adv_params_set(min_interval, cmd->type,
   11c00:	7ba5      	ldrb	r5, [r4, #14]
   11c02:	79a3      	ldrb	r3, [r4, #6]
   11c04:	7962      	ldrb	r2, [r4, #5]
   11c06:	7921      	ldrb	r1, [r4, #4]
   11c08:	8820      	ldrh	r0, [r4, #0]
   11c0a:	9502      	str	r5, [sp, #8]
   11c0c:	7b65      	ldrb	r5, [r4, #13]
   11c0e:	9501      	str	r5, [sp, #4]
				   &cmd->direct_addr.a.val[0], cmd->channel_map,
   11c10:	3407      	adds	r4, #7
	status = ll_adv_params_set(min_interval, cmd->type,
   11c12:	9400      	str	r4, [sp, #0]
   11c14:	f002 f8e4 	bl	13de0 <ll_adv_params_set>
   11c18:	e796      	b.n	11b48 <hci_cmd_handle+0x45c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11c1a:	2102      	movs	r1, #2
   11c1c:	a807      	add	r0, sp, #28
   11c1e:	f7ff fc2b 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   11c22:	2300      	movs	r3, #0
   11c24:	7003      	strb	r3, [r0, #0]
	rp->tx_power_level = 0;
   11c26:	7043      	strb	r3, [r0, #1]
	if (err == -EINVAL) {
   11c28:	e5fb      	b.n	11822 <hci_cmd_handle+0x136>
	status = ll_adv_data_set(cmd->len, &cmd->data[0]);
   11c2a:	68a1      	ldr	r1, [r4, #8]
   11c2c:	f811 0b01 	ldrb.w	r0, [r1], #1
   11c30:	f002 f962 	bl	13ef8 <ll_adv_data_set>
   11c34:	e788      	b.n	11b48 <hci_cmd_handle+0x45c>
	status = ll_adv_scan_rsp_set(cmd->len, &cmd->data[0]);
   11c36:	68a1      	ldr	r1, [r4, #8]
   11c38:	f811 0b01 	ldrb.w	r0, [r1], #1
   11c3c:	f002 f9b6 	bl	13fac <ll_adv_scan_rsp_set>
   11c40:	e782      	b.n	11b48 <hci_cmd_handle+0x45c>
	status = ll_adv_enable(cmd->enable);
   11c42:	68a3      	ldr	r3, [r4, #8]
   11c44:	7818      	ldrb	r0, [r3, #0]
   11c46:	f7f0 fbff 	bl	2448 <ll_adv_enable>
   11c4a:	e77d      	b.n	11b48 <hci_cmd_handle+0x45c>
	handle = sys_le16_to_cpu(cmd->handle);
   11c4c:	68a2      	ldr	r2, [r4, #8]
   11c4e:	f832 4b02 	ldrh.w	r4, [r2], #2
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
   11c52:	2100      	movs	r1, #0
   11c54:	4620      	mov	r0, r4
   11c56:	f012 ffd9 	bl	24c0c <ll_start_enc_req_send>
   11c5a:	e610      	b.n	1187e <hci_cmd_handle+0x192>
	handle = sys_le16_to_cpu(cmd->handle);
   11c5c:	68a3      	ldr	r3, [r4, #8]
	status = ll_start_enc_req_send(handle, BT_HCI_ERR_PIN_OR_KEY_MISSING,
   11c5e:	2200      	movs	r2, #0
	handle = sys_le16_to_cpu(cmd->handle);
   11c60:	881c      	ldrh	r4, [r3, #0]
	status = ll_start_enc_req_send(handle, BT_HCI_ERR_PIN_OR_KEY_MISSING,
   11c62:	2106      	movs	r1, #6
   11c64:	e7f6      	b.n	11c54 <hci_cmd_handle+0x568>
	handle = sys_le16_to_cpu(cmd->handle);
   11c66:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11c68:	2108      	movs	r1, #8
   11c6a:	a807      	add	r0, sp, #28
	handle = sys_le16_to_cpu(cmd->handle);
   11c6c:	881d      	ldrh	r5, [r3, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11c6e:	f7ff fc03 	bl	11478 <hci_cmd_complete>
	handle = sys_le16_to_cpu(cmd->handle);
   11c72:	b2ae      	uxth	r6, r5
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11c74:	4604      	mov	r4, r0
	status = ll_chm_get(handle, rp->ch_map);
   11c76:	1cc1      	adds	r1, r0, #3
   11c78:	4630      	mov	r0, r6
   11c7a:	f012 fe00 	bl	2487e <ll_chm_get>
   11c7e:	e5e1      	b.n	11844 <hci_cmd_handle+0x158>
	handle = sys_le16_to_cpu(cmd->handle);
   11c80:	68a3      	ldr	r3, [r4, #8]
	status = ll_feature_req_send(handle);
   11c82:	8818      	ldrh	r0, [r3, #0]
   11c84:	f012 fe21 	bl	248ca <ll_feature_req_send>
   11c88:	e58e      	b.n	117a8 <hci_cmd_handle+0xbc>
		le_conn_update(cmd, evt);
   11c8a:	68a2      	ldr	r2, [r4, #8]
	status = ll_conn_update(handle, 0, 0, conn_interval_min,
   11c8c:	8911      	ldrh	r1, [r2, #8]
   11c8e:	8853      	ldrh	r3, [r2, #2]
   11c90:	8810      	ldrh	r0, [r2, #0]
   11c92:	9102      	str	r1, [sp, #8]
   11c94:	88d1      	ldrh	r1, [r2, #6]
   11c96:	9101      	str	r1, [sp, #4]
   11c98:	8892      	ldrh	r2, [r2, #4]
   11c9a:	9200      	str	r2, [sp, #0]
   11c9c:	2200      	movs	r2, #0
   11c9e:	4611      	mov	r1, r2
   11ca0:	f012 fd75 	bl	2478e <ll_conn_update>
	*evt = cmd_status(status);
   11ca4:	e580      	b.n	117a8 <hci_cmd_handle+0xbc>
		le_conn_param_req_reply(cmd, evt);
   11ca6:	68a2      	ldr	r2, [r4, #8]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
   11ca8:	8911      	ldrh	r1, [r2, #8]
	handle = sys_le16_to_cpu(cmd->handle);
   11caa:	8814      	ldrh	r4, [r2, #0]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
   11cac:	8853      	ldrh	r3, [r2, #2]
   11cae:	9102      	str	r1, [sp, #8]
   11cb0:	88d1      	ldrh	r1, [r2, #6]
   11cb2:	9101      	str	r1, [sp, #4]
   11cb4:	8892      	ldrh	r2, [r2, #4]
   11cb6:	9200      	str	r2, [sp, #0]
   11cb8:	2200      	movs	r2, #0
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
   11cba:	2102      	movs	r1, #2
   11cbc:	4620      	mov	r0, r4
   11cbe:	f012 fd66 	bl	2478e <ll_conn_update>
   11cc2:	e5dc      	b.n	1187e <hci_cmd_handle+0x192>
		le_conn_param_req_neg_reply(cmd, evt);
   11cc4:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
   11cc6:	881c      	ldrh	r4, [r3, #0]
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
   11cc8:	789a      	ldrb	r2, [r3, #2]
   11cca:	2300      	movs	r3, #0
   11ccc:	e9cd 3301 	strd	r3, r3, [sp, #4]
   11cd0:	9300      	str	r3, [sp, #0]
   11cd2:	e7f2      	b.n	11cba <hci_cmd_handle+0x5ce>
		le_set_data_len(cmd, evt);
   11cd4:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
   11cd6:	881c      	ldrh	r4, [r3, #0]
	status = ll_length_req_send(handle, tx_octets, tx_time);
   11cd8:	889a      	ldrh	r2, [r3, #4]
   11cda:	8859      	ldrh	r1, [r3, #2]
   11cdc:	4620      	mov	r0, r4
   11cde:	f012 fe16 	bl	2490e <ll_length_req_send>
   11ce2:	e5cc      	b.n	1187e <hci_cmd_handle+0x192>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11ce4:	2105      	movs	r1, #5
   11ce6:	a807      	add	r0, sp, #28
   11ce8:	f7ff fbc6 	bl	11478 <hci_cmd_complete>
	ll_length_default_get(&max_tx_octets, &max_tx_time);
   11cec:	a908      	add	r1, sp, #32
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11cee:	4604      	mov	r4, r0
	ll_length_default_get(&max_tx_octets, &max_tx_time);
   11cf0:	f10d 001a 	add.w	r0, sp, #26
   11cf4:	f003 f914 	bl	14f20 <ll_length_default_get>
	rp->max_tx_octets = sys_cpu_to_le16(max_tx_octets);
   11cf8:	f8bd 301a 	ldrh.w	r3, [sp, #26]
   11cfc:	f8a4 3001 	strh.w	r3, [r4, #1]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
   11d00:	f8bd 3020 	ldrh.w	r3, [sp, #32]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
   11d04:	f8a4 3003 	strh.w	r3, [r4, #3]
	rp->status = 0x00;
   11d08:	2300      	movs	r3, #0
   11d0a:	7023      	strb	r3, [r4, #0]
	if (err == -EINVAL) {
   11d0c:	e589      	b.n	11822 <hci_cmd_handle+0x136>
		le_write_default_data_len(cmd, evt);
   11d0e:	68a3      	ldr	r3, [r4, #8]
	status = ll_length_default_set(max_tx_octets, max_tx_time);
   11d10:	8859      	ldrh	r1, [r3, #2]
   11d12:	8818      	ldrh	r0, [r3, #0]
   11d14:	f003 f910 	bl	14f38 <ll_length_default_set>
   11d18:	e716      	b.n	11b48 <hci_cmd_handle+0x45c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11d1a:	2109      	movs	r1, #9
   11d1c:	a807      	add	r0, sp, #28
   11d1e:	f7ff fbab 	bl	11478 <hci_cmd_complete>
	ll_length_max_get(&max_tx_octets, &max_tx_time,
   11d22:	ab08      	add	r3, sp, #32
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11d24:	4604      	mov	r4, r0
	ll_length_max_get(&max_tx_octets, &max_tx_time,
   11d26:	f10d 021a 	add.w	r2, sp, #26
   11d2a:	a906      	add	r1, sp, #24
   11d2c:	f10d 0016 	add.w	r0, sp, #22
   11d30:	f012 fe20 	bl	24974 <ll_length_max_get>
	rp->max_tx_octets = sys_cpu_to_le16(max_tx_octets);
   11d34:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   11d38:	f8a4 3001 	strh.w	r3, [r4, #1]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
   11d3c:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   11d40:	e7e0      	b.n	11d04 <hci_cmd_handle+0x618>
	handle = sys_le16_to_cpu(cmd->handle);
   11d42:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11d44:	2105      	movs	r1, #5
   11d46:	a807      	add	r0, sp, #28
	handle = sys_le16_to_cpu(cmd->handle);
   11d48:	881d      	ldrh	r5, [r3, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11d4a:	f7ff fb95 	bl	11478 <hci_cmd_complete>
	handle = sys_le16_to_cpu(cmd->handle);
   11d4e:	b2ae      	uxth	r6, r5
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11d50:	4604      	mov	r4, r0
	status = ll_phy_get(handle, &rp->tx_phy, &rp->rx_phy);
   11d52:	1d02      	adds	r2, r0, #4
   11d54:	1cc1      	adds	r1, r0, #3
   11d56:	4630      	mov	r0, r6
   11d58:	f012 fe15 	bl	24986 <ll_phy_get>
 * @return least significant bit set, 0 if @a op is 0
 */

static ALWAYS_INLINE unsigned int find_lsb_set(u32_t op)
{
	return __builtin_ffs(op);
   11d5c:	78e2      	ldrb	r2, [r4, #3]
	rp->status = status;
   11d5e:	7020      	strb	r0, [r4, #0]
   11d60:	2a00      	cmp	r2, #0
   11d62:	fa92 f3a2 	rbit	r3, r2
   11d66:	fab3 f383 	clz	r3, r3
   11d6a:	7922      	ldrb	r2, [r4, #4]
	rp->handle = sys_cpu_to_le16(handle);
   11d6c:	f8a4 5001 	strh.w	r5, [r4, #1]
   11d70:	bf08      	it	eq
   11d72:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   11d76:	3301      	adds	r3, #1
	rp->tx_phy = find_lsb_set(rp->tx_phy);
   11d78:	70e3      	strb	r3, [r4, #3]
   11d7a:	2a00      	cmp	r2, #0
   11d7c:	fa92 f3a2 	rbit	r3, r2
   11d80:	fab3 f383 	clz	r3, r3
   11d84:	bf08      	it	eq
   11d86:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   11d8a:	3301      	adds	r3, #1
	rp->rx_phy = find_lsb_set(rp->rx_phy);
   11d8c:	7123      	strb	r3, [r4, #4]
	if (err == -EINVAL) {
   11d8e:	e548      	b.n	11822 <hci_cmd_handle+0x136>
		le_set_default_phy(cmd, evt);
   11d90:	68a3      	ldr	r3, [r4, #8]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
   11d92:	781a      	ldrb	r2, [r3, #0]
   11d94:	07d1      	lsls	r1, r2, #31
		cmd->tx_phys = 0x07;
   11d96:	bf44      	itt	mi
   11d98:	2107      	movmi	r1, #7
   11d9a:	7059      	strbmi	r1, [r3, #1]
	if (cmd->all_phys & BT_HCI_LE_PHY_RX_ANY) {
   11d9c:	0792      	lsls	r2, r2, #30
		cmd->rx_phys = 0x07;
   11d9e:	bf44      	itt	mi
   11da0:	2207      	movmi	r2, #7
   11da2:	709a      	strbmi	r2, [r3, #2]
	status = ll_phy_default_set(cmd->tx_phys, cmd->rx_phys);
   11da4:	7899      	ldrb	r1, [r3, #2]
   11da6:	7858      	ldrb	r0, [r3, #1]
   11da8:	f003 f8d0 	bl	14f4c <ll_phy_default_set>
   11dac:	e6cc      	b.n	11b48 <hci_cmd_handle+0x45c>
		le_set_phy(cmd, evt);
   11dae:	68a3      	ldr	r3, [r4, #8]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
   11db0:	7899      	ldrb	r1, [r3, #2]
	handle = sys_le16_to_cpu(cmd->handle);
   11db2:	8818      	ldrh	r0, [r3, #0]
	phy_opts = sys_le16_to_cpu(cmd->phy_opts);
   11db4:	f8b3 4005 	ldrh.w	r4, [r3, #5]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
   11db8:	07cf      	lsls	r7, r1, #31
		cmd->tx_phys |= mask_phys;
   11dba:	bf42      	ittt	mi
   11dbc:	78da      	ldrbmi	r2, [r3, #3]
   11dbe:	f042 0203 	orrmi.w	r2, r2, #3
   11dc2:	70da      	strbmi	r2, [r3, #3]
	if (cmd->all_phys & BT_HCI_LE_PHY_RX_ANY) {
   11dc4:	078e      	lsls	r6, r1, #30
		cmd->rx_phys |= mask_phys;
   11dc6:	bf48      	it	mi
   11dc8:	791a      	ldrbmi	r2, [r3, #4]
	if ((cmd->tx_phys | cmd->rx_phys) & ~mask_phys) {
   11dca:	78d9      	ldrb	r1, [r3, #3]
		cmd->rx_phys |= mask_phys;
   11dcc:	bf44      	itt	mi
   11dce:	f042 0203 	orrmi.w	r2, r2, #3
   11dd2:	711a      	strbmi	r2, [r3, #4]
	if ((cmd->tx_phys | cmd->rx_phys) & ~mask_phys) {
   11dd4:	791b      	ldrb	r3, [r3, #4]
   11dd6:	ea41 0203 	orr.w	r2, r1, r3
   11dda:	f012 0ffc 	tst.w	r2, #252	; 0xfc
   11dde:	d001      	beq.n	11de4 <hci_cmd_handle+0x6f8>
		*evt = cmd_status(BT_HCI_ERR_UNSUPP_FEATURE_PARAM_VAL);
   11de0:	2011      	movs	r0, #17
   11de2:	e4e1      	b.n	117a8 <hci_cmd_handle+0xbc>
	if (!(cmd->tx_phys & 0x07) ||
   11de4:	074d      	lsls	r5, r1, #29
   11de6:	d001      	beq.n	11dec <hci_cmd_handle+0x700>
   11de8:	075a      	lsls	r2, r3, #29
   11dea:	d101      	bne.n	11df0 <hci_cmd_handle+0x704>
		*evt = cmd_status(BT_HCI_ERR_INVALID_PARAM);
   11dec:	2012      	movs	r0, #18
   11dee:	e4db      	b.n	117a8 <hci_cmd_handle+0xbc>
	if (phy_opts & 0x03) {
   11df0:	f014 0203 	ands.w	r2, r4, #3
		phy_opts -= 1U;
   11df4:	bf1c      	itt	ne
   11df6:	f104 34ff 	addne.w	r4, r4, #4294967295	; 0xffffffff
		phy_opts &= 1;
   11dfa:	f004 0201 	andne.w	r2, r4, #1
	status = ll_phy_req_send(handle, cmd->tx_phys, phy_opts,
   11dfe:	f012 fdd6 	bl	249ae <ll_phy_req_send>
	*evt = cmd_status(status);
   11e02:	e4d1      	b.n	117a8 <hci_cmd_handle+0xbc>
   11e04:	2000e630 	.word	0x2000e630
   11e08:	ec30cc8f 	.word	0xec30cc8f
		le_add_dev_to_rl(cmd, evt);
   11e0c:	68a0      	ldr	r0, [r4, #8]
	status = ll_rl_add(&cmd->peer_id_addr, cmd->peer_irk, cmd->local_irk);
   11e0e:	f100 0217 	add.w	r2, r0, #23
   11e12:	1dc1      	adds	r1, r0, #7
   11e14:	f005 ff32 	bl	17c7c <ll_rl_add>
   11e18:	e696      	b.n	11b48 <hci_cmd_handle+0x45c>
	status = ll_rl_remove(&cmd->peer_id_addr);
   11e1a:	68a0      	ldr	r0, [r4, #8]
   11e1c:	f005 ffd4 	bl	17dc8 <ll_rl_remove>
   11e20:	e692      	b.n	11b48 <hci_cmd_handle+0x45c>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   11e22:	2101      	movs	r1, #1
   11e24:	a807      	add	r0, sp, #28
   11e26:	f7ff fb27 	bl	11478 <hci_cmd_complete>
   11e2a:	4604      	mov	r4, r0
	ccst->status = ll_rl_clear();
   11e2c:	f005 fdb6 	bl	1799c <ll_rl_clear>
   11e30:	e6a3      	b.n	11b7a <hci_cmd_handle+0x48e>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11e32:	2102      	movs	r1, #2
   11e34:	a807      	add	r0, sp, #28
   11e36:	f7ff fb1f 	bl	11478 <hci_cmd_complete>
   11e3a:	4604      	mov	r4, r0
	rp->rl_size = ll_rl_size_get();
   11e3c:	f012 ff3b 	bl	24cb6 <ll_rl_size_get>
   11e40:	7060      	strb	r0, [r4, #1]
   11e42:	e761      	b.n	11d08 <hci_cmd_handle+0x61c>
	bt_addr_le_copy(&peer_id_addr, &cmd->peer_id_addr);
   11e44:	68a1      	ldr	r1, [r4, #8]
   11e46:	a808      	add	r0, sp, #32
   11e48:	f012 fa80 	bl	2434c <bt_addr_le_copy>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11e4c:	2107      	movs	r1, #7
   11e4e:	a807      	add	r0, sp, #28
   11e50:	f7ff fb12 	bl	11478 <hci_cmd_complete>
   11e54:	4604      	mov	r4, r0
	rp->status = ll_rl_crpa_get(&peer_id_addr, &rp->peer_rpa);
   11e56:	1c41      	adds	r1, r0, #1
   11e58:	a808      	add	r0, sp, #32
   11e5a:	f006 f849 	bl	17ef0 <ll_rl_crpa_get>
   11e5e:	e68c      	b.n	11b7a <hci_cmd_handle+0x48e>
	bt_addr_le_copy(&peer_id_addr, &cmd->peer_id_addr);
   11e60:	68a1      	ldr	r1, [r4, #8]
   11e62:	a808      	add	r0, sp, #32
   11e64:	f012 fa72 	bl	2434c <bt_addr_le_copy>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11e68:	2107      	movs	r1, #7
   11e6a:	a807      	add	r0, sp, #28
   11e6c:	f7ff fb04 	bl	11478 <hci_cmd_complete>
   11e70:	4604      	mov	r4, r0
	rp->status = ll_rl_lrpa_get(&peer_id_addr, &rp->local_rpa);
   11e72:	1c41      	adds	r1, r0, #1
   11e74:	a808      	add	r0, sp, #32
   11e76:	f006 f85b 	bl	17f30 <ll_rl_lrpa_get>
   11e7a:	e67e      	b.n	11b7a <hci_cmd_handle+0x48e>
	u8_t enable = cmd->enable;
   11e7c:	68a3      	ldr	r3, [r4, #8]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   11e7e:	2101      	movs	r1, #1
   11e80:	a807      	add	r0, sp, #28
	u8_t enable = cmd->enable;
   11e82:	781d      	ldrb	r5, [r3, #0]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   11e84:	f7ff faf8 	bl	11478 <hci_cmd_complete>
   11e88:	4604      	mov	r4, r0
	ccst->status = ll_rl_enable(enable);
   11e8a:	4628      	mov	r0, r5
   11e8c:	f005 fdc4 	bl	17a18 <ll_rl_enable>
   11e90:	e673      	b.n	11b7a <hci_cmd_handle+0x48e>
	u16_t timeout = sys_le16_to_cpu(cmd->rpa_timeout);
   11e92:	68a3      	ldr	r3, [r4, #8]
	ll_rl_timeout_set(timeout);
   11e94:	8818      	ldrh	r0, [r3, #0]
   11e96:	f005 fdd7 	bl	17a48 <ll_rl_timeout_set>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   11e9a:	e4a3      	b.n	117e4 <hci_cmd_handle+0xf8>
		le_set_privacy_mode(cmd, evt);
   11e9c:	68a0      	ldr	r0, [r4, #8]
	status = ll_priv_mode_set(&cmd->id_addr, cmd->mode);
   11e9e:	79c1      	ldrb	r1, [r0, #7]
   11ea0:	f006 f85e 	bl	17f60 <ll_priv_mode_set>
   11ea4:	e650      	b.n	11b48 <hci_cmd_handle+0x45c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   11ea6:	2103      	movs	r1, #3
   11ea8:	a807      	add	r0, sp, #28
   11eaa:	f7ff fae5 	bl	11478 <hci_cmd_complete>
	rp->status = 0x00;
   11eae:	4601      	mov	r1, r0
   11eb0:	2300      	movs	r3, #0
   11eb2:	f801 3b02 	strb.w	r3, [r1], #2
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
   11eb6:	3001      	adds	r0, #1
   11eb8:	f012 fa3b 	bl	24332 <ll_tx_pwr_get>
	if (err == -EINVAL) {
   11ebc:	e4b1      	b.n	11822 <hci_cmd_handle+0x136>
   11ebe:	bf00      	nop

00011ec0 <hci_acl_handle>:
{
   11ec0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	*evt = NULL;
   11ec4:	2300      	movs	r3, #0
   11ec6:	600b      	str	r3, [r1, #0]
	if (buf->len < sizeof(*acl)) {
   11ec8:	8983      	ldrh	r3, [r0, #12]
   11eca:	2b03      	cmp	r3, #3
{
   11ecc:	4605      	mov	r5, r0
   11ece:	4688      	mov	r8, r1
	if (buf->len < sizeof(*acl)) {
   11ed0:	d810      	bhi.n	11ef4 <hci_acl_handle+0x34>
		BT_ERR("No HCI ACL header");
   11ed2:	2301      	movs	r3, #1
   11ed4:	f04f 0100 	mov.w	r1, #0
   11ed8:	f363 0107 	bfi	r1, r3, #0, #8
   11edc:	4a40      	ldr	r2, [pc, #256]	; (11fe0 <hci_acl_handle+0x120>)
   11ede:	4b41      	ldr	r3, [pc, #260]	; (11fe4 <hci_acl_handle+0x124>)
   11ee0:	4841      	ldr	r0, [pc, #260]	; (11fe8 <hci_acl_handle+0x128>)
   11ee2:	1a9b      	subs	r3, r3, r2
   11ee4:	08db      	lsrs	r3, r3, #3
   11ee6:	f363 118f 	bfi	r1, r3, #6, #10
		BT_ERR("Invalid HCI ACL packet length");
   11eea:	f00f f8a6 	bl	2103a <log_0>
		return -EINVAL;
   11eee:	f06f 0015 	mvn.w	r0, #21
   11ef2:	e046      	b.n	11f82 <hci_acl_handle+0xc2>
	acl = net_buf_pull_mem(buf, sizeof(*acl));
   11ef4:	2104      	movs	r1, #4
   11ef6:	3008      	adds	r0, #8
   11ef8:	f012 ffa0 	bl	24e3c <net_buf_simple_pull_mem>
	if (buf->len < len) {
   11efc:	89ab      	ldrh	r3, [r5, #12]
	len = sys_le16_to_cpu(acl->len);
   11efe:	8847      	ldrh	r7, [r0, #2]
	handle = sys_le16_to_cpu(acl->handle);
   11f00:	f8b0 9000 	ldrh.w	r9, [r0]
	if (buf->len < len) {
   11f04:	42bb      	cmp	r3, r7
   11f06:	d20c      	bcs.n	11f22 <hci_acl_handle+0x62>
		BT_ERR("Invalid HCI ACL packet length");
   11f08:	2301      	movs	r3, #1
   11f0a:	f04f 0100 	mov.w	r1, #0
   11f0e:	f363 0107 	bfi	r1, r3, #0, #8
   11f12:	4a33      	ldr	r2, [pc, #204]	; (11fe0 <hci_acl_handle+0x120>)
   11f14:	4b33      	ldr	r3, [pc, #204]	; (11fe4 <hci_acl_handle+0x124>)
   11f16:	4835      	ldr	r0, [pc, #212]	; (11fec <hci_acl_handle+0x12c>)
   11f18:	1a9b      	subs	r3, r3, r2
   11f1a:	08db      	lsrs	r3, r3, #3
   11f1c:	f363 118f 	bfi	r1, r3, #6, #10
   11f20:	e7e3      	b.n	11eea <hci_acl_handle+0x2a>
	node_tx = ll_tx_mem_acquire();
   11f22:	f002 ff8d 	bl	14e40 <ll_tx_mem_acquire>
	flags = bt_acl_flags(handle);
   11f26:	ea4f 3619 	mov.w	r6, r9, lsr #12
	if (!node_tx) {
   11f2a:	4604      	mov	r4, r0
   11f2c:	bb58      	cbnz	r0, 11f86 <hci_acl_handle+0xc6>
		BT_ERR("Tx Buffer Overflow");
   11f2e:	2301      	movs	r3, #1
   11f30:	f04f 0100 	mov.w	r1, #0
   11f34:	4a2a      	ldr	r2, [pc, #168]	; (11fe0 <hci_acl_handle+0x120>)
   11f36:	482e      	ldr	r0, [pc, #184]	; (11ff0 <hci_acl_handle+0x130>)
   11f38:	f363 0107 	bfi	r1, r3, #0, #8
   11f3c:	4b29      	ldr	r3, [pc, #164]	; (11fe4 <hci_acl_handle+0x124>)
   11f3e:	1a9b      	subs	r3, r3, r2
   11f40:	08db      	lsrs	r3, r3, #3
   11f42:	f363 118f 	bfi	r1, r3, #6, #10
   11f46:	f00f f878 	bl	2103a <log_0>
	if (!(event_mask & BT_EVT_MASK_DATA_BUFFER_OVERFLOW)) {
   11f4a:	4b2a      	ldr	r3, [pc, #168]	; (11ff4 <hci_acl_handle+0x134>)
   11f4c:	6819      	ldr	r1, [r3, #0]
   11f4e:	4623      	mov	r3, r4
   11f50:	f001 7200 	and.w	r2, r1, #33554432	; 0x2000000
   11f54:	4313      	orrs	r3, r2
   11f56:	d012      	beq.n	11f7e <hci_acl_handle+0xbe>
	*buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   11f58:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   11f5c:	2001      	movs	r0, #1
   11f5e:	f7f8 fa67 	bl	a430 <bt_buf_get_rx>
	hci_evt_create(*buf, BT_HCI_EVT_DATA_BUF_OVERFLOW, sizeof(*ep));
   11f62:	2201      	movs	r2, #1
	*buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   11f64:	f8c8 0000 	str.w	r0, [r8]
	hci_evt_create(*buf, BT_HCI_EVT_DATA_BUF_OVERFLOW, sizeof(*ep));
   11f68:	211a      	movs	r1, #26
   11f6a:	f012 f9fb 	bl	24364 <hci_evt_create>
	ep = net_buf_add(*buf, sizeof(*ep));
   11f6e:	f8d8 0000 	ldr.w	r0, [r8]
   11f72:	2101      	movs	r1, #1
   11f74:	3008      	adds	r0, #8
   11f76:	f012 ff2f 	bl	24dd8 <net_buf_simple_add>
	ep->link_type = BT_OVERFLOW_LINK_ACL;
   11f7a:	2301      	movs	r3, #1
   11f7c:	7003      	strb	r3, [r0, #0]
		return -ENOBUFS;
   11f7e:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
   11f82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (bt_acl_flags_bc(flags) != BT_ACL_POINT_TO_POINT) {
   11f86:	08b3      	lsrs	r3, r6, #2
   11f88:	d1b1      	bne.n	11eee <hci_acl_handle+0x2e>
	switch (bt_acl_flags_pb(flags)) {
   11f8a:	b12e      	cbz	r6, 11f98 <hci_acl_handle+0xd8>
   11f8c:	2e01      	cmp	r6, #1
   11f8e:	d1ae      	bne.n	11eee <hci_acl_handle+0x2e>
		pdu_data->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   11f90:	7903      	ldrb	r3, [r0, #4]
   11f92:	f366 0301 	bfi	r3, r6, #0, #2
   11f96:	e003      	b.n	11fa0 <hci_acl_handle+0xe0>
		pdu_data->ll_id = PDU_DATA_LLID_DATA_START;
   11f98:	7903      	ldrb	r3, [r0, #4]
   11f9a:	2202      	movs	r2, #2
   11f9c:	f362 0301 	bfi	r3, r2, #0, #2
	pdu_data->len = len;
   11fa0:	7167      	strb	r7, [r4, #5]
   11fa2:	68a9      	ldr	r1, [r5, #8]
		pdu_data->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   11fa4:	7123      	strb	r3, [r4, #4]
   11fa6:	463a      	mov	r2, r7
   11fa8:	1de0      	adds	r0, r4, #7
   11faa:	f7ef fe1f 	bl	1bec <memcpy>
	if (ll_tx_mem_enqueue(handle, node_tx)) {
   11fae:	4621      	mov	r1, r4
   11fb0:	f3c9 000b 	ubfx	r0, r9, #0, #12
   11fb4:	f002 ff50 	bl	14e58 <ll_tx_mem_enqueue>
   11fb8:	2800      	cmp	r0, #0
   11fba:	d0e2      	beq.n	11f82 <hci_acl_handle+0xc2>
		BT_ERR("Invalid Tx Enqueue");
   11fbc:	2301      	movs	r3, #1
   11fbe:	f04f 0100 	mov.w	r1, #0
   11fc2:	4a07      	ldr	r2, [pc, #28]	; (11fe0 <hci_acl_handle+0x120>)
   11fc4:	480c      	ldr	r0, [pc, #48]	; (11ff8 <hci_acl_handle+0x138>)
   11fc6:	f363 0107 	bfi	r1, r3, #0, #8
   11fca:	4b06      	ldr	r3, [pc, #24]	; (11fe4 <hci_acl_handle+0x124>)
   11fcc:	1a9b      	subs	r3, r3, r2
   11fce:	08db      	lsrs	r3, r3, #3
   11fd0:	f363 118f 	bfi	r1, r3, #6, #10
   11fd4:	f00f f831 	bl	2103a <log_0>
		ll_tx_mem_release(node_tx);
   11fd8:	4620      	mov	r0, r4
   11fda:	f002 ff37 	bl	14e4c <ll_tx_mem_release>
		return -EINVAL;
   11fde:	e786      	b.n	11eee <hci_acl_handle+0x2e>
   11fe0:	00028540 	.word	0x00028540
   11fe4:	00028588 	.word	0x00028588
   11fe8:	00064236 	.word	0x00064236
   11fec:	00064248 	.word	0x00064248
   11ff0:	00064266 	.word	0x00064266
   11ff4:	2000e628 	.word	0x2000e628
   11ff8:	00064279 	.word	0x00064279

00011ffc <hci_acl_encode>:
	u16_t handle;
	u8_t *data;

	handle = node_rx->hdr.handle;

	switch (pdu_data->ll_id) {
   11ffc:	f890 3020 	ldrb.w	r3, [r0, #32]
   12000:	f003 0303 	and.w	r3, r3, #3
   12004:	3b01      	subs	r3, #1
   12006:	2b01      	cmp	r3, #1
{
   12008:	b570      	push	{r4, r5, r6, lr}
   1200a:	4604      	mov	r4, r0
	switch (pdu_data->ll_id) {
   1200c:	d81f      	bhi.n	1204e <hci_acl_encode+0x52>
	case PDU_DATA_LLID_DATA_CONTINUE:
	case PDU_DATA_LLID_DATA_START:
		acl = (void *)net_buf_add(buf, sizeof(*acl));
   1200e:	f101 0608 	add.w	r6, r1, #8
	handle = node_rx->hdr.handle;
   12012:	88c5      	ldrh	r5, [r0, #6]
		acl = (void *)net_buf_add(buf, sizeof(*acl));
   12014:	2104      	movs	r1, #4
   12016:	4630      	mov	r0, r6
   12018:	f012 fede 	bl	24dd8 <net_buf_simple_add>
		if (pdu_data->ll_id == PDU_DATA_LLID_DATA_START) {
   1201c:	f894 3020 	ldrb.w	r3, [r4, #32]
   12020:	f003 0303 	and.w	r3, r3, #3
   12024:	2b02      	cmp	r3, #2
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_START);
   12026:	bf0c      	ite	eq
   12028:	f445 5500 	orreq.w	r5, r5, #8192	; 0x2000
		} else {
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_CONT);
   1202c:	f445 5580 	orrne.w	r5, r5, #4096	; 0x1000
		}
		acl->handle = sys_cpu_to_le16(handle_flags);
   12030:	8005      	strh	r5, [r0, #0]
		acl->len = sys_cpu_to_le16(pdu_data->len);
   12032:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
   12036:	8041      	strh	r1, [r0, #2]
		data = (void *)net_buf_add(buf, pdu_data->len);
   12038:	4630      	mov	r0, r6
   1203a:	f012 fecd 	bl	24dd8 <net_buf_simple_add>
   1203e:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
   12042:	f104 0123 	add.w	r1, r4, #35	; 0x23

	default:
		LL_ASSERT(0);
		break;
	}
}
   12046:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1204a:	f7ef bdcf 	b.w	1bec <memcpy>
		LL_ASSERT(0);
   1204e:	f640 539e 	movw	r3, #3486	; 0xd9e
   12052:	4a06      	ldr	r2, [pc, #24]	; (1206c <hci_acl_encode+0x70>)
   12054:	4906      	ldr	r1, [pc, #24]	; (12070 <hci_acl_encode+0x74>)
   12056:	4807      	ldr	r0, [pc, #28]	; (12074 <hci_acl_encode+0x78>)
   12058:	f00d feab 	bl	1fdb2 <printk>
   1205c:	4040      	eors	r0, r0
   1205e:	f380 8811 	msr	BASEPRI, r0
   12062:	f04f 0003 	mov.w	r0, #3
   12066:	df02      	svc	2
}
   12068:	bd70      	pop	{r4, r5, r6, pc}
   1206a:	bf00      	nop
   1206c:	00064204 	.word	0x00064204
   12070:	00065948 	.word	0x00065948
   12074:	000632fe 	.word	0x000632fe

00012078 <hci_evt_encode>:
#endif /* CONFIG_BT_CONN */

void hci_evt_encode(struct node_rx_pdu *node_rx, struct net_buf *buf)
{
   12078:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct pdu_data *pdu_data = PDU_DATA(node_rx);

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   1207a:	7903      	ldrb	r3, [r0, #4]
   1207c:	88c6      	ldrh	r6, [r0, #6]
   1207e:	2b02      	cmp	r3, #2
{
   12080:	b089      	sub	sp, #36	; 0x24
   12082:	4604      	mov	r4, r0
   12084:	460d      	mov	r5, r1
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   12086:	f000 81ad 	beq.w	123e4 <hci_evt_encode+0x36c>
	switch (node_rx->hdr.type) {
   1208a:	3b08      	subs	r3, #8
   1208c:	2b06      	cmp	r3, #6
   1208e:	f200 8187 	bhi.w	123a0 <hci_evt_encode+0x328>
   12092:	e8df f013 	tbh	[pc, r3, lsl #1]
   12096:	0007      	.short	0x0007
   12098:	00be00a1 	.word	0x00be00a1
   1209c:	00f700e1 	.word	0x00f700e1
   120a0:	0126010b 	.word	0x0126010b
	u8_t status = node_rx->status;
   120a4:	f890 7020 	ldrb.w	r7, [r0, #32]
	if (!status) {
   120a8:	b947      	cbnz	r7, 120bc <hci_evt_encode+0x44>
		ll_rl_crpa_set(node_rx->peer_addr_type,
   120aa:	f100 0329 	add.w	r3, r0, #41	; 0x29
   120ae:	f100 0123 	add.w	r1, r0, #35	; 0x23
   120b2:	22ff      	movs	r2, #255	; 0xff
   120b4:	f890 0022 	ldrb.w	r0, [r0, #34]	; 0x22
   120b8:	f005 fefa 	bl	17eb0 <ll_rl_crpa_set>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   120bc:	4bbf      	ldr	r3, [pc, #764]	; (123bc <hci_evt_encode+0x344>)
   120be:	6859      	ldr	r1, [r3, #4]
   120c0:	f04f 0c00 	mov.w	ip, #0
   120c4:	4662      	mov	r2, ip
   120c6:	f001 5300 	and.w	r3, r1, #536870912	; 0x20000000
   120ca:	4313      	orrs	r3, r2
   120cc:	d057      	beq.n	1217e <hci_evt_encode+0x106>
	    (!(le_event_mask & BT_EVT_MASK_LE_CONN_COMPLETE) &&
   120ce:	4bbc      	ldr	r3, [pc, #752]	; (123c0 <hci_evt_encode+0x348>)
   120d0:	f8d3 e000 	ldr.w	lr, [r3]
   120d4:	f240 2001 	movw	r0, #513	; 0x201
   120d8:	ea0e 0000 	and.w	r0, lr, r0
   120dc:	4661      	mov	r1, ip
   120de:	4301      	orrs	r1, r0
	     !(le_event_mask & BT_EVT_MASK_LE_ENH_CONN_COMPLETE))) {
   120e0:	f40e 7200 	and.w	r2, lr, #512	; 0x200
   120e4:	4663      	mov	r3, ip
	    (!(le_event_mask & BT_EVT_MASK_LE_CONN_COMPLETE) &&
   120e6:	d04a      	beq.n	1217e <hci_evt_encode+0x106>
	if (!status) {
   120e8:	b91f      	cbnz	r7, 120f2 <hci_evt_encode+0x7a>
		conn_count++;
   120ea:	48b6      	ldr	r0, [pc, #728]	; (123c4 <hci_evt_encode+0x34c>)
   120ec:	6801      	ldr	r1, [r0, #0]
   120ee:	3101      	adds	r1, #1
   120f0:	6001      	str	r1, [r0, #0]
	if (le_event_mask & BT_EVT_MASK_LE_ENH_CONN_COMPLETE) {
   120f2:	4313      	orrs	r3, r2
   120f4:	d049      	beq.n	1218a <hci_evt_encode+0x112>
		leecc = meta_evt(buf, BT_HCI_EVT_LE_ENH_CONN_COMPLETE,
   120f6:	4628      	mov	r0, r5
   120f8:	221e      	movs	r2, #30
   120fa:	210a      	movs	r1, #10
   120fc:	f012 f93c 	bl	24378 <meta_evt>
   12100:	4605      	mov	r5, r0
		if (status) {
   12102:	b12f      	cbz	r7, 12110 <hci_evt_encode+0x98>
__ssp_bos_icheck3(memset, void *, int)
   12104:	221e      	movs	r2, #30
   12106:	2100      	movs	r1, #0
   12108:	f7ef fd91 	bl	1c2e <memset>
		lecc->status = status;
   1210c:	702f      	strb	r7, [r5, #0]
		return;
   1210e:	e036      	b.n	1217e <hci_evt_encode+0x106>
		leecc->status = 0x00;
   12110:	7007      	strb	r7, [r0, #0]
		leecc->handle = sys_cpu_to_le16(handle);
   12112:	f8a0 6001 	strh.w	r6, [r0, #1]
		leecc->role = node_rx->role;
   12116:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
   1211a:	70c3      	strb	r3, [r0, #3]
		leecc->peer_addr.type = node_rx->peer_addr_type;
   1211c:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
   12120:	7103      	strb	r3, [r0, #4]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   12122:	4623      	mov	r3, r4
   12124:	f853 2f23 	ldr.w	r2, [r3, #35]!
   12128:	f8c0 2005 	str.w	r2, [r0, #5]
   1212c:	889b      	ldrh	r3, [r3, #4]
   1212e:	f8a0 3009 	strh.w	r3, [r0, #9]
		if ((node_rx->own_addr_type) &&
   12132:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
   12136:	f100 020b 	add.w	r2, r0, #11
   1213a:	b313      	cbz	r3, 12182 <hci_evt_encode+0x10a>
   1213c:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
   12140:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   12144:	2b40      	cmp	r3, #64	; 0x40
   12146:	d11c      	bne.n	12182 <hci_evt_encode+0x10a>
   12148:	4623      	mov	r3, r4
   1214a:	f853 1f30 	ldr.w	r1, [r3, #48]!
   1214e:	f8c0 100b 	str.w	r1, [r0, #11]
   12152:	889b      	ldrh	r3, [r3, #4]
__ssp_bos_icheck3(memset, void *, int)
   12154:	8093      	strh	r3, [r2, #4]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   12156:	4623      	mov	r3, r4
   12158:	f853 2f29 	ldr.w	r2, [r3, #41]!
   1215c:	f8c5 2011 	str.w	r2, [r5, #17]
   12160:	889b      	ldrh	r3, [r3, #4]
   12162:	f8a5 3015 	strh.w	r3, [r5, #21]
		leecc->interval = sys_cpu_to_le16(node_rx->interval);
   12166:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   12168:	f8a5 3017 	strh.w	r3, [r5, #23]
		leecc->latency = sys_cpu_to_le16(node_rx->latency);
   1216c:	8f23      	ldrh	r3, [r4, #56]	; 0x38
   1216e:	f8a5 3019 	strh.w	r3, [r5, #25]
		leecc->supv_timeout = sys_cpu_to_le16(node_rx->timeout);
   12172:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   12174:	f8a5 301b 	strh.w	r3, [r5, #27]
		leecc->clock_accuracy = node_rx->sca;
   12178:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   1217c:	776b      	strb	r3, [r5, #29]
		encode_control(node_rx, pdu_data, buf);
	} else if (IS_ENABLED(CONFIG_BT_CONN)) {
		encode_data_ctrl(node_rx, pdu_data, buf);
	}
}
   1217e:	b009      	add	sp, #36	; 0x24
   12180:	bdf0      	pop	{r4, r5, r6, r7, pc}
__ssp_bos_icheck3(memset, void *, int)
   12182:	2300      	movs	r3, #0
   12184:	f8c5 300b 	str.w	r3, [r5, #11]
   12188:	e7e4      	b.n	12154 <hci_evt_encode+0xdc>
	lecc = meta_evt(buf, BT_HCI_EVT_LE_CONN_COMPLETE, sizeof(*lecc));
   1218a:	4628      	mov	r0, r5
   1218c:	2212      	movs	r2, #18
   1218e:	2101      	movs	r1, #1
   12190:	f012 f8f2 	bl	24378 <meta_evt>
   12194:	4605      	mov	r5, r0
	if (status) {
   12196:	b10f      	cbz	r7, 1219c <hci_evt_encode+0x124>
   12198:	2212      	movs	r2, #18
   1219a:	e7b4      	b.n	12106 <hci_evt_encode+0x8e>
	lecc->status = 0x00;
   1219c:	7007      	strb	r7, [r0, #0]
	lecc->handle = sys_cpu_to_le16(handle);
   1219e:	f8a0 6001 	strh.w	r6, [r0, #1]
	lecc->role = node_rx->role;
   121a2:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
   121a6:	70c3      	strb	r3, [r0, #3]
	lecc->peer_addr.type = node_rx->peer_addr_type;
   121a8:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
   121ac:	7103      	strb	r3, [r0, #4]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   121ae:	4623      	mov	r3, r4
   121b0:	f853 2f23 	ldr.w	r2, [r3, #35]!
   121b4:	f8c0 2005 	str.w	r2, [r0, #5]
   121b8:	889b      	ldrh	r3, [r3, #4]
   121ba:	f8a0 3009 	strh.w	r3, [r0, #9]
	lecc->interval = sys_cpu_to_le16(node_rx->interval);
   121be:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   121c0:	f8a0 300b 	strh.w	r3, [r0, #11]
	lecc->latency = sys_cpu_to_le16(node_rx->latency);
   121c4:	8f23      	ldrh	r3, [r4, #56]	; 0x38
   121c6:	f8a0 300d 	strh.w	r3, [r0, #13]
	lecc->supv_timeout = sys_cpu_to_le16(node_rx->timeout);
   121ca:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   121cc:	f8a0 300f 	strh.w	r3, [r0, #15]
	lecc->clock_accuracy = node_rx->sca;
   121d0:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   121d4:	7443      	strb	r3, [r0, #17]
   121d6:	e7d2      	b.n	1217e <hci_evt_encode+0x106>
	if (!(event_mask & BT_EVT_MASK_DISCONN_COMPLETE)) {
   121d8:	4b78      	ldr	r3, [pc, #480]	; (123bc <hci_evt_encode+0x344>)
   121da:	6819      	ldr	r1, [r3, #0]
   121dc:	2700      	movs	r7, #0
   121de:	f001 0210 	and.w	r2, r1, #16
   121e2:	463b      	mov	r3, r7
   121e4:	4313      	orrs	r3, r2
   121e6:	d0ca      	beq.n	1217e <hci_evt_encode+0x106>
	hci_evt_create(buf, BT_HCI_EVT_DISCONN_COMPLETE, sizeof(*ep));
   121e8:	2204      	movs	r2, #4
   121ea:	2105      	movs	r1, #5
   121ec:	4628      	mov	r0, r5
   121ee:	f012 f8b9 	bl	24364 <hci_evt_create>
	ep = net_buf_add(buf, sizeof(*ep));
   121f2:	2104      	movs	r1, #4
   121f4:	f105 0008 	add.w	r0, r5, #8
   121f8:	f012 fdee 	bl	24dd8 <net_buf_simple_add>
	conn_count--;
   121fc:	4a71      	ldr	r2, [pc, #452]	; (123c4 <hci_evt_encode+0x34c>)
	ep->status = 0x00;
   121fe:	7007      	strb	r7, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
   12200:	f8a0 6001 	strh.w	r6, [r0, #1]
	ep->reason = *((u8_t *)pdu_data);
   12204:	f894 3020 	ldrb.w	r3, [r4, #32]
   12208:	70c3      	strb	r3, [r0, #3]
	conn_count--;
   1220a:	6813      	ldr	r3, [r2, #0]
   1220c:	3b01      	subs	r3, #1
   1220e:	6013      	str	r3, [r2, #0]
   12210:	e7b5      	b.n	1217e <hci_evt_encode+0x106>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   12212:	4b6a      	ldr	r3, [pc, #424]	; (123bc <hci_evt_encode+0x344>)
   12214:	6858      	ldr	r0, [r3, #4]
   12216:	2100      	movs	r1, #0
   12218:	460a      	mov	r2, r1
   1221a:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
   1221e:	4313      	orrs	r3, r2
   12220:	d0ad      	beq.n	1217e <hci_evt_encode+0x106>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_UPDATE_COMPLETE)) {
   12222:	4b67      	ldr	r3, [pc, #412]	; (123c0 <hci_evt_encode+0x348>)
   12224:	6818      	ldr	r0, [r3, #0]
   12226:	460b      	mov	r3, r1
   12228:	f000 0204 	and.w	r2, r0, #4
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1222c:	4313      	orrs	r3, r2
   1222e:	d0a6      	beq.n	1217e <hci_evt_encode+0x106>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CONN_UPDATE_COMPLETE, sizeof(*sep));
   12230:	2209      	movs	r2, #9
   12232:	2103      	movs	r1, #3
   12234:	4628      	mov	r0, r5
   12236:	f012 f89f 	bl	24378 <meta_evt>
	sep->status = cu->status;
   1223a:	f894 3020 	ldrb.w	r3, [r4, #32]
   1223e:	7003      	strb	r3, [r0, #0]
	sep->interval = sys_cpu_to_le16(cu->interval);
   12240:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   12242:	f8a0 3003 	strh.w	r3, [r0, #3]
	sep->latency = sys_cpu_to_le16(cu->latency);
   12246:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   12248:	f8a0 3005 	strh.w	r3, [r0, #5]
	sep->supv_timeout = sys_cpu_to_le16(cu->timeout);
   1224c:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
	sep->handle = sys_cpu_to_le16(handle);
   1224e:	f8a0 6001 	strh.w	r6, [r0, #1]
	sep->supv_timeout = sys_cpu_to_le16(cu->timeout);
   12252:	f8a0 3007 	strh.w	r3, [r0, #7]
   12256:	e792      	b.n	1217e <hci_evt_encode+0x106>
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_KEY_REFRESH_COMPLETE)) {
   12258:	4b58      	ldr	r3, [pc, #352]	; (123bc <hci_evt_encode+0x344>)
   1225a:	6859      	ldr	r1, [r3, #4]
   1225c:	2400      	movs	r4, #0
   1225e:	4622      	mov	r2, r4
   12260:	f401 4300 	and.w	r3, r1, #32768	; 0x8000
   12264:	4313      	orrs	r3, r2
   12266:	d08a      	beq.n	1217e <hci_evt_encode+0x106>
	hci_evt_create(buf, BT_HCI_EVT_ENCRYPT_KEY_REFRESH_COMPLETE,
   12268:	2203      	movs	r2, #3
   1226a:	2130      	movs	r1, #48	; 0x30
   1226c:	4628      	mov	r0, r5
   1226e:	f012 f879 	bl	24364 <hci_evt_create>
	ep = net_buf_add(buf, sizeof(*ep));
   12272:	2103      	movs	r1, #3
   12274:	f105 0008 	add.w	r0, r5, #8
   12278:	f012 fdae 	bl	24dd8 <net_buf_simple_add>
	ep->status = 0x00;
   1227c:	7004      	strb	r4, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
   1227e:	f8a0 6001 	strh.w	r6, [r0, #1]
   12282:	e77c      	b.n	1217e <hci_evt_encode+0x106>
	if (!(event_mask_page_2 & BT_EVT_MASK_AUTH_PAYLOAD_TIMEOUT_EXP)) {
   12284:	4b50      	ldr	r3, [pc, #320]	; (123c8 <hci_evt_encode+0x350>)
   12286:	6819      	ldr	r1, [r3, #0]
   12288:	2300      	movs	r3, #0
   1228a:	f401 0200 	and.w	r2, r1, #8388608	; 0x800000
   1228e:	4313      	orrs	r3, r2
   12290:	f43f af75 	beq.w	1217e <hci_evt_encode+0x106>
	hci_evt_create(buf, BT_HCI_EVT_AUTH_PAYLOAD_TIMEOUT_EXP, sizeof(*ep));
   12294:	2202      	movs	r2, #2
   12296:	2157      	movs	r1, #87	; 0x57
   12298:	4628      	mov	r0, r5
   1229a:	f012 f863 	bl	24364 <hci_evt_create>
	ep = net_buf_add(buf, sizeof(*ep));
   1229e:	2102      	movs	r1, #2
   122a0:	f105 0008 	add.w	r0, r5, #8
   122a4:	f012 fd98 	bl	24dd8 <net_buf_simple_add>
	ep->handle = sys_cpu_to_le16(handle);
   122a8:	8006      	strh	r6, [r0, #0]
   122aa:	e768      	b.n	1217e <hci_evt_encode+0x106>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   122ac:	4b43      	ldr	r3, [pc, #268]	; (123bc <hci_evt_encode+0x344>)
   122ae:	6858      	ldr	r0, [r3, #4]
   122b0:	2100      	movs	r1, #0
   122b2:	460a      	mov	r2, r1
   122b4:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
   122b8:	4313      	orrs	r3, r2
   122ba:	f43f af60 	beq.w	1217e <hci_evt_encode+0x106>
	    !(le_event_mask & BT_EVT_MASK_LE_CHAN_SEL_ALGO)) {
   122be:	4b40      	ldr	r3, [pc, #256]	; (123c0 <hci_evt_encode+0x348>)
   122c0:	6818      	ldr	r0, [r3, #0]
   122c2:	460b      	mov	r3, r1
   122c4:	f400 2200 	and.w	r2, r0, #524288	; 0x80000
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   122c8:	4313      	orrs	r3, r2
   122ca:	f43f af58 	beq.w	1217e <hci_evt_encode+0x106>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CHAN_SEL_ALGO, sizeof(*sep));
   122ce:	2203      	movs	r2, #3
   122d0:	2114      	movs	r1, #20
   122d2:	4628      	mov	r0, r5
   122d4:	f012 f850 	bl	24378 <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
   122d8:	8006      	strh	r6, [r0, #0]
	sep->chan_sel_algo = cs->csa;
   122da:	f894 3020 	ldrb.w	r3, [r4, #32]
   122de:	7083      	strb	r3, [r0, #2]
   122e0:	e74d      	b.n	1217e <hci_evt_encode+0x106>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   122e2:	4b36      	ldr	r3, [pc, #216]	; (123bc <hci_evt_encode+0x344>)
   122e4:	6858      	ldr	r0, [r3, #4]
   122e6:	2100      	movs	r1, #0
   122e8:	460a      	mov	r2, r1
   122ea:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
   122ee:	4313      	orrs	r3, r2
   122f0:	d006      	beq.n	12300 <hci_evt_encode+0x288>
	    !(le_event_mask & BT_EVT_MASK_LE_PHY_UPDATE_COMPLETE)) {
   122f2:	4b33      	ldr	r3, [pc, #204]	; (123c0 <hci_evt_encode+0x348>)
   122f4:	6818      	ldr	r0, [r3, #0]
   122f6:	460b      	mov	r3, r1
   122f8:	f400 6200 	and.w	r2, r0, #2048	; 0x800
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   122fc:	4313      	orrs	r3, r2
   122fe:	d12c      	bne.n	1235a <hci_evt_encode+0x2e2>
		BT_WARN("handle: 0x%04x, status: %x, tx: %x, rx: %x.", handle,
   12300:	2202      	movs	r2, #2
   12302:	f04f 0300 	mov.w	r3, #0
   12306:	f362 0307 	bfi	r3, r2, #0, #8
   1230a:	4930      	ldr	r1, [pc, #192]	; (123cc <hci_evt_encode+0x354>)
   1230c:	4a30      	ldr	r2, [pc, #192]	; (123d0 <hci_evt_encode+0x358>)
   1230e:	4831      	ldr	r0, [pc, #196]	; (123d4 <hci_evt_encode+0x35c>)
   12310:	9604      	str	r6, [sp, #16]
   12312:	1a52      	subs	r2, r2, r1
   12314:	08d2      	lsrs	r2, r2, #3
   12316:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
   1231a:	f362 138f 	bfi	r3, r2, #6, #10
   1231e:	f894 2020 	ldrb.w	r2, [r4, #32]
   12322:	9205      	str	r2, [sp, #20]
   12324:	2900      	cmp	r1, #0
   12326:	fa91 f2a1 	rbit	r2, r1
   1232a:	fab2 f282 	clz	r2, r2
   1232e:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
   12332:	bf08      	it	eq
   12334:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
   12338:	3201      	adds	r2, #1
   1233a:	2900      	cmp	r1, #0
   1233c:	9206      	str	r2, [sp, #24]
   1233e:	fa91 f2a1 	rbit	r2, r1
   12342:	fab2 f282 	clz	r2, r2
   12346:	bf08      	it	eq
   12348:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
   1234c:	3201      	adds	r2, #1
   1234e:	9207      	str	r2, [sp, #28]
   12350:	a904      	add	r1, sp, #16
   12352:	2204      	movs	r2, #4
   12354:	f00e fec5 	bl	210e2 <log_n>
		return;
   12358:	e711      	b.n	1217e <hci_evt_encode+0x106>
	sep = meta_evt(buf, BT_HCI_EVT_LE_PHY_UPDATE_COMPLETE, sizeof(*sep));
   1235a:	2205      	movs	r2, #5
   1235c:	210c      	movs	r1, #12
   1235e:	4628      	mov	r0, r5
   12360:	f012 f80a 	bl	24378 <meta_evt>
	sep->status = pu->status;
   12364:	f894 3020 	ldrb.w	r3, [r4, #32]
   12368:	7003      	strb	r3, [r0, #0]
	sep->handle = sys_cpu_to_le16(handle);
   1236a:	f8a0 6001 	strh.w	r6, [r0, #1]
   1236e:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
   12372:	2a00      	cmp	r2, #0
   12374:	fa92 f3a2 	rbit	r3, r2
   12378:	fab3 f383 	clz	r3, r3
   1237c:	bf08      	it	eq
   1237e:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   12382:	3301      	adds	r3, #1
	sep->tx_phy = find_lsb_set(pu->tx);
   12384:	70c3      	strb	r3, [r0, #3]
   12386:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
   1238a:	fa92 f3a2 	rbit	r3, r2
   1238e:	2a00      	cmp	r2, #0
   12390:	fab3 f383 	clz	r3, r3
   12394:	bf08      	it	eq
   12396:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   1239a:	3301      	adds	r3, #1
	sep->rx_phy = find_lsb_set(pu->rx);
   1239c:	7103      	strb	r3, [r0, #4]
   1239e:	e6ee      	b.n	1217e <hci_evt_encode+0x106>
		LL_ASSERT(0);
   123a0:	f640 43a9 	movw	r3, #3241	; 0xca9
		LL_ASSERT(0);
   123a4:	4a0c      	ldr	r2, [pc, #48]	; (123d8 <hci_evt_encode+0x360>)
   123a6:	490d      	ldr	r1, [pc, #52]	; (123dc <hci_evt_encode+0x364>)
   123a8:	480d      	ldr	r0, [pc, #52]	; (123e0 <hci_evt_encode+0x368>)
   123aa:	f00d fd02 	bl	1fdb2 <printk>
   123ae:	4040      	eors	r0, r0
   123b0:	f380 8811 	msr	BASEPRI, r0
   123b4:	f04f 0003 	mov.w	r0, #3
   123b8:	df02      	svc	2
}
   123ba:	e6e0      	b.n	1217e <hci_evt_encode+0x106>
   123bc:	2000e628 	.word	0x2000e628
   123c0:	2000e630 	.word	0x2000e630
   123c4:	20000a5c 	.word	0x20000a5c
   123c8:	20000008 	.word	0x20000008
   123cc:	00028540 	.word	0x00028540
   123d0:	00028588 	.word	0x00028588
   123d4:	000642c0 	.word	0x000642c0
   123d8:	00064204 	.word	0x00064204
   123dc:	00065948 	.word	0x00065948
   123e0:	000632fe 	.word	0x000632fe
	switch (pdu_data->llctrl.opcode) {
   123e4:	f890 3023 	ldrb.w	r3, [r0, #35]	; 0x23
   123e8:	3b03      	subs	r3, #3
   123ea:	2b12      	cmp	r3, #18
   123ec:	f200 80a1 	bhi.w	12532 <hci_evt_encode+0x4ba>
   123f0:	e8df f003 	tbb	[pc, r3]
   123f4:	2d9f9f0a 	.word	0x2d9f9f0a
   123f8:	9f339f87 	.word	0x9f339f87
   123fc:	9f3b9f9f 	.word	0x9f3b9f9f
   12400:	9f9f9f40 	.word	0x9f9f9f40
   12404:	689f      	.short	0x689f
   12406:	68          	.byte	0x68
   12407:	00          	.byte	0x00
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   12408:	4b4b      	ldr	r3, [pc, #300]	; (12538 <hci_evt_encode+0x4c0>)
   1240a:	6858      	ldr	r0, [r3, #4]
   1240c:	2100      	movs	r1, #0
   1240e:	460a      	mov	r2, r1
   12410:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
   12414:	4313      	orrs	r3, r2
   12416:	f43f aeb2 	beq.w	1217e <hci_evt_encode+0x106>
	    !(le_event_mask & BT_EVT_MASK_LE_LTK_REQUEST)) {
   1241a:	4b48      	ldr	r3, [pc, #288]	; (1253c <hci_evt_encode+0x4c4>)
   1241c:	6818      	ldr	r0, [r3, #0]
   1241e:	460b      	mov	r3, r1
   12420:	f000 0210 	and.w	r2, r0, #16
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   12424:	4313      	orrs	r3, r2
   12426:	f43f aeaa 	beq.w	1217e <hci_evt_encode+0x106>
	sep = meta_evt(buf, BT_HCI_EVT_LE_LTK_REQUEST, sizeof(*sep));
   1242a:	220c      	movs	r2, #12
   1242c:	2105      	movs	r1, #5
   1242e:	4628      	mov	r0, r5
   12430:	f011 ffa2 	bl	24378 <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
   12434:	4603      	mov	r3, r0
   12436:	4621      	mov	r1, r4
   12438:	f823 6b02 	strh.w	r6, [r3], #2
   1243c:	f851 2f24 	ldr.w	r2, [r1, #36]!
   12440:	f8c0 2002 	str.w	r2, [r0, #2]
   12444:	684a      	ldr	r2, [r1, #4]
   12446:	605a      	str	r2, [r3, #4]
   12448:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
   1244a:	8143      	strh	r3, [r0, #10]
   1244c:	e697      	b.n	1217e <hci_evt_encode+0x106>
		encrypt_change(0x00, handle, buf);
   1244e:	460a      	mov	r2, r1
   12450:	2000      	movs	r0, #0
   12452:	4631      	mov	r1, r6
		encrypt_change(pdu_data->llctrl.reject_ind.error_code, handle,
   12454:	f7fe fff0 	bl	11438 <encrypt_change>
		break;
   12458:	e691      	b.n	1217e <hci_evt_encode+0x106>
		le_remote_feat_complete(0x00, pdu_data, handle, buf);
   1245a:	460b      	mov	r3, r1
   1245c:	4632      	mov	r2, r6
   1245e:	f100 0120 	add.w	r1, r0, #32
   12462:	2000      	movs	r0, #0
		le_remote_feat_complete(BT_HCI_ERR_UNSUPP_REMOTE_FEATURE,
   12464:	f7fe ffba 	bl	113dc <le_remote_feat_complete>
		break;
   12468:	e689      	b.n	1217e <hci_evt_encode+0x106>
		encrypt_change(pdu_data->llctrl.reject_ind.error_code, handle,
   1246a:	460a      	mov	r2, r1
   1246c:	f890 0024 	ldrb.w	r0, [r0, #36]	; 0x24
   12470:	4631      	mov	r1, r6
   12472:	e7ef      	b.n	12454 <hci_evt_encode+0x3dc>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   12474:	4b30      	ldr	r3, [pc, #192]	; (12538 <hci_evt_encode+0x4c0>)
   12476:	6858      	ldr	r0, [r3, #4]
   12478:	2100      	movs	r1, #0
   1247a:	460a      	mov	r2, r1
   1247c:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
   12480:	4313      	orrs	r3, r2
   12482:	d006      	beq.n	12492 <hci_evt_encode+0x41a>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_PARAM_REQ)) {
   12484:	4b2d      	ldr	r3, [pc, #180]	; (1253c <hci_evt_encode+0x4c4>)
   12486:	6818      	ldr	r0, [r3, #0]
   12488:	460b      	mov	r3, r1
   1248a:	f000 0220 	and.w	r2, r0, #32
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1248e:	4313      	orrs	r3, r2
   12490:	d109      	bne.n	124a6 <hci_evt_encode+0x42e>
		ll_conn_update(handle, 2, BT_HCI_ERR_UNSUPP_REMOTE_FEATURE, 0,
   12492:	2300      	movs	r3, #0
   12494:	e9cd 3301 	strd	r3, r3, [sp, #4]
   12498:	9300      	str	r3, [sp, #0]
   1249a:	221a      	movs	r2, #26
   1249c:	2102      	movs	r1, #2
   1249e:	4630      	mov	r0, r6
   124a0:	f012 f975 	bl	2478e <ll_conn_update>
		return;
   124a4:	e66b      	b.n	1217e <hci_evt_encode+0x106>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CONN_PARAM_REQ, sizeof(*sep));
   124a6:	220a      	movs	r2, #10
   124a8:	2106      	movs	r1, #6
   124aa:	4628      	mov	r0, r5
   124ac:	f011 ff64 	bl	24378 <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
   124b0:	8006      	strh	r6, [r0, #0]
	sep->interval_min = pdu_data->llctrl.conn_param_req.interval_min;
   124b2:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   124b4:	8043      	strh	r3, [r0, #2]
	sep->interval_max = pdu_data->llctrl.conn_param_req.interval_max;
   124b6:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
   124b8:	8083      	strh	r3, [r0, #4]
	sep->latency = pdu_data->llctrl.conn_param_req.latency;
   124ba:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   124bc:	80c3      	strh	r3, [r0, #6]
	sep->timeout = pdu_data->llctrl.conn_param_req.timeout;
   124be:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
	sep->max_rx_time = pdu_data->llctrl.length_rsp.max_rx_time;
   124c0:	8103      	strh	r3, [r0, #8]
   124c2:	e65c      	b.n	1217e <hci_evt_encode+0x106>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   124c4:	4b1c      	ldr	r3, [pc, #112]	; (12538 <hci_evt_encode+0x4c0>)
   124c6:	6858      	ldr	r0, [r3, #4]
   124c8:	2100      	movs	r1, #0
   124ca:	460a      	mov	r2, r1
   124cc:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
   124d0:	4313      	orrs	r3, r2
   124d2:	f43f ae54 	beq.w	1217e <hci_evt_encode+0x106>
	    !(le_event_mask & BT_EVT_MASK_LE_DATA_LEN_CHANGE)) {
   124d6:	4b19      	ldr	r3, [pc, #100]	; (1253c <hci_evt_encode+0x4c4>)
   124d8:	6818      	ldr	r0, [r3, #0]
   124da:	460b      	mov	r3, r1
   124dc:	f000 0240 	and.w	r2, r0, #64	; 0x40
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   124e0:	4313      	orrs	r3, r2
   124e2:	f43f ae4c 	beq.w	1217e <hci_evt_encode+0x106>
	sep = meta_evt(buf, BT_HCI_EVT_LE_DATA_LEN_CHANGE, sizeof(*sep));
   124e6:	220a      	movs	r2, #10
   124e8:	2107      	movs	r1, #7
   124ea:	4628      	mov	r0, r5
   124ec:	f011 ff44 	bl	24378 <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
   124f0:	8006      	strh	r6, [r0, #0]
	sep->max_tx_octets = pdu_data->llctrl.length_rsp.max_tx_octets;
   124f2:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   124f4:	8043      	strh	r3, [r0, #2]
	sep->max_tx_time = pdu_data->llctrl.length_rsp.max_tx_time;
   124f6:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
   124f8:	8083      	strh	r3, [r0, #4]
	sep->max_rx_octets = pdu_data->llctrl.length_rsp.max_rx_octets;
   124fa:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   124fc:	80c3      	strh	r3, [r0, #6]
	sep->max_rx_time = pdu_data->llctrl.length_rsp.max_rx_time;
   124fe:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
   12500:	e7de      	b.n	124c0 <hci_evt_encode+0x448>
		le_unknown_rsp(pdu_data, handle, buf);
   12502:	f890 1024 	ldrb.w	r1, [r0, #36]	; 0x24
	switch (pdu_data->llctrl.unknown_rsp.type) {
   12506:	290e      	cmp	r1, #14
   12508:	d104      	bne.n	12514 <hci_evt_encode+0x49c>
		le_remote_feat_complete(BT_HCI_ERR_UNSUPP_REMOTE_FEATURE,
   1250a:	462b      	mov	r3, r5
   1250c:	4632      	mov	r2, r6
   1250e:	2100      	movs	r1, #0
   12510:	201a      	movs	r0, #26
   12512:	e7a7      	b.n	12464 <hci_evt_encode+0x3ec>
		BT_WARN("type: 0x%02x",	pdu_data->llctrl.unknown_rsp.type);
   12514:	2302      	movs	r3, #2
   12516:	f04f 0200 	mov.w	r2, #0
   1251a:	f363 0207 	bfi	r2, r3, #0, #8
   1251e:	4808      	ldr	r0, [pc, #32]	; (12540 <hci_evt_encode+0x4c8>)
   12520:	4b08      	ldr	r3, [pc, #32]	; (12544 <hci_evt_encode+0x4cc>)
   12522:	1a1b      	subs	r3, r3, r0
   12524:	08db      	lsrs	r3, r3, #3
   12526:	f363 128f 	bfi	r2, r3, #6, #10
   1252a:	4807      	ldr	r0, [pc, #28]	; (12548 <hci_evt_encode+0x4d0>)
   1252c:	f00e fd92 	bl	21054 <log_1>
   12530:	e625      	b.n	1217e <hci_evt_encode+0x106>
		LL_ASSERT(0);
   12532:	f640 5372 	movw	r3, #3442	; 0xd72
   12536:	e735      	b.n	123a4 <hci_evt_encode+0x32c>
   12538:	2000e628 	.word	0x2000e628
   1253c:	2000e630 	.word	0x2000e630
   12540:	00028540 	.word	0x00028540
   12544:	00028588 	.word	0x00028588
   12548:	000642ec 	.word	0x000642ec

0001254c <hci_init>:
	event_mask = DEFAULT_EVENT_MASK;
   1254c:	4b08      	ldr	r3, [pc, #32]	; (12570 <hci_init+0x24>)
   1254e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   12552:	f641 71ff 	movw	r1, #8191	; 0x1fff
   12556:	e9c3 0100 	strd	r0, r1, [r3]
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
   1255a:	4b06      	ldr	r3, [pc, #24]	; (12574 <hci_init+0x28>)
   1255c:	2000      	movs	r0, #0
   1255e:	2100      	movs	r1, #0
   12560:	e9c3 0100 	strd	r0, r1, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
   12564:	4b04      	ldr	r3, [pc, #16]	; (12578 <hci_init+0x2c>)
   12566:	201f      	movs	r0, #31
   12568:	2100      	movs	r1, #0
   1256a:	e9c3 0100 	strd	r0, r1, [r3]
{
#if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
	hbuf_signal = signal_host_buf;
#endif
	reset(NULL, NULL);
}
   1256e:	4770      	bx	lr
   12570:	2000e628 	.word	0x2000e628
   12574:	20000008 	.word	0x20000008
   12578:	2000e630 	.word	0x2000e630

0001257c <bt_rand>:
#include "hal/ecb.h"

static struct device *entropy_driver;

int bt_rand(void *buf, size_t len)
{
   1257c:	b570      	push	{r4, r5, r6, lr}
	struct device *dev = entropy_driver;
   1257e:	4c08      	ldr	r4, [pc, #32]	; (125a0 <bt_rand+0x24>)
{
   12580:	4605      	mov	r5, r0
	struct device *dev = entropy_driver;
   12582:	6820      	ldr	r0, [r4, #0]
{
   12584:	460e      	mov	r6, r1

	if (unlikely(!dev)) {
   12586:	b918      	cbnz	r0, 12590 <bt_rand+0x14>
   12588:	4806      	ldr	r0, [pc, #24]	; (125a4 <bt_rand+0x28>)
   1258a:	f00b fd49 	bl	1e020 <z_impl_device_get_binding>
		dev = device_get_binding(CONFIG_ENTROPY_NAME);
		__ASSERT((dev != NULL),
			"Device driver for %s (CONFIG_ENTROPY_NAME) not found. "
			"Check your build configuration!",
			CONFIG_ENTROPY_NAME);
		entropy_driver = dev;
   1258e:	6020      	str	r0, [r4, #0]
	return api->get_entropy(dev, buffer, length);
   12590:	6843      	ldr	r3, [r0, #4]
   12592:	b2b2      	uxth	r2, r6
   12594:	4629      	mov	r1, r5
   12596:	681b      	ldr	r3, [r3, #0]
	}

	return entropy_get_entropy(dev, (u8_t *)buf, len);
}
   12598:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1259c:	4718      	bx	r3
   1259e:	bf00      	nop
   125a0:	20000a60 	.word	0x20000a60
   125a4:	00064317 	.word	0x00064317

000125a8 <ll_rx_link_inc_quota>:
	rx_alloc(UINT8_MAX);
}

static inline void ll_rx_link_inc_quota(int8_t delta)
{
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
   125a8:	2801      	cmp	r0, #1
{
   125aa:	b538      	push	{r3, r4, r5, lr}
   125ac:	4604      	mov	r4, r0
   125ae:	4d0b      	ldr	r5, [pc, #44]	; (125dc <ll_rx_link_inc_quota+0x34>)
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
   125b0:	d10f      	bne.n	125d2 <ll_rx_link_inc_quota+0x2a>
   125b2:	782b      	ldrb	r3, [r5, #0]
   125b4:	2b06      	cmp	r3, #6
   125b6:	d90c      	bls.n	125d2 <ll_rx_link_inc_quota+0x2a>
   125b8:	f240 3369 	movw	r3, #873	; 0x369
   125bc:	4a08      	ldr	r2, [pc, #32]	; (125e0 <ll_rx_link_inc_quota+0x38>)
   125be:	4909      	ldr	r1, [pc, #36]	; (125e4 <ll_rx_link_inc_quota+0x3c>)
   125c0:	4809      	ldr	r0, [pc, #36]	; (125e8 <ll_rx_link_inc_quota+0x40>)
   125c2:	f00d fbf6 	bl	1fdb2 <printk>
   125c6:	4040      	eors	r0, r0
   125c8:	f380 8811 	msr	BASEPRI, r0
   125cc:	f04f 0003 	mov.w	r0, #3
   125d0:	df02      	svc	2
	mem_link_rx.quota_pdu += delta;
   125d2:	782b      	ldrb	r3, [r5, #0]
   125d4:	441c      	add	r4, r3
   125d6:	702c      	strb	r4, [r5, #0]
}
   125d8:	bd38      	pop	{r3, r4, r5, pc}
   125da:	bf00      	nop
   125dc:	20000b5c 	.word	0x20000b5c
   125e0:	0006437c 	.word	0x0006437c
   125e4:	000643b0 	.word	0x000643b0
   125e8:	000632fe 	.word	0x000632fe

000125ec <rx_alloc>:

	return done;
}

static inline void rx_alloc(u8_t max)
{
   125ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	u8_t idx;

#if defined(CONFIG_BT_CONN)
	while (mem_link_rx.quota_pdu &&
   125f0:	4e31      	ldr	r6, [pc, #196]	; (126b8 <rx_alloc+0xcc>)
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
   125f2:	4f32      	ldr	r7, [pc, #200]	; (126bc <rx_alloc+0xd0>)
{
   125f4:	4680      	mov	r8, r0
   125f6:	46b1      	mov	r9, r6
	while (mem_link_rx.quota_pdu &&
   125f8:	7833      	ldrb	r3, [r6, #0]
   125fa:	b1b3      	cbz	r3, 1262a <rx_alloc+0x3e>
 */
static inline bool mfifo_enqueue_idx_get(u8_t count, u8_t first, u8_t last,
					 u8_t *idx)
{
	/* Non-destructive: Advance write-index modulo 'count' */
	last = last + 1;
   125fc:	78fc      	ldrb	r4, [r7, #3]
	if (last == count) {
   125fe:	787a      	ldrb	r2, [r7, #1]
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
   12600:	78bb      	ldrb	r3, [r7, #2]
	last = last + 1;
   12602:	3401      	adds	r4, #1
   12604:	b2e4      	uxtb	r4, r4
		last = 0U;
   12606:	42a2      	cmp	r2, r4
   12608:	bf08      	it	eq
   1260a:	2400      	moveq	r4, #0
	 * We want to maintain the invariant of emptiness defined by
	 * first == last, but we just advanced a copy of the write-index before
	 * and may have wrapped. So if first == last the queue is full and we
	 * can not continue
	 */
	if (last == first) {
   1260c:	42a3      	cmp	r3, r4
   1260e:	d00c      	beq.n	1262a <rx_alloc+0x3e>
		memq_link_t *link;
		struct node_rx_hdr *rx;

		link = mem_acquire(&mem_link_rx.free);
   12610:	482b      	ldr	r0, [pc, #172]	; (126c0 <rx_alloc+0xd4>)
   12612:	f011 fcdc 	bl	23fce <mem_acquire>
		if (!link) {
   12616:	4605      	mov	r5, r0
   12618:	b138      	cbz	r0, 1262a <rx_alloc+0x3e>
			break;
		}

		rx = mem_acquire(&mem_pdu_rx.free);
   1261a:	482a      	ldr	r0, [pc, #168]	; (126c4 <rx_alloc+0xd8>)
   1261c:	f011 fcd7 	bl	23fce <mem_acquire>
		if (!rx) {
   12620:	bb00      	cbnz	r0, 12664 <rx_alloc+0x78>
			mem_release(link, &mem_link_rx.free);
   12622:	4927      	ldr	r1, [pc, #156]	; (126c0 <rx_alloc+0xd4>)
   12624:	4628      	mov	r0, r5
   12626:	f011 fce3 	bl	23ff0 <mem_release>

		ll_rx_link_inc_quota(-1);
	}
#endif /* CONFIG_BT_CONN */

	if (max > mem_link_rx.quota_pdu) {
   1262a:	f899 6000 	ldrb.w	r6, [r9]

	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
		memq_link_t *link;
		struct node_rx_hdr *rx;

		link = mem_acquire(&mem_link_rx.free);
   1262e:	4f24      	ldr	r7, [pc, #144]	; (126c0 <rx_alloc+0xd4>)
   12630:	4546      	cmp	r6, r8
   12632:	bf28      	it	cs
   12634:	4646      	movcs	r6, r8
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
   12636:	f8df 8090 	ldr.w	r8, [pc, #144]	; 126c8 <rx_alloc+0xdc>
   1263a:	b18e      	cbz	r6, 12660 <rx_alloc+0x74>
	last = last + 1;
   1263c:	f898 4003 	ldrb.w	r4, [r8, #3]
	if (last == count) {
   12640:	f898 2001 	ldrb.w	r2, [r8, #1]
   12644:	f898 3002 	ldrb.w	r3, [r8, #2]
	last = last + 1;
   12648:	3401      	adds	r4, #1
   1264a:	b2e4      	uxtb	r4, r4
		last = 0U;
   1264c:	42a2      	cmp	r2, r4
   1264e:	bf08      	it	eq
   12650:	2400      	moveq	r4, #0
	if (last == first) {
   12652:	42a3      	cmp	r3, r4
   12654:	d004      	beq.n	12660 <rx_alloc+0x74>
		link = mem_acquire(&mem_link_rx.free);
   12656:	4638      	mov	r0, r7
   12658:	f011 fcb9 	bl	23fce <mem_acquire>
		if (!link) {
   1265c:	4605      	mov	r5, r0
   1265e:	b978      	cbnz	r0, 12680 <rx_alloc+0x94>

		MFIFO_BY_IDX_ENQUEUE(pdu_rx_free, idx, rx);

		ll_rx_link_inc_quota(-1);
	}
}
   12660:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		link->mem = NULL;
   12664:	2300      	movs	r3, #0
   12666:	606b      	str	r3, [r5, #4]
		rx->link = link;
   12668:	6005      	str	r5, [r0, #0]
 */
static inline void mfifo_by_idx_enqueue(u8_t *fifo, u8_t size, u8_t idx,
					void *mem, u8_t *last)
{
	/* API 2: fifo is array of void-ptrs */
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   1266a:	78fa      	ldrb	r2, [r7, #3]
   1266c:	783b      	ldrb	r3, [r7, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   1266e:	fb02 7303 	mla	r3, r2, r3, r7
   12672:	6058      	str	r0, [r3, #4]

	*last = idx; /* Commit: Update write index */
   12674:	70fc      	strb	r4, [r7, #3]
		ll_rx_link_inc_quota(-1);
   12676:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1267a:	f7ff ff95 	bl	125a8 <ll_rx_link_inc_quota>
   1267e:	e7bb      	b.n	125f8 <rx_alloc+0xc>
		rx = mem_acquire(&mem_pdu_rx.free);
   12680:	4810      	ldr	r0, [pc, #64]	; (126c4 <rx_alloc+0xd8>)
   12682:	f011 fca4 	bl	23fce <mem_acquire>
		if (!rx) {
   12686:	b928      	cbnz	r0, 12694 <rx_alloc+0xa8>
			mem_release(link, &mem_link_rx.free);
   12688:	4628      	mov	r0, r5
   1268a:	490d      	ldr	r1, [pc, #52]	; (126c0 <rx_alloc+0xd4>)
}
   1268c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			mem_release(link, &mem_link_rx.free);
   12690:	f011 bcae 	b.w	23ff0 <mem_release>
		rx->link = link;
   12694:	6005      	str	r5, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   12696:	f898 2003 	ldrb.w	r2, [r8, #3]
   1269a:	f898 3000 	ldrb.w	r3, [r8]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   1269e:	fb02 8303 	mla	r3, r2, r3, r8
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
   126a2:	3e01      	subs	r6, #1
   126a4:	6058      	str	r0, [r3, #4]
	*last = idx; /* Commit: Update write index */
   126a6:	f888 4003 	strb.w	r4, [r8, #3]
		ll_rx_link_inc_quota(-1);
   126aa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
   126ae:	b2f6      	uxtb	r6, r6
		ll_rx_link_inc_quota(-1);
   126b0:	f7ff ff7a 	bl	125a8 <ll_rx_link_inc_quota>
   126b4:	e7c1      	b.n	1263a <rx_alloc+0x4e>
   126b6:	bf00      	nop
   126b8:	20000b5c 	.word	0x20000b5c
   126bc:	2000e84c 	.word	0x2000e84c
   126c0:	20000b60 	.word	0x20000b60
   126c4:	20000bb4 	.word	0x20000bb4
   126c8:	2000e860 	.word	0x2000e860

000126cc <init_reset>:
	mem_init(mem_done.pool, sizeof(struct node_rx_event_done),
   126cc:	4b3a      	ldr	r3, [pc, #232]	; (127b8 <init_reset+0xec>)
{
   126ce:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	mem_init(mem_done.pool, sizeof(struct node_rx_event_done),
   126d2:	1d18      	adds	r0, r3, #4
   126d4:	2203      	movs	r2, #3
   126d6:	2138      	movs	r1, #56	; 0x38
   126d8:	f011 fc60 	bl	23f9c <mem_init>
	mem_init(mem_link_done.pool, sizeof(memq_link_t), EVENT_DONE_MAX,
   126dc:	4b37      	ldr	r3, [pc, #220]	; (127bc <init_reset+0xf0>)
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
   126de:	4d38      	ldr	r5, [pc, #224]	; (127c0 <init_reset+0xf4>)
		link = mem_acquire(&mem_link_done.free);
   126e0:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 127bc <init_reset+0xf0>
	mem_init(mem_link_done.pool, sizeof(memq_link_t), EVENT_DONE_MAX,
   126e4:	2203      	movs	r2, #3
   126e6:	2108      	movs	r1, #8
   126e8:	1d18      	adds	r0, r3, #4
   126ea:	f011 fc57 	bl	23f9c <mem_init>
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
   126ee:	462e      	mov	r6, r5
	last = last + 1;
   126f0:	78ec      	ldrb	r4, [r5, #3]
	if (last == count) {
   126f2:	786a      	ldrb	r2, [r5, #1]
   126f4:	78ab      	ldrb	r3, [r5, #2]
	last = last + 1;
   126f6:	3401      	adds	r4, #1
   126f8:	b2e4      	uxtb	r4, r4
		last = 0U;
   126fa:	42a2      	cmp	r2, r4
   126fc:	bf08      	it	eq
   126fe:	2400      	moveq	r4, #0
	if (last == first) {
   12700:	429c      	cmp	r4, r3
   12702:	d00d      	beq.n	12720 <init_reset+0x54>
		link = mem_acquire(&mem_link_done.free);
   12704:	4640      	mov	r0, r8
   12706:	f011 fc62 	bl	23fce <mem_acquire>
		if (!link) {
   1270a:	4607      	mov	r7, r0
   1270c:	b140      	cbz	r0, 12720 <init_reset+0x54>
		rx = mem_acquire(&mem_done.free);
   1270e:	482a      	ldr	r0, [pc, #168]	; (127b8 <init_reset+0xec>)
   12710:	f011 fc5d 	bl	23fce <mem_acquire>
		if (!rx) {
   12714:	2800      	cmp	r0, #0
   12716:	d146      	bne.n	127a6 <init_reset+0xda>
			mem_release(link, &mem_link_done.free);
   12718:	4928      	ldr	r1, [pc, #160]	; (127bc <init_reset+0xf0>)
   1271a:	4638      	mov	r0, r7
   1271c:	f011 fc68 	bl	23ff0 <mem_release>
	mem_init(mem_pdu_rx.pool, (PDU_RX_NODE_POOL_ELEMENT_SIZE),
   12720:	4b28      	ldr	r3, [pc, #160]	; (127c4 <init_reset+0xf8>)
   12722:	2208      	movs	r2, #8
   12724:	1d18      	adds	r0, r3, #4
   12726:	214c      	movs	r1, #76	; 0x4c
   12728:	f011 fc38 	bl	23f9c <mem_init>
	mem_init(mem_link_rx.pool, sizeof(memq_link_t),
   1272c:	4b26      	ldr	r3, [pc, #152]	; (127c8 <init_reset+0xfc>)
   1272e:	220a      	movs	r2, #10
   12730:	1d18      	adds	r0, r3, #4
   12732:	2108      	movs	r1, #8
   12734:	f011 fc32 	bl	23f9c <mem_init>
	link = mem_acquire(&mem_link_rx.free);
   12738:	4823      	ldr	r0, [pc, #140]	; (127c8 <init_reset+0xfc>)
   1273a:	f011 fc48 	bl	23fce <mem_acquire>
	LL_ASSERT(link);
   1273e:	4604      	mov	r4, r0
   12740:	b960      	cbnz	r0, 1275c <init_reset+0x90>
   12742:	f240 43bb 	movw	r3, #1211	; 0x4bb
   12746:	4a21      	ldr	r2, [pc, #132]	; (127cc <init_reset+0x100>)
   12748:	4921      	ldr	r1, [pc, #132]	; (127d0 <init_reset+0x104>)
   1274a:	4822      	ldr	r0, [pc, #136]	; (127d4 <init_reset+0x108>)
   1274c:	f00d fb31 	bl	1fdb2 <printk>
   12750:	4040      	eors	r0, r0
   12752:	f380 8811 	msr	BASEPRI, r0
   12756:	f04f 0003 	mov.w	r0, #3
   1275a:	df02      	svc	2
	MEMQ_INIT(ull_rx, link);
   1275c:	4a1e      	ldr	r2, [pc, #120]	; (127d8 <init_reset+0x10c>)
   1275e:	4620      	mov	r0, r4
   12760:	1f11      	subs	r1, r2, #4
   12762:	f011 fc78 	bl	24056 <memq_init>
	link = mem_acquire(&mem_link_rx.free);
   12766:	4818      	ldr	r0, [pc, #96]	; (127c8 <init_reset+0xfc>)
   12768:	f011 fc31 	bl	23fce <mem_acquire>
	LL_ASSERT(link);
   1276c:	4604      	mov	r4, r0
   1276e:	b960      	cbnz	r0, 1278a <init_reset+0xbe>
   12770:	f240 43c2 	movw	r3, #1218	; 0x4c2
   12774:	4a15      	ldr	r2, [pc, #84]	; (127cc <init_reset+0x100>)
   12776:	4916      	ldr	r1, [pc, #88]	; (127d0 <init_reset+0x104>)
   12778:	4816      	ldr	r0, [pc, #88]	; (127d4 <init_reset+0x108>)
   1277a:	f00d fb1a 	bl	1fdb2 <printk>
   1277e:	4040      	eors	r0, r0
   12780:	f380 8811 	msr	BASEPRI, r0
   12784:	f04f 0003 	mov.w	r0, #3
   12788:	df02      	svc	2
	MEMQ_INIT(ll_rx, link);
   1278a:	4a14      	ldr	r2, [pc, #80]	; (127dc <init_reset+0x110>)
   1278c:	4620      	mov	r0, r4
   1278e:	1f11      	subs	r1, r2, #4
   12790:	f011 fc61 	bl	24056 <memq_init>
	mem_link_rx.quota_pdu = RX_CNT;
   12794:	4b12      	ldr	r3, [pc, #72]	; (127e0 <init_reset+0x114>)
   12796:	2207      	movs	r2, #7
	rx_alloc(UINT8_MAX);
   12798:	20ff      	movs	r0, #255	; 0xff
	mem_link_rx.quota_pdu = RX_CNT;
   1279a:	701a      	strb	r2, [r3, #0]
	rx_alloc(UINT8_MAX);
   1279c:	f7ff ff26 	bl	125ec <rx_alloc>
}
   127a0:	2000      	movs	r0, #0
   127a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		rx->link = link;
   127a6:	6007      	str	r7, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   127a8:	78f2      	ldrb	r2, [r6, #3]
   127aa:	7833      	ldrb	r3, [r6, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   127ac:	fb02 6303 	mla	r3, r2, r3, r6
   127b0:	6058      	str	r0, [r3, #4]
	*last = idx; /* Commit: Update write index */
   127b2:	70f4      	strb	r4, [r6, #3]
   127b4:	e79c      	b.n	126f0 <init_reset+0x24>
   127b6:	bf00      	nop
   127b8:	20000a94 	.word	0x20000a94
   127bc:	20000b40 	.word	0x20000b40
   127c0:	2000e838 	.word	0x2000e838
   127c4:	20000bb4 	.word	0x20000bb4
   127c8:	20000b60 	.word	0x20000b60
   127cc:	0006437c 	.word	0x0006437c
   127d0:	00064829 	.word	0x00064829
   127d4:	000632fe 	.word	0x000632fe
   127d8:	20000e24 	.word	0x20000e24
   127dc:	20000e1c 	.word	0x20000e1c
   127e0:	20000b5c 	.word	0x20000b5c

000127e4 <perform_lll_reset>:
{
   127e4:	b510      	push	{r4, lr}
   127e6:	4604      	mov	r4, r0
	err = lll_reset();
   127e8:	f011 fe8b 	bl	24502 <lll_reset>
	LL_ASSERT(!err);
   127ec:	b160      	cbz	r0, 12808 <perform_lll_reset+0x24>
   127ee:	f240 43d4 	movw	r3, #1236	; 0x4d4
   127f2:	4a18      	ldr	r2, [pc, #96]	; (12854 <perform_lll_reset+0x70>)
   127f4:	4918      	ldr	r1, [pc, #96]	; (12858 <perform_lll_reset+0x74>)
   127f6:	4819      	ldr	r0, [pc, #100]	; (1285c <perform_lll_reset+0x78>)
   127f8:	f00d fadb 	bl	1fdb2 <printk>
   127fc:	4040      	eors	r0, r0
   127fe:	f380 8811 	msr	BASEPRI, r0
   12802:	f04f 0003 	mov.w	r0, #3
   12806:	df02      	svc	2
	err = lll_adv_reset();
   12808:	f011 ff37 	bl	2467a <lll_adv_reset>
	LL_ASSERT(!err);
   1280c:	b160      	cbz	r0, 12828 <perform_lll_reset+0x44>
   1280e:	f240 43d9 	movw	r3, #1241	; 0x4d9
   12812:	4a10      	ldr	r2, [pc, #64]	; (12854 <perform_lll_reset+0x70>)
   12814:	4910      	ldr	r1, [pc, #64]	; (12858 <perform_lll_reset+0x74>)
   12816:	4811      	ldr	r0, [pc, #68]	; (1285c <perform_lll_reset+0x78>)
   12818:	f00d facb 	bl	1fdb2 <printk>
   1281c:	4040      	eors	r0, r0
   1281e:	f380 8811 	msr	BASEPRI, r0
   12822:	f04f 0003 	mov.w	r0, #3
   12826:	df02      	svc	2
	err = lll_conn_reset();
   12828:	f012 f95b 	bl	24ae2 <lll_conn_reset>
	LL_ASSERT(!err);
   1282c:	b160      	cbz	r0, 12848 <perform_lll_reset+0x64>
   1282e:	f240 43e5 	movw	r3, #1253	; 0x4e5
   12832:	4a08      	ldr	r2, [pc, #32]	; (12854 <perform_lll_reset+0x70>)
   12834:	4908      	ldr	r1, [pc, #32]	; (12858 <perform_lll_reset+0x74>)
   12836:	4809      	ldr	r0, [pc, #36]	; (1285c <perform_lll_reset+0x78>)
   12838:	f00d fabb 	bl	1fdb2 <printk>
   1283c:	4040      	eors	r0, r0
   1283e:	f380 8811 	msr	BASEPRI, r0
   12842:	f04f 0003 	mov.w	r0, #3
   12846:	df02      	svc	2
	z_impl_k_sem_give(sem);
   12848:	4620      	mov	r0, r4
}
   1284a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1284e:	f00c ba95 	b.w	1ed7c <z_impl_k_sem_give>
   12852:	bf00      	nop
   12854:	0006437c 	.word	0x0006437c
   12858:	00064426 	.word	0x00064426
   1285c:	000632fe 	.word	0x000632fe

00012860 <tx_cmplt_get>:

#if defined(CONFIG_BT_CONN)
static u8_t tx_cmplt_get(u16_t *handle, u8_t *first, u8_t last)
{
   12860:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   12864:	460d      	mov	r5, r1
	struct lll_tx *tx;
	u8_t cmplt;

	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
   12866:	4e28      	ldr	r6, [pc, #160]	; (12908 <tx_cmplt_get+0xa8>)
					   u8_t first, u8_t last, u8_t *idx)
{
	void *p;
	u8_t i;

	if (*idx >= count) {
   12868:	782b      	ldrb	r3, [r5, #0]
   1286a:	7871      	ldrb	r1, [r6, #1]
   1286c:	428b      	cmp	r3, r1
   1286e:	bf28      	it	cs
   12870:	78b3      	ldrbcs	r3, [r6, #2]
{
   12872:	4680      	mov	r8, r0
	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
   12874:	7830      	ldrb	r0, [r6, #0]
		*idx = first;
   12876:	bf28      	it	cs
   12878:	702b      	strbcs	r3, [r5, #0]
	}

	if (*idx == last) {
   1287a:	782b      	ldrb	r3, [r5, #0]
   1287c:	429a      	cmp	r2, r3
{
   1287e:	4691      	mov	r9, r2
   12880:	d103      	bne.n	1288a <tx_cmplt_get+0x2a>
				    mfifo_tx_ack.n, mfifo_tx_ack.f, last,
				    first);
	if (!tx) {
		return 0;
   12882:	2700      	movs	r7, #0
					    mfifo_tx_ack.n, mfifo_tx_ack.f,
					    last, first);
	} while (tx && tx->handle == *handle);

	return cmplt;
}
   12884:	4638      	mov	r0, r7
   12886:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return NULL;
	}

	i = *idx + 1;
   1288a:	1c5a      	adds	r2, r3, #1
   1288c:	b2d2      	uxtb	r2, r2
	if (i == count) {
		i = 0U;
	}

	p = (void *)(fifo + (*idx) * size);
   1288e:	4c1f      	ldr	r4, [pc, #124]	; (1290c <tx_cmplt_get+0xac>)
		i = 0U;
   12890:	4291      	cmp	r1, r2
   12892:	bf08      	it	eq
   12894:	2200      	moveq	r2, #0
	p = (void *)(fifo + (*idx) * size);
   12896:	fb13 f300 	smulbb	r3, r3, r0

	*idx = i;
   1289a:	702a      	strb	r2, [r5, #0]
	if (!tx) {
   1289c:	18e2      	adds	r2, r4, r3
   1289e:	d0f0      	beq.n	12882 <tx_cmplt_get+0x22>
	*handle = tx->handle;
   128a0:	5ae3      	ldrh	r3, [r4, r3]
   128a2:	f8a8 3000 	strh.w	r3, [r8]
	cmplt = 0U;
   128a6:	2700      	movs	r7, #0
		node_tx = tx->node;
   128a8:	6850      	ldr	r0, [r2, #4]
		if (!node_tx || (node_tx == (void *)1) ||
   128aa:	2801      	cmp	r0, #1
   128ac:	f020 0103 	bic.w	r1, r0, #3
   128b0:	d906      	bls.n	128c0 <tx_cmplt_get+0x60>
   128b2:	b331      	cbz	r1, 12902 <tx_cmplt_get+0xa2>
		     (p->ll_id == PDU_DATA_LLID_DATA_START ||
   128b4:	7903      	ldrb	r3, [r0, #4]
   128b6:	f003 0303 	and.w	r3, r3, #3
		    (((u32_t)node_tx & ~3) &&
   128ba:	3b01      	subs	r3, #1
   128bc:	2b01      	cmp	r3, #1
   128be:	d820      	bhi.n	12902 <tx_cmplt_get+0xa2>
			cmplt++;
   128c0:	3701      	adds	r7, #1
   128c2:	b2ff      	uxtb	r7, r7
			tx->node = (void *)1;
   128c4:	2301      	movs	r3, #1
   128c6:	6053      	str	r3, [r2, #4]
		if (((u32_t)node_tx & ~3)) {
   128c8:	b109      	cbz	r1, 128ce <tx_cmplt_get+0x6e>
			ll_tx_mem_release(node_tx);
   128ca:	f002 fabf 	bl	14e4c <ll_tx_mem_release>
	if (*idx >= count) {
   128ce:	782b      	ldrb	r3, [r5, #0]
		tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
   128d0:	7872      	ldrb	r2, [r6, #1]
   128d2:	7830      	ldrb	r0, [r6, #0]
   128d4:	4293      	cmp	r3, r2
   128d6:	bf24      	itt	cs
   128d8:	78b3      	ldrbcs	r3, [r6, #2]
		*idx = first;
   128da:	702b      	strbcs	r3, [r5, #0]
	if (*idx == last) {
   128dc:	782b      	ldrb	r3, [r5, #0]
   128de:	4599      	cmp	r9, r3
   128e0:	d0d0      	beq.n	12884 <tx_cmplt_get+0x24>
	i = *idx + 1;
   128e2:	1c59      	adds	r1, r3, #1
   128e4:	b2c9      	uxtb	r1, r1
	p = (void *)(fifo + (*idx) * size);
   128e6:	fb13 f300 	smulbb	r3, r3, r0
		i = 0U;
   128ea:	428a      	cmp	r2, r1
   128ec:	bf08      	it	eq
   128ee:	2100      	moveq	r1, #0
	} while (tx && tx->handle == *handle);
   128f0:	18e2      	adds	r2, r4, r3
	*idx = i;
   128f2:	7029      	strb	r1, [r5, #0]
   128f4:	d0c6      	beq.n	12884 <tx_cmplt_get+0x24>
   128f6:	5ae3      	ldrh	r3, [r4, r3]
   128f8:	f8b8 1000 	ldrh.w	r1, [r8]
   128fc:	4299      	cmp	r1, r3
   128fe:	d0d3      	beq.n	128a8 <tx_cmplt_get+0x48>
   12900:	e7c0      	b.n	12884 <tx_cmplt_get+0x24>
			tx->node = (void *)2;
   12902:	2302      	movs	r3, #2
   12904:	e7df      	b.n	128c6 <tx_cmplt_get+0x66>
   12906:	bf00      	nop
   12908:	2000e99c 	.word	0x2000e99c
   1290c:	2000e9a0 	.word	0x2000e9a0

00012910 <ll_init>:
{
   12910:	b510      	push	{r4, lr}
	sem_recv = sem_rx;
   12912:	4b28      	ldr	r3, [pc, #160]	; (129b4 <ll_init+0xa4>)
{
   12914:	b086      	sub	sp, #24
	sem_recv = sem_rx;
   12916:	6018      	str	r0, [r3, #0]
	cntr_init();
   12918:	f005 fda8 	bl	1846c <cntr_init>
	mayfly_init();
   1291c:	f7fd fe38 	bl	10590 <mayfly_init>
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
   12920:	4a25      	ldr	r2, [pc, #148]	; (129b8 <ll_init+0xa8>)
   12922:	2103      	movs	r1, #3
   12924:	7011      	strb	r1, [r2, #0]
	ticker_users[MAYFLY_CALL_ID_PROGRAM][0] = TICKER_USER_APP_OPS;
   12926:	7611      	strb	r1, [r2, #24]
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
   12928:	2002      	movs	r0, #2
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
   1292a:	4924      	ldr	r1, [pc, #144]	; (129bc <ll_init+0xac>)
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
   1292c:	7410      	strb	r0, [r2, #16]
	ticker_users[MAYFLY_CALL_ID_1][0] = TICKER_USER_ULL_HIGH_OPS;
   1292e:	2304      	movs	r3, #4
   12930:	7213      	strb	r3, [r2, #8]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
   12932:	9105      	str	r1, [sp, #20]
   12934:	4922      	ldr	r1, [pc, #136]	; (129c0 <ll_init+0xb0>)
   12936:	9104      	str	r1, [sp, #16]
   12938:	4922      	ldr	r1, [pc, #136]	; (129c4 <ll_init+0xb4>)
   1293a:	9103      	str	r1, [sp, #12]
   1293c:	4922      	ldr	r1, [pc, #136]	; (129c8 <ll_init+0xb8>)
   1293e:	9102      	str	r1, [sp, #8]
   12940:	210c      	movs	r1, #12
   12942:	e9cd 2100 	strd	r2, r1, [sp]
   12946:	2000      	movs	r0, #0
   12948:	4a20      	ldr	r2, [pc, #128]	; (129cc <ll_init+0xbc>)
   1294a:	2105      	movs	r1, #5
   1294c:	f7fe fa96 	bl	10e7c <ticker_init>
	LL_ASSERT(!err);
   12950:	b160      	cbz	r0, 1296c <ll_init+0x5c>
   12952:	f240 130f 	movw	r3, #271	; 0x10f
   12956:	4a1e      	ldr	r2, [pc, #120]	; (129d0 <ll_init+0xc0>)
   12958:	491e      	ldr	r1, [pc, #120]	; (129d4 <ll_init+0xc4>)
   1295a:	481f      	ldr	r0, [pc, #124]	; (129d8 <ll_init+0xc8>)
   1295c:	f00d fa29 	bl	1fdb2 <printk>
   12960:	4040      	eors	r0, r0
   12962:	f380 8811 	msr	BASEPRI, r0
   12966:	f04f 0003 	mov.w	r0, #3
   1296a:	df02      	svc	2
	z_impl_k_sem_init(sem, initial_count, limit);
   1296c:	2201      	movs	r2, #1
   1296e:	2100      	movs	r1, #0
   12970:	481a      	ldr	r0, [pc, #104]	; (129dc <ll_init+0xcc>)
   12972:	f015 fa4a 	bl	27e0a <z_impl_k_sem_init>
	err = lll_init();
   12976:	f000 ff3d 	bl	137f4 <lll_init>
	if (err) {
   1297a:	4604      	mov	r4, r0
   1297c:	b9b0      	cbnz	r0, 129ac <ll_init+0x9c>
	err = init_reset();
   1297e:	f7ff fea5 	bl	126cc <init_reset>
	if (err) {
   12982:	4604      	mov	r4, r0
   12984:	b990      	cbnz	r0, 129ac <ll_init+0x9c>
	err = lll_adv_init();
   12986:	f011 fe76 	bl	24676 <lll_adv_init>
	if (err) {
   1298a:	4604      	mov	r4, r0
   1298c:	b970      	cbnz	r0, 129ac <ll_init+0x9c>
	err = ull_adv_init();
   1298e:	f011 fde4 	bl	2455a <ull_adv_init>
	if (err) {
   12992:	4604      	mov	r4, r0
   12994:	b950      	cbnz	r0, 129ac <ll_init+0x9c>
	err = lll_conn_init();
   12996:	f012 f8a2 	bl	24ade <lll_conn_init>
	if (err) {
   1299a:	4604      	mov	r4, r0
   1299c:	b930      	cbnz	r0, 129ac <ll_init+0x9c>
	err = ull_conn_init();
   1299e:	f002 fadf 	bl	14f60 <ull_conn_init>
	if (err) {
   129a2:	4604      	mov	r4, r0
   129a4:	b910      	cbnz	r0, 129ac <ll_init+0x9c>
		ull_filter_reset(true);
   129a6:	2001      	movs	r0, #1
   129a8:	f005 fc0c 	bl	181c4 <ull_filter_reset>
}
   129ac:	4620      	mov	r0, r4
   129ae:	b006      	add	sp, #24
   129b0:	bd10      	pop	{r4, pc}
   129b2:	bf00      	nop
   129b4:	20000e28 	.word	0x20000e28
   129b8:	20001160 	.word	0x20001160
   129bc:	00024d5f 	.word	0x00024d5f
   129c0:	00018e4d 	.word	0x00018e4d
   129c4:	00018df5 	.word	0x00018df5
   129c8:	20000f20 	.word	0x20000f20
   129cc:	20000e44 	.word	0x20000e44
   129d0:	0006437c 	.word	0x0006437c
   129d4:	00064426 	.word	0x00064426
   129d8:	000632fe 	.word	0x000632fe
   129dc:	20000e2c 	.word	0x20000e2c

000129e0 <ll_reset>:
{
   129e0:	b510      	push	{r4, lr}
   129e2:	b086      	sub	sp, #24
	err = ull_adv_reset();
   129e4:	f011 fdbb 	bl	2455e <ull_adv_reset>
	LL_ASSERT(!err);
   129e8:	b160      	cbz	r0, 12a04 <ll_reset+0x24>
   129ea:	f240 135d 	movw	r3, #349	; 0x15d
   129ee:	4a2d      	ldr	r2, [pc, #180]	; (12aa4 <ll_reset+0xc4>)
   129f0:	492d      	ldr	r1, [pc, #180]	; (12aa8 <ll_reset+0xc8>)
   129f2:	482e      	ldr	r0, [pc, #184]	; (12aac <ll_reset+0xcc>)
   129f4:	f00d f9dd 	bl	1fdb2 <printk>
   129f8:	4040      	eors	r0, r0
   129fa:	f380 8811 	msr	BASEPRI, r0
   129fe:	f04f 0003 	mov.w	r0, #3
   12a02:	df02      	svc	2
	err = ull_conn_reset();
   12a04:	f002 fabe 	bl	14f84 <ull_conn_reset>
	LL_ASSERT(!err);
   12a08:	b160      	cbz	r0, 12a24 <ll_reset+0x44>
   12a0a:	f240 137d 	movw	r3, #381	; 0x17d
   12a0e:	4a25      	ldr	r2, [pc, #148]	; (12aa4 <ll_reset+0xc4>)
   12a10:	4925      	ldr	r1, [pc, #148]	; (12aa8 <ll_reset+0xc8>)
   12a12:	4826      	ldr	r0, [pc, #152]	; (12aac <ll_reset+0xcc>)
   12a14:	f00d f9cd 	bl	1fdb2 <printk>
   12a18:	4040      	eors	r0, r0
   12a1a:	f380 8811 	msr	BASEPRI, r0
   12a1e:	f04f 0003 	mov.w	r0, #3
   12a22:	df02      	svc	2
	MFIFO_INIT(tx_ack);
   12a24:	4b22      	ldr	r3, [pc, #136]	; (12ab0 <ll_reset+0xd0>)
   12a26:	2400      	movs	r4, #0
   12a28:	805c      	strh	r4, [r3, #2]
		ull_filter_reset(false);
   12a2a:	4620      	mov	r0, r4
   12a2c:	f005 fbca 	bl	181c4 <ull_filter_reset>
	MFIFO_INIT(prep);
   12a30:	4b20      	ldr	r3, [pc, #128]	; (12ab4 <ll_reset+0xd4>)
   12a32:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(done);
   12a34:	4b20      	ldr	r3, [pc, #128]	; (12ab8 <ll_reset+0xd8>)
   12a36:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(pdu_rx_free);
   12a38:	4b20      	ldr	r3, [pc, #128]	; (12abc <ll_reset+0xdc>)
   12a3a:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(ll_pdu_rx_free);
   12a3c:	4b20      	ldr	r3, [pc, #128]	; (12ac0 <ll_reset+0xe0>)
   12a3e:	805c      	strh	r4, [r3, #2]
   12a40:	2201      	movs	r2, #1
   12a42:	4621      	mov	r1, r4
   12a44:	4668      	mov	r0, sp
   12a46:	f015 f9e0 	bl	27e0a <z_impl_k_sem_init>
		mfy.param = &sem;
   12a4a:	4b1e      	ldr	r3, [pc, #120]	; (12ac4 <ll_reset+0xe4>)
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
   12a4c:	4622      	mov	r2, r4
   12a4e:	4621      	mov	r1, r4
   12a50:	2003      	movs	r0, #3
		mfy.param = &sem;
   12a52:	f8c3 d008 	str.w	sp, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
   12a56:	f7fd fded 	bl	10634 <mayfly_enqueue>
		LL_ASSERT(!retval);
   12a5a:	b160      	cbz	r0, 12a76 <ll_reset+0x96>
   12a5c:	f240 13af 	movw	r3, #431	; 0x1af
   12a60:	4a10      	ldr	r2, [pc, #64]	; (12aa4 <ll_reset+0xc4>)
   12a62:	4919      	ldr	r1, [pc, #100]	; (12ac8 <ll_reset+0xe8>)
   12a64:	4811      	ldr	r0, [pc, #68]	; (12aac <ll_reset+0xcc>)
   12a66:	f00d f9a4 	bl	1fdb2 <printk>
   12a6a:	4040      	eors	r0, r0
   12a6c:	f380 8811 	msr	BASEPRI, r0
   12a70:	f04f 0003 	mov.w	r0, #3
   12a74:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
   12a76:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   12a7a:	4668      	mov	r0, sp
   12a7c:	f00c f9aa 	bl	1edd4 <z_impl_k_sem_take>
	err = init_reset();
   12a80:	f7ff fe24 	bl	126cc <init_reset>
	LL_ASSERT(!err);
   12a84:	b160      	cbz	r0, 12aa0 <ll_reset+0xc0>
   12a86:	f240 13bb 	movw	r3, #443	; 0x1bb
   12a8a:	4a06      	ldr	r2, [pc, #24]	; (12aa4 <ll_reset+0xc4>)
   12a8c:	4906      	ldr	r1, [pc, #24]	; (12aa8 <ll_reset+0xc8>)
   12a8e:	4807      	ldr	r0, [pc, #28]	; (12aac <ll_reset+0xcc>)
   12a90:	f00d f98f 	bl	1fdb2 <printk>
   12a94:	4040      	eors	r0, r0
   12a96:	f380 8811 	msr	BASEPRI, r0
   12a9a:	f04f 0003 	mov.w	r0, #3
   12a9e:	df02      	svc	2
}
   12aa0:	b006      	add	sp, #24
   12aa2:	bd10      	pop	{r4, pc}
   12aa4:	0006437c 	.word	0x0006437c
   12aa8:	00064426 	.word	0x00064426
   12aac:	000632fe 	.word	0x000632fe
   12ab0:	2000e99c 	.word	0x2000e99c
   12ab4:	2000e878 	.word	0x2000e878
   12ab8:	2000e838 	.word	0x2000e838
   12abc:	2000e860 	.word	0x2000e860
   12ac0:	2000e84c 	.word	0x2000e84c
   12ac4:	2000e9c0 	.word	0x2000e9c0
   12ac8:	00064335 	.word	0x00064335

00012acc <ll_rx_get>:
{
   12acc:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
   12ad0:	4d25      	ldr	r5, [pc, #148]	; (12b68 <ll_rx_get+0x9c>)
   12ad2:	4e26      	ldr	r6, [pc, #152]	; (12b6c <ll_rx_get+0xa0>)
{
   12ad4:	4680      	mov	r8, r0
   12ad6:	460f      	mov	r7, r1
   12ad8:	46aa      	mov	sl, r5
	*node_rx = NULL;
   12ada:	2300      	movs	r3, #0
   12adc:	f8c8 3000 	str.w	r3, [r8]
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
   12ae0:	aa01      	add	r2, sp, #4
   12ae2:	e9d5 0100 	ldrd	r0, r1, [r5]
   12ae6:	f011 facb 	bl	24080 <memq_peek>
	if (link) {
   12aea:	4681      	mov	r9, r0
   12aec:	b3a0      	cbz	r0, 12b58 <ll_rx_get+0x8c>
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
   12aee:	9b01      	ldr	r3, [sp, #4]
   12af0:	491f      	ldr	r1, [pc, #124]	; (12b70 <ll_rx_get+0xa4>)
   12af2:	781a      	ldrb	r2, [r3, #0]
   12af4:	4638      	mov	r0, r7
   12af6:	f7ff feb3 	bl	12860 <tx_cmplt_get>
		if (!cmplt) {
   12afa:	4604      	mov	r4, r0
   12afc:	bb40      	cbnz	r0, 12b50 <ll_rx_get+0x84>
			f = mfifo_tx_ack.f;
   12afe:	78b3      	ldrb	r3, [r6, #2]
   12b00:	f88d 3001 	strb.w	r3, [sp, #1]
				cmplt_curr = tx_cmplt_get(&h, &f,
   12b04:	78f2      	ldrb	r2, [r6, #3]
   12b06:	f10d 0101 	add.w	r1, sp, #1
   12b0a:	f10d 0002 	add.w	r0, sp, #2
   12b0e:	f7ff fea7 	bl	12860 <tx_cmplt_get>
				 (cmplt_prev != cmplt_curr));
   12b12:	b9cc      	cbnz	r4, 12b48 <ll_rx_get+0x7c>
			} while ((cmplt_prev != 0U) ||
   12b14:	b9c0      	cbnz	r0, 12b48 <ll_rx_get+0x7c>
			if (rx->type == NODE_RX_TYPE_DC_PDU_RELEASE) {
   12b16:	9b01      	ldr	r3, [sp, #4]
   12b18:	791a      	ldrb	r2, [r3, #4]
   12b1a:	2a03      	cmp	r2, #3
   12b1c:	d116      	bne.n	12b4c <ll_rx_get+0x80>
				(void)memq_dequeue(memq_ll_rx.tail,
   12b1e:	4622      	mov	r2, r4
   12b20:	4629      	mov	r1, r5
   12b22:	f8da 0004 	ldr.w	r0, [sl, #4]
   12b26:	f011 fab3 	bl	24090 <memq_dequeue>
				mem_release(link, &mem_link_rx.free);
   12b2a:	4912      	ldr	r1, [pc, #72]	; (12b74 <ll_rx_get+0xa8>)
   12b2c:	4648      	mov	r0, r9
   12b2e:	f011 fa5f 	bl	23ff0 <mem_release>
				ll_rx_link_inc_quota(1);
   12b32:	2001      	movs	r0, #1
   12b34:	f7ff fd38 	bl	125a8 <ll_rx_link_inc_quota>
				mem_release(rx, &mem_pdu_rx.free);
   12b38:	9801      	ldr	r0, [sp, #4]
   12b3a:	490f      	ldr	r1, [pc, #60]	; (12b78 <ll_rx_get+0xac>)
   12b3c:	f011 fa58 	bl	23ff0 <mem_release>
				rx_alloc(1);
   12b40:	2001      	movs	r0, #1
   12b42:	f7ff fd53 	bl	125ec <rx_alloc>
				goto ll_rx_get_again;
   12b46:	e7c8      	b.n	12ada <ll_rx_get+0xe>
{
   12b48:	4604      	mov	r4, r0
   12b4a:	e7db      	b.n	12b04 <ll_rx_get+0x38>
			*node_rx = rx;
   12b4c:	f8c8 3000 	str.w	r3, [r8]
}
   12b50:	4620      	mov	r0, r4
   12b52:	b002      	add	sp, #8
   12b54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, mfifo_tx_ack.l);
   12b58:	78f2      	ldrb	r2, [r6, #3]
   12b5a:	4905      	ldr	r1, [pc, #20]	; (12b70 <ll_rx_get+0xa4>)
   12b5c:	4638      	mov	r0, r7
   12b5e:	f7ff fe7f 	bl	12860 <tx_cmplt_get>
   12b62:	4604      	mov	r4, r0
   12b64:	e7f4      	b.n	12b50 <ll_rx_get+0x84>
   12b66:	bf00      	nop
   12b68:	20000e18 	.word	0x20000e18
   12b6c:	2000e99c 	.word	0x2000e99c
   12b70:	2000e99e 	.word	0x2000e99e
   12b74:	20000b60 	.word	0x20000b60
   12b78:	20000bb4 	.word	0x20000bb4

00012b7c <ll_rx_dequeue>:
{
   12b7c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   12b7e:	4954      	ldr	r1, [pc, #336]	; (12cd0 <ll_rx_dequeue+0x154>)
	struct node_rx_hdr *rx = NULL;
   12b80:	2300      	movs	r3, #0
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   12b82:	aa01      	add	r2, sp, #4
   12b84:	6848      	ldr	r0, [r1, #4]
	struct node_rx_hdr *rx = NULL;
   12b86:	9301      	str	r3, [sp, #4]
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   12b88:	f011 fa82 	bl	24090 <memq_dequeue>
	LL_ASSERT(link);
   12b8c:	4604      	mov	r4, r0
   12b8e:	b960      	cbnz	r0, 12baa <ll_rx_dequeue+0x2e>
   12b90:	f240 230d 	movw	r3, #525	; 0x20d
   12b94:	4a4f      	ldr	r2, [pc, #316]	; (12cd4 <ll_rx_dequeue+0x158>)
   12b96:	4950      	ldr	r1, [pc, #320]	; (12cd8 <ll_rx_dequeue+0x15c>)
   12b98:	4850      	ldr	r0, [pc, #320]	; (12cdc <ll_rx_dequeue+0x160>)
   12b9a:	f00d f90a 	bl	1fdb2 <printk>
   12b9e:	4040      	eors	r0, r0
   12ba0:	f380 8811 	msr	BASEPRI, r0
   12ba4:	f04f 0003 	mov.w	r0, #3
   12ba8:	df02      	svc	2
	mem_release(link, &mem_link_rx.free);
   12baa:	494d      	ldr	r1, [pc, #308]	; (12ce0 <ll_rx_dequeue+0x164>)
   12bac:	4620      	mov	r0, r4
   12bae:	f011 fa1f 	bl	23ff0 <mem_release>
	switch (rx->type) {
   12bb2:	9b01      	ldr	r3, [sp, #4]
   12bb4:	7919      	ldrb	r1, [r3, #4]
   12bb6:	290e      	cmp	r1, #14
   12bb8:	f200 8084 	bhi.w	12cc4 <ll_rx_dequeue+0x148>
   12bbc:	2201      	movs	r2, #1
   12bbe:	408a      	lsls	r2, r1
   12bc0:	f647 6005 	movw	r0, #32261	; 0x7e05
   12bc4:	4202      	tst	r2, r0
   12bc6:	d16d      	bne.n	12ca4 <ll_rx_dequeue+0x128>
   12bc8:	05d2      	lsls	r2, r2, #23
   12bca:	d57b      	bpl.n	12cc4 <ll_rx_dequeue+0x148>
		} else if ((cc->status == BT_HCI_ERR_ADV_TIMEOUT) || cc->role) {
   12bcc:	f893 2020 	ldrb.w	r2, [r3, #32]
   12bd0:	2a3c      	cmp	r2, #60	; 0x3c
   12bd2:	d003      	beq.n	12bdc <ll_rx_dequeue+0x60>
   12bd4:	f893 1021 	ldrb.w	r1, [r3, #33]	; 0x21
   12bd8:	2900      	cmp	r1, #0
   12bda:	d055      	beq.n	12c88 <ll_rx_dequeue+0x10c>
			struct lll_adv *lll = ftr->param;
   12bdc:	689e      	ldr	r6, [r3, #8]
			if (cc->status == BT_HCI_ERR_ADV_TIMEOUT) {
   12bde:	2a3c      	cmp	r2, #60	; 0x3c
			struct ll_adv_set *adv = (void *)HDR_LLL2EVT(lll);
   12be0:	6835      	ldr	r5, [r6, #0]
			if (cc->status == BT_HCI_ERR_ADV_TIMEOUT) {
   12be2:	d146      	bne.n	12c72 <ll_rx_dequeue+0xf6>
				conn_lll = lll->conn;
   12be4:	68b4      	ldr	r4, [r6, #8]
				LL_ASSERT(conn_lll);
   12be6:	b964      	cbnz	r4, 12c02 <ll_rx_dequeue+0x86>
   12be8:	f240 2326 	movw	r3, #550	; 0x226
   12bec:	4a39      	ldr	r2, [pc, #228]	; (12cd4 <ll_rx_dequeue+0x158>)
   12bee:	493d      	ldr	r1, [pc, #244]	; (12ce4 <ll_rx_dequeue+0x168>)
   12bf0:	483a      	ldr	r0, [pc, #232]	; (12cdc <ll_rx_dequeue+0x160>)
   12bf2:	f00d f8de 	bl	1fdb2 <printk>
   12bf6:	4040      	eors	r0, r0
   12bf8:	f380 8811 	msr	BASEPRI, r0
   12bfc:	f04f 0003 	mov.w	r0, #3
   12c00:	df02      	svc	2
				lll->conn = NULL;
   12c02:	2300      	movs	r3, #0
   12c04:	60b3      	str	r3, [r6, #8]
				LL_ASSERT(!conn_lll->link_tx_free);
   12c06:	6de3      	ldr	r3, [r4, #92]	; 0x5c
   12c08:	b163      	cbz	r3, 12c24 <ll_rx_dequeue+0xa8>
   12c0a:	f240 2329 	movw	r3, #553	; 0x229
   12c0e:	4a31      	ldr	r2, [pc, #196]	; (12cd4 <ll_rx_dequeue+0x158>)
   12c10:	4935      	ldr	r1, [pc, #212]	; (12ce8 <ll_rx_dequeue+0x16c>)
   12c12:	4832      	ldr	r0, [pc, #200]	; (12cdc <ll_rx_dequeue+0x160>)
   12c14:	f00d f8cd 	bl	1fdb2 <printk>
   12c18:	4040      	eors	r0, r0
   12c1a:	f380 8811 	msr	BASEPRI, r0
   12c1e:	f04f 0003 	mov.w	r0, #3
   12c22:	df02      	svc	2
				link = memq_deinit(&conn_lll->memq_tx.head,
   12c24:	f104 0150 	add.w	r1, r4, #80	; 0x50
   12c28:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   12c2c:	f011 fa16 	bl	2405c <memq_deinit>
				LL_ASSERT(link);
   12c30:	4606      	mov	r6, r0
   12c32:	b960      	cbnz	r0, 12c4e <ll_rx_dequeue+0xd2>
   12c34:	f44f 730b 	mov.w	r3, #556	; 0x22c
   12c38:	4a26      	ldr	r2, [pc, #152]	; (12cd4 <ll_rx_dequeue+0x158>)
   12c3a:	4927      	ldr	r1, [pc, #156]	; (12cd8 <ll_rx_dequeue+0x15c>)
   12c3c:	4827      	ldr	r0, [pc, #156]	; (12cdc <ll_rx_dequeue+0x160>)
   12c3e:	f00d f8b8 	bl	1fdb2 <printk>
   12c42:	4040      	eors	r0, r0
   12c44:	f380 8811 	msr	BASEPRI, r0
   12c48:	f04f 0003 	mov.w	r0, #3
   12c4c:	df02      	svc	2
				conn_lll->link_tx_free = link;
   12c4e:	65e6      	str	r6, [r4, #92]	; 0x5c
				ll_conn_release(conn);
   12c50:	6820      	ldr	r0, [r4, #0]
   12c52:	f002 f8df 	bl	14e14 <ll_conn_release>
			adv->is_enabled = 0U;
   12c56:	f895 30cc 	ldrb.w	r3, [r5, #204]	; 0xcc
   12c5a:	f36f 0300 	bfc	r3, #0, #1
   12c5e:	f885 30cc 	strb.w	r3, [r5, #204]	; 0xcc
			      ull_adv_is_enabled(0));
   12c62:	2000      	movs	r0, #0
   12c64:	f011 fc80 	bl	24568 <ull_adv_is_enabled>
			if (!bm) {
   12c68:	b908      	cbnz	r0, 12c6e <ll_rx_dequeue+0xf2>
				ull_filter_adv_scan_state_cb(0);
   12c6a:	f004 fef5 	bl	17a58 <ull_filter_adv_scan_state_cb>
}
   12c6e:	b002      	add	sp, #8
   12c70:	bd70      	pop	{r4, r5, r6, pc}
				if (adv->node_rx_cc_free) {
   12c72:	f8d5 00d4 	ldr.w	r0, [r5, #212]	; 0xd4
   12c76:	2800      	cmp	r0, #0
   12c78:	d0ed      	beq.n	12c56 <ll_rx_dequeue+0xda>
					adv->node_rx_cc_free = NULL;
   12c7a:	2300      	movs	r3, #0
   12c7c:	f8c5 30d4 	str.w	r3, [r5, #212]	; 0xd4
					mem_release(rx_free, &mem_pdu_rx.free);
   12c80:	491a      	ldr	r1, [pc, #104]	; (12cec <ll_rx_dequeue+0x170>)
   12c82:	f011 f9b5 	bl	23ff0 <mem_release>
   12c86:	e7e6      	b.n	12c56 <ll_rx_dequeue+0xda>
			LL_ASSERT(0);
   12c88:	f44f 7312 	mov.w	r3, #584	; 0x248
   12c8c:	4a11      	ldr	r2, [pc, #68]	; (12cd4 <ll_rx_dequeue+0x158>)
   12c8e:	4918      	ldr	r1, [pc, #96]	; (12cf0 <ll_rx_dequeue+0x174>)
   12c90:	4812      	ldr	r0, [pc, #72]	; (12cdc <ll_rx_dequeue+0x160>)
   12c92:	f00d f88e 	bl	1fdb2 <printk>
   12c96:	4040      	eors	r0, r0
   12c98:	f380 8811 	msr	BASEPRI, r0
   12c9c:	f04f 0003 	mov.w	r0, #3
   12ca0:	df02      	svc	2
   12ca2:	e7de      	b.n	12c62 <ll_rx_dequeue+0xe6>
		LL_ASSERT(rx->type != NODE_RX_TYPE_NONE);
   12ca4:	2900      	cmp	r1, #0
   12ca6:	d1e2      	bne.n	12c6e <ll_rx_dequeue+0xf2>
   12ca8:	4a0a      	ldr	r2, [pc, #40]	; (12cd4 <ll_rx_dequeue+0x158>)
   12caa:	4912      	ldr	r1, [pc, #72]	; (12cf4 <ll_rx_dequeue+0x178>)
   12cac:	f240 2399 	movw	r3, #665	; 0x299
		LL_ASSERT(0);
   12cb0:	480a      	ldr	r0, [pc, #40]	; (12cdc <ll_rx_dequeue+0x160>)
   12cb2:	f00d f87e 	bl	1fdb2 <printk>
   12cb6:	4040      	eors	r0, r0
   12cb8:	f380 8811 	msr	BASEPRI, r0
   12cbc:	f04f 0003 	mov.w	r0, #3
   12cc0:	df02      	svc	2
}
   12cc2:	e7d4      	b.n	12c6e <ll_rx_dequeue+0xf2>
		LL_ASSERT(0);
   12cc4:	f240 239d 	movw	r3, #669	; 0x29d
   12cc8:	4a02      	ldr	r2, [pc, #8]	; (12cd4 <ll_rx_dequeue+0x158>)
   12cca:	4909      	ldr	r1, [pc, #36]	; (12cf0 <ll_rx_dequeue+0x174>)
   12ccc:	e7f0      	b.n	12cb0 <ll_rx_dequeue+0x134>
   12cce:	bf00      	nop
   12cd0:	20000e18 	.word	0x20000e18
   12cd4:	0006437c 	.word	0x0006437c
   12cd8:	00064829 	.word	0x00064829
   12cdc:	000632fe 	.word	0x000632fe
   12ce0:	20000b60 	.word	0x20000b60
   12ce4:	0006433d 	.word	0x0006433d
   12ce8:	00064346 	.word	0x00064346
   12cec:	20000bb4 	.word	0x20000bb4
   12cf0:	00065948 	.word	0x00065948
   12cf4:	0006435e 	.word	0x0006435e

00012cf8 <ll_rx_mem_release>:
{
   12cf8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx = *node_rx;
   12cfc:	6804      	ldr	r4, [r0, #0]
			LL_ASSERT(0);
   12cfe:	4d44      	ldr	r5, [pc, #272]	; (12e10 <ll_rx_mem_release+0x118>)
   12d00:	f8df 8128 	ldr.w	r8, [pc, #296]	; 12e2c <ll_rx_mem_release+0x134>
   12d04:	4e43      	ldr	r6, [pc, #268]	; (12e14 <ll_rx_mem_release+0x11c>)
{
   12d06:	4607      	mov	r7, r0
	while (rx) {
   12d08:	b92c      	cbnz	r4, 12d16 <ll_rx_mem_release+0x1e>
	*node_rx = rx;
   12d0a:	603c      	str	r4, [r7, #0]
	rx_alloc(UINT8_MAX);
   12d0c:	20ff      	movs	r0, #255	; 0xff
}
   12d0e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx_alloc(UINT8_MAX);
   12d12:	f7ff bc6b 	b.w	125ec <rx_alloc>
		switch (rx_free->type) {
   12d16:	7922      	ldrb	r2, [r4, #4]
		rx = rx->next;
   12d18:	f8d4 9000 	ldr.w	r9, [r4]
		switch (rx_free->type) {
   12d1c:	2a0e      	cmp	r2, #14
   12d1e:	d868      	bhi.n	12df2 <ll_rx_mem_release+0xfa>
   12d20:	2301      	movs	r3, #1
   12d22:	4093      	lsls	r3, r2
   12d24:	f647 4205 	movw	r2, #31749	; 0x7c05
   12d28:	4213      	tst	r3, r2
   12d2a:	d11b      	bne.n	12d64 <ll_rx_mem_release+0x6c>
   12d2c:	059a      	lsls	r2, r3, #22
   12d2e:	d42c      	bmi.n	12d8a <ll_rx_mem_release+0x92>
   12d30:	05db      	lsls	r3, r3, #23
   12d32:	d55e      	bpl.n	12df2 <ll_rx_mem_release+0xfa>
			} else if (cc->status == BT_HCI_ERR_ADV_TIMEOUT) {
   12d34:	f894 3020 	ldrb.w	r3, [r4, #32]
   12d38:	2b3c      	cmp	r3, #60	; 0x3c
   12d3a:	d105      	bne.n	12d48 <ll_rx_mem_release+0x50>
			mem_release(rx_free, &mem_pdu_rx.free);
   12d3c:	4936      	ldr	r1, [pc, #216]	; (12e18 <ll_rx_mem_release+0x120>)
   12d3e:	4620      	mov	r0, r4
   12d40:	f011 f956 	bl	23ff0 <mem_release>
{
   12d44:	464c      	mov	r4, r9
   12d46:	e7df      	b.n	12d08 <ll_rx_mem_release+0x10>
				LL_ASSERT(!cc->status);
   12d48:	b163      	cbz	r3, 12d64 <ll_rx_mem_release+0x6c>
   12d4a:	f240 23f5 	movw	r3, #757	; 0x2f5
   12d4e:	462a      	mov	r2, r5
   12d50:	4932      	ldr	r1, [pc, #200]	; (12e1c <ll_rx_mem_release+0x124>)
   12d52:	4630      	mov	r0, r6
   12d54:	f00d f82d 	bl	1fdb2 <printk>
   12d58:	4040      	eors	r0, r0
   12d5a:	f380 8811 	msr	BASEPRI, r0
   12d5e:	f04f 0003 	mov.w	r0, #3
   12d62:	df02      	svc	2
			LL_ASSERT(rx_free->type != NODE_RX_TYPE_NONE);
   12d64:	7923      	ldrb	r3, [r4, #4]
   12d66:	b963      	cbnz	r3, 12d82 <ll_rx_mem_release+0x8a>
   12d68:	f240 3336 	movw	r3, #822	; 0x336
   12d6c:	462a      	mov	r2, r5
   12d6e:	492c      	ldr	r1, [pc, #176]	; (12e20 <ll_rx_mem_release+0x128>)
   12d70:	4630      	mov	r0, r6
   12d72:	f00d f81e 	bl	1fdb2 <printk>
   12d76:	4040      	eors	r0, r0
   12d78:	f380 8811 	msr	BASEPRI, r0
   12d7c:	f04f 0003 	mov.w	r0, #3
   12d80:	df02      	svc	2
			ll_rx_link_inc_quota(1);
   12d82:	2001      	movs	r0, #1
   12d84:	f7ff fc10 	bl	125a8 <ll_rx_link_inc_quota>
   12d88:	e7d8      	b.n	12d3c <ll_rx_mem_release+0x44>
			conn = ll_conn_get(rx_free->handle);
   12d8a:	88e0      	ldrh	r0, [r4, #6]
   12d8c:	f002 f850 	bl	14e30 <ll_conn_get>
			lll->handle = 0xFFFF;
   12d90:	f64f 73ff 	movw	r3, #65535	; 0xffff
			conn = ll_conn_get(rx_free->handle);
   12d94:	4604      	mov	r4, r0
			lll->handle = 0xFFFF;
   12d96:	8583      	strh	r3, [r0, #44]	; 0x2c
			ull_conn_tx_demux(UINT8_MAX);
   12d98:	20ff      	movs	r0, #255	; 0xff
   12d9a:	f003 fd5d 	bl	16858 <ull_conn_tx_demux>
			LL_ASSERT(!lll->link_tx_free);
   12d9e:	6fa3      	ldr	r3, [r4, #120]	; 0x78
   12da0:	b163      	cbz	r3, 12dbc <ll_rx_mem_release+0xc4>
   12da2:	f240 334f 	movw	r3, #847	; 0x34f
   12da6:	462a      	mov	r2, r5
   12da8:	491e      	ldr	r1, [pc, #120]	; (12e24 <ll_rx_mem_release+0x12c>)
   12daa:	4630      	mov	r0, r6
   12dac:	f00d f801 	bl	1fdb2 <printk>
   12db0:	4040      	eors	r0, r0
   12db2:	f380 8811 	msr	BASEPRI, r0
   12db6:	f04f 0003 	mov.w	r0, #3
   12dba:	df02      	svc	2
			link = memq_deinit(&lll->memq_tx.head,
   12dbc:	f104 016c 	add.w	r1, r4, #108	; 0x6c
   12dc0:	f104 0068 	add.w	r0, r4, #104	; 0x68
   12dc4:	f011 f94a 	bl	2405c <memq_deinit>
			LL_ASSERT(link);
   12dc8:	4682      	mov	sl, r0
   12dca:	b960      	cbnz	r0, 12de6 <ll_rx_mem_release+0xee>
   12dcc:	f240 3352 	movw	r3, #850	; 0x352
   12dd0:	462a      	mov	r2, r5
   12dd2:	4915      	ldr	r1, [pc, #84]	; (12e28 <ll_rx_mem_release+0x130>)
   12dd4:	4630      	mov	r0, r6
   12dd6:	f00c ffec 	bl	1fdb2 <printk>
   12dda:	4040      	eors	r0, r0
   12ddc:	f380 8811 	msr	BASEPRI, r0
   12de0:	f04f 0003 	mov.w	r0, #3
   12de4:	df02      	svc	2
			lll->link_tx_free = link;
   12de6:	f8c4 a078 	str.w	sl, [r4, #120]	; 0x78
			ll_conn_release(conn);
   12dea:	4620      	mov	r0, r4
   12dec:	f002 f812 	bl	14e14 <ll_conn_release>
		break;
   12df0:	e7a8      	b.n	12d44 <ll_rx_mem_release+0x4c>
			LL_ASSERT(0);
   12df2:	f240 335d 	movw	r3, #861	; 0x35d
   12df6:	462a      	mov	r2, r5
   12df8:	4641      	mov	r1, r8
   12dfa:	4630      	mov	r0, r6
   12dfc:	f00c ffd9 	bl	1fdb2 <printk>
   12e00:	4040      	eors	r0, r0
   12e02:	f380 8811 	msr	BASEPRI, r0
   12e06:	f04f 0003 	mov.w	r0, #3
   12e0a:	df02      	svc	2
			break;
   12e0c:	e79a      	b.n	12d44 <ll_rx_mem_release+0x4c>
   12e0e:	bf00      	nop
   12e10:	0006437c 	.word	0x0006437c
   12e14:	000632fe 	.word	0x000632fe
   12e18:	20000bb4 	.word	0x20000bb4
   12e1c:	000643e4 	.word	0x000643e4
   12e20:	000643f0 	.word	0x000643f0
   12e24:	00064413 	.word	0x00064413
   12e28:	00064829 	.word	0x00064829
   12e2c:	00065948 	.word	0x00065948

00012e30 <ll_rx_link_alloc>:
	return mem_acquire(&mem_link_rx.free);
   12e30:	4801      	ldr	r0, [pc, #4]	; (12e38 <ll_rx_link_alloc+0x8>)
   12e32:	f011 b8cc 	b.w	23fce <mem_acquire>
   12e36:	bf00      	nop
   12e38:	20000b60 	.word	0x20000b60

00012e3c <ll_rx_link_release>:
	mem_release(link, &mem_link_rx.free);
   12e3c:	4901      	ldr	r1, [pc, #4]	; (12e44 <ll_rx_link_release+0x8>)
   12e3e:	f011 b8d7 	b.w	23ff0 <mem_release>
   12e42:	bf00      	nop
   12e44:	20000b60 	.word	0x20000b60

00012e48 <ll_rx_alloc>:
	return mem_acquire(&mem_pdu_rx.free);
   12e48:	4801      	ldr	r0, [pc, #4]	; (12e50 <ll_rx_alloc+0x8>)
   12e4a:	f011 b8c0 	b.w	23fce <mem_acquire>
   12e4e:	bf00      	nop
   12e50:	20000bb4 	.word	0x20000bb4

00012e54 <ll_rx_release>:
	mem_release(node_rx, &mem_pdu_rx.free);
   12e54:	4901      	ldr	r1, [pc, #4]	; (12e5c <ll_rx_release+0x8>)
   12e56:	f011 b8cb 	b.w	23ff0 <mem_release>
   12e5a:	bf00      	nop
   12e5c:	20000bb4 	.word	0x20000bb4

00012e60 <ll_rx_put>:
	rx_hdr->ack_last = mfifo_tx_ack.l;
   12e60:	4b02      	ldr	r3, [pc, #8]	; (12e6c <ll_rx_put+0xc>)
	memq_enqueue(link, rx, &memq_ll_rx.tail);
   12e62:	4a03      	ldr	r2, [pc, #12]	; (12e70 <ll_rx_put+0x10>)
	rx_hdr->ack_last = mfifo_tx_ack.l;
   12e64:	78db      	ldrb	r3, [r3, #3]
   12e66:	700b      	strb	r3, [r1, #0]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
   12e68:	f011 b903 	b.w	24072 <memq_enqueue>
   12e6c:	2000e99c 	.word	0x2000e99c
   12e70:	20000e1c 	.word	0x20000e1c

00012e74 <ll_rx_sched>:
	k_sem_give(sem_recv);
   12e74:	4b01      	ldr	r3, [pc, #4]	; (12e7c <ll_rx_sched+0x8>)
   12e76:	6818      	ldr	r0, [r3, #0]
	z_impl_k_sem_give(sem);
   12e78:	f00b bf80 	b.w	1ed7c <z_impl_k_sem_give>
   12e7c:	20000e28 	.word	0x20000e28

00012e80 <ll_pdu_rx_alloc_peek>:
{
   12e80:	b510      	push	{r4, lr}
	if (count > MFIFO_AVAIL_COUNT_GET(ll_pdu_rx_free)) {
   12e82:	4a0a      	ldr	r2, [pc, #40]	; (12eac <ll_pdu_rx_alloc_peek+0x2c>)
   12e84:	7891      	ldrb	r1, [r2, #2]
   12e86:	78d4      	ldrb	r4, [r2, #3]
   12e88:	7853      	ldrb	r3, [r2, #1]
	if (last >= first) {
   12e8a:	42a1      	cmp	r1, r4
		return count - first + last;
   12e8c:	bf8a      	itet	hi
   12e8e:	1a5b      	subhi	r3, r3, r1
		return last - first;
   12e90:	1a63      	subls	r3, r4, r1
		return count - first + last;
   12e92:	191b      	addhi	r3, r3, r4
   12e94:	b2db      	uxtb	r3, r3
   12e96:	4298      	cmp	r0, r3
   12e98:	d806      	bhi.n	12ea8 <ll_pdu_rx_alloc_peek+0x28>
	if (first == last) {
   12e9a:	42a1      	cmp	r1, r4
	return MFIFO_DEQUEUE_PEEK(ll_pdu_rx_free);
   12e9c:	7813      	ldrb	r3, [r2, #0]
   12e9e:	d003      	beq.n	12ea8 <ll_pdu_rx_alloc_peek+0x28>
	return *((void **)(fifo + first * size));
   12ea0:	fb01 2203 	mla	r2, r1, r3, r2
   12ea4:	6850      	ldr	r0, [r2, #4]
}
   12ea6:	bd10      	pop	{r4, pc}
		return NULL;
   12ea8:	2000      	movs	r0, #0
   12eaa:	e7fc      	b.n	12ea6 <ll_pdu_rx_alloc_peek+0x26>
   12eac:	2000e84c 	.word	0x2000e84c

00012eb0 <ll_pdu_rx_alloc>:
{
   12eb0:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(ll_pdu_rx_free);
   12eb2:	4a09      	ldr	r2, [pc, #36]	; (12ed8 <ll_pdu_rx_alloc+0x28>)
 * @return              Head buffer; or NULL if queue was empty
 */
static inline void *mfifo_dequeue(u8_t *fifo, u8_t size, u8_t count,
				  u8_t last, u8_t *first)
{
	u8_t _first = *first; /* Copy read-index */
   12eb4:	7893      	ldrb	r3, [r2, #2]
	void *mem;

	/* Queue is empty if first == last */
	if (_first == last) {
   12eb6:	78d0      	ldrb	r0, [r2, #3]
   12eb8:	7811      	ldrb	r1, [r2, #0]
   12eba:	7854      	ldrb	r4, [r2, #1]
   12ebc:	4298      	cmp	r0, r3
   12ebe:	d009      	beq.n	12ed4 <ll_pdu_rx_alloc+0x24>
	}

	/* Obtain address of head buffer.
	 * API 2: fifo is array of void-ptrs
	 */
	mem = *((void **)(fifo + _first * size));
   12ec0:	fb03 2101 	mla	r1, r3, r1, r2

	/* Circular buffer increment read-index modulo 'count' */
	_first += 1U;
   12ec4:	3301      	adds	r3, #1
   12ec6:	b2db      	uxtb	r3, r3
	if (_first == count) {
		_first = 0U;
   12ec8:	429c      	cmp	r4, r3
   12eca:	bf08      	it	eq
   12ecc:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
   12ece:	6848      	ldr	r0, [r1, #4]
	}

	*first = _first; /* Write back read-index */
   12ed0:	7093      	strb	r3, [r2, #2]
}
   12ed2:	bd10      	pop	{r4, pc}
		return NULL;
   12ed4:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(ll_pdu_rx_free);
   12ed6:	e7fc      	b.n	12ed2 <ll_pdu_rx_alloc+0x22>
   12ed8:	2000e84c 	.word	0x2000e84c

00012edc <ll_tx_ack_put>:
{
   12edc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	idx = MFIFO_ENQUEUE_GET(tx_ack, (void **)&tx);
   12ede:	4a12      	ldr	r2, [pc, #72]	; (12f28 <ll_tx_ack_put+0x4c>)
   12ee0:	78d4      	ldrb	r4, [r2, #3]
	if (last == count) {
   12ee2:	7857      	ldrb	r7, [r2, #1]
   12ee4:	7895      	ldrb	r5, [r2, #2]
   12ee6:	7816      	ldrb	r6, [r2, #0]
	last = last + 1;
   12ee8:	1c63      	adds	r3, r4, #1
   12eea:	b2db      	uxtb	r3, r3
		last = 0U;
   12eec:	429f      	cmp	r7, r3
   12eee:	bf08      	it	eq
   12ef0:	2300      	moveq	r3, #0
	if (last == first) {
   12ef2:	429d      	cmp	r5, r3
   12ef4:	d004      	beq.n	12f00 <ll_tx_ack_put+0x24>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   12ef6:	1d15      	adds	r5, r2, #4
   12ef8:	fb14 f406 	smulbb	r4, r4, r6
	LL_ASSERT(tx);
   12efc:	192e      	adds	r6, r5, r4
   12efe:	d10f      	bne.n	12f20 <ll_tx_ack_put+0x44>
   12f00:	f240 33b3 	movw	r3, #947	; 0x3b3
   12f04:	4a09      	ldr	r2, [pc, #36]	; (12f2c <ll_tx_ack_put+0x50>)
   12f06:	490a      	ldr	r1, [pc, #40]	; (12f30 <ll_tx_ack_put+0x54>)
   12f08:	480a      	ldr	r0, [pc, #40]	; (12f34 <ll_tx_ack_put+0x58>)
   12f0a:	f00c ff52 	bl	1fdb2 <printk>
   12f0e:	4040      	eors	r0, r0
   12f10:	f380 8811 	msr	BASEPRI, r0
   12f14:	f04f 0003 	mov.w	r0, #3
   12f18:	df02      	svc	2
	tx->handle = handle;
   12f1a:	2300      	movs	r3, #0
   12f1c:	801b      	strh	r3, [r3, #0]
   12f1e:	deff      	udf	#255	; 0xff
   12f20:	5328      	strh	r0, [r5, r4]
	*last = idx; /* Commit: Update write index */
   12f22:	70d3      	strb	r3, [r2, #3]
	tx->node = node_tx;
   12f24:	6071      	str	r1, [r6, #4]
}
   12f26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   12f28:	2000e99c 	.word	0x2000e99c
   12f2c:	0006437c 	.word	0x0006437c
   12f30:	000647a4 	.word	0x000647a4
   12f34:	000632fe 	.word	0x000632fe

00012f38 <ll_radio_state_abort>:
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
   12f38:	2200      	movs	r2, #0
{
   12f3a:	b508      	push	{r3, lr}
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
   12f3c:	4611      	mov	r1, r2
   12f3e:	4b09      	ldr	r3, [pc, #36]	; (12f64 <ll_radio_state_abort+0x2c>)
   12f40:	2001      	movs	r0, #1
   12f42:	f7fd fb77 	bl	10634 <mayfly_enqueue>
	LL_ASSERT(!ret);
   12f46:	b160      	cbz	r0, 12f62 <ll_radio_state_abort+0x2a>
   12f48:	f240 33cb 	movw	r3, #971	; 0x3cb
   12f4c:	4a06      	ldr	r2, [pc, #24]	; (12f68 <ll_radio_state_abort+0x30>)
   12f4e:	4907      	ldr	r1, [pc, #28]	; (12f6c <ll_radio_state_abort+0x34>)
   12f50:	4807      	ldr	r0, [pc, #28]	; (12f70 <ll_radio_state_abort+0x38>)
   12f52:	f00c ff2e 	bl	1fdb2 <printk>
   12f56:	4040      	eors	r0, r0
   12f58:	f380 8811 	msr	BASEPRI, r0
   12f5c:	f04f 0003 	mov.w	r0, #3
   12f60:	df02      	svc	2
}
   12f62:	bd08      	pop	{r3, pc}
   12f64:	2000e9d0 	.word	0x2000e9d0
   12f68:	0006437c 	.word	0x0006437c
   12f6c:	00064330 	.word	0x00064330
   12f70:	000632fe 	.word	0x000632fe

00012f74 <ull_ticker_status_give>:
	*((u32_t volatile *)param) = status;
   12f74:	6008      	str	r0, [r1, #0]
   12f76:	4801      	ldr	r0, [pc, #4]	; (12f7c <ull_ticker_status_give+0x8>)
   12f78:	f00b bf00 	b.w	1ed7c <z_impl_k_sem_give>
   12f7c:	20000e2c 	.word	0x20000e2c

00012f80 <ull_ticker_status_take>:
{
   12f80:	b510      	push	{r4, lr}
   12f82:	460c      	mov	r4, r1
	return z_impl_k_sem_take(sem, timeout);
   12f84:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   12f88:	4802      	ldr	r0, [pc, #8]	; (12f94 <ull_ticker_status_take+0x14>)
   12f8a:	f00b ff23 	bl	1edd4 <z_impl_k_sem_take>
	return *ret_cb;
   12f8e:	6820      	ldr	r0, [r4, #0]
}
   12f90:	bd10      	pop	{r4, pc}
   12f92:	bf00      	nop
   12f94:	20000e2c 	.word	0x20000e2c

00012f98 <ull_disable_mark>:
	if (!*m) {
   12f98:	4b02      	ldr	r3, [pc, #8]	; (12fa4 <ull_disable_mark+0xc>)
   12f9a:	681a      	ldr	r2, [r3, #0]
   12f9c:	b902      	cbnz	r2, 12fa0 <ull_disable_mark+0x8>
		*m = param;
   12f9e:	6018      	str	r0, [r3, #0]
}
   12fa0:	6818      	ldr	r0, [r3, #0]
   12fa2:	4770      	bx	lr
   12fa4:	20000a8c 	.word	0x20000a8c

00012fa8 <ull_disable_unmark>:
	if (*m && *m == param) {
   12fa8:	4905      	ldr	r1, [pc, #20]	; (12fc0 <ull_disable_unmark+0x18>)
   12faa:	680b      	ldr	r3, [r1, #0]
   12fac:	b12b      	cbz	r3, 12fba <ull_disable_unmark+0x12>
   12fae:	4298      	cmp	r0, r3
   12fb0:	f04f 0200 	mov.w	r2, #0
		*m = NULL;
   12fb4:	bf0c      	ite	eq
   12fb6:	600a      	streq	r2, [r1, #0]
	return NULL;
   12fb8:	4613      	movne	r3, r2
}
   12fba:	4618      	mov	r0, r3
   12fbc:	4770      	bx	lr
   12fbe:	bf00      	nop
   12fc0:	20000a8c 	.word	0x20000a8c

00012fc4 <ull_disable_mark_get>:
}
   12fc4:	4b01      	ldr	r3, [pc, #4]	; (12fcc <ull_disable_mark_get+0x8>)
   12fc6:	6818      	ldr	r0, [r3, #0]
   12fc8:	4770      	bx	lr
   12fca:	bf00      	nop
   12fcc:	20000a8c 	.word	0x20000a8c

00012fd0 <ull_update_mark>:
	if (!*m) {
   12fd0:	4b02      	ldr	r3, [pc, #8]	; (12fdc <ull_update_mark+0xc>)
   12fd2:	681a      	ldr	r2, [r3, #0]
   12fd4:	b902      	cbnz	r2, 12fd8 <ull_update_mark+0x8>
		*m = param;
   12fd6:	6018      	str	r0, [r3, #0]
}
   12fd8:	6818      	ldr	r0, [r3, #0]
   12fda:	4770      	bx	lr
   12fdc:	20000a90 	.word	0x20000a90

00012fe0 <ull_update_unmark>:
	if (*m && *m == param) {
   12fe0:	4905      	ldr	r1, [pc, #20]	; (12ff8 <ull_update_unmark+0x18>)
   12fe2:	680b      	ldr	r3, [r1, #0]
   12fe4:	b12b      	cbz	r3, 12ff2 <ull_update_unmark+0x12>
   12fe6:	4298      	cmp	r0, r3
   12fe8:	f04f 0200 	mov.w	r2, #0
		*m = NULL;
   12fec:	bf0c      	ite	eq
   12fee:	600a      	streq	r2, [r1, #0]
	return NULL;
   12ff0:	4613      	movne	r3, r2
}
   12ff2:	4618      	mov	r0, r3
   12ff4:	4770      	bx	lr
   12ff6:	bf00      	nop
   12ff8:	20000a90 	.word	0x20000a90

00012ffc <ull_update_mark_get>:
}
   12ffc:	4b01      	ldr	r3, [pc, #4]	; (13004 <ull_update_mark_get+0x8>)
   12ffe:	6818      	ldr	r0, [r3, #0]
   13000:	4770      	bx	lr
   13002:	bf00      	nop
   13004:	20000a90 	.word	0x20000a90

00013008 <ull_disable>:
{
   13008:	b530      	push	{r4, r5, lr}
	hdr = HDR_ULL(((struct lll_hdr *)lll)->parent);
   1300a:	6804      	ldr	r4, [r0, #0]
	if (!hdr) {
   1300c:	f114 0f10 	cmn.w	r4, #16
{
   13010:	b087      	sub	sp, #28
   13012:	4605      	mov	r5, r0
	if (!hdr) {
   13014:	d102      	bne.n	1301c <ull_disable+0x14>
		return ULL_STATUS_SUCCESS;
   13016:	2000      	movs	r0, #0
}
   13018:	b007      	add	sp, #28
   1301a:	bd30      	pop	{r4, r5, pc}
	z_impl_k_sem_init(sem, initial_count, limit);
   1301c:	2201      	movs	r2, #1
   1301e:	2100      	movs	r1, #0
   13020:	4668      	mov	r0, sp
   13022:	f014 fef2 	bl	27e0a <z_impl_k_sem_init>
	hdr->disabled_cb = disabled_cb;
   13026:	4b11      	ldr	r3, [pc, #68]	; (1306c <ull_disable+0x64>)
   13028:	6163      	str	r3, [r4, #20]
	if (!hdr->ref) {
   1302a:	7c23      	ldrb	r3, [r4, #16]
	hdr->disabled_param = &sem;
   1302c:	f8c4 d018 	str.w	sp, [r4, #24]
	if (!hdr->ref) {
   13030:	2b00      	cmp	r3, #0
   13032:	d0f0      	beq.n	13016 <ull_disable+0xe>
	mfy.param = lll;
   13034:	4b0e      	ldr	r3, [pc, #56]	; (13070 <ull_disable+0x68>)
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
   13036:	2200      	movs	r2, #0
   13038:	4611      	mov	r1, r2
   1303a:	2003      	movs	r0, #3
	mfy.param = lll;
   1303c:	609d      	str	r5, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
   1303e:	f7fd faf9 	bl	10634 <mayfly_enqueue>
	LL_ASSERT(!ret);
   13042:	b160      	cbz	r0, 1305e <ull_disable+0x56>
   13044:	f240 431e 	movw	r3, #1054	; 0x41e
   13048:	4a0a      	ldr	r2, [pc, #40]	; (13074 <ull_disable+0x6c>)
   1304a:	490b      	ldr	r1, [pc, #44]	; (13078 <ull_disable+0x70>)
   1304c:	480b      	ldr	r0, [pc, #44]	; (1307c <ull_disable+0x74>)
   1304e:	f00c feb0 	bl	1fdb2 <printk>
   13052:	4040      	eors	r0, r0
   13054:	f380 8811 	msr	BASEPRI, r0
   13058:	f04f 0003 	mov.w	r0, #3
   1305c:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
   1305e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   13062:	4668      	mov	r0, sp
   13064:	f00b feb6 	bl	1edd4 <z_impl_k_sem_take>
	return k_sem_take(&sem, K_FOREVER);
   13068:	e7d6      	b.n	13018 <ull_disable+0x10>
   1306a:	bf00      	nop
   1306c:	00024407 	.word	0x00024407
   13070:	2000e9e0 	.word	0x2000e9e0
   13074:	0006437c 	.word	0x0006437c
   13078:	00064330 	.word	0x00064330
   1307c:	000632fe 	.word	0x000632fe

00013080 <ull_pdu_rx_alloc_peek>:
{
   13080:	b510      	push	{r4, lr}
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
   13082:	4a0a      	ldr	r2, [pc, #40]	; (130ac <ull_pdu_rx_alloc_peek+0x2c>)
   13084:	7891      	ldrb	r1, [r2, #2]
   13086:	78d4      	ldrb	r4, [r2, #3]
   13088:	7853      	ldrb	r3, [r2, #1]
	if (last >= first) {
   1308a:	42a1      	cmp	r1, r4
		return count - first + last;
   1308c:	bf8a      	itet	hi
   1308e:	1a5b      	subhi	r3, r3, r1
		return last - first;
   13090:	1a63      	subls	r3, r4, r1
		return count - first + last;
   13092:	191b      	addhi	r3, r3, r4
   13094:	b2db      	uxtb	r3, r3
   13096:	4298      	cmp	r0, r3
   13098:	d806      	bhi.n	130a8 <ull_pdu_rx_alloc_peek+0x28>
	if (first == last) {
   1309a:	42a1      	cmp	r1, r4
	return MFIFO_DEQUEUE_PEEK(pdu_rx_free);
   1309c:	7813      	ldrb	r3, [r2, #0]
   1309e:	d003      	beq.n	130a8 <ull_pdu_rx_alloc_peek+0x28>
	return *((void **)(fifo + first * size));
   130a0:	fb01 2203 	mla	r2, r1, r3, r2
   130a4:	6850      	ldr	r0, [r2, #4]
}
   130a6:	bd10      	pop	{r4, pc}
		return NULL;
   130a8:	2000      	movs	r0, #0
   130aa:	e7fc      	b.n	130a6 <ull_pdu_rx_alloc_peek+0x26>
   130ac:	2000e860 	.word	0x2000e860

000130b0 <ull_pdu_rx_alloc>:
{
   130b0:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(pdu_rx_free);
   130b2:	4a09      	ldr	r2, [pc, #36]	; (130d8 <ull_pdu_rx_alloc+0x28>)
	u8_t _first = *first; /* Copy read-index */
   130b4:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
   130b6:	78d0      	ldrb	r0, [r2, #3]
   130b8:	7811      	ldrb	r1, [r2, #0]
   130ba:	7854      	ldrb	r4, [r2, #1]
   130bc:	4298      	cmp	r0, r3
   130be:	d009      	beq.n	130d4 <ull_pdu_rx_alloc+0x24>
	mem = *((void **)(fifo + _first * size));
   130c0:	fb03 2101 	mla	r1, r3, r1, r2
	_first += 1U;
   130c4:	3301      	adds	r3, #1
   130c6:	b2db      	uxtb	r3, r3
		_first = 0U;
   130c8:	429c      	cmp	r4, r3
   130ca:	bf08      	it	eq
   130cc:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
   130ce:	6848      	ldr	r0, [r1, #4]
	*first = _first; /* Write back read-index */
   130d0:	7093      	strb	r3, [r2, #2]
}
   130d2:	bd10      	pop	{r4, pc}
		return NULL;
   130d4:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(pdu_rx_free);
   130d6:	e7fc      	b.n	130d2 <ull_pdu_rx_alloc+0x22>
   130d8:	2000e860 	.word	0x2000e860

000130dc <ull_rx_put>:
{
   130dc:	b538      	push	{r3, r4, r5, lr}
   130de:	460c      	mov	r4, r1
   130e0:	4605      	mov	r5, r0
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
   130e2:	f003 fcbd 	bl	16a60 <ull_conn_ack_last_idx_get>
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   130e6:	4621      	mov	r1, r4
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
   130e8:	7020      	strb	r0, [r4, #0]
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   130ea:	4a03      	ldr	r2, [pc, #12]	; (130f8 <ull_rx_put+0x1c>)
   130ec:	4628      	mov	r0, r5
}
   130ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   130f2:	f010 bfbe 	b.w	24072 <memq_enqueue>
   130f6:	bf00      	nop
   130f8:	20000e24 	.word	0x20000e24

000130fc <ull_rx_sched>:
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
   130fc:	2201      	movs	r2, #1
   130fe:	4b02      	ldr	r3, [pc, #8]	; (13108 <ull_rx_sched+0xc>)
   13100:	4611      	mov	r1, r2
   13102:	2000      	movs	r0, #0
   13104:	f7fd ba96 	b.w	10634 <mayfly_enqueue>
   13108:	2000e9f0 	.word	0x2000e9f0

0001310c <ull_prepare_enqueue>:
{
   1310c:	b5f0      	push	{r4, r5, r6, r7, lr}
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   1310e:	4d18      	ldr	r5, [pc, #96]	; (13170 <ull_prepare_enqueue+0x64>)
   13110:	78ef      	ldrb	r7, [r5, #3]
	if (last == count) {
   13112:	f895 e001 	ldrb.w	lr, [r5, #1]
   13116:	78ac      	ldrb	r4, [r5, #2]
   13118:	f895 c000 	ldrb.w	ip, [r5]
	last = last + 1;
   1311c:	1c7e      	adds	r6, r7, #1
   1311e:	b2f6      	uxtb	r6, r6
		last = 0U;
   13120:	45b6      	cmp	lr, r6
   13122:	bf08      	it	eq
   13124:	2600      	moveq	r6, #0
	if (last == first) {
   13126:	42b4      	cmp	r4, r6
   13128:	d01e      	beq.n	13168 <ull_prepare_enqueue+0x5c>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1312a:	1d2c      	adds	r4, r5, #4
   1312c:	fb07 440c 	mla	r4, r7, ip, r4
	if (!e) {
   13130:	b1d4      	cbz	r4, 13168 <ull_prepare_enqueue+0x5c>
   13132:	4627      	mov	r7, r4
   13134:	f102 0c10 	add.w	ip, r2, #16
   13138:	f852 eb04 	ldr.w	lr, [r2], #4
   1313c:	f847 eb04 	str.w	lr, [r7], #4
   13140:	4562      	cmp	r2, ip
   13142:	d1f9      	bne.n	13138 <ull_prepare_enqueue+0x2c>
	e->is_abort_cb = is_abort_cb;
   13144:	e9c4 3004 	strd	r3, r0, [r4, #16]
	e->prio = prio;
   13148:	9b05      	ldr	r3, [sp, #20]
   1314a:	61e3      	str	r3, [r4, #28]
	e->is_resume = is_resume;
   1314c:	f89d 2018 	ldrb.w	r2, [sp, #24]
   13150:	f894 3020 	ldrb.w	r3, [r4, #32]
	e->abort_cb = abort_cb;
   13154:	61a1      	str	r1, [r4, #24]
	e->is_resume = is_resume;
   13156:	f362 0300 	bfi	r3, r2, #0, #1
	e->is_aborted = 0U;
   1315a:	f36f 0341 	bfc	r3, #1, #1
   1315e:	f884 3020 	strb.w	r3, [r4, #32]
	*last = idx; /* Commit: Update write index */
   13162:	70ee      	strb	r6, [r5, #3]
	return 0;
   13164:	2000      	movs	r0, #0
}
   13166:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -ENOBUFS;
   13168:	f06f 0068 	mvn.w	r0, #104	; 0x68
   1316c:	e7fb      	b.n	13166 <ull_prepare_enqueue+0x5a>
   1316e:	bf00      	nop
   13170:	2000e878 	.word	0x2000e878

00013174 <ull_prepare_dequeue_get>:
	return MFIFO_DEQUEUE_GET(prep);
   13174:	4b05      	ldr	r3, [pc, #20]	; (1318c <ull_prepare_dequeue_get+0x18>)
   13176:	789a      	ldrb	r2, [r3, #2]
	if (first == last) {
   13178:	78d9      	ldrb	r1, [r3, #3]
   1317a:	7818      	ldrb	r0, [r3, #0]
   1317c:	4291      	cmp	r1, r2
	return (void *)(fifo + first * size);
   1317e:	bf1a      	itte	ne
   13180:	3304      	addne	r3, #4
   13182:	fb02 3000 	mlane	r0, r2, r0, r3
		return NULL;
   13186:	2000      	moveq	r0, #0
}
   13188:	4770      	bx	lr
   1318a:	bf00      	nop
   1318c:	2000e878 	.word	0x2000e878

00013190 <rx_demux>:
		}
}
#endif /* CONFIG_BT_CONN */

static void rx_demux(void *param)
{
   13190:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
					     TICKER_USER_ID_LLL, 0, &mfy);
			LL_ASSERT(!ret);
		}

		MFIFO_DEQUEUE(prep);
   13194:	4e8b      	ldr	r6, [pc, #556]	; (133c4 <rx_demux+0x234>)
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
   13196:	4c8c      	ldr	r4, [pc, #560]	; (133c8 <rx_demux+0x238>)
   13198:	aa01      	add	r2, sp, #4
   1319a:	e9d4 0100 	ldrd	r0, r1, [r4]
   1319e:	f010 ff6f 	bl	24080 <memq_peek>
		if (link) {
   131a2:	4605      	mov	r5, r0
   131a4:	2800      	cmp	r0, #0
   131a6:	f000 80ee 	beq.w	13386 <rx_demux+0x1f6>
			LL_ASSERT(rx);
   131aa:	9b01      	ldr	r3, [sp, #4]
   131ac:	b963      	cbnz	r3, 131c8 <rx_demux+0x38>
   131ae:	f240 53d6 	movw	r3, #1494	; 0x5d6
   131b2:	4a86      	ldr	r2, [pc, #536]	; (133cc <rx_demux+0x23c>)
   131b4:	4986      	ldr	r1, [pc, #536]	; (133d0 <rx_demux+0x240>)
   131b6:	4887      	ldr	r0, [pc, #540]	; (133d4 <rx_demux+0x244>)
   131b8:	f00c fdfb 	bl	1fdb2 <printk>
   131bc:	4040      	eors	r0, r0
   131be:	f380 8811 	msr	BASEPRI, r0
   131c2:	f04f 0003 	mov.w	r0, #3
   131c6:	df02      	svc	2
			link_tx = ull_conn_ack_by_last_peek(rx->ack_last,
   131c8:	9b01      	ldr	r3, [sp, #4]
   131ca:	aa02      	add	r2, sp, #8
   131cc:	f10d 0102 	add.w	r1, sp, #2
   131d0:	7818      	ldrb	r0, [r3, #0]
   131d2:	f003 fc63 	bl	16a9c <ull_conn_ack_by_last_peek>
			if (link_tx) {
   131d6:	9f01      	ldr	r7, [sp, #4]
   131d8:	4602      	mov	r2, r0
   131da:	b130      	cbz	r0, 131ea <rx_demux+0x5a>
				rx_demux_conn_tx_ack(rx->ack_last, handle,
   131dc:	9b02      	ldr	r3, [sp, #8]
   131de:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   131e2:	7838      	ldrb	r0, [r7, #0]
				rx_demux_conn_tx_ack(ack_last, handle,
   131e4:	f011 f911 	bl	2440a <rx_demux_conn_tx_ack>
   131e8:	e7d5      	b.n	13196 <rx_demux+0x6>
	switch (rx->type) {
   131ea:	793b      	ldrb	r3, [r7, #4]
   131ec:	9703      	str	r7, [sp, #12]
   131ee:	3b01      	subs	r3, #1
   131f0:	2b08      	cmp	r3, #8
   131f2:	f200 80ba 	bhi.w	1336a <rx_demux+0x1da>
   131f6:	e8df f003 	tbb	[pc, r3]
   131fa:	9c05      	.short	0x9c05
   131fc:	b8b8b8b8 	.word	0xb8b8b8b8
   13200:	92b8      	.short	0x92b8
   13202:	b1          	.byte	0xb1
   13203:	00          	.byte	0x00
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   13204:	6860      	ldr	r0, [r4, #4]
   13206:	4970      	ldr	r1, [pc, #448]	; (133c8 <rx_demux+0x238>)
   13208:	2200      	movs	r2, #0
   1320a:	f010 ff41 	bl	24090 <memq_dequeue>
		rx_demux_event_done(link, rx);
   1320e:	9f03      	ldr	r7, [sp, #12]
	switch (done->extra.type) {
   13210:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
	ull_hdr = done->param;
   13214:	6a3c      	ldr	r4, [r7, #32]
	switch (done->extra.type) {
   13216:	b123      	cbz	r3, 13222 <rx_demux+0x92>
   13218:	2b01      	cmp	r3, #1
   1321a:	d169      	bne.n	132f0 <rx_demux+0x160>
		ull_conn_done(done);
   1321c:	4638      	mov	r0, r7
   1321e:	f003 f9dd 	bl	165dc <ull_conn_done>
	if (!MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
   13222:	4a6d      	ldr	r2, [pc, #436]	; (133d8 <rx_demux+0x248>)
   13224:	78d1      	ldrb	r1, [r2, #3]
	if (last == count) {
   13226:	f892 c001 	ldrb.w	ip, [r2, #1]
   1322a:	7890      	ldrb	r0, [r2, #2]
	done->extra.type = 0U;
   1322c:	2300      	movs	r3, #0
   1322e:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	last = last + 1;
   13232:	1c4b      	adds	r3, r1, #1
   13234:	b2db      	uxtb	r3, r3
		last = 0U;
   13236:	459c      	cmp	ip, r3
   13238:	bf08      	it	eq
   1323a:	2300      	moveq	r3, #0
	if (last == first) {
   1323c:	4298      	cmp	r0, r3
   1323e:	f000 80b0 	beq.w	133a2 <rx_demux+0x212>
	done->hdr.link = link;
   13242:	603d      	str	r5, [r7, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   13244:	7810      	ldrb	r0, [r2, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   13246:	fb00 2101 	mla	r1, r0, r1, r2
   1324a:	604f      	str	r7, [r1, #4]
	*last = idx; /* Commit: Update write index */
   1324c:	70d3      	strb	r3, [r2, #3]
	next = ull_prepare_dequeue_get();
   1324e:	f7ff ff91 	bl	13174 <ull_prepare_dequeue_get>
			mfy.param = next;
   13252:	f8df 8188 	ldr.w	r8, [pc, #392]	; 133dc <rx_demux+0x24c>
	while (next) {
   13256:	b358      	cbz	r0, 132b0 <rx_demux+0x120>
		u8_t is_aborted = next->is_aborted;
   13258:	f890 5020 	ldrb.w	r5, [r0, #32]
   1325c:	f3c5 0740 	ubfx	r7, r5, #1, #1
		u8_t is_resume = next->is_resume;
   13260:	f005 0501 	and.w	r5, r5, #1
		if (!is_aborted) {
   13264:	b9af      	cbnz	r7, 13292 <rx_demux+0x102>
			mfy.param = next;
   13266:	f8c8 0008 	str.w	r0, [r8, #8]
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1326a:	4b5c      	ldr	r3, [pc, #368]	; (133dc <rx_demux+0x24c>)
   1326c:	463a      	mov	r2, r7
   1326e:	4639      	mov	r1, r7
   13270:	2001      	movs	r0, #1
   13272:	f7fd f9df 	bl	10634 <mayfly_enqueue>
			LL_ASSERT(!ret);
   13276:	b160      	cbz	r0, 13292 <rx_demux+0x102>
   13278:	f240 63a7 	movw	r3, #1703	; 0x6a7
   1327c:	4a53      	ldr	r2, [pc, #332]	; (133cc <rx_demux+0x23c>)
   1327e:	4958      	ldr	r1, [pc, #352]	; (133e0 <rx_demux+0x250>)
   13280:	4854      	ldr	r0, [pc, #336]	; (133d4 <rx_demux+0x244>)
   13282:	f00c fd96 	bl	1fdb2 <printk>
   13286:	4040      	eors	r0, r0
   13288:	f380 8811 	msr	BASEPRI, r0
   1328c:	f04f 0003 	mov.w	r0, #3
   13290:	df02      	svc	2
	u8_t _first = *first; /* Copy read-index */
   13292:	78b3      	ldrb	r3, [r6, #2]
	if (_first == last) {
   13294:	78f1      	ldrb	r1, [r6, #3]
		MFIFO_DEQUEUE(prep);
   13296:	7872      	ldrb	r2, [r6, #1]
   13298:	4299      	cmp	r1, r3
   1329a:	d005      	beq.n	132a8 <rx_demux+0x118>
	_first += 1U;
   1329c:	3301      	adds	r3, #1
   1329e:	b2db      	uxtb	r3, r3
		_first = 0U;
   132a0:	429a      	cmp	r2, r3
   132a2:	bf08      	it	eq
   132a4:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   132a6:	70b3      	strb	r3, [r6, #2]

		next = ull_prepare_dequeue_get();
   132a8:	f7ff ff64 	bl	13174 <ull_prepare_dequeue_get>

		if (!next || (!is_aborted && (!is_resume || next->is_resume))) {
   132ac:	2800      	cmp	r0, #0
   132ae:	d12d      	bne.n	1330c <rx_demux+0x17c>
			break;
		}
	}

	/* ull instance will resume, dont decrement ref */
	if (!ull_hdr) {
   132b0:	2c00      	cmp	r4, #0
   132b2:	f43f af70 	beq.w	13196 <rx_demux+0x6>
		return;
	}

	/* Decrement prepare reference */
	LL_ASSERT(ull_hdr->ref);
   132b6:	7823      	ldrb	r3, [r4, #0]
   132b8:	b963      	cbnz	r3, 132d4 <rx_demux+0x144>
   132ba:	f240 63b9 	movw	r3, #1721	; 0x6b9
   132be:	4a43      	ldr	r2, [pc, #268]	; (133cc <rx_demux+0x23c>)
   132c0:	4948      	ldr	r1, [pc, #288]	; (133e4 <rx_demux+0x254>)
   132c2:	4844      	ldr	r0, [pc, #272]	; (133d4 <rx_demux+0x244>)
   132c4:	f00c fd75 	bl	1fdb2 <printk>
   132c8:	4040      	eors	r0, r0
   132ca:	f380 8811 	msr	BASEPRI, r0
   132ce:	f04f 0003 	mov.w	r0, #3
   132d2:	df02      	svc	2
	return hdr->ref--;
   132d4:	7823      	ldrb	r3, [r4, #0]
   132d6:	3b01      	subs	r3, #1
   132d8:	b2db      	uxtb	r3, r3
   132da:	7023      	strb	r3, [r4, #0]
	ull_ref_dec(ull_hdr);

	/* If disable initiated, signal the semaphore */
	if (!ull_hdr->ref && ull_hdr->disabled_cb) {
   132dc:	2b00      	cmp	r3, #0
   132de:	f47f af5a 	bne.w	13196 <rx_demux+0x6>
   132e2:	6863      	ldr	r3, [r4, #4]
   132e4:	2b00      	cmp	r3, #0
   132e6:	f43f af56 	beq.w	13196 <rx_demux+0x6>
		ull_hdr->disabled_cb(ull_hdr->disabled_param);
   132ea:	68a0      	ldr	r0, [r4, #8]
   132ec:	4798      	blx	r3
			if (nack) {
   132ee:	e752      	b.n	13196 <rx_demux+0x6>
		LL_ASSERT(0);
   132f0:	f240 638f 	movw	r3, #1679	; 0x68f
   132f4:	4a35      	ldr	r2, [pc, #212]	; (133cc <rx_demux+0x23c>)
   132f6:	493c      	ldr	r1, [pc, #240]	; (133e8 <rx_demux+0x258>)
   132f8:	4836      	ldr	r0, [pc, #216]	; (133d4 <rx_demux+0x244>)
   132fa:	f00c fd5a 	bl	1fdb2 <printk>
   132fe:	4040      	eors	r0, r0
   13300:	f380 8811 	msr	BASEPRI, r0
   13304:	f04f 0003 	mov.w	r0, #3
   13308:	df02      	svc	2
		break;
   1330a:	e78a      	b.n	13222 <rx_demux+0x92>
		if (!next || (!is_aborted && (!is_resume || next->is_resume))) {
   1330c:	2f00      	cmp	r7, #0
   1330e:	d1a2      	bne.n	13256 <rx_demux+0xc6>
   13310:	2d00      	cmp	r5, #0
   13312:	d0cd      	beq.n	132b0 <rx_demux+0x120>
   13314:	f890 3020 	ldrb.w	r3, [r0, #32]
   13318:	07db      	lsls	r3, r3, #31
   1331a:	d4c9      	bmi.n	132b0 <rx_demux+0x120>
   1331c:	e79b      	b.n	13256 <rx_demux+0xc6>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   1331e:	2200      	movs	r2, #0
   13320:	4929      	ldr	r1, [pc, #164]	; (133c8 <rx_demux+0x238>)
   13322:	6860      	ldr	r0, [r4, #4]
   13324:	f010 feb4 	bl	24090 <memq_dequeue>
		ull_conn_setup(link, rx);
   13328:	9903      	ldr	r1, [sp, #12]
   1332a:	4628      	mov	r0, r5
   1332c:	f001 feb8 	bl	150a0 <ull_conn_setup>
			if (nack) {
   13330:	e731      	b.n	13196 <rx_demux+0x6>
		nack = ull_conn_rx(link, (void *)&rx);
   13332:	a903      	add	r1, sp, #12
   13334:	4628      	mov	r0, r5
   13336:	f001 fed5 	bl	150e4 <ull_conn_rx>
		if (nack) {
   1333a:	4602      	mov	r2, r0
   1333c:	2800      	cmp	r0, #0
   1333e:	d13e      	bne.n	133be <rx_demux+0x22e>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   13340:	4921      	ldr	r1, [pc, #132]	; (133c8 <rx_demux+0x238>)
   13342:	6860      	ldr	r0, [r4, #4]
   13344:	f010 fea4 	bl	24090 <memq_dequeue>
		if (rx) {
   13348:	9903      	ldr	r1, [sp, #12]
   1334a:	2900      	cmp	r1, #0
   1334c:	f43f af23 	beq.w	13196 <rx_demux+0x6>
		ll_rx_put(link, rx);
   13350:	4628      	mov	r0, r5
   13352:	f7ff fd85 	bl	12e60 <ll_rx_put>
		ll_rx_sched();
   13356:	f7ff fd8d 	bl	12e74 <ll_rx_sched>
			if (nack) {
   1335a:	e71c      	b.n	13196 <rx_demux+0x6>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   1335c:	491a      	ldr	r1, [pc, #104]	; (133c8 <rx_demux+0x238>)
   1335e:	6860      	ldr	r0, [r4, #4]
   13360:	2200      	movs	r2, #0
   13362:	f010 fe95 	bl	24090 <memq_dequeue>
		ll_rx_put(link, rx);
   13366:	9903      	ldr	r1, [sp, #12]
   13368:	e7f2      	b.n	13350 <rx_demux+0x1c0>
		LL_ASSERT(0);
   1336a:	f240 6367 	movw	r3, #1639	; 0x667
   1336e:	4a17      	ldr	r2, [pc, #92]	; (133cc <rx_demux+0x23c>)
   13370:	491d      	ldr	r1, [pc, #116]	; (133e8 <rx_demux+0x258>)
   13372:	4818      	ldr	r0, [pc, #96]	; (133d4 <rx_demux+0x244>)
   13374:	f00c fd1d 	bl	1fdb2 <printk>
   13378:	4040      	eors	r0, r0
   1337a:	f380 8811 	msr	BASEPRI, r0
   1337e:	f04f 0003 	mov.w	r0, #3
   13382:	df02      	svc	2
			if (nack) {
   13384:	e707      	b.n	13196 <rx_demux+0x6>
			link = ull_conn_ack_peek(&ack_last, &handle, &node_tx);
   13386:	aa03      	add	r2, sp, #12
   13388:	a902      	add	r1, sp, #8
   1338a:	f10d 0002 	add.w	r0, sp, #2
   1338e:	f003 fb6d 	bl	16a6c <ull_conn_ack_peek>
			if (link) {
   13392:	4602      	mov	r2, r0
   13394:	b198      	cbz	r0, 133be <rx_demux+0x22e>
				rx_demux_conn_tx_ack(ack_last, handle,
   13396:	9b03      	ldr	r3, [sp, #12]
   13398:	f8bd 1008 	ldrh.w	r1, [sp, #8]
   1339c:	f89d 0002 	ldrb.w	r0, [sp, #2]
   133a0:	e720      	b.n	131e4 <rx_demux+0x54>
	LL_ASSERT(release == done);
   133a2:	f240 6396 	movw	r3, #1686	; 0x696
   133a6:	4a09      	ldr	r2, [pc, #36]	; (133cc <rx_demux+0x23c>)
   133a8:	4910      	ldr	r1, [pc, #64]	; (133ec <rx_demux+0x25c>)
   133aa:	480a      	ldr	r0, [pc, #40]	; (133d4 <rx_demux+0x244>)
   133ac:	f00c fd01 	bl	1fdb2 <printk>
   133b0:	4040      	eors	r0, r0
   133b2:	f380 8811 	msr	BASEPRI, r0
   133b6:	f04f 0003 	mov.w	r0, #3
   133ba:	df02      	svc	2
   133bc:	e747      	b.n	1324e <rx_demux+0xbe>
}
   133be:	b004      	add	sp, #16
   133c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   133c4:	2000e878 	.word	0x2000e878
   133c8:	20000e20 	.word	0x20000e20
   133cc:	0006437c 	.word	0x0006437c
   133d0:	00064986 	.word	0x00064986
   133d4:	000632fe 	.word	0x000632fe
   133d8:	2000e838 	.word	0x2000e838
   133dc:	2000ea00 	.word	0x2000ea00
   133e0:	00064330 	.word	0x00064330
   133e4:	0006442b 	.word	0x0006442b
   133e8:	00065948 	.word	0x00065948
   133ec:	00064438 	.word	0x00064438

000133f0 <ull_prepare_dequeue_iter>:
{
   133f0:	b530      	push	{r4, r5, lr}
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
   133f2:	4b0c      	ldr	r3, [pc, #48]	; (13424 <ull_prepare_dequeue_iter+0x34>)
	if (*idx >= count) {
   133f4:	7801      	ldrb	r1, [r0, #0]
   133f6:	785c      	ldrb	r4, [r3, #1]
   133f8:	78dd      	ldrb	r5, [r3, #3]
   133fa:	781a      	ldrb	r2, [r3, #0]
   133fc:	42a1      	cmp	r1, r4
   133fe:	bf24      	itt	cs
   13400:	789b      	ldrbcs	r3, [r3, #2]
		*idx = first;
   13402:	7003      	strbcs	r3, [r0, #0]
	if (*idx == last) {
   13404:	7801      	ldrb	r1, [r0, #0]
   13406:	428d      	cmp	r5, r1
   13408:	d00a      	beq.n	13420 <ull_prepare_dequeue_iter+0x30>
	i = *idx + 1;
   1340a:	1c4b      	adds	r3, r1, #1
   1340c:	b2db      	uxtb	r3, r3
		i = 0U;
   1340e:	429c      	cmp	r4, r3
   13410:	bf08      	it	eq
   13412:	2300      	moveq	r3, #0
	p = (void *)(fifo + (*idx) * size);
   13414:	4c04      	ldr	r4, [pc, #16]	; (13428 <ull_prepare_dequeue_iter+0x38>)
	*idx = i;
   13416:	7003      	strb	r3, [r0, #0]
	p = (void *)(fifo + (*idx) * size);
   13418:	fb01 4202 	mla	r2, r1, r2, r4
}
   1341c:	4610      	mov	r0, r2
   1341e:	bd30      	pop	{r4, r5, pc}
		return NULL;
   13420:	2200      	movs	r2, #0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
   13422:	e7fb      	b.n	1341c <ull_prepare_dequeue_iter+0x2c>
   13424:	2000e878 	.word	0x2000e878
   13428:	2000e87c 	.word	0x2000e87c

0001342c <ull_event_done_extra_get>:
	evdone = MFIFO_DEQUEUE_PEEK(done);
   1342c:	4b06      	ldr	r3, [pc, #24]	; (13448 <ull_event_done_extra_get+0x1c>)
   1342e:	7899      	ldrb	r1, [r3, #2]
	if (first == last) {
   13430:	78d8      	ldrb	r0, [r3, #3]
   13432:	781a      	ldrb	r2, [r3, #0]
   13434:	4288      	cmp	r0, r1
   13436:	d005      	beq.n	13444 <ull_event_done_extra_get+0x18>
	return *((void **)(fifo + first * size));
   13438:	fb01 3302 	mla	r3, r1, r2, r3
   1343c:	6858      	ldr	r0, [r3, #4]
	if (!evdone) {
   1343e:	b110      	cbz	r0, 13446 <ull_event_done_extra_get+0x1a>
	return &evdone->extra;
   13440:	3024      	adds	r0, #36	; 0x24
   13442:	4770      	bx	lr
		return NULL;
   13444:	2000      	movs	r0, #0
}
   13446:	4770      	bx	lr
   13448:	2000e838 	.word	0x2000e838

0001344c <ull_event_done>:
{
   1344c:	b538      	push	{r3, r4, r5, lr}
	evdone = MFIFO_DEQUEUE(done);
   1344e:	4a10      	ldr	r2, [pc, #64]	; (13490 <ull_event_done+0x44>)
	u8_t _first = *first; /* Copy read-index */
   13450:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
   13452:	78d4      	ldrb	r4, [r2, #3]
   13454:	7811      	ldrb	r1, [r2, #0]
   13456:	7855      	ldrb	r5, [r2, #1]
   13458:	429c      	cmp	r4, r3
   1345a:	d017      	beq.n	1348c <ull_event_done+0x40>
	mem = *((void **)(fifo + _first * size));
   1345c:	fb03 2101 	mla	r1, r3, r1, r2
	_first += 1U;
   13460:	3301      	adds	r3, #1
	mem = *((void **)(fifo + _first * size));
   13462:	684c      	ldr	r4, [r1, #4]
	_first += 1U;
   13464:	b2db      	uxtb	r3, r3
		_first = 0U;
   13466:	429d      	cmp	r5, r3
   13468:	bf08      	it	eq
   1346a:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   1346c:	7093      	strb	r3, [r2, #2]
	if (!evdone) {
   1346e:	b15c      	cbz	r4, 13488 <ull_event_done+0x3c>
	link = evdone->hdr.link;
   13470:	6823      	ldr	r3, [r4, #0]
	evdone->param = param;
   13472:	6220      	str	r0, [r4, #32]
	evdone->hdr.link = NULL;
   13474:	2200      	movs	r2, #0
   13476:	6022      	str	r2, [r4, #0]
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
   13478:	2201      	movs	r2, #1
   1347a:	7122      	strb	r2, [r4, #4]
	ull_rx_put(link, evdone);
   1347c:	4621      	mov	r1, r4
   1347e:	4618      	mov	r0, r3
   13480:	f7ff fe2c 	bl	130dc <ull_rx_put>
	ull_rx_sched();
   13484:	f7ff fe3a 	bl	130fc <ull_rx_sched>
}
   13488:	4620      	mov	r0, r4
   1348a:	bd38      	pop	{r3, r4, r5, pc}
		return NULL;
   1348c:	2400      	movs	r4, #0
   1348e:	e7fb      	b.n	13488 <ull_event_done+0x3c>
   13490:	2000e838 	.word	0x2000e838

00013494 <lll_chan_sel_2>:
}

#if defined(CONFIG_BT_CTLR_CHAN_SEL_2)
u8_t lll_chan_sel_2(u16_t counter, u16_t chan_id, u8_t *chan_map,
		    u8_t chan_count)
{
   13494:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
/* Attribution:
 * http://graphics.stanford.edu/%7Eseander/bithacks.html#ReverseByteWith32Bits
 */
static u8_t chan_rev_8(u8_t b)
{
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   13498:	4f25      	ldr	r7, [pc, #148]	; (13530 <lll_chan_sel_2+0x9c>)
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   1349a:	4d26      	ldr	r5, [pc, #152]	; (13534 <lll_chan_sel_2+0xa0>)
static u16_t chan_prn(u16_t counter, u16_t chan_id)
{
	u8_t iterate;
	u16_t prn_e;

	prn_e = counter ^ chan_id;
   1349c:	4048      	eors	r0, r1
   1349e:	2403      	movs	r4, #3
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   134a0:	f640 0c02 	movw	ip, #2050	; 0x802
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   134a4:	f248 0620 	movw	r6, #32800	; 0x8020
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   134a8:	ea4f 2e10 	mov.w	lr, r0, lsr #8
   134ac:	fb0c f80e 	mul.w	r8, ip, lr
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   134b0:	fb06 fe0e 	mul.w	lr, r6, lr
   134b4:	ea0e 0e05 	and.w	lr, lr, r5
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   134b8:	ea08 0807 	and.w	r8, r8, r7
   134bc:	ea48 080e 	orr.w	r8, r8, lr
   134c0:	b2c0      	uxtb	r0, r0
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   134c2:	eb08 2e08 	add.w	lr, r8, r8, lsl #8
   134c6:	eb08 280e 	add.w	r8, r8, lr, lsl #8
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   134ca:	fb0c fe00 	mul.w	lr, ip, r0
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   134ce:	4370      	muls	r0, r6
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   134d0:	ea0e 0e07 	and.w	lr, lr, r7
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   134d4:	4028      	ands	r0, r5
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   134d6:	ea4e 0000 	orr.w	r0, lr, r0
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   134da:	eb00 2e00 	add.w	lr, r0, r0, lsl #8
   134de:	eb00 200e 	add.w	r0, r0, lr, lsl #8
   134e2:	ea4f 4818 	mov.w	r8, r8, lsr #16
	return (chan_rev_8((i >> 8) & 0xFF) << 8) | chan_rev_8(i & 0xFF);
   134e6:	f3c0 4007 	ubfx	r0, r0, #16, #8
   134ea:	ea40 2008 	orr.w	r0, r0, r8, lsl #8
	return ((u32_t)a * 17U + b) & 0xFFFF;
   134ee:	eb00 1000 	add.w	r0, r0, r0, lsl #4
   134f2:	3c01      	subs	r4, #1
   134f4:	4408      	add	r0, r1

	for (iterate = 0U; iterate < 3; iterate++) {
   134f6:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
	return ((u32_t)a * 17U + b) & 0xFFFF;
   134fa:	b280      	uxth	r0, r0
	for (iterate = 0U; iterate < 3; iterate++) {
   134fc:	d1d4      	bne.n	134a8 <lll_chan_sel_2+0x14>
	chan_next = prn_e % 37;
   134fe:	2425      	movs	r4, #37	; 0x25
		prn_e = chan_perm(prn_e);
		prn_e = chan_mam(prn_e, chan_id);
	}

	prn_e ^= chan_id;
   13500:	4041      	eors	r1, r0
	chan_next = prn_e % 37;
   13502:	fbb1 f0f4 	udiv	r0, r1, r4
   13506:	fb04 1010 	mls	r0, r4, r0, r1
   1350a:	b2c0      	uxtb	r0, r0
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
   1350c:	08c4      	lsrs	r4, r0, #3
   1350e:	f000 0507 	and.w	r5, r0, #7
   13512:	5d14      	ldrb	r4, [r2, r4]
   13514:	412c      	asrs	r4, r5
   13516:	07e4      	lsls	r4, r4, #31
   13518:	d407      	bmi.n	1352a <lll_chan_sel_2+0x96>
		chan_index = ((u32_t)chan_count * prn_e) >> 16;
   1351a:	4359      	muls	r1, r3
		chan_next = chan_sel_remap(chan_map, chan_index);
   1351c:	f3c1 4107 	ubfx	r1, r1, #16, #8
   13520:	4610      	mov	r0, r2
}
   13522:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		chan_next = chan_sel_remap(chan_map, chan_index);
   13526:	f010 bf9c 	b.w	24462 <chan_sel_remap>
}
   1352a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1352e:	bf00      	nop
   13530:	00022110 	.word	0x00022110
   13534:	00088440 	.word	0x00088440

00013538 <rtc0_nrf5_isr>:
	DEBUG_RADIO_ISR(0);
	return 1;
}

static void rtc0_nrf5_isr(void *arg)
{
   13538:	b508      	push	{r3, lr}
	DEBUG_TICKER_ISR(1);

	/* On compare0 run ticker worker instance0 */
	if (NRF_RTC0->EVENTS_COMPARE[0]) {
   1353a:	4b08      	ldr	r3, [pc, #32]	; (1355c <rtc0_nrf5_isr+0x24>)
   1353c:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
   13540:	b122      	cbz	r2, 1354c <rtc0_nrf5_isr+0x14>
		NRF_RTC0->EVENTS_COMPARE[0] = 0;
   13542:	2000      	movs	r0, #0
   13544:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140

		ticker_trigger(0);
   13548:	f7fd fce0 	bl	10f0c <ticker_trigger>
	}

	mayfly_run(TICKER_USER_ID_ULL_HIGH);
   1354c:	2001      	movs	r0, #1
   1354e:	f7fd f8c1 	bl	106d4 <mayfly_run>

#if !defined(CONFIG_BT_CTLR_LOW_LAT) && \
	(CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	mayfly_run(TICKER_USER_ID_ULL_LOW);
   13552:	2002      	movs	r0, #2
#endif

	DEBUG_TICKER_ISR(0);
}
   13554:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	mayfly_run(TICKER_USER_ID_ULL_LOW);
   13558:	f7fd b8bc 	b.w	106d4 <mayfly_run>
   1355c:	4000b000 	.word	0x4000b000

00013560 <prepare>:
}

static int prepare(lll_is_abort_cb_t is_abort_cb, lll_abort_cb_t abort_cb,
		   lll_prepare_cb_t prepare_cb, int prio,
		   struct lll_prepare_param *prepare_param, u8_t is_resume)
{
   13560:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   13564:	b08d      	sub	sp, #52	; 0x34
   13566:	4699      	mov	r9, r3
   13568:	9d14      	ldr	r5, [sp, #80]	; 0x50
   1356a:	f89d 4054 	ldrb.w	r4, [sp, #84]	; 0x54
	u8_t idx = UINT8_MAX;
   1356e:	23ff      	movs	r3, #255	; 0xff
{
   13570:	4680      	mov	r8, r0
   13572:	460f      	mov	r7, r1
   13574:	4616      	mov	r6, r2
	u8_t idx = UINT8_MAX;
   13576:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
	int ret, err;

	/* Find the ready prepare in the pipeline */
	p = ull_prepare_dequeue_iter(&idx);
	while (p && (p->is_aborted || p->is_resume)) {
		p = ull_prepare_dequeue_iter(&idx);
   1357a:	f10d 002f 	add.w	r0, sp, #47	; 0x2f
   1357e:	f7ff ff37 	bl	133f0 <ull_prepare_dequeue_iter>
	while (p && (p->is_aborted || p->is_resume)) {
   13582:	b118      	cbz	r0, 1358c <prepare+0x2c>
   13584:	f890 3020 	ldrb.w	r3, [r0, #32]
   13588:	079b      	lsls	r3, r3, #30
   1358a:	d1f6      	bne.n	1357a <prepare+0x1a>
	}

	/* Current event active or another prepare is ready in the pipeline */
	if (event.curr.abort_cb || (p && is_resume)) {
   1358c:	4b36      	ldr	r3, [pc, #216]	; (13668 <prepare+0x108>)
   1358e:	689a      	ldr	r2, [r3, #8]
   13590:	b91a      	cbnz	r2, 1359a <prepare+0x3a>
   13592:	2800      	cmp	r0, #0
   13594:	d04a      	beq.n	1362c <prepare+0xcc>
   13596:	2c00      	cmp	r4, #0
   13598:	d048      	beq.n	1362c <prepare+0xcc>
			/* early abort */
			event.curr.abort_cb(NULL, event.curr.param);
		}

		/* Store the next prepare for deferred call */
		ret = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
   1359a:	e9cd 9400 	strd	r9, r4, [sp]
   1359e:	4633      	mov	r3, r6
   135a0:	462a      	mov	r2, r5
   135a2:	4639      	mov	r1, r7
   135a4:	4640      	mov	r0, r8
   135a6:	f7ff fdb1 	bl	1310c <ull_prepare_enqueue>
					  prepare_cb, prio, is_resume);
		LL_ASSERT(!ret);
   135aa:	b160      	cbz	r0, 135c6 <prepare+0x66>
   135ac:	f240 13e5 	movw	r3, #485	; 0x1e5
   135b0:	4a2e      	ldr	r2, [pc, #184]	; (1366c <prepare+0x10c>)
   135b2:	492f      	ldr	r1, [pc, #188]	; (13670 <prepare+0x110>)
   135b4:	482f      	ldr	r0, [pc, #188]	; (13674 <prepare+0x114>)
   135b6:	f00c fbfc 	bl	1fdb2 <printk>
   135ba:	4040      	eors	r0, r0
   135bc:	f380 8811 	msr	BASEPRI, r0
   135c0:	f04f 0003 	mov.w	r0, #3
   135c4:	df02      	svc	2

#if !defined(CONFIG_BT_CTLR_LOW_LAT)
		if (is_resume) {
   135c6:	b12c      	cbz	r4, 135d4 <prepare+0x74>
				LL_ASSERT(ret == -ECANCELED);
			}
		}
#endif /* CONFIG_BT_CTLR_LOW_LAT */

		return -EINPROGRESS;
   135c8:	f06f 0476 	mvn.w	r4, #118	; 0x76
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
		  (ret == TICKER_STATUS_FAILURE) ||
		  (ret == TICKER_STATUS_BUSY));

	return err;
}
   135cc:	4620      	mov	r0, r4
   135ce:	b00d      	add	sp, #52	; 0x34
   135d0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		evt = HDR_LLL2EVT(prepare_param->param);
   135d4:	68eb      	ldr	r3, [r5, #12]
   135d6:	681a      	ldr	r2, [r3, #0]
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   135d8:	4b27      	ldr	r3, [pc, #156]	; (13678 <prepare+0x118>)
   135da:	9408      	str	r4, [sp, #32]
   135dc:	e9cd 4306 	strd	r4, r3, [sp, #24]
   135e0:	4b26      	ldr	r3, [pc, #152]	; (1367c <prepare+0x11c>)
   135e2:	9401      	str	r4, [sp, #4]
   135e4:	e9cd 4304 	strd	r4, r3, [sp, #16]
   135e8:	e9cd 4402 	strd	r4, r4, [sp, #8]
		preempt_to = MAX(evt->ticks_active_to_start,
   135ec:	e9d2 0100 	ldrd	r0, r1, [r2]
   135f0:	6893      	ldr	r3, [r2, #8]
   135f2:	4288      	cmp	r0, r1
   135f4:	bf2c      	ite	cs
   135f6:	ebc3 0300 	rsbcs	r3, r3, r0
   135fa:	ebc3 0301 	rsbcc	r3, r3, r1
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   135fe:	9300      	str	r3, [sp, #0]
   13600:	682b      	ldr	r3, [r5, #0]
   13602:	4622      	mov	r2, r4
   13604:	4621      	mov	r1, r4
   13606:	4620      	mov	r0, r4
   13608:	f7fd fc92 	bl	10f30 <ticker_start>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1360c:	2802      	cmp	r0, #2
   1360e:	d9db      	bls.n	135c8 <prepare+0x68>
   13610:	f240 2301 	movw	r3, #513	; 0x201
   13614:	4a15      	ldr	r2, [pc, #84]	; (1366c <prepare+0x10c>)
   13616:	491a      	ldr	r1, [pc, #104]	; (13680 <prepare+0x120>)
   13618:	4816      	ldr	r0, [pc, #88]	; (13674 <prepare+0x114>)
   1361a:	f00c fbca 	bl	1fdb2 <printk>
   1361e:	4040      	eors	r0, r0
   13620:	f380 8811 	msr	BASEPRI, r0
   13624:	f04f 0003 	mov.w	r0, #3
   13628:	df02      	svc	2
   1362a:	e7cd      	b.n	135c8 <prepare+0x68>
	event.curr.param = prepare_param->param;
   1362c:	68ea      	ldr	r2, [r5, #12]
	event.curr.abort_cb = abort_cb;
   1362e:	609f      	str	r7, [r3, #8]
	event.curr.is_abort_cb = is_abort_cb;
   13630:	e9c3 2800 	strd	r2, r8, [r3]
	err = prepare_cb(prepare_param);
   13634:	4628      	mov	r0, r5
   13636:	47b0      	blx	r6
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
   13638:	2300      	movs	r3, #0
	err = prepare_cb(prepare_param);
   1363a:	4604      	mov	r4, r0
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
   1363c:	9300      	str	r3, [sp, #0]
   1363e:	461a      	mov	r2, r3
   13640:	4619      	mov	r1, r3
   13642:	4618      	mov	r0, r3
   13644:	f7fd fd06 	bl	11054 <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   13648:	2802      	cmp	r0, #2
   1364a:	d9bf      	bls.n	135cc <prepare+0x6c>
   1364c:	f240 2331 	movw	r3, #561	; 0x231
   13650:	4a06      	ldr	r2, [pc, #24]	; (1366c <prepare+0x10c>)
   13652:	490b      	ldr	r1, [pc, #44]	; (13680 <prepare+0x120>)
   13654:	4807      	ldr	r0, [pc, #28]	; (13674 <prepare+0x114>)
   13656:	f00c fbac 	bl	1fdb2 <printk>
   1365a:	4040      	eors	r0, r0
   1365c:	f380 8811 	msr	BASEPRI, r0
   13660:	f04f 0003 	mov.w	r0, #3
   13664:	df02      	svc	2
   13666:	e7b1      	b.n	135cc <prepare+0x6c>
   13668:	20001184 	.word	0x20001184
   1366c:	000644b6 	.word	0x000644b6
   13670:	00064330 	.word	0x00064330
   13674:	000632fe 	.word	0x000632fe
   13678:	00013789 	.word	0x00013789
   1367c:	000137b9 	.word	0x000137b9
   13680:	000644f5 	.word	0x000644f5

00013684 <preempt>:
			     0, &mfy);
	LL_ASSERT(!ret);
}

static void preempt(void *param)
{
   13684:	b5f0      	push	{r4, r5, r6, r7, lr}
   13686:	b08b      	sub	sp, #44	; 0x2c
	struct lll_event *next = ull_prepare_dequeue_get();
   13688:	f7ff fd74 	bl	13174 <ull_prepare_dequeue_get>
	lll_prepare_cb_t resume_cb;
	u8_t idx = UINT8_MAX;
   1368c:	23ff      	movs	r3, #255	; 0xff
	int resume_prio;
	int ret;

	next = ull_prepare_dequeue_iter(&idx);
   1368e:	f10d 000e 	add.w	r0, sp, #14
	u8_t idx = UINT8_MAX;
   13692:	f88d 300e 	strb.w	r3, [sp, #14]
	next = ull_prepare_dequeue_iter(&idx);
   13696:	f7ff feab 	bl	133f0 <ull_prepare_dequeue_iter>
	if (!next || !event.curr.abort_cb || !event.curr.param) {
   1369a:	4605      	mov	r5, r0
   1369c:	b120      	cbz	r0, 136a8 <preempt+0x24>
   1369e:	4c35      	ldr	r4, [pc, #212]	; (13774 <preempt+0xf0>)
   136a0:	68a3      	ldr	r3, [r4, #8]
   136a2:	b10b      	cbz	r3, 136a8 <preempt+0x24>
   136a4:	6823      	ldr	r3, [r4, #0]
   136a6:	b943      	cbnz	r3, 136ba <preempt+0x36>
		ret = resume_enqueue(resume_cb, resume_prio);
		LL_ASSERT(!ret);
	} else {
		LL_ASSERT(ret == -ECANCELED);
	}
}
   136a8:	b00b      	add	sp, #44	; 0x2c
   136aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next = ull_prepare_dequeue_iter(&idx);
   136ac:	f10d 000e 	add.w	r0, sp, #14
   136b0:	f7ff fe9e 	bl	133f0 <ull_prepare_dequeue_iter>
	while (next && (next->is_aborted || next->is_resume)) {
   136b4:	4605      	mov	r5, r0
   136b6:	2800      	cmp	r0, #0
   136b8:	d0f6      	beq.n	136a8 <preempt+0x24>
   136ba:	f895 0020 	ldrb.w	r0, [r5, #32]
   136be:	f010 0603 	ands.w	r6, r0, #3
   136c2:	d1f3      	bne.n	136ac <preempt+0x28>
	ret = event.curr.is_abort_cb(next->prepare_param.param, next->prio,
   136c4:	ab05      	add	r3, sp, #20
   136c6:	9300      	str	r3, [sp, #0]
   136c8:	6867      	ldr	r7, [r4, #4]
   136ca:	6822      	ldr	r2, [r4, #0]
   136cc:	69e9      	ldr	r1, [r5, #28]
   136ce:	68e8      	ldr	r0, [r5, #12]
   136d0:	ab04      	add	r3, sp, #16
   136d2:	47b8      	blx	r7
	if (!ret) {
   136d4:	4607      	mov	r7, r0
   136d6:	b950      	cbnz	r0, 136ee <preempt+0x6a>
		next->is_aborted = 1;
   136d8:	f895 3020 	ldrb.w	r3, [r5, #32]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
   136dc:	68e9      	ldr	r1, [r5, #12]
		next->is_aborted = 1;
   136de:	f043 0302 	orr.w	r3, r3, #2
   136e2:	f885 3020 	strb.w	r3, [r5, #32]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
   136e6:	4628      	mov	r0, r5
   136e8:	69ab      	ldr	r3, [r5, #24]
   136ea:	4798      	blx	r3
		return;
   136ec:	e7dc      	b.n	136a8 <preempt+0x24>
	event.curr.abort_cb(NULL, event.curr.param);
   136ee:	68a3      	ldr	r3, [r4, #8]
   136f0:	6821      	ldr	r1, [r4, #0]
   136f2:	4630      	mov	r0, r6
   136f4:	4798      	blx	r3
	if (ret == -EAGAIN) {
   136f6:	f117 0f0b 	cmn.w	r7, #11
   136fa:	d133      	bne.n	13764 <preempt+0xe0>
		u8_t idx = UINT8_MAX;
   136fc:	23ff      	movs	r3, #255	; 0xff
   136fe:	f88d 300f 	strb.w	r3, [sp, #15]
			iter = ull_prepare_dequeue_iter(&idx);
   13702:	f10d 000f 	add.w	r0, sp, #15
   13706:	f7ff fe73 	bl	133f0 <ull_prepare_dequeue_iter>
		while (iter) {
   1370a:	b9e0      	cbnz	r0, 13746 <preempt+0xc2>
	prepare_param.param = event.curr.param;
   1370c:	6823      	ldr	r3, [r4, #0]
   1370e:	9309      	str	r3, [sp, #36]	; 0x24
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
   13710:	2301      	movs	r3, #1
   13712:	9301      	str	r3, [sp, #4]
   13714:	9b05      	ldr	r3, [sp, #20]
	event.curr.param = NULL;
   13716:	6020      	str	r0, [r4, #0]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
   13718:	9300      	str	r3, [sp, #0]
   1371a:	aa06      	add	r2, sp, #24
   1371c:	9b04      	ldr	r3, [sp, #16]
   1371e:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
   13722:	f7ff fcf3 	bl	1310c <ull_prepare_enqueue>
		LL_ASSERT(!ret);
   13726:	2800      	cmp	r0, #0
   13728:	d0be      	beq.n	136a8 <preempt+0x24>
   1372a:	4a13      	ldr	r2, [pc, #76]	; (13778 <preempt+0xf4>)
   1372c:	4913      	ldr	r1, [pc, #76]	; (1377c <preempt+0xf8>)
   1372e:	f44f 7323 	mov.w	r3, #652	; 0x28c
		LL_ASSERT(ret == -ECANCELED);
   13732:	4813      	ldr	r0, [pc, #76]	; (13780 <preempt+0xfc>)
   13734:	f00c fb3d 	bl	1fdb2 <printk>
   13738:	4040      	eors	r0, r0
   1373a:	f380 8811 	msr	BASEPRI, r0
   1373e:	f04f 0003 	mov.w	r0, #3
   13742:	df02      	svc	2
   13744:	e7b0      	b.n	136a8 <preempt+0x24>
			if (!iter->is_aborted &&
   13746:	f890 3020 	ldrb.w	r3, [r0, #32]
   1374a:	079a      	lsls	r2, r3, #30
   1374c:	d4d9      	bmi.n	13702 <preempt+0x7e>
			    event.curr.param == iter->prepare_param.param) {
   1374e:	68c2      	ldr	r2, [r0, #12]
			if (!iter->is_aborted &&
   13750:	6821      	ldr	r1, [r4, #0]
   13752:	4291      	cmp	r1, r2
   13754:	d1d5      	bne.n	13702 <preempt+0x7e>
				iter->is_aborted = 1;
   13756:	f043 0302 	orr.w	r3, r3, #2
   1375a:	f880 3020 	strb.w	r3, [r0, #32]
				iter->abort_cb(&iter->prepare_param,
   1375e:	6983      	ldr	r3, [r0, #24]
   13760:	4798      	blx	r3
   13762:	e7ce      	b.n	13702 <preempt+0x7e>
		LL_ASSERT(ret == -ECANCELED);
   13764:	378c      	adds	r7, #140	; 0x8c
   13766:	d09f      	beq.n	136a8 <preempt+0x24>
   13768:	f240 238e 	movw	r3, #654	; 0x28e
   1376c:	4a02      	ldr	r2, [pc, #8]	; (13778 <preempt+0xf4>)
   1376e:	4905      	ldr	r1, [pc, #20]	; (13784 <preempt+0x100>)
   13770:	e7df      	b.n	13732 <preempt+0xae>
   13772:	bf00      	nop
   13774:	20001184 	.word	0x20001184
   13778:	000644b6 	.word	0x000644b6
   1377c:	00064330 	.word	0x00064330
   13780:	000632fe 	.word	0x000632fe
   13784:	000644aa 	.word	0x000644aa

00013788 <ticker_start_op_cb>:
	LL_ASSERT((status == TICKER_STATUS_SUCCESS) ||
   13788:	2801      	cmp	r0, #1
{
   1378a:	b508      	push	{r3, lr}
	LL_ASSERT((status == TICKER_STATUS_SUCCESS) ||
   1378c:	d90c      	bls.n	137a8 <ticker_start_op_cb+0x20>
   1378e:	f240 234a 	movw	r3, #586	; 0x24a
   13792:	4a06      	ldr	r2, [pc, #24]	; (137ac <ticker_start_op_cb+0x24>)
   13794:	4906      	ldr	r1, [pc, #24]	; (137b0 <ticker_start_op_cb+0x28>)
   13796:	4807      	ldr	r0, [pc, #28]	; (137b4 <ticker_start_op_cb+0x2c>)
   13798:	f00c fb0b 	bl	1fdb2 <printk>
   1379c:	4040      	eors	r0, r0
   1379e:	f380 8811 	msr	BASEPRI, r0
   137a2:	f04f 0003 	mov.w	r0, #3
   137a6:	df02      	svc	2
}
   137a8:	bd08      	pop	{r3, pc}
   137aa:	bf00      	nop
   137ac:	000644b6 	.word	0x000644b6
   137b0:	00064528 	.word	0x00064528
   137b4:	000632fe 	.word	0x000632fe

000137b8 <preempt_ticker_cb>:
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   137b8:	2200      	movs	r2, #0
{
   137ba:	b508      	push	{r3, lr}
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   137bc:	4611      	mov	r1, r2
   137be:	4b09      	ldr	r3, [pc, #36]	; (137e4 <preempt_ticker_cb+0x2c>)
   137c0:	2001      	movs	r0, #1
   137c2:	f7fc ff37 	bl	10634 <mayfly_enqueue>
	LL_ASSERT(!ret);
   137c6:	b160      	cbz	r0, 137e2 <preempt_ticker_cb+0x2a>
   137c8:	f240 2356 	movw	r3, #598	; 0x256
   137cc:	4a06      	ldr	r2, [pc, #24]	; (137e8 <preempt_ticker_cb+0x30>)
   137ce:	4907      	ldr	r1, [pc, #28]	; (137ec <preempt_ticker_cb+0x34>)
   137d0:	4807      	ldr	r0, [pc, #28]	; (137f0 <preempt_ticker_cb+0x38>)
   137d2:	f00c faee 	bl	1fdb2 <printk>
   137d6:	4040      	eors	r0, r0
   137d8:	f380 8811 	msr	BASEPRI, r0
   137dc:	f04f 0003 	mov.w	r0, #3
   137e0:	df02      	svc	2
}
   137e2:	bd08      	pop	{r3, pc}
   137e4:	2000ea10 	.word	0x2000ea10
   137e8:	000644b6 	.word	0x000644b6
   137ec:	00064330 	.word	0x00064330
   137f0:	000632fe 	.word	0x000632fe

000137f4 <lll_init>:
{
   137f4:	b538      	push	{r3, r4, r5, lr}
   137f6:	4818      	ldr	r0, [pc, #96]	; (13858 <lll_init+0x64>)
   137f8:	f00a fc12 	bl	1e020 <z_impl_device_get_binding>
	dev_entropy = device_get_binding(CONFIG_ENTROPY_NAME);
   137fc:	4b17      	ldr	r3, [pc, #92]	; (1385c <lll_init+0x68>)
   137fe:	6018      	str	r0, [r3, #0]
	if (!dev_entropy) {
   13800:	b910      	cbnz	r0, 13808 <lll_init+0x14>
		return -ENODEV;
   13802:	f06f 0012 	mvn.w	r0, #18
}
   13806:	bd38      	pop	{r3, r4, r5, pc}
	event.curr.abort_cb = NULL;
   13808:	4b15      	ldr	r3, [pc, #84]	; (13860 <lll_init+0x6c>)
   1380a:	2400      	movs	r4, #0
   1380c:	609c      	str	r4, [r3, #8]
   1380e:	4815      	ldr	r0, [pc, #84]	; (13864 <lll_init+0x70>)
   13810:	f00a fc06 	bl	1e020 <z_impl_device_get_binding>
	if (!clk) {
   13814:	4605      	mov	r5, r0
   13816:	2800      	cmp	r0, #0
   13818:	d0f3      	beq.n	13802 <lll_init+0xe>
	clock_control_on(clk, CLOCK_CONTROL_NRF_SUBSYS_LF);
   1381a:	2101      	movs	r1, #1
   1381c:	f010 fe5c 	bl	244d8 <clock_control_on>
	lll.clk = clk;
   13820:	4b11      	ldr	r3, [pc, #68]	; (13868 <lll_init+0x74>)
	IRQ_DIRECT_CONNECT(RADIO_IRQn, CONFIG_BT_CTLR_LLL_PRIO,
   13822:	4622      	mov	r2, r4
   13824:	4621      	mov	r1, r4
   13826:	2001      	movs	r0, #1
	lll.clk = clk;
   13828:	601d      	str	r5, [r3, #0]
	IRQ_DIRECT_CONNECT(RADIO_IRQn, CONFIG_BT_CTLR_LLL_PRIO,
   1382a:	f7f3 f99b 	bl	6b64 <z_arm_irq_priority_set>
	IRQ_CONNECT(RTC0_IRQn, CONFIG_BT_CTLR_ULL_HIGH_PRIO,
   1382e:	4622      	mov	r2, r4
   13830:	4621      	mov	r1, r4
   13832:	200b      	movs	r0, #11
   13834:	f7f3 f996 	bl	6b64 <z_arm_irq_priority_set>
	IRQ_CONNECT(HAL_SWI_RADIO_IRQ, CONFIG_BT_CTLR_LLL_PRIO,
   13838:	4622      	mov	r2, r4
   1383a:	4621      	mov	r1, r4
   1383c:	2018      	movs	r0, #24
   1383e:	f7f3 f991 	bl	6b64 <z_arm_irq_priority_set>
	irq_enable(RADIO_IRQn);
   13842:	2001      	movs	r0, #1
   13844:	f7f3 f95c 	bl	6b00 <arch_irq_enable>
	irq_enable(RTC0_IRQn);
   13848:	200b      	movs	r0, #11
   1384a:	f7f3 f959 	bl	6b00 <arch_irq_enable>
	irq_enable(HAL_SWI_RADIO_IRQ);
   1384e:	2018      	movs	r0, #24
   13850:	f7f3 f956 	bl	6b00 <arch_irq_enable>
	return 0;
   13854:	4620      	mov	r0, r4
   13856:	e7d6      	b.n	13806 <lll_init+0x12>
   13858:	00064317 	.word	0x00064317
   1385c:	20001180 	.word	0x20001180
   13860:	20001184 	.word	0x20001184
   13864:	0006233c 	.word	0x0006233c
   13868:	20001198 	.word	0x20001198

0001386c <lll_entropy_get>:
{
   1386c:	b538      	push	{r3, r4, r5, lr}
	return entropy_get_entropy_isr(dev_entropy, rand, len, 0);
   1386e:	4b07      	ldr	r3, [pc, #28]	; (1388c <lll_entropy_get+0x20>)
   13870:	681d      	ldr	r5, [r3, #0]
	if (unlikely(!api->get_entropy_isr)) {
   13872:	686b      	ldr	r3, [r5, #4]
   13874:	685c      	ldr	r4, [r3, #4]
   13876:	4602      	mov	r2, r0
   13878:	b124      	cbz	r4, 13884 <lll_entropy_get+0x18>
	return api->get_entropy_isr(dev, buffer, length, flags);
   1387a:	2300      	movs	r3, #0
   1387c:	4628      	mov	r0, r5
   1387e:	47a0      	blx	r4
}
   13880:	b2c0      	uxtb	r0, r0
   13882:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOTSUP;
   13884:	f06f 0085 	mvn.w	r0, #133	; 0x85
   13888:	e7fa      	b.n	13880 <lll_entropy_get+0x14>
   1388a:	bf00      	nop
   1388c:	20001180 	.word	0x20001180

00013890 <lll_resume>:
{
   13890:	b507      	push	{r0, r1, r2, lr}
		      next->prio, &next->prepare_param, next->is_resume);
   13892:	f890 3020 	ldrb.w	r3, [r0, #32]
	ret = prepare(next->is_abort_cb, next->abort_cb, next->prepare_cb,
   13896:	f003 0301 	and.w	r3, r3, #1
   1389a:	e9cd 0300 	strd	r0, r3, [sp]
   1389e:	69c3      	ldr	r3, [r0, #28]
   138a0:	6902      	ldr	r2, [r0, #16]
   138a2:	e9d0 0105 	ldrd	r0, r1, [r0, #20]
   138a6:	f7ff fe5b 	bl	13560 <prepare>
	LL_ASSERT(!ret || ret == -EINPROGRESS);
   138aa:	b168      	cbz	r0, 138c8 <lll_resume+0x38>
   138ac:	3077      	adds	r0, #119	; 0x77
   138ae:	d00b      	beq.n	138c8 <lll_resume+0x38>
   138b0:	23da      	movs	r3, #218	; 0xda
   138b2:	4a07      	ldr	r2, [pc, #28]	; (138d0 <lll_resume+0x40>)
   138b4:	4907      	ldr	r1, [pc, #28]	; (138d4 <lll_resume+0x44>)
   138b6:	4808      	ldr	r0, [pc, #32]	; (138d8 <lll_resume+0x48>)
   138b8:	f00c fa7b 	bl	1fdb2 <printk>
   138bc:	4040      	eors	r0, r0
   138be:	f380 8811 	msr	BASEPRI, r0
   138c2:	f04f 0003 	mov.w	r0, #3
   138c6:	df02      	svc	2
}
   138c8:	b003      	add	sp, #12
   138ca:	f85d fb04 	ldr.w	pc, [sp], #4
   138ce:	bf00      	nop
   138d0:	000644b6 	.word	0x000644b6
   138d4:	00064496 	.word	0x00064496
   138d8:	000632fe 	.word	0x000632fe

000138dc <lll_disable>:
{
   138dc:	b513      	push	{r0, r1, r4, lr}
   138de:	4b1b      	ldr	r3, [pc, #108]	; (1394c <lll_disable+0x70>)
	if (!param || (param == event.curr.param)) {
   138e0:	4604      	mov	r4, r0
   138e2:	b110      	cbz	r0, 138ea <lll_disable+0xe>
   138e4:	681a      	ldr	r2, [r3, #0]
   138e6:	4282      	cmp	r2, r0
   138e8:	d105      	bne.n	138f6 <lll_disable+0x1a>
		if (event.curr.abort_cb && event.curr.param) {
   138ea:	689a      	ldr	r2, [r3, #8]
   138ec:	b16a      	cbz	r2, 1390a <lll_disable+0x2e>
   138ee:	6819      	ldr	r1, [r3, #0]
   138f0:	b159      	cbz	r1, 1390a <lll_disable+0x2e>
			event.curr.abort_cb(NULL, event.curr.param);
   138f2:	2000      	movs	r0, #0
   138f4:	4790      	blx	r2
		u8_t idx = UINT8_MAX;
   138f6:	23ff      	movs	r3, #255	; 0xff
   138f8:	f88d 3007 	strb.w	r3, [sp, #7]
			next = ull_prepare_dequeue_iter(&idx);
   138fc:	f10d 0007 	add.w	r0, sp, #7
   13900:	f7ff fd76 	bl	133f0 <ull_prepare_dequeue_iter>
		while (next) {
   13904:	b980      	cbnz	r0, 13928 <lll_disable+0x4c>
}
   13906:	b002      	add	sp, #8
   13908:	bd10      	pop	{r4, pc}
			LL_ASSERT(!param);
   1390a:	2c00      	cmp	r4, #0
   1390c:	d0f3      	beq.n	138f6 <lll_disable+0x1a>
   1390e:	23e4      	movs	r3, #228	; 0xe4
   13910:	4a0f      	ldr	r2, [pc, #60]	; (13950 <lll_disable+0x74>)
   13912:	4910      	ldr	r1, [pc, #64]	; (13954 <lll_disable+0x78>)
   13914:	4810      	ldr	r0, [pc, #64]	; (13958 <lll_disable+0x7c>)
   13916:	f00c fa4c 	bl	1fdb2 <printk>
   1391a:	4040      	eors	r0, r0
   1391c:	f380 8811 	msr	BASEPRI, r0
   13920:	f04f 0003 	mov.w	r0, #3
   13924:	df02      	svc	2
   13926:	e7e6      	b.n	138f6 <lll_disable+0x1a>
			if (!next->is_aborted &&
   13928:	f890 3020 	ldrb.w	r3, [r0, #32]
   1392c:	079b      	lsls	r3, r3, #30
   1392e:	d4e5      	bmi.n	138fc <lll_disable+0x20>
   13930:	68c1      	ldr	r1, [r0, #12]
   13932:	b10c      	cbz	r4, 13938 <lll_disable+0x5c>
			    (!param || (param == next->prepare_param.param))) {
   13934:	428c      	cmp	r4, r1
   13936:	d1e1      	bne.n	138fc <lll_disable+0x20>
				next->is_aborted = 1;
   13938:	f890 3020 	ldrb.w	r3, [r0, #32]
   1393c:	f043 0302 	orr.w	r3, r3, #2
   13940:	f880 3020 	strb.w	r3, [r0, #32]
				next->abort_cb(&next->prepare_param,
   13944:	6983      	ldr	r3, [r0, #24]
   13946:	4798      	blx	r3
   13948:	e7d8      	b.n	138fc <lll_disable+0x20>
   1394a:	bf00      	nop
   1394c:	20001184 	.word	0x20001184
   13950:	000644b6 	.word	0x000644b6
   13954:	00064465 	.word	0x00064465
   13958:	000632fe 	.word	0x000632fe

0001395c <lll_done>:
{
   1395c:	b510      	push	{r4, lr}
   1395e:	4604      	mov	r4, r0
	struct lll_event *next = ull_prepare_dequeue_get();
   13960:	f7ff fc08 	bl	13174 <ull_prepare_dequeue_get>
	LL_ASSERT(!param || next);
   13964:	b17c      	cbz	r4, 13986 <lll_done+0x2a>
   13966:	b960      	cbnz	r0, 13982 <lll_done+0x26>
   13968:	f240 1313 	movw	r3, #275	; 0x113
   1396c:	4a1a      	ldr	r2, [pc, #104]	; (139d8 <lll_done+0x7c>)
   1396e:	491b      	ldr	r1, [pc, #108]	; (139dc <lll_done+0x80>)
   13970:	481b      	ldr	r0, [pc, #108]	; (139e0 <lll_done+0x84>)
   13972:	f00c fa1e 	bl	1fdb2 <printk>
   13976:	4040      	eors	r0, r0
   13978:	f380 8811 	msr	BASEPRI, r0
   1397c:	f04f 0003 	mov.w	r0, #3
   13980:	df02      	svc	2
		ull = HDR_ULL(((struct lll_hdr *)param)->parent);
   13982:	6820      	ldr	r0, [r4, #0]
   13984:	e015      	b.n	139b2 <lll_done+0x56>
		LL_ASSERT(event.curr.abort_cb);
   13986:	4c17      	ldr	r4, [pc, #92]	; (139e4 <lll_done+0x88>)
   13988:	68a3      	ldr	r3, [r4, #8]
   1398a:	b963      	cbnz	r3, 139a6 <lll_done+0x4a>
   1398c:	f44f 738c 	mov.w	r3, #280	; 0x118
   13990:	4a11      	ldr	r2, [pc, #68]	; (139d8 <lll_done+0x7c>)
   13992:	4915      	ldr	r1, [pc, #84]	; (139e8 <lll_done+0x8c>)
   13994:	4812      	ldr	r0, [pc, #72]	; (139e0 <lll_done+0x84>)
   13996:	f00c fa0c 	bl	1fdb2 <printk>
   1399a:	4040      	eors	r0, r0
   1399c:	f380 8811 	msr	BASEPRI, r0
   139a0:	f04f 0003 	mov.w	r0, #3
   139a4:	df02      	svc	2
		param = event.curr.param;
   139a6:	6820      	ldr	r0, [r4, #0]
		event.curr.abort_cb = NULL;
   139a8:	2300      	movs	r3, #0
   139aa:	60a3      	str	r3, [r4, #8]
		event.curr.param = NULL;
   139ac:	6023      	str	r3, [r4, #0]
		if (param) {
   139ae:	b108      	cbz	r0, 139b4 <lll_done+0x58>
			ull = HDR_ULL(((struct lll_hdr *)param)->parent);
   139b0:	6800      	ldr	r0, [r0, #0]
   139b2:	3010      	adds	r0, #16
	evdone = ull_event_done(ull);
   139b4:	f7ff fd4a 	bl	1344c <ull_event_done>
	LL_ASSERT(evdone);
   139b8:	b960      	cbnz	r0, 139d4 <lll_done+0x78>
   139ba:	f44f 7398 	mov.w	r3, #304	; 0x130
   139be:	4a06      	ldr	r2, [pc, #24]	; (139d8 <lll_done+0x7c>)
   139c0:	490a      	ldr	r1, [pc, #40]	; (139ec <lll_done+0x90>)
   139c2:	4807      	ldr	r0, [pc, #28]	; (139e0 <lll_done+0x84>)
   139c4:	f00c f9f5 	bl	1fdb2 <printk>
   139c8:	4040      	eors	r0, r0
   139ca:	f380 8811 	msr	BASEPRI, r0
   139ce:	f04f 0003 	mov.w	r0, #3
   139d2:	df02      	svc	2
}
   139d4:	2000      	movs	r0, #0
   139d6:	bd10      	pop	{r4, pc}
   139d8:	000644b6 	.word	0x000644b6
   139dc:	0006446c 	.word	0x0006446c
   139e0:	000632fe 	.word	0x000632fe
   139e4:	20001184 	.word	0x20001184
   139e8:	0006447b 	.word	0x0006447b
   139ec:	0006448f 	.word	0x0006448f

000139f0 <lll_clk_on>:
	err = clock_control_on(lll.clk, CLOCK_CONTROL_NRF_SUBSYS_HF);
   139f0:	4b02      	ldr	r3, [pc, #8]	; (139fc <lll_clk_on+0xc>)
   139f2:	2100      	movs	r1, #0
   139f4:	6818      	ldr	r0, [r3, #0]
   139f6:	f010 bd6f 	b.w	244d8 <clock_control_on>
   139fa:	bf00      	nop
   139fc:	20001198 	.word	0x20001198

00013a00 <lll_clk_off>:
	err = clock_control_off(lll.clk, CLOCK_CONTROL_NRF_SUBSYS_HF);
   13a00:	4b02      	ldr	r3, [pc, #8]	; (13a0c <lll_clk_off+0xc>)
   13a02:	6818      	ldr	r0, [r3, #0]
				    clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->off(dev, sys);
   13a04:	6843      	ldr	r3, [r0, #4]
   13a06:	2100      	movs	r1, #0
   13a08:	685b      	ldr	r3, [r3, #4]
   13a0a:	4718      	bx	r3
   13a0c:	20001198 	.word	0x20001198

00013a10 <lll_chan_set>:
	switch (chan) {
   13a10:	2826      	cmp	r0, #38	; 0x26
{
   13a12:	b510      	push	{r4, lr}
   13a14:	4604      	mov	r4, r0
	switch (chan) {
   13a16:	d00b      	beq.n	13a30 <lll_chan_set+0x20>
   13a18:	2827      	cmp	r0, #39	; 0x27
   13a1a:	d00b      	beq.n	13a34 <lll_chan_set+0x24>
   13a1c:	2825      	cmp	r0, #37	; 0x25
   13a1e:	d10b      	bne.n	13a38 <lll_chan_set+0x28>
		radio_freq_chan_set(2);
   13a20:	2002      	movs	r0, #2
		radio_freq_chan_set(26);
   13a22:	f004 fe83 	bl	1872c <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
   13a26:	4620      	mov	r0, r4
}
   13a28:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
   13a2c:	f004 be84 	b.w	18738 <radio_whiten_iv_set>
		radio_freq_chan_set(26);
   13a30:	201a      	movs	r0, #26
   13a32:	e7f6      	b.n	13a22 <lll_chan_set+0x12>
		radio_freq_chan_set(80);
   13a34:	2050      	movs	r0, #80	; 0x50
   13a36:	e7f4      	b.n	13a22 <lll_chan_set+0x12>
		if (chan < 11) {
   13a38:	280a      	cmp	r0, #10
   13a3a:	d802      	bhi.n	13a42 <lll_chan_set+0x32>
			radio_freq_chan_set(4 + (chan * 2U));
   13a3c:	3002      	adds	r0, #2
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
   13a3e:	0040      	lsls	r0, r0, #1
   13a40:	e7ef      	b.n	13a22 <lll_chan_set+0x12>
		} else if (chan < 40) {
   13a42:	2827      	cmp	r0, #39	; 0x27
   13a44:	d801      	bhi.n	13a4a <lll_chan_set+0x3a>
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
   13a46:	3003      	adds	r0, #3
   13a48:	e7f9      	b.n	13a3e <lll_chan_set+0x2e>
			LL_ASSERT(0);
   13a4a:	f240 13a1 	movw	r3, #417	; 0x1a1
   13a4e:	4a06      	ldr	r2, [pc, #24]	; (13a68 <lll_chan_set+0x58>)
   13a50:	4906      	ldr	r1, [pc, #24]	; (13a6c <lll_chan_set+0x5c>)
   13a52:	4807      	ldr	r0, [pc, #28]	; (13a70 <lll_chan_set+0x60>)
   13a54:	f00c f9ad 	bl	1fdb2 <printk>
   13a58:	4040      	eors	r0, r0
   13a5a:	f380 8811 	msr	BASEPRI, r0
   13a5e:	f04f 0003 	mov.w	r0, #3
   13a62:	df02      	svc	2
   13a64:	e7df      	b.n	13a26 <lll_chan_set+0x16>
   13a66:	bf00      	nop
   13a68:	000644b6 	.word	0x000644b6
   13a6c:	00065948 	.word	0x00065948
   13a70:	000632fe 	.word	0x000632fe

00013a74 <ticker_cb>:
	return adv;
}

static void ticker_cb(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
		      void *param)
{
   13a74:	b5f0      	push	{r4, r5, r6, r7, lr}
   13a76:	461d      	mov	r5, r3

	DEBUG_RADIO_PREPARE_A(1);

	lll = &adv->lll;

	if (IS_ENABLED(CONFIG_BT_TICKER_COMPATIBILITY_MODE) ||
   13a78:	f64f 73ff 	movw	r3, #65535	; 0xffff
   13a7c:	429a      	cmp	r2, r3
{
   13a7e:	b08b      	sub	sp, #44	; 0x2c
   13a80:	4607      	mov	r7, r0
   13a82:	460e      	mov	r6, r1
   13a84:	4614      	mov	r4, r2
	if (IS_ENABLED(CONFIG_BT_TICKER_COMPATIBILITY_MODE) ||
   13a86:	d02d      	beq.n	13ae4 <ticker_cb+0x70>
	return ++hdr->ref;
   13a88:	7c2b      	ldrb	r3, [r5, #16]
   13a8a:	3301      	adds	r3, #1
   13a8c:	b2db      	uxtb	r3, r3
   13a8e:	742b      	strb	r3, [r5, #16]
	    (lazy != TICKER_LAZY_MUST_EXPIRE)) {
		/* Increment prepare reference count */
		ref = ull_ref_inc(&adv->ull);
		LL_ASSERT(ref);
   13a90:	b963      	cbnz	r3, 13aac <ticker_cb+0x38>
   13a92:	f240 4312 	movw	r3, #1042	; 0x412
   13a96:	4a2f      	ldr	r2, [pc, #188]	; (13b54 <ticker_cb+0xe0>)
   13a98:	492f      	ldr	r1, [pc, #188]	; (13b58 <ticker_cb+0xe4>)
   13a9a:	4830      	ldr	r0, [pc, #192]	; (13b5c <ticker_cb+0xe8>)
   13a9c:	f00c f989 	bl	1fdb2 <printk>
   13aa0:	4040      	eors	r0, r0
   13aa2:	f380 8811 	msr	BASEPRI, r0
   13aa6:	f04f 0003 	mov.w	r0, #3
   13aaa:	df02      	svc	2

		/* Append timing parameters */
		p.ticks_at_expire = ticks_at_expire;
   13aac:	4a2c      	ldr	r2, [pc, #176]	; (13b60 <ticker_cb+0xec>)
	lll = &adv->lll;
   13aae:	f105 031c 	add.w	r3, r5, #28
		p.remainder = remainder;
		p.lazy = lazy;
		p.param = lll;
   13ab2:	60d3      	str	r3, [r2, #12]
		mfy.param = &p;
   13ab4:	4b2b      	ldr	r3, [pc, #172]	; (13b64 <ticker_cb+0xf0>)
		p.lazy = lazy;
   13ab6:	8114      	strh	r4, [r2, #8]
		p.remainder = remainder;
   13ab8:	e9c2 7600 	strd	r7, r6, [r2]
		mfy.param = &p;
   13abc:	609a      	str	r2, [r3, #8]

		/* Kick LLL prepare */
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   13abe:	2200      	movs	r2, #0
   13ac0:	4611      	mov	r1, r2
   13ac2:	2001      	movs	r0, #1
   13ac4:	f7fc fdb6 	bl	10634 <mayfly_enqueue>
				     TICKER_USER_ID_LLL, 0, &mfy);
		LL_ASSERT(!ret);
   13ac8:	b160      	cbz	r0, 13ae4 <ticker_cb+0x70>
   13aca:	f240 431e 	movw	r3, #1054	; 0x41e
   13ace:	4a21      	ldr	r2, [pc, #132]	; (13b54 <ticker_cb+0xe0>)
   13ad0:	4925      	ldr	r1, [pc, #148]	; (13b68 <ticker_cb+0xf4>)
   13ad2:	4822      	ldr	r0, [pc, #136]	; (13b5c <ticker_cb+0xe8>)
   13ad4:	f00c f96d 	bl	1fdb2 <printk>
   13ad8:	4040      	eors	r0, r0
   13ada:	f380 8811 	msr	BASEPRI, r0
   13ade:	f04f 0003 	mov.w	r0, #3
   13ae2:	df02      	svc	2
	}

	/* Apply adv random delay */
#if defined(CONFIG_BT_PERIPHERAL)
	if (!lll->is_hdcd)
   13ae4:	f895 4028 	ldrb.w	r4, [r5, #40]	; 0x28
   13ae8:	f014 0401 	ands.w	r4, r4, #1
   13aec:	d12f      	bne.n	13b4e <ticker_cb+0xda>
#endif /* CONFIG_BT_PERIPHERAL */
	{
		u32_t random_delay;
		u32_t ret;

		lll_entropy_get(sizeof(random_delay), &random_delay);
   13aee:	a909      	add	r1, sp, #36	; 0x24
   13af0:	2004      	movs	r0, #4
   13af2:	f7ff febb 	bl	1386c <lll_entropy_get>
		random_delay %= HAL_TICKER_US_TO_TICKS(10000);
   13af6:	9909      	ldr	r1, [sp, #36]	; 0x24
		random_delay += 1;

		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   13af8:	9506      	str	r5, [sp, #24]
		random_delay %= HAL_TICKER_US_TO_TICKS(10000);
   13afa:	f240 1247 	movw	r2, #327	; 0x147
   13afe:	fbb1 f3f2 	udiv	r3, r1, r2
   13b02:	fb02 1313 	mls	r3, r2, r3, r1
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   13b06:	4a19      	ldr	r2, [pc, #100]	; (13b6c <ticker_cb+0xf8>)
   13b08:	21e4      	movs	r1, #228	; 0xe4
   13b0a:	1aaa      	subs	r2, r5, r2
   13b0c:	fbb2 f2f1 	udiv	r2, r2, r1
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   13b10:	4917      	ldr	r1, [pc, #92]	; (13b70 <ticker_cb+0xfc>)
				    TICKER_USER_ID_ULL_HIGH,
				    (TICKER_ID_ADV_BASE +
   13b12:	3202      	adds	r2, #2
		random_delay += 1;
   13b14:	3301      	adds	r3, #1
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   13b16:	e9cd 4104 	strd	r4, r1, [sp, #16]
   13b1a:	e9cd 4402 	strd	r4, r4, [sp, #8]
   13b1e:	e9cd 4400 	strd	r4, r4, [sp]
   13b22:	b2d2      	uxtb	r2, r2
   13b24:	2101      	movs	r1, #1
   13b26:	4620      	mov	r0, r4
		random_delay += 1;
   13b28:	9309      	str	r3, [sp, #36]	; 0x24
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   13b2a:	f7fd fa4b 	bl	10fc4 <ticker_update>
				     ull_adv_handle_get(adv)),
				    random_delay,
				    0, 0, 0, 0, 0,
				    ticker_op_update_cb, adv);
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   13b2e:	f030 0302 	bics.w	r3, r0, #2
   13b32:	d00c      	beq.n	13b4e <ticker_cb+0xda>
   13b34:	f240 4335 	movw	r3, #1077	; 0x435
   13b38:	4a06      	ldr	r2, [pc, #24]	; (13b54 <ticker_cb+0xe0>)
   13b3a:	490e      	ldr	r1, [pc, #56]	; (13b74 <ticker_cb+0x100>)
   13b3c:	4807      	ldr	r0, [pc, #28]	; (13b5c <ticker_cb+0xe8>)
   13b3e:	f00c f938 	bl	1fdb2 <printk>
   13b42:	4040      	eors	r0, r0
   13b44:	f380 8811 	msr	BASEPRI, r0
   13b48:	f04f 0003 	mov.w	r0, #3
   13b4c:	df02      	svc	2
			  (ret == TICKER_STATUS_BUSY));
	}

	DEBUG_RADIO_PREPARE_A(1);
}
   13b4e:	b00b      	add	sp, #44	; 0x2c
   13b50:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13b52:	bf00      	nop
   13b54:	0006458a 	.word	0x0006458a
   13b58:	00064434 	.word	0x00064434
   13b5c:	000632fe 	.word	0x000632fe
   13b60:	20001290 	.word	0x20001290
   13b64:	2000ea20 	.word	0x2000ea20
   13b68:	00064330 	.word	0x00064330
   13b6c:	200011ac 	.word	0x200011ac
   13b70:	00013d31 	.word	0x00013d31
   13b74:	000645c2 	.word	0x000645c2

00013b78 <conn_release>:
	ll_rx_put(link, rx);
	ll_rx_sched();
}

static inline void conn_release(struct ll_adv_set *adv)
{
   13b78:	b570      	push	{r4, r5, r6, lr}
	struct lll_conn *lll = adv->lll.conn;
   13b7a:	6a45      	ldr	r5, [r0, #36]	; 0x24
	memq_link_t *link;

	LL_ASSERT(!lll->link_tx_free);
   13b7c:	6deb      	ldr	r3, [r5, #92]	; 0x5c
{
   13b7e:	4604      	mov	r4, r0
	LL_ASSERT(!lll->link_tx_free);
   13b80:	b163      	cbz	r3, 13b9c <conn_release+0x24>
   13b82:	f240 43b1 	movw	r3, #1201	; 0x4b1
   13b86:	4a19      	ldr	r2, [pc, #100]	; (13bec <conn_release+0x74>)
   13b88:	4919      	ldr	r1, [pc, #100]	; (13bf0 <conn_release+0x78>)
   13b8a:	481a      	ldr	r0, [pc, #104]	; (13bf4 <conn_release+0x7c>)
   13b8c:	f00c f911 	bl	1fdb2 <printk>
   13b90:	4040      	eors	r0, r0
   13b92:	f380 8811 	msr	BASEPRI, r0
   13b96:	f04f 0003 	mov.w	r0, #3
   13b9a:	df02      	svc	2
	link = memq_deinit(&lll->memq_tx.head, &lll->memq_tx.tail);
   13b9c:	f105 0150 	add.w	r1, r5, #80	; 0x50
   13ba0:	f105 004c 	add.w	r0, r5, #76	; 0x4c
   13ba4:	f010 fa5a 	bl	2405c <memq_deinit>
	LL_ASSERT(link);
   13ba8:	4606      	mov	r6, r0
   13baa:	b960      	cbnz	r0, 13bc6 <conn_release+0x4e>
   13bac:	f240 43b3 	movw	r3, #1203	; 0x4b3
   13bb0:	4a0e      	ldr	r2, [pc, #56]	; (13bec <conn_release+0x74>)
   13bb2:	4911      	ldr	r1, [pc, #68]	; (13bf8 <conn_release+0x80>)
   13bb4:	480f      	ldr	r0, [pc, #60]	; (13bf4 <conn_release+0x7c>)
   13bb6:	f00c f8fc 	bl	1fdb2 <printk>
   13bba:	4040      	eors	r0, r0
   13bbc:	f380 8811 	msr	BASEPRI, r0
   13bc0:	f04f 0003 	mov.w	r0, #3
   13bc4:	df02      	svc	2
	lll->link_tx_free = link;

	ll_conn_release(lll->hdr.parent);
   13bc6:	6828      	ldr	r0, [r5, #0]
	lll->link_tx_free = link;
   13bc8:	65ee      	str	r6, [r5, #92]	; 0x5c
	adv->lll.conn = NULL;
   13bca:	2500      	movs	r5, #0
	ll_conn_release(lll->hdr.parent);
   13bcc:	f001 f922 	bl	14e14 <ll_conn_release>

	ll_rx_release(adv->node_rx_cc_free);
   13bd0:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
	adv->lll.conn = NULL;
   13bd4:	6265      	str	r5, [r4, #36]	; 0x24
	ll_rx_release(adv->node_rx_cc_free);
   13bd6:	f7ff f93d 	bl	12e54 <ll_rx_release>
	adv->node_rx_cc_free = NULL;
   13bda:	f8c4 50d4 	str.w	r5, [r4, #212]	; 0xd4
	ll_rx_link_release(adv->link_cc_free);
   13bde:	f8d4 00d0 	ldr.w	r0, [r4, #208]	; 0xd0
   13be2:	f7ff f92b 	bl	12e3c <ll_rx_link_release>
	adv->link_cc_free = NULL;
   13be6:	f8c4 50d0 	str.w	r5, [r4, #208]	; 0xd0
}
   13bea:	bd70      	pop	{r4, r5, r6, pc}
   13bec:	0006458a 	.word	0x0006458a
   13bf0:	00064413 	.word	0x00064413
   13bf4:	000632fe 	.word	0x000632fe
   13bf8:	00064829 	.word	0x00064829

00013bfc <ticker_op_stop_cb>:
{
   13bfc:	b570      	push	{r4, r5, r6, lr}
   13bfe:	460c      	mov	r4, r1
	if (status != TICKER_STATUS_SUCCESS) {
   13c00:	2800      	cmp	r0, #0
   13c02:	d12f      	bne.n	13c64 <ticker_op_stop_cb+0x68>
	mfy.param = &adv->lll;
   13c04:	4b1d      	ldr	r3, [pc, #116]	; (13c7c <ticker_op_stop_cb+0x80>)
   13c06:	4d1e      	ldr	r5, [pc, #120]	; (13c80 <ticker_op_stop_cb+0x84>)
   13c08:	f101 021c 	add.w	r2, r1, #28
   13c0c:	609a      	str	r2, [r3, #8]
	if (hdr->ref) {
   13c0e:	7c0a      	ldrb	r2, [r1, #16]
   13c10:	461e      	mov	r6, r3
   13c12:	b342      	cbz	r2, 13c66 <ticker_op_stop_cb+0x6a>
		LL_ASSERT(!hdr->disabled_cb);
   13c14:	694b      	ldr	r3, [r1, #20]
   13c16:	b163      	cbz	r3, 13c32 <ticker_op_stop_cb+0x36>
   13c18:	f240 437c 	movw	r3, #1148	; 0x47c
   13c1c:	4a19      	ldr	r2, [pc, #100]	; (13c84 <ticker_op_stop_cb+0x88>)
   13c1e:	491a      	ldr	r1, [pc, #104]	; (13c88 <ticker_op_stop_cb+0x8c>)
   13c20:	481a      	ldr	r0, [pc, #104]	; (13c8c <ticker_op_stop_cb+0x90>)
   13c22:	f00c f8c6 	bl	1fdb2 <printk>
   13c26:	4040      	eors	r0, r0
   13c28:	f380 8811 	msr	BASEPRI, r0
   13c2c:	f04f 0003 	mov.w	r0, #3
   13c30:	df02      	svc	2
		hdr->disabled_param = mfy.param;
   13c32:	68b3      	ldr	r3, [r6, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   13c34:	2200      	movs	r2, #0
		hdr->disabled_cb = disabled_cb;
   13c36:	e9c4 5305 	strd	r5, r3, [r4, #20]
		mfy.fp = lll_disable;
   13c3a:	4b15      	ldr	r3, [pc, #84]	; (13c90 <ticker_op_stop_cb+0x94>)
   13c3c:	60f3      	str	r3, [r6, #12]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   13c3e:	4611      	mov	r1, r2
   13c40:	4b0e      	ldr	r3, [pc, #56]	; (13c7c <ticker_op_stop_cb+0x80>)
   13c42:	2002      	movs	r0, #2
   13c44:	f7fc fcf6 	bl	10634 <mayfly_enqueue>
		LL_ASSERT(!ret);
   13c48:	b160      	cbz	r0, 13c64 <ticker_op_stop_cb+0x68>
   13c4a:	f240 4383 	movw	r3, #1155	; 0x483
		LL_ASSERT(!ret);
   13c4e:	4a0d      	ldr	r2, [pc, #52]	; (13c84 <ticker_op_stop_cb+0x88>)
   13c50:	4910      	ldr	r1, [pc, #64]	; (13c94 <ticker_op_stop_cb+0x98>)
   13c52:	480e      	ldr	r0, [pc, #56]	; (13c8c <ticker_op_stop_cb+0x90>)
   13c54:	f00c f8ad 	bl	1fdb2 <printk>
   13c58:	4040      	eors	r0, r0
   13c5a:	f380 8811 	msr	BASEPRI, r0
   13c5e:	f04f 0003 	mov.w	r0, #3
   13c62:	df02      	svc	2
}
   13c64:	bd70      	pop	{r4, r5, r6, pc}
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   13c66:	2101      	movs	r1, #1
   13c68:	2002      	movs	r0, #2
		mfy.fp = disabled_cb;
   13c6a:	60dd      	str	r5, [r3, #12]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   13c6c:	f7fc fce2 	bl	10634 <mayfly_enqueue>
		LL_ASSERT(!ret);
   13c70:	2800      	cmp	r0, #0
   13c72:	d0f7      	beq.n	13c64 <ticker_op_stop_cb+0x68>
   13c74:	f44f 6391 	mov.w	r3, #1160	; 0x488
   13c78:	e7e9      	b.n	13c4e <ticker_op_stop_cb+0x52>
   13c7a:	bf00      	nop
   13c7c:	2000ea30 	.word	0x2000ea30
   13c80:	00013c99 	.word	0x00013c99
   13c84:	0006458a 	.word	0x0006458a
   13c88:	000645db 	.word	0x000645db
   13c8c:	000632fe 	.word	0x000632fe
   13c90:	000138dd 	.word	0x000138dd
   13c94:	00064330 	.word	0x00064330

00013c98 <disabled_cb>:
{
   13c98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	adv = ((struct lll_hdr *)param)->parent;
   13c9a:	6805      	ldr	r5, [r0, #0]
	LL_ASSERT(adv->link_cc_free);
   13c9c:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
{
   13ca0:	4606      	mov	r6, r0
	LL_ASSERT(adv->link_cc_free);
   13ca2:	b963      	cbnz	r3, 13cbe <disabled_cb+0x26>
   13ca4:	f240 4396 	movw	r3, #1174	; 0x496
   13ca8:	4a1d      	ldr	r2, [pc, #116]	; (13d20 <disabled_cb+0x88>)
   13caa:	491e      	ldr	r1, [pc, #120]	; (13d24 <disabled_cb+0x8c>)
   13cac:	481e      	ldr	r0, [pc, #120]	; (13d28 <disabled_cb+0x90>)
   13cae:	f00c f880 	bl	1fdb2 <printk>
   13cb2:	4040      	eors	r0, r0
   13cb4:	f380 8811 	msr	BASEPRI, r0
   13cb8:	f04f 0003 	mov.w	r0, #3
   13cbc:	df02      	svc	2
	adv->link_cc_free = NULL;
   13cbe:	2300      	movs	r3, #0
	link = adv->link_cc_free;
   13cc0:	f8d5 70d0 	ldr.w	r7, [r5, #208]	; 0xd0
	adv->link_cc_free = NULL;
   13cc4:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
	LL_ASSERT(adv->node_rx_cc_free);
   13cc8:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
   13ccc:	b963      	cbnz	r3, 13ce8 <disabled_cb+0x50>
   13cce:	f240 439a 	movw	r3, #1178	; 0x49a
   13cd2:	4a13      	ldr	r2, [pc, #76]	; (13d20 <disabled_cb+0x88>)
   13cd4:	4915      	ldr	r1, [pc, #84]	; (13d2c <disabled_cb+0x94>)
   13cd6:	4814      	ldr	r0, [pc, #80]	; (13d28 <disabled_cb+0x90>)
   13cd8:	f00c f86b 	bl	1fdb2 <printk>
   13cdc:	4040      	eors	r0, r0
   13cde:	f380 8811 	msr	BASEPRI, r0
   13ce2:	f04f 0003 	mov.w	r0, #3
   13ce6:	df02      	svc	2
	rx = adv->node_rx_cc_free;
   13ce8:	f8d5 40d4 	ldr.w	r4, [r5, #212]	; 0xd4
	adv->node_rx_cc_free = NULL;
   13cec:	2100      	movs	r1, #0
	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   13cee:	2308      	movs	r3, #8
	adv->node_rx_cc_free = NULL;
   13cf0:	f8c5 10d4 	str.w	r1, [r5, #212]	; 0xd4
	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   13cf4:	7123      	strb	r3, [r4, #4]
	rx->hdr.handle = 0xffff;
   13cf6:	f64f 73ff 	movw	r3, #65535	; 0xffff
   13cfa:	80e3      	strh	r3, [r4, #6]
__ssp_bos_icheck3(memset, void *, int)
   13cfc:	221e      	movs	r2, #30
   13cfe:	f104 0020 	add.w	r0, r4, #32
   13d02:	f7ed ff94 	bl	1c2e <memset>
	cc->status = BT_HCI_ERR_ADV_TIMEOUT;
   13d06:	233c      	movs	r3, #60	; 0x3c
   13d08:	f884 3020 	strb.w	r3, [r4, #32]
	ftr->param = param;
   13d0c:	60a6      	str	r6, [r4, #8]
	ll_rx_put(link, rx);
   13d0e:	4621      	mov	r1, r4
   13d10:	4638      	mov	r0, r7
   13d12:	f7ff f8a5 	bl	12e60 <ll_rx_put>
}
   13d16:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	ll_rx_sched();
   13d1a:	f7ff b8ab 	b.w	12e74 <ll_rx_sched>
   13d1e:	bf00      	nop
   13d20:	0006458a 	.word	0x0006458a
   13d24:	00064553 	.word	0x00064553
   13d28:	000632fe 	.word	0x000632fe
   13d2c:	00064565 	.word	0x00064565

00013d30 <ticker_op_update_cb>:
{
   13d30:	b510      	push	{r4, lr}
   13d32:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
   13d34:	b180      	cbz	r0, 13d58 <ticker_op_update_cb+0x28>
   13d36:	f7ff f945 	bl	12fc4 <ull_disable_mark_get>
   13d3a:	4284      	cmp	r4, r0
   13d3c:	d00c      	beq.n	13d58 <ticker_op_update_cb+0x28>
   13d3e:	f240 433e 	movw	r3, #1086	; 0x43e
   13d42:	4a06      	ldr	r2, [pc, #24]	; (13d5c <ticker_op_update_cb+0x2c>)
   13d44:	4906      	ldr	r1, [pc, #24]	; (13d60 <ticker_op_update_cb+0x30>)
   13d46:	4807      	ldr	r0, [pc, #28]	; (13d64 <ticker_op_update_cb+0x34>)
   13d48:	f00c f833 	bl	1fdb2 <printk>
   13d4c:	4040      	eors	r0, r0
   13d4e:	f380 8811 	msr	BASEPRI, r0
   13d52:	f04f 0003 	mov.w	r0, #3
   13d56:	df02      	svc	2
}
   13d58:	bd10      	pop	{r4, pc}
   13d5a:	bf00      	nop
   13d5c:	0006458a 	.word	0x0006458a
   13d60:	000645ed 	.word	0x000645ed
   13d64:	000632fe 	.word	0x000632fe

00013d68 <ticker_stop_cb>:
{
   13d68:	b537      	push	{r0, r1, r2, r4, r5, lr}
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   13d6a:	4c17      	ldr	r4, [pc, #92]	; (13dc8 <ticker_stop_cb+0x60>)
{
   13d6c:	461d      	mov	r5, r3
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   13d6e:	1b1c      	subs	r4, r3, r4
   13d70:	22e4      	movs	r2, #228	; 0xe4
   13d72:	fbb4 f4f2 	udiv	r4, r4, r2
	LL_ASSERT(handle < BT_CTLR_ADV_MAX);
   13d76:	b2a3      	uxth	r3, r4
   13d78:	b163      	cbz	r3, 13d94 <ticker_stop_cb+0x2c>
   13d7a:	f240 4359 	movw	r3, #1113	; 0x459
   13d7e:	4a13      	ldr	r2, [pc, #76]	; (13dcc <ticker_stop_cb+0x64>)
   13d80:	4913      	ldr	r1, [pc, #76]	; (13dd0 <ticker_stop_cb+0x68>)
   13d82:	4814      	ldr	r0, [pc, #80]	; (13dd4 <ticker_stop_cb+0x6c>)
   13d84:	f00c f815 	bl	1fdb2 <printk>
   13d88:	4040      	eors	r0, r0
   13d8a:	f380 8811 	msr	BASEPRI, r0
   13d8e:	f04f 0003 	mov.w	r0, #3
   13d92:	df02      	svc	2
			  TICKER_ID_ADV_BASE + handle,
   13d94:	1ca2      	adds	r2, r4, #2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
   13d96:	4b10      	ldr	r3, [pc, #64]	; (13dd8 <ticker_stop_cb+0x70>)
   13d98:	9500      	str	r5, [sp, #0]
   13d9a:	b2d2      	uxtb	r2, r2
   13d9c:	2101      	movs	r1, #1
   13d9e:	2000      	movs	r0, #0
   13da0:	f7fd f958 	bl	11054 <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   13da4:	f030 0302 	bics.w	r3, r0, #2
   13da8:	d00c      	beq.n	13dc4 <ticker_stop_cb+0x5c>
   13daa:	f240 435f 	movw	r3, #1119	; 0x45f
   13dae:	4a07      	ldr	r2, [pc, #28]	; (13dcc <ticker_stop_cb+0x64>)
   13db0:	490a      	ldr	r1, [pc, #40]	; (13ddc <ticker_stop_cb+0x74>)
   13db2:	4808      	ldr	r0, [pc, #32]	; (13dd4 <ticker_stop_cb+0x6c>)
   13db4:	f00b fffd 	bl	1fdb2 <printk>
   13db8:	4040      	eors	r0, r0
   13dba:	f380 8811 	msr	BASEPRI, r0
   13dbe:	f04f 0003 	mov.w	r0, #3
   13dc2:	df02      	svc	2
}
   13dc4:	b003      	add	sp, #12
   13dc6:	bd30      	pop	{r4, r5, pc}
   13dc8:	200011ac 	.word	0x200011ac
   13dcc:	0006458a 	.word	0x0006458a
   13dd0:	0006461c 	.word	0x0006461c
   13dd4:	000632fe 	.word	0x000632fe
   13dd8:	00013bfd 	.word	0x00013bfd
   13ddc:	000645c2 	.word	0x000645c2

00013de0 <ll_adv_params_set>:
{
   13de0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
   13de2:	4c43      	ldr	r4, [pc, #268]	; (13ef0 <ll_adv_params_set+0x110>)
   13de4:	9400      	str	r4, [sp, #0]
   13de6:	2401      	movs	r4, #1
   13de8:	f88d 4004 	strb.w	r4, [sp, #4]
	if (!adv || adv->is_enabled) {
   13dec:	4c41      	ldr	r4, [pc, #260]	; (13ef4 <ll_adv_params_set+0x114>)
{
   13dee:	f8dd c020 	ldr.w	ip, [sp, #32]
	if (!adv || adv->is_enabled) {
   13df2:	f894 60cc 	ldrb.w	r6, [r4, #204]	; 0xcc
   13df6:	f016 0601 	ands.w	r6, r6, #1
   13dfa:	d177      	bne.n	13eec <ll_adv_params_set+0x10c>
		adv->interval = 0;
   13dfc:	2901      	cmp	r1, #1
   13dfe:	bf08      	it	eq
   13e00:	2000      	moveq	r0, #0
   13e02:	f8a4 00d8 	strh.w	r0, [r4, #216]	; 0xd8
	adv->lll.chan_map = chan_map;
   13e06:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
   13e0a:	f894 0028 	ldrb.w	r0, [r4, #40]	; 0x28
   13e0e:	f365 0043 	bfi	r0, r5, #1, #3
   13e12:	f884 0028 	strb.w	r0, [r4, #40]	; 0x28
	adv->lll.filter_policy = filter_policy;
   13e16:	f89d 5028 	ldrb.w	r5, [sp, #40]	; 0x28
   13e1a:	f894 0029 	ldrb.w	r0, [r4, #41]	; 0x29
   13e1e:	f365 0001 	bfi	r0, r5, #0, #2
   13e22:	f894 502c 	ldrb.w	r5, [r4, #44]	; 0x2c
   13e26:	f884 0029 	strb.w	r0, [r4, #41]	; 0x29
   13e2a:	2727      	movs	r7, #39	; 0x27
   13e2c:	202d      	movs	r0, #45	; 0x2d
   13e2e:	fb17 0505 	smlabb	r5, r7, r5, r0
	pdu->type = pdu_adv_type[adv_type];
   13e32:	a802      	add	r0, sp, #8
   13e34:	4408      	add	r0, r1
   13e36:	5d61      	ldrb	r1, [r4, r5]
   13e38:	f810 0c08 	ldrb.w	r0, [r0, #-8]
   13e3c:	f360 0103 	bfi	r1, r0, #0, #4
	pdu->rfu = 0;
   13e40:	f366 1104 	bfi	r1, r6, #4, #1
	    ((pdu->type == PDU_ADV_TYPE_ADV_IND) ||
   13e44:	b2c9      	uxtb	r1, r1
	if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2) &&
   13e46:	f011 0f0e 	tst.w	r1, #14
   13e4a:	bf0c      	ite	eq
   13e4c:	2001      	moveq	r0, #1
   13e4e:	2000      	movne	r0, #0
   13e50:	f360 1145 	bfi	r1, r0, #5, #1
   13e54:	5561      	strb	r1, [r4, r5]
	adv->own_addr_type = own_addr_type;
   13e56:	f894 10da 	ldrb.w	r1, [r4, #218]	; 0xda
   13e5a:	f362 0101 	bfi	r1, r2, #0, #2
   13e5e:	f884 10da 	strb.w	r1, [r4, #218]	; 0xda
	if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
   13e62:	b2c9      	uxtb	r1, r1
   13e64:	0788      	lsls	r0, r1, #30
   13e66:	eb04 0705 	add.w	r7, r4, r5
   13e6a:	d50b      	bpl.n	13e84 <ll_adv_params_set+0xa4>
		adv->id_addr_type = direct_addr_type;
   13e6c:	f363 0182 	bfi	r1, r3, #2, #1
   13e70:	f884 10da 	strb.w	r1, [r4, #218]	; 0xda
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   13e74:	f8dc 0000 	ldr.w	r0, [ip]
   13e78:	f8c4 00dc 	str.w	r0, [r4, #220]	; 0xdc
   13e7c:	f8bc 1004 	ldrh.w	r1, [ip, #4]
   13e80:	f8a4 10e0 	strh.w	r1, [r4, #224]	; 0xe0
	pdu->tx_addr = own_addr_type & 0x1;
   13e84:	5d61      	ldrb	r1, [r4, r5]
   13e86:	f002 0201 	and.w	r2, r2, #1
   13e8a:	f362 1186 	bfi	r1, r2, #6, #1
	pdu->rx_addr = 0;
   13e8e:	f36f 11c7 	bfc	r1, #7, #1
   13e92:	5561      	strb	r1, [r4, r5]
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   13e94:	b2c9      	uxtb	r1, r1
   13e96:	f001 000f 	and.w	r0, r1, #15
   13e9a:	2801      	cmp	r0, #1
   13e9c:	d121      	bne.n	13ee2 <ll_adv_params_set+0x102>
		pdu->rx_addr = direct_addr_type;
   13e9e:	f363 11c7 	bfi	r1, r3, #7, #1
   13ea2:	5561      	strb	r1, [r4, r5]
   13ea4:	f8dc 3000 	ldr.w	r3, [ip]
   13ea8:	60bb      	str	r3, [r7, #8]
   13eaa:	f8bc 3004 	ldrh.w	r3, [ip, #4]
   13eae:	81bb      	strh	r3, [r7, #12]
		pdu->len = sizeof(struct pdu_adv_direct_ind);
   13eb0:	230c      	movs	r3, #12
		pdu->len = BDADDR_SIZE;
   13eb2:	707b      	strb	r3, [r7, #1]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   13eb4:	f894 007c 	ldrb.w	r0, [r4, #124]	; 0x7c
   13eb8:	237d      	movs	r3, #125	; 0x7d
   13eba:	2127      	movs	r1, #39	; 0x27
   13ebc:	fb11 3100 	smlabb	r1, r1, r0, r3
   13ec0:	1860      	adds	r0, r4, r1
	pdu->tx_addr = own_addr_type & 0x1;
   13ec2:	5c63      	ldrb	r3, [r4, r1]
   13ec4:	f362 1386 	bfi	r3, r2, #6, #1
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
   13ec8:	f003 0340 	and.w	r3, r3, #64	; 0x40
   13ecc:	f043 0304 	orr.w	r3, r3, #4
   13ed0:	5463      	strb	r3, [r4, r1]
	if (pdu->len == 0) {
   13ed2:	7843      	ldrb	r3, [r0, #1]
   13ed4:	b913      	cbnz	r3, 13edc <ll_adv_params_set+0xfc>
		pdu->len = BDADDR_SIZE;
   13ed6:	2206      	movs	r2, #6
   13ed8:	7042      	strb	r2, [r0, #1]
	return 0;
   13eda:	461e      	mov	r6, r3
}
   13edc:	4630      	mov	r0, r6
   13ede:	b003      	add	sp, #12
   13ee0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	} else if (pdu->len == 0) {
   13ee2:	787b      	ldrb	r3, [r7, #1]
   13ee4:	2b00      	cmp	r3, #0
   13ee6:	d1e5      	bne.n	13eb4 <ll_adv_params_set+0xd4>
		pdu->len = BDADDR_SIZE;
   13ee8:	2306      	movs	r3, #6
   13eea:	e7e2      	b.n	13eb2 <ll_adv_params_set+0xd2>
		return BT_HCI_ERR_CMD_DISALLOWED;
   13eec:	260c      	movs	r6, #12
   13eee:	e7f5      	b.n	13edc <ll_adv_params_set+0xfc>
   13ef0:	02060100 	.word	0x02060100
   13ef4:	200011ac 	.word	0x200011ac

00013ef8 <ll_adv_data_set>:
{
   13ef8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   13efc:	4a2a      	ldr	r2, [pc, #168]	; (13fa8 <ll_adv_data_set+0xb0>)
   13efe:	f892 402c 	ldrb.w	r4, [r2, #44]	; 0x2c
   13f02:	232d      	movs	r3, #45	; 0x2d
   13f04:	4680      	mov	r8, r0
   13f06:	2027      	movs	r0, #39	; 0x27
   13f08:	fb10 3004 	smlabb	r0, r0, r4, r3
   13f0c:	1816      	adds	r6, r2, r0
	if ((prev->type == PDU_ADV_TYPE_DIRECT_IND) ||
   13f0e:	f812 e000 	ldrb.w	lr, [r2, r0]
   13f12:	f00e 030f 	and.w	r3, lr, #15
   13f16:	2b01      	cmp	r3, #1
   13f18:	4615      	mov	r5, r2
   13f1a:	d042      	beq.n	13fa2 <ll_adv_data_set+0xaa>
	if (pdu->first == pdu->last) {
   13f1c:	f892 302b 	ldrb.w	r3, [r2, #43]	; 0x2b
   13f20:	42a3      	cmp	r3, r4
   13f22:	d104      	bne.n	13f2e <ll_adv_data_set+0x36>
		last = pdu->last + 1;
   13f24:	3401      	adds	r4, #1
   13f26:	b2e4      	uxtb	r4, r4
			last = 0U;
   13f28:	2c02      	cmp	r4, #2
   13f2a:	bf08      	it	eq
   13f2c:	2400      	moveq	r4, #0
	return (void *)pdu->pdu[last];
   13f2e:	2727      	movs	r7, #39	; 0x27
   13f30:	232d      	movs	r3, #45	; 0x2d
   13f32:	fb17 3304 	smlabb	r3, r7, r4, r3
   13f36:	18ef      	adds	r7, r5, r3
	pdu->type = prev->type;
   13f38:	f815 c003 	ldrb.w	ip, [r5, r3]
   13f3c:	f36e 0c03 	bfi	ip, lr, #0, #4
	pdu->rfu = 0U;
   13f40:	f36f 1c04 	bfc	ip, #4, #1
   13f44:	f805 c003 	strb.w	ip, [r5, r3]
		pdu->chan_sel = prev->chan_sel;
   13f48:	f812 c000 	ldrb.w	ip, [r2, r0]
   13f4c:	f815 e003 	ldrb.w	lr, [r5, r3]
   13f50:	f3cc 1c40 	ubfx	ip, ip, #5, #1
   13f54:	f36c 1e45 	bfi	lr, ip, #5, #1
   13f58:	f805 e003 	strb.w	lr, [r5, r3]
	pdu->tx_addr = prev->tx_addr;
   13f5c:	f812 c000 	ldrb.w	ip, [r2, r0]
   13f60:	fa5f fe8e 	uxtb.w	lr, lr
   13f64:	f3cc 1c80 	ubfx	ip, ip, #6, #1
   13f68:	f36c 1e86 	bfi	lr, ip, #6, #1
   13f6c:	f805 e003 	strb.w	lr, [r5, r3]
	pdu->rx_addr = prev->rx_addr;
   13f70:	5c12      	ldrb	r2, [r2, r0]
   13f72:	fa5f f08e 	uxtb.w	r0, lr
   13f76:	09d2      	lsrs	r2, r2, #7
   13f78:	f362 10c7 	bfi	r0, r2, #7, #1
   13f7c:	54e8      	strb	r0, [r5, r3]
   13f7e:	4633      	mov	r3, r6
   13f80:	f107 0008 	add.w	r0, r7, #8
   13f84:	f853 2f02 	ldr.w	r2, [r3, #2]!
   13f88:	f8c7 2002 	str.w	r2, [r7, #2]
   13f8c:	889b      	ldrh	r3, [r3, #4]
   13f8e:	80fb      	strh	r3, [r7, #6]
   13f90:	4642      	mov	r2, r8
	pdu->len = BDADDR_SIZE + len;
   13f92:	f108 0806 	add.w	r8, r8, #6
   13f96:	f7ed fe29 	bl	1bec <memcpy>
   13f9a:	f887 8001 	strb.w	r8, [r7, #1]
	pdu->last = idx;
   13f9e:	f885 402c 	strb.w	r4, [r5, #44]	; 0x2c
}
   13fa2:	2000      	movs	r0, #0
   13fa4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13fa8:	200011ac 	.word	0x200011ac

00013fac <ll_adv_scan_rsp_set>:
{
   13fac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   13fae:	4f20      	ldr	r7, [pc, #128]	; (14030 <ll_adv_scan_rsp_set+0x84>)
   13fb0:	f897 407c 	ldrb.w	r4, [r7, #124]	; 0x7c
   13fb4:	237d      	movs	r3, #125	; 0x7d
   13fb6:	4602      	mov	r2, r0
   13fb8:	2027      	movs	r0, #39	; 0x27
   13fba:	fb10 3004 	smlabb	r0, r0, r4, r3
	if (pdu->first == pdu->last) {
   13fbe:	f897 307b 	ldrb.w	r3, [r7, #123]	; 0x7b
   13fc2:	42a3      	cmp	r3, r4
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   13fc4:	eb07 0600 	add.w	r6, r7, r0
	if (pdu->first == pdu->last) {
   13fc8:	463d      	mov	r5, r7
   13fca:	d104      	bne.n	13fd6 <ll_adv_scan_rsp_set+0x2a>
		last = pdu->last + 1;
   13fcc:	3401      	adds	r4, #1
   13fce:	b2e4      	uxtb	r4, r4
			last = 0U;
   13fd0:	2c02      	cmp	r4, #2
   13fd2:	bf08      	it	eq
   13fd4:	2400      	moveq	r4, #0
	return (void *)pdu->pdu[last];
   13fd6:	f04f 0c27 	mov.w	ip, #39	; 0x27
   13fda:	237d      	movs	r3, #125	; 0x7d
   13fdc:	fb1c 3304 	smlabb	r3, ip, r4, r3
   13fe0:	eb05 0e03 	add.w	lr, r5, r3
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
   13fe4:	f815 c003 	ldrb.w	ip, [r5, r3]
   13fe8:	f02c 0c3f 	bic.w	ip, ip, #63	; 0x3f
   13fec:	f04c 0c04 	orr.w	ip, ip, #4
   13ff0:	f805 c003 	strb.w	ip, [r5, r3]
	pdu->tx_addr = prev->tx_addr;
   13ff4:	5c38      	ldrb	r0, [r7, r0]
   13ff6:	fa5f f78c 	uxtb.w	r7, ip
   13ffa:	f3c0 1080 	ubfx	r0, r0, #6, #1
   13ffe:	f360 1786 	bfi	r7, r0, #6, #1
	pdu->rx_addr = 0;
   14002:	f36f 17c7 	bfc	r7, #7, #1
   14006:	54ef      	strb	r7, [r5, r3]
	pdu->len = BDADDR_SIZE + len;
   14008:	1d93      	adds	r3, r2, #6
   1400a:	f88e 3001 	strb.w	r3, [lr, #1]
   1400e:	4633      	mov	r3, r6
   14010:	f853 0f02 	ldr.w	r0, [r3, #2]!
   14014:	f8ce 0002 	str.w	r0, [lr, #2]
   14018:	889b      	ldrh	r3, [r3, #4]
   1401a:	f8ae 3006 	strh.w	r3, [lr, #6]
   1401e:	f10e 0008 	add.w	r0, lr, #8
   14022:	f7ed fde3 	bl	1bec <memcpy>
	pdu->last = idx;
   14026:	f885 407c 	strb.w	r4, [r5, #124]	; 0x7c
}
   1402a:	2000      	movs	r0, #0
   1402c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1402e:	bf00      	nop
   14030:	200011ac 	.word	0x200011ac

00014034 <ull_adv_handle_get>:
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   14034:	4b03      	ldr	r3, [pc, #12]	; (14044 <ull_adv_handle_get+0x10>)
   14036:	1ac0      	subs	r0, r0, r3
   14038:	23e4      	movs	r3, #228	; 0xe4
   1403a:	fbb0 f0f3 	udiv	r0, r0, r3
}
   1403e:	b280      	uxth	r0, r0
   14040:	4770      	bx	lr
   14042:	bf00      	nop
   14044:	200011ac 	.word	0x200011ac

00014048 <ull_adv_lll_handle_get>:
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   14048:	6800      	ldr	r0, [r0, #0]
   1404a:	4b03      	ldr	r3, [pc, #12]	; (14058 <ull_adv_lll_handle_get+0x10>)
   1404c:	1ac0      	subs	r0, r0, r3
   1404e:	23e4      	movs	r3, #228	; 0xe4
   14050:	fbb0 f0f3 	udiv	r0, r0, r3
}
   14054:	b280      	uxth	r0, r0
   14056:	4770      	bx	lr
   14058:	200011ac 	.word	0x200011ac

0001405c <ull_adv_is_enabled_get>:
	if (handle >= BT_CTLR_ADV_MAX) {
   1405c:	b938      	cbnz	r0, 1406e <ull_adv_is_enabled_get+0x12>
	if (!adv || !adv->is_enabled) {
   1405e:	4805      	ldr	r0, [pc, #20]	; (14074 <ull_adv_is_enabled_get+0x18>)
   14060:	f890 30cc 	ldrb.w	r3, [r0, #204]	; 0xcc
	return &ll_adv[handle];
   14064:	f013 0f01 	tst.w	r3, #1
   14068:	bf08      	it	eq
   1406a:	2000      	moveq	r0, #0
   1406c:	4770      	bx	lr
		return NULL;
   1406e:	2000      	movs	r0, #0
}
   14070:	4770      	bx	lr
   14072:	bf00      	nop
   14074:	200011ac 	.word	0x200011ac

00014078 <disable.constprop.5>:
#endif /* CONFIG_BT_PERIPHERAL */

static inline u8_t disable(u16_t handle)
   14078:	b530      	push	{r4, r5, lr}
   1407a:	b085      	sub	sp, #20
{
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   1407c:	2302      	movs	r3, #2
	struct ll_adv_set *adv;
	void *mark;
	u32_t ret;

	adv = ull_adv_is_enabled_get(handle);
   1407e:	2000      	movs	r0, #0
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   14080:	9303      	str	r3, [sp, #12]
	adv = ull_adv_is_enabled_get(handle);
   14082:	f7ff ffeb 	bl	1405c <ull_adv_is_enabled_get>
	if (!adv) {
   14086:	4604      	mov	r4, r0
   14088:	b910      	cbnz	r0, 14090 <disable.constprop.5+0x18>
		ret = ull_ticker_status_take(ret, &ret_cb);
		if (ret) {
			mark = ull_disable_mark(adv);
			LL_ASSERT(mark == adv);

			return BT_HCI_ERR_CMD_DISALLOWED;
   1408a:	200c      	movs	r0, #12
		ull_filter_adv_scan_state_cb(0);
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	return 0;
}
   1408c:	b005      	add	sp, #20
   1408e:	bd30      	pop	{r4, r5, pc}
	mark = ull_disable_mark(adv);
   14090:	f7fe ff82 	bl	12f98 <ull_disable_mark>
	LL_ASSERT(mark == adv);
   14094:	4284      	cmp	r4, r0
   14096:	d00c      	beq.n	140b2 <disable.constprop.5+0x3a>
   14098:	f240 43cd 	movw	r3, #1229	; 0x4cd
   1409c:	4a3a      	ldr	r2, [pc, #232]	; (14188 <disable.constprop.5+0x110>)
   1409e:	493b      	ldr	r1, [pc, #236]	; (1418c <disable.constprop.5+0x114>)
   140a0:	483b      	ldr	r0, [pc, #236]	; (14190 <disable.constprop.5+0x118>)
   140a2:	f00b fe86 	bl	1fdb2 <printk>
   140a6:	4040      	eors	r0, r0
   140a8:	f380 8811 	msr	BASEPRI, r0
   140ac:	f04f 0003 	mov.w	r0, #3
   140b0:	df02      	svc	2
	if (adv->lll.is_hdcd) {
   140b2:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
   140b6:	f013 0f01 	tst.w	r3, #1
   140ba:	ad03      	add	r5, sp, #12
   140bc:	d01f      	beq.n	140fe <disable.constprop.5+0x86>
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   140be:	2103      	movs	r1, #3
   140c0:	9500      	str	r5, [sp, #0]
   140c2:	4b34      	ldr	r3, [pc, #208]	; (14194 <disable.constprop.5+0x11c>)
   140c4:	2201      	movs	r2, #1
   140c6:	2000      	movs	r0, #0
   140c8:	f7fc ffc4 	bl	11054 <ticker_stop>
		ret = ull_ticker_status_take(ret, &ret_cb);
   140cc:	4629      	mov	r1, r5
   140ce:	f7fe ff57 	bl	12f80 <ull_ticker_status_take>
		if (ret) {
   140d2:	b190      	cbz	r0, 140fa <disable.constprop.5+0x82>
			mark = ull_disable_mark(adv);
   140d4:	4620      	mov	r0, r4
   140d6:	f7fe ff5f 	bl	12f98 <ull_disable_mark>
			LL_ASSERT(mark == adv);
   140da:	4284      	cmp	r4, r0
   140dc:	d0d5      	beq.n	1408a <disable.constprop.5+0x12>
   140de:	f240 43d7 	movw	r3, #1239	; 0x4d7
   140e2:	4a29      	ldr	r2, [pc, #164]	; (14188 <disable.constprop.5+0x110>)
   140e4:	4929      	ldr	r1, [pc, #164]	; (1418c <disable.constprop.5+0x114>)
   140e6:	482a      	ldr	r0, [pc, #168]	; (14190 <disable.constprop.5+0x118>)
   140e8:	f00b fe63 	bl	1fdb2 <printk>
   140ec:	4040      	eors	r0, r0
   140ee:	f380 8811 	msr	BASEPRI, r0
   140f2:	f04f 0003 	mov.w	r0, #3
   140f6:	df02      	svc	2
   140f8:	e7c7      	b.n	1408a <disable.constprop.5+0x12>
		ret_cb = TICKER_STATUS_BUSY;
   140fa:	2302      	movs	r3, #2
   140fc:	9303      	str	r3, [sp, #12]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   140fe:	2103      	movs	r1, #3
   14100:	9500      	str	r5, [sp, #0]
   14102:	4b24      	ldr	r3, [pc, #144]	; (14194 <disable.constprop.5+0x11c>)
   14104:	2202      	movs	r2, #2
   14106:	2000      	movs	r0, #0
   14108:	f7fc ffa4 	bl	11054 <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
   1410c:	4629      	mov	r1, r5
   1410e:	f7fe ff37 	bl	12f80 <ull_ticker_status_take>
	if (ret) {
   14112:	b138      	cbz	r0, 14124 <disable.constprop.5+0xac>
		mark = ull_disable_mark(adv);
   14114:	4620      	mov	r0, r4
   14116:	f7fe ff3f 	bl	12f98 <ull_disable_mark>
		LL_ASSERT(mark == adv);
   1411a:	4284      	cmp	r4, r0
   1411c:	d0b5      	beq.n	1408a <disable.constprop.5+0x12>
   1411e:	f240 43e6 	movw	r3, #1254	; 0x4e6
   14122:	e7de      	b.n	140e2 <disable.constprop.5+0x6a>
	ret = ull_disable(&adv->lll);
   14124:	f104 001c 	add.w	r0, r4, #28
   14128:	f7fe ff6e 	bl	13008 <ull_disable>
	LL_ASSERT(!ret);
   1412c:	b160      	cbz	r0, 14148 <disable.constprop.5+0xd0>
   1412e:	f240 43ec 	movw	r3, #1260	; 0x4ec
   14132:	4a15      	ldr	r2, [pc, #84]	; (14188 <disable.constprop.5+0x110>)
   14134:	4918      	ldr	r1, [pc, #96]	; (14198 <disable.constprop.5+0x120>)
   14136:	4816      	ldr	r0, [pc, #88]	; (14190 <disable.constprop.5+0x118>)
   14138:	f00b fe3b 	bl	1fdb2 <printk>
   1413c:	4040      	eors	r0, r0
   1413e:	f380 8811 	msr	BASEPRI, r0
   14142:	f04f 0003 	mov.w	r0, #3
   14146:	df02      	svc	2
	mark = ull_disable_unmark(adv);
   14148:	4620      	mov	r0, r4
   1414a:	f7fe ff2d 	bl	12fa8 <ull_disable_unmark>
	LL_ASSERT(mark == adv);
   1414e:	4284      	cmp	r4, r0
   14150:	d00c      	beq.n	1416c <disable.constprop.5+0xf4>
   14152:	f240 43ef 	movw	r3, #1263	; 0x4ef
   14156:	4a0c      	ldr	r2, [pc, #48]	; (14188 <disable.constprop.5+0x110>)
   14158:	490c      	ldr	r1, [pc, #48]	; (1418c <disable.constprop.5+0x114>)
   1415a:	480d      	ldr	r0, [pc, #52]	; (14190 <disable.constprop.5+0x118>)
   1415c:	f00b fe29 	bl	1fdb2 <printk>
   14160:	4040      	eors	r0, r0
   14162:	f380 8811 	msr	BASEPRI, r0
   14166:	f04f 0003 	mov.w	r0, #3
   1416a:	df02      	svc	2
	if (adv->lll.conn) {
   1416c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1416e:	b113      	cbz	r3, 14176 <disable.constprop.5+0xfe>
		conn_release(adv);
   14170:	4620      	mov	r0, r4
   14172:	f7ff fd01 	bl	13b78 <conn_release>
	adv->is_enabled = 0U;
   14176:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
   1417a:	f36f 0300 	bfc	r3, #0, #1
   1417e:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
	return 0;
   14182:	2000      	movs	r0, #0
   14184:	e782      	b.n	1408c <disable.constprop.5+0x14>
   14186:	bf00      	nop
   14188:	0006458a 	.word	0x0006458a
   1418c:	00064547 	.word	0x00064547
   14190:	000632fe 	.word	0x000632fe
   14194:	00012f75 	.word	0x00012f75
   14198:	00064330 	.word	0x00064330

0001419c <isr_cleanup>:

	isr_cleanup(param);
}

static void isr_cleanup(void *param)
{
   1419c:	b508      	push	{r3, lr}
	int err;

	radio_isr_set(isr_race, param);
   1419e:	4601      	mov	r1, r0
   141a0:	480d      	ldr	r0, [pc, #52]	; (141d8 <isr_cleanup+0x3c>)
   141a2:	f004 fa69 	bl	18678 <radio_isr_set>
	radio_tmr_stop();
   141a6:	f004 fc91 	bl	18acc <radio_tmr_stop>

	err = lll_clk_off();
   141aa:	f7ff fc29 	bl	13a00 <lll_clk_off>
	LL_ASSERT(!err || err == -EBUSY);
   141ae:	b170      	cbz	r0, 141ce <isr_cleanup+0x32>
   141b0:	3010      	adds	r0, #16
   141b2:	d00c      	beq.n	141ce <isr_cleanup+0x32>
   141b4:	f44f 7311 	mov.w	r3, #580	; 0x244
   141b8:	4a08      	ldr	r2, [pc, #32]	; (141dc <isr_cleanup+0x40>)
   141ba:	4909      	ldr	r1, [pc, #36]	; (141e0 <isr_cleanup+0x44>)
   141bc:	4809      	ldr	r0, [pc, #36]	; (141e4 <isr_cleanup+0x48>)
   141be:	f00b fdf8 	bl	1fdb2 <printk>
   141c2:	4040      	eors	r0, r0
   141c4:	f380 8811 	msr	BASEPRI, r0
   141c8:	f04f 0003 	mov.w	r0, #3
   141cc:	df02      	svc	2

	lll_done(NULL);
   141ce:	2000      	movs	r0, #0
}
   141d0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
   141d4:	f7ff bbc2 	b.w	1395c <lll_done>
   141d8:	00024589 	.word	0x00024589
   141dc:	0006463b 	.word	0x0006463b
   141e0:	0006467e 	.word	0x0006467e
   141e4:	000632fe 	.word	0x000632fe

000141e8 <isr_tx>:
{
   141e8:	b537      	push	{r0, r1, r2, r4, r5, lr}
   141ea:	4604      	mov	r4, r0
	radio_status_reset();
   141ec:	f004 fb1e 	bl	1882c <radio_status_reset>
	radio_tmr_status_reset();
   141f0:	f004 fbda 	bl	189a8 <radio_tmr_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
   141f4:	2096      	movs	r0, #150	; 0x96
   141f6:	f004 fbe7 	bl	189c8 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
   141fa:	2300      	movs	r3, #0
   141fc:	461a      	mov	r2, r3
   141fe:	4619      	mov	r1, r3
   14200:	4618      	mov	r0, r3
   14202:	f004 fb5d 	bl	188c0 <radio_switch_complete_and_tx>
	radio_pkt_rx_set(radio_pkt_scratch_get());
   14206:	f004 fb4b 	bl	188a0 <radio_pkt_scratch_get>
   1420a:	f004 faeb 	bl	187e4 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
   1420e:	f004 fb19 	bl	18844 <radio_is_ready>
   14212:	b160      	cbz	r0, 1422e <isr_tx+0x46>
   14214:	f44f 73ab 	mov.w	r3, #342	; 0x156
   14218:	4a17      	ldr	r2, [pc, #92]	; (14278 <isr_tx+0x90>)
   1421a:	4918      	ldr	r1, [pc, #96]	; (1427c <isr_tx+0x94>)
   1421c:	4818      	ldr	r0, [pc, #96]	; (14280 <isr_tx+0x98>)
   1421e:	f00b fdc8 	bl	1fdb2 <printk>
   14222:	4040      	eors	r0, r0
   14224:	f380 8811 	msr	BASEPRI, r0
   14228:	f04f 0003 	mov.w	r0, #3
   1422c:	df02      	svc	2
	radio_isr_set(isr_rx, param);
   1422e:	4621      	mov	r1, r4
   14230:	4814      	ldr	r0, [pc, #80]	; (14284 <isr_tx+0x9c>)
   14232:	f004 fa21 	bl	18678 <radio_isr_set>
	if (ull_filter_lll_rl_enabled()) {
   14236:	f004 f911 	bl	1845c <ull_filter_lll_rl_enabled>
   1423a:	b140      	cbz	r0, 1424e <isr_tx+0x66>
		u8_t count, *irks = ull_filter_lll_irks_get(&count);
   1423c:	f10d 0007 	add.w	r0, sp, #7
   14240:	f004 f848 	bl	182d4 <ull_filter_lll_irks_get>
		radio_ar_configure(count, irks);
   14244:	4601      	mov	r1, r0
   14246:	f89d 0007 	ldrb.w	r0, [sp, #7]
   1424a:	f004 fd19 	bl	18c80 <radio_ar_configure>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   1424e:	f004 fc8f 	bl	18b70 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
   14252:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   14254:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
   14256:	4608      	mov	r0, r1
   14258:	f010 fd63 	bl	24d22 <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
   1425c:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
   1425e:	4605      	mov	r5, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
   14260:	4608      	mov	r0, r1
   14262:	f010 fd5a 	bl	24d1a <radio_tx_chain_delay_get>
   14266:	442c      	add	r4, r5
   14268:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
   1426a:	1a20      	subs	r0, r4, r0
   1426c:	f004 fc3a 	bl	18ae4 <radio_tmr_hcto_configure>
	radio_tmr_end_capture();
   14270:	f004 fc70 	bl	18b54 <radio_tmr_end_capture>
}
   14274:	b003      	add	sp, #12
   14276:	bd30      	pop	{r4, r5, pc}
   14278:	0006463b 	.word	0x0006463b
   1427c:	00064691 	.word	0x00064691
   14280:	000632fe 	.word	0x000632fe
   14284:	0001434d 	.word	0x0001434d

00014288 <is_abort_cb>:
	if (next != curr) {
   14288:	4282      	cmp	r2, r0
{
   1428a:	b508      	push	{r3, lr}
	if (next != curr) {
   1428c:	d01c      	beq.n	142c8 <is_abort_cb+0x40>
		} else if (lll->is_hdcd) {
   1428e:	7b12      	ldrb	r2, [r2, #12]
   14290:	07d2      	lsls	r2, r2, #31
   14292:	d526      	bpl.n	142e2 <is_abort_cb+0x5a>
			*resume_cb = resume_prepare_cb;
   14294:	4a14      	ldr	r2, [pc, #80]	; (142e8 <is_abort_cb+0x60>)
   14296:	601a      	str	r2, [r3, #0]
			*resume_prio = 0; /* TODO: */
   14298:	9b02      	ldr	r3, [sp, #8]
   1429a:	2200      	movs	r2, #0
   1429c:	601a      	str	r2, [r3, #0]
			err = lll_clk_on();
   1429e:	f7ff fba7 	bl	139f0 <lll_clk_on>
			LL_ASSERT(!err || err == -EINPROGRESS);
   142a2:	b170      	cbz	r0, 142c2 <is_abort_cb+0x3a>
   142a4:	3077      	adds	r0, #119	; 0x77
   142a6:	d00c      	beq.n	142c2 <is_abort_cb+0x3a>
   142a8:	f44f 7389 	mov.w	r3, #274	; 0x112
   142ac:	4a0f      	ldr	r2, [pc, #60]	; (142ec <is_abort_cb+0x64>)
   142ae:	4910      	ldr	r1, [pc, #64]	; (142f0 <is_abort_cb+0x68>)
   142b0:	4810      	ldr	r0, [pc, #64]	; (142f4 <is_abort_cb+0x6c>)
   142b2:	f00b fd7e 	bl	1fdb2 <printk>
   142b6:	4040      	eors	r0, r0
   142b8:	f380 8811 	msr	BASEPRI, r0
   142bc:	f04f 0003 	mov.w	r0, #3
   142c0:	df02      	svc	2
   142c2:	f06f 000a 	mvn.w	r0, #10
   142c6:	e00b      	b.n	142e0 <is_abort_cb+0x58>
	return lll_adv_pdu_latest_get(&lll->scan_rsp, is_modified);
}

static inline struct pdu_adv *lll_adv_data_curr_get(struct lll_adv *lll)
{
	return (void *)lll->adv_data.pdu[lll->adv_data.first];
   142c8:	7bd3      	ldrb	r3, [r2, #15]
   142ca:	2127      	movs	r1, #39	; 0x27
   142cc:	fb01 2203 	mla	r2, r1, r3, r2
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   142d0:	7c53      	ldrb	r3, [r2, #17]
   142d2:	f003 030f 	and.w	r3, r3, #15
   142d6:	2b01      	cmp	r3, #1
		return 0;
   142d8:	bf14      	ite	ne
   142da:	f06f 008b 	mvnne.w	r0, #139	; 0x8b
   142de:	2000      	moveq	r0, #0
}
   142e0:	bd08      	pop	{r3, pc}
			return -ECANCELED;
   142e2:	f06f 008b 	mvn.w	r0, #139	; 0x8b
   142e6:	e7fb      	b.n	142e0 <is_abort_cb+0x58>
   142e8:	000245fb 	.word	0x000245fb
   142ec:	0006463b 	.word	0x0006463b
   142f0:	00064627 	.word	0x00064627
   142f4:	000632fe 	.word	0x000632fe

000142f8 <abort_cb>:
{
   142f8:	b510      	push	{r4, lr}
   142fa:	460c      	mov	r4, r1
	if (!prepare_param) {
   142fc:	b930      	cbnz	r0, 1430c <abort_cb+0x14>
		radio_isr_set(isr_abort, param);
   142fe:	480f      	ldr	r0, [pc, #60]	; (1433c <abort_cb+0x44>)
   14300:	f004 f9ba 	bl	18678 <radio_isr_set>
}
   14304:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
   14308:	f004 ba7e 	b.w	18808 <radio_disable>
	err = lll_clk_off();
   1430c:	f7ff fb78 	bl	13a00 <lll_clk_off>
	LL_ASSERT(!err || err == -EBUSY);
   14310:	b170      	cbz	r0, 14330 <abort_cb+0x38>
   14312:	3010      	adds	r0, #16
   14314:	d00c      	beq.n	14330 <abort_cb+0x38>
   14316:	f44f 739c 	mov.w	r3, #312	; 0x138
   1431a:	4a09      	ldr	r2, [pc, #36]	; (14340 <abort_cb+0x48>)
   1431c:	4909      	ldr	r1, [pc, #36]	; (14344 <abort_cb+0x4c>)
   1431e:	480a      	ldr	r0, [pc, #40]	; (14348 <abort_cb+0x50>)
   14320:	f00b fd47 	bl	1fdb2 <printk>
   14324:	4040      	eors	r0, r0
   14326:	f380 8811 	msr	BASEPRI, r0
   1432a:	f04f 0003 	mov.w	r0, #3
   1432e:	df02      	svc	2
	lll_done(param);
   14330:	4620      	mov	r0, r4
}
   14332:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
   14336:	f7ff bb11 	b.w	1395c <lll_done>
   1433a:	bf00      	nop
   1433c:	0002458d 	.word	0x0002458d
   14340:	0006463b 	.word	0x0006463b
   14344:	0006467e 	.word	0x0006467e
   14348:	000632fe 	.word	0x000632fe

0001434c <isr_rx>:
{
   1434c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   14350:	4604      	mov	r4, r0
	trx_done = radio_is_done();
   14352:	f004 fa81 	bl	18858 <radio_is_done>
   14356:	b2c5      	uxtb	r5, r0
	if (trx_done) {
   14358:	2d00      	cmp	r5, #0
   1435a:	d04d      	beq.n	143f8 <isr_rx+0xac>
		crc_ok = radio_crc_is_valid();
   1435c:	f004 fa92 	bl	18884 <radio_crc_is_valid>
   14360:	fa5f f880 	uxtb.w	r8, r0
		devmatch_ok = radio_filter_has_match();
   14364:	f004 fb04 	bl	18970 <radio_filter_has_match>
   14368:	fa5f f980 	uxtb.w	r9, r0
		devmatch_id = radio_filter_match_get();
   1436c:	f004 fb0a 	bl	18984 <radio_filter_match_get>
		irkmatch_ok = radio_ar_has_match();
   14370:	f004 fcc4 	bl	18cfc <radio_ar_has_match>
   14374:	b2c6      	uxtb	r6, r0
		irkmatch_id = radio_ar_match_get();
   14376:	f004 fcaf 	bl	18cd8 <radio_ar_match_get>
   1437a:	b2c7      	uxtb	r7, r0
		rssi_ready = radio_rssi_is_ready();
   1437c:	f004 fac0 	bl	18900 <radio_rssi_is_ready>
	radio_status_reset();
   14380:	f004 fa54 	bl	1882c <radio_status_reset>
	radio_tmr_status_reset();
   14384:	f004 fb10 	bl	189a8 <radio_tmr_status_reset>
	radio_filter_status_reset();
   14388:	f004 faea 	bl	18960 <radio_filter_status_reset>
	radio_ar_status_reset();
   1438c:	f004 fcaa 	bl	18ce4 <radio_ar_status_reset>
	radio_rssi_status_reset();
   14390:	f004 faae 	bl	188f0 <radio_rssi_status_reset>
	if (!trx_done) {
   14394:	2d00      	cmp	r5, #0
   14396:	f000 8137 	beq.w	14608 <isr_rx+0x2bc>
	if (crc_ok) {
   1439a:	f1b8 0f00 	cmp.w	r8, #0
   1439e:	f000 8133 	beq.w	14608 <isr_rx+0x2bc>
{
	struct pdu_adv *pdu_rx, *pdu_adv;

#if defined(CONFIG_BT_CTLR_PRIVACY)
	/* An IRK match implies address resolution enabled */
	u8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
   143a2:	b376      	cbz	r6, 14402 <isr_rx+0xb6>
   143a4:	4638      	mov	r0, r7
   143a6:	f003 ff9f 	bl	182e8 <ull_filter_lll_rl_irk_idx>
   143aa:	f88d 0007 	strb.w	r0, [sp, #7]
				    FILTER_IDX_NONE;
#else
	u8_t rl_idx = FILTER_IDX_NONE;
#endif /* CONFIG_BT_CTLR_PRIVACY */

	pdu_rx = (void *)radio_pkt_scratch_get();
   143ae:	f004 fa77 	bl	188a0 <radio_pkt_scratch_get>
   143b2:	7be2      	ldrb	r2, [r4, #15]
   143b4:	4605      	mov	r5, r0
	pdu_adv = lll_adv_data_curr_get(lll);

	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
   143b6:	7800      	ldrb	r0, [r0, #0]
   143b8:	2311      	movs	r3, #17
   143ba:	2727      	movs	r7, #39	; 0x27
   143bc:	fb17 3702 	smlabb	r7, r7, r2, r3
   143c0:	f000 030f 	and.w	r3, r0, #15
   143c4:	2b03      	cmp	r3, #3
   143c6:	eb04 0807 	add.w	r8, r4, r7
   143ca:	d157      	bne.n	1447c <isr_rx+0x130>
   143cc:	786b      	ldrb	r3, [r5, #1]
   143ce:	2b0c      	cmp	r3, #12
   143d0:	f040 811a 	bne.w	14608 <isr_rx+0x2bc>
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
	    (pdu_adv->type != PDU_ADV_TYPE_DIRECT_IND) &&
   143d4:	5de3      	ldrb	r3, [r4, r7]
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
   143d6:	f003 030f 	and.w	r3, r3, #15
   143da:	2b01      	cmp	r3, #1
   143dc:	f000 8114 	beq.w	14608 <isr_rx+0x2bc>
static inline bool isr_rx_sr_check(struct lll_adv *lll, struct pdu_adv *adv,
				   struct pdu_adv *sr, u8_t devmatch_ok,
				   u8_t *rl_idx)
{
#if defined(CONFIG_BT_CTLR_PRIVACY)
	return ((((lll->filter_policy & 0x01) == 0) &&
   143e0:	7b63      	ldrb	r3, [r4, #13]
		 ull_filter_lll_rl_addr_allowed(sr->tx_addr,
						sr->scan_req.scan_addr,
						rl_idx)) ||
		(((lll->filter_policy & 0x01) != 0) &&
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   143e2:	07da      	lsls	r2, r3, #31
   143e4:	d50f      	bpl.n	14406 <isr_rx+0xba>
		(((lll->filter_policy & 0x01) != 0) &&
   143e6:	f1b9 0f00 	cmp.w	r9, #0
   143ea:	d114      	bne.n	14416 <isr_rx+0xca>
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   143ec:	f89d 0007 	ldrb.w	r0, [sp, #7]
   143f0:	f003 ffc4 	bl	1837c <ull_filter_lll_irk_whitelisted>
   143f4:	b978      	cbnz	r0, 14416 <isr_rx+0xca>
   143f6:	e041      	b.n	1447c <isr_rx+0x130>
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
   143f8:	462e      	mov	r6, r5
   143fa:	46a9      	mov	r9, r5
   143fc:	46a8      	mov	r8, r5
		devmatch_id = irkmatch_id = 0xFF;
   143fe:	27ff      	movs	r7, #255	; 0xff
   14400:	e7be      	b.n	14380 <isr_rx+0x34>
	u8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
   14402:	20ff      	movs	r0, #255	; 0xff
   14404:	e7d1      	b.n	143aa <isr_rx+0x5e>
		 ull_filter_lll_rl_addr_allowed(sr->tx_addr,
   14406:	f10d 0207 	add.w	r2, sp, #7
   1440a:	1ca9      	adds	r1, r5, #2
   1440c:	f3c0 1080 	ubfx	r0, r0, #6, #1
   14410:	f003 ffe8 	bl	183e4 <ull_filter_lll_rl_addr_allowed>
	return ((((lll->filter_policy & 0x01) == 0) &&
   14414:	b378      	cbz	r0, 14476 <isr_rx+0x12a>
}

static inline bool isr_rx_sr_adva_check(struct pdu_adv *adv,
					struct pdu_adv *sr)
{
	return (adv->tx_addr == sr->rx_addr) &&
   14416:	5de3      	ldrb	r3, [r4, r7]
   14418:	782a      	ldrb	r2, [r5, #0]
   1441a:	f3c3 1380 	ubfx	r3, r3, #6, #1
   1441e:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
   14422:	d12b      	bne.n	1447c <isr_rx+0x130>
		!memcmp(adv->adv_ind.addr, sr->scan_req.adv_addr, BDADDR_SIZE);
   14424:	2206      	movs	r2, #6
   14426:	f105 0108 	add.w	r1, r5, #8
   1442a:	f108 0002 	add.w	r0, r8, #2
   1442e:	f7ed fbcf 	bl	1bd0 <memcmp>
	    (pdu_adv->type != PDU_ADV_TYPE_DIRECT_IND) &&
   14432:	bb18      	cbnz	r0, 1447c <isr_rx+0x130>
		radio_isr_set(isr_done, lll);
   14434:	4621      	mov	r1, r4
   14436:	4878      	ldr	r0, [pc, #480]	; (14618 <isr_rx+0x2cc>)
   14438:	f004 f91e 	bl	18678 <radio_isr_set>
		radio_switch_complete_and_disable();
   1443c:	f004 fa4a 	bl	188d4 <radio_switch_complete_and_disable>
}

static inline struct pdu_adv *lll_adv_scan_rsp_curr_get(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.first];
   14440:	f894 005f 	ldrb.w	r0, [r4, #95]	; 0x5f
   14444:	2327      	movs	r3, #39	; 0x27
   14446:	fb03 4000 	mla	r0, r3, r0, r4
		radio_pkt_tx_set(lll_adv_scan_rsp_curr_get(lll));
   1444a:	3061      	adds	r0, #97	; 0x61
   1444c:	f004 f9d0 	bl	187f0 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
   14450:	f004 f9f8 	bl	18844 <radio_is_ready>
   14454:	b160      	cbz	r0, 14470 <isr_rx+0x124>
   14456:	f240 2396 	movw	r3, #662	; 0x296
   1445a:	4a70      	ldr	r2, [pc, #448]	; (1461c <isr_rx+0x2d0>)
   1445c:	4970      	ldr	r1, [pc, #448]	; (14620 <isr_rx+0x2d4>)
   1445e:	4871      	ldr	r0, [pc, #452]	; (14624 <isr_rx+0x2d8>)
   14460:	f00b fca7 	bl	1fdb2 <printk>
   14464:	4040      	eors	r0, r0
   14466:	f380 8811 	msr	BASEPRI, r0
   1446a:	f04f 0003 	mov.w	r0, #3
   1446e:	df02      	svc	2
}
   14470:	b003      	add	sp, #12
   14472:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		(((lll->filter_policy & 0x01) != 0) &&
   14476:	7b63      	ldrb	r3, [r4, #13]
						rl_idx)) ||
   14478:	07db      	lsls	r3, r3, #31
   1447a:	d4b4      	bmi.n	143e6 <isr_rx+0x9a>
	} else if ((pdu_rx->type == PDU_ADV_TYPE_CONNECT_IND) &&
   1447c:	7828      	ldrb	r0, [r5, #0]
   1447e:	f000 030f 	and.w	r3, r0, #15
   14482:	2b05      	cmp	r3, #5
   14484:	f040 80c0 	bne.w	14608 <isr_rx+0x2bc>
   14488:	786b      	ldrb	r3, [r5, #1]
   1448a:	2b22      	cmp	r3, #34	; 0x22
   1448c:	f040 80bc 	bne.w	14608 <isr_rx+0x2bc>
static inline bool isr_rx_ci_check(struct lll_adv *lll, struct pdu_adv *adv,
				   struct pdu_adv *ci, u8_t devmatch_ok,
				   u8_t *rl_idx)
{
	/* LL 4.3.2: filter policy shall be ignored for directed adv */
	if (adv->type == PDU_ADV_TYPE_DIRECT_IND) {
   14490:	5de3      	ldrb	r3, [r4, r7]
   14492:	f003 030f 	and.w	r3, r3, #15
   14496:	2b01      	cmp	r3, #1
   14498:	f040 8097 	bne.w	145ca <isr_rx+0x27e>
#if defined(CONFIG_BT_CTLR_PRIVACY)
		return ull_filter_lll_rl_addr_allowed(ci->tx_addr,
						      ci->connect_ind.init_addr,
   1449c:	f105 0902 	add.w	r9, r5, #2
		return ull_filter_lll_rl_addr_allowed(ci->tx_addr,
   144a0:	f10d 0207 	add.w	r2, sp, #7
   144a4:	4649      	mov	r1, r9
   144a6:	f3c0 1080 	ubfx	r0, r0, #6, #1
   144aa:	f003 ff9b 	bl	183e4 <ull_filter_lll_rl_addr_allowed>
						      rl_idx) &&
#else
		return (1) &&
#endif
		       isr_rx_ci_adva_check(adv, ci) &&
   144ae:	b908      	cbnz	r0, 144b4 <isr_rx+0x168>
	return ((((lll->filter_policy & 0x02) == 0) &&
		 ull_filter_lll_rl_addr_allowed(ci->tx_addr,
						ci->connect_ind.init_addr,
						rl_idx)) ||
		(((lll->filter_policy & 0x02) != 0) &&
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   144b0:	2000      	movs	r0, #0
   144b2:	e00d      	b.n	144d0 <isr_rx+0x184>
		       isr_rx_ci_adva_check(adv, ci) &&
   144b4:	4629      	mov	r1, r5
   144b6:	4640      	mov	r0, r8
   144b8:	f010 f87b 	bl	245b2 <isr_rx_ci_adva_check>
						      rl_idx) &&
   144bc:	2800      	cmp	r0, #0
   144be:	d0f7      	beq.n	144b0 <isr_rx+0x164>
		       isr_rx_ci_tgta_check(lll, adv, ci, *rl_idx);
   144c0:	f89d 3007 	ldrb.w	r3, [sp, #7]
static inline bool isr_rx_ci_tgta_check(struct lll_adv *lll,
					struct pdu_adv *adv, struct pdu_adv *ci,
					u8_t rl_idx)
{
#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (rl_idx != FILTER_IDX_NONE) {
   144c4:	2bff      	cmp	r3, #255	; 0xff
   144c6:	d06e      	beq.n	145a6 <isr_rx+0x25a>
		return rl_idx == lll->rl_idx;
   144c8:	7ba0      	ldrb	r0, [r4, #14]
   144ca:	1ac7      	subs	r7, r0, r3
   144cc:	4278      	negs	r0, r7
   144ce:	4178      	adcs	r0, r7
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   144d0:	f000 0001 	and.w	r0, r0, #1
		   (pdu_rx->len == sizeof(struct pdu_adv_connect_ind)) &&
   144d4:	2800      	cmp	r0, #0
   144d6:	f000 8097 	beq.w	14608 <isr_rx+0x2bc>
				   &rl_idx) &&
   144da:	68a3      	ldr	r3, [r4, #8]
   144dc:	2b00      	cmp	r3, #0
   144de:	f000 8093 	beq.w	14608 <isr_rx+0x2bc>
			rx = ull_pdu_rx_alloc_peek(4);
   144e2:	2004      	movs	r0, #4
   144e4:	f7fe fdcc 	bl	13080 <ull_pdu_rx_alloc_peek>
		if (!rx) {
   144e8:	2800      	cmp	r0, #0
   144ea:	f000 808d 	beq.w	14608 <isr_rx+0x2bc>
		radio_isr_set(isr_abort, lll);
   144ee:	4621      	mov	r1, r4
   144f0:	484d      	ldr	r0, [pc, #308]	; (14628 <isr_rx+0x2dc>)
   144f2:	f004 f8c1 	bl	18678 <radio_isr_set>
		radio_disable();
   144f6:	f004 f987 	bl	18808 <radio_disable>
		LL_ASSERT(!radio_is_ready());
   144fa:	f004 f9a3 	bl	18844 <radio_is_ready>
   144fe:	b160      	cbz	r0, 1451a <isr_rx+0x1ce>
   14500:	f240 23d2 	movw	r3, #722	; 0x2d2
   14504:	4a45      	ldr	r2, [pc, #276]	; (1461c <isr_rx+0x2d0>)
   14506:	4946      	ldr	r1, [pc, #280]	; (14620 <isr_rx+0x2d4>)
   14508:	4846      	ldr	r0, [pc, #280]	; (14624 <isr_rx+0x2d8>)
   1450a:	f00b fc52 	bl	1fdb2 <printk>
   1450e:	4040      	eors	r0, r0
   14510:	f380 8811 	msr	BASEPRI, r0
   14514:	f04f 0003 	mov.w	r0, #3
   14518:	df02      	svc	2
}

static inline int lll_stop(void *lll)
{
	struct lll_hdr *hdr = lll;
	int ret = !!hdr->is_stop;
   1451a:	7923      	ldrb	r3, [r4, #4]

	hdr->is_stop = 1U;
   1451c:	f043 0201 	orr.w	r2, r3, #1
		LL_ASSERT(!ret);
   14520:	07db      	lsls	r3, r3, #31
   14522:	7122      	strb	r2, [r4, #4]
   14524:	d50c      	bpl.n	14540 <isr_rx+0x1f4>
   14526:	f44f 7338 	mov.w	r3, #736	; 0x2e0
   1452a:	4a3c      	ldr	r2, [pc, #240]	; (1461c <isr_rx+0x2d0>)
   1452c:	493f      	ldr	r1, [pc, #252]	; (1462c <isr_rx+0x2e0>)
   1452e:	483d      	ldr	r0, [pc, #244]	; (14624 <isr_rx+0x2d8>)
   14530:	f00b fc3f 	bl	1fdb2 <printk>
   14534:	4040      	eors	r0, r0
   14536:	f380 8811 	msr	BASEPRI, r0
   1453a:	f04f 0003 	mov.w	r0, #3
   1453e:	df02      	svc	2
		rx = ull_pdu_rx_alloc();
   14540:	f7fe fdb6 	bl	130b0 <ull_pdu_rx_alloc>
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   14544:	2308      	movs	r3, #8
   14546:	7103      	strb	r3, [r0, #4]
		rx->hdr.handle = 0xffff;
   14548:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1454c:	80c3      	strh	r3, [r0, #6]
		rx = ull_pdu_rx_alloc();
   1454e:	4607      	mov	r7, r0
   14550:	f100 0320 	add.w	r3, r0, #32
   14554:	f105 0224 	add.w	r2, r5, #36	; 0x24
   14558:	f855 1b04 	ldr.w	r1, [r5], #4
   1455c:	f843 1b04 	str.w	r1, [r3], #4
   14560:	4295      	cmp	r5, r2
   14562:	d1f9      	bne.n	14558 <isr_rx+0x20c>
		ftr->param = lll;
   14564:	60bc      	str	r4, [r7, #8]
		ftr->ticks_anchor = radio_tmr_start_get();
   14566:	f004 faab 	bl	18ac0 <radio_tmr_start_get>
   1456a:	6138      	str	r0, [r7, #16]
		ftr->us_radio_end = radio_tmr_end_get() -
   1456c:	f004 fafa 	bl	18b64 <radio_tmr_end_get>
				    radio_tx_chain_delay_get(0, 0);
   14570:	2100      	movs	r1, #0
		ftr->us_radio_end = radio_tmr_end_get() -
   14572:	4604      	mov	r4, r0
				    radio_tx_chain_delay_get(0, 0);
   14574:	4608      	mov	r0, r1
   14576:	f010 fbd0 	bl	24d1a <radio_tx_chain_delay_get>
		ftr->us_radio_rdy = radio_rx_ready_delay_get(0, 0);
   1457a:	2100      	movs	r1, #0
		ftr->us_radio_end = radio_tmr_end_get() -
   1457c:	1a20      	subs	r0, r4, r0
   1457e:	6178      	str	r0, [r7, #20]
		ftr->us_radio_rdy = radio_rx_ready_delay_get(0, 0);
   14580:	4608      	mov	r0, r1
   14582:	f010 fbcc 	bl	24d1e <radio_rx_ready_delay_get>
   14586:	61b8      	str	r0, [r7, #24]
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
   14588:	2e00      	cmp	r6, #0
   1458a:	d03b      	beq.n	14604 <isr_rx+0x2b8>
   1458c:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14590:	777b      	strb	r3, [r7, #29]
			ftr->extra = ull_pdu_rx_alloc();
   14592:	f7fe fd8d 	bl	130b0 <ull_pdu_rx_alloc>
		ull_rx_put(rx->hdr.link, rx);
   14596:	4639      	mov	r1, r7
			ftr->extra = ull_pdu_rx_alloc();
   14598:	60f8      	str	r0, [r7, #12]
		ull_rx_put(rx->hdr.link, rx);
   1459a:	6838      	ldr	r0, [r7, #0]
   1459c:	f7fe fd9e 	bl	130dc <ull_rx_put>
		ull_rx_sched();
   145a0:	f7fe fdac 	bl	130fc <ull_rx_sched>
		if (!err) {
   145a4:	e764      	b.n	14470 <isr_rx+0x124>
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */
	return (adv->rx_addr == ci->tx_addr) &&
   145a6:	782b      	ldrb	r3, [r5, #0]
   145a8:	5de2      	ldrb	r2, [r4, r7]
   145aa:	f3c3 1380 	ubfx	r3, r3, #6, #1
   145ae:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
   145b2:	f47f af7d 	bne.w	144b0 <isr_rx+0x164>
	       !memcmp(adv->direct_ind.tgt_addr, ci->connect_ind.init_addr,
   145b6:	2206      	movs	r2, #6
   145b8:	4649      	mov	r1, r9
   145ba:	f108 0008 	add.w	r0, r8, #8
   145be:	f7ed fb07 	bl	1bd0 <memcmp>
	return (adv->rx_addr == ci->tx_addr) &&
   145c2:	fab0 f080 	clz	r0, r0
   145c6:	0940      	lsrs	r0, r0, #5
   145c8:	e782      	b.n	144d0 <isr_rx+0x184>
	return ((((lll->filter_policy & 0x02) == 0) &&
   145ca:	7b63      	ldrb	r3, [r4, #13]
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   145cc:	0799      	lsls	r1, r3, #30
   145ce:	d508      	bpl.n	145e2 <isr_rx+0x296>
		(((lll->filter_policy & 0x02) != 0) &&
   145d0:	f1b9 0f00 	cmp.w	r9, #0
   145d4:	d10d      	bne.n	145f2 <isr_rx+0x2a6>
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   145d6:	f89d 0007 	ldrb.w	r0, [sp, #7]
   145da:	f003 fecf 	bl	1837c <ull_filter_lll_irk_whitelisted>
   145de:	b940      	cbnz	r0, 145f2 <isr_rx+0x2a6>
   145e0:	e766      	b.n	144b0 <isr_rx+0x164>
		 ull_filter_lll_rl_addr_allowed(ci->tx_addr,
   145e2:	f10d 0207 	add.w	r2, sp, #7
   145e6:	1ca9      	adds	r1, r5, #2
   145e8:	f3c0 1080 	ubfx	r0, r0, #6, #1
   145ec:	f003 fefa 	bl	183e4 <ull_filter_lll_rl_addr_allowed>
	return ((((lll->filter_policy & 0x02) == 0) &&
   145f0:	b120      	cbz	r0, 145fc <isr_rx+0x2b0>
	       isr_rx_ci_adva_check(adv, ci);
   145f2:	4629      	mov	r1, r5
   145f4:	4640      	mov	r0, r8
   145f6:	f00f ffdc 	bl	245b2 <isr_rx_ci_adva_check>
   145fa:	e769      	b.n	144d0 <isr_rx+0x184>
		(((lll->filter_policy & 0x02) != 0) &&
   145fc:	7b63      	ldrb	r3, [r4, #13]
						rl_idx)) ||
   145fe:	079a      	lsls	r2, r3, #30
   14600:	d4e6      	bmi.n	145d0 <isr_rx+0x284>
   14602:	e755      	b.n	144b0 <isr_rx+0x164>
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
   14604:	23ff      	movs	r3, #255	; 0xff
   14606:	e7c3      	b.n	14590 <isr_rx+0x244>
	radio_isr_set(isr_done, param);
   14608:	4621      	mov	r1, r4
   1460a:	4803      	ldr	r0, [pc, #12]	; (14618 <isr_rx+0x2cc>)
   1460c:	f004 f834 	bl	18678 <radio_isr_set>
	radio_disable();
   14610:	f004 f8fa 	bl	18808 <radio_disable>
   14614:	e72c      	b.n	14470 <isr_rx+0x124>
   14616:	bf00      	nop
   14618:	00024623 	.word	0x00024623
   1461c:	0006463b 	.word	0x0006463b
   14620:	00064691 	.word	0x00064691
   14624:	000632fe 	.word	0x000632fe
   14628:	0002458d 	.word	0x0002458d
   1462c:	00064330 	.word	0x00064330

00014630 <chan_prepare>:
{
   14630:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	first = pdu->first;
   14632:	7bc3      	ldrb	r3, [r0, #15]
	if (first != pdu->last) {
   14634:	7c02      	ldrb	r2, [r0, #16]
   14636:	4293      	cmp	r3, r2
   14638:	4604      	mov	r4, r0
   1463a:	d061      	beq.n	14700 <chan_prepare+0xd0>
		first += 1U;
   1463c:	1c5a      	adds	r2, r3, #1
   1463e:	b2d2      	uxtb	r2, r2
			first = 0U;
   14640:	2a02      	cmp	r2, #2
   14642:	bf08      	it	eq
   14644:	2200      	moveq	r2, #0
		pdu->first = first;
   14646:	73c2      	strb	r2, [r0, #15]
		*is_modified = 1U;
   14648:	f04f 0e01 	mov.w	lr, #1
	first = pdu->first;
   1464c:	4621      	mov	r1, r4
	return (void *)pdu->pdu[first];
   1464e:	2527      	movs	r5, #39	; 0x27
   14650:	f04f 0c02 	mov.w	ip, #2
   14654:	fb15 c702 	smlabb	r7, r5, r2, ip
	if (first != pdu->last) {
   14658:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
	first = pdu->first;
   1465c:	f811 2f5f 	ldrb.w	r2, [r1, #95]!
	return (void *)pdu->pdu[first];
   14660:	f104 060f 	add.w	r6, r4, #15
	if (first != pdu->last) {
   14664:	4293      	cmp	r3, r2
	return (void *)pdu->pdu[first];
   14666:	eb06 0007 	add.w	r0, r6, r7
	if (first != pdu->last) {
   1466a:	d04c      	beq.n	14706 <chan_prepare+0xd6>
		first += 1U;
   1466c:	3201      	adds	r2, #1
   1466e:	b2d3      	uxtb	r3, r2
			first = 0U;
   14670:	4563      	cmp	r3, ip
   14672:	bf08      	it	eq
   14674:	2300      	moveq	r3, #0
		pdu->first = first;
   14676:	f884 305f 	strb.w	r3, [r4, #95]	; 0x5f
	return (void *)pdu->pdu[first];
   1467a:	fb15 c303 	smlabb	r3, r5, r3, ip
   1467e:	4419      	add	r1, r3
   14680:	4603      	mov	r3, r0
   14682:	f853 2f02 	ldr.w	r2, [r3, #2]!
   14686:	f8c1 2002 	str.w	r2, [r1, #2]
   1468a:	889b      	ldrh	r3, [r3, #4]
   1468c:	80cb      	strh	r3, [r1, #6]
	radio_pkt_tx_set(pdu);
   1468e:	f004 f8af 	bl	187f0 <radio_pkt_tx_set>
	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
   14692:	5df3      	ldrb	r3, [r6, r7]
   14694:	f003 030f 	and.w	r3, r3, #15
   14698:	2b02      	cmp	r3, #2
		radio_isr_set(isr_tx, lll);
   1469a:	4621      	mov	r1, r4
	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
   1469c:	d03a      	beq.n	14714 <chan_prepare+0xe4>
		radio_isr_set(isr_tx, lll);
   1469e:	4820      	ldr	r0, [pc, #128]	; (14720 <chan_prepare+0xf0>)
   146a0:	f003 ffea 	bl	18678 <radio_isr_set>
		radio_tmr_tifs_set(EVENT_IFS_US);
   146a4:	2096      	movs	r0, #150	; 0x96
   146a6:	f004 f98f 	bl	189c8 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
   146aa:	2000      	movs	r0, #0
   146ac:	f004 f8fc 	bl	188a8 <radio_switch_complete_and_rx>
	chan = find_lsb_set(lll->chan_map_curr);
   146b0:	7b23      	ldrb	r3, [r4, #12]
   146b2:	f3c3 1302 	ubfx	r3, r3, #4, #3
   146b6:	2b00      	cmp	r3, #0
   146b8:	fa93 f0a3 	rbit	r0, r3
   146bc:	fab0 f080 	clz	r0, r0
   146c0:	bf08      	it	eq
   146c2:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
	LL_ASSERT(chan);
   146c6:	1c45      	adds	r5, r0, #1
   146c8:	d10c      	bne.n	146e4 <chan_prepare+0xb4>
   146ca:	f44f 731d 	mov.w	r3, #628	; 0x274
   146ce:	4a15      	ldr	r2, [pc, #84]	; (14724 <chan_prepare+0xf4>)
   146d0:	4915      	ldr	r1, [pc, #84]	; (14728 <chan_prepare+0xf8>)
   146d2:	4816      	ldr	r0, [pc, #88]	; (1472c <chan_prepare+0xfc>)
   146d4:	f00b fb6d 	bl	1fdb2 <printk>
   146d8:	4040      	eors	r0, r0
   146da:	f380 8811 	msr	BASEPRI, r0
   146de:	f04f 0003 	mov.w	r0, #3
   146e2:	df02      	svc	2
	lll->chan_map_curr &= (lll->chan_map_curr - 1);
   146e4:	7b23      	ldrb	r3, [r4, #12]
   146e6:	f3c3 1202 	ubfx	r2, r3, #4, #3
   146ea:	1e51      	subs	r1, r2, #1
   146ec:	400a      	ands	r2, r1
   146ee:	f362 1306 	bfi	r3, r2, #4, #3
   146f2:	7323      	strb	r3, [r4, #12]
	lll_chan_set(36 + chan);
   146f4:	f105 0024 	add.w	r0, r5, #36	; 0x24
}
   146f8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	lll_chan_set(36 + chan);
   146fc:	f7ff b988 	b.w	13a10 <lll_chan_set>
	u8_t upd = 0U;
   14700:	f04f 0e00 	mov.w	lr, #0
   14704:	e7a2      	b.n	1464c <chan_prepare+0x1c>
	if (upd) {
   14706:	f1be 0f00 	cmp.w	lr, #0
   1470a:	d0c0      	beq.n	1468e <chan_prepare+0x5e>
   1470c:	fb15 c503 	smlabb	r5, r5, r3, ip
   14710:	4429      	add	r1, r5
   14712:	e7b5      	b.n	14680 <chan_prepare+0x50>
		radio_isr_set(isr_done, lll);
   14714:	4806      	ldr	r0, [pc, #24]	; (14730 <chan_prepare+0x100>)
   14716:	f003 ffaf 	bl	18678 <radio_isr_set>
		radio_switch_complete_and_disable();
   1471a:	f004 f8db 	bl	188d4 <radio_switch_complete_and_disable>
   1471e:	e7c7      	b.n	146b0 <chan_prepare+0x80>
   14720:	000141e9 	.word	0x000141e9
   14724:	0006463b 	.word	0x0006463b
   14728:	00064460 	.word	0x00064460
   1472c:	000632fe 	.word	0x000632fe
   14730:	00024623 	.word	0x00024623

00014734 <prepare_cb>:
{
   14734:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct lll_adv *lll = prepare_param->param;
   14736:	68c4      	ldr	r4, [r0, #12]
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
   14738:	4b40      	ldr	r3, [pc, #256]	; (1483c <prepare_cb+0x108>)

static inline int lll_is_stop(void *lll)
{
	struct lll_hdr *hdr = lll;

	return !!hdr->is_stop;
   1473a:	7925      	ldrb	r5, [r4, #4]
   1473c:	9301      	str	r3, [sp, #4]
	if (lll_is_stop(lll)) {
   1473e:	f015 0501 	ands.w	r5, r5, #1
{
   14742:	4606      	mov	r6, r0
	if (lll_is_stop(lll)) {
   14744:	d016      	beq.n	14774 <prepare_cb+0x40>
		err = lll_clk_off();
   14746:	f7ff f95b 	bl	13a00 <lll_clk_off>
		LL_ASSERT(!err || err == -EBUSY);
   1474a:	b168      	cbz	r0, 14768 <prepare_cb+0x34>
   1474c:	3010      	adds	r0, #16
   1474e:	d00b      	beq.n	14768 <prepare_cb+0x34>
   14750:	238a      	movs	r3, #138	; 0x8a
   14752:	4a3b      	ldr	r2, [pc, #236]	; (14840 <prepare_cb+0x10c>)
   14754:	493b      	ldr	r1, [pc, #236]	; (14844 <prepare_cb+0x110>)
   14756:	483c      	ldr	r0, [pc, #240]	; (14848 <prepare_cb+0x114>)
   14758:	f00b fb2b 	bl	1fdb2 <printk>
   1475c:	4040      	eors	r0, r0
   1475e:	f380 8811 	msr	BASEPRI, r0
   14762:	f04f 0003 	mov.w	r0, #3
   14766:	df02      	svc	2
		lll_done(NULL);
   14768:	2000      	movs	r0, #0
   1476a:	f7ff f8f7 	bl	1395c <lll_done>
}
   1476e:	2000      	movs	r0, #0
   14770:	b003      	add	sp, #12
   14772:	bdf0      	pop	{r4, r5, r6, r7, pc}
	radio_reset();
   14774:	f003 ffa0 	bl	186b8 <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   14778:	4628      	mov	r0, r5
   1477a:	f003 ffd1 	bl	18720 <radio_tx_power_set>
	radio_phy_set(0, 0);
   1477e:	4629      	mov	r1, r5
   14780:	4628      	mov	r0, r5
   14782:	f003 ffbd 	bl	18700 <radio_phy_set>
	radio_pkt_configure(8, PDU_AC_PAYLOAD_SIZE_MAX, 0);
   14786:	462a      	mov	r2, r5
   14788:	2125      	movs	r1, #37	; 0x25
   1478a:	2008      	movs	r0, #8
   1478c:	f003 fffe 	bl	1878c <radio_pkt_configure>
	radio_aa_set((u8_t *)&aa);
   14790:	a801      	add	r0, sp, #4
   14792:	f003 ffe3 	bl	1875c <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
   14796:	492d      	ldr	r1, [pc, #180]	; (1484c <prepare_cb+0x118>)
   14798:	f240 605b 	movw	r0, #1627	; 0x65b
   1479c:	f004 f866 	bl	1886c <radio_crc_configure>
	lll->chan_map_curr = lll->chan_map;
   147a0:	7b23      	ldrb	r3, [r4, #12]
   147a2:	f3c3 0242 	ubfx	r2, r3, #1, #3
   147a6:	f362 1306 	bfi	r3, r2, #4, #3
   147aa:	7323      	strb	r3, [r4, #12]
	chan_prepare(lll);
   147ac:	4620      	mov	r0, r4
   147ae:	f7ff ff3f 	bl	14630 <chan_prepare>
	if (ull_filter_lll_rl_enabled()) {
   147b2:	f003 fe53 	bl	1845c <ull_filter_lll_rl_enabled>
   147b6:	7b63      	ldrb	r3, [r4, #13]
   147b8:	b348      	cbz	r0, 1480e <prepare_cb+0xda>
			ull_filter_lll_get(!!(lll->filter_policy));
   147ba:	f013 0003 	ands.w	r0, r3, #3
   147be:	bf18      	it	ne
   147c0:	2001      	movne	r0, #1
		struct lll_filter *wl = ull_filter_lll_get(true);
   147c2:	f003 fe03 	bl	183cc <ull_filter_lll_get>
		radio_filter_configure(wl->enable_bitmask,
   147c6:	1c82      	adds	r2, r0, #2
   147c8:	7841      	ldrb	r1, [r0, #1]
   147ca:	7800      	ldrb	r0, [r0, #0]
   147cc:	f004 f8a2 	bl	18914 <radio_filter_configure>
	evt = HDR_LLL2EVT(lll);
   147d0:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
   147d2:	6835      	ldr	r5, [r6, #0]
	ticks_at_event += lll_evt_offset_get(evt);
   147d4:	4638      	mov	r0, r7
   147d6:	f00f fea1 	bl	2451c <lll_evt_offset_get>
   147da:	4405      	add	r5, r0
	remainder_us = radio_tmr_start(1, ticks_at_start, remainder);
   147dc:	6872      	ldr	r2, [r6, #4]
   147de:	f105 0109 	add.w	r1, r5, #9
   147e2:	2001      	movs	r0, #1
   147e4:	f004 f8fc 	bl	189e0 <radio_tmr_start>
	radio_tmr_end_capture();
   147e8:	f004 f9b4 	bl	18b54 <radio_tmr_end_capture>
				   ull_adv_lll_handle_get(lll)),
   147ec:	4620      	mov	r0, r4
   147ee:	f7ff fc2b 	bl	14048 <ull_adv_lll_handle_get>
	if (lll_preempt_calc(evt, (TICKER_ID_ADV_BASE +
   147f2:	1c81      	adds	r1, r0, #2
   147f4:	462a      	mov	r2, r5
   147f6:	b2c9      	uxtb	r1, r1
   147f8:	4638      	mov	r0, r7
   147fa:	f00f fe9d 	bl	24538 <lll_preempt_calc>
   147fe:	b150      	cbz	r0, 14816 <prepare_cb+0xe2>
		radio_isr_set(isr_abort, lll);
   14800:	4621      	mov	r1, r4
   14802:	4813      	ldr	r0, [pc, #76]	; (14850 <prepare_cb+0x11c>)
   14804:	f003 ff38 	bl	18678 <radio_isr_set>
		radio_disable();
   14808:	f003 fffe 	bl	18808 <radio_disable>
   1480c:	e7af      	b.n	1476e <prepare_cb+0x3a>
	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER) && lll->filter_policy) {
   1480e:	079b      	lsls	r3, r3, #30
   14810:	d0de      	beq.n	147d0 <prepare_cb+0x9c>
		struct lll_filter *wl = ull_filter_lll_get(true);
   14812:	2001      	movs	r0, #1
   14814:	e7d5      	b.n	147c2 <prepare_cb+0x8e>
		ret = lll_prepare_done(lll);
   14816:	4620      	mov	r0, r4
   14818:	f00f fe7e 	bl	24518 <lll_prepare_done>
		LL_ASSERT(!ret);
   1481c:	2800      	cmp	r0, #0
   1481e:	d0a6      	beq.n	1476e <prepare_cb+0x3a>
   14820:	23e8      	movs	r3, #232	; 0xe8
   14822:	4a07      	ldr	r2, [pc, #28]	; (14840 <prepare_cb+0x10c>)
   14824:	490b      	ldr	r1, [pc, #44]	; (14854 <prepare_cb+0x120>)
   14826:	4808      	ldr	r0, [pc, #32]	; (14848 <prepare_cb+0x114>)
   14828:	f00b fac3 	bl	1fdb2 <printk>
   1482c:	4040      	eors	r0, r0
   1482e:	f380 8811 	msr	BASEPRI, r0
   14832:	f04f 0003 	mov.w	r0, #3
   14836:	df02      	svc	2
   14838:	e799      	b.n	1476e <prepare_cb+0x3a>
   1483a:	bf00      	nop
   1483c:	8e89bed6 	.word	0x8e89bed6
   14840:	0006463b 	.word	0x0006463b
   14844:	0006467e 	.word	0x0006467e
   14848:	000632fe 	.word	0x000632fe
   1484c:	00555555 	.word	0x00555555
   14850:	0002458d 	.word	0x0002458d
   14854:	00064330 	.word	0x00064330

00014858 <lll_adv_prepare>:
{
   14858:	b513      	push	{r0, r1, r4, lr}
   1485a:	4604      	mov	r4, r0
	err = lll_clk_on();
   1485c:	f7ff f8c8 	bl	139f0 <lll_clk_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
   14860:	b168      	cbz	r0, 1487e <lll_adv_prepare+0x26>
   14862:	3077      	adds	r0, #119	; 0x77
   14864:	d00b      	beq.n	1487e <lll_adv_prepare+0x26>
   14866:	236d      	movs	r3, #109	; 0x6d
   14868:	4a11      	ldr	r2, [pc, #68]	; (148b0 <lll_adv_prepare+0x58>)
   1486a:	4912      	ldr	r1, [pc, #72]	; (148b4 <lll_adv_prepare+0x5c>)
   1486c:	4812      	ldr	r0, [pc, #72]	; (148b8 <lll_adv_prepare+0x60>)
   1486e:	f00b faa0 	bl	1fdb2 <printk>
   14872:	4040      	eors	r0, r0
   14874:	f380 8811 	msr	BASEPRI, r0
   14878:	f04f 0003 	mov.w	r0, #3
   1487c:	df02      	svc	2
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, p);
   1487e:	9400      	str	r4, [sp, #0]
   14880:	2300      	movs	r3, #0
   14882:	4a0e      	ldr	r2, [pc, #56]	; (148bc <lll_adv_prepare+0x64>)
   14884:	490e      	ldr	r1, [pc, #56]	; (148c0 <lll_adv_prepare+0x68>)
   14886:	480f      	ldr	r0, [pc, #60]	; (148c4 <lll_adv_prepare+0x6c>)
   14888:	f00f fe3d 	bl	24506 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   1488c:	b168      	cbz	r0, 148aa <lll_adv_prepare+0x52>
   1488e:	3077      	adds	r0, #119	; 0x77
   14890:	d00b      	beq.n	148aa <lll_adv_prepare+0x52>
   14892:	2370      	movs	r3, #112	; 0x70
   14894:	4a06      	ldr	r2, [pc, #24]	; (148b0 <lll_adv_prepare+0x58>)
   14896:	4907      	ldr	r1, [pc, #28]	; (148b4 <lll_adv_prepare+0x5c>)
   14898:	4807      	ldr	r0, [pc, #28]	; (148b8 <lll_adv_prepare+0x60>)
   1489a:	f00b fa8a 	bl	1fdb2 <printk>
   1489e:	4040      	eors	r0, r0
   148a0:	f380 8811 	msr	BASEPRI, r0
   148a4:	f04f 0003 	mov.w	r0, #3
   148a8:	df02      	svc	2
}
   148aa:	b002      	add	sp, #8
   148ac:	bd10      	pop	{r4, pc}
   148ae:	bf00      	nop
   148b0:	0006463b 	.word	0x0006463b
   148b4:	00064627 	.word	0x00064627
   148b8:	000632fe 	.word	0x000632fe
   148bc:	00014735 	.word	0x00014735
   148c0:	000142f9 	.word	0x000142f9
   148c4:	00014289 	.word	0x00014289

000148c8 <pdu_len_cmp>:
		break;
	}
}

static inline bool pdu_len_cmp(u8_t opcode, u8_t len)
{
   148c8:	b5f0      	push	{r4, r5, r6, r7, lr}
	const u8_t ctrl_len_lut[] = {
   148ca:	4b0d      	ldr	r3, [pc, #52]	; (14900 <pdu_len_cmp+0x38>)
{
   148cc:	b089      	sub	sp, #36	; 0x24
   148ce:	4605      	mov	r5, r0
   148d0:	460e      	mov	r6, r1
	const u8_t ctrl_len_lut[] = {
   148d2:	aa01      	add	r2, sp, #4
   148d4:	f103 0718 	add.w	r7, r3, #24
   148d8:	6818      	ldr	r0, [r3, #0]
   148da:	6859      	ldr	r1, [r3, #4]
   148dc:	4614      	mov	r4, r2
   148de:	c403      	stmia	r4!, {r0, r1}
   148e0:	3308      	adds	r3, #8
   148e2:	42bb      	cmp	r3, r7
   148e4:	4622      	mov	r2, r4
   148e6:	d1f7      	bne.n	148d8 <pdu_len_cmp+0x10>
   148e8:	881b      	ldrh	r3, [r3, #0]
   148ea:	8023      	strh	r3, [r4, #0]
		 sizeof(struct pdu_data_llctrl_phy_upd_ind)),
		(offsetof(struct pdu_data_llctrl, min_used_chans_ind) +
		 sizeof(struct pdu_data_llctrl_min_used_chans_ind)),
	};

	return ctrl_len_lut[opcode] == len;
   148ec:	ab08      	add	r3, sp, #32
   148ee:	441d      	add	r5, r3
   148f0:	f815 0c1c 	ldrb.w	r0, [r5, #-28]
}
   148f4:	1b83      	subs	r3, r0, r6
   148f6:	4258      	negs	r0, r3
   148f8:	4158      	adcs	r0, r3
   148fa:	b009      	add	sp, #36	; 0x24
   148fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   148fe:	bf00      	nop
   14900:	0002873e 	.word	0x0002873e

00014904 <ticker_update_latency_cancel_op_cb>:
{
   14904:	b510      	push	{r4, lr}
   14906:	460c      	mov	r4, r1
	LL_ASSERT(ticker_status == TICKER_STATUS_SUCCESS);
   14908:	b160      	cbz	r0, 14924 <ticker_update_latency_cancel_op_cb+0x20>
   1490a:	f240 633a 	movw	r3, #1594	; 0x63a
   1490e:	4a09      	ldr	r2, [pc, #36]	; (14934 <ticker_update_latency_cancel_op_cb+0x30>)
   14910:	4909      	ldr	r1, [pc, #36]	; (14938 <ticker_update_latency_cancel_op_cb+0x34>)
   14912:	480a      	ldr	r0, [pc, #40]	; (1493c <ticker_update_latency_cancel_op_cb+0x38>)
   14914:	f00b fa4d 	bl	1fdb2 <printk>
   14918:	4040      	eors	r0, r0
   1491a:	f380 8811 	msr	BASEPRI, r0
   1491e:	f04f 0003 	mov.w	r0, #3
   14922:	df02      	svc	2
	conn->slave.latency_cancel = 0U;
   14924:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
   14928:	f36f 0341 	bfc	r3, #1, #1
   1492c:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
}
   14930:	bd10      	pop	{r4, pc}
   14932:	bf00      	nop
   14934:	00064754 	.word	0x00064754
   14938:	0006478d 	.word	0x0006478d
   1493c:	000632fe 	.word	0x000632fe

00014940 <init_reset>:
{
   14940:	b508      	push	{r3, lr}
	mem_init(conn_pool, sizeof(struct ll_conn),
   14942:	2201      	movs	r2, #1
   14944:	4b12      	ldr	r3, [pc, #72]	; (14990 <init_reset+0x50>)
   14946:	4813      	ldr	r0, [pc, #76]	; (14994 <init_reset+0x54>)
   14948:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
   1494c:	f00f fb26 	bl	23f9c <mem_init>
	mem_init(mem_conn_tx.pool, CONN_TX_BUF_SIZE, CONFIG_BT_CTLR_TX_BUFFERS,
   14950:	4b11      	ldr	r3, [pc, #68]	; (14998 <init_reset+0x58>)
   14952:	2203      	movs	r2, #3
   14954:	1d18      	adds	r0, r3, #4
   14956:	2124      	movs	r1, #36	; 0x24
   14958:	f00f fb20 	bl	23f9c <mem_init>
	mem_init(mem_conn_tx_ctrl.pool, CONN_TX_CTRL_BUF_SIZE,
   1495c:	4b0f      	ldr	r3, [pc, #60]	; (1499c <init_reset+0x5c>)
   1495e:	2204      	movs	r2, #4
   14960:	1898      	adds	r0, r3, r2
   14962:	2120      	movs	r1, #32
   14964:	f00f fb1a 	bl	23f9c <mem_init>
	mem_init(mem_link_tx.pool, sizeof(memq_link_t),
   14968:	4b0d      	ldr	r3, [pc, #52]	; (149a0 <init_reset+0x60>)
   1496a:	2207      	movs	r2, #7
   1496c:	1d18      	adds	r0, r3, #4
   1496e:	2108      	movs	r1, #8
   14970:	f00f fb14 	bl	23f9c <mem_init>
	default_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
   14974:	4b0b      	ldr	r3, [pc, #44]	; (149a4 <init_reset+0x64>)
   14976:	221b      	movs	r2, #27
   14978:	801a      	strh	r2, [r3, #0]
	default_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0);
   1497a:	4b0b      	ldr	r3, [pc, #44]	; (149a8 <init_reset+0x68>)
   1497c:	f44f 72a4 	mov.w	r2, #328	; 0x148
   14980:	801a      	strh	r2, [r3, #0]
	default_phy_tx |= BIT(1);
   14982:	4a0a      	ldr	r2, [pc, #40]	; (149ac <init_reset+0x6c>)
   14984:	2303      	movs	r3, #3
   14986:	7013      	strb	r3, [r2, #0]
	default_phy_rx |= BIT(1);
   14988:	4a09      	ldr	r2, [pc, #36]	; (149b0 <init_reset+0x70>)
   1498a:	7013      	strb	r3, [r2, #0]
}
   1498c:	2000      	movs	r0, #0
   1498e:	bd08      	pop	{r3, pc}
   14990:	200012a0 	.word	0x200012a0
   14994:	200012a4 	.word	0x200012a4
   14998:	2000147c 	.word	0x2000147c
   1499c:	200014ec 	.word	0x200014ec
   149a0:	20001570 	.word	0x20001570
   149a4:	2000613e 	.word	0x2000613e
   149a8:	20006140 	.word	0x20006140
   149ac:	2000aa6d 	.word	0x2000aa6d
   149b0:	2000aa6c 	.word	0x2000aa6c

000149b4 <ticker_start_conn_op_cb>:
{
   149b4:	b510      	push	{r4, lr}
   149b6:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   149b8:	b160      	cbz	r0, 149d4 <ticker_start_conn_op_cb+0x20>
   149ba:	f240 6356 	movw	r3, #1622	; 0x656
   149be:	4a0f      	ldr	r2, [pc, #60]	; (149fc <ticker_start_conn_op_cb+0x48>)
   149c0:	490f      	ldr	r1, [pc, #60]	; (14a00 <ticker_start_conn_op_cb+0x4c>)
   149c2:	4810      	ldr	r0, [pc, #64]	; (14a04 <ticker_start_conn_op_cb+0x50>)
   149c4:	f00b f9f5 	bl	1fdb2 <printk>
   149c8:	4040      	eors	r0, r0
   149ca:	f380 8811 	msr	BASEPRI, r0
   149ce:	f04f 0003 	mov.w	r0, #3
   149d2:	df02      	svc	2
	void *p = ull_update_unmark(param);
   149d4:	4620      	mov	r0, r4
   149d6:	f7fe fb03 	bl	12fe0 <ull_update_unmark>
	LL_ASSERT(p == param);
   149da:	4284      	cmp	r4, r0
   149dc:	d00c      	beq.n	149f8 <ticker_start_conn_op_cb+0x44>
   149de:	f240 635a 	movw	r3, #1626	; 0x65a
   149e2:	4a06      	ldr	r2, [pc, #24]	; (149fc <ticker_start_conn_op_cb+0x48>)
   149e4:	4908      	ldr	r1, [pc, #32]	; (14a08 <ticker_start_conn_op_cb+0x54>)
   149e6:	4807      	ldr	r0, [pc, #28]	; (14a04 <ticker_start_conn_op_cb+0x50>)
   149e8:	f00b f9e3 	bl	1fdb2 <printk>
   149ec:	4040      	eors	r0, r0
   149ee:	f380 8811 	msr	BASEPRI, r0
   149f2:	f04f 0003 	mov.w	r0, #3
   149f6:	df02      	svc	2
}
   149f8:	bd10      	pop	{r4, pc}
   149fa:	bf00      	nop
   149fc:	00064754 	.word	0x00064754
   14a00:	00064794 	.word	0x00064794
   14a04:	000632fe 	.word	0x000632fe
   14a08:	000646f8 	.word	0x000646f8

00014a0c <ticker_stop_conn_op_cb>:
{
   14a0c:	b510      	push	{r4, lr}
   14a0e:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   14a10:	b160      	cbz	r0, 14a2c <ticker_stop_conn_op_cb+0x20>
   14a12:	f240 634d 	movw	r3, #1613	; 0x64d
   14a16:	4a0f      	ldr	r2, [pc, #60]	; (14a54 <ticker_stop_conn_op_cb+0x48>)
   14a18:	490f      	ldr	r1, [pc, #60]	; (14a58 <ticker_stop_conn_op_cb+0x4c>)
   14a1a:	4810      	ldr	r0, [pc, #64]	; (14a5c <ticker_stop_conn_op_cb+0x50>)
   14a1c:	f00b f9c9 	bl	1fdb2 <printk>
   14a20:	4040      	eors	r0, r0
   14a22:	f380 8811 	msr	BASEPRI, r0
   14a26:	f04f 0003 	mov.w	r0, #3
   14a2a:	df02      	svc	2
	void *p = ull_update_mark(param);
   14a2c:	4620      	mov	r0, r4
   14a2e:	f7fe facf 	bl	12fd0 <ull_update_mark>
	LL_ASSERT(p == param);
   14a32:	4284      	cmp	r4, r0
   14a34:	d00c      	beq.n	14a50 <ticker_stop_conn_op_cb+0x44>
   14a36:	f240 6351 	movw	r3, #1617	; 0x651
   14a3a:	4a06      	ldr	r2, [pc, #24]	; (14a54 <ticker_stop_conn_op_cb+0x48>)
   14a3c:	4908      	ldr	r1, [pc, #32]	; (14a60 <ticker_stop_conn_op_cb+0x54>)
   14a3e:	4807      	ldr	r0, [pc, #28]	; (14a5c <ticker_stop_conn_op_cb+0x50>)
   14a40:	f00b f9b7 	bl	1fdb2 <printk>
   14a44:	4040      	eors	r0, r0
   14a46:	f380 8811 	msr	BASEPRI, r0
   14a4a:	f04f 0003 	mov.w	r0, #3
   14a4e:	df02      	svc	2
}
   14a50:	bd10      	pop	{r4, pc}
   14a52:	bf00      	nop
   14a54:	00064754 	.word	0x00064754
   14a58:	00064794 	.word	0x00064794
   14a5c:	000632fe 	.word	0x000632fe
   14a60:	000646f8 	.word	0x000646f8

00014a64 <ticker_update_conn_op_cb>:
{
   14a64:	b510      	push	{r4, lr}
   14a66:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
   14a68:	b1a0      	cbz	r0, 14a94 <ticker_update_conn_op_cb+0x30>
   14a6a:	f7fe fac7 	bl	12ffc <ull_update_mark_get>
   14a6e:	4284      	cmp	r4, r0
   14a70:	d010      	beq.n	14a94 <ticker_update_conn_op_cb+0x30>
   14a72:	f7fe faa7 	bl	12fc4 <ull_disable_mark_get>
   14a76:	4284      	cmp	r4, r0
   14a78:	d00c      	beq.n	14a94 <ticker_update_conn_op_cb+0x30>
   14a7a:	f44f 63c9 	mov.w	r3, #1608	; 0x648
   14a7e:	4a06      	ldr	r2, [pc, #24]	; (14a98 <ticker_update_conn_op_cb+0x34>)
   14a80:	4906      	ldr	r1, [pc, #24]	; (14a9c <ticker_update_conn_op_cb+0x38>)
   14a82:	4807      	ldr	r0, [pc, #28]	; (14aa0 <ticker_update_conn_op_cb+0x3c>)
   14a84:	f00b f995 	bl	1fdb2 <printk>
   14a88:	4040      	eors	r0, r0
   14a8a:	f380 8811 	msr	BASEPRI, r0
   14a8e:	f04f 0003 	mov.w	r0, #3
   14a92:	df02      	svc	2
}
   14a94:	bd10      	pop	{r4, pc}
   14a96:	bf00      	nop
   14a98:	00064754 	.word	0x00064754
   14a9c:	00064703 	.word	0x00064703
   14aa0:	000632fe 	.word	0x000632fe

00014aa4 <ticker_op_stop_cb>:
{
   14aa4:	b510      	push	{r4, lr}
   14aa6:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   14aa8:	b160      	cbz	r0, 14ac4 <ticker_op_stop_cb+0x20>
   14aaa:	f240 6363 	movw	r3, #1635	; 0x663
   14aae:	4a10      	ldr	r2, [pc, #64]	; (14af0 <ticker_op_stop_cb+0x4c>)
   14ab0:	4910      	ldr	r1, [pc, #64]	; (14af4 <ticker_op_stop_cb+0x50>)
   14ab2:	4811      	ldr	r0, [pc, #68]	; (14af8 <ticker_op_stop_cb+0x54>)
   14ab4:	f00b f97d 	bl	1fdb2 <printk>
   14ab8:	4040      	eors	r0, r0
   14aba:	f380 8811 	msr	BASEPRI, r0
   14abe:	f04f 0003 	mov.w	r0, #3
   14ac2:	df02      	svc	2
	mfy.param = param;
   14ac4:	4b0d      	ldr	r3, [pc, #52]	; (14afc <ticker_op_stop_cb+0x58>)
	retval = mayfly_enqueue(TICKER_USER_ID_ULL_LOW, TICKER_USER_ID_LLL, 0,
   14ac6:	2200      	movs	r2, #0
   14ac8:	4611      	mov	r1, r2
   14aca:	2002      	movs	r0, #2
	mfy.param = param;
   14acc:	609c      	str	r4, [r3, #8]
	retval = mayfly_enqueue(TICKER_USER_ID_ULL_LOW, TICKER_USER_ID_LLL, 0,
   14ace:	f7fb fdb1 	bl	10634 <mayfly_enqueue>
	LL_ASSERT(!retval);
   14ad2:	b160      	cbz	r0, 14aee <ticker_op_stop_cb+0x4a>
   14ad4:	f240 636a 	movw	r3, #1642	; 0x66a
   14ad8:	4a05      	ldr	r2, [pc, #20]	; (14af0 <ticker_op_stop_cb+0x4c>)
   14ada:	4909      	ldr	r1, [pc, #36]	; (14b00 <ticker_op_stop_cb+0x5c>)
   14adc:	4806      	ldr	r0, [pc, #24]	; (14af8 <ticker_op_stop_cb+0x54>)
   14ade:	f00b f968 	bl	1fdb2 <printk>
   14ae2:	4040      	eors	r0, r0
   14ae4:	f380 8811 	msr	BASEPRI, r0
   14ae8:	f04f 0003 	mov.w	r0, #3
   14aec:	df02      	svc	2
}
   14aee:	bd10      	pop	{r4, pc}
   14af0:	00064754 	.word	0x00064754
   14af4:	00064794 	.word	0x00064794
   14af8:	000632fe 	.word	0x000632fe
   14afc:	2000eaa8 	.word	0x2000eaa8
   14b00:	00064335 	.word	0x00064335

00014b04 <conn_cleanup>:
	rx->hdr.handle = conn->lll.handle;
   14b04:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
{
   14b06:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	rx->hdr.handle = conn->lll.handle;
   14b0a:	f8a0 3132 	strh.w	r3, [r0, #306]	; 0x132
	*((u8_t *)rx->pdu) = reason;
   14b0e:	f880 114c 	strb.w	r1, [r0, #332]	; 0x14c
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
   14b12:	2309      	movs	r3, #9
	rx = conn->llcp_rx;
   14b14:	f8d0 1100 	ldr.w	r1, [r0, #256]	; 0x100
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
   14b18:	f880 3130 	strb.w	r3, [r0, #304]	; 0x130
{
   14b1c:	4604      	mov	r4, r0
	struct lll_conn *lll = &conn->lll;
   14b1e:	f100 061c 	add.w	r6, r0, #28
		hdr->type = NODE_RX_TYPE_DC_PDU_RELEASE;
   14b22:	2503      	movs	r5, #3
	while (rx) {
   14b24:	bb19      	cbnz	r1, 14b6e <conn_cleanup+0x6a>
		link = mem_acquire(&mem_link_tx.free);
   14b26:	4f24      	ldr	r7, [pc, #144]	; (14bb8 <conn_cleanup+0xb4>)
		LL_ASSERT(link);
   14b28:	f8df 8094 	ldr.w	r8, [pc, #148]	; 14bc0 <conn_cleanup+0xbc>
   14b2c:	f8df 909c 	ldr.w	r9, [pc, #156]	; 14bcc <conn_cleanup+0xc8>
	while (conn->tx_head) {
   14b30:	f8d4 01b0 	ldr.w	r0, [r4, #432]	; 0x1b0
   14b34:	bb10      	cbnz	r0, 14b7c <conn_cleanup+0x78>
				    TICKER_ID_CONN_BASE + lll->handle,
   14b36:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   14b3a:	4b20      	ldr	r3, [pc, #128]	; (14bbc <conn_cleanup+0xb8>)
   14b3c:	9600      	str	r6, [sp, #0]
				    TICKER_ID_CONN_BASE + lll->handle,
   14b3e:	3203      	adds	r2, #3
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   14b40:	b2d2      	uxtb	r2, r2
   14b42:	2101      	movs	r1, #1
   14b44:	f7fc fa86 	bl	11054 <ticker_stop>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   14b48:	f030 0302 	bics.w	r3, r0, #2
   14b4c:	d00c      	beq.n	14b68 <conn_cleanup+0x64>
   14b4e:	f240 63b3 	movw	r3, #1715	; 0x6b3
   14b52:	4a1b      	ldr	r2, [pc, #108]	; (14bc0 <conn_cleanup+0xbc>)
   14b54:	491b      	ldr	r1, [pc, #108]	; (14bc4 <conn_cleanup+0xc0>)
   14b56:	481c      	ldr	r0, [pc, #112]	; (14bc8 <conn_cleanup+0xc4>)
   14b58:	f00b f92b 	bl	1fdb2 <printk>
   14b5c:	4040      	eors	r0, r0
   14b5e:	f380 8811 	msr	BASEPRI, r0
   14b62:	f04f 0003 	mov.w	r0, #3
   14b66:	df02      	svc	2
}
   14b68:	b002      	add	sp, #8
   14b6a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		rx = hdr->link->mem;
   14b6e:	6808      	ldr	r0, [r1, #0]
   14b70:	6847      	ldr	r7, [r0, #4]
		hdr->type = NODE_RX_TYPE_DC_PDU_RELEASE;
   14b72:	710d      	strb	r5, [r1, #4]
		ll_rx_put(hdr->link, hdr);
   14b74:	f7fe f974 	bl	12e60 <ll_rx_put>
		rx = hdr->link->mem;
   14b78:	4639      	mov	r1, r7
   14b7a:	e7d3      	b.n	14b24 <conn_cleanup+0x20>
		tx = tx_ull_dequeue(conn, conn->tx_head);
   14b7c:	4601      	mov	r1, r0
   14b7e:	4620      	mov	r0, r4
   14b80:	f00f fd7d 	bl	2467e <tx_ull_dequeue>
   14b84:	4682      	mov	sl, r0
		link = mem_acquire(&mem_link_tx.free);
   14b86:	4638      	mov	r0, r7
   14b88:	f00f fa21 	bl	23fce <mem_acquire>
		LL_ASSERT(link);
   14b8c:	4605      	mov	r5, r0
   14b8e:	b960      	cbnz	r0, 14baa <conn_cleanup+0xa6>
   14b90:	f240 63bf 	movw	r3, #1727	; 0x6bf
   14b94:	4642      	mov	r2, r8
   14b96:	4649      	mov	r1, r9
   14b98:	480b      	ldr	r0, [pc, #44]	; (14bc8 <conn_cleanup+0xc4>)
   14b9a:	f00b f90a 	bl	1fdb2 <printk>
   14b9e:	4040      	eors	r0, r0
   14ba0:	f380 8811 	msr	BASEPRI, r0
   14ba4:	f04f 0003 	mov.w	r0, #3
   14ba8:	df02      	svc	2
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
   14baa:	f104 026c 	add.w	r2, r4, #108	; 0x6c
   14bae:	4651      	mov	r1, sl
   14bb0:	4628      	mov	r0, r5
   14bb2:	f00f fa5e 	bl	24072 <memq_enqueue>
   14bb6:	e7bb      	b.n	14b30 <conn_cleanup+0x2c>
   14bb8:	20001570 	.word	0x20001570
   14bbc:	00014aa5 	.word	0x00014aa5
   14bc0:	00064754 	.word	0x00064754
   14bc4:	000646b3 	.word	0x000646b3
   14bc8:	000632fe 	.word	0x000632fe
   14bcc:	00064829 	.word	0x00064829

00014bd0 <tx_lll_flush>:
{
   14bd0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	struct ll_conn *conn = (void *)HDR_LLL2EVT(param);
   14bd4:	4606      	mov	r6, r0
{
   14bd6:	4607      	mov	r7, r0
	struct ll_conn *conn = (void *)HDR_LLL2EVT(param);
   14bd8:	f856 5b4c 	ldr.w	r5, [r6], #76
		idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   14bdc:	4c2e      	ldr	r4, [pc, #184]	; (14c98 <tx_lll_flush+0xc8>)
	lll_conn_flush(lll);
   14bde:	f010 f814 	bl	24c0a <lll_conn_flush>
	link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
   14be2:	aa01      	add	r2, sp, #4
   14be4:	4631      	mov	r1, r6
   14be6:	6d38      	ldr	r0, [r7, #80]	; 0x50
   14be8:	f00f fa52 	bl	24090 <memq_dequeue>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   14bec:	f104 0804 	add.w	r8, r4, #4
	while (link) {
   14bf0:	b9f0      	cbnz	r0, 14c30 <tx_lll_flush+0x60>
	LL_ASSERT(rx->hdr.link);
   14bf2:	f8d5 312c 	ldr.w	r3, [r5, #300]	; 0x12c
	rx = (void *)&conn->llcp_terminate.node_rx;
   14bf6:	f505 7496 	add.w	r4, r5, #300	; 0x12c
	LL_ASSERT(rx->hdr.link);
   14bfa:	b963      	cbnz	r3, 14c16 <tx_lll_flush+0x46>
   14bfc:	f240 63ea 	movw	r3, #1770	; 0x6ea
   14c00:	4a26      	ldr	r2, [pc, #152]	; (14c9c <tx_lll_flush+0xcc>)
   14c02:	4927      	ldr	r1, [pc, #156]	; (14ca0 <tx_lll_flush+0xd0>)
   14c04:	4827      	ldr	r0, [pc, #156]	; (14ca4 <tx_lll_flush+0xd4>)
   14c06:	f00b f8d4 	bl	1fdb2 <printk>
   14c0a:	4040      	eors	r0, r0
   14c0c:	f380 8811 	msr	BASEPRI, r0
   14c10:	f04f 0003 	mov.w	r0, #3
   14c14:	df02      	svc	2
	rx->hdr.link = NULL;
   14c16:	2300      	movs	r3, #0
	link = rx->hdr.link;
   14c18:	f8d5 012c 	ldr.w	r0, [r5, #300]	; 0x12c
	rx->hdr.link = NULL;
   14c1c:	f8c5 312c 	str.w	r3, [r5, #300]	; 0x12c
	ull_rx_put(link, rx);
   14c20:	4621      	mov	r1, r4
   14c22:	f7fe fa5b 	bl	130dc <ull_rx_put>
	ull_rx_sched();
   14c26:	f7fe fa69 	bl	130fc <ull_rx_sched>
}
   14c2a:	b002      	add	sp, #8
   14c2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   14c30:	78e2      	ldrb	r2, [r4, #3]
	if (last == count) {
   14c32:	f894 e001 	ldrb.w	lr, [r4, #1]
   14c36:	f894 c002 	ldrb.w	ip, [r4, #2]
   14c3a:	7821      	ldrb	r1, [r4, #0]
	last = last + 1;
   14c3c:	1c53      	adds	r3, r2, #1
   14c3e:	b2db      	uxtb	r3, r3
		last = 0U;
   14c40:	459e      	cmp	lr, r3
   14c42:	bf08      	it	eq
   14c44:	2300      	moveq	r3, #0
	if (last == first) {
   14c46:	459c      	cmp	ip, r3
   14c48:	d004      	beq.n	14c54 <tx_lll_flush+0x84>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   14c4a:	fb12 f201 	smulbb	r2, r2, r1
		LL_ASSERT(lll_tx);
   14c4e:	eb18 0c02 	adds.w	ip, r8, r2
   14c52:	d10f      	bne.n	14c74 <tx_lll_flush+0xa4>
   14c54:	f240 63d6 	movw	r3, #1750	; 0x6d6
   14c58:	4a10      	ldr	r2, [pc, #64]	; (14c9c <tx_lll_flush+0xcc>)
   14c5a:	4913      	ldr	r1, [pc, #76]	; (14ca8 <tx_lll_flush+0xd8>)
   14c5c:	4811      	ldr	r0, [pc, #68]	; (14ca4 <tx_lll_flush+0xd4>)
   14c5e:	f00b f8a8 	bl	1fdb2 <printk>
   14c62:	4040      	eors	r0, r0
   14c64:	f380 8811 	msr	BASEPRI, r0
   14c68:	f04f 0003 	mov.w	r0, #3
   14c6c:	df02      	svc	2
		lll_tx->handle = 0xFFFF;
   14c6e:	2300      	movs	r3, #0
   14c70:	801b      	strh	r3, [r3, #0]
   14c72:	deff      	udf	#255	; 0xff
   14c74:	f64f 71ff 	movw	r1, #65535	; 0xffff
   14c78:	f828 1002 	strh.w	r1, [r8, r2]
		lll_tx->node = tx;
   14c7c:	9901      	ldr	r1, [sp, #4]
   14c7e:	f8cc 1004 	str.w	r1, [ip, #4]
		link->next = tx->next; /* Indicates ctrl pool or data pool */
   14c82:	680a      	ldr	r2, [r1, #0]
   14c84:	6002      	str	r2, [r0, #0]
		tx->next = link;
   14c86:	6008      	str	r0, [r1, #0]
		link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
   14c88:	aa01      	add	r2, sp, #4
	*last = idx; /* Commit: Update write index */
   14c8a:	70e3      	strb	r3, [r4, #3]
   14c8c:	4631      	mov	r1, r6
   14c8e:	6d38      	ldr	r0, [r7, #80]	; 0x50
   14c90:	f00f f9fe 	bl	24090 <memq_dequeue>
   14c94:	e7ac      	b.n	14bf0 <tx_lll_flush+0x20>
   14c96:	bf00      	nop
   14c98:	2000ea40 	.word	0x2000ea40
   14c9c:	00064754 	.word	0x00064754
   14ca0:	00064821 	.word	0x00064821
   14ca4:	000632fe 	.word	0x000632fe
   14ca8:	000647a0 	.word	0x000647a0

00014cac <ctrl_tx_pause_enqueue>:
{
   14cac:	b538      	push	{r3, r4, r5, lr}
   14cae:	460d      	mov	r5, r1
   14cb0:	e9d0 316c 	ldrd	r3, r1, [r0, #432]	; 0x1b0
   14cb4:	4604      	mov	r4, r0
	if (
   14cb6:	2b00      	cmp	r3, #0
   14cb8:	d030      	beq.n	14d1c <ctrl_tx_pause_enqueue+0x70>
	    !conn->llcp_enc.pause_tx &&
   14cba:	f890 0152 	ldrb.w	r0, [r0, #338]	; 0x152
	    conn->tx_head &&
   14cbe:	0780      	lsls	r0, r0, #30
   14cc0:	d42c      	bmi.n	14d1c <ctrl_tx_pause_enqueue+0x70>
	    !conn->llcp_phy.pause_tx &&
   14cc2:	f894 01ab 	ldrb.w	r0, [r4, #427]	; 0x1ab
   14cc6:	07c0      	lsls	r0, r0, #31
   14cc8:	d428      	bmi.n	14d1c <ctrl_tx_pause_enqueue+0x70>
		if (conn->tx_head == conn->tx_data) {
   14cca:	f8d4 01bc 	ldr.w	r0, [r4, #444]	; 0x1bc
   14cce:	4283      	cmp	r3, r0
			conn->tx_data = conn->tx_data->next;
   14cd0:	bf04      	itt	eq
   14cd2:	6818      	ldreq	r0, [r3, #0]
   14cd4:	f8c4 01bc 	streq.w	r0, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
   14cd8:	b961      	cbnz	r1, 14cf4 <ctrl_tx_pause_enqueue+0x48>
			tx->next = conn->tx_head->next;
   14cda:	6819      	ldr	r1, [r3, #0]
   14cdc:	6029      	str	r1, [r5, #0]
			conn->tx_head->next = tx;
   14cde:	601d      	str	r5, [r3, #0]
			if (!pause) {
   14ce0:	b91a      	cbnz	r2, 14cea <ctrl_tx_pause_enqueue+0x3e>
				conn->tx_ctrl = tx;
   14ce2:	f8c4 51b4 	str.w	r5, [r4, #436]	; 0x1b4
	conn->tx_ctrl_last = tx;
   14ce6:	f8c4 51b8 	str.w	r5, [r4, #440]	; 0x1b8
	if (!tx->next) {
   14cea:	682b      	ldr	r3, [r5, #0]
   14cec:	b90b      	cbnz	r3, 14cf2 <ctrl_tx_pause_enqueue+0x46>
		conn->tx_data_last = tx;
   14cee:	f8c4 51c0 	str.w	r5, [r4, #448]	; 0x1c0
}
   14cf2:	bd38      	pop	{r3, r4, r5, pc}
			LL_ASSERT(!pause);
   14cf4:	b162      	cbz	r2, 14d10 <ctrl_tx_pause_enqueue+0x64>
   14cf6:	f240 7345 	movw	r3, #1861	; 0x745
			LL_ASSERT(!pause);
   14cfa:	4a0d      	ldr	r2, [pc, #52]	; (14d30 <ctrl_tx_pause_enqueue+0x84>)
   14cfc:	490d      	ldr	r1, [pc, #52]	; (14d34 <ctrl_tx_pause_enqueue+0x88>)
   14cfe:	480e      	ldr	r0, [pc, #56]	; (14d38 <ctrl_tx_pause_enqueue+0x8c>)
   14d00:	f00b f857 	bl	1fdb2 <printk>
   14d04:	4040      	eors	r0, r0
   14d06:	f380 8811 	msr	BASEPRI, r0
   14d0a:	f04f 0003 	mov.w	r0, #3
   14d0e:	df02      	svc	2
	tx->next = conn->tx_ctrl_last->next;
   14d10:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
   14d14:	681a      	ldr	r2, [r3, #0]
   14d16:	602a      	str	r2, [r5, #0]
	conn->tx_ctrl_last->next = tx;
   14d18:	601d      	str	r5, [r3, #0]
   14d1a:	e7e4      	b.n	14ce6 <ctrl_tx_pause_enqueue+0x3a>
		if (!conn->tx_ctrl) {
   14d1c:	b919      	cbnz	r1, 14d26 <ctrl_tx_pause_enqueue+0x7a>
			tx->next = conn->tx_head;
   14d1e:	602b      	str	r3, [r5, #0]
			conn->tx_head = tx;
   14d20:	f8c4 51b0 	str.w	r5, [r4, #432]	; 0x1b0
			if (!pause) {
   14d24:	e7dc      	b.n	14ce0 <ctrl_tx_pause_enqueue+0x34>
			LL_ASSERT(!pause);
   14d26:	2a00      	cmp	r2, #0
   14d28:	d0f2      	beq.n	14d10 <ctrl_tx_pause_enqueue+0x64>
   14d2a:	f240 7357 	movw	r3, #1879	; 0x757
   14d2e:	e7e4      	b.n	14cfa <ctrl_tx_pause_enqueue+0x4e>
   14d30:	00064754 	.word	0x00064754
   14d34:	000646e0 	.word	0x000646e0
   14d38:	000632fe 	.word	0x000632fe

00014d3c <feature_rsp_send.isra.15>:
static int feature_rsp_send(struct ll_conn *conn, struct node_rx_pdu *rx,
   14d3c:	b570      	push	{r4, r5, r6, lr}
   14d3e:	4605      	mov	r5, r0
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   14d40:	481f      	ldr	r0, [pc, #124]	; (14dc0 <feature_rsp_send.isra.15+0x84>)
static int feature_rsp_send(struct ll_conn *conn, struct node_rx_pdu *rx,
   14d42:	460c      	mov	r4, r1
   14d44:	4616      	mov	r6, r2
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   14d46:	f00f f942 	bl	23fce <mem_acquire>
	if (!tx) {
   14d4a:	4601      	mov	r1, r0
   14d4c:	b3a0      	cbz	r0, 14db8 <feature_rsp_send.isra.15+0x7c>
	       (features[1] << 8) | (features[2] << 16);
   14d4e:	79b3      	ldrb	r3, [r6, #6]
   14d50:	7972      	ldrb	r2, [r6, #5]
   14d52:	041b      	lsls	r3, r3, #16
   14d54:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	feat = ~LL_FEAT_BIT_MASK_VALID | features[0] |
   14d58:	7932      	ldrb	r2, [r6, #4]
	       (features[1] << 8) | (features[2] << 16);
   14d5a:	4313      	orrs	r3, r2
   14d5c:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
   14d60:	f443 037e 	orr.w	r3, r3, #16646144	; 0xfe0000
	conn->llcp_feature.features &= feat_get(&req->features[0]);
   14d64:	f8d5 211c 	ldr.w	r2, [r5, #284]	; 0x11c
	       (features[1] << 8) | (features[2] << 16);
   14d68:	f443 5343 	orr.w	r3, r3, #12480	; 0x30c0
   14d6c:	f043 0310 	orr.w	r3, r3, #16
	conn->llcp_feature.features &= feat_get(&req->features[0]);
   14d70:	4013      	ands	r3, r2
   14d72:	f3c3 0310 	ubfx	r3, r3, #0, #17
   14d76:	f8c5 311c 	str.w	r3, [r5, #284]	; 0x11c
	conn->common.fex_valid = 1U;
   14d7a:	f895 30dc 	ldrb.w	r3, [r5, #220]	; 0xdc
   14d7e:	f043 0301 	orr.w	r3, r3, #1
   14d82:	f885 30dc 	strb.w	r3, [r5, #220]	; 0xdc
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   14d86:	7903      	ldrb	r3, [r0, #4]
   14d88:	f043 0303 	orr.w	r3, r3, #3
   14d8c:	7103      	strb	r3, [r0, #4]
__ssp_bos_icheck3(memset, void *, int)
   14d8e:	2600      	movs	r6, #0
	pdu_tx->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
   14d90:	2309      	movs	r3, #9
   14d92:	6086      	str	r6, [r0, #8]
   14d94:	7143      	strb	r3, [r0, #5]
   14d96:	60c6      	str	r6, [r0, #12]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
   14d98:	71c3      	strb	r3, [r0, #7]
	sys_put_le24(conn->llcp_feature.features,
   14d9a:	f8d5 311c 	ldr.w	r3, [r5, #284]	; 0x11c
	dst[0] = val;
   14d9e:	7203      	strb	r3, [r0, #8]
	dst[1] = val >> 8;
   14da0:	f3c3 2207 	ubfx	r2, r3, #8, #8
	dst[2] = val >> 16;
   14da4:	0c1b      	lsrs	r3, r3, #16
   14da6:	7283      	strb	r3, [r0, #10]
	dst[1] = val >> 8;
   14da8:	7242      	strb	r2, [r0, #9]
	ctrl_tx_sec_enqueue(conn, tx);
   14daa:	4628      	mov	r0, r5
   14dac:	f00f fc9a 	bl	246e4 <ctrl_tx_sec_enqueue>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   14db0:	2303      	movs	r3, #3
   14db2:	7023      	strb	r3, [r4, #0]
	return 0;
   14db4:	4630      	mov	r0, r6
}
   14db6:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOBUFS;
   14db8:	f06f 0068 	mvn.w	r0, #104	; 0x68
   14dbc:	e7fb      	b.n	14db6 <feature_rsp_send.isra.15+0x7a>
   14dbe:	bf00      	nop
   14dc0:	200014ec 	.word	0x200014ec

00014dc4 <reject_ext_ind_send.isra.9>:
static int reject_ext_ind_send(struct ll_conn *conn, struct node_rx_pdu *rx,
   14dc4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14dc8:	4606      	mov	r6, r0
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   14dca:	480e      	ldr	r0, [pc, #56]	; (14e04 <reject_ext_ind_send.isra.9+0x40>)
static int reject_ext_ind_send(struct ll_conn *conn, struct node_rx_pdu *rx,
   14dcc:	460d      	mov	r5, r1
   14dce:	4690      	mov	r8, r2
   14dd0:	461f      	mov	r7, r3
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   14dd2:	f00f f8fc 	bl	23fce <mem_acquire>
	if (!tx) {
   14dd6:	4601      	mov	r1, r0
   14dd8:	b188      	cbz	r0, 14dfe <reject_ext_ind_send.isra.9+0x3a>
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   14dda:	7900      	ldrb	r0, [r0, #4]
	pdu_ctrl_tx->llctrl.reject_ext_ind.reject_opcode = reject_opcode;
   14ddc:	f881 8008 	strb.w	r8, [r1, #8]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   14de0:	f040 0003 	orr.w	r0, r0, #3
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
   14de4:	2403      	movs	r4, #3
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
   14de6:	2311      	movs	r3, #17
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   14de8:	7108      	strb	r0, [r1, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
   14dea:	714c      	strb	r4, [r1, #5]
	ctrl_tx_enqueue(conn, tx);
   14dec:	4630      	mov	r0, r6
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
   14dee:	71cb      	strb	r3, [r1, #7]
	pdu_ctrl_tx->llctrl.reject_ext_ind.error_code = error_code;
   14df0:	724f      	strb	r7, [r1, #9]
	ctrl_tx_enqueue(conn, tx);
   14df2:	f00f fcb1 	bl	24758 <ctrl_tx_enqueue>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   14df6:	702c      	strb	r4, [r5, #0]
	return 0;
   14df8:	2000      	movs	r0, #0
}
   14dfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENOBUFS;
   14dfe:	f06f 0068 	mvn.w	r0, #104	; 0x68
   14e02:	e7fa      	b.n	14dfa <reject_ext_ind_send.isra.9+0x36>
   14e04:	200014ec 	.word	0x200014ec

00014e08 <ll_conn_acquire>:
	return mem_acquire(&conn_free);
   14e08:	4801      	ldr	r0, [pc, #4]	; (14e10 <ll_conn_acquire+0x8>)
   14e0a:	f00f b8e0 	b.w	23fce <mem_acquire>
   14e0e:	bf00      	nop
   14e10:	200012a0 	.word	0x200012a0

00014e14 <ll_conn_release>:
	mem_release(conn, &conn_free);
   14e14:	4901      	ldr	r1, [pc, #4]	; (14e1c <ll_conn_release+0x8>)
   14e16:	f00f b8eb 	b.w	23ff0 <mem_release>
   14e1a:	bf00      	nop
   14e1c:	200012a0 	.word	0x200012a0

00014e20 <ll_conn_handle_get>:
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
   14e20:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
   14e24:	4901      	ldr	r1, [pc, #4]	; (14e2c <ll_conn_handle_get+0xc>)
   14e26:	f00f b8f7 	b.w	24018 <mem_index_get>
   14e2a:	bf00      	nop
   14e2c:	200012a4 	.word	0x200012a4

00014e30 <ll_conn_get>:
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   14e30:	4602      	mov	r2, r0
   14e32:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
   14e36:	4801      	ldr	r0, [pc, #4]	; (14e3c <ll_conn_get+0xc>)
   14e38:	f00f b8eb 	b.w	24012 <mem_get>
   14e3c:	200012a4 	.word	0x200012a4

00014e40 <ll_tx_mem_acquire>:
	return mem_acquire(&mem_conn_tx.free);
   14e40:	4801      	ldr	r0, [pc, #4]	; (14e48 <ll_tx_mem_acquire+0x8>)
   14e42:	f00f b8c4 	b.w	23fce <mem_acquire>
   14e46:	bf00      	nop
   14e48:	2000147c 	.word	0x2000147c

00014e4c <ll_tx_mem_release>:
	mem_release(tx, &mem_conn_tx.free);
   14e4c:	4901      	ldr	r1, [pc, #4]	; (14e54 <ll_tx_mem_release+0x8>)
   14e4e:	f00f b8cf 	b.w	23ff0 <mem_release>
   14e52:	bf00      	nop
   14e54:	2000147c 	.word	0x2000147c

00014e58 <ll_tx_mem_enqueue>:
{
   14e58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14e5c:	b088      	sub	sp, #32
   14e5e:	4606      	mov	r6, r0
   14e60:	4688      	mov	r8, r1
	conn = ll_connected_get(handle);
   14e62:	f00f fc8c 	bl	2477e <ll_connected_get>
	if (!conn) {
   14e66:	2800      	cmp	r0, #0
   14e68:	d049      	beq.n	14efe <ll_tx_mem_enqueue+0xa6>
	idx = MFIFO_ENQUEUE_GET(conn_tx, (void **) &lll_tx);
   14e6a:	4c28      	ldr	r4, [pc, #160]	; (14f0c <ll_tx_mem_enqueue+0xb4>)
   14e6c:	78e5      	ldrb	r5, [r4, #3]
	if (last == count) {
   14e6e:	7867      	ldrb	r7, [r4, #1]
   14e70:	78a2      	ldrb	r2, [r4, #2]
   14e72:	7821      	ldrb	r1, [r4, #0]
	last = last + 1;
   14e74:	1c6b      	adds	r3, r5, #1
   14e76:	b2db      	uxtb	r3, r3
		last = 0U;
   14e78:	429f      	cmp	r7, r3
   14e7a:	bf08      	it	eq
   14e7c:	2300      	moveq	r3, #0
	if (last == first) {
   14e7e:	429a      	cmp	r2, r3
   14e80:	d040      	beq.n	14f04 <ll_tx_mem_enqueue+0xac>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   14e82:	1d22      	adds	r2, r4, #4
   14e84:	fb15 f501 	smulbb	r5, r5, r1
	if (!lll_tx) {
   14e88:	1957      	adds	r7, r2, r5
   14e8a:	d03b      	beq.n	14f04 <ll_tx_mem_enqueue+0xac>
	lll_tx->handle = handle;
   14e8c:	5356      	strh	r6, [r2, r5]
	*last = idx; /* Commit: Update write index */
   14e8e:	70e3      	strb	r3, [r4, #3]
	if (conn->lll.role && conn->lll.latency_event &&
   14e90:	f990 303d 	ldrsb.w	r3, [r0, #61]	; 0x3d
	lll_tx->node = tx;
   14e94:	f8c7 8004 	str.w	r8, [r7, #4]
	if (conn->lll.role && conn->lll.latency_event &&
   14e98:	2b00      	cmp	r3, #0
   14e9a:	db03      	blt.n	14ea4 <ll_tx_mem_enqueue+0x4c>
	return 0;
   14e9c:	2000      	movs	r0, #0
}
   14e9e:	b008      	add	sp, #32
   14ea0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (conn->lll.role && conn->lll.latency_event &&
   14ea4:	8e83      	ldrh	r3, [r0, #52]	; 0x34
   14ea6:	2b00      	cmp	r3, #0
   14ea8:	d0f8      	beq.n	14e9c <ll_tx_mem_enqueue+0x44>
	    !conn->slave.latency_cancel) {
   14eaa:	f890 30dc 	ldrb.w	r3, [r0, #220]	; 0xdc
	if (conn->lll.role && conn->lll.latency_event &&
   14eae:	f013 0402 	ands.w	r4, r3, #2
   14eb2:	d1f3      	bne.n	14e9c <ll_tx_mem_enqueue+0x44>
		conn->slave.latency_cancel = 1U;
   14eb4:	f043 0302 	orr.w	r3, r3, #2
   14eb8:	f880 30dc 	strb.w	r3, [r0, #220]	; 0xdc
			ticker_update(TICKER_INSTANCE_ID_CTLR,
   14ebc:	4b14      	ldr	r3, [pc, #80]	; (14f10 <ll_tx_mem_enqueue+0xb8>)
   14ebe:	9006      	str	r0, [sp, #24]
   14ec0:	e9cd 4304 	strd	r4, r3, [sp, #16]
				      (TICKER_ID_CONN_BASE + handle),
   14ec4:	1cf2      	adds	r2, r6, #3
			ticker_update(TICKER_INSTANCE_ID_CTLR,
   14ec6:	2301      	movs	r3, #1
   14ec8:	e9cd 4302 	strd	r4, r3, [sp, #8]
   14ecc:	e9cd 4400 	strd	r4, r4, [sp]
   14ed0:	4623      	mov	r3, r4
   14ed2:	b2d2      	uxtb	r2, r2
   14ed4:	2103      	movs	r1, #3
   14ed6:	4620      	mov	r0, r4
   14ed8:	f7fc f874 	bl	10fc4 <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   14edc:	f030 0302 	bics.w	r3, r0, #2
   14ee0:	d0dc      	beq.n	14e9c <ll_tx_mem_enqueue+0x44>
   14ee2:	f240 1301 	movw	r3, #257	; 0x101
   14ee6:	4a0b      	ldr	r2, [pc, #44]	; (14f14 <ll_tx_mem_enqueue+0xbc>)
   14ee8:	490b      	ldr	r1, [pc, #44]	; (14f18 <ll_tx_mem_enqueue+0xc0>)
   14eea:	480c      	ldr	r0, [pc, #48]	; (14f1c <ll_tx_mem_enqueue+0xc4>)
   14eec:	f00a ff61 	bl	1fdb2 <printk>
   14ef0:	4040      	eors	r0, r0
   14ef2:	f380 8811 	msr	BASEPRI, r0
   14ef6:	f04f 0003 	mov.w	r0, #3
   14efa:	df02      	svc	2
   14efc:	e7ce      	b.n	14e9c <ll_tx_mem_enqueue+0x44>
		return -EINVAL;
   14efe:	f06f 0015 	mvn.w	r0, #21
   14f02:	e7cc      	b.n	14e9e <ll_tx_mem_enqueue+0x46>
		return -ENOBUFS;
   14f04:	f06f 0068 	mvn.w	r0, #104	; 0x68
   14f08:	e7c9      	b.n	14e9e <ll_tx_mem_enqueue+0x46>
   14f0a:	bf00      	nop
   14f0c:	2000ea84 	.word	0x2000ea84
   14f10:	00014905 	.word	0x00014905
   14f14:	00064754 	.word	0x00064754
   14f18:	000646b3 	.word	0x000646b3
   14f1c:	000632fe 	.word	0x000632fe

00014f20 <ll_length_default_get>:
	*max_tx_octets = default_tx_octets;
   14f20:	4b03      	ldr	r3, [pc, #12]	; (14f30 <ll_length_default_get+0x10>)
   14f22:	881b      	ldrh	r3, [r3, #0]
   14f24:	8003      	strh	r3, [r0, #0]
	*max_tx_time = default_tx_time;
   14f26:	4b03      	ldr	r3, [pc, #12]	; (14f34 <ll_length_default_get+0x14>)
   14f28:	881b      	ldrh	r3, [r3, #0]
   14f2a:	800b      	strh	r3, [r1, #0]
}
   14f2c:	4770      	bx	lr
   14f2e:	bf00      	nop
   14f30:	2000613e 	.word	0x2000613e
   14f34:	20006140 	.word	0x20006140

00014f38 <ll_length_default_set>:
	default_tx_octets = max_tx_octets;
   14f38:	4b02      	ldr	r3, [pc, #8]	; (14f44 <ll_length_default_set+0xc>)
   14f3a:	8018      	strh	r0, [r3, #0]
	default_tx_time = max_tx_time;
   14f3c:	4b02      	ldr	r3, [pc, #8]	; (14f48 <ll_length_default_set+0x10>)
}
   14f3e:	2000      	movs	r0, #0
	default_tx_time = max_tx_time;
   14f40:	8019      	strh	r1, [r3, #0]
}
   14f42:	4770      	bx	lr
   14f44:	2000613e 	.word	0x2000613e
   14f48:	20006140 	.word	0x20006140

00014f4c <ll_phy_default_set>:
	default_phy_tx = tx;
   14f4c:	4b02      	ldr	r3, [pc, #8]	; (14f58 <ll_phy_default_set+0xc>)
   14f4e:	7018      	strb	r0, [r3, #0]
	default_phy_rx = rx;
   14f50:	4b02      	ldr	r3, [pc, #8]	; (14f5c <ll_phy_default_set+0x10>)
}
   14f52:	2000      	movs	r0, #0
	default_phy_rx = rx;
   14f54:	7019      	strb	r1, [r3, #0]
}
   14f56:	4770      	bx	lr
   14f58:	2000aa6d 	.word	0x2000aa6d
   14f5c:	2000aa6c 	.word	0x2000aa6c

00014f60 <ull_conn_init>:
{
   14f60:	b508      	push	{r3, lr}
   14f62:	4806      	ldr	r0, [pc, #24]	; (14f7c <ull_conn_init+0x1c>)
   14f64:	f009 f85c 	bl	1e020 <z_impl_device_get_binding>
	entropy = device_get_binding(CONFIG_ENTROPY_NAME);
   14f68:	4b05      	ldr	r3, [pc, #20]	; (14f80 <ull_conn_init+0x20>)
   14f6a:	6018      	str	r0, [r3, #0]
	if (!entropy) {
   14f6c:	b118      	cbz	r0, 14f76 <ull_conn_init+0x16>
}
   14f6e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	err = init_reset();
   14f72:	f7ff bce5 	b.w	14940 <init_reset>
}
   14f76:	f06f 0012 	mvn.w	r0, #18
   14f7a:	bd08      	pop	{r3, pc}
   14f7c:	00064317 	.word	0x00064317
   14f80:	20001470 	.word	0x20001470

00014f84 <ull_conn_reset>:
{
   14f84:	b530      	push	{r4, r5, lr}
   14f86:	b085      	sub	sp, #20
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   14f88:	2302      	movs	r3, #2
	conn = ll_conn_get(handle);
   14f8a:	2000      	movs	r0, #0
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   14f8c:	9303      	str	r3, [sp, #12]
	conn = ll_conn_get(handle);
   14f8e:	f7ff ff4f 	bl	14e30 <ll_conn_get>
   14f92:	4604      	mov	r4, r0
	mark = ull_disable_mark(conn);
   14f94:	f7fe f800 	bl	12f98 <ull_disable_mark>
	LL_ASSERT(mark == conn);
   14f98:	4284      	cmp	r4, r0
   14f9a:	d00c      	beq.n	14fb6 <ull_conn_reset+0x32>
   14f9c:	f240 6377 	movw	r3, #1655	; 0x677
   14fa0:	4a29      	ldr	r2, [pc, #164]	; (15048 <ull_conn_reset+0xc4>)
   14fa2:	492a      	ldr	r1, [pc, #168]	; (1504c <ull_conn_reset+0xc8>)
   14fa4:	482a      	ldr	r0, [pc, #168]	; (15050 <ull_conn_reset+0xcc>)
   14fa6:	f00a ff04 	bl	1fdb2 <printk>
   14faa:	4040      	eors	r0, r0
   14fac:	f380 8811 	msr	BASEPRI, r0
   14fb0:	f04f 0003 	mov.w	r0, #3
   14fb4:	df02      	svc	2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   14fb6:	ad03      	add	r5, sp, #12
   14fb8:	2203      	movs	r2, #3
   14fba:	4611      	mov	r1, r2
   14fbc:	9500      	str	r5, [sp, #0]
   14fbe:	4b25      	ldr	r3, [pc, #148]	; (15054 <ull_conn_reset+0xd0>)
   14fc0:	2000      	movs	r0, #0
   14fc2:	f7fc f847 	bl	11054 <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
   14fc6:	4629      	mov	r1, r5
   14fc8:	f7fd ffda 	bl	12f80 <ull_ticker_status_take>
	if (!ret) {
   14fcc:	b988      	cbnz	r0, 14ff2 <ull_conn_reset+0x6e>
		ret = ull_disable(&conn->lll);
   14fce:	f104 001c 	add.w	r0, r4, #28
   14fd2:	f7fe f819 	bl	13008 <ull_disable>
		LL_ASSERT(!ret);
   14fd6:	b160      	cbz	r0, 14ff2 <ull_conn_reset+0x6e>
   14fd8:	f44f 63d0 	mov.w	r3, #1664	; 0x680
   14fdc:	4a1a      	ldr	r2, [pc, #104]	; (15048 <ull_conn_reset+0xc4>)
   14fde:	491e      	ldr	r1, [pc, #120]	; (15058 <ull_conn_reset+0xd4>)
   14fe0:	481b      	ldr	r0, [pc, #108]	; (15050 <ull_conn_reset+0xcc>)
   14fe2:	f00a fee6 	bl	1fdb2 <printk>
   14fe6:	4040      	eors	r0, r0
   14fe8:	f380 8811 	msr	BASEPRI, r0
   14fec:	f04f 0003 	mov.w	r0, #3
   14ff0:	df02      	svc	2
	conn->lll.link_tx_free = NULL;
   14ff2:	2300      	movs	r3, #0
   14ff4:	67a3      	str	r3, [r4, #120]	; 0x78
	mark = ull_disable_unmark(conn);
   14ff6:	4620      	mov	r0, r4
   14ff8:	f7fd ffd6 	bl	12fa8 <ull_disable_unmark>
	LL_ASSERT(mark == conn);
   14ffc:	4284      	cmp	r4, r0
   14ffe:	d00c      	beq.n	1501a <ull_conn_reset+0x96>
   15000:	f240 6386 	movw	r3, #1670	; 0x686
   15004:	4a10      	ldr	r2, [pc, #64]	; (15048 <ull_conn_reset+0xc4>)
   15006:	4911      	ldr	r1, [pc, #68]	; (1504c <ull_conn_reset+0xc8>)
   15008:	4811      	ldr	r0, [pc, #68]	; (15050 <ull_conn_reset+0xcc>)
   1500a:	f00a fed2 	bl	1fdb2 <printk>
   1500e:	4040      	eors	r0, r0
   15010:	f380 8811 	msr	BASEPRI, r0
   15014:	f04f 0003 	mov.w	r0, #3
   15018:	df02      	svc	2
	data_chan_map[0] = 0xFF;
   1501a:	4b10      	ldr	r3, [pc, #64]	; (1505c <ull_conn_reset+0xd8>)
   1501c:	22ff      	movs	r2, #255	; 0xff
   1501e:	701a      	strb	r2, [r3, #0]
	data_chan_map[1] = 0xFF;
   15020:	705a      	strb	r2, [r3, #1]
	data_chan_map[2] = 0xFF;
   15022:	709a      	strb	r2, [r3, #2]
	data_chan_map[3] = 0xFF;
   15024:	70da      	strb	r2, [r3, #3]
	data_chan_map[4] = 0x1F;
   15026:	221f      	movs	r2, #31
   15028:	711a      	strb	r2, [r3, #4]
	data_chan_count = 37U;
   1502a:	4b0d      	ldr	r3, [pc, #52]	; (15060 <ull_conn_reset+0xdc>)
   1502c:	2225      	movs	r2, #37	; 0x25
   1502e:	701a      	strb	r2, [r3, #0]
	MFIFO_INIT(conn_tx);
   15030:	4a0c      	ldr	r2, [pc, #48]	; (15064 <ull_conn_reset+0xe0>)
   15032:	2300      	movs	r3, #0
   15034:	8053      	strh	r3, [r2, #2]
	MFIFO_INIT(conn_ack);
   15036:	4a0c      	ldr	r2, [pc, #48]	; (15068 <ull_conn_reset+0xe4>)
   15038:	8053      	strh	r3, [r2, #2]
	conn_upd_curr = NULL;
   1503a:	4a0c      	ldr	r2, [pc, #48]	; (1506c <ull_conn_reset+0xe8>)
   1503c:	6013      	str	r3, [r2, #0]
	err = init_reset();
   1503e:	f7ff fc7f 	bl	14940 <init_reset>
}
   15042:	b005      	add	sp, #20
   15044:	bd30      	pop	{r4, r5, pc}
   15046:	bf00      	nop
   15048:	00064754 	.word	0x00064754
   1504c:	0006482e 	.word	0x0006482e
   15050:	000632fe 	.word	0x000632fe
   15054:	00012f75 	.word	0x00012f75
   15058:	00064330 	.word	0x00064330
   1505c:	2000edee 	.word	0x2000edee
   15060:	2000eded 	.word	0x2000eded
   15064:	2000ea84 	.word	0x2000ea84
   15068:	2000ea40 	.word	0x2000ea40
   1506c:	2000146c 	.word	0x2000146c

00015070 <ull_conn_default_tx_octets_get>:
}
   15070:	4b01      	ldr	r3, [pc, #4]	; (15078 <ull_conn_default_tx_octets_get+0x8>)
   15072:	8818      	ldrh	r0, [r3, #0]
   15074:	4770      	bx	lr
   15076:	bf00      	nop
   15078:	2000613e 	.word	0x2000613e

0001507c <ull_conn_default_tx_time_get>:
}
   1507c:	4b01      	ldr	r3, [pc, #4]	; (15084 <ull_conn_default_tx_time_get+0x8>)
   1507e:	8818      	ldrh	r0, [r3, #0]
   15080:	4770      	bx	lr
   15082:	bf00      	nop
   15084:	20006140 	.word	0x20006140

00015088 <ull_conn_default_phy_tx_get>:
}
   15088:	4b01      	ldr	r3, [pc, #4]	; (15090 <ull_conn_default_phy_tx_get+0x8>)
   1508a:	7818      	ldrb	r0, [r3, #0]
   1508c:	4770      	bx	lr
   1508e:	bf00      	nop
   15090:	2000aa6d 	.word	0x2000aa6d

00015094 <ull_conn_default_phy_rx_get>:
}
   15094:	4b01      	ldr	r3, [pc, #4]	; (1509c <ull_conn_default_phy_rx_get+0x8>)
   15096:	7818      	ldrb	r0, [r3, #0]
   15098:	4770      	bx	lr
   1509a:	bf00      	nop
   1509c:	2000aa6c 	.word	0x2000aa6c

000150a0 <ull_conn_setup>:
	lll = *((struct lll_conn **)((u8_t *)ftr->param +
   150a0:	688b      	ldr	r3, [r1, #8]
   150a2:	689b      	ldr	r3, [r3, #8]
{
   150a4:	b510      	push	{r4, lr}
	switch (lll->role) {
   150a6:	f893 4021 	ldrb.w	r4, [r3, #33]	; 0x21
   150aa:	09e4      	lsrs	r4, r4, #7
{
   150ac:	460a      	mov	r2, r1
	switch (lll->role) {
   150ae:	d004      	beq.n	150ba <ull_conn_setup+0x1a>
		ull_slave_setup(link, rx, ftr, lll);
   150b0:	3208      	adds	r2, #8
}
   150b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ull_slave_setup(link, rx, ftr, lll);
   150b6:	f7ee bcf3 	b.w	3aa0 <ull_slave_setup>
		LL_ASSERT(0);
   150ba:	f240 23c2 	movw	r3, #706	; 0x2c2
   150be:	4a06      	ldr	r2, [pc, #24]	; (150d8 <ull_conn_setup+0x38>)
   150c0:	4906      	ldr	r1, [pc, #24]	; (150dc <ull_conn_setup+0x3c>)
   150c2:	4807      	ldr	r0, [pc, #28]	; (150e0 <ull_conn_setup+0x40>)
   150c4:	f00a fe75 	bl	1fdb2 <printk>
   150c8:	4040      	eors	r0, r0
   150ca:	f380 8811 	msr	BASEPRI, r0
   150ce:	f04f 0003 	mov.w	r0, #3
   150d2:	df02      	svc	2
}
   150d4:	bd10      	pop	{r4, pc}
   150d6:	bf00      	nop
   150d8:	00064754 	.word	0x00064754
   150dc:	00065948 	.word	0x00065948
   150e0:	000632fe 	.word	0x000632fe

000150e4 <ull_conn_rx>:
	conn = ll_connected_get((*rx)->hdr.handle);
   150e4:	680b      	ldr	r3, [r1, #0]
{
   150e6:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   150ea:	4680      	mov	r8, r0
	conn = ll_connected_get((*rx)->hdr.handle);
   150ec:	88d8      	ldrh	r0, [r3, #6]
{
   150ee:	460e      	mov	r6, r1
	conn = ll_connected_get((*rx)->hdr.handle);
   150f0:	f00f fb45 	bl	2477e <ll_connected_get>
	if (!conn) {
   150f4:	6835      	ldr	r5, [r6, #0]
   150f6:	4604      	mov	r4, r0
   150f8:	b910      	cbnz	r0, 15100 <ull_conn_rx+0x1c>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   150fa:	2303      	movs	r3, #3
   150fc:	712b      	strb	r3, [r5, #4]
	return 0;
   150fe:	e1a3      	b.n	15448 <ull_conn_rx+0x364>
	switch (pdu_rx->ll_id) {
   15100:	f895 3020 	ldrb.w	r3, [r5, #32]
   15104:	f890 7152 	ldrb.w	r7, [r0, #338]	; 0x152
   15108:	f3c3 0301 	ubfx	r3, r3, #0, #2
   1510c:	b2d9      	uxtb	r1, r3
   1510e:	b25b      	sxtb	r3, r3
   15110:	f007 0201 	and.w	r2, r7, #1
   15114:	2b00      	cmp	r3, #0
   15116:	f001 8209 	beq.w	1652c <ull_conn_rx+0x1448>
   1511a:	2902      	cmp	r1, #2
   1511c:	f241 8201 	bls.w	16522 <ull_conn_rx+0x143e>
			  struct pdu_data *pdu_rx, struct ll_conn *conn)
{
	int nack = 0;
	u8_t opcode;

	opcode = pdu_rx->llctrl.opcode;
   15120:	f895 9023 	ldrb.w	r9, [r5, #35]	; 0x23

#if defined(CONFIG_BT_CTLR_LE_ENC)
	/* FIXME: do check in individual case to reduce CPU time */
	if (conn->llcp_enc.pause_rx && ctrl_is_unexpected(conn, opcode)) {
   15124:	b14a      	cbz	r2, 1513a <ull_conn_rx+0x56>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)))) ||
   15126:	f990 203d 	ldrsb.w	r2, [r0, #61]	; 0x3d
   1512a:	2a00      	cmp	r2, #0
   1512c:	f007 0304 	and.w	r3, r7, #4
   15130:	db3d      	blt.n	151ae <ull_conn_rx+0xca>
	return (!conn->lll.role &&
   15132:	bb23      	cbnz	r3, 1517e <ull_conn_rx+0x9a>
		((!conn->llcp_enc.refresh &&
   15134:	f1b9 0f02 	cmp.w	r9, #2
   15138:	d132      	bne.n	151a0 <ull_conn_rx+0xbc>
	pdu_rx = (void *)(*rx)->pdu;
   1513a:	f105 0a20 	add.w	sl, r5, #32

		return 0;
	}
#endif /* CONFIG_BT_CTLR_LE_ENC */

	switch (opcode) {
   1513e:	f1b9 0f19 	cmp.w	r9, #25
   15142:	f201 81db 	bhi.w	164fc <ull_conn_rx+0x1418>
   15146:	e8df f019 	tbh	[pc, r9, lsl #1]
   1514a:	008e      	.short	0x008e
   1514c:	003a0108 	.word	0x003a0108
   15150:	0181013b 	.word	0x0181013b
   15154:	01c901a3 	.word	0x01c901a3
   15158:	0202060b 	.word	0x0202060b
   1515c:	024c0220 	.word	0x024c0220
   15160:	02a1027d 	.word	0x02a1027d
   15164:	021702f7 	.word	0x021702f7
   15168:	049b030a 	.word	0x049b030a
   1516c:	05d4005d 	.word	0x05d4005d
   15170:	06d305f0 	.word	0x06d305f0
   15174:	07c506d3 	.word	0x07c506d3
   15178:	08e20899 	.word	0x08e20899
   1517c:	09a4      	.short	0x09a4
		 (conn->llcp_enc.refresh &&
   1517e:	f1a9 0302 	sub.w	r3, r9, #2
   15182:	b2db      	uxtb	r3, r3
   15184:	2b09      	cmp	r3, #9
   15186:	d80b      	bhi.n	151a0 <ull_conn_rx+0xbc>
   15188:	f240 2205 	movw	r2, #517	; 0x205
   1518c:	fa22 f303 	lsr.w	r3, r2, r3
   15190:	07da      	lsls	r2, r3, #31
   15192:	d4d2      	bmi.n	1513a <ull_conn_rx+0x56>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)) ||
   15194:	4bcf      	ldr	r3, [pc, #828]	; (154d4 <ull_conn_rx+0x3f0>)
   15196:	fa23 f309 	lsr.w	r3, r3, r9
   1519a:	07db      	lsls	r3, r3, #31
   1519c:	d4cd      	bmi.n	1513a <ull_conn_rx+0x56>
   1519e:	e002      	b.n	151a6 <ull_conn_rx+0xc2>
   151a0:	f1b9 0f11 	cmp.w	r9, #17
   151a4:	d9f6      	bls.n	15194 <ull_conn_rx+0xb0>
			conn->llcp_terminate.reason_peer =
   151a6:	233d      	movs	r3, #61	; 0x3d
   151a8:	f884 312b 	strb.w	r3, [r4, #299]	; 0x12b
   151ac:	e16c      	b.n	15488 <ull_conn_rx+0x3a4>
	       (conn->lll.role &&
   151ae:	b99b      	cbnz	r3, 151d8 <ull_conn_rx+0xf4>
		((!conn->llcp_enc.refresh &&
   151b0:	f1b9 0f07 	cmp.w	r9, #7
   151b4:	f000 85d4 	beq.w	15d60 <ull_conn_rx+0xc7c>
		  (opcode != PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP) &&
   151b8:	f1b9 0f02 	cmp.w	r9, #2
   151bc:	d117      	bne.n	151ee <ull_conn_rx+0x10a>
		}
	}
	break;

	case PDU_DATA_LLCTRL_TYPE_TERMINATE_IND:
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_TERMINATE_IND,
   151be:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   151c2:	2002      	movs	r0, #2
   151c4:	f7ff fb80 	bl	148c8 <pdu_len_cmp>
   151c8:	2800      	cmp	r0, #0
   151ca:	f001 8197 	beq.w	164fc <ull_conn_rx+0x1418>
				 pdu_rx->len)) {
			goto ull_conn_rx_unknown_rsp_send;
		}

		terminate_ind_recv(conn, *rx, pdu_rx);
   151ce:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
	conn->llcp_terminate.reason_peer = pdu->llctrl.terminate_ind.error_code;
   151d2:	f884 312b 	strb.w	r3, [r4, #299]	; 0x12b
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   151d6:	e790      	b.n	150fa <ull_conn_rx+0x16>
		 (conn->llcp_enc.refresh &&
   151d8:	f1b9 0f02 	cmp.w	r9, #2
   151dc:	d0ef      	beq.n	151be <ull_conn_rx+0xda>
		  (opcode != PDU_DATA_LLCTRL_TYPE_TERMINATE_IND) &&
   151de:	f1b9 0f0b 	cmp.w	r9, #11
   151e2:	f000 822f 	beq.w	15644 <ull_conn_rx+0x560>
		  (opcode != PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP) &&
   151e6:	f1b9 0f03 	cmp.w	r9, #3
   151ea:	f000 80e9 	beq.w	153c0 <ull_conn_rx+0x2dc>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)) ||
   151ee:	f1b9 0f06 	cmp.w	r9, #6
   151f2:	f000 8173 	beq.w	154dc <ull_conn_rx+0x3f8>
   151f6:	f1b9 0f0d 	cmp.w	r9, #13
   151fa:	f000 829d 	beq.w	15738 <ull_conn_rx+0x654>
	if (conn->llcp_enc.pause_rx && ctrl_is_unexpected(conn, opcode)) {
   151fe:	f1b9 0f11 	cmp.w	r9, #17
   15202:	d1d0      	bne.n	151a6 <ull_conn_rx+0xc2>

		break;
#endif /* CONFIG_BT_CTLR_CONN_PARAM_REQ */

	case PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND:
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND,
   15204:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   15208:	2011      	movs	r0, #17
   1520a:	f7ff fb5d 	bl	148c8 <pdu_len_cmp>
   1520e:	2800      	cmp	r0, #0
   15210:	f001 8174 	beq.w	164fc <ull_conn_rx+0x1418>
	switch (rej_ext_ind->reject_opcode) {
   15214:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   15218:	2b0f      	cmp	r3, #15
   1521a:	f000 84fd 	beq.w	15c18 <ull_conn_rx+0xb34>
   1521e:	f200 84c1 	bhi.w	15ba4 <ull_conn_rx+0xac0>
   15222:	2b03      	cmp	r3, #3
   15224:	f47f af69 	bne.w	150fa <ull_conn_rx+0x16>
		if ((conn->llcp_ack != conn->llcp_req) &&
   15228:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
   1522c:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   15230:	4293      	cmp	r3, r2
   15232:	f43f af62 	beq.w	150fa <ull_conn_rx+0x16>
   15236:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
   1523a:	2b03      	cmp	r3, #3
   1523c:	f47f af5d 	bne.w	150fa <ull_conn_rx+0x16>
	conn->llcp_enc.pause_rx = 0U;
   15240:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
	conn->llcp_ack = conn->llcp_req;
   15244:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
	conn->llcp_enc.pause_rx = 0U;
   15248:	f023 0303 	bic.w	r3, r3, #3
	conn->procedure_expire = 0U;
   1524c:	2000      	movs	r0, #0
	conn->llcp_enc.pause_rx = 0U;
   1524e:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	conn->procedure_expire = 0U;
   15252:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
   15256:	230d      	movs	r3, #13
   15258:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
	pdu_rx->llctrl.reject_ind.error_code = rej_ext_ind->error_code;
   1525c:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   15260:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
	if (err) {
   15264:	e1d1      	b.n	1560a <ull_conn_rx+0x526>
		if (!conn->lll.role ||
   15266:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   1526a:	2b00      	cmp	r3, #0
   1526c:	f281 8146 	bge.w	164fc <ull_conn_rx+0x1418>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND,
   15270:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   15274:	2000      	movs	r0, #0
   15276:	f7ff fb27 	bl	148c8 <pdu_len_cmp>
		if (!conn->lll.role ||
   1527a:	2800      	cmp	r0, #0
   1527c:	f001 813e 	beq.w	164fc <ull_conn_rx+0x1418>
	instant = sys_le16_to_cpu(pdu->llctrl.conn_update_ind.instant);
   15280:	f8b5 202d 	ldrh.w	r2, [r5, #45]	; 0x2d
	if (((instant - conn->lll.event_counter) & 0xFFFF) > 0x7FFF) {
   15284:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   15286:	1ad3      	subs	r3, r2, r3
   15288:	041f      	lsls	r7, r3, #16
   1528a:	d505      	bpl.n	15298 <ull_conn_rx+0x1b4>
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1528c:	2303      	movs	r3, #3
   1528e:	712b      	strb	r3, [r5, #4]
		return BT_HCI_ERR_INSTANT_PASSED;
   15290:	2328      	movs	r3, #40	; 0x28
			goto ull_conn_rx_unknown_rsp_send;
		}

		err = phy_upd_ind_recv(conn, link, rx, pdu_rx);
		if (err) {
			conn->llcp_terminate.reason_peer = err;
   15292:	f884 312b 	strb.w	r3, [r4, #299]	; 0x12b
   15296:	e0d7      	b.n	15448 <ull_conn_rx+0x364>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   15298:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   1529c:	f894 10e9 	ldrb.w	r1, [r4, #233]	; 0xe9
   152a0:	1a5b      	subs	r3, r3, r1
   152a2:	f003 0303 	and.w	r3, r3, #3
   152a6:	2b02      	cmp	r3, #2
   152a8:	d103      	bne.n	152b2 <ull_conn_rx+0x1ce>
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   152aa:	2303      	movs	r3, #3
   152ac:	712b      	strb	r3, [r5, #4]
		return BT_HCI_ERR_DIFF_TRANS_COLLISION;
   152ae:	232a      	movs	r3, #42	; 0x2a
   152b0:	e7ef      	b.n	15292 <ull_conn_rx+0x1ae>
	if (!conn_upd_curr) {
   152b2:	4b89      	ldr	r3, [pc, #548]	; (154d8 <ull_conn_rx+0x3f4>)
   152b4:	6819      	ldr	r1, [r3, #0]
   152b6:	b901      	cbnz	r1, 152ba <ull_conn_rx+0x1d6>
		conn_upd_curr = conn;
   152b8:	601c      	str	r4, [r3, #0]
	conn->llcp_cu.win_size = pdu->llctrl.conn_update_ind.win_size;
   152ba:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   152be:	f884 3114 	strb.w	r3, [r4, #276]	; 0x114
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.win_offset) * 1250;
   152c2:	f8b5 1025 	ldrh.w	r1, [r5, #37]	; 0x25
   152c6:	f240 43e2 	movw	r3, #1250	; 0x4e2
   152ca:	434b      	muls	r3, r1
	conn->llcp_cu.win_offset_us =
   152cc:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.interval);
   152d0:	f895 1028 	ldrb.w	r1, [r5, #40]	; 0x28
   152d4:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
   152d8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	conn->llcp_cu.interval =
   152dc:	f8a4 3108 	strh.w	r3, [r4, #264]	; 0x108
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.latency);
   152e0:	f895 102a 	ldrb.w	r1, [r5, #42]	; 0x2a
   152e4:	f895 3029 	ldrb.w	r3, [r5, #41]	; 0x29
   152e8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	conn->llcp_cu.latency =
   152ec:	f8a4 310a 	strh.w	r3, [r4, #266]	; 0x10a
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.timeout);
   152f0:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
   152f4:	f895 102c 	ldrb.w	r1, [r5, #44]	; 0x2c
	conn->llcp.conn_upd.instant = instant;
   152f8:	f8a4 20ec 	strh.w	r2, [r4, #236]	; 0xec
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.timeout);
   152fc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	conn->llcp_cu.timeout =
   15300:	f8a4 310c 	strh.w	r3, [r4, #268]	; 0x10c
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
   15304:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
   15308:	f023 0307 	bic.w	r3, r3, #7
   1530c:	f043 0304 	orr.w	r3, r3, #4
   15310:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
	conn->llcp_cu.ack--;
   15314:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
   15318:	3b01      	subs	r3, #1
   1531a:	f884 3105 	strb.w	r3, [r4, #261]	; 0x105
	link->mem = conn->llcp_rx;
   1531e:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
   15322:	f8c8 3004 	str.w	r3, [r8, #4]
	(*rx)->hdr.link = link;
   15326:	6833      	ldr	r3, [r6, #0]
   15328:	f8c3 8000 	str.w	r8, [r3]
	conn->llcp_rx = *rx;
   1532c:	6833      	ldr	r3, [r6, #0]
   1532e:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
	*rx = NULL;
   15332:	2300      	movs	r3, #0
   15334:	6033      	str	r3, [r6, #0]
	if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
   15336:	f894 2170 	ldrb.w	r2, [r4, #368]	; 0x170
   1533a:	f894 3171 	ldrb.w	r3, [r4, #369]	; 0x171
   1533e:	4293      	cmp	r3, r2
   15340:	d007      	beq.n	15352 <ull_conn_rx+0x26e>
	    (conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT)) {
   15342:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
	if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
   15346:	f003 0307 	and.w	r3, r3, #7
   1534a:	2b04      	cmp	r3, #4
   1534c:	d101      	bne.n	15352 <ull_conn_rx+0x26e>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   1534e:	f884 2171 	strb.w	r2, [r4, #369]	; 0x171
		conn->procedure_expire = 0U;
   15352:	2000      	movs	r0, #0
   15354:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
		break;
   15358:	e157      	b.n	1560a <ull_conn_rx+0x526>
		if (!conn->lll.role ||
   1535a:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   1535e:	2b00      	cmp	r3, #0
   15360:	f281 80cc 	bge.w	164fc <ull_conn_rx+0x1418>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CHAN_MAP_IND,
   15364:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   15368:	2001      	movs	r0, #1
   1536a:	f7ff faad 	bl	148c8 <pdu_len_cmp>
		if (!conn->lll.role ||
   1536e:	2800      	cmp	r0, #0
   15370:	f001 80c4 	beq.w	164fc <ull_conn_rx+0x1418>
	instant = sys_le16_to_cpu(pdu->llctrl.chan_map_ind.instant);
   15374:	f8b5 1029 	ldrh.w	r1, [r5, #41]	; 0x29
	if (((instant - conn->lll.event_counter) & 0xffff) > 0x7fff) {
   15378:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   1537a:	1acb      	subs	r3, r1, r3
   1537c:	0418      	lsls	r0, r3, #16
   1537e:	d485      	bmi.n	1528c <ull_conn_rx+0x1a8>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   15380:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
   15384:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   15388:	1a9b      	subs	r3, r3, r2
   1538a:	f003 0303 	and.w	r3, r3, #3
   1538e:	2b02      	cmp	r3, #2
   15390:	d08b      	beq.n	152aa <ull_conn_rx+0x1c6>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   15392:	462b      	mov	r3, r5
	conn->llcp_ack -= 2U;
   15394:	3a02      	subs	r2, #2
   15396:	f853 0f24 	ldr.w	r0, [r3, #36]!
   1539a:	f8c4 00ed 	str.w	r0, [r4, #237]	; 0xed
   1539e:	791b      	ldrb	r3, [r3, #4]
   153a0:	f884 30f1 	strb.w	r3, [r4, #241]	; 0xf1
	conn->llcp.chan_map.initiate = 0U;
   153a4:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
	conn->llcp.chan_map.instant = instant;
   153a8:	f8a4 10f2 	strh.w	r1, [r4, #242]	; 0xf2
	conn->llcp.chan_map.initiate = 0U;
   153ac:	f36f 0300 	bfc	r3, #0, #1
   153b0:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
	conn->llcp_type = LLCP_CHAN_MAP;
   153b4:	2302      	movs	r3, #2
   153b6:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
	conn->llcp_ack -= 2U;
   153ba:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   153be:	e69c      	b.n	150fa <ull_conn_rx+0x16>
		if (!conn->lll.role ||
   153c0:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   153c4:	2b00      	cmp	r3, #0
   153c6:	f281 8099 	bge.w	164fc <ull_conn_rx+0x1418>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_ENC_REQ, pdu_rx->len)) {
   153ca:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   153ce:	2003      	movs	r0, #3
   153d0:	f7ff fa7a 	bl	148c8 <pdu_len_cmp>
		if (!conn->lll.role ||
   153d4:	2800      	cmp	r0, #0
   153d6:	f001 8091 	beq.w	164fc <ull_conn_rx+0x1418>
   153da:	462a      	mov	r2, r5
   153dc:	f852 3f24 	ldr.w	r3, [r2, #36]!
   153e0:	f8c4 3155 	str.w	r3, [r4, #341]	; 0x155
   153e4:	6853      	ldr	r3, [r2, #4]
   153e6:	f8c4 3159 	str.w	r3, [r4, #345]	; 0x159
		conn->llcp_enc.ediv[0] = pdu_rx->llctrl.enc_req.ediv[0];
   153ea:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
   153ee:	f884 3153 	strb.w	r3, [r4, #339]	; 0x153
		conn->llcp_enc.ediv[1] = pdu_rx->llctrl.enc_req.ediv[1];
   153f2:	f895 302d 	ldrb.w	r3, [r5, #45]	; 0x2d
   153f6:	f884 3154 	strb.w	r3, [r4, #340]	; 0x154
		conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
   153fa:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   153fe:	2201      	movs	r2, #1
   15400:	f362 0301 	bfi	r3, r2, #0, #2
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   15404:	6832      	ldr	r2, [r6, #0]
		conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
   15406:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1540a:	2303      	movs	r3, #3
   1540c:	7113      	strb	r3, [r2, #4]
		conn->llcp_type = LLCP_ENCRYPTION;
   1540e:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
		conn->llcp_ack -= 2U;
   15412:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   15416:	462a      	mov	r2, r5
   15418:	3b02      	subs	r3, #2
   1541a:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
   1541e:	f852 3f2e 	ldr.w	r3, [r2, #46]!
   15422:	f8c4 30ee 	str.w	r3, [r4, #238]	; 0xee
   15426:	6853      	ldr	r3, [r2, #4]
   15428:	f8c4 30f2 	str.w	r3, [r4, #242]	; 0xf2
   1542c:	f8d5 3036 	ldr.w	r3, [r5, #54]	; 0x36
   15430:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
		conn->llcp_enc.pause_rx = 1U;
   15434:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   15438:	f043 0301 	orr.w	r3, r3, #1
   1543c:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		conn->procedure_expire = conn->procedure_reload;
   15440:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
   15444:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	return 0;
   15448:	2000      	movs	r0, #0
		break;
   1544a:	e0de      	b.n	1560a <ull_conn_rx+0x526>
		if (conn->lll.role ||
   1544c:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   15450:	2b00      	cmp	r3, #0
   15452:	f2c1 8053 	blt.w	164fc <ull_conn_rx+0x1418>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_ENC_RSP, pdu_rx->len)) {
   15456:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1545a:	2004      	movs	r0, #4
   1545c:	f7ff fa34 	bl	148c8 <pdu_len_cmp>
		if (conn->lll.role ||
   15460:	2800      	cmp	r0, #0
   15462:	f001 804b 	beq.w	164fc <ull_conn_rx+0x1418>
   15466:	462a      	mov	r2, r5
   15468:	f852 3f24 	ldr.w	r3, [r2, #36]!
   1546c:	f8c4 30f6 	str.w	r3, [r4, #246]	; 0xf6
   15470:	6853      	ldr	r3, [r2, #4]
   15472:	f8c4 30fa 	str.w	r3, [r4, #250]	; 0xfa
   15476:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   15478:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
		conn->llcp_enc.pause_rx = 1U;
   1547c:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   15480:	f043 0301 	orr.w	r3, r3, #1
   15484:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   15488:	6833      	ldr	r3, [r6, #0]
   1548a:	2203      	movs	r2, #3
   1548c:	711a      	strb	r2, [r3, #4]
   1548e:	e7db      	b.n	15448 <ull_conn_rx+0x364>
		if (conn->lll.role || (conn->llcp_req == conn->llcp_ack) ||
   15490:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   15494:	2b00      	cmp	r3, #0
   15496:	f2c1 8031 	blt.w	164fc <ull_conn_rx+0x1418>
   1549a:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
   1549e:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   154a2:	429a      	cmp	r2, r3
   154a4:	f001 802a 	beq.w	164fc <ull_conn_rx+0x1418>
   154a8:	f894 60ea 	ldrb.w	r6, [r4, #234]	; 0xea
   154ac:	2e03      	cmp	r6, #3
   154ae:	f041 8025 	bne.w	164fc <ull_conn_rx+0x1418>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_START_ENC_REQ,
   154b2:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   154b6:	2005      	movs	r0, #5
   154b8:	f7ff fa06 	bl	148c8 <pdu_len_cmp>
		    (conn->llcp_type != LLCP_ENCRYPTION) ||
   154bc:	2800      	cmp	r0, #0
   154be:	f001 801d 	beq.w	164fc <ull_conn_rx+0x1418>
		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   154c2:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   154c6:	f36f 0301 	bfc	r3, #0, #2
   154ca:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   154ce:	712e      	strb	r6, [r5, #4]
	return 0;
   154d0:	e7ba      	b.n	15448 <ull_conn_rx+0x364>
   154d2:	bf00      	nop
   154d4:	00022060 	.word	0x00022060
   154d8:	2000146c 	.word	0x2000146c
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_START_ENC_RSP,
   154dc:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   154e0:	2006      	movs	r0, #6
   154e2:	f7ff f9f1 	bl	148c8 <pdu_len_cmp>
   154e6:	2800      	cmp	r0, #0
   154e8:	f001 8008 	beq.w	164fc <ull_conn_rx+0x1418>
		if (conn->lll.role) {
   154ec:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   154f0:	2b00      	cmp	r3, #0
   154f2:	da25      	bge.n	15540 <ull_conn_rx+0x45c>
			if ((conn->llcp_req != conn->llcp_ack) &&
   154f4:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   154f8:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
   154fc:	4293      	cmp	r3, r2
   154fe:	d004      	beq.n	1550a <ull_conn_rx+0x426>
   15500:	f894 10ea 	ldrb.w	r1, [r4, #234]	; 0xea
   15504:	2903      	cmp	r1, #3
   15506:	f040 87f9 	bne.w	164fc <ull_conn_rx+0x1418>
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   1550a:	f894 10ec 	ldrb.w	r1, [r4, #236]	; 0xec
			if (conn->llcp_req == conn->llcp_ack) {
   1550e:	4293      	cmp	r3, r2
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   15510:	f36f 0101 	bfc	r1, #0, #2
   15514:	f884 10ec 	strb.w	r1, [r4, #236]	; 0xec
			if (conn->llcp_req == conn->llcp_ack) {
   15518:	d105      	bne.n	15526 <ull_conn_rx+0x442>
				conn->llcp_type = LLCP_ENCRYPTION;
   1551a:	2203      	movs	r2, #3
				conn->llcp_ack -= 2U;
   1551c:	3b02      	subs	r3, #2
				conn->llcp_type = LLCP_ENCRYPTION;
   1551e:	f884 20ea 	strb.w	r2, [r4, #234]	; 0xea
				conn->llcp_ack -= 2U;
   15522:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		if (conn->llcp_enc.refresh) {
   15526:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   1552a:	0759      	lsls	r1, r3, #29
   1552c:	f57f af11 	bpl.w	15352 <ull_conn_rx+0x26e>
			conn->llcp_enc.refresh = 0U;
   15530:	f36f 0382 	bfc	r3, #2, #1
   15534:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
			(*rx)->hdr.type = NODE_RX_TYPE_ENC_REFRESH;
   15538:	6833      	ldr	r3, [r6, #0]
   1553a:	220b      	movs	r2, #11
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1553c:	711a      	strb	r2, [r3, #4]
   1553e:	e708      	b.n	15352 <ull_conn_rx+0x26e>
			conn->llcp_enc.pause_rx = 0U;
   15540:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   15544:	f023 0303 	bic.w	r3, r3, #3
   15548:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
   1554c:	e7eb      	b.n	15526 <ull_conn_rx+0x442>
		if (!conn->lll.role ||
   1554e:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   15552:	2b00      	cmp	r3, #0
   15554:	f280 87d2 	bge.w	164fc <ull_conn_rx+0x1418>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_FEATURE_REQ,
   15558:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1555c:	2008      	movs	r0, #8
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_SLAVE_FEATURE_REQ,
   1555e:	f7ff f9b3 	bl	148c8 <pdu_len_cmp>
		if (conn->lll.role ||
   15562:	2800      	cmp	r0, #0
   15564:	f000 87ca 	beq.w	164fc <ull_conn_rx+0x1418>
		nack = feature_rsp_send(conn, *rx, pdu_rx);
   15568:	4652      	mov	r2, sl
   1556a:	1d29      	adds	r1, r5, #4
   1556c:	4620      	mov	r0, r4
}
   1556e:	b003      	add	sp, #12
   15570:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		nack = feature_rsp_send(conn, *rx, pdu_rx);
   15574:	f7ff bbe2 	b.w	14d3c <feature_rsp_send.isra.15>
		if (conn->lll.role ||
   15578:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   1557c:	2b00      	cmp	r3, #0
   1557e:	f2c0 87bd 	blt.w	164fc <ull_conn_rx+0x1418>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_SLAVE_FEATURE_REQ,
   15582:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   15586:	200e      	movs	r0, #14
   15588:	e7e9      	b.n	1555e <ull_conn_rx+0x47a>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_FEATURE_RSP,
   1558a:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1558e:	2009      	movs	r0, #9
   15590:	f7ff f99a 	bl	148c8 <pdu_len_cmp>
   15594:	2800      	cmp	r0, #0
   15596:	f000 87b1 	beq.w	164fc <ull_conn_rx+0x1418>
	       (features[1] << 8) | (features[2] << 16);
   1559a:	f895 3026 	ldrb.w	r3, [r5, #38]	; 0x26
   1559e:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   155a2:	041b      	lsls	r3, r3, #16
   155a4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	feat = ~LL_FEAT_BIT_MASK_VALID | features[0] |
   155a8:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
	       (features[1] << 8) | (features[2] << 16);
   155ac:	4313      	orrs	r3, r2
   155ae:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
   155b2:	f443 037e 	orr.w	r3, r3, #16646144	; 0xfe0000
	conn->llcp_feature.features &= feat_get(&rsp->features[0]);
   155b6:	f8d4 211c 	ldr.w	r2, [r4, #284]	; 0x11c
	       (features[1] << 8) | (features[2] << 16);
   155ba:	f443 5343 	orr.w	r3, r3, #12480	; 0x30c0
   155be:	f043 0310 	orr.w	r3, r3, #16
	conn->llcp_feature.features &= feat_get(&rsp->features[0]);
   155c2:	4013      	ands	r3, r2
   155c4:	f3c3 0310 	ubfx	r3, r3, #0, #17
   155c8:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
	conn->common.fex_valid = 1U;
   155cc:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
   155d0:	f043 0301 	orr.w	r3, r3, #1
   155d4:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
	conn->llcp_feature.ack = conn->llcp_feature.req;
   155d8:	f894 3118 	ldrb.w	r3, [r4, #280]	; 0x118
   155dc:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
	conn->procedure_expire = 0U;
   155e0:	e6b7      	b.n	15352 <ull_conn_rx+0x26e>
		if (!conn->lll.role ||
   155e2:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   155e6:	2b00      	cmp	r3, #0
   155e8:	f280 8788 	bge.w	164fc <ull_conn_rx+0x1418>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_REQ,
   155ec:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   155f0:	200a      	movs	r0, #10
   155f2:	f7ff f969 	bl	148c8 <pdu_len_cmp>
		if (!conn->lll.role ||
   155f6:	2800      	cmp	r0, #0
   155f8:	f000 8780 	beq.w	164fc <ull_conn_rx+0x1418>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   155fc:	48c3      	ldr	r0, [pc, #780]	; (1590c <ull_conn_rx+0x828>)
   155fe:	f00e fce6 	bl	23fce <mem_acquire>
		if (!tx) {
   15602:	4601      	mov	r1, r0
   15604:	b920      	cbnz	r0, 15610 <ull_conn_rx+0x52c>
			return -ENOBUFS;
   15606:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
   1560a:	b003      	add	sp, #12
   1560c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	conn->llcp_enc.pause_rx = 1U;
   15610:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   15614:	f023 0305 	bic.w	r3, r3, #5
   15618:	f043 0305 	orr.w	r3, r3, #5
   1561c:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	conn->lll.enc_rx = 0;
   15620:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
   15624:	f36f 03c3 	bfc	r3, #3, #1
   15628:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   1562c:	790b      	ldrb	r3, [r1, #4]
   1562e:	f043 0303 	orr.w	r3, r3, #3
   15632:	710b      	strb	r3, [r1, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
   15634:	2301      	movs	r3, #1
   15636:	714b      	strb	r3, [r1, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP;
   15638:	230b      	movs	r3, #11
   1563a:	71cb      	strb	r3, [r1, #7]
	ctrl_tx_enqueue(conn, tx);
   1563c:	4620      	mov	r0, r4
   1563e:	f00f f88b 	bl	24758 <ctrl_tx_enqueue>
   15642:	e55a      	b.n	150fa <ull_conn_rx+0x16>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP,
   15644:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   15648:	200b      	movs	r0, #11
   1564a:	f7ff f93d 	bl	148c8 <pdu_len_cmp>
   1564e:	2800      	cmp	r0, #0
   15650:	f000 8754 	beq.w	164fc <ull_conn_rx+0x1418>
	} else if (!conn->lll.role) {
   15654:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   15658:	2b00      	cmp	r3, #0
   1565a:	db10      	blt.n	1567e <ull_conn_rx+0x59a>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   1565c:	48ab      	ldr	r0, [pc, #684]	; (1590c <ull_conn_rx+0x828>)
   1565e:	f00e fcb6 	bl	23fce <mem_acquire>
		if (!tx) {
   15662:	4601      	mov	r1, r0
   15664:	2800      	cmp	r0, #0
   15666:	d0ce      	beq.n	15606 <ull_conn_rx+0x522>
	conn->llcp_enc.pause_rx = 1U;
   15668:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   1566c:	f043 0301 	orr.w	r3, r3, #1
   15670:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	conn->lll.enc_rx = 0;
   15674:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
   15678:	f023 0318 	bic.w	r3, r3, #24
   1567c:	e7d4      	b.n	15628 <ull_conn_rx+0x544>
		conn->lll.enc_tx = 0;
   1567e:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
   15682:	f36f 1304 	bfc	r3, #4, #1
   15686:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1568a:	e536      	b.n	150fa <ull_conn_rx+0x16>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_VERSION_IND,
   1568c:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   15690:	200c      	movs	r0, #12
   15692:	f7ff f919 	bl	148c8 <pdu_len_cmp>
   15696:	2800      	cmp	r0, #0
   15698:	f000 8730 	beq.w	164fc <ull_conn_rx+0x1418>
	if (!conn->llcp_version.tx) {
   1569c:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
   156a0:	07da      	lsls	r2, r3, #31
   156a2:	d43e      	bmi.n	15722 <ull_conn_rx+0x63e>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   156a4:	4899      	ldr	r0, [pc, #612]	; (1590c <ull_conn_rx+0x828>)
   156a6:	f00e fc92 	bl	23fce <mem_acquire>
		if (!tx) {
   156aa:	4601      	mov	r1, r0
   156ac:	2800      	cmp	r0, #0
   156ae:	d0aa      	beq.n	15606 <ull_conn_rx+0x522>
		conn->llcp_version.tx = 1U;
   156b0:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
   156b4:	f043 0301 	orr.w	r3, r3, #1
   156b8:	f884 3122 	strb.w	r3, [r4, #290]	; 0x122
		pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   156bc:	7903      	ldrb	r3, [r0, #4]
   156be:	f043 0303 	orr.w	r3, r3, #3
   156c2:	7103      	strb	r3, [r0, #4]
		pdu_tx->len =
   156c4:	2306      	movs	r3, #6
   156c6:	7143      	strb	r3, [r0, #5]
		pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
   156c8:	230c      	movs	r3, #12
   156ca:	71c3      	strb	r3, [r0, #7]
		v->version_number = LL_VERSION_NUMBER;
   156cc:	230a      	movs	r3, #10
   156ce:	7203      	strb	r3, [r0, #8]
		v->company_id =	sys_cpu_to_le16(ll_settings_company_id());
   156d0:	f06f 030e 	mvn.w	r3, #14
   156d4:	7243      	strb	r3, [r0, #9]
   156d6:	2305      	movs	r3, #5
   156d8:	7283      	strb	r3, [r0, #10]
		v->sub_version_number =
   156da:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   156de:	72c3      	strb	r3, [r0, #11]
   156e0:	7303      	strb	r3, [r0, #12]
		ctrl_tx_sec_enqueue(conn, tx);
   156e2:	4620      	mov	r0, r4
   156e4:	f00e fffe 	bl	246e4 <ctrl_tx_sec_enqueue>
		rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   156e8:	2303      	movs	r3, #3
   156ea:	712b      	strb	r3, [r5, #4]
	conn->llcp_version.version_number = v->version_number;
   156ec:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   156f0:	f884 3123 	strb.w	r3, [r4, #291]	; 0x123
	conn->llcp_version.company_id = sys_le16_to_cpu(v->company_id);
   156f4:	f895 2026 	ldrb.w	r2, [r5, #38]	; 0x26
   156f8:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   156fc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   15700:	f8a4 3124 	strh.w	r3, [r4, #292]	; 0x124
		sys_le16_to_cpu(v->sub_version_number);
   15704:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
   15708:	f895 2028 	ldrb.w	r2, [r5, #40]	; 0x28
   1570c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	conn->llcp_version.sub_version_number =
   15710:	f8a4 3126 	strh.w	r3, [r4, #294]	; 0x126
	conn->llcp_version.rx = 1U;
   15714:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
   15718:	f043 0302 	orr.w	r3, r3, #2
   1571c:	f884 3122 	strb.w	r3, [r4, #290]	; 0x122
	return 0;
   15720:	e692      	b.n	15448 <ull_conn_rx+0x364>
	} else if (!conn->llcp_version.rx) {
   15722:	f013 0302 	ands.w	r3, r3, #2
   15726:	f47f ace8 	bne.w	150fa <ull_conn_rx+0x16>
		conn->llcp_version.ack = conn->llcp_version.req;
   1572a:	f894 2120 	ldrb.w	r2, [r4, #288]	; 0x120
   1572e:	f884 2121 	strb.w	r2, [r4, #289]	; 0x121
		conn->procedure_expire = 0U;
   15732:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
   15736:	e7d9      	b.n	156ec <ull_conn_rx+0x608>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_REJECT_IND, pdu_rx->len)) {
   15738:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1573c:	200d      	movs	r0, #13
   1573e:	f7ff f8c3 	bl	148c8 <pdu_len_cmp>
   15742:	2800      	cmp	r0, #0
   15744:	f000 86da 	beq.w	164fc <ull_conn_rx+0x1418>
		conn->llcp_enc.pause_rx = 0U;
   15748:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   1574c:	f023 0303 	bic.w	r3, r3, #3
   15750:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		conn->llcp_ack = conn->llcp_req;
   15754:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   15758:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		conn->procedure_expire = 0U;
   1575c:	e5f9      	b.n	15352 <ull_conn_rx+0x26e>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ,
   1575e:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   15762:	200f      	movs	r0, #15
   15764:	f7ff f8b0 	bl	148c8 <pdu_len_cmp>
   15768:	2800      	cmp	r0, #0
   1576a:	f000 86c7 	beq.w	164fc <ull_conn_rx+0x1418>
		if (conn_upd_curr && (conn_upd_curr != conn)) {
   1576e:	4b68      	ldr	r3, [pc, #416]	; (15910 <ull_conn_rx+0x82c>)
   15770:	6818      	ldr	r0, [r3, #0]
   15772:	b150      	cbz	r0, 1578a <ull_conn_rx+0x6a6>
   15774:	4284      	cmp	r4, r0
   15776:	d008      	beq.n	1578a <ull_conn_rx+0x6a6>
			nack = reject_ext_ind_send(conn, *rx,
   15778:	2320      	movs	r3, #32
				nack = reject_ext_ind_send(conn, *rx,
   1577a:	220f      	movs	r2, #15
				nack = reject_ext_ind_send(conn, *rx,
   1577c:	1d29      	adds	r1, r5, #4
   1577e:	4620      	mov	r0, r4
}
   15780:	b003      	add	sp, #12
   15782:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
				nack = reject_ext_ind_send(conn, *rx,
   15786:	f7ff bb1d 	b.w	14dc4 <reject_ext_ind_send.isra.9>
		if (!conn->lll.role) {
   1578a:	f994 103d 	ldrsb.w	r1, [r4, #61]	; 0x3d
   1578e:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
   15792:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
   15796:	2900      	cmp	r1, #0
   15798:	f2c0 80bc 	blt.w	15914 <ull_conn_rx+0x830>
			if ((conn->llcp_conn_param.req !=
   1579c:	429a      	cmp	r2, r3
   1579e:	d009      	beq.n	157b4 <ull_conn_rx+0x6d0>
			    ((conn->llcp_conn_param.state ==
   157a0:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
					conn->llcp_conn_param.ack) &&
   157a4:	f013 0307 	ands.w	r3, r3, #7
   157a8:	d002      	beq.n	157b0 <ull_conn_rx+0x6cc>
			      LLCP_CPR_STATE_REQ) ||
   157aa:	3b04      	subs	r3, #4
   157ac:	2b01      	cmp	r3, #1
   157ae:	d801      	bhi.n	157b4 <ull_conn_rx+0x6d0>
				nack = reject_ext_ind_send(conn, *rx,
   157b0:	2323      	movs	r3, #35	; 0x23
   157b2:	e7e2      	b.n	1577a <ull_conn_rx+0x696>
			} else if (((((conn->llcp_req - conn->llcp_ack) &
   157b4:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   157b8:	f894 10e9 	ldrb.w	r1, [r4, #233]	; 0xe9
   157bc:	1a5b      	subs	r3, r3, r1
   157be:	f003 0303 	and.w	r3, r3, #3
   157c2:	2b02      	cmp	r3, #2
   157c4:	d103      	bne.n	157ce <ull_conn_rx+0x6ea>
				      0x03) == 0x02) &&
   157c6:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
   157ca:	2b03      	cmp	r3, #3
   157cc:	d105      	bne.n	157da <ull_conn_rx+0x6f6>
				    (conn->llcp_type != LLCP_ENCRYPTION)) ||
   157ce:	f894 11a8 	ldrb.w	r1, [r4, #424]	; 0x1a8
   157d2:	f894 31a9 	ldrb.w	r3, [r4, #425]	; 0x1a9
   157d6:	4299      	cmp	r1, r3
   157d8:	d001      	beq.n	157de <ull_conn_rx+0x6fa>
				nack = reject_ext_ind_send(conn, *rx,
   157da:	232a      	movs	r3, #42	; 0x2a
   157dc:	e7cd      	b.n	1577a <ull_conn_rx+0x696>
				u16_t interval_min =
   157de:	f8b5 a024 	ldrh.w	sl, [r5, #36]	; 0x24
   157e2:	fa1f f38a 	uxth.w	r3, sl
				if ((interval_min < 6) ||
   157e6:	2b05      	cmp	r3, #5
   157e8:	d925      	bls.n	15836 <ull_conn_rx+0x752>
				u16_t interval_max =
   157ea:	f8b5 9026 	ldrh.w	r9, [r5, #38]	; 0x26
   157ee:	fa1f f189 	uxth.w	r1, r9
				if ((interval_min < 6) ||
   157f2:	f5b1 6f48 	cmp.w	r1, #3200	; 0xc80
   157f6:	d81e      	bhi.n	15836 <ull_conn_rx+0x752>
				    (interval_max > 3200) ||
   157f8:	428b      	cmp	r3, r1
   157fa:	d81c      	bhi.n	15836 <ull_conn_rx+0x752>
				u16_t latency =
   157fc:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
   157fe:	f8ad 3000 	strh.w	r3, [sp]
   15802:	fa1f fc83 	uxth.w	ip, r3
				    (interval_min > interval_max) ||
   15806:	f5bc 7ffa 	cmp.w	ip, #500	; 0x1f4
   1580a:	d214      	bcs.n	15836 <ull_conn_rx+0x752>
				u16_t timeout =
   1580c:	f8b5 b02a 	ldrh.w	fp, [r5, #42]	; 0x2a
   15810:	fa1f f38b 	uxth.w	r3, fp
				    (latency > 499) ||
   15814:	f1a3 0e0a 	sub.w	lr, r3, #10
   15818:	fa1f fe8e 	uxth.w	lr, lr
   1581c:	f640 4876 	movw	r8, #3190	; 0xc76
   15820:	45c6      	cmp	lr, r8
   15822:	d808      	bhi.n	15836 <ull_conn_rx+0x752>
				     ((latency + 1) * interval_max)) ||
   15824:	fb0c 1e01 	mla	lr, ip, r1, r1
				    (timeout > 3200) ||
   15828:	ebbe 0f83 	cmp.w	lr, r3, lsl #2
   1582c:	d203      	bcs.n	15836 <ull_conn_rx+0x752>
					cpr->preferred_periodicity;
   1582e:	f895 e02c 	ldrb.w	lr, [r5, #44]	; 0x2c
				     ((latency + 1) * interval_max)) ||
   15832:	4571      	cmp	r1, lr
   15834:	d201      	bcs.n	1583a <ull_conn_rx+0x756>
				nack = reject_ext_ind_send(conn, *rx,
   15836:	231e      	movs	r3, #30
   15838:	e79f      	b.n	1577a <ull_conn_rx+0x696>
				conn->llcp_conn_param.latency =	latency;
   1583a:	f8bd 8000 	ldrh.w	r8, [sp]
				conn->llcp_conn_param.interval_min =
   1583e:	f8a4 a174 	strh.w	sl, [r4, #372]	; 0x174
				conn->llcp_conn_param.interval_max =
   15842:	f8a4 9176 	strh.w	r9, [r4, #374]	; 0x176
				conn->llcp_conn_param.latency =	latency;
   15846:	f8a4 8178 	strh.w	r8, [r4, #376]	; 0x178
				conn->llcp_conn_param.timeout =	timeout;
   1584a:	f8a4 b17a 	strh.w	fp, [r4, #378]	; 0x17a
				conn->llcp_conn_param.preferred_periodicity =
   1584e:	f884 e17c 	strb.w	lr, [r4, #380]	; 0x17c
					sys_le16_to_cpu(cpr->reference_conn_event_count);
   15852:	f895 802e 	ldrb.w	r8, [r5, #46]	; 0x2e
   15856:	f895 e02d 	ldrb.w	lr, [r5, #45]	; 0x2d
   1585a:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.reference_conn_event_count =
   1585e:	f8a4 e17e 	strh.w	lr, [r4, #382]	; 0x17e
					sys_le16_to_cpu(cpr->offset0);
   15862:	f895 8030 	ldrb.w	r8, [r5, #48]	; 0x30
   15866:	f895 e02f 	ldrb.w	lr, [r5, #47]	; 0x2f
   1586a:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.offset0 =
   1586e:	f8a4 e180 	strh.w	lr, [r4, #384]	; 0x180
					sys_le16_to_cpu(cpr->offset1);
   15872:	f895 8032 	ldrb.w	r8, [r5, #50]	; 0x32
   15876:	f895 e031 	ldrb.w	lr, [r5, #49]	; 0x31
   1587a:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.offset1 =
   1587e:	f8a4 e182 	strh.w	lr, [r4, #386]	; 0x182
					sys_le16_to_cpu(cpr->offset2);
   15882:	f895 8034 	ldrb.w	r8, [r5, #52]	; 0x34
   15886:	f895 e033 	ldrb.w	lr, [r5, #51]	; 0x33
   1588a:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.offset2 =
   1588e:	f8a4 e184 	strh.w	lr, [r4, #388]	; 0x184
					sys_le16_to_cpu(cpr->offset3);
   15892:	f895 8036 	ldrb.w	r8, [r5, #54]	; 0x36
   15896:	f895 e035 	ldrb.w	lr, [r5, #53]	; 0x35
   1589a:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.offset3 =
   1589e:	f8a4 e186 	strh.w	lr, [r4, #390]	; 0x186
					sys_le16_to_cpu(cpr->offset4);
   158a2:	f895 e037 	ldrb.w	lr, [r5, #55]	; 0x37
   158a6:	f895 8038 	ldrb.w	r8, [r5, #56]	; 0x38
   158aa:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.offset4 =
   158ae:	f8a4 e188 	strh.w	lr, [r4, #392]	; 0x188
					sys_le16_to_cpu(cpr->offset5);
   158b2:	f895 e039 	ldrb.w	lr, [r5, #57]	; 0x39
   158b6:	f895 503a 	ldrb.w	r5, [r5, #58]	; 0x3a
   158ba:	ea4e 2505 	orr.w	r5, lr, r5, lsl #8
				conn->llcp_conn_param.offset5 =
   158be:	f8a4 518a 	strh.w	r5, [r4, #394]	; 0x18a
				     lll->interval) ||
   158c2:	8de5      	ldrh	r5, [r4, #46]	; 0x2e
				if ((conn->llcp_conn_param.interval_max !=
   158c4:	42a9      	cmp	r1, r5
   158c6:	d112      	bne.n	158ee <ull_conn_rx+0x80a>
				     lll->interval) ||
   158c8:	8e21      	ldrh	r1, [r4, #48]	; 0x30
   158ca:	4561      	cmp	r1, ip
   158cc:	d10f      	bne.n	158ee <ull_conn_rx+0x80a>
				    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
   158ce:	f240 41e2 	movw	r1, #1250	; 0x4e2
   158d2:	4369      	muls	r1, r5
   158d4:	f242 7510 	movw	r5, #10000	; 0x2710
   158d8:	fb05 1303 	mla	r3, r5, r3, r1
   158dc:	3b01      	subs	r3, #1
   158de:	fbb3 f3f1 	udiv	r3, r3, r1
				     lll->latency) ||
   158e2:	f8b4 10c6 	ldrh.w	r1, [r4, #198]	; 0xc6
   158e6:	b29b      	uxth	r3, r3
   158e8:	4299      	cmp	r1, r3
   158ea:	f000 80b2 	beq.w	15a52 <ull_conn_rx+0x96e>
					if (conn->llcp_enc.pause_tx) {
   158ee:	f017 0f02 	tst.w	r7, #2
   158f2:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   158f6:	f000 809e 	beq.w	15a36 <ull_conn_rx+0x952>
						conn->llcp_conn_param.state =
   158fa:	2102      	movs	r1, #2
   158fc:	f361 0302 	bfi	r3, r1, #0, #3
   15900:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   15904:	6833      	ldr	r3, [r6, #0]
   15906:	2103      	movs	r1, #3
   15908:	7119      	strb	r1, [r3, #4]
   1590a:	e099      	b.n	15a40 <ull_conn_rx+0x95c>
   1590c:	200014ec 	.word	0x200014ec
   15910:	2000146c 	.word	0x2000146c
		} else if ((conn->llcp_conn_param.req ==
   15914:	429a      	cmp	r2, r3
   15916:	d004      	beq.n	15922 <ull_conn_rx+0x83e>
			    conn->llcp_conn_param.ack) ||
   15918:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   1591c:	079f      	lsls	r7, r3, #30
   1591e:	f040 80a1 	bne.w	15a64 <ull_conn_rx+0x980>
			u16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
   15922:	f8b5 a024 	ldrh.w	sl, [r5, #36]	; 0x24
   15926:	fa1f f38a 	uxth.w	r3, sl
			if ((interval_min < 6) ||
   1592a:	2b05      	cmp	r3, #5
   1592c:	d983      	bls.n	15836 <ull_conn_rx+0x752>
			u16_t interval_max = sys_le16_to_cpu(cpr->interval_max);
   1592e:	f8b5 9026 	ldrh.w	r9, [r5, #38]	; 0x26
   15932:	fa1f f189 	uxth.w	r1, r9
			if ((interval_min < 6) ||
   15936:	f5b1 6f48 	cmp.w	r1, #3200	; 0xc80
   1593a:	f63f af7c 	bhi.w	15836 <ull_conn_rx+0x752>
			    (interval_max > 3200) ||
   1593e:	428b      	cmp	r3, r1
   15940:	f63f af79 	bhi.w	15836 <ull_conn_rx+0x752>
			u16_t latency = sys_le16_to_cpu(cpr->latency);
   15944:	f8b5 8028 	ldrh.w	r8, [r5, #40]	; 0x28
   15948:	fa1f f788 	uxth.w	r7, r8
			    (interval_min > interval_max) ||
   1594c:	f5b7 7ffa 	cmp.w	r7, #500	; 0x1f4
   15950:	f4bf af71 	bcs.w	15836 <ull_conn_rx+0x752>
			u16_t timeout = sys_le16_to_cpu(cpr->timeout);
   15954:	f8b5 e02a 	ldrh.w	lr, [r5, #42]	; 0x2a
   15958:	fa1f f38e 	uxth.w	r3, lr
			    (latency > 499) ||
   1595c:	f1a3 0c0a 	sub.w	ip, r3, #10
   15960:	fa1f fc8c 	uxth.w	ip, ip
   15964:	f640 4b76 	movw	fp, #3190	; 0xc76
   15968:	45dc      	cmp	ip, fp
   1596a:	f63f af64 	bhi.w	15836 <ull_conn_rx+0x752>
			     ((latency + 1) * interval_max)) ||
   1596e:	fb07 1c01 	mla	ip, r7, r1, r1
			    (timeout < 10) || (timeout > 3200) ||
   15972:	ebbc 0f83 	cmp.w	ip, r3, lsl #2
   15976:	f4bf af5e 	bcs.w	15836 <ull_conn_rx+0x752>
				cpr->preferred_periodicity;
   1597a:	f895 c02c 	ldrb.w	ip, [r5, #44]	; 0x2c
			     ((latency + 1) * interval_max)) ||
   1597e:	4561      	cmp	r1, ip
   15980:	f4ff af59 	bcc.w	15836 <ull_conn_rx+0x752>
			conn->llcp_conn_param.interval_min = interval_min;
   15984:	f8a4 a174 	strh.w	sl, [r4, #372]	; 0x174
			conn->llcp_conn_param.interval_max = interval_max;
   15988:	f8a4 9176 	strh.w	r9, [r4, #374]	; 0x176
			conn->llcp_conn_param.latency =	latency;
   1598c:	f8a4 8178 	strh.w	r8, [r4, #376]	; 0x178
			conn->llcp_conn_param.timeout =	timeout;
   15990:	f8a4 e17a 	strh.w	lr, [r4, #378]	; 0x17a
			conn->llcp_conn_param.preferred_periodicity =
   15994:	f884 c17c 	strb.w	ip, [r4, #380]	; 0x17c
				sys_le16_to_cpu(cpr->reference_conn_event_count);
   15998:	f895 e02e 	ldrb.w	lr, [r5, #46]	; 0x2e
   1599c:	f895 c02d 	ldrb.w	ip, [r5, #45]	; 0x2d
   159a0:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.reference_conn_event_count =
   159a4:	f8a4 c17e 	strh.w	ip, [r4, #382]	; 0x17e
				sys_le16_to_cpu(cpr->offset0);
   159a8:	f895 e030 	ldrb.w	lr, [r5, #48]	; 0x30
   159ac:	f895 c02f 	ldrb.w	ip, [r5, #47]	; 0x2f
   159b0:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.offset0 =
   159b4:	f8a4 c180 	strh.w	ip, [r4, #384]	; 0x180
				sys_le16_to_cpu(cpr->offset1);
   159b8:	f895 e032 	ldrb.w	lr, [r5, #50]	; 0x32
   159bc:	f895 c031 	ldrb.w	ip, [r5, #49]	; 0x31
   159c0:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.offset1 =
   159c4:	f8a4 c182 	strh.w	ip, [r4, #386]	; 0x182
				sys_le16_to_cpu(cpr->offset2);
   159c8:	f895 e034 	ldrb.w	lr, [r5, #52]	; 0x34
   159cc:	f895 c033 	ldrb.w	ip, [r5, #51]	; 0x33
   159d0:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.offset2 =
   159d4:	f8a4 c184 	strh.w	ip, [r4, #388]	; 0x184
				sys_le16_to_cpu(cpr->offset3);
   159d8:	f895 e036 	ldrb.w	lr, [r5, #54]	; 0x36
   159dc:	f895 c035 	ldrb.w	ip, [r5, #53]	; 0x35
   159e0:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.offset3 =
   159e4:	f8a4 c186 	strh.w	ip, [r4, #390]	; 0x186
				sys_le16_to_cpu(cpr->offset4);
   159e8:	f895 c037 	ldrb.w	ip, [r5, #55]	; 0x37
   159ec:	f895 e038 	ldrb.w	lr, [r5, #56]	; 0x38
   159f0:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.offset4 =
   159f4:	f8a4 c188 	strh.w	ip, [r4, #392]	; 0x188
				sys_le16_to_cpu(cpr->offset5);
   159f8:	f895 c039 	ldrb.w	ip, [r5, #57]	; 0x39
   159fc:	f895 503a 	ldrb.w	r5, [r5, #58]	; 0x3a
   15a00:	ea4c 2505 	orr.w	r5, ip, r5, lsl #8
			conn->llcp_conn_param.offset5 =
   15a04:	f8a4 518a 	strh.w	r5, [r4, #394]	; 0x18a
			     lll->interval) ||
   15a08:	8de5      	ldrh	r5, [r4, #46]	; 0x2e
			if ((conn->llcp_conn_param.interval_max !=
   15a0a:	42a9      	cmp	r1, r5
   15a0c:	d111      	bne.n	15a32 <ull_conn_rx+0x94e>
			     lll->interval) ||
   15a0e:	8e25      	ldrh	r5, [r4, #48]	; 0x30
   15a10:	42bd      	cmp	r5, r7
   15a12:	d10e      	bne.n	15a32 <ull_conn_rx+0x94e>
			    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
   15a14:	f240 45e2 	movw	r5, #1250	; 0x4e2
   15a18:	4369      	muls	r1, r5
   15a1a:	f242 7510 	movw	r5, #10000	; 0x2710
   15a1e:	fb05 1303 	mla	r3, r5, r3, r1
   15a22:	3b01      	subs	r3, #1
   15a24:	fbb3 f3f1 	udiv	r3, r3, r1
			    (conn->llcp_conn_param.latency != lll->latency) ||
   15a28:	f8b4 10c6 	ldrh.w	r1, [r4, #198]	; 0xc6
   15a2c:	b29b      	uxth	r3, r3
   15a2e:	4299      	cmp	r1, r3
   15a30:	d00f      	beq.n	15a52 <ull_conn_rx+0x96e>
				conn->llcp_conn_param.state =
   15a32:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   15a36:	2103      	movs	r1, #3
   15a38:	f361 0302 	bfi	r3, r1, #0, #3
   15a3c:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
			conn->llcp_conn_param.ack--;
   15a40:	3a01      	subs	r2, #1
   15a42:	f884 2171 	strb.w	r2, [r4, #369]	; 0x171
			if (!conn_upd_curr) {
   15a46:	2800      	cmp	r0, #0
   15a48:	f47f acfe 	bne.w	15448 <ull_conn_rx+0x364>
				conn_upd_curr = conn;
   15a4c:	4bbe      	ldr	r3, [pc, #760]	; (15d48 <ull_conn_rx+0xc64>)
   15a4e:	601c      	str	r4, [r3, #0]
   15a50:	e5db      	b.n	1560a <ull_conn_rx+0x526>
				conn->llcp_conn_param.state =
   15a52:	f8b4 3172 	ldrh.w	r3, [r4, #370]	; 0x172
   15a56:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   15a5a:	f043 0301 	orr.w	r3, r3, #1
   15a5e:	f8a4 3172 	strh.w	r3, [r4, #370]	; 0x172
   15a62:	e74f      	b.n	15904 <ull_conn_rx+0x820>
			LL_ASSERT(0);
   15a64:	f241 6311 	movw	r3, #5649	; 0x1611
   15a68:	4ab8      	ldr	r2, [pc, #736]	; (15d4c <ull_conn_rx+0xc68>)
   15a6a:	49b9      	ldr	r1, [pc, #740]	; (15d50 <ull_conn_rx+0xc6c>)
   15a6c:	48b9      	ldr	r0, [pc, #740]	; (15d54 <ull_conn_rx+0xc70>)
   15a6e:	f00a f9a0 	bl	1fdb2 <printk>
   15a72:	4040      	eors	r0, r0
   15a74:	f380 8811 	msr	BASEPRI, r0
   15a78:	f04f 0003 	mov.w	r0, #3
   15a7c:	df02      	svc	2
   15a7e:	e4e3      	b.n	15448 <ull_conn_rx+0x364>
		if (conn->lll.role ||
   15a80:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   15a84:	2b00      	cmp	r3, #0
   15a86:	f2c0 8539 	blt.w	164fc <ull_conn_rx+0x1418>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CONN_PARAM_RSP,
   15a8a:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   15a8e:	2010      	movs	r0, #16
   15a90:	f7fe ff1a 	bl	148c8 <pdu_len_cmp>
		if (conn->lll.role ||
   15a94:	2800      	cmp	r0, #0
   15a96:	f000 8531 	beq.w	164fc <ull_conn_rx+0x1418>
		if (!conn->lll.role &&
   15a9a:	f894 2170 	ldrb.w	r2, [r4, #368]	; 0x170
   15a9e:	f894 3171 	ldrb.w	r3, [r4, #369]	; 0x171
   15aa2:	429a      	cmp	r2, r3
   15aa4:	f43f acf0 	beq.w	15488 <ull_conn_rx+0x3a4>
		    (conn->llcp_conn_param.state ==
   15aa8:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
		     conn->llcp_conn_param.ack) &&
   15aac:	f003 0307 	and.w	r3, r3, #7
   15ab0:	2b04      	cmp	r3, #4
   15ab2:	f47f ace9 	bne.w	15488 <ull_conn_rx+0x3a4>
			u16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
   15ab6:	f8b5 e024 	ldrh.w	lr, [r5, #36]	; 0x24
   15aba:	fa1f f28e 	uxth.w	r2, lr
			if ((interval_min < 6) ||
   15abe:	2a05      	cmp	r2, #5
   15ac0:	d920      	bls.n	15b04 <ull_conn_rx+0xa20>
			u16_t interval_max = sys_le16_to_cpu(cpr->interval_max);
   15ac2:	f8b5 c026 	ldrh.w	ip, [r5, #38]	; 0x26
   15ac6:	fa1f f38c 	uxth.w	r3, ip
			if ((interval_min < 6) ||
   15aca:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   15ace:	d819      	bhi.n	15b04 <ull_conn_rx+0xa20>
			    (interval_max > 3200) ||
   15ad0:	429a      	cmp	r2, r3
   15ad2:	d817      	bhi.n	15b04 <ull_conn_rx+0xa20>
			u16_t latency = sys_le16_to_cpu(cpr->latency);
   15ad4:	8d2f      	ldrh	r7, [r5, #40]	; 0x28
   15ad6:	b2ba      	uxth	r2, r7
			    (interval_min > interval_max) ||
   15ad8:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
   15adc:	d212      	bcs.n	15b04 <ull_conn_rx+0xa20>
			u16_t timeout = sys_le16_to_cpu(cpr->timeout);
   15ade:	8d68      	ldrh	r0, [r5, #42]	; 0x2a
   15ae0:	fa1f f880 	uxth.w	r8, r0
			    (latency > 499) ||
   15ae4:	f1a8 010a 	sub.w	r1, r8, #10
   15ae8:	b289      	uxth	r1, r1
   15aea:	f640 4976 	movw	r9, #3190	; 0xc76
   15aee:	4549      	cmp	r1, r9
   15af0:	d808      	bhi.n	15b04 <ull_conn_rx+0xa20>
			     ((latency + 1) * interval_max)) ||
   15af2:	fb02 3203 	mla	r2, r2, r3, r3
			    (timeout < 10) || (timeout > 3200) ||
   15af6:	ebb2 0f88 	cmp.w	r2, r8, lsl #2
   15afa:	d203      	bcs.n	15b04 <ull_conn_rx+0xa20>
				cpr->preferred_periodicity;
   15afc:	f895 202c 	ldrb.w	r2, [r5, #44]	; 0x2c
			     ((latency + 1) * interval_max)) ||
   15b00:	4293      	cmp	r3, r2
   15b02:	d202      	bcs.n	15b0a <ull_conn_rx+0xa26>
				nack = reject_ext_ind_send(conn, *rx,
   15b04:	231e      	movs	r3, #30
   15b06:	2210      	movs	r2, #16
   15b08:	e638      	b.n	1577c <ull_conn_rx+0x698>
			conn->procedure_expire = 0U;
   15b0a:	2300      	movs	r3, #0
   15b0c:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
			conn->llcp_conn_param.interval_min = interval_min;
   15b10:	f8a4 e174 	strh.w	lr, [r4, #372]	; 0x174
			conn->llcp_conn_param.interval_max = interval_max;
   15b14:	f8a4 c176 	strh.w	ip, [r4, #374]	; 0x176
			conn->llcp_conn_param.latency =	latency;
   15b18:	f8a4 7178 	strh.w	r7, [r4, #376]	; 0x178
			conn->llcp_conn_param.timeout =	timeout;
   15b1c:	f8a4 017a 	strh.w	r0, [r4, #378]	; 0x17a
			conn->llcp_conn_param.preferred_periodicity =
   15b20:	f884 217c 	strb.w	r2, [r4, #380]	; 0x17c
				sys_le16_to_cpu(cpr->reference_conn_event_count);
   15b24:	f895 202e 	ldrb.w	r2, [r5, #46]	; 0x2e
   15b28:	f895 302d 	ldrb.w	r3, [r5, #45]	; 0x2d
   15b2c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.reference_conn_event_count =
   15b30:	f8a4 317e 	strh.w	r3, [r4, #382]	; 0x17e
				sys_le16_to_cpu(cpr->offset0);
   15b34:	f895 2030 	ldrb.w	r2, [r5, #48]	; 0x30
   15b38:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
   15b3c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset0 =
   15b40:	f8a4 3180 	strh.w	r3, [r4, #384]	; 0x180
				sys_le16_to_cpu(cpr->offset1);
   15b44:	f895 2032 	ldrb.w	r2, [r5, #50]	; 0x32
   15b48:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
   15b4c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset1 =
   15b50:	f8a4 3182 	strh.w	r3, [r4, #386]	; 0x182
				sys_le16_to_cpu(cpr->offset2);
   15b54:	f895 2034 	ldrb.w	r2, [r5, #52]	; 0x34
   15b58:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
   15b5c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset2 =
   15b60:	f8a4 3184 	strh.w	r3, [r4, #388]	; 0x184
				sys_le16_to_cpu(cpr->offset3);
   15b64:	f895 2036 	ldrb.w	r2, [r5, #54]	; 0x36
   15b68:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
   15b6c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset3 =
   15b70:	f8a4 3186 	strh.w	r3, [r4, #390]	; 0x186
				sys_le16_to_cpu(cpr->offset4);
   15b74:	f895 2038 	ldrb.w	r2, [r5, #56]	; 0x38
   15b78:	f895 3037 	ldrb.w	r3, [r5, #55]	; 0x37
   15b7c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset4 =
   15b80:	f8a4 3188 	strh.w	r3, [r4, #392]	; 0x188
				sys_le16_to_cpu(cpr->offset5);
   15b84:	f895 203a 	ldrb.w	r2, [r5, #58]	; 0x3a
   15b88:	f895 3039 	ldrb.w	r3, [r5, #57]	; 0x39
   15b8c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset5 =
   15b90:	f8a4 318a 	strh.w	r3, [r4, #394]	; 0x18a
			conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP;
   15b94:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   15b98:	2201      	movs	r2, #1
   15b9a:	f362 0302 	bfi	r3, r2, #0, #3
   15b9e:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   15ba2:	e471      	b.n	15488 <ull_conn_rx+0x3a4>
	switch (rej_ext_ind->reject_opcode) {
   15ba4:	2b14      	cmp	r3, #20
   15ba6:	f000 8085 	beq.w	15cb4 <ull_conn_rx+0xbd0>
   15baa:	2b16      	cmp	r3, #22
   15bac:	f47f aaa5 	bne.w	150fa <ull_conn_rx+0x16>
		if (conn->llcp_phy.ack != conn->llcp_phy.req) {
   15bb0:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
   15bb4:	f894 21a9 	ldrb.w	r2, [r4, #425]	; 0x1a9
   15bb8:	429a      	cmp	r2, r3
   15bba:	f43f aa9e 	beq.w	150fa <ull_conn_rx+0x16>
	if (rej_ext_ind->error_code != BT_HCI_ERR_LL_PROC_COLLISION) {
   15bbe:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   15bc2:	2a23      	cmp	r2, #35	; 0x23
   15bc4:	d012      	beq.n	15bec <ull_conn_rx+0xb08>
		conn->llcp_phy.ack = conn->llcp_phy.req;
   15bc6:	f884 31a9 	strb.w	r3, [r4, #425]	; 0x1a9
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   15bca:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
   15bce:	f3c3 0102 	ubfx	r1, r3, #0, #3
   15bd2:	f361 1306 	bfi	r3, r1, #4, #3
   15bd6:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
   15bda:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   15bde:	f36f 0300 	bfc	r3, #0, #1
   15be2:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		conn->procedure_expire = 0U;
   15be6:	2300      	movs	r3, #0
   15be8:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	if (!conn->llcp_phy.cmd) {
   15bec:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   15bf0:	0759      	lsls	r1, r3, #29
   15bf2:	f57f aa82 	bpl.w	150fa <ull_conn_rx+0x16>
	rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
   15bf6:	230e      	movs	r3, #14
   15bf8:	712b      	strb	r3, [r5, #4]
	p->status = rej_ext_ind->error_code;
   15bfa:	f885 2020 	strb.w	r2, [r5, #32]
	p->tx = conn->lll.phy_tx;
   15bfe:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
   15c02:	f3c3 0302 	ubfx	r3, r3, #0, #3
   15c06:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
	p->rx = conn->lll.phy_rx;
   15c0a:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
   15c0e:	f3c3 0302 	ubfx	r3, r3, #0, #3
   15c12:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
	if (err) {
   15c16:	e417      	b.n	15448 <ull_conn_rx+0x364>
		if (conn->llcp_conn_param.ack != conn->llcp_conn_param.req) {
   15c18:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
   15c1c:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
   15c20:	429a      	cmp	r2, r3
   15c22:	f43f aa6a 	beq.w	150fa <ull_conn_rx+0x16>
	if (!lll->role && (rej_ext_ind->error_code ==
   15c26:	f994 203d 	ldrsb.w	r2, [r4, #61]	; 0x3d
   15c2a:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   15c2e:	2a00      	cmp	r2, #0
   15c30:	f2c0 848c 	blt.w	1654c <ull_conn_rx+0x1468>
   15c34:	2b1a      	cmp	r3, #26
   15c36:	f040 848f 	bne.w	16558 <ull_conn_rx+0x1474>
		LL_ASSERT(conn->llcp_cu.req == conn->llcp_cu.ack);
   15c3a:	f894 2104 	ldrb.w	r2, [r4, #260]	; 0x104
   15c3e:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
   15c42:	429a      	cmp	r2, r3
   15c44:	d00c      	beq.n	15c60 <ull_conn_rx+0xb7c>
   15c46:	f241 0346 	movw	r3, #4166	; 0x1046
   15c4a:	4a40      	ldr	r2, [pc, #256]	; (15d4c <ull_conn_rx+0xc68>)
   15c4c:	4942      	ldr	r1, [pc, #264]	; (15d58 <ull_conn_rx+0xc74>)
   15c4e:	4841      	ldr	r0, [pc, #260]	; (15d54 <ull_conn_rx+0xc70>)
   15c50:	f00a f8af 	bl	1fdb2 <printk>
   15c54:	4040      	eors	r0, r0
   15c56:	f380 8811 	msr	BASEPRI, r0
   15c5a:	f04f 0003 	mov.w	r0, #3
   15c5e:	df02      	svc	2
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
   15c60:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
   15c64:	2305      	movs	r3, #5
   15c66:	f363 0202 	bfi	r2, r3, #0, #3
		conn->llcp_cu.win_offset_us = 0U;
   15c6a:	2300      	movs	r3, #0
   15c6c:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
		conn->llcp_cu.interval = conn->llcp_conn_param.interval_max;
   15c70:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
   15c74:	f8a4 3108 	strh.w	r3, [r4, #264]	; 0x108
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
   15c78:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
   15c7c:	f8a4 310a 	strh.w	r3, [r4, #266]	; 0x10a
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
   15c80:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
   15c84:	f8a4 310c 	strh.w	r3, [r4, #268]	; 0x10c
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   15c88:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
   15c8c:	f884 2172 	strb.w	r2, [r4, #370]	; 0x172
		conn->llcp_cu.win_size = 1U;
   15c90:	2101      	movs	r1, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   15c92:	f361 0301 	bfi	r3, r1, #0, #2
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
   15c96:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   15c9a:	f362 0382 	bfi	r3, r2, #2, #1
   15c9e:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
		conn->llcp_cu.ack--;
   15ca2:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
		conn->llcp_cu.win_size = 1U;
   15ca6:	f884 1114 	strb.w	r1, [r4, #276]	; 0x114
		conn->llcp_cu.ack--;
   15caa:	3b01      	subs	r3, #1
   15cac:	f884 3105 	strb.w	r3, [r4, #261]	; 0x105
	if (err) {
   15cb0:	f7ff ba23 	b.w	150fa <ull_conn_rx+0x16>
		if (conn->llcp_length.ack != conn->llcp_length.req) {
   15cb4:	f894 3198 	ldrb.w	r3, [r4, #408]	; 0x198
   15cb8:	f894 2199 	ldrb.w	r2, [r4, #409]	; 0x199
   15cbc:	429a      	cmp	r2, r3
   15cbe:	f43f aa1c 	beq.w	150fa <ull_conn_rx+0x16>
	conn->llcp_length.ack = conn->llcp_length.req;
   15cc2:	f884 3199 	strb.w	r3, [r4, #409]	; 0x199
	conn->procedure_expire = 0U;
   15cc6:	2000      	movs	r0, #0
	pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
   15cc8:	2309      	movs	r3, #9
	conn->procedure_expire = 0U;
   15cca:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
	pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
   15cce:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
   15cd2:	2315      	movs	r3, #21
   15cd4:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
	lr->max_rx_octets = sys_cpu_to_le16(conn->lll.max_rx_octets);
   15cd8:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
   15cdc:	84ab      	strh	r3, [r5, #36]	; 0x24
	lr->max_tx_octets = sys_cpu_to_le16(conn->lll.max_tx_octets);
   15cde:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
   15ce2:	852b      	strh	r3, [r5, #40]	; 0x28
	lr->max_rx_time = sys_cpu_to_le16(conn->lll.max_rx_time);
   15ce4:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
   15ce8:	84eb      	strh	r3, [r5, #38]	; 0x26
	lr->max_tx_time = sys_cpu_to_le16(conn->lll.max_tx_time);
   15cea:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
   15cee:	856b      	strh	r3, [r5, #42]	; 0x2a
	if (err) {
   15cf0:	e48b      	b.n	1560a <ull_conn_rx+0x526>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PING_REQ, pdu_rx->len)) {
   15cf2:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   15cf6:	2012      	movs	r0, #18
   15cf8:	f7fe fde6 	bl	148c8 <pdu_len_cmp>
   15cfc:	2800      	cmp	r0, #0
   15cfe:	f000 83fd 	beq.w	164fc <ull_conn_rx+0x1418>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   15d02:	4816      	ldr	r0, [pc, #88]	; (15d5c <ull_conn_rx+0xc78>)
   15d04:	f00e f963 	bl	23fce <mem_acquire>
	if (!tx) {
   15d08:	4601      	mov	r1, r0
   15d0a:	2800      	cmp	r0, #0
   15d0c:	f43f ac7b 	beq.w	15606 <ull_conn_rx+0x522>
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   15d10:	7903      	ldrb	r3, [r0, #4]
   15d12:	f043 0303 	orr.w	r3, r3, #3
   15d16:	7103      	strb	r3, [r0, #4]
	pdu_tx->len = offsetof(struct pdu_data_llctrl, ping_rsp) +
   15d18:	2301      	movs	r3, #1
   15d1a:	7143      	strb	r3, [r0, #5]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_RSP;
   15d1c:	2313      	movs	r3, #19
   15d1e:	71c3      	strb	r3, [r0, #7]
	ctrl_tx_sec_enqueue(conn, tx);
   15d20:	4620      	mov	r0, r4
   15d22:	f00e fcdf 	bl	246e4 <ctrl_tx_sec_enqueue>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   15d26:	f7ff b9e8 	b.w	150fa <ull_conn_rx+0x16>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PING_RSP, pdu_rx->len)) {
   15d2a:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   15d2e:	2013      	movs	r0, #19
   15d30:	f7fe fdca 	bl	148c8 <pdu_len_cmp>
   15d34:	2800      	cmp	r0, #0
   15d36:	f000 83e1 	beq.w	164fc <ull_conn_rx+0x1418>
		conn->procedure_expire = 0U;
   15d3a:	2000      	movs	r0, #0
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   15d3c:	2303      	movs	r3, #3
		conn->procedure_expire = 0U;
   15d3e:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   15d42:	712b      	strb	r3, [r5, #4]
		break;
   15d44:	e461      	b.n	1560a <ull_conn_rx+0x526>
   15d46:	bf00      	nop
   15d48:	2000146c 	.word	0x2000146c
   15d4c:	00064754 	.word	0x00064754
   15d50:	00065948 	.word	0x00065948
   15d54:	000632fe 	.word	0x000632fe
   15d58:	0006483b 	.word	0x0006483b
   15d5c:	200014ec 	.word	0x200014ec
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP,
   15d60:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   15d64:	2007      	movs	r0, #7
   15d66:	f7fe fdaf 	bl	148c8 <pdu_len_cmp>
   15d6a:	2800      	cmp	r0, #0
   15d6c:	f000 83c6 	beq.w	164fc <ull_conn_rx+0x1418>
		} else if (conn->llcp_conn_param.ack !=
   15d70:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
   15d74:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
   15d78:	429a      	cmp	r2, r3
   15d7a:	d07b      	beq.n	15e74 <ull_conn_rx+0xd90>
			conn->llcp_conn_param.disabled = 1U;
   15d7c:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   15d80:	f043 0310 	orr.w	r3, r3, #16
   15d84:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
			if (!conn->lll.role) {
   15d88:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   15d8c:	2b00      	cmp	r3, #0
   15d8e:	db3f      	blt.n	15e10 <ull_conn_rx+0xd2c>
				LL_ASSERT(conn->llcp_cu.req ==
   15d90:	f894 2104 	ldrb.w	r2, [r4, #260]	; 0x104
   15d94:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
   15d98:	429a      	cmp	r2, r3
   15d9a:	d00c      	beq.n	15db6 <ull_conn_rx+0xcd2>
   15d9c:	f241 6392 	movw	r3, #5778	; 0x1692
   15da0:	4ac5      	ldr	r2, [pc, #788]	; (160b8 <ull_conn_rx+0xfd4>)
   15da2:	49c6      	ldr	r1, [pc, #792]	; (160bc <ull_conn_rx+0xfd8>)
   15da4:	48c6      	ldr	r0, [pc, #792]	; (160c0 <ull_conn_rx+0xfdc>)
   15da6:	f00a f804 	bl	1fdb2 <printk>
   15daa:	4040      	eors	r0, r0
   15dac:	f380 8811 	msr	BASEPRI, r0
   15db0:	f04f 0003 	mov.w	r0, #3
   15db4:	df02      	svc	2
				conn->llcp_conn_param.state =
   15db6:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
   15dba:	2305      	movs	r3, #5
   15dbc:	f363 0202 	bfi	r2, r3, #0, #3
				conn->llcp_cu.interval =
   15dc0:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
   15dc4:	f8a4 3108 	strh.w	r3, [r4, #264]	; 0x108
				conn->llcp_cu.latency =
   15dc8:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
   15dcc:	f8a4 310a 	strh.w	r3, [r4, #266]	; 0x10a
				conn->llcp_cu.timeout =
   15dd0:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
   15dd4:	f8a4 310c 	strh.w	r3, [r4, #268]	; 0x10c
				conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   15dd8:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
				conn->llcp_conn_param.state =
   15ddc:	f884 2172 	strb.w	r2, [r4, #370]	; 0x172
				conn->llcp_cu.win_size = 1U;
   15de0:	2101      	movs	r1, #1
				conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   15de2:	f361 0301 	bfi	r3, r1, #0, #2
				conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
   15de6:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   15dea:	f362 0382 	bfi	r3, r2, #2, #1
   15dee:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
				conn->llcp_cu.ack--;
   15df2:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
				conn->llcp_cu.win_size = 1U;
   15df6:	f884 1114 	strb.w	r1, [r4, #276]	; 0x114
				conn->llcp_cu.ack--;
   15dfa:	3b01      	subs	r3, #1
   15dfc:	f884 3105 	strb.w	r3, [r4, #261]	; 0x105
				conn->llcp_cu.win_offset_us = 0U;
   15e00:	2000      	movs	r0, #0
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   15e02:	6833      	ldr	r3, [r6, #0]
				conn->llcp_cu.win_offset_us = 0U;
   15e04:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   15e08:	2203      	movs	r2, #3
   15e0a:	711a      	strb	r2, [r3, #4]
				break;
   15e0c:	f7ff bbfd 	b.w	1560a <ull_conn_rx+0x526>
			LL_ASSERT(conn_upd_curr == conn);
   15e10:	4fac      	ldr	r7, [pc, #688]	; (160c4 <ull_conn_rx+0xfe0>)
   15e12:	683a      	ldr	r2, [r7, #0]
   15e14:	4294      	cmp	r4, r2
   15e16:	d00c      	beq.n	15e32 <ull_conn_rx+0xd4e>
   15e18:	f241 63a9 	movw	r3, #5801	; 0x16a9
   15e1c:	4aa6      	ldr	r2, [pc, #664]	; (160b8 <ull_conn_rx+0xfd4>)
   15e1e:	49aa      	ldr	r1, [pc, #680]	; (160c8 <ull_conn_rx+0xfe4>)
   15e20:	48a7      	ldr	r0, [pc, #668]	; (160c0 <ull_conn_rx+0xfdc>)
   15e22:	f009 ffc6 	bl	1fdb2 <printk>
   15e26:	4040      	eors	r0, r0
   15e28:	f380 8811 	msr	BASEPRI, r0
   15e2c:	f04f 0003 	mov.w	r0, #3
   15e30:	df02      	svc	2
			conn_upd_curr = NULL;
   15e32:	2300      	movs	r3, #0
			if (!conn->llcp_conn_param.cmd) {
   15e34:	f894 0172 	ldrb.w	r0, [r4, #370]	; 0x172
			conn_upd_curr = NULL;
   15e38:	603b      	str	r3, [r7, #0]
			conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   15e3a:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
   15e3e:	f884 3171 	strb.w	r3, [r4, #369]	; 0x171
			if (!conn->llcp_conn_param.cmd) {
   15e42:	f010 0008 	ands.w	r0, r0, #8
   15e46:	6833      	ldr	r3, [r6, #0]
   15e48:	d0de      	beq.n	15e08 <ull_conn_rx+0xd24>
			(*rx)->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
   15e4a:	220a      	movs	r2, #10
   15e4c:	711a      	strb	r2, [r3, #4]
			cu->status = BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
   15e4e:	231a      	movs	r3, #26
   15e50:	f885 3020 	strb.w	r3, [r5, #32]
			cu->latency = lll->latency;
   15e54:	8e22      	ldrh	r2, [r4, #48]	; 0x30
			cu->interval = lll->interval;
   15e56:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
			cu->latency = lll->latency;
   15e58:	84aa      	strh	r2, [r5, #36]	; 0x24
			cu->timeout = conn->supervision_reload *
   15e5a:	f8b4 20c6 	ldrh.w	r2, [r4, #198]	; 0xc6
			cu->interval = lll->interval;
   15e5e:	846b      	strh	r3, [r5, #34]	; 0x22
			cu->timeout = conn->supervision_reload *
   15e60:	435a      	muls	r2, r3
				      lll->interval * 125U / 1000;
   15e62:	237d      	movs	r3, #125	; 0x7d
   15e64:	4353      	muls	r3, r2
   15e66:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   15e6a:	fbb3 f3f2 	udiv	r3, r3, r2
			cu->timeout = conn->supervision_reload *
   15e6e:	84eb      	strh	r3, [r5, #38]	; 0x26
   15e70:	f7ff ba6f 	b.w	15352 <ull_conn_rx+0x26e>
		} else if (conn->llcp_length.req != conn->llcp_length.ack) {
   15e74:	f894 3198 	ldrb.w	r3, [r4, #408]	; 0x198
   15e78:	f894 2199 	ldrb.w	r2, [r4, #409]	; 0x199
   15e7c:	429a      	cmp	r2, r3
   15e7e:	d003      	beq.n	15e88 <ull_conn_rx+0xda4>
			conn->llcp_length.ack = conn->llcp_length.req;
   15e80:	f884 3199 	strb.w	r3, [r4, #409]	; 0x199
   15e84:	f7ff ba65 	b.w	15352 <ull_conn_rx+0x26e>
		} else if (conn->llcp_phy.req !=
   15e88:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
   15e8c:	f894 21a9 	ldrb.w	r2, [r4, #425]	; 0x1a9
   15e90:	429a      	cmp	r2, r3
   15e92:	d025      	beq.n	15ee0 <ull_conn_rx+0xdfc>
			conn->llcp_phy.ack = conn->llcp_phy.req;
   15e94:	f884 31a9 	strb.w	r3, [r4, #425]	; 0x1a9
			lll->phy_tx_time = lll->phy_tx;
   15e98:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
			conn->llcp_phy.pause_tx = 0U;
   15e9c:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
			lll->phy_tx_time = lll->phy_tx;
   15ea0:	f3c3 0102 	ubfx	r1, r3, #0, #3
			conn->llcp_phy.pause_tx = 0U;
   15ea4:	f36f 0200 	bfc	r2, #0, #1
			lll->phy_tx_time = lll->phy_tx;
   15ea8:	f361 1306 	bfi	r3, r1, #4, #3
			conn->llcp_phy.pause_tx = 0U;
   15eac:	f884 21ab 	strb.w	r2, [r4, #427]	; 0x1ab
			lll->phy_tx_time = lll->phy_tx;
   15eb0:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
			if (conn->llcp_phy.cmd) {
   15eb4:	f012 0f04 	tst.w	r2, #4
   15eb8:	6833      	ldr	r3, [r6, #0]
   15eba:	d00e      	beq.n	15eda <ull_conn_rx+0xdf6>
				(*rx)->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
   15ebc:	220e      	movs	r2, #14
   15ebe:	711a      	strb	r2, [r3, #4]
				p->status = 0U;
   15ec0:	2300      	movs	r3, #0
   15ec2:	f885 3020 	strb.w	r3, [r5, #32]
				p->tx = lll->phy_tx;
   15ec6:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21
				p->rx = lll->phy_rx;
   15eca:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
   15ece:	f3c3 0302 	ubfx	r3, r3, #0, #3
   15ed2:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   15ed6:	f7ff ba3c 	b.w	15352 <ull_conn_rx+0x26e>
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   15eda:	2203      	movs	r2, #3
   15edc:	f7ff bb2e 	b.w	1553c <ull_conn_rx+0x458>
			switch (llctrl->unknown_rsp.type) {
   15ee0:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   15ee4:	2b12      	cmp	r3, #18
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   15ee6:	bf04      	itt	eq
   15ee8:	2303      	moveq	r3, #3
   15eea:	712b      	strbeq	r3, [r5, #4]
				break;
   15eec:	f7ff ba31 	b.w	15352 <ull_conn_rx+0x26e>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_LENGTH_REQ,
   15ef0:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   15ef4:	2014      	movs	r0, #20
   15ef6:	f7fe fce7 	bl	148c8 <pdu_len_cmp>
   15efa:	2800      	cmp	r0, #0
   15efc:	f000 82fe 	beq.w	164fc <ull_conn_rx+0x1418>
	if (pdu_rx->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_LENGTH_REQ) {
   15f00:	f1b9 0f14 	cmp.w	r9, #20
   15f04:	d176      	bne.n	15ff4 <ull_conn_rx+0xf10>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   15f06:	4871      	ldr	r0, [pc, #452]	; (160cc <ull_conn_rx+0xfe8>)
   15f08:	f00e f861 	bl	23fce <mem_acquire>
		if (!tx) {
   15f0c:	4607      	mov	r7, r0
   15f0e:	2800      	cmp	r0, #0
   15f10:	f43f ab79 	beq.w	15606 <ull_conn_rx+0x522>
	eff_rx_octets = conn->lll.max_rx_octets;
   15f14:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
   15f18:	9300      	str	r3, [sp, #0]
	    ((conn->llcp_length.req == conn->llcp_length.ack) &&
   15f1a:	f894 3198 	ldrb.w	r3, [r4, #408]	; 0x198
   15f1e:	9301      	str	r3, [sp, #4]
	if (/* Local idle, and Peer request then complete the Peer procedure
   15f20:	f894 2199 	ldrb.w	r2, [r4, #409]	; 0x199
   15f24:	9901      	ldr	r1, [sp, #4]
	eff_tx_octets = conn->lll.max_tx_octets;
   15f26:	f8b4 905c 	ldrh.w	r9, [r4, #92]	; 0x5c
	eff_rx_time = conn->lll.max_rx_time;
   15f2a:	f8b4 a062 	ldrh.w	sl, [r4, #98]	; 0x62
	eff_tx_time = conn->lll.max_tx_time;
   15f2e:	f8b4 b060 	ldrh.w	fp, [r4, #96]	; 0x60
	if (/* Local idle, and Peer request then complete the Peer procedure
   15f32:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
   15f36:	428a      	cmp	r2, r1
   15f38:	d15e      	bne.n	15ff8 <ull_conn_rx+0xf14>
	    ((conn->llcp_length.req == conn->llcp_length.ack) &&
   15f3a:	2b14      	cmp	r3, #20
   15f3c:	f040 80b4 	bne.w	160a8 <ull_conn_rx+0xfc4>
		max_rx_octets = sys_le16_to_cpu(lr->max_rx_octets);
   15f40:	8cab      	ldrh	r3, [r5, #36]	; 0x24
		if (max_rx_octets >= PDU_DC_PAYLOAD_SIZE_MIN) {
   15f42:	2b1a      	cmp	r3, #26
   15f44:	d974      	bls.n	16030 <ull_conn_rx+0xf4c>
			eff_tx_octets = MIN(max_rx_octets,
   15f46:	f8b4 20d6 	ldrh.w	r2, [r4, #214]	; 0xd6
   15f4a:	429a      	cmp	r2, r3
   15f4c:	bf28      	it	cs
   15f4e:	461a      	movcs	r2, r3
		if (max_tx_octets >= PDU_DC_PAYLOAD_SIZE_MIN) {
   15f50:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
			eff_rx_octets = MIN(max_tx_octets,
   15f52:	2b1b      	cmp	r3, #27
   15f54:	9b00      	ldr	r3, [sp, #0]
   15f56:	bf38      	it	cc
   15f58:	469c      	movcc	ip, r3
		max_rx_time = sys_le16_to_cpu(lr->max_rx_time);
   15f5a:	8ceb      	ldrh	r3, [r5, #38]	; 0x26
			eff_rx_octets = MIN(max_tx_octets,
   15f5c:	bf28      	it	cs
   15f5e:	f04f 0c1b 	movcs.w	ip, #27
		if (max_rx_time >= PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0)) {
   15f62:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
   15f66:	d365      	bcc.n	16034 <ull_conn_rx+0xf50>
			eff_tx_time = MIN(max_rx_time,
   15f68:	f8b4 10d8 	ldrh.w	r1, [r4, #216]	; 0xd8
   15f6c:	428b      	cmp	r3, r1
   15f6e:	bf28      	it	cs
   15f70:	460b      	movcs	r3, r1
		if (max_tx_time >= PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0)) {
   15f72:	8d69      	ldrh	r1, [r5, #42]	; 0x2a
		if (eff_rx_octets != conn->lll.max_rx_octets) {
   15f74:	9800      	ldr	r0, [sp, #0]
			eff_rx_time = MIN(max_tx_time,
   15f76:	f5b1 7fa4 	cmp.w	r1, #328	; 0x148
   15f7a:	bf34      	ite	cc
   15f7c:	4651      	movcc	r1, sl
   15f7e:	f44f 71a4 	movcs.w	r1, #328	; 0x148
		if (eff_rx_octets != conn->lll.max_rx_octets) {
   15f82:	4560      	cmp	r0, ip
   15f84:	d05e      	beq.n	16044 <ull_conn_rx+0xf60>
			conn->llcp_length.ack = (conn->llcp_length.req -
   15f86:	9801      	ldr	r0, [sp, #4]
			conn->llcp_length.rx_octets = eff_rx_octets;
   15f88:	f8a4 c19c 	strh.w	ip, [r4, #412]	; 0x19c
			conn->llcp_length.ack = (conn->llcp_length.req -
   15f8c:	3801      	subs	r0, #1
   15f8e:	f884 0199 	strb.w	r0, [r4, #409]	; 0x199
			conn->llcp_length.tx_octets = eff_tx_octets;
   15f92:	f8a4 219e 	strh.w	r2, [r4, #414]	; 0x19e
			conn->llcp_length.rx_time = eff_rx_time;
   15f96:	f8a4 11a0 	strh.w	r1, [r4, #416]	; 0x1a0
			conn->llcp_length.tx_time = eff_tx_time;
   15f9a:	f8a4 31a2 	strh.w	r3, [r4, #418]	; 0x1a2
			if (tx) {
   15f9e:	f894 019a 	ldrb.w	r0, [r4, #410]	; 0x19a
   15fa2:	2f00      	cmp	r7, #0
   15fa4:	d048      	beq.n	16038 <ull_conn_rx+0xf54>
				conn->llcp_length.state =
   15fa6:	2505      	movs	r5, #5
				conn->llcp_length.state =
   15fa8:	f365 0002 	bfi	r0, r5, #0, #3
   15fac:	f884 019a 	strb.w	r0, [r4, #410]	; 0x19a
			link->mem = conn->llcp_rx;
   15fb0:	f8d4 0100 	ldr.w	r0, [r4, #256]	; 0x100
   15fb4:	f8c8 0004 	str.w	r0, [r8, #4]
			(*rx)->hdr.link = link;
   15fb8:	6830      	ldr	r0, [r6, #0]
   15fba:	f8c0 8000 	str.w	r8, [r0]
			conn->llcp_rx = *rx;
   15fbe:	6830      	ldr	r0, [r6, #0]
   15fc0:	f8c4 0100 	str.w	r0, [r4, #256]	; 0x100
			*rx = NULL;
   15fc4:	2000      	movs	r0, #0
   15fc6:	6030      	str	r0, [r6, #0]
	if (tx) {
   15fc8:	2f00      	cmp	r7, #0
   15fca:	f43f aa3d 	beq.w	15448 <ull_conn_rx+0x364>
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   15fce:	7938      	ldrb	r0, [r7, #4]
	pdu_tx->llctrl.length_rsp.max_rx_time = sys_cpu_to_le16(eff_rx_time);
   15fd0:	8179      	strh	r1, [r7, #10]
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   15fd2:	f040 0003 	orr.w	r0, r0, #3
   15fd6:	7138      	strb	r0, [r7, #4]
	pdu_tx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
   15fd8:	2009      	movs	r0, #9
   15fda:	7178      	strb	r0, [r7, #5]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
   15fdc:	2015      	movs	r0, #21
   15fde:	71f8      	strb	r0, [r7, #7]
	pdu_tx->llctrl.length_rsp.max_rx_octets =
   15fe0:	f8a7 c008 	strh.w	ip, [r7, #8]
	pdu_tx->llctrl.length_rsp.max_tx_octets =
   15fe4:	81ba      	strh	r2, [r7, #12]
	pdu_tx->llctrl.length_rsp.max_tx_time = sys_cpu_to_le16(eff_tx_time);
   15fe6:	81fb      	strh	r3, [r7, #14]
	ctrl_tx_sec_enqueue(conn, tx);
   15fe8:	4639      	mov	r1, r7
   15fea:	4620      	mov	r0, r4
   15fec:	f00e fb7a 	bl	246e4 <ctrl_tx_sec_enqueue>
   15ff0:	f7ff ba2a 	b.w	15448 <ull_conn_rx+0x364>
	struct node_tx *tx = NULL;
   15ff4:	2700      	movs	r7, #0
   15ff6:	e78d      	b.n	15f14 <ull_conn_rx+0xe30>
	     ((((conn->llcp_length.state == LLCP_LENGTH_STATE_REQ) ||
   15ff8:	f894 219a 	ldrb.w	r2, [r4, #410]	; 0x19a
	    ((conn->llcp_length.req != conn->llcp_length.ack) &&
   15ffc:	f012 0f06 	tst.w	r2, #6
   16000:	d101      	bne.n	16006 <ull_conn_rx+0xf22>
		(conn->llcp_length.state == LLCP_LENGTH_STATE_REQ_ACK_WAIT)) &&
   16002:	2b14      	cmp	r3, #20
   16004:	d09c      	beq.n	15f40 <ull_conn_rx+0xe5c>
		PDU_DATA_LLCTRL_TYPE_LENGTH_REQ)) ||
   16006:	f002 0207 	and.w	r2, r2, #7
   1600a:	2a02      	cmp	r2, #2
   1600c:	d14c      	bne.n	160a8 <ull_conn_rx+0xfc4>
	      ((conn->llcp_length.state == LLCP_LENGTH_STATE_RSP_WAIT) &&
   1600e:	3b14      	subs	r3, #20
   16010:	2b01      	cmp	r3, #1
   16012:	d995      	bls.n	15f40 <ull_conn_rx+0xe5c>
		LL_ASSERT(pdu_rx->llctrl.opcode ==
   16014:	f241 2316 	movw	r3, #4630	; 0x1216
   16018:	4a27      	ldr	r2, [pc, #156]	; (160b8 <ull_conn_rx+0xfd4>)
   1601a:	492d      	ldr	r1, [pc, #180]	; (160d0 <ull_conn_rx+0xfec>)
   1601c:	4828      	ldr	r0, [pc, #160]	; (160c0 <ull_conn_rx+0xfdc>)
   1601e:	f009 fec8 	bl	1fdb2 <printk>
   16022:	4040      	eors	r0, r0
   16024:	f380 8811 	msr	BASEPRI, r0
   16028:	f04f 0003 	mov.w	r0, #3
   1602c:	df02      	svc	2
   1602e:	e03d      	b.n	160ac <ull_conn_rx+0xfc8>
	eff_tx_octets = conn->lll.max_tx_octets;
   16030:	464a      	mov	r2, r9
   16032:	e78d      	b.n	15f50 <ull_conn_rx+0xe6c>
	eff_tx_time = conn->lll.max_tx_time;
   16034:	465b      	mov	r3, fp
   16036:	e79c      	b.n	15f72 <ull_conn_rx+0xe8e>
				conn->lll.max_tx_octets = eff_tx_octets;
   16038:	f8a4 205c 	strh.w	r2, [r4, #92]	; 0x5c
				conn->lll.max_tx_time = eff_tx_time;
   1603c:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
				conn->llcp_length.state =
   16040:	2504      	movs	r5, #4
   16042:	e7b1      	b.n	15fa8 <ull_conn_rx+0xec4>
			conn->llcp_length.ack = conn->llcp_length.req;
   16044:	9801      	ldr	r0, [sp, #4]
   16046:	f884 0199 	strb.w	r0, [r4, #409]	; 0x199
			conn->procedure_expire = 0U;
   1604a:	f04f 0e00 	mov.w	lr, #0
			if (eff_tx_octets == conn->lll.max_tx_octets &&
   1604e:	4591      	cmp	r9, r2
			conn->procedure_expire = 0U;
   16050:	f8a4 e0cc 	strh.w	lr, [r4, #204]	; 0xcc
			if (eff_tx_octets == conn->lll.max_tx_octets &&
   16054:	d107      	bne.n	16066 <ull_conn_rx+0xf82>
   16056:	459b      	cmp	fp, r3
   16058:	d105      	bne.n	16066 <ull_conn_rx+0xf82>
			    eff_rx_time == conn->lll.max_rx_time &&
   1605a:	458a      	cmp	sl, r1
   1605c:	d103      	bne.n	16066 <ull_conn_rx+0xf82>
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1605e:	6830      	ldr	r0, [r6, #0]
   16060:	2503      	movs	r5, #3
   16062:	7105      	strb	r5, [r0, #4]
				goto send_length_resp;
   16064:	e7b0      	b.n	15fc8 <ull_conn_rx+0xee4>
			conn->lll.max_rx_time = eff_rx_time;
   16066:	f8a4 1062 	strh.w	r1, [r4, #98]	; 0x62
			if (tx) {
   1606a:	b1c7      	cbz	r7, 1609e <ull_conn_rx+0xfba>
					(conn->llcp_length.req - 1);
   1606c:	9801      	ldr	r0, [sp, #4]
				conn->llcp_length.rx_octets = eff_rx_octets;
   1606e:	f8a4 c19c 	strh.w	ip, [r4, #412]	; 0x19c
					(conn->llcp_length.req - 1);
   16072:	3801      	subs	r0, #1
				conn->llcp_length.ack =
   16074:	f884 0199 	strb.w	r0, [r4, #409]	; 0x199
				conn->llcp_length.state =
   16078:	f894 019a 	ldrb.w	r0, [r4, #410]	; 0x19a
				conn->llcp_length.tx_octets = eff_tx_octets;
   1607c:	f8a4 219e 	strh.w	r2, [r4, #414]	; 0x19e
				conn->llcp_length.state =
   16080:	2603      	movs	r6, #3
   16082:	f366 0002 	bfi	r0, r6, #0, #3
				conn->llcp_length.rx_time = eff_rx_time;
   16086:	f8a4 11a0 	strh.w	r1, [r4, #416]	; 0x1a0
				conn->llcp_length.tx_time = eff_tx_time;
   1608a:	f8a4 31a2 	strh.w	r3, [r4, #418]	; 0x1a2
				conn->llcp_length.state =
   1608e:	f884 019a 	strb.w	r0, [r4, #410]	; 0x19a
			lr->max_rx_octets = sys_cpu_to_le16(eff_rx_octets);
   16092:	f8a5 c024 	strh.w	ip, [r5, #36]	; 0x24
			lr->max_tx_octets = sys_cpu_to_le16(eff_tx_octets);
   16096:	852a      	strh	r2, [r5, #40]	; 0x28
			lr->max_rx_time = sys_cpu_to_le16(eff_rx_time);
   16098:	84e9      	strh	r1, [r5, #38]	; 0x26
			lr->max_tx_time = sys_cpu_to_le16(eff_tx_time);
   1609a:	856b      	strh	r3, [r5, #42]	; 0x2a
   1609c:	e794      	b.n	15fc8 <ull_conn_rx+0xee4>
				conn->lll.max_tx_octets = eff_tx_octets;
   1609e:	f8a4 205c 	strh.w	r2, [r4, #92]	; 0x5c
				conn->lll.max_tx_time = eff_tx_time;
   160a2:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
   160a6:	e7f4      	b.n	16092 <ull_conn_rx+0xfae>
		LL_ASSERT(pdu_rx->llctrl.opcode ==
   160a8:	2b15      	cmp	r3, #21
   160aa:	d1b3      	bne.n	16014 <ull_conn_rx+0xf30>
	eff_tx_time = conn->lll.max_tx_time;
   160ac:	465b      	mov	r3, fp
	eff_rx_time = conn->lll.max_rx_time;
   160ae:	4651      	mov	r1, sl
	eff_tx_octets = conn->lll.max_tx_octets;
   160b0:	464a      	mov	r2, r9
	eff_rx_octets = conn->lll.max_rx_octets;
   160b2:	f8dd c000 	ldr.w	ip, [sp]
   160b6:	e787      	b.n	15fc8 <ull_conn_rx+0xee4>
   160b8:	00064754 	.word	0x00064754
   160bc:	0006483b 	.word	0x0006483b
   160c0:	000632fe 	.word	0x000632fe
   160c4:	2000146c 	.word	0x2000146c
   160c8:	00064862 	.word	0x00064862
   160cc:	200014ec 	.word	0x200014ec
   160d0:	00064878 	.word	0x00064878
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PHY_REQ, pdu_rx->len)) {
   160d4:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   160d8:	2016      	movs	r0, #22
   160da:	f7fe fbf5 	bl	148c8 <pdu_len_cmp>
   160de:	2800      	cmp	r0, #0
   160e0:	f000 820c 	beq.w	164fc <ull_conn_rx+0x1418>
		if (!conn->lll.role) {
   160e4:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   160e8:	2b00      	cmp	r3, #0
   160ea:	db6d      	blt.n	161c8 <ull_conn_rx+0x10e4>
			if ((conn->llcp_phy.ack !=
   160ec:	f894 31a9 	ldrb.w	r3, [r4, #425]	; 0x1a9
			     conn->llcp_phy.req) &&
   160f0:	f894 11a8 	ldrb.w	r1, [r4, #424]	; 0x1a8
			if ((conn->llcp_phy.ack !=
   160f4:	428b      	cmp	r3, r1
   160f6:	d00a      	beq.n	1610e <ull_conn_rx+0x102a>
			      LLCP_PHY_STATE_RSP_WAIT) ||
   160f8:	f894 21aa 	ldrb.w	r2, [r4, #426]	; 0x1aa
   160fc:	f002 0203 	and.w	r2, r2, #3
			     conn->llcp_phy.req) &&
   16100:	3a01      	subs	r2, #1
   16102:	2a02      	cmp	r2, #2
   16104:	d803      	bhi.n	1610e <ull_conn_rx+0x102a>
				nack = reject_ext_ind_send(conn, *rx,
   16106:	2323      	movs	r3, #35	; 0x23
				nack = reject_ext_ind_send(conn, *rx,
   16108:	2216      	movs	r2, #22
   1610a:	f7ff bb37 	b.w	1577c <ull_conn_rx+0x698>
			} else if (((((conn->llcp_req - conn->llcp_ack) &
   1610e:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
   16112:	f894 00e9 	ldrb.w	r0, [r4, #233]	; 0xe9
   16116:	1a12      	subs	r2, r2, r0
   16118:	f002 0203 	and.w	r2, r2, #3
   1611c:	2a02      	cmp	r2, #2
   1611e:	d103      	bne.n	16128 <ull_conn_rx+0x1044>
				      0x03) == 0x02) &&
   16120:	f894 20ea 	ldrb.w	r2, [r4, #234]	; 0xea
   16124:	2a03      	cmp	r2, #3
   16126:	d105      	bne.n	16134 <ull_conn_rx+0x1050>
				     LLCP_ENCRYPTION)) ||
   16128:	f894 0170 	ldrb.w	r0, [r4, #368]	; 0x170
   1612c:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
   16130:	4290      	cmp	r0, r2
   16132:	d001      	beq.n	16138 <ull_conn_rx+0x1054>
				nack = reject_ext_ind_send(conn, *rx,
   16134:	232a      	movs	r3, #42	; 0x2a
   16136:	e7e7      	b.n	16108 <ull_conn_rx+0x1024>
				conn->llcp_phy.state =
   16138:	f894 21aa 	ldrb.w	r2, [r4, #426]	; 0x1aa
				if (conn->llcp_phy.ack ==
   1613c:	428b      	cmp	r3, r1
				conn->llcp_phy.state =
   1613e:	f042 0203 	orr.w	r2, r2, #3
   16142:	f884 21aa 	strb.w	r2, [r4, #426]	; 0x1aa
				if (conn->llcp_phy.ack ==
   16146:	d116      	bne.n	16176 <ull_conn_rx+0x1092>
					conn->llcp_phy.ack--;
   16148:	3b01      	subs	r3, #1
   1614a:	f884 31a9 	strb.w	r3, [r4, #425]	; 0x1a9
					conn->llcp_phy.cmd = 0U;
   1614e:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
						conn->phy_pref_tx;
   16152:	f894 21ac 	ldrb.w	r2, [r4, #428]	; 0x1ac
					conn->llcp_phy.cmd = 0U;
   16156:	f36f 0382 	bfc	r3, #2, #1
   1615a:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
					conn->llcp_phy.tx =
   1615e:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
						conn->phy_pref_tx;
   16162:	f3c2 0102 	ubfx	r1, r2, #0, #3
					conn->llcp_phy.tx =
   16166:	f361 0384 	bfi	r3, r1, #2, #3
						conn->phy_pref_rx;
   1616a:	f3c2 1202 	ubfx	r2, r2, #4, #3
					conn->llcp_phy.rx =
   1616e:	f362 1347 	bfi	r3, r2, #5, #3
   16172:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
				conn->llcp_phy.tx &= p->rx_phys;
   16176:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   1617a:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   1617e:	f3c3 0182 	ubfx	r1, r3, #2, #3
   16182:	400a      	ands	r2, r1
   16184:	f362 0384 	bfi	r3, r2, #2, #3
   16188:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
				conn->llcp_phy.rx &= p->tx_phys;
   1618c:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
   16190:	b2db      	uxtb	r3, r3
   16192:	ea02 1253 	and.w	r2, r2, r3, lsr #5
   16196:	f362 1347 	bfi	r3, r2, #5, #3
   1619a:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
				if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
   1619e:	b2db      	uxtb	r3, r3
   161a0:	f013 0f1c 	tst.w	r3, #28
   161a4:	d002      	beq.n	161ac <ull_conn_rx+0x10c8>
   161a6:	f013 0fe0 	tst.w	r3, #224	; 0xe0
   161aa:	d105      	bne.n	161b8 <ull_conn_rx+0x10d4>
					conn->llcp_phy.tx = 0;
   161ac:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   161b0:	f003 0303 	and.w	r3, r3, #3
   161b4:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
				conn->llcp_phy.pause_tx = 1U;
   161b8:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   161bc:	f043 0301 	orr.w	r3, r3, #1
   161c0:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   161c4:	f7ff b960 	b.w	15488 <ull_conn_rx+0x3a4>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   161c8:	48db      	ldr	r0, [pc, #876]	; (16538 <ull_conn_rx+0x1454>)
   161ca:	f00d ff00 	bl	23fce <mem_acquire>
	if (!tx) {
   161ce:	4601      	mov	r1, r0
   161d0:	2800      	cmp	r0, #0
   161d2:	f43f aa18 	beq.w	15606 <ull_conn_rx+0x522>
	conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
   161d6:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
	if (conn->llcp_phy.ack ==
   161da:	f894 c1a9 	ldrb.w	ip, [r4, #425]	; 0x1a9
	conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
   161de:	2202      	movs	r2, #2
   161e0:	f362 0301 	bfi	r3, r2, #0, #2
   161e4:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
	if (conn->llcp_phy.ack ==
   161e8:	f894 21ac 	ldrb.w	r2, [r4, #428]	; 0x1ac
   161ec:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
   161f0:	f3c2 0002 	ubfx	r0, r2, #0, #3
   161f4:	4563      	cmp	r3, ip
   161f6:	f3c2 1202 	ubfx	r2, r2, #4, #3
   161fa:	b2c7      	uxtb	r7, r0
   161fc:	b2d6      	uxtb	r6, r2
   161fe:	d114      	bne.n	1622a <ull_conn_rx+0x1146>
		conn->llcp_phy.ack--;
   16200:	3b01      	subs	r3, #1
   16202:	f884 31a9 	strb.w	r3, [r4, #425]	; 0x1a9
		conn->llcp_phy.cmd = 0U;
   16206:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   1620a:	f36f 0382 	bfc	r3, #2, #1
   1620e:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		conn->llcp_phy.tx =
   16212:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   16216:	f367 0384 	bfi	r3, r7, #2, #3
		conn->llcp_phy.rx =
   1621a:	f366 1347 	bfi	r3, r6, #5, #3
   1621e:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
		conn->procedure_expire =
   16222:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
   16226:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	conn->llcp_phy.tx &= p->rx_phys;
   1622a:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   1622e:	f895 6025 	ldrb.w	r6, [r5, #37]	; 0x25
   16232:	f3c3 0782 	ubfx	r7, r3, #2, #3
   16236:	403e      	ands	r6, r7
   16238:	f366 0384 	bfi	r3, r6, #2, #3
   1623c:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
	conn->llcp_phy.rx &= p->tx_phys;
   16240:	f895 6024 	ldrb.w	r6, [r5, #36]	; 0x24
   16244:	b2db      	uxtb	r3, r3
   16246:	ea06 1653 	and.w	r6, r6, r3, lsr #5
   1624a:	f366 1347 	bfi	r3, r6, #5, #3
   1624e:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
	conn->llcp_phy.pause_tx = 1U;
   16252:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   16256:	f043 0301 	orr.w	r3, r3, #1
   1625a:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   1625e:	790b      	ldrb	r3, [r1, #4]
	pdu_ctrl_tx->llctrl.phy_rsp.tx_phys = conn->phy_pref_tx;
   16260:	7208      	strb	r0, [r1, #8]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   16262:	f043 0303 	orr.w	r3, r3, #3
   16266:	710b      	strb	r3, [r1, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, phy_rsp) +
   16268:	2603      	movs	r6, #3
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_RSP;
   1626a:	2317      	movs	r3, #23
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, phy_rsp) +
   1626c:	714e      	strb	r6, [r1, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_RSP;
   1626e:	71cb      	strb	r3, [r1, #7]
	pdu_ctrl_tx->llctrl.phy_rsp.rx_phys = conn->phy_pref_rx;
   16270:	724a      	strb	r2, [r1, #9]
	ctrl_tx_enqueue(conn, tx);
   16272:	4620      	mov	r0, r4
   16274:	f00e fa70 	bl	24758 <ctrl_tx_enqueue>
   16278:	f7ff b929 	b.w	154ce <ull_conn_rx+0x3ea>
		if (conn->lll.role ||
   1627c:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   16280:	2b00      	cmp	r3, #0
   16282:	f2c0 813b 	blt.w	164fc <ull_conn_rx+0x1418>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PHY_RSP, pdu_rx->len)) {
   16286:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1628a:	2017      	movs	r0, #23
   1628c:	f7fe fb1c 	bl	148c8 <pdu_len_cmp>
		if (conn->lll.role ||
   16290:	2800      	cmp	r0, #0
   16292:	f000 8133 	beq.w	164fc <ull_conn_rx+0x1418>
		if (!conn->lll.role &&
   16296:	f894 21a9 	ldrb.w	r2, [r4, #425]	; 0x1a9
   1629a:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
   1629e:	429a      	cmp	r2, r3
   162a0:	f43e af2b 	beq.w	150fa <ull_conn_rx+0x16>
		    (conn->llcp_phy.state == LLCP_PHY_STATE_RSP_WAIT)) {
   162a4:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
		    (conn->llcp_phy.ack != conn->llcp_phy.req) &&
   162a8:	f003 0203 	and.w	r2, r3, #3
   162ac:	2a02      	cmp	r2, #2
   162ae:	f47e af24 	bne.w	150fa <ull_conn_rx+0x16>
			conn->llcp_phy.state = LLCP_PHY_STATE_UPD;
   162b2:	f043 0303 	orr.w	r3, r3, #3
   162b6:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
			conn->llcp_phy.tx &= p->rx_phys;
   162ba:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   162be:	f3c3 0182 	ubfx	r1, r3, #2, #3
   162c2:	400a      	ands	r2, r1
   162c4:	f362 0384 	bfi	r3, r2, #2, #3
   162c8:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
			conn->llcp_phy.rx &= p->tx_phys;
   162cc:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
   162d0:	b2db      	uxtb	r3, r3
   162d2:	ea02 1253 	and.w	r2, r2, r3, lsr #5
   162d6:	f362 1347 	bfi	r3, r2, #5, #3
   162da:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
			if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
   162de:	b2db      	uxtb	r3, r3
   162e0:	f013 0f1c 	tst.w	r3, #28
   162e4:	d002      	beq.n	162ec <ull_conn_rx+0x1208>
   162e6:	f013 0fe0 	tst.w	r3, #224	; 0xe0
   162ea:	d105      	bne.n	162f8 <ull_conn_rx+0x1214>
				conn->llcp_phy.tx = 0;
   162ec:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   162f0:	f003 0303 	and.w	r3, r3, #3
   162f4:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
			conn->llcp_phy.pause_tx = 1U;
   162f8:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   162fc:	f043 0301 	orr.w	r3, r3, #1
   16300:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
			conn->procedure_expire = 0U;
   16304:	2300      	movs	r3, #0
   16306:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1630a:	f7fe bef6 	b.w	150fa <ull_conn_rx+0x16>
		if (!conn->lll.role ||
   1630e:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   16312:	2b00      	cmp	r3, #0
   16314:	f280 80f2 	bge.w	164fc <ull_conn_rx+0x1418>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PHY_UPD_IND,
   16318:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1631c:	2018      	movs	r0, #24
   1631e:	f7fe fad3 	bl	148c8 <pdu_len_cmp>
		if (!conn->lll.role ||
   16322:	2800      	cmp	r0, #0
   16324:	f000 80ea 	beq.w	164fc <ull_conn_rx+0x1418>
	if (!((ind->m_to_s_phy | ind->s_to_m_phy) & 0x07)) {
   16328:	f895 1024 	ldrb.w	r1, [r5, #36]	; 0x24
   1632c:	f895 7025 	ldrb.w	r7, [r5, #37]	; 0x25
   16330:	ea41 0007 	orr.w	r0, r1, r7
   16334:	f010 0007 	ands.w	r0, r0, #7
   16338:	d135      	bne.n	163a6 <ull_conn_rx+0x12c2>
		if ((conn->llcp_phy.ack == conn->llcp_phy.req) ||
   1633a:	f894 21a8 	ldrb.w	r2, [r4, #424]	; 0x1a8
   1633e:	f894 31a9 	ldrb.w	r3, [r4, #425]	; 0x1a9
   16342:	4293      	cmp	r3, r2
   16344:	f43e aed9 	beq.w	150fa <ull_conn_rx+0x16>
		    (conn->llcp_phy.state != LLCP_PHY_STATE_RSP_WAIT)) {
   16348:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
		if ((conn->llcp_phy.ack == conn->llcp_phy.req) ||
   1634c:	f003 0303 	and.w	r3, r3, #3
   16350:	2b02      	cmp	r3, #2
   16352:	f47e aed2 	bne.w	150fa <ull_conn_rx+0x16>
		conn->llcp_phy.ack = conn->llcp_phy.req;
   16356:	f884 21a9 	strb.w	r2, [r4, #425]	; 0x1a9
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   1635a:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
   1635e:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
		conn->procedure_expire = 0U;
   16362:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   16366:	f3c2 0102 	ubfx	r1, r2, #0, #3
		conn->llcp_phy.pause_tx = 0U;
   1636a:	f360 0300 	bfi	r3, r0, #0, #1
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   1636e:	f361 1206 	bfi	r2, r1, #4, #3
		conn->llcp_phy.pause_tx = 0U;
   16372:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   16376:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
		if (!conn->llcp_phy.cmd) {
   1637a:	f013 0304 	ands.w	r3, r3, #4
   1637e:	6832      	ldr	r2, [r6, #0]
   16380:	d103      	bne.n	1638a <ull_conn_rx+0x12a6>
			(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   16382:	2103      	movs	r1, #3
   16384:	7111      	strb	r1, [r2, #4]
		if (err) {
   16386:	f7ff b85f 	b.w	15448 <ull_conn_rx+0x364>
		(*rx)->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
   1638a:	230e      	movs	r3, #14
   1638c:	7113      	strb	r3, [r2, #4]
		p->status = 0U;
   1638e:	f885 0020 	strb.w	r0, [r5, #32]
		p->tx = conn->lll.phy_tx;
   16392:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21
		p->rx = conn->lll.phy_rx;
   16396:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
   1639a:	f3c3 0302 	ubfx	r3, r3, #0, #3
   1639e:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
		if (err) {
   163a2:	f7ff b932 	b.w	1560a <ull_conn_rx+0x526>
	instant = sys_le16_to_cpu(ind->instant);
   163a6:	8cea      	ldrh	r2, [r5, #38]	; 0x26
	if (((instant - conn->lll.event_counter) & 0xffff) > 0x7fff) {
   163a8:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   163aa:	1ad3      	subs	r3, r2, r3
   163ac:	041b      	lsls	r3, r3, #16
   163ae:	f53e af6d 	bmi.w	1528c <ull_conn_rx+0x1a8>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   163b2:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   163b6:	f894 00e9 	ldrb.w	r0, [r4, #233]	; 0xe9
   163ba:	1a1b      	subs	r3, r3, r0
   163bc:	f003 0303 	and.w	r3, r3, #3
   163c0:	2b02      	cmp	r3, #2
   163c2:	f43e af72 	beq.w	152aa <ull_conn_rx+0x1c6>
	if ((conn->llcp_phy.ack != conn->llcp_phy.req) &&
   163c6:	f894 01a8 	ldrb.w	r0, [r4, #424]	; 0x1a8
   163ca:	f894 31a9 	ldrb.w	r3, [r4, #425]	; 0x1a9
   163ce:	4283      	cmp	r3, r0
   163d0:	d018      	beq.n	16404 <ull_conn_rx+0x1320>
	    (conn->llcp_phy.state == LLCP_PHY_STATE_RSP_WAIT)) {
   163d2:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
	if ((conn->llcp_phy.ack != conn->llcp_phy.req) &&
   163d6:	f003 0303 	and.w	r3, r3, #3
   163da:	2b02      	cmp	r3, #2
   163dc:	d112      	bne.n	16404 <ull_conn_rx+0x1320>
		conn->llcp_phy.pause_tx = 0U;
   163de:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
		conn->llcp_phy.ack = conn->llcp_phy.req;
   163e2:	f884 01a9 	strb.w	r0, [r4, #425]	; 0x1a9
		conn->procedure_expire = 0U;
   163e6:	2000      	movs	r0, #0
		conn->llcp_phy.pause_tx = 0U;
   163e8:	f36f 0300 	bfc	r3, #0, #1
		conn->procedure_expire = 0U;
   163ec:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
   163f0:	f894 00ec 	ldrb.w	r0, [r4, #236]	; 0xec
		conn->llcp_phy.pause_tx = 0U;
   163f4:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
   163f8:	f3c3 0380 	ubfx	r3, r3, #2, #1
   163fc:	f363 0041 	bfi	r0, r3, #1, #1
   16400:	f884 00ec 	strb.w	r0, [r4, #236]	; 0xec
	conn->llcp.phy_upd_ind.tx = ind->s_to_m_phy;
   16404:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
	conn->llcp.phy_upd_ind.instant = instant;
   16408:	f8a4 20ee 	strh.w	r2, [r4, #238]	; 0xee
	conn->llcp.phy_upd_ind.tx = ind->s_to_m_phy;
   1640c:	f367 0384 	bfi	r3, r7, #2, #3
	conn->llcp.phy_upd_ind.rx = ind->m_to_s_phy;
   16410:	f361 1347 	bfi	r3, r1, #5, #3
	conn->llcp.phy_upd_ind.initiate = 0U;
   16414:	f36f 0300 	bfc	r3, #0, #1
   16418:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
	link->mem = conn->llcp_rx;
   1641c:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
   16420:	f8c8 3004 	str.w	r3, [r8, #4]
	(*rx)->hdr.link = link;
   16424:	6833      	ldr	r3, [r6, #0]
   16426:	f8c3 8000 	str.w	r8, [r3]
	conn->llcp_rx = *rx;
   1642a:	6833      	ldr	r3, [r6, #0]
   1642c:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
	*rx = NULL;
   16430:	2300      	movs	r3, #0
   16432:	6033      	str	r3, [r6, #0]
	struct node_rx_pdu *rx_dle = ll_pdu_rx_alloc();
   16434:	f7fc fd3c 	bl	12eb0 <ll_pdu_rx_alloc>
	LL_ASSERT(rx_dle);
   16438:	4605      	mov	r5, r0
   1643a:	b960      	cbnz	r0, 16456 <ull_conn_rx+0x1372>
   1643c:	f241 23d9 	movw	r3, #4825	; 0x12d9
   16440:	4a3e      	ldr	r2, [pc, #248]	; (1653c <ull_conn_rx+0x1458>)
   16442:	493f      	ldr	r1, [pc, #252]	; (16540 <ull_conn_rx+0x145c>)
   16444:	483f      	ldr	r0, [pc, #252]	; (16544 <ull_conn_rx+0x1460>)
   16446:	f009 fcb4 	bl	1fdb2 <printk>
   1644a:	4040      	eors	r0, r0
   1644c:	f380 8811 	msr	BASEPRI, r0
   16450:	f04f 0003 	mov.w	r0, #3
   16454:	df02      	svc	2
	rx_dle->hdr.link->mem = conn->llcp_rx;
   16456:	682b      	ldr	r3, [r5, #0]
   16458:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
   1645c:	605a      	str	r2, [r3, #4]
	conn->llcp_type = LLCP_PHY_UPD;
   1645e:	2306      	movs	r3, #6
   16460:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
	conn->llcp_ack -= 2U;
   16464:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
	conn->llcp_rx = rx_dle;
   16468:	f8c4 5100 	str.w	r5, [r4, #256]	; 0x100
	conn->llcp_ack -= 2U;
   1646c:	3b02      	subs	r3, #2
   1646e:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
	if (conn->llcp.phy_upd_ind.tx) {
   16472:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   16476:	f013 0f1c 	tst.w	r3, #28
   1647a:	f43e afe5 	beq.w	15448 <ull_conn_rx+0x364>
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
   1647e:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
   16482:	f3c3 0382 	ubfx	r3, r3, #2, #3
   16486:	f363 1206 	bfi	r2, r3, #4, #3
   1648a:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
		if (err) {
   1648e:	f7fe bfdb 	b.w	15448 <ull_conn_rx+0x364>
	break;
#endif /* CONFIG_BT_CTLR_PHY */

#if defined(CONFIG_BT_CTLR_MIN_USED_CHAN)
	case PDU_DATA_LLCTRL_TYPE_MIN_USED_CHAN_IND:
		if (conn->lll.role ||
   16492:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   16496:	2b00      	cmp	r3, #0
   16498:	db30      	blt.n	164fc <ull_conn_rx+0x1418>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_MIN_USED_CHAN_IND,
   1649a:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1649e:	2019      	movs	r0, #25
   164a0:	f7fe fa12 	bl	148c8 <pdu_len_cmp>
		if (conn->lll.role ||
   164a4:	b350      	cbz	r0, 164fc <ull_conn_rx+0x1418>
		if (!conn->lll.role) {
			struct pdu_data_llctrl_min_used_chans_ind *p =
				&pdu_rx->llctrl.min_used_chans_ind;

#if defined(CONFIG_BT_CTLR_PHY)
			if (!(p->phys & (conn->lll.phy_tx |
   164a6:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
					 conn->lll.phy_rx))) {
   164aa:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
			if (!(p->phys & (conn->lll.phy_tx |
   164ae:	4313      	orrs	r3, r2
   164b0:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
   164b4:	f003 0307 	and.w	r3, r3, #7
   164b8:	4213      	tst	r3, r2
   164ba:	f43e afc5 	beq.w	15448 <ull_conn_rx+0x364>
			if (!(p->phys & 0x01)) {
#endif /* !CONFIG_BT_CTLR_PHY */
				break;
			}

			if (((conn->llcp_req - conn->llcp_ack) & 0x03) ==
   164be:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
   164c2:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   164c6:	1a9b      	subs	r3, r3, r2
   164c8:	f003 0303 	and.w	r3, r3, #3
   164cc:	2b02      	cmp	r3, #2
   164ce:	f43e afbb 	beq.w	15448 <ull_conn_rx+0x364>
   164d2:	4b1d      	ldr	r3, [pc, #116]	; (16548 <ull_conn_rx+0x1464>)
   164d4:	6819      	ldr	r1, [r3, #0]
   164d6:	791b      	ldrb	r3, [r3, #4]
   164d8:	f884 30f1 	strb.w	r3, [r4, #241]	; 0xf1
			}

			memcpy(&conn->llcp.chan_map.chm[0], data_chan_map,
			       sizeof(conn->llcp.chan_map.chm));
			/* conn->llcp.chan_map.instant     = 0; */
			conn->llcp.chan_map.initiate = 1U;
   164dc:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   164e0:	f8c4 10ed 	str.w	r1, [r4, #237]	; 0xed
   164e4:	f043 0301 	orr.w	r3, r3, #1
   164e8:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec

			conn->llcp_type = LLCP_CHAN_MAP;
			conn->llcp_ack -= 2U;
   164ec:	3a02      	subs	r2, #2
			conn->llcp_type = LLCP_CHAN_MAP;
   164ee:	2302      	movs	r3, #2
   164f0:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
			conn->llcp_ack -= 2U;
   164f4:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
		}

		/* Mark for buffer for release */
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   164f8:	f7fe bfc6 	b.w	15488 <ull_conn_rx+0x3a4>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   164fc:	480e      	ldr	r0, [pc, #56]	; (16538 <ull_conn_rx+0x1454>)
   164fe:	f00d fd66 	bl	23fce <mem_acquire>
	if (!tx) {
   16502:	4601      	mov	r1, r0
   16504:	2800      	cmp	r0, #0
   16506:	f43f a87e 	beq.w	15606 <ull_conn_rx+0x522>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
   1650a:	7903      	ldrb	r3, [r0, #4]
	pdu->llctrl.unknown_rsp.type = type;
   1650c:	f880 9008 	strb.w	r9, [r0, #8]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
   16510:	f043 0303 	orr.w	r3, r3, #3
   16514:	7103      	strb	r3, [r0, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, unknown_rsp) +
   16516:	2302      	movs	r3, #2
   16518:	7143      	strb	r3, [r0, #5]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP;
   1651a:	2307      	movs	r3, #7
   1651c:	71c3      	strb	r3, [r0, #7]
	pdu->llctrl.unknown_rsp.type = type;
   1651e:	f7ff b88d 	b.w	1563c <ull_conn_rx+0x558>
		if (conn->llcp_enc.pause_rx) {
   16522:	2a00      	cmp	r2, #0
   16524:	f43e af90 	beq.w	15448 <ull_conn_rx+0x364>
   16528:	f7fe be3d 	b.w	151a6 <ull_conn_rx+0xc2>
		if (conn->llcp_enc.pause_rx) {
   1652c:	2a00      	cmp	r2, #0
   1652e:	f43e afab 	beq.w	15488 <ull_conn_rx+0x3a4>
   16532:	f7fe be38 	b.w	151a6 <ull_conn_rx+0xc2>
   16536:	bf00      	nop
   16538:	200014ec 	.word	0x200014ec
   1653c:	00064754 	.word	0x00064754
   16540:	000648b1 	.word	0x000648b1
   16544:	000632fe 	.word	0x000632fe
   16548:	2000edee 	.word	0x2000edee
	else if (rej_ext_ind->error_code != BT_HCI_ERR_LL_PROC_COLLISION) {
   1654c:	2b23      	cmp	r3, #35	; 0x23
   1654e:	d003      	beq.n	16558 <ull_conn_rx+0x1474>
			conn->slave.ticks_to_offset =
   16550:	f8d4 3194 	ldr.w	r3, [r4, #404]	; 0x194
   16554:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4
	if (conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT) {
   16558:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   1655c:	f003 0307 	and.w	r3, r3, #7
   16560:	2b04      	cmp	r3, #4
   16562:	d118      	bne.n	16596 <ull_conn_rx+0x14b2>
		LL_ASSERT(conn_upd_curr == conn);
   16564:	4e19      	ldr	r6, [pc, #100]	; (165cc <ull_conn_rx+0x14e8>)
   16566:	6832      	ldr	r2, [r6, #0]
   16568:	4294      	cmp	r4, r2
   1656a:	d00c      	beq.n	16586 <ull_conn_rx+0x14a2>
   1656c:	f241 0361 	movw	r3, #4193	; 0x1061
   16570:	4a17      	ldr	r2, [pc, #92]	; (165d0 <ull_conn_rx+0x14ec>)
   16572:	4918      	ldr	r1, [pc, #96]	; (165d4 <ull_conn_rx+0x14f0>)
   16574:	4818      	ldr	r0, [pc, #96]	; (165d8 <ull_conn_rx+0x14f4>)
   16576:	f009 fc1c 	bl	1fdb2 <printk>
   1657a:	4040      	eors	r0, r0
   1657c:	f380 8811 	msr	BASEPRI, r0
   16580:	f04f 0003 	mov.w	r0, #3
   16584:	df02      	svc	2
		conn_upd_curr = NULL;
   16586:	2300      	movs	r3, #0
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   16588:	f894 2170 	ldrb.w	r2, [r4, #368]	; 0x170
		conn_upd_curr = NULL;
   1658c:	6033      	str	r3, [r6, #0]
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   1658e:	f884 2171 	strb.w	r2, [r4, #369]	; 0x171
		conn->procedure_expire = 0U;
   16592:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	if (!conn->llcp_conn_param.cmd) {
   16596:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   1659a:	071a      	lsls	r2, r3, #28
   1659c:	f57e adad 	bpl.w	150fa <ull_conn_rx+0x16>
	rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
   165a0:	230a      	movs	r3, #10
   165a2:	712b      	strb	r3, [r5, #4]
	cu->status = rej_ext_ind->error_code;
   165a4:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   165a8:	f885 3020 	strb.w	r3, [r5, #32]
	cu->latency = lll->latency;
   165ac:	8e22      	ldrh	r2, [r4, #48]	; 0x30
	cu->interval = lll->interval;
   165ae:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
	cu->latency = lll->latency;
   165b0:	84aa      	strh	r2, [r5, #36]	; 0x24
	cu->timeout = conn->supervision_reload *
   165b2:	f8b4 20c6 	ldrh.w	r2, [r4, #198]	; 0xc6
	cu->interval = lll->interval;
   165b6:	846b      	strh	r3, [r5, #34]	; 0x22
	cu->timeout = conn->supervision_reload *
   165b8:	435a      	muls	r2, r3
		      lll->interval * 125U / 1000;
   165ba:	237d      	movs	r3, #125	; 0x7d
   165bc:	4353      	muls	r3, r2
   165be:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   165c2:	fbb3 f3f2 	udiv	r3, r3, r2
	cu->timeout = conn->supervision_reload *
   165c6:	84eb      	strh	r3, [r5, #38]	; 0x26
	if (err) {
   165c8:	f7fe bf3e 	b.w	15448 <ull_conn_rx+0x364>
   165cc:	2000146c 	.word	0x2000146c
   165d0:	00064754 	.word	0x00064754
   165d4:	00064862 	.word	0x00064862
   165d8:	000632fe 	.word	0x000632fe

000165dc <ull_conn_done>:
{
   165dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct lll_conn *lll = (void *)HDR_ULL2LLL(done->param);
   165e0:	6a05      	ldr	r5, [r0, #32]
	if (lll->handle == 0xFFFF) {
   165e2:	8baa      	ldrh	r2, [r5, #28]
   165e4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   165e8:	429a      	cmp	r2, r3
{
   165ea:	b08b      	sub	sp, #44	; 0x2c
   165ec:	4680      	mov	r8, r0
	if (lll->handle == 0xFFFF) {
   165ee:	d00f      	beq.n	16610 <ull_conn_done+0x34>
	switch (done->extra.mic_state) {
   165f0:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
	struct ll_conn *conn = (void *)HDR_LLL2EVT(lll);
   165f4:	68ec      	ldr	r4, [r5, #12]
	switch (done->extra.mic_state) {
   165f6:	2b01      	cmp	r3, #1
   165f8:	d032      	beq.n	16660 <ull_conn_done+0x84>
   165fa:	b163      	cbz	r3, 16616 <ull_conn_done+0x3a>
   165fc:	2b02      	cmp	r3, #2
   165fe:	d035      	beq.n	1666c <ull_conn_done+0x90>
	reason_peer = conn->llcp_terminate.reason_peer;
   16600:	f894 612b 	ldrb.w	r6, [r4, #299]	; 0x12b
	if (reason_peer && (
   16604:	2e00      	cmp	r6, #0
   16606:	d035      	beq.n	16674 <ull_conn_done+0x98>
		conn_cleanup(conn, reason_peer);
   16608:	4631      	mov	r1, r6
			conn_cleanup(conn, BT_HCI_ERR_CONN_FAIL_TO_ESTAB);
   1660a:	4620      	mov	r0, r4
   1660c:	f7fe fa7a 	bl	14b04 <conn_cleanup>
}
   16610:	b00b      	add	sp, #44	; 0x2c
   16612:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (lll->enc_rx || conn->llcp_enc.pause_rx) {
   16616:	f895 306e 	ldrb.w	r3, [r5, #110]	; 0x6e
   1661a:	0719      	lsls	r1, r3, #28
   1661c:	d403      	bmi.n	16626 <ull_conn_done+0x4a>
   1661e:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   16622:	07da      	lsls	r2, r3, #31
   16624:	d5ec      	bpl.n	16600 <ull_conn_done+0x24>
					    (lll->latency + 6)) ?
   16626:	8c2b      	ldrh	r3, [r5, #32]
			appto_reload_new = (conn->apto_reload >
   16628:	f8b4 20d2 	ldrh.w	r2, [r4, #210]	; 0xd2
					    (lll->latency + 6)) ?
   1662c:	1d99      	adds	r1, r3, #6
			appto_reload_new = (conn->apto_reload >
   1662e:	428a      	cmp	r2, r1
					   (conn->apto_reload -
   16630:	bfc4      	itt	gt
   16632:	1ad3      	subgt	r3, r2, r3
   16634:	3b06      	subgt	r3, #6
			if (conn->appto_reload != appto_reload_new) {
   16636:	f8b4 10ce 	ldrh.w	r1, [r4, #206]	; 0xce
			appto_reload_new = (conn->apto_reload >
   1663a:	bfcc      	ite	gt
   1663c:	b29b      	uxthgt	r3, r3
   1663e:	4613      	movle	r3, r2
			if (conn->appto_reload != appto_reload_new) {
   16640:	4299      	cmp	r1, r3
   16642:	d008      	beq.n	16656 <ull_conn_done+0x7a>
				conn->appto_reload = appto_reload_new;
   16644:	f8a4 30ce 	strh.w	r3, [r4, #206]	; 0xce
				conn->appto_expire = conn->appto_reload;
   16648:	f8b4 30ce 	ldrh.w	r3, [r4, #206]	; 0xce
   1664c:	f8a4 30d0 	strh.w	r3, [r4, #208]	; 0xd0
				conn->apto_expire = conn->apto_reload;
   16650:	f8a4 20d4 	strh.w	r2, [r4, #212]	; 0xd4
   16654:	e7d4      	b.n	16600 <ull_conn_done+0x24>
			if (conn->apto_expire == 0U) {
   16656:	f8b4 30d4 	ldrh.w	r3, [r4, #212]	; 0xd4
   1665a:	2b00      	cmp	r3, #0
   1665c:	d1d0      	bne.n	16600 <ull_conn_done+0x24>
   1665e:	e7f3      	b.n	16648 <ull_conn_done+0x6c>
		conn->appto_expire = conn->apto_expire = 0U;
   16660:	2300      	movs	r3, #0
   16662:	f8a4 30d4 	strh.w	r3, [r4, #212]	; 0xd4
   16666:	f8a4 30d0 	strh.w	r3, [r4, #208]	; 0xd0
		break;
   1666a:	e7c9      	b.n	16600 <ull_conn_done+0x24>
		conn->llcp_terminate.reason_peer =
   1666c:	233d      	movs	r3, #61	; 0x3d
   1666e:	f884 312b 	strb.w	r3, [r4, #299]	; 0x12b
		break;
   16672:	e7c5      	b.n	16600 <ull_conn_done+0x24>
	latency_event = lll->latency_event;
   16674:	f8b5 9024 	ldrh.w	r9, [r5, #36]	; 0x24
	if (done->extra.trx_cnt) {
   16678:	f8b8 3028 	ldrh.w	r3, [r8, #40]	; 0x28
	elapsed_event = latency_event + 1;
   1667c:	f109 0701 	add.w	r7, r9, #1
   16680:	b2bf      	uxth	r7, r7
	ticks_drift_minus = 0U;
   16682:	e9cd 6608 	strd	r6, r6, [sp, #32]
	if (done->extra.trx_cnt) {
   16686:	b183      	cbz	r3, 166aa <ull_conn_done+0xce>
		} else if (lll->role) {
   16688:	f995 302d 	ldrsb.w	r3, [r5, #45]	; 0x2d
   1668c:	2b00      	cmp	r3, #0
   1668e:	da09      	bge.n	166a4 <ull_conn_done+0xc8>
			ull_slave_done(done, &ticks_drift_plus,
   16690:	aa08      	add	r2, sp, #32
   16692:	a909      	add	r1, sp, #36	; 0x24
   16694:	4640      	mov	r0, r8
   16696:	f7ed fbd3 	bl	3e40 <ull_slave_done>
			if (conn->tx_head || memq_peek(lll->memq_tx.head,
   1669a:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
   1669e:	b15b      	cbz	r3, 166b8 <ull_conn_done+0xdc>
				lll->latency_event = 0;
   166a0:	2300      	movs	r3, #0
				lll->latency_event = lll->latency;
   166a2:	84ab      	strh	r3, [r5, #36]	; 0x24
		conn->connect_expire = 0U;
   166a4:	2300      	movs	r3, #0
   166a6:	f8a4 30c4 	strh.w	r3, [r4, #196]	; 0xc4
	if (done->extra.crc_valid) {
   166aa:	f898 302a 	ldrb.w	r3, [r8, #42]	; 0x2a
   166ae:	b183      	cbz	r3, 166d2 <ull_conn_done+0xf6>
		conn->supervision_expire = 0U;
   166b0:	2300      	movs	r3, #0
			conn->supervision_expire = conn->supervision_reload;
   166b2:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
   166b6:	e014      	b.n	166e2 <ull_conn_done+0x106>
			if (conn->tx_head || memq_peek(lll->memq_tx.head,
   166b8:	4632      	mov	r2, r6
   166ba:	e9d5 0116 	ldrd	r0, r1, [r5, #88]	; 0x58
   166be:	f00d fcdf 	bl	24080 <memq_peek>
   166c2:	2800      	cmp	r0, #0
   166c4:	d1ec      	bne.n	166a0 <ull_conn_done+0xc4>
			} else if (lll->slave.latency_enabled) {
   166c6:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
   166ca:	07db      	lsls	r3, r3, #31
   166cc:	d5ea      	bpl.n	166a4 <ull_conn_done+0xc8>
				lll->latency_event = lll->latency;
   166ce:	8c2b      	ldrh	r3, [r5, #32]
   166d0:	e7e7      	b.n	166a2 <ull_conn_done+0xc6>
	else if (conn->connect_expire) {
   166d2:	f8b4 30c4 	ldrh.w	r3, [r4, #196]	; 0xc4
   166d6:	b3c3      	cbz	r3, 1674a <ull_conn_done+0x16e>
		if (conn->connect_expire > elapsed_event) {
   166d8:	42bb      	cmp	r3, r7
   166da:	d934      	bls.n	16746 <ull_conn_done+0x16a>
			conn->connect_expire -= elapsed_event;
   166dc:	1bdb      	subs	r3, r3, r7
   166de:	f8a4 30c4 	strh.w	r3, [r4, #196]	; 0xc4
	if (conn->supervision_expire) {
   166e2:	f8b4 30c8 	ldrh.w	r3, [r4, #200]	; 0xc8
   166e6:	b1eb      	cbz	r3, 16724 <ull_conn_done+0x148>
		if (conn->supervision_expire > elapsed_event) {
   166e8:	42bb      	cmp	r3, r7
   166ea:	d935      	bls.n	16758 <ull_conn_done+0x17c>
			conn->supervision_expire -= elapsed_event;
   166ec:	1bdb      	subs	r3, r3, r7
   166ee:	b29b      	uxth	r3, r3
			lll->latency_event = 0;
   166f0:	2200      	movs	r2, #0
			if (conn->supervision_expire <= 6U) {
   166f2:	2b06      	cmp	r3, #6
			conn->supervision_expire -= elapsed_event;
   166f4:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
			lll->latency_event = 0;
   166f8:	84aa      	strh	r2, [r5, #36]	; 0x24
			if (conn->supervision_expire <= 6U) {
   166fa:	d92f      	bls.n	1675c <ull_conn_done+0x180>
			else if (lll->role) {
   166fc:	f995 302d 	ldrsb.w	r3, [r5, #45]	; 0x2d
   16700:	4293      	cmp	r3, r2
   16702:	da0f      	bge.n	16724 <ull_conn_done+0x148>
				if (latency_event) {
   16704:	f1b9 0f00 	cmp.w	r9, #0
   16708:	d128      	bne.n	1675c <ull_conn_done+0x180>
					force = conn->slave.force & 0x01;
   1670a:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
					conn->slave.force >>= 1;
   1670e:	085a      	lsrs	r2, r3, #1
					if (force) {
   16710:	f013 0301 	ands.w	r3, r3, #1
						conn->slave.force |= BIT(31);
   16714:	bf17      	itett	ne
   16716:	f042 4200 	orrne.w	r2, r2, #2147483648	; 0x80000000
					conn->slave.force >>= 1;
   1671a:	f8c4 20e0 	streq.w	r2, [r4, #224]	; 0xe0
						conn->slave.force |= BIT(31);
   1671e:	f8c4 20e0 	strne.w	r2, [r4, #224]	; 0xe0
					force = conn->slave.force & 0x01;
   16722:	461e      	movne	r6, r3
	if (conn->procedure_expire != 0U) {
   16724:	f8b4 30cc 	ldrh.w	r3, [r4, #204]	; 0xcc
   16728:	b123      	cbz	r3, 16734 <ull_conn_done+0x158>
		if (conn->procedure_expire > elapsed_event) {
   1672a:	42bb      	cmp	r3, r7
   1672c:	d918      	bls.n	16760 <ull_conn_done+0x184>
			conn->procedure_expire -= elapsed_event;
   1672e:	1bdb      	subs	r3, r3, r7
   16730:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	if (conn->apto_expire != 0U) {
   16734:	f8b4 30d4 	ldrh.w	r3, [r4, #212]	; 0xd4
   16738:	b323      	cbz	r3, 16784 <ull_conn_done+0x1a8>
		if (conn->apto_expire > elapsed_event) {
   1673a:	42bb      	cmp	r3, r7
   1673c:	d912      	bls.n	16764 <ull_conn_done+0x188>
			conn->apto_expire -= elapsed_event;
   1673e:	1bdb      	subs	r3, r3, r7
				conn->apto_expire = 1U;
   16740:	f8a4 30d4 	strh.w	r3, [r4, #212]	; 0xd4
   16744:	e01e      	b.n	16784 <ull_conn_done+0x1a8>
			conn_cleanup(conn, BT_HCI_ERR_CONN_FAIL_TO_ESTAB);
   16746:	213e      	movs	r1, #62	; 0x3e
   16748:	e75f      	b.n	1660a <ull_conn_done+0x2e>
		if (!conn->supervision_expire) {
   1674a:	f8b4 30c8 	ldrh.w	r3, [r4, #200]	; 0xc8
   1674e:	2b00      	cmp	r3, #0
   16750:	d1c7      	bne.n	166e2 <ull_conn_done+0x106>
			conn->supervision_expire = conn->supervision_reload;
   16752:	f8b4 30c6 	ldrh.w	r3, [r4, #198]	; 0xc6
   16756:	e7ac      	b.n	166b2 <ull_conn_done+0xd6>
			conn_cleanup(conn, BT_HCI_ERR_CONN_TIMEOUT);
   16758:	2108      	movs	r1, #8
   1675a:	e756      	b.n	1660a <ull_conn_done+0x2e>
				force = 1U;
   1675c:	2601      	movs	r6, #1
   1675e:	e7e1      	b.n	16724 <ull_conn_done+0x148>
			conn_cleanup(conn, BT_HCI_ERR_LL_RESP_TIMEOUT);
   16760:	2122      	movs	r1, #34	; 0x22
   16762:	e752      	b.n	1660a <ull_conn_done+0x2e>
			rx = ll_pdu_rx_alloc();
   16764:	f7fc fba4 	bl	12eb0 <ll_pdu_rx_alloc>
			if (rx) {
   16768:	4601      	mov	r1, r0
   1676a:	b320      	cbz	r0, 167b6 <ull_conn_done+0x1da>
				conn->apto_expire = 0U;
   1676c:	2300      	movs	r3, #0
   1676e:	f8a4 30d4 	strh.w	r3, [r4, #212]	; 0xd4
				rx->handle = lll->handle;
   16772:	8bab      	ldrh	r3, [r5, #28]
   16774:	80c3      	strh	r3, [r0, #6]
				rx->type = NODE_RX_TYPE_APTO;
   16776:	230c      	movs	r3, #12
   16778:	7103      	strb	r3, [r0, #4]
				ll_rx_put(rx->link, rx);
   1677a:	6800      	ldr	r0, [r0, #0]
   1677c:	f7fc fb70 	bl	12e60 <ll_rx_put>
				ll_rx_sched();
   16780:	f7fc fb78 	bl	12e74 <ll_rx_sched>
	if (conn->appto_expire != 0U) {
   16784:	f8b4 20d0 	ldrh.w	r2, [r4, #208]	; 0xd0
   16788:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   1678c:	f894 10e9 	ldrb.w	r1, [r4, #233]	; 0xe9
   16790:	b122      	cbz	r2, 1679c <ull_conn_done+0x1c0>
		if (conn->appto_expire > elapsed_event) {
   16792:	42ba      	cmp	r2, r7
   16794:	d911      	bls.n	167ba <ull_conn_done+0x1de>
			conn->appto_expire -= elapsed_event;
   16796:	1bd7      	subs	r7, r2, r7
   16798:	f8a4 70d0 	strh.w	r7, [r4, #208]	; 0xd0
	if ((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   1679c:	1a5b      	subs	r3, r3, r1
   1679e:	f003 0303 	and.w	r3, r3, #3
   167a2:	2b02      	cmp	r3, #2
   167a4:	d118      	bne.n	167d8 <ull_conn_done+0x1fc>
	    ((conn->llcp_type == LLCP_CONN_UPD) ||
   167a6:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
	if ((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   167aa:	3b01      	subs	r3, #1
   167ac:	2b01      	cmp	r3, #1
		lll->latency_event = 0;
   167ae:	bf9c      	itt	ls
   167b0:	2300      	movls	r3, #0
   167b2:	84ab      	strhls	r3, [r5, #36]	; 0x24
   167b4:	e010      	b.n	167d8 <ull_conn_done+0x1fc>
				conn->apto_expire = 1U;
   167b6:	2301      	movs	r3, #1
   167b8:	e7c2      	b.n	16740 <ull_conn_done+0x164>
			conn->appto_expire = 0U;
   167ba:	2200      	movs	r2, #0
   167bc:	f8a4 20d0 	strh.w	r2, [r4, #208]	; 0xd0
			if ((conn->procedure_expire == 0U) &&
   167c0:	f8b4 20cc 	ldrh.w	r2, [r4, #204]	; 0xcc
   167c4:	2a00      	cmp	r2, #0
   167c6:	d1e9      	bne.n	1679c <ull_conn_done+0x1c0>
   167c8:	428b      	cmp	r3, r1
   167ca:	d1e7      	bne.n	1679c <ull_conn_done+0x1c0>
				conn->llcp_type = LLCP_PING;
   167cc:	2205      	movs	r2, #5
				conn->llcp_ack -= 2U;
   167ce:	3b02      	subs	r3, #2
				conn->llcp_type = LLCP_PING;
   167d0:	f884 20ea 	strb.w	r2, [r4, #234]	; 0xea
				conn->llcp_ack -= 2U;
   167d4:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
	if ((force) || (latency_event != lll->latency_event)) {
   167d8:	8ca9      	ldrh	r1, [r5, #36]	; 0x24
   167da:	b90e      	cbnz	r6, 167e0 <ull_conn_done+0x204>
   167dc:	4589      	cmp	r9, r1
   167de:	d031      	beq.n	16844 <ull_conn_done+0x268>
		lazy = lll->latency_event + 1;
   167e0:	3101      	adds	r1, #1
   167e2:	b289      	uxth	r1, r1
	if ((ticks_drift_plus != 0U) || (ticks_drift_minus != 0U) ||
   167e4:	e9dd 7308 	ldrd	r7, r3, [sp, #32]
   167e8:	ea53 0207 	orrs.w	r2, r3, r7
   167ec:	d103      	bne.n	167f6 <ull_conn_done+0x21a>
   167ee:	b911      	cbnz	r1, 167f6 <ull_conn_done+0x21a>
	    (lazy != 0U) || (force != 0U)) {
   167f0:	2e00      	cmp	r6, #0
   167f2:	f43f af0d 	beq.w	16610 <ull_conn_done+0x34>
		u8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
   167f6:	7f2a      	ldrb	r2, [r5, #28]
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   167f8:	4813      	ldr	r0, [pc, #76]	; (16848 <ull_conn_done+0x26c>)
		struct ll_conn *conn = lll->hdr.parent;
   167fa:	68ec      	ldr	r4, [r5, #12]
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   167fc:	9406      	str	r4, [sp, #24]
   167fe:	e9cd 6004 	strd	r6, r0, [sp, #16]
		u8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
   16802:	3203      	adds	r2, #3
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   16804:	2000      	movs	r0, #0
   16806:	9103      	str	r1, [sp, #12]
   16808:	e9cd 0001 	strd	r0, r0, [sp, #4]
   1680c:	9700      	str	r7, [sp, #0]
   1680e:	b2d2      	uxtb	r2, r2
   16810:	2101      	movs	r1, #1
   16812:	f7fa fbd7 	bl	10fc4 <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   16816:	f030 0302 	bics.w	r3, r0, #2
   1681a:	f43f aef9 	beq.w	16610 <ull_conn_done+0x34>
   1681e:	f7fc fbd1 	bl	12fc4 <ull_disable_mark_get>
   16822:	4284      	cmp	r4, r0
   16824:	f43f aef4 	beq.w	16610 <ull_conn_done+0x34>
   16828:	f240 43cb 	movw	r3, #1227	; 0x4cb
   1682c:	4a07      	ldr	r2, [pc, #28]	; (1684c <ull_conn_done+0x270>)
   1682e:	4908      	ldr	r1, [pc, #32]	; (16850 <ull_conn_done+0x274>)
   16830:	4808      	ldr	r0, [pc, #32]	; (16854 <ull_conn_done+0x278>)
   16832:	f009 fabe 	bl	1fdb2 <printk>
   16836:	4040      	eors	r0, r0
   16838:	f380 8811 	msr	BASEPRI, r0
   1683c:	f04f 0003 	mov.w	r0, #3
   16840:	df02      	svc	2
   16842:	e6e5      	b.n	16610 <ull_conn_done+0x34>
	lazy = 0U;
   16844:	4631      	mov	r1, r6
   16846:	e7cd      	b.n	167e4 <ull_conn_done+0x208>
   16848:	00014a65 	.word	0x00014a65
   1684c:	00064754 	.word	0x00064754
   16850:	000647a7 	.word	0x000647a7
   16854:	000632fe 	.word	0x000632fe

00016858 <ull_conn_tx_demux>:
{
   16858:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
   1685c:	4e20      	ldr	r6, [pc, #128]	; (168e0 <ull_conn_tx_demux+0x88>)
{
   1685e:	4604      	mov	r4, r0
   16860:	4637      	mov	r7, r6
	return (void *)(fifo + first * size);
   16862:	1d35      	adds	r5, r6, #4
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
   16864:	78b3      	ldrb	r3, [r6, #2]
	if (first == last) {
   16866:	78f1      	ldrb	r1, [r6, #3]
   16868:	7832      	ldrb	r2, [r6, #0]
   1686a:	4299      	cmp	r1, r3
   1686c:	d02d      	beq.n	168ca <ull_conn_tx_demux+0x72>
	return (void *)(fifo + first * size);
   1686e:	fb13 f302 	smulbb	r3, r3, r2
		if (!lll_tx) {
   16872:	eb15 0803 	adds.w	r8, r5, r3
   16876:	d028      	beq.n	168ca <ull_conn_tx_demux+0x72>
		conn = ll_connected_get(lll_tx->handle);
   16878:	5ae8      	ldrh	r0, [r5, r3]
   1687a:	f00d ff80 	bl	2477e <ll_connected_get>
		if (conn) {
   1687e:	f8d8 1004 	ldr.w	r1, [r8, #4]
   16882:	b320      	cbz	r0, 168ce <ull_conn_tx_demux+0x76>
			tx->next = NULL;
   16884:	2300      	movs	r3, #0
   16886:	600b      	str	r3, [r1, #0]
			if (!conn->tx_data) {
   16888:	f8d0 31bc 	ldr.w	r3, [r0, #444]	; 0x1bc
   1688c:	b943      	cbnz	r3, 168a0 <ull_conn_tx_demux+0x48>
				if (!conn->tx_head) {
   1688e:	f8d0 31b0 	ldr.w	r3, [r0, #432]	; 0x1b0
				conn->tx_data = tx;
   16892:	f8c0 11bc 	str.w	r1, [r0, #444]	; 0x1bc
				if (!conn->tx_head) {
   16896:	b91b      	cbnz	r3, 168a0 <ull_conn_tx_demux+0x48>
					conn->tx_head = tx;
   16898:	f8c0 11b0 	str.w	r1, [r0, #432]	; 0x1b0
					conn->tx_data_last = NULL;
   1689c:	f8c0 31c0 	str.w	r3, [r0, #448]	; 0x1c0
			if (conn->tx_data_last) {
   168a0:	f8d0 31c0 	ldr.w	r3, [r0, #448]	; 0x1c0
   168a4:	b103      	cbz	r3, 168a8 <ull_conn_tx_demux+0x50>
				conn->tx_data_last->next = tx;
   168a6:	6019      	str	r1, [r3, #0]
			conn->tx_data_last = tx;
   168a8:	f8c0 11c0 	str.w	r1, [r0, #448]	; 0x1c0
	u8_t _first = *first; /* Copy read-index */
   168ac:	78bb      	ldrb	r3, [r7, #2]
	if (_first == last) {
   168ae:	78f9      	ldrb	r1, [r7, #3]
		MFIFO_DEQUEUE(conn_tx);
   168b0:	787a      	ldrb	r2, [r7, #1]
   168b2:	4299      	cmp	r1, r3
   168b4:	d005      	beq.n	168c2 <ull_conn_tx_demux+0x6a>
	_first += 1U;
   168b6:	3301      	adds	r3, #1
   168b8:	b2db      	uxtb	r3, r3
		_first = 0U;
   168ba:	429a      	cmp	r2, r3
   168bc:	bf08      	it	eq
   168be:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   168c0:	70bb      	strb	r3, [r7, #2]
	} while (--count);
   168c2:	3c01      	subs	r4, #1
   168c4:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
   168c8:	d1cc      	bne.n	16864 <ull_conn_tx_demux+0xc>
}
   168ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			p->ll_id = PDU_DATA_LLID_RESV;
   168ce:	790b      	ldrb	r3, [r1, #4]
   168d0:	f360 0301 	bfi	r3, r0, #0, #2
   168d4:	710b      	strb	r3, [r1, #4]
			ll_tx_ack_put(0xFFFF, tx);
   168d6:	f64f 70ff 	movw	r0, #65535	; 0xffff
   168da:	f7fc faff 	bl	12edc <ll_tx_ack_put>
   168de:	e7e5      	b.n	168ac <ull_conn_tx_demux+0x54>
   168e0:	2000ea84 	.word	0x2000ea84

000168e4 <ull_conn_tx_lll_enqueue>:
{
   168e4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		link = mem_acquire(&mem_link_tx.free);
   168e8:	4e56      	ldr	r6, [pc, #344]	; (16a44 <ull_conn_tx_lll_enqueue+0x160>)
		LL_ASSERT(link);
   168ea:	4f57      	ldr	r7, [pc, #348]	; (16a48 <ull_conn_tx_lll_enqueue+0x164>)
   168ec:	f8df 8160 	ldr.w	r8, [pc, #352]	; 16a50 <ull_conn_tx_lll_enqueue+0x16c>
{
   168f0:	4604      	mov	r4, r0
   168f2:	460d      	mov	r5, r1
	while (conn->tx_head &&
   168f4:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
   168f8:	b1f3      	cbz	r3, 16938 <ull_conn_tx_lll_enqueue+0x54>
		 !conn->llcp_phy.pause_tx &&
   168fa:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
	while (conn->tx_head &&
   168fe:	07d1      	lsls	r1, r2, #31
   16900:	f100 809a 	bmi.w	16a38 <ull_conn_tx_lll_enqueue+0x154>
		 !conn->llcp_enc.pause_tx &&
   16904:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
		 !conn->llcp_phy.pause_tx &&
   16908:	0792      	lsls	r2, r2, #30
   1690a:	f100 8095 	bmi.w	16a38 <ull_conn_tx_lll_enqueue+0x154>
	if ((pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
   1690e:	791a      	ldrb	r2, [r3, #4]
   16910:	f002 0203 	and.w	r2, r2, #3
   16914:	2a03      	cmp	r2, #3
   16916:	d10e      	bne.n	16936 <ull_conn_tx_lll_enqueue+0x52>
	    ((pdu_data_tx->llctrl.opcode ==
   16918:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
   1691a:	2a03      	cmp	r2, #3
   1691c:	d001      	beq.n	16922 <ull_conn_tx_lll_enqueue+0x3e>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) ||
   1691e:	2a0a      	cmp	r2, #10
   16920:	d109      	bne.n	16936 <ull_conn_tx_lll_enqueue+0x52>
		if (((conn->llcp_req != conn->llcp_ack) &&
   16922:	f894 10e9 	ldrb.w	r1, [r4, #233]	; 0xe9
   16926:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
   1692a:	428a      	cmp	r2, r1
   1692c:	d041      	beq.n	169b2 <ull_conn_tx_lll_enqueue+0xce>
   1692e:	f894 20ea 	ldrb.w	r2, [r4, #234]	; 0xea
   16932:	2a03      	cmp	r2, #3
   16934:	d15b      	bne.n	169ee <ull_conn_tx_lll_enqueue+0x10a>
		(!pause_tx && (conn->tx_head == conn->tx_ctrl))) && count--) {
   16936:	b90d      	cbnz	r5, 1693c <ull_conn_tx_lll_enqueue+0x58>
}
   16938:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		tx = tx_ull_dequeue(conn, conn->tx_head);
   1693c:	f8d4 11b0 	ldr.w	r1, [r4, #432]	; 0x1b0
   16940:	4620      	mov	r0, r4
   16942:	f00d fe9c 	bl	2467e <tx_ull_dequeue>
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
   16946:	7903      	ldrb	r3, [r0, #4]
   16948:	f003 0303 	and.w	r3, r3, #3
   1694c:	2b03      	cmp	r3, #3
		tx = tx_ull_dequeue(conn, conn->tx_head);
   1694e:	4681      	mov	r9, r0
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
   16950:	d114      	bne.n	1697c <ull_conn_tx_lll_enqueue+0x98>
	switch (pdu_tx->llctrl.opcode) {
   16952:	79c3      	ldrb	r3, [r0, #7]
   16954:	3b03      	subs	r3, #3
   16956:	2b08      	cmp	r3, #8
   16958:	d810      	bhi.n	1697c <ull_conn_tx_lll_enqueue+0x98>
   1695a:	e8df f003 	tbb	[pc, r3]
   1695e:	0909      	.short	0x0909
   16960:	0f0f0f0f 	.word	0x0f0f0f0f
   16964:	090f      	.short	0x090f
   16966:	05          	.byte	0x05
   16967:	00          	.byte	0x00
		if (!conn->lll.role) {
   16968:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   1696c:	2b00      	cmp	r3, #0
   1696e:	da05      	bge.n	1697c <ull_conn_tx_lll_enqueue+0x98>
		conn->llcp_enc.pause_tx = 1U;
   16970:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   16974:	f043 0302 	orr.w	r3, r3, #2
   16978:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		link = mem_acquire(&mem_link_tx.free);
   1697c:	4630      	mov	r0, r6
   1697e:	f00d fb26 	bl	23fce <mem_acquire>
		LL_ASSERT(link);
   16982:	4682      	mov	sl, r0
   16984:	b960      	cbnz	r0, 169a0 <ull_conn_tx_lll_enqueue+0xbc>
   16986:	f240 5345 	movw	r3, #1349	; 0x545
   1698a:	463a      	mov	r2, r7
   1698c:	4641      	mov	r1, r8
   1698e:	482f      	ldr	r0, [pc, #188]	; (16a4c <ull_conn_tx_lll_enqueue+0x168>)
   16990:	f009 fa0f 	bl	1fdb2 <printk>
   16994:	4040      	eors	r0, r0
   16996:	f380 8811 	msr	BASEPRI, r0
   1699a:	f04f 0003 	mov.w	r0, #3
   1699e:	df02      	svc	2
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
   169a0:	f104 026c 	add.w	r2, r4, #108	; 0x6c
   169a4:	4649      	mov	r1, r9
   169a6:	4650      	mov	r0, sl
   169a8:	3d01      	subs	r5, #1
   169aa:	f00d fb62 	bl	24072 <memq_enqueue>
   169ae:	b2ed      	uxtb	r5, r5
   169b0:	e7a0      	b.n	168f4 <ull_conn_tx_lll_enqueue+0x10>
		    ((conn->llcp_req == conn->llcp_ack) &&
   169b2:	f894 0119 	ldrb.w	r0, [r4, #281]	; 0x119
   169b6:	f894 1118 	ldrb.w	r1, [r4, #280]	; 0x118
   169ba:	4288      	cmp	r0, r1
   169bc:	d117      	bne.n	169ee <ull_conn_tx_lll_enqueue+0x10a>
		     ((conn->llcp_feature.ack != conn->llcp_feature.req) ||
   169be:	f894 0121 	ldrb.w	r0, [r4, #289]	; 0x121
   169c2:	f894 1120 	ldrb.w	r1, [r4, #288]	; 0x120
   169c6:	4288      	cmp	r0, r1
   169c8:	d111      	bne.n	169ee <ull_conn_tx_lll_enqueue+0x10a>
		      (conn->llcp_version.ack != conn->llcp_version.req) ||
   169ca:	f894 0171 	ldrb.w	r0, [r4, #369]	; 0x171
   169ce:	f894 1170 	ldrb.w	r1, [r4, #368]	; 0x170
   169d2:	4288      	cmp	r0, r1
   169d4:	d10b      	bne.n	169ee <ull_conn_tx_lll_enqueue+0x10a>
		       conn->llcp_conn_param.req) ||
   169d6:	f894 0199 	ldrb.w	r0, [r4, #409]	; 0x199
   169da:	f894 1198 	ldrb.w	r1, [r4, #408]	; 0x198
   169de:	4288      	cmp	r0, r1
   169e0:	d105      	bne.n	169ee <ull_conn_tx_lll_enqueue+0x10a>
		      (conn->llcp_phy.ack != conn->llcp_phy.req) ||
   169e2:	f894 01a9 	ldrb.w	r0, [r4, #425]	; 0x1a9
   169e6:	f894 11a8 	ldrb.w	r1, [r4, #424]	; 0x1a8
   169ea:	4288      	cmp	r0, r1
   169ec:	d016      	beq.n	16a1c <ull_conn_tx_lll_enqueue+0x138>
			if ((tx->next != NULL) &&
   169ee:	681a      	ldr	r2, [r3, #0]
   169f0:	2a00      	cmp	r2, #0
   169f2:	d0a1      	beq.n	16938 <ull_conn_tx_lll_enqueue+0x54>
   169f4:	f8d4 11b4 	ldr.w	r1, [r4, #436]	; 0x1b4
   169f8:	428a      	cmp	r2, r1
   169fa:	d19d      	bne.n	16938 <ull_conn_tx_lll_enqueue+0x54>
				conn->tx_head = tx->next;
   169fc:	f8c4 21b0 	str.w	r2, [r4, #432]	; 0x1b0
				tx->next = conn->tx_ctrl_last->next;
   16a00:	f8d4 21b8 	ldr.w	r2, [r4, #440]	; 0x1b8
   16a04:	6811      	ldr	r1, [r2, #0]
   16a06:	6019      	str	r1, [r3, #0]
				conn->tx_ctrl_last->next = tx;
   16a08:	6013      	str	r3, [r2, #0]
				if (!conn->tx_data_last) {
   16a0a:	f8d4 21c0 	ldr.w	r2, [r4, #448]	; 0x1c0
				conn->tx_data = tx;
   16a0e:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
				if (!conn->tx_data_last) {
   16a12:	2a00      	cmp	r2, #0
   16a14:	d18f      	bne.n	16936 <ull_conn_tx_lll_enqueue+0x52>
					conn->tx_data_last = tx;
   16a16:	f8c4 31c0 	str.w	r3, [r4, #448]	; 0x1c0
   16a1a:	e78c      	b.n	16936 <ull_conn_tx_lll_enqueue+0x52>
			conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
   16a1c:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   16a20:	2101      	movs	r1, #1
   16a22:	f361 0301 	bfi	r3, r1, #0, #2
   16a26:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
			conn->llcp_ack -= 2U;
   16a2a:	3a02      	subs	r2, #2
			conn->llcp_type = LLCP_ENCRYPTION;
   16a2c:	2303      	movs	r3, #3
   16a2e:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
			conn->llcp_ack -= 2U;
   16a32:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
   16a36:	e77e      	b.n	16936 <ull_conn_tx_lll_enqueue+0x52>
		(!pause_tx && (conn->tx_head == conn->tx_ctrl))) && count--) {
   16a38:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
   16a3c:	4293      	cmp	r3, r2
   16a3e:	f43f af7a 	beq.w	16936 <ull_conn_tx_lll_enqueue+0x52>
   16a42:	e779      	b.n	16938 <ull_conn_tx_lll_enqueue+0x54>
   16a44:	20001570 	.word	0x20001570
   16a48:	00064754 	.word	0x00064754
   16a4c:	000632fe 	.word	0x000632fe
   16a50:	00064829 	.word	0x00064829

00016a54 <ull_conn_link_tx_release>:
	mem_release(link, &mem_link_tx.free);
   16a54:	4901      	ldr	r1, [pc, #4]	; (16a5c <ull_conn_link_tx_release+0x8>)
   16a56:	f00d bacb 	b.w	23ff0 <mem_release>
   16a5a:	bf00      	nop
   16a5c:	20001570 	.word	0x20001570

00016a60 <ull_conn_ack_last_idx_get>:
}
   16a60:	4b01      	ldr	r3, [pc, #4]	; (16a68 <ull_conn_ack_last_idx_get+0x8>)
   16a62:	78d8      	ldrb	r0, [r3, #3]
   16a64:	4770      	bx	lr
   16a66:	bf00      	nop
   16a68:	2000ea40 	.word	0x2000ea40

00016a6c <ull_conn_ack_peek>:
{
   16a6c:	b570      	push	{r4, r5, r6, lr}
	lll_tx = MFIFO_DEQUEUE_GET(conn_ack);
   16a6e:	4b0a      	ldr	r3, [pc, #40]	; (16a98 <ull_conn_ack_peek+0x2c>)
   16a70:	789c      	ldrb	r4, [r3, #2]
   16a72:	78dd      	ldrb	r5, [r3, #3]
	if (first == last) {
   16a74:	42ac      	cmp	r4, r5
{
   16a76:	4606      	mov	r6, r0
	lll_tx = MFIFO_DEQUEUE_GET(conn_ack);
   16a78:	7818      	ldrb	r0, [r3, #0]
   16a7a:	d00b      	beq.n	16a94 <ull_conn_ack_peek+0x28>
	return (void *)(fifo + first * size);
   16a7c:	3304      	adds	r3, #4
   16a7e:	fb14 f400 	smulbb	r4, r4, r0
	if (!lll_tx) {
   16a82:	1918      	adds	r0, r3, r4
   16a84:	d005      	beq.n	16a92 <ull_conn_ack_peek+0x26>
	*ack_last = mfifo_conn_ack.l;
   16a86:	7035      	strb	r5, [r6, #0]
	*handle = lll_tx->handle;
   16a88:	5b1b      	ldrh	r3, [r3, r4]
   16a8a:	800b      	strh	r3, [r1, #0]
	*tx = lll_tx->node;
   16a8c:	6843      	ldr	r3, [r0, #4]
   16a8e:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
   16a90:	6818      	ldr	r0, [r3, #0]
}
   16a92:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
   16a94:	2000      	movs	r0, #0
   16a96:	e7fc      	b.n	16a92 <ull_conn_ack_peek+0x26>
   16a98:	2000ea40 	.word	0x2000ea40

00016a9c <ull_conn_ack_by_last_peek>:
{
   16a9c:	b530      	push	{r4, r5, lr}
	lll_tx = mfifo_dequeue_get(mfifo_conn_ack.m, mfifo_conn_ack.s,
   16a9e:	4b09      	ldr	r3, [pc, #36]	; (16ac4 <ull_conn_ack_by_last_peek+0x28>)
   16aa0:	789c      	ldrb	r4, [r3, #2]
   16aa2:	781d      	ldrb	r5, [r3, #0]
	if (first == last) {
   16aa4:	4284      	cmp	r4, r0
   16aa6:	d00a      	beq.n	16abe <ull_conn_ack_by_last_peek+0x22>
	return (void *)(fifo + first * size);
   16aa8:	3304      	adds	r3, #4
   16aaa:	fb14 f405 	smulbb	r4, r4, r5
	if (!lll_tx) {
   16aae:	1918      	adds	r0, r3, r4
   16ab0:	d004      	beq.n	16abc <ull_conn_ack_by_last_peek+0x20>
	*handle = lll_tx->handle;
   16ab2:	5b1b      	ldrh	r3, [r3, r4]
   16ab4:	800b      	strh	r3, [r1, #0]
	*tx = lll_tx->node;
   16ab6:	6843      	ldr	r3, [r0, #4]
   16ab8:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
   16aba:	6818      	ldr	r0, [r3, #0]
}
   16abc:	bd30      	pop	{r4, r5, pc}
		return NULL;
   16abe:	2000      	movs	r0, #0
   16ac0:	e7fc      	b.n	16abc <ull_conn_ack_by_last_peek+0x20>
   16ac2:	bf00      	nop
   16ac4:	2000ea40 	.word	0x2000ea40

00016ac8 <ull_conn_ack_dequeue>:
{
   16ac8:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(conn_ack);
   16aca:	4a09      	ldr	r2, [pc, #36]	; (16af0 <ull_conn_ack_dequeue+0x28>)
	u8_t _first = *first; /* Copy read-index */
   16acc:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
   16ace:	78d0      	ldrb	r0, [r2, #3]
   16ad0:	7811      	ldrb	r1, [r2, #0]
   16ad2:	7854      	ldrb	r4, [r2, #1]
   16ad4:	4298      	cmp	r0, r3
   16ad6:	d009      	beq.n	16aec <ull_conn_ack_dequeue+0x24>
	mem = *((void **)(fifo + _first * size));
   16ad8:	fb03 2101 	mla	r1, r3, r1, r2
	_first += 1U;
   16adc:	3301      	adds	r3, #1
   16ade:	b2db      	uxtb	r3, r3
		_first = 0U;
   16ae0:	429c      	cmp	r4, r3
   16ae2:	bf08      	it	eq
   16ae4:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
   16ae6:	6848      	ldr	r0, [r1, #4]
	*first = _first; /* Write back read-index */
   16ae8:	7093      	strb	r3, [r2, #2]
}
   16aea:	bd10      	pop	{r4, pc}
		return NULL;
   16aec:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(conn_ack);
   16aee:	e7fc      	b.n	16aea <ull_conn_ack_dequeue+0x22>
   16af0:	2000ea40 	.word	0x2000ea40

00016af4 <ull_conn_lll_ack_enqueue>:
{
   16af4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   16af6:	4a12      	ldr	r2, [pc, #72]	; (16b40 <ull_conn_lll_ack_enqueue+0x4c>)
   16af8:	78d4      	ldrb	r4, [r2, #3]
	if (last == count) {
   16afa:	7857      	ldrb	r7, [r2, #1]
   16afc:	7895      	ldrb	r5, [r2, #2]
   16afe:	7816      	ldrb	r6, [r2, #0]
	last = last + 1;
   16b00:	1c63      	adds	r3, r4, #1
   16b02:	b2db      	uxtb	r3, r3
		last = 0U;
   16b04:	429f      	cmp	r7, r3
   16b06:	bf08      	it	eq
   16b08:	2300      	moveq	r3, #0
	if (last == first) {
   16b0a:	429d      	cmp	r5, r3
   16b0c:	d004      	beq.n	16b18 <ull_conn_lll_ack_enqueue+0x24>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   16b0e:	1d15      	adds	r5, r2, #4
   16b10:	fb14 f406 	smulbb	r4, r4, r6
	LL_ASSERT(lll_tx);
   16b14:	192e      	adds	r6, r5, r4
   16b16:	d10f      	bne.n	16b38 <ull_conn_lll_ack_enqueue+0x44>
   16b18:	f240 5383 	movw	r3, #1411	; 0x583
   16b1c:	4a09      	ldr	r2, [pc, #36]	; (16b44 <ull_conn_lll_ack_enqueue+0x50>)
   16b1e:	490a      	ldr	r1, [pc, #40]	; (16b48 <ull_conn_lll_ack_enqueue+0x54>)
   16b20:	480a      	ldr	r0, [pc, #40]	; (16b4c <ull_conn_lll_ack_enqueue+0x58>)
   16b22:	f009 f946 	bl	1fdb2 <printk>
   16b26:	4040      	eors	r0, r0
   16b28:	f380 8811 	msr	BASEPRI, r0
   16b2c:	f04f 0003 	mov.w	r0, #3
   16b30:	df02      	svc	2
	lll_tx->handle = handle;
   16b32:	2300      	movs	r3, #0
   16b34:	801b      	strh	r3, [r3, #0]
   16b36:	deff      	udf	#255	; 0xff
   16b38:	5328      	strh	r0, [r5, r4]
	*last = idx; /* Commit: Update write index */
   16b3a:	70d3      	strb	r3, [r2, #3]
	lll_tx->node = tx;
   16b3c:	6071      	str	r1, [r6, #4]
}
   16b3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   16b40:	2000ea40 	.word	0x2000ea40
   16b44:	00064754 	.word	0x00064754
   16b48:	000647a0 	.word	0x000647a0
   16b4c:	000632fe 	.word	0x000632fe

00016b50 <ull_conn_tx_ack>:
{
   16b50:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	LL_ASSERT(pdu_tx->len);
   16b54:	7953      	ldrb	r3, [r2, #5]
{
   16b56:	4606      	mov	r6, r0
   16b58:	460f      	mov	r7, r1
   16b5a:	4615      	mov	r5, r2
	LL_ASSERT(pdu_tx->len);
   16b5c:	b963      	cbnz	r3, 16b78 <ull_conn_tx_ack+0x28>
   16b5e:	f240 5392 	movw	r3, #1426	; 0x592
   16b62:	4aa2      	ldr	r2, [pc, #648]	; (16dec <ull_conn_tx_ack+0x29c>)
   16b64:	49a2      	ldr	r1, [pc, #648]	; (16df0 <ull_conn_tx_ack+0x2a0>)
   16b66:	48a3      	ldr	r0, [pc, #652]	; (16df4 <ull_conn_tx_ack+0x2a4>)
   16b68:	f009 f923 	bl	1fdb2 <printk>
   16b6c:	4040      	eors	r0, r0
   16b6e:	f380 8811 	msr	BASEPRI, r0
   16b72:	f04f 0003 	mov.w	r0, #3
   16b76:	df02      	svc	2
	if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
   16b78:	792b      	ldrb	r3, [r5, #4]
   16b7a:	f003 0203 	and.w	r2, r3, #3
   16b7e:	2a03      	cmp	r2, #3
   16b80:	f64f 72ff 	movw	r2, #65535	; 0xffff
   16b84:	f040 8125 	bne.w	16dd2 <ull_conn_tx_ack+0x282>
		if (handle != 0xFFFF) {
   16b88:	4296      	cmp	r6, r2
   16b8a:	f000 810a 	beq.w	16da2 <ull_conn_tx_ack+0x252>
			conn = ll_conn_get(handle);
   16b8e:	4630      	mov	r0, r6
   16b90:	f7fe f94e 	bl	14e30 <ll_conn_get>
	switch (pdu_tx->llctrl.opcode) {
   16b94:	79eb      	ldrb	r3, [r5, #7]
   16b96:	3b02      	subs	r3, #2
			conn = ll_conn_get(handle);
   16b98:	4604      	mov	r4, r0
	switch (pdu_tx->llctrl.opcode) {
   16b9a:	2b16      	cmp	r3, #22
   16b9c:	d81e      	bhi.n	16bdc <ull_conn_tx_ack+0x8c>
   16b9e:	e8df f013 	tbh	[pc, r3, lsl #1]
   16ba2:	0017      	.short	0x0017
   16ba4:	00840037 	.word	0x00840037
   16ba8:	001d001d 	.word	0x001d001d
   16bac:	001d001d 	.word	0x001d001d
   16bb0:	0052001d 	.word	0x0052001d
   16bb4:	001d0059 	.word	0x001d0059
   16bb8:	001d008e 	.word	0x001d008e
   16bbc:	001d001d 	.word	0x001d001d
   16bc0:	001d008b 	.word	0x001d008b
   16bc4:	0098001d 	.word	0x0098001d
   16bc8:	00d200a0 	.word	0x00d200a0
   16bcc:	00f900d9 	.word	0x00f900d9
		u8_t reason = (pdu_tx->llctrl.terminate_ind.error_code ==
   16bd0:	7a29      	ldrb	r1, [r5, #8]
   16bd2:	2913      	cmp	r1, #19
		conn_cleanup(conn, reason);
   16bd4:	bf08      	it	eq
   16bd6:	2116      	moveq	r1, #22
   16bd8:	f7fd ff94 	bl	14b04 <conn_cleanup>
		if (link->next == (void *)tx) {
   16bdc:	683b      	ldr	r3, [r7, #0]
   16bde:	42ab      	cmp	r3, r5
   16be0:	f040 80e1 	bne.w	16da6 <ull_conn_tx_ack+0x256>
			LL_ASSERT(link->next);
   16be4:	b965      	cbnz	r5, 16c00 <ull_conn_tx_ack+0xb0>
   16be6:	f240 539e 	movw	r3, #1438	; 0x59e
   16bea:	4a80      	ldr	r2, [pc, #512]	; (16dec <ull_conn_tx_ack+0x29c>)
   16bec:	4982      	ldr	r1, [pc, #520]	; (16df8 <ull_conn_tx_ack+0x2a8>)
   16bee:	4881      	ldr	r0, [pc, #516]	; (16df4 <ull_conn_tx_ack+0x2a4>)
   16bf0:	f009 f8df 	bl	1fdb2 <printk>
   16bf4:	4040      	eors	r0, r0
   16bf6:	f380 8811 	msr	BASEPRI, r0
   16bfa:	f04f 0003 	mov.w	r0, #3
   16bfe:	df02      	svc	2
			mem_release(tx, &mem_conn_tx_ctrl.free);
   16c00:	497e      	ldr	r1, [pc, #504]	; (16dfc <ull_conn_tx_ack+0x2ac>)
   16c02:	4628      	mov	r0, r5
   16c04:	f00d f9f4 	bl	23ff0 <mem_release>
}
   16c08:	4620      	mov	r0, r4
   16c0a:	b002      	add	sp, #8
   16c0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   16c10:	462a      	mov	r2, r5
   16c12:	f852 3f12 	ldr.w	r3, [r2, #18]!
   16c16:	f8c0 30ee 	str.w	r3, [r0, #238]	; 0xee
   16c1a:	6853      	ldr	r3, [r2, #4]
   16c1c:	f8c0 30f2 	str.w	r3, [r0, #242]	; 0xf2
   16c20:	f8d5 301a 	ldr.w	r3, [r5, #26]
   16c24:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
		conn->llcp_enc.pause_tx = 1U;
   16c28:	f890 3152 	ldrb.w	r3, [r0, #338]	; 0x152
   16c2c:	f043 0302 	orr.w	r3, r3, #2
		conn->llcp_enc.pause_tx = 1U;
   16c30:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		conn->procedure_expire = conn->procedure_reload;
   16c34:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
   16c38:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
		conn->llcp_enc.ack = conn->llcp_enc.req;
   16c3c:	f894 3150 	ldrb.w	r3, [r4, #336]	; 0x150
   16c40:	f884 3151 	strb.w	r3, [r4, #337]	; 0x151
		break;
   16c44:	e7ca      	b.n	16bdc <ull_conn_tx_ack+0x8c>
		conn->llcp_enc.pause_tx = 1U;
   16c46:	f890 3152 	ldrb.w	r3, [r0, #338]	; 0x152
   16c4a:	f023 0306 	bic.w	r3, r3, #6
   16c4e:	f043 0306 	orr.w	r3, r3, #6
   16c52:	e7ed      	b.n	16c30 <ull_conn_tx_ack+0xe0>
		if (!conn->lll.role) {
   16c54:	f990 303d 	ldrsb.w	r3, [r0, #61]	; 0x3d
   16c58:	2b00      	cmp	r3, #0
   16c5a:	db26      	blt.n	16caa <ull_conn_tx_ack+0x15a>
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   16c5c:	792b      	ldrb	r3, [r5, #4]
   16c5e:	f043 0303 	orr.w	r3, r3, #3
   16c62:	712b      	strb	r3, [r5, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_req) +
   16c64:	2317      	movs	r3, #23
   16c66:	716b      	strb	r3, [r5, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
   16c68:	2303      	movs	r3, #3
   16c6a:	71eb      	strb	r3, [r5, #7]
   16c6c:	f8d0 2155 	ldr.w	r2, [r0, #341]	; 0x155
   16c70:	60aa      	str	r2, [r5, #8]
   16c72:	f8d0 2159 	ldr.w	r2, [r0, #345]	; 0x159
   16c76:	60ea      	str	r2, [r5, #12]
	pdu_ctrl_tx->llctrl.enc_req.ediv[0] = conn->llcp_enc.ediv[0];
   16c78:	f890 3153 	ldrb.w	r3, [r0, #339]	; 0x153
   16c7c:	742b      	strb	r3, [r5, #16]
	pdu_ctrl_tx->llctrl.enc_req.ediv[1] = conn->llcp_enc.ediv[1];
   16c7e:	f890 3154 	ldrb.w	r3, [r0, #340]	; 0x154
   16c82:	746b      	strb	r3, [r5, #17]
	entropy_get_entropy_isr(entropy, pdu_ctrl_tx->llctrl.enc_req.skdm,
   16c84:	4b5e      	ldr	r3, [pc, #376]	; (16e00 <ull_conn_tx_ack+0x2b0>)
   16c86:	6818      	ldr	r0, [r3, #0]
	if (unlikely(!api->get_entropy_isr)) {
   16c88:	6843      	ldr	r3, [r0, #4]
   16c8a:	f8d3 8004 	ldr.w	r8, [r3, #4]
   16c8e:	f105 0112 	add.w	r1, r5, #18
   16c92:	f1b8 0f00 	cmp.w	r8, #0
   16c96:	d002      	beq.n	16c9e <ull_conn_tx_ack+0x14e>
	return api->get_entropy_isr(dev, buffer, length, flags);
   16c98:	2300      	movs	r3, #0
   16c9a:	220c      	movs	r2, #12
   16c9c:	47c0      	blx	r8
	ctrl_tx_enqueue(conn, *tx);
   16c9e:	4629      	mov	r1, r5
   16ca0:	4620      	mov	r0, r4
   16ca2:	f00d fd59 	bl	24758 <ctrl_tx_enqueue>
	*tx = NULL;
   16ca6:	2500      	movs	r5, #0
   16ca8:	e798      	b.n	16bdc <ull_conn_tx_ack+0x8c>
			conn->llcp_enc.pause_tx = 1U;
   16caa:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   16cae:	f043 0302 	orr.w	r3, r3, #2
   16cb2:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
   16cb6:	e791      	b.n	16bdc <ull_conn_tx_ack+0x8c>
		if (pdu_tx->llctrl.reject_ext_ind.reject_opcode !=
   16cb8:	7a2b      	ldrb	r3, [r5, #8]
   16cba:	2b03      	cmp	r3, #3
   16cbc:	d18e      	bne.n	16bdc <ull_conn_tx_ack+0x8c>
		conn->llcp_enc.pause_rx = 0U;
   16cbe:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   16cc2:	f023 0303 	bic.w	r3, r3, #3
   16cc6:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		conn->procedure_expire = 0U;
   16cca:	2300      	movs	r3, #0
   16ccc:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
		break;
   16cd0:	e784      	b.n	16bdc <ull_conn_tx_ack+0x8c>
		conn->llcp_length.state = LLCP_LENGTH_STATE_RSP_WAIT;
   16cd2:	f890 319a 	ldrb.w	r3, [r0, #410]	; 0x19a
   16cd6:	2202      	movs	r2, #2
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   16cd8:	f362 0302 	bfi	r3, r2, #0, #3
   16cdc:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
				break;
   16ce0:	e77c      	b.n	16bdc <ull_conn_tx_ack+0x8c>
		if (conn->llcp_length.req != conn->llcp_length.ack) {
   16ce2:	f890 1198 	ldrb.w	r1, [r0, #408]	; 0x198
   16ce6:	f890 3199 	ldrb.w	r3, [r0, #409]	; 0x199
   16cea:	428b      	cmp	r3, r1
   16cec:	f43f af76 	beq.w	16bdc <ull_conn_tx_ack+0x8c>
			switch (conn->llcp_length.state) {
   16cf0:	f890 319a 	ldrb.w	r3, [r0, #410]	; 0x19a
   16cf4:	f003 0007 	and.w	r0, r3, #7
   16cf8:	2807      	cmp	r0, #7
   16cfa:	f43f af6f 	beq.w	16bdc <ull_conn_tx_ack+0x8c>
   16cfe:	2201      	movs	r2, #1
   16d00:	4082      	lsls	r2, r0
   16d02:	f012 0f68 	tst.w	r2, #104	; 0x68
   16d06:	f43f af69 	beq.w	16bdc <ull_conn_tx_ack+0x8c>
				conn->lll.max_tx_octets =
   16d0a:	f8b4 219e 	ldrh.w	r2, [r4, #414]	; 0x19e
   16d0e:	f8a4 205c 	strh.w	r2, [r4, #92]	; 0x5c
				if (conn->llcp_length.state ==
   16d12:	2805      	cmp	r0, #5
				conn->lll.max_tx_time =
   16d14:	f8b4 21a2 	ldrh.w	r2, [r4, #418]	; 0x1a2
   16d18:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
				if (conn->llcp_length.state ==
   16d1c:	d101      	bne.n	16d22 <ull_conn_tx_ack+0x1d2>
					conn->llcp_length.state =
   16d1e:	2204      	movs	r2, #4
   16d20:	e7da      	b.n	16cd8 <ull_conn_tx_ack+0x188>
				if (!conn->llcp_length.cache.tx_octets) {
   16d22:	f8b4 21a4 	ldrh.w	r2, [r4, #420]	; 0x1a4
   16d26:	b922      	cbnz	r2, 16d32 <ull_conn_tx_ack+0x1e2>
					conn->llcp_length.ack =
   16d28:	f884 1199 	strb.w	r1, [r4, #409]	; 0x199
					conn->procedure_expire = 0U;
   16d2c:	f8a4 20cc 	strh.w	r2, [r4, #204]	; 0xcc
					break;
   16d30:	e754      	b.n	16bdc <ull_conn_tx_ack+0x8c>
				conn->llcp_length.tx_octets =
   16d32:	f8a4 219e 	strh.w	r2, [r4, #414]	; 0x19e
				conn->llcp_length.tx_time =
   16d36:	f8b4 11a6 	ldrh.w	r1, [r4, #422]	; 0x1a6
   16d3a:	f8a4 11a2 	strh.w	r1, [r4, #418]	; 0x1a2
				conn->llcp_length.cache.tx_octets = 0;
   16d3e:	2200      	movs	r2, #0
   16d40:	f8a4 21a4 	strh.w	r2, [r4, #420]	; 0x1a4
				conn->llcp_length.tx_time =
   16d44:	e7c8      	b.n	16cd8 <ull_conn_tx_ack+0x188>
		conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
   16d46:	f890 31aa 	ldrb.w	r3, [r0, #426]	; 0x1aa
   16d4a:	2202      	movs	r2, #2
   16d4c:	f362 0301 	bfi	r3, r2, #0, #2
   16d50:	f880 31aa 	strb.w	r3, [r0, #426]	; 0x1aa
		if (conn->lll.role) {
   16d54:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   16d58:	2b00      	cmp	r3, #0
   16d5a:	da14      	bge.n	16d86 <ull_conn_tx_ack+0x236>
			u8_t phy_tx_time[8] = {BIT(0), BIT(0), BIT(1), BIT(0),
   16d5c:	4a29      	ldr	r2, [pc, #164]	; (16e04 <ull_conn_tx_ack+0x2b4>)
   16d5e:	f04f 3304 	mov.w	r3, #67372036	; 0x4040404
   16d62:	e9cd 2300 	strd	r2, r3, [sp]
			phys = conn->llcp_phy.tx | lll->phy_tx;
   16d66:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   16d6a:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
   16d6e:	ea42 0393 	orr.w	r3, r2, r3, lsr #2
			lll->phy_tx_time = phy_tx_time[phys];
   16d72:	f003 0307 	and.w	r3, r3, #7
   16d76:	a902      	add	r1, sp, #8
   16d78:	440b      	add	r3, r1
   16d7a:	f813 3c08 	ldrb.w	r3, [r3, #-8]
   16d7e:	f363 1206 	bfi	r2, r3, #4, #3
   16d82:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
   16d86:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   16d8a:	f36f 0300 	bfc	r3, #0, #1
   16d8e:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		break;
   16d92:	e723      	b.n	16bdc <ull_conn_tx_ack+0x8c>
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
   16d94:	f890 30ec 	ldrb.w	r3, [r0, #236]	; 0xec
   16d98:	f890 2064 	ldrb.w	r2, [r0, #100]	; 0x64
   16d9c:	f3c3 0382 	ubfx	r3, r3, #2, #3
   16da0:	e7ed      	b.n	16d7e <ull_conn_tx_ack+0x22e>
	struct ll_conn *conn = NULL;
   16da2:	2400      	movs	r4, #0
   16da4:	e71a      	b.n	16bdc <ull_conn_tx_ack+0x8c>
		} else if (!tx) {
   16da6:	2d00      	cmp	r5, #0
   16da8:	f43f af2e 	beq.w	16c08 <ull_conn_tx_ack+0xb8>
			LL_ASSERT(!link->next);
   16dac:	b163      	cbz	r3, 16dc8 <ull_conn_tx_ack+0x278>
   16dae:	f240 53a5 	movw	r3, #1445	; 0x5a5
   16db2:	4a0e      	ldr	r2, [pc, #56]	; (16dec <ull_conn_tx_ack+0x29c>)
   16db4:	4914      	ldr	r1, [pc, #80]	; (16e08 <ull_conn_tx_ack+0x2b8>)
   16db6:	480f      	ldr	r0, [pc, #60]	; (16df4 <ull_conn_tx_ack+0x2a4>)
   16db8:	f008 fffb 	bl	1fdb2 <printk>
   16dbc:	4040      	eors	r0, r0
   16dbe:	f380 8811 	msr	BASEPRI, r0
   16dc2:	f04f 0003 	mov.w	r0, #3
   16dc6:	df02      	svc	2
	ll_tx_ack_put(handle, tx);
   16dc8:	4629      	mov	r1, r5
   16dca:	4630      	mov	r0, r6
   16dcc:	f7fc f886 	bl	12edc <ll_tx_ack_put>
	return conn;
   16dd0:	e71a      	b.n	16c08 <ull_conn_tx_ack+0xb8>
	} else if (handle != 0xFFFF) {
   16dd2:	4296      	cmp	r6, r2
   16dd4:	d004      	beq.n	16de0 <ull_conn_tx_ack+0x290>
		conn = ll_conn_get(handle);
   16dd6:	4630      	mov	r0, r6
   16dd8:	f7fe f82a 	bl	14e30 <ll_conn_get>
   16ddc:	4604      	mov	r4, r0
   16dde:	e7f3      	b.n	16dc8 <ull_conn_tx_ack+0x278>
		pdu_tx->ll_id = PDU_DATA_LLID_RESV;
   16de0:	f36f 0301 	bfc	r3, #0, #2
   16de4:	712b      	strb	r3, [r5, #4]
	struct ll_conn *conn = NULL;
   16de6:	2400      	movs	r4, #0
   16de8:	e7ee      	b.n	16dc8 <ull_conn_tx_ack+0x278>
   16dea:	bf00      	nop
   16dec:	00064754 	.word	0x00064754
   16df0:	000648b8 	.word	0x000648b8
   16df4:	000632fe 	.word	0x000632fe
   16df8:	000648c5 	.word	0x000648c5
   16dfc:	200014ec 	.word	0x200014ec
   16e00:	20001470 	.word	0x20001470
   16e04:	01020101 	.word	0x01020101
   16e08:	000648c4 	.word	0x000648c4

00016e0c <lll_clock_wait>:

void lll_clock_wait(void)
{
	static bool done;

	if (done) {
   16e0c:	4b13      	ldr	r3, [pc, #76]	; (16e5c <lll_clock_wait+0x50>)
   16e0e:	781a      	ldrb	r2, [r3, #0]
{
   16e10:	b510      	push	{r4, lr}
	if (done) {
   16e12:	b9fa      	cbnz	r2, 16e54 <lll_clock_wait+0x48>
		return;
	}
	done = true;
   16e14:	2201      	movs	r2, #1
   16e16:	701a      	strb	r2, [r3, #0]
   16e18:	4811      	ldr	r0, [pc, #68]	; (16e60 <lll_clock_wait+0x54>)
   16e1a:	f007 f901 	bl	1e020 <z_impl_device_get_binding>

	struct device *clock =
			device_get_binding(DT_INST_0_NORDIC_NRF_CLOCK_LABEL);

	LL_ASSERT(clock);
   16e1e:	4604      	mov	r4, r0
   16e20:	b958      	cbnz	r0, 16e3a <lll_clock_wait+0x2e>
   16e22:	231e      	movs	r3, #30
   16e24:	4a0f      	ldr	r2, [pc, #60]	; (16e64 <lll_clock_wait+0x58>)
   16e26:	4910      	ldr	r1, [pc, #64]	; (16e68 <lll_clock_wait+0x5c>)
   16e28:	4810      	ldr	r0, [pc, #64]	; (16e6c <lll_clock_wait+0x60>)
   16e2a:	f008 ffc2 	bl	1fdb2 <printk>
   16e2e:	4040      	eors	r0, r0
   16e30:	f380 8811 	msr	BASEPRI, r0
   16e34:	f04f 0003 	mov.w	r0, #3
   16e38:	df02      	svc	2
	return api->on(dev, sys);
   16e3a:	6863      	ldr	r3, [r4, #4]
   16e3c:	2101      	movs	r1, #1
   16e3e:	681b      	ldr	r3, [r3, #0]
   16e40:	4620      	mov	r0, r4
   16e42:	4798      	blx	r3
						clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	if (!api->get_status) {
   16e44:	6863      	ldr	r3, [r4, #4]
   16e46:	691b      	ldr	r3, [r3, #16]
   16e48:	b12b      	cbz	r3, 16e56 <lll_clock_wait+0x4a>
		return CLOCK_CONTROL_STATUS_UNKNOWN;
	}

	return api->get_status(dev, sys);
   16e4a:	2101      	movs	r1, #1
   16e4c:	4620      	mov	r0, r4
   16e4e:	4798      	blx	r3

	clock_control_on(clock, CLOCK_CONTROL_NRF_SUBSYS_LF);
	while (clock_control_get_status(clock, CLOCK_CONTROL_NRF_SUBSYS_LF) !=
   16e50:	2802      	cmp	r0, #2
   16e52:	d100      	bne.n	16e56 <lll_clock_wait+0x4a>
			CLOCK_CONTROL_STATUS_ON) {
		DEBUG_CPU_SLEEP(1);
		k_cpu_idle();
		DEBUG_CPU_SLEEP(0);
	}
}
   16e54:	bd10      	pop	{r4, pc}
 * @return N/A
 * @req K-CPU-IDLE-001
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
   16e56:	f7ef fef1 	bl	6c3c <arch_cpu_idle>
   16e5a:	e7f3      	b.n	16e44 <lll_clock_wait+0x38>
   16e5c:	2000aa6e 	.word	0x2000aa6e
   16e60:	0006233c 	.word	0x0006233c
   16e64:	000648d0 	.word	0x000648d0
   16e68:	00064921 	.word	0x00064921
   16e6c:	000632fe 	.word	0x000632fe

00016e70 <isr_cleanup>:

	isr_cleanup(param);
}

static void isr_cleanup(void *param)
{
   16e70:	b508      	push	{r3, lr}
	int err;

	radio_isr_set(isr_race, param);
   16e72:	4601      	mov	r1, r0
   16e74:	480d      	ldr	r0, [pc, #52]	; (16eac <isr_cleanup+0x3c>)
   16e76:	f001 fbff 	bl	18678 <radio_isr_set>
	radio_tmr_stop();
   16e7a:	f001 fe27 	bl	18acc <radio_tmr_stop>

	err = lll_clk_off();
   16e7e:	f7fc fdbf 	bl	13a00 <lll_clk_off>
	LL_ASSERT(!err || err == -EBUSY);
   16e82:	b170      	cbz	r0, 16ea2 <isr_cleanup+0x32>
   16e84:	3010      	adds	r0, #16
   16e86:	d00c      	beq.n	16ea2 <isr_cleanup+0x32>
   16e88:	f240 237e 	movw	r3, #638	; 0x27e
   16e8c:	4a08      	ldr	r2, [pc, #32]	; (16eb0 <isr_cleanup+0x40>)
   16e8e:	4909      	ldr	r1, [pc, #36]	; (16eb4 <isr_cleanup+0x44>)
   16e90:	4809      	ldr	r0, [pc, #36]	; (16eb8 <isr_cleanup+0x48>)
   16e92:	f008 ff8e 	bl	1fdb2 <printk>
   16e96:	4040      	eors	r0, r0
   16e98:	f380 8811 	msr	BASEPRI, r0
   16e9c:	f04f 0003 	mov.w	r0, #3
   16ea0:	df02      	svc	2

	lll_done(NULL);
   16ea2:	2000      	movs	r0, #0
}
   16ea4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
   16ea8:	f7fc bd58 	b.w	1395c <lll_done>
   16eac:	00024a9d 	.word	0x00024a9d
   16eb0:	00064927 	.word	0x00064927
   16eb4:	0006467e 	.word	0x0006467e
   16eb8:	000632fe 	.word	0x000632fe

00016ebc <isr_done>:
{
   16ebc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16ebe:	4605      	mov	r5, r0
	radio_status_reset();
   16ec0:	f001 fcb4 	bl	1882c <radio_status_reset>
	radio_tmr_status_reset();
   16ec4:	f001 fd70 	bl	189a8 <radio_tmr_status_reset>
	radio_filter_status_reset();
   16ec8:	f001 fd4a 	bl	18960 <radio_filter_status_reset>
	radio_ar_status_reset();
   16ecc:	f001 ff0a 	bl	18ce4 <radio_ar_status_reset>
	radio_rssi_status_reset();
   16ed0:	f001 fd0e 	bl	188f0 <radio_rssi_status_reset>
	e = ull_event_done_extra_get();
   16ed4:	f7fc faaa 	bl	1342c <ull_event_done_extra_get>
	LL_ASSERT(e);
   16ed8:	4604      	mov	r4, r0
   16eda:	b960      	cbnz	r0, 16ef6 <isr_done+0x3a>
   16edc:	f240 234d 	movw	r3, #589	; 0x24d
   16ee0:	4a1c      	ldr	r2, [pc, #112]	; (16f54 <isr_done+0x98>)
   16ee2:	491d      	ldr	r1, [pc, #116]	; (16f58 <isr_done+0x9c>)
   16ee4:	481d      	ldr	r0, [pc, #116]	; (16f5c <isr_done+0xa0>)
   16ee6:	f008 ff64 	bl	1fdb2 <printk>
   16eea:	4040      	eors	r0, r0
   16eec:	f380 8811 	msr	BASEPRI, r0
   16ef0:	f04f 0003 	mov.w	r0, #3
   16ef4:	df02      	svc	2
	e->crc_valid = crc_valid;
   16ef6:	4a1a      	ldr	r2, [pc, #104]	; (16f60 <isr_done+0xa4>)
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
   16ef8:	2301      	movs	r3, #1
	e->crc_valid = crc_valid;
   16efa:	7812      	ldrb	r2, [r2, #0]
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
   16efc:	7023      	strb	r3, [r4, #0]
	e->trx_cnt = trx_cnt;
   16efe:	4b19      	ldr	r3, [pc, #100]	; (16f64 <isr_done+0xa8>)
	e->crc_valid = crc_valid;
   16f00:	71a2      	strb	r2, [r4, #6]
	e->mic_state = mic_state;
   16f02:	4a19      	ldr	r2, [pc, #100]	; (16f68 <isr_done+0xac>)
	e->trx_cnt = trx_cnt;
   16f04:	881b      	ldrh	r3, [r3, #0]
	e->mic_state = mic_state;
   16f06:	7812      	ldrb	r2, [r2, #0]
	e->trx_cnt = trx_cnt;
   16f08:	80a3      	strh	r3, [r4, #4]
	e->mic_state = mic_state;
   16f0a:	71e2      	strb	r2, [r4, #7]
	if (trx_cnt) {
   16f0c:	b1db      	cbz	r3, 16f46 <isr_done+0x8a>
		if (lll->role) {
   16f0e:	f995 3021 	ldrsb.w	r3, [r5, #33]	; 0x21
   16f12:	2b00      	cmp	r3, #0
   16f14:	da17      	bge.n	16f46 <isr_done+0x8a>
				addr_us_get(lll->phy_rx);
   16f16:	f895 3049 	ldrb.w	r3, [r5, #73]	; 0x49
   16f1a:	f003 0307 	and.w	r3, r3, #7
#define RANGE_DISTANCE 1000 /* meters */
#define RANGE_DELAY_US (2 * RANGE_DISTANCE * 4 / 1000)

static inline u32_t addr_us_get(u8_t phy)
{
	switch (phy) {
   16f1e:	2b02      	cmp	r3, #2
   16f20:	d016      	beq.n	16f50 <isr_done+0x94>
	default:
	case BIT(0):
		return 40;
   16f22:	2b04      	cmp	r3, #4
   16f24:	bf0c      	ite	eq
   16f26:	f44f 77bc 	moveq.w	r7, #376	; 0x178
   16f2a:	2728      	movne	r7, #40	; 0x28
				radio_tmr_aa_restore() - radio_tmr_ready_get();
   16f2c:	f001 fe06 	bl	18b3c <radio_tmr_aa_restore>
   16f30:	4606      	mov	r6, r0
   16f32:	f001 fe09 	bl	18b48 <radio_tmr_ready_get>
			e->slave.window_widening_event_us =
   16f36:	6b6b      	ldr	r3, [r5, #52]	; 0x34
				radio_tmr_aa_restore() - radio_tmr_ready_get();
   16f38:	1a30      	subs	r0, r6, r0
			e->slave.preamble_to_addr_us = preamble_to_addr_us;
   16f3a:	e9c4 3703 	strd	r3, r7, [r4, #12]
			lll->slave.window_widening_event_us = 0;
   16f3e:	2300      	movs	r3, #0
			e->slave.start_to_address_actual_us =
   16f40:	60a0      	str	r0, [r4, #8]
			lll->slave.window_widening_event_us = 0;
   16f42:	636b      	str	r3, [r5, #52]	; 0x34
			lll->slave.window_size_event_us = 0;
   16f44:	63eb      	str	r3, [r5, #60]	; 0x3c
	isr_cleanup(param);
   16f46:	4628      	mov	r0, r5
}
   16f48:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	isr_cleanup(param);
   16f4c:	f7ff bf90 	b.w	16e70 <isr_cleanup>
	case BIT(1):
		return 24;
   16f50:	2718      	movs	r7, #24
   16f52:	e7eb      	b.n	16f2c <isr_done+0x70>
   16f54:	00064927 	.word	0x00064927
   16f58:	00065ae4 	.word	0x00065ae4
   16f5c:	000632fe 	.word	0x000632fe
   16f60:	2000aa70 	.word	0x2000aa70
   16f64:	20006142 	.word	0x20006142
   16f68:	2000aa71 	.word	0x2000aa71

00016f6c <lll_conn_ppm_get>:
}
   16f6c:	4b01      	ldr	r3, [pc, #4]	; (16f74 <lll_conn_ppm_get+0x8>)
   16f6e:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
   16f72:	4770      	bx	lr
   16f74:	00029820 	.word	0x00029820

00016f78 <lll_conn_prepare_reset>:
	trx_cnt = 0U;
   16f78:	4a04      	ldr	r2, [pc, #16]	; (16f8c <lll_conn_prepare_reset+0x14>)
   16f7a:	2300      	movs	r3, #0
   16f7c:	8013      	strh	r3, [r2, #0]
	crc_expire = 0U;
   16f7e:	4a04      	ldr	r2, [pc, #16]	; (16f90 <lll_conn_prepare_reset+0x18>)
   16f80:	7013      	strb	r3, [r2, #0]
	crc_valid = 0U;
   16f82:	4a04      	ldr	r2, [pc, #16]	; (16f94 <lll_conn_prepare_reset+0x1c>)
   16f84:	7013      	strb	r3, [r2, #0]
	mic_state = LLL_CONN_MIC_NONE;
   16f86:	4a04      	ldr	r2, [pc, #16]	; (16f98 <lll_conn_prepare_reset+0x20>)
   16f88:	7013      	strb	r3, [r2, #0]
}
   16f8a:	4770      	bx	lr
   16f8c:	20006142 	.word	0x20006142
   16f90:	2000aa6f 	.word	0x2000aa6f
   16f94:	2000aa70 	.word	0x2000aa70
   16f98:	2000aa71 	.word	0x2000aa71

00016f9c <lll_conn_abort_cb>:
{
   16f9c:	b510      	push	{r4, lr}
   16f9e:	460c      	mov	r4, r1
	if (!prepare_param) {
   16fa0:	b930      	cbnz	r0, 16fb0 <lll_conn_abort_cb+0x14>
		radio_isr_set(isr_done, param);
   16fa2:	480e      	ldr	r0, [pc, #56]	; (16fdc <lll_conn_abort_cb+0x40>)
   16fa4:	f001 fb68 	bl	18678 <radio_isr_set>
}
   16fa8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
   16fac:	f001 bc2c 	b.w	18808 <radio_disable>
	err = lll_clk_off();
   16fb0:	f7fc fd26 	bl	13a00 <lll_clk_off>
	LL_ASSERT(!err || err == -EBUSY);
   16fb4:	b168      	cbz	r0, 16fd2 <lll_conn_abort_cb+0x36>
   16fb6:	3010      	adds	r0, #16
   16fb8:	d00b      	beq.n	16fd2 <lll_conn_abort_cb+0x36>
   16fba:	2381      	movs	r3, #129	; 0x81
   16fbc:	4a08      	ldr	r2, [pc, #32]	; (16fe0 <lll_conn_abort_cb+0x44>)
   16fbe:	4909      	ldr	r1, [pc, #36]	; (16fe4 <lll_conn_abort_cb+0x48>)
   16fc0:	4809      	ldr	r0, [pc, #36]	; (16fe8 <lll_conn_abort_cb+0x4c>)
   16fc2:	f008 fef6 	bl	1fdb2 <printk>
   16fc6:	4040      	eors	r0, r0
   16fc8:	f380 8811 	msr	BASEPRI, r0
   16fcc:	f04f 0003 	mov.w	r0, #3
   16fd0:	df02      	svc	2
	lll_done(param);
   16fd2:	4620      	mov	r0, r4
}
   16fd4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
   16fd8:	f7fc bcc0 	b.w	1395c <lll_done>
   16fdc:	00016ebd 	.word	0x00016ebd
   16fe0:	00064927 	.word	0x00064927
   16fe4:	0006467e 	.word	0x0006467e
   16fe8:	000632fe 	.word	0x000632fe

00016fec <lll_conn_rx_pkt_set>:
{
   16fec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16fee:	4607      	mov	r7, r0
	node_rx = ull_pdu_rx_alloc_peek(1);
   16ff0:	2001      	movs	r0, #1
   16ff2:	f7fc f845 	bl	13080 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   16ff6:	4604      	mov	r4, r0
   16ff8:	b960      	cbnz	r0, 17014 <lll_conn_rx_pkt_set+0x28>
   16ffa:	f44f 73df 	mov.w	r3, #446	; 0x1be
   16ffe:	4a19      	ldr	r2, [pc, #100]	; (17064 <lll_conn_rx_pkt_set+0x78>)
   17000:	4919      	ldr	r1, [pc, #100]	; (17068 <lll_conn_rx_pkt_set+0x7c>)
   17002:	481a      	ldr	r0, [pc, #104]	; (1706c <lll_conn_rx_pkt_set+0x80>)
   17004:	f008 fed5 	bl	1fdb2 <printk>
   17008:	4040      	eors	r0, r0
   1700a:	f380 8811 	msr	BASEPRI, r0
   1700e:	f04f 0003 	mov.w	r0, #3
   17012:	df02      	svc	2
	phy = lll->phy_rx;
   17014:	f897 5049 	ldrb.w	r5, [r7, #73]	; 0x49
	max_rx_octets = lll->max_rx_octets;
   17018:	f8b7 6042 	ldrh.w	r6, [r7, #66]	; 0x42
	phy = lll->phy_rx;
   1701c:	f005 0507 	and.w	r5, r5, #7
	radio_phy_set(phy, 0);
   17020:	2100      	movs	r1, #0
   17022:	4628      	mov	r0, r5
   17024:	f001 fb6c 	bl	18700 <radio_phy_set>
	} else if (lll->enc_rx) {
   17028:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
   1702c:	006a      	lsls	r2, r5, #1
   1702e:	071b      	lsls	r3, r3, #28
   17030:	f042 0201 	orr.w	r2, r2, #1
   17034:	f104 0420 	add.w	r4, r4, #32
   17038:	d50e      	bpl.n	17058 <lll_conn_rx_pkt_set+0x6c>
		radio_pkt_configure(8, (max_rx_octets + 4), (phy << 1) | 0x01);
   1703a:	1d31      	adds	r1, r6, #4
   1703c:	b2c9      	uxtb	r1, r1
   1703e:	2008      	movs	r0, #8
   17040:	f001 fba4 	bl	1878c <radio_pkt_configure>
		radio_pkt_rx_set(radio_ccm_rx_pkt_set(&lll->ccm_rx, phy,
   17044:	4622      	mov	r2, r4
   17046:	4629      	mov	r1, r5
   17048:	f107 0063 	add.w	r0, r7, #99	; 0x63
   1704c:	f001 fd96 	bl	18b7c <radio_ccm_rx_pkt_set>
}
   17050:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_rx_set(node_rx->pdu);
   17054:	f001 bbc6 	b.w	187e4 <radio_pkt_rx_set>
		radio_pkt_configure(8, max_rx_octets, (phy << 1) | 0x01);
   17058:	2008      	movs	r0, #8
   1705a:	b2f1      	uxtb	r1, r6
   1705c:	f001 fb96 	bl	1878c <radio_pkt_configure>
		radio_pkt_rx_set(node_rx->pdu);
   17060:	4620      	mov	r0, r4
   17062:	e7f5      	b.n	17050 <lll_conn_rx_pkt_set+0x64>
   17064:	00064927 	.word	0x00064927
   17068:	00064981 	.word	0x00064981
   1706c:	000632fe 	.word	0x000632fe

00017070 <lll_conn_isr_tx>:
{
   17070:	b538      	push	{r3, r4, r5, lr}
   17072:	4604      	mov	r4, r0
	radio_status_reset();
   17074:	f001 fbda 	bl	1882c <radio_status_reset>
	radio_tmr_status_reset();
   17078:	f001 fc96 	bl	189a8 <radio_tmr_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
   1707c:	2096      	movs	r0, #150	; 0x96
   1707e:	f001 fca3 	bl	189c8 <radio_tmr_tifs_set>
				     lll->phy_flags);
   17082:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
	radio_switch_complete_and_tx(lll->phy_rx, 0,
   17086:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   1708a:	f3c2 03c0 	ubfx	r3, r2, #3, #1
   1708e:	2100      	movs	r1, #0
   17090:	f002 0207 	and.w	r2, r2, #7
   17094:	f000 0007 	and.w	r0, r0, #7
   17098:	f001 fc12 	bl	188c0 <radio_switch_complete_and_tx>
	lll_conn_rx_pkt_set(lll);
   1709c:	4620      	mov	r0, r4
   1709e:	f7ff ffa5 	bl	16fec <lll_conn_rx_pkt_set>
	LL_ASSERT(!radio_is_ready());
   170a2:	f001 fbcf 	bl	18844 <radio_is_ready>
   170a6:	b160      	cbz	r0, 170c2 <lll_conn_isr_tx+0x52>
   170a8:	f240 1379 	movw	r3, #377	; 0x179
   170ac:	4a1b      	ldr	r2, [pc, #108]	; (1711c <lll_conn_isr_tx+0xac>)
   170ae:	491c      	ldr	r1, [pc, #112]	; (17120 <lll_conn_isr_tx+0xb0>)
   170b0:	481c      	ldr	r0, [pc, #112]	; (17124 <lll_conn_isr_tx+0xb4>)
   170b2:	f008 fe7e 	bl	1fdb2 <printk>
   170b6:	4040      	eors	r0, r0
   170b8:	f380 8811 	msr	BASEPRI, r0
   170bc:	f04f 0003 	mov.w	r0, #3
   170c0:	df02      	svc	2
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 +
   170c2:	f001 fd55 	bl	18b70 <radio_tmr_tifs_base_get>
   170c6:	4605      	mov	r5, r0
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
   170c8:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   170cc:	2101      	movs	r1, #1
   170ce:	f000 0007 	and.w	r0, r0, #7
   170d2:	f00d fe26 	bl	24d22 <radio_rx_chain_delay_get>
	hcto += addr_us_get(lll->phy_rx);
   170d6:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
   170da:	f003 0307 	and.w	r3, r3, #7
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
   170de:	4405      	add	r5, r0
	switch (phy) {
   170e0:	2b02      	cmp	r3, #2
   170e2:	f105 05a3 	add.w	r5, r5, #163	; 0xa3
   170e6:	d016      	beq.n	17116 <lll_conn_isr_tx+0xa6>
		return 40;
   170e8:	2b04      	cmp	r3, #4
   170ea:	bf0c      	ite	eq
   170ec:	f44f 70bc 	moveq.w	r0, #376	; 0x178
   170f0:	2028      	movne	r0, #40	; 0x28
	hcto += addr_us_get(lll->phy_rx);
   170f2:	4405      	add	r5, r0
	hcto -= radio_tx_chain_delay_get(lll->phy_tx, lll->phy_flags);
   170f4:	f894 0048 	ldrb.w	r0, [r4, #72]	; 0x48
   170f8:	f3c0 01c0 	ubfx	r1, r0, #3, #1
   170fc:	f000 0007 	and.w	r0, r0, #7
   17100:	f00d fe0b 	bl	24d1a <radio_tx_chain_delay_get>
	radio_tmr_hcto_configure(hcto);
   17104:	1a28      	subs	r0, r5, r0
   17106:	f001 fced 	bl	18ae4 <radio_tmr_hcto_configure>
	radio_isr_set(lll_conn_isr_rx, param);
   1710a:	4621      	mov	r1, r4
   1710c:	4806      	ldr	r0, [pc, #24]	; (17128 <lll_conn_isr_tx+0xb8>)
}
   1710e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_isr_set(lll_conn_isr_rx, param);
   17112:	f001 bab1 	b.w	18678 <radio_isr_set>
		return 24;
   17116:	2018      	movs	r0, #24
   17118:	e7eb      	b.n	170f2 <lll_conn_isr_tx+0x82>
   1711a:	bf00      	nop
   1711c:	00064927 	.word	0x00064927
   17120:	00064691 	.word	0x00064691
   17124:	000632fe 	.word	0x000632fe
   17128:	0001712d 	.word	0x0001712d

0001712c <lll_conn_isr_rx>:
{
   1712c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   17130:	4604      	mov	r4, r0
	trx_done = radio_is_done();
   17132:	f001 fb91 	bl	18858 <radio_is_done>
   17136:	b2c5      	uxtb	r5, r0
	if (trx_done) {
   17138:	b1a5      	cbz	r5, 17164 <lll_conn_isr_rx+0x38>
		crc_ok = radio_crc_is_valid();
   1713a:	f001 fba3 	bl	18884 <radio_crc_is_valid>
   1713e:	b2c7      	uxtb	r7, r0
		rssi_ready = radio_rssi_is_ready();
   17140:	f001 fbde 	bl	18900 <radio_rssi_is_ready>
	radio_status_reset();
   17144:	f001 fb72 	bl	1882c <radio_status_reset>
	radio_tmr_status_reset();
   17148:	f001 fc2e 	bl	189a8 <radio_tmr_status_reset>
	radio_rssi_status_reset();
   1714c:	f001 fbd0 	bl	188f0 <radio_rssi_status_reset>
	if (!trx_done) {
   17150:	b955      	cbnz	r5, 17168 <lll_conn_isr_rx+0x3c>
		radio_isr_set(isr_done, param);
   17152:	4621      	mov	r1, r4
   17154:	48bd      	ldr	r0, [pc, #756]	; (1744c <lll_conn_isr_rx+0x320>)
   17156:	f001 fa8f 	bl	18678 <radio_isr_set>
		radio_disable();
   1715a:	f001 fb55 	bl	18808 <radio_disable>
}
   1715e:	b003      	add	sp, #12
   17160:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		crc_ok = rssi_ready = 0U;
   17164:	462f      	mov	r7, r5
   17166:	e7ed      	b.n	17144 <lll_conn_isr_rx+0x18>
	trx_cnt++;
   17168:	4ab9      	ldr	r2, [pc, #740]	; (17450 <lll_conn_isr_rx+0x324>)
   1716a:	8813      	ldrh	r3, [r2, #0]
	node_rx = ull_pdu_rx_alloc_peek(1);
   1716c:	2001      	movs	r0, #1
	trx_cnt++;
   1716e:	3301      	adds	r3, #1
   17170:	8013      	strh	r3, [r2, #0]
	node_rx = ull_pdu_rx_alloc_peek(1);
   17172:	f7fb ff85 	bl	13080 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   17176:	4606      	mov	r6, r0
   17178:	b958      	cbnz	r0, 17192 <lll_conn_isr_rx+0x66>
   1717a:	23b7      	movs	r3, #183	; 0xb7
   1717c:	4ab5      	ldr	r2, [pc, #724]	; (17454 <lll_conn_isr_rx+0x328>)
   1717e:	49b6      	ldr	r1, [pc, #728]	; (17458 <lll_conn_isr_rx+0x32c>)
   17180:	48b6      	ldr	r0, [pc, #728]	; (1745c <lll_conn_isr_rx+0x330>)
   17182:	f008 fe16 	bl	1fdb2 <printk>
   17186:	4040      	eors	r0, r0
   17188:	f380 8811 	msr	BASEPRI, r0
   1718c:	f04f 0003 	mov.w	r0, #3
   17190:	df02      	svc	2
	if (crc_ok) {
   17192:	2f00      	cmp	r7, #0
   17194:	f000 814a 	beq.w	1742c <lll_conn_isr_rx+0x300>

static int isr_rx_pdu(struct lll_conn *lll, struct pdu_data *pdu_data_rx,
		      struct node_tx **tx_release, u8_t *is_rx_enqueue)
{
	/* Ack for tx-ed data */
	if (pdu_data_rx->nesn != lll->sn) {
   17198:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
   1719c:	f896 1020 	ldrb.w	r1, [r6, #32]
   171a0:	f003 0201 	and.w	r2, r3, #1
   171a4:	f3c1 0180 	ubfx	r1, r1, #2, #1
   171a8:	4291      	cmp	r1, r2
   171aa:	f000 80dd 	beq.w	17368 <lll_conn_isr_rx+0x23c>
		/* Increment serial number */
		lll->sn++;
   171ae:	f082 0201 	eor.w	r2, r2, #1
   171b2:	f362 0300 	bfi	r3, r2, #0, #1
   171b6:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62

#if defined(CONFIG_BT_PERIPHERAL)
		/* First ack (and redundantly any other ack) enable use of
		 * slave latency.
		 */
		if (lll->role) {
   171ba:	f994 3021 	ldrsb.w	r3, [r4, #33]	; 0x21
   171be:	2b00      	cmp	r3, #0
			lll->slave.latency_enabled = 1;
   171c0:	bfbe      	ittt	lt
   171c2:	f894 3024 	ldrblt.w	r3, [r4, #36]	; 0x24
   171c6:	f043 0301 	orrlt.w	r3, r3, #1
   171ca:	f884 3024 	strblt.w	r3, [r4, #36]	; 0x24
		}
#endif /* CONFIG_BT_PERIPHERAL */

		if (!lll->empty) {
   171ce:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
   171d2:	0758      	lsls	r0, r3, #29
   171d4:	f100 80c4 	bmi.w	17360 <lll_conn_isr_rx+0x234>
			struct pdu_data *pdu_data_tx;
			u8_t pdu_data_tx_len;
			struct node_tx *tx;
			memq_link_t *link;

			link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail,
   171d8:	aa01      	add	r2, sp, #4
   171da:	e9d4 0113 	ldrd	r0, r1, [r4, #76]	; 0x4c
   171de:	f00c ff4f 	bl	24080 <memq_peek>
					 (void **)&tx);
			LL_ASSERT(link);
   171e2:	4605      	mov	r5, r0
   171e4:	b960      	cbnz	r0, 17200 <lll_conn_isr_rx+0xd4>
   171e6:	f240 23a9 	movw	r3, #681	; 0x2a9
   171ea:	4a9a      	ldr	r2, [pc, #616]	; (17454 <lll_conn_isr_rx+0x328>)
   171ec:	499c      	ldr	r1, [pc, #624]	; (17460 <lll_conn_isr_rx+0x334>)
   171ee:	489b      	ldr	r0, [pc, #620]	; (1745c <lll_conn_isr_rx+0x330>)
   171f0:	f008 fddf 	bl	1fdb2 <printk>
   171f4:	4040      	eors	r0, r0
   171f6:	f380 8811 	msr	BASEPRI, r0
   171fa:	f04f 0003 	mov.w	r0, #3
   171fe:	df02      	svc	2

			pdu_data_tx = (void *)(tx->pdu +
					       lll->packet_tx_head_offset);
   17200:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61

			pdu_data_tx_len = pdu_data_tx->len;
   17204:	9a01      	ldr	r2, [sp, #4]
   17206:	441a      	add	r2, r3
   17208:	7950      	ldrb	r0, [r2, #5]
#if defined(CONFIG_BT_CTLR_LE_ENC)
			if (pdu_data_tx_len != 0U) {
   1720a:	b150      	cbz	r0, 17222 <lll_conn_isr_rx+0xf6>
				/* if encrypted increment tx counter */
				if (lll->enc_tx) {
   1720c:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
   17210:	06d1      	lsls	r1, r2, #27
   17212:	d506      	bpl.n	17222 <lll_conn_isr_rx+0xf6>
					lll->ccm_tx.counter++;
   17214:	e9d4 2125 	ldrd	r2, r1, [r4, #148]	; 0x94
   17218:	3201      	adds	r2, #1
   1721a:	f141 0100 	adc.w	r1, r1, #0
   1721e:	e9c4 2125 	strd	r2, r1, [r4, #148]	; 0x94
				}
			}
#endif /* CONFIG_BT_CTLR_LE_ENC */

			lll->packet_tx_head_offset += pdu_data_tx_len;
			if (lll->packet_tx_head_offset ==
   17222:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
			lll->packet_tx_head_offset += pdu_data_tx_len;
   17226:	4403      	add	r3, r0
   17228:	b2db      	uxtb	r3, r3
			if (lll->packet_tx_head_offset ==
   1722a:	429a      	cmp	r2, r3
			lll->packet_tx_head_offset += pdu_data_tx_len;
   1722c:	f884 3061 	strb.w	r3, [r4, #97]	; 0x61
			if (lll->packet_tx_head_offset ==
   17230:	f04f 0200 	mov.w	r2, #0
   17234:	f040 8098 	bne.w	17368 <lll_conn_isr_rx+0x23c>
			    lll->packet_tx_head_len) {
				lll->packet_tx_head_len = 0;
   17238:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
				lll->packet_tx_head_offset = 0;

				memq_dequeue(lll->memq_tx.tail,
   1723c:	f104 014c 	add.w	r1, r4, #76	; 0x4c
   17240:	6d20      	ldr	r0, [r4, #80]	; 0x50
   17242:	f00c ff25 	bl	24090 <memq_dequeue>
					     &lll->memq_tx.head, NULL);

				/* TX node UPSTREAM, i.e. Tx node ack path */
				link->next = tx->next; /* Indicates ctrl or data
   17246:	f8dd 8004 	ldr.w	r8, [sp, #4]
   1724a:	f8d8 3000 	ldr.w	r3, [r8]
   1724e:	602b      	str	r3, [r5, #0]
							* pool.
							*/
				tx->next = link;
   17250:	f8c8 5000 	str.w	r5, [r8]
			lll->empty = 0;
		}
	}

	/* process received data */
	if ((pdu_data_rx->sn == lll->nesn) &&
   17254:	f896 2020 	ldrb.w	r2, [r6, #32]
   17258:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
   1725c:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   17260:	f3c3 0340 	ubfx	r3, r3, #1, #1
   17264:	429a      	cmp	r2, r3
   17266:	f000 8082 	beq.w	1736e <lll_conn_isr_rx+0x242>
	u8_t is_rx_enqueue = 0U;
   1726a:	f04f 0900 	mov.w	r9, #0
		crc_expire = 0U;
   1726e:	4b7d      	ldr	r3, [pc, #500]	; (17464 <lll_conn_isr_rx+0x338>)
   17270:	2500      	movs	r5, #0
   17272:	701d      	strb	r5, [r3, #0]
		crc_valid = 1U;
   17274:	4b7c      	ldr	r3, [pc, #496]	; (17468 <lll_conn_isr_rx+0x33c>)
   17276:	2201      	movs	r2, #1
   17278:	701a      	strb	r2, [r3, #0]
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
   1727a:	a901      	add	r1, sp, #4
   1727c:	4620      	mov	r0, r4
   1727e:	f00d fc72 	bl	24b66 <lll_conn_pdu_tx_prep>
	is_done = is_crc_backoff || ((crc_ok) && (pdu_data_rx->md == 0) &&
   17282:	2d00      	cmp	r5, #0
   17284:	f040 80fc 	bne.w	17480 <lll_conn_isr_rx+0x354>
   17288:	b147      	cbz	r7, 1729c <lll_conn_isr_rx+0x170>
   1728a:	f896 3020 	ldrb.w	r3, [r6, #32]
   1728e:	06db      	lsls	r3, r3, #27
   17290:	d404      	bmi.n	1729c <lll_conn_isr_rx+0x170>
				     (pdu_data_tx->len == 0));
   17292:	9b01      	ldr	r3, [sp, #4]
	is_done = is_crc_backoff || ((crc_ok) && (pdu_data_rx->md == 0) &&
   17294:	785b      	ldrb	r3, [r3, #1]
   17296:	2b00      	cmp	r3, #0
   17298:	f000 80f2 	beq.w	17480 <lll_conn_isr_rx+0x354>
		radio_tmr_tifs_set(EVENT_IFS_US);
   1729c:	2096      	movs	r0, #150	; 0x96
   1729e:	f001 fb93 	bl	189c8 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(lll->phy_rx);
   172a2:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   172a6:	f000 0007 	and.w	r0, r0, #7
   172aa:	f001 fafd 	bl	188a8 <radio_switch_complete_and_rx>
		radio_isr_set(lll_conn_isr_tx, param);
   172ae:	4621      	mov	r1, r4
   172b0:	486e      	ldr	r0, [pc, #440]	; (1746c <lll_conn_isr_rx+0x340>)
   172b2:	f001 f9e1 	bl	18678 <radio_isr_set>
		radio_tmr_end_capture();
   172b6:	f001 fc4d 	bl	18b54 <radio_tmr_end_capture>
	pdu_data_tx->sn = lll->sn;
   172ba:	9901      	ldr	r1, [sp, #4]
   172bc:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
   172c0:	780b      	ldrb	r3, [r1, #0]
   172c2:	f3c2 0200 	ubfx	r2, r2, #0, #1
   172c6:	f362 03c3 	bfi	r3, r2, #3, #1
	pdu_data_tx->nesn = lll->nesn;
   172ca:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
   172ce:	f3c2 0240 	ubfx	r2, r2, #1, #1
   172d2:	f362 0382 	bfi	r3, r2, #2, #1
   172d6:	700b      	strb	r3, [r1, #0]
	lll_conn_tx_pkt_set(lll, pdu_data_tx);
   172d8:	4620      	mov	r0, r4
   172da:	f00d fc1b 	bl	24b14 <lll_conn_tx_pkt_set>
	LL_ASSERT(!radio_is_ready());
   172de:	f001 fab1 	bl	18844 <radio_is_ready>
   172e2:	b160      	cbz	r0, 172fe <lll_conn_isr_rx+0x1d2>
   172e4:	f240 1321 	movw	r3, #289	; 0x121
   172e8:	4a5a      	ldr	r2, [pc, #360]	; (17454 <lll_conn_isr_rx+0x328>)
   172ea:	4961      	ldr	r1, [pc, #388]	; (17470 <lll_conn_isr_rx+0x344>)
   172ec:	485b      	ldr	r0, [pc, #364]	; (1745c <lll_conn_isr_rx+0x330>)
   172ee:	f008 fd60 	bl	1fdb2 <printk>
   172f2:	4040      	eors	r0, r0
   172f4:	f380 8811 	msr	BASEPRI, r0
   172f8:	f04f 0003 	mov.w	r0, #3
   172fc:	df02      	svc	2
	if (!radio_tmr_aa_restore()) {
   172fe:	f001 fc1d 	bl	18b3c <radio_tmr_aa_restore>
   17302:	b918      	cbnz	r0, 1730c <lll_conn_isr_rx+0x1e0>
		radio_tmr_aa_save(radio_tmr_aa_get());
   17304:	f001 fc0e 	bl	18b24 <radio_tmr_aa_get>
   17308:	f001 fc12 	bl	18b30 <radio_tmr_aa_save>
	if (tx_release) {
   1730c:	f1b8 0f00 	cmp.w	r8, #0
   17310:	f000 80bd 	beq.w	1748e <lll_conn_isr_rx+0x362>
		LL_ASSERT(lll->handle != 0xFFFF);
   17314:	8a22      	ldrh	r2, [r4, #16]
   17316:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1731a:	429a      	cmp	r2, r3
   1731c:	d10c      	bne.n	17338 <lll_conn_isr_rx+0x20c>
   1731e:	f44f 7397 	mov.w	r3, #302	; 0x12e
   17322:	4a4c      	ldr	r2, [pc, #304]	; (17454 <lll_conn_isr_rx+0x328>)
   17324:	4953      	ldr	r1, [pc, #332]	; (17474 <lll_conn_isr_rx+0x348>)
   17326:	484d      	ldr	r0, [pc, #308]	; (1745c <lll_conn_isr_rx+0x330>)
   17328:	f008 fd43 	bl	1fdb2 <printk>
   1732c:	4040      	eors	r0, r0
   1732e:	f380 8811 	msr	BASEPRI, r0
   17332:	f04f 0003 	mov.w	r0, #3
   17336:	df02      	svc	2
		ull_conn_lll_ack_enqueue(lll->handle, tx_release);
   17338:	4641      	mov	r1, r8
   1733a:	8a20      	ldrh	r0, [r4, #16]
   1733c:	f7ff fbda 	bl	16af4 <ull_conn_lll_ack_enqueue>
	if (is_rx_enqueue) {
   17340:	f1b9 0f00 	cmp.w	r9, #0
   17344:	d009      	beq.n	1735a <lll_conn_isr_rx+0x22e>
		ull_pdu_rx_alloc();
   17346:	f7fb feb3 	bl	130b0 <ull_pdu_rx_alloc>
		node_rx->hdr.type = NODE_RX_TYPE_DC_PDU;
   1734a:	2302      	movs	r3, #2
   1734c:	7133      	strb	r3, [r6, #4]
		node_rx->hdr.handle = lll->handle;
   1734e:	8a23      	ldrh	r3, [r4, #16]
   17350:	80f3      	strh	r3, [r6, #6]
		ull_rx_put(node_rx->hdr.link, node_rx);
   17352:	4631      	mov	r1, r6
   17354:	6830      	ldr	r0, [r6, #0]
   17356:	f7fb fec1 	bl	130dc <ull_rx_put>
		ull_rx_sched();
   1735a:	f7fb fecf 	bl	130fc <ull_rx_sched>
	ARG_UNUSED(rssi_ready);
   1735e:	e6fe      	b.n	1715e <lll_conn_isr_rx+0x32>
			lll->empty = 0;
   17360:	f36f 0382 	bfc	r3, #2, #1
   17364:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62
	struct node_tx *tx_release = NULL;
   17368:	f04f 0800 	mov.w	r8, #0
   1736c:	e772      	b.n	17254 <lll_conn_isr_rx+0x128>
	    /* check so that we will NEVER use the rx buffer reserved for empty
	     * packet and internal control enqueue
	     */
	    (ull_pdu_rx_alloc_peek(3) != 0)) {
   1736e:	2003      	movs	r0, #3
   17370:	f7fb fe86 	bl	13080 <ull_pdu_rx_alloc_peek>
	if ((pdu_data_rx->sn == lll->nesn) &&
   17374:	2800      	cmp	r0, #0
   17376:	f43f af78 	beq.w	1726a <lll_conn_isr_rx+0x13e>
		/* Increment next expected serial number */
		lll->nesn++;
   1737a:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
   1737e:	f083 0302 	eor.w	r3, r3, #2
   17382:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62

		if (pdu_data_rx->len != 0) {
   17386:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
   1738a:	2b00      	cmp	r3, #0
   1738c:	f43f af6d 	beq.w	1726a <lll_conn_isr_rx+0x13e>
#if defined(CONFIG_BT_CTLR_LE_ENC)
			/* If required, wait for CCM to finish
			 */
			if (lll->enc_rx) {
   17390:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
   17394:	071a      	lsls	r2, r3, #28
   17396:	d546      	bpl.n	17426 <lll_conn_isr_rx+0x2fa>
				u32_t done;

				done = radio_ccm_is_done();
   17398:	f001 fc4a 	bl	18c30 <radio_ccm_is_done>
				LL_ASSERT(done);
   1739c:	b960      	cbnz	r0, 173b8 <lll_conn_isr_rx+0x28c>
   1739e:	f240 23df 	movw	r3, #735	; 0x2df
   173a2:	4a2c      	ldr	r2, [pc, #176]	; (17454 <lll_conn_isr_rx+0x328>)
   173a4:	4934      	ldr	r1, [pc, #208]	; (17478 <lll_conn_isr_rx+0x34c>)
   173a6:	482d      	ldr	r0, [pc, #180]	; (1745c <lll_conn_isr_rx+0x330>)
   173a8:	f008 fd03 	bl	1fdb2 <printk>
   173ac:	4040      	eors	r0, r0
   173ae:	f380 8811 	msr	BASEPRI, r0
   173b2:	f04f 0003 	mov.w	r0, #3
   173b6:	df02      	svc	2

				bool mic_failure = !radio_ccm_mic_is_valid();
   173b8:	f001 fc58 	bl	18c6c <radio_ccm_mic_is_valid>

				if (mic_failure &&
   173bc:	4d2f      	ldr	r5, [pc, #188]	; (1747c <lll_conn_isr_rx+0x350>)
   173be:	bb10      	cbnz	r0, 17406 <lll_conn_isr_rx+0x2da>
				    lll->ccm_rx.counter == 0 &&
   173c0:	f8d4 2073 	ldr.w	r2, [r4, #115]	; 0x73
   173c4:	f8d4 3077 	ldr.w	r3, [r4, #119]	; 0x77
				if (mic_failure &&
   173c8:	4313      	orrs	r3, r2
   173ca:	d165      	bne.n	17498 <lll_conn_isr_rx+0x36c>
				    (pdu_data_rx->ll_id ==
   173cc:	f896 3020 	ldrb.w	r3, [r6, #32]
				    lll->ccm_rx.counter == 0 &&
   173d0:	f003 0303 	and.w	r3, r3, #3
   173d4:	2b03      	cmp	r3, #3
   173d6:	d15f      	bne.n	17498 <lll_conn_isr_rx+0x36c>
					 * middle of the LL encryption procedure
					 * with MIC failure.
					 * This could be an unencrypted packet
					 */
					struct pdu_data *scratch_pkt =
						radio_pkt_scratch_get();
   173d8:	f001 fa62 	bl	188a0 <radio_pkt_scratch_get>

					if (ctrl_pdu_len_check(
   173dc:	7842      	ldrb	r2, [r0, #1]
   173de:	2a1b      	cmp	r2, #27
						radio_pkt_scratch_get();
   173e0:	4601      	mov	r1, r0
					if (ctrl_pdu_len_check(
   173e2:	d859      	bhi.n	17498 <lll_conn_isr_rx+0x36c>
   173e4:	3203      	adds	r2, #3
   173e6:	f106 0020 	add.w	r0, r6, #32
   173ea:	f7ea fbff 	bl	1bec <memcpy>
						       scratch_pkt,
						       scratch_pkt->len +
						       offsetof(struct pdu_data,
							llctrl));
						mic_failure = false;
						lll->ccm_rx.counter--;
   173ee:	f8d4 3073 	ldr.w	r3, [r4, #115]	; 0x73
   173f2:	f8d4 2077 	ldr.w	r2, [r4, #119]	; 0x77
   173f6:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   173fa:	f142 32ff 	adc.w	r2, r2, #4294967295	; 0xffffffff
   173fe:	f8c4 3073 	str.w	r3, [r4, #115]	; 0x73
   17402:	f8c4 2077 	str.w	r2, [r4, #119]	; 0x77

					return -EINVAL;
				}

				/* Increment counter */
				lll->ccm_rx.counter++;
   17406:	f8d4 3073 	ldr.w	r3, [r4, #115]	; 0x73
   1740a:	f8d4 2077 	ldr.w	r2, [r4, #119]	; 0x77
   1740e:	3301      	adds	r3, #1
   17410:	f142 0200 	adc.w	r2, r2, #0

				/* Record MIC valid */
				mic_state = LLL_CONN_MIC_PASS;
   17414:	f04f 0901 	mov.w	r9, #1
				lll->ccm_rx.counter++;
   17418:	f8c4 3073 	str.w	r3, [r4, #115]	; 0x73
   1741c:	f8c4 2077 	str.w	r2, [r4, #119]	; 0x77
				mic_state = LLL_CONN_MIC_PASS;
   17420:	f885 9000 	strb.w	r9, [r5]
		if (err) {
   17424:	e723      	b.n	1726e <lll_conn_isr_rx+0x142>
			}
#endif /* CONFIG_BT_CTLR_LE_ENC */

			/* Enqueue non-empty PDU */
			*is_rx_enqueue = 1U;
   17426:	f04f 0901 	mov.w	r9, #1
   1742a:	e720      	b.n	1726e <lll_conn_isr_rx+0x142>
		if (crc_expire == 0U) {
   1742c:	4b0d      	ldr	r3, [pc, #52]	; (17464 <lll_conn_isr_rx+0x338>)
   1742e:	781a      	ldrb	r2, [r3, #0]
   17430:	b90a      	cbnz	r2, 17436 <lll_conn_isr_rx+0x30a>
			crc_expire = 2U;
   17432:	2202      	movs	r2, #2
   17434:	701a      	strb	r2, [r3, #0]
		crc_expire--;
   17436:	781d      	ldrb	r5, [r3, #0]
   17438:	3d01      	subs	r5, #1
   1743a:	b2ed      	uxtb	r5, r5
   1743c:	701d      	strb	r5, [r3, #0]
	u8_t is_rx_enqueue = 0U;
   1743e:	f04f 0900 	mov.w	r9, #0
		is_crc_backoff = (crc_expire == 0U);
   17442:	fab5 f585 	clz	r5, r5
   17446:	096d      	lsrs	r5, r5, #5
	struct node_tx *tx_release = NULL;
   17448:	46c8      	mov	r8, r9
   1744a:	e716      	b.n	1727a <lll_conn_isr_rx+0x14e>
   1744c:	00016ebd 	.word	0x00016ebd
   17450:	20006142 	.word	0x20006142
   17454:	00064927 	.word	0x00064927
   17458:	00064981 	.word	0x00064981
   1745c:	000632fe 	.word	0x000632fe
   17460:	00064829 	.word	0x00064829
   17464:	2000aa6f 	.word	0x2000aa6f
   17468:	2000aa70 	.word	0x2000aa70
   1746c:	00017071 	.word	0x00017071
   17470:	00064691 	.word	0x00064691
   17474:	0006496b 	.word	0x0006496b
   17478:	00064443 	.word	0x00064443
   1747c:	2000aa71 	.word	0x2000aa71
		radio_isr_set(isr_done, param);
   17480:	4621      	mov	r1, r4
   17482:	4808      	ldr	r0, [pc, #32]	; (174a4 <lll_conn_isr_rx+0x378>)
   17484:	f001 f8f8 	bl	18678 <radio_isr_set>
			radio_switch_complete_and_disable();
   17488:	f001 fa24 	bl	188d4 <radio_switch_complete_and_disable>
   1748c:	e715      	b.n	172ba <lll_conn_isr_rx+0x18e>
	if (is_rx_enqueue) {
   1748e:	f1b9 0f00 	cmp.w	r9, #0
   17492:	f43f ae64 	beq.w	1715e <lll_conn_isr_rx+0x32>
   17496:	e756      	b.n	17346 <lll_conn_isr_rx+0x21a>
					mic_state = LLL_CONN_MIC_FAIL;
   17498:	2302      	movs	r3, #2
   1749a:	702b      	strb	r3, [r5, #0]
	u8_t is_rx_enqueue = 0U;
   1749c:	f04f 0900 	mov.w	r9, #0
   174a0:	e72d      	b.n	172fe <lll_conn_isr_rx+0x1d2>
   174a2:	bf00      	nop
   174a4:	00016ebd 	.word	0x00016ebd

000174a8 <ticker_op_cb>:
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
		  param == ull_disable_mark_get());
}

static void ticker_op_cb(u32_t status, void *param)
{
   174a8:	b508      	push	{r3, lr}
	ARG_UNUSED(param);

	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   174aa:	b160      	cbz	r0, 174c6 <ticker_op_cb+0x1e>
   174ac:	f240 13b9 	movw	r3, #441	; 0x1b9
   174b0:	4a05      	ldr	r2, [pc, #20]	; (174c8 <ticker_op_cb+0x20>)
   174b2:	4906      	ldr	r1, [pc, #24]	; (174cc <ticker_op_cb+0x24>)
   174b4:	4806      	ldr	r0, [pc, #24]	; (174d0 <ticker_op_cb+0x28>)
   174b6:	f008 fc7c 	bl	1fdb2 <printk>
   174ba:	4040      	eors	r0, r0
   174bc:	f380 8811 	msr	BASEPRI, r0
   174c0:	f04f 0003 	mov.w	r0, #3
   174c4:	df02      	svc	2
}
   174c6:	bd08      	pop	{r3, pc}
   174c8:	000649ac 	.word	0x000649ac
   174cc:	00064794 	.word	0x00064794
   174d0:	000632fe 	.word	0x000632fe

000174d4 <ticker_op_stop_adv_cb>:
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
   174d4:	2801      	cmp	r0, #1
{
   174d6:	b510      	push	{r4, lr}
   174d8:	460c      	mov	r4, r1
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
   174da:	d110      	bne.n	174fe <ticker_op_stop_adv_cb+0x2a>
   174dc:	f7fb fd72 	bl	12fc4 <ull_disable_mark_get>
   174e0:	4284      	cmp	r4, r0
   174e2:	d00c      	beq.n	174fe <ticker_op_stop_adv_cb+0x2a>
   174e4:	f44f 73d9 	mov.w	r3, #434	; 0x1b2
   174e8:	4a05      	ldr	r2, [pc, #20]	; (17500 <ticker_op_stop_adv_cb+0x2c>)
   174ea:	4906      	ldr	r1, [pc, #24]	; (17504 <ticker_op_stop_adv_cb+0x30>)
   174ec:	4806      	ldr	r0, [pc, #24]	; (17508 <ticker_op_stop_adv_cb+0x34>)
   174ee:	f008 fc60 	bl	1fdb2 <printk>
   174f2:	4040      	eors	r0, r0
   174f4:	f380 8811 	msr	BASEPRI, r0
   174f8:	f04f 0003 	mov.w	r0, #3
   174fc:	df02      	svc	2
}
   174fe:	bd10      	pop	{r4, pc}
   17500:	000649ac 	.word	0x000649ac
   17504:	000649e6 	.word	0x000649e6
   17508:	000632fe 	.word	0x000632fe

0001750c <ull_slave_ticker_cb>:
{
   1750c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1750e:	4605      	mov	r5, r0
   17510:	460f      	mov	r7, r1
	ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
   17512:	4601      	mov	r1, r0
   17514:	4618      	mov	r0, r3
{
   17516:	4616      	mov	r6, r2
   17518:	461c      	mov	r4, r3
	ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
   1751a:	f7eb f9cd 	bl	28b8 <ull_conn_llcp>
	if (ret) {
   1751e:	2800      	cmp	r0, #0
   17520:	d136      	bne.n	17590 <ull_slave_ticker_cb+0x84>
   17522:	7c23      	ldrb	r3, [r4, #16]
   17524:	3301      	adds	r3, #1
   17526:	b2db      	uxtb	r3, r3
   17528:	7423      	strb	r3, [r4, #16]
	LL_ASSERT(ref);
   1752a:	b963      	cbnz	r3, 17546 <ull_slave_ticker_cb+0x3a>
   1752c:	f240 1369 	movw	r3, #361	; 0x169
   17530:	4a18      	ldr	r2, [pc, #96]	; (17594 <ull_slave_ticker_cb+0x88>)
   17532:	4919      	ldr	r1, [pc, #100]	; (17598 <ull_slave_ticker_cb+0x8c>)
   17534:	4819      	ldr	r0, [pc, #100]	; (1759c <ull_slave_ticker_cb+0x90>)
   17536:	f008 fc3c 	bl	1fdb2 <printk>
   1753a:	4040      	eors	r0, r0
   1753c:	f380 8811 	msr	BASEPRI, r0
   17540:	f04f 0003 	mov.w	r0, #3
   17544:	df02      	svc	2
	p.ticks_at_expire = ticks_at_expire;
   17546:	4a16      	ldr	r2, [pc, #88]	; (175a0 <ull_slave_ticker_cb+0x94>)
	p.param = &conn->lll;
   17548:	f104 031c 	add.w	r3, r4, #28
   1754c:	60d3      	str	r3, [r2, #12]
	mfy.param = &p;
   1754e:	4b15      	ldr	r3, [pc, #84]	; (175a4 <ull_slave_ticker_cb+0x98>)
	p.lazy = lazy;
   17550:	8116      	strh	r6, [r2, #8]
	p.remainder = remainder;
   17552:	e9c2 5700 	strd	r5, r7, [r2]
	mfy.param = &p;
   17556:	609a      	str	r2, [r3, #8]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   17558:	2200      	movs	r2, #0
   1755a:	4611      	mov	r1, r2
   1755c:	2001      	movs	r0, #1
   1755e:	f7f9 f869 	bl	10634 <mayfly_enqueue>
	LL_ASSERT(!err);
   17562:	b160      	cbz	r0, 1757e <ull_slave_ticker_cb+0x72>
   17564:	f240 1375 	movw	r3, #373	; 0x175
   17568:	4a0a      	ldr	r2, [pc, #40]	; (17594 <ull_slave_ticker_cb+0x88>)
   1756a:	490f      	ldr	r1, [pc, #60]	; (175a8 <ull_slave_ticker_cb+0x9c>)
   1756c:	480b      	ldr	r0, [pc, #44]	; (1759c <ull_slave_ticker_cb+0x90>)
   1756e:	f008 fc20 	bl	1fdb2 <printk>
   17572:	4040      	eors	r0, r0
   17574:	f380 8811 	msr	BASEPRI, r0
   17578:	f04f 0003 	mov.w	r0, #3
   1757c:	df02      	svc	2
	ull_conn_tx_demux(UINT8_MAX);
   1757e:	20ff      	movs	r0, #255	; 0xff
   17580:	f7ff f96a 	bl	16858 <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
   17584:	4620      	mov	r0, r4
   17586:	21ff      	movs	r1, #255	; 0xff
}
   17588:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
   1758c:	f7ff b9aa 	b.w	168e4 <ull_conn_tx_lll_enqueue>
}
   17590:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   17592:	bf00      	nop
   17594:	000649ac 	.word	0x000649ac
   17598:	00064434 	.word	0x00064434
   1759c:	000632fe 	.word	0x000632fe
   175a0:	200015b4 	.word	0x200015b4
   175a4:	2000eab8 	.word	0x2000eab8
   175a8:	00064426 	.word	0x00064426

000175ac <prepare_cb>:
{
	return 0;
}

static int prepare_cb(struct lll_prepare_param *prepare_param)
{
   175ac:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	struct lll_conn *lll = prepare_param->param;
   175b0:	68c4      	ldr	r4, [r0, #12]

	DEBUG_RADIO_START_S(1);

	/* TODO: Do the below in ULL ?  */

	lazy = prepare_param->lazy;
   175b2:	8903      	ldrh	r3, [r0, #8]

	/* Calc window widening */
	if (lll->role) {
   175b4:	f994 2021 	ldrsb.w	r2, [r4, #33]	; 0x21
   175b8:	2a00      	cmp	r2, #0
{
   175ba:	4605      	mov	r5, r0
	if (lll->role) {
   175bc:	da09      	bge.n	175d2 <prepare_cb+0x26>
		lll->slave.window_widening_prepare_us +=
		    lll->slave.window_widening_periodic_us * (lazy + 1);
   175be:	6aa2      	ldr	r2, [r4, #40]	; 0x28
		lll->slave.window_widening_prepare_us +=
   175c0:	6b21      	ldr	r1, [r4, #48]	; 0x30
		    lll->slave.window_widening_periodic_us * (lazy + 1);
   175c2:	fb03 2202 	mla	r2, r3, r2, r2
		lll->slave.window_widening_prepare_us +=
   175c6:	440a      	add	r2, r1
		if (lll->slave.window_widening_prepare_us >
		    lll->slave.window_widening_max_us) {
   175c8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
			lll->slave.window_widening_prepare_us =
   175ca:	4291      	cmp	r1, r2
   175cc:	bf94      	ite	ls
   175ce:	6321      	strls	r1, [r4, #48]	; 0x30
   175d0:	6322      	strhi	r2, [r4, #48]	; 0x30
				lll->slave.window_widening_max_us;
		}
	}

	/* save the latency for use in event */
	lll->latency_prepare += lazy;
   175d2:	8ae2      	ldrh	r2, [r4, #22]
   175d4:	4413      	add	r3, r2

	/* calc current event counter value */
	event_counter = lll->event_counter + lll->latency_prepare;
   175d6:	8b62      	ldrh	r2, [r4, #26]
	lll->latency_prepare += lazy;
   175d8:	b29b      	uxth	r3, r3
   175da:	82e3      	strh	r3, [r4, #22]
	event_counter = lll->event_counter + lll->latency_prepare;
   175dc:	4413      	add	r3, r2

	/* store the next event counter value */
	lll->event_counter = event_counter + 1;
   175de:	3301      	adds	r3, #1
   175e0:	8363      	strh	r3, [r4, #26]

	/* TODO: Do the above in ULL ?  */

	/* Reset connection event global variables */
	lll_conn_prepare_reset();
   175e2:	f7ff fcc9 	bl	16f78 <lll_conn_prepare_reset>

	/* TODO: can we do something in ULL? */
	lll->latency_event = lll->latency_prepare;
	lll->latency_prepare = 0;
   175e6:	2300      	movs	r3, #0
	lll->latency_event = lll->latency_prepare;
   175e8:	8ae2      	ldrh	r2, [r4, #22]
	lll->latency_prepare = 0;
   175ea:	82e3      	strh	r3, [r4, #22]

	if (lll->data_chan_sel) {
   175ec:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
	lll->latency_event = lll->latency_prepare;
   175f0:	8322      	strh	r2, [r4, #24]
	if (lll->data_chan_sel) {
   175f2:	0659      	lsls	r1, r3, #25
   175f4:	f104 061c 	add.w	r6, r4, #28
   175f8:	f140 808e 	bpl.w	17718 <prepare_cb+0x16c>
#if defined(CONFIG_BT_CTLR_CHAN_SEL_2)
		data_chan_use = lll_chan_sel_2(lll->event_counter - 1,
   175fc:	8b60      	ldrh	r0, [r4, #26]
   175fe:	8c61      	ldrh	r1, [r4, #34]	; 0x22
   17600:	3801      	subs	r0, #1
   17602:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   17606:	4632      	mov	r2, r6
   17608:	b280      	uxth	r0, r0
   1760a:	f7fb ff43 	bl	13494 <lll_chan_sel_2>
					       &lll->data_chan_map[0],
					       lll->data_chan_count);
	}

	/* current window widening */
	lll->slave.window_widening_event_us +=
   1760e:	e9d4 230c 	ldrd	r2, r3, [r4, #48]	; 0x30
   17612:	4413      	add	r3, r2
		lll->slave.window_widening_prepare_us;
	lll->slave.window_widening_prepare_us = 0;
	if (lll->slave.window_widening_event_us >
	    lll->slave.window_widening_max_us) {
   17614:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
		lll->slave.window_widening_event_us =
   17616:	429a      	cmp	r2, r3
   17618:	bf94      	ite	ls
   1761a:	6362      	strls	r2, [r4, #52]	; 0x34
   1761c:	6363      	strhi	r3, [r4, #52]	; 0x34
			lll->slave.window_widening_max_us;
	}

	/* current window size */
	lll->slave.window_size_event_us +=
   1761e:	e9d4 230e 	ldrd	r2, r3, [r4, #56]	; 0x38
	lll->slave.window_widening_prepare_us = 0;
   17622:	f04f 0800 	mov.w	r8, #0
	lll->slave.window_size_event_us +=
   17626:	4413      	add	r3, r2
		lll->slave.window_size_prepare_us;
	lll->slave.window_size_prepare_us = 0;
   17628:	e9c4 830e 	strd	r8, r3, [r4, #56]	; 0x38
	lll->slave.window_widening_prepare_us = 0;
   1762c:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
   17630:	4606      	mov	r6, r0

	/* Start setting up Radio h/w */
	radio_reset();
   17632:	f001 f841 	bl	186b8 <radio_reset>
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	radio_tx_power_set(lll->tx_pwr_lvl);
#else
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   17636:	4640      	mov	r0, r8
   17638:	f001 f872 	bl	18720 <radio_tx_power_set>
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */

	lll_conn_rx_pkt_set(lll);
   1763c:	4620      	mov	r0, r4
   1763e:	f7ff fcd5 	bl	16fec <lll_conn_rx_pkt_set>

	radio_aa_set(lll->access_addr);
   17642:	f104 0008 	add.w	r0, r4, #8
   17646:	f001 f889 	bl	1875c <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
			    (((u32_t)lll->crc_init[2] << 16) |
			     ((u32_t)lll->crc_init[1] << 8) |
   1764a:	7b63      	ldrb	r3, [r4, #13]
			    (((u32_t)lll->crc_init[2] << 16) |
   1764c:	7ba1      	ldrb	r1, [r4, #14]
			     ((u32_t)lll->crc_init[1] << 8) |
   1764e:	021b      	lsls	r3, r3, #8
			    (((u32_t)lll->crc_init[2] << 16) |
   17650:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
			     ((u32_t)lll->crc_init[0])));
   17654:	7b21      	ldrb	r1, [r4, #12]
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
   17656:	f240 605b 	movw	r0, #1627	; 0x65b
   1765a:	4319      	orrs	r1, r3
   1765c:	f001 f906 	bl	1886c <radio_crc_configure>

	lll_chan_set(data_chan_use);
   17660:	4630      	mov	r0, r6
   17662:	f7fc f9d5 	bl	13a10 <lll_chan_set>

	radio_isr_set(lll_conn_isr_rx, lll);
   17666:	4621      	mov	r1, r4
   17668:	483b      	ldr	r0, [pc, #236]	; (17758 <prepare_cb+0x1ac>)
   1766a:	f001 f805 	bl	18678 <radio_isr_set>

	radio_tmr_tifs_set(EVENT_IFS_US);
   1766e:	2096      	movs	r0, #150	; 0x96
   17670:	f001 f9aa 	bl	189c8 <radio_tmr_tifs_set>

#if defined(CONFIG_BT_CTLR_PHY)
	radio_switch_complete_and_tx(lll->phy_rx, 0, lll->phy_tx,
				     lll->phy_flags);
   17674:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
	radio_switch_complete_and_tx(lll->phy_rx, 0, lll->phy_tx,
   17678:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   1767c:	f3c2 03c0 	ubfx	r3, r2, #3, #1
   17680:	4641      	mov	r1, r8
   17682:	f002 0207 	and.w	r2, r2, #7
   17686:	f000 0007 	and.w	r0, r0, #7
   1768a:	f001 f919 	bl	188c0 <radio_switch_complete_and_tx>
#else /* !CONFIG_BT_CTLR_PHY */
	radio_switch_complete_and_tx(0, 0, 0, 0);
#endif /* !CONFIG_BT_CTLR_PHY */

	ticks_at_event = prepare_param->ticks_at_expire;
	evt = HDR_LLL2EVT(lll);
   1768e:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
   17690:	682e      	ldr	r6, [r5, #0]
	ticks_at_event += lll_evt_offset_get(evt);
   17692:	4638      	mov	r0, r7
   17694:	f00c ff42 	bl	2451c <lll_evt_offset_get>
   17698:	4406      	add	r6, r0

	ticks_at_start = ticks_at_event;
	ticks_at_start += HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US);

	remainder = prepare_param->remainder;
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
   1769a:	686a      	ldr	r2, [r5, #4]
   1769c:	f106 0109 	add.w	r1, r6, #9
   176a0:	4640      	mov	r0, r8
   176a2:	f001 f99d 	bl	189e0 <radio_tmr_start>
   176a6:	4681      	mov	r9, r0

	radio_tmr_aa_capture();
   176a8:	f001 fa28 	bl	18afc <radio_tmr_aa_capture>
	radio_tmr_aa_save(0);
   176ac:	4640      	mov	r0, r8
   176ae:	f001 fa3f 	bl	18b30 <radio_tmr_aa_save>

	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
   176b2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	       (lll->slave.window_widening_event_us << 1) +
   176b4:	6b60      	ldr	r0, [r4, #52]	; 0x34
	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
   176b6:	f103 0550 	add.w	r5, r3, #80	; 0x50
   176ba:	eb05 0540 	add.w	r5, r5, r0, lsl #1
	       lll->slave.window_size_event_us;

#if defined(CONFIG_BT_CTLR_PHY)
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
   176be:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   176c2:	2101      	movs	r1, #1
   176c4:	f000 0007 	and.w	r0, r0, #7
   176c8:	f00d fb29 	bl	24d1e <radio_rx_ready_delay_get>
	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
   176cc:	444d      	add	r5, r9
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
   176ce:	4405      	add	r5, r0
	hcto += addr_us_get(lll->phy_rx);
   176d0:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   176d4:	f000 0007 	and.w	r0, r0, #7
	switch (phy) {
   176d8:	2802      	cmp	r0, #2
   176da:	d028      	beq.n	1772e <prepare_cb+0x182>
		return 40;
   176dc:	2804      	cmp	r0, #4
   176de:	bf0c      	ite	eq
   176e0:	f44f 73bc 	moveq.w	r3, #376	; 0x178
   176e4:	2328      	movne	r3, #40	; 0x28
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
   176e6:	2101      	movs	r1, #1
	hcto += addr_us_get(lll->phy_rx);
   176e8:	441d      	add	r5, r3
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
   176ea:	f00d fb1a 	bl	24d22 <radio_rx_chain_delay_get>
	hcto += radio_rx_ready_delay_get(0, 0);
	hcto += addr_us_get(0);
	hcto += radio_rx_chain_delay_get(0, 0);
#endif /* !CONFIG_BT_CTLR_PHY */

	radio_tmr_hcto_configure(hcto);
   176ee:	4428      	add	r0, r5
   176f0:	f001 f9f8 	bl	18ae4 <radio_tmr_hcto_configure>
#endif /* CONFIG_BT_CTLR_CONN_RSSI */

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
	(EVENT_OVERHEAD_PREEMPT_US <= EVENT_OVERHEAD_PREEMPT_MIN_US)
	/* check if preempt to start has changed */
	if (lll_preempt_calc(evt, (TICKER_ID_CONN_BASE + lll->handle),
   176f4:	7c21      	ldrb	r1, [r4, #16]
   176f6:	3103      	adds	r1, #3
   176f8:	4632      	mov	r2, r6
   176fa:	b2c9      	uxtb	r1, r1
   176fc:	4638      	mov	r0, r7
   176fe:	f00c ff1b 	bl	24538 <lll_preempt_calc>
   17702:	b1b0      	cbz	r0, 17732 <prepare_cb+0x186>
			     ticks_at_event)) {
		radio_isr_set(lll_conn_isr_abort, lll);
   17704:	4621      	mov	r1, r4
   17706:	4815      	ldr	r0, [pc, #84]	; (1775c <prepare_cb+0x1b0>)
   17708:	f000 ffb6 	bl	18678 <radio_isr_set>
		radio_disable();
   1770c:	f001 f87c 	bl	18808 <radio_disable>
	}

	DEBUG_RADIO_START_S(1);

	return 0;
}
   17710:	2000      	movs	r0, #0
   17712:	b003      	add	sp, #12
   17714:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
   17718:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   1771c:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
   17720:	9300      	str	r3, [sp, #0]
   17722:	f104 0023 	add.w	r0, r4, #35	; 0x23
   17726:	4633      	mov	r3, r6
   17728:	f00c feb4 	bl	24494 <lll_chan_sel_1>
   1772c:	e76f      	b.n	1760e <prepare_cb+0x62>
		return 24;
   1772e:	2318      	movs	r3, #24
   17730:	e7d9      	b.n	176e6 <prepare_cb+0x13a>
		ret = lll_prepare_done(lll);
   17732:	4620      	mov	r0, r4
   17734:	f00c fef0 	bl	24518 <lll_prepare_done>
		LL_ASSERT(!ret);
   17738:	2800      	cmp	r0, #0
   1773a:	d0e9      	beq.n	17710 <prepare_cb+0x164>
   1773c:	23ff      	movs	r3, #255	; 0xff
   1773e:	4a08      	ldr	r2, [pc, #32]	; (17760 <prepare_cb+0x1b4>)
   17740:	4908      	ldr	r1, [pc, #32]	; (17764 <prepare_cb+0x1b8>)
   17742:	4809      	ldr	r0, [pc, #36]	; (17768 <prepare_cb+0x1bc>)
   17744:	f008 fb35 	bl	1fdb2 <printk>
   17748:	4040      	eors	r0, r0
   1774a:	f380 8811 	msr	BASEPRI, r0
   1774e:	f04f 0003 	mov.w	r0, #3
   17752:	df02      	svc	2
   17754:	e7dc      	b.n	17710 <prepare_cb+0x164>
   17756:	bf00      	nop
   17758:	0001712d 	.word	0x0001712d
   1775c:	00024af3 	.word	0x00024af3
   17760:	00064a15 	.word	0x00064a15
   17764:	00064330 	.word	0x00064330
   17768:	000632fe 	.word	0x000632fe

0001776c <lll_slave_prepare>:
{
   1776c:	b513      	push	{r0, r1, r4, lr}
   1776e:	4604      	mov	r4, r0
	err = lll_clk_on();
   17770:	f7fc f93e 	bl	139f0 <lll_clk_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
   17774:	b168      	cbz	r0, 17792 <lll_slave_prepare+0x26>
   17776:	3077      	adds	r0, #119	; 0x77
   17778:	d00b      	beq.n	17792 <lll_slave_prepare+0x26>
   1777a:	2345      	movs	r3, #69	; 0x45
   1777c:	4a11      	ldr	r2, [pc, #68]	; (177c4 <lll_slave_prepare+0x58>)
   1777e:	4912      	ldr	r1, [pc, #72]	; (177c8 <lll_slave_prepare+0x5c>)
   17780:	4812      	ldr	r0, [pc, #72]	; (177cc <lll_slave_prepare+0x60>)
   17782:	f008 fb16 	bl	1fdb2 <printk>
   17786:	4040      	eors	r0, r0
   17788:	f380 8811 	msr	BASEPRI, r0
   1778c:	f04f 0003 	mov.w	r0, #3
   17790:	df02      	svc	2
	err = lll_prepare(lll_conn_is_abort_cb, lll_conn_abort_cb, prepare_cb,
   17792:	9400      	str	r4, [sp, #0]
   17794:	2300      	movs	r3, #0
   17796:	4a0e      	ldr	r2, [pc, #56]	; (177d0 <lll_slave_prepare+0x64>)
   17798:	490e      	ldr	r1, [pc, #56]	; (177d4 <lll_slave_prepare+0x68>)
   1779a:	480f      	ldr	r0, [pc, #60]	; (177d8 <lll_slave_prepare+0x6c>)
   1779c:	f00c feb3 	bl	24506 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   177a0:	b168      	cbz	r0, 177be <lll_slave_prepare+0x52>
   177a2:	3077      	adds	r0, #119	; 0x77
   177a4:	d00b      	beq.n	177be <lll_slave_prepare+0x52>
   177a6:	2349      	movs	r3, #73	; 0x49
   177a8:	4a06      	ldr	r2, [pc, #24]	; (177c4 <lll_slave_prepare+0x58>)
   177aa:	4907      	ldr	r1, [pc, #28]	; (177c8 <lll_slave_prepare+0x5c>)
   177ac:	4807      	ldr	r0, [pc, #28]	; (177cc <lll_slave_prepare+0x60>)
   177ae:	f008 fb00 	bl	1fdb2 <printk>
   177b2:	4040      	eors	r0, r0
   177b4:	f380 8811 	msr	BASEPRI, r0
   177b8:	f04f 0003 	mov.w	r0, #3
   177bc:	df02      	svc	2
}
   177be:	b002      	add	sp, #8
   177c0:	bd10      	pop	{r4, pc}
   177c2:	bf00      	nop
   177c4:	00064a15 	.word	0x00064a15
   177c8:	00064627 	.word	0x00064627
   177cc:	000632fe 	.word	0x000632fe
   177d0:	000175ad 	.word	0x000175ad
   177d4:	00016f9d 	.word	0x00016f9d
   177d8:	00024aed 	.word	0x00024aed

000177dc <wl_find>:
		wl[i].taken = 0U;
	}
}

static u8_t wl_find(u8_t addr_type, u8_t *addr, u8_t *free)
{
   177dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   177e0:	4688      	mov	r8, r1
	int i;

	if (free) {
   177e2:	4615      	mov	r5, r2
   177e4:	b10a      	cbz	r2, 177ea <wl_find+0xe>
		*free = FILTER_IDX_NONE;
   177e6:	23ff      	movs	r3, #255	; 0xff
   177e8:	7013      	strb	r3, [r2, #0]
	}

	for (i = 0; i < WL_SIZE; i++) {
		if (LIST_MATCH(wl, i, addr_type, addr)) {
   177ea:	4f14      	ldr	r7, [pc, #80]	; (1783c <wl_find+0x60>)
{
   177ec:	2400      	movs	r4, #0
		if (LIST_MATCH(wl, i, addr_type, addr)) {
   177ee:	f000 0601 	and.w	r6, r0, #1
   177f2:	f817 3034 	ldrb.w	r3, [r7, r4, lsl #3]
   177f6:	07da      	lsls	r2, r3, #31
   177f8:	d51c      	bpl.n	17834 <wl_find+0x58>
   177fa:	f3c3 0340 	ubfx	r3, r3, #1, #1
   177fe:	42b3      	cmp	r3, r6
   17800:	d113      	bne.n	1782a <wl_find+0x4e>
   17802:	480f      	ldr	r0, [pc, #60]	; (17840 <wl_find+0x64>)
   17804:	2206      	movs	r2, #6
   17806:	4641      	mov	r1, r8
   17808:	eb00 00c4 	add.w	r0, r0, r4, lsl #3
   1780c:	f7ea f9e0 	bl	1bd0 <memcmp>
   17810:	b910      	cbnz	r0, 17818 <wl_find+0x3c>
			return i;
   17812:	b2e0      	uxtb	r0, r4
			*free = i;
		}
	}

	return FILTER_IDX_NONE;
}
   17814:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		} else if (free && !wl[i].taken && (*free == FILTER_IDX_NONE)) {
   17818:	b13d      	cbz	r5, 1782a <wl_find+0x4e>
   1781a:	f817 3034 	ldrb.w	r3, [r7, r4, lsl #3]
   1781e:	07db      	lsls	r3, r3, #31
   17820:	d403      	bmi.n	1782a <wl_find+0x4e>
   17822:	782b      	ldrb	r3, [r5, #0]
   17824:	2bff      	cmp	r3, #255	; 0xff
			*free = i;
   17826:	bf08      	it	eq
   17828:	702c      	strbeq	r4, [r5, #0]
	for (i = 0; i < WL_SIZE; i++) {
   1782a:	3401      	adds	r4, #1
   1782c:	2c08      	cmp	r4, #8
   1782e:	d1e0      	bne.n	177f2 <wl_find+0x16>
	return FILTER_IDX_NONE;
   17830:	20ff      	movs	r0, #255	; 0xff
   17832:	e7ef      	b.n	17814 <wl_find+0x38>
		} else if (free && !wl[i].taken && (*free == FILTER_IDX_NONE)) {
   17834:	2d00      	cmp	r5, #0
   17836:	d1f4      	bne.n	17822 <wl_find+0x46>
   17838:	e7f7      	b.n	1782a <wl_find+0x4e>
   1783a:	bf00      	nop
   1783c:	2000ab5e 	.word	0x2000ab5e
   17840:	2000ab60 	.word	0x2000ab60

00017844 <ll_wl_clear>:
{
   17844:	b508      	push	{r3, lr}
	if (ull_adv_filter_pol_get(0)) {
   17846:	2000      	movs	r0, #0
   17848:	f00c fe95 	bl	24576 <ull_adv_filter_pol_get>
   1784c:	bb58      	cbnz	r0, 178a6 <ll_wl_clear+0x62>
		wl[i].taken = 0U;
   1784e:	4b17      	ldr	r3, [pc, #92]	; (178ac <ll_wl_clear+0x68>)
   17850:	781a      	ldrb	r2, [r3, #0]
   17852:	f360 0200 	bfi	r2, r0, #0, #1
   17856:	701a      	strb	r2, [r3, #0]
   17858:	7a1a      	ldrb	r2, [r3, #8]
   1785a:	f360 0200 	bfi	r2, r0, #0, #1
   1785e:	721a      	strb	r2, [r3, #8]
   17860:	7c1a      	ldrb	r2, [r3, #16]
   17862:	f360 0200 	bfi	r2, r0, #0, #1
   17866:	741a      	strb	r2, [r3, #16]
   17868:	7e1a      	ldrb	r2, [r3, #24]
   1786a:	f360 0200 	bfi	r2, r0, #0, #1
   1786e:	761a      	strb	r2, [r3, #24]
   17870:	f893 2020 	ldrb.w	r2, [r3, #32]
   17874:	f360 0200 	bfi	r2, r0, #0, #1
   17878:	f883 2020 	strb.w	r2, [r3, #32]
   1787c:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
   17880:	f360 0200 	bfi	r2, r0, #0, #1
   17884:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
   17888:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
   1788c:	f360 0200 	bfi	r2, r0, #0, #1
   17890:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
   17894:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
   17898:	f360 0200 	bfi	r2, r0, #0, #1
   1789c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
	wl_anon = 0U;
   178a0:	4b03      	ldr	r3, [pc, #12]	; (178b0 <ll_wl_clear+0x6c>)
   178a2:	7018      	strb	r0, [r3, #0]
}
   178a4:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   178a6:	200c      	movs	r0, #12
   178a8:	e7fc      	b.n	178a4 <ll_wl_clear+0x60>
   178aa:	bf00      	nop
   178ac:	2000ab5e 	.word	0x2000ab5e
   178b0:	2000ab9e 	.word	0x2000ab9e

000178b4 <ll_wl_remove>:
{
   178b4:	b538      	push	{r3, r4, r5, lr}
   178b6:	4605      	mov	r5, r0
	if (ull_adv_filter_pol_get(0)) {
   178b8:	2000      	movs	r0, #0
   178ba:	f00c fe5c 	bl	24576 <ull_adv_filter_pol_get>
   178be:	4604      	mov	r4, r0
   178c0:	bb18      	cbnz	r0, 1790a <ll_wl_remove+0x56>
	if (addr->type == ADDR_TYPE_ANON) {
   178c2:	7828      	ldrb	r0, [r5, #0]
   178c4:	28ff      	cmp	r0, #255	; 0xff
   178c6:	d103      	bne.n	178d0 <ll_wl_remove+0x1c>
		wl_anon = 0U;
   178c8:	4b11      	ldr	r3, [pc, #68]	; (17910 <ll_wl_remove+0x5c>)
		return 0;
   178ca:	4620      	mov	r0, r4
		wl_anon = 0U;
   178cc:	701c      	strb	r4, [r3, #0]
}
   178ce:	bd38      	pop	{r3, r4, r5, pc}
}

static u32_t wl_remove(bt_addr_le_t *id_addr)
{
	/* find the device and mark it as empty */
	u8_t i = wl_find(id_addr->type, id_addr->a.val, NULL);
   178d0:	4622      	mov	r2, r4
   178d2:	1c69      	adds	r1, r5, #1
   178d4:	f7ff ff82 	bl	177dc <wl_find>

	if (i < ARRAY_SIZE(wl)) {
   178d8:	2807      	cmp	r0, #7
   178da:	d814      	bhi.n	17906 <ll_wl_remove+0x52>
		u8_t j = wl[i].rl_idx;
   178dc:	4b0d      	ldr	r3, [pc, #52]	; (17914 <ll_wl_remove+0x60>)
   178de:	eb03 02c0 	add.w	r2, r3, r0, lsl #3
   178e2:	7855      	ldrb	r5, [r2, #1]

		if (j < ARRAY_SIZE(rl)) {
   178e4:	2d07      	cmp	r5, #7
   178e6:	d806      	bhi.n	178f6 <ll_wl_remove+0x42>
			rl[j].wl = 0U;
   178e8:	2228      	movs	r2, #40	; 0x28
   178ea:	490b      	ldr	r1, [pc, #44]	; (17918 <ll_wl_remove+0x64>)
   178ec:	436a      	muls	r2, r5
   178ee:	5c8d      	ldrb	r5, [r1, r2]
   178f0:	f364 1545 	bfi	r5, r4, #5, #1
   178f4:	548d      	strb	r5, [r1, r2]
		}
		wl[i].taken = 0U;
   178f6:	f813 2030 	ldrb.w	r2, [r3, r0, lsl #3]
   178fa:	f36f 0200 	bfc	r2, #0, #1
   178fe:	f803 2030 	strb.w	r2, [r3, r0, lsl #3]
	return wl_remove(addr);
   17902:	b2e0      	uxtb	r0, r4
   17904:	e7e3      	b.n	178ce <ll_wl_remove+0x1a>
		return 0;
	}

	return BT_HCI_ERR_UNKNOWN_CONN_ID;
   17906:	2402      	movs	r4, #2
   17908:	e7fb      	b.n	17902 <ll_wl_remove+0x4e>
		return BT_HCI_ERR_CMD_DISALLOWED;
   1790a:	200c      	movs	r0, #12
   1790c:	e7df      	b.n	178ce <ll_wl_remove+0x1a>
   1790e:	bf00      	nop
   17910:	2000ab9e 	.word	0x2000ab9e
   17914:	2000ab5e 	.word	0x2000ab5e
   17918:	200015c4 	.word	0x200015c4

0001791c <ll_rl_id_addr_get>:
	LL_ASSERT(rl_idx < CONFIG_BT_CTLR_RL_SIZE);
   1791c:	2807      	cmp	r0, #7
{
   1791e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17920:	4604      	mov	r4, r0
   17922:	460f      	mov	r7, r1
   17924:	4616      	mov	r6, r2
	LL_ASSERT(rl_idx < CONFIG_BT_CTLR_RL_SIZE);
   17926:	d90b      	bls.n	17940 <ll_rl_id_addr_get+0x24>
   17928:	23ff      	movs	r3, #255	; 0xff
   1792a:	4a17      	ldr	r2, [pc, #92]	; (17988 <ll_rl_id_addr_get+0x6c>)
   1792c:	4917      	ldr	r1, [pc, #92]	; (1798c <ll_rl_id_addr_get+0x70>)
   1792e:	4818      	ldr	r0, [pc, #96]	; (17990 <ll_rl_id_addr_get+0x74>)
   17930:	f008 fa3f 	bl	1fdb2 <printk>
   17934:	4040      	eors	r0, r0
   17936:	f380 8811 	msr	BASEPRI, r0
   1793a:	f04f 0003 	mov.w	r0, #3
   1793e:	df02      	svc	2
	LL_ASSERT(rl[rl_idx].taken);
   17940:	2328      	movs	r3, #40	; 0x28
   17942:	4d14      	ldr	r5, [pc, #80]	; (17994 <ll_rl_id_addr_get+0x78>)
   17944:	4363      	muls	r3, r4
   17946:	5ceb      	ldrb	r3, [r5, r3]
   17948:	07db      	lsls	r3, r3, #31
   1794a:	d40c      	bmi.n	17966 <ll_rl_id_addr_get+0x4a>
   1794c:	f44f 7380 	mov.w	r3, #256	; 0x100
   17950:	4a0d      	ldr	r2, [pc, #52]	; (17988 <ll_rl_id_addr_get+0x6c>)
   17952:	4911      	ldr	r1, [pc, #68]	; (17998 <ll_rl_id_addr_get+0x7c>)
   17954:	480e      	ldr	r0, [pc, #56]	; (17990 <ll_rl_id_addr_get+0x74>)
   17956:	f008 fa2c 	bl	1fdb2 <printk>
   1795a:	4040      	eors	r0, r0
   1795c:	f380 8811 	msr	BASEPRI, r0
   17960:	f04f 0003 	mov.w	r0, #3
   17964:	df02      	svc	2
	*id_addr_type = rl[rl_idx].id_addr_type;
   17966:	2228      	movs	r2, #40	; 0x28
   17968:	fb02 f304 	mul.w	r3, r2, r4
	memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
   1796c:	fb02 5404 	mla	r4, r2, r4, r5
	*id_addr_type = rl[rl_idx].id_addr_type;
   17970:	5ceb      	ldrb	r3, [r5, r3]
   17972:	f3c3 1380 	ubfx	r3, r3, #6, #1
   17976:	703b      	strb	r3, [r7, #0]
   17978:	f8d4 3001 	ldr.w	r3, [r4, #1]
   1797c:	6033      	str	r3, [r6, #0]
   1797e:	f8b4 3005 	ldrh.w	r3, [r4, #5]
   17982:	80b3      	strh	r3, [r6, #4]
}
   17984:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   17986:	bf00      	nop
   17988:	00064a6c 	.word	0x00064a6c
   1798c:	00064aa7 	.word	0x00064aa7
   17990:	000632fe 	.word	0x000632fe
   17994:	200015c4 	.word	0x200015c4
   17998:	00064ab2 	.word	0x00064ab2

0001799c <ll_rl_clear>:
{
   1799c:	b508      	push	{r3, lr}
		if (!rl_enable) {
			return -1;
		}
	}

	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
   1799e:	2000      	movs	r0, #0
   179a0:	f00c fde2 	bl	24568 <ull_adv_is_enabled>
	if (!rl_access_check(false)) {
   179a4:	bb88      	cbnz	r0, 17a0a <ll_rl_clear+0x6e>
		rl[i].taken = 0U;
   179a6:	4b1a      	ldr	r3, [pc, #104]	; (17a10 <ll_rl_clear+0x74>)
   179a8:	781a      	ldrb	r2, [r3, #0]
   179aa:	f360 0200 	bfi	r2, r0, #0, #1
   179ae:	701a      	strb	r2, [r3, #0]
   179b0:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
   179b4:	f360 0200 	bfi	r2, r0, #0, #1
   179b8:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
   179bc:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
   179c0:	f360 0200 	bfi	r2, r0, #0, #1
   179c4:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
   179c8:	f893 2078 	ldrb.w	r2, [r3, #120]	; 0x78
   179cc:	f360 0200 	bfi	r2, r0, #0, #1
   179d0:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
   179d4:	f893 20a0 	ldrb.w	r2, [r3, #160]	; 0xa0
   179d8:	f360 0200 	bfi	r2, r0, #0, #1
   179dc:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0
   179e0:	f893 20c8 	ldrb.w	r2, [r3, #200]	; 0xc8
   179e4:	f360 0200 	bfi	r2, r0, #0, #1
   179e8:	f883 20c8 	strb.w	r2, [r3, #200]	; 0xc8
   179ec:	f893 20f0 	ldrb.w	r2, [r3, #240]	; 0xf0
   179f0:	f360 0200 	bfi	r2, r0, #0, #1
   179f4:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
   179f8:	f893 2118 	ldrb.w	r2, [r3, #280]	; 0x118
   179fc:	f360 0200 	bfi	r2, r0, #0, #1
   17a00:	f883 2118 	strb.w	r2, [r3, #280]	; 0x118
	peer_irk_count = 0U;
   17a04:	4b03      	ldr	r3, [pc, #12]	; (17a14 <ll_rl_clear+0x78>)
   17a06:	7018      	strb	r0, [r3, #0]
}
   17a08:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   17a0a:	200c      	movs	r0, #12
   17a0c:	e7fc      	b.n	17a08 <ll_rl_clear+0x6c>
   17a0e:	bf00      	nop
   17a10:	200015c4 	.word	0x200015c4
   17a14:	2000aaa2 	.word	0x2000aaa2

00017a18 <ll_rl_enable>:
{
   17a18:	b510      	push	{r4, lr}
   17a1a:	4604      	mov	r4, r0
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
   17a1c:	2000      	movs	r0, #0
   17a1e:	f00c fda3 	bl	24568 <ull_adv_is_enabled>
	if (!rl_access_check(false)) {
   17a22:	b960      	cbnz	r0, 17a3e <ll_rl_enable+0x26>
	switch (enable) {
   17a24:	b124      	cbz	r4, 17a30 <ll_rl_enable+0x18>
   17a26:	2c01      	cmp	r4, #1
   17a28:	d005      	beq.n	17a36 <ll_rl_enable+0x1e>
		return BT_HCI_ERR_INVALID_PARAM;
   17a2a:	2412      	movs	r4, #18
}
   17a2c:	4620      	mov	r0, r4
   17a2e:	bd10      	pop	{r4, pc}
		rl_enable = 0U;
   17a30:	4b04      	ldr	r3, [pc, #16]	; (17a44 <ll_rl_enable+0x2c>)
   17a32:	701c      	strb	r4, [r3, #0]
		break;
   17a34:	e7fa      	b.n	17a2c <ll_rl_enable+0x14>
		rl_enable = 1U;
   17a36:	4b03      	ldr	r3, [pc, #12]	; (17a44 <ll_rl_enable+0x2c>)
   17a38:	701c      	strb	r4, [r3, #0]
	return 0;
   17a3a:	4604      	mov	r4, r0
		break;
   17a3c:	e7f6      	b.n	17a2c <ll_rl_enable+0x14>
		return BT_HCI_ERR_CMD_DISALLOWED;
   17a3e:	240c      	movs	r4, #12
   17a40:	e7f4      	b.n	17a2c <ll_rl_enable+0x14>
   17a42:	bf00      	nop
   17a44:	2000ab2b 	.word	0x2000ab2b

00017a48 <ll_rl_timeout_set>:
	rpa_timeout_ms = timeout * 1000U;
   17a48:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   17a4c:	4358      	muls	r0, r3
   17a4e:	4b01      	ldr	r3, [pc, #4]	; (17a54 <ll_rl_timeout_set+0xc>)
   17a50:	6018      	str	r0, [r3, #0]
}
   17a52:	4770      	bx	lr
   17a54:	20001704 	.word	0x20001704

00017a58 <ull_filter_adv_scan_state_cb>:
	if (bm) {
   17a58:	b128      	cbz	r0, 17a66 <ull_filter_adv_scan_state_cb+0xe>
}

static void rpa_refresh_start(void)
{
	BT_DBG("");
	k_delayed_work_submit(&rpa_work, rpa_timeout_ms);
   17a5a:	4b04      	ldr	r3, [pc, #16]	; (17a6c <ull_filter_adv_scan_state_cb+0x14>)
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   17a5c:	4904      	ldr	r1, [pc, #16]	; (17a70 <ull_filter_adv_scan_state_cb+0x18>)
   17a5e:	681a      	ldr	r2, [r3, #0]
   17a60:	4804      	ldr	r0, [pc, #16]	; (17a74 <ull_filter_adv_scan_state_cb+0x1c>)
   17a62:	f007 bafd 	b.w	1f060 <k_delayed_work_submit_to_queue>
}

static void rpa_refresh_stop(void)
{
	k_delayed_work_cancel(&rpa_work);
   17a66:	4802      	ldr	r0, [pc, #8]	; (17a70 <ull_filter_adv_scan_state_cb+0x18>)
   17a68:	f010 ba55 	b.w	27f16 <k_delayed_work_cancel>
   17a6c:	20001704 	.word	0x20001704
   17a70:	20001708 	.word	0x20001708
   17a74:	20006090 	.word	0x20006090

00017a78 <ull_filter_adv_update>:
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
}

static void filter_clear(struct lll_filter *filter)
{
	filter->enable_bitmask = 0;
   17a78:	4a03      	ldr	r2, [pc, #12]	; (17a88 <ull_filter_adv_update+0x10>)
   17a7a:	2300      	movs	r3, #0
   17a7c:	7013      	strb	r3, [r2, #0]
	filter->addr_type_bitmask = 0;
   17a7e:	7053      	strb	r3, [r2, #1]
	filter->enable_bitmask = 0;
   17a80:	4a02      	ldr	r2, [pc, #8]	; (17a8c <ull_filter_adv_update+0x14>)
   17a82:	7013      	strb	r3, [r2, #0]
	filter->addr_type_bitmask = 0;
   17a84:	7053      	strb	r3, [r2, #1]
}
   17a86:	4770      	bx	lr
   17a88:	2000ab9f 	.word	0x2000ab9f
   17a8c:	2000ab2c 	.word	0x2000ab2c

00017a90 <ull_filter_adv_pdu_update>:
	if (idx < ARRAY_SIZE(rl) && rl[idx].lirk) {
   17a90:	2907      	cmp	r1, #7
{
   17a92:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   17a96:	4606      	mov	r6, r0
   17a98:	460d      	mov	r5, r1
   17a9a:	4614      	mov	r4, r2
   17a9c:	f102 0802 	add.w	r8, r2, #2
	if (idx < ARRAY_SIZE(rl) && rl[idx].lirk) {
   17aa0:	d83e      	bhi.n	17b20 <ull_filter_adv_pdu_update+0x90>
   17aa2:	2328      	movs	r3, #40	; 0x28
   17aa4:	4f2c      	ldr	r7, [pc, #176]	; (17b58 <ull_filter_adv_pdu_update+0xc8>)
   17aa6:	434b      	muls	r3, r1
   17aa8:	5cfb      	ldrb	r3, [r7, r3]
   17aaa:	071a      	lsls	r2, r3, #28
   17aac:	d538      	bpl.n	17b20 <ull_filter_adv_pdu_update+0x90>
		LL_ASSERT(rl[idx].rpas_ready);
   17aae:	079b      	lsls	r3, r3, #30
   17ab0:	d40c      	bmi.n	17acc <ull_filter_adv_pdu_update+0x3c>
   17ab2:	f44f 7318 	mov.w	r3, #608	; 0x260
   17ab6:	4a29      	ldr	r2, [pc, #164]	; (17b5c <ull_filter_adv_pdu_update+0xcc>)
   17ab8:	4929      	ldr	r1, [pc, #164]	; (17b60 <ull_filter_adv_pdu_update+0xd0>)
   17aba:	482a      	ldr	r0, [pc, #168]	; (17b64 <ull_filter_adv_pdu_update+0xd4>)
   17abc:	f008 f979 	bl	1fdb2 <printk>
   17ac0:	4040      	eors	r0, r0
   17ac2:	f380 8811 	msr	BASEPRI, r0
   17ac6:	f04f 0003 	mov.w	r0, #3
   17aca:	df02      	svc	2
		pdu->tx_addr = 1;
   17acc:	7823      	ldrb	r3, [r4, #0]
   17ace:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   17ad2:	7023      	strb	r3, [r4, #0]
		memcpy(adva, rl[idx].local_rpa->val, BDADDR_SIZE);
   17ad4:	2328      	movs	r3, #40	; 0x28
   17ad6:	fb03 7705 	mla	r7, r3, r5, r7
   17ada:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   17adc:	681a      	ldr	r2, [r3, #0]
   17ade:	f8c4 2002 	str.w	r2, [r4, #2]
   17ae2:	889b      	ldrh	r3, [r3, #4]
   17ae4:	f8a8 3004 	strh.w	r3, [r8, #4]
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   17ae8:	7823      	ldrb	r3, [r4, #0]
   17aea:	f003 020f 	and.w	r2, r3, #15
   17aee:	2a01      	cmp	r2, #1
   17af0:	d114      	bne.n	17b1c <ull_filter_adv_pdu_update+0x8c>
		if (idx < ARRAY_SIZE(rl) && rl[idx].pirk) {
   17af2:	2d07      	cmp	r5, #7
   17af4:	f104 0208 	add.w	r2, r4, #8
   17af8:	d820      	bhi.n	17b3c <ull_filter_adv_pdu_update+0xac>
   17afa:	2028      	movs	r0, #40	; 0x28
   17afc:	4916      	ldr	r1, [pc, #88]	; (17b58 <ull_filter_adv_pdu_update+0xc8>)
   17afe:	fb00 f705 	mul.w	r7, r0, r5
   17b02:	5dcf      	ldrb	r7, [r1, r7]
   17b04:	077f      	lsls	r7, r7, #29
   17b06:	d519      	bpl.n	17b3c <ull_filter_adv_pdu_update+0xac>
			pdu->rx_addr = 1;
   17b08:	f043 0380 	orr.w	r3, r3, #128	; 0x80
			memcpy(&pdu->direct_ind.tgt_addr[0],
   17b0c:	fb00 1505 	mla	r5, r0, r5, r1
			pdu->rx_addr = 1;
   17b10:	7023      	strb	r3, [r4, #0]
   17b12:	f8d5 301e 	ldr.w	r3, [r5, #30]
   17b16:	60a3      	str	r3, [r4, #8]
   17b18:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
   17b1a:	8093      	strh	r3, [r2, #4]
}
   17b1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		pdu->tx_addr = adv->own_addr_type & 0x1;
   17b20:	f896 00da 	ldrb.w	r0, [r6, #218]	; 0xda
   17b24:	7823      	ldrb	r3, [r4, #0]
   17b26:	f000 0003 	and.w	r0, r0, #3
   17b2a:	f360 1386 	bfi	r3, r0, #6, #1
   17b2e:	7023      	strb	r3, [r4, #0]
		ll_addr_get(adv->own_addr_type & 0x1, adva);
   17b30:	4641      	mov	r1, r8
   17b32:	f000 0001 	and.w	r0, r0, #1
   17b36:	f7f9 fac7 	bl	110c8 <ll_addr_get>
   17b3a:	e7d5      	b.n	17ae8 <ull_filter_adv_pdu_update+0x58>
			pdu->rx_addr = adv->id_addr_type;
   17b3c:	f896 30da 	ldrb.w	r3, [r6, #218]	; 0xda
   17b40:	7821      	ldrb	r1, [r4, #0]
   17b42:	f3c3 0380 	ubfx	r3, r3, #2, #1
   17b46:	f363 11c7 	bfi	r1, r3, #7, #1
   17b4a:	7021      	strb	r1, [r4, #0]
   17b4c:	f856 3fdc 	ldr.w	r3, [r6, #220]!
   17b50:	60a3      	str	r3, [r4, #8]
   17b52:	88b3      	ldrh	r3, [r6, #4]
   17b54:	e7e1      	b.n	17b1a <ull_filter_adv_pdu_update+0x8a>
   17b56:	bf00      	nop
   17b58:	200015c4 	.word	0x200015c4
   17b5c:	00064a6c 	.word	0x00064a6c
   17b60:	00064ad6 	.word	0x00064ad6
   17b64:	000632fe 	.word	0x000632fe

00017b68 <ull_filter_rl_find>:
{
   17b68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   17b6c:	468a      	mov	sl, r1
	if (free) {
   17b6e:	4614      	mov	r4, r2
   17b70:	b10a      	cbz	r2, 17b76 <ull_filter_rl_find+0xe>
		*free = FILTER_IDX_NONE;
   17b72:	23ff      	movs	r3, #255	; 0xff
   17b74:	7013      	strb	r3, [r2, #0]
		if (LIST_MATCH(rl, i, id_addr_type, id_addr)) {
   17b76:	f8df 9058 	ldr.w	r9, [pc, #88]	; 17bd0 <ull_filter_rl_find+0x68>
{
   17b7a:	2500      	movs	r5, #0
		if (LIST_MATCH(rl, i, id_addr_type, id_addr)) {
   17b7c:	f000 0801 	and.w	r8, r0, #1
   17b80:	2628      	movs	r6, #40	; 0x28
   17b82:	436e      	muls	r6, r5
   17b84:	b2ef      	uxtb	r7, r5
   17b86:	f819 3006 	ldrb.w	r3, [r9, r6]
   17b8a:	07da      	lsls	r2, r3, #31
   17b8c:	d51a      	bpl.n	17bc4 <ull_filter_rl_find+0x5c>
   17b8e:	f3c3 1380 	ubfx	r3, r3, #6, #1
   17b92:	4543      	cmp	r3, r8
   17b94:	d10f      	bne.n	17bb6 <ull_filter_rl_find+0x4e>
   17b96:	480d      	ldr	r0, [pc, #52]	; (17bcc <ull_filter_rl_find+0x64>)
   17b98:	2206      	movs	r2, #6
   17b9a:	4651      	mov	r1, sl
   17b9c:	4430      	add	r0, r6
   17b9e:	f7ea f817 	bl	1bd0 <memcmp>
   17ba2:	b160      	cbz	r0, 17bbe <ull_filter_rl_find+0x56>
		} else if (free && !rl[i].taken && (*free == FILTER_IDX_NONE)) {
   17ba4:	b13c      	cbz	r4, 17bb6 <ull_filter_rl_find+0x4e>
   17ba6:	f819 3006 	ldrb.w	r3, [r9, r6]
   17baa:	07db      	lsls	r3, r3, #31
   17bac:	d403      	bmi.n	17bb6 <ull_filter_rl_find+0x4e>
   17bae:	7823      	ldrb	r3, [r4, #0]
   17bb0:	2bff      	cmp	r3, #255	; 0xff
			*free = i;
   17bb2:	bf08      	it	eq
   17bb4:	7027      	strbeq	r7, [r4, #0]
   17bb6:	3501      	adds	r5, #1
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
   17bb8:	2d08      	cmp	r5, #8
   17bba:	d1e1      	bne.n	17b80 <ull_filter_rl_find+0x18>
	return FILTER_IDX_NONE;
   17bbc:	27ff      	movs	r7, #255	; 0xff
}
   17bbe:	4638      	mov	r0, r7
   17bc0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		} else if (free && !rl[i].taken && (*free == FILTER_IDX_NONE)) {
   17bc4:	2c00      	cmp	r4, #0
   17bc6:	d1f2      	bne.n	17bae <ull_filter_rl_find+0x46>
   17bc8:	e7f5      	b.n	17bb6 <ull_filter_rl_find+0x4e>
   17bca:	bf00      	nop
   17bcc:	200015c5 	.word	0x200015c5
   17bd0:	200015c4 	.word	0x200015c4

00017bd4 <ll_wl_add>:
{
   17bd4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   17bd8:	4607      	mov	r7, r0
	if (ull_adv_filter_pol_get(0)) {
   17bda:	2000      	movs	r0, #0
   17bdc:	f00c fccb 	bl	24576 <ull_adv_filter_pol_get>
   17be0:	4604      	mov	r4, r0
   17be2:	2800      	cmp	r0, #0
   17be4:	d141      	bne.n	17c6a <ll_wl_add+0x96>
	if (addr->type == ADDR_TYPE_ANON) {
   17be6:	7838      	ldrb	r0, [r7, #0]
   17be8:	28ff      	cmp	r0, #255	; 0xff
   17bea:	d106      	bne.n	17bfa <ll_wl_add+0x26>
		wl_anon = 1U;
   17bec:	4b20      	ldr	r3, [pc, #128]	; (17c70 <ll_wl_add+0x9c>)
   17bee:	2201      	movs	r2, #1
   17bf0:	701a      	strb	r2, [r3, #0]
		return 0;
   17bf2:	4620      	mov	r0, r4
}
   17bf4:	b002      	add	sp, #8
   17bf6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	i = wl_find(id_addr->type, id_addr->a.val, &j);
   17bfa:	f107 0801 	add.w	r8, r7, #1
   17bfe:	f10d 0207 	add.w	r2, sp, #7
   17c02:	4641      	mov	r1, r8
   17c04:	f7ff fdea 	bl	177dc <wl_find>
	if (i < ARRAY_SIZE(wl)) {
   17c08:	2807      	cmp	r0, #7
   17c0a:	d927      	bls.n	17c5c <ll_wl_add+0x88>
	} else if (j >= ARRAY_SIZE(wl)) {
   17c0c:	f89d 6007 	ldrb.w	r6, [sp, #7]
   17c10:	2e07      	cmp	r6, #7
   17c12:	d828      	bhi.n	17c66 <ll_wl_add+0x92>
	wl[i].id_addr_type = id_addr->type & 0x1;
   17c14:	4d17      	ldr	r5, [pc, #92]	; (17c74 <ll_wl_add+0xa0>)
   17c16:	783a      	ldrb	r2, [r7, #0]
   17c18:	f815 3036 	ldrb.w	r3, [r5, r6, lsl #3]
	bt_addr_copy(&wl[i].id_addr, &id_addr->a);
   17c1c:	eb05 00c6 	add.w	r0, r5, r6, lsl #3
	wl[i].id_addr_type = id_addr->type & 0x1;
   17c20:	f362 0341 	bfi	r3, r2, #1, #1
	bt_addr_copy(&wl[i].id_addr, &id_addr->a);
   17c24:	4641      	mov	r1, r8
   17c26:	3002      	adds	r0, #2
	wl[i].id_addr_type = id_addr->type & 0x1;
   17c28:	f805 3036 	strb.w	r3, [r5, r6, lsl #3]
	bt_addr_copy(&wl[i].id_addr, &id_addr->a);
   17c2c:	f00d f83c 	bl	24ca8 <bt_addr_copy>
	j = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   17c30:	4622      	mov	r2, r4
   17c32:	7838      	ldrb	r0, [r7, #0]
   17c34:	f7ff ff98 	bl	17b68 <ull_filter_rl_find>
	if (j < ARRAY_SIZE(rl)) {
   17c38:	00f3      	lsls	r3, r6, #3
   17c3a:	2807      	cmp	r0, #7
		wl[i].rl_idx = j;
   17c3c:	442b      	add	r3, r5
	if (j < ARRAY_SIZE(rl)) {
   17c3e:	d80f      	bhi.n	17c60 <ll_wl_add+0x8c>
		wl[i].rl_idx = j;
   17c40:	7058      	strb	r0, [r3, #1]
		rl[j].wl = 1U;
   17c42:	2328      	movs	r3, #40	; 0x28
   17c44:	4a0c      	ldr	r2, [pc, #48]	; (17c78 <ll_wl_add+0xa4>)
   17c46:	4358      	muls	r0, r3
   17c48:	5c13      	ldrb	r3, [r2, r0]
   17c4a:	f043 0320 	orr.w	r3, r3, #32
   17c4e:	5413      	strb	r3, [r2, r0]
	wl[i].taken = 1U;
   17c50:	f815 3036 	ldrb.w	r3, [r5, r6, lsl #3]
   17c54:	f043 0301 	orr.w	r3, r3, #1
   17c58:	f805 3036 	strb.w	r3, [r5, r6, lsl #3]
	return wl_add(addr);
   17c5c:	b2e0      	uxtb	r0, r4
   17c5e:	e7c9      	b.n	17bf4 <ll_wl_add+0x20>
		wl[i].rl_idx = FILTER_IDX_NONE;
   17c60:	22ff      	movs	r2, #255	; 0xff
   17c62:	705a      	strb	r2, [r3, #1]
   17c64:	e7f4      	b.n	17c50 <ll_wl_add+0x7c>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
   17c66:	2407      	movs	r4, #7
   17c68:	e7f8      	b.n	17c5c <ll_wl_add+0x88>
		return BT_HCI_ERR_CMD_DISALLOWED;
   17c6a:	200c      	movs	r0, #12
   17c6c:	e7c2      	b.n	17bf4 <ll_wl_add+0x20>
   17c6e:	bf00      	nop
   17c70:	2000ab9e 	.word	0x2000ab9e
   17c74:	2000ab5e 	.word	0x2000ab5e
   17c78:	200015c4 	.word	0x200015c4

00017c7c <ll_rl_add>:
{
   17c7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17c80:	4681      	mov	r9, r0
   17c82:	b085      	sub	sp, #20
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
   17c84:	2000      	movs	r0, #0
{
   17c86:	468a      	mov	sl, r1
   17c88:	4690      	mov	r8, r2
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
   17c8a:	f00c fc6d 	bl	24568 <ull_adv_is_enabled>
	if (!rl_access_check(false)) {
   17c8e:	2800      	cmp	r0, #0
   17c90:	f040 808a 	bne.w	17da8 <ll_rl_add+0x12c>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, &j);
   17c94:	46cb      	mov	fp, r9
   17c96:	f10d 020f 	add.w	r2, sp, #15
   17c9a:	f81b 0b01 	ldrb.w	r0, [fp], #1
   17c9e:	4659      	mov	r1, fp
   17ca0:	f7ff ff62 	bl	17b68 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
   17ca4:	2807      	cmp	r0, #7
   17ca6:	f240 8081 	bls.w	17dac <ll_rl_add+0x130>
	} else if (j >= ARRAY_SIZE(rl)) {
   17caa:	f89d 500f 	ldrb.w	r5, [sp, #15]
   17cae:	2d07      	cmp	r5, #7
   17cb0:	d87e      	bhi.n	17db0 <ll_rl_add+0x134>
	bt_addr_copy(&rl[i].id_addr, &id_addr->a);
   17cb2:	eb05 0785 	add.w	r7, r5, r5, lsl #2
   17cb6:	4c3f      	ldr	r4, [pc, #252]	; (17db4 <ll_rl_add+0x138>)
   17cb8:	00ff      	lsls	r7, r7, #3
	rl[i].id_addr_type = id_addr->type & 0x1;
   17cba:	2628      	movs	r6, #40	; 0x28
   17cbc:	436e      	muls	r6, r5
	bt_addr_copy(&rl[i].id_addr, &id_addr->a);
   17cbe:	1c78      	adds	r0, r7, #1
   17cc0:	4659      	mov	r1, fp
   17cc2:	4420      	add	r0, r4
   17cc4:	f00c fff0 	bl	24ca8 <bt_addr_copy>
	rl[i].id_addr_type = id_addr->type & 0x1;
   17cc8:	f899 1000 	ldrb.w	r1, [r9]
   17ccc:	5da3      	ldrb	r3, [r4, r6]
   17cce:	19a2      	adds	r2, r4, r6
   17cd0:	f361 1386 	bfi	r3, r1, #6, #1
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
   17cd4:	4650      	mov	r0, sl
   17cd6:	2110      	movs	r1, #16
	rl[i].id_addr_type = id_addr->type & 0x1;
   17cd8:	9201      	str	r2, [sp, #4]
   17cda:	55a3      	strb	r3, [r4, r6]
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
   17cdc:	f00c f9b0 	bl	24040 <mem_nz>
   17ce0:	5da3      	ldrb	r3, [r4, r6]
	rl[i].lirk = mem_nz((u8_t *)lirk, IRK_SIZE);
   17ce2:	2110      	movs	r1, #16
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
   17ce4:	f360 0382 	bfi	r3, r0, #2, #1
	rl[i].lirk = mem_nz((u8_t *)lirk, IRK_SIZE);
   17ce8:	4640      	mov	r0, r8
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
   17cea:	55a3      	strb	r3, [r4, r6]
	rl[i].lirk = mem_nz((u8_t *)lirk, IRK_SIZE);
   17cec:	f00c f9a8 	bl	24040 <mem_nz>
   17cf0:	5da3      	ldrb	r3, [r4, r6]
	if (rl[i].pirk) {
   17cf2:	9a01      	ldr	r2, [sp, #4]
	rl[i].lirk = mem_nz((u8_t *)lirk, IRK_SIZE);
   17cf4:	f000 0001 	and.w	r0, r0, #1
   17cf8:	f360 03c3 	bfi	r3, r0, #3, #1
	if (rl[i].pirk) {
   17cfc:	f013 0f04 	tst.w	r3, #4
	rl[i].lirk = mem_nz((u8_t *)lirk, IRK_SIZE);
   17d00:	55a3      	strb	r3, [r4, r6]
	if (rl[i].pirk) {
   17d02:	d12d      	bne.n	17d60 <ll_rl_add+0xe4>
	if (rl[i].lirk) {
   17d04:	2800      	cmp	r0, #0
   17d06:	d13f      	bne.n	17d88 <ll_rl_add+0x10c>
	memset(rl[i].curr_rpa.val, 0x00, sizeof(rl[i].curr_rpa));
   17d08:	3718      	adds	r7, #24
__ssp_bos_icheck3(memset, void *, int)
   17d0a:	f04f 0800 	mov.w	r8, #0
   17d0e:	19e3      	adds	r3, r4, r7
   17d10:	2628      	movs	r6, #40	; 0x28
   17d12:	f844 8007 	str.w	r8, [r4, r7]
   17d16:	436e      	muls	r6, r5
   17d18:	f8a3 8004 	strh.w	r8, [r3, #4]
	rl[i].rpas_ready = 0U;
   17d1c:	5da3      	ldrb	r3, [r4, r6]
   17d1e:	f023 0312 	bic.w	r3, r3, #18
   17d22:	55a3      	strb	r3, [r4, r6]
	j = wl_find(id_addr->type, id_addr->a.val, NULL);
   17d24:	4642      	mov	r2, r8
   17d26:	4659      	mov	r1, fp
   17d28:	f899 0000 	ldrb.w	r0, [r9]
   17d2c:	f7ff fd56 	bl	177dc <wl_find>
	if (j < ARRAY_SIZE(wl)) {
   17d30:	2807      	cmp	r0, #7
   17d32:	5da3      	ldrb	r3, [r4, r6]
		wl[j].rl_idx = i;
   17d34:	bf9d      	ittte	ls
   17d36:	4a20      	ldrls	r2, [pc, #128]	; (17db8 <ll_rl_add+0x13c>)
		rl[i].wl = 1U;
   17d38:	f043 0320 	orrls.w	r3, r3, #32
		wl[j].rl_idx = i;
   17d3c:	eb02 02c0 	addls.w	r2, r2, r0, lsl #3
		rl[i].wl = 0U;
   17d40:	f368 1345 	bfihi	r3, r8, #5, #1
   17d44:	55a3      	strb	r3, [r4, r6]
	rl[i].taken = 1U;
   17d46:	f04f 0328 	mov.w	r3, #40	; 0x28
		wl[j].rl_idx = i;
   17d4a:	bf98      	it	ls
   17d4c:	7055      	strbls	r5, [r2, #1]
	rl[i].taken = 1U;
   17d4e:	435d      	muls	r5, r3
	return 0;
   17d50:	2000      	movs	r0, #0
	rl[i].taken = 1U;
   17d52:	5d63      	ldrb	r3, [r4, r5]
   17d54:	f043 0301 	orr.w	r3, r3, #1
   17d58:	5563      	strb	r3, [r4, r5]
}
   17d5a:	b005      	add	sp, #20
   17d5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		rl[i].pirk_idx = peer_irk_count;
   17d60:	4b16      	ldr	r3, [pc, #88]	; (17dbc <ll_rl_add+0x140>)
   17d62:	7819      	ldrb	r1, [r3, #0]
   17d64:	75d1      	strb	r1, [r2, #23]
		peer_irk_rl_ids[peer_irk_count] = i;
   17d66:	4a16      	ldr	r2, [pc, #88]	; (17dc0 <ll_rl_add+0x144>)
   17d68:	5455      	strb	r5, [r2, r1]
		sys_memcpy_swap(peer_irks[peer_irk_count++], pirk, IRK_SIZE);
   17d6a:	1c4a      	adds	r2, r1, #1
   17d6c:	701a      	strb	r2, [r3, #0]
	for (; length > 0; length--) {
   17d6e:	4b15      	ldr	r3, [pc, #84]	; (17dc4 <ll_rl_add+0x148>)
   17d70:	eb03 1301 	add.w	r3, r3, r1, lsl #4
   17d74:	f10a 0210 	add.w	r2, sl, #16
   17d78:	3b01      	subs	r3, #1
		*pdst++ = *psrc--;
   17d7a:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
   17d7e:	f803 1f01 	strb.w	r1, [r3, #1]!
	for (; length > 0; length--) {
   17d82:	4552      	cmp	r2, sl
   17d84:	d1f9      	bne.n	17d7a <ll_rl_add+0xfe>
   17d86:	e7bd      	b.n	17d04 <ll_rl_add+0x88>
		memcpy(rl[i].local_irk, lirk, IRK_SIZE);
   17d88:	1dfb      	adds	r3, r7, #7
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   17d8a:	4423      	add	r3, r4
   17d8c:	f108 0210 	add.w	r2, r8, #16
   17d90:	f858 1b04 	ldr.w	r1, [r8], #4
   17d94:	f843 1b04 	str.w	r1, [r3], #4
   17d98:	4590      	cmp	r8, r2
   17d9a:	d1f9      	bne.n	17d90 <ll_rl_add+0x114>
		rl[i].local_rpa = NULL;
   17d9c:	2328      	movs	r3, #40	; 0x28
   17d9e:	fb03 4305 	mla	r3, r3, r5, r4
   17da2:	2200      	movs	r2, #0
   17da4:	625a      	str	r2, [r3, #36]	; 0x24
   17da6:	e7af      	b.n	17d08 <ll_rl_add+0x8c>
		return BT_HCI_ERR_CMD_DISALLOWED;
   17da8:	200c      	movs	r0, #12
   17daa:	e7d6      	b.n	17d5a <ll_rl_add+0xde>
		return BT_HCI_ERR_INVALID_PARAM;
   17dac:	2012      	movs	r0, #18
   17dae:	e7d4      	b.n	17d5a <ll_rl_add+0xde>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
   17db0:	2007      	movs	r0, #7
   17db2:	e7d2      	b.n	17d5a <ll_rl_add+0xde>
   17db4:	200015c4 	.word	0x200015c4
   17db8:	2000ab5e 	.word	0x2000ab5e
   17dbc:	2000aaa2 	.word	0x2000aaa2
   17dc0:	2000aaa3 	.word	0x2000aaa3
   17dc4:	2000aaab 	.word	0x2000aaab

00017dc8 <ll_rl_remove>:
{
   17dc8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   17dcc:	4680      	mov	r8, r0
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
   17dce:	2000      	movs	r0, #0
   17dd0:	f00c fbca 	bl	24568 <ull_adv_is_enabled>
	if (!rl_access_check(false)) {
   17dd4:	4605      	mov	r5, r0
   17dd6:	2800      	cmp	r0, #0
   17dd8:	d15c      	bne.n	17e94 <ll_rl_remove+0xcc>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   17dda:	4646      	mov	r6, r8
   17ddc:	462a      	mov	r2, r5
   17dde:	f816 0b01 	ldrb.w	r0, [r6], #1
   17de2:	4631      	mov	r1, r6
   17de4:	f7ff fec0 	bl	17b68 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
   17de8:	2807      	cmp	r0, #7
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   17dea:	4607      	mov	r7, r0
	if (i < ARRAY_SIZE(rl)) {
   17dec:	d854      	bhi.n	17e98 <ll_rl_remove+0xd0>
		if (rl[i].pirk) {
   17dee:	2328      	movs	r3, #40	; 0x28
   17df0:	4c2a      	ldr	r4, [pc, #168]	; (17e9c <ll_rl_remove+0xd4>)
   17df2:	4343      	muls	r3, r0
   17df4:	18e2      	adds	r2, r4, r3
   17df6:	5ce3      	ldrb	r3, [r4, r3]
   17df8:	075b      	lsls	r3, r3, #29
   17dfa:	d52e      	bpl.n	17e5a <ll_rl_remove+0x92>
			u8_t pi = rl[i].pirk_idx, pj = peer_irk_count - 1;
   17dfc:	4928      	ldr	r1, [pc, #160]	; (17ea0 <ll_rl_remove+0xd8>)
   17dfe:	780b      	ldrb	r3, [r1, #0]
   17e00:	3b01      	subs	r3, #1
			if (pj && pi != pj) {
   17e02:	f013 0eff 	ands.w	lr, r3, #255	; 0xff
   17e06:	d027      	beq.n	17e58 <ll_rl_remove+0x90>
			u8_t pi = rl[i].pirk_idx, pj = peer_irk_count - 1;
   17e08:	7dd0      	ldrb	r0, [r2, #23]
			if (pj && pi != pj) {
   17e0a:	4570      	cmp	r0, lr
   17e0c:	d024      	beq.n	17e58 <ll_rl_remove+0x90>
				memcpy(peer_irks[pi], peer_irks[pj], IRK_SIZE);
   17e0e:	4a25      	ldr	r2, [pc, #148]	; (17ea4 <ll_rl_remove+0xdc>)
   17e10:	eb02 1c0e 	add.w	ip, r2, lr, lsl #4
   17e14:	f10c 0910 	add.w	r9, ip, #16
   17e18:	eb02 1200 	add.w	r2, r2, r0, lsl #4
   17e1c:	f85c ab04 	ldr.w	sl, [ip], #4
   17e20:	f842 ab04 	str.w	sl, [r2], #4
   17e24:	45cc      	cmp	ip, r9
   17e26:	d1f9      	bne.n	17e1c <ll_rl_remove+0x54>
					if (rl[k].taken && rl[k].pirk &&
   17e28:	f04f 0928 	mov.w	r9, #40	; 0x28
   17e2c:	fb09 fc05 	mul.w	ip, r9, r5
   17e30:	eb04 020c 	add.w	r2, r4, ip
   17e34:	f814 c00c 	ldrb.w	ip, [r4, ip]
   17e38:	f01c 0f01 	tst.w	ip, #1
   17e3c:	fa5f fa85 	uxtb.w	sl, r5
   17e40:	d024      	beq.n	17e8c <ll_rl_remove+0xc4>
   17e42:	f01c 0f04 	tst.w	ip, #4
   17e46:	d021      	beq.n	17e8c <ll_rl_remove+0xc4>
   17e48:	f892 c017 	ldrb.w	ip, [r2, #23]
   17e4c:	45f4      	cmp	ip, lr
   17e4e:	d11d      	bne.n	17e8c <ll_rl_remove+0xc4>
						rl[k].pirk_idx = pi;
   17e50:	75d0      	strb	r0, [r2, #23]
						peer_irk_rl_ids[pi] = k;
   17e52:	4a15      	ldr	r2, [pc, #84]	; (17ea8 <ll_rl_remove+0xe0>)
   17e54:	f802 a000 	strb.w	sl, [r2, r0]
			peer_irk_count--;
   17e58:	700b      	strb	r3, [r1, #0]
		j = wl_find(id_addr->type, id_addr->a.val, NULL);
   17e5a:	2200      	movs	r2, #0
   17e5c:	4631      	mov	r1, r6
   17e5e:	f898 0000 	ldrb.w	r0, [r8]
   17e62:	f7ff fcbb 	bl	177dc <wl_find>
		if (j < ARRAY_SIZE(wl)) {
   17e66:	2807      	cmp	r0, #7
			wl[j].rl_idx = FILTER_IDX_NONE;
   17e68:	bf9c      	itt	ls
   17e6a:	4b10      	ldrls	r3, [pc, #64]	; (17eac <ll_rl_remove+0xe4>)
   17e6c:	eb03 03c0 	addls.w	r3, r3, r0, lsl #3
		rl[i].taken = 0U;
   17e70:	f04f 0028 	mov.w	r0, #40	; 0x28
   17e74:	fb00 f007 	mul.w	r0, r0, r7
			wl[j].rl_idx = FILTER_IDX_NONE;
   17e78:	bf9c      	itt	ls
   17e7a:	22ff      	movls	r2, #255	; 0xff
   17e7c:	705a      	strbls	r2, [r3, #1]
		rl[i].taken = 0U;
   17e7e:	5c23      	ldrb	r3, [r4, r0]
   17e80:	f36f 0300 	bfc	r3, #0, #1
   17e84:	5423      	strb	r3, [r4, r0]
		return 0;
   17e86:	2000      	movs	r0, #0
}
   17e88:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   17e8c:	3501      	adds	r5, #1
				for (k = 0U;
   17e8e:	2d08      	cmp	r5, #8
   17e90:	d1cc      	bne.n	17e2c <ll_rl_remove+0x64>
   17e92:	e7e1      	b.n	17e58 <ll_rl_remove+0x90>
		return BT_HCI_ERR_CMD_DISALLOWED;
   17e94:	200c      	movs	r0, #12
   17e96:	e7f7      	b.n	17e88 <ll_rl_remove+0xc0>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
   17e98:	2002      	movs	r0, #2
   17e9a:	e7f5      	b.n	17e88 <ll_rl_remove+0xc0>
   17e9c:	200015c4 	.word	0x200015c4
   17ea0:	2000aaa2 	.word	0x2000aaa2
   17ea4:	2000aaab 	.word	0x2000aaab
   17ea8:	2000aaa3 	.word	0x2000aaa3
   17eac:	2000ab5e 	.word	0x2000ab5e

00017eb0 <ll_rl_crpa_set>:
{
   17eb0:	b538      	push	{r3, r4, r5, lr}
   17eb2:	461c      	mov	r4, r3
	if ((crpa[5] & 0xc0) == 0x40) {
   17eb4:	795b      	ldrb	r3, [r3, #5]
   17eb6:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   17eba:	2b40      	cmp	r3, #64	; 0x40
   17ebc:	d115      	bne.n	17eea <ll_rl_crpa_set+0x3a>
		if (id_addr) {
   17ebe:	b119      	cbz	r1, 17ec8 <ll_rl_crpa_set+0x18>
			rl_idx = ull_filter_rl_find(id_addr_type, id_addr, NULL);
   17ec0:	2200      	movs	r2, #0
   17ec2:	f7ff fe51 	bl	17b68 <ull_filter_rl_find>
   17ec6:	4602      	mov	r2, r0
		if (rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].taken) {
   17ec8:	2a07      	cmp	r2, #7
   17eca:	d80e      	bhi.n	17eea <ll_rl_crpa_set+0x3a>
   17ecc:	2128      	movs	r1, #40	; 0x28
   17ece:	4b07      	ldr	r3, [pc, #28]	; (17eec <ll_rl_crpa_set+0x3c>)
   17ed0:	fb01 f002 	mul.w	r0, r1, r2
   17ed4:	5c18      	ldrb	r0, [r3, r0]
   17ed6:	07c0      	lsls	r0, r0, #31
   17ed8:	d507      	bpl.n	17eea <ll_rl_crpa_set+0x3a>
			memcpy(rl[rl_idx].curr_rpa.val, crpa,
   17eda:	2018      	movs	r0, #24
   17edc:	fb11 0202 	smlabb	r2, r1, r2, r0
   17ee0:	6820      	ldr	r0, [r4, #0]
   17ee2:	5098      	str	r0, [r3, r2]
   17ee4:	1899      	adds	r1, r3, r2
   17ee6:	88a3      	ldrh	r3, [r4, #4]
   17ee8:	808b      	strh	r3, [r1, #4]
}
   17eea:	bd38      	pop	{r3, r4, r5, pc}
   17eec:	200015c4 	.word	0x200015c4

00017ef0 <ll_rl_crpa_get>:
{
   17ef0:	b538      	push	{r3, r4, r5, lr}
   17ef2:	460d      	mov	r5, r1
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   17ef4:	4601      	mov	r1, r0
   17ef6:	2200      	movs	r2, #0
   17ef8:	f811 0b01 	ldrb.w	r0, [r1], #1
   17efc:	f7ff fe34 	bl	17b68 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl) &&
   17f00:	2807      	cmp	r0, #7
   17f02:	d901      	bls.n	17f08 <ll_rl_crpa_get+0x18>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
   17f04:	2002      	movs	r0, #2
}
   17f06:	bd38      	pop	{r3, r4, r5, pc}
	    mem_nz(rl[i].curr_rpa.val, sizeof(rl[i].curr_rpa.val))) {
   17f08:	2428      	movs	r4, #40	; 0x28
   17f0a:	2318      	movs	r3, #24
   17f0c:	fb14 3000 	smlabb	r0, r4, r0, r3
   17f10:	4c06      	ldr	r4, [pc, #24]	; (17f2c <ll_rl_crpa_get+0x3c>)
   17f12:	4404      	add	r4, r0
   17f14:	2106      	movs	r1, #6
   17f16:	4620      	mov	r0, r4
   17f18:	f00c f892 	bl	24040 <mem_nz>
	if (i < ARRAY_SIZE(rl) &&
   17f1c:	2800      	cmp	r0, #0
   17f1e:	d0f1      	beq.n	17f04 <ll_rl_crpa_get+0x14>
		bt_addr_copy(crpa, &rl[i].curr_rpa);
   17f20:	4628      	mov	r0, r5
   17f22:	4621      	mov	r1, r4
   17f24:	f00c fec0 	bl	24ca8 <bt_addr_copy>
		return 0;
   17f28:	2000      	movs	r0, #0
   17f2a:	e7ec      	b.n	17f06 <ll_rl_crpa_get+0x16>
   17f2c:	200015c4 	.word	0x200015c4

00017f30 <ll_rl_lrpa_get>:
{
   17f30:	b510      	push	{r4, lr}
   17f32:	460c      	mov	r4, r1
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   17f34:	4601      	mov	r1, r0
   17f36:	2200      	movs	r2, #0
   17f38:	f811 0b01 	ldrb.w	r0, [r1], #1
   17f3c:	f7ff fe14 	bl	17b68 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
   17f40:	2807      	cmp	r0, #7
   17f42:	d809      	bhi.n	17f58 <ll_rl_lrpa_get+0x28>
		bt_addr_copy(lrpa, rl[i].local_rpa);
   17f44:	4b05      	ldr	r3, [pc, #20]	; (17f5c <ll_rl_lrpa_get+0x2c>)
   17f46:	2228      	movs	r2, #40	; 0x28
   17f48:	fb02 3000 	mla	r0, r2, r0, r3
   17f4c:	6a41      	ldr	r1, [r0, #36]	; 0x24
   17f4e:	4620      	mov	r0, r4
   17f50:	f00c feaa 	bl	24ca8 <bt_addr_copy>
		return 0;
   17f54:	2000      	movs	r0, #0
}
   17f56:	bd10      	pop	{r4, pc}
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
   17f58:	2002      	movs	r0, #2
   17f5a:	e7fc      	b.n	17f56 <ll_rl_lrpa_get+0x26>
   17f5c:	200015c4 	.word	0x200015c4

00017f60 <ll_priv_mode_set>:
{
   17f60:	b570      	push	{r4, r5, r6, lr}
   17f62:	4605      	mov	r5, r0
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
   17f64:	2000      	movs	r0, #0
{
   17f66:	460c      	mov	r4, r1
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
   17f68:	f00c fafe 	bl	24568 <ull_adv_is_enabled>
	if (!rl_access_check(false)) {
   17f6c:	4606      	mov	r6, r0
   17f6e:	b9f0      	cbnz	r0, 17fae <ll_priv_mode_set+0x4e>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   17f70:	4629      	mov	r1, r5
   17f72:	4632      	mov	r2, r6
   17f74:	f811 0b01 	ldrb.w	r0, [r1], #1
   17f78:	f7ff fdf6 	bl	17b68 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
   17f7c:	2807      	cmp	r0, #7
   17f7e:	d818      	bhi.n	17fb2 <ll_priv_mode_set+0x52>
		switch (mode) {
   17f80:	b124      	cbz	r4, 17f8c <ll_priv_mode_set+0x2c>
   17f82:	2c01      	cmp	r4, #1
   17f84:	d00a      	beq.n	17f9c <ll_priv_mode_set+0x3c>
			return BT_HCI_ERR_INVALID_PARAM;
   17f86:	2412      	movs	r4, #18
}
   17f88:	4620      	mov	r0, r4
   17f8a:	bd70      	pop	{r4, r5, r6, pc}
			rl[i].dev = 0U;
   17f8c:	2328      	movs	r3, #40	; 0x28
   17f8e:	4a0a      	ldr	r2, [pc, #40]	; (17fb8 <ll_priv_mode_set+0x58>)
   17f90:	4358      	muls	r0, r3
   17f92:	5c13      	ldrb	r3, [r2, r0]
   17f94:	f364 1304 	bfi	r3, r4, #4, #1
   17f98:	5413      	strb	r3, [r2, r0]
			break;
   17f9a:	e7f5      	b.n	17f88 <ll_priv_mode_set+0x28>
			rl[i].dev = 1U;
   17f9c:	2328      	movs	r3, #40	; 0x28
   17f9e:	4a06      	ldr	r2, [pc, #24]	; (17fb8 <ll_priv_mode_set+0x58>)
   17fa0:	4358      	muls	r0, r3
	return 0;
   17fa2:	4634      	mov	r4, r6
			rl[i].dev = 1U;
   17fa4:	5c13      	ldrb	r3, [r2, r0]
   17fa6:	f043 0310 	orr.w	r3, r3, #16
   17faa:	5413      	strb	r3, [r2, r0]
			break;
   17fac:	e7ec      	b.n	17f88 <ll_priv_mode_set+0x28>
		return BT_HCI_ERR_CMD_DISALLOWED;
   17fae:	240c      	movs	r4, #12
   17fb0:	e7ea      	b.n	17f88 <ll_priv_mode_set+0x28>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   17fb2:	2402      	movs	r4, #2
   17fb4:	e7e8      	b.n	17f88 <ll_priv_mode_set+0x28>
   17fb6:	bf00      	nop
   17fb8:	200015c4 	.word	0x200015c4

00017fbc <ull_filter_rpa_update>:
{
   17fbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17fc0:	b087      	sub	sp, #28
   17fc2:	9001      	str	r0, [sp, #4]
	return z_impl_k_uptime_get();
   17fc4:	f010 f800 	bl	27fc8 <z_impl_k_uptime_get>
	bool all = timeout || (rpa_last_ms == -1) ||
   17fc8:	9b01      	ldr	r3, [sp, #4]
   17fca:	4680      	mov	r8, r0
   17fcc:	468a      	mov	sl, r1
   17fce:	2b00      	cmp	r3, #0
   17fd0:	f040 80d3 	bne.w	1817a <ull_filter_rpa_update+0x1be>
   17fd4:	4b6a      	ldr	r3, [pc, #424]	; (18180 <ull_filter_rpa_update+0x1c4>)
   17fd6:	e9d3 2300 	ldrd	r2, r3, [r3]
   17fda:	1c59      	adds	r1, r3, #1
   17fdc:	bf08      	it	eq
   17fde:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
   17fe2:	f000 80ca 	beq.w	1817a <ull_filter_rpa_update+0x1be>
		   (now - rpa_last_ms >= rpa_timeout_ms);
   17fe6:	ebb8 0402 	subs.w	r4, r8, r2
   17fea:	eb6a 0503 	sbc.w	r5, sl, r3
   17fee:	4b65      	ldr	r3, [pc, #404]	; (18184 <ull_filter_rpa_update+0x1c8>)
   17ff0:	681a      	ldr	r2, [r3, #0]
   17ff2:	2300      	movs	r3, #0
	bool all = timeout || (rpa_last_ms == -1) ||
   17ff4:	4294      	cmp	r4, r2
   17ff6:	eb75 0303 	sbcs.w	r3, r5, r3
   17ffa:	bfac      	ite	ge
   17ffc:	2701      	movge	r7, #1
   17ffe:	2700      	movlt	r7, #0
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
   18000:	4d61      	ldr	r5, [pc, #388]	; (18188 <ull_filter_rpa_update+0x1cc>)
				LL_ASSERT(!err);
   18002:	f8df 9194 	ldr.w	r9, [pc, #404]	; 18198 <ull_filter_rpa_update+0x1dc>
   18006:	f8df b194 	ldr.w	fp, [pc, #404]	; 1819c <ull_filter_rpa_update+0x1e0>
	bool all = timeout || (rpa_last_ms == -1) ||
   1800a:	2400      	movs	r4, #0
   1800c:	462e      	mov	r6, r5
		if ((rl[i].taken) && (all || !rl[i].rpas_ready)) {
   1800e:	2328      	movs	r3, #40	; 0x28
   18010:	4363      	muls	r3, r4
   18012:	5cf3      	ldrb	r3, [r6, r3]
   18014:	07da      	lsls	r2, r3, #31
   18016:	d54f      	bpl.n	180b8 <ull_filter_rpa_update+0xfc>
   18018:	b90f      	cbnz	r7, 1801e <ull_filter_rpa_update+0x62>
   1801a:	0798      	lsls	r0, r3, #30
   1801c:	d44c      	bmi.n	180b8 <ull_filter_rpa_update+0xfc>
			if (rl[i].pirk) {
   1801e:	2328      	movs	r3, #40	; 0x28
   18020:	4363      	muls	r3, r4
   18022:	5cf3      	ldrb	r3, [r6, r3]
   18024:	0759      	lsls	r1, r3, #29
   18026:	d51f      	bpl.n	18068 <ull_filter_rpa_update+0xac>
				sys_memcpy_swap(irk, peer_irks[rl[i].pirk_idx],
   18028:	7dea      	ldrb	r2, [r5, #23]
   1802a:	4b58      	ldr	r3, [pc, #352]	; (1818c <ull_filter_rpa_update+0x1d0>)
   1802c:	a902      	add	r1, sp, #8
   1802e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   18032:	f103 0210 	add.w	r2, r3, #16
   18036:	4608      	mov	r0, r1
		*pdst++ = *psrc--;
   18038:	f812 cd01 	ldrb.w	ip, [r2, #-1]!
   1803c:	f801 cb01 	strb.w	ip, [r1], #1
	for (; length > 0; length--) {
   18040:	429a      	cmp	r2, r3
   18042:	d1f9      	bne.n	18038 <ull_filter_rpa_update+0x7c>
				err = bt_rpa_create(irk, &rl[i].peer_rpa);
   18044:	f105 011e 	add.w	r1, r5, #30
   18048:	f00a f8fa 	bl	22240 <bt_rpa_create>
				LL_ASSERT(!err);
   1804c:	b160      	cbz	r0, 18068 <ull_filter_rpa_update+0xac>
   1804e:	f240 232a 	movw	r3, #554	; 0x22a
   18052:	464a      	mov	r2, r9
   18054:	4659      	mov	r1, fp
   18056:	484e      	ldr	r0, [pc, #312]	; (18190 <ull_filter_rpa_update+0x1d4>)
   18058:	f007 feab 	bl	1fdb2 <printk>
   1805c:	4040      	eors	r0, r0
   1805e:	f380 8811 	msr	BASEPRI, r0
   18062:	f04f 0003 	mov.w	r0, #3
   18066:	df02      	svc	2
			if (rl[i].lirk) {
   18068:	2328      	movs	r3, #40	; 0x28
   1806a:	4363      	muls	r3, r4
   1806c:	5cf3      	ldrb	r3, [r6, r3]
   1806e:	071a      	lsls	r2, r3, #28
   18070:	d51c      	bpl.n	180ac <ull_filter_rpa_update+0xf0>
				err = bt_rpa_create(rl[i].local_irk, &rpa);
   18072:	a902      	add	r1, sp, #8
   18074:	1de8      	adds	r0, r5, #7
   18076:	f00a f8e3 	bl	22240 <bt_rpa_create>
				LL_ASSERT(!err);
   1807a:	b160      	cbz	r0, 18096 <ull_filter_rpa_update+0xda>
   1807c:	f240 2337 	movw	r3, #567	; 0x237
   18080:	464a      	mov	r2, r9
   18082:	4659      	mov	r1, fp
   18084:	4842      	ldr	r0, [pc, #264]	; (18190 <ull_filter_rpa_update+0x1d4>)
   18086:	f007 fe94 	bl	1fdb2 <printk>
   1808a:	4040      	eors	r0, r0
   1808c:	f380 8811 	msr	BASEPRI, r0
   18090:	f04f 0003 	mov.w	r0, #3
   18094:	df02      	svc	2
				rl[i].local_rpa = &rpa;
   18096:	ab02      	add	r3, sp, #8
   18098:	626b      	str	r3, [r5, #36]	; 0x24
				bt_addr_copy(&local_rpas[i], &rpa);
   1809a:	4b3e      	ldr	r3, [pc, #248]	; (18194 <ull_filter_rpa_update+0x1d8>)
   1809c:	2206      	movs	r2, #6
   1809e:	fb02 3204 	mla	r2, r2, r4, r3
   180a2:	a902      	add	r1, sp, #8
   180a4:	4610      	mov	r0, r2
   180a6:	f00c fdff 	bl	24ca8 <bt_addr_copy>
				rl[i].local_rpa = &local_rpas[i];
   180aa:	626a      	str	r2, [r5, #36]	; 0x24
			rl[i].rpas_ready = 1U;
   180ac:	2328      	movs	r3, #40	; 0x28
   180ae:	4363      	muls	r3, r4
   180b0:	5cf2      	ldrb	r2, [r6, r3]
   180b2:	f042 0202 	orr.w	r2, r2, #2
   180b6:	54f2      	strb	r2, [r6, r3]
   180b8:	3401      	adds	r4, #1
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
   180ba:	2c08      	cmp	r4, #8
   180bc:	f105 0528 	add.w	r5, r5, #40	; 0x28
   180c0:	d1a5      	bne.n	1800e <ull_filter_rpa_update+0x52>
	if (all) {
   180c2:	b117      	cbz	r7, 180ca <ull_filter_rpa_update+0x10e>
		rpa_last_ms = now;
   180c4:	4b2e      	ldr	r3, [pc, #184]	; (18180 <ull_filter_rpa_update+0x1c4>)
   180c6:	e9c3 8a00 	strd	r8, sl, [r3]
	if (timeout) {
   180ca:	9b01      	ldr	r3, [sp, #4]
   180cc:	2b00      	cmp	r3, #0
   180ce:	d051      	beq.n	18174 <ull_filter_rpa_update+0x1b8>
		adv = ull_adv_is_enabled_get(0);
   180d0:	2000      	movs	r0, #0
   180d2:	f7fb ffc3 	bl	1405c <ull_adv_is_enabled_get>
		if (adv) {
   180d6:	4605      	mov	r5, r0
   180d8:	2800      	cmp	r0, #0
   180da:	d04b      	beq.n	18174 <ull_filter_rpa_update+0x1b8>
	if (adv->own_addr_type != BT_ADDR_LE_PUBLIC_ID &&
   180dc:	f890 00da 	ldrb.w	r0, [r0, #218]	; 0xda
   180e0:	0783      	lsls	r3, r0, #30
   180e2:	d547      	bpl.n	18174 <ull_filter_rpa_update+0x1b8>
	rl_idx = ull_filter_rl_find(adv->id_addr_type, adv->id_addr, NULL);
   180e4:	f105 01dc 	add.w	r1, r5, #220	; 0xdc
   180e8:	2200      	movs	r2, #0
   180ea:	f3c0 0080 	ubfx	r0, r0, #2, #1
   180ee:	f7ff fd3b 	bl	17b68 <ull_filter_rl_find>
	if (rl_idx >= ARRAY_SIZE(rl)) {
   180f2:	2807      	cmp	r0, #7
	rl_idx = ull_filter_rl_find(adv->id_addr_type, adv->id_addr, NULL);
   180f4:	4601      	mov	r1, r0
	if (rl_idx >= ARRAY_SIZE(rl)) {
   180f6:	d83d      	bhi.n	18174 <ull_filter_rpa_update+0x1b8>
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   180f8:	f895 402c 	ldrb.w	r4, [r5, #44]	; 0x2c
   180fc:	2311      	movs	r3, #17
   180fe:	2627      	movs	r6, #39	; 0x27
   18100:	fb16 3604 	smlabb	r6, r6, r4, r3
	if (pdu->first == pdu->last) {
   18104:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   18108:	f105 0c1c 	add.w	ip, r5, #28
	if (pdu->first == pdu->last) {
   1810c:	42a3      	cmp	r3, r4
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   1810e:	eb0c 0906 	add.w	r9, ip, r6
	if (pdu->first == pdu->last) {
   18112:	d104      	bne.n	1811e <ull_filter_rpa_update+0x162>
		last = pdu->last + 1;
   18114:	3401      	adds	r4, #1
   18116:	b2e4      	uxtb	r4, r4
			last = 0U;
   18118:	2c02      	cmp	r4, #2
   1811a:	bf08      	it	eq
   1811c:	2400      	moveq	r4, #0
	return (void *)pdu->pdu[last];
   1811e:	2027      	movs	r0, #39	; 0x27
   18120:	2302      	movs	r3, #2
   18122:	fb10 3304 	smlabb	r3, r0, r4, r3
   18126:	f105 022b 	add.w	r2, r5, #43	; 0x2b
	pdu->type = prev->type;
   1812a:	f81c 0006 	ldrb.w	r0, [ip, r6]
   1812e:	5cd7      	ldrb	r7, [r2, r3]
   18130:	f360 0703 	bfi	r7, r0, #0, #4
	pdu->rfu = 0;
   18134:	f36f 1704 	bfc	r7, #4, #1
   18138:	54d7      	strb	r7, [r2, r3]
		pdu->chan_sel = prev->chan_sel;
   1813a:	f81c 6006 	ldrb.w	r6, [ip, r6]
   1813e:	b2f8      	uxtb	r0, r7
   18140:	f3c6 1640 	ubfx	r6, r6, #5, #1
   18144:	eb02 0803 	add.w	r8, r2, r3
   18148:	f366 1045 	bfi	r0, r6, #5, #1
   1814c:	54d0      	strb	r0, [r2, r3]
	ull_filter_adv_pdu_update(adv, rl_idx, pdu);
   1814e:	4642      	mov	r2, r8
   18150:	4628      	mov	r0, r5
   18152:	f7ff fc9d 	bl	17a90 <ull_filter_adv_pdu_update>
	memcpy(&pdu->adv_ind.data[0], &prev->adv_ind.data[0],
   18156:	f899 2001 	ldrb.w	r2, [r9, #1]
   1815a:	f109 0108 	add.w	r1, r9, #8
   1815e:	3a06      	subs	r2, #6
   18160:	f108 0008 	add.w	r0, r8, #8
   18164:	f7e9 fd42 	bl	1bec <memcpy>
	pdu->len = prev->len;
   18168:	f899 3001 	ldrb.w	r3, [r9, #1]
   1816c:	f888 3001 	strb.w	r3, [r8, #1]
	pdu->last = idx;
   18170:	f885 402c 	strb.w	r4, [r5, #44]	; 0x2c
}
   18174:	b007      	add	sp, #28
   18176:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	bool all = timeout || (rpa_last_ms == -1) ||
   1817a:	2701      	movs	r7, #1
   1817c:	e740      	b.n	18000 <ull_filter_rpa_update+0x44>
   1817e:	bf00      	nop
   18180:	20000010 	.word	0x20000010
   18184:	20001704 	.word	0x20001704
   18188:	200015c4 	.word	0x200015c4
   1818c:	2000aaab 	.word	0x2000aaab
   18190:	000632fe 	.word	0x000632fe
   18194:	2000aa72 	.word	0x2000aa72
   18198:	00064a6c 	.word	0x00064a6c
   1819c:	00064426 	.word	0x00064426

000181a0 <rpa_timeout>:
{
   181a0:	b508      	push	{r3, lr}
	ull_filter_rpa_update(true);
   181a2:	2001      	movs	r0, #1
   181a4:	f7ff ff0a 	bl	17fbc <ull_filter_rpa_update>
   181a8:	4b03      	ldr	r3, [pc, #12]	; (181b8 <rpa_timeout+0x18>)
   181aa:	4904      	ldr	r1, [pc, #16]	; (181bc <rpa_timeout+0x1c>)
   181ac:	681a      	ldr	r2, [r3, #0]
   181ae:	4804      	ldr	r0, [pc, #16]	; (181c0 <rpa_timeout+0x20>)
}
   181b0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   181b4:	f006 bf54 	b.w	1f060 <k_delayed_work_submit_to_queue>
   181b8:	20001704 	.word	0x20001704
   181bc:	20001708 	.word	0x20001708
   181c0:	20006090 	.word	0x20006090

000181c4 <ull_filter_reset>:
	wl_anon = 0U;
   181c4:	4a39      	ldr	r2, [pc, #228]	; (182ac <ull_filter_reset+0xe8>)
   181c6:	2300      	movs	r3, #0
{
   181c8:	b430      	push	{r4, r5}
	wl_anon = 0U;
   181ca:	7013      	strb	r3, [r2, #0]
		wl[i].taken = 0U;
   181cc:	4a38      	ldr	r2, [pc, #224]	; (182b0 <ull_filter_reset+0xec>)
   181ce:	7811      	ldrb	r1, [r2, #0]
   181d0:	f363 0100 	bfi	r1, r3, #0, #1
   181d4:	7011      	strb	r1, [r2, #0]
   181d6:	7a11      	ldrb	r1, [r2, #8]
   181d8:	f363 0100 	bfi	r1, r3, #0, #1
   181dc:	7211      	strb	r1, [r2, #8]
   181de:	7c11      	ldrb	r1, [r2, #16]
   181e0:	f363 0100 	bfi	r1, r3, #0, #1
   181e4:	7411      	strb	r1, [r2, #16]
   181e6:	7e11      	ldrb	r1, [r2, #24]
   181e8:	f363 0100 	bfi	r1, r3, #0, #1
   181ec:	7611      	strb	r1, [r2, #24]
   181ee:	f892 1020 	ldrb.w	r1, [r2, #32]
   181f2:	f363 0100 	bfi	r1, r3, #0, #1
   181f6:	f882 1020 	strb.w	r1, [r2, #32]
   181fa:	f892 1028 	ldrb.w	r1, [r2, #40]	; 0x28
   181fe:	f363 0100 	bfi	r1, r3, #0, #1
   18202:	f882 1028 	strb.w	r1, [r2, #40]	; 0x28
   18206:	f892 1030 	ldrb.w	r1, [r2, #48]	; 0x30
   1820a:	f363 0100 	bfi	r1, r3, #0, #1
   1820e:	f882 1030 	strb.w	r1, [r2, #48]	; 0x30
   18212:	f892 1038 	ldrb.w	r1, [r2, #56]	; 0x38
   18216:	f363 0100 	bfi	r1, r3, #0, #1
   1821a:	f882 1038 	strb.w	r1, [r2, #56]	; 0x38
	rl_enable = 0U;
   1821e:	4a25      	ldr	r2, [pc, #148]	; (182b4 <ull_filter_reset+0xf0>)
	rpa_timeout_ms = DEFAULT_RPA_TIMEOUT_MS;
   18220:	4925      	ldr	r1, [pc, #148]	; (182b8 <ull_filter_reset+0xf4>)
	rl_enable = 0U;
   18222:	7013      	strb	r3, [r2, #0]
	rpa_timeout_ms = DEFAULT_RPA_TIMEOUT_MS;
   18224:	4a25      	ldr	r2, [pc, #148]	; (182bc <ull_filter_reset+0xf8>)
   18226:	6011      	str	r1, [r2, #0]
	rpa_last_ms = -1;
   18228:	4a25      	ldr	r2, [pc, #148]	; (182c0 <ull_filter_reset+0xfc>)
   1822a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1822e:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   18232:	e9c2 4500 	strd	r4, r5, [r2]
		rl[i].taken = 0U;
   18236:	4a23      	ldr	r2, [pc, #140]	; (182c4 <ull_filter_reset+0x100>)
   18238:	7811      	ldrb	r1, [r2, #0]
   1823a:	f363 0100 	bfi	r1, r3, #0, #1
   1823e:	7011      	strb	r1, [r2, #0]
   18240:	f892 1028 	ldrb.w	r1, [r2, #40]	; 0x28
   18244:	f363 0100 	bfi	r1, r3, #0, #1
   18248:	f882 1028 	strb.w	r1, [r2, #40]	; 0x28
   1824c:	f892 1050 	ldrb.w	r1, [r2, #80]	; 0x50
   18250:	f363 0100 	bfi	r1, r3, #0, #1
   18254:	f882 1050 	strb.w	r1, [r2, #80]	; 0x50
   18258:	f892 1078 	ldrb.w	r1, [r2, #120]	; 0x78
   1825c:	f363 0100 	bfi	r1, r3, #0, #1
   18260:	f882 1078 	strb.w	r1, [r2, #120]	; 0x78
   18264:	f892 10a0 	ldrb.w	r1, [r2, #160]	; 0xa0
   18268:	f363 0100 	bfi	r1, r3, #0, #1
   1826c:	f882 10a0 	strb.w	r1, [r2, #160]	; 0xa0
   18270:	f892 10c8 	ldrb.w	r1, [r2, #200]	; 0xc8
   18274:	f363 0100 	bfi	r1, r3, #0, #1
   18278:	f882 10c8 	strb.w	r1, [r2, #200]	; 0xc8
   1827c:	f892 10f0 	ldrb.w	r1, [r2, #240]	; 0xf0
   18280:	f363 0100 	bfi	r1, r3, #0, #1
   18284:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
   18288:	f892 1118 	ldrb.w	r1, [r2, #280]	; 0x118
   1828c:	f363 0100 	bfi	r1, r3, #0, #1
   18290:	f882 1118 	strb.w	r1, [r2, #280]	; 0x118
	peer_irk_count = 0U;
   18294:	4a0c      	ldr	r2, [pc, #48]	; (182c8 <ull_filter_reset+0x104>)
   18296:	7013      	strb	r3, [r2, #0]
	if (init) {
   18298:	b120      	cbz	r0, 182a4 <ull_filter_reset+0xe0>
		k_delayed_work_init(&rpa_work, rpa_timeout);
   1829a:	490c      	ldr	r1, [pc, #48]	; (182cc <ull_filter_reset+0x108>)
   1829c:	480c      	ldr	r0, [pc, #48]	; (182d0 <ull_filter_reset+0x10c>)
}
   1829e:	bc30      	pop	{r4, r5}
		k_delayed_work_init(&rpa_work, rpa_timeout);
   182a0:	f00f be31 	b.w	27f06 <k_delayed_work_init>
		k_delayed_work_cancel(&rpa_work);
   182a4:	480a      	ldr	r0, [pc, #40]	; (182d0 <ull_filter_reset+0x10c>)
}
   182a6:	bc30      	pop	{r4, r5}
		k_delayed_work_cancel(&rpa_work);
   182a8:	f00f be35 	b.w	27f16 <k_delayed_work_cancel>
   182ac:	2000ab9e 	.word	0x2000ab9e
   182b0:	2000ab5e 	.word	0x2000ab5e
   182b4:	2000ab2b 	.word	0x2000ab2b
   182b8:	000dbba0 	.word	0x000dbba0
   182bc:	20001704 	.word	0x20001704
   182c0:	20000010 	.word	0x20000010
   182c4:	200015c4 	.word	0x200015c4
   182c8:	2000aaa2 	.word	0x2000aaa2
   182cc:	000181a1 	.word	0x000181a1
   182d0:	20001708 	.word	0x20001708

000182d4 <ull_filter_lll_irks_get>:
	*count = peer_irk_count;
   182d4:	4b02      	ldr	r3, [pc, #8]	; (182e0 <ull_filter_lll_irks_get+0xc>)
   182d6:	781b      	ldrb	r3, [r3, #0]
   182d8:	7003      	strb	r3, [r0, #0]
}
   182da:	4802      	ldr	r0, [pc, #8]	; (182e4 <ull_filter_lll_irks_get+0x10>)
   182dc:	4770      	bx	lr
   182de:	bf00      	nop
   182e0:	2000aaa2 	.word	0x2000aaa2
   182e4:	2000aaab 	.word	0x2000aaab

000182e8 <ull_filter_lll_rl_irk_idx>:
{
   182e8:	b510      	push	{r4, lr}
	LL_ASSERT(irkmatch_id < peer_irk_count);
   182ea:	4b1c      	ldr	r3, [pc, #112]	; (1835c <ull_filter_lll_rl_irk_idx+0x74>)
   182ec:	781b      	ldrb	r3, [r3, #0]
   182ee:	4283      	cmp	r3, r0
{
   182f0:	4604      	mov	r4, r0
	LL_ASSERT(irkmatch_id < peer_irk_count);
   182f2:	d80c      	bhi.n	1830e <ull_filter_lll_rl_irk_idx+0x26>
   182f4:	f240 23cd 	movw	r3, #717	; 0x2cd
   182f8:	4a19      	ldr	r2, [pc, #100]	; (18360 <ull_filter_lll_rl_irk_idx+0x78>)
   182fa:	491a      	ldr	r1, [pc, #104]	; (18364 <ull_filter_lll_rl_irk_idx+0x7c>)
   182fc:	481a      	ldr	r0, [pc, #104]	; (18368 <ull_filter_lll_rl_irk_idx+0x80>)
   182fe:	f007 fd58 	bl	1fdb2 <printk>
   18302:	4040      	eors	r0, r0
   18304:	f380 8811 	msr	BASEPRI, r0
   18308:	f04f 0003 	mov.w	r0, #3
   1830c:	df02      	svc	2
	i = peer_irk_rl_ids[irkmatch_id];
   1830e:	4b17      	ldr	r3, [pc, #92]	; (1836c <ull_filter_lll_rl_irk_idx+0x84>)
   18310:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(i < CONFIG_BT_CTLR_RL_SIZE);
   18312:	2c07      	cmp	r4, #7
   18314:	d90c      	bls.n	18330 <ull_filter_lll_rl_irk_idx+0x48>
   18316:	f240 23cf 	movw	r3, #719	; 0x2cf
   1831a:	4a11      	ldr	r2, [pc, #68]	; (18360 <ull_filter_lll_rl_irk_idx+0x78>)
   1831c:	4914      	ldr	r1, [pc, #80]	; (18370 <ull_filter_lll_rl_irk_idx+0x88>)
   1831e:	4812      	ldr	r0, [pc, #72]	; (18368 <ull_filter_lll_rl_irk_idx+0x80>)
   18320:	f007 fd47 	bl	1fdb2 <printk>
   18324:	4040      	eors	r0, r0
   18326:	f380 8811 	msr	BASEPRI, r0
   1832a:	f04f 0003 	mov.w	r0, #3
   1832e:	df02      	svc	2
	LL_ASSERT(rl[i].taken);
   18330:	2328      	movs	r3, #40	; 0x28
   18332:	4363      	muls	r3, r4
   18334:	4a0f      	ldr	r2, [pc, #60]	; (18374 <ull_filter_lll_rl_irk_idx+0x8c>)
   18336:	5cd3      	ldrb	r3, [r2, r3]
   18338:	07db      	lsls	r3, r3, #31
   1833a:	d40c      	bmi.n	18356 <ull_filter_lll_rl_irk_idx+0x6e>
   1833c:	f44f 7334 	mov.w	r3, #720	; 0x2d0
   18340:	4a07      	ldr	r2, [pc, #28]	; (18360 <ull_filter_lll_rl_irk_idx+0x78>)
   18342:	490d      	ldr	r1, [pc, #52]	; (18378 <ull_filter_lll_rl_irk_idx+0x90>)
   18344:	4808      	ldr	r0, [pc, #32]	; (18368 <ull_filter_lll_rl_irk_idx+0x80>)
   18346:	f007 fd34 	bl	1fdb2 <printk>
   1834a:	4040      	eors	r0, r0
   1834c:	f380 8811 	msr	BASEPRI, r0
   18350:	f04f 0003 	mov.w	r0, #3
   18354:	df02      	svc	2
}
   18356:	4620      	mov	r0, r4
   18358:	bd10      	pop	{r4, pc}
   1835a:	bf00      	nop
   1835c:	2000aaa2 	.word	0x2000aaa2
   18360:	00064a6c 	.word	0x00064a6c
   18364:	00064c51 	.word	0x00064c51
   18368:	000632fe 	.word	0x000632fe
   1836c:	2000aaa3 	.word	0x2000aaa3
   18370:	00064c6e 	.word	0x00064c6e
   18374:	200015c4 	.word	0x200015c4
   18378:	00064c45 	.word	0x00064c45

0001837c <ull_filter_lll_irk_whitelisted>:
	if (rl_idx >= ARRAY_SIZE(rl)) {
   1837c:	2807      	cmp	r0, #7
{
   1837e:	b538      	push	{r3, r4, r5, lr}
   18380:	4605      	mov	r5, r0
	if (rl_idx >= ARRAY_SIZE(rl)) {
   18382:	d818      	bhi.n	183b6 <ull_filter_lll_irk_whitelisted+0x3a>
	LL_ASSERT(rl[rl_idx].taken);
   18384:	2228      	movs	r2, #40	; 0x28
   18386:	4c0d      	ldr	r4, [pc, #52]	; (183bc <ull_filter_lll_irk_whitelisted+0x40>)
   18388:	4342      	muls	r2, r0
   1838a:	5ca2      	ldrb	r2, [r4, r2]
   1838c:	07d3      	lsls	r3, r2, #31
   1838e:	d40c      	bmi.n	183aa <ull_filter_lll_irk_whitelisted+0x2e>
   18390:	f240 23db 	movw	r3, #731	; 0x2db
   18394:	4a0a      	ldr	r2, [pc, #40]	; (183c0 <ull_filter_lll_irk_whitelisted+0x44>)
   18396:	490b      	ldr	r1, [pc, #44]	; (183c4 <ull_filter_lll_irk_whitelisted+0x48>)
   18398:	480b      	ldr	r0, [pc, #44]	; (183c8 <ull_filter_lll_irk_whitelisted+0x4c>)
   1839a:	f007 fd0a 	bl	1fdb2 <printk>
   1839e:	4040      	eors	r0, r0
   183a0:	f380 8811 	msr	BASEPRI, r0
   183a4:	f04f 0003 	mov.w	r0, #3
   183a8:	df02      	svc	2
	return rl[rl_idx].wl;
   183aa:	2028      	movs	r0, #40	; 0x28
   183ac:	4368      	muls	r0, r5
   183ae:	5c20      	ldrb	r0, [r4, r0]
   183b0:	f3c0 1040 	ubfx	r0, r0, #5, #1
}
   183b4:	bd38      	pop	{r3, r4, r5, pc}
		return false;
   183b6:	2000      	movs	r0, #0
   183b8:	e7fc      	b.n	183b4 <ull_filter_lll_irk_whitelisted+0x38>
   183ba:	bf00      	nop
   183bc:	200015c4 	.word	0x200015c4
   183c0:	00064a6c 	.word	0x00064a6c
   183c4:	00064ab2 	.word	0x00064ab2
   183c8:	000632fe 	.word	0x000632fe

000183cc <ull_filter_lll_get>:
}
   183cc:	4a03      	ldr	r2, [pc, #12]	; (183dc <ull_filter_lll_get+0x10>)
   183ce:	4b04      	ldr	r3, [pc, #16]	; (183e0 <ull_filter_lll_get+0x14>)
   183d0:	2800      	cmp	r0, #0
   183d2:	bf0c      	ite	eq
   183d4:	4610      	moveq	r0, r2
   183d6:	4618      	movne	r0, r3
   183d8:	4770      	bx	lr
   183da:	bf00      	nop
   183dc:	2000ab2c 	.word	0x2000ab2c
   183e0:	2000ab9f 	.word	0x2000ab9f

000183e4 <ull_filter_lll_rl_addr_allowed>:
{
   183e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!rl_enable || *rl_idx != FILTER_IDX_NONE) {
   183e8:	4b1a      	ldr	r3, [pc, #104]	; (18454 <ull_filter_lll_rl_addr_allowed+0x70>)
   183ea:	781b      	ldrb	r3, [r3, #0]
   183ec:	b383      	cbz	r3, 18450 <ull_filter_lll_rl_addr_allowed+0x6c>
   183ee:	7813      	ldrb	r3, [r2, #0]
   183f0:	2bff      	cmp	r3, #255	; 0xff
   183f2:	d12d      	bne.n	18450 <ull_filter_lll_rl_addr_allowed+0x6c>
		if (rl[i].taken && (rl[i].id_addr_type == id_addr_type)) {
   183f4:	4e18      	ldr	r6, [pc, #96]	; (18458 <ull_filter_lll_rl_addr_allowed+0x74>)
   183f6:	2300      	movs	r3, #0
   183f8:	f04f 0828 	mov.w	r8, #40	; 0x28
   183fc:	46b4      	mov	ip, r6
   183fe:	f106 0906 	add.w	r9, r6, #6
   18402:	fb08 f403 	mul.w	r4, r8, r3
   18406:	fa5f fe83 	uxtb.w	lr, r3
   1840a:	5d37      	ldrb	r7, [r6, r4]
   1840c:	f017 0f01 	tst.w	r7, #1
   18410:	eb06 0504 	add.w	r5, r6, r4
   18414:	d019      	beq.n	1844a <ull_filter_lll_rl_addr_allowed+0x66>
   18416:	f3c7 1780 	ubfx	r7, r7, #6, #1
   1841a:	4287      	cmp	r7, r0
   1841c:	d115      	bne.n	1844a <ull_filter_lll_rl_addr_allowed+0x66>
			for (j = 0U; j < BDADDR_SIZE; j++) {
   1841e:	1e4f      	subs	r7, r1, #1
   18420:	444c      	add	r4, r9
				if (addr[j] != id_addr[j]) {
   18422:	f815 bf01 	ldrb.w	fp, [r5, #1]!
   18426:	f817 af01 	ldrb.w	sl, [r7, #1]!
   1842a:	45d3      	cmp	fp, sl
   1842c:	d10d      	bne.n	1844a <ull_filter_lll_rl_addr_allowed+0x66>
			for (j = 0U; j < BDADDR_SIZE; j++) {
   1842e:	42a5      	cmp	r5, r4
   18430:	d1f7      	bne.n	18422 <ull_filter_lll_rl_addr_allowed+0x3e>
				*rl_idx = i;
   18432:	f882 e000 	strb.w	lr, [r2]
				return !rl[i].pirk || rl[i].dev;
   18436:	2228      	movs	r2, #40	; 0x28
   18438:	4353      	muls	r3, r2
   1843a:	f81c 0003 	ldrb.w	r0, [ip, r3]
   1843e:	0743      	lsls	r3, r0, #29
   18440:	d506      	bpl.n	18450 <ull_filter_lll_rl_addr_allowed+0x6c>
   18442:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
   18446:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1844a:	3301      	adds	r3, #1
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
   1844c:	2b08      	cmp	r3, #8
   1844e:	d1d8      	bne.n	18402 <ull_filter_lll_rl_addr_allowed+0x1e>
				return !rl[i].pirk || rl[i].dev;
   18450:	2001      	movs	r0, #1
   18452:	e7f8      	b.n	18446 <ull_filter_lll_rl_addr_allowed+0x62>
   18454:	2000ab2b 	.word	0x2000ab2b
   18458:	200015c4 	.word	0x200015c4

0001845c <ull_filter_lll_rl_enabled>:
	return rl_enable;
   1845c:	4b02      	ldr	r3, [pc, #8]	; (18468 <ull_filter_lll_rl_enabled+0xc>)
   1845e:	7818      	ldrb	r0, [r3, #0]
}
   18460:	3000      	adds	r0, #0
   18462:	bf18      	it	ne
   18464:	2001      	movne	r0, #1
   18466:	4770      	bx	lr
   18468:	2000ab2b 	.word	0x2000ab2b

0001846c <cntr_init>:

static u8_t _refcount;

void cntr_init(void)
{
	NRF_RTC->PRESCALER = 0;
   1846c:	4b05      	ldr	r3, [pc, #20]	; (18484 <cntr_init+0x18>)
   1846e:	2200      	movs	r2, #0
   18470:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
   18474:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   18478:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
    p_reg->INTENSET = mask;
   1847c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	nrf_rtc_event_enable(NRF_RTC, RTC_EVTENSET_COMPARE0_Msk);
	nrf_rtc_int_enable(NRF_RTC, RTC_INTENSET_COMPARE0_Msk);
}
   18480:	4770      	bx	lr
   18482:	bf00      	nop
   18484:	4000b000 	.word	0x4000b000

00018488 <cntr_start>:

u32_t cntr_start(void)
{
	if (_refcount++) {
   18488:	4a04      	ldr	r2, [pc, #16]	; (1849c <cntr_start+0x14>)
   1848a:	7813      	ldrb	r3, [r2, #0]
   1848c:	1c59      	adds	r1, r3, #1
   1848e:	7011      	strb	r1, [r2, #0]
   18490:	2001      	movs	r0, #1
   18492:	b913      	cbnz	r3, 1849a <cntr_start+0x12>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   18494:	4a02      	ldr	r2, [pc, #8]	; (184a0 <cntr_start+0x18>)
   18496:	6010      	str	r0, [r2, #0]
		return 1;
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_START);

	return 0;
   18498:	4618      	mov	r0, r3
}
   1849a:	4770      	bx	lr
   1849c:	2000abd1 	.word	0x2000abd1
   184a0:	4000b000 	.word	0x4000b000

000184a4 <cntr_stop>:

u32_t cntr_stop(void)
{
   184a4:	b510      	push	{r4, lr}
	LL_ASSERT(_refcount);
   184a6:	4c0d      	ldr	r4, [pc, #52]	; (184dc <cntr_stop+0x38>)
   184a8:	7823      	ldrb	r3, [r4, #0]
   184aa:	b95b      	cbnz	r3, 184c4 <cntr_stop+0x20>
   184ac:	232e      	movs	r3, #46	; 0x2e
   184ae:	4a0c      	ldr	r2, [pc, #48]	; (184e0 <cntr_stop+0x3c>)
   184b0:	490c      	ldr	r1, [pc, #48]	; (184e4 <cntr_stop+0x40>)
   184b2:	480d      	ldr	r0, [pc, #52]	; (184e8 <cntr_stop+0x44>)
   184b4:	f007 fc7d 	bl	1fdb2 <printk>
   184b8:	4040      	eors	r0, r0
   184ba:	f380 8811 	msr	BASEPRI, r0
   184be:	f04f 0003 	mov.w	r0, #3
   184c2:	df02      	svc	2

	if (--_refcount) {
   184c4:	7820      	ldrb	r0, [r4, #0]
   184c6:	3801      	subs	r0, #1
   184c8:	b2c0      	uxtb	r0, r0
   184ca:	7020      	strb	r0, [r4, #0]
   184cc:	2301      	movs	r3, #1
   184ce:	b910      	cbnz	r0, 184d6 <cntr_stop+0x32>
   184d0:	4a06      	ldr	r2, [pc, #24]	; (184ec <cntr_stop+0x48>)
   184d2:	6013      	str	r3, [r2, #0]
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_STOP);

	return 0;
}
   184d4:	bd10      	pop	{r4, pc}
		return 1;
   184d6:	4618      	mov	r0, r3
   184d8:	e7fc      	b.n	184d4 <cntr_stop+0x30>
   184da:	bf00      	nop
   184dc:	2000abd1 	.word	0x2000abd1
   184e0:	00064c90 	.word	0x00064c90
   184e4:	00064cd5 	.word	0x00064cd5
   184e8:	000632fe 	.word	0x000632fe
   184ec:	4000b004 	.word	0x4000b004

000184f0 <cntr_cnt_get>:
     return p_reg->COUNTER;
   184f0:	4b01      	ldr	r3, [pc, #4]	; (184f8 <cntr_cnt_get+0x8>)
   184f2:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

u32_t cntr_cnt_get(void)
{
	return nrf_rtc_counter_get(NRF_RTC);
}
   184f6:	4770      	bx	lr
   184f8:	4000b000 	.word	0x4000b000

000184fc <cntr_cmp_set>:
    p_reg->CC[ch] = cc_val;
   184fc:	f500 70a8 	add.w	r0, r0, #336	; 0x150
   18500:	4b01      	ldr	r3, [pc, #4]	; (18508 <cntr_cmp_set+0xc>)
   18502:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

void cntr_cmp_set(u8_t cmp, u32_t value)
{
	nrf_rtc_cc_set(NRF_RTC, cmp, value);
}
   18506:	4770      	bx	lr
   18508:	4000b000 	.word	0x4000b000

0001850c <do_ecb>:
	u8_t clear_text[16];
	u8_t cipher_text[16];
} __packed;

static void do_ecb(struct ecb_param *ecb)
{
   1850c:	b5f0      	push	{r4, r5, r6, r7, lr}
	do {
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
		NRF_ECB->ECBDATAPTR = (u32_t)ecb;
   1850e:	4b13      	ldr	r3, [pc, #76]	; (1855c <do_ecb+0x50>)

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ecb_task_trigger(NRF_ECB_Type * p_reg, nrf_ecb_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   18510:	4c13      	ldr	r4, [pc, #76]	; (18560 <do_ecb+0x54>)
   18512:	2501      	movs	r5, #1
{
   18514:	4684      	mov	ip, r0
   18516:	462e      	mov	r6, r5
		NRF_ECB->EVENTS_ENDECB = 0;
   18518:	2700      	movs	r7, #0
   1851a:	46a6      	mov	lr, r4
   1851c:	461a      	mov	r2, r3
   1851e:	6026      	str	r6, [r4, #0]
		NRF_ECB->ECBDATAPTR = (u32_t)ecb;
   18520:	f8c3 c504 	str.w	ip, [r3, #1284]	; 0x504
		NRF_ECB->EVENTS_ENDECB = 0;
   18524:	f8c3 7100 	str.w	r7, [r3, #256]	; 0x100
		NRF_ECB->EVENTS_ERRORECB = 0;
   18528:	f8c3 7104 	str.w	r7, [r3, #260]	; 0x104
   1852c:	601e      	str	r6, [r3, #0]
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STARTECB);
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
   1852e:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
   18532:	b931      	cbnz	r1, 18542 <do_ecb+0x36>
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
   18534:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
   18538:	b919      	cbnz	r1, 18542 <do_ecb+0x36>
		       (NRF_ECB->ECBDATAPTR != 0)) {
   1853a:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
   1853e:	2900      	cmp	r1, #0
   18540:	d1f5      	bne.n	1852e <do_ecb+0x22>
   18542:	f8ce 5000 	str.w	r5, [lr]
#else
			/*__WFE();*/
#endif
		}
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
	} while ((NRF_ECB->EVENTS_ERRORECB != 0) || (NRF_ECB->ECBDATAPTR == 0));
   18546:	f8d2 1104 	ldr.w	r1, [r2, #260]	; 0x104
   1854a:	2900      	cmp	r1, #0
   1854c:	d1e7      	bne.n	1851e <do_ecb+0x12>
   1854e:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
   18552:	2800      	cmp	r0, #0
   18554:	d0e3      	beq.n	1851e <do_ecb+0x12>

	NRF_ECB->ECBDATAPTR = 0;
   18556:	f8c2 1504 	str.w	r1, [r2, #1284]	; 0x504
}
   1855a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1855c:	4000e000 	.word	0x4000e000
   18560:	4000e004 	.word	0x4000e004

00018564 <hal_radio_enable_on_tick_ppi_config_and_enable>:
static inline void hal_radio_enable_on_tick_ppi_config_and_enable(u8_t trx)
{
	/* No need to configure anything for the pre-programmed channels.
	 * Just enable and disable them accordingly.
	 */
	nrf_ppi_channels_disable(
   18564:	2800      	cmp	r0, #0
    p_reg->CHENSET = mask;
}

NRF_STATIC_INLINE void nrf_ppi_channels_disable(NRF_PPI_Type * p_reg, uint32_t mask)
{
    p_reg->CHENCLR = mask;
   18566:	4b08      	ldr	r3, [pc, #32]	; (18588 <hal_radio_enable_on_tick_ppi_config_and_enable+0x24>)
   18568:	bf14      	ite	ne
   1856a:	f44f 1200 	movne.w	r2, #2097152	; 0x200000
   1856e:	f44f 1280 	moveq.w	r2, #1048576	; 0x100000
   18572:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
		NRF_PPI,
		trx ? BIT(HAL_RADIO_ENABLE_RX_ON_TICK_PPI)
		    : BIT(HAL_RADIO_ENABLE_TX_ON_TICK_PPI));
	nrf_ppi_channels_enable(
   18576:	bf14      	ite	ne
   18578:	f44f 1280 	movne.w	r2, #1048576	; 0x100000
   1857c:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
    p_reg->CHENSET = mask;
   18580:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
		NRF_PPI,
		trx ? BIT(HAL_RADIO_ENABLE_TX_ON_TICK_PPI)
		    : BIT(HAL_RADIO_ENABLE_RX_ON_TICK_PPI));
}
   18584:	4770      	bx	lr
   18586:	bf00      	nop
   18588:	4001f000 	.word	0x4001f000

0001858c <sw_switch.isra.10>:
}

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
static u8_t sw_tifs_toggle;

static void sw_switch(u8_t dir, u8_t phy_curr, u8_t flags_curr, u8_t phy_next,
   1858c:	b5f0      	push	{r4, r5, r6, r7, lr}
		      u8_t flags_next)
{
	u8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
   1858e:	4e2d      	ldr	r6, [pc, #180]	; (18644 <sw_switch.isra.10+0xb8>)
NRF_STATIC_INLINE void nrf_ppi_channel_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                      nrf_ppi_channel_t channel,
                                                      uint32_t          eep,
                                                      uint32_t          tep)
{
    p_reg->CH[(uint32_t) channel].EEP = eep;
   18590:	4f2d      	ldr	r7, [pc, #180]	; (18648 <sw_switch.isra.10+0xbc>)
   18592:	7835      	ldrb	r5, [r6, #0]
   18594:	f8df c0bc 	ldr.w	ip, [pc, #188]	; 18654 <sw_switch.isra.10+0xc8>
   18598:	f8c7 c560 	str.w	ip, [r7, #1376]	; 0x560
	 */
	nrf_ppi_channel_endpoint_setup(
		NRF_PPI,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_EVT,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_TASK(ppi_group_index));
   1859c:	b22b      	sxth	r3, r5
   1859e:	00dc      	lsls	r4, r3, #3
   185a0:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
   185a4:	f504 34f8 	add.w	r4, r4, #126976	; 0x1f000
    p_reg->CH[(uint32_t) channel].TEP = tep;
   185a8:	f8c7 4564 	str.w	r4, [r7, #1380]	; 0x564
   185ac:	f105 040b 	add.w	r4, r5, #11
   185b0:	b2e4      	uxtb	r4, r4
   185b2:	00e4      	lsls	r4, r4, #3
	 * (TX/RX).
	 */
	nrf_ppi_event_endpoint_setup(
		NRF_PPI,
		radio_enable_ppi,
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(compare_reg));
   185b4:	f5a7 37af 	sub.w	r7, r7, #89600	; 0x15e00
   185b8:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
   185bc:	3fc0      	subs	r7, #192	; 0xc0
   185be:	f504 34f8 	add.w	r4, r4, #126976	; 0x1f000
   185c2:	eb07 0783 	add.w	r7, r7, r3, lsl #2

NRF_STATIC_INLINE void nrf_ppi_event_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                    nrf_ppi_channel_t channel,
                                                    uint32_t          eep)
{
    p_reg->CH[(uint32_t) channel].EEP = eep;
   185c6:	f8c4 7510 	str.w	r7, [r4, #1296]	; 0x510
	u8_t cc = SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle);
	u32_t delay;

	hal_radio_sw_switch_setup(cc, ppi, sw_tifs_toggle);

	if (dir) {
   185ca:	2800      	cmp	r0, #0
   185cc:	d034      	beq.n	18638 <sw_switch.isra.10+0xac>
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF52832_TXEN_TXIDLE_TX_1M_NS;
	case BIT(1):
		return HAL_RADIO_NRF52832_TXEN_TXIDLE_TX_2M_NS;
   185ce:	f649 4740 	movw	r7, #40000	; 0x9c40
   185d2:	f24a 005a 	movw	r0, #41050	; 0xa05a
   185d6:	2a02      	cmp	r2, #2
   185d8:	bf08      	it	eq
   185da:	4638      	moveq	r0, r7
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF52832_RX_CHAIN_DELAY_1M_NS;
	case BIT(1):
		return HAL_RADIO_NRF52832_RX_CHAIN_DELAY_2M_NS;
   185dc:	f242 42b8 	movw	r2, #9400	; 0x24b8
   185e0:	f241 574a 	movw	r7, #5450	; 0x154a
   185e4:	2902      	cmp	r1, #2
   185e6:	bf14      	ite	ne
   185e8:	4611      	movne	r1, r2
   185ea:	4639      	moveq	r1, r7
		/* TX */

		/* Calculate delay with respect to current (RX) and next
		 * (TX) PHY. If RX PHY is LE Coded, assume S8 coding scheme.
		 */
		delay = HAL_RADIO_NS2US_ROUND(
   185ec:	f500 70fa 	add.w	r0, r0, #500	; 0x1f4
   185f0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   185f4:	4401      	add	r1, r0
   185f6:	fbb1 f1f2 	udiv	r1, r1, r2

NRF_STATIC_INLINE void nrf_ppi_task_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                   nrf_ppi_channel_t channel,
                                                   uint32_t          tep)
{
    p_reg->CH[(uint32_t) channel].TEP = tep;
   185fa:	4a14      	ldr	r2, [pc, #80]	; (1864c <sw_switch.isra.10+0xc0>)
   185fc:	f8c4 2514 	str.w	r2, [r4, #1300]	; 0x514
		}
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	}

	if (delay <
   18600:	009b      	lsls	r3, r3, #2
   18602:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   18606:	f503 4310 	add.w	r3, r3, #36864	; 0x9000
		SW_SWITCH_TIMER->CC[cc]) {
   1860a:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
	if (delay <
   1860e:	428a      	cmp	r2, r1
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
				 SW_SWITCH_TIMER->CC[cc] - delay);
   18610:	bf8b      	itete	hi
   18612:	f8d3 2540 	ldrhi.w	r2, [r3, #1344]	; 0x540

NRF_STATIC_INLINE void nrf_timer_cc_set(NRF_TIMER_Type *       p_reg,
                                        nrf_timer_cc_channel_t cc_channel,
                                        uint32_t               cc_value)
{
    p_reg->CC[cc_channel] = cc_value;
   18616:	2201      	movls	r2, #1
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
   18618:	1a51      	subhi	r1, r2, r1
   1861a:	f8c3 2540 	strls.w	r2, [r3, #1344]	; 0x540
   1861e:	bf88      	it	hi
   18620:	f8c3 1540 	strhi.w	r1, [r3, #1344]	; 0x540
    p_reg->CHENSET = mask;
   18624:	4b08      	ldr	r3, [pc, #32]	; (18648 <sw_switch.isra.10+0xbc>)
   18626:	f44f 6290 	mov.w	r2, #1152	; 0x480
   1862a:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	 * always need to capture the PDU END time-stamp.
	 */
	radio_tmr_end_capture();
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */

	sw_tifs_toggle += 1U;
   1862e:	1c6b      	adds	r3, r5, #1
	sw_tifs_toggle &= 1;
   18630:	f003 0301 	and.w	r3, r3, #1
   18634:	7033      	strb	r3, [r6, #0]
}
   18636:	bdf0      	pop	{r4, r5, r6, r7, pc}
    p_reg->CH[(uint32_t) channel].TEP = tep;
   18638:	4a05      	ldr	r2, [pc, #20]	; (18650 <sw_switch.isra.10+0xc4>)
   1863a:	f8c4 2514 	str.w	r2, [r4, #1300]	; 0x514
		delay = HAL_RADIO_NS2US_CEIL(
   1863e:	2129      	movs	r1, #41	; 0x29
   18640:	e7de      	b.n	18600 <sw_switch.isra.10+0x74>
   18642:	bf00      	nop
   18644:	2000abd2 	.word	0x2000abd2
   18648:	4001f000 	.word	0x4001f000
   1864c:	40001000 	.word	0x40001000
   18650:	40001004 	.word	0x40001004
   18654:	4000110c 	.word	0x4000110c

00018658 <isr_radio>:
	return (NRF_RADIO->EVENTS_DISABLED != 0);
   18658:	4b04      	ldr	r3, [pc, #16]	; (1866c <isr_radio+0x14>)
   1865a:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
	if (radio_has_disabled()) {
   1865e:	b123      	cbz	r3, 1866a <isr_radio+0x12>
		isr_cb(isr_cb_param);
   18660:	4b03      	ldr	r3, [pc, #12]	; (18670 <isr_radio+0x18>)
   18662:	4a04      	ldr	r2, [pc, #16]	; (18674 <isr_radio+0x1c>)
   18664:	681b      	ldr	r3, [r3, #0]
   18666:	6810      	ldr	r0, [r2, #0]
   18668:	4718      	bx	r3
}
   1866a:	4770      	bx	lr
   1866c:	40001000 	.word	0x40001000
   18670:	20001940 	.word	0x20001940
   18674:	20001944 	.word	0x20001944

00018678 <radio_isr_set>:
{
   18678:	b538      	push	{r3, r4, r5, lr}
   1867a:	4604      	mov	r4, r0
	irq_disable(RADIO_IRQn);
   1867c:	2001      	movs	r0, #1
{
   1867e:	460d      	mov	r5, r1
	irq_disable(RADIO_IRQn);
   18680:	f7ee fa4e 	bl	6b20 <arch_irq_disable>
	isr_cb_param = param;
   18684:	4b08      	ldr	r3, [pc, #32]	; (186a8 <radio_isr_set+0x30>)
   18686:	601d      	str	r5, [r3, #0]
	isr_cb = cb;
   18688:	4b08      	ldr	r3, [pc, #32]	; (186ac <radio_isr_set+0x34>)
   1868a:	601c      	str	r4, [r3, #0]
    return p_reg->SHORTS;
}

NRF_STATIC_INLINE void nrf_radio_int_enable(NRF_RADIO_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   1868c:	4b08      	ldr	r3, [pc, #32]	; (186b0 <radio_isr_set+0x38>)
   1868e:	2210      	movs	r2, #16
   18690:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   18694:	4b07      	ldr	r3, [pc, #28]	; (186b4 <radio_isr_set+0x3c>)
   18696:	2202      	movs	r2, #2
   18698:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	irq_enable(RADIO_IRQn);
   1869c:	2001      	movs	r0, #1
}
   1869e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	irq_enable(RADIO_IRQn);
   186a2:	f7ee ba2d 	b.w	6b00 <arch_irq_enable>
   186a6:	bf00      	nop
   186a8:	20001944 	.word	0x20001944
   186ac:	20001940 	.word	0x20001940
   186b0:	40001000 	.word	0x40001000
   186b4:	e000e100 	.word	0xe000e100

000186b8 <radio_reset>:
{
   186b8:	b508      	push	{r3, lr}
	irq_disable(RADIO_IRQn);
   186ba:	2001      	movs	r0, #1
   186bc:	f7ee fa30 	bl	6b20 <arch_irq_disable>
}
#endif

NRF_STATIC_INLINE void nrf_radio_power_set(NRF_RADIO_Type * p_reg, bool radio_power)
{
    p_reg->POWER = (uint32_t) radio_power;
   186c0:	4b0c      	ldr	r3, [pc, #48]	; (186f4 <radio_reset+0x3c>)
   186c2:	2200      	movs	r2, #0
   186c4:	f8c3 2ffc 	str.w	r2, [r3, #4092]	; 0xffc
   186c8:	2201      	movs	r2, #1
   186ca:	f8c3 2ffc 	str.w	r2, [r3, #4092]	; 0xffc
	*(volatile u32_t *)0x40001774 = ((*(volatile u32_t *)0x40001774) &
   186ce:	4a0a      	ldr	r2, [pc, #40]	; (186f8 <radio_reset+0x40>)
   186d0:	6813      	ldr	r3, [r2, #0]
					 0xfffffffe) | 0x01000000;
   186d2:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   186d6:	f023 0301 	bic.w	r3, r3, #1
   186da:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
	*(volatile u32_t *)0x40001774 = ((*(volatile u32_t *)0x40001774) &
   186de:	6013      	str	r3, [r2, #0]
static inline void hal_radio_sw_switch_ppi_group_setup(void)
{
	/* Include the appropriate PPI channels in the two PPI Groups. */
#if !defined(CONFIG_BT_CTLR_PHY_CODED) || \
	!defined(CONFIG_HAS_HW_NRF_RADIO_BLE_CODED)
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
   186e0:	4b06      	ldr	r3, [pc, #24]	; (186fc <radio_reset+0x44>)
   186e2:	f44f 6210 	mov.w	r2, #2304	; 0x900
   186e6:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_0_INCLUDE |
			HAL_SW_SWITCH_RADIO_ENABLE_PPI_0_INCLUDE;
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
   186ea:	f44f 5290 	mov.w	r2, #4608	; 0x1200
   186ee:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
}
   186f2:	bd08      	pop	{r3, pc}
   186f4:	40001000 	.word	0x40001000
   186f8:	40001774 	.word	0x40001774
   186fc:	4001f000 	.word	0x4001f000

00018700 <radio_phy_set>:
	NRF_RADIO->MODE = (mode << RADIO_MODE_MODE_Pos) & RADIO_MODE_MODE_Msk;
   18700:	4b06      	ldr	r3, [pc, #24]	; (1871c <radio_phy_set+0x1c>)
	switch (phy) {
   18702:	2802      	cmp	r0, #2
		mode = RADIO_MODE_MODE_Ble_2Mbit;
   18704:	bf14      	ite	ne
   18706:	2203      	movne	r2, #3
   18708:	2204      	moveq	r2, #4
   1870a:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_RADIO->MODECNF0 |= (RADIO_MODECNF0_RU_Fast <<
   1870e:	f8d3 2650 	ldr.w	r2, [r3, #1616]	; 0x650
   18712:	f042 0201 	orr.w	r2, r2, #1
   18716:	f8c3 2650 	str.w	r2, [r3, #1616]	; 0x650
}
   1871a:	4770      	bx	lr
   1871c:	40001000 	.word	0x40001000

00018720 <radio_tx_power_set>:
	NRF_RADIO->TXPOWER = (u32_t)power;
   18720:	4b01      	ldr	r3, [pc, #4]	; (18728 <radio_tx_power_set+0x8>)
   18722:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
}
   18726:	4770      	bx	lr
   18728:	40001000 	.word	0x40001000

0001872c <radio_freq_chan_set>:
	NRF_RADIO->FREQUENCY = chan;
   1872c:	4b01      	ldr	r3, [pc, #4]	; (18734 <radio_freq_chan_set+0x8>)
   1872e:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
}
   18732:	4770      	bx	lr
   18734:	40001000 	.word	0x40001000

00018738 <radio_whiten_iv_set>:
	NRF_RADIO->DATAWHITEIV = iv;
   18738:	4b07      	ldr	r3, [pc, #28]	; (18758 <radio_whiten_iv_set+0x20>)
   1873a:	f8c3 0554 	str.w	r0, [r3, #1364]	; 0x554
	NRF_RADIO->PCNF1 &= ~RADIO_PCNF1_WHITEEN_Msk;
   1873e:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
   18742:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
   18746:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((1UL) << RADIO_PCNF1_WHITEEN_Pos) &
   1874a:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
   1874e:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
   18752:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
   18756:	4770      	bx	lr
   18758:	40001000 	.word	0x40001000

0001875c <radio_aa_set>:
	NRF_RADIO->TXADDRESS =
   1875c:	4a0a      	ldr	r2, [pc, #40]	; (18788 <radio_aa_set+0x2c>)
   1875e:	2300      	movs	r3, #0
   18760:	f8c2 352c 	str.w	r3, [r2, #1324]	; 0x52c
	NRF_RADIO->RXADDRESSES =
   18764:	2301      	movs	r3, #1
   18766:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
	NRF_RADIO->PREFIX0 = aa[3];
   1876a:	78c3      	ldrb	r3, [r0, #3]
   1876c:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
	NRF_RADIO->BASE0 = (aa[2] << 24) | (aa[1] << 16) | (aa[0] << 8);
   18770:	7843      	ldrb	r3, [r0, #1]
   18772:	7881      	ldrb	r1, [r0, #2]
   18774:	041b      	lsls	r3, r3, #16
   18776:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
   1877a:	7801      	ldrb	r1, [r0, #0]
   1877c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   18780:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
}
   18784:	4770      	bx	lr
   18786:	bf00      	nop
   18788:	40001000 	.word	0x40001000

0001878c <radio_pkt_configure>:
	switch (phy) {
   1878c:	f3c2 0342 	ubfx	r3, r2, #1, #3
		extra |= (RADIO_PCNF0_PLEN_16bit << RADIO_PCNF0_PLEN_Pos) &
   18790:	2b02      	cmp	r3, #2
{
   18792:	b510      	push	{r4, lr}
		extra |= (RADIO_PCNF0_PLEN_16bit << RADIO_PCNF0_PLEN_Pos) &
   18794:	bf14      	ite	ne
   18796:	2400      	movne	r4, #0
   18798:	f04f 7480 	moveq.w	r4, #16777216	; 0x1000000
	if (dc) {
   1879c:	07d3      	lsls	r3, r2, #31
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
   1879e:	f1c0 0308 	rsb	r3, r0, #8
		extra |= (RADIO_PCNF0_S1INCL_Include <<
   187a2:	bf48      	it	mi
   187a4:	f444 1480 	orrmi.w	r4, r4, #1048576	; 0x100000
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
   187a8:	041b      	lsls	r3, r3, #16
			   ((((u32_t)bits_len) << RADIO_PCNF0_LFLEN_Pos) &
   187aa:	f000 000f 	and.w	r0, r0, #15
			    RADIO_PCNF0_S1LEN_Msk) |
   187ae:	4320      	orrs	r0, r4
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
   187b0:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
   187b4:	4a09      	ldr	r2, [pc, #36]	; (187dc <radio_pkt_configure+0x50>)
			    RADIO_PCNF0_S1LEN_Msk) |
   187b6:	4303      	orrs	r3, r0
   187b8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
   187bc:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
   187c0:	f8d2 0518 	ldr.w	r0, [r2, #1304]	; 0x518
   187c4:	4b06      	ldr	r3, [pc, #24]	; (187e0 <radio_pkt_configure+0x54>)
   187c6:	4003      	ands	r3, r0
   187c8:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((((u32_t)max_len) << RADIO_PCNF1_MAXLEN_Pos) &
   187cc:	f8d2 3518 	ldr.w	r3, [r2, #1304]	; 0x518
   187d0:	4319      	orrs	r1, r3
   187d2:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
   187d6:	f8c2 1518 	str.w	r1, [r2, #1304]	; 0x518
}
   187da:	bd10      	pop	{r4, pc}
   187dc:	40001000 	.word	0x40001000
   187e0:	fef80000 	.word	0xfef80000

000187e4 <radio_pkt_rx_set>:
	NRF_RADIO->PACKETPTR = (u32_t)rx_packet;
   187e4:	4b01      	ldr	r3, [pc, #4]	; (187ec <radio_pkt_rx_set+0x8>)
   187e6:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
}
   187ea:	4770      	bx	lr
   187ec:	40001000 	.word	0x40001000

000187f0 <radio_pkt_tx_set>:
   187f0:	4b01      	ldr	r3, [pc, #4]	; (187f8 <radio_pkt_tx_set+0x8>)
   187f2:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
   187f6:	4770      	bx	lr
   187f8:	40001000 	.word	0x40001000

000187fc <radio_tx_enable>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   187fc:	4b01      	ldr	r3, [pc, #4]	; (18804 <radio_tx_enable+0x8>)
   187fe:	2201      	movs	r2, #1
   18800:	601a      	str	r2, [r3, #0]
}
   18802:	4770      	bx	lr
   18804:	40001000 	.word	0x40001000

00018808 <radio_disable>:
    p_reg->CHENCLR = mask;
   18808:	4a07      	ldr	r2, [pc, #28]	; (18828 <radio_disable+0x20>)
   1880a:	f44f 6390 	mov.w	r3, #1152	; 0x480
   1880e:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    p_reg->TASKS_CHG[(uint32_t) group].EN = 1UL;
}

NRF_STATIC_INLINE void nrf_ppi_group_disable(NRF_PPI_Type * p_reg, nrf_ppi_channel_group_t group)
{
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1UL;
   18812:	2301      	movs	r3, #1
   18814:	6053      	str	r3, [r2, #4]
   18816:	60d3      	str	r3, [r2, #12]
	NRF_RADIO->SHORTS = 0;
   18818:	f5a2 32f0 	sub.w	r2, r2, #122880	; 0x1e000
   1881c:	2100      	movs	r1, #0
   1881e:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
   18822:	6113      	str	r3, [r2, #16]
}
   18824:	4770      	bx	lr
   18826:	bf00      	nop
   18828:	4001f000 	.word	0x4001f000

0001882c <radio_status_reset>:
	NRF_RADIO->EVENTS_READY = 0;
   1882c:	4b04      	ldr	r3, [pc, #16]	; (18840 <radio_status_reset+0x14>)
   1882e:	2200      	movs	r2, #0
   18830:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	NRF_RADIO->EVENTS_END = 0;
   18834:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
	NRF_RADIO->EVENTS_DISABLED = 0;
   18838:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
   1883c:	4770      	bx	lr
   1883e:	bf00      	nop
   18840:	40001000 	.word	0x40001000

00018844 <radio_is_ready>:
	return (NRF_RADIO->EVENTS_READY != 0);
   18844:	4b03      	ldr	r3, [pc, #12]	; (18854 <radio_is_ready+0x10>)
   18846:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
}
   1884a:	3000      	adds	r0, #0
   1884c:	bf18      	it	ne
   1884e:	2001      	movne	r0, #1
   18850:	4770      	bx	lr
   18852:	bf00      	nop
   18854:	40001000 	.word	0x40001000

00018858 <radio_is_done>:
	return (NRF_RADIO->EVENTS_END != 0);
   18858:	4b03      	ldr	r3, [pc, #12]	; (18868 <radio_is_done+0x10>)
   1885a:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
}
   1885e:	3000      	adds	r0, #0
   18860:	bf18      	it	ne
   18862:	2001      	movne	r0, #1
   18864:	4770      	bx	lr
   18866:	bf00      	nop
   18868:	40001000 	.word	0x40001000

0001886c <radio_crc_configure>:
	NRF_RADIO->CRCCNF =
   1886c:	4b04      	ldr	r3, [pc, #16]	; (18880 <radio_crc_configure+0x14>)
   1886e:	f240 1203 	movw	r2, #259	; 0x103
   18872:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
	NRF_RADIO->CRCPOLY = polynomial;
   18876:	f8c3 0538 	str.w	r0, [r3, #1336]	; 0x538
	NRF_RADIO->CRCINIT = iv;
   1887a:	f8c3 153c 	str.w	r1, [r3, #1340]	; 0x53c
}
   1887e:	4770      	bx	lr
   18880:	40001000 	.word	0x40001000

00018884 <radio_crc_is_valid>:
	return (NRF_RADIO->CRCSTATUS != 0);
   18884:	4b03      	ldr	r3, [pc, #12]	; (18894 <radio_crc_is_valid+0x10>)
   18886:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
   1888a:	3000      	adds	r0, #0
   1888c:	bf18      	it	ne
   1888e:	2001      	movne	r0, #1
   18890:	4770      	bx	lr
   18892:	bf00      	nop
   18894:	40001000 	.word	0x40001000

00018898 <radio_pkt_empty_get>:
}
   18898:	4800      	ldr	r0, [pc, #0]	; (1889c <radio_pkt_empty_get+0x4>)
   1889a:	4770      	bx	lr
   1889c:	20001838 	.word	0x20001838

000188a0 <radio_pkt_scratch_get>:
}
   188a0:	4800      	ldr	r0, [pc, #0]	; (188a4 <radio_pkt_scratch_get+0x4>)
   188a2:	4770      	bx	lr
   188a4:	2000183c 	.word	0x2000183c

000188a8 <radio_switch_complete_and_rx>:
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_RXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
   188a8:	4b04      	ldr	r3, [pc, #16]	; (188bc <radio_switch_complete_and_rx+0x14>)
   188aa:	2203      	movs	r2, #3
			    RADIO_SHORTS_END_DISABLE_Msk;
	sw_switch(0, 0, 0, phy_rx, 0);
   188ac:	2100      	movs	r1, #0
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
   188ae:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
	sw_switch(0, 0, 0, phy_rx, 0);
   188b2:	4602      	mov	r2, r0
   188b4:	4608      	mov	r0, r1
   188b6:	f7ff be69 	b.w	1858c <sw_switch.isra.10>
   188ba:	bf00      	nop
   188bc:	40001000 	.word	0x40001000

000188c0 <radio_switch_complete_and_tx>:
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_TXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
   188c0:	4b03      	ldr	r3, [pc, #12]	; (188d0 <radio_switch_complete_and_tx+0x10>)
   188c2:	2103      	movs	r1, #3
   188c4:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
			    RADIO_SHORTS_END_DISABLE_Msk;
	sw_switch(1, phy_rx, flags_rx, phy_tx, flags_tx);
   188c8:	4601      	mov	r1, r0
   188ca:	2001      	movs	r0, #1
   188cc:	f7ff be5e 	b.w	1858c <sw_switch.isra.10>
   188d0:	40001000 	.word	0x40001000

000188d4 <radio_switch_complete_and_disable>:
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}

void radio_switch_complete_and_disable(void)
{
	NRF_RADIO->SHORTS =
   188d4:	4b05      	ldr	r3, [pc, #20]	; (188ec <radio_switch_complete_and_disable+0x18>)
   188d6:	2203      	movs	r2, #3
   188d8:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    p_reg->CHENCLR = mask;
   188dc:	f503 33f0 	add.w	r3, r3, #122880	; 0x1e000
   188e0:	f44f 6290 	mov.w	r2, #1152	; 0x480
   188e4:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
	    (RADIO_SHORTS_READY_START_Msk | RADIO_SHORTS_END_DISABLE_Msk);

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	hal_radio_sw_switch_disable();
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   188e8:	4770      	bx	lr
   188ea:	bf00      	nop
   188ec:	40001000 	.word	0x40001000

000188f0 <radio_rssi_status_reset>:
	return NRF_RADIO->RSSISAMPLE;
}

void radio_rssi_status_reset(void)
{
	NRF_RADIO->EVENTS_RSSIEND = 0;
   188f0:	4b02      	ldr	r3, [pc, #8]	; (188fc <radio_rssi_status_reset+0xc>)
   188f2:	2200      	movs	r2, #0
   188f4:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
}
   188f8:	4770      	bx	lr
   188fa:	bf00      	nop
   188fc:	40001000 	.word	0x40001000

00018900 <radio_rssi_is_ready>:

u32_t radio_rssi_is_ready(void)
{
	return (NRF_RADIO->EVENTS_RSSIEND != 0);
   18900:	4b03      	ldr	r3, [pc, #12]	; (18910 <radio_rssi_is_ready+0x10>)
   18902:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
}
   18906:	3000      	adds	r0, #0
   18908:	bf18      	it	ne
   1890a:	2001      	movne	r0, #1
   1890c:	4770      	bx	lr
   1890e:	bf00      	nop
   18910:	40001000 	.word	0x40001000

00018914 <radio_filter_configure>:

void radio_filter_configure(u8_t bitmask_enable, u8_t bitmask_addr_type,
			    u8_t *bdaddr)
{
   18914:	b5f0      	push	{r4, r5, r6, r7, lr}
   18916:	2400      	movs	r4, #0
   18918:	2706      	movs	r7, #6
   1891a:	00a3      	lsls	r3, r4, #2
   1891c:	fb07 2504 	mla	r5, r7, r4, r2
	u8_t index;

	for (index = 0U; index < 8; index++) {
		NRF_RADIO->DAB[index] = ((u32_t)bdaddr[3] << 24) |
   18920:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   18924:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
			((u32_t)bdaddr[2] << 16) |
			((u32_t)bdaddr[1] << 8) |
   18928:	682e      	ldr	r6, [r5, #0]
		NRF_RADIO->DAB[index] = ((u32_t)bdaddr[3] << 24) |
   1892a:	f8c3 6600 	str.w	r6, [r3, #1536]	; 0x600
			bdaddr[0];
		NRF_RADIO->DAP[index] = ((u32_t)bdaddr[5] << 8) | bdaddr[4];
   1892e:	3401      	adds	r4, #1
   18930:	88ad      	ldrh	r5, [r5, #4]
   18932:	f8c3 5620 	str.w	r5, [r3, #1568]	; 0x620
	for (index = 0U; index < 8; index++) {
   18936:	2c08      	cmp	r4, #8
   18938:	d1ef      	bne.n	1891a <radio_filter_configure+0x6>
		bdaddr += 6;
	}

	NRF_RADIO->DACNF = ((u32_t)bitmask_addr_type << 8) | bitmask_enable;
   1893a:	4b03      	ldr	r3, [pc, #12]	; (18948 <radio_filter_configure+0x34>)
   1893c:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
   18940:	f8c3 0640 	str.w	r0, [r3, #1600]	; 0x640
}
   18944:	bdf0      	pop	{r4, r5, r6, r7, pc}
   18946:	bf00      	nop
   18948:	40001000 	.word	0x40001000

0001894c <radio_filter_disable>:

void radio_filter_disable(void)
{
	NRF_RADIO->DACNF &= ~(0x000000FF);
   1894c:	4a03      	ldr	r2, [pc, #12]	; (1895c <radio_filter_disable+0x10>)
   1894e:	f8d2 3640 	ldr.w	r3, [r2, #1600]	; 0x640
   18952:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   18956:	f8c2 3640 	str.w	r3, [r2, #1600]	; 0x640
}
   1895a:	4770      	bx	lr
   1895c:	40001000 	.word	0x40001000

00018960 <radio_filter_status_reset>:

void radio_filter_status_reset(void)
{
	NRF_RADIO->EVENTS_DEVMATCH = 0;
   18960:	4b02      	ldr	r3, [pc, #8]	; (1896c <radio_filter_status_reset+0xc>)
   18962:	2200      	movs	r2, #0
   18964:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
   18968:	4770      	bx	lr
   1896a:	bf00      	nop
   1896c:	40001000 	.word	0x40001000

00018970 <radio_filter_has_match>:

u32_t radio_filter_has_match(void)
{
	return (NRF_RADIO->EVENTS_DEVMATCH != 0);
   18970:	4b03      	ldr	r3, [pc, #12]	; (18980 <radio_filter_has_match+0x10>)
   18972:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
   18976:	3000      	adds	r0, #0
   18978:	bf18      	it	ne
   1897a:	2001      	movne	r0, #1
   1897c:	4770      	bx	lr
   1897e:	bf00      	nop
   18980:	40001000 	.word	0x40001000

00018984 <radio_filter_match_get>:

u32_t radio_filter_match_get(void)
{
	return NRF_RADIO->DAI;
   18984:	4b01      	ldr	r3, [pc, #4]	; (1898c <radio_filter_match_get+0x8>)
   18986:	f8d3 0410 	ldr.w	r0, [r3, #1040]	; 0x410
}
   1898a:	4770      	bx	lr
   1898c:	40001000 	.word	0x40001000

00018990 <radio_bc_configure>:
    p_reg->BCC = radio_bcc;
   18990:	4b04      	ldr	r3, [pc, #16]	; (189a4 <radio_bc_configure+0x14>)
   18992:	f8c3 0560 	str.w	r0, [r3, #1376]	; 0x560

void radio_bc_configure(u32_t n)
{
	nrf_radio_bcc_set(NRF_RADIO, n);
	NRF_RADIO->SHORTS |= RADIO_SHORTS_ADDRESS_BCSTART_Msk;
   18996:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   1899a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   1899e:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
}
   189a2:	4770      	bx	lr
   189a4:	40001000 	.word	0x40001000

000189a8 <radio_tmr_status_reset>:
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   189a8:	4b05      	ldr	r3, [pc, #20]	; (189c0 <radio_tmr_status_reset+0x18>)
   189aa:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   189ae:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
   189b2:	f503 33a0 	add.w	r3, r3, #81920	; 0x14000
   189b6:	4a03      	ldr	r2, [pc, #12]	; (189c4 <radio_tmr_status_reset+0x1c>)
   189b8:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
			BIT(HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI) |
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
			BIT(HAL_TRIGGER_CRYPT_PPI));
}
   189bc:	4770      	bx	lr
   189be:	bf00      	nop
   189c0:	4000b000 	.word	0x4000b000
   189c4:	0e700060 	.word	0x0e700060

000189c8 <radio_tmr_tifs_set>:
void radio_tmr_tifs_set(u32_t tifs)
{
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->TIFS = tifs;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	nrf_timer_cc_set(SW_SWITCH_TIMER,
   189c8:	4b03      	ldr	r3, [pc, #12]	; (189d8 <radio_tmr_tifs_set+0x10>)
   189ca:	4a04      	ldr	r2, [pc, #16]	; (189dc <radio_tmr_tifs_set+0x14>)
   189cc:	781b      	ldrb	r3, [r3, #0]
   189ce:	f503 73a8 	add.w	r3, r3, #336	; 0x150
   189d2:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
			 SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle), tifs);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   189d6:	4770      	bx	lr
   189d8:	2000abd2 	.word	0x2000abd2
   189dc:	40009000 	.word	0x40009000

000189e0 <radio_tmr_start>:

u32_t radio_tmr_start(u8_t trx, u32_t ticks_start, u32_t remainder)
{
   189e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if ((!(remainder / 1000000UL)) || (remainder & 0x80000000)) {
   189e2:	f5a2 2374 	sub.w	r3, r2, #999424	; 0xf4000
   189e6:	4c2f      	ldr	r4, [pc, #188]	; (18aa4 <radio_tmr_start+0xc4>)
   189e8:	f5a3 7310 	sub.w	r3, r3, #576	; 0x240
   189ec:	42a3      	cmp	r3, r4
		ticks_start--;
		remainder += 30517578UL;
   189ee:	bf88      	it	hi
   189f0:	f102 72e8 	addhi.w	r2, r2, #30408704	; 0x1d00000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   189f4:	4b2c      	ldr	r3, [pc, #176]	; (18aa8 <radio_tmr_start+0xc8>)
	}
	remainder /= 1000000UL;
   189f6:	4c2d      	ldr	r4, [pc, #180]	; (18aac <radio_tmr_start+0xcc>)
		remainder += 30517578UL;
   189f8:	bf84      	itt	hi
   189fa:	f502 32d4 	addhi.w	r2, r2, #108544	; 0x1a800
   189fe:	f502 72a5 	addhi.w	r2, r2, #330	; 0x14a
   18a02:	f04f 0501 	mov.w	r5, #1
	remainder /= 1000000UL;
   18a06:	fbb2 f4f4 	udiv	r4, r2, r4

	nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CLEAR);
	EVENT_TIMER->MODE = 0;
   18a0a:	f04f 0600 	mov.w	r6, #0
	EVENT_TIMER->PRESCALER = 4;
   18a0e:	f04f 0704 	mov.w	r7, #4
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
   18a12:	f04f 0202 	mov.w	r2, #2
   18a16:	601d      	str	r5, [r3, #0]
	EVENT_TIMER->MODE = 0;
   18a18:	f8c3 64f8 	str.w	r6, [r3, #1272]	; 0x4f8
	EVENT_TIMER->PRESCALER = 4;
   18a1c:	f8c3 7504 	str.w	r7, [r3, #1284]	; 0x504
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
   18a20:	f8c3 24fc 	str.w	r2, [r3, #1276]	; 0x4fc
    p_reg->CC[ch] = cc_val;
   18a24:	4a22      	ldr	r2, [pc, #136]	; (18ab0 <radio_tmr_start+0xd0>)
    p_reg->CC[cc_channel] = cc_value;
   18a26:	f8c3 4534 	str.w	r4, [r3, #1332]	; 0x534
		ticks_start--;
   18a2a:	bf88      	it	hi
   18a2c:	f101 31ff 	addhi.w	r1, r1, #4294967295	; 0xffffffff
   18a30:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
    p_reg->EVTENSET = mask;
   18a34:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   18a38:	f8c2 1344 	str.w	r1, [r2, #836]	; 0x344
    p_reg->CH[(uint32_t) channel].EEP = eep;
   18a3c:	491d      	ldr	r1, [pc, #116]	; (18ab4 <radio_tmr_start+0xd4>)
   18a3e:	f502 72a4 	add.w	r2, r2, #328	; 0x148
	EVENT_TIMER->MODE = 0;
   18a42:	3b0c      	subs	r3, #12
   18a44:	f8c1 2538 	str.w	r2, [r1, #1336]	; 0x538
    p_reg->CH[(uint32_t) channel].TEP = tep;
   18a48:	f8c1 353c 	str.w	r3, [r1, #1340]	; 0x53c
    p_reg->CHENSET = mask;
   18a4c:	2320      	movs	r3, #32
   18a4e:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
	nrf_rtc_event_enable(NRF_RTC0, RTC_EVTENSET_COMPARE2_Msk);

	hal_event_timer_start_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_EVENT_TIMER_START_PPI));

	hal_radio_enable_on_tick_ppi_config_and_enable(trx);
   18a52:	f7ff fd87 	bl	18564 <hal_radio_enable_on_tick_ppi_config_and_enable>
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	last_pdu_end_us = 0U;

#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_CLEAR);
	SW_SWITCH_TIMER->MODE = 0;
   18a56:	4b18      	ldr	r3, [pc, #96]	; (18ab8 <radio_tmr_start+0xd8>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   18a58:	4a18      	ldr	r2, [pc, #96]	; (18abc <radio_tmr_start+0xdc>)
   18a5a:	6015      	str	r5, [r2, #0]
   18a5c:	f8c3 6504 	str.w	r6, [r3, #1284]	; 0x504
	SW_SWITCH_TIMER->PRESCALER = 4;
   18a60:	f8c3 7510 	str.w	r7, [r3, #1296]	; 0x510
	SW_SWITCH_TIMER->BITMODE = 0; /* 16 bit */
   18a64:	f8c3 6508 	str.w	r6, [r3, #1288]	; 0x508
   18a68:	601d      	str	r5, [r3, #0]
    p_reg->CH[(uint32_t) channel].EEP = eep;
   18a6a:	f5a3 43fd 	sub.w	r3, r3, #32384	; 0x7e80
   18a6e:	3b74      	subs	r3, #116	; 0x74
   18a70:	f8c1 3548 	str.w	r3, [r1, #1352]	; 0x548
   18a74:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
   18a78:	3334      	adds	r3, #52	; 0x34
    p_reg->CH[(uint32_t) channel].TEP = tep;
   18a7a:	f8c1 254c 	str.w	r2, [r1, #1356]	; 0x54c
    p_reg->CH[(uint32_t) channel].EEP = eep;
   18a7e:	f8c1 3550 	str.w	r3, [r1, #1360]	; 0x550
    p_reg->CH[(uint32_t) channel].TEP = tep;
   18a82:	f503 33af 	add.w	r3, r3, #89600	; 0x15e00
   18a86:	33c4      	adds	r3, #196	; 0xc4
   18a88:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
    p_reg->CH[(uint32_t) channel].EEP = eep;
   18a8c:	f5a3 33af 	sub.w	r3, r3, #89600	; 0x15e00
   18a90:	3bc0      	subs	r3, #192	; 0xc0
   18a92:	f8c1 3558 	str.w	r3, [r1, #1368]	; 0x558
    p_reg->CH[(uint32_t) channel].TEP = tep;
   18a96:	f503 33af 	add.w	r3, r3, #89600	; 0x15e00
   18a9a:	33c8      	adds	r3, #200	; 0xc8
   18a9c:	f8c1 355c 	str.w	r3, [r1, #1372]	; 0x55c
	 */
#endif /* CONFIG_BT_CTLR_PHY_CODED && CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder;
}
   18aa0:	4620      	mov	r0, r4
   18aa2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   18aa4:	7ff0bdbf 	.word	0x7ff0bdbf
   18aa8:	4000800c 	.word	0x4000800c
   18aac:	000f4240 	.word	0x000f4240
   18ab0:	4000b000 	.word	0x4000b000
   18ab4:	4001f000 	.word	0x4001f000
   18ab8:	40009000 	.word	0x40009000
   18abc:	4000900c 	.word	0x4000900c

00018ac0 <radio_tmr_start_get>:
    return p_reg->CC[ch];
   18ac0:	4b01      	ldr	r3, [pc, #4]	; (18ac8 <radio_tmr_start_get+0x8>)
   18ac2:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}

u32_t radio_tmr_start_get(void)
{
	return nrf_rtc_cc_get(NRF_RTC0, 2);
}
   18ac6:	4770      	bx	lr
   18ac8:	4000b000 	.word	0x4000b000

00018acc <radio_tmr_stop>:
   18acc:	4a04      	ldr	r2, [pc, #16]	; (18ae0 <radio_tmr_stop+0x14>)
   18ace:	2301      	movs	r3, #1
   18ad0:	6013      	str	r3, [r2, #0]
   18ad2:	60d3      	str	r3, [r2, #12]
   18ad4:	320c      	adds	r2, #12
   18ad6:	f602 72f4 	addw	r2, r2, #4084	; 0xff4
   18ada:	6013      	str	r3, [r2, #0]
   18adc:	60d3      	str	r3, [r2, #12]

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_STOP);
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_SHUTDOWN);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   18ade:	4770      	bx	lr
   18ae0:	40008004 	.word	0x40008004

00018ae4 <radio_tmr_hcto_configure>:
    p_reg->CC[cc_channel] = cc_value;
   18ae4:	4b04      	ldr	r3, [pc, #16]	; (18af8 <radio_tmr_hcto_configure+0x14>)
   18ae6:	f8c3 0544 	str.w	r0, [r3, #1348]	; 0x544
    p_reg->CHENSET = mask;
   18aea:	f503 33b8 	add.w	r3, r3, #94208	; 0x17000
   18aee:	f04f 6288 	mov.w	r2, #71303168	; 0x4400000
   18af2:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_disable_on_hcto_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI) |
		BIT(HAL_RADIO_DISABLE_ON_HCTO_PPI));
}
   18af6:	4770      	bx	lr
   18af8:	40008000 	.word	0x40008000

00018afc <radio_tmr_aa_capture>:
    p_reg->CH[(uint32_t) channel].EEP = eep;
   18afc:	4b06      	ldr	r3, [pc, #24]	; (18b18 <radio_tmr_aa_capture+0x1c>)
   18afe:	4a07      	ldr	r2, [pc, #28]	; (18b1c <radio_tmr_aa_capture+0x20>)
   18b00:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    p_reg->CH[(uint32_t) channel].TEP = tep;
   18b04:	f502 42de 	add.w	r2, r2, #28416	; 0x6f00
   18b08:	3240      	adds	r2, #64	; 0x40
   18b0a:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    p_reg->CHENSET = mask;
   18b0e:	4a04      	ldr	r2, [pc, #16]	; (18b20 <radio_tmr_aa_capture+0x24>)
   18b10:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_ready_time_capture_ppi_config();
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_READY_TIME_CAPTURE_PPI) |
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI));
}
   18b14:	4770      	bx	lr
   18b16:	bf00      	nop
   18b18:	4001f000 	.word	0x4001f000
   18b1c:	40001100 	.word	0x40001100
   18b20:	04000040 	.word	0x04000040

00018b24 <radio_tmr_aa_get>:

u32_t radio_tmr_aa_get(void)
{
	return EVENT_TIMER->CC[1];
   18b24:	4b01      	ldr	r3, [pc, #4]	; (18b2c <radio_tmr_aa_get+0x8>)
   18b26:	f8d3 0544 	ldr.w	r0, [r3, #1348]	; 0x544
}
   18b2a:	4770      	bx	lr
   18b2c:	40008000 	.word	0x40008000

00018b30 <radio_tmr_aa_save>:

static u32_t radio_tmr_aa;

void radio_tmr_aa_save(u32_t aa)
{
	radio_tmr_aa = aa;
   18b30:	4b01      	ldr	r3, [pc, #4]	; (18b38 <radio_tmr_aa_save+0x8>)
   18b32:	6018      	str	r0, [r3, #0]
}
   18b34:	4770      	bx	lr
   18b36:	bf00      	nop
   18b38:	20001948 	.word	0x20001948

00018b3c <radio_tmr_aa_restore>:

u32_t radio_tmr_aa_restore(void)
{
	/* NOTE: we dont need to restore for now, but return the saved value. */
	return radio_tmr_aa;
}
   18b3c:	4b01      	ldr	r3, [pc, #4]	; (18b44 <radio_tmr_aa_restore+0x8>)
   18b3e:	6818      	ldr	r0, [r3, #0]
   18b40:	4770      	bx	lr
   18b42:	bf00      	nop
   18b44:	20001948 	.word	0x20001948

00018b48 <radio_tmr_ready_get>:

u32_t radio_tmr_ready_get(void)
{
	return EVENT_TIMER->CC[0];
   18b48:	4b01      	ldr	r3, [pc, #4]	; (18b50 <radio_tmr_ready_get+0x8>)
   18b4a:	f8d3 0540 	ldr.w	r0, [r3, #1344]	; 0x540
}
   18b4e:	4770      	bx	lr
   18b50:	40008000 	.word	0x40008000

00018b54 <radio_tmr_end_capture>:
   18b54:	4b02      	ldr	r3, [pc, #8]	; (18b60 <radio_tmr_end_capture+0xc>)
   18b56:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
   18b5a:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504

void radio_tmr_end_capture(void)
{
	hal_radio_end_time_capture_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_RADIO_END_TIME_CAPTURE_PPI));
}
   18b5e:	4770      	bx	lr
   18b60:	4001f000 	.word	0x4001f000

00018b64 <radio_tmr_end_get>:
u32_t radio_tmr_end_get(void)
{
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	return last_pdu_end_us;
#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	return EVENT_TIMER->CC[2];
   18b64:	4b01      	ldr	r3, [pc, #4]	; (18b6c <radio_tmr_end_get+0x8>)
   18b66:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
#endif /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
}
   18b6a:	4770      	bx	lr
   18b6c:	40008000 	.word	0x40008000

00018b70 <radio_tmr_tifs_base_get>:
   18b70:	4b01      	ldr	r3, [pc, #4]	; (18b78 <radio_tmr_tifs_base_get+0x8>)
   18b72:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
   18b76:	4770      	bx	lr
   18b78:	40008000 	.word	0x40008000

00018b7c <radio_ccm_rx_pkt_set>:
void *radio_ccm_rx_pkt_set(struct ccm *ccm, u8_t phy, void *pkt)
{

	u32_t mode;

	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   18b7c:	4b13      	ldr	r3, [pc, #76]	; (18bcc <radio_ccm_rx_pkt_set+0x50>)
{
   18b7e:	b570      	push	{r4, r5, r6, lr}
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   18b80:	2400      	movs	r4, #0
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
   18b82:	2502      	movs	r5, #2
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   18b84:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
			 CCM_MODE_DATARATE_Pos) &
			CCM_MODE_DATARATE_Msk;
		break;

	case BIT(1):
		mode |= (CCM_MODE_DATARATE_2Mbit <<
   18b88:	4e11      	ldr	r6, [pc, #68]	; (18bd0 <radio_ccm_rx_pkt_set+0x54>)
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
   18b8a:	f8c3 5500 	str.w	r5, [r3, #1280]	; 0x500
		mode |= (CCM_MODE_DATARATE_2Mbit <<
   18b8e:	4d11      	ldr	r5, [pc, #68]	; (18bd4 <radio_ccm_rx_pkt_set+0x58>)
   18b90:	2902      	cmp	r1, #2
   18b92:	bf14      	ite	ne
   18b94:	4629      	movne	r1, r5
   18b96:	4631      	moveq	r1, r6
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	}
#endif /* !CONFIG_SOC_SERIES_NRF51X */

	NRF_CCM->MODE = mode;
   18b98:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
	NRF_CCM->CNFPTR = (u32_t)ccm;
   18b9c:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
	NRF_CCM->INPTR = (u32_t)_pkt_scratch;
   18ba0:	480d      	ldr	r0, [pc, #52]	; (18bd8 <radio_ccm_rx_pkt_set+0x5c>)
   18ba2:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
	NRF_CCM->OUTPTR = (u32_t)pkt;
   18ba6:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
   18baa:	4a0c      	ldr	r2, [pc, #48]	; (18bdc <radio_ccm_rx_pkt_set+0x60>)
   18bac:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
   18bb0:	4a0b      	ldr	r2, [pc, #44]	; (18be0 <radio_ccm_rx_pkt_set+0x64>)
	NRF_CCM->SHORTS = 0;
   18bb2:	f8c3 4200 	str.w	r4, [r3, #512]	; 0x200
   18bb6:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
	NRF_CCM->EVENTS_ENDCRYPT = 0;
   18bba:	f8c3 4104 	str.w	r4, [r3, #260]	; 0x104
	NRF_CCM->EVENTS_ERROR = 0;
   18bbe:	f8c3 4108 	str.w	r4, [r3, #264]	; 0x108
   18bc2:	f8c2 1504 	str.w	r1, [r2, #1284]	; 0x504
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ccm_task_trigger(NRF_CCM_Type * p_reg,
                                            nrf_ccm_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   18bc6:	2201      	movs	r2, #1
   18bc8:	601a      	str	r2, [r3, #0]
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_TRIGGER_CRYPT_PPI));

	nrf_ccm_task_trigger(NRF_CCM, NRF_CCM_TASK_KSGEN);

	return _pkt_scratch;
}
   18bca:	bd70      	pop	{r4, r5, r6, pc}
   18bcc:	4000f000 	.word	0x4000f000
   18bd0:	01010001 	.word	0x01010001
   18bd4:	01000001 	.word	0x01000001
   18bd8:	2000183c 	.word	0x2000183c
   18bdc:	2000172c 	.word	0x2000172c
   18be0:	4001f000 	.word	0x4001f000

00018be4 <radio_ccm_tx_pkt_set>:

void *radio_ccm_tx_pkt_set(struct ccm *ccm, void *pkt)
{
   18be4:	b510      	push	{r4, lr}
	u32_t mode;

	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   18be6:	4b0e      	ldr	r3, [pc, #56]	; (18c20 <radio_ccm_tx_pkt_set+0x3c>)
   18be8:	2200      	movs	r2, #0
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
   18bea:	2402      	movs	r4, #2
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   18bec:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
   18bf0:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
	 * radio Tx on any PHY.
	 */
	mode |= (CCM_MODE_DATARATE_2Mbit << CCM_MODE_DATARATE_Pos) &
		CCM_MODE_DATARATE_Msk;
#endif
	NRF_CCM->MODE = mode;
   18bf4:	4c0b      	ldr	r4, [pc, #44]	; (18c24 <radio_ccm_tx_pkt_set+0x40>)
   18bf6:	f8c3 4504 	str.w	r4, [r3, #1284]	; 0x504
	NRF_CCM->CNFPTR = (u32_t)ccm;
   18bfa:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
	NRF_CCM->INPTR = (u32_t)pkt;
   18bfe:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
	NRF_CCM->OUTPTR = (u32_t)_pkt_scratch;
   18c02:	4809      	ldr	r0, [pc, #36]	; (18c28 <radio_ccm_tx_pkt_set+0x44>)
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
   18c04:	4909      	ldr	r1, [pc, #36]	; (18c2c <radio_ccm_tx_pkt_set+0x48>)
	NRF_CCM->OUTPTR = (u32_t)_pkt_scratch;
   18c06:	f8c3 0510 	str.w	r0, [r3, #1296]	; 0x510
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
   18c0a:	f8c3 1514 	str.w	r1, [r3, #1300]	; 0x514
	NRF_CCM->SHORTS = CCM_SHORTS_ENDKSGEN_CRYPT_Msk;
   18c0e:	2101      	movs	r1, #1
   18c10:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
	NRF_CCM->EVENTS_ENDCRYPT = 0;
   18c14:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	NRF_CCM->EVENTS_ERROR = 0;
   18c18:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   18c1c:	6019      	str	r1, [r3, #0]

	nrf_ccm_task_trigger(NRF_CCM, NRF_CCM_TASK_KSGEN);

	return _pkt_scratch;
}
   18c1e:	bd10      	pop	{r4, pc}
   18c20:	4000f000 	.word	0x4000f000
   18c24:	01010000 	.word	0x01010000
   18c28:	2000183c 	.word	0x2000183c
   18c2c:	2000172c 	.word	0x2000172c

00018c30 <radio_ccm_is_done>:
    return ((uint32_t)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE void nrf_ccm_int_enable(NRF_CCM_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   18c30:	4b0c      	ldr	r3, [pc, #48]	; (18c64 <radio_ccm_is_done+0x34>)
   18c32:	2202      	movs	r2, #2
   18c34:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

u32_t radio_ccm_is_done(void)
{
	nrf_ccm_int_enable(NRF_CCM, CCM_INTENSET_ENDCRYPT_Msk);
	while (NRF_CCM->EVENTS_ENDCRYPT == 0) {
   18c38:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
   18c3c:	b16a      	cbz	r2, 18c5a <radio_ccm_is_done+0x2a>
}

NRF_STATIC_INLINE void nrf_ccm_int_disable(NRF_CCM_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
   18c3e:	2202      	movs	r2, #2
   18c40:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   18c44:	4a08      	ldr	r2, [pc, #32]	; (18c68 <radio_ccm_is_done+0x38>)
   18c46:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   18c4a:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
		__WFE();
	}
	nrf_ccm_int_disable(NRF_CCM, CCM_INTENCLR_ENDCRYPT_Msk);
	NVIC_ClearPendingIRQ(nrfx_get_irq_number(NRF_CCM));

	return (NRF_CCM->EVENTS_ERROR == 0);
   18c4e:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
}
   18c52:	fab0 f080 	clz	r0, r0
   18c56:	0940      	lsrs	r0, r0, #5
   18c58:	4770      	bx	lr
		__WFE();
   18c5a:	bf20      	wfe
		__SEV();
   18c5c:	bf40      	sev
		__WFE();
   18c5e:	bf20      	wfe
   18c60:	e7ea      	b.n	18c38 <radio_ccm_is_done+0x8>
   18c62:	bf00      	nop
   18c64:	4000f000 	.word	0x4000f000
   18c68:	e000e100 	.word	0xe000e100

00018c6c <radio_ccm_mic_is_valid>:

u32_t radio_ccm_mic_is_valid(void)
{
	return (NRF_CCM->MICSTATUS != 0);
   18c6c:	4b03      	ldr	r3, [pc, #12]	; (18c7c <radio_ccm_mic_is_valid+0x10>)
   18c6e:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
   18c72:	3000      	adds	r0, #0
   18c74:	bf18      	it	ne
   18c76:	2001      	movne	r0, #1
   18c78:	4770      	bx	lr
   18c7a:	bf00      	nop
   18c7c:	4000f000 	.word	0x4000f000

00018c80 <radio_ar_configure>:

static u8_t MALIGN(4) _aar_scratch[3];

void radio_ar_configure(u32_t nirk, void *irk)
{
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
   18c80:	4b11      	ldr	r3, [pc, #68]	; (18cc8 <radio_ar_configure+0x48>)
{
   18c82:	b510      	push	{r4, lr}
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
   18c84:	2203      	movs	r2, #3
			  AAR_ENABLE_ENABLE_Msk;
	NRF_AAR->NIRK = nirk;
	NRF_AAR->IRKPTR = (u32_t)irk;
	NRF_AAR->ADDRPTR = (u32_t)NRF_RADIO->PACKETPTR - 1;
   18c86:	4c11      	ldr	r4, [pc, #68]	; (18ccc <radio_ar_configure+0x4c>)
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
   18c88:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
	NRF_AAR->NIRK = nirk;
   18c8c:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
	NRF_AAR->IRKPTR = (u32_t)irk;
   18c90:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
	NRF_AAR->ADDRPTR = (u32_t)NRF_RADIO->PACKETPTR - 1;
   18c94:	f8d4 2504 	ldr.w	r2, [r4, #1284]	; 0x504
   18c98:	3a01      	subs	r2, #1
   18c9a:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_AAR->SCRATCHPTR = (u32_t)&_aar_scratch[0];

	NRF_AAR->EVENTS_END = 0;
   18c9e:	2100      	movs	r1, #0
	NRF_AAR->SCRATCHPTR = (u32_t)&_aar_scratch[0];
   18ca0:	4a0b      	ldr	r2, [pc, #44]	; (18cd0 <radio_ar_configure+0x50>)
   18ca2:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
	NRF_AAR->EVENTS_RESOLVED = 0;
	NRF_AAR->EVENTS_NOTRESOLVED = 0;

	radio_bc_configure(64);
   18ca6:	2040      	movs	r0, #64	; 0x40
	NRF_AAR->EVENTS_END = 0;
   18ca8:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
	NRF_AAR->EVENTS_RESOLVED = 0;
   18cac:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
	NRF_AAR->EVENTS_NOTRESOLVED = 0;
   18cb0:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108
	radio_bc_configure(64);
   18cb4:	f7ff fe6c 	bl	18990 <radio_bc_configure>
   18cb8:	4b06      	ldr	r3, [pc, #24]	; (18cd4 <radio_ar_configure+0x54>)
	NRF_RADIO->EVENTS_BCMATCH = 0;
   18cba:	f8c4 1128 	str.w	r1, [r4, #296]	; 0x128
   18cbe:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   18cc2:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	radio_bc_status_reset();

	hal_trigger_aar_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_TRIGGER_AAR_PPI));
}
   18cc6:	bd10      	pop	{r4, pc}
   18cc8:	4000f000 	.word	0x4000f000
   18ccc:	40001000 	.word	0x40001000
   18cd0:	20001728 	.word	0x20001728
   18cd4:	4001f000 	.word	0x4001f000

00018cd8 <radio_ar_match_get>:

u32_t radio_ar_match_get(void)
{
	return NRF_AAR->STATUS;
   18cd8:	4b01      	ldr	r3, [pc, #4]	; (18ce0 <radio_ar_match_get+0x8>)
   18cda:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
   18cde:	4770      	bx	lr
   18ce0:	4000f000 	.word	0x4000f000

00018ce4 <radio_ar_status_reset>:
	NRF_RADIO->EVENTS_BCMATCH = 0;
   18ce4:	4a04      	ldr	r2, [pc, #16]	; (18cf8 <radio_ar_status_reset+0x14>)
   18ce6:	2300      	movs	r3, #0
   18ce8:	f8c2 3128 	str.w	r3, [r2, #296]	; 0x128

void radio_ar_status_reset(void)
{
	radio_bc_status_reset();

	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Disabled << AAR_ENABLE_ENABLE_Pos) &
   18cec:	f502 4260 	add.w	r2, r2, #57344	; 0xe000
   18cf0:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
			  AAR_ENABLE_ENABLE_Msk;
}
   18cf4:	4770      	bx	lr
   18cf6:	bf00      	nop
   18cf8:	40001000 	.word	0x40001000

00018cfc <radio_ar_has_match>:
	return (NRF_RADIO->EVENTS_BCMATCH != 0);
   18cfc:	4b08      	ldr	r3, [pc, #32]	; (18d20 <radio_ar_has_match+0x24>)
   18cfe:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128

u32_t radio_ar_has_match(void)
{
	return (radio_bc_has_match() &&
		NRF_AAR->EVENTS_END &&
		NRF_AAR->EVENTS_RESOLVED &&
   18d02:	b160      	cbz	r0, 18d1e <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_END &&
   18d04:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
   18d08:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
	return (radio_bc_has_match() &&
   18d0c:	b138      	cbz	r0, 18d1e <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_RESOLVED &&
   18d0e:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
		NRF_AAR->EVENTS_END &&
   18d12:	b120      	cbz	r0, 18d1e <radio_ar_has_match+0x22>
		!NRF_AAR->EVENTS_NOTRESOLVED);
   18d14:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
		NRF_AAR->EVENTS_RESOLVED &&
   18d18:	fab0 f080 	clz	r0, r0
   18d1c:	0940      	lsrs	r0, r0, #5
}
   18d1e:	4770      	bx	lr
   18d20:	40001000 	.word	0x40001000

00018d24 <mayfly_enable_cb>:

void mayfly_enable_cb(u8_t caller_id, u8_t callee_id, u8_t enable)
{
	(void)caller_id;

	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
   18d24:	2902      	cmp	r1, #2
{
   18d26:	b510      	push	{r4, lr}
   18d28:	4614      	mov	r4, r2
	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
   18d2a:	d00b      	beq.n	18d44 <mayfly_enable_cb+0x20>
   18d2c:	2325      	movs	r3, #37	; 0x25
   18d2e:	4a0a      	ldr	r2, [pc, #40]	; (18d58 <mayfly_enable_cb+0x34>)
   18d30:	490a      	ldr	r1, [pc, #40]	; (18d5c <mayfly_enable_cb+0x38>)
   18d32:	480b      	ldr	r0, [pc, #44]	; (18d60 <mayfly_enable_cb+0x3c>)
   18d34:	f007 f83d 	bl	1fdb2 <printk>
   18d38:	4040      	eors	r0, r0
   18d3a:	f380 8811 	msr	BASEPRI, r0
   18d3e:	f04f 0003 	mov.w	r0, #3
   18d42:	df02      	svc	2

	if (enable) {
		irq_enable(HAL_SWI_JOB_IRQ);
   18d44:	200b      	movs	r0, #11
	if (enable) {
   18d46:	b11c      	cbz	r4, 18d50 <mayfly_enable_cb+0x2c>
	} else {
		irq_disable(HAL_SWI_JOB_IRQ);
	}
}
   18d48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_enable(HAL_SWI_JOB_IRQ);
   18d4c:	f7ed bed8 	b.w	6b00 <arch_irq_enable>
}
   18d50:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_disable(HAL_SWI_JOB_IRQ);
   18d54:	f7ed bee4 	b.w	6b20 <arch_irq_disable>
   18d58:	00064d00 	.word	0x00064d00
   18d5c:	00064d47 	.word	0x00064d47
   18d60:	000632fe 	.word	0x000632fe

00018d64 <mayfly_is_enabled>:

u32_t mayfly_is_enabled(u8_t caller_id, u8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
   18d64:	2901      	cmp	r1, #1
{
   18d66:	b508      	push	{r3, lr}
	switch (callee_id) {
   18d68:	d015      	beq.n	18d96 <mayfly_is_enabled+0x32>
   18d6a:	b179      	cbz	r1, 18d8c <mayfly_is_enabled+0x28>
   18d6c:	2902      	cmp	r1, #2
   18d6e:	d012      	beq.n	18d96 <mayfly_is_enabled+0x32>

	case MAYFLY_CALL_ID_JOB:
		return irq_is_enabled(HAL_SWI_JOB_IRQ);

	default:
		LL_ASSERT(0);
   18d70:	233f      	movs	r3, #63	; 0x3f
   18d72:	4a0a      	ldr	r2, [pc, #40]	; (18d9c <mayfly_is_enabled+0x38>)
   18d74:	490a      	ldr	r1, [pc, #40]	; (18da0 <mayfly_is_enabled+0x3c>)
   18d76:	480b      	ldr	r0, [pc, #44]	; (18da4 <mayfly_is_enabled+0x40>)
   18d78:	f007 f81b 	bl	1fdb2 <printk>
   18d7c:	4040      	eors	r0, r0
   18d7e:	f380 8811 	msr	BASEPRI, r0
   18d82:	f04f 0003 	mov.w	r0, #3
   18d86:	df02      	svc	2
		break;
	}

	return 0;
}
   18d88:	2000      	movs	r0, #0
   18d8a:	bd08      	pop	{r3, pc}
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);
   18d8c:	2018      	movs	r0, #24
}
   18d8e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		return irq_is_enabled(HAL_SWI_WORKER_IRQ);
   18d92:	f7ed bed9 	b.w	6b48 <arch_irq_is_enabled>
   18d96:	200b      	movs	r0, #11
   18d98:	e7f9      	b.n	18d8e <mayfly_is_enabled+0x2a>
   18d9a:	bf00      	nop
   18d9c:	00064d00 	.word	0x00064d00
   18da0:	00065948 	.word	0x00065948
   18da4:	000632fe 	.word	0x000632fe

00018da8 <mayfly_pend>:

void mayfly_pend(u8_t caller_id, u8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
   18da8:	2901      	cmp	r1, #1
{
   18daa:	b508      	push	{r3, lr}
	switch (callee_id) {
   18dac:	d015      	beq.n	18dda <mayfly_pend+0x32>
   18dae:	b171      	cbz	r1, 18dce <mayfly_pend+0x26>
   18db0:	2902      	cmp	r1, #2
   18db2:	d012      	beq.n	18dda <mayfly_pend+0x32>
	case MAYFLY_CALL_ID_JOB:
		hal_swi_job_pend();
		break;

	default:
		LL_ASSERT(0);
   18db4:	237b      	movs	r3, #123	; 0x7b
   18db6:	4a0b      	ldr	r2, [pc, #44]	; (18de4 <mayfly_pend+0x3c>)
   18db8:	490b      	ldr	r1, [pc, #44]	; (18de8 <mayfly_pend+0x40>)
   18dba:	480c      	ldr	r0, [pc, #48]	; (18dec <mayfly_pend+0x44>)
   18dbc:	f006 fff9 	bl	1fdb2 <printk>
   18dc0:	4040      	eors	r0, r0
   18dc2:	f380 8811 	msr	BASEPRI, r0
   18dc6:	f04f 0003 	mov.w	r0, #3
   18dca:	df02      	svc	2
		break;
	}
}
   18dcc:	e004      	b.n	18dd8 <mayfly_pend+0x30>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   18dce:	4b08      	ldr	r3, [pc, #32]	; (18df0 <mayfly_pend+0x48>)
   18dd0:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   18dd4:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   18dd8:	bd08      	pop	{r3, pc}
   18dda:	4b05      	ldr	r3, [pc, #20]	; (18df0 <mayfly_pend+0x48>)
   18ddc:	f44f 6200 	mov.w	r2, #2048	; 0x800
   18de0:	e7f8      	b.n	18dd4 <mayfly_pend+0x2c>
   18de2:	bf00      	nop
   18de4:	00064d00 	.word	0x00064d00
   18de8:	00065948 	.word	0x00065948
   18dec:	000632fe 	.word	0x000632fe
   18df0:	e000e100 	.word	0xe000e100

00018df4 <hal_ticker_instance0_caller_id_get>:

u8_t hal_ticker_instance0_caller_id_get(u8_t user_id)
{
	u8_t caller_id;

	LL_ASSERT(user_id < sizeof(caller_id_lut));
   18df4:	2803      	cmp	r0, #3
{
   18df6:	b510      	push	{r4, lr}
   18df8:	4604      	mov	r4, r0
	LL_ASSERT(user_id < sizeof(caller_id_lut));
   18dfa:	d90b      	bls.n	18e14 <hal_ticker_instance0_caller_id_get+0x20>
   18dfc:	2338      	movs	r3, #56	; 0x38
   18dfe:	4a0e      	ldr	r2, [pc, #56]	; (18e38 <hal_ticker_instance0_caller_id_get+0x44>)
   18e00:	490e      	ldr	r1, [pc, #56]	; (18e3c <hal_ticker_instance0_caller_id_get+0x48>)
   18e02:	480f      	ldr	r0, [pc, #60]	; (18e40 <hal_ticker_instance0_caller_id_get+0x4c>)
   18e04:	f006 ffd5 	bl	1fdb2 <printk>
   18e08:	4040      	eors	r0, r0
   18e0a:	f380 8811 	msr	BASEPRI, r0
   18e0e:	f04f 0003 	mov.w	r0, #3
   18e12:	df02      	svc	2

	caller_id = caller_id_lut[user_id];
   18e14:	4b0b      	ldr	r3, [pc, #44]	; (18e44 <hal_ticker_instance0_caller_id_get+0x50>)
   18e16:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
   18e18:	b95c      	cbnz	r4, 18e32 <hal_ticker_instance0_caller_id_get+0x3e>
   18e1a:	233b      	movs	r3, #59	; 0x3b
   18e1c:	4a06      	ldr	r2, [pc, #24]	; (18e38 <hal_ticker_instance0_caller_id_get+0x44>)
   18e1e:	490a      	ldr	r1, [pc, #40]	; (18e48 <hal_ticker_instance0_caller_id_get+0x54>)
   18e20:	4807      	ldr	r0, [pc, #28]	; (18e40 <hal_ticker_instance0_caller_id_get+0x4c>)
   18e22:	f006 ffc6 	bl	1fdb2 <printk>
   18e26:	4040      	eors	r0, r0
   18e28:	f380 8811 	msr	BASEPRI, r0
   18e2c:	f04f 0003 	mov.w	r0, #3
   18e30:	df02      	svc	2

	return caller_id;
}
   18e32:	4620      	mov	r0, r4
   18e34:	bd10      	pop	{r4, pc}
   18e36:	bf00      	nop
   18e38:	00064d6d 	.word	0x00064d6d
   18e3c:	00064db4 	.word	0x00064db4
   18e40:	000632fe 	.word	0x000632fe
   18e44:	00064d69 	.word	0x00064d69
   18e48:	00064dd4 	.word	0x00064dd4

00018e4c <hal_ticker_instance0_sched>:
{
	/* return value not checked as we allow multiple calls to schedule
	 * before being actually needing the work to complete before new
	 * schedule.
	 */
	switch (caller_id) {
   18e4c:	3801      	subs	r0, #1
{
   18e4e:	b510      	push	{r4, lr}
   18e50:	461c      	mov	r4, r3
	switch (caller_id) {
   18e52:	2804      	cmp	r0, #4
   18e54:	d845      	bhi.n	18ee2 <hal_ticker_instance0_sched+0x96>
   18e56:	e8df f000 	tbb	[pc, r0]
   18e5a:	1a03      	.short	0x1a03
   18e5c:	2c23      	.short	0x2c23
   18e5e:	3b          	.byte	0x3b
   18e5f:	00          	.byte	0x00
#if defined(CONFIG_BT_LL_SW_SPLIT)
	case TICKER_CALL_ID_ISR:
		switch (callee_id) {
   18e60:	2904      	cmp	r1, #4
   18e62:	d107      	bne.n	18e74 <hal_ticker_instance0_sched+0x28>
		{
			static memq_link_t link;
			static struct mayfly m = {0, 0, &link, NULL,
						  ticker_job};

			m.param = instance;
   18e64:	4b20      	ldr	r3, [pc, #128]	; (18ee8 <hal_ticker_instance0_sched+0x9c>)

			/* TODO: scheduler lock, if preemptive threads used */
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
   18e66:	2102      	movs	r1, #2
			m.param = instance;
   18e68:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
   18e6a:	2000      	movs	r0, #0

	default:
		LL_ASSERT(0);
		break;
	}
}
   18e6c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
   18e70:	f7f7 bbe0 	b.w	10634 <mayfly_enqueue>
			LL_ASSERT(0);
   18e74:	235c      	movs	r3, #92	; 0x5c
		LL_ASSERT(0);
   18e76:	4a1d      	ldr	r2, [pc, #116]	; (18eec <hal_ticker_instance0_sched+0xa0>)
   18e78:	491d      	ldr	r1, [pc, #116]	; (18ef0 <hal_ticker_instance0_sched+0xa4>)
   18e7a:	481e      	ldr	r0, [pc, #120]	; (18ef4 <hal_ticker_instance0_sched+0xa8>)
   18e7c:	f006 ff99 	bl	1fdb2 <printk>
   18e80:	4040      	eors	r0, r0
   18e82:	f380 8811 	msr	BASEPRI, r0
   18e86:	f04f 0003 	mov.w	r0, #3
   18e8a:	df02      	svc	2
}
   18e8c:	bd10      	pop	{r4, pc}
		switch (callee_id) {
   18e8e:	2903      	cmp	r1, #3
   18e90:	d104      	bne.n	18e9c <hal_ticker_instance0_sched+0x50>
			m.param = instance;
   18e92:	4b19      	ldr	r3, [pc, #100]	; (18ef8 <hal_ticker_instance0_sched+0xac>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
   18e94:	2101      	movs	r1, #1
			m.param = instance;
   18e96:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   18e98:	4608      	mov	r0, r1
   18e9a:	e7e7      	b.n	18e6c <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
   18e9c:	2374      	movs	r3, #116	; 0x74
   18e9e:	e7ea      	b.n	18e76 <hal_ticker_instance0_sched+0x2a>
		switch (callee_id) {
   18ea0:	2904      	cmp	r1, #4
   18ea2:	d104      	bne.n	18eae <hal_ticker_instance0_sched+0x62>
			m.param = instance;
   18ea4:	4b15      	ldr	r3, [pc, #84]	; (18efc <hal_ticker_instance0_sched+0xb0>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
   18ea6:	2102      	movs	r1, #2
			m.param = instance;
   18ea8:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
   18eaa:	2001      	movs	r0, #1
   18eac:	e7de      	b.n	18e6c <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
   18eae:	238b      	movs	r3, #139	; 0x8b
   18eb0:	e7e1      	b.n	18e76 <hal_ticker_instance0_sched+0x2a>
		switch (callee_id) {
   18eb2:	2903      	cmp	r1, #3
   18eb4:	d003      	beq.n	18ebe <hal_ticker_instance0_sched+0x72>
   18eb6:	2904      	cmp	r1, #4
   18eb8:	d006      	beq.n	18ec8 <hal_ticker_instance0_sched+0x7c>
			LL_ASSERT(0);
   18eba:	23b1      	movs	r3, #177	; 0xb1
   18ebc:	e7db      	b.n	18e76 <hal_ticker_instance0_sched+0x2a>
			m.param = instance;
   18ebe:	4b10      	ldr	r3, [pc, #64]	; (18f00 <hal_ticker_instance0_sched+0xb4>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   18ec0:	2101      	movs	r1, #1
			m.param = instance;
   18ec2:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   18ec4:	2002      	movs	r0, #2
   18ec6:	e7d1      	b.n	18e6c <hal_ticker_instance0_sched+0x20>
			m.param = instance;
   18ec8:	4b0e      	ldr	r3, [pc, #56]	; (18f04 <hal_ticker_instance0_sched+0xb8>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   18eca:	2102      	movs	r1, #2
			m.param = instance;
   18ecc:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   18ece:	e7e3      	b.n	18e98 <hal_ticker_instance0_sched+0x4c>
		switch (callee_id) {
   18ed0:	2904      	cmp	r1, #4
   18ed2:	d104      	bne.n	18ede <hal_ticker_instance0_sched+0x92>
			m.param = instance;
   18ed4:	4b0c      	ldr	r3, [pc, #48]	; (18f08 <hal_ticker_instance0_sched+0xbc>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
   18ed6:	2102      	movs	r1, #2
			m.param = instance;
   18ed8:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
   18eda:	2003      	movs	r0, #3
   18edc:	e7c6      	b.n	18e6c <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
   18ede:	23c9      	movs	r3, #201	; 0xc9
   18ee0:	e7c9      	b.n	18e76 <hal_ticker_instance0_sched+0x2a>
		LL_ASSERT(0);
   18ee2:	23cf      	movs	r3, #207	; 0xcf
   18ee4:	e7c7      	b.n	18e76 <hal_ticker_instance0_sched+0x2a>
   18ee6:	bf00      	nop
   18ee8:	2000eac8 	.word	0x2000eac8
   18eec:	00064d6d 	.word	0x00064d6d
   18ef0:	00065948 	.word	0x00065948
   18ef4:	000632fe 	.word	0x000632fe
   18ef8:	2000ead8 	.word	0x2000ead8
   18efc:	2000eae8 	.word	0x2000eae8
   18f00:	2000eaf8 	.word	0x2000eaf8
   18f04:	2000eb08 	.word	0x2000eb08
   18f08:	2000eb18 	.word	0x2000eb18

00018f0c <net_buf_pool_get>:
extern struct net_buf_pool _net_buf_pool_list[];

struct net_buf_pool *net_buf_pool_get(int id)
{
	return &_net_buf_pool_list[id];
}
   18f0c:	4b02      	ldr	r3, [pc, #8]	; (18f18 <net_buf_pool_get+0xc>)
   18f0e:	2224      	movs	r2, #36	; 0x24
   18f10:	fb02 3000 	mla	r0, r2, r0, r3
   18f14:	4770      	bx	lr
   18f16:	bf00      	nop
   18f18:	2000f008 	.word	0x2000f008

00018f1c <net_buf_id>:
	return pool - _net_buf_pool_list;
}

int net_buf_id(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   18f1c:	7983      	ldrb	r3, [r0, #6]

	return buf - pool->__bufs;
   18f1e:	4a05      	ldr	r2, [pc, #20]	; (18f34 <net_buf_id+0x18>)
   18f20:	2124      	movs	r1, #36	; 0x24
   18f22:	fb01 2303 	mla	r3, r1, r3, r2
   18f26:	6a1b      	ldr	r3, [r3, #32]
   18f28:	1ac0      	subs	r0, r0, r3
}
   18f2a:	4b03      	ldr	r3, [pc, #12]	; (18f38 <net_buf_id+0x1c>)
	return buf - pool->__bufs;
   18f2c:	10c0      	asrs	r0, r0, #3
}
   18f2e:	4358      	muls	r0, r3
   18f30:	4770      	bx	lr
   18f32:	bf00      	nop
   18f34:	2000f008 	.word	0x2000f008
   18f38:	aaaaaaab 	.word	0xaaaaaaab

00018f3c <fixed_data_alloc>:
	.ref   = generic_data_ref,
	.unref = mem_pool_data_unref,
};

static u8_t *fixed_data_alloc(struct net_buf *buf, size_t *size, s32_t timeout)
{
   18f3c:	b510      	push	{r4, lr}
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   18f3e:	4a0a      	ldr	r2, [pc, #40]	; (18f68 <fixed_data_alloc+0x2c>)
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   18f40:	7983      	ldrb	r3, [r0, #6]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   18f42:	2424      	movs	r4, #36	; 0x24
   18f44:	fb04 2303 	mla	r3, r4, r3, r2

	*size = MIN(fixed->data_size, *size);
   18f48:	680a      	ldr	r2, [r1, #0]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   18f4a:	69db      	ldr	r3, [r3, #28]
   18f4c:	685c      	ldr	r4, [r3, #4]
	*size = MIN(fixed->data_size, *size);
   18f4e:	6823      	ldr	r3, [r4, #0]
   18f50:	429a      	cmp	r2, r3
   18f52:	bf94      	ite	ls
   18f54:	600a      	strls	r2, [r1, #0]
   18f56:	600b      	strhi	r3, [r1, #0]

	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
   18f58:	f7ff ffe0 	bl	18f1c <net_buf_id>
   18f5c:	e9d4 2300 	ldrd	r2, r3, [r4]
}
   18f60:	fb02 3000 	mla	r0, r2, r0, r3
   18f64:	bd10      	pop	{r4, pc}
   18f66:	bf00      	nop
   18f68:	2000f008 	.word	0x2000f008

00018f6c <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  s32_t timeout)
#endif
{
   18f6c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   18f70:	4605      	mov	r5, r0
   18f72:	9101      	str	r1, [sp, #4]
   18f74:	4616      	mov	r6, r2
	u32_t alloc_start = k_uptime_get_32();
   18f76:	f00b fef7 	bl	24d68 <k_uptime_get_32>
   18f7a:	4607      	mov	r7, r0
	__asm__ volatile(
   18f7c:	f04f 0320 	mov.w	r3, #32
   18f80:	f3ef 8811 	mrs	r8, BASEPRI
   18f84:	f383 8811 	msr	BASEPRI, r3
   18f88:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
   18f8c:	8aeb      	ldrh	r3, [r5, #22]
   18f8e:	2b00      	cmp	r3, #0
   18f90:	d046      	beq.n	19020 <net_buf_alloc_len+0xb4>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
   18f92:	8aaa      	ldrh	r2, [r5, #20]
   18f94:	429a      	cmp	r2, r3
   18f96:	d92f      	bls.n	18ff8 <net_buf_alloc_len+0x8c>
	return z_impl_k_queue_get(queue, timeout);
   18f98:	2100      	movs	r1, #0
   18f9a:	4628      	mov	r0, r5
   18f9c:	f00e fddc 	bl	27b58 <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
   18fa0:	4604      	mov	r4, r0
   18fa2:	b348      	cbz	r0, 18ff8 <net_buf_alloc_len+0x8c>
	__asm__ volatile(
   18fa4:	f388 8811 	msr	BASEPRI, r8
   18fa8:	f3bf 8f6f 	isb	sy
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
   18fac:	9b01      	ldr	r3, [sp, #4]
   18fae:	2b00      	cmp	r3, #0
   18fb0:	d045      	beq.n	1903e <net_buf_alloc_len+0xd2>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (timeout != K_NO_WAIT && timeout != K_FOREVER) {
   18fb2:	1c73      	adds	r3, r6, #1
   18fb4:	2b01      	cmp	r3, #1
   18fb6:	d906      	bls.n	18fc6 <net_buf_alloc_len+0x5a>
			u32_t diff = k_uptime_get_32() - alloc_start;
   18fb8:	f00b fed6 	bl	24d68 <k_uptime_get_32>
   18fbc:	1bc0      	subs	r0, r0, r7

			timeout -= MIN(timeout, diff);
   18fbe:	42b0      	cmp	r0, r6
   18fc0:	bf94      	ite	ls
   18fc2:	1a36      	subls	r6, r6, r0
   18fc4:	1bb6      	subhi	r6, r6, r6
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   18fc6:	79a3      	ldrb	r3, [r4, #6]
	return pool->alloc->cb->alloc(buf, size, timeout);
   18fc8:	4f22      	ldr	r7, [pc, #136]	; (19054 <net_buf_alloc_len+0xe8>)
   18fca:	2224      	movs	r2, #36	; 0x24
   18fcc:	fb02 7303 	mla	r3, r2, r3, r7
   18fd0:	a901      	add	r1, sp, #4
   18fd2:	69db      	ldr	r3, [r3, #28]
   18fd4:	681b      	ldr	r3, [r3, #0]
   18fd6:	4632      	mov	r2, r6
   18fd8:	681b      	ldr	r3, [r3, #0]
   18fda:	4620      	mov	r0, r4
   18fdc:	4798      	blx	r3
   18fde:	4605      	mov	r5, r0
		}

		buf->__buf = data_alloc(buf, &size, timeout);
   18fe0:	6120      	str	r0, [r4, #16]
		if (!buf->__buf) {
   18fe2:	bb68      	cbnz	r0, 19040 <net_buf_alloc_len+0xd4>
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	k_lifo_put(&pool->free, buf);
   18fe4:	79a0      	ldrb	r0, [r4, #6]
   18fe6:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   18fea:	4621      	mov	r1, r4
   18fec:	eb07 0080 	add.w	r0, r7, r0, lsl #2
   18ff0:	f00e fd8e 	bl	27b10 <k_queue_prepend>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
   18ff4:	462c      	mov	r4, r5
   18ff6:	e01e      	b.n	19036 <net_buf_alloc_len+0xca>
		uninit_count = pool->uninit_count--;
   18ff8:	8aeb      	ldrh	r3, [r5, #22]
   18ffa:	1e5a      	subs	r2, r3, #1
   18ffc:	82ea      	strh	r2, [r5, #22]
   18ffe:	f388 8811 	msr	BASEPRI, r8
   19002:	f3bf 8f6f 	isb	sy
	buf = &pool->__bufs[pool->buf_count - uninit_count];
   19006:	8aac      	ldrh	r4, [r5, #20]
   19008:	1ae4      	subs	r4, r4, r3
   1900a:	6a2b      	ldr	r3, [r5, #32]
   1900c:	2218      	movs	r2, #24
   1900e:	fb02 3404 	mla	r4, r2, r4, r3
	return pool - _net_buf_pool_list;
   19012:	4b10      	ldr	r3, [pc, #64]	; (19054 <net_buf_alloc_len+0xe8>)
   19014:	1aed      	subs	r5, r5, r3
   19016:	4b10      	ldr	r3, [pc, #64]	; (19058 <net_buf_alloc_len+0xec>)
   19018:	10ad      	asrs	r5, r5, #2
   1901a:	435d      	muls	r5, r3
	buf->pool_id = pool_id(pool);
   1901c:	71a5      	strb	r5, [r4, #6]
		goto success;
   1901e:	e7c5      	b.n	18fac <net_buf_alloc_len+0x40>
   19020:	f388 8811 	msr	BASEPRI, r8
   19024:	f3bf 8f6f 	isb	sy
   19028:	4631      	mov	r1, r6
   1902a:	4628      	mov	r0, r5
   1902c:	f00e fd94 	bl	27b58 <z_impl_k_queue_get>
	if (!buf) {
   19030:	4604      	mov	r4, r0
   19032:	2800      	cmp	r0, #0
   19034:	d1ba      	bne.n	18fac <net_buf_alloc_len+0x40>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	pool->avail_count--;
	__ASSERT_NO_MSG(pool->avail_count >= 0);
#endif
	return buf;
}
   19036:	4620      	mov	r0, r4
   19038:	b002      	add	sp, #8
   1903a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		buf->__buf = NULL;
   1903e:	6123      	str	r3, [r4, #16]
	buf->frags = NULL;
   19040:	2300      	movs	r3, #0
	buf->ref   = 1U;
   19042:	2201      	movs	r2, #1
	buf->frags = NULL;
   19044:	6023      	str	r3, [r4, #0]
	buf->ref   = 1U;
   19046:	80a2      	strh	r2, [r4, #4]
	buf->len  = 0U;
   19048:	81a3      	strh	r3, [r4, #12]
	buf->size  = size;
   1904a:	9a01      	ldr	r2, [sp, #4]
	buf->data = buf->__buf;
   1904c:	6923      	ldr	r3, [r4, #16]
   1904e:	81e2      	strh	r2, [r4, #14]
   19050:	60a3      	str	r3, [r4, #8]
	return buf;
   19052:	e7f0      	b.n	19036 <net_buf_alloc_len+0xca>
   19054:	2000f008 	.word	0x2000f008
   19058:	38e38e39 	.word	0x38e38e39

0001905c <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
   1905c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   19060:	4d17      	ldr	r5, [pc, #92]	; (190c0 <net_buf_unref+0x64>)
   19062:	4604      	mov	r4, r0
			return;
		}

		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
   19064:	2600      	movs	r6, #0
	pool->alloc->cb->unref(buf, data);
   19066:	2724      	movs	r7, #36	; 0x24
	while (buf) {
   19068:	b90c      	cbnz	r4, 1906e <net_buf_unref+0x12>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
   1906a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (--buf->ref > 0) {
   1906e:	7923      	ldrb	r3, [r4, #4]
		struct net_buf *frags = buf->frags;
   19070:	f8d4 8000 	ldr.w	r8, [r4]
		if (--buf->ref > 0) {
   19074:	3b01      	subs	r3, #1
   19076:	b2db      	uxtb	r3, r3
   19078:	7123      	strb	r3, [r4, #4]
   1907a:	2b00      	cmp	r3, #0
   1907c:	d1f5      	bne.n	1906a <net_buf_unref+0xe>
		if (buf->__buf) {
   1907e:	6921      	ldr	r1, [r4, #16]
   19080:	b159      	cbz	r1, 1909a <net_buf_unref+0x3e>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
   19082:	7963      	ldrb	r3, [r4, #5]
   19084:	079b      	lsls	r3, r3, #30
   19086:	d407      	bmi.n	19098 <net_buf_unref+0x3c>
	pool->alloc->cb->unref(buf, data);
   19088:	79a3      	ldrb	r3, [r4, #6]
   1908a:	fb07 5303 	mla	r3, r7, r3, r5
   1908e:	4620      	mov	r0, r4
   19090:	69db      	ldr	r3, [r3, #28]
   19092:	681b      	ldr	r3, [r3, #0]
   19094:	689b      	ldr	r3, [r3, #8]
   19096:	4798      	blx	r3
			buf->__buf = NULL;
   19098:	6126      	str	r6, [r4, #16]
		pool = net_buf_pool_get(buf->pool_id);
   1909a:	79a0      	ldrb	r0, [r4, #6]
		buf->data = NULL;
   1909c:	60a6      	str	r6, [r4, #8]
		if (pool->destroy) {
   1909e:	fb07 5300 	mla	r3, r7, r0, r5
		buf->frags = NULL;
   190a2:	6026      	str	r6, [r4, #0]
		if (pool->destroy) {
   190a4:	699b      	ldr	r3, [r3, #24]
   190a6:	b11b      	cbz	r3, 190b0 <net_buf_unref+0x54>
			pool->destroy(buf);
   190a8:	4620      	mov	r0, r4
   190aa:	4798      	blx	r3
{
   190ac:	4644      	mov	r4, r8
   190ae:	e7db      	b.n	19068 <net_buf_unref+0xc>
	k_lifo_put(&pool->free, buf);
   190b0:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   190b4:	4621      	mov	r1, r4
   190b6:	eb05 0080 	add.w	r0, r5, r0, lsl #2
   190ba:	f00e fd29 	bl	27b10 <k_queue_prepend>
   190be:	e7f5      	b.n	190ac <net_buf_unref+0x50>
   190c0:	2000f008 	.word	0x2000f008

000190c4 <nrf_gpio_pin_port_decode.isra.8.part.9>:
 *
 * @param[in,out] p_pin Pointer to the absolute pin number overriden by the pin number that is relative to the port.
 *
 * @return Pointer to port register set.
 */
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
   190c4:	b508      	push	{r3, lr}
{
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   190c6:	4a03      	ldr	r2, [pc, #12]	; (190d4 <nrf_gpio_pin_port_decode.isra.8.part.9+0x10>)
   190c8:	4b03      	ldr	r3, [pc, #12]	; (190d8 <nrf_gpio_pin_port_decode.isra.8.part.9+0x14>)
   190ca:	4804      	ldr	r0, [pc, #16]	; (190dc <nrf_gpio_pin_port_decode.isra.8.part.9+0x18>)
   190cc:	f44f 71ed 	mov.w	r1, #474	; 0x1da
   190d0:	f7e7 f870 	bl	1b4 <__assert_func>
   190d4:	00064dfe 	.word	0x00064dfe
   190d8:	00064e17 	.word	0x00064e17
   190dc:	00064e25 	.word	0x00064e25

000190e0 <gpio_nrfx_init>:
#endif
	}
}

static int gpio_nrfx_init(struct device *port)
{
   190e0:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
   190e2:	4b09      	ldr	r3, [pc, #36]	; (19108 <gpio_nrfx_init+0x28>)
   190e4:	781a      	ldrb	r2, [r3, #0]
   190e6:	b96a      	cbnz	r2, 19104 <gpio_nrfx_init+0x24>
		gpio_initialized = true;
   190e8:	2101      	movs	r1, #1
   190ea:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0,
   190ec:	2006      	movs	r0, #6
   190ee:	2105      	movs	r1, #5
   190f0:	f7ed fd38 	bl	6b64 <z_arm_irq_priority_set>
			    DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0_PRIORITY,
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0);
   190f4:	2006      	movs	r0, #6
   190f6:	f7ed fd03 	bl	6b00 <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   190fa:	4b04      	ldr	r3, [pc, #16]	; (1910c <gpio_nrfx_init+0x2c>)
   190fc:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   19100:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
   19104:	2000      	movs	r0, #0
   19106:	bd08      	pop	{r3, pc}
   19108:	2000abd3 	.word	0x2000abd3
   1910c:	40006000 	.word	0x40006000

00019110 <gpiote_pin_int_cfg>:
{
   19110:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return port->config->config_info;
   19112:	6803      	ldr	r3, [r0, #0]
	struct gpio_nrfx_data *data = get_port_data(port);
   19114:	6887      	ldr	r7, [r0, #8]
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   19116:	689b      	ldr	r3, [r3, #8]
   19118:	f001 051f 	and.w	r5, r1, #31
{
   1911c:	460e      	mov	r6, r1
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
   1911e:	494e      	ldr	r1, [pc, #312]	; (19258 <gpiote_pin_int_cfg+0x148>)
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   19120:	791b      	ldrb	r3, [r3, #4]
   19122:	f8d1 2304 	ldr.w	r2, [r1, #772]	; 0x304
   19126:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
   1912a:	b2d2      	uxtb	r2, r2
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   1912c:	2300      	movs	r3, #0
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   1912e:	f503 70a2 	add.w	r0, r3, #324	; 0x144
   19132:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
   19136:	f3c0 2004 	ubfx	r0, r0, #8, #5
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
   1913a:	4285      	cmp	r5, r0
   1913c:	d170      	bne.n	19220 <gpiote_pin_int_cfg+0x110>
		    && (intenset & BIT(i))) {
   1913e:	fa22 f003 	lsr.w	r0, r2, r3
   19142:	07c0      	lsls	r0, r0, #31
   19144:	d56c      	bpl.n	19220 <gpiote_pin_int_cfg+0x110>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
   19146:	009a      	lsls	r2, r3, #2
   19148:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   1914c:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
   19150:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   19154:	f020 0001 	bic.w	r0, r0, #1
   19158:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
   1915c:	2201      	movs	r2, #1
   1915e:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENCLR = mask;
   19162:	f8c1 3308 	str.w	r3, [r1, #776]	; 0x308
	nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   19166:	4628      	mov	r0, r5
   19168:	2100      	movs	r1, #0
   1916a:	f00b fee4 	bl	24f36 <nrf_gpio_cfg_sense_set>
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
   1916e:	68b8      	ldr	r0, [r7, #8]
   19170:	40f0      	lsrs	r0, r6
   19172:	f010 0001 	ands.w	r0, r0, #1
   19176:	d051      	beq.n	1921c <gpiote_pin_int_cfg+0x10c>
   19178:	68f8      	ldr	r0, [r7, #12]
   1917a:	40f0      	lsrs	r0, r6
   1917c:	f010 0001 	ands.w	r0, r0, #1
   19180:	d04c      	beq.n	1921c <gpiote_pin_int_cfg+0x10c>
		if (data->trig_edge & BIT(pin)) {
   19182:	6978      	ldr	r0, [r7, #20]
   19184:	40f0      	lsrs	r0, r6
   19186:	f010 0401 	ands.w	r4, r0, #1
   1918a:	d055      	beq.n	19238 <gpiote_pin_int_cfg+0x128>
			if (data->double_edge & BIT(pin)) {
   1918c:	69bb      	ldr	r3, [r7, #24]
   1918e:	40f3      	lsrs	r3, r6
   19190:	07db      	lsls	r3, r3, #31
   19192:	d449      	bmi.n	19228 <gpiote_pin_int_cfg+0x118>
			} else if (((data->active_level & BIT(pin)) != 0U)
   19194:	693b      	ldr	r3, [r7, #16]
				   ^ ((BIT(pin) & data->inverted) != 0)) {
   19196:	69fa      	ldr	r2, [r7, #28]
			} else if (((data->active_level & BIT(pin)) != 0U)
   19198:	40f3      	lsrs	r3, r6
				   ^ ((BIT(pin) & data->inverted) != 0)) {
   1919a:	fa22 f606 	lsr.w	r6, r2, r6
			} else if (((data->active_level & BIT(pin)) != 0U)
   1919e:	f003 0301 	and.w	r3, r3, #1
   191a2:	f006 0601 	and.w	r6, r6, #1
				pol = NRF_GPIOTE_POLARITY_HITOLO;
   191a6:	42b3      	cmp	r3, r6
   191a8:	bf14      	ite	ne
   191aa:	2601      	movne	r6, #1
   191ac:	2602      	moveq	r6, #2
    p_reg->CONFIG[idx] = 0;
}

NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
   191ae:	4c2a      	ldr	r4, [pc, #168]	; (19258 <gpiote_pin_int_cfg+0x148>)
   191b0:	2100      	movs	r1, #0
   191b2:	f501 73a2 	add.w	r3, r1, #324	; 0x144
   191b6:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
		if (!nrf_gpiote_te_is_enabled(NRF_GPIOTE, channel)) {
   191ba:	f010 0003 	ands.w	r0, r0, #3
   191be:	d135      	bne.n	1922c <gpiote_pin_int_cfg+0x11c>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   191c0:	008b      	lsls	r3, r1, #2
   191c2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   191c6:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   191ca:	022d      	lsls	r5, r5, #8
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   191cc:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   191d0:	f422 3247 	bic.w	r2, r2, #203776	; 0x31c00
   191d4:	f422 7240 	bic.w	r2, r2, #768	; 0x300
   191d8:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   191dc:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   191e0:	f405 55f8 	and.w	r5, r5, #7936	; 0x1f00
   191e4:	ea45 4606 	orr.w	r6, r5, r6, lsl #16
   191e8:	4316      	orrs	r6, r2
			nrf_gpiote_event_t evt =
   191ea:	f101 0240 	add.w	r2, r1, #64	; 0x40
   191ee:	0092      	lsls	r2, r2, #2
    return ((uint32_t)p_reg + event);
   191f0:	b292      	uxth	r2, r2
   191f2:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   191f6:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   191fa:	f8c3 6510 	str.w	r6, [r3, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   191fe:	6010      	str	r0, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
   19200:	6812      	ldr	r2, [r2, #0]
   19202:	9201      	str	r2, [sp, #4]
    (void)dummy;
   19204:	9a01      	ldr	r2, [sp, #4]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   19206:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   1920a:	f042 0201 	orr.w	r2, r2, #1
   1920e:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
   19212:	2301      	movs	r3, #1
   19214:	fa03 f101 	lsl.w	r1, r3, r1
    p_reg->INTENSET = mask;
   19218:	f8c4 1304 	str.w	r1, [r4, #772]	; 0x304
}
   1921c:	b003      	add	sp, #12
   1921e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   19220:	3301      	adds	r3, #1
   19222:	2b08      	cmp	r3, #8
   19224:	d183      	bne.n	1912e <gpiote_pin_int_cfg+0x1e>
   19226:	e79e      	b.n	19166 <gpiote_pin_int_cfg+0x56>
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
   19228:	2603      	movs	r6, #3
   1922a:	e7c0      	b.n	191ae <gpiote_pin_int_cfg+0x9e>
   1922c:	3101      	adds	r1, #1
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
   1922e:	2908      	cmp	r1, #8
   19230:	d1bf      	bne.n	191b2 <gpiote_pin_int_cfg+0xa2>
	return -ENODEV;
   19232:	f06f 0012 	mvn.w	r0, #18
   19236:	e7f1      	b.n	1921c <gpiote_pin_int_cfg+0x10c>
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   19238:	693b      	ldr	r3, [r7, #16]
   1923a:	69fa      	ldr	r2, [r7, #28]
   1923c:	4053      	eors	r3, r2
   1923e:	fa23 f606 	lsr.w	r6, r3, r6
		return NRF_GPIO_PIN_SENSE_HIGH;
   19242:	f016 0f01 	tst.w	r6, #1
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   19246:	4628      	mov	r0, r5
   19248:	bf0c      	ite	eq
   1924a:	2103      	moveq	r1, #3
   1924c:	2102      	movne	r1, #2
   1924e:	f00b fe72 	bl	24f36 <nrf_gpio_cfg_sense_set>
	int res = 0;
   19252:	4620      	mov	r0, r4
   19254:	e7e2      	b.n	1921c <gpiote_pin_int_cfg+0x10c>
   19256:	bf00      	nop
   19258:	40006000 	.word	0x40006000

0001925c <gpiote_event_handler>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1925c:	4b51      	ldr	r3, [pc, #324]	; (193a4 <gpiote_event_handler+0x148>)
{
   1925e:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   19262:	681e      	ldr	r6, [r3, #0]
	if (port_event) {
   19264:	4698      	mov	r8, r3
   19266:	2e00      	cmp	r6, #0
   19268:	d068      	beq.n	1933c <gpiote_event_handler+0xe0>
	struct gpio_nrfx_data *data = get_port_data(port);
   1926a:	4a4f      	ldr	r2, [pc, #316]	; (193a8 <gpiote_event_handler+0x14c>)
   1926c:	6893      	ldr	r3, [r2, #8]
	return port->config->config_info;
   1926e:	6812      	ldr	r2, [r2, #0]
	u32_t pin_states = ~(port_in ^ data->inverted ^ data->active_level);
   19270:	69dc      	ldr	r4, [r3, #28]
	return port->config->config_info;
   19272:	f8d2 9008 	ldr.w	r9, [r2, #8]
	u32_t out = data->int_en & data->pin_int_en;
   19276:	e9d3 2502 	ldrd	r2, r5, [r3, #8]
   1927a:	4015      	ands	r5, r2
	out &= ~data->trig_edge & ~data->double_edge;
   1927c:	e9d3 2105 	ldrd	r2, r1, [r3, #20]
   19280:	430a      	orrs	r2, r1
   19282:	ea25 0502 	bic.w	r5, r5, r2
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
   19286:	f8d9 2000 	ldr.w	r2, [r9]
	u32_t pin_states = ~(port_in ^ data->inverted ^ data->active_level);
   1928a:	691b      	ldr	r3, [r3, #16]
}


NRF_STATIC_INLINE uint32_t nrf_gpio_port_in_read(NRF_GPIO_Type const * p_reg)
{
    return p_reg->IN;
   1928c:	f8d2 2510 	ldr.w	r2, [r2, #1296]	; 0x510
   19290:	405c      	eors	r4, r3
   19292:	4054      	eors	r4, r2
	u32_t out = pin_states & level_pins;
   19294:	ea25 0404 	bic.w	r4, r5, r4
	u32_t bit = 1U << pin;
   19298:	2701      	movs	r7, #1
	u32_t pin = 0U;
   1929a:	f04f 0a00 	mov.w	sl, #0
	while (level_pins) {
   1929e:	2d00      	cmp	r5, #0
   192a0:	d13b      	bne.n	1931a <gpiote_event_handler+0xbe>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   192a2:	f8c8 5000 	str.w	r5, [r8]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
   192a6:	f8d8 3000 	ldr.w	r3, [r8]
   192aa:	9300      	str	r3, [sp, #0]
    (void)dummy;
   192ac:	9b00      	ldr	r3, [sp, #0]
    return p_reg->INTENSET & mask;
   192ae:	483f      	ldr	r0, [pc, #252]	; (193ac <gpiote_event_handler+0x150>)
	u32_t fired_triggers[GPIO_COUNT] = {0};
   192b0:	2300      	movs	r3, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
   192b2:	2501      	movs	r5, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   192b4:	461f      	mov	r7, r3
    return p_reg->INTENSET & mask;
   192b6:	f8d0 2304 	ldr.w	r2, [r0, #772]	; 0x304
   192ba:	fa05 f103 	lsl.w	r1, r5, r3
   192be:	4211      	tst	r1, r2
   192c0:	d013      	beq.n	192ea <gpiote_event_handler+0x8e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   192c2:	009a      	lsls	r2, r3, #2
   192c4:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   192c8:	f502 42c2 	add.w	r2, r2, #24832	; 0x6100
   192cc:	6811      	ldr	r1, [r2, #0]
   192ce:	b161      	cbz	r1, 192ea <gpiote_event_handler+0x8e>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   192d0:	f503 71a2 	add.w	r1, r3, #324	; 0x144
   192d4:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   192d8:	6017      	str	r7, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
   192da:	6812      	ldr	r2, [r2, #0]
   192dc:	9201      	str	r2, [sp, #4]
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   192de:	f3c1 2104 	ubfx	r1, r1, #8, #5
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
   192e2:	fa05 f101 	lsl.w	r1, r5, r1
    (void)dummy;
   192e6:	9a01      	ldr	r2, [sp, #4]
   192e8:	430c      	orrs	r4, r1
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   192ea:	3301      	adds	r3, #1
   192ec:	2b08      	cmp	r3, #8
   192ee:	d1e2      	bne.n	192b6 <gpiote_event_handler+0x5a>
	if (fired_triggers[0]) {
   192f0:	bb34      	cbnz	r4, 19340 <gpiote_event_handler+0xe4>
	if (port_event) {
   192f2:	b17e      	cbz	r6, 19314 <gpiote_event_handler+0xb8>
	const struct gpio_nrfx_data *data = get_port_data(port);
   192f4:	4b2c      	ldr	r3, [pc, #176]	; (193a8 <gpiote_event_handler+0x14c>)
   192f6:	689d      	ldr	r5, [r3, #8]
	return port->config->config_info;
   192f8:	681b      	ldr	r3, [r3, #0]
   192fa:	689e      	ldr	r6, [r3, #8]
	u32_t out = data->int_en & data->pin_int_en;
   192fc:	e9d5 3402 	ldrd	r3, r4, [r5, #8]
   19300:	401c      	ands	r4, r3
	out &= ~data->trig_edge & ~data->double_edge;
   19302:	e9d5 3205 	ldrd	r3, r2, [r5, #20]
   19306:	4313      	orrs	r3, r2
   19308:	ea24 0403 	bic.w	r4, r4, r3
	u32_t bit = 1U << pin;
   1930c:	2701      	movs	r7, #1
	u32_t pin = 0U;
   1930e:	f04f 0800 	mov.w	r8, #0
	while (level_pins) {
   19312:	bb64      	cbnz	r4, 1936e <gpiote_event_handler+0x112>
}
   19314:	b002      	add	sp, #8
   19316:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (level_pins & bit) {
   1931a:	423d      	tst	r5, r7
   1931c:	d00a      	beq.n	19334 <gpiote_event_handler+0xd8>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1931e:	f899 3004 	ldrb.w	r3, [r9, #4]
   19322:	f00a 001f 	and.w	r0, sl, #31
			nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   19326:	2100      	movs	r1, #0
   19328:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
   1932c:	f00b fe03 	bl	24f36 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   19330:	ea25 0507 	bic.w	r5, r5, r7
		++pin;
   19334:	f10a 0a01 	add.w	sl, sl, #1
		bit <<= 1;
   19338:	007f      	lsls	r7, r7, #1
   1933a:	e7b0      	b.n	1929e <gpiote_event_handler+0x42>
	u32_t fired_triggers[GPIO_COUNT] = {0};
   1933c:	4634      	mov	r4, r6
   1933e:	e7b6      	b.n	192ae <gpiote_event_handler+0x52>
	struct gpio_nrfx_data *data = get_port_data(port);
   19340:	4f19      	ldr	r7, [pc, #100]	; (193a8 <gpiote_event_handler+0x14c>)
   19342:	f8d7 8008 	ldr.w	r8, [r7, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   19346:	f8d8 1000 	ldr.w	r1, [r8]
   1934a:	2900      	cmp	r1, #0
   1934c:	d0d1      	beq.n	192f2 <gpiote_event_handler+0x96>
   1934e:	680d      	ldr	r5, [r1, #0]
		if ((cb->pin_mask & pins) & data->int_en) {
   19350:	f8d8 300c 	ldr.w	r3, [r8, #12]
   19354:	688a      	ldr	r2, [r1, #8]
   19356:	4023      	ands	r3, r4
   19358:	4213      	tst	r3, r2
   1935a:	d003      	beq.n	19364 <gpiote_event_handler+0x108>
			cb->handler(port, cb, pins);
   1935c:	684b      	ldr	r3, [r1, #4]
   1935e:	4622      	mov	r2, r4
   19360:	4638      	mov	r0, r7
   19362:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   19364:	2d00      	cmp	r5, #0
   19366:	d0c4      	beq.n	192f2 <gpiote_event_handler+0x96>
   19368:	4629      	mov	r1, r5
   1936a:	682d      	ldr	r5, [r5, #0]
   1936c:	e7f0      	b.n	19350 <gpiote_event_handler+0xf4>
		if (level_pins & bit) {
   1936e:	4227      	tst	r7, r4
   19370:	d013      	beq.n	1939a <gpiote_event_handler+0x13e>
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   19372:	692b      	ldr	r3, [r5, #16]
   19374:	69ea      	ldr	r2, [r5, #28]
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   19376:	f896 c004 	ldrb.w	ip, [r6, #4]
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   1937a:	4053      	eors	r3, r2
   1937c:	fa23 f308 	lsr.w	r3, r3, r8
		return NRF_GPIO_PIN_SENSE_HIGH;
   19380:	f013 0f01 	tst.w	r3, #1
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   19384:	f008 001f 	and.w	r0, r8, #31
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   19388:	bf0c      	ite	eq
   1938a:	2103      	moveq	r1, #3
   1938c:	2102      	movne	r1, #2
   1938e:	ea40 104c 	orr.w	r0, r0, ip, lsl #5
   19392:	f00b fdd0 	bl	24f36 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   19396:	ea24 0407 	bic.w	r4, r4, r7
		++pin;
   1939a:	f108 0801 	add.w	r8, r8, #1
		bit <<= 1;
   1939e:	007f      	lsls	r7, r7, #1
   193a0:	e7b7      	b.n	19312 <gpiote_event_handler+0xb6>
   193a2:	bf00      	nop
   193a4:	4000617c 	.word	0x4000617c
   193a8:	2000ee60 	.word	0x2000ee60
   193ac:	40006000 	.word	0x40006000

000193b0 <twi_1_init>:
#ifdef CONFIG_I2C_0_NRF_TWI
I2C_NRFX_TWI_DEVICE(0);
#endif

#ifdef CONFIG_I2C_1_NRF_TWI
I2C_NRFX_TWI_DEVICE(1);
   193b0:	b510      	push	{r4, lr}
   193b2:	4604      	mov	r4, r0
   193b4:	2200      	movs	r2, #0
   193b6:	2101      	movs	r1, #1
   193b8:	2004      	movs	r0, #4
   193ba:	f7ed fbd3 	bl	6b64 <z_arm_irq_priority_set>
	return dev->config->config_info;
   193be:	6823      	ldr	r3, [r4, #0]
	nrfx_err_t result = nrfx_twi_init(&get_dev_config(dev)->twi,
   193c0:	4a0f      	ldr	r2, [pc, #60]	; (19400 <twi_1_init+0x50>)
	return dev->config->config_info;
   193c2:	6898      	ldr	r0, [r3, #8]
	nrfx_err_t result = nrfx_twi_init(&get_dev_config(dev)->twi,
   193c4:	4623      	mov	r3, r4
   193c6:	f100 0108 	add.w	r1, r0, #8
   193ca:	f001 fa37 	bl	1a83c <nrfx_twi_init>
	if (result != NRFX_SUCCESS) {
   193ce:	4b0d      	ldr	r3, [pc, #52]	; (19404 <twi_1_init+0x54>)
   193d0:	4298      	cmp	r0, r3
   193d2:	d012      	beq.n	193fa <twi_1_init+0x4a>
		LOG_ERR("Failed to initialize device: %s",
   193d4:	2301      	movs	r3, #1
   193d6:	f04f 0200 	mov.w	r2, #0
   193da:	f363 0207 	bfi	r2, r3, #0, #8
   193de:	490a      	ldr	r1, [pc, #40]	; (19408 <twi_1_init+0x58>)
   193e0:	4b0a      	ldr	r3, [pc, #40]	; (1940c <twi_1_init+0x5c>)
   193e2:	480b      	ldr	r0, [pc, #44]	; (19410 <twi_1_init+0x60>)
   193e4:	1a5b      	subs	r3, r3, r1
   193e6:	08db      	lsrs	r3, r3, #3
   193e8:	f363 128f 	bfi	r2, r3, #6, #10
   193ec:	6823      	ldr	r3, [r4, #0]
   193ee:	6819      	ldr	r1, [r3, #0]
   193f0:	f007 fe30 	bl	21054 <log_1>
		return -EBUSY;
   193f4:	f06f 000f 	mvn.w	r0, #15
I2C_NRFX_TWI_DEVICE(1);
   193f8:	bd10      	pop	{r4, pc}
	return 0;
   193fa:	2000      	movs	r0, #0
I2C_NRFX_TWI_DEVICE(1);
   193fc:	e7fc      	b.n	193f8 <twi_1_init+0x48>
   193fe:	bf00      	nop
   19400:	00019579 	.word	0x00019579
   19404:	0bad0000 	.word	0x0bad0000
   19408:	00028540 	.word	0x00028540
   1940c:	00028668 	.word	0x00028668
   19410:	00064e9d 	.word	0x00064e9d

00019414 <i2c_nrfx_twi_configure>:
{
   19414:	b508      	push	{r3, lr}
	return dev->config->config_info;
   19416:	6803      	ldr	r3, [r0, #0]
	if (I2C_ADDR_10_BITS & dev_config) {
   19418:	07ca      	lsls	r2, r1, #31
	return dev->config->config_info;
   1941a:	689b      	ldr	r3, [r3, #8]
	if (I2C_ADDR_10_BITS & dev_config) {
   1941c:	d413      	bmi.n	19446 <i2c_nrfx_twi_configure+0x32>
	switch (I2C_SPEED_GET(dev_config)) {
   1941e:	f3c1 0242 	ubfx	r2, r1, #1, #3
   19422:	2a01      	cmp	r2, #1
   19424:	d012      	beq.n	1944c <i2c_nrfx_twi_configure+0x38>
   19426:	2a02      	cmp	r2, #2
   19428:	d019      	beq.n	1945e <i2c_nrfx_twi_configure+0x4a>
		LOG_ERR("unsupported speed");
   1942a:	2301      	movs	r3, #1
   1942c:	f04f 0100 	mov.w	r1, #0
   19430:	f363 0107 	bfi	r1, r3, #0, #8
   19434:	4a0c      	ldr	r2, [pc, #48]	; (19468 <i2c_nrfx_twi_configure+0x54>)
   19436:	4b0d      	ldr	r3, [pc, #52]	; (1946c <i2c_nrfx_twi_configure+0x58>)
   19438:	480d      	ldr	r0, [pc, #52]	; (19470 <i2c_nrfx_twi_configure+0x5c>)
   1943a:	1a9b      	subs	r3, r3, r2
   1943c:	08db      	lsrs	r3, r3, #3
   1943e:	f363 118f 	bfi	r1, r3, #6, #10
   19442:	f007 fdfa 	bl	2103a <log_0>
		return -EINVAL;
   19446:	f06f 0015 	mvn.w	r0, #21
   1944a:	e007      	b.n	1945c <i2c_nrfx_twi_configure+0x48>
		nrf_twi_frequency_set(inst->p_twi, NRF_TWI_FREQ_100K);
   1944c:	681b      	ldr	r3, [r3, #0]
}

NRF_STATIC_INLINE void nrf_twi_frequency_set(NRF_TWI_Type *      p_reg,
                                             nrf_twi_frequency_t frequency)
{
    p_reg->FREQUENCY = frequency;
   1944e:	f04f 72cc 	mov.w	r2, #26738688	; 0x1980000
   19452:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	get_dev_data(dev)->dev_config = dev_config;
   19456:	6883      	ldr	r3, [r0, #8]
	return 0;
   19458:	2000      	movs	r0, #0
	get_dev_data(dev)->dev_config = dev_config;
   1945a:	6359      	str	r1, [r3, #52]	; 0x34
}
   1945c:	bd08      	pop	{r3, pc}
		nrf_twi_frequency_set(inst->p_twi, NRF_TWI_FREQ_400K);
   1945e:	681b      	ldr	r3, [r3, #0]
   19460:	f04f 62cd 	mov.w	r2, #107479040	; 0x6680000
   19464:	e7f5      	b.n	19452 <i2c_nrfx_twi_configure+0x3e>
   19466:	bf00      	nop
   19468:	00028540 	.word	0x00028540
   1946c:	00028668 	.word	0x00028668
   19470:	00064e57 	.word	0x00064e57

00019474 <i2c_nrfx_twi_transfer>:
{
   19474:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19478:	4605      	mov	r5, r0
   1947a:	b087      	sub	sp, #28
   1947c:	460c      	mov	r4, r1
   1947e:	4617      	mov	r7, r2
   19480:	4699      	mov	r9, r3
	k_sem_take(&(get_dev_data(dev)->transfer_sync), K_FOREVER);
   19482:	6880      	ldr	r0, [r0, #8]
	return z_impl_k_sem_take(sem, timeout);
   19484:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   19488:	f005 fca4 	bl	1edd4 <z_impl_k_sem_take>
	return dev->config->config_info;
   1948c:	682b      	ldr	r3, [r5, #0]
		if (res != NRFX_SUCCESS) {
   1948e:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 19574 <i2c_nrfx_twi_transfer+0x100>
	nrfx_twi_enable(&get_dev_config(dev)->twi);
   19492:	6898      	ldr	r0, [r3, #8]
   19494:	f001 fa34 	bl	1a900 <nrfx_twi_enable>
	for (size_t i = 0; i < num_msgs; i++) {
   19498:	2600      	movs	r6, #0
   1949a:	42be      	cmp	r6, r7
   1949c:	d301      	bcc.n	194a2 <i2c_nrfx_twi_transfer+0x2e>
	int ret = 0;
   1949e:	2400      	movs	r4, #0
   194a0:	e02e      	b.n	19500 <i2c_nrfx_twi_transfer+0x8c>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
   194a2:	f894 b008 	ldrb.w	fp, [r4, #8]
   194a6:	f01b 0a08 	ands.w	sl, fp, #8
   194aa:	d158      	bne.n	1955e <i2c_nrfx_twi_transfer+0xea>
		nrfx_twi_xfer_desc_t cur_xfer = {
   194ac:	2212      	movs	r2, #18
   194ae:	4651      	mov	r1, sl
   194b0:	f10d 0006 	add.w	r0, sp, #6
   194b4:	f7e8 fbbb 	bl	1c2e <memset>
   194b8:	6862      	ldr	r2, [r4, #4]
   194ba:	9202      	str	r2, [sp, #8]
					  NRFX_TWI_XFER_RX : NRFX_TWI_XFER_TX
   194bc:	f00b 0301 	and.w	r3, fp, #1
		nrfx_twi_xfer_desc_t cur_xfer = {
   194c0:	6822      	ldr	r2, [r4, #0]
   194c2:	f88d 3004 	strb.w	r3, [sp, #4]
		if (!(msgs[i].flags & I2C_MSG_STOP)) {
   194c6:	f01b 0f02 	tst.w	fp, #2
		nrfx_twi_xfer_desc_t cur_xfer = {
   194ca:	f88d 9005 	strb.w	r9, [sp, #5]
   194ce:	9204      	str	r2, [sp, #16]
		if (!(msgs[i].flags & I2C_MSG_STOP)) {
   194d0:	d121      	bne.n	19516 <i2c_nrfx_twi_transfer+0xa2>
			if ((i < (num_msgs - 1)) &&
   194d2:	1e7a      	subs	r2, r7, #1
   194d4:	42b2      	cmp	r2, r6
   194d6:	d902      	bls.n	194de <i2c_nrfx_twi_transfer+0x6a>
   194d8:	7d22      	ldrb	r2, [r4, #20]
   194da:	0752      	lsls	r2, r2, #29
   194dc:	d51d      	bpl.n	1951a <i2c_nrfx_twi_transfer+0xa6>
			} else if (msgs[i].flags & I2C_MSG_READ) {
   194de:	2b00      	cmp	r3, #0
   194e0:	d13d      	bne.n	1955e <i2c_nrfx_twi_transfer+0xea>
				xfer_flags |= NRFX_TWI_FLAG_TX_NO_STOP;
   194e2:	2220      	movs	r2, #32
	return dev->config->config_info;
   194e4:	682b      	ldr	r3, [r5, #0]
		res = nrfx_twi_xfer(&get_dev_config(dev)->twi,
   194e6:	a901      	add	r1, sp, #4
   194e8:	6898      	ldr	r0, [r3, #8]
   194ea:	f001 fa53 	bl	1a994 <nrfx_twi_xfer>
		if (res != NRFX_SUCCESS) {
   194ee:	4540      	cmp	r0, r8
   194f0:	d015      	beq.n	1951e <i2c_nrfx_twi_transfer+0xaa>
			if (res == NRFX_ERROR_BUSY) {
   194f2:	4b1c      	ldr	r3, [pc, #112]	; (19564 <i2c_nrfx_twi_transfer+0xf0>)
				ret = -EIO;
   194f4:	4298      	cmp	r0, r3
   194f6:	bf0c      	ite	eq
   194f8:	f06f 040f 	mvneq.w	r4, #15
   194fc:	f06f 0404 	mvnne.w	r4, #4
	return dev->config->config_info;
   19500:	682b      	ldr	r3, [r5, #0]
	nrfx_twi_disable(&get_dev_config(dev)->twi);
   19502:	6898      	ldr	r0, [r3, #8]
   19504:	f001 fa1c 	bl	1a940 <nrfx_twi_disable>
	k_sem_give(&(get_dev_data(dev)->transfer_sync));
   19508:	68a8      	ldr	r0, [r5, #8]
	z_impl_k_sem_give(sem);
   1950a:	f005 fc37 	bl	1ed7c <z_impl_k_sem_give>
}
   1950e:	4620      	mov	r0, r4
   19510:	b007      	add	sp, #28
   19512:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		u32_t xfer_flags = 0;
   19516:	4652      	mov	r2, sl
   19518:	e7e4      	b.n	194e4 <i2c_nrfx_twi_transfer+0x70>
				xfer_flags |= NRFX_TWI_FLAG_SUSPEND;
   1951a:	2240      	movs	r2, #64	; 0x40
   1951c:	e7e2      	b.n	194e4 <i2c_nrfx_twi_transfer+0x70>
		k_sem_take(&(get_dev_data(dev)->completion_sync), K_FOREVER);
   1951e:	68a8      	ldr	r0, [r5, #8]
   19520:	3018      	adds	r0, #24
	return z_impl_k_sem_take(sem, timeout);
   19522:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   19526:	f005 fc55 	bl	1edd4 <z_impl_k_sem_take>
		res = get_dev_data(dev)->res;
   1952a:	68ab      	ldr	r3, [r5, #8]
   1952c:	6b19      	ldr	r1, [r3, #48]	; 0x30
		if (res != NRFX_SUCCESS) {
   1952e:	4541      	cmp	r1, r8
   19530:	f104 040c 	add.w	r4, r4, #12
   19534:	d011      	beq.n	1955a <i2c_nrfx_twi_transfer+0xe6>
			LOG_ERR("Error %d occurred for message %d", res, i);
   19536:	2201      	movs	r2, #1
   19538:	f04f 0300 	mov.w	r3, #0
   1953c:	f362 0307 	bfi	r3, r2, #0, #8
   19540:	4809      	ldr	r0, [pc, #36]	; (19568 <i2c_nrfx_twi_transfer+0xf4>)
   19542:	4a0a      	ldr	r2, [pc, #40]	; (1956c <i2c_nrfx_twi_transfer+0xf8>)
   19544:	1a12      	subs	r2, r2, r0
   19546:	08d2      	lsrs	r2, r2, #3
   19548:	f362 138f 	bfi	r3, r2, #6, #10
   1954c:	4808      	ldr	r0, [pc, #32]	; (19570 <i2c_nrfx_twi_transfer+0xfc>)
   1954e:	4632      	mov	r2, r6
   19550:	f007 fd94 	bl	2107c <log_2>
			ret = -EIO;
   19554:	f06f 0404 	mvn.w	r4, #4
			break;
   19558:	e7d2      	b.n	19500 <i2c_nrfx_twi_transfer+0x8c>
	for (size_t i = 0; i < num_msgs; i++) {
   1955a:	3601      	adds	r6, #1
   1955c:	e79d      	b.n	1949a <i2c_nrfx_twi_transfer+0x26>
			ret = -ENOTSUP;
   1955e:	f06f 0485 	mvn.w	r4, #133	; 0x85
   19562:	e7cd      	b.n	19500 <i2c_nrfx_twi_transfer+0x8c>
   19564:	0bad000b 	.word	0x0bad000b
   19568:	00028540 	.word	0x00028540
   1956c:	00028668 	.word	0x00028668
   19570:	00064e69 	.word	0x00064e69
   19574:	0bad0000 	.word	0x0bad0000

00019578 <event_handler>:
	switch (p_event->type) {
   19578:	7802      	ldrb	r2, [r0, #0]
	struct i2c_nrfx_twi_data *dev_data = get_dev_data(dev);
   1957a:	688b      	ldr	r3, [r1, #8]
	switch (p_event->type) {
   1957c:	2a01      	cmp	r2, #1
   1957e:	d00a      	beq.n	19596 <event_handler+0x1e>
   19580:	b11a      	cbz	r2, 1958a <event_handler+0x12>
   19582:	2a02      	cmp	r2, #2
   19584:	d009      	beq.n	1959a <event_handler+0x22>
		dev_data->res = NRFX_ERROR_INTERNAL;
   19586:	4a06      	ldr	r2, [pc, #24]	; (195a0 <event_handler+0x28>)
   19588:	e000      	b.n	1958c <event_handler+0x14>
		dev_data->res = NRFX_SUCCESS;
   1958a:	4a06      	ldr	r2, [pc, #24]	; (195a4 <event_handler+0x2c>)
		dev_data->res = NRFX_ERROR_INTERNAL;
   1958c:	631a      	str	r2, [r3, #48]	; 0x30
	z_impl_k_sem_give(sem);
   1958e:	f103 0018 	add.w	r0, r3, #24
   19592:	f005 bbf3 	b.w	1ed7c <z_impl_k_sem_give>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   19596:	4a04      	ldr	r2, [pc, #16]	; (195a8 <event_handler+0x30>)
   19598:	e7f8      	b.n	1958c <event_handler+0x14>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   1959a:	4a04      	ldr	r2, [pc, #16]	; (195ac <event_handler+0x34>)
   1959c:	e7f6      	b.n	1958c <event_handler+0x14>
   1959e:	bf00      	nop
   195a0:	0bad0001 	.word	0x0bad0001
   195a4:	0bad0000 	.word	0x0bad0000
   195a8:	0bae0001 	.word	0x0bae0001
   195ac:	0bae0002 	.word	0x0bae0002

000195b0 <spi_0_init>:
		      &spi_##idx##z_config,				       \
		      POST_KERNEL, CONFIG_SPI_INIT_PRIORITY,		       \
		      &spi_nrfx_driver_api)

#ifdef CONFIG_SPI_0_NRF_SPI
SPI_NRFX_SPI_DEVICE(0);
   195b0:	b510      	push	{r4, lr}
   195b2:	4604      	mov	r4, r0
   195b4:	2200      	movs	r2, #0
   195b6:	2101      	movs	r1, #1
   195b8:	2003      	movs	r0, #3
   195ba:	f7ed fad3 	bl	6b64 <z_arm_irq_priority_set>
	return dev->config->config_info;
   195be:	6823      	ldr	r3, [r4, #0]
	nrfx_err_t result = nrfx_spi_init(&get_dev_config(dev)->spi,
   195c0:	4a10      	ldr	r2, [pc, #64]	; (19604 <spi_0_init+0x54>)
	return dev->config->config_info;
   195c2:	6898      	ldr	r0, [r3, #8]
	nrfx_err_t result = nrfx_spi_init(&get_dev_config(dev)->spi,
   195c4:	4623      	mov	r3, r4
   195c6:	f100 0108 	add.w	r1, r0, #8
   195ca:	f000 fea9 	bl	1a320 <nrfx_spi_init>
	if (result != NRFX_SUCCESS) {
   195ce:	4b0e      	ldr	r3, [pc, #56]	; (19608 <spi_0_init+0x58>)
   195d0:	4298      	cmp	r0, r3
   195d2:	d012      	beq.n	195fa <spi_0_init+0x4a>
		LOG_ERR("Failed to initialize device: %s",
   195d4:	2301      	movs	r3, #1
   195d6:	f04f 0200 	mov.w	r2, #0
   195da:	f363 0207 	bfi	r2, r3, #0, #8
   195de:	490b      	ldr	r1, [pc, #44]	; (1960c <spi_0_init+0x5c>)
   195e0:	4b0b      	ldr	r3, [pc, #44]	; (19610 <spi_0_init+0x60>)
   195e2:	480c      	ldr	r0, [pc, #48]	; (19614 <spi_0_init+0x64>)
   195e4:	1a5b      	subs	r3, r3, r1
   195e6:	08db      	lsrs	r3, r3, #3
   195e8:	f363 128f 	bfi	r2, r3, #6, #10
   195ec:	6823      	ldr	r3, [r4, #0]
   195ee:	6819      	ldr	r1, [r3, #0]
   195f0:	f007 fd30 	bl	21054 <log_1>
		return -EBUSY;
   195f4:	f06f 000f 	mvn.w	r0, #15
SPI_NRFX_SPI_DEVICE(0);
   195f8:	bd10      	pop	{r4, pc}
	spi_context_unlock_unconditionally(&get_dev_data(dev)->ctx);
   195fa:	68a0      	ldr	r0, [r4, #8]
   195fc:	f00b fdb6 	bl	2516c <spi_context_unlock_unconditionally>
	return 0;
   19600:	2000      	movs	r0, #0
SPI_NRFX_SPI_DEVICE(0);
   19602:	e7f9      	b.n	195f8 <spi_0_init+0x48>
   19604:	00019699 	.word	0x00019699
   19608:	0bad0000 	.word	0x0bad0000
   1960c:	00028540 	.word	0x00028540
   19610:	000286b0 	.word	0x000286b0
   19614:	00064e9d 	.word	0x00064e9d

00019618 <transfer_next_chunk>:
{
   19618:	b530      	push	{r4, r5, lr}
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   1961a:	6885      	ldr	r5, [r0, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
}

static inline size_t spi_context_longest_current_buf(struct spi_context *ctx)
{
	if (!ctx->tx_len) {
   1961c:	6cea      	ldr	r2, [r5, #76]	; 0x4c
   1961e:	6d6b      	ldr	r3, [r5, #84]	; 0x54
{
   19620:	b085      	sub	sp, #20
   19622:	b982      	cbnz	r2, 19646 <transfer_next_chunk+0x2e>
	if (chunk_len > 0) {
   19624:	bb7b      	cbnz	r3, 19686 <transfer_next_chunk+0x6e>
	int error = 0;
   19626:	461c      	mov	r4, r3
	_spi_context_cs_control(ctx, on, false);
   19628:	2200      	movs	r2, #0
   1962a:	4611      	mov	r1, r2
   1962c:	4628      	mov	r0, r5
   1962e:	f00b fd73 	bl	25118 <_spi_context_cs_control.isra.7>
	ctx->sync_status = status;
   19632:	636c      	str	r4, [r5, #52]	; 0x34
   19634:	f105 001c 	add.w	r0, r5, #28
   19638:	f005 fba0 	bl	1ed7c <z_impl_k_sem_give>
	dev_data->busy = false;
   1963c:	2300      	movs	r3, #0
   1963e:	f885 305c 	strb.w	r3, [r5, #92]	; 0x5c
}
   19642:	b005      	add	sp, #20
   19644:	bd30      	pop	{r4, r5, pc}
		return ctx->rx_len;
	} else if (!ctx->rx_len) {
   19646:	4611      	mov	r1, r2
   19648:	b113      	cbz	r3, 19650 <transfer_next_chunk+0x38>
		return ctx->tx_len;
	} else if (ctx->tx_len < ctx->rx_len) {
   1964a:	429a      	cmp	r2, r3
   1964c:	bf28      	it	cs
   1964e:	4619      	movcs	r1, r3
		xfer.p_tx_buffer = ctx->tx_buf;
   19650:	6cac      	ldr	r4, [r5, #72]	; 0x48
		dev_data->chunk_len = chunk_len;
   19652:	65a9      	str	r1, [r5, #88]	; 0x58
		xfer.p_tx_buffer = ctx->tx_buf;
   19654:	9400      	str	r4, [sp, #0]
	return !!(ctx->tx_buf && ctx->tx_len);
   19656:	b1c4      	cbz	r4, 1968a <transfer_next_chunk+0x72>
   19658:	2a00      	cmp	r2, #0
   1965a:	bf18      	it	ne
   1965c:	460a      	movne	r2, r1
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
   1965e:	9201      	str	r2, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
   19660:	6d2a      	ldr	r2, [r5, #80]	; 0x50
   19662:	9202      	str	r2, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
   19664:	b19a      	cbz	r2, 1968e <transfer_next_chunk+0x76>
   19666:	2b00      	cmp	r3, #0
   19668:	bf18      	it	ne
   1966a:	460b      	movne	r3, r1
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   1966c:	9303      	str	r3, [sp, #12]
	return dev->config->config_info;
   1966e:	6803      	ldr	r3, [r0, #0]
		result = nrfx_spi_xfer(&get_dev_config(dev)->spi, &xfer, 0);
   19670:	2200      	movs	r2, #0
   19672:	6898      	ldr	r0, [r3, #8]
   19674:	4669      	mov	r1, sp
   19676:	f000 ff09 	bl	1a48c <nrfx_spi_xfer>
		if (result == NRFX_SUCCESS) {
   1967a:	4b06      	ldr	r3, [pc, #24]	; (19694 <transfer_next_chunk+0x7c>)
   1967c:	4298      	cmp	r0, r3
   1967e:	d0e0      	beq.n	19642 <transfer_next_chunk+0x2a>
		error = -EIO;
   19680:	f06f 0404 	mvn.w	r4, #4
   19684:	e7d0      	b.n	19628 <transfer_next_chunk+0x10>
   19686:	4619      	mov	r1, r3
   19688:	e7e2      	b.n	19650 <transfer_next_chunk+0x38>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
   1968a:	4622      	mov	r2, r4
   1968c:	e7e7      	b.n	1965e <transfer_next_chunk+0x46>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   1968e:	4613      	mov	r3, r2
   19690:	e7ec      	b.n	1966c <transfer_next_chunk+0x54>
   19692:	bf00      	nop
   19694:	0bad0000 	.word	0x0bad0000

00019698 <event_handler>:
{
   19698:	b538      	push	{r3, r4, r5, lr}
	if (p_event->type == NRFX_SPI_EVENT_DONE) {
   1969a:	7803      	ldrb	r3, [r0, #0]
{
   1969c:	460d      	mov	r5, r1
	if (p_event->type == NRFX_SPI_EVENT_DONE) {
   1969e:	2b00      	cmp	r3, #0
   196a0:	d157      	bne.n	19752 <event_handler+0xba>
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   196a2:	688c      	ldr	r4, [r1, #8]
	if (!ctx->tx_len) {
   196a4:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   196a6:	b183      	cbz	r3, 196ca <event_handler+0x32>
		spi_context_update_tx(&dev_data->ctx, 1, dev_data->chunk_len);
   196a8:	6da2      	ldr	r2, [r4, #88]	; 0x58
	if (len > ctx->tx_len) {
   196aa:	429a      	cmp	r2, r3
   196ac:	d925      	bls.n	196fa <event_handler+0x62>
		LOG_ERR("Update exceeds current buffer");
   196ae:	2301      	movs	r3, #1
   196b0:	f04f 0100 	mov.w	r1, #0
   196b4:	f363 0107 	bfi	r1, r3, #0, #8
   196b8:	4a26      	ldr	r2, [pc, #152]	; (19754 <event_handler+0xbc>)
   196ba:	4b27      	ldr	r3, [pc, #156]	; (19758 <event_handler+0xc0>)
   196bc:	4827      	ldr	r0, [pc, #156]	; (1975c <event_handler+0xc4>)
   196be:	1a9b      	subs	r3, r3, r2
   196c0:	08db      	lsrs	r3, r3, #3
   196c2:	f363 118f 	bfi	r1, r3, #6, #10
   196c6:	f007 fcb8 	bl	2103a <log_0>
	if (!ctx->rx_len) {
   196ca:	6d63      	ldr	r3, [r4, #84]	; 0x54
   196cc:	b183      	cbz	r3, 196f0 <event_handler+0x58>
		spi_context_update_rx(&dev_data->ctx, 1, dev_data->chunk_len);
   196ce:	6da2      	ldr	r2, [r4, #88]	; 0x58
	if (len > ctx->rx_len) {
   196d0:	429a      	cmp	r2, r3
   196d2:	d928      	bls.n	19726 <event_handler+0x8e>
		LOG_ERR("Update exceeds current buffer");
   196d4:	2301      	movs	r3, #1
   196d6:	f04f 0100 	mov.w	r1, #0
   196da:	f363 0107 	bfi	r1, r3, #0, #8
   196de:	4a1d      	ldr	r2, [pc, #116]	; (19754 <event_handler+0xbc>)
   196e0:	4b1d      	ldr	r3, [pc, #116]	; (19758 <event_handler+0xc0>)
   196e2:	481e      	ldr	r0, [pc, #120]	; (1975c <event_handler+0xc4>)
   196e4:	1a9b      	subs	r3, r3, r2
   196e6:	08db      	lsrs	r3, r3, #3
   196e8:	f363 118f 	bfi	r1, r3, #6, #10
   196ec:	f007 fca5 	bl	2103a <log_0>
		transfer_next_chunk(dev);
   196f0:	4628      	mov	r0, r5
}
   196f2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		transfer_next_chunk(dev);
   196f6:	f7ff bf8f 	b.w	19618 <transfer_next_chunk>
	ctx->tx_len -= len;
   196fa:	1a9b      	subs	r3, r3, r2
   196fc:	64e3      	str	r3, [r4, #76]	; 0x4c
	if (!ctx->tx_len) {
   196fe:	b963      	cbnz	r3, 1971a <event_handler+0x82>
		ctx->tx_count--;
   19700:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   19702:	3b01      	subs	r3, #1
   19704:	63e3      	str	r3, [r4, #60]	; 0x3c
		if (ctx->tx_count) {
   19706:	b163      	cbz	r3, 19722 <event_handler+0x8a>
			ctx->current_tx++;
   19708:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1970a:	f103 0208 	add.w	r2, r3, #8
   1970e:	63a2      	str	r2, [r4, #56]	; 0x38
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   19710:	689a      	ldr	r2, [r3, #8]
			ctx->tx_len = ctx->current_tx->len / dfs;
   19712:	68db      	ldr	r3, [r3, #12]
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   19714:	64a2      	str	r2, [r4, #72]	; 0x48
			ctx->tx_len = ctx->current_tx->len / dfs;
   19716:	64e3      	str	r3, [r4, #76]	; 0x4c
   19718:	e7d7      	b.n	196ca <event_handler+0x32>
	} else if (ctx->tx_buf) {
   1971a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   1971c:	2b00      	cmp	r3, #0
   1971e:	d0d4      	beq.n	196ca <event_handler+0x32>
		ctx->tx_buf += dfs * len;
   19720:	4413      	add	r3, r2
   19722:	64a3      	str	r3, [r4, #72]	; 0x48
   19724:	e7d1      	b.n	196ca <event_handler+0x32>
	ctx->rx_len -= len;
   19726:	1a9b      	subs	r3, r3, r2
   19728:	6563      	str	r3, [r4, #84]	; 0x54
	if (!ctx->rx_len) {
   1972a:	b963      	cbnz	r3, 19746 <event_handler+0xae>
		ctx->rx_count--;
   1972c:	6c63      	ldr	r3, [r4, #68]	; 0x44
   1972e:	3b01      	subs	r3, #1
   19730:	6463      	str	r3, [r4, #68]	; 0x44
		if (ctx->rx_count) {
   19732:	b163      	cbz	r3, 1974e <event_handler+0xb6>
			ctx->current_rx++;
   19734:	6c23      	ldr	r3, [r4, #64]	; 0x40
   19736:	f103 0208 	add.w	r2, r3, #8
   1973a:	6422      	str	r2, [r4, #64]	; 0x40
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   1973c:	689a      	ldr	r2, [r3, #8]
			ctx->rx_len = ctx->current_rx->len / dfs;
   1973e:	68db      	ldr	r3, [r3, #12]
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   19740:	6522      	str	r2, [r4, #80]	; 0x50
			ctx->rx_len = ctx->current_rx->len / dfs;
   19742:	6563      	str	r3, [r4, #84]	; 0x54
   19744:	e7d4      	b.n	196f0 <event_handler+0x58>
	} else if (ctx->rx_buf) {
   19746:	6d23      	ldr	r3, [r4, #80]	; 0x50
   19748:	2b00      	cmp	r3, #0
   1974a:	d0d1      	beq.n	196f0 <event_handler+0x58>
		ctx->rx_buf += dfs * len;
   1974c:	4413      	add	r3, r2
   1974e:	6523      	str	r3, [r4, #80]	; 0x50
   19750:	e7ce      	b.n	196f0 <event_handler+0x58>
}
   19752:	bd38      	pop	{r3, r4, r5, pc}
   19754:	00028540 	.word	0x00028540
   19758:	000286b0 	.word	0x000286b0
   1975c:	00064ebd 	.word	0x00064ebd

00019760 <spi_nrfx_transceive>:
{
   19760:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   19764:	4607      	mov	r7, r0
	k_sem_take(&ctx->lock, K_FOREVER);
   19766:	6880      	ldr	r0, [r0, #8]
   19768:	4688      	mov	r8, r1
   1976a:	4616      	mov	r6, r2
   1976c:	461d      	mov	r5, r3
   1976e:	3004      	adds	r0, #4
	return z_impl_k_sem_take(sem, timeout);
   19770:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   19774:	f005 fb2e 	bl	1edd4 <z_impl_k_sem_take>
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   19778:	68bc      	ldr	r4, [r7, #8]
	if (spi_context_configured(ctx, spi_cfg)) {
   1977a:	6823      	ldr	r3, [r4, #0]
   1977c:	4598      	cmp	r8, r3
   1977e:	f000 80b0 	beq.w	198e2 <spi_nrfx_transceive+0x182>
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
   19782:	f8b8 3004 	ldrh.w	r3, [r8, #4]
	const nrfx_spi_t *spi = &get_dev_config(dev)->spi;
   19786:	6838      	ldr	r0, [r7, #0]
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
   19788:	07d9      	lsls	r1, r3, #31
   1978a:	d516      	bpl.n	197ba <spi_nrfx_transceive+0x5a>
		LOG_ERR("Slave mode is not supported on %s",
   1978c:	2301      	movs	r3, #1
   1978e:	f04f 0200 	mov.w	r2, #0
   19792:	f363 0207 	bfi	r2, r3, #0, #8
   19796:	4980      	ldr	r1, [pc, #512]	; (19998 <spi_nrfx_transceive+0x238>)
   19798:	4b80      	ldr	r3, [pc, #512]	; (1999c <spi_nrfx_transceive+0x23c>)
   1979a:	1a5b      	subs	r3, r3, r1
   1979c:	08db      	lsrs	r3, r3, #3
   1979e:	6801      	ldr	r1, [r0, #0]
   197a0:	487f      	ldr	r0, [pc, #508]	; (199a0 <spi_nrfx_transceive+0x240>)
   197a2:	f363 128f 	bfi	r2, r3, #6, #10
   197a6:	f007 fc55 	bl	21054 <log_1>
		return -EINVAL;
   197aa:	f06f 0515 	mvn.w	r5, #21
	z_impl_k_sem_give(sem);
   197ae:	1d20      	adds	r0, r4, #4
   197b0:	f005 fae4 	bl	1ed7c <z_impl_k_sem_give>
}
   197b4:	4628      	mov	r0, r5
   197b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (spi_cfg->operation & SPI_MODE_LOOP) {
   197ba:	071a      	lsls	r2, r3, #28
   197bc:	d50e      	bpl.n	197dc <spi_nrfx_transceive+0x7c>
		LOG_ERR("Loopback mode is not supported");
   197be:	2301      	movs	r3, #1
   197c0:	f04f 0100 	mov.w	r1, #0
   197c4:	f363 0107 	bfi	r1, r3, #0, #8
   197c8:	4a73      	ldr	r2, [pc, #460]	; (19998 <spi_nrfx_transceive+0x238>)
   197ca:	4b74      	ldr	r3, [pc, #464]	; (1999c <spi_nrfx_transceive+0x23c>)
   197cc:	4875      	ldr	r0, [pc, #468]	; (199a4 <spi_nrfx_transceive+0x244>)
   197ce:	1a9b      	subs	r3, r3, r2
   197d0:	08db      	lsrs	r3, r3, #3
   197d2:	f363 118f 	bfi	r1, r3, #6, #10
		LOG_ERR("Word sizes other than 8 bits"
   197d6:	f007 fc30 	bl	2103a <log_0>
   197da:	e7e6      	b.n	197aa <spi_nrfx_transceive+0x4a>
	if ((spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
   197dc:	f413 51c0 	ands.w	r1, r3, #6144	; 0x1800
   197e0:	d00c      	beq.n	197fc <spi_nrfx_transceive+0x9c>
		LOG_ERR("Only single line mode is supported");
   197e2:	2301      	movs	r3, #1
   197e4:	f04f 0100 	mov.w	r1, #0
   197e8:	f363 0107 	bfi	r1, r3, #0, #8
   197ec:	4a6a      	ldr	r2, [pc, #424]	; (19998 <spi_nrfx_transceive+0x238>)
   197ee:	4b6b      	ldr	r3, [pc, #428]	; (1999c <spi_nrfx_transceive+0x23c>)
   197f0:	486d      	ldr	r0, [pc, #436]	; (199a8 <spi_nrfx_transceive+0x248>)
   197f2:	1a9b      	subs	r3, r3, r2
   197f4:	08db      	lsrs	r3, r3, #3
   197f6:	f363 118f 	bfi	r1, r3, #6, #10
   197fa:	e7ec      	b.n	197d6 <spi_nrfx_transceive+0x76>
	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
   197fc:	f3c3 1345 	ubfx	r3, r3, #5, #6
   19800:	2b08      	cmp	r3, #8
   19802:	d00c      	beq.n	1981e <spi_nrfx_transceive+0xbe>
		LOG_ERR("Word sizes other than 8 bits"
   19804:	2301      	movs	r3, #1
   19806:	f04f 0100 	mov.w	r1, #0
   1980a:	f363 0107 	bfi	r1, r3, #0, #8
   1980e:	4a62      	ldr	r2, [pc, #392]	; (19998 <spi_nrfx_transceive+0x238>)
   19810:	4b62      	ldr	r3, [pc, #392]	; (1999c <spi_nrfx_transceive+0x23c>)
   19812:	4866      	ldr	r0, [pc, #408]	; (199ac <spi_nrfx_transceive+0x24c>)
   19814:	1a9b      	subs	r3, r3, r2
   19816:	08db      	lsrs	r3, r3, #3
   19818:	f363 118f 	bfi	r1, r3, #6, #10
   1981c:	e7db      	b.n	197d6 <spi_nrfx_transceive+0x76>
	if (spi_cfg->frequency < 125000) {
   1981e:	f8d8 2000 	ldr.w	r2, [r8]
   19822:	4b63      	ldr	r3, [pc, #396]	; (199b0 <spi_nrfx_transceive+0x250>)
   19824:	429a      	cmp	r2, r3
   19826:	d80c      	bhi.n	19842 <spi_nrfx_transceive+0xe2>
		LOG_ERR("Frequencies lower than 125 kHz are not supported");
   19828:	2301      	movs	r3, #1
   1982a:	f04f 0100 	mov.w	r1, #0
   1982e:	f363 0107 	bfi	r1, r3, #0, #8
   19832:	4a59      	ldr	r2, [pc, #356]	; (19998 <spi_nrfx_transceive+0x238>)
   19834:	4b59      	ldr	r3, [pc, #356]	; (1999c <spi_nrfx_transceive+0x23c>)
   19836:	485f      	ldr	r0, [pc, #380]	; (199b4 <spi_nrfx_transceive+0x254>)
   19838:	1a9b      	subs	r3, r3, r2
   1983a:	08db      	lsrs	r3, r3, #3
   1983c:	f363 118f 	bfi	r1, r3, #6, #10
   19840:	e7c9      	b.n	197d6 <spi_nrfx_transceive+0x76>
	if (ctx->config->cs && ctx->config->cs->gpio_dev) {
   19842:	f8d8 3008 	ldr.w	r3, [r8, #8]
	return dev->config->config_info;
   19846:	f8d0 9008 	ldr.w	r9, [r0, #8]
	ctx->config = spi_cfg;
   1984a:	f8c4 8000 	str.w	r8, [r4]
   1984e:	2b00      	cmp	r3, #0
   19850:	d06f      	beq.n	19932 <spi_nrfx_transceive+0x1d2>
   19852:	6818      	ldr	r0, [r3, #0]
   19854:	2800      	cmp	r0, #0
   19856:	d06c      	beq.n	19932 <spi_nrfx_transceive+0x1d2>
		gpio_pin_configure(ctx->config->cs->gpio_dev,
   19858:	685a      	ldr	r2, [r3, #4]
   1985a:	6843      	ldr	r3, [r0, #4]
   1985c:	f8d3 a000 	ldr.w	sl, [r3]
   19860:	2301      	movs	r3, #1
   19862:	47d0      	blx	sl
		gpio_pin_write(ctx->config->cs->gpio_dev,
   19864:	6822      	ldr	r2, [r4, #0]
   19866:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   19868:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
		gpio_pin_write(ctx->config->cs->gpio_dev,
   1986c:	43d2      	mvns	r2, r2
   1986e:	0fd2      	lsrs	r2, r2, #31
   19870:	e9d3 0100 	ldrd	r0, r1, [r3]
   19874:	f00b fc47 	bl	25106 <gpio_pin_write>
	nrf_spi_configure(spi->p_reg,
   19878:	f8b8 3004 	ldrh.w	r3, [r8, #4]
   1987c:	f8d9 1000 	ldr.w	r1, [r9]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
   19880:	0798      	lsls	r0, r3, #30
   19882:	f003 0204 	and.w	r2, r3, #4
   19886:	d563      	bpl.n	19950 <spi_nrfx_transceive+0x1f0>
			return NRF_SPI_MODE_2;
   19888:	2a00      	cmp	r2, #0
   1988a:	bf14      	ite	ne
   1988c:	2203      	movne	r2, #3
   1988e:	2202      	moveq	r2, #2
                                         nrf_spi_mode_t      spi_mode,
                                         nrf_spi_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPI_BIT_ORDER_MSB_FIRST ?
        SPI_CONFIG_ORDER_MsbFirst : SPI_CONFIG_ORDER_LsbFirst);
    switch (spi_mode)
   19890:	2a02      	cmp	r2, #2
	if (operation & SPI_TRANSFER_LSB) {
   19892:	f3c3 1300 	ubfx	r3, r3, #4, #1
   19896:	d05f      	beq.n	19958 <spi_nrfx_transceive+0x1f8>
   19898:	2a03      	cmp	r2, #3
   1989a:	d060      	beq.n	1995e <spi_nrfx_transceive+0x1fe>
   1989c:	2a01      	cmp	r2, #1
   1989e:	d101      	bne.n	198a4 <spi_nrfx_transceive+0x144>
        config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
                  (SPI_CONFIG_CPHA_Leading    << SPI_CONFIG_CPHA_Pos);
        break;

    case NRF_SPI_MODE_1:
        config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
   198a0:	f043 0302 	orr.w	r3, r3, #2
    case NRF_SPI_MODE_3:
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
                  (SPI_CONFIG_CPHA_Trailing   << SPI_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
   198a4:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
	if (frequency < 250000) {
   198a8:	4a43      	ldr	r2, [pc, #268]	; (199b8 <spi_nrfx_transceive+0x258>)
	nrf_spi_frequency_set(spi->p_reg,
   198aa:	f8d8 3000 	ldr.w	r3, [r8]
	if (frequency < 250000) {
   198ae:	4293      	cmp	r3, r2
   198b0:	d958      	bls.n	19964 <spi_nrfx_transceive+0x204>
	} else if (frequency < 500000) {
   198b2:	4a42      	ldr	r2, [pc, #264]	; (199bc <spi_nrfx_transceive+0x25c>)
   198b4:	4293      	cmp	r3, r2
   198b6:	d958      	bls.n	1996a <spi_nrfx_transceive+0x20a>
	} else if (frequency < 1000000) {
   198b8:	4a41      	ldr	r2, [pc, #260]	; (199c0 <spi_nrfx_transceive+0x260>)
   198ba:	4293      	cmp	r3, r2
   198bc:	d958      	bls.n	19970 <spi_nrfx_transceive+0x210>
	} else if (frequency < 2000000) {
   198be:	4a41      	ldr	r2, [pc, #260]	; (199c4 <spi_nrfx_transceive+0x264>)
   198c0:	4293      	cmp	r3, r2
   198c2:	d958      	bls.n	19976 <spi_nrfx_transceive+0x216>
	} else if (frequency < 4000000) {
   198c4:	4a40      	ldr	r2, [pc, #256]	; (199c8 <spi_nrfx_transceive+0x268>)
   198c6:	4293      	cmp	r3, r2
   198c8:	d958      	bls.n	1997c <spi_nrfx_transceive+0x21c>
		return NRF_SPI_FREQ_8M;
   198ca:	f502 1274 	add.w	r2, r2, #3997696	; 0x3d0000
   198ce:	f502 6210 	add.w	r2, r2, #2304	; 0x900
   198d2:	4293      	cmp	r3, r2
   198d4:	bf94      	ite	ls
   198d6:	f04f 4380 	movls.w	r3, #1073741824	; 0x40000000
   198da:	f04f 4300 	movhi.w	r3, #2147483648	; 0x80000000
    p_reg->FREQUENCY = (uint32_t)frequency;
   198de:	f8c1 3524 	str.w	r3, [r1, #1316]	; 0x524
		dev_data->busy = true;
   198e2:	2301      	movs	r3, #1
   198e4:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
	if (tx_bufs) {
   198e8:	2e00      	cmp	r6, #0
   198ea:	d04a      	beq.n	19982 <spi_nrfx_transceive+0x222>
		ctx->current_tx = tx_bufs->buffers;
   198ec:	6833      	ldr	r3, [r6, #0]
		ctx->tx_count = tx_bufs->count;
   198ee:	6872      	ldr	r2, [r6, #4]
		ctx->current_tx = tx_bufs->buffers;
   198f0:	63a3      	str	r3, [r4, #56]	; 0x38
		ctx->tx_count = tx_bufs->count;
   198f2:	63e2      	str	r2, [r4, #60]	; 0x3c
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   198f4:	681a      	ldr	r2, [r3, #0]
		ctx->tx_len = ctx->current_tx->len / dfs;
   198f6:	685b      	ldr	r3, [r3, #4]
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   198f8:	64a2      	str	r2, [r4, #72]	; 0x48
		ctx->tx_len = ctx->current_tx->len / dfs;
   198fa:	64e3      	str	r3, [r4, #76]	; 0x4c
	if (rx_bufs) {
   198fc:	2d00      	cmp	r5, #0
   198fe:	d045      	beq.n	1998c <spi_nrfx_transceive+0x22c>
		ctx->current_rx = rx_bufs->buffers;
   19900:	682b      	ldr	r3, [r5, #0]
		ctx->rx_count = rx_bufs->count;
   19902:	686a      	ldr	r2, [r5, #4]
		ctx->current_rx = rx_bufs->buffers;
   19904:	6423      	str	r3, [r4, #64]	; 0x40
		ctx->rx_count = rx_bufs->count;
   19906:	6462      	str	r2, [r4, #68]	; 0x44
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   19908:	681a      	ldr	r2, [r3, #0]
		ctx->rx_len = ctx->current_rx->len / dfs;
   1990a:	685b      	ldr	r3, [r3, #4]
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   1990c:	6522      	str	r2, [r4, #80]	; 0x50
		ctx->rx_len = ctx->current_rx->len / dfs;
   1990e:	6563      	str	r3, [r4, #84]	; 0x54
	ctx->sync_status = 0;
   19910:	2200      	movs	r2, #0
   19912:	6362      	str	r2, [r4, #52]	; 0x34
	_spi_context_cs_control(ctx, on, false);
   19914:	2101      	movs	r1, #1
   19916:	4620      	mov	r0, r4
   19918:	f00b fbfe 	bl	25118 <_spi_context_cs_control.isra.7>
		transfer_next_chunk(dev);
   1991c:	4638      	mov	r0, r7
   1991e:	f7ff fe7b 	bl	19618 <transfer_next_chunk>
	return z_impl_k_sem_take(sem, timeout);
   19922:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   19926:	f104 001c 	add.w	r0, r4, #28
   1992a:	f005 fa53 	bl	1edd4 <z_impl_k_sem_take>
	status = ctx->sync_status;
   1992e:	6b65      	ldr	r5, [r4, #52]	; 0x34
	return status;
   19930:	e73d      	b.n	197ae <spi_nrfx_transceive+0x4e>
		LOG_INF("CS control inhibited (no GPIO device)");
   19932:	2303      	movs	r3, #3
   19934:	f04f 0100 	mov.w	r1, #0
   19938:	f363 0107 	bfi	r1, r3, #0, #8
   1993c:	4a16      	ldr	r2, [pc, #88]	; (19998 <spi_nrfx_transceive+0x238>)
   1993e:	4b17      	ldr	r3, [pc, #92]	; (1999c <spi_nrfx_transceive+0x23c>)
   19940:	4822      	ldr	r0, [pc, #136]	; (199cc <spi_nrfx_transceive+0x26c>)
   19942:	1a9b      	subs	r3, r3, r2
   19944:	08db      	lsrs	r3, r3, #3
   19946:	f363 118f 	bfi	r1, r3, #6, #10
   1994a:	f007 fb76 	bl	2103a <log_0>
   1994e:	e793      	b.n	19878 <spi_nrfx_transceive+0x118>
			return NRF_SPI_MODE_0;
   19950:	3200      	adds	r2, #0
   19952:	bf18      	it	ne
   19954:	2201      	movne	r2, #1
   19956:	e79b      	b.n	19890 <spi_nrfx_transceive+0x130>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
   19958:	f043 0304 	orr.w	r3, r3, #4
        break;
   1995c:	e7a2      	b.n	198a4 <spi_nrfx_transceive+0x144>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
   1995e:	f043 0306 	orr.w	r3, r3, #6
        break;
   19962:	e79f      	b.n	198a4 <spi_nrfx_transceive+0x144>
		return NRF_SPI_FREQ_125K;
   19964:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
   19968:	e7b9      	b.n	198de <spi_nrfx_transceive+0x17e>
		return NRF_SPI_FREQ_250K;
   1996a:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   1996e:	e7b6      	b.n	198de <spi_nrfx_transceive+0x17e>
		return NRF_SPI_FREQ_500K;
   19970:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
   19974:	e7b3      	b.n	198de <spi_nrfx_transceive+0x17e>
		return NRF_SPI_FREQ_1M;
   19976:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   1997a:	e7b0      	b.n	198de <spi_nrfx_transceive+0x17e>
		return NRF_SPI_FREQ_2M;
   1997c:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
   19980:	e7ad      	b.n	198de <spi_nrfx_transceive+0x17e>
		ctx->tx_count = 0;
   19982:	e9c4 660e 	strd	r6, r6, [r4, #56]	; 0x38
		ctx->tx_len = 0;
   19986:	e9c4 6612 	strd	r6, r6, [r4, #72]	; 0x48
   1998a:	e7b7      	b.n	198fc <spi_nrfx_transceive+0x19c>
		ctx->rx_count = 0;
   1998c:	e9c4 5510 	strd	r5, r5, [r4, #64]	; 0x40
		ctx->rx_len = 0;
   19990:	e9c4 5514 	strd	r5, r5, [r4, #80]	; 0x50
   19994:	e7bc      	b.n	19910 <spi_nrfx_transceive+0x1b0>
   19996:	bf00      	nop
   19998:	00028540 	.word	0x00028540
   1999c:	000286b0 	.word	0x000286b0
   199a0:	00064edb 	.word	0x00064edb
   199a4:	00064efd 	.word	0x00064efd
   199a8:	00064f1c 	.word	0x00064f1c
   199ac:	00064f3f 	.word	0x00064f3f
   199b0:	0001e847 	.word	0x0001e847
   199b4:	00064f6e 	.word	0x00064f6e
   199b8:	0003d08f 	.word	0x0003d08f
   199bc:	0007a11f 	.word	0x0007a11f
   199c0:	000f423f 	.word	0x000f423f
   199c4:	001e847f 	.word	0x001e847f
   199c8:	003d08ff 	.word	0x003d08ff
   199cc:	00064f9f 	.word	0x00064f9f

000199d0 <nvmc_wait_ready>:

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrf_nvmc_ready_check(NRF_NVMC_Type const * p_reg)
{
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   199d0:	4a02      	ldr	r2, [pc, #8]	; (199dc <nvmc_wait_ready+0xc>)
   199d2:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
   199d6:	07db      	lsls	r3, r3, #31
   199d8:	d5fb      	bpl.n	199d2 <nvmc_wait_ready+0x2>
}
   199da:	4770      	bx	lr
   199dc:	4001e000 	.word	0x4001e000

000199e0 <flash_nrf_pages_layout>:
	*layout = &dev_layout;
   199e0:	4b02      	ldr	r3, [pc, #8]	; (199ec <flash_nrf_pages_layout+0xc>)
   199e2:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
   199e4:	2301      	movs	r3, #1
   199e6:	6013      	str	r3, [r2, #0]
}
   199e8:	4770      	bx	lr
   199ea:	bf00      	nop
   199ec:	2000199c 	.word	0x2000199c

000199f0 <time_slot_callback_helper>:
{
   199f0:	b570      	push	{r4, r5, r6, lr}
   199f2:	b08c      	sub	sp, #48	; 0x30
   199f4:	461d      	mov	r5, r3
   199f6:	4606      	mov	r6, r0
	ll_radio_state_abort();
   199f8:	f7f9 fa9e 	bl	12f38 <ll_radio_state_abort>
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
   199fc:	f10d 012f 	add.w	r1, sp, #47	; 0x2f
   19a00:	f10d 002e 	add.w	r0, sp, #46	; 0x2e
   19a04:	f00a fd28 	bl	24458 <ll_timeslice_ticker_id_get>
	err = ticker_start(instance_index, /* Radio instance ticker */
   19a08:	4b13      	ldr	r3, [pc, #76]	; (19a58 <time_slot_callback_helper+0x68>)
   19a0a:	9506      	str	r5, [sp, #24]
   19a0c:	2400      	movs	r4, #0
   19a0e:	e9cd 4304 	strd	r4, r3, [sp, #16]
   19a12:	2310      	movs	r3, #16
   19a14:	9300      	str	r3, [sp, #0]
   19a16:	e9cd 4407 	strd	r4, r4, [sp, #28]
   19a1a:	4633      	mov	r3, r6
   19a1c:	e9cd 4402 	strd	r4, r4, [sp, #8]
   19a20:	9401      	str	r4, [sp, #4]
   19a22:	4622      	mov	r2, r4
   19a24:	4621      	mov	r1, r4
   19a26:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
   19a2a:	f7f7 fa81 	bl	10f30 <ticker_start>
	if (err != TICKER_STATUS_SUCCESS && err != TICKER_STATUS_BUSY) {
   19a2e:	f030 0302 	bics.w	r3, r0, #2
   19a32:	d00e      	beq.n	19a52 <time_slot_callback_helper+0x62>
		((struct flash_op_desc *)context)->result = -ECANCELED;
   19a34:	f06f 038b 	mvn.w	r3, #139	; 0x8b
   19a38:	60ab      	str	r3, [r5, #8]
		err = ticker_stop(instance_index, 0, ticker_id, NULL, NULL);
   19a3a:	9400      	str	r4, [sp, #0]
   19a3c:	4623      	mov	r3, r4
   19a3e:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
   19a42:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
   19a46:	4621      	mov	r1, r4
   19a48:	f7f7 fb04 	bl	11054 <ticker_stop>
	z_impl_k_sem_give(sem);
   19a4c:	4803      	ldr	r0, [pc, #12]	; (19a5c <time_slot_callback_helper+0x6c>)
   19a4e:	f005 f995 	bl	1ed7c <z_impl_k_sem_give>
}
   19a52:	b00c      	add	sp, #48	; 0x30
   19a54:	bd70      	pop	{r4, r5, r6, pc}
   19a56:	bf00      	nop
   19a58:	00019a95 	.word	0x00019a95
   19a5c:	200019bc 	.word	0x200019bc

00019a60 <nrf_flash_init>:
{
   19a60:	b510      	push	{r4, lr}
	z_impl_k_sem_init(sem, initial_count, limit);
   19a62:	2201      	movs	r2, #1
   19a64:	4611      	mov	r1, r2
   19a66:	4808      	ldr	r0, [pc, #32]	; (19a88 <nrf_flash_init+0x28>)
   19a68:	f00e f9cf 	bl	27e0a <z_impl_k_sem_init>
   19a6c:	2201      	movs	r2, #1
   19a6e:	2100      	movs	r1, #0
   19a70:	4806      	ldr	r0, [pc, #24]	; (19a8c <nrf_flash_init+0x2c>)
	dev_layout.pages_count = nrfx_nvmc_flash_page_count_get();
   19a72:	4c07      	ldr	r4, [pc, #28]	; (19a90 <nrf_flash_init+0x30>)
   19a74:	f00e f9c9 	bl	27e0a <z_impl_k_sem_init>
   19a78:	f00b fc41 	bl	252fe <nrfx_nvmc_flash_page_count_get>
   19a7c:	6020      	str	r0, [r4, #0]
	dev_layout.pages_size = nrfx_nvmc_flash_page_size_get();
   19a7e:	f00b fc3a 	bl	252f6 <nrfx_nvmc_flash_page_size_get>
   19a82:	6060      	str	r0, [r4, #4]
}
   19a84:	2000      	movs	r0, #0
   19a86:	bd10      	pop	{r4, pc}
   19a88:	200019a4 	.word	0x200019a4
   19a8c:	200019bc 	.word	0x200019bc
   19a90:	2000199c 	.word	0x2000199c

00019a94 <time_slot_callback_work>:
{
   19a94:	b530      	push	{r4, r5, lr}
   19a96:	461d      	mov	r5, r3
   19a98:	b085      	sub	sp, #20
	if (op_desc->handler(op_desc->context) == FLASH_OP_DONE) {
   19a9a:	e9d3 3000 	ldrd	r3, r0, [r3]
   19a9e:	4798      	blx	r3
   19aa0:	4604      	mov	r4, r0
   19aa2:	b990      	cbnz	r0, 19aca <time_slot_callback_work+0x36>
		ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
   19aa4:	f10d 010f 	add.w	r1, sp, #15
   19aa8:	f10d 000e 	add.w	r0, sp, #14
   19aac:	f00a fcd4 	bl	24458 <ll_timeslice_ticker_id_get>
		result = ticker_stop(instance_index,
   19ab0:	9400      	str	r4, [sp, #0]
   19ab2:	4623      	mov	r3, r4
   19ab4:	f89d 200f 	ldrb.w	r2, [sp, #15]
   19ab8:	f89d 000e 	ldrb.w	r0, [sp, #14]
   19abc:	4621      	mov	r1, r4
   19abe:	f7f7 fac9 	bl	11054 <ticker_stop>
		((struct flash_op_desc *)context)->result = 0;
   19ac2:	60ac      	str	r4, [r5, #8]
	z_impl_k_sem_give(sem);
   19ac4:	4802      	ldr	r0, [pc, #8]	; (19ad0 <time_slot_callback_work+0x3c>)
   19ac6:	f005 f959 	bl	1ed7c <z_impl_k_sem_give>
}
   19aca:	b005      	add	sp, #20
   19acc:	bd30      	pop	{r4, r5, pc}
   19ace:	bf00      	nop
   19ad0:	200019bc 	.word	0x200019bc

00019ad4 <flash_nrf_erase>:
{
   19ad4:	b5f0      	push	{r4, r5, r6, r7, lr}
   19ad6:	b08b      	sub	sp, #44	; 0x2c
   19ad8:	460e      	mov	r6, r1
   19ada:	4615      	mov	r5, r2
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   19adc:	f00b fc0b 	bl	252f6 <nrfx_nvmc_flash_page_size_get>
	if (is_regular_addr_valid(addr, size)) {
   19ae0:	4629      	mov	r1, r5
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   19ae2:	4607      	mov	r7, r0
	if (is_regular_addr_valid(addr, size)) {
   19ae4:	4630      	mov	r0, r6
   19ae6:	f00b fb63 	bl	251b0 <is_regular_addr_valid>
   19aea:	2800      	cmp	r0, #0
   19aec:	d03a      	beq.n	19b64 <flash_nrf_erase+0x90>
		if (((addr % pg_size) != 0) || ((size % pg_size) != 0)) {
   19aee:	fbb6 f3f7 	udiv	r3, r6, r7
   19af2:	fb07 6313 	mls	r3, r7, r3, r6
   19af6:	bbab      	cbnz	r3, 19b64 <flash_nrf_erase+0x90>
   19af8:	fbb5 f4f7 	udiv	r4, r5, r7
   19afc:	fb07 5414 	mls	r4, r7, r4, r5
   19b00:	bb84      	cbnz	r4, 19b64 <flash_nrf_erase+0x90>
		if (!n_pages) {
   19b02:	42af      	cmp	r7, r5
   19b04:	d822      	bhi.n	19b4c <flash_nrf_erase+0x78>
	return z_impl_k_sem_take(sem, timeout);
   19b06:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   19b0a:	4818      	ldr	r0, [pc, #96]	; (19b6c <flash_nrf_erase+0x98>)
   19b0c:	f005 f962 	bl	1edd4 <z_impl_k_sem_take>
	if (ticker_is_initialized(0)) {
   19b10:	4620      	mov	r0, r4
   19b12:	f7f7 f9ef 	bl	10ef4 <ticker_is_initialized>
   19b16:	ab04      	add	r3, sp, #16
   19b18:	4601      	mov	r1, r0
   19b1a:	b1d0      	cbz	r0, 19b52 <flash_nrf_erase+0x7e>
	struct flash_context context = {
   19b1c:	2210      	movs	r2, #16
   19b1e:	4621      	mov	r1, r4
   19b20:	4618      	mov	r0, r3
   19b22:	f7e8 f884 	bl	1c2e <memset>
   19b26:	2201      	movs	r2, #1
   19b28:	f88d 201c 	strb.w	r2, [sp, #28]
   19b2c:	4a10      	ldr	r2, [pc, #64]	; (19b70 <flash_nrf_erase+0x9c>)
	struct flash_op_desc flash_op_desc = {
   19b2e:	9403      	str	r4, [sp, #12]
	struct flash_context context = {
   19b30:	e9cd 2208 	strd	r2, r2, [sp, #32]
	struct flash_op_desc flash_op_desc = {
   19b34:	4a0f      	ldr	r2, [pc, #60]	; (19b74 <flash_nrf_erase+0xa0>)
   19b36:	e9cd 2001 	strd	r2, r0, [sp, #4]
	return work_in_time_slice(&flash_op_desc);
   19b3a:	a801      	add	r0, sp, #4
	struct flash_context context = {
   19b3c:	e9cd 6505 	strd	r6, r5, [sp, #20]
	return work_in_time_slice(&flash_op_desc);
   19b40:	f7ea f9fe 	bl	3f40 <work_in_time_slice>
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
		.enable_time_limit = 0 /* disable time limit */
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */
	};

	return	erase_op(&context);
   19b44:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
   19b46:	4809      	ldr	r0, [pc, #36]	; (19b6c <flash_nrf_erase+0x98>)
   19b48:	f005 f918 	bl	1ed7c <z_impl_k_sem_give>
}
   19b4c:	4620      	mov	r0, r4
   19b4e:	b00b      	add	sp, #44	; 0x2c
   19b50:	bdf0      	pop	{r4, r5, r6, r7, pc}
	struct flash_context context = {
   19b52:	2218      	movs	r2, #24
   19b54:	4618      	mov	r0, r3
   19b56:	f7e8 f86a 	bl	1c2e <memset>
   19b5a:	e9cd 6505 	strd	r6, r5, [sp, #20]
	return	erase_op(&context);
   19b5e:	f7ea f9a7 	bl	3eb0 <erase_op>
   19b62:	e7ef      	b.n	19b44 <flash_nrf_erase+0x70>
		return -EINVAL;
   19b64:	f06f 0415 	mvn.w	r4, #21
   19b68:	e7f0      	b.n	19b4c <flash_nrf_erase+0x78>
   19b6a:	bf00      	nop
   19b6c:	200019a4 	.word	0x200019a4
   19b70:	00015e64 	.word	0x00015e64
   19b74:	00003eb1 	.word	0x00003eb1

00019b78 <flash_nrf_write>:
{
   19b78:	b570      	push	{r4, r5, r6, lr}
   19b7a:	460d      	mov	r5, r1
   19b7c:	b08a      	sub	sp, #40	; 0x28
	if (is_regular_addr_valid(addr, len)) {
   19b7e:	4619      	mov	r1, r3
   19b80:	4628      	mov	r0, r5
{
   19b82:	4616      	mov	r6, r2
   19b84:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
   19b86:	f00b fb13 	bl	251b0 <is_regular_addr_valid>
   19b8a:	b368      	cbz	r0, 19be8 <flash_nrf_write+0x70>
	if (!len) {
   19b8c:	b304      	cbz	r4, 19bd0 <flash_nrf_write+0x58>
	return z_impl_k_sem_take(sem, timeout);
   19b8e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   19b92:	4817      	ldr	r0, [pc, #92]	; (19bf0 <flash_nrf_write+0x78>)
   19b94:	f005 f91e 	bl	1edd4 <z_impl_k_sem_take>
	if (ticker_is_initialized(0)) {
   19b98:	2000      	movs	r0, #0
   19b9a:	f7f7 f9ab 	bl	10ef4 <ticker_is_initialized>
   19b9e:	4603      	mov	r3, r0
   19ba0:	a804      	add	r0, sp, #16
   19ba2:	b1c3      	cbz	r3, 19bd6 <flash_nrf_write+0x5e>
	struct flash_context context = {
   19ba4:	2301      	movs	r3, #1
   19ba6:	f88d 301c 	strb.w	r3, [sp, #28]
   19baa:	f641 534c 	movw	r3, #7500	; 0x1d4c
   19bae:	e9cd 3308 	strd	r3, r3, [sp, #32]
	struct flash_op_desc flash_op_desc = {
   19bb2:	2300      	movs	r3, #0
   19bb4:	9303      	str	r3, [sp, #12]
   19bb6:	4b0f      	ldr	r3, [pc, #60]	; (19bf4 <flash_nrf_write+0x7c>)
	struct flash_context context = {
   19bb8:	9406      	str	r4, [sp, #24]
	struct flash_op_desc flash_op_desc = {
   19bba:	e9cd 3001 	strd	r3, r0, [sp, #4]
	return  work_in_time_slice(&flash_op_desc);
   19bbe:	a801      	add	r0, sp, #4
	struct flash_context context = {
   19bc0:	e9cd 6504 	strd	r6, r5, [sp, #16]
	return  work_in_time_slice(&flash_op_desc);
   19bc4:	f7ea f9bc 	bl	3f40 <work_in_time_slice>
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
		.enable_time_limit = 0 /* disable time limit */
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */
	};

	return write_op(&context);
   19bc8:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
   19bca:	4809      	ldr	r0, [pc, #36]	; (19bf0 <flash_nrf_write+0x78>)
   19bcc:	f005 f8d6 	bl	1ed7c <z_impl_k_sem_give>
}
   19bd0:	4620      	mov	r0, r4
   19bd2:	b00a      	add	sp, #40	; 0x28
   19bd4:	bd70      	pop	{r4, r5, r6, pc}
	struct flash_context context = {
   19bd6:	e9cd 3307 	strd	r3, r3, [sp, #28]
   19bda:	9309      	str	r3, [sp, #36]	; 0x24
   19bdc:	e9cd 6504 	strd	r6, r5, [sp, #16]
   19be0:	9406      	str	r4, [sp, #24]
	return write_op(&context);
   19be2:	f7ea fa21 	bl	4028 <write_op>
   19be6:	e7ef      	b.n	19bc8 <flash_nrf_write+0x50>
		return -EINVAL;
   19be8:	f06f 0415 	mvn.w	r4, #21
   19bec:	e7f0      	b.n	19bd0 <flash_nrf_write+0x58>
   19bee:	bf00      	nop
   19bf0:	200019a4 	.word	0x200019a4
   19bf4:	00004029 	.word	0x00004029

00019bf8 <rng_pool_get>:
#pragma GCC push_options
#if defined(CONFIG_BT_CTLR_FAST_ENC)
#pragma GCC optimize ("Ofast")
#endif
static u16_t rng_pool_get(struct rng_pool *rngp, u8_t *buf, u16_t len)
{
   19bf8:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32_t last  = rngp->last;
   19bfa:	7883      	ldrb	r3, [r0, #2]
	u32_t mask  = rngp->mask;
   19bfc:	78c7      	ldrb	r7, [r0, #3]
	__asm__ volatile(
   19bfe:	f04f 0420 	mov.w	r4, #32
   19c02:	f3ef 8e11 	mrs	lr, BASEPRI
   19c06:	f384 8811 	msr	BASEPRI, r4
   19c0a:	f3bf 8f6f 	isb	sy
	u32_t first, available;
	u32_t other_read_in_progress;
	unsigned int key;

	key = irq_lock();
	first = rngp->first_alloc;
   19c0e:	7806      	ldrb	r6, [r0, #0]
	/*
	 * The other_read_in_progress is non-zero if rngp->first_read != first,
	 * which means that lower-priority code (which was interrupted by this
	 * call) already allocated area for read.
	 */
	other_read_in_progress = (rngp->first_read ^ first);
   19c10:	f890 c001 	ldrb.w	ip, [r0, #1]

	available = (last - first) & mask;
   19c14:	1b9b      	subs	r3, r3, r6
   19c16:	403b      	ands	r3, r7
	if (available < len) {
   19c18:	429a      	cmp	r2, r3
		len = available;
   19c1a:	bf88      	it	hi
   19c1c:	b29a      	uxthhi	r2, r3

	/*
	 * Move alloc index forward to signal, that part of the buffer is
	 * now reserved for this call.
	 */
	rngp->first_alloc = (first + len) & mask;
   19c1e:	18b4      	adds	r4, r6, r2
   19c20:	403c      	ands	r4, r7
	first = rngp->first_alloc;
   19c22:	4635      	mov	r5, r6
	rngp->first_alloc = (first + len) & mask;
   19c24:	7004      	strb	r4, [r0, #0]
	__asm__ volatile(
   19c26:	f38e 8811 	msr	BASEPRI, lr
   19c2a:	f3bf 8f6f 	isb	sy
   19c2e:	440a      	add	r2, r1
	u8_t *dst   = buf;
   19c30:	460c      	mov	r4, r1
	irq_unlock(key);

	while (likely(len--)) {
   19c32:	42a2      	cmp	r2, r4
   19c34:	d11a      	bne.n	19c6c <rng_pool_get+0x74>
	/*
	 * If this call is the last one accessing the pool, move read index
	 * to signal that all allocated regions are now read and could be
	 * overwritten.
	 */
	if (likely(!other_read_in_progress)) {
   19c36:	4566      	cmp	r6, ip
   19c38:	d10d      	bne.n	19c56 <rng_pool_get+0x5e>
	__asm__ volatile(
   19c3a:	f04f 0520 	mov.w	r5, #32
   19c3e:	f3ef 8211 	mrs	r2, BASEPRI
   19c42:	f385 8811 	msr	BASEPRI, r5
   19c46:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		rngp->first_read = rngp->first_alloc;
   19c4a:	7805      	ldrb	r5, [r0, #0]
   19c4c:	7045      	strb	r5, [r0, #1]
	__asm__ volatile(
   19c4e:	f382 8811 	msr	BASEPRI, r2
   19c52:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}

	len = dst - buf;
   19c56:	1a64      	subs	r4, r4, r1
   19c58:	b2a2      	uxth	r2, r4
	available = available - len;
	if (available <= rngp->threshold) {
   19c5a:	7901      	ldrb	r1, [r0, #4]
	available = available - len;
   19c5c:	1a9c      	subs	r4, r3, r2
	if (available <= rngp->threshold) {
   19c5e:	42a1      	cmp	r1, r4
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)rng_task);
}

NRF_STATIC_INLINE void nrf_rng_task_trigger(NRF_RNG_Type * p_reg, nrf_rng_task_t rng_task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   19c60:	bf22      	ittt	cs
   19c62:	4b07      	ldrcs	r3, [pc, #28]	; (19c80 <rng_pool_get+0x88>)
   19c64:	2101      	movcs	r1, #1
   19c66:	6019      	strcs	r1, [r3, #0]
		nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);
	}

	return len;
}
   19c68:	4610      	mov	r0, r2
   19c6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*dst++ = rngp->buffer[first];
   19c6c:	eb00 0e05 	add.w	lr, r0, r5
		first = (first + 1) & mask;
   19c70:	3501      	adds	r5, #1
		*dst++ = rngp->buffer[first];
   19c72:	f89e e005 	ldrb.w	lr, [lr, #5]
   19c76:	f804 eb01 	strb.w	lr, [r4], #1
		first = (first + 1) & mask;
   19c7a:	403d      	ands	r5, r7
   19c7c:	e7d9      	b.n	19c32 <rng_pool_get+0x3a>
   19c7e:	bf00      	nop
   19c80:	4000d000 	.word	0x4000d000

00019c84 <entropy_nrf5_get_entropy>:
		k_sem_give(&entropy_nrf5_data.sem_sync);
	}
}

static int entropy_nrf5_get_entropy(struct device *device, u8_t *buf, u16_t len)
{
   19c84:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return z_impl_k_sem_take(sem, timeout);
   19c88:	4d11      	ldr	r5, [pc, #68]	; (19cd0 <entropy_nrf5_get_entropy+0x4c>)
   19c8a:	460e      	mov	r6, r1
   19c8c:	4614      	mov	r4, r2

	while (len) {
		u16_t bytes;

		k_sem_take(&entropy_nrf5_data.sem_lock, K_FOREVER);
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
   19c8e:	f105 0845 	add.w	r8, r5, #69	; 0x45
   19c92:	f105 0918 	add.w	r9, r5, #24
	while (len) {
   19c96:	b914      	cbnz	r4, 19c9e <entropy_nrf5_get_entropy+0x1a>
		len -= bytes;
		buf += bytes;
	}

	return 0;
}
   19c98:	4620      	mov	r0, r4
   19c9a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   19c9e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   19ca2:	4628      	mov	r0, r5
   19ca4:	f005 f896 	bl	1edd4 <z_impl_k_sem_take>
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
   19ca8:	4622      	mov	r2, r4
   19caa:	4631      	mov	r1, r6
   19cac:	4640      	mov	r0, r8
   19cae:	f7ff ffa3 	bl	19bf8 <rng_pool_get>
   19cb2:	4607      	mov	r7, r0
	z_impl_k_sem_give(sem);
   19cb4:	4628      	mov	r0, r5
   19cb6:	f005 f861 	bl	1ed7c <z_impl_k_sem_give>
		if (bytes == 0U) {
   19cba:	b92f      	cbnz	r7, 19cc8 <entropy_nrf5_get_entropy+0x44>
	return z_impl_k_sem_take(sem, timeout);
   19cbc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   19cc0:	4648      	mov	r0, r9
   19cc2:	f005 f887 	bl	1edd4 <z_impl_k_sem_take>
   19cc6:	e7e6      	b.n	19c96 <entropy_nrf5_get_entropy+0x12>
		len -= bytes;
   19cc8:	1be4      	subs	r4, r4, r7
   19cca:	b2a4      	uxth	r4, r4
		buf += bytes;
   19ccc:	443e      	add	r6, r7
   19cce:	e7e2      	b.n	19c96 <entropy_nrf5_get_entropy+0x12>
   19cd0:	200019d4 	.word	0x200019d4

00019cd4 <random_byte_get>:
{
   19cd4:	b082      	sub	sp, #8
	__asm__ volatile(
   19cd6:	f04f 0320 	mov.w	r3, #32
   19cda:	f3ef 8211 	mrs	r2, BASEPRI
   19cde:	f383 8811 	msr	BASEPRI, r3
   19ce2:	f3bf 8f6f 	isb	sy
#endif
}

NRF_STATIC_INLINE bool nrf_rng_event_check(NRF_RNG_Type const * p_reg, nrf_rng_event_t rng_event)
{
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   19ce6:	4b0a      	ldr	r3, [pc, #40]	; (19d10 <random_byte_get+0x3c>)
   19ce8:	6819      	ldr	r1, [r3, #0]
	if (nrf_rng_event_check(NRF_RNG, NRF_RNG_EVENT_VALRDY)) {
   19cea:	b171      	cbz	r1, 19d0a <random_byte_get+0x36>
     p_reg->SHORTS &= ~mask;
}

NRF_STATIC_INLINE uint8_t nrf_rng_random_value_get(NRF_RNG_Type const * p_reg)
{
    return (uint8_t)(p_reg->VALUE & RNG_VALUE_VALUE_Msk);
   19cec:	4909      	ldr	r1, [pc, #36]	; (19d14 <random_byte_get+0x40>)
   19cee:	f8d1 0508 	ldr.w	r0, [r1, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   19cf2:	2100      	movs	r1, #0
   19cf4:	6019      	str	r1, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   19cf6:	681b      	ldr	r3, [r3, #0]
   19cf8:	9301      	str	r3, [sp, #4]
    (void)dummy;
   19cfa:	9b01      	ldr	r3, [sp, #4]
		retval = nrf_rng_random_value_get(NRF_RNG);
   19cfc:	b2c0      	uxtb	r0, r0
	__asm__ volatile(
   19cfe:	f382 8811 	msr	BASEPRI, r2
   19d02:	f3bf 8f6f 	isb	sy
}
   19d06:	b002      	add	sp, #8
   19d08:	4770      	bx	lr
	int retval = -EAGAIN;
   19d0a:	f06f 000a 	mvn.w	r0, #10
   19d0e:	e7f6      	b.n	19cfe <random_byte_get+0x2a>
   19d10:	4000d100 	.word	0x4000d100
   19d14:	4000d000 	.word	0x4000d000

00019d18 <entropy_nrf5_get_entropy_isr>:
	u16_t cnt = len;

	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == DEV_DATA(dev));

	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
   19d18:	07db      	lsls	r3, r3, #31
{
   19d1a:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   19d1e:	4688      	mov	r8, r1
   19d20:	4614      	mov	r4, r2
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
   19d22:	d405      	bmi.n	19d30 <entropy_nrf5_get_entropy_isr+0x18>
		return rng_pool_get((struct rng_pool *)(entropy_nrf5_data.isr),
   19d24:	4820      	ldr	r0, [pc, #128]	; (19da8 <entropy_nrf5_get_entropy_isr+0x90>)
   19d26:	f7ff ff67 	bl	19bf8 <rng_pool_get>
			irq_enable(RNG_IRQn);
		}
	}

	return cnt;
}
   19d2a:	b002      	add	sp, #8
   19d2c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
   19d30:	2a00      	cmp	r2, #0
   19d32:	d032      	beq.n	19d9a <entropy_nrf5_get_entropy_isr+0x82>
	__asm__ volatile(
   19d34:	f04f 0320 	mov.w	r3, #32
   19d38:	f3ef 8511 	mrs	r5, BASEPRI
   19d3c:	f383 8811 	msr	BASEPRI, r3
   19d40:	f3bf 8f6f 	isb	sy
		irq_enabled = irq_is_enabled(RNG_IRQn);
   19d44:	200d      	movs	r0, #13
   19d46:	f7ec feff 	bl	6b48 <arch_irq_is_enabled>
   19d4a:	4607      	mov	r7, r0
		irq_disable(RNG_IRQn);
   19d4c:	200d      	movs	r0, #13
   19d4e:	f7ec fee7 	bl	6b20 <arch_irq_disable>
	__asm__ volatile(
   19d52:	f385 8811 	msr	BASEPRI, r5
   19d56:	f3bf 8f6f 	isb	sy
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   19d5a:	4e14      	ldr	r6, [pc, #80]	; (19dac <entropy_nrf5_get_entropy_isr+0x94>)
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   19d5c:	f8df 9054 	ldr.w	r9, [pc, #84]	; 19db4 <entropy_nrf5_get_entropy_isr+0x9c>
   19d60:	2200      	movs	r2, #0
   19d62:	6032      	str	r2, [r6, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   19d64:	6832      	ldr	r2, [r6, #0]
   19d66:	9201      	str	r2, [sp, #4]
    (void)dummy;
   19d68:	9a01      	ldr	r2, [sp, #4]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   19d6a:	4a11      	ldr	r2, [pc, #68]	; (19db0 <entropy_nrf5_get_entropy_isr+0x98>)
   19d6c:	2101      	movs	r1, #1
   19d6e:	6011      	str	r1, [r2, #0]
   19d70:	4625      	mov	r5, r4
   19d72:	f44f 5a00 	mov.w	sl, #8192	; 0x2000
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   19d76:	6833      	ldr	r3, [r6, #0]
			while (!nrf_rng_event_check(NRF_RNG,
   19d78:	b18b      	cbz	r3, 19d9e <entropy_nrf5_get_entropy_isr+0x86>
			byte = random_byte_get();
   19d7a:	f7ff ffab 	bl	19cd4 <random_byte_get>
			if (byte < 0) {
   19d7e:	2800      	cmp	r0, #0
   19d80:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
   19d84:	dbf7      	blt.n	19d76 <entropy_nrf5_get_entropy_isr+0x5e>
   19d86:	3d01      	subs	r5, #1
   19d88:	b2ad      	uxth	r5, r5
			buf[--len] = byte;
   19d8a:	f808 0005 	strb.w	r0, [r8, r5]
		} while (len);
   19d8e:	2d00      	cmp	r5, #0
   19d90:	d1f1      	bne.n	19d76 <entropy_nrf5_get_entropy_isr+0x5e>
		if (irq_enabled) {
   19d92:	b117      	cbz	r7, 19d9a <entropy_nrf5_get_entropy_isr+0x82>
			irq_enable(RNG_IRQn);
   19d94:	200d      	movs	r0, #13
   19d96:	f7ec feb3 	bl	6b00 <arch_irq_enable>
	return cnt;
   19d9a:	4620      	mov	r0, r4
   19d9c:	e7c5      	b.n	19d2a <entropy_nrf5_get_entropy_isr+0x12>
				__WFE();
   19d9e:	bf20      	wfe
				__SEV();
   19da0:	bf40      	sev
				__WFE();
   19da2:	bf20      	wfe
   19da4:	e7e7      	b.n	19d76 <entropy_nrf5_get_entropy_isr+0x5e>
   19da6:	bf00      	nop
   19da8:	20001a04 	.word	0x20001a04
   19dac:	4000d100 	.word	0x4000d100
   19db0:	4000d000 	.word	0x4000d000
   19db4:	e000e100 	.word	0xe000e100

00019db8 <entropy_nrf5_init>:
		    entropy_nrf5_init, &entropy_nrf5_data, NULL,
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &entropy_nrf5_api_funcs);

static int entropy_nrf5_init(struct device *device)
{
   19db8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	z_impl_k_sem_init(sem, initial_count, limit);
   19dba:	4c1b      	ldr	r4, [pc, #108]	; (19e28 <entropy_nrf5_init+0x70>)
   19dbc:	2201      	movs	r2, #1
   19dbe:	4611      	mov	r1, r2
   19dc0:	4620      	mov	r0, r4
   19dc2:	f00e f822 	bl	27e0a <z_impl_k_sem_init>
   19dc6:	2201      	movs	r2, #1
   19dc8:	f104 0018 	add.w	r0, r4, #24
   19dcc:	2100      	movs	r1, #0
   19dce:	f00e f81c 	bl	27e0a <z_impl_k_sem_init>
	rngp->mask	  = size - 1;
   19dd2:	f240 4307 	movw	r3, #1031	; 0x407
   19dd6:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
	rngp->first_alloc = 0U;
   19dda:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   19dde:	6323      	str	r3, [r4, #48]	; 0x30
	rngp->threshold	  = threshold;
   19de0:	230c      	movs	r3, #12
   19de2:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	rngp->first_alloc = 0U;
   19de6:	2500      	movs	r5, #0
}

NRF_STATIC_INLINE void nrf_rng_error_correction_enable(NRF_RNG_Type * p_reg)
{
    p_reg->CONFIG |= RNG_CONFIG_DERCEN_Msk;
   19de8:	4b10      	ldr	r3, [pc, #64]	; (19e2c <entropy_nrf5_init+0x74>)
   19dea:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
	rngp->first_read  = 0U;
   19dee:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
   19df2:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   19df6:	f042 0201 	orr.w	r2, r2, #1
   19dfa:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   19dfe:	4a0c      	ldr	r2, [pc, #48]	; (19e30 <entropy_nrf5_init+0x78>)
   19e00:	6015      	str	r5, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   19e02:	6812      	ldr	r2, [r2, #0]
   19e04:	9201      	str	r2, [sp, #4]
    (void)dummy;
   19e06:	9a01      	ldr	r2, [sp, #4]
    p_reg->INTENSET = mask;
   19e08:	2201      	movs	r2, #1
   19e0a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

	nrf_rng_event_clear(NRF_RNG, NRF_RNG_EVENT_VALRDY);
	nrf_rng_int_enable(NRF_RNG, NRF_RNG_INT_VALRDY_MASK);
	nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);

	IRQ_CONNECT(RNG_IRQn, CONFIG_ENTROPY_NRF5_PRI, isr,
   19e0e:	2105      	movs	r1, #5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   19e10:	601a      	str	r2, [r3, #0]
   19e12:	200d      	movs	r0, #13
   19e14:	462a      	mov	r2, r5
   19e16:	f7ec fea5 	bl	6b64 <z_arm_irq_priority_set>
		    &entropy_nrf5_data, 0);
	irq_enable(RNG_IRQn);
   19e1a:	200d      	movs	r0, #13
   19e1c:	f7ec fe70 	bl	6b00 <arch_irq_enable>

	return 0;
}
   19e20:	4628      	mov	r0, r5
   19e22:	b003      	add	sp, #12
   19e24:	bd30      	pop	{r4, r5, pc}
   19e26:	bf00      	nop
   19e28:	200019d4 	.word	0x200019d4
   19e2c:	4000d000 	.word	0x4000d000
   19e30:	4000d100 	.word	0x4000d100

00019e34 <isr>:
{
   19e34:	b510      	push	{r4, lr}
	byte = random_byte_get();
   19e36:	f7ff ff4d 	bl	19cd4 <random_byte_get>
	if (byte < 0) {
   19e3a:	2800      	cmp	r0, #0
   19e3c:	db20      	blt.n	19e80 <isr+0x4c>
	u8_t last  = rngp->last;
   19e3e:	4b17      	ldr	r3, [pc, #92]	; (19e9c <isr+0x68>)
   19e40:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	if (((last - first) & mask) == mask) {
   19e44:	f893 1031 	ldrb.w	r1, [r3, #49]	; 0x31
	u8_t mask  = rngp->mask;
   19e48:	f893 4033 	ldrb.w	r4, [r3, #51]	; 0x33
	if (((last - first) & mask) == mask) {
   19e4c:	1a51      	subs	r1, r2, r1
   19e4e:	ea34 0101 	bics.w	r1, r4, r1
	ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.isr), byte);
   19e52:	b2c0      	uxtb	r0, r0
	if (((last - first) & mask) == mask) {
   19e54:	d10d      	bne.n	19e72 <isr+0x3e>
	u8_t last  = rngp->last;
   19e56:	f893 2047 	ldrb.w	r2, [r3, #71]	; 0x47
	if (((last - first) & mask) == mask) {
   19e5a:	f893 1046 	ldrb.w	r1, [r3, #70]	; 0x46
	u8_t mask  = rngp->mask;
   19e5e:	f893 4048 	ldrb.w	r4, [r3, #72]	; 0x48
	if (((last - first) & mask) == mask) {
   19e62:	1a51      	subs	r1, r2, r1
   19e64:	ea34 0101 	bics.w	r1, r4, r1
   19e68:	d10b      	bne.n	19e82 <isr+0x4e>
   19e6a:	4b0d      	ldr	r3, [pc, #52]	; (19ea0 <isr+0x6c>)
   19e6c:	2201      	movs	r2, #1
   19e6e:	601a      	str	r2, [r3, #0]
   19e70:	e00e      	b.n	19e90 <isr+0x5c>
	rngp->buffer[last] = byte;
   19e72:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
   19e74:	3201      	adds	r2, #1
   19e76:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
   19e78:	f881 0035 	strb.w	r0, [r1, #53]	; 0x35
	rngp->last = (last + 1) & mask;
   19e7c:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
}
   19e80:	bd10      	pop	{r4, pc}
	rngp->buffer[last] = byte;
   19e82:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
   19e84:	3201      	adds	r2, #1
   19e86:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
   19e88:	f881 004a 	strb.w	r0, [r1, #74]	; 0x4a
	rngp->last = (last + 1) & mask;
   19e8c:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
	z_impl_k_sem_give(sem);
   19e90:	4804      	ldr	r0, [pc, #16]	; (19ea4 <isr+0x70>)
}
   19e92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   19e96:	f004 bf71 	b.w	1ed7c <z_impl_k_sem_give>
   19e9a:	bf00      	nop
   19e9c:	200019d4 	.word	0x200019d4
   19ea0:	4000d004 	.word	0x4000d004
   19ea4:	200019ec 	.word	0x200019ec

00019ea8 <errata_108>:
static bool errata_12(void)
{
    uint32_t var1;
    uint32_t var2;

    if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
   19ea8:	4b04      	ldr	r3, [pc, #16]	; (19ebc <errata_108+0x14>)
   19eaa:	6818      	ldr	r0, [r3, #0]
   19eac:	1c42      	adds	r2, r0, #1
    {
        var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   19eae:	bf04      	itt	eq
   19eb0:	4b03      	ldreq	r3, [pc, #12]	; (19ec0 <errata_108+0x18>)
   19eb2:	7818      	ldrbeq	r0, [r3, #0]
        break;

    }

    return false;
}
   19eb4:	1f83      	subs	r3, r0, #6
   19eb6:	4258      	negs	r0, r3
   19eb8:	4158      	adcs	r0, r3
   19eba:	4770      	bx	lr
   19ebc:	10000130 	.word	0x10000130
   19ec0:	f0000fe0 	.word	0xf0000fe0

00019ec4 <errata_16>:
    return false;
}

static bool errata_16(void)
{
    uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   19ec4:	4b07      	ldr	r3, [pc, #28]	; (19ee4 <errata_16+0x20>)
   19ec6:	781b      	ldrb	r3, [r3, #0]
    uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;

    switch(var1)
   19ec8:	2b06      	cmp	r3, #6
   19eca:	d109      	bne.n	19ee0 <errata_16+0x1c>
    uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   19ecc:	4b06      	ldr	r3, [pc, #24]	; (19ee8 <errata_16+0x24>)
   19ece:	681b      	ldr	r3, [r3, #0]
   19ed0:	f3c3 1303 	ubfx	r3, r3, #4, #4
   19ed4:	3b03      	subs	r3, #3
   19ed6:	2b03      	cmp	r3, #3
   19ed8:	d802      	bhi.n	19ee0 <errata_16+0x1c>
   19eda:	4a04      	ldr	r2, [pc, #16]	; (19eec <errata_16+0x28>)
   19edc:	5cd0      	ldrb	r0, [r2, r3]
   19ede:	4770      	bx	lr
            }
        break;

    }

    return false;
   19ee0:	2000      	movs	r0, #0
}
   19ee2:	4770      	bx	lr
   19ee4:	f0000fe0 	.word	0xf0000fe0
   19ee8:	f0000fe8 	.word	0xf0000fe8
   19eec:	00064fd2 	.word	0x00064fd2

00019ef0 <SystemInit>:
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
}

void SystemInit(void)
{
   19ef0:	b508      	push	{r3, lr}
        NRF_P0->PIN_CNF[20] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
    #endif
    
    /* Workaround for Errata 12 "COMP: Reference ladder not correctly calibrated" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp */
    if (errata_12()){
   19ef2:	f7ff ffd9 	bl	19ea8 <errata_108>
   19ef6:	b128      	cbz	r0, 19f04 <SystemInit+0x14>
        *(volatile uint32_t *)0x40013540 = (*(uint32_t *)0x10000324 & 0x00001F00) >> 8;
   19ef8:	4b7c      	ldr	r3, [pc, #496]	; (1a0ec <SystemInit+0x1fc>)
   19efa:	4a7d      	ldr	r2, [pc, #500]	; (1a0f0 <SystemInit+0x200>)
   19efc:	681b      	ldr	r3, [r3, #0]
   19efe:	f3c3 2304 	ubfx	r3, r3, #8, #5
   19f02:	6013      	str	r3, [r2, #0]
    }
    
    /* Workaround for Errata 16 "System: RAM may be corrupt on wakeup from CPU IDLE" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp */
    if (errata_16()){
   19f04:	f7ff ffde 	bl	19ec4 <errata_16>
   19f08:	b110      	cbz	r0, 19f10 <SystemInit+0x20>
        *(volatile uint32_t *)0x4007C074 = 3131961357ul;
   19f0a:	4b7a      	ldr	r3, [pc, #488]	; (1a0f4 <SystemInit+0x204>)
   19f0c:	4a7a      	ldr	r2, [pc, #488]	; (1a0f8 <SystemInit+0x208>)
   19f0e:	601a      	str	r2, [r3, #0]
    }

    /* Workaround for Errata 31 "CLOCK: Calibration values are not correctly loaded from FICR at reset" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp */
    if (errata_31()){
   19f10:	f7ff ffca 	bl	19ea8 <errata_108>
   19f14:	b128      	cbz	r0, 19f22 <SystemInit+0x32>
        *(volatile uint32_t *)0x4000053C = ((*(volatile uint32_t *)0x10000244) & 0x0000E000) >> 13;
   19f16:	4b79      	ldr	r3, [pc, #484]	; (1a0fc <SystemInit+0x20c>)
   19f18:	4a79      	ldr	r2, [pc, #484]	; (1a100 <SystemInit+0x210>)
   19f1a:	681b      	ldr	r3, [r3, #0]
   19f1c:	f3c3 3342 	ubfx	r3, r3, #13, #3
   19f20:	6013      	str	r3, [r2, #0]
    }

    /* Workaround for Errata 32 "DIF: Debug session automatically enables TracePort pins" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp */
    if (errata_32()){
   19f22:	f7ff ffcf 	bl	19ec4 <errata_16>
   19f26:	b120      	cbz	r0, 19f32 <SystemInit+0x42>
        CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk;
   19f28:	4a76      	ldr	r2, [pc, #472]	; (1a104 <SystemInit+0x214>)
   19f2a:	68d3      	ldr	r3, [r2, #12]
   19f2c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   19f30:	60d3      	str	r3, [r2, #12]
    }

    /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_36()){
   19f32:	f7ff ffb9 	bl	19ea8 <errata_108>
   19f36:	b140      	cbz	r0, 19f4a <SystemInit+0x5a>
        NRF_CLOCK->EVENTS_DONE = 0;
   19f38:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   19f3c:	2200      	movs	r2, #0
   19f3e:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
        NRF_CLOCK->EVENTS_CTTO = 0;
   19f42:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
        NRF_CLOCK->CTIV = 0;
   19f46:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    }

    /* Workaround for Errata 37 "RADIO: Encryption engine is slow by default" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_37()){
   19f4a:	f7ff ffbb 	bl	19ec4 <errata_16>
   19f4e:	b110      	cbz	r0, 19f56 <SystemInit+0x66>
        *(volatile uint32_t *)0x400005A0 = 0x3;
   19f50:	4b6d      	ldr	r3, [pc, #436]	; (1a108 <SystemInit+0x218>)
   19f52:	2203      	movs	r2, #3
   19f54:	601a      	str	r2, [r3, #0]
    }

    /* Workaround for Errata 57 "NFCT: NFC Modulation amplitude" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_57()){
   19f56:	f7ff ffb5 	bl	19ec4 <errata_16>
   19f5a:	b140      	cbz	r0, 19f6e <SystemInit+0x7e>
        *(volatile uint32_t *)0x40005610 = 0x00000005;
   19f5c:	4b6b      	ldr	r3, [pc, #428]	; (1a10c <SystemInit+0x21c>)
   19f5e:	2205      	movs	r2, #5
   19f60:	601a      	str	r2, [r3, #0]
        *(volatile uint32_t *)0x40005688 = 0x00000001;
   19f62:	2201      	movs	r2, #1
   19f64:	679a      	str	r2, [r3, #120]	; 0x78
        *(volatile uint32_t *)0x40005618 = 0x00000000;
   19f66:	2200      	movs	r2, #0
   19f68:	609a      	str	r2, [r3, #8]
        *(volatile uint32_t *)0x40005614 = 0x0000003F;
   19f6a:	223f      	movs	r2, #63	; 0x3f
   19f6c:	605a      	str	r2, [r3, #4]
static bool errata_66(void)
{
    uint32_t var1;
    uint32_t var2;

    if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
   19f6e:	4b68      	ldr	r3, [pc, #416]	; (1a110 <SystemInit+0x220>)
   19f70:	681a      	ldr	r2, [r3, #0]
   19f72:	1c51      	adds	r1, r2, #1
    {
        var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   19f74:	bf0b      	itete	eq
   19f76:	4b67      	ldreq	r3, [pc, #412]	; (1a114 <SystemInit+0x224>)
        var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    }
    else
    {
        var1 = *(uint32_t *)0x10000130ul;
        var2 = *(uint32_t *)0x10000134ul;
   19f78:	4b67      	ldrne	r3, [pc, #412]	; (1a118 <SystemInit+0x228>)
        var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   19f7a:	781a      	ldrbeq	r2, [r3, #0]
        var2 = *(uint32_t *)0x10000134ul;
   19f7c:	681b      	ldrne	r3, [r3, #0]
        var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   19f7e:	bf02      	ittt	eq
   19f80:	3308      	addeq	r3, #8
   19f82:	681b      	ldreq	r3, [r3, #0]
   19f84:	f3c3 1303 	ubfxeq	r3, r3, #4, #4
    }

    switch(var1)
   19f88:	2a06      	cmp	r2, #6
   19f8a:	d14d      	bne.n	1a028 <SystemInit+0x138>
    {
        case 0x06:
            switch(var2)
   19f8c:	3b03      	subs	r3, #3
   19f8e:	2b03      	cmp	r3, #3
   19f90:	d803      	bhi.n	19f9a <SystemInit+0xaa>
    }

    /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_66()){
   19f92:	4a62      	ldr	r2, [pc, #392]	; (1a11c <SystemInit+0x22c>)
   19f94:	5cd3      	ldrb	r3, [r2, r3]
   19f96:	2b00      	cmp	r3, #0
   19f98:	d046      	beq.n	1a028 <SystemInit+0x138>
        NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
   19f9a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   19f9e:	4b60      	ldr	r3, [pc, #384]	; (1a120 <SystemInit+0x230>)
   19fa0:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
   19fa4:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
        NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
   19fa8:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
   19fac:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
        NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
   19fb0:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
   19fb4:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
        NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
   19fb8:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
   19fbc:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
        NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
   19fc0:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
   19fc4:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
        NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
   19fc8:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
   19fcc:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
        NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
   19fd0:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
   19fd4:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
        NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
   19fd8:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
   19fdc:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
        NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
   19fe0:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
   19fe4:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
        NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
   19fe8:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
   19fec:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
        NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
   19ff0:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
   19ff4:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
        NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
   19ff8:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
   19ffc:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
        NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
   1a000:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
   1a004:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
        NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
   1a008:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
   1a00c:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
        NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
   1a010:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
   1a014:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
        NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
   1a018:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
   1a01c:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
        NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
   1a020:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
   1a024:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    }

    /* Workaround for Errata 108 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_108()){
   1a028:	f7ff ff3e 	bl	19ea8 <errata_108>
   1a02c:	b128      	cbz	r0, 1a03a <SystemInit+0x14a>
        *(volatile uint32_t *)0x40000EE4ul = *(volatile uint32_t *)0x10000258ul & 0x0000004Ful;
   1a02e:	4b3d      	ldr	r3, [pc, #244]	; (1a124 <SystemInit+0x234>)
   1a030:	4a3d      	ldr	r2, [pc, #244]	; (1a128 <SystemInit+0x238>)
   1a032:	681b      	ldr	r3, [r3, #0]
   1a034:	f003 034f 	and.w	r3, r3, #79	; 0x4f
   1a038:	6013      	str	r3, [r2, #0]
    }
    
    /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_136()){
   1a03a:	f7ff ff35 	bl	19ea8 <errata_108>
   1a03e:	b148      	cbz	r0, 1a054 <SystemInit+0x164>
        if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
   1a040:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1a044:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
   1a048:	07d2      	lsls	r2, r2, #31
            NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
   1a04a:	bf44      	itt	mi
   1a04c:	f06f 0201 	mvnmi.w	r2, #1
   1a050:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400
    return false;
}

static bool errata_182(void)
{
    uint32_t var1 = *(uint32_t *)0x10000130ul;
   1a054:	4b2e      	ldr	r3, [pc, #184]	; (1a110 <SystemInit+0x220>)
    uint32_t var2 = *(uint32_t *)0x10000134ul;

    switch(var1)
   1a056:	681b      	ldr	r3, [r3, #0]
   1a058:	2b06      	cmp	r3, #6
   1a05a:	d109      	bne.n	1a070 <SystemInit+0x180>
    uint32_t var2 = *(uint32_t *)0x10000134ul;
   1a05c:	4b2e      	ldr	r3, [pc, #184]	; (1a118 <SystemInit+0x228>)
    {
        case 0x06:
            switch(var2)
   1a05e:	681b      	ldr	r3, [r3, #0]
   1a060:	3b03      	subs	r3, #3
   1a062:	2b02      	cmp	r3, #2
    }
    
    /* Workaround for Errata 182 "RADIO: Fixes for anomalies #102, #106, and #107 do not take effect" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_182()){
        *(volatile uint32_t *) 0x4000173C |= (0x1 << 10);
   1a064:	bf81      	itttt	hi
   1a066:	4a31      	ldrhi	r2, [pc, #196]	; (1a12c <SystemInit+0x23c>)
   1a068:	6813      	ldrhi	r3, [r2, #0]
   1a06a:	f443 6380 	orrhi.w	r3, r3, #1024	; 0x400
   1a06e:	6013      	strhi	r3, [r2, #0]

    /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
      defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
      reserved for PinReset and not available as normal GPIO. */
    #if defined (CONFIG_GPIO_AS_PINRESET)
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
   1a070:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   1a074:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   1a078:	2a00      	cmp	r2, #0
   1a07a:	db03      	blt.n	1a084 <SystemInit+0x194>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
   1a07c:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
   1a080:	2b00      	cmp	r3, #0
   1a082:	da2f      	bge.n	1a0e4 <SystemInit+0x1f4>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
   1a084:	4b2a      	ldr	r3, [pc, #168]	; (1a130 <SystemInit+0x240>)
   1a086:	2201      	movs	r2, #1
   1a088:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   1a08c:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
   1a090:	2a00      	cmp	r2, #0
   1a092:	d0fb      	beq.n	1a08c <SystemInit+0x19c>
            NRF_UICR->PSELRESET[0] = 21;
   1a094:	f04f 2210 	mov.w	r2, #268439552	; 0x10001000
   1a098:	2115      	movs	r1, #21
   1a09a:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   1a09e:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
   1a0a2:	2a00      	cmp	r2, #0
   1a0a4:	d0fb      	beq.n	1a09e <SystemInit+0x1ae>
            NRF_UICR->PSELRESET[1] = 21;
   1a0a6:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   1a0aa:	2215      	movs	r2, #21
   1a0ac:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   1a0b0:	4b1f      	ldr	r3, [pc, #124]	; (1a130 <SystemInit+0x240>)
   1a0b2:	461a      	mov	r2, r3
   1a0b4:	f8d3 1400 	ldr.w	r1, [r3, #1024]	; 0x400
   1a0b8:	2900      	cmp	r1, #0
   1a0ba:	d0fb      	beq.n	1a0b4 <SystemInit+0x1c4>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
   1a0bc:	2100      	movs	r1, #0
   1a0be:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   1a0c2:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
   1a0c6:	2b00      	cmp	r3, #0
   1a0c8:	d0fb      	beq.n	1a0c2 <SystemInit+0x1d2>
  __ASM volatile ("dsb 0xF":::"memory");
   1a0ca:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   1a0ce:	4919      	ldr	r1, [pc, #100]	; (1a134 <SystemInit+0x244>)
   1a0d0:	4b19      	ldr	r3, [pc, #100]	; (1a138 <SystemInit+0x248>)
   1a0d2:	68ca      	ldr	r2, [r1, #12]
   1a0d4:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   1a0d8:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   1a0da:	60cb      	str	r3, [r1, #12]
   1a0dc:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   1a0e0:	bf00      	nop
   1a0e2:	e7fd      	b.n	1a0e0 <SystemInit+0x1f0>
    SystemCoreClock = __SYSTEM_CLOCK_64M;
   1a0e4:	4b15      	ldr	r3, [pc, #84]	; (1a13c <SystemInit+0x24c>)
   1a0e6:	4a16      	ldr	r2, [pc, #88]	; (1a140 <SystemInit+0x250>)
   1a0e8:	601a      	str	r2, [r3, #0]
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
}
   1a0ea:	bd08      	pop	{r3, pc}
   1a0ec:	10000324 	.word	0x10000324
   1a0f0:	40013540 	.word	0x40013540
   1a0f4:	4007c074 	.word	0x4007c074
   1a0f8:	baadf00d 	.word	0xbaadf00d
   1a0fc:	10000244 	.word	0x10000244
   1a100:	4000053c 	.word	0x4000053c
   1a104:	e000edf0 	.word	0xe000edf0
   1a108:	400005a0 	.word	0x400005a0
   1a10c:	40005610 	.word	0x40005610
   1a110:	10000130 	.word	0x10000130
   1a114:	f0000fe0 	.word	0xf0000fe0
   1a118:	10000134 	.word	0x10000134
   1a11c:	00064fd6 	.word	0x00064fd6
   1a120:	4000c000 	.word	0x4000c000
   1a124:	10000258 	.word	0x10000258
   1a128:	40000ee4 	.word	0x40000ee4
   1a12c:	4000173c 	.word	0x4000173c
   1a130:	4001e000 	.word	0x4001e000
   1a134:	e000ed00 	.word	0xe000ed00
   1a138:	05fa0004 	.word	0x05fa0004
   1a13c:	2000ebc0 	.word	0x2000ebc0
   1a140:	03d09000 	.word	0x03d09000

0001a144 <nvmc_word_write>:
   1a144:	4a04      	ldr	r2, [pc, #16]	; (1a158 <nvmc_word_write+0x14>)
   1a146:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
{
#if defined(NRF9160_XXAA)
    while (!nrf_nvmc_write_ready_check(NRF_NVMC))
    {}
#else
    while (!nrf_nvmc_ready_check(NRF_NVMC))
   1a14a:	07db      	lsls	r3, r3, #31
   1a14c:	d5fb      	bpl.n	1a146 <nvmc_word_write+0x2>
    {}
#endif

    *(volatile uint32_t *)addr = value;
   1a14e:	6001      	str	r1, [r0, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   1a150:	f3bf 8f5f 	dmb	sy
    __DMB();
}
   1a154:	4770      	bx	lr
   1a156:	bf00      	nop
   1a158:	4001e000 	.word	0x4001e000

0001a15c <partial_word_create>:
{
   1a15c:	b507      	push	{r0, r1, r2, lr}
    byte_shift = addr % NVMC_BYTES_IN_WORD;
   1a15e:	f000 0003 	and.w	r0, r0, #3
    NRFX_ASSERT(bytes_count <= (NVMC_BYTES_IN_WORD - byte_shift));
   1a162:	f1c0 0304 	rsb	r3, r0, #4
   1a166:	4293      	cmp	r3, r2
   1a168:	d205      	bcs.n	1a176 <partial_word_create+0x1a>
   1a16a:	4b0b      	ldr	r3, [pc, #44]	; (1a198 <partial_word_create+0x3c>)
   1a16c:	4a0b      	ldr	r2, [pc, #44]	; (1a19c <partial_word_create+0x40>)
   1a16e:	480c      	ldr	r0, [pc, #48]	; (1a1a0 <partial_word_create+0x44>)
   1a170:	2197      	movs	r1, #151	; 0x97
   1a172:	f7e6 f81f 	bl	1b4 <__assert_func>
    value32 = 0xFFFFFFFF;
   1a176:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1a17a:	9301      	str	r3, [sp, #4]
    for (uint32_t i = 0; i < bytes_count; i++)
   1a17c:	ab01      	add	r3, sp, #4
   1a17e:	4418      	add	r0, r3
   1a180:	440a      	add	r2, r1
   1a182:	4291      	cmp	r1, r2
   1a184:	d103      	bne.n	1a18e <partial_word_create+0x32>
}
   1a186:	9801      	ldr	r0, [sp, #4]
   1a188:	b003      	add	sp, #12
   1a18a:	f85d fb04 	ldr.w	pc, [sp], #4
        ((uint8_t *)&value32)[byte_shift] = bytes[i];
   1a18e:	f811 3b01 	ldrb.w	r3, [r1], #1
   1a192:	f800 3b01 	strb.w	r3, [r0], #1
        byte_shift++;
   1a196:	e7f4      	b.n	1a182 <partial_word_create+0x26>
   1a198:	00065075 	.word	0x00065075
   1a19c:	00064fda 	.word	0x00064fda
   1a1a0:	00065095 	.word	0x00065095

0001a1a4 <nrfx_nvmc_page_erase>:
        nvmc_word_write(addr + (NVMC_BYTES_IN_WORD * i), ((uint32_t const *)src)[i]);
    }
}

nrfx_err_t nrfx_nvmc_page_erase(uint32_t addr)
{
   1a1a4:	b508      	push	{r3, lr}
   1a1a6:	4602      	mov	r2, r0
    NRFX_ASSERT(addr < flash_total_size_get());
   1a1a8:	f00b f89d 	bl	252e6 <flash_total_size_get>
   1a1ac:	4290      	cmp	r0, r2
   1a1ae:	d805      	bhi.n	1a1bc <nrfx_nvmc_page_erase+0x18>
   1a1b0:	4b0f      	ldr	r3, [pc, #60]	; (1a1f0 <nrfx_nvmc_page_erase+0x4c>)
   1a1b2:	4a10      	ldr	r2, [pc, #64]	; (1a1f4 <nrfx_nvmc_page_erase+0x50>)
   1a1b4:	4810      	ldr	r0, [pc, #64]	; (1a1f8 <nrfx_nvmc_page_erase+0x54>)
   1a1b6:	21d6      	movs	r1, #214	; 0xd6
   1a1b8:	f7e5 fffc 	bl	1b4 <__assert_func>
NRF_STATIC_INLINE uint32_t nrf_ficr_codepagesize_get(NRF_FICR_Type const * p_reg)
{
#if defined(FICR_INFO_CODEPAGESIZE_CODEPAGESIZE_Msk)
    return p_reg->INFO.CODEPAGESIZE;
#else
    return p_reg->CODEPAGESIZE;
   1a1bc:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   1a1c0:	6919      	ldr	r1, [r3, #16]
    return !(addr % flash_page_size_get());
   1a1c2:	fbb2 f3f1 	udiv	r3, r2, r1
   1a1c6:	fb01 2313 	mls	r3, r1, r3, r2

    if (!is_page_aligned_check(addr))
   1a1ca:	b973      	cbnz	r3, 1a1ea <nrfx_nvmc_page_erase+0x46>
#endif

NRF_STATIC_INLINE void nrf_nvmc_mode_set(NRF_NVMC_Type * p_reg,
                                         nrf_nvmc_mode_t mode)
{
    p_reg->CONFIG = (uint32_t)mode;
   1a1cc:	4b0b      	ldr	r3, [pc, #44]	; (1a1fc <nrfx_nvmc_page_erase+0x58>)
   1a1ce:	2102      	movs	r1, #2
   1a1d0:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
    else
    {
        p_reg->ERASEPCR1 = page_addr;
    }
#elif defined(NRF52_SERIES)
    p_reg->ERASEPAGE = page_addr;
   1a1d4:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   1a1d8:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
        return NRFX_ERROR_INVALID_ADDR;
    }

    nvmc_erase_mode_set();
    nrf_nvmc_page_erase_start(NRF_NVMC, addr);
    while (!nrf_nvmc_ready_check(NRF_NVMC))
   1a1dc:	07d2      	lsls	r2, r2, #31
   1a1de:	d5fb      	bpl.n	1a1d8 <nrfx_nvmc_page_erase+0x34>
    p_reg->CONFIG = (uint32_t)mode;
   1a1e0:	2200      	movs	r2, #0
    {}
    nvmc_readonly_mode_set();

    return NRFX_SUCCESS;
   1a1e2:	4807      	ldr	r0, [pc, #28]	; (1a200 <nrfx_nvmc_page_erase+0x5c>)
   1a1e4:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
   1a1e8:	bd08      	pop	{r3, pc}
        return NRFX_ERROR_INVALID_ADDR;
   1a1ea:	4806      	ldr	r0, [pc, #24]	; (1a204 <nrfx_nvmc_page_erase+0x60>)
   1a1ec:	e7fc      	b.n	1a1e8 <nrfx_nvmc_page_erase+0x44>
   1a1ee:	bf00      	nop
   1a1f0:	0006502e 	.word	0x0006502e
   1a1f4:	00064fee 	.word	0x00064fee
   1a1f8:	00065095 	.word	0x00065095
   1a1fc:	4001e000 	.word	0x4001e000
   1a200:	0bad0000 	.word	0x0bad0000
   1a204:	0bad000a 	.word	0x0bad000a

0001a208 <nrfx_nvmc_word_write>:

    nrfx_nvmc_word_write(aligned_addr, partial_word_create(addr, &value, 1));
}

void nrfx_nvmc_word_write(uint32_t addr, uint32_t value)
{
   1a208:	b538      	push	{r3, r4, r5, lr}
   1a20a:	4602      	mov	r2, r0
    NRFX_ASSERT(addr < flash_total_size_get());
   1a20c:	f00b f86b 	bl	252e6 <flash_total_size_get>
   1a210:	4290      	cmp	r0, r2
   1a212:	d806      	bhi.n	1a222 <nrfx_nvmc_word_write+0x1a>
   1a214:	4b0c      	ldr	r3, [pc, #48]	; (1a248 <nrfx_nvmc_word_write+0x40>)
   1a216:	4a0d      	ldr	r2, [pc, #52]	; (1a24c <nrfx_nvmc_word_write+0x44>)
   1a218:	f44f 71a3 	mov.w	r1, #326	; 0x146
    NRFX_ASSERT(nrfx_is_word_aligned((void const *)addr));
   1a21c:	480c      	ldr	r0, [pc, #48]	; (1a250 <nrfx_nvmc_word_write+0x48>)
   1a21e:	f7e5 ffc9 	bl	1b4 <__assert_func>
   1a222:	f012 0503 	ands.w	r5, r2, #3
   1a226:	d004      	beq.n	1a232 <nrfx_nvmc_word_write+0x2a>
   1a228:	4b0a      	ldr	r3, [pc, #40]	; (1a254 <nrfx_nvmc_word_write+0x4c>)
   1a22a:	4a08      	ldr	r2, [pc, #32]	; (1a24c <nrfx_nvmc_word_write+0x44>)
   1a22c:	f240 1147 	movw	r1, #327	; 0x147
   1a230:	e7f4      	b.n	1a21c <nrfx_nvmc_word_write+0x14>
   1a232:	4c09      	ldr	r4, [pc, #36]	; (1a258 <nrfx_nvmc_word_write+0x50>)
   1a234:	2301      	movs	r3, #1
   1a236:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504

    nvmc_write_mode_set();

    nvmc_word_write(addr, value);
   1a23a:	4610      	mov	r0, r2
   1a23c:	f7ff ff82 	bl	1a144 <nvmc_word_write>
   1a240:	f8c4 5504 	str.w	r5, [r4, #1284]	; 0x504

    nvmc_readonly_mode_set();
}
   1a244:	bd38      	pop	{r3, r4, r5, pc}
   1a246:	bf00      	nop
   1a248:	0006502e 	.word	0x0006502e
   1a24c:	00065003 	.word	0x00065003
   1a250:	00065095 	.word	0x00065095
   1a254:	0006504c 	.word	0x0006504c
   1a258:	4001e000 	.word	0x4001e000

0001a25c <nrfx_nvmc_bytes_write>:

void nrfx_nvmc_bytes_write(uint32_t addr, void const * src, uint32_t num_bytes)
{
   1a25c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1a260:	4604      	mov	r4, r0
   1a262:	460e      	mov	r6, r1
   1a264:	4615      	mov	r5, r2
    NRFX_ASSERT(addr < flash_total_size_get());
   1a266:	f00b f83e 	bl	252e6 <flash_total_size_get>
   1a26a:	42a0      	cmp	r0, r4
   1a26c:	d806      	bhi.n	1a27c <nrfx_nvmc_bytes_write+0x20>
   1a26e:	4b21      	ldr	r3, [pc, #132]	; (1a2f4 <nrfx_nvmc_bytes_write+0x98>)
   1a270:	4a21      	ldr	r2, [pc, #132]	; (1a2f8 <nrfx_nvmc_bytes_write+0x9c>)
   1a272:	4822      	ldr	r0, [pc, #136]	; (1a2fc <nrfx_nvmc_bytes_write+0xa0>)
   1a274:	f44f 71a9 	mov.w	r1, #338	; 0x152
   1a278:	f7e5 ff9c 	bl	1b4 <__assert_func>
   1a27c:	4b20      	ldr	r3, [pc, #128]	; (1a300 <nrfx_nvmc_bytes_write+0xa4>)
   1a27e:	2201      	movs	r2, #1
    nvmc_write_mode_set();

    uint8_t const * bytes_src = (uint8_t const *)src;

    uint32_t unaligned_bytes = addr % NVMC_BYTES_IN_WORD;
    if (unaligned_bytes != 0)
   1a280:	f014 0003 	ands.w	r0, r4, #3
   1a284:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
   1a288:	d011      	beq.n	1a2ae <nrfx_nvmc_bytes_write+0x52>
    {
        uint32_t leading_bytes = NVMC_BYTES_IN_WORD - unaligned_bytes;
   1a28a:	f1c0 0704 	rsb	r7, r0, #4
        if (leading_bytes > num_bytes)
   1a28e:	42af      	cmp	r7, r5
   1a290:	bf28      	it	cs
   1a292:	462f      	movcs	r7, r5
        {
            leading_bytes = num_bytes;
        }

        nvmc_word_write(addr - unaligned_bytes,
   1a294:	eba4 0800 	sub.w	r8, r4, r0
   1a298:	463a      	mov	r2, r7
   1a29a:	4620      	mov	r0, r4
   1a29c:	f7ff ff5e 	bl	1a15c <partial_word_create>
   1a2a0:	4601      	mov	r1, r0
   1a2a2:	4640      	mov	r0, r8
   1a2a4:	f7ff ff4e 	bl	1a144 <nvmc_word_write>
                        partial_word_create(addr, bytes_src, leading_bytes));
        num_bytes -= leading_bytes;
   1a2a8:	1bed      	subs	r5, r5, r7
        addr      += leading_bytes;
   1a2aa:	443c      	add	r4, r7
        bytes_src += leading_bytes;
   1a2ac:	443e      	add	r6, r7
    for (uint32_t i = 0; i < num_words; i++)
   1a2ae:	f025 0803 	bic.w	r8, r5, #3
   1a2b2:	44b0      	add	r8, r6
        }
    }
    else
#endif
    {
        uint32_t word_count = num_bytes / NVMC_BYTES_IN_WORD;
   1a2b4:	4637      	mov	r7, r6
   1a2b6:	eba4 0906 	sub.w	r9, r4, r6
    for (uint32_t i = 0; i < num_words; i++)
   1a2ba:	45b8      	cmp	r8, r7
   1a2bc:	d113      	bne.n	1a2e6 <nrfx_nvmc_bytes_write+0x8a>
        addr += word_count * NVMC_BYTES_IN_WORD;
        bytes_src += word_count * NVMC_BYTES_IN_WORD;
    }

    uint32_t trailing_bytes = num_bytes % NVMC_BYTES_IN_WORD;
    if (trailing_bytes != 0)
   1a2be:	f015 0203 	ands.w	r2, r5, #3
   1a2c2:	d00a      	beq.n	1a2da <nrfx_nvmc_bytes_write+0x7e>
        addr += word_count * NVMC_BYTES_IN_WORD;
   1a2c4:	f025 0103 	bic.w	r1, r5, #3
   1a2c8:	440c      	add	r4, r1
    {
        nvmc_word_write(addr, partial_word_create(addr, bytes_src, trailing_bytes));
   1a2ca:	4620      	mov	r0, r4
   1a2cc:	4431      	add	r1, r6
   1a2ce:	f7ff ff45 	bl	1a15c <partial_word_create>
   1a2d2:	4601      	mov	r1, r0
   1a2d4:	4620      	mov	r0, r4
   1a2d6:	f7ff ff35 	bl	1a144 <nvmc_word_write>
   1a2da:	4b09      	ldr	r3, [pc, #36]	; (1a300 <nrfx_nvmc_bytes_write+0xa4>)
   1a2dc:	2200      	movs	r2, #0
   1a2de:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    }

    nvmc_readonly_mode_set();
}
   1a2e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        nvmc_word_write(addr + (NVMC_BYTES_IN_WORD * i), ((uint32_t const *)src)[i]);
   1a2e6:	eb09 0007 	add.w	r0, r9, r7
   1a2ea:	f857 1b04 	ldr.w	r1, [r7], #4
   1a2ee:	f7ff ff29 	bl	1a144 <nvmc_word_write>
   1a2f2:	e7e2      	b.n	1a2ba <nrfx_nvmc_bytes_write+0x5e>
   1a2f4:	0006502e 	.word	0x0006502e
   1a2f8:	00065018 	.word	0x00065018
   1a2fc:	00065095 	.word	0x00065095
   1a300:	4001e000 	.word	0x4001e000

0001a304 <nrf_gpio_pin_port_decode.isra.0.part.1>:
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
   1a304:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   1a306:	4a03      	ldr	r2, [pc, #12]	; (1a314 <nrf_gpio_pin_port_decode.isra.0.part.1+0x10>)
   1a308:	4b03      	ldr	r3, [pc, #12]	; (1a318 <nrf_gpio_pin_port_decode.isra.0.part.1+0x14>)
   1a30a:	4804      	ldr	r0, [pc, #16]	; (1a31c <nrf_gpio_pin_port_decode.isra.0.part.1+0x18>)
   1a30c:	f44f 71ed 	mov.w	r1, #474	; 0x1da
   1a310:	f7e5 ff50 	bl	1b4 <__assert_func>
   1a314:	000650d0 	.word	0x000650d0
   1a318:	00064e17 	.word	0x00064e17
   1a31c:	00064e25 	.word	0x00064e25

0001a320 <nrfx_spi_init>:

nrfx_err_t nrfx_spi_init(nrfx_spi_t const *        p_instance,
                         nrfx_spi_config_t const * p_config,
                         nrfx_spi_evt_handler_t    handler,
                         void *                    p_context)
{
   1a320:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1a324:	4680      	mov	r8, r0
    NRFX_ASSERT(p_config);
   1a326:	460c      	mov	r4, r1
   1a328:	b929      	cbnz	r1, 1a336 <nrfx_spi_init+0x16>
   1a32a:	4b52      	ldr	r3, [pc, #328]	; (1a474 <nrfx_spi_init+0x154>)
   1a32c:	4a52      	ldr	r2, [pc, #328]	; (1a478 <nrfx_spi_init+0x158>)
   1a32e:	4853      	ldr	r0, [pc, #332]	; (1a47c <nrfx_spi_init+0x15c>)
   1a330:	214a      	movs	r1, #74	; 0x4a
   1a332:	f7e5 ff3f 	bl	1b4 <__assert_func>
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   1a336:	7907      	ldrb	r7, [r0, #4]
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   1a338:	4d51      	ldr	r5, [pc, #324]	; (1a480 <nrfx_spi_init+0x160>)
   1a33a:	212c      	movs	r1, #44	; 0x2c
   1a33c:	4379      	muls	r1, r7
   1a33e:	1868      	adds	r0, r5, r1
   1a340:	7f06      	ldrb	r6, [r0, #28]
   1a342:	2e00      	cmp	r6, #0
   1a344:	f040 8093 	bne.w	1a46e <nrfx_spi_init+0x14e>
        return err_code;
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler = handler;
    p_cb->p_context = p_context;
   1a348:	6043      	str	r3, [r0, #4]
    // Configure pins used by the peripheral:
    // - SCK - output with initial value corresponding with the SPI mode used:
    //   0 - for modes 0 and 1 (CPOL = 0), 1 - for modes 2 and 3 (CPOL = 1);
    //   according to the reference manual guidelines this pin and its input
    //   buffer must always be connected for the SPI to work.
    if (p_config->mode <= NRF_SPI_MODE_1)
   1a34a:	7b23      	ldrb	r3, [r4, #12]
    p_cb->handler = handler;
   1a34c:	506a      	str	r2, [r5, r1]
    if (p_config->mode <= NRF_SPI_MODE_1)
   1a34e:	2b01      	cmp	r3, #1
   1a350:	7820      	ldrb	r0, [r4, #0]
   1a352:	d806      	bhi.n	1a362 <nrfx_spi_init+0x42>
    {
        nrf_gpio_pin_clear(p_config->sck_pin);
   1a354:	f00b f80b 	bl	2536e <nrf_gpio_pin_clear>
    }
    else
    {
        nrf_gpio_pin_set(p_config->sck_pin);
    }
    nrf_gpio_cfg(p_config->sck_pin,
   1a358:	7823      	ldrb	r3, [r4, #0]
   1a35a:	2b1f      	cmp	r3, #31
   1a35c:	d904      	bls.n	1a368 <nrfx_spi_init+0x48>
   1a35e:	f7ff ffd1 	bl	1a304 <nrf_gpio_pin_port_decode.isra.0.part.1>
        nrf_gpio_pin_set(p_config->sck_pin);
   1a362:	f00b f810 	bl	25386 <nrf_gpio_pin_set>
   1a366:	e7f7      	b.n	1a358 <nrfx_spi_init+0x38>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1a368:	f04f 49a0 	mov.w	r9, #1342177280	; 0x50000000
   1a36c:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
   1a370:	2201      	movs	r2, #1
   1a372:	f849 2023 	str.w	r2, [r9, r3, lsl #2]
                 NRF_GPIO_PIN_INPUT_CONNECT,
                 NRF_GPIO_PIN_NOPULL,
                 NRF_GPIO_PIN_S0S1,
                 NRF_GPIO_PIN_NOSENSE);
    // - MOSI (optional) - output with initial value 0,
    if (p_config->mosi_pin != NRFX_SPI_PIN_NOT_USED)
   1a376:	7866      	ldrb	r6, [r4, #1]
   1a378:	2eff      	cmp	r6, #255	; 0xff
   1a37a:	d06c      	beq.n	1a456 <nrfx_spi_init+0x136>
    {
        mosi_pin = p_config->mosi_pin;
        nrf_gpio_pin_clear(mosi_pin);
   1a37c:	4630      	mov	r0, r6
   1a37e:	f00a fff6 	bl	2536e <nrf_gpio_pin_clear>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   1a382:	2e1f      	cmp	r6, #31
   1a384:	d8eb      	bhi.n	1a35e <nrfx_spi_init+0x3e>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1a386:	f506 73e0 	add.w	r3, r6, #448	; 0x1c0
   1a38a:	2203      	movs	r2, #3
   1a38c:	f849 2023 	str.w	r2, [r9, r3, lsl #2]
    else
    {
        mosi_pin = NRF_SPI_PIN_NOT_CONNECTED;
    }
    // - MISO (optional) - input,
    if (p_config->miso_pin != NRFX_SPI_PIN_NOT_USED)
   1a390:	78a3      	ldrb	r3, [r4, #2]
   1a392:	2bff      	cmp	r3, #255	; 0xff
   1a394:	d062      	beq.n	1a45c <nrfx_spi_init+0x13c>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   1a396:	2b1f      	cmp	r3, #31
    {
        miso_pin = p_config->miso_pin;
   1a398:	4699      	mov	r9, r3
        nrf_gpio_cfg_input(miso_pin, p_config->miso_pull);
   1a39a:	7ba1      	ldrb	r1, [r4, #14]
   1a39c:	d8df      	bhi.n	1a35e <nrfx_spi_init+0x3e>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1a39e:	f503 72e0 	add.w	r2, r3, #448	; 0x1c0
   1a3a2:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
   1a3a6:	0089      	lsls	r1, r1, #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1a3a8:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
    }
    else
    {
        miso_pin = NRF_SPI_PIN_NOT_CONNECTED;
    }
    m_cb[p_instance->drv_inst_idx].miso_pin = p_config->miso_pin;
   1a3ac:	f898 2004 	ldrb.w	r2, [r8, #4]
   1a3b0:	212c      	movs	r1, #44	; 0x2c
   1a3b2:	fb01 5202 	mla	r2, r1, r2, r5
   1a3b6:	77d3      	strb	r3, [r2, #31]
    // - Slave Select (optional) - output with initial value 1 (inactive).
    if (p_config->ss_pin != NRFX_SPI_PIN_NOT_USED)
   1a3b8:	78e0      	ldrb	r0, [r4, #3]
   1a3ba:	28ff      	cmp	r0, #255	; 0xff
   1a3bc:	d00b      	beq.n	1a3d6 <nrfx_spi_init+0xb6>
    {
        nrf_gpio_pin_set(p_config->ss_pin);
   1a3be:	f00a ffe2 	bl	25386 <nrf_gpio_pin_set>
        nrf_gpio_cfg_output(p_config->ss_pin);
   1a3c2:	78e3      	ldrb	r3, [r4, #3]
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   1a3c4:	2b1f      	cmp	r3, #31
   1a3c6:	d8ca      	bhi.n	1a35e <nrfx_spi_init+0x3e>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1a3c8:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
   1a3cc:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   1a3d0:	2103      	movs	r1, #3
   1a3d2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    }
    m_cb[p_instance->drv_inst_idx].ss_pin = p_config->ss_pin;
   1a3d6:	f898 2004 	ldrb.w	r2, [r8, #4]
   1a3da:	78e1      	ldrb	r1, [r4, #3]
   1a3dc:	232c      	movs	r3, #44	; 0x2c
   1a3de:	fb03 5302 	mla	r3, r3, r2, r5
   1a3e2:	7799      	strb	r1, [r3, #30]

    NRF_SPI_Type * p_spi = p_instance->p_reg;
   1a3e4:	f8d8 0000 	ldr.w	r0, [r8]
    nrf_spi_pins_set(p_spi, p_config->sck_pin, mosi_pin, miso_pin);
   1a3e8:	7823      	ldrb	r3, [r4, #0]
    p_reg->PSELSCK  = sck_pin;
   1a3ea:	f8c0 3508 	str.w	r3, [r0, #1288]	; 0x508
    p_reg->FREQUENCY = (uint32_t)frequency;
   1a3ee:	68a3      	ldr	r3, [r4, #8]
    p_reg->PSELMOSI = mosi_pin;
   1a3f0:	f8c0 650c 	str.w	r6, [r0, #1292]	; 0x50c
    p_reg->PSELMISO = miso_pin;
   1a3f4:	f8c0 9510 	str.w	r9, [r0, #1296]	; 0x510
    p_reg->FREQUENCY = (uint32_t)frequency;
   1a3f8:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524
        SPI_CONFIG_ORDER_MsbFirst : SPI_CONFIG_ORDER_LsbFirst);
   1a3fc:	7b63      	ldrb	r3, [r4, #13]
    nrf_spi_frequency_set(p_spi, p_config->frequency);
    nrf_spi_configure(p_spi, p_config->mode, p_config->bit_order);
   1a3fe:	7b21      	ldrb	r1, [r4, #12]
   1a400:	3300      	adds	r3, #0
   1a402:	bf18      	it	ne
   1a404:	2301      	movne	r3, #1
    switch (spi_mode)
   1a406:	2902      	cmp	r1, #2
   1a408:	d02b      	beq.n	1a462 <nrfx_spi_init+0x142>
   1a40a:	2903      	cmp	r1, #3
   1a40c:	d02c      	beq.n	1a468 <nrfx_spi_init+0x148>
   1a40e:	2901      	cmp	r1, #1
   1a410:	d101      	bne.n	1a416 <nrfx_spi_init+0xf6>
        config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
   1a412:	f043 0302 	orr.w	r3, r3, #2
    p_reg->CONFIG = config;
   1a416:	f8c0 3554 	str.w	r3, [r0, #1364]	; 0x554

    m_cb[p_instance->drv_inst_idx].orc = p_config->orc;
   1a41a:	232c      	movs	r3, #44	; 0x2c
   1a41c:	fb03 5202 	mla	r2, r3, r2, r5

    if (p_cb->handler)
   1a420:	437b      	muls	r3, r7
    m_cb[p_instance->drv_inst_idx].orc = p_config->orc;
   1a422:	7961      	ldrb	r1, [r4, #5]
    if (p_cb->handler)
   1a424:	58eb      	ldr	r3, [r5, r3]
    m_cb[p_instance->drv_inst_idx].orc = p_config->orc;
   1a426:	f882 1020 	strb.w	r1, [r2, #32]
    if (p_cb->handler)
   1a42a:	b113      	cbz	r3, 1a432 <nrfx_spi_init+0x112>
    p_reg->INTENSET = mask;
   1a42c:	2204      	movs	r2, #4
   1a42e:	f8c0 2304 	str.w	r2, [r0, #772]	; 0x304
    p_reg->ENABLE = (SPI_ENABLE_ENABLE_Enabled << SPI_ENABLE_ENABLE_Pos);
   1a432:	2201      	movs	r2, #1
   1a434:	f8c0 2500 	str.w	r2, [r0, #1280]	; 0x500
        nrf_spi_int_enable(p_spi, NRF_SPI_INT_READY_MASK);
    }

    nrf_spi_enable(p_spi);

    if (p_cb->handler)
   1a438:	b11b      	cbz	r3, 1a442 <nrfx_spi_init+0x122>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_reg),
            p_config->irq_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
   1a43a:	f340 3007 	sbfx	r0, r0, #12, #8
   1a43e:	f7ec fb5f 	bl	6b00 <arch_irq_enable>
    }

    p_cb->transfer_in_progress = false;
   1a442:	232c      	movs	r3, #44	; 0x2c
   1a444:	fb03 5507 	mla	r5, r3, r7, r5
   1a448:	2300      	movs	r3, #0
   1a44a:	776b      	strb	r3, [r5, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   1a44c:	480d      	ldr	r0, [pc, #52]	; (1a484 <nrfx_spi_init+0x164>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   1a44e:	2301      	movs	r3, #1
   1a450:	772b      	strb	r3, [r5, #28]
}
   1a452:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        mosi_pin = NRF_SPI_PIN_NOT_CONNECTED;
   1a456:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   1a45a:	e799      	b.n	1a390 <nrfx_spi_init+0x70>
        miso_pin = NRF_SPI_PIN_NOT_CONNECTED;
   1a45c:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
   1a460:	e7a4      	b.n	1a3ac <nrfx_spi_init+0x8c>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
   1a462:	f043 0304 	orr.w	r3, r3, #4
        break;
   1a466:	e7d6      	b.n	1a416 <nrfx_spi_init+0xf6>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
   1a468:	f043 0306 	orr.w	r3, r3, #6
        break;
   1a46c:	e7d3      	b.n	1a416 <nrfx_spi_init+0xf6>
        return err_code;
   1a46e:	4806      	ldr	r0, [pc, #24]	; (1a488 <nrfx_spi_init+0x168>)
   1a470:	e7ef      	b.n	1a452 <nrfx_spi_init+0x132>
   1a472:	bf00      	nop
   1a474:	0006511f 	.word	0x0006511f
   1a478:	000650e9 	.word	0x000650e9
   1a47c:	00065128 	.word	0x00065128
   1a480:	20001a28 	.word	0x20001a28
   1a484:	0bad0000 	.word	0x0bad0000
   1a488:	0bad0005 	.word	0x0bad0005

0001a48c <nrfx_spi_xfer>:
}

nrfx_err_t nrfx_spi_xfer(nrfx_spi_t const *           p_instance,
                         nrfx_spi_xfer_desc_t const * p_xfer_desc,
                         uint32_t                     flags)
{
   1a48c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   1a490:	4c4c      	ldr	r4, [pc, #304]	; (1a5c4 <nrfx_spi_xfer+0x138>)
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   1a492:	7906      	ldrb	r6, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   1a494:	232c      	movs	r3, #44	; 0x2c
   1a496:	fb03 4306 	mla	r3, r3, r6, r4
{
   1a49a:	4681      	mov	r9, r0
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   1a49c:	7f1b      	ldrb	r3, [r3, #28]
{
   1a49e:	460d      	mov	r5, r1
   1a4a0:	4690      	mov	r8, r2
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   1a4a2:	b933      	cbnz	r3, 1a4b2 <nrfx_spi_xfer+0x26>
   1a4a4:	4b48      	ldr	r3, [pc, #288]	; (1a5c8 <nrfx_spi_xfer+0x13c>)
   1a4a6:	4a49      	ldr	r2, [pc, #292]	; (1a5cc <nrfx_spi_xfer+0x140>)
   1a4a8:	f240 115b 	movw	r1, #347	; 0x15b
    NRFX_ASSERT(p_xfer_desc->p_tx_buffer != NULL || p_xfer_desc->tx_length == 0);
   1a4ac:	4848      	ldr	r0, [pc, #288]	; (1a5d0 <nrfx_spi_xfer+0x144>)
   1a4ae:	f7e5 fe81 	bl	1b4 <__assert_func>
   1a4b2:	680b      	ldr	r3, [r1, #0]
   1a4b4:	b933      	cbnz	r3, 1a4c4 <nrfx_spi_xfer+0x38>
   1a4b6:	684b      	ldr	r3, [r1, #4]
   1a4b8:	b123      	cbz	r3, 1a4c4 <nrfx_spi_xfer+0x38>
   1a4ba:	4b46      	ldr	r3, [pc, #280]	; (1a5d4 <nrfx_spi_xfer+0x148>)
   1a4bc:	4a43      	ldr	r2, [pc, #268]	; (1a5cc <nrfx_spi_xfer+0x140>)
   1a4be:	f44f 71ae 	mov.w	r1, #348	; 0x15c
   1a4c2:	e7f3      	b.n	1a4ac <nrfx_spi_xfer+0x20>
    NRFX_ASSERT(p_xfer_desc->p_rx_buffer != NULL || p_xfer_desc->rx_length == 0);
   1a4c4:	68ab      	ldr	r3, [r5, #8]
   1a4c6:	b933      	cbnz	r3, 1a4d6 <nrfx_spi_xfer+0x4a>
   1a4c8:	68eb      	ldr	r3, [r5, #12]
   1a4ca:	b123      	cbz	r3, 1a4d6 <nrfx_spi_xfer+0x4a>
   1a4cc:	4b42      	ldr	r3, [pc, #264]	; (1a5d8 <nrfx_spi_xfer+0x14c>)
   1a4ce:	4a3f      	ldr	r2, [pc, #252]	; (1a5cc <nrfx_spi_xfer+0x140>)
   1a4d0:	f240 115d 	movw	r1, #349	; 0x15d
   1a4d4:	e7ea      	b.n	1a4ac <nrfx_spi_xfer+0x20>

    nrfx_err_t err_code = NRFX_SUCCESS;

    if (p_cb->transfer_in_progress)
   1a4d6:	232c      	movs	r3, #44	; 0x2c
   1a4d8:	4373      	muls	r3, r6
   1a4da:	18e2      	adds	r2, r4, r3
   1a4dc:	7f51      	ldrb	r1, [r2, #29]
   1a4de:	2900      	cmp	r1, #0
   1a4e0:	d16d      	bne.n	1a5be <nrfx_spi_xfer+0x132>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    else
    {
        if (p_cb->handler)
   1a4e2:	58e3      	ldr	r3, [r4, r3]
   1a4e4:	b10b      	cbz	r3, 1a4ea <nrfx_spi_xfer+0x5e>
        {
            p_cb->transfer_in_progress = true;
   1a4e6:	2301      	movs	r3, #1
   1a4e8:	7753      	strb	r3, [r2, #29]
        }
    }

    p_cb->evt.xfer_desc = *p_xfer_desc;
   1a4ea:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   1a4ee:	272c      	movs	r7, #44	; 0x2c
   1a4f0:	fb07 4706 	mla	r7, r7, r6, r4
   1a4f4:	f107 0c0c 	add.w	ip, r7, #12
   1a4f8:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
    p_cb->abort = false;

    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
   1a4fc:	7fb8      	ldrb	r0, [r7, #30]
    p_cb->abort = false;
   1a4fe:	2300      	movs	r3, #0
    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
   1a500:	28ff      	cmp	r0, #255	; 0xff
    p_cb->abort = false;
   1a502:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
   1a506:	d001      	beq.n	1a50c <nrfx_spi_xfer+0x80>
    {
        nrf_gpio_pin_clear(p_cb->ss_pin);
   1a508:	f00a ff31 	bl	2536e <nrf_gpio_pin_clear>
    }
    if (flags)
   1a50c:	232c      	movs	r3, #44	; 0x2c
   1a50e:	f1b8 0f00 	cmp.w	r8, #0
   1a512:	d007      	beq.n	1a524 <nrfx_spi_xfer+0x98>
    {
        p_cb->transfer_in_progress = false;
   1a514:	fb03 4306 	mla	r3, r3, r6, r4
   1a518:	2200      	movs	r2, #0
        err_code = NRFX_ERROR_NOT_SUPPORTED;
   1a51a:	4830      	ldr	r0, [pc, #192]	; (1a5dc <nrfx_spi_xfer+0x150>)
        p_cb->transfer_in_progress = false;
   1a51c:	775a      	strb	r2, [r3, #29]
    }
    NRFX_LOG_INFO("Function: %s, error code: %s.",
                  __func__,
                  NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   1a51e:	b003      	add	sp, #12
   1a520:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        spi_xfer(p_instance->p_reg, p_cb, p_xfer_desc);
   1a524:	f8d9 7000 	ldr.w	r7, [r9]
    p_reg->INTENCLR = mask;
   1a528:	2204      	movs	r2, #4
   1a52a:	f8c7 2308 	str.w	r2, [r7, #776]	; 0x308
    p_cb->bytes_transferred = 0;
   1a52e:	fb03 4306 	mla	r3, r3, r6, r4
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1a532:	f8c7 8108 	str.w	r8, [r7, #264]	; 0x108
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   1a536:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
   1a53a:	f8c3 8024 	str.w	r8, [r3, #36]	; 0x24
   1a53e:	9200      	str	r2, [sp, #0]
    (void)dummy;
   1a540:	9a00      	ldr	r2, [sp, #0]
        (p_xfer_desc->tx_length > 0 ? p_xfer_desc->p_tx_buffer[0] : p_cb->orc));
   1a542:	686a      	ldr	r2, [r5, #4]
    nrf_spi_txd_set(p_spi,
   1a544:	b19a      	cbz	r2, 1a56e <nrfx_spi_xfer+0xe2>
   1a546:	682b      	ldr	r3, [r5, #0]
   1a548:	781b      	ldrb	r3, [r3, #0]
    p_reg->TXD = data;
   1a54a:	f8c7 351c 	str.w	r3, [r7, #1308]	; 0x51c
    if (p_xfer_desc->tx_length > 1)
   1a54e:	2a01      	cmp	r2, #1
   1a550:	d910      	bls.n	1a574 <nrfx_spi_xfer+0xe8>
        nrf_spi_txd_set(p_spi, p_xfer_desc->p_tx_buffer[1]);
   1a552:	682b      	ldr	r3, [r5, #0]
   1a554:	785b      	ldrb	r3, [r3, #1]
   1a556:	f8c7 351c 	str.w	r3, [r7, #1308]	; 0x51c
    if (p_cb->handler)
   1a55a:	212c      	movs	r1, #44	; 0x2c
   1a55c:	fb01 f306 	mul.w	r3, r1, r6
   1a560:	58e3      	ldr	r3, [r4, r3]
   1a562:	b183      	cbz	r3, 1a586 <nrfx_spi_xfer+0xfa>
    p_reg->INTENSET = mask;
   1a564:	2304      	movs	r3, #4
   1a566:	f8c7 3304 	str.w	r3, [r7, #772]	; 0x304
    nrfx_err_t err_code = NRFX_SUCCESS;
   1a56a:	481d      	ldr	r0, [pc, #116]	; (1a5e0 <nrfx_spi_xfer+0x154>)
   1a56c:	e7d7      	b.n	1a51e <nrfx_spi_xfer+0x92>
    nrf_spi_txd_set(p_spi,
   1a56e:	f893 3020 	ldrb.w	r3, [r3, #32]
   1a572:	e7ea      	b.n	1a54a <nrfx_spi_xfer+0xbe>
    else if (p_xfer_desc->rx_length > 1)
   1a574:	68eb      	ldr	r3, [r5, #12]
   1a576:	2b01      	cmp	r3, #1
   1a578:	d9ef      	bls.n	1a55a <nrfx_spi_xfer+0xce>
        nrf_spi_txd_set(p_spi, p_cb->orc);
   1a57a:	232c      	movs	r3, #44	; 0x2c
   1a57c:	fb03 4306 	mla	r3, r3, r6, r4
    p_reg->TXD = data;
   1a580:	f893 3020 	ldrb.w	r3, [r3, #32]
   1a584:	e7e7      	b.n	1a556 <nrfx_spi_xfer+0xca>
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   1a586:	fb06 4501 	mla	r5, r6, r1, r4
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1a58a:	4698      	mov	r8, r3
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1a58c:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
            while (!nrf_spi_event_check(p_spi, NRF_SPI_EVENT_READY)) {}
   1a590:	2b00      	cmp	r3, #0
   1a592:	d0fb      	beq.n	1a58c <nrfx_spi_xfer+0x100>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1a594:	f8c7 8108 	str.w	r8, [r7, #264]	; 0x108
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   1a598:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
   1a59c:	9301      	str	r3, [sp, #4]
        } while (transfer_byte(p_spi, p_cb));
   1a59e:	4629      	mov	r1, r5
   1a5a0:	4638      	mov	r0, r7
    (void)dummy;
   1a5a2:	9b01      	ldr	r3, [sp, #4]
   1a5a4:	f00a feaf 	bl	25306 <transfer_byte>
   1a5a8:	2800      	cmp	r0, #0
   1a5aa:	d1ef      	bne.n	1a58c <nrfx_spi_xfer+0x100>
        if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
   1a5ac:	232c      	movs	r3, #44	; 0x2c
   1a5ae:	fb03 4406 	mla	r4, r3, r6, r4
   1a5b2:	7fa0      	ldrb	r0, [r4, #30]
   1a5b4:	28ff      	cmp	r0, #255	; 0xff
   1a5b6:	d0d8      	beq.n	1a56a <nrfx_spi_xfer+0xde>
            nrf_gpio_pin_set(p_cb->ss_pin);
   1a5b8:	f00a fee5 	bl	25386 <nrf_gpio_pin_set>
   1a5bc:	e7d5      	b.n	1a56a <nrfx_spi_xfer+0xde>
        return err_code;
   1a5be:	4809      	ldr	r0, [pc, #36]	; (1a5e4 <nrfx_spi_xfer+0x158>)
   1a5c0:	e7ad      	b.n	1a51e <nrfx_spi_xfer+0x92>
   1a5c2:	bf00      	nop
   1a5c4:	20001a28 	.word	0x20001a28
   1a5c8:	00065162 	.word	0x00065162
   1a5cc:	000650f7 	.word	0x000650f7
   1a5d0:	00065128 	.word	0x00065128
   1a5d4:	0006518e 	.word	0x0006518e
   1a5d8:	000651d5 	.word	0x000651d5
   1a5dc:	0bad0003 	.word	0x0bad0003
   1a5e0:	0bad0000 	.word	0x0bad0000
   1a5e4:	0bad000b 	.word	0x0bad000b

0001a5e8 <nrfx_spi_0_irq_handler>:
    }
}

#if NRFX_CHECK(NRFX_SPI0_ENABLED)
void nrfx_spi_0_irq_handler(void)
{
   1a5e8:	b513      	push	{r0, r1, r4, lr}
    NRFX_ASSERT(p_cb->handler);
   1a5ea:	4c13      	ldr	r4, [pc, #76]	; (1a638 <nrfx_spi_0_irq_handler+0x50>)
   1a5ec:	6823      	ldr	r3, [r4, #0]
   1a5ee:	b933      	cbnz	r3, 1a5fe <nrfx_spi_0_irq_handler+0x16>
   1a5f0:	4b12      	ldr	r3, [pc, #72]	; (1a63c <nrfx_spi_0_irq_handler+0x54>)
   1a5f2:	4a13      	ldr	r2, [pc, #76]	; (1a640 <nrfx_spi_0_irq_handler+0x58>)
   1a5f4:	4813      	ldr	r0, [pc, #76]	; (1a644 <nrfx_spi_0_irq_handler+0x5c>)
   1a5f6:	f44f 71c8 	mov.w	r1, #400	; 0x190
   1a5fa:	f7e5 fddb 	bl	1b4 <__assert_func>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1a5fe:	4b12      	ldr	r3, [pc, #72]	; (1a648 <nrfx_spi_0_irq_handler+0x60>)
    if (!transfer_byte(p_spi, p_cb))
   1a600:	4812      	ldr	r0, [pc, #72]	; (1a64c <nrfx_spi_0_irq_handler+0x64>)
   1a602:	2200      	movs	r2, #0
   1a604:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   1a606:	681b      	ldr	r3, [r3, #0]
   1a608:	9301      	str	r3, [sp, #4]
   1a60a:	4621      	mov	r1, r4
    (void)dummy;
   1a60c:	9b01      	ldr	r3, [sp, #4]
   1a60e:	f00a fe7a 	bl	25306 <transfer_byte>
   1a612:	b970      	cbnz	r0, 1a632 <nrfx_spi_0_irq_handler+0x4a>
    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
   1a614:	7fa0      	ldrb	r0, [r4, #30]
   1a616:	28ff      	cmp	r0, #255	; 0xff
   1a618:	d001      	beq.n	1a61e <nrfx_spi_0_irq_handler+0x36>
        nrf_gpio_pin_set(p_cb->ss_pin);
   1a61a:	f00a feb4 	bl	25386 <nrf_gpio_pin_set>
    p_cb->transfer_in_progress = false;
   1a61e:	2300      	movs	r3, #0
   1a620:	7763      	strb	r3, [r4, #29]
    p_cb->evt.type = NRFX_SPI_EVENT_DONE;
   1a622:	7223      	strb	r3, [r4, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   1a624:	e9d4 3100 	ldrd	r3, r1, [r4]
   1a628:	4809      	ldr	r0, [pc, #36]	; (1a650 <nrfx_spi_0_irq_handler+0x68>)
    irq_handler(NRF_SPI0, &m_cb[NRFX_SPI0_INST_IDX]);
}
   1a62a:	b002      	add	sp, #8
   1a62c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   1a630:	4718      	bx	r3
}
   1a632:	b002      	add	sp, #8
   1a634:	bd10      	pop	{r4, pc}
   1a636:	bf00      	nop
   1a638:	20001a28 	.word	0x20001a28
   1a63c:	00065111 	.word	0x00065111
   1a640:	00065105 	.word	0x00065105
   1a644:	00065128 	.word	0x00065128
   1a648:	40003108 	.word	0x40003108
   1a64c:	40003000 	.word	0x40003000
   1a650:	20001a30 	.word	0x20001a30

0001a654 <twi_rx_start_transfer>:
    return ret_code;
}

static nrfx_err_t twi_rx_start_transfer(NRF_TWI_Type        * p_twi,
                                        twi_control_block_t * p_cb)
{
   1a654:	b537      	push	{r0, r1, r2, r4, r5, lr}
    nrfx_err_t ret_code = NRFX_SUCCESS;
    volatile int32_t hw_timeout;

    hw_timeout = HW_TIMEOUT;
   1a656:	4b34      	ldr	r3, [pc, #208]	; (1a728 <twi_rx_start_transfer+0xd4>)
   1a658:	9301      	str	r3, [sp, #4]
{
   1a65a:	460d      	mov	r5, r1

    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
   1a65c:	f44f 7182 	mov.w	r1, #260	; 0x104
{
   1a660:	4604      	mov	r4, r0
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
   1a662:	f00a fe9c 	bl	2539e <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
   1a666:	f44f 7192 	mov.w	r1, #292	; 0x124
   1a66a:	f00a fe98 	bl	2539e <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_TXDSENT);
   1a66e:	f44f 718e 	mov.w	r1, #284	; 0x11c
   1a672:	f00a fe94 	bl	2539e <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_RXDREADY);
   1a676:	f44f 7184 	mov.w	r1, #264	; 0x108
   1a67a:	f00a fe90 	bl	2539e <nrf_twi_event_clear>

    p_cb->bytes_transferred = 0;
   1a67e:	2300      	movs	r3, #0
   1a680:	636b      	str	r3, [r5, #52]	; 0x34
    p_cb->error             = false;
   1a682:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f

    if ((p_cb->curr_length == 1) && (!TWI_FLAG_SUSPEND(p_cb->flags)))
   1a686:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1a688:	2b01      	cmp	r3, #1
   1a68a:	d118      	bne.n	1a6be <twi_rx_start_transfer+0x6a>
   1a68c:	6a2b      	ldr	r3, [r5, #32]
   1a68e:	065b      	lsls	r3, r3, #25
   1a690:	d415      	bmi.n	1a6be <twi_rx_start_transfer+0x6a>
}

NRF_STATIC_INLINE void nrf_twi_shorts_set(NRF_TWI_Type * p_reg,
                                          uint32_t       mask)
{
    p_reg->SHORTS = mask;
   1a692:	2302      	movs	r3, #2
        nrf_twi_shorts_set(p_twi, NRF_TWI_SHORT_BB_SUSPEND_MASK);
    }
    // In case TWI is suspended resume its operation.
    nrf_twi_task_trigger(p_twi, NRF_TWI_TASK_RESUME);

    if (p_cb->prev_suspend != TWI_SUSPEND_RX)
   1a694:	f895 202d 	ldrb.w	r2, [r5, #45]	; 0x2d
   1a698:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
   1a69c:	2a02      	cmp	r2, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1a69e:	f04f 0301 	mov.w	r3, #1
   1a6a2:	6223      	str	r3, [r4, #32]
   1a6a4:	bf18      	it	ne
   1a6a6:	6023      	strne	r3, [r4, #0]
    {
        nrf_twi_task_trigger(p_twi, NRF_TWI_TASK_STARTRX);
    }

    if (p_cb->handler)
   1a6a8:	682b      	ldr	r3, [r5, #0]
   1a6aa:	b193      	cbz	r3, 1a6d2 <twi_rx_start_transfer+0x7e>
    {
        p_cb->int_mask = NRF_TWI_INT_STOPPED_MASK   |
   1a6ac:	f240 2386 	movw	r3, #646	; 0x286
   1a6b0:	60ab      	str	r3, [r5, #8]
                        NRF_TWI_INT_ERROR_MASK     |
                        NRF_TWI_INT_TXDSENT_MASK   |
                        NRF_TWI_INT_RXDREADY_MASK;
        nrf_twi_int_enable(p_twi, p_cb->int_mask);
   1a6b2:	68ab      	ldr	r3, [r5, #8]
    nrfx_err_t ret_code = NRFX_SUCCESS;
   1a6b4:	481d      	ldr	r0, [pc, #116]	; (1a72c <twi_rx_start_transfer+0xd8>)
    p_reg->INTENSET = mask;
   1a6b6:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
            nrf_twi_enable(p_twi);
            ret_code = NRFX_ERROR_INTERNAL;
        }
    }
    return ret_code;
}
   1a6ba:	b003      	add	sp, #12
   1a6bc:	bd30      	pop	{r4, r5, pc}
    p_reg->SHORTS = mask;
   1a6be:	2301      	movs	r3, #1
   1a6c0:	e7e8      	b.n	1a694 <twi_rx_start_transfer+0x40>
               twi_transfer(p_twi, p_cb))
   1a6c2:	4629      	mov	r1, r5
   1a6c4:	4620      	mov	r0, r4
   1a6c6:	f00a fe92 	bl	253ee <twi_transfer>
        while ((hw_timeout > 0) &&
   1a6ca:	b128      	cbz	r0, 1a6d8 <twi_rx_start_transfer+0x84>
               hw_timeout--;
   1a6cc:	9b01      	ldr	r3, [sp, #4]
   1a6ce:	3b01      	subs	r3, #1
   1a6d0:	9301      	str	r3, [sp, #4]
        while ((hw_timeout > 0) &&
   1a6d2:	9b01      	ldr	r3, [sp, #4]
   1a6d4:	2b00      	cmp	r3, #0
   1a6d6:	dcf4      	bgt.n	1a6c2 <twi_rx_start_transfer+0x6e>
        if (p_cb->error)
   1a6d8:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
   1a6dc:	b95b      	cbnz	r3, 1a6f6 <twi_rx_start_transfer+0xa2>
    nrfx_err_t ret_code = NRFX_SUCCESS;
   1a6de:	4813      	ldr	r0, [pc, #76]	; (1a72c <twi_rx_start_transfer+0xd8>)
        if (hw_timeout <= 0)
   1a6e0:	9b01      	ldr	r3, [sp, #4]
   1a6e2:	2b00      	cmp	r3, #0
   1a6e4:	dce9      	bgt.n	1a6ba <twi_rx_start_transfer+0x66>
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos);
   1a6e6:	2300      	movs	r3, #0
   1a6e8:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Enabled << TWI_ENABLE_ENABLE_Pos);
   1a6ec:	2305      	movs	r3, #5
   1a6ee:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
            ret_code = NRFX_ERROR_INTERNAL;
   1a6f2:	480f      	ldr	r0, [pc, #60]	; (1a730 <twi_rx_start_transfer+0xdc>)
    return ret_code;
   1a6f4:	e7e1      	b.n	1a6ba <twi_rx_start_transfer+0x66>
    uint32_t error_source = p_reg->ERRORSRC;
   1a6f6:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   1a6fa:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
            if (errorsrc)
   1a6fe:	2b00      	cmp	r3, #0
   1a700:	d0ed      	beq.n	1a6de <twi_rx_start_transfer+0x8a>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
   1a702:	4a0c      	ldr	r2, [pc, #48]	; (1a734 <twi_rx_start_transfer+0xe0>)
   1a704:	480a      	ldr	r0, [pc, #40]	; (1a730 <twi_rx_start_transfer+0xdc>)
   1a706:	f013 0f01 	tst.w	r3, #1
   1a70a:	bf18      	it	ne
   1a70c:	4610      	movne	r0, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   1a70e:	f013 0f02 	tst.w	r3, #2
   1a712:	f102 0201 	add.w	r2, r2, #1
   1a716:	bf18      	it	ne
   1a718:	4610      	movne	r0, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   1a71a:	f013 0f04 	tst.w	r3, #4
   1a71e:	4b06      	ldr	r3, [pc, #24]	; (1a738 <twi_rx_start_transfer+0xe4>)
   1a720:	bf18      	it	ne
   1a722:	4618      	movne	r0, r3
   1a724:	e7dc      	b.n	1a6e0 <twi_rx_start_transfer+0x8c>
   1a726:	bf00      	nop
   1a728:	000186a0 	.word	0x000186a0
   1a72c:	0bad0000 	.word	0x0bad0000
   1a730:	0bad0001 	.word	0x0bad0001
   1a734:	0bae0000 	.word	0x0bae0000
   1a738:	0bae0002 	.word	0x0bae0002

0001a73c <nrf_gpio_pin_port_decode.isra.1>:
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   1a73c:	281f      	cmp	r0, #31
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
   1a73e:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   1a740:	d906      	bls.n	1a750 <nrf_gpio_pin_port_decode.isra.1+0x14>
   1a742:	4b05      	ldr	r3, [pc, #20]	; (1a758 <nrf_gpio_pin_port_decode.isra.1+0x1c>)
   1a744:	4a05      	ldr	r2, [pc, #20]	; (1a75c <nrf_gpio_pin_port_decode.isra.1+0x20>)
   1a746:	4806      	ldr	r0, [pc, #24]	; (1a760 <nrf_gpio_pin_port_decode.isra.1+0x24>)
   1a748:	f44f 71ed 	mov.w	r1, #474	; 0x1da
   1a74c:	f7e5 fd32 	bl	1b4 <__assert_func>
}
   1a750:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
   1a754:	bd08      	pop	{r3, pc}
   1a756:	bf00      	nop
   1a758:	00064e17 	.word	0x00064e17
   1a75c:	0006521c 	.word	0x0006521c
   1a760:	00064e25 	.word	0x00064e25

0001a764 <twi_tx_start_transfer>:
{
   1a764:	b537      	push	{r0, r1, r2, r4, r5, lr}
    hw_timeout = HW_TIMEOUT;
   1a766:	4b30      	ldr	r3, [pc, #192]	; (1a828 <twi_tx_start_transfer+0xc4>)
   1a768:	9301      	str	r3, [sp, #4]
{
   1a76a:	460d      	mov	r5, r1
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
   1a76c:	f44f 7182 	mov.w	r1, #260	; 0x104
{
   1a770:	4604      	mov	r4, r0
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
   1a772:	f00a fe14 	bl	2539e <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
   1a776:	f44f 7192 	mov.w	r1, #292	; 0x124
   1a77a:	f00a fe10 	bl	2539e <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_TXDSENT);
   1a77e:	f44f 718e 	mov.w	r1, #284	; 0x11c
   1a782:	f00a fe0c 	bl	2539e <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_RXDREADY);
   1a786:	f44f 7184 	mov.w	r1, #264	; 0x108
   1a78a:	f00a fe08 	bl	2539e <nrf_twi_event_clear>
    p_reg->SHORTS = mask;
   1a78e:	2300      	movs	r3, #0
    if (p_cb->prev_suspend != TWI_SUSPEND_TX)
   1a790:	f895 202d 	ldrb.w	r2, [r5, #45]	; 0x2d
   1a794:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
    p_cb->bytes_transferred = 0;
   1a798:	636b      	str	r3, [r5, #52]	; 0x34
    p_cb->error             = false;
   1a79a:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1a79e:	2301      	movs	r3, #1
    if (p_cb->prev_suspend != TWI_SUSPEND_TX)
   1a7a0:	429a      	cmp	r2, r3
   1a7a2:	6203      	str	r3, [r0, #32]
    (void)twi_send_byte(p_twi, p_cb);
   1a7a4:	4629      	mov	r1, r5
   1a7a6:	bf18      	it	ne
   1a7a8:	6083      	strne	r3, [r0, #8]
   1a7aa:	f00a fe00 	bl	253ae <twi_send_byte>
    if (p_cb->handler)
   1a7ae:	682b      	ldr	r3, [r5, #0]
   1a7b0:	b183      	cbz	r3, 1a7d4 <twi_tx_start_transfer+0x70>
        p_cb->int_mask = NRF_TWI_INT_STOPPED_MASK   |
   1a7b2:	f240 2386 	movw	r3, #646	; 0x286
   1a7b6:	60ab      	str	r3, [r5, #8]
        nrf_twi_int_enable(p_twi, p_cb->int_mask);
   1a7b8:	68ab      	ldr	r3, [r5, #8]
    nrfx_err_t ret_code = NRFX_SUCCESS;
   1a7ba:	481c      	ldr	r0, [pc, #112]	; (1a82c <twi_tx_start_transfer+0xc8>)
    p_reg->INTENSET = mask;
   1a7bc:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
   1a7c0:	b003      	add	sp, #12
   1a7c2:	bd30      	pop	{r4, r5, pc}
               twi_transfer(p_twi, p_cb))
   1a7c4:	4629      	mov	r1, r5
   1a7c6:	4620      	mov	r0, r4
   1a7c8:	f00a fe11 	bl	253ee <twi_transfer>
        while ((hw_timeout > 0) &&
   1a7cc:	b128      	cbz	r0, 1a7da <twi_tx_start_transfer+0x76>
            hw_timeout--;
   1a7ce:	9b01      	ldr	r3, [sp, #4]
   1a7d0:	3b01      	subs	r3, #1
   1a7d2:	9301      	str	r3, [sp, #4]
        while ((hw_timeout > 0) &&
   1a7d4:	9b01      	ldr	r3, [sp, #4]
   1a7d6:	2b00      	cmp	r3, #0
   1a7d8:	dcf4      	bgt.n	1a7c4 <twi_tx_start_transfer+0x60>
        if (p_cb->error)
   1a7da:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
   1a7de:	b95b      	cbnz	r3, 1a7f8 <twi_tx_start_transfer+0x94>
    nrfx_err_t ret_code = NRFX_SUCCESS;
   1a7e0:	4812      	ldr	r0, [pc, #72]	; (1a82c <twi_tx_start_transfer+0xc8>)
        if (hw_timeout <= 0)
   1a7e2:	9b01      	ldr	r3, [sp, #4]
   1a7e4:	2b00      	cmp	r3, #0
   1a7e6:	dceb      	bgt.n	1a7c0 <twi_tx_start_transfer+0x5c>
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos);
   1a7e8:	2300      	movs	r3, #0
   1a7ea:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Enabled << TWI_ENABLE_ENABLE_Pos);
   1a7ee:	2305      	movs	r3, #5
   1a7f0:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
            ret_code = NRFX_ERROR_INTERNAL;
   1a7f4:	480e      	ldr	r0, [pc, #56]	; (1a830 <twi_tx_start_transfer+0xcc>)
    return ret_code;
   1a7f6:	e7e3      	b.n	1a7c0 <twi_tx_start_transfer+0x5c>
    uint32_t error_source = p_reg->ERRORSRC;
   1a7f8:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   1a7fc:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
            if (errorsrc)
   1a800:	2b00      	cmp	r3, #0
   1a802:	d0ed      	beq.n	1a7e0 <twi_tx_start_transfer+0x7c>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
   1a804:	4a0b      	ldr	r2, [pc, #44]	; (1a834 <twi_tx_start_transfer+0xd0>)
   1a806:	480a      	ldr	r0, [pc, #40]	; (1a830 <twi_tx_start_transfer+0xcc>)
   1a808:	f013 0f01 	tst.w	r3, #1
   1a80c:	bf18      	it	ne
   1a80e:	4610      	movne	r0, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   1a810:	f013 0f02 	tst.w	r3, #2
   1a814:	f102 0201 	add.w	r2, r2, #1
   1a818:	bf18      	it	ne
   1a81a:	4610      	movne	r0, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   1a81c:	f013 0f04 	tst.w	r3, #4
   1a820:	4b05      	ldr	r3, [pc, #20]	; (1a838 <twi_tx_start_transfer+0xd4>)
   1a822:	bf18      	it	ne
   1a824:	4618      	movne	r0, r3
   1a826:	e7dc      	b.n	1a7e2 <twi_tx_start_transfer+0x7e>
   1a828:	000186a0 	.word	0x000186a0
   1a82c:	0bad0000 	.word	0x0bad0000
   1a830:	0bad0001 	.word	0x0bad0001
   1a834:	0bae0000 	.word	0x0bae0000
   1a838:	0bae0002 	.word	0x0bae0002

0001a83c <nrfx_twi_init>:
{
   1a83c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a840:	4681      	mov	r9, r0
   1a842:	4690      	mov	r8, r2
    NRFX_ASSERT(p_config);
   1a844:	460d      	mov	r5, r1
   1a846:	b929      	cbnz	r1, 1a854 <nrfx_twi_init+0x18>
   1a848:	4b26      	ldr	r3, [pc, #152]	; (1a8e4 <nrfx_twi_init+0xa8>)
   1a84a:	4a27      	ldr	r2, [pc, #156]	; (1a8e8 <nrfx_twi_init+0xac>)
   1a84c:	218e      	movs	r1, #142	; 0x8e
    NRFX_ASSERT(p_config->scl != p_config->sda);
   1a84e:	4827      	ldr	r0, [pc, #156]	; (1a8ec <nrfx_twi_init+0xb0>)
   1a850:	f7e5 fcb0 	bl	1b4 <__assert_func>
   1a854:	e9d1 a700 	ldrd	sl, r7, [r1]
   1a858:	45ba      	cmp	sl, r7
   1a85a:	d103      	bne.n	1a864 <nrfx_twi_init+0x28>
   1a85c:	4b24      	ldr	r3, [pc, #144]	; (1a8f0 <nrfx_twi_init+0xb4>)
   1a85e:	4a22      	ldr	r2, [pc, #136]	; (1a8e8 <nrfx_twi_init+0xac>)
   1a860:	218f      	movs	r1, #143	; 0x8f
   1a862:	e7f4      	b.n	1a84e <nrfx_twi_init+0x12>
    twi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   1a864:	7906      	ldrb	r6, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   1a866:	4c23      	ldr	r4, [pc, #140]	; (1a8f4 <nrfx_twi_init+0xb8>)
   1a868:	223c      	movs	r2, #60	; 0x3c
   1a86a:	4372      	muls	r2, r6
   1a86c:	18a0      	adds	r0, r4, r2
   1a86e:	f890 102e 	ldrb.w	r1, [r0, #46]	; 0x2e
   1a872:	bba9      	cbnz	r1, 1a8e0 <nrfx_twi_init+0xa4>
    p_cb->p_context       = p_context;
   1a874:	6043      	str	r3, [r0, #4]
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   1a876:	7b6b      	ldrb	r3, [r5, #13]
    p_cb->int_mask        = 0;
   1a878:	6081      	str	r1, [r0, #8]
    p_cb->prev_suspend    = TWI_NO_SUSPEND;
   1a87a:	f880 102d 	strb.w	r1, [r0, #45]	; 0x2d
    p_cb->repeated        = false;
   1a87e:	f880 1031 	strb.w	r1, [r0, #49]	; 0x31
    p_cb->busy            = false;
   1a882:	f880 1030 	strb.w	r1, [r0, #48]	; 0x30
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   1a886:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
    p_cb->handler         = event_handler;
   1a88a:	f844 8002 	str.w	r8, [r4, r2]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   1a88e:	4650      	mov	r0, sl
   1a890:	f7ff ff54 	bl	1a73c <nrf_gpio_pin_port_decode.isra.1>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1a894:	f50a 73e0 	add.w	r3, sl, #448	; 0x1c0
   1a898:	f240 6b0c 	movw	fp, #1548	; 0x60c
   1a89c:	f840 b023 	str.w	fp, [r0, r3, lsl #2]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   1a8a0:	4638      	mov	r0, r7
   1a8a2:	f7ff ff4b 	bl	1a73c <nrf_gpio_pin_port_decode.isra.1>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1a8a6:	f507 73e0 	add.w	r3, r7, #448	; 0x1c0
   1a8aa:	f840 b023 	str.w	fp, [r0, r3, lsl #2]
    NRF_TWI_Type * p_twi = p_instance->p_twi;
   1a8ae:	f8d9 0000 	ldr.w	r0, [r9]
        (nrf_twi_frequency_t)p_config->frequency);
   1a8b2:	68ab      	ldr	r3, [r5, #8]
    p_reg->PSELSCL = scl_pin;
   1a8b4:	f8c0 a508 	str.w	sl, [r0, #1288]	; 0x508
    p_reg->PSELSDA = sda_pin;
   1a8b8:	f8c0 750c 	str.w	r7, [r0, #1292]	; 0x50c
    p_reg->FREQUENCY = frequency;
   1a8bc:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524
    if (p_cb->handler)
   1a8c0:	f1b8 0f00 	cmp.w	r8, #0
   1a8c4:	d003      	beq.n	1a8ce <nrfx_twi_init+0x92>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twi));
   1a8c6:	f340 3007 	sbfx	r0, r0, #12, #8
   1a8ca:	f7ec f919 	bl	6b00 <arch_irq_enable>
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   1a8ce:	233c      	movs	r3, #60	; 0x3c
   1a8d0:	fb03 4406 	mla	r4, r3, r6, r4
    return err_code;
   1a8d4:	4808      	ldr	r0, [pc, #32]	; (1a8f8 <nrfx_twi_init+0xbc>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   1a8d6:	2301      	movs	r3, #1
   1a8d8:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
}
   1a8dc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return err_code;
   1a8e0:	4806      	ldr	r0, [pc, #24]	; (1a8fc <nrfx_twi_init+0xc0>)
   1a8e2:	e7fb      	b.n	1a8dc <nrfx_twi_init+0xa0>
   1a8e4:	0006511f 	.word	0x0006511f
   1a8e8:	00065235 	.word	0x00065235
   1a8ec:	000652ac 	.word	0x000652ac
   1a8f0:	000652e6 	.word	0x000652e6
   1a8f4:	20001a54 	.word	0x20001a54
   1a8f8:	0bad0000 	.word	0x0bad0000
   1a8fc:	0bad0005 	.word	0x0bad0005

0001a900 <nrfx_twi_enable>:
{
   1a900:	b508      	push	{r3, lr}
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   1a902:	4a0b      	ldr	r2, [pc, #44]	; (1a930 <nrfx_twi_enable+0x30>)
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   1a904:	7903      	ldrb	r3, [r0, #4]
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   1a906:	213c      	movs	r1, #60	; 0x3c
   1a908:	fb01 2303 	mla	r3, r1, r3, r2
   1a90c:	f893 202e 	ldrb.w	r2, [r3, #46]	; 0x2e
   1a910:	2a01      	cmp	r2, #1
   1a912:	d005      	beq.n	1a920 <nrfx_twi_enable+0x20>
   1a914:	4b07      	ldr	r3, [pc, #28]	; (1a934 <nrfx_twi_enable+0x34>)
   1a916:	4a08      	ldr	r2, [pc, #32]	; (1a938 <nrfx_twi_enable+0x38>)
   1a918:	4808      	ldr	r0, [pc, #32]	; (1a93c <nrfx_twi_enable+0x3c>)
   1a91a:	21ee      	movs	r1, #238	; 0xee
   1a91c:	f7e5 fc4a 	bl	1b4 <__assert_func>
    NRF_TWI_Type * p_twi = p_instance->p_twi;
   1a920:	6802      	ldr	r2, [r0, #0]
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Enabled << TWI_ENABLE_ENABLE_Pos);
   1a922:	2105      	movs	r1, #5
   1a924:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
   1a928:	2202      	movs	r2, #2
   1a92a:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
}
   1a92e:	bd08      	pop	{r3, pc}
   1a930:	20001a54 	.word	0x20001a54
   1a934:	00065282 	.word	0x00065282
   1a938:	00065243 	.word	0x00065243
   1a93c:	000652ac 	.word	0x000652ac

0001a940 <nrfx_twi_disable>:
{
   1a940:	b508      	push	{r3, lr}
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   1a942:	4a0f      	ldr	r2, [pc, #60]	; (1a980 <nrfx_twi_disable+0x40>)
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   1a944:	7903      	ldrb	r3, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   1a946:	213c      	movs	r1, #60	; 0x3c
   1a948:	fb01 2303 	mla	r3, r1, r3, r2
   1a94c:	f893 202e 	ldrb.w	r2, [r3, #46]	; 0x2e
   1a950:	b92a      	cbnz	r2, 1a95e <nrfx_twi_disable+0x1e>
   1a952:	4b0c      	ldr	r3, [pc, #48]	; (1a984 <nrfx_twi_disable+0x44>)
   1a954:	4a0c      	ldr	r2, [pc, #48]	; (1a988 <nrfx_twi_disable+0x48>)
   1a956:	480d      	ldr	r0, [pc, #52]	; (1a98c <nrfx_twi_disable+0x4c>)
   1a958:	21fa      	movs	r1, #250	; 0xfa
   1a95a:	f7e5 fc2b 	bl	1b4 <__assert_func>
    NRF_TWI_Type * p_twi = p_instance->p_twi;
   1a95e:	6802      	ldr	r2, [r0, #0]
    p_reg->INTENCLR = mask;
   1a960:	490b      	ldr	r1, [pc, #44]	; (1a990 <nrfx_twi_disable+0x50>)
   1a962:	f8c2 1308 	str.w	r1, [r2, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
   1a966:	f8d2 1200 	ldr.w	r1, [r2, #512]	; 0x200
   1a96a:	f021 0103 	bic.w	r1, r1, #3
   1a96e:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos);
   1a972:	2100      	movs	r1, #0
   1a974:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   1a978:	2201      	movs	r2, #1
   1a97a:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
}
   1a97e:	bd08      	pop	{r3, pc}
   1a980:	20001a54 	.word	0x20001a54
   1a984:	00065162 	.word	0x00065162
   1a988:	00065253 	.word	0x00065253
   1a98c:	000652ac 	.word	0x000652ac
   1a990:	00044286 	.word	0x00044286

0001a994 <nrfx_twi_xfer>:
}

nrfx_err_t nrfx_twi_xfer(nrfx_twi_t const *           p_instance,
                         nrfx_twi_xfer_desc_t const * p_xfer_desc,
                         uint32_t                     flags)
{
   1a994:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

    nrfx_err_t err_code = NRFX_SUCCESS;
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   1a998:	7907      	ldrb	r7, [r0, #4]

    // TXRX and TXTX transfers are supported only in non-blocking mode.
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWI_XFER_TXRX)));
   1a99a:	4c3c      	ldr	r4, [pc, #240]	; (1aa8c <nrfx_twi_xfer+0xf8>)
   1a99c:	233c      	movs	r3, #60	; 0x3c
   1a99e:	437b      	muls	r3, r7
{
   1a9a0:	460e      	mov	r6, r1
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWI_XFER_TXRX)));
   1a9a2:	58e3      	ldr	r3, [r4, r3]
{
   1a9a4:	4690      	mov	r8, r2
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWI_XFER_TXRX)));
   1a9a6:	b983      	cbnz	r3, 1a9ca <nrfx_twi_xfer+0x36>
   1a9a8:	780b      	ldrb	r3, [r1, #0]
   1a9aa:	2b02      	cmp	r3, #2
   1a9ac:	d106      	bne.n	1a9bc <nrfx_twi_xfer+0x28>
   1a9ae:	4b38      	ldr	r3, [pc, #224]	; (1aa90 <nrfx_twi_xfer+0xfc>)
   1a9b0:	4a38      	ldr	r2, [pc, #224]	; (1aa94 <nrfx_twi_xfer+0x100>)
   1a9b2:	f44f 7115 	mov.w	r1, #596	; 0x254
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWI_XFER_TXTX)));
   1a9b6:	4838      	ldr	r0, [pc, #224]	; (1aa98 <nrfx_twi_xfer+0x104>)
   1a9b8:	f7e5 fbfc 	bl	1b4 <__assert_func>
   1a9bc:	2b03      	cmp	r3, #3
   1a9be:	d104      	bne.n	1a9ca <nrfx_twi_xfer+0x36>
   1a9c0:	4b36      	ldr	r3, [pc, #216]	; (1aa9c <nrfx_twi_xfer+0x108>)
   1a9c2:	4a34      	ldr	r2, [pc, #208]	; (1aa94 <nrfx_twi_xfer+0x100>)
   1a9c4:	f240 2155 	movw	r1, #597	; 0x255
   1a9c8:	e7f5      	b.n	1a9b6 <nrfx_twi_xfer+0x22>
    if ((p_cb->prev_suspend == TWI_SUSPEND_TX) && (p_xfer_desc->type == NRFX_TWI_XFER_RX))
   1a9ca:	233c      	movs	r3, #60	; 0x3c
   1a9cc:	fb03 4307 	mla	r3, r3, r7, r4
                           p_xfer_desc->primary_length * sizeof(p_xfer_desc->p_primary_buf[0]));
    NRFX_LOG_DEBUG("Secondary buffer data:");
    NRFX_LOG_HEXDUMP_DEBUG(p_xfer_desc->p_secondary_buf,
                           p_xfer_desc->secondary_length * sizeof(p_xfer_desc->p_secondary_buf[0]));

    err_code = twi_xfer((NRF_TWI_Type  *)p_instance->p_twi, p_cb, p_xfer_desc, flags);
   1a9d0:	f8d0 9000 	ldr.w	r9, [r0]
    if ((p_cb->prev_suspend == TWI_SUSPEND_TX) && (p_xfer_desc->type == NRFX_TWI_XFER_RX))
   1a9d4:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
   1a9d8:	2b01      	cmp	r3, #1
   1a9da:	d104      	bne.n	1a9e6 <nrfx_twi_xfer+0x52>
   1a9dc:	7833      	ldrb	r3, [r6, #0]
   1a9de:	2b01      	cmp	r3, #1
   1a9e0:	d106      	bne.n	1a9f0 <nrfx_twi_xfer+0x5c>
        return NRFX_ERROR_INVALID_STATE;
   1a9e2:	482f      	ldr	r0, [pc, #188]	; (1aaa0 <nrfx_twi_xfer+0x10c>)
    NRFX_LOG_WARNING("Function: %s, error code: %s.",
                     __func__,
                     NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   1a9e4:	e011      	b.n	1aa0a <nrfx_twi_xfer+0x76>
    else if ((p_cb->prev_suspend == TWI_SUSPEND_RX) && (p_xfer_desc->type != NRFX_TWI_XFER_RX))
   1a9e6:	2b02      	cmp	r3, #2
   1a9e8:	d102      	bne.n	1a9f0 <nrfx_twi_xfer+0x5c>
   1a9ea:	7833      	ldrb	r3, [r6, #0]
   1a9ec:	2b01      	cmp	r3, #1
   1a9ee:	d1f8      	bne.n	1a9e2 <nrfx_twi_xfer+0x4e>
    if (p_cb->busy)
   1a9f0:	253c      	movs	r5, #60	; 0x3c
    p_reg->INTENCLR = mask;
   1a9f2:	4b2c      	ldr	r3, [pc, #176]	; (1aaa4 <nrfx_twi_xfer+0x110>)
   1a9f4:	f8c9 3308 	str.w	r3, [r9, #776]	; 0x308
   1a9f8:	fb05 4507 	mla	r5, r5, r7, r4
   1a9fc:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
   1aa00:	b12b      	cbz	r3, 1aa0e <nrfx_twi_xfer+0x7a>
        nrf_twi_int_enable(p_twi, p_cb->int_mask);
   1aa02:	68ab      	ldr	r3, [r5, #8]
        return err_code;
   1aa04:	4828      	ldr	r0, [pc, #160]	; (1aaa8 <nrfx_twi_xfer+0x114>)
    p_reg->INTENSET = mask;
   1aa06:	f8c9 3304 	str.w	r3, [r9, #772]	; 0x304
}
   1aa0a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        p_cb->busy = (TWI_FLAG_NO_HANDLER_IN_USE(flags)) ? false : true;
   1aa0e:	f088 0304 	eor.w	r3, r8, #4
   1aa12:	f3c3 0380 	ubfx	r3, r3, #2, #1
   1aa16:	f885 3030 	strb.w	r3, [r5, #48]	; 0x30
    p_cb->flags       = flags;
   1aa1a:	f8c5 8020 	str.w	r8, [r5, #32]
    p_cb->xfer_desc   = *p_xfer_desc;
   1aa1e:	46b6      	mov	lr, r6
   1aa20:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   1aa24:	f105 0c0c 	add.w	ip, r5, #12
   1aa28:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   1aa2c:	f8de 3000 	ldr.w	r3, [lr]
   1aa30:	f8cc 3000 	str.w	r3, [ip]
    p_cb->curr_length = p_xfer_desc->primary_length;
   1aa34:	6873      	ldr	r3, [r6, #4]
   1aa36:	62ab      	str	r3, [r5, #40]	; 0x28
    p_cb->p_curr_buf  = p_xfer_desc->p_primary_buf;
   1aa38:	68f3      	ldr	r3, [r6, #12]
   1aa3a:	626b      	str	r3, [r5, #36]	; 0x24
    p_reg->ADDRESS = address;
   1aa3c:	7873      	ldrb	r3, [r6, #1]
   1aa3e:	f8c9 3588 	str.w	r3, [r9, #1416]	; 0x588
    if (p_xfer_desc->type != NRFX_TWI_XFER_RX)
   1aa42:	7833      	ldrb	r3, [r6, #0]
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   1aa44:	ebc7 1a07 	rsb	sl, r7, r7, lsl #4
    if (p_xfer_desc->type != NRFX_TWI_XFER_RX)
   1aa48:	2b01      	cmp	r3, #1
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   1aa4a:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
    if (p_xfer_desc->type != NRFX_TWI_XFER_RX)
   1aa4e:	d017      	beq.n	1aa80 <nrfx_twi_xfer+0xec>
                                 !(flags & NRFX_TWI_FLAG_TX_NO_STOP)) ? false : true;
   1aa50:	b99b      	cbnz	r3, 1aa7a <nrfx_twi_xfer+0xe6>
   1aa52:	f3c8 1840 	ubfx	r8, r8, #5, #1
        p_cb->curr_tx_no_stop = ((p_xfer_desc->type == NRFX_TWI_XFER_TX) &&
   1aa56:	233c      	movs	r3, #60	; 0x3c
   1aa58:	fb03 4307 	mla	r3, r3, r7, r4
        err_code = twi_tx_start_transfer(p_twi, p_cb);
   1aa5c:	4651      	mov	r1, sl
                                 !(flags & NRFX_TWI_FLAG_TX_NO_STOP)) ? false : true;
   1aa5e:	f883 802c 	strb.w	r8, [r3, #44]	; 0x2c
        err_code = twi_tx_start_transfer(p_twi, p_cb);
   1aa62:	4648      	mov	r0, r9
   1aa64:	f7ff fe7e 	bl	1a764 <twi_tx_start_transfer>
    if (p_cb->handler == NULL)
   1aa68:	233c      	movs	r3, #60	; 0x3c
   1aa6a:	435f      	muls	r7, r3
   1aa6c:	19e2      	adds	r2, r4, r7
   1aa6e:	59e3      	ldr	r3, [r4, r7]
   1aa70:	2b00      	cmp	r3, #0
   1aa72:	d1ca      	bne.n	1aa0a <nrfx_twi_xfer+0x76>
        p_cb->busy = false;
   1aa74:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
   1aa78:	e7c7      	b.n	1aa0a <nrfx_twi_xfer+0x76>
                                 !(flags & NRFX_TWI_FLAG_TX_NO_STOP)) ? false : true;
   1aa7a:	f04f 0801 	mov.w	r8, #1
   1aa7e:	e7ea      	b.n	1aa56 <nrfx_twi_xfer+0xc2>
        err_code = twi_rx_start_transfer(p_twi, p_cb);
   1aa80:	4651      	mov	r1, sl
   1aa82:	4648      	mov	r0, r9
   1aa84:	f7ff fde6 	bl	1a654 <twi_rx_start_transfer>
   1aa88:	e7ee      	b.n	1aa68 <nrfx_twi_xfer+0xd4>
   1aa8a:	bf00      	nop
   1aa8c:	20001a54 	.word	0x20001a54
   1aa90:	00065305 	.word	0x00065305
   1aa94:	00065264 	.word	0x00065264
   1aa98:	000652ac 	.word	0x000652ac
   1aa9c:	00065354 	.word	0x00065354
   1aaa0:	0bad0005 	.word	0x0bad0005
   1aaa4:	00044286 	.word	0x00044286
   1aaa8:	0bad000b 	.word	0x0bad000b

0001aaac <nrfx_twi_1_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_TWI1_ENABLED)
void nrfx_twi_1_irq_handler(void)
{
   1aaac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    NRFX_ASSERT(p_cb->handler);
   1aab0:	4c2d      	ldr	r4, [pc, #180]	; (1ab68 <nrfx_twi_1_irq_handler+0xbc>)
   1aab2:	6823      	ldr	r3, [r4, #0]
{
   1aab4:	b086      	sub	sp, #24
   1aab6:	46a0      	mov	r8, r4
    NRFX_ASSERT(p_cb->handler);
   1aab8:	b933      	cbnz	r3, 1aac8 <nrfx_twi_1_irq_handler+0x1c>
   1aaba:	4b2c      	ldr	r3, [pc, #176]	; (1ab6c <nrfx_twi_1_irq_handler+0xc0>)
   1aabc:	4a2c      	ldr	r2, [pc, #176]	; (1ab70 <nrfx_twi_1_irq_handler+0xc4>)
   1aabe:	482d      	ldr	r0, [pc, #180]	; (1ab74 <nrfx_twi_1_irq_handler+0xc8>)
   1aac0:	f240 2175 	movw	r1, #629	; 0x275
   1aac4:	f7e5 fb76 	bl	1b4 <__assert_func>
    if (twi_transfer(p_twi, p_cb))
   1aac8:	4621      	mov	r1, r4
   1aaca:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
   1aace:	f00a fc8e 	bl	253ee <twi_transfer>
   1aad2:	b9e0      	cbnz	r0, 1ab0e <nrfx_twi_1_irq_handler+0x62>
    if (!p_cb->error &&
   1aad4:	f894 702f 	ldrb.w	r7, [r4, #47]	; 0x2f
   1aad8:	6a26      	ldr	r6, [r4, #32]
   1aada:	b9f7      	cbnz	r7, 1ab1a <nrfx_twi_1_irq_handler+0x6e>
        ((p_cb->xfer_desc.type == NRFX_TWI_XFER_TXRX) ||
   1aadc:	7b23      	ldrb	r3, [r4, #12]
    if (!p_cb->error &&
   1aade:	1e9a      	subs	r2, r3, #2
   1aae0:	2a01      	cmp	r2, #1
   1aae2:	d81a      	bhi.n	1ab1a <nrfx_twi_1_irq_handler+0x6e>
         (p_cb->xfer_desc.type == NRFX_TWI_XFER_TXTX)) &&
   1aae4:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1aae6:	69a2      	ldr	r2, [r4, #24]
   1aae8:	4291      	cmp	r1, r2
   1aaea:	d116      	bne.n	1ab1a <nrfx_twi_1_irq_handler+0x6e>
        p_cb->p_curr_buf      = p_cb->xfer_desc.p_secondary_buf;
   1aaec:	69e2      	ldr	r2, [r4, #28]
   1aaee:	6262      	str	r2, [r4, #36]	; 0x24
        p_cb->curr_tx_no_stop = (p_cb->flags & NRFX_TWI_FLAG_TX_NO_STOP);
   1aaf0:	f3c6 1640 	ubfx	r6, r6, #5, #1
        p_cb->curr_length     = p_cb->xfer_desc.secondary_length;
   1aaf4:	6962      	ldr	r2, [r4, #20]
   1aaf6:	62a2      	str	r2, [r4, #40]	; 0x28
        if (p_cb->xfer_desc.type == NRFX_TWI_XFER_TXTX)
   1aaf8:	2b03      	cmp	r3, #3
        p_cb->curr_tx_no_stop = (p_cb->flags & NRFX_TWI_FLAG_TX_NO_STOP);
   1aafa:	f884 602c 	strb.w	r6, [r4, #44]	; 0x2c
        p_cb->prev_suspend    = TWI_NO_SUSPEND;
   1aafe:	f884 702d 	strb.w	r7, [r4, #45]	; 0x2d
            (void)twi_tx_start_transfer(p_twi, p_cb);
   1ab02:	4621      	mov	r1, r4
   1ab04:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
        if (p_cb->xfer_desc.type == NRFX_TWI_XFER_TXTX)
   1ab08:	d104      	bne.n	1ab14 <nrfx_twi_1_irq_handler+0x68>
            (void)twi_tx_start_transfer(p_twi, p_cb);
   1ab0a:	f7ff fe2b 	bl	1a764 <twi_tx_start_transfer>
    twi_irq_handler(NRF_TWI1, &m_cb[NRFX_TWI1_INST_IDX]);
}
   1ab0e:	b006      	add	sp, #24
   1ab10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            (void)twi_rx_start_transfer(p_twi, p_cb);
   1ab14:	f7ff fd9e 	bl	1a654 <twi_rx_start_transfer>
   1ab18:	e7f9      	b.n	1ab0e <nrfx_twi_1_irq_handler+0x62>
        event.xfer_desc = p_cb->xfer_desc;
   1ab1a:	4d17      	ldr	r5, [pc, #92]	; (1ab78 <nrfx_twi_1_irq_handler+0xcc>)
   1ab1c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1ab1e:	ac01      	add	r4, sp, #4
   1ab20:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1ab22:	682b      	ldr	r3, [r5, #0]
   1ab24:	6023      	str	r3, [r4, #0]
        if (p_cb->error)
   1ab26:	b1e7      	cbz	r7, 1ab62 <nrfx_twi_1_irq_handler+0xb6>
    uint32_t error_source = p_reg->ERRORSRC;
   1ab28:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   1ab2c:	f8d2 34c4 	ldr.w	r3, [r2, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   1ab30:	f8c2 34c4 	str.w	r3, [r2, #1220]	; 0x4c4
            if (errorsrc & NRF_TWI_ERROR_ADDRESS_NACK)
   1ab34:	0798      	lsls	r0, r3, #30
   1ab36:	d50c      	bpl.n	1ab52 <nrfx_twi_1_irq_handler+0xa6>
                event.type = NRFX_TWI_EVT_ADDRESS_NACK;
   1ab38:	2301      	movs	r3, #1
                event.type = NRFX_TWI_EVT_DATA_NACK;
   1ab3a:	f88d 3000 	strb.w	r3, [sp]
        p_cb->busy = false;
   1ab3e:	2300      	movs	r3, #0
   1ab40:	f888 3030 	strb.w	r3, [r8, #48]	; 0x30
        if (!(TWI_FLAG_NO_HANDLER_IN_USE(p_cb->flags)))
   1ab44:	0773      	lsls	r3, r6, #29
   1ab46:	d4e2      	bmi.n	1ab0e <nrfx_twi_1_irq_handler+0x62>
            p_cb->handler(&event, p_cb->p_context);
   1ab48:	e9d8 3100 	ldrd	r3, r1, [r8]
   1ab4c:	4668      	mov	r0, sp
   1ab4e:	4798      	blx	r3
}
   1ab50:	e7dd      	b.n	1ab0e <nrfx_twi_1_irq_handler+0x62>
            else if (errorsrc & NRF_TWI_ERROR_DATA_NACK)
   1ab52:	0759      	lsls	r1, r3, #29
   1ab54:	d501      	bpl.n	1ab5a <nrfx_twi_1_irq_handler+0xae>
                event.type = NRFX_TWI_EVT_DATA_NACK;
   1ab56:	2302      	movs	r3, #2
   1ab58:	e7ef      	b.n	1ab3a <nrfx_twi_1_irq_handler+0x8e>
            else if (errorsrc & NRF_TWI_ERROR_OVERRUN)
   1ab5a:	07da      	lsls	r2, r3, #31
   1ab5c:	d5ef      	bpl.n	1ab3e <nrfx_twi_1_irq_handler+0x92>
                event.type = NRFX_TWI_EVT_OVERRUN;
   1ab5e:	2303      	movs	r3, #3
   1ab60:	e7eb      	b.n	1ab3a <nrfx_twi_1_irq_handler+0x8e>
            event.type = NRFX_TWI_EVT_DONE;
   1ab62:	f88d 7000 	strb.w	r7, [sp]
   1ab66:	e7ea      	b.n	1ab3e <nrfx_twi_1_irq_handler+0x92>
   1ab68:	20001a54 	.word	0x20001a54
   1ab6c:	00065111 	.word	0x00065111
   1ab70:	00065272 	.word	0x00065272
   1ab74:	000652ac 	.word	0x000652ac
   1ab78:	20001a60 	.word	0x20001a60

0001ab7c <lv_disp_get_scr_act>:
 * @param disp pointer to display which active screen should be get. (NULL to use the default
 * screen)
 * @return pointer to the active screen object (loaded by 'lv_scr_load()')
 */
lv_obj_t * lv_disp_get_scr_act(lv_disp_t * disp)
{
   1ab7c:	b510      	push	{r4, lr}
    if(!disp) disp = lv_disp_get_default();
   1ab7e:	4604      	mov	r4, r0
   1ab80:	b958      	cbnz	r0, 1ab9a <lv_disp_get_scr_act+0x1e>
   1ab82:	f001 ff37 	bl	1c9f4 <lv_disp_get_default>
    if(!disp) {
   1ab86:	4604      	mov	r4, r0
   1ab88:	b938      	cbnz	r0, 1ab9a <lv_disp_get_scr_act+0x1e>
        LV_LOG_WARN("lv_scr_act: no display registered to get its top layer");
   1ab8a:	4b05      	ldr	r3, [pc, #20]	; (1aba0 <lv_disp_get_scr_act+0x24>)
   1ab8c:	4905      	ldr	r1, [pc, #20]	; (1aba4 <lv_disp_get_scr_act+0x28>)
   1ab8e:	222e      	movs	r2, #46	; 0x2e
   1ab90:	2002      	movs	r0, #2
   1ab92:	f002 fa61 	bl	1d058 <lv_log_add>
        return NULL;
    }

    return disp->act_scr;
}
   1ab96:	4620      	mov	r0, r4
   1ab98:	bd10      	pop	{r4, pc}
    return disp->act_scr;
   1ab9a:	6b64      	ldr	r4, [r4, #52]	; 0x34
   1ab9c:	e7fb      	b.n	1ab96 <lv_disp_get_scr_act+0x1a>
   1ab9e:	bf00      	nop
   1aba0:	00065415 	.word	0x00065415
   1aba4:	0006544c 	.word	0x0006544c

0001aba8 <lv_disp_get_layer_top>:
 * Return with the top layer. (Same on every screen and it is above the normal screen layer)
 * @param disp pointer to display which top layer should be get. (NULL to use the default screen)
 * @return pointer to the top layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_top(lv_disp_t * disp)
{
   1aba8:	b510      	push	{r4, lr}
    if(!disp) disp = lv_disp_get_default();
   1abaa:	4604      	mov	r4, r0
   1abac:	b958      	cbnz	r0, 1abc6 <lv_disp_get_layer_top+0x1e>
   1abae:	f001 ff21 	bl	1c9f4 <lv_disp_get_default>
    if(!disp) {
   1abb2:	4604      	mov	r4, r0
   1abb4:	b938      	cbnz	r0, 1abc6 <lv_disp_get_layer_top+0x1e>
        LV_LOG_WARN("lv_layer_top: no display registered to get its top layer");
   1abb6:	4b05      	ldr	r3, [pc, #20]	; (1abcc <lv_disp_get_layer_top+0x24>)
   1abb8:	4905      	ldr	r1, [pc, #20]	; (1abd0 <lv_disp_get_layer_top+0x28>)
   1abba:	224b      	movs	r2, #75	; 0x4b
   1abbc:	2002      	movs	r0, #2
   1abbe:	f002 fa4b 	bl	1d058 <lv_log_add>
        return NULL;
    }

    return disp->top_layer;
}
   1abc2:	4620      	mov	r0, r4
   1abc4:	bd10      	pop	{r4, pc}
    return disp->top_layer;
   1abc6:	6ba4      	ldr	r4, [r4, #56]	; 0x38
   1abc8:	e7fb      	b.n	1abc2 <lv_disp_get_layer_top+0x1a>
   1abca:	bf00      	nop
   1abcc:	000653dc 	.word	0x000653dc
   1abd0:	0006544c 	.word	0x0006544c

0001abd4 <lv_disp_get_layer_sys>:
 * layer)
 * @param disp pointer to display which sys. layer  should be get. (NULL to use the default screen)
 * @return pointer to the sys layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_sys(lv_disp_t * disp)
{
   1abd4:	b510      	push	{r4, lr}
    if(!disp) disp = lv_disp_get_default();
   1abd6:	4604      	mov	r4, r0
   1abd8:	b958      	cbnz	r0, 1abf2 <lv_disp_get_layer_sys+0x1e>
   1abda:	f001 ff0b 	bl	1c9f4 <lv_disp_get_default>
    if(!disp) {
   1abde:	4604      	mov	r4, r0
   1abe0:	b938      	cbnz	r0, 1abf2 <lv_disp_get_layer_sys+0x1e>
        LV_LOG_WARN("lv_layer_sys: no display registered to get its top layer");
   1abe2:	4b05      	ldr	r3, [pc, #20]	; (1abf8 <lv_disp_get_layer_sys+0x24>)
   1abe4:	4905      	ldr	r1, [pc, #20]	; (1abfc <lv_disp_get_layer_sys+0x28>)
   1abe6:	225c      	movs	r2, #92	; 0x5c
   1abe8:	2002      	movs	r0, #2
   1abea:	f002 fa35 	bl	1d058 <lv_log_add>
        return NULL;
    }

    return disp->sys_layer;
}
   1abee:	4620      	mov	r0, r4
   1abf0:	bd10      	pop	{r4, pc}
    return disp->sys_layer;
   1abf2:	6be4      	ldr	r4, [r4, #60]	; 0x3c
   1abf4:	e7fb      	b.n	1abee <lv_disp_get_layer_sys+0x1a>
   1abf6:	bf00      	nop
   1abf8:	000653a3 	.word	0x000653a3
   1abfc:	0006544c 	.word	0x0006544c

0001ac00 <lv_init>:

/**
 * Init. the 'lv' library.
 */
void lv_init(void)
{
   1ac00:	b510      	push	{r4, lr}
    /* Do nothing if already initialized */
    if(lv_initialized) {
   1ac02:	4c14      	ldr	r4, [pc, #80]	; (1ac54 <lv_init+0x54>)
   1ac04:	7823      	ldrb	r3, [r4, #0]
   1ac06:	b13b      	cbz	r3, 1ac18 <lv_init+0x18>
        LV_LOG_WARN("lv_init: already inited");
   1ac08:	4b13      	ldr	r3, [pc, #76]	; (1ac58 <lv_init+0x58>)
   1ac0a:	4914      	ldr	r1, [pc, #80]	; (1ac5c <lv_init+0x5c>)
   1ac0c:	2253      	movs	r2, #83	; 0x53
   1ac0e:	2002      	movs	r0, #2
    lv_img_decoder_init();
    lv_img_cache_set_size(LV_IMG_CACHE_DEF_SIZE);

    lv_initialized = true;
    LV_LOG_INFO("lv_init ready");
}
   1ac10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LV_LOG_INFO("lv_init ready");
   1ac14:	f002 ba20 	b.w	1d058 <lv_log_add>
    lv_mem_init();
   1ac18:	f00c fafa 	bl	27210 <lv_mem_init>
    lv_task_core_init();
   1ac1c:	f001 ff1a 	bl	1ca54 <lv_task_core_init>
    lv_style_init();
   1ac20:	f000 fbd2 	bl	1b3c8 <lv_style_init>
    lv_refr_init();
   1ac24:	f00b f817 	bl	25c56 <lv_refr_init>
    lv_ll_init(&LV_GC_ROOT(_lv_disp_ll), sizeof(lv_disp_t));
   1ac28:	f44f 71b4 	mov.w	r1, #360	; 0x168
   1ac2c:	480c      	ldr	r0, [pc, #48]	; (1ac60 <lv_init+0x60>)
   1ac2e:	f00c fafd 	bl	2722c <lv_ll_init>
    lv_ll_init(&LV_GC_ROOT(_lv_indev_ll), sizeof(lv_indev_t));
   1ac32:	2160      	movs	r1, #96	; 0x60
   1ac34:	480b      	ldr	r0, [pc, #44]	; (1ac64 <lv_init+0x64>)
   1ac36:	f00c faf9 	bl	2722c <lv_ll_init>
    lv_indev_init();
   1ac3a:	f00a fc5d 	bl	254f8 <lv_indev_init>
    lv_img_decoder_init();
   1ac3e:	f001 fd55 	bl	1c6ec <lv_img_decoder_init>
    lv_img_cache_set_size(LV_IMG_CACHE_DEF_SIZE);
   1ac42:	2001      	movs	r0, #1
   1ac44:	f001 fe44 	bl	1c8d0 <lv_img_cache_set_size>
    lv_initialized = true;
   1ac48:	2001      	movs	r0, #1
   1ac4a:	7020      	strb	r0, [r4, #0]
    LV_LOG_INFO("lv_init ready");
   1ac4c:	4b06      	ldr	r3, [pc, #24]	; (1ac68 <lv_init+0x68>)
   1ac4e:	4903      	ldr	r1, [pc, #12]	; (1ac5c <lv_init+0x5c>)
   1ac50:	2279      	movs	r2, #121	; 0x79
   1ac52:	e7dd      	b.n	1ac10 <lv_init+0x10>
   1ac54:	2000abd4 	.word	0x2000abd4
   1ac58:	00065482 	.word	0x00065482
   1ac5c:	0006549a 	.word	0x0006549a
   1ac60:	20001ec4 	.word	0x20001ec4
   1ac64:	20001ee4 	.word	0x20001ee4
   1ac68:	000654cf 	.word	0x000654cf

0001ac6c <lv_obj_get_disp>:
 * Get the display of an object
 * @param scr pointer to an object
 * @return pointer the object's display
 */
lv_disp_t * lv_obj_get_disp(const lv_obj_t * obj)
{
   1ac6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);

    const lv_obj_t * scr;

    if(obj->par == NULL)
   1ac6e:	6803      	ldr	r3, [r0, #0]
{
   1ac70:	4605      	mov	r5, r0
    if(obj->par == NULL)
   1ac72:	b97b      	cbnz	r3, 1ac94 <lv_obj_get_disp+0x28>
        scr = obj; /*`obj` is a screen*/
    else
        scr = lv_obj_get_screen(obj); /*get the screen of `obj`*/

    lv_disp_t * d;
    LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d)
   1ac74:	4813      	ldr	r0, [pc, #76]	; (1acc4 <lv_obj_get_disp+0x58>)
   1ac76:	4f13      	ldr	r7, [pc, #76]	; (1acc4 <lv_obj_get_disp+0x58>)
   1ac78:	f00c fb18 	bl	272ac <lv_ll_get_head>
   1ac7c:	4604      	mov	r4, r0
   1ac7e:	b96c      	cbnz	r4, 1ac9c <lv_obj_get_disp+0x30>
        {
            if(s == scr) return d;
        }
    }

    LV_LOG_WARN("lv_scr_get_disp: screen not found")
   1ac80:	4b11      	ldr	r3, [pc, #68]	; (1acc8 <lv_obj_get_disp+0x5c>)
   1ac82:	4912      	ldr	r1, [pc, #72]	; (1accc <lv_obj_get_disp+0x60>)
   1ac84:	f240 6267 	movw	r2, #1639	; 0x667
   1ac88:	2002      	movs	r0, #2
   1ac8a:	f002 f9e5 	bl	1d058 <lv_log_add>
    return NULL;
}
   1ac8e:	4620      	mov	r0, r4
   1ac90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    } while(par != NULL);
   1ac92:	461d      	mov	r5, r3
 */
lv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)
{
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);

    return obj->par;
   1ac94:	682b      	ldr	r3, [r5, #0]
    } while(par != NULL);
   1ac96:	2b00      	cmp	r3, #0
   1ac98:	d1fb      	bne.n	1ac92 <lv_obj_get_disp+0x26>
   1ac9a:	e7eb      	b.n	1ac74 <lv_obj_get_disp+0x8>
        LV_LL_READ(d->scr_ll, s)
   1ac9c:	f104 0628 	add.w	r6, r4, #40	; 0x28
   1aca0:	4630      	mov	r0, r6
   1aca2:	f00c fb03 	bl	272ac <lv_ll_get_head>
   1aca6:	b928      	cbnz	r0, 1acb4 <lv_obj_get_disp+0x48>
    LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d)
   1aca8:	4621      	mov	r1, r4
   1acaa:	4638      	mov	r0, r7
   1acac:	f00c fb04 	bl	272b8 <lv_ll_get_next>
   1acb0:	4604      	mov	r4, r0
   1acb2:	e7e4      	b.n	1ac7e <lv_obj_get_disp+0x12>
            if(s == scr) return d;
   1acb4:	4285      	cmp	r5, r0
   1acb6:	d0ea      	beq.n	1ac8e <lv_obj_get_disp+0x22>
        LV_LL_READ(d->scr_ll, s)
   1acb8:	4601      	mov	r1, r0
   1acba:	4630      	mov	r0, r6
   1acbc:	f00c fafc 	bl	272b8 <lv_ll_get_next>
   1acc0:	e7f1      	b.n	1aca6 <lv_obj_get_disp+0x3a>
   1acc2:	bf00      	nop
   1acc4:	20001ec4 	.word	0x20001ec4
   1acc8:	00065555 	.word	0x00065555
   1accc:	0006549a 	.word	0x0006549a

0001acd0 <lv_obj_create>:
{
   1acd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1acd2:	460d      	mov	r5, r1
    if(parent == NULL) {
   1acd4:	4606      	mov	r6, r0
   1acd6:	2800      	cmp	r0, #0
   1acd8:	f040 80cd 	bne.w	1ae76 <lv_obj_create+0x1a6>
        lv_disp_t * disp = lv_disp_get_default();
   1acdc:	f001 fe8a 	bl	1c9f4 <lv_disp_get_default>
        if(!disp) {
   1ace0:	4604      	mov	r4, r0
   1ace2:	b938      	cbnz	r0, 1acf4 <lv_obj_create+0x24>
            LV_LOG_WARN("lv_obj_create: not display created to so far. No place to assign the new screen");
   1ace4:	4b80      	ldr	r3, [pc, #512]	; (1aee8 <lv_obj_create+0x218>)
   1ace6:	4981      	ldr	r1, [pc, #516]	; (1aeec <lv_obj_create+0x21c>)
   1ace8:	2290      	movs	r2, #144	; 0x90
   1acea:	2002      	movs	r0, #2
   1acec:	f002 f9b4 	bl	1d058 <lv_log_add>
}
   1acf0:	4620      	mov	r0, r4
   1acf2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        new_obj = lv_ll_ins_head(&disp->scr_ll);
   1acf4:	3028      	adds	r0, #40	; 0x28
   1acf6:	f00c faa3 	bl	27240 <lv_ll_ins_head>
        if(new_obj == NULL) return NULL;
   1acfa:	4604      	mov	r4, r0
   1acfc:	b908      	cbnz	r0, 1ad02 <lv_obj_create+0x32>
   1acfe:	2400      	movs	r4, #0
   1ad00:	e7f6      	b.n	1acf0 <lv_obj_create+0x20>
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
   1ad02:	2138      	movs	r1, #56	; 0x38
        new_obj->par = NULL; /*Screens has no a parent*/
   1ad04:	f840 6b04 	str.w	r6, [r0], #4
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
   1ad08:	f00c fa90 	bl	2722c <lv_ll_init>
        new_obj->signal_cb = lv_obj_signal;
   1ad0c:	4b78      	ldr	r3, [pc, #480]	; (1aef0 <lv_obj_create+0x220>)
   1ad0e:	61e3      	str	r3, [r4, #28]
        new_obj->design_cb = lv_obj_design;
   1ad10:	4b78      	ldr	r3, [pc, #480]	; (1aef4 <lv_obj_create+0x224>)
   1ad12:	6223      	str	r3, [r4, #32]
        new_obj->event_cb = NULL;
   1ad14:	61a6      	str	r6, [r4, #24]
        new_obj->coords.x1    = 0;
   1ad16:	6126      	str	r6, [r4, #16]
        new_obj->coords.x2    = lv_disp_get_hor_res(NULL) - 1;
   1ad18:	4630      	mov	r0, r6
   1ad1a:	f001 fe71 	bl	1ca00 <lv_disp_get_hor_res>
   1ad1e:	3801      	subs	r0, #1
   1ad20:	82a0      	strh	r0, [r4, #20]
        new_obj->coords.y2    = lv_disp_get_ver_res(NULL) - 1;
   1ad22:	4630      	mov	r0, r6
   1ad24:	f001 fe7c 	bl	1ca20 <lv_disp_get_ver_res>
   1ad28:	3801      	subs	r0, #1
   1ad2a:	82e0      	strh	r0, [r4, #22]
        new_obj->ext_draw_pad = 0;
   1ad2c:	8626      	strh	r6, [r4, #48]	; 0x30
        lv_theme_t * th = lv_theme_get_current();
   1ad2e:	f002 fef7 	bl	1db20 <lv_theme_get_current>
        if(th) {
   1ad32:	2800      	cmp	r0, #0
   1ad34:	f000 809d 	beq.w	1ae72 <lv_obj_create+0x1a2>
            new_obj->style_p = th->style.scr;
   1ad38:	6803      	ldr	r3, [r0, #0]
   1ad3a:	62a3      	str	r3, [r4, #40]	; 0x28
        new_obj->click        = 0;
   1ad3c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
        LV_LOG_INFO("Screen create ready");
   1ad3e:	496b      	ldr	r1, [pc, #428]	; (1aeec <lv_obj_create+0x21c>)
        new_obj->click        = 0;
   1ad40:	f403 4303 	and.w	r3, r3, #33536	; 0x8300
__ssp_bos_icheck3(memset, void *, int)
   1ad44:	2200      	movs	r2, #0
   1ad46:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
   1ad4a:	6362      	str	r2, [r4, #52]	; 0x34
   1ad4c:	62e3      	str	r3, [r4, #44]	; 0x2c
        new_obj->ext_attr = NULL;
   1ad4e:	6262      	str	r2, [r4, #36]	; 0x24
        LV_LOG_INFO("Screen create ready");
   1ad50:	4b69      	ldr	r3, [pc, #420]	; (1aef8 <lv_obj_create+0x228>)
   1ad52:	22de      	movs	r2, #222	; 0xde
   1ad54:	2001      	movs	r0, #1
   1ad56:	f002 f97f 	bl	1d058 <lv_log_add>
    if(copy != NULL) {
   1ad5a:	2d00      	cmp	r5, #0
   1ad5c:	d07d      	beq.n	1ae5a <lv_obj_create+0x18a>
        lv_area_copy(&new_obj->coords, &copy->coords);
   1ad5e:	f105 0110 	add.w	r1, r5, #16
   1ad62:	f104 0010 	add.w	r0, r4, #16
   1ad66:	f00a fbe9 	bl	2553c <lv_area_copy>
        new_obj->ext_draw_pad = copy->ext_draw_pad;
   1ad6a:	f9b5 3030 	ldrsh.w	r3, [r5, #48]	; 0x30
   1ad6e:	8623      	strh	r3, [r4, #48]	; 0x30
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1ad70:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   1ad72:	6363      	str	r3, [r4, #52]	; 0x34
        new_obj->event_cb = copy->event_cb;
   1ad74:	69ab      	ldr	r3, [r5, #24]
        new_obj->click        = copy->click;
   1ad76:	f895 202c 	ldrb.w	r2, [r5, #44]	; 0x2c
        new_obj->event_cb = copy->event_cb;
   1ad7a:	61a3      	str	r3, [r4, #24]
        new_obj->click        = copy->click;
   1ad7c:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
   1ad80:	f362 0300 	bfi	r3, r2, #0, #1
   1ad84:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
        new_obj->drag         = copy->drag;
   1ad88:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
   1ad8c:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
   1ad90:	f3c3 0340 	ubfx	r3, r3, #1, #1
   1ad94:	f363 0241 	bfi	r2, r3, #1, #1
   1ad98:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->drag_dir     = copy->drag_dir;
   1ad9c:	f895 202d 	ldrb.w	r2, [r5, #45]	; 0x2d
   1ada0:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
   1ada4:	f362 0301 	bfi	r3, r2, #0, #2
   1ada8:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
        new_obj->drag_throw   = copy->drag_throw;
   1adac:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
   1adb0:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
   1adb4:	f3c3 0380 	ubfx	r3, r3, #2, #1
   1adb8:	f363 0282 	bfi	r2, r3, #2, #1
   1adbc:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->drag_parent  = copy->drag_parent;
   1adc0:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
   1adc4:	b2d2      	uxtb	r2, r2
   1adc6:	f3c3 03c0 	ubfx	r3, r3, #3, #1
   1adca:	f363 02c3 	bfi	r2, r3, #3, #1
   1adce:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->hidden       = copy->hidden;
   1add2:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
   1add6:	b2d2      	uxtb	r2, r2
   1add8:	f3c3 1300 	ubfx	r3, r3, #4, #1
   1addc:	f363 1204 	bfi	r2, r3, #4, #1
   1ade0:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->top          = copy->top;
   1ade4:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
   1ade8:	b2d2      	uxtb	r2, r2
   1adea:	f3c3 1340 	ubfx	r3, r3, #5, #1
   1adee:	f363 1245 	bfi	r2, r3, #5, #1
   1adf2:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->parent_event = copy->parent_event;
   1adf6:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
   1adfa:	b2d2      	uxtb	r2, r2
   1adfc:	09db      	lsrs	r3, r3, #7
   1adfe:	f363 12c7 	bfi	r2, r3, #7, #1
   1ae02:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->opa_scale_en = copy->opa_scale_en;
   1ae06:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
   1ae0a:	b2d2      	uxtb	r2, r2
   1ae0c:	f3c3 1380 	ubfx	r3, r3, #6, #1
   1ae10:	f363 1286 	bfi	r2, r3, #6, #1
   1ae14:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
        new_obj->protect      = copy->protect;
   1ae18:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
   1ae1c:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
        new_obj->opa_scale    = copy->opa_scale;
   1ae20:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
   1ae24:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
        new_obj->style_p = copy->style_p;
   1ae28:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1ae2a:	62a3      	str	r3, [r4, #40]	; 0x28
        if(lv_obj_get_parent(copy) != NULL && parent != NULL) {
   1ae2c:	682b      	ldr	r3, [r5, #0]
   1ae2e:	2b00      	cmp	r3, #0
   1ae30:	d056      	beq.n	1aee0 <lv_obj_create+0x210>
   1ae32:	2e00      	cmp	r6, #0
   1ae34:	d054      	beq.n	1aee0 <lv_obj_create+0x210>
            lv_obj_set_pos(new_obj, lv_obj_get_x(copy), lv_obj_get_y(copy));
   1ae36:	4628      	mov	r0, r5
   1ae38:	f00a fcbc 	bl	257b4 <lv_obj_get_x>
   1ae3c:	4601      	mov	r1, r0
   1ae3e:	4628      	mov	r0, r5
   1ae40:	f00a fcc0 	bl	257c4 <lv_obj_get_y>
   1ae44:	4602      	mov	r2, r0
            lv_obj_set_pos(new_obj, 0, 0);
   1ae46:	4620      	mov	r0, r4
   1ae48:	f00a fbde 	bl	25608 <lv_obj_set_pos>
        LV_LOG_INFO("Object create ready");
   1ae4c:	4b2b      	ldr	r3, [pc, #172]	; (1aefc <lv_obj_create+0x22c>)
   1ae4e:	4927      	ldr	r1, [pc, #156]	; (1aeec <lv_obj_create+0x21c>)
   1ae50:	f240 127d 	movw	r2, #381	; 0x17d
   1ae54:	2001      	movs	r0, #1
   1ae56:	f002 f8ff 	bl	1d058 <lv_log_add>
    if(parent != NULL) {
   1ae5a:	2e00      	cmp	r6, #0
   1ae5c:	f43f af48 	beq.w	1acf0 <lv_obj_create+0x20>
        parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, new_obj);
   1ae60:	69f3      	ldr	r3, [r6, #28]
   1ae62:	4622      	mov	r2, r4
   1ae64:	2101      	movs	r1, #1
   1ae66:	4630      	mov	r0, r6
   1ae68:	4798      	blx	r3
        lv_obj_invalidate(new_obj);
   1ae6a:	4620      	mov	r0, r4
   1ae6c:	f00a fb7d 	bl	2556a <lv_obj_invalidate>
   1ae70:	e73e      	b.n	1acf0 <lv_obj_create+0x20>
            new_obj->style_p = &lv_style_scr;
   1ae72:	4b23      	ldr	r3, [pc, #140]	; (1af00 <lv_obj_create+0x230>)
   1ae74:	e761      	b.n	1ad3a <lv_obj_create+0x6a>
        new_obj = lv_ll_ins_head(&parent->child_ll);
   1ae76:	3004      	adds	r0, #4
   1ae78:	f00c f9e2 	bl	27240 <lv_ll_ins_head>
        if(new_obj == NULL) return NULL;
   1ae7c:	4604      	mov	r4, r0
   1ae7e:	2800      	cmp	r0, #0
   1ae80:	f43f af3d 	beq.w	1acfe <lv_obj_create+0x2e>
        new_obj->par = parent; /*Set the parent*/
   1ae84:	f840 6b04 	str.w	r6, [r0], #4
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
   1ae88:	2138      	movs	r1, #56	; 0x38
   1ae8a:	f00c f9cf 	bl	2722c <lv_ll_init>
        new_obj->signal_cb = lv_obj_signal;
   1ae8e:	4b18      	ldr	r3, [pc, #96]	; (1aef0 <lv_obj_create+0x220>)
   1ae90:	61e3      	str	r3, [r4, #28]
        new_obj->design_cb = lv_obj_design;
   1ae92:	4b18      	ldr	r3, [pc, #96]	; (1aef4 <lv_obj_create+0x224>)
   1ae94:	6223      	str	r3, [r4, #32]
        new_obj->base_dir     = LV_BIDI_DIR_LTR;
   1ae96:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
        new_obj->event_cb = NULL;
   1ae9a:	2700      	movs	r7, #0
        new_obj->base_dir     = LV_BIDI_DIR_LTR;
   1ae9c:	f367 0383 	bfi	r3, r7, #2, #2
   1aea0:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
        new_obj->coords.y1    = parent->coords.y1;
   1aea4:	f9b6 3012 	ldrsh.w	r3, [r6, #18]
   1aea8:	8263      	strh	r3, [r4, #18]
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
   1aeaa:	8a73      	ldrh	r3, [r6, #18]
        new_obj->event_cb = NULL;
   1aeac:	61a7      	str	r7, [r4, #24]
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
   1aeae:	3342      	adds	r3, #66	; 0x42
   1aeb0:	82e3      	strh	r3, [r4, #22]
            new_obj->coords.x1    = parent->coords.x1;
   1aeb2:	f9b6 3010 	ldrsh.w	r3, [r6, #16]
   1aeb6:	8223      	strh	r3, [r4, #16]
            new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;
   1aeb8:	8a33      	ldrh	r3, [r6, #16]
        new_obj->ext_draw_pad = 0;
   1aeba:	8627      	strh	r7, [r4, #48]	; 0x30
            new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;
   1aebc:	3364      	adds	r3, #100	; 0x64
   1aebe:	82a3      	strh	r3, [r4, #20]
        lv_theme_t * th = lv_theme_get_current();
   1aec0:	f002 fe2e 	bl	1db20 <lv_theme_get_current>
        if(th) {
   1aec4:	b150      	cbz	r0, 1aedc <lv_obj_create+0x20c>
            new_obj->style_p = th->style.panel;
   1aec6:	6883      	ldr	r3, [r0, #8]
   1aec8:	62a3      	str	r3, [r4, #40]	; 0x28
        new_obj->click        = 1;
   1aeca:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
__ssp_bos_icheck3(memset, void *, int)
   1aecc:	6367      	str	r7, [r4, #52]	; 0x34
   1aece:	f403 420c 	and.w	r2, r3, #35840	; 0x8c00
   1aed2:	4b0c      	ldr	r3, [pc, #48]	; (1af04 <lv_obj_create+0x234>)
        new_obj->ext_attr = NULL;
   1aed4:	6267      	str	r7, [r4, #36]	; 0x24
        new_obj->click        = 1;
   1aed6:	4313      	orrs	r3, r2
   1aed8:	62e3      	str	r3, [r4, #44]	; 0x2c
        new_obj->ext_attr = NULL;
   1aeda:	e73e      	b.n	1ad5a <lv_obj_create+0x8a>
            new_obj->style_p = &lv_style_plain_color;
   1aedc:	4b0a      	ldr	r3, [pc, #40]	; (1af08 <lv_obj_create+0x238>)
   1aede:	e7f3      	b.n	1aec8 <lv_obj_create+0x1f8>
            lv_obj_set_pos(new_obj, 0, 0);
   1aee0:	2200      	movs	r2, #0
   1aee2:	4611      	mov	r1, r2
   1aee4:	e7af      	b.n	1ae46 <lv_obj_create+0x176>
   1aee6:	bf00      	nop
   1aee8:	000654dd 	.word	0x000654dd
   1aeec:	0006549a 	.word	0x0006549a
   1aef0:	0001af2d 	.word	0x0001af2d
   1aef4:	00025a49 	.word	0x00025a49
   1aef8:	0006552d 	.word	0x0006552d
   1aefc:	00065541 	.word	0x00065541
   1af00:	20001d68 	.word	0x20001d68
   1af04:	ff000301 	.word	0xff000301
   1af08:	20001c78 	.word	0x20001c78

0001af0c <lv_obj_get_style>:
 */
const lv_style_t * lv_obj_get_style(const lv_obj_t * obj)
{
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);

    const lv_style_t * style_act = obj->style_p;
   1af0c:	6a83      	ldr	r3, [r0, #40]	; 0x28
    if(style_act == NULL) {
   1af0e:	b913      	cbnz	r3, 1af16 <lv_obj_get_style+0xa>
        lv_obj_t * par = obj->par;
   1af10:	6802      	ldr	r2, [r0, #0]

        while(par) {
   1af12:	b912      	cbnz	r2, 1af1a <lv_obj_get_style+0xe>
            style_act = lv_group_mod_style(obj->group_p, style_act);
        }
    }
#endif

    if(style_act == NULL) style_act = &lv_style_plain;
   1af14:	4b04      	ldr	r3, [pc, #16]	; (1af28 <lv_obj_get_style+0x1c>)

    return style_act;
}
   1af16:	4618      	mov	r0, r3
   1af18:	4770      	bx	lr
            if(par->style_p) {
   1af1a:	6a93      	ldr	r3, [r2, #40]	; 0x28
   1af1c:	b113      	cbz	r3, 1af24 <lv_obj_get_style+0x18>
                if(par->style_p->glass == 0) {
   1af1e:	7819      	ldrb	r1, [r3, #0]
   1af20:	07c9      	lsls	r1, r1, #31
   1af22:	d5f8      	bpl.n	1af16 <lv_obj_get_style+0xa>
            par = par->par;
   1af24:	6812      	ldr	r2, [r2, #0]
   1af26:	e7f4      	b.n	1af12 <lv_obj_get_style+0x6>
   1af28:	20001c28 	.word	0x20001c28

0001af2c <lv_obj_signal>:
 * @param param parameter for the signal (depends on signal type)
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_obj_signal(lv_obj_t * obj, lv_signal_t sign, void * param)
{
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
   1af2c:	2907      	cmp	r1, #7
{
   1af2e:	b510      	push	{r4, lr}
   1af30:	4604      	mov	r4, r0
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
   1af32:	d105      	bne.n	1af40 <lv_obj_signal+0x14>
   1af34:	490f      	ldr	r1, [pc, #60]	; (1af74 <lv_obj_signal+0x48>)
   1af36:	4610      	mov	r0, r2
        if(style->body.shadow.width > obj->ext_draw_pad) obj->ext_draw_pad = style->body.shadow.width;
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
        lv_obj_refresh_ext_draw_pad(obj);
    }
    return res;
}
   1af38:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
   1af3c:	f00a bdd8 	b.w	25af0 <lv_obj_handle_get_type_signal>
    if(sign == LV_SIGNAL_CHILD_CHG) {
   1af40:	2901      	cmp	r1, #1
   1af42:	d105      	bne.n	1af50 <lv_obj_signal+0x24>
    return (obj->protect & prot) == 0 ? false : true;
   1af44:	f890 002e 	ldrb.w	r0, [r0, #46]	; 0x2e
   1af48:	43c0      	mvns	r0, r0
   1af4a:	f000 0001 	and.w	r0, r0, #1
}
   1af4e:	bd10      	pop	{r4, pc}
    } else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
   1af50:	2906      	cmp	r1, #6
   1af52:	d10a      	bne.n	1af6a <lv_obj_signal+0x3e>
        const lv_style_t * style = lv_obj_get_style(obj);
   1af54:	f7ff ffda 	bl	1af0c <lv_obj_get_style>
        if(style->body.shadow.width > obj->ext_draw_pad) obj->ext_draw_pad = style->body.shadow.width;
   1af58:	f9b4 2030 	ldrsh.w	r2, [r4, #48]	; 0x30
   1af5c:	f9b0 301c 	ldrsh.w	r3, [r0, #28]
   1af60:	429a      	cmp	r2, r3
   1af62:	da00      	bge.n	1af66 <lv_obj_signal+0x3a>
   1af64:	8623      	strh	r3, [r4, #48]	; 0x30
    lv_res_t res = LV_RES_OK;
   1af66:	2001      	movs	r0, #1
   1af68:	e7f1      	b.n	1af4e <lv_obj_signal+0x22>
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
   1af6a:	2904      	cmp	r1, #4
   1af6c:	d1fb      	bne.n	1af66 <lv_obj_signal+0x3a>
        lv_obj_refresh_ext_draw_pad(obj);
   1af6e:	f00a fb90 	bl	25692 <lv_obj_refresh_ext_draw_pad>
   1af72:	e7f8      	b.n	1af66 <lv_obj_signal+0x3a>
   1af74:	00065577 	.word	0x00065577

0001af78 <lv_refr_vdb_flush>:

/**
 * Flush the content of the VDB
 */
static void lv_refr_vdb_flush(void)
{
   1af78:	b538      	push	{r3, r4, r5, lr}
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
   1af7a:	4d10      	ldr	r5, [pc, #64]	; (1afbc <lv_refr_vdb_flush+0x44>)
   1af7c:	6828      	ldr	r0, [r5, #0]
   1af7e:	f00c f842 	bl	27006 <lv_disp_get_buf>
   1af82:	4604      	mov	r4, r0

    /*In double buffered mode wait until the other buffer is flushed before flushing the current
     * one*/
    if(lv_disp_is_double_buf(disp_refr)) {
   1af84:	6828      	ldr	r0, [r5, #0]
   1af86:	f00c f840 	bl	2700a <lv_disp_is_double_buf>
   1af8a:	b110      	cbz	r0, 1af92 <lv_refr_vdb_flush+0x1a>
        while(vdb->flushing)
   1af8c:	69a3      	ldr	r3, [r4, #24]
   1af8e:	07db      	lsls	r3, r3, #31
   1af90:	d4fc      	bmi.n	1af8c <lv_refr_vdb_flush+0x14>
            ;
    }

    vdb->flushing = 1;
   1af92:	7e23      	ldrb	r3, [r4, #24]
    return disp_refr;
   1af94:	6828      	ldr	r0, [r5, #0]
    vdb->flushing = 1;
   1af96:	f043 0301 	orr.w	r3, r3, #1
   1af9a:	7623      	strb	r3, [r4, #24]

    /*Flush the rendered content to the display*/
    lv_disp_t * disp = lv_refr_get_disp_refreshing();
    if(disp->driver.flush_cb) disp->driver.flush_cb(&disp->driver, &vdb->area, vdb->buf_act);
   1af9c:	68c3      	ldr	r3, [r0, #12]
   1af9e:	b11b      	cbz	r3, 1afa8 <lv_refr_vdb_flush+0x30>
   1afa0:	68a2      	ldr	r2, [r4, #8]
   1afa2:	f104 0110 	add.w	r1, r4, #16
   1afa6:	4798      	blx	r3

    if(vdb->buf1 && vdb->buf2) {
   1afa8:	6823      	ldr	r3, [r4, #0]
   1afaa:	b133      	cbz	r3, 1afba <lv_refr_vdb_flush+0x42>
   1afac:	6862      	ldr	r2, [r4, #4]
   1afae:	b122      	cbz	r2, 1afba <lv_refr_vdb_flush+0x42>
        if(vdb->buf_act == vdb->buf1)
   1afb0:	68a1      	ldr	r1, [r4, #8]
            vdb->buf_act = vdb->buf2;
   1afb2:	428b      	cmp	r3, r1
   1afb4:	bf08      	it	eq
   1afb6:	4613      	moveq	r3, r2
   1afb8:	60a3      	str	r3, [r4, #8]
        else
            vdb->buf_act = vdb->buf1;
    }
}
   1afba:	bd38      	pop	{r3, r4, r5, pc}
   1afbc:	20001a90 	.word	0x20001a90

0001afc0 <lv_refr_obj_and_children>:
{
   1afc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1afc2:	460e      	mov	r6, r1
    if(top_p == NULL) top_p = lv_disp_get_scr_act(disp_refr);
   1afc4:	4605      	mov	r5, r0
   1afc6:	b920      	cbnz	r0, 1afd2 <lv_refr_obj_and_children+0x12>
   1afc8:	4b12      	ldr	r3, [pc, #72]	; (1b014 <lv_refr_obj_and_children+0x54>)
   1afca:	6818      	ldr	r0, [r3, #0]
   1afcc:	f7ff fdd6 	bl	1ab7c <lv_disp_get_scr_act>
   1afd0:	4605      	mov	r5, r0
    lv_refr_obj(top_p, mask_p);
   1afd2:	4628      	mov	r0, r5
   1afd4:	4631      	mov	r1, r6
   1afd6:	f00a fdd1 	bl	25b7c <lv_refr_obj>
    par = lv_obj_get_parent(top_p);
   1afda:	4628      	mov	r0, r5
   1afdc:	f00a fbb6 	bl	2574c <lv_obj_get_parent>
        par = lv_obj_get_parent(par);
   1afe0:	4604      	mov	r4, r0
    while(par != NULL) {
   1afe2:	b900      	cbnz	r0, 1afe6 <lv_refr_obj_and_children+0x26>
}
   1afe4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        lv_obj_t * i = lv_ll_get_prev(&(par->child_ll), border_p);
   1afe6:	1d27      	adds	r7, r4, #4
            i = lv_ll_get_prev(&(par->child_ll), i);
   1afe8:	4629      	mov	r1, r5
   1afea:	4638      	mov	r0, r7
   1afec:	f00c f969 	bl	272c2 <lv_ll_get_prev>
   1aff0:	4605      	mov	r5, r0
        while(i != NULL) {
   1aff2:	b948      	cbnz	r0, 1b008 <lv_refr_obj_and_children+0x48>
        par->design_cb(par, mask_p, LV_DESIGN_DRAW_POST);
   1aff4:	6a23      	ldr	r3, [r4, #32]
   1aff6:	2201      	movs	r2, #1
   1aff8:	4631      	mov	r1, r6
   1affa:	4620      	mov	r0, r4
   1affc:	4798      	blx	r3
        par = lv_obj_get_parent(par);
   1affe:	4620      	mov	r0, r4
   1b000:	f00a fba4 	bl	2574c <lv_obj_get_parent>
   1b004:	4625      	mov	r5, r4
   1b006:	e7eb      	b.n	1afe0 <lv_refr_obj_and_children+0x20>
            lv_refr_obj(i, mask_p);
   1b008:	4631      	mov	r1, r6
   1b00a:	4628      	mov	r0, r5
   1b00c:	f00a fdb6 	bl	25b7c <lv_refr_obj>
   1b010:	e7ea      	b.n	1afe8 <lv_refr_obj_and_children+0x28>
   1b012:	bf00      	nop
   1b014:	20001a90 	.word	0x20001a90

0001b018 <lv_refr_area_part>:
{
   1b018:	b573      	push	{r0, r1, r4, r5, r6, lr}
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
   1b01a:	4c18      	ldr	r4, [pc, #96]	; (1b07c <lv_refr_area_part+0x64>)
{
   1b01c:	4606      	mov	r6, r0
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
   1b01e:	6820      	ldr	r0, [r4, #0]
   1b020:	f00b fff1 	bl	27006 <lv_disp_get_buf>
   1b024:	4605      	mov	r5, r0
    if(lv_disp_is_double_buf(disp_refr) == false) {
   1b026:	6820      	ldr	r0, [r4, #0]
   1b028:	f00b ffef 	bl	2700a <lv_disp_is_double_buf>
   1b02c:	b910      	cbnz	r0, 1b034 <lv_refr_area_part+0x1c>
        while(vdb->flushing)
   1b02e:	69ab      	ldr	r3, [r5, #24]
   1b030:	07db      	lsls	r3, r3, #31
   1b032:	d4fc      	bmi.n	1b02e <lv_refr_area_part+0x16>
    lv_area_intersect(&start_mask, area_p, &vdb->area);
   1b034:	f105 0210 	add.w	r2, r5, #16
   1b038:	4631      	mov	r1, r6
   1b03a:	4668      	mov	r0, sp
   1b03c:	f00c f845 	bl	270ca <lv_area_intersect>
    top_p = lv_refr_get_top_obj(&start_mask, lv_disp_get_scr_act(disp_refr));
   1b040:	6820      	ldr	r0, [r4, #0]
   1b042:	f7ff fd9b 	bl	1ab7c <lv_disp_get_scr_act>
   1b046:	4601      	mov	r1, r0
   1b048:	4668      	mov	r0, sp
   1b04a:	f00a fd5f 	bl	25b0c <lv_refr_get_top_obj>
    lv_refr_obj_and_children(top_p, &start_mask);
   1b04e:	4669      	mov	r1, sp
   1b050:	f7ff ffb6 	bl	1afc0 <lv_refr_obj_and_children>
    lv_refr_obj_and_children(lv_disp_get_layer_top(disp_refr), &start_mask);
   1b054:	6820      	ldr	r0, [r4, #0]
   1b056:	f7ff fda7 	bl	1aba8 <lv_disp_get_layer_top>
   1b05a:	4669      	mov	r1, sp
   1b05c:	f7ff ffb0 	bl	1afc0 <lv_refr_obj_and_children>
    lv_refr_obj_and_children(lv_disp_get_layer_sys(disp_refr), &start_mask);
   1b060:	6820      	ldr	r0, [r4, #0]
   1b062:	f7ff fdb7 	bl	1abd4 <lv_disp_get_layer_sys>
   1b066:	4669      	mov	r1, sp
   1b068:	f7ff ffaa 	bl	1afc0 <lv_refr_obj_and_children>
    if(lv_disp_is_true_double_buf(disp_refr) == false) {
   1b06c:	6820      	ldr	r0, [r4, #0]
   1b06e:	f00b ffd4 	bl	2701a <lv_disp_is_true_double_buf>
   1b072:	b908      	cbnz	r0, 1b078 <lv_refr_area_part+0x60>
        lv_refr_vdb_flush();
   1b074:	f7ff ff80 	bl	1af78 <lv_refr_vdb_flush>
}
   1b078:	b002      	add	sp, #8
   1b07a:	bd70      	pop	{r4, r5, r6, pc}
   1b07c:	20001a90 	.word	0x20001a90

0001b080 <lv_refr_get_disp_refreshing>:
}
   1b080:	4b01      	ldr	r3, [pc, #4]	; (1b088 <lv_refr_get_disp_refreshing+0x8>)
   1b082:	6818      	ldr	r0, [r3, #0]
   1b084:	4770      	bx	lr
   1b086:	bf00      	nop
   1b088:	20001a90 	.word	0x20001a90

0001b08c <lv_disp_refr_task>:
{
   1b08c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b090:	b089      	sub	sp, #36	; 0x24
   1b092:	4605      	mov	r5, r0
    uint32_t start = lv_tick_get();
   1b094:	f00b ffd0 	bl	27038 <lv_tick_get>
    disp_refr = task->user_data;
   1b098:	4cc1      	ldr	r4, [pc, #772]	; (1b3a0 <lv_disp_refr_task+0x314>)
   1b09a:	68eb      	ldr	r3, [r5, #12]
    uint32_t start = lv_tick_get();
   1b09c:	9003      	str	r0, [sp, #12]
    disp_refr = task->user_data;
   1b09e:	6023      	str	r3, [r4, #0]
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
   1b0a0:	2600      	movs	r6, #0
                disp_refr->inv_area_joined[join_from] = 1;
   1b0a2:	f04f 0901 	mov.w	r9, #1
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
   1b0a6:	6823      	ldr	r3, [r4, #0]
   1b0a8:	f8b3 2160 	ldrh.w	r2, [r3, #352]	; 0x160
   1b0ac:	f3c2 0209 	ubfx	r2, r2, #0, #10
   1b0b0:	4296      	cmp	r6, r2
   1b0b2:	d32f      	bcc.n	1b114 <lv_disp_refr_task+0x88>
    px_num = 0;
   1b0b4:	4bbb      	ldr	r3, [pc, #748]	; (1b3a4 <lv_disp_refr_task+0x318>)
            if(disp_refr->driver.monitor_cb) px_num += lv_area_get_size(&disp_refr->inv_areas[i]);
   1b0b6:	9302      	str	r3, [sp, #8]
    px_num = 0;
   1b0b8:	2200      	movs	r2, #0
   1b0ba:	601a      	str	r2, [r3, #0]
    for(i = 0; i < disp_refr->inv_p; i++) {
   1b0bc:	4690      	mov	r8, r2
   1b0be:	6827      	ldr	r7, [r4, #0]
   1b0c0:	f8b7 3160 	ldrh.w	r3, [r7, #352]	; 0x160
   1b0c4:	f3c3 0209 	ubfx	r2, r3, #0, #10
   1b0c8:	4590      	cmp	r8, r2
   1b0ca:	d365      	bcc.n	1b198 <lv_disp_refr_task+0x10c>
    if(disp_refr->inv_p != 0) {
   1b0cc:	b1ea      	cbz	r2, 1b10a <lv_disp_refr_task+0x7e>
        if(lv_disp_is_true_double_buf(disp_refr)) {
   1b0ce:	4638      	mov	r0, r7
   1b0d0:	f00b ffa3 	bl	2701a <lv_disp_is_true_double_buf>
   1b0d4:	2800      	cmp	r0, #0
   1b0d6:	f040 8117 	bne.w	1b308 <lv_disp_refr_task+0x27c>
        memset(disp_refr->inv_areas, 0, sizeof(disp_refr->inv_areas));
   1b0da:	6824      	ldr	r4, [r4, #0]
   1b0dc:	f44f 7280 	mov.w	r2, #256	; 0x100
   1b0e0:	2100      	movs	r1, #0
   1b0e2:	f104 0040 	add.w	r0, r4, #64	; 0x40
   1b0e6:	f7e6 fda2 	bl	1c2e <memset>
   1b0ea:	2220      	movs	r2, #32
   1b0ec:	2100      	movs	r1, #0
   1b0ee:	f504 70a0 	add.w	r0, r4, #320	; 0x140
   1b0f2:	f7e6 fd9c 	bl	1c2e <memset>
        disp_refr->inv_p = 0;
   1b0f6:	f8b4 3160 	ldrh.w	r3, [r4, #352]	; 0x160
        if(disp_refr->driver.monitor_cb) {
   1b0fa:	69a5      	ldr	r5, [r4, #24]
        disp_refr->inv_p = 0;
   1b0fc:	f36f 0309 	bfc	r3, #0, #10
   1b100:	f8a4 3160 	strh.w	r3, [r4, #352]	; 0x160
        if(disp_refr->driver.monitor_cb) {
   1b104:	2d00      	cmp	r5, #0
   1b106:	f040 8153 	bne.w	1b3b0 <lv_disp_refr_task+0x324>
    lv_draw_free_buf();
   1b10a:	f000 fcf7 	bl	1bafc <lv_draw_free_buf>
}
   1b10e:	b009      	add	sp, #36	; 0x24
   1b110:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(disp_refr->inv_area_joined[join_in] != 0) continue;
   1b114:	4433      	add	r3, r6
   1b116:	f893 5140 	ldrb.w	r5, [r3, #320]	; 0x140
   1b11a:	b10d      	cbz	r5, 1b120 <lv_disp_refr_task+0x94>
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
   1b11c:	3601      	adds	r6, #1
   1b11e:	e7c2      	b.n	1b0a6 <lv_disp_refr_task+0x1a>
   1b120:	00f7      	lsls	r7, r6, #3
   1b122:	3740      	adds	r7, #64	; 0x40
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
   1b124:	6820      	ldr	r0, [r4, #0]
   1b126:	f8b0 3160 	ldrh.w	r3, [r0, #352]	; 0x160
   1b12a:	f3c3 0309 	ubfx	r3, r3, #0, #10
   1b12e:	429d      	cmp	r5, r3
   1b130:	d2f4      	bcs.n	1b11c <lv_disp_refr_task+0x90>
            if(disp_refr->inv_area_joined[join_from] != 0 || join_in == join_from) {
   1b132:	1943      	adds	r3, r0, r5
   1b134:	f893 3140 	ldrb.w	r3, [r3, #320]	; 0x140
   1b138:	bb63      	cbnz	r3, 1b194 <lv_disp_refr_task+0x108>
   1b13a:	42ae      	cmp	r6, r5
   1b13c:	d02a      	beq.n	1b194 <lv_disp_refr_task+0x108>
            if(lv_area_is_on(&disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]) == false) {
   1b13e:	ea4f 08c5 	mov.w	r8, r5, lsl #3
   1b142:	f108 0840 	add.w	r8, r8, #64	; 0x40
   1b146:	eb00 0108 	add.w	r1, r0, r8
   1b14a:	4438      	add	r0, r7
   1b14c:	f00c f809 	bl	27162 <lv_area_is_on>
   1b150:	b300      	cbz	r0, 1b194 <lv_disp_refr_task+0x108>
            lv_area_join(&joined_area, &disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]);
   1b152:	6821      	ldr	r1, [r4, #0]
   1b154:	a806      	add	r0, sp, #24
   1b156:	eb01 0208 	add.w	r2, r1, r8
   1b15a:	4439      	add	r1, r7
   1b15c:	f00b ffdf 	bl	2711e <lv_area_join>
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
   1b160:	a806      	add	r0, sp, #24
   1b162:	f00b ffa4 	bl	270ae <lv_area_get_size>
   1b166:	4683      	mov	fp, r0
   1b168:	6820      	ldr	r0, [r4, #0]
   1b16a:	4438      	add	r0, r7
   1b16c:	f00b ff9f 	bl	270ae <lv_area_get_size>
   1b170:	4682      	mov	sl, r0
                                                 lv_area_get_size(&disp_refr->inv_areas[join_from]))) {
   1b172:	6820      	ldr	r0, [r4, #0]
   1b174:	4440      	add	r0, r8
   1b176:	f00b ff9a 	bl	270ae <lv_area_get_size>
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
   1b17a:	4450      	add	r0, sl
   1b17c:	4583      	cmp	fp, r0
   1b17e:	d209      	bcs.n	1b194 <lv_disp_refr_task+0x108>
                lv_area_copy(&disp_refr->inv_areas[join_in], &joined_area);
   1b180:	f8d4 8000 	ldr.w	r8, [r4]
   1b184:	eb08 0007 	add.w	r0, r8, r7
                disp_refr->inv_area_joined[join_from] = 1;
   1b188:	44a8      	add	r8, r5
                lv_area_copy(&disp_refr->inv_areas[join_in], &joined_area);
   1b18a:	a906      	add	r1, sp, #24
   1b18c:	f00a fcf0 	bl	25b70 <lv_area_copy>
                disp_refr->inv_area_joined[join_from] = 1;
   1b190:	f888 9140 	strb.w	r9, [r8, #320]	; 0x140
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
   1b194:	3501      	adds	r5, #1
   1b196:	e7c5      	b.n	1b124 <lv_disp_refr_task+0x98>
        if(disp_refr->inv_area_joined[i] == 0) {
   1b198:	eb07 0308 	add.w	r3, r7, r8
   1b19c:	f893 6140 	ldrb.w	r6, [r3, #320]	; 0x140
   1b1a0:	2e00      	cmp	r6, #0
   1b1a2:	d17a      	bne.n	1b29a <lv_disp_refr_task+0x20e>
            lv_refr_area(&disp_refr->inv_areas[i]);
   1b1a4:	ea4f 05c8 	mov.w	r5, r8, lsl #3
   1b1a8:	f105 0340 	add.w	r3, r5, #64	; 0x40
    if(lv_disp_is_true_double_buf(disp_refr)) {
   1b1ac:	4638      	mov	r0, r7
   1b1ae:	9301      	str	r3, [sp, #4]
            lv_refr_area(&disp_refr->inv_areas[i]);
   1b1b0:	eb07 0b03 	add.w	fp, r7, r3
    if(lv_disp_is_true_double_buf(disp_refr)) {
   1b1b4:	f00b ff31 	bl	2701a <lv_disp_is_true_double_buf>
   1b1b8:	b198      	cbz	r0, 1b1e2 <lv_disp_refr_task+0x156>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
   1b1ba:	6820      	ldr	r0, [r4, #0]
   1b1bc:	f00b ff23 	bl	27006 <lv_disp_get_buf>
   1b1c0:	4605      	mov	r5, r0
        vdb->area.x1        = 0;
   1b1c2:	8206      	strh	r6, [r0, #16]
        vdb->area.x2        = lv_disp_get_hor_res(disp_refr) - 1;
   1b1c4:	6820      	ldr	r0, [r4, #0]
   1b1c6:	f001 fc1b 	bl	1ca00 <lv_disp_get_hor_res>
   1b1ca:	3801      	subs	r0, #1
   1b1cc:	82a8      	strh	r0, [r5, #20]
        vdb->area.y1        = 0;
   1b1ce:	826e      	strh	r6, [r5, #18]
        vdb->area.y2        = lv_disp_get_ver_res(disp_refr) - 1;
   1b1d0:	6820      	ldr	r0, [r4, #0]
   1b1d2:	f001 fc25 	bl	1ca20 <lv_disp_get_ver_res>
   1b1d6:	3801      	subs	r0, #1
   1b1d8:	82e8      	strh	r0, [r5, #22]
            lv_refr_area_part(area_p);
   1b1da:	4658      	mov	r0, fp
   1b1dc:	f7ff ff1c 	bl	1b018 <lv_refr_area_part>
   1b1e0:	e04f      	b.n	1b282 <lv_disp_refr_task+0x1f6>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
   1b1e2:	443d      	add	r5, r7
   1b1e4:	6820      	ldr	r0, [r4, #0]
   1b1e6:	f00b ff0e 	bl	27006 <lv_disp_get_buf>
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1b1ea:	f8b5 a044 	ldrh.w	sl, [r5, #68]	; 0x44
   1b1ee:	f8b5 7040 	ldrh.w	r7, [r5, #64]	; 0x40
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1b1f2:	f9b5 9046 	ldrsh.w	r9, [r5, #70]	; 0x46
   1b1f6:	f8b5 3042 	ldrh.w	r3, [r5, #66]	; 0x42
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1b1fa:	f10a 0a01 	add.w	sl, sl, #1
   1b1fe:	ebaa 0a07 	sub.w	sl, sl, r7
   1b202:	4606      	mov	r6, r0
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1b204:	f109 0701 	add.w	r7, r9, #1
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? y2 = lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
   1b208:	6820      	ldr	r0, [r4, #0]
   1b20a:	1aff      	subs	r7, r7, r3
   1b20c:	f001 fc08 	bl	1ca20 <lv_disp_get_ver_res>
        lv_coord_t y2 =
   1b210:	4581      	cmp	r9, r0
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1b212:	fa0f fa8a 	sxth.w	sl, sl
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1b216:	b23f      	sxth	r7, r7
   1b218:	db42      	blt.n	1b2a0 <lv_disp_refr_task+0x214>
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? y2 = lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
   1b21a:	6820      	ldr	r0, [r4, #0]
   1b21c:	f001 fc00 	bl	1ca20 <lv_disp_get_ver_res>
   1b220:	3801      	subs	r0, #1
   1b222:	fa0f f980 	sxth.w	r9, r0
        int32_t max_row = (uint32_t)vdb->size / w;
   1b226:	68f3      	ldr	r3, [r6, #12]
   1b228:	fbb3 f3fa 	udiv	r3, r3, sl
        if(max_row > h) max_row = h;
   1b22c:	429f      	cmp	r7, r3
   1b22e:	bfa8      	it	ge
   1b230:	461f      	movge	r7, r3
        if(disp_refr->driver.rounder_cb) {
   1b232:	6823      	ldr	r3, [r4, #0]
   1b234:	691b      	ldr	r3, [r3, #16]
   1b236:	2b00      	cmp	r3, #0
   1b238:	d038      	beq.n	1b2ac <lv_disp_refr_task+0x220>
            tmp.x1 = 0;
   1b23a:	2300      	movs	r3, #0
   1b23c:	9306      	str	r3, [sp, #24]
            tmp.x2 = 0;
   1b23e:	f8ad 301c 	strh.w	r3, [sp, #28]
            lv_coord_t h_tmp = max_row;
   1b242:	b23b      	sxth	r3, r7
                tmp.y2 = h_tmp - 1;
   1b244:	f103 3aff 	add.w	sl, r3, #4294967295	; 0xffffffff
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
   1b248:	6820      	ldr	r0, [r4, #0]
                tmp.y2 = h_tmp - 1;
   1b24a:	9304      	str	r3, [sp, #16]
   1b24c:	fa0f fa8a 	sxth.w	sl, sl
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
   1b250:	6902      	ldr	r2, [r0, #16]
                tmp.y2 = h_tmp - 1;
   1b252:	f8ad a01e 	strh.w	sl, [sp, #30]
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
   1b256:	a906      	add	r1, sp, #24
   1b258:	4790      	blx	r2
   1b25a:	f9bd 101e 	ldrsh.w	r1, [sp, #30]
   1b25e:	f8bd 201a 	ldrh.w	r2, [sp, #26]
                if(lv_area_get_height(&tmp) <= max_row) break;
   1b262:	9b04      	ldr	r3, [sp, #16]
   1b264:	3101      	adds	r1, #1
   1b266:	1a8a      	subs	r2, r1, r2
   1b268:	b212      	sxth	r2, r2
   1b26a:	4297      	cmp	r7, r2
   1b26c:	da1b      	bge.n	1b2a6 <lv_disp_refr_task+0x21a>
            } while(h_tmp > 0);
   1b26e:	f1ba 0300 	subs.w	r3, sl, #0
   1b272:	dce7      	bgt.n	1b244 <lv_disp_refr_task+0x1b8>
                LV_LOG_WARN("Can't set VDB height using the round function. (Wrong round_cb or to "
   1b274:	4b4c      	ldr	r3, [pc, #304]	; (1b3a8 <lv_disp_refr_task+0x31c>)
   1b276:	494d      	ldr	r1, [pc, #308]	; (1b3ac <lv_disp_refr_task+0x320>)
   1b278:	f240 124f 	movw	r2, #335	; 0x14f
   1b27c:	2002      	movs	r0, #2
   1b27e:	f001 feeb 	bl	1d058 <lv_log_add>
            if(disp_refr->driver.monitor_cb) px_num += lv_area_get_size(&disp_refr->inv_areas[i]);
   1b282:	6820      	ldr	r0, [r4, #0]
   1b284:	6983      	ldr	r3, [r0, #24]
   1b286:	b143      	cbz	r3, 1b29a <lv_disp_refr_task+0x20e>
   1b288:	9b01      	ldr	r3, [sp, #4]
   1b28a:	4418      	add	r0, r3
   1b28c:	f00b ff0f 	bl	270ae <lv_area_get_size>
   1b290:	9b02      	ldr	r3, [sp, #8]
   1b292:	681b      	ldr	r3, [r3, #0]
   1b294:	4418      	add	r0, r3
   1b296:	9b02      	ldr	r3, [sp, #8]
   1b298:	6018      	str	r0, [r3, #0]
    for(i = 0; i < disp_refr->inv_p; i++) {
   1b29a:	f108 0801 	add.w	r8, r8, #1
   1b29e:	e70e      	b.n	1b0be <lv_disp_refr_task+0x32>
        lv_coord_t y2 =
   1b2a0:	f9b5 9046 	ldrsh.w	r9, [r5, #70]	; 0x46
   1b2a4:	e7bf      	b.n	1b226 <lv_disp_refr_task+0x19a>
            if(h_tmp <= 0) {
   1b2a6:	2b00      	cmp	r3, #0
   1b2a8:	dde4      	ble.n	1b274 <lv_disp_refr_task+0x1e8>
                max_row = tmp.y2 + 1;
   1b2aa:	460f      	mov	r7, r1
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
   1b2ac:	f9b5 3042 	ldrsh.w	r3, [r5, #66]	; 0x42
        lv_coord_t row_last = 0;
   1b2b0:	f04f 0a00 	mov.w	sl, #0
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
   1b2b4:	1e7a      	subs	r2, r7, #1
   1b2b6:	18d1      	adds	r1, r2, r3
   1b2b8:	4549      	cmp	r1, r9
   1b2ba:	dd0b      	ble.n	1b2d4 <lv_disp_refr_task+0x248>
        if(y2 != row_last) {
   1b2bc:	45d1      	cmp	r9, sl
   1b2be:	d0e0      	beq.n	1b282 <lv_disp_refr_task+0x1f6>
            vdb->area.x1 = area_p->x1;
   1b2c0:	f9b5 2040 	ldrsh.w	r2, [r5, #64]	; 0x40
   1b2c4:	8232      	strh	r2, [r6, #16]
            vdb->area.x2 = area_p->x2;
   1b2c6:	f9b5 2044 	ldrsh.w	r2, [r5, #68]	; 0x44
   1b2ca:	82b2      	strh	r2, [r6, #20]
            vdb->area.y1 = row;
   1b2cc:	8273      	strh	r3, [r6, #18]
            vdb->area.y2 = y2;
   1b2ce:	f8a6 9016 	strh.w	r9, [r6, #22]
   1b2d2:	e782      	b.n	1b1da <lv_disp_refr_task+0x14e>
            vdb->area.x1 = area_p->x1;
   1b2d4:	f9b5 1040 	ldrsh.w	r1, [r5, #64]	; 0x40
   1b2d8:	8231      	strh	r1, [r6, #16]
            vdb->area.x2 = area_p->x2;
   1b2da:	f9b5 1044 	ldrsh.w	r1, [r5, #68]	; 0x44
            vdb->area.y1 = row;
   1b2de:	8273      	strh	r3, [r6, #18]
            vdb->area.y2 = row + max_row - 1;
   1b2e0:	443b      	add	r3, r7
   1b2e2:	b21b      	sxth	r3, r3
   1b2e4:	f103 3aff 	add.w	sl, r3, #4294967295	; 0xffffffff
   1b2e8:	fa0f fa8a 	sxth.w	sl, sl
   1b2ec:	45ca      	cmp	sl, r9
   1b2ee:	bfa8      	it	ge
   1b2f0:	46ca      	movge	sl, r9
            vdb->area.x2 = area_p->x2;
   1b2f2:	82b1      	strh	r1, [r6, #20]
            vdb->area.y2 = row + max_row - 1;
   1b2f4:	f8a6 a016 	strh.w	sl, [r6, #22]
            lv_refr_area_part(area_p);
   1b2f8:	4658      	mov	r0, fp
   1b2fa:	9205      	str	r2, [sp, #20]
   1b2fc:	9304      	str	r3, [sp, #16]
   1b2fe:	f7ff fe8b 	bl	1b018 <lv_refr_area_part>
   1b302:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
   1b306:	e7d6      	b.n	1b2b6 <lv_disp_refr_task+0x22a>
            lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
   1b308:	6820      	ldr	r0, [r4, #0]
   1b30a:	f00b fe7c 	bl	27006 <lv_disp_get_buf>
   1b30e:	4605      	mov	r5, r0
            lv_refr_vdb_flush();
   1b310:	f7ff fe32 	bl	1af78 <lv_refr_vdb_flush>
            while(vdb->flushing)
   1b314:	69ab      	ldr	r3, [r5, #24]
   1b316:	07db      	lsls	r3, r3, #31
   1b318:	d4fc      	bmi.n	1b314 <lv_disp_refr_task+0x288>
            uint8_t * buf_ina = (uint8_t *)vdb->buf_act == vdb->buf1 ? vdb->buf2 : vdb->buf1;
   1b31a:	f8d5 a000 	ldr.w	sl, [r5]
            uint8_t * buf_act = (uint8_t *)vdb->buf_act;
   1b31e:	f8d5 b008 	ldr.w	fp, [r5, #8]
            lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
   1b322:	6820      	ldr	r0, [r4, #0]
            uint8_t * buf_ina = (uint8_t *)vdb->buf_act == vdb->buf1 ? vdb->buf2 : vdb->buf1;
   1b324:	45da      	cmp	sl, fp
   1b326:	bf08      	it	eq
   1b328:	f8d5 a004 	ldreq.w	sl, [r5, #4]
            lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
   1b32c:	f001 fb68 	bl	1ca00 <lv_disp_get_hor_res>
            for(a = 0; a < disp_refr->inv_p; a++) {
   1b330:	f04f 0900 	mov.w	r9, #0
            lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
   1b334:	4603      	mov	r3, r0
            for(a = 0; a < disp_refr->inv_p; a++) {
   1b336:	6826      	ldr	r6, [r4, #0]
   1b338:	f8b6 2160 	ldrh.w	r2, [r6, #352]	; 0x160
   1b33c:	fa1f f189 	uxth.w	r1, r9
   1b340:	f3c2 0209 	ubfx	r2, r2, #0, #10
   1b344:	428a      	cmp	r2, r1
   1b346:	f67f aec8 	bls.w	1b0da <lv_disp_refr_task+0x4e>
                if(disp_refr->inv_area_joined[a] == 0) {
   1b34a:	eb06 0209 	add.w	r2, r6, r9
   1b34e:	f892 2140 	ldrb.w	r2, [r2, #320]	; 0x140
   1b352:	b112      	cbz	r2, 1b35a <lv_disp_refr_task+0x2ce>
   1b354:	f109 0901 	add.w	r9, r9, #1
   1b358:	e7ed      	b.n	1b336 <lv_disp_refr_task+0x2aa>
                    uint32_t start_offs =
   1b35a:	eb06 06c9 	add.w	r6, r6, r9, lsl #3
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1b35e:	f8b6 5044 	ldrh.w	r5, [r6, #68]	; 0x44
                        (hres * disp_refr->inv_areas[a].y1 + disp_refr->inv_areas[a].x1) * sizeof(lv_color_t);
   1b362:	f9b6 2040 	ldrsh.w	r2, [r6, #64]	; 0x40
   1b366:	f9b6 7042 	ldrsh.w	r7, [r6, #66]	; 0x42
   1b36a:	3501      	adds	r5, #1
   1b36c:	1aad      	subs	r5, r5, r2
   1b36e:	fb03 2807 	mla	r8, r3, r7, r2
                    uint32_t line_length = lv_area_get_width(&disp_refr->inv_areas[a]) * sizeof(lv_color_t);
   1b372:	b22d      	sxth	r5, r5
                    uint32_t start_offs =
   1b374:	ea4f 0888 	mov.w	r8, r8, lsl #2
                    uint32_t line_length = lv_area_get_width(&disp_refr->inv_areas[a]) * sizeof(lv_color_t);
   1b378:	00ad      	lsls	r5, r5, #2
                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
   1b37a:	f9b6 2046 	ldrsh.w	r2, [r6, #70]	; 0x46
   1b37e:	42ba      	cmp	r2, r7
   1b380:	dbe8      	blt.n	1b354 <lv_disp_refr_task+0x2c8>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1b382:	eb0a 0108 	add.w	r1, sl, r8
   1b386:	eb0b 0008 	add.w	r0, fp, r8
   1b38a:	462a      	mov	r2, r5
   1b38c:	9301      	str	r3, [sp, #4]
   1b38e:	f7e6 fc2d 	bl	1bec <memcpy>
                        start_offs += hres * sizeof(lv_color_t);
   1b392:	9b01      	ldr	r3, [sp, #4]
                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
   1b394:	3701      	adds	r7, #1
                        start_offs += hres * sizeof(lv_color_t);
   1b396:	eb08 0883 	add.w	r8, r8, r3, lsl #2
                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
   1b39a:	b23f      	sxth	r7, r7
   1b39c:	e7ed      	b.n	1b37a <lv_disp_refr_task+0x2ee>
   1b39e:	bf00      	nop
   1b3a0:	20001a90 	.word	0x20001a90
   1b3a4:	20001a94 	.word	0x20001a94
   1b3a8:	0006557e 	.word	0x0006557e
   1b3ac:	000655ce 	.word	0x000655ce
            disp_refr->driver.monitor_cb(&disp_refr->driver, lv_tick_elaps(start), px_num);
   1b3b0:	9803      	ldr	r0, [sp, #12]
   1b3b2:	f00b fe45 	bl	27040 <lv_tick_elaps>
   1b3b6:	4b03      	ldr	r3, [pc, #12]	; (1b3c4 <lv_disp_refr_task+0x338>)
   1b3b8:	4601      	mov	r1, r0
   1b3ba:	681a      	ldr	r2, [r3, #0]
   1b3bc:	4620      	mov	r0, r4
   1b3be:	47a8      	blx	r5
   1b3c0:	e6a3      	b.n	1b10a <lv_disp_refr_task+0x7e>
   1b3c2:	bf00      	nop
   1b3c4:	20001a94 	.word	0x20001a94

0001b3c8 <lv_style_init>:
{
    /* Not White/Black/Gray colors are created by HSV model with
     * HUE = 210*/

    /*Screen style*/
    lv_style_scr.glass               = 0;
   1b3c8:	4977      	ldr	r1, [pc, #476]	; (1b5a8 <lv_style_init+0x1e0>)
{
   1b3ca:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    lv_style_scr.glass               = 0;
   1b3ce:	780b      	ldrb	r3, [r1, #0]
    lv_style_scr.body.shadow.type  = LV_SHADOW_FULL;
    lv_style_scr.body.shadow.width = 0;

    lv_style_scr.text.opa          = LV_OPA_COVER;
    lv_style_scr.text.color        = lv_color_make(0x30, 0x30, 0x30);
    lv_style_scr.text.sel_color    = lv_color_make(0x55, 0x96, 0xd8);
   1b3d0:	4c76      	ldr	r4, [pc, #472]	; (1b5ac <lv_style_init+0x1e4>)
    lv_style_scr.debug_sentinel = LV_STYLE_DEGUG_SENTINEL_VALUE;
#endif
#endif

    /*Plain style (by default near the same as the screen style)*/
    lv_style_copy(&lv_style_plain, &lv_style_scr);
   1b3d2:	4e77      	ldr	r6, [pc, #476]	; (1b5b0 <lv_style_init+0x1e8>)
    lv_style_scr.image.color   = lv_color_make(0x20, 0x20, 0x20);
   1b3d4:	4f77      	ldr	r7, [pc, #476]	; (1b5b4 <lv_style_init+0x1ec>)
    lv_style_scr.body.shadow.color = LV_COLOR_GRAY;
   1b3d6:	f8df 925c 	ldr.w	r9, [pc, #604]	; 1b634 <lv_style_init+0x26c>
    lv_style_plain.body.padding.right  = LV_DPI / 20;
    lv_style_plain.body.padding.top    = LV_DPI / 20;
    lv_style_plain.body.padding.bottom = LV_DPI / 20;

    /*Plain color style*/
    lv_style_copy(&lv_style_plain_color, &lv_style_plain);
   1b3da:	f8df a25c 	ldr.w	sl, [pc, #604]	; 1b638 <lv_style_init+0x270>
    lv_style_scr.image.color   = lv_color_make(0x20, 0x20, 0x20);
   1b3de:	640f      	str	r7, [r1, #64]	; 0x40
    lv_style_scr.glass               = 0;
   1b3e0:	f36f 0300 	bfc	r3, #0, #1
   1b3e4:	700b      	strb	r3, [r1, #0]
    lv_style_scr.body.padding.inner  = LV_DPI / 20;
   1b3e6:	2305      	movs	r3, #5
   1b3e8:	850b      	strh	r3, [r1, #40]	; 0x28
    lv_style_scr.body.border.color = LV_COLOR_BLACK;
   1b3ea:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
   1b3ee:	610b      	str	r3, [r1, #16]
    lv_style_scr.body.border.width = 0;
   1b3f0:	f503 2370 	add.w	r3, r3, #983040	; 0xf0000
   1b3f4:	614b      	str	r3, [r1, #20]
    lv_style_scr.body.shadow.type  = LV_SHADOW_FULL;
   1b3f6:	2301      	movs	r3, #1
   1b3f8:	778b      	strb	r3, [r1, #30]
    lv_style_scr.text.sel_color    = lv_color_make(0x55, 0x96, 0xd8);
   1b3fa:	4b6f      	ldr	r3, [pc, #444]	; (1b5b8 <lv_style_init+0x1f0>)
    lv_style_scr.line.color   = lv_color_make(0x20, 0x20, 0x20);
   1b3fc:	648f      	str	r7, [r1, #72]	; 0x48
    lv_style_scr.text.sel_color    = lv_color_make(0x55, 0x96, 0xd8);
   1b3fe:	e9c1 340b 	strd	r3, r4, [r1, #44]	; 0x2c
    lv_style_scr.text.font         = LV_FONT_DEFAULT;
   1b402:	4b6e      	ldr	r3, [pc, #440]	; (1b5bc <lv_style_init+0x1f4>)
   1b404:	634b      	str	r3, [r1, #52]	; 0x34
    lv_style_scr.text.letter_space = 0;
   1b406:	f44f 3300 	mov.w	r3, #131072	; 0x20000
   1b40a:	638b      	str	r3, [r1, #56]	; 0x38
    lv_style_scr.text.opa          = LV_OPA_COVER;
   1b40c:	23ff      	movs	r3, #255	; 0xff
   1b40e:	f881 303c 	strb.w	r3, [r1, #60]	; 0x3c
    lv_style_scr.image.intense = LV_OPA_TRANSP;
   1b412:	f44f 437f 	mov.w	r3, #65280	; 0xff00
   1b416:	f8a1 3044 	strh.w	r3, [r1, #68]	; 0x44
    lv_style_scr.line.width   = 2;
   1b41a:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
    lv_style_scr.body.shadow.color = LV_COLOR_GRAY;
   1b41c:	f8c1 9018 	str.w	r9, [r1, #24]
    lv_style_scr.line.width   = 2;
   1b420:	f003 437e 	and.w	r3, r3, #4261412864	; 0xfe000000
   1b424:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
    lv_style_scr.body.radius         = 0;
   1b428:	2500      	movs	r5, #0
    lv_style_scr.body.main_color     = LV_COLOR_WHITE;
   1b42a:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    lv_style_scr.line.width   = 2;
   1b42e:	f043 0302 	orr.w	r3, r3, #2
    lv_style_scr.body.grad_color     = LV_COLOR_WHITE;
   1b432:	e9c1 8801 	strd	r8, r8, [r1, #4]
    lv_style_scr.body.padding.left   = 0;
   1b436:	e9c1 5508 	strd	r5, r5, [r1, #32]
    lv_style_scr.line.width   = 2;
   1b43a:	64cb      	str	r3, [r1, #76]	; 0x4c
    lv_style_copy(&lv_style_plain, &lv_style_scr);
   1b43c:	4630      	mov	r0, r6
    lv_style_scr.body.radius         = 0;
   1b43e:	818d      	strh	r5, [r1, #12]
    lv_style_scr.body.opa            = LV_OPA_COVER;
   1b440:	f881 800e 	strb.w	r8, [r1, #14]
    lv_style_scr.body.shadow.width = 0;
   1b444:	838d      	strh	r5, [r1, #28]
    lv_style_copy(&lv_style_plain, &lv_style_scr);
   1b446:	f00a fc5c 	bl	25d02 <lv_style_copy>
    lv_style_plain.body.padding.top    = LV_DPI / 20;
   1b44a:	f04f 1305 	mov.w	r3, #327685	; 0x50005
    lv_style_plain.body.padding.left   = LV_DPI / 20;
   1b44e:	e9c6 3308 	strd	r3, r3, [r6, #32]
    lv_style_copy(&lv_style_plain_color, &lv_style_plain);
   1b452:	4631      	mov	r1, r6
   1b454:	4650      	mov	r0, sl
   1b456:	f00a fc54 	bl	25d02 <lv_style_copy>
    lv_style_plain_color.text.color      = lv_color_make(0xf0, 0xf0, 0xf0);
    lv_style_plain_color.image.color     = lv_color_make(0xf0, 0xf0, 0xf0);
    lv_style_plain_color.line.color      = lv_color_make(0xf0, 0xf0, 0xf0);
    lv_style_plain_color.body.main_color = lv_color_make(0x55, 0x96, 0xd8);
    lv_style_plain_color.body.grad_color = lv_style_plain_color.body.main_color;
   1b45a:	e9ca 4401 	strd	r4, r4, [sl, #4]

    /*Pretty style */
    lv_style_copy(&lv_style_pretty, &lv_style_plain);
   1b45e:	4c58      	ldr	r4, [pc, #352]	; (1b5c0 <lv_style_init+0x1f8>)
    lv_style_plain_color.text.color      = lv_color_make(0xf0, 0xf0, 0xf0);
   1b460:	4b58      	ldr	r3, [pc, #352]	; (1b5c4 <lv_style_init+0x1fc>)
   1b462:	f8ca 302c 	str.w	r3, [sl, #44]	; 0x2c
    lv_style_plain_color.image.color     = lv_color_make(0xf0, 0xf0, 0xf0);
   1b466:	f8ca 3040 	str.w	r3, [sl, #64]	; 0x40
    lv_style_plain_color.line.color      = lv_color_make(0xf0, 0xf0, 0xf0);
   1b46a:	f8ca 3048 	str.w	r3, [sl, #72]	; 0x48
    lv_style_copy(&lv_style_pretty, &lv_style_plain);
   1b46e:	4631      	mov	r1, r6
   1b470:	4620      	mov	r0, r4
   1b472:	f00a fc46 	bl	25d02 <lv_style_copy>
    lv_style_pretty.text.color        = lv_color_make(0x20, 0x20, 0x20);
   1b476:	62e7      	str	r7, [r4, #44]	; 0x2c
    lv_style_pretty.image.color       = lv_color_make(0x20, 0x20, 0x20);
   1b478:	6427      	str	r7, [r4, #64]	; 0x40
    lv_style_pretty.line.color        = lv_color_make(0x20, 0x20, 0x20);
   1b47a:	64a7      	str	r7, [r4, #72]	; 0x48
    lv_style_pretty.body.border.color = lv_color_make(0x40, 0x40, 0x40);
    lv_style_pretty.body.border.width = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
    lv_style_pretty.body.border.opa   = LV_OPA_30;

    /*Pretty color style*/
    lv_style_copy(&lv_style_pretty_color, &lv_style_pretty);
   1b47c:	4f52      	ldr	r7, [pc, #328]	; (1b5c8 <lv_style_init+0x200>)
    lv_style_pretty.body.grad_color   = LV_COLOR_SILVER;
   1b47e:	4b53      	ldr	r3, [pc, #332]	; (1b5cc <lv_style_init+0x204>)
    lv_style_pretty.body.border.color = lv_color_make(0x40, 0x40, 0x40);
   1b480:	4a53      	ldr	r2, [pc, #332]	; (1b5d0 <lv_style_init+0x208>)
    lv_style_pretty.body.main_color   = LV_COLOR_WHITE;
   1b482:	f8c4 8004 	str.w	r8, [r4, #4]
    lv_style_pretty.body.grad_color   = LV_COLOR_SILVER;
   1b486:	60a3      	str	r3, [r4, #8]
    lv_style_pretty.body.border.color = lv_color_make(0x40, 0x40, 0x40);
   1b488:	6122      	str	r2, [r4, #16]
    lv_style_copy(&lv_style_pretty_color, &lv_style_pretty);
   1b48a:	4621      	mov	r1, r4
    lv_style_pretty.body.border.opa   = LV_OPA_30;
   1b48c:	224c      	movs	r2, #76	; 0x4c
    lv_style_copy(&lv_style_pretty_color, &lv_style_pretty);
   1b48e:	4638      	mov	r0, r7
    lv_style_pretty.body.radius       = LV_DPI / 15;
   1b490:	f04f 0b06 	mov.w	fp, #6
    lv_style_pretty.body.border.width = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
   1b494:	f04f 0a02 	mov.w	sl, #2
    lv_style_pretty.body.border.opa   = LV_OPA_30;
   1b498:	75e2      	strb	r2, [r4, #23]
    lv_style_pretty.body.radius       = LV_DPI / 15;
   1b49a:	f8a4 b00c 	strh.w	fp, [r4, #12]
    lv_style_pretty.body.border.width = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
   1b49e:	f8a4 a014 	strh.w	sl, [r4, #20]
    lv_style_copy(&lv_style_pretty_color, &lv_style_pretty);
   1b4a2:	f00a fc2e 	bl	25d02 <lv_style_copy>
    lv_style_pretty_color.text.color        = lv_color_make(0xe0, 0xe0, 0xe0);
    lv_style_pretty_color.image.color       = lv_color_make(0xe0, 0xe0, 0xe0);
    lv_style_pretty_color.line.color        = lv_color_make(0xc0, 0xc0, 0xc0);
   1b4a6:	4b49      	ldr	r3, [pc, #292]	; (1b5cc <lv_style_init+0x204>)
   1b4a8:	64bb      	str	r3, [r7, #72]	; 0x48
    lv_style_pretty_color.body.main_color   = lv_color_make(0x6b, 0x9a, 0xc7);
    lv_style_pretty_color.body.grad_color   = lv_color_make(0x2b, 0x59, 0x8b);
   1b4aa:	494a      	ldr	r1, [pc, #296]	; (1b5d4 <lv_style_init+0x20c>)
   1b4ac:	4b4a      	ldr	r3, [pc, #296]	; (1b5d8 <lv_style_init+0x210>)
    lv_style_pretty_color.body.border.color = lv_color_make(0x15, 0x2c, 0x42);

    /*Transparent style*/
    lv_style_copy(&lv_style_transp, &lv_style_plain);
   1b4ae:	4c4b      	ldr	r4, [pc, #300]	; (1b5dc <lv_style_init+0x214>)
    lv_style_pretty_color.text.color        = lv_color_make(0xe0, 0xe0, 0xe0);
   1b4b0:	4a4b      	ldr	r2, [pc, #300]	; (1b5e0 <lv_style_init+0x218>)
   1b4b2:	62fa      	str	r2, [r7, #44]	; 0x2c
    lv_style_pretty_color.body.grad_color   = lv_color_make(0x2b, 0x59, 0x8b);
   1b4b4:	e9c7 1301 	strd	r1, r3, [r7, #4]
    lv_style_pretty_color.body.border.color = lv_color_make(0x15, 0x2c, 0x42);
   1b4b8:	f5a3 13b1 	sub.w	r3, r3, #1449984	; 0x162000
   1b4bc:	f6a3 5349 	subw	r3, r3, #3401	; 0xd49
    lv_style_pretty_color.image.color       = lv_color_make(0xe0, 0xe0, 0xe0);
   1b4c0:	643a      	str	r2, [r7, #64]	; 0x40
    lv_style_pretty_color.body.border.color = lv_color_make(0x15, 0x2c, 0x42);
   1b4c2:	613b      	str	r3, [r7, #16]
    lv_style_copy(&lv_style_transp, &lv_style_plain);
   1b4c4:	4631      	mov	r1, r6
   1b4c6:	4620      	mov	r0, r4
   1b4c8:	f00a fc1b 	bl	25d02 <lv_style_copy>
    lv_style_transp.glass             = 1;
   1b4cc:	7823      	ldrb	r3, [r4, #0]
    lv_style_transp.body.border.width = 0;
    lv_style_transp.body.opa          = LV_OPA_TRANSP;

    /*Transparent fitting size*/
    lv_style_copy(&lv_style_transp_fit, &lv_style_transp);
   1b4ce:	4f45      	ldr	r7, [pc, #276]	; (1b5e4 <lv_style_init+0x21c>)
    lv_style_transp.body.border.width = 0;
   1b4d0:	82a5      	strh	r5, [r4, #20]
    lv_style_transp.glass             = 1;
   1b4d2:	f043 0301 	orr.w	r3, r3, #1
   1b4d6:	7023      	strb	r3, [r4, #0]
    lv_style_transp.body.opa          = LV_OPA_TRANSP;
   1b4d8:	73a5      	strb	r5, [r4, #14]
    lv_style_copy(&lv_style_transp_fit, &lv_style_transp);
   1b4da:	4621      	mov	r1, r4
    lv_style_transp_fit.body.padding.right  = 0;
    lv_style_transp_fit.body.padding.top    = 0;
    lv_style_transp_fit.body.padding.bottom = 0;

    /*Transparent tight style*/
    lv_style_copy(&lv_style_transp_tight, &lv_style_transp_fit);
   1b4dc:	4c42      	ldr	r4, [pc, #264]	; (1b5e8 <lv_style_init+0x220>)
    lv_style_copy(&lv_style_transp_fit, &lv_style_transp);
   1b4de:	4638      	mov	r0, r7
   1b4e0:	f00a fc0f 	bl	25d02 <lv_style_copy>
    lv_style_transp_fit.body.padding.left   = 0;
   1b4e4:	e9c7 5508 	strd	r5, r5, [r7, #32]
    lv_style_copy(&lv_style_transp_tight, &lv_style_transp_fit);
   1b4e8:	4639      	mov	r1, r7
   1b4ea:	4620      	mov	r0, r4
   1b4ec:	f00a fc09 	bl	25d02 <lv_style_copy>
    lv_style_transp_tight.body.padding.inner = 0;
   1b4f0:	8525      	strh	r5, [r4, #40]	; 0x28

    /*Button released style*/
    lv_style_copy(&lv_style_btn_rel, &lv_style_plain);
   1b4f2:	4c3e      	ldr	r4, [pc, #248]	; (1b5ec <lv_style_init+0x224>)
    lv_style_btn_rel.image.color         = lv_color_make(0xff, 0xff, 0xff);

    /*Button pressed style*/
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
    lv_style_btn_pr.body.main_color = lv_color_make(0x33, 0x62, 0x94);
    lv_style_btn_pr.body.grad_color = lv_color_make(0x10, 0x26, 0x3c);
   1b4f4:	4f3e      	ldr	r7, [pc, #248]	; (1b5f0 <lv_style_init+0x228>)
    lv_style_copy(&lv_style_btn_rel, &lv_style_plain);
   1b4f6:	4631      	mov	r1, r6
   1b4f8:	4620      	mov	r0, r4
   1b4fa:	f00a fc02 	bl	25d02 <lv_style_copy>
    lv_style_btn_rel.body.grad_color     = lv_color_make(0x19, 0x3a, 0x5d);
   1b4fe:	483d      	ldr	r0, [pc, #244]	; (1b5f4 <lv_style_init+0x22c>)
   1b500:	4b3d      	ldr	r3, [pc, #244]	; (1b5f8 <lv_style_init+0x230>)
    lv_style_btn_rel.body.shadow.width   = 0;
   1b502:	83a5      	strh	r5, [r4, #28]
    lv_style_btn_rel.body.grad_color     = lv_color_make(0x19, 0x3a, 0x5d);
   1b504:	e9c4 0301 	strd	r0, r3, [r4, #4]
    lv_style_btn_rel.body.padding.left   = LV_DPI / 4;
   1b508:	f04f 1610 	mov.w	r6, #1048592	; 0x100010
   1b50c:	f04f 1319 	mov.w	r3, #1638425	; 0x190019
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
   1b510:	4d3a      	ldr	r5, [pc, #232]	; (1b5fc <lv_style_init+0x234>)
    lv_style_btn_rel.text.color          = lv_color_make(0xff, 0xff, 0xff);
   1b512:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
    lv_style_btn_rel.body.padding.left   = LV_DPI / 4;
   1b516:	e9c4 6308 	strd	r6, r3, [r4, #32]
    lv_style_btn_rel.body.padding.inner  = LV_DPI / 10;
   1b51a:	230a      	movs	r3, #10
   1b51c:	8523      	strh	r3, [r4, #40]	; 0x28
    lv_style_btn_rel.body.border.color   = lv_color_make(0x0b, 0x19, 0x28);
   1b51e:	4b38      	ldr	r3, [pc, #224]	; (1b600 <lv_style_init+0x238>)
   1b520:	6123      	str	r3, [r4, #16]
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
   1b522:	4628      	mov	r0, r5
    lv_style_btn_rel.body.border.opa     = LV_OPA_70;
   1b524:	23b2      	movs	r3, #178	; 0xb2
    lv_style_btn_rel.image.color         = lv_color_make(0xff, 0xff, 0xff);
   1b526:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
   1b52a:	4621      	mov	r1, r4
    lv_style_btn_rel.body.shadow.color   = LV_COLOR_GRAY;
   1b52c:	f8c4 9018 	str.w	r9, [r4, #24]
    lv_style_btn_rel.body.border.opa     = LV_OPA_70;
   1b530:	75e3      	strb	r3, [r4, #23]
    lv_style_btn_rel.body.radius         = LV_DPI / 15;
   1b532:	f8a4 b00c 	strh.w	fp, [r4, #12]
    lv_style_btn_rel.body.border.width   = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
   1b536:	f8a4 a014 	strh.w	sl, [r4, #20]
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
   1b53a:	f00a fbe2 	bl	25d02 <lv_style_copy>
    lv_style_btn_pr.body.grad_color = lv_color_make(0x10, 0x26, 0x3c);
   1b53e:	4b31      	ldr	r3, [pc, #196]	; (1b604 <lv_style_init+0x23c>)
    lv_style_btn_tgl_rel.text.color        = lv_color_make(0xc8, 0xdd, 0xf4);
    lv_style_btn_tgl_rel.image.color       = lv_color_make(0xc8, 0xdd, 0xf4);
    lv_style_btn_tgl_rel.line.color        = lv_color_make(0xc8, 0xdd, 0xf4);

    /*Button toggle pressed style*/
    lv_style_copy(&lv_style_btn_tgl_pr, &lv_style_btn_tgl_rel);
   1b540:	4e31      	ldr	r6, [pc, #196]	; (1b608 <lv_style_init+0x240>)
    lv_style_btn_tgl_pr.body.main_color = lv_color_make(0x02, 0x14, 0x27);
    lv_style_btn_tgl_pr.body.grad_color = lv_color_make(0x2b, 0x4c, 0x70);
   1b542:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 1b63c <lv_style_init+0x274>
    lv_style_btn_pr.body.grad_color = lv_color_make(0x10, 0x26, 0x3c);
   1b546:	e9c5 7301 	strd	r7, r3, [r5, #4]
    lv_style_btn_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
   1b54a:	4f30      	ldr	r7, [pc, #192]	; (1b60c <lv_style_init+0x244>)
   1b54c:	62ef      	str	r7, [r5, #44]	; 0x2c
    lv_style_btn_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
   1b54e:	642f      	str	r7, [r5, #64]	; 0x40
    lv_style_btn_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);
   1b550:	64af      	str	r7, [r5, #72]	; 0x48
    lv_style_copy(&lv_style_btn_tgl_rel, &lv_style_btn_rel);
   1b552:	4d2f      	ldr	r5, [pc, #188]	; (1b610 <lv_style_init+0x248>)
   1b554:	4621      	mov	r1, r4
   1b556:	4628      	mov	r0, r5
   1b558:	f00a fbd3 	bl	25d02 <lv_style_copy>
    lv_style_btn_tgl_rel.body.grad_color   = lv_color_make(0x37, 0x62, 0x90);
   1b55c:	f8df c0e0 	ldr.w	ip, [pc, #224]	; 1b640 <lv_style_init+0x278>
   1b560:	4b2c      	ldr	r3, [pc, #176]	; (1b614 <lv_style_init+0x24c>)
   1b562:	e9c5 c301 	strd	ip, r3, [r5, #4]
    lv_style_btn_tgl_rel.body.border.color = lv_color_make(0x01, 0x07, 0x0d);
   1b566:	4b2c      	ldr	r3, [pc, #176]	; (1b618 <lv_style_init+0x250>)
   1b568:	612b      	str	r3, [r5, #16]
    lv_style_btn_tgl_rel.text.color        = lv_color_make(0xc8, 0xdd, 0xf4);
   1b56a:	4b2c      	ldr	r3, [pc, #176]	; (1b61c <lv_style_init+0x254>)
   1b56c:	62eb      	str	r3, [r5, #44]	; 0x2c
    lv_style_btn_tgl_rel.image.color       = lv_color_make(0xc8, 0xdd, 0xf4);
   1b56e:	642b      	str	r3, [r5, #64]	; 0x40
    lv_style_btn_tgl_rel.line.color        = lv_color_make(0xc8, 0xdd, 0xf4);
   1b570:	64ab      	str	r3, [r5, #72]	; 0x48
    lv_style_copy(&lv_style_btn_tgl_pr, &lv_style_btn_tgl_rel);
   1b572:	4629      	mov	r1, r5
   1b574:	4630      	mov	r0, r6
   1b576:	f00a fbc4 	bl	25d02 <lv_style_copy>
    lv_style_btn_tgl_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
    lv_style_btn_tgl_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
    lv_style_btn_tgl_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);

    /*Button inactive style*/
    lv_style_copy(&lv_style_btn_ina, &lv_style_btn_rel);
   1b57a:	4d29      	ldr	r5, [pc, #164]	; (1b620 <lv_style_init+0x258>)
    lv_style_btn_tgl_pr.body.grad_color = lv_color_make(0x2b, 0x4c, 0x70);
   1b57c:	4b29      	ldr	r3, [pc, #164]	; (1b624 <lv_style_init+0x25c>)
    lv_style_btn_tgl_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
   1b57e:	62f7      	str	r7, [r6, #44]	; 0x2c
    lv_style_btn_tgl_pr.body.grad_color = lv_color_make(0x2b, 0x4c, 0x70);
   1b580:	e9c6 8301 	strd	r8, r3, [r6, #4]
    lv_style_btn_tgl_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
   1b584:	6437      	str	r7, [r6, #64]	; 0x40
    lv_style_btn_tgl_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);
   1b586:	64b7      	str	r7, [r6, #72]	; 0x48
    lv_style_copy(&lv_style_btn_ina, &lv_style_btn_rel);
   1b588:	4621      	mov	r1, r4
   1b58a:	4628      	mov	r0, r5
   1b58c:	f00a fbb9 	bl	25d02 <lv_style_copy>
    lv_style_btn_ina.body.main_color   = lv_color_make(0xd8, 0xd8, 0xd8);
   1b590:	4b25      	ldr	r3, [pc, #148]	; (1b628 <lv_style_init+0x260>)
    lv_style_btn_ina.body.grad_color   = lv_color_make(0xd8, 0xd8, 0xd8);
   1b592:	e9c5 3301 	strd	r3, r3, [r5, #4]
    lv_style_btn_ina.body.border.color = lv_color_make(0x90, 0x90, 0x90);
   1b596:	4b25      	ldr	r3, [pc, #148]	; (1b62c <lv_style_init+0x264>)
   1b598:	612b      	str	r3, [r5, #16]
    lv_style_btn_ina.text.color        = lv_color_make(0x70, 0x70, 0x70);
   1b59a:	4b25      	ldr	r3, [pc, #148]	; (1b630 <lv_style_init+0x268>)
   1b59c:	62eb      	str	r3, [r5, #44]	; 0x2c
    lv_style_btn_ina.image.color       = lv_color_make(0x70, 0x70, 0x70);
   1b59e:	642b      	str	r3, [r5, #64]	; 0x40
    lv_style_btn_ina.line.color        = lv_color_make(0x70, 0x70, 0x70);
   1b5a0:	64ab      	str	r3, [r5, #72]	; 0x48
}
   1b5a2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1b5a6:	bf00      	nop
   1b5a8:	20001d68 	.word	0x20001d68
   1b5ac:	ff5596d8 	.word	0xff5596d8
   1b5b0:	20001c28 	.word	0x20001c28
   1b5b4:	ff202020 	.word	0xff202020
   1b5b8:	ff303030 	.word	0xff303030
   1b5bc:	2000ebf8 	.word	0x2000ebf8
   1b5c0:	20001cc8 	.word	0x20001cc8
   1b5c4:	fff0f0f0 	.word	0xfff0f0f0
   1b5c8:	20001d18 	.word	0x20001d18
   1b5cc:	ffc0c0c0 	.word	0xffc0c0c0
   1b5d0:	ff404040 	.word	0xff404040
   1b5d4:	ff6b9ac7 	.word	0xff6b9ac7
   1b5d8:	ff2b598b 	.word	0xff2b598b
   1b5dc:	20001db8 	.word	0x20001db8
   1b5e0:	ffe0e0e0 	.word	0xffe0e0e0
   1b5e4:	20001e08 	.word	0x20001e08
   1b5e8:	20001e58 	.word	0x20001e58
   1b5ec:	20001b38 	.word	0x20001b38
   1b5f0:	ff336294 	.word	0xff336294
   1b5f4:	ff76a2d0 	.word	0xff76a2d0
   1b5f8:	ff193a5d 	.word	0xff193a5d
   1b5fc:	20001ae8 	.word	0x20001ae8
   1b600:	ff0b1928 	.word	0xff0b1928
   1b604:	ff10263c 	.word	0xff10263c
   1b608:	20001b88 	.word	0x20001b88
   1b60c:	ffa4b5c6 	.word	0xffa4b5c6
   1b610:	20001bd8 	.word	0x20001bd8
   1b614:	ff376290 	.word	0xff376290
   1b618:	ff01070d 	.word	0xff01070d
   1b61c:	ffc8ddf4 	.word	0xffc8ddf4
   1b620:	20001a98 	.word	0x20001a98
   1b624:	ff2b4c70 	.word	0xff2b4c70
   1b628:	ffd8d8d8 	.word	0xffd8d8d8
   1b62c:	ff909090 	.word	0xff909090
   1b630:	ff707070 	.word	0xff707070
   1b634:	ff808080 	.word	0xff808080
   1b638:	20001c78 	.word	0x20001c78
   1b63c:	ff021427 	.word	0xff021427
   1b640:	ff0a1122 	.word	0xff0a1122

0001b644 <lv_draw_letter>:
 * @param color color of letter
 * @param opa opacity of letter (0..255)
 */
void lv_draw_letter(const lv_point_t * pos_p, const lv_area_t * mask_p, const lv_font_t * font_p, uint32_t letter,
                    lv_color_t color, lv_opa_t opa)
{
   1b644:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b648:	b0a3      	sub	sp, #140	; 0x8c
   1b64a:	469a      	mov	sl, r3
   1b64c:	f89d 30b4 	ldrb.w	r3, [sp, #180]	; 0xb4
   1b650:	9308      	str	r3, [sp, #32]
    /*clang-format off*/
    const uint8_t bpp1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
   1b652:	f44f 437f 	mov.w	r3, #65280	; 0xff00
   1b656:	f8ad 3064 	strh.w	r3, [sp, #100]	; 0x64
    const uint8_t bpp2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
   1b65a:	f5a3 03ad 	sub.w	r3, r3, #5668864	; 0x568000
   1b65e:	f5a3 5328 	sub.w	r3, r3, #10752	; 0x2a00
   1b662:	931b      	str	r3, [sp, #108]	; 0x6c
    const uint8_t bpp4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
   1b664:	4bb4      	ldr	r3, [pc, #720]	; (1b938 <lv_draw_letter+0x2f4>)
{
   1b666:	4617      	mov	r7, r2
   1b668:	4604      	mov	r4, r0
   1b66a:	460d      	mov	r5, r1
    const uint8_t bpp4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
   1b66c:	aa1e      	add	r2, sp, #120	; 0x78
   1b66e:	f103 0c10 	add.w	ip, r3, #16
   1b672:	6818      	ldr	r0, [r3, #0]
   1b674:	6859      	ldr	r1, [r3, #4]
   1b676:	4616      	mov	r6, r2
   1b678:	c603      	stmia	r6!, {r0, r1}
   1b67a:	3308      	adds	r3, #8
   1b67c:	4563      	cmp	r3, ip
   1b67e:	4632      	mov	r2, r6
   1b680:	d1f7      	bne.n	1b672 <lv_draw_letter+0x2e>
                                        68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255};
    /*clang-format on*/

    if(opa < LV_OPA_MIN) return;
   1b682:	9b08      	ldr	r3, [sp, #32]
   1b684:	2b0f      	cmp	r3, #15
   1b686:	d90a      	bls.n	1b69e <lv_draw_letter+0x5a>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
   1b688:	2bfc      	cmp	r3, #252	; 0xfc
   1b68a:	bf28      	it	cs
   1b68c:	23ff      	movcs	r3, #255	; 0xff
   1b68e:	9308      	str	r3, [sp, #32]

    if(font_p == NULL) {
   1b690:	b947      	cbnz	r7, 1b6a4 <lv_draw_letter+0x60>
        LV_LOG_WARN("Font: character's bitmap not found");
   1b692:	4baa      	ldr	r3, [pc, #680]	; (1b93c <lv_draw_letter+0x2f8>)
   1b694:	49aa      	ldr	r1, [pc, #680]	; (1b940 <lv_draw_letter+0x2fc>)
   1b696:	22f7      	movs	r2, #247	; 0xf7
   1b698:	2002      	movs	r0, #2
   1b69a:	f001 fcdd 	bl	1d058 <lv_log_add>

        /*Next row in VDB*/
        if(subpx) vdb_buf_tmp += vdb_width - (col_end - col_start) / 3;
        else vdb_buf_tmp += vdb_width - (col_end - col_start);
    }
}
   1b69e:	b023      	add	sp, #140	; 0x8c
   1b6a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bool g_ret = lv_font_get_glyph_dsc(font_p, &g, letter, '\0');
   1b6a4:	2300      	movs	r3, #0
   1b6a6:	4652      	mov	r2, sl
   1b6a8:	a91c      	add	r1, sp, #112	; 0x70
   1b6aa:	4638      	mov	r0, r7
   1b6ac:	f00c f94e 	bl	2794c <lv_font_get_glyph_dsc>
    if(g_ret == false) return;
   1b6b0:	2800      	cmp	r0, #0
   1b6b2:	d0f4      	beq.n	1b69e <lv_draw_letter+0x5a>
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
   1b6b4:	f99d 1075 	ldrsb.w	r1, [sp, #117]	; 0x75
   1b6b8:	9106      	str	r1, [sp, #24]
    if(g.bpp == 3) g.bpp = 4;
   1b6ba:	f89d 1076 	ldrb.w	r1, [sp, #118]	; 0x76
    lv_coord_t pos_x = pos_p->x + g.ofs_x;
   1b6be:	f9b4 9000 	ldrsh.w	r9, [r4]
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
   1b6c2:	f9b4 6002 	ldrsh.w	r6, [r4, #2]
    lv_coord_t pos_x = pos_p->x + g.ofs_x;
   1b6c6:	f99d 2074 	ldrsb.w	r2, [sp, #116]	; 0x74
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
   1b6ca:	f897 8008 	ldrb.w	r8, [r7, #8]
   1b6ce:	7a7b      	ldrb	r3, [r7, #9]
   1b6d0:	f89d 4073 	ldrb.w	r4, [sp, #115]	; 0x73
    if(g.bpp == 3) g.bpp = 4;
   1b6d4:	2903      	cmp	r1, #3
   1b6d6:	d106      	bne.n	1b6e6 <lv_draw_letter+0xa2>
   1b6d8:	2104      	movs	r1, #4
   1b6da:	f88d 1076 	strb.w	r1, [sp, #118]	; 0x76
            bitmask_init  = 0xF0;
   1b6de:	21f0      	movs	r1, #240	; 0xf0
   1b6e0:	9109      	str	r1, [sp, #36]	; 0x24
            bpp_opa_table = bpp4_opa_table;
   1b6e2:	a91e      	add	r1, sp, #120	; 0x78
   1b6e4:	e019      	b.n	1b71a <lv_draw_letter+0xd6>
    switch(g.bpp) {
   1b6e6:	3901      	subs	r1, #1
   1b6e8:	2907      	cmp	r1, #7
   1b6ea:	d8d8      	bhi.n	1b69e <lv_draw_letter+0x5a>
   1b6ec:	a001      	add	r0, pc, #4	; (adr r0, 1b6f4 <lv_draw_letter+0xb0>)
   1b6ee:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
   1b6f2:	bf00      	nop
   1b6f4:	0001b8e9 	.word	0x0001b8e9
   1b6f8:	0001b715 	.word	0x0001b715
   1b6fc:	0001b69f 	.word	0x0001b69f
   1b700:	0001b6df 	.word	0x0001b6df
   1b704:	0001b69f 	.word	0x0001b69f
   1b708:	0001b69f 	.word	0x0001b69f
   1b70c:	0001b69f 	.word	0x0001b69f
   1b710:	0001b8e1 	.word	0x0001b8e1
            bitmask_init  = 0xC0;
   1b714:	21c0      	movs	r1, #192	; 0xc0
   1b716:	9109      	str	r1, [sp, #36]	; 0x24
            bpp_opa_table = bpp2_opa_table;
   1b718:	a91b      	add	r1, sp, #108	; 0x6c
            bpp_opa_table = bpp1_opa_table;
   1b71a:	9105      	str	r1, [sp, #20]
    const uint8_t * map_p = lv_font_get_glyph_bitmap(font_p, letter);
   1b71c:	4638      	mov	r0, r7
   1b71e:	4651      	mov	r1, sl
   1b720:	930a      	str	r3, [sp, #40]	; 0x28
   1b722:	9207      	str	r2, [sp, #28]
   1b724:	f00c f910 	bl	27948 <lv_font_get_glyph_bitmap>
    if(map_p == NULL) return;
   1b728:	9004      	str	r0, [sp, #16]
   1b72a:	2800      	cmp	r0, #0
   1b72c:	d0b7      	beq.n	1b69e <lv_draw_letter+0x5a>
    lv_coord_t pos_x = pos_p->x + g.ofs_x;
   1b72e:	9a07      	ldr	r2, [sp, #28]
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
   1b730:	f9b5 1000 	ldrsh.w	r1, [r5]
    lv_coord_t pos_x = pos_p->x + g.ofs_x;
   1b734:	4491      	add	r9, r2
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
   1b736:	f89d 2072 	ldrb.w	r2, [sp, #114]	; 0x72
    lv_coord_t pos_x = pos_p->x + g.ofs_x;
   1b73a:	fa0f f989 	sxth.w	r9, r9
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
   1b73e:	444a      	add	r2, r9
   1b740:	428a      	cmp	r2, r1
   1b742:	dbac      	blt.n	1b69e <lv_draw_letter+0x5a>
   1b744:	f9b5 2004 	ldrsh.w	r2, [r5, #4]
   1b748:	454a      	cmp	r2, r9
   1b74a:	dba8      	blt.n	1b69e <lv_draw_letter+0x5a>
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
   1b74c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
   1b74e:	f9b5 2002 	ldrsh.w	r2, [r5, #2]
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
   1b752:	eba8 0803 	sub.w	r8, r8, r3
   1b756:	9b06      	ldr	r3, [sp, #24]
   1b758:	4446      	add	r6, r8
   1b75a:	b236      	sxth	r6, r6
   1b75c:	441c      	add	r4, r3
   1b75e:	1b33      	subs	r3, r6, r4
   1b760:	fa0f f883 	sxth.w	r8, r3
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
   1b764:	f89d 3073 	ldrb.w	r3, [sp, #115]	; 0x73
   1b768:	4443      	add	r3, r8
   1b76a:	4293      	cmp	r3, r2
   1b76c:	db97      	blt.n	1b69e <lv_draw_letter+0x5a>
   1b76e:	f9b5 3006 	ldrsh.w	r3, [r5, #6]
   1b772:	4543      	cmp	r3, r8
   1b774:	db93      	blt.n	1b69e <lv_draw_letter+0x5a>
    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
   1b776:	f7ff fc83 	bl	1b080 <lv_refr_get_disp_refreshing>
   1b77a:	9011      	str	r0, [sp, #68]	; 0x44
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   1b77c:	f00b fc43 	bl	27006 <lv_disp_get_buf>
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1b780:	8a83      	ldrh	r3, [r0, #20]
   1b782:	f9b0 1010 	ldrsh.w	r1, [r0, #16]
   1b786:	9007      	str	r0, [sp, #28]
   1b788:	3301      	adds	r3, #1
   1b78a:	1a5b      	subs	r3, r3, r1
   1b78c:	b21b      	sxth	r3, r3
   1b78e:	930b      	str	r3, [sp, #44]	; 0x2c
    bool subpx = font_p->subpx == LV_FONT_SUBPX_NONE ? false : true;
   1b790:	7abb      	ldrb	r3, [r7, #10]
    lv_color_t * vdb_buf_tmp = vdb->buf_act;
   1b792:	f8d0 c008 	ldr.w	ip, [r0, #8]
    uint16_t width_bit = g.box_w * g.bpp; /*Letter width in bits*/
   1b796:	f89d 2076 	ldrb.w	r2, [sp, #118]	; 0x76
    uint8_t width_byte_scr = g.box_w >> 3; /*Width in bytes (on the screen finally) (e.g. w = 11 -> 2 bytes wide)*/
   1b79a:	f89d 0072 	ldrb.w	r0, [sp, #114]	; 0x72
    uint16_t width_bit = g.box_w * g.bpp; /*Letter width in bits*/
   1b79e:	f9b5 a000 	ldrsh.w	sl, [r5]
    if(subpx == false) {
   1b7a2:	f013 0303 	ands.w	r3, r3, #3
    uint16_t width_bit = g.box_w * g.bpp; /*Letter width in bits*/
   1b7a6:	fb00 fe02 	mul.w	lr, r0, r2
    if(subpx == false) {
   1b7aa:	930c      	str	r3, [sp, #48]	; 0x30
   1b7ac:	f040 80a5 	bne.w	1b8fa <lv_draw_letter+0x2b6>
        col_start = pos_x >= mask_p->x1 ? 0 : mask_p->x1 - pos_x;
   1b7b0:	45ca      	cmp	sl, r9
        col_end   = pos_x + g.box_w <= mask_p->x2 ? g.box_w : mask_p->x2 - pos_x + 1;
   1b7b2:	f9b5 3004 	ldrsh.w	r3, [r5, #4]
        col_start = pos_x >= mask_p->x1 ? 0 : mask_p->x1 - pos_x;
   1b7b6:	bfd4      	ite	le
   1b7b8:	f8dd a030 	ldrle.w	sl, [sp, #48]	; 0x30
   1b7bc:	ebaa 0a09 	subgt.w	sl, sl, r9
        col_end   = pos_x + g.box_w <= mask_p->x2 ? g.box_w : mask_p->x2 - pos_x + 1;
   1b7c0:	eb00 0709 	add.w	r7, r0, r9
        col_start = pos_x >= mask_p->x1 ? 0 : mask_p->x1 - pos_x;
   1b7c4:	bfc8      	it	gt
   1b7c6:	fa0f fa8a 	sxthgt.w	sl, sl
        col_end   = pos_x + g.box_w <= mask_p->x2 ? g.box_w : mask_p->x2 - pos_x + 1;
   1b7ca:	429f      	cmp	r7, r3
   1b7cc:	f300 8090 	bgt.w	1b8f0 <lv_draw_letter+0x2ac>
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
   1b7d0:	b203      	sxth	r3, r0
        row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
   1b7d2:	f9b5 7002 	ldrsh.w	r7, [r5, #2]
        row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
   1b7d6:	f89d 0073 	ldrb.w	r0, [sp, #115]	; 0x73
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
   1b7da:	9306      	str	r3, [sp, #24]
        row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
   1b7dc:	4547      	cmp	r7, r8
   1b7de:	bfc8      	it	gt
   1b7e0:	193f      	addgt	r7, r7, r4
        row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
   1b7e2:	f9b5 3006 	ldrsh.w	r3, [r5, #6]
        row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
   1b7e6:	bfc8      	it	gt
   1b7e8:	1bbf      	subgt	r7, r7, r6
        row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
   1b7ea:	eb00 0508 	add.w	r5, r0, r8
        row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
   1b7ee:	bfcc      	ite	gt
   1b7f0:	b23f      	sxthgt	r7, r7
   1b7f2:	2700      	movle	r7, #0
        row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
   1b7f4:	429d      	cmp	r5, r3
   1b7f6:	bfc2      	ittt	gt
   1b7f8:	3401      	addgt	r4, #1
   1b7fa:	18e4      	addgt	r4, r4, r3
   1b7fc:	1ba0      	subgt	r0, r4, r6
   1b7fe:	b203      	sxth	r3, r0
   1b800:	930f      	str	r3, [sp, #60]	; 0x3c
    vdb_buf_tmp += ((pos_y - vdb->area.y1) * vdb_width) + pos_x - vdb->area.x1;
   1b802:	9b07      	ldr	r3, [sp, #28]
   1b804:	f9b3 4012 	ldrsh.w	r4, [r3, #18]
   1b808:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1b80a:	eba9 0101 	sub.w	r1, r9, r1
   1b80e:	eba8 0404 	sub.w	r4, r8, r4
   1b812:	fb03 1404 	mla	r4, r3, r4, r1
   1b816:	fb03 f107 	mul.w	r1, r3, r7
    if(subpx) vdb_buf_tmp += (row_start * vdb_width) + col_start / 3;
   1b81a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    vdb_buf_tmp += ((pos_y - vdb->area.y1) * vdb_width) + pos_x - vdb->area.x1;
   1b81c:	eb0c 0484 	add.w	r4, ip, r4, lsl #2
    if(subpx) vdb_buf_tmp += (row_start * vdb_width) + col_start / 3;
   1b820:	2b00      	cmp	r3, #0
   1b822:	f000 8086 	beq.w	1b932 <lv_draw_letter+0x2ee>
   1b826:	2303      	movs	r3, #3
   1b828:	fb9a f3f3 	sdiv	r3, sl, r3
   1b82c:	440b      	add	r3, r1
    uint32_t bit_ofs = (row_start * width_bit) + (col_start * g.bpp);
   1b82e:	fb12 f50a 	smulbb	r5, r2, sl
    else vdb_buf_tmp += (row_start * vdb_width) + col_start;
   1b832:	eb04 0483 	add.w	r4, r4, r3, lsl #2
    map_p += bit_ofs >> 3;
   1b836:	9b04      	ldr	r3, [sp, #16]
        else vdb_buf_tmp += vdb_width - (col_end - col_start);
   1b838:	9a06      	ldr	r2, [sp, #24]
    uint32_t bit_ofs = (row_start * width_bit) + (col_start * g.bpp);
   1b83a:	fb07 550e 	mla	r5, r7, lr, r5
    map_p += bit_ofs >> 3;
   1b83e:	eb03 03d5 	add.w	r3, r3, r5, lsr #3
   1b842:	930a      	str	r3, [sp, #40]	; 0x28
    col_bit = bit_ofs & 0x7; /* "& 0x7" equals to "% 8" just faster */
   1b844:	f005 0307 	and.w	r3, r5, #7
   1b848:	9304      	str	r3, [sp, #16]
    uint8_t txt_rgb[3] = {LV_COLOR_GET_R(color), LV_COLOR_GET_G(color), LV_COLOR_GET_B(color)};
   1b84a:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   1b84c:	f3c3 4307 	ubfx	r3, r3, #16, #8
   1b850:	9312      	str	r3, [sp, #72]	; 0x48
   1b852:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   1b854:	f3c3 2307 	ubfx	r3, r3, #8, #8
   1b858:	9313      	str	r3, [sp, #76]	; 0x4c
   1b85a:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   1b85c:	b2db      	uxtb	r3, r3
   1b85e:	9314      	str	r3, [sp, #80]	; 0x50
        else vdb_buf_tmp += vdb_width - (col_end - col_start);
   1b860:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1b862:	4453      	add	r3, sl
   1b864:	1a9b      	subs	r3, r3, r2
   1b866:	009b      	lsls	r3, r3, #2
   1b868:	9316      	str	r3, [sp, #88]	; 0x58
        if(subpx) vdb_buf_tmp += vdb_width - (col_end - col_start) / 3;
   1b86a:	eba2 030a 	sub.w	r3, r2, sl
   1b86e:	f06f 0202 	mvn.w	r2, #2
   1b872:	fb93 f3f2 	sdiv	r3, r3, r2
   1b876:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1b878:	4413      	add	r3, r2
   1b87a:	009b      	lsls	r3, r3, #2
   1b87c:	9315      	str	r3, [sp, #84]	; 0x54
    for(row = row_start; row < row_end; row++) {
   1b87e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1b880:	429f      	cmp	r7, r3
   1b882:	f6bf af0c 	bge.w	1b69e <lv_draw_letter+0x5a>
        bitmask = bitmask_init >> col_bit;
   1b886:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1b888:	9a04      	ldr	r2, [sp, #16]
   1b88a:	4113      	asrs	r3, r2
   1b88c:	b2db      	uxtb	r3, r3
        for(col = col_start; col < col_end; col++) {
   1b88e:	e9cd 3a0d 	strd	r3, sl, [sp, #52]	; 0x34
   1b892:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   1b896:	9310      	str	r3, [sp, #64]	; 0x40
                                *vdb_buf_tmp = lv_color_mix(color, *vdb_buf_tmp, px_opa);
   1b898:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   1b89a:	f3c3 4307 	ubfx	r3, r3, #16, #8
        uint8_t sub_px_cnt = 0;
   1b89e:	2600      	movs	r6, #0
                                *vdb_buf_tmp = lv_color_mix(color, *vdb_buf_tmp, px_opa);
   1b8a0:	9317      	str	r3, [sp, #92]	; 0x5c
        for(col = col_start; col < col_end; col++) {
   1b8a2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b8a4:	9a06      	ldr	r2, [sp, #24]
   1b8a6:	f89d 1076 	ldrb.w	r1, [sp, #118]	; 0x76
   1b8aa:	4293      	cmp	r3, r2
   1b8ac:	db4a      	blt.n	1b944 <lv_draw_letter+0x300>
        col_bit += ((g.box_w - col_end) + col_start) * g.bpp;
   1b8ae:	f89d 3072 	ldrb.w	r3, [sp, #114]	; 0x72
   1b8b2:	4453      	add	r3, sl
   1b8b4:	1a9b      	subs	r3, r3, r2
   1b8b6:	9a04      	ldr	r2, [sp, #16]
   1b8b8:	fb13 f301 	smulbb	r3, r3, r1
   1b8bc:	441a      	add	r2, r3
        map_p += (col_bit >> 3);
   1b8be:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        col_bit += ((g.box_w - col_end) + col_start) * g.bpp;
   1b8c0:	b295      	uxth	r5, r2
        map_p += (col_bit >> 3);
   1b8c2:	eb03 03d5 	add.w	r3, r3, r5, lsr #3
   1b8c6:	930a      	str	r3, [sp, #40]	; 0x28
        col_bit = col_bit & 0x7;
   1b8c8:	f005 0307 	and.w	r3, r5, #7
   1b8cc:	9304      	str	r3, [sp, #16]
        if(subpx) vdb_buf_tmp += vdb_width - (col_end - col_start) / 3;
   1b8ce:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1b8d0:	2b00      	cmp	r3, #0
   1b8d2:	f000 80f9 	beq.w	1bac8 <lv_draw_letter+0x484>
   1b8d6:	9b15      	ldr	r3, [sp, #84]	; 0x54
    for(row = row_start; row < row_end; row++) {
   1b8d8:	3701      	adds	r7, #1
        else vdb_buf_tmp += vdb_width - (col_end - col_start);
   1b8da:	441c      	add	r4, r3
    for(row = row_start; row < row_end; row++) {
   1b8dc:	b23f      	sxth	r7, r7
   1b8de:	e7ce      	b.n	1b87e <lv_draw_letter+0x23a>
            bitmask_init  = 0xFF;
   1b8e0:	21ff      	movs	r1, #255	; 0xff
   1b8e2:	9109      	str	r1, [sp, #36]	; 0x24
            bpp_opa_table = NULL;
   1b8e4:	2100      	movs	r1, #0
   1b8e6:	e718      	b.n	1b71a <lv_draw_letter+0xd6>
            bitmask_init  = 0x80;
   1b8e8:	2180      	movs	r1, #128	; 0x80
   1b8ea:	9109      	str	r1, [sp, #36]	; 0x24
            bpp_opa_table = bpp1_opa_table;
   1b8ec:	a919      	add	r1, sp, #100	; 0x64
   1b8ee:	e714      	b.n	1b71a <lv_draw_letter+0xd6>
        col_end   = pos_x + g.box_w <= mask_p->x2 ? g.box_w : mask_p->x2 - pos_x + 1;
   1b8f0:	3301      	adds	r3, #1
   1b8f2:	eba3 0309 	sub.w	r3, r3, r9
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
   1b8f6:	b21b      	sxth	r3, r3
   1b8f8:	e76b      	b.n	1b7d2 <lv_draw_letter+0x18e>
        col_start = pos_x >= mask_p->x1 ? 0 : (mask_p->x1 - pos_x) * 3;
   1b8fa:	45ca      	cmp	sl, r9
   1b8fc:	bfc8      	it	gt
   1b8fe:	ebaa 0a09 	subgt.w	sl, sl, r9
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
   1b902:	f9b5 3004 	ldrsh.w	r3, [r5, #4]
        col_start = pos_x >= mask_p->x1 ? 0 : (mask_p->x1 - pos_x) * 3;
   1b906:	bfc8      	it	gt
   1b908:	eb0a 0a4a 	addgt.w	sl, sl, sl, lsl #1
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
   1b90c:	f04f 0703 	mov.w	r7, #3
   1b910:	fbb0 f7f7 	udiv	r7, r0, r7
   1b914:	444f      	add	r7, r9
        col_start = pos_x >= mask_p->x1 ? 0 : (mask_p->x1 - pos_x) * 3;
   1b916:	bfcc      	ite	gt
   1b918:	fa0f fa8a 	sxthgt.w	sl, sl
   1b91c:	f04f 0a00 	movle.w	sl, #0
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
   1b920:	429f      	cmp	r7, r3
   1b922:	f77f af55 	ble.w	1b7d0 <lv_draw_letter+0x18c>
   1b926:	3301      	adds	r3, #1
   1b928:	eba3 0309 	sub.w	r3, r3, r9
   1b92c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1b930:	e7e1      	b.n	1b8f6 <lv_draw_letter+0x2b2>
    else vdb_buf_tmp += (row_start * vdb_width) + col_start;
   1b932:	eb01 030a 	add.w	r3, r1, sl
   1b936:	e77a      	b.n	1b82e <lv_draw_letter+0x1ea>
   1b938:	00028758 	.word	0x00028758
   1b93c:	00065604 	.word	0x00065604
   1b940:	00065627 	.word	0x00065627
            letter_px = (*map_p & bitmask) >> (8 - col_bit - g.bpp);
   1b944:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1b946:	9804      	ldr	r0, [sp, #16]
   1b948:	781a      	ldrb	r2, [r3, #0]
   1b94a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1b94c:	401a      	ands	r2, r3
   1b94e:	f1c1 0308 	rsb	r3, r1, #8
   1b952:	1a1b      	subs	r3, r3, r0
   1b954:	411a      	asrs	r2, r3
            if(subpx == false) {
   1b956:	9b0c      	ldr	r3, [sp, #48]	; 0x30
            letter_px = (*map_p & bitmask) >> (8 - col_bit - g.bpp);
   1b958:	b2d2      	uxtb	r2, r2
            if(subpx == false) {
   1b95a:	2b00      	cmp	r3, #0
   1b95c:	d15c      	bne.n	1ba18 <lv_draw_letter+0x3d4>
                if(letter_px != 0) {
   1b95e:	b30a      	cbz	r2, 1b9a4 <lv_draw_letter+0x360>
                    if(opa == LV_OPA_COVER) {
   1b960:	9b08      	ldr	r3, [sp, #32]
   1b962:	2bff      	cmp	r3, #255	; 0xff
   1b964:	d134      	bne.n	1b9d0 <lv_draw_letter+0x38c>
                        px_opa = g.bpp == 8 ? letter_px : bpp_opa_table[letter_px];
   1b966:	2908      	cmp	r1, #8
   1b968:	d001      	beq.n	1b96e <lv_draw_letter+0x32a>
   1b96a:	9b05      	ldr	r3, [sp, #20]
   1b96c:	5c9a      	ldrb	r2, [r3, r2]
                    if(disp->driver.set_px_cb) {
   1b96e:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1b970:	695b      	ldr	r3, [r3, #20]
   1b972:	461d      	mov	r5, r3
   1b974:	2b00      	cmp	r3, #0
   1b976:	d035      	beq.n	1b9e4 <lv_draw_letter+0x3a0>
                        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width,
   1b978:	9b07      	ldr	r3, [sp, #28]
   1b97a:	990e      	ldr	r1, [sp, #56]	; 0x38
   1b97c:	8a1b      	ldrh	r3, [r3, #16]
   1b97e:	9202      	str	r2, [sp, #8]
   1b980:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
   1b982:	9201      	str	r2, [sp, #4]
   1b984:	9a07      	ldr	r2, [sp, #28]
   1b986:	9811      	ldr	r0, [sp, #68]	; 0x44
   1b988:	8a52      	ldrh	r2, [r2, #18]
   1b98a:	eba8 0202 	sub.w	r2, r8, r2
   1b98e:	eba9 0303 	sub.w	r3, r9, r3
   1b992:	443a      	add	r2, r7
   1b994:	440b      	add	r3, r1
   1b996:	b212      	sxth	r2, r2
   1b998:	9907      	ldr	r1, [sp, #28]
   1b99a:	9200      	str	r2, [sp, #0]
   1b99c:	b21b      	sxth	r3, r3
   1b99e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1b9a0:	6889      	ldr	r1, [r1, #8]
   1b9a2:	47a8      	blx	r5
                vdb_buf_tmp++;
   1b9a4:	3404      	adds	r4, #4
            if(col_bit < 8 - g.bpp) {
   1b9a6:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
   1b9aa:	9904      	ldr	r1, [sp, #16]
   1b9ac:	f1c3 0208 	rsb	r2, r3, #8
   1b9b0:	4291      	cmp	r1, r2
   1b9b2:	f280 8081 	bge.w	1bab8 <lv_draw_letter+0x474>
                col_bit += g.bpp;
   1b9b6:	460a      	mov	r2, r1
   1b9b8:	441a      	add	r2, r3
   1b9ba:	b292      	uxth	r2, r2
   1b9bc:	9204      	str	r2, [sp, #16]
                bitmask = bitmask >> g.bpp;
   1b9be:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1b9c0:	411a      	asrs	r2, r3
   1b9c2:	b2d3      	uxtb	r3, r2
   1b9c4:	930d      	str	r3, [sp, #52]	; 0x34
        for(col = col_start; col < col_end; col++) {
   1b9c6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b9c8:	3301      	adds	r3, #1
   1b9ca:	b21b      	sxth	r3, r3
   1b9cc:	930e      	str	r3, [sp, #56]	; 0x38
   1b9ce:	e768      	b.n	1b8a2 <lv_draw_letter+0x25e>
                        px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
   1b9d0:	2908      	cmp	r1, #8
                                : (uint16_t)((uint16_t)bpp_opa_table[letter_px] * opa) >> 8;
   1b9d2:	bf1c      	itt	ne
   1b9d4:	9b05      	ldrne	r3, [sp, #20]
   1b9d6:	5c9a      	ldrbne	r2, [r3, r2]
   1b9d8:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1b9da:	fb12 f203 	smulbb	r2, r2, r3
                        px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
   1b9de:	f3c2 2207 	ubfx	r2, r2, #8, #8
   1b9e2:	e7c4      	b.n	1b96e <lv_draw_letter+0x32a>
                    } else if(vdb_buf_tmp->full != color.full) {
   1b9e4:	6823      	ldr	r3, [r4, #0]
   1b9e6:	992c      	ldr	r1, [sp, #176]	; 0xb0
   1b9e8:	428b      	cmp	r3, r1
   1b9ea:	d0db      	beq.n	1b9a4 <lv_draw_letter+0x360>
                        if(px_opa > LV_OPA_MAX) {
   1b9ec:	2afb      	cmp	r2, #251	; 0xfb
   1b9ee:	d901      	bls.n	1b9f4 <lv_draw_letter+0x3b0>
                            *vdb_buf_tmp = color;
   1b9f0:	6021      	str	r1, [r4, #0]
   1b9f2:	e7d7      	b.n	1b9a4 <lv_draw_letter+0x360>
                        } else if(px_opa > LV_OPA_MIN) {
   1b9f4:	2a10      	cmp	r2, #16
   1b9f6:	d9d5      	bls.n	1b9a4 <lv_draw_letter+0x360>
                                *vdb_buf_tmp = lv_color_mix(color, *vdb_buf_tmp, px_opa);
   1b9f8:	7823      	ldrb	r3, [r4, #0]
   1b9fa:	9202      	str	r2, [sp, #8]
   1b9fc:	78a2      	ldrb	r2, [r4, #2]
   1b9fe:	9201      	str	r2, [sp, #4]
   1ba00:	992c      	ldr	r1, [sp, #176]	; 0xb0
   1ba02:	982c      	ldr	r0, [sp, #176]	; 0xb0
   1ba04:	7862      	ldrb	r2, [r4, #1]
   1ba06:	9200      	str	r2, [sp, #0]
   1ba08:	f3c1 2107 	ubfx	r1, r1, #8, #8
   1ba0c:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   1ba0e:	b2c0      	uxtb	r0, r0
   1ba10:	f00a f97a 	bl	25d08 <lv_color_mix.isra.0>
   1ba14:	6020      	str	r0, [r4, #0]
   1ba16:	e7c5      	b.n	1b9a4 <lv_draw_letter+0x360>
                if(letter_px != 0) {
   1ba18:	b132      	cbz	r2, 1ba28 <lv_draw_letter+0x3e4>
                    if(opa == LV_OPA_COVER) {
   1ba1a:	9b08      	ldr	r3, [sp, #32]
   1ba1c:	2bff      	cmp	r3, #255	; 0xff
   1ba1e:	d11b      	bne.n	1ba58 <lv_draw_letter+0x414>
                        px_opa = g.bpp == 8 ? letter_px : bpp_opa_table[letter_px];
   1ba20:	2908      	cmp	r1, #8
   1ba22:	d001      	beq.n	1ba28 <lv_draw_letter+0x3e4>
   1ba24:	9b05      	ldr	r3, [sp, #20]
   1ba26:	5c9a      	ldrb	r2, [r3, r2]
                    font_rgb[sub_px_cnt] = 0;
   1ba28:	ab22      	add	r3, sp, #136	; 0x88
   1ba2a:	4433      	add	r3, r6
                sub_px_cnt ++;
   1ba2c:	3601      	adds	r6, #1
   1ba2e:	b2f6      	uxtb	r6, r6
                if(sub_px_cnt == 3) {
   1ba30:	2e03      	cmp	r6, #3
                    font_rgb[sub_px_cnt] = 0;
   1ba32:	f803 2c20 	strb.w	r2, [r3, #-32]
                if(sub_px_cnt == 3) {
   1ba36:	d1b6      	bne.n	1b9a6 <lv_draw_letter+0x362>
                    if(font_rgb[0] == 0 && font_rgb[1] == 0 && font_rgb[2] == 0) {
   1ba38:	f89d c068 	ldrb.w	ip, [sp, #104]	; 0x68
   1ba3c:	f89d 2069 	ldrb.w	r2, [sp, #105]	; 0x69
   1ba40:	f89d 006a 	ldrb.w	r0, [sp, #106]	; 0x6a
   1ba44:	ea4c 0302 	orr.w	r3, ip, r2
   1ba48:	4303      	orrs	r3, r0
   1ba4a:	d10f      	bne.n	1ba6c <lv_draw_letter+0x428>
                        res_color = *vdb_buf_tmp;
   1ba4c:	f8d4 b000 	ldr.w	fp, [r4]
                        vdb_buf_tmp->full = res_color.full;
   1ba50:	f844 bb04 	str.w	fp, [r4], #4
                    sub_px_cnt = 0;
   1ba54:	2600      	movs	r6, #0
   1ba56:	e7a6      	b.n	1b9a6 <lv_draw_letter+0x362>
                        px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
   1ba58:	2908      	cmp	r1, #8
                                : (uint16_t)((uint16_t)bpp_opa_table[letter_px] * opa) >> 8;
   1ba5a:	bf1c      	itt	ne
   1ba5c:	9b05      	ldrne	r3, [sp, #20]
   1ba5e:	5c9a      	ldrbne	r2, [r3, r2]
   1ba60:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1ba62:	fb12 f203 	smulbb	r2, r2, r3
                        px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
   1ba66:	f3c2 2207 	ubfx	r2, r2, #8, #8
                    font_rgb[sub_px_cnt] = px_opa;
   1ba6a:	e7dd      	b.n	1ba28 <lv_draw_letter+0x3e4>
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8);
   1ba6c:	9d12      	ldr	r5, [sp, #72]	; 0x48
   1ba6e:	f894 e002 	ldrb.w	lr, [r4, #2]
                        uint8_t bg_rgb[3] = {LV_COLOR_GET_R(*vdb_buf_tmp), LV_COLOR_GET_G(*vdb_buf_tmp), LV_COLOR_GET_B(*vdb_buf_tmp)};
   1ba72:	7821      	ldrb	r1, [r4, #0]
   1ba74:	7863      	ldrb	r3, [r4, #1]
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8);
   1ba76:	f1cc 06ff 	rsb	r6, ip, #255	; 0xff
   1ba7a:	fb15 fc0c 	smulbb	ip, r5, ip
                        LV_COLOR_SET_B(res_color, (uint16_t)((uint16_t)txt_rgb[2] * font_rgb[2] + (bg_rgb[2] * (255 - font_rgb[2]))) >> 8);
   1ba7e:	9d14      	ldr	r5, [sp, #80]	; 0x50
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8);
   1ba80:	fb0e cc06 	mla	ip, lr, r6, ip
                        LV_COLOR_SET_B(res_color, (uint16_t)((uint16_t)txt_rgb[2] * font_rgb[2] + (bg_rgb[2] * (255 - font_rgb[2]))) >> 8);
   1ba84:	f1c0 06ff 	rsb	r6, r0, #255	; 0xff
   1ba88:	fb15 f000 	smulbb	r0, r5, r0
   1ba8c:	fb06 0101 	mla	r1, r6, r1, r0
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8);
   1ba90:	f3cc 2c07 	ubfx	ip, ip, #8, #8
                        LV_COLOR_SET_G(res_color, (uint16_t)((uint16_t)txt_rgb[1] * font_rgb[1] + (bg_rgb[1] * (255 - font_rgb[1]))) >> 8);
   1ba94:	9813      	ldr	r0, [sp, #76]	; 0x4c
                        LV_COLOR_SET_B(res_color, (uint16_t)((uint16_t)txt_rgb[2] * font_rgb[2] + (bg_rgb[2] * (255 - font_rgb[2]))) >> 8);
   1ba96:	f3c1 2107 	ubfx	r1, r1, #8, #8
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8);
   1ba9a:	f36c 4b17 	bfi	fp, ip, #16, #8
                        LV_COLOR_SET_B(res_color, (uint16_t)((uint16_t)txt_rgb[2] * font_rgb[2] + (bg_rgb[2] * (255 - font_rgb[2]))) >> 8);
   1ba9e:	f361 0b07 	bfi	fp, r1, #0, #8
                        LV_COLOR_SET_G(res_color, (uint16_t)((uint16_t)txt_rgb[1] * font_rgb[1] + (bg_rgb[1] * (255 - font_rgb[1]))) >> 8);
   1baa2:	f1c2 01ff 	rsb	r1, r2, #255	; 0xff
   1baa6:	fb10 f202 	smulbb	r2, r0, r2
   1baaa:	fb01 2303 	mla	r3, r1, r3, r2
   1baae:	f3c3 2307 	ubfx	r3, r3, #8, #8
   1bab2:	f363 2b0f 	bfi	fp, r3, #8, #8
   1bab6:	e7cb      	b.n	1ba50 <lv_draw_letter+0x40c>
                map_p++;
   1bab8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1baba:	3301      	adds	r3, #1
   1babc:	930a      	str	r3, [sp, #40]	; 0x28
                bitmask = bitmask_init;
   1babe:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1bac0:	930d      	str	r3, [sp, #52]	; 0x34
                col_bit = 0;
   1bac2:	2300      	movs	r3, #0
   1bac4:	9304      	str	r3, [sp, #16]
   1bac6:	e77e      	b.n	1b9c6 <lv_draw_letter+0x382>
        else vdb_buf_tmp += vdb_width - (col_end - col_start);
   1bac8:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1baca:	e705      	b.n	1b8d8 <lv_draw_letter+0x294>

0001bacc <lv_draw_get_buf>:
 * Be careful to not use the buffer while other processes are using it.
 * @param size the required size
 */
void * lv_draw_get_buf(uint32_t size)
{
    if(size <= draw_buf_size) return LV_GC_ROOT(_lv_draw_buf);
   1bacc:	4a09      	ldr	r2, [pc, #36]	; (1baf4 <lv_draw_get_buf+0x28>)
{
   1bace:	b538      	push	{r3, r4, r5, lr}
    if(size <= draw_buf_size) return LV_GC_ROOT(_lv_draw_buf);
   1bad0:	6815      	ldr	r5, [r2, #0]
   1bad2:	4c09      	ldr	r4, [pc, #36]	; (1baf8 <lv_draw_get_buf+0x2c>)
   1bad4:	4285      	cmp	r5, r0
{
   1bad6:	4601      	mov	r1, r0
   1bad8:	6823      	ldr	r3, [r4, #0]
    if(size <= draw_buf_size) return LV_GC_ROOT(_lv_draw_buf);
   1bada:	d205      	bcs.n	1bae8 <lv_draw_get_buf+0x1c>

    LV_LOG_TRACE("lv_draw_get_buf: allocate");

    draw_buf_size = size;
   1badc:	6010      	str	r0, [r2, #0]

    if(LV_GC_ROOT(_lv_draw_buf) == NULL) {
   1bade:	b92b      	cbnz	r3, 1baec <lv_draw_get_buf+0x20>
        LV_GC_ROOT(_lv_draw_buf) = lv_mem_alloc(size);
   1bae0:	f001 f8f8 	bl	1ccd4 <lv_mem_alloc>
        LV_ASSERT_MEM(LV_GC_ROOT(_lv_draw_buf));
        return LV_GC_ROOT(_lv_draw_buf);
    }

    LV_GC_ROOT(_lv_draw_buf) = lv_mem_realloc(LV_GC_ROOT(_lv_draw_buf), size);
   1bae4:	4603      	mov	r3, r0
   1bae6:	6020      	str	r0, [r4, #0]
    LV_ASSERT_MEM(LV_GC_ROOT(_lv_draw_buf));
    return LV_GC_ROOT(_lv_draw_buf);
}
   1bae8:	4618      	mov	r0, r3
   1baea:	bd38      	pop	{r3, r4, r5, pc}
    LV_GC_ROOT(_lv_draw_buf) = lv_mem_realloc(LV_GC_ROOT(_lv_draw_buf), size);
   1baec:	4618      	mov	r0, r3
   1baee:	f001 f935 	bl	1cd5c <lv_mem_realloc>
   1baf2:	e7f7      	b.n	1bae4 <lv_draw_get_buf+0x18>
   1baf4:	20001ea8 	.word	0x20001ea8
   1baf8:	20001ed0 	.word	0x20001ed0

0001bafc <lv_draw_free_buf>:

/**
 * Free the draw buffer
 */
void lv_draw_free_buf(void)
{
   1bafc:	b510      	push	{r4, lr}
    if(LV_GC_ROOT(_lv_draw_buf)) {
   1bafe:	4c05      	ldr	r4, [pc, #20]	; (1bb14 <lv_draw_free_buf+0x18>)
   1bb00:	6820      	ldr	r0, [r4, #0]
   1bb02:	b128      	cbz	r0, 1bb10 <lv_draw_free_buf+0x14>
        lv_mem_free(LV_GC_ROOT(_lv_draw_buf));
   1bb04:	f001 f90c 	bl	1cd20 <lv_mem_free>
        LV_GC_ROOT(_lv_draw_buf) = NULL;
        draw_buf_size = 0;
   1bb08:	4a03      	ldr	r2, [pc, #12]	; (1bb18 <lv_draw_free_buf+0x1c>)
        LV_GC_ROOT(_lv_draw_buf) = NULL;
   1bb0a:	2300      	movs	r3, #0
   1bb0c:	6023      	str	r3, [r4, #0]
        draw_buf_size = 0;
   1bb0e:	6013      	str	r3, [r2, #0]
    }
}
   1bb10:	bd10      	pop	{r4, pc}
   1bb12:	bf00      	nop
   1bb14:	20001ed0 	.word	0x20001ed0
   1bb18:	20001ea8 	.word	0x20001ea8

0001bb1c <hex_char_to_num>:
 * Convert a hexadecimal characters to a number (0..15)
 * @param hex Pointer to a hexadecimal character (0..9, A..F)
 * @return the numerical value of `hex` or 0 on error
 */
static uint8_t hex_char_to_num(char hex)
{
   1bb1c:	4603      	mov	r3, r0
    uint8_t result = 0;

    if(hex >= '0' && hex <= '9') {
   1bb1e:	3830      	subs	r0, #48	; 0x30
   1bb20:	b2c0      	uxtb	r0, r0
   1bb22:	2809      	cmp	r0, #9
   1bb24:	d90b      	bls.n	1bb3e <hex_char_to_num+0x22>
        result = hex - '0';
    } else {
        if(hex >= 'a') hex -= 'a' - 'A'; /*Convert to upper case*/
   1bb26:	2b60      	cmp	r3, #96	; 0x60
   1bb28:	bf84      	itt	hi
   1bb2a:	3b20      	subhi	r3, #32
   1bb2c:	b2db      	uxtbhi	r3, r3

        switch(hex) {
   1bb2e:	3b41      	subs	r3, #65	; 0x41
   1bb30:	b2db      	uxtb	r3, r3
   1bb32:	2b05      	cmp	r3, #5
   1bb34:	d802      	bhi.n	1bb3c <hex_char_to_num+0x20>
   1bb36:	4a02      	ldr	r2, [pc, #8]	; (1bb40 <hex_char_to_num+0x24>)
   1bb38:	5cd0      	ldrb	r0, [r2, r3]
   1bb3a:	4770      	bx	lr
{
   1bb3c:	2000      	movs	r0, #0
        default: result = 0; break;
        }
    }

    return result;
}
   1bb3e:	4770      	bx	lr
   1bb40:	00065663 	.word	0x00065663

0001bb44 <lv_draw_label>:
{
   1bb44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1bb48:	b0ad      	sub	sp, #180	; 0xb4
   1bb4a:	4606      	mov	r6, r0
   1bb4c:	9305      	str	r3, [sp, #20]
    if (txt[0] == '\0')  return;
   1bb4e:	9b36      	ldr	r3, [sp, #216]	; 0xd8
{
   1bb50:	910b      	str	r1, [sp, #44]	; 0x2c
    if (txt[0] == '\0')  return;
   1bb52:	781b      	ldrb	r3, [r3, #0]
{
   1bb54:	f89d a0dc 	ldrb.w	sl, [sp, #220]	; 0xdc
   1bb58:	9f3a      	ldr	r7, [sp, #232]	; 0xe8
   1bb5a:	4615      	mov	r5, r2
    if (txt[0] == '\0')  return;
   1bb5c:	2b00      	cmp	r3, #0
   1bb5e:	f000 80a7 	beq.w	1bcb0 <lv_draw_label+0x16c>
    const lv_font_t * font = style->text.font;
   1bb62:	6b53      	ldr	r3, [r2, #52]	; 0x34
   1bb64:	9304      	str	r3, [sp, #16]
    if((flag & LV_TXT_FLAG_EXPAND) == 0) {
   1bb66:	f01a 0f02 	tst.w	sl, #2
   1bb6a:	f040 80a4 	bne.w	1bcb6 <lv_draw_label+0x172>
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1bb6e:	8883      	ldrh	r3, [r0, #4]
   1bb70:	8802      	ldrh	r2, [r0, #0]
   1bb72:	3301      	adds	r3, #1
   1bb74:	1a9b      	subs	r3, r3, r2
   1bb76:	b21b      	sxth	r3, r3
        w = p.x;
   1bb78:	9308      	str	r3, [sp, #32]
    lv_coord_t line_height = lv_font_get_line_height(font) + style->text.line_space;
   1bb7a:	9b04      	ldr	r3, [sp, #16]
   1bb7c:	8f6a      	ldrh	r2, [r5, #58]	; 0x3a
   1bb7e:	7a1b      	ldrb	r3, [r3, #8]
   1bb80:	4413      	add	r3, r2
   1bb82:	b21b      	sxth	r3, r3
   1bb84:	9307      	str	r3, [sp, #28]
    pos.x = coords->x1;
   1bb86:	8833      	ldrh	r3, [r6, #0]
   1bb88:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
    if(offset != NULL) {
   1bb8c:	9b38      	ldr	r3, [sp, #224]	; 0xe0
    pos.y = coords->y1;
   1bb8e:	f9b6 2002 	ldrsh.w	r2, [r6, #2]
   1bb92:	f8ad 2052 	strh.w	r2, [sp, #82]	; 0x52
    if(offset != NULL) {
   1bb96:	2b00      	cmp	r3, #0
   1bb98:	f000 8212 	beq.w	1bfc0 <lv_draw_label+0x47c>
        x_ofs = offset->x;
   1bb9c:	f9b3 3000 	ldrsh.w	r3, [r3]
   1bba0:	930e      	str	r3, [sp, #56]	; 0x38
        y_ofs = offset->y;
   1bba2:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   1bba4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
        pos.y += y_ofs;
   1bba8:	18d1      	adds	r1, r2, r3
   1bbaa:	f8ad 1052 	strh.w	r1, [sp, #82]	; 0x52
    if(hint && y_ofs == 0 && coords->y1 < 0) {
   1bbae:	2f00      	cmp	r7, #0
   1bbb0:	f000 820a 	beq.w	1bfc8 <lv_draw_label+0x484>
   1bbb4:	2b00      	cmp	r3, #0
   1bbb6:	f040 8207 	bne.w	1bfc8 <lv_draw_label+0x484>
   1bbba:	2a00      	cmp	r2, #0
   1bbbc:	f280 8204 	bge.w	1bfc8 <lv_draw_label+0x484>
        if(LV_MATH_ABS(hint->coord_y - coords->y1) > LV_LABEL_HINT_UPDATE_TH - 2 * line_height) {
   1bbc0:	68bb      	ldr	r3, [r7, #8]
   1bbc2:	1a9b      	subs	r3, r3, r2
   1bbc4:	9a07      	ldr	r2, [sp, #28]
   1bbc6:	2b00      	cmp	r3, #0
   1bbc8:	bfb8      	it	lt
   1bbca:	425b      	neglt	r3, r3
   1bbcc:	f5c2 7200 	rsb	r2, r2, #512	; 0x200
   1bbd0:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
            hint->line_start = -1;
   1bbd4:	bfc4      	itt	gt
   1bbd6:	f04f 33ff 	movgt.w	r3, #4294967295	; 0xffffffff
   1bbda:	603b      	strgt	r3, [r7, #0]
        last_line_start = hint->line_start;
   1bbdc:	683c      	ldr	r4, [r7, #0]
    if(hint && last_line_start >= 0) {
   1bbde:	2c00      	cmp	r4, #0
   1bbe0:	f2c0 81f2 	blt.w	1bfc8 <lv_draw_label+0x484>
        pos.y += hint->y;
   1bbe4:	f8bd 2052 	ldrh.w	r2, [sp, #82]	; 0x52
   1bbe8:	687b      	ldr	r3, [r7, #4]
   1bbea:	4413      	add	r3, r2
   1bbec:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
    uint32_t line_end = line_start + lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
   1bbf0:	9836      	ldr	r0, [sp, #216]	; 0xd8
   1bbf2:	f8cd a000 	str.w	sl, [sp]
   1bbf6:	9b08      	ldr	r3, [sp, #32]
   1bbf8:	f9b5 2038 	ldrsh.w	r2, [r5, #56]	; 0x38
   1bbfc:	9904      	ldr	r1, [sp, #16]
   1bbfe:	4420      	add	r0, r4
   1bc00:	f001 f92e 	bl	1ce60 <lv_txt_get_next_line>
   1bc04:	eb00 0804 	add.w	r8, r0, r4
    while(pos.y + line_height < mask->y1) {
   1bc08:	9a07      	ldr	r2, [sp, #28]
   1bc0a:	f9bd 3052 	ldrsh.w	r3, [sp, #82]	; 0x52
   1bc0e:	4413      	add	r3, r2
   1bc10:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1bc12:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
   1bc16:	4293      	cmp	r3, r2
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
   1bc18:	9b36      	ldr	r3, [sp, #216]	; 0xd8
    while(pos.y + line_height < mask->y1) {
   1bc1a:	db61      	blt.n	1bce0 <lv_draw_label+0x19c>
    if(flag & LV_TXT_FLAG_CENTER) {
   1bc1c:	1918      	adds	r0, r3, r4
   1bc1e:	f01a 0304 	ands.w	r3, sl, #4
   1bc22:	9312      	str	r3, [sp, #72]	; 0x48
   1bc24:	f000 8084 	beq.w	1bd30 <lv_draw_label+0x1ec>
        line_width = lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
   1bc28:	eba8 0104 	sub.w	r1, r8, r4
   1bc2c:	f9b5 3038 	ldrsh.w	r3, [r5, #56]	; 0x38
   1bc30:	9a04      	ldr	r2, [sp, #16]
   1bc32:	f8cd a000 	str.w	sl, [sp]
   1bc36:	b289      	uxth	r1, r1
   1bc38:	f001 f8c2 	bl	1cdc0 <lv_txt_get_width>
   1bc3c:	88b3      	ldrh	r3, [r6, #4]
   1bc3e:	8832      	ldrh	r2, [r6, #0]
   1bc40:	3301      	adds	r3, #1
   1bc42:	1a9b      	subs	r3, r3, r2
        pos.x += (lv_area_get_width(coords) - line_width) / 2;
   1bc44:	b21b      	sxth	r3, r3
   1bc46:	1a18      	subs	r0, r3, r0
   1bc48:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
   1bc4c:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
   1bc50:	eb03 0060 	add.w	r0, r3, r0, asr #1
        pos.x += lv_area_get_width(coords) - line_width;
   1bc54:	f8ad 0050 	strh.w	r0, [sp, #80]	; 0x50
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->text.opa : (uint16_t)((uint16_t)style->text.opa * opa_scale) >> 8;
   1bc58:	f895 303c 	ldrb.w	r3, [r5, #60]	; 0x3c
   1bc5c:	9309      	str	r3, [sp, #36]	; 0x24
   1bc5e:	9b05      	ldr	r3, [sp, #20]
   1bc60:	2bff      	cmp	r3, #255	; 0xff
   1bc62:	d004      	beq.n	1bc6e <lv_draw_label+0x12a>
   1bc64:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1bc66:	9a05      	ldr	r2, [sp, #20]
   1bc68:	4353      	muls	r3, r2
   1bc6a:	0a1b      	lsrs	r3, r3, #8
   1bc6c:	9309      	str	r3, [sp, #36]	; 0x24
    if(sel) {
   1bc6e:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   1bc70:	2b00      	cmp	r3, #0
   1bc72:	d073      	beq.n	1bd5c <lv_draw_label+0x218>
        sel_start = sel->start;
   1bc74:	881b      	ldrh	r3, [r3, #0]
   1bc76:	9306      	str	r3, [sp, #24]
        sel_end = sel->end;
   1bc78:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   1bc7a:	885b      	ldrh	r3, [r3, #2]
   1bc7c:	9305      	str	r3, [sp, #20]
        if(sel_start > sel_end) {
   1bc7e:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
   1bc82:	4293      	cmp	r3, r2
   1bc84:	d901      	bls.n	1bc8a <lv_draw_label+0x146>
   1bc86:	e9cd 3205 	strd	r3, r2, [sp, #20]
    lv_style_copy(&sel_style, &lv_style_plain_color);
   1bc8a:	499b      	ldr	r1, [pc, #620]	; (1bef8 <lv_draw_label+0x3b4>)
   1bc8c:	a818      	add	r0, sp, #96	; 0x60
   1bc8e:	f00a f838 	bl	25d02 <lv_style_copy>
    sel_style.body.main_color = sel_style.body.grad_color = style->text.sel_color;
   1bc92:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   1bc94:	e9cd 3319 	strd	r3, r3, [sp, #100]	; 0x64
    uint16_t par_start = 0;
   1bc98:	2300      	movs	r3, #0
   1bc9a:	930d      	str	r3, [sp, #52]	; 0x34
   1bc9c:	f00a 0301 	and.w	r3, sl, #1
   1bca0:	9311      	str	r3, [sp, #68]	; 0x44
    while(txt[line_start] != '\0') {
   1bca2:	9b36      	ldr	r3, [sp, #216]	; 0xd8
   1bca4:	4423      	add	r3, r4
   1bca6:	930c      	str	r3, [sp, #48]	; 0x30
   1bca8:	9b36      	ldr	r3, [sp, #216]	; 0xd8
   1bcaa:	5d1b      	ldrb	r3, [r3, r4]
   1bcac:	2b00      	cmp	r3, #0
   1bcae:	d15a      	bne.n	1bd66 <lv_draw_label+0x222>
}
   1bcb0:	b02d      	add	sp, #180	; 0xb4
   1bcb2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        lv_txt_get_size(&p, txt, style->text.font, style->text.letter_space, style->text.line_space, LV_COORD_MAX,
   1bcb6:	f647 4318 	movw	r3, #31768	; 0x7c18
   1bcba:	f8cd a008 	str.w	sl, [sp, #8]
   1bcbe:	9301      	str	r3, [sp, #4]
   1bcc0:	f9b2 303a 	ldrsh.w	r3, [r2, #58]	; 0x3a
   1bcc4:	9300      	str	r3, [sp, #0]
   1bcc6:	f9b2 3038 	ldrsh.w	r3, [r2, #56]	; 0x38
   1bcca:	9936      	ldr	r1, [sp, #216]	; 0xd8
   1bccc:	9a04      	ldr	r2, [sp, #16]
   1bcce:	a818      	add	r0, sp, #96	; 0x60
   1bcd0:	f00b fbc4 	bl	2745c <lv_txt_get_size>
        w = p.x;
   1bcd4:	f9bd 3060 	ldrsh.w	r3, [sp, #96]	; 0x60
   1bcd8:	e74e      	b.n	1bb78 <lv_draw_label+0x34>
    lv_coord_t x_ofs = 0;
   1bcda:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   1bcdc:	930e      	str	r3, [sp, #56]	; 0x38
   1bcde:	e76c      	b.n	1bbba <lv_draw_label+0x76>
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
   1bce0:	eb03 0908 	add.w	r9, r3, r8
   1bce4:	f9b5 2038 	ldrsh.w	r2, [r5, #56]	; 0x38
   1bce8:	9b08      	ldr	r3, [sp, #32]
   1bcea:	f8cd a000 	str.w	sl, [sp]
   1bcee:	9904      	ldr	r1, [sp, #16]
   1bcf0:	4648      	mov	r0, r9
   1bcf2:	f001 f8b5 	bl	1ce60 <lv_txt_get_next_line>
        pos.y += line_height;
   1bcf6:	f8bd 3052 	ldrh.w	r3, [sp, #82]	; 0x52
   1bcfa:	9a07      	ldr	r2, [sp, #28]
   1bcfc:	4413      	add	r3, r2
   1bcfe:	b21b      	sxth	r3, r3
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
   1bd00:	4440      	add	r0, r8
        pos.y += line_height;
   1bd02:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
        if(hint && pos.y >= -LV_LABEL_HINT_UPDATE_TH && hint->line_start < 0) {
   1bd06:	b167      	cbz	r7, 1bd22 <lv_draw_label+0x1de>
   1bd08:	f513 6f80 	cmn.w	r3, #1024	; 0x400
   1bd0c:	db09      	blt.n	1bd22 <lv_draw_label+0x1de>
   1bd0e:	683a      	ldr	r2, [r7, #0]
   1bd10:	2a00      	cmp	r2, #0
            hint->y          = pos.y - coords->y1;
   1bd12:	bfbf      	itttt	lt
   1bd14:	f9b6 2002 	ldrshlt.w	r2, [r6, #2]
            hint->line_start = line_start;
   1bd18:	f8c7 8000 	strlt.w	r8, [r7]
            hint->y          = pos.y - coords->y1;
   1bd1c:	1a9b      	sublt	r3, r3, r2
            hint->coord_y    = coords->y1;
   1bd1e:	e9c7 3201 	strdlt	r3, r2, [r7, #4]
        if(txt[line_start] == '\0') return;
   1bd22:	f899 3000 	ldrb.w	r3, [r9]
   1bd26:	4644      	mov	r4, r8
   1bd28:	2b00      	cmp	r3, #0
   1bd2a:	d0c1      	beq.n	1bcb0 <lv_draw_label+0x16c>
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
   1bd2c:	4680      	mov	r8, r0
   1bd2e:	e76b      	b.n	1bc08 <lv_draw_label+0xc4>
    else if(flag & LV_TXT_FLAG_RIGHT) {
   1bd30:	f01a 0f08 	tst.w	sl, #8
   1bd34:	d090      	beq.n	1bc58 <lv_draw_label+0x114>
        line_width = lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
   1bd36:	eba8 0104 	sub.w	r1, r8, r4
   1bd3a:	f9b5 3038 	ldrsh.w	r3, [r5, #56]	; 0x38
   1bd3e:	9a04      	ldr	r2, [sp, #16]
   1bd40:	f8cd a000 	str.w	sl, [sp]
   1bd44:	b289      	uxth	r1, r1
   1bd46:	f001 f83b 	bl	1cdc0 <lv_txt_get_width>
        pos.x += lv_area_get_width(coords) - line_width;
   1bd4a:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
   1bd4e:	88b2      	ldrh	r2, [r6, #4]
   1bd50:	3301      	adds	r3, #1
   1bd52:	4413      	add	r3, r2
   1bd54:	8832      	ldrh	r2, [r6, #0]
   1bd56:	1a9b      	subs	r3, r3, r2
   1bd58:	1a18      	subs	r0, r3, r0
   1bd5a:	e77b      	b.n	1bc54 <lv_draw_label+0x110>
    uint16_t sel_end = 0xFFFF;
   1bd5c:	f64f 73ff 	movw	r3, #65535	; 0xffff
    uint16_t sel_start = 0xFFFF;
   1bd60:	e9cd 3305 	strd	r3, r3, [sp, #20]
   1bd64:	e791      	b.n	1bc8a <lv_draw_label+0x146>
        if(offset != NULL) {
   1bd66:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   1bd68:	b12b      	cbz	r3, 1bd76 <lv_draw_label+0x232>
            pos.x += x_ofs;
   1bd6a:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
   1bd6e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1bd70:	4413      	add	r3, r2
   1bd72:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
        i         = 0;
   1bd76:	2700      	movs	r7, #0
   1bd78:	9715      	str	r7, [sp, #84]	; 0x54
        while(i < line_end - line_start) {
   1bd7a:	9915      	ldr	r1, [sp, #84]	; 0x54
   1bd7c:	eba8 0304 	sub.w	r3, r8, r4
   1bd80:	428b      	cmp	r3, r1
   1bd82:	d83b      	bhi.n	1bdfc <lv_draw_label+0x2b8>
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
   1bd84:	9b36      	ldr	r3, [sp, #216]	; 0xd8
   1bd86:	9904      	ldr	r1, [sp, #16]
   1bd88:	f8cd a000 	str.w	sl, [sp]
   1bd8c:	eb03 0408 	add.w	r4, r3, r8
   1bd90:	f9b5 2038 	ldrsh.w	r2, [r5, #56]	; 0x38
   1bd94:	9b08      	ldr	r3, [sp, #32]
   1bd96:	4620      	mov	r0, r4
   1bd98:	f001 f862 	bl	1ce60 <lv_txt_get_next_line>
        pos.x = coords->x1;
   1bd9c:	8833      	ldrh	r3, [r6, #0]
   1bd9e:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
        if(flag & LV_TXT_FLAG_CENTER) {
   1bda2:	9b12      	ldr	r3, [sp, #72]	; 0x48
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
   1bda4:	4601      	mov	r1, r0
   1bda6:	eb00 0708 	add.w	r7, r0, r8
        if(flag & LV_TXT_FLAG_CENTER) {
   1bdaa:	2b00      	cmp	r3, #0
   1bdac:	f000 80f3 	beq.w	1bf96 <lv_draw_label+0x452>
                    lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
   1bdb0:	f9b5 3038 	ldrsh.w	r3, [r5, #56]	; 0x38
   1bdb4:	9a04      	ldr	r2, [sp, #16]
   1bdb6:	f8cd a000 	str.w	sl, [sp]
   1bdba:	4620      	mov	r0, r4
   1bdbc:	f001 f800 	bl	1cdc0 <lv_txt_get_width>
   1bdc0:	88b3      	ldrh	r3, [r6, #4]
   1bdc2:	8832      	ldrh	r2, [r6, #0]
   1bdc4:	3301      	adds	r3, #1
   1bdc6:	1a9b      	subs	r3, r3, r2
            pos.x += (lv_area_get_width(coords) - line_width) / 2;
   1bdc8:	b21b      	sxth	r3, r3
   1bdca:	1a18      	subs	r0, r3, r0
   1bdcc:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
   1bdd0:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
   1bdd4:	eb03 0060 	add.w	r0, r3, r0, asr #1
            pos.x += lv_area_get_width(coords) - line_width;
   1bdd8:	f8ad 0050 	strh.w	r0, [sp, #80]	; 0x50
        pos.y += line_height;
   1bddc:	f8bd 3052 	ldrh.w	r3, [sp, #82]	; 0x52
   1bde0:	9a07      	ldr	r2, [sp, #28]
   1bde2:	4413      	add	r3, r2
        if(pos.y > mask->y2) return;
   1bde4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1bde6:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
        pos.y += line_height;
   1bdea:	b21b      	sxth	r3, r3
        if(pos.y > mask->y2) return;
   1bdec:	429a      	cmp	r2, r3
        pos.y += line_height;
   1bdee:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
        line_start = line_end;
   1bdf2:	4644      	mov	r4, r8
        if(pos.y > mask->y2) return;
   1bdf4:	f6ff af5c 	blt.w	1bcb0 <lv_draw_label+0x16c>
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
   1bdf8:	46b8      	mov	r8, r7
   1bdfa:	e752      	b.n	1bca2 <lv_draw_label+0x15e>
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
   1bdfc:	9a06      	ldr	r2, [sp, #24]
   1bdfe:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1be02:	429a      	cmp	r2, r3
   1be04:	d026      	beq.n	1be54 <lv_draw_label+0x310>
   1be06:	9a05      	ldr	r2, [sp, #20]
   1be08:	429a      	cmp	r2, r3
   1be0a:	d023      	beq.n	1be54 <lv_draw_label+0x310>
                logical_char_pos = lv_txt_encoded_get_char_id(txt, line_start + i);
   1be0c:	4b3b      	ldr	r3, [pc, #236]	; (1befc <lv_draw_label+0x3b8>)
   1be0e:	9836      	ldr	r0, [sp, #216]	; 0xd8
   1be10:	681b      	ldr	r3, [r3, #0]
   1be12:	4421      	add	r1, r4
   1be14:	4798      	blx	r3
   1be16:	b283      	uxth	r3, r0
            letter      = lv_txt_encoded_next(bidi_txt, &i);
   1be18:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 1bf00 <lv_draw_label+0x3bc>
   1be1c:	980c      	ldr	r0, [sp, #48]	; 0x30
   1be1e:	f8d9 2000 	ldr.w	r2, [r9]
   1be22:	9310      	str	r3, [sp, #64]	; 0x40
   1be24:	a915      	add	r1, sp, #84	; 0x54
   1be26:	4790      	blx	r2
            letter_next = lv_txt_encoded_next(&bidi_txt[i], NULL);
   1be28:	9b0c      	ldr	r3, [sp, #48]	; 0x30
            letter      = lv_txt_encoded_next(bidi_txt, &i);
   1be2a:	900a      	str	r0, [sp, #40]	; 0x28
            letter_next = lv_txt_encoded_next(&bidi_txt[i], NULL);
   1be2c:	9815      	ldr	r0, [sp, #84]	; 0x54
   1be2e:	f8d9 2000 	ldr.w	r2, [r9]
   1be32:	2100      	movs	r1, #0
   1be34:	4418      	add	r0, r3
   1be36:	4790      	blx	r2
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   1be38:	e9dd 3110 	ldrd	r3, r1, [sp, #64]	; 0x40
            letter_next = lv_txt_encoded_next(&bidi_txt[i], NULL);
   1be3c:	4602      	mov	r2, r0
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   1be3e:	2900      	cmp	r1, #0
   1be40:	d055      	beq.n	1beee <lv_draw_label+0x3aa>
                if(letter == (uint32_t)LV_TXT_COLOR_CMD[0]) {
   1be42:	990a      	ldr	r1, [sp, #40]	; 0x28
   1be44:	2923      	cmp	r1, #35	; 0x23
   1be46:	d10d      	bne.n	1be64 <lv_draw_label+0x320>
                    if(cmd_state == CMD_STATE_WAIT) { /*Start char*/
   1be48:	b937      	cbnz	r7, 1be58 <lv_draw_label+0x314>
                        par_start = i;
   1be4a:	f8bd 3054 	ldrh.w	r3, [sp, #84]	; 0x54
   1be4e:	930d      	str	r3, [sp, #52]	; 0x34
                        cmd_state = CMD_STATE_PAR;
   1be50:	9f11      	ldr	r7, [sp, #68]	; 0x44
                        continue;
   1be52:	e792      	b.n	1bd7a <lv_draw_label+0x236>
            uint16_t logical_char_pos = 0;
   1be54:	2300      	movs	r3, #0
   1be56:	e7df      	b.n	1be18 <lv_draw_label+0x2d4>
                    } else if(cmd_state == CMD_STATE_PAR) { /*Other start char in parameter escaped cmd. char */
   1be58:	2f01      	cmp	r7, #1
   1be5a:	d053      	beq.n	1bf04 <lv_draw_label+0x3c0>
                    } else if(cmd_state == CMD_STATE_IN) { /*Command end */
   1be5c:	2f02      	cmp	r7, #2
   1be5e:	d152      	bne.n	1bf06 <lv_draw_label+0x3c2>
                        cmd_state = CMD_STATE_WAIT;
   1be60:	2700      	movs	r7, #0
   1be62:	e78a      	b.n	1bd7a <lv_draw_label+0x236>
                if(cmd_state == CMD_STATE_PAR) {
   1be64:	2f01      	cmp	r7, #1
   1be66:	d142      	bne.n	1beee <lv_draw_label+0x3aa>
                    if(letter == ' ') {
   1be68:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1be6a:	2b20      	cmp	r3, #32
   1be6c:	d185      	bne.n	1bd7a <lv_draw_label+0x236>
                        if(i - par_start == LABEL_RECOLOR_PAR_LENGTH + 1) {
   1be6e:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1be70:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1be72:	1a9b      	subs	r3, r3, r2
   1be74:	2b07      	cmp	r3, #7
   1be76:	d137      	bne.n	1bee8 <lv_draw_label+0x3a4>
                            memcpy(buf, &bidi_txt[par_start], LABEL_RECOLOR_PAR_LENGTH);
   1be78:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1be7a:	4413      	add	r3, r2
   1be7c:	6818      	ldr	r0, [r3, #0]
   1be7e:	9016      	str	r0, [sp, #88]	; 0x58
   1be80:	889b      	ldrh	r3, [r3, #4]
   1be82:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
   1be86:	f3c0 2207 	ubfx	r2, r0, #8, #8
   1be8a:	f3c0 4907 	ubfx	r9, r0, #16, #8
   1be8e:	f3c0 6707 	ubfx	r7, r0, #24, #8
                            r       = (hex_char_to_num(buf[0]) << 4) + hex_char_to_num(buf[1]);
   1be92:	b2c0      	uxtb	r0, r0
                            memcpy(buf, &bidi_txt[par_start], LABEL_RECOLOR_PAR_LENGTH);
   1be94:	920a      	str	r2, [sp, #40]	; 0x28
                            r       = (hex_char_to_num(buf[0]) << 4) + hex_char_to_num(buf[1]);
   1be96:	f7ff fe41 	bl	1bb1c <hex_char_to_num>
   1be9a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1be9c:	4601      	mov	r1, r0
   1be9e:	4610      	mov	r0, r2
   1bea0:	f7ff fe3c 	bl	1bb1c <hex_char_to_num>
   1bea4:	eb00 1101 	add.w	r1, r0, r1, lsl #4
                            g       = (hex_char_to_num(buf[2]) << 4) + hex_char_to_num(buf[3]);
   1bea8:	4648      	mov	r0, r9
   1beaa:	f7ff fe37 	bl	1bb1c <hex_char_to_num>
   1beae:	4681      	mov	r9, r0
   1beb0:	4638      	mov	r0, r7
   1beb2:	f7ff fe33 	bl	1bb1c <hex_char_to_num>
   1beb6:	eb00 1709 	add.w	r7, r0, r9, lsl #4
                            b       = (hex_char_to_num(buf[4]) << 4) + hex_char_to_num(buf[5]);
   1beba:	f89d 005c 	ldrb.w	r0, [sp, #92]	; 0x5c
   1bebe:	f7ff fe2d 	bl	1bb1c <hex_char_to_num>
   1bec2:	4681      	mov	r9, r0
   1bec4:	f89d 005d 	ldrb.w	r0, [sp, #93]	; 0x5d
   1bec8:	f7ff fe28 	bl	1bb1c <hex_char_to_num>
   1becc:	eb00 1009 	add.w	r0, r0, r9, lsl #4
   1bed0:	f360 0b07 	bfi	fp, r0, #0, #8
   1bed4:	f367 2b0f 	bfi	fp, r7, #8, #8
   1bed8:	f361 4b17 	bfi	fp, r1, #16, #8
   1bedc:	f04b 4b7f 	orr.w	fp, fp, #4278190080	; 0xff000000
   1bee0:	f8cd b03c 	str.w	fp, [sp, #60]	; 0x3c
                        cmd_state = CMD_STATE_IN; /*After the parameter the text is in the command*/
   1bee4:	2702      	movs	r7, #2
   1bee6:	e748      	b.n	1bd7a <lv_draw_label+0x236>
                            recolor.full = style->text.color.full;
   1bee8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   1beea:	930f      	str	r3, [sp, #60]	; 0x3c
   1beec:	e7fa      	b.n	1bee4 <lv_draw_label+0x3a0>
            if(cmd_state == CMD_STATE_IN) color = recolor;
   1beee:	2f02      	cmp	r7, #2
   1bef0:	d109      	bne.n	1bf06 <lv_draw_label+0x3c2>
   1bef2:	990f      	ldr	r1, [sp, #60]	; 0x3c
   1bef4:	e008      	b.n	1bf08 <lv_draw_label+0x3c4>
   1bef6:	bf00      	nop
   1bef8:	20001c78 	.word	0x20001c78
   1befc:	2000ebc8 	.word	0x2000ebc8
   1bf00:	2000ebcc 	.word	0x2000ebcc
                        cmd_state = CMD_STATE_WAIT;
   1bf04:	2700      	movs	r7, #0
            lv_color_t color = style->text.color;
   1bf06:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
            if(cmd_state == CMD_STATE_IN) color = recolor;
   1bf08:	9110      	str	r1, [sp, #64]	; 0x40
            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
   1bf0a:	9804      	ldr	r0, [sp, #16]
   1bf0c:	990a      	ldr	r1, [sp, #40]	; 0x28
   1bf0e:	9313      	str	r3, [sp, #76]	; 0x4c
   1bf10:	f00b fd21 	bl	27956 <lv_font_get_glyph_width>
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
   1bf14:	9b06      	ldr	r3, [sp, #24]
   1bf16:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1bf1a:	4293      	cmp	r3, r2
            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
   1bf1c:	fa0f f980 	sxth.w	r9, r0
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
   1bf20:	d023      	beq.n	1bf6a <lv_draw_label+0x426>
   1bf22:	9b05      	ldr	r3, [sp, #20]
   1bf24:	4293      	cmp	r3, r2
   1bf26:	d020      	beq.n	1bf6a <lv_draw_label+0x426>
                if(logical_char_pos >= sel_start && logical_char_pos < sel_end) {
   1bf28:	9b06      	ldr	r3, [sp, #24]
   1bf2a:	461a      	mov	r2, r3
   1bf2c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1bf2e:	429a      	cmp	r2, r3
   1bf30:	d81b      	bhi.n	1bf6a <lv_draw_label+0x426>
   1bf32:	9a05      	ldr	r2, [sp, #20]
   1bf34:	429a      	cmp	r2, r3
   1bf36:	d918      	bls.n	1bf6a <lv_draw_label+0x426>
                    sel_coords.x1 = pos.x;
   1bf38:	f9bd 3050 	ldrsh.w	r3, [sp, #80]	; 0x50
                    sel_coords.x2 = pos.x + letter_w + style->text.letter_space - 1;
   1bf3c:	8f29      	ldrh	r1, [r5, #56]	; 0x38
                    sel_coords.x1 = pos.x;
   1bf3e:	f8ad 3058 	strh.w	r3, [sp, #88]	; 0x58
                    sel_coords.x2 = pos.x + letter_w + style->text.letter_space - 1;
   1bf42:	3b01      	subs	r3, #1
   1bf44:	440b      	add	r3, r1
                    sel_coords.y1 = pos.y;
   1bf46:	f9bd 2052 	ldrsh.w	r2, [sp, #82]	; 0x52
   1bf4a:	f8ad 205a 	strh.w	r2, [sp, #90]	; 0x5a
                    sel_coords.x2 = pos.x + letter_w + style->text.letter_space - 1;
   1bf4e:	444b      	add	r3, r9
   1bf50:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
                    sel_coords.y2 = pos.y + line_height - 1;
   1bf54:	9b07      	ldr	r3, [sp, #28]
                    lv_draw_rect(&sel_coords, mask, &sel_style, opa);
   1bf56:	990b      	ldr	r1, [sp, #44]	; 0x2c
                    sel_coords.y2 = pos.y + line_height - 1;
   1bf58:	3a01      	subs	r2, #1
   1bf5a:	441a      	add	r2, r3
   1bf5c:	f8ad 205e 	strh.w	r2, [sp, #94]	; 0x5e
                    lv_draw_rect(&sel_coords, mask, &sel_style, opa);
   1bf60:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1bf62:	aa18      	add	r2, sp, #96	; 0x60
   1bf64:	a816      	add	r0, sp, #88	; 0x58
   1bf66:	f00a f96a 	bl	2623e <lv_draw_rect>
            lv_draw_letter(&pos, mask, font, letter, color, opa);
   1bf6a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1bf6c:	9301      	str	r3, [sp, #4]
   1bf6e:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1bf70:	9300      	str	r3, [sp, #0]
   1bf72:	9a04      	ldr	r2, [sp, #16]
   1bf74:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1bf76:	990b      	ldr	r1, [sp, #44]	; 0x2c
   1bf78:	a814      	add	r0, sp, #80	; 0x50
   1bf7a:	f7ff fb63 	bl	1b644 <lv_draw_letter>
            if(letter_w > 0) {
   1bf7e:	f1b9 0f00 	cmp.w	r9, #0
   1bf82:	f77f aefa 	ble.w	1bd7a <lv_draw_label+0x236>
                pos.x += letter_w + style->text.letter_space;
   1bf86:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
   1bf8a:	8f2a      	ldrh	r2, [r5, #56]	; 0x38
   1bf8c:	4413      	add	r3, r2
   1bf8e:	4499      	add	r9, r3
   1bf90:	f8ad 9050 	strh.w	r9, [sp, #80]	; 0x50
   1bf94:	e6f1      	b.n	1bd7a <lv_draw_label+0x236>
        else if(flag & LV_TXT_FLAG_RIGHT) {
   1bf96:	f01a 0f08 	tst.w	sl, #8
   1bf9a:	f43f af1f 	beq.w	1bddc <lv_draw_label+0x298>
                    lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
   1bf9e:	f9b5 3038 	ldrsh.w	r3, [r5, #56]	; 0x38
   1bfa2:	9a04      	ldr	r2, [sp, #16]
   1bfa4:	f8cd a000 	str.w	sl, [sp]
   1bfa8:	4620      	mov	r0, r4
   1bfaa:	f000 ff09 	bl	1cdc0 <lv_txt_get_width>
            pos.x += lv_area_get_width(coords) - line_width;
   1bfae:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
   1bfb2:	88b2      	ldrh	r2, [r6, #4]
   1bfb4:	3301      	adds	r3, #1
   1bfb6:	4413      	add	r3, r2
   1bfb8:	8832      	ldrh	r2, [r6, #0]
   1bfba:	1a9b      	subs	r3, r3, r2
   1bfbc:	1a18      	subs	r0, r3, r0
   1bfbe:	e70b      	b.n	1bdd8 <lv_draw_label+0x294>
    if(hint && y_ofs == 0 && coords->y1 < 0) {
   1bfc0:	2f00      	cmp	r7, #0
   1bfc2:	f47f ae8a 	bne.w	1bcda <lv_draw_label+0x196>
    lv_coord_t x_ofs = 0;
   1bfc6:	970e      	str	r7, [sp, #56]	; 0x38
    uint32_t line_start     = 0;
   1bfc8:	2400      	movs	r4, #0
   1bfca:	e611      	b.n	1bbf0 <lv_draw_label+0xac>

0001bfcc <lv_img_color_format_get_px_size>:
 */
uint8_t lv_img_color_format_get_px_size(lv_img_cf_t cf)
{
    uint8_t px_size = 0;

    switch(cf) {
   1bfcc:	3804      	subs	r0, #4
   1bfce:	b2c0      	uxtb	r0, r0
   1bfd0:	280a      	cmp	r0, #10
   1bfd2:	bf9a      	itte	ls
   1bfd4:	4b01      	ldrls	r3, [pc, #4]	; (1bfdc <lv_img_color_format_get_px_size+0x10>)
   1bfd6:	5c18      	ldrbls	r0, [r3, r0]
{
   1bfd8:	2000      	movhi	r0, #0
        case LV_IMG_CF_ALPHA_8BIT: px_size = 8; break;
        default: px_size = 0; break;
    }

    return px_size;
}
   1bfda:	4770      	bx	lr
   1bfdc:	00065669 	.word	0x00065669

0001bfe0 <lv_draw_img>:
{
   1bfe0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1bfe4:	b091      	sub	sp, #68	; 0x44
   1bfe6:	4604      	mov	r4, r0
   1bfe8:	460e      	mov	r6, r1
   1bfea:	4698      	mov	r8, r3
   1bfec:	f89d a068 	ldrb.w	sl, [sp, #104]	; 0x68
    if(src == NULL) {
   1bff0:	4617      	mov	r7, r2
   1bff2:	b992      	cbnz	r2, 1c01a <lv_draw_img+0x3a>
        LV_LOG_WARN("Image draw: src is NULL");
   1bff4:	4b6a      	ldr	r3, [pc, #424]	; (1c1a0 <lv_draw_img+0x1c0>)
   1bff6:	496b      	ldr	r1, [pc, #428]	; (1c1a4 <lv_draw_img+0x1c4>)
   1bff8:	2234      	movs	r2, #52	; 0x34
   1bffa:	2002      	movs	r0, #2
   1bffc:	f001 f82c 	bl	1d058 <lv_log_add>
        lv_draw_rect(coords, mask, &lv_style_plain, LV_OPA_COVER);
   1c000:	23ff      	movs	r3, #255	; 0xff
   1c002:	4a69      	ldr	r2, [pc, #420]	; (1c1a8 <lv_draw_img+0x1c8>)
   1c004:	4631      	mov	r1, r6
   1c006:	4620      	mov	r0, r4
   1c008:	f00a f919 	bl	2623e <lv_draw_rect>
        lv_draw_label(coords, mask, &lv_style_plain, LV_OPA_COVER, "No\ndata", LV_TXT_FLAG_NONE, NULL, NULL, NULL, LV_BIDI_DIR_LTR);
   1c00c:	e9cd 7704 	strd	r7, r7, [sp, #16]
   1c010:	e9cd 7702 	strd	r7, r7, [sp, #8]
   1c014:	9701      	str	r7, [sp, #4]
        lv_draw_label(coords, mask, &lv_style_plain, LV_OPA_COVER, "No\ndata", LV_TXT_FLAG_NONE, NULL,  NULL, NULL, LV_BIDI_DIR_LTR);
   1c016:	4b65      	ldr	r3, [pc, #404]	; (1c1ac <lv_draw_img+0x1cc>)
   1c018:	e02d      	b.n	1c076 <lv_draw_img+0x96>
                                 const lv_style_t * style, lv_opa_t opa_scale)
{

    lv_area_t mask_com; /*Common area of mask and coords*/
    bool union_ok;
    union_ok = lv_area_intersect(&mask_com, mask, coords);
   1c01a:	ad0c      	add	r5, sp, #48	; 0x30
   1c01c:	4602      	mov	r2, r0
   1c01e:	4628      	mov	r0, r5
   1c020:	f00b f853 	bl	270ca <lv_area_intersect>
    if(union_ok == false) {
   1c024:	2800      	cmp	r0, #0
   1c026:	d049      	beq.n	1c0bc <lv_draw_img+0xdc>
        return LV_RES_OK; /*Out of mask. There is nothing to draw so the image is drawn
                             successfully.*/
    }

    lv_opa_t opa =
   1c028:	f898 9045 	ldrb.w	r9, [r8, #69]	; 0x45
   1c02c:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
   1c030:	bf18      	it	ne
   1c032:	fb09 f90a 	mulne.w	r9, r9, sl
        opa_scale == LV_OPA_COVER ? style->image.opa : (uint16_t)((uint16_t)style->image.opa * opa_scale) >> 8;

    lv_img_cache_entry_t * cdsc = lv_img_cache_open(src, style);
   1c036:	4638      	mov	r0, r7
   1c038:	4641      	mov	r1, r8
    lv_opa_t opa =
   1c03a:	bf18      	it	ne
   1c03c:	ea4f 2919 	movne.w	r9, r9, lsr #8
    lv_img_cache_entry_t * cdsc = lv_img_cache_open(src, style);
   1c040:	f000 fb7c 	bl	1c73c <lv_img_cache_open>

    if(cdsc == NULL) return LV_RES_INV;
   1c044:	4607      	mov	r7, r0
   1c046:	2800      	cmp	r0, #0
   1c048:	d07a      	beq.n	1c140 <lv_draw_img+0x160>

    bool chroma_keyed = lv_img_color_format_is_chroma_keyed(cdsc->dec_dsc.header.cf);
    bool alpha_byte   = lv_img_color_format_has_alpha(cdsc->dec_dsc.header.cf);

    if(cdsc->dec_dsc.error_msg != NULL) {
   1c04a:	69c3      	ldr	r3, [r0, #28]
   1c04c:	b1db      	cbz	r3, 1c086 <lv_draw_img+0xa6>
        LV_LOG_WARN("Image draw error");
   1c04e:	4b58      	ldr	r3, [pc, #352]	; (1c1b0 <lv_draw_img+0x1d0>)
   1c050:	4954      	ldr	r1, [pc, #336]	; (1c1a4 <lv_draw_img+0x1c4>)
   1c052:	f240 2233 	movw	r2, #563	; 0x233
   1c056:	2002      	movs	r0, #2
   1c058:	f000 fffe 	bl	1d058 <lv_log_add>
        lv_draw_rect(coords, mask, &lv_style_plain, LV_OPA_COVER);
   1c05c:	23ff      	movs	r3, #255	; 0xff
   1c05e:	4a52      	ldr	r2, [pc, #328]	; (1c1a8 <lv_draw_img+0x1c8>)
   1c060:	4631      	mov	r1, r6
   1c062:	4620      	mov	r0, r4
   1c064:	f00a f8eb 	bl	2623e <lv_draw_rect>
        lv_draw_label(coords, mask, &lv_style_plain, LV_OPA_COVER, cdsc->dec_dsc.error_msg, LV_TXT_FLAG_NONE, NULL, NULL, NULL, LV_BIDI_DIR_LTR);
   1c068:	2300      	movs	r3, #0
   1c06a:	e9cd 3304 	strd	r3, r3, [sp, #16]
   1c06e:	e9cd 3302 	strd	r3, r3, [sp, #8]
   1c072:	9301      	str	r3, [sp, #4]
   1c074:	69fb      	ldr	r3, [r7, #28]
        lv_draw_label(coords, mask, &lv_style_plain, LV_OPA_COVER, "No\ndata", LV_TXT_FLAG_NONE, NULL,  NULL, NULL, LV_BIDI_DIR_LTR);
   1c076:	9300      	str	r3, [sp, #0]
   1c078:	4a4b      	ldr	r2, [pc, #300]	; (1c1a8 <lv_draw_img+0x1c8>)
   1c07a:	23ff      	movs	r3, #255	; 0xff
   1c07c:	4631      	mov	r1, r6
   1c07e:	4620      	mov	r0, r4
   1c080:	f7ff fd60 	bl	1bb44 <lv_draw_label>
        return;
   1c084:	e01a      	b.n	1c0bc <lv_draw_img+0xdc>
    bool chroma_keyed = lv_img_color_format_is_chroma_keyed(cdsc->dec_dsc.header.cf);
   1c086:	7c02      	ldrb	r2, [r0, #16]
   1c088:	f002 021f 	and.w	r2, r2, #31
   1c08c:	4610      	mov	r0, r2
   1c08e:	f00a ff3e 	bl	26f0e <lv_img_color_format_is_chroma_keyed>
   1c092:	9007      	str	r0, [sp, #28]
    bool alpha_byte   = lv_img_color_format_has_alpha(cdsc->dec_dsc.header.cf);
   1c094:	4610      	mov	r0, r2
   1c096:	f00a ff42 	bl	26f1e <lv_img_color_format_has_alpha>
    }
    /* The decoder open could open the image and gave the entire uncompressed image.
     * Just draw it!*/
    else if(cdsc->dec_dsc.img_data) {
   1c09a:	697a      	ldr	r2, [r7, #20]
    bool alpha_byte   = lv_img_color_format_has_alpha(cdsc->dec_dsc.header.cf);
   1c09c:	9008      	str	r0, [sp, #32]
    else if(cdsc->dec_dsc.img_data) {
   1c09e:	b182      	cbz	r2, 1c0c2 <lv_draw_img+0xe2>
        lv_draw_map(coords, mask, cdsc->dec_dsc.img_data, opa, chroma_keyed, alpha_byte, style->image.color,
   1c0a0:	f898 3044 	ldrb.w	r3, [r8, #68]	; 0x44
   1c0a4:	9303      	str	r3, [sp, #12]
   1c0a6:	f8d8 3040 	ldr.w	r3, [r8, #64]	; 0x40
   1c0aa:	9302      	str	r3, [sp, #8]
   1c0ac:	9b07      	ldr	r3, [sp, #28]
   1c0ae:	9001      	str	r0, [sp, #4]
   1c0b0:	9300      	str	r3, [sp, #0]
   1c0b2:	4631      	mov	r1, r6
   1c0b4:	464b      	mov	r3, r9
   1c0b6:	4620      	mov	r0, r4
   1c0b8:	f009 ff17 	bl	25eea <lv_draw_map>
}
   1c0bc:	b011      	add	sp, #68	; 0x44
   1c0be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1c0c2:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
   1c0c6:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
   1c0ca:	3301      	adds	r3, #1
   1c0cc:	1a9b      	subs	r3, r3, r2
   1c0ce:	fa0f fa83 	sxth.w	sl, r3
    }
    /* The whole uncompressed image is not available. Try to read it line-by-line*/
    else {
        lv_coord_t width = lv_area_get_width(&mask_com);

        uint8_t  * buf = lv_draw_get_buf(lv_area_get_width(&mask_com) * LV_IMG_PX_SIZE_ALPHA_BYTE);  /*space for the possible alpha byte*/
   1c0d2:	ea4f 008a 	mov.w	r0, sl, lsl #2
   1c0d6:	f7ff fcf9 	bl	1bacc <lv_draw_get_buf>
   1c0da:	4683      	mov	fp, r0
    memcpy(dest, src, sizeof(lv_area_t));
   1c0dc:	e895 0003 	ldmia.w	r5, {r0, r1}
   1c0e0:	aa0e      	add	r2, sp, #56	; 0x38
   1c0e2:	e882 0003 	stmia.w	r2, {r0, r1}

        lv_area_t line;
        lv_area_copy(&line, &mask_com);
        lv_area_set_height(&line, 1);
   1c0e6:	2101      	movs	r1, #1
   1c0e8:	4610      	mov	r0, r2
   1c0ea:	f00a ffdb 	bl	270a4 <lv_area_set_height>
        lv_coord_t x = mask_com.x1 - coords->x1;
   1c0ee:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   1c0f2:	8821      	ldrh	r1, [r4, #0]
        lv_coord_t y = mask_com.y1 - coords->y1;
   1c0f4:	f9bd 5032 	ldrsh.w	r5, [sp, #50]	; 0x32
        lv_coord_t x = mask_com.x1 - coords->x1;
   1c0f8:	1a5b      	subs	r3, r3, r1
   1c0fa:	b21b      	sxth	r3, r3
   1c0fc:	9309      	str	r3, [sp, #36]	; 0x24
        lv_coord_t y = mask_com.y1 - coords->y1;
   1c0fe:	8863      	ldrh	r3, [r4, #2]
   1c100:	1aeb      	subs	r3, r5, r3
   1c102:	b21b      	sxth	r3, r3
        lv_coord_t row;
        lv_res_t read_res;
        for(row = mask_com.y1; row <= mask_com.y2; row++) {
   1c104:	1b5b      	subs	r3, r3, r5
            if(read_res != LV_RES_OK) {
                lv_img_decoder_close(&cdsc->dec_dsc);
                LV_LOG_WARN("Image draw can't read the line");
                return LV_RES_INV;
            }
            lv_draw_map(&line, mask, buf, opa, chroma_keyed, alpha_byte, style->image.color, style->image.intense);
   1c106:	aa0e      	add	r2, sp, #56	; 0x38
   1c108:	930a      	str	r3, [sp, #40]	; 0x28
   1c10a:	920b      	str	r2, [sp, #44]	; 0x2c
   1c10c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1c10e:	195a      	adds	r2, r3, r5
        for(row = mask_com.y1; row <= mask_com.y2; row++) {
   1c110:	f9bd 3036 	ldrsh.w	r3, [sp, #54]	; 0x36
   1c114:	42ab      	cmp	r3, r5
   1c116:	b212      	sxth	r2, r2
   1c118:	dbd0      	blt.n	1c0bc <lv_draw_img+0xdc>
            read_res = lv_img_decoder_read_line(&cdsc->dec_dsc, x, y, width, buf);
   1c11a:	f8cd b000 	str.w	fp, [sp]
   1c11e:	4653      	mov	r3, sl
   1c120:	9909      	ldr	r1, [sp, #36]	; 0x24
   1c122:	4638      	mov	r0, r7
   1c124:	f00a ff26 	bl	26f74 <lv_img_decoder_read_line>
            if(read_res != LV_RES_OK) {
   1c128:	2801      	cmp	r0, #1
   1c12a:	d01c      	beq.n	1c166 <lv_draw_img+0x186>
                lv_img_decoder_close(&cdsc->dec_dsc);
   1c12c:	4638      	mov	r0, r7
   1c12e:	f00a ff31 	bl	26f94 <lv_img_decoder_close>
                LV_LOG_WARN("Image draw can't read the line");
   1c132:	4b20      	ldr	r3, [pc, #128]	; (1c1b4 <lv_draw_img+0x1d4>)
   1c134:	491b      	ldr	r1, [pc, #108]	; (1c1a4 <lv_draw_img+0x1c4>)
   1c136:	f240 224e 	movw	r2, #590	; 0x24e
   1c13a:	2002      	movs	r0, #2
   1c13c:	f000 ff8c 	bl	1d058 <lv_log_add>
        LV_LOG_WARN("Image draw error");
   1c140:	4b1b      	ldr	r3, [pc, #108]	; (1c1b0 <lv_draw_img+0x1d0>)
   1c142:	4918      	ldr	r1, [pc, #96]	; (1c1a4 <lv_draw_img+0x1c4>)
   1c144:	223e      	movs	r2, #62	; 0x3e
   1c146:	2002      	movs	r0, #2
   1c148:	f000 ff86 	bl	1d058 <lv_log_add>
        lv_draw_rect(coords, mask, &lv_style_plain, LV_OPA_COVER);
   1c14c:	23ff      	movs	r3, #255	; 0xff
   1c14e:	4a16      	ldr	r2, [pc, #88]	; (1c1a8 <lv_draw_img+0x1c8>)
   1c150:	4631      	mov	r1, r6
   1c152:	4620      	mov	r0, r4
   1c154:	f00a f873 	bl	2623e <lv_draw_rect>
        lv_draw_label(coords, mask, &lv_style_plain, LV_OPA_COVER, "No\ndata", LV_TXT_FLAG_NONE, NULL,  NULL, NULL, LV_BIDI_DIR_LTR);
   1c158:	2300      	movs	r3, #0
   1c15a:	e9cd 3304 	strd	r3, r3, [sp, #16]
   1c15e:	e9cd 3302 	strd	r3, r3, [sp, #8]
   1c162:	9301      	str	r3, [sp, #4]
   1c164:	e757      	b.n	1c016 <lv_draw_img+0x36>
            lv_draw_map(&line, mask, buf, opa, chroma_keyed, alpha_byte, style->image.color, style->image.intense);
   1c166:	f898 3044 	ldrb.w	r3, [r8, #68]	; 0x44
   1c16a:	9303      	str	r3, [sp, #12]
   1c16c:	f8d8 3040 	ldr.w	r3, [r8, #64]	; 0x40
   1c170:	9302      	str	r3, [sp, #8]
   1c172:	9b08      	ldr	r3, [sp, #32]
   1c174:	9301      	str	r3, [sp, #4]
   1c176:	9b07      	ldr	r3, [sp, #28]
   1c178:	9300      	str	r3, [sp, #0]
   1c17a:	465a      	mov	r2, fp
   1c17c:	464b      	mov	r3, r9
   1c17e:	4631      	mov	r1, r6
   1c180:	980b      	ldr	r0, [sp, #44]	; 0x2c
   1c182:	f009 feb2 	bl	25eea <lv_draw_map>
            line.y1++;
   1c186:	f8bd 303a 	ldrh.w	r3, [sp, #58]	; 0x3a
   1c18a:	3301      	adds	r3, #1
   1c18c:	f8ad 303a 	strh.w	r3, [sp, #58]	; 0x3a
            line.y2++;
   1c190:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
        for(row = mask_com.y1; row <= mask_com.y2; row++) {
   1c194:	3501      	adds	r5, #1
            line.y2++;
   1c196:	3301      	adds	r3, #1
   1c198:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
        for(row = mask_com.y1; row <= mask_com.y2; row++) {
   1c19c:	b22d      	sxth	r5, r5
   1c19e:	e7b5      	b.n	1c10c <lv_draw_img+0x12c>
   1c1a0:	00065674 	.word	0x00065674
   1c1a4:	000656f5 	.word	0x000656f5
   1c1a8:	20001c28 	.word	0x20001c28
   1c1ac:	0006568c 	.word	0x0006568c
   1c1b0:	00065694 	.word	0x00065694
   1c1b4:	000656a5 	.word	0x000656a5

0001c1b8 <lv_img_decoder_built_in_info>:
 * @param src the image source: pointer to an `lv_img_dsc_t` variable, a file path or a symbol
 * @param header store the image data here
 * @return LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error.
 */
lv_res_t lv_img_decoder_built_in_info(lv_img_decoder_t * decoder, const void * src, lv_img_header_t * header)
{
   1c1b8:	b538      	push	{r3, r4, r5, lr}
    (void)decoder; /*Unused*/

    lv_img_src_t src_type = lv_img_src_get_type(src);
   1c1ba:	4608      	mov	r0, r1
{
   1c1bc:	460d      	mov	r5, r1
   1c1be:	4614      	mov	r4, r2
    lv_img_src_t src_type = lv_img_src_get_type(src);
   1c1c0:	f00a feba 	bl	26f38 <lv_img_src_get_type>
    if(src_type == LV_IMG_SRC_VARIABLE) {
   1c1c4:	b9c0      	cbnz	r0, 1c1f8 <lv_img_decoder_built_in_info+0x40>
        lv_img_cf_t cf = ((lv_img_dsc_t *)src)->header.cf;
   1c1c6:	782b      	ldrb	r3, [r5, #0]
   1c1c8:	f3c3 0304 	ubfx	r3, r3, #0, #5
        if(cf < CF_BUILT_IN_FIRST || cf > CF_BUILT_IN_LAST) return LV_RES_INV;
   1c1cc:	3b04      	subs	r3, #4
   1c1ce:	b2db      	uxtb	r3, r3
   1c1d0:	2b0a      	cmp	r3, #10
   1c1d2:	d810      	bhi.n	1c1f6 <lv_img_decoder_built_in_info+0x3e>

        header->w  = ((lv_img_dsc_t *)src)->header.w;
        header->h  = ((lv_img_dsc_t *)src)->header.h;
   1c1d4:	886b      	ldrh	r3, [r5, #2]
   1c1d6:	8862      	ldrh	r2, [r4, #2]
        lv_img_cf_t cf = ((lv_img_dsc_t *)src)->header.cf;
   1c1d8:	6829      	ldr	r1, [r5, #0]
        header->h  = ((lv_img_dsc_t *)src)->header.h;
   1c1da:	095b      	lsrs	r3, r3, #5
   1c1dc:	f363 124f 	bfi	r2, r3, #5, #11
   1c1e0:	8062      	strh	r2, [r4, #2]
        header->cf = ((lv_img_dsc_t *)src)->header.cf;
   1c1e2:	6823      	ldr	r3, [r4, #0]
   1c1e4:	4a0c      	ldr	r2, [pc, #48]	; (1c218 <lv_img_decoder_built_in_info+0x60>)
   1c1e6:	f023 131f 	bic.w	r3, r3, #2031647	; 0x1f001f
   1c1ea:	f423 437c 	bic.w	r3, r3, #64512	; 0xfc00
   1c1ee:	400a      	ands	r2, r1
         * function*/
        header->w = 1;
        header->h = 1;
        /* Symbols always have transparent parts. Important because of cover check in the design
         * function. The actual value doesn't matter because lv_draw_label will draw it*/
        header->cf = LV_IMG_CF_ALPHA_1BIT;
   1c1f0:	4313      	orrs	r3, r2
   1c1f2:	6023      	str	r3, [r4, #0]
    } else {
        LV_LOG_WARN("Image get info found unknown src type");
        return LV_RES_INV;
    }
    return LV_RES_OK;
   1c1f4:	2001      	movs	r0, #1
}
   1c1f6:	bd38      	pop	{r3, r4, r5, pc}
    else if(src_type == LV_IMG_SRC_SYMBOL) {
   1c1f8:	2802      	cmp	r0, #2
   1c1fa:	d104      	bne.n	1c206 <lv_img_decoder_built_in_info+0x4e>
        header->cf = LV_IMG_CF_ALPHA_1BIT;
   1c1fc:	6823      	ldr	r3, [r4, #0]
   1c1fe:	f403 7278 	and.w	r2, r3, #992	; 0x3e0
   1c202:	4b06      	ldr	r3, [pc, #24]	; (1c21c <lv_img_decoder_built_in_info+0x64>)
   1c204:	e7f4      	b.n	1c1f0 <lv_img_decoder_built_in_info+0x38>
        LV_LOG_WARN("Image get info found unknown src type");
   1c206:	2002      	movs	r0, #2
   1c208:	4b05      	ldr	r3, [pc, #20]	; (1c220 <lv_img_decoder_built_in_info+0x68>)
   1c20a:	4906      	ldr	r1, [pc, #24]	; (1c224 <lv_img_decoder_built_in_info+0x6c>)
   1c20c:	f240 1231 	movw	r2, #305	; 0x131
   1c210:	f000 ff22 	bl	1d058 <lv_log_add>
   1c214:	2000      	movs	r0, #0
   1c216:	e7ee      	b.n	1c1f6 <lv_img_decoder_built_in_info+0x3e>
   1c218:	001ffc1f 	.word	0x001ffc1f
   1c21c:	0020040b 	.word	0x0020040b
   1c220:	000657b6 	.word	0x000657b6
   1c224:	000657dc 	.word	0x000657dc

0001c228 <lv_img_decoder_built_in_open>:
 * @param decoder the decoder where this function belongs
 * @param dsc pointer to decoder descriptor. `src`, `style` are already initialized in it.
 * @return LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error.
 */
lv_res_t lv_img_decoder_built_in_open(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)
{
   1c228:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    /*Open the file if it's a file*/
    if(dsc->src_type == LV_IMG_SRC_FILE) {
   1c22c:	7b0a      	ldrb	r2, [r1, #12]
   1c22e:	2a01      	cmp	r2, #1
{
   1c230:	460c      	mov	r4, r1
    if(dsc->src_type == LV_IMG_SRC_FILE) {
   1c232:	d108      	bne.n	1c246 <lv_img_decoder_built_in_open+0x1e>
        }

        memcpy(user_data->f, &f, sizeof(f));

#else
        LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
   1c234:	4b3a      	ldr	r3, [pc, #232]	; (1c320 <lv_img_decoder_built_in_open+0xf8>)
   1c236:	f240 1261 	movw	r2, #353	; 0x161
    /*Unknown format. Can't decode it.*/
    else {
        /*Free the potentially allocated memories*/
        lv_img_decoder_built_in_close(decoder, dsc);

        LV_LOG_WARN("Image decoder open: unknown color format")
   1c23a:	2002      	movs	r0, #2
   1c23c:	4939      	ldr	r1, [pc, #228]	; (1c324 <lv_img_decoder_built_in_open+0xfc>)
   1c23e:	f000 ff0b 	bl	1d058 <lv_log_add>
        return LV_RES_INV;
   1c242:	2000      	movs	r0, #0
   1c244:	e00b      	b.n	1c25e <lv_img_decoder_built_in_open+0x36>
    lv_img_cf_t cf = dsc->header.cf;
   1c246:	7c0b      	ldrb	r3, [r1, #16]
   1c248:	f003 031f 	and.w	r3, r3, #31
    if(cf == LV_IMG_CF_TRUE_COLOR || cf == LV_IMG_CF_TRUE_COLOR_ALPHA || cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
   1c24c:	1f1d      	subs	r5, r3, #4
   1c24e:	2d02      	cmp	r5, #2
   1c250:	d807      	bhi.n	1c262 <lv_img_decoder_built_in_open+0x3a>
        if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
   1c252:	2a00      	cmp	r2, #0
   1c254:	d143      	bne.n	1c2de <lv_img_decoder_built_in_open+0xb6>
            dsc->img_data = ((lv_img_dsc_t *)dsc->src)->data;
   1c256:	684b      	ldr	r3, [r1, #4]
   1c258:	689b      	ldr	r3, [r3, #8]
            dsc->img_data = NULL;
   1c25a:	6163      	str	r3, [r4, #20]
            return LV_RES_OK;
   1c25c:	2001      	movs	r0, #1
    }
}
   1c25e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if(cf == LV_IMG_CF_INDEXED_1BIT || cf == LV_IMG_CF_INDEXED_2BIT || cf == LV_IMG_CF_INDEXED_4BIT ||
   1c262:	1fda      	subs	r2, r3, #7
   1c264:	2a03      	cmp	r2, #3
   1c266:	d852      	bhi.n	1c30e <lv_img_decoder_built_in_open+0xe6>
        uint8_t px_size       = lv_img_color_format_get_px_size(cf);
   1c268:	4618      	mov	r0, r3
   1c26a:	f7ff feaf 	bl	1bfcc <lv_img_color_format_get_px_size>
        if(dsc->user_data == NULL) {
   1c26e:	6a23      	ldr	r3, [r4, #32]
        uint32_t palette_size = 1 << px_size;
   1c270:	2601      	movs	r6, #1
        uint8_t px_size       = lv_img_color_format_get_px_size(cf);
   1c272:	4607      	mov	r7, r0
        uint32_t palette_size = 1 << px_size;
   1c274:	4086      	lsls	r6, r0
        if(dsc->user_data == NULL) {
   1c276:	b97b      	cbnz	r3, 1c298 <lv_img_decoder_built_in_open+0x70>
            dsc->user_data = lv_mem_alloc(sizeof(lv_img_decoder_built_in_data_t));
   1c278:	2008      	movs	r0, #8
   1c27a:	f000 fd2b 	bl	1ccd4 <lv_mem_alloc>
   1c27e:	6220      	str	r0, [r4, #32]
            if(dsc->user_data == NULL) {
   1c280:	b930      	cbnz	r0, 1c290 <lv_img_decoder_built_in_open+0x68>
                LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
   1c282:	4b29      	ldr	r3, [pc, #164]	; (1c328 <lv_img_decoder_built_in_open+0x100>)
   1c284:	4927      	ldr	r1, [pc, #156]	; (1c324 <lv_img_decoder_built_in_open+0xfc>)
   1c286:	f44f 72c0 	mov.w	r2, #384	; 0x180
   1c28a:	2003      	movs	r0, #3
   1c28c:	f000 fee4 	bl	1d058 <lv_log_add>
__ssp_bos_icheck3(memset, void *, int)
   1c290:	6a23      	ldr	r3, [r4, #32]
   1c292:	2200      	movs	r2, #0
   1c294:	601a      	str	r2, [r3, #0]
   1c296:	605a      	str	r2, [r3, #4]
        user_data->palette                         = lv_mem_alloc(palette_size * sizeof(lv_color_t));
   1c298:	2004      	movs	r0, #4
   1c29a:	40b8      	lsls	r0, r7
        lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
   1c29c:	6a25      	ldr	r5, [r4, #32]
        user_data->palette                         = lv_mem_alloc(palette_size * sizeof(lv_color_t));
   1c29e:	f000 fd19 	bl	1ccd4 <lv_mem_alloc>
   1c2a2:	6028      	str	r0, [r5, #0]
        user_data->opa                             = lv_mem_alloc(palette_size * sizeof(lv_opa_t));
   1c2a4:	4630      	mov	r0, r6
   1c2a6:	f000 fd15 	bl	1ccd4 <lv_mem_alloc>
        if(user_data->palette == NULL || user_data->opa == NULL) {
   1c2aa:	682b      	ldr	r3, [r5, #0]
        user_data->opa                             = lv_mem_alloc(palette_size * sizeof(lv_opa_t));
   1c2ac:	6068      	str	r0, [r5, #4]
        if(user_data->palette == NULL || user_data->opa == NULL) {
   1c2ae:	b103      	cbz	r3, 1c2b2 <lv_img_decoder_built_in_open+0x8a>
   1c2b0:	b930      	cbnz	r0, 1c2c0 <lv_img_decoder_built_in_open+0x98>
            LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
   1c2b2:	4b1d      	ldr	r3, [pc, #116]	; (1c328 <lv_img_decoder_built_in_open+0x100>)
   1c2b4:	491b      	ldr	r1, [pc, #108]	; (1c324 <lv_img_decoder_built_in_open+0xfc>)
   1c2b6:	f44f 72c5 	mov.w	r2, #394	; 0x18a
   1c2ba:	2003      	movs	r0, #3
   1c2bc:	f000 fecc 	bl	1d058 <lv_log_add>
        if(dsc->src_type == LV_IMG_SRC_FILE) {
   1c2c0:	7b23      	ldrb	r3, [r4, #12]
   1c2c2:	2b01      	cmp	r3, #1
   1c2c4:	d103      	bne.n	1c2ce <lv_img_decoder_built_in_open+0xa6>
            LV_LOG_WARN("Image built-in decoder can read the palette because LV_USE_FILESYSTEM = 0");
   1c2c6:	4b19      	ldr	r3, [pc, #100]	; (1c32c <lv_img_decoder_built_in_open+0x104>)
   1c2c8:	f44f 72ce 	mov.w	r2, #412	; 0x19c
   1c2cc:	e7b5      	b.n	1c23a <lv_img_decoder_built_in_open+0x12>
            lv_color32_t * palette_p = (lv_color32_t *)((lv_img_dsc_t *)dsc->src)->data;
   1c2ce:	6863      	ldr	r3, [r4, #4]
                user_data->palette[i] = lv_color_make(palette_p[i].ch.red, palette_p[i].ch.green, palette_p[i].ch.blue);
   1c2d0:	27ff      	movs	r7, #255	; 0xff
   1c2d2:	689a      	ldr	r2, [r3, #8]
            for(i = 0; i < palette_size; i++) {
   1c2d4:	2300      	movs	r3, #0
   1c2d6:	42b3      	cmp	r3, r6
   1c2d8:	f102 0204 	add.w	r2, r2, #4
   1c2dc:	d101      	bne.n	1c2e2 <lv_img_decoder_built_in_open+0xba>
            dsc->img_data = NULL;
   1c2de:	2300      	movs	r3, #0
   1c2e0:	e7bb      	b.n	1c25a <lv_img_decoder_built_in_open+0x32>
                user_data->palette[i] = lv_color_make(palette_p[i].ch.red, palette_p[i].ch.green, palette_p[i].ch.blue);
   1c2e2:	6828      	ldr	r0, [r5, #0]
   1c2e4:	f812 8c04 	ldrb.w	r8, [r2, #-4]
   1c2e8:	f812 cc02 	ldrb.w	ip, [r2, #-2]
   1c2ec:	f812 ec03 	ldrb.w	lr, [r2, #-3]
   1c2f0:	f800 8023 	strb.w	r8, [r0, r3, lsl #2]
   1c2f4:	eb00 0183 	add.w	r1, r0, r3, lsl #2
   1c2f8:	f881 e001 	strb.w	lr, [r1, #1]
   1c2fc:	f881 c002 	strb.w	ip, [r1, #2]
   1c300:	70cf      	strb	r7, [r1, #3]
                user_data->opa[i]     = palette_p[i].ch.alpha;
   1c302:	6869      	ldr	r1, [r5, #4]
   1c304:	f812 0c01 	ldrb.w	r0, [r2, #-1]
   1c308:	54c8      	strb	r0, [r1, r3]
            for(i = 0; i < palette_size; i++) {
   1c30a:	3301      	adds	r3, #1
   1c30c:	e7e3      	b.n	1c2d6 <lv_img_decoder_built_in_open+0xae>
    else if(cf == LV_IMG_CF_ALPHA_1BIT || cf == LV_IMG_CF_ALPHA_2BIT || cf == LV_IMG_CF_ALPHA_4BIT ||
   1c30e:	3b0b      	subs	r3, #11
   1c310:	2b03      	cmp	r3, #3
   1c312:	d9e4      	bls.n	1c2de <lv_img_decoder_built_in_open+0xb6>
        lv_img_decoder_built_in_close(decoder, dsc);
   1c314:	f00a fe20 	bl	26f58 <lv_img_decoder_built_in_close>
        LV_LOG_WARN("Image decoder open: unknown color format")
   1c318:	4b05      	ldr	r3, [pc, #20]	; (1c330 <lv_img_decoder_built_in_open+0x108>)
   1c31a:	f240 12c1 	movw	r2, #449	; 0x1c1
   1c31e:	e78c      	b.n	1c23a <lv_img_decoder_built_in_open+0x12>
   1c320:	00065819 	.word	0x00065819
   1c324:	000657dc 	.word	0x000657dc
   1c328:	0006585f 	.word	0x0006585f
   1c32c:	00065888 	.word	0x00065888
   1c330:	000658d2 	.word	0x000658d2

0001c334 <lv_img_decoder_built_in_read_line>:
 * @param buf a buffer to store the decoded pixels
 * @return LV_RES_OK: ok; LV_RES_INV: failed
 */
lv_res_t lv_img_decoder_built_in_read_line(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc, lv_coord_t x,
                                                  lv_coord_t y, lv_coord_t len, uint8_t * buf)
{
   1c334:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    (void)decoder; /*Unused*/

    lv_res_t res = LV_RES_INV;

    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
   1c338:	7c08      	ldrb	r0, [r1, #16]
{
   1c33a:	b087      	sub	sp, #28
   1c33c:	461e      	mov	r6, r3
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
   1c33e:	f000 031e 	and.w	r3, r0, #30
   1c342:	2b04      	cmp	r3, #4
{
   1c344:	460d      	mov	r5, r1
   1c346:	4614      	mov	r4, r2
   1c348:	f9bd 7038 	ldrsh.w	r7, [sp, #56]	; 0x38
   1c34c:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
   1c350:	d003      	beq.n	1c35a <lv_img_decoder_built_in_read_line+0x26>
       dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
   1c352:	f000 031f 	and.w	r3, r0, #31
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
   1c356:	2b06      	cmp	r3, #6
   1c358:	d10b      	bne.n	1c372 <lv_img_decoder_built_in_read_line+0x3e>
        /* For TRUE_COLOR images read line required only for files.
         * For variables the image data was returned in `open`*/
        if(dsc->src_type == LV_IMG_SRC_FILE) {
   1c35a:	7b2b      	ldrb	r3, [r5, #12]
   1c35c:	2b01      	cmp	r3, #1
   1c35e:	d106      	bne.n	1c36e <lv_img_decoder_built_in_read_line+0x3a>
        return LV_RES_INV;
    }

    return LV_RES_OK;
#else
    LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
   1c360:	4b9d      	ldr	r3, [pc, #628]	; (1c5d8 <lv_img_decoder_built_in_read_line+0x2a4>)
   1c362:	f240 2225 	movw	r2, #549	; 0x225
        LV_LOG_WARN("Built-in image decoder read not supports the color format");
   1c366:	499d      	ldr	r1, [pc, #628]	; (1c5dc <lv_img_decoder_built_in_read_line+0x2a8>)
   1c368:	2002      	movs	r0, #2
   1c36a:	f000 fe75 	bl	1d058 <lv_log_add>
    lv_res_t res = LV_RES_INV;
   1c36e:	2000      	movs	r0, #0
   1c370:	e05c      	b.n	1c42c <lv_img_decoder_built_in_read_line+0xf8>
    } else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
   1c372:	f1a3 020b 	sub.w	r2, r3, #11
   1c376:	2a03      	cmp	r2, #3
   1c378:	f200 80a7 	bhi.w	1c4ca <lv_img_decoder_built_in_read_line+0x196>
static lv_res_t lv_img_decoder_built_in_line_alpha(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                   lv_coord_t len, uint8_t * buf)
{

#if LV_IMG_CF_ALPHA
    const lv_opa_t alpha1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
   1c37c:	f44f 437f 	mov.w	r3, #65280	; 0xff00
   1c380:	f8ad 3000 	strh.w	r3, [sp]
    const lv_opa_t alpha2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
   1c384:	f5a3 03ad 	sub.w	r3, r3, #5668864	; 0x568000
   1c388:	f5a3 5328 	sub.w	r3, r3, #10752	; 0x2a00
   1c38c:	9301      	str	r3, [sp, #4]
    const lv_opa_t alpha4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
   1c38e:	4b94      	ldr	r3, [pc, #592]	; (1c5e0 <lv_img_decoder_built_in_read_line+0x2ac>)
   1c390:	aa02      	add	r2, sp, #8
   1c392:	f103 0e10 	add.w	lr, r3, #16
   1c396:	4691      	mov	r9, r2
   1c398:	6818      	ldr	r0, [r3, #0]
   1c39a:	6859      	ldr	r1, [r3, #4]
   1c39c:	4694      	mov	ip, r2
   1c39e:	e8ac 0003 	stmia.w	ip!, {r0, r1}
   1c3a2:	3308      	adds	r3, #8
   1c3a4:	4573      	cmp	r3, lr
   1c3a6:	4662      	mov	r2, ip
   1c3a8:	d1f6      	bne.n	1c398 <lv_img_decoder_built_in_read_line+0x64>
                                           68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255};

    /*Simply fill the buffer with the color. Later only the alpha value will be modified.*/
    lv_color_t bg_color = dsc->style->image.color;
   1c3aa:	68ab      	ldr	r3, [r5, #8]
   1c3ac:	6c19      	ldr	r1, [r3, #64]	; 0x40
   1c3ae:	2300      	movs	r3, #0
    lv_coord_t i;
    for(i = 0; i < len; i++) {
   1c3b0:	b21a      	sxth	r2, r3
   1c3b2:	4297      	cmp	r7, r2
   1c3b4:	dc16      	bgt.n	1c3e4 <lv_img_decoder_built_in_read_line+0xb0>
#error "Invalid LV_COLOR_DEPTH. Check it in lv_conf.h"
#endif
    }

    const lv_opa_t * opa_table = NULL;
    uint8_t px_size            = lv_img_color_format_get_px_size(dsc->header.cf);
   1c3b6:	7c28      	ldrb	r0, [r5, #16]
   1c3b8:	f000 001f 	and.w	r0, r0, #31
   1c3bc:	f7ff fe06 	bl	1bfcc <lv_img_color_format_get_px_size>
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/

    lv_coord_t w = 0;
    uint32_t ofs = 0;
    int8_t pos   = 0;
    switch(dsc->header.cf) {
   1c3c0:	7c2b      	ldrb	r3, [r5, #16]
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
   1c3c2:	f04f 0c01 	mov.w	ip, #1
   1c3c6:	fa0c fc00 	lsl.w	ip, ip, r0
    switch(dsc->header.cf) {
   1c3ca:	f003 031f 	and.w	r3, r3, #31
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
   1c3ce:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    switch(dsc->header.cf) {
   1c3d2:	3b0b      	subs	r3, #11
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
   1c3d4:	fa1f fc8c 	uxth.w	ip, ip
    switch(dsc->header.cf) {
   1c3d8:	2b03      	cmp	r3, #3
   1c3da:	d856      	bhi.n	1c48a <lv_img_decoder_built_in_read_line+0x156>
   1c3dc:	e8df f003 	tbb	[pc, r3]
   1c3e0:	4d3b2906 	.word	0x4d3b2906
        *((uint32_t *)&buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE]) = bg_color.full;
   1c3e4:	f848 1023 	str.w	r1, [r8, r3, lsl #2]
   1c3e8:	3301      	adds	r3, #1
   1c3ea:	e7e1      	b.n	1c3b0 <lv_img_decoder_built_in_read_line+0x7c>
        case LV_IMG_CF_ALPHA_1BIT:
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
   1c3ec:	6929      	ldr	r1, [r5, #16]
   1c3ee:	f3c1 218a 	ubfx	r1, r1, #10, #11
   1c3f2:	08cb      	lsrs	r3, r1, #3
            if(dsc->header.w & 0x7) w++;
   1c3f4:	0749      	lsls	r1, r1, #29
            ofs += w * y + (x >> 3); /*First pixel*/
   1c3f6:	ea4f 02e4 	mov.w	r2, r4, asr #3
            if(dsc->header.w & 0x7) w++;
   1c3fa:	bf18      	it	ne
   1c3fc:	3301      	addne	r3, #1
            pos       = 7 - (x & 0x7);
   1c3fe:	43e4      	mvns	r4, r4
            ofs += w * y + (x >> 3); /*First pixel*/
   1c400:	fb03 2306 	mla	r3, r3, r6, r2
            pos       = 7 - (x & 0x7);
   1c404:	f004 0407 	and.w	r4, r4, #7
            opa_table = alpha1_opa_table;
   1c408:	466e      	mov	r6, sp
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
    uint8_t fs_buf[LV_HOR_RES_MAX];
#endif

    const uint8_t * data_tmp = NULL;
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
   1c40a:	7b29      	ldrb	r1, [r5, #12]
   1c40c:	2900      	cmp	r1, #0
   1c40e:	d13f      	bne.n	1c490 <lv_img_decoder_built_in_read_line+0x15c>
        const lv_img_dsc_t * img_dsc = dsc->src;

        data_tmp = img_dsc->data + ofs;
   1c410:	686a      	ldr	r2, [r5, #4]
        val_act = (data_tmp[byte_act] & (mask << pos)) >> pos;

        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];

        pos -= px_size;
   1c412:	b240      	sxtb	r0, r0
        data_tmp = img_dsc->data + ofs;
   1c414:	6892      	ldr	r2, [r2, #8]
        if(pos < 0) {
            pos = 8 - px_size;
   1c416:	f1c0 0e08 	rsb	lr, r0, #8
        data_tmp = img_dsc->data + ofs;
   1c41a:	4413      	add	r3, r2
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
   1c41c:	f108 0803 	add.w	r8, r8, #3
            pos = 8 - px_size;
   1c420:	fa4f fe8e 	sxtb.w	lr, lr
    for(i = 0; i < len; i++) {
   1c424:	b20a      	sxth	r2, r1
   1c426:	4297      	cmp	r7, r2
   1c428:	dc36      	bgt.n	1c498 <lv_img_decoder_built_in_read_line+0x164>
            pos = 8 - px_size;
            data_tmp++;
        }
    }

    return LV_RES_OK;
   1c42a:	2001      	movs	r0, #1
}
   1c42c:	b007      	add	sp, #28
   1c42e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
   1c432:	6929      	ldr	r1, [r5, #16]
   1c434:	f3c1 218a 	ubfx	r1, r1, #10, #11
   1c438:	088b      	lsrs	r3, r1, #2
            if(dsc->header.w & 0x3) w++;
   1c43a:	078a      	lsls	r2, r1, #30
            ofs += w * y + (x >> 2); /*First pixel*/
   1c43c:	ea4f 02a4 	mov.w	r2, r4, asr #2
            pos       = 6 - ((x & 0x3) * 2);
   1c440:	ea6f 0404 	mvn.w	r4, r4
            if(dsc->header.w & 0x3) w++;
   1c444:	bf18      	it	ne
   1c446:	3301      	addne	r3, #1
            pos       = 6 - ((x & 0x3) * 2);
   1c448:	f004 0403 	and.w	r4, r4, #3
            ofs += w * y + (x >> 2); /*First pixel*/
   1c44c:	fb03 2306 	mla	r3, r3, r6, r2
            pos       = 6 - ((x & 0x3) * 2);
   1c450:	0064      	lsls	r4, r4, #1
            opa_table = alpha2_opa_table;
   1c452:	ae01      	add	r6, sp, #4
   1c454:	e7d9      	b.n	1c40a <lv_img_decoder_built_in_read_line+0xd6>
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
   1c456:	692b      	ldr	r3, [r5, #16]
   1c458:	f3c3 218a 	ubfx	r1, r3, #10, #11
   1c45c:	084b      	lsrs	r3, r1, #1
            if(dsc->header.w & 0x1) w++;
   1c45e:	07c9      	lsls	r1, r1, #31
            ofs += w * y + (x >> 1); /*First pixel*/
   1c460:	ea4f 0264 	mov.w	r2, r4, asr #1
            if(dsc->header.w & 0x1) w++;
   1c464:	bf48      	it	mi
   1c466:	3301      	addmi	r3, #1
            pos       = 4 - ((x & 0x1) * 4);
   1c468:	f014 0f01 	tst.w	r4, #1
            ofs += w * y + (x >> 1); /*First pixel*/
   1c46c:	fb03 2306 	mla	r3, r3, r6, r2
            pos       = 4 - ((x & 0x1) * 4);
   1c470:	bf0c      	ite	eq
   1c472:	2404      	moveq	r4, #4
   1c474:	2400      	movne	r4, #0
   1c476:	464e      	mov	r6, r9
   1c478:	e7c7      	b.n	1c40a <lv_img_decoder_built_in_read_line+0xd6>
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
   1c47a:	692b      	ldr	r3, [r5, #16]
   1c47c:	f3c3 238a 	ubfx	r3, r3, #10, #11
            ofs += w * y + x;  /*First pixel*/
   1c480:	fb16 4303 	smlabb	r3, r6, r3, r4
            pos = 0;
   1c484:	2400      	movs	r4, #0
    const lv_opa_t * opa_table = NULL;
   1c486:	4626      	mov	r6, r4
   1c488:	e7bf      	b.n	1c40a <lv_img_decoder_built_in_read_line+0xd6>
    int8_t pos   = 0;
   1c48a:	2400      	movs	r4, #0
    uint32_t ofs = 0;
   1c48c:	4623      	mov	r3, r4
   1c48e:	e7fa      	b.n	1c486 <lv_img_decoder_built_in_read_line+0x152>
        LV_LOG_WARN("Image built-in alpha line reader can't read file because LV_USE_FILESYSTEM = 0");
   1c490:	4b54      	ldr	r3, [pc, #336]	; (1c5e4 <lv_img_decoder_built_in_read_line+0x2b0>)
   1c492:	f240 2279 	movw	r2, #633	; 0x279
   1c496:	e766      	b.n	1c366 <lv_img_decoder_built_in_read_line+0x32>
        val_act = (data_tmp[byte_act] & (mask << pos)) >> pos;
   1c498:	781a      	ldrb	r2, [r3, #0]
   1c49a:	fa0c f904 	lsl.w	r9, ip, r4
   1c49e:	ea02 0209 	and.w	r2, r2, r9
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];
   1c4a2:	f895 9010 	ldrb.w	r9, [r5, #16]
        val_act = (data_tmp[byte_act] & (mask << pos)) >> pos;
   1c4a6:	4122      	asrs	r2, r4
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
   1c4a8:	b2d2      	uxtb	r2, r2
   1c4aa:	f009 091f 	and.w	r9, r9, #31
        pos -= px_size;
   1c4ae:	1a24      	subs	r4, r4, r0
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
   1c4b0:	f1b9 0f0e 	cmp.w	r9, #14
        pos -= px_size;
   1c4b4:	b264      	sxtb	r4, r4
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
   1c4b6:	bf18      	it	ne
   1c4b8:	5cb2      	ldrbne	r2, [r6, r2]
   1c4ba:	f808 2021 	strb.w	r2, [r8, r1, lsl #2]
        if(pos < 0) {
   1c4be:	2c00      	cmp	r4, #0
            pos = 8 - px_size;
   1c4c0:	bfbc      	itt	lt
   1c4c2:	4674      	movlt	r4, lr
            data_tmp++;
   1c4c4:	3301      	addlt	r3, #1
   1c4c6:	3101      	adds	r1, #1
   1c4c8:	e7ac      	b.n	1c424 <lv_img_decoder_built_in_read_line+0xf0>
    } else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT || dsc->header.cf == LV_IMG_CF_INDEXED_2BIT ||
   1c4ca:	3b07      	subs	r3, #7
   1c4cc:	2b03      	cmp	r3, #3
   1c4ce:	d87f      	bhi.n	1c5d0 <lv_img_decoder_built_in_read_line+0x29c>
    uint8_t px_size = lv_img_color_format_get_px_size(dsc->header.cf);
   1c4d0:	f000 001f 	and.w	r0, r0, #31
   1c4d4:	f7ff fd7a 	bl	1bfcc <lv_img_color_format_get_px_size>
    switch(dsc->header.cf) {
   1c4d8:	7c2b      	ldrb	r3, [r5, #16]
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
   1c4da:	f04f 0c01 	mov.w	ip, #1
   1c4de:	fa0c fc00 	lsl.w	ip, ip, r0
    switch(dsc->header.cf) {
   1c4e2:	f003 031f 	and.w	r3, r3, #31
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
   1c4e6:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    switch(dsc->header.cf) {
   1c4ea:	3b07      	subs	r3, #7
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
   1c4ec:	fa1f fc8c 	uxth.w	ip, ip
    switch(dsc->header.cf) {
   1c4f0:	2b03      	cmp	r3, #3
   1c4f2:	d866      	bhi.n	1c5c2 <lv_img_decoder_built_in_read_line+0x28e>
   1c4f4:	e8df f003 	tbb	[pc, r3]
   1c4f8:	5c4a3a02 	.word	0x5c4a3a02
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
   1c4fc:	692a      	ldr	r2, [r5, #16]
   1c4fe:	f3c2 228a 	ubfx	r2, r2, #10, #11
   1c502:	08d3      	lsrs	r3, r2, #3
            if(dsc->header.w & 0x7) w++;
   1c504:	0752      	lsls	r2, r2, #29
   1c506:	bf18      	it	ne
   1c508:	3301      	addne	r3, #1
            ofs += w * y + (x >> 3); /*First pixel*/
   1c50a:	10e2      	asrs	r2, r4, #3
   1c50c:	fb03 2306 	mla	r3, r3, r6, r2
            pos = 7 - (x & 0x7);
   1c510:	43e2      	mvns	r2, r4
            ofs += 8;                /*Skip the palette*/
   1c512:	3308      	adds	r3, #8
            pos = 7 - (x & 0x7);
   1c514:	f002 0207 	and.w	r2, r2, #7
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
   1c518:	7b29      	ldrb	r1, [r5, #12]
   1c51a:	2900      	cmp	r1, #0
   1c51c:	d154      	bne.n	1c5c8 <lv_img_decoder_built_in_read_line+0x294>
        data_tmp                     = img_dsc->data + ofs;
   1c51e:	686c      	ldr	r4, [r5, #4]
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
   1c520:	6a2e      	ldr	r6, [r5, #32]
        data_tmp                     = img_dsc->data + ofs;
   1c522:	68a4      	ldr	r4, [r4, #8]
        pos -= px_size;
   1c524:	b240      	sxtb	r0, r0
            pos = 8 - px_size;
   1c526:	f1c0 0e08 	rsb	lr, r0, #8
        data_tmp                     = img_dsc->data + ofs;
   1c52a:	4423      	add	r3, r4
    for(i = 0; i < len; i++) {
   1c52c:	f1a8 0804 	sub.w	r8, r8, #4
        data_tmp                     = img_dsc->data + ofs;
   1c530:	460d      	mov	r5, r1
            pos = 8 - px_size;
   1c532:	fa4f fe8e 	sxtb.w	lr, lr
    for(i = 0; i < len; i++) {
   1c536:	b229      	sxth	r1, r5
   1c538:	428f      	cmp	r7, r1
   1c53a:	f77f af76 	ble.w	1c42a <lv_img_decoder_built_in_read_line+0xf6>
        val_act = (*data_tmp & (mask << pos)) >> pos;
   1c53e:	7819      	ldrb	r1, [r3, #0]
   1c540:	fa0c f402 	lsl.w	r4, ip, r2
   1c544:	4021      	ands	r1, r4
   1c546:	4111      	asrs	r1, r2
        lv_color_t color = user_data->palette[val_act];
   1c548:	6834      	ldr	r4, [r6, #0]
   1c54a:	b2c9      	uxtb	r1, r1
        pos -= px_size;
   1c54c:	1a12      	subs	r2, r2, r0
        lv_color_t color = user_data->palette[val_act];
   1c54e:	f854 4021 	ldr.w	r4, [r4, r1, lsl #2]
        *((uint32_t *)&buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE]) = color.full;
   1c552:	f848 4f04 	str.w	r4, [r8, #4]!
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] = user_data->opa[val_act];
   1c556:	6874      	ldr	r4, [r6, #4]
        pos -= px_size;
   1c558:	b252      	sxtb	r2, r2
        if(pos < 0) {
   1c55a:	2a00      	cmp	r2, #0
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] = user_data->opa[val_act];
   1c55c:	5c61      	ldrb	r1, [r4, r1]
   1c55e:	f888 1003 	strb.w	r1, [r8, #3]
            pos = 8 - px_size;
   1c562:	bfbc      	itt	lt
   1c564:	4672      	movlt	r2, lr
            data_tmp++;
   1c566:	3301      	addlt	r3, #1
   1c568:	3501      	adds	r5, #1
   1c56a:	e7e4      	b.n	1c536 <lv_img_decoder_built_in_read_line+0x202>
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
   1c56c:	692a      	ldr	r2, [r5, #16]
   1c56e:	f3c2 228a 	ubfx	r2, r2, #10, #11
   1c572:	0893      	lsrs	r3, r2, #2
            if(dsc->header.w & 0x3) w++;
   1c574:	0791      	lsls	r1, r2, #30
   1c576:	bf18      	it	ne
   1c578:	3301      	addne	r3, #1
            ofs += w * y + (x >> 2); /*First pixel*/
   1c57a:	10a2      	asrs	r2, r4, #2
   1c57c:	fb03 2306 	mla	r3, r3, r6, r2
            pos = 6 - ((x & 0x3) * 2);
   1c580:	43e2      	mvns	r2, r4
   1c582:	f002 0203 	and.w	r2, r2, #3
            ofs += 16;               /*Skip the palette*/
   1c586:	3310      	adds	r3, #16
            pos = 6 - ((x & 0x3) * 2);
   1c588:	0052      	lsls	r2, r2, #1
            break;
   1c58a:	e7c5      	b.n	1c518 <lv_img_decoder_built_in_read_line+0x1e4>
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
   1c58c:	692a      	ldr	r2, [r5, #16]
   1c58e:	f3c2 228a 	ubfx	r2, r2, #10, #11
   1c592:	0853      	lsrs	r3, r2, #1
            if(dsc->header.w & 0x1) w++;
   1c594:	07d2      	lsls	r2, r2, #31
   1c596:	bf48      	it	mi
   1c598:	3301      	addmi	r3, #1
            ofs += w * y + (x >> 1); /*First pixel*/
   1c59a:	1062      	asrs	r2, r4, #1
   1c59c:	fb03 2306 	mla	r3, r3, r6, r2
            pos = 4 - ((x & 0x1) * 4);
   1c5a0:	f014 0f01 	tst.w	r4, #1
            ofs += 64;               /*Skip the palette*/
   1c5a4:	f103 0340 	add.w	r3, r3, #64	; 0x40
            pos = 4 - ((x & 0x1) * 4);
   1c5a8:	bf0c      	ite	eq
   1c5aa:	2204      	moveq	r2, #4
   1c5ac:	2200      	movne	r2, #0
   1c5ae:	e7b3      	b.n	1c518 <lv_img_decoder_built_in_read_line+0x1e4>
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
   1c5b0:	692b      	ldr	r3, [r5, #16]
   1c5b2:	f3c3 238a 	ubfx	r3, r3, #10, #11
            ofs += w * y + x;  /*First pixel*/
   1c5b6:	fb16 4303 	smlabb	r3, r6, r3, r4
            ofs += 1024;       /*Skip the palette*/
   1c5ba:	f503 6380 	add.w	r3, r3, #1024	; 0x400
            pos = 0;
   1c5be:	2200      	movs	r2, #0
   1c5c0:	e7aa      	b.n	1c518 <lv_img_decoder_built_in_read_line+0x1e4>
    uint32_t ofs = 0;
   1c5c2:	2300      	movs	r3, #0
    int8_t pos   = 0;
   1c5c4:	461a      	mov	r2, r3
   1c5c6:	e7a7      	b.n	1c518 <lv_img_decoder_built_in_read_line+0x1e4>
        LV_LOG_WARN("Image built-in indexed line reader can't read file because LV_USE_FILESYSTEM = 0");
   1c5c8:	4b07      	ldr	r3, [pc, #28]	; (1c5e8 <lv_img_decoder_built_in_read_line+0x2b4>)
   1c5ca:	f240 22ce 	movw	r2, #718	; 0x2ce
   1c5ce:	e6ca      	b.n	1c366 <lv_img_decoder_built_in_read_line+0x32>
        LV_LOG_WARN("Built-in image decoder read not supports the color format");
   1c5d0:	4b06      	ldr	r3, [pc, #24]	; (1c5ec <lv_img_decoder_built_in_read_line+0x2b8>)
   1c5d2:	f240 12e7 	movw	r2, #487	; 0x1e7
   1c5d6:	e6c6      	b.n	1c366 <lv_img_decoder_built_in_read_line+0x32>
   1c5d8:	00065819 	.word	0x00065819
   1c5dc:	000657dc 	.word	0x000657dc
   1c5e0:	00028768 	.word	0x00028768
   1c5e4:	000658fb 	.word	0x000658fb
   1c5e8:	0006594a 	.word	0x0006594a
   1c5ec:	0006599b 	.word	0x0006599b

0001c5f0 <lv_img_decoder_get_info>:
    header->always_zero = 0;
   1c5f0:	780b      	ldrb	r3, [r1, #0]
   1c5f2:	f36f 1347 	bfc	r3, #5, #3
{
   1c5f6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c5fa:	4607      	mov	r7, r0
    header->always_zero = 0;
   1c5fc:	700b      	strb	r3, [r1, #0]
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
   1c5fe:	480d      	ldr	r0, [pc, #52]	; (1c634 <lv_img_decoder_get_info+0x44>)
   1c600:	f8df 8030 	ldr.w	r8, [pc, #48]	; 1c634 <lv_img_decoder_get_info+0x44>
{
   1c604:	460e      	mov	r6, r1
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
   1c606:	f00a fe51 	bl	272ac <lv_ll_get_head>
    lv_res_t res = LV_RES_INV;
   1c60a:	2400      	movs	r4, #0
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
   1c60c:	4605      	mov	r5, r0
   1c60e:	b915      	cbnz	r5, 1c616 <lv_img_decoder_get_info+0x26>
}
   1c610:	4620      	mov	r0, r4
   1c612:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(d->info_cb) {
   1c616:	682c      	ldr	r4, [r5, #0]
   1c618:	b134      	cbz	r4, 1c628 <lv_img_decoder_get_info+0x38>
            res = d->info_cb(d, src, header);
   1c61a:	4632      	mov	r2, r6
   1c61c:	4639      	mov	r1, r7
   1c61e:	4628      	mov	r0, r5
   1c620:	47a0      	blx	r4
            if(res == LV_RES_OK) break;
   1c622:	2801      	cmp	r0, #1
            res = d->info_cb(d, src, header);
   1c624:	4604      	mov	r4, r0
            if(res == LV_RES_OK) break;
   1c626:	d0f3      	beq.n	1c610 <lv_img_decoder_get_info+0x20>
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
   1c628:	4629      	mov	r1, r5
   1c62a:	4640      	mov	r0, r8
   1c62c:	f00a fe44 	bl	272b8 <lv_ll_get_next>
   1c630:	4605      	mov	r5, r0
   1c632:	e7ec      	b.n	1c60e <lv_img_decoder_get_info+0x1e>
   1c634:	20001ed8 	.word	0x20001ed8

0001c638 <lv_img_decoder_open>:
{
   1c638:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1c63c:	4604      	mov	r4, r0
    dsc->style     = style;
   1c63e:	6082      	str	r2, [r0, #8]
    dsc->src_type  = lv_img_src_get_type(src);
   1c640:	4608      	mov	r0, r1
{
   1c642:	460f      	mov	r7, r1
    dsc->src_type  = lv_img_src_get_type(src);
   1c644:	f00a fc78 	bl	26f38 <lv_img_src_get_type>
    dsc->user_data = NULL;
   1c648:	2300      	movs	r3, #0
    if(dsc->src_type == LV_IMG_SRC_FILE) {
   1c64a:	2801      	cmp	r0, #1
    dsc->src_type  = lv_img_src_get_type(src);
   1c64c:	7320      	strb	r0, [r4, #12]
    dsc->user_data = NULL;
   1c64e:	6223      	str	r3, [r4, #32]
    if(dsc->src_type == LV_IMG_SRC_FILE) {
   1c650:	d11d      	bne.n	1c68e <lv_img_decoder_open+0x56>
        size_t fnlen = strlen(src);
   1c652:	4638      	mov	r0, r7
   1c654:	f7e5 fb28 	bl	1ca8 <strlen>
        dsc->src = lv_mem_alloc(fnlen + 1);
   1c658:	3001      	adds	r0, #1
   1c65a:	f000 fb3b 	bl	1ccd4 <lv_mem_alloc>
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
   1c65e:	4639      	mov	r1, r7
   1c660:	6060      	str	r0, [r4, #4]
   1c662:	f7e5 fb19 	bl	1c98 <strcpy>
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
   1c666:	4819      	ldr	r0, [pc, #100]	; (1c6cc <lv_img_decoder_open+0x94>)
   1c668:	f8df a060 	ldr.w	sl, [pc, #96]	; 1c6cc <lv_img_decoder_open+0x94>
   1c66c:	f00a fe1e 	bl	272ac <lv_ll_get_head>
    lv_res_t res = LV_RES_INV;
   1c670:	2600      	movs	r6, #0
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
   1c672:	4605      	mov	r5, r0
        res = d->info_cb(d, src, &dsc->header);
   1c674:	f104 0910 	add.w	r9, r4, #16
        dsc->error_msg = NULL;
   1c678:	46b0      	mov	r8, r6
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
   1c67a:	b955      	cbnz	r5, 1c692 <lv_img_decoder_open+0x5a>
    if(res == LV_RES_INV) {
   1c67c:	b926      	cbnz	r6, 1c688 <lv_img_decoder_open+0x50>
__ssp_bos_icheck3(memset, void *, int)
   1c67e:	2224      	movs	r2, #36	; 0x24
   1c680:	4631      	mov	r1, r6
   1c682:	4620      	mov	r0, r4
   1c684:	f7e5 fad3 	bl	1c2e <memset>
}
   1c688:	4630      	mov	r0, r6
   1c68a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        dsc->src       = src;
   1c68e:	6067      	str	r7, [r4, #4]
   1c690:	e7e9      	b.n	1c666 <lv_img_decoder_open+0x2e>
        if(d->info_cb == NULL || d->open_cb == NULL) continue;
   1c692:	682b      	ldr	r3, [r5, #0]
   1c694:	b1a3      	cbz	r3, 1c6c0 <lv_img_decoder_open+0x88>
   1c696:	686a      	ldr	r2, [r5, #4]
   1c698:	b192      	cbz	r2, 1c6c0 <lv_img_decoder_open+0x88>
        res = d->info_cb(d, src, &dsc->header);
   1c69a:	464a      	mov	r2, r9
   1c69c:	4639      	mov	r1, r7
   1c69e:	4628      	mov	r0, r5
   1c6a0:	4798      	blx	r3
        if(res != LV_RES_OK) continue;
   1c6a2:	2801      	cmp	r0, #1
        res = d->info_cb(d, src, &dsc->header);
   1c6a4:	4606      	mov	r6, r0
        if(res != LV_RES_OK) continue;
   1c6a6:	d10b      	bne.n	1c6c0 <lv_img_decoder_open+0x88>
        dsc->error_msg = NULL;
   1c6a8:	f8c4 801c 	str.w	r8, [r4, #28]
        dsc->img_data  = NULL;
   1c6ac:	f8c4 8014 	str.w	r8, [r4, #20]
        dsc->decoder   = d;
   1c6b0:	6025      	str	r5, [r4, #0]
        res = d->open_cb(d, dsc);
   1c6b2:	686b      	ldr	r3, [r5, #4]
   1c6b4:	4621      	mov	r1, r4
   1c6b6:	4628      	mov	r0, r5
   1c6b8:	4798      	blx	r3
        if(res == LV_RES_OK) break;
   1c6ba:	2801      	cmp	r0, #1
        res = d->open_cb(d, dsc);
   1c6bc:	4606      	mov	r6, r0
        if(res == LV_RES_OK) break;
   1c6be:	d0e3      	beq.n	1c688 <lv_img_decoder_open+0x50>
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
   1c6c0:	4629      	mov	r1, r5
   1c6c2:	4650      	mov	r0, sl
   1c6c4:	f00a fdf8 	bl	272b8 <lv_ll_get_next>
   1c6c8:	4605      	mov	r5, r0
   1c6ca:	e7d6      	b.n	1c67a <lv_img_decoder_open+0x42>
   1c6cc:	20001ed8 	.word	0x20001ed8

0001c6d0 <lv_img_decoder_create>:
{
   1c6d0:	b510      	push	{r4, lr}
    decoder = lv_ll_ins_head(&LV_GC_ROOT(_lv_img_defoder_ll));
   1c6d2:	4805      	ldr	r0, [pc, #20]	; (1c6e8 <lv_img_decoder_create+0x18>)
   1c6d4:	f00a fdb4 	bl	27240 <lv_ll_ins_head>
    if(decoder == NULL) return NULL;
   1c6d8:	4604      	mov	r4, r0
   1c6da:	b118      	cbz	r0, 1c6e4 <lv_img_decoder_create+0x14>
   1c6dc:	2214      	movs	r2, #20
   1c6de:	2100      	movs	r1, #0
   1c6e0:	f7e5 faa5 	bl	1c2e <memset>
}
   1c6e4:	4620      	mov	r0, r4
   1c6e6:	bd10      	pop	{r4, pc}
   1c6e8:	20001ed8 	.word	0x20001ed8

0001c6ec <lv_img_decoder_init>:
{
   1c6ec:	b510      	push	{r4, lr}
    lv_ll_init(&LV_GC_ROOT(_lv_img_defoder_ll), sizeof(lv_img_decoder_t));
   1c6ee:	2114      	movs	r1, #20
   1c6f0:	480b      	ldr	r0, [pc, #44]	; (1c720 <lv_img_decoder_init+0x34>)
   1c6f2:	f00a fd9b 	bl	2722c <lv_ll_init>
    decoder = lv_img_decoder_create();
   1c6f6:	f7ff ffeb 	bl	1c6d0 <lv_img_decoder_create>
    if(decoder == NULL) {
   1c6fa:	b938      	cbnz	r0, 1c70c <lv_img_decoder_init+0x20>
        LV_LOG_WARN("lv_img_decoder_init: out of memory");
   1c6fc:	4b09      	ldr	r3, [pc, #36]	; (1c724 <lv_img_decoder_init+0x38>)
   1c6fe:	490a      	ldr	r1, [pc, #40]	; (1c728 <lv_img_decoder_init+0x3c>)
   1c700:	2248      	movs	r2, #72	; 0x48
   1c702:	2002      	movs	r0, #2
}
   1c704:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        LV_LOG_WARN("lv_img_decoder_init: out of memory");
   1c708:	f000 bca6 	b.w	1d058 <lv_log_add>
    decoder->info_cb = info_cb;
   1c70c:	4b07      	ldr	r3, [pc, #28]	; (1c72c <lv_img_decoder_init+0x40>)
   1c70e:	6003      	str	r3, [r0, #0]
    decoder->open_cb = open_cb;
   1c710:	4b07      	ldr	r3, [pc, #28]	; (1c730 <lv_img_decoder_init+0x44>)
   1c712:	6043      	str	r3, [r0, #4]
    decoder->read_line_cb = read_line_cb;
   1c714:	4b07      	ldr	r3, [pc, #28]	; (1c734 <lv_img_decoder_init+0x48>)
   1c716:	6083      	str	r3, [r0, #8]
    decoder->close_cb = close_cb;
   1c718:	4b07      	ldr	r3, [pc, #28]	; (1c738 <lv_img_decoder_init+0x4c>)
   1c71a:	60c3      	str	r3, [r0, #12]
}
   1c71c:	bd10      	pop	{r4, pc}
   1c71e:	bf00      	nop
   1c720:	20001ed8 	.word	0x20001ed8
   1c724:	000659d5 	.word	0x000659d5
   1c728:	000657dc 	.word	0x000657dc
   1c72c:	0001c1b9 	.word	0x0001c1b9
   1c730:	0001c229 	.word	0x0001c229
   1c734:	0001c335 	.word	0x0001c335
   1c738:	00026f59 	.word	0x00026f59

0001c73c <lv_img_cache_open>:
 * @param style style of the image
 * @return pointer to the cache entry or NULL if can open the image
 */
lv_img_cache_entry_t * lv_img_cache_open(const void * src, const lv_style_t * style)
{
    if(entry_cnt == 0) {
   1c73c:	4b49      	ldr	r3, [pc, #292]	; (1c864 <lv_img_cache_open+0x128>)
{
   1c73e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if(entry_cnt == 0) {
   1c742:	881c      	ldrh	r4, [r3, #0]
{
   1c744:	4607      	mov	r7, r0
   1c746:	4688      	mov	r8, r1
   1c748:	4699      	mov	r9, r3
    if(entry_cnt == 0) {
   1c74a:	b944      	cbnz	r4, 1c75e <lv_img_cache_open+0x22>
        LV_LOG_WARN("lv_img_cache_open: the cache size is 0");
   1c74c:	4b46      	ldr	r3, [pc, #280]	; (1c868 <lv_img_cache_open+0x12c>)
   1c74e:	4947      	ldr	r1, [pc, #284]	; (1c86c <lv_img_cache_open+0x130>)
   1c750:	2244      	movs	r2, #68	; 0x44
   1c752:	2002      	movs	r0, #2
   1c754:	f000 fc80 	bl	1d058 <lv_log_add>

        if(cached_src->dec_dsc.time_to_open == 0) cached_src->dec_dsc.time_to_open = 1;
    }

    return cached_src;
}
   1c758:	4620      	mov	r0, r4
   1c75a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
   1c75e:	4b44      	ldr	r3, [pc, #272]	; (1c870 <lv_img_cache_open+0x134>)
        if(cache[i].life > INT32_MIN + LV_IMG_CACHE_AGING) {
   1c760:	4844      	ldr	r0, [pc, #272]	; (1c874 <lv_img_cache_open+0x138>)
    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
   1c762:	681d      	ldr	r5, [r3, #0]
    for(i = 0; i < entry_cnt; i++) {
   1c764:	2100      	movs	r1, #0
   1c766:	462b      	mov	r3, r5
   1c768:	b28a      	uxth	r2, r1
   1c76a:	4294      	cmp	r4, r2
   1c76c:	d839      	bhi.n	1c7e2 <lv_img_cache_open+0xa6>
   1c76e:	2600      	movs	r6, #0
        lv_img_src_t src_type = lv_img_src_get_type(cache[i].dec_dsc.src);
   1c770:	f04f 0a28 	mov.w	sl, #40	; 0x28
    for(i = 0; i < entry_cnt; i++) {
   1c774:	f8b9 1000 	ldrh.w	r1, [r9]
   1c778:	b2b3      	uxth	r3, r6
   1c77a:	4299      	cmp	r1, r3
   1c77c:	d83a      	bhi.n	1c7f4 <lv_img_cache_open+0xb8>
   1c77e:	f105 0228 	add.w	r2, r5, #40	; 0x28
        cached_src = &cache[0];
   1c782:	462c      	mov	r4, r5
        for(i = 1; i < entry_cnt; i++) {
   1c784:	2301      	movs	r3, #1
   1c786:	4299      	cmp	r1, r3
   1c788:	d853      	bhi.n	1c832 <lv_img_cache_open+0xf6>
        if(cached_src->dec_dsc.src) {
   1c78a:	6863      	ldr	r3, [r4, #4]
   1c78c:	2b00      	cmp	r3, #0
   1c78e:	d059      	beq.n	1c844 <lv_img_cache_open+0x108>
            lv_img_decoder_close(&cached_src->dec_dsc);
   1c790:	4620      	mov	r0, r4
   1c792:	f00a fbff 	bl	26f94 <lv_img_decoder_close>
            LV_LOG_INFO("image draw: cache miss, close and reuse an entry");
   1c796:	4b38      	ldr	r3, [pc, #224]	; (1c878 <lv_img_cache_open+0x13c>)
   1c798:	2276      	movs	r2, #118	; 0x76
            LV_LOG_INFO("image draw: cache miss, cached to an empty entry");
   1c79a:	4934      	ldr	r1, [pc, #208]	; (1c86c <lv_img_cache_open+0x130>)
   1c79c:	2001      	movs	r0, #1
   1c79e:	f000 fc5b 	bl	1d058 <lv_log_add>
        t_start                          = lv_tick_get();
   1c7a2:	f00a fc49 	bl	27038 <lv_tick_get>
        cached_src->dec_dsc.time_to_open = 0;
   1c7a6:	2600      	movs	r6, #0
        t_start                          = lv_tick_get();
   1c7a8:	4681      	mov	r9, r0
        cached_src->dec_dsc.time_to_open = 0;
   1c7aa:	61a6      	str	r6, [r4, #24]
        lv_res_t open_res                = lv_img_decoder_open(&cached_src->dec_dsc, src, style);
   1c7ac:	4642      	mov	r2, r8
   1c7ae:	4639      	mov	r1, r7
   1c7b0:	4620      	mov	r0, r4
   1c7b2:	f7ff ff41 	bl	1c638 <lv_img_decoder_open>
        if(open_res == LV_RES_INV) {
   1c7b6:	4605      	mov	r5, r0
   1c7b8:	2800      	cmp	r0, #0
   1c7ba:	d146      	bne.n	1c84a <lv_img_cache_open+0x10e>
            LV_LOG_WARN("Image draw cannot open the image resource");
   1c7bc:	4b2f      	ldr	r3, [pc, #188]	; (1c87c <lv_img_cache_open+0x140>)
   1c7be:	492b      	ldr	r1, [pc, #172]	; (1c86c <lv_img_cache_open+0x130>)
   1c7c0:	2281      	movs	r2, #129	; 0x81
   1c7c2:	2002      	movs	r0, #2
   1c7c4:	f000 fc48 	bl	1d058 <lv_log_add>
            lv_img_decoder_close(&cached_src->dec_dsc);
   1c7c8:	4620      	mov	r0, r4
   1c7ca:	f00a fbe3 	bl	26f94 <lv_img_decoder_close>
   1c7ce:	4620      	mov	r0, r4
   1c7d0:	2224      	movs	r2, #36	; 0x24
   1c7d2:	4629      	mov	r1, r5
   1c7d4:	f7e5 fa2b 	bl	1c2e <memset>
            cached_src->life = INT32_MIN; /*Make the empty entry very "weak" to force its use  */
   1c7d8:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   1c7dc:	6263      	str	r3, [r4, #36]	; 0x24
            return NULL;
   1c7de:	462c      	mov	r4, r5
   1c7e0:	e7ba      	b.n	1c758 <lv_img_cache_open+0x1c>
        if(cache[i].life > INT32_MIN + LV_IMG_CACHE_AGING) {
   1c7e2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   1c7e4:	4282      	cmp	r2, r0
            cache[i].life -= LV_IMG_CACHE_AGING;
   1c7e6:	bfa4      	itt	ge
   1c7e8:	f102 32ff 	addge.w	r2, r2, #4294967295	; 0xffffffff
   1c7ec:	625a      	strge	r2, [r3, #36]	; 0x24
   1c7ee:	3101      	adds	r1, #1
   1c7f0:	3328      	adds	r3, #40	; 0x28
   1c7f2:	e7b9      	b.n	1c768 <lv_img_cache_open+0x2c>
        lv_img_src_t src_type = lv_img_src_get_type(cache[i].dec_dsc.src);
   1c7f4:	b2b4      	uxth	r4, r6
   1c7f6:	fb0a 5404 	mla	r4, sl, r4, r5
   1c7fa:	6860      	ldr	r0, [r4, #4]
   1c7fc:	f00a fb9c 	bl	26f38 <lv_img_src_get_type>
        if(src_type == LV_IMG_SRC_VARIABLE) {
   1c800:	b950      	cbnz	r0, 1c818 <lv_img_cache_open+0xdc>
            if(cache[i].dec_dsc.src == src) match = true;
   1c802:	6863      	ldr	r3, [r4, #4]
   1c804:	42bb      	cmp	r3, r7
   1c806:	d10f      	bne.n	1c828 <lv_img_cache_open+0xec>
            cached_src->life += cached_src->dec_dsc.time_to_open * LV_IMG_CACHE_LIFE_GAIN;
   1c808:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1c80a:	69a2      	ldr	r2, [r4, #24]
   1c80c:	4413      	add	r3, r2
            if(cached_src->life > LV_IMG_CACHE_LIFE_LIMIT) cached_src->life = LV_IMG_CACHE_LIFE_LIMIT;
   1c80e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   1c812:	dc0b      	bgt.n	1c82c <lv_img_cache_open+0xf0>
   1c814:	6263      	str	r3, [r4, #36]	; 0x24
   1c816:	e79f      	b.n	1c758 <lv_img_cache_open+0x1c>
        } else if(src_type == LV_IMG_SRC_FILE) {
   1c818:	2801      	cmp	r0, #1
   1c81a:	d105      	bne.n	1c828 <lv_img_cache_open+0xec>
            if(strcmp(cache[i].dec_dsc.src, src) == 0) match = true;
   1c81c:	4639      	mov	r1, r7
   1c81e:	6860      	ldr	r0, [r4, #4]
   1c820:	f7e5 fa30 	bl	1c84 <strcmp>
   1c824:	2800      	cmp	r0, #0
   1c826:	d0ef      	beq.n	1c808 <lv_img_cache_open+0xcc>
   1c828:	3601      	adds	r6, #1
   1c82a:	e7a3      	b.n	1c774 <lv_img_cache_open+0x38>
            if(cached_src->life > LV_IMG_CACHE_LIFE_LIMIT) cached_src->life = LV_IMG_CACHE_LIFE_LIMIT;
   1c82c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1c830:	e7f0      	b.n	1c814 <lv_img_cache_open+0xd8>
            if(cache[i].life < cached_src->life) {
   1c832:	6a55      	ldr	r5, [r2, #36]	; 0x24
   1c834:	6a60      	ldr	r0, [r4, #36]	; 0x24
        for(i = 1; i < entry_cnt; i++) {
   1c836:	3301      	adds	r3, #1
            if(cache[i].life < cached_src->life) {
   1c838:	4285      	cmp	r5, r0
   1c83a:	bfb8      	it	lt
   1c83c:	4614      	movlt	r4, r2
        for(i = 1; i < entry_cnt; i++) {
   1c83e:	b29b      	uxth	r3, r3
   1c840:	3228      	adds	r2, #40	; 0x28
   1c842:	e7a0      	b.n	1c786 <lv_img_cache_open+0x4a>
            LV_LOG_INFO("image draw: cache miss, cached to an empty entry");
   1c844:	4b0e      	ldr	r3, [pc, #56]	; (1c880 <lv_img_cache_open+0x144>)
   1c846:	2278      	movs	r2, #120	; 0x78
   1c848:	e7a7      	b.n	1c79a <lv_img_cache_open+0x5e>
        if(cached_src->dec_dsc.time_to_open == 0) {
   1c84a:	69a3      	ldr	r3, [r4, #24]
        cached_src->life = 0;
   1c84c:	6266      	str	r6, [r4, #36]	; 0x24
        if(cached_src->dec_dsc.time_to_open == 0) {
   1c84e:	2b00      	cmp	r3, #0
   1c850:	d182      	bne.n	1c758 <lv_img_cache_open+0x1c>
            cached_src->dec_dsc.time_to_open = lv_tick_elaps(t_start);
   1c852:	4648      	mov	r0, r9
   1c854:	f00a fbf4 	bl	27040 <lv_tick_elaps>
        if(cached_src->dec_dsc.time_to_open == 0) cached_src->dec_dsc.time_to_open = 1;
   1c858:	b108      	cbz	r0, 1c85e <lv_img_cache_open+0x122>
            cached_src->dec_dsc.time_to_open = lv_tick_elaps(t_start);
   1c85a:	61a0      	str	r0, [r4, #24]
   1c85c:	e77c      	b.n	1c758 <lv_img_cache_open+0x1c>
        if(cached_src->dec_dsc.time_to_open == 0) cached_src->dec_dsc.time_to_open = 1;
   1c85e:	2301      	movs	r3, #1
   1c860:	61a3      	str	r3, [r4, #24]
   1c862:	e779      	b.n	1c758 <lv_img_cache_open+0x1c>
   1c864:	20006144 	.word	0x20006144
   1c868:	000659f8 	.word	0x000659f8
   1c86c:	00065a1f 	.word	0x00065a1f
   1c870:	20001ed4 	.word	0x20001ed4
   1c874:	80000002 	.word	0x80000002
   1c878:	00065a5a 	.word	0x00065a5a
   1c87c:	00065abc 	.word	0x00065abc
   1c880:	00065a8b 	.word	0x00065a8b

0001c884 <lv_img_cache_invalidate_src>:
 * Invalidate an image source in the cache.
 * Useful if the image source is updated therefore it needs to be cached again.
 * @param src an image source path to a file or pointer to an `lv_img_dsc_t` variable.
 */
void lv_img_cache_invalidate_src(const void * src)
{
   1c884:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
   1c888:	4b0f      	ldr	r3, [pc, #60]	; (1c8c8 <lv_img_cache_invalidate_src+0x44>)

    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
   1c88a:	4f10      	ldr	r7, [pc, #64]	; (1c8cc <lv_img_cache_invalidate_src+0x48>)
    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
   1c88c:	f8d3 8000 	ldr.w	r8, [r3]
{
   1c890:	4606      	mov	r6, r0
    for(i = 0; i < entry_cnt; i++) {
   1c892:	2500      	movs	r5, #0
        if(cache[i].dec_dsc.src == src || src == NULL) {
   1c894:	f04f 0928 	mov.w	r9, #40	; 0x28
    for(i = 0; i < entry_cnt; i++) {
   1c898:	883a      	ldrh	r2, [r7, #0]
   1c89a:	b2ab      	uxth	r3, r5
   1c89c:	429a      	cmp	r2, r3
   1c89e:	d801      	bhi.n	1c8a4 <lv_img_cache_invalidate_src+0x20>

            memset(&cache[i].dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
            memset(&cache[i], 0, sizeof(lv_img_cache_entry_t));
        }
    }
}
   1c8a0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if(cache[i].dec_dsc.src == src || src == NULL) {
   1c8a4:	b2ac      	uxth	r4, r5
   1c8a6:	fb09 8404 	mla	r4, r9, r4, r8
   1c8aa:	6863      	ldr	r3, [r4, #4]
   1c8ac:	42b3      	cmp	r3, r6
   1c8ae:	d000      	beq.n	1c8b2 <lv_img_cache_invalidate_src+0x2e>
   1c8b0:	b946      	cbnz	r6, 1c8c4 <lv_img_cache_invalidate_src+0x40>
            if(cache[i].dec_dsc.src != NULL) {
   1c8b2:	b113      	cbz	r3, 1c8ba <lv_img_cache_invalidate_src+0x36>
                lv_img_decoder_close(&cache[i].dec_dsc);
   1c8b4:	4620      	mov	r0, r4
   1c8b6:	f00a fb6d 	bl	26f94 <lv_img_decoder_close>
   1c8ba:	2228      	movs	r2, #40	; 0x28
   1c8bc:	2100      	movs	r1, #0
   1c8be:	4620      	mov	r0, r4
   1c8c0:	f7e5 f9b5 	bl	1c2e <memset>
   1c8c4:	3501      	adds	r5, #1
   1c8c6:	e7e7      	b.n	1c898 <lv_img_cache_invalidate_src+0x14>
   1c8c8:	20001ed4 	.word	0x20001ed4
   1c8cc:	20006144 	.word	0x20006144

0001c8d0 <lv_img_cache_set_size>:
{
   1c8d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(LV_GC_ROOT(_lv_img_cache_array) != NULL) {
   1c8d4:	4c14      	ldr	r4, [pc, #80]	; (1c928 <lv_img_cache_set_size+0x58>)
   1c8d6:	6823      	ldr	r3, [r4, #0]
{
   1c8d8:	4607      	mov	r7, r0
    if(LV_GC_ROOT(_lv_img_cache_array) != NULL) {
   1c8da:	b12b      	cbz	r3, 1c8e8 <lv_img_cache_set_size+0x18>
        lv_img_cache_invalidate_src(NULL);
   1c8dc:	2000      	movs	r0, #0
   1c8de:	f7ff ffd1 	bl	1c884 <lv_img_cache_invalidate_src>
        lv_mem_free(LV_GC_ROOT(_lv_img_cache_array));
   1c8e2:	6820      	ldr	r0, [r4, #0]
   1c8e4:	f000 fa1c 	bl	1cd20 <lv_mem_free>
    LV_GC_ROOT(_lv_img_cache_array) = lv_mem_alloc(sizeof(lv_img_cache_entry_t) * new_entry_cnt);
   1c8e8:	2628      	movs	r6, #40	; 0x28
   1c8ea:	fb06 f007 	mul.w	r0, r6, r7
   1c8ee:	f000 f9f1 	bl	1ccd4 <lv_mem_alloc>
   1c8f2:	4b0e      	ldr	r3, [pc, #56]	; (1c92c <lv_img_cache_set_size+0x5c>)
   1c8f4:	6020      	str	r0, [r4, #0]
    if(LV_GC_ROOT(_lv_img_cache_array) == NULL) {
   1c8f6:	b910      	cbnz	r0, 1c8fe <lv_img_cache_set_size+0x2e>
        entry_cnt = 0;
   1c8f8:	8018      	strh	r0, [r3, #0]
}
   1c8fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    entry_cnt = new_entry_cnt;
   1c8fe:	801f      	strh	r7, [r3, #0]
    for(i = 0; i < entry_cnt; i++) {
   1c900:	2500      	movs	r5, #0
   1c902:	42af      	cmp	r7, r5
   1c904:	d0f9      	beq.n	1c8fa <lv_img_cache_set_size+0x2a>
        memset(&LV_GC_ROOT(_lv_img_cache_array)[i].dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
   1c906:	6820      	ldr	r0, [r4, #0]
   1c908:	fb06 f805 	mul.w	r8, r6, r5
   1c90c:	2224      	movs	r2, #36	; 0x24
   1c90e:	2100      	movs	r1, #0
   1c910:	4440      	add	r0, r8
   1c912:	f7e5 f98c 	bl	1c2e <memset>
        memset(&LV_GC_ROOT(_lv_img_cache_array)[i], 0, sizeof(lv_img_cache_entry_t));
   1c916:	6820      	ldr	r0, [r4, #0]
   1c918:	2228      	movs	r2, #40	; 0x28
   1c91a:	2100      	movs	r1, #0
   1c91c:	4440      	add	r0, r8
   1c91e:	f7e5 f986 	bl	1c2e <memset>
   1c922:	3501      	adds	r5, #1
   1c924:	e7ed      	b.n	1c902 <lv_img_cache_set_size+0x32>
   1c926:	bf00      	nop
   1c928:	20001ed4 	.word	0x20001ed4
   1c92c:	20006144 	.word	0x20006144

0001c930 <lv_disp_drv_register>:
 * Automatically set the first display as active.
 * @param driver pointer to an initialized 'lv_disp_drv_t' variable (can be local variable)
 * @return pointer to the new display or NULL on error
 */
lv_disp_t * lv_disp_drv_register(lv_disp_drv_t * driver)
{
   1c930:	b570      	push	{r4, r5, r6, lr}
   1c932:	4605      	mov	r5, r0
    lv_disp_t * disp = lv_ll_ins_head(&LV_GC_ROOT(_lv_disp_ll));
   1c934:	482b      	ldr	r0, [pc, #172]	; (1c9e4 <lv_disp_drv_register+0xb4>)
   1c936:	f00a fc83 	bl	27240 <lv_ll_ins_head>
    if(!disp) {
   1c93a:	4604      	mov	r4, r0
   1c93c:	b910      	cbnz	r0, 1c944 <lv_disp_drv_register+0x14>
        LV_ASSERT_MEM(disp);
        return NULL;
   1c93e:	2400      	movs	r4, #0
    if(disp->refr_task == NULL) return NULL;

    lv_task_ready(disp->refr_task); /*Be sure the screen will be refreshed immediately on start up*/

    return disp;
}
   1c940:	4620      	mov	r0, r4
   1c942:	bd70      	pop	{r4, r5, r6, pc}
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1c944:	4628      	mov	r0, r5
   1c946:	4623      	mov	r3, r4
   1c948:	f105 0224 	add.w	r2, r5, #36	; 0x24
   1c94c:	f850 1b04 	ldr.w	r1, [r0], #4
   1c950:	f843 1b04 	str.w	r1, [r3], #4
   1c954:	4290      	cmp	r0, r2
   1c956:	d1f9      	bne.n	1c94c <lv_disp_drv_register+0x1c>
__ssp_bos_icheck3(memset, void *, int)
   1c958:	2220      	movs	r2, #32
   1c95a:	2100      	movs	r1, #0
   1c95c:	f504 70a0 	add.w	r0, r4, #320	; 0x140
   1c960:	f7e5 f965 	bl	1c2e <memset>
    if(disp_def == NULL) disp_def = disp;
   1c964:	4d20      	ldr	r5, [pc, #128]	; (1c9e8 <lv_disp_drv_register+0xb8>)
   1c966:	f44f 7280 	mov.w	r2, #256	; 0x100
   1c96a:	2100      	movs	r1, #0
   1c96c:	f104 0040 	add.w	r0, r4, #64	; 0x40
   1c970:	f7e5 f95d 	bl	1c2e <memset>
    lv_ll_init(&disp->scr_ll, sizeof(lv_obj_t));
   1c974:	2138      	movs	r1, #56	; 0x38
   1c976:	f104 0028 	add.w	r0, r4, #40	; 0x28
   1c97a:	f00a fc57 	bl	2722c <lv_ll_init>
    if(disp_def == NULL) disp_def = disp;
   1c97e:	682b      	ldr	r3, [r5, #0]
   1c980:	b903      	cbnz	r3, 1c984 <lv_disp_drv_register+0x54>
   1c982:	602c      	str	r4, [r5, #0]
    disp->inv_p = 0;
   1c984:	f8b4 3160 	ldrh.w	r3, [r4, #352]	; 0x160
    lv_disp_t * disp_def_tmp = disp_def;
   1c988:	682e      	ldr	r6, [r5, #0]
    disp_def                 = disp; /*Temporarily change the default screen to create the default screens on the
   1c98a:	602c      	str	r4, [r5, #0]
    disp->inv_p = 0;
   1c98c:	f36f 0309 	bfc	r3, #0, #10
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
   1c990:	2100      	movs	r1, #0
    disp->inv_p = 0;
   1c992:	f8a4 3160 	strh.w	r3, [r4, #352]	; 0x160
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
   1c996:	4608      	mov	r0, r1
   1c998:	f7fe f99a 	bl	1acd0 <lv_obj_create>
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
   1c99c:	2100      	movs	r1, #0
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
   1c99e:	6360      	str	r0, [r4, #52]	; 0x34
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
   1c9a0:	4608      	mov	r0, r1
   1c9a2:	f7fe f995 	bl	1acd0 <lv_obj_create>
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
   1c9a6:	2100      	movs	r1, #0
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
   1c9a8:	63a0      	str	r0, [r4, #56]	; 0x38
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
   1c9aa:	4608      	mov	r0, r1
   1c9ac:	f7fe f990 	bl	1acd0 <lv_obj_create>
    lv_obj_set_style(disp->top_layer, &lv_style_transp);
   1c9b0:	490e      	ldr	r1, [pc, #56]	; (1c9ec <lv_disp_drv_register+0xbc>)
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
   1c9b2:	63e0      	str	r0, [r4, #60]	; 0x3c
    lv_obj_set_style(disp->top_layer, &lv_style_transp);
   1c9b4:	6ba0      	ldr	r0, [r4, #56]	; 0x38
   1c9b6:	f008 feed 	bl	25794 <lv_obj_set_style>
    lv_obj_set_style(disp->sys_layer, &lv_style_transp);
   1c9ba:	490c      	ldr	r1, [pc, #48]	; (1c9ec <lv_disp_drv_register+0xbc>)
   1c9bc:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1c9be:	f008 fee9 	bl	25794 <lv_obj_set_style>
    lv_obj_invalidate(disp->act_scr);
   1c9c2:	6b60      	ldr	r0, [r4, #52]	; 0x34
   1c9c4:	f008 fdd1 	bl	2556a <lv_obj_invalidate>
    disp->refr_task = lv_task_create(lv_disp_refr_task, LV_DISP_DEF_REFR_PERIOD, LV_TASK_PRIO_MID, disp);
   1c9c8:	4623      	mov	r3, r4
   1c9ca:	2203      	movs	r2, #3
   1c9cc:	2132      	movs	r1, #50	; 0x32
   1c9ce:	4808      	ldr	r0, [pc, #32]	; (1c9f0 <lv_disp_drv_register+0xc0>)
    disp_def = disp_def_tmp; /*Revert the default display*/
   1c9d0:	602e      	str	r6, [r5, #0]
    disp->refr_task = lv_task_create(lv_disp_refr_task, LV_DISP_DEF_REFR_PERIOD, LV_TASK_PRIO_MID, disp);
   1c9d2:	f00a fc00 	bl	271d6 <lv_task_create>
   1c9d6:	6260      	str	r0, [r4, #36]	; 0x24
    if(disp->refr_task == NULL) return NULL;
   1c9d8:	2800      	cmp	r0, #0
   1c9da:	d0b0      	beq.n	1c93e <lv_disp_drv_register+0xe>
    lv_task_ready(disp->refr_task); /*Be sure the screen will be refreshed immediately on start up*/
   1c9dc:	f00a fc0f 	bl	271fe <lv_task_ready>
    return disp;
   1c9e0:	e7ae      	b.n	1c940 <lv_disp_drv_register+0x10>
   1c9e2:	bf00      	nop
   1c9e4:	20001ec4 	.word	0x20001ec4
   1c9e8:	20001eac 	.word	0x20001eac
   1c9ec:	20001db8 	.word	0x20001db8
   1c9f0:	0001b08d 	.word	0x0001b08d

0001c9f4 <lv_disp_get_default>:
 * @return pointer to the default display
 */
lv_disp_t * lv_disp_get_default(void)
{
    return disp_def;
}
   1c9f4:	4b01      	ldr	r3, [pc, #4]	; (1c9fc <lv_disp_get_default+0x8>)
   1c9f6:	6818      	ldr	r0, [r3, #0]
   1c9f8:	4770      	bx	lr
   1c9fa:	bf00      	nop
   1c9fc:	20001eac 	.word	0x20001eac

0001ca00 <lv_disp_get_hor_res>:
 * @param disp pointer to a display (NULL to use the default display)
 * @return the horizontal resolution of the display
 */
lv_coord_t lv_disp_get_hor_res(lv_disp_t * disp)
{
    if(disp == NULL) disp = lv_disp_get_default();
   1ca00:	b910      	cbnz	r0, 1ca08 <lv_disp_get_hor_res+0x8>
    return disp_def;
   1ca02:	4b06      	ldr	r3, [pc, #24]	; (1ca1c <lv_disp_get_hor_res+0x1c>)
   1ca04:	6818      	ldr	r0, [r3, #0]

    if(disp == NULL)
   1ca06:	b138      	cbz	r0, 1ca18 <lv_disp_get_hor_res+0x18>
        return LV_HOR_RES_MAX;
    else
        return disp->driver.rotated == 0 ? disp->driver.hor_res : disp->driver.ver_res;
   1ca08:	7a03      	ldrb	r3, [r0, #8]
   1ca0a:	07db      	lsls	r3, r3, #31
   1ca0c:	bf54      	ite	pl
   1ca0e:	f9b0 0000 	ldrshpl.w	r0, [r0]
   1ca12:	f9b0 0002 	ldrshmi.w	r0, [r0, #2]
   1ca16:	4770      	bx	lr
        return LV_HOR_RES_MAX;
   1ca18:	20f0      	movs	r0, #240	; 0xf0
}
   1ca1a:	4770      	bx	lr
   1ca1c:	20001eac 	.word	0x20001eac

0001ca20 <lv_disp_get_ver_res>:
 * @param disp pointer to a display (NULL to use the default display)
 * @return the vertical resolution of the display
 */
lv_coord_t lv_disp_get_ver_res(lv_disp_t * disp)
{
    if(disp == NULL) disp = lv_disp_get_default();
   1ca20:	b910      	cbnz	r0, 1ca28 <lv_disp_get_ver_res+0x8>
    return disp_def;
   1ca22:	4b06      	ldr	r3, [pc, #24]	; (1ca3c <lv_disp_get_ver_res+0x1c>)
   1ca24:	6818      	ldr	r0, [r3, #0]

    if(disp == NULL)
   1ca26:	b138      	cbz	r0, 1ca38 <lv_disp_get_ver_res+0x18>
        return LV_VER_RES_MAX;
    else
        return disp->driver.rotated == 0 ? disp->driver.ver_res : disp->driver.hor_res;
   1ca28:	7a03      	ldrb	r3, [r0, #8]
   1ca2a:	07db      	lsls	r3, r3, #31
   1ca2c:	bf54      	ite	pl
   1ca2e:	f9b0 0002 	ldrshpl.w	r0, [r0, #2]
   1ca32:	f9b0 0000 	ldrshmi.w	r0, [r0]
   1ca36:	4770      	bx	lr
        return LV_VER_RES_MAX;
   1ca38:	20f0      	movs	r0, #240	; 0xf0
}
   1ca3a:	4770      	bx	lr
   1ca3c:	20001eac 	.word	0x20001eac

0001ca40 <lv_indev_get_next>:
 * @return the next input devise or NULL if no more. Give the first input device when the parameter
 * is NULL
 */
lv_indev_t * lv_indev_get_next(lv_indev_t * indev)
{
    if(indev == NULL)
   1ca40:	4601      	mov	r1, r0
        return lv_ll_get_head(&LV_GC_ROOT(_lv_indev_ll));
   1ca42:	4803      	ldr	r0, [pc, #12]	; (1ca50 <lv_indev_get_next+0x10>)
    if(indev == NULL)
   1ca44:	b909      	cbnz	r1, 1ca4a <lv_indev_get_next+0xa>
        return lv_ll_get_head(&LV_GC_ROOT(_lv_indev_ll));
   1ca46:	f00a bc31 	b.w	272ac <lv_ll_get_head>
    else
        return lv_ll_get_next(&LV_GC_ROOT(_lv_indev_ll), indev);
   1ca4a:	f00a bc35 	b.w	272b8 <lv_ll_get_next>
   1ca4e:	bf00      	nop
   1ca50:	20001ee4 	.word	0x20001ee4

0001ca54 <lv_task_core_init>:

/**
 * Init the lv_task module
 */
void lv_task_core_init(void)
{
   1ca54:	b508      	push	{r3, lr}
    lv_ll_init(&LV_GC_ROOT(_lv_task_ll), sizeof(lv_task_t));
   1ca56:	2114      	movs	r1, #20
   1ca58:	4803      	ldr	r0, [pc, #12]	; (1ca68 <lv_task_core_init+0x14>)
   1ca5a:	f00a fbe7 	bl	2722c <lv_ll_init>
 * Enable or disable the whole lv_task handling
 * @param en: true: lv_task handling is running, false: lv_task handling is suspended
 */
void lv_task_enable(bool en)
{
    lv_task_run = en;
   1ca5e:	4b03      	ldr	r3, [pc, #12]	; (1ca6c <lv_task_core_init+0x18>)
   1ca60:	2201      	movs	r2, #1
   1ca62:	701a      	strb	r2, [r3, #0]
}
   1ca64:	bd08      	pop	{r3, pc}
   1ca66:	bf00      	nop
   1ca68:	20001ef4 	.word	0x20001ef4
   1ca6c:	2000abd7 	.word	0x2000abd7

0001ca70 <lv_task_create_basic>:
{
   1ca70:	b538      	push	{r3, r4, r5, lr}
    tmp = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
   1ca72:	481a      	ldr	r0, [pc, #104]	; (1cadc <lv_task_create_basic+0x6c>)
   1ca74:	f00a fc1a 	bl	272ac <lv_ll_get_head>
    if(NULL == tmp) {
   1ca78:	4601      	mov	r1, r0
   1ca7a:	b148      	cbz	r0, 1ca90 <lv_task_create_basic+0x20>
            tmp = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), tmp);
   1ca7c:	4c17      	ldr	r4, [pc, #92]	; (1cadc <lv_task_create_basic+0x6c>)
            if(tmp->prio <= DEF_PRIO) {
   1ca7e:	7c0b      	ldrb	r3, [r1, #16]
   1ca80:	f003 0307 	and.w	r3, r3, #7
   1ca84:	2b03      	cmp	r3, #3
   1ca86:	d80b      	bhi.n	1caa0 <lv_task_create_basic+0x30>
                new_task = lv_ll_ins_prev(&LV_GC_ROOT(_lv_task_ll), tmp);
   1ca88:	4814      	ldr	r0, [pc, #80]	; (1cadc <lv_task_create_basic+0x6c>)
   1ca8a:	f00a fc1e 	bl	272ca <lv_ll_ins_prev>
   1ca8e:	e002      	b.n	1ca96 <lv_task_create_basic+0x26>
        new_task = lv_ll_ins_head(&LV_GC_ROOT(_lv_task_ll));
   1ca90:	4812      	ldr	r0, [pc, #72]	; (1cadc <lv_task_create_basic+0x6c>)
   1ca92:	f00a fbd5 	bl	27240 <lv_ll_ins_head>
        if(new_task == NULL) return NULL;
   1ca96:	4604      	mov	r4, r0
   1ca98:	b960      	cbnz	r0, 1cab4 <lv_task_create_basic+0x44>
   1ca9a:	2400      	movs	r4, #0
}
   1ca9c:	4620      	mov	r0, r4
   1ca9e:	bd38      	pop	{r3, r4, r5, pc}
            tmp = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), tmp);
   1caa0:	4620      	mov	r0, r4
   1caa2:	f00a fc09 	bl	272b8 <lv_ll_get_next>
        } while(tmp != NULL);
   1caa6:	4601      	mov	r1, r0
   1caa8:	2800      	cmp	r0, #0
   1caaa:	d1e8      	bne.n	1ca7e <lv_task_create_basic+0xe>
            new_task = lv_ll_ins_tail(&LV_GC_ROOT(_lv_task_ll));
   1caac:	480b      	ldr	r0, [pc, #44]	; (1cadc <lv_task_create_basic+0x6c>)
   1caae:	f00a fbe2 	bl	27276 <lv_ll_ins_tail>
   1cab2:	e7f0      	b.n	1ca96 <lv_task_create_basic+0x26>
    new_task->period  = DEF_PERIOD;
   1cab4:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   1cab8:	6003      	str	r3, [r0, #0]
    new_task->prio    = DEF_PRIO;
   1caba:	7c03      	ldrb	r3, [r0, #16]
   1cabc:	f023 030f 	bic.w	r3, r3, #15
   1cac0:	f043 0303 	orr.w	r3, r3, #3
    new_task->task_cb = NULL;
   1cac4:	2500      	movs	r5, #0
    new_task->prio    = DEF_PRIO;
   1cac6:	7403      	strb	r3, [r0, #16]
    new_task->task_cb = NULL;
   1cac8:	6085      	str	r5, [r0, #8]
    new_task->last_run = lv_tick_get();
   1caca:	f00a fab5 	bl	27038 <lv_tick_get>
    task_created = true;
   1cace:	4b04      	ldr	r3, [pc, #16]	; (1cae0 <lv_task_create_basic+0x70>)
    new_task->last_run = lv_tick_get();
   1cad0:	6060      	str	r0, [r4, #4]
    task_created = true;
   1cad2:	2201      	movs	r2, #1
    new_task->user_data = NULL;
   1cad4:	60e5      	str	r5, [r4, #12]
    task_created = true;
   1cad6:	701a      	strb	r2, [r3, #0]
    return new_task;
   1cad8:	e7e0      	b.n	1ca9c <lv_task_create_basic+0x2c>
   1cada:	bf00      	nop
   1cadc:	20001ef4 	.word	0x20001ef4
   1cae0:	2000abd8 	.word	0x2000abd8

0001cae4 <lv_task_del>:
{
   1cae4:	b510      	push	{r4, lr}
    lv_ll_rem(&LV_GC_ROOT(_lv_task_ll), task);
   1cae6:	4601      	mov	r1, r0
{
   1cae8:	4604      	mov	r4, r0
    lv_ll_rem(&LV_GC_ROOT(_lv_task_ll), task);
   1caea:	4807      	ldr	r0, [pc, #28]	; (1cb08 <lv_task_del+0x24>)
   1caec:	f00a fc1b 	bl	27326 <lv_ll_rem>
    lv_mem_free(task);
   1caf0:	4620      	mov	r0, r4
   1caf2:	f000 f915 	bl	1cd20 <lv_mem_free>
    if(LV_GC_ROOT(_lv_task_act) == task) task_deleted = true; /*The active task was deleted*/
   1caf6:	4b05      	ldr	r3, [pc, #20]	; (1cb0c <lv_task_del+0x28>)
   1caf8:	681b      	ldr	r3, [r3, #0]
   1cafa:	42a3      	cmp	r3, r4
   1cafc:	bf02      	ittt	eq
   1cafe:	4b04      	ldreq	r3, [pc, #16]	; (1cb10 <lv_task_del+0x2c>)
   1cb00:	2201      	moveq	r2, #1
   1cb02:	701a      	strbeq	r2, [r3, #0]
}
   1cb04:	bd10      	pop	{r4, pc}
   1cb06:	bf00      	nop
   1cb08:	20001ef4 	.word	0x20001ef4
   1cb0c:	20001ef0 	.word	0x20001ef0
   1cb10:	2000abd9 	.word	0x2000abd9

0001cb14 <lv_task_exec>:
 * Execute task if its the priority is appropriate
 * @param task pointer to lv_task
 * @return true: execute, false: not executed
 */
static bool lv_task_exec(lv_task_t * task)
{
   1cb14:	b538      	push	{r3, r4, r5, lr}
   1cb16:	4604      	mov	r4, r0
    bool exec = false;

    /*Execute if at least 'period' time elapsed*/
    uint32_t elp = lv_tick_elaps(task->last_run);
   1cb18:	6840      	ldr	r0, [r0, #4]
   1cb1a:	f00a fa91 	bl	27040 <lv_tick_elaps>
    if(elp >= task->period) {
   1cb1e:	6823      	ldr	r3, [r4, #0]
   1cb20:	4283      	cmp	r3, r0
   1cb22:	d817      	bhi.n	1cb54 <lv_task_exec+0x40>
        task->last_run = lv_tick_get();
   1cb24:	f00a fa88 	bl	27038 <lv_tick_get>
        task_deleted   = false;
   1cb28:	4d0b      	ldr	r5, [pc, #44]	; (1cb58 <lv_task_exec+0x44>)
        task_created   = false;
   1cb2a:	4a0c      	ldr	r2, [pc, #48]	; (1cb5c <lv_task_exec+0x48>)
        task->last_run = lv_tick_get();
   1cb2c:	6060      	str	r0, [r4, #4]
        task_deleted   = false;
   1cb2e:	2300      	movs	r3, #0
   1cb30:	702b      	strb	r3, [r5, #0]
        task_created   = false;
   1cb32:	7013      	strb	r3, [r2, #0]
        if(task->task_cb) task->task_cb(task);
   1cb34:	68a3      	ldr	r3, [r4, #8]
   1cb36:	b933      	cbnz	r3, 1cb46 <lv_task_exec+0x32>

        /*Delete if it was a one shot lv_task*/
        if(task_deleted == false) { /*The task might be deleted by itself as well*/
            if(task->once != 0) {
   1cb38:	7c23      	ldrb	r3, [r4, #16]
   1cb3a:	071b      	lsls	r3, r3, #28
   1cb3c:	d508      	bpl.n	1cb50 <lv_task_exec+0x3c>
                lv_task_del(task);
   1cb3e:	4620      	mov	r0, r4
   1cb40:	f7ff ffd0 	bl	1cae4 <lv_task_del>
   1cb44:	e004      	b.n	1cb50 <lv_task_exec+0x3c>
        if(task->task_cb) task->task_cb(task);
   1cb46:	4620      	mov	r0, r4
   1cb48:	4798      	blx	r3
        if(task_deleted == false) { /*The task might be deleted by itself as well*/
   1cb4a:	782b      	ldrb	r3, [r5, #0]
   1cb4c:	2b00      	cmp	r3, #0
   1cb4e:	d0f3      	beq.n	1cb38 <lv_task_exec+0x24>
                lv_task_del(task);
   1cb50:	2001      	movs	r0, #1
        }
        exec = true;
    }

    return exec;
}
   1cb52:	bd38      	pop	{r3, r4, r5, pc}
    bool exec = false;
   1cb54:	2000      	movs	r0, #0
   1cb56:	e7fc      	b.n	1cb52 <lv_task_exec+0x3e>
   1cb58:	2000abd9 	.word	0x2000abd9
   1cb5c:	2000abd8 	.word	0x2000abd8

0001cb60 <lv_task_handler>:
{
   1cb60:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(already_running) return;
   1cb64:	4d3e      	ldr	r5, [pc, #248]	; (1cc60 <lv_task_handler+0x100>)
   1cb66:	782c      	ldrb	r4, [r5, #0]
   1cb68:	b934      	cbnz	r4, 1cb78 <lv_task_handler+0x18>
    already_running = true;
   1cb6a:	2301      	movs	r3, #1
   1cb6c:	702b      	strb	r3, [r5, #0]
    if(lv_task_run == false) {
   1cb6e:	4b3d      	ldr	r3, [pc, #244]	; (1cc64 <lv_task_handler+0x104>)
   1cb70:	781b      	ldrb	r3, [r3, #0]
   1cb72:	b923      	cbnz	r3, 1cb7e <lv_task_handler+0x1e>
        already_running = false; /*Release mutex*/
   1cb74:	2300      	movs	r3, #0
   1cb76:	702b      	strb	r3, [r5, #0]
}
   1cb78:	b003      	add	sp, #12
   1cb7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    handler_start = lv_tick_get();
   1cb7e:	f00a fa5b 	bl	27038 <lv_tick_get>
   1cb82:	4b39      	ldr	r3, [pc, #228]	; (1cc68 <lv_task_handler+0x108>)
        task_deleted             = false;
   1cb84:	4e39      	ldr	r6, [pc, #228]	; (1cc6c <lv_task_handler+0x10c>)
    handler_start = lv_tick_get();
   1cb86:	6018      	str	r0, [r3, #0]
    lv_task_t * task_interrupter = NULL;
   1cb88:	9301      	str	r3, [sp, #4]
        task_deleted             = false;
   1cb8a:	46a3      	mov	fp, r4
        task_created             = false;
   1cb8c:	4f38      	ldr	r7, [pc, #224]	; (1cc70 <lv_task_handler+0x110>)
        LV_GC_ROOT(_lv_task_act) = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
   1cb8e:	4839      	ldr	r0, [pc, #228]	; (1cc74 <lv_task_handler+0x114>)
        task_deleted             = false;
   1cb90:	f886 b000 	strb.w	fp, [r6]
        task_created             = false;
   1cb94:	f887 b000 	strb.w	fp, [r7]
        LV_GC_ROOT(_lv_task_act) = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
   1cb98:	f00a fb88 	bl	272ac <lv_ll_get_head>
   1cb9c:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 1cc84 <lv_task_handler+0x124>
   1cba0:	f8c8 0000 	str.w	r0, [r8]
        while(LV_GC_ROOT(_lv_task_act)) {
   1cba4:	46c1      	mov	r9, r8
   1cba6:	f8d9 1000 	ldr.w	r1, [r9]
   1cbaa:	b1b9      	cbz	r1, 1cbdc <lv_task_handler+0x7c>
            next = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), LV_GC_ROOT(_lv_task_act));
   1cbac:	4831      	ldr	r0, [pc, #196]	; (1cc74 <lv_task_handler+0x114>)
   1cbae:	f00a fb83 	bl	272b8 <lv_ll_get_next>
   1cbb2:	4682      	mov	sl, r0
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_OFF) {
   1cbb4:	f8d9 0000 	ldr.w	r0, [r9]
   1cbb8:	7c03      	ldrb	r3, [r0, #16]
   1cbba:	f013 0207 	ands.w	r2, r3, #7
   1cbbe:	d00d      	beq.n	1cbdc <lv_task_handler+0x7c>
            if(LV_GC_ROOT(_lv_task_act) == task_interrupter) {
   1cbc0:	42a0      	cmp	r0, r4
   1cbc2:	d103      	bne.n	1cbcc <lv_task_handler+0x6c>
                LV_GC_ROOT(_lv_task_act) = next;
   1cbc4:	f8c9 a000 	str.w	sl, [r9]
                task_interrupter = NULL; /*From this point only task after the interrupter comes, so
   1cbc8:	2400      	movs	r4, #0
                continue; /*Load the next task*/
   1cbca:	e7ec      	b.n	1cba6 <lv_task_handler+0x46>
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_HIGHEST) {
   1cbcc:	2a05      	cmp	r2, #5
   1cbce:	d12b      	bne.n	1cc28 <lv_task_handler+0xc8>
                lv_task_exec(LV_GC_ROOT(_lv_task_act));
   1cbd0:	f7ff ffa0 	bl	1cb14 <lv_task_exec>
            if(task_created || task_deleted) {
   1cbd4:	4b26      	ldr	r3, [pc, #152]	; (1cc70 <lv_task_handler+0x110>)
   1cbd6:	781b      	ldrb	r3, [r3, #0]
   1cbd8:	2b00      	cmp	r3, #0
   1cbda:	d03a      	beq.n	1cc52 <lv_task_handler+0xf2>
    busy_time += lv_tick_elaps(handler_start);
   1cbdc:	9b01      	ldr	r3, [sp, #4]
   1cbde:	4c26      	ldr	r4, [pc, #152]	; (1cc78 <lv_task_handler+0x118>)
   1cbe0:	6818      	ldr	r0, [r3, #0]
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
   1cbe2:	4e26      	ldr	r6, [pc, #152]	; (1cc7c <lv_task_handler+0x11c>)
    busy_time += lv_tick_elaps(handler_start);
   1cbe4:	f00a fa2c 	bl	27040 <lv_tick_elaps>
   1cbe8:	6823      	ldr	r3, [r4, #0]
   1cbea:	4418      	add	r0, r3
   1cbec:	6020      	str	r0, [r4, #0]
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
   1cbee:	6830      	ldr	r0, [r6, #0]
   1cbf0:	f00a fa26 	bl	27040 <lv_tick_elaps>
    if(idle_period_time >= IDLE_MEAS_PERIOD) {
   1cbf4:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
   1cbf8:	d3bc      	bcc.n	1cb74 <lv_task_handler+0x14>
        idle_last         = (uint32_t)((uint32_t)busy_time * 100) / IDLE_MEAS_PERIOD; /*Calculate the busy percentage*/
   1cbfa:	6822      	ldr	r2, [r4, #0]
   1cbfc:	2364      	movs	r3, #100	; 0x64
   1cbfe:	4353      	muls	r3, r2
   1cc00:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
   1cc04:	fbb3 f3f2 	udiv	r3, r3, r2
        idle_last         = idle_last > 100 ? 0 : 100 - idle_last;                    /*But we need idle time*/
   1cc08:	b2da      	uxtb	r2, r3
   1cc0a:	2a64      	cmp	r2, #100	; 0x64
   1cc0c:	bf98      	it	ls
   1cc0e:	f1c3 0364 	rsbls	r3, r3, #100	; 0x64
   1cc12:	4a1b      	ldr	r2, [pc, #108]	; (1cc80 <lv_task_handler+0x120>)
   1cc14:	bf94      	ite	ls
   1cc16:	b2db      	uxtbls	r3, r3
   1cc18:	2300      	movhi	r3, #0
   1cc1a:	7013      	strb	r3, [r2, #0]
        busy_time         = 0;
   1cc1c:	2300      	movs	r3, #0
   1cc1e:	6023      	str	r3, [r4, #0]
        idle_period_start = lv_tick_get();
   1cc20:	f00a fa0a 	bl	27038 <lv_tick_get>
   1cc24:	6030      	str	r0, [r6, #0]
   1cc26:	e7a5      	b.n	1cb74 <lv_task_handler+0x14>
            else if(task_interrupter) {
   1cc28:	b134      	cbz	r4, 1cc38 <lv_task_handler+0xd8>
                if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio > task_interrupter->prio) {
   1cc2a:	7c22      	ldrb	r2, [r4, #16]
   1cc2c:	f003 0307 	and.w	r3, r3, #7
   1cc30:	f002 0207 	and.w	r2, r2, #7
   1cc34:	4293      	cmp	r3, r2
   1cc36:	d9cd      	bls.n	1cbd4 <lv_task_handler+0x74>
                if(lv_task_exec(LV_GC_ROOT(_lv_task_act))) {
   1cc38:	f7ff ff6c 	bl	1cb14 <lv_task_exec>
   1cc3c:	2800      	cmp	r0, #0
   1cc3e:	d0c9      	beq.n	1cbd4 <lv_task_handler+0x74>
                    if(!task_created && !task_deleted) {
   1cc40:	783b      	ldrb	r3, [r7, #0]
   1cc42:	2b00      	cmp	r3, #0
   1cc44:	d1ca      	bne.n	1cbdc <lv_task_handler+0x7c>
   1cc46:	7833      	ldrb	r3, [r6, #0]
   1cc48:	2b00      	cmp	r3, #0
   1cc4a:	d1c7      	bne.n	1cbdc <lv_task_handler+0x7c>
                        task_interrupter = LV_GC_ROOT(_lv_task_act); /*Check all tasks again from the highest priority */
   1cc4c:	f8d8 4000 	ldr.w	r4, [r8]
                        break;
   1cc50:	e79c      	b.n	1cb8c <lv_task_handler+0x2c>
            if(task_created || task_deleted) {
   1cc52:	7833      	ldrb	r3, [r6, #0]
   1cc54:	2b00      	cmp	r3, #0
   1cc56:	d1c1      	bne.n	1cbdc <lv_task_handler+0x7c>
            LV_GC_ROOT(_lv_task_act) = next; /*Load the next task*/
   1cc58:	f8c9 a000 	str.w	sl, [r9]
   1cc5c:	e7a3      	b.n	1cba6 <lv_task_handler+0x46>
   1cc5e:	bf00      	nop
   1cc60:	2000abd5 	.word	0x2000abd5
   1cc64:	2000abd7 	.word	0x2000abd7
   1cc68:	20001eb4 	.word	0x20001eb4
   1cc6c:	2000abd9 	.word	0x2000abd9
   1cc70:	2000abd8 	.word	0x2000abd8
   1cc74:	20001ef4 	.word	0x20001ef4
   1cc78:	20001eb0 	.word	0x20001eb0
   1cc7c:	20001eb8 	.word	0x20001eb8
   1cc80:	2000abd6 	.word	0x2000abd6
   1cc84:	20001ef0 	.word	0x20001ef0

0001cc88 <lv_task_set_prio>:
    if(task->prio == prio) return;
   1cc88:	7c03      	ldrb	r3, [r0, #16]
   1cc8a:	f003 0307 	and.w	r3, r3, #7
   1cc8e:	428b      	cmp	r3, r1
{
   1cc90:	b570      	push	{r4, r5, r6, lr}
   1cc92:	4604      	mov	r4, r0
   1cc94:	460d      	mov	r5, r1
    if(task->prio == prio) return;
   1cc96:	d014      	beq.n	1ccc2 <lv_task_set_prio+0x3a>
    LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i)
   1cc98:	480d      	ldr	r0, [pc, #52]	; (1ccd0 <lv_task_set_prio+0x48>)
   1cc9a:	4e0d      	ldr	r6, [pc, #52]	; (1ccd0 <lv_task_set_prio+0x48>)
   1cc9c:	f00a fb06 	bl	272ac <lv_ll_get_head>
   1cca0:	4602      	mov	r2, r0
   1cca2:	b132      	cbz	r2, 1ccb2 <lv_task_set_prio+0x2a>
        if(i->prio <= prio) {
   1cca4:	7c13      	ldrb	r3, [r2, #16]
   1cca6:	f003 0307 	and.w	r3, r3, #7
   1ccaa:	429d      	cmp	r5, r3
   1ccac:	db0a      	blt.n	1ccc4 <lv_task_set_prio+0x3c>
            if(i != task) lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, i);
   1ccae:	42a2      	cmp	r2, r4
   1ccb0:	d003      	beq.n	1ccba <lv_task_set_prio+0x32>
        lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, NULL);
   1ccb2:	4621      	mov	r1, r4
   1ccb4:	4806      	ldr	r0, [pc, #24]	; (1ccd0 <lv_task_set_prio+0x48>)
   1ccb6:	f00a fb6f 	bl	27398 <lv_ll_move_before>
    task->prio = prio;
   1ccba:	7c23      	ldrb	r3, [r4, #16]
   1ccbc:	f365 0302 	bfi	r3, r5, #0, #3
   1ccc0:	7423      	strb	r3, [r4, #16]
}
   1ccc2:	bd70      	pop	{r4, r5, r6, pc}
    LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i)
   1ccc4:	4611      	mov	r1, r2
   1ccc6:	4630      	mov	r0, r6
   1ccc8:	f00a faf6 	bl	272b8 <lv_ll_get_next>
   1cccc:	4602      	mov	r2, r0
   1ccce:	e7e8      	b.n	1cca2 <lv_task_set_prio+0x1a>
   1ccd0:	20001ef4 	.word	0x20001ef4

0001ccd4 <lv_mem_alloc>:
 * Allocate a memory dynamically
 * @param size size of the memory to allocate in bytes
 * @return pointer to the allocated memory
 */
void * lv_mem_alloc(size_t size)
{
   1ccd4:	b538      	push	{r3, r4, r5, lr}
    if(size == 0) {
   1ccd6:	4604      	mov	r4, r0
   1ccd8:	b198      	cbz	r0, 1cd02 <lv_mem_alloc+0x2e>
        size = size & (~0x7);
        size += 8;
    }
#else
    /*Round the size up to 4*/
    if(size & 0x3) {
   1ccda:	0783      	lsls	r3, r0, #30
        size = size & (~0x3);
   1ccdc:	bf1c      	itt	ne
   1ccde:	f020 0403 	bicne.w	r4, r0, #3
        size += 4;
   1cce2:	3404      	addne	r4, #4
/*Use custom, user defined malloc function*/
#if LV_ENABLE_GC == 1 /*gc must not include header*/
    alloc = LV_MEM_CUSTOM_ALLOC(size);
#else                 /* LV_ENABLE_GC */
    /*Allocate a header too to store the size*/
    alloc = LV_MEM_CUSTOM_ALLOC(size + sizeof(lv_mem_header_t));
   1cce4:	1d20      	adds	r0, r4, #4
   1cce6:	f001 fc25 	bl	1e534 <k_malloc>
    if(alloc != NULL) {
   1ccea:	4605      	mov	r5, r0
   1ccec:	b158      	cbz	r0, 1cd06 <lv_mem_alloc+0x32>
        ((lv_mem_ent_t *)alloc)->header.s.d_size = size;
   1ccee:	6803      	ldr	r3, [r0, #0]
   1ccf0:	f364 035f 	bfi	r3, r4, #1, #31
   1ccf4:	6003      	str	r3, [r0, #0]
        ((lv_mem_ent_t *)alloc)->header.s.used   = 1;
   1ccf6:	f043 0301 	orr.w	r3, r3, #1
   1ccfa:	f805 3b04 	strb.w	r3, [r5], #4
#endif

    if(alloc == NULL) LV_LOG_WARN("Couldn't allocate memory");

    return alloc;
}
   1ccfe:	4628      	mov	r0, r5
   1cd00:	bd38      	pop	{r3, r4, r5, pc}
        return &zero_mem;
   1cd02:	4d04      	ldr	r5, [pc, #16]	; (1cd14 <lv_mem_alloc+0x40>)
   1cd04:	e7fb      	b.n	1ccfe <lv_mem_alloc+0x2a>
    if(alloc == NULL) LV_LOG_WARN("Couldn't allocate memory");
   1cd06:	4b04      	ldr	r3, [pc, #16]	; (1cd18 <lv_mem_alloc+0x44>)
   1cd08:	4904      	ldr	r1, [pc, #16]	; (1cd1c <lv_mem_alloc+0x48>)
   1cd0a:	22a7      	movs	r2, #167	; 0xa7
   1cd0c:	2002      	movs	r0, #2
   1cd0e:	f000 f9a3 	bl	1d058 <lv_log_add>
   1cd12:	e7f4      	b.n	1ccfe <lv_mem_alloc+0x2a>
   1cd14:	20001ebc 	.word	0x20001ebc
   1cd18:	00065ae6 	.word	0x00065ae6
   1cd1c:	00065aff 	.word	0x00065aff

0001cd20 <lv_mem_free>:
 * Free an allocated data
 * @param data pointer to an allocated memory
 */
void lv_mem_free(const void * data)
{
    if(data == &zero_mem) return;
   1cd20:	4b06      	ldr	r3, [pc, #24]	; (1cd3c <lv_mem_free+0x1c>)
   1cd22:	4298      	cmp	r0, r3
   1cd24:	d008      	beq.n	1cd38 <lv_mem_free+0x18>
    if(data == NULL) return;
   1cd26:	b138      	cbz	r0, 1cd38 <lv_mem_free+0x18>
#endif

#if LV_ENABLE_GC == 0
    /*e points to the header*/
    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));
    e->header.s.used = 0;
   1cd28:	f810 3c04 	ldrb.w	r3, [r0, #-4]
   1cd2c:	f36f 0300 	bfc	r3, #0, #1
   1cd30:	f800 3d04 	strb.w	r3, [r0, #-4]!
        e_next = ent_get_next(e_next);
    }
#endif
#else /*Use custom, user defined free function*/
#if LV_ENABLE_GC == 0
    LV_MEM_CUSTOM_FREE(e);
   1cd34:	f00a be75 	b.w	27a22 <k_free>
#else
    LV_MEM_CUSTOM_FREE((void *)data);
#endif /*LV_ENABLE_GC*/
#endif
}
   1cd38:	4770      	bx	lr
   1cd3a:	bf00      	nop
   1cd3c:	20001ebc 	.word	0x20001ebc

0001cd40 <lv_mem_get_size>:

#if LV_ENABLE_GC == 0

uint32_t lv_mem_get_size(const void * data)
{
    if(data == NULL) return 0;
   1cd40:	b140      	cbz	r0, 1cd54 <lv_mem_get_size+0x14>
    if(data == &zero_mem) return 0;
   1cd42:	4b05      	ldr	r3, [pc, #20]	; (1cd58 <lv_mem_get_size+0x18>)
   1cd44:	4298      	cmp	r0, r3
   1cd46:	d004      	beq.n	1cd52 <lv_mem_get_size+0x12>

    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));

    return e->header.s.d_size;
   1cd48:	f850 0c04 	ldr.w	r0, [r0, #-4]
   1cd4c:	f3c0 005e 	ubfx	r0, r0, #1, #31
   1cd50:	4770      	bx	lr
    if(data == NULL) return 0;
   1cd52:	2000      	movs	r0, #0
}
   1cd54:	4770      	bx	lr
   1cd56:	bf00      	nop
   1cd58:	20001ebc 	.word	0x20001ebc

0001cd5c <lv_mem_realloc>:
{
   1cd5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1cd5e:	460d      	mov	r5, r1
    if(data_p != NULL) {
   1cd60:	4604      	mov	r4, r0
   1cd62:	b130      	cbz	r0, 1cd72 <lv_mem_realloc+0x16>
        if(e->header.s.used == 0) {
   1cd64:	f810 3c04 	ldrb.w	r3, [r0, #-4]
            data_p = NULL;
   1cd68:	f013 0f01 	tst.w	r3, #1
   1cd6c:	bf14      	ite	ne
   1cd6e:	4604      	movne	r4, r0
   1cd70:	2400      	moveq	r4, #0
    uint32_t old_size = lv_mem_get_size(data_p);
   1cd72:	4620      	mov	r0, r4
   1cd74:	f7ff ffe4 	bl	1cd40 <lv_mem_get_size>
    if(old_size == new_size) return data_p; /*Also avoid reallocating the same memory*/
   1cd78:	42a8      	cmp	r0, r5
    uint32_t old_size = lv_mem_get_size(data_p);
   1cd7a:	4606      	mov	r6, r0
    if(old_size == new_size) return data_p; /*Also avoid reallocating the same memory*/
   1cd7c:	d012      	beq.n	1cda4 <lv_mem_realloc+0x48>
    new_p = lv_mem_alloc(new_size);
   1cd7e:	4628      	mov	r0, r5
   1cd80:	f7ff ffa8 	bl	1ccd4 <lv_mem_alloc>
    if(new_p != NULL && data_p != NULL) {
   1cd84:	4607      	mov	r7, r0
   1cd86:	b178      	cbz	r0, 1cda8 <lv_mem_realloc+0x4c>
   1cd88:	b154      	cbz	r4, 1cda0 <lv_mem_realloc+0x44>
        if(old_size != 0) {
   1cd8a:	b14e      	cbz	r6, 1cda0 <lv_mem_realloc+0x44>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1cd8c:	42ae      	cmp	r6, r5
   1cd8e:	4632      	mov	r2, r6
   1cd90:	4621      	mov	r1, r4
   1cd92:	bf28      	it	cs
   1cd94:	462a      	movcs	r2, r5
   1cd96:	f7e4 ff29 	bl	1bec <memcpy>
            lv_mem_free(data_p);
   1cd9a:	4620      	mov	r0, r4
   1cd9c:	f7ff ffc0 	bl	1cd20 <lv_mem_free>
}
   1cda0:	4638      	mov	r0, r7
   1cda2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1cda4:	4627      	mov	r7, r4
   1cda6:	e7fb      	b.n	1cda0 <lv_mem_realloc+0x44>
    if(new_p == NULL) LV_LOG_WARN("Couldn't allocate memory");
   1cda8:	4b03      	ldr	r3, [pc, #12]	; (1cdb8 <lv_mem_realloc+0x5c>)
   1cdaa:	4904      	ldr	r1, [pc, #16]	; (1cdbc <lv_mem_realloc+0x60>)
   1cdac:	f44f 7281 	mov.w	r2, #258	; 0x102
   1cdb0:	2002      	movs	r0, #2
   1cdb2:	f000 f951 	bl	1d058 <lv_log_add>
   1cdb6:	e7f3      	b.n	1cda0 <lv_mem_realloc+0x44>
   1cdb8:	00065ae6 	.word	0x00065ae6
   1cdbc:	00065aff 	.word	0x00065aff

0001cdc0 <lv_txt_get_width>:
 * @param flags settings for the text from 'txt_flag_t' enum
 * @return length of a char_num long text
 */
lv_coord_t lv_txt_get_width(const char * txt, uint16_t length, const lv_font_t * font, lv_coord_t letter_space,
                            lv_txt_flag_t flag)
{
   1cdc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1cdc4:	4688      	mov	r8, r1
   1cdc6:	b085      	sub	sp, #20
   1cdc8:	4617      	mov	r7, r2
   1cdca:	461e      	mov	r6, r3
    if(txt == NULL) return 0;
   1cdcc:	4605      	mov	r5, r0
   1cdce:	2400      	movs	r4, #0
   1cdd0:	2800      	cmp	r0, #0
   1cdd2:	d03f      	beq.n	1ce54 <lv_txt_get_width+0x94>
    if(font == NULL) return 0;
   1cdd4:	2a00      	cmp	r2, #0
   1cdd6:	d03f      	beq.n	1ce58 <lv_txt_get_width+0x98>

    uint32_t i                   = 0;
   1cdd8:	9403      	str	r4, [sp, #12]
    lv_coord_t width             = 0;
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
   1cdda:	f88d 400b 	strb.w	r4, [sp, #11]
    uint32_t letter;
    uint32_t letter_next;

    if(length != 0) {
   1cdde:	2900      	cmp	r1, #0
   1cde0:	d036      	beq.n	1ce50 <lv_txt_get_width+0x90>
        while(i < length) {
            letter      = lv_txt_encoded_next(txt, &i);
            letter_next = lv_txt_encoded_next(&txt[i], NULL);
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   1cde2:	f89d 9038 	ldrb.w	r9, [sp, #56]	; 0x38
            letter      = lv_txt_encoded_next(txt, &i);
   1cde6:	f8df a074 	ldr.w	sl, [pc, #116]	; 1ce5c <lv_txt_get_width+0x9c>
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   1cdea:	f009 0901 	and.w	r9, r9, #1
            letter      = lv_txt_encoded_next(txt, &i);
   1cdee:	f8da 3000 	ldr.w	r3, [sl]
   1cdf2:	a903      	add	r1, sp, #12
   1cdf4:	4628      	mov	r0, r5
   1cdf6:	4798      	blx	r3
   1cdf8:	4683      	mov	fp, r0
            letter_next = lv_txt_encoded_next(&txt[i], NULL);
   1cdfa:	9803      	ldr	r0, [sp, #12]
   1cdfc:	f8da 3000 	ldr.w	r3, [sl]
   1ce00:	2100      	movs	r1, #0
   1ce02:	4428      	add	r0, r5
   1ce04:	4798      	blx	r3
   1ce06:	4602      	mov	r2, r0
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   1ce08:	f1b9 0f00 	cmp.w	r9, #0
   1ce0c:	d111      	bne.n	1ce32 <lv_txt_get_width+0x72>
                if(lv_txt_is_cmd(&cmd_state, letter) != false) {
                    continue;
                }
            }

            lv_coord_t char_width = lv_font_get_glyph_width(font, letter, letter_next);
   1ce0e:	4659      	mov	r1, fp
   1ce10:	4638      	mov	r0, r7
   1ce12:	f00a fda0 	bl	27956 <lv_font_get_glyph_width>
   1ce16:	b200      	sxth	r0, r0
            if(char_width > 0) {
   1ce18:	2800      	cmp	r0, #0
   1ce1a:	dc14      	bgt.n	1ce46 <lv_txt_get_width+0x86>
        while(i < length) {
   1ce1c:	9b03      	ldr	r3, [sp, #12]
   1ce1e:	4598      	cmp	r8, r3
   1ce20:	d8e5      	bhi.n	1cdee <lv_txt_get_width+0x2e>
                width += char_width;
                width += letter_space;
            }
        }

        if(width > 0) {
   1ce22:	2c00      	cmp	r4, #0
   1ce24:	dd01      	ble.n	1ce2a <lv_txt_get_width+0x6a>
            width -= letter_space; /*Trim the last letter space. Important if the text is center
   1ce26:	1ba4      	subs	r4, r4, r6
   1ce28:	b224      	sxth	r4, r4
                                      aligned */
        }
    }

    return width;
}
   1ce2a:	4620      	mov	r0, r4
   1ce2c:	b005      	add	sp, #20
   1ce2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ce32:	9001      	str	r0, [sp, #4]
                if(lv_txt_is_cmd(&cmd_state, letter) != false) {
   1ce34:	4659      	mov	r1, fp
   1ce36:	f10d 000b 	add.w	r0, sp, #11
   1ce3a:	f00a faf2 	bl	27422 <lv_txt_is_cmd>
   1ce3e:	9a01      	ldr	r2, [sp, #4]
   1ce40:	2800      	cmp	r0, #0
   1ce42:	d0e4      	beq.n	1ce0e <lv_txt_get_width+0x4e>
   1ce44:	e7ea      	b.n	1ce1c <lv_txt_get_width+0x5c>
                width += letter_space;
   1ce46:	19a3      	adds	r3, r4, r6
   1ce48:	fa00 f483 	sxtah	r4, r0, r3
   1ce4c:	b224      	sxth	r4, r4
   1ce4e:	e7e5      	b.n	1ce1c <lv_txt_get_width+0x5c>
    lv_coord_t width             = 0;
   1ce50:	460c      	mov	r4, r1
   1ce52:	e7ea      	b.n	1ce2a <lv_txt_get_width+0x6a>
    if(txt == NULL) return 0;
   1ce54:	4604      	mov	r4, r0
   1ce56:	e7e8      	b.n	1ce2a <lv_txt_get_width+0x6a>
   1ce58:	4614      	mov	r4, r2
   1ce5a:	e7e6      	b.n	1ce2a <lv_txt_get_width+0x6a>
   1ce5c:	2000ebcc 	.word	0x2000ebcc

0001ce60 <lv_txt_get_next_line>:
{
   1ce60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ce64:	b091      	sub	sp, #68	; 0x44
   1ce66:	4699      	mov	r9, r3
   1ce68:	f89d 3068 	ldrb.w	r3, [sp, #104]	; 0x68
   1ce6c:	9102      	str	r1, [sp, #8]
   1ce6e:	9207      	str	r2, [sp, #28]
   1ce70:	9303      	str	r3, [sp, #12]
    if(txt == NULL) return 0;
   1ce72:	4607      	mov	r7, r0
   1ce74:	2800      	cmp	r0, #0
   1ce76:	d05a      	beq.n	1cf2e <lv_txt_get_next_line+0xce>
    if(font == NULL) return 0;
   1ce78:	2900      	cmp	r1, #0
   1ce7a:	f000 80de 	beq.w	1d03a <lv_txt_get_next_line+0x1da>
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
   1ce7e:	9b03      	ldr	r3, [sp, #12]
   1ce80:	f013 0302 	ands.w	r3, r3, #2
   1ce84:	9304      	str	r3, [sp, #16]
   1ce86:	f647 4318 	movw	r3, #31768	; 0x7c18
   1ce8a:	bf18      	it	ne
   1ce8c:	4699      	movne	r9, r3
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
   1ce8e:	2300      	movs	r3, #0
   1ce90:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    uint32_t i = 0;                                        /* Iterating index into txt */
   1ce94:	930c      	str	r3, [sp, #48]	; 0x30
    while(txt[i] != '\0' && max_width > 0) {
   1ce96:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1ce98:	9300      	str	r3, [sp, #0]
   1ce9a:	eb07 0b03 	add.w	fp, r7, r3
   1ce9e:	5cfb      	ldrb	r3, [r7, r3]
   1cea0:	2b00      	cmp	r3, #0
   1cea2:	d03b      	beq.n	1cf1c <lv_txt_get_next_line+0xbc>
   1cea4:	f1b9 0f00 	cmp.w	r9, #0
   1cea8:	dd38      	ble.n	1cf1c <lv_txt_get_next_line+0xbc>
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
   1ceaa:	9a04      	ldr	r2, [sp, #16]
   1ceac:	f647 4318 	movw	r3, #31768	; 0x7c18
   1ceb0:	2a00      	cmp	r2, #0
   1ceb2:	bf08      	it	eq
   1ceb4:	464b      	moveq	r3, r9
   1ceb6:	9306      	str	r3, [sp, #24]
    letter = lv_txt_encoded_next(txt, &i_next);
   1ceb8:	4b61      	ldr	r3, [pc, #388]	; (1d040 <lv_txt_get_next_line+0x1e0>)
    uint32_t i = 0, i_next = 0, i_next_next = 0;  /* Iterating index into txt */
   1ceba:	2500      	movs	r5, #0
    letter = lv_txt_encoded_next(txt, &i_next);
   1cebc:	681b      	ldr	r3, [r3, #0]
    uint32_t i = 0, i_next = 0, i_next_next = 0;  /* Iterating index into txt */
   1cebe:	950f      	str	r5, [sp, #60]	; 0x3c
   1cec0:	e9cd 550d 	strd	r5, r5, [sp, #52]	; 0x34
    letter = lv_txt_encoded_next(txt, &i_next);
   1cec4:	a90e      	add	r1, sp, #56	; 0x38
   1cec6:	4658      	mov	r0, fp
   1cec8:	4798      	blx	r3
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   1ceca:	9a03      	ldr	r2, [sp, #12]
    i_next_next = i_next;
   1cecc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1cece:	930f      	str	r3, [sp, #60]	; 0x3c
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   1ced0:	f002 0201 	and.w	r2, r2, #1
    letter = lv_txt_encoded_next(txt, &i_next);
   1ced4:	4680      	mov	r8, r0
    uint32_t break_letter_count = 0; /* Number of characters up to the long word break point */
   1ced6:	9501      	str	r5, [sp, #4]
    uint32_t break_index = NO_BREAK_FOUND; /* only used for "long" words */
   1ced8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    uint32_t word_len = 0;   /* Number of characters in the transversed word */
   1cedc:	46aa      	mov	sl, r5
    lv_coord_t cur_w = 0;  /* Pixel Width of transversed string */
   1cede:	462e      	mov	r6, r5
    uint32_t letter_next = 0; /* Letter at i_next */
   1cee0:	462b      	mov	r3, r5
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   1cee2:	9208      	str	r2, [sp, #32]
    while(txt[i] != '\0') {
   1cee4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1cee6:	f81b 2002 	ldrb.w	r2, [fp, r2]
   1ceea:	bb1a      	cbnz	r2, 1cf34 <lv_txt_get_next_line+0xd4>
    if( break_index == NO_BREAK_FOUND ) {
   1ceec:	1c62      	adds	r2, r4, #1
   1ceee:	d06f      	beq.n	1cfd0 <lv_txt_get_next_line+0x170>
    if(word_len < LV_TXT_LINE_BREAK_LONG_LEN) {
   1cef0:	f1ba 0f0b 	cmp.w	sl, #11
   1cef4:	d879      	bhi.n	1cfea <lv_txt_get_next_line+0x18a>
        if( force ) return break_index;
   1cef6:	9b00      	ldr	r3, [sp, #0]
   1cef8:	2b00      	cmp	r3, #0
   1cefa:	f040 8089 	bne.w	1d010 <lv_txt_get_next_line+0x1b0>
   1cefe:	b2a4      	uxth	r4, r4
        max_width -= word_w;
   1cf00:	eba9 0905 	sub.w	r9, r9, r5
   1cf04:	fa0f f989 	sxth.w	r9, r9
        if( advance == 0 ){
   1cf08:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1cf0a:	2c00      	cmp	r4, #0
   1cf0c:	f040 8083 	bne.w	1d016 <lv_txt_get_next_line+0x1b6>
            if(i == 0) lv_txt_encoded_next(txt, &i); // prevent inf loops
   1cf10:	b95b      	cbnz	r3, 1cf2a <lv_txt_get_next_line+0xca>
   1cf12:	4b4b      	ldr	r3, [pc, #300]	; (1d040 <lv_txt_get_next_line+0x1e0>)
   1cf14:	a90c      	add	r1, sp, #48	; 0x30
   1cf16:	681b      	ldr	r3, [r3, #0]
   1cf18:	4638      	mov	r0, r7
   1cf1a:	4798      	blx	r3
    if(i == 0) {
   1cf1c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1cf1e:	b923      	cbnz	r3, 1cf2a <lv_txt_get_next_line+0xca>
        lv_txt_encoded_next(txt, &i);
   1cf20:	4b47      	ldr	r3, [pc, #284]	; (1d040 <lv_txt_get_next_line+0x1e0>)
   1cf22:	a90c      	add	r1, sp, #48	; 0x30
   1cf24:	681b      	ldr	r3, [r3, #0]
   1cf26:	4638      	mov	r0, r7
   1cf28:	4798      	blx	r3
    return i;
   1cf2a:	f8bd 0030 	ldrh.w	r0, [sp, #48]	; 0x30
}
   1cf2e:	b011      	add	sp, #68	; 0x44
   1cf30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        letter_next = lv_txt_encoded_next(txt, &i_next_next);
   1cf34:	4b42      	ldr	r3, [pc, #264]	; (1d040 <lv_txt_get_next_line+0x1e0>)
   1cf36:	a90f      	add	r1, sp, #60	; 0x3c
   1cf38:	681b      	ldr	r3, [r3, #0]
   1cf3a:	4658      	mov	r0, fp
   1cf3c:	4798      	blx	r3
        word_len++;
   1cf3e:	f10a 0201 	add.w	r2, sl, #1
   1cf42:	9205      	str	r2, [sp, #20]
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   1cf44:	9a08      	ldr	r2, [sp, #32]
        letter_next = lv_txt_encoded_next(txt, &i_next_next);
   1cf46:	4603      	mov	r3, r0
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   1cf48:	b17a      	cbz	r2, 1cf6a <lv_txt_get_next_line+0x10a>
   1cf4a:	9009      	str	r0, [sp, #36]	; 0x24
            if(lv_txt_is_cmd(cmd_state, letter) != false) {
   1cf4c:	4641      	mov	r1, r8
   1cf4e:	f10d 002f 	add.w	r0, sp, #47	; 0x2f
   1cf52:	f00a fa66 	bl	27422 <lv_txt_is_cmd>
   1cf56:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1cf58:	b138      	cbz	r0, 1cf6a <lv_txt_get_next_line+0x10a>
        i = i_next;
   1cf5a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1cf5c:	920d      	str	r2, [sp, #52]	; 0x34
        i_next = i_next_next;
   1cf5e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   1cf60:	920e      	str	r2, [sp, #56]	; 0x38
        letter_next = lv_txt_encoded_next(txt, &i_next_next);
   1cf62:	f8dd a014 	ldr.w	sl, [sp, #20]
   1cf66:	4698      	mov	r8, r3
   1cf68:	e7bc      	b.n	1cee4 <lv_txt_get_next_line+0x84>
        letter_w = lv_font_get_glyph_width(font, letter, letter_next);
   1cf6a:	461a      	mov	r2, r3
   1cf6c:	4641      	mov	r1, r8
   1cf6e:	9802      	ldr	r0, [sp, #8]
   1cf70:	9309      	str	r3, [sp, #36]	; 0x24
   1cf72:	f00a fcf0 	bl	27956 <lv_font_get_glyph_width>
   1cf76:	b200      	sxth	r0, r0
        cur_w += letter_w;
   1cf78:	4406      	add	r6, r0
        if(break_index == NO_BREAK_FOUND && cur_w > max_width) {
   1cf7a:	1c63      	adds	r3, r4, #1
        cur_w += letter_w;
   1cf7c:	b236      	sxth	r6, r6
        if(break_index == NO_BREAK_FOUND && cur_w > max_width) {
   1cf7e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1cf80:	d105      	bne.n	1cf8e <lv_txt_get_next_line+0x12e>
   1cf82:	9a06      	ldr	r2, [sp, #24]
   1cf84:	4296      	cmp	r6, r2
            break_index = i; 
   1cf86:	bfc4      	itt	gt
   1cf88:	9c0d      	ldrgt	r4, [sp, #52]	; 0x34
   1cf8a:	f8cd a004 	strgt.w	sl, [sp, #4]
        if(letter == '\n' || letter == '\r' || is_break_char(letter)) {
   1cf8e:	f1b8 0f0a 	cmp.w	r8, #10
   1cf92:	d017      	beq.n	1cfc4 <lv_txt_get_next_line+0x164>
   1cf94:	f1b8 0f0d 	cmp.w	r8, #13
   1cf98:	d014      	beq.n	1cfc4 <lv_txt_get_next_line+0x164>
{
    uint8_t i;
    bool ret = false;

    /*Compare the letter to TXT_BREAK_CHARS*/
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
   1cf9a:	f8df c0ac 	ldr.w	ip, [pc, #172]	; 1d048 <lv_txt_get_next_line+0x1e8>
        if(letter == '\n' || letter == '\r' || is_break_char(letter)) {
   1cf9e:	2200      	movs	r2, #0
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
   1cfa0:	b2d1      	uxtb	r1, r2
   1cfa2:	f81c 1001 	ldrb.w	r1, [ip, r1]
   1cfa6:	b949      	cbnz	r1, 1cfbc <lv_txt_get_next_line+0x15c>
        if( word_w_ptr != NULL && break_index == NO_BREAK_FOUND ) *word_w_ptr = cur_w;
   1cfa8:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   1cfac:	bf08      	it	eq
   1cfae:	4635      	moveq	r5, r6
        if(letter_w > 0) {
   1cfb0:	2800      	cmp	r0, #0
   1cfb2:	ddd2      	ble.n	1cf5a <lv_txt_get_next_line+0xfa>
            cur_w += letter_space;
   1cfb4:	9a07      	ldr	r2, [sp, #28]
   1cfb6:	4416      	add	r6, r2
   1cfb8:	b236      	sxth	r6, r6
   1cfba:	e7ce      	b.n	1cf5a <lv_txt_get_next_line+0xfa>
        if(letter == (uint32_t)LV_TXT_BREAK_CHARS[i]) {
   1cfbc:	4588      	cmp	r8, r1
   1cfbe:	f102 0201 	add.w	r2, r2, #1
   1cfc2:	d1ed      	bne.n	1cfa0 <lv_txt_get_next_line+0x140>
            if(i == 0 && break_index == NO_BREAK_FOUND && word_w_ptr != NULL) *word_w_ptr = cur_w;
   1cfc4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1cfc6:	2a00      	cmp	r2, #0
   1cfc8:	d190      	bne.n	1ceec <lv_txt_get_next_line+0x8c>
   1cfca:	1c61      	adds	r1, r4, #1
   1cfcc:	d190      	bne.n	1cef0 <lv_txt_get_next_line+0x90>
   1cfce:	4635      	mov	r5, r6
        if( word_len == 0 || (letter == '\r' && letter_next == '\n') ) i = i_next;
   1cfd0:	f1ba 0f00 	cmp.w	sl, #0
   1cfd4:	d004      	beq.n	1cfe0 <lv_txt_get_next_line+0x180>
   1cfd6:	f1b8 0f0d 	cmp.w	r8, #13
   1cfda:	d103      	bne.n	1cfe4 <lv_txt_get_next_line+0x184>
   1cfdc:	2b0a      	cmp	r3, #10
   1cfde:	d101      	bne.n	1cfe4 <lv_txt_get_next_line+0x184>
   1cfe0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1cfe2:	930d      	str	r3, [sp, #52]	; 0x34
    return i;
   1cfe4:	f8bd 4034 	ldrh.w	r4, [sp, #52]	; 0x34
   1cfe8:	e78a      	b.n	1cf00 <lv_txt_get_next_line+0xa0>
    if(break_letter_count < LV_TXT_LINE_BREAK_LONG_PRE_MIN_LEN) {
   1cfea:	9b01      	ldr	r3, [sp, #4]
   1cfec:	2b02      	cmp	r3, #2
   1cfee:	d982      	bls.n	1cef6 <lv_txt_get_next_line+0x96>
        int32_t n_move = LV_TXT_LINE_BREAK_LONG_POST_MIN_LEN - (word_len - break_letter_count);
   1cff0:	9b01      	ldr	r3, [sp, #4]
        i = break_index;
   1cff2:	940d      	str	r4, [sp, #52]	; 0x34
        int32_t n_move = LV_TXT_LINE_BREAK_LONG_POST_MIN_LEN - (word_len - break_letter_count);
   1cff4:	3303      	adds	r3, #3
   1cff6:	eba3 0a0a 	sub.w	sl, r3, sl
        for(;n_move>0; n_move--){
   1cffa:	f1ba 0f00 	cmp.w	sl, #0
   1cffe:	ddf1      	ble.n	1cfe4 <lv_txt_get_next_line+0x184>
            lv_txt_encoded_prev(txt, &i);
   1d000:	4b10      	ldr	r3, [pc, #64]	; (1d044 <lv_txt_get_next_line+0x1e4>)
   1d002:	a90d      	add	r1, sp, #52	; 0x34
   1d004:	681b      	ldr	r3, [r3, #0]
   1d006:	4658      	mov	r0, fp
   1d008:	4798      	blx	r3
        for(;n_move>0; n_move--){
   1d00a:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   1d00e:	e7f4      	b.n	1cffa <lv_txt_get_next_line+0x19a>
        if(word_w_ptr != NULL) *word_w_ptr = 0; /* Return no word */
   1d010:	2500      	movs	r5, #0
        return 0;
   1d012:	462c      	mov	r4, r5
   1d014:	e774      	b.n	1cf00 <lv_txt_get_next_line+0xa0>
        i += advance;
   1d016:	441c      	add	r4, r3
        if(txt[0] == '\n' || txt[0] == '\r') break;
   1d018:	783b      	ldrb	r3, [r7, #0]
        i += advance;
   1d01a:	940c      	str	r4, [sp, #48]	; 0x30
        if(txt[0] == '\n' || txt[0] == '\r') break;
   1d01c:	2b0a      	cmp	r3, #10
   1d01e:	f43f af7d 	beq.w	1cf1c <lv_txt_get_next_line+0xbc>
   1d022:	2b0d      	cmp	r3, #13
   1d024:	f43f af7a 	beq.w	1cf1c <lv_txt_get_next_line+0xbc>
        if(txt[i] == '\n' || txt[i] == '\r'){
   1d028:	5d3b      	ldrb	r3, [r7, r4]
   1d02a:	2b0a      	cmp	r3, #10
   1d02c:	d002      	beq.n	1d034 <lv_txt_get_next_line+0x1d4>
   1d02e:	2b0d      	cmp	r3, #13
   1d030:	f47f af31 	bne.w	1ce96 <lv_txt_get_next_line+0x36>
            i++;  /* Include the following newline in the current line */
   1d034:	3401      	adds	r4, #1
   1d036:	940c      	str	r4, [sp, #48]	; 0x30
            break;
   1d038:	e770      	b.n	1cf1c <lv_txt_get_next_line+0xbc>
    if(txt == NULL) return 0;
   1d03a:	9802      	ldr	r0, [sp, #8]
   1d03c:	e777      	b.n	1cf2e <lv_txt_get_next_line+0xce>
   1d03e:	bf00      	nop
   1d040:	2000ebcc 	.word	0x2000ebcc
   1d044:	2000ebd0 	.word	0x2000ebd0
   1d048:	00065b34 	.word	0x00065b34

0001d04c <lv_log_register_print_cb>:
 * and send the formatted log message to a consol or serial port.
 * @param print_cb a function pointer to print a log
 */
void lv_log_register_print_cb(lv_log_print_g_cb_t print_cb)
{
    custom_print_cb = print_cb;
   1d04c:	4b01      	ldr	r3, [pc, #4]	; (1d054 <lv_log_register_print_cb+0x8>)
   1d04e:	6018      	str	r0, [r3, #0]
}
   1d050:	4770      	bx	lr
   1d052:	bf00      	nop
   1d054:	20001ec0 	.word	0x20001ec0

0001d058 <lv_log_add>:
 * @param file name of the file when the log added
 * @param line line number in the source code where the log added
 * @param dsc description of the log
 */
void lv_log_add(lv_log_level_t level, const char * file, int line, const char * dsc)
{
   1d058:	b410      	push	{r4}
    if(level >= _LV_LOG_LEVEL_NUM) return; /*Invalid level*/

    if(level >= LV_LOG_LEVEL) {
   1d05a:	1e44      	subs	r4, r0, #1
   1d05c:	b2e4      	uxtb	r4, r4
   1d05e:	2c03      	cmp	r4, #3
   1d060:	d805      	bhi.n	1d06e <lv_log_add+0x16>

#if LV_LOG_PRINTF
        static const char * lvl_prefix[] = {"Trace", "Info", "Warn", "Error"};
        printf("%s: %s \t(%s #%d)\n", lvl_prefix[level], dsc, file, line);
#else
        if(custom_print_cb) custom_print_cb(level, file, line, dsc);
   1d062:	4c04      	ldr	r4, [pc, #16]	; (1d074 <lv_log_add+0x1c>)
   1d064:	6824      	ldr	r4, [r4, #0]
   1d066:	b114      	cbz	r4, 1d06e <lv_log_add+0x16>
   1d068:	46a4      	mov	ip, r4
#endif
    }
}
   1d06a:	bc10      	pop	{r4}
        if(custom_print_cb) custom_print_cb(level, file, line, dsc);
   1d06c:	4760      	bx	ip
}
   1d06e:	bc10      	pop	{r4}
   1d070:	4770      	bx	lr
   1d072:	bf00      	nop
   1d074:	20001ec0 	.word	0x20001ec0

0001d078 <lv_label_revert_dots>:

    lv_obj_invalidate(label);
}

static void lv_label_revert_dots(lv_obj_t * label)
{
   1d078:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d07c:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1d07e:	f008 fd35 	bl	25aec <lv_obj_get_ext_attr>
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
   1d082:	7b83      	ldrb	r3, [r0, #14]
   1d084:	f003 0307 	and.w	r3, r3, #7
   1d088:	2b02      	cmp	r3, #2
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1d08a:	4604      	mov	r4, r0
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
   1d08c:	d126      	bne.n	1d0dc <lv_label_revert_dots+0x64>
    if(ext->dot_end == LV_LABEL_DOT_END_INV) return;
   1d08e:	8901      	ldrh	r1, [r0, #8]
   1d090:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1d094:	4299      	cmp	r1, r3
   1d096:	d021      	beq.n	1d0dc <lv_label_revert_dots+0x64>
    uint32_t letter_i = ext->dot_end - LV_LABEL_DOT_NUM;
    uint32_t byte_i   = lv_txt_encoded_get_byte_id(ext->text, letter_i);
   1d098:	4b12      	ldr	r3, [pc, #72]	; (1d0e4 <lv_label_revert_dots+0x6c>)
   1d09a:	6800      	ldr	r0, [r0, #0]
   1d09c:	681b      	ldr	r3, [r3, #0]
   1d09e:	3903      	subs	r1, #3
   1d0a0:	4798      	blx	r3
   1d0a2:	4680      	mov	r8, r0
 * @param label pointer to label object
 * @return char pointer to a stored characters. Is *not* necessarily NULL-terminated.
 */
static char * lv_label_get_dot_tmp(lv_obj_t * label)
{
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1d0a4:	4628      	mov	r0, r5
   1d0a6:	f008 fd21 	bl	25aec <lv_obj_get_ext_attr>
    if(ext->dot_tmp_alloc) {
   1d0aa:	7bc3      	ldrb	r3, [r0, #15]
   1d0ac:	079b      	lsls	r3, r3, #30
        return ext->dot.tmp_ptr;
   1d0ae:	bf4c      	ite	mi
   1d0b0:	6840      	ldrmi	r0, [r0, #4]
    } else {
        return ext->dot.tmp;
   1d0b2:	3004      	addpl	r0, #4
    while(ext->text[byte_i + i] != '\0') {
   1d0b4:	2100      	movs	r1, #0
   1d0b6:	b2ce      	uxtb	r6, r1
   1d0b8:	eb06 0308 	add.w	r3, r6, r8
   1d0bc:	6822      	ldr	r2, [r4, #0]
   1d0be:	5d86      	ldrb	r6, [r0, r6]
   1d0c0:	f812 c003 	ldrb.w	ip, [r2, r3]
   1d0c4:	18d7      	adds	r7, r2, r3
   1d0c6:	3101      	adds	r1, #1
   1d0c8:	f1bc 0f00 	cmp.w	ip, #0
   1d0cc:	d108      	bne.n	1d0e0 <lv_label_revert_dots+0x68>
    ext->text[byte_i + i] = dot_tmp[i];
   1d0ce:	703e      	strb	r6, [r7, #0]
    lv_label_dot_tmp_free(label);
   1d0d0:	4628      	mov	r0, r5
   1d0d2:	f00a fa36 	bl	27542 <lv_label_dot_tmp_free>
    ext->dot_end = LV_LABEL_DOT_END_INV;
   1d0d6:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1d0da:	8123      	strh	r3, [r4, #8]
}
   1d0dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ext->text[byte_i + i] = dot_tmp[i];
   1d0e0:	54d6      	strb	r6, [r2, r3]
        i++;
   1d0e2:	e7e8      	b.n	1d0b6 <lv_label_revert_dots+0x3e>
   1d0e4:	2000ebc4 	.word	0x2000ebc4

0001d0e8 <lv_label_set_dot_tmp>:
{
   1d0e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d0ea:	4616      	mov	r6, r2
   1d0ec:	4604      	mov	r4, r0
   1d0ee:	460f      	mov	r7, r1
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1d0f0:	f008 fcfc 	bl	25aec <lv_obj_get_ext_attr>
   1d0f4:	4605      	mov	r5, r0
    lv_label_dot_tmp_free(label); /* Deallocate any existing space */
   1d0f6:	4620      	mov	r0, r4
   1d0f8:	f00a fa23 	bl	27542 <lv_label_dot_tmp_free>
    if(len > sizeof(char *)) {
   1d0fc:	2e04      	cmp	r6, #4
   1d0fe:	d91b      	bls.n	1d138 <lv_label_set_dot_tmp+0x50>
        ext->dot.tmp_ptr = lv_mem_alloc(len + 1);
   1d100:	1c70      	adds	r0, r6, #1
   1d102:	f7ff fde7 	bl	1ccd4 <lv_mem_alloc>
   1d106:	4604      	mov	r4, r0
   1d108:	6068      	str	r0, [r5, #4]
        if(ext->dot.tmp_ptr == NULL) {
   1d10a:	b940      	cbnz	r0, 1d11e <lv_label_set_dot_tmp+0x36>
            LV_LOG_ERROR("Failed to allocate memory for dot_tmp_ptr");
   1d10c:	2003      	movs	r0, #3
   1d10e:	4b0f      	ldr	r3, [pc, #60]	; (1d14c <lv_label_set_dot_tmp+0x64>)
   1d110:	490f      	ldr	r1, [pc, #60]	; (1d150 <lv_label_set_dot_tmp+0x68>)
   1d112:	f240 526e 	movw	r2, #1390	; 0x56e
   1d116:	f7ff ff9f 	bl	1d058 <lv_log_add>
            return false;
   1d11a:	4620      	mov	r0, r4
}
   1d11c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1d11e:	4632      	mov	r2, r6
   1d120:	4639      	mov	r1, r7
   1d122:	f7e4 fd63 	bl	1bec <memcpy>
        ext->dot.tmp_ptr[len] = '\0';
   1d126:	686b      	ldr	r3, [r5, #4]
   1d128:	2200      	movs	r2, #0
   1d12a:	559a      	strb	r2, [r3, r6]
        ext->dot_tmp_alloc    = true;
   1d12c:	7beb      	ldrb	r3, [r5, #15]
   1d12e:	f043 0302 	orr.w	r3, r3, #2
   1d132:	73eb      	strb	r3, [r5, #15]
    return true;
   1d134:	2001      	movs	r0, #1
   1d136:	e7f1      	b.n	1d11c <lv_label_set_dot_tmp+0x34>
        ext->dot_tmp_alloc = false;
   1d138:	7beb      	ldrb	r3, [r5, #15]
   1d13a:	f36f 0341 	bfc	r3, #1, #1
   1d13e:	73eb      	strb	r3, [r5, #15]
   1d140:	4632      	mov	r2, r6
   1d142:	4639      	mov	r1, r7
   1d144:	1d28      	adds	r0, r5, #4
   1d146:	f7e4 fd51 	bl	1bec <memcpy>
   1d14a:	e7f3      	b.n	1d134 <lv_label_set_dot_tmp+0x4c>
   1d14c:	00065b4f 	.word	0x00065b4f
   1d150:	00065b79 	.word	0x00065b79

0001d154 <lv_label_get_letter_on>:
{
   1d154:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1d158:	b08b      	sub	sp, #44	; 0x2c
   1d15a:	4680      	mov	r8, r0
   1d15c:	9107      	str	r1, [sp, #28]
    const char * txt         = lv_label_get_text(label);
   1d15e:	f00a fa2b 	bl	275b8 <lv_label_get_text>
   1d162:	9003      	str	r0, [sp, #12]
    lv_label_ext_t * ext     = lv_obj_get_ext_attr(label);
   1d164:	4640      	mov	r0, r8
   1d166:	f008 fcc1 	bl	25aec <lv_obj_get_ext_attr>
   1d16a:	4604      	mov	r4, r0
    lv_coord_t max_w         = lv_obj_get_width(label);
   1d16c:	4640      	mov	r0, r8
   1d16e:	f008 fc51 	bl	25a14 <lv_obj_get_width>
   1d172:	9005      	str	r0, [sp, #20]
    const lv_style_t * style = lv_obj_get_style(label);
   1d174:	4640      	mov	r0, r8
   1d176:	f7fd fec9 	bl	1af0c <lv_obj_get_style>
    const lv_font_t * font   = style->text.font;
   1d17a:	6b43      	ldr	r3, [r0, #52]	; 0x34
   1d17c:	9304      	str	r3, [sp, #16]
    uint8_t letter_height    = lv_font_get_line_height(font);
   1d17e:	7a1b      	ldrb	r3, [r3, #8]
   1d180:	9306      	str	r3, [sp, #24]
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
   1d182:	7ba3      	ldrb	r3, [r4, #14]
    const lv_style_t * style = lv_obj_get_style(label);
   1d184:	4683      	mov	fp, r0
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
   1d186:	f3c3 1680 	ubfx	r6, r3, #6, #1
    lv_label_align_t align = lv_label_get_align(label);
   1d18a:	4640      	mov	r0, r8
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
   1d18c:	061b      	lsls	r3, r3, #24
   1d18e:	bf48      	it	mi
   1d190:	f046 0602 	orrmi.w	r6, r6, #2
    lv_label_align_t align = lv_label_get_align(label);
   1d194:	f00a fa1c 	bl	275d0 <lv_label_get_align>
    if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
   1d198:	2801      	cmp	r0, #1
    lv_label_align_t align = lv_label_get_align(label);
   1d19a:	4681      	mov	r9, r0
    if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
   1d19c:	d113      	bne.n	1d1c6 <lv_label_get_letter_on+0x72>
   1d19e:	f046 0604 	orr.w	r6, r6, #4
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
   1d1a2:	7ba3      	ldrb	r3, [r4, #14]
        max_w = LV_COORD_MAX;
   1d1a4:	9a05      	ldr	r2, [sp, #20]
   1d1a6:	f013 0f07 	tst.w	r3, #7
   1d1aa:	f647 4318 	movw	r3, #31768	; 0x7c18
   1d1ae:	bf08      	it	eq
   1d1b0:	461a      	moveq	r2, r3
   1d1b2:	f04f 0a00 	mov.w	sl, #0
   1d1b6:	9205      	str	r2, [sp, #20]
   1d1b8:	4655      	mov	r5, sl
    while(txt[line_start] != '\0') {
   1d1ba:	9b03      	ldr	r3, [sp, #12]
   1d1bc:	195f      	adds	r7, r3, r5
   1d1be:	5d5b      	ldrb	r3, [r3, r5]
   1d1c0:	b933      	cbnz	r3, 1d1d0 <lv_label_get_letter_on+0x7c>
   1d1c2:	462c      	mov	r4, r5
   1d1c4:	e021      	b.n	1d20a <lv_label_get_letter_on+0xb6>
    if(align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
   1d1c6:	2802      	cmp	r0, #2
   1d1c8:	bf08      	it	eq
   1d1ca:	f046 0608 	orreq.w	r6, r6, #8
   1d1ce:	e7e8      	b.n	1d1a2 <lv_label_get_letter_on+0x4e>
        new_line_start += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, max_w, flag);
   1d1d0:	f9bb 2038 	ldrsh.w	r2, [fp, #56]	; 0x38
   1d1d4:	9600      	str	r6, [sp, #0]
   1d1d6:	e9dd 1304 	ldrd	r1, r3, [sp, #16]
   1d1da:	4638      	mov	r0, r7
   1d1dc:	f7ff fe40 	bl	1ce60 <lv_txt_get_next_line>
        if(pos->y <= y + letter_height) {
   1d1e0:	9b07      	ldr	r3, [sp, #28]
   1d1e2:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
   1d1e6:	9b06      	ldr	r3, [sp, #24]
   1d1e8:	4453      	add	r3, sl
   1d1ea:	429a      	cmp	r2, r3
        new_line_start += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, max_w, flag);
   1d1ec:	eb00 0405 	add.w	r4, r0, r5
        if(pos->y <= y + letter_height) {
   1d1f0:	dc3a      	bgt.n	1d268 <lv_label_get_letter_on+0x114>
            letter = lv_txt_encoded_prev(txt, &tmp);
   1d1f2:	4b4c      	ldr	r3, [pc, #304]	; (1d324 <lv_label_get_letter_on+0x1d0>)
            uint32_t tmp = new_line_start;
   1d1f4:	9409      	str	r4, [sp, #36]	; 0x24
            letter = lv_txt_encoded_prev(txt, &tmp);
   1d1f6:	681b      	ldr	r3, [r3, #0]
   1d1f8:	9803      	ldr	r0, [sp, #12]
   1d1fa:	a909      	add	r1, sp, #36	; 0x24
   1d1fc:	4798      	blx	r3
            if(letter != '\n' && txt[new_line_start] == '\0' ) new_line_start++;
   1d1fe:	280a      	cmp	r0, #10
   1d200:	d003      	beq.n	1d20a <lv_label_get_letter_on+0xb6>
   1d202:	9b03      	ldr	r3, [sp, #12]
   1d204:	5d1b      	ldrb	r3, [r3, r4]
   1d206:	b903      	cbnz	r3, 1d20a <lv_label_get_letter_on+0xb6>
   1d208:	3401      	adds	r4, #1
    if(align == LV_LABEL_ALIGN_CENTER) {
   1d20a:	f1b9 0f01 	cmp.w	r9, #1
   1d20e:	d134      	bne.n	1d27a <lv_label_get_letter_on+0x126>
        line_w = lv_txt_get_width(bidi_txt, new_line_start - line_start, font, style->text.letter_space, flag);
   1d210:	1b61      	subs	r1, r4, r5
   1d212:	f9bb 3038 	ldrsh.w	r3, [fp, #56]	; 0x38
   1d216:	9a04      	ldr	r2, [sp, #16]
   1d218:	9600      	str	r6, [sp, #0]
   1d21a:	b289      	uxth	r1, r1
   1d21c:	4638      	mov	r0, r7
   1d21e:	f7ff fdcf 	bl	1cdc0 <lv_txt_get_width>
   1d222:	4681      	mov	r9, r0
        x += lv_obj_get_width(label) / 2 - line_w / 2;
   1d224:	4640      	mov	r0, r8
   1d226:	f008 fbf5 	bl	25a14 <lv_obj_get_width>
   1d22a:	eb09 79d9 	add.w	r9, r9, r9, lsr #31
   1d22e:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
   1d232:	ea4f 0969 	mov.w	r9, r9, asr #1
   1d236:	ebc9 0960 	rsb	r9, r9, r0, asr #1
   1d23a:	fa0f f889 	sxth.w	r8, r9
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
   1d23e:	2300      	movs	r3, #0
   1d240:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    uint32_t i = 0;
   1d244:	9309      	str	r3, [sp, #36]	; 0x24
    if(new_line_start > 0) {
   1d246:	2c00      	cmp	r4, #0
   1d248:	d165      	bne.n	1d316 <lv_label_get_letter_on+0x1c2>
    logical_pos = lv_txt_encoded_get_char_id(bidi_txt, i);
   1d24a:	4e37      	ldr	r6, [pc, #220]	; (1d328 <lv_label_get_letter_on+0x1d4>)
   1d24c:	9909      	ldr	r1, [sp, #36]	; 0x24
   1d24e:	6833      	ldr	r3, [r6, #0]
   1d250:	4638      	mov	r0, r7
   1d252:	4798      	blx	r3
    return  logical_pos + lv_txt_encoded_get_char_id(txt, line_start);
   1d254:	6833      	ldr	r3, [r6, #0]
    logical_pos = lv_txt_encoded_get_char_id(bidi_txt, i);
   1d256:	4604      	mov	r4, r0
    return  logical_pos + lv_txt_encoded_get_char_id(txt, line_start);
   1d258:	4629      	mov	r1, r5
   1d25a:	9803      	ldr	r0, [sp, #12]
   1d25c:	4798      	blx	r3
   1d25e:	4420      	add	r0, r4
}
   1d260:	b280      	uxth	r0, r0
   1d262:	b00b      	add	sp, #44	; 0x2c
   1d264:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        y += letter_height + style->text.line_space;
   1d268:	f8bb 303a 	ldrh.w	r3, [fp, #58]	; 0x3a
   1d26c:	9a06      	ldr	r2, [sp, #24]
   1d26e:	4413      	add	r3, r2
   1d270:	449a      	add	sl, r3
   1d272:	fa0f fa8a 	sxth.w	sl, sl
        new_line_start += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, max_w, flag);
   1d276:	4625      	mov	r5, r4
   1d278:	e79f      	b.n	1d1ba <lv_label_get_letter_on+0x66>
    else if(align == LV_LABEL_ALIGN_RIGHT) {
   1d27a:	f1b9 0f02 	cmp.w	r9, #2
   1d27e:	d111      	bne.n	1d2a4 <lv_label_get_letter_on+0x150>
        line_w = lv_txt_get_width(bidi_txt, new_line_start - line_start, font, style->text.letter_space, flag);
   1d280:	1b61      	subs	r1, r4, r5
   1d282:	f9bb 3038 	ldrsh.w	r3, [fp, #56]	; 0x38
   1d286:	9a04      	ldr	r2, [sp, #16]
   1d288:	9600      	str	r6, [sp, #0]
   1d28a:	b289      	uxth	r1, r1
   1d28c:	4638      	mov	r0, r7
   1d28e:	f7ff fd97 	bl	1cdc0 <lv_txt_get_width>
   1d292:	4681      	mov	r9, r0
        x += lv_obj_get_width(label) - line_w;
   1d294:	4640      	mov	r0, r8
   1d296:	f008 fbbd 	bl	25a14 <lv_obj_get_width>
   1d29a:	eba0 0009 	sub.w	r0, r0, r9
   1d29e:	fa0f f880 	sxth.w	r8, r0
   1d2a2:	e7cc      	b.n	1d23e <lv_label_get_letter_on+0xea>
    lv_coord_t x = 0;
   1d2a4:	f04f 0800 	mov.w	r8, #0
   1d2a8:	e7c9      	b.n	1d23e <lv_label_get_letter_on+0xea>
                if(lv_txt_is_cmd(&cmd_state, bidi_txt[i]) != false) {
   1d2aa:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1d2ac:	9006      	str	r0, [sp, #24]
   1d2ae:	5cf9      	ldrb	r1, [r7, r3]
   1d2b0:	f10d 0023 	add.w	r0, sp, #35	; 0x23
   1d2b4:	f00a f8b5 	bl	27422 <lv_txt_is_cmd>
   1d2b8:	9a06      	ldr	r2, [sp, #24]
   1d2ba:	b190      	cbz	r0, 1d2e2 <lv_label_get_letter_on+0x18e>
        while(i + line_start < new_line_start) {
   1d2bc:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1d2be:	442b      	add	r3, r5
   1d2c0:	42a3      	cmp	r3, r4
   1d2c2:	d2c2      	bcs.n	1d24a <lv_label_get_letter_on+0xf6>
            letter = lv_txt_encoded_next(bidi_txt, &i);
   1d2c4:	f8d9 3000 	ldr.w	r3, [r9]
   1d2c8:	a909      	add	r1, sp, #36	; 0x24
   1d2ca:	4638      	mov	r0, r7
   1d2cc:	4798      	blx	r3
   1d2ce:	9005      	str	r0, [sp, #20]
            letter_next = lv_txt_encoded_next(&bidi_txt[i], NULL);
   1d2d0:	9809      	ldr	r0, [sp, #36]	; 0x24
   1d2d2:	f8d9 3000 	ldr.w	r3, [r9]
   1d2d6:	2100      	movs	r1, #0
   1d2d8:	4438      	add	r0, r7
   1d2da:	4798      	blx	r3
   1d2dc:	4602      	mov	r2, r0
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   1d2de:	2e00      	cmp	r6, #0
   1d2e0:	d1e3      	bne.n	1d2aa <lv_label_get_letter_on+0x156>
            x += lv_font_get_glyph_width(font, letter, letter_next);
   1d2e2:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   1d2e6:	f00a fb36 	bl	27956 <lv_font_get_glyph_width>
            if(pos->x < x || i + line_start == new_line_start) {
   1d2ea:	9b07      	ldr	r3, [sp, #28]
            x += lv_font_get_glyph_width(font, letter, letter_next);
   1d2ec:	4480      	add	r8, r0
            if(pos->x < x || i + line_start == new_line_start) {
   1d2ee:	f9b3 3000 	ldrsh.w	r3, [r3]
            x += lv_font_get_glyph_width(font, letter, letter_next);
   1d2f2:	fa0f f888 	sxth.w	r8, r8
            if(pos->x < x || i + line_start == new_line_start) {
   1d2f6:	4543      	cmp	r3, r8
   1d2f8:	da02      	bge.n	1d300 <lv_label_get_letter_on+0x1ac>
                i = i_act;
   1d2fa:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
                break;
   1d2fe:	e7a4      	b.n	1d24a <lv_label_get_letter_on+0xf6>
            if(pos->x < x || i + line_start == new_line_start) {
   1d300:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1d302:	195a      	adds	r2, r3, r5
   1d304:	42a2      	cmp	r2, r4
   1d306:	d0f8      	beq.n	1d2fa <lv_label_get_letter_on+0x1a6>
            x += style->text.letter_space;
   1d308:	f8bb 0038 	ldrh.w	r0, [fp, #56]	; 0x38
   1d30c:	4480      	add	r8, r0
   1d30e:	fa0f f888 	sxth.w	r8, r8
            i_act = i;
   1d312:	469a      	mov	sl, r3
   1d314:	e7d2      	b.n	1d2bc <lv_label_get_letter_on+0x168>
    uint32_t i_act = i;
   1d316:	469a      	mov	sl, r3
            letter = lv_txt_encoded_next(bidi_txt, &i);
   1d318:	f8df 9010 	ldr.w	r9, [pc, #16]	; 1d32c <lv_label_get_letter_on+0x1d8>
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   1d31c:	f006 0601 	and.w	r6, r6, #1
   1d320:	e7cc      	b.n	1d2bc <lv_label_get_letter_on+0x168>
   1d322:	bf00      	nop
   1d324:	2000ebd0 	.word	0x2000ebd0
   1d328:	2000ebc8 	.word	0x2000ebc8
   1d32c:	2000ebcc 	.word	0x2000ebcc

0001d330 <lv_label_refr_text>:
{
   1d330:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1d334:	b089      	sub	sp, #36	; 0x24
   1d336:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1d338:	f008 fbd8 	bl	25aec <lv_obj_get_ext_attr>
    if(ext->text == NULL) return;
   1d33c:	6803      	ldr	r3, [r0, #0]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1d33e:	4604      	mov	r4, r0
    if(ext->text == NULL) return;
   1d340:	b373      	cbz	r3, 1d3a0 <lv_label_refr_text+0x70>
    lv_coord_t max_w         = lv_obj_get_width(label);
   1d342:	4628      	mov	r0, r5
   1d344:	f008 fb66 	bl	25a14 <lv_obj_get_width>
   1d348:	4607      	mov	r7, r0
    const lv_style_t * style = lv_obj_get_style(label);
   1d34a:	4628      	mov	r0, r5
   1d34c:	f7fd fdde 	bl	1af0c <lv_obj_get_style>
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
   1d350:	7ba3      	ldrb	r3, [r4, #14]
    const lv_font_t * font   = style->text.font;
   1d352:	6b42      	ldr	r2, [r0, #52]	; 0x34
        max_w = LV_COORD_MAX;
   1d354:	f013 0f07 	tst.w	r3, #7
   1d358:	f647 4118 	movw	r1, #31768	; 0x7c18
   1d35c:	bf08      	it	eq
   1d35e:	460f      	moveq	r7, r1
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
   1d360:	f3c3 1180 	ubfx	r1, r3, #6, #1
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
   1d364:	061b      	lsls	r3, r3, #24
   1d366:	bf48      	it	mi
   1d368:	f041 0102 	orrmi.w	r1, r1, #2
    lv_txt_get_size(&size, ext->text, font, style->text.letter_space, style->text.line_space, max_w, flag);
   1d36c:	f9b0 3038 	ldrsh.w	r3, [r0, #56]	; 0x38
   1d370:	e9cd 7101 	strd	r7, r1, [sp, #4]
   1d374:	f9b0 103a 	ldrsh.w	r1, [r0, #58]	; 0x3a
   1d378:	9100      	str	r1, [sp, #0]
    const lv_style_t * style = lv_obj_get_style(label);
   1d37a:	4606      	mov	r6, r0
    lv_txt_get_size(&size, ext->text, font, style->text.letter_space, style->text.line_space, max_w, flag);
   1d37c:	6821      	ldr	r1, [r4, #0]
   1d37e:	a805      	add	r0, sp, #20
   1d380:	f00a f86c 	bl	2745c <lv_txt_get_size>
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
   1d384:	7ba3      	ldrb	r3, [r4, #14]
   1d386:	f013 0307 	ands.w	r3, r3, #7
   1d38a:	d10c      	bne.n	1d3a6 <lv_label_refr_text+0x76>
        lv_obj_set_size(label, size.x, size.y);
   1d38c:	f9bd 2016 	ldrsh.w	r2, [sp, #22]
   1d390:	f9bd 1014 	ldrsh.w	r1, [sp, #20]
   1d394:	4628      	mov	r0, r5
   1d396:	f008 f988 	bl	256aa <lv_obj_set_size>
    lv_obj_invalidate(label);
   1d39a:	4628      	mov	r0, r5
   1d39c:	f008 f8e5 	bl	2556a <lv_obj_invalidate>
}
   1d3a0:	b009      	add	sp, #36	; 0x24
   1d3a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    else if(ext->long_mode == LV_LABEL_LONG_SROLL) {
   1d3a6:	1eda      	subs	r2, r3, #3
   1d3a8:	2a01      	cmp	r2, #1
   1d3aa:	d9f6      	bls.n	1d39a <lv_label_refr_text+0x6a>
    } else if(ext->long_mode == LV_LABEL_LONG_DOT) {
   1d3ac:	2b02      	cmp	r3, #2
   1d3ae:	d16e      	bne.n	1d48e <lv_label_refr_text+0x15e>
        if(size.y <= lv_obj_get_height(label)) { /*No dots are required, the text is short enough*/
   1d3b0:	4628      	mov	r0, r5
   1d3b2:	f9bd 7016 	ldrsh.w	r7, [sp, #22]
   1d3b6:	f008 fb33 	bl	25a20 <lv_obj_get_height>
   1d3ba:	4287      	cmp	r7, r0
   1d3bc:	dc03      	bgt.n	1d3c6 <lv_label_refr_text+0x96>
            ext->dot_end = LV_LABEL_DOT_END_INV;
   1d3be:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1d3c2:	8123      	strh	r3, [r4, #8]
   1d3c4:	e7e9      	b.n	1d39a <lv_label_refr_text+0x6a>
        } else if(lv_txt_get_encoded_length(ext->text) <= LV_LABEL_DOT_NUM) { /*Don't turn to dots all the characters*/
   1d3c6:	4b36      	ldr	r3, [pc, #216]	; (1d4a0 <lv_label_refr_text+0x170>)
   1d3c8:	6820      	ldr	r0, [r4, #0]
   1d3ca:	681b      	ldr	r3, [r3, #0]
   1d3cc:	4798      	blx	r3
   1d3ce:	2803      	cmp	r0, #3
   1d3d0:	d9f5      	bls.n	1d3be <lv_label_refr_text+0x8e>
            p.x = lv_obj_get_width(label) -
   1d3d2:	4628      	mov	r0, r5
   1d3d4:	f008 fb1e 	bl	25a14 <lv_obj_get_width>
                  (lv_font_get_glyph_width(style->text.font, '.', '.') + style->text.letter_space) *
   1d3d8:	222e      	movs	r2, #46	; 0x2e
   1d3da:	4611      	mov	r1, r2
            p.x = lv_obj_get_width(label) -
   1d3dc:	4607      	mov	r7, r0
                  (lv_font_get_glyph_width(style->text.font, '.', '.') + style->text.letter_space) *
   1d3de:	6b70      	ldr	r0, [r6, #52]	; 0x34
                len += lv_txt_encoded_size(&ext->text[byte_id]);
   1d3e0:	f8df a0c4 	ldr.w	sl, [pc, #196]	; 1d4a8 <lv_label_refr_text+0x178>
                lv_txt_encoded_next(ext->text, &byte_id);
   1d3e4:	f8df b0c4 	ldr.w	fp, [pc, #196]	; 1d4ac <lv_label_refr_text+0x17c>
                  (lv_font_get_glyph_width(style->text.font, '.', '.') + style->text.letter_space) *
   1d3e8:	f00a fab5 	bl	27956 <lv_font_get_glyph_width>
   1d3ec:	f9b6 3038 	ldrsh.w	r3, [r6, #56]	; 0x38
   1d3f0:	4418      	add	r0, r3
            p.x = lv_obj_get_width(label) -
   1d3f2:	eba0 0080 	sub.w	r0, r0, r0, lsl #2
   1d3f6:	4438      	add	r0, r7
   1d3f8:	f8ad 0018 	strh.w	r0, [sp, #24]
            p.y = lv_obj_get_height(label);
   1d3fc:	4628      	mov	r0, r5
   1d3fe:	f008 fb0f 	bl	25a20 <lv_obj_get_height>
                   (lv_font_get_line_height(style->text.font) + style->text.line_space); /*Round down to the last line*/
   1d402:	6b73      	ldr	r3, [r6, #52]	; 0x34
   1d404:	f9b6 103a 	ldrsh.w	r1, [r6, #58]	; 0x3a
   1d408:	7a1b      	ldrb	r3, [r3, #8]
   1d40a:	440b      	add	r3, r1
            p.y -= style->text.line_space;                                               /*Trim the last line space*/
   1d40c:	1a42      	subs	r2, r0, r1
            p.y -= p.y %
   1d40e:	fb90 f1f3 	sdiv	r1, r0, r3
   1d412:	fb03 0311 	mls	r3, r3, r1, r0
            p.y -= style->text.line_space;                                               /*Trim the last line space*/
   1d416:	1ad2      	subs	r2, r2, r3
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
   1d418:	a906      	add	r1, sp, #24
   1d41a:	4628      	mov	r0, r5
            p.y -= style->text.line_space;                                               /*Trim the last line space*/
   1d41c:	f8ad 201a 	strh.w	r2, [sp, #26]
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
   1d420:	f7ff fe98 	bl	1d154 <lv_label_get_letter_on>
            uint32_t byte_id     = lv_txt_encoded_get_byte_id(ext->text, letter_id);
   1d424:	4b1f      	ldr	r3, [pc, #124]	; (1d4a4 <lv_label_refr_text+0x174>)
   1d426:	4601      	mov	r1, r0
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
   1d428:	4607      	mov	r7, r0
            uint32_t byte_id     = lv_txt_encoded_get_byte_id(ext->text, letter_id);
   1d42a:	681b      	ldr	r3, [r3, #0]
   1d42c:	6820      	ldr	r0, [r4, #0]
   1d42e:	4798      	blx	r3
   1d430:	f04f 0804 	mov.w	r8, #4
   1d434:	4606      	mov	r6, r0
   1d436:	9007      	str	r0, [sp, #28]
            uint8_t len          = 0;
   1d438:	f04f 0900 	mov.w	r9, #0
                len += lv_txt_encoded_size(&ext->text[byte_id]);
   1d43c:	9907      	ldr	r1, [sp, #28]
   1d43e:	6820      	ldr	r0, [r4, #0]
   1d440:	f8da 3000 	ldr.w	r3, [sl]
   1d444:	4408      	add	r0, r1
   1d446:	4798      	blx	r3
                lv_txt_encoded_next(ext->text, &byte_id);
   1d448:	f8db 3000 	ldr.w	r3, [fp]
                len += lv_txt_encoded_size(&ext->text[byte_id]);
   1d44c:	4481      	add	r9, r0
                lv_txt_encoded_next(ext->text, &byte_id);
   1d44e:	a907      	add	r1, sp, #28
   1d450:	6820      	ldr	r0, [r4, #0]
   1d452:	4798      	blx	r3
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
   1d454:	f1b8 0801 	subs.w	r8, r8, #1
                len += lv_txt_encoded_size(&ext->text[byte_id]);
   1d458:	fa5f f989 	uxtb.w	r9, r9
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
   1d45c:	d1ee      	bne.n	1d43c <lv_label_refr_text+0x10c>
            if(lv_label_set_dot_tmp(label, &ext->text[byte_id_ori], len)) {
   1d45e:	6821      	ldr	r1, [r4, #0]
   1d460:	464a      	mov	r2, r9
   1d462:	4431      	add	r1, r6
   1d464:	4628      	mov	r0, r5
   1d466:	f7ff fe3f 	bl	1d0e8 <lv_label_set_dot_tmp>
   1d46a:	2800      	cmp	r0, #0
   1d46c:	d095      	beq.n	1d39a <lv_label_refr_text+0x6a>
                    ext->text[byte_id_ori + i] = '.';
   1d46e:	6823      	ldr	r3, [r4, #0]
   1d470:	222e      	movs	r2, #46	; 0x2e
   1d472:	559a      	strb	r2, [r3, r6]
   1d474:	6823      	ldr	r3, [r4, #0]
   1d476:	4433      	add	r3, r6
                ext->dot_end                              = letter_id + LV_LABEL_DOT_NUM;
   1d478:	3703      	adds	r7, #3
                    ext->text[byte_id_ori + i] = '.';
   1d47a:	705a      	strb	r2, [r3, #1]
   1d47c:	6823      	ldr	r3, [r4, #0]
   1d47e:	4433      	add	r3, r6
   1d480:	709a      	strb	r2, [r3, #2]
                ext->text[byte_id_ori + LV_LABEL_DOT_NUM] = '\0';
   1d482:	6823      	ldr	r3, [r4, #0]
   1d484:	441e      	add	r6, r3
   1d486:	f886 8003 	strb.w	r8, [r6, #3]
                ext->dot_end                              = letter_id + LV_LABEL_DOT_NUM;
   1d48a:	8127      	strh	r7, [r4, #8]
   1d48c:	e785      	b.n	1d39a <lv_label_refr_text+0x6a>
    else if(ext->long_mode == LV_LABEL_LONG_BREAK) {
   1d48e:	2b01      	cmp	r3, #1
   1d490:	d183      	bne.n	1d39a <lv_label_refr_text+0x6a>
        lv_obj_set_height(label, size.y);
   1d492:	f9bd 1016 	ldrsh.w	r1, [sp, #22]
   1d496:	4628      	mov	r0, r5
   1d498:	f008 f950 	bl	2573c <lv_obj_set_height>
   1d49c:	e77d      	b.n	1d39a <lv_label_refr_text+0x6a>
   1d49e:	bf00      	nop
   1d4a0:	2000ebd8 	.word	0x2000ebd8
   1d4a4:	2000ebc4 	.word	0x2000ebc4
   1d4a8:	2000ebd4 	.word	0x2000ebd4
   1d4ac:	2000ebcc 	.word	0x2000ebcc

0001d4b0 <lv_label_signal>:
    res = ancestor_signal(label, sign, param);
   1d4b0:	4b34      	ldr	r3, [pc, #208]	; (1d584 <lv_label_signal+0xd4>)
{
   1d4b2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    res = ancestor_signal(label, sign, param);
   1d4b6:	681b      	ldr	r3, [r3, #0]
{
   1d4b8:	4604      	mov	r4, r0
   1d4ba:	460d      	mov	r5, r1
   1d4bc:	4617      	mov	r7, r2
    res = ancestor_signal(label, sign, param);
   1d4be:	4798      	blx	r3
    if(res != LV_RES_OK) return res;
   1d4c0:	2801      	cmp	r0, #1
    res = ancestor_signal(label, sign, param);
   1d4c2:	4606      	mov	r6, r0
    if(res != LV_RES_OK) return res;
   1d4c4:	d118      	bne.n	1d4f8 <lv_label_signal+0x48>
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
   1d4c6:	2d07      	cmp	r5, #7
   1d4c8:	d105      	bne.n	1d4d6 <lv_label_signal+0x26>
   1d4ca:	4638      	mov	r0, r7
   1d4cc:	492e      	ldr	r1, [pc, #184]	; (1d588 <lv_label_signal+0xd8>)
}
   1d4ce:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
   1d4d2:	f008 bb0d 	b.w	25af0 <lv_obj_handle_get_type_signal>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1d4d6:	4620      	mov	r0, r4
   1d4d8:	f008 fb08 	bl	25aec <lv_obj_get_ext_attr>
   1d4dc:	4680      	mov	r8, r0
    if(sign == LV_SIGNAL_CLEANUP) {
   1d4de:	b975      	cbnz	r5, 1d4fe <lv_label_signal+0x4e>
        if(ext->static_txt == 0) {
   1d4e0:	7b83      	ldrb	r3, [r0, #14]
   1d4e2:	f013 0508 	ands.w	r5, r3, #8
   1d4e6:	d104      	bne.n	1d4f2 <lv_label_signal+0x42>
            lv_mem_free(ext->text);
   1d4e8:	6800      	ldr	r0, [r0, #0]
   1d4ea:	f7ff fc19 	bl	1cd20 <lv_mem_free>
            ext->text = NULL;
   1d4ee:	f8c8 5000 	str.w	r5, [r8]
        lv_label_dot_tmp_free(label);
   1d4f2:	4620      	mov	r0, r4
   1d4f4:	f00a f825 	bl	27542 <lv_label_dot_tmp_free>
}
   1d4f8:	4630      	mov	r0, r6
   1d4fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
   1d4fe:	2d04      	cmp	r5, #4
   1d500:	d106      	bne.n	1d510 <lv_label_signal+0x60>
        lv_label_revert_dots(label);
   1d502:	4620      	mov	r0, r4
   1d504:	f7ff fdb8 	bl	1d078 <lv_label_revert_dots>
        lv_label_refr_text(label);
   1d508:	4620      	mov	r0, r4
   1d50a:	f7ff ff11 	bl	1d330 <lv_label_refr_text>
   1d50e:	e7f3      	b.n	1d4f8 <lv_label_signal+0x48>
    } else if(sign == LV_SIGNAL_CORD_CHG) {
   1d510:	2d02      	cmp	r5, #2
   1d512:	d114      	bne.n	1d53e <lv_label_signal+0x8e>
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1d514:	8a23      	ldrh	r3, [r4, #16]
   1d516:	8aa2      	ldrh	r2, [r4, #20]
   1d518:	8839      	ldrh	r1, [r7, #0]
   1d51a:	1ad2      	subs	r2, r2, r3
   1d51c:	88bb      	ldrh	r3, [r7, #4]
   1d51e:	1a5b      	subs	r3, r3, r1
        if(lv_area_get_width(&label->coords) != lv_area_get_width(param) ||
   1d520:	b212      	sxth	r2, r2
   1d522:	b21b      	sxth	r3, r3
   1d524:	429a      	cmp	r2, r3
   1d526:	d1ec      	bne.n	1d502 <lv_label_signal+0x52>
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1d528:	8a63      	ldrh	r3, [r4, #18]
   1d52a:	8ae2      	ldrh	r2, [r4, #22]
   1d52c:	8879      	ldrh	r1, [r7, #2]
   1d52e:	1ad2      	subs	r2, r2, r3
   1d530:	88fb      	ldrh	r3, [r7, #6]
   1d532:	1a5b      	subs	r3, r3, r1
   1d534:	b212      	sxth	r2, r2
   1d536:	b21b      	sxth	r3, r3
   1d538:	429a      	cmp	r2, r3
   1d53a:	d1e2      	bne.n	1d502 <lv_label_signal+0x52>
   1d53c:	e7dc      	b.n	1d4f8 <lv_label_signal+0x48>
    } else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
   1d53e:	2d06      	cmp	r5, #6
   1d540:	d1da      	bne.n	1d4f8 <lv_label_signal+0x48>
        if(ext->body_draw) {
   1d542:	7bc3      	ldrb	r3, [r0, #15]
   1d544:	f013 0501 	ands.w	r5, r3, #1
   1d548:	d0d6      	beq.n	1d4f8 <lv_label_signal+0x48>
 * @return pointer to the label's style
 */
static inline const lv_style_t * lv_label_get_style(const lv_obj_t * label, lv_label_style_t type)
{
    (void)type; /*Unused*/
    return lv_obj_get_style(label);
   1d54a:	4620      	mov	r0, r4
   1d54c:	f7fd fcde 	bl	1af0c <lv_obj_get_style>
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.right);
   1d550:	f9b0 3024 	ldrsh.w	r3, [r0, #36]	; 0x24
   1d554:	f9b0 2026 	ldrsh.w	r2, [r0, #38]	; 0x26
   1d558:	4293      	cmp	r3, r2
   1d55a:	bfb8      	it	lt
   1d55c:	4613      	movlt	r3, r2
   1d55e:	f9b4 2030 	ldrsh.w	r2, [r4, #48]	; 0x30
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.top);
   1d562:	4293      	cmp	r3, r2
   1d564:	bfb8      	it	lt
   1d566:	4613      	movlt	r3, r2
   1d568:	f9b0 2020 	ldrsh.w	r2, [r0, #32]
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.bottom);
   1d56c:	4293      	cmp	r3, r2
   1d56e:	bfb8      	it	lt
   1d570:	4613      	movlt	r3, r2
   1d572:	f9b0 2022 	ldrsh.w	r2, [r0, #34]	; 0x22
   1d576:	4293      	cmp	r3, r2
   1d578:	bfb8      	it	lt
   1d57a:	4613      	movlt	r3, r2
   1d57c:	8623      	strh	r3, [r4, #48]	; 0x30
   1d57e:	462e      	mov	r6, r5
   1d580:	e7ba      	b.n	1d4f8 <lv_label_signal+0x48>
   1d582:	bf00      	nop
   1d584:	20001f00 	.word	0x20001f00
   1d588:	00065bb0 	.word	0x00065bb0

0001d58c <lv_label_create>:
{
   1d58c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d590:	460e      	mov	r6, r1
    lv_obj_t * new_label = lv_obj_create(par, copy);
   1d592:	f7fd fb9d 	bl	1acd0 <lv_obj_create>
    if(new_label == NULL) return NULL;
   1d596:	4604      	mov	r4, r0
   1d598:	b918      	cbnz	r0, 1d5a2 <lv_label_create+0x16>
   1d59a:	2400      	movs	r4, #0
}
   1d59c:	4620      	mov	r0, r4
   1d59e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_label);
   1d5a2:	4d51      	ldr	r5, [pc, #324]	; (1d6e8 <lv_label_create+0x15c>)
   1d5a4:	682b      	ldr	r3, [r5, #0]
   1d5a6:	b913      	cbnz	r3, 1d5ae <lv_label_create+0x22>
   1d5a8:	f008 fa9e 	bl	25ae8 <lv_obj_get_signal_cb>
   1d5ac:	6028      	str	r0, [r5, #0]
    lv_obj_allocate_ext_attr(new_label, sizeof(lv_label_ext_t));
   1d5ae:	2110      	movs	r1, #16
   1d5b0:	4620      	mov	r0, r4
   1d5b2:	f007 ffd3 	bl	2555c <lv_obj_allocate_ext_attr>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(new_label);
   1d5b6:	4620      	mov	r0, r4
   1d5b8:	f008 fa98 	bl	25aec <lv_obj_get_ext_attr>
    if(ext == NULL) return NULL;
   1d5bc:	4605      	mov	r5, r0
   1d5be:	2800      	cmp	r0, #0
   1d5c0:	d0eb      	beq.n	1d59a <lv_label_create+0xe>
    ext->text       = NULL;
   1d5c2:	2300      	movs	r3, #0
    ext->dot.tmp_ptr   = NULL;
   1d5c4:	e9c0 3300 	strd	r3, r3, [r0]
    ext->dot_end    = LV_LABEL_DOT_END_INV;
   1d5c8:	f64f 73ff 	movw	r3, #65535	; 0xffff
    ext->offset.y = 0;
   1d5cc:	68c2      	ldr	r2, [r0, #12]
    ext->dot_end    = LV_LABEL_DOT_END_INV;
   1d5ce:	6083      	str	r3, [r0, #8]
    ext->offset.y = 0;
   1d5d0:	4b46      	ldr	r3, [pc, #280]	; (1d6ec <lv_label_create+0x160>)
    lv_obj_set_design_cb(new_label, lv_label_design);
   1d5d2:	4947      	ldr	r1, [pc, #284]	; (1d6f0 <lv_label_create+0x164>)
    ext->offset.y = 0;
   1d5d4:	4013      	ands	r3, r2
   1d5d6:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
   1d5da:	60c3      	str	r3, [r0, #12]
    lv_obj_set_design_cb(new_label, lv_label_design);
   1d5dc:	4620      	mov	r0, r4
   1d5de:	f007 ffbb 	bl	25558 <lv_obj_set_design_cb>
    lv_obj_set_signal_cb(new_label, lv_label_signal);
   1d5e2:	4944      	ldr	r1, [pc, #272]	; (1d6f4 <lv_label_create+0x168>)
   1d5e4:	4620      	mov	r0, r4
   1d5e6:	f007 ffb5 	bl	25554 <lv_obj_set_signal_cb>
    if(copy == NULL) {
   1d5ea:	b9b6      	cbnz	r6, 1d61a <lv_label_create+0x8e>
        lv_obj_set_click(new_label, false);
   1d5ec:	4631      	mov	r1, r6
   1d5ee:	4620      	mov	r0, r4
   1d5f0:	f007 ffa9 	bl	25546 <lv_obj_set_click>
        lv_label_set_long_mode(new_label, LV_LABEL_LONG_EXPAND);
   1d5f4:	4631      	mov	r1, r6
   1d5f6:	4620      	mov	r0, r4
   1d5f8:	f00a f965 	bl	278c6 <lv_label_set_long_mode>
        lv_label_set_text(new_label, "Text");
   1d5fc:	493e      	ldr	r1, [pc, #248]	; (1d6f8 <lv_label_create+0x16c>)
   1d5fe:	4620      	mov	r0, r4
   1d600:	f00a f90c 	bl	2781c <lv_label_set_text>
    lv_obj_set_style(label, style);
   1d604:	4631      	mov	r1, r6
   1d606:	4620      	mov	r0, r4
   1d608:	f008 f8c4 	bl	25794 <lv_obj_set_style>
    LV_LOG_INFO("label created");
   1d60c:	4b3b      	ldr	r3, [pc, #236]	; (1d6fc <lv_label_create+0x170>)
   1d60e:	493c      	ldr	r1, [pc, #240]	; (1d700 <lv_label_create+0x174>)
   1d610:	22a1      	movs	r2, #161	; 0xa1
   1d612:	2001      	movs	r0, #1
   1d614:	f7ff fd20 	bl	1d058 <lv_log_add>
    return new_label;
   1d618:	e7c0      	b.n	1d59c <lv_label_create+0x10>
        lv_label_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
   1d61a:	4630      	mov	r0, r6
   1d61c:	f008 fa66 	bl	25aec <lv_obj_get_ext_attr>
   1d620:	4607      	mov	r7, r0
        lv_label_set_long_mode(new_label, lv_label_get_long_mode(copy));
   1d622:	4630      	mov	r0, r6
   1d624:	f009 ffcd 	bl	275c2 <lv_label_get_long_mode>
   1d628:	4601      	mov	r1, r0
   1d62a:	4620      	mov	r0, r4
   1d62c:	f00a f94b 	bl	278c6 <lv_label_set_long_mode>
        lv_label_set_recolor(new_label, lv_label_get_recolor(copy));
   1d630:	4630      	mov	r0, r6
   1d632:	f00a f8e5 	bl	27800 <lv_label_get_recolor>
   1d636:	4601      	mov	r1, r0
   1d638:	4620      	mov	r0, r4
   1d63a:	f00a f96b 	bl	27914 <lv_label_set_recolor>
        lv_label_set_body_draw(new_label, lv_label_get_body_draw(copy));
   1d63e:	4630      	mov	r0, r6
   1d640:	f00a f8e5 	bl	2780e <lv_label_get_body_draw>
   1d644:	4601      	mov	r1, r0
   1d646:	4620      	mov	r0, r4
   1d648:	f009 ffa0 	bl	2758c <lv_label_set_body_draw>
        lv_label_set_align(new_label, lv_label_get_align(copy));
   1d64c:	4630      	mov	r0, r6
   1d64e:	f009 ffbf 	bl	275d0 <lv_label_get_align>
   1d652:	4601      	mov	r1, r0
   1d654:	4620      	mov	r0, r4
   1d656:	f009 ff86 	bl	27566 <lv_label_set_align>
        if(copy_ext->static_txt == 0)
   1d65a:	7bbb      	ldrb	r3, [r7, #14]
   1d65c:	071a      	lsls	r2, r3, #28
            lv_label_set_text(new_label, lv_label_get_text(copy));
   1d65e:	4630      	mov	r0, r6
        if(copy_ext->static_txt == 0)
   1d660:	d439      	bmi.n	1d6d6 <lv_label_create+0x14a>
            lv_label_set_text(new_label, lv_label_get_text(copy));
   1d662:	f009 ffa9 	bl	275b8 <lv_label_get_text>
   1d666:	4601      	mov	r1, r0
   1d668:	4620      	mov	r0, r4
   1d66a:	f00a f8d7 	bl	2781c <lv_label_set_text>
        if(copy_ext->long_mode == LV_LABEL_LONG_DOT) {
   1d66e:	7bbb      	ldrb	r3, [r7, #14]
   1d670:	f003 0307 	and.w	r3, r3, #7
   1d674:	2b02      	cmp	r3, #2
   1d676:	d115      	bne.n	1d6a4 <lv_label_create+0x118>
            ext->text = lv_mem_realloc(ext->text, lv_mem_get_size(copy_ext->text));
   1d678:	6838      	ldr	r0, [r7, #0]
   1d67a:	682e      	ldr	r6, [r5, #0]
   1d67c:	f7ff fb60 	bl	1cd40 <lv_mem_get_size>
   1d680:	4601      	mov	r1, r0
   1d682:	4630      	mov	r0, r6
   1d684:	f7ff fb6a 	bl	1cd5c <lv_mem_realloc>
   1d688:	4606      	mov	r6, r0
   1d68a:	6028      	str	r0, [r5, #0]
            if(ext->text == NULL) return NULL;
   1d68c:	2800      	cmp	r0, #0
   1d68e:	d084      	beq.n	1d59a <lv_label_create+0xe>
            memcpy(ext->text, copy_ext->text, lv_mem_get_size(copy_ext->text));
   1d690:	f8d7 8000 	ldr.w	r8, [r7]
   1d694:	4640      	mov	r0, r8
   1d696:	f7ff fb53 	bl	1cd40 <lv_mem_get_size>
   1d69a:	4641      	mov	r1, r8
   1d69c:	4602      	mov	r2, r0
   1d69e:	4630      	mov	r0, r6
   1d6a0:	f7e4 faa4 	bl	1bec <memcpy>
        if(copy_ext->dot_tmp_alloc && copy_ext->dot.tmp_ptr) {
   1d6a4:	7bfb      	ldrb	r3, [r7, #15]
   1d6a6:	6878      	ldr	r0, [r7, #4]
   1d6a8:	079b      	lsls	r3, r3, #30
   1d6aa:	d51b      	bpl.n	1d6e4 <lv_label_create+0x158>
   1d6ac:	b1d0      	cbz	r0, 1d6e4 <lv_label_create+0x158>
            uint16_t len = (uint16_t    )strlen(copy_ext->dot.tmp_ptr);
   1d6ae:	f7e4 fafb 	bl	1ca8 <strlen>
            lv_label_set_dot_tmp(new_label, ext->dot.tmp_ptr, len);
   1d6b2:	6869      	ldr	r1, [r5, #4]
   1d6b4:	b282      	uxth	r2, r0
   1d6b6:	4620      	mov	r0, r4
   1d6b8:	f7ff fd16 	bl	1d0e8 <lv_label_set_dot_tmp>
        ext->dot_tmp_alloc = copy_ext->dot_tmp_alloc;
   1d6bc:	7bfb      	ldrb	r3, [r7, #15]
   1d6be:	7bea      	ldrb	r2, [r5, #15]
   1d6c0:	f3c3 0340 	ubfx	r3, r3, #1, #1
   1d6c4:	f363 0241 	bfi	r2, r3, #1, #1
   1d6c8:	73ea      	strb	r2, [r5, #15]
        ext->dot_end       = copy_ext->dot_end;
   1d6ca:	893b      	ldrh	r3, [r7, #8]
   1d6cc:	812b      	strh	r3, [r5, #8]
        lv_obj_refresh_style(new_label);
   1d6ce:	4620      	mov	r0, r4
   1d6d0:	f007 ffd1 	bl	25676 <lv_obj_refresh_style>
   1d6d4:	e79a      	b.n	1d60c <lv_label_create+0x80>
            lv_label_set_static_text(new_label, lv_label_get_text(copy));
   1d6d6:	f009 ff6f 	bl	275b8 <lv_label_get_text>
   1d6da:	4601      	mov	r1, r0
   1d6dc:	4620      	mov	r0, r4
   1d6de:	f00a f8d8 	bl	27892 <lv_label_set_static_text>
   1d6e2:	e7c4      	b.n	1d66e <lv_label_create+0xe2>
   1d6e4:	6068      	str	r0, [r5, #4]
   1d6e6:	e7e9      	b.n	1d6bc <lv_label_create+0x130>
   1d6e8:	20001f00 	.word	0x20001f00
   1d6ec:	fc800000 	.word	0xfc800000
   1d6f0:	000275e5 	.word	0x000275e5
   1d6f4:	0001d4b1 	.word	0x0001d4b1
   1d6f8:	00065b3c 	.word	0x00065b3c
   1d6fc:	00065b41 	.word	0x00065b41
   1d700:	00065b79 	.word	0x00065b79

0001d704 <lv_img_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return true/false, depends on 'mode'
 */
static bool lv_img_design(lv_obj_t * img, const lv_area_t * mask, lv_design_mode_t mode)
{
   1d704:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1d708:	b09d      	sub	sp, #116	; 0x74
   1d70a:	4690      	mov	r8, r2
   1d70c:	4681      	mov	r9, r0
   1d70e:	460d      	mov	r5, r1
    const lv_style_t * style = lv_obj_get_style(img);
   1d710:	f7fd fbfc 	bl	1af0c <lv_obj_get_style>
   1d714:	4606      	mov	r6, r0
    lv_img_ext_t * ext       = lv_obj_get_ext_attr(img);
   1d716:	4648      	mov	r0, r9
   1d718:	f008 f9e8 	bl	25aec <lv_obj_get_ext_attr>

    if(mode == LV_DESIGN_COVER_CHK) {
   1d71c:	f1b8 0f02 	cmp.w	r8, #2
    lv_img_ext_t * ext       = lv_obj_get_ext_attr(img);
   1d720:	4604      	mov	r4, r0
    if(mode == LV_DESIGN_COVER_CHK) {
   1d722:	d112      	bne.n	1d74a <lv_img_design+0x46>
        bool cover = false;
        if(ext->src_type == LV_IMG_SRC_UNKNOWN || ext->src_type == LV_IMG_SRC_SYMBOL) return false;
   1d724:	7b03      	ldrb	r3, [r0, #12]
   1d726:	f013 0002 	ands.w	r0, r3, #2
   1d72a:	f040 8093 	bne.w	1d854 <lv_img_design+0x150>

        if(ext->cf == LV_IMG_CF_TRUE_COLOR || ext->cf == LV_IMG_CF_RAW) cover = lv_area_is_in(mask, &img->coords);
   1d72e:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
   1d732:	2b20      	cmp	r3, #32
   1d734:	d001      	beq.n	1d73a <lv_img_design+0x36>
   1d736:	2b08      	cmp	r3, #8
   1d738:	d104      	bne.n	1d744 <lv_img_design+0x40>
   1d73a:	f109 0110 	add.w	r1, r9, #16
   1d73e:	4628      	mov	r0, r5
   1d740:	f009 fd2c 	bl	2719c <lv_area_is_in>
            lv_draw_img(&img->coords, mask, NULL, style, opa_scale);
        }
    }

    return true;
}
   1d744:	b01d      	add	sp, #116	; 0x74
   1d746:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    } else if(mode == LV_DESIGN_DRAW_MAIN) {
   1d74a:	f1b8 0f00 	cmp.w	r8, #0
   1d74e:	d105      	bne.n	1d75c <lv_img_design+0x58>
        if(ext->h == 0 || ext->w == 0) return true;
   1d750:	f9b0 300a 	ldrsh.w	r3, [r0, #10]
   1d754:	b113      	cbz	r3, 1d75c <lv_img_design+0x58>
   1d756:	f9b0 3008 	ldrsh.w	r3, [r0, #8]
   1d75a:	b90b      	cbnz	r3, 1d760 <lv_img_design+0x5c>
    return true;
   1d75c:	2001      	movs	r0, #1
   1d75e:	e7f1      	b.n	1d744 <lv_img_design+0x40>
        lv_opa_t opa_scale = lv_obj_get_opa_scale(img);
   1d760:	4648      	mov	r0, r9
   1d762:	f008 f965 	bl	25a30 <lv_obj_get_opa_scale>
        lv_obj_get_coords(img, &coords);
   1d766:	a906      	add	r1, sp, #24
        lv_opa_t opa_scale = lv_obj_get_opa_scale(img);
   1d768:	4607      	mov	r7, r0
        lv_obj_get_coords(img, &coords);
   1d76a:	4648      	mov	r0, r9
   1d76c:	f008 f81c 	bl	257a8 <lv_obj_get_coords>
        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_VARIABLE) {
   1d770:	7b23      	ldrb	r3, [r4, #12]
   1d772:	079a      	lsls	r2, r3, #30
   1d774:	d443      	bmi.n	1d7fe <lv_img_design+0xfa>
            coords.x1 -= ext->offset.x;
   1d776:	88a2      	ldrh	r2, [r4, #4]
   1d778:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   1d77c:	1a9b      	subs	r3, r3, r2
   1d77e:	f8ad 3018 	strh.w	r3, [sp, #24]
            coords.y1 -= ext->offset.y;
   1d782:	88e2      	ldrh	r2, [r4, #6]
   1d784:	f8bd 301a 	ldrh.w	r3, [sp, #26]
   1d788:	1a9b      	subs	r3, r3, r2
            cords_tmp.y2 = coords.y1 + ext->h - 1;
   1d78a:	8962      	ldrh	r2, [r4, #10]
            coords.y1 -= ext->offset.y;
   1d78c:	b21b      	sxth	r3, r3
   1d78e:	f8ad 301a 	strh.w	r3, [sp, #26]
            cords_tmp.y1 = coords.y1;
   1d792:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
            cords_tmp.y2 = coords.y1 + ext->h - 1;
   1d796:	3a01      	subs	r2, #1
            for(; cords_tmp.y1 <= coords.y2; cords_tmp.y1 += ext->h, cords_tmp.y2 += ext->h) {
   1d798:	4413      	add	r3, r2
   1d79a:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
   1d79e:	f9bd 2022 	ldrsh.w	r2, [sp, #34]	; 0x22
   1d7a2:	f9bd 301e 	ldrsh.w	r3, [sp, #30]
   1d7a6:	429a      	cmp	r2, r3
   1d7a8:	dcd8      	bgt.n	1d75c <lv_img_design+0x58>
                cords_tmp.x1 = coords.x1;
   1d7aa:	f9bd 3018 	ldrsh.w	r3, [sp, #24]
                cords_tmp.x2 = coords.x1 + ext->w - 1;
   1d7ae:	8922      	ldrh	r2, [r4, #8]
                cords_tmp.x1 = coords.x1;
   1d7b0:	f8ad 3020 	strh.w	r3, [sp, #32]
                cords_tmp.x2 = coords.x1 + ext->w - 1;
   1d7b4:	3b01      	subs	r3, #1
                for(; cords_tmp.x1 <= coords.x2; cords_tmp.x1 += ext->w, cords_tmp.x2 += ext->w) {
   1d7b6:	4413      	add	r3, r2
   1d7b8:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
   1d7bc:	f9bd 2020 	ldrsh.w	r2, [sp, #32]
   1d7c0:	f9bd 301c 	ldrsh.w	r3, [sp, #28]
   1d7c4:	429a      	cmp	r2, r3
   1d7c6:	dd09      	ble.n	1d7dc <lv_img_design+0xd8>
            for(; cords_tmp.y1 <= coords.y2; cords_tmp.y1 += ext->h, cords_tmp.y2 += ext->h) {
   1d7c8:	f9b4 300a 	ldrsh.w	r3, [r4, #10]
   1d7cc:	f8bd 2022 	ldrh.w	r2, [sp, #34]	; 0x22
   1d7d0:	441a      	add	r2, r3
   1d7d2:	f8ad 2022 	strh.w	r2, [sp, #34]	; 0x22
   1d7d6:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
   1d7da:	e7dd      	b.n	1d798 <lv_img_design+0x94>
                    lv_draw_img(&cords_tmp, mask, ext->src, style, opa_scale);
   1d7dc:	9700      	str	r7, [sp, #0]
   1d7de:	4633      	mov	r3, r6
   1d7e0:	6822      	ldr	r2, [r4, #0]
   1d7e2:	4629      	mov	r1, r5
   1d7e4:	a808      	add	r0, sp, #32
   1d7e6:	f7fe fbfb 	bl	1bfe0 <lv_draw_img>
                for(; cords_tmp.x1 <= coords.x2; cords_tmp.x1 += ext->w, cords_tmp.x2 += ext->w) {
   1d7ea:	f9b4 3008 	ldrsh.w	r3, [r4, #8]
   1d7ee:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   1d7f2:	441a      	add	r2, r3
   1d7f4:	f8ad 2020 	strh.w	r2, [sp, #32]
   1d7f8:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
   1d7fc:	e7db      	b.n	1d7b6 <lv_img_design+0xb2>
        } else if(ext->src_type == LV_IMG_SRC_SYMBOL) {
   1d7fe:	f003 0303 	and.w	r3, r3, #3
   1d802:	2b02      	cmp	r3, #2
   1d804:	d116      	bne.n	1d834 <lv_img_design+0x130>
            lv_style_copy(&style_mod, style);
   1d806:	4631      	mov	r1, r6
   1d808:	a808      	add	r0, sp, #32
   1d80a:	f008 fa7a 	bl	25d02 <lv_style_copy>
            style_mod.text.color = style->image.color;
   1d80e:	6c33      	ldr	r3, [r6, #64]	; 0x40
   1d810:	9313      	str	r3, [sp, #76]	; 0x4c
            lv_draw_label(&coords, mask, &style_mod, opa_scale, ext->src, LV_TXT_FLAG_NONE, NULL, NULL, NULL, lv_obj_get_base_dir(img));
   1d812:	4648      	mov	r0, r9
   1d814:	6824      	ldr	r4, [r4, #0]
   1d816:	f008 f909 	bl	25a2c <lv_obj_get_base_dir>
   1d81a:	e9cd 8802 	strd	r8, r8, [sp, #8]
   1d81e:	e9cd 8004 	strd	r8, r0, [sp, #16]
   1d822:	e9cd 4800 	strd	r4, r8, [sp]
   1d826:	463b      	mov	r3, r7
   1d828:	aa08      	add	r2, sp, #32
   1d82a:	4629      	mov	r1, r5
   1d82c:	a806      	add	r0, sp, #24
   1d82e:	f7fe f989 	bl	1bb44 <lv_draw_label>
   1d832:	e793      	b.n	1d75c <lv_img_design+0x58>
            LV_LOG_WARN("lv_img_design: image source type is unknown");
   1d834:	4b08      	ldr	r3, [pc, #32]	; (1d858 <lv_img_design+0x154>)
   1d836:	4909      	ldr	r1, [pc, #36]	; (1d85c <lv_img_design+0x158>)
   1d838:	f44f 72c3 	mov.w	r2, #390	; 0x186
   1d83c:	2002      	movs	r0, #2
   1d83e:	f7ff fc0b 	bl	1d058 <lv_log_add>
            lv_draw_img(&img->coords, mask, NULL, style, opa_scale);
   1d842:	9700      	str	r7, [sp, #0]
   1d844:	4633      	mov	r3, r6
   1d846:	4642      	mov	r2, r8
   1d848:	4629      	mov	r1, r5
   1d84a:	f109 0010 	add.w	r0, r9, #16
   1d84e:	f7fe fbc7 	bl	1bfe0 <lv_draw_img>
   1d852:	e783      	b.n	1d75c <lv_img_design+0x58>
        if(ext->src_type == LV_IMG_SRC_UNKNOWN || ext->src_type == LV_IMG_SRC_SYMBOL) return false;
   1d854:	2000      	movs	r0, #0
   1d856:	e775      	b.n	1d744 <lv_img_design+0x40>
   1d858:	00065bc7 	.word	0x00065bc7
   1d85c:	00065bf3 	.word	0x00065bf3

0001d860 <lv_img_set_src>:
{
   1d860:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1d864:	4607      	mov	r7, r0
   1d866:	b087      	sub	sp, #28
    lv_img_src_t src_type = lv_img_src_get_type(src_img);
   1d868:	4608      	mov	r0, r1
{
   1d86a:	460d      	mov	r5, r1
    lv_img_src_t src_type = lv_img_src_get_type(src_img);
   1d86c:	f009 fb64 	bl	26f38 <lv_img_src_get_type>
   1d870:	4606      	mov	r6, r0
    lv_img_ext_t * ext    = lv_obj_get_ext_attr(img);
   1d872:	4638      	mov	r0, r7
   1d874:	f008 f93a 	bl	25aec <lv_obj_get_ext_attr>
    switch(src_type) {
   1d878:	2e02      	cmp	r6, #2
    lv_img_ext_t * ext    = lv_obj_get_ext_attr(img);
   1d87a:	4604      	mov	r4, r0
    switch(src_type) {
   1d87c:	d91f      	bls.n	1d8be <lv_img_set_src+0x5e>
        default: LV_LOG_WARN("lv_img_set_src: unknown type");
   1d87e:	4b4f      	ldr	r3, [pc, #316]	; (1d9bc <lv_img_set_src+0x15c>)
   1d880:	494f      	ldr	r1, [pc, #316]	; (1d9c0 <lv_img_set_src+0x160>)
   1d882:	2288      	movs	r2, #136	; 0x88
   1d884:	2002      	movs	r0, #2
   1d886:	f7ff fbe7 	bl	1d058 <lv_log_add>
    if(src_type == LV_IMG_SRC_UNKNOWN) {
   1d88a:	2e03      	cmp	r6, #3
   1d88c:	d117      	bne.n	1d8be <lv_img_set_src+0x5e>
        LV_LOG_WARN("lv_img_set_src: unknown image type");
   1d88e:	4b4d      	ldr	r3, [pc, #308]	; (1d9c4 <lv_img_set_src+0x164>)
   1d890:	494b      	ldr	r1, [pc, #300]	; (1d9c0 <lv_img_set_src+0x160>)
   1d892:	228e      	movs	r2, #142	; 0x8e
   1d894:	2002      	movs	r0, #2
   1d896:	f7ff fbdf 	bl	1d058 <lv_log_add>
        if(ext->src_type == LV_IMG_SRC_SYMBOL || ext->src_type == LV_IMG_SRC_FILE) {
   1d89a:	7b23      	ldrb	r3, [r4, #12]
   1d89c:	f003 0303 	and.w	r3, r3, #3
   1d8a0:	3b01      	subs	r3, #1
   1d8a2:	2b01      	cmp	r3, #1
   1d8a4:	d802      	bhi.n	1d8ac <lv_img_set_src+0x4c>
            lv_mem_free(ext->src);
   1d8a6:	6820      	ldr	r0, [r4, #0]
   1d8a8:	f7ff fa3a 	bl	1cd20 <lv_mem_free>
        ext->src      = NULL;
   1d8ac:	2300      	movs	r3, #0
   1d8ae:	6023      	str	r3, [r4, #0]
        ext->src_type = LV_IMG_SRC_UNKNOWN;
   1d8b0:	7b23      	ldrb	r3, [r4, #12]
   1d8b2:	f043 0303 	orr.w	r3, r3, #3
   1d8b6:	7323      	strb	r3, [r4, #12]
}
   1d8b8:	b007      	add	sp, #28
   1d8ba:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    lv_img_decoder_get_info(src_img, &header);
   1d8be:	a904      	add	r1, sp, #16
   1d8c0:	4628      	mov	r0, r5
   1d8c2:	f7fe fe95 	bl	1c5f0 <lv_img_decoder_get_info>
    if(src_type == LV_IMG_SRC_VARIABLE) {
   1d8c6:	bb8e      	cbnz	r6, 1d92c <lv_img_set_src+0xcc>
        LV_LOG_INFO("lv_img_set_src:  `LV_IMG_SRC_VARIABLE` type found");
   1d8c8:	4b3f      	ldr	r3, [pc, #252]	; (1d9c8 <lv_img_set_src+0x168>)
   1d8ca:	493d      	ldr	r1, [pc, #244]	; (1d9c0 <lv_img_set_src+0x160>)
   1d8cc:	229c      	movs	r2, #156	; 0x9c
   1d8ce:	2001      	movs	r0, #1
   1d8d0:	f7ff fbc2 	bl	1d058 <lv_log_add>
        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
   1d8d4:	7b23      	ldrb	r3, [r4, #12]
   1d8d6:	f003 0303 	and.w	r3, r3, #3
   1d8da:	3b01      	subs	r3, #1
   1d8dc:	2b01      	cmp	r3, #1
   1d8de:	d802      	bhi.n	1d8e6 <lv_img_set_src+0x86>
            lv_mem_free(ext->src);
   1d8e0:	6820      	ldr	r0, [r4, #0]
   1d8e2:	f7ff fa1d 	bl	1cd20 <lv_mem_free>
        ext->src = src_img;
   1d8e6:	6025      	str	r5, [r4, #0]
    ext->w        = header.w;
   1d8e8:	9a04      	ldr	r2, [sp, #16]
    ext->src_type = src_type;
   1d8ea:	7b23      	ldrb	r3, [r4, #12]
    ext->w        = header.w;
   1d8ec:	f3c2 228a 	ubfx	r2, r2, #10, #11
   1d8f0:	8122      	strh	r2, [r4, #8]
    ext->h        = header.h;
   1d8f2:	f8bd 2012 	ldrh.w	r2, [sp, #18]
   1d8f6:	f3c2 124a 	ubfx	r2, r2, #5, #11
   1d8fa:	8162      	strh	r2, [r4, #10]
    ext->cf       = header.cf;
   1d8fc:	f89d 2010 	ldrb.w	r2, [sp, #16]
    ext->src_type = src_type;
   1d900:	f366 0301 	bfi	r3, r6, #0, #2
    ext->cf       = header.cf;
   1d904:	f3c2 0204 	ubfx	r2, r2, #0, #5
   1d908:	f362 03c7 	bfi	r3, r2, #3, #5
   1d90c:	7323      	strb	r3, [r4, #12]
    if(lv_img_get_auto_size(img) != false) {
   1d90e:	4638      	mov	r0, r7
   1d910:	f00a f813 	bl	2793a <lv_img_get_auto_size>
   1d914:	b130      	cbz	r0, 1d924 <lv_img_set_src+0xc4>
        lv_obj_set_size(img, ext->w, ext->h);
   1d916:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
   1d91a:	f9b4 1008 	ldrsh.w	r1, [r4, #8]
   1d91e:	4638      	mov	r0, r7
   1d920:	f007 fec3 	bl	256aa <lv_obj_set_size>
    lv_obj_invalidate(img);
   1d924:	4638      	mov	r0, r7
   1d926:	f007 fe20 	bl	2556a <lv_obj_invalidate>
   1d92a:	e7c5      	b.n	1d8b8 <lv_img_set_src+0x58>
    } else if(src_type == LV_IMG_SRC_FILE || src_type == LV_IMG_SRC_SYMBOL) {
   1d92c:	1e73      	subs	r3, r6, #1
   1d92e:	b2db      	uxtb	r3, r3
   1d930:	2b01      	cmp	r3, #1
   1d932:	d81f      	bhi.n	1d974 <lv_img_set_src+0x114>
        if(ext->src != src_img) {
   1d934:	f8d4 8000 	ldr.w	r8, [r4]
   1d938:	45a8      	cmp	r8, r5
   1d93a:	d01b      	beq.n	1d974 <lv_img_set_src+0x114>
            if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
   1d93c:	7b23      	ldrb	r3, [r4, #12]
   1d93e:	f003 0303 	and.w	r3, r3, #3
   1d942:	3b01      	subs	r3, #1
            const void * old_src = NULL;
   1d944:	2b01      	cmp	r3, #1
            char * new_str = lv_mem_alloc(strlen(src_img) + 1);
   1d946:	4628      	mov	r0, r5
            const void * old_src = NULL;
   1d948:	bf88      	it	hi
   1d94a:	f04f 0800 	movhi.w	r8, #0
            char * new_str = lv_mem_alloc(strlen(src_img) + 1);
   1d94e:	f7e4 f9ab 	bl	1ca8 <strlen>
   1d952:	3001      	adds	r0, #1
   1d954:	f7ff f9be 	bl	1ccd4 <lv_mem_alloc>
            if(new_str == NULL) return;
   1d958:	4681      	mov	r9, r0
   1d95a:	2800      	cmp	r0, #0
   1d95c:	d0ac      	beq.n	1d8b8 <lv_img_set_src+0x58>
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
   1d95e:	4629      	mov	r1, r5
   1d960:	f7e4 f99a 	bl	1c98 <strcpy>
            ext->src = new_str;
   1d964:	f8c4 9000 	str.w	r9, [r4]
            if(old_src) lv_mem_free(old_src);
   1d968:	f1b8 0f00 	cmp.w	r8, #0
   1d96c:	d002      	beq.n	1d974 <lv_img_set_src+0x114>
   1d96e:	4640      	mov	r0, r8
   1d970:	f7ff f9d6 	bl	1cd20 <lv_mem_free>
    if(src_type == LV_IMG_SRC_SYMBOL) {
   1d974:	2e02      	cmp	r6, #2
   1d976:	d1b7      	bne.n	1d8e8 <lv_img_set_src+0x88>
 * @return pointer to the image's style
 */
static inline const lv_style_t * lv_img_get_style(const lv_obj_t * img, lv_img_style_t type)
{
    (void)type; /*Unused*/
    return lv_obj_get_style(img);
   1d978:	4638      	mov	r0, r7
   1d97a:	f7fd fac7 	bl	1af0c <lv_obj_get_style>
        lv_txt_get_size(&size, src_img, style->text.font, style->text.letter_space, style->text.line_space,
   1d97e:	f647 4218 	movw	r2, #31768	; 0x7c18
   1d982:	2100      	movs	r1, #0
   1d984:	f9b0 3038 	ldrsh.w	r3, [r0, #56]	; 0x38
   1d988:	e9cd 2101 	strd	r2, r1, [sp, #4]
   1d98c:	f9b0 203a 	ldrsh.w	r2, [r0, #58]	; 0x3a
   1d990:	9200      	str	r2, [sp, #0]
   1d992:	6b42      	ldr	r2, [r0, #52]	; 0x34
   1d994:	4629      	mov	r1, r5
   1d996:	a805      	add	r0, sp, #20
   1d998:	f009 fd60 	bl	2745c <lv_txt_get_size>
        header.w = size.x;
   1d99c:	9b04      	ldr	r3, [sp, #16]
   1d99e:	f8bd 2014 	ldrh.w	r2, [sp, #20]
   1d9a2:	f362 2394 	bfi	r3, r2, #10, #11
        header.h = size.y;
   1d9a6:	f8bd 2016 	ldrh.w	r2, [sp, #22]
        header.w = size.x;
   1d9aa:	9304      	str	r3, [sp, #16]
        header.h = size.y;
   1d9ac:	f3c3 430f 	ubfx	r3, r3, #16, #16
   1d9b0:	f362 134f 	bfi	r3, r2, #5, #11
   1d9b4:	f8ad 3012 	strh.w	r3, [sp, #18]
   1d9b8:	e796      	b.n	1d8e8 <lv_img_set_src+0x88>
   1d9ba:	bf00      	nop
   1d9bc:	00065c28 	.word	0x00065c28
   1d9c0:	00065bf3 	.word	0x00065bf3
   1d9c4:	00065c45 	.word	0x00065c45
   1d9c8:	00065c68 	.word	0x00065c68

0001d9cc <lv_img_create>:
{
   1d9cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d9d0:	4607      	mov	r7, r0
   1d9d2:	460e      	mov	r6, r1
    new_img = lv_obj_create(par, copy);
   1d9d4:	f7fd f97c 	bl	1acd0 <lv_obj_create>
    if(new_img == NULL) return NULL;
   1d9d8:	4605      	mov	r5, r0
   1d9da:	b918      	cbnz	r0, 1d9e4 <lv_img_create+0x18>
   1d9dc:	2500      	movs	r5, #0
}
   1d9de:	4628      	mov	r0, r5
   1d9e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_img);
   1d9e4:	4c2c      	ldr	r4, [pc, #176]	; (1da98 <lv_img_create+0xcc>)
   1d9e6:	6823      	ldr	r3, [r4, #0]
   1d9e8:	b913      	cbnz	r3, 1d9f0 <lv_img_create+0x24>
   1d9ea:	f008 f87d 	bl	25ae8 <lv_obj_get_signal_cb>
   1d9ee:	6020      	str	r0, [r4, #0]
    lv_img_ext_t * ext = lv_obj_allocate_ext_attr(new_img, sizeof(lv_img_ext_t));
   1d9f0:	2110      	movs	r1, #16
   1d9f2:	4628      	mov	r0, r5
   1d9f4:	f007 fdb2 	bl	2555c <lv_obj_allocate_ext_attr>
    if(ext == NULL) return NULL;
   1d9f8:	4604      	mov	r4, r0
   1d9fa:	2800      	cmp	r0, #0
   1d9fc:	d0ee      	beq.n	1d9dc <lv_img_create+0x10>
    ext->src_type  = LV_IMG_SRC_UNKNOWN;
   1d9fe:	7b03      	ldrb	r3, [r0, #12]
   1da00:	f003 0304 	and.w	r3, r3, #4
   1da04:	f043 0303 	orr.w	r3, r3, #3
    ext->src       = NULL;
   1da08:	f04f 0800 	mov.w	r8, #0
    ext->src_type  = LV_IMG_SRC_UNKNOWN;
   1da0c:	7303      	strb	r3, [r0, #12]
    ext->src       = NULL;
   1da0e:	f8c0 8000 	str.w	r8, [r0]
    ext->w         = lv_obj_get_width(new_img);
   1da12:	4628      	mov	r0, r5
   1da14:	f007 fffe 	bl	25a14 <lv_obj_get_width>
   1da18:	8120      	strh	r0, [r4, #8]
    ext->h         = lv_obj_get_height(new_img);
   1da1a:	4628      	mov	r0, r5
   1da1c:	f008 f800 	bl	25a20 <lv_obj_get_height>
    ext->auto_size = 1;
   1da20:	7b23      	ldrb	r3, [r4, #12]
    ext->h         = lv_obj_get_height(new_img);
   1da22:	8160      	strh	r0, [r4, #10]
    ext->auto_size = 1;
   1da24:	f043 0304 	orr.w	r3, r3, #4
    lv_obj_set_signal_cb(new_img, lv_img_signal);
   1da28:	491c      	ldr	r1, [pc, #112]	; (1da9c <lv_img_create+0xd0>)
    ext->auto_size = 1;
   1da2a:	7323      	strb	r3, [r4, #12]
    lv_obj_set_signal_cb(new_img, lv_img_signal);
   1da2c:	4628      	mov	r0, r5
    ext->offset.x  = 0;
   1da2e:	f8c4 8004 	str.w	r8, [r4, #4]
    lv_obj_set_signal_cb(new_img, lv_img_signal);
   1da32:	f007 fd8f 	bl	25554 <lv_obj_set_signal_cb>
    lv_obj_set_design_cb(new_img, lv_img_design);
   1da36:	491a      	ldr	r1, [pc, #104]	; (1daa0 <lv_img_create+0xd4>)
   1da38:	4628      	mov	r0, r5
   1da3a:	f007 fd8d 	bl	25558 <lv_obj_set_design_cb>
    if(copy == NULL) {
   1da3e:	b9c6      	cbnz	r6, 1da72 <lv_img_create+0xa6>
        lv_obj_set_click(new_img, false);
   1da40:	4631      	mov	r1, r6
   1da42:	4628      	mov	r0, r5
   1da44:	f007 fd7f 	bl	25546 <lv_obj_set_click>
        if(par != NULL) {
   1da48:	7b23      	ldrb	r3, [r4, #12]
   1da4a:	b16f      	cbz	r7, 1da68 <lv_img_create+0x9c>
            ext->auto_size = 1;
   1da4c:	f043 0304 	orr.w	r3, r3, #4
   1da50:	7323      	strb	r3, [r4, #12]
            lv_obj_set_style(new_img, NULL); /*Inherit the style  by default*/
   1da52:	4631      	mov	r1, r6
            lv_obj_set_style(new_img, &lv_style_plain); /*Set a style for screens*/
   1da54:	4628      	mov	r0, r5
   1da56:	f007 fe9d 	bl	25794 <lv_obj_set_style>
    LV_LOG_INFO("image created");
   1da5a:	4b12      	ldr	r3, [pc, #72]	; (1daa4 <lv_img_create+0xd8>)
   1da5c:	4912      	ldr	r1, [pc, #72]	; (1daa8 <lv_img_create+0xdc>)
   1da5e:	226e      	movs	r2, #110	; 0x6e
   1da60:	2001      	movs	r0, #1
   1da62:	f7ff faf9 	bl	1d058 <lv_log_add>
    return new_img;
   1da66:	e7ba      	b.n	1d9de <lv_img_create+0x12>
            ext->auto_size = 0;
   1da68:	f367 0382 	bfi	r3, r7, #2, #1
   1da6c:	7323      	strb	r3, [r4, #12]
            lv_obj_set_style(new_img, &lv_style_plain); /*Set a style for screens*/
   1da6e:	490f      	ldr	r1, [pc, #60]	; (1daac <lv_img_create+0xe0>)
   1da70:	e7f0      	b.n	1da54 <lv_img_create+0x88>
        lv_img_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
   1da72:	4630      	mov	r0, r6
   1da74:	f008 f83a 	bl	25aec <lv_obj_get_ext_attr>
        ext->auto_size          = copy_ext->auto_size;
   1da78:	7b03      	ldrb	r3, [r0, #12]
   1da7a:	7b22      	ldrb	r2, [r4, #12]
   1da7c:	f3c3 0380 	ubfx	r3, r3, #2, #1
   1da80:	f363 0282 	bfi	r2, r3, #2, #1
   1da84:	7322      	strb	r2, [r4, #12]
        lv_img_set_src(new_img, copy_ext->src);
   1da86:	6801      	ldr	r1, [r0, #0]
   1da88:	4628      	mov	r0, r5
   1da8a:	f7ff fee9 	bl	1d860 <lv_img_set_src>
        lv_obj_refresh_style(new_img);
   1da8e:	4628      	mov	r0, r5
   1da90:	f007 fdf1 	bl	25676 <lv_obj_refresh_style>
   1da94:	e7e1      	b.n	1da5a <lv_img_create+0x8e>
   1da96:	bf00      	nop
   1da98:	20001f04 	.word	0x20001f04
   1da9c:	0001dab1 	.word	0x0001dab1
   1daa0:	0001d705 	.word	0x0001d705
   1daa4:	00065bb9 	.word	0x00065bb9
   1daa8:	00065bf3 	.word	0x00065bf3
   1daac:	20001c28 	.word	0x20001c28

0001dab0 <lv_img_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_img_signal(lv_obj_t * img, lv_signal_t sign, void * param)
{
   1dab0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(img, sign, param);
   1dab2:	4b19      	ldr	r3, [pc, #100]	; (1db18 <lv_img_signal+0x68>)
   1dab4:	681b      	ldr	r3, [r3, #0]
{
   1dab6:	4607      	mov	r7, r0
   1dab8:	460d      	mov	r5, r1
   1daba:	4614      	mov	r4, r2
    res = ancestor_signal(img, sign, param);
   1dabc:	4798      	blx	r3
    if(res != LV_RES_OK) return res;
   1dabe:	2801      	cmp	r0, #1
    res = ancestor_signal(img, sign, param);
   1dac0:	4606      	mov	r6, r0
    if(res != LV_RES_OK) return res;
   1dac2:	d11a      	bne.n	1dafa <lv_img_signal+0x4a>

    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
   1dac4:	2d07      	cmp	r5, #7
   1dac6:	d105      	bne.n	1dad4 <lv_img_signal+0x24>
   1dac8:	4620      	mov	r0, r4
   1daca:	4914      	ldr	r1, [pc, #80]	; (1db1c <lv_img_signal+0x6c>)
            lv_img_set_src(img, ext->src);
        }
    }

    return res;
}
   1dacc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
   1dad0:	f008 b80e 	b.w	25af0 <lv_obj_handle_get_type_signal>
    lv_img_ext_t * ext = lv_obj_get_ext_attr(img);
   1dad4:	4638      	mov	r0, r7
   1dad6:	f008 f809 	bl	25aec <lv_obj_get_ext_attr>
   1dada:	4604      	mov	r4, r0
    if(sign == LV_SIGNAL_CLEANUP) {
   1dadc:	b97d      	cbnz	r5, 1dafe <lv_img_signal+0x4e>
        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
   1dade:	7b03      	ldrb	r3, [r0, #12]
   1dae0:	f003 0303 	and.w	r3, r3, #3
   1dae4:	3b01      	subs	r3, #1
   1dae6:	2b01      	cmp	r3, #1
   1dae8:	d807      	bhi.n	1dafa <lv_img_signal+0x4a>
            lv_mem_free(ext->src);
   1daea:	6800      	ldr	r0, [r0, #0]
   1daec:	f7ff f918 	bl	1cd20 <lv_mem_free>
            ext->src_type = LV_IMG_SRC_UNKNOWN;
   1daf0:	7b23      	ldrb	r3, [r4, #12]
            ext->src      = NULL;
   1daf2:	6025      	str	r5, [r4, #0]
            ext->src_type = LV_IMG_SRC_UNKNOWN;
   1daf4:	f043 0303 	orr.w	r3, r3, #3
   1daf8:	7323      	strb	r3, [r4, #12]
}
   1dafa:	4630      	mov	r0, r6
   1dafc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
   1dafe:	2d04      	cmp	r5, #4
   1db00:	d1fb      	bne.n	1dafa <lv_img_signal+0x4a>
        if(ext->src_type == LV_IMG_SRC_SYMBOL) {
   1db02:	7b03      	ldrb	r3, [r0, #12]
   1db04:	f003 0303 	and.w	r3, r3, #3
   1db08:	2b02      	cmp	r3, #2
   1db0a:	d1f6      	bne.n	1dafa <lv_img_signal+0x4a>
            lv_img_set_src(img, ext->src);
   1db0c:	6801      	ldr	r1, [r0, #0]
   1db0e:	4638      	mov	r0, r7
   1db10:	f7ff fea6 	bl	1d860 <lv_img_set_src>
   1db14:	e7f1      	b.n	1dafa <lv_img_signal+0x4a>
   1db16:	bf00      	nop
   1db18:	20001f04 	.word	0x20001f04
   1db1c:	00065c9a 	.word	0x00065c9a

0001db20 <lv_theme_get_current>:
    if(!inited)
        return NULL;
    else
        return &current_theme;
#endif
}
   1db20:	4b01      	ldr	r3, [pc, #4]	; (1db28 <lv_theme_get_current+0x8>)
   1db22:	6818      	ldr	r0, [r3, #0]
   1db24:	4770      	bx	lr
   1db26:	bf00      	nop
   1db28:	20001f08 	.word	0x20001f08

0001db2c <bits_write>:
 * @param len length of bits to write from `val`. (Counted from the LSB).
 * @note `len == 3` will be converted to `len = 4` and `val` will be upscaled too
 */
static void bits_write(uint8_t * out, uint32_t bit_pos, uint8_t val, uint8_t len)
{
    if(len == 3) {
   1db2c:	2b03      	cmp	r3, #3
{
   1db2e:	b530      	push	{r4, r5, lr}
    if(len == 3) {
   1db30:	d104      	bne.n	1db3c <bits_write+0x10>
        len = 4;
        switch(val) {
   1db32:	2a07      	cmp	r2, #7
   1db34:	bf9c      	itt	ls
   1db36:	4b0a      	ldrls	r3, [pc, #40]	; (1db60 <bits_write+0x34>)
   1db38:	5c9a      	ldrbls	r2, [r3, r2]
        len = 4;
   1db3a:	2304      	movs	r3, #4
        case 7: val = 15; break;
        }
    }

    uint16_t byte_pos = bit_pos >> 3;
    bit_pos = bit_pos & 0x7;
   1db3c:	f001 0507 	and.w	r5, r1, #7
    bit_pos = 8 - bit_pos - len;

    uint8_t bit_mask = (uint16_t)((uint16_t) 1 << len) - 1;
   1db40:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    out[byte_pos] &= ((~bit_mask) << bit_pos);
   1db44:	f3c1 01cf 	ubfx	r1, r1, #3, #16
   1db48:	409c      	lsls	r4, r3
   1db4a:	f1c5 0508 	rsb	r5, r5, #8
    bit_pos = 8 - bit_pos - len;
   1db4e:	1aed      	subs	r5, r5, r3
    out[byte_pos] &= ((~bit_mask) << bit_pos);
   1db50:	b264      	sxtb	r4, r4
   1db52:	5c43      	ldrb	r3, [r0, r1]
   1db54:	40ac      	lsls	r4, r5
   1db56:	401c      	ands	r4, r3
    out[byte_pos] |= (val << bit_pos);
   1db58:	40aa      	lsls	r2, r5
   1db5a:	4314      	orrs	r4, r2
   1db5c:	5444      	strb	r4, [r0, r1]
}
   1db5e:	bd30      	pop	{r4, r5, pc}
   1db60:	00065ca1 	.word	0x00065ca1

0001db64 <rle_next>:
    rle_prev_v = 0;
    rle_cnt = 0;
}

static uint8_t rle_next(void)
{
   1db64:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint8_t v = 0;
    uint8_t ret = 0;

    if(rle_state == RLE_STATE_SINGLE) {
   1db68:	4e4a      	ldr	r6, [pc, #296]	; (1dc94 <rle_next+0x130>)
   1db6a:	f896 9000 	ldrb.w	r9, [r6]
   1db6e:	f1b9 0f00 	cmp.w	r9, #0
   1db72:	d11d      	bne.n	1dbb0 <rle_next+0x4c>
        ret = get_bits(rle_in, rle_rdp, rle_bpp);
   1db74:	4b48      	ldr	r3, [pc, #288]	; (1dc98 <rle_next+0x134>)
   1db76:	4d49      	ldr	r5, [pc, #292]	; (1dc9c <rle_next+0x138>)
   1db78:	781f      	ldrb	r7, [r3, #0]
   1db7a:	f8d5 8000 	ldr.w	r8, [r5]
   1db7e:	4b48      	ldr	r3, [pc, #288]	; (1dca0 <rle_next+0x13c>)
   1db80:	463a      	mov	r2, r7
   1db82:	6818      	ldr	r0, [r3, #0]
   1db84:	4641      	mov	r1, r8
   1db86:	f009 ff04 	bl	27992 <get_bits>
   1db8a:	4b46      	ldr	r3, [pc, #280]	; (1dca4 <rle_next+0x140>)
   1db8c:	4604      	mov	r4, r0
        if(rle_rdp != 0 && rle_prev_v == ret) {
   1db8e:	f1b8 0f00 	cmp.w	r8, #0
   1db92:	d007      	beq.n	1dba4 <rle_next+0x40>
   1db94:	781a      	ldrb	r2, [r3, #0]
   1db96:	4282      	cmp	r2, r0
            rle_cnt = 0;
   1db98:	bf01      	itttt	eq
   1db9a:	4a43      	ldreq	r2, [pc, #268]	; (1dca8 <rle_next+0x144>)
   1db9c:	f882 9000 	strbeq.w	r9, [r2]
            rle_state = RLE_STATE_REPEATE;
   1dba0:	2201      	moveq	r2, #1
   1dba2:	7032      	strbeq	r2, [r6, #0]
        }

        rle_prev_v = ret;
        rle_rdp += rle_bpp;
   1dba4:	4447      	add	r7, r8
        rle_prev_v = ret;
   1dba6:	701c      	strb	r4, [r3, #0]
        rle_rdp += rle_bpp;
   1dba8:	602f      	str	r7, [r5, #0]
            rle_state = RLE_STATE_SINGLE;
        }
    }

    return ret;
}
   1dbaa:	4620      	mov	r0, r4
   1dbac:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    else if(rle_state == RLE_STATE_REPEATE) {
   1dbb0:	f1b9 0f01 	cmp.w	r9, #1
   1dbb4:	d149      	bne.n	1dc4a <rle_next+0xe6>
        v = get_bits(rle_in, rle_rdp, 1);
   1dbb6:	4b3a      	ldr	r3, [pc, #232]	; (1dca0 <rle_next+0x13c>)
   1dbb8:	4f38      	ldr	r7, [pc, #224]	; (1dc9c <rle_next+0x138>)
   1dbba:	f8d3 8000 	ldr.w	r8, [r3]
   1dbbe:	683d      	ldr	r5, [r7, #0]
        rle_cnt++;
   1dbc0:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 1dca8 <rle_next+0x144>
        v = get_bits(rle_in, rle_rdp, 1);
   1dbc4:	464a      	mov	r2, r9
   1dbc6:	4629      	mov	r1, r5
   1dbc8:	4640      	mov	r0, r8
   1dbca:	f009 fee2 	bl	27992 <get_bits>
        rle_cnt++;
   1dbce:	f89a 3000 	ldrb.w	r3, [sl]
   1dbd2:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 1dca4 <rle_next+0x140>
   1dbd6:	3301      	adds	r3, #1
   1dbd8:	b2db      	uxtb	r3, r3
        rle_rdp += 1;
   1dbda:	f105 0b01 	add.w	fp, r5, #1
        if(v == 1) {
   1dbde:	2801      	cmp	r0, #1
        rle_cnt++;
   1dbe0:	f88a 3000 	strb.w	r3, [sl]
        rle_rdp += 1;
   1dbe4:	f8c7 b000 	str.w	fp, [r7]
        if(v == 1) {
   1dbe8:	d121      	bne.n	1dc2e <rle_next+0xca>
            if(rle_cnt == 11) {
   1dbea:	2b0b      	cmp	r3, #11
            ret = rle_prev_v;
   1dbec:	f899 4000 	ldrb.w	r4, [r9]
            if(rle_cnt == 11) {
   1dbf0:	d1db      	bne.n	1dbaa <rle_next+0x46>
                rle_cnt = get_bits(rle_in, rle_rdp, 6);
   1dbf2:	4659      	mov	r1, fp
   1dbf4:	2206      	movs	r2, #6
   1dbf6:	4640      	mov	r0, r8
   1dbf8:	f009 fecb 	bl	27992 <get_bits>
                rle_rdp += 6;
   1dbfc:	3507      	adds	r5, #7
                rle_cnt = get_bits(rle_in, rle_rdp, 6);
   1dbfe:	4683      	mov	fp, r0
   1dc00:	f88a 0000 	strb.w	r0, [sl]
                rle_rdp += 6;
   1dc04:	603d      	str	r5, [r7, #0]
                if(rle_cnt != 0) {
   1dc06:	b110      	cbz	r0, 1dc0e <rle_next+0xaa>
                    rle_state = RLE_STATE_COUNTER;
   1dc08:	2302      	movs	r3, #2
            rle_state = RLE_STATE_SINGLE;
   1dc0a:	7033      	strb	r3, [r6, #0]
   1dc0c:	e7cd      	b.n	1dbaa <rle_next+0x46>
                    ret = get_bits(rle_in, rle_rdp, rle_bpp);
   1dc0e:	4b22      	ldr	r3, [pc, #136]	; (1dc98 <rle_next+0x134>)
   1dc10:	f893 a000 	ldrb.w	sl, [r3]
   1dc14:	4629      	mov	r1, r5
   1dc16:	4652      	mov	r2, sl
   1dc18:	4640      	mov	r0, r8
   1dc1a:	f009 feba 	bl	27992 <get_bits>
                    rle_rdp += rle_bpp;
   1dc1e:	4455      	add	r5, sl
                    ret = get_bits(rle_in, rle_rdp, rle_bpp);
   1dc20:	4604      	mov	r4, r0
                    rle_prev_v = ret;
   1dc22:	f889 0000 	strb.w	r0, [r9]
                    rle_rdp += rle_bpp;
   1dc26:	603d      	str	r5, [r7, #0]
                    rle_state = RLE_STATE_SINGLE;
   1dc28:	f886 b000 	strb.w	fp, [r6]
   1dc2c:	e7bd      	b.n	1dbaa <rle_next+0x46>
            ret = get_bits(rle_in, rle_rdp, rle_bpp);
   1dc2e:	4b1a      	ldr	r3, [pc, #104]	; (1dc98 <rle_next+0x134>)
   1dc30:	781d      	ldrb	r5, [r3, #0]
   1dc32:	4659      	mov	r1, fp
   1dc34:	462a      	mov	r2, r5
   1dc36:	4640      	mov	r0, r8
   1dc38:	f009 feab 	bl	27992 <get_bits>
            rle_rdp += rle_bpp;
   1dc3c:	445d      	add	r5, fp
            ret = get_bits(rle_in, rle_rdp, rle_bpp);
   1dc3e:	4604      	mov	r4, r0
            rle_prev_v = ret;
   1dc40:	f889 0000 	strb.w	r0, [r9]
            rle_rdp += rle_bpp;
   1dc44:	603d      	str	r5, [r7, #0]
            rle_state = RLE_STATE_SINGLE;
   1dc46:	2300      	movs	r3, #0
   1dc48:	e7df      	b.n	1dc0a <rle_next+0xa6>
    else if(rle_state == RLE_STATE_COUNTER) {
   1dc4a:	f1b9 0f02 	cmp.w	r9, #2
   1dc4e:	d11e      	bne.n	1dc8e <rle_next+0x12a>
        rle_cnt--;
   1dc50:	4b15      	ldr	r3, [pc, #84]	; (1dca8 <rle_next+0x144>)
        ret = rle_prev_v;
   1dc52:	f8df a050 	ldr.w	sl, [pc, #80]	; 1dca4 <rle_next+0x140>
        rle_cnt--;
   1dc56:	781d      	ldrb	r5, [r3, #0]
        ret = rle_prev_v;
   1dc58:	f89a 4000 	ldrb.w	r4, [sl]
        rle_cnt--;
   1dc5c:	3d01      	subs	r5, #1
   1dc5e:	b2ed      	uxtb	r5, r5
   1dc60:	701d      	strb	r5, [r3, #0]
        if(rle_cnt == 0) {
   1dc62:	2d00      	cmp	r5, #0
   1dc64:	d1a1      	bne.n	1dbaa <rle_next+0x46>
            ret = get_bits(rle_in, rle_rdp, rle_bpp);
   1dc66:	f8df 8034 	ldr.w	r8, [pc, #52]	; 1dc9c <rle_next+0x138>
   1dc6a:	4b0b      	ldr	r3, [pc, #44]	; (1dc98 <rle_next+0x134>)
   1dc6c:	f8d8 9000 	ldr.w	r9, [r8]
   1dc70:	781f      	ldrb	r7, [r3, #0]
   1dc72:	4b0b      	ldr	r3, [pc, #44]	; (1dca0 <rle_next+0x13c>)
   1dc74:	463a      	mov	r2, r7
   1dc76:	4649      	mov	r1, r9
   1dc78:	6818      	ldr	r0, [r3, #0]
   1dc7a:	f009 fe8a 	bl	27992 <get_bits>
            rle_rdp += rle_bpp;
   1dc7e:	444f      	add	r7, r9
            ret = get_bits(rle_in, rle_rdp, rle_bpp);
   1dc80:	4604      	mov	r4, r0
            rle_prev_v = ret;
   1dc82:	f88a 0000 	strb.w	r0, [sl]
            rle_rdp += rle_bpp;
   1dc86:	f8c8 7000 	str.w	r7, [r8]
            rle_state = RLE_STATE_SINGLE;
   1dc8a:	7035      	strb	r5, [r6, #0]
   1dc8c:	e78d      	b.n	1dbaa <rle_next+0x46>
    uint8_t ret = 0;
   1dc8e:	2400      	movs	r4, #0
   1dc90:	e78b      	b.n	1dbaa <rle_next+0x46>
   1dc92:	bf00      	nop
   1dc94:	2000abdd 	.word	0x2000abdd
   1dc98:	2000abda 	.word	0x2000abda
   1dc9c:	20001f14 	.word	0x20001f14
   1dca0:	20001f10 	.word	0x20001f10
   1dca4:	2000abdc 	.word	0x2000abdc
   1dca8:	2000abdb 	.word	0x2000abdb

0001dcac <get_glyph_dsc_id.isra.0.part.1>:
static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
   1dcac:	b5f0      	push	{r4, r5, r6, r7, lr}
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
   1dcae:	6804      	ldr	r4, [r0, #0]
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
   1dcb0:	6963      	ldr	r3, [r4, #20]
   1dcb2:	428b      	cmp	r3, r1
static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
   1dcb4:	b085      	sub	sp, #20
   1dcb6:	460d      	mov	r5, r1
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
   1dcb8:	d145      	bne.n	1dd46 <get_glyph_dsc_id.isra.0.part.1+0x9a>
   1dcba:	69a0      	ldr	r0, [r4, #24]
}
   1dcbc:	b005      	add	sp, #20
   1dcbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
   1dcc0:	68a2      	ldr	r2, [r4, #8]
   1dcc2:	fb07 f603 	mul.w	r6, r7, r3
   1dcc6:	1991      	adds	r1, r2, r6
   1dcc8:	5992      	ldr	r2, [r2, r6]
        if(rcp > fdsc->cmaps[i].range_length) continue;
   1dcca:	8888      	ldrh	r0, [r1, #4]
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
   1dccc:	1aaa      	subs	r2, r5, r2
        if(rcp > fdsc->cmaps[i].range_length) continue;
   1dcce:	4282      	cmp	r2, r0
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
   1dcd0:	9203      	str	r2, [sp, #12]
        if(rcp > fdsc->cmaps[i].range_length) continue;
   1dcd2:	f103 0301 	add.w	r3, r3, #1
   1dcd6:	d838      	bhi.n	1dd4a <get_glyph_dsc_id.isra.0.part.1+0x9e>
        if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY) {
   1dcd8:	7c8b      	ldrb	r3, [r1, #18]
   1dcda:	b923      	cbnz	r3, 1dce6 <get_glyph_dsc_id.isra.0.part.1+0x3a>
            glyph_id = fdsc->cmaps[i].glyph_id_start + rcp;
   1dcdc:	88c8      	ldrh	r0, [r1, #6]
   1dcde:	4410      	add	r0, r2
        fdsc->last_letter = letter;
   1dce0:	6165      	str	r5, [r4, #20]
    fdsc->last_glyph_id = 0;
   1dce2:	61a0      	str	r0, [r4, #24]
    return 0;
   1dce4:	e7ea      	b.n	1dcbc <get_glyph_dsc_id.isra.0.part.1+0x10>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL) {
   1dce6:	2b01      	cmp	r3, #1
   1dce8:	d104      	bne.n	1dcf4 <get_glyph_dsc_id.isra.0.part.1+0x48>
            glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_8[rcp];
   1dcea:	68cb      	ldr	r3, [r1, #12]
   1dcec:	5c98      	ldrb	r0, [r3, r2]
   1dcee:	88cb      	ldrh	r3, [r1, #6]
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
   1dcf0:	4418      	add	r0, r3
   1dcf2:	e7f5      	b.n	1dce0 <get_glyph_dsc_id.isra.0.part.1+0x34>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_TINY) {
   1dcf4:	2b02      	cmp	r3, #2
   1dcf6:	d111      	bne.n	1dd1c <get_glyph_dsc_id.isra.0.part.1+0x70>
            uint8_t * p = lv_utils_bsearch(&rcp, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length, sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);
   1dcf8:	4818      	ldr	r0, [pc, #96]	; (1dd5c <get_glyph_dsc_id.isra.0.part.1+0xb0>)
   1dcfa:	8a0a      	ldrh	r2, [r1, #16]
   1dcfc:	9000      	str	r0, [sp, #0]
   1dcfe:	6889      	ldr	r1, [r1, #8]
   1dd00:	a803      	add	r0, sp, #12
   1dd02:	f009 fc00 	bl	27506 <lv_utils_bsearch>
            if(p) {
   1dd06:	b908      	cbnz	r0, 1dd0c <get_glyph_dsc_id.isra.0.part.1+0x60>
        uint32_t glyph_id = 0;
   1dd08:	2000      	movs	r0, #0
   1dd0a:	e7e9      	b.n	1dce0 <get_glyph_dsc_id.isra.0.part.1+0x34>
                lv_uintptr_t ofs = (lv_uintptr_t)(p - (uint8_t *) fdsc->cmaps[i].unicode_list);
   1dd0c:	68a3      	ldr	r3, [r4, #8]
   1dd0e:	4433      	add	r3, r6
   1dd10:	689a      	ldr	r2, [r3, #8]
   1dd12:	1a82      	subs	r2, r0, r2
                glyph_id = fdsc->cmaps[i].glyph_id_start + ofs;
   1dd14:	88d8      	ldrh	r0, [r3, #6]
   1dd16:	eb00 0052 	add.w	r0, r0, r2, lsr #1
   1dd1a:	e7e1      	b.n	1dce0 <get_glyph_dsc_id.isra.0.part.1+0x34>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_FULL) {
   1dd1c:	2b03      	cmp	r3, #3
   1dd1e:	d1f3      	bne.n	1dd08 <get_glyph_dsc_id.isra.0.part.1+0x5c>
            uint8_t * p = lv_utils_bsearch(&rcp, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length, sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);
   1dd20:	4b0e      	ldr	r3, [pc, #56]	; (1dd5c <get_glyph_dsc_id.isra.0.part.1+0xb0>)
   1dd22:	8a0a      	ldrh	r2, [r1, #16]
   1dd24:	9300      	str	r3, [sp, #0]
   1dd26:	6889      	ldr	r1, [r1, #8]
   1dd28:	2302      	movs	r3, #2
   1dd2a:	a803      	add	r0, sp, #12
   1dd2c:	f009 fbeb 	bl	27506 <lv_utils_bsearch>
            if(p) {
   1dd30:	2800      	cmp	r0, #0
   1dd32:	d0e9      	beq.n	1dd08 <get_glyph_dsc_id.isra.0.part.1+0x5c>
                lv_uintptr_t ofs = (lv_uintptr_t)(p - (uint8_t*) fdsc->cmaps[i].unicode_list);
   1dd34:	68a3      	ldr	r3, [r4, #8]
   1dd36:	4433      	add	r3, r6
   1dd38:	689a      	ldr	r2, [r3, #8]
   1dd3a:	1a80      	subs	r0, r0, r2
                ofs = ofs >> 1;     /*The list stores `uint16_t` so the get the index divide by 2*/
   1dd3c:	0840      	lsrs	r0, r0, #1
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
   1dd3e:	68da      	ldr	r2, [r3, #12]
   1dd40:	88db      	ldrh	r3, [r3, #6]
   1dd42:	5c10      	ldrb	r0, [r2, r0]
   1dd44:	e7d4      	b.n	1dcf0 <get_glyph_dsc_id.isra.0.part.1+0x44>
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
   1dd46:	2300      	movs	r3, #0
   1dd48:	2714      	movs	r7, #20
    for(i = 0; i < fdsc->cmap_num; i++) {
   1dd4a:	8a62      	ldrh	r2, [r4, #18]
   1dd4c:	b299      	uxth	r1, r3
   1dd4e:	f3c2 0209 	ubfx	r2, r2, #0, #10
   1dd52:	428a      	cmp	r2, r1
   1dd54:	d8b4      	bhi.n	1dcc0 <get_glyph_dsc_id.isra.0.part.1+0x14>
    fdsc->last_letter = letter;
   1dd56:	6165      	str	r5, [r4, #20]
    fdsc->last_glyph_id = 0;
   1dd58:	2000      	movs	r0, #0
   1dd5a:	e7c2      	b.n	1dce2 <get_glyph_dsc_id.isra.0.part.1+0x36>
   1dd5c:	000279bb 	.word	0x000279bb

0001dd60 <lv_font_get_bitmap_fmt_txt>:
{
   1dd60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1dd64:	b087      	sub	sp, #28
    if(letter == '\0') return 0;
   1dd66:	b919      	cbnz	r1, 1dd70 <lv_font_get_bitmap_fmt_txt+0x10>
    if(!gid) return NULL;
   1dd68:	2000      	movs	r0, #0
}
   1dd6a:	b007      	add	sp, #28
   1dd6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
   1dd70:	f850 6f0c 	ldr.w	r6, [r0, #12]!
   1dd74:	f7ff ff9a 	bl	1dcac <get_glyph_dsc_id.isra.0.part.1>
    if(!gid) return NULL;
   1dd78:	4680      	mov	r8, r0
   1dd7a:	2800      	cmp	r0, #0
   1dd7c:	d0f4      	beq.n	1dd68 <lv_font_get_bitmap_fmt_txt+0x8>
    if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {
   1dd7e:	7cf3      	ldrb	r3, [r6, #19]
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
   1dd80:	f8d6 9004 	ldr.w	r9, [r6, #4]
    if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {
   1dd84:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
   1dd88:	eb09 07c0 	add.w	r7, r9, r0, lsl #3
    if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {
   1dd8c:	d108      	bne.n	1dda0 <lv_font_get_bitmap_fmt_txt+0x40>
        if(gdsc) return &fdsc->glyph_bitmap[gdsc->bitmap_index];
   1dd8e:	2f00      	cmp	r7, #0
   1dd90:	d0ea      	beq.n	1dd68 <lv_font_get_bitmap_fmt_txt+0x8>
   1dd92:	f859 3030 	ldr.w	r3, [r9, r0, lsl #3]
   1dd96:	6830      	ldr	r0, [r6, #0]
   1dd98:	f3c3 0313 	ubfx	r3, r3, #0, #20
   1dd9c:	4418      	add	r0, r3
   1dd9e:	e7e4      	b.n	1dd6a <lv_font_get_bitmap_fmt_txt+0xa>
        uint32_t gsize = gdsc->box_w * gdsc->box_h;
   1dda0:	793c      	ldrb	r4, [r7, #4]
   1dda2:	7979      	ldrb	r1, [r7, #5]
   1dda4:	fb14 f401 	smulbb	r4, r4, r1
        if(gsize == 0) return NULL;
   1dda8:	2c00      	cmp	r4, #0
   1ddaa:	d0dd      	beq.n	1dd68 <lv_font_get_bitmap_fmt_txt+0x8>
        switch(fdsc->bpp) {
   1ddac:	f3c3 0382 	ubfx	r3, r3, #2, #3
   1ddb0:	3b01      	subs	r3, #1
   1ddb2:	2b03      	cmp	r3, #3
   1ddb4:	d804      	bhi.n	1ddc0 <lv_font_get_bitmap_fmt_txt+0x60>
   1ddb6:	e8df f003 	tbb	[pc, r3]
   1ddba:	4502      	.short	0x4502
   1ddbc:	4747      	.short	0x4747
        case 1: buf_size = gsize >> 3;  break;
   1ddbe:	08e4      	lsrs	r4, r4, #3
        if(lv_mem_get_size(buf) < buf_size) {
   1ddc0:	4d41      	ldr	r5, [pc, #260]	; (1dec8 <lv_font_get_bitmap_fmt_txt+0x168>)
   1ddc2:	6828      	ldr	r0, [r5, #0]
   1ddc4:	f7fe ffbc 	bl	1cd40 <lv_mem_get_size>
   1ddc8:	42a0      	cmp	r0, r4
   1ddca:	d33f      	bcc.n	1de4c <lv_font_get_bitmap_fmt_txt+0xec>
        decompress(&fdsc->glyph_bitmap[gdsc->bitmap_index], buf, gdsc->box_w , gdsc->box_h, (uint8_t)fdsc->bpp);
   1ddcc:	f859 2038 	ldr.w	r2, [r9, r8, lsl #3]
   1ddd0:	6833      	ldr	r3, [r6, #0]
   1ddd2:	f3c2 0213 	ubfx	r2, r2, #0, #20
   1ddd6:	441a      	add	r2, r3
   1ddd8:	682b      	ldr	r3, [r5, #0]
   1ddda:	9302      	str	r3, [sp, #8]
   1dddc:	797b      	ldrb	r3, [r7, #5]
   1ddde:	9304      	str	r3, [sp, #16]
   1dde0:	7cf3      	ldrb	r3, [r6, #19]
   1dde2:	793d      	ldrb	r5, [r7, #4]
   1dde4:	f3c3 0382 	ubfx	r3, r3, #2, #3
   1dde8:	b2df      	uxtb	r7, r3
    if(bpp == 3) wr_size = 4;
   1ddea:	2f03      	cmp	r7, #3
   1ddec:	bf14      	ite	ne
   1ddee:	4639      	movne	r1, r7
   1ddf0:	2104      	moveq	r1, #4
   1ddf2:	9100      	str	r1, [sp, #0]
    rle_in = in;
   1ddf4:	4935      	ldr	r1, [pc, #212]	; (1decc <lv_font_get_bitmap_fmt_txt+0x16c>)
   1ddf6:	600a      	str	r2, [r1, #0]
    rle_bpp = bpp;
   1ddf8:	4a35      	ldr	r2, [pc, #212]	; (1ded0 <lv_font_get_bitmap_fmt_txt+0x170>)
   1ddfa:	7013      	strb	r3, [r2, #0]
    rle_state = RLE_STATE_SINGLE;
   1ddfc:	4a35      	ldr	r2, [pc, #212]	; (1ded4 <lv_font_get_bitmap_fmt_txt+0x174>)
   1ddfe:	2300      	movs	r3, #0
   1de00:	7013      	strb	r3, [r2, #0]
    rle_rdp = 0;
   1de02:	4a35      	ldr	r2, [pc, #212]	; (1ded8 <lv_font_get_bitmap_fmt_txt+0x178>)
   1de04:	6013      	str	r3, [r2, #0]
    rle_prev_v = 0;
   1de06:	4a35      	ldr	r2, [pc, #212]	; (1dedc <lv_font_get_bitmap_fmt_txt+0x17c>)
   1de08:	7013      	strb	r3, [r2, #0]
    rle_cnt = 0;
   1de0a:	4a35      	ldr	r2, [pc, #212]	; (1dee0 <lv_font_get_bitmap_fmt_txt+0x180>)
    uint8_t * line_buf = lv_draw_get_buf(w * 2);
   1de0c:	0068      	lsls	r0, r5, #1
    rle_cnt = 0;
   1de0e:	7013      	strb	r3, [r2, #0]
    uint8_t * line_buf = lv_draw_get_buf(w * 2);
   1de10:	f7fd fe5c 	bl	1bacc <lv_draw_get_buf>
   1de14:	4680      	mov	r8, r0
    uint8_t * line_buf2 = line_buf + w;
   1de16:	1946      	adds	r6, r0, r5
static void decompress_line(uint8_t * out, lv_coord_t w)
   1de18:	4681      	mov	r9, r0
    uint8_t * line_buf2 = line_buf + w;
   1de1a:	4604      	mov	r4, r0
    for(i = 0; i < w; i++) {
   1de1c:	42b4      	cmp	r4, r6
   1de1e:	d11d      	bne.n	1de5c <lv_font_get_bitmap_fmt_txt+0xfc>
    uint32_t wrp = 0;
   1de20:	f04f 0a00 	mov.w	sl, #0
    for(x = 0; x < w; x++) {
   1de24:	45a1      	cmp	r9, r4
   1de26:	d11e      	bne.n	1de66 <lv_font_get_bitmap_fmt_txt+0x106>
   1de28:	9b00      	ldr	r3, [sp, #0]
   1de2a:	fb15 f303 	smulbb	r3, r5, r3
   1de2e:	9303      	str	r3, [sp, #12]
   1de30:	4699      	mov	r9, r3
   1de32:	1973      	adds	r3, r6, r5
    for(y = 1; y < h; y++) {
   1de34:	2401      	movs	r4, #1
   1de36:	9305      	str	r3, [sp, #20]
   1de38:	9b04      	ldr	r3, [sp, #16]
   1de3a:	42a3      	cmp	r3, r4
   1de3c:	dd40      	ble.n	1dec0 <lv_font_get_bitmap_fmt_txt+0x160>
   1de3e:	9601      	str	r6, [sp, #4]
   1de40:	4635      	mov	r5, r6
   1de42:	e01e      	b.n	1de82 <lv_font_get_bitmap_fmt_txt+0x122>
        case 2: buf_size = gsize >> 2;  break;
   1de44:	08a4      	lsrs	r4, r4, #2
   1de46:	e7bb      	b.n	1ddc0 <lv_font_get_bitmap_fmt_txt+0x60>
        case 4: buf_size = gsize >> 1;  break;
   1de48:	0864      	lsrs	r4, r4, #1
   1de4a:	e7b9      	b.n	1ddc0 <lv_font_get_bitmap_fmt_txt+0x60>
            buf = lv_mem_realloc(buf, buf_size);
   1de4c:	4621      	mov	r1, r4
   1de4e:	6828      	ldr	r0, [r5, #0]
   1de50:	f7fe ff84 	bl	1cd5c <lv_mem_realloc>
   1de54:	6028      	str	r0, [r5, #0]
            if(buf == NULL) return NULL;
   1de56:	2800      	cmp	r0, #0
   1de58:	d1b8      	bne.n	1ddcc <lv_font_get_bitmap_fmt_txt+0x6c>
   1de5a:	e785      	b.n	1dd68 <lv_font_get_bitmap_fmt_txt+0x8>
        out[i] = rle_next();
   1de5c:	f7ff fe82 	bl	1db64 <rle_next>
   1de60:	f804 0b01 	strb.w	r0, [r4], #1
   1de64:	e7da      	b.n	1de1c <lv_font_get_bitmap_fmt_txt+0xbc>
        bits_write(out,wrp, line_buf1[x], bpp);
   1de66:	463b      	mov	r3, r7
   1de68:	4651      	mov	r1, sl
   1de6a:	f819 2b01 	ldrb.w	r2, [r9], #1
   1de6e:	9802      	ldr	r0, [sp, #8]
   1de70:	f7ff fe5c 	bl	1db2c <bits_write>
        wrp += wr_size;
   1de74:	9b00      	ldr	r3, [sp, #0]
   1de76:	449a      	add	sl, r3
   1de78:	e7d4      	b.n	1de24 <lv_font_get_bitmap_fmt_txt+0xc4>
        out[i] = rle_next();
   1de7a:	f7ff fe73 	bl	1db64 <rle_next>
   1de7e:	f805 0b01 	strb.w	r0, [r5], #1
    for(i = 0; i < w; i++) {
   1de82:	9b05      	ldr	r3, [sp, #20]
   1de84:	429d      	cmp	r5, r3
   1de86:	d1f8      	bne.n	1de7a <lv_font_get_bitmap_fmt_txt+0x11a>
   1de88:	f108 3bff 	add.w	fp, r8, #4294967295	; 0xffffffff
   1de8c:	46ca      	mov	sl, r9
        for(x = 0; x < w; x++) {
   1de8e:	9b01      	ldr	r3, [sp, #4]
   1de90:	42ab      	cmp	r3, r5
   1de92:	d104      	bne.n	1de9e <lv_font_get_bitmap_fmt_txt+0x13e>
   1de94:	9b03      	ldr	r3, [sp, #12]
    for(y = 1; y < h; y++) {
   1de96:	3401      	adds	r4, #1
   1de98:	4499      	add	r9, r3
   1de9a:	b224      	sxth	r4, r4
   1de9c:	e7cc      	b.n	1de38 <lv_font_get_bitmap_fmt_txt+0xd8>
            line_buf1[x] = line_buf2[x] ^ line_buf1[x];
   1de9e:	9b01      	ldr	r3, [sp, #4]
            bits_write(out,wrp, line_buf1[x], bpp);
   1dea0:	9802      	ldr	r0, [sp, #8]
            line_buf1[x] = line_buf2[x] ^ line_buf1[x];
   1dea2:	f813 2b01 	ldrb.w	r2, [r3], #1
   1dea6:	9301      	str	r3, [sp, #4]
   1dea8:	f81b 3f01 	ldrb.w	r3, [fp, #1]!
   1deac:	405a      	eors	r2, r3
            bits_write(out,wrp, line_buf1[x], bpp);
   1deae:	4651      	mov	r1, sl
   1deb0:	463b      	mov	r3, r7
            line_buf1[x] = line_buf2[x] ^ line_buf1[x];
   1deb2:	f88b 2000 	strb.w	r2, [fp]
            bits_write(out,wrp, line_buf1[x], bpp);
   1deb6:	f7ff fe39 	bl	1db2c <bits_write>
            wrp += wr_size;
   1deba:	9b00      	ldr	r3, [sp, #0]
   1debc:	449a      	add	sl, r3
   1debe:	e7e6      	b.n	1de8e <lv_font_get_bitmap_fmt_txt+0x12e>
        return buf;
   1dec0:	4b01      	ldr	r3, [pc, #4]	; (1dec8 <lv_font_get_bitmap_fmt_txt+0x168>)
   1dec2:	6818      	ldr	r0, [r3, #0]
   1dec4:	e751      	b.n	1dd6a <lv_font_get_bitmap_fmt_txt+0xa>
   1dec6:	bf00      	nop
   1dec8:	20001f0c 	.word	0x20001f0c
   1decc:	20001f10 	.word	0x20001f10
   1ded0:	2000abda 	.word	0x2000abda
   1ded4:	2000abdd 	.word	0x2000abdd
   1ded8:	20001f14 	.word	0x20001f14
   1dedc:	2000abdc 	.word	0x2000abdc
   1dee0:	2000abdb 	.word	0x2000abdb

0001dee4 <lv_font_get_glyph_dsc_fmt_txt>:
{
   1dee4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1dee8:	4680      	mov	r8, r0
   1deea:	b085      	sub	sp, #20
   1deec:	460c      	mov	r4, r1
   1deee:	4699      	mov	r9, r3
    if(letter == '\0') return 0;
   1def0:	b91a      	cbnz	r2, 1defa <lv_font_get_glyph_dsc_fmt_txt+0x16>
    if(!gid) return false;
   1def2:	2000      	movs	r0, #0
}
   1def4:	b005      	add	sp, #20
   1def6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
   1defa:	4607      	mov	r7, r0
   1defc:	4611      	mov	r1, r2
   1defe:	f857 5f0c 	ldr.w	r5, [r7, #12]!
   1df02:	4638      	mov	r0, r7
   1df04:	f7ff fed2 	bl	1dcac <get_glyph_dsc_id.isra.0.part.1>
    if(!gid) return false;
   1df08:	4606      	mov	r6, r0
   1df0a:	2800      	cmp	r0, #0
   1df0c:	d0f1      	beq.n	1def2 <lv_font_get_glyph_dsc_fmt_txt+0xe>
    if(fdsc->kern_dsc) {
   1df0e:	68eb      	ldr	r3, [r5, #12]
   1df10:	b9d3      	cbnz	r3, 1df48 <lv_font_get_glyph_dsc_fmt_txt+0x64>
    int8_t kvalue = 0;
   1df12:	2000      	movs	r0, #0
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
   1df14:	686b      	ldr	r3, [r5, #4]
   1df16:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
    int32_t kv = ((int32_t)((int32_t)kvalue * fdsc->kern_scale) >> 4);
   1df1a:	8a2b      	ldrh	r3, [r5, #16]
   1df1c:	4358      	muls	r0, r3
    uint32_t adv_w = gdsc->adv_w + kv;
   1df1e:	8873      	ldrh	r3, [r6, #2]
   1df20:	091b      	lsrs	r3, r3, #4
   1df22:	eb03 1020 	add.w	r0, r3, r0, asr #4
    adv_w  = (adv_w + (1 << 3)) >> 4;
   1df26:	3008      	adds	r0, #8
   1df28:	0900      	lsrs	r0, r0, #4
    dsc_out->adv_w = adv_w;
   1df2a:	8020      	strh	r0, [r4, #0]
    dsc_out->box_h = gdsc->box_h;
   1df2c:	7973      	ldrb	r3, [r6, #5]
   1df2e:	70e3      	strb	r3, [r4, #3]
    dsc_out->box_w = gdsc->box_w;
   1df30:	7933      	ldrb	r3, [r6, #4]
   1df32:	70a3      	strb	r3, [r4, #2]
    dsc_out->ofs_x = gdsc->ofs_x;
   1df34:	79b3      	ldrb	r3, [r6, #6]
   1df36:	7123      	strb	r3, [r4, #4]
    dsc_out->ofs_y = gdsc->ofs_y;
   1df38:	79f3      	ldrb	r3, [r6, #7]
   1df3a:	7163      	strb	r3, [r4, #5]
    dsc_out->bpp   = (uint8_t)fdsc->bpp;
   1df3c:	7ceb      	ldrb	r3, [r5, #19]
   1df3e:	f3c3 0382 	ubfx	r3, r3, #2, #3
   1df42:	71a3      	strb	r3, [r4, #6]
    return true;
   1df44:	2001      	movs	r0, #1
   1df46:	e7d5      	b.n	1def4 <lv_font_get_glyph_dsc_fmt_txt+0x10>
    if(letter == '\0') return 0;
   1df48:	f1b9 0f00 	cmp.w	r9, #0
   1df4c:	d0e1      	beq.n	1df12 <lv_font_get_glyph_dsc_fmt_txt+0x2e>
   1df4e:	4649      	mov	r1, r9
   1df50:	4638      	mov	r0, r7
   1df52:	f7ff feab 	bl	1dcac <get_glyph_dsc_id.isra.0.part.1>
        if(gid_next) {
   1df56:	2800      	cmp	r0, #0
   1df58:	d0db      	beq.n	1df12 <lv_font_get_glyph_dsc_fmt_txt+0x2e>
            kvalue = get_kern_value(font, gid, gid_next);
   1df5a:	f8d8 300c 	ldr.w	r3, [r8, #12]
    if(fdsc->kern_classes == 0) {
   1df5e:	68df      	ldr	r7, [r3, #12]
   1df60:	7cdb      	ldrb	r3, [r3, #19]
   1df62:	069b      	lsls	r3, r3, #26
   1df64:	d432      	bmi.n	1dfcc <lv_font_get_glyph_dsc_fmt_txt+0xe8>
        if(kdsc->glyph_ids_size == 0) {
   1df66:	7afb      	ldrb	r3, [r7, #11]
   1df68:	f013 0303 	ands.w	r3, r3, #3
   1df6c:	d117      	bne.n	1df9e <lv_font_get_glyph_dsc_fmt_txt+0xba>
            const uint8_t * g_ids = kdsc->glyph_ids;
   1df6e:	f8d7 8000 	ldr.w	r8, [r7]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
   1df72:	68ba      	ldr	r2, [r7, #8]
   1df74:	4b1d      	ldr	r3, [pc, #116]	; (1dfec <lv_font_get_glyph_dsc_fmt_txt+0x108>)
   1df76:	9300      	str	r3, [sp, #0]
            uint16_t g_id_both = (gid_right << 8) + gid_left; /*Create one number from the ids*/
   1df78:	eb06 2000 	add.w	r0, r6, r0, lsl #8
   1df7c:	f8ad 000c 	strh.w	r0, [sp, #12]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
   1df80:	2302      	movs	r3, #2
   1df82:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
   1df86:	4641      	mov	r1, r8
   1df88:	a803      	add	r0, sp, #12
   1df8a:	f009 fabc 	bl	27506 <lv_utils_bsearch>
            if(kid_p) {
   1df8e:	2800      	cmp	r0, #0
   1df90:	d0c0      	beq.n	1df14 <lv_font_get_glyph_dsc_fmt_txt+0x30>
                lv_uintptr_t ofs = (lv_uintptr_t)(kid_p - g_ids);
   1df92:	eba0 0008 	sub.w	r0, r0, r8
                ofs = ofs >> 1;     /*ofs is for pair, divide by 2 to refer as a single value*/
   1df96:	0840      	lsrs	r0, r0, #1
                value = kdsc->values[ofs];
   1df98:	687b      	ldr	r3, [r7, #4]
   1df9a:	5618      	ldrsb	r0, [r3, r0]
   1df9c:	e7ba      	b.n	1df14 <lv_font_get_glyph_dsc_fmt_txt+0x30>
        } else if(kdsc->glyph_ids_size == 1) {
   1df9e:	2b01      	cmp	r3, #1
   1dfa0:	d1b7      	bne.n	1df12 <lv_font_get_glyph_dsc_fmt_txt+0x2e>
            const uint16_t * g_ids = kdsc->glyph_ids;
   1dfa2:	f8d7 8000 	ldr.w	r8, [r7]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
   1dfa6:	68ba      	ldr	r2, [r7, #8]
   1dfa8:	4b11      	ldr	r3, [pc, #68]	; (1dff0 <lv_font_get_glyph_dsc_fmt_txt+0x10c>)
   1dfaa:	9300      	str	r3, [sp, #0]
            lv_uintptr_t g_id_both = (uint32_t)((uint32_t)gid_right << 8) + gid_left; /*Create one number from the ids*/
   1dfac:	eb06 2000 	add.w	r0, r6, r0, lsl #8
   1dfb0:	9003      	str	r0, [sp, #12]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
   1dfb2:	2304      	movs	r3, #4
   1dfb4:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
   1dfb8:	4641      	mov	r1, r8
   1dfba:	a803      	add	r0, sp, #12
   1dfbc:	f009 faa3 	bl	27506 <lv_utils_bsearch>
            if(kid_p) {
   1dfc0:	2800      	cmp	r0, #0
   1dfc2:	d0a7      	beq.n	1df14 <lv_font_get_glyph_dsc_fmt_txt+0x30>
                lv_uintptr_t ofs = (lv_uintptr_t) (kid_p - (const uint8_t *)g_ids);
   1dfc4:	eba0 0008 	sub.w	r0, r0, r8
                ofs = ofs >> 4;     /*ofs is 4 byte pairs, divide by 4 to refer as a single value*/
   1dfc8:	0900      	lsrs	r0, r0, #4
   1dfca:	e7e5      	b.n	1df98 <lv_font_get_glyph_dsc_fmt_txt+0xb4>
        uint8_t left_class = kdsc->left_class_mapping[gid_left];
   1dfcc:	687a      	ldr	r2, [r7, #4]
   1dfce:	5d93      	ldrb	r3, [r2, r6]
        if(left_class > 0 && right_class > 0) {
   1dfd0:	2b00      	cmp	r3, #0
   1dfd2:	d09e      	beq.n	1df12 <lv_font_get_glyph_dsc_fmt_txt+0x2e>
        uint8_t right_class = kdsc->left_class_mapping[gid_right];
   1dfd4:	5c11      	ldrb	r1, [r2, r0]
        if(left_class > 0 && right_class > 0) {
   1dfd6:	2900      	cmp	r1, #0
   1dfd8:	d09b      	beq.n	1df12 <lv_font_get_glyph_dsc_fmt_txt+0x2e>
            value = kdsc->class_pair_values[(left_class-1)* kdsc->right_class_cnt + (right_class-1)];
   1dfda:	683a      	ldr	r2, [r7, #0]
   1dfdc:	7b78      	ldrb	r0, [r7, #13]
   1dfde:	3b01      	subs	r3, #1
   1dfe0:	440a      	add	r2, r1
   1dfe2:	fb00 2303 	mla	r3, r0, r3, r2
   1dfe6:	f913 0c01 	ldrsb.w	r0, [r3, #-1]
   1dfea:	e793      	b.n	1df14 <lv_font_get_glyph_dsc_fmt_txt+0x30>
   1dfec:	0002796f 	.word	0x0002796f
   1dff0:	00027981 	.word	0x00027981

0001dff4 <z_sys_device_do_config_level>:
		__device_APPLICATION_start,
		/* End marker */
		__device_init_end,
	};

	for (info = config_levels[level]; info < config_levels[level+1];
   1dff4:	4b09      	ldr	r3, [pc, #36]	; (1e01c <z_sys_device_do_config_level+0x28>)
{
   1dff6:	b570      	push	{r4, r5, r6, lr}
	for (info = config_levels[level]; info < config_levels[level+1];
   1dff8:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   1dffc:	3001      	adds	r0, #1
		retval = device_conf->init(info);
		if (retval != 0) {
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
   1dffe:	2600      	movs	r6, #0
	for (info = config_levels[level]; info < config_levels[level+1];
   1e000:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
   1e004:	42a5      	cmp	r5, r4
   1e006:	d800      	bhi.n	1e00a <z_sys_device_do_config_level+0x16>
		} else {
			z_object_init(info);
		}
	}
}
   1e008:	bd70      	pop	{r4, r5, r6, pc}
		retval = device_conf->init(info);
   1e00a:	6823      	ldr	r3, [r4, #0]
   1e00c:	4620      	mov	r0, r4
   1e00e:	685b      	ldr	r3, [r3, #4]
   1e010:	4798      	blx	r3
		if (retval != 0) {
   1e012:	b100      	cbz	r0, 1e016 <z_sys_device_do_config_level+0x22>
			info->driver_api = NULL;
   1e014:	6066      	str	r6, [r4, #4]
								info++) {
   1e016:	340c      	adds	r4, #12
   1e018:	e7f4      	b.n	1e004 <z_sys_device_do_config_level+0x10>
   1e01a:	bf00      	nop
   1e01c:	000297f4 	.word	0x000297f4

0001e020 <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
   1e020:	4b10      	ldr	r3, [pc, #64]	; (1e064 <z_impl_device_get_binding+0x44>)
{
   1e022:	b570      	push	{r4, r5, r6, lr}
	for (info = __device_init_start; info != __device_init_end; info++) {
   1e024:	4c10      	ldr	r4, [pc, #64]	; (1e068 <z_impl_device_get_binding+0x48>)
{
   1e026:	4605      	mov	r5, r0
   1e028:	461e      	mov	r6, r3
	for (info = __device_init_start; info != __device_init_end; info++) {
   1e02a:	429c      	cmp	r4, r3
   1e02c:	d104      	bne.n	1e038 <z_impl_device_get_binding+0x18>
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
   1e02e:	4c0e      	ldr	r4, [pc, #56]	; (1e068 <z_impl_device_get_binding+0x48>)
   1e030:	42b4      	cmp	r4, r6
   1e032:	d109      	bne.n	1e048 <z_impl_device_get_binding+0x28>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
   1e034:	2400      	movs	r4, #0
   1e036:	e012      	b.n	1e05e <z_impl_device_get_binding+0x3e>
		if ((info->driver_api != NULL) &&
   1e038:	6862      	ldr	r2, [r4, #4]
   1e03a:	b11a      	cbz	r2, 1e044 <z_impl_device_get_binding+0x24>
		    (info->config->name == name)) {
   1e03c:	6822      	ldr	r2, [r4, #0]
		if ((info->driver_api != NULL) &&
   1e03e:	6812      	ldr	r2, [r2, #0]
   1e040:	42aa      	cmp	r2, r5
   1e042:	d00c      	beq.n	1e05e <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
   1e044:	340c      	adds	r4, #12
   1e046:	e7f0      	b.n	1e02a <z_impl_device_get_binding+0xa>
		if (info->driver_api == NULL) {
   1e048:	6863      	ldr	r3, [r4, #4]
   1e04a:	b90b      	cbnz	r3, 1e050 <z_impl_device_get_binding+0x30>
	for (info = __device_init_start; info != __device_init_end; info++) {
   1e04c:	340c      	adds	r4, #12
   1e04e:	e7ef      	b.n	1e030 <z_impl_device_get_binding+0x10>
		if (strcmp(name, info->config->name) == 0) {
   1e050:	6823      	ldr	r3, [r4, #0]
   1e052:	4628      	mov	r0, r5
   1e054:	6819      	ldr	r1, [r3, #0]
   1e056:	f7e3 fe15 	bl	1c84 <strcmp>
   1e05a:	2800      	cmp	r0, #0
   1e05c:	d1f6      	bne.n	1e04c <z_impl_device_get_binding+0x2c>
}
   1e05e:	4620      	mov	r0, r4
   1e060:	bd70      	pop	{r4, r5, r6, pc}
   1e062:	bf00      	nop
   1e064:	2000eed8 	.word	0x2000eed8
   1e068:	2000edf4 	.word	0x2000edf4

0001e06c <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
   1e06c:	b510      	push	{r4, lr}
   1e06e:	4604      	mov	r4, r0
	z_impl_log_panic();
   1e070:	f7e6 ffb2 	bl	4fd8 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
   1e074:	2301      	movs	r3, #1
   1e076:	f04f 0100 	mov.w	r1, #0
   1e07a:	f363 0107 	bfi	r1, r3, #0, #8
   1e07e:	4a06      	ldr	r2, [pc, #24]	; (1e098 <k_sys_fatal_error_handler+0x2c>)
   1e080:	4b06      	ldr	r3, [pc, #24]	; (1e09c <k_sys_fatal_error_handler+0x30>)
   1e082:	4807      	ldr	r0, [pc, #28]	; (1e0a0 <k_sys_fatal_error_handler+0x34>)
   1e084:	1a9b      	subs	r3, r3, r2
   1e086:	08db      	lsrs	r3, r3, #3
   1e088:	f363 118f 	bfi	r1, r3, #6, #10
   1e08c:	f002 ffd5 	bl	2103a <log_0>
	arch_system_halt(reason);
   1e090:	4620      	mov	r0, r4
   1e092:	f009 fc96 	bl	279c2 <arch_system_halt>
   1e096:	bf00      	nop
   1e098:	00028540 	.word	0x00028540
   1e09c:	00028690 	.word	0x00028690
   1e0a0:	0006d865 	.word	0x0006d865

0001e0a4 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   1e0a4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   1e0a8:	4605      	mov	r5, r0
   1e0aa:	4688      	mov	r8, r1
	return z_impl_k_current_get();
   1e0ac:	f000 fe60 	bl	1ed70 <z_impl_k_current_get>
	struct k_thread *thread = k_current_get();

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   1e0b0:	2201      	movs	r2, #1
   1e0b2:	f04f 0300 	mov.w	r3, #0
   1e0b6:	f362 0307 	bfi	r3, r2, #0, #8
   1e0ba:	4c24      	ldr	r4, [pc, #144]	; (1e14c <z_fatal_error+0xa8>)
   1e0bc:	4a24      	ldr	r2, [pc, #144]	; (1e150 <z_fatal_error+0xac>)
   1e0be:	2d04      	cmp	r5, #4
   1e0c0:	eba4 0402 	sub.w	r4, r4, r2
   1e0c4:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   1e0c8:	bf96      	itet	ls
   1e0ca:	4a22      	ldrls	r2, [pc, #136]	; (1e154 <z_fatal_error+0xb0>)
   1e0cc:	4a22      	ldrhi	r2, [pc, #136]	; (1e158 <z_fatal_error+0xb4>)
   1e0ce:	f852 2025 	ldrls.w	r2, [r2, r5, lsl #2]
   1e0d2:	f364 138f 	bfi	r3, r4, #6, #10
   1e0d6:	f8ad 3000 	strh.w	r3, [sp]
   1e0da:	4606      	mov	r6, r0
   1e0dc:	2300      	movs	r3, #0
   1e0de:	4629      	mov	r1, r5
   1e0e0:	481e      	ldr	r0, [pc, #120]	; (1e15c <z_fatal_error+0xb8>)
   1e0e2:	f002 ffe3 	bl	210ac <log_3>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   1e0e6:	f8d8 301c 	ldr.w	r3, [r8, #28]
   1e0ea:	f3c3 0308 	ubfx	r3, r3, #0, #9
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if (arch_is_in_nested_exception(esf)) {
   1e0ee:	b14b      	cbz	r3, 1e104 <z_fatal_error+0x60>
		LOG_ERR("Fault during interrupt handling\n");
   1e0f0:	f04f 0100 	mov.w	r1, #0
   1e0f4:	2301      	movs	r3, #1
   1e0f6:	f363 0107 	bfi	r1, r3, #0, #8
   1e0fa:	f364 118f 	bfi	r1, r4, #6, #10
   1e0fe:	4818      	ldr	r0, [pc, #96]	; (1e160 <z_fatal_error+0xbc>)
   1e100:	f002 ff9b 	bl	2103a <log_0>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   1e104:	f04f 0700 	mov.w	r7, #0
   1e108:	2301      	movs	r3, #1
   1e10a:	f363 0707 	bfi	r7, r3, #0, #8
	const char *thread_name = k_thread_name_get(thread);
   1e10e:	4630      	mov	r0, r6
	LOG_ERR("Current thread: %p (%s)", thread,
   1e110:	f364 178f 	bfi	r7, r4, #6, #10
	const char *thread_name = k_thread_name_get(thread);
   1e114:	f009 fe87 	bl	27e26 <k_thread_name_get>
	if (thread_name == NULL || thread_name[0] == '\0') {
   1e118:	b1b0      	cbz	r0, 1e148 <z_fatal_error+0xa4>
   1e11a:	7802      	ldrb	r2, [r0, #0]
		thread_name = "unknown";
   1e11c:	4b11      	ldr	r3, [pc, #68]	; (1e164 <z_fatal_error+0xc0>)
   1e11e:	2a00      	cmp	r2, #0
   1e120:	bf08      	it	eq
   1e122:	4618      	moveq	r0, r3
	LOG_ERR("Current thread: %p (%s)", thread,
   1e124:	f7e6 fdec 	bl	4d00 <log_strdup>
   1e128:	463b      	mov	r3, r7
   1e12a:	4602      	mov	r2, r0
   1e12c:	4631      	mov	r1, r6
   1e12e:	480e      	ldr	r0, [pc, #56]	; (1e168 <z_fatal_error+0xc4>)
   1e130:	f002 ffa4 	bl	2107c <log_2>
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
   1e134:	4641      	mov	r1, r8
   1e136:	4628      	mov	r0, r5
   1e138:	f7ff ff98 	bl	1e06c <k_sys_fatal_error_handler>
	z_impl_k_thread_abort(thread);
   1e13c:	4630      	mov	r0, r6
			}
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	k_thread_abort(thread);
}
   1e13e:	b002      	add	sp, #8
   1e140:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1e144:	f7e9 b8d2 	b.w	72ec <z_impl_k_thread_abort>
		thread_name = "unknown";
   1e148:	4806      	ldr	r0, [pc, #24]	; (1e164 <z_fatal_error+0xc0>)
   1e14a:	e7eb      	b.n	1e124 <z_fatal_error+0x80>
   1e14c:	00028690 	.word	0x00028690
   1e150:	00028540 	.word	0x00028540
   1e154:	0002980c 	.word	0x0002980c
   1e158:	0006d8be 	.word	0x0006d8be
   1e15c:	0006d8cc 	.word	0x0006d8cc
   1e160:	0006d8f4 	.word	0x0006d8f4
   1e164:	00065beb 	.word	0x00065beb
   1e168:	0006d915 	.word	0x0006d915

0001e16c <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
   1e16c:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
   1e16e:	4d0b      	ldr	r5, [pc, #44]	; (1e19c <idle+0x30>)
	__asm__ volatile(
   1e170:	f04f 0220 	mov.w	r2, #32
   1e174:	f3ef 8311 	mrs	r3, BASEPRI
   1e178:	f382 8811 	msr	BASEPRI, r2
   1e17c:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
   1e180:	f009 fef4 	bl	27f6c <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   1e184:	2101      	movs	r1, #1
   1e186:	2802      	cmp	r0, #2
	s32_t ticks = z_get_next_timeout_expiry();
   1e188:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   1e18a:	bfd8      	it	le
   1e18c:	4608      	movle	r0, r1
   1e18e:	f009 fefd 	bl	27f8c <z_set_timeout_expiry>
	_kernel.idle = ticks;
   1e192:	622c      	str	r4, [r5, #32]
	arch_cpu_idle();
   1e194:	f7e8 fd52 	bl	6c3c <arch_cpu_idle>
   1e198:	e7ea      	b.n	1e170 <idle+0x4>
   1e19a:	bf00      	nop
   1e19c:	20006054 	.word	0x20006054

0001e1a0 <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   1e1a0:	4802      	ldr	r0, [pc, #8]	; (1e1ac <z_bss_zero+0xc>)
__ssp_bos_icheck3(memset, void *, int)
   1e1a2:	4a03      	ldr	r2, [pc, #12]	; (1e1b0 <z_bss_zero+0x10>)
   1e1a4:	2100      	movs	r1, #0
   1e1a6:	1a12      	subs	r2, r2, r0
   1e1a8:	f7e3 bd41 	b.w	1c2e <memset>
   1e1ac:	20000000 	.word	0x20000000
   1e1b0:	2000abec 	.word	0x2000abec

0001e1b4 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   1e1b4:	b508      	push	{r3, lr}
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1e1b6:	4806      	ldr	r0, [pc, #24]	; (1e1d0 <z_data_copy+0x1c>)
   1e1b8:	4a06      	ldr	r2, [pc, #24]	; (1e1d4 <z_data_copy+0x20>)
   1e1ba:	4907      	ldr	r1, [pc, #28]	; (1e1d8 <z_data_copy+0x24>)
   1e1bc:	1a12      	subs	r2, r2, r0
   1e1be:	f7e3 fd15 	bl	1bec <memcpy>
   1e1c2:	4a06      	ldr	r2, [pc, #24]	; (1e1dc <z_data_copy+0x28>)
   1e1c4:	4906      	ldr	r1, [pc, #24]	; (1e1e0 <z_data_copy+0x2c>)
   1e1c6:	4807      	ldr	r0, [pc, #28]	; (1e1e4 <z_data_copy+0x30>)
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   1e1c8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   1e1cc:	f7e3 bd0e 	b.w	1bec <memcpy>
   1e1d0:	2000e248 	.word	0x2000e248
   1e1d4:	2000f128 	.word	0x2000f128
   1e1d8:	0006d9ef 	.word	0x0006d9ef
   1e1dc:	00000000 	.word	0x00000000
   1e1e0:	0006d9ec 	.word	0x0006d9ec
   1e1e4:	20000000 	.word	0x20000000

0001e1e8 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
   1e1e8:	b508      	push	{r3, lr}
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
   1e1ea:	4b0b      	ldr	r3, [pc, #44]	; (1e218 <bg_thread_main+0x30>)
   1e1ec:	2201      	movs	r2, #1

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   1e1ee:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   1e1f0:	701a      	strb	r2, [r3, #0]
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   1e1f2:	f7ff feff 	bl	1dff4 <z_sys_device_do_config_level>
			KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
   1e1f6:	2003      	movs	r0, #3
   1e1f8:	f7ff fefc 	bl	1dff4 <z_sys_device_do_config_level>

#ifdef CONFIG_CPLUSPLUS
	/* Process the .ctors and .init_array sections */
	extern void __do_global_ctors_aux(void);
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
   1e1fc:	f7e7 fa8a 	bl	5714 <__do_global_ctors_aux>
	__do_init_array_aux();
   1e200:	f7e7 fa7a 	bl	56f8 <__do_init_array_aux>
#endif

	z_init_static_threads();
   1e204:	f000 feae 	bl	1ef64 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
   1e208:	f7e6 f98c 	bl	4524 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   1e20c:	4a03      	ldr	r2, [pc, #12]	; (1e21c <bg_thread_main+0x34>)
   1e20e:	7b13      	ldrb	r3, [r2, #12]
   1e210:	f023 0301 	bic.w	r3, r3, #1
   1e214:	7313      	strb	r3, [r2, #12]

	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   1e216:	bd08      	pop	{r3, pc}
   1e218:	2000abde 	.word	0x2000abde
   1e21c:	20001f84 	.word	0x20001f84

0001e220 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
   1e220:	b580      	push	{r7, lr}
   1e222:	b0a2      	sub	sp, #136	; 0x88
#endif	/* CONFIG_STACK_CANARIES */

	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
   1e224:	f7e6 fcb6 	bl	4b94 <log_core_init>
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(_interrupt_stack)) +
   1e228:	4b35      	ldr	r3, [pc, #212]	; (1e300 <z_cstart+0xe0>)
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   1e22a:	f383 8808 	msr	MSP, r3
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
   1e22e:	4c35      	ldr	r4, [pc, #212]	; (1e304 <z_cstart+0xe4>)
	_kernel.ready_q.cache = &z_main_thread;
   1e230:	4e35      	ldr	r6, [pc, #212]	; (1e308 <z_cstart+0xe8>)
   1e232:	6963      	ldr	r3, [r4, #20]
   1e234:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   1e238:	6163      	str	r3, [r4, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e23a:	2500      	movs	r5, #0
   1e23c:	23e0      	movs	r3, #224	; 0xe0
   1e23e:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
   1e242:	77e5      	strb	r5, [r4, #31]
   1e244:	7625      	strb	r5, [r4, #24]
   1e246:	7665      	strb	r5, [r4, #25]
   1e248:	76a5      	strb	r5, [r4, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   1e24a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1e24c:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   1e250:	6263      	str	r3, [r4, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   1e252:	f7e9 f837 	bl	72c4 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   1e256:	f7e8 fceb 	bl	6c30 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   1e25a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1e25e:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   1e260:	62e3      	str	r3, [r4, #44]	; 0x2c

	/* perform any architecture-specific initialization */
	arch_kernel_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
   1e262:	ab07      	add	r3, sp, #28
   1e264:	226c      	movs	r2, #108	; 0x6c
   1e266:	4629      	mov	r1, r5
   1e268:	4618      	mov	r0, r3
   1e26a:	f7e3 fce0 	bl	1c2e <memset>
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
   1e26e:	4c27      	ldr	r4, [pc, #156]	; (1e30c <z_cstart+0xec>)
	struct k_thread dummy_thread = {
   1e270:	2701      	movs	r7, #1
	_current = &dummy_thread;
   1e272:	60a0      	str	r0, [r4, #8]
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   1e274:	4628      	mov	r0, r5
	struct k_thread dummy_thread = {
   1e276:	f88d 7029 	strb.w	r7, [sp, #41]	; 0x29
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   1e27a:	f7ff febb 	bl	1dff4 <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   1e27e:	4638      	mov	r0, r7
   1e280:	f7ff feb8 	bl	1dff4 <z_sys_device_do_config_level>
	z_sched_init();
   1e284:	f000 fcf4 	bl	1ec70 <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
   1e288:	4b21      	ldr	r3, [pc, #132]	; (1e310 <z_cstart+0xf0>)
	_kernel.ready_q.cache = &z_main_thread;
   1e28a:	6266      	str	r6, [r4, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
   1e28c:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1e290:	e9cd 7304 	strd	r7, r3, [sp, #16]
   1e294:	e9cd 5502 	strd	r5, r5, [sp, #8]
   1e298:	4b1e      	ldr	r3, [pc, #120]	; (1e314 <z_cstart+0xf4>)
   1e29a:	491f      	ldr	r1, [pc, #124]	; (1e318 <z_cstart+0xf8>)
   1e29c:	e9cd 5500 	strd	r5, r5, [sp]
   1e2a0:	4630      	mov	r0, r6
   1e2a2:	f000 fdf7 	bl	1ee94 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   1e2a6:	7b73      	ldrb	r3, [r6, #13]
   1e2a8:	f023 0204 	bic.w	r2, r3, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1e2ac:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
   1e2b0:	7372      	strb	r2, [r6, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1e2b2:	d104      	bne.n	1e2be <z_cstart+0x9e>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
   1e2b4:	69b3      	ldr	r3, [r6, #24]
   1e2b6:	b913      	cbnz	r3, 1e2be <z_cstart+0x9e>
		z_add_thread_to_ready_q(thread);
   1e2b8:	4630      	mov	r0, r6
   1e2ba:	f000 faa3 	bl	1e804 <z_add_thread_to_ready_q>
	z_setup_new_thread(thread, stack,
   1e2be:	4b17      	ldr	r3, [pc, #92]	; (1e31c <z_cstart+0xfc>)
   1e2c0:	4d17      	ldr	r5, [pc, #92]	; (1e320 <z_cstart+0x100>)
   1e2c2:	9305      	str	r3, [sp, #20]
   1e2c4:	2201      	movs	r2, #1
   1e2c6:	230f      	movs	r3, #15
   1e2c8:	e9cd 3203 	strd	r3, r2, [sp, #12]
   1e2cc:	2300      	movs	r3, #0
   1e2ce:	e9cd 3301 	strd	r3, r3, [sp, #4]
   1e2d2:	9300      	str	r3, [sp, #0]
   1e2d4:	f44f 72a0 	mov.w	r2, #320	; 0x140
   1e2d8:	4b12      	ldr	r3, [pc, #72]	; (1e324 <z_cstart+0x104>)
   1e2da:	4913      	ldr	r1, [pc, #76]	; (1e328 <z_cstart+0x108>)
   1e2dc:	4628      	mov	r0, r5
   1e2de:	f000 fdd9 	bl	1ee94 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_PRESTART;
   1e2e2:	7b6b      	ldrb	r3, [r5, #13]
	_kernel.cpus[0].idle_thread = &z_idle_thread;
   1e2e4:	60e5      	str	r5, [r4, #12]
   1e2e6:	f023 0304 	bic.w	r3, r3, #4
   1e2ea:	736b      	strb	r3, [r5, #13]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
   1e2ec:	4b0f      	ldr	r3, [pc, #60]	; (1e32c <z_cstart+0x10c>)
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
   1e2ee:	490a      	ldr	r1, [pc, #40]	; (1e318 <z_cstart+0xf8>)
   1e2f0:	4805      	ldr	r0, [pc, #20]	; (1e308 <z_cstart+0xe8>)
	list->tail = (sys_dnode_t *)list;
   1e2f2:	e9c4 3306 	strd	r3, r3, [r4, #24]
   1e2f6:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1e2fa:	4b06      	ldr	r3, [pc, #24]	; (1e314 <z_cstart+0xf4>)
   1e2fc:	f7e8 fc7a 	bl	6bf4 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   1e300:	2000cec0 	.word	0x2000cec0
   1e304:	e000ed00 	.word	0xe000ed00
   1e308:	20001f84 	.word	0x20001f84
   1e30c:	20006054 	.word	0x20006054
   1e310:	0006d930 	.word	0x0006d930
   1e314:	0001e1e9 	.word	0x0001e1e9
   1e318:	2000c180 	.word	0x2000c180
   1e31c:	0006d935 	.word	0x0006d935
   1e320:	20001f18 	.word	0x20001f18
   1e324:	0001e16d 	.word	0x0001e16d
   1e328:	2000c580 	.word	0x2000c580
   1e32c:	2000606c 	.word	0x2000606c

0001e330 <init_mem_slab_module>:
 */
static int init_mem_slab_module(struct device *dev)
{
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   1e330:	4b0b      	ldr	r3, [pc, #44]	; (1e360 <init_mem_slab_module+0x30>)
   1e332:	480c      	ldr	r0, [pc, #48]	; (1e364 <init_mem_slab_module+0x34>)
{
   1e334:	b570      	push	{r4, r5, r6, lr}
	slab->free_list = NULL;
   1e336:	2400      	movs	r4, #0
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   1e338:	4283      	cmp	r3, r0
   1e33a:	d301      	bcc.n	1e340 <init_mem_slab_module+0x10>
		create_free_list(slab);
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}
	return 0;
}
   1e33c:	2000      	movs	r0, #0
   1e33e:	bd70      	pop	{r4, r5, r6, pc}
	p = slab->buffer;
   1e340:	691a      	ldr	r2, [r3, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
   1e342:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
   1e344:	615c      	str	r4, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   1e346:	2100      	movs	r1, #0
   1e348:	42a9      	cmp	r1, r5
   1e34a:	d101      	bne.n	1e350 <init_mem_slab_module+0x20>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   1e34c:	331c      	adds	r3, #28
   1e34e:	e7f3      	b.n	1e338 <init_mem_slab_module+0x8>
		*(char **)p = slab->free_list;
   1e350:	695e      	ldr	r6, [r3, #20]
   1e352:	6016      	str	r6, [r2, #0]
		p += slab->block_size;
   1e354:	68de      	ldr	r6, [r3, #12]
		slab->free_list = p;
   1e356:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   1e358:	3101      	adds	r1, #1
		p += slab->block_size;
   1e35a:	4432      	add	r2, r6
   1e35c:	e7f4      	b.n	1e348 <init_mem_slab_module+0x18>
   1e35e:	bf00      	nop
   1e360:	2000eed8 	.word	0x2000eed8
   1e364:	2000ef10 	.word	0x2000ef10

0001e368 <k_mem_slab_alloc>:

	z_object_init(slab);
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, s32_t timeout)
{
   1e368:	b510      	push	{r4, lr}
   1e36a:	4613      	mov	r3, r2
   1e36c:	460c      	mov	r4, r1
   1e36e:	f04f 0220 	mov.w	r2, #32
   1e372:	f3ef 8111 	mrs	r1, BASEPRI
   1e376:	f382 8811 	msr	BASEPRI, r2
   1e37a:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
   1e37e:	6942      	ldr	r2, [r0, #20]
   1e380:	b15a      	cbz	r2, 1e39a <k_mem_slab_alloc+0x32>
		/* take a free block */
		*mem = slab->free_list;
   1e382:	6022      	str	r2, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
   1e384:	6813      	ldr	r3, [r2, #0]
   1e386:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   1e388:	6983      	ldr	r3, [r0, #24]
   1e38a:	3301      	adds	r3, #1
   1e38c:	6183      	str	r3, [r0, #24]
		result = 0;
   1e38e:	2000      	movs	r0, #0
	__asm__ volatile(
   1e390:	f381 8811 	msr	BASEPRI, r1
   1e394:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
   1e398:	e00d      	b.n	1e3b6 <k_mem_slab_alloc+0x4e>
	} else if (timeout == K_NO_WAIT) {
   1e39a:	b91b      	cbnz	r3, 1e3a4 <k_mem_slab_alloc+0x3c>
		*mem = NULL;
   1e39c:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
   1e39e:	f06f 000b 	mvn.w	r0, #11
   1e3a2:	e7f5      	b.n	1e390 <k_mem_slab_alloc+0x28>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
   1e3a4:	4602      	mov	r2, r0
   1e3a6:	4804      	ldr	r0, [pc, #16]	; (1e3b8 <k_mem_slab_alloc+0x50>)
   1e3a8:	f000 fbde 	bl	1eb68 <z_pend_curr>
		if (result == 0) {
   1e3ac:	b918      	cbnz	r0, 1e3b6 <k_mem_slab_alloc+0x4e>
			*mem = _current->base.swap_data;
   1e3ae:	4b03      	ldr	r3, [pc, #12]	; (1e3bc <k_mem_slab_alloc+0x54>)
   1e3b0:	689b      	ldr	r3, [r3, #8]
   1e3b2:	695b      	ldr	r3, [r3, #20]
   1e3b4:	6023      	str	r3, [r4, #0]
}
   1e3b6:	bd10      	pop	{r4, pc}
   1e3b8:	2000abdf 	.word	0x2000abdf
   1e3bc:	20006054 	.word	0x20006054

0001e3c0 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   1e3c0:	b570      	push	{r4, r5, r6, lr}
   1e3c2:	4604      	mov	r4, r0
   1e3c4:	460d      	mov	r5, r1
	__asm__ volatile(
   1e3c6:	f04f 0320 	mov.w	r3, #32
   1e3ca:	f3ef 8611 	mrs	r6, BASEPRI
   1e3ce:	f383 8811 	msr	BASEPRI, r3
   1e3d2:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   1e3d6:	f009 fcd5 	bl	27d84 <z_unpend_first_thread>

	if (pending_thread != NULL) {
   1e3da:	b180      	cbz	r0, 1e3fe <k_mem_slab_free+0x3e>
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   1e3dc:	682a      	ldr	r2, [r5, #0]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   1e3de:	6142      	str	r2, [r0, #20]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1e3e0:	7b42      	ldrb	r2, [r0, #13]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   1e3e2:	2100      	movs	r1, #0
   1e3e4:	06d2      	lsls	r2, r2, #27
   1e3e6:	6681      	str	r1, [r0, #104]	; 0x68
   1e3e8:	d103      	bne.n	1e3f2 <k_mem_slab_free+0x32>
	if (z_is_thread_ready(thread)) {
   1e3ea:	6983      	ldr	r3, [r0, #24]
   1e3ec:	b90b      	cbnz	r3, 1e3f2 <k_mem_slab_free+0x32>
		z_add_thread_to_ready_q(thread);
   1e3ee:	f000 fa09 	bl	1e804 <z_add_thread_to_ready_q>
		z_ready_thread(pending_thread);
		z_reschedule(&lock, key);
   1e3f2:	4631      	mov	r1, r6
   1e3f4:	4808      	ldr	r0, [pc, #32]	; (1e418 <k_mem_slab_free+0x58>)
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
   1e3f6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   1e3fa:	f009 bc4d 	b.w	27c98 <z_reschedule>
		**(char ***)mem = slab->free_list;
   1e3fe:	682b      	ldr	r3, [r5, #0]
   1e400:	6962      	ldr	r2, [r4, #20]
   1e402:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
   1e404:	682b      	ldr	r3, [r5, #0]
   1e406:	6163      	str	r3, [r4, #20]
		slab->num_used--;
   1e408:	69a3      	ldr	r3, [r4, #24]
   1e40a:	3b01      	subs	r3, #1
   1e40c:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   1e40e:	f386 8811 	msr	BASEPRI, r6
   1e412:	f3bf 8f6f 	isb	sy
}
   1e416:	bd70      	pop	{r4, r5, r6, pc}
   1e418:	2000abdf 	.word	0x2000abdf

0001e41c <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
   1e41c:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);

	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
   1e41e:	4c07      	ldr	r4, [pc, #28]	; (1e43c <init_static_pools+0x20>)
   1e420:	4d07      	ldr	r5, [pc, #28]	; (1e440 <init_static_pools+0x24>)
   1e422:	42ac      	cmp	r4, r5
   1e424:	d301      	bcc.n	1e42a <init_static_pools+0xe>
		k_mem_pool_init(p);
	}

	return 0;
}
   1e426:	2000      	movs	r0, #0
   1e428:	bd38      	pop	{r3, r4, r5, pc}
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   1e42a:	f104 0314 	add.w	r3, r4, #20
	z_sys_mem_pool_base_init(&p->base);
   1e42e:	4620      	mov	r0, r4
   1e430:	e9c4 3305 	strd	r3, r3, [r4, #20]
   1e434:	f001 f999 	bl	1f76a <z_sys_mem_pool_base_init>
	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
   1e438:	341c      	adds	r4, #28
   1e43a:	e7f2      	b.n	1e422 <init_static_pools+0x6>
   1e43c:	2000ef10 	.word	0x2000ef10
   1e440:	2000ef2c 	.word	0x2000ef2c

0001e444 <k_mem_pool_alloc>:

SYS_INIT(init_static_pools, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, s32_t timeout)
{
   1e444:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int ret;
	s64_t end = 0;

	__ASSERT(!(arch_is_in_isr() && timeout != K_NO_WAIT), "");

	if (timeout > 0) {
   1e448:	1e1c      	subs	r4, r3, #0
{
   1e44a:	b085      	sub	sp, #20
   1e44c:	4607      	mov	r7, r0
   1e44e:	460d      	mov	r5, r1
   1e450:	4692      	mov	sl, r2
	if (timeout > 0) {
   1e452:	dd3b      	ble.n	1e4cc <k_mem_pool_alloc+0x88>
	return z_impl_k_uptime_get();
   1e454:	f009 fdb8 	bl	27fc8 <z_impl_k_uptime_get>
		end = k_uptime_get() + timeout;
   1e458:	eb10 0804 	adds.w	r8, r0, r4
	return pool - &_k_mem_pool_list_start[0];
   1e45c:	4b1d      	ldr	r3, [pc, #116]	; (1e4d4 <k_mem_pool_alloc+0x90>)
   1e45e:	4e1e      	ldr	r6, [pc, #120]	; (1e4d8 <k_mem_pool_alloc+0x94>)
   1e460:	1afb      	subs	r3, r7, r3
   1e462:	109b      	asrs	r3, r3, #2
   1e464:	435e      	muls	r6, r3
		u32_t level_num, block_num;

		ret = z_sys_mem_pool_block_alloc(&p->base, size,
						 &level_num, &block_num,
						 &block->data);
		block->id.pool = pool_id(p);
   1e466:	b2f6      	uxtb	r6, r6
		if (ret == 0 || timeout == K_NO_WAIT ||
		    ret != -ENOMEM) {
			return ret;
		}

		z_pend_curr_unlocked(&p->wait_q, timeout);
   1e468:	f107 0b14 	add.w	fp, r7, #20
		ret = z_sys_mem_pool_block_alloc(&p->base, size,
   1e46c:	ab03      	add	r3, sp, #12
   1e46e:	aa02      	add	r2, sp, #8
   1e470:	9500      	str	r5, [sp, #0]
   1e472:	4651      	mov	r1, sl
   1e474:	4638      	mov	r0, r7
   1e476:	f001 f9be 	bl	1f7f6 <z_sys_mem_pool_block_alloc>
		block->id.level = level_num;
   1e47a:	796b      	ldrb	r3, [r5, #5]
   1e47c:	9a02      	ldr	r2, [sp, #8]
		block->id.pool = pool_id(p);
   1e47e:	712e      	strb	r6, [r5, #4]
		block->id.level = level_num;
   1e480:	f362 0303 	bfi	r3, r2, #0, #4
   1e484:	716b      	strb	r3, [r5, #5]
		block->id.block = block_num;
   1e486:	686b      	ldr	r3, [r5, #4]
   1e488:	9a03      	ldr	r2, [sp, #12]
   1e48a:	f362 331f 	bfi	r3, r2, #12, #20
   1e48e:	606b      	str	r3, [r5, #4]
		if (ret == 0 || timeout == K_NO_WAIT ||
   1e490:	b1c8      	cbz	r0, 1e4c6 <k_mem_pool_alloc+0x82>
   1e492:	b1c4      	cbz	r4, 1e4c6 <k_mem_pool_alloc+0x82>
   1e494:	f110 0f0c 	cmn.w	r0, #12
   1e498:	d115      	bne.n	1e4c6 <k_mem_pool_alloc+0x82>
	__asm__ volatile(
   1e49a:	f04f 0320 	mov.w	r3, #32
   1e49e:	f3ef 8011 	mrs	r0, BASEPRI
   1e4a2:	f383 8811 	msr	BASEPRI, r3
   1e4a6:	f3bf 8f6f 	isb	sy
	(void) z_pend_curr_irqlock(arch_irq_lock(), wait_q, timeout);
   1e4aa:	4622      	mov	r2, r4
   1e4ac:	4659      	mov	r1, fp
   1e4ae:	f000 fb37 	bl	1eb20 <z_pend_curr_irqlock>

		if (timeout != K_FOREVER) {
   1e4b2:	1c63      	adds	r3, r4, #1
   1e4b4:	d0da      	beq.n	1e46c <k_mem_pool_alloc+0x28>
   1e4b6:	f009 fd87 	bl	27fc8 <z_impl_k_uptime_get>
			timeout = end - k_uptime_get();
   1e4ba:	eba8 0400 	sub.w	r4, r8, r0
			if (timeout <= 0) {
   1e4be:	2c00      	cmp	r4, #0
   1e4c0:	dcd4      	bgt.n	1e46c <k_mem_pool_alloc+0x28>
				break;
			}
		}
	}

	return -EAGAIN;
   1e4c2:	f06f 000a 	mvn.w	r0, #10
}
   1e4c6:	b005      	add	sp, #20
   1e4c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	s64_t end = 0;
   1e4cc:	f04f 0800 	mov.w	r8, #0
   1e4d0:	e7c4      	b.n	1e45c <k_mem_pool_alloc+0x18>
   1e4d2:	bf00      	nop
   1e4d4:	2000ef10 	.word	0x2000ef10
   1e4d8:	b6db6db7 	.word	0xb6db6db7

0001e4dc <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
   1e4dc:	b570      	push	{r4, r5, r6, lr}
   1e4de:	7804      	ldrb	r4, [r0, #0]
	int need_sched = 0;
	struct k_mem_pool *p = get_pool(id->pool);

	z_sys_mem_pool_block_free(&p->base, id->level, id->block);
   1e4e0:	6802      	ldr	r2, [r0, #0]
   1e4e2:	7841      	ldrb	r1, [r0, #1]
   1e4e4:	4e11      	ldr	r6, [pc, #68]	; (1e52c <k_mem_pool_free_id+0x50>)
   1e4e6:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   1e4ea:	00a4      	lsls	r4, r4, #2
   1e4ec:	0b12      	lsrs	r2, r2, #12
   1e4ee:	f001 010f 	and.w	r1, r1, #15
   1e4f2:	1930      	adds	r0, r6, r4
   1e4f4:	f001 fa32 	bl	1f95c <z_sys_mem_pool_block_free>
   1e4f8:	f04f 0320 	mov.w	r3, #32
   1e4fc:	f3ef 8511 	mrs	r5, BASEPRI
   1e500:	f383 8811 	msr	BASEPRI, r3
   1e504:	f3bf 8f6f 	isb	sy
	 * is unsynchronized.  Maybe we want to put the lock into the
	 * wait_q instead and make the API safe?)
	 */
	k_spinlock_key_t key = k_spin_lock(&lock);

	need_sched = z_unpend_all(&p->wait_q);
   1e508:	f104 0014 	add.w	r0, r4, #20
   1e50c:	4430      	add	r0, r6
   1e50e:	f009 fc66 	bl	27dde <z_unpend_all>

	if (need_sched != 0) {
   1e512:	b128      	cbz	r0, 1e520 <k_mem_pool_free_id+0x44>
		z_reschedule(&lock, key);
   1e514:	4629      	mov	r1, r5
   1e516:	4806      	ldr	r0, [pc, #24]	; (1e530 <k_mem_pool_free_id+0x54>)
	} else {
		k_spin_unlock(&lock, key);
	}
}
   1e518:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   1e51c:	f009 bbbc 	b.w	27c98 <z_reschedule>
	__asm__ volatile(
   1e520:	f385 8811 	msr	BASEPRI, r5
   1e524:	f3bf 8f6f 	isb	sy
}
   1e528:	bd70      	pop	{r4, r5, r6, pc}
   1e52a:	bf00      	nop
   1e52c:	2000ef10 	.word	0x2000ef10
   1e530:	2000abe0 	.word	0x2000abe0

0001e534 <k_malloc>:
		  CONFIG_HEAP_MEM_POOL_SIZE, 1, 4);
#define _HEAP_MEM_POOL (&_heap_mem_pool)

void *k_malloc(size_t size)
{
	return k_mem_pool_malloc(_HEAP_MEM_POOL, size);
   1e534:	4601      	mov	r1, r0
   1e536:	4801      	ldr	r0, [pc, #4]	; (1e53c <k_malloc+0x8>)
   1e538:	f009 ba60 	b.w	279fc <k_mem_pool_malloc>
   1e53c:	2000ef10 	.word	0x2000ef10

0001e540 <z_thread_malloc>:

void *z_thread_malloc(size_t size)
{
	void *ret;

	if (_current->resource_pool != NULL) {
   1e540:	4b03      	ldr	r3, [pc, #12]	; (1e550 <z_thread_malloc+0x10>)
   1e542:	689b      	ldr	r3, [r3, #8]
{
   1e544:	4601      	mov	r1, r0
	if (_current->resource_pool != NULL) {
   1e546:	6e18      	ldr	r0, [r3, #96]	; 0x60
   1e548:	b108      	cbz	r0, 1e54e <z_thread_malloc+0xe>
		ret = k_mem_pool_malloc(_current->resource_pool, size);
   1e54a:	f009 ba57 	b.w	279fc <k_mem_pool_malloc>
	} else {
		ret = NULL;
	}

	return ret;
}
   1e54e:	4770      	bx	lr
   1e550:	20006054 	.word	0x20006054

0001e554 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, s32_t timeout)
{
   1e554:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e556:	4604      	mov	r4, r0
   1e558:	460f      	mov	r7, r1
	__asm__ volatile(
   1e55a:	f04f 0320 	mov.w	r3, #32
   1e55e:	f3ef 8511 	mrs	r5, BASEPRI
   1e562:	f383 8811 	msr	BASEPRI, r3
   1e566:	f3bf 8f6f 	isb	sy
	bool resched = false;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   1e56a:	68c2      	ldr	r2, [r0, #12]
   1e56c:	4930      	ldr	r1, [pc, #192]	; (1e630 <z_impl_k_mutex_lock+0xdc>)
   1e56e:	b15a      	cbz	r2, 1e588 <z_impl_k_mutex_lock+0x34>
   1e570:	6880      	ldr	r0, [r0, #8]
   1e572:	688e      	ldr	r6, [r1, #8]
   1e574:	42b0      	cmp	r0, r6
   1e576:	d015      	beq.n	1e5a4 <z_impl_k_mutex_lock+0x50>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
	}

	if (unlikely(timeout == (s32_t)K_NO_WAIT)) {
   1e578:	b9b7      	cbnz	r7, 1e5a8 <z_impl_k_mutex_lock+0x54>
	__asm__ volatile(
   1e57a:	f385 8811 	msr	BASEPRI, r5
   1e57e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
   1e582:	f06f 000f 	mvn.w	r0, #15
   1e586:	e00c      	b.n	1e5a2 <z_impl_k_mutex_lock+0x4e>
					_current->base.prio :
   1e588:	688b      	ldr	r3, [r1, #8]
   1e58a:	f993 300e 	ldrsb.w	r3, [r3, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   1e58e:	6123      	str	r3, [r4, #16]
		mutex->lock_count++;
   1e590:	3201      	adds	r2, #1
		mutex->owner = _current;
   1e592:	688b      	ldr	r3, [r1, #8]
		mutex->lock_count++;
   1e594:	60e2      	str	r2, [r4, #12]
		mutex->owner = _current;
   1e596:	60a3      	str	r3, [r4, #8]
   1e598:	f385 8811 	msr	BASEPRI, r5
   1e59c:	f3bf 8f6f 	isb	sy
		return 0;
   1e5a0:	2000      	movs	r0, #0
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
   1e5a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					_current->base.prio :
   1e5a4:	6923      	ldr	r3, [r4, #16]
   1e5a6:	e7f2      	b.n	1e58e <z_impl_k_mutex_lock+0x3a>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   1e5a8:	f990 300e 	ldrsb.w	r3, [r0, #14]
   1e5ac:	f996 100e 	ldrsb.w	r1, [r6, #14]
   1e5b0:	4299      	cmp	r1, r3
   1e5b2:	bfa8      	it	ge
   1e5b4:	4619      	movge	r1, r3
   1e5b6:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   1e5ba:	4299      	cmp	r1, r3
   1e5bc:	da2b      	bge.n	1e616 <z_impl_k_mutex_lock+0xc2>
		return z_set_prio(mutex->owner, new_prio);
   1e5be:	f000 fb15 	bl	1ebec <z_set_prio>
   1e5c2:	4606      	mov	r6, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   1e5c4:	463b      	mov	r3, r7
   1e5c6:	4622      	mov	r2, r4
   1e5c8:	4629      	mov	r1, r5
   1e5ca:	481a      	ldr	r0, [pc, #104]	; (1e634 <z_impl_k_mutex_lock+0xe0>)
   1e5cc:	f000 facc 	bl	1eb68 <z_pend_curr>
	if (got_mutex == 0) {
   1e5d0:	2800      	cmp	r0, #0
   1e5d2:	d0e6      	beq.n	1e5a2 <z_impl_k_mutex_lock+0x4e>
	__asm__ volatile(
   1e5d4:	f04f 0320 	mov.w	r3, #32
   1e5d8:	f3ef 8511 	mrs	r5, BASEPRI
   1e5dc:	f383 8811 	msr	BASEPRI, r3
   1e5e0:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   1e5e4:	6823      	ldr	r3, [r4, #0]
   1e5e6:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1e5e8:	429c      	cmp	r4, r3
   1e5ea:	d007      	beq.n	1e5fc <z_impl_k_mutex_lock+0xa8>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   1e5ec:	b133      	cbz	r3, 1e5fc <z_impl_k_mutex_lock+0xa8>
   1e5ee:	f993 300e 	ldrsb.w	r3, [r3, #14]
   1e5f2:	4299      	cmp	r1, r3
   1e5f4:	bfa8      	it	ge
   1e5f6:	4619      	movge	r1, r3
   1e5f8:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   1e5fc:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   1e5fe:	f990 300e 	ldrsb.w	r3, [r0, #14]
   1e602:	4299      	cmp	r1, r3
   1e604:	d109      	bne.n	1e61a <z_impl_k_mutex_lock+0xc6>
	if (resched) {
   1e606:	b16e      	cbz	r6, 1e624 <z_impl_k_mutex_lock+0xd0>
		z_reschedule(&lock, key);
   1e608:	4629      	mov	r1, r5
   1e60a:	480a      	ldr	r0, [pc, #40]	; (1e634 <z_impl_k_mutex_lock+0xe0>)
   1e60c:	f009 fb44 	bl	27c98 <z_reschedule>
	return -EAGAIN;
   1e610:	f06f 000a 	mvn.w	r0, #10
   1e614:	e7c5      	b.n	1e5a2 <z_impl_k_mutex_lock+0x4e>
	bool resched = false;
   1e616:	2600      	movs	r6, #0
   1e618:	e7d4      	b.n	1e5c4 <z_impl_k_mutex_lock+0x70>
		return z_set_prio(mutex->owner, new_prio);
   1e61a:	f000 fae7 	bl	1ebec <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   1e61e:	2800      	cmp	r0, #0
   1e620:	d1f2      	bne.n	1e608 <z_impl_k_mutex_lock+0xb4>
   1e622:	e7f0      	b.n	1e606 <z_impl_k_mutex_lock+0xb2>
	__asm__ volatile(
   1e624:	f385 8811 	msr	BASEPRI, r5
   1e628:	f3bf 8f6f 	isb	sy
   1e62c:	e7f0      	b.n	1e610 <z_impl_k_mutex_lock+0xbc>
   1e62e:	bf00      	nop
   1e630:	20006054 	.word	0x20006054
   1e634:	2000abe1 	.word	0x2000abe1

0001e638 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

void z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   1e638:	b538      	push	{r3, r4, r5, lr}
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
   1e63a:	4b1d      	ldr	r3, [pc, #116]	; (1e6b0 <z_impl_k_mutex_unlock+0x78>)
   1e63c:	689a      	ldr	r2, [r3, #8]
   1e63e:	7bd3      	ldrb	r3, [r2, #15]
   1e640:	3b01      	subs	r3, #1
   1e642:	4604      	mov	r4, r0
   1e644:	73d3      	strb	r3, [r2, #15]
	sys_trace_void(SYS_TRACE_ID_MUTEX_UNLOCK);
	z_sched_lock();

	K_DEBUG("mutex %p lock_count: %d\n", mutex, mutex->lock_count);

	if (mutex->lock_count - 1U != 0U) {
   1e646:	68c3      	ldr	r3, [r0, #12]
   1e648:	2b01      	cmp	r3, #1
   1e64a:	d005      	beq.n	1e658 <z_impl_k_mutex_unlock+0x20>
		mutex->lock_count--;
   1e64c:	3b01      	subs	r3, #1
   1e64e:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	k_sched_unlock();
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);
}
   1e650:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	k_sched_unlock();
   1e654:	f000 b8ba 	b.w	1e7cc <k_sched_unlock>
	__asm__ volatile(
   1e658:	f04f 0320 	mov.w	r3, #32
   1e65c:	f3ef 8511 	mrs	r5, BASEPRI
   1e660:	f383 8811 	msr	BASEPRI, r3
   1e664:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   1e668:	6901      	ldr	r1, [r0, #16]
   1e66a:	6880      	ldr	r0, [r0, #8]
	if (mutex->owner->base.prio != new_prio) {
   1e66c:	f990 300e 	ldrsb.w	r3, [r0, #14]
   1e670:	4299      	cmp	r1, r3
   1e672:	d001      	beq.n	1e678 <z_impl_k_mutex_unlock+0x40>
		return z_set_prio(mutex->owner, new_prio);
   1e674:	f000 faba 	bl	1ebec <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   1e678:	4620      	mov	r0, r4
   1e67a:	f009 fb83 	bl	27d84 <z_unpend_first_thread>
	mutex->owner = new_owner;
   1e67e:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   1e680:	b180      	cbz	r0, 1e6a4 <z_impl_k_mutex_unlock+0x6c>
		mutex->owner_orig_prio = new_owner->base.prio;
   1e682:	f990 200e 	ldrsb.w	r2, [r0, #14]
   1e686:	6122      	str	r2, [r4, #16]
   1e688:	2200      	movs	r2, #0
   1e68a:	6682      	str	r2, [r0, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1e68c:	7b42      	ldrb	r2, [r0, #13]
   1e68e:	06d2      	lsls	r2, r2, #27
   1e690:	d103      	bne.n	1e69a <z_impl_k_mutex_unlock+0x62>
	if (z_is_thread_ready(thread)) {
   1e692:	6983      	ldr	r3, [r0, #24]
   1e694:	b90b      	cbnz	r3, 1e69a <z_impl_k_mutex_unlock+0x62>
		z_add_thread_to_ready_q(thread);
   1e696:	f000 f8b5 	bl	1e804 <z_add_thread_to_ready_q>
		z_reschedule(&lock, key);
   1e69a:	4629      	mov	r1, r5
   1e69c:	4805      	ldr	r0, [pc, #20]	; (1e6b4 <z_impl_k_mutex_unlock+0x7c>)
   1e69e:	f009 fafb 	bl	27c98 <z_reschedule>
   1e6a2:	e7d5      	b.n	1e650 <z_impl_k_mutex_unlock+0x18>
		mutex->lock_count = 0U;
   1e6a4:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   1e6a6:	f385 8811 	msr	BASEPRI, r5
   1e6aa:	f3bf 8f6f 	isb	sy
   1e6ae:	e7cf      	b.n	1e650 <z_impl_k_mutex_unlock+0x18>
   1e6b0:	20006054 	.word	0x20006054
   1e6b4:	2000abe1 	.word	0x2000abe1

0001e6b8 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
   1e6b8:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
   1e6ba:	4c08      	ldr	r4, [pc, #32]	; (1e6dc <z_reset_time_slice+0x24>)
   1e6bc:	6823      	ldr	r3, [r4, #0]
   1e6be:	b15b      	cbz	r3, 1e6d8 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   1e6c0:	f7e8 f902 	bl	68c8 <z_clock_elapsed>
   1e6c4:	6823      	ldr	r3, [r4, #0]
   1e6c6:	4a06      	ldr	r2, [pc, #24]	; (1e6e0 <z_reset_time_slice+0x28>)
   1e6c8:	4418      	add	r0, r3
   1e6ca:	6110      	str	r0, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
   1e6cc:	2100      	movs	r1, #0
   1e6ce:	4618      	mov	r0, r3
	}
}
   1e6d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_set_timeout_expiry(slice_time, false);
   1e6d4:	f009 bc5a 	b.w	27f8c <z_set_timeout_expiry>
}
   1e6d8:	bd10      	pop	{r4, pc}
   1e6da:	bf00      	nop
   1e6dc:	2000608c 	.word	0x2000608c
   1e6e0:	20006054 	.word	0x20006054

0001e6e4 <k_sched_time_slice_set>:

void k_sched_time_slice_set(s32_t slice, int prio)
{
   1e6e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e6e6:	460d      	mov	r5, r1
	__asm__ volatile(
   1e6e8:	f04f 0320 	mov.w	r3, #32
   1e6ec:	f3ef 8411 	mrs	r4, BASEPRI
   1e6f0:	f383 8811 	msr	BASEPRI, r3
   1e6f4:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
   1e6f8:	4b0d      	ldr	r3, [pc, #52]	; (1e730 <k_sched_time_slice_set+0x4c>)
			return (u32_t)((t * to_hz + off) / from_hz);
   1e6fa:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   1e6fe:	f240 36e7 	movw	r6, #999	; 0x3e7
   1e702:	2700      	movs	r7, #0
   1e704:	fbe1 6700 	umlal	r6, r7, r1, r0
   1e708:	2200      	movs	r2, #0
   1e70a:	611a      	str	r2, [r3, #16]
   1e70c:	4630      	mov	r0, r6
   1e70e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1e712:	2300      	movs	r3, #0
   1e714:	4639      	mov	r1, r7
   1e716:	f7e1 fd33 	bl	180 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
   1e71a:	4b06      	ldr	r3, [pc, #24]	; (1e734 <k_sched_time_slice_set+0x50>)
   1e71c:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
   1e71e:	4b06      	ldr	r3, [pc, #24]	; (1e738 <k_sched_time_slice_set+0x54>)
   1e720:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
   1e722:	f7ff ffc9 	bl	1e6b8 <z_reset_time_slice>
	__asm__ volatile(
   1e726:	f384 8811 	msr	BASEPRI, r4
   1e72a:	f3bf 8f6f 	isb	sy
	}
}
   1e72e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e730:	20006054 	.word	0x20006054
   1e734:	2000608c 	.word	0x2000608c
   1e738:	20006088 	.word	0x20006088

0001e73c <k_sched_lock>:
	__asm__ volatile(
   1e73c:	f04f 0320 	mov.w	r3, #32
   1e740:	f3ef 8111 	mrs	r1, BASEPRI
   1e744:	f383 8811 	msr	BASEPRI, r3
   1e748:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
   1e74c:	4b04      	ldr	r3, [pc, #16]	; (1e760 <k_sched_lock+0x24>)
   1e74e:	689a      	ldr	r2, [r3, #8]
   1e750:	7bd3      	ldrb	r3, [r2, #15]
   1e752:	3b01      	subs	r3, #1
   1e754:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   1e756:	f381 8811 	msr	BASEPRI, r1
   1e75a:	f3bf 8f6f 	isb	sy
void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
   1e75e:	4770      	bx	lr
   1e760:	20006054 	.word	0x20006054

0001e764 <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   1e764:	4b09      	ldr	r3, [pc, #36]	; (1e78c <z_priq_dumb_remove+0x28>)
   1e766:	f103 0228 	add.w	r2, r3, #40	; 0x28
   1e76a:	4282      	cmp	r2, r0
   1e76c:	d105      	bne.n	1e77a <z_priq_dumb_remove+0x16>
   1e76e:	689b      	ldr	r3, [r3, #8]
   1e770:	428b      	cmp	r3, r1
   1e772:	d102      	bne.n	1e77a <z_priq_dumb_remove+0x16>
   1e774:	7b4b      	ldrb	r3, [r1, #13]
   1e776:	06db      	lsls	r3, r3, #27
   1e778:	d106      	bne.n	1e788 <z_priq_dumb_remove+0x24>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
   1e77a:	e9d1 3200 	ldrd	r3, r2, [r1]
   1e77e:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   1e780:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   1e782:	2300      	movs	r3, #0
	node->prev = NULL;
   1e784:	e9c1 3300 	strd	r3, r3, [r1]
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
   1e788:	4770      	bx	lr
   1e78a:	bf00      	nop
   1e78c:	20006054 	.word	0x20006054

0001e790 <update_cache>:
{
   1e790:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   1e792:	4c0d      	ldr	r4, [pc, #52]	; (1e7c8 <update_cache+0x38>)
{
   1e794:	4602      	mov	r2, r0
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   1e796:	f104 0028 	add.w	r0, r4, #40	; 0x28
   1e79a:	f009 fabc 	bl	27d16 <z_priq_dumb_best>
	return thread ? thread : _current_cpu->idle_thread;
   1e79e:	4605      	mov	r5, r0
   1e7a0:	b900      	cbnz	r0, 1e7a4 <update_cache+0x14>
   1e7a2:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
   1e7a4:	68a3      	ldr	r3, [r4, #8]
   1e7a6:	b94a      	cbnz	r2, 1e7bc <update_cache+0x2c>
	if (z_is_thread_prevented_from_running(_current)) {
   1e7a8:	7b5a      	ldrb	r2, [r3, #13]
   1e7aa:	06d2      	lsls	r2, r2, #27
   1e7ac:	d106      	bne.n	1e7bc <update_cache+0x2c>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   1e7ae:	69aa      	ldr	r2, [r5, #24]
   1e7b0:	b922      	cbnz	r2, 1e7bc <update_cache+0x2c>
	if (is_preempt(_current) || is_metairq(thread)) {
   1e7b2:	89da      	ldrh	r2, [r3, #14]
   1e7b4:	2a7f      	cmp	r2, #127	; 0x7f
   1e7b6:	d901      	bls.n	1e7bc <update_cache+0x2c>
		_kernel.ready_q.cache = _current;
   1e7b8:	6263      	str	r3, [r4, #36]	; 0x24
}
   1e7ba:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
   1e7bc:	429d      	cmp	r5, r3
   1e7be:	d001      	beq.n	1e7c4 <update_cache+0x34>
			z_reset_time_slice();
   1e7c0:	f7ff ff7a 	bl	1e6b8 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   1e7c4:	6265      	str	r5, [r4, #36]	; 0x24
}
   1e7c6:	e7f8      	b.n	1e7ba <update_cache+0x2a>
   1e7c8:	20006054 	.word	0x20006054

0001e7cc <k_sched_unlock>:
{
   1e7cc:	b510      	push	{r4, lr}
	__asm__ volatile(
   1e7ce:	f04f 0320 	mov.w	r3, #32
   1e7d2:	f3ef 8411 	mrs	r4, BASEPRI
   1e7d6:	f383 8811 	msr	BASEPRI, r3
   1e7da:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   1e7de:	4b08      	ldr	r3, [pc, #32]	; (1e800 <k_sched_unlock+0x34>)
   1e7e0:	689a      	ldr	r2, [r3, #8]
   1e7e2:	7bd3      	ldrb	r3, [r2, #15]
   1e7e4:	3301      	adds	r3, #1
   1e7e6:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   1e7e8:	2000      	movs	r0, #0
   1e7ea:	f7ff ffd1 	bl	1e790 <update_cache>
	__asm__ volatile(
   1e7ee:	f384 8811 	msr	BASEPRI, r4
   1e7f2:	f3bf 8f6f 	isb	sy
}
   1e7f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   1e7fa:	f009 ba64 	b.w	27cc6 <z_reschedule_unlocked>
   1e7fe:	bf00      	nop
   1e800:	20006054 	.word	0x20006054

0001e804 <z_add_thread_to_ready_q>:
{
   1e804:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
   1e806:	f04f 0320 	mov.w	r3, #32
   1e80a:	f3ef 8411 	mrs	r4, BASEPRI
   1e80e:	f383 8811 	msr	BASEPRI, r3
   1e812:	f3bf 8f6f 	isb	sy
	return list->head == list;
   1e816:	4a15      	ldr	r2, [pc, #84]	; (1e86c <z_add_thread_to_ready_q+0x68>)
   1e818:	4611      	mov	r1, r2
   1e81a:	f851 3f28 	ldr.w	r3, [r1, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1e81e:	428b      	cmp	r3, r1
   1e820:	d01d      	beq.n	1e85e <z_add_thread_to_ready_q+0x5a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1e822:	b1e3      	cbz	r3, 1e85e <z_add_thread_to_ready_q+0x5a>
   1e824:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
	if (thread_1->base.prio < thread_2->base.prio) {
   1e826:	f990 500e 	ldrsb.w	r5, [r0, #14]
   1e82a:	f993 700e 	ldrsb.w	r7, [r3, #14]
   1e82e:	42af      	cmp	r7, r5
   1e830:	dd10      	ble.n	1e854 <z_add_thread_to_ready_q+0x50>
	node->prev = successor->prev;
   1e832:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   1e834:	e9c0 3200 	strd	r3, r2, [r0]
	successor->prev->next = node;
   1e838:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   1e83a:	6058      	str	r0, [r3, #4]
	thread->base.thread_state |= states;
   1e83c:	7b43      	ldrb	r3, [r0, #13]
   1e83e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1e842:	7343      	strb	r3, [r0, #13]
		update_cache(0);
   1e844:	2000      	movs	r0, #0
   1e846:	f7ff ffa3 	bl	1e790 <update_cache>
	__asm__ volatile(
   1e84a:	f384 8811 	msr	BASEPRI, r4
   1e84e:	f3bf 8f6f 	isb	sy
}
   1e852:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   1e854:	42b3      	cmp	r3, r6
   1e856:	d002      	beq.n	1e85e <z_add_thread_to_ready_q+0x5a>
   1e858:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1e85a:	2b00      	cmp	r3, #0
   1e85c:	d1e5      	bne.n	1e82a <z_add_thread_to_ready_q+0x26>
	node->prev = list->tail;
   1e85e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   1e860:	6043      	str	r3, [r0, #4]
	list->tail->next = node;
   1e862:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	node->next = list;
   1e864:	6001      	str	r1, [r0, #0]
	list->tail->next = node;
   1e866:	6018      	str	r0, [r3, #0]
	list->tail = node;
   1e868:	62d0      	str	r0, [r2, #44]	; 0x2c
   1e86a:	e7e7      	b.n	1e83c <z_add_thread_to_ready_q+0x38>
   1e86c:	20006054 	.word	0x20006054

0001e870 <z_move_thread_to_end_of_prio_q>:
{
   1e870:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e872:	4604      	mov	r4, r0
	__asm__ volatile(
   1e874:	f04f 0320 	mov.w	r3, #32
   1e878:	f3ef 8511 	mrs	r5, BASEPRI
   1e87c:	f383 8811 	msr	BASEPRI, r3
   1e880:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   1e884:	7b43      	ldrb	r3, [r0, #13]
   1e886:	065a      	lsls	r2, r3, #25
   1e888:	d503      	bpl.n	1e892 <z_move_thread_to_end_of_prio_q+0x22>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   1e88a:	4601      	mov	r1, r0
   1e88c:	4817      	ldr	r0, [pc, #92]	; (1e8ec <z_move_thread_to_end_of_prio_q+0x7c>)
   1e88e:	f7ff ff69 	bl	1e764 <z_priq_dumb_remove>
	return list->head == list;
   1e892:	4a17      	ldr	r2, [pc, #92]	; (1e8f0 <z_move_thread_to_end_of_prio_q+0x80>)
   1e894:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1e898:	f102 0128 	add.w	r1, r2, #40	; 0x28
   1e89c:	428b      	cmp	r3, r1
   1e89e:	d01f      	beq.n	1e8e0 <z_move_thread_to_end_of_prio_q+0x70>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1e8a0:	b1f3      	cbz	r3, 1e8e0 <z_move_thread_to_end_of_prio_q+0x70>
	if (thread_1->base.prio < thread_2->base.prio) {
   1e8a2:	f994 600e 	ldrsb.w	r6, [r4, #14]
   1e8a6:	f993 700e 	ldrsb.w	r7, [r3, #14]
   1e8aa:	42b7      	cmp	r7, r6
   1e8ac:	dd13      	ble.n	1e8d6 <z_move_thread_to_end_of_prio_q+0x66>
	node->prev = successor->prev;
   1e8ae:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   1e8b0:	e9c4 3100 	strd	r3, r1, [r4]
	successor->prev->next = node;
   1e8b4:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   1e8b6:	605c      	str	r4, [r3, #4]
   1e8b8:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
   1e8ba:	6890      	ldr	r0, [r2, #8]
   1e8bc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1e8c0:	7363      	strb	r3, [r4, #13]
   1e8c2:	1b03      	subs	r3, r0, r4
   1e8c4:	4258      	negs	r0, r3
   1e8c6:	4158      	adcs	r0, r3
   1e8c8:	f7ff ff62 	bl	1e790 <update_cache>
	__asm__ volatile(
   1e8cc:	f385 8811 	msr	BASEPRI, r5
   1e8d0:	f3bf 8f6f 	isb	sy
}
   1e8d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   1e8d6:	4283      	cmp	r3, r0
   1e8d8:	d002      	beq.n	1e8e0 <z_move_thread_to_end_of_prio_q+0x70>
   1e8da:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1e8dc:	2b00      	cmp	r3, #0
   1e8de:	d1e2      	bne.n	1e8a6 <z_move_thread_to_end_of_prio_q+0x36>
	node->prev = list->tail;
   1e8e0:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   1e8e4:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   1e8e6:	601c      	str	r4, [r3, #0]
	list->tail = node;
   1e8e8:	62d4      	str	r4, [r2, #44]	; 0x2c
   1e8ea:	e7e5      	b.n	1e8b8 <z_move_thread_to_end_of_prio_q+0x48>
   1e8ec:	2000607c 	.word	0x2000607c
   1e8f0:	20006054 	.word	0x20006054

0001e8f4 <z_time_slice>:
	if (pending_current == _current) {
   1e8f4:	4a15      	ldr	r2, [pc, #84]	; (1e94c <z_time_slice+0x58>)
   1e8f6:	4916      	ldr	r1, [pc, #88]	; (1e950 <z_time_slice+0x5c>)
{
   1e8f8:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
   1e8fa:	680c      	ldr	r4, [r1, #0]
   1e8fc:	6893      	ldr	r3, [r2, #8]
   1e8fe:	42a3      	cmp	r3, r4
   1e900:	4614      	mov	r4, r2
   1e902:	d103      	bne.n	1e90c <z_time_slice+0x18>
}
   1e904:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
   1e908:	f7ff bed6 	b.w	1e6b8 <z_reset_time_slice>
	pending_current = NULL;
   1e90c:	2500      	movs	r5, #0
   1e90e:	600d      	str	r5, [r1, #0]
	if (slice_time && sliceable(_current)) {
   1e910:	4910      	ldr	r1, [pc, #64]	; (1e954 <z_time_slice+0x60>)
   1e912:	6809      	ldr	r1, [r1, #0]
   1e914:	b1b9      	cbz	r1, 1e946 <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   1e916:	89d9      	ldrh	r1, [r3, #14]
   1e918:	297f      	cmp	r1, #127	; 0x7f
   1e91a:	d814      	bhi.n	1e946 <z_time_slice+0x52>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   1e91c:	490e      	ldr	r1, [pc, #56]	; (1e958 <z_time_slice+0x64>)
   1e91e:	f993 500e 	ldrsb.w	r5, [r3, #14]
   1e922:	6809      	ldr	r1, [r1, #0]
   1e924:	428d      	cmp	r5, r1
   1e926:	db0e      	blt.n	1e946 <z_time_slice+0x52>
		&& !z_is_idle_thread_object(thread)
   1e928:	490c      	ldr	r1, [pc, #48]	; (1e95c <z_time_slice+0x68>)
   1e92a:	428b      	cmp	r3, r1
   1e92c:	d00b      	beq.n	1e946 <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   1e92e:	6999      	ldr	r1, [r3, #24]
   1e930:	b949      	cbnz	r1, 1e946 <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
   1e932:	6911      	ldr	r1, [r2, #16]
   1e934:	4281      	cmp	r1, r0
   1e936:	dc03      	bgt.n	1e940 <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
   1e938:	4618      	mov	r0, r3
   1e93a:	f7ff ff99 	bl	1e870 <z_move_thread_to_end_of_prio_q>
   1e93e:	e7e1      	b.n	1e904 <z_time_slice+0x10>
			_current_cpu->slice_ticks -= ticks;
   1e940:	1a09      	subs	r1, r1, r0
   1e942:	6111      	str	r1, [r2, #16]
}
   1e944:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
   1e946:	2300      	movs	r3, #0
   1e948:	6123      	str	r3, [r4, #16]
   1e94a:	e7fb      	b.n	1e944 <z_time_slice+0x50>
   1e94c:	20006054 	.word	0x20006054
   1e950:	20006084 	.word	0x20006084
   1e954:	2000608c 	.word	0x2000608c
   1e958:	20006088 	.word	0x20006088
   1e95c:	20001f18 	.word	0x20001f18

0001e960 <z_thread_single_suspend>:
{
   1e960:	b570      	push	{r4, r5, r6, lr}
   1e962:	4604      	mov	r4, r0
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   1e964:	3018      	adds	r0, #24
   1e966:	f009 faeb 	bl	27f40 <z_abort_timeout>
	__asm__ volatile(
   1e96a:	f04f 0320 	mov.w	r3, #32
   1e96e:	f3ef 8611 	mrs	r6, BASEPRI
   1e972:	f383 8811 	msr	BASEPRI, r3
   1e976:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   1e97a:	7b63      	ldrb	r3, [r4, #13]
   1e97c:	065a      	lsls	r2, r3, #25
   1e97e:	d507      	bpl.n	1e990 <z_thread_single_suspend+0x30>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   1e980:	4621      	mov	r1, r4
   1e982:	480f      	ldr	r0, [pc, #60]	; (1e9c0 <z_thread_single_suspend+0x60>)
   1e984:	f7ff feee 	bl	1e764 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   1e988:	7b63      	ldrb	r3, [r4, #13]
   1e98a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   1e98e:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   1e990:	4d0c      	ldr	r5, [pc, #48]	; (1e9c4 <z_thread_single_suspend+0x64>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   1e992:	7b63      	ldrb	r3, [r4, #13]
   1e994:	68a8      	ldr	r0, [r5, #8]
   1e996:	f043 0310 	orr.w	r3, r3, #16
   1e99a:	7363      	strb	r3, [r4, #13]
   1e99c:	1b03      	subs	r3, r0, r4
   1e99e:	4258      	negs	r0, r3
   1e9a0:	4158      	adcs	r0, r3
   1e9a2:	f7ff fef5 	bl	1e790 <update_cache>
	__asm__ volatile(
   1e9a6:	f386 8811 	msr	BASEPRI, r6
   1e9aa:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   1e9ae:	68ab      	ldr	r3, [r5, #8]
   1e9b0:	42a3      	cmp	r3, r4
   1e9b2:	d103      	bne.n	1e9bc <z_thread_single_suspend+0x5c>
}
   1e9b4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   1e9b8:	f009 b985 	b.w	27cc6 <z_reschedule_unlocked>
}
   1e9bc:	bd70      	pop	{r4, r5, r6, pc}
   1e9be:	bf00      	nop
   1e9c0:	2000607c 	.word	0x2000607c
   1e9c4:	20006054 	.word	0x20006054

0001e9c8 <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
   1e9c8:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
   1e9ca:	b570      	push	{r4, r5, r6, lr}
   1e9cc:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
   1e9ce:	b103      	cbz	r3, 1e9d2 <z_thread_single_abort+0xa>
		thread->fn_abort();
   1e9d0:	4798      	blx	r3
   1e9d2:	f104 0018 	add.w	r0, r4, #24
   1e9d6:	f009 fab3 	bl	27f40 <z_abort_timeout>
	__asm__ volatile(
   1e9da:	f04f 0320 	mov.w	r3, #32
   1e9de:	f3ef 8511 	mrs	r5, BASEPRI
   1e9e2:	f383 8811 	msr	BASEPRI, r3
   1e9e6:	f3bf 8f6f 	isb	sy
		if (z_is_thread_ready(thread)) {
   1e9ea:	4620      	mov	r0, r4
   1e9ec:	f009 f919 	bl	27c22 <z_is_thread_ready>
   1e9f0:	7b63      	ldrb	r3, [r4, #13]
   1e9f2:	4606      	mov	r6, r0
   1e9f4:	b1c8      	cbz	r0, 1ea2a <z_thread_single_abort+0x62>
			if (z_is_thread_queued(thread)) {
   1e9f6:	0659      	lsls	r1, r3, #25
   1e9f8:	d507      	bpl.n	1ea0a <z_thread_single_abort+0x42>
				_priq_run_remove(&_kernel.ready_q.runq,
   1e9fa:	4621      	mov	r1, r4
   1e9fc:	4811      	ldr	r0, [pc, #68]	; (1ea44 <z_thread_single_abort+0x7c>)
   1e9fe:	f7ff feb1 	bl	1e764 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   1ea02:	7b63      	ldrb	r3, [r4, #13]
   1ea04:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   1ea08:	7363      	strb	r3, [r4, #13]
			update_cache(thread == _current);
   1ea0a:	4b0f      	ldr	r3, [pc, #60]	; (1ea48 <z_thread_single_abort+0x80>)
   1ea0c:	6898      	ldr	r0, [r3, #8]
   1ea0e:	1b02      	subs	r2, r0, r4
   1ea10:	4250      	negs	r0, r2
   1ea12:	4150      	adcs	r0, r2
   1ea14:	f7ff febc 	bl	1e790 <update_cache>
		thread->base.thread_state |= _THREAD_DEAD;
   1ea18:	7b63      	ldrb	r3, [r4, #13]
   1ea1a:	f043 0308 	orr.w	r3, r3, #8
   1ea1e:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   1ea20:	f385 8811 	msr	BASEPRI, r5
   1ea24:	f3bf 8f6f 	isb	sy
}
   1ea28:	bd70      	pop	{r4, r5, r6, pc}
			if (z_is_thread_pending(thread)) {
   1ea2a:	079b      	lsls	r3, r3, #30
   1ea2c:	d5f4      	bpl.n	1ea18 <z_thread_single_abort+0x50>
				_priq_wait_remove(&pended_on(thread)->waitq,
   1ea2e:	4621      	mov	r1, r4
   1ea30:	68a0      	ldr	r0, [r4, #8]
   1ea32:	f7ff fe97 	bl	1e764 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1ea36:	7b63      	ldrb	r3, [r4, #13]
				thread->base.pended_on = NULL;
   1ea38:	60a6      	str	r6, [r4, #8]
   1ea3a:	f023 0302 	bic.w	r3, r3, #2
   1ea3e:	7363      	strb	r3, [r4, #13]
   1ea40:	e7ea      	b.n	1ea18 <z_thread_single_abort+0x50>
   1ea42:	bf00      	nop
   1ea44:	2000607c 	.word	0x2000607c
   1ea48:	20006054 	.word	0x20006054

0001ea4c <z_remove_thread_from_ready_q>:
{
   1ea4c:	b538      	push	{r3, r4, r5, lr}
   1ea4e:	4604      	mov	r4, r0
	__asm__ volatile(
   1ea50:	f04f 0320 	mov.w	r3, #32
   1ea54:	f3ef 8511 	mrs	r5, BASEPRI
   1ea58:	f383 8811 	msr	BASEPRI, r3
   1ea5c:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   1ea60:	7b43      	ldrb	r3, [r0, #13]
   1ea62:	065a      	lsls	r2, r3, #25
   1ea64:	d507      	bpl.n	1ea76 <z_remove_thread_from_ready_q+0x2a>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   1ea66:	4601      	mov	r1, r0
   1ea68:	4809      	ldr	r0, [pc, #36]	; (1ea90 <z_remove_thread_from_ready_q+0x44>)
   1ea6a:	f7ff fe7b 	bl	1e764 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   1ea6e:	7b63      	ldrb	r3, [r4, #13]
   1ea70:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   1ea74:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   1ea76:	4b07      	ldr	r3, [pc, #28]	; (1ea94 <z_remove_thread_from_ready_q+0x48>)
   1ea78:	6898      	ldr	r0, [r3, #8]
   1ea7a:	1b03      	subs	r3, r0, r4
   1ea7c:	4258      	negs	r0, r3
   1ea7e:	4158      	adcs	r0, r3
   1ea80:	f7ff fe86 	bl	1e790 <update_cache>
	__asm__ volatile(
   1ea84:	f385 8811 	msr	BASEPRI, r5
   1ea88:	f3bf 8f6f 	isb	sy
}
   1ea8c:	bd38      	pop	{r3, r4, r5, pc}
   1ea8e:	bf00      	nop
   1ea90:	2000607c 	.word	0x2000607c
   1ea94:	20006054 	.word	0x20006054

0001ea98 <pend>:
{
   1ea98:	b570      	push	{r4, r5, r6, lr}
   1ea9a:	4604      	mov	r4, r0
   1ea9c:	460d      	mov	r5, r1
   1ea9e:	4616      	mov	r6, r2
	z_remove_thread_from_ready_q(thread);
   1eaa0:	f7ff ffd4 	bl	1ea4c <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_PENDING;
   1eaa4:	7b63      	ldrb	r3, [r4, #13]
   1eaa6:	f043 0302 	orr.w	r3, r3, #2
   1eaaa:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   1eaac:	b17d      	cbz	r5, 1eace <pend+0x36>
	return list->head == list;
   1eaae:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
   1eab0:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1eab2:	429d      	cmp	r5, r3
   1eab4:	d029      	beq.n	1eb0a <pend+0x72>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1eab6:	b343      	cbz	r3, 1eb0a <pend+0x72>
	if (thread_1->base.prio < thread_2->base.prio) {
   1eab8:	f994 200e 	ldrsb.w	r2, [r4, #14]
   1eabc:	f993 100e 	ldrsb.w	r1, [r3, #14]
   1eac0:	4291      	cmp	r1, r2
   1eac2:	dd1c      	ble.n	1eafe <pend+0x66>
	node->prev = successor->prev;
   1eac4:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   1eac6:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   1eaca:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   1eacc:	605c      	str	r4, [r3, #4]
	if (timeout != K_FOREVER) {
   1eace:	1c73      	adds	r3, r6, #1
   1ead0:	d022      	beq.n	1eb18 <pend+0x80>
   1ead2:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
   1ead6:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   1eada:	f240 30e7 	movw	r0, #999	; 0x3e7
   1eade:	2100      	movs	r1, #0
   1eae0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1eae4:	fbc5 0106 	smlal	r0, r1, r5, r6
   1eae8:	2300      	movs	r3, #0
   1eaea:	f7e1 fb49 	bl	180 <__aeabi_uldivmod>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   1eaee:	490b      	ldr	r1, [pc, #44]	; (1eb1c <pend+0x84>)
   1eaf0:	1c42      	adds	r2, r0, #1
   1eaf2:	f104 0018 	add.w	r0, r4, #24
}
   1eaf6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1eafa:	f000 bb2f 	b.w	1f15c <z_add_timeout>
	return (node == list->tail) ? NULL : node->next;
   1eafe:	6869      	ldr	r1, [r5, #4]
   1eb00:	428b      	cmp	r3, r1
   1eb02:	d002      	beq.n	1eb0a <pend+0x72>
   1eb04:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1eb06:	2b00      	cmp	r3, #0
   1eb08:	d1d8      	bne.n	1eabc <pend+0x24>
	node->prev = list->tail;
   1eb0a:	686b      	ldr	r3, [r5, #4]
   1eb0c:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   1eb0e:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   1eb10:	6025      	str	r5, [r4, #0]
	list->tail->next = node;
   1eb12:	601c      	str	r4, [r3, #0]
	list->tail = node;
   1eb14:	606c      	str	r4, [r5, #4]
   1eb16:	e7da      	b.n	1eace <pend+0x36>
}
   1eb18:	bd70      	pop	{r4, r5, r6, pc}
   1eb1a:	bf00      	nop
   1eb1c:	00027d23 	.word	0x00027d23

0001eb20 <z_pend_curr_irqlock>:
{
   1eb20:	b570      	push	{r4, r5, r6, lr}
	pend(_current, wait_q, timeout);
   1eb22:	4d0f      	ldr	r5, [pc, #60]	; (1eb60 <z_pend_curr_irqlock+0x40>)
	pending_current = _current;
   1eb24:	4c0f      	ldr	r4, [pc, #60]	; (1eb64 <z_pend_curr_irqlock+0x44>)
{
   1eb26:	4606      	mov	r6, r0
	pend(_current, wait_q, timeout);
   1eb28:	68a8      	ldr	r0, [r5, #8]
   1eb2a:	f7ff ffb5 	bl	1ea98 <pend>
	pending_current = _current;
   1eb2e:	68ab      	ldr	r3, [r5, #8]
   1eb30:	6023      	str	r3, [r4, #0]
   1eb32:	4630      	mov	r0, r6
   1eb34:	f7e7 ff90 	bl	6a58 <arch_swap>
	__asm__ volatile(
   1eb38:	f04f 0220 	mov.w	r2, #32
   1eb3c:	f3ef 8311 	mrs	r3, BASEPRI
   1eb40:	f382 8811 	msr	BASEPRI, r2
   1eb44:	f3bf 8f6f 	isb	sy
		if (pending_current == _current) {
   1eb48:	6822      	ldr	r2, [r4, #0]
   1eb4a:	68a9      	ldr	r1, [r5, #8]
   1eb4c:	4291      	cmp	r1, r2
			pending_current = NULL;
   1eb4e:	bf04      	itt	eq
   1eb50:	2200      	moveq	r2, #0
   1eb52:	6022      	streq	r2, [r4, #0]
	__asm__ volatile(
   1eb54:	f383 8811 	msr	BASEPRI, r3
   1eb58:	f3bf 8f6f 	isb	sy
}
   1eb5c:	bd70      	pop	{r4, r5, r6, pc}
   1eb5e:	bf00      	nop
   1eb60:	20006054 	.word	0x20006054
   1eb64:	20006084 	.word	0x20006084

0001eb68 <z_pend_curr>:
{
   1eb68:	b510      	push	{r4, lr}
   1eb6a:	460c      	mov	r4, r1
   1eb6c:	4611      	mov	r1, r2
	pending_current = _current;
   1eb6e:	4a06      	ldr	r2, [pc, #24]	; (1eb88 <z_pend_curr+0x20>)
   1eb70:	6890      	ldr	r0, [r2, #8]
   1eb72:	4a06      	ldr	r2, [pc, #24]	; (1eb8c <z_pend_curr+0x24>)
   1eb74:	6010      	str	r0, [r2, #0]
	pend(_current, wait_q, timeout);
   1eb76:	461a      	mov	r2, r3
   1eb78:	f7ff ff8e 	bl	1ea98 <pend>
   1eb7c:	4620      	mov	r0, r4
}
   1eb7e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1eb82:	f7e7 bf69 	b.w	6a58 <arch_swap>
   1eb86:	bf00      	nop
   1eb88:	20006054 	.word	0x20006054
   1eb8c:	20006084 	.word	0x20006084

0001eb90 <z_tick_sleep.part.19>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static s32_t z_tick_sleep(s32_t ticks)
   1eb90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (ticks == 0) {
		k_yield();
		return 0;
	}

	ticks += _TICK_ALIGN;
   1eb92:	1c46      	adds	r6, r0, #1
	expected_wakeup_time = ticks + z_tick_get_32();
   1eb94:	f009 fa14 	bl	27fc0 <z_tick_get_32>
   1eb98:	1834      	adds	r4, r6, r0
	__asm__ volatile(
   1eb9a:	f04f 0320 	mov.w	r3, #32
   1eb9e:	f3ef 8711 	mrs	r7, BASEPRI
   1eba2:	f383 8811 	msr	BASEPRI, r3
   1eba6:	f3bf 8f6f 	isb	sy
	 */
	struct k_spinlock local_lock = {};
	k_spinlock_key_t key = k_spin_lock(&local_lock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
   1ebaa:	4d0d      	ldr	r5, [pc, #52]	; (1ebe0 <z_tick_sleep.part.19+0x50>)
   1ebac:	4b0d      	ldr	r3, [pc, #52]	; (1ebe4 <z_tick_sleep.part.19+0x54>)
   1ebae:	68a8      	ldr	r0, [r5, #8]
   1ebb0:	6018      	str	r0, [r3, #0]
#endif
	z_remove_thread_from_ready_q(_current);
   1ebb2:	f7ff ff4b 	bl	1ea4c <z_remove_thread_from_ready_q>
   1ebb6:	68a8      	ldr	r0, [r5, #8]
   1ebb8:	490b      	ldr	r1, [pc, #44]	; (1ebe8 <z_tick_sleep.part.19+0x58>)
   1ebba:	4632      	mov	r2, r6
   1ebbc:	3018      	adds	r0, #24
   1ebbe:	f000 facd 	bl	1f15c <z_add_timeout>
	z_add_thread_timeout(_current, ticks);
	z_mark_thread_as_suspended(_current);
   1ebc2:	68aa      	ldr	r2, [r5, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
   1ebc4:	7b53      	ldrb	r3, [r2, #13]
   1ebc6:	f043 0310 	orr.w	r3, r3, #16
   1ebca:	7353      	strb	r3, [r2, #13]
   1ebcc:	4638      	mov	r0, r7
   1ebce:	f7e7 ff43 	bl	6a58 <arch_swap>

	(void)z_swap(&local_lock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = expected_wakeup_time - z_tick_get_32();
   1ebd2:	f009 f9f5 	bl	27fc0 <z_tick_get_32>
   1ebd6:	1a20      	subs	r0, r4, r0
		return ticks;
	}
#endif

	return 0;
}
   1ebd8:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   1ebdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1ebde:	bf00      	nop
   1ebe0:	20006054 	.word	0x20006054
   1ebe4:	20006084 	.word	0x20006084
   1ebe8:	00027d23 	.word	0x00027d23

0001ebec <z_set_prio>:
{
   1ebec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1ebf0:	4604      	mov	r4, r0
   1ebf2:	f04f 0320 	mov.w	r3, #32
   1ebf6:	f3ef 8911 	mrs	r9, BASEPRI
   1ebfa:	f383 8811 	msr	BASEPRI, r3
   1ebfe:	f3bf 8f6f 	isb	sy
		need_sched = z_is_thread_ready(thread);
   1ec02:	f009 f80e 	bl	27c22 <z_is_thread_ready>
		if (need_sched) {
   1ec06:	b24e      	sxtb	r6, r1
   1ec08:	4680      	mov	r8, r0
   1ec0a:	b360      	cbz	r0, 1ec66 <z_set_prio+0x7a>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
   1ec0c:	4d17      	ldr	r5, [pc, #92]	; (1ec6c <z_set_prio+0x80>)
   1ec0e:	f105 0728 	add.w	r7, r5, #40	; 0x28
   1ec12:	4621      	mov	r1, r4
   1ec14:	4638      	mov	r0, r7
   1ec16:	f7ff fda5 	bl	1e764 <z_priq_dumb_remove>
	return list->head == list;
   1ec1a:	6aab      	ldr	r3, [r5, #40]	; 0x28
				thread->base.prio = prio;
   1ec1c:	73a6      	strb	r6, [r4, #14]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1ec1e:	42bb      	cmp	r3, r7
   1ec20:	462a      	mov	r2, r5
   1ec22:	d019      	beq.n	1ec58 <z_set_prio+0x6c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1ec24:	b1c3      	cbz	r3, 1ec58 <z_set_prio+0x6c>
   1ec26:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
	if (thread_1->base.prio < thread_2->base.prio) {
   1ec28:	f993 000e 	ldrsb.w	r0, [r3, #14]
   1ec2c:	42b0      	cmp	r0, r6
   1ec2e:	dd0e      	ble.n	1ec4e <z_set_prio+0x62>
	node->prev = successor->prev;
   1ec30:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   1ec32:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   1ec36:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   1ec38:	605c      	str	r4, [r3, #4]
			update_cache(1);
   1ec3a:	2001      	movs	r0, #1
   1ec3c:	f7ff fda8 	bl	1e790 <update_cache>
	__asm__ volatile(
   1ec40:	f389 8811 	msr	BASEPRI, r9
   1ec44:	f3bf 8f6f 	isb	sy
}
   1ec48:	4640      	mov	r0, r8
   1ec4a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return (node == list->tail) ? NULL : node->next;
   1ec4e:	4299      	cmp	r1, r3
   1ec50:	d002      	beq.n	1ec58 <z_set_prio+0x6c>
   1ec52:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1ec54:	2b00      	cmp	r3, #0
   1ec56:	d1e7      	bne.n	1ec28 <z_set_prio+0x3c>
	node->prev = list->tail;
   1ec58:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   1ec5a:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   1ec5c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	node->next = list;
   1ec5e:	6027      	str	r7, [r4, #0]
	list->tail->next = node;
   1ec60:	601c      	str	r4, [r3, #0]
	list->tail = node;
   1ec62:	62d4      	str	r4, [r2, #44]	; 0x2c
   1ec64:	e7e9      	b.n	1ec3a <z_set_prio+0x4e>
			thread->base.prio = prio;
   1ec66:	73a6      	strb	r6, [r4, #14]
   1ec68:	e7ea      	b.n	1ec40 <z_set_prio+0x54>
   1ec6a:	bf00      	nop
   1ec6c:	20006054 	.word	0x20006054

0001ec70 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
   1ec70:	4b04      	ldr	r3, [pc, #16]	; (1ec84 <z_sched_init+0x14>)
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   1ec72:	2100      	movs	r1, #0
   1ec74:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
   1ec78:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
   1ec7c:	4608      	mov	r0, r1
   1ec7e:	f7ff bd31 	b.w	1e6e4 <k_sched_time_slice_set>
   1ec82:	bf00      	nop
   1ec84:	20006054 	.word	0x20006054

0001ec88 <z_impl_k_yield>:
{
   1ec88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!z_is_idle_thread_object(_current)) {
   1ec8a:	4c23      	ldr	r4, [pc, #140]	; (1ed18 <z_impl_k_yield+0x90>)
   1ec8c:	4b23      	ldr	r3, [pc, #140]	; (1ed1c <z_impl_k_yield+0x94>)
   1ec8e:	68a2      	ldr	r2, [r4, #8]
   1ec90:	429a      	cmp	r2, r3
   1ec92:	d029      	beq.n	1ece8 <z_impl_k_yield+0x60>
	__asm__ volatile(
   1ec94:	f04f 0320 	mov.w	r3, #32
   1ec98:	f3ef 8611 	mrs	r6, BASEPRI
   1ec9c:	f383 8811 	msr	BASEPRI, r3
   1eca0:	f3bf 8f6f 	isb	sy
				_priq_run_remove(&_kernel.ready_q.runq,
   1eca4:	f104 0528 	add.w	r5, r4, #40	; 0x28
   1eca8:	68a1      	ldr	r1, [r4, #8]
   1ecaa:	4628      	mov	r0, r5
   1ecac:	f7ff fd5a 	bl	1e764 <z_priq_dumb_remove>
	return list->head == list;
   1ecb0:	6aa2      	ldr	r2, [r4, #40]	; 0x28
			_priq_run_add(&_kernel.ready_q.runq, _current);
   1ecb2:	68a3      	ldr	r3, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1ecb4:	42aa      	cmp	r2, r5
   1ecb6:	d028      	beq.n	1ed0a <z_impl_k_yield+0x82>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1ecb8:	b33a      	cbz	r2, 1ed0a <z_impl_k_yield+0x82>
   1ecba:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
	if (thread_1->base.prio < thread_2->base.prio) {
   1ecbc:	f993 100e 	ldrsb.w	r1, [r3, #14]
   1ecc0:	f992 700e 	ldrsb.w	r7, [r2, #14]
   1ecc4:	428f      	cmp	r7, r1
   1ecc6:	dd1b      	ble.n	1ed00 <z_impl_k_yield+0x78>
	node->prev = successor->prev;
   1ecc8:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
   1ecca:	e9c3 2100 	strd	r2, r1, [r3]
	successor->prev->next = node;
   1ecce:	600b      	str	r3, [r1, #0]
	successor->prev = node;
   1ecd0:	6053      	str	r3, [r2, #4]
	thread->base.thread_state |= states;
   1ecd2:	7b5a      	ldrb	r2, [r3, #13]
   1ecd4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   1ecd8:	735a      	strb	r2, [r3, #13]
			update_cache(1);
   1ecda:	2001      	movs	r0, #1
   1ecdc:	f7ff fd58 	bl	1e790 <update_cache>
	__asm__ volatile(
   1ece0:	f386 8811 	msr	BASEPRI, r6
   1ece4:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   1ece8:	f04f 0320 	mov.w	r3, #32
   1ecec:	f3ef 8011 	mrs	r0, BASEPRI
   1ecf0:	f383 8811 	msr	BASEPRI, r3
   1ecf4:	f3bf 8f6f 	isb	sy
}
   1ecf8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   1ecfc:	f7e7 beac 	b.w	6a58 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   1ed00:	4282      	cmp	r2, r0
   1ed02:	d002      	beq.n	1ed0a <z_impl_k_yield+0x82>
   1ed04:	6812      	ldr	r2, [r2, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1ed06:	2a00      	cmp	r2, #0
   1ed08:	d1da      	bne.n	1ecc0 <z_impl_k_yield+0x38>
	node->prev = list->tail;
   1ed0a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1ed0c:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
   1ed0e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
	node->next = list;
   1ed10:	601d      	str	r5, [r3, #0]
	list->tail->next = node;
   1ed12:	6013      	str	r3, [r2, #0]
	list->tail = node;
   1ed14:	62e3      	str	r3, [r4, #44]	; 0x2c
   1ed16:	e7dc      	b.n	1ecd2 <z_impl_k_yield+0x4a>
   1ed18:	20006054 	.word	0x20006054
   1ed1c:	20001f18 	.word	0x20001f18

0001ed20 <z_impl_k_sleep>:

s32_t z_impl_k_sleep(int ms)
{
   1ed20:	b538      	push	{r3, r4, r5, lr}
	s32_t ticks;

	__ASSERT(!arch_is_in_isr(), "");

	if (ms == K_FOREVER) {
   1ed22:	1c43      	adds	r3, r0, #1
{
   1ed24:	4604      	mov	r4, r0
	if (ms == K_FOREVER) {
   1ed26:	d105      	bne.n	1ed34 <z_impl_k_sleep+0x14>
		k_thread_suspend(_current);
   1ed28:	4b10      	ldr	r3, [pc, #64]	; (1ed6c <z_impl_k_sleep+0x4c>)
   1ed2a:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   1ed2c:	f000 f8fa 	bl	1ef24 <z_impl_k_thread_suspend>
	}

	ticks = k_ms_to_ticks_ceil32(ms);
	ticks = z_tick_sleep(ticks);
	return k_ticks_to_ms_floor64(ticks);
}
   1ed30:	4620      	mov	r0, r4
   1ed32:	bd38      	pop	{r3, r4, r5, pc}
   1ed34:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   1ed38:	f240 30e7 	movw	r0, #999	; 0x3e7
   1ed3c:	2100      	movs	r1, #0
   1ed3e:	fbe5 0104 	umlal	r0, r1, r5, r4
   1ed42:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1ed46:	2300      	movs	r3, #0
   1ed48:	f7e1 fa1a 	bl	180 <__aeabi_uldivmod>
	if (ticks == 0) {
   1ed4c:	4604      	mov	r4, r0
   1ed4e:	b948      	cbnz	r0, 1ed64 <z_impl_k_sleep+0x44>
	z_impl_k_yield();
   1ed50:	f7ff ff9a 	bl	1ec88 <z_impl_k_yield>
			return (t * to_hz + off) / from_hz;
   1ed54:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   1ed58:	fb84 0100 	smull	r0, r1, r4, r0
   1ed5c:	0bc4      	lsrs	r4, r0, #15
   1ed5e:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
	return k_ticks_to_ms_floor64(ticks);
   1ed62:	e7e5      	b.n	1ed30 <z_impl_k_sleep+0x10>
   1ed64:	f7ff ff14 	bl	1eb90 <z_tick_sleep.part.19>
   1ed68:	4604      	mov	r4, r0
   1ed6a:	e7f3      	b.n	1ed54 <z_impl_k_sleep+0x34>
   1ed6c:	20006054 	.word	0x20006054

0001ed70 <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
   1ed70:	4b01      	ldr	r3, [pc, #4]	; (1ed78 <z_impl_k_current_get+0x8>)
   1ed72:	6898      	ldr	r0, [r3, #8]
   1ed74:	4770      	bx	lr
   1ed76:	bf00      	nop
   1ed78:	20006054 	.word	0x20006054

0001ed7c <z_impl_k_sem_give>:
		handle_poll_events(sem);
	}
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   1ed7c:	b570      	push	{r4, r5, r6, lr}
   1ed7e:	4604      	mov	r4, r0
   1ed80:	f04f 0320 	mov.w	r3, #32
   1ed84:	f3ef 8611 	mrs	r6, BASEPRI
   1ed88:	f383 8811 	msr	BASEPRI, r3
   1ed8c:	f3bf 8f6f 	isb	sy
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
   1ed90:	f008 fff8 	bl	27d84 <z_unpend_first_thread>
	if (thread != NULL) {
   1ed94:	4605      	mov	r5, r0
   1ed96:	b170      	cbz	r0, 1edb6 <z_impl_k_sem_give+0x3a>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1ed98:	7b43      	ldrb	r3, [r0, #13]
   1ed9a:	06db      	lsls	r3, r3, #27
   1ed9c:	d103      	bne.n	1eda6 <z_impl_k_sem_give+0x2a>
	if (z_is_thread_ready(thread)) {
   1ed9e:	6983      	ldr	r3, [r0, #24]
   1eda0:	b90b      	cbnz	r3, 1eda6 <z_impl_k_sem_give+0x2a>
		z_add_thread_to_ready_q(thread);
   1eda2:	f7ff fd2f 	bl	1e804 <z_add_thread_to_ready_q>
   1eda6:	2300      	movs	r3, #0
   1eda8:	66ab      	str	r3, [r5, #104]	; 0x68
	k_spinlock_key_t key = k_spin_lock(&lock);

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);
	do_sem_give(sem);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
   1edaa:	4631      	mov	r1, r6
   1edac:	4808      	ldr	r0, [pc, #32]	; (1edd0 <z_impl_k_sem_give+0x54>)
}
   1edae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&lock, key);
   1edb2:	f008 bf71 	b.w	27c98 <z_reschedule>
	sem->count += (sem->count != sem->limit) ? 1U : 0U;
   1edb6:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   1edba:	429a      	cmp	r2, r3
   1edbc:	bf18      	it	ne
   1edbe:	3301      	addne	r3, #1
   1edc0:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   1edc2:	2102      	movs	r1, #2
   1edc4:	f104 0010 	add.w	r0, r4, #16
   1edc8:	f009 fa31 	bl	2822e <z_handle_obj_poll_events>
   1edcc:	e7ed      	b.n	1edaa <z_impl_k_sem_give+0x2e>
   1edce:	bf00      	nop
   1edd0:	2000abe2 	.word	0x2000abe2

0001edd4 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, s32_t timeout)
{
   1edd4:	b410      	push	{r4}
   1edd6:	4602      	mov	r2, r0
   1edd8:	460b      	mov	r3, r1
   1edda:	f04f 0020 	mov.w	r0, #32
   1edde:	f3ef 8111 	mrs	r1, BASEPRI
   1ede2:	f380 8811 	msr	BASEPRI, r0
   1ede6:	f3bf 8f6f 	isb	sy
	__ASSERT(((arch_is_in_isr() == false) || (timeout == K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
   1edea:	6894      	ldr	r4, [r2, #8]
   1edec:	b144      	cbz	r4, 1ee00 <z_impl_k_sem_take+0x2c>
		sem->count--;
   1edee:	3c01      	subs	r4, #1
   1edf0:	6094      	str	r4, [r2, #8]
	__asm__ volatile(
   1edf2:	f381 8811 	msr	BASEPRI, r1
   1edf6:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
		return 0;
   1edfa:	2000      	movs	r0, #0

	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);

	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
	return ret;
}
   1edfc:	bc10      	pop	{r4}
   1edfe:	4770      	bx	lr
	if (timeout == K_NO_WAIT) {
   1ee00:	b933      	cbnz	r3, 1ee10 <z_impl_k_sem_take+0x3c>
   1ee02:	f381 8811 	msr	BASEPRI, r1
   1ee06:	f3bf 8f6f 	isb	sy
		return -EBUSY;
   1ee0a:	f06f 000f 	mvn.w	r0, #15
   1ee0e:	e7f5      	b.n	1edfc <z_impl_k_sem_take+0x28>
	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   1ee10:	4801      	ldr	r0, [pc, #4]	; (1ee18 <z_impl_k_sem_take+0x44>)
}
   1ee12:	bc10      	pop	{r4}
	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   1ee14:	f7ff bea8 	b.w	1eb68 <z_pend_curr>
   1ee18:	2000abe2 	.word	0x2000abe2

0001ee1c <k_sys_work_q_init>:
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
   1ee1c:	b510      	push	{r4, lr}
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
   1ee1e:	4c08      	ldr	r4, [pc, #32]	; (1ee40 <k_sys_work_q_init+0x24>)
   1ee20:	4908      	ldr	r1, [pc, #32]	; (1ee44 <k_sys_work_q_init+0x28>)
   1ee22:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1ee26:	f44f 6200 	mov.w	r2, #2048	; 0x800
   1ee2a:	4620      	mov	r0, r4
   1ee2c:	f000 f8f4 	bl	1f018 <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
   1ee30:	4905      	ldr	r1, [pc, #20]	; (1ee48 <k_sys_work_q_init+0x2c>)
   1ee32:	f104 0014 	add.w	r0, r4, #20
   1ee36:	f008 fff3 	bl	27e20 <z_impl_k_thread_name_set>
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
   1ee3a:	2000      	movs	r0, #0
   1ee3c:	bd10      	pop	{r4, pc}
   1ee3e:	bf00      	nop
   1ee40:	20006090 	.word	0x20006090
   1ee44:	2000cec0 	.word	0x2000cec0
   1ee48:	0006d93a 	.word	0x0006d93a

0001ee4c <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
   1ee4c:	b510      	push	{r4, lr}
	__asm__ volatile(
   1ee4e:	f04f 0220 	mov.w	r2, #32
   1ee52:	f3ef 8411 	mrs	r4, BASEPRI
   1ee56:	f382 8811 	msr	BASEPRI, r2
   1ee5a:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock); /* protect kernel queues */

	if (z_has_thread_started(thread)) {
   1ee5e:	7b42      	ldrb	r2, [r0, #13]
   1ee60:	0751      	lsls	r1, r2, #29
   1ee62:	d404      	bmi.n	1ee6e <z_impl_k_thread_start+0x22>
	__asm__ volatile(
   1ee64:	f384 8811 	msr	BASEPRI, r4
   1ee68:	f3bf 8f6f 	isb	sy
	}

	z_mark_thread_as_started(thread);
	z_ready_thread(thread);
	z_reschedule(&lock, key);
}
   1ee6c:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   1ee6e:	f022 0104 	bic.w	r1, r2, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1ee72:	f012 0f1b 	tst.w	r2, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
   1ee76:	7341      	strb	r1, [r0, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1ee78:	d103      	bne.n	1ee82 <z_impl_k_thread_start+0x36>
	if (z_is_thread_ready(thread)) {
   1ee7a:	6983      	ldr	r3, [r0, #24]
   1ee7c:	b90b      	cbnz	r3, 1ee82 <z_impl_k_thread_start+0x36>
		z_add_thread_to_ready_q(thread);
   1ee7e:	f7ff fcc1 	bl	1e804 <z_add_thread_to_ready_q>
	z_reschedule(&lock, key);
   1ee82:	4621      	mov	r1, r4
   1ee84:	4802      	ldr	r0, [pc, #8]	; (1ee90 <z_impl_k_thread_start+0x44>)
}
   1ee86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&lock, key);
   1ee8a:	f008 bf05 	b.w	27c98 <z_reschedule>
   1ee8e:	bf00      	nop
   1ee90:	2000abe3 	.word	0x2000abe3

0001ee94 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
   1ee94:	b530      	push	{r4, r5, lr}
   1ee96:	b087      	sub	sp, #28
   1ee98:	4604      	mov	r4, r0
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   1ee9a:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   1ee9c:	9504      	str	r5, [sp, #16]
   1ee9e:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   1eea0:	9503      	str	r5, [sp, #12]
   1eea2:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   1eea4:	9502      	str	r5, [sp, #8]
   1eea6:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   1eea8:	9501      	str	r5, [sp, #4]
   1eeaa:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   1eeac:	9500      	str	r5, [sp, #0]
   1eeae:	f7e7 fe7f 	bl	6bb0 <arch_new_thread>
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
   1eeb2:	4b03      	ldr	r3, [pc, #12]	; (1eec0 <z_setup_new_thread+0x2c>)
   1eeb4:	689b      	ldr	r3, [r3, #8]
   1eeb6:	b103      	cbz	r3, 1eeba <z_setup_new_thread+0x26>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
   1eeb8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
   1eeba:	6623      	str	r3, [r4, #96]	; 0x60
	sys_trace_thread_create(new_thread);
}
   1eebc:	b007      	add	sp, #28
   1eebe:	bd30      	pop	{r4, r5, pc}
   1eec0:	20006054 	.word	0x20006054

0001eec4 <z_impl_k_thread_create>:
k_tid_t z_impl_k_thread_create(struct k_thread *new_thread,
			      k_thread_stack_t *stack,
			      size_t stack_size, k_thread_entry_t entry,
			      void *p1, void *p2, void *p3,
			      int prio, u32_t options, s32_t delay)
{
   1eec4:	b570      	push	{r4, r5, r6, lr}
   1eec6:	b086      	sub	sp, #24
	__ASSERT((options & K_USER) == 0,
		 "Platform is capable of user mode, and test thread created with K_USER option,"
		 " but neither CONFIG_TEST_USERSPACE nor CONFIG_USERSPACE is set\n");
#endif

	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   1eec8:	2600      	movs	r6, #0
   1eeca:	9605      	str	r6, [sp, #20]
   1eecc:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   1eece:	9604      	str	r6, [sp, #16]
   1eed0:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   1eed2:	9603      	str	r6, [sp, #12]
   1eed4:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   1eed6:	9602      	str	r6, [sp, #8]
   1eed8:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
{
   1eeda:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   1eedc:	9601      	str	r6, [sp, #4]
   1eede:	9e0a      	ldr	r6, [sp, #40]	; 0x28
   1eee0:	9600      	str	r6, [sp, #0]
{
   1eee2:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   1eee4:	f7ff ffd6 	bl	1ee94 <z_setup_new_thread>
			  prio, options, NULL);

	if (delay != K_FOREVER) {
   1eee8:	1c6b      	adds	r3, r5, #1
   1eeea:	d003      	beq.n	1eef4 <z_impl_k_thread_create+0x30>
	if (delay == 0) {
   1eeec:	b92d      	cbnz	r5, 1eefa <z_impl_k_thread_create+0x36>
	z_impl_k_thread_start(thread);
   1eeee:	4620      	mov	r0, r4
   1eef0:	f7ff ffac 	bl	1ee4c <z_impl_k_thread_start>
		schedule_new_thread(new_thread, delay);
	}

	return new_thread;
}
   1eef4:	4620      	mov	r0, r4
   1eef6:	b006      	add	sp, #24
   1eef8:	bd70      	pop	{r4, r5, r6, pc}
			return (u32_t)((t * to_hz + off) / from_hz);
   1eefa:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   1eefe:	f240 30e7 	movw	r0, #999	; 0x3e7
   1ef02:	2100      	movs	r1, #0
   1ef04:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1ef08:	2300      	movs	r3, #0
   1ef0a:	fbe6 0105 	umlal	r0, r1, r6, r5
   1ef0e:	f7e1 f937 	bl	180 <__aeabi_uldivmod>
   1ef12:	4903      	ldr	r1, [pc, #12]	; (1ef20 <z_impl_k_thread_create+0x5c>)
   1ef14:	1c42      	adds	r2, r0, #1
   1ef16:	f104 0018 	add.w	r0, r4, #24
   1ef1a:	f000 f91f 	bl	1f15c <z_add_timeout>
   1ef1e:	e7e9      	b.n	1eef4 <z_impl_k_thread_create+0x30>
   1ef20:	00027d23 	.word	0x00027d23

0001ef24 <z_impl_k_thread_suspend>:
#endif /* CONFIG_MULTITHREADING */

extern void z_thread_single_suspend(struct k_thread *thread);

void z_impl_k_thread_suspend(struct k_thread *thread)
{
   1ef24:	b538      	push	{r3, r4, r5, lr}
   1ef26:	4605      	mov	r5, r0
	__asm__ volatile(
   1ef28:	f04f 0320 	mov.w	r3, #32
   1ef2c:	f3ef 8411 	mrs	r4, BASEPRI
   1ef30:	f383 8811 	msr	BASEPRI, r3
   1ef34:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);

	z_thread_single_suspend(thread);
   1ef38:	f7ff fd12 	bl	1e960 <z_thread_single_suspend>

	if (thread == _current) {
   1ef3c:	4b07      	ldr	r3, [pc, #28]	; (1ef5c <z_impl_k_thread_suspend+0x38>)
   1ef3e:	689b      	ldr	r3, [r3, #8]
   1ef40:	42ab      	cmp	r3, r5
   1ef42:	d105      	bne.n	1ef50 <z_impl_k_thread_suspend+0x2c>
		z_reschedule(&lock, key);
   1ef44:	4621      	mov	r1, r4
   1ef46:	4806      	ldr	r0, [pc, #24]	; (1ef60 <z_impl_k_thread_suspend+0x3c>)
	} else {
		k_spin_unlock(&lock, key);
	}
}
   1ef48:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&lock, key);
   1ef4c:	f008 bea4 	b.w	27c98 <z_reschedule>
	__asm__ volatile(
   1ef50:	f384 8811 	msr	BASEPRI, r4
   1ef54:	f3bf 8f6f 	isb	sy
}
   1ef58:	bd38      	pop	{r3, r4, r5, pc}
   1ef5a:	bf00      	nop
   1ef5c:	20006054 	.word	0x20006054
   1ef60:	2000abe3 	.word	0x2000abe3

0001ef64 <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
   1ef64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   1ef68:	4e28      	ldr	r6, [pc, #160]	; (1f00c <z_init_static_threads+0xa8>)
   1ef6a:	4d29      	ldr	r5, [pc, #164]	; (1f010 <z_init_static_threads+0xac>)
{
   1ef6c:	b087      	sub	sp, #28
   1ef6e:	46b0      	mov	r8, r6
	_FOREACH_STATIC_THREAD(thread_data) {
   1ef70:	42b5      	cmp	r5, r6
   1ef72:	f105 0430 	add.w	r4, r5, #48	; 0x30
   1ef76:	d310      	bcc.n	1ef9a <z_init_static_threads+0x36>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
   1ef78:	f7ff fbe0 	bl	1e73c <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   1ef7c:	4c24      	ldr	r4, [pc, #144]	; (1f010 <z_init_static_threads+0xac>)
   1ef7e:	f8df a094 	ldr.w	sl, [pc, #148]	; 1f014 <z_init_static_threads+0xb0>
   1ef82:	f44f 4900 	mov.w	r9, #32768	; 0x8000
   1ef86:	f240 36e7 	movw	r6, #999	; 0x3e7
   1ef8a:	2700      	movs	r7, #0
   1ef8c:	4544      	cmp	r4, r8
   1ef8e:	d321      	bcc.n	1efd4 <z_init_static_threads+0x70>
			schedule_new_thread(thread_data->init_thread,
					    thread_data->init_delay);
		}
	}
	k_sched_unlock();
}
   1ef90:	b007      	add	sp, #28
   1ef92:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	k_sched_unlock();
   1ef96:	f7ff bc19 	b.w	1e7cc <k_sched_unlock>
		z_setup_new_thread(
   1ef9a:	f854 3c04 	ldr.w	r3, [r4, #-4]
   1ef9e:	9305      	str	r3, [sp, #20]
   1efa0:	f854 3c10 	ldr.w	r3, [r4, #-16]
   1efa4:	9304      	str	r3, [sp, #16]
   1efa6:	f854 3c14 	ldr.w	r3, [r4, #-20]
   1efaa:	9303      	str	r3, [sp, #12]
   1efac:	f854 3c18 	ldr.w	r3, [r4, #-24]
   1efb0:	9302      	str	r3, [sp, #8]
   1efb2:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   1efb6:	9301      	str	r3, [sp, #4]
   1efb8:	f854 3c20 	ldr.w	r3, [r4, #-32]
   1efbc:	9300      	str	r3, [sp, #0]
   1efbe:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   1efc2:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   1efc6:	f7ff ff65 	bl	1ee94 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   1efca:	f854 3c30 	ldr.w	r3, [r4, #-48]
   1efce:	64dd      	str	r5, [r3, #76]	; 0x4c
   1efd0:	4625      	mov	r5, r4
   1efd2:	e7cd      	b.n	1ef70 <z_init_static_threads+0xc>
		if (thread_data->init_delay != K_FOREVER) {
   1efd4:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1efd6:	1c4b      	adds	r3, r1, #1
   1efd8:	d004      	beq.n	1efe4 <z_init_static_threads+0x80>
			schedule_new_thread(thread_data->init_thread,
   1efda:	6825      	ldr	r5, [r4, #0]
	if (delay == 0) {
   1efdc:	b921      	cbnz	r1, 1efe8 <z_init_static_threads+0x84>
   1efde:	4628      	mov	r0, r5
   1efe0:	f7ff ff34 	bl	1ee4c <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   1efe4:	3430      	adds	r4, #48	; 0x30
   1efe6:	e7d1      	b.n	1ef8c <z_init_static_threads+0x28>
   1efe8:	46b3      	mov	fp, r6
   1efea:	46bc      	mov	ip, r7
   1efec:	fbe9 bc01 	umlal	fp, ip, r9, r1
   1eff0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1eff4:	2300      	movs	r3, #0
   1eff6:	4658      	mov	r0, fp
   1eff8:	4661      	mov	r1, ip
   1effa:	f7e1 f8c1 	bl	180 <__aeabi_uldivmod>
   1effe:	4651      	mov	r1, sl
   1f000:	1c42      	adds	r2, r0, #1
   1f002:	f105 0018 	add.w	r0, r5, #24
   1f006:	f000 f8a9 	bl	1f15c <z_add_timeout>
   1f00a:	e7eb      	b.n	1efe4 <z_init_static_threads+0x80>
   1f00c:	2000eed8 	.word	0x2000eed8
   1f010:	2000eed8 	.word	0x2000eed8
   1f014:	00027d23 	.word	0x00027d23

0001f018 <k_work_q_start>:

extern void z_work_q_main(void *work_q_ptr, void *p2, void *p3);

void k_work_q_start(struct k_work_q *work_q, k_thread_stack_t *stack,
		    size_t stack_size, int prio)
{
   1f018:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1f01c:	4605      	mov	r5, r0
   1f01e:	b086      	sub	sp, #24
   1f020:	460e      	mov	r6, r1
   1f022:	4617      	mov	r7, r2
   1f024:	4698      	mov	r8, r3
	z_impl_k_queue_init(queue);
   1f026:	f008 fd65 	bl	27af4 <z_impl_k_queue_init>
	k_queue_init(&work_q->queue);
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
   1f02a:	f105 0414 	add.w	r4, r5, #20
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   1f02e:	2000      	movs	r0, #0
   1f030:	e9cd 0004 	strd	r0, r0, [sp, #16]
   1f034:	e9cd 0802 	strd	r0, r8, [sp, #8]
   1f038:	e9cd 5000 	strd	r5, r0, [sp]
   1f03c:	4b06      	ldr	r3, [pc, #24]	; (1f058 <k_work_q_start+0x40>)
   1f03e:	463a      	mov	r2, r7
   1f040:	4631      	mov	r1, r6
   1f042:	4620      	mov	r0, r4
   1f044:	f7ff ff3e 	bl	1eec4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   1f048:	4904      	ldr	r1, [pc, #16]	; (1f05c <k_work_q_start+0x44>)
   1f04a:	4620      	mov	r0, r4
			work_q, NULL, NULL, prio, 0, K_NO_WAIT);

	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}
   1f04c:	b006      	add	sp, #24
   1f04e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1f052:	f008 bee5 	b.w	27e20 <z_impl_k_thread_name_set>
   1f056:	bf00      	nop
   1f058:	0001fe23 	.word	0x0001fe23
   1f05c:	0006d943 	.word	0x0006d943

0001f060 <k_delayed_work_submit_to_queue>:
}

int k_delayed_work_submit_to_queue(struct k_work_q *work_q,
				   struct k_delayed_work *work,
				   s32_t delay)
{
   1f060:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1f064:	4606      	mov	r6, r0
   1f066:	460d      	mov	r5, r1
   1f068:	4617      	mov	r7, r2
	__asm__ volatile(
   1f06a:	f04f 0320 	mov.w	r3, #32
   1f06e:	f3ef 8811 	mrs	r8, BASEPRI
   1f072:	f383 8811 	msr	BASEPRI, r3
   1f076:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int err = 0;

	/* Work cannot be active in multiple queues */
	if (work->work_q != NULL && work->work_q != work_q) {
   1f07a:	69cc      	ldr	r4, [r1, #28]
   1f07c:	b15c      	cbz	r4, 1f096 <k_delayed_work_submit_to_queue+0x36>
   1f07e:	4284      	cmp	r4, r0
   1f080:	d12c      	bne.n	1f0dc <k_delayed_work_submit_to_queue+0x7c>
		goto done;
	}

	/* Cancel if work has been submitted */
	if (work->work_q == work_q) {
		err = work_cancel(work);
   1f082:	4628      	mov	r0, r5
   1f084:	f008 fefd 	bl	27e82 <work_cancel>
		if (err < 0) {
   1f088:	1e04      	subs	r4, r0, #0
   1f08a:	da06      	bge.n	1f09a <k_delayed_work_submit_to_queue+0x3a>
	__asm__ volatile(
   1f08c:	f388 8811 	msr	BASEPRI, r8
   1f090:	f3bf 8f6f 	isb	sy
	z_add_timeout(&work->timeout, work_timeout,
		     _TICK_ALIGN + k_ms_to_ticks_ceil32(delay));

done:
	k_spin_unlock(&lock, key);
	return err;
   1f094:	e00c      	b.n	1f0b0 <k_delayed_work_submit_to_queue+0x50>
	if (work->work_q == work_q) {
   1f096:	2800      	cmp	r0, #0
   1f098:	d0f3      	beq.n	1f082 <k_delayed_work_submit_to_queue+0x22>
	work->work_q = work_q;
   1f09a:	61ee      	str	r6, [r5, #28]
	if (delay == 0) {
   1f09c:	b95f      	cbnz	r7, 1f0b6 <k_delayed_work_submit_to_queue+0x56>
   1f09e:	f388 8811 	msr	BASEPRI, r8
   1f0a2:	f3bf 8f6f 	isb	sy
		k_work_submit_to_queue(work_q, &work->work);
   1f0a6:	4629      	mov	r1, r5
   1f0a8:	4630      	mov	r0, r6
   1f0aa:	f008 fecd 	bl	27e48 <k_work_submit_to_queue>
		return 0;
   1f0ae:	463c      	mov	r4, r7
}
   1f0b0:	4620      	mov	r0, r4
   1f0b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1f0b6:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   1f0ba:	f240 30e7 	movw	r0, #999	; 0x3e7
   1f0be:	2100      	movs	r1, #0
   1f0c0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1f0c4:	2300      	movs	r3, #0
   1f0c6:	fbe6 0107 	umlal	r0, r1, r6, r7
   1f0ca:	f7e1 f859 	bl	180 <__aeabi_uldivmod>
	z_add_timeout(&work->timeout, work_timeout,
   1f0ce:	4905      	ldr	r1, [pc, #20]	; (1f0e4 <k_delayed_work_submit_to_queue+0x84>)
   1f0d0:	1c42      	adds	r2, r0, #1
   1f0d2:	f105 000c 	add.w	r0, r5, #12
   1f0d6:	f000 f841 	bl	1f15c <z_add_timeout>
   1f0da:	e7d7      	b.n	1f08c <k_delayed_work_submit_to_queue+0x2c>
		err = -EADDRINUSE;
   1f0dc:	f06f 046f 	mvn.w	r4, #111	; 0x6f
   1f0e0:	e7d4      	b.n	1f08c <k_delayed_work_submit_to_queue+0x2c>
   1f0e2:	bf00      	nop
   1f0e4:	00027e79 	.word	0x00027e79

0001f0e8 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
   1f0e8:	4b03      	ldr	r3, [pc, #12]	; (1f0f8 <elapsed+0x10>)
   1f0ea:	681b      	ldr	r3, [r3, #0]
   1f0ec:	b90b      	cbnz	r3, 1f0f2 <elapsed+0xa>
   1f0ee:	f7e7 bbeb 	b.w	68c8 <z_clock_elapsed>
}
   1f0f2:	2000      	movs	r0, #0
   1f0f4:	4770      	bx	lr
   1f0f6:	bf00      	nop
   1f0f8:	20006110 	.word	0x20006110

0001f0fc <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1f0fc:	6803      	ldr	r3, [r0, #0]
   1f0fe:	b140      	cbz	r0, 1f112 <remove_timeout+0x16>
   1f100:	4a07      	ldr	r2, [pc, #28]	; (1f120 <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
   1f102:	6852      	ldr	r2, [r2, #4]
   1f104:	4290      	cmp	r0, r2
   1f106:	d004      	beq.n	1f112 <remove_timeout+0x16>
	if (next(t) != NULL) {
   1f108:	b11b      	cbz	r3, 1f112 <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
   1f10a:	689a      	ldr	r2, [r3, #8]
   1f10c:	6881      	ldr	r1, [r0, #8]
   1f10e:	440a      	add	r2, r1
   1f110:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
   1f112:	6842      	ldr	r2, [r0, #4]
   1f114:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   1f116:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   1f118:	2300      	movs	r3, #0
	node->prev = NULL;
   1f11a:	e9c0 3300 	strd	r3, r3, [r0]
}
   1f11e:	4770      	bx	lr
   1f120:	2000ec0c 	.word	0x2000ec0c

0001f124 <next_timeout>:
	return list->head == list;
   1f124:	4b0b      	ldr	r3, [pc, #44]	; (1f154 <next_timeout+0x30>)

static s32_t next_timeout(void)
{
   1f126:	b510      	push	{r4, lr}
   1f128:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1f12a:	429c      	cmp	r4, r3
   1f12c:	bf08      	it	eq
   1f12e:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
   1f130:	f7ff ffda 	bl	1f0e8 <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   1f134:	b154      	cbz	r4, 1f14c <next_timeout+0x28>
   1f136:	68a3      	ldr	r3, [r4, #8]
   1f138:	1a18      	subs	r0, r3, r0
   1f13a:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   1f13e:	4b06      	ldr	r3, [pc, #24]	; (1f158 <next_timeout+0x34>)
   1f140:	691b      	ldr	r3, [r3, #16]
   1f142:	b113      	cbz	r3, 1f14a <next_timeout+0x26>
   1f144:	4298      	cmp	r0, r3
   1f146:	bfa8      	it	ge
   1f148:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   1f14a:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   1f14c:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   1f150:	e7f5      	b.n	1f13e <next_timeout+0x1a>
   1f152:	bf00      	nop
   1f154:	2000ec0c 	.word	0x2000ec0c
   1f158:	20006054 	.word	0x20006054

0001f15c <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
   1f15c:	b570      	push	{r4, r5, r6, lr}
   1f15e:	4604      	mov	r4, r0
   1f160:	4616      	mov	r6, r2
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   1f162:	60c1      	str	r1, [r0, #12]
	__asm__ volatile(
   1f164:	f04f 0320 	mov.w	r3, #32
   1f168:	f3ef 8511 	mrs	r5, BASEPRI
   1f16c:	f383 8811 	msr	BASEPRI, r3
   1f170:	f3bf 8f6f 	isb	sy
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
   1f174:	f7ff ffb8 	bl	1f0e8 <elapsed>
	return list->head == list;
   1f178:	4b18      	ldr	r3, [pc, #96]	; (1f1dc <z_add_timeout+0x80>)
   1f17a:	681a      	ldr	r2, [r3, #0]
   1f17c:	2e01      	cmp	r6, #1
   1f17e:	bfac      	ite	ge
   1f180:	1980      	addge	r0, r0, r6
   1f182:	3001      	addlt	r0, #1
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1f184:	429a      	cmp	r2, r3
   1f186:	60a0      	str	r0, [r4, #8]
   1f188:	d001      	beq.n	1f18e <z_add_timeout+0x32>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1f18a:	685e      	ldr	r6, [r3, #4]
		for (t = first(); t != NULL; t = next(t)) {
   1f18c:	b932      	cbnz	r2, 1f19c <z_add_timeout+0x40>
	node->prev = list->tail;
   1f18e:	685a      	ldr	r2, [r3, #4]
   1f190:	6062      	str	r2, [r4, #4]
	list->tail->next = node;
   1f192:	685a      	ldr	r2, [r3, #4]
	node->next = list;
   1f194:	6023      	str	r3, [r4, #0]
	list->tail->next = node;
   1f196:	6014      	str	r4, [r2, #0]
	list->tail = node;
   1f198:	605c      	str	r4, [r3, #4]
   1f19a:	e00a      	b.n	1f1b2 <z_add_timeout+0x56>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
   1f19c:	6890      	ldr	r0, [r2, #8]
   1f19e:	68a1      	ldr	r1, [r4, #8]
   1f1a0:	4288      	cmp	r0, r1
   1f1a2:	dd15      	ble.n	1f1d0 <z_add_timeout+0x74>
				t->dticks -= to->dticks;
   1f1a4:	1a41      	subs	r1, r0, r1
   1f1a6:	6091      	str	r1, [r2, #8]
	node->prev = successor->prev;
   1f1a8:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
   1f1aa:	e9c4 2100 	strd	r2, r1, [r4]
	successor->prev->next = node;
   1f1ae:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   1f1b0:	6054      	str	r4, [r2, #4]
	return list->head == list;
   1f1b2:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1f1b4:	429a      	cmp	r2, r3
   1f1b6:	d006      	beq.n	1f1c6 <z_add_timeout+0x6a>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   1f1b8:	4294      	cmp	r4, r2
   1f1ba:	d104      	bne.n	1f1c6 <z_add_timeout+0x6a>
			z_clock_set_timeout(next_timeout(), false);
   1f1bc:	f7ff ffb2 	bl	1f124 <next_timeout>
   1f1c0:	2100      	movs	r1, #0
   1f1c2:	f7e7 fb2b 	bl	681c <z_clock_set_timeout>
	__asm__ volatile(
   1f1c6:	f385 8811 	msr	BASEPRI, r5
   1f1ca:	f3bf 8f6f 	isb	sy
		}
	}
}
   1f1ce:	bd70      	pop	{r4, r5, r6, pc}
			to->dticks -= t->dticks;
   1f1d0:	1a09      	subs	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
   1f1d2:	42b2      	cmp	r2, r6
   1f1d4:	60a1      	str	r1, [r4, #8]
   1f1d6:	d0da      	beq.n	1f18e <z_add_timeout+0x32>
   1f1d8:	6812      	ldr	r2, [r2, #0]
   1f1da:	e7d7      	b.n	1f18c <z_add_timeout+0x30>
   1f1dc:	2000ec0c 	.word	0x2000ec0c

0001f1e0 <z_timeout_remaining>:

	return ret;
}

s32_t z_timeout_remaining(struct _timeout *timeout)
{
   1f1e0:	b538      	push	{r3, r4, r5, lr}
	s32_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
   1f1e2:	6804      	ldr	r4, [r0, #0]
   1f1e4:	b314      	cbz	r4, 1f22c <z_timeout_remaining+0x4c>
	__asm__ volatile(
   1f1e6:	f04f 0320 	mov.w	r3, #32
   1f1ea:	f3ef 8111 	mrs	r1, BASEPRI
   1f1ee:	f383 8811 	msr	BASEPRI, r3
   1f1f2:	f3bf 8f6f 	isb	sy
	return list->head == list;
   1f1f6:	4a0e      	ldr	r2, [pc, #56]	; (1f230 <z_timeout_remaining+0x50>)
   1f1f8:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1f1fa:	4293      	cmp	r3, r2
   1f1fc:	d014      	beq.n	1f228 <z_timeout_remaining+0x48>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1f1fe:	6852      	ldr	r2, [r2, #4]
   1f200:	2400      	movs	r4, #0
		return 0;
	}

	LOCKED(&timeout_lock) {
		for (struct _timeout *t = first(); t != NULL; t = next(t)) {
   1f202:	b93b      	cbnz	r3, 1f214 <z_timeout_remaining+0x34>
	__asm__ volatile(
   1f204:	f381 8811 	msr	BASEPRI, r1
   1f208:	f3bf 8f6f 	isb	sy
				break;
			}
		}
	}

	return ticks - elapsed();
   1f20c:	f7ff ff6c 	bl	1f0e8 <elapsed>
   1f210:	1a20      	subs	r0, r4, r0
}
   1f212:	bd38      	pop	{r3, r4, r5, pc}
			ticks += t->dticks;
   1f214:	689d      	ldr	r5, [r3, #8]
			if (timeout == t) {
   1f216:	4283      	cmp	r3, r0
			ticks += t->dticks;
   1f218:	442c      	add	r4, r5
			if (timeout == t) {
   1f21a:	d0f3      	beq.n	1f204 <z_timeout_remaining+0x24>
   1f21c:	2b00      	cmp	r3, #0
   1f21e:	d0f1      	beq.n	1f204 <z_timeout_remaining+0x24>
	return (node == list->tail) ? NULL : node->next;
   1f220:	4293      	cmp	r3, r2
   1f222:	d0ef      	beq.n	1f204 <z_timeout_remaining+0x24>
   1f224:	681b      	ldr	r3, [r3, #0]
   1f226:	e7ec      	b.n	1f202 <z_timeout_remaining+0x22>
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1f228:	2400      	movs	r4, #0
   1f22a:	e7eb      	b.n	1f204 <z_timeout_remaining+0x24>
		return 0;
   1f22c:	4620      	mov	r0, r4
   1f22e:	e7f0      	b.n	1f212 <z_timeout_remaining+0x32>
   1f230:	2000ec0c 	.word	0x2000ec0c

0001f234 <z_clock_announce>:
		}
	}
}

void z_clock_announce(s32_t ticks)
{
   1f234:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
   1f238:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   1f23a:	f7ff fb5b 	bl	1e8f4 <z_time_slice>
	__asm__ volatile(
   1f23e:	f04f 0320 	mov.w	r3, #32
   1f242:	f3ef 8511 	mrs	r5, BASEPRI
   1f246:	f383 8811 	msr	BASEPRI, r3
   1f24a:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   1f24e:	4e21      	ldr	r6, [pc, #132]	; (1f2d4 <z_clock_announce+0xa0>)
   1f250:	4f21      	ldr	r7, [pc, #132]	; (1f2d8 <z_clock_announce+0xa4>)
	return list->head == list;
   1f252:	f8df 9088 	ldr.w	r9, [pc, #136]	; 1f2dc <z_clock_announce+0xa8>
   1f256:	6034      	str	r4, [r6, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
   1f258:	46b8      	mov	r8, r7
   1f25a:	f8d9 4000 	ldr.w	r4, [r9]
   1f25e:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1f260:	454c      	cmp	r4, r9
   1f262:	e9d7 bc00 	ldrd	fp, ip, [r7]
   1f266:	d005      	beq.n	1f274 <z_clock_announce+0x40>
   1f268:	b124      	cbz	r4, 1f274 <z_clock_announce+0x40>
   1f26a:	68a3      	ldr	r3, [r4, #8]
   1f26c:	4293      	cmp	r3, r2
   1f26e:	dd14      	ble.n	1f29a <z_clock_announce+0x66>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   1f270:	1a9b      	subs	r3, r3, r2
   1f272:	60a3      	str	r3, [r4, #8]
	}

	curr_tick += announce_remaining;
   1f274:	eb1b 0002 	adds.w	r0, fp, r2
   1f278:	eb4c 71e2 	adc.w	r1, ip, r2, asr #31
	announce_remaining = 0;
   1f27c:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
   1f27e:	e9c8 0100 	strd	r0, r1, [r8]
	announce_remaining = 0;
   1f282:	6034      	str	r4, [r6, #0]

	z_clock_set_timeout(next_timeout(), false);
   1f284:	f7ff ff4e 	bl	1f124 <next_timeout>
   1f288:	4621      	mov	r1, r4
   1f28a:	f7e7 fac7 	bl	681c <z_clock_set_timeout>
	__asm__ volatile(
   1f28e:	f385 8811 	msr	BASEPRI, r5
   1f292:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   1f296:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		curr_tick += dt;
   1f29a:	eb1b 0003 	adds.w	r0, fp, r3
   1f29e:	eb4c 71e3 	adc.w	r1, ip, r3, asr #31
		announce_remaining -= dt;
   1f2a2:	1ad3      	subs	r3, r2, r3
   1f2a4:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
   1f2a6:	2300      	movs	r3, #0
		curr_tick += dt;
   1f2a8:	e9c7 0100 	strd	r0, r1, [r7]
		t->dticks = 0;
   1f2ac:	60a3      	str	r3, [r4, #8]
		remove_timeout(t);
   1f2ae:	4620      	mov	r0, r4
   1f2b0:	f7ff ff24 	bl	1f0fc <remove_timeout>
   1f2b4:	f385 8811 	msr	BASEPRI, r5
   1f2b8:	f3bf 8f6f 	isb	sy
		t->fn(t);
   1f2bc:	68e3      	ldr	r3, [r4, #12]
   1f2be:	4798      	blx	r3
	__asm__ volatile(
   1f2c0:	f04f 0320 	mov.w	r3, #32
   1f2c4:	f3ef 8511 	mrs	r5, BASEPRI
   1f2c8:	f383 8811 	msr	BASEPRI, r3
   1f2cc:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
   1f2d0:	e7c3      	b.n	1f25a <z_clock_announce+0x26>
   1f2d2:	bf00      	nop
   1f2d4:	20006110 	.word	0x20006110
   1f2d8:	20000018 	.word	0x20000018
   1f2dc:	2000ec0c 	.word	0x2000ec0c

0001f2e0 <z_tick_get>:

s64_t z_tick_get(void)
{
   1f2e0:	e92d 4818 	stmdb	sp!, {r3, r4, fp, lr}
   1f2e4:	f04f 0320 	mov.w	r3, #32
   1f2e8:	f3ef 8411 	mrs	r4, BASEPRI
   1f2ec:	f383 8811 	msr	BASEPRI, r3
   1f2f0:	f3bf 8f6f 	isb	sy
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
   1f2f4:	f7e7 fae8 	bl	68c8 <z_clock_elapsed>
   1f2f8:	4b07      	ldr	r3, [pc, #28]	; (1f318 <z_tick_get+0x38>)
   1f2fa:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f2fe:	eb12 0b00 	adds.w	fp, r2, r0
   1f302:	f143 0c00 	adc.w	ip, r3, #0
   1f306:	4658      	mov	r0, fp
   1f308:	4661      	mov	r1, ip
	__asm__ volatile(
   1f30a:	f384 8811 	msr	BASEPRI, r4
   1f30e:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   1f312:	e8bd 8818 	ldmia.w	sp!, {r3, r4, fp, pc}
   1f316:	bf00      	nop
   1f318:	20000018 	.word	0x20000018

0001f31c <z_timer_expiration_handler>:

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
   1f31c:	6a02      	ldr	r2, [r0, #32]
   1f31e:	2a00      	cmp	r2, #0
{
   1f320:	b538      	push	{r3, r4, r5, lr}
   1f322:	4604      	mov	r4, r0
	if (timer->period > 0) {
   1f324:	dd02      	ble.n	1f32c <z_timer_expiration_handler+0x10>
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   1f326:	490e      	ldr	r1, [pc, #56]	; (1f360 <z_timer_expiration_handler+0x44>)
   1f328:	f7ff ff18 	bl	1f15c <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   1f32c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1f32e:	3301      	adds	r3, #1
   1f330:	6263      	str	r3, [r4, #36]	; 0x24

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   1f332:	69a3      	ldr	r3, [r4, #24]
   1f334:	b10b      	cbz	r3, 1f33a <z_timer_expiration_handler+0x1e>
		timer->expiry_fn(timer);
   1f336:	4620      	mov	r0, r4
   1f338:	4798      	blx	r3
	return list->head == list;
   1f33a:	f854 5f10 	ldr.w	r5, [r4, #16]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1f33e:	42a5      	cmp	r5, r4
   1f340:	d00d      	beq.n	1f35e <z_timer_expiration_handler+0x42>
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   1f342:	b165      	cbz	r5, 1f35e <z_timer_expiration_handler+0x42>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
   1f344:	4628      	mov	r0, r5
   1f346:	f008 fc8e 	bl	27c66 <z_unpend_thread_no_timeout>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1f34a:	7b6b      	ldrb	r3, [r5, #13]
   1f34c:	06db      	lsls	r3, r3, #27
   1f34e:	d104      	bne.n	1f35a <z_timer_expiration_handler+0x3e>
	if (z_is_thread_ready(thread)) {
   1f350:	69ab      	ldr	r3, [r5, #24]
   1f352:	b913      	cbnz	r3, 1f35a <z_timer_expiration_handler+0x3e>
		z_add_thread_to_ready_q(thread);
   1f354:	4628      	mov	r0, r5
   1f356:	f7ff fa55 	bl	1e804 <z_add_thread_to_ready_q>
   1f35a:	2300      	movs	r3, #0
   1f35c:	66ab      	str	r3, [r5, #104]	; 0x68

	z_ready_thread(thread);

	arch_thread_return_value_set(thread, 0);
}
   1f35e:	bd38      	pop	{r3, r4, r5, pc}
   1f360:	0001f31d 	.word	0x0001f31d

0001f364 <z_impl_k_timer_start>:
	z_object_init(timer);
}


void z_impl_k_timer_start(struct k_timer *timer, s32_t duration, s32_t period)
{
   1f364:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   1f368:	f240 36e7 	movw	r6, #999	; 0x3e7
   1f36c:	2700      	movs	r7, #0
   1f36e:	4604      	mov	r4, r0
   1f370:	4688      	mov	r8, r1
   1f372:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   1f376:	4630      	mov	r0, r6
   1f378:	4639      	mov	r1, r7
   1f37a:	fbe5 0102 	umlal	r0, r1, r5, r2
   1f37e:	2300      	movs	r3, #0
   1f380:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1f384:	f7e0 fefc 	bl	180 <__aeabi_uldivmod>
   1f388:	4639      	mov	r1, r7
	__ASSERT(duration >= 0 && period >= 0 &&
		 (duration != 0 || period != 0), "invalid parameters\n");

	volatile s32_t period_in_ticks, duration_in_ticks;

	period_in_ticks = k_ms_to_ticks_ceil32(period);
   1f38a:	9000      	str	r0, [sp, #0]
   1f38c:	4630      	mov	r0, r6
   1f38e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1f392:	2300      	movs	r3, #0
   1f394:	fbe5 0108 	umlal	r0, r1, r5, r8
   1f398:	f7e0 fef2 	bl	180 <__aeabi_uldivmod>
	duration_in_ticks = k_ms_to_ticks_ceil32(duration);
   1f39c:	9001      	str	r0, [sp, #4]

	(void)z_abort_timeout(&timer->timeout);
   1f39e:	4620      	mov	r0, r4
   1f3a0:	f008 fdce 	bl	27f40 <z_abort_timeout>
	timer->period = period_in_ticks;
   1f3a4:	9b00      	ldr	r3, [sp, #0]
	timer->status = 0U;
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   1f3a6:	4905      	ldr	r1, [pc, #20]	; (1f3bc <z_impl_k_timer_start+0x58>)
   1f3a8:	9a01      	ldr	r2, [sp, #4]
	timer->period = period_in_ticks;
   1f3aa:	6223      	str	r3, [r4, #32]
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   1f3ac:	4620      	mov	r0, r4
	timer->status = 0U;
   1f3ae:	2300      	movs	r3, #0
   1f3b0:	6263      	str	r3, [r4, #36]	; 0x24
		     duration_in_ticks);
}
   1f3b2:	b002      	add	sp, #8
   1f3b4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   1f3b8:	f7ff bed0 	b.w	1f15c <z_add_timeout>
   1f3bc:	0001f31d 	.word	0x0001f31d

0001f3c0 <k_poll_event_init>:
 */
static struct k_spinlock lock;

void k_poll_event_init(struct k_poll_event *event, u32_t type,
		       int mode, void *obj)
{
   1f3c0:	b510      	push	{r4, lr}
	__ASSERT(type < (BIT(_POLL_NUM_TYPES)), "invalid type\n");
	__ASSERT(obj != NULL, "must provide an object\n");

	event->poller = NULL;
	/* event->tag is left uninitialized: the user will set it if needed */
	event->type = type;
   1f3c2:	7b44      	ldrb	r4, [r0, #13]
   1f3c4:	f361 0403 	bfi	r4, r1, #0, #4
	event->state = K_POLL_STATE_NOT_READY;
	event->mode = mode;
   1f3c8:	7b81      	ldrb	r1, [r0, #14]
	event->type = type;
   1f3ca:	7344      	strb	r4, [r0, #13]
	event->mode = mode;
   1f3cc:	f362 0141 	bfi	r1, r2, #1, #1
   1f3d0:	7381      	strb	r1, [r0, #14]
	event->poller = NULL;
   1f3d2:	2200      	movs	r2, #0
	event->state = K_POLL_STATE_NOT_READY;
   1f3d4:	68c1      	ldr	r1, [r0, #12]
	event->poller = NULL;
   1f3d6:	6082      	str	r2, [r0, #8]
	event->state = K_POLL_STATE_NOT_READY;
   1f3d8:	4a02      	ldr	r2, [pc, #8]	; (1f3e4 <k_poll_event_init+0x24>)
   1f3da:	400a      	ands	r2, r1
	event->unused = 0U;
	event->obj = obj;
   1f3dc:	e9c0 2303 	strd	r2, r3, [r0, #12]
}
   1f3e0:	bd10      	pop	{r4, pc}
   1f3e2:	bf00      	nop
   1f3e4:	00020fff 	.word	0x00020fff

0001f3e8 <z_impl_k_poll>:

	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events, s32_t timeout)
{
   1f3e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1f3ec:	b086      	sub	sp, #24
	int events_registered;
	k_spinlock_key_t key;
	struct _poller poller = { .is_polling = true,
   1f3ee:	2301      	movs	r3, #1
   1f3f0:	f88d 300c 	strb.w	r3, [sp, #12]
				  .thread     = _current,
   1f3f4:	4b23      	ldr	r3, [pc, #140]	; (1f484 <z_impl_k_poll+0x9c>)
	struct _poller poller = { .is_polling = true,
   1f3f6:	689b      	ldr	r3, [r3, #8]
   1f3f8:	9304      	str	r3, [sp, #16]
   1f3fa:	4b23      	ldr	r3, [pc, #140]	; (1f488 <z_impl_k_poll+0xa0>)
   1f3fc:	9305      	str	r3, [sp, #20]

	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(events != NULL, "NULL events\n");
	__ASSERT(num_events >= 0, "<0 events\n");

	events_registered = register_events(events, num_events, &poller,
   1f3fe:	fab2 f382 	clz	r3, r2
   1f402:	4690      	mov	r8, r2
   1f404:	095b      	lsrs	r3, r3, #5
   1f406:	aa03      	add	r2, sp, #12
{
   1f408:	4606      	mov	r6, r0
	events_registered = register_events(events, num_events, &poller,
   1f40a:	f008 feb6 	bl	2817a <register_events>
   1f40e:	4607      	mov	r7, r0
	__asm__ volatile(
   1f410:	f04f 0320 	mov.w	r3, #32
   1f414:	f3ef 8511 	mrs	r5, BASEPRI
   1f418:	f383 8811 	msr	BASEPRI, r3
   1f41c:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller.is_polling) {
   1f420:	f89d 300c 	ldrb.w	r3, [sp, #12]
   1f424:	f003 04ff 	and.w	r4, r3, #255	; 0xff
   1f428:	b94b      	cbnz	r3, 1f43e <z_impl_k_poll+0x56>
	 * we've already know the return code (-EAGAIN), and even if they are
	 * added to the list of events that occurred, the user has to check the
	 * return code first, which invalidates the whole list of event states.
	 */
	key = k_spin_lock(&lock);
	clear_event_registrations(events, events_registered, key);
   1f42a:	462a      	mov	r2, r5
   1f42c:	4639      	mov	r1, r7
   1f42e:	4630      	mov	r0, r6
   1f430:	f008 fe0b 	bl	2804a <clear_event_registrations>
	__asm__ volatile(
   1f434:	f385 8811 	msr	BASEPRI, r5
   1f438:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	return swap_rc;
   1f43c:	e00b      	b.n	1f456 <z_impl_k_poll+0x6e>
	poller.is_polling = false;
   1f43e:	2300      	movs	r3, #0
   1f440:	f88d 300c 	strb.w	r3, [sp, #12]
	if (timeout == K_NO_WAIT) {
   1f444:	f1b8 0f00 	cmp.w	r8, #0
   1f448:	d109      	bne.n	1f45e <z_impl_k_poll+0x76>
   1f44a:	f385 8811 	msr	BASEPRI, r5
   1f44e:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
   1f452:	f06f 040a 	mvn.w	r4, #10
}
   1f456:	4620      	mov	r0, r4
   1f458:	b006      	add	sp, #24
   1f45a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   1f45e:	aa01      	add	r2, sp, #4
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   1f460:	4643      	mov	r3, r8
   1f462:	4629      	mov	r1, r5
   1f464:	4809      	ldr	r0, [pc, #36]	; (1f48c <z_impl_k_poll+0xa4>)
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   1f466:	e9cd 2201 	strd	r2, r2, [sp, #4]
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   1f46a:	f7ff fb7d 	bl	1eb68 <z_pend_curr>
   1f46e:	4604      	mov	r4, r0
	__asm__ volatile(
   1f470:	f04f 0320 	mov.w	r3, #32
   1f474:	f3ef 8511 	mrs	r5, BASEPRI
   1f478:	f383 8811 	msr	BASEPRI, r3
   1f47c:	f3bf 8f6f 	isb	sy
   1f480:	e7d3      	b.n	1f42a <z_impl_k_poll+0x42>
   1f482:	bf00      	nop
   1f484:	20006054 	.word	0x20006054
   1f488:	000280db 	.word	0x000280db
   1f48c:	2000abe4 	.word	0x2000abe4

0001f490 <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *signal, int result)
{
   1f490:	b538      	push	{r3, r4, r5, lr}
   1f492:	f04f 0320 	mov.w	r3, #32
   1f496:	f3ef 8511 	mrs	r5, BASEPRI
   1f49a:	f383 8811 	msr	BASEPRI, r3
   1f49e:	f3bf 8f6f 	isb	sy
	return list->head == list;
   1f4a2:	6803      	ldr	r3, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	signal->result = result;
   1f4a4:	60c1      	str	r1, [r0, #12]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   1f4a6:	4298      	cmp	r0, r3
	signal->signaled = 1U;
   1f4a8:	f04f 0101 	mov.w	r1, #1
   1f4ac:	6081      	str	r1, [r0, #8]
   1f4ae:	d106      	bne.n	1f4be <z_impl_k_poll_signal_raise+0x2e>
	__asm__ volatile(
   1f4b0:	f385 8811 	msr	BASEPRI, r5
   1f4b4:	f3bf 8f6f 	isb	sy

	poll_event = (struct k_poll_event *)sys_dlist_get(&signal->poll_events);
	if (poll_event == NULL) {
		k_spin_unlock(&lock, key);
		return 0;
   1f4b8:	2400      	movs	r4, #0

	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);

	z_reschedule(&lock, key);
	return rc;
}
   1f4ba:	4620      	mov	r0, r4
   1f4bc:	bd38      	pop	{r3, r4, r5, pc}
	node->prev->next = node->next;
   1f4be:	e9d3 2000 	ldrd	r2, r0, [r3]
   1f4c2:	6002      	str	r2, [r0, #0]
	node->next->prev = node->prev;
   1f4c4:	6050      	str	r0, [r2, #4]
	node->next = NULL;
   1f4c6:	2200      	movs	r2, #0
	node->prev = NULL;
   1f4c8:	e9c3 2200 	strd	r2, r2, [r3]
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   1f4cc:	4618      	mov	r0, r3
   1f4ce:	f008 fde9 	bl	280a4 <signal_poll_event>
	z_reschedule(&lock, key);
   1f4d2:	4629      	mov	r1, r5
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   1f4d4:	4604      	mov	r4, r0
	z_reschedule(&lock, key);
   1f4d6:	4802      	ldr	r0, [pc, #8]	; (1f4e0 <z_impl_k_poll_signal_raise+0x50>)
   1f4d8:	f008 fbde 	bl	27c98 <z_reschedule>
	return rc;
   1f4dc:	e7ed      	b.n	1f4ba <z_impl_k_poll_signal_raise+0x2a>
   1f4de:	bf00      	nop
   1f4e0:	2000abe4 	.word	0x2000abe4

0001f4e4 <read_signed>:
{
   1f4e4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	return bt_gatt_attr_read(conn, attr, buf, len, offset, value,
   1f4e6:	2404      	movs	r4, #4
   1f4e8:	9402      	str	r4, [sp, #8]
   1f4ea:	68cc      	ldr	r4, [r1, #12]
   1f4ec:	9401      	str	r4, [sp, #4]
   1f4ee:	f8bd 4018 	ldrh.w	r4, [sp, #24]
   1f4f2:	9400      	str	r4, [sp, #0]
   1f4f4:	f003 ffd4 	bl	234a0 <bt_gatt_attr_read>
}
   1f4f8:	b004      	add	sp, #16
   1f4fa:	bd10      	pop	{r4, pc}

0001f4fc <read_long_vnd>:
{
   1f4fc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	return bt_gatt_attr_read(conn, attr, buf, len, offset, value,
   1f4fe:	244a      	movs	r4, #74	; 0x4a
   1f500:	9402      	str	r4, [sp, #8]
   1f502:	68cc      	ldr	r4, [r1, #12]
   1f504:	9401      	str	r4, [sp, #4]
   1f506:	f8bd 4018 	ldrh.w	r4, [sp, #24]
   1f50a:	9400      	str	r4, [sp, #0]
   1f50c:	f003 ffc8 	bl	234a0 <bt_gatt_attr_read>
}
   1f510:	b004      	add	sp, #16
   1f512:	bd10      	pop	{r4, pc}

0001f514 <read_vnd>:
{
   1f514:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	char *value = attr->user_data;
   1f518:	68cd      	ldr	r5, [r1, #12]
{
   1f51a:	4606      	mov	r6, r0
				 strlen(value));
   1f51c:	4628      	mov	r0, r5
{
   1f51e:	4698      	mov	r8, r3
   1f520:	460c      	mov	r4, r1
   1f522:	4617      	mov	r7, r2
				 strlen(value));
   1f524:	f7e2 fbc0 	bl	1ca8 <strlen>
	return bt_gatt_attr_read(conn, attr, buf, len, offset, value,
   1f528:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   1f52c:	9300      	str	r3, [sp, #0]
   1f52e:	b280      	uxth	r0, r0
   1f530:	e9cd 5001 	strd	r5, r0, [sp, #4]
   1f534:	4643      	mov	r3, r8
   1f536:	463a      	mov	r2, r7
   1f538:	4621      	mov	r1, r4
   1f53a:	4630      	mov	r0, r6
   1f53c:	f003 ffb0 	bl	234a0 <bt_gatt_attr_read>
}
   1f540:	b004      	add	sp, #16
   1f542:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0001f546 <write_without_rsp_vnd>:
{
   1f546:	b570      	push	{r4, r5, r6, lr}
   1f548:	4616      	mov	r6, r2
	if (!(flags & BT_GATT_WRITE_FLAG_CMD)) {
   1f54a:	f89d 2014 	ldrb.w	r2, [sp, #20]
{
   1f54e:	f8bd 0010 	ldrh.w	r0, [sp, #16]
	u8_t *value = attr->user_data;
   1f552:	68cd      	ldr	r5, [r1, #12]
	if (!(flags & BT_GATT_WRITE_FLAG_CMD)) {
   1f554:	0792      	lsls	r2, r2, #30
   1f556:	d50a      	bpl.n	1f56e <write_without_rsp_vnd+0x28>
	if (offset + len > sizeof(vnd_value)) {
   1f558:	461c      	mov	r4, r3
   1f55a:	18c3      	adds	r3, r0, r3
   1f55c:	2b06      	cmp	r3, #6
   1f55e:	dc09      	bgt.n	1f574 <write_without_rsp_vnd+0x2e>
   1f560:	4622      	mov	r2, r4
   1f562:	4631      	mov	r1, r6
   1f564:	4428      	add	r0, r5
   1f566:	f7e2 fb41 	bl	1bec <memcpy>
}
   1f56a:	4620      	mov	r0, r4
   1f56c:	bd70      	pop	{r4, r5, r6, pc}
		return BT_GATT_ERR(BT_ATT_ERR_WRITE_REQ_REJECTED);
   1f56e:	f06f 04fb 	mvn.w	r4, #251	; 0xfb
   1f572:	e7fa      	b.n	1f56a <write_without_rsp_vnd+0x24>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1f574:	f06f 0406 	mvn.w	r4, #6
   1f578:	e7f7      	b.n	1f56a <write_without_rsp_vnd+0x24>

0001f57a <write_signed>:
{
   1f57a:	b570      	push	{r4, r5, r6, lr}
   1f57c:	f8bd 0010 	ldrh.w	r0, [sp, #16]
	u8_t *value = attr->user_data;
   1f580:	68cd      	ldr	r5, [r1, #12]
	if (offset + len > sizeof(signed_value)) {
   1f582:	461c      	mov	r4, r3
   1f584:	18c3      	adds	r3, r0, r3
   1f586:	2b04      	cmp	r3, #4
{
   1f588:	4616      	mov	r6, r2
	if (offset + len > sizeof(signed_value)) {
   1f58a:	dc06      	bgt.n	1f59a <write_signed+0x20>
   1f58c:	4622      	mov	r2, r4
   1f58e:	4631      	mov	r1, r6
   1f590:	4428      	add	r0, r5
   1f592:	f7e2 fb2b 	bl	1bec <memcpy>
}
   1f596:	4620      	mov	r0, r4
   1f598:	bd70      	pop	{r4, r5, r6, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1f59a:	f06f 0406 	mvn.w	r4, #6
   1f59e:	e7fa      	b.n	1f596 <write_signed+0x1c>

0001f5a0 <write_long_vnd>:
{
   1f5a0:	b538      	push	{r3, r4, r5, lr}
   1f5a2:	460d      	mov	r5, r1
   1f5a4:	4611      	mov	r1, r2
	if (flags & BT_GATT_WRITE_FLAG_PREPARE) {
   1f5a6:	f89d 2014 	ldrb.w	r2, [sp, #20]
{
   1f5aa:	f8bd 0010 	ldrh.w	r0, [sp, #16]
	if (flags & BT_GATT_WRITE_FLAG_PREPARE) {
   1f5ae:	07d2      	lsls	r2, r2, #31
   1f5b0:	d40a      	bmi.n	1f5c8 <write_long_vnd+0x28>
	if (offset + len > sizeof(vnd_long_value)) {
   1f5b2:	461c      	mov	r4, r3
   1f5b4:	18c3      	adds	r3, r0, r3
   1f5b6:	2b4a      	cmp	r3, #74	; 0x4a
   1f5b8:	dc08      	bgt.n	1f5cc <write_long_vnd+0x2c>
	memcpy(value + offset, buf, len);
   1f5ba:	68eb      	ldr	r3, [r5, #12]
   1f5bc:	4622      	mov	r2, r4
   1f5be:	4418      	add	r0, r3
   1f5c0:	f7e2 fb14 	bl	1bec <memcpy>
}
   1f5c4:	4620      	mov	r0, r4
   1f5c6:	bd38      	pop	{r3, r4, r5, pc}
		return 0;
   1f5c8:	2400      	movs	r4, #0
   1f5ca:	e7fb      	b.n	1f5c4 <write_long_vnd+0x24>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1f5cc:	f06f 0406 	mvn.w	r4, #6
   1f5d0:	e7f8      	b.n	1f5c4 <write_long_vnd+0x24>

0001f5d2 <write_vnd>:
{
   1f5d2:	b570      	push	{r4, r5, r6, lr}
   1f5d4:	f8bd 0010 	ldrh.w	r0, [sp, #16]
	u8_t *value = attr->user_data;
   1f5d8:	68cd      	ldr	r5, [r1, #12]
	if (offset + len > sizeof(vnd_value)) {
   1f5da:	461c      	mov	r4, r3
   1f5dc:	18c3      	adds	r3, r0, r3
   1f5de:	2b06      	cmp	r3, #6
{
   1f5e0:	4616      	mov	r6, r2
	if (offset + len > sizeof(vnd_value)) {
   1f5e2:	dc06      	bgt.n	1f5f2 <write_vnd+0x20>
   1f5e4:	4622      	mov	r2, r4
   1f5e6:	4631      	mov	r1, r6
   1f5e8:	4428      	add	r0, r5
   1f5ea:	f7e2 faff 	bl	1bec <memcpy>
}
   1f5ee:	4620      	mov	r0, r4
   1f5f0:	bd70      	pop	{r4, r5, r6, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1f5f2:	f06f 0406 	mvn.w	r4, #6
   1f5f6:	e7fa      	b.n	1f5ee <write_vnd+0x1c>

0001f5f8 <ct_ccc_cfg_changed>:
}
   1f5f8:	4770      	bx	lr

0001f5fa <read_ct>:
{
   1f5fa:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	return bt_gatt_attr_read(conn, attr, buf, len, offset, value,
   1f5fc:	240a      	movs	r4, #10
   1f5fe:	9402      	str	r4, [sp, #8]
   1f600:	68cc      	ldr	r4, [r1, #12]
   1f602:	9401      	str	r4, [sp, #4]
   1f604:	f8bd 4018 	ldrh.w	r4, [sp, #24]
   1f608:	9400      	str	r4, [sp, #0]
   1f60a:	f003 ff49 	bl	234a0 <bt_gatt_attr_read>
}
   1f60e:	b004      	add	sp, #16
   1f610:	bd10      	pop	{r4, pc}

0001f612 <lv_scr_act>:
/**
 * Get the active screen of the default display
 * @return pointer to the active screen
 */
static inline lv_obj_t * lv_scr_act(void)
{
   1f612:	b508      	push	{r3, lr}
    return lv_disp_get_scr_act(lv_disp_get_default());
   1f614:	f7fd f9ee 	bl	1c9f4 <lv_disp_get_default>
}
   1f618:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return lv_disp_get_scr_act(lv_disp_get_default());
   1f61c:	f7fb baae 	b.w	1ab7c <lv_disp_get_scr_act>

0001f620 <counter_set_channel_alarm.constprop.2>:
 * @retval -ENOTSUP if request is not supported (device does not support
 *		    interrupts or requested channel).
 * @retval -EINVAL if alarm settings are invalid.
 * @retval -ETIME  if absolute alarm was set too late.
 */
static inline int counter_set_channel_alarm(struct device *dev, u8_t chan_id,
   1f620:	460a      	mov	r2, r1
	const struct counter_config_info *config =
   1f622:	e9d0 3100 	ldrd	r3, r1, [r0]
	return config->channels;
   1f626:	689b      	ldr	r3, [r3, #8]
				      const struct counter_alarm_cfg *alarm_cfg)
{
	const struct counter_driver_api *api =
				(struct counter_driver_api *)dev->driver_api;

	if (chan_id >= counter_get_num_of_channels(dev)) {
   1f628:	7a5b      	ldrb	r3, [r3, #9]
   1f62a:	b113      	cbz	r3, 1f632 <counter_set_channel_alarm.constprop.2+0x12>
		return -ENOTSUP;
	}

	return api->set_alarm(dev, chan_id, alarm_cfg);
   1f62c:	68cb      	ldr	r3, [r1, #12]
   1f62e:	2100      	movs	r1, #0
   1f630:	4718      	bx	r3
}
   1f632:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1f636:	4770      	bx	lr

0001f638 <u8_to_dec>:
 */

#include <sys/util.h>

u8_t u8_to_dec(char *buf, u8_t buflen, u8_t value)
{
   1f638:	b5f0      	push	{r4, r5, r6, r7, lr}
	u8_t divisor = 100;
	u8_t num_digits = 0;
   1f63a:	2300      	movs	r3, #0
	u8_t digit;

	while (buflen > 0 && divisor > 0) {
   1f63c:	2504      	movs	r5, #4
	u8_t divisor = 100;
   1f63e:	2464      	movs	r4, #100	; 0x64
			buflen--;
			num_digits++;
		}

		value -= digit * divisor;
		divisor /= 10;
   1f640:	f04f 0c0a 	mov.w	ip, #10
	while (buflen > 0 && divisor > 0) {
   1f644:	b111      	cbz	r1, 1f64c <u8_to_dec+0x14>
   1f646:	3d01      	subs	r5, #1
   1f648:	d102      	bne.n	1f650 <u8_to_dec+0x18>
	}

	if (buflen) {
		*buf = '\0';
   1f64a:	7005      	strb	r5, [r0, #0]
	}

	return num_digits;
}
   1f64c:	4618      	mov	r0, r3
   1f64e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (digit != 0 || divisor == 1 || num_digits != 0) {
   1f650:	42a2      	cmp	r2, r4
		digit = value / divisor;
   1f652:	fbb2 f7f4 	udiv	r7, r2, r4
   1f656:	b2fe      	uxtb	r6, r7
		if (digit != 0 || divisor == 1 || num_digits != 0) {
   1f658:	d202      	bcs.n	1f660 <u8_to_dec+0x28>
   1f65a:	2c01      	cmp	r4, #1
   1f65c:	d000      	beq.n	1f660 <u8_to_dec+0x28>
   1f65e:	b133      	cbz	r3, 1f66e <u8_to_dec+0x36>
			*buf = (char)digit + '0';
   1f660:	3630      	adds	r6, #48	; 0x30
			buflen--;
   1f662:	3901      	subs	r1, #1
			num_digits++;
   1f664:	3301      	adds	r3, #1
			*buf = (char)digit + '0';
   1f666:	f800 6b01 	strb.w	r6, [r0], #1
			buflen--;
   1f66a:	b2c9      	uxtb	r1, r1
			num_digits++;
   1f66c:	b2db      	uxtb	r3, r3
		value -= digit * divisor;
   1f66e:	fb04 2217 	mls	r2, r4, r7, r2
   1f672:	b2d2      	uxtb	r2, r2
		divisor /= 10;
   1f674:	fbb4 f4fc 	udiv	r4, r4, ip
   1f678:	e7e4      	b.n	1f644 <u8_to_dec+0xc>

0001f67a <char2hex>:
#include <errno.h>
#include <sys/util.h>

int char2hex(char c, u8_t *x)
{
	if (c >= '0' && c <= '9') {
   1f67a:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
   1f67e:	b2db      	uxtb	r3, r3
   1f680:	2b09      	cmp	r3, #9
   1f682:	d802      	bhi.n	1f68a <char2hex+0x10>
		*x = c - '0';
   1f684:	700b      	strb	r3, [r1, #0]
		*x = c - 'A' + 10;
	} else {
		return -EINVAL;
	}

	return 0;
   1f686:	2000      	movs	r0, #0
   1f688:	4770      	bx	lr
	} else if (c >= 'a' && c <= 'f') {
   1f68a:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
   1f68e:	2b05      	cmp	r3, #5
   1f690:	d802      	bhi.n	1f698 <char2hex+0x1e>
		*x = c - 'a' + 10;
   1f692:	3857      	subs	r0, #87	; 0x57
   1f694:	7008      	strb	r0, [r1, #0]
   1f696:	e7f6      	b.n	1f686 <char2hex+0xc>
	} else if (c >= 'A' && c <= 'F') {
   1f698:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
   1f69c:	2b05      	cmp	r3, #5
   1f69e:	d801      	bhi.n	1f6a4 <char2hex+0x2a>
		*x = c - 'A' + 10;
   1f6a0:	3837      	subs	r0, #55	; 0x37
   1f6a2:	e7f7      	b.n	1f694 <char2hex+0x1a>
		return -EINVAL;
   1f6a4:	f06f 0015 	mvn.w	r0, #21
}
   1f6a8:	4770      	bx	lr

0001f6aa <hex2bin>:
	hex[2 * buflen] = '\0';
	return 2 * buflen;
}

size_t hex2bin(const char *hex, size_t hexlen, u8_t *buf, size_t buflen)
{
   1f6aa:	b573      	push	{r0, r1, r4, r5, r6, lr}
	u8_t dec;

	if (buflen < hexlen / 2 + hexlen % 2) {
   1f6ac:	084d      	lsrs	r5, r1, #1
   1f6ae:	f001 0101 	and.w	r1, r1, #1
   1f6b2:	186e      	adds	r6, r5, r1
   1f6b4:	429e      	cmp	r6, r3
{
   1f6b6:	4604      	mov	r4, r0
	if (buflen < hexlen / 2 + hexlen % 2) {
   1f6b8:	d903      	bls.n	1f6c2 <hex2bin+0x18>
		return 0;
   1f6ba:	2600      	movs	r6, #0
		}
		buf[i] += dec;
	}

	return hexlen / 2 + hexlen % 2;
}
   1f6bc:	4630      	mov	r0, r6
   1f6be:	b002      	add	sp, #8
   1f6c0:	bd70      	pop	{r4, r5, r6, pc}
	if (hexlen % 2) {
   1f6c2:	b159      	cbz	r1, 1f6dc <hex2bin+0x32>
		if (char2hex(hex[0], &dec) < 0) {
   1f6c4:	f10d 0107 	add.w	r1, sp, #7
   1f6c8:	7800      	ldrb	r0, [r0, #0]
   1f6ca:	f7ff ffd6 	bl	1f67a <char2hex>
   1f6ce:	2800      	cmp	r0, #0
   1f6d0:	dbf3      	blt.n	1f6ba <hex2bin+0x10>
		buf[0] = dec;
   1f6d2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1f6d6:	f802 3b01 	strb.w	r3, [r2], #1
		hex++;
   1f6da:	3401      	adds	r4, #1
	for (size_t i = 0; i < hexlen / 2; i++) {
   1f6dc:	3a01      	subs	r2, #1
   1f6de:	eb04 0545 	add.w	r5, r4, r5, lsl #1
   1f6e2:	42ac      	cmp	r4, r5
   1f6e4:	d0ea      	beq.n	1f6bc <hex2bin+0x12>
		if (char2hex(hex[2 * i], &dec) < 0) {
   1f6e6:	f10d 0107 	add.w	r1, sp, #7
   1f6ea:	7820      	ldrb	r0, [r4, #0]
   1f6ec:	f7ff ffc5 	bl	1f67a <char2hex>
   1f6f0:	2800      	cmp	r0, #0
   1f6f2:	dbe2      	blt.n	1f6ba <hex2bin+0x10>
		buf[i] = dec << 4;
   1f6f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1f6f8:	011b      	lsls	r3, r3, #4
   1f6fa:	7053      	strb	r3, [r2, #1]
		if (char2hex(hex[2 * i + 1], &dec) < 0) {
   1f6fc:	7860      	ldrb	r0, [r4, #1]
   1f6fe:	f10d 0107 	add.w	r1, sp, #7
   1f702:	f7ff ffba 	bl	1f67a <char2hex>
   1f706:	2800      	cmp	r0, #0
   1f708:	f104 0402 	add.w	r4, r4, #2
   1f70c:	dbd5      	blt.n	1f6ba <hex2bin+0x10>
		buf[i] += dec;
   1f70e:	f812 3f01 	ldrb.w	r3, [r2, #1]!
   1f712:	f89d 1007 	ldrb.w	r1, [sp, #7]
   1f716:	440b      	add	r3, r1
   1f718:	7013      	strb	r3, [r2, #0]
   1f71a:	e7e2      	b.n	1f6e2 <hex2bin+0x38>

0001f71c <get_bit_ptr>:
/* Places a 32 bit output pointer in word, and an integer bit index
 * within that word as the return value
 */
static int get_bit_ptr(struct sys_mem_pool_base *p, int level, int bn,
		       u32_t **word)
{
   1f71c:	b570      	push	{r4, r5, r6, lr}
   1f71e:	68c6      	ldr	r6, [r0, #12]
	u32_t *bitarray = level <= p->max_inline_level ?
   1f720:	f990 000b 	ldrsb.w	r0, [r0, #11]
   1f724:	250c      	movs	r5, #12
   1f726:	434d      	muls	r5, r1
		p->levels[level].bits : p->levels[level].bits_p;
   1f728:	4288      	cmp	r0, r1
   1f72a:	eb06 0405 	add.w	r4, r6, r5
   1f72e:	bfb8      	it	lt
   1f730:	5974      	ldrlt	r4, [r6, r5]

	*word = &bitarray[bn / 32];
   1f732:	2a00      	cmp	r2, #0
   1f734:	4610      	mov	r0, r2
   1f736:	bfb8      	it	lt
   1f738:	f102 001f 	addlt.w	r0, r2, #31
   1f73c:	1140      	asrs	r0, r0, #5
   1f73e:	eb04 0180 	add.w	r1, r4, r0, lsl #2
   1f742:	6019      	str	r1, [r3, #0]

	return bn & 0x1f;
}
   1f744:	f002 001f 	and.w	r0, r2, #31
   1f748:	bd70      	pop	{r4, r5, r6, pc}

0001f74a <pool_irq_lock.isra.2.part.3>:
	__asm__ volatile(
   1f74a:	f04f 0320 	mov.w	r3, #32
   1f74e:	f3ef 8011 	mrs	r0, BASEPRI
   1f752:	f383 8811 	msr	BASEPRI, r3
   1f756:	f3bf 8f6f 	isb	sy
	if (p->flags & SYS_MEM_POOL_KERNEL) {
		return irq_lock();
	} else {
		return 0;
	}
}
   1f75a:	4770      	bx	lr

0001f75c <pool_irq_unlock.isra.4>:

static inline void pool_irq_unlock(struct sys_mem_pool_base *p, int key)
{
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   1f75c:	07c3      	lsls	r3, r0, #31
   1f75e:	d503      	bpl.n	1f768 <pool_irq_unlock.isra.4+0xc>
	__asm__ volatile(
   1f760:	f381 8811 	msr	BASEPRI, r1
   1f764:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}
}
   1f768:	4770      	bx	lr

0001f76a <z_sys_mem_pool_base_init>:
{
   1f76a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   1f76e:	6846      	ldr	r6, [r0, #4]
   1f770:	8907      	ldrh	r7, [r0, #8]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
   1f772:	6801      	ldr	r1, [r0, #0]
	for (i = 0; i < p->n_levels; i++) {
   1f774:	f890 800a 	ldrb.w	r8, [r0, #10]
	p->max_inline_level = -1;
   1f778:	23ff      	movs	r3, #255	; 0xff
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   1f77a:	fb06 fc07 	mul.w	ip, r6, r7
	p->max_inline_level = -1;
   1f77e:	72c3      	strb	r3, [r0, #11]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
   1f780:	4461      	add	r1, ip
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   1f782:	4632      	mov	r2, r6
	for (i = 0; i < p->n_levels; i++) {
   1f784:	2300      	movs	r3, #0
		sys_dlist_init(&p->levels[i].free_list);
   1f786:	f04f 090c 	mov.w	r9, #12
	for (i = 0; i < p->n_levels; i++) {
   1f78a:	4598      	cmp	r8, r3
   1f78c:	dc05      	bgt.n	1f79a <z_sys_mem_pool_base_init+0x30>
   1f78e:	2300      	movs	r3, #0
	for (i = 0; i < p->n_max; i++) {
   1f790:	4619      	mov	r1, r3
   1f792:	428f      	cmp	r7, r1
   1f794:	dc20      	bgt.n	1f7d8 <z_sys_mem_pool_base_init+0x6e>
}
   1f796:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		sys_dlist_init(&p->levels[i].free_list);
   1f79a:	f8d0 a00c 	ldr.w	sl, [r0, #12]
		int nblocks = buflen / sz;
   1f79e:	fbbc f5f2 	udiv	r5, ip, r2
		sys_dlist_init(&p->levels[i].free_list);
   1f7a2:	fb09 fe03 	mul.w	lr, r9, r3
   1f7a6:	eb0a 040e 	add.w	r4, sl, lr
   1f7aa:	f104 0b04 	add.w	fp, r4, #4
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
   1f7ae:	2d20      	cmp	r5, #32
	list->tail = (sys_dnode_t *)list;
   1f7b0:	e9c4 bb01 	strd	fp, fp, [r4, #4]
   1f7b4:	d805      	bhi.n	1f7c2 <z_sys_mem_pool_base_init+0x58>
			p->max_inline_level = i;
   1f7b6:	72c3      	strb	r3, [r0, #11]
		sz = WB_DN(sz / 4);
   1f7b8:	0892      	lsrs	r2, r2, #2
   1f7ba:	f022 0203 	bic.w	r2, r2, #3
	for (i = 0; i < p->n_levels; i++) {
   1f7be:	3301      	adds	r3, #1
   1f7c0:	e7e3      	b.n	1f78a <z_sys_mem_pool_base_init+0x20>
			bits += (nblocks + 31)/32;
   1f7c2:	f115 041f 	adds.w	r4, r5, #31
   1f7c6:	bf48      	it	mi
   1f7c8:	f105 043e 	addmi.w	r4, r5, #62	; 0x3e
   1f7cc:	1164      	asrs	r4, r4, #5
			p->levels[i].bits_p = bits;
   1f7ce:	f84a 100e 	str.w	r1, [sl, lr]
			bits += (nblocks + 31)/32;
   1f7d2:	eb01 0184 	add.w	r1, r1, r4, lsl #2
   1f7d6:	e7ef      	b.n	1f7b8 <z_sys_mem_pool_base_init+0x4e>
		sys_dlist_append(&p->levels[0].free_list, block);
   1f7d8:	68c2      	ldr	r2, [r0, #12]
	return (u8_t *)p->buf + lsz * block;
   1f7da:	6805      	ldr	r5, [r0, #0]
		sys_dlist_append(&p->levels[0].free_list, block);
   1f7dc:	f102 0c04 	add.w	ip, r2, #4
	return (u8_t *)p->buf + lsz * block;
   1f7e0:	18ec      	adds	r4, r5, r3
	node->next = list;
   1f7e2:	f845 c003 	str.w	ip, [r5, r3]
	node->prev = list->tail;
   1f7e6:	6895      	ldr	r5, [r2, #8]
   1f7e8:	6065      	str	r5, [r4, #4]
	list->tail->next = node;
   1f7ea:	6895      	ldr	r5, [r2, #8]
	for (i = 0; i < p->n_max; i++) {
   1f7ec:	3101      	adds	r1, #1
   1f7ee:	602c      	str	r4, [r5, #0]
	list->tail = node;
   1f7f0:	4433      	add	r3, r6
   1f7f2:	6094      	str	r4, [r2, #8]
   1f7f4:	e7cd      	b.n	1f792 <z_sys_mem_pool_base_init+0x28>

0001f7f6 <z_sys_mem_pool_block_alloc>:
	return block;
}

int z_sys_mem_pool_block_alloc(struct sys_mem_pool_base *p, size_t size,
			      u32_t *level_p, u32_t *block_p, void **data_p)
{
   1f7f6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1f7fa:	b087      	sub	sp, #28
	int i, from_l, alloc_l = -1;
	unsigned int key;
	void *data = NULL;
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   1f7fc:	7a85      	ldrb	r5, [r0, #10]
{
   1f7fe:	af00      	add	r7, sp, #0
   1f800:	e9c7 3201 	strd	r3, r2, [r7, #4]
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   1f804:	00ab      	lsls	r3, r5, #2
   1f806:	3307      	adds	r3, #7
   1f808:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
   1f80c:	ebad 0d03 	sub.w	sp, sp, r3
   1f810:	46ea      	mov	sl, sp
	 * want to allocate and the smallest one with a free entry
	 * from which we can split an allocation if needed.  Along the
	 * way, we populate an array of sizes for each level so we
	 * don't need to waste RAM storing it.
	 */
	lsizes[0] = p->max_sz;
   1f812:	4653      	mov	r3, sl
   1f814:	6842      	ldr	r2, [r0, #4]
   1f816:	f843 2904 	str.w	r2, [r3], #-4
{
   1f81a:	4604      	mov	r4, r0
	for (i = 0; i < p->n_levels; i++) {
   1f81c:	2200      	movs	r2, #0
   1f81e:	4295      	cmp	r5, r2
   1f820:	f102 39ff 	add.w	r9, r2, #4294967295	; 0xffffffff
   1f824:	dd09      	ble.n	1f83a <z_sys_mem_pool_block_alloc+0x44>
		if (i > 0) {
   1f826:	b122      	cbz	r2, 1f832 <z_sys_mem_pool_block_alloc+0x3c>
			lsizes[i] = WB_DN(lsizes[i-1] / 4);
   1f828:	6818      	ldr	r0, [r3, #0]
   1f82a:	0880      	lsrs	r0, r0, #2
   1f82c:	f020 0003 	bic.w	r0, r0, #3
   1f830:	6058      	str	r0, [r3, #4]
		}

		if (lsizes[i] < size) {
   1f832:	f853 0f04 	ldr.w	r0, [r3, #4]!
   1f836:	4288      	cmp	r0, r1
   1f838:	d208      	bcs.n	1f84c <z_sys_mem_pool_block_alloc+0x56>
		}

		alloc_l = i;
	}

	if (alloc_l < 0) {
   1f83a:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   1f83e:	d107      	bne.n	1f850 <z_sys_mem_pool_block_alloc+0x5a>
		*data_p = NULL;
   1f840:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1f842:	2300      	movs	r3, #0
   1f844:	6013      	str	r3, [r2, #0]
	pool_irq_unlock(p, key);

	*data_p = data;

	if (data == NULL) {
		return -ENOMEM;
   1f846:	f06f 000b 	mvn.w	r0, #11
   1f84a:	e044      	b.n	1f8d6 <z_sys_mem_pool_block_alloc+0xe0>
	for (i = 0; i < p->n_levels; i++) {
   1f84c:	3201      	adds	r2, #1
   1f84e:	e7e6      	b.n	1f81e <z_sys_mem_pool_block_alloc+0x28>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   1f850:	7c20      	ldrb	r0, [r4, #16]
   1f852:	f010 0001 	ands.w	r0, r0, #1
   1f856:	d001      	beq.n	1f85c <z_sys_mem_pool_block_alloc+0x66>
   1f858:	f7ff ff77 	bl	1f74a <pool_irq_lock.isra.2.part.3>
   1f85c:	68e2      	ldr	r2, [r4, #12]
   1f85e:	230c      	movs	r3, #12
	key = pool_irq_lock(p);
   1f860:	4680      	mov	r8, r0
	for (i = alloc_l; i >= 0; i--) {
   1f862:	fb03 2309 	mla	r3, r3, r9, r2
	block = sys_dlist_get(&p->levels[l].free_list);
   1f866:	464e      	mov	r6, r9
	return list->head == list;
   1f868:	461a      	mov	r2, r3
   1f86a:	f852 5f04 	ldr.w	r5, [r2, #4]!
	if (!sys_dlist_is_empty(list)) {
   1f86e:	4295      	cmp	r5, r2
   1f870:	d06d      	beq.n	1f94e <z_sys_mem_pool_block_alloc+0x158>
	node->prev->next = node->next;
   1f872:	e9d5 3200 	ldrd	r3, r2, [r5]
   1f876:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   1f878:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   1f87a:	2300      	movs	r3, #0
	node->prev = NULL;
   1f87c:	e9c5 3300 	strd	r3, r3, [r5]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   1f880:	6823      	ldr	r3, [r4, #0]
		data = block_alloc(p, i, lsizes[i]);
   1f882:	f85a 1026 	ldr.w	r1, [sl, r6, lsl #2]
	int bit = get_bit_ptr(p, level, bn, &word);
   1f886:	f107 0b14 	add.w	fp, r7, #20
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   1f88a:	1aea      	subs	r2, r5, r3
	int bit = get_bit_ptr(p, level, bn, &word);
   1f88c:	4620      	mov	r0, r4
   1f88e:	fb92 f2f1 	sdiv	r2, r2, r1
   1f892:	465b      	mov	r3, fp
   1f894:	4631      	mov	r1, r6
   1f896:	f7ff ff41 	bl	1f71c <get_bit_ptr>
	*word |= (1<<bit);
   1f89a:	6979      	ldr	r1, [r7, #20]
   1f89c:	2201      	movs	r2, #1
   1f89e:	680b      	ldr	r3, [r1, #0]
   1f8a0:	603a      	str	r2, [r7, #0]
   1f8a2:	fa02 f000 	lsl.w	r0, r2, r0
   1f8a6:	4303      	orrs	r3, r0
   1f8a8:	600b      	str	r3, [r1, #0]
			for (from_l = i; from_l < alloc_l; from_l++) {
   1f8aa:	454e      	cmp	r6, r9
   1f8ac:	db17      	blt.n	1f8de <z_sys_mem_pool_block_alloc+0xe8>
	pool_irq_unlock(p, key);
   1f8ae:	4641      	mov	r1, r8
   1f8b0:	7c20      	ldrb	r0, [r4, #16]
   1f8b2:	f7ff ff53 	bl	1f75c <pool_irq_unlock.isra.4>
	*data_p = data;
   1f8b6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1f8b8:	601d      	str	r5, [r3, #0]
	if (data == NULL) {
   1f8ba:	2d00      	cmp	r5, #0
   1f8bc:	d0c3      	beq.n	1f846 <z_sys_mem_pool_block_alloc+0x50>
	}

	*level_p = alloc_l;
   1f8be:	68bb      	ldr	r3, [r7, #8]
   1f8c0:	f8c3 9000 	str.w	r9, [r3]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   1f8c4:	6823      	ldr	r3, [r4, #0]
   1f8c6:	1aed      	subs	r5, r5, r3
   1f8c8:	f85a 3029 	ldr.w	r3, [sl, r9, lsl #2]
   1f8cc:	fb95 f5f3 	sdiv	r5, r5, r3
	*block_p = block_num(p, data, lsizes[alloc_l]);
   1f8d0:	687b      	ldr	r3, [r7, #4]

	return 0;
   1f8d2:	2000      	movs	r0, #0
	*block_p = block_num(p, data, lsizes[alloc_l]);
   1f8d4:	601d      	str	r5, [r3, #0]
}
   1f8d6:	371c      	adds	r7, #28
   1f8d8:	46bd      	mov	sp, r7
   1f8da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   1f8de:	6822      	ldr	r2, [r4, #0]
   1f8e0:	f85a 3026 	ldr.w	r3, [sl, r6, lsl #2]
	set_alloc_bit(p, l + 1, 4*bn);
   1f8e4:	3601      	adds	r6, #1
	int bit = get_bit_ptr(p, level, bn, &word);
   1f8e6:	4631      	mov	r1, r6
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   1f8e8:	1aaa      	subs	r2, r5, r2
	int bit = get_bit_ptr(p, level, bn, &word);
   1f8ea:	4620      	mov	r0, r4
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   1f8ec:	fb92 f2f3 	sdiv	r2, r2, r3
	int bit = get_bit_ptr(p, level, bn, &word);
   1f8f0:	465b      	mov	r3, fp
   1f8f2:	0092      	lsls	r2, r2, #2
   1f8f4:	f7ff ff12 	bl	1f71c <get_bit_ptr>
	*word |= (1<<bit);
   1f8f8:	697a      	ldr	r2, [r7, #20]
   1f8fa:	683b      	ldr	r3, [r7, #0]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   1f8fc:	68e1      	ldr	r1, [r4, #12]
	*word |= (1<<bit);
   1f8fe:	fa03 f000 	lsl.w	r0, r3, r0
   1f902:	6813      	ldr	r3, [r2, #0]
   1f904:	4303      	orrs	r3, r0
   1f906:	6013      	str	r3, [r2, #0]
		int lsz = lsizes[l + 1];
   1f908:	f85a 0026 	ldr.w	r0, [sl, r6, lsl #2]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   1f90c:	230c      	movs	r3, #12
   1f90e:	fb03 1106 	mla	r1, r3, r6, r1
   1f912:	2203      	movs	r2, #3
   1f914:	f101 0e04 	add.w	lr, r1, #4
   1f918:	182b      	adds	r3, r5, r0
   1f91a:	60fa      	str	r2, [r7, #12]
	node->prev = list->tail;
   1f91c:	688a      	ldr	r2, [r1, #8]
   1f91e:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
   1f920:	688a      	ldr	r2, [r1, #8]
	node->next = list;
   1f922:	f8c3 e000 	str.w	lr, [r3]
	list->tail->next = node;
   1f926:	6013      	str	r3, [r2, #0]
	for (i = 1; i < 4; i++) {
   1f928:	68fa      	ldr	r2, [r7, #12]
	list->tail = node;
   1f92a:	608b      	str	r3, [r1, #8]
   1f92c:	3a01      	subs	r2, #1
   1f92e:	4403      	add	r3, r0
   1f930:	60fa      	str	r2, [r7, #12]
   1f932:	d1f3      	bne.n	1f91c <z_sys_mem_pool_block_alloc+0x126>
				pool_irq_unlock(p, key);
   1f934:	4641      	mov	r1, r8
   1f936:	7c20      	ldrb	r0, [r4, #16]
   1f938:	f7ff ff10 	bl	1f75c <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   1f93c:	7c23      	ldrb	r3, [r4, #16]
   1f93e:	07d9      	lsls	r1, r3, #31
   1f940:	d503      	bpl.n	1f94a <z_sys_mem_pool_block_alloc+0x154>
   1f942:	f7ff ff02 	bl	1f74a <pool_irq_lock.isra.2.part.3>
				key = pool_irq_lock(p);
   1f946:	4680      	mov	r8, r0
   1f948:	e7af      	b.n	1f8aa <z_sys_mem_pool_block_alloc+0xb4>
		return 0;
   1f94a:	68f8      	ldr	r0, [r7, #12]
   1f94c:	e7fb      	b.n	1f946 <z_sys_mem_pool_block_alloc+0x150>
	for (i = alloc_l; i >= 0; i--) {
   1f94e:	3e01      	subs	r6, #1
   1f950:	1c72      	adds	r2, r6, #1
   1f952:	f1a3 030c 	sub.w	r3, r3, #12
   1f956:	d187      	bne.n	1f868 <z_sys_mem_pool_block_alloc+0x72>
   1f958:	2500      	movs	r5, #0
   1f95a:	e7a8      	b.n	1f8ae <z_sys_mem_pool_block_alloc+0xb8>

0001f95c <z_sys_mem_pool_block_free>:

void z_sys_mem_pool_block_free(struct sys_mem_pool_base *p, u32_t level,
			      u32_t block)
{
   1f95c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1f960:	b085      	sub	sp, #20
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   1f962:	7a83      	ldrb	r3, [r0, #10]
   1f964:	009b      	lsls	r3, r3, #2
   1f966:	3307      	adds	r3, #7
   1f968:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
{
   1f96c:	af00      	add	r7, sp, #0
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   1f96e:	ebad 0d03 	sub.w	sp, sp, r3
   1f972:	46eb      	mov	fp, sp
	 * to avoid having to store it in precious RAM bytes.
	 * Overhead here is somewhat higher because block_free()
	 * doesn't inherently need to traverse all the larger
	 * sublevels.
	 */
	lsizes[0] = p->max_sz;
   1f974:	6843      	ldr	r3, [r0, #4]
   1f976:	f8cb 3000 	str.w	r3, [fp]
{
   1f97a:	4606      	mov	r6, r0
	for (i = 1; i <= level; i++) {
   1f97c:	465c      	mov	r4, fp
   1f97e:	2001      	movs	r0, #1
   1f980:	4281      	cmp	r1, r0
   1f982:	d215      	bcs.n	1f9b0 <z_sys_mem_pool_block_free+0x54>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   1f984:	7c30      	ldrb	r0, [r6, #16]
   1f986:	f010 0001 	ands.w	r0, r0, #1
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
	}

	block_free(p, level, lsizes, block);
   1f98a:	4688      	mov	r8, r1
   1f98c:	4615      	mov	r5, r2
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   1f98e:	d001      	beq.n	1f994 <z_sys_mem_pool_block_free+0x38>
   1f990:	f7ff fedb 	bl	1f74a <pool_irq_lock.isra.2.part.3>
	unsigned int key = pool_irq_lock(p);
   1f994:	4604      	mov	r4, r0
	while (level >= 0) {
   1f996:	f1b8 0f00 	cmp.w	r8, #0
   1f99a:	da11      	bge.n	1f9c0 <z_sys_mem_pool_block_free+0x64>
	return -1;
   1f99c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	pool_irq_unlock(p, key);
   1f9a0:	4621      	mov	r1, r4
   1f9a2:	7c30      	ldrb	r0, [r6, #16]
   1f9a4:	f7ff feda 	bl	1f75c <pool_irq_unlock.isra.4>
}
   1f9a8:	3714      	adds	r7, #20
   1f9aa:	46bd      	mov	sp, r7
   1f9ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
   1f9b0:	6823      	ldr	r3, [r4, #0]
   1f9b2:	089b      	lsrs	r3, r3, #2
   1f9b4:	f023 0303 	bic.w	r3, r3, #3
   1f9b8:	f844 3f04 	str.w	r3, [r4, #4]!
	for (i = 1; i <= level; i++) {
   1f9bc:	3001      	adds	r0, #1
   1f9be:	e7df      	b.n	1f980 <z_sys_mem_pool_block_free+0x24>
		int i, lsz = lsizes[level];
   1f9c0:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
   1f9c4:	607b      	str	r3, [r7, #4]
	return (u8_t *)p->buf + lsz * block;
   1f9c6:	fb03 fa05 	mul.w	sl, r3, r5
   1f9ca:	6833      	ldr	r3, [r6, #0]
   1f9cc:	603b      	str	r3, [r7, #0]
   1f9ce:	eb03 090a 	add.w	r9, r3, sl
	int bit = get_bit_ptr(p, level, bn, &word);
   1f9d2:	462a      	mov	r2, r5
   1f9d4:	f107 030c 	add.w	r3, r7, #12
   1f9d8:	4641      	mov	r1, r8
   1f9da:	4630      	mov	r0, r6
   1f9dc:	f7ff fe9e 	bl	1f71c <get_bit_ptr>
	*word &= ~(1<<bit);
   1f9e0:	68fa      	ldr	r2, [r7, #12]
	node->next = list;
   1f9e2:	6839      	ldr	r1, [r7, #0]
   1f9e4:	2301      	movs	r3, #1
   1f9e6:	fa03 f000 	lsl.w	r0, r3, r0
   1f9ea:	6813      	ldr	r3, [r2, #0]
   1f9ec:	ea23 0300 	bic.w	r3, r3, r0
   1f9f0:	6013      	str	r3, [r2, #0]
		sys_dlist_append(&p->levels[level].free_list, block);
   1f9f2:	68f3      	ldr	r3, [r6, #12]
   1f9f4:	220c      	movs	r2, #12
   1f9f6:	fb02 3308 	mla	r3, r2, r8, r3
   1f9fa:	1d1a      	adds	r2, r3, #4
   1f9fc:	f841 200a 	str.w	r2, [r1, sl]
	node->prev = list->tail;
   1fa00:	689a      	ldr	r2, [r3, #8]
   1fa02:	f8c9 2004 	str.w	r2, [r9, #4]
	list->tail->next = node;
   1fa06:	689a      	ldr	r2, [r3, #8]
   1fa08:	f8c2 9000 	str.w	r9, [r2]
	list->tail = node;
   1fa0c:	f8c3 9008 	str.w	r9, [r3, #8]
		pool_irq_unlock(p, key);
   1fa10:	7c30      	ldrb	r0, [r6, #16]
   1fa12:	4621      	mov	r1, r4
   1fa14:	f7ff fea2 	bl	1f75c <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   1fa18:	7c30      	ldrb	r0, [r6, #16]
   1fa1a:	f010 0001 	ands.w	r0, r0, #1
   1fa1e:	d001      	beq.n	1fa24 <z_sys_mem_pool_block_free+0xc8>
   1fa20:	f7ff fe93 	bl	1f74a <pool_irq_lock.isra.2.part.3>
		key = pool_irq_lock(p);
   1fa24:	4604      	mov	r4, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
   1fa26:	f1b8 0f00 	cmp.w	r8, #0
   1fa2a:	d0b9      	beq.n	1f9a0 <z_sys_mem_pool_block_free+0x44>
	int bit = get_bit_ptr(p, level, bn, &word);
   1fa2c:	f107 030c 	add.w	r3, r7, #12
   1fa30:	462a      	mov	r2, r5
   1fa32:	4641      	mov	r1, r8
   1fa34:	4630      	mov	r0, r6
   1fa36:	f7ff fe71 	bl	1f71c <get_bit_ptr>
	return (*word >> (4*(bit / 4))) & 0xf;
   1fa3a:	68fb      	ldr	r3, [r7, #12]
   1fa3c:	2800      	cmp	r0, #0
   1fa3e:	bfb8      	it	lt
   1fa40:	3003      	addlt	r0, #3
   1fa42:	681b      	ldr	r3, [r3, #0]
   1fa44:	f020 0003 	bic.w	r0, r0, #3
   1fa48:	fa23 f000 	lsr.w	r0, r3, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
   1fa4c:	f010 000f 	ands.w	r0, r0, #15
   1fa50:	d1a6      	bne.n	1f9a0 <z_sys_mem_pool_block_free+0x44>
			int b = (bn & ~3) + i;
   1fa52:	f025 0a03 	bic.w	sl, r5, #3
	node->next = NULL;
   1fa56:	4684      	mov	ip, r0
	return (u8_t *)p->buf + lsz * block;
   1fa58:	687a      	ldr	r2, [r7, #4]
			int b = (bn & ~3) + i;
   1fa5a:	eb0a 0300 	add.w	r3, sl, r0
	return (u8_t *)p->buf + lsz * block;
   1fa5e:	4353      	muls	r3, r2
   1fa60:	6832      	ldr	r2, [r6, #0]
   1fa62:	18d1      	adds	r1, r2, r3
	node->prev->next = node->next;
   1fa64:	f852 e003 	ldr.w	lr, [r2, r3]
   1fa68:	f8d1 9004 	ldr.w	r9, [r1, #4]
		for (i = 0; i < 4; i++) {
   1fa6c:	3001      	adds	r0, #1
   1fa6e:	2804      	cmp	r0, #4
   1fa70:	f8c9 e000 	str.w	lr, [r9]
	node->next->prev = node->prev;
   1fa74:	f8ce 9004 	str.w	r9, [lr, #4]
	node->next = NULL;
   1fa78:	f842 c003 	str.w	ip, [r2, r3]
	node->prev = NULL;
   1fa7c:	f8c1 c004 	str.w	ip, [r1, #4]
   1fa80:	d1ea      	bne.n	1fa58 <z_sys_mem_pool_block_free+0xfc>
		bn = bn / 4;
   1fa82:	2d00      	cmp	r5, #0
   1fa84:	bfb8      	it	lt
   1fa86:	3503      	addlt	r5, #3
		level = level - 1;
   1fa88:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
		bn = bn / 4;
   1fa8c:	10ad      	asrs	r5, r5, #2
   1fa8e:	e782      	b.n	1f996 <z_sys_mem_pool_block_free+0x3a>

0001fa90 <print_err>:
{
   1fa90:	b570      	push	{r4, r5, r6, lr}
   1fa92:	4604      	mov	r4, r0
   1fa94:	460d      	mov	r5, r1
	out('E', ctx);
   1fa96:	2045      	movs	r0, #69	; 0x45
   1fa98:	47a0      	blx	r4
	out('R', ctx);
   1fa9a:	4629      	mov	r1, r5
   1fa9c:	2052      	movs	r0, #82	; 0x52
   1fa9e:	47a0      	blx	r4
	out('R', ctx);
   1faa0:	4629      	mov	r1, r5
   1faa2:	4623      	mov	r3, r4
   1faa4:	2052      	movs	r0, #82	; 0x52
}
   1faa6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
   1faaa:	4718      	bx	r3

0001faac <str_out>:
{
   1faac:	b530      	push	{r4, r5, lr}
   1faae:	688a      	ldr	r2, [r1, #8]
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   1fab0:	680c      	ldr	r4, [r1, #0]
   1fab2:	1c55      	adds	r5, r2, #1
   1fab4:	b114      	cbz	r4, 1fabc <str_out+0x10>
   1fab6:	684b      	ldr	r3, [r1, #4]
   1fab8:	4293      	cmp	r3, r2
   1faba:	dc01      	bgt.n	1fac0 <str_out+0x14>
		ctx->count++;
   1fabc:	608d      	str	r5, [r1, #8]
}
   1fabe:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
   1fac0:	3b01      	subs	r3, #1
   1fac2:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
   1fac4:	bf08      	it	eq
   1fac6:	2200      	moveq	r2, #0
   1fac8:	608d      	str	r5, [r1, #8]
   1faca:	bf0c      	ite	eq
   1facc:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
   1face:	54a0      	strbne	r0, [r4, r2]
   1fad0:	e7f5      	b.n	1fabe <str_out+0x12>

0001fad2 <z_vprintk>:
{
   1fad2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1fad6:	b08b      	sub	sp, #44	; 0x2c
   1fad8:	461c      	mov	r4, r3
	char length_mod = 0;
   1fada:	f04f 0800 	mov.w	r8, #0
   1fade:	1e53      	subs	r3, r2, #1
{
   1fae0:	4606      	mov	r6, r0
   1fae2:	460f      	mov	r7, r1
   1fae4:	9302      	str	r3, [sp, #8]
	int min_width = -1;
   1fae6:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
	enum pad_type padding = PAD_NONE;
   1faea:	46c1      	mov	r9, r8
			might_format = 0;
   1faec:	2500      	movs	r5, #0
					break;
   1faee:	e005      	b.n	1fafc <z_vprintk+0x2a>
		if (!might_format) {
   1faf0:	b96d      	cbnz	r5, 1fb0e <z_vprintk+0x3c>
			if (*fmt != '%') {
   1faf2:	2825      	cmp	r0, #37	; 0x25
   1faf4:	f000 814f 	beq.w	1fd96 <z_vprintk+0x2c4>
				out((int)*fmt, ctx);
   1faf8:	4639      	mov	r1, r7
   1fafa:	47b0      	blx	r6
	while (*fmt) {
   1fafc:	9b02      	ldr	r3, [sp, #8]
   1fafe:	f813 0f01 	ldrb.w	r0, [r3, #1]!
   1fb02:	9302      	str	r3, [sp, #8]
   1fb04:	2800      	cmp	r0, #0
   1fb06:	d1f3      	bne.n	1faf0 <z_vprintk+0x1e>
}
   1fb08:	b00b      	add	sp, #44	; 0x2c
   1fb0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			switch (*fmt) {
   1fb0e:	2864      	cmp	r0, #100	; 0x64
   1fb10:	d06e      	beq.n	1fbf0 <z_vprintk+0x11e>
   1fb12:	d81a      	bhi.n	1fb4a <z_vprintk+0x78>
   1fb14:	2839      	cmp	r0, #57	; 0x39
   1fb16:	d80a      	bhi.n	1fb2e <z_vprintk+0x5c>
   1fb18:	2831      	cmp	r0, #49	; 0x31
   1fb1a:	d260      	bcs.n	1fbde <z_vprintk+0x10c>
   1fb1c:	282d      	cmp	r0, #45	; 0x2d
   1fb1e:	f000 8140 	beq.w	1fda2 <z_vprintk+0x2d0>
   1fb22:	2830      	cmp	r0, #48	; 0x30
   1fb24:	d04c      	beq.n	1fbc0 <z_vprintk+0xee>
   1fb26:	2825      	cmp	r0, #37	; 0x25
   1fb28:	d107      	bne.n	1fb3a <z_vprintk+0x68>
				out((int)'%', ctx);
   1fb2a:	4639      	mov	r1, r7
   1fb2c:	e00b      	b.n	1fb46 <z_vprintk+0x74>
			switch (*fmt) {
   1fb2e:	2858      	cmp	r0, #88	; 0x58
   1fb30:	f000 80bb 	beq.w	1fcaa <z_vprintk+0x1d8>
   1fb34:	2863      	cmp	r0, #99	; 0x63
   1fb36:	f000 812a 	beq.w	1fd8e <z_vprintk+0x2bc>
					out((int)'%', ctx);
   1fb3a:	4639      	mov	r1, r7
   1fb3c:	2025      	movs	r0, #37	; 0x25
   1fb3e:	47b0      	blx	r6
					out((int)*fmt, ctx);
   1fb40:	9b02      	ldr	r3, [sp, #8]
   1fb42:	7818      	ldrb	r0, [r3, #0]
   1fb44:	4639      	mov	r1, r7
   1fb46:	47b0      	blx	r6
   1fb48:	e7d0      	b.n	1faec <z_vprintk+0x1a>
			switch (*fmt) {
   1fb4a:	2870      	cmp	r0, #112	; 0x70
   1fb4c:	f000 80a3 	beq.w	1fc96 <z_vprintk+0x1c4>
   1fb50:	d811      	bhi.n	1fb76 <z_vprintk+0xa4>
   1fb52:	2869      	cmp	r0, #105	; 0x69
   1fb54:	d04c      	beq.n	1fbf0 <z_vprintk+0x11e>
   1fb56:	286c      	cmp	r0, #108	; 0x6c
   1fb58:	d105      	bne.n	1fb66 <z_vprintk+0x94>
				} else if (*fmt == 'l' && length_mod == 'l') {
   1fb5a:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   1fb5e:	d12a      	bne.n	1fbb6 <z_vprintk+0xe4>
					length_mod = 'L';
   1fb60:	f04f 084c 	mov.w	r8, #76	; 0x4c
   1fb64:	e7ca      	b.n	1fafc <z_vprintk+0x2a>
			switch (*fmt) {
   1fb66:	2868      	cmp	r0, #104	; 0x68
   1fb68:	d1e7      	bne.n	1fb3a <z_vprintk+0x68>
				if (*fmt == 'h' && length_mod == 'h') {
   1fb6a:	f1b8 0f68 	cmp.w	r8, #104	; 0x68
   1fb6e:	d122      	bne.n	1fbb6 <z_vprintk+0xe4>
					length_mod = 'H';
   1fb70:	f04f 0848 	mov.w	r8, #72	; 0x48
   1fb74:	e7c2      	b.n	1fafc <z_vprintk+0x2a>
			switch (*fmt) {
   1fb76:	2875      	cmp	r0, #117	; 0x75
   1fb78:	d071      	beq.n	1fc5e <z_vprintk+0x18c>
   1fb7a:	d818      	bhi.n	1fbae <z_vprintk+0xdc>
   1fb7c:	2873      	cmp	r0, #115	; 0x73
   1fb7e:	d1dc      	bne.n	1fb3a <z_vprintk+0x68>
				char *s = va_arg(ap, char *);
   1fb80:	f854 5b04 	ldr.w	r5, [r4], #4
				while (*s) {
   1fb84:	46ab      	mov	fp, r5
   1fb86:	465b      	mov	r3, fp
   1fb88:	f81b 0b01 	ldrb.w	r0, [fp], #1
   1fb8c:	2800      	cmp	r0, #0
   1fb8e:	f040 80fb 	bne.w	1fd88 <z_vprintk+0x2b6>
				if (padding == PAD_SPACE_AFTER) {
   1fb92:	f1b9 0f03 	cmp.w	r9, #3
   1fb96:	f040 810a 	bne.w	1fdae <z_vprintk+0x2dc>
					int remaining = min_width - (s - start);
   1fb9a:	1b5d      	subs	r5, r3, r5
   1fb9c:	ebaa 0505 	sub.w	r5, sl, r5
					while (remaining-- > 0) {
   1fba0:	2d00      	cmp	r5, #0
   1fba2:	dda3      	ble.n	1faec <z_vprintk+0x1a>
						out(' ', ctx);
   1fba4:	4639      	mov	r1, r7
   1fba6:	2020      	movs	r0, #32
   1fba8:	47b0      	blx	r6
   1fbaa:	3d01      	subs	r5, #1
   1fbac:	e7f8      	b.n	1fba0 <z_vprintk+0xce>
			switch (*fmt) {
   1fbae:	2878      	cmp	r0, #120	; 0x78
   1fbb0:	d07b      	beq.n	1fcaa <z_vprintk+0x1d8>
   1fbb2:	287a      	cmp	r0, #122	; 0x7a
   1fbb4:	d1c1      	bne.n	1fb3a <z_vprintk+0x68>
				} else if (length_mod == 0) {
   1fbb6:	f1b8 0f00 	cmp.w	r8, #0
   1fbba:	d1be      	bne.n	1fb3a <z_vprintk+0x68>
   1fbbc:	4680      	mov	r8, r0
   1fbbe:	e79d      	b.n	1fafc <z_vprintk+0x2a>
				if (min_width < 0 && padding == PAD_NONE) {
   1fbc0:	f1ba 0f00 	cmp.w	sl, #0
   1fbc4:	da0e      	bge.n	1fbe4 <z_vprintk+0x112>
   1fbc6:	f1b9 0f00 	cmp.w	r9, #0
   1fbca:	f000 80ed 	beq.w	1fda8 <z_vprintk+0x2d6>
					min_width = *fmt - '0';
   1fbce:	f1a0 0a30 	sub.w	sl, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
   1fbd2:	f1b9 0f00 	cmp.w	r9, #0
   1fbd6:	bf08      	it	eq
   1fbd8:	f04f 0902 	moveq.w	r9, #2
   1fbdc:	e78e      	b.n	1fafc <z_vprintk+0x2a>
				if (min_width < 0) {
   1fbde:	f1ba 0f00 	cmp.w	sl, #0
   1fbe2:	dbf4      	blt.n	1fbce <z_vprintk+0xfc>
					min_width = 10 * min_width + *fmt - '0';
   1fbe4:	230a      	movs	r3, #10
   1fbe6:	fb03 0a0a 	mla	sl, r3, sl, r0
   1fbea:	f1aa 0a30 	sub.w	sl, sl, #48	; 0x30
   1fbee:	e7f0      	b.n	1fbd2 <z_vprintk+0x100>
				if (length_mod == 'z') {
   1fbf0:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
   1fbf4:	d102      	bne.n	1fbfc <z_vprintk+0x12a>
					d = va_arg(ap, int);
   1fbf6:	f854 5b04 	ldr.w	r5, [r4], #4
   1fbfa:	e01f      	b.n	1fc3c <z_vprintk+0x16a>
				} else if (length_mod == 'l') {
   1fbfc:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   1fc00:	d0f9      	beq.n	1fbf6 <z_vprintk+0x124>
				} else if (length_mod == 'L') {
   1fc02:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   1fc06:	d1f6      	bne.n	1fbf6 <z_vprintk+0x124>
					long long lld = va_arg(ap, long long);
   1fc08:	3407      	adds	r4, #7
   1fc0a:	f024 0407 	bic.w	r4, r4, #7
   1fc0e:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (lld > __LONG_MAX__ ||
   1fc12:	f112 4100 	adds.w	r1, r2, #2147483648	; 0x80000000
   1fc16:	9106      	str	r1, [sp, #24]
   1fc18:	f143 0100 	adc.w	r1, r3, #0
   1fc1c:	9107      	str	r1, [sp, #28]
   1fc1e:	e9dd bc06 	ldrd	fp, ip, [sp, #24]
   1fc22:	2100      	movs	r1, #0
   1fc24:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1fc28:	4561      	cmp	r1, ip
   1fc2a:	bf08      	it	eq
   1fc2c:	4558      	cmpeq	r0, fp
   1fc2e:	d204      	bcs.n	1fc3a <z_vprintk+0x168>
						print_err(out, ctx);
   1fc30:	4639      	mov	r1, r7
   1fc32:	4630      	mov	r0, r6
   1fc34:	f7ff ff2c 	bl	1fa90 <print_err>
						break;
   1fc38:	e758      	b.n	1faec <z_vprintk+0x1a>
					d = lld;
   1fc3a:	4615      	mov	r5, r2
				if (d < 0) {
   1fc3c:	2d00      	cmp	r5, #0
   1fc3e:	da05      	bge.n	1fc4c <z_vprintk+0x17a>
					out((int)'-', ctx);
   1fc40:	4639      	mov	r1, r7
   1fc42:	202d      	movs	r0, #45	; 0x2d
   1fc44:	47b0      	blx	r6
					d = -d;
   1fc46:	426d      	negs	r5, r5
					min_width--;
   1fc48:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
				_printk_dec_ulong(out, ctx, d, padding,
   1fc4c:	f8cd a000 	str.w	sl, [sp]
   1fc50:	464b      	mov	r3, r9
   1fc52:	462a      	mov	r2, r5
				_printk_dec_ulong(out, ctx, u, padding,
   1fc54:	4639      	mov	r1, r7
   1fc56:	4630      	mov	r0, r6
   1fc58:	f7e4 fd52 	bl	4700 <_printk_dec_ulong>
				break;
   1fc5c:	e746      	b.n	1faec <z_vprintk+0x1a>
				if (length_mod == 'z') {
   1fc5e:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
   1fc62:	d102      	bne.n	1fc6a <z_vprintk+0x198>
					u = va_arg(ap, unsigned int);
   1fc64:	f854 2b04 	ldr.w	r2, [r4], #4
   1fc68:	e011      	b.n	1fc8e <z_vprintk+0x1bc>
				} else if (length_mod == 'l') {
   1fc6a:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   1fc6e:	d0f9      	beq.n	1fc64 <z_vprintk+0x192>
				} else if (length_mod == 'L') {
   1fc70:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   1fc74:	d1f6      	bne.n	1fc64 <z_vprintk+0x192>
					unsigned long long llu =
   1fc76:	3407      	adds	r4, #7
   1fc78:	f024 0407 	bic.w	r4, r4, #7
   1fc7c:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (llu > ~0UL) {
   1fc80:	2100      	movs	r1, #0
   1fc82:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1fc86:	4299      	cmp	r1, r3
   1fc88:	bf08      	it	eq
   1fc8a:	4290      	cmpeq	r0, r2
   1fc8c:	d3d0      	bcc.n	1fc30 <z_vprintk+0x15e>
				_printk_dec_ulong(out, ctx, u, padding,
   1fc8e:	f8cd a000 	str.w	sl, [sp]
   1fc92:	464b      	mov	r3, r9
   1fc94:	e7de      	b.n	1fc54 <z_vprintk+0x182>
				out('0', ctx);
   1fc96:	4639      	mov	r1, r7
   1fc98:	2030      	movs	r0, #48	; 0x30
   1fc9a:	47b0      	blx	r6
				out('x', ctx);
   1fc9c:	4639      	mov	r1, r7
   1fc9e:	2078      	movs	r0, #120	; 0x78
   1fca0:	47b0      	blx	r6
					min_width = 8;
   1fca2:	f04f 0a08 	mov.w	sl, #8
				padding = PAD_ZERO_BEFORE;
   1fca6:	f04f 0901 	mov.w	r9, #1
				if (*fmt == 'p') {
   1fcaa:	9b02      	ldr	r3, [sp, #8]
   1fcac:	781b      	ldrb	r3, [r3, #0]
   1fcae:	2b70      	cmp	r3, #112	; 0x70
   1fcb0:	d104      	bne.n	1fcbc <z_vprintk+0x1ea>
					x = va_arg(ap, unsigned int);
   1fcb2:	f854 3b04 	ldr.w	r3, [r4], #4
   1fcb6:	9304      	str	r3, [sp, #16]
   1fcb8:	2300      	movs	r3, #0
   1fcba:	e00d      	b.n	1fcd8 <z_vprintk+0x206>
				} else if (length_mod == 'l') {
   1fcbc:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   1fcc0:	d0f7      	beq.n	1fcb2 <z_vprintk+0x1e0>
				} else if (length_mod == 'L') {
   1fcc2:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   1fcc6:	d1f4      	bne.n	1fcb2 <z_vprintk+0x1e0>
					x = va_arg(ap, unsigned long long);
   1fcc8:	3407      	adds	r4, #7
   1fcca:	f024 0307 	bic.w	r3, r4, #7
   1fcce:	461c      	mov	r4, r3
   1fcd0:	685b      	ldr	r3, [r3, #4]
   1fcd2:	f854 2b08 	ldr.w	r2, [r4], #8
   1fcd6:	9204      	str	r2, [sp, #16]
	int digits = 0;
   1fcd8:	2100      	movs	r1, #0
	int remaining = 16; /* 16 digits max */
   1fcda:	2210      	movs	r2, #16
	int digits = 0;
   1fcdc:	9103      	str	r1, [sp, #12]
	int found_largest_digit = 0;
   1fcde:	9105      	str	r1, [sp, #20]
	int shift = sizeof(num) * 8;
   1fce0:	f04f 0b40 	mov.w	fp, #64	; 0x40
		shift -= 4;
   1fce4:	f1ab 0b04 	sub.w	fp, fp, #4
		nibble = (num >> shift) & 0xf;
   1fce8:	9804      	ldr	r0, [sp, #16]
   1fcea:	f1cb 0c20 	rsb	ip, fp, #32
   1fcee:	f1ab 0120 	sub.w	r1, fp, #32
   1fcf2:	fa20 f00b 	lsr.w	r0, r0, fp
   1fcf6:	fa03 fc0c 	lsl.w	ip, r3, ip
   1fcfa:	ea40 000c 	orr.w	r0, r0, ip
   1fcfe:	fa23 f101 	lsr.w	r1, r3, r1
   1fd02:	4308      	orrs	r0, r1
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
   1fd04:	f010 000f 	ands.w	r0, r0, #15
   1fd08:	d108      	bne.n	1fd1c <z_vprintk+0x24a>
   1fd0a:	9905      	ldr	r1, [sp, #20]
   1fd0c:	b911      	cbnz	r1, 1fd14 <z_vprintk+0x242>
   1fd0e:	f1bb 0f00 	cmp.w	fp, #0
   1fd12:	d124      	bne.n	1fd5e <z_vprintk+0x28c>
			nibble += nibble > 9 ? 87 : 48;
   1fd14:	2130      	movs	r1, #48	; 0x30
   1fd16:	e005      	b.n	1fd24 <z_vprintk+0x252>
			found_largest_digit = 1;
   1fd18:	9505      	str	r5, [sp, #20]
   1fd1a:	e7e3      	b.n	1fce4 <z_vprintk+0x212>
			nibble += nibble > 9 ? 87 : 48;
   1fd1c:	2809      	cmp	r0, #9
   1fd1e:	bf8c      	ite	hi
   1fd20:	2157      	movhi	r1, #87	; 0x57
   1fd22:	2130      	movls	r1, #48	; 0x30
   1fd24:	4408      	add	r0, r1
			out((int)nibble, ctx);
   1fd26:	b240      	sxtb	r0, r0
   1fd28:	4639      	mov	r1, r7
   1fd2a:	9308      	str	r3, [sp, #32]
   1fd2c:	9205      	str	r2, [sp, #20]
   1fd2e:	47b0      	blx	r6
			digits++;
   1fd30:	9b03      	ldr	r3, [sp, #12]
	while (shift >= 4) {
   1fd32:	9a05      	ldr	r2, [sp, #20]
			digits++;
   1fd34:	3301      	adds	r3, #1
   1fd36:	9303      	str	r3, [sp, #12]
	while (shift >= 4) {
   1fd38:	9b08      	ldr	r3, [sp, #32]
   1fd3a:	f1bb 0f00 	cmp.w	fp, #0
   1fd3e:	d1eb      	bne.n	1fd18 <z_vprintk+0x246>
	if (padding == PAD_SPACE_AFTER) {
   1fd40:	f1b9 0f03 	cmp.w	r9, #3
   1fd44:	f47f aed2 	bne.w	1faec <z_vprintk+0x1a>
		remaining = min_width * 2 - digits;
   1fd48:	9b03      	ldr	r3, [sp, #12]
   1fd4a:	ebc3 054a 	rsb	r5, r3, sl, lsl #1
		while (remaining-- > 0) {
   1fd4e:	2d00      	cmp	r5, #0
   1fd50:	f77f aecc 	ble.w	1faec <z_vprintk+0x1a>
			out(' ', ctx);
   1fd54:	4639      	mov	r1, r7
   1fd56:	2020      	movs	r0, #32
   1fd58:	47b0      	blx	r6
   1fd5a:	3d01      	subs	r5, #1
   1fd5c:	e7f7      	b.n	1fd4e <z_vprintk+0x27c>
		if (remaining-- <= min_width) {
   1fd5e:	1e51      	subs	r1, r2, #1
   1fd60:	4592      	cmp	sl, r2
   1fd62:	9108      	str	r1, [sp, #32]
   1fd64:	db07      	blt.n	1fd76 <z_vprintk+0x2a4>
			if (padding == PAD_ZERO_BEFORE) {
   1fd66:	f1b9 0f01 	cmp.w	r9, #1
   1fd6a:	d106      	bne.n	1fd7a <z_vprintk+0x2a8>
   1fd6c:	9309      	str	r3, [sp, #36]	; 0x24
				out('0', ctx);
   1fd6e:	4639      	mov	r1, r7
   1fd70:	2030      	movs	r0, #48	; 0x30
				out(' ', ctx);
   1fd72:	47b0      	blx	r6
   1fd74:	9b09      	ldr	r3, [sp, #36]	; 0x24
					x = va_arg(ap, unsigned int);
   1fd76:	9a08      	ldr	r2, [sp, #32]
   1fd78:	e7b4      	b.n	1fce4 <z_vprintk+0x212>
			} else if (padding == PAD_SPACE_BEFORE) {
   1fd7a:	f1b9 0f02 	cmp.w	r9, #2
   1fd7e:	d1fa      	bne.n	1fd76 <z_vprintk+0x2a4>
   1fd80:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
   1fd82:	4639      	mov	r1, r7
   1fd84:	2020      	movs	r0, #32
   1fd86:	e7f4      	b.n	1fd72 <z_vprintk+0x2a0>
					out((int)(*s++), ctx);
   1fd88:	4639      	mov	r1, r7
   1fd8a:	47b0      	blx	r6
   1fd8c:	e6fb      	b.n	1fb86 <z_vprintk+0xb4>
				out(c, ctx);
   1fd8e:	4639      	mov	r1, r7
   1fd90:	f854 0b04 	ldr.w	r0, [r4], #4
   1fd94:	e6d7      	b.n	1fb46 <z_vprintk+0x74>
				length_mod = 0;
   1fd96:	46a8      	mov	r8, r5
				padding = PAD_NONE;
   1fd98:	46a9      	mov	r9, r5
				min_width = -1;
   1fd9a:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
				might_format = 1;
   1fd9e:	2501      	movs	r5, #1
   1fda0:	e6ac      	b.n	1fafc <z_vprintk+0x2a>
				padding = PAD_SPACE_AFTER;
   1fda2:	f04f 0903 	mov.w	r9, #3
   1fda6:	e6a9      	b.n	1fafc <z_vprintk+0x2a>
					padding = PAD_ZERO_BEFORE;
   1fda8:	f04f 0901 	mov.w	r9, #1
   1fdac:	e6a6      	b.n	1fafc <z_vprintk+0x2a>
			might_format = 0;
   1fdae:	4605      	mov	r5, r0
		++fmt;
   1fdb0:	e6a4      	b.n	1fafc <z_vprintk+0x2a>

0001fdb2 <printk>:
{
   1fdb2:	b40f      	push	{r0, r1, r2, r3}
   1fdb4:	b507      	push	{r0, r1, r2, lr}
   1fdb6:	a904      	add	r1, sp, #16
   1fdb8:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   1fdbc:	9101      	str	r1, [sp, #4]
		log_printk(fmt, ap);
   1fdbe:	f001 f99b 	bl	210f8 <log_printk>
}
   1fdc2:	b003      	add	sp, #12
   1fdc4:	f85d eb04 	ldr.w	lr, [sp], #4
   1fdc8:	b004      	add	sp, #16
   1fdca:	4770      	bx	lr

0001fdcc <snprintk>:
{
   1fdcc:	b40c      	push	{r2, r3}
   1fdce:	b507      	push	{r0, r1, r2, lr}
   1fdd0:	ab04      	add	r3, sp, #16
   1fdd2:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
   1fdd6:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
   1fdd8:	f7e4 fcde 	bl	4798 <vsnprintk>
}
   1fddc:	b003      	add	sp, #12
   1fdde:	f85d eb04 	ldr.w	lr, [sp], #4
   1fde2:	b002      	add	sp, #8
   1fde4:	4770      	bx	lr

0001fde6 <sys_sem_give>:

	return 0;
}

int sys_sem_give(struct sys_sem *sem)
{
   1fde6:	b508      	push	{r3, lr}
	z_impl_k_sem_give(sem);
   1fde8:	f7fe ffc8 	bl	1ed7c <z_impl_k_sem_give>
	k_sem_give(&sem->kernel_sem);

	return 0;
}
   1fdec:	2000      	movs	r0, #0
   1fdee:	bd08      	pop	{r3, pc}

0001fdf0 <sys_sem_take>:

int sys_sem_take(struct sys_sem *sem, s32_t timeout)
{
   1fdf0:	b508      	push	{r3, lr}
	return z_impl_k_sem_take(sem, timeout);
   1fdf2:	f7fe ffef 	bl	1edd4 <z_impl_k_sem_take>
	int ret_value = 0;

	ret_value = k_sem_take(&sem->kernel_sem, timeout);
	if (ret_value == -EAGAIN || ret_value == -EBUSY) {
   1fdf6:	f110 0f0b 	cmn.w	r0, #11
   1fdfa:	d005      	beq.n	1fe08 <sys_sem_take+0x18>
   1fdfc:	f110 0f10 	cmn.w	r0, #16
		ret_value = -ETIMEDOUT;
   1fe00:	bf08      	it	eq
   1fe02:	f06f 0073 	mvneq.w	r0, #115	; 0x73
	}

	return ret_value;
}
   1fe06:	bd08      	pop	{r3, pc}
		ret_value = -ETIMEDOUT;
   1fe08:	f06f 0073 	mvn.w	r0, #115	; 0x73
	return ret_value;
   1fe0c:	e7fb      	b.n	1fe06 <sys_sem_take+0x16>

0001fe0e <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   1fe0e:	4604      	mov	r4, r0
   1fe10:	b508      	push	{r3, lr}
   1fe12:	4608      	mov	r0, r1
   1fe14:	4611      	mov	r1, r2
	entry(p1, p2, p3);
   1fe16:	461a      	mov	r2, r3
   1fe18:	47a0      	blx	r4
	return z_impl_k_current_get();
   1fe1a:	f7fe ffa9 	bl	1ed70 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
   1fe1e:	f7e7 fa65 	bl	72ec <z_impl_k_thread_abort>

0001fe22 <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
   1fe22:	b510      	push	{r4, lr}
   1fe24:	4604      	mov	r4, r0
	return z_impl_k_queue_get(queue, timeout);
   1fe26:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1fe2a:	4620      	mov	r0, r4
   1fe2c:	f007 fe94 	bl	27b58 <z_impl_k_queue_get>
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
   1fe30:	4603      	mov	r3, r0
   1fe32:	2800      	cmp	r0, #0
   1fe34:	d0f7      	beq.n	1fe26 <z_work_q_main+0x4>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1fe36:	3308      	adds	r3, #8
			continue;
		}

		handler = work->handler;
   1fe38:	6842      	ldr	r2, [r0, #4]
   1fe3a:	f3bf 8f5b 	dmb	ish
   1fe3e:	e853 1f00 	ldrex	r1, [r3]
   1fe42:	f021 0c01 	bic.w	ip, r1, #1
   1fe46:	e843 ce00 	strex	lr, ip, [r3]
   1fe4a:	f1be 0f00 	cmp.w	lr, #0
   1fe4e:	d1f6      	bne.n	1fe3e <z_work_q_main+0x1c>
   1fe50:	f3bf 8f5b 	dmb	ish

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
   1fe54:	07cb      	lsls	r3, r1, #31
   1fe56:	d500      	bpl.n	1fe5a <z_work_q_main+0x38>
					      K_WORK_STATE_PENDING)) {
			handler(work);
   1fe58:	4790      	blx	r2
	z_impl_k_yield();
   1fe5a:	f7fe ff15 	bl	1ec88 <z_impl_k_yield>
   1fe5e:	e7e2      	b.n	1fe26 <z_work_q_main+0x4>

0001fe60 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_REBOOT, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   1fe60:	4770      	bx	lr

0001fe62 <_copy>:
#define MASK_TWENTY_SEVEN 0x1b

unsigned int _copy(uint8_t *to, unsigned int to_len,
		   const uint8_t *from, unsigned int from_len)
{
	if (from_len <= to_len) {
   1fe62:	428b      	cmp	r3, r1
{
   1fe64:	b538      	push	{r3, r4, r5, lr}
   1fe66:	4615      	mov	r5, r2
   1fe68:	461c      	mov	r4, r3
	if (from_len <= to_len) {
   1fe6a:	d805      	bhi.n	1fe78 <_copy+0x16>
   1fe6c:	461a      	mov	r2, r3
   1fe6e:	4629      	mov	r1, r5
   1fe70:	f7e1 febc 	bl	1bec <memcpy>
		(void)memcpy(to, from, from_len);
		return from_len;
	} else {
		return TC_CRYPTO_FAIL;
	}
}
   1fe74:	4620      	mov	r0, r4
   1fe76:	bd38      	pop	{r3, r4, r5, pc}
		return TC_CRYPTO_FAIL;
   1fe78:	2400      	movs	r4, #0
   1fe7a:	e7fb      	b.n	1fe74 <_copy+0x12>

0001fe7c <_set>:
__ssp_bos_icheck3(memset, void *, int)
   1fe7c:	f7e1 bed7 	b.w	1c2e <memset>

0001fe80 <_double_byte>:
/*
 * Doubles the value of a byte for values up to 127.
 */
uint8_t _double_byte(uint8_t a)
{
	return ((a<<1) ^ ((a>>7) * MASK_TWENTY_SEVEN));
   1fe80:	09c3      	lsrs	r3, r0, #7
   1fe82:	005a      	lsls	r2, r3, #1
   1fe84:	4413      	add	r3, r2
   1fe86:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
   1fe8a:	ea83 0040 	eor.w	r0, r3, r0, lsl #1
}
   1fe8e:	b2c0      	uxtb	r0, r0
   1fe90:	4770      	bx	lr

0001fe92 <_set_secure.constprop.0>:
   1fe92:	460a      	mov	r2, r1
 * @param len IN -- number of times the value will be copied
 */
#ifdef TINYCRYPT_ARCH_HAS_SET_SECURE
extern void _set_secure(void *to, uint8_t val, unsigned int len);
#else /* ! TINYCRYPT_ARCH_HAS_SET_SECURE */
static inline void _set_secure(void *to, uint8_t val, unsigned int len)
   1fe94:	b508      	push	{r3, lr}
   1fe96:	2100      	movs	r1, #0
   1fe98:	f7e1 fec9 	bl	1c2e <memset>
{
  (void) memset(to, val, len);
#ifdef __GNUC__
  __asm__ __volatile__("" :: "g"(to) : "memory");
#endif /* __GNUC__ */
}
   1fe9c:	bd08      	pop	{r3, pc}

0001fe9e <uECC_make_key>:
	}
	return 0;
}

int uECC_make_key(uint8_t *public_key, uint8_t *private_key, uECC_Curve curve)
{
   1fe9e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1fea2:	4606      	mov	r6, r0
   1fea4:	b0a8      	sub	sp, #160	; 0xa0
   1fea6:	460f      	mov	r7, r1
   1fea8:	4614      	mov	r4, r2
   1feaa:	2540      	movs	r5, #64	; 0x40
			!rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE)) {
        		return 0;
		}

		/* computing modular reduction of _random (see FIPS 186.4 B.4.1): */
		uECC_vli_mmod(_private, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
   1feac:	f102 0824 	add.w	r8, r2, #36	; 0x24
		uECC_RNG_Function rng_function = uECC_get_rng();
   1feb0:	f7e4 fc86 	bl	47c0 <uECC_get_rng>
		if (!rng_function ||
   1feb4:	4603      	mov	r3, r0
   1feb6:	2800      	cmp	r0, #0
   1feb8:	d03c      	beq.n	1ff34 <uECC_make_key+0x96>
			!rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE)) {
   1feba:	2140      	movs	r1, #64	; 0x40
   1febc:	a808      	add	r0, sp, #32
   1febe:	4798      	blx	r3
		if (!rng_function ||
   1fec0:	b3c0      	cbz	r0, 1ff34 <uECC_make_key+0x96>
		uECC_vli_mmod(_private, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
   1fec2:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
   1fec6:	f112 031f 	adds.w	r3, r2, #31
   1feca:	bf48      	it	mi
   1fecc:	f102 033e 	addmi.w	r3, r2, #62	; 0x3e
   1fed0:	a908      	add	r1, sp, #32
   1fed2:	4642      	mov	r2, r8
   1fed4:	4668      	mov	r0, sp
   1fed6:	f343 1347 	sbfx	r3, r3, #5, #8
   1feda:	f000 f9fc 	bl	202d6 <uECC_vli_mmod>

		/* Computing public-key from private: */
		if (EccPoint_compute_public_key(_public, _private, curve)) {
   1fede:	4622      	mov	r2, r4
   1fee0:	4669      	mov	r1, sp
   1fee2:	a818      	add	r0, sp, #96	; 0x60
   1fee4:	f000 fe12 	bl	20b0c <EccPoint_compute_public_key>
   1fee8:	b310      	cbz	r0, 1ff30 <uECC_make_key+0x92>

			/* Converting buffers to correct bit order: */
			uECC_vli_nativeToBytes(private_key,
					       BITS_TO_BYTES(curve->num_n_bits),
   1feea:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
			uECC_vli_nativeToBytes(private_key,
   1feee:	1dd9      	adds	r1, r3, #7
   1fef0:	bf48      	it	mi
   1fef2:	f103 010e 	addmi.w	r1, r3, #14
   1fef6:	466a      	mov	r2, sp
   1fef8:	10c9      	asrs	r1, r1, #3
   1fefa:	4638      	mov	r0, r7
   1fefc:	f000 fe2e 	bl	20b5c <uECC_vli_nativeToBytes>
					       _private);
			uECC_vli_nativeToBytes(public_key,
   1ff00:	aa18      	add	r2, sp, #96	; 0x60
   1ff02:	f994 1001 	ldrsb.w	r1, [r4, #1]
   1ff06:	4630      	mov	r0, r6
   1ff08:	f000 fe28 	bl	20b5c <uECC_vli_nativeToBytes>
					       curve->num_bytes,
					       _public);
			uECC_vli_nativeToBytes(public_key + curve->num_bytes,
   1ff0c:	f994 1001 	ldrsb.w	r1, [r4, #1]
 					       curve->num_bytes,
					       _public + curve->num_words);
   1ff10:	f994 2000 	ldrsb.w	r2, [r4]
			uECC_vli_nativeToBytes(public_key + curve->num_bytes,
   1ff14:	ab18      	add	r3, sp, #96	; 0x60
   1ff16:	1870      	adds	r0, r6, r1
   1ff18:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   1ff1c:	f000 fe1e 	bl	20b5c <uECC_vli_nativeToBytes>

			/* erasing temporary buffer that stored secret: */
			_set_secure(_private, 0, NUM_ECC_BYTES);
   1ff20:	4668      	mov	r0, sp
   1ff22:	2120      	movs	r1, #32
   1ff24:	f7ff ffb5 	bl	1fe92 <_set_secure.constprop.0>

      			return 1;
   1ff28:	2001      	movs	r0, #1
    		}
  	}
	return 0;
}
   1ff2a:	b028      	add	sp, #160	; 0xa0
   1ff2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
   1ff30:	3d01      	subs	r5, #1
   1ff32:	d1bd      	bne.n	1feb0 <uECC_make_key+0x12>
        		return 0;
   1ff34:	2000      	movs	r0, #0
   1ff36:	e7f8      	b.n	1ff2a <uECC_make_key+0x8c>

0001ff38 <uECC_shared_secret>:

int uECC_shared_secret(const uint8_t *public_key, const uint8_t *private_key,
		       uint8_t *secret, uECC_Curve curve)
{
   1ff38:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1ff3c:	461c      	mov	r4, r3
	uECC_word_t tmp[NUM_ECC_WORDS];
	uECC_word_t *p2[2] = {_private, tmp};
	uECC_word_t *initial_Z = 0;
	uECC_word_t carry;
	wordcount_t num_words = curve->num_words;
	wordcount_t num_bytes = curve->num_bytes;
   1ff3e:	f993 6001 	ldrsb.w	r6, [r3, #1]
	wordcount_t num_words = curve->num_words;
   1ff42:	f993 a000 	ldrsb.w	sl, [r3]
	int r;

	/* Converting buffers to correct bit order: */
	uECC_vli_bytesToNative(_private,
      			       private_key,
			       BITS_TO_BYTES(curve->num_n_bits));
   1ff46:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
{
   1ff4a:	b0a4      	sub	sp, #144	; 0x90
   1ff4c:	4690      	mov	r8, r2
	uECC_vli_bytesToNative(_private,
   1ff4e:	1dda      	adds	r2, r3, #7
   1ff50:	bf48      	it	mi
   1ff52:	f103 020e 	addmi.w	r2, r3, #14
	uECC_word_t *p2[2] = {_private, tmp};
   1ff56:	ad04      	add	r5, sp, #16
{
   1ff58:	4681      	mov	r9, r0
	uECC_word_t *p2[2] = {_private, tmp};
   1ff5a:	af0c      	add	r7, sp, #48	; 0x30
	uECC_vli_bytesToNative(_private,
   1ff5c:	4628      	mov	r0, r5
   1ff5e:	10d2      	asrs	r2, r2, #3
	uECC_word_t *p2[2] = {_private, tmp};
   1ff60:	9502      	str	r5, [sp, #8]
   1ff62:	9703      	str	r7, [sp, #12]
	uECC_vli_bytesToNative(_private,
   1ff64:	f000 fe0e 	bl	20b84 <uECC_vli_bytesToNative>
	uECC_vli_bytesToNative(_public,
   1ff68:	4632      	mov	r2, r6
   1ff6a:	4649      	mov	r1, r9
   1ff6c:	a814      	add	r0, sp, #80	; 0x50
   1ff6e:	f000 fe09 	bl	20b84 <uECC_vli_bytesToNative>
      			       public_key,
			       num_bytes);
	uECC_vli_bytesToNative(_public + num_words,
   1ff72:	ab14      	add	r3, sp, #80	; 0x50
   1ff74:	eb03 008a 	add.w	r0, r3, sl, lsl #2
   1ff78:	4632      	mov	r2, r6
   1ff7a:	eb09 0106 	add.w	r1, r9, r6
   1ff7e:	f000 fe01 	bl	20b84 <uECC_vli_bytesToNative>
			       public_key + num_bytes,
			       num_bytes);

	/* Regularize the bitcount for the private key so that attackers cannot use a
	 * side channel attack to learn the number of leading zeros. */
	carry = regularize_k(_private, _private, tmp, curve);
   1ff82:	4623      	mov	r3, r4
   1ff84:	463a      	mov	r2, r7
   1ff86:	4629      	mov	r1, r5
   1ff88:	4628      	mov	r0, r5
   1ff8a:	f000 fd92 	bl	20ab2 <regularize_k>
			goto clear_and_out;
    		}
    		initial_Z = p2[carry];
  	}

	EccPoint_mult(_public, _public, p2[!carry], initial_Z, curve->num_n_bits + 1,
   1ff8e:	fab0 f080 	clz	r0, r0
   1ff92:	9401      	str	r4, [sp, #4]
   1ff94:	ab24      	add	r3, sp, #144	; 0x90
   1ff96:	0940      	lsrs	r0, r0, #5
   1ff98:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1ff9c:	8863      	ldrh	r3, [r4, #2]
   1ff9e:	3301      	adds	r3, #1
   1ffa0:	b21b      	sxth	r3, r3
   1ffa2:	9300      	str	r3, [sp, #0]
   1ffa4:	a914      	add	r1, sp, #80	; 0x50
   1ffa6:	2300      	movs	r3, #0
   1ffa8:	f850 2c88 	ldr.w	r2, [r0, #-136]
   1ffac:	4608      	mov	r0, r1
   1ffae:	f000 fcb1 	bl	20914 <EccPoint_mult>
		      curve);

	uECC_vli_nativeToBytes(secret, num_bytes, _public);
   1ffb2:	aa14      	add	r2, sp, #80	; 0x50
   1ffb4:	4631      	mov	r1, r6
   1ffb6:	4640      	mov	r0, r8
   1ffb8:	f000 fdd0 	bl	20b5c <uECC_vli_nativeToBytes>
	r = !EccPoint_isZero(_public, curve);
   1ffbc:	4621      	mov	r1, r4
   1ffbe:	a814      	add	r0, sp, #80	; 0x50
   1ffc0:	f000 fc1f 	bl	20802 <EccPoint_isZero>

clear_and_out:
	/* erasing temporary buffer used to store secret: */
	_set_secure(p2, 0, sizeof(p2));
   1ffc4:	2108      	movs	r1, #8
	r = !EccPoint_isZero(_public, curve);
   1ffc6:	4604      	mov	r4, r0
	_set_secure(p2, 0, sizeof(p2));
   1ffc8:	eb0d 0001 	add.w	r0, sp, r1
   1ffcc:	f7ff ff61 	bl	1fe92 <_set_secure.constprop.0>
	_set_secure(tmp, 0, sizeof(tmp));
   1ffd0:	4638      	mov	r0, r7
   1ffd2:	2120      	movs	r1, #32
   1ffd4:	f7ff ff5d 	bl	1fe92 <_set_secure.constprop.0>
	_set_secure(_private, 0, sizeof(_private));
   1ffd8:	4628      	mov	r0, r5
   1ffda:	2120      	movs	r1, #32
   1ffdc:	f7ff ff59 	bl	1fe92 <_set_secure.constprop.0>

	return r;
}
   1ffe0:	fab4 f084 	clz	r0, r4
   1ffe4:	0940      	lsrs	r0, r0, #5
   1ffe6:	b024      	add	sp, #144	; 0x90
   1ffe8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0001ffec <uECC_vli_add>:
{
   1ffec:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
   1ffee:	2400      	movs	r4, #0
{
   1fff0:	4607      	mov	r7, r0
	uECC_word_t carry = 0;
   1fff2:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
   1fff4:	b265      	sxtb	r5, r4
   1fff6:	42ab      	cmp	r3, r5
   1fff8:	dc00      	bgt.n	1fffc <uECC_vli_add+0x10>
}
   1fffa:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t sum = left[i] + right[i] + carry;
   1fffc:	f851 6024 	ldr.w	r6, [r1, r4, lsl #2]
   20000:	f852 5024 	ldr.w	r5, [r2, r4, lsl #2]
   20004:	4435      	add	r5, r6
   20006:	4405      	add	r5, r0
		carry = cond_set(val, carry, (sum != left[i]));
   20008:	42ae      	cmp	r6, r5
		uECC_word_t val = (sum < left[i]);
   2000a:	bf8c      	ite	hi
   2000c:	2601      	movhi	r6, #1
   2000e:	2600      	movls	r6, #0
		result[i] = sum;
   20010:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
   20014:	bf18      	it	ne
   20016:	4630      	movne	r0, r6
		result[i] = sum;
   20018:	3401      	adds	r4, #1
   2001a:	e7eb      	b.n	1fff4 <uECC_vli_add+0x8>

0002001c <uECC_vli_rshift1>:
	vli += num_words;
   2001c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	uECC_word_t carry = 0;
   20020:	2300      	movs	r3, #0
	while (vli-- > end) {
   20022:	4288      	cmp	r0, r1
   20024:	d300      	bcc.n	20028 <uECC_vli_rshift1+0xc>
}
   20026:	4770      	bx	lr
		uECC_word_t temp = *vli;
   20028:	f851 2d04 	ldr.w	r2, [r1, #-4]!
		*vli = (temp >> 1) | carry;
   2002c:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
   20030:	600b      	str	r3, [r1, #0]
		carry = temp << (uECC_WORD_BITS - 1);
   20032:	07d3      	lsls	r3, r2, #31
   20034:	e7f5      	b.n	20022 <uECC_vli_rshift1+0x6>

00020036 <vli_modInv_update>:
	if (!EVEN(uv)) {
   20036:	6803      	ldr	r3, [r0, #0]
{
   20038:	b570      	push	{r4, r5, r6, lr}
	if (!EVEN(uv)) {
   2003a:	f013 0601 	ands.w	r6, r3, #1
{
   2003e:	4605      	mov	r5, r0
   20040:	4614      	mov	r4, r2
	if (!EVEN(uv)) {
   20042:	d005      	beq.n	20050 <vli_modInv_update+0x1a>
		carry = uECC_vli_add(uv, uv, mod, num_words);
   20044:	4613      	mov	r3, r2
   20046:	460a      	mov	r2, r1
   20048:	4601      	mov	r1, r0
   2004a:	f7ff ffcf 	bl	1ffec <uECC_vli_add>
   2004e:	4606      	mov	r6, r0
	uECC_vli_rshift1(uv, num_words);
   20050:	4621      	mov	r1, r4
   20052:	4628      	mov	r0, r5
   20054:	f7ff ffe2 	bl	2001c <uECC_vli_rshift1>
	if (carry) {
   20058:	b146      	cbz	r6, 2006c <vli_modInv_update+0x36>
		uv[num_words - 1] |= HIGH_BIT_SET;
   2005a:	f104 4280 	add.w	r2, r4, #1073741824	; 0x40000000
   2005e:	3a01      	subs	r2, #1
   20060:	f855 3022 	ldr.w	r3, [r5, r2, lsl #2]
   20064:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   20068:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
}
   2006c:	bd70      	pop	{r4, r5, r6, pc}

0002006e <uECC_vli_mult>:
{
   2006e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (k = 0; k < num_words; ++k) {
   20072:	2500      	movs	r5, #0
{
   20074:	b087      	sub	sp, #28
   20076:	e9cd 1200 	strd	r1, r2, [sp]
	uECC_word_t r1 = 0;
   2007a:	462c      	mov	r4, r5
	uECC_word_t r0 = 0;
   2007c:	462a      	mov	r2, r5
   2007e:	fa4f f885 	sxtb.w	r8, r5
	for (k = 0; k < num_words; ++k) {
   20082:	4543      	cmp	r3, r8
   20084:	dc16      	bgt.n	200b4 <uECC_vli_mult+0x46>
	for (k = num_words; k < num_words * 2 - 1; ++k) {
   20086:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   2008a:	eb05 0543 	add.w	r5, r5, r3, lsl #1
   2008e:	9502      	str	r5, [sp, #8]
   20090:	f04f 0a00 	mov.w	sl, #0
   20094:	fa5f f58a 	uxtb.w	r5, sl
   20098:	eb05 0c03 	add.w	ip, r5, r3
   2009c:	9e02      	ldr	r6, [sp, #8]
   2009e:	fa4f fc8c 	sxtb.w	ip, ip
   200a2:	45b4      	cmp	ip, r6
   200a4:	db2d      	blt.n	20102 <uECC_vli_mult+0x94>
	result[num_words * 2 - 1] = r0;
   200a6:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   200aa:	f840 2c04 	str.w	r2, [r0, #-4]
}
   200ae:	b007      	add	sp, #28
   200b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   200b4:	9e01      	ldr	r6, [sp, #4]
	for (k = 0; k < num_words; ++k) {
   200b6:	f04f 0c00 	mov.w	ip, #0
   200ba:	eb06 0985 	add.w	r9, r6, r5, lsl #2
   200be:	46e6      	mov	lr, ip
	uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;
   200c0:	e9cd 2402 	strd	r2, r4, [sp, #8]
	uECC_dword_t p = (uECC_dword_t)a * b;
   200c4:	9900      	ldr	r1, [sp, #0]
			muladd(left[i], right[k - i], &r0, &r1, &r2);
   200c6:	f859 7904 	ldr.w	r7, [r9], #-4
	uECC_dword_t p = (uECC_dword_t)a * b;
   200ca:	f851 602c 	ldr.w	r6, [r1, ip, lsl #2]
   200ce:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
   200d2:	fba7 ab06 	umull	sl, fp, r7, r6
   200d6:	eb1a 0601 	adds.w	r6, sl, r1
   200da:	f10c 0c01 	add.w	ip, ip, #1
   200de:	eb5b 0702 	adcs.w	r7, fp, r2
		for (i = 0; i <= k; ++i) {
   200e2:	fa4f fa8c 	sxtb.w	sl, ip
   200e6:	bf2c      	ite	cs
   200e8:	2201      	movcs	r2, #1
   200ea:	2200      	movcc	r2, #0
   200ec:	45c2      	cmp	sl, r8
	*r2 += (r01 < p);
   200ee:	4496      	add	lr, r2
	*r1 = r01 >> uECC_WORD_BITS;
   200f0:	463c      	mov	r4, r7
	*r0 = (uECC_word_t)r01;
   200f2:	4632      	mov	r2, r6
		for (i = 0; i <= k; ++i) {
   200f4:	dde4      	ble.n	200c0 <uECC_vli_mult+0x52>
		result[k] = r0;
   200f6:	f840 6025 	str.w	r6, [r0, r5, lsl #2]
	*r1 = r01 >> uECC_WORD_BITS;
   200fa:	463a      	mov	r2, r7
   200fc:	3501      	adds	r5, #1
	*r2 += (r01 < p);
   200fe:	4674      	mov	r4, lr
   20100:	e7bd      	b.n	2007e <uECC_vli_mult+0x10>
		for (i = (k + 1) - num_words; i < num_words; ++i) {
   20102:	3501      	adds	r5, #1
   20104:	b26d      	sxtb	r5, r5
   20106:	9e01      	ldr	r6, [sp, #4]
   20108:	9900      	ldr	r1, [sp, #0]
   2010a:	ebac 0e05 	sub.w	lr, ip, r5
   2010e:	eb06 0e8e 	add.w	lr, r6, lr, lsl #2
   20112:	eb01 0b85 	add.w	fp, r1, r5, lsl #2
   20116:	4626      	mov	r6, r4
   20118:	2400      	movs	r4, #0
   2011a:	429d      	cmp	r5, r3
   2011c:	db05      	blt.n	2012a <uECC_vli_mult+0xbc>
		result[k] = r0;
   2011e:	f840 202c 	str.w	r2, [r0, ip, lsl #2]
		r2 = 0;
   20122:	f10a 0a01 	add.w	sl, sl, #1
		result[k] = r0;
   20126:	4632      	mov	r2, r6
   20128:	e7b4      	b.n	20094 <uECC_vli_mult+0x26>
	uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;
   2012a:	e9cd 2604 	strd	r2, r6, [sp, #16]
			muladd(left[i], right[k - i], &r0, &r1, &r2);
   2012e:	f85e 7904 	ldr.w	r7, [lr], #-4
   20132:	f85b 8b04 	ldr.w	r8, [fp], #4
	r01 += p;
   20136:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
	uECC_dword_t p = (uECC_dword_t)a * b;
   2013a:	fba8 8907 	umull	r8, r9, r8, r7
   2013e:	eb18 0601 	adds.w	r6, r8, r1
   20142:	eb59 0702 	adcs.w	r7, r9, r2
   20146:	bf2c      	ite	cs
   20148:	2201      	movcs	r2, #1
   2014a:	2200      	movcc	r2, #0
		for (i = (k + 1) - num_words; i < num_words; ++i) {
   2014c:	3501      	adds	r5, #1
	*r2 += (r01 < p);
   2014e:	4414      	add	r4, r2
		for (i = (k + 1) - num_words; i < num_words; ++i) {
   20150:	b26d      	sxtb	r5, r5
	*r0 = (uECC_word_t)r01;
   20152:	4632      	mov	r2, r6
	*r1 = r01 >> uECC_WORD_BITS;
   20154:	463e      	mov	r6, r7
   20156:	e7e0      	b.n	2011a <uECC_vli_mult+0xac>

00020158 <uECC_vli_clear>:
	for (i = 0; i < num_words; ++i) {
   20158:	2300      	movs	r3, #0
{
   2015a:	b510      	push	{r4, lr}
		 vli[i] = 0;
   2015c:	461c      	mov	r4, r3
	for (i = 0; i < num_words; ++i) {
   2015e:	b25a      	sxtb	r2, r3
   20160:	4291      	cmp	r1, r2
   20162:	dc00      	bgt.n	20166 <uECC_vli_clear+0xe>
}
   20164:	bd10      	pop	{r4, pc}
		 vli[i] = 0;
   20166:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
   2016a:	3301      	adds	r3, #1
   2016c:	e7f7      	b.n	2015e <uECC_vli_clear+0x6>

0002016e <uECC_vli_isZero>:
{
   2016e:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
   20170:	2300      	movs	r3, #0
	uECC_word_t bits = 0;
   20172:	461a      	mov	r2, r3
	for (i = 0; i < num_words; ++i) {
   20174:	b25c      	sxtb	r4, r3
   20176:	42a1      	cmp	r1, r4
   20178:	dc03      	bgt.n	20182 <uECC_vli_isZero+0x14>
}
   2017a:	fab2 f082 	clz	r0, r2
   2017e:	0940      	lsrs	r0, r0, #5
   20180:	bd10      	pop	{r4, pc}
		bits |= vli[i];
   20182:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   20186:	3301      	adds	r3, #1
   20188:	4322      	orrs	r2, r4
   2018a:	e7f3      	b.n	20174 <uECC_vli_isZero+0x6>

0002018c <uECC_vli_testBit>:
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   2018c:	114a      	asrs	r2, r1, #5
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
   2018e:	2301      	movs	r3, #1
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   20190:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
   20194:	f001 011f 	and.w	r1, r1, #31
   20198:	fa03 f101 	lsl.w	r1, r3, r1
}
   2019c:	4008      	ands	r0, r1
   2019e:	4770      	bx	lr

000201a0 <uECC_vli_numBits>:
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
   201a0:	3901      	subs	r1, #1
   201a2:	b249      	sxtb	r1, r1
   201a4:	eb00 0381 	add.w	r3, r0, r1, lsl #2
   201a8:	2900      	cmp	r1, #0
   201aa:	da04      	bge.n	201b6 <uECC_vli_numBits+0x16>
	return (i + 1);
   201ac:	3101      	adds	r1, #1
   201ae:	b249      	sxtb	r1, r1
	if (num_digits == 0) {
   201b0:	b941      	cbnz	r1, 201c4 <uECC_vli_numBits+0x24>
		return 0;
   201b2:	4608      	mov	r0, r1
}
   201b4:	4770      	bx	lr
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
   201b6:	f853 2904 	ldr.w	r2, [r3], #-4
   201ba:	2a00      	cmp	r2, #0
   201bc:	d1f6      	bne.n	201ac <uECC_vli_numBits+0xc>
   201be:	3901      	subs	r1, #1
   201c0:	b249      	sxtb	r1, r1
   201c2:	e7f1      	b.n	201a8 <uECC_vli_numBits+0x8>
	digit = vli[num_digits - 1];
   201c4:	f101 4380 	add.w	r3, r1, #1073741824	; 0x40000000
   201c8:	3b01      	subs	r3, #1
   201ca:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
	for (i = 0; digit; ++i) {
   201ce:	2000      	movs	r0, #0
   201d0:	b923      	cbnz	r3, 201dc <uECC_vli_numBits+0x3c>
	return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);
   201d2:	3901      	subs	r1, #1
   201d4:	eb00 1141 	add.w	r1, r0, r1, lsl #5
   201d8:	b208      	sxth	r0, r1
   201da:	4770      	bx	lr
		digit >>= 1;
   201dc:	085b      	lsrs	r3, r3, #1
	for (i = 0; digit; ++i) {
   201de:	3001      	adds	r0, #1
   201e0:	e7f6      	b.n	201d0 <uECC_vli_numBits+0x30>

000201e2 <uECC_vli_set>:
{
   201e2:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
   201e4:	2300      	movs	r3, #0
   201e6:	b25c      	sxtb	r4, r3
   201e8:	42a2      	cmp	r2, r4
   201ea:	dc00      	bgt.n	201ee <uECC_vli_set+0xc>
}
   201ec:	bd10      	pop	{r4, pc}
		dest[i] = src[i];
   201ee:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
   201f2:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
   201f6:	3301      	adds	r3, #1
   201f8:	e7f5      	b.n	201e6 <uECC_vli_set+0x4>

000201fa <uECC_vli_cmp_unsafe>:
{
   201fa:	b530      	push	{r4, r5, lr}
	for (i = num_words - 1; i >= 0; --i) {
   201fc:	3a01      	subs	r2, #1
   201fe:	b252      	sxtb	r2, r2
   20200:	0093      	lsls	r3, r2, #2
   20202:	2a00      	cmp	r2, #0
   20204:	da01      	bge.n	2020a <uECC_vli_cmp_unsafe+0x10>
	return 0;
   20206:	2000      	movs	r0, #0
}
   20208:	bd30      	pop	{r4, r5, pc}
		if (left[i] > right[i]) {
   2020a:	58c5      	ldr	r5, [r0, r3]
   2020c:	58cc      	ldr	r4, [r1, r3]
   2020e:	42a5      	cmp	r5, r4
   20210:	d805      	bhi.n	2021e <uECC_vli_cmp_unsafe+0x24>
		} else if (left[i] < right[i]) {
   20212:	f1a3 0304 	sub.w	r3, r3, #4
   20216:	d304      	bcc.n	20222 <uECC_vli_cmp_unsafe+0x28>
	for (i = num_words - 1; i >= 0; --i) {
   20218:	3a01      	subs	r2, #1
   2021a:	b252      	sxtb	r2, r2
   2021c:	e7f1      	b.n	20202 <uECC_vli_cmp_unsafe+0x8>
			return 1;
   2021e:	2001      	movs	r0, #1
   20220:	e7f2      	b.n	20208 <uECC_vli_cmp_unsafe+0xe>
			return -1;
   20222:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   20226:	e7ef      	b.n	20208 <uECC_vli_cmp_unsafe+0xe>

00020228 <uECC_vli_equal>:
	for (i = num_words - 1; i >= 0; --i) {
   20228:	3a01      	subs	r2, #1
   2022a:	b252      	sxtb	r2, r2
{
   2022c:	b570      	push	{r4, r5, r6, lr}
   2022e:	0093      	lsls	r3, r2, #2
	uECC_word_t diff = 0;
   20230:	2400      	movs	r4, #0
	for (i = num_words - 1; i >= 0; --i) {
   20232:	2a00      	cmp	r2, #0
   20234:	da03      	bge.n	2023e <uECC_vli_equal+0x16>
}
   20236:	1c20      	adds	r0, r4, #0
   20238:	bf18      	it	ne
   2023a:	2001      	movne	r0, #1
   2023c:	bd70      	pop	{r4, r5, r6, pc}
		diff |= (left[i] ^ right[i]);
   2023e:	58c5      	ldr	r5, [r0, r3]
   20240:	58ce      	ldr	r6, [r1, r3]
	for (i = num_words - 1; i >= 0; --i) {
   20242:	3a01      	subs	r2, #1
		diff |= (left[i] ^ right[i]);
   20244:	4075      	eors	r5, r6
   20246:	432c      	orrs	r4, r5
	for (i = num_words - 1; i >= 0; --i) {
   20248:	b252      	sxtb	r2, r2
   2024a:	3b04      	subs	r3, #4
   2024c:	e7f1      	b.n	20232 <uECC_vli_equal+0xa>

0002024e <uECC_vli_sub>:
{
   2024e:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
   20250:	2400      	movs	r4, #0
{
   20252:	4607      	mov	r7, r0
   20254:	469c      	mov	ip, r3
	uECC_word_t borrow = 0;
   20256:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
   20258:	b265      	sxtb	r5, r4
   2025a:	45ac      	cmp	ip, r5
   2025c:	dc00      	bgt.n	20260 <uECC_vli_sub+0x12>
}
   2025e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t diff = left[i] - right[i] - borrow;
   20260:	f851 6024 	ldr.w	r6, [r1, r4, lsl #2]
   20264:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
   20268:	1a35      	subs	r5, r6, r0
   2026a:	1aed      	subs	r5, r5, r3
		borrow = cond_set(val, borrow, (diff != left[i]));
   2026c:	42ae      	cmp	r6, r5
		uECC_word_t val = (diff > left[i]);
   2026e:	bf34      	ite	cc
   20270:	2601      	movcc	r6, #1
   20272:	2600      	movcs	r6, #0
		result[i] = diff;
   20274:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
   20278:	bf18      	it	ne
   2027a:	4630      	movne	r0, r6
		result[i] = diff;
   2027c:	3401      	adds	r4, #1
   2027e:	e7eb      	b.n	20258 <uECC_vli_sub+0xa>

00020280 <uECC_vli_modAdd>:
{
   20280:	b570      	push	{r4, r5, r6, lr}
   20282:	f99d 4010 	ldrsb.w	r4, [sp, #16]
   20286:	461e      	mov	r6, r3
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
   20288:	4623      	mov	r3, r4
{
   2028a:	4605      	mov	r5, r0
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
   2028c:	f7ff feae 	bl	1ffec <uECC_vli_add>
	if (carry || uECC_vli_cmp_unsafe(mod, result, num_words) != 1) {
   20290:	b930      	cbnz	r0, 202a0 <uECC_vli_modAdd+0x20>
   20292:	4622      	mov	r2, r4
   20294:	4629      	mov	r1, r5
   20296:	4630      	mov	r0, r6
   20298:	f7ff ffaf 	bl	201fa <uECC_vli_cmp_unsafe>
   2029c:	2801      	cmp	r0, #1
   2029e:	d007      	beq.n	202b0 <uECC_vli_modAdd+0x30>
		uECC_vli_sub(result, result, mod, num_words);
   202a0:	4623      	mov	r3, r4
   202a2:	4632      	mov	r2, r6
   202a4:	4629      	mov	r1, r5
   202a6:	4628      	mov	r0, r5
}
   202a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_sub(result, result, mod, num_words);
   202ac:	f7ff bfcf 	b.w	2024e <uECC_vli_sub>
}
   202b0:	bd70      	pop	{r4, r5, r6, pc}

000202b2 <uECC_vli_modSub>:
{
   202b2:	b570      	push	{r4, r5, r6, lr}
   202b4:	f99d 4010 	ldrsb.w	r4, [sp, #16]
   202b8:	461e      	mov	r6, r3
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
   202ba:	4623      	mov	r3, r4
{
   202bc:	4605      	mov	r5, r0
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
   202be:	f7ff ffc6 	bl	2024e <uECC_vli_sub>
	if (l_borrow) {
   202c2:	b138      	cbz	r0, 202d4 <uECC_vli_modSub+0x22>
		uECC_vli_add(result, result, mod, num_words);
   202c4:	4623      	mov	r3, r4
   202c6:	4632      	mov	r2, r6
   202c8:	4629      	mov	r1, r5
   202ca:	4628      	mov	r0, r5
}
   202cc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_add(result, result, mod, num_words);
   202d0:	f7ff be8c 	b.w	1ffec <uECC_vli_add>
}
   202d4:	bd70      	pop	{r4, r5, r6, pc}

000202d6 <uECC_vli_mmod>:
{
   202d6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   202da:	b0a5      	sub	sp, #148	; 0x94
   202dc:	461d      	mov	r5, r3
	uECC_word_t *v[2] = {tmp, product};
   202de:	ab14      	add	r3, sp, #80	; 0x50
   202e0:	e9cd 3102 	strd	r3, r1, [sp, #8]
{
   202e4:	4681      	mov	r9, r0
			   uECC_vli_numBits(mod, num_words);
   202e6:	4629      	mov	r1, r5
   202e8:	4610      	mov	r0, r2
{
   202ea:	4617      	mov	r7, r2
			   uECC_vli_numBits(mod, num_words);
   202ec:	f7ff ff58 	bl	201a0 <uECC_vli_numBits>
	bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) -
   202f0:	ebc0 1085 	rsb	r0, r0, r5, lsl #6
   202f4:	b204      	sxth	r4, r0
	wordcount_t word_shift = shift / uECC_WORD_BITS;
   202f6:	2c00      	cmp	r4, #0
   202f8:	4626      	mov	r6, r4
   202fa:	bfb8      	it	lt
   202fc:	f104 061f 	addlt.w	r6, r4, #31
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   20300:	4263      	negs	r3, r4
	wordcount_t word_shift = shift / uECC_WORD_BITS;
   20302:	f346 1647 	sbfx	r6, r6, #5, #8
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   20306:	f003 031f 	and.w	r3, r3, #31
   2030a:	f004 081f 	and.w	r8, r4, #31
	uECC_vli_clear(mod_multiple, word_shift);
   2030e:	a804      	add	r0, sp, #16
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   20310:	bf58      	it	pl
   20312:	f1c3 0800 	rsbpl	r8, r3, #0
	uECC_vli_clear(mod_multiple, word_shift);
   20316:	4631      	mov	r1, r6
   20318:	f7ff ff1e 	bl	20158 <uECC_vli_clear>
	if (bit_shift > 0) {
   2031c:	f1b8 0f00 	cmp.w	r8, #0
   20320:	b230      	sxth	r0, r6
   20322:	dd2d      	ble.n	20380 <uECC_vli_mmod+0xaa>
   20324:	ab04      	add	r3, sp, #16
	uECC_word_t carry = 0;
   20326:	2200      	movs	r2, #0
   20328:	eb03 0080 	add.w	r0, r3, r0, lsl #2
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
   2032c:	f1c8 0c20 	rsb	ip, r8, #32
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
   20330:	4613      	mov	r3, r2
   20332:	429d      	cmp	r5, r3
   20334:	d819      	bhi.n	2036a <uECC_vli_mmod+0x94>
		for (i = 0; i < num_words * 2; ++i) {
   20336:	b22f      	sxth	r7, r5
   20338:	007b      	lsls	r3, r7, #1
   2033a:	9301      	str	r3, [sp, #4]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   2033c:	ab04      	add	r3, sp, #16
   2033e:	eb03 0787 	add.w	r7, r3, r7, lsl #2
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   20342:	f105 38ff 	add.w	r8, r5, #4294967295	; 0xffffffff
   20346:	ab24      	add	r3, sp, #144	; 0x90
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   20348:	2601      	movs	r6, #1
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   2034a:	eb03 0888 	add.w	r8, r3, r8, lsl #2
	for (index = 1; shift >= 0; --shift) {
   2034e:	2c00      	cmp	r4, #0
   20350:	da54      	bge.n	203fc <uECC_vli_mmod+0x126>
	uECC_vli_set(result, v[index], num_words);
   20352:	ab24      	add	r3, sp, #144	; 0x90
   20354:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   20358:	462a      	mov	r2, r5
   2035a:	f856 1c88 	ldr.w	r1, [r6, #-136]
   2035e:	4648      	mov	r0, r9
   20360:	f7ff ff3f 	bl	201e2 <uECC_vli_set>
}
   20364:	b025      	add	sp, #148	; 0x94
   20366:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
   2036a:	f857 6023 	ldr.w	r6, [r7, r3, lsl #2]
   2036e:	fa06 f108 	lsl.w	r1, r6, r8
   20372:	430a      	orrs	r2, r1
   20374:	f840 2b04 	str.w	r2, [r0], #4
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
   20378:	3301      	adds	r3, #1
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
   2037a:	fa26 f20c 	lsr.w	r2, r6, ip
   2037e:	e7d8      	b.n	20332 <uECC_vli_mmod+0x5c>
		uECC_vli_set(mod_multiple + word_shift, mod, num_words);
   20380:	ab04      	add	r3, sp, #16
   20382:	462a      	mov	r2, r5
   20384:	4639      	mov	r1, r7
   20386:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   2038a:	f7ff ff2a 	bl	201e2 <uECC_vli_set>
   2038e:	e7d2      	b.n	20336 <uECC_vli_mmod+0x60>
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   20390:	fa0f fe82 	sxth.w	lr, r2
   20394:	f85a 3c88 	ldr.w	r3, [sl, #-136]
   20398:	f853 b02e 	ldr.w	fp, [r3, lr, lsl #2]
   2039c:	ab24      	add	r3, sp, #144	; 0x90
   2039e:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   203a2:	3001      	adds	r0, #1
   203a4:	f852 3c80 	ldr.w	r3, [r2, #-128]
   203a8:	440b      	add	r3, r1
   203aa:	ebbb 0303 	subs.w	r3, fp, r3
   203ae:	bf34      	ite	cc
   203b0:	2201      	movcc	r2, #1
   203b2:	2200      	movcs	r2, #0
			if (diff != v[index][i]) {
   203b4:	459b      	cmp	fp, r3
				borrow = (diff > v[index][i]);
   203b6:	bf18      	it	ne
   203b8:	4611      	movne	r1, r2
			v[1 - index][i] = diff;
   203ba:	f85c 2c88 	ldr.w	r2, [ip, #-136]
   203be:	f842 302e 	str.w	r3, [r2, lr, lsl #2]
		for (i = 0; i < num_words * 2; ++i) {
   203c2:	9b01      	ldr	r3, [sp, #4]
   203c4:	b242      	sxtb	r2, r0
   203c6:	429a      	cmp	r2, r3
   203c8:	dbe2      	blt.n	20390 <uECC_vli_mmod+0xba>
		index = !(index ^ borrow);
   203ca:	1a73      	subs	r3, r6, r1
   203cc:	425e      	negs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
   203ce:	4629      	mov	r1, r5
   203d0:	a804      	add	r0, sp, #16
		index = !(index ^ borrow);
   203d2:	415e      	adcs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
   203d4:	f7ff fe22 	bl	2001c <uECC_vli_rshift1>
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   203d8:	ab24      	add	r3, sp, #144	; 0x90
   203da:	eb03 0385 	add.w	r3, r3, r5, lsl #2
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   203de:	4629      	mov	r1, r5
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   203e0:	f853 2c80 	ldr.w	r2, [r3, #-128]
   203e4:	f858 3c80 	ldr.w	r3, [r8, #-128]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   203e8:	4638      	mov	r0, r7
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   203ea:	ea43 73c2 	orr.w	r3, r3, r2, lsl #31
	for (index = 1; shift >= 0; --shift) {
   203ee:	3c01      	subs	r4, #1
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   203f0:	f848 3c80 	str.w	r3, [r8, #-128]
	for (index = 1; shift >= 0; --shift) {
   203f4:	b224      	sxth	r4, r4
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   203f6:	f7ff fe11 	bl	2001c <uECC_vli_rshift1>
   203fa:	e7a8      	b.n	2034e <uECC_vli_mmod+0x78>
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   203fc:	ab24      	add	r3, sp, #144	; 0x90
   203fe:	2000      	movs	r0, #0
			v[1 - index][i] = diff;
   20400:	f1c6 0c01 	rsb	ip, r6, #1
		uECC_word_t borrow = 0;
   20404:	4601      	mov	r1, r0
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   20406:	eb03 0a86 	add.w	sl, r3, r6, lsl #2
			v[1 - index][i] = diff;
   2040a:	eb03 0c8c 	add.w	ip, r3, ip, lsl #2
   2040e:	e7d8      	b.n	203c2 <uECC_vli_mmod+0xec>

00020410 <uECC_vli_modMult_fast>:
{
   20410:	b530      	push	{r4, r5, lr}
   20412:	461c      	mov	r4, r3
   20414:	b091      	sub	sp, #68	; 0x44
   20416:	4605      	mov	r5, r0
	uECC_vli_mult(product, left, right, curve->num_words);
   20418:	f993 3000 	ldrsb.w	r3, [r3]
   2041c:	4668      	mov	r0, sp
   2041e:	f7ff fe26 	bl	2006e <uECC_vli_mult>
	curve->mmod_fast(result, product);
   20422:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
   20426:	4669      	mov	r1, sp
   20428:	4628      	mov	r0, r5
   2042a:	4798      	blx	r3
}
   2042c:	b011      	add	sp, #68	; 0x44
   2042e:	bd30      	pop	{r4, r5, pc}

00020430 <uECC_vli_modSquare_fast>:
	uECC_vli_modMult_fast(result, left, left, curve);
   20430:	4613      	mov	r3, r2
   20432:	460a      	mov	r2, r1
   20434:	f7ff bfec 	b.w	20410 <uECC_vli_modMult_fast>

00020438 <double_jacobian_default>:
{
   20438:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	wordcount_t num_words = curve->num_words;
   2043c:	f993 6000 	ldrsb.w	r6, [r3]
{
   20440:	b092      	sub	sp, #72	; 0x48
   20442:	4604      	mov	r4, r0
   20444:	4689      	mov	r9, r1
	if (uECC_vli_isZero(Z1, num_words)) {
   20446:	4610      	mov	r0, r2
   20448:	4631      	mov	r1, r6
{
   2044a:	4615      	mov	r5, r2
   2044c:	4698      	mov	r8, r3
	if (uECC_vli_isZero(Z1, num_words)) {
   2044e:	f7ff fe8e 	bl	2016e <uECC_vli_isZero>
   20452:	2800      	cmp	r0, #0
   20454:	f040 8091 	bne.w	2057a <double_jacobian_default+0x142>
	uECC_vli_modSquare_fast(t4, Y1, curve);   /* t4 = y1^2 */
   20458:	4642      	mov	r2, r8
   2045a:	4649      	mov	r1, r9
   2045c:	a802      	add	r0, sp, #8
   2045e:	f7ff ffe7 	bl	20430 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(t5, X1, t4, curve); /* t5 = x1*y1^2 = A */
   20462:	4643      	mov	r3, r8
   20464:	aa02      	add	r2, sp, #8
   20466:	4621      	mov	r1, r4
   20468:	a80a      	add	r0, sp, #40	; 0x28
   2046a:	f7ff ffd1 	bl	20410 <uECC_vli_modMult_fast>
	uECC_vli_modSquare_fast(t4, t4, curve);   /* t4 = y1^4 */
   2046e:	a902      	add	r1, sp, #8
   20470:	4608      	mov	r0, r1
   20472:	4642      	mov	r2, r8
   20474:	f7ff ffdc 	bl	20430 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(Y1, Y1, Z1, curve); /* t2 = y1*z1 = z3 */
   20478:	4643      	mov	r3, r8
   2047a:	462a      	mov	r2, r5
   2047c:	4649      	mov	r1, r9
   2047e:	4648      	mov	r0, r9
   20480:	f7ff ffc6 	bl	20410 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
   20484:	f108 0704 	add.w	r7, r8, #4
	uECC_vli_modSquare_fast(Z1, Z1, curve);   /* t3 = z1^2 */
   20488:	4642      	mov	r2, r8
   2048a:	4629      	mov	r1, r5
   2048c:	4628      	mov	r0, r5
   2048e:	f7ff ffcf 	bl	20430 <uECC_vli_modSquare_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
   20492:	463b      	mov	r3, r7
   20494:	462a      	mov	r2, r5
   20496:	4621      	mov	r1, r4
   20498:	4620      	mov	r0, r4
   2049a:	9600      	str	r6, [sp, #0]
   2049c:	f7ff fef0 	bl	20280 <uECC_vli_modAdd>
	uECC_vli_modAdd(Z1, Z1, Z1, curve->p, num_words); /* t3 = 2*z1^2 */
   204a0:	463b      	mov	r3, r7
   204a2:	462a      	mov	r2, r5
   204a4:	4629      	mov	r1, r5
   204a6:	4628      	mov	r0, r5
   204a8:	9600      	str	r6, [sp, #0]
   204aa:	f7ff fee9 	bl	20280 <uECC_vli_modAdd>
	uECC_vli_modSub(Z1, X1, Z1, curve->p, num_words); /* t3 = x1 - z1^2 */
   204ae:	463b      	mov	r3, r7
   204b0:	462a      	mov	r2, r5
   204b2:	4621      	mov	r1, r4
   204b4:	4628      	mov	r0, r5
   204b6:	9600      	str	r6, [sp, #0]
   204b8:	f7ff fefb 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, Z1, curve); /* t1 = x1^2 - z1^4 */
   204bc:	4643      	mov	r3, r8
   204be:	462a      	mov	r2, r5
   204c0:	4621      	mov	r1, r4
   204c2:	4620      	mov	r0, r4
   204c4:	f7ff ffa4 	bl	20410 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(Z1, X1, X1, curve->p, num_words); /* t3 = 2*(x1^2 - z1^4) */
   204c8:	463b      	mov	r3, r7
   204ca:	4622      	mov	r2, r4
   204cc:	4621      	mov	r1, r4
   204ce:	4628      	mov	r0, r5
   204d0:	9600      	str	r6, [sp, #0]
   204d2:	f7ff fed5 	bl	20280 <uECC_vli_modAdd>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = 3*(x1^2 - z1^4) */
   204d6:	463b      	mov	r3, r7
   204d8:	9600      	str	r6, [sp, #0]
   204da:	462a      	mov	r2, r5
   204dc:	4621      	mov	r1, r4
   204de:	4620      	mov	r0, r4
   204e0:	f7ff fece 	bl	20280 <uECC_vli_modAdd>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   204e4:	6823      	ldr	r3, [r4, #0]
	if (uECC_vli_testBit(X1, 0)) {
   204e6:	07db      	lsls	r3, r3, #31
   204e8:	d54a      	bpl.n	20580 <double_jacobian_default+0x148>
		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
   204ea:	4633      	mov	r3, r6
   204ec:	463a      	mov	r2, r7
   204ee:	4621      	mov	r1, r4
   204f0:	4620      	mov	r0, r4
   204f2:	f7ff fd7b 	bl	1ffec <uECC_vli_add>
		uECC_vli_rshift1(X1, num_words);
   204f6:	4631      	mov	r1, r6
		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
   204f8:	4682      	mov	sl, r0
		uECC_vli_rshift1(X1, num_words);
   204fa:	4620      	mov	r0, r4
   204fc:	f7ff fd8e 	bl	2001c <uECC_vli_rshift1>
		X1[num_words - 1] |= l_carry << (uECC_WORD_BITS - 1);
   20500:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
   20504:	3b01      	subs	r3, #1
   20506:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
   2050a:	ea40 70ca 	orr.w	r0, r0, sl, lsl #31
   2050e:	f844 0023 	str.w	r0, [r4, r3, lsl #2]
	uECC_vli_modSquare_fast(Z1, X1, curve); /* t3 = B^2 */
   20512:	4642      	mov	r2, r8
   20514:	4621      	mov	r1, r4
   20516:	4628      	mov	r0, r5
   20518:	f7ff ff8a 	bl	20430 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - A */
   2051c:	463b      	mov	r3, r7
   2051e:	aa0a      	add	r2, sp, #40	; 0x28
   20520:	4629      	mov	r1, r5
   20522:	4628      	mov	r0, r5
   20524:	9600      	str	r6, [sp, #0]
   20526:	f7ff fec4 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - 2A = x3 */
   2052a:	463b      	mov	r3, r7
   2052c:	aa0a      	add	r2, sp, #40	; 0x28
   2052e:	4629      	mov	r1, r5
   20530:	4628      	mov	r0, r5
   20532:	9600      	str	r6, [sp, #0]
   20534:	f7ff febd 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, Z1, curve->p, num_words); /* t5 = A - x3 */
   20538:	a90a      	add	r1, sp, #40	; 0x28
   2053a:	4608      	mov	r0, r1
   2053c:	463b      	mov	r3, r7
   2053e:	462a      	mov	r2, r5
   20540:	9600      	str	r6, [sp, #0]
   20542:	f7ff feb6 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = B * (A - x3) */
   20546:	4643      	mov	r3, r8
   20548:	aa0a      	add	r2, sp, #40	; 0x28
   2054a:	4621      	mov	r1, r4
   2054c:	4620      	mov	r0, r4
   2054e:	f7ff ff5f 	bl	20410 <uECC_vli_modMult_fast>
	uECC_vli_modSub(t4, X1, t4, curve->p, num_words);
   20552:	aa02      	add	r2, sp, #8
   20554:	463b      	mov	r3, r7
   20556:	4610      	mov	r0, r2
   20558:	4621      	mov	r1, r4
   2055a:	9600      	str	r6, [sp, #0]
   2055c:	f7ff fea9 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_set(X1, Z1, num_words);
   20560:	4632      	mov	r2, r6
   20562:	4629      	mov	r1, r5
   20564:	4620      	mov	r0, r4
   20566:	f7ff fe3c 	bl	201e2 <uECC_vli_set>
	uECC_vli_set(Z1, Y1, num_words);
   2056a:	4649      	mov	r1, r9
   2056c:	4628      	mov	r0, r5
   2056e:	f7ff fe38 	bl	201e2 <uECC_vli_set>
	uECC_vli_set(Y1, t4, num_words);
   20572:	a902      	add	r1, sp, #8
   20574:	4648      	mov	r0, r9
   20576:	f7ff fe34 	bl	201e2 <uECC_vli_set>
}
   2057a:	b012      	add	sp, #72	; 0x48
   2057c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uECC_vli_rshift1(X1, num_words);
   20580:	4631      	mov	r1, r6
   20582:	4620      	mov	r0, r4
   20584:	f7ff fd4a 	bl	2001c <uECC_vli_rshift1>
   20588:	e7c3      	b.n	20512 <double_jacobian_default+0xda>

0002058a <x_side_default>:
{
   2058a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2058e:	4615      	mov	r5, r2
   20590:	b08a      	sub	sp, #40	; 0x28
   20592:	4604      	mov	r4, r0
   20594:	4688      	mov	r8, r1
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   20596:	221c      	movs	r2, #28
   20598:	2100      	movs	r1, #0
   2059a:	a803      	add	r0, sp, #12
   2059c:	f7e1 fb47 	bl	1c2e <memset>
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
   205a0:	1d2e      	adds	r6, r5, #4
	wordcount_t num_words = curve->num_words;
   205a2:	f995 7000 	ldrsb.w	r7, [r5]
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   205a6:	2303      	movs	r3, #3
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
   205a8:	462a      	mov	r2, r5
   205aa:	4641      	mov	r1, r8
   205ac:	4620      	mov	r0, r4
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   205ae:	9302      	str	r3, [sp, #8]
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
   205b0:	f7ff ff3e 	bl	20430 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
   205b4:	4633      	mov	r3, r6
   205b6:	aa02      	add	r2, sp, #8
   205b8:	4621      	mov	r1, r4
   205ba:	4620      	mov	r0, r4
   205bc:	9700      	str	r7, [sp, #0]
   205be:	f7ff fe78 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modMult_fast(result, result, x, curve); /* r = x^3 - 3x */
   205c2:	462b      	mov	r3, r5
   205c4:	4642      	mov	r2, r8
   205c6:	4621      	mov	r1, r4
   205c8:	4620      	mov	r0, r4
   205ca:	f7ff ff21 	bl	20410 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(result, result, curve->b, curve->p, num_words);
   205ce:	9700      	str	r7, [sp, #0]
   205d0:	4633      	mov	r3, r6
   205d2:	f105 0284 	add.w	r2, r5, #132	; 0x84
   205d6:	4621      	mov	r1, r4
   205d8:	4620      	mov	r0, r4
   205da:	f7ff fe51 	bl	20280 <uECC_vli_modAdd>
}
   205de:	b00a      	add	sp, #40	; 0x28
   205e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000205e4 <XYcZ_addC>:
   or P => P - Q, Q => P + Q
 */
static void XYcZ_addC(uECC_word_t * X1, uECC_word_t * Y1,
		      uECC_word_t * X2, uECC_word_t * Y2,
		      uECC_Curve curve)
{
   205e4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   205e8:	b09b      	sub	sp, #108	; 0x6c
   205ea:	4616      	mov	r6, r2
	/* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
	uECC_word_t t5[NUM_ECC_WORDS];
	uECC_word_t t6[NUM_ECC_WORDS];
	uECC_word_t t7[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
   205ec:	9c22      	ldr	r4, [sp, #136]	; 0x88
   205ee:	f914 5b04 	ldrsb.w	r5, [r4], #4

	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   205f2:	9500      	str	r5, [sp, #0]
{
   205f4:	4698      	mov	r8, r3
   205f6:	4607      	mov	r7, r0
   205f8:	4689      	mov	r9, r1
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   205fa:	4623      	mov	r3, r4
   205fc:	4602      	mov	r2, r0
   205fe:	4631      	mov	r1, r6
   20600:	a802      	add	r0, sp, #8
   20602:	f7ff fe56 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
   20606:	a902      	add	r1, sp, #8
   20608:	9a22      	ldr	r2, [sp, #136]	; 0x88
   2060a:	4608      	mov	r0, r1
   2060c:	f7ff ff10 	bl	20430 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
   20610:	9b22      	ldr	r3, [sp, #136]	; 0x88
   20612:	aa02      	add	r2, sp, #8
   20614:	4639      	mov	r1, r7
   20616:	4638      	mov	r0, r7
   20618:	f7ff fefa 	bl	20410 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
   2061c:	9b22      	ldr	r3, [sp, #136]	; 0x88
   2061e:	aa02      	add	r2, sp, #8
   20620:	4631      	mov	r1, r6
   20622:	4630      	mov	r0, r6
   20624:	f7ff fef4 	bl	20410 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t5, Y2, Y1, curve->p, num_words); /* t5 = y2 + y1 */
   20628:	4623      	mov	r3, r4
   2062a:	464a      	mov	r2, r9
   2062c:	4641      	mov	r1, r8
   2062e:	a802      	add	r0, sp, #8
   20630:	9500      	str	r5, [sp, #0]
   20632:	f7ff fe25 	bl	20280 <uECC_vli_modAdd>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
   20636:	4623      	mov	r3, r4
   20638:	464a      	mov	r2, r9
   2063a:	4641      	mov	r1, r8
   2063c:	4640      	mov	r0, r8
   2063e:	9500      	str	r5, [sp, #0]
   20640:	f7ff fe37 	bl	202b2 <uECC_vli_modSub>

	uECC_vli_modSub(t6, X2, X1, curve->p, num_words); /* t6 = C - B */
   20644:	4623      	mov	r3, r4
   20646:	463a      	mov	r2, r7
   20648:	4631      	mov	r1, r6
   2064a:	a80a      	add	r0, sp, #40	; 0x28
   2064c:	9500      	str	r5, [sp, #0]
   2064e:	f7ff fe30 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, t6, curve); /* t2 = y1 * (C - B) = E */
   20652:	9b22      	ldr	r3, [sp, #136]	; 0x88
   20654:	aa0a      	add	r2, sp, #40	; 0x28
   20656:	4649      	mov	r1, r9
   20658:	4648      	mov	r0, r9
   2065a:	f7ff fed9 	bl	20410 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t6, X1, X2, curve->p, num_words); /* t6 = B + C */
   2065e:	4623      	mov	r3, r4
   20660:	4632      	mov	r2, r6
   20662:	4639      	mov	r1, r7
   20664:	a80a      	add	r0, sp, #40	; 0x28
   20666:	9500      	str	r5, [sp, #0]
   20668:	f7ff fe0a 	bl	20280 <uECC_vli_modAdd>
	uECC_vli_modSquare_fast(X2, Y2, curve); /* t3 = (y2 - y1)^2 = D */
   2066c:	9a22      	ldr	r2, [sp, #136]	; 0x88
   2066e:	4641      	mov	r1, r8
   20670:	4630      	mov	r0, r6
   20672:	f7ff fedd 	bl	20430 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(X2, X2, t6, curve->p, num_words); /* t3 = D - (B + C) = x3 */
   20676:	4623      	mov	r3, r4
   20678:	aa0a      	add	r2, sp, #40	; 0x28
   2067a:	4631      	mov	r1, r6
   2067c:	4630      	mov	r0, r6
   2067e:	9500      	str	r5, [sp, #0]
   20680:	f7ff fe17 	bl	202b2 <uECC_vli_modSub>

	uECC_vli_modSub(t7, X1, X2, curve->p, num_words); /* t7 = B - x3 */
   20684:	4623      	mov	r3, r4
   20686:	4632      	mov	r2, r6
   20688:	4639      	mov	r1, r7
   2068a:	a812      	add	r0, sp, #72	; 0x48
   2068c:	9500      	str	r5, [sp, #0]
   2068e:	f7ff fe10 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, t7, curve); /* t4 = (y2 - y1)*(B - x3) */
   20692:	9b22      	ldr	r3, [sp, #136]	; 0x88
   20694:	aa12      	add	r2, sp, #72	; 0x48
   20696:	4641      	mov	r1, r8
   20698:	4640      	mov	r0, r8
   2069a:	f7ff feb9 	bl	20410 <uECC_vli_modMult_fast>
	/* t4 = (y2 - y1)*(B - x3) - E = y3: */
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words);
   2069e:	4623      	mov	r3, r4
   206a0:	464a      	mov	r2, r9
   206a2:	4641      	mov	r1, r8
   206a4:	4640      	mov	r0, r8
   206a6:	9500      	str	r5, [sp, #0]
   206a8:	f7ff fe03 	bl	202b2 <uECC_vli_modSub>

	uECC_vli_modSquare_fast(t7, t5, curve); /* t7 = (y2 + y1)^2 = F */
   206ac:	9a22      	ldr	r2, [sp, #136]	; 0x88
   206ae:	a902      	add	r1, sp, #8
   206b0:	a812      	add	r0, sp, #72	; 0x48
   206b2:	f7ff febd 	bl	20430 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t7, t7, t6, curve->p, num_words); /* t7 = F - (B + C) = x3' */
   206b6:	a912      	add	r1, sp, #72	; 0x48
   206b8:	4623      	mov	r3, r4
   206ba:	aa0a      	add	r2, sp, #40	; 0x28
   206bc:	4608      	mov	r0, r1
   206be:	9500      	str	r5, [sp, #0]
   206c0:	f7ff fdf7 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modSub(t6, t7, X1, curve->p, num_words); /* t6 = x3' - B */
   206c4:	4623      	mov	r3, r4
   206c6:	463a      	mov	r2, r7
   206c8:	a912      	add	r1, sp, #72	; 0x48
   206ca:	a80a      	add	r0, sp, #40	; 0x28
   206cc:	9500      	str	r5, [sp, #0]
   206ce:	f7ff fdf0 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modMult_fast(t6, t6, t5, curve); /* t6 = (y2+y1)*(x3' - B) */
   206d2:	a90a      	add	r1, sp, #40	; 0x28
   206d4:	9b22      	ldr	r3, [sp, #136]	; 0x88
   206d6:	aa02      	add	r2, sp, #8
   206d8:	4608      	mov	r0, r1
   206da:	f7ff fe99 	bl	20410 <uECC_vli_modMult_fast>
	/* t2 = (y2+y1)*(x3' - B) - E = y3': */
	uECC_vli_modSub(Y1, t6, Y1, curve->p, num_words);
   206de:	4623      	mov	r3, r4
   206e0:	464a      	mov	r2, r9
   206e2:	a90a      	add	r1, sp, #40	; 0x28
   206e4:	4648      	mov	r0, r9
   206e6:	9500      	str	r5, [sp, #0]
   206e8:	f7ff fde3 	bl	202b2 <uECC_vli_modSub>

	uECC_vli_set(X1, t7, num_words);
   206ec:	462a      	mov	r2, r5
   206ee:	a912      	add	r1, sp, #72	; 0x48
   206f0:	4638      	mov	r0, r7
   206f2:	f7ff fd76 	bl	201e2 <uECC_vli_set>
}
   206f6:	b01b      	add	sp, #108	; 0x6c
   206f8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

000206fc <uECC_vli_modInv>:
{
   206fc:	b5f0      	push	{r4, r5, r6, r7, lr}
   206fe:	460f      	mov	r7, r1
   20700:	b0a1      	sub	sp, #132	; 0x84
   20702:	4606      	mov	r6, r0
	if (uECC_vli_isZero(input, num_words)) {
   20704:	4619      	mov	r1, r3
   20706:	4638      	mov	r0, r7
{
   20708:	4615      	mov	r5, r2
   2070a:	461c      	mov	r4, r3
	if (uECC_vli_isZero(input, num_words)) {
   2070c:	f7ff fd2f 	bl	2016e <uECC_vli_isZero>
   20710:	b120      	cbz	r0, 2071c <uECC_vli_modInv+0x20>
		uECC_vli_clear(result, num_words);
   20712:	4630      	mov	r0, r6
   20714:	f7ff fd20 	bl	20158 <uECC_vli_clear>
}
   20718:	b021      	add	sp, #132	; 0x84
   2071a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uECC_vli_set(a, input, num_words);
   2071c:	4622      	mov	r2, r4
   2071e:	4639      	mov	r1, r7
   20720:	4668      	mov	r0, sp
   20722:	f7ff fd5e 	bl	201e2 <uECC_vli_set>
	uECC_vli_set(b, mod, num_words);
   20726:	4629      	mov	r1, r5
   20728:	a808      	add	r0, sp, #32
   2072a:	f7ff fd5a 	bl	201e2 <uECC_vli_set>
	uECC_vli_clear(u, num_words);
   2072e:	a810      	add	r0, sp, #64	; 0x40
   20730:	4621      	mov	r1, r4
   20732:	f7ff fd11 	bl	20158 <uECC_vli_clear>
	u[0] = 1;
   20736:	2301      	movs	r3, #1
	uECC_vli_clear(v, num_words);
   20738:	a818      	add	r0, sp, #96	; 0x60
	u[0] = 1;
   2073a:	9310      	str	r3, [sp, #64]	; 0x40
	uECC_vli_clear(v, num_words);
   2073c:	f7ff fd0c 	bl	20158 <uECC_vli_clear>
	while ((cmpResult = uECC_vli_cmp_unsafe(a, b, num_words)) != 0) {
   20740:	4622      	mov	r2, r4
   20742:	a908      	add	r1, sp, #32
   20744:	4668      	mov	r0, sp
   20746:	f7ff fd58 	bl	201fa <uECC_vli_cmp_unsafe>
   2074a:	b928      	cbnz	r0, 20758 <uECC_vli_modInv+0x5c>
  	uECC_vli_set(result, u, num_words);
   2074c:	4622      	mov	r2, r4
   2074e:	a910      	add	r1, sp, #64	; 0x40
   20750:	4630      	mov	r0, r6
   20752:	f7ff fd46 	bl	201e2 <uECC_vli_set>
   20756:	e7df      	b.n	20718 <uECC_vli_modInv+0x1c>
		if (EVEN(a)) {
   20758:	9b00      	ldr	r3, [sp, #0]
   2075a:	07da      	lsls	r2, r3, #31
   2075c:	d409      	bmi.n	20772 <uECC_vli_modInv+0x76>
			uECC_vli_rshift1(a, num_words);
   2075e:	4621      	mov	r1, r4
   20760:	4668      	mov	r0, sp
   20762:	f7ff fc5b 	bl	2001c <uECC_vli_rshift1>
      			vli_modInv_update(u, mod, num_words);
   20766:	4622      	mov	r2, r4
   20768:	4629      	mov	r1, r5
   2076a:	a810      	add	r0, sp, #64	; 0x40
      			vli_modInv_update(v, mod, num_words);
   2076c:	f7ff fc63 	bl	20036 <vli_modInv_update>
   20770:	e7e6      	b.n	20740 <uECC_vli_modInv+0x44>
    		} else if (EVEN(b)) {
   20772:	9b08      	ldr	r3, [sp, #32]
   20774:	07db      	lsls	r3, r3, #31
   20776:	d407      	bmi.n	20788 <uECC_vli_modInv+0x8c>
			uECC_vli_rshift1(b, num_words);
   20778:	4621      	mov	r1, r4
   2077a:	a808      	add	r0, sp, #32
   2077c:	f7ff fc4e 	bl	2001c <uECC_vli_rshift1>
      			vli_modInv_update(v, mod, num_words);
   20780:	4622      	mov	r2, r4
   20782:	4629      	mov	r1, r5
   20784:	a818      	add	r0, sp, #96	; 0x60
   20786:	e7f1      	b.n	2076c <uECC_vli_modInv+0x70>
		} else if (cmpResult > 0) {
   20788:	2800      	cmp	r0, #0
			uECC_vli_sub(a, a, b, num_words);
   2078a:	4623      	mov	r3, r4
		} else if (cmpResult > 0) {
   2078c:	dd1c      	ble.n	207c8 <uECC_vli_modInv+0xcc>
			uECC_vli_sub(a, a, b, num_words);
   2078e:	aa08      	add	r2, sp, #32
   20790:	4669      	mov	r1, sp
   20792:	4668      	mov	r0, sp
   20794:	f7ff fd5b 	bl	2024e <uECC_vli_sub>
			uECC_vli_rshift1(a, num_words);
   20798:	4621      	mov	r1, r4
   2079a:	4668      	mov	r0, sp
   2079c:	f7ff fc3e 	bl	2001c <uECC_vli_rshift1>
			if (uECC_vli_cmp_unsafe(u, v, num_words) < 0) {
   207a0:	4622      	mov	r2, r4
   207a2:	a918      	add	r1, sp, #96	; 0x60
   207a4:	a810      	add	r0, sp, #64	; 0x40
   207a6:	f7ff fd28 	bl	201fa <uECC_vli_cmp_unsafe>
   207aa:	2800      	cmp	r0, #0
   207ac:	da05      	bge.n	207ba <uECC_vli_modInv+0xbe>
        			uECC_vli_add(u, u, mod, num_words);
   207ae:	a910      	add	r1, sp, #64	; 0x40
   207b0:	4623      	mov	r3, r4
   207b2:	462a      	mov	r2, r5
   207b4:	4608      	mov	r0, r1
   207b6:	f7ff fc19 	bl	1ffec <uECC_vli_add>
      			uECC_vli_sub(u, u, v, num_words);
   207ba:	a910      	add	r1, sp, #64	; 0x40
   207bc:	4623      	mov	r3, r4
   207be:	aa18      	add	r2, sp, #96	; 0x60
   207c0:	4608      	mov	r0, r1
   207c2:	f7ff fd44 	bl	2024e <uECC_vli_sub>
   207c6:	e7ce      	b.n	20766 <uECC_vli_modInv+0x6a>
      			uECC_vli_sub(b, b, a, num_words);
   207c8:	a908      	add	r1, sp, #32
   207ca:	466a      	mov	r2, sp
   207cc:	4608      	mov	r0, r1
   207ce:	f7ff fd3e 	bl	2024e <uECC_vli_sub>
      			uECC_vli_rshift1(b, num_words);
   207d2:	4621      	mov	r1, r4
   207d4:	a808      	add	r0, sp, #32
   207d6:	f7ff fc21 	bl	2001c <uECC_vli_rshift1>
      			if (uECC_vli_cmp_unsafe(v, u, num_words) < 0) {
   207da:	4622      	mov	r2, r4
   207dc:	a910      	add	r1, sp, #64	; 0x40
   207de:	a818      	add	r0, sp, #96	; 0x60
   207e0:	f7ff fd0b 	bl	201fa <uECC_vli_cmp_unsafe>
   207e4:	2800      	cmp	r0, #0
   207e6:	da05      	bge.n	207f4 <uECC_vli_modInv+0xf8>
        			uECC_vli_add(v, v, mod, num_words);
   207e8:	a918      	add	r1, sp, #96	; 0x60
   207ea:	4623      	mov	r3, r4
   207ec:	462a      	mov	r2, r5
   207ee:	4608      	mov	r0, r1
   207f0:	f7ff fbfc 	bl	1ffec <uECC_vli_add>
      			uECC_vli_sub(v, v, u, num_words);
   207f4:	a918      	add	r1, sp, #96	; 0x60
   207f6:	4623      	mov	r3, r4
   207f8:	aa10      	add	r2, sp, #64	; 0x40
   207fa:	4608      	mov	r0, r1
   207fc:	f7ff fd27 	bl	2024e <uECC_vli_sub>
   20800:	e7be      	b.n	20780 <uECC_vli_modInv+0x84>

00020802 <EccPoint_isZero>:
	return uECC_vli_isZero(point, curve->num_words * 2);
   20802:	7809      	ldrb	r1, [r1, #0]
   20804:	0049      	lsls	r1, r1, #1
   20806:	b249      	sxtb	r1, r1
   20808:	f7ff bcb1 	b.w	2016e <uECC_vli_isZero>

0002080c <apply_z>:
{
   2080c:	b5f0      	push	{r4, r5, r6, r7, lr}
   2080e:	4615      	mov	r5, r2
   20810:	b089      	sub	sp, #36	; 0x24
   20812:	461c      	mov	r4, r3
   20814:	4607      	mov	r7, r0
   20816:	460e      	mov	r6, r1
	uECC_vli_modSquare_fast(t1, Z, curve);    /* z^2 */
   20818:	461a      	mov	r2, r3
   2081a:	4629      	mov	r1, r5
   2081c:	4668      	mov	r0, sp
   2081e:	f7ff fe07 	bl	20430 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t1, curve); /* x1 * z^2 */
   20822:	4623      	mov	r3, r4
   20824:	466a      	mov	r2, sp
   20826:	4639      	mov	r1, r7
   20828:	4638      	mov	r0, r7
   2082a:	f7ff fdf1 	bl	20410 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(t1, t1, Z, curve);  /* z^3 */
   2082e:	4623      	mov	r3, r4
   20830:	462a      	mov	r2, r5
   20832:	4669      	mov	r1, sp
   20834:	4668      	mov	r0, sp
   20836:	f7ff fdeb 	bl	20410 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(Y1, Y1, t1, curve); /* y1 * z^3 */
   2083a:	4623      	mov	r3, r4
   2083c:	466a      	mov	r2, sp
   2083e:	4631      	mov	r1, r6
   20840:	4630      	mov	r0, r6
   20842:	f7ff fde5 	bl	20410 <uECC_vli_modMult_fast>
}
   20846:	b009      	add	sp, #36	; 0x24
   20848:	bdf0      	pop	{r4, r5, r6, r7, pc}

0002084a <XYcZ_add>:
{
   2084a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2084e:	b08b      	sub	sp, #44	; 0x2c
   20850:	4614      	mov	r4, r2
	wordcount_t num_words = curve->num_words;
   20852:	9d12      	ldr	r5, [sp, #72]	; 0x48
   20854:	f915 6b04 	ldrsb.w	r6, [r5], #4
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   20858:	9600      	str	r6, [sp, #0]
{
   2085a:	461f      	mov	r7, r3
   2085c:	4680      	mov	r8, r0
   2085e:	4689      	mov	r9, r1
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   20860:	462b      	mov	r3, r5
   20862:	4602      	mov	r2, r0
   20864:	4621      	mov	r1, r4
   20866:	a802      	add	r0, sp, #8
   20868:	f7ff fd23 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
   2086c:	a902      	add	r1, sp, #8
   2086e:	9a12      	ldr	r2, [sp, #72]	; 0x48
   20870:	4608      	mov	r0, r1
   20872:	f7ff fddd 	bl	20430 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
   20876:	9b12      	ldr	r3, [sp, #72]	; 0x48
   20878:	aa02      	add	r2, sp, #8
   2087a:	4641      	mov	r1, r8
   2087c:	4640      	mov	r0, r8
   2087e:	f7ff fdc7 	bl	20410 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
   20882:	9b12      	ldr	r3, [sp, #72]	; 0x48
   20884:	aa02      	add	r2, sp, #8
   20886:	4621      	mov	r1, r4
   20888:	4620      	mov	r0, r4
   2088a:	f7ff fdc1 	bl	20410 <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
   2088e:	462b      	mov	r3, r5
   20890:	464a      	mov	r2, r9
   20892:	4639      	mov	r1, r7
   20894:	4638      	mov	r0, r7
   20896:	9600      	str	r6, [sp, #0]
   20898:	f7ff fd0b 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, Y2, curve); /* t5 = (y2 - y1)^2 = D */
   2089c:	9a12      	ldr	r2, [sp, #72]	; 0x48
   2089e:	4639      	mov	r1, r7
   208a0:	a802      	add	r0, sp, #8
   208a2:	f7ff fdc5 	bl	20430 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t5, t5, X1, curve->p, num_words); /* t5 = D - B */
   208a6:	a902      	add	r1, sp, #8
   208a8:	462b      	mov	r3, r5
   208aa:	4642      	mov	r2, r8
   208ac:	4608      	mov	r0, r1
   208ae:	9600      	str	r6, [sp, #0]
   208b0:	f7ff fcff 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, X2, curve->p, num_words); /* t5 = D - B - C = x3 */
   208b4:	a902      	add	r1, sp, #8
   208b6:	462b      	mov	r3, r5
   208b8:	4622      	mov	r2, r4
   208ba:	4608      	mov	r0, r1
   208bc:	9600      	str	r6, [sp, #0]
   208be:	f7ff fcf8 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modSub(X2, X2, X1, curve->p, num_words); /* t3 = C - B */
   208c2:	462b      	mov	r3, r5
   208c4:	4642      	mov	r2, r8
   208c6:	4621      	mov	r1, r4
   208c8:	4620      	mov	r0, r4
   208ca:	9600      	str	r6, [sp, #0]
   208cc:	f7ff fcf1 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, X2, curve); /* t2 = y1*(C - B) */
   208d0:	9b12      	ldr	r3, [sp, #72]	; 0x48
   208d2:	4622      	mov	r2, r4
   208d4:	4649      	mov	r1, r9
   208d6:	4648      	mov	r0, r9
   208d8:	f7ff fd9a 	bl	20410 <uECC_vli_modMult_fast>
	uECC_vli_modSub(X2, X1, t5, curve->p, num_words); /* t3 = B - x3 */
   208dc:	462b      	mov	r3, r5
   208de:	aa02      	add	r2, sp, #8
   208e0:	4641      	mov	r1, r8
   208e2:	4620      	mov	r0, r4
   208e4:	9600      	str	r6, [sp, #0]
   208e6:	f7ff fce4 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, X2, curve); /* t4 = (y2 - y1)*(B - x3) */
   208ea:	9b12      	ldr	r3, [sp, #72]	; 0x48
   208ec:	4622      	mov	r2, r4
   208ee:	4639      	mov	r1, r7
   208f0:	4638      	mov	r0, r7
   208f2:	f7ff fd8d 	bl	20410 <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y3 */
   208f6:	462b      	mov	r3, r5
   208f8:	464a      	mov	r2, r9
   208fa:	4639      	mov	r1, r7
   208fc:	4638      	mov	r0, r7
   208fe:	9600      	str	r6, [sp, #0]
   20900:	f7ff fcd7 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_set(X2, t5, num_words);
   20904:	4632      	mov	r2, r6
   20906:	a902      	add	r1, sp, #8
   20908:	4620      	mov	r0, r4
   2090a:	f7ff fc6a 	bl	201e2 <uECC_vli_set>
}
   2090e:	b00b      	add	sp, #44	; 0x2c
   20910:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00020914 <EccPoint_mult>:

void EccPoint_mult(uECC_word_t * result, const uECC_word_t * point,
		   const uECC_word_t * scalar,
		   const uECC_word_t * initial_Z,
		   bitcount_t num_bits, uECC_Curve curve) 
{
   20914:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20918:	b0b1      	sub	sp, #196	; 0xc4
   2091a:	e9cd 0104 	strd	r0, r1, [sp, #16]
   2091e:	9c3b      	ldr	r4, [sp, #236]	; 0xec
   20920:	9206      	str	r2, [sp, #24]
	uECC_word_t Rx[2][NUM_ECC_WORDS];
	uECC_word_t Ry[2][NUM_ECC_WORDS];
	uECC_word_t z[NUM_ECC_WORDS];
	bitcount_t i;
	uECC_word_t nb;
	wordcount_t num_words = curve->num_words;
   20922:	f994 7000 	ldrsb.w	r7, [r4]

	uECC_vli_set(Rx[1], point, num_words);
   20926:	a818      	add	r0, sp, #96	; 0x60
   20928:	463a      	mov	r2, r7
{
   2092a:	461e      	mov	r6, r3
	uECC_vli_set(Rx[1], point, num_words);
   2092c:	f7ff fc59 	bl	201e2 <uECC_vli_set>
  	uECC_vli_set(Ry[1], point + num_words, num_words);
   20930:	00bb      	lsls	r3, r7, #2
   20932:	9307      	str	r3, [sp, #28]
   20934:	9b05      	ldr	r3, [sp, #20]
   20936:	00ba      	lsls	r2, r7, #2
   20938:	4413      	add	r3, r2
   2093a:	4619      	mov	r1, r3
   2093c:	463a      	mov	r2, r7
   2093e:	a828      	add	r0, sp, #160	; 0xa0
   20940:	9302      	str	r3, [sp, #8]
   20942:	f7ff fc4e 	bl	201e2 <uECC_vli_set>
	wordcount_t num_words = curve->num_words;
   20946:	f994 5000 	ldrsb.w	r5, [r4]
	if (initial_Z) {
   2094a:	2e00      	cmp	r6, #0
   2094c:	f000 8087 	beq.w	20a5e <EccPoint_mult+0x14a>
		uECC_vli_set(z, initial_Z, num_words);
   20950:	462a      	mov	r2, r5
   20952:	4631      	mov	r1, r6
   20954:	a808      	add	r0, sp, #32
   20956:	f7ff fc44 	bl	201e2 <uECC_vli_set>
	uECC_vli_set(X2, X1, num_words);
   2095a:	ae10      	add	r6, sp, #64	; 0x40
   2095c:	462a      	mov	r2, r5
   2095e:	a918      	add	r1, sp, #96	; 0x60
   20960:	4630      	mov	r0, r6
	uECC_vli_set(Y2, Y1, num_words);
   20962:	f10d 0980 	add.w	r9, sp, #128	; 0x80
	uECC_vli_set(X2, X1, num_words);
   20966:	f7ff fc3c 	bl	201e2 <uECC_vli_set>
	uECC_vli_set(Y2, Y1, num_words);
   2096a:	a928      	add	r1, sp, #160	; 0xa0
   2096c:	4648      	mov	r0, r9
   2096e:	f7ff fc38 	bl	201e2 <uECC_vli_set>
	apply_z(X1, Y1, z, curve);
   20972:	4623      	mov	r3, r4
   20974:	aa08      	add	r2, sp, #32
   20976:	a928      	add	r1, sp, #160	; 0xa0
   20978:	a818      	add	r0, sp, #96	; 0x60
   2097a:	f7ff ff47 	bl	2080c <apply_z>
	curve->double_jacobian(X1, Y1, z, curve);
   2097e:	f8d4 50a4 	ldr.w	r5, [r4, #164]	; 0xa4
   20982:	4623      	mov	r3, r4
   20984:	aa08      	add	r2, sp, #32
   20986:	a928      	add	r1, sp, #160	; 0xa0
   20988:	a818      	add	r0, sp, #96	; 0x60
   2098a:	47a8      	blx	r5
	apply_z(X2, Y2, z, curve);
   2098c:	4623      	mov	r3, r4
   2098e:	aa08      	add	r2, sp, #32
   20990:	4649      	mov	r1, r9
   20992:	4630      	mov	r0, r6
   20994:	f7ff ff3a 	bl	2080c <apply_z>

	XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z, curve);

	for (i = num_bits - 2; i > 0; --i) {
   20998:	f9bd 50e8 	ldrsh.w	r5, [sp, #232]	; 0xe8
   2099c:	3d02      	subs	r5, #2
   2099e:	b22d      	sxth	r5, r5
   209a0:	2d00      	cmp	r5, #0
   209a2:	dc63      	bgt.n	20a6c <EccPoint_mult+0x158>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   209a4:	9b06      	ldr	r3, [sp, #24]
   209a6:	681d      	ldr	r5, [r3, #0]
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
	}

	nb = !uECC_vli_testBit(scalar, 0);
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   209a8:	9400      	str	r4, [sp, #0]
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   209aa:	f005 0601 	and.w	r6, r5, #1
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   209ae:	ab10      	add	r3, sp, #64	; 0x40
   209b0:	0176      	lsls	r6, r6, #5
   209b2:	43ed      	mvns	r5, r5
   209b4:	eb03 0806 	add.w	r8, r3, r6
   209b8:	f005 0501 	and.w	r5, r5, #1
   209bc:	ab20      	add	r3, sp, #128	; 0x80
   209be:	441e      	add	r6, r3
   209c0:	016d      	lsls	r5, r5, #5
   209c2:	ab10      	add	r3, sp, #64	; 0x40
   209c4:	eb03 0905 	add.w	r9, r3, r5
   209c8:	ab20      	add	r3, sp, #128	; 0x80
   209ca:	441d      	add	r5, r3

	/* Find final 1/Z value. */
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
   209cc:	f104 0a04 	add.w	sl, r4, #4
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   209d0:	462b      	mov	r3, r5
   209d2:	464a      	mov	r2, r9
   209d4:	4631      	mov	r1, r6
   209d6:	4640      	mov	r0, r8
   209d8:	f7ff fe04 	bl	205e4 <XYcZ_addC>
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
   209dc:	4653      	mov	r3, sl
   209de:	aa10      	add	r2, sp, #64	; 0x40
   209e0:	a918      	add	r1, sp, #96	; 0x60
   209e2:	a808      	add	r0, sp, #32
   209e4:	9700      	str	r7, [sp, #0]
   209e6:	f7ff fc64 	bl	202b2 <uECC_vli_modSub>
	uECC_vli_modMult_fast(z, z, Ry[1 - nb], curve); /* Yb * (X1 - X0) */
   209ea:	a908      	add	r1, sp, #32
   209ec:	4623      	mov	r3, r4
   209ee:	4632      	mov	r2, r6
   209f0:	4608      	mov	r0, r1
   209f2:	f7ff fd0d 	bl	20410 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(z, z, point, curve); /* xP * Yb * (X1 - X0) */
   209f6:	a908      	add	r1, sp, #32
   209f8:	4623      	mov	r3, r4
   209fa:	9a05      	ldr	r2, [sp, #20]
   209fc:	4608      	mov	r0, r1
   209fe:	f7ff fd07 	bl	20410 <uECC_vli_modMult_fast>
	uECC_vli_modInv(z, z, curve->p, num_words); /* 1 / (xP * Yb * (X1 - X0))*/
   20a02:	a908      	add	r1, sp, #32
   20a04:	463b      	mov	r3, r7
   20a06:	4652      	mov	r2, sl
   20a08:	4608      	mov	r0, r1
   20a0a:	f7ff fe77 	bl	206fc <uECC_vli_modInv>
	/* yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, point + num_words, curve);
   20a0e:	a908      	add	r1, sp, #32
   20a10:	4623      	mov	r3, r4
   20a12:	9a02      	ldr	r2, [sp, #8]
   20a14:	4608      	mov	r0, r1
   20a16:	f7ff fcfb 	bl	20410 <uECC_vli_modMult_fast>
	/* Xb * yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, Rx[1 - nb], curve);
   20a1a:	a908      	add	r1, sp, #32
   20a1c:	4623      	mov	r3, r4
   20a1e:	4642      	mov	r2, r8
   20a20:	4608      	mov	r0, r1
   20a22:	f7ff fcf5 	bl	20410 <uECC_vli_modMult_fast>
	/* End 1/Z calculation */

	XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
   20a26:	9400      	str	r4, [sp, #0]
   20a28:	4633      	mov	r3, r6
   20a2a:	4642      	mov	r2, r8
   20a2c:	4629      	mov	r1, r5
   20a2e:	4648      	mov	r0, r9
   20a30:	f7ff ff0b 	bl	2084a <XYcZ_add>
	apply_z(Rx[0], Ry[0], z, curve);
   20a34:	4623      	mov	r3, r4
   20a36:	aa08      	add	r2, sp, #32
   20a38:	a920      	add	r1, sp, #128	; 0x80
   20a3a:	a810      	add	r0, sp, #64	; 0x40
   20a3c:	f7ff fee6 	bl	2080c <apply_z>

	uECC_vli_set(result, Rx[0], num_words);
   20a40:	463a      	mov	r2, r7
   20a42:	a910      	add	r1, sp, #64	; 0x40
   20a44:	9804      	ldr	r0, [sp, #16]
   20a46:	f7ff fbcc 	bl	201e2 <uECC_vli_set>
	uECC_vli_set(result + num_words, Ry[0], num_words);
   20a4a:	9b04      	ldr	r3, [sp, #16]
   20a4c:	9c07      	ldr	r4, [sp, #28]
   20a4e:	4423      	add	r3, r4
   20a50:	a920      	add	r1, sp, #128	; 0x80
   20a52:	4618      	mov	r0, r3
   20a54:	f7ff fbc5 	bl	201e2 <uECC_vli_set>
}
   20a58:	b031      	add	sp, #196	; 0xc4
   20a5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uECC_vli_clear(z, num_words);
   20a5e:	4629      	mov	r1, r5
   20a60:	a808      	add	r0, sp, #32
   20a62:	f7ff fb79 	bl	20158 <uECC_vli_clear>
		z[0] = 1;
   20a66:	2301      	movs	r3, #1
   20a68:	9308      	str	r3, [sp, #32]
   20a6a:	e776      	b.n	2095a <EccPoint_mult+0x46>
		nb = !uECC_vli_testBit(scalar, i);
   20a6c:	4629      	mov	r1, r5
   20a6e:	9806      	ldr	r0, [sp, #24]
   20a70:	f7ff fb8c 	bl	2018c <uECC_vli_testBit>
   20a74:	fab0 f080 	clz	r0, r0
   20a78:	0940      	lsrs	r0, r0, #5
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   20a7a:	f1c0 0801 	rsb	r8, r0, #1
   20a7e:	ea4f 1848 	mov.w	r8, r8, lsl #5
   20a82:	0140      	lsls	r0, r0, #5
   20a84:	eb06 0b08 	add.w	fp, r6, r8
   20a88:	eb06 0a00 	add.w	sl, r6, r0
   20a8c:	44c8      	add	r8, r9
   20a8e:	eb09 0300 	add.w	r3, r9, r0
   20a92:	4652      	mov	r2, sl
   20a94:	4641      	mov	r1, r8
   20a96:	4658      	mov	r0, fp
   20a98:	9400      	str	r4, [sp, #0]
   20a9a:	9303      	str	r3, [sp, #12]
   20a9c:	f7ff fda2 	bl	205e4 <XYcZ_addC>
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
   20aa0:	9400      	str	r4, [sp, #0]
   20aa2:	4643      	mov	r3, r8
   20aa4:	465a      	mov	r2, fp
   20aa6:	9903      	ldr	r1, [sp, #12]
   20aa8:	4650      	mov	r0, sl
   20aaa:	f7ff fece 	bl	2084a <XYcZ_add>
	for (i = num_bits - 2; i > 0; --i) {
   20aae:	3d01      	subs	r5, #1
   20ab0:	e775      	b.n	2099e <EccPoint_mult+0x8a>

00020ab2 <regularize_k>:

uECC_word_t regularize_k(const uECC_word_t * const k, uECC_word_t *k0,
			 uECC_word_t *k1, uECC_Curve curve)
{
   20ab2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   20ab6:	f9b3 4002 	ldrsh.w	r4, [r3, #2]
   20aba:	f114 051f 	adds.w	r5, r4, #31
   20abe:	bf48      	it	mi
   20ac0:	f104 053e 	addmi.w	r5, r4, #62	; 0x3e
{
   20ac4:	460f      	mov	r7, r1

	bitcount_t num_n_bits = curve->num_n_bits;

	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   20ac6:	f103 0624 	add.w	r6, r3, #36	; 0x24
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   20aca:	f345 1547 	sbfx	r5, r5, #5, #8
{
   20ace:	4690      	mov	r8, r2
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   20ad0:	4601      	mov	r1, r0
   20ad2:	462b      	mov	r3, r5
   20ad4:	4632      	mov	r2, r6
   20ad6:	4638      	mov	r0, r7
   20ad8:	f7ff fa88 	bl	1ffec <uECC_vli_add>
   20adc:	b990      	cbnz	r0, 20b04 <regularize_k+0x52>
   20ade:	ebb4 1f45 	cmp.w	r4, r5, lsl #5
   20ae2:	da11      	bge.n	20b08 <regularize_k+0x56>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
			     uECC_vli_testBit(k0, num_n_bits));
   20ae4:	4621      	mov	r1, r4
   20ae6:	4638      	mov	r0, r7
   20ae8:	f7ff fb50 	bl	2018c <uECC_vli_testBit>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
   20aec:	1c04      	adds	r4, r0, #0
   20aee:	bf18      	it	ne
   20af0:	2401      	movne	r4, #1

	uECC_vli_add(k1, k0, curve->n, num_n_words);
   20af2:	462b      	mov	r3, r5
   20af4:	4632      	mov	r2, r6
   20af6:	4639      	mov	r1, r7
   20af8:	4640      	mov	r0, r8
   20afa:	f7ff fa77 	bl	1ffec <uECC_vli_add>

	return carry;
}
   20afe:	4620      	mov	r0, r4
   20b00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   20b04:	2401      	movs	r4, #1
   20b06:	e7f4      	b.n	20af2 <regularize_k+0x40>
   20b08:	4604      	mov	r4, r0
   20b0a:	e7f2      	b.n	20af2 <regularize_k+0x40>

00020b0c <EccPoint_compute_public_key>:

uECC_word_t EccPoint_compute_public_key(uECC_word_t *result,
					uECC_word_t *private_key,
					uECC_Curve curve)
{
   20b0c:	b530      	push	{r4, r5, lr}
   20b0e:	4614      	mov	r4, r2
   20b10:	b095      	sub	sp, #84	; 0x54
   20b12:	4605      	mov	r5, r0

	uECC_word_t tmp1[NUM_ECC_WORDS];
 	uECC_word_t tmp2[NUM_ECC_WORDS];
	uECC_word_t *p2[2] = {tmp1, tmp2};
   20b14:	aa0c      	add	r2, sp, #48	; 0x30
	uECC_word_t carry;

	/* Regularize the bitcount for the private key so that attackers cannot
	 * use a side channel attack to learn the number of leading zeros. */
	carry = regularize_k(private_key, tmp1, tmp2, curve);
   20b16:	4623      	mov	r3, r4
{
   20b18:	4608      	mov	r0, r1
	uECC_word_t *p2[2] = {tmp1, tmp2};
   20b1a:	a904      	add	r1, sp, #16
   20b1c:	9102      	str	r1, [sp, #8]
   20b1e:	9203      	str	r2, [sp, #12]
	carry = regularize_k(private_key, tmp1, tmp2, curve);
   20b20:	f7ff ffc7 	bl	20ab2 <regularize_k>

	EccPoint_mult(result, curve->G, p2[!carry], 0, curve->num_n_bits + 1, curve);
   20b24:	fab0 f080 	clz	r0, r0
   20b28:	ab14      	add	r3, sp, #80	; 0x50
   20b2a:	0940      	lsrs	r0, r0, #5
   20b2c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   20b30:	8863      	ldrh	r3, [r4, #2]
   20b32:	9401      	str	r4, [sp, #4]
   20b34:	3301      	adds	r3, #1
   20b36:	b21b      	sxth	r3, r3
   20b38:	9300      	str	r3, [sp, #0]
   20b3a:	f850 2c48 	ldr.w	r2, [r0, #-72]
   20b3e:	2300      	movs	r3, #0
   20b40:	f104 0144 	add.w	r1, r4, #68	; 0x44
   20b44:	4628      	mov	r0, r5
   20b46:	f7ff fee5 	bl	20914 <EccPoint_mult>

	if (EccPoint_isZero(result, curve)) {
   20b4a:	4621      	mov	r1, r4
   20b4c:	4628      	mov	r0, r5
   20b4e:	f7ff fe58 	bl	20802 <EccPoint_isZero>
		return 0;
	}
	return 1;
}
   20b52:	fab0 f080 	clz	r0, r0
   20b56:	0940      	lsrs	r0, r0, #5
   20b58:	b015      	add	sp, #84	; 0x54
   20b5a:	bd30      	pop	{r4, r5, pc}

00020b5c <uECC_vli_nativeToBytes>:

/* Converts an integer in uECC native format to big-endian bytes. */
void uECC_vli_nativeToBytes(uint8_t *bytes, int num_bytes,
			    const unsigned int *native)
{
   20b5c:	b5f0      	push	{r4, r5, r6, r7, lr}
	wordcount_t i;
	for (i = 0; i < num_bytes; ++i) {
   20b5e:	2500      	movs	r5, #0
		unsigned b = num_bytes - 1 - i;
   20b60:	1e4f      	subs	r7, r1, #1
   20b62:	b26c      	sxtb	r4, r5
	for (i = 0; i < num_bytes; ++i) {
   20b64:	428c      	cmp	r4, r1
   20b66:	f105 0501 	add.w	r5, r5, #1
   20b6a:	db00      	blt.n	20b6e <uECC_vli_nativeToBytes+0x12>
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
	}
}
   20b6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
   20b6e:	1b3b      	subs	r3, r7, r4
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
   20b70:	f023 0603 	bic.w	r6, r3, #3
   20b74:	f003 0303 	and.w	r3, r3, #3
   20b78:	5996      	ldr	r6, [r2, r6]
   20b7a:	00db      	lsls	r3, r3, #3
   20b7c:	fa26 f303 	lsr.w	r3, r6, r3
   20b80:	5503      	strb	r3, [r0, r4]
   20b82:	e7ee      	b.n	20b62 <uECC_vli_nativeToBytes+0x6>

00020b84 <uECC_vli_bytesToNative>:

/* Converts big-endian bytes to an integer in uECC native format. */
void uECC_vli_bytesToNative(unsigned int *native, const uint8_t *bytes,
			    int num_bytes)
{
   20b84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   20b86:	460e      	mov	r6, r1
	wordcount_t i;
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
   20b88:	1cd1      	adds	r1, r2, #3
   20b8a:	bf48      	it	mi
   20b8c:	1d91      	addmi	r1, r2, #6
{
   20b8e:	4614      	mov	r4, r2
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
   20b90:	f341 0187 	sbfx	r1, r1, #2, #8
{
   20b94:	4605      	mov	r5, r0
	for (i = 0; i < num_bytes; ++i) {
		unsigned b = num_bytes - 1 - i;
   20b96:	1e67      	subs	r7, r4, #1
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
   20b98:	f7ff fade 	bl	20158 <uECC_vli_clear>
	for (i = 0; i < num_bytes; ++i) {
   20b9c:	2100      	movs	r1, #0
   20b9e:	b24a      	sxtb	r2, r1
   20ba0:	42a2      	cmp	r2, r4
   20ba2:	f101 0101 	add.w	r1, r1, #1
   20ba6:	db00      	blt.n	20baa <uECC_vli_bytesToNative+0x26>
		native[b / uECC_WORD_SIZE] |=
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
  	}
}
   20ba8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
   20baa:	1abb      	subs	r3, r7, r2
		native[b / uECC_WORD_SIZE] |=
   20bac:	f023 0003 	bic.w	r0, r3, #3
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
   20bb0:	5cb2      	ldrb	r2, [r6, r2]
   20bb2:	f003 0303 	and.w	r3, r3, #3
   20bb6:	00db      	lsls	r3, r3, #3
   20bb8:	fa02 f303 	lsl.w	r3, r2, r3
		native[b / uECC_WORD_SIZE] |=
   20bbc:	582a      	ldr	r2, [r5, r0]
   20bbe:	431a      	orrs	r2, r3
   20bc0:	502a      	str	r2, [r5, r0]
   20bc2:	e7ec      	b.n	20b9e <uECC_vli_bytesToNative+0x1a>

00020bc4 <uECC_valid_point>:
	return 0;
}


int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve)
{
   20bc4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   20bc8:	b090      	sub	sp, #64	; 0x40
   20bca:	4606      	mov	r6, r0
   20bcc:	460c      	mov	r4, r1
	uECC_word_t tmp1[NUM_ECC_WORDS];
	uECC_word_t tmp2[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
   20bce:	f991 5000 	ldrsb.w	r5, [r1]

	/* The point at infinity is invalid. */
	if (EccPoint_isZero(point, curve)) {
   20bd2:	f7ff fe16 	bl	20802 <EccPoint_isZero>
   20bd6:	bb40      	cbnz	r0, 20c2a <uECC_valid_point+0x66>
		return -1;
	}

	/* x and y must be smaller than p. */
	if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
   20bd8:	f104 0804 	add.w	r8, r4, #4
   20bdc:	462a      	mov	r2, r5
   20bde:	4631      	mov	r1, r6
   20be0:	4640      	mov	r0, r8
   20be2:	f7ff fb0a 	bl	201fa <uECC_vli_cmp_unsafe>
   20be6:	2801      	cmp	r0, #1
   20be8:	d122      	bne.n	20c30 <uECC_valid_point+0x6c>
		uECC_vli_cmp_unsafe(curve->p, point + num_words, num_words) != 1) {
   20bea:	eb06 0785 	add.w	r7, r6, r5, lsl #2
   20bee:	462a      	mov	r2, r5
   20bf0:	4639      	mov	r1, r7
   20bf2:	4640      	mov	r0, r8
   20bf4:	f7ff fb01 	bl	201fa <uECC_vli_cmp_unsafe>
	if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
   20bf8:	2801      	cmp	r0, #1
   20bfa:	d119      	bne.n	20c30 <uECC_valid_point+0x6c>
		return -2;
	}

	uECC_vli_modSquare_fast(tmp1, point + num_words, curve);
   20bfc:	4622      	mov	r2, r4
   20bfe:	4668      	mov	r0, sp
   20c00:	f7ff fc16 	bl	20430 <uECC_vli_modSquare_fast>
	curve->x_side(tmp2, point, curve); /* tmp2 = x^3 + ax + b */
   20c04:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
   20c08:	4622      	mov	r2, r4
   20c0a:	4631      	mov	r1, r6
   20c0c:	a808      	add	r0, sp, #32
   20c0e:	4798      	blx	r3

	/* Make sure that y^2 == x^3 + ax + b */
	if (uECC_vli_equal(tmp1, tmp2, num_words) != 0)
   20c10:	462a      	mov	r2, r5
   20c12:	a908      	add	r1, sp, #32
   20c14:	4668      	mov	r0, sp
   20c16:	f7ff fb07 	bl	20228 <uECC_vli_equal>
   20c1a:	2800      	cmp	r0, #0
		return -3;
   20c1c:	bf0c      	ite	eq
   20c1e:	2000      	moveq	r0, #0
   20c20:	f06f 0002 	mvnne.w	r0, #2

	return 0;
}
   20c24:	b010      	add	sp, #64	; 0x40
   20c26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -1;
   20c2a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   20c2e:	e7f9      	b.n	20c24 <uECC_valid_point+0x60>
		return -2;
   20c30:	f06f 0001 	mvn.w	r0, #1
   20c34:	e7f6      	b.n	20c24 <uECC_valid_point+0x60>

00020c36 <uECC_valid_public_key>:

int uECC_valid_public_key(const uint8_t *public_key, uECC_Curve curve)
{
   20c36:	b570      	push	{r4, r5, r6, lr}
   20c38:	460c      	mov	r4, r1
   20c3a:	b090      	sub	sp, #64	; 0x40

	uECC_word_t _public[NUM_ECC_WORDS * 2];

	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
	uECC_vli_bytesToNative(
	_public + curve->num_words,
   20c3c:	4625      	mov	r5, r4
	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
   20c3e:	f991 2001 	ldrsb.w	r2, [r1, #1]
{
   20c42:	4606      	mov	r6, r0
	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
   20c44:	4601      	mov	r1, r0
   20c46:	4668      	mov	r0, sp
   20c48:	f7ff ff9c 	bl	20b84 <uECC_vli_bytesToNative>
	public_key + curve->num_bytes,
   20c4c:	f994 2001 	ldrsb.w	r2, [r4, #1]
	_public + curve->num_words,
   20c50:	f915 0b44 	ldrsb.w	r0, [r5], #68
	uECC_vli_bytesToNative(
   20c54:	18b1      	adds	r1, r6, r2
   20c56:	eb0d 0080 	add.w	r0, sp, r0, lsl #2
   20c5a:	f7ff ff93 	bl	20b84 <uECC_vli_bytesToNative>
	curve->num_bytes);

	if (uECC_vli_cmp_unsafe(_public, curve->G, NUM_ECC_WORDS * 2) == 0) {
   20c5e:	2210      	movs	r2, #16
   20c60:	4629      	mov	r1, r5
   20c62:	4668      	mov	r0, sp
   20c64:	f7ff fac9 	bl	201fa <uECC_vli_cmp_unsafe>
   20c68:	b128      	cbz	r0, 20c76 <uECC_valid_public_key+0x40>
		return -4;
	}

	return uECC_valid_point(_public, curve);
   20c6a:	4621      	mov	r1, r4
   20c6c:	4668      	mov	r0, sp
   20c6e:	f7ff ffa9 	bl	20bc4 <uECC_valid_point>
}
   20c72:	b010      	add	sp, #64	; 0x40
   20c74:	bd70      	pop	{r4, r5, r6, pc}
		return -4;
   20c76:	f06f 0003 	mvn.w	r0, #3
   20c7a:	e7fa      	b.n	20c72 <uECC_valid_public_key+0x3c>

00020c7c <add_round_key>:
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
   20c7c:	78cb      	ldrb	r3, [r1, #3]
   20c7e:	7802      	ldrb	r2, [r0, #0]
   20c80:	4053      	eors	r3, r2
   20c82:	7003      	strb	r3, [r0, #0]
   20c84:	884b      	ldrh	r3, [r1, #2]
   20c86:	7842      	ldrb	r2, [r0, #1]
   20c88:	4053      	eors	r3, r2
   20c8a:	7043      	strb	r3, [r0, #1]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
   20c8c:	680a      	ldr	r2, [r1, #0]
   20c8e:	7883      	ldrb	r3, [r0, #2]
   20c90:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   20c94:	7083      	strb	r3, [r0, #2]
   20c96:	680a      	ldr	r2, [r1, #0]
   20c98:	78c3      	ldrb	r3, [r0, #3]
   20c9a:	4053      	eors	r3, r2
   20c9c:	70c3      	strb	r3, [r0, #3]
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
   20c9e:	79cb      	ldrb	r3, [r1, #7]
   20ca0:	7902      	ldrb	r2, [r0, #4]
   20ca2:	4053      	eors	r3, r2
   20ca4:	7103      	strb	r3, [r0, #4]
   20ca6:	88cb      	ldrh	r3, [r1, #6]
   20ca8:	7942      	ldrb	r2, [r0, #5]
   20caa:	4053      	eors	r3, r2
   20cac:	7143      	strb	r3, [r0, #5]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
   20cae:	684a      	ldr	r2, [r1, #4]
   20cb0:	7983      	ldrb	r3, [r0, #6]
   20cb2:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   20cb6:	7183      	strb	r3, [r0, #6]
   20cb8:	684a      	ldr	r2, [r1, #4]
   20cba:	79c3      	ldrb	r3, [r0, #7]
   20cbc:	4053      	eors	r3, r2
   20cbe:	71c3      	strb	r3, [r0, #7]
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
   20cc0:	7acb      	ldrb	r3, [r1, #11]
   20cc2:	7a02      	ldrb	r2, [r0, #8]
   20cc4:	4053      	eors	r3, r2
   20cc6:	7203      	strb	r3, [r0, #8]
   20cc8:	7a42      	ldrb	r2, [r0, #9]
   20cca:	894b      	ldrh	r3, [r1, #10]
   20ccc:	4053      	eors	r3, r2
   20cce:	7243      	strb	r3, [r0, #9]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
   20cd0:	688a      	ldr	r2, [r1, #8]
   20cd2:	7a83      	ldrb	r3, [r0, #10]
   20cd4:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   20cd8:	7283      	strb	r3, [r0, #10]
   20cda:	688a      	ldr	r2, [r1, #8]
   20cdc:	7ac3      	ldrb	r3, [r0, #11]
   20cde:	4053      	eors	r3, r2
   20ce0:	72c3      	strb	r3, [r0, #11]
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
   20ce2:	7bcb      	ldrb	r3, [r1, #15]
   20ce4:	7b02      	ldrb	r2, [r0, #12]
   20ce6:	4053      	eors	r3, r2
   20ce8:	7303      	strb	r3, [r0, #12]
   20cea:	89cb      	ldrh	r3, [r1, #14]
   20cec:	7b42      	ldrb	r2, [r0, #13]
   20cee:	4053      	eors	r3, r2
   20cf0:	7343      	strb	r3, [r0, #13]
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
   20cf2:	68ca      	ldr	r2, [r1, #12]
   20cf4:	7b83      	ldrb	r3, [r0, #14]
   20cf6:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   20cfa:	7383      	strb	r3, [r0, #14]
   20cfc:	68ca      	ldr	r2, [r1, #12]
   20cfe:	7bc3      	ldrb	r3, [r0, #15]
   20d00:	4053      	eors	r3, r2
   20d02:	73c3      	strb	r3, [r0, #15]
}
   20d04:	4770      	bx	lr

00020d06 <shift_rows>:
{
   20d06:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
   20d08:	7802      	ldrb	r2, [r0, #0]
   20d0a:	f88d 2000 	strb.w	r2, [sp]
   20d0e:	7942      	ldrb	r2, [r0, #5]
   20d10:	f88d 2001 	strb.w	r2, [sp, #1]
   20d14:	7a82      	ldrb	r2, [r0, #10]
   20d16:	f88d 2002 	strb.w	r2, [sp, #2]
   20d1a:	7bc2      	ldrb	r2, [r0, #15]
   20d1c:	f88d 2003 	strb.w	r2, [sp, #3]
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
   20d20:	7902      	ldrb	r2, [r0, #4]
   20d22:	f88d 2004 	strb.w	r2, [sp, #4]
   20d26:	7a42      	ldrb	r2, [r0, #9]
   20d28:	f88d 2005 	strb.w	r2, [sp, #5]
   20d2c:	7b82      	ldrb	r2, [r0, #14]
   20d2e:	f88d 2006 	strb.w	r2, [sp, #6]
   20d32:	78c2      	ldrb	r2, [r0, #3]
   20d34:	f88d 2007 	strb.w	r2, [sp, #7]
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
   20d38:	7a02      	ldrb	r2, [r0, #8]
   20d3a:	f88d 2008 	strb.w	r2, [sp, #8]
   20d3e:	7b42      	ldrb	r2, [r0, #13]
   20d40:	f88d 2009 	strb.w	r2, [sp, #9]
   20d44:	7882      	ldrb	r2, [r0, #2]
   20d46:	f88d 200a 	strb.w	r2, [sp, #10]
   20d4a:	79c2      	ldrb	r2, [r0, #7]
   20d4c:	f88d 200b 	strb.w	r2, [sp, #11]
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
   20d50:	7b02      	ldrb	r2, [r0, #12]
   20d52:	f88d 200c 	strb.w	r2, [sp, #12]
   20d56:	7842      	ldrb	r2, [r0, #1]
   20d58:	f88d 200d 	strb.w	r2, [sp, #13]
   20d5c:	7ac3      	ldrb	r3, [r0, #11]
   20d5e:	7982      	ldrb	r2, [r0, #6]
   20d60:	f88d 200e 	strb.w	r2, [sp, #14]
   20d64:	f88d 300f 	strb.w	r3, [sp, #15]
	(void) _copy(s, sizeof(t), t, sizeof(t));
   20d68:	2310      	movs	r3, #16
   20d6a:	466a      	mov	r2, sp
   20d6c:	4619      	mov	r1, r3
   20d6e:	f7ff f878 	bl	1fe62 <_copy>
}
   20d72:	b005      	add	sp, #20
   20d74:	f85d fb04 	ldr.w	pc, [sp], #4

00020d78 <mult_row_column>:
{
   20d78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   20d7a:	4606      	mov	r6, r0
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   20d7c:	7808      	ldrb	r0, [r1, #0]
{
   20d7e:	460c      	mov	r4, r1
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   20d80:	f7ff f87e 	bl	1fe80 <_double_byte>
   20d84:	4605      	mov	r5, r0
   20d86:	7860      	ldrb	r0, [r4, #1]
   20d88:	f7ff f87a 	bl	1fe80 <_double_byte>
   20d8c:	78a2      	ldrb	r2, [r4, #2]
   20d8e:	7863      	ldrb	r3, [r4, #1]
   20d90:	4053      	eors	r3, r2
   20d92:	78e2      	ldrb	r2, [r4, #3]
   20d94:	4053      	eors	r3, r2
   20d96:	405d      	eors	r5, r3
   20d98:	4045      	eors	r5, r0
   20d9a:	7035      	strb	r5, [r6, #0]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
   20d9c:	7860      	ldrb	r0, [r4, #1]
   20d9e:	7827      	ldrb	r7, [r4, #0]
   20da0:	f7ff f86e 	bl	1fe80 <_double_byte>
   20da4:	4605      	mov	r5, r0
   20da6:	78a0      	ldrb	r0, [r4, #2]
   20da8:	f7ff f86a 	bl	1fe80 <_double_byte>
   20dac:	78a3      	ldrb	r3, [r4, #2]
   20dae:	405f      	eors	r7, r3
   20db0:	78e3      	ldrb	r3, [r4, #3]
   20db2:	405f      	eors	r7, r3
   20db4:	407d      	eors	r5, r7
   20db6:	4045      	eors	r5, r0
   20db8:	7075      	strb	r5, [r6, #1]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
   20dba:	78a0      	ldrb	r0, [r4, #2]
   20dbc:	7865      	ldrb	r5, [r4, #1]
   20dbe:	7827      	ldrb	r7, [r4, #0]
   20dc0:	f7ff f85e 	bl	1fe80 <_double_byte>
   20dc4:	406f      	eors	r7, r5
   20dc6:	4605      	mov	r5, r0
   20dc8:	78e0      	ldrb	r0, [r4, #3]
   20dca:	f7ff f859 	bl	1fe80 <_double_byte>
   20dce:	78e3      	ldrb	r3, [r4, #3]
   20dd0:	405f      	eors	r7, r3
   20dd2:	407d      	eors	r5, r7
   20dd4:	4045      	eors	r5, r0
   20dd6:	70b5      	strb	r5, [r6, #2]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
   20dd8:	7820      	ldrb	r0, [r4, #0]
   20dda:	f7ff f851 	bl	1fe80 <_double_byte>
   20dde:	7863      	ldrb	r3, [r4, #1]
   20de0:	7825      	ldrb	r5, [r4, #0]
   20de2:	405d      	eors	r5, r3
   20de4:	78a3      	ldrb	r3, [r4, #2]
   20de6:	405d      	eors	r5, r3
   20de8:	4045      	eors	r5, r0
   20dea:	78e0      	ldrb	r0, [r4, #3]
   20dec:	f7ff f848 	bl	1fe80 <_double_byte>
   20df0:	b2ed      	uxtb	r5, r5
   20df2:	4068      	eors	r0, r5
   20df4:	70f0      	strb	r0, [r6, #3]
}
   20df6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00020df8 <gf_double>:
 *           the in and out buffers do not overlap.
 *  effects: doubles the GF(2^n) value pointed to by "in" and places
 *           the result in the GF(2^n) value pointed to by "out."
 */
void gf_double(uint8_t *out, uint8_t *in)
{
   20df8:	b510      	push	{r4, lr}

	/* start with low order byte */
	uint8_t *x = in + (TC_AES_BLOCK_SIZE - 1);

	/* if msb == 1, we need to add the gf_wrap value, otherwise add 0 */
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   20dfa:	460a      	mov	r2, r1

	out += (TC_AES_BLOCK_SIZE - 1);
   20dfc:	300f      	adds	r0, #15
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   20dfe:	f912 3b10 	ldrsb.w	r3, [r2], #16
   20e02:	2b00      	cmp	r3, #0
   20e04:	bfb4      	ite	lt
   20e06:	2387      	movlt	r3, #135	; 0x87
   20e08:	2300      	movge	r3, #0
	for (;;) {
		*out-- = (*x << 1) ^ carry;
   20e0a:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
   20e0e:	ea83 0344 	eor.w	r3, r3, r4, lsl #1
		if (x == in) {
   20e12:	4291      	cmp	r1, r2
		*out-- = (*x << 1) ^ carry;
   20e14:	f800 3901 	strb.w	r3, [r0], #-1
		if (x == in) {
   20e18:	d002      	beq.n	20e20 <gf_double+0x28>
			break;
		}
		carry = *x-- >> 7;
   20e1a:	7813      	ldrb	r3, [r2, #0]
   20e1c:	09db      	lsrs	r3, r3, #7
		*out-- = (*x << 1) ^ carry;
   20e1e:	e7f4      	b.n	20e0a <gf_double+0x12>
	}
}
   20e20:	bd10      	pop	{r4, pc}

00020e22 <tc_cmac_erase>:

	return TC_CRYPTO_SUCCESS;
}

int tc_cmac_erase(TCCmacState_t s)
{
   20e22:	b508      	push	{r3, lr}
	if (s == (TCCmacState_t) 0) {
   20e24:	b120      	cbz	r0, 20e30 <tc_cmac_erase+0xe>
		return TC_CRYPTO_FAIL;
	}

	/* destroy the current state */
	_set(s, 0, sizeof(*s));
   20e26:	2258      	movs	r2, #88	; 0x58
   20e28:	2100      	movs	r1, #0
   20e2a:	f7ff f827 	bl	1fe7c <_set>
   20e2e:	2001      	movs	r0, #1

	return TC_CRYPTO_SUCCESS;
}
   20e30:	bd08      	pop	{r3, pc}

00020e32 <tc_cmac_init>:

int tc_cmac_init(TCCmacState_t s)
{
   20e32:	b510      	push	{r4, lr}
	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   20e34:	4604      	mov	r4, r0
   20e36:	b188      	cbz	r0, 20e5c <tc_cmac_init+0x2a>
		return TC_CRYPTO_FAIL;
	}

	/* CMAC starts with an all zero initialization vector */
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   20e38:	2210      	movs	r2, #16
   20e3a:	2100      	movs	r1, #0
   20e3c:	f7ff f81e 	bl	1fe7c <_set>

	/* and the leftover buffer is empty */
	_set(s->leftover, 0, TC_AES_BLOCK_SIZE);
   20e40:	2210      	movs	r2, #16
   20e42:	f104 0030 	add.w	r0, r4, #48	; 0x30
   20e46:	2100      	movs	r1, #0
   20e48:	f7ff f818 	bl	1fe7c <_set>
	s->leftover_offset = 0;
   20e4c:	2300      	movs	r3, #0
   20e4e:	6463      	str	r3, [r4, #68]	; 0x44

	/* Set countdown to max number of calls allowed before re-keying: */
	s->countdown = MAX_CALLS;
   20e50:	2200      	movs	r2, #0
   20e52:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   20e56:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50
   20e5a:	2001      	movs	r0, #1

	return TC_CRYPTO_SUCCESS;
}
   20e5c:	bd10      	pop	{r4, pc}

00020e5e <tc_cmac_setup>:
{
   20e5e:	b570      	push	{r4, r5, r6, lr}
   20e60:	460d      	mov	r5, r1
   20e62:	4616      	mov	r6, r2
	if (s == (TCCmacState_t) 0 ||
   20e64:	4604      	mov	r4, r0
   20e66:	b310      	cbz	r0, 20eae <tc_cmac_setup+0x50>
   20e68:	b311      	cbz	r1, 20eb0 <tc_cmac_setup+0x52>
	_set(s, 0, sizeof(*s));
   20e6a:	2258      	movs	r2, #88	; 0x58
   20e6c:	2100      	movs	r1, #0
   20e6e:	f7ff f805 	bl	1fe7c <_set>
	tc_aes128_set_encrypt_key(s->sched, key);
   20e72:	4629      	mov	r1, r5
	s->sched = sched;
   20e74:	64a6      	str	r6, [r4, #72]	; 0x48
	tc_aes128_set_encrypt_key(s->sched, key);
   20e76:	4630      	mov	r0, r6
   20e78:	f7e3 fd78 	bl	496c <tc_aes128_set_encrypt_key>
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   20e7c:	2210      	movs	r2, #16
   20e7e:	2100      	movs	r1, #0
   20e80:	4620      	mov	r0, r4
   20e82:	f7fe fffb 	bl	1fe7c <_set>
	gf_double (s->K1, s->iv);
   20e86:	f104 0510 	add.w	r5, r4, #16
	tc_aes_encrypt(s->iv, s->iv, s->sched);
   20e8a:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   20e8c:	4621      	mov	r1, r4
   20e8e:	4620      	mov	r0, r4
   20e90:	f7e3 fdc2 	bl	4a18 <tc_aes_encrypt>
	gf_double (s->K1, s->iv);
   20e94:	4621      	mov	r1, r4
   20e96:	4628      	mov	r0, r5
   20e98:	f7ff ffae 	bl	20df8 <gf_double>
	gf_double (s->K2, s->K1);
   20e9c:	4629      	mov	r1, r5
   20e9e:	f104 0020 	add.w	r0, r4, #32
   20ea2:	f7ff ffa9 	bl	20df8 <gf_double>
	tc_cmac_init(s);
   20ea6:	4620      	mov	r0, r4
   20ea8:	f7ff ffc3 	bl	20e32 <tc_cmac_init>
	return TC_CRYPTO_SUCCESS;
   20eac:	2001      	movs	r0, #1
}
   20eae:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
   20eb0:	4608      	mov	r0, r1
   20eb2:	e7fc      	b.n	20eae <tc_cmac_setup+0x50>

00020eb4 <tc_cmac_update>:

int tc_cmac_update(TCCmacState_t s, const uint8_t *data, size_t data_length)
{
   20eb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   20eb8:	460d      	mov	r5, r1
   20eba:	4616      	mov	r6, r2
	unsigned int i;

	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   20ebc:	4604      	mov	r4, r0
   20ebe:	2800      	cmp	r0, #0
   20ec0:	d061      	beq.n	20f86 <tc_cmac_update+0xd2>
		return TC_CRYPTO_FAIL;
	}
	if (data_length == 0) {
   20ec2:	b912      	cbnz	r2, 20eca <tc_cmac_update+0x16>
		/* save leftover data for next time */
		_copy(s->leftover, data_length, data, data_length);
		s->leftover_offset = data_length;
	}

	return TC_CRYPTO_SUCCESS;
   20ec4:	2001      	movs	r0, #1
}
   20ec6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (data == (const uint8_t *) 0) {
   20eca:	2900      	cmp	r1, #0
   20ecc:	d05b      	beq.n	20f86 <tc_cmac_update+0xd2>
	if (s->countdown == 0) {
   20ece:	e9d0 0114 	ldrd	r0, r1, [r0, #80]	; 0x50
   20ed2:	ea50 0301 	orrs.w	r3, r0, r1
   20ed6:	d056      	beq.n	20f86 <tc_cmac_update+0xd2>
	s->countdown--;
   20ed8:	f110 32ff 	adds.w	r2, r0, #4294967295	; 0xffffffff
	if (s->leftover_offset > 0) {
   20edc:	f8d4 8044 	ldr.w	r8, [r4, #68]	; 0x44
	s->countdown--;
   20ee0:	f141 33ff 	adc.w	r3, r1, #4294967295	; 0xffffffff
   20ee4:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50
	if (s->leftover_offset > 0) {
   20ee8:	f1b8 0f00 	cmp.w	r8, #0
   20eec:	d02a      	beq.n	20f44 <tc_cmac_update+0x90>
		size_t remaining_space = TC_AES_BLOCK_SIZE - s->leftover_offset;
   20eee:	f1c8 0710 	rsb	r7, r8, #16
		if (data_length < remaining_space) {
   20ef2:	f108 0030 	add.w	r0, r8, #48	; 0x30
   20ef6:	42be      	cmp	r6, r7
   20ef8:	4420      	add	r0, r4
   20efa:	d208      	bcs.n	20f0e <tc_cmac_update+0x5a>
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
   20efc:	4633      	mov	r3, r6
   20efe:	4631      	mov	r1, r6
   20f00:	462a      	mov	r2, r5
   20f02:	f7fe ffae 	bl	1fe62 <_copy>
			s->leftover_offset += data_length;
   20f06:	6c63      	ldr	r3, [r4, #68]	; 0x44
   20f08:	441e      	add	r6, r3
		s->leftover_offset = data_length;
   20f0a:	6466      	str	r6, [r4, #68]	; 0x44
   20f0c:	e7da      	b.n	20ec4 <tc_cmac_update+0x10>
		_copy(&s->leftover[s->leftover_offset],
   20f0e:	463b      	mov	r3, r7
   20f10:	462a      	mov	r2, r5
   20f12:	4639      	mov	r1, r7
   20f14:	f7fe ffa5 	bl	1fe62 <_copy>
		data_length -= remaining_space;
   20f18:	3e10      	subs	r6, #16
		s->leftover_offset = 0;
   20f1a:	2300      	movs	r3, #0
   20f1c:	6463      	str	r3, [r4, #68]	; 0x44
		data_length -= remaining_space;
   20f1e:	4446      	add	r6, r8
		data += remaining_space;
   20f20:	443d      	add	r5, r7
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   20f22:	1e63      	subs	r3, r4, #1
   20f24:	f104 010f 	add.w	r1, r4, #15
			s->iv[i] ^= s->leftover[i];
   20f28:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   20f2c:	f893 0030 	ldrb.w	r0, [r3, #48]	; 0x30
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   20f30:	428b      	cmp	r3, r1
			s->iv[i] ^= s->leftover[i];
   20f32:	ea82 0200 	eor.w	r2, r2, r0
   20f36:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   20f38:	d1f6      	bne.n	20f28 <tc_cmac_update+0x74>
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   20f3a:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   20f3c:	4621      	mov	r1, r4
   20f3e:	4620      	mov	r0, r4
   20f40:	f7e3 fd6a 	bl	4a18 <tc_aes_encrypt>
   20f44:	f104 070f 	add.w	r7, r4, #15
	while (data_length > TC_AES_BLOCK_SIZE) {
   20f48:	2e10      	cmp	r6, #16
   20f4a:	d809      	bhi.n	20f60 <tc_cmac_update+0xac>
	if (data_length > 0) {
   20f4c:	2e00      	cmp	r6, #0
   20f4e:	d0b9      	beq.n	20ec4 <tc_cmac_update+0x10>
		_copy(s->leftover, data_length, data, data_length);
   20f50:	4633      	mov	r3, r6
   20f52:	462a      	mov	r2, r5
   20f54:	4631      	mov	r1, r6
   20f56:	f104 0030 	add.w	r0, r4, #48	; 0x30
   20f5a:	f7fe ff82 	bl	1fe62 <_copy>
   20f5e:	e7d4      	b.n	20f0a <tc_cmac_update+0x56>
   20f60:	1e63      	subs	r3, r4, #1
   20f62:	1e69      	subs	r1, r5, #1
			s->iv[i] ^= data[i];
   20f64:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   20f68:	f811 0f01 	ldrb.w	r0, [r1, #1]!
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   20f6c:	42bb      	cmp	r3, r7
			s->iv[i] ^= data[i];
   20f6e:	ea82 0200 	eor.w	r2, r2, r0
   20f72:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   20f74:	d1f6      	bne.n	20f64 <tc_cmac_update+0xb0>
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   20f76:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   20f78:	4621      	mov	r1, r4
   20f7a:	4620      	mov	r0, r4
   20f7c:	f7e3 fd4c 	bl	4a18 <tc_aes_encrypt>
		data += TC_AES_BLOCK_SIZE;
   20f80:	3510      	adds	r5, #16
		data_length  -= TC_AES_BLOCK_SIZE;
   20f82:	3e10      	subs	r6, #16
   20f84:	e7e0      	b.n	20f48 <tc_cmac_update+0x94>
		return TC_CRYPTO_FAIL;
   20f86:	2000      	movs	r0, #0
   20f88:	e79d      	b.n	20ec6 <tc_cmac_update+0x12>

00020f8a <tc_cmac_final>:

int tc_cmac_final(uint8_t *tag, TCCmacState_t s)
{
   20f8a:	b570      	push	{r4, r5, r6, lr}
   20f8c:	460c      	mov	r4, r1
	uint8_t *k;
	unsigned int i;

	/* input sanity check: */
	if (tag == (uint8_t *) 0 ||
   20f8e:	4605      	mov	r5, r0
   20f90:	b1e8      	cbz	r0, 20fce <tc_cmac_final+0x44>
   20f92:	b369      	cbz	r1, 20ff0 <tc_cmac_final+0x66>
	    s == (TCCmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	if (s->leftover_offset == TC_AES_BLOCK_SIZE) {
   20f94:	6c4a      	ldr	r2, [r1, #68]	; 0x44
   20f96:	2a10      	cmp	r2, #16
   20f98:	d11a      	bne.n	20fd0 <tc_cmac_final+0x46>
		/* the last message block is a full-sized block */
		k = (uint8_t *) s->K1;
   20f9a:	3110      	adds	r1, #16

		_set(&s->leftover[s->leftover_offset], 0, remaining);
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
		k = (uint8_t *) s->K2;
	}
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   20f9c:	1e63      	subs	r3, r4, #1
   20f9e:	3901      	subs	r1, #1
   20fa0:	f104 000f 	add.w	r0, r4, #15
		s->iv[i] ^= s->leftover[i] ^ k[i];
   20fa4:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   20fa8:	f893 6030 	ldrb.w	r6, [r3, #48]	; 0x30
   20fac:	4072      	eors	r2, r6
   20fae:	f811 6f01 	ldrb.w	r6, [r1, #1]!
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   20fb2:	4298      	cmp	r0, r3
		s->iv[i] ^= s->leftover[i] ^ k[i];
   20fb4:	ea82 0206 	eor.w	r2, r2, r6
   20fb8:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   20fba:	d1f3      	bne.n	20fa4 <tc_cmac_final+0x1a>
	}

	tc_aes_encrypt(tag, s->iv, s->sched);
   20fbc:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   20fbe:	4621      	mov	r1, r4
   20fc0:	4628      	mov	r0, r5
   20fc2:	f7e3 fd29 	bl	4a18 <tc_aes_encrypt>

	/* erasing state: */
	tc_cmac_erase(s);
   20fc6:	4620      	mov	r0, r4
   20fc8:	f7ff ff2b 	bl	20e22 <tc_cmac_erase>

	return TC_CRYPTO_SUCCESS;
   20fcc:	2001      	movs	r0, #1
}
   20fce:	bd70      	pop	{r4, r5, r6, pc}
		_set(&s->leftover[s->leftover_offset], 0, remaining);
   20fd0:	f102 0030 	add.w	r0, r2, #48	; 0x30
   20fd4:	2100      	movs	r1, #0
   20fd6:	f1c2 0210 	rsb	r2, r2, #16
   20fda:	4420      	add	r0, r4
   20fdc:	f7fe ff4e 	bl	1fe7c <_set>
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
   20fe0:	6c63      	ldr	r3, [r4, #68]	; 0x44
   20fe2:	4423      	add	r3, r4
   20fe4:	2280      	movs	r2, #128	; 0x80
   20fe6:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
		k = (uint8_t *) s->K2;
   20fea:	f104 0120 	add.w	r1, r4, #32
   20fee:	e7d5      	b.n	20f9c <tc_cmac_final+0x12>
		return TC_CRYPTO_FAIL;
   20ff0:	4608      	mov	r0, r1
   20ff2:	e7ec      	b.n	20fce <tc_cmac_final+0x44>

00020ff4 <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
   20ff4:	2300      	movs	r3, #0
	list->head = NULL;
   20ff6:	e9c0 3300 	strd	r3, r3, [r0]
}
   20ffa:	4770      	bx	lr

00020ffc <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
   20ffc:	6803      	ldr	r3, [r0, #0]
   20ffe:	b923      	cbnz	r3, 2100a <log_list_add_tail+0xe>
		list->head = msg;
   21000:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
   21002:	2300      	movs	r3, #0
	list->tail = msg;
   21004:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
   21006:	600b      	str	r3, [r1, #0]
}
   21008:	4770      	bx	lr
		list->tail->next = msg;
   2100a:	6843      	ldr	r3, [r0, #4]
   2100c:	6019      	str	r1, [r3, #0]
   2100e:	e7f8      	b.n	21002 <log_list_add_tail+0x6>

00021010 <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
   21010:	6800      	ldr	r0, [r0, #0]
   21012:	4770      	bx	lr

00021014 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
	struct log_msg *msg = list->head;
   21014:	6803      	ldr	r3, [r0, #0]

	if (list->head != NULL) {
   21016:	b10b      	cbz	r3, 2101c <log_list_head_get+0x8>
		list->head = list->head->next;
   21018:	681a      	ldr	r2, [r3, #0]
   2101a:	6002      	str	r2, [r0, #0]
	}

	return msg;
}
   2101c:	4618      	mov	r0, r3
   2101e:	4770      	bx	lr

00021020 <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
   21020:	b508      	push	{r3, lr}
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   21022:	f7e4 f839 	bl	5098 <log_msg_chunk_alloc>

	if (msg != NULL) {
   21026:	b118      	cbz	r0, 21030 <z_log_msg_std_alloc+0x10>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
   21028:	2301      	movs	r3, #1
   2102a:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
   2102c:	2300      	movs	r3, #0
   2102e:	8103      	strh	r3, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
	}

	return msg;
}
   21030:	bd08      	pop	{r3, pc}

00021032 <k_cycle_get_32_wrapper>:
#ifndef _ASMLANGUAGE
extern u32_t z_timer_cycle_get_32(void);

static inline u32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
   21032:	f7e5 bc63 	b.w	68fc <z_timer_cycle_get_32>

00021036 <dummy_timestamp>:
   21036:	2000      	movs	r0, #0
   21038:	4770      	bx	lr

0002103a <log_0>:
{
   2103a:	b538      	push	{r3, r4, r5, lr}
   2103c:	4605      	mov	r5, r0
   2103e:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
   21040:	f7ff ffee 	bl	21020 <z_log_msg_std_alloc>

	if (msg != NULL) {
   21044:	b128      	cbz	r0, 21052 <log_0+0x18>
		msg->str = str;
   21046:	6105      	str	r5, [r0, #16]
		msg_finalize(msg, src_level);
   21048:	4621      	mov	r1, r4
}
   2104a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		msg_finalize(msg, src_level);
   2104e:	f7e3 bf45 	b.w	4edc <msg_finalize>
}
   21052:	bd38      	pop	{r3, r4, r5, pc}

00021054 <log_1>:
{
   21054:	b570      	push	{r4, r5, r6, lr}
   21056:	4604      	mov	r4, r0
   21058:	460e      	mov	r6, r1
   2105a:	4615      	mov	r5, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   2105c:	f7ff ffe0 	bl	21020 <z_log_msg_std_alloc>

	if (msg != NULL) {
   21060:	b158      	cbz	r0, 2107a <log_1+0x26>
		msg->str = str;
   21062:	6104      	str	r4, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
   21064:	7a44      	ldrb	r4, [r0, #9]
		msg->payload.single.args[0] = arg1;
   21066:	6146      	str	r6, [r0, #20]
		msg->hdr.params.std.nargs = 1U;
   21068:	2201      	movs	r2, #1
   2106a:	f362 1407 	bfi	r4, r2, #4, #4
   2106e:	7244      	strb	r4, [r0, #9]
		msg_finalize(msg, src_level);
   21070:	4629      	mov	r1, r5
}
   21072:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		msg_finalize(msg, src_level);
   21076:	f7e3 bf31 	b.w	4edc <msg_finalize>
}
   2107a:	bd70      	pop	{r4, r5, r6, pc}

0002107c <log_2>:
{
   2107c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   21080:	4605      	mov	r5, r0
   21082:	4688      	mov	r8, r1
   21084:	4617      	mov	r7, r2
   21086:	461e      	mov	r6, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   21088:	f7ff ffca 	bl	21020 <z_log_msg_std_alloc>

	if (msg != NULL) {
   2108c:	b160      	cbz	r0, 210a8 <log_2+0x2c>
		msg->str = str;
   2108e:	6105      	str	r5, [r0, #16]
		msg->hdr.params.std.nargs = 2U;
   21090:	7a45      	ldrb	r5, [r0, #9]
   21092:	2302      	movs	r3, #2
   21094:	f363 1507 	bfi	r5, r3, #4, #4
   21098:	7245      	strb	r5, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   2109a:	e9c0 8705 	strd	r8, r7, [r0, #20]
		msg_finalize(msg, src_level);
   2109e:	4631      	mov	r1, r6
}
   210a0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		msg_finalize(msg, src_level);
   210a4:	f7e3 bf1a 	b.w	4edc <msg_finalize>
}
   210a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000210ac <log_3>:
{
   210ac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   210b0:	4605      	mov	r5, r0
   210b2:	4689      	mov	r9, r1
   210b4:	4690      	mov	r8, r2
   210b6:	461f      	mov	r7, r3
   210b8:	f8bd 6020 	ldrh.w	r6, [sp, #32]
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   210bc:	f7ff ffb0 	bl	21020 <z_log_msg_std_alloc>

	if (msg != NULL) {
   210c0:	b168      	cbz	r0, 210de <log_3+0x32>
		msg->str = str;
   210c2:	6105      	str	r5, [r0, #16]
		msg->hdr.params.std.nargs = 3U;
   210c4:	7a45      	ldrb	r5, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
		msg->payload.single.args[2] = arg3;
   210c6:	61c7      	str	r7, [r0, #28]
		msg->hdr.params.std.nargs = 3U;
   210c8:	2303      	movs	r3, #3
   210ca:	f363 1507 	bfi	r5, r3, #4, #4
   210ce:	7245      	strb	r5, [r0, #9]
		msg->payload.single.args[1] = arg2;
   210d0:	e9c0 9805 	strd	r9, r8, [r0, #20]
		msg_finalize(msg, src_level);
   210d4:	4631      	mov	r1, r6
}
   210d6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		msg_finalize(msg, src_level);
   210da:	f7e3 beff 	b.w	4edc <msg_finalize>
}
   210de:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000210e2 <log_n>:
{
   210e2:	b510      	push	{r4, lr}
   210e4:	461c      	mov	r4, r3
		struct log_msg *msg = log_msg_create_n(str, args, narg);
   210e6:	f000 f8b3 	bl	21250 <log_msg_create_n>
		if (msg == NULL) {
   210ea:	b120      	cbz	r0, 210f6 <log_n+0x14>
		msg_finalize(msg, src_level);
   210ec:	4621      	mov	r1, r4
}
   210ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		msg_finalize(msg, src_level);
   210f2:	f7e3 bef3 	b.w	4edc <msg_finalize>
}
   210f6:	bd10      	pop	{r4, pc}

000210f8 <log_printk>:
{
   210f8:	b500      	push	{lr}
   210fa:	b0a3      	sub	sp, #140	; 0x8c
			length = vsnprintk(str, sizeof(str), fmt, ap);
   210fc:	4602      	mov	r2, r0
   210fe:	460b      	mov	r3, r1
   21100:	a801      	add	r0, sp, #4
   21102:	2181      	movs	r1, #129	; 0x81
   21104:	f7e3 fb48 	bl	4798 <vsnprintk>
			msg = log_msg_hexdump_create(NULL, str, length);
   21108:	2881      	cmp	r0, #129	; 0x81
   2110a:	4602      	mov	r2, r0
   2110c:	a901      	add	r1, sp, #4
   2110e:	bf28      	it	cs
   21110:	2281      	movcs	r2, #129	; 0x81
   21112:	2000      	movs	r0, #0
   21114:	f000 f8f0 	bl	212f8 <log_msg_hexdump_create>
			if (msg == NULL) {
   21118:	b118      	cbz	r0, 21122 <log_printk+0x2a>
			msg_finalize(msg, src_level_union.structure);
   2111a:	f04f 0100 	mov.w	r1, #0
   2111e:	f7e3 fedd 	bl	4edc <msg_finalize>
}
   21122:	b023      	add	sp, #140	; 0x8c
   21124:	f85d fb04 	ldr.w	pc, [sp], #4

00021128 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    u8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
   21128:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2112c:	461c      	mov	r4, r3
	u32_t available_len = msg->hdr.params.hexdump.length;
   2112e:	8903      	ldrh	r3, [r0, #8]
{
   21130:	f89d 7020 	ldrb.w	r7, [sp, #32]
	u32_t available_len = msg->hdr.params.hexdump.length;
   21134:	089b      	lsrs	r3, r3, #2
	u8_t *head_data;
	u32_t chunk_len;
	u32_t req_len;
	u32_t cpy_len;

	if (offset >= available_len) {
   21136:	42a3      	cmp	r3, r4
{
   21138:	460e      	mov	r6, r1
	if (offset >= available_len) {
   2113a:	d803      	bhi.n	21144 <log_msg_hexdump_data_op+0x1c>
		*length = 0;
   2113c:	2300      	movs	r3, #0
   2113e:	6013      	str	r3, [r2, #0]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
   21140:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((offset + *length) > available_len) {
   21144:	6811      	ldr	r1, [r2, #0]
   21146:	4421      	add	r1, r4
   21148:	4299      	cmp	r1, r3
		*length = available_len - offset;
   2114a:	bf84      	itt	hi
   2114c:	1b19      	subhi	r1, r3, r4
   2114e:	6011      	strhi	r1, [r2, #0]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   21150:	2b0c      	cmp	r3, #12
	req_len = *length;
   21152:	f8d2 9000 	ldr.w	r9, [r2]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   21156:	d928      	bls.n	211aa <log_msg_hexdump_data_op+0x82>
	if (offset < chunk_len) {
   21158:	2c07      	cmp	r4, #7
		cont = msg->payload.ext.next;
   2115a:	f8d0 8014 	ldr.w	r8, [r0, #20]
	if (offset < chunk_len) {
   2115e:	d82b      	bhi.n	211b8 <log_msg_hexdump_data_op+0x90>
		head_data = msg->payload.ext.data.bytes;
   21160:	3018      	adds	r0, #24
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   21162:	2308      	movs	r3, #8
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   21164:	454b      	cmp	r3, r9
   21166:	bf28      	it	cs
   21168:	464b      	movcs	r3, r9
   2116a:	461d      	mov	r5, r3
		if (put_op) {
   2116c:	4420      	add	r0, r4
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   2116e:	461a      	mov	r2, r3
   21170:	b1ff      	cbz	r7, 211b2 <log_msg_hexdump_data_op+0x8a>
   21172:	4631      	mov	r1, r6
   21174:	f7e0 fd3a 	bl	1bec <memcpy>
		req_len -= cpy_len;
   21178:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
   2117c:	442e      	add	r6, r5
	while (req_len > 0) {
   2117e:	f1b9 0f00 	cmp.w	r9, #0
   21182:	d0dd      	beq.n	21140 <log_msg_hexdump_data_op+0x18>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
   21184:	f1c4 051c 	rsb	r5, r4, #28
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   21188:	454d      	cmp	r5, r9
   2118a:	bf28      	it	cs
   2118c:	464d      	movcs	r5, r9
		if (put_op) {
   2118e:	1d20      	adds	r0, r4, #4
   21190:	4440      	add	r0, r8
   21192:	462a      	mov	r2, r5
   21194:	b1bf      	cbz	r7, 211c6 <log_msg_hexdump_data_op+0x9e>
   21196:	4631      	mov	r1, r6
   21198:	f7e0 fd28 	bl	1bec <memcpy>
		req_len -= cpy_len;
   2119c:	eba9 0905 	sub.w	r9, r9, r5
		cont = cont->next;
   211a0:	f8d8 8000 	ldr.w	r8, [r8]
		data += cpy_len;
   211a4:	442e      	add	r6, r5
		offset = 0;
   211a6:	2400      	movs	r4, #0
   211a8:	e7e9      	b.n	2117e <log_msg_hexdump_data_op+0x56>
		head_data = msg->payload.single.bytes;
   211aa:	3014      	adds	r0, #20
	struct log_msg_cont *cont = NULL;
   211ac:	f04f 0800 	mov.w	r8, #0
   211b0:	e7d8      	b.n	21164 <log_msg_hexdump_data_op+0x3c>
   211b2:	4601      	mov	r1, r0
   211b4:	4630      	mov	r0, r6
   211b6:	e7dd      	b.n	21174 <log_msg_hexdump_data_op+0x4c>
		offset -= chunk_len;
   211b8:	3c08      	subs	r4, #8
		while (offset >= chunk_len) {
   211ba:	2c1b      	cmp	r4, #27
   211bc:	d9df      	bls.n	2117e <log_msg_hexdump_data_op+0x56>
			cont = cont->next;
   211be:	f8d8 8000 	ldr.w	r8, [r8]
			offset -= chunk_len;
   211c2:	3c1c      	subs	r4, #28
   211c4:	e7f9      	b.n	211ba <log_msg_hexdump_data_op+0x92>
   211c6:	4601      	mov	r1, r0
   211c8:	4630      	mov	r0, r6
   211ca:	e7e5      	b.n	21198 <log_msg_hexdump_data_op+0x70>

000211cc <log_msg_get>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   211cc:	3004      	adds	r0, #4
   211ce:	f3bf 8f5b 	dmb	ish
   211d2:	e850 3f00 	ldrex	r3, [r0]
   211d6:	3301      	adds	r3, #1
   211d8:	e840 3200 	strex	r2, r3, [r0]
   211dc:	2a00      	cmp	r2, #0
   211de:	d1f8      	bne.n	211d2 <log_msg_get+0x6>
   211e0:	f3bf 8f5b 	dmb	ish
}
   211e4:	4770      	bx	lr

000211e6 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
   211e6:	7a40      	ldrb	r0, [r0, #9]
}
   211e8:	0900      	lsrs	r0, r0, #4
   211ea:	4770      	bx	lr

000211ec <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
   211ec:	7a43      	ldrb	r3, [r0, #9]
   211ee:	091b      	lsrs	r3, r3, #4
   211f0:	428b      	cmp	r3, r1
   211f2:	d916      	bls.n	21222 <log_msg_arg_get+0x36>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   211f4:	2b03      	cmp	r3, #3
   211f6:	d803      	bhi.n	21200 <log_msg_arg_get+0x14>
		arg = msg->payload.single.args[arg_idx];
   211f8:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   211fc:	6948      	ldr	r0, [r1, #20]
   211fe:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
   21200:	2901      	cmp	r1, #1
   21202:	d803      	bhi.n	2120c <log_msg_arg_get+0x20>
		return msg->payload.ext.data.args[arg_idx];
   21204:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   21208:	6988      	ldr	r0, [r1, #24]
   2120a:	4770      	bx	lr
	cont = msg->payload.ext.next;
   2120c:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
   2120e:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
   21210:	2906      	cmp	r1, #6
   21212:	d803      	bhi.n	2121c <log_msg_arg_get+0x30>
	return cont->payload.args[arg_idx];
   21214:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   21218:	6848      	ldr	r0, [r1, #4]
   2121a:	4770      	bx	lr
		arg_idx -= ARGS_CONT_MSG;
   2121c:	3907      	subs	r1, #7
		cont = cont->next;
   2121e:	681b      	ldr	r3, [r3, #0]
   21220:	e7f6      	b.n	21210 <log_msg_arg_get+0x24>
		return 0;
   21222:	2000      	movs	r0, #0
}
   21224:	4770      	bx	lr

00021226 <log_msg_put>:
{
   21226:	4603      	mov	r3, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   21228:	1d02      	adds	r2, r0, #4
   2122a:	f3bf 8f5b 	dmb	ish
   2122e:	e852 1f00 	ldrex	r1, [r2]
   21232:	3901      	subs	r1, #1
   21234:	e842 1c00 	strex	ip, r1, [r2]
   21238:	f1bc 0f00 	cmp.w	ip, #0
   2123c:	d1f7      	bne.n	2122e <log_msg_put+0x8>
   2123e:	f3bf 8f5b 	dmb	ish
	if (msg->hdr.ref_cnt == 0) {
   21242:	685b      	ldr	r3, [r3, #4]
   21244:	b90b      	cbnz	r3, 2124a <log_msg_put+0x24>
		msg_free(msg);
   21246:	f7e3 bf39 	b.w	50bc <msg_free>
}
   2124a:	4770      	bx	lr

0002124c <log_msg_str_get>:
}
   2124c:	6900      	ldr	r0, [r0, #16]
   2124e:	4770      	bx	lr

00021250 <log_msg_create_n>:
{
   21250:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   21254:	4682      	mov	sl, r0
   21256:	4688      	mov	r8, r1
   21258:	4615      	mov	r5, r2
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   2125a:	f7e3 ff1d 	bl	5098 <log_msg_chunk_alloc>
	if (msg != NULL) {
   2125e:	4604      	mov	r4, r0
   21260:	b330      	cbz	r0, 212b0 <log_msg_create_n+0x60>
		msg->hdr.ref_cnt = 1;
   21262:	2301      	movs	r3, #1
		msg->hdr.params.raw = 0U;
   21264:	2600      	movs	r6, #0
	if ((msg == NULL) || nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   21266:	2d03      	cmp	r5, #3
		msg->hdr.ref_cnt = 1;
   21268:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
   2126a:	8106      	strh	r6, [r0, #8]
   2126c:	d909      	bls.n	21282 <log_msg_create_n+0x32>
	msg->hdr.params.generic.ext = 1;
   2126e:	2202      	movs	r2, #2
   21270:	8102      	strh	r2, [r0, #8]
	n -= LOG_MSG_NARGS_HEAD_CHUNK;
   21272:	f1a5 0902 	sub.w	r9, r5, #2
	next = &msg->payload.ext.next;
   21276:	f100 0b14 	add.w	fp, r0, #20
	*next = NULL;
   2127a:	6146      	str	r6, [r0, #20]
	while (n > 0) {
   2127c:	f1b9 0f00 	cmp.w	r9, #0
   21280:	dc0e      	bgt.n	212a0 <log_msg_create_n+0x50>
		msg->hdr.params.std.nargs = nargs;
   21282:	7a63      	ldrb	r3, [r4, #9]
		msg->str = str;
   21284:	f8c4 a010 	str.w	sl, [r4, #16]
		msg->hdr.params.std.nargs = nargs;
   21288:	f365 1307 	bfi	r3, r5, #4, #4
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
   2128c:	2d03      	cmp	r5, #3
		msg->hdr.params.std.nargs = nargs;
   2128e:	7263      	strb	r3, [r4, #9]
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
   21290:	d818      	bhi.n	212c4 <log_msg_create_n+0x74>
   21292:	00aa      	lsls	r2, r5, #2
   21294:	4641      	mov	r1, r8
   21296:	f104 0014 	add.w	r0, r4, #20
   2129a:	f7e0 fca7 	bl	1bec <memcpy>
   2129e:	e007      	b.n	212b0 <log_msg_create_n+0x60>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
   212a0:	f7e3 fefa 	bl	5098 <log_msg_chunk_alloc>
		if (cont == NULL) {
   212a4:	4607      	mov	r7, r0
   212a6:	b930      	cbnz	r0, 212b6 <log_msg_create_n+0x66>
			msg_free(msg);
   212a8:	4620      	mov	r0, r4
   212aa:	f7e3 ff07 	bl	50bc <msg_free>
			return NULL;
   212ae:	463c      	mov	r4, r7
}
   212b0:	4620      	mov	r0, r4
   212b2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		*next = cont;
   212b6:	f8cb 0000 	str.w	r0, [fp]
		cont->next = NULL;
   212ba:	f1a9 0907 	sub.w	r9, r9, #7
   212be:	6006      	str	r6, [r0, #0]
		next = &cont->next;
   212c0:	4683      	mov	fp, r0
		n -= ARGS_CONT_MSG;
   212c2:	e7db      	b.n	2127c <log_msg_create_n+0x2c>
   212c4:	f8d8 3000 	ldr.w	r3, [r8]
   212c8:	61a3      	str	r3, [r4, #24]
   212ca:	f8d8 3004 	ldr.w	r3, [r8, #4]
	struct log_msg_cont *cont = msg->payload.ext.next;
   212ce:	6967      	ldr	r7, [r4, #20]
   212d0:	61e3      	str	r3, [r4, #28]
		nargs -= LOG_MSG_NARGS_HEAD_CHUNK;
   212d2:	3d02      	subs	r5, #2
		args += LOG_MSG_NARGS_HEAD_CHUNK;
   212d4:	f108 0808 	add.w	r8, r8, #8
		u32_t cpy_args = MIN(nargs, ARGS_CONT_MSG);
   212d8:	2d07      	cmp	r5, #7
   212da:	462e      	mov	r6, r5
   212dc:	bf28      	it	cs
   212de:	2607      	movcs	r6, #7
		(void)memcpy(cont->payload.args, args,
   212e0:	ea4f 0986 	mov.w	r9, r6, lsl #2
   212e4:	4641      	mov	r1, r8
   212e6:	1d38      	adds	r0, r7, #4
   212e8:	464a      	mov	r2, r9
   212ea:	f7e0 fc7f 	bl	1bec <memcpy>
	while (nargs != 0U) {
   212ee:	1bad      	subs	r5, r5, r6
		args += cpy_args;
   212f0:	44c8      	add	r8, r9
		cont = cont->next;
   212f2:	683f      	ldr	r7, [r7, #0]
	while (nargs != 0U) {
   212f4:	d1f0      	bne.n	212d8 <log_msg_create_n+0x88>
   212f6:	e7db      	b.n	212b0 <log_msg_create_n+0x60>

000212f8 <log_msg_hexdump_create>:
{
   212f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	length = (length > LOG_MSG_HEXDUMP_MAX_LENGTH) ?
   212fc:	f643 75ff 	movw	r5, #16383	; 0x3fff
   21300:	4295      	cmp	r5, r2
{
   21302:	4680      	mov	r8, r0
   21304:	460e      	mov	r6, r1
   21306:	4617      	mov	r7, r2
	length = (length > LOG_MSG_HEXDUMP_MAX_LENGTH) ?
   21308:	bf28      	it	cs
   2130a:	4615      	movcs	r5, r2
	msg = (struct log_msg *)log_msg_chunk_alloc();
   2130c:	f7e3 fec4 	bl	5098 <log_msg_chunk_alloc>
	if (msg == NULL) {
   21310:	4604      	mov	r4, r0
   21312:	b378      	cbz	r0, 21374 <log_msg_hexdump_create+0x7c>
	msg->hdr.ref_cnt = 1;
   21314:	2301      	movs	r3, #1
   21316:	6043      	str	r3, [r0, #4]
	msg->hdr.params.hexdump.type = LOG_MSG_TYPE_HEXDUMP;
   21318:	7a03      	ldrb	r3, [r0, #8]
	msg->str = str;
   2131a:	f8c0 8010 	str.w	r8, [r0, #16]
	msg->hdr.params.hexdump.type = LOG_MSG_TYPE_HEXDUMP;
   2131e:	f043 0301 	orr.w	r3, r3, #1
   21322:	7203      	strb	r3, [r0, #8]
	msg->hdr.params.hexdump.length = length;
   21324:	8903      	ldrh	r3, [r0, #8]
	if (length > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   21326:	2f0c      	cmp	r7, #12
	msg->hdr.params.hexdump.length = length;
   21328:	f365 038f 	bfi	r3, r5, #2, #14
   2132c:	8103      	strh	r3, [r0, #8]
	if (length > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   2132e:	f100 0814 	add.w	r8, r0, #20
   21332:	d916      	bls.n	21362 <log_msg_hexdump_create+0x6a>
   21334:	6833      	ldr	r3, [r6, #0]
		msg->hdr.params.generic.ext = 1;
   21336:	7a02      	ldrb	r2, [r0, #8]
   21338:	6183      	str	r3, [r0, #24]
   2133a:	6873      	ldr	r3, [r6, #4]
   2133c:	61c3      	str	r3, [r0, #28]
   2133e:	f042 0202 	orr.w	r2, r2, #2
		msg->payload.ext.next = NULL;
   21342:	2300      	movs	r3, #0
   21344:	6143      	str	r3, [r0, #20]
		msg->hdr.params.generic.ext = 1;
   21346:	7202      	strb	r2, [r0, #8]
		data += LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   21348:	3608      	adds	r6, #8
		length -= LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   2134a:	3d08      	subs	r5, #8
	while (length > 0) {
   2134c:	4699      	mov	r9, r3
   2134e:	b18d      	cbz	r5, 21374 <log_msg_hexdump_create+0x7c>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
   21350:	f7e3 fea2 	bl	5098 <log_msg_chunk_alloc>
		if (cont == NULL) {
   21354:	4607      	mov	r7, r0
   21356:	b980      	cbnz	r0, 2137a <log_msg_hexdump_create+0x82>
			msg_free(msg);
   21358:	4620      	mov	r0, r4
   2135a:	f7e3 feaf 	bl	50bc <msg_free>
			return NULL;
   2135e:	463c      	mov	r4, r7
   21360:	e008      	b.n	21374 <log_msg_hexdump_create+0x7c>
   21362:	462a      	mov	r2, r5
   21364:	4631      	mov	r1, r6
   21366:	4640      	mov	r0, r8
   21368:	f7e0 fc40 	bl	1bec <memcpy>
		msg->hdr.params.generic.ext = 0;
   2136c:	7a23      	ldrb	r3, [r4, #8]
   2136e:	f36f 0341 	bfc	r3, #1, #1
   21372:	7223      	strb	r3, [r4, #8]
}
   21374:	4620      	mov	r0, r4
   21376:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		chunk_length = (length > HEXDUMP_BYTES_CONT_MSG) ?
   2137a:	2d1c      	cmp	r5, #28
   2137c:	462f      	mov	r7, r5
   2137e:	bf28      	it	cs
   21380:	271c      	movcs	r7, #28
		*prev_cont = cont;
   21382:	f8c8 0000 	str.w	r0, [r8]
   21386:	4631      	mov	r1, r6
		cont->next = NULL;
   21388:	f8c0 9000 	str.w	r9, [r0]
		prev_cont = &cont->next;
   2138c:	4680      	mov	r8, r0
   2138e:	463a      	mov	r2, r7
   21390:	3004      	adds	r0, #4
   21392:	f7e0 fc2b 	bl	1bec <memcpy>
		data += chunk_length;
   21396:	443e      	add	r6, r7
		length -= chunk_length;
   21398:	1bed      	subs	r5, r5, r7
   2139a:	e7d8      	b.n	2134e <log_msg_hexdump_create+0x56>

0002139c <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      u8_t *data,
			      size_t *length,
			      size_t offset)
{
   2139c:	b513      	push	{r0, r1, r4, lr}
	log_msg_hexdump_data_op(msg, data, length, offset, false);
   2139e:	2400      	movs	r4, #0
   213a0:	9400      	str	r4, [sp, #0]
   213a2:	f7ff fec1 	bl	21128 <log_msg_hexdump_data_op>
}
   213a6:	b002      	add	sp, #8
   213a8:	bd10      	pop	{r4, pc}

000213aa <buffer_write>:
{
   213aa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   213ac:	4606      	mov	r6, r0
   213ae:	460d      	mov	r5, r1
   213b0:	4614      	mov	r4, r2
   213b2:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
   213b4:	4621      	mov	r1, r4
   213b6:	4628      	mov	r0, r5
   213b8:	463a      	mov	r2, r7
   213ba:	47b0      	blx	r6
	} while (len != 0);
   213bc:	1a24      	subs	r4, r4, r0
		buf += processed;
   213be:	4405      	add	r5, r0
	} while (len != 0);
   213c0:	d1f8      	bne.n	213b4 <buffer_write+0xa>
}
   213c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000213c4 <std_print>:
{
   213c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   213c8:	b08e      	sub	sp, #56	; 0x38
   213ca:	af0e      	add	r7, sp, #56	; 0x38
   213cc:	4681      	mov	r9, r0
   213ce:	460d      	mov	r5, r1
	const char *str = log_msg_str_get(msg);
   213d0:	f7ff ff3c 	bl	2124c <log_msg_str_get>
   213d4:	4606      	mov	r6, r0
	u32_t nargs = log_msg_nargs_get(msg);
   213d6:	4648      	mov	r0, r9
   213d8:	f7ff ff05 	bl	211e6 <log_msg_nargs_get>
	u32_t *args = alloca(sizeof(u32_t)*nargs);
   213dc:	0083      	lsls	r3, r0, #2
   213de:	3307      	adds	r3, #7
   213e0:	f023 0307 	bic.w	r3, r3, #7
   213e4:	ebad 0d03 	sub.w	sp, sp, r3
	u32_t nargs = log_msg_nargs_get(msg);
   213e8:	4682      	mov	sl, r0
	u32_t *args = alloca(sizeof(u32_t)*nargs);
   213ea:	ac0e      	add	r4, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
   213ec:	f04f 0800 	mov.w	r8, #0
   213f0:	45d0      	cmp	r8, sl
   213f2:	d116      	bne.n	21422 <std_print+0x5e>
	switch (log_msg_nargs_get(msg)) {
   213f4:	4648      	mov	r0, r9
   213f6:	f7ff fef6 	bl	211e6 <log_msg_nargs_get>
   213fa:	280f      	cmp	r0, #15
   213fc:	d81e      	bhi.n	2143c <std_print+0x78>
   213fe:	e8df f010 	tbh	[pc, r0, lsl #1]
   21402:	0019      	.short	0x0019
   21404:	00260020 	.word	0x00260020
   21408:	0036002d 	.word	0x0036002d
   2140c:	004e0041 	.word	0x004e0041
   21410:	006e005d 	.word	0x006e005d
   21414:	00960081 	.word	0x00960081
   21418:	00c600ad 	.word	0x00c600ad
   2141c:	00fe00e1 	.word	0x00fe00e1
   21420:	011d      	.short	0x011d
		args[i] = log_msg_arg_get(msg, i);
   21422:	4641      	mov	r1, r8
   21424:	4648      	mov	r0, r9
   21426:	f7ff fee1 	bl	211ec <log_msg_arg_get>
   2142a:	f844 0028 	str.w	r0, [r4, r8, lsl #2]
	for (i = 0; i < nargs; i++) {
   2142e:	f108 0801 	add.w	r8, r8, #1
   21432:	e7dd      	b.n	213f0 <std_print+0x2c>
		print_formatted(log_output, str);
   21434:	4631      	mov	r1, r6
   21436:	4628      	mov	r0, r5
   21438:	f7e3 fe82 	bl	5140 <print_formatted>
}
   2143c:	46bd      	mov	sp, r7
   2143e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, str, args[0]);
   21442:	6822      	ldr	r2, [r4, #0]
   21444:	4631      	mov	r1, r6
   21446:	4628      	mov	r0, r5
   21448:	f7e3 fe7a 	bl	5140 <print_formatted>
		break;
   2144c:	e7f6      	b.n	2143c <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1]);
   2144e:	e9d4 2300 	ldrd	r2, r3, [r4]
   21452:	4631      	mov	r1, r6
   21454:	4628      	mov	r0, r5
   21456:	f7e3 fe73 	bl	5140 <print_formatted>
		break;
   2145a:	e7ef      	b.n	2143c <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2]);
   2145c:	68a3      	ldr	r3, [r4, #8]
   2145e:	9300      	str	r3, [sp, #0]
   21460:	e9d4 2300 	ldrd	r2, r3, [r4]
   21464:	4631      	mov	r1, r6
   21466:	4628      	mov	r0, r5
   21468:	f7e3 fe6a 	bl	5140 <print_formatted>
		break;
   2146c:	e7e6      	b.n	2143c <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   2146e:	68e3      	ldr	r3, [r4, #12]
   21470:	9301      	str	r3, [sp, #4]
   21472:	68a3      	ldr	r3, [r4, #8]
   21474:	9300      	str	r3, [sp, #0]
   21476:	e9d4 2300 	ldrd	r2, r3, [r4]
   2147a:	4631      	mov	r1, r6
   2147c:	4628      	mov	r0, r5
   2147e:	f7e3 fe5f 	bl	5140 <print_formatted>
		break;
   21482:	e7db      	b.n	2143c <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   21484:	6923      	ldr	r3, [r4, #16]
   21486:	9302      	str	r3, [sp, #8]
   21488:	68e3      	ldr	r3, [r4, #12]
   2148a:	9301      	str	r3, [sp, #4]
   2148c:	68a3      	ldr	r3, [r4, #8]
   2148e:	9300      	str	r3, [sp, #0]
   21490:	e9d4 2300 	ldrd	r2, r3, [r4]
   21494:	4631      	mov	r1, r6
   21496:	4628      	mov	r0, r5
   21498:	f7e3 fe52 	bl	5140 <print_formatted>
		break;
   2149c:	e7ce      	b.n	2143c <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   2149e:	6963      	ldr	r3, [r4, #20]
   214a0:	9303      	str	r3, [sp, #12]
   214a2:	6923      	ldr	r3, [r4, #16]
   214a4:	9302      	str	r3, [sp, #8]
   214a6:	68e3      	ldr	r3, [r4, #12]
   214a8:	9301      	str	r3, [sp, #4]
   214aa:	68a3      	ldr	r3, [r4, #8]
   214ac:	9300      	str	r3, [sp, #0]
   214ae:	e9d4 2300 	ldrd	r2, r3, [r4]
   214b2:	4631      	mov	r1, r6
   214b4:	4628      	mov	r0, r5
   214b6:	f7e3 fe43 	bl	5140 <print_formatted>
		break;
   214ba:	e7bf      	b.n	2143c <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   214bc:	69a3      	ldr	r3, [r4, #24]
   214be:	9304      	str	r3, [sp, #16]
   214c0:	6963      	ldr	r3, [r4, #20]
   214c2:	9303      	str	r3, [sp, #12]
   214c4:	6923      	ldr	r3, [r4, #16]
   214c6:	9302      	str	r3, [sp, #8]
   214c8:	68e3      	ldr	r3, [r4, #12]
   214ca:	9301      	str	r3, [sp, #4]
   214cc:	68a3      	ldr	r3, [r4, #8]
   214ce:	9300      	str	r3, [sp, #0]
   214d0:	e9d4 2300 	ldrd	r2, r3, [r4]
   214d4:	4631      	mov	r1, r6
   214d6:	4628      	mov	r0, r5
   214d8:	f7e3 fe32 	bl	5140 <print_formatted>
		break;
   214dc:	e7ae      	b.n	2143c <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   214de:	69e3      	ldr	r3, [r4, #28]
   214e0:	9305      	str	r3, [sp, #20]
   214e2:	69a3      	ldr	r3, [r4, #24]
   214e4:	9304      	str	r3, [sp, #16]
   214e6:	6963      	ldr	r3, [r4, #20]
   214e8:	9303      	str	r3, [sp, #12]
   214ea:	6923      	ldr	r3, [r4, #16]
   214ec:	9302      	str	r3, [sp, #8]
   214ee:	68e3      	ldr	r3, [r4, #12]
   214f0:	9301      	str	r3, [sp, #4]
   214f2:	68a3      	ldr	r3, [r4, #8]
   214f4:	9300      	str	r3, [sp, #0]
   214f6:	e9d4 2300 	ldrd	r2, r3, [r4]
   214fa:	4631      	mov	r1, r6
   214fc:	4628      	mov	r0, r5
   214fe:	f7e3 fe1f 	bl	5140 <print_formatted>
		break;
   21502:	e79b      	b.n	2143c <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   21504:	6a23      	ldr	r3, [r4, #32]
   21506:	9306      	str	r3, [sp, #24]
   21508:	69e3      	ldr	r3, [r4, #28]
   2150a:	9305      	str	r3, [sp, #20]
   2150c:	69a3      	ldr	r3, [r4, #24]
   2150e:	9304      	str	r3, [sp, #16]
   21510:	6963      	ldr	r3, [r4, #20]
   21512:	9303      	str	r3, [sp, #12]
   21514:	6923      	ldr	r3, [r4, #16]
   21516:	9302      	str	r3, [sp, #8]
   21518:	68e3      	ldr	r3, [r4, #12]
   2151a:	9301      	str	r3, [sp, #4]
   2151c:	68a3      	ldr	r3, [r4, #8]
   2151e:	9300      	str	r3, [sp, #0]
   21520:	e9d4 2300 	ldrd	r2, r3, [r4]
   21524:	4631      	mov	r1, r6
   21526:	4628      	mov	r0, r5
   21528:	f7e3 fe0a 	bl	5140 <print_formatted>
		break;
   2152c:	e786      	b.n	2143c <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   2152e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   21530:	9307      	str	r3, [sp, #28]
   21532:	6a23      	ldr	r3, [r4, #32]
   21534:	9306      	str	r3, [sp, #24]
   21536:	69e3      	ldr	r3, [r4, #28]
   21538:	9305      	str	r3, [sp, #20]
   2153a:	69a3      	ldr	r3, [r4, #24]
   2153c:	9304      	str	r3, [sp, #16]
   2153e:	6963      	ldr	r3, [r4, #20]
   21540:	9303      	str	r3, [sp, #12]
   21542:	6923      	ldr	r3, [r4, #16]
   21544:	9302      	str	r3, [sp, #8]
   21546:	68e3      	ldr	r3, [r4, #12]
   21548:	9301      	str	r3, [sp, #4]
   2154a:	68a3      	ldr	r3, [r4, #8]
   2154c:	9300      	str	r3, [sp, #0]
   2154e:	e9d4 2300 	ldrd	r2, r3, [r4]
   21552:	4631      	mov	r1, r6
   21554:	4628      	mov	r0, r5
   21556:	f7e3 fdf3 	bl	5140 <print_formatted>
		break;
   2155a:	e76f      	b.n	2143c <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   2155c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   2155e:	9308      	str	r3, [sp, #32]
   21560:	6a63      	ldr	r3, [r4, #36]	; 0x24
   21562:	9307      	str	r3, [sp, #28]
   21564:	6a23      	ldr	r3, [r4, #32]
   21566:	9306      	str	r3, [sp, #24]
   21568:	69e3      	ldr	r3, [r4, #28]
   2156a:	9305      	str	r3, [sp, #20]
   2156c:	69a3      	ldr	r3, [r4, #24]
   2156e:	9304      	str	r3, [sp, #16]
   21570:	6963      	ldr	r3, [r4, #20]
   21572:	9303      	str	r3, [sp, #12]
   21574:	6923      	ldr	r3, [r4, #16]
   21576:	9302      	str	r3, [sp, #8]
   21578:	68e3      	ldr	r3, [r4, #12]
   2157a:	9301      	str	r3, [sp, #4]
   2157c:	68a3      	ldr	r3, [r4, #8]
   2157e:	9300      	str	r3, [sp, #0]
   21580:	e9d4 2300 	ldrd	r2, r3, [r4]
   21584:	4631      	mov	r1, r6
   21586:	4628      	mov	r0, r5
   21588:	f7e3 fdda 	bl	5140 <print_formatted>
		break;
   2158c:	e756      	b.n	2143c <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   2158e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   21590:	9309      	str	r3, [sp, #36]	; 0x24
   21592:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   21594:	9308      	str	r3, [sp, #32]
   21596:	6a63      	ldr	r3, [r4, #36]	; 0x24
   21598:	9307      	str	r3, [sp, #28]
   2159a:	6a23      	ldr	r3, [r4, #32]
   2159c:	9306      	str	r3, [sp, #24]
   2159e:	69e3      	ldr	r3, [r4, #28]
   215a0:	9305      	str	r3, [sp, #20]
   215a2:	69a3      	ldr	r3, [r4, #24]
   215a4:	9304      	str	r3, [sp, #16]
   215a6:	6963      	ldr	r3, [r4, #20]
   215a8:	9303      	str	r3, [sp, #12]
   215aa:	6923      	ldr	r3, [r4, #16]
   215ac:	9302      	str	r3, [sp, #8]
   215ae:	68e3      	ldr	r3, [r4, #12]
   215b0:	9301      	str	r3, [sp, #4]
   215b2:	68a3      	ldr	r3, [r4, #8]
   215b4:	9300      	str	r3, [sp, #0]
   215b6:	e9d4 2300 	ldrd	r2, r3, [r4]
   215ba:	4631      	mov	r1, r6
   215bc:	4628      	mov	r0, r5
   215be:	f7e3 fdbf 	bl	5140 <print_formatted>
		break;
   215c2:	e73b      	b.n	2143c <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   215c4:	6b23      	ldr	r3, [r4, #48]	; 0x30
   215c6:	930a      	str	r3, [sp, #40]	; 0x28
   215c8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   215ca:	9309      	str	r3, [sp, #36]	; 0x24
   215cc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   215ce:	9308      	str	r3, [sp, #32]
   215d0:	6a63      	ldr	r3, [r4, #36]	; 0x24
   215d2:	9307      	str	r3, [sp, #28]
   215d4:	6a23      	ldr	r3, [r4, #32]
   215d6:	9306      	str	r3, [sp, #24]
   215d8:	69e3      	ldr	r3, [r4, #28]
   215da:	9305      	str	r3, [sp, #20]
   215dc:	69a3      	ldr	r3, [r4, #24]
   215de:	9304      	str	r3, [sp, #16]
   215e0:	6963      	ldr	r3, [r4, #20]
   215e2:	9303      	str	r3, [sp, #12]
   215e4:	6923      	ldr	r3, [r4, #16]
   215e6:	9302      	str	r3, [sp, #8]
   215e8:	68e3      	ldr	r3, [r4, #12]
   215ea:	9301      	str	r3, [sp, #4]
   215ec:	68a3      	ldr	r3, [r4, #8]
   215ee:	9300      	str	r3, [sp, #0]
   215f0:	e9d4 2300 	ldrd	r2, r3, [r4]
   215f4:	4631      	mov	r1, r6
   215f6:	4628      	mov	r0, r5
   215f8:	f7e3 fda2 	bl	5140 <print_formatted>
		break;
   215fc:	e71e      	b.n	2143c <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   215fe:	6b63      	ldr	r3, [r4, #52]	; 0x34
   21600:	930b      	str	r3, [sp, #44]	; 0x2c
   21602:	6b23      	ldr	r3, [r4, #48]	; 0x30
   21604:	930a      	str	r3, [sp, #40]	; 0x28
   21606:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   21608:	9309      	str	r3, [sp, #36]	; 0x24
   2160a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   2160c:	9308      	str	r3, [sp, #32]
   2160e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   21610:	9307      	str	r3, [sp, #28]
   21612:	6a23      	ldr	r3, [r4, #32]
   21614:	9306      	str	r3, [sp, #24]
   21616:	69e3      	ldr	r3, [r4, #28]
   21618:	9305      	str	r3, [sp, #20]
   2161a:	69a3      	ldr	r3, [r4, #24]
   2161c:	9304      	str	r3, [sp, #16]
   2161e:	6963      	ldr	r3, [r4, #20]
   21620:	9303      	str	r3, [sp, #12]
   21622:	6923      	ldr	r3, [r4, #16]
   21624:	9302      	str	r3, [sp, #8]
   21626:	68e3      	ldr	r3, [r4, #12]
   21628:	9301      	str	r3, [sp, #4]
   2162a:	68a3      	ldr	r3, [r4, #8]
   2162c:	9300      	str	r3, [sp, #0]
   2162e:	e9d4 2300 	ldrd	r2, r3, [r4]
   21632:	4631      	mov	r1, r6
   21634:	4628      	mov	r0, r5
   21636:	f7e3 fd83 	bl	5140 <print_formatted>
		break;
   2163a:	e6ff      	b.n	2143c <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   2163c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   2163e:	930c      	str	r3, [sp, #48]	; 0x30
   21640:	6b63      	ldr	r3, [r4, #52]	; 0x34
   21642:	930b      	str	r3, [sp, #44]	; 0x2c
   21644:	6b23      	ldr	r3, [r4, #48]	; 0x30
   21646:	930a      	str	r3, [sp, #40]	; 0x28
   21648:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   2164a:	9309      	str	r3, [sp, #36]	; 0x24
   2164c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   2164e:	9308      	str	r3, [sp, #32]
   21650:	6a63      	ldr	r3, [r4, #36]	; 0x24
   21652:	9307      	str	r3, [sp, #28]
   21654:	6a23      	ldr	r3, [r4, #32]
   21656:	9306      	str	r3, [sp, #24]
   21658:	69e3      	ldr	r3, [r4, #28]
   2165a:	9305      	str	r3, [sp, #20]
   2165c:	69a3      	ldr	r3, [r4, #24]
   2165e:	9304      	str	r3, [sp, #16]
   21660:	6963      	ldr	r3, [r4, #20]
   21662:	9303      	str	r3, [sp, #12]
   21664:	6923      	ldr	r3, [r4, #16]
   21666:	9302      	str	r3, [sp, #8]
   21668:	68e3      	ldr	r3, [r4, #12]
   2166a:	9301      	str	r3, [sp, #4]
   2166c:	68a3      	ldr	r3, [r4, #8]
   2166e:	9300      	str	r3, [sp, #0]
   21670:	e9d4 2300 	ldrd	r2, r3, [r4]
   21674:	4631      	mov	r1, r6
   21676:	4628      	mov	r0, r5
   21678:	f7e3 fd62 	bl	5140 <print_formatted>
}
   2167c:	e6de      	b.n	2143c <std_print+0x78>

0002167e <log_output_flush>:
		     log_output->control_block->offset,
   2167e:	6842      	ldr	r2, [r0, #4]
	buffer_write(log_output->func, log_output->buf,
   21680:	6881      	ldr	r1, [r0, #8]
{
   21682:	b510      	push	{r4, lr}
   21684:	4604      	mov	r4, r0
	buffer_write(log_output->func, log_output->buf,
   21686:	e9d2 2300 	ldrd	r2, r3, [r2]
   2168a:	6800      	ldr	r0, [r0, #0]
   2168c:	f7ff fe8d 	bl	213aa <buffer_write>
	log_output->control_block->offset = 0;
   21690:	6863      	ldr	r3, [r4, #4]
   21692:	2200      	movs	r2, #0
   21694:	601a      	str	r2, [r3, #0]
}
   21696:	bd10      	pop	{r4, pc}

00021698 <out_func>:
{
   21698:	b538      	push	{r3, r4, r5, lr}
	if (out_ctx->control_block->offset == out_ctx->size) {
   2169a:	684b      	ldr	r3, [r1, #4]
   2169c:	681a      	ldr	r2, [r3, #0]
   2169e:	68cb      	ldr	r3, [r1, #12]
   216a0:	429a      	cmp	r2, r3
{
   216a2:	4605      	mov	r5, r0
   216a4:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
   216a6:	d102      	bne.n	216ae <out_func+0x16>
		log_output_flush(out_ctx);
   216a8:	4608      	mov	r0, r1
   216aa:	f7ff ffe8 	bl	2167e <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   216ae:	6863      	ldr	r3, [r4, #4]
   216b0:	f3bf 8f5b 	dmb	ish
   216b4:	e853 2f00 	ldrex	r2, [r3]
   216b8:	1c51      	adds	r1, r2, #1
   216ba:	e843 1000 	strex	r0, r1, [r3]
   216be:	2800      	cmp	r0, #0
   216c0:	d1f8      	bne.n	216b4 <out_func+0x1c>
   216c2:	f3bf 8f5b 	dmb	ish
	out_ctx->buf[idx] = (u8_t)c;
   216c6:	68a3      	ldr	r3, [r4, #8]
   216c8:	549d      	strb	r5, [r3, r2]
}
   216ca:	2000      	movs	r0, #0
   216cc:	bd38      	pop	{r3, r4, r5, pc}

000216ce <read_str>:
{
   216ce:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	return bt_gatt_attr_read(conn, attr, buf, len, offset, attr->user_data,
   216d2:	68cd      	ldr	r5, [r1, #12]
{
   216d4:	4606      	mov	r6, r0
				 strlen(attr->user_data));
   216d6:	4628      	mov	r0, r5
{
   216d8:	4698      	mov	r8, r3
   216da:	460c      	mov	r4, r1
   216dc:	4617      	mov	r7, r2
				 strlen(attr->user_data));
   216de:	f7e0 fae3 	bl	1ca8 <strlen>
	return bt_gatt_attr_read(conn, attr, buf, len, offset, attr->user_data,
   216e2:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   216e6:	9300      	str	r3, [sp, #0]
   216e8:	b280      	uxth	r0, r0
   216ea:	e9cd 5001 	strd	r5, r0, [sp, #4]
   216ee:	4643      	mov	r3, r8
   216f0:	463a      	mov	r2, r7
   216f2:	4621      	mov	r1, r4
   216f4:	4630      	mov	r0, r6
   216f6:	f001 fed3 	bl	234a0 <bt_gatt_attr_read>
}
   216fa:	b004      	add	sp, #16
   216fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00021700 <bas_init>:
static int bas_init(struct device *dev)
{
	ARG_UNUSED(dev);

	return 0;
}
   21700:	2000      	movs	r0, #0
   21702:	4770      	bx	lr

00021704 <flash_write_protection_set>:
	return api->write_protection(dev, enable);
   21704:	6843      	ldr	r3, [r0, #4]
   21706:	68db      	ldr	r3, [r3, #12]
   21708:	4718      	bx	r3

0002170a <nvs_flash_rd>:
{
   2170a:	b470      	push	{r4, r5, r6}
	offset += addr & ADDR_OFFS_MASK;
   2170c:	6806      	ldr	r6, [r0, #0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   2170e:	8984      	ldrh	r4, [r0, #12]
	rc = flash_read(fs->flash_device, offset, data, len);
   21710:	6a80      	ldr	r0, [r0, #40]	; 0x28
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   21712:	0c0d      	lsrs	r5, r1, #16
	offset += addr & ADDR_OFFS_MASK;
   21714:	fa16 f181 	uxtah	r1, r6, r1
   21718:	fb05 1104 	mla	r1, r5, r4, r1
	return api->read(dev, offset, data, len);
   2171c:	6844      	ldr	r4, [r0, #4]
   2171e:	6824      	ldr	r4, [r4, #0]
   21720:	46a4      	mov	ip, r4
}
   21722:	bc70      	pop	{r4, r5, r6}
   21724:	4760      	bx	ip

00021726 <nvs_flash_block_cmp>:
{
   21726:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   2172a:	7c05      	ldrb	r5, [r0, #16]
   2172c:	426d      	negs	r5, r5
{
   2172e:	b089      	sub	sp, #36	; 0x24
   21730:	4681      	mov	r9, r0
   21732:	460f      	mov	r7, r1
   21734:	4690      	mov	r8, r2
   21736:	461c      	mov	r4, r3
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   21738:	f005 0520 	and.w	r5, r5, #32
	while (len) {
   2173c:	b91c      	cbnz	r4, 21746 <nvs_flash_block_cmp+0x20>
	return 0;
   2173e:	4620      	mov	r0, r4
}
   21740:	b009      	add	sp, #36	; 0x24
   21742:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		bytes_to_cmp = MIN(block_size, len);
   21746:	42ac      	cmp	r4, r5
   21748:	4626      	mov	r6, r4
   2174a:	bf28      	it	cs
   2174c:	462e      	movcs	r6, r5
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_cmp);
   2174e:	4633      	mov	r3, r6
   21750:	466a      	mov	r2, sp
   21752:	4639      	mov	r1, r7
   21754:	4648      	mov	r0, r9
   21756:	f7ff ffd8 	bl	2170a <nvs_flash_rd>
		if (rc) {
   2175a:	2800      	cmp	r0, #0
   2175c:	d1f0      	bne.n	21740 <nvs_flash_block_cmp+0x1a>
		rc = memcmp(data8, buf, bytes_to_cmp);
   2175e:	4632      	mov	r2, r6
   21760:	4669      	mov	r1, sp
   21762:	4640      	mov	r0, r8
   21764:	f7e0 fa34 	bl	1bd0 <memcmp>
		if (rc) {
   21768:	b918      	cbnz	r0, 21772 <nvs_flash_block_cmp+0x4c>
		len -= bytes_to_cmp;
   2176a:	1ba4      	subs	r4, r4, r6
		addr += bytes_to_cmp;
   2176c:	4437      	add	r7, r6
		data8 += bytes_to_cmp;
   2176e:	44b0      	add	r8, r6
   21770:	e7e4      	b.n	2173c <nvs_flash_block_cmp+0x16>
			return 1;
   21772:	2001      	movs	r0, #1
   21774:	e7e4      	b.n	21740 <nvs_flash_block_cmp+0x1a>

00021776 <nvs_ate_crc8_check>:
{
   21776:	b510      	push	{r4, lr}
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   21778:	4601      	mov	r1, r0
{
   2177a:	4604      	mov	r4, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   2177c:	2207      	movs	r2, #7
   2177e:	20ff      	movs	r0, #255	; 0xff
   21780:	f7e2 ffa8 	bl	46d4 <crc8_ccitt>
	if (crc8 == entry->crc8) {
   21784:	79e3      	ldrb	r3, [r4, #7]
}
   21786:	1a18      	subs	r0, r3, r0
   21788:	bf18      	it	ne
   2178a:	2001      	movne	r0, #1
   2178c:	bd10      	pop	{r4, pc}

0002178e <nvs_ate_crc8_update>:
{
   2178e:	b510      	push	{r4, lr}
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   21790:	4601      	mov	r1, r0
{
   21792:	4604      	mov	r4, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   21794:	2207      	movs	r2, #7
   21796:	20ff      	movs	r0, #255	; 0xff
   21798:	f7e2 ff9c 	bl	46d4 <crc8_ccitt>
	entry->crc8 = crc8;
   2179c:	71e0      	strb	r0, [r4, #7]
}
   2179e:	bd10      	pop	{r4, pc}

000217a0 <nvs_al_size.isra.1>:
	if (fs->write_block_size <= 1U) {
   217a0:	2801      	cmp	r0, #1
	return (len + (fs->write_block_size - 1U)) & ~(fs->write_block_size - 1U);
   217a2:	bf81      	itttt	hi
   217a4:	f100 33ff 	addhi.w	r3, r0, #4294967295	; 0xffffffff
   217a8:	18c9      	addhi	r1, r1, r3
   217aa:	4240      	neghi	r0, r0
   217ac:	4001      	andhi	r1, r0
}
   217ae:	4608      	mov	r0, r1
   217b0:	4770      	bx	lr

000217b2 <nvs_sector_advance.isra.2>:
	*addr += (1 << ADDR_SECT_SHIFT);
   217b2:	680b      	ldr	r3, [r1, #0]
   217b4:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
	if ((*addr >> ADDR_SECT_SHIFT) == fs->sector_count) {
   217b8:	0c1a      	lsrs	r2, r3, #16
   217ba:	4282      	cmp	r2, r0
		*addr -= (fs->sector_count << ADDR_SECT_SHIFT);
   217bc:	bf08      	it	eq
   217be:	eba3 4302 	subeq.w	r3, r3, r2, lsl #16
   217c2:	600b      	str	r3, [r1, #0]
}
   217c4:	4770      	bx	lr

000217c6 <nvs_flash_cmp_const.constprop.5>:
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   217c6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   217ca:	7c04      	ldrb	r4, [r0, #16]
   217cc:	4264      	negs	r4, r4
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   217ce:	b088      	sub	sp, #32
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   217d0:	f004 0420 	and.w	r4, r4, #32
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   217d4:	4680      	mov	r8, r0
   217d6:	460e      	mov	r6, r1
   217d8:	4615      	mov	r5, r2
	(void)memset(cmp, value, block_size);
   217da:	2320      	movs	r3, #32
   217dc:	4622      	mov	r2, r4
   217de:	21ff      	movs	r1, #255	; 0xff
   217e0:	4668      	mov	r0, sp
   217e2:	f7e0 fa2c 	bl	1c3e <__memset_chk>
	while (len) {
   217e6:	b91d      	cbnz	r5, 217f0 <nvs_flash_cmp_const.constprop.5+0x2a>
	return 0;
   217e8:	4628      	mov	r0, r5
}
   217ea:	b008      	add	sp, #32
   217ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		bytes_to_cmp = MIN(block_size, len);
   217f0:	42ac      	cmp	r4, r5
   217f2:	4627      	mov	r7, r4
   217f4:	bf28      	it	cs
   217f6:	462f      	movcs	r7, r5
		rc = nvs_flash_block_cmp(fs, addr, cmp, bytes_to_cmp);
   217f8:	463b      	mov	r3, r7
   217fa:	466a      	mov	r2, sp
   217fc:	4631      	mov	r1, r6
   217fe:	4640      	mov	r0, r8
   21800:	f7ff ff91 	bl	21726 <nvs_flash_block_cmp>
		if (rc) {
   21804:	2800      	cmp	r0, #0
   21806:	d1f0      	bne.n	217ea <nvs_flash_cmp_const.constprop.5+0x24>
		len -= bytes_to_cmp;
   21808:	1bed      	subs	r5, r5, r7
		addr += bytes_to_cmp;
   2180a:	443e      	add	r6, r7
   2180c:	e7eb      	b.n	217e6 <nvs_flash_cmp_const.constprop.5+0x20>

0002180e <nvs_flash_al_wrt.part.3>:
static int nvs_flash_al_wrt(struct nvs_fs *fs, u32_t addr, const void *data,
   2180e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   21812:	4607      	mov	r7, r0
   21814:	b088      	sub	sp, #32
   21816:	460d      	mov	r5, r1
	offset = fs->offset;
   21818:	f8d0 a000 	ldr.w	sl, [r0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   2181c:	8986      	ldrh	r6, [r0, #12]
	rc = flash_write_protection_set(fs->flash_device, 0);
   2181e:	6a80      	ldr	r0, [r0, #40]	; 0x28
   21820:	2100      	movs	r1, #0
static int nvs_flash_al_wrt(struct nvs_fs *fs, u32_t addr, const void *data,
   21822:	4690      	mov	r8, r2
   21824:	461c      	mov	r4, r3
	rc = flash_write_protection_set(fs->flash_device, 0);
   21826:	f7ff ff6d 	bl	21704 <flash_write_protection_set>
	if (rc) {
   2182a:	bb88      	cbnz	r0, 21890 <nvs_flash_al_wrt.part.3+0x82>
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   2182c:	ea4f 4915 	mov.w	r9, r5, lsr #16
	offset += addr & ADDR_OFFS_MASK;
   21830:	fa1a f585 	uxtah	r5, sl, r5
   21834:	fb06 5909 	mla	r9, r6, r9, r5
	blen = len & ~(fs->write_block_size - 1U);
   21838:	7c3d      	ldrb	r5, [r7, #16]
   2183a:	426d      	negs	r5, r5
	if (blen > 0) {
   2183c:	4025      	ands	r5, r4
   2183e:	d00b      	beq.n	21858 <nvs_flash_al_wrt.part.3+0x4a>
   21840:	6ab8      	ldr	r0, [r7, #40]	; 0x28
	return api->write(dev, offset, data, len);
   21842:	6843      	ldr	r3, [r0, #4]
   21844:	4642      	mov	r2, r8
   21846:	685e      	ldr	r6, [r3, #4]
   21848:	4649      	mov	r1, r9
   2184a:	462b      	mov	r3, r5
   2184c:	47b0      	blx	r6
		if (rc) {
   2184e:	4606      	mov	r6, r0
   21850:	b9c8      	cbnz	r0, 21886 <nvs_flash_al_wrt.part.3+0x78>
		len -= blen;
   21852:	1b64      	subs	r4, r4, r5
		offset += blen;
   21854:	44a9      	add	r9, r5
		data8 += blen;
   21856:	44a8      	add	r8, r5
	if (len) {
   21858:	b1ec      	cbz	r4, 21896 <nvs_flash_al_wrt.part.3+0x88>
		memcpy(buf, data8, len);
   2185a:	2320      	movs	r3, #32
   2185c:	4622      	mov	r2, r4
   2185e:	4641      	mov	r1, r8
   21860:	4668      	mov	r0, sp
   21862:	6abd      	ldr	r5, [r7, #40]	; 0x28
   21864:	f7e0 f9d0 	bl	1c08 <__memcpy_chk>
		(void)memset(buf + len, 0xff, fs->write_block_size - len);
   21868:	7c3e      	ldrb	r6, [r7, #16]
__ssp_bos_icheck3(memset, void *, int)
   2186a:	21ff      	movs	r1, #255	; 0xff
   2186c:	1b32      	subs	r2, r6, r4
   2186e:	eb0d 0004 	add.w	r0, sp, r4
   21872:	f7e0 f9dc 	bl	1c2e <memset>
   21876:	686b      	ldr	r3, [r5, #4]
   21878:	466a      	mov	r2, sp
   2187a:	685c      	ldr	r4, [r3, #4]
   2187c:	4649      	mov	r1, r9
   2187e:	4633      	mov	r3, r6
   21880:	4628      	mov	r0, r5
   21882:	47a0      	blx	r4
   21884:	4606      	mov	r6, r0
	(void) flash_write_protection_set(fs->flash_device, 1);
   21886:	2101      	movs	r1, #1
   21888:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   2188a:	f7ff ff3b 	bl	21704 <flash_write_protection_set>
	return rc;
   2188e:	4630      	mov	r0, r6
}
   21890:	b008      	add	sp, #32
   21892:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
   21896:	4626      	mov	r6, r4
   21898:	e7f5      	b.n	21886 <nvs_flash_al_wrt.part.3+0x78>

0002189a <nvs_flash_ate_wrt>:
{
   2189a:	b510      	push	{r4, lr}
   2189c:	2308      	movs	r3, #8
   2189e:	460a      	mov	r2, r1
   218a0:	6841      	ldr	r1, [r0, #4]
   218a2:	4604      	mov	r4, r0
   218a4:	f7ff ffb3 	bl	2180e <nvs_flash_al_wrt.part.3>
	fs->ate_wra -= nvs_al_size(fs, sizeof(struct nvs_ate));
   218a8:	2108      	movs	r1, #8
   218aa:	4602      	mov	r2, r0
   218ac:	7c20      	ldrb	r0, [r4, #16]
   218ae:	f7ff ff77 	bl	217a0 <nvs_al_size.isra.1>
   218b2:	6863      	ldr	r3, [r4, #4]
   218b4:	1a18      	subs	r0, r3, r0
   218b6:	6060      	str	r0, [r4, #4]
}
   218b8:	4610      	mov	r0, r2
   218ba:	bd10      	pop	{r4, pc}

000218bc <nvs_delete>:
	return nvs_write(fs, id, NULL, 0);
   218bc:	2300      	movs	r3, #0
   218be:	461a      	mov	r2, r3
   218c0:	f7e4 ba1a 	b.w	5cf8 <nvs_write>

000218c4 <nvs_read>:

ssize_t nvs_read(struct nvs_fs *fs, u16_t id, void *data, size_t len)
{
   218c4:	b513      	push	{r0, r1, r4, lr}
	int rc;

	rc = nvs_read_hist(fs, id, data, len, 0);
   218c6:	2400      	movs	r4, #0
   218c8:	9400      	str	r4, [sp, #0]
   218ca:	f7e4 fafb 	bl	5ec4 <nvs_read_hist>
	return rc;
}
   218ce:	b002      	add	sp, #8
   218d0:	bd10      	pop	{r4, pc}

000218d2 <get_sectors_cb>:
{
   218d2:	b570      	push	{r4, r5, r6, lr}
	if (info->start_offset < data->area_off) {
   218d4:	6802      	ldr	r2, [r0, #0]
   218d6:	684c      	ldr	r4, [r1, #4]
   218d8:	42a2      	cmp	r2, r4
   218da:	d316      	bcc.n	2190a <get_sectors_cb+0x38>
	} else if (info->start_offset >= data->area_off + data->area_len) {
   218dc:	688b      	ldr	r3, [r1, #8]
   218de:	4423      	add	r3, r4
   218e0:	429a      	cmp	r2, r3
   218e2:	d206      	bcs.n	218f2 <get_sectors_cb+0x20>
	} else if (data->ret_idx >= data->ret_len) {
   218e4:	e9d1 3504 	ldrd	r3, r5, [r1, #16]
   218e8:	42ab      	cmp	r3, r5
   218ea:	d304      	bcc.n	218f6 <get_sectors_cb+0x24>
		data->status = -ENOMEM;
   218ec:	f06f 030b 	mvn.w	r3, #11
   218f0:	618b      	str	r3, [r1, #24]
		*bail_value = false;
   218f2:	2000      	movs	r0, #0
   218f4:	e00a      	b.n	2190c <get_sectors_cb+0x3a>
	ret[data->ret_idx].fs_off = info->start_offset - data->area_off;
   218f6:	68cd      	ldr	r5, [r1, #12]
   218f8:	1b12      	subs	r2, r2, r4
   218fa:	eb05 06c3 	add.w	r6, r5, r3, lsl #3
   218fe:	f845 2033 	str.w	r2, [r5, r3, lsl #3]
	ret[data->ret_idx].fs_size = info->size;
   21902:	6842      	ldr	r2, [r0, #4]
   21904:	6072      	str	r2, [r6, #4]
	data->ret_idx++;
   21906:	3301      	adds	r3, #1
   21908:	610b      	str	r3, [r1, #16]
		*bail_value = true;
   2190a:	2001      	movs	r0, #1
}
   2190c:	bd70      	pop	{r4, r5, r6, pc}

0002190e <settings_delete>:
	return settings_save_one(name, NULL, 0);
   2190e:	2200      	movs	r2, #0
   21910:	4611      	mov	r1, r2
   21912:	f7e4 bb91 	b.w	6038 <settings_save_one>

00021916 <settings_name_steq>:
{
   21916:	b530      	push	{r4, r5, lr}
	if (next) {
   21918:	b10a      	cbz	r2, 2191e <settings_name_steq+0x8>
		*next = NULL;
   2191a:	2300      	movs	r3, #0
   2191c:	6013      	str	r3, [r2, #0]
	if ((!name) || (!key)) {
   2191e:	b190      	cbz	r0, 21946 <settings_name_steq+0x30>
   21920:	b151      	cbz	r1, 21938 <settings_name_steq+0x22>
   21922:	1e4d      	subs	r5, r1, #1
	while ((*key != '\0') && (*key == *name) &&
   21924:	f815 4f01 	ldrb.w	r4, [r5, #1]!
   21928:	4603      	mov	r3, r0
   2192a:	f810 1b01 	ldrb.w	r1, [r0], #1
   2192e:	b15c      	cbz	r4, 21948 <settings_name_steq+0x32>
   21930:	428c      	cmp	r4, r1
   21932:	d101      	bne.n	21938 <settings_name_steq+0x22>
	       (*name != '\0') && (*name != SETTINGS_NAME_END)) {
   21934:	2c3d      	cmp	r4, #61	; 0x3d
   21936:	d1f5      	bne.n	21924 <settings_name_steq+0xe>
	return 0;
   21938:	2000      	movs	r0, #0
   2193a:	e004      	b.n	21946 <settings_name_steq+0x30>
	if ((*name == SETTINGS_NAME_END) || (*name == '\0')) {
   2193c:	293d      	cmp	r1, #61	; 0x3d
   2193e:	d008      	beq.n	21952 <settings_name_steq+0x3c>
   21940:	fab1 f081 	clz	r0, r1
   21944:	0940      	lsrs	r0, r0, #5
}
   21946:	bd30      	pop	{r4, r5, pc}
	if (*name == SETTINGS_NAME_SEPARATOR) {
   21948:	292f      	cmp	r1, #47	; 0x2f
   2194a:	d1f7      	bne.n	2193c <settings_name_steq+0x26>
		if (next) {
   2194c:	b10a      	cbz	r2, 21952 <settings_name_steq+0x3c>
			*next = name + 1;
   2194e:	3301      	adds	r3, #1
   21950:	6013      	str	r3, [r2, #0]
		return 1;
   21952:	2001      	movs	r0, #1
   21954:	e7f7      	b.n	21946 <settings_name_steq+0x30>

00021956 <settings_name_next>:
{
   21956:	b530      	push	{r4, r5, lr}
   21958:	4603      	mov	r3, r0
	if (next) {
   2195a:	b109      	cbz	r1, 21960 <settings_name_next+0xa>
		*next = NULL;
   2195c:	2200      	movs	r2, #0
   2195e:	600a      	str	r2, [r1, #0]
	if (!name) {
   21960:	b16b      	cbz	r3, 2197e <settings_name_next+0x28>
   21962:	461a      	mov	r2, r3
   21964:	4614      	mov	r4, r2
   21966:	1ad0      	subs	r0, r2, r3
	while ((*name != '\0') && (*name != SETTINGS_NAME_END) &&
   21968:	f812 5b01 	ldrb.w	r5, [r2], #1
   2196c:	b135      	cbz	r5, 2197c <settings_name_next+0x26>
   2196e:	2d3d      	cmp	r5, #61	; 0x3d
   21970:	d004      	beq.n	2197c <settings_name_next+0x26>
   21972:	2d2f      	cmp	r5, #47	; 0x2f
   21974:	d1f6      	bne.n	21964 <settings_name_next+0xe>
		if (next) {
   21976:	b109      	cbz	r1, 2197c <settings_name_next+0x26>
			*next = name + 1;
   21978:	3401      	adds	r4, #1
   2197a:	600c      	str	r4, [r1, #0]
}
   2197c:	bd30      	pop	{r4, r5, pc}
		return 0;
   2197e:	4618      	mov	r0, r3
   21980:	e7fc      	b.n	2197c <settings_name_next+0x26>

00021982 <settings_nvs_read_fn>:
{
   21982:	b510      	push	{r4, lr}
	rc = nvs_read(rd_fn_arg->fs, rd_fn_arg->id, data, len);
   21984:	4613      	mov	r3, r2
{
   21986:	4614      	mov	r4, r2
	rc = nvs_read(rd_fn_arg->fs, rd_fn_arg->id, data, len);
   21988:	460a      	mov	r2, r1
   2198a:	8881      	ldrh	r1, [r0, #4]
   2198c:	6800      	ldr	r0, [r0, #0]
   2198e:	f7ff ff99 	bl	218c4 <nvs_read>
}
   21992:	42a0      	cmp	r0, r4
   21994:	bfa8      	it	ge
   21996:	4620      	movge	r0, r4
   21998:	bd10      	pop	{r4, pc}

0002199a <settings_nvs_save>:
{
   2199a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2199e:	b097      	sub	sp, #92	; 0x5c
   219a0:	4604      	mov	r4, r0
   219a2:	9201      	str	r2, [sp, #4]
   219a4:	469b      	mov	fp, r3
	if (!name) {
   219a6:	468a      	mov	sl, r1
   219a8:	2900      	cmp	r1, #0
   219aa:	d067      	beq.n	21a7c <settings_nvs_save+0xe2>
	delete = ((value == NULL) || (val_len == 0));
   219ac:	b1da      	cbz	r2, 219e6 <settings_nvs_save+0x4c>
   219ae:	fabb f78b 	clz	r7, fp
   219b2:	097f      	lsrs	r7, r7, #5
	name_id = cf->last_name_id + 1;
   219b4:	8ea5      	ldrh	r5, [r4, #52]	; 0x34
   219b6:	3501      	adds	r5, #1
   219b8:	b2ad      	uxth	r5, r5
	write_name_id = cf->last_name_id + 1;
   219ba:	46a8      	mov	r8, r5
		rc = nvs_read(&cf->cf_nvs, name_id, &rdname, sizeof(rdname));
   219bc:	f104 0908 	add.w	r9, r4, #8
		name_id--;
   219c0:	1e6e      	subs	r6, r5, #1
   219c2:	b2b6      	uxth	r6, r6
		if (name_id == NVS_NAMECNT_ID) {
   219c4:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
   219c8:	d02e      	beq.n	21a28 <settings_nvs_save+0x8e>
		rc = nvs_read(&cf->cf_nvs, name_id, &rdname, sizeof(rdname));
   219ca:	234a      	movs	r3, #74	; 0x4a
   219cc:	aa03      	add	r2, sp, #12
   219ce:	4631      	mov	r1, r6
   219d0:	4648      	mov	r0, r9
   219d2:	f7ff ff77 	bl	218c4 <nvs_read>
		if (rc < 0) {
   219d6:	2800      	cmp	r0, #0
   219d8:	da07      	bge.n	219ea <settings_nvs_save+0x50>
			if (rc == -ENOENT) {
   219da:	f110 0f02 	cmn.w	r0, #2
   219de:	bf08      	it	eq
   219e0:	46b0      	moveq	r8, r6
   219e2:	4635      	mov	r5, r6
   219e4:	e7ec      	b.n	219c0 <settings_nvs_save+0x26>
	delete = ((value == NULL) || (val_len == 0));
   219e6:	2701      	movs	r7, #1
   219e8:	e7e4      	b.n	219b4 <settings_nvs_save+0x1a>
		rdname[rc] = '\0';
   219ea:	ab16      	add	r3, sp, #88	; 0x58
   219ec:	4418      	add	r0, r3
   219ee:	2300      	movs	r3, #0
   219f0:	f800 3c4c 	strb.w	r3, [r0, #-76]
		if (strcmp(name, rdname)) {
   219f4:	a903      	add	r1, sp, #12
   219f6:	4650      	mov	r0, sl
   219f8:	f7e0 f944 	bl	1c84 <strcmp>
   219fc:	2800      	cmp	r0, #0
   219fe:	d1f0      	bne.n	219e2 <settings_nvs_save+0x48>
		if ((delete) && (name_id == cf->last_name_id)) {
   21a00:	2f00      	cmp	r7, #0
   21a02:	d039      	beq.n	21a78 <settings_nvs_save+0xde>
   21a04:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   21a06:	42b3      	cmp	r3, r6
   21a08:	d140      	bne.n	21a8c <settings_nvs_save+0xf2>
			cf->last_name_id--;
   21a0a:	4622      	mov	r2, r4
   21a0c:	1e73      	subs	r3, r6, #1
   21a0e:	f822 3f34 	strh.w	r3, [r2, #52]!
			rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID,
   21a12:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   21a16:	2302      	movs	r3, #2
   21a18:	4648      	mov	r0, r9
   21a1a:	f7e4 f96d 	bl	5cf8 <nvs_write>
			if (rc < 0) {
   21a1e:	2800      	cmp	r0, #0
   21a20:	da34      	bge.n	21a8c <settings_nvs_save+0xf2>
}
   21a22:	b017      	add	sp, #92	; 0x5c
   21a24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (delete) {
   21a28:	bb5f      	cbnz	r7, 21a82 <settings_nvs_save+0xe8>
	write_name = true;
   21a2a:	2701      	movs	r7, #1
	if (write_name_id == NVS_NAMECNT_ID + NVS_NAME_ID_OFFSET) {
   21a2c:	f5b8 4f40 	cmp.w	r8, #49152	; 0xc000
   21a30:	d029      	beq.n	21a86 <settings_nvs_save+0xec>
	rc = nvs_write(&cf->cf_nvs, write_name_id + NVS_NAME_ID_OFFSET,
   21a32:	f104 0508 	add.w	r5, r4, #8
   21a36:	f508 4180 	add.w	r1, r8, #16384	; 0x4000
   21a3a:	465b      	mov	r3, fp
   21a3c:	9a01      	ldr	r2, [sp, #4]
   21a3e:	b289      	uxth	r1, r1
   21a40:	4628      	mov	r0, r5
   21a42:	f7e4 f959 	bl	5cf8 <nvs_write>
	if (write_name) {
   21a46:	b157      	cbz	r7, 21a5e <settings_nvs_save+0xc4>
		rc = nvs_write(&cf->cf_nvs, write_name_id, name, strlen(name));
   21a48:	4650      	mov	r0, sl
   21a4a:	f7e0 f92d 	bl	1ca8 <strlen>
   21a4e:	4652      	mov	r2, sl
   21a50:	4603      	mov	r3, r0
   21a52:	4641      	mov	r1, r8
   21a54:	4628      	mov	r0, r5
   21a56:	f7e4 f94f 	bl	5cf8 <nvs_write>
		if (rc < 0) {
   21a5a:	2800      	cmp	r0, #0
   21a5c:	dbe1      	blt.n	21a22 <settings_nvs_save+0x88>
	if (write_name_id > cf->last_name_id) {
   21a5e:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   21a60:	4543      	cmp	r3, r8
   21a62:	d220      	bcs.n	21aa6 <settings_nvs_save+0x10c>
		cf->last_name_id = write_name_id;
   21a64:	4622      	mov	r2, r4
		rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID, &cf->last_name_id,
   21a66:	2302      	movs	r3, #2
		cf->last_name_id = write_name_id;
   21a68:	f822 8f34 	strh.w	r8, [r2, #52]!
		rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID, &cf->last_name_id,
   21a6c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   21a70:	4628      	mov	r0, r5
   21a72:	f7e4 f941 	bl	5cf8 <nvs_write>
   21a76:	e016      	b.n	21aa6 <settings_nvs_save+0x10c>
   21a78:	46b0      	mov	r8, r6
   21a7a:	e7d7      	b.n	21a2c <settings_nvs_save+0x92>
		return -EINVAL;
   21a7c:	f06f 0015 	mvn.w	r0, #21
   21a80:	e7cf      	b.n	21a22 <settings_nvs_save+0x88>
		return 0;
   21a82:	2000      	movs	r0, #0
   21a84:	e7cd      	b.n	21a22 <settings_nvs_save+0x88>
		return -ENOMEM;
   21a86:	f06f 000b 	mvn.w	r0, #11
   21a8a:	e7ca      	b.n	21a22 <settings_nvs_save+0x88>
			rc = nvs_delete(&cf->cf_nvs, name_id);
   21a8c:	4631      	mov	r1, r6
   21a8e:	4648      	mov	r0, r9
   21a90:	f7ff ff14 	bl	218bc <nvs_delete>
			if (rc >= 0) {
   21a94:	2800      	cmp	r0, #0
   21a96:	dbc4      	blt.n	21a22 <settings_nvs_save+0x88>
				rc = nvs_delete(&cf->cf_nvs, name_id +
   21a98:	f505 517f 	add.w	r1, r5, #16320	; 0x3fc0
   21a9c:	313f      	adds	r1, #63	; 0x3f
   21a9e:	b289      	uxth	r1, r1
   21aa0:	4648      	mov	r0, r9
   21aa2:	f7ff ff0b 	bl	218bc <nvs_delete>
	if (rc < 0) {
   21aa6:	ea00 70e0 	and.w	r0, r0, r0, asr #31
   21aaa:	e7ba      	b.n	21a22 <settings_nvs_save+0x88>

00021aac <settings_nvs_backend_init>:
{
   21aac:	b573      	push	{r0, r1, r4, r5, r6, lr}
	rc = nvs_init(&cf->cf_nvs, cf->flash_dev_name);
   21aae:	f100 0608 	add.w	r6, r0, #8
   21ab2:	6b81      	ldr	r1, [r0, #56]	; 0x38
{
   21ab4:	4604      	mov	r4, r0
	rc = nvs_init(&cf->cf_nvs, cf->flash_dev_name);
   21ab6:	4630      	mov	r0, r6
   21ab8:	f7e3 ffb2 	bl	5a20 <nvs_init>
	if (rc) {
   21abc:	4605      	mov	r5, r0
   21abe:	b970      	cbnz	r0, 21ade <settings_nvs_backend_init+0x32>
	rc = nvs_read(&cf->cf_nvs, NVS_NAMECNT_ID, &last_name_id,
   21ac0:	2302      	movs	r3, #2
   21ac2:	f10d 0206 	add.w	r2, sp, #6
   21ac6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   21aca:	4630      	mov	r0, r6
   21acc:	f7ff fefa 	bl	218c4 <nvs_read>
	if (rc < 0) {
   21ad0:	2800      	cmp	r0, #0
		cf->last_name_id = NVS_NAMECNT_ID;
   21ad2:	bfb4      	ite	lt
   21ad4:	f44f 4300 	movlt.w	r3, #32768	; 0x8000
		cf->last_name_id = last_name_id;
   21ad8:	f8bd 3006 	ldrhge.w	r3, [sp, #6]
   21adc:	86a3      	strh	r3, [r4, #52]	; 0x34
}
   21ade:	4628      	mov	r0, r5
   21ae0:	b002      	add	sp, #8
   21ae2:	bd70      	pop	{r4, r5, r6, pc}

00021ae4 <get_status>:
	data = get_sub_data(dev, type);
   21ae4:	6883      	ldr	r3, [r0, #8]
	return &data->subsys[type];
   21ae6:	b2c9      	uxtb	r1, r1
	if (data->started) {
   21ae8:	220c      	movs	r2, #12
   21aea:	fb02 3101 	mla	r1, r2, r1, r3
   21aee:	7a4b      	ldrb	r3, [r1, #9]
   21af0:	b923      	cbnz	r3, 21afc <get_status+0x18>
	if (data->ref > 0) {
   21af2:	7a08      	ldrb	r0, [r1, #8]
		return CLOCK_CONTROL_STATUS_ON;
   21af4:	fab0 f080 	clz	r0, r0
   21af8:	0940      	lsrs	r0, r0, #5
   21afa:	4770      	bx	lr
   21afc:	2002      	movs	r0, #2
}
   21afe:	4770      	bx	lr

00021b00 <clkstarted_handle>:
{
   21b00:	b538      	push	{r3, r4, r5, lr}
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
   21b02:	6883      	ldr	r3, [r0, #8]
	sub_data->started = true;
   21b04:	240c      	movs	r4, #12
   21b06:	fb04 3401 	mla	r4, r4, r1, r3
   21b0a:	2301      	movs	r3, #1
{
   21b0c:	4605      	mov	r5, r0
	sub_data->started = true;
   21b0e:	7263      	strb	r3, [r4, #9]
	__asm__ volatile(
   21b10:	f04f 0320 	mov.w	r3, #32
   21b14:	f3ef 8111 	mrs	r1, BASEPRI
   21b18:	f383 8811 	msr	BASEPRI, r3
   21b1c:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
   21b20:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_GET(slist, snode)
   21b22:	b12b      	cbz	r3, 21b30 <clkstarted_handle+0x30>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   21b24:	6860      	ldr	r0, [r4, #4]
   21b26:	681a      	ldr	r2, [r3, #0]
	list->head = node;
   21b28:	6022      	str	r2, [r4, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   21b2a:	4283      	cmp	r3, r0
	list->tail = node;
   21b2c:	bf08      	it	eq
   21b2e:	6062      	streq	r2, [r4, #4]
	__asm__ volatile(
   21b30:	f381 8811 	msr	BASEPRI, r1
   21b34:	f3bf 8f6f 	isb	sy
	while ((async_data = list_get(&sub_data->list)) != NULL) {
   21b38:	b903      	cbnz	r3, 21b3c <clkstarted_handle+0x3c>
}
   21b3a:	bd38      	pop	{r3, r4, r5, pc}
		async_data->cb(dev, async_data->user_data);
   21b3c:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
   21b40:	4628      	mov	r0, r5
   21b42:	4790      	blx	r2
   21b44:	e7e4      	b.n	21b10 <clkstarted_handle+0x10>

00021b46 <clock_async_start>:
	const struct nrf_clock_control_config *config =
   21b46:	6803      	ldr	r3, [r0, #0]
	clk_data = get_sub_data(dev, type);
   21b48:	f8d0 c008 	ldr.w	ip, [r0, #8]
{
   21b4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   21b50:	4605      	mov	r5, r0
	const struct nrf_clock_control_config *config =
   21b52:	689f      	ldr	r7, [r3, #8]
	return &config->subsys[type];
   21b54:	b2ce      	uxtb	r6, r1
	if ((data != NULL)
   21b56:	b14a      	cbz	r2, 21b6c <clock_async_start+0x26>
	sys_snode_t *item = sys_slist_peek_head(list);
   21b58:	230c      	movs	r3, #12
   21b5a:	4373      	muls	r3, r6
   21b5c:	f85c 3003 	ldr.w	r3, [ip, r3]
		if (item == node) {
   21b60:	429a      	cmp	r2, r3
   21b62:	d05b      	beq.n	21c1c <clock_async_start+0xd6>
Z_GENLIST_PEEK_NEXT(slist, snode)
   21b64:	b113      	cbz	r3, 21b6c <clock_async_start+0x26>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   21b66:	681b      	ldr	r3, [r3, #0]
	} while (item);
   21b68:	2b00      	cmp	r3, #0
   21b6a:	d1f9      	bne.n	21b60 <clock_async_start+0x1a>
	__asm__ volatile(
   21b6c:	f04f 0320 	mov.w	r3, #32
   21b70:	f3ef 8011 	mrs	r0, BASEPRI
   21b74:	f383 8811 	msr	BASEPRI, r3
   21b78:	f3bf 8f6f 	isb	sy
	ref = ++clk_data->ref;
   21b7c:	210c      	movs	r1, #12
   21b7e:	4371      	muls	r1, r6
   21b80:	eb0c 0301 	add.w	r3, ip, r1
   21b84:	7a1c      	ldrb	r4, [r3, #8]
   21b86:	3401      	adds	r4, #1
   21b88:	b2e4      	uxtb	r4, r4
   21b8a:	721c      	strb	r4, [r3, #8]
	__asm__ volatile(
   21b8c:	f380 8811 	msr	BASEPRI, r0
   21b90:	f3bf 8f6f 	isb	sy
	if (data) {
   21b94:	b332      	cbz	r2, 21be4 <clock_async_start+0x9e>
    p_reg->INTENCLR = mask;
   21b96:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
   21b9a:	f04f 0e03 	mov.w	lr, #3
   21b9e:	f8c0 e308 	str.w	lr, [r0, #776]	; 0x308
		already_started = clk_data->started;
   21ba2:	7a58      	ldrb	r0, [r3, #9]
		if (!already_started) {
   21ba4:	b9a0      	cbnz	r0, 21bd0 <clock_async_start+0x8a>
	__asm__ volatile(
   21ba6:	f04f 0e20 	mov.w	lr, #32
   21baa:	f3ef 8811 	mrs	r8, BASEPRI
   21bae:	f38e 8811 	msr	BASEPRI, lr
   21bb2:	f3bf 8f6f 	isb	sy
	parent->next = child;
   21bb6:	6010      	str	r0, [r2, #0]
Z_GENLIST_APPEND(slist, snode)
   21bb8:	f8d3 e004 	ldr.w	lr, [r3, #4]
   21bbc:	f1be 0f00 	cmp.w	lr, #0
   21bc0:	d11f      	bne.n	21c02 <clock_async_start+0xbc>
	list->tail = node;
   21bc2:	605a      	str	r2, [r3, #4]
	list->head = node;
   21bc4:	f84c 2001 	str.w	r2, [ip, r1]
	__asm__ volatile(
   21bc8:	f388 8811 	msr	BASEPRI, r8
   21bcc:	f3bf 8f6f 	isb	sy
    p_reg->INTENSET = mask;
   21bd0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   21bd4:	2103      	movs	r1, #3
   21bd6:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304
		if (already_started) {
   21bda:	b118      	cbz	r0, 21be4 <clock_async_start+0x9e>
			data->cb(dev, data->user_data);
   21bdc:	e9d2 3101 	ldrd	r3, r1, [r2, #4]
   21be0:	4628      	mov	r0, r5
   21be2:	4798      	blx	r3
	if (ref == 1) {
   21be4:	2c01      	cmp	r4, #1
   21be6:	d10a      	bne.n	21bfe <clock_async_start+0xb8>
		do_start =  (config->start_handler) ?
   21be8:	ea4f 1806 	mov.w	r8, r6, lsl #4
   21bec:	f857 3008 	ldr.w	r3, [r7, r8]
				config->start_handler(dev) : true;
   21bf0:	b95b      	cbnz	r3, 21c0a <clock_async_start+0xc4>
			nrf_clock_task_trigger(NRF_CLOCK,
   21bf2:	4447      	add	r7, r8
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21bf4:	2201      	movs	r2, #1
   21bf6:	7abb      	ldrb	r3, [r7, #10]
   21bf8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   21bfc:	601a      	str	r2, [r3, #0]
	return 0;
   21bfe:	2000      	movs	r0, #0
   21c00:	e00e      	b.n	21c20 <clock_async_start+0xda>
	parent->next = child;
   21c02:	f8ce 2000 	str.w	r2, [lr]
	list->tail = node;
   21c06:	605a      	str	r2, [r3, #4]
   21c08:	e7de      	b.n	21bc8 <clock_async_start+0x82>
				config->start_handler(dev) : true;
   21c0a:	4628      	mov	r0, r5
   21c0c:	4798      	blx	r3
   21c0e:	2800      	cmp	r0, #0
   21c10:	d1ef      	bne.n	21bf2 <clock_async_start+0xac>
			clkstarted_handle(dev, type);
   21c12:	4631      	mov	r1, r6
   21c14:	4628      	mov	r0, r5
   21c16:	f7ff ff73 	bl	21b00 <clkstarted_handle>
   21c1a:	e7f0      	b.n	21bfe <clock_async_start+0xb8>
		return -EBUSY;
   21c1c:	f06f 000f 	mvn.w	r0, #15
}
   21c20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00021c24 <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
   21c24:	2200      	movs	r2, #0
   21c26:	f7ff bf8e 	b.w	21b46 <clock_async_start>

00021c2a <clk_init>:
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   21c2a:	2200      	movs	r2, #0
{
   21c2c:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   21c2e:	2101      	movs	r1, #1
{
   21c30:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   21c32:	4610      	mov	r0, r2
   21c34:	f7e4 ff96 	bl	6b64 <z_arm_irq_priority_set>
	irq_enable(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0);
   21c38:	2000      	movs	r0, #0
   21c3a:	f7e4 ff61 	bl	6b00 <arch_irq_enable>
}

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->LFCLKSRC = (uint32_t)(source);
   21c3e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   21c42:	2201      	movs	r2, #1
   21c44:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    p_reg->INTENSET = mask;
   21c48:	2203      	movs	r2, #3
   21c4a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		sys_slist_init(&(get_sub_data(dev, i)->list));
   21c4e:	68a3      	ldr	r3, [r4, #8]
	list->head = NULL;
   21c50:	2000      	movs	r0, #0
	list->tail = NULL;
   21c52:	e9c3 0000 	strd	r0, r0, [r3]
   21c56:	68a3      	ldr	r3, [r4, #8]
   21c58:	e9c3 0003 	strd	r0, r0, [r3, #12]
}
   21c5c:	bd10      	pop	{r4, pc}

00021c5e <clock_stop>:
	const struct nrf_clock_control_config *config =
   21c5e:	6802      	ldr	r2, [r0, #0]
{
   21c60:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	const struct nrf_clock_control_config *config =
   21c64:	f8d2 8008 	ldr.w	r8, [r2, #8]
	data = get_sub_data(dev, type);
   21c68:	6887      	ldr	r7, [r0, #8]
   21c6a:	b2cc      	uxtb	r4, r1
	__asm__ volatile(
   21c6c:	f04f 0320 	mov.w	r3, #32
   21c70:	f3ef 8611 	mrs	r6, BASEPRI
   21c74:	f383 8811 	msr	BASEPRI, r3
   21c78:	f3bf 8f6f 	isb	sy
	if (data->ref == 0) {
   21c7c:	220c      	movs	r2, #12
   21c7e:	4362      	muls	r2, r4
   21c80:	18b9      	adds	r1, r7, r2
   21c82:	7a0b      	ldrb	r3, [r1, #8]
   21c84:	b343      	cbz	r3, 21cd8 <clock_stop+0x7a>
	data->ref--;
   21c86:	3b01      	subs	r3, #1
   21c88:	b2db      	uxtb	r3, r3
   21c8a:	720b      	strb	r3, [r1, #8]
	if (data->ref == 0) {
   21c8c:	bb3b      	cbnz	r3, 21cde <clock_stop+0x80>
		do_stop =  (config->stop_handler) ?
   21c8e:	0125      	lsls	r5, r4, #4
	list->head = NULL;
   21c90:	50bb      	str	r3, [r7, r2]
	list->tail = NULL;
   21c92:	604b      	str	r3, [r1, #4]
   21c94:	eb08 0305 	add.w	r3, r8, r5
   21c98:	685b      	ldr	r3, [r3, #4]
				config->stop_handler(dev) : true;
   21c9a:	b9cb      	cbnz	r3, 21cd0 <clock_stop+0x72>
			nrf_clock_task_trigger(NRF_CLOCK, config->stop_tsk);
   21c9c:	4445      	add	r5, r8
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21c9e:	2201      	movs	r2, #1
   21ca0:	7aeb      	ldrb	r3, [r5, #11]
   21ca2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   21ca6:	601a      	str	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21ca8:	892b      	ldrh	r3, [r5, #8]
   21caa:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   21cae:	2200      	movs	r2, #0
   21cb0:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   21cb2:	681b      	ldr	r3, [r3, #0]
   21cb4:	9301      	str	r3, [sp, #4]
    (void)dummy;
   21cb6:	9b01      	ldr	r3, [sp, #4]
		data->started = false;
   21cb8:	210c      	movs	r1, #12
   21cba:	fb01 7404 	mla	r4, r1, r4, r7
   21cbe:	2000      	movs	r0, #0
   21cc0:	7260      	strb	r0, [r4, #9]
	__asm__ volatile(
   21cc2:	f386 8811 	msr	BASEPRI, r6
   21cc6:	f3bf 8f6f 	isb	sy
}
   21cca:	b002      	add	sp, #8
   21ccc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				config->stop_handler(dev) : true;
   21cd0:	4798      	blx	r3
   21cd2:	2800      	cmp	r0, #0
   21cd4:	d1e2      	bne.n	21c9c <clock_stop+0x3e>
   21cd6:	e7ef      	b.n	21cb8 <clock_stop+0x5a>
		err = -EALREADY;
   21cd8:	f06f 0077 	mvn.w	r0, #119	; 0x77
   21cdc:	e7f1      	b.n	21cc2 <clock_stop+0x64>
	int err = 0;
   21cde:	2000      	movs	r0, #0
   21ce0:	e7ef      	b.n	21cc2 <clock_stop+0x64>

00021ce2 <st7789v_read>:
}
   21ce2:	f06f 0085 	mvn.w	r0, #133	; 0x85
   21ce6:	4770      	bx	lr

00021ce8 <st7789v_get_framebuffer>:
}
   21ce8:	2000      	movs	r0, #0
   21cea:	4770      	bx	lr

00021cec <st7789v_set_brightness>:
}
   21cec:	f06f 0085 	mvn.w	r0, #133	; 0x85
   21cf0:	4770      	bx	lr

00021cf2 <k_sleep>:
	return z_impl_k_sleep(ms);
   21cf2:	f7fd b815 	b.w	1ed20 <z_impl_k_sleep>

00021cf6 <st7789v_get_capabilities>:
{
   21cf6:	b538      	push	{r3, r4, r5, lr}
   21cf8:	460b      	mov	r3, r1
   21cfa:	2410      	movs	r4, #16
	struct st7789v_data *data = (struct st7789v_data *)dev->driver_data;
   21cfc:	6885      	ldr	r5, [r0, #8]
   21cfe:	4622      	mov	r2, r4
   21d00:	2100      	movs	r1, #0
   21d02:	4618      	mov	r0, r3
   21d04:	f7df ff93 	bl	1c2e <memset>
	capabilities->x_resolution = data->width;
   21d08:	8cea      	ldrh	r2, [r5, #38]	; 0x26
   21d0a:	8002      	strh	r2, [r0, #0]
	capabilities->y_resolution = data->height;
   21d0c:	8caa      	ldrh	r2, [r5, #36]	; 0x24
	capabilities->current_pixel_format = PIXEL_FORMAT_RGB_565;
   21d0e:	8184      	strh	r4, [r0, #12]
	capabilities->y_resolution = data->height;
   21d10:	8042      	strh	r2, [r0, #2]
	capabilities->supported_pixel_formats = PIXEL_FORMAT_RGB_565;
   21d12:	6044      	str	r4, [r0, #4]
}
   21d14:	bd38      	pop	{r3, r4, r5, pc}

00021d16 <gpio_pin_write>:
 * @param value Value set on the pin.
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_write(struct device *port, u32_t pin,
				 u32_t value)
{
   21d16:	b410      	push	{r4}
   21d18:	4613      	mov	r3, r2
	return api->write(port, access_op, pin, value);
   21d1a:	6842      	ldr	r2, [r0, #4]
   21d1c:	6854      	ldr	r4, [r2, #4]
   21d1e:	460a      	mov	r2, r1
   21d20:	46a4      	mov	ip, r4
   21d22:	2100      	movs	r1, #0
	return gpio_write(port, GPIO_ACCESS_BY_PIN, pin, value);
}
   21d24:	bc10      	pop	{r4}
	return api->write(port, access_op, pin, value);
   21d26:	4760      	bx	ip

00021d28 <st7789v_set_contrast>:
   21d28:	f06f 0085 	mvn.w	r0, #133	; 0x85
   21d2c:	4770      	bx	lr

00021d2e <st7789v_transmit>:
{
   21d2e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   21d32:	4605      	mov	r5, r0
   21d34:	b087      	sub	sp, #28
   21d36:	4698      	mov	r8, r3
	spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
   21d38:	462c      	mov	r4, r5
	struct spi_buf tx_buf = { .buf = &cmd, .len = 1 };
   21d3a:	f10d 0307 	add.w	r3, sp, #7
{
   21d3e:	f88d 1007 	strb.w	r1, [sp, #7]
	struct spi_buf tx_buf = { .buf = &cmd, .len = 1 };
   21d42:	9302      	str	r3, [sp, #8]
   21d44:	2601      	movs	r6, #1
	struct spi_buf_set tx_bufs = { .buffers = &tx_buf, .count = 1 };
   21d46:	ab02      	add	r3, sp, #8
{
   21d48:	4617      	mov	r7, r2
	gpio_pin_write(data->cmd_data_gpio, ST7789V_CMD_DATA_PIN, !is_cmd);
   21d4a:	2112      	movs	r1, #18
   21d4c:	2200      	movs	r2, #0
   21d4e:	6a00      	ldr	r0, [r0, #32]
	struct spi_buf tx_buf = { .buf = &cmd, .len = 1 };
   21d50:	9603      	str	r6, [sp, #12]
	struct spi_buf_set tx_bufs = { .buffers = &tx_buf, .count = 1 };
   21d52:	e9cd 3604 	strd	r3, r6, [sp, #16]
	gpio_pin_write(data->cmd_data_gpio, ST7789V_CMD_DATA_PIN, !is_cmd);
   21d56:	f7ff ffde 	bl	21d16 <gpio_pin_write>
	spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
   21d5a:	f854 0b04 	ldr.w	r0, [r4], #4
				       const struct spi_buf_set *rx_bufs)
{
	const struct spi_driver_api *api =
		(const struct spi_driver_api *)dev->driver_api;

	return api->transceive(dev, config, tx_bufs, rx_bufs);
   21d5e:	6843      	ldr	r3, [r0, #4]
   21d60:	aa04      	add	r2, sp, #16
   21d62:	f8d3 9000 	ldr.w	r9, [r3]
   21d66:	4621      	mov	r1, r4
   21d68:	2300      	movs	r3, #0
   21d6a:	47c8      	blx	r9
	if (tx_data != NULL) {
   21d6c:	b16f      	cbz	r7, 21d8a <st7789v_transmit+0x5c>
	gpio_pin_write(data->cmd_data_gpio, ST7789V_CMD_DATA_PIN, !is_cmd);
   21d6e:	4632      	mov	r2, r6
   21d70:	2112      	movs	r1, #18
   21d72:	6a28      	ldr	r0, [r5, #32]
		tx_buf.len = tx_count;
   21d74:	e9cd 7802 	strd	r7, r8, [sp, #8]
	gpio_pin_write(data->cmd_data_gpio, ST7789V_CMD_DATA_PIN, !is_cmd);
   21d78:	f7ff ffcd 	bl	21d16 <gpio_pin_write>
		spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
   21d7c:	6828      	ldr	r0, [r5, #0]
   21d7e:	6843      	ldr	r3, [r0, #4]
   21d80:	aa04      	add	r2, sp, #16
   21d82:	681d      	ldr	r5, [r3, #0]
   21d84:	4621      	mov	r1, r4
   21d86:	2300      	movs	r3, #0
   21d88:	47a8      	blx	r5
}
   21d8a:	b007      	add	sp, #28
   21d8c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00021d90 <st7789v_blanking_on>:
{
   21d90:	b508      	push	{r3, lr}
	st7789v_transmit(driver, ST7789V_CMD_DISP_OFF, NULL, 0);
   21d92:	2300      	movs	r3, #0
   21d94:	461a      	mov	r2, r3
   21d96:	2128      	movs	r1, #40	; 0x28
   21d98:	6880      	ldr	r0, [r0, #8]
   21d9a:	f7ff ffc8 	bl	21d2e <st7789v_transmit>
}
   21d9e:	2000      	movs	r0, #0
   21da0:	bd08      	pop	{r3, pc}

00021da2 <st7789v_blanking_off>:
{
   21da2:	b508      	push	{r3, lr}
	st7789v_transmit(driver, ST7789V_CMD_DISP_ON, NULL, 0);
   21da4:	2300      	movs	r3, #0
   21da6:	461a      	mov	r2, r3
   21da8:	2129      	movs	r1, #41	; 0x29
   21daa:	6880      	ldr	r0, [r0, #8]
   21dac:	f7ff ffbf 	bl	21d2e <st7789v_transmit>
}
   21db0:	2000      	movs	r0, #0
   21db2:	bd08      	pop	{r3, pc}

00021db4 <st7789v_write>:
{
   21db4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct st7789v_data *data = (struct st7789v_data *)dev->driver_data;
   21db8:	6885      	ldr	r5, [r0, #8]
	u16_t ram_x = x + data->x_offset;
   21dba:	8d28      	ldrh	r0, [r5, #40]	; 0x28
	u16_t ram_y = y + data->y_offset;
   21dbc:	f8b5 802a 	ldrh.w	r8, [r5, #42]	; 0x2a
{
   21dc0:	461c      	mov	r4, r3
	st7789v_set_mem_area(data, x, y, desc->width, desc->height);
   21dc2:	889b      	ldrh	r3, [r3, #4]
   21dc4:	88e6      	ldrh	r6, [r4, #6]
	u16_t ram_x = x + data->x_offset;
   21dc6:	4401      	add	r1, r0
   21dc8:	b289      	uxth	r1, r1
	spi_data[1] = sys_cpu_to_be16(ram_x + w - 1);
   21dca:	3b01      	subs	r3, #1
{
   21dcc:	b085      	sub	sp, #20
	spi_data[1] = sys_cpu_to_be16(ram_x + w - 1);
   21dce:	440b      	add	r3, r1
	u16_t ram_y = y + data->y_offset;
   21dd0:	4490      	add	r8, r2
	spi_data[1] = sys_cpu_to_be16(ram_x + w - 1);
   21dd2:	ba5b      	rev16	r3, r3
	spi_data[0] = sys_cpu_to_be16(ram_x);
   21dd4:	ba4a      	rev16	r2, r1
	u16_t ram_y = y + data->y_offset;
   21dd6:	fa1f f888 	uxth.w	r8, r8
	spi_data[0] = sys_cpu_to_be16(ram_x);
   21dda:	f8ad 2008 	strh.w	r2, [sp, #8]
	spi_data[1] = sys_cpu_to_be16(ram_x + w - 1);
   21dde:	f8ad 300a 	strh.w	r3, [sp, #10]
	st7789v_transmit(data, ST7789V_CMD_CASET, (u8_t *)&spi_data[0], 4);
   21de2:	aa02      	add	r2, sp, #8
   21de4:	2304      	movs	r3, #4
   21de6:	212a      	movs	r1, #42	; 0x2a
   21de8:	4628      	mov	r0, r5
	spi_data[1] = sys_cpu_to_be16(ram_y + h - 1);
   21dea:	3e01      	subs	r6, #1
{
   21dec:	9f0e      	ldr	r7, [sp, #56]	; 0x38
	spi_data[1] = sys_cpu_to_be16(ram_y + h - 1);
   21dee:	4446      	add	r6, r8
	st7789v_transmit(data, ST7789V_CMD_CASET, (u8_t *)&spi_data[0], 4);
   21df0:	f7ff ff9d 	bl	21d2e <st7789v_transmit>
	spi_data[0] = sys_cpu_to_be16(ram_y);
   21df4:	fa98 f398 	rev16.w	r3, r8
   21df8:	f8ad 3008 	strh.w	r3, [sp, #8]
	spi_data[1] = sys_cpu_to_be16(ram_y + h - 1);
   21dfc:	ba76      	rev16	r6, r6
	st7789v_transmit(data, ST7789V_CMD_RASET, (u8_t *)&spi_data[0], 4);
   21dfe:	2304      	movs	r3, #4
   21e00:	aa02      	add	r2, sp, #8
   21e02:	212b      	movs	r1, #43	; 0x2b
   21e04:	4628      	mov	r0, r5
	spi_data[1] = sys_cpu_to_be16(ram_y + h - 1);
   21e06:	f8ad 600a 	strh.w	r6, [sp, #10]
	st7789v_transmit(data, ST7789V_CMD_RASET, (u8_t *)&spi_data[0], 4);
   21e0a:	f7ff ff90 	bl	21d2e <st7789v_transmit>
	if (desc->pitch > desc->width) {
   21e0e:	88a3      	ldrh	r3, [r4, #4]
   21e10:	8922      	ldrh	r2, [r4, #8]
   21e12:	88e6      	ldrh	r6, [r4, #6]
		nbr_of_writes = desc->height;
   21e14:	429a      	cmp	r2, r3
   21e16:	bf84      	itt	hi
   21e18:	46b1      	movhi	r9, r6
   21e1a:	2601      	movhi	r6, #1
	st7789v_transmit(data, ST7789V_CMD_RAMWR,
   21e1c:	fb06 f303 	mul.w	r3, r6, r3
   21e20:	ea4f 0343 	mov.w	r3, r3, lsl #1
   21e24:	463a      	mov	r2, r7
   21e26:	f04f 012c 	mov.w	r1, #44	; 0x2c
   21e2a:	4628      	mov	r0, r5
		nbr_of_writes = desc->height;
   21e2c:	bf98      	it	ls
   21e2e:	f04f 0901 	movls.w	r9, #1
	st7789v_transmit(data, ST7789V_CMD_RAMWR,
   21e32:	f7ff ff7c 	bl	21d2e <st7789v_transmit>
	tx_bufs.count = 1;
   21e36:	2301      	movs	r3, #1
   21e38:	9303      	str	r3, [sp, #12]
	write_data_start += (desc->pitch * ST7789V_PIXEL_SIZE);
   21e3a:	8923      	ldrh	r3, [r4, #8]
	tx_bufs.buffers = &tx_buf;
   21e3c:	f8cd d008 	str.w	sp, [sp, #8]
	write_data_start += (desc->pitch * ST7789V_PIXEL_SIZE);
   21e40:	eb07 0743 	add.w	r7, r7, r3, lsl #1
	for (write_cnt = 1U; write_cnt < nbr_of_writes; ++write_cnt) {
   21e44:	f04f 0800 	mov.w	r8, #0
		spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
   21e48:	f105 0a04 	add.w	sl, r5, #4
   21e4c:	f108 0801 	add.w	r8, r8, #1
	for (write_cnt = 1U; write_cnt < nbr_of_writes; ++write_cnt) {
   21e50:	fa1f f388 	uxth.w	r3, r8
   21e54:	4599      	cmp	r9, r3
   21e56:	d803      	bhi.n	21e60 <st7789v_write+0xac>
}
   21e58:	2000      	movs	r0, #0
   21e5a:	b005      	add	sp, #20
   21e5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		tx_buf.len = desc->width * ST7789V_PIXEL_SIZE * write_h;
   21e60:	88a3      	ldrh	r3, [r4, #4]
		tx_buf.buf = (void *)write_data_start;
   21e62:	9700      	str	r7, [sp, #0]
		tx_buf.len = desc->width * ST7789V_PIXEL_SIZE * write_h;
   21e64:	4373      	muls	r3, r6
   21e66:	005b      	lsls	r3, r3, #1
   21e68:	9301      	str	r3, [sp, #4]
		spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
   21e6a:	6828      	ldr	r0, [r5, #0]
   21e6c:	6843      	ldr	r3, [r0, #4]
   21e6e:	aa02      	add	r2, sp, #8
   21e70:	f8d3 b000 	ldr.w	fp, [r3]
   21e74:	4651      	mov	r1, sl
   21e76:	2300      	movs	r3, #0
   21e78:	47d8      	blx	fp
		write_data_start += (desc->pitch * ST7789V_PIXEL_SIZE);
   21e7a:	8923      	ldrh	r3, [r4, #8]
   21e7c:	eb07 0743 	add.w	r7, r7, r3, lsl #1
   21e80:	e7e4      	b.n	21e4c <st7789v_write+0x98>

00021e82 <z_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
   21e82:	4770      	bx	lr

00021e84 <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
   21e84:	4770      	bx	lr

00021e86 <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
   21e86:	f7e4 bd53 	b.w	6930 <_DoInit>

00021e8a <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(struct device *unused)
{
   21e8a:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
   21e8c:	f7ff fffb 	bl	21e86 <SEGGER_RTT_Init>

	return 0;
}
   21e90:	2000      	movs	r0, #0
   21e92:	bd08      	pop	{r3, pc}

00021e94 <z_irq_spurious>:
	z_arm_reserved();
   21e94:	f7e4 bed8 	b.w	6c48 <z_arm_bus_fault>

00021e98 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   21e98:	4601      	mov	r1, r0
			reason = K_ERR_KERNEL_OOPS;
		}
	}

#endif /* CONFIG_USERSPACE */
	z_arm_fatal_error(reason, esf);
   21e9a:	6800      	ldr	r0, [r0, #0]
   21e9c:	f7e4 bede 	b.w	6c5c <z_arm_fatal_error>

00021ea0 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   21ea0:	b508      	push	{r3, lr}
	handler();
   21ea2:	f7e4 ff2d 	bl	6d00 <z_SysNmiOnReset>
	z_arm_exc_exit();
}
   21ea6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_exc_exit();
   21eaa:	f7e4 bdc7 	b.w	6a3c <z_arm_exc_exit>

00021eae <z_arm_configure_dynamic_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_dynamic_mpu_regions(struct k_thread *thread)
{
   21eae:	b507      	push	{r0, r1, r2, lr}

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(
   21eb0:	2100      	movs	r1, #0
   21eb2:	a801      	add	r0, sp, #4
   21eb4:	f7e5 fb0e 	bl	74d4 <arm_core_mpu_configure_dynamic_mpu_regions>
		(const struct k_mem_partition **)dynamic_regions,
		region_num);
}
   21eb8:	b003      	add	sp, #12
   21eba:	f85d fb04 	ldr.w	pc, [sp], #4

00021ebe <_stdout_hook_default>:
}
   21ebe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   21ec2:	4770      	bx	lr

00021ec4 <_stdin_hook_default>:
}
   21ec4:	2000      	movs	r0, #0
   21ec6:	4770      	bx	lr

00021ec8 <_read>:
{
   21ec8:	4608      	mov	r0, r1
	return z_impl_zephyr_read_stdin(buf, nbytes);
   21eca:	4611      	mov	r1, r2
   21ecc:	f7e5 bb18 	b.w	7500 <z_impl_zephyr_read_stdin>

00021ed0 <_write>:
{
   21ed0:	4608      	mov	r0, r1
	return z_impl_zephyr_write_stdout(buf, nbytes);
   21ed2:	4611      	mov	r1, r2
   21ed4:	f7e5 bb28 	b.w	7528 <z_impl_zephyr_write_stdout>

00021ed8 <_close>:
   21ed8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   21edc:	4770      	bx	lr

00021ede <_lseek>:
}
   21ede:	2000      	movs	r0, #0
   21ee0:	4770      	bx	lr

00021ee2 <_isatty>:
}
   21ee2:	2001      	movs	r0, #1
   21ee4:	4770      	bx	lr

00021ee6 <_kill>:
}
   21ee6:	2000      	movs	r0, #0
   21ee8:	4770      	bx	lr

00021eea <_getpid>:
}
   21eea:	2000      	movs	r0, #0
   21eec:	4770      	bx	lr

00021eee <_fstat>:
	st->st_mode = S_IFCHR;
   21eee:	f44f 5300 	mov.w	r3, #8192	; 0x2000
   21ef2:	604b      	str	r3, [r1, #4]
}
   21ef4:	2000      	movs	r0, #0
   21ef6:	4770      	bx	lr

00021ef8 <display_get_capabilities>:
   21ef8:	6843      	ldr	r3, [r0, #4]
   21efa:	69db      	ldr	r3, [r3, #28]
   21efc:	4718      	bx	r3

00021efe <lvgl_flush_cb_mono>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_mono(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
   21efe:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u16_t w = area->x2 - area->x1 + 1;
   21f02:	888c      	ldrh	r4, [r1, #4]
   21f04:	880b      	ldrh	r3, [r1, #0]
	u16_t h = area->y2 - area->y1 + 1;
   21f06:	88ce      	ldrh	r6, [r1, #6]
	struct device *display_dev = (struct device *)disp_drv->user_data;
   21f08:	f8d0 9020 	ldr.w	r9, [r0, #32]
	u16_t w = area->x2 - area->x1 + 1;
   21f0c:	3401      	adds	r4, #1
   21f0e:	1ae4      	subs	r4, r4, r3
	u16_t h = area->y2 - area->y1 + 1;
   21f10:	884b      	ldrh	r3, [r1, #2]
   21f12:	3601      	adds	r6, #1
{
   21f14:	b08b      	sub	sp, #44	; 0x2c
	u16_t h = area->y2 - area->y1 + 1;
   21f16:	1af6      	subs	r6, r6, r3
	u16_t w = area->x2 - area->x1 + 1;
   21f18:	b2a4      	uxth	r4, r4
{
   21f1a:	460d      	mov	r5, r1
	u16_t h = area->y2 - area->y1 + 1;
   21f1c:	b2b6      	uxth	r6, r6
	struct display_capabilities cap;
	struct display_buffer_descriptor desc;

	display_get_capabilities(display_dev, &cap);
   21f1e:	a906      	add	r1, sp, #24
{
   21f20:	4607      	mov	r7, r0
	display_get_capabilities(display_dev, &cap);
   21f22:	4648      	mov	r0, r9
{
   21f24:	4690      	mov	r8, r2
	display_get_capabilities(display_dev, &cap);
   21f26:	f7ff ffe7 	bl	21ef8 <display_get_capabilities>

	desc.buf_size = (w * h)/8U;
   21f2a:	fb06 f304 	mul.w	r3, r6, r4
   21f2e:	08db      	lsrs	r3, r3, #3
   21f30:	9303      	str	r3, [sp, #12]
	return api->write(dev, x, y, desc, buf);
   21f32:	f8d9 3004 	ldr.w	r3, [r9, #4]
   21f36:	f8cd 8000 	str.w	r8, [sp]
	desc.width = w;
   21f3a:	f8ad 4010 	strh.w	r4, [sp, #16]
	desc.pitch = w;
   21f3e:	f8ad 4014 	strh.w	r4, [sp, #20]
	desc.height = h;
   21f42:	f8ad 6012 	strh.w	r6, [sp, #18]
   21f46:	689c      	ldr	r4, [r3, #8]
   21f48:	886a      	ldrh	r2, [r5, #2]
   21f4a:	8829      	ldrh	r1, [r5, #0]
   21f4c:	ab03      	add	r3, sp, #12
   21f4e:	4648      	mov	r0, r9
   21f50:	47a0      	blx	r4
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);
	if (cap.screen_info & SCREEN_INFO_DOUBLE_BUFFER) {
   21f52:	9b08      	ldr	r3, [sp, #32]
   21f54:	071b      	lsls	r3, r3, #28
   21f56:	d509      	bpl.n	21f6c <lvgl_flush_cb_mono+0x6e>
   21f58:	f8d9 3004 	ldr.w	r3, [r9, #4]
   21f5c:	f8cd 8000 	str.w	r8, [sp]
   21f60:	689c      	ldr	r4, [r3, #8]
   21f62:	886a      	ldrh	r2, [r5, #2]
   21f64:	8829      	ldrh	r1, [r5, #0]
   21f66:	ab03      	add	r3, sp, #12
   21f68:	4648      	mov	r0, r9
   21f6a:	47a0      	blx	r4
		display_write(display_dev, area->x1, area->y1, &desc,
				(void *) color_p);
	}

	lv_disp_flush_ready(disp_drv);
   21f6c:	4638      	mov	r0, r7
   21f6e:	f005 f844 	bl	26ffa <lv_disp_flush_ready>
}
   21f72:	b00b      	add	sp, #44	; 0x2c
   21f74:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00021f78 <lvgl_set_px_cb_mono>:


void lvgl_set_px_cb_mono(struct _disp_drv_t *disp_drv,
		u8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
   21f78:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	struct device *display_dev = (struct device *)disp_drv->user_data;
	u8_t *buf_xy;
	u8_t bit;
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);
   21f7c:	6a00      	ldr	r0, [r0, #32]
{
   21f7e:	f9bd 6028 	ldrsh.w	r6, [sp, #40]	; 0x28
   21f82:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   21f84:	460f      	mov	r7, r1
	display_get_capabilities(display_dev, &cap);
   21f86:	4669      	mov	r1, sp
{
   21f88:	4690      	mov	r8, r2
   21f8a:	461c      	mov	r4, r3
	display_get_capabilities(display_dev, &cap);
   21f8c:	f7ff ffb4 	bl	21ef8 <display_get_capabilities>

	if (cap.screen_info & SCREEN_INFO_MONO_VTILED) {
   21f90:	9802      	ldr	r0, [sp, #8]
   21f92:	f010 0f01 	tst.w	r0, #1
   21f96:	f000 0002 	and.w	r0, r0, #2
   21f9a:	d01f      	beq.n	21fdc <lvgl_set_px_cb_mono+0x64>
		buf_xy = buf + x + y/8 * buf_w;
   21f9c:	2e00      	cmp	r6, #0
   21f9e:	4631      	mov	r1, r6
   21fa0:	bfb8      	it	lt
   21fa2:	1df1      	addlt	r1, r6, #7
   21fa4:	10c9      	asrs	r1, r1, #3
   21fa6:	fb11 4108 	smlabb	r1, r1, r8, r4
   21faa:	4439      	add	r1, r7

		if (cap.screen_info & SCREEN_INFO_MONO_MSB_FIRST) {
   21fac:	4273      	negs	r3, r6
   21fae:	f006 0407 	and.w	r4, r6, #7
   21fb2:	f003 0307 	and.w	r3, r3, #7
   21fb6:	bf58      	it	pl
   21fb8:	425c      	negpl	r4, r3
			bit = y%8;
		}
	} else {
		buf_xy = buf + x/8 + y * buf_w/8;

		if (cap.screen_info & SCREEN_INFO_MONO_MSB_FIRST) {
   21fba:	b108      	cbz	r0, 21fc0 <lvgl_set_px_cb_mono+0x48>
			bit = 7 - x%8;
   21fbc:	f1c4 0407 	rsb	r4, r4, #7
		} else {
			bit = x%8;
   21fc0:	2301      	movs	r3, #1
   21fc2:	b2e4      	uxtb	r4, r4
		}
	}

	if (cap.current_pixel_format == PIXEL_FORMAT_MONO10) {
   21fc4:	fa03 f404 	lsl.w	r4, r3, r4
   21fc8:	f89d 300c 	ldrb.w	r3, [sp, #12]
   21fcc:	7808      	ldrb	r0, [r1, #0]
   21fce:	2b04      	cmp	r3, #4
   21fd0:	b2e4      	uxtb	r4, r4
   21fd2:	d115      	bne.n	22000 <lvgl_set_px_cb_mono+0x88>
		if (color.full == 0) {
   21fd4:	b9b5      	cbnz	r5, 22004 <lvgl_set_px_cb_mono+0x8c>
		}
	} else {
		if (color.full == 0) {
			*buf_xy |= BIT(bit);
		} else {
			*buf_xy &= ~BIT(bit);
   21fd6:	ea20 0004 	bic.w	r0, r0, r4
   21fda:	e014      	b.n	22006 <lvgl_set_px_cb_mono+0x8e>
		buf_xy = buf + x/8 + y * buf_w/8;
   21fdc:	4643      	mov	r3, r8
   21fde:	435e      	muls	r6, r3
   21fe0:	bf48      	it	mi
   21fe2:	3607      	addmi	r6, #7
   21fe4:	2c00      	cmp	r4, #0
   21fe6:	4622      	mov	r2, r4
   21fe8:	ea4f 06e6 	mov.w	r6, r6, asr #3
   21fec:	bfb8      	it	lt
   21fee:	1de2      	addlt	r2, r4, #7
   21ff0:	eb06 06e2 	add.w	r6, r6, r2, asr #3
   21ff4:	4263      	negs	r3, r4
   21ff6:	eb07 0106 	add.w	r1, r7, r6
		if (cap.screen_info & SCREEN_INFO_MONO_MSB_FIRST) {
   21ffa:	f004 0407 	and.w	r4, r4, #7
   21ffe:	e7d8      	b.n	21fb2 <lvgl_set_px_cb_mono+0x3a>
		if (color.full == 0) {
   22000:	2d00      	cmp	r5, #0
   22002:	d1e8      	bne.n	21fd6 <lvgl_set_px_cb_mono+0x5e>
			*buf_xy |= BIT(bit);
   22004:	4320      	orrs	r0, r4
			*buf_xy &= ~BIT(bit);
   22006:	7008      	strb	r0, [r1, #0]
		}
	}
}
   22008:	b004      	add	sp, #16
   2200a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002200e <lvgl_rounder_cb_mono>:

void lvgl_rounder_cb_mono(struct _disp_drv_t *disp_drv,
		lv_area_t *area)
{
   2200e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   22010:	460c      	mov	r4, r1
	struct device *display_dev = (struct device *)disp_drv->user_data;
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);
   22012:	6a00      	ldr	r0, [r0, #32]
   22014:	4669      	mov	r1, sp
   22016:	f7ff ff6f 	bl	21ef8 <display_get_capabilities>

	if (cap.screen_info & SCREEN_INFO_MONO_VTILED) {
   2201a:	9b02      	ldr	r3, [sp, #8]
   2201c:	07db      	lsls	r3, r3, #31
   2201e:	d509      	bpl.n	22034 <lvgl_rounder_cb_mono+0x26>
		area->y1 &= ~0x7;
   22020:	8863      	ldrh	r3, [r4, #2]
   22022:	f023 0307 	bic.w	r3, r3, #7
   22026:	8063      	strh	r3, [r4, #2]
		area->y2 |= 0x7;
   22028:	88e3      	ldrh	r3, [r4, #6]
   2202a:	f043 0307 	orr.w	r3, r3, #7
   2202e:	80e3      	strh	r3, [r4, #6]
	} else {
		area->x1 &= ~0x7;
		area->x2 |= 0x7;
	}
}
   22030:	b004      	add	sp, #16
   22032:	bd10      	pop	{r4, pc}
		area->x1 &= ~0x7;
   22034:	8823      	ldrh	r3, [r4, #0]
   22036:	f023 0307 	bic.w	r3, r3, #7
   2203a:	8023      	strh	r3, [r4, #0]
		area->x2 |= 0x7;
   2203c:	88a3      	ldrh	r3, [r4, #4]
   2203e:	f043 0307 	orr.w	r3, r3, #7
   22042:	80a3      	strh	r3, [r4, #4]
}
   22044:	e7f4      	b.n	22030 <lvgl_rounder_cb_mono+0x22>

00022046 <lvgl_flush_cb_16bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_16bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
   22046:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct device *display_dev = (struct device *)disp_drv->user_data;
	u16_t w = area->x2 - area->x1 + 1;
   22048:	888b      	ldrh	r3, [r1, #4]
	u16_t h = area->y2 - area->y1 + 1;
   2204a:	88cc      	ldrh	r4, [r1, #6]
	u16_t w = area->x2 - area->x1 + 1;
   2204c:	f9b1 6000 	ldrsh.w	r6, [r1]
	u16_t h = area->y2 - area->y1 + 1;
   22050:	f9b1 7002 	ldrsh.w	r7, [r1, #2]
	u16_t w = area->x2 - area->x1 + 1;
   22054:	3301      	adds	r3, #1
	u16_t h = area->y2 - area->y1 + 1;
   22056:	3401      	adds	r4, #1
{
   22058:	b087      	sub	sp, #28
   2205a:	4605      	mov	r5, r0
	u16_t w = area->x2 - area->x1 + 1;
   2205c:	1b9b      	subs	r3, r3, r6
	struct device *display_dev = (struct device *)disp_drv->user_data;
   2205e:	6a00      	ldr	r0, [r0, #32]
	u16_t h = area->y2 - area->y1 + 1;
   22060:	1be4      	subs	r4, r4, r7
	u16_t w = area->x2 - area->x1 + 1;
   22062:	b29b      	uxth	r3, r3
	u16_t h = area->y2 - area->y1 + 1;
   22064:	b2a4      	uxth	r4, r4
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 2U * h;
   22066:	fb04 f103 	mul.w	r1, r4, r3
	desc.width = w;
   2206a:	f8ad 3010 	strh.w	r3, [sp, #16]
	desc.pitch = w;
   2206e:	f8ad 3014 	strh.w	r3, [sp, #20]
   22072:	6843      	ldr	r3, [r0, #4]
   22074:	9200      	str	r2, [sp, #0]
	desc.buf_size = w * 2U * h;
   22076:	0049      	lsls	r1, r1, #1
   22078:	9103      	str	r1, [sp, #12]
	desc.height = h;
   2207a:	f8ad 4012 	strh.w	r4, [sp, #18]
   2207e:	b2ba      	uxth	r2, r7
   22080:	689c      	ldr	r4, [r3, #8]
   22082:	b2b1      	uxth	r1, r6
   22084:	ab03      	add	r3, sp, #12
   22086:	47a0      	blx	r4
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);

	lv_disp_flush_ready(disp_drv);
   22088:	4628      	mov	r0, r5
   2208a:	f004 ffb6 	bl	26ffa <lv_disp_flush_ready>
}
   2208e:	b007      	add	sp, #28
   22090:	bdf0      	pop	{r4, r5, r6, r7, pc}

00022092 <lvgl_set_px_cb_16bit>:

#ifndef CONFIG_LVGL_COLOR_DEPTH_16
void lvgl_set_px_cb_16bit(struct _disp_drv_t *disp_drv,
		u8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
   22092:	b530      	push	{r4, r5, lr}
   22094:	9804      	ldr	r0, [sp, #16]
    return ret.full;
#elif LV_COLOR_DEPTH == 16
    return color.full;
#elif LV_COLOR_DEPTH == 32
    lv_color16_t ret;
    LV_COLOR_SET_R16(ret, LV_COLOR_GET_R(color) >> 3);   /* 8 - 5  = 3*/
   22096:	f04f 0400 	mov.w	r4, #0
   2209a:	f3c0 45c4 	ubfx	r5, r0, #19, #5
   2209e:	f365 24cf 	bfi	r4, r5, #11, #5

#if LV_COLOR_16_SWAP == 0
    LV_COLOR_SET_G16(ret, LV_COLOR_GET_G(color) >> 2); /* 8 - 6  = 2*/
   220a2:	f3c0 2585 	ubfx	r5, r0, #10, #6
   220a6:	f365 144a 	bfi	r4, r5, #5, #6
#else
    LV_COLOR_SET_G16_SWAP(ret, ret.ch.green_h = (LV_COLOR_GET_G(color) >> 2); /*(2^6 - 1)/(2^3 - 1) = 63/7 = 9*/
#endif
    LV_COLOR_SET_B16(ret, LV_COLOR_GET_B(color) >> 3);  /* 8 - 5  = 3*/
   220aa:	f3c0 00c4 	ubfx	r0, r0, #3, #5
   220ae:	f360 0404 	bfi	r4, r0, #0, #5
	u16_t *buf_xy = (u16_t *)(buf + x * 2U + y * 2U * buf_w);
   220b2:	f9bd 000c 	ldrsh.w	r0, [sp, #12]
   220b6:	fb00 3302 	mla	r3, r0, r2, r3
	*buf_xy = lv_color_to16(color);
   220ba:	f821 4013 	strh.w	r4, [r1, r3, lsl #1]
}
   220be:	bd30      	pop	{r4, r5, pc}

000220c0 <lvgl_flush_cb_24bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_24bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
   220c0:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct device *display_dev = (struct device *)disp_drv->user_data;
	u16_t w = area->x2 - area->x1 + 1;
   220c2:	888b      	ldrh	r3, [r1, #4]
	u16_t h = area->y2 - area->y1 + 1;
   220c4:	88cc      	ldrh	r4, [r1, #6]
   220c6:	f9b1 c002 	ldrsh.w	ip, [r1, #2]
	u16_t w = area->x2 - area->x1 + 1;
   220ca:	f9b1 7000 	ldrsh.w	r7, [r1]
   220ce:	3301      	adds	r3, #1
	u16_t h = area->y2 - area->y1 + 1;
   220d0:	3401      	adds	r4, #1
{
   220d2:	b087      	sub	sp, #28
	u16_t h = area->y2 - area->y1 + 1;
   220d4:	eba4 040c 	sub.w	r4, r4, ip
{
   220d8:	4605      	mov	r5, r0
	u16_t w = area->x2 - area->x1 + 1;
   220da:	1bdb      	subs	r3, r3, r7
	struct device *display_dev = (struct device *)disp_drv->user_data;
   220dc:	6a00      	ldr	r0, [r0, #32]
	u16_t w = area->x2 - area->x1 + 1;
   220de:	b29b      	uxth	r3, r3
	u16_t h = area->y2 - area->y1 + 1;
   220e0:	b2a4      	uxth	r4, r4
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 3U * h;
   220e2:	fb04 f603 	mul.w	r6, r4, r3
	desc.width = w;
   220e6:	f8ad 3010 	strh.w	r3, [sp, #16]
	desc.pitch = w;
   220ea:	f8ad 3014 	strh.w	r3, [sp, #20]
   220ee:	6843      	ldr	r3, [r0, #4]
   220f0:	9200      	str	r2, [sp, #0]
	desc.buf_size = w * 3U * h;
   220f2:	eb06 0646 	add.w	r6, r6, r6, lsl #1
	desc.height = h;
   220f6:	f8ad 4012 	strh.w	r4, [sp, #18]
   220fa:	fa1f f28c 	uxth.w	r2, ip
   220fe:	689c      	ldr	r4, [r3, #8]
	desc.buf_size = w * 3U * h;
   22100:	9603      	str	r6, [sp, #12]
   22102:	ab03      	add	r3, sp, #12
   22104:	b2b9      	uxth	r1, r7
   22106:	47a0      	blx	r4
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);

	lv_disp_flush_ready(disp_drv);
   22108:	4628      	mov	r0, r5
   2210a:	f004 ff76 	bl	26ffa <lv_disp_flush_ready>
}
   2210e:	b007      	add	sp, #28
   22110:	bdf0      	pop	{r4, r5, r6, r7, pc}

00022112 <lvgl_set_px_cb_24bit>:

void lvgl_set_px_cb_24bit(struct _disp_drv_t *disp_drv,
		u8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
   22112:	b5f0      	push	{r4, r5, r6, r7, lr}
	u8_t *buf_xy = buf + x * 3U + y * 3U * buf_w;
   22114:	f9bd 5014 	ldrsh.w	r5, [sp, #20]
{
   22118:	f89d 401c 	ldrb.w	r4, [sp, #28]
   2211c:	9806      	ldr	r0, [sp, #24]
	u8_t *buf_xy = buf + x * 3U + y * 3U * buf_w;
   2211e:	fb05 3302 	mla	r3, r5, r2, r3
   22122:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	lv_color32_t converted_color;

#ifdef CONFIG_LVGL_COLOR_DEPTH_32
	if (opa != LV_OPA_COVER) {
   22126:	2cff      	cmp	r4, #255	; 0xff
	u8_t *buf_xy = buf + x * 3U + y * 3U * buf_w;
   22128:	eb01 0603 	add.w	r6, r1, r3
	if (opa != LV_OPA_COVER) {
   2212c:	d027      	beq.n	2217e <lvgl_set_px_cb_24bit+0x6c>
static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
   2212e:	5ccd      	ldrb	r5, [r1, r3]
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
   22130:	f896 c001 	ldrb.w	ip, [r6, #1]
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
   22134:	b2a2      	uxth	r2, r4
   22136:	f1c4 04ff 	rsb	r4, r4, #255	; 0xff
   2213a:	fb15 f504 	smulbb	r5, r5, r4
   2213e:	f3c0 4707 	ubfx	r7, r0, #16, #8
   22142:	fb07 5702 	mla	r7, r7, r2, r5
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
   22146:	fb1c fc04 	smulbb	ip, ip, r4
   2214a:	f3c0 2507 	ubfx	r5, r0, #8, #8
   2214e:	fb05 c502 	mla	r5, r5, r2, ip
    LV_COLOR_SET_B(ret, (uint16_t)((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) * (255 - mix)) >> 8);
   22152:	f896 c002 	ldrb.w	ip, [r6, #2]
   22156:	fa5f fe80 	uxtb.w	lr, r0
   2215a:	fb1c f404 	smulbb	r4, ip, r4
   2215e:	fb0e 4202 	mla	r2, lr, r2, r4
   22162:	f3c2 2207 	ubfx	r2, r2, #8, #8
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
   22166:	f3c5 2507 	ubfx	r5, r5, #8, #8
   2216a:	f362 0007 	bfi	r0, r2, #0, #8
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
   2216e:	f3c7 2707 	ubfx	r7, r7, #8, #8
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
   22172:	f365 200f 	bfi	r0, r5, #8, #8
   22176:	f367 4017 	bfi	r0, r7, #16, #8
   2217a:	f040 407f 	orr.w	r0, r0, #4278190080	; 0xff000000
		color = lv_color_mix(color, mix_color, opa);
	}
#endif

	converted_color.full = lv_color_to32(color);
	*buf_xy = converted_color.ch.red;
   2217e:	f3c0 4207 	ubfx	r2, r0, #16, #8
   22182:	54ca      	strb	r2, [r1, r3]
	*(buf_xy + 1) = converted_color.ch.green;
   22184:	f3c0 2307 	ubfx	r3, r0, #8, #8
   22188:	7073      	strb	r3, [r6, #1]
	*(buf_xy + 2) = converted_color.ch.blue;
   2218a:	70b0      	strb	r0, [r6, #2]
}
   2218c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0002218e <lvgl_flush_cb_32bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_32bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
   2218e:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct device *display_dev = (struct device *)disp_drv->user_data;
	u16_t w = area->x2 - area->x1 + 1;
   22190:	888b      	ldrh	r3, [r1, #4]
	u16_t h = area->y2 - area->y1 + 1;
   22192:	88cc      	ldrh	r4, [r1, #6]
	u16_t w = area->x2 - area->x1 + 1;
   22194:	f9b1 6000 	ldrsh.w	r6, [r1]
	u16_t h = area->y2 - area->y1 + 1;
   22198:	f9b1 7002 	ldrsh.w	r7, [r1, #2]
	u16_t w = area->x2 - area->x1 + 1;
   2219c:	3301      	adds	r3, #1
	u16_t h = area->y2 - area->y1 + 1;
   2219e:	3401      	adds	r4, #1
{
   221a0:	b087      	sub	sp, #28
   221a2:	4605      	mov	r5, r0
	u16_t w = area->x2 - area->x1 + 1;
   221a4:	1b9b      	subs	r3, r3, r6
	struct device *display_dev = (struct device *)disp_drv->user_data;
   221a6:	6a00      	ldr	r0, [r0, #32]
	u16_t h = area->y2 - area->y1 + 1;
   221a8:	1be4      	subs	r4, r4, r7
	u16_t w = area->x2 - area->x1 + 1;
   221aa:	b29b      	uxth	r3, r3
	u16_t h = area->y2 - area->y1 + 1;
   221ac:	b2a4      	uxth	r4, r4
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 4U * h;
   221ae:	fb04 f103 	mul.w	r1, r4, r3
	desc.width = w;
   221b2:	f8ad 3010 	strh.w	r3, [sp, #16]
	desc.pitch = w;
   221b6:	f8ad 3014 	strh.w	r3, [sp, #20]
   221ba:	6843      	ldr	r3, [r0, #4]
   221bc:	9200      	str	r2, [sp, #0]
	desc.buf_size = w * 4U * h;
   221be:	0089      	lsls	r1, r1, #2
   221c0:	9103      	str	r1, [sp, #12]
	desc.height = h;
   221c2:	f8ad 4012 	strh.w	r4, [sp, #18]
   221c6:	b2ba      	uxth	r2, r7
   221c8:	689c      	ldr	r4, [r3, #8]
   221ca:	b2b1      	uxth	r1, r6
   221cc:	ab03      	add	r3, sp, #12
   221ce:	47a0      	blx	r4
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);

	lv_disp_flush_ready(disp_drv);
   221d0:	4628      	mov	r0, r5
   221d2:	f004 ff12 	bl	26ffa <lv_disp_flush_ready>
}
   221d6:	b007      	add	sp, #28
   221d8:	bdf0      	pop	{r4, r5, r6, r7, pc}

000221da <z_platform_init>:

void z_platform_init(void)
{
	SystemInit();
   221da:	f7f7 be89 	b.w	19ef0 <SystemInit>

000221de <ah>:
#define BT_DBG_ENABLED IS_ENABLED(CONFIG_BT_DEBUG_RPA)
#define LOG_MODULE_NAME bt_rpa
#include "common/log.h"

static int ah(const u8_t irk[16], const u8_t r[3], u8_t out[3])
{
   221de:	b530      	push	{r4, r5, lr}
   221e0:	b085      	sub	sp, #20
   221e2:	4614      	mov	r4, r2

	BT_DBG("irk %s", bt_hex(irk, 16));
	BT_DBG("r %s", bt_hex(r, 3));

	/* r' = padding || r */
	memcpy(res, r, 3);
   221e4:	880a      	ldrh	r2, [r1, #0]
   221e6:	788b      	ldrb	r3, [r1, #2]
   221e8:	f8ad 2000 	strh.w	r2, [sp]
{
   221ec:	4605      	mov	r5, r0
	(void)memset(res + 3, 0, 13);
   221ee:	220d      	movs	r2, #13
   221f0:	2100      	movs	r1, #0
   221f2:	f10d 0003 	add.w	r0, sp, #3
	memcpy(res, r, 3);
   221f6:	f88d 3002 	strb.w	r3, [sp, #2]
	(void)memset(res + 3, 0, 13);
   221fa:	f7df fd18 	bl	1c2e <memset>

	err = bt_encrypt_le(irk, res, res);
   221fe:	466a      	mov	r2, sp
   22200:	4669      	mov	r1, sp
   22202:	4628      	mov	r0, r5
   22204:	f002 f8f9 	bl	243fa <bt_encrypt_le>
	if (err) {
   22208:	b928      	cbnz	r0, 22216 <ah+0x38>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   2220a:	f8bd 2000 	ldrh.w	r2, [sp]
   2220e:	f89d 3002 	ldrb.w	r3, [sp, #2]
   22212:	8022      	strh	r2, [r4, #0]
   22214:	70a3      	strb	r3, [r4, #2]
	 * result of ah.
	 */
	memcpy(out, res, 3);

	return 0;
}
   22216:	b005      	add	sp, #20
   22218:	bd30      	pop	{r4, r5, pc}

0002221a <bt_rpa_irk_matches>:

#if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_CTLR_PRIVACY)
bool bt_rpa_irk_matches(const u8_t irk[16], const bt_addr_t *addr)
{
   2221a:	b513      	push	{r0, r1, r4, lr}
   2221c:	460c      	mov	r4, r1
	u8_t hash[3];
	int err;

	BT_DBG("IRK %s bdaddr %s", bt_hex(irk, 16), bt_addr_str(addr));

	err = ah(irk, addr->val + 3, hash);
   2221e:	aa01      	add	r2, sp, #4
   22220:	3103      	adds	r1, #3
   22222:	f7ff ffdc 	bl	221de <ah>
	if (err) {
   22226:	b948      	cbnz	r0, 2223c <bt_rpa_irk_matches+0x22>
		return false;
	}

	return !memcmp(addr->val, hash, 3);
   22228:	2203      	movs	r2, #3
   2222a:	a901      	add	r1, sp, #4
   2222c:	4620      	mov	r0, r4
   2222e:	f7df fccf 	bl	1bd0 <memcmp>
   22232:	fab0 f080 	clz	r0, r0
   22236:	0940      	lsrs	r0, r0, #5
}
   22238:	b002      	add	sp, #8
   2223a:	bd10      	pop	{r4, pc}
		return false;
   2223c:	2000      	movs	r0, #0
   2223e:	e7fb      	b.n	22238 <bt_rpa_irk_matches+0x1e>

00022240 <bt_rpa_create>:
#endif

#if defined(CONFIG_BT_PRIVACY) || defined(CONFIG_BT_CTLR_PRIVACY)
int bt_rpa_create(const u8_t irk[16], bt_addr_t *rpa)
{
   22240:	b570      	push	{r4, r5, r6, lr}
	int err;

	err = bt_rand(rpa->val + 3, 3);
   22242:	1ccd      	adds	r5, r1, #3
{
   22244:	4606      	mov	r6, r0
   22246:	460c      	mov	r4, r1
	err = bt_rand(rpa->val + 3, 3);
   22248:	4628      	mov	r0, r5
   2224a:	2103      	movs	r1, #3
   2224c:	f7f0 f996 	bl	1257c <bt_rand>
	if (err) {
   22250:	b960      	cbnz	r0, 2226c <bt_rpa_create+0x2c>
		return err;
	}

	BT_ADDR_SET_RPA(rpa);
   22252:	7963      	ldrb	r3, [r4, #5]
   22254:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   22258:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   2225c:	7163      	strb	r3, [r4, #5]

	err = ah(irk, rpa->val + 3, rpa->val);
   2225e:	4622      	mov	r2, r4
   22260:	4629      	mov	r1, r5
   22262:	4630      	mov	r0, r6
	}

	BT_DBG("Created RPA %s", bt_addr_str((bt_addr_t *)rpa->val));

	return 0;
}
   22264:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	err = ah(irk, rpa->val + 3, rpa->val);
   22268:	f7ff bfb9 	b.w	221de <ah>
}
   2226c:	bd70      	pop	{r4, r5, r6, pc}

0002226e <send_cmd_status>:
{
   2226e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   22272:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
   22276:	4680      	mov	r8, r0
   22278:	460f      	mov	r7, r1
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   2227a:	200f      	movs	r0, #15
   2227c:	2100      	movs	r1, #0
   2227e:	f7e8 f90d 	bl	a49c <bt_buf_get_evt>
	*(u8_t *)net_buf_user_data(buf) = type;
   22282:	2501      	movs	r5, #1
	hdr = net_buf_add(buf, sizeof(*hdr));
   22284:	f100 0608 	add.w	r6, r0, #8
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   22288:	4604      	mov	r4, r0
   2228a:	7505      	strb	r5, [r0, #20]
	hdr = net_buf_add(buf, sizeof(*hdr));
   2228c:	2102      	movs	r1, #2
   2228e:	4630      	mov	r0, r6
   22290:	f002 fda2 	bl	24dd8 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_CMD_STATUS;
   22294:	230f      	movs	r3, #15
	hdr->len = sizeof(*evt);
   22296:	2104      	movs	r1, #4
	hdr->evt = BT_HCI_EVT_CMD_STATUS;
   22298:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*evt);
   2229a:	7041      	strb	r1, [r0, #1]
	evt = net_buf_add(buf, sizeof(*evt));
   2229c:	4630      	mov	r0, r6
   2229e:	f002 fd9b 	bl	24dd8 <net_buf_simple_add>
	evt->ncmd = 1U;
   222a2:	7045      	strb	r5, [r0, #1]
	evt->status = status;
   222a4:	7007      	strb	r7, [r0, #0]
	evt->opcode = sys_cpu_to_le16(opcode);
   222a6:	f8a0 8002 	strh.w	r8, [r0, #2]
	bt_recv_prio(buf);
   222aa:	4620      	mov	r0, r4
}
   222ac:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	bt_recv_prio(buf);
   222b0:	f7e7 ba34 	b.w	971c <bt_recv_prio>

000222b4 <sys_memcpy_swap.constprop.2>:
   222b4:	f101 0320 	add.w	r3, r1, #32
   222b8:	3801      	subs	r0, #1
		*pdst++ = *psrc--;
   222ba:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
   222be:	f800 2f01 	strb.w	r2, [r0, #1]!
	for (; length > 0; length--) {
   222c2:	428b      	cmp	r3, r1
   222c4:	d1f9      	bne.n	222ba <sys_memcpy_swap.constprop.2+0x6>
}
   222c6:	4770      	bx	lr

000222c8 <default_CSPRNG>:
{
   222c8:	b508      	push	{r3, lr}
	return !bt_rand(dst, len);
   222ca:	f7f0 f957 	bl	1257c <bt_rand>
}
   222ce:	fab0 f080 	clz	r0, r0
   222d2:	0940      	lsrs	r0, r0, #5
   222d4:	bd08      	pop	{r3, pc}

000222d6 <bt_settings_decode_key>:
{
   222d6:	b570      	push	{r4, r5, r6, lr}
   222d8:	460d      	mov	r5, r1
	if (settings_name_next(key, NULL) != 13) {
   222da:	2100      	movs	r1, #0
{
   222dc:	4604      	mov	r4, r0
	if (settings_name_next(key, NULL) != 13) {
   222de:	f7ff fb3a 	bl	21956 <settings_name_next>
   222e2:	280d      	cmp	r0, #13
   222e4:	d118      	bne.n	22318 <bt_settings_decode_key+0x42>
	if (key[12] == '0') {
   222e6:	7b23      	ldrb	r3, [r4, #12]
   222e8:	2b30      	cmp	r3, #48	; 0x30
   222ea:	d111      	bne.n	22310 <bt_settings_decode_key+0x3a>
		addr->type = BT_ADDR_LE_PUBLIC;
   222ec:	2300      	movs	r3, #0
   222ee:	702b      	strb	r3, [r5, #0]
   222f0:	f104 060c 	add.w	r6, r4, #12
   222f4:	3506      	adds	r5, #6
		hex2bin(&key[i * 2], 2, &addr->a.val[5 - i], 1);
   222f6:	462a      	mov	r2, r5
   222f8:	4620      	mov	r0, r4
   222fa:	2301      	movs	r3, #1
   222fc:	2102      	movs	r1, #2
   222fe:	3402      	adds	r4, #2
   22300:	f7fd f9d3 	bl	1f6aa <hex2bin>
	for (u8_t i = 0; i < 6; i++) {
   22304:	42b4      	cmp	r4, r6
   22306:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
   2230a:	d1f4      	bne.n	222f6 <bt_settings_decode_key+0x20>
	return 0;
   2230c:	2000      	movs	r0, #0
}
   2230e:	bd70      	pop	{r4, r5, r6, pc}
	} else if (key[12] == '1') {
   22310:	2b31      	cmp	r3, #49	; 0x31
   22312:	d101      	bne.n	22318 <bt_settings_decode_key+0x42>
		addr->type = BT_ADDR_LE_RANDOM;
   22314:	2301      	movs	r3, #1
   22316:	e7ea      	b.n	222ee <bt_settings_decode_key+0x18>
		return -EINVAL;
   22318:	f06f 0015 	mvn.w	r0, #21
   2231c:	e7f7      	b.n	2230e <bt_settings_decode_key+0x38>

0002231e <bt_uuid_cmp>:

	return memcmp(uuid1.val, uuid2.val, 16);
}

int bt_uuid_cmp(const struct bt_uuid *u1, const struct bt_uuid *u2)
{
   2231e:	b510      	push	{r4, lr}
   22320:	460c      	mov	r4, r1
	/* Convert to 128 bit if types don't match */
	if (u1->type != u2->type) {
   22322:	7801      	ldrb	r1, [r0, #0]
   22324:	7822      	ldrb	r2, [r4, #0]
   22326:	428a      	cmp	r2, r1
{
   22328:	b08a      	sub	sp, #40	; 0x28
	if (u1->type != u2->type) {
   2232a:	d00e      	beq.n	2234a <bt_uuid_cmp+0x2c>
	uuid_to_uuid128(u1, &uuid1);
   2232c:	4669      	mov	r1, sp
   2232e:	f7e5 fdef 	bl	7f10 <uuid_to_uuid128>
	uuid_to_uuid128(u2, &uuid2);
   22332:	a905      	add	r1, sp, #20
   22334:	4620      	mov	r0, r4
   22336:	f7e5 fdeb 	bl	7f10 <uuid_to_uuid128>
	return memcmp(uuid1.val, uuid2.val, 16);
   2233a:	2210      	movs	r2, #16
   2233c:	f10d 0115 	add.w	r1, sp, #21
   22340:	f10d 0001 	add.w	r0, sp, #1
	case BT_UUID_TYPE_16:
		return (int)BT_UUID_16(u1)->val - (int)BT_UUID_16(u2)->val;
	case BT_UUID_TYPE_32:
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
	case BT_UUID_TYPE_128:
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
   22344:	f7df fc44 	bl	1bd0 <memcmp>
   22348:	e006      	b.n	22358 <bt_uuid_cmp+0x3a>
	switch (u1->type) {
   2234a:	2a01      	cmp	r2, #1
   2234c:	d00a      	beq.n	22364 <bt_uuid_cmp+0x46>
   2234e:	b12a      	cbz	r2, 2235c <bt_uuid_cmp+0x3e>
   22350:	2a02      	cmp	r2, #2
   22352:	d00a      	beq.n	2236a <bt_uuid_cmp+0x4c>
	}

	return -EINVAL;
   22354:	f06f 0015 	mvn.w	r0, #21
}
   22358:	b00a      	add	sp, #40	; 0x28
   2235a:	bd10      	pop	{r4, pc}
		return (int)BT_UUID_16(u1)->val - (int)BT_UUID_16(u2)->val;
   2235c:	8840      	ldrh	r0, [r0, #2]
   2235e:	8863      	ldrh	r3, [r4, #2]
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
   22360:	1ac0      	subs	r0, r0, r3
   22362:	e7f9      	b.n	22358 <bt_uuid_cmp+0x3a>
   22364:	6840      	ldr	r0, [r0, #4]
   22366:	6863      	ldr	r3, [r4, #4]
   22368:	e7fa      	b.n	22360 <bt_uuid_cmp+0x42>
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
   2236a:	2210      	movs	r2, #16
   2236c:	1c61      	adds	r1, r4, #1
   2236e:	3001      	adds	r0, #1
   22370:	e7e8      	b.n	22344 <bt_uuid_cmp+0x26>

00022372 <bt_uuid_create>:

bool bt_uuid_create(struct bt_uuid *uuid, const u8_t *data, u8_t data_len)
{
	/* Copy UUID from packet data/internal variable to internal bt_uuid */
	switch (data_len) {
   22372:	2a04      	cmp	r2, #4
{
   22374:	b530      	push	{r4, r5, lr}
	switch (data_len) {
   22376:	d00d      	beq.n	22394 <bt_uuid_create+0x22>
   22378:	2a10      	cmp	r2, #16
   2237a:	d019      	beq.n	223b0 <bt_uuid_create+0x3e>
   2237c:	2a02      	cmp	r2, #2
   2237e:	f04f 0300 	mov.w	r3, #0
   22382:	d121      	bne.n	223c8 <bt_uuid_create+0x56>
	case 2:
		uuid->type = BT_UUID_TYPE_16;
   22384:	7003      	strb	r3, [r0, #0]
	return ((u16_t)src[1] << 8) | src[0];
   22386:	784a      	ldrb	r2, [r1, #1]
   22388:	780b      	ldrb	r3, [r1, #0]
   2238a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		BT_UUID_16(uuid)->val = sys_get_le16(data);
   2238e:	8043      	strh	r3, [r0, #2]
		memcpy(&BT_UUID_128(uuid)->val, data, 16);
		break;
	default:
		return false;
	}
	return true;
   22390:	2001      	movs	r0, #1
}
   22392:	bd30      	pop	{r4, r5, pc}
		uuid->type = BT_UUID_TYPE_32;
   22394:	2301      	movs	r3, #1
   22396:	7003      	strb	r3, [r0, #0]
   22398:	788a      	ldrb	r2, [r1, #2]
   2239a:	78cc      	ldrb	r4, [r1, #3]
   2239c:	784d      	ldrb	r5, [r1, #1]
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   2239e:	ea42 2404 	orr.w	r4, r2, r4, lsl #8
	return ((u16_t)src[1] << 8) | src[0];
   223a2:	780a      	ldrb	r2, [r1, #0]
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   223a4:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
   223a8:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
		BT_UUID_32(uuid)->val = sys_get_le32(data);
   223ac:	6042      	str	r2, [r0, #4]
		break;
   223ae:	e7ef      	b.n	22390 <bt_uuid_create+0x1e>
		uuid->type = BT_UUID_TYPE_128;
   223b0:	2302      	movs	r3, #2
   223b2:	f800 3b01 	strb.w	r3, [r0], #1
   223b6:	f101 0310 	add.w	r3, r1, #16
   223ba:	f851 2b04 	ldr.w	r2, [r1], #4
   223be:	f840 2b04 	str.w	r2, [r0], #4
   223c2:	4299      	cmp	r1, r3
   223c4:	d1f9      	bne.n	223ba <bt_uuid_create+0x48>
   223c6:	e7e3      	b.n	22390 <bt_uuid_create+0x1e>
		return false;
   223c8:	4618      	mov	r0, r3
   223ca:	e7e2      	b.n	22392 <bt_uuid_create+0x20>

000223cc <atomic_and>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   223cc:	f3bf 8f5b 	dmb	ish
   223d0:	e850 3f00 	ldrex	r3, [r0]
   223d4:	ea03 0201 	and.w	r2, r3, r1
   223d8:	e840 2c00 	strex	ip, r2, [r0]
   223dc:	f1bc 0f00 	cmp.w	ip, #0
   223e0:	d1f6      	bne.n	223d0 <atomic_and+0x4>
   223e2:	f3bf 8f5b 	dmb	ish
}
   223e6:	4618      	mov	r0, r3
   223e8:	4770      	bx	lr

000223ea <atomic_or>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   223ea:	f3bf 8f5b 	dmb	ish
   223ee:	e850 3f00 	ldrex	r3, [r0]
   223f2:	ea43 0201 	orr.w	r2, r3, r1
   223f6:	e840 2c00 	strex	ip, r2, [r0]
   223fa:	f1bc 0f00 	cmp.w	ip, #0
   223fe:	d1f6      	bne.n	223ee <atomic_or+0x4>
   22400:	f3bf 8f5b 	dmb	ish
}
   22404:	4618      	mov	r0, r3
   22406:	4770      	bx	lr

00022408 <atomic_set_bit_to>:
 * @param val true for 1, false for 0.
 *
 * @return N/A
 */
static inline void atomic_set_bit_to(atomic_t *target, int bit, bool val)
{
   22408:	460b      	mov	r3, r1
   2240a:	b410      	push	{r4}
   2240c:	095b      	lsrs	r3, r3, #5
	atomic_val_t mask = ATOMIC_MASK(bit);
   2240e:	f001 041f 	and.w	r4, r1, #31
   22412:	2101      	movs	r1, #1
   22414:	40a1      	lsls	r1, r4

	if (val) {
   22416:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   2241a:	b112      	cbz	r2, 22422 <atomic_set_bit_to+0x1a>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
	} else {
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
	}
}
   2241c:	bc10      	pop	{r4}
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   2241e:	f7ff bfe4 	b.w	223ea <atomic_or>
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   22422:	43c9      	mvns	r1, r1
}
   22424:	bc10      	pop	{r4}
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   22426:	f7ff bfd1 	b.w	223cc <atomic_and>

0002242a <unpair>:
{
   2242a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2242c:	4606      	mov	r6, r0
   2242e:	460f      	mov	r7, r1
	struct bt_conn *conn = bt_conn_lookup_addr_le(id, addr);
   22430:	f7e8 fcfe 	bl	ae30 <bt_conn_lookup_addr_le>
	if (conn) {
   22434:	4604      	mov	r4, r0
   22436:	b970      	cbnz	r0, 22456 <unpair+0x2c>
			keys = bt_keys_find_addr(id, addr);
   22438:	4639      	mov	r1, r7
   2243a:	4630      	mov	r0, r6
   2243c:	f7ed ff5a 	bl	102f4 <bt_keys_find_addr>
		if (keys) {
   22440:	4605      	mov	r5, r0
   22442:	b110      	cbz	r0, 2244a <unpair+0x20>
			bt_keys_clear(keys);
   22444:	4628      	mov	r0, r5
   22446:	f7ed ff65 	bl	10314 <bt_keys_clear>
		bt_gatt_clear(id, addr);
   2244a:	4639      	mov	r1, r7
   2244c:	4630      	mov	r0, r6
}
   2244e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		bt_gatt_clear(id, addr);
   22452:	f7ec b87f 	b.w	e554 <bt_gatt_clear>
		if (conn->type == BT_CONN_TYPE_LE) {
   22456:	7883      	ldrb	r3, [r0, #2]
   22458:	2b01      	cmp	r3, #1
   2245a:	f04f 0300 	mov.w	r3, #0
			keys = conn->le.keys;
   2245e:	bf04      	itt	eq
   22460:	f8d0 50a0 	ldreq.w	r5, [r0, #160]	; 0xa0
			conn->le.keys = NULL;
   22464:	f8c0 30a0 	streq.w	r3, [r0, #160]	; 0xa0
		bt_conn_disconnect(conn, BT_HCI_ERR_REMOTE_USER_TERM_CONN);
   22468:	f04f 0113 	mov.w	r1, #19
	struct bt_keys *keys = NULL;
   2246c:	bf18      	it	ne
   2246e:	461d      	movne	r5, r3
		bt_conn_disconnect(conn, BT_HCI_ERR_REMOTE_USER_TERM_CONN);
   22470:	f000 f95a 	bl	22728 <bt_conn_disconnect>
		bt_conn_unref(conn);
   22474:	4620      	mov	r0, r4
   22476:	f000 f952 	bl	2271e <bt_conn_unref>
		if (!keys) {
   2247a:	2d00      	cmp	r5, #0
   2247c:	d1e2      	bne.n	22444 <unpair+0x1a>
   2247e:	e7db      	b.n	22438 <unpair+0xe>

00022480 <unpair_remote>:
	unpair(*id, &info->addr);
   22480:	780b      	ldrb	r3, [r1, #0]
   22482:	4601      	mov	r1, r0
   22484:	4618      	mov	r0, r3
   22486:	f7ff bfd0 	b.w	2242a <unpair>

0002248a <bt_addr_copy>:
   2248a:	680b      	ldr	r3, [r1, #0]
   2248c:	6003      	str	r3, [r0, #0]
   2248e:	888b      	ldrh	r3, [r1, #4]
   22490:	8083      	strh	r3, [r0, #4]
}
   22492:	4770      	bx	lr

00022494 <bt_addr_le_copy>:
   22494:	680b      	ldr	r3, [r1, #0]
   22496:	6003      	str	r3, [r0, #0]
   22498:	888b      	ldrh	r3, [r1, #4]
   2249a:	8083      	strh	r3, [r0, #4]
   2249c:	798b      	ldrb	r3, [r1, #6]
   2249e:	7183      	strb	r3, [r0, #6]
}
   224a0:	4770      	bx	lr

000224a2 <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   224a2:	f3bf 8f5b 	dmb	ish
   224a6:	6800      	ldr	r0, [r0, #0]
   224a8:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   224ac:	4108      	asrs	r0, r1
}
   224ae:	f000 0001 	and.w	r0, r0, #1
   224b2:	4770      	bx	lr

000224b4 <sys_put_le64>:
	dst[1] = val >> 8;
   224b4:	f3c0 2307 	ubfx	r3, r0, #8, #8
	dst[0] = val;
   224b8:	7010      	strb	r0, [r2, #0]
	dst[1] = val >> 8;
   224ba:	0e00      	lsrs	r0, r0, #24
   224bc:	7053      	strb	r3, [r2, #1]
   224be:	70d0      	strb	r0, [r2, #3]
	dst[0] = val;
   224c0:	2300      	movs	r3, #0
	dst[1] = val >> 8;
   224c2:	f3c1 2007 	ubfx	r0, r1, #8, #8
   224c6:	0e09      	lsrs	r1, r1, #24
	dst[0] = val;
   224c8:	7093      	strb	r3, [r2, #2]
   224ca:	7113      	strb	r3, [r2, #4]
	dst[1] = val >> 8;
   224cc:	7150      	strb	r0, [r2, #5]
	dst[0] = val;
   224ce:	7193      	strb	r3, [r2, #6]
	dst[1] = val >> 8;
   224d0:	71d1      	strb	r1, [r2, #7]
}
   224d2:	4770      	bx	lr

000224d4 <keys_add_id>:
	hci_id_add(&keys->addr, keys->irk.val);
   224d4:	f100 0126 	add.w	r1, r0, #38	; 0x26
   224d8:	3001      	adds	r0, #1
   224da:	f7e6 bc49 	b.w	8d70 <hci_id_add>

000224de <addr_res_enable>:
{
   224de:	b538      	push	{r3, r4, r5, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE, 1);
   224e0:	2101      	movs	r1, #1
{
   224e2:	4605      	mov	r5, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE, 1);
   224e4:	f242 002d 	movw	r0, #8237	; 0x202d
   224e8:	f7e6 f9c8 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
   224ec:	4604      	mov	r4, r0
   224ee:	b158      	cbz	r0, 22508 <addr_res_enable+0x2a>
	net_buf_add_u8(buf, enable);
   224f0:	4629      	mov	r1, r5
   224f2:	3008      	adds	r0, #8
   224f4:	f002 fc80 	bl	24df8 <net_buf_simple_add_u8>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE,
   224f8:	4621      	mov	r1, r4
   224fa:	2200      	movs	r2, #0
   224fc:	f242 002d 	movw	r0, #8237	; 0x202d
}
   22500:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE,
   22504:	f7e6 bb30 	b.w	8b68 <bt_hci_cmd_send_sync>
}
   22508:	f06f 0068 	mvn.w	r0, #104	; 0x68
   2250c:	bd38      	pop	{r3, r4, r5, pc}

0002250e <bt_lookup_id_addr>:
{
   2250e:	b510      	push	{r4, lr}
   22510:	460c      	mov	r4, r1
		keys = bt_keys_find_irk(id, addr);
   22512:	f7ed feb5 	bl	10280 <bt_keys_find_irk>
		if (keys) {
   22516:	b100      	cbz	r0, 2251a <bt_lookup_id_addr+0xc>
			return &keys->addr;
   22518:	1c44      	adds	r4, r0, #1
}
   2251a:	4620      	mov	r0, r4
   2251c:	bd10      	pop	{r4, pc}

0002251e <bt_le_conn_params_valid>:
	if (param->interval_min > param->interval_max ||
   2251e:	8802      	ldrh	r2, [r0, #0]
   22520:	8843      	ldrh	r3, [r0, #2]
   22522:	429a      	cmp	r2, r3
{
   22524:	b510      	push	{r4, lr}
	if (param->interval_min > param->interval_max ||
   22526:	d818      	bhi.n	2255a <bt_le_conn_params_valid+0x3c>
   22528:	2a05      	cmp	r2, #5
   2252a:	d916      	bls.n	2255a <bt_le_conn_params_valid+0x3c>
	    param->interval_min < 6 || param->interval_max > 3200) {
   2252c:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   22530:	d813      	bhi.n	2255a <bt_le_conn_params_valid+0x3c>
	if (param->latency > 499) {
   22532:	8884      	ldrh	r4, [r0, #4]
   22534:	f5b4 7ffa 	cmp.w	r4, #500	; 0x1f4
   22538:	d20f      	bcs.n	2255a <bt_le_conn_params_valid+0x3c>
	if (param->timeout < 10 || param->timeout > 3200 ||
   2253a:	88c1      	ldrh	r1, [r0, #6]
   2253c:	f1a1 020a 	sub.w	r2, r1, #10
   22540:	b292      	uxth	r2, r2
   22542:	f640 4076 	movw	r0, #3190	; 0xc76
   22546:	4282      	cmp	r2, r0
   22548:	d807      	bhi.n	2255a <bt_le_conn_params_valid+0x3c>
	     ((1 + param->latency) * param->interval_max))) {
   2254a:	fb04 3303 	mla	r3, r4, r3, r3
	if (param->timeout < 10 || param->timeout > 3200 ||
   2254e:	ebb3 0f81 	cmp.w	r3, r1, lsl #2
   22552:	bf34      	ite	cc
   22554:	2001      	movcc	r0, #1
   22556:	2000      	movcs	r0, #0
}
   22558:	bd10      	pop	{r4, pc}
		return false;
   2255a:	2000      	movs	r0, #0
   2255c:	e7fc      	b.n	22558 <bt_le_conn_params_valid+0x3a>

0002255e <update_pending_id>:
	if (keys->flags & BT_KEYS_ID_PENDING_ADD) {
   2255e:	7a43      	ldrb	r3, [r0, #9]
   22560:	0759      	lsls	r1, r3, #29
   22562:	d504      	bpl.n	2256e <update_pending_id+0x10>
		keys->flags &= ~BT_KEYS_ID_PENDING_ADD;
   22564:	f023 0304 	bic.w	r3, r3, #4
   22568:	7243      	strb	r3, [r0, #9]
		bt_id_add(keys);
   2256a:	f7e6 be47 	b.w	91fc <bt_id_add>
	if (keys->flags & BT_KEYS_ID_PENDING_DEL) {
   2256e:	0719      	lsls	r1, r3, #28
   22570:	d504      	bpl.n	2257c <update_pending_id+0x1e>
		keys->flags &= ~BT_KEYS_ID_PENDING_DEL;
   22572:	f023 0308 	bic.w	r3, r3, #8
   22576:	7243      	strb	r3, [r0, #9]
		bt_id_del(keys);
   22578:	f7e6 bf1e 	b.w	93b8 <bt_id_del>
}
   2257c:	4770      	bx	lr

0002257e <bt_addr_le_create_static>:
	addr->type = BT_ADDR_LE_RANDOM;
   2257e:	2301      	movs	r3, #1
{
   22580:	b510      	push	{r4, lr}
	return bt_rand(addr->a.val, 6);
   22582:	2106      	movs	r1, #6
{
   22584:	4604      	mov	r4, r0
	addr->type = BT_ADDR_LE_RANDOM;
   22586:	f800 3b01 	strb.w	r3, [r0], #1
	return bt_rand(addr->a.val, 6);
   2258a:	f7ef fff7 	bl	1257c <bt_rand>
	if (err) {
   2258e:	b918      	cbnz	r0, 22598 <bt_addr_le_create_static+0x1a>
	BT_ADDR_SET_STATIC(&addr->a);
   22590:	79a3      	ldrb	r3, [r4, #6]
   22592:	f063 033f 	orn	r3, r3, #63	; 0x3f
   22596:	71a3      	strb	r3, [r4, #6]
}
   22598:	bd10      	pop	{r4, pc}

0002259a <bt_send>:
		return bt_hci_ecc_send(buf);
   2259a:	f7e5 ba4f 	b.w	7a3c <bt_hci_ecc_send>

0002259e <bt_addr_le_is_bonded>:
{
   2259e:	b508      	push	{r3, lr}
		struct bt_keys *keys = bt_keys_find_addr(id, addr);
   225a0:	f7ed fea8 	bl	102f4 <bt_keys_find_addr>
		return keys && keys->keys;
   225a4:	b118      	cbz	r0, 225ae <bt_addr_le_is_bonded+0x10>
   225a6:	8940      	ldrh	r0, [r0, #10]
   225a8:	3000      	adds	r0, #0
   225aa:	bf18      	it	ne
   225ac:	2001      	movne	r0, #1
}
   225ae:	bd08      	pop	{r3, pc}

000225b0 <bt_le_adv_start>:
{
   225b0:	b513      	push	{r0, r1, r4, lr}
	if (param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) {
   225b2:	7844      	ldrb	r4, [r0, #1]
   225b4:	f014 0410 	ands.w	r4, r4, #16
   225b8:	d106      	bne.n	225c8 <bt_le_adv_start+0x18>
	return bt_le_adv_start_internal(param, ad, ad_len, sd, sd_len, NULL);
   225ba:	9401      	str	r4, [sp, #4]
   225bc:	9c04      	ldr	r4, [sp, #16]
   225be:	9400      	str	r4, [sp, #0]
   225c0:	f7e7 fc04 	bl	9dcc <bt_le_adv_start_internal>
}
   225c4:	b002      	add	sp, #8
   225c6:	bd10      	pop	{r4, pc}
		return -EINVAL;
   225c8:	f06f 0015 	mvn.w	r0, #21
   225cc:	e7fa      	b.n	225c4 <bt_le_adv_start+0x14>

000225ce <le_enh_conn_complete>:
	enh_conn_complete((void *)buf->data);
   225ce:	6880      	ldr	r0, [r0, #8]
   225d0:	f7e7 be10 	b.w	a1f4 <enh_conn_complete>

000225d4 <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   225d4:	f3bf 8f5b 	dmb	ish
   225d8:	6800      	ldr	r0, [r0, #0]
   225da:	f3bf 8f5b 	dmb	ish
}
   225de:	4770      	bx	lr

000225e0 <atomic_test_bit>:
{
   225e0:	b508      	push	{r3, lr}
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   225e2:	f7ff fff7 	bl	225d4 <atomic_get>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   225e6:	4108      	asrs	r0, r1
}
   225e8:	f000 0001 	and.w	r0, r0, #1
   225ec:	bd08      	pop	{r3, pc}

000225ee <bt_conn_reset_rx_state>:
	if (!conn->rx_len) {
   225ee:	89c3      	ldrh	r3, [r0, #14]
{
   225f0:	b510      	push	{r4, lr}
   225f2:	4604      	mov	r4, r0
	if (!conn->rx_len) {
   225f4:	b12b      	cbz	r3, 22602 <bt_conn_reset_rx_state+0x14>
	net_buf_unref(conn->rx);
   225f6:	6900      	ldr	r0, [r0, #16]
   225f8:	f7f6 fd30 	bl	1905c <net_buf_unref>
	conn->rx = NULL;
   225fc:	2300      	movs	r3, #0
   225fe:	6123      	str	r3, [r4, #16]
	conn->rx_len = 0U;
   22600:	81e3      	strh	r3, [r4, #14]
}
   22602:	bd10      	pop	{r4, pc}

00022604 <atomic_dec>:
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   22604:	f3bf 8f5b 	dmb	ish
   22608:	e850 3f00 	ldrex	r3, [r0]
   2260c:	1e5a      	subs	r2, r3, #1
   2260e:	e840 2100 	strex	r1, r2, [r0]
   22612:	2900      	cmp	r1, #0
   22614:	d1f8      	bne.n	22608 <atomic_dec+0x4>
   22616:	f3bf 8f5b 	dmb	ish
}
   2261a:	4618      	mov	r0, r3
   2261c:	4770      	bx	lr

0002261e <atomic_inc>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   2261e:	f3bf 8f5b 	dmb	ish
   22622:	e850 3f00 	ldrex	r3, [r0]
   22626:	1c5a      	adds	r2, r3, #1
   22628:	e840 2100 	strex	r1, r2, [r0]
   2262c:	2900      	cmp	r1, #0
   2262e:	d1f8      	bne.n	22622 <atomic_inc+0x4>
   22630:	f3bf 8f5b 	dmb	ish
}
   22634:	4618      	mov	r0, r3
   22636:	4770      	bx	lr

00022638 <tx_notify>:
{
   22638:	b570      	push	{r4, r5, r6, lr}
   2263a:	4604      	mov	r4, r0
	__asm__ volatile(
   2263c:	f04f 0220 	mov.w	r2, #32
   22640:	f3ef 8311 	mrs	r3, BASEPRI
   22644:	f382 8811 	msr	BASEPRI, r2
   22648:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
   2264c:	6a20      	ldr	r0, [r4, #32]
		if (sys_slist_is_empty(&conn->tx_complete)) {
   2264e:	b920      	cbnz	r0, 2265a <tx_notify+0x22>
	__asm__ volatile(
   22650:	f383 8811 	msr	BASEPRI, r3
   22654:	f3bf 8f6f 	isb	sy
}
   22658:	bd70      	pop	{r4, r5, r6, pc}
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2265a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   2265c:	6802      	ldr	r2, [r0, #0]
	list->head = node;
   2265e:	6222      	str	r2, [r4, #32]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   22660:	4288      	cmp	r0, r1
	list->tail = node;
   22662:	bf08      	it	eq
   22664:	6262      	streq	r2, [r4, #36]	; 0x24
   22666:	f383 8811 	msr	BASEPRI, r3
   2266a:	f3bf 8f6f 	isb	sy
		user_data = tx->user_data;
   2266e:	e9d0 5601 	ldrd	r5, r6, [r0, #4]
		tx_free(tx);
   22672:	f7e7 ffe3 	bl	a63c <tx_free>
		cb(conn, user_data);
   22676:	4631      	mov	r1, r6
   22678:	4620      	mov	r0, r4
   2267a:	47a8      	blx	r5
	while (1) {
   2267c:	e7de      	b.n	2263c <tx_notify+0x4>

0002267e <tx_complete_work>:
	tx_notify(conn);
   2267e:	3828      	subs	r0, #40	; 0x28
   22680:	f7ff bfda 	b.w	22638 <tx_notify>

00022684 <bt_conn_set_security>:
	if (conn->state != BT_CONN_CONNECTED) {
   22684:	7b43      	ldrb	r3, [r0, #13]
   22686:	2b06      	cmp	r3, #6
{
   22688:	b510      	push	{r4, lr}
   2268a:	4604      	mov	r4, r0
	if (conn->state != BT_CONN_CONNECTED) {
   2268c:	d128      	bne.n	226e0 <bt_conn_set_security+0x5c>
	if (conn->sec_level >= sec || conn->required_sec_level >= sec) {
   2268e:	7a43      	ldrb	r3, [r0, #9]
   22690:	428b      	cmp	r3, r1
   22692:	d228      	bcs.n	226e6 <bt_conn_set_security+0x62>
   22694:	7a83      	ldrb	r3, [r0, #10]
   22696:	428b      	cmp	r3, r1
   22698:	d225      	bcs.n	226e6 <bt_conn_set_security+0x62>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2269a:	f3bf 8f5b 	dmb	ish
	if (val) {
   2269e:	060a      	lsls	r2, r1, #24
	atomic_set_bit_to(conn->flags, BT_CONN_FORCE_PAIR,
   226a0:	f100 0304 	add.w	r3, r0, #4
   226a4:	d513      	bpl.n	226ce <bt_conn_set_security+0x4a>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   226a6:	e853 2f00 	ldrex	r2, [r3]
   226aa:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
   226ae:	e843 2000 	strex	r0, r2, [r3]
   226b2:	2800      	cmp	r0, #0
   226b4:	d1f7      	bne.n	226a6 <bt_conn_set_security+0x22>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   226b6:	f3bf 8f5b 	dmb	ish
	conn->required_sec_level = sec & ~BT_SECURITY_FORCE_PAIR;
   226ba:	f001 017f 	and.w	r1, r1, #127	; 0x7f
   226be:	72a1      	strb	r1, [r4, #10]
		return bt_smp_start_security(conn);
   226c0:	4620      	mov	r0, r4
   226c2:	f7ed fbed 	bl	fea0 <bt_smp_start_security>
	if (err) {
   226c6:	b108      	cbz	r0, 226cc <bt_conn_set_security+0x48>
		conn->required_sec_level = conn->sec_level;
   226c8:	7a63      	ldrb	r3, [r4, #9]
   226ca:	72a3      	strb	r3, [r4, #10]
}
   226cc:	bd10      	pop	{r4, pc}
   226ce:	e853 2f00 	ldrex	r2, [r3]
   226d2:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
   226d6:	e843 2000 	strex	r0, r2, [r3]
   226da:	2800      	cmp	r0, #0
   226dc:	d0eb      	beq.n	226b6 <bt_conn_set_security+0x32>
   226de:	e7f6      	b.n	226ce <bt_conn_set_security+0x4a>
		return -ENOTCONN;
   226e0:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   226e4:	e7f2      	b.n	226cc <bt_conn_set_security+0x48>
		return 0;
   226e6:	2000      	movs	r0, #0
   226e8:	e7f0      	b.n	226cc <bt_conn_set_security+0x48>

000226ea <bt_conn_get_security>:
}
   226ea:	7a40      	ldrb	r0, [r0, #9]
   226ec:	4770      	bx	lr

000226ee <bt_conn_addr_le_cmp>:
{
   226ee:	b538      	push	{r3, r4, r5, lr}
   226f0:	460d      	mov	r5, r1
   226f2:	4604      	mov	r4, r0
	return memcmp(a, b, sizeof(*a));
   226f4:	f100 0174 	add.w	r1, r0, #116	; 0x74
   226f8:	2207      	movs	r2, #7
   226fa:	4628      	mov	r0, r5
   226fc:	f7df fa68 	bl	1bd0 <memcmp>
	if (!bt_addr_le_cmp(peer, &conn->le.dst)) {
   22700:	b160      	cbz	r0, 2271c <bt_conn_addr_le_cmp+0x2e>
	if (conn->role == BT_HCI_ROLE_MASTER) {
   22702:	78e3      	ldrb	r3, [r4, #3]
   22704:	2207      	movs	r2, #7
   22706:	b933      	cbnz	r3, 22716 <bt_conn_addr_le_cmp+0x28>
   22708:	f104 0182 	add.w	r1, r4, #130	; 0x82
   2270c:	4628      	mov	r0, r5
}
   2270e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   22712:	f7df ba5d 	b.w	1bd0 <memcmp>
   22716:	f104 017b 	add.w	r1, r4, #123	; 0x7b
   2271a:	e7f7      	b.n	2270c <bt_conn_addr_le_cmp+0x1e>
   2271c:	bd38      	pop	{r3, r4, r5, pc}

0002271e <bt_conn_unref>:
	atomic_dec(&conn->ref);
   2271e:	3050      	adds	r0, #80	; 0x50
   22720:	f7ff bf70 	b.w	22604 <atomic_dec>

00022724 <bt_conn_get_dst>:
}
   22724:	3074      	adds	r0, #116	; 0x74
   22726:	4770      	bx	lr

00022728 <bt_conn_disconnect>:
	switch (conn->state) {
   22728:	7b43      	ldrb	r3, [r0, #13]
   2272a:	3b01      	subs	r3, #1
{
   2272c:	b570      	push	{r4, r5, r6, lr}
   2272e:	4604      	mov	r4, r0
   22730:	460e      	mov	r6, r1
	switch (conn->state) {
   22732:	2b06      	cmp	r3, #6
   22734:	d805      	bhi.n	22742 <bt_conn_disconnect+0x1a>
   22736:	e8df f003 	tbb	[pc, r3]
   2273a:	0408      	.short	0x0408
   2273c:	160c0e04 	.word	0x160c0e04
   22740:	0c          	.byte	0x0c
   22741:	00          	.byte	0x00
		return -ENOTCONN;
   22742:	f06f 057f 	mvn.w	r5, #127	; 0x7f
}
   22746:	4628      	mov	r0, r5
   22748:	bd70      	pop	{r4, r5, r6, pc}
		conn->err = reason;
   2274a:	7321      	strb	r1, [r4, #12]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   2274c:	2100      	movs	r1, #0
   2274e:	f7e8 fa8b 	bl	ac68 <bt_conn_set_state>
		return 0;
   22752:	2500      	movs	r5, #0
   22754:	e7f7      	b.n	22746 <bt_conn_disconnect+0x1e>
		conn->err = reason;
   22756:	7321      	strb	r1, [r4, #12]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   22758:	2100      	movs	r1, #0
   2275a:	f7e8 fa85 	bl	ac68 <bt_conn_set_state>
}
   2275e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			return bt_le_adv_stop();
   22762:	f7e7 bc8d 	b.w	a080 <bt_le_adv_stop>
	buf = bt_hci_cmd_create(BT_HCI_OP_DISCONNECT, sizeof(*disconn));
   22766:	2103      	movs	r1, #3
   22768:	f240 4006 	movw	r0, #1030	; 0x406
   2276c:	f7e6 f886 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
   22770:	4605      	mov	r5, r0
   22772:	b198      	cbz	r0, 2279c <bt_conn_disconnect+0x74>
	disconn = net_buf_add(buf, sizeof(*disconn));
   22774:	2103      	movs	r1, #3
   22776:	3008      	adds	r0, #8
   22778:	f002 fb2e 	bl	24dd8 <net_buf_simple_add>
	disconn->handle = sys_cpu_to_le16(conn->handle);
   2277c:	8823      	ldrh	r3, [r4, #0]
   2277e:	8003      	strh	r3, [r0, #0]
	disconn->reason = reason;
   22780:	7086      	strb	r6, [r0, #2]
	err = bt_hci_cmd_send(BT_HCI_OP_DISCONNECT, buf);
   22782:	4629      	mov	r1, r5
   22784:	f240 4006 	movw	r0, #1030	; 0x406
   22788:	f7e6 f8ae 	bl	88e8 <bt_hci_cmd_send>
	if (err) {
   2278c:	4605      	mov	r5, r0
   2278e:	2800      	cmp	r0, #0
   22790:	d1d9      	bne.n	22746 <bt_conn_disconnect+0x1e>
	bt_conn_set_state(conn, BT_CONN_DISCONNECT);
   22792:	2107      	movs	r1, #7
   22794:	4620      	mov	r0, r4
   22796:	f7e8 fa67 	bl	ac68 <bt_conn_set_state>
	return 0;
   2279a:	e7d4      	b.n	22746 <bt_conn_disconnect+0x1e>
		return -ENOBUFS;
   2279c:	f06f 0568 	mvn.w	r5, #104	; 0x68
   227a0:	e7d1      	b.n	22746 <bt_conn_disconnect+0x1e>

000227a2 <bt_conn_le_conn_update>:
{
   227a2:	b570      	push	{r4, r5, r6, lr}
   227a4:	4606      	mov	r6, r0
   227a6:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_UPDATE,
   227a8:	f242 0013 	movw	r0, #8211	; 0x2013
   227ac:	210e      	movs	r1, #14
   227ae:	f7e6 f865 	bl	887c <bt_hci_cmd_create>
	if (!buf) {
   227b2:	4605      	mov	r5, r0
   227b4:	b1c8      	cbz	r0, 227ea <bt_conn_le_conn_update+0x48>
	conn_update = net_buf_add(buf, sizeof(*conn_update));
   227b6:	210e      	movs	r1, #14
   227b8:	3008      	adds	r0, #8
   227ba:	f002 fb0d 	bl	24dd8 <net_buf_simple_add>
__ssp_bos_icheck3(memset, void *, int)
   227be:	220e      	movs	r2, #14
   227c0:	2100      	movs	r1, #0
   227c2:	f7df fa34 	bl	1c2e <memset>
	conn_update->handle = sys_cpu_to_le16(conn->handle);
   227c6:	8832      	ldrh	r2, [r6, #0]
   227c8:	8002      	strh	r2, [r0, #0]
	conn_update->conn_interval_min = sys_cpu_to_le16(param->interval_min);
   227ca:	8822      	ldrh	r2, [r4, #0]
   227cc:	8042      	strh	r2, [r0, #2]
	conn_update->conn_interval_max = sys_cpu_to_le16(param->interval_max);
   227ce:	8862      	ldrh	r2, [r4, #2]
   227d0:	8082      	strh	r2, [r0, #4]
	conn_update->conn_latency = sys_cpu_to_le16(param->latency);
   227d2:	88a2      	ldrh	r2, [r4, #4]
   227d4:	80c2      	strh	r2, [r0, #6]
	conn_update->supervision_timeout = sys_cpu_to_le16(param->timeout);
   227d6:	88e2      	ldrh	r2, [r4, #6]
   227d8:	8102      	strh	r2, [r0, #8]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   227da:	4629      	mov	r1, r5
   227dc:	2200      	movs	r2, #0
   227de:	f242 0013 	movw	r0, #8211	; 0x2013
}
   227e2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   227e6:	f7e6 b9bf 	b.w	8b68 <bt_hci_cmd_send_sync>
}
   227ea:	f06f 0068 	mvn.w	r0, #104	; 0x68
   227ee:	bd70      	pop	{r4, r5, r6, pc}

000227f0 <l2cap_connected>:
}
   227f0:	4770      	bx	lr

000227f2 <l2cap_disconnected>:
   227f2:	4770      	bx	lr

000227f4 <bt_l2cap_chan_remove>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   227f4:	6c83      	ldr	r3, [r0, #72]	; 0x48
{
   227f6:	b510      	push	{r4, lr}
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   227f8:	b17b      	cbz	r3, 2281a <bt_l2cap_chan_remove+0x26>
   227fa:	3b08      	subs	r3, #8
   227fc:	2200      	movs	r2, #0
   227fe:	b163      	cbz	r3, 2281a <bt_l2cap_chan_remove+0x26>
		if (chan == ch) {
   22800:	428b      	cmp	r3, r1
   22802:	f103 0408 	add.w	r4, r3, #8
   22806:	d10f      	bne.n	22828 <bt_l2cap_chan_remove+0x34>
Z_GENLIST_REMOVE(slist, snode)
   22808:	688b      	ldr	r3, [r1, #8]
   2280a:	b93a      	cbnz	r2, 2281c <bt_l2cap_chan_remove+0x28>
   2280c:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
	list->head = node;
   2280e:	6483      	str	r3, [r0, #72]	; 0x48
Z_GENLIST_REMOVE(slist, snode)
   22810:	4294      	cmp	r4, r2
   22812:	d100      	bne.n	22816 <bt_l2cap_chan_remove+0x22>
	list->tail = node;
   22814:	64c3      	str	r3, [r0, #76]	; 0x4c
	parent->next = child;
   22816:	2300      	movs	r3, #0
   22818:	608b      	str	r3, [r1, #8]
}
   2281a:	bd10      	pop	{r4, pc}
   2281c:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   2281e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   22820:	429c      	cmp	r4, r3
	list->tail = node;
   22822:	bf08      	it	eq
   22824:	64c2      	streq	r2, [r0, #76]	; 0x4c
   22826:	e7f6      	b.n	22816 <bt_l2cap_chan_remove+0x22>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   22828:	689b      	ldr	r3, [r3, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   2282a:	2b00      	cmp	r3, #0
   2282c:	d0f5      	beq.n	2281a <bt_l2cap_chan_remove+0x26>
   2282e:	3b08      	subs	r3, #8
   22830:	4622      	mov	r2, r4
   22832:	e7e4      	b.n	227fe <bt_l2cap_chan_remove+0xa>

00022834 <bt_l2cap_chan_del>:
	if (!chan->conn) {
   22834:	6803      	ldr	r3, [r0, #0]
{
   22836:	b510      	push	{r4, lr}
   22838:	4604      	mov	r4, r0
	if (!chan->conn) {
   2283a:	b12b      	cbz	r3, 22848 <bt_l2cap_chan_del+0x14>
	if (chan->ops->disconnected) {
   2283c:	6843      	ldr	r3, [r0, #4]
   2283e:	685b      	ldr	r3, [r3, #4]
   22840:	b103      	cbz	r3, 22844 <bt_l2cap_chan_del+0x10>
		chan->ops->disconnected(chan);
   22842:	4798      	blx	r3
	chan->conn = NULL;
   22844:	2300      	movs	r3, #0
   22846:	6023      	str	r3, [r4, #0]
	if (chan->destroy) {
   22848:	68e3      	ldr	r3, [r4, #12]
   2284a:	b10b      	cbz	r3, 22850 <bt_l2cap_chan_del+0x1c>
		chan->destroy(chan);
   2284c:	4620      	mov	r0, r4
   2284e:	4798      	blx	r3
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   22850:	f3bf 8f5b 	dmb	ish
   22854:	3430      	adds	r4, #48	; 0x30
   22856:	2300      	movs	r3, #0
   22858:	e854 2f00 	ldrex	r2, [r4]
   2285c:	e844 3100 	strex	r1, r3, [r4]
   22860:	2900      	cmp	r1, #0
   22862:	d1f9      	bne.n	22858 <bt_l2cap_chan_del+0x24>
   22864:	f3bf 8f5b 	dmb	ish
}
   22868:	bd10      	pop	{r4, pc}

0002286a <bt_l2cap_disconnected>:
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   2286a:	6c83      	ldr	r3, [r0, #72]	; 0x48
{
   2286c:	b510      	push	{r4, lr}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   2286e:	b173      	cbz	r3, 2288e <bt_l2cap_disconnected+0x24>
   22870:	f1b3 0008 	subs.w	r0, r3, #8
   22874:	d00b      	beq.n	2288e <bt_l2cap_disconnected+0x24>
   22876:	681c      	ldr	r4, [r3, #0]
   22878:	b104      	cbz	r4, 2287c <bt_l2cap_disconnected+0x12>
   2287a:	3c08      	subs	r4, #8
		bt_l2cap_chan_del(chan);
   2287c:	f7ff ffda 	bl	22834 <bt_l2cap_chan_del>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   22880:	b12c      	cbz	r4, 2288e <bt_l2cap_disconnected+0x24>
   22882:	68a3      	ldr	r3, [r4, #8]
   22884:	b103      	cbz	r3, 22888 <bt_l2cap_disconnected+0x1e>
   22886:	3b08      	subs	r3, #8
{
   22888:	4620      	mov	r0, r4
   2288a:	461c      	mov	r4, r3
   2288c:	e7f6      	b.n	2287c <bt_l2cap_disconnected+0x12>
}
   2288e:	bd10      	pop	{r4, pc}

00022890 <bt_l2cap_encrypt_change>:
{
   22890:	b538      	push	{r3, r4, r5, lr}
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   22892:	6c84      	ldr	r4, [r0, #72]	; 0x48
{
   22894:	460d      	mov	r5, r1
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   22896:	b10c      	cbz	r4, 2289c <bt_l2cap_encrypt_change+0xc>
   22898:	3c08      	subs	r4, #8
   2289a:	b904      	cbnz	r4, 2289e <bt_l2cap_encrypt_change+0xe>
}
   2289c:	bd38      	pop	{r3, r4, r5, pc}
		if (chan->ops->encrypt_change) {
   2289e:	6863      	ldr	r3, [r4, #4]
   228a0:	689b      	ldr	r3, [r3, #8]
   228a2:	b113      	cbz	r3, 228aa <bt_l2cap_encrypt_change+0x1a>
			chan->ops->encrypt_change(chan, hci_status);
   228a4:	4629      	mov	r1, r5
   228a6:	4620      	mov	r0, r4
   228a8:	4798      	blx	r3
   228aa:	68a4      	ldr	r4, [r4, #8]
   228ac:	e7f3      	b.n	22896 <bt_l2cap_encrypt_change+0x6>

000228ae <bt_l2cap_create_pdu_timeout>:
	return bt_conn_create_pdu_timeout(pool,
   228ae:	3104      	adds	r1, #4
   228b0:	f7e8 bba0 	b.w	aff4 <bt_conn_create_pdu_timeout>

000228b4 <bt_l2cap_send_cb>:
{
   228b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   228b8:	4614      	mov	r4, r2
   228ba:	4605      	mov	r5, r0
   228bc:	4688      	mov	r8, r1
	hdr = net_buf_push(buf, sizeof(*hdr));
   228be:	f102 0008 	add.w	r0, r2, #8
   228c2:	2104      	movs	r1, #4
{
   228c4:	461e      	mov	r6, r3
   228c6:	9f06      	ldr	r7, [sp, #24]
	hdr = net_buf_push(buf, sizeof(*hdr));
   228c8:	f002 faa8 	bl	24e1c <net_buf_simple_push>
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   228cc:	89a1      	ldrh	r1, [r4, #12]
	hdr->cid = sys_cpu_to_le16(cid);
   228ce:	f8a0 8002 	strh.w	r8, [r0, #2]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   228d2:	3904      	subs	r1, #4
   228d4:	8001      	strh	r1, [r0, #0]
	return bt_conn_send_cb(conn, buf, cb, user_data);
   228d6:	463b      	mov	r3, r7
   228d8:	4632      	mov	r2, r6
   228da:	4621      	mov	r1, r4
   228dc:	4628      	mov	r0, r5
}
   228de:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_conn_send_cb(conn, buf, cb, user_data);
   228e2:	f7e8 b8cd 	b.w	aa80 <bt_conn_send_cb>

000228e6 <bt_l2cap_le_lookup_tx_cid>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   228e6:	6c80      	ldr	r0, [r0, #72]	; 0x48
   228e8:	b108      	cbz	r0, 228ee <bt_l2cap_le_lookup_tx_cid+0x8>
   228ea:	3808      	subs	r0, #8
   228ec:	b900      	cbnz	r0, 228f0 <bt_l2cap_le_lookup_tx_cid+0xa>
}
   228ee:	4770      	bx	lr
		if (BT_L2CAP_LE_CHAN(chan)->tx.cid == cid) {
   228f0:	f8b0 3040 	ldrh.w	r3, [r0, #64]	; 0x40
   228f4:	428b      	cmp	r3, r1
   228f6:	d0fa      	beq.n	228ee <bt_l2cap_le_lookup_tx_cid+0x8>
   228f8:	6880      	ldr	r0, [r0, #8]
   228fa:	e7f5      	b.n	228e8 <bt_l2cap_le_lookup_tx_cid+0x2>

000228fc <bt_l2cap_le_lookup_rx_cid>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   228fc:	6c80      	ldr	r0, [r0, #72]	; 0x48
   228fe:	b108      	cbz	r0, 22904 <bt_l2cap_le_lookup_rx_cid+0x8>
   22900:	3808      	subs	r0, #8
   22902:	b900      	cbnz	r0, 22906 <bt_l2cap_le_lookup_rx_cid+0xa>
}
   22904:	4770      	bx	lr
		if (BT_L2CAP_LE_CHAN(chan)->rx.cid == cid) {
   22906:	8e83      	ldrh	r3, [r0, #52]	; 0x34
   22908:	428b      	cmp	r3, r1
   2290a:	d0fb      	beq.n	22904 <bt_l2cap_le_lookup_rx_cid+0x8>
   2290c:	6880      	ldr	r0, [r0, #8]
   2290e:	e7f6      	b.n	228fe <bt_l2cap_le_lookup_rx_cid+0x2>

00022910 <bt_l2cap_init>:
void bt_l2cap_init(void)
{
	if (IS_ENABLED(CONFIG_BT_BREDR)) {
		bt_l2cap_br_init();
	}
}
   22910:	4770      	bx	lr

00022912 <att_op_get_type>:
	switch (op) {
   22912:	280e      	cmp	r0, #14
   22914:	d00a      	beq.n	2292c <att_op_get_type+0x1a>
   22916:	d81e      	bhi.n	22956 <att_op_get_type+0x44>
   22918:	2807      	cmp	r0, #7
   2291a:	d015      	beq.n	22948 <att_op_get_type+0x36>
   2291c:	d80d      	bhi.n	2293a <att_op_get_type+0x28>
   2291e:	2803      	cmp	r0, #3
   22920:	d012      	beq.n	22948 <att_op_get_type+0x36>
   22922:	d805      	bhi.n	22930 <att_op_get_type+0x1e>
   22924:	2801      	cmp	r0, #1
   22926:	d00f      	beq.n	22948 <att_op_get_type+0x36>
   22928:	2802      	cmp	r0, #2
   2292a:	d12b      	bne.n	22984 <att_op_get_type+0x72>
		return ATT_REQUEST;
   2292c:	2001      	movs	r0, #1
   2292e:	4770      	bx	lr
	switch (op) {
   22930:	2805      	cmp	r0, #5
		return ATT_REQUEST;
   22932:	bf0c      	ite	eq
   22934:	2002      	moveq	r0, #2
   22936:	2001      	movne	r0, #1
   22938:	4770      	bx	lr
	switch (op) {
   2293a:	280a      	cmp	r0, #10
   2293c:	d0f6      	beq.n	2292c <att_op_get_type+0x1a>
   2293e:	d805      	bhi.n	2294c <att_op_get_type+0x3a>
   22940:	2808      	cmp	r0, #8
   22942:	d0f3      	beq.n	2292c <att_op_get_type+0x1a>
   22944:	2809      	cmp	r0, #9
   22946:	d11d      	bne.n	22984 <att_op_get_type+0x72>
		return ATT_RESPONSE;
   22948:	2002      	movs	r0, #2
   2294a:	4770      	bx	lr
	switch (op) {
   2294c:	280c      	cmp	r0, #12
		return ATT_RESPONSE;
   2294e:	bf0c      	ite	eq
   22950:	2001      	moveq	r0, #1
   22952:	2002      	movne	r0, #2
   22954:	4770      	bx	lr
	switch (op) {
   22956:	2817      	cmp	r0, #23
   22958:	d0f6      	beq.n	22948 <att_op_get_type+0x36>
   2295a:	d80b      	bhi.n	22974 <att_op_get_type+0x62>
   2295c:	2811      	cmp	r0, #17
   2295e:	d0f3      	beq.n	22948 <att_op_get_type+0x36>
   22960:	d803      	bhi.n	2296a <att_op_get_type+0x58>
   22962:	280f      	cmp	r0, #15
   22964:	d0f0      	beq.n	22948 <att_op_get_type+0x36>
   22966:	2810      	cmp	r0, #16
   22968:	e7df      	b.n	2292a <att_op_get_type+0x18>
   2296a:	2813      	cmp	r0, #19
   2296c:	d0ec      	beq.n	22948 <att_op_get_type+0x36>
   2296e:	d3dd      	bcc.n	2292c <att_op_get_type+0x1a>
   22970:	2816      	cmp	r0, #22
   22972:	e7da      	b.n	2292a <att_op_get_type+0x18>
   22974:	281d      	cmp	r0, #29
   22976:	d013      	beq.n	229a0 <att_op_get_type+0x8e>
   22978:	d80a      	bhi.n	22990 <att_op_get_type+0x7e>
   2297a:	2819      	cmp	r0, #25
   2297c:	d0e4      	beq.n	22948 <att_op_get_type+0x36>
   2297e:	d3d5      	bcc.n	2292c <att_op_get_type+0x1a>
   22980:	281b      	cmp	r0, #27
   22982:	d00f      	beq.n	229a4 <att_op_get_type+0x92>
	if (op & ATT_CMD_MASK) {
   22984:	f010 0f40 	tst.w	r0, #64	; 0x40
		return ATT_COMMAND;
   22988:	bf0c      	ite	eq
   2298a:	2006      	moveq	r0, #6
   2298c:	2000      	movne	r0, #0
   2298e:	4770      	bx	lr
	switch (op) {
   22990:	2852      	cmp	r0, #82	; 0x52
   22992:	d009      	beq.n	229a8 <att_op_get_type+0x96>
   22994:	28d2      	cmp	r0, #210	; 0xd2
   22996:	d007      	beq.n	229a8 <att_op_get_type+0x96>
   22998:	281e      	cmp	r0, #30
   2299a:	d1f3      	bne.n	22984 <att_op_get_type+0x72>
		return ATT_CONFIRMATION;
   2299c:	2004      	movs	r0, #4
}
   2299e:	4770      	bx	lr
		return ATT_INDICATION;
   229a0:	2005      	movs	r0, #5
   229a2:	4770      	bx	lr
		return ATT_NOTIFICATION;
   229a4:	2003      	movs	r0, #3
   229a6:	4770      	bx	lr
		return ATT_COMMAND;
   229a8:	2000      	movs	r0, #0
   229aa:	4770      	bx	lr

000229ac <att_notify>:
{
   229ac:	b538      	push	{r3, r4, r5, lr}
	struct bt_conn *conn = att->chan.chan.conn;
   229ae:	6805      	ldr	r5, [r0, #0]
	handle = net_buf_pull_le16(buf);
   229b0:	f101 0008 	add.w	r0, r1, #8
{
   229b4:	460c      	mov	r4, r1
	handle = net_buf_pull_le16(buf);
   229b6:	f002 fa49 	bl	24e4c <net_buf_simple_pull_le16>
	bt_gatt_notification(conn, handle, buf->data, buf->len);
   229ba:	89a3      	ldrh	r3, [r4, #12]
   229bc:	68a2      	ldr	r2, [r4, #8]
   229be:	4601      	mov	r1, r0
   229c0:	4628      	mov	r0, r5
   229c2:	f000 fed4 	bl	2376e <bt_gatt_notification>
}
   229c6:	2000      	movs	r0, #0
   229c8:	bd38      	pop	{r3, r4, r5, pc}

000229ca <bt_gatt_foreach_attr>:
 *  @param user_data Data to pass to the callback.
 */
static inline void bt_gatt_foreach_attr(u16_t start_handle, u16_t end_handle,
					bt_gatt_attr_func_t func,
					void *user_data)
{
   229ca:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   229cc:	e9cd 2301 	strd	r2, r3, [sp, #4]
   229d0:	2300      	movs	r3, #0
   229d2:	9300      	str	r3, [sp, #0]
   229d4:	461a      	mov	r2, r3
   229d6:	f7ea fc87 	bl	d2e8 <bt_gatt_foreach_attr_type>
				  user_data);
}
   229da:	b005      	add	sp, #20
   229dc:	f85d fb04 	ldr.w	pc, [sp], #4

000229e0 <read_group_cb>:
{
   229e0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	struct bt_att *att = data->att;
   229e4:	680c      	ldr	r4, [r1, #0]
{
   229e6:	4606      	mov	r6, r0
   229e8:	460d      	mov	r5, r1
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   229ea:	f04f 0800 	mov.w	r8, #0
   229ee:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   229f2:	a902      	add	r1, sp, #8
   229f4:	6800      	ldr	r0, [r0, #0]
	struct bt_conn *conn = att->chan.chan.conn;
   229f6:	6827      	ldr	r7, [r4, #0]
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   229f8:	f88d 8008 	strb.w	r8, [sp, #8]
   229fc:	f8ad 300a 	strh.w	r3, [sp, #10]
   22a00:	f7ff fc8d 	bl	2231e <bt_uuid_cmp>
   22a04:	b198      	cbz	r0, 22a2e <read_group_cb+0x4e>
	    bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   22a06:	f642 0301 	movw	r3, #10241	; 0x2801
   22a0a:	a903      	add	r1, sp, #12
   22a0c:	6830      	ldr	r0, [r6, #0]
   22a0e:	f88d 800c 	strb.w	r8, [sp, #12]
   22a12:	f8ad 300e 	strh.w	r3, [sp, #14]
   22a16:	f7ff fc82 	bl	2231e <bt_uuid_cmp>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   22a1a:	b140      	cbz	r0, 22a2e <read_group_cb+0x4e>
		if (data->group &&
   22a1c:	692b      	ldr	r3, [r5, #16]
   22a1e:	b123      	cbz	r3, 22a2a <read_group_cb+0x4a>
		    attr->handle > sys_le16_to_cpu(data->group->end_handle)) {
   22a20:	8a32      	ldrh	r2, [r6, #16]
		if (data->group &&
   22a22:	8859      	ldrh	r1, [r3, #2]
   22a24:	4291      	cmp	r1, r2
   22a26:	d200      	bcs.n	22a2a <read_group_cb+0x4a>
			data->group->end_handle = sys_cpu_to_le16(attr->handle);
   22a28:	805a      	strh	r2, [r3, #2]
		return BT_GATT_ITER_CONTINUE;
   22a2a:	2001      	movs	r0, #1
   22a2c:	e012      	b.n	22a54 <read_group_cb+0x74>
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   22a2e:	6869      	ldr	r1, [r5, #4]
   22a30:	6830      	ldr	r0, [r6, #0]
   22a32:	f7ff fc74 	bl	2231e <bt_uuid_cmp>
   22a36:	b110      	cbz	r0, 22a3e <read_group_cb+0x5e>
		data->group = NULL;
   22a38:	2300      	movs	r3, #0
   22a3a:	612b      	str	r3, [r5, #16]
		return BT_GATT_ITER_CONTINUE;
   22a3c:	e7f5      	b.n	22a2a <read_group_cb+0x4a>
	if (data->rsp->len &&
   22a3e:	68eb      	ldr	r3, [r5, #12]
   22a40:	68a8      	ldr	r0, [r5, #8]
   22a42:	781a      	ldrb	r2, [r3, #0]
   22a44:	b14a      	cbz	r2, 22a5a <read_group_cb+0x7a>
	    att->chan.tx.mtu - data->buf->len < data->rsp->len) {
   22a46:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
   22a4a:	8981      	ldrh	r1, [r0, #12]
   22a4c:	1a5b      	subs	r3, r3, r1
	if (data->rsp->len &&
   22a4e:	4293      	cmp	r3, r2
   22a50:	da03      	bge.n	22a5a <read_group_cb+0x7a>
		return BT_GATT_ITER_STOP;
   22a52:	2000      	movs	r0, #0
}
   22a54:	b004      	add	sp, #16
   22a56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	data->group = net_buf_add(data->buf, sizeof(*data->group));
   22a5a:	2104      	movs	r1, #4
   22a5c:	3008      	adds	r0, #8
   22a5e:	f002 f9bb 	bl	24dd8 <net_buf_simple_add>
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   22a62:	68a9      	ldr	r1, [r5, #8]
	data->group->start_handle = sys_cpu_to_le16(attr->handle);
   22a64:	8a33      	ldrh	r3, [r6, #16]
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   22a66:	898a      	ldrh	r2, [r1, #12]
	data->group = net_buf_add(data->buf, sizeof(*data->group));
   22a68:	6128      	str	r0, [r5, #16]
	data->group->start_handle = sys_cpu_to_le16(attr->handle);
   22a6a:	8003      	strh	r3, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(attr->handle);
   22a6c:	8043      	strh	r3, [r0, #2]
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   22a6e:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
   22a72:	6889      	ldr	r1, [r1, #8]
   22a74:	2400      	movs	r4, #0
   22a76:	1a9b      	subs	r3, r3, r2
   22a78:	9400      	str	r4, [sp, #0]
   22a7a:	440a      	add	r2, r1
   22a7c:	f8d6 8004 	ldr.w	r8, [r6, #4]
   22a80:	4631      	mov	r1, r6
   22a82:	b29b      	uxth	r3, r3
   22a84:	4638      	mov	r0, r7
   22a86:	47c0      	blx	r8
	if (read < 0) {
   22a88:	1e01      	subs	r1, r0, #0
   22a8a:	dbe2      	blt.n	22a52 <read_group_cb+0x72>
	if (!data->rsp->len) {
   22a8c:	68ee      	ldr	r6, [r5, #12]
   22a8e:	68ab      	ldr	r3, [r5, #8]
   22a90:	7830      	ldrb	r0, [r6, #0]
   22a92:	1d0a      	adds	r2, r1, #4
   22a94:	b928      	cbnz	r0, 22aa2 <read_group_cb+0xc2>
		data->rsp->len = read + sizeof(*data->group);
   22a96:	7032      	strb	r2, [r6, #0]
	net_buf_add(data->buf, read);
   22a98:	f103 0008 	add.w	r0, r3, #8
   22a9c:	f002 f99c 	bl	24dd8 <net_buf_simple_add>
	return BT_GATT_ITER_CONTINUE;
   22aa0:	e7c3      	b.n	22a2a <read_group_cb+0x4a>
	} else if (data->rsp->len != read + sizeof(*data->group)) {
   22aa2:	4290      	cmp	r0, r2
   22aa4:	d0f8      	beq.n	22a98 <read_group_cb+0xb8>
		data->buf->len -= sizeof(*data->group);
   22aa6:	899a      	ldrh	r2, [r3, #12]
   22aa8:	3a04      	subs	r2, #4
   22aaa:	819a      	strh	r2, [r3, #12]
		return false;
   22aac:	e7d1      	b.n	22a52 <read_group_cb+0x72>

00022aae <read_type_cb>:
{
   22aae:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	struct bt_att *att = data->att;
   22ab2:	680f      	ldr	r7, [r1, #0]
{
   22ab4:	4605      	mov	r5, r0
   22ab6:	460e      	mov	r6, r1
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   22ab8:	6800      	ldr	r0, [r0, #0]
   22aba:	6849      	ldr	r1, [r1, #4]
	struct bt_conn *conn = att->chan.chan.conn;
   22abc:	f8d7 9000 	ldr.w	r9, [r7]
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   22ac0:	f7ff fc2d 	bl	2231e <bt_uuid_cmp>
   22ac4:	4680      	mov	r8, r0
   22ac6:	2800      	cmp	r0, #0
   22ac8:	d14c      	bne.n	22b64 <read_type_cb+0xb6>
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   22aca:	2215      	movs	r2, #21
   22acc:	4629      	mov	r1, r5
   22ace:	4648      	mov	r0, r9
   22ad0:	f000 fd47 	bl	23562 <bt_gatt_check_perm>
   22ad4:	4604      	mov	r4, r0
   22ad6:	7530      	strb	r0, [r6, #20]
	if (data->err) {
   22ad8:	b148      	cbz	r0, 22aee <read_type_cb+0x40>
		if (data->rsp->len) {
   22ada:	68f3      	ldr	r3, [r6, #12]
   22adc:	781c      	ldrb	r4, [r3, #0]
   22ade:	b114      	cbz	r4, 22ae6 <read_type_cb+0x38>
			data->err = 0x00;
   22ae0:	f886 8014 	strb.w	r8, [r6, #20]
		return BT_GATT_ITER_STOP;
   22ae4:	4644      	mov	r4, r8
}
   22ae6:	4620      	mov	r0, r4
   22ae8:	b003      	add	sp, #12
   22aea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	data->item = net_buf_add(data->buf, sizeof(*data->item));
   22aee:	68b0      	ldr	r0, [r6, #8]
   22af0:	2102      	movs	r1, #2
   22af2:	3008      	adds	r0, #8
   22af4:	f002 f970 	bl	24dd8 <net_buf_simple_add>
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   22af8:	68b1      	ldr	r1, [r6, #8]
	data->item->handle = sys_cpu_to_le16(attr->handle);
   22afa:	8a2b      	ldrh	r3, [r5, #16]
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   22afc:	898a      	ldrh	r2, [r1, #12]
	data->item = net_buf_add(data->buf, sizeof(*data->item));
   22afe:	6130      	str	r0, [r6, #16]
	data->item->handle = sys_cpu_to_le16(attr->handle);
   22b00:	8003      	strh	r3, [r0, #0]
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   22b02:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
   22b06:	6889      	ldr	r1, [r1, #8]
   22b08:	9400      	str	r4, [sp, #0]
   22b0a:	1a9b      	subs	r3, r3, r2
   22b0c:	f8d5 8004 	ldr.w	r8, [r5, #4]
   22b10:	440a      	add	r2, r1
   22b12:	b29b      	uxth	r3, r3
   22b14:	4629      	mov	r1, r5
   22b16:	4648      	mov	r0, r9
   22b18:	47c0      	blx	r8
	if (read < 0) {
   22b1a:	1e01      	subs	r1, r0, #0
   22b1c:	da07      	bge.n	22b2e <read_type_cb+0x80>
	if (err < 0 && err >= -0xff) {
   22b1e:	f111 0fff 	cmn.w	r1, #255	; 0xff
		return -err;
   22b22:	bf26      	itte	cs
   22b24:	4249      	negcs	r1, r1
   22b26:	b2c9      	uxtbcs	r1, r1
	return BT_ATT_ERR_UNLIKELY;
   22b28:	210e      	movcc	r1, #14
		data->err = err_to_att(read);
   22b2a:	7531      	strb	r1, [r6, #20]
		return BT_GATT_ITER_STOP;
   22b2c:	e7db      	b.n	22ae6 <read_type_cb+0x38>
	if (!data->rsp->len) {
   22b2e:	68f5      	ldr	r5, [r6, #12]
   22b30:	68b0      	ldr	r0, [r6, #8]
   22b32:	782a      	ldrb	r2, [r5, #0]
   22b34:	1c8b      	adds	r3, r1, #2
   22b36:	b97a      	cbnz	r2, 22b58 <read_type_cb+0xaa>
		data->rsp->len = read + sizeof(*data->item);
   22b38:	702b      	strb	r3, [r5, #0]
	net_buf_add(data->buf, read);
   22b3a:	3008      	adds	r0, #8
   22b3c:	f002 f94c 	bl	24dd8 <net_buf_simple_add>
	return att->chan.tx.mtu - data->buf->len > data->rsp->len ?
   22b40:	68b3      	ldr	r3, [r6, #8]
   22b42:	f8b7 4042 	ldrh.w	r4, [r7, #66]	; 0x42
   22b46:	899b      	ldrh	r3, [r3, #12]
   22b48:	1ae4      	subs	r4, r4, r3
   22b4a:	68f3      	ldr	r3, [r6, #12]
   22b4c:	781b      	ldrb	r3, [r3, #0]
	       BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
   22b4e:	429c      	cmp	r4, r3
   22b50:	bfd4      	ite	le
   22b52:	2400      	movle	r4, #0
   22b54:	2401      	movgt	r4, #1
   22b56:	e7c6      	b.n	22ae6 <read_type_cb+0x38>
	} else if (data->rsp->len != read + sizeof(*data->item)) {
   22b58:	429a      	cmp	r2, r3
   22b5a:	d0ee      	beq.n	22b3a <read_type_cb+0x8c>
		data->buf->len -= sizeof(*data->item);
   22b5c:	8983      	ldrh	r3, [r0, #12]
   22b5e:	3b02      	subs	r3, #2
   22b60:	8183      	strh	r3, [r0, #12]
		return BT_GATT_ITER_STOP;
   22b62:	e7c0      	b.n	22ae6 <read_type_cb+0x38>
		return BT_GATT_ITER_CONTINUE;
   22b64:	2401      	movs	r4, #1
   22b66:	e7be      	b.n	22ae6 <read_type_cb+0x38>

00022b68 <find_info_cb>:
	if (!data->rsp) {
   22b68:	688b      	ldr	r3, [r1, #8]
{
   22b6a:	b570      	push	{r4, r5, r6, lr}
   22b6c:	4605      	mov	r5, r0
   22b6e:	460c      	mov	r4, r1
	struct bt_att *att = data->att;
   22b70:	680e      	ldr	r6, [r1, #0]
	if (!data->rsp) {
   22b72:	b963      	cbnz	r3, 22b8e <find_info_cb+0x26>
		data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   22b74:	6848      	ldr	r0, [r1, #4]
   22b76:	2101      	movs	r1, #1
   22b78:	3008      	adds	r0, #8
   22b7a:	f002 f92d 	bl	24dd8 <net_buf_simple_add>
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   22b7e:	682b      	ldr	r3, [r5, #0]
		data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   22b80:	60a0      	str	r0, [r4, #8]
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   22b82:	781b      	ldrb	r3, [r3, #0]
   22b84:	2b00      	cmp	r3, #0
   22b86:	bf0c      	ite	eq
   22b88:	2301      	moveq	r3, #1
   22b8a:	2302      	movne	r3, #2
   22b8c:	7003      	strb	r3, [r0, #0]
	switch (data->rsp->format) {
   22b8e:	68a3      	ldr	r3, [r4, #8]
   22b90:	781b      	ldrb	r3, [r3, #0]
   22b92:	2b01      	cmp	r3, #1
   22b94:	d003      	beq.n	22b9e <find_info_cb+0x36>
   22b96:	2b02      	cmp	r3, #2
   22b98:	d01a      	beq.n	22bd0 <find_info_cb+0x68>
			return BT_GATT_ITER_STOP;
   22b9a:	2000      	movs	r0, #0
   22b9c:	e017      	b.n	22bce <find_info_cb+0x66>
		if (attr->uuid->type != BT_UUID_TYPE_16) {
   22b9e:	682b      	ldr	r3, [r5, #0]
   22ba0:	781b      	ldrb	r3, [r3, #0]
   22ba2:	2b00      	cmp	r3, #0
   22ba4:	d1f9      	bne.n	22b9a <find_info_cb+0x32>
		data->info16 = net_buf_add(data->buf, sizeof(*data->info16));
   22ba6:	6860      	ldr	r0, [r4, #4]
   22ba8:	2104      	movs	r1, #4
   22baa:	3008      	adds	r0, #8
   22bac:	f002 f914 	bl	24dd8 <net_buf_simple_add>
		data->info16->handle = sys_cpu_to_le16(attr->handle);
   22bb0:	8a2b      	ldrh	r3, [r5, #16]
		data->info16 = net_buf_add(data->buf, sizeof(*data->info16));
   22bb2:	60e0      	str	r0, [r4, #12]
		data->info16->handle = sys_cpu_to_le16(attr->handle);
   22bb4:	8003      	strh	r3, [r0, #0]
		data->info16->uuid = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
   22bb6:	682b      	ldr	r3, [r5, #0]
   22bb8:	885b      	ldrh	r3, [r3, #2]
   22bba:	8043      	strh	r3, [r0, #2]
		if (att->chan.tx.mtu - data->buf->len >
   22bbc:	6863      	ldr	r3, [r4, #4]
   22bbe:	f8b6 0042 	ldrh.w	r0, [r6, #66]	; 0x42
   22bc2:	899b      	ldrh	r3, [r3, #12]
   22bc4:	1ac0      	subs	r0, r0, r3
			return BT_GATT_ITER_STOP;
   22bc6:	2804      	cmp	r0, #4
   22bc8:	bf94      	ite	ls
   22bca:	2000      	movls	r0, #0
   22bcc:	2001      	movhi	r0, #1
}
   22bce:	bd70      	pop	{r4, r5, r6, pc}
		if (attr->uuid->type != BT_UUID_TYPE_128) {
   22bd0:	682b      	ldr	r3, [r5, #0]
   22bd2:	781b      	ldrb	r3, [r3, #0]
   22bd4:	2b02      	cmp	r3, #2
   22bd6:	d1e0      	bne.n	22b9a <find_info_cb+0x32>
		data->info128 = net_buf_add(data->buf, sizeof(*data->info128));
   22bd8:	6860      	ldr	r0, [r4, #4]
   22bda:	2112      	movs	r1, #18
   22bdc:	3008      	adds	r0, #8
   22bde:	f002 f8fb 	bl	24dd8 <net_buf_simple_add>
		data->info128->handle = sys_cpu_to_le16(attr->handle);
   22be2:	8a2b      	ldrh	r3, [r5, #16]
		data->info128 = net_buf_add(data->buf, sizeof(*data->info128));
   22be4:	60e0      	str	r0, [r4, #12]
		data->info128->handle = sys_cpu_to_le16(attr->handle);
   22be6:	f820 3b02 	strh.w	r3, [r0], #2
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   22bea:	682b      	ldr	r3, [r5, #0]
   22bec:	1c5a      	adds	r2, r3, #1
   22bee:	3311      	adds	r3, #17
   22bf0:	f852 1b04 	ldr.w	r1, [r2], #4
   22bf4:	f840 1b04 	str.w	r1, [r0], #4
   22bf8:	429a      	cmp	r2, r3
   22bfa:	d1f9      	bne.n	22bf0 <find_info_cb+0x88>
		if (att->chan.tx.mtu - data->buf->len >
   22bfc:	6863      	ldr	r3, [r4, #4]
   22bfe:	f8b6 0042 	ldrh.w	r0, [r6, #66]	; 0x42
   22c02:	899b      	ldrh	r3, [r3, #12]
   22c04:	1ac0      	subs	r0, r0, r3
			return BT_GATT_ITER_STOP;
   22c06:	2812      	cmp	r0, #18
   22c08:	e7de      	b.n	22bc8 <find_info_cb+0x60>

00022c0a <att_send_req>:
{
   22c0a:	b573      	push	{r0, r1, r4, r5, r6, lr}
   22c0c:	4605      	mov	r5, r0
   22c0e:	460c      	mov	r4, r1
	att->req = req;
   22c10:	f8c5 109c 	str.w	r1, [r5, #156]	; 0x9c
	return z_impl_k_sem_take(sem, timeout);
   22c14:	2100      	movs	r1, #0
   22c16:	30c8      	adds	r0, #200	; 0xc8
   22c18:	f7fc f8dc 	bl	1edd4 <z_impl_k_sem_take>
	if (k_sem_take(&att->tx_sem, K_NO_WAIT) < 0) {
   22c1c:	2800      	cmp	r0, #0
   22c1e:	da08      	bge.n	22c32 <att_send_req+0x28>
		k_fifo_put(&att->tx_queue, req->buf);
   22c20:	f105 00e0 	add.w	r0, r5, #224	; 0xe0
   22c24:	6921      	ldr	r1, [r4, #16]
   22c26:	f004 ff6e 	bl	27b06 <k_queue_append>
		return 0;
   22c2a:	2500      	movs	r5, #0
}
   22c2c:	4628      	mov	r0, r5
   22c2e:	b002      	add	sp, #8
   22c30:	bd70      	pop	{r4, r5, r6, pc}
	net_buf_simple_save(&req->buf->b, &req->state);
   22c32:	6926      	ldr	r6, [r4, #16]
	state->offset = net_buf_simple_headroom(buf);
   22c34:	f106 0008 	add.w	r0, r6, #8
   22c38:	f002 f910 	bl	24e5c <net_buf_simple_headroom>
	state->len = buf->len;
   22c3c:	89b3      	ldrh	r3, [r6, #12]
	state->offset = net_buf_simple_headroom(buf);
   22c3e:	81a0      	strh	r0, [r4, #12]
	state->len = buf->len;
   22c40:	81e3      	strh	r3, [r4, #14]
	err = bt_l2cap_send_cb(att->chan.chan.conn, BT_L2CAP_CID_ATT,
   22c42:	6920      	ldr	r0, [r4, #16]
   22c44:	682d      	ldr	r5, [r5, #0]
   22c46:	f002 f8c3 	bl	24dd0 <net_buf_ref>
   22c4a:	6923      	ldr	r3, [r4, #16]
   22c4c:	4602      	mov	r2, r0
   22c4e:	6898      	ldr	r0, [r3, #8]
   22c50:	f7e8 fd28 	bl	b6a4 <att_cb.isra.6>
   22c54:	2600      	movs	r6, #0
   22c56:	4603      	mov	r3, r0
   22c58:	9600      	str	r6, [sp, #0]
   22c5a:	4628      	mov	r0, r5
   22c5c:	2104      	movs	r1, #4
   22c5e:	f7ff fe29 	bl	228b4 <bt_l2cap_send_cb>
	if (err) {
   22c62:	4605      	mov	r5, r0
   22c64:	2800      	cmp	r0, #0
   22c66:	d0e1      	beq.n	22c2c <att_send_req+0x22>
		net_buf_unref(req->buf);
   22c68:	6920      	ldr	r0, [r4, #16]
   22c6a:	f7f6 f9f7 	bl	1905c <net_buf_unref>
		req->buf = NULL;
   22c6e:	6126      	str	r6, [r4, #16]
		return err;
   22c70:	e7dc      	b.n	22c2c <att_send_req+0x22>

00022c72 <att_pdu_sent>:
{
   22c72:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   22c76:	2104      	movs	r1, #4
{
   22c78:	4680      	mov	r8, r0
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   22c7a:	f7ff fe34 	bl	228e6 <bt_l2cap_le_lookup_tx_cid>
   22c7e:	4606      	mov	r6, r0
	while ((buf = net_buf_get(&att->tx_queue, K_NO_WAIT))) {
   22c80:	f100 07e0 	add.w	r7, r0, #224	; 0xe0
   22c84:	2100      	movs	r1, #0
   22c86:	4638      	mov	r0, r7
   22c88:	f002 f878 	bl	24d7c <net_buf_get>
   22c8c:	4604      	mov	r4, r0
   22c8e:	b928      	cbnz	r0, 22c9c <att_pdu_sent+0x2a>
	z_impl_k_sem_give(sem);
   22c90:	f106 00c8 	add.w	r0, r6, #200	; 0xc8
}
   22c94:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   22c98:	f7fc b870 	b.w	1ed7c <z_impl_k_sem_give>
		if (att->req && att->req->buf == buf) {
   22c9c:	f8d6 509c 	ldr.w	r5, [r6, #156]	; 0x9c
   22ca0:	b14d      	cbz	r5, 22cb6 <att_pdu_sent+0x44>
   22ca2:	692b      	ldr	r3, [r5, #16]
   22ca4:	42a3      	cmp	r3, r4
   22ca6:	d106      	bne.n	22cb6 <att_pdu_sent+0x44>
	state->offset = net_buf_simple_headroom(buf);
   22ca8:	f104 0008 	add.w	r0, r4, #8
   22cac:	f002 f8d6 	bl	24e5c <net_buf_simple_headroom>
	state->len = buf->len;
   22cb0:	89a3      	ldrh	r3, [r4, #12]
	state->offset = net_buf_simple_headroom(buf);
   22cb2:	81a8      	strh	r0, [r5, #12]
	state->len = buf->len;
   22cb4:	81eb      	strh	r3, [r5, #14]
		if (!att_send(conn, buf, NULL, NULL)) {
   22cb6:	2300      	movs	r3, #0
   22cb8:	461a      	mov	r2, r3
   22cba:	4621      	mov	r1, r4
   22cbc:	4640      	mov	r0, r8
   22cbe:	f7e8 fd03 	bl	b6c8 <att_send>
   22cc2:	2800      	cmp	r0, #0
   22cc4:	d1de      	bne.n	22c84 <att_pdu_sent+0x12>
}
   22cc6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00022cca <att_cfm_sent>:
{
   22cca:	b538      	push	{r3, r4, r5, lr}
   22ccc:	460d      	mov	r5, r1
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   22cce:	2104      	movs	r1, #4
{
   22cd0:	4604      	mov	r4, r0
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   22cd2:	f7ff fe08 	bl	228e6 <bt_l2cap_le_lookup_tx_cid>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   22cd6:	f3bf 8f5b 	dmb	ish
   22cda:	3098      	adds	r0, #152	; 0x98
   22cdc:	e850 3f00 	ldrex	r3, [r0]
   22ce0:	f023 0302 	bic.w	r3, r3, #2
   22ce4:	e840 3200 	strex	r2, r3, [r0]
   22ce8:	2a00      	cmp	r2, #0
   22cea:	d1f7      	bne.n	22cdc <att_cfm_sent+0x12>
   22cec:	f3bf 8f5b 	dmb	ish
	att_pdu_sent(conn, user_data);
   22cf0:	4629      	mov	r1, r5
   22cf2:	4620      	mov	r0, r4
}
   22cf4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	att_pdu_sent(conn, user_data);
   22cf8:	f7ff bfbb 	b.w	22c72 <att_pdu_sent>

00022cfc <att_rsp_sent>:
{
   22cfc:	b538      	push	{r3, r4, r5, lr}
   22cfe:	460d      	mov	r5, r1
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   22d00:	2104      	movs	r1, #4
{
   22d02:	4604      	mov	r4, r0
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   22d04:	f7ff fdef 	bl	228e6 <bt_l2cap_le_lookup_tx_cid>
   22d08:	f3bf 8f5b 	dmb	ish
   22d0c:	3098      	adds	r0, #152	; 0x98
   22d0e:	e850 3f00 	ldrex	r3, [r0]
   22d12:	f023 0301 	bic.w	r3, r3, #1
   22d16:	e840 3200 	strex	r2, r3, [r0]
   22d1a:	2a00      	cmp	r2, #0
   22d1c:	d1f7      	bne.n	22d0e <att_rsp_sent+0x12>
   22d1e:	f3bf 8f5b 	dmb	ish
	att_pdu_sent(conn, user_data);
   22d22:	4629      	mov	r1, r5
   22d24:	4620      	mov	r0, r4
}
   22d26:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	att_pdu_sent(conn, user_data);
   22d2a:	f7ff bfa2 	b.w	22c72 <att_pdu_sent>

00022d2e <write_cb>:
{
   22d2e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   22d30:	460c      	mov	r4, r1
   22d32:	4606      	mov	r6, r0
	data->err = bt_gatt_check_perm(data->conn, attr,
   22d34:	4601      	mov	r1, r0
   22d36:	222a      	movs	r2, #42	; 0x2a
   22d38:	6820      	ldr	r0, [r4, #0]
   22d3a:	f000 fc12 	bl	23562 <bt_gatt_check_perm>
   22d3e:	4605      	mov	r5, r0
   22d40:	7520      	strb	r0, [r4, #20]
	if (data->err) {
   22d42:	bb00      	cbnz	r0, 22d86 <write_cb+0x58>
	if (!data->req) {
   22d44:	7a23      	ldrb	r3, [r4, #8]
	write = attr->write(data->conn, attr, data->value, data->len,
   22d46:	68b7      	ldr	r7, [r6, #8]
   22d48:	68e2      	ldr	r2, [r4, #12]
   22d4a:	6820      	ldr	r0, [r4, #0]
	if (!data->req) {
   22d4c:	2b00      	cmp	r3, #0
		flags |= BT_GATT_WRITE_FLAG_CMD;
   22d4e:	bf14      	ite	ne
   22d50:	2300      	movne	r3, #0
   22d52:	2302      	moveq	r3, #2
	write = attr->write(data->conn, attr, data->value, data->len,
   22d54:	9301      	str	r3, [sp, #4]
   22d56:	8a63      	ldrh	r3, [r4, #18]
   22d58:	9300      	str	r3, [sp, #0]
   22d5a:	4631      	mov	r1, r6
   22d5c:	8a23      	ldrh	r3, [r4, #16]
   22d5e:	47b8      	blx	r7
	if (write < 0 || write != data->len) {
   22d60:	2800      	cmp	r0, #0
   22d62:	db05      	blt.n	22d70 <write_cb+0x42>
   22d64:	8a23      	ldrh	r3, [r4, #16]
   22d66:	4298      	cmp	r0, r3
   22d68:	d10b      	bne.n	22d82 <write_cb+0x54>
	data->err = 0U;
   22d6a:	7525      	strb	r5, [r4, #20]
	return BT_GATT_ITER_CONTINUE;
   22d6c:	2501      	movs	r5, #1
   22d6e:	e005      	b.n	22d7c <write_cb+0x4e>
	if (err < 0 && err >= -0xff) {
   22d70:	f110 0fff 	cmn.w	r0, #255	; 0xff
   22d74:	d305      	bcc.n	22d82 <write_cb+0x54>
		return -err;
   22d76:	4240      	negs	r0, r0
   22d78:	b2c0      	uxtb	r0, r0
		data->err = err_to_att(write);
   22d7a:	7520      	strb	r0, [r4, #20]
}
   22d7c:	4628      	mov	r0, r5
   22d7e:	b003      	add	sp, #12
   22d80:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return BT_ATT_ERR_UNLIKELY;
   22d82:	200e      	movs	r0, #14
   22d84:	e7f9      	b.n	22d7a <write_cb+0x4c>
		return BT_GATT_ITER_STOP;
   22d86:	2500      	movs	r5, #0
   22d88:	e7f8      	b.n	22d7c <write_cb+0x4e>

00022d8a <read_cb>:
{
   22d8a:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   22d8e:	4606      	mov	r6, r0
	data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   22d90:	6888      	ldr	r0, [r1, #8]
	struct bt_att *att = data->att;
   22d92:	f8d1 9000 	ldr.w	r9, [r1]
{
   22d96:	460c      	mov	r4, r1
	data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   22d98:	3008      	adds	r0, #8
   22d9a:	2100      	movs	r1, #0
	struct bt_conn *conn = att->chan.chan.conn;
   22d9c:	f8d9 8000 	ldr.w	r8, [r9]
	data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   22da0:	f002 f81a 	bl	24dd8 <net_buf_simple_add>
	data->err = 0x00;
   22da4:	2700      	movs	r7, #0
	data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   22da6:	60e0      	str	r0, [r4, #12]
	data->err = 0x00;
   22da8:	7427      	strb	r7, [r4, #16]
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   22daa:	2215      	movs	r2, #21
   22dac:	4631      	mov	r1, r6
   22dae:	4640      	mov	r0, r8
   22db0:	f000 fbd7 	bl	23562 <bt_gatt_check_perm>
   22db4:	4605      	mov	r5, r0
   22db6:	7420      	strb	r0, [r4, #16]
	if (data->err) {
   22db8:	bb00      	cbnz	r0, 22dfc <read_cb+0x72>
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   22dba:	68a1      	ldr	r1, [r4, #8]
   22dbc:	f8b9 3042 	ldrh.w	r3, [r9, #66]	; 0x42
   22dc0:	898a      	ldrh	r2, [r1, #12]
   22dc2:	6889      	ldr	r1, [r1, #8]
   22dc4:	88a0      	ldrh	r0, [r4, #4]
   22dc6:	9000      	str	r0, [sp, #0]
   22dc8:	1a9b      	subs	r3, r3, r2
   22dca:	6877      	ldr	r7, [r6, #4]
   22dcc:	440a      	add	r2, r1
   22dce:	b29b      	uxth	r3, r3
   22dd0:	4631      	mov	r1, r6
   22dd2:	4640      	mov	r0, r8
   22dd4:	47b8      	blx	r7
	if (read < 0) {
   22dd6:	1e01      	subs	r1, r0, #0
   22dd8:	da0a      	bge.n	22df0 <read_cb+0x66>
	if (err < 0 && err >= -0xff) {
   22dda:	f111 0fff 	cmn.w	r1, #255	; 0xff
		return -err;
   22dde:	bf26      	itte	cs
   22de0:	4249      	negcs	r1, r1
   22de2:	b2c9      	uxtbcs	r1, r1
	return BT_ATT_ERR_UNLIKELY;
   22de4:	210e      	movcc	r1, #14
		data->err = err_to_att(read);
   22de6:	7421      	strb	r1, [r4, #16]
}
   22de8:	4628      	mov	r0, r5
   22dea:	b003      	add	sp, #12
   22dec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	net_buf_add(data->buf, read);
   22df0:	68a0      	ldr	r0, [r4, #8]
   22df2:	3008      	adds	r0, #8
   22df4:	f001 fff0 	bl	24dd8 <net_buf_simple_add>
	return BT_GATT_ITER_CONTINUE;
   22df8:	2501      	movs	r5, #1
   22dfa:	e7f5      	b.n	22de8 <read_cb+0x5e>
		return BT_GATT_ITER_STOP;
   22dfc:	463d      	mov	r5, r7
   22dfe:	e7f3      	b.n	22de8 <read_cb+0x5e>

00022e00 <att_write_cmd>:
{
   22e00:	b530      	push	{r4, r5, lr}
   22e02:	460c      	mov	r4, r1
   22e04:	b085      	sub	sp, #20
	struct bt_conn *conn = att->chan.chan.conn;
   22e06:	6805      	ldr	r5, [r0, #0]
	handle = net_buf_pull_le16(buf);
   22e08:	f101 0008 	add.w	r0, r1, #8
   22e0c:	f002 f81e 	bl	24e4c <net_buf_simple_pull_le16>
	return att_write_rsp(conn, 0, 0, handle, 0, buf->data, buf->len);
   22e10:	89a3      	ldrh	r3, [r4, #12]
   22e12:	9302      	str	r3, [sp, #8]
   22e14:	2200      	movs	r2, #0
   22e16:	68a3      	ldr	r3, [r4, #8]
   22e18:	9301      	str	r3, [sp, #4]
   22e1a:	9200      	str	r2, [sp, #0]
   22e1c:	4603      	mov	r3, r0
   22e1e:	4611      	mov	r1, r2
   22e20:	4628      	mov	r0, r5
   22e22:	f7e8 fef7 	bl	bc14 <att_write_rsp>
}
   22e26:	b005      	add	sp, #20
   22e28:	bd30      	pop	{r4, r5, pc}

00022e2a <att_write_req>:
{
   22e2a:	b530      	push	{r4, r5, lr}
   22e2c:	460c      	mov	r4, r1
   22e2e:	b085      	sub	sp, #20
	struct bt_conn *conn = att->chan.chan.conn;
   22e30:	6805      	ldr	r5, [r0, #0]
	handle = net_buf_pull_le16(buf);
   22e32:	f101 0008 	add.w	r0, r1, #8
   22e36:	f002 f809 	bl	24e4c <net_buf_simple_pull_le16>
	return att_write_rsp(conn, BT_ATT_OP_WRITE_REQ, BT_ATT_OP_WRITE_RSP,
   22e3a:	89a3      	ldrh	r3, [r4, #12]
   22e3c:	9302      	str	r3, [sp, #8]
   22e3e:	68a3      	ldr	r3, [r4, #8]
   22e40:	9301      	str	r3, [sp, #4]
   22e42:	2300      	movs	r3, #0
   22e44:	9300      	str	r3, [sp, #0]
   22e46:	2213      	movs	r2, #19
   22e48:	4603      	mov	r3, r0
   22e4a:	2112      	movs	r1, #18
   22e4c:	4628      	mov	r0, r5
   22e4e:	f7e8 fee1 	bl	bc14 <att_write_rsp>
}
   22e52:	b005      	add	sp, #20
   22e54:	bd30      	pop	{r4, r5, pc}

00022e56 <att_read_blob_req>:
{
   22e56:	b507      	push	{r0, r1, r2, lr}
	req = (void *)buf->data;
   22e58:	688a      	ldr	r2, [r1, #8]
	return att_read_rsp(att, BT_ATT_OP_READ_BLOB_REQ,
   22e5a:	8813      	ldrh	r3, [r2, #0]
   22e5c:	8852      	ldrh	r2, [r2, #2]
   22e5e:	9200      	str	r2, [sp, #0]
   22e60:	210c      	movs	r1, #12
   22e62:	220d      	movs	r2, #13
   22e64:	f7e9 f900 	bl	c068 <att_read_rsp>
}
   22e68:	b003      	add	sp, #12
   22e6a:	f85d fb04 	ldr.w	pc, [sp], #4

00022e6e <att_read_req>:
{
   22e6e:	b507      	push	{r0, r1, r2, lr}
	handle = sys_le16_to_cpu(req->handle);
   22e70:	688b      	ldr	r3, [r1, #8]
	return att_read_rsp(att, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
   22e72:	2200      	movs	r2, #0
   22e74:	881b      	ldrh	r3, [r3, #0]
   22e76:	9200      	str	r2, [sp, #0]
   22e78:	210a      	movs	r1, #10
   22e7a:	220b      	movs	r2, #11
   22e7c:	f7e9 f8f4 	bl	c068 <att_read_rsp>
}
   22e80:	b003      	add	sp, #12
   22e82:	f85d fb04 	ldr.w	pc, [sp], #4

00022e86 <bt_att_init>:
	bt_gatt_init();
   22e86:	f7ea b9c9 	b.w	d21c <bt_gatt_init>

00022e8a <bt_att_get_mtu>:
{
   22e8a:	b508      	push	{r3, lr}
	att = att_chan_get(conn);
   22e8c:	f7e8 fcbe 	bl	b80c <att_chan_get>
	if (!att) {
   22e90:	b108      	cbz	r0, 22e96 <bt_att_get_mtu+0xc>
	return att->chan.tx.mtu;
   22e92:	f8b0 0042 	ldrh.w	r0, [r0, #66]	; 0x42
}
   22e96:	bd08      	pop	{r3, pc}

00022e98 <att_req_destroy>:
{
   22e98:	b510      	push	{r4, lr}
   22e9a:	4604      	mov	r4, r0
	if (req->buf) {
   22e9c:	6900      	ldr	r0, [r0, #16]
   22e9e:	b108      	cbz	r0, 22ea4 <att_req_destroy+0xc>
		net_buf_unref(req->buf);
   22ea0:	f7f6 f8dc 	bl	1905c <net_buf_unref>
	if (req->destroy) {
   22ea4:	68a3      	ldr	r3, [r4, #8]
   22ea6:	b10b      	cbz	r3, 22eac <att_req_destroy+0x14>
		req->destroy(req);
   22ea8:	4620      	mov	r0, r4
   22eaa:	4798      	blx	r3
	bt_att_req_free(req);
   22eac:	4620      	mov	r0, r4
}
   22eae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_att_req_free(req);
   22eb2:	f7e9 ba53 	b.w	c35c <bt_att_req_free>

00022eb6 <att_handle_find_info_rsp>:
	return att_handle_rsp(att, buf->data, buf->len, 0);
   22eb6:	898a      	ldrh	r2, [r1, #12]
   22eb8:	6889      	ldr	r1, [r1, #8]
   22eba:	2300      	movs	r3, #0
   22ebc:	f7e9 ba5a 	b.w	c374 <att_handle_rsp>

00022ec0 <att_handle_find_type_rsp>:
   22ec0:	f7ff bff9 	b.w	22eb6 <att_handle_find_info_rsp>

00022ec4 <att_handle_read_type_rsp>:
   22ec4:	f7ff bff7 	b.w	22eb6 <att_handle_find_info_rsp>

00022ec8 <att_handle_read_rsp>:
   22ec8:	f7ff bff5 	b.w	22eb6 <att_handle_find_info_rsp>

00022ecc <att_handle_read_blob_rsp>:
   22ecc:	f7ff bff3 	b.w	22eb6 <att_handle_find_info_rsp>

00022ed0 <att_handle_read_mult_rsp>:
   22ed0:	f7ff bff1 	b.w	22eb6 <att_handle_find_info_rsp>

00022ed4 <att_handle_read_group_rsp>:
   22ed4:	f7ff bfef 	b.w	22eb6 <att_handle_find_info_rsp>

00022ed8 <att_handle_write_rsp>:
   22ed8:	f7ff bfed 	b.w	22eb6 <att_handle_find_info_rsp>

00022edc <att_handle_prepare_write_rsp>:
   22edc:	f7ff bfeb 	b.w	22eb6 <att_handle_find_info_rsp>

00022ee0 <att_handle_exec_write_rsp>:
   22ee0:	f7ff bfe9 	b.w	22eb6 <att_handle_find_info_rsp>

00022ee4 <att_confirm>:
   22ee4:	f7ff bfe7 	b.w	22eb6 <att_handle_find_info_rsp>

00022ee8 <att_mtu_rsp>:
{
   22ee8:	b410      	push	{r4}
   22eea:	460a      	mov	r2, r1
	if (!att) {
   22eec:	b190      	cbz	r0, 22f14 <att_mtu_rsp+0x2c>
	rsp = (void *)buf->data;
   22eee:	6889      	ldr	r1, [r1, #8]
	mtu = sys_le16_to_cpu(rsp->mtu);
   22ef0:	880b      	ldrh	r3, [r1, #0]
	if (mtu < BT_ATT_DEFAULT_LE_MTU) {
   22ef2:	2b16      	cmp	r3, #22
   22ef4:	d805      	bhi.n	22f02 <att_mtu_rsp+0x1a>
		return att_handle_rsp(att, NULL, 0, BT_ATT_ERR_INVALID_PDU);
   22ef6:	2200      	movs	r2, #0
   22ef8:	2304      	movs	r3, #4
   22efa:	4611      	mov	r1, r2
}
   22efc:	bc10      	pop	{r4}
	return att_handle_rsp(att, rsp, buf->len, 0);
   22efe:	f7e9 ba39 	b.w	c374 <att_handle_rsp>
	att->chan.rx.mtu = MIN(mtu, BT_ATT_MTU);
   22f02:	2b41      	cmp	r3, #65	; 0x41
   22f04:	bf28      	it	cs
   22f06:	2341      	movcs	r3, #65	; 0x41
   22f08:	86c3      	strh	r3, [r0, #54]	; 0x36
	att->chan.tx.mtu = att->chan.rx.mtu;
   22f0a:	f8a0 3042 	strh.w	r3, [r0, #66]	; 0x42
	return att_handle_rsp(att, rsp, buf->len, 0);
   22f0e:	8992      	ldrh	r2, [r2, #12]
   22f10:	2300      	movs	r3, #0
   22f12:	e7f3      	b.n	22efc <att_mtu_rsp+0x14>
}
   22f14:	bc10      	pop	{r4}
   22f16:	4770      	bx	lr

00022f18 <att_reset>:
{
   22f18:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   22f1a:	4604      	mov	r4, r0
	while ((buf = k_fifo_get(&att->prep_queue, K_NO_WAIT))) {
   22f1c:	f100 05f4 	add.w	r5, r0, #244	; 0xf4
	return z_impl_k_queue_get(queue, timeout);
   22f20:	2100      	movs	r1, #0
   22f22:	4628      	mov	r0, r5
   22f24:	f004 fe18 	bl	27b58 <z_impl_k_queue_get>
   22f28:	bb50      	cbnz	r0, 22f80 <att_reset+0x68>
	while ((buf = k_fifo_get(&att->tx_queue, K_NO_WAIT))) {
   22f2a:	f104 05e0 	add.w	r5, r4, #224	; 0xe0
   22f2e:	2100      	movs	r1, #0
   22f30:	4628      	mov	r0, r5
   22f32:	f004 fe11 	bl	27b58 <z_impl_k_queue_get>
   22f36:	bb30      	cbnz	r0, 22f86 <att_reset+0x6e>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   22f38:	f3bf 8f5b 	dmb	ish
   22f3c:	f104 0398 	add.w	r3, r4, #152	; 0x98
   22f40:	e853 2f00 	ldrex	r2, [r3]
   22f44:	f042 0204 	orr.w	r2, r2, #4
   22f48:	e843 2100 	strex	r1, r2, [r3]
   22f4c:	2900      	cmp	r1, #0
   22f4e:	d1f7      	bne.n	22f40 <att_reset+0x28>
   22f50:	f3bf 8f5b 	dmb	ish
		k_sem_give(&att->tx_sem);
   22f54:	f104 05c8 	add.w	r5, r4, #200	; 0xc8
	z_impl_k_sem_give(sem);
   22f58:	4628      	mov	r0, r5
   22f5a:	f7fb ff0f 	bl	1ed7c <z_impl_k_sem_give>
   22f5e:	4628      	mov	r0, r5
   22f60:	f7fb ff0c 	bl	1ed7c <z_impl_k_sem_give>
   22f64:	4628      	mov	r0, r5
   22f66:	f7fb ff09 	bl	1ed7c <z_impl_k_sem_give>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->reqs, req, tmp, node) {
   22f6a:	f8d4 50a0 	ldr.w	r5, [r4, #160]	; 0xa0
   22f6e:	b96d      	cbnz	r5, 22f8c <att_reset+0x74>
	if (!att->req) {
   22f70:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
	list->head = NULL;
   22f74:	2200      	movs	r2, #0
	list->tail = NULL;
   22f76:	e9c4 2228 	strd	r2, r2, [r4, #160]	; 0xa0
   22f7a:	b9c3      	cbnz	r3, 22fae <att_reset+0x96>
}
   22f7c:	b003      	add	sp, #12
   22f7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		net_buf_unref(buf);
   22f80:	f7f6 f86c 	bl	1905c <net_buf_unref>
   22f84:	e7cc      	b.n	22f20 <att_reset+0x8>
		net_buf_unref(buf);
   22f86:	f7f6 f869 	bl	1905c <net_buf_unref>
   22f8a:	e7d0      	b.n	22f2e <att_reset+0x16>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   22f8c:	682e      	ldr	r6, [r5, #0]
		if (req->func) {
   22f8e:	686f      	ldr	r7, [r5, #4]
   22f90:	b12f      	cbz	r7, 22f9e <att_reset+0x86>
			req->func(NULL, BT_ATT_ERR_UNLIKELY, NULL, 0, req);
   22f92:	2300      	movs	r3, #0
   22f94:	9500      	str	r5, [sp, #0]
   22f96:	461a      	mov	r2, r3
   22f98:	210e      	movs	r1, #14
   22f9a:	4618      	mov	r0, r3
   22f9c:	47b8      	blx	r7
		att_req_destroy(req);
   22f9e:	4628      	mov	r0, r5
   22fa0:	f7ff ff7a 	bl	22e98 <att_req_destroy>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->reqs, req, tmp, node) {
   22fa4:	2e00      	cmp	r6, #0
   22fa6:	d0e3      	beq.n	22f70 <att_reset+0x58>
   22fa8:	4635      	mov	r5, r6
   22faa:	6836      	ldr	r6, [r6, #0]
   22fac:	e7ef      	b.n	22f8e <att_reset+0x76>
	att_handle_rsp(att, NULL, 0, BT_ATT_ERR_UNLIKELY);
   22fae:	230e      	movs	r3, #14
   22fb0:	4611      	mov	r1, r2
   22fb2:	4620      	mov	r0, r4
}
   22fb4:	b003      	add	sp, #12
   22fb6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	att_handle_rsp(att, NULL, 0, BT_ATT_ERR_UNLIKELY);
   22fba:	f7e9 b9db 	b.w	c374 <att_handle_rsp>

00022fbe <bt_att_send>:
{
   22fbe:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   22fc2:	4607      	mov	r7, r0
   22fc4:	460d      	mov	r5, r1
   22fc6:	4614      	mov	r4, r2
   22fc8:	4698      	mov	r8, r3
	att = att_chan_get(conn);
   22fca:	f7e8 fc1f 	bl	b80c <att_chan_get>
	if (!att) {
   22fce:	4606      	mov	r6, r0
   22fd0:	b938      	cbnz	r0, 22fe2 <bt_att_send+0x24>
		net_buf_unref(buf);
   22fd2:	4628      	mov	r0, r5
   22fd4:	f7f6 f842 	bl	1905c <net_buf_unref>
		return -ENOTCONN;
   22fd8:	f06f 057f 	mvn.w	r5, #127	; 0x7f
}
   22fdc:	4628      	mov	r0, r5
   22fde:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!cb) {
   22fe2:	b964      	cbnz	r4, 22ffe <bt_att_send+0x40>
	return z_impl_k_sem_take(sem, timeout);
   22fe4:	4621      	mov	r1, r4
   22fe6:	30c8      	adds	r0, #200	; 0xc8
   22fe8:	f7fb fef4 	bl	1edd4 <z_impl_k_sem_take>
		if (k_sem_take(&att->tx_sem, K_NO_WAIT) < 0) {
   22fec:	2800      	cmp	r0, #0
   22fee:	da06      	bge.n	22ffe <bt_att_send+0x40>
			k_fifo_put(&att->tx_queue, buf);
   22ff0:	4629      	mov	r1, r5
   22ff2:	f106 00e0 	add.w	r0, r6, #224	; 0xe0
   22ff6:	f004 fd86 	bl	27b06 <k_queue_append>
			return 0;
   22ffa:	4625      	mov	r5, r4
   22ffc:	e7ee      	b.n	22fdc <bt_att_send+0x1e>
	err = att_send(conn, buf, cb, user_data);
   22ffe:	4629      	mov	r1, r5
   23000:	4643      	mov	r3, r8
   23002:	4622      	mov	r2, r4
   23004:	4638      	mov	r0, r7
   23006:	f7e8 fb5f 	bl	b6c8 <att_send>
	if (err) {
   2300a:	4605      	mov	r5, r0
   2300c:	2800      	cmp	r0, #0
   2300e:	d0e5      	beq.n	22fdc <bt_att_send+0x1e>
		if (!cb) {
   23010:	2c00      	cmp	r4, #0
   23012:	d1e3      	bne.n	22fdc <bt_att_send+0x1e>
	z_impl_k_sem_give(sem);
   23014:	f106 00c8 	add.w	r0, r6, #200	; 0xc8
   23018:	f7fb feb0 	bl	1ed7c <z_impl_k_sem_give>
   2301c:	e7de      	b.n	22fdc <bt_att_send+0x1e>

0002301e <bt_att_req_send>:
{
   2301e:	b538      	push	{r3, r4, r5, lr}
   23020:	460c      	mov	r4, r1
	att = att_chan_get(conn);
   23022:	f7e8 fbf3 	bl	b80c <att_chan_get>
	if (!att) {
   23026:	4605      	mov	r5, r0
   23028:	b930      	cbnz	r0, 23038 <bt_att_req_send+0x1a>
		net_buf_unref(req->buf);
   2302a:	6920      	ldr	r0, [r4, #16]
   2302c:	f7f6 f816 	bl	1905c <net_buf_unref>
		req->buf = NULL;
   23030:	6125      	str	r5, [r4, #16]
		return -ENOTCONN;
   23032:	f06f 007f 	mvn.w	r0, #127	; 0x7f
}
   23036:	bd38      	pop	{r3, r4, r5, pc}
	if (att->req) {
   23038:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
   2303c:	b163      	cbz	r3, 23058 <bt_att_req_send+0x3a>
	parent->next = child;
   2303e:	2000      	movs	r0, #0
   23040:	6020      	str	r0, [r4, #0]
Z_GENLIST_APPEND(slist, snode)
   23042:	f8d5 30a4 	ldr.w	r3, [r5, #164]	; 0xa4
   23046:	b91b      	cbnz	r3, 23050 <bt_att_req_send+0x32>
	list->head = node;
   23048:	e9c5 4428 	strd	r4, r4, [r5, #160]	; 0xa0
		return 0;
   2304c:	4618      	mov	r0, r3
   2304e:	e7f2      	b.n	23036 <bt_att_req_send+0x18>
	parent->next = child;
   23050:	601c      	str	r4, [r3, #0]
	list->tail = node;
   23052:	f8c5 40a4 	str.w	r4, [r5, #164]	; 0xa4
   23056:	e7ee      	b.n	23036 <bt_att_req_send+0x18>
	return att_send_req(att, req);
   23058:	4621      	mov	r1, r4
}
   2305a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return att_send_req(att, req);
   2305e:	f7ff bdd4 	b.w	22c0a <att_send_req>

00023062 <gatt_ccc_changed>:
{
   23062:	460b      	mov	r3, r1
		if (ccc->cfg[i].value > value) {
   23064:	8909      	ldrh	r1, [r1, #8]
	if (value != ccc->value) {
   23066:	895a      	ldrh	r2, [r3, #10]
   23068:	428a      	cmp	r2, r1
   2306a:	d003      	beq.n	23074 <gatt_ccc_changed+0x12>
		ccc->value = value;
   2306c:	8159      	strh	r1, [r3, #10]
		if (ccc->cfg_changed) {
   2306e:	68db      	ldr	r3, [r3, #12]
   23070:	b103      	cbz	r3, 23074 <gatt_ccc_changed+0x12>
			ccc->cfg_changed(attr, value);
   23072:	4718      	bx	r3
}
   23074:	4770      	bx	lr

00023076 <gatt_indicate_rsp>:
{
   23076:	b410      	push	{r4}
   23078:	9b01      	ldr	r3, [sp, #4]
	params->func(conn, params->attr, err);
   2307a:	689c      	ldr	r4, [r3, #8]
   2307c:	460a      	mov	r2, r1
   2307e:	6859      	ldr	r1, [r3, #4]
   23080:	4623      	mov	r3, r4
}
   23082:	bc10      	pop	{r4}
	params->func(conn, params->attr, err);
   23084:	4718      	bx	r3

00023086 <write_name>:
{
   23086:	b570      	push	{r4, r5, r6, lr}
   23088:	b092      	sub	sp, #72	; 0x48
   2308a:	4615      	mov	r5, r2
   2308c:	f8bd 6058 	ldrh.w	r6, [sp, #88]	; 0x58
	char value[CONFIG_BT_DEVICE_NAME_MAX] = {};
   23090:	2241      	movs	r2, #65	; 0x41
   23092:	2100      	movs	r1, #0
   23094:	a801      	add	r0, sp, #4
{
   23096:	461c      	mov	r4, r3
	char value[CONFIG_BT_DEVICE_NAME_MAX] = {};
   23098:	f7de fdc9 	bl	1c2e <memset>
	if (offset) {
   2309c:	b96e      	cbnz	r6, 230ba <write_name+0x34>
	if (len >= sizeof(value)) {
   2309e:	2c40      	cmp	r4, #64	; 0x40
   230a0:	d80e      	bhi.n	230c0 <write_name+0x3a>
	memcpy(value, buf, len);
   230a2:	2341      	movs	r3, #65	; 0x41
   230a4:	4622      	mov	r2, r4
   230a6:	4629      	mov	r1, r5
   230a8:	a801      	add	r0, sp, #4
   230aa:	f7de fdad 	bl	1c08 <__memcpy_chk>
	bt_set_name(value);
   230ae:	a801      	add	r0, sp, #4
   230b0:	f7e6 fcae 	bl	9a10 <bt_set_name>
	return len;
   230b4:	4620      	mov	r0, r4
}
   230b6:	b012      	add	sp, #72	; 0x48
   230b8:	bd70      	pop	{r4, r5, r6, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   230ba:	f06f 0006 	mvn.w	r0, #6
   230be:	e7fa      	b.n	230b6 <write_name+0x30>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
   230c0:	f06f 000c 	mvn.w	r0, #12
   230c4:	e7f7      	b.n	230b6 <write_name+0x30>

000230c6 <gen_hash_m>:
{
   230c6:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (attr->uuid->type != BT_UUID_TYPE_16)
   230c8:	6807      	ldr	r7, [r0, #0]
   230ca:	783d      	ldrb	r5, [r7, #0]
{
   230cc:	b089      	sub	sp, #36	; 0x24
   230ce:	4606      	mov	r6, r0
   230d0:	460c      	mov	r4, r1
	if (attr->uuid->type != BT_UUID_TYPE_16)
   230d2:	b10d      	cbz	r5, 230d8 <gen_hash_m+0x12>
		return BT_GATT_ITER_CONTINUE;
   230d4:	2501      	movs	r5, #1
   230d6:	e015      	b.n	23104 <gen_hash_m+0x3e>
	switch (u16->val) {
   230d8:	887b      	ldrh	r3, [r7, #2]
   230da:	f5b3 5f24 	cmp.w	r3, #10496	; 0x2900
   230de:	d004      	beq.n	230ea <gen_hash_m+0x24>
   230e0:	d813      	bhi.n	2310a <gen_hash_m+0x44>
   230e2:	f5a3 5320 	sub.w	r3, r3, #10240	; 0x2800
   230e6:	2b03      	cmp	r3, #3
   230e8:	d8f4      	bhi.n	230d4 <gen_hash_m+0xe>
		value = sys_cpu_to_le16(attr->handle);
   230ea:	8a33      	ldrh	r3, [r6, #16]
   230ec:	f8ad 300e 	strh.w	r3, [sp, #14]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   230f0:	2202      	movs	r2, #2
   230f2:	f10d 010e 	add.w	r1, sp, #14
   230f6:	4620      	mov	r0, r4
   230f8:	f7fd fedc 	bl	20eb4 <tc_cmac_update>
   230fc:	b9d8      	cbnz	r0, 23136 <gen_hash_m+0x70>
			state->err = -EINVAL;
   230fe:	f06f 0315 	mvn.w	r3, #21
   23102:	65a3      	str	r3, [r4, #88]	; 0x58
}
   23104:	4628      	mov	r0, r5
   23106:	b009      	add	sp, #36	; 0x24
   23108:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (u16->val) {
   2310a:	f642 1205 	movw	r2, #10501	; 0x2905
   2310e:	4293      	cmp	r3, r2
   23110:	d8e0      	bhi.n	230d4 <gen_hash_m+0xe>
		value = sys_cpu_to_le16(attr->handle);
   23112:	8a03      	ldrh	r3, [r0, #16]
   23114:	f8ad 300e 	strh.w	r3, [sp, #14]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   23118:	2202      	movs	r2, #2
   2311a:	f10d 010e 	add.w	r1, sp, #14
   2311e:	4620      	mov	r0, r4
   23120:	f7fd fec8 	bl	20eb4 <tc_cmac_update>
   23124:	2800      	cmp	r0, #0
   23126:	d0ea      	beq.n	230fe <gen_hash_m+0x38>
		value = sys_cpu_to_le16(u16->val);
   23128:	887b      	ldrh	r3, [r7, #2]
   2312a:	f8ad 300e 	strh.w	r3, [sp, #14]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   2312e:	2202      	movs	r2, #2
   23130:	f10d 010e 	add.w	r1, sp, #14
   23134:	e017      	b.n	23166 <gen_hash_m+0xa0>
		value = sys_cpu_to_le16(u16->val);
   23136:	887b      	ldrh	r3, [r7, #2]
   23138:	f8ad 300e 	strh.w	r3, [sp, #14]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   2313c:	2202      	movs	r2, #2
   2313e:	f10d 010e 	add.w	r1, sp, #14
   23142:	4620      	mov	r0, r4
   23144:	f7fd feb6 	bl	20eb4 <tc_cmac_update>
   23148:	2800      	cmp	r0, #0
   2314a:	d0d8      	beq.n	230fe <gen_hash_m+0x38>
		len = attr->read(NULL, attr, data, sizeof(data), 0);
   2314c:	2000      	movs	r0, #0
   2314e:	2310      	movs	r3, #16
   23150:	eb0d 0203 	add.w	r2, sp, r3
   23154:	9000      	str	r0, [sp, #0]
   23156:	6877      	ldr	r7, [r6, #4]
   23158:	4631      	mov	r1, r6
   2315a:	47b8      	blx	r7
		if (len < 0) {
   2315c:	1e02      	subs	r2, r0, #0
   2315e:	da01      	bge.n	23164 <gen_hash_m+0x9e>
			state->err = len;
   23160:	65a2      	str	r2, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   23162:	e7cf      	b.n	23104 <gen_hash_m+0x3e>
		if (tc_cmac_update(&state->state, data, len) ==
   23164:	a904      	add	r1, sp, #16
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   23166:	4620      	mov	r0, r4
   23168:	f7fd fea4 	bl	20eb4 <tc_cmac_update>
   2316c:	2800      	cmp	r0, #0
   2316e:	d1b1      	bne.n	230d4 <gen_hash_m+0xe>
   23170:	e7c5      	b.n	230fe <gen_hash_m+0x38>

00023172 <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   23172:	f3bf 8f5b 	dmb	ish
   23176:	6800      	ldr	r0, [r0, #0]
   23178:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   2317c:	4108      	asrs	r0, r1
}
   2317e:	f000 0001 	and.w	r0, r0, #1
   23182:	4770      	bx	lr

00023184 <atomic_and>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   23184:	f3bf 8f5b 	dmb	ish
   23188:	e850 3f00 	ldrex	r3, [r0]
   2318c:	ea03 0201 	and.w	r2, r3, r1
   23190:	e840 2c00 	strex	ip, r2, [r0]
   23194:	f1bc 0f00 	cmp.w	ip, #0
   23198:	d1f6      	bne.n	23188 <atomic_and+0x4>
   2319a:	f3bf 8f5b 	dmb	ish
}
   2319e:	4618      	mov	r0, r3
   231a0:	4770      	bx	lr

000231a2 <bt_addr_le_copy>:
   231a2:	680b      	ldr	r3, [r1, #0]
   231a4:	6003      	str	r3, [r0, #0]
   231a6:	888b      	ldrh	r3, [r1, #4]
   231a8:	8083      	strh	r3, [r0, #4]
   231aa:	798b      	ldrb	r3, [r1, #6]
   231ac:	7183      	strb	r3, [r0, #6]
}
   231ae:	4770      	bx	lr

000231b0 <clear_ccc_cfg>:
{
   231b0:	b513      	push	{r0, r1, r4, lr}
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   231b2:	2200      	movs	r2, #0
{
   231b4:	4604      	mov	r4, r0
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   231b6:	4669      	mov	r1, sp
   231b8:	3001      	adds	r0, #1
   231ba:	9200      	str	r2, [sp, #0]
   231bc:	f8cd 2003 	str.w	r2, [sp, #3]
   231c0:	f7ff ffef 	bl	231a2 <bt_addr_le_copy>
	cfg->id = 0U;
   231c4:	7022      	strb	r2, [r4, #0]
	cfg->value = 0U;
   231c6:	8122      	strh	r2, [r4, #8]
}
   231c8:	b002      	add	sp, #8
   231ca:	bd10      	pop	{r4, pc}

000231cc <gatt_read_multiple_rsp>:
{
   231cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   231ce:	9c08      	ldr	r4, [sp, #32]
   231d0:	4606      	mov	r6, r0
   231d2:	6827      	ldr	r7, [r4, #0]
	if (err || !length) {
   231d4:	460d      	mov	r5, r1
   231d6:	b901      	cbnz	r1, 231da <gatt_read_multiple_rsp+0xe>
   231d8:	b94b      	cbnz	r3, 231ee <gatt_read_multiple_rsp+0x22>
		params->func(conn, err, params, NULL, 0);
   231da:	2300      	movs	r3, #0
   231dc:	9308      	str	r3, [sp, #32]
   231de:	4622      	mov	r2, r4
   231e0:	4629      	mov	r1, r5
	params->func(conn, 0, params, NULL, 0);
   231e2:	4630      	mov	r0, r6
   231e4:	46bc      	mov	ip, r7
}
   231e6:	b003      	add	sp, #12
   231e8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	params->func(conn, 0, params, NULL, 0);
   231ec:	4760      	bx	ip
	params->func(conn, 0, params, pdu, length);
   231ee:	9300      	str	r3, [sp, #0]
   231f0:	4613      	mov	r3, r2
   231f2:	4622      	mov	r2, r4
   231f4:	47b8      	blx	r7
	params->func(conn, 0, params, NULL, 0);
   231f6:	9508      	str	r5, [sp, #32]
   231f8:	6827      	ldr	r7, [r4, #0]
   231fa:	462b      	mov	r3, r5
   231fc:	4622      	mov	r2, r4
   231fe:	4629      	mov	r1, r5
   23200:	e7ef      	b.n	231e2 <gatt_read_multiple_rsp+0x16>

00023202 <gatt_sub_remove.part.13>:
static void gatt_sub_remove(struct bt_conn *conn, struct gatt_sub *sub,
   23202:	b507      	push	{r0, r1, r2, lr}
		bt_addr_le_copy(&sub->peer, BT_ADDR_LE_ANY);
   23204:	2300      	movs	r3, #0
   23206:	4669      	mov	r1, sp
   23208:	9300      	str	r3, [sp, #0]
   2320a:	f8cd 3003 	str.w	r3, [sp, #3]
   2320e:	f7ff ffc8 	bl	231a2 <bt_addr_le_copy>
}
   23212:	b003      	add	sp, #12
   23214:	f85d fb04 	ldr.w	pc, [sp], #4

00023218 <bt_gatt_attr_read.constprop.33>:
ssize_t bt_gatt_attr_read(struct bt_conn *conn, const struct bt_gatt_attr *attr,
   23218:	b538      	push	{r3, r4, r5, lr}
   2321a:	4615      	mov	r5, r2
   2321c:	f8bd 2010 	ldrh.w	r2, [sp, #16]
	if (offset > value_len) {
   23220:	42aa      	cmp	r2, r5
   23222:	d30a      	bcc.n	2323a <bt_gatt_attr_read.constprop.33+0x22>
	len = MIN(buf_len, value_len - offset);
   23224:	1b54      	subs	r4, r2, r5
   23226:	428c      	cmp	r4, r1
   23228:	bfa8      	it	ge
   2322a:	460c      	movge	r4, r1
   2322c:	b2a4      	uxth	r4, r4
   2322e:	4622      	mov	r2, r4
   23230:	1959      	adds	r1, r3, r5
   23232:	f7de fcdb 	bl	1bec <memcpy>
}
   23236:	4620      	mov	r0, r4
   23238:	bd38      	pop	{r3, r4, r5, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   2323a:	f06f 0406 	mvn.w	r4, #6
   2323e:	e7fa      	b.n	23236 <bt_gatt_attr_read.constprop.33+0x1e>

00023240 <bt_gatt_attr_read_service>:
{
   23240:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   23242:	461c      	mov	r4, r3
	struct bt_uuid *uuid = attr->user_data;
   23244:	68cb      	ldr	r3, [r1, #12]
	if (uuid->type == BT_UUID_TYPE_16) {
   23246:	7819      	ldrb	r1, [r3, #0]
{
   23248:	4610      	mov	r0, r2
   2324a:	f8bd 2018 	ldrh.w	r2, [sp, #24]
	if (uuid->type == BT_UUID_TYPE_16) {
   2324e:	b959      	cbnz	r1, 23268 <bt_gatt_attr_read_service+0x28>
		u16_t uuid16 = sys_cpu_to_le16(BT_UUID_16(uuid)->val);
   23250:	885b      	ldrh	r3, [r3, #2]
   23252:	f8ad 300e 	strh.w	r3, [sp, #14]
		return bt_gatt_attr_read(conn, attr, buf, len, offset,
   23256:	2302      	movs	r3, #2
   23258:	9300      	str	r3, [sp, #0]
   2325a:	f10d 030e 	add.w	r3, sp, #14
	return bt_gatt_attr_read(conn, attr, buf, len, offset,
   2325e:	4621      	mov	r1, r4
   23260:	f7ff ffda 	bl	23218 <bt_gatt_attr_read.constprop.33>
}
   23264:	b004      	add	sp, #16
   23266:	bd10      	pop	{r4, pc}
	return bt_gatt_attr_read(conn, attr, buf, len, offset,
   23268:	2110      	movs	r1, #16
   2326a:	9100      	str	r1, [sp, #0]
   2326c:	3301      	adds	r3, #1
   2326e:	e7f6      	b.n	2325e <bt_gatt_attr_read_service+0x1e>

00023270 <read_name>:
{
   23270:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   23274:	4614      	mov	r4, r2
   23276:	461d      	mov	r5, r3
   23278:	f8bd 6018 	ldrh.w	r6, [sp, #24]
	const char *name = bt_get_name();
   2327c:	f7e6 fc1a 	bl	9ab4 <bt_get_name>
   23280:	4607      	mov	r7, r0
				 strlen(name));
   23282:	f7de fd11 	bl	1ca8 <strlen>
	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
   23286:	b280      	uxth	r0, r0
   23288:	9006      	str	r0, [sp, #24]
   2328a:	463b      	mov	r3, r7
   2328c:	4632      	mov	r2, r6
   2328e:	4629      	mov	r1, r5
   23290:	4620      	mov	r0, r4
}
   23292:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
   23296:	f7ff bfbf 	b.w	23218 <bt_gatt_attr_read.constprop.33>

0002329a <read_appearance>:
{
   2329a:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   2329c:	4619      	mov	r1, r3
	u16_t appearance = sys_cpu_to_le16(gap_appearance);
   2329e:	f240 3341 	movw	r3, #833	; 0x341
   232a2:	f8ad 300e 	strh.w	r3, [sp, #14]
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &appearance,
   232a6:	2302      	movs	r3, #2
   232a8:	9300      	str	r3, [sp, #0]
{
   232aa:	4610      	mov	r0, r2
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &appearance,
   232ac:	f10d 030e 	add.w	r3, sp, #14
   232b0:	f8bd 2018 	ldrh.w	r2, [sp, #24]
   232b4:	f7ff ffb0 	bl	23218 <bt_gatt_attr_read.constprop.33>
}
   232b8:	b005      	add	sp, #20
   232ba:	f85d fb04 	ldr.w	pc, [sp], #4

000232be <clear_cf_cfg>:
{
   232be:	b513      	push	{r0, r1, r4, lr}
   232c0:	4602      	mov	r2, r0
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   232c2:	2400      	movs	r4, #0
   232c4:	4669      	mov	r1, sp
   232c6:	3001      	adds	r0, #1
   232c8:	9400      	str	r4, [sp, #0]
   232ca:	f8cd 4003 	str.w	r4, [sp, #3]
   232ce:	f7ff ff68 	bl	231a2 <bt_addr_le_copy>
__ssp_bos_icheck3(memset, void *, int)
   232d2:	7214      	strb	r4, [r2, #8]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   232d4:	320c      	adds	r2, #12
   232d6:	f3bf 8f5b 	dmb	ish
   232da:	e852 3f00 	ldrex	r3, [r2]
   232de:	e842 4100 	strex	r1, r4, [r2]
   232e2:	2900      	cmp	r1, #0
   232e4:	d1f9      	bne.n	232da <clear_cf_cfg+0x1c>
   232e6:	f3bf 8f5b 	dmb	ish
}
   232ea:	b002      	add	sp, #8
   232ec:	bd10      	pop	{r4, pc}

000232ee <match_uuid>:
   232ee:	6008      	str	r0, [r1, #0]
   232f0:	2000      	movs	r0, #0
   232f2:	4770      	bx	lr

000232f4 <ccc_find_cfg>:
{
   232f4:	b510      	push	{r4, lr}
		if (id == ccc->cfg[i].id &&
   232f6:	7803      	ldrb	r3, [r0, #0]
   232f8:	4293      	cmp	r3, r2
{
   232fa:	4604      	mov	r4, r0
		if (id == ccc->cfg[i].id &&
   232fc:	d001      	beq.n	23302 <ccc_find_cfg+0xe>
	return NULL;
   232fe:	2000      	movs	r0, #0
}
   23300:	bd10      	pop	{r4, pc}
	return memcmp(a, b, sizeof(*a));
   23302:	2207      	movs	r2, #7
   23304:	3001      	adds	r0, #1
   23306:	f7de fc63 	bl	1bd0 <memcmp>
		if (id == ccc->cfg[i].id &&
   2330a:	2800      	cmp	r0, #0
   2330c:	d1f7      	bne.n	232fe <ccc_find_cfg+0xa>
			return &ccc->cfg[i];
   2330e:	4620      	mov	r0, r4
   23310:	e7f6      	b.n	23300 <ccc_find_cfg+0xc>

00023312 <find_ccc_cfg>:
{
   23312:	b513      	push	{r0, r1, r4, lr}
   23314:	460c      	mov	r4, r1
		if (conn) {
   23316:	b168      	cbz	r0, 23334 <find_ccc_cfg+0x22>
			if (conn->id == ccc->cfg[i].id &&
   23318:	7a02      	ldrb	r2, [r0, #8]
   2331a:	780b      	ldrb	r3, [r1, #0]
   2331c:	429a      	cmp	r2, r3
   2331e:	d002      	beq.n	23326 <find_ccc_cfg+0x14>
	return NULL;
   23320:	2000      	movs	r0, #0
}
   23322:	b002      	add	sp, #8
   23324:	bd10      	pop	{r4, pc}
			    !bt_conn_addr_le_cmp(conn, &ccc->cfg[i].peer)) {
   23326:	3101      	adds	r1, #1
   23328:	f7ff f9e1 	bl	226ee <bt_conn_addr_le_cmp>
			if (conn->id == ccc->cfg[i].id &&
   2332c:	2800      	cmp	r0, #0
   2332e:	d1f7      	bne.n	23320 <find_ccc_cfg+0xe>
				return &ccc->cfg[i];
   23330:	4620      	mov	r0, r4
   23332:	e7f6      	b.n	23322 <find_ccc_cfg+0x10>
		} else if (!bt_addr_le_cmp(&ccc->cfg[i].peer, BT_ADDR_LE_ANY)) {
   23334:	9000      	str	r0, [sp, #0]
   23336:	2207      	movs	r2, #7
   23338:	f8cd 0003 	str.w	r0, [sp, #3]
   2333c:	4669      	mov	r1, sp
   2333e:	1c60      	adds	r0, r4, #1
   23340:	f7de fc46 	bl	1bd0 <memcmp>
   23344:	e7f2      	b.n	2332c <find_ccc_cfg+0x1a>

00023346 <bt_gatt_attr_read_ccc>:
{
   23346:	b530      	push	{r4, r5, lr}
	cfg = find_ccc_cfg(conn, ccc);
   23348:	68c9      	ldr	r1, [r1, #12]
{
   2334a:	b085      	sub	sp, #20
   2334c:	4614      	mov	r4, r2
   2334e:	461d      	mov	r5, r3
	cfg = find_ccc_cfg(conn, ccc);
   23350:	f7ff ffdf 	bl	23312 <find_ccc_cfg>
	if (cfg) {
   23354:	b100      	cbz	r0, 23358 <bt_gatt_attr_read_ccc+0x12>
		value = sys_cpu_to_le16(cfg->value);
   23356:	8900      	ldrh	r0, [r0, #8]
   23358:	f8ad 000e 	strh.w	r0, [sp, #14]
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value,
   2335c:	2302      	movs	r3, #2
   2335e:	9300      	str	r3, [sp, #0]
   23360:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   23364:	f10d 030e 	add.w	r3, sp, #14
   23368:	4629      	mov	r1, r5
   2336a:	4620      	mov	r0, r4
   2336c:	f7ff ff54 	bl	23218 <bt_gatt_attr_read.constprop.33>
}
   23370:	b005      	add	sp, #20
   23372:	bd30      	pop	{r4, r5, pc}

00023374 <atomic_set_bit>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   23374:	2301      	movs	r3, #1
   23376:	fa03 f101 	lsl.w	r1, r3, r1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2337a:	f3bf 8f5b 	dmb	ish
   2337e:	e850 3f00 	ldrex	r3, [r0]
   23382:	430b      	orrs	r3, r1
   23384:	e840 3200 	strex	r2, r3, [r0]
   23388:	2a00      	cmp	r2, #0
   2338a:	d1f8      	bne.n	2337e <atomic_set_bit+0xa>
   2338c:	f3bf 8f5b 	dmb	ish
}
   23390:	4770      	bx	lr

00023392 <sc_ccc_cfg_write>:
{
   23392:	b508      	push	{r3, lr}
   23394:	4601      	mov	r1, r0
	if (value == BT_GATT_CCC_INDICATE) {
   23396:	2a02      	cmp	r2, #2
   23398:	7a00      	ldrb	r0, [r0, #8]
   2339a:	f101 0174 	add.w	r1, r1, #116	; 0x74
   2339e:	d105      	bne.n	233ac <sc_ccc_cfg_write+0x1a>
		sc_save(conn->id, &conn->le.dst, 0, 0);
   233a0:	2300      	movs	r3, #0
   233a2:	461a      	mov	r2, r3
   233a4:	f7e9 fcd6 	bl	cd54 <sc_save>
}
   233a8:	2002      	movs	r0, #2
   233aa:	bd08      	pop	{r3, pc}
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
   233ac:	f7e9 fcb0 	bl	cd10 <find_sc_cfg.part.10>
		if (cfg) {
   233b0:	2800      	cmp	r0, #0
   233b2:	d0f9      	beq.n	233a8 <sc_ccc_cfg_write+0x16>
			sc_clear(cfg);
   233b4:	f7e9 fa1c 	bl	c7f0 <sc_clear>
   233b8:	e7f6      	b.n	233a8 <sc_ccc_cfg_write+0x16>

000233ba <sc_restore_rsp>:
{
   233ba:	b508      	push	{r3, lr}
   233bc:	f7e9 fe14 	bl	cfe8 <find_cf_cfg.part.9>
	if (cfg && CF_ROBUST_CACHING(cfg)) {
   233c0:	b140      	cbz	r0, 233d4 <sc_restore_rsp+0x1a>
   233c2:	7a03      	ldrb	r3, [r0, #8]
   233c4:	07db      	lsls	r3, r3, #31
   233c6:	d505      	bpl.n	233d4 <sc_restore_rsp+0x1a>
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   233c8:	2100      	movs	r1, #0
   233ca:	300c      	adds	r0, #12
}
   233cc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   233d0:	f7ff bfd0 	b.w	23374 <atomic_set_bit>
}
   233d4:	bd08      	pop	{r3, pc}

000233d6 <cf_read>:
{
   233d6:	b530      	push	{r4, r5, lr}
   233d8:	b085      	sub	sp, #20
   233da:	461d      	mov	r5, r3
	u8_t data[1] = {};
   233dc:	2300      	movs	r3, #0
{
   233de:	4614      	mov	r4, r2
	u8_t data[1] = {};
   233e0:	f88d 300c 	strb.w	r3, [sp, #12]
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
   233e4:	f7e9 fe00 	bl	cfe8 <find_cf_cfg.part.9>
	if (cfg) {
   233e8:	b110      	cbz	r0, 233f0 <cf_read+0x1a>
		memcpy(data, cfg->data, sizeof(data));
   233ea:	7a03      	ldrb	r3, [r0, #8]
   233ec:	f88d 300c 	strb.w	r3, [sp, #12]
	return bt_gatt_attr_read(conn, attr, buf, len, offset, data,
   233f0:	2301      	movs	r3, #1
   233f2:	9300      	str	r3, [sp, #0]
   233f4:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   233f8:	ab03      	add	r3, sp, #12
   233fa:	4629      	mov	r1, r5
   233fc:	4620      	mov	r0, r4
   233fe:	f7ff ff0b 	bl	23218 <bt_gatt_attr_read.constprop.33>
}
   23402:	b005      	add	sp, #20
   23404:	bd30      	pop	{r4, r5, pc}

00023406 <gatt_sub_remove>:
{
   23406:	b538      	push	{r3, r4, r5, lr}
   23408:	460c      	mov	r4, r1
	if (params) {
   2340a:	4619      	mov	r1, r3
   2340c:	b16b      	cbz	r3, 2342a <gatt_sub_remove+0x24>
		sys_slist_remove(&sub->list, prev, &params->node);
   2340e:	f103 0510 	add.w	r5, r3, #16
Z_GENLIST_REMOVE(slist, snode)
   23412:	691b      	ldr	r3, [r3, #16]
   23414:	b982      	cbnz	r2, 23438 <gatt_sub_remove+0x32>
   23416:	68e2      	ldr	r2, [r4, #12]
	list->head = node;
   23418:	60a3      	str	r3, [r4, #8]
Z_GENLIST_REMOVE(slist, snode)
   2341a:	4295      	cmp	r5, r2
   2341c:	d100      	bne.n	23420 <gatt_sub_remove+0x1a>
	list->tail = node;
   2341e:	60e3      	str	r3, [r4, #12]
	parent->next = child;
   23420:	2300      	movs	r3, #0
   23422:	610b      	str	r3, [r1, #16]
		params->notify(conn, params, NULL, 0);
   23424:	680d      	ldr	r5, [r1, #0]
   23426:	461a      	mov	r2, r3
   23428:	47a8      	blx	r5
	if (sys_slist_is_empty(&sub->list)) {
   2342a:	68a3      	ldr	r3, [r4, #8]
   2342c:	b953      	cbnz	r3, 23444 <gatt_sub_remove+0x3e>
   2342e:	4620      	mov	r0, r4
}
   23430:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   23434:	f7ff bee5 	b.w	23202 <gatt_sub_remove.part.13>
   23438:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   2343a:	68e3      	ldr	r3, [r4, #12]
   2343c:	429d      	cmp	r5, r3
	list->tail = node;
   2343e:	bf08      	it	eq
   23440:	60e2      	streq	r2, [r4, #12]
   23442:	e7ed      	b.n	23420 <gatt_sub_remove+0x1a>
   23444:	bd38      	pop	{r3, r4, r5, pc}

00023446 <gatt_write_ccc_rsp>:
{
   23446:	b570      	push	{r4, r5, r6, lr}
   23448:	9c04      	ldr	r4, [sp, #16]
   2344a:	460e      	mov	r6, r1
   2344c:	4605      	mov	r5, r0
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2344e:	f06f 0104 	mvn.w	r1, #4
   23452:	f104 000c 	add.w	r0, r4, #12
   23456:	f7ff fe95 	bl	23184 <atomic_and>
	if (err) {
   2345a:	b1b6      	cbz	r6, 2348a <gatt_write_ccc_rsp+0x44>
		sub = gatt_sub_find(conn);
   2345c:	2100      	movs	r1, #0
   2345e:	4628      	mov	r0, r5
   23460:	f7e9 fc22 	bl	cca8 <gatt_sub_find_free>
		if (!sub) {
   23464:	4601      	mov	r1, r0
   23466:	b1d0      	cbz	r0, 2349e <gatt_write_ccc_rsp+0x58>
		SYS_SLIST_FOR_EACH_NODE_SAFE(&sub->list, node, tmp) {
   23468:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_PEEK_NEXT(slist, snode)
   2346a:	b1c3      	cbz	r3, 2349e <gatt_write_ccc_rsp+0x58>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   2346c:	681a      	ldr	r2, [r3, #0]
			if (node == &params->node) {
   2346e:	f104 0010 	add.w	r0, r4, #16
   23472:	4283      	cmp	r3, r0
   23474:	d105      	bne.n	23482 <gatt_write_ccc_rsp+0x3c>
				gatt_sub_remove(conn, sub, tmp, params);
   23476:	4623      	mov	r3, r4
   23478:	4628      	mov	r0, r5
}
   2347a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				gatt_sub_remove(conn, sub, tmp, params);
   2347e:	f7ff bfc2 	b.w	23406 <gatt_sub_remove>
Z_GENLIST_PEEK_NEXT(slist, snode)
   23482:	b162      	cbz	r2, 2349e <gatt_write_ccc_rsp+0x58>
   23484:	4613      	mov	r3, r2
   23486:	6812      	ldr	r2, [r2, #0]
   23488:	e7f3      	b.n	23472 <gatt_write_ccc_rsp+0x2c>
	} else if (!params->value) {
   2348a:	8923      	ldrh	r3, [r4, #8]
   2348c:	b93b      	cbnz	r3, 2349e <gatt_write_ccc_rsp+0x58>
		params->notify(conn, params, NULL, 0);
   2348e:	6826      	ldr	r6, [r4, #0]
   23490:	4621      	mov	r1, r4
   23492:	4628      	mov	r0, r5
   23494:	46b4      	mov	ip, r6
   23496:	461a      	mov	r2, r3
}
   23498:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		params->notify(conn, params, NULL, 0);
   2349c:	4760      	bx	ip
}
   2349e:	bd70      	pop	{r4, r5, r6, pc}

000234a0 <bt_gatt_attr_read>:
{
   234a0:	b510      	push	{r4, lr}
   234a2:	4610      	mov	r0, r2
   234a4:	f8bd 1008 	ldrh.w	r1, [sp, #8]
   234a8:	f8bd 2010 	ldrh.w	r2, [sp, #16]
	if (offset > value_len) {
   234ac:	428a      	cmp	r2, r1
   234ae:	d30b      	bcc.n	234c8 <bt_gatt_attr_read+0x28>
	len = MIN(buf_len, value_len - offset);
   234b0:	1a54      	subs	r4, r2, r1
   234b2:	429c      	cmp	r4, r3
   234b4:	bfa8      	it	ge
   234b6:	461c      	movge	r4, r3
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   234b8:	9b03      	ldr	r3, [sp, #12]
   234ba:	b2a4      	uxth	r4, r4
   234bc:	4622      	mov	r2, r4
   234be:	4419      	add	r1, r3
   234c0:	f7de fb94 	bl	1bec <memcpy>
}
   234c4:	4620      	mov	r0, r4
   234c6:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   234c8:	f06f 0406 	mvn.w	r4, #6
   234cc:	e7fa      	b.n	234c4 <bt_gatt_attr_read+0x24>

000234ce <bt_gatt_attr_read_chrc>:
{
   234ce:	b570      	push	{r4, r5, r6, lr}
	struct bt_gatt_chrc *chrc = attr->user_data;
   234d0:	68cc      	ldr	r4, [r1, #12]
{
   234d2:	b088      	sub	sp, #32
   234d4:	4608      	mov	r0, r1
   234d6:	461e      	mov	r6, r3
	pdu.properties = chrc->properties;
   234d8:	79a3      	ldrb	r3, [r4, #6]
   234da:	f88d 300c 	strb.w	r3, [sp, #12]
{
   234de:	4615      	mov	r5, r2
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   234e0:	f7e9 feea 	bl	d2b8 <bt_gatt_attr_value_handle>
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   234e4:	6823      	ldr	r3, [r4, #0]
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   234e6:	f8ad 000d 	strh.w	r0, [sp, #13]
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   234ea:	781a      	ldrb	r2, [r3, #0]
   234ec:	b96a      	cbnz	r2, 2350a <bt_gatt_attr_read_chrc+0x3c>
		pdu.uuid16 = sys_cpu_to_le16(BT_UUID_16(chrc->uuid)->val);
   234ee:	885b      	ldrh	r3, [r3, #2]
   234f0:	f8ad 300f 	strh.w	r3, [sp, #15]
		value_len += 2U;
   234f4:	2305      	movs	r3, #5
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &pdu, value_len);
   234f6:	9300      	str	r3, [sp, #0]
   234f8:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
   234fc:	ab03      	add	r3, sp, #12
   234fe:	4631      	mov	r1, r6
   23500:	4628      	mov	r0, r5
   23502:	f7ff fe89 	bl	23218 <bt_gatt_attr_read.constprop.33>
}
   23506:	b008      	add	sp, #32
   23508:	bd70      	pop	{r4, r5, r6, pc}
		memcpy(pdu.uuid, BT_UUID_128(chrc->uuid)->val, 16);
   2350a:	1c5a      	adds	r2, r3, #1
   2350c:	f10d 000f 	add.w	r0, sp, #15
   23510:	3311      	adds	r3, #17
   23512:	f852 1b04 	ldr.w	r1, [r2], #4
   23516:	f840 1b04 	str.w	r1, [r0], #4
   2351a:	429a      	cmp	r2, r3
   2351c:	d1f9      	bne.n	23512 <bt_gatt_attr_read_chrc+0x44>
		value_len += 16U;
   2351e:	2313      	movs	r3, #19
   23520:	e7e9      	b.n	234f6 <bt_gatt_attr_read_chrc+0x28>

00023522 <bt_gatt_foreach_attr>:
{
   23522:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   23524:	e9cd 2301 	strd	r2, r3, [sp, #4]
   23528:	2300      	movs	r3, #0
   2352a:	9300      	str	r3, [sp, #0]
   2352c:	461a      	mov	r2, r3
   2352e:	f7e9 fedb 	bl	d2e8 <bt_gatt_foreach_attr_type>
}
   23532:	b005      	add	sp, #20
   23534:	f85d fb04 	ldr.w	pc, [sp], #4

00023538 <db_hash_process>:
	db_hash_gen(true);
   23538:	2001      	movs	r0, #1
   2353a:	f7e9 bf3d 	b.w	d3b8 <db_hash_gen>

0002353e <bt_gatt_attr_read_cep>:
{
   2353e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   23540:	461c      	mov	r4, r3
	u16_t props = sys_cpu_to_le16(value->properties);
   23542:	68cb      	ldr	r3, [r1, #12]
   23544:	881b      	ldrh	r3, [r3, #0]
   23546:	f8ad 300e 	strh.w	r3, [sp, #14]
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &props,
   2354a:	2302      	movs	r3, #2
   2354c:	9300      	str	r3, [sp, #0]
{
   2354e:	4610      	mov	r0, r2
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &props,
   23550:	f10d 030e 	add.w	r3, sp, #14
   23554:	f8bd 2018 	ldrh.w	r2, [sp, #24]
   23558:	4621      	mov	r1, r4
   2355a:	f7ff fe5d 	bl	23218 <bt_gatt_attr_read.constprop.33>
}
   2355e:	b004      	add	sp, #16
   23560:	bd10      	pop	{r4, pc}

00023562 <bt_gatt_check_perm>:
{
   23562:	b538      	push	{r3, r4, r5, lr}
	if ((mask & BT_GATT_PERM_READ) &&
   23564:	07d4      	lsls	r4, r2, #31
{
   23566:	4605      	mov	r5, r0
   23568:	7c88      	ldrb	r0, [r1, #18]
	if ((mask & BT_GATT_PERM_READ) &&
   2356a:	d504      	bpl.n	23576 <bt_gatt_check_perm+0x14>
   2356c:	f010 0f15 	tst.w	r0, #21
   23570:	d01e      	beq.n	235b0 <bt_gatt_check_perm+0x4e>
	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
   23572:	684b      	ldr	r3, [r1, #4]
   23574:	b1e3      	cbz	r3, 235b0 <bt_gatt_check_perm+0x4e>
	if ((mask & BT_GATT_PERM_WRITE) &&
   23576:	0793      	lsls	r3, r2, #30
   23578:	d504      	bpl.n	23584 <bt_gatt_check_perm+0x22>
   2357a:	f010 0f2a 	tst.w	r0, #42	; 0x2a
   2357e:	d019      	beq.n	235b4 <bt_gatt_check_perm+0x52>
	    (!(attr->perm & BT_GATT_PERM_WRITE_MASK) || !attr->write)) {
   23580:	688b      	ldr	r3, [r1, #8]
   23582:	b1bb      	cbz	r3, 235b4 <bt_gatt_check_perm+0x52>
	mask &= attr->perm;
   23584:	ea02 0400 	and.w	r4, r2, r0
	if (mask & BT_GATT_PERM_AUTHEN_MASK) {
   23588:	f014 0f30 	tst.w	r4, #48	; 0x30
   2358c:	d103      	bne.n	23596 <bt_gatt_check_perm+0x34>
	if ((mask & BT_GATT_PERM_ENCRYPT_MASK)) {
   2358e:	f014 000c 	ands.w	r0, r4, #12
   23592:	d107      	bne.n	235a4 <bt_gatt_check_perm+0x42>
}
   23594:	bd38      	pop	{r3, r4, r5, pc}
		if (bt_conn_get_security(conn) < BT_SECURITY_L3) {
   23596:	4628      	mov	r0, r5
   23598:	f7ff f8a7 	bl	226ea <bt_conn_get_security>
   2359c:	2802      	cmp	r0, #2
   2359e:	d8f6      	bhi.n	2358e <bt_gatt_check_perm+0x2c>
			return BT_ATT_ERR_AUTHENTICATION;
   235a0:	2005      	movs	r0, #5
   235a2:	e7f7      	b.n	23594 <bt_gatt_check_perm+0x32>
		if (!conn->encrypt) {
   235a4:	7aeb      	ldrb	r3, [r5, #11]
			return BT_ATT_ERR_INSUFFICIENT_ENCRYPTION;
   235a6:	2b00      	cmp	r3, #0
   235a8:	bf14      	ite	ne
   235aa:	2000      	movne	r0, #0
   235ac:	200f      	moveq	r0, #15
   235ae:	e7f1      	b.n	23594 <bt_gatt_check_perm+0x32>
		return BT_ATT_ERR_READ_NOT_PERMITTED;
   235b0:	2002      	movs	r0, #2
   235b2:	e7ef      	b.n	23594 <bt_gatt_check_perm+0x32>
		return BT_ATT_ERR_WRITE_NOT_PERMITTED;
   235b4:	2003      	movs	r0, #3
   235b6:	e7ed      	b.n	23594 <bt_gatt_check_perm+0x32>

000235b8 <gatt_discover_next>:
{
   235b8:	b570      	push	{r4, r5, r6, lr}
   235ba:	4605      	mov	r5, r0
   235bc:	4614      	mov	r4, r2
	if (!last_handle)
   235be:	b929      	cbnz	r1, 235cc <gatt_discover_next+0x14>
	if (!bt_gatt_discover(conn, params)) {
   235c0:	4621      	mov	r1, r4
   235c2:	4628      	mov	r0, r5
   235c4:	f7ea f980 	bl	d8c8 <bt_gatt_discover>
   235c8:	b928      	cbnz	r0, 235d6 <gatt_discover_next+0x1e>
}
   235ca:	bd70      	pop	{r4, r5, r6, pc}
	if (params->start_handle < UINT16_MAX) {
   235cc:	f64f 73ff 	movw	r3, #65535	; 0xffff
   235d0:	4299      	cmp	r1, r3
   235d2:	d107      	bne.n	235e4 <gatt_discover_next+0x2c>
	params->start_handle = last_handle;
   235d4:	8111      	strh	r1, [r2, #8]
	params->func(conn, NULL, params);
   235d6:	6863      	ldr	r3, [r4, #4]
   235d8:	4622      	mov	r2, r4
   235da:	4628      	mov	r0, r5
   235dc:	2100      	movs	r1, #0
}
   235de:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	params->func(conn, NULL, params);
   235e2:	4718      	bx	r3
		params->start_handle++;
   235e4:	3101      	adds	r1, #1
	if (params->start_handle > params->end_handle) {
   235e6:	89d3      	ldrh	r3, [r2, #14]
		params->start_handle++;
   235e8:	b289      	uxth	r1, r1
	if (params->start_handle > params->end_handle) {
   235ea:	428b      	cmp	r3, r1
		params->start_handle++;
   235ec:	8111      	strh	r1, [r2, #8]
	if (params->start_handle > params->end_handle) {
   235ee:	d2e7      	bcs.n	235c0 <gatt_discover_next+0x8>
   235f0:	e7f1      	b.n	235d6 <gatt_discover_next+0x1e>

000235f2 <gatt_find_type_rsp>:
{
   235f2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   235f6:	b088      	sub	sp, #32
   235f8:	4607      	mov	r7, r0
   235fa:	4690      	mov	r8, r2
   235fc:	461e      	mov	r6, r3
   235fe:	9d10      	ldr	r5, [sp, #64]	; 0x40
	if (err) {
   23600:	2900      	cmp	r1, #0
   23602:	d13a      	bne.n	2367a <gatt_find_type_rsp+0x88>
   23604:	460c      	mov	r4, r1
	u16_t end_handle = 0U, start_handle;
   23606:	468a      	mov	sl, r1
		struct bt_gatt_attr attr = {};
   23608:	4689      	mov	r9, r1
	for (i = 0U; length >= sizeof(rsp->list[i]);
   2360a:	2e03      	cmp	r6, #3
   2360c:	d809      	bhi.n	23622 <gatt_find_type_rsp+0x30>
	if (length > 0) {
   2360e:	2e00      	cmp	r6, #0
   23610:	d133      	bne.n	2367a <gatt_find_type_rsp+0x88>
	gatt_discover_next(conn, end_handle, params);
   23612:	462a      	mov	r2, r5
   23614:	4651      	mov	r1, sl
   23616:	4638      	mov	r0, r7
   23618:	f7ff ffce 	bl	235b8 <gatt_discover_next>
}
   2361c:	b008      	add	sp, #32
   2361e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		struct bt_gatt_attr attr = {};
   23622:	2210      	movs	r2, #16
   23624:	2100      	movs	r1, #0
   23626:	eb0d 0002 	add.w	r0, sp, r2
   2362a:	f7de fb00 	bl	1c2e <memset>
		start_handle = sys_le16_to_cpu(rsp->list[i].start_handle);
   2362e:	b2e3      	uxtb	r3, r4
   23630:	eb08 0383 	add.w	r3, r8, r3, lsl #2
		uuid_svc.uuid.type = BT_UUID_TYPE_16;
   23634:	f88d 9000 	strb.w	r9, [sp]
		start_handle = sys_le16_to_cpu(rsp->list[i].start_handle);
   23638:	881a      	ldrh	r2, [r3, #0]
		end_handle = sys_le16_to_cpu(rsp->list[i].end_handle);
   2363a:	f8b3 a002 	ldrh.w	sl, [r3, #2]
		if (params->type == BT_GATT_DISCOVER_PRIMARY) {
   2363e:	7c2b      	ldrb	r3, [r5, #16]
		attr.handle = start_handle;
   23640:	f8ad 201c 	strh.w	r2, [sp, #28]
			uuid_svc.val = BT_UUID_16(BT_UUID_GATT_SECONDARY)->val;
   23644:	2b00      	cmp	r3, #0
   23646:	f642 0301 	movw	r3, #10241	; 0x2801
   2364a:	bf08      	it	eq
   2364c:	f44f 5320 	moveq.w	r3, #10240	; 0x2800
   23650:	f8ad 3002 	strh.w	r3, [sp, #2]
		value.uuid = params->uuid;
   23654:	682b      	ldr	r3, [r5, #0]
   23656:	9301      	str	r3, [sp, #4]
		attr.user_data = &value;
   23658:	ab01      	add	r3, sp, #4
   2365a:	9306      	str	r3, [sp, #24]
		value.end_handle = end_handle;
   2365c:	f8ad a008 	strh.w	sl, [sp, #8]
		attr.uuid = &uuid_svc.uuid;
   23660:	f8cd d00c 	str.w	sp, [sp, #12]
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   23664:	686b      	ldr	r3, [r5, #4]
   23666:	462a      	mov	r2, r5
   23668:	a903      	add	r1, sp, #12
   2366a:	4638      	mov	r0, r7
   2366c:	4798      	blx	r3
   2366e:	3401      	adds	r4, #1
   23670:	2800      	cmp	r0, #0
   23672:	d0d3      	beq.n	2361c <gatt_find_type_rsp+0x2a>
	     i++, length -=  sizeof(rsp->list[i])) {
   23674:	3e04      	subs	r6, #4
   23676:	b2b6      	uxth	r6, r6
   23678:	e7c7      	b.n	2360a <gatt_find_type_rsp+0x18>
	params->func(conn, NULL, params);
   2367a:	686b      	ldr	r3, [r5, #4]
   2367c:	462a      	mov	r2, r5
   2367e:	2100      	movs	r1, #0
   23680:	4638      	mov	r0, r7
   23682:	4798      	blx	r3
   23684:	e7ca      	b.n	2361c <gatt_find_type_rsp+0x2a>

00023686 <bt_gatt_unsubscribe>:
	if (conn->state != BT_CONN_CONNECTED) {
   23686:	7b43      	ldrb	r3, [r0, #13]
   23688:	2b06      	cmp	r3, #6
{
   2368a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2368e:	4681      	mov	r9, r0
   23690:	460e      	mov	r6, r1
	if (conn->state != BT_CONN_CONNECTED) {
   23692:	d169      	bne.n	23768 <bt_gatt_unsubscribe+0xe2>
	sub = gatt_sub_find(conn);
   23694:	2100      	movs	r1, #0
   23696:	f7e9 fb07 	bl	cca8 <gatt_sub_find_free>
	if (!sub) {
   2369a:	4680      	mov	r8, r0
   2369c:	b920      	cbnz	r0, 236a8 <bt_gatt_unsubscribe+0x22>
		return -EINVAL;
   2369e:	f06f 0015 	mvn.w	r0, #21
}
   236a2:	b003      	add	sp, #12
   236a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, tmp, next, node) {
   236a8:	6885      	ldr	r5, [r0, #8]
   236aa:	b1c5      	cbz	r5, 236de <bt_gatt_unsubscribe+0x58>
   236ac:	f1b5 0410 	subs.w	r4, r5, #16
   236b0:	d017      	beq.n	236e2 <bt_gatt_unsubscribe+0x5c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   236b2:	682d      	ldr	r5, [r5, #0]
   236b4:	b105      	cbz	r5, 236b8 <bt_gatt_unsubscribe+0x32>
   236b6:	3d10      	subs	r5, #16
   236b8:	2700      	movs	r7, #0
   236ba:	463b      	mov	r3, r7
   236bc:	46ba      	mov	sl, r7
			if (atomic_test_bit(params->flags,
   236be:	f106 0b0c 	add.w	fp, r6, #12
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, tmp, next, node) {
   236c2:	b984      	cbnz	r4, 236e6 <bt_gatt_unsubscribe+0x60>
	if (!found) {
   236c4:	2b00      	cmp	r3, #0
   236c6:	d0ea      	beq.n	2369e <bt_gatt_unsubscribe+0x18>
	if (has_subscription) {
   236c8:	f1ba 0f00 	cmp.w	sl, #0
   236cc:	d041      	beq.n	23752 <bt_gatt_unsubscribe+0xcc>
		params->notify(conn, params, NULL, 0);
   236ce:	6835      	ldr	r5, [r6, #0]
   236d0:	4623      	mov	r3, r4
   236d2:	4622      	mov	r2, r4
   236d4:	4631      	mov	r1, r6
   236d6:	4648      	mov	r0, r9
   236d8:	47a8      	blx	r5
		return 0;
   236da:	4620      	mov	r0, r4
   236dc:	e7e1      	b.n	236a2 <bt_gatt_unsubscribe+0x1c>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, tmp, next, node) {
   236de:	462c      	mov	r4, r5
   236e0:	e7ea      	b.n	236b8 <bt_gatt_unsubscribe+0x32>
   236e2:	4625      	mov	r5, r4
   236e4:	e7e8      	b.n	236b8 <bt_gatt_unsubscribe+0x32>
		if (params == tmp) {
   236e6:	42b4      	cmp	r4, r6
   236e8:	f104 0110 	add.w	r1, r4, #16
   236ec:	d125      	bne.n	2373a <bt_gatt_unsubscribe+0xb4>
Z_GENLIST_REMOVE(slist, snode)
   236ee:	6920      	ldr	r0, [r4, #16]
   236f0:	b9df      	cbnz	r7, 2372a <bt_gatt_unsubscribe+0xa4>
   236f2:	f8d8 300c 	ldr.w	r3, [r8, #12]
	list->head = node;
   236f6:	f8c8 0008 	str.w	r0, [r8, #8]
Z_GENLIST_REMOVE(slist, snode)
   236fa:	4299      	cmp	r1, r3
   236fc:	d101      	bne.n	23702 <bt_gatt_unsubscribe+0x7c>
	list->tail = node;
   236fe:	f8c8 000c 	str.w	r0, [r8, #12]
	parent->next = child;
   23702:	2300      	movs	r3, #0
   23704:	6123      	str	r3, [r4, #16]
			if (atomic_test_bit(params->flags,
   23706:	2102      	movs	r1, #2
   23708:	4658      	mov	r0, fp
   2370a:	f7ff fd32 	bl	23172 <atomic_test_bit>
   2370e:	b1e0      	cbz	r0, 2374a <bt_gatt_unsubscribe+0xc4>
   23710:	9001      	str	r0, [sp, #4]
	bt_att_req_cancel(conn, params);
   23712:	4631      	mov	r1, r6
   23714:	4648      	mov	r0, r9
   23716:	f7e8 ff55 	bl	c5c4 <bt_att_req_cancel>
   2371a:	9b01      	ldr	r3, [sp, #4]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, tmp, next, node) {
   2371c:	b1bd      	cbz	r5, 2374e <bt_gatt_unsubscribe+0xc8>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   2371e:	6929      	ldr	r1, [r5, #16]
   23720:	b101      	cbz	r1, 23724 <bt_gatt_unsubscribe+0x9e>
   23722:	3910      	subs	r1, #16
   23724:	462c      	mov	r4, r5
   23726:	460d      	mov	r5, r1
   23728:	e7cb      	b.n	236c2 <bt_gatt_unsubscribe+0x3c>
	parent->next = child;
   2372a:	6038      	str	r0, [r7, #0]
Z_GENLIST_REMOVE(slist, snode)
   2372c:	f8d8 300c 	ldr.w	r3, [r8, #12]
   23730:	4299      	cmp	r1, r3
	list->tail = node;
   23732:	bf08      	it	eq
   23734:	f8c8 700c 	streq.w	r7, [r8, #12]
   23738:	e7e3      	b.n	23702 <bt_gatt_unsubscribe+0x7c>
		if (tmp->value_handle == params->value_handle) {
   2373a:	88a4      	ldrh	r4, [r4, #4]
   2373c:	88b0      	ldrh	r0, [r6, #4]
   2373e:	460f      	mov	r7, r1
   23740:	4284      	cmp	r4, r0
   23742:	bf08      	it	eq
   23744:	f04f 0a01 	moveq.w	sl, #1
   23748:	e7e8      	b.n	2371c <bt_gatt_unsubscribe+0x96>
			found = true;
   2374a:	2301      	movs	r3, #1
   2374c:	e7e6      	b.n	2371c <bt_gatt_unsubscribe+0x96>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, tmp, next, node) {
   2374e:	4629      	mov	r1, r5
   23750:	e7e8      	b.n	23724 <bt_gatt_unsubscribe+0x9e>
	return gatt_write_ccc(conn, params->ccc_handle, params->value,
   23752:	88f1      	ldrh	r1, [r6, #6]
	params->value = 0x0000;
   23754:	f8a6 a008 	strh.w	sl, [r6, #8]
	return gatt_write_ccc(conn, params->ccc_handle, params->value,
   23758:	4633      	mov	r3, r6
   2375a:	4652      	mov	r2, sl
   2375c:	4648      	mov	r0, r9
}
   2375e:	b003      	add	sp, #12
   23760:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return gatt_write_ccc(conn, params->ccc_handle, params->value,
   23764:	f7e9 ba6c 	b.w	cc40 <gatt_write_ccc.constprop.32>
		return -ENOTCONN;
   23768:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   2376c:	e799      	b.n	236a2 <bt_gatt_unsubscribe+0x1c>

0002376e <bt_gatt_notification>:
{
   2376e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   23772:	4688      	mov	r8, r1
	sub = gatt_sub_find(conn);
   23774:	2100      	movs	r1, #0
{
   23776:	4606      	mov	r6, r0
   23778:	4691      	mov	r9, r2
   2377a:	469a      	mov	sl, r3
	sub = gatt_sub_find(conn);
   2377c:	f7e9 fa94 	bl	cca8 <gatt_sub_find_free>
	if (!sub) {
   23780:	b1e0      	cbz	r0, 237bc <bt_gatt_notification+0x4e>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   23782:	6883      	ldr	r3, [r0, #8]
   23784:	b1d3      	cbz	r3, 237bc <bt_gatt_notification+0x4e>
   23786:	f1b3 0510 	subs.w	r5, r3, #16
   2378a:	d017      	beq.n	237bc <bt_gatt_notification+0x4e>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   2378c:	681c      	ldr	r4, [r3, #0]
   2378e:	b104      	cbz	r4, 23792 <bt_gatt_notification+0x24>
   23790:	3c10      	subs	r4, #16
		if (handle != params->value_handle) {
   23792:	88ab      	ldrh	r3, [r5, #4]
   23794:	4543      	cmp	r3, r8
   23796:	d10a      	bne.n	237ae <bt_gatt_notification+0x40>
		if (params->notify(conn, params, data, length) ==
   23798:	682f      	ldr	r7, [r5, #0]
   2379a:	4653      	mov	r3, sl
   2379c:	464a      	mov	r2, r9
   2379e:	4629      	mov	r1, r5
   237a0:	4630      	mov	r0, r6
   237a2:	47b8      	blx	r7
   237a4:	b918      	cbnz	r0, 237ae <bt_gatt_notification+0x40>
			bt_gatt_unsubscribe(conn, params);
   237a6:	4629      	mov	r1, r5
   237a8:	4630      	mov	r0, r6
   237aa:	f7ff ff6c 	bl	23686 <bt_gatt_unsubscribe>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   237ae:	b12c      	cbz	r4, 237bc <bt_gatt_notification+0x4e>
   237b0:	6923      	ldr	r3, [r4, #16]
   237b2:	b103      	cbz	r3, 237b6 <bt_gatt_notification+0x48>
   237b4:	3b10      	subs	r3, #16
{
   237b6:	4625      	mov	r5, r4
   237b8:	461c      	mov	r4, r3
   237ba:	e7ea      	b.n	23792 <bt_gatt_notification+0x24>
}
   237bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

000237c0 <bt_gatt_change_aware>:
{
   237c0:	b570      	push	{r4, r5, r6, lr}
   237c2:	460d      	mov	r5, r1
   237c4:	f7e9 fc10 	bl	cfe8 <find_cf_cfg.part.9>
	if (!cfg || !CF_ROBUST_CACHING(cfg)) {
   237c8:	b910      	cbnz	r0, 237d0 <bt_gatt_change_aware+0x10>
		return true;
   237ca:	2501      	movs	r5, #1
}
   237cc:	4628      	mov	r0, r5
   237ce:	bd70      	pop	{r4, r5, r6, pc}
	if (!cfg || !CF_ROBUST_CACHING(cfg)) {
   237d0:	7a03      	ldrb	r3, [r0, #8]
   237d2:	07db      	lsls	r3, r3, #31
   237d4:	d5f9      	bpl.n	237ca <bt_gatt_change_aware+0xa>
	if (atomic_test_bit(cfg->flags, CF_CHANGE_AWARE)) {
   237d6:	f100 040c 	add.w	r4, r0, #12
   237da:	2100      	movs	r1, #0
   237dc:	4620      	mov	r0, r4
   237de:	f7ff fcc8 	bl	23172 <atomic_test_bit>
   237e2:	4606      	mov	r6, r0
   237e4:	2800      	cmp	r0, #0
   237e6:	d1f0      	bne.n	237ca <bt_gatt_change_aware+0xa>
	if (!req) {
   237e8:	2d00      	cmp	r5, #0
   237ea:	d0ef      	beq.n	237cc <bt_gatt_change_aware+0xc>
	if (atomic_test_bit(cfg->flags, CF_OUT_OF_SYNC)) {
   237ec:	2101      	movs	r1, #1
   237ee:	4620      	mov	r0, r4
   237f0:	f7ff fcbf 	bl	23172 <atomic_test_bit>
   237f4:	4605      	mov	r5, r0
   237f6:	b148      	cbz	r0, 2380c <bt_gatt_change_aware+0x4c>
   237f8:	f06f 0102 	mvn.w	r1, #2
   237fc:	4620      	mov	r0, r4
   237fe:	f7ff fcc1 	bl	23184 <atomic_and>
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   23802:	4631      	mov	r1, r6
	atomic_set_bit(cfg->flags, CF_OUT_OF_SYNC);
   23804:	4620      	mov	r0, r4
   23806:	f7ff fdb5 	bl	23374 <atomic_set_bit>
	return false;
   2380a:	e7df      	b.n	237cc <bt_gatt_change_aware+0xc>
	atomic_set_bit(cfg->flags, CF_OUT_OF_SYNC);
   2380c:	2101      	movs	r1, #1
   2380e:	e7f9      	b.n	23804 <bt_gatt_change_aware+0x44>

00023810 <sys_memcpy_swap>:
	psrc += length - 1;
   23810:	1e53      	subs	r3, r2, #1
   23812:	4419      	add	r1, r3
	for (; length > 0; length--) {
   23814:	4402      	add	r2, r0
		*pdst++ = *psrc--;
   23816:	f811 3901 	ldrb.w	r3, [r1], #-1
   2381a:	f800 3b01 	strb.w	r3, [r0], #1
	for (; length > 0; length--) {
   2381e:	4290      	cmp	r0, r2
   23820:	d1f9      	bne.n	23816 <sys_memcpy_swap+0x6>
}
   23822:	4770      	bx	lr

00023824 <sys_mem_swap>:
{
   23824:	b510      	push	{r4, lr}
   23826:	1843      	adds	r3, r0, r1
   23828:	eb00 0151 	add.w	r1, r0, r1, lsr #1
		((u8_t *)buf)[i] = ((u8_t *)buf)[length - 1 - i];
   2382c:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
		u8_t tmp = ((u8_t *)buf)[i];
   23830:	7802      	ldrb	r2, [r0, #0]
		((u8_t *)buf)[i] = ((u8_t *)buf)[length - 1 - i];
   23832:	f800 4b01 	strb.w	r4, [r0], #1
	for (i = 0; i < (length/2); i++) {
   23836:	4288      	cmp	r0, r1
		((u8_t *)buf)[length - 1 - i] = tmp;
   23838:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < (length/2); i++) {
   2383a:	d1f7      	bne.n	2382c <sys_mem_swap+0x8>
	}
}
   2383c:	bd10      	pop	{r4, pc}

0002383e <smp_pairing_rsp>:
}
   2383e:	2007      	movs	r0, #7
   23840:	4770      	bx	lr

00023842 <atomic_set_bit>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   23842:	2301      	movs	r3, #1
   23844:	fa03 f101 	lsl.w	r1, r3, r1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   23848:	f3bf 8f5b 	dmb	ish
   2384c:	e850 3f00 	ldrex	r3, [r0]
   23850:	430b      	orrs	r3, r1
   23852:	e840 3200 	strex	r2, r3, [r0]
   23856:	2a00      	cmp	r2, #0
   23858:	d1f8      	bne.n	2384c <atomic_set_bit+0xa>
   2385a:	f3bf 8f5b 	dmb	ish
}
   2385e:	4770      	bx	lr

00023860 <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   23860:	f3bf 8f5b 	dmb	ish
   23864:	6800      	ldr	r0, [r0, #0]
   23866:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   2386a:	4108      	asrs	r0, r1
}
   2386c:	f000 0001 	and.w	r0, r0, #1
   23870:	4770      	bx	lr

00023872 <bt_smp_aes_cmac>:
{
   23872:	b570      	push	{r4, r5, r6, lr}
   23874:	b0c2      	sub	sp, #264	; 0x108
   23876:	460d      	mov	r5, r1
   23878:	4616      	mov	r6, r2
	if (tc_cmac_setup(&state, key, &sched) == TC_CRYPTO_FAIL) {
   2387a:	4601      	mov	r1, r0
   2387c:	aa16      	add	r2, sp, #88	; 0x58
   2387e:	4668      	mov	r0, sp
{
   23880:	461c      	mov	r4, r3
	if (tc_cmac_setup(&state, key, &sched) == TC_CRYPTO_FAIL) {
   23882:	f7fd faec 	bl	20e5e <tc_cmac_setup>
   23886:	b150      	cbz	r0, 2389e <bt_smp_aes_cmac+0x2c>
	if (tc_cmac_update(&state, in, len) == TC_CRYPTO_FAIL) {
   23888:	4632      	mov	r2, r6
   2388a:	4629      	mov	r1, r5
   2388c:	4668      	mov	r0, sp
   2388e:	f7fd fb11 	bl	20eb4 <tc_cmac_update>
   23892:	b120      	cbz	r0, 2389e <bt_smp_aes_cmac+0x2c>
	if (tc_cmac_final(out, &state) == TC_CRYPTO_FAIL) {
   23894:	4669      	mov	r1, sp
   23896:	4620      	mov	r0, r4
   23898:	f7fd fb77 	bl	20f8a <tc_cmac_final>
   2389c:	b918      	cbnz	r0, 238a6 <bt_smp_aes_cmac+0x34>
		return -EIO;
   2389e:	f06f 0004 	mvn.w	r0, #4
}
   238a2:	b042      	add	sp, #264	; 0x108
   238a4:	bd70      	pop	{r4, r5, r6, pc}
	return 0;
   238a6:	2000      	movs	r0, #0
   238a8:	e7fb      	b.n	238a2 <bt_smp_aes_cmac+0x30>

000238aa <smp_f4>:
{
   238aa:	b570      	push	{r4, r5, r6, lr}
   238ac:	b096      	sub	sp, #88	; 0x58
   238ae:	4614      	mov	r4, r2
   238b0:	460e      	mov	r6, r1
	sys_memcpy_swap(m, u, 32);
   238b2:	2220      	movs	r2, #32
   238b4:	4601      	mov	r1, r0
   238b6:	a805      	add	r0, sp, #20
{
   238b8:	461d      	mov	r5, r3
	sys_memcpy_swap(m, u, 32);
   238ba:	f7ff ffa9 	bl	23810 <sys_memcpy_swap>
	sys_memcpy_swap(m + 32, v, 32);
   238be:	2220      	movs	r2, #32
   238c0:	4631      	mov	r1, r6
   238c2:	a80d      	add	r0, sp, #52	; 0x34
   238c4:	f7ff ffa4 	bl	23810 <sys_memcpy_swap>
	sys_memcpy_swap(xs, x, 16);
   238c8:	4621      	mov	r1, r4
   238ca:	2210      	movs	r2, #16
   238cc:	a801      	add	r0, sp, #4
	m[64] = z;
   238ce:	f88d 5054 	strb.w	r5, [sp, #84]	; 0x54
	sys_memcpy_swap(xs, x, 16);
   238d2:	f7ff ff9d 	bl	23810 <sys_memcpy_swap>
	err = bt_smp_aes_cmac(xs, m, sizeof(m), res);
   238d6:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   238d8:	2241      	movs	r2, #65	; 0x41
   238da:	a905      	add	r1, sp, #20
   238dc:	a801      	add	r0, sp, #4
   238de:	f7ff ffc8 	bl	23872 <bt_smp_aes_cmac>
	if (err) {
   238e2:	4604      	mov	r4, r0
   238e4:	b918      	cbnz	r0, 238ee <smp_f4+0x44>
	sys_mem_swap(res, 16);
   238e6:	2110      	movs	r1, #16
   238e8:	981a      	ldr	r0, [sp, #104]	; 0x68
   238ea:	f7ff ff9b 	bl	23824 <sys_mem_swap>
}
   238ee:	4620      	mov	r0, r4
   238f0:	b016      	add	sp, #88	; 0x58
   238f2:	bd70      	pop	{r4, r5, r6, pc}

000238f4 <atomic_clear_bit>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   238f4:	2301      	movs	r3, #1
   238f6:	fa03 f101 	lsl.w	r1, r3, r1
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   238fa:	43c9      	mvns	r1, r1
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   238fc:	f3bf 8f5b 	dmb	ish
   23900:	e850 3f00 	ldrex	r3, [r0]
   23904:	400b      	ands	r3, r1
   23906:	e840 3200 	strex	r2, r3, [r0]
   2390a:	2a00      	cmp	r2, #0
   2390c:	d1f8      	bne.n	23900 <atomic_clear_bit+0xc>
   2390e:	f3bf 8f5b 	dmb	ish
}
   23912:	4770      	bx	lr

00023914 <bt_addr_le_copy>:
   23914:	680b      	ldr	r3, [r1, #0]
   23916:	6003      	str	r3, [r0, #0]
   23918:	888b      	ldrh	r3, [r1, #4]
   2391a:	8083      	strh	r3, [r0, #4]
   2391c:	798b      	ldrb	r3, [r1, #6]
   2391e:	7183      	strb	r3, [r0, #6]
}
   23920:	4770      	bx	lr

00023922 <smp_f6>:
{
   23922:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   23926:	b096      	sub	sp, #88	; 0x58
   23928:	4606      	mov	r6, r0
   2392a:	4690      	mov	r8, r2
	sys_memcpy_swap(m, n1, 16);
   2392c:	a805      	add	r0, sp, #20
   2392e:	2210      	movs	r2, #16
{
   23930:	461f      	mov	r7, r3
   23932:	e9dd 541d 	ldrd	r5, r4, [sp, #116]	; 0x74
	sys_memcpy_swap(m, n1, 16);
   23936:	f7ff ff6b 	bl	23810 <sys_memcpy_swap>
	sys_memcpy_swap(m + 16, n2, 16);
   2393a:	2210      	movs	r2, #16
   2393c:	4641      	mov	r1, r8
   2393e:	a809      	add	r0, sp, #36	; 0x24
   23940:	f7ff ff66 	bl	23810 <sys_memcpy_swap>
	sys_memcpy_swap(m + 32, r, 16);
   23944:	2210      	movs	r2, #16
   23946:	4639      	mov	r1, r7
   23948:	a80d      	add	r0, sp, #52	; 0x34
   2394a:	f7ff ff61 	bl	23810 <sys_memcpy_swap>
	sys_memcpy_swap(m + 48, iocap, 3);
   2394e:	2203      	movs	r2, #3
   23950:	991c      	ldr	r1, [sp, #112]	; 0x70
   23952:	a811      	add	r0, sp, #68	; 0x44
   23954:	f7ff ff5c 	bl	23810 <sys_memcpy_swap>
	memcpy(m + 52, a1->a.val, 6);
   23958:	4629      	mov	r1, r5
	m[51] = a1->type;
   2395a:	782b      	ldrb	r3, [r5, #0]
	memcpy(m + 52, a1->a.val, 6);
   2395c:	f851 0f01 	ldr.w	r0, [r1, #1]!
	m[51] = a1->type;
   23960:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
	memcpy(m + 52, a1->a.val, 6);
   23964:	9012      	str	r0, [sp, #72]	; 0x48
   23966:	888b      	ldrh	r3, [r1, #4]
   23968:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
	sys_memcpy_swap(m + 52, a1->a.val, 6);
   2396c:	2206      	movs	r2, #6
   2396e:	a812      	add	r0, sp, #72	; 0x48
   23970:	f7ff ff4e 	bl	23810 <sys_memcpy_swap>
	memcpy(m + 59, a2->a.val, 6);
   23974:	4621      	mov	r1, r4
	m[58] = a2->type;
   23976:	7823      	ldrb	r3, [r4, #0]
   23978:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
	memcpy(m + 59, a2->a.val, 6);
   2397c:	f851 3f01 	ldr.w	r3, [r1, #1]!
   23980:	f8cd 304f 	str.w	r3, [sp, #79]	; 0x4f
	sys_memcpy_swap(m + 59, a2->a.val, 6);
   23984:	2206      	movs	r2, #6
	memcpy(m + 59, a2->a.val, 6);
   23986:	888b      	ldrh	r3, [r1, #4]
   23988:	f8ad 3053 	strh.w	r3, [sp, #83]	; 0x53
	sys_memcpy_swap(m + 59, a2->a.val, 6);
   2398c:	f10d 004f 	add.w	r0, sp, #79	; 0x4f
   23990:	f7ff ff3e 	bl	23810 <sys_memcpy_swap>
	sys_memcpy_swap(ws, w, 16);
   23994:	2210      	movs	r2, #16
   23996:	4631      	mov	r1, r6
   23998:	a801      	add	r0, sp, #4
   2399a:	f7ff ff39 	bl	23810 <sys_memcpy_swap>
	err = bt_smp_aes_cmac(ws, m, sizeof(m), check);
   2399e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   239a0:	2241      	movs	r2, #65	; 0x41
   239a2:	a905      	add	r1, sp, #20
   239a4:	a801      	add	r0, sp, #4
   239a6:	f7ff ff64 	bl	23872 <bt_smp_aes_cmac>
	if (err) {
   239aa:	4604      	mov	r4, r0
   239ac:	b918      	cbnz	r0, 239b6 <smp_f6+0x94>
	sys_mem_swap(check, 16);
   239ae:	2110      	movs	r1, #16
   239b0:	981f      	ldr	r0, [sp, #124]	; 0x7c
   239b2:	f7ff ff37 	bl	23824 <sys_mem_swap>
}
   239b6:	4620      	mov	r0, r4
   239b8:	b016      	add	sp, #88	; 0x58
   239ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000239be <smp_create_pdu.isra.5>:
static struct net_buf *smp_create_pdu(struct bt_smp *smp, u8_t op, size_t len)
   239be:	b570      	push	{r4, r5, r6, lr}
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
   239c0:	f100 059c 	add.w	r5, r0, #156	; 0x9c
static struct net_buf *smp_create_pdu(struct bt_smp *smp, u8_t op, size_t len)
   239c4:	460e      	mov	r6, r1
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
   239c6:	4628      	mov	r0, r5
   239c8:	2104      	movs	r1, #4
   239ca:	f7ff ff49 	bl	23860 <atomic_test_bit>
	buf = bt_l2cap_create_pdu_timeout(NULL, 0, timeout);
   239ce:	2100      	movs	r1, #0
		timeout = SMP_TIMEOUT;
   239d0:	2800      	cmp	r0, #0
	buf = bt_l2cap_create_pdu_timeout(NULL, 0, timeout);
   239d2:	f247 5230 	movw	r2, #30000	; 0x7530
   239d6:	4608      	mov	r0, r1
   239d8:	bf18      	it	ne
   239da:	2200      	movne	r2, #0
   239dc:	f7fe ff67 	bl	228ae <bt_l2cap_create_pdu_timeout>
	if (!buf) {
   239e0:	4604      	mov	r4, r0
   239e2:	b928      	cbnz	r0, 239f0 <smp_create_pdu.isra.5+0x32>
		atomic_set_bit(smp->flags, SMP_FLAG_TIMEOUT);
   239e4:	2104      	movs	r1, #4
   239e6:	4628      	mov	r0, r5
   239e8:	f7ff ff2b 	bl	23842 <atomic_set_bit>
}
   239ec:	4620      	mov	r0, r4
   239ee:	bd70      	pop	{r4, r5, r6, pc}
	hdr = net_buf_add(buf, sizeof(*hdr));
   239f0:	2101      	movs	r1, #1
   239f2:	3008      	adds	r0, #8
   239f4:	f001 f9f0 	bl	24dd8 <net_buf_simple_add>
	hdr->code = op;
   239f8:	7006      	strb	r6, [r0, #0]
	return buf;
   239fa:	e7f7      	b.n	239ec <smp_create_pdu.isra.5+0x2e>

000239fc <bt_smp_disconnected>:
{
   239fc:	b538      	push	{r3, r4, r5, lr}
	struct bt_keys *keys = chan->conn->le.keys;
   239fe:	6803      	ldr	r3, [r0, #0]
   23a00:	f8d3 40a0 	ldr.w	r4, [r3, #160]	; 0xa0
{
   23a04:	4605      	mov	r5, r0
	k_delayed_work_cancel(&smp->work);
   23a06:	f500 70c2 	add.w	r0, r0, #388	; 0x184
   23a0a:	f004 fa84 	bl	27f16 <k_delayed_work_cancel>
	if (keys) {
   23a0e:	b13c      	cbz	r4, 23a20 <bt_smp_disconnected+0x24>
		if (!keys->keys || (!IS_ENABLED(CONFIG_BT_STORE_DEBUG_KEYS) &&
   23a10:	8963      	ldrh	r3, [r4, #10]
   23a12:	b113      	cbz	r3, 23a1a <bt_smp_disconnected+0x1e>
   23a14:	7a63      	ldrb	r3, [r4, #9]
   23a16:	079b      	lsls	r3, r3, #30
   23a18:	d502      	bpl.n	23a20 <bt_smp_disconnected+0x24>
			bt_keys_clear(keys);
   23a1a:	4620      	mov	r0, r4
   23a1c:	f7ec fc7a 	bl	10314 <bt_keys_clear>
__ssp_bos_icheck3(memset, void *, int)
   23a20:	4628      	mov	r0, r5
   23a22:	f44f 72d2 	mov.w	r2, #420	; 0x1a4
   23a26:	2100      	movs	r1, #0
}
   23a28:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   23a2c:	f7de b8ff 	b.w	1c2e <memset>

00023a30 <smp_dhkey_check>:
{
   23a30:	b570      	push	{r4, r5, r6, lr}
	if (smp->chan.chan.conn->role == BT_HCI_ROLE_SLAVE) {
   23a32:	6803      	ldr	r3, [r0, #0]
   23a34:	78db      	ldrb	r3, [r3, #3]
   23a36:	2b01      	cmp	r3, #1
{
   23a38:	4606      	mov	r6, r0
	if (smp->chan.chan.conn->role == BT_HCI_ROLE_SLAVE) {
   23a3a:	d11a      	bne.n	23a72 <smp_dhkey_check+0x42>
	struct bt_smp_dhkey_check *req = (void *)buf->data;
   23a3c:	688c      	ldr	r4, [r1, #8]
		atomic_clear_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT);
   23a3e:	f100 059c 	add.w	r5, r0, #156	; 0x9c
   23a42:	210f      	movs	r1, #15
   23a44:	4628      	mov	r0, r5
   23a46:	f7ff ff55 	bl	238f4 <atomic_clear_bit>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   23a4a:	4623      	mov	r3, r4
   23a4c:	f206 124f 	addw	r2, r6, #335	; 0x14f
   23a50:	f104 0110 	add.w	r1, r4, #16
   23a54:	f853 0b04 	ldr.w	r0, [r3], #4
   23a58:	f842 0b04 	str.w	r0, [r2], #4
   23a5c:	428b      	cmp	r3, r1
   23a5e:	d1f9      	bne.n	23a54 <smp_dhkey_check+0x24>
		if (atomic_test_bit(smp->flags, SMP_FLAG_DHKEY_PENDING)) {
   23a60:	2107      	movs	r1, #7
   23a62:	4628      	mov	r0, r5
   23a64:	f7ff fefc 	bl	23860 <atomic_test_bit>
   23a68:	b128      	cbz	r0, 23a76 <smp_dhkey_check+0x46>
			atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_SEND);
   23a6a:	2108      	movs	r1, #8
   23a6c:	4628      	mov	r0, r5
   23a6e:	f7ff fee8 	bl	23842 <atomic_set_bit>
}
   23a72:	2000      	movs	r0, #0
   23a74:	bd70      	pop	{r4, r5, r6, pc}
		if (atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
   23a76:	2109      	movs	r1, #9
   23a78:	4628      	mov	r0, r5
   23a7a:	f7ff fef1 	bl	23860 <atomic_test_bit>
   23a7e:	2800      	cmp	r0, #0
   23a80:	d1f3      	bne.n	23a6a <smp_dhkey_check+0x3a>
		return compute_and_check_and_send_slave_dhcheck(smp);
   23a82:	4630      	mov	r0, r6
}
   23a84:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return compute_and_check_and_send_slave_dhcheck(smp);
   23a88:	f7eb b802 	b.w	ea90 <compute_and_check_and_send_slave_dhcheck>

00023a8c <smp_send_pairing_random>:
{
   23a8c:	b538      	push	{r3, r4, r5, lr}
	rsp_buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_RANDOM, sizeof(*req));
   23a8e:	2104      	movs	r1, #4
{
   23a90:	4604      	mov	r4, r0
	rsp_buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_RANDOM, sizeof(*req));
   23a92:	f7ff ff94 	bl	239be <smp_create_pdu.isra.5>
	if (!rsp_buf) {
   23a96:	4605      	mov	r5, r0
   23a98:	b1a0      	cbz	r0, 23ac4 <smp_send_pairing_random+0x38>
	req = net_buf_add(rsp_buf, sizeof(*req));
   23a9a:	2110      	movs	r1, #16
   23a9c:	3008      	adds	r0, #8
   23a9e:	f001 f99b 	bl	24dd8 <net_buf_simple_add>
   23aa2:	f104 03bf 	add.w	r3, r4, #191	; 0xbf
   23aa6:	f104 02cf 	add.w	r2, r4, #207	; 0xcf
   23aaa:	f853 1b04 	ldr.w	r1, [r3], #4
   23aae:	f840 1b04 	str.w	r1, [r0], #4
   23ab2:	4293      	cmp	r3, r2
   23ab4:	d1f9      	bne.n	23aaa <smp_send_pairing_random+0x1e>
	smp_send(smp, rsp_buf, NULL, NULL);
   23ab6:	4620      	mov	r0, r4
   23ab8:	2200      	movs	r2, #0
   23aba:	4629      	mov	r1, r5
   23abc:	f7ea ff2e 	bl	e91c <smp_send.isra.7>
	return 0;
   23ac0:	2000      	movs	r0, #0
}
   23ac2:	bd38      	pop	{r3, r4, r5, pc}
		return BT_SMP_ERR_UNSPECIFIED;
   23ac4:	2008      	movs	r0, #8
   23ac6:	e7fc      	b.n	23ac2 <smp_send_pairing_random+0x36>

00023ac8 <send_pairing_rsp>:
{
   23ac8:	b538      	push	{r3, r4, r5, lr}
	rsp_buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_RSP, sizeof(*rsp));
   23aca:	2102      	movs	r1, #2
{
   23acc:	4605      	mov	r5, r0
	rsp_buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_RSP, sizeof(*rsp));
   23ace:	f7ff ff76 	bl	239be <smp_create_pdu.isra.5>
	if (!rsp_buf) {
   23ad2:	4604      	mov	r4, r0
   23ad4:	b180      	cbz	r0, 23af8 <send_pairing_rsp+0x30>
	rsp = net_buf_add(rsp_buf, sizeof(*rsp));
   23ad6:	2106      	movs	r1, #6
   23ad8:	3008      	adds	r0, #8
   23ada:	f001 f97d 	bl	24dd8 <net_buf_simple_add>
   23ade:	462b      	mov	r3, r5
	smp_send(smp, rsp_buf, NULL, NULL);
   23ae0:	4621      	mov	r1, r4
   23ae2:	f853 2fa9 	ldr.w	r2, [r3, #169]!
   23ae6:	6002      	str	r2, [r0, #0]
   23ae8:	889b      	ldrh	r3, [r3, #4]
   23aea:	8083      	strh	r3, [r0, #4]
   23aec:	2200      	movs	r2, #0
   23aee:	4628      	mov	r0, r5
   23af0:	f7ea ff14 	bl	e91c <smp_send.isra.7>
	return 0;
   23af4:	2000      	movs	r0, #0
}
   23af6:	bd38      	pop	{r3, r4, r5, pc}
		return BT_SMP_ERR_UNSPECIFIED;
   23af8:	2008      	movs	r0, #8
   23afa:	e7fc      	b.n	23af6 <send_pairing_rsp+0x2e>

00023afc <smp_security_request>:
   23afc:	2007      	movs	r0, #7
   23afe:	4770      	bx	lr

00023b00 <atomic_test_and_clear_bit>:
{
   23b00:	b510      	push	{r4, lr}
	atomic_val_t mask = ATOMIC_MASK(bit);
   23b02:	f001 021f 	and.w	r2, r1, #31
   23b06:	2301      	movs	r3, #1
   23b08:	4093      	lsls	r3, r2
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   23b0a:	0949      	lsrs	r1, r1, #5
   23b0c:	43dc      	mvns	r4, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   23b0e:	eb00 0081 	add.w	r0, r0, r1, lsl #2
   23b12:	f3bf 8f5b 	dmb	ish
   23b16:	e850 2f00 	ldrex	r2, [r0]
   23b1a:	ea02 0104 	and.w	r1, r2, r4
   23b1e:	e840 1c00 	strex	ip, r1, [r0]
   23b22:	f1bc 0f00 	cmp.w	ip, #0
   23b26:	d1f6      	bne.n	23b16 <atomic_test_and_clear_bit+0x16>
   23b28:	f3bf 8f5b 	dmb	ish
	return (old & mask) != 0;
   23b2c:	421a      	tst	r2, r3
}
   23b2e:	bf14      	ite	ne
   23b30:	2001      	movne	r0, #1
   23b32:	2000      	moveq	r0, #0
   23b34:	bd10      	pop	{r4, pc}

00023b36 <smp_reset>:
{
   23b36:	b538      	push	{r3, r4, r5, lr}
   23b38:	4604      	mov	r4, r0
	struct bt_conn *conn = smp->chan.chan.conn;
   23b3a:	6805      	ldr	r5, [r0, #0]
	k_delayed_work_cancel(&smp->work);
   23b3c:	f500 70c2 	add.w	r0, r0, #388	; 0x184
   23b40:	f004 f9e9 	bl	27f16 <k_delayed_work_cancel>
	smp->method = JUST_WORKS;
   23b44:	2300      	movs	r3, #0
   23b46:	f884 30a0 	strb.w	r3, [r4, #160]	; 0xa0
	atomic_set(&smp->allowed_cmds, 0);
   23b4a:	f104 0098 	add.w	r0, r4, #152	; 0x98
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   23b4e:	f3bf 8f5b 	dmb	ish
   23b52:	e850 2f00 	ldrex	r2, [r0]
   23b56:	e840 3100 	strex	r1, r3, [r0]
   23b5a:	2900      	cmp	r1, #0
   23b5c:	d1f9      	bne.n	23b52 <smp_reset+0x1c>
   23b5e:	f3bf 8f5b 	dmb	ish
   23b62:	f3bf 8f5b 	dmb	ish
   23b66:	349c      	adds	r4, #156	; 0x9c
   23b68:	e854 2f00 	ldrex	r2, [r4]
   23b6c:	e844 3100 	strex	r1, r3, [r4]
   23b70:	2900      	cmp	r1, #0
   23b72:	d1f9      	bne.n	23b68 <smp_reset+0x32>
   23b74:	f3bf 8f5b 	dmb	ish
	if (conn->required_sec_level != conn->sec_level) {
   23b78:	7a6b      	ldrb	r3, [r5, #9]
   23b7a:	7aaa      	ldrb	r2, [r5, #10]
   23b7c:	429a      	cmp	r2, r3
		conn->required_sec_level = conn->sec_level;
   23b7e:	bf18      	it	ne
   23b80:	72ab      	strbne	r3, [r5, #10]
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_REQ);
   23b82:	2101      	movs	r1, #1
}
   23b84:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_REQ);
   23b88:	f7ff be5b 	b.w	23842 <atomic_set_bit>

00023b8c <smp_error>:
{
   23b8c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   23b8e:	4606      	mov	r6, r0
   23b90:	460c      	mov	r4, r1
	smp_pairing_complete(smp, reason);
   23b92:	f7eb fad7 	bl	f144 <smp_pairing_complete>
	buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_FAIL, sizeof(*rsp));
   23b96:	2105      	movs	r1, #5
   23b98:	4630      	mov	r0, r6
   23b9a:	f7ff ff10 	bl	239be <smp_create_pdu.isra.5>
	if (!buf) {
   23b9e:	4605      	mov	r5, r0
   23ba0:	b178      	cbz	r0, 23bc2 <smp_error+0x36>
	rsp = net_buf_add(buf, sizeof(*rsp));
   23ba2:	2101      	movs	r1, #1
   23ba4:	3008      	adds	r0, #8
   23ba6:	f001 f917 	bl	24dd8 <net_buf_simple_add>
	rsp->reason = reason;
   23baa:	7004      	strb	r4, [r0, #0]
   23bac:	2400      	movs	r4, #0
   23bae:	9400      	str	r4, [sp, #0]
   23bb0:	4623      	mov	r3, r4
   23bb2:	462a      	mov	r2, r5
   23bb4:	2106      	movs	r1, #6
   23bb6:	6830      	ldr	r0, [r6, #0]
   23bb8:	f7fe fe7c 	bl	228b4 <bt_l2cap_send_cb>
	return 0;
   23bbc:	4620      	mov	r0, r4
}
   23bbe:	b002      	add	sp, #8
   23bc0:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOBUFS;
   23bc2:	f06f 0068 	mvn.w	r0, #104	; 0x68
   23bc6:	e7fa      	b.n	23bbe <smp_error+0x32>

00023bc8 <smp_check_complete.part.15>:
static void smp_check_complete(struct bt_conn *conn, u8_t dist_complete)
   23bc8:	b510      	push	{r4, lr}
   23bca:	460c      	mov	r4, r1
		chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_SMP);
   23bcc:	2106      	movs	r1, #6
   23bce:	f7fe fe8a 	bl	228e6 <bt_l2cap_le_lookup_tx_cid>
		smp->local_dist &= ~dist_complete;
   23bd2:	f890 1180 	ldrb.w	r1, [r0, #384]	; 0x180
   23bd6:	ea21 0104 	bic.w	r1, r1, r4
   23bda:	f880 1180 	strb.w	r1, [r0, #384]	; 0x180
		if (!smp->local_dist && !smp->remote_dist) {
   23bde:	f8b0 1180 	ldrh.w	r1, [r0, #384]	; 0x180
   23be2:	b919      	cbnz	r1, 23bec <smp_check_complete.part.15+0x24>
}
   23be4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			smp_pairing_complete(smp, 0);
   23be8:	f7eb baac 	b.w	f144 <smp_pairing_complete>
}
   23bec:	bd10      	pop	{r4, pc}

00023bee <smp_sign_info_sent>:
	if (conn->type == BT_CONN_TYPE_LE) {
   23bee:	7883      	ldrb	r3, [r0, #2]
   23bf0:	2b01      	cmp	r3, #1
   23bf2:	d102      	bne.n	23bfa <smp_sign_info_sent+0xc>
   23bf4:	2104      	movs	r1, #4
   23bf6:	f7ff bfe7 	b.w	23bc8 <smp_check_complete.part.15>
}
   23bfa:	4770      	bx	lr

00023bfc <smp_ident_sent>:
	if (conn->type == BT_CONN_TYPE_LE) {
   23bfc:	7881      	ldrb	r1, [r0, #2]
   23bfe:	2901      	cmp	r1, #1
   23c00:	d101      	bne.n	23c06 <smp_ident_sent+0xa>
   23c02:	f7ff bfe1 	b.w	23bc8 <smp_check_complete.part.15>
}
   23c06:	4770      	bx	lr

00023c08 <smp_id_sent>:
	if (conn->type == BT_CONN_TYPE_LE) {
   23c08:	7883      	ldrb	r3, [r0, #2]
   23c0a:	2b01      	cmp	r3, #1
   23c0c:	d102      	bne.n	23c14 <smp_id_sent+0xc>
   23c0e:	2102      	movs	r1, #2
   23c10:	f7ff bfda 	b.w	23bc8 <smp_check_complete.part.15>
}
   23c14:	4770      	bx	lr

00023c16 <smp_c1>:
{
   23c16:	b5f0      	push	{r4, r5, r6, r7, lr}
   23c18:	b089      	sub	sp, #36	; 0x24
   23c1a:	e9dd 560e 	ldrd	r5, r6, [sp, #56]	; 0x38
   23c1e:	4607      	mov	r7, r0
	p1[0] = ia->type;
   23c20:	7828      	ldrb	r0, [r5, #0]
   23c22:	f88d 0000 	strb.w	r0, [sp]
	p1[1] = ra->type;
   23c26:	7830      	ldrb	r0, [r6, #0]
   23c28:	f88d 0001 	strb.w	r0, [sp, #1]
	memcpy(p1 + 2, preq, 7);
   23c2c:	6810      	ldr	r0, [r2, #0]
   23c2e:	f8cd 0002 	str.w	r0, [sp, #2]
   23c32:	8890      	ldrh	r0, [r2, #4]
   23c34:	7992      	ldrb	r2, [r2, #6]
{
   23c36:	9c10      	ldr	r4, [sp, #64]	; 0x40
	memcpy(p1 + 2, preq, 7);
   23c38:	f88d 2008 	strb.w	r2, [sp, #8]
	memcpy(p1 + 9, pres, 7);
   23c3c:	681a      	ldr	r2, [r3, #0]
   23c3e:	f8cd 2009 	str.w	r2, [sp, #9]
   23c42:	889a      	ldrh	r2, [r3, #4]
   23c44:	799b      	ldrb	r3, [r3, #6]
	memcpy(p1 + 2, preq, 7);
   23c46:	f8ad 0006 	strh.w	r0, [sp, #6]
	memcpy(p1 + 9, pres, 7);
   23c4a:	f8ad 200d 	strh.w	r2, [sp, #13]
   23c4e:	f88d 300f 	strb.w	r3, [sp, #15]
	while (len--) {
   23c52:	f101 0c10 	add.w	ip, r1, #16
	memcpy(p1 + 9, pres, 7);
   23c56:	4620      	mov	r0, r4
   23c58:	466a      	mov	r2, sp
	while (len--) {
   23c5a:	458c      	cmp	ip, r1
   23c5c:	d124      	bne.n	23ca8 <smp_c1+0x92>
	err = bt_encrypt_le(k, enc_data, enc_data);
   23c5e:	4622      	mov	r2, r4
   23c60:	4621      	mov	r1, r4
   23c62:	4638      	mov	r0, r7
   23c64:	f000 fbc9 	bl	243fa <bt_encrypt_le>
	if (err) {
   23c68:	4602      	mov	r2, r0
   23c6a:	bb70      	cbnz	r0, 23cca <smp_c1+0xb4>
	memcpy(p2, ra->a.val, 6);
   23c6c:	4633      	mov	r3, r6
	(void)memset(p2 + 12, 0, 4);
   23c6e:	9207      	str	r2, [sp, #28]
	memcpy(p2, ra->a.val, 6);
   23c70:	f853 0f01 	ldr.w	r0, [r3, #1]!
   23c74:	9004      	str	r0, [sp, #16]
   23c76:	889b      	ldrh	r3, [r3, #4]
   23c78:	f8ad 3014 	strh.w	r3, [sp, #20]
	memcpy(p2 + 6, ia->a.val, 6);
   23c7c:	462b      	mov	r3, r5
   23c7e:	f104 0010 	add.w	r0, r4, #16
   23c82:	f853 1f01 	ldr.w	r1, [r3, #1]!
   23c86:	f8cd 1016 	str.w	r1, [sp, #22]
   23c8a:	889b      	ldrh	r3, [r3, #4]
   23c8c:	f8ad 301a 	strh.w	r3, [sp, #26]
	(void)memset(p2 + 12, 0, 4);
   23c90:	4622      	mov	r2, r4
   23c92:	ab04      	add	r3, sp, #16
	while (len--) {
   23c94:	4282      	cmp	r2, r0
   23c96:	d110      	bne.n	23cba <smp_c1+0xa4>
	return bt_encrypt_le(k, enc_data, enc_data);
   23c98:	4622      	mov	r2, r4
   23c9a:	4621      	mov	r1, r4
   23c9c:	4638      	mov	r0, r7
}
   23c9e:	b009      	add	sp, #36	; 0x24
   23ca0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	return bt_encrypt_le(k, enc_data, enc_data);
   23ca4:	f000 bba9 	b.w	243fa <bt_encrypt_le>
		*r++ = *p++ ^ *q++;
   23ca8:	f811 3b01 	ldrb.w	r3, [r1], #1
   23cac:	f812 eb01 	ldrb.w	lr, [r2], #1
   23cb0:	ea83 030e 	eor.w	r3, r3, lr
   23cb4:	f800 3b01 	strb.w	r3, [r0], #1
   23cb8:	e7cf      	b.n	23c5a <smp_c1+0x44>
   23cba:	f812 1b01 	ldrb.w	r1, [r2], #1
   23cbe:	f813 5b01 	ldrb.w	r5, [r3], #1
   23cc2:	4069      	eors	r1, r5
   23cc4:	f802 1c01 	strb.w	r1, [r2, #-1]
   23cc8:	e7e4      	b.n	23c94 <smp_c1+0x7e>
}
   23cca:	b009      	add	sp, #36	; 0x24
   23ccc:	bdf0      	pop	{r4, r5, r6, r7, pc}

00023cce <legacy_pairing_confirm>:
{
   23cce:	b5f0      	push	{r4, r5, r6, r7, lr}
		if (!atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
   23cd0:	f100 079c 	add.w	r7, r0, #156	; 0x9c
{
   23cd4:	b085      	sub	sp, #20
   23cd6:	4605      	mov	r5, r0
		if (!atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
   23cd8:	2109      	movs	r1, #9
   23cda:	4638      	mov	r0, r7
   23cdc:	f7ff fdc0 	bl	23860 <atomic_test_bit>
   23ce0:	bb90      	cbnz	r0, 23d48 <legacy_pairing_confirm+0x7a>
			atomic_set_bit(&smp->allowed_cmds,
   23ce2:	2104      	movs	r1, #4
   23ce4:	f105 0098 	add.w	r0, r5, #152	; 0x98
   23ce8:	f7ff fdab 	bl	23842 <atomic_set_bit>
	buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_CONFIRM, sizeof(*req));
   23cec:	2103      	movs	r1, #3
   23cee:	4628      	mov	r0, r5
	struct bt_conn *conn = smp->chan.chan.conn;
   23cf0:	682c      	ldr	r4, [r5, #0]
	buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_CONFIRM, sizeof(*req));
   23cf2:	f7ff fe64 	bl	239be <smp_create_pdu.isra.5>
	if (!buf) {
   23cf6:	4606      	mov	r6, r0
   23cf8:	b1c0      	cbz	r0, 23d2c <legacy_pairing_confirm+0x5e>
	req = net_buf_add(buf, sizeof(*req));
   23cfa:	2110      	movs	r1, #16
   23cfc:	3008      	adds	r0, #8
   23cfe:	f001 f86b 	bl	24dd8 <net_buf_simple_add>
		   &conn->le.init_addr, &conn->le.resp_addr, req->val)) {
   23d02:	f104 0382 	add.w	r3, r4, #130	; 0x82
   23d06:	347b      	adds	r4, #123	; 0x7b
	if (smp_c1(smp->tk, smp->prnd, smp->preq, smp->prsp,
   23d08:	9002      	str	r0, [sp, #8]
   23d0a:	9301      	str	r3, [sp, #4]
   23d0c:	9400      	str	r4, [sp, #0]
   23d0e:	f105 03a8 	add.w	r3, r5, #168	; 0xa8
   23d12:	f105 02a1 	add.w	r2, r5, #161	; 0xa1
   23d16:	f105 01bf 	add.w	r1, r5, #191	; 0xbf
   23d1a:	f105 00df 	add.w	r0, r5, #223	; 0xdf
   23d1e:	f7ff ff7a 	bl	23c16 <smp_c1>
   23d22:	4604      	mov	r4, r0
   23d24:	b120      	cbz	r0, 23d30 <legacy_pairing_confirm+0x62>
		net_buf_unref(buf);
   23d26:	4630      	mov	r0, r6
   23d28:	f7f5 f998 	bl	1905c <net_buf_unref>
		return BT_SMP_ERR_UNSPECIFIED;
   23d2c:	2008      	movs	r0, #8
   23d2e:	e009      	b.n	23d44 <legacy_pairing_confirm+0x76>
	smp_send(smp, buf, NULL, NULL);
   23d30:	4602      	mov	r2, r0
   23d32:	4631      	mov	r1, r6
   23d34:	4628      	mov	r0, r5
   23d36:	f7ea fdf1 	bl	e91c <smp_send.isra.7>
	atomic_clear_bit(smp->flags, SMP_FLAG_CFM_DELAYED);
   23d3a:	4621      	mov	r1, r4
   23d3c:	4638      	mov	r0, r7
   23d3e:	f7ff fdd9 	bl	238f4 <atomic_clear_bit>
	return 0;
   23d42:	2000      	movs	r0, #0
}
   23d44:	b005      	add	sp, #20
   23d46:	bdf0      	pop	{r4, r5, r6, r7, pc}
		atomic_set_bit(smp->flags, SMP_FLAG_CFM_DELAYED);
   23d48:	2100      	movs	r1, #0
   23d4a:	4638      	mov	r0, r7
   23d4c:	f7ff fd79 	bl	23842 <atomic_set_bit>
   23d50:	e7f7      	b.n	23d42 <legacy_pairing_confirm+0x74>

00023d52 <smp_pairing_confirm>:
{
   23d52:	b570      	push	{r4, r5, r6, lr}
	struct bt_smp_pairing_confirm *req = (void *)buf->data;
   23d54:	688d      	ldr	r5, [r1, #8]
	atomic_clear_bit(smp->flags, SMP_FLAG_DISPLAY);
   23d56:	f100 069c 	add.w	r6, r0, #156	; 0x9c
{
   23d5a:	4604      	mov	r4, r0
	atomic_clear_bit(smp->flags, SMP_FLAG_DISPLAY);
   23d5c:	210a      	movs	r1, #10
   23d5e:	4630      	mov	r0, r6
   23d60:	f7ff fdc8 	bl	238f4 <atomic_clear_bit>
   23d64:	462b      	mov	r3, r5
   23d66:	f104 02af 	add.w	r2, r4, #175	; 0xaf
   23d6a:	f105 0110 	add.w	r1, r5, #16
   23d6e:	f853 0b04 	ldr.w	r0, [r3], #4
   23d72:	f842 0b04 	str.w	r0, [r2], #4
   23d76:	428b      	cmp	r3, r1
   23d78:	d1f9      	bne.n	23d6e <smp_pairing_confirm+0x1c>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
   23d7a:	2105      	movs	r1, #5
   23d7c:	4630      	mov	r0, r6
   23d7e:	f7ff fd6f 	bl	23860 <atomic_test_bit>
   23d82:	b920      	cbnz	r0, 23d8e <smp_pairing_confirm+0x3c>
		return legacy_pairing_confirm(smp);
   23d84:	4620      	mov	r0, r4
}
   23d86:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return legacy_pairing_confirm(smp);
   23d8a:	f7ff bfa0 	b.w	23cce <legacy_pairing_confirm>
	switch (smp->method) {
   23d8e:	f894 30a0 	ldrb.w	r3, [r4, #160]	; 0xa0
   23d92:	2b01      	cmp	r3, #1
   23d94:	d00b      	beq.n	23dae <smp_pairing_confirm+0x5c>
   23d96:	2b02      	cmp	r3, #2
   23d98:	d115      	bne.n	23dc6 <smp_pairing_confirm+0x74>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
   23d9a:	f104 0098 	add.w	r0, r4, #152	; 0x98
   23d9e:	2104      	movs	r1, #4
   23da0:	f7ff fd4f 	bl	23842 <atomic_set_bit>
		return smp_send_pairing_confirm(smp);
   23da4:	4620      	mov	r0, r4
}
   23da6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return smp_send_pairing_confirm(smp);
   23daa:	f7ea bdcd 	b.w	e948 <smp_send_pairing_confirm>
		if (atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
   23dae:	2109      	movs	r1, #9
   23db0:	4630      	mov	r0, r6
   23db2:	f7ff fd55 	bl	23860 <atomic_test_bit>
   23db6:	2800      	cmp	r0, #0
   23db8:	d0ef      	beq.n	23d9a <smp_pairing_confirm+0x48>
			atomic_set_bit(smp->flags, SMP_FLAG_CFM_DELAYED);
   23dba:	4630      	mov	r0, r6
   23dbc:	2100      	movs	r1, #0
   23dbe:	f7ff fd40 	bl	23842 <atomic_set_bit>
			return 0;
   23dc2:	2000      	movs	r0, #0
}
   23dc4:	bd70      	pop	{r4, r5, r6, pc}
		return BT_SMP_ERR_UNSPECIFIED;
   23dc6:	2008      	movs	r0, #8
   23dc8:	e7fc      	b.n	23dc4 <smp_pairing_confirm+0x72>

00023dca <bt_smp_request_ltk>:
{
   23dca:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   23dce:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
   23dd0:	4605      	mov	r5, r0
   23dd2:	e9cd 2300 	strd	r2, r3, [sp]
	smp = smp_chan_get(conn);
   23dd6:	f7ea fd41 	bl	e85c <smp_chan_get>
	if (!smp) {
   23dda:	4604      	mov	r4, r0
   23ddc:	2800      	cmp	r0, #0
   23dde:	f000 809c 	beq.w	23f1a <bt_smp_request_ltk+0x150>
	if (ediv == 0U && rand == 0U &&
   23de2:	f8bd 9028 	ldrh.w	r9, [sp, #40]	; 0x28
   23de6:	f1b9 0f00 	cmp.w	r9, #0
   23dea:	d12d      	bne.n	23e48 <bt_smp_request_ltk+0x7e>
   23dec:	e9dd 2300 	ldrd	r2, r3, [sp]
   23df0:	4313      	orrs	r3, r2
   23df2:	d129      	bne.n	23e48 <bt_smp_request_ltk+0x7e>
	    atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) &&
   23df4:	f100 089c 	add.w	r8, r0, #156	; 0x9c
   23df8:	2103      	movs	r1, #3
   23dfa:	4640      	mov	r0, r8
   23dfc:	f7ff fd30 	bl	23860 <atomic_test_bit>
	if (ediv == 0U && rand == 0U &&
   23e00:	b310      	cbz	r0, 23e48 <bt_smp_request_ltk+0x7e>
	    atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
   23e02:	2101      	movs	r1, #1
   23e04:	4640      	mov	r0, r8
   23e06:	f7ff fd2b 	bl	23860 <atomic_test_bit>
	    atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) &&
   23e0a:	4606      	mov	r6, r0
   23e0c:	b1e0      	cbz	r0, 23e48 <bt_smp_request_ltk+0x7e>
	return MIN(req->max_key_size, rsp->max_key_size);
   23e0e:	f894 50ac 	ldrb.w	r5, [r4, #172]	; 0xac
   23e12:	f894 30a5 	ldrb.w	r3, [r4, #165]	; 0xa5
   23e16:	429d      	cmp	r5, r3
   23e18:	bf28      	it	cs
   23e1a:	461d      	movcs	r5, r3
   23e1c:	462a      	mov	r2, r5
   23e1e:	f104 01df 	add.w	r1, r4, #223	; 0xdf
   23e22:	4638      	mov	r0, r7
   23e24:	f7dd fee2 	bl	1bec <memcpy>
		if (enc_size < BT_SMP_MAX_ENC_KEY_SIZE) {
   23e28:	2d0f      	cmp	r5, #15
   23e2a:	d805      	bhi.n	23e38 <bt_smp_request_ltk+0x6e>
__ssp_bos_icheck3(memset, void *, int)
   23e2c:	f1c5 0210 	rsb	r2, r5, #16
   23e30:	4649      	mov	r1, r9
   23e32:	1978      	adds	r0, r7, r5
   23e34:	f7dd fefb 	bl	1c2e <memset>
		atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
   23e38:	2101      	movs	r1, #1
   23e3a:	4640      	mov	r0, r8
   23e3c:	f7ff fd01 	bl	23842 <atomic_set_bit>
}
   23e40:	4630      	mov	r0, r6
   23e42:	b003      	add	sp, #12
   23e44:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (!conn->le.keys) {
   23e48:	f8d5 30a0 	ldr.w	r3, [r5, #160]	; 0xa0
   23e4c:	b983      	cbnz	r3, 23e70 <bt_smp_request_ltk+0xa6>
					     &conn->le.dst);
   23e4e:	f105 0674 	add.w	r6, r5, #116	; 0x74
		conn->le.keys = bt_keys_find(BT_KEYS_LTK_P256, conn->id,
   23e52:	4632      	mov	r2, r6
   23e54:	7a29      	ldrb	r1, [r5, #8]
   23e56:	2020      	movs	r0, #32
   23e58:	f7ec f9fa 	bl	10250 <bt_keys_find>
   23e5c:	f8c5 00a0 	str.w	r0, [r5, #160]	; 0xa0
		if (!conn->le.keys) {
   23e60:	b930      	cbnz	r0, 23e70 <bt_smp_request_ltk+0xa6>
			conn->le.keys = bt_keys_find(BT_KEYS_SLAVE_LTK,
   23e62:	4632      	mov	r2, r6
   23e64:	7a29      	ldrb	r1, [r5, #8]
   23e66:	2001      	movs	r0, #1
   23e68:	f7ec f9f2 	bl	10250 <bt_keys_find>
   23e6c:	f8c5 00a0 	str.w	r0, [r5, #160]	; 0xa0
	if (ediv == 0U && rand == 0U &&
   23e70:	f8bd 6028 	ldrh.w	r6, [sp, #40]	; 0x28
   23e74:	f8d5 00a0 	ldr.w	r0, [r5, #160]	; 0xa0
   23e78:	b9ce      	cbnz	r6, 23eae <bt_smp_request_ltk+0xe4>
   23e7a:	e9dd 2300 	ldrd	r2, r3, [sp]
   23e7e:	4313      	orrs	r3, r2
   23e80:	d115      	bne.n	23eae <bt_smp_request_ltk+0xe4>
   23e82:	2800      	cmp	r0, #0
   23e84:	d03c      	beq.n	23f00 <bt_smp_request_ltk+0x136>
	    conn->le.keys && (conn->le.keys->keys & BT_KEYS_LTK_P256)) {
   23e86:	8943      	ldrh	r3, [r0, #10]
   23e88:	069a      	lsls	r2, r3, #26
   23e8a:	d511      	bpl.n	23eb0 <bt_smp_request_ltk+0xe6>
		enc_size = conn->le.keys->enc_size;
   23e8c:	7a04      	ldrb	r4, [r0, #8]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   23e8e:	f100 0116 	add.w	r1, r0, #22
   23e92:	4622      	mov	r2, r4
   23e94:	4638      	mov	r0, r7
   23e96:	f7dd fea9 	bl	1bec <memcpy>
		if (enc_size < BT_SMP_MAX_ENC_KEY_SIZE) {
   23e9a:	2c0f      	cmp	r4, #15
   23e9c:	d805      	bhi.n	23eaa <bt_smp_request_ltk+0xe0>
__ssp_bos_icheck3(memset, void *, int)
   23e9e:	f1c4 0210 	rsb	r2, r4, #16
   23ea2:	4631      	mov	r1, r6
   23ea4:	1938      	adds	r0, r7, r4
   23ea6:	f7dd fec2 	bl	1c2e <memset>
		return true;
   23eaa:	2601      	movs	r6, #1
   23eac:	e7c8      	b.n	23e40 <bt_smp_request_ltk+0x76>
	if (conn->le.keys && (conn->le.keys->keys & BT_KEYS_SLAVE_LTK) &&
   23eae:	b338      	cbz	r0, 23f00 <bt_smp_request_ltk+0x136>
   23eb0:	8943      	ldrh	r3, [r0, #10]
   23eb2:	07db      	lsls	r3, r3, #31
   23eb4:	d524      	bpl.n	23f00 <bt_smp_request_ltk+0x136>
	    !memcmp(conn->le.keys->slave_ltk.rand, &rand, 8) &&
   23eb6:	2208      	movs	r2, #8
   23eb8:	4669      	mov	r1, sp
   23eba:	3064      	adds	r0, #100	; 0x64
   23ebc:	f7dd fe88 	bl	1bd0 <memcmp>
	if (conn->le.keys && (conn->le.keys->keys & BT_KEYS_SLAVE_LTK) &&
   23ec0:	b9f0      	cbnz	r0, 23f00 <bt_smp_request_ltk+0x136>
	    !memcmp(conn->le.keys->slave_ltk.ediv, &ediv, 2)) {
   23ec2:	f8d5 00a0 	ldr.w	r0, [r5, #160]	; 0xa0
   23ec6:	2202      	movs	r2, #2
   23ec8:	a90a      	add	r1, sp, #40	; 0x28
   23eca:	306c      	adds	r0, #108	; 0x6c
   23ecc:	f7dd fe80 	bl	1bd0 <memcmp>
	    !memcmp(conn->le.keys->slave_ltk.rand, &rand, 8) &&
   23ed0:	4606      	mov	r6, r0
   23ed2:	b9a8      	cbnz	r0, 23f00 <bt_smp_request_ltk+0x136>
		enc_size = conn->le.keys->enc_size;
   23ed4:	f8d5 10a0 	ldr.w	r1, [r5, #160]	; 0xa0
   23ed8:	7a0d      	ldrb	r5, [r1, #8]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   23eda:	4638      	mov	r0, r7
   23edc:	462a      	mov	r2, r5
   23ede:	316e      	adds	r1, #110	; 0x6e
   23ee0:	f7dd fe84 	bl	1bec <memcpy>
		if (enc_size < BT_SMP_MAX_ENC_KEY_SIZE) {
   23ee4:	2d0f      	cmp	r5, #15
   23ee6:	d805      	bhi.n	23ef4 <bt_smp_request_ltk+0x12a>
__ssp_bos_icheck3(memset, void *, int)
   23ee8:	f1c5 0210 	rsb	r2, r5, #16
   23eec:	4631      	mov	r1, r6
   23eee:	1978      	adds	r0, r7, r5
   23ef0:	f7dd fe9d 	bl	1c2e <memset>
		atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
   23ef4:	2101      	movs	r1, #1
   23ef6:	f104 009c 	add.w	r0, r4, #156	; 0x9c
   23efa:	f7ff fca2 	bl	23842 <atomic_set_bit>
		return true;
   23efe:	e7d4      	b.n	23eaa <bt_smp_request_ltk+0xe0>
	if (atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ)) {
   23f00:	210e      	movs	r1, #14
   23f02:	f104 009c 	add.w	r0, r4, #156	; 0x9c
   23f06:	f7ff fcab 	bl	23860 <atomic_test_bit>
   23f0a:	b118      	cbz	r0, 23f14 <bt_smp_request_ltk+0x14a>
		bt_conn_security_changed(smp->chan.chan.conn,
   23f0c:	2102      	movs	r1, #2
   23f0e:	6820      	ldr	r0, [r4, #0]
   23f10:	f7e6 fce0 	bl	a8d4 <bt_conn_security_changed>
	smp_reset(smp);
   23f14:	4620      	mov	r0, r4
   23f16:	f7ff fe0e 	bl	23b36 <smp_reset>
	return false;
   23f1a:	2600      	movs	r6, #0
   23f1c:	e790      	b.n	23e40 <bt_smp_request_ltk+0x76>

00023f1e <bt_smp_irk_get>:
{
   23f1e:	b530      	push	{r4, r5, lr}
   23f20:	b085      	sub	sp, #20
   23f22:	4605      	mov	r5, r0
	u8_t invalid_ir[16] = { 0 };
   23f24:	2210      	movs	r2, #16
{
   23f26:	460c      	mov	r4, r1
	u8_t invalid_ir[16] = { 0 };
   23f28:	4668      	mov	r0, sp
   23f2a:	2100      	movs	r1, #0
   23f2c:	f7dd fe7f 	bl	1c2e <memset>
	if (!memcmp(ir, invalid_ir, 16)) {
   23f30:	2210      	movs	r2, #16
   23f32:	4669      	mov	r1, sp
   23f34:	4628      	mov	r0, r5
   23f36:	f7dd fe4b 	bl	1bd0 <memcmp>
   23f3a:	b178      	cbz	r0, 23f5c <bt_smp_irk_get+0x3e>
	dst[0] = val;
   23f3c:	2301      	movs	r3, #1
   23f3e:	7023      	strb	r3, [r4, #0]
	dst[1] = val >> 8;
   23f40:	2300      	movs	r3, #0
   23f42:	7063      	strb	r3, [r4, #1]
	dst[0] = val;
   23f44:	70a3      	strb	r3, [r4, #2]
	dst[1] = val >> 8;
   23f46:	70e3      	strb	r3, [r4, #3]
   23f48:	6063      	str	r3, [r4, #4]
   23f4a:	60a3      	str	r3, [r4, #8]
   23f4c:	60e3      	str	r3, [r4, #12]
	err = bt_encrypt_le(key, res, res);
   23f4e:	4622      	mov	r2, r4
   23f50:	4621      	mov	r1, r4
   23f52:	4628      	mov	r0, r5
   23f54:	f000 fa51 	bl	243fa <bt_encrypt_le>
}
   23f58:	b005      	add	sp, #20
   23f5a:	bd30      	pop	{r4, r5, pc}
		return -EINVAL;
   23f5c:	f06f 0015 	mvn.w	r0, #21
   23f60:	e7fa      	b.n	23f58 <bt_smp_irk_get+0x3a>

00023f62 <id_add>:
	bt_id_add(keys);
   23f62:	f7e5 b94b 	b.w	91fc <bt_id_add>

00023f66 <bt_addr_le_copy>:
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   23f66:	680b      	ldr	r3, [r1, #0]
   23f68:	6003      	str	r3, [r0, #0]
   23f6a:	888b      	ldrh	r3, [r1, #4]
   23f6c:	8083      	strh	r3, [r0, #4]
   23f6e:	798b      	ldrb	r3, [r1, #6]
   23f70:	7183      	strb	r3, [r0, #6]
   23f72:	4770      	bx	lr

00023f74 <bt_keys_get_type>:
{
   23f74:	b570      	push	{r4, r5, r6, lr}
   23f76:	4604      	mov	r4, r0
   23f78:	460d      	mov	r5, r1
   23f7a:	4616      	mov	r6, r2
	keys = bt_keys_find(type, id, addr);
   23f7c:	f7ec f968 	bl	10250 <bt_keys_find>
	if (keys) {
   23f80:	b938      	cbnz	r0, 23f92 <bt_keys_get_type+0x1e>
	keys = bt_keys_get_addr(id, addr);
   23f82:	4631      	mov	r1, r6
   23f84:	4628      	mov	r0, r5
   23f86:	f7ec f8f3 	bl	10170 <bt_keys_get_addr>
	if (!keys) {
   23f8a:	b110      	cbz	r0, 23f92 <bt_keys_get_type+0x1e>
	keys->keys |= type;
   23f8c:	8943      	ldrh	r3, [r0, #10]
   23f8e:	431c      	orrs	r4, r3
   23f90:	8144      	strh	r4, [r0, #10]
}
   23f92:	bd70      	pop	{r4, r5, r6, pc}

00023f94 <bt_keys_add_type>:
	keys->keys |= type;
   23f94:	8943      	ldrh	r3, [r0, #10]
   23f96:	4319      	orrs	r1, r3
   23f98:	8141      	strh	r1, [r0, #10]
}
   23f9a:	4770      	bx	lr

00023f9c <mem_init>:

#include "mem.h"

void mem_init(void *mem_pool, u16_t mem_size, u16_t mem_count,
	      void **mem_head)
{
   23f9c:	b530      	push	{r4, r5, lr}
	*mem_head = mem_pool;
   23f9e:	6018      	str	r0, [r3, #0]

	/* Store free mem_count after the list's next pointer at an 32-bit
	 * aligned memory location to ensure atomic read/write (in ARM for now).
	 */
	*((u16_t *)MROUND((u8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   23fa0:	1dc3      	adds	r3, r0, #7
   23fa2:	f023 0303 	bic.w	r3, r3, #3
__ssp_bos_icheck3(memset, void *, int)
   23fa6:	2400      	movs	r4, #0
   23fa8:	801a      	strh	r2, [r3, #0]

	/* Initialize next pointers to form a free list,
	 * next pointer is stored in the first 32-bit of each block
	 */
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   23faa:	3a01      	subs	r2, #1
   23fac:	b292      	uxth	r2, r2
   23fae:	fb01 f302 	mul.w	r3, r1, r2
   23fb2:	50c4      	str	r4, [r0, r3]
		     sizeof(mem_pool));
	while (mem_count--) {
   23fb4:	f64f 74ff 	movw	r4, #65535	; 0xffff
   23fb8:	3a01      	subs	r2, #1
   23fba:	b292      	uxth	r2, r2
   23fbc:	42a2      	cmp	r2, r4
   23fbe:	d100      	bne.n	23fc2 <mem_init+0x26>
		next = (u32_t)((u8_t *) mem_pool +
			       (mem_size * (mem_count + 1)));
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
		       (void *)&next, sizeof(next));
	}
}
   23fc0:	bd30      	pop	{r4, r5, pc}
			       (mem_size * (mem_count + 1)));
   23fc2:	fb02 1301 	mla	r3, r2, r1, r1
		next = (u32_t)((u8_t *) mem_pool +
   23fc6:	18c5      	adds	r5, r0, r3
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
   23fc8:	1a5b      	subs	r3, r3, r1
   23fca:	50c5      	str	r5, [r0, r3]
   23fcc:	e7f4      	b.n	23fb8 <mem_init+0x1c>

00023fce <mem_acquire>:

void *mem_acquire(void **mem_head)
{
	if (*mem_head) {
   23fce:	6803      	ldr	r3, [r0, #0]
{
   23fd0:	b510      	push	{r4, lr}
	if (*mem_head) {
   23fd2:	b15b      	cbz	r3, 23fec <mem_acquire+0x1e>
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
					       sizeof(mem_head)));
		free_count--;

		mem = *mem_head;
		memcpy(&head, mem, sizeof(head));
   23fd4:	681a      	ldr	r2, [r3, #0]

		/* Store free mem_count after the list's next pointer */
		if (head) {
   23fd6:	b142      	cbz	r2, 23fea <mem_acquire+0x1c>
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
   23fd8:	1dd9      	adds	r1, r3, #7
   23fda:	f021 0103 	bic.w	r1, r1, #3
   23fde:	880c      	ldrh	r4, [r1, #0]
			*((u16_t *)MROUND((u8_t *)head + sizeof(head))) =
   23fe0:	1dd1      	adds	r1, r2, #7
   23fe2:	f021 0103 	bic.w	r1, r1, #3
		free_count--;
   23fe6:	3c01      	subs	r4, #1
			*((u16_t *)MROUND((u8_t *)head + sizeof(head))) =
   23fe8:	800c      	strh	r4, [r1, #0]
				free_count;
		}

		*mem_head = head;
   23fea:	6002      	str	r2, [r0, #0]
		return mem;
	}

	return NULL;
}
   23fec:	4618      	mov	r0, r3
   23fee:	bd10      	pop	{r4, pc}

00023ff0 <mem_release>:
void mem_release(void *mem, void **mem_head)
{
	u16_t free_count = 0U;

	/* Get the free count from the list and increment it */
	if (*mem_head) {
   23ff0:	680b      	ldr	r3, [r1, #0]
{
   23ff2:	b510      	push	{r4, lr}
	if (*mem_head) {
   23ff4:	b11b      	cbz	r3, 23ffe <mem_release+0xe>
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
   23ff6:	3307      	adds	r3, #7
   23ff8:	f023 0303 	bic.w	r3, r3, #3
   23ffc:	881b      	ldrh	r3, [r3, #0]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   23ffe:	680c      	ldr	r4, [r1, #0]
   24000:	4602      	mov	r2, r0
					       sizeof(mem_head)));
	}
	free_count++;
   24002:	3301      	adds	r3, #1
   24004:	f842 4b07 	str.w	r4, [r2], #7

	memcpy(mem, mem_head, sizeof(mem));

	/* Store free mem_count after the list's next pointer */
	*((u16_t *)MROUND((u8_t *)mem + sizeof(mem))) = free_count;
   24008:	f022 0203 	bic.w	r2, r2, #3
   2400c:	8013      	strh	r3, [r2, #0]

	*mem_head = mem;
   2400e:	6008      	str	r0, [r1, #0]
}
   24010:	bd10      	pop	{r4, pc}

00024012 <mem_get>:
}

void *mem_get(void *mem_pool, u16_t mem_size, u16_t index)
{
	return ((void *)((u8_t *)mem_pool + (mem_size * index)));
}
   24012:	fb02 0001 	mla	r0, r2, r1, r0
   24016:	4770      	bx	lr

00024018 <mem_index_get>:

u16_t mem_index_get(void *mem, void *mem_pool, u16_t mem_size)
{
	return ((u16_t)((u8_t *)mem - (u8_t *)mem_pool) / mem_size);
   24018:	1a40      	subs	r0, r0, r1
   2401a:	b280      	uxth	r0, r0
}
   2401c:	fbb0 f0f2 	udiv	r0, r0, r2
   24020:	4770      	bx	lr

00024022 <mem_rcopy>:
/**
 * @brief  Copy bytes in reverse
 * @details Example: [ 0x11 0x22 0x33 ] -> [ 0x33 0x22 0x11 ]
 */
void mem_rcopy(u8_t *dst, u8_t const *src, u16_t len)
{
   24022:	b510      	push	{r4, lr}
	src += len;
   24024:	4411      	add	r1, r2
	while (len--) {
   24026:	3801      	subs	r0, #1
   24028:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2402c:	3a01      	subs	r2, #1
   2402e:	b292      	uxth	r2, r2
   24030:	429a      	cmp	r2, r3
   24032:	d100      	bne.n	24036 <mem_rcopy+0x14>
		*dst++ = *--src;
	}
}
   24034:	bd10      	pop	{r4, pc}
		*dst++ = *--src;
   24036:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
   2403a:	f800 4f01 	strb.w	r4, [r0, #1]!
   2403e:	e7f5      	b.n	2402c <mem_rcopy+0xa>

00024040 <mem_nz>:
 * @brief Determine if src[0..len-1] contains one or more non-zero bytes
 * @return 0 if all bytes are zero; otherwise 1
 */
u8_t mem_nz(u8_t *src, u16_t len)
{
	while (len--) {
   24040:	4401      	add	r1, r0
   24042:	4288      	cmp	r0, r1
   24044:	d101      	bne.n	2404a <mem_nz+0xa>
		if (*src++) {
			return 1;
		}
	}

	return 0;
   24046:	2000      	movs	r0, #0
   24048:	4770      	bx	lr
		if (*src++) {
   2404a:	f810 3b01 	ldrb.w	r3, [r0], #1
   2404e:	2b00      	cmp	r3, #0
   24050:	d0f7      	beq.n	24042 <mem_nz+0x2>
			return 1;
   24052:	2001      	movs	r0, #1
}
   24054:	4770      	bx	lr

00024056 <memq_init>:
 * @return          Initial link-element
 */
memq_link_t *memq_init(memq_link_t *link, memq_link_t **head, memq_link_t **tail)
{
	/* Head and tail pointer to the initial link - forms an empty queue */
	*head = *tail = link;
   24056:	6010      	str	r0, [r2, #0]
   24058:	6008      	str	r0, [r1, #0]

	return link;
}
   2405a:	4770      	bx	lr

0002405c <memq_deinit>:
memq_link_t *memq_deinit(memq_link_t **head, memq_link_t **tail)
{
	memq_link_t *old_head;

	/* If head and tail are not equal, then queue is not empty */
	if (*head != *tail) {
   2405c:	6803      	ldr	r3, [r0, #0]
   2405e:	680a      	ldr	r2, [r1, #0]
   24060:	4293      	cmp	r3, r2
   24062:	f04f 0200 	mov.w	r2, #0
		return NULL;
   24066:	bf12      	itee	ne
   24068:	4613      	movne	r3, r2
	}

	old_head = *head;
	*head = *tail = NULL;
   2406a:	600a      	streq	r2, [r1, #0]
   2406c:	6002      	streq	r2, [r0, #0]

	return old_head;
}
   2406e:	4618      	mov	r0, r3
   24070:	4770      	bx	lr

00024072 <memq_enqueue>:
 * @param mem[in]      The memory payload to be enqueued. Pointed to by old tail
 * @param tail[in,out] Tail of queue. Will be updated to point to link
 * @return             New tail. Note: Does not point to the new mem
 */
memq_link_t *memq_enqueue(memq_link_t *link, void *mem, memq_link_t **tail)
{
   24072:	b510      	push	{r4, lr}
	/* Let the old tail element point to the new tail element */
	(*tail)->next = link;
   24074:	6814      	ldr	r4, [r2, #0]
   24076:	6020      	str	r0, [r4, #0]

	/* Let the old tail element point the the new memory */
	(*tail)->mem = mem;
   24078:	6814      	ldr	r4, [r2, #0]
   2407a:	6061      	str	r1, [r4, #4]

	/* Update the tail-pointer to point to the new tail element.
	 * The new tail-element is not expected to point to anything sensible
	 */
	*tail = link;
   2407c:	6010      	str	r0, [r2, #0]

	return link;
}
   2407e:	bd10      	pop	{r4, pc}

00024080 <memq_peek>:
 * @return         head or NULL if queue is empty
 */
memq_link_t *memq_peek(memq_link_t *head, memq_link_t *tail, void **mem)
{
	/* If head and tail are equal, then queue empty */
	if (head == tail) {
   24080:	4288      	cmp	r0, r1
   24082:	d003      	beq.n	2408c <memq_peek+0xc>
		return NULL;
	}

	/* Extract the head link-element's memory */
	if (mem) {
   24084:	b11a      	cbz	r2, 2408e <memq_peek+0xe>
		*mem = head->mem;
   24086:	6843      	ldr	r3, [r0, #4]
   24088:	6013      	str	r3, [r2, #0]
   2408a:	4770      	bx	lr
		return NULL;
   2408c:	2000      	movs	r0, #0
	}

	return head; /* queue was not empty */
}
   2408e:	4770      	bx	lr

00024090 <memq_dequeue>:
memq_link_t *memq_dequeue(memq_link_t *tail, memq_link_t **head, void **mem)
{
	memq_link_t *old_head;

	/* Use memq peek to get the old head and its mem */
	old_head = memq_peek(*head, tail, mem);
   24090:	680b      	ldr	r3, [r1, #0]
	if (head == tail) {
   24092:	4283      	cmp	r3, r0
   24094:	d009      	beq.n	240aa <memq_dequeue+0x1a>
	if (mem) {
   24096:	b122      	cbz	r2, 240a2 <memq_dequeue+0x12>
		*mem = head->mem;
   24098:	6858      	ldr	r0, [r3, #4]
   2409a:	6010      	str	r0, [r2, #0]
	if (old_head == NULL) {
		return NULL; /* queue is empty */
	}

	/* Update the head-pointer to point to the new head element */
	*head = old_head->next;
   2409c:	681a      	ldr	r2, [r3, #0]
   2409e:	600a      	str	r2, [r1, #0]

	return old_head;
   240a0:	e001      	b.n	240a6 <memq_dequeue+0x16>
	if (old_head == NULL) {
   240a2:	2b00      	cmp	r3, #0
   240a4:	d1fa      	bne.n	2409c <memq_dequeue+0xc>
}
   240a6:	4618      	mov	r0, r3
   240a8:	4770      	bx	lr
		return NULL; /* queue is empty */
   240aa:	2300      	movs	r3, #0
   240ac:	e7fb      	b.n	240a6 <memq_dequeue+0x16>

000240ae <util_ones_count_get>:
 * @param octets_len Must not be bigger than 255/8 = 31 bytes
 *
 * @return popcnt of 'octets'
 */
u8_t util_ones_count_get(u8_t *octets, u8_t octets_len)
{
   240ae:	b510      	push	{r4, lr}
   240b0:	1e42      	subs	r2, r0, #1
	u8_t one_count = 0U;
   240b2:	2000      	movs	r0, #0

	while (octets_len--) {
   240b4:	3901      	subs	r1, #1
   240b6:	b2c9      	uxtb	r1, r1
   240b8:	29ff      	cmp	r1, #255	; 0xff
   240ba:	d100      	bne.n	240be <util_ones_count_get+0x10>
		}
		octets++;
	}

	return one_count;
}
   240bc:	bd10      	pop	{r4, pc}
		bite = *octets;
   240be:	f812 3f01 	ldrb.w	r3, [r2, #1]!
		while (bite) {
   240c2:	2b00      	cmp	r3, #0
   240c4:	d0f6      	beq.n	240b4 <util_ones_count_get+0x6>
			bite &= (bite - 1);
   240c6:	b25b      	sxtb	r3, r3
   240c8:	1e5c      	subs	r4, r3, #1
   240ca:	4023      	ands	r3, r4
			one_count++;
   240cc:	3001      	adds	r0, #1
			bite &= (bite - 1);
   240ce:	b2db      	uxtb	r3, r3
			one_count++;
   240d0:	b2c0      	uxtb	r0, r0
   240d2:	e7f6      	b.n	240c2 <util_ones_count_get+0x14>

000240d4 <ticks_to_expire_prep>:
{
   240d4:	b530      	push	{r4, r5, lr}
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
   240d6:	1a55      	subs	r5, r2, r1
   240d8:	f415 0f00 	tst.w	r5, #8388608	; 0x800000
	u32_t ticks_to_expire = ticker->ticks_to_expire;
   240dc:	6883      	ldr	r3, [r0, #8]
	u32_t ticks_to_expire_minus = ticker->ticks_to_expire_minus;
   240de:	6944      	ldr	r4, [r0, #20]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
   240e0:	d109      	bne.n	240f6 <ticks_to_expire_prep+0x22>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   240e2:	f025 427f 	bic.w	r2, r5, #4278190080	; 0xff000000
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
   240e6:	441a      	add	r2, r3
	if (ticks_to_expire > ticks_to_expire_minus) {
   240e8:	42a2      	cmp	r2, r4
   240ea:	d90e      	bls.n	2410a <ticks_to_expire_prep+0x36>
		ticks_to_expire -= ticks_to_expire_minus;
   240ec:	1b12      	subs	r2, r2, r4
		ticks_to_expire_minus = 0U;
   240ee:	2400      	movs	r4, #0
	ticker->ticks_to_expire = ticks_to_expire;
   240f0:	6082      	str	r2, [r0, #8]
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
   240f2:	6144      	str	r4, [r0, #20]
}
   240f4:	bd30      	pop	{r4, r5, pc}
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   240f6:	1a8a      	subs	r2, r1, r2
   240f8:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
   240fc:	4293      	cmp	r3, r2
   240fe:	d901      	bls.n	24104 <ticks_to_expire_prep+0x30>
			ticks_to_expire -= delta_current_start;
   24100:	1a9a      	subs	r2, r3, r2
   24102:	e7f1      	b.n	240e8 <ticks_to_expire_prep+0x14>
			ticks_to_expire_minus +=
   24104:	4422      	add	r2, r4
   24106:	1ad4      	subs	r4, r2, r3
			ticks_to_expire = 0U;
   24108:	2200      	movs	r2, #0
		ticks_to_expire_minus -= ticks_to_expire;
   2410a:	1aa4      	subs	r4, r4, r2
		ticks_to_expire = 0U;
   2410c:	2200      	movs	r2, #0
   2410e:	e7ef      	b.n	240f0 <ticks_to_expire_prep+0x1c>

00024110 <ticker_job_op_cb>:
{
   24110:	4603      	mov	r3, r0
	user_op->op = TICKER_USER_OP_TYPE_NONE;
   24112:	2200      	movs	r2, #0
   24114:	701a      	strb	r2, [r3, #0]
	if (user_op->fp_op_func) {
   24116:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	user_op->status = status;
   24118:	6259      	str	r1, [r3, #36]	; 0x24
{
   2411a:	4608      	mov	r0, r1
	if (user_op->fp_op_func) {
   2411c:	b10a      	cbz	r2, 24122 <ticker_job_op_cb+0x12>
		user_op->fp_op_func(user_op->status, user_op->op_context);
   2411e:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
   24120:	4710      	bx	r2
}
   24122:	4770      	bx	lr

00024124 <ticker_worker>:
{
   24124:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (instance->job_guard) {
   24128:	7f86      	ldrb	r6, [r0, #30]
	instance->worker_trigger = 1U;
   2412a:	2301      	movs	r3, #1
{
   2412c:	b08b      	sub	sp, #44	; 0x2c
   2412e:	4605      	mov	r5, r0
	instance->worker_trigger = 1U;
   24130:	77c3      	strb	r3, [r0, #31]
	if (instance->job_guard) {
   24132:	b91e      	cbnz	r6, 2413c <ticker_worker+0x18>
	if (instance->ticker_id_head == TICKER_NULL) {
   24134:	7f43      	ldrb	r3, [r0, #29]
   24136:	2bff      	cmp	r3, #255	; 0xff
   24138:	d103      	bne.n	24142 <ticker_worker+0x1e>
		instance->worker_trigger = 0U;
   2413a:	77c6      	strb	r6, [r0, #31]
}
   2413c:	b00b      	add	sp, #44	; 0x2c
   2413e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ticks_elapsed = ticker_ticks_diff_get(cntr_cnt_get(),
   24142:	f7f4 f9d5 	bl	184f0 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   24146:	696b      	ldr	r3, [r5, #20]
	ticker_id_head = instance->ticker_id_head;
   24148:	f895 801d 	ldrb.w	r8, [r5, #29]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   2414c:	1ac0      	subs	r0, r0, r3
	if (instance->ticker_id_slot_previous != TICKER_NULL) {
   2414e:	7f2b      	ldrb	r3, [r5, #28]
   24150:	2bff      	cmp	r3, #255	; 0xff
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   24152:	f020 497f 	bic.w	r9, r0, #4278190080	; 0xff000000
	if (instance->ticker_id_slot_previous != TICKER_NULL) {
   24156:	d027      	beq.n	241a8 <ticker_worker+0x84>
		if (instance->ticks_slot_previous > ticks_elapsed) {
   24158:	69ae      	ldr	r6, [r5, #24]
	u8_t slot_reserved = 0;
   2415a:	454e      	cmp	r6, r9
   2415c:	bf94      	ite	ls
   2415e:	2300      	movls	r3, #0
   24160:	2301      	movhi	r3, #1
   24162:	9301      	str	r3, [sp, #4]
	node = &instance->nodes[0];
   24164:	f8d5 a000 	ldr.w	sl, [r5]
	ticks_expired = 0U;
   24168:	f04f 0b00 	mov.w	fp, #0
	while (ticker_id_head != TICKER_NULL) {
   2416c:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
   24170:	d11c      	bne.n	241ac <ticker_worker+0x88>
	if (instance->ticks_elapsed_first == instance->ticks_elapsed_last) {
   24172:	7aea      	ldrb	r2, [r5, #11]
   24174:	7aab      	ldrb	r3, [r5, #10]
   24176:	4293      	cmp	r3, r2
   24178:	d105      	bne.n	24186 <ticker_worker+0x62>
	u8_t idx = *ticks_elapsed_index + 1;
   2417a:	3301      	adds	r3, #1
   2417c:	b2db      	uxtb	r3, r3
		idx = 0U;
   2417e:	2b02      	cmp	r3, #2
   24180:	bf08      	it	eq
   24182:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
   24184:	72eb      	strb	r3, [r5, #11]
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   24186:	7aeb      	ldrb	r3, [r5, #11]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   24188:	6a6c      	ldr	r4, [r5, #36]	; 0x24
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   2418a:	eb05 0383 	add.w	r3, r5, r3, lsl #2
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   2418e:	2201      	movs	r2, #1
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   24190:	f8c3 b00c 	str.w	fp, [r3, #12]
	instance->worker_trigger = 0U;
   24194:	2300      	movs	r3, #0
   24196:	77eb      	strb	r3, [r5, #31]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   24198:	2104      	movs	r1, #4
   2419a:	462b      	mov	r3, r5
   2419c:	2003      	movs	r0, #3
   2419e:	46a4      	mov	ip, r4
}
   241a0:	b00b      	add	sp, #44	; 0x2c
   241a2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   241a6:	4760      	bx	ip
	u8_t slot_reserved = 0;
   241a8:	9601      	str	r6, [sp, #4]
   241aa:	e7db      	b.n	24164 <ticker_worker+0x40>
		ticker = &node[ticker_id_head];
   241ac:	232c      	movs	r3, #44	; 0x2c
   241ae:	fb18 f803 	smulbb	r8, r8, r3
   241b2:	eb0a 0408 	add.w	r4, sl, r8
		ticks_to_expire = ticker->ticks_to_expire;
   241b6:	68a3      	ldr	r3, [r4, #8]
		if (ticks_elapsed < ticks_to_expire) {
   241b8:	4599      	cmp	r9, r3
   241ba:	d3da      	bcc.n	24172 <ticker_worker+0x4e>
		if (ticker->ticks_slot != 0U &&
   241bc:	69a7      	ldr	r7, [r4, #24]
		ticker_id_head = ticker->next;
   241be:	f81a 8008 	ldrb.w	r8, [sl, r8]
		ticks_elapsed -= ticks_to_expire;
   241c2:	eba9 0903 	sub.w	r9, r9, r3
		ticks_expired += ticks_to_expire;
   241c6:	449b      	add	fp, r3
		if (ticker->ticks_slot != 0U &&
   241c8:	b35f      	cbz	r7, 24222 <ticker_worker+0xfe>
   241ca:	8be3      	ldrh	r3, [r4, #30]
   241cc:	461e      	mov	r6, r3
   241ce:	9b01      	ldr	r3, [sp, #4]
   241d0:	2b00      	cmp	r3, #0
   241d2:	f040 8083 	bne.w	242dc <ticker_worker+0x1b8>
	if (ticker->lazy_periodic > lazy_current) {
   241d6:	8ba2      	ldrh	r2, [r4, #28]
   241d8:	4296      	cmp	r6, r2
   241da:	d37f      	bcc.n	242dc <ticker_worker+0x1b8>
	} else if ((ticker->priority != TICKER_PRIORITY_CRITICAL) &&
   241dc:	f994 3029 	ldrsb.w	r3, [r4, #41]	; 0x29
   241e0:	9302      	str	r3, [sp, #8]
   241e2:	3380      	adds	r3, #128	; 0x80
   241e4:	d01c      	beq.n	24220 <ticker_worker+0xfc>
   241e6:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
   241ea:	f000 8088 	beq.w	242fe <ticker_worker+0x1da>
		u32_t acc_ticks_to_expire = 0;
   241ee:	9901      	ldr	r1, [sp, #4]
		u32_t current_age = ticker->ticks_periodic +
   241f0:	6863      	ldr	r3, [r4, #4]
		u32_t acc_ticks_to_expire = 0;
   241f2:	9104      	str	r1, [sp, #16]
				(lazy_current - ticker->priority);
   241f4:	9902      	ldr	r1, [sp, #8]
			lazy_current -= ticker->lazy_periodic;
   241f6:	1ab2      	subs	r2, r6, r2
		u32_t current_age = ticker->ticks_periodic +
   241f8:	fb02 3303 	mla	r3, r2, r3, r3
				(lazy_current - ticker->priority);
   241fc:	1a52      	subs	r2, r2, r1
		u32_t current_age = ticker->ticks_periodic +
   241fe:	9306      	str	r3, [sp, #24]
				(lazy_current - ticker->priority);
   24200:	9209      	str	r2, [sp, #36]	; 0x24
		u32_t current_age = ticker->ticks_periodic +
   24202:	4643      	mov	r3, r8
			struct ticker_node *ticker_next = &nodes[id_head];
   24204:	222c      	movs	r2, #44	; 0x2c
   24206:	fb13 f302 	smulbb	r3, r3, r2
   2420a:	eb0a 0e03 	add.w	lr, sl, r3
   2420e:	9305      	str	r3, [sp, #20]
			if (ticker_next->ticks_slot == 0) {
   24210:	f8de 3018 	ldr.w	r3, [lr, #24]
   24214:	bb4b      	cbnz	r3, 2426a <ticker_worker+0x146>
			id_head = ticker_next->next;
   24216:	9b05      	ldr	r3, [sp, #20]
   24218:	f81a 3003 	ldrb.w	r3, [sl, r3]
		while (id_head != TICKER_NULL) {
   2421c:	2bff      	cmp	r3, #255	; 0xff
   2421e:	d1f1      	bne.n	24204 <ticker_worker+0xe0>
		must_expire_skip = 0U;
   24220:	2700      	movs	r7, #0
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
   24222:	78a2      	ldrb	r2, [r4, #2]
   24224:	7863      	ldrb	r3, [r4, #1]
   24226:	1a9b      	subs	r3, r3, r2
   24228:	b2db      	uxtb	r3, r3
   2422a:	2b01      	cmp	r3, #1
   2422c:	d19e      	bne.n	2416c <ticker_worker+0x48>
		if (ticker->timeout_func) {
   2422e:	68e3      	ldr	r3, [r4, #12]
		ticker->ack--;
   24230:	3a01      	subs	r2, #1
   24232:	70a2      	strb	r2, [r4, #2]
		if (ticker->timeout_func) {
   24234:	461e      	mov	r6, r3
   24236:	2b00      	cmp	r3, #0
   24238:	d098      	beq.n	2416c <ticker_worker+0x48>
					   ticks_expired -
   2423a:	6960      	ldr	r0, [r4, #20]
   2423c:	696b      	ldr	r3, [r5, #20]
			ticker->timeout_func(ticks_at_expire,
   2423e:	6a61      	ldr	r1, [r4, #36]	; 0x24
					   ticks_expired -
   24240:	ebab 0000 	sub.w	r0, fp, r0
   24244:	4418      	add	r0, r3
			ticks_at_expire = (instance->ticks_current +
   24246:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticker->timeout_func(ticks_at_expire,
   2424a:	2f00      	cmp	r7, #0
   2424c:	d159      	bne.n	24302 <ticker_worker+0x1de>
   2424e:	8be2      	ldrh	r2, [r4, #30]
   24250:	6923      	ldr	r3, [r4, #16]
   24252:	47b0      	blx	r6
			if (must_expire_skip == 0U) {
   24254:	2f00      	cmp	r7, #0
   24256:	d189      	bne.n	2416c <ticker_worker+0x48>
				if (ticker->ticks_slot != 0U) {
   24258:	69a3      	ldr	r3, [r4, #24]
				ticker->lazy_current = 0U;
   2425a:	83e7      	strh	r7, [r4, #30]
					slot_reserved = 1U;
   2425c:	2b00      	cmp	r3, #0
   2425e:	9b01      	ldr	r3, [sp, #4]
				ticker->force = 0U;
   24260:	70e7      	strb	r7, [r4, #3]
					slot_reserved = 1U;
   24262:	bf18      	it	ne
   24264:	2301      	movne	r3, #1
   24266:	9301      	str	r3, [sp, #4]
   24268:	e780      	b.n	2416c <ticker_worker+0x48>
			s32_t lazy_next = ticker_next->lazy_current;
   2426a:	f8be 001e 	ldrh.w	r0, [lr, #30]
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   2426e:	9a04      	ldr	r2, [sp, #16]
				ticker_next->lazy_periodic > lazy_next;
   24270:	f8be c01c 	ldrh.w	ip, [lr, #28]
				ticker_next->priority;
   24274:	f99e 1029 	ldrsb.w	r1, [lr, #41]	; 0x29
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   24278:	f8de 3008 	ldr.w	r3, [lr, #8]
				ticker_next->priority;
   2427c:	9103      	str	r1, [sp, #12]
			u32_t next_age = (ticker_next->ticks_periodic == 0U ?
   2427e:	f8de 1004 	ldr.w	r1, [lr, #4]
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   24282:	441a      	add	r2, r3
			if (!lazy_next_periodic_skip) {
   24284:	4560      	cmp	r0, ip
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   24286:	9204      	str	r2, [sp, #16]
			s32_t lazy_next = ticker_next->lazy_current;
   24288:	4602      	mov	r2, r0
				lazy_next -= ticker_next->lazy_periodic;
   2428a:	bf28      	it	cs
   2428c:	eba0 020c 	subcs.w	r2, r0, ip
					  0U :
   24290:	2900      	cmp	r1, #0
   24292:	d032      	beq.n	242fa <ticker_worker+0x1d6>
   24294:	1acb      	subs	r3, r1, r3
   24296:	9307      	str	r3, [sp, #28]
			u8_t next_force = (ticker_next->force > ticker->force);
   24298:	f89e 3003 	ldrb.w	r3, [lr, #3]
   2429c:	9308      	str	r3, [sp, #32]
			if (!lazy_next_periodic_skip &&
   2429e:	4560      	cmp	r0, ip
			u8_t next_force = (ticker_next->force > ticker->force);
   242a0:	f894 e003 	ldrb.w	lr, [r4, #3]
			if (!lazy_next_periodic_skip &&
   242a4:	d3b7      	bcc.n	24216 <ticker_worker+0xf2>
   242a6:	9b04      	ldr	r3, [sp, #16]
   242a8:	429f      	cmp	r7, r3
   242aa:	d9b4      	bls.n	24216 <ticker_worker+0xf2>
			    (acc_ticks_to_expire < ticker->ticks_slot) &&
   242ac:	9b08      	ldr	r3, [sp, #32]
   242ae:	4573      	cmp	r3, lr
   242b0:	d814      	bhi.n	242dc <ticker_worker+0x1b8>
			    (next_force ||
   242b2:	9b03      	ldr	r3, [sp, #12]
   242b4:	3380      	adds	r3, #128	; 0x80
   242b6:	d011      	beq.n	242dc <ticker_worker+0x1b8>
			u32_t next_age = (ticker_next->ticks_periodic == 0U ?
   242b8:	9b07      	ldr	r3, [sp, #28]
   242ba:	fb01 3302 	mla	r3, r1, r2, r3
				(lazy_next - ticker_next->priority) >
   242be:	9903      	ldr	r1, [sp, #12]
   242c0:	1a52      	subs	r2, r2, r1
			     next_is_critical ||
   242c2:	9909      	ldr	r1, [sp, #36]	; 0x24
   242c4:	428a      	cmp	r2, r1
   242c6:	dd02      	ble.n	242ce <ticker_worker+0x1aa>
			    (next_has_priority && !current_is_older) ||
   242c8:	9a06      	ldr	r2, [sp, #24]
   242ca:	429a      	cmp	r2, r3
   242cc:	d906      	bls.n	242dc <ticker_worker+0x1b8>
   242ce:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
   242d2:	428a      	cmp	r2, r1
   242d4:	d19f      	bne.n	24216 <ticker_worker+0xf2>
			    (equal_priority && next_is_older))) {
   242d6:	9a06      	ldr	r2, [sp, #24]
   242d8:	429a      	cmp	r2, r3
   242da:	d29c      	bcs.n	24216 <ticker_worker+0xf2>
			ticker->lazy_current++;
   242dc:	4633      	mov	r3, r6
   242de:	3301      	adds	r3, #1
			if ((ticker->must_expire == 0U) ||
   242e0:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
			ticker->lazy_current++;
   242e4:	b29b      	uxth	r3, r3
   242e6:	83e3      	strh	r3, [r4, #30]
			if ((ticker->must_expire == 0U) ||
   242e8:	2a00      	cmp	r2, #0
   242ea:	f43f af3f 	beq.w	2416c <ticker_worker+0x48>
   242ee:	8ba2      	ldrh	r2, [r4, #28]
   242f0:	429a      	cmp	r2, r3
   242f2:	f4bf af3b 	bcs.w	2416c <ticker_worker+0x48>
			must_expire_skip = 1U;
   242f6:	2701      	movs	r7, #1
   242f8:	e793      	b.n	24222 <ticker_worker+0xfe>
					  0U :
   242fa:	9107      	str	r1, [sp, #28]
   242fc:	e7cc      	b.n	24298 <ticker_worker+0x174>
		must_expire_skip = 0U;
   242fe:	9f01      	ldr	r7, [sp, #4]
   24300:	e78f      	b.n	24222 <ticker_worker+0xfe>
			ticker->timeout_func(ticks_at_expire,
   24302:	f64f 72ff 	movw	r2, #65535	; 0xffff
   24306:	e7a3      	b.n	24250 <ticker_worker+0x12c>

00024308 <ticker_ticks_now_get>:
	return cntr_cnt_get();
   24308:	f7f4 b8f2 	b.w	184f0 <cntr_cnt_get>

0002430c <ticker_ticks_diff_get>:
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   2430c:	1a40      	subs	r0, r0, r1
}
   2430e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   24312:	4770      	bx	lr

00024314 <ll_tx_pwr_lvl_get>:
#include "ull_conn_internal.h"

u8_t ll_tx_pwr_lvl_get(u8_t handle_type,
		       u16_t handle, u8_t type, s8_t *tx_pwr_lvl)
{
	switch (handle_type) {
   24314:	2802      	cmp	r0, #2
{
   24316:	b538      	push	{r3, r4, r5, lr}
   24318:	4604      	mov	r4, r0
   2431a:	461d      	mov	r5, r3
	switch (handle_type) {
   2431c:	d107      	bne.n	2432e <ll_tx_pwr_lvl_get+0x1a>
#endif /* CONFIG_BT_OBSERVER && CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL*/
#if defined(CONFIG_BT_CONN)
		case (BT_HCI_VS_LL_HANDLE_TYPE_CONN): {
			struct ll_conn *conn;

			conn = ll_connected_get(handle);
   2431e:	4608      	mov	r0, r1
   24320:	f000 fa2d 	bl	2477e <ll_connected_get>
			if (!conn) {
   24324:	b108      	cbz	r0, 2432a <ll_tx_pwr_lvl_get+0x16>
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
				/* Level desired is maximum available */
				*tx_pwr_lvl = lll_radio_tx_pwr_max_get();
#else  /* !CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */
				/* Return default if not multiple TXP */
				*tx_pwr_lvl = RADIO_TXP_DEFAULT;
   24326:	2400      	movs	r4, #0
   24328:	702c      	strb	r4, [r5, #0]
			return BT_HCI_ERR_UNKNOWN_CMD;
		}
	}

	return BT_HCI_ERR_SUCCESS;
}
   2432a:	4620      	mov	r0, r4
   2432c:	bd38      	pop	{r3, r4, r5, pc}
			return BT_HCI_ERR_UNKNOWN_CMD;
   2432e:	2401      	movs	r4, #1
   24330:	e7fb      	b.n	2432a <ll_tx_pwr_lvl_get+0x16>

00024332 <ll_tx_pwr_get>:
{
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	*min = lll_radio_tx_pwr_min_get();
	*max = lll_radio_tx_pwr_max_get();
#else
	*min = RADIO_TXP_DEFAULT;
   24332:	2300      	movs	r3, #0
   24334:	7003      	strb	r3, [r0, #0]
	*max = RADIO_TXP_DEFAULT;
   24336:	700b      	strb	r3, [r1, #0]
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */
}
   24338:	4770      	bx	lr

0002433a <sys_put_le32>:
   2433a:	f3c0 2307 	ubfx	r3, r0, #8, #8
	dst[0] = val;
   2433e:	7008      	strb	r0, [r1, #0]
	sys_put_le16(val >> 16, &dst[2]);
   24340:	0c00      	lsrs	r0, r0, #16
	dst[0] = val;
   24342:	7088      	strb	r0, [r1, #2]
	dst[1] = val >> 8;
   24344:	0a00      	lsrs	r0, r0, #8
   24346:	704b      	strb	r3, [r1, #1]
   24348:	70c8      	strb	r0, [r1, #3]
}
   2434a:	4770      	bx	lr

0002434c <bt_addr_le_copy>:
{
   2434c:	4603      	mov	r3, r0
   2434e:	6808      	ldr	r0, [r1, #0]
   24350:	6018      	str	r0, [r3, #0]
   24352:	8888      	ldrh	r0, [r1, #4]
   24354:	798a      	ldrb	r2, [r1, #6]
   24356:	719a      	strb	r2, [r3, #6]
   24358:	8098      	strh	r0, [r3, #4]
}
   2435a:	4770      	bx	lr

0002435c <sys_get_le64>:
{
   2435c:	4603      	mov	r3, r0
}
   2435e:	6800      	ldr	r0, [r0, #0]
   24360:	6859      	ldr	r1, [r3, #4]
   24362:	4770      	bx	lr

00024364 <hci_evt_create>:
{
   24364:	b538      	push	{r3, r4, r5, lr}
	hdr = net_buf_add(buf, sizeof(*hdr));
   24366:	3008      	adds	r0, #8
{
   24368:	460d      	mov	r5, r1
	hdr = net_buf_add(buf, sizeof(*hdr));
   2436a:	2102      	movs	r1, #2
{
   2436c:	4614      	mov	r4, r2
	hdr = net_buf_add(buf, sizeof(*hdr));
   2436e:	f000 fd33 	bl	24dd8 <net_buf_simple_add>
	hdr->evt = evt;
   24372:	7005      	strb	r5, [r0, #0]
	hdr->len = len;
   24374:	7044      	strb	r4, [r0, #1]
}
   24376:	bd38      	pop	{r3, r4, r5, pc}

00024378 <meta_evt>:
{
   24378:	b570      	push	{r4, r5, r6, lr}
   2437a:	4604      	mov	r4, r0
   2437c:	4615      	mov	r5, r2
	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
   2437e:	3201      	adds	r2, #1
{
   24380:	460e      	mov	r6, r1
	me = net_buf_add(buf, sizeof(*me));
   24382:	3408      	adds	r4, #8
	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
   24384:	b2d2      	uxtb	r2, r2
   24386:	213e      	movs	r1, #62	; 0x3e
   24388:	f7ff ffec 	bl	24364 <hci_evt_create>
	me = net_buf_add(buf, sizeof(*me));
   2438c:	2101      	movs	r1, #1
   2438e:	4620      	mov	r0, r4
   24390:	f000 fd22 	bl	24dd8 <net_buf_simple_add>
	me->subevent = subevt;
   24394:	7006      	strb	r6, [r0, #0]
	return net_buf_add(buf, melen);
   24396:	4629      	mov	r1, r5
   24398:	4620      	mov	r0, r4
}
   2439a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return net_buf_add(buf, melen);
   2439e:	f000 bd1b 	b.w	24dd8 <net_buf_simple_add>

000243a2 <hci_num_cmplt_encode>:
{
   243a2:	b570      	push	{r4, r5, r6, lr}
   243a4:	4606      	mov	r6, r0
   243a6:	460d      	mov	r5, r1
   243a8:	4614      	mov	r4, r2
	hci_evt_create(buf, BT_HCI_EVT_NUM_COMPLETED_PACKETS, len);
   243aa:	2113      	movs	r1, #19
   243ac:	2205      	movs	r2, #5
   243ae:	f7ff ffd9 	bl	24364 <hci_evt_create>
	ep = net_buf_add(buf, len);
   243b2:	2105      	movs	r1, #5
   243b4:	f106 0008 	add.w	r0, r6, #8
   243b8:	f000 fd0e 	bl	24dd8 <net_buf_simple_add>
	ep->num_handles = num_handles;
   243bc:	2301      	movs	r3, #1
   243be:	7003      	strb	r3, [r0, #0]
	hc->handle = sys_cpu_to_le16(handle);
   243c0:	f8a0 5001 	strh.w	r5, [r0, #1]
	hc->count = sys_cpu_to_le16(num);
   243c4:	f8a0 4003 	strh.w	r4, [r0, #3]
}
   243c8:	bd70      	pop	{r4, r5, r6, pc}

000243ca <hci_get_class>:
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   243ca:	7903      	ldrb	r3, [r0, #4]
   243cc:	2b02      	cmp	r3, #2
   243ce:	d007      	beq.n	243e0 <hci_get_class+0x16>
		switch (node_rx->hdr.type) {
   243d0:	2b08      	cmp	r3, #8
   243d2:	d00e      	beq.n	243f2 <hci_get_class+0x28>
   243d4:	d30f      	bcc.n	243f6 <hci_get_class+0x2c>
   243d6:	2b0e      	cmp	r3, #14
			return HCI_CLASS_EVT_CONNECTION;
   243d8:	bf8c      	ite	hi
   243da:	2000      	movhi	r0, #0
   243dc:	2003      	movls	r0, #3
   243de:	4770      	bx	lr
	} else if (pdu_data->ll_id == PDU_DATA_LLID_CTRL) {
   243e0:	f890 3020 	ldrb.w	r3, [r0, #32]
   243e4:	f003 0303 	and.w	r3, r3, #3
   243e8:	2b03      	cmp	r3, #3
		return HCI_CLASS_ACL_DATA;
   243ea:	bf0c      	ite	eq
   243ec:	2004      	moveq	r0, #4
   243ee:	2005      	movne	r0, #5
   243f0:	4770      	bx	lr
			return HCI_CLASS_EVT_REQUIRED;
   243f2:	2001      	movs	r0, #1
   243f4:	4770      	bx	lr
			return HCI_CLASS_NONE;
   243f6:	2000      	movs	r0, #0
}
   243f8:	4770      	bx	lr

000243fa <bt_encrypt_le>:

int bt_encrypt_le(const u8_t key[16], const u8_t plaintext[16],
		  u8_t enc_data[16])
{
   243fa:	b508      	push	{r3, lr}
	BT_DBG("key %s", bt_hex(key, 16));
	BT_DBG("plaintext %s", bt_hex(plaintext, 16));

	ecb_encrypt(key, plaintext, enc_data, NULL);
   243fc:	2300      	movs	r3, #0
   243fe:	f000 fc64 	bl	24cca <ecb_encrypt>

	BT_DBG("enc_data %s", bt_hex(enc_data, 16));

	return 0;
}
   24402:	2000      	movs	r0, #0
   24404:	bd08      	pop	{r3, pc}

00024406 <disabled_cb>:
   24406:	f7fa bcb9 	b.w	1ed7c <z_impl_k_sem_give>

0002440a <rx_demux_conn_tx_ack>:
{
   2440a:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2440c:	4606      	mov	r6, r0
   2440e:	4614      	mov	r4, r2
   24410:	9300      	str	r3, [sp, #0]
   24412:	f8ad 1006 	strh.w	r1, [sp, #6]
		ull_conn_ack_dequeue();
   24416:	f7f2 fb57 	bl	16ac8 <ull_conn_ack_dequeue>
		conn = ull_conn_tx_ack(handle, link, node_tx);
   2441a:	9a00      	ldr	r2, [sp, #0]
   2441c:	f8bd 0006 	ldrh.w	r0, [sp, #6]
   24420:	4621      	mov	r1, r4
   24422:	f7f2 fb95 	bl	16b50 <ull_conn_tx_ack>
   24426:	4605      	mov	r5, r0
		ull_conn_link_tx_release(link);
   24428:	4620      	mov	r0, r4
   2442a:	f7f2 fb13 	bl	16a54 <ull_conn_link_tx_release>
		ull_conn_tx_demux(1);
   2442e:	2001      	movs	r0, #1
   24430:	f7f2 fa12 	bl	16858 <ull_conn_tx_demux>
		if (conn) {
   24434:	b11d      	cbz	r5, 2443e <rx_demux_conn_tx_ack+0x34>
			ull_conn_tx_lll_enqueue(conn, 1);
   24436:	2101      	movs	r1, #1
   24438:	4628      	mov	r0, r5
   2443a:	f7f2 fa53 	bl	168e4 <ull_conn_tx_lll_enqueue>
		link = ull_conn_ack_by_last_peek(ack_last, &handle, &node_tx);
   2443e:	466a      	mov	r2, sp
   24440:	f10d 0106 	add.w	r1, sp, #6
   24444:	4630      	mov	r0, r6
   24446:	f7f2 fb29 	bl	16a9c <ull_conn_ack_by_last_peek>
	} while (link);
   2444a:	4604      	mov	r4, r0
   2444c:	2800      	cmp	r0, #0
   2444e:	d1e2      	bne.n	24416 <rx_demux_conn_tx_ack+0xc>
			ll_rx_sched();
   24450:	f7ee fd10 	bl	12e74 <ll_rx_sched>
}
   24454:	b002      	add	sp, #8
   24456:	bd70      	pop	{r4, r5, r6, pc}

00024458 <ll_timeslice_ticker_id_get>:
	*instance_index = TICKER_INSTANCE_ID_CTLR;
   24458:	2300      	movs	r3, #0
   2445a:	7003      	strb	r3, [r0, #0]
	*user_id = (TICKER_NODES - FLASH_TICKER_NODES);
   2445c:	2304      	movs	r3, #4
   2445e:	700b      	strb	r3, [r1, #0]
}
   24460:	4770      	bx	lr

00024462 <chan_sel_remap>:
{
   24462:	b530      	push	{r4, r5, lr}
   24464:	1e42      	subs	r2, r0, #1
   24466:	1d03      	adds	r3, r0, #4
	chan_next = 0U;
   24468:	2000      	movs	r0, #0
	while (byte_count--) {
   2446a:	4293      	cmp	r3, r2
   2446c:	d100      	bne.n	24470 <chan_sel_remap+0xe>
}
   2446e:	bd30      	pop	{r4, r5, pc}
		bite = *chan_map;
   24470:	f100 0408 	add.w	r4, r0, #8
   24474:	f812 5f01 	ldrb.w	r5, [r2, #1]!
		while (bit_count--) {
   24478:	b2e4      	uxtb	r4, r4
   2447a:	4284      	cmp	r4, r0
   2447c:	d0f5      	beq.n	2446a <chan_sel_remap+0x8>
			if (bite & 0x01) {
   2447e:	f015 0f01 	tst.w	r5, #1
   24482:	d003      	beq.n	2448c <chan_sel_remap+0x2a>
				if (chan_index == 0U) {
   24484:	2900      	cmp	r1, #0
   24486:	d0f2      	beq.n	2446e <chan_sel_remap+0xc>
				chan_index--;
   24488:	3901      	subs	r1, #1
   2448a:	b2c9      	uxtb	r1, r1
			chan_next++;
   2448c:	3001      	adds	r0, #1
   2448e:	b2c0      	uxtb	r0, r0
			bite >>= 1;
   24490:	086d      	lsrs	r5, r5, #1
   24492:	e7f2      	b.n	2447a <chan_sel_remap+0x18>

00024494 <lll_chan_sel_1>:
{
   24494:	b430      	push	{r4, r5}
	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
   24496:	fb02 1101 	mla	r1, r2, r1, r1
   2449a:	7802      	ldrb	r2, [r0, #0]
{
   2449c:	f89d 5008 	ldrb.w	r5, [sp, #8]
	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
   244a0:	4411      	add	r1, r2
   244a2:	2425      	movs	r4, #37	; 0x25
   244a4:	fbb1 f2f4 	udiv	r2, r1, r4
   244a8:	fb04 1212 	mls	r2, r4, r2, r1
   244ac:	b2d1      	uxtb	r1, r2
	*chan_use = chan_next;
   244ae:	7001      	strb	r1, [r0, #0]
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
   244b0:	08c8      	lsrs	r0, r1, #3
   244b2:	f002 0207 	and.w	r2, r2, #7
   244b6:	5c1c      	ldrb	r4, [r3, r0]
   244b8:	fa44 f202 	asr.w	r2, r4, r2
   244bc:	07d2      	lsls	r2, r2, #31
   244be:	d408      	bmi.n	244d2 <lll_chan_sel_1+0x3e>
		chan_index = chan_next % chan_count;
   244c0:	fbb1 f2f5 	udiv	r2, r1, r5
   244c4:	fb05 1112 	mls	r1, r5, r2, r1
		chan_next = chan_sel_remap(chan_map, chan_index);
   244c8:	b2c9      	uxtb	r1, r1
   244ca:	4618      	mov	r0, r3
}
   244cc:	bc30      	pop	{r4, r5}
		chan_next = chan_sel_remap(chan_map, chan_index);
   244ce:	f7ff bfc8 	b.w	24462 <chan_sel_remap>
}
   244d2:	4608      	mov	r0, r1
   244d4:	bc30      	pop	{r4, r5}
   244d6:	4770      	bx	lr

000244d8 <clock_control_on>:
	return api->on(dev, sys);
   244d8:	6843      	ldr	r3, [r0, #4]
   244da:	681b      	ldr	r3, [r3, #0]
   244dc:	4718      	bx	r3

000244de <swi_lll_nrf5_isr>:
	mayfly_run(TICKER_USER_ID_LLL);
   244de:	2000      	movs	r0, #0
   244e0:	f7ec b8f8 	b.w	106d4 <mayfly_run>

000244e4 <radio_nrf5_isr>:
ISR_DIRECT_DECLARE(radio_nrf5_isr)
   244e4:	4668      	mov	r0, sp
   244e6:	f020 0107 	bic.w	r1, r0, #7
   244ea:	468d      	mov	sp, r1
   244ec:	b501      	push	{r0, lr}
	isr_radio();
   244ee:	f7f4 f8b3 	bl	18658 <isr_radio>
	ISR_DIRECT_PM();
   244f2:	f7e2 fb4f 	bl	6b94 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING
	sys_trace_isr_exit();
#endif
	if (maybe_swap) {
		z_arm_int_exit();
   244f6:	f7e2 faa1 	bl	6a3c <z_arm_exc_exit>
ISR_DIRECT_DECLARE(radio_nrf5_isr)
   244fa:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   244fe:	4685      	mov	sp, r0
   24500:	4770      	bx	lr

00024502 <lll_reset>:
}
   24502:	2000      	movs	r0, #0
   24504:	4770      	bx	lr

00024506 <lll_prepare>:
{
   24506:	b513      	push	{r0, r1, r4, lr}
	return prepare(is_abort_cb, abort_cb, prepare_cb, prio, prepare_param,
   24508:	2400      	movs	r4, #0
   2450a:	9401      	str	r4, [sp, #4]
   2450c:	9c04      	ldr	r4, [sp, #16]
   2450e:	9400      	str	r4, [sp, #0]
   24510:	f7ef f826 	bl	13560 <prepare>
}
   24514:	b002      	add	sp, #8
   24516:	bd10      	pop	{r4, pc}

00024518 <lll_prepare_done>:
}
   24518:	2000      	movs	r0, #0
   2451a:	4770      	bx	lr

0002451c <lll_evt_offset_get>:
	} else if (evt->ticks_xtal_to_start & XON_BITMASK) {
   2451c:	e9d0 2300 	ldrd	r2, r3, [r0]
   24520:	2a00      	cmp	r2, #0
   24522:	da04      	bge.n	2452e <lll_evt_offset_get+0x12>
		return MAX(evt->ticks_active_to_start,
   24524:	6880      	ldr	r0, [r0, #8]
   24526:	4298      	cmp	r0, r3
   24528:	bf38      	it	cc
   2452a:	4618      	movcc	r0, r3
   2452c:	4770      	bx	lr
		return MAX(evt->ticks_active_to_start,
   2452e:	429a      	cmp	r2, r3
   24530:	bf38      	it	cc
   24532:	461a      	movcc	r2, r3
   24534:	4610      	mov	r0, r2
}
   24536:	4770      	bx	lr

00024538 <lll_preempt_calc>:
{
   24538:	b510      	push	{r4, lr}
   2453a:	4614      	mov	r4, r2
	u32_t ticks_now = ticker_ticks_now_get();
   2453c:	f7ff fee4 	bl	24308 <ticker_ticks_now_get>
	diff = ticker_ticks_diff_get(ticks_now, ticks_at_event);
   24540:	4621      	mov	r1, r4
   24542:	f7ff fee3 	bl	2430c <ticker_ticks_diff_get>
	diff += HAL_TICKER_CNTR_CMP_OFFSET_MIN;
   24546:	3003      	adds	r0, #3
	if (!(diff & BIT(HAL_TICKER_CNTR_MSBIT)) &&
   24548:	0203      	lsls	r3, r0, #8
   2454a:	d404      	bmi.n	24556 <lll_preempt_calc+0x1e>
   2454c:	2809      	cmp	r0, #9
   2454e:	bf94      	ite	ls
   24550:	2000      	movls	r0, #0
   24552:	2001      	movhi	r0, #1
}
   24554:	bd10      	pop	{r4, pc}
	return 0;
   24556:	2000      	movs	r0, #0
   24558:	e7fc      	b.n	24554 <lll_preempt_calc+0x1c>

0002455a <ull_adv_init>:
}
   2455a:	2000      	movs	r0, #0
   2455c:	4770      	bx	lr

0002455e <ull_adv_reset>:
{
   2455e:	b508      	push	{r3, lr}
		(void)disable(handle);
   24560:	f7ef fd8a 	bl	14078 <disable.constprop.5>
}
   24564:	2000      	movs	r0, #0
   24566:	bd08      	pop	{r3, pc}

00024568 <ull_adv_is_enabled>:
{
   24568:	b508      	push	{r3, lr}
	adv = ull_adv_is_enabled_get(handle);
   2456a:	f7ef fd77 	bl	1405c <ull_adv_is_enabled_get>
}
   2456e:	3000      	adds	r0, #0
   24570:	bf18      	it	ne
   24572:	2001      	movne	r0, #1
   24574:	bd08      	pop	{r3, pc}

00024576 <ull_adv_filter_pol_get>:
{
   24576:	b508      	push	{r3, lr}
	adv = ull_adv_is_enabled_get(handle);
   24578:	f7ef fd70 	bl	1405c <ull_adv_is_enabled_get>
	if (!adv) {
   2457c:	b118      	cbz	r0, 24586 <ull_adv_filter_pol_get+0x10>
	return adv->lll.filter_policy;
   2457e:	f890 0029 	ldrb.w	r0, [r0, #41]	; 0x29
   24582:	f000 0003 	and.w	r0, r0, #3
}
   24586:	bd08      	pop	{r3, pc}

00024588 <isr_race>:
	radio_status_reset();
   24588:	f7f4 b950 	b.w	1882c <radio_status_reset>

0002458c <isr_abort>:
{
   2458c:	b510      	push	{r4, lr}
   2458e:	4604      	mov	r4, r0
	radio_status_reset();
   24590:	f7f4 f94c 	bl	1882c <radio_status_reset>
	radio_tmr_status_reset();
   24594:	f7f4 fa08 	bl	189a8 <radio_tmr_status_reset>
	radio_filter_status_reset();
   24598:	f7f4 f9e2 	bl	18960 <radio_filter_status_reset>
	radio_ar_status_reset();
   2459c:	f7f4 fba2 	bl	18ce4 <radio_ar_status_reset>
	radio_rssi_status_reset();
   245a0:	f7f4 f9a6 	bl	188f0 <radio_rssi_status_reset>
	radio_filter_disable();
   245a4:	f7f4 f9d2 	bl	1894c <radio_filter_disable>
	isr_cleanup(param);
   245a8:	4620      	mov	r0, r4
}
   245aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   245ae:	f7ef bdf5 	b.w	1419c <isr_cleanup>

000245b2 <isr_rx_ci_adva_check>:
		       BDADDR_SIZE);
}

static inline bool isr_rx_ci_adva_check(struct pdu_adv *adv,
					struct pdu_adv *ci)
{
   245b2:	b570      	push	{r4, r5, r6, lr}
	return (adv->tx_addr == ci->rx_addr) &&
   245b4:	7804      	ldrb	r4, [r0, #0]
   245b6:	780a      	ldrb	r2, [r1, #0]
   245b8:	f3c4 1380 	ubfx	r3, r4, #6, #1
   245bc:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
   245c0:	d119      	bne.n	245f6 <isr_rx_ci_adva_check+0x44>
   245c2:	f004 040f 	and.w	r4, r4, #15
   245c6:	2c01      	cmp	r4, #1
   245c8:	f100 0502 	add.w	r5, r0, #2
   245cc:	f101 0608 	add.w	r6, r1, #8
   245d0:	d008      	beq.n	245e4 <isr_rx_ci_adva_check+0x32>
		(((adv->type == PDU_ADV_TYPE_DIRECT_IND) &&
		 !memcmp(adv->direct_ind.adv_addr, ci->connect_ind.adv_addr,
			 BDADDR_SIZE)) ||
		 (!memcmp(adv->adv_ind.addr, ci->connect_ind.adv_addr,
   245d2:	2206      	movs	r2, #6
   245d4:	4631      	mov	r1, r6
   245d6:	4628      	mov	r0, r5
   245d8:	f7dd fafa 	bl	1bd0 <memcmp>
			 BDADDR_SIZE)) ||
   245dc:	fab0 f080 	clz	r0, r0
   245e0:	0940      	lsrs	r0, r0, #5
			  BDADDR_SIZE)));
}
   245e2:	bd70      	pop	{r4, r5, r6, pc}
		 !memcmp(adv->direct_ind.adv_addr, ci->connect_ind.adv_addr,
   245e4:	2206      	movs	r2, #6
   245e6:	4631      	mov	r1, r6
   245e8:	4628      	mov	r0, r5
   245ea:	f7dd faf1 	bl	1bd0 <memcmp>
		(((adv->type == PDU_ADV_TYPE_DIRECT_IND) &&
   245ee:	2800      	cmp	r0, #0
   245f0:	d1ef      	bne.n	245d2 <isr_rx_ci_adva_check+0x20>
	return (adv->tx_addr == ci->rx_addr) &&
   245f2:	4620      	mov	r0, r4
   245f4:	e7f5      	b.n	245e2 <isr_rx_ci_adva_check+0x30>
   245f6:	2000      	movs	r0, #0
   245f8:	e7f3      	b.n	245e2 <isr_rx_ci_adva_check+0x30>

000245fa <resume_prepare_cb>:
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
   245fa:	68c3      	ldr	r3, [r0, #12]
{
   245fc:	b570      	push	{r4, r5, r6, lr}
   245fe:	4604      	mov	r4, r0
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
   24600:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
   24602:	f7ff fe81 	bl	24308 <ticker_ticks_now_get>
   24606:	4605      	mov	r5, r0
   24608:	4630      	mov	r0, r6
   2460a:	f7ff ff87 	bl	2451c <lll_evt_offset_get>
	p->remainder = 0;
   2460e:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
   24610:	1a28      	subs	r0, r5, r0
   24612:	6020      	str	r0, [r4, #0]
	p->remainder = 0;
   24614:	6063      	str	r3, [r4, #4]
	p->lazy = 0;
   24616:	8123      	strh	r3, [r4, #8]
	return prepare_cb(p);
   24618:	4620      	mov	r0, r4
}
   2461a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return prepare_cb(p);
   2461e:	f7f0 b889 	b.w	14734 <prepare_cb>

00024622 <isr_done>:
{
   24622:	b510      	push	{r4, lr}
   24624:	4604      	mov	r4, r0
	radio_status_reset();
   24626:	f7f4 f901 	bl	1882c <radio_status_reset>
	radio_tmr_status_reset();
   2462a:	f7f4 f9bd 	bl	189a8 <radio_tmr_status_reset>
	radio_filter_status_reset();
   2462e:	f7f4 f997 	bl	18960 <radio_filter_status_reset>
	radio_ar_status_reset();
   24632:	f7f4 fb57 	bl	18ce4 <radio_ar_status_reset>
	radio_rssi_status_reset();
   24636:	f7f4 f95b 	bl	188f0 <radio_rssi_status_reset>
	if (!IS_ENABLED(CONFIG_BT_CTLR_LOW_LAT) && lll->is_hdcd &&
   2463a:	7b23      	ldrb	r3, [r4, #12]
   2463c:	f003 0271 	and.w	r2, r3, #113	; 0x71
   24640:	2a01      	cmp	r2, #1
		lll->chan_map_curr = lll->chan_map;
   24642:	bf02      	ittt	eq
   24644:	f3c3 0242 	ubfxeq	r2, r3, #1, #3
   24648:	f362 1306 	bfieq	r3, r2, #4, #3
   2464c:	7323      	strbeq	r3, [r4, #12]
	if (lll->chan_map_curr) {
   2464e:	7b23      	ldrb	r3, [r4, #12]
   24650:	f013 0f70 	tst.w	r3, #112	; 0x70
   24654:	d008      	beq.n	24668 <isr_done+0x46>
		chan_prepare(lll);
   24656:	4620      	mov	r0, r4
   24658:	f7ef ffea 	bl	14630 <chan_prepare>
		radio_tx_enable();
   2465c:	f7f4 f8ce 	bl	187fc <radio_tx_enable>
}
   24660:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_tmr_end_capture();
   24664:	f7f4 ba76 	b.w	18b54 <radio_tmr_end_capture>
	radio_filter_disable();
   24668:	f7f4 f970 	bl	1894c <radio_filter_disable>
	isr_cleanup(param);
   2466c:	4620      	mov	r0, r4
}
   2466e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   24672:	f7ef bd93 	b.w	1419c <isr_cleanup>

00024676 <lll_adv_init>:
}
   24676:	2000      	movs	r0, #0
   24678:	4770      	bx	lr

0002467a <lll_adv_reset>:
   2467a:	2000      	movs	r0, #0
   2467c:	4770      	bx	lr

0002467e <tx_ull_dequeue>:
{
   2467e:	4603      	mov	r3, r0
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
   24680:	e9d0 206c 	ldrd	r2, r0, [r0, #432]	; 0x1b0
{
   24684:	b510      	push	{r4, lr}
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
   24686:	b978      	cbnz	r0, 246a8 <tx_ull_dequeue+0x2a>
   24688:	f8d3 01bc 	ldr.w	r0, [r3, #444]	; 0x1bc
   2468c:	4290      	cmp	r0, r2
   2468e:	d00b      	beq.n	246a8 <tx_ull_dequeue+0x2a>
		if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   24690:	7910      	ldrb	r0, [r2, #4]
   24692:	f000 0003 	and.w	r0, r0, #3
   24696:	2803      	cmp	r0, #3
   24698:	d104      	bne.n	246a4 <tx_ull_dequeue+0x26>
		    ((pdu_data_tx->llctrl.opcode !=
   2469a:	79d0      	ldrb	r0, [r2, #7]
		if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   2469c:	2803      	cmp	r0, #3
   2469e:	d003      	beq.n	246a8 <tx_ull_dequeue+0x2a>
		      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   246a0:	280a      	cmp	r0, #10
   246a2:	d001      	beq.n	246a8 <tx_ull_dequeue+0x2a>
			conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   246a4:	e9c3 226d 	strd	r2, r2, [r3, #436]	; 0x1b4
	if (conn->tx_head == conn->tx_ctrl) {
   246a8:	f8d3 41b4 	ldr.w	r4, [r3, #436]	; 0x1b4
   246ac:	6810      	ldr	r0, [r2, #0]
   246ae:	4294      	cmp	r4, r2
   246b0:	d10d      	bne.n	246ce <tx_ull_dequeue+0x50>
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
   246b2:	f8d3 41b8 	ldr.w	r4, [r3, #440]	; 0x1b8
		conn->tx_head = conn->tx_head->next;
   246b6:	f8c3 01b0 	str.w	r0, [r3, #432]	; 0x1b0
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
   246ba:	42a2      	cmp	r2, r4
			conn->tx_ctrl = NULL;
   246bc:	bf06      	itte	eq
   246be:	2200      	moveq	r2, #0
			conn->tx_ctrl_last = NULL;
   246c0:	e9c3 226d 	strdeq	r2, r2, [r3, #436]	; 0x1b4
			conn->tx_ctrl = conn->tx_head;
   246c4:	f8c3 01b4 	strne.w	r0, [r3, #436]	; 0x1b4
		tx->next = tx;
   246c8:	6009      	str	r1, [r1, #0]
}
   246ca:	4608      	mov	r0, r1
   246cc:	bd10      	pop	{r4, pc}
		if (conn->tx_head == conn->tx_data) {
   246ce:	f8d3 41bc 	ldr.w	r4, [r3, #444]	; 0x1bc
		conn->tx_head = conn->tx_head->next;
   246d2:	f8c3 01b0 	str.w	r0, [r3, #432]	; 0x1b0
		if (conn->tx_head == conn->tx_data) {
   246d6:	4294      	cmp	r4, r2
			conn->tx_data = conn->tx_data->next;
   246d8:	bf08      	it	eq
   246da:	f8c3 01bc 	streq.w	r0, [r3, #444]	; 0x1bc
		tx->next = NULL;
   246de:	2300      	movs	r3, #0
   246e0:	600b      	str	r3, [r1, #0]
   246e2:	e7f2      	b.n	246ca <tx_ull_dequeue+0x4c>

000246e4 <ctrl_tx_sec_enqueue>:
	if (conn->llcp_enc.pause_tx) {
   246e4:	f890 2152 	ldrb.w	r2, [r0, #338]	; 0x152
   246e8:	f012 0202 	ands.w	r2, r2, #2
{
   246ec:	b430      	push	{r4, r5}
	if (conn->llcp_enc.pause_tx) {
   246ee:	d013      	beq.n	24718 <ctrl_tx_sec_enqueue+0x34>
		if (!conn->tx_ctrl) {
   246f0:	f8d0 31b4 	ldr.w	r3, [r0, #436]	; 0x1b4
   246f4:	b953      	cbnz	r3, 2470c <ctrl_tx_sec_enqueue+0x28>
			tx->next = conn->tx_head;
   246f6:	f8d0 31b0 	ldr.w	r3, [r0, #432]	; 0x1b0
   246fa:	600b      	str	r3, [r1, #0]
			conn->tx_head = tx;
   246fc:	f8c0 11b0 	str.w	r1, [r0, #432]	; 0x1b0
		if (!tx->next) {
   24700:	680b      	ldr	r3, [r1, #0]
   24702:	b90b      	cbnz	r3, 24708 <ctrl_tx_sec_enqueue+0x24>
			conn->tx_data_last = tx;
   24704:	f8c0 11c0 	str.w	r1, [r0, #448]	; 0x1c0
}
   24708:	bc30      	pop	{r4, r5}
   2470a:	4770      	bx	lr
			tx->next = conn->tx_ctrl_last->next;
   2470c:	f8d0 31b8 	ldr.w	r3, [r0, #440]	; 0x1b8
   24710:	681a      	ldr	r2, [r3, #0]
   24712:	600a      	str	r2, [r1, #0]
			conn->tx_ctrl_last->next = tx;
   24714:	6019      	str	r1, [r3, #0]
   24716:	e7f3      	b.n	24700 <ctrl_tx_sec_enqueue+0x1c>
		if (conn->tx_head) {
   24718:	f8d0 31b0 	ldr.w	r3, [r0, #432]	; 0x1b0
   2471c:	b1c3      	cbz	r3, 24750 <ctrl_tx_sec_enqueue+0x6c>
			if ((conn->llcp_req != conn->llcp_ack) &&
   2471e:	f890 50e8 	ldrb.w	r5, [r0, #232]	; 0xe8
   24722:	f890 40e9 	ldrb.w	r4, [r0, #233]	; 0xe9
   24726:	42a5      	cmp	r5, r4
   24728:	d00f      	beq.n	2474a <ctrl_tx_sec_enqueue+0x66>
   2472a:	f890 40ea 	ldrb.w	r4, [r0, #234]	; 0xea
   2472e:	2c03      	cmp	r4, #3
   24730:	d10b      	bne.n	2474a <ctrl_tx_sec_enqueue+0x66>
			    (pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
   24732:	791c      	ldrb	r4, [r3, #4]
			    (conn->llcp_type == LLCP_ENCRYPTION) &&
   24734:	f004 0403 	and.w	r4, r4, #3
   24738:	2c03      	cmp	r4, #3
   2473a:	d106      	bne.n	2474a <ctrl_tx_sec_enqueue+0x66>
			    ((pdu_data_tx->llctrl.opcode ==
   2473c:	79da      	ldrb	r2, [r3, #7]
			    (pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
   2473e:	2a03      	cmp	r2, #3
   24740:	d008      	beq.n	24754 <ctrl_tx_sec_enqueue+0x70>
			      PDU_DATA_LLCTRL_TYPE_ENC_REQ) ||
   24742:	f1a2 030a 	sub.w	r3, r2, #10
   24746:	425a      	negs	r2, r3
   24748:	415a      	adcs	r2, r3
}
   2474a:	bc30      	pop	{r4, r5}
		ctrl_tx_pause_enqueue(conn, tx, pause);
   2474c:	f7f0 baae 	b.w	14cac <ctrl_tx_pause_enqueue>
	bool pause = false;
   24750:	461a      	mov	r2, r3
   24752:	e7fa      	b.n	2474a <ctrl_tx_sec_enqueue+0x66>
				pause = true;
   24754:	2201      	movs	r2, #1
   24756:	e7f8      	b.n	2474a <ctrl_tx_sec_enqueue+0x66>

00024758 <ctrl_tx_enqueue>:
	ctrl_tx_pause_enqueue(conn, tx, false);
   24758:	2200      	movs	r2, #0
   2475a:	f7f0 baa7 	b.w	14cac <ctrl_tx_pause_enqueue>

0002475e <start_enc_rsp_send>:
	conn->lll.enc_tx = 1;
   2475e:	f890 307e 	ldrb.w	r3, [r0, #126]	; 0x7e
   24762:	f043 0310 	orr.w	r3, r3, #16
   24766:	f880 307e 	strb.w	r3, [r0, #126]	; 0x7e
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   2476a:	780b      	ldrb	r3, [r1, #0]
   2476c:	f043 0303 	orr.w	r3, r3, #3
   24770:	700b      	strb	r3, [r1, #0]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
   24772:	2301      	movs	r3, #1
   24774:	704b      	strb	r3, [r1, #1]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_RSP;
   24776:	2306      	movs	r3, #6
   24778:	70cb      	strb	r3, [r1, #3]
}
   2477a:	2000      	movs	r0, #0
   2477c:	4770      	bx	lr

0002477e <ll_connected_get>:
{
   2477e:	b508      	push	{r3, lr}
	if (handle >= CONFIG_BT_MAX_CONN) {
   24780:	b918      	cbnz	r0, 2478a <ll_connected_get+0xc>
	conn = ll_conn_get(handle);
   24782:	f7f0 fb55 	bl	14e30 <ll_conn_get>
	if (conn->lll.handle != handle) {
   24786:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
   24788:	b103      	cbz	r3, 2478c <ll_connected_get+0xe>
		return NULL;
   2478a:	2000      	movs	r0, #0
}
   2478c:	bd08      	pop	{r3, pc}

0002478e <ll_conn_update>:
{
   2478e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   24792:	460d      	mov	r5, r1
   24794:	4690      	mov	r8, r2
   24796:	469a      	mov	sl, r3
   24798:	f8bd 9020 	ldrh.w	r9, [sp, #32]
   2479c:	f8bd 7024 	ldrh.w	r7, [sp, #36]	; 0x24
   247a0:	f8bd 6028 	ldrh.w	r6, [sp, #40]	; 0x28
	conn = ll_connected_get(handle);
   247a4:	f7ff ffeb 	bl	2477e <ll_connected_get>
	if (!conn) {
   247a8:	4604      	mov	r4, r0
   247aa:	2800      	cmp	r0, #0
   247ac:	d065      	beq.n	2487a <ll_conn_update+0xec>
	if (!cmd) {
   247ae:	bb7d      	cbnz	r5, 24810 <ll_conn_update+0x82>
		if (!conn->llcp_conn_param.disabled &&
   247b0:	f890 3172 	ldrb.w	r3, [r0, #370]	; 0x172
   247b4:	06da      	lsls	r2, r3, #27
   247b6:	d408      	bmi.n	247ca <ll_conn_update+0x3c>
		    (!conn->common.fex_valid ||
   247b8:	f890 10dc 	ldrb.w	r1, [r0, #220]	; 0xdc
		if (!conn->llcp_conn_param.disabled &&
   247bc:	f011 0101 	ands.w	r1, r1, #1
   247c0:	d041      	beq.n	24846 <ll_conn_update+0xb8>
		     (conn->llcp_feature.features &
   247c2:	f8d0 311c 	ldr.w	r3, [r0, #284]	; 0x11c
		    (!conn->common.fex_valid ||
   247c6:	079b      	lsls	r3, r3, #30
   247c8:	d423      	bmi.n	24812 <ll_conn_update+0x84>
		} else if (conn->lll.role) {
   247ca:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   247ce:	2b00      	cmp	r3, #0
   247d0:	db51      	blt.n	24876 <ll_conn_update+0xe8>
		if (conn->llcp_cu.req != conn->llcp_cu.ack) {
   247d2:	f894 3104 	ldrb.w	r3, [r4, #260]	; 0x104
   247d6:	f894 2105 	ldrb.w	r2, [r4, #261]	; 0x105
   247da:	429a      	cmp	r2, r3
   247dc:	d14d      	bne.n	2487a <ll_conn_update+0xec>
		conn->llcp_cu.win_size = 1U;
   247de:	2301      	movs	r3, #1
   247e0:	f884 3114 	strb.w	r3, [r4, #276]	; 0x114
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   247e4:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
		conn->llcp_cu.interval = interval_max;
   247e8:	f8a4 9108 	strh.w	r9, [r4, #264]	; 0x108
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   247ec:	f023 0307 	bic.w	r3, r3, #7
		conn->llcp_cu.win_offset_us = 0U;
   247f0:	2000      	movs	r0, #0
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   247f2:	f043 0305 	orr.w	r3, r3, #5
		conn->llcp_cu.req++;
   247f6:	3201      	adds	r2, #1
		conn->llcp_cu.win_offset_us = 0U;
   247f8:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
		conn->llcp_cu.latency = latency;
   247fc:	f8a4 710a 	strh.w	r7, [r4, #266]	; 0x10a
		conn->llcp_cu.timeout = timeout;
   24800:	f8a4 610c 	strh.w	r6, [r4, #268]	; 0x10c
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   24804:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
		conn->llcp_cu.req++;
   24808:	f884 2104 	strb.w	r2, [r4, #260]	; 0x104
}
   2480c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   24810:	4629      	mov	r1, r5
		cmd--;
   24812:	1e48      	subs	r0, r1, #1
		if (cmd) {
   24814:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
   24818:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
   2481c:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
   24820:	d013      	beq.n	2484a <ll_conn_update+0xbc>
			if ((conn->llcp_conn_param.req ==
   24822:	4293      	cmp	r3, r2
   24824:	d029      	beq.n	2487a <ll_conn_update+0xec>
			    (conn->llcp_conn_param.state !=
   24826:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
			     conn->llcp_conn_param.ack) ||
   2482a:	f003 0207 	and.w	r2, r3, #7
   2482e:	2a03      	cmp	r2, #3
   24830:	d123      	bne.n	2487a <ll_conn_update+0xec>
			conn->llcp_conn_param.state = cmd;
   24832:	f360 0302 	bfi	r3, r0, #0, #3
			conn->llcp_conn_param.cmd = 1U;
   24836:	f043 0308 	orr.w	r3, r3, #8
			conn->llcp_conn_param.status = status;
   2483a:	f884 8173 	strb.w	r8, [r4, #371]	; 0x173
			conn->llcp_conn_param.cmd = 1U;
   2483e:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
	return 0;
   24842:	2000      	movs	r0, #0
   24844:	e7e2      	b.n	2480c <ll_conn_update+0x7e>
			cmd++;
   24846:	2101      	movs	r1, #1
   24848:	e7e3      	b.n	24812 <ll_conn_update+0x84>
			if (conn->llcp_conn_param.req !=
   2484a:	4293      	cmp	r3, r2
   2484c:	d115      	bne.n	2487a <ll_conn_update+0xec>
			conn->llcp_conn_param.state = cmd;
   2484e:	f8b4 2172 	ldrh.w	r2, [r4, #370]	; 0x172
			conn->llcp_conn_param.interval_min = interval_min;
   24852:	f8a4 a174 	strh.w	sl, [r4, #372]	; 0x174
			conn->llcp_conn_param.state = cmd;
   24856:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
   2485a:	f042 0208 	orr.w	r2, r2, #8
			conn->llcp_conn_param.req++;
   2485e:	3301      	adds	r3, #1
			conn->llcp_conn_param.interval_max = interval_max;
   24860:	f8a4 9176 	strh.w	r9, [r4, #374]	; 0x176
			conn->llcp_conn_param.latency = latency;
   24864:	f8a4 7178 	strh.w	r7, [r4, #376]	; 0x178
			conn->llcp_conn_param.timeout = timeout;
   24868:	f8a4 617a 	strh.w	r6, [r4, #378]	; 0x17a
			conn->llcp_conn_param.state = cmd;
   2486c:	f8a4 2172 	strh.w	r2, [r4, #370]	; 0x172
			conn->llcp_conn_param.req++;
   24870:	f884 3170 	strb.w	r3, [r4, #368]	; 0x170
   24874:	e7ca      	b.n	2480c <ll_conn_update+0x7e>
			return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
   24876:	201a      	movs	r0, #26
   24878:	e7c8      	b.n	2480c <ll_conn_update+0x7e>
		return BT_HCI_ERR_CMD_DISALLOWED;
   2487a:	200c      	movs	r0, #12
   2487c:	e7c6      	b.n	2480c <ll_conn_update+0x7e>

0002487e <ll_chm_get>:
{
   2487e:	b538      	push	{r3, r4, r5, lr}
   24880:	460c      	mov	r4, r1
	conn = ll_connected_get(handle);
   24882:	f7ff ff7c 	bl	2477e <ll_connected_get>
	if (!conn) {
   24886:	4603      	mov	r3, r0
   24888:	b168      	cbz	r0, 248a6 <ll_chm_get+0x28>
		conn->chm_updated = 0U;
   2488a:	2500      	movs	r5, #0
   2488c:	f100 0238 	add.w	r2, r0, #56	; 0x38
   24890:	f883 51c4 	strb.w	r5, [r3, #452]	; 0x1c4
   24894:	6811      	ldr	r1, [r2, #0]
   24896:	6021      	str	r1, [r4, #0]
   24898:	7911      	ldrb	r1, [r2, #4]
   2489a:	7121      	strb	r1, [r4, #4]
	} while (conn->chm_updated);
   2489c:	f893 01c4 	ldrb.w	r0, [r3, #452]	; 0x1c4
   248a0:	2800      	cmp	r0, #0
   248a2:	d1f5      	bne.n	24890 <ll_chm_get+0x12>
}
   248a4:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   248a6:	200c      	movs	r0, #12
   248a8:	e7fc      	b.n	248a4 <ll_chm_get+0x26>

000248aa <ll_terminate_ind_send>:
{
   248aa:	b510      	push	{r4, lr}
   248ac:	460c      	mov	r4, r1
	conn = ll_connected_get(handle);
   248ae:	f7ff ff66 	bl	2477e <ll_connected_get>
	if (!conn) {
   248b2:	b140      	cbz	r0, 248c6 <ll_terminate_ind_send+0x1c>
	conn->llcp_terminate.req++;
   248b4:	f890 3128 	ldrb.w	r3, [r0, #296]	; 0x128
	conn->llcp_terminate.reason_own = reason;
   248b8:	f880 412a 	strb.w	r4, [r0, #298]	; 0x12a
	conn->llcp_terminate.req++;
   248bc:	3301      	adds	r3, #1
   248be:	f880 3128 	strb.w	r3, [r0, #296]	; 0x128
	return 0;
   248c2:	2000      	movs	r0, #0
}
   248c4:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   248c6:	200c      	movs	r0, #12
   248c8:	e7fc      	b.n	248c4 <ll_terminate_ind_send+0x1a>

000248ca <ll_feature_req_send>:
{
   248ca:	b508      	push	{r3, lr}
	conn = ll_connected_get(handle);
   248cc:	f7ff ff57 	bl	2477e <ll_connected_get>
	if (!conn) {
   248d0:	b150      	cbz	r0, 248e8 <ll_feature_req_send+0x1e>
	if (conn->llcp_feature.req != conn->llcp_feature.ack) {
   248d2:	f890 2118 	ldrb.w	r2, [r0, #280]	; 0x118
   248d6:	f890 3119 	ldrb.w	r3, [r0, #281]	; 0x119
   248da:	4293      	cmp	r3, r2
   248dc:	d104      	bne.n	248e8 <ll_feature_req_send+0x1e>
	conn->llcp_feature.req++;
   248de:	3301      	adds	r3, #1
   248e0:	f880 3118 	strb.w	r3, [r0, #280]	; 0x118
	return 0;
   248e4:	2000      	movs	r0, #0
}
   248e6:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   248e8:	200c      	movs	r0, #12
   248ea:	e7fc      	b.n	248e6 <ll_feature_req_send+0x1c>

000248ec <ll_version_ind_send>:
{
   248ec:	b508      	push	{r3, lr}
	conn = ll_connected_get(handle);
   248ee:	f7ff ff46 	bl	2477e <ll_connected_get>
	if (!conn) {
   248f2:	b150      	cbz	r0, 2490a <ll_version_ind_send+0x1e>
	if (conn->llcp_version.req != conn->llcp_version.ack) {
   248f4:	f890 2120 	ldrb.w	r2, [r0, #288]	; 0x120
   248f8:	f890 3121 	ldrb.w	r3, [r0, #289]	; 0x121
   248fc:	4293      	cmp	r3, r2
   248fe:	d104      	bne.n	2490a <ll_version_ind_send+0x1e>
	conn->llcp_version.req++;
   24900:	3301      	adds	r3, #1
   24902:	f880 3120 	strb.w	r3, [r0, #288]	; 0x120
	return 0;
   24906:	2000      	movs	r0, #0
}
   24908:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   2490a:	200c      	movs	r0, #12
   2490c:	e7fc      	b.n	24908 <ll_version_ind_send+0x1c>

0002490e <ll_length_req_send>:
{
   2490e:	b570      	push	{r4, r5, r6, lr}
   24910:	460e      	mov	r6, r1
   24912:	4615      	mov	r5, r2
	conn = ll_connected_get(handle);
   24914:	f7ff ff33 	bl	2477e <ll_connected_get>
	if (!conn) {
   24918:	b340      	cbz	r0, 2496c <ll_length_req_send+0x5e>
	if (conn->llcp_length.req != conn->llcp_length.ack) {
   2491a:	f890 2198 	ldrb.w	r2, [r0, #408]	; 0x198
   2491e:	f890 3199 	ldrb.w	r3, [r0, #409]	; 0x199
   24922:	4293      	cmp	r3, r2
   24924:	d014      	beq.n	24950 <ll_length_req_send+0x42>
		switch (conn->llcp_length.state) {
   24926:	f890 319a 	ldrb.w	r3, [r0, #410]	; 0x19a
   2492a:	f003 0307 	and.w	r3, r3, #7
   2492e:	2b07      	cmp	r3, #7
   24930:	d01e      	beq.n	24970 <ll_length_req_send+0x62>
   24932:	2401      	movs	r4, #1
   24934:	fa04 f303 	lsl.w	r3, r4, r3
   24938:	f013 0f68 	tst.w	r3, #104	; 0x68
   2493c:	d018      	beq.n	24970 <ll_length_req_send+0x62>
			if (!conn->llcp_length.cache.tx_octets) {
   2493e:	f8b0 31a4 	ldrh.w	r3, [r0, #420]	; 0x1a4
   24942:	b9ab      	cbnz	r3, 24970 <ll_length_req_send+0x62>
				conn->llcp_length.cache.tx_octets = tx_octets;
   24944:	f8a0 61a4 	strh.w	r6, [r0, #420]	; 0x1a4
				conn->llcp_length.cache.tx_time = tx_time;
   24948:	f8a0 51a6 	strh.w	r5, [r0, #422]	; 0x1a6
	return 0;
   2494c:	2000      	movs	r0, #0
}
   2494e:	bd70      	pop	{r4, r5, r6, pc}
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   24950:	f890 219a 	ldrb.w	r2, [r0, #410]	; 0x19a
	conn->llcp_length.tx_octets = tx_octets;
   24954:	f8a0 619e 	strh.w	r6, [r0, #414]	; 0x19e
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   24958:	f36f 0202 	bfc	r2, #0, #3
	conn->llcp_length.req++;
   2495c:	3301      	adds	r3, #1
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   2495e:	f880 219a 	strb.w	r2, [r0, #410]	; 0x19a
	conn->llcp_length.tx_time = tx_time;
   24962:	f8a0 51a2 	strh.w	r5, [r0, #418]	; 0x1a2
	conn->llcp_length.req++;
   24966:	f880 3198 	strb.w	r3, [r0, #408]	; 0x198
   2496a:	e7ef      	b.n	2494c <ll_length_req_send+0x3e>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   2496c:	2002      	movs	r0, #2
   2496e:	e7ee      	b.n	2494e <ll_length_req_send+0x40>
			return BT_HCI_ERR_CMD_DISALLOWED;
   24970:	200c      	movs	r0, #12
   24972:	e7ec      	b.n	2494e <ll_length_req_send+0x40>

00024974 <ll_length_max_get>:
{
   24974:	b510      	push	{r4, lr}
	*max_tx_octets = LL_LENGTH_OCTETS_RX_MAX;
   24976:	241b      	movs	r4, #27
   24978:	8004      	strh	r4, [r0, #0]
	*max_rx_octets = LL_LENGTH_OCTETS_RX_MAX;
   2497a:	8014      	strh	r4, [r2, #0]
	*max_tx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, BIT(2));
   2497c:	f44f 72a4 	mov.w	r2, #328	; 0x148
   24980:	800a      	strh	r2, [r1, #0]
	*max_rx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, BIT(2));
   24982:	801a      	strh	r2, [r3, #0]
}
   24984:	bd10      	pop	{r4, pc}

00024986 <ll_phy_get>:
{
   24986:	b538      	push	{r3, r4, r5, lr}
   24988:	460d      	mov	r5, r1
   2498a:	4614      	mov	r4, r2
	conn = ll_connected_get(handle);
   2498c:	f7ff fef7 	bl	2477e <ll_connected_get>
	if (!conn) {
   24990:	b158      	cbz	r0, 249aa <ll_phy_get+0x24>
	*tx = conn->lll.phy_tx;
   24992:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
   24996:	f3c3 0302 	ubfx	r3, r3, #0, #3
   2499a:	702b      	strb	r3, [r5, #0]
	*rx = conn->lll.phy_rx;
   2499c:	f890 3065 	ldrb.w	r3, [r0, #101]	; 0x65
   249a0:	f3c3 0302 	ubfx	r3, r3, #0, #3
   249a4:	7023      	strb	r3, [r4, #0]
	return 0;
   249a6:	2000      	movs	r0, #0
}
   249a8:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   249aa:	2002      	movs	r0, #2
   249ac:	e7fc      	b.n	249a8 <ll_phy_get+0x22>

000249ae <ll_phy_req_send>:
{
   249ae:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   249b2:	4689      	mov	r9, r1
   249b4:	4690      	mov	r8, r2
   249b6:	461f      	mov	r7, r3
	conn = ll_connected_get(handle);
   249b8:	f7ff fee1 	bl	2477e <ll_connected_get>
	if (!conn) {
   249bc:	b330      	cbz	r0, 24a0c <ll_phy_req_send+0x5e>
	if ((conn->llcp_req != conn->llcp_ack) ||
   249be:	f890 20e8 	ldrb.w	r2, [r0, #232]	; 0xe8
   249c2:	f890 30e9 	ldrb.w	r3, [r0, #233]	; 0xe9
   249c6:	429a      	cmp	r2, r3
   249c8:	d122      	bne.n	24a10 <ll_phy_req_send+0x62>
	    (conn->llcp_phy.req != conn->llcp_phy.ack)) {
   249ca:	f890 31a8 	ldrb.w	r3, [r0, #424]	; 0x1a8
	if ((conn->llcp_req != conn->llcp_ack) ||
   249ce:	f890 61a9 	ldrb.w	r6, [r0, #425]	; 0x1a9
   249d2:	429e      	cmp	r6, r3
   249d4:	d11c      	bne.n	24a10 <ll_phy_req_send+0x62>
	conn->llcp_phy.state = LLCP_PHY_STATE_REQ;
   249d6:	f8b0 41aa 	ldrh.w	r4, [r0, #426]	; 0x1aa
   249da:	f424 6480 	bic.w	r4, r4, #1024	; 0x400
   249de:	f024 0403 	bic.w	r4, r4, #3
   249e2:	f444 6480 	orr.w	r4, r4, #1024	; 0x400
	conn->llcp_phy.tx = tx;
   249e6:	4625      	mov	r5, r4
   249e8:	f369 0584 	bfi	r5, r9, #2, #3
	conn->llcp_phy.flags = flags;
   249ec:	f3c4 2407 	ubfx	r4, r4, #8, #8
   249f0:	f368 0441 	bfi	r4, r8, #1, #1
	conn->llcp_phy.rx = rx;
   249f4:	f367 1547 	bfi	r5, r7, #5, #3
	conn->llcp_phy.req++;
   249f8:	3601      	adds	r6, #1
	conn->llcp_phy.flags = flags;
   249fa:	f880 41ab 	strb.w	r4, [r0, #427]	; 0x1ab
	conn->llcp_phy.rx = rx;
   249fe:	f880 51aa 	strb.w	r5, [r0, #426]	; 0x1aa
	conn->llcp_phy.req++;
   24a02:	f880 61a8 	strb.w	r6, [r0, #424]	; 0x1a8
	return 0;
   24a06:	2000      	movs	r0, #0
}
   24a08:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   24a0c:	2002      	movs	r0, #2
   24a0e:	e7fb      	b.n	24a08 <ll_phy_req_send+0x5a>
		return BT_HCI_ERR_CMD_DISALLOWED;
   24a10:	200c      	movs	r0, #12
   24a12:	e7f9      	b.n	24a08 <ll_phy_req_send+0x5a>

00024a14 <ll_apto_get>:
{
   24a14:	b510      	push	{r4, lr}
   24a16:	460c      	mov	r4, r1
	conn = ll_connected_get(handle);
   24a18:	f7ff feb1 	bl	2477e <ll_connected_get>
	if (!conn) {
   24a1c:	b160      	cbz	r0, 24a38 <ll_apto_get+0x24>
	*apto = conn->apto_reload * conn->lll.interval * 125U / 1000;
   24a1e:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
   24a20:	f8b0 20d2 	ldrh.w	r2, [r0, #210]	; 0xd2
   24a24:	435a      	muls	r2, r3
   24a26:	237d      	movs	r3, #125	; 0x7d
   24a28:	4353      	muls	r3, r2
	return 0;
   24a2a:	2000      	movs	r0, #0
	*apto = conn->apto_reload * conn->lll.interval * 125U / 1000;
   24a2c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   24a30:	fbb3 f3f2 	udiv	r3, r3, r2
   24a34:	8023      	strh	r3, [r4, #0]
}
   24a36:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   24a38:	2002      	movs	r0, #2
   24a3a:	e7fc      	b.n	24a36 <ll_apto_get+0x22>

00024a3c <ll_apto_set>:
{
   24a3c:	b510      	push	{r4, lr}
   24a3e:	460c      	mov	r4, r1
	conn = ll_connected_get(handle);
   24a40:	f7ff fe9d 	bl	2477e <ll_connected_get>
	if (!conn) {
   24a44:	b170      	cbz	r0, 24a64 <ll_apto_set+0x28>
	conn->apto_reload = RADIO_CONN_EVENTS(apto * 10U * 1000U,
   24a46:	8dc2      	ldrh	r2, [r0, #46]	; 0x2e
   24a48:	f240 43e2 	movw	r3, #1250	; 0x4e2
   24a4c:	4353      	muls	r3, r2
   24a4e:	f242 7110 	movw	r1, #10000	; 0x2710
   24a52:	fb01 3404 	mla	r4, r1, r4, r3
   24a56:	3c01      	subs	r4, #1
   24a58:	fbb4 f4f3 	udiv	r4, r4, r3
   24a5c:	f8a0 40d2 	strh.w	r4, [r0, #210]	; 0xd2
	return 0;
   24a60:	2000      	movs	r0, #0
}
   24a62:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   24a64:	2002      	movs	r0, #2
   24a66:	e7fc      	b.n	24a62 <ll_apto_set+0x26>

00024a68 <ull_conn_lll_max_tx_octets_get>:
	switch (lll->phy_tx_time) {
   24a68:	f890 2048 	ldrb.w	r2, [r0, #72]	; 0x48
   24a6c:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
   24a70:	f3c2 1202 	ubfx	r2, r2, #4, #3
   24a74:	2a02      	cmp	r2, #2
		max_tx_octets = (lll->max_tx_time >> 3) - 10;
   24a76:	bf14      	ite	ne
   24a78:	08db      	lsrne	r3, r3, #3
		max_tx_octets = (lll->max_tx_time >> 2) - 11;
   24a7a:	089b      	lsreq	r3, r3, #2
	if (lll->enc_tx) {
   24a7c:	f890 2062 	ldrb.w	r2, [r0, #98]	; 0x62
	return max_tx_octets;
   24a80:	f8b0 0040 	ldrh.w	r0, [r0, #64]	; 0x40
		max_tx_octets = (lll->max_tx_time >> 3) - 10;
   24a84:	bf14      	ite	ne
   24a86:	3b0a      	subne	r3, #10
		max_tx_octets = (lll->max_tx_time >> 2) - 11;
   24a88:	3b0b      	subeq	r3, #11
   24a8a:	b29b      	uxth	r3, r3
	if (lll->enc_tx) {
   24a8c:	06d2      	lsls	r2, r2, #27
		max_tx_octets -= 4U;
   24a8e:	bf44      	itt	mi
   24a90:	3b04      	submi	r3, #4
   24a92:	b29b      	uxthmi	r3, r3
}
   24a94:	4298      	cmp	r0, r3
   24a96:	bf28      	it	cs
   24a98:	4618      	movcs	r0, r3
   24a9a:	4770      	bx	lr

00024a9c <isr_race>:
	radio_status_reset();
   24a9c:	f7f3 bec6 	b.w	1882c <radio_status_reset>

00024aa0 <empty_tx_enqueue>:

	return 0;
}

static struct pdu_data *empty_tx_enqueue(struct lll_conn *lll)
{
   24aa0:	b538      	push	{r3, r4, r5, lr}
	struct pdu_data *p;

	lll->empty = 1;
   24aa2:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
   24aa6:	f043 0304 	orr.w	r3, r3, #4
   24aaa:	f880 3062 	strb.w	r3, [r0, #98]	; 0x62
{
   24aae:	4605      	mov	r5, r0

	p = (void *)radio_pkt_empty_get();
   24ab0:	f7f3 fef2 	bl	18898 <radio_pkt_empty_get>
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   24ab4:	7803      	ldrb	r3, [r0, #0]
   24ab6:	2201      	movs	r2, #1
   24ab8:	f362 0301 	bfi	r3, r2, #0, #2
	p->len = 0;
   24abc:	2200      	movs	r2, #0
   24abe:	7042      	strb	r2, [r0, #1]
	p = (void *)radio_pkt_empty_get();
   24ac0:	4604      	mov	r4, r0
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   24ac2:	7003      	strb	r3, [r0, #0]
	if (memq_peek(lll->memq_tx.head, lll->memq_tx.tail, NULL)) {
   24ac4:	e9d5 0113 	ldrd	r0, r1, [r5, #76]	; 0x4c
   24ac8:	f7ff fada 	bl	24080 <memq_peek>
   24acc:	7823      	ldrb	r3, [r4, #0]
   24ace:	3000      	adds	r0, #0
   24ad0:	bf18      	it	ne
   24ad2:	2001      	movne	r0, #1
   24ad4:	f360 1304 	bfi	r3, r0, #4, #1
   24ad8:	7023      	strb	r3, [r4, #0]
	} else {
		p->md = 0;
	}

	return p;
}
   24ada:	4620      	mov	r0, r4
   24adc:	bd38      	pop	{r3, r4, r5, pc}

00024ade <lll_conn_init>:
}
   24ade:	2000      	movs	r0, #0
   24ae0:	4770      	bx	lr

00024ae2 <lll_conn_reset>:
   24ae2:	2000      	movs	r0, #0
   24ae4:	4770      	bx	lr

00024ae6 <lll_conn_ppm_local_get>:
}
   24ae6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   24aea:	4770      	bx	lr

00024aec <lll_conn_is_abort_cb>:
}
   24aec:	f06f 008b 	mvn.w	r0, #139	; 0x8b
   24af0:	4770      	bx	lr

00024af2 <lll_conn_isr_abort>:
{
   24af2:	b510      	push	{r4, lr}
   24af4:	4604      	mov	r4, r0
	radio_status_reset();
   24af6:	f7f3 fe99 	bl	1882c <radio_status_reset>
	radio_tmr_status_reset();
   24afa:	f7f3 ff55 	bl	189a8 <radio_tmr_status_reset>
	radio_filter_status_reset();
   24afe:	f7f3 ff2f 	bl	18960 <radio_filter_status_reset>
	radio_ar_status_reset();
   24b02:	f7f4 f8ef 	bl	18ce4 <radio_ar_status_reset>
	radio_rssi_status_reset();
   24b06:	f7f3 fef3 	bl	188f0 <radio_rssi_status_reset>
	isr_cleanup(param);
   24b0a:	4620      	mov	r0, r4
}
   24b0c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   24b10:	f7f2 b9ae 	b.w	16e70 <isr_cleanup>

00024b14 <lll_conn_tx_pkt_set>:
{
   24b14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   24b16:	460f      	mov	r7, r1
	phy = lll->phy_tx;
   24b18:	f890 1048 	ldrb.w	r1, [r0, #72]	; 0x48
	max_tx_octets = lll->max_tx_octets;
   24b1c:	f8b0 5040 	ldrh.w	r5, [r0, #64]	; 0x40
	phy = lll->phy_tx;
   24b20:	f001 0407 	and.w	r4, r1, #7
{
   24b24:	4606      	mov	r6, r0
	radio_phy_set(phy, flags);
   24b26:	f3c1 01c0 	ubfx	r1, r1, #3, #1
   24b2a:	4620      	mov	r0, r4
   24b2c:	f7f3 fde8 	bl	18700 <radio_phy_set>
	} else if (lll->enc_tx) {
   24b30:	f896 3062 	ldrb.w	r3, [r6, #98]	; 0x62
   24b34:	0062      	lsls	r2, r4, #1
   24b36:	06db      	lsls	r3, r3, #27
   24b38:	b2e9      	uxtb	r1, r5
   24b3a:	f042 0201 	orr.w	r2, r2, #1
   24b3e:	d50d      	bpl.n	24b5c <lll_conn_tx_pkt_set+0x48>
		radio_pkt_configure(8, (max_tx_octets + 4U),
   24b40:	3104      	adds	r1, #4
   24b42:	b2c9      	uxtb	r1, r1
   24b44:	2008      	movs	r0, #8
   24b46:	f7f3 fe21 	bl	1878c <radio_pkt_configure>
		radio_pkt_tx_set(radio_ccm_tx_pkt_set(&lll->ccm_tx,
   24b4a:	4639      	mov	r1, r7
   24b4c:	f106 0084 	add.w	r0, r6, #132	; 0x84
   24b50:	f7f4 f848 	bl	18be4 <radio_ccm_tx_pkt_set>
}
   24b54:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_tx_set(pdu_data_tx);
   24b58:	f7f3 be4a 	b.w	187f0 <radio_pkt_tx_set>
		radio_pkt_configure(8, max_tx_octets, (phy << 1) | 0x01);
   24b5c:	2008      	movs	r0, #8
   24b5e:	f7f3 fe15 	bl	1878c <radio_pkt_configure>
		radio_pkt_tx_set(pdu_data_tx);
   24b62:	4638      	mov	r0, r7
   24b64:	e7f6      	b.n	24b54 <lll_conn_tx_pkt_set+0x40>

00024b66 <lll_conn_pdu_tx_prep>:
	if (lll->empty) {
   24b66:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
   24b6a:	075b      	lsls	r3, r3, #29
{
   24b6c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   24b70:	4606      	mov	r6, r0
   24b72:	4688      	mov	r8, r1
	if (lll->empty) {
   24b74:	d506      	bpl.n	24b84 <lll_conn_pdu_tx_prep+0x1e>
		*pdu_data_tx = empty_tx_enqueue(lll);
   24b76:	f7ff ff93 	bl	24aa0 <empty_tx_enqueue>
   24b7a:	f8c8 0000 	str.w	r0, [r8]
}
   24b7e:	b003      	add	sp, #12
   24b80:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, (void **)&tx);
   24b84:	aa01      	add	r2, sp, #4
   24b86:	e9d0 0113 	ldrd	r0, r1, [r0, #76]	; 0x4c
   24b8a:	f7ff fa79 	bl	24080 <memq_peek>
	if (!link) {
   24b8e:	4681      	mov	r9, r0
   24b90:	b960      	cbnz	r0, 24bac <lll_conn_pdu_tx_prep+0x46>
		p = empty_tx_enqueue(lll);
   24b92:	4630      	mov	r0, r6
   24b94:	f7ff ff84 	bl	24aa0 <empty_tx_enqueue>
   24b98:	4607      	mov	r7, r0
	p->rfu = 0U;
   24b9a:	783b      	ldrb	r3, [r7, #0]
   24b9c:	f36f 1347 	bfc	r3, #5, #3
   24ba0:	703b      	strb	r3, [r7, #0]
	p->resv = 0U;
   24ba2:	2300      	movs	r3, #0
   24ba4:	70bb      	strb	r3, [r7, #2]
	*pdu_data_tx = p;
   24ba6:	f8c8 7000 	str.w	r7, [r8]
   24baa:	e7e8      	b.n	24b7e <lll_conn_pdu_tx_prep+0x18>
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
   24bac:	9d01      	ldr	r5, [sp, #4]
   24bae:	f896 4061 	ldrb.w	r4, [r6, #97]	; 0x61
		if (!lll->packet_tx_head_len) {
   24bb2:	f896 3060 	ldrb.w	r3, [r6, #96]	; 0x60
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
   24bb6:	3504      	adds	r5, #4
   24bb8:	192f      	adds	r7, r5, r4
		if (!lll->packet_tx_head_len) {
   24bba:	b913      	cbnz	r3, 24bc2 <lll_conn_pdu_tx_prep+0x5c>
			lll->packet_tx_head_len = p->len;
   24bbc:	787b      	ldrb	r3, [r7, #1]
   24bbe:	f886 3060 	strb.w	r3, [r6, #96]	; 0x60
		if (lll->packet_tx_head_offset) {
   24bc2:	b124      	cbz	r4, 24bce <lll_conn_pdu_tx_prep+0x68>
			p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   24bc4:	5d2b      	ldrb	r3, [r5, r4]
   24bc6:	2201      	movs	r2, #1
   24bc8:	f362 0301 	bfi	r3, r2, #0, #2
   24bcc:	552b      	strb	r3, [r5, r4]
		p->len = lll->packet_tx_head_len - lll->packet_tx_head_offset;
   24bce:	f896 3060 	ldrb.w	r3, [r6, #96]	; 0x60
   24bd2:	1b1b      	subs	r3, r3, r4
   24bd4:	707b      	strb	r3, [r7, #1]
		p->md = 0;
   24bd6:	5d2b      	ldrb	r3, [r5, r4]
   24bd8:	f36f 1304 	bfc	r3, #4, #1
   24bdc:	552b      	strb	r3, [r5, r4]
		max_tx_octets = ull_conn_lll_max_tx_octets_get(lll);
   24bde:	4630      	mov	r0, r6
   24be0:	f7ff ff42 	bl	24a68 <ull_conn_lll_max_tx_octets_get>
		if (p->len > max_tx_octets) {
   24be4:	787b      	ldrb	r3, [r7, #1]
   24be6:	4283      	cmp	r3, r0
			p->len = max_tx_octets;
   24be8:	bf84      	itt	hi
   24bea:	7078      	strbhi	r0, [r7, #1]
			p->md = 1;
   24bec:	5d2b      	ldrbhi	r3, [r5, r4]
		if (link->next != lll->memq_tx.tail) {
   24bee:	f8d9 2000 	ldr.w	r2, [r9]
			p->md = 1;
   24bf2:	bf84      	itt	hi
   24bf4:	f043 0310 	orrhi.w	r3, r3, #16
   24bf8:	552b      	strbhi	r3, [r5, r4]
		if (link->next != lll->memq_tx.tail) {
   24bfa:	6d33      	ldr	r3, [r6, #80]	; 0x50
   24bfc:	429a      	cmp	r2, r3
			p->md = 1;
   24bfe:	bf1e      	ittt	ne
   24c00:	5d2b      	ldrbne	r3, [r5, r4]
   24c02:	f043 0310 	orrne.w	r3, r3, #16
   24c06:	552b      	strbne	r3, [r5, r4]
   24c08:	e7c7      	b.n	24b9a <lll_conn_pdu_tx_prep+0x34>

00024c0a <lll_conn_flush>:

void lll_conn_flush(struct lll_conn *lll)
{
	/* Nothing to be flushed */
}
   24c0a:	4770      	bx	lr

00024c0c <ll_start_enc_req_send>:
{
   24c0c:	b538      	push	{r3, r4, r5, lr}
   24c0e:	460d      	mov	r5, r1
   24c10:	4614      	mov	r4, r2
	conn = ll_connected_get(handle);
   24c12:	f7ff fdb4 	bl	2477e <ll_connected_get>
	if (!conn) {
   24c16:	4603      	mov	r3, r0
   24c18:	2800      	cmp	r0, #0
   24c1a:	d041      	beq.n	24ca0 <ll_start_enc_req_send+0x94>
	if (error_code) {
   24c1c:	b325      	cbz	r5, 24c68 <ll_start_enc_req_send+0x5c>
		if (conn->llcp_enc.refresh == 0U) {
   24c1e:	f890 0152 	ldrb.w	r0, [r0, #338]	; 0x152
   24c22:	f010 0004 	ands.w	r0, r0, #4
   24c26:	d112      	bne.n	24c4e <ll_start_enc_req_send+0x42>
			if ((conn->llcp_req == conn->llcp_ack) ||
   24c28:	f893 10e8 	ldrb.w	r1, [r3, #232]	; 0xe8
   24c2c:	f893 20e9 	ldrb.w	r2, [r3, #233]	; 0xe9
   24c30:	4291      	cmp	r1, r2
   24c32:	d037      	beq.n	24ca4 <ll_start_enc_req_send+0x98>
   24c34:	f893 20ea 	ldrb.w	r2, [r3, #234]	; 0xea
   24c38:	2a03      	cmp	r2, #3
   24c3a:	d133      	bne.n	24ca4 <ll_start_enc_req_send+0x98>
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   24c3c:	f893 20ec 	ldrb.w	r2, [r3, #236]	; 0xec
			conn->llcp.encryption.error_code = error_code;
   24c40:	f883 50ed 	strb.w	r5, [r3, #237]	; 0xed
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   24c44:	f360 0201 	bfi	r2, r0, #0, #2
   24c48:	f883 20ec 	strb.w	r2, [r3, #236]	; 0xec
}
   24c4c:	bd38      	pop	{r3, r4, r5, pc}
			    conn->llcp_terminate.req) {
   24c4e:	f893 1128 	ldrb.w	r1, [r3, #296]	; 0x128
			if (conn->llcp_terminate.ack !=
   24c52:	f893 2129 	ldrb.w	r2, [r3, #297]	; 0x129
   24c56:	428a      	cmp	r2, r1
   24c58:	d124      	bne.n	24ca4 <ll_start_enc_req_send+0x98>
			conn->llcp_terminate.req++;
   24c5a:	3201      	adds	r2, #1
			conn->llcp_terminate.reason_own = error_code;
   24c5c:	f883 512a 	strb.w	r5, [r3, #298]	; 0x12a
			conn->llcp_terminate.req++;
   24c60:	f883 2128 	strb.w	r2, [r3, #296]	; 0x128
	return 0;
   24c64:	2000      	movs	r0, #0
   24c66:	e7f1      	b.n	24c4c <ll_start_enc_req_send+0x40>
		if ((conn->llcp_req == conn->llcp_ack) ||
   24c68:	f890 10e8 	ldrb.w	r1, [r0, #232]	; 0xe8
   24c6c:	f890 20e9 	ldrb.w	r2, [r0, #233]	; 0xe9
   24c70:	4291      	cmp	r1, r2
   24c72:	d017      	beq.n	24ca4 <ll_start_enc_req_send+0x98>
   24c74:	f890 20ea 	ldrb.w	r2, [r0, #234]	; 0xea
   24c78:	2a03      	cmp	r2, #3
   24c7a:	d113      	bne.n	24ca4 <ll_start_enc_req_send+0x98>
   24c7c:	f200 115d 	addw	r1, r0, #349	; 0x15d
   24c80:	4622      	mov	r2, r4
   24c82:	f104 0010 	add.w	r0, r4, #16
   24c86:	f852 4b04 	ldr.w	r4, [r2], #4
   24c8a:	f841 4b04 	str.w	r4, [r1], #4
   24c8e:	4282      	cmp	r2, r0
   24c90:	d1f9      	bne.n	24c86 <ll_start_enc_req_send+0x7a>
		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   24c92:	f8b3 20ec 	ldrh.w	r2, [r3, #236]	; 0xec
   24c96:	f002 02fc 	and.w	r2, r2, #252	; 0xfc
   24c9a:	f8a3 20ec 	strh.w	r2, [r3, #236]	; 0xec
   24c9e:	e7e1      	b.n	24c64 <ll_start_enc_req_send+0x58>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   24ca0:	2002      	movs	r0, #2
   24ca2:	e7d3      	b.n	24c4c <ll_start_enc_req_send+0x40>
				return BT_HCI_ERR_CMD_DISALLOWED;
   24ca4:	200c      	movs	r0, #12
   24ca6:	e7d1      	b.n	24c4c <ll_start_enc_req_send+0x40>

00024ca8 <bt_addr_copy>:
   24ca8:	680b      	ldr	r3, [r1, #0]
   24caa:	6003      	str	r3, [r0, #0]
   24cac:	888b      	ldrh	r3, [r1, #4]
   24cae:	8083      	strh	r3, [r0, #4]
}
   24cb0:	4770      	bx	lr

00024cb2 <ll_wl_size_get>:
}
   24cb2:	2008      	movs	r0, #8
   24cb4:	4770      	bx	lr

00024cb6 <ll_rl_size_get>:
   24cb6:	2008      	movs	r0, #8
   24cb8:	4770      	bx	lr

00024cba <ctlr_set>:

#endif /* CONFIG_BT_CTLR_VERSION_SETTINGS */

static int ctlr_set(const char *name, size_t len_rd,
		    settings_read_cb read_cb, void *store)
{
   24cba:	b507      	push	{r0, r1, r2, lr}
	int len, nlen;
	const char *next;

	nlen = settings_name_next(name, &next);
   24cbc:	a901      	add	r1, sp, #4
   24cbe:	f7fc fe4a 	bl	21956 <settings_name_next>
		return 0;
	}
#endif /* CONFIG_BT_CTLR_VERSION_SETTINGS */

	return 0;
}
   24cc2:	2000      	movs	r0, #0
   24cc4:	b003      	add	sp, #12
   24cc6:	f85d fb04 	ldr.w	pc, [sp], #4

00024cca <ecb_encrypt>:
	memcpy(cipher_text_be, &ecb.cipher_text[0], sizeof(ecb.cipher_text));
}

void ecb_encrypt(u8_t const *const key_le, u8_t const *const clear_text_le,
		 u8_t * const cipher_text_le, u8_t * const cipher_text_be)
{
   24cca:	b570      	push	{r4, r5, r6, lr}
   24ccc:	b08c      	sub	sp, #48	; 0x30
   24cce:	460e      	mov	r6, r1
   24cd0:	4615      	mov	r5, r2
	struct ecb_param ecb;

	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
   24cd2:	4601      	mov	r1, r0
   24cd4:	2210      	movs	r2, #16
   24cd6:	4668      	mov	r0, sp
{
   24cd8:	461c      	mov	r4, r3
	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
   24cda:	f7ff f9a2 	bl	24022 <mem_rcopy>
	mem_rcopy(&ecb.clear_text[0], clear_text_le, sizeof(ecb.clear_text));
   24cde:	2210      	movs	r2, #16
   24ce0:	eb0d 0002 	add.w	r0, sp, r2
   24ce4:	4631      	mov	r1, r6
   24ce6:	f7ff f99c 	bl	24022 <mem_rcopy>

	do_ecb(&ecb);
   24cea:	4668      	mov	r0, sp
   24cec:	f7f3 fc0e 	bl	1850c <do_ecb>

	if (cipher_text_le) {
   24cf0:	b125      	cbz	r5, 24cfc <ecb_encrypt+0x32>
		mem_rcopy(cipher_text_le, &ecb.cipher_text[0],
   24cf2:	2210      	movs	r2, #16
   24cf4:	a908      	add	r1, sp, #32
   24cf6:	4628      	mov	r0, r5
   24cf8:	f7ff f993 	bl	24022 <mem_rcopy>
			  sizeof(ecb.cipher_text));
	}

	if (cipher_text_be) {
   24cfc:	b15c      	cbz	r4, 24d16 <ecb_encrypt+0x4c>
   24cfe:	4623      	mov	r3, r4
   24d00:	ad08      	add	r5, sp, #32
   24d02:	ac0c      	add	r4, sp, #48	; 0x30
   24d04:	462a      	mov	r2, r5
   24d06:	ca03      	ldmia	r2!, {r0, r1}
   24d08:	42a2      	cmp	r2, r4
   24d0a:	6018      	str	r0, [r3, #0]
   24d0c:	6059      	str	r1, [r3, #4]
   24d0e:	4615      	mov	r5, r2
   24d10:	f103 0308 	add.w	r3, r3, #8
   24d14:	d1f6      	bne.n	24d04 <ecb_encrypt+0x3a>
		memcpy(cipher_text_be, &ecb.cipher_text[0],
			 sizeof(ecb.cipher_text));
	}
}
   24d16:	b00c      	add	sp, #48	; 0x30
   24d18:	bd70      	pop	{r4, r5, r6, pc}

00024d1a <radio_tx_chain_delay_get>:
}
   24d1a:	2001      	movs	r0, #1
   24d1c:	4770      	bx	lr

00024d1e <radio_rx_ready_delay_get>:
}
   24d1e:	2029      	movs	r0, #41	; 0x29
   24d20:	4770      	bx	lr

00024d22 <radio_rx_chain_delay_get>:
	switch (phy) {
   24d22:	2802      	cmp	r0, #2
}
   24d24:	bf14      	ite	ne
   24d26:	200a      	movne	r0, #10
   24d28:	2006      	moveq	r0, #6
   24d2a:	4770      	bx	lr

00024d2c <mayfly_prio_is_equal>:
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   24d2c:	4288      	cmp	r0, r1
   24d2e:	d00c      	beq.n	24d4a <mayfly_prio_is_equal+0x1e>
	return (caller_id == callee_id) ||
   24d30:	b978      	cbnz	r0, 24d52 <mayfly_prio_is_equal+0x26>
	       ((caller_id == MAYFLY_CALL_ID_LLL) &&
   24d32:	1e48      	subs	r0, r1, #1
   24d34:	2801      	cmp	r0, #1
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
   24d36:	bf8c      	ite	hi
   24d38:	2000      	movhi	r0, #0
   24d3a:	2001      	movls	r0, #1
   24d3c:	4770      	bx	lr
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
   24d3e:	f011 0ffd 	tst.w	r1, #253	; 0xfd
   24d42:	bf0c      	ite	eq
   24d44:	2001      	moveq	r0, #1
   24d46:	2000      	movne	r0, #0
   24d48:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   24d4a:	2001      	movs	r0, #1
   24d4c:	4770      	bx	lr
   24d4e:	2000      	movs	r0, #0
}
   24d50:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   24d52:	2801      	cmp	r0, #1
   24d54:	d0f3      	beq.n	24d3e <mayfly_prio_is_equal+0x12>
		(callee_id == MAYFLY_CALL_ID_JOB)) ||
   24d56:	2802      	cmp	r0, #2
   24d58:	d1f9      	bne.n	24d4e <mayfly_prio_is_equal+0x22>
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
   24d5a:	2901      	cmp	r1, #1
   24d5c:	e7eb      	b.n	24d36 <mayfly_prio_is_equal+0xa>

00024d5e <hal_ticker_instance0_trigger_set>:

void hal_ticker_instance0_trigger_set(u32_t value)
{
	cntr_cmp_set(0, value);
   24d5e:	4601      	mov	r1, r0
   24d60:	2000      	movs	r0, #0
   24d62:	f7f3 bbcb 	b.w	184fc <cntr_cmp_set>

00024d66 <fixed_data_unref>:
}
   24d66:	4770      	bx	lr

00024d68 <k_uptime_get_32>:
{
   24d68:	b508      	push	{r3, lr}
	return z_impl_k_uptime_get();
   24d6a:	f003 f92d 	bl	27fc8 <z_impl_k_uptime_get>
}
   24d6e:	bd08      	pop	{r3, pc}

00024d70 <net_buf_alloc_fixed>:
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   24d70:	69c3      	ldr	r3, [r0, #28]
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
   24d72:	685b      	ldr	r3, [r3, #4]
   24d74:	460a      	mov	r2, r1
   24d76:	6819      	ldr	r1, [r3, #0]
   24d78:	f7f4 b8f8 	b.w	18f6c <net_buf_alloc_len>

00024d7c <net_buf_get>:
{
   24d7c:	b570      	push	{r4, r5, r6, lr}
   24d7e:	4606      	mov	r6, r0
	return z_impl_k_queue_get(queue, timeout);
   24d80:	f002 feea 	bl	27b58 <z_impl_k_queue_get>
	if (!buf) {
   24d84:	4605      	mov	r5, r0
   24d86:	b128      	cbz	r0, 24d94 <net_buf_get+0x18>
   24d88:	4604      	mov	r4, r0
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   24d8a:	7963      	ldrb	r3, [r4, #5]
   24d8c:	f013 0301 	ands.w	r3, r3, #1
   24d90:	d102      	bne.n	24d98 <net_buf_get+0x1c>
	frag->frags = NULL;
   24d92:	6023      	str	r3, [r4, #0]
}
   24d94:	4628      	mov	r0, r5
   24d96:	bd70      	pop	{r4, r5, r6, pc}
   24d98:	2100      	movs	r1, #0
   24d9a:	4630      	mov	r0, r6
   24d9c:	f002 fedc 	bl	27b58 <z_impl_k_queue_get>
		frag->flags &= ~NET_BUF_FRAGS;
   24da0:	7963      	ldrb	r3, [r4, #5]
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
   24da2:	6020      	str	r0, [r4, #0]
		frag->flags &= ~NET_BUF_FRAGS;
   24da4:	f023 0301 	bic.w	r3, r3, #1
   24da8:	7163      	strb	r3, [r4, #5]
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   24daa:	4604      	mov	r4, r0
   24dac:	e7ed      	b.n	24d8a <net_buf_get+0xe>

00024dae <net_buf_simple_reserve>:
	buf->data = buf->__buf + reserve;
   24dae:	6883      	ldr	r3, [r0, #8]
   24db0:	4419      	add	r1, r3
   24db2:	6001      	str	r1, [r0, #0]
}
   24db4:	4770      	bx	lr

00024db6 <net_buf_put>:
{
   24db6:	b410      	push	{r4}
	for (tail = buf; tail->frags; tail = tail->frags) {
   24db8:	460a      	mov	r2, r1
   24dba:	6814      	ldr	r4, [r2, #0]
   24dbc:	b914      	cbnz	r4, 24dc4 <net_buf_put+0xe>
}
   24dbe:	bc10      	pop	{r4}
	k_fifo_put_list(fifo, buf, tail);
   24dc0:	f002 beab 	b.w	27b1a <k_queue_append_list>
		tail->flags |= NET_BUF_FRAGS;
   24dc4:	7953      	ldrb	r3, [r2, #5]
   24dc6:	f043 0301 	orr.w	r3, r3, #1
   24dca:	7153      	strb	r3, [r2, #5]
   24dcc:	4622      	mov	r2, r4
   24dce:	e7f4      	b.n	24dba <net_buf_put+0x4>

00024dd0 <net_buf_ref>:
{
	__ASSERT_NO_MSG(buf);

	NET_BUF_DBG("buf %p (old) ref %u pool_id %u",
		    buf, buf->ref, buf->pool_id);
	buf->ref++;
   24dd0:	7903      	ldrb	r3, [r0, #4]
   24dd2:	3301      	adds	r3, #1
   24dd4:	7103      	strb	r3, [r0, #4]
	return buf;
}
   24dd6:	4770      	bx	lr

00024dd8 <net_buf_simple_add>:
	return buf->data + buf->len;
   24dd8:	8883      	ldrh	r3, [r0, #4]
   24dda:	6802      	ldr	r2, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
   24ddc:	4419      	add	r1, r3
   24dde:	8081      	strh	r1, [r0, #4]
	return tail;
}
   24de0:	18d0      	adds	r0, r2, r3
   24de2:	4770      	bx	lr

00024de4 <net_buf_simple_add_mem>:

void *net_buf_simple_add_mem(struct net_buf_simple *buf, const void *mem,
			     size_t len)
{
   24de4:	b510      	push	{r4, lr}
   24de6:	6803      	ldr	r3, [r0, #0]
   24de8:	8884      	ldrh	r4, [r0, #4]
   24dea:	4423      	add	r3, r4
	buf->len += len;
   24dec:	4414      	add	r4, r2
   24dee:	8084      	strh	r4, [r0, #4]
   24df0:	4618      	mov	r0, r3
   24df2:	f7dc fefb 	bl	1bec <memcpy>
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	return memcpy(net_buf_simple_add(buf, len), mem, len);
}
   24df6:	bd10      	pop	{r4, pc}

00024df8 <net_buf_simple_add_u8>:
   24df8:	8883      	ldrh	r3, [r0, #4]
   24dfa:	6802      	ldr	r2, [r0, #0]

u8_t *net_buf_simple_add_u8(struct net_buf_simple *buf, u8_t val)
{
   24dfc:	b510      	push	{r4, lr}
	buf->len += len;
   24dfe:	1c5c      	adds	r4, r3, #1
   24e00:	8084      	strh	r4, [r0, #4]
	u8_t *u8;

	NET_BUF_SIMPLE_DBG("buf %p val 0x%02x", buf, val);

	u8 = net_buf_simple_add(buf, 1);
	*u8 = val;
   24e02:	54d1      	strb	r1, [r2, r3]

	return u8;
}
   24e04:	18d0      	adds	r0, r2, r3
   24e06:	bd10      	pop	{r4, pc}

00024e08 <net_buf_simple_add_le16>:
   24e08:	8883      	ldrh	r3, [r0, #4]
   24e0a:	6802      	ldr	r2, [r0, #0]

void net_buf_simple_add_le16(struct net_buf_simple *buf, u16_t val)
{
   24e0c:	b530      	push	{r4, r5, lr}
   24e0e:	18d4      	adds	r4, r2, r3
	buf->len += len;
   24e10:	1c9d      	adds	r5, r3, #2
   24e12:	8085      	strh	r5, [r0, #4]
	dst[0] = val;
   24e14:	54d1      	strb	r1, [r2, r3]
	dst[1] = val >> 8;
   24e16:	0a09      	lsrs	r1, r1, #8
   24e18:	7061      	strb	r1, [r4, #1]
	NET_BUF_SIMPLE_DBG("buf %p val %u", buf, val);

	sys_put_le16(val, net_buf_simple_add(buf, sizeof(val)));
}
   24e1a:	bd30      	pop	{r4, r5, pc}

00024e1c <net_buf_simple_push>:
{
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);

	buf->data -= len;
   24e1c:	6803      	ldr	r3, [r0, #0]
	buf->len += len;
   24e1e:	8882      	ldrh	r2, [r0, #4]
	buf->data -= len;
   24e20:	1a5b      	subs	r3, r3, r1
	buf->len += len;
   24e22:	4411      	add	r1, r2
	buf->data -= len;
   24e24:	6003      	str	r3, [r0, #0]
	buf->len += len;
   24e26:	8081      	strh	r1, [r0, #4]
	return buf->data;
}
   24e28:	4618      	mov	r0, r3
   24e2a:	4770      	bx	lr

00024e2c <net_buf_simple_pull>:
{
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   24e2c:	8883      	ldrh	r3, [r0, #4]
   24e2e:	1a5b      	subs	r3, r3, r1
   24e30:	8083      	strh	r3, [r0, #4]
	return buf->data += len;
   24e32:	6803      	ldr	r3, [r0, #0]
   24e34:	4419      	add	r1, r3
   24e36:	6001      	str	r1, [r0, #0]
}
   24e38:	4608      	mov	r0, r1
   24e3a:	4770      	bx	lr

00024e3c <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
   24e3c:	4603      	mov	r3, r0
	void *data = buf->data;
   24e3e:	6800      	ldr	r0, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   24e40:	889a      	ldrh	r2, [r3, #4]
   24e42:	1a52      	subs	r2, r2, r1
	buf->data += len;
   24e44:	4401      	add	r1, r0
	buf->len -= len;
   24e46:	809a      	strh	r2, [r3, #4]
	buf->data += len;
   24e48:	6019      	str	r1, [r3, #0]

	return data;
}
   24e4a:	4770      	bx	lr

00024e4c <net_buf_simple_pull_le16>:

	return val;
}

u16_t net_buf_simple_pull_le16(struct net_buf_simple *buf)
{
   24e4c:	b508      	push	{r3, lr}
	u16_t val;

	val = UNALIGNED_GET((u16_t *)buf->data);
   24e4e:	6803      	ldr	r3, [r0, #0]
	net_buf_simple_pull(buf, sizeof(val));
   24e50:	2102      	movs	r1, #2
	val = UNALIGNED_GET((u16_t *)buf->data);
   24e52:	881a      	ldrh	r2, [r3, #0]
	net_buf_simple_pull(buf, sizeof(val));
   24e54:	f7ff ffea 	bl	24e2c <net_buf_simple_pull>

	return sys_le16_to_cpu(val);
}
   24e58:	4610      	mov	r0, r2
   24e5a:	bd08      	pop	{r3, pc}

00024e5c <net_buf_simple_headroom>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
   24e5c:	6802      	ldr	r2, [r0, #0]
   24e5e:	6880      	ldr	r0, [r0, #8]
}
   24e60:	1a10      	subs	r0, r2, r0
   24e62:	4770      	bx	lr

00024e64 <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
   24e64:	8883      	ldrh	r3, [r0, #4]
   24e66:	88c2      	ldrh	r2, [r0, #6]
   24e68:	1ad2      	subs	r2, r2, r3
	return buf->data - buf->__buf;
   24e6a:	6803      	ldr	r3, [r0, #0]
   24e6c:	6880      	ldr	r0, [r0, #8]
   24e6e:	1a18      	subs	r0, r3, r0
}
   24e70:	1a10      	subs	r0, r2, r0
   24e72:	4770      	bx	lr

00024e74 <gpio_nrfx_write>:
{
   24e74:	b510      	push	{r4, lr}
	return port->config->config_info;
   24e76:	6804      	ldr	r4, [r0, #0]
   24e78:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   24e7a:	68a4      	ldr	r4, [r4, #8]
   24e7c:	69c0      	ldr	r0, [r0, #28]
   24e7e:	6824      	ldr	r4, [r4, #0]
	if (access_op == GPIO_ACCESS_BY_PORT) {
   24e80:	2901      	cmp	r1, #1
   24e82:	d104      	bne.n	24e8e <gpio_nrfx_write+0x1a>
		nrf_gpio_port_out_write(reg, value ^ data->inverted);
   24e84:	4058      	eors	r0, r3
}


NRF_STATIC_INLINE void nrf_gpio_port_out_write(NRF_GPIO_Type * p_reg, uint32_t value)
{
    p_reg->OUT = value;
   24e86:	f8c4 0504 	str.w	r0, [r4, #1284]	; 0x504
}
   24e8a:	2000      	movs	r0, #0
   24e8c:	bd10      	pop	{r4, pc}
		if ((value > 0) ^ ((BIT(pin) & data->inverted) != 0)) {
   24e8e:	3300      	adds	r3, #0
   24e90:	fa20 f002 	lsr.w	r0, r0, r2
   24e94:	f04f 0101 	mov.w	r1, #1
   24e98:	bf18      	it	ne
   24e9a:	2301      	movne	r3, #1
   24e9c:	f000 0001 	and.w	r0, r0, #1
   24ea0:	4091      	lsls	r1, r2
   24ea2:	4283      	cmp	r3, r0
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
   24ea4:	bf14      	ite	ne
   24ea6:	f8c4 1508 	strne.w	r1, [r4, #1288]	; 0x508
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
   24eaa:	f8c4 150c 	streq.w	r1, [r4, #1292]	; 0x50c
   24eae:	e7ec      	b.n	24e8a <gpio_nrfx_write+0x16>

00024eb0 <gpio_nrfx_read>:
{
   24eb0:	b570      	push	{r4, r5, r6, lr}
	return port->config->config_info;
   24eb2:	6804      	ldr	r4, [r0, #0]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   24eb4:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   24eb6:	68a4      	ldr	r4, [r4, #8]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   24eb8:	69c0      	ldr	r0, [r0, #28]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   24eba:	6825      	ldr	r5, [r4, #0]
    return p_reg->DIR;
   24ebc:	f8d5 6514 	ldr.w	r6, [r5, #1300]	; 0x514
    return p_reg->IN;
   24ec0:	f8d5 4510 	ldr.w	r4, [r5, #1296]	; 0x510
    return p_reg->OUT;
   24ec4:	f8d5 5504 	ldr.w	r5, [r5, #1284]	; 0x504
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   24ec8:	4060      	eors	r0, r4
   24eca:	406c      	eors	r4, r5
   24ecc:	4034      	ands	r4, r6
   24ece:	4060      	eors	r0, r4
	if (access_op == GPIO_ACCESS_BY_PORT) {
   24ed0:	2901      	cmp	r1, #1
		*value = (port_val & BIT(pin)) ? 1 : 0;
   24ed2:	bf1c      	itt	ne
   24ed4:	40d0      	lsrne	r0, r2
   24ed6:	f000 0001 	andne.w	r0, r0, #1
   24eda:	6018      	str	r0, [r3, #0]
}
   24edc:	2000      	movs	r0, #0
   24ede:	bd70      	pop	{r4, r5, r6, pc}

00024ee0 <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   24ee0:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_IS_EMPTY(slist)
   24ee2:	6818      	ldr	r0, [r3, #0]
{
   24ee4:	b530      	push	{r4, r5, lr}
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
   24ee6:	b158      	cbz	r0, 24f00 <gpio_nrfx_manage_callback+0x20>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   24ee8:	2400      	movs	r4, #0
   24eea:	4281      	cmp	r1, r0
   24eec:	d113      	bne.n	24f16 <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
   24eee:	6808      	ldr	r0, [r1, #0]
   24ef0:	b95c      	cbnz	r4, 24f0a <gpio_nrfx_manage_callback+0x2a>
   24ef2:	685c      	ldr	r4, [r3, #4]
	list->head = node;
   24ef4:	6018      	str	r0, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   24ef6:	42a1      	cmp	r1, r4
   24ef8:	d100      	bne.n	24efc <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
   24efa:	6058      	str	r0, [r3, #4]
	parent->next = child;
   24efc:	2000      	movs	r0, #0
   24efe:	6008      	str	r0, [r1, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
   24f00:	b972      	cbnz	r2, 24f20 <gpio_nrfx_manage_callback+0x40>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
   24f02:	2000      	movs	r0, #0
}
   24f04:	bd30      	pop	{r4, r5, pc}
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   24f06:	4628      	mov	r0, r5
   24f08:	e7ef      	b.n	24eea <gpio_nrfx_manage_callback+0xa>
	parent->next = child;
   24f0a:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   24f0c:	6858      	ldr	r0, [r3, #4]
   24f0e:	4281      	cmp	r1, r0
	list->tail = node;
   24f10:	bf08      	it	eq
   24f12:	605c      	streq	r4, [r3, #4]
   24f14:	e7f2      	b.n	24efc <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   24f16:	6805      	ldr	r5, [r0, #0]
	return node->next;
   24f18:	4604      	mov	r4, r0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   24f1a:	2d00      	cmp	r5, #0
   24f1c:	d1f3      	bne.n	24f06 <gpio_nrfx_manage_callback+0x26>
			if (!set) {
   24f1e:	b13a      	cbz	r2, 24f30 <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
   24f20:	681a      	ldr	r2, [r3, #0]
	parent->next = child;
   24f22:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   24f24:	6858      	ldr	r0, [r3, #4]
	list->head = node;
   24f26:	6019      	str	r1, [r3, #0]
Z_GENLIST_PREPEND(slist, snode)
   24f28:	2800      	cmp	r0, #0
   24f2a:	d1ea      	bne.n	24f02 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
   24f2c:	6059      	str	r1, [r3, #4]
   24f2e:	e7e9      	b.n	24f04 <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
   24f30:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   24f34:	e7e6      	b.n	24f04 <gpio_nrfx_manage_callback+0x24>

00024f36 <nrf_gpio_cfg_sense_set>:
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   24f36:	281f      	cmp	r0, #31
{
   24f38:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   24f3a:	d901      	bls.n	24f40 <nrf_gpio_cfg_sense_set+0xa>
   24f3c:	f7f4 f8c2 	bl	190c4 <nrf_gpio_pin_port_decode.isra.8.part.9>
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
   24f40:	0080      	lsls	r0, r0, #2
   24f42:	f100 40a0 	add.w	r0, r0, #1342177280	; 0x50000000
   24f46:	f8d0 3700 	ldr.w	r3, [r0, #1792]	; 0x700
   24f4a:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   24f4e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   24f52:	f8c0 3700 	str.w	r3, [r0, #1792]	; 0x700
}
   24f56:	bd08      	pop	{r3, pc}

00024f58 <gpio_nrfx_pin_disable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
   24f58:	2901      	cmp	r1, #1
{
   24f5a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
   24f5e:	bf18      	it	ne
   24f60:	b2d4      	uxtbne	r4, r2
	struct gpio_nrfx_data *data = get_port_data(port);
   24f62:	6887      	ldr	r7, [r0, #8]
{
   24f64:	4606      	mov	r6, r0
		to_pin   = pin;
   24f66:	bf12      	itee	ne
   24f68:	4625      	movne	r5, r4
		to_pin   = 31U;
   24f6a:	251f      	moveq	r5, #31
		from_pin = 0U;
   24f6c:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
   24f6e:	f04f 0801 	mov.w	r8, #1
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   24f72:	42ac      	cmp	r4, r5
   24f74:	d902      	bls.n	24f7c <gpio_nrfx_pin_disable_callback+0x24>
	return res;
   24f76:	2000      	movs	r0, #0
}
   24f78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
   24f7c:	68fb      	ldr	r3, [r7, #12]
   24f7e:	fa08 f204 	lsl.w	r2, r8, r4
   24f82:	ea23 0302 	bic.w	r3, r3, r2
   24f86:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
   24f88:	4621      	mov	r1, r4
   24f8a:	4630      	mov	r0, r6
   24f8c:	f7f4 f8c0 	bl	19110 <gpiote_pin_int_cfg>
		if (res != 0) {
   24f90:	2800      	cmp	r0, #0
   24f92:	d1f1      	bne.n	24f78 <gpio_nrfx_pin_disable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   24f94:	3401      	adds	r4, #1
   24f96:	b2e4      	uxtb	r4, r4
   24f98:	e7eb      	b.n	24f72 <gpio_nrfx_pin_disable_callback+0x1a>

00024f9a <gpio_nrfx_config>:
{
   24f9a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   24f9e:	4680      	mov	r8, r0
	struct gpio_nrfx_data *data = get_port_data(port);
   24fa0:	6885      	ldr	r5, [r0, #8]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   24fa2:	f403 4070 	and.w	r0, r3, #61440	; 0xf000
   24fa6:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
{
   24faa:	461e      	mov	r6, r3
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   24fac:	d041      	beq.n	25032 <gpio_nrfx_config+0x98>
   24fae:	dc09      	bgt.n	24fc4 <gpio_nrfx_config+0x2a>
   24fb0:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   24fb4:	d03f      	beq.n	25036 <gpio_nrfx_config+0x9c>
   24fb6:	f5b0 5f40 	cmp.w	r0, #12288	; 0x3000
   24fba:	d03e      	beq.n	2503a <gpio_nrfx_config+0xa0>
   24fbc:	b190      	cbz	r0, 24fe4 <gpio_nrfx_config+0x4a>
		return -EINVAL;
   24fbe:	f06f 0015 	mvn.w	r0, #21
   24fc2:	e033      	b.n	2502c <gpio_nrfx_config+0x92>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   24fc4:	f5b0 4fe0 	cmp.w	r0, #28672	; 0x7000
   24fc8:	d039      	beq.n	2503e <gpio_nrfx_config+0xa4>
   24fca:	dc04      	bgt.n	24fd6 <gpio_nrfx_config+0x3c>
   24fcc:	f5b0 4fa0 	cmp.w	r0, #20480	; 0x5000
   24fd0:	d1f5      	bne.n	24fbe <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0H1;
   24fd2:	2003      	movs	r0, #3
   24fd4:	e006      	b.n	24fe4 <gpio_nrfx_config+0x4a>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   24fd6:	f5b0 4f40 	cmp.w	r0, #49152	; 0xc000
   24fda:	d032      	beq.n	25042 <gpio_nrfx_config+0xa8>
   24fdc:	f5b0 4f50 	cmp.w	r0, #53248	; 0xd000
   24fe0:	d1ed      	bne.n	24fbe <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0D1;
   24fe2:	2007      	movs	r0, #7
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
   24fe4:	f406 7740 	and.w	r7, r6, #768	; 0x300
   24fe8:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
   24fec:	d02b      	beq.n	25046 <gpio_nrfx_config+0xac>
		pull = NRF_GPIO_PIN_NOPULL;
   24fee:	f5a7 7400 	sub.w	r4, r7, #512	; 0x200
   24ff2:	4263      	negs	r3, r4
   24ff4:	4163      	adcs	r3, r4
	dir = ((flags & GPIO_DIR_MASK) == GPIO_DIR_OUT)
   24ff6:	f006 0c01 	and.w	ip, r6, #1
                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
   24ffa:	ea4f 074c 	mov.w	r7, ip, lsl #1
	if (access_op == GPIO_ACCESS_BY_PORT) {
   24ffe:	2901      	cmp	r1, #1
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   25000:	ea47 070c 	orr.w	r7, r7, ip
		from_pin = pin;
   25004:	bf18      	it	ne
   25006:	b2d4      	uxtbne	r4, r2
   25008:	ea47 2000 	orr.w	r0, r7, r0, lsl #8
   2500c:	ea40 0783 	orr.w	r7, r0, r3, lsl #2
		to_pin   = pin;
   25010:	bf12      	itee	ne
   25012:	46a1      	movne	r9, r4
		to_pin   = 31U;
   25014:	f04f 091f 	moveq.w	r9, #31
		from_pin = 0U;
   25018:	2400      	moveq	r4, #0
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   2501a:	f04f 4aa0 	mov.w	sl, #1342177280	; 0x50000000
   2501e:	f04f 0b01 	mov.w	fp, #1
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
   25022:	f006 0302 	and.w	r3, r6, #2
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   25026:	45a1      	cmp	r9, r4
   25028:	d20f      	bcs.n	2504a <gpio_nrfx_config+0xb0>
	return 0;
   2502a:	2000      	movs	r0, #0
}
   2502c:	b003      	add	sp, #12
   2502e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		drive = NRF_GPIO_PIN_S0H1;
   25032:	2002      	movs	r0, #2
   25034:	e7d6      	b.n	24fe4 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_H0S1;
   25036:	2001      	movs	r0, #1
   25038:	e7d4      	b.n	24fe4 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0S1;
   2503a:	2004      	movs	r0, #4
   2503c:	e7d2      	b.n	24fe4 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0H1;
   2503e:	2005      	movs	r0, #5
   25040:	e7d0      	b.n	24fe4 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_S0D1;
   25042:	2006      	movs	r0, #6
   25044:	e7ce      	b.n	24fe4 <gpio_nrfx_config+0x4a>
		pull = NRF_GPIO_PIN_PULLUP;
   25046:	2303      	movs	r3, #3
   25048:	e7d5      	b.n	24ff6 <gpio_nrfx_config+0x5c>
	return port->config->config_info;
   2504a:	f8d8 2000 	ldr.w	r2, [r8]
		nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num,
   2504e:	6892      	ldr	r2, [r2, #8]
   25050:	7911      	ldrb	r1, [r2, #4]
   25052:	f004 021f 	and.w	r2, r4, #31
   25056:	ea42 1241 	orr.w	r2, r2, r1, lsl #5
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   2505a:	2a1f      	cmp	r2, #31
   2505c:	dd01      	ble.n	25062 <gpio_nrfx_config+0xc8>
   2505e:	f7f4 f831 	bl	190c4 <nrf_gpio_pin_port_decode.isra.8.part.9>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   25062:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
   25066:	f84a 7022 	str.w	r7, [sl, r2, lsl #2]
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
   2506a:	fa0b f204 	lsl.w	r2, fp, r4
   2506e:	68a9      	ldr	r1, [r5, #8]
   25070:	2b00      	cmp	r3, #0
   25072:	d025      	beq.n	250c0 <gpio_nrfx_config+0x126>
   25074:	4311      	orrs	r1, r2
   25076:	60a9      	str	r1, [r5, #8]
		WRITE_BIT(data->trig_edge, curr_pin, flags & GPIO_INT_EDGE);
   25078:	6969      	ldr	r1, [r5, #20]
   2507a:	9301      	str	r3, [sp, #4]
   2507c:	06b0      	lsls	r0, r6, #26
   2507e:	bf4c      	ite	mi
   25080:	4311      	orrmi	r1, r2
   25082:	4391      	bicpl	r1, r2
   25084:	6169      	str	r1, [r5, #20]
		WRITE_BIT(data->double_edge, curr_pin,
   25086:	69a9      	ldr	r1, [r5, #24]
   25088:	0670      	lsls	r0, r6, #25
   2508a:	bf4c      	ite	mi
   2508c:	4311      	orrmi	r1, r2
   2508e:	4391      	bicpl	r1, r2
   25090:	61a9      	str	r1, [r5, #24]
		WRITE_BIT(data->active_level, curr_pin,
   25092:	6929      	ldr	r1, [r5, #16]
   25094:	0770      	lsls	r0, r6, #29
   25096:	bf4c      	ite	mi
   25098:	4311      	orrmi	r1, r2
   2509a:	4391      	bicpl	r1, r2
   2509c:	6129      	str	r1, [r5, #16]
		WRITE_BIT(data->inverted, curr_pin, flags & GPIO_POL_INV);
   2509e:	69e9      	ldr	r1, [r5, #28]
   250a0:	0630      	lsls	r0, r6, #24
   250a2:	bf4c      	ite	mi
   250a4:	430a      	orrmi	r2, r1
   250a6:	ea21 0202 	bicpl.w	r2, r1, r2
   250aa:	61ea      	str	r2, [r5, #28]
		res = gpiote_pin_int_cfg(port, curr_pin);
   250ac:	4621      	mov	r1, r4
   250ae:	4640      	mov	r0, r8
   250b0:	f7f4 f82e 	bl	19110 <gpiote_pin_int_cfg>
		if (res != 0) {
   250b4:	2800      	cmp	r0, #0
   250b6:	d1b9      	bne.n	2502c <gpio_nrfx_config+0x92>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   250b8:	3401      	adds	r4, #1
   250ba:	b2e4      	uxtb	r4, r4
   250bc:	9b01      	ldr	r3, [sp, #4]
   250be:	e7b2      	b.n	25026 <gpio_nrfx_config+0x8c>
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
   250c0:	ea21 0102 	bic.w	r1, r1, r2
   250c4:	e7d7      	b.n	25076 <gpio_nrfx_config+0xdc>

000250c6 <gpio_nrfx_pin_enable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
   250c6:	2901      	cmp	r1, #1
{
   250c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
   250cc:	bf18      	it	ne
   250ce:	b2d4      	uxtbne	r4, r2
	struct gpio_nrfx_data *data = get_port_data(port);
   250d0:	6887      	ldr	r7, [r0, #8]
{
   250d2:	4606      	mov	r6, r0
		to_pin   = pin;
   250d4:	bf12      	itee	ne
   250d6:	4625      	movne	r5, r4
		to_pin   = 31U;
   250d8:	251f      	moveq	r5, #31
		from_pin = 0U;
   250da:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
   250dc:	f04f 0801 	mov.w	r8, #1
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   250e0:	42ac      	cmp	r4, r5
   250e2:	d902      	bls.n	250ea <gpio_nrfx_pin_enable_callback+0x24>
	return res;
   250e4:	2000      	movs	r0, #0
}
   250e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
   250ea:	68fb      	ldr	r3, [r7, #12]
   250ec:	fa08 f204 	lsl.w	r2, r8, r4
   250f0:	4313      	orrs	r3, r2
   250f2:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
   250f4:	4621      	mov	r1, r4
   250f6:	4630      	mov	r0, r6
   250f8:	f7f4 f80a 	bl	19110 <gpiote_pin_int_cfg>
		if (res != 0) {
   250fc:	2800      	cmp	r0, #0
   250fe:	d1f2      	bne.n	250e6 <gpio_nrfx_pin_enable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   25100:	3401      	adds	r4, #1
   25102:	b2e4      	uxtb	r4, r4
   25104:	e7ec      	b.n	250e0 <gpio_nrfx_pin_enable_callback+0x1a>

00025106 <gpio_pin_write>:
{
   25106:	b410      	push	{r4}
   25108:	4613      	mov	r3, r2
	return api->write(port, access_op, pin, value);
   2510a:	6842      	ldr	r2, [r0, #4]
   2510c:	6854      	ldr	r4, [r2, #4]
   2510e:	460a      	mov	r2, r1
   25110:	46a4      	mov	ip, r4
   25112:	2100      	movs	r1, #0
}
   25114:	bc10      	pop	{r4}
	return api->write(port, access_op, pin, value);
   25116:	4760      	bx	ip

00025118 <_spi_context_cs_control.isra.7>:
static inline void _spi_context_cs_control(struct spi_context *ctx,
   25118:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   2511a:	6804      	ldr	r4, [r0, #0]
static inline void _spi_context_cs_control(struct spi_context *ctx,
   2511c:	4605      	mov	r5, r0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   2511e:	b324      	cbz	r4, 2516a <_spi_context_cs_control.isra.7+0x52>
   25120:	68a3      	ldr	r3, [r4, #8]
   25122:	b313      	cbz	r3, 2516a <_spi_context_cs_control.isra.7+0x52>
   25124:	6818      	ldr	r0, [r3, #0]
   25126:	b300      	cbz	r0, 2516a <_spi_context_cs_control.isra.7+0x52>
		if (on) {
   25128:	b161      	cbz	r1, 25144 <_spi_context_cs_control.isra.7+0x2c>
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   2512a:	f9b4 2004 	ldrsh.w	r2, [r4, #4]
			gpio_pin_write(ctx->config->cs->gpio_dev,
   2512e:	6859      	ldr	r1, [r3, #4]
   25130:	0fd2      	lsrs	r2, r2, #31
   25132:	f7ff ffe8 	bl	25106 <gpio_pin_write>
			k_busy_wait(ctx->config->cs->delay);
   25136:	682b      	ldr	r3, [r5, #0]
   25138:	689b      	ldr	r3, [r3, #8]
   2513a:	6898      	ldr	r0, [r3, #8]
}
   2513c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_busy_wait(usec_to_wait);
   25140:	f002 be6c 	b.w	27e1c <z_impl_k_busy_wait>
			if (!force_off &&
   25144:	b912      	cbnz	r2, 2514c <_spi_context_cs_control.isra.7+0x34>
   25146:	88a2      	ldrh	r2, [r4, #4]
   25148:	0492      	lsls	r2, r2, #18
   2514a:	d40e      	bmi.n	2516a <_spi_context_cs_control.isra.7+0x52>
			k_busy_wait(ctx->config->cs->delay);
   2514c:	6898      	ldr	r0, [r3, #8]
   2514e:	f002 fe65 	bl	27e1c <z_impl_k_busy_wait>
			gpio_pin_write(ctx->config->cs->gpio_dev,
   25152:	682a      	ldr	r2, [r5, #0]
   25154:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   25156:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
			gpio_pin_write(ctx->config->cs->gpio_dev,
   2515a:	43d2      	mvns	r2, r2
   2515c:	e9d3 0100 	ldrd	r0, r1, [r3]
   25160:	0fd2      	lsrs	r2, r2, #31
}
   25162:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gpio_pin_write(ctx->config->cs->gpio_dev,
   25166:	f7ff bfce 	b.w	25106 <gpio_pin_write>
}
   2516a:	bd38      	pop	{r3, r4, r5, pc}

0002516c <spi_context_unlock_unconditionally>:
{
   2516c:	b510      	push	{r4, lr}
	_spi_context_cs_control(ctx, false, true);
   2516e:	2201      	movs	r2, #1
   25170:	2100      	movs	r1, #0
{
   25172:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
   25174:	f7ff ffd0 	bl	25118 <_spi_context_cs_control.isra.7>
	if (!k_sem_count_get(&ctx->lock)) {
   25178:	68e3      	ldr	r3, [r4, #12]
   2517a:	b923      	cbnz	r3, 25186 <spi_context_unlock_unconditionally+0x1a>
	z_impl_k_sem_give(sem);
   2517c:	1d20      	adds	r0, r4, #4
}
   2517e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   25182:	f7f9 bdfb 	b.w	1ed7c <z_impl_k_sem_give>
   25186:	bd10      	pop	{r4, pc}

00025188 <spi_nrfx_release>:
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   25188:	6880      	ldr	r0, [r0, #8]
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   2518a:	6803      	ldr	r3, [r0, #0]
   2518c:	428b      	cmp	r3, r1
{
   2518e:	b510      	push	{r4, lr}
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   25190:	d106      	bne.n	251a0 <spi_nrfx_release+0x18>
	if (dev_data->busy) {
   25192:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
   25196:	b934      	cbnz	r4, 251a6 <spi_nrfx_release+0x1e>
	spi_context_unlock_unconditionally(&dev_data->ctx);
   25198:	f7ff ffe8 	bl	2516c <spi_context_unlock_unconditionally>
	return 0;
   2519c:	4620      	mov	r0, r4
}
   2519e:	bd10      	pop	{r4, pc}
		return -EINVAL;
   251a0:	f06f 0015 	mvn.w	r0, #21
   251a4:	e7fb      	b.n	2519e <spi_nrfx_release+0x16>
		return -EBUSY;
   251a6:	f06f 000f 	mvn.w	r0, #15
   251aa:	e7f8      	b.n	2519e <spi_nrfx_release+0x16>

000251ac <flash_nrf_write_protection>:
}
   251ac:	2000      	movs	r0, #0
   251ae:	4770      	bx	lr

000251b0 <is_regular_addr_valid>:
{
   251b0:	b538      	push	{r3, r4, r5, lr}
   251b2:	4604      	mov	r4, r0
   251b4:	460d      	mov	r5, r1
	size_t flash_size = nrfx_nvmc_flash_size_get();
   251b6:	f000 f89c 	bl	252f2 <nrfx_nvmc_flash_size_get>
	if (addr >= flash_size ||
   251ba:	4284      	cmp	r4, r0
   251bc:	d209      	bcs.n	251d2 <is_regular_addr_valid+0x22>
   251be:	2c00      	cmp	r4, #0
   251c0:	db07      	blt.n	251d2 <is_regular_addr_valid+0x22>
	    addr < 0 ||
   251c2:	42a8      	cmp	r0, r5
   251c4:	d305      	bcc.n	251d2 <is_regular_addr_valid+0x22>
	    (addr) + len > flash_size) {
   251c6:	442c      	add	r4, r5
	    len > flash_size ||
   251c8:	4284      	cmp	r4, r0
   251ca:	bf8c      	ite	hi
   251cc:	2000      	movhi	r0, #0
   251ce:	2001      	movls	r0, #1
}
   251d0:	bd38      	pop	{r3, r4, r5, pc}
		return false;
   251d2:	2000      	movs	r0, #0
   251d4:	e7fc      	b.n	251d0 <is_regular_addr_valid+0x20>

000251d6 <flash_nrf_read>:
{
   251d6:	b570      	push	{r4, r5, r6, lr}
   251d8:	460d      	mov	r5, r1
	if (is_regular_addr_valid(addr, len)) {
   251da:	4628      	mov	r0, r5
   251dc:	4619      	mov	r1, r3
{
   251de:	4616      	mov	r6, r2
   251e0:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
   251e2:	f7ff ffe5 	bl	251b0 <is_regular_addr_valid>
   251e6:	b138      	cbz	r0, 251f8 <flash_nrf_read+0x22>
	if (!len) {
   251e8:	b14c      	cbz	r4, 251fe <flash_nrf_read+0x28>
   251ea:	4622      	mov	r2, r4
   251ec:	4629      	mov	r1, r5
   251ee:	4630      	mov	r0, r6
   251f0:	f7dc fcfc 	bl	1bec <memcpy>
   251f4:	2000      	movs	r0, #0
}
   251f6:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   251f8:	f06f 0015 	mvn.w	r0, #21
   251fc:	e7fb      	b.n	251f6 <flash_nrf_read+0x20>
		return 0;
   251fe:	4620      	mov	r0, r4
   25200:	e7f9      	b.n	251f6 <flash_nrf_read+0x20>

00025202 <flash_get_page_info>:

#include <drivers/flash.h>

static int flash_get_page_info(struct device *dev, off_t offs,
				   bool use_addr, struct flash_pages_info *info)
{
   25202:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   25206:	461d      	mov	r5, r3
	off_t group_offs = 0;
	u32_t num_in_group;
	off_t end = 0;
	size_t layout_size;

	api->page_layout(dev, &layout, &layout_size);
   25208:	6843      	ldr	r3, [r0, #4]
{
   2520a:	460c      	mov	r4, r1
	api->page_layout(dev, &layout, &layout_size);
   2520c:	691b      	ldr	r3, [r3, #16]
   2520e:	4669      	mov	r1, sp
{
   25210:	4616      	mov	r6, r2
	api->page_layout(dev, &layout, &layout_size);
   25212:	aa01      	add	r2, sp, #4
   25214:	4798      	blx	r3

	while (layout_size--) {
   25216:	e9dd 1200 	ldrd	r1, r2, [sp]
   2521a:	2300      	movs	r3, #0
   2521c:	3a01      	subs	r2, #1
	off_t end = 0;
   2521e:	4618      	mov	r0, r3
	off_t group_offs = 0;
   25220:	469e      	mov	lr, r3
	size_t page_count = 0;
   25222:	469c      	mov	ip, r3
	while (layout_size--) {
   25224:	1c57      	adds	r7, r2, #1
   25226:	d102      	bne.n	2522e <flash_get_page_info+0x2c>
		page_count += layout->pages_count;

		layout++;
	}

	return -EINVAL; /* page of the index doesn't exist */
   25228:	f06f 0015 	mvn.w	r0, #21
   2522c:	e01a      	b.n	25264 <flash_get_page_info+0x62>
		if (use_addr) {
   2522e:	f8d1 8000 	ldr.w	r8, [r1]
   25232:	b1d6      	cbz	r6, 2526a <flash_get_page_info+0x68>
			end += layout->pages_count * layout->pages_size;
   25234:	684f      	ldr	r7, [r1, #4]
   25236:	fb07 0008 	mla	r0, r7, r8, r0
		if (offs < end) {
   2523a:	42a0      	cmp	r0, r4
   2523c:	f102 37ff 	add.w	r7, r2, #4294967295	; 0xffffffff
   25240:	dd18      	ble.n	25274 <flash_get_page_info+0x72>
   25242:	9201      	str	r2, [sp, #4]
   25244:	b103      	cbz	r3, 25248 <flash_get_page_info+0x46>
   25246:	9100      	str	r1, [sp, #0]
			info->size = layout->pages_size;
   25248:	9b00      	ldr	r3, [sp, #0]
   2524a:	685b      	ldr	r3, [r3, #4]
   2524c:	606b      	str	r3, [r5, #4]
			if (use_addr) {
   2524e:	b176      	cbz	r6, 2526e <flash_get_page_info+0x6c>
				num_in_group = (offs - group_offs) /
   25250:	eba4 040e 	sub.w	r4, r4, lr
   25254:	fbb4 f4f3 	udiv	r4, r4, r3
			info->start_offset = group_offs +
   25258:	fb04 e303 	mla	r3, r4, r3, lr
			info->index = page_count + num_in_group;
   2525c:	4464      	add	r4, ip
			info->start_offset = group_offs +
   2525e:	602b      	str	r3, [r5, #0]
			info->index = page_count + num_in_group;
   25260:	60ac      	str	r4, [r5, #8]
			return 0;
   25262:	2000      	movs	r0, #0
}
   25264:	b002      	add	sp, #8
   25266:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			end += layout->pages_count;
   2526a:	4440      	add	r0, r8
   2526c:	e7e5      	b.n	2523a <flash_get_page_info+0x38>
				num_in_group = offs - page_count;
   2526e:	eba4 040c 	sub.w	r4, r4, ip
   25272:	e7f1      	b.n	25258 <flash_get_page_info+0x56>
		group_offs += layout->pages_count * layout->pages_size;
   25274:	684b      	ldr	r3, [r1, #4]
		page_count += layout->pages_count;
   25276:	44c4      	add	ip, r8
		group_offs += layout->pages_count * layout->pages_size;
   25278:	fb03 ee08 	mla	lr, r3, r8, lr
		layout++;
   2527c:	3108      	adds	r1, #8
   2527e:	2301      	movs	r3, #1
   25280:	463a      	mov	r2, r7
   25282:	e7cf      	b.n	25224 <flash_get_page_info+0x22>

00025284 <z_impl_flash_get_page_info_by_offs>:

int z_impl_flash_get_page_info_by_offs(struct device *dev, off_t offs,
				      struct flash_pages_info *info)
{
	return flash_get_page_info(dev, offs, true, info);
   25284:	4613      	mov	r3, r2
   25286:	2201      	movs	r2, #1
   25288:	f7ff bfbb 	b.w	25202 <flash_get_page_info>

0002528c <flash_page_foreach>:

	return count;
}

void flash_page_foreach(struct device *dev, flash_page_cb cb, void *data)
{
   2528c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	const struct flash_pages_layout *layout;
	struct flash_pages_info page_info;
	size_t block, num_blocks, page = 0, i;
	off_t off = 0;

	api->page_layout(dev, &layout, &num_blocks);
   25290:	6843      	ldr	r3, [r0, #4]
{
   25292:	b086      	sub	sp, #24
   25294:	4689      	mov	r9, r1
   25296:	4692      	mov	sl, r2
	api->page_layout(dev, &layout, &num_blocks);
   25298:	691b      	ldr	r3, [r3, #16]
   2529a:	aa02      	add	r2, sp, #8
   2529c:	a901      	add	r1, sp, #4
   2529e:	4798      	blx	r3
	off_t off = 0;
   252a0:	2400      	movs	r4, #0
	size_t block, num_blocks, page = 0, i;
   252a2:	46a0      	mov	r8, r4

	for (block = 0; block < num_blocks; block++) {
   252a4:	4625      	mov	r5, r4
   252a6:	9b02      	ldr	r3, [sp, #8]
   252a8:	42ab      	cmp	r3, r5
   252aa:	d802      	bhi.n	252b2 <flash_page_foreach+0x26>

			off += page_info.size;
			page++;
		}
	}
}
   252ac:	b006      	add	sp, #24
   252ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		const struct flash_pages_layout *l = &layout[block];
   252b2:	9f01      	ldr	r7, [sp, #4]
   252b4:	eb07 07c5 	add.w	r7, r7, r5, lsl #3
		for (i = 0; i < l->pages_count; i++) {
   252b8:	2600      	movs	r6, #0
		page_info.size = l->pages_size;
   252ba:	687b      	ldr	r3, [r7, #4]
   252bc:	9304      	str	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
   252be:	683a      	ldr	r2, [r7, #0]
   252c0:	42b2      	cmp	r2, r6
   252c2:	eb08 0306 	add.w	r3, r8, r6
   252c6:	d802      	bhi.n	252ce <flash_page_foreach+0x42>
	for (block = 0; block < num_blocks; block++) {
   252c8:	3501      	adds	r5, #1
   252ca:	4698      	mov	r8, r3
   252cc:	e7eb      	b.n	252a6 <flash_page_foreach+0x1a>
			if (!cb(&page_info, data)) {
   252ce:	4651      	mov	r1, sl
   252d0:	a803      	add	r0, sp, #12
			page_info.start_offset = off;
   252d2:	9403      	str	r4, [sp, #12]
			page_info.index = page;
   252d4:	9305      	str	r3, [sp, #20]
			if (!cb(&page_info, data)) {
   252d6:	47c8      	blx	r9
   252d8:	2800      	cmp	r0, #0
   252da:	d0e7      	beq.n	252ac <flash_page_foreach+0x20>
			off += page_info.size;
   252dc:	9b04      	ldr	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
   252de:	3601      	adds	r6, #1
			off += page_info.size;
   252e0:	441c      	add	r4, r3
			page++;
   252e2:	e7ec      	b.n	252be <flash_page_foreach+0x32>

000252e4 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   252e4:	4700      	bx	r0

000252e6 <flash_total_size_get>:
   252e6:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   252ea:	6918      	ldr	r0, [r3, #16]
NRF_STATIC_INLINE uint32_t nrf_ficr_codesize_get(NRF_FICR_Type const * p_reg)
{
#if defined(FICR_INFO_CODESIZE_CODESIZE_Msk)
    return p_reg->INFO.CODESIZE;
#else
    return p_reg->CODESIZE;
   252ec:	695b      	ldr	r3, [r3, #20]
}
   252ee:	4358      	muls	r0, r3
   252f0:	4770      	bx	lr

000252f2 <nrfx_nvmc_flash_size_get>:
    nvmc_readonly_mode_set();
}

uint32_t nrfx_nvmc_flash_size_get(void)
{
    return flash_total_size_get();
   252f2:	f7ff bff8 	b.w	252e6 <flash_total_size_get>

000252f6 <nrfx_nvmc_flash_page_size_get>:
    return p_reg->CODEPAGESIZE;
   252f6:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   252fa:	6918      	ldr	r0, [r3, #16]
}

uint32_t nrfx_nvmc_flash_page_size_get(void)
{
    return flash_page_size_get();
}
   252fc:	4770      	bx	lr

000252fe <nrfx_nvmc_flash_page_count_get>:
    return p_reg->CODESIZE;
   252fe:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   25302:	6958      	ldr	r0, [r3, #20]

uint32_t nrfx_nvmc_flash_page_count_get(void)
{
    return flash_page_count_get();
}
   25304:	4770      	bx	lr

00025306 <transfer_byte>:
{
   25306:	b537      	push	{r0, r1, r2, r4, r5, lr}
    return p_reg->RXD;
   25308:	f8d0 3518 	ldr.w	r3, [r0, #1304]	; 0x518
    if (p_cb->bytes_transferred < p_cb->evt.xfer_desc.rx_length)
   2530c:	698a      	ldr	r2, [r1, #24]
   2530e:	b2db      	uxtb	r3, r3
    volatile uint8_t rx_data = nrf_spi_rxd_get(p_spi);
   25310:	f88d 3007 	strb.w	r3, [sp, #7]
    if (p_cb->bytes_transferred < p_cb->evt.xfer_desc.rx_length)
   25314:	6a4b      	ldr	r3, [r1, #36]	; 0x24
   25316:	4293      	cmp	r3, r2
        p_cb->evt.xfer_desc.p_rx_buffer[p_cb->bytes_transferred] = rx_data;
   25318:	bf3e      	ittt	cc
   2531a:	694a      	ldrcc	r2, [r1, #20]
   2531c:	f89d 4007 	ldrbcc.w	r4, [sp, #7]
   25320:	54d4      	strbcc	r4, [r2, r3]
    ++p_cb->bytes_transferred;
   25322:	6a4a      	ldr	r2, [r1, #36]	; 0x24
    if (p_cb->abort)
   25324:	f891 4028 	ldrb.w	r4, [r1, #40]	; 0x28
    ++p_cb->bytes_transferred;
   25328:	1c53      	adds	r3, r2, #1
   2532a:	624b      	str	r3, [r1, #36]	; 0x24
    size_t bytes_used = p_cb->bytes_transferred + 1;
   2532c:	3202      	adds	r2, #2
    if (p_cb->abort)
   2532e:	b13c      	cbz	r4, 25340 <transfer_byte+0x3a>
        if (bytes_used < p_cb->evt.xfer_desc.tx_length)
   25330:	690c      	ldr	r4, [r1, #16]
   25332:	42a2      	cmp	r2, r4
        if (bytes_used < p_cb->evt.xfer_desc.rx_length)
   25334:	698c      	ldr	r4, [r1, #24]
            p_cb->evt.xfer_desc.tx_length = bytes_used;
   25336:	bf38      	it	cc
   25338:	610a      	strcc	r2, [r1, #16]
        if (bytes_used < p_cb->evt.xfer_desc.rx_length)
   2533a:	4294      	cmp	r4, r2
            p_cb->evt.xfer_desc.rx_length = bytes_used;
   2533c:	bf88      	it	hi
   2533e:	618a      	strhi	r2, [r1, #24]
    if (bytes_used < p_cb->evt.xfer_desc.tx_length)
   25340:	690d      	ldr	r5, [r1, #16]
   25342:	4295      	cmp	r5, r2
   25344:	d905      	bls.n	25352 <transfer_byte+0x4c>
        nrf_spi_txd_set(p_spi, p_cb->evt.xfer_desc.p_tx_buffer[bytes_used]);
   25346:	68cb      	ldr	r3, [r1, #12]
    p_reg->TXD = data;
   25348:	5c9b      	ldrb	r3, [r3, r2]
   2534a:	f8c0 351c 	str.w	r3, [r0, #1308]	; 0x51c
    return (p_cb->bytes_transferred < p_cb->evt.xfer_desc.tx_length ||
   2534e:	2001      	movs	r0, #1
   25350:	e00b      	b.n	2536a <transfer_byte+0x64>
    else if (bytes_used < p_cb->evt.xfer_desc.rx_length)
   25352:	698c      	ldr	r4, [r1, #24]
   25354:	4294      	cmp	r4, r2
   25356:	d902      	bls.n	2535e <transfer_byte+0x58>
   25358:	f891 3020 	ldrb.w	r3, [r1, #32]
   2535c:	e7f5      	b.n	2534a <transfer_byte+0x44>
    return (p_cb->bytes_transferred < p_cb->evt.xfer_desc.tx_length ||
   2535e:	42ab      	cmp	r3, r5
   25360:	d3f5      	bcc.n	2534e <transfer_byte+0x48>
   25362:	42a3      	cmp	r3, r4
   25364:	bf2c      	ite	cs
   25366:	2000      	movcs	r0, #0
   25368:	2001      	movcc	r0, #1
}
   2536a:	b003      	add	sp, #12
   2536c:	bd30      	pop	{r4, r5, pc}

0002536e <nrf_gpio_pin_clear>:
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   2536e:	281f      	cmp	r0, #31
{
   25370:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   25372:	d901      	bls.n	25378 <nrf_gpio_pin_clear+0xa>
   25374:	f7f4 ffc6 	bl	1a304 <nrf_gpio_pin_port_decode.isra.0.part.1>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   25378:	2301      	movs	r3, #1
    p_reg->OUTCLR = clr_mask;
   2537a:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   2537e:	4083      	lsls	r3, r0
    p_reg->OUTCLR = clr_mask;
   25380:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
}
   25384:	bd08      	pop	{r3, pc}

00025386 <nrf_gpio_pin_set>:
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   25386:	281f      	cmp	r0, #31
{
   25388:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   2538a:	d901      	bls.n	25390 <nrf_gpio_pin_set+0xa>
   2538c:	f7f4 ffba 	bl	1a304 <nrf_gpio_pin_port_decode.isra.0.part.1>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   25390:	2301      	movs	r3, #1
    p_reg->OUTSET = set_mask;
   25392:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   25396:	4083      	lsls	r3, r0
    p_reg->OUTSET = set_mask;
   25398:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
}
   2539c:	bd08      	pop	{r3, pc}

0002539e <nrf_twi_event_clear>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2539e:	2300      	movs	r3, #0
   253a0:	5043      	str	r3, [r0, r1]
{
   253a2:	b082      	sub	sp, #8
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   253a4:	5843      	ldr	r3, [r0, r1]
   253a6:	9301      	str	r3, [sp, #4]
    (void)dummy;
   253a8:	9b01      	ldr	r3, [sp, #4]
}
   253aa:	b002      	add	sp, #8
   253ac:	4770      	bx	lr

000253ae <twi_send_byte>:
    if (p_cb->bytes_transferred < p_cb->curr_length)
   253ae:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   253b0:	6a8a      	ldr	r2, [r1, #40]	; 0x28
   253b2:	4293      	cmp	r3, r2
   253b4:	d208      	bcs.n	253c8 <twi_send_byte+0x1a>
        nrf_twi_txd_set(p_twi, p_cb->p_curr_buf[p_cb->bytes_transferred]);
   253b6:	6a4a      	ldr	r2, [r1, #36]	; 0x24
    p_reg->TXD = data;
   253b8:	5cd2      	ldrb	r2, [r2, r3]
   253ba:	f8c0 251c 	str.w	r2, [r0, #1308]	; 0x51c
        ++(p_cb->bytes_transferred);
   253be:	3301      	adds	r3, #1
   253c0:	634b      	str	r3, [r1, #52]	; 0x34
    return true;
   253c2:	2301      	movs	r3, #1
}
   253c4:	4618      	mov	r0, r3
   253c6:	4770      	bx	lr
        if (p_cb->curr_tx_no_stop)
   253c8:	f891 302c 	ldrb.w	r3, [r1, #44]	; 0x2c
   253cc:	b11b      	cbz	r3, 253d6 <twi_send_byte+0x28>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   253ce:	2301      	movs	r3, #1
   253d0:	61c3      	str	r3, [r0, #28]
            return false;
   253d2:	2300      	movs	r3, #0
   253d4:	e7f6      	b.n	253c4 <twi_send_byte+0x16>
        else if(TWI_FLAG_SUSPEND(p_cb->flags))
   253d6:	6a0a      	ldr	r2, [r1, #32]
   253d8:	f012 0f40 	tst.w	r2, #64	; 0x40
   253dc:	f04f 0201 	mov.w	r2, #1
   253e0:	bf15      	itete	ne
   253e2:	61c2      	strne	r2, [r0, #28]
   253e4:	6142      	streq	r2, [r0, #20]
            p_cb->prev_suspend = TWI_SUSPEND_TX;
   253e6:	f881 202d 	strbne.w	r2, [r1, #45]	; 0x2d
    return true;
   253ea:	4613      	moveq	r3, r2
   253ec:	e7ea      	b.n	253c4 <twi_send_byte+0x16>

000253ee <twi_transfer>:
    bool do_stop_check = ((p_cb->error) || ((p_cb->bytes_transferred) == p_cb->curr_length));
   253ee:	f891 202f 	ldrb.w	r2, [r1, #47]	; 0x2f
{
   253f2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   253f4:	4604      	mov	r4, r0
   253f6:	460d      	mov	r5, r1
    bool do_stop_check = ((p_cb->error) || ((p_cb->bytes_transferred) == p_cb->curr_length));
   253f8:	2a00      	cmp	r2, #0
   253fa:	d160      	bne.n	254be <twi_transfer+0xd0>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   253fc:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
   25400:	6b4e      	ldr	r6, [r1, #52]	; 0x34
   25402:	6a8f      	ldr	r7, [r1, #40]	; 0x28
    else if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_ERROR))
   25404:	b1b3      	cbz	r3, 25434 <twi_transfer+0x46>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
   25406:	f44f 7192 	mov.w	r1, #292	; 0x124
                nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
   2540a:	f7ff ffc8 	bl	2539e <nrf_twi_event_clear>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2540e:	2301      	movs	r3, #1
   25410:	6163      	str	r3, [r4, #20]
                p_cb->error = true;
   25412:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    if (do_stop_check && nrf_twi_event_check(p_twi, NRF_TWI_EVENT_STOPPED))
   25416:	42be      	cmp	r6, r7
   25418:	d14f      	bne.n	254ba <twi_transfer+0xcc>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2541a:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
   2541e:	2b00      	cmp	r3, #0
   25420:	d04b      	beq.n	254ba <twi_transfer+0xcc>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
   25422:	f44f 7182 	mov.w	r1, #260	; 0x104
   25426:	4620      	mov	r0, r4
   25428:	f7ff ffb9 	bl	2539e <nrf_twi_event_clear>
        p_cb->prev_suspend = TWI_NO_SUSPEND;
   2542c:	2200      	movs	r2, #0
   2542e:	f885 202d 	strb.w	r2, [r5, #45]	; 0x2d
        return false;
   25432:	e013      	b.n	2545c <twi_transfer+0x6e>
   25434:	f8d0 311c 	ldr.w	r3, [r0, #284]	; 0x11c
        if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_TXDSENT))
   25438:	b193      	cbz	r3, 25460 <twi_transfer+0x72>
            nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_TXDSENT);
   2543a:	f44f 718e 	mov.w	r1, #284	; 0x11c
   2543e:	f7ff ffae 	bl	2539e <nrf_twi_event_clear>
   25442:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
            if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_ERROR))
   25446:	b11b      	cbz	r3, 25450 <twi_transfer+0x62>
                nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
   25448:	f44f 7192 	mov.w	r1, #292	; 0x124
   2544c:	4620      	mov	r0, r4
   2544e:	e7dc      	b.n	2540a <twi_transfer+0x1c>
                if (!twi_send_byte(p_twi, p_cb))
   25450:	4629      	mov	r1, r5
   25452:	f7ff ffac 	bl	253ae <twi_send_byte>
   25456:	4602      	mov	r2, r0
   25458:	2800      	cmp	r0, #0
   2545a:	d1dc      	bne.n	25416 <twi_transfer+0x28>
}
   2545c:	4610      	mov	r0, r2
   2545e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   25460:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
        else if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_RXDREADY))
   25464:	2b00      	cmp	r3, #0
   25466:	d0d6      	beq.n	25416 <twi_transfer+0x28>
            nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_RXDREADY);
   25468:	f44f 7184 	mov.w	r1, #264	; 0x108
   2546c:	f7ff ff97 	bl	2539e <nrf_twi_event_clear>
   25470:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
            if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_ERROR))
   25474:	2b00      	cmp	r3, #0
   25476:	d1e7      	bne.n	25448 <twi_transfer+0x5a>
    if (p_cb->bytes_transferred < p_cb->curr_length)
   25478:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   2547a:	6aa9      	ldr	r1, [r5, #40]	; 0x28
   2547c:	428b      	cmp	r3, r1
   2547e:	d2ca      	bcs.n	25416 <twi_transfer+0x28>
        p_cb->p_curr_buf[p_cb->bytes_transferred] = nrf_twi_rxd_get(p_twi);
   25480:	6a69      	ldr	r1, [r5, #36]	; 0x24
    return (uint8_t)p_reg->RXD;
   25482:	f8d0 0518 	ldr.w	r0, [r0, #1304]	; 0x518
   25486:	54c8      	strb	r0, [r1, r3]
        ++(p_cb->bytes_transferred);
   25488:	6b6b      	ldr	r3, [r5, #52]	; 0x34
        if ((p_cb->bytes_transferred == p_cb->curr_length - 1) && (!TWI_FLAG_SUSPEND(p_cb->flags)))
   2548a:	6aa9      	ldr	r1, [r5, #40]	; 0x28
        ++(p_cb->bytes_transferred);
   2548c:	3301      	adds	r3, #1
        if ((p_cb->bytes_transferred == p_cb->curr_length - 1) && (!TWI_FLAG_SUSPEND(p_cb->flags)))
   2548e:	1e48      	subs	r0, r1, #1
   25490:	4283      	cmp	r3, r0
        ++(p_cb->bytes_transferred);
   25492:	636b      	str	r3, [r5, #52]	; 0x34
        if ((p_cb->bytes_transferred == p_cb->curr_length - 1) && (!TWI_FLAG_SUSPEND(p_cb->flags)))
   25494:	d108      	bne.n	254a8 <twi_transfer+0xba>
   25496:	6a28      	ldr	r0, [r5, #32]
   25498:	0640      	lsls	r0, r0, #25
   2549a:	d41d      	bmi.n	254d8 <twi_transfer+0xea>
    p_reg->SHORTS = mask;
   2549c:	2302      	movs	r3, #2
   2549e:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   254a2:	2301      	movs	r3, #1
   254a4:	6223      	str	r3, [r4, #32]
   254a6:	e7b6      	b.n	25416 <twi_transfer+0x28>
        else if (p_cb->bytes_transferred == p_cb->curr_length && (!TWI_FLAG_SUSPEND(p_cb->flags)))
   254a8:	428b      	cmp	r3, r1
   254aa:	d1fa      	bne.n	254a2 <twi_transfer+0xb4>
   254ac:	6a2b      	ldr	r3, [r5, #32]
   254ae:	065b      	lsls	r3, r3, #25
   254b0:	d5b1      	bpl.n	25416 <twi_transfer+0x28>
            p_cb->prev_suspend = TWI_SUSPEND_RX;
   254b2:	2302      	movs	r3, #2
   254b4:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
            return false;
   254b8:	e7d0      	b.n	2545c <twi_transfer+0x6e>
    return true;
   254ba:	2201      	movs	r2, #1
   254bc:	e7ce      	b.n	2545c <twi_transfer+0x6e>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
   254be:	f44f 7192 	mov.w	r1, #292	; 0x124
   254c2:	f7ff ff6c 	bl	2539e <nrf_twi_event_clear>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_TXDSENT);
   254c6:	f44f 718e 	mov.w	r1, #284	; 0x11c
   254ca:	f7ff ff68 	bl	2539e <nrf_twi_event_clear>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_RXDREADY);
   254ce:	f44f 7184 	mov.w	r1, #264	; 0x108
   254d2:	f7ff ff64 	bl	2539e <nrf_twi_event_clear>
    if (do_stop_check && nrf_twi_event_check(p_twi, NRF_TWI_EVENT_STOPPED))
   254d6:	e7a0      	b.n	2541a <twi_transfer+0x2c>
        else if (p_cb->bytes_transferred == p_cb->curr_length && (!TWI_FLAG_SUSPEND(p_cb->flags)))
   254d8:	428b      	cmp	r3, r1
   254da:	d1e2      	bne.n	254a2 <twi_transfer+0xb4>
   254dc:	e7e9      	b.n	254b2 <twi_transfer+0xc4>

000254de <lv_indev_reset.part.5>:
}
/**
 * Reset one or all input devices
 * @param indev pointer to an input device to reset or NULL to reset all of them
 */
void lv_indev_reset(lv_indev_t * indev)
   254de:	b508      	push	{r3, lr}
{
    if(indev)
        indev->proc.reset_query = 1;
    else {
        lv_indev_t * i = lv_indev_get_next(NULL);
   254e0:	2000      	movs	r0, #0
        while(i) {
            i->proc.reset_query = 1;

            i = lv_indev_get_next(i);
   254e2:	f7f7 faad 	bl	1ca40 <lv_indev_get_next>
        while(i) {
   254e6:	b900      	cbnz	r0, 254ea <lv_indev_reset.part.5+0xc>
        }
    }
}
   254e8:	bd08      	pop	{r3, pc}
            i->proc.reset_query = 1;
   254ea:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
   254ee:	f043 0302 	orr.w	r3, r3, #2
   254f2:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50
   254f6:	e7f4      	b.n	254e2 <lv_indev_reset.part.5+0x4>

000254f8 <lv_indev_init>:
    if(indev)
   254f8:	f7ff bff1 	b.w	254de <lv_indev_reset.part.5>

000254fc <refresh_children_position>:
 * @param obj pointer to an object which children will be repositioned
 * @param x_diff x coordinate shift
 * @param y_diff y coordinate shift
 */
static void refresh_children_position(lv_obj_t * obj, lv_coord_t x_diff, lv_coord_t y_diff)
{
   254fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    lv_obj_t * i;
    LV_LL_READ(obj->child_ll, i)
   254fe:	1d07      	adds	r7, r0, #4
   25500:	4638      	mov	r0, r7
{
   25502:	460d      	mov	r5, r1
   25504:	4616      	mov	r6, r2
    LV_LL_READ(obj->child_ll, i)
   25506:	f001 fed1 	bl	272ac <lv_ll_get_head>
   2550a:	4604      	mov	r4, r0
   2550c:	b900      	cbnz	r0, 25510 <refresh_children_position+0x14>
        i->coords.x2 += x_diff;
        i->coords.y2 += y_diff;

        refresh_children_position(i, x_diff, y_diff);
    }
}
   2550e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        i->coords.x1 += x_diff;
   25510:	8a23      	ldrh	r3, [r4, #16]
   25512:	442b      	add	r3, r5
   25514:	8223      	strh	r3, [r4, #16]
        i->coords.y1 += y_diff;
   25516:	8a63      	ldrh	r3, [r4, #18]
   25518:	4433      	add	r3, r6
   2551a:	8263      	strh	r3, [r4, #18]
        i->coords.x2 += x_diff;
   2551c:	8aa3      	ldrh	r3, [r4, #20]
   2551e:	442b      	add	r3, r5
   25520:	82a3      	strh	r3, [r4, #20]
        i->coords.y2 += y_diff;
   25522:	8ae3      	ldrh	r3, [r4, #22]
   25524:	4433      	add	r3, r6
        refresh_children_position(i, x_diff, y_diff);
   25526:	4629      	mov	r1, r5
   25528:	4620      	mov	r0, r4
        i->coords.y2 += y_diff;
   2552a:	82e3      	strh	r3, [r4, #22]
        refresh_children_position(i, x_diff, y_diff);
   2552c:	4632      	mov	r2, r6
   2552e:	f7ff ffe5 	bl	254fc <refresh_children_position>
    LV_LL_READ(obj->child_ll, i)
   25532:	4621      	mov	r1, r4
   25534:	4638      	mov	r0, r7
   25536:	f001 febf 	bl	272b8 <lv_ll_get_next>
   2553a:	e7e6      	b.n	2550a <refresh_children_position+0xe>

0002553c <lv_area_copy>:
   2553c:	680b      	ldr	r3, [r1, #0]
   2553e:	6003      	str	r3, [r0, #0]
   25540:	684b      	ldr	r3, [r1, #4]
   25542:	6043      	str	r3, [r0, #4]
}
   25544:	4770      	bx	lr

00025546 <lv_obj_set_click>:
    obj->click = (en == true ? 1 : 0);
   25546:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
   2554a:	f361 0300 	bfi	r3, r1, #0, #1
   2554e:	f880 302c 	strb.w	r3, [r0, #44]	; 0x2c
}
   25552:	4770      	bx	lr

00025554 <lv_obj_set_signal_cb>:
    obj->signal_cb = signal_cb;
   25554:	61c1      	str	r1, [r0, #28]
}
   25556:	4770      	bx	lr

00025558 <lv_obj_set_design_cb>:
    obj->design_cb = design_cb;
   25558:	6201      	str	r1, [r0, #32]
}
   2555a:	4770      	bx	lr

0002555c <lv_obj_allocate_ext_attr>:
{
   2555c:	b510      	push	{r4, lr}
   2555e:	4604      	mov	r4, r0
    obj->ext_attr = lv_mem_realloc(obj->ext_attr, ext_size);
   25560:	6a40      	ldr	r0, [r0, #36]	; 0x24
   25562:	f7f7 fbfb 	bl	1cd5c <lv_mem_realloc>
   25566:	6260      	str	r0, [r4, #36]	; 0x24
}
   25568:	bd10      	pop	{r4, pc}

0002556a <lv_obj_invalidate>:
    return obj->hidden == 0 ? false : true;
   2556a:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
    if(lv_obj_get_hidden(obj)) return;
   2556e:	06da      	lsls	r2, r3, #27
{
   25570:	b573      	push	{r0, r1, r4, r5, r6, lr}
   25572:	4605      	mov	r5, r0
    if(lv_obj_get_hidden(obj)) return;
   25574:	d438      	bmi.n	255e8 <lv_obj_invalidate+0x7e>
   25576:	4604      	mov	r4, r0
    return obj->par;
   25578:	6823      	ldr	r3, [r4, #0]
    } while(par != NULL);
   2557a:	bb4b      	cbnz	r3, 255d0 <lv_obj_invalidate+0x66>
    lv_disp_t * disp   = lv_obj_get_disp(obj_scr);
   2557c:	4620      	mov	r0, r4
   2557e:	f7f5 fb75 	bl	1ac6c <lv_obj_get_disp>
   25582:	4606      	mov	r6, r0
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
   25584:	f7f5 fafa 	bl	1ab7c <lv_disp_get_scr_act>
   25588:	4284      	cmp	r4, r0
   2558a:	d123      	bne.n	255d4 <lv_obj_invalidate+0x6a>
        lv_area_copy(&area_trunc, &obj->coords);
   2558c:	f105 0110 	add.w	r1, r5, #16
   25590:	4668      	mov	r0, sp
        lv_coord_t ext_size = obj->ext_draw_pad;
   25592:	f9b5 2030 	ldrsh.w	r2, [r5, #48]	; 0x30
    return obj->par;
   25596:	682c      	ldr	r4, [r5, #0]
        lv_area_copy(&area_trunc, &obj->coords);
   25598:	f7ff ffd0 	bl	2553c <lv_area_copy>
        area_trunc.x1 -= ext_size;
   2559c:	f8bd 3000 	ldrh.w	r3, [sp]
   255a0:	1a9b      	subs	r3, r3, r2
   255a2:	f8ad 3000 	strh.w	r3, [sp]
        area_trunc.y1 -= ext_size;
   255a6:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   255aa:	1a9b      	subs	r3, r3, r2
   255ac:	f8ad 3002 	strh.w	r3, [sp, #2]
        area_trunc.x2 += ext_size;
   255b0:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   255b4:	4413      	add	r3, r2
   255b6:	f8ad 3004 	strh.w	r3, [sp, #4]
        area_trunc.y2 += ext_size;
   255ba:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   255be:	441a      	add	r2, r3
   255c0:	f8ad 2006 	strh.w	r2, [sp, #6]
        while(par != NULL) {
   255c4:	b994      	cbnz	r4, 255ec <lv_obj_invalidate+0x82>
        if(union_ok) lv_inv_area(disp, &area_trunc);
   255c6:	4669      	mov	r1, sp
   255c8:	4630      	mov	r0, r6
   255ca:	f000 fb45 	bl	25c58 <lv_inv_area>
   255ce:	e00b      	b.n	255e8 <lv_obj_invalidate+0x7e>
    } while(par != NULL);
   255d0:	461c      	mov	r4, r3
   255d2:	e7d1      	b.n	25578 <lv_obj_invalidate+0xe>
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
   255d4:	4630      	mov	r0, r6
   255d6:	f7f5 fae7 	bl	1aba8 <lv_disp_get_layer_top>
   255da:	4284      	cmp	r4, r0
   255dc:	d0d6      	beq.n	2558c <lv_obj_invalidate+0x22>
       obj_scr == lv_disp_get_layer_sys(disp)) {
   255de:	4630      	mov	r0, r6
   255e0:	f7f5 faf8 	bl	1abd4 <lv_disp_get_layer_sys>
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
   255e4:	4284      	cmp	r4, r0
   255e6:	d0d1      	beq.n	2558c <lv_obj_invalidate+0x22>
}
   255e8:	b002      	add	sp, #8
   255ea:	bd70      	pop	{r4, r5, r6, pc}
            union_ok = lv_area_intersect(&area_trunc, &area_trunc, &par->coords);
   255ec:	f104 0210 	add.w	r2, r4, #16
   255f0:	4669      	mov	r1, sp
   255f2:	4668      	mov	r0, sp
   255f4:	f001 fd69 	bl	270ca <lv_area_intersect>
            if(union_ok == false) break;       /*If no common parts with parent break;*/
   255f8:	2800      	cmp	r0, #0
   255fa:	d0f5      	beq.n	255e8 <lv_obj_invalidate+0x7e>
    return obj->hidden == 0 ? false : true;
   255fc:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
            if(lv_obj_get_hidden(par)) return; /*If the parent is hidden then the child is hidden and won't be drawn*/
   25600:	06db      	lsls	r3, r3, #27
   25602:	d4f1      	bmi.n	255e8 <lv_obj_invalidate+0x7e>
    return obj->par;
   25604:	6824      	ldr	r4, [r4, #0]
   25606:	e7dd      	b.n	255c4 <lv_obj_invalidate+0x5a>

00025608 <lv_obj_set_pos>:
{
   25608:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    lv_obj_t * par = obj->par;
   2560a:	6807      	ldr	r7, [r0, #0]
    diff.x = x - obj->coords.x1;
   2560c:	8a03      	ldrh	r3, [r0, #16]
   2560e:	8a3d      	ldrh	r5, [r7, #16]
    diff.y = y - obj->coords.y1;
   25610:	8a7e      	ldrh	r6, [r7, #18]
    diff.x = x - obj->coords.x1;
   25612:	1aed      	subs	r5, r5, r3
    diff.y = y - obj->coords.y1;
   25614:	8a43      	ldrh	r3, [r0, #18]
   25616:	1af6      	subs	r6, r6, r3
    diff.x = x - obj->coords.x1;
   25618:	440d      	add	r5, r1
    diff.y = y - obj->coords.y1;
   2561a:	4416      	add	r6, r2
    diff.x = x - obj->coords.x1;
   2561c:	b22d      	sxth	r5, r5
    diff.y = y - obj->coords.y1;
   2561e:	b236      	sxth	r6, r6
    if(diff.x == 0 && diff.y == 0) return;
   25620:	ea55 0306 	orrs.w	r3, r5, r6
{
   25624:	4604      	mov	r4, r0
    if(diff.x == 0 && diff.y == 0) return;
   25626:	d024      	beq.n	25672 <lv_obj_set_pos+0x6a>
    lv_obj_invalidate(obj);
   25628:	f7ff ff9f 	bl	2556a <lv_obj_invalidate>
    lv_area_copy(cords_p, &obj->coords);
   2562c:	f104 0110 	add.w	r1, r4, #16
   25630:	4668      	mov	r0, sp
   25632:	f7ff ff83 	bl	2553c <lv_area_copy>
    obj->coords.x1 += diff.x;
   25636:	8a23      	ldrh	r3, [r4, #16]
   25638:	442b      	add	r3, r5
   2563a:	8223      	strh	r3, [r4, #16]
    obj->coords.y1 += diff.y;
   2563c:	8a63      	ldrh	r3, [r4, #18]
   2563e:	4433      	add	r3, r6
   25640:	8263      	strh	r3, [r4, #18]
    obj->coords.x2 += diff.x;
   25642:	8aa3      	ldrh	r3, [r4, #20]
   25644:	442b      	add	r3, r5
   25646:	82a3      	strh	r3, [r4, #20]
    obj->coords.y2 += diff.y;
   25648:	8ae3      	ldrh	r3, [r4, #22]
   2564a:	4433      	add	r3, r6
   2564c:	82e3      	strh	r3, [r4, #22]
    refresh_children_position(obj, diff.x, diff.y);
   2564e:	4632      	mov	r2, r6
   25650:	4629      	mov	r1, r5
   25652:	4620      	mov	r0, r4
   25654:	f7ff ff52 	bl	254fc <refresh_children_position>
    obj->signal_cb(obj, LV_SIGNAL_CORD_CHG, &ori);
   25658:	69e3      	ldr	r3, [r4, #28]
   2565a:	466a      	mov	r2, sp
   2565c:	2102      	movs	r1, #2
   2565e:	4620      	mov	r0, r4
   25660:	4798      	blx	r3
    par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
   25662:	69fb      	ldr	r3, [r7, #28]
   25664:	4622      	mov	r2, r4
   25666:	2101      	movs	r1, #1
   25668:	4638      	mov	r0, r7
   2566a:	4798      	blx	r3
    lv_obj_invalidate(obj);
   2566c:	4620      	mov	r0, r4
   2566e:	f7ff ff7c 	bl	2556a <lv_obj_invalidate>
}
   25672:	b003      	add	sp, #12
   25674:	bdf0      	pop	{r4, r5, r6, r7, pc}

00025676 <lv_obj_refresh_style>:
{
   25676:	b510      	push	{r4, lr}
   25678:	4604      	mov	r4, r0
    lv_obj_invalidate(obj);
   2567a:	f7ff ff76 	bl	2556a <lv_obj_invalidate>
    obj->signal_cb(obj, LV_SIGNAL_STYLE_CHG, NULL);
   2567e:	69e3      	ldr	r3, [r4, #28]
   25680:	4620      	mov	r0, r4
   25682:	2200      	movs	r2, #0
   25684:	2104      	movs	r1, #4
   25686:	4798      	blx	r3
    lv_obj_invalidate(obj);
   25688:	4620      	mov	r0, r4
}
   2568a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    lv_obj_invalidate(obj);
   2568e:	f7ff bf6c 	b.w	2556a <lv_obj_invalidate>

00025692 <lv_obj_refresh_ext_draw_pad>:
{
   25692:	b510      	push	{r4, lr}
    obj->ext_draw_pad = 0;
   25694:	2200      	movs	r2, #0
{
   25696:	4604      	mov	r4, r0
    obj->ext_draw_pad = 0;
   25698:	8602      	strh	r2, [r0, #48]	; 0x30
    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);
   2569a:	69c3      	ldr	r3, [r0, #28]
   2569c:	2106      	movs	r1, #6
   2569e:	4798      	blx	r3
    lv_obj_invalidate(obj);
   256a0:	4620      	mov	r0, r4
}
   256a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    lv_obj_invalidate(obj);
   256a6:	f7ff bf60 	b.w	2556a <lv_obj_invalidate>

000256aa <lv_obj_set_size>:
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   256aa:	8a83      	ldrh	r3, [r0, #20]
{
   256ac:	b573      	push	{r0, r1, r4, r5, r6, lr}
   256ae:	4616      	mov	r6, r2
   256b0:	8a02      	ldrh	r2, [r0, #16]
   256b2:	3301      	adds	r3, #1
   256b4:	1a9b      	subs	r3, r3, r2
    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {
   256b6:	b21b      	sxth	r3, r3
   256b8:	428b      	cmp	r3, r1
{
   256ba:	4604      	mov	r4, r0
   256bc:	460d      	mov	r5, r1
    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {
   256be:	d106      	bne.n	256ce <lv_obj_set_size+0x24>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   256c0:	8ac3      	ldrh	r3, [r0, #22]
   256c2:	8a42      	ldrh	r2, [r0, #18]
   256c4:	3301      	adds	r3, #1
   256c6:	1a9b      	subs	r3, r3, r2
   256c8:	b21b      	sxth	r3, r3
   256ca:	429e      	cmp	r6, r3
   256cc:	d023      	beq.n	25716 <lv_obj_set_size+0x6c>
    lv_obj_invalidate(obj);
   256ce:	4620      	mov	r0, r4
   256d0:	f7ff ff4b 	bl	2556a <lv_obj_invalidate>
    lv_area_copy(cords_p, &obj->coords);
   256d4:	f104 0110 	add.w	r1, r4, #16
   256d8:	4668      	mov	r0, sp
   256da:	f7ff ff2f 	bl	2553c <lv_area_copy>
    obj->coords.y2 = obj->coords.y1 + h - 1;
   256de:	8a62      	ldrh	r2, [r4, #18]
        obj->coords.x2 = obj->coords.x1 + w - 1;
   256e0:	8a23      	ldrh	r3, [r4, #16]
    obj->coords.y2 = obj->coords.y1 + h - 1;
   256e2:	3e01      	subs	r6, #1
        obj->coords.x2 = obj->coords.x1 + w - 1;
   256e4:	3d01      	subs	r5, #1
    obj->coords.y2 = obj->coords.y1 + h - 1;
   256e6:	4416      	add	r6, r2
        obj->coords.x2 = obj->coords.x1 + w - 1;
   256e8:	441d      	add	r5, r3
    obj->coords.y2 = obj->coords.y1 + h - 1;
   256ea:	82e6      	strh	r6, [r4, #22]
        obj->coords.x2 = obj->coords.x1 + w - 1;
   256ec:	82a5      	strh	r5, [r4, #20]
    obj->signal_cb(obj, LV_SIGNAL_CORD_CHG, &ori);
   256ee:	69e3      	ldr	r3, [r4, #28]
   256f0:	466a      	mov	r2, sp
   256f2:	2102      	movs	r1, #2
   256f4:	4620      	mov	r0, r4
   256f6:	4798      	blx	r3
    return obj->par;
   256f8:	6820      	ldr	r0, [r4, #0]
    if(par != NULL) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
   256fa:	b118      	cbz	r0, 25704 <lv_obj_set_size+0x5a>
   256fc:	69c3      	ldr	r3, [r0, #28]
   256fe:	4622      	mov	r2, r4
   25700:	2101      	movs	r1, #1
   25702:	4798      	blx	r3
    LV_LL_READ(obj->child_ll, i)
   25704:	1d26      	adds	r6, r4, #4
   25706:	4630      	mov	r0, r6
   25708:	f001 fdd0 	bl	272ac <lv_ll_get_head>
   2570c:	4605      	mov	r5, r0
   2570e:	b920      	cbnz	r0, 2571a <lv_obj_set_size+0x70>
    lv_obj_invalidate(obj);
   25710:	4620      	mov	r0, r4
   25712:	f7ff ff2a 	bl	2556a <lv_obj_invalidate>
}
   25716:	b002      	add	sp, #8
   25718:	bd70      	pop	{r4, r5, r6, pc}
        i->signal_cb(i, LV_SIGNAL_PARENT_SIZE_CHG, NULL);
   2571a:	69eb      	ldr	r3, [r5, #28]
   2571c:	2200      	movs	r2, #0
   2571e:	2103      	movs	r1, #3
   25720:	4628      	mov	r0, r5
   25722:	4798      	blx	r3
    LV_LL_READ(obj->child_ll, i)
   25724:	4629      	mov	r1, r5
   25726:	4630      	mov	r0, r6
   25728:	f001 fdc6 	bl	272b8 <lv_ll_get_next>
   2572c:	e7ee      	b.n	2570c <lv_obj_set_size+0x62>

0002572e <lv_obj_set_width>:
   2572e:	8ac2      	ldrh	r2, [r0, #22]
   25730:	8a43      	ldrh	r3, [r0, #18]
   25732:	3201      	adds	r2, #1
   25734:	1ad2      	subs	r2, r2, r3
    lv_obj_set_size(obj, w, lv_obj_get_height(obj));
   25736:	b212      	sxth	r2, r2
   25738:	f7ff bfb7 	b.w	256aa <lv_obj_set_size>

0002573c <lv_obj_set_height>:
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   2573c:	8a83      	ldrh	r3, [r0, #20]
   2573e:	8a02      	ldrh	r2, [r0, #16]
   25740:	3301      	adds	r3, #1
   25742:	1a9b      	subs	r3, r3, r2
    lv_obj_set_size(obj, lv_obj_get_width(obj), h);
   25744:	460a      	mov	r2, r1
   25746:	b219      	sxth	r1, r3
   25748:	f7ff bfaf 	b.w	256aa <lv_obj_set_size>

0002574c <lv_obj_get_parent>:
}
   2574c:	6800      	ldr	r0, [r0, #0]
   2574e:	4770      	bx	lr

00025750 <lv_obj_get_child>:
    if(child == NULL) {
   25750:	3004      	adds	r0, #4
   25752:	b909      	cbnz	r1, 25758 <lv_obj_get_child+0x8>
        result = lv_ll_get_head(&obj->child_ll);
   25754:	f001 bdaa 	b.w	272ac <lv_ll_get_head>
        result = lv_ll_get_next(&obj->child_ll, child);
   25758:	f001 bdae 	b.w	272b8 <lv_ll_get_next>

0002575c <refresh_children_style>:
 * Recursively refresh the style of the children. Go deeper until a not NULL style is found
 * because the NULL styles are inherited from the parent
 * @param obj pointer to an object
 */
static void refresh_children_style(lv_obj_t * obj)
{
   2575c:	b538      	push	{r3, r4, r5, lr}
   2575e:	4605      	mov	r5, r0
        result = lv_ll_get_head(&obj->child_ll);
   25760:	3004      	adds	r0, #4
   25762:	f001 fda3 	bl	272ac <lv_ll_get_head>
            lv_obj_refresh_style(child);   /*Notify the child about the style change*/
        } else if(child->style_p->glass) {
            /*Children with 'glass' parent might be effected if their style == NULL*/
            refresh_children_style(child);
        }
        child = lv_obj_get_child(obj, child);
   25766:	4604      	mov	r4, r0
    while(child != NULL) {
   25768:	b900      	cbnz	r0, 2576c <refresh_children_style+0x10>
    }
}
   2576a:	bd38      	pop	{r3, r4, r5, pc}
        if(child->style_p == NULL) {
   2576c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   2576e:	b953      	cbnz	r3, 25786 <refresh_children_style+0x2a>
            refresh_children_style(child); /*Check children too*/
   25770:	4620      	mov	r0, r4
   25772:	f7ff fff3 	bl	2575c <refresh_children_style>
            lv_obj_refresh_style(child);   /*Notify the child about the style change*/
   25776:	4620      	mov	r0, r4
   25778:	f7ff ff7d 	bl	25676 <lv_obj_refresh_style>
        child = lv_obj_get_child(obj, child);
   2577c:	4621      	mov	r1, r4
   2577e:	4628      	mov	r0, r5
   25780:	f7ff ffe6 	bl	25750 <lv_obj_get_child>
   25784:	e7ef      	b.n	25766 <refresh_children_style+0xa>
        } else if(child->style_p->glass) {
   25786:	781b      	ldrb	r3, [r3, #0]
   25788:	07db      	lsls	r3, r3, #31
   2578a:	d5f7      	bpl.n	2577c <refresh_children_style+0x20>
            refresh_children_style(child);
   2578c:	4620      	mov	r0, r4
   2578e:	f7ff ffe5 	bl	2575c <refresh_children_style>
   25792:	e7f3      	b.n	2577c <refresh_children_style+0x20>

00025794 <lv_obj_set_style>:
{
   25794:	b510      	push	{r4, lr}
   25796:	4604      	mov	r4, r0
    obj->style_p = style;
   25798:	6281      	str	r1, [r0, #40]	; 0x28
    refresh_children_style(obj);
   2579a:	f7ff ffdf 	bl	2575c <refresh_children_style>
    lv_obj_refresh_style(obj);
   2579e:	4620      	mov	r0, r4
}
   257a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    lv_obj_refresh_style(obj);
   257a4:	f7ff bf67 	b.w	25676 <lv_obj_refresh_style>

000257a8 <lv_obj_get_coords>:
{
   257a8:	460b      	mov	r3, r1
    lv_area_copy(cords_p, &obj->coords);
   257aa:	f100 0110 	add.w	r1, r0, #16
   257ae:	4618      	mov	r0, r3
   257b0:	f7ff bec4 	b.w	2553c <lv_area_copy>

000257b4 <lv_obj_get_x>:
    return obj->par;
   257b4:	6803      	ldr	r3, [r0, #0]
    if(parent) {
   257b6:	f9b0 0010 	ldrsh.w	r0, [r0, #16]
   257ba:	b113      	cbz	r3, 257c2 <lv_obj_get_x+0xe>
        rel_x             = obj->coords.x1 - parent->coords.x1;
   257bc:	8a1b      	ldrh	r3, [r3, #16]
   257be:	1ac0      	subs	r0, r0, r3
   257c0:	b200      	sxth	r0, r0
}
   257c2:	4770      	bx	lr

000257c4 <lv_obj_get_y>:
    return obj->par;
   257c4:	6803      	ldr	r3, [r0, #0]
   if(parent) {
   257c6:	f9b0 0012 	ldrsh.w	r0, [r0, #18]
   257ca:	b113      	cbz	r3, 257d2 <lv_obj_get_y+0xe>
       rel_y             = obj->coords.y1 - parent->coords.y1;
   257cc:	8a5b      	ldrh	r3, [r3, #18]
   257ce:	1ac0      	subs	r0, r0, r3
   257d0:	b200      	sxth	r0, r0
}
   257d2:	4770      	bx	lr

000257d4 <lv_obj_align>:
{
   257d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   257d8:	4606      	mov	r6, r0
   257da:	461f      	mov	r7, r3
    lv_coord_t new_x = lv_obj_get_x(obj);
   257dc:	f7ff ffea 	bl	257b4 <lv_obj_get_x>
   257e0:	4605      	mov	r5, r0
    lv_coord_t new_y = lv_obj_get_y(obj);
   257e2:	4630      	mov	r0, r6
   257e4:	f7ff ffee 	bl	257c4 <lv_obj_get_y>
    if(base == NULL) {
   257e8:	f8d6 e000 	ldr.w	lr, [r6]
{
   257ec:	f9bd 8018 	ldrsh.w	r8, [sp, #24]
   257f0:	2900      	cmp	r1, #0
   257f2:	bf08      	it	eq
   257f4:	4671      	moveq	r1, lr
    switch(align) {
   257f6:	f9b1 3012 	ldrsh.w	r3, [r1, #18]
   257fa:	f9b1 c010 	ldrsh.w	ip, [r1, #16]
   257fe:	2a14      	cmp	r2, #20
   25800:	d818      	bhi.n	25834 <lv_obj_align+0x60>
   25802:	e8df f012 	tbh	[pc, r2, lsl #1]
   25806:	0029      	.short	0x0029
   25808:	004c0015 	.word	0x004c0015
   2580c:	00680060 	.word	0x00680060
   25810:	00880070 	.word	0x00880070
   25814:	00a10090 	.word	0x00a10090
   25818:	00ae00a9 	.word	0x00ae00a9
   2581c:	00ce00c6 	.word	0x00ce00c6
   25820:	00e700d1 	.word	0x00e700d1
   25824:	00f400ef 	.word	0x00f400ef
   25828:	00fe00f9 	.word	0x00fe00f9
   2582c:	01040101 	.word	0x01040101
            new_y = 0;
   25830:	2000      	movs	r0, #0
            new_x = 0;
   25832:	2500      	movs	r5, #0
    new_y -= par_abs_y;
   25834:	f8be 2012 	ldrh.w	r2, [lr, #18]
    new_x -= par_abs_x;
   25838:	f8be 1010 	ldrh.w	r1, [lr, #16]
    new_y -= par_abs_y;
   2583c:	eba8 0202 	sub.w	r2, r8, r2
    new_x -= par_abs_x;
   25840:	1a79      	subs	r1, r7, r1
    new_y -= par_abs_y;
   25842:	441a      	add	r2, r3
    new_x -= par_abs_x;
   25844:	4461      	add	r1, ip
    new_y -= par_abs_y;
   25846:	4402      	add	r2, r0
    new_x -= par_abs_x;
   25848:	4429      	add	r1, r5
    lv_obj_set_pos(obj, new_x, new_y);
   2584a:	4630      	mov	r0, r6
   2584c:	b212      	sxth	r2, r2
   2584e:	b209      	sxth	r1, r1
}
   25850:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    lv_obj_set_pos(obj, new_x, new_y);
   25854:	f7ff bed8 	b.w	25608 <lv_obj_set_pos>
   25858:	8ab5      	ldrh	r5, [r6, #20]
   2585a:	8a32      	ldrh	r2, [r6, #16]
   2585c:	3501      	adds	r5, #1
   2585e:	1aad      	subs	r5, r5, r2
   25860:	8a8a      	ldrh	r2, [r1, #20]
   25862:	3201      	adds	r2, #1
   25864:	eba2 020c 	sub.w	r2, r2, ip
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
   25868:	b212      	sxth	r2, r2
   2586a:	b22d      	sxth	r5, r5
   2586c:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
   25870:	eb05 70d5 	add.w	r0, r5, r5, lsr #31
   25874:	1055      	asrs	r5, r2, #1
   25876:	eba5 0560 	sub.w	r5, r5, r0, asr #1
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   2587a:	8acc      	ldrh	r4, [r1, #22]
   2587c:	8af0      	ldrh	r0, [r6, #22]
   2587e:	8a72      	ldrh	r2, [r6, #18]
   25880:	3401      	adds	r4, #1
   25882:	3001      	adds	r0, #1
   25884:	1ae4      	subs	r4, r4, r3
   25886:	1a80      	subs	r0, r0, r2
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
   25888:	b224      	sxth	r4, r4
   2588a:	b200      	sxth	r0, r0
   2588c:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
   25890:	eb00 72d0 	add.w	r2, r0, r0, lsr #31
   25894:	1060      	asrs	r0, r4, #1
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   25896:	b22d      	sxth	r5, r5
   25898:	eba0 0062 	sub.w	r0, r0, r2, asr #1
   2589c:	e077      	b.n	2598e <lv_obj_align+0x1ba>
   2589e:	8ab5      	ldrh	r5, [r6, #20]
   258a0:	8a32      	ldrh	r2, [r6, #16]
   258a2:	3501      	adds	r5, #1
   258a4:	1aad      	subs	r5, r5, r2
   258a6:	8a8a      	ldrh	r2, [r1, #20]
   258a8:	3201      	adds	r2, #1
   258aa:	eba2 020c 	sub.w	r2, r2, ip
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
   258ae:	b212      	sxth	r2, r2
   258b0:	b22d      	sxth	r5, r5
   258b2:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
   258b6:	eb05 70d5 	add.w	r0, r5, r5, lsr #31
   258ba:	1055      	asrs	r5, r2, #1
   258bc:	eba5 0560 	sub.w	r5, r5, r0, asr #1
   258c0:	b22d      	sxth	r5, r5
            new_y = 0;
   258c2:	2000      	movs	r0, #0
            break;
   258c4:	e7b6      	b.n	25834 <lv_obj_align+0x60>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
   258c6:	8a35      	ldrh	r5, [r6, #16]
   258c8:	8ab2      	ldrh	r2, [r6, #20]
   258ca:	8a89      	ldrh	r1, [r1, #20]
   258cc:	1aad      	subs	r5, r5, r2
   258ce:	440d      	add	r5, r1
   258d0:	eba5 050c 	sub.w	r5, r5, ip
   258d4:	e7f4      	b.n	258c0 <lv_obj_align+0xec>
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
   258d6:	8af2      	ldrh	r2, [r6, #22]
   258d8:	8a70      	ldrh	r0, [r6, #18]
   258da:	1a80      	subs	r0, r0, r2
   258dc:	8aca      	ldrh	r2, [r1, #22]
   258de:	4410      	add	r0, r2
   258e0:	1ac0      	subs	r0, r0, r3
   258e2:	b200      	sxth	r0, r0
   258e4:	e7a5      	b.n	25832 <lv_obj_align+0x5e>
   258e6:	8ab5      	ldrh	r5, [r6, #20]
   258e8:	8a32      	ldrh	r2, [r6, #16]
   258ea:	3501      	adds	r5, #1
   258ec:	1aad      	subs	r5, r5, r2
   258ee:	8a8a      	ldrh	r2, [r1, #20]
   258f0:	3201      	adds	r2, #1
   258f2:	eba2 020c 	sub.w	r2, r2, ip
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
   258f6:	b212      	sxth	r2, r2
   258f8:	b22d      	sxth	r5, r5
   258fa:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
   258fe:	eb05 70d5 	add.w	r0, r5, r5, lsr #31
   25902:	1055      	asrs	r5, r2, #1
   25904:	eba5 0560 	sub.w	r5, r5, r0, asr #1
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
   25908:	8af2      	ldrh	r2, [r6, #22]
   2590a:	8a70      	ldrh	r0, [r6, #18]
   2590c:	1a80      	subs	r0, r0, r2
   2590e:	8aca      	ldrh	r2, [r1, #22]
   25910:	b22d      	sxth	r5, r5
   25912:	4410      	add	r0, r2
   25914:	e05c      	b.n	259d0 <lv_obj_align+0x1fc>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
   25916:	8ab2      	ldrh	r2, [r6, #20]
   25918:	8a35      	ldrh	r5, [r6, #16]
   2591a:	1aad      	subs	r5, r5, r2
   2591c:	8a8a      	ldrh	r2, [r1, #20]
   2591e:	4415      	add	r5, r2
   25920:	eba5 050c 	sub.w	r5, r5, ip
   25924:	e7f0      	b.n	25908 <lv_obj_align+0x134>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   25926:	8acc      	ldrh	r4, [r1, #22]
   25928:	8af0      	ldrh	r0, [r6, #22]
   2592a:	8a72      	ldrh	r2, [r6, #18]
   2592c:	3401      	adds	r4, #1
   2592e:	3001      	adds	r0, #1
   25930:	1ae4      	subs	r4, r4, r3
   25932:	1a80      	subs	r0, r0, r2
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
   25934:	b224      	sxth	r4, r4
   25936:	b200      	sxth	r0, r0
   25938:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
   2593c:	eb00 72d0 	add.w	r2, r0, r0, lsr #31
   25940:	1060      	asrs	r0, r4, #1
   25942:	eba0 0062 	sub.w	r0, r0, r2, asr #1
   25946:	e7cc      	b.n	258e2 <lv_obj_align+0x10e>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
   25948:	8ab2      	ldrh	r2, [r6, #20]
   2594a:	8a35      	ldrh	r5, [r6, #16]
   2594c:	1aad      	subs	r5, r5, r2
   2594e:	8a8a      	ldrh	r2, [r1, #20]
   25950:	4415      	add	r5, r2
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   25952:	eba5 050c 	sub.w	r5, r5, ip
   25956:	e790      	b.n	2587a <lv_obj_align+0xa6>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   25958:	8af0      	ldrh	r0, [r6, #22]
   2595a:	1c42      	adds	r2, r0, #1
   2595c:	8a70      	ldrh	r0, [r6, #18]
            new_y = -lv_obj_get_height(obj);
   2595e:	1a80      	subs	r0, r0, r2
   25960:	e7bf      	b.n	258e2 <lv_obj_align+0x10e>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   25962:	8ab5      	ldrh	r5, [r6, #20]
   25964:	8a32      	ldrh	r2, [r6, #16]
   25966:	3501      	adds	r5, #1
   25968:	1aad      	subs	r5, r5, r2
   2596a:	8a8a      	ldrh	r2, [r1, #20]
   2596c:	3201      	adds	r2, #1
   2596e:	eba2 020c 	sub.w	r2, r2, ip
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
   25972:	b212      	sxth	r2, r2
   25974:	b22d      	sxth	r5, r5
   25976:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
   2597a:	eb05 70d5 	add.w	r0, r5, r5, lsr #31
   2597e:	1055      	asrs	r5, r2, #1
   25980:	eba5 0560 	sub.w	r5, r5, r0, asr #1
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   25984:	8af0      	ldrh	r0, [r6, #22]
   25986:	1c42      	adds	r2, r0, #1
   25988:	8a70      	ldrh	r0, [r6, #18]
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
   2598a:	b22d      	sxth	r5, r5
            new_y = -lv_obj_get_height(obj);
   2598c:	1a80      	subs	r0, r0, r2
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
   2598e:	b200      	sxth	r0, r0
            break;
   25990:	e750      	b.n	25834 <lv_obj_align+0x60>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
   25992:	8a35      	ldrh	r5, [r6, #16]
   25994:	8ab2      	ldrh	r2, [r6, #20]
   25996:	8a89      	ldrh	r1, [r1, #20]
   25998:	1aad      	subs	r5, r5, r2
   2599a:	440d      	add	r5, r1
   2599c:	eba5 050c 	sub.w	r5, r5, ip
   259a0:	e7f0      	b.n	25984 <lv_obj_align+0x1b0>
   259a2:	8ac8      	ldrh	r0, [r1, #22]
   259a4:	3001      	adds	r0, #1
   259a6:	e79b      	b.n	258e0 <lv_obj_align+0x10c>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   259a8:	8ab5      	ldrh	r5, [r6, #20]
   259aa:	8a32      	ldrh	r2, [r6, #16]
   259ac:	3501      	adds	r5, #1
   259ae:	1aad      	subs	r5, r5, r2
   259b0:	8a8a      	ldrh	r2, [r1, #20]
   259b2:	3201      	adds	r2, #1
   259b4:	eba2 020c 	sub.w	r2, r2, ip
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
   259b8:	b212      	sxth	r2, r2
   259ba:	b22d      	sxth	r5, r5
   259bc:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
   259c0:	eb05 70d5 	add.w	r0, r5, r5, lsr #31
   259c4:	1055      	asrs	r5, r2, #1
   259c6:	eba5 0560 	sub.w	r5, r5, r0, asr #1
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   259ca:	8ac8      	ldrh	r0, [r1, #22]
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
   259cc:	b22d      	sxth	r5, r5
   259ce:	3001      	adds	r0, #1
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
   259d0:	1ac0      	subs	r0, r0, r3
   259d2:	e7dc      	b.n	2598e <lv_obj_align+0x1ba>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
   259d4:	8ab2      	ldrh	r2, [r6, #20]
   259d6:	8a35      	ldrh	r5, [r6, #16]
   259d8:	1aad      	subs	r5, r5, r2
   259da:	8a8a      	ldrh	r2, [r1, #20]
   259dc:	4415      	add	r5, r2
   259de:	eba5 050c 	sub.w	r5, r5, ip
   259e2:	e7f2      	b.n	259ca <lv_obj_align+0x1f6>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   259e4:	8ab5      	ldrh	r5, [r6, #20]
   259e6:	1c69      	adds	r1, r5, #1
   259e8:	8a35      	ldrh	r5, [r6, #16]
            new_x = -lv_obj_get_width(obj);
   259ea:	1a6d      	subs	r5, r5, r1
   259ec:	e768      	b.n	258c0 <lv_obj_align+0xec>
   259ee:	8ab5      	ldrh	r5, [r6, #20]
   259f0:	1c6a      	adds	r2, r5, #1
   259f2:	8a35      	ldrh	r5, [r6, #16]
            new_x = -lv_obj_get_width(obj);
   259f4:	1aad      	subs	r5, r5, r2
   259f6:	e740      	b.n	2587a <lv_obj_align+0xa6>
   259f8:	8ab5      	ldrh	r5, [r6, #20]
   259fa:	1c6a      	adds	r2, r5, #1
   259fc:	8a35      	ldrh	r5, [r6, #16]
            new_x = -lv_obj_get_width(obj);
   259fe:	1aad      	subs	r5, r5, r2
   25a00:	e782      	b.n	25908 <lv_obj_align+0x134>
   25a02:	8a8d      	ldrh	r5, [r1, #20]
   25a04:	3501      	adds	r5, #1
   25a06:	e763      	b.n	258d0 <lv_obj_align+0xfc>
   25a08:	8a8d      	ldrh	r5, [r1, #20]
   25a0a:	3501      	adds	r5, #1
   25a0c:	e7a1      	b.n	25952 <lv_obj_align+0x17e>
   25a0e:	8a8d      	ldrh	r5, [r1, #20]
   25a10:	3501      	adds	r5, #1
   25a12:	e785      	b.n	25920 <lv_obj_align+0x14c>

00025a14 <lv_obj_get_width>:
   25a14:	8a83      	ldrh	r3, [r0, #20]
   25a16:	8a00      	ldrh	r0, [r0, #16]
   25a18:	3301      	adds	r3, #1
   25a1a:	1a18      	subs	r0, r3, r0
}
   25a1c:	b200      	sxth	r0, r0
   25a1e:	4770      	bx	lr

00025a20 <lv_obj_get_height>:
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   25a20:	8ac3      	ldrh	r3, [r0, #22]
   25a22:	8a40      	ldrh	r0, [r0, #18]
   25a24:	3301      	adds	r3, #1
   25a26:	1a18      	subs	r0, r3, r0
}
   25a28:	b200      	sxth	r0, r0
   25a2a:	4770      	bx	lr

00025a2c <lv_obj_get_base_dir>:
}
   25a2c:	2000      	movs	r0, #0
   25a2e:	4770      	bx	lr

00025a30 <lv_obj_get_opa_scale>:
    while(parent) {
   25a30:	b908      	cbnz	r0, 25a36 <lv_obj_get_opa_scale+0x6>
    return LV_OPA_COVER;
   25a32:	20ff      	movs	r0, #255	; 0xff
}
   25a34:	4770      	bx	lr
        if(parent->opa_scale_en) return parent->opa_scale;
   25a36:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
   25a3a:	065b      	lsls	r3, r3, #25
   25a3c:	d502      	bpl.n	25a44 <lv_obj_get_opa_scale+0x14>
   25a3e:	f890 002f 	ldrb.w	r0, [r0, #47]	; 0x2f
   25a42:	4770      	bx	lr
    return obj->par;
   25a44:	6800      	ldr	r0, [r0, #0]
   25a46:	e7f3      	b.n	25a30 <lv_obj_get_opa_scale>

00025a48 <lv_obj_design>:
    if(mode == LV_DESIGN_COVER_CHK) {
   25a48:	2a02      	cmp	r2, #2
{
   25a4a:	b573      	push	{r0, r1, r4, r5, r6, lr}
   25a4c:	4604      	mov	r4, r0
   25a4e:	460d      	mov	r5, r1
    if(mode == LV_DESIGN_COVER_CHK) {
   25a50:	d13b      	bne.n	25aca <lv_obj_design+0x82>
        if(lv_area_is_in(mask_p, &obj->coords) == false) return false;
   25a52:	f100 0610 	add.w	r6, r0, #16
   25a56:	4631      	mov	r1, r6
   25a58:	4628      	mov	r0, r5
   25a5a:	f001 fb9f 	bl	2719c <lv_area_is_in>
   25a5e:	b388      	cbz	r0, 25ac4 <lv_obj_design+0x7c>
        const lv_style_t * style = lv_obj_get_style(obj);
   25a60:	4620      	mov	r0, r4
   25a62:	f7f5 fa53 	bl	1af0c <lv_obj_get_style>
        if(style->body.opa < LV_OPA_MAX) return false;
   25a66:	7b83      	ldrb	r3, [r0, #14]
   25a68:	2bfa      	cmp	r3, #250	; 0xfa
   25a6a:	d92b      	bls.n	25ac4 <lv_obj_design+0x7c>
        lv_coord_t r = style->body.radius;
   25a6c:	f9b0 400c 	ldrsh.w	r4, [r0, #12]
        if(r == LV_RADIUS_CIRCLE) return false;
   25a70:	f647 4318 	movw	r3, #31768	; 0x7c18
   25a74:	429c      	cmp	r4, r3
   25a76:	d025      	beq.n	25ac4 <lv_obj_design+0x7c>
    lv_area_copy(cords_p, &obj->coords);
   25a78:	4631      	mov	r1, r6
   25a7a:	4668      	mov	r0, sp
   25a7c:	f7ff fd5e 	bl	2553c <lv_area_copy>
        area_tmp.x1 += r;
   25a80:	f8bd 3000 	ldrh.w	r3, [sp]
   25a84:	4423      	add	r3, r4
   25a86:	f8ad 3000 	strh.w	r3, [sp]
        area_tmp.x2 -= r;
   25a8a:	f8bd 3004 	ldrh.w	r3, [sp, #4]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
   25a8e:	4669      	mov	r1, sp
        area_tmp.x2 -= r;
   25a90:	1b1b      	subs	r3, r3, r4
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
   25a92:	4628      	mov	r0, r5
        area_tmp.x2 -= r;
   25a94:	f8ad 3004 	strh.w	r3, [sp, #4]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
   25a98:	f001 fb80 	bl	2719c <lv_area_is_in>
   25a9c:	b190      	cbz	r0, 25ac4 <lv_obj_design+0x7c>
    lv_area_copy(cords_p, &obj->coords);
   25a9e:	4631      	mov	r1, r6
   25aa0:	4668      	mov	r0, sp
   25aa2:	f7ff fd4b 	bl	2553c <lv_area_copy>
        area_tmp.y1 += r;
   25aa6:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   25aaa:	4423      	add	r3, r4
   25aac:	f8ad 3002 	strh.w	r3, [sp, #2]
        area_tmp.y2 -= r;
   25ab0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
   25ab4:	4669      	mov	r1, sp
        area_tmp.y2 -= r;
   25ab6:	1b1c      	subs	r4, r3, r4
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
   25ab8:	4628      	mov	r0, r5
        area_tmp.y2 -= r;
   25aba:	f8ad 4006 	strh.w	r4, [sp, #6]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
   25abe:	f001 fb6d 	bl	2719c <lv_area_is_in>
   25ac2:	b900      	cbnz	r0, 25ac6 <lv_obj_design+0x7e>
        if(lv_area_is_in(mask_p, &obj->coords) == false) return false;
   25ac4:	2000      	movs	r0, #0
}
   25ac6:	b002      	add	sp, #8
   25ac8:	bd70      	pop	{r4, r5, r6, pc}
    } else if(mode == LV_DESIGN_DRAW_MAIN) {
   25aca:	b95a      	cbnz	r2, 25ae4 <lv_obj_design+0x9c>
        const lv_style_t * style = lv_obj_get_style(obj);
   25acc:	f7f5 fa1e 	bl	1af0c <lv_obj_get_style>
   25ad0:	4602      	mov	r2, r0
        lv_draw_rect(&obj->coords, mask_p, style, lv_obj_get_opa_scale(obj));
   25ad2:	4620      	mov	r0, r4
   25ad4:	f7ff ffac 	bl	25a30 <lv_obj_get_opa_scale>
   25ad8:	4629      	mov	r1, r5
   25ada:	4603      	mov	r3, r0
   25adc:	f104 0010 	add.w	r0, r4, #16
   25ae0:	f000 fbad 	bl	2623e <lv_draw_rect>
    return true;
   25ae4:	2001      	movs	r0, #1
   25ae6:	e7ee      	b.n	25ac6 <lv_obj_design+0x7e>

00025ae8 <lv_obj_get_signal_cb>:
}
   25ae8:	69c0      	ldr	r0, [r0, #28]
   25aea:	4770      	bx	lr

00025aec <lv_obj_get_ext_attr>:
}
   25aec:	6a40      	ldr	r0, [r0, #36]	; 0x24
   25aee:	4770      	bx	lr

00025af0 <lv_obj_handle_get_type_signal>:
{
   25af0:	b510      	push	{r4, lr}
   25af2:	2300      	movs	r3, #0
        if(buf->type[i] == NULL) break;
   25af4:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   25af8:	b2da      	uxtb	r2, r3
   25afa:	b11c      	cbz	r4, 25b04 <lv_obj_handle_get_type_signal+0x14>
   25afc:	3301      	adds	r3, #1
    for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
   25afe:	2b07      	cmp	r3, #7
   25b00:	d1f8      	bne.n	25af4 <lv_obj_handle_get_type_signal+0x4>
   25b02:	461a      	mov	r2, r3
    buf->type[i] = name;
   25b04:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
}
   25b08:	2001      	movs	r0, #1
   25b0a:	bd10      	pop	{r4, pc}

00025b0c <lv_refr_get_top_obj>:
{
   25b0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25b0e:	460c      	mov	r4, r1
    if(lv_area_is_in(area_p, &obj->coords) && obj->hidden == 0) {
   25b10:	3110      	adds	r1, #16
{
   25b12:	4606      	mov	r6, r0
    if(lv_area_is_in(area_p, &obj->coords) && obj->hidden == 0) {
   25b14:	f001 fb42 	bl	2719c <lv_area_is_in>
   25b18:	b908      	cbnz	r0, 25b1e <lv_refr_get_top_obj+0x12>
    lv_obj_t * found_p = NULL;
   25b1a:	2000      	movs	r0, #0
}
   25b1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(lv_area_is_in(area_p, &obj->coords) && obj->hidden == 0) {
   25b1e:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
   25b22:	06db      	lsls	r3, r3, #27
   25b24:	d4f9      	bmi.n	25b1a <lv_refr_get_top_obj+0xe>
        LV_LL_READ(obj->child_ll, i)
   25b26:	1d27      	adds	r7, r4, #4
   25b28:	4638      	mov	r0, r7
   25b2a:	f001 fbbf 	bl	272ac <lv_ll_get_head>
   25b2e:	4605      	mov	r5, r0
   25b30:	b998      	cbnz	r0, 25b5a <lv_refr_get_top_obj+0x4e>
            const lv_style_t * style = lv_obj_get_style(obj);
   25b32:	4620      	mov	r0, r4
   25b34:	f7f5 f9ea 	bl	1af0c <lv_obj_get_style>
            if(style->body.opa == LV_OPA_COVER && obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK) != false &&
   25b38:	7b83      	ldrb	r3, [r0, #14]
   25b3a:	2bff      	cmp	r3, #255	; 0xff
   25b3c:	d1ed      	bne.n	25b1a <lv_refr_get_top_obj+0xe>
   25b3e:	6a23      	ldr	r3, [r4, #32]
   25b40:	2202      	movs	r2, #2
   25b42:	4631      	mov	r1, r6
   25b44:	4620      	mov	r0, r4
   25b46:	4798      	blx	r3
   25b48:	2800      	cmp	r0, #0
   25b4a:	d0e6      	beq.n	25b1a <lv_refr_get_top_obj+0xe>
               lv_obj_get_opa_scale(obj) == LV_OPA_COVER) {
   25b4c:	4620      	mov	r0, r4
   25b4e:	f7ff ff6f 	bl	25a30 <lv_obj_get_opa_scale>
            if(style->body.opa == LV_OPA_COVER && obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK) != false &&
   25b52:	28ff      	cmp	r0, #255	; 0xff
   25b54:	d1e1      	bne.n	25b1a <lv_refr_get_top_obj+0xe>
   25b56:	4620      	mov	r0, r4
    return found_p;
   25b58:	e7e0      	b.n	25b1c <lv_refr_get_top_obj+0x10>
            found_p = lv_refr_get_top_obj(area_p, i);
   25b5a:	4629      	mov	r1, r5
   25b5c:	4630      	mov	r0, r6
   25b5e:	f7ff ffd5 	bl	25b0c <lv_refr_get_top_obj>
            if(found_p != NULL) {
   25b62:	2800      	cmp	r0, #0
   25b64:	d1da      	bne.n	25b1c <lv_refr_get_top_obj+0x10>
        LV_LL_READ(obj->child_ll, i)
   25b66:	4629      	mov	r1, r5
   25b68:	4638      	mov	r0, r7
   25b6a:	f001 fba5 	bl	272b8 <lv_ll_get_next>
   25b6e:	e7de      	b.n	25b2e <lv_refr_get_top_obj+0x22>

00025b70 <lv_area_copy>:
   25b70:	460b      	mov	r3, r1
{
   25b72:	4602      	mov	r2, r0
   25b74:	cb03      	ldmia	r3!, {r0, r1}
   25b76:	6010      	str	r0, [r2, #0]
   25b78:	6051      	str	r1, [r2, #4]
}
   25b7a:	4770      	bx	lr

00025b7c <lv_refr_obj>:
{
   25b7c:	b5f0      	push	{r4, r5, r6, r7, lr}
    if(obj->hidden != 0) return;
   25b7e:	f890 602c 	ldrb.w	r6, [r0, #44]	; 0x2c
   25b82:	f016 0610 	ands.w	r6, r6, #16
{
   25b86:	b08b      	sub	sp, #44	; 0x2c
   25b88:	4604      	mov	r4, r0
   25b8a:	460f      	mov	r7, r1
    if(obj->hidden != 0) return;
   25b8c:	d138      	bne.n	25c00 <lv_refr_obj+0x84>
    lv_obj_get_coords(obj, &obj_area);
   25b8e:	a904      	add	r1, sp, #16
    lv_coord_t ext_size = obj->ext_draw_pad;
   25b90:	f9b0 5030 	ldrsh.w	r5, [r0, #48]	; 0x30
    lv_obj_get_coords(obj, &obj_area);
   25b94:	f7ff fe08 	bl	257a8 <lv_obj_get_coords>
    obj_area.x1 -= ext_size;
   25b98:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   25b9c:	1b5b      	subs	r3, r3, r5
   25b9e:	f8ad 3010 	strh.w	r3, [sp, #16]
    obj_area.y1 -= ext_size;
   25ba2:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   25ba6:	1b5b      	subs	r3, r3, r5
   25ba8:	f8ad 3012 	strh.w	r3, [sp, #18]
    obj_area.x2 += ext_size;
   25bac:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   25bb0:	442b      	add	r3, r5
   25bb2:	f8ad 3014 	strh.w	r3, [sp, #20]
    obj_area.y2 += ext_size;
   25bb6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    union_ok = lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
   25bba:	aa04      	add	r2, sp, #16
    obj_area.y2 += ext_size;
   25bbc:	441d      	add	r5, r3
    union_ok = lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
   25bbe:	4639      	mov	r1, r7
   25bc0:	a802      	add	r0, sp, #8
    obj_area.y2 += ext_size;
   25bc2:	f8ad 5016 	strh.w	r5, [sp, #22]
    union_ok = lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
   25bc6:	f001 fa80 	bl	270ca <lv_area_intersect>
    if(union_ok != false) {
   25bca:	b1c8      	cbz	r0, 25c00 <lv_refr_obj+0x84>
        obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_MAIN);
   25bcc:	4632      	mov	r2, r6
   25bce:	6a23      	ldr	r3, [r4, #32]
   25bd0:	a902      	add	r1, sp, #8
   25bd2:	4620      	mov	r0, r4
   25bd4:	4798      	blx	r3
        lv_obj_get_coords(obj, &obj_area);
   25bd6:	a904      	add	r1, sp, #16
   25bd8:	4620      	mov	r0, r4
   25bda:	f7ff fde5 	bl	257a8 <lv_obj_get_coords>
        union_ok = lv_area_intersect(&obj_mask, mask_ori_p, &obj_area);
   25bde:	aa04      	add	r2, sp, #16
   25be0:	4639      	mov	r1, r7
   25be2:	4668      	mov	r0, sp
   25be4:	f001 fa71 	bl	270ca <lv_area_intersect>
        if(union_ok != false) {
   25be8:	b128      	cbz	r0, 25bf6 <lv_refr_obj+0x7a>
            LV_LL_READ_BACK(obj->child_ll, child_p)
   25bea:	1d26      	adds	r6, r4, #4
   25bec:	4630      	mov	r0, r6
   25bee:	f001 fb60 	bl	272b2 <lv_ll_get_tail>
   25bf2:	4605      	mov	r5, r0
   25bf4:	b930      	cbnz	r0, 25c04 <lv_refr_obj+0x88>
        obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_POST);
   25bf6:	6a23      	ldr	r3, [r4, #32]
   25bf8:	2201      	movs	r2, #1
   25bfa:	a902      	add	r1, sp, #8
   25bfc:	4620      	mov	r0, r4
   25bfe:	4798      	blx	r3
}
   25c00:	b00b      	add	sp, #44	; 0x2c
   25c02:	bdf0      	pop	{r4, r5, r6, r7, pc}
                lv_obj_get_coords(child_p, &child_area);
   25c04:	a908      	add	r1, sp, #32
   25c06:	4628      	mov	r0, r5
   25c08:	f7ff fdce 	bl	257a8 <lv_obj_get_coords>
                ext_size = child_p->ext_draw_pad;
   25c0c:	f9b5 3030 	ldrsh.w	r3, [r5, #48]	; 0x30
                child_area.x1 -= ext_size;
   25c10:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   25c14:	1ad2      	subs	r2, r2, r3
   25c16:	f8ad 2020 	strh.w	r2, [sp, #32]
                child_area.y1 -= ext_size;
   25c1a:	f8bd 2022 	ldrh.w	r2, [sp, #34]	; 0x22
   25c1e:	1ad2      	subs	r2, r2, r3
   25c20:	f8ad 2022 	strh.w	r2, [sp, #34]	; 0x22
                child_area.x2 += ext_size;
   25c24:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
   25c28:	441a      	add	r2, r3
   25c2a:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
                child_area.y2 += ext_size;
   25c2e:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
                union_ok = lv_area_intersect(&mask_child, &obj_mask, &child_area);
   25c32:	4669      	mov	r1, sp
                child_area.y2 += ext_size;
   25c34:	4413      	add	r3, r2
                union_ok = lv_area_intersect(&mask_child, &obj_mask, &child_area);
   25c36:	a806      	add	r0, sp, #24
   25c38:	aa08      	add	r2, sp, #32
                child_area.y2 += ext_size;
   25c3a:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
                union_ok = lv_area_intersect(&mask_child, &obj_mask, &child_area);
   25c3e:	f001 fa44 	bl	270ca <lv_area_intersect>
                if(union_ok) {
   25c42:	b118      	cbz	r0, 25c4c <lv_refr_obj+0xd0>
                    lv_refr_obj(child_p, &mask_child);
   25c44:	a906      	add	r1, sp, #24
   25c46:	4628      	mov	r0, r5
   25c48:	f7ff ff98 	bl	25b7c <lv_refr_obj>
            LV_LL_READ_BACK(obj->child_ll, child_p)
   25c4c:	4629      	mov	r1, r5
   25c4e:	4630      	mov	r0, r6
   25c50:	f001 fb37 	bl	272c2 <lv_ll_get_prev>
   25c54:	e7cd      	b.n	25bf2 <lv_refr_obj+0x76>

00025c56 <lv_refr_init>:
}
   25c56:	4770      	bx	lr

00025c58 <lv_inv_area>:
{
   25c58:	b5f0      	push	{r4, r5, r6, r7, lr}
   25c5a:	460d      	mov	r5, r1
   25c5c:	b085      	sub	sp, #20
    if(!disp) disp = lv_disp_get_default();
   25c5e:	4604      	mov	r4, r0
   25c60:	b920      	cbnz	r0, 25c6c <lv_inv_area+0x14>
   25c62:	f7f6 fec7 	bl	1c9f4 <lv_disp_get_default>
    if(!disp) return;
   25c66:	4604      	mov	r4, r0
   25c68:	2800      	cmp	r0, #0
   25c6a:	d048      	beq.n	25cfe <lv_inv_area+0xa6>
    if(area_p == NULL) {
   25c6c:	b935      	cbnz	r5, 25c7c <lv_inv_area+0x24>
        disp->inv_p = 0;
   25c6e:	f8b4 3160 	ldrh.w	r3, [r4, #352]	; 0x160
   25c72:	f365 0309 	bfi	r3, r5, #0, #10
        disp->inv_p++;
   25c76:	f8a4 3160 	strh.w	r3, [r4, #352]	; 0x160
   25c7a:	e040      	b.n	25cfe <lv_inv_area+0xa6>
    scr_area.x1 = 0;
   25c7c:	2300      	movs	r3, #0
    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;
   25c7e:	4620      	mov	r0, r4
    scr_area.x1 = 0;
   25c80:	9300      	str	r3, [sp, #0]
    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;
   25c82:	f7f6 febd 	bl	1ca00 <lv_disp_get_hor_res>
   25c86:	3801      	subs	r0, #1
   25c88:	f8ad 0004 	strh.w	r0, [sp, #4]
    scr_area.y2 = lv_disp_get_ver_res(disp) - 1;
   25c8c:	4620      	mov	r0, r4
   25c8e:	f7f6 fec7 	bl	1ca20 <lv_disp_get_ver_res>
   25c92:	3801      	subs	r0, #1
   25c94:	f8ad 0006 	strh.w	r0, [sp, #6]
    suc = lv_area_intersect(&com_area, area_p, &scr_area);
   25c98:	466a      	mov	r2, sp
   25c9a:	4629      	mov	r1, r5
   25c9c:	a802      	add	r0, sp, #8
   25c9e:	f001 fa14 	bl	270ca <lv_area_intersect>
    if(suc != false) {
   25ca2:	b360      	cbz	r0, 25cfe <lv_inv_area+0xa6>
        if(disp->driver.rounder_cb) disp->driver.rounder_cb(&disp->driver, &com_area);
   25ca4:	6923      	ldr	r3, [r4, #16]
   25ca6:	b113      	cbz	r3, 25cae <lv_inv_area+0x56>
   25ca8:	a902      	add	r1, sp, #8
   25caa:	4620      	mov	r0, r4
   25cac:	4798      	blx	r3
   25cae:	f104 0540 	add.w	r5, r4, #64	; 0x40
{
   25cb2:	2600      	movs	r6, #0
   25cb4:	462f      	mov	r7, r5
        for(i = 0; i < disp->inv_p; i++) {
   25cb6:	f8b4 3160 	ldrh.w	r3, [r4, #352]	; 0x160
   25cba:	b2b2      	uxth	r2, r6
   25cbc:	f3c3 0009 	ubfx	r0, r3, #0, #10
   25cc0:	4290      	cmp	r0, r2
   25cc2:	d814      	bhi.n	25cee <lv_inv_area+0x96>
        if(disp->inv_p < LV_INV_BUF_SIZE) {
   25cc4:	281f      	cmp	r0, #31
            disp->inv_p = 0;
   25cc6:	bf8b      	itete	hi
   25cc8:	f36f 0309 	bfchi	r3, #0, #10
            lv_area_copy(&disp->inv_areas[disp->inv_p], &com_area);
   25ccc:	3008      	addls	r0, #8
            disp->inv_p = 0;
   25cce:	f8a4 3160 	strhhi.w	r3, [r4, #352]	; 0x160
            lv_area_copy(&disp->inv_areas[disp->inv_p], &com_area);
   25cd2:	a902      	addls	r1, sp, #8
   25cd4:	bf92      	itee	ls
   25cd6:	eb04 00c0 	addls.w	r0, r4, r0, lsl #3
            lv_area_copy(&disp->inv_areas[disp->inv_p], &scr_area);
   25cda:	4669      	movhi	r1, sp
   25cdc:	4638      	movhi	r0, r7
   25cde:	f7ff ff47 	bl	25b70 <lv_area_copy>
        disp->inv_p++;
   25ce2:	f8b4 3160 	ldrh.w	r3, [r4, #352]	; 0x160
   25ce6:	1c5a      	adds	r2, r3, #1
   25ce8:	f362 0309 	bfi	r3, r2, #0, #10
   25cec:	e7c3      	b.n	25c76 <lv_inv_area+0x1e>
            if(lv_area_is_in(&com_area, &disp->inv_areas[i]) != false) return;
   25cee:	4629      	mov	r1, r5
   25cf0:	a802      	add	r0, sp, #8
   25cf2:	f001 fa53 	bl	2719c <lv_area_is_in>
   25cf6:	3601      	adds	r6, #1
   25cf8:	3508      	adds	r5, #8
   25cfa:	2800      	cmp	r0, #0
   25cfc:	d0db      	beq.n	25cb6 <lv_inv_area+0x5e>
}
   25cfe:	b005      	add	sp, #20
   25d00:	bdf0      	pop	{r4, r5, r6, r7, pc}

00025d02 <lv_style_copy>:
   25d02:	2250      	movs	r2, #80	; 0x50
   25d04:	f7db bf72 	b.w	1bec <memcpy>

00025d08 <lv_color_mix.isra.0>:
#elif LV_COLOR_DEPTH == 32
    return color.full;
#endif
}

static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
   25d08:	b530      	push	{r4, r5, lr}
   25d0a:	f89d 5014 	ldrb.w	r5, [sp, #20]
{
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
   25d0e:	b2ac      	uxth	r4, r5
   25d10:	f1c5 05ff 	rsb	r5, r5, #255	; 0xff
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    LV_COLOR_SET_B(ret, (uint16_t)((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) * (255 - mix)) >> 8);
   25d14:	436b      	muls	r3, r5
   25d16:	fb00 3304 	mla	r3, r0, r4, r3
   25d1a:	f3c3 2307 	ubfx	r3, r3, #8, #8
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
   25d1e:	2000      	movs	r0, #0
   25d20:	f363 0007 	bfi	r0, r3, #0, #8
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
   25d24:	f89d 300c 	ldrb.w	r3, [sp, #12]
   25d28:	fb13 f305 	smulbb	r3, r3, r5
   25d2c:	fb01 3104 	mla	r1, r1, r4, r3
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
   25d30:	f89d 3010 	ldrb.w	r3, [sp, #16]
   25d34:	fb13 f505 	smulbb	r5, r3, r5
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
   25d38:	f3c1 2107 	ubfx	r1, r1, #8, #8
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
   25d3c:	fb02 5204 	mla	r2, r2, r4, r5
    return ret;
   25d40:	f361 200f 	bfi	r0, r1, #8, #8
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
   25d44:	f3c2 2207 	ubfx	r2, r2, #8, #8
    return ret;
   25d48:	f362 4017 	bfi	r0, r2, #16, #8
}
   25d4c:	f040 407f 	orr.w	r0, r0, #4278190080	; 0xff000000
   25d50:	bd30      	pop	{r4, r5, pc}

00025d52 <lv_draw_fill>:
{
   25d52:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(opa < LV_OPA_MIN) return;
   25d56:	2b0f      	cmp	r3, #15
{
   25d58:	b08d      	sub	sp, #52	; 0x34
   25d5a:	4616      	mov	r6, r2
   25d5c:	461f      	mov	r7, r3
    if(opa < LV_OPA_MIN) return;
   25d5e:	d973      	bls.n	25e48 <lv_draw_fill+0xf6>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
   25d60:	2bfc      	cmp	r3, #252	; 0xfc
    union_ok = lv_area_intersect(&res_a, cords_p, mask_p);
   25d62:	460a      	mov	r2, r1
   25d64:	4601      	mov	r1, r0
   25d66:	a80a      	add	r0, sp, #40	; 0x28
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
   25d68:	bf28      	it	cs
   25d6a:	27ff      	movcs	r7, #255	; 0xff
    union_ok = lv_area_intersect(&res_a, cords_p, mask_p);
   25d6c:	f001 f9ad 	bl	270ca <lv_area_intersect>
    if(union_ok == false) {
   25d70:	2800      	cmp	r0, #0
   25d72:	d069      	beq.n	25e48 <lv_draw_fill+0xf6>
    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
   25d74:	f7f5 f984 	bl	1b080 <lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   25d78:	f001 f945 	bl	27006 <lv_disp_get_buf>
    vdb_rel_a.y1 = res_a.y1 - vdb->area.y1;
   25d7c:	f8bd 102a 	ldrh.w	r1, [sp, #42]	; 0x2a
   25d80:	f9b0 5012 	ldrsh.w	r5, [r0, #18]
    vdb_rel_a.x1 = res_a.x1 - vdb->area.x1;
   25d84:	f9b0 3010 	ldrsh.w	r3, [r0, #16]
   25d88:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
    lv_color_t * vdb_buf_tmp = vdb->buf_act;
   25d8c:	f8d0 a008 	ldr.w	sl, [r0, #8]
    vdb_rel_a.y1 = res_a.y1 - vdb->area.y1;
   25d90:	1b49      	subs	r1, r1, r5
   25d92:	fa0f fb81 	sxth.w	fp, r1
    vdb_rel_a.x2 = res_a.x2 - vdb->area.x1;
   25d96:	f8bd 102c 	ldrh.w	r1, [sp, #44]	; 0x2c
   25d9a:	1ac9      	subs	r1, r1, r3
   25d9c:	b20a      	sxth	r2, r1
   25d9e:	9204      	str	r2, [sp, #16]
    vdb_rel_a.y2 = res_a.y2 - vdb->area.y1;
   25da0:	f8bd 202e 	ldrh.w	r2, [sp, #46]	; 0x2e
   25da4:	1b52      	subs	r2, r2, r5
   25da6:	8a85      	ldrh	r5, [r0, #20]
   25da8:	3501      	adds	r5, #1
   25daa:	1aed      	subs	r5, r5, r3
    vdb_rel_a.x1 = res_a.x1 - vdb->area.x1;
   25dac:	1ae4      	subs	r4, r4, r3
   25dae:	b22b      	sxth	r3, r5
   25db0:	9309      	str	r3, [sp, #36]	; 0x24
   25db2:	b2f3      	uxtb	r3, r6
   25db4:	9307      	str	r3, [sp, #28]
   25db6:	f3c6 2307 	ubfx	r3, r6, #8, #8
    vdb_rel_a.y2 = res_a.y2 - vdb->area.y1;
   25dba:	b212      	sxth	r2, r2
   25dbc:	9306      	str	r3, [sp, #24]
   25dbe:	f3c6 4307 	ubfx	r3, r6, #16, #8
   25dc2:	9305      	str	r3, [sp, #20]
   25dc4:	9208      	str	r2, [sp, #32]
{
    /*Set all row in vdb to the given color*/
    lv_coord_t row;
    lv_coord_t col;

    lv_disp_t * disp = lv_refr_get_disp_refreshing();
   25dc6:	f7f5 f95b 	bl	1b080 <lv_refr_get_disp_refreshing>
    if(disp->driver.set_px_cb) {
   25dca:	6943      	ldr	r3, [r0, #20]
    vdb_rel_a.x1 = res_a.x1 - vdb->area.x1;
   25dcc:	b224      	sxth	r4, r4
    lv_disp_t * disp = lv_refr_get_disp_refreshing();
   25dce:	4681      	mov	r9, r0
    if(disp->driver.set_px_cb) {
   25dd0:	2b00      	cmp	r3, #0
   25dd2:	d136      	bne.n	25e42 <lv_draw_fill+0xf0>
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
                disp->driver.set_px_cb(&disp->driver, (uint8_t *)mem, mem_width, col, row, color, opa);
            }
        }
    } else {
        mem += fill_area->y1 * mem_width; /*Go to the first row*/
   25dd4:	9a09      	ldr	r2, [sp, #36]	; 0x24
   25dd6:	fb0b f202 	mul.w	r2, fp, r2
   25dda:	eb0a 0a82 	add.w	sl, sl, r2, lsl #2

        /*Run simpler function without opacity*/
        if(opa == LV_OPA_COVER) {
   25dde:	9a09      	ldr	r2, [sp, #36]	; 0x24
   25de0:	2fff      	cmp	r7, #255	; 0xff
   25de2:	ea4f 0582 	mov.w	r5, r2, lsl #2
   25de6:	d05c      	beq.n	25ea2 <lv_draw_fill+0x150>
#if LV_COLOR_DEPTH == 32 && LV_COLOR_SCREEN_TRANSP
            scr_transp = disp->driver.screen_transp;
#endif

            lv_color_t bg_tmp  = LV_COLOR_BLACK;
            lv_color_t opa_tmp = lv_color_mix(color, bg_tmp, opa);
   25de8:	e9cd 3701 	strd	r3, r7, [sp, #4]
   25dec:	9300      	str	r3, [sp, #0]
   25dee:	e9dd 2105 	ldrd	r2, r1, [sp, #20]
   25df2:	9807      	ldr	r0, [sp, #28]
            lv_color_t bg_tmp  = LV_COLOR_BLACK;
   25df4:	f04f 487f 	mov.w	r8, #4278190080	; 0xff000000
            lv_color_t opa_tmp = lv_color_mix(color, bg_tmp, opa);
   25df8:	f7ff ff86 	bl	25d08 <lv_color_mix.isra.0>
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
   25dfc:	9b08      	ldr	r3, [sp, #32]
   25dfe:	455b      	cmp	r3, fp
   25e00:	db22      	blt.n	25e48 <lv_draw_fill+0xf6>
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
   25e02:	4626      	mov	r6, r4
   25e04:	e068      	b.n	25ed8 <lv_draw_fill+0x186>
                disp->driver.set_px_cb(&disp->driver, (uint8_t *)mem, mem_width, col, row, color, opa);
   25e06:	f8d9 3014 	ldr.w	r3, [r9, #20]
   25e0a:	9a09      	ldr	r2, [sp, #36]	; 0x24
   25e0c:	f8cd 8000 	str.w	r8, [sp]
   25e10:	461d      	mov	r5, r3
   25e12:	9b07      	ldr	r3, [sp, #28]
   25e14:	f363 0607 	bfi	r6, r3, #0, #8
   25e18:	9b06      	ldr	r3, [sp, #24]
   25e1a:	f363 260f 	bfi	r6, r3, #8, #8
   25e1e:	9b05      	ldr	r3, [sp, #20]
   25e20:	f363 4617 	bfi	r6, r3, #16, #8
   25e24:	e9cd 6701 	strd	r6, r7, [sp, #4]
   25e28:	4623      	mov	r3, r4
   25e2a:	4651      	mov	r1, sl
   25e2c:	4648      	mov	r0, r9
   25e2e:	47a8      	blx	r5
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
   25e30:	f108 0801 	add.w	r8, r8, #1
   25e34:	fa0f f888 	sxth.w	r8, r8
   25e38:	9b08      	ldr	r3, [sp, #32]
   25e3a:	4543      	cmp	r3, r8
   25e3c:	dae3      	bge.n	25e06 <lv_draw_fill+0xb4>
        for(col = fill_area->x1; col <= fill_area->x2; col++) {
   25e3e:	3401      	adds	r4, #1
   25e40:	b224      	sxth	r4, r4
   25e42:	9b04      	ldr	r3, [sp, #16]
   25e44:	42a3      	cmp	r3, r4
   25e46:	da02      	bge.n	25e4e <lv_draw_fill+0xfc>
}
   25e48:	b00d      	add	sp, #52	; 0x34
   25e4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
   25e4e:	46d8      	mov	r8, fp
   25e50:	e7f2      	b.n	25e38 <lv_draw_fill+0xe6>
                mem[col] = color;
   25e52:	9a07      	ldr	r2, [sp, #28]
   25e54:	f362 0607 	bfi	r6, r2, #0, #8
   25e58:	9a06      	ldr	r2, [sp, #24]
   25e5a:	f362 260f 	bfi	r6, r2, #8, #8
   25e5e:	9a05      	ldr	r2, [sp, #20]
   25e60:	f362 4617 	bfi	r6, r2, #16, #8
   25e64:	f84a 6023 	str.w	r6, [sl, r3, lsl #2]
            for(col = fill_area->x1; col <= fill_area->x2; col++) {
   25e68:	3301      	adds	r3, #1
   25e6a:	b21b      	sxth	r3, r3
   25e6c:	9a04      	ldr	r2, [sp, #16]
   25e6e:	429a      	cmp	r2, r3
   25e70:	daef      	bge.n	25e52 <lv_draw_fill+0x100>
            lv_coord_t copy_size   = (fill_area->x2 - fill_area->x1 + 1) * sizeof(lv_color_t);
   25e72:	3201      	adds	r2, #1
            lv_color_t * mem_first = &mem[fill_area->x1];
   25e74:	00a3      	lsls	r3, r4, #2
            lv_coord_t copy_size   = (fill_area->x2 - fill_area->x1 + 1) * sizeof(lv_color_t);
   25e76:	1b14      	subs	r4, r2, r4
            lv_color_t * mem_first = &mem[fill_area->x1];
   25e78:	eb0a 0603 	add.w	r6, sl, r3
            lv_coord_t copy_size   = (fill_area->x2 - fill_area->x1 + 1) * sizeof(lv_color_t);
   25e7c:	00a4      	lsls	r4, r4, #2
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
   25e7e:	f10b 0701 	add.w	r7, fp, #1
   25e82:	442b      	add	r3, r5
            lv_coord_t copy_size   = (fill_area->x2 - fill_area->x1 + 1) * sizeof(lv_color_t);
   25e84:	b224      	sxth	r4, r4
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
   25e86:	b23f      	sxth	r7, r7
   25e88:	449a      	add	sl, r3
   25e8a:	9b08      	ldr	r3, [sp, #32]
   25e8c:	42bb      	cmp	r3, r7
   25e8e:	dbdb      	blt.n	25e48 <lv_draw_fill+0xf6>
   25e90:	4650      	mov	r0, sl
   25e92:	4622      	mov	r2, r4
   25e94:	4631      	mov	r1, r6
   25e96:	3701      	adds	r7, #1
   25e98:	f7db fea8 	bl	1bec <memcpy>
   25e9c:	b23f      	sxth	r7, r7
   25e9e:	44aa      	add	sl, r5
   25ea0:	e7f3      	b.n	25e8a <lv_draw_fill+0x138>
            for(col = fill_area->x1; col <= fill_area->x2; col++) {
   25ea2:	4623      	mov	r3, r4
   25ea4:	e7e2      	b.n	25e6c <lv_draw_fill+0x11a>
                    if(scr_transp == false) {
                        /*If the bg color changed recalculate the result color*/
                        if(mem[col].full != bg_tmp.full) {
   25ea6:	f85a 3026 	ldr.w	r3, [sl, r6, lsl #2]
   25eaa:	4543      	cmp	r3, r8
   25eac:	eb0a 0986 	add.w	r9, sl, r6, lsl #2
   25eb0:	d00e      	beq.n	25ed0 <lv_draw_fill+0x17e>
                            bg_tmp  = mem[col];
   25eb2:	4698      	mov	r8, r3
                            opa_tmp = lv_color_mix(color, bg_tmp, opa);
   25eb4:	f3c3 4307 	ubfx	r3, r3, #16, #8
   25eb8:	9301      	str	r3, [sp, #4]
   25eba:	f3c8 2307 	ubfx	r3, r8, #8, #8
   25ebe:	9300      	str	r3, [sp, #0]
   25ec0:	9702      	str	r7, [sp, #8]
   25ec2:	fa5f f388 	uxtb.w	r3, r8
   25ec6:	e9dd 2105 	ldrd	r2, r1, [sp, #20]
   25eca:	9807      	ldr	r0, [sp, #28]
   25ecc:	f7ff ff1c 	bl	25d08 <lv_color_mix.isra.0>
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
   25ed0:	3601      	adds	r6, #1
                        }

                        mem[col] = opa_tmp;
   25ed2:	f8c9 0000 	str.w	r0, [r9]
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
   25ed6:	b236      	sxth	r6, r6
   25ed8:	9b04      	ldr	r3, [sp, #16]
   25eda:	42b3      	cmp	r3, r6
   25edc:	dae3      	bge.n	25ea6 <lv_draw_fill+0x154>
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
   25ede:	f10b 0301 	add.w	r3, fp, #1
#if LV_COLOR_DEPTH == 32 && LV_COLOR_SCREEN_TRANSP
                        mem[col] = color_mix_2_alpha(mem[col], mem[col].ch.alpha, color, opa);
#endif
                    }
                }
                mem += mem_width;
   25ee2:	44aa      	add	sl, r5
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
   25ee4:	fa0f fb83 	sxth.w	fp, r3
   25ee8:	e788      	b.n	25dfc <lv_draw_fill+0xaa>

00025eea <lv_draw_map>:
{
   25eea:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   25eee:	b097      	sub	sp, #92	; 0x5c
   25ef0:	461e      	mov	r6, r3
   25ef2:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
   25ef6:	9311      	str	r3, [sp, #68]	; 0x44
   25ef8:	4615      	mov	r5, r2
   25efa:	f89d 3084 	ldrb.w	r3, [sp, #132]	; 0x84
   25efe:	f89d 208c 	ldrb.w	r2, [sp, #140]	; 0x8c
   25f02:	9312      	str	r3, [sp, #72]	; 0x48
    if(opa < LV_OPA_MIN) return;
   25f04:	2e0f      	cmp	r6, #15
{
   25f06:	4607      	mov	r7, r0
   25f08:	9b22      	ldr	r3, [sp, #136]	; 0x88
   25f0a:	920a      	str	r2, [sp, #40]	; 0x28
    if(opa < LV_OPA_MIN) return;
   25f0c:	f240 80a6 	bls.w	2605c <lv_draw_map+0x172>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
   25f10:	b2da      	uxtb	r2, r3
   25f12:	920e      	str	r2, [sp, #56]	; 0x38
   25f14:	f3c3 2207 	ubfx	r2, r3, #8, #8
   25f18:	2efc      	cmp	r6, #252	; 0xfc
   25f1a:	9210      	str	r2, [sp, #64]	; 0x40
   25f1c:	f3c3 4307 	ubfx	r3, r3, #16, #8
    union_ok = lv_area_intersect(&masked_a, cords_p, mask_p);
   25f20:	460a      	mov	r2, r1
   25f22:	4601      	mov	r1, r0
   25f24:	a814      	add	r0, sp, #80	; 0x50
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
   25f26:	bf28      	it	cs
   25f28:	26ff      	movcs	r6, #255	; 0xff
   25f2a:	930f      	str	r3, [sp, #60]	; 0x3c
    union_ok = lv_area_intersect(&masked_a, cords_p, mask_p);
   25f2c:	f001 f8cd 	bl	270ca <lv_area_intersect>
    if(union_ok == false) return;
   25f30:	2800      	cmp	r0, #0
   25f32:	f000 8093 	beq.w	2605c <lv_draw_map+0x172>
   25f36:	88bc      	ldrh	r4, [r7, #4]
   25f38:	f9b7 2000 	ldrsh.w	r2, [r7]
    if(cords_p->y1 < masked_a.y1) {
   25f3c:	f9b7 1002 	ldrsh.w	r1, [r7, #2]
   25f40:	f9bd 3052 	ldrsh.w	r3, [sp, #82]	; 0x52
   25f44:	3401      	adds	r4, #1
   25f46:	4299      	cmp	r1, r3
   25f48:	eba4 0402 	sub.w	r4, r4, r2
        map_p += (uint32_t)map_width * ((masked_a.y1 - cords_p->y1)) * px_size_byte;
   25f4c:	bfb8      	it	lt
   25f4e:	1a5b      	sublt	r3, r3, r1
   25f50:	b224      	sxth	r4, r4
   25f52:	bfbc      	itt	lt
   25f54:	4363      	mullt	r3, r4
   25f56:	eb05 0583 	addlt.w	r5, r5, r3, lsl #2
    if(cords_p->x1 < masked_a.x1) {
   25f5a:	f9bd 3050 	ldrsh.w	r3, [sp, #80]	; 0x50
   25f5e:	4293      	cmp	r3, r2
        map_p += (masked_a.x1 - cords_p->x1) * px_size_byte;
   25f60:	bfc4      	itt	gt
   25f62:	1a9a      	subgt	r2, r3, r2
   25f64:	eb05 0582 	addgt.w	r5, r5, r2, lsl #2
    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
   25f68:	f7f5 f88a 	bl	1b080 <lv_refr_get_disp_refreshing>
   25f6c:	4680      	mov	r8, r0
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   25f6e:	f001 f84a 	bl	27006 <lv_disp_get_buf>
   25f72:	4682      	mov	sl, r0
    masked_a.x2 = masked_a.x2 - vdb->area.x1;
   25f74:	f9bd 3054 	ldrsh.w	r3, [sp, #84]	; 0x54
    masked_a.x1 = masked_a.x1 - vdb->area.x1;
   25f78:	f9ba 1010 	ldrsh.w	r1, [sl, #16]
    masked_a.y1 = masked_a.y1 - vdb->area.y1;
   25f7c:	f9ba e012 	ldrsh.w	lr, [sl, #18]
    masked_a.x1 = masked_a.x1 - vdb->area.x1;
   25f80:	f9bd 0050 	ldrsh.w	r0, [sp, #80]	; 0x50
    masked_a.y1 = masked_a.y1 - vdb->area.y1;
   25f84:	f8bd 7052 	ldrh.w	r7, [sp, #82]	; 0x52
    masked_a.x2 = masked_a.x2 - vdb->area.x1;
   25f88:	eba3 0c01 	sub.w	ip, r3, r1
   25f8c:	f8ad c054 	strh.w	ip, [sp, #84]	; 0x54
    masked_a.y2 = masked_a.y2 - vdb->area.y1;
   25f90:	f8bd c056 	ldrh.w	ip, [sp, #86]	; 0x56
   25f94:	ebac 0c0e 	sub.w	ip, ip, lr
   25f98:	f8ad c056 	strh.w	ip, [sp, #86]	; 0x56
   25f9c:	f8ba c014 	ldrh.w	ip, [sl, #20]
   25fa0:	f10c 0c01 	add.w	ip, ip, #1
    masked_a.x1 = masked_a.x1 - vdb->area.x1;
   25fa4:	1a42      	subs	r2, r0, r1
   25fa6:	ebac 0101 	sub.w	r1, ip, r1
   25faa:	b209      	sxth	r1, r1
   25fac:	3301      	adds	r3, #1
   25fae:	9105      	str	r1, [sp, #20]
   25fb0:	1a18      	subs	r0, r3, r0
    lv_color_t * vdb_buf_tmp = vdb->buf_act;
   25fb2:	f8da 1008 	ldr.w	r1, [sl, #8]
   25fb6:	9106      	str	r1, [sp, #24]
   25fb8:	b203      	sxth	r3, r0
    vdb_buf_tmp += (uint32_t)masked_a.x1;             /*Move to the first col*/
   25fba:	9905      	ldr	r1, [sp, #20]
   25fbc:	930c      	str	r3, [sp, #48]	; 0x30
    masked_a.y1 = masked_a.y1 - vdb->area.y1;
   25fbe:	eba7 070e 	sub.w	r7, r7, lr
    masked_a.x1 = masked_a.x1 - vdb->area.x1;
   25fc2:	b212      	sxth	r2, r2
    masked_a.y1 = masked_a.y1 - vdb->area.y1;
   25fc4:	b23f      	sxth	r7, r7
   25fc6:	00a3      	lsls	r3, r4, #2
    masked_a.x1 = masked_a.x1 - vdb->area.x1;
   25fc8:	f8ad 2050 	strh.w	r2, [sp, #80]	; 0x50
    masked_a.y1 = masked_a.y1 - vdb->area.y1;
   25fcc:	930d      	str	r3, [sp, #52]	; 0x34
    vdb_buf_tmp += (uint32_t)masked_a.x1;             /*Move to the first col*/
   25fce:	fb01 2207 	mla	r2, r1, r7, r2
    if(chroma_key == false && alpha_byte == false && opa == LV_OPA_COVER && recolor_opa == LV_OPA_TRANSP) {
   25fd2:	9b11      	ldr	r3, [sp, #68]	; 0x44
    vdb_buf_tmp += (uint32_t)masked_a.x1;             /*Move to the first col*/
   25fd4:	9906      	ldr	r1, [sp, #24]
    masked_a.y1 = masked_a.y1 - vdb->area.y1;
   25fd6:	f8ad 7052 	strh.w	r7, [sp, #82]	; 0x52
    vdb_buf_tmp += (uint32_t)masked_a.x1;             /*Move to the first col*/
   25fda:	eb01 0b82 	add.w	fp, r1, r2, lsl #2
    if(chroma_key == false && alpha_byte == false && opa == LV_OPA_COVER && recolor_opa == LV_OPA_TRANSP) {
   25fde:	2b00      	cmp	r3, #0
   25fe0:	d142      	bne.n	26068 <lv_draw_map+0x17e>
   25fe2:	9b12      	ldr	r3, [sp, #72]	; 0x48
   25fe4:	2b00      	cmp	r3, #0
   25fe6:	d13f      	bne.n	26068 <lv_draw_map+0x17e>
   25fe8:	2eff      	cmp	r6, #255	; 0xff
   25fea:	d13d      	bne.n	26068 <lv_draw_map+0x17e>
   25fec:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   25fee:	2b00      	cmp	r3, #0
   25ff0:	d13a      	bne.n	26068 <lv_draw_map+0x17e>
        if(disp->driver.set_px_cb) {
   25ff2:	f8d8 3014 	ldr.w	r3, [r8, #20]
   25ff6:	bb6b      	cbnz	r3, 26054 <lv_draw_map+0x16a>
        memcpy(dest, src, length * sizeof(lv_color_t));
   25ff8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   25ffa:	009e      	lsls	r6, r3, #2
                vdb_buf_tmp += vdb_width;          /*Next row on the VDB*/
   25ffc:	9b05      	ldr	r3, [sp, #20]
   25ffe:	009c      	lsls	r4, r3, #2
            for(row = masked_a.y1; row <= masked_a.y2; row++) {
   26000:	f9bd 3056 	ldrsh.w	r3, [sp, #86]	; 0x56
   26004:	42bb      	cmp	r3, r7
   26006:	db29      	blt.n	2605c <lv_draw_map+0x172>
   26008:	4629      	mov	r1, r5
   2600a:	4658      	mov	r0, fp
   2600c:	4632      	mov	r2, r6
   2600e:	f7db fded 	bl	1bec <memcpy>
                map_p += map_width * px_size_byte; /*Next row on the map*/
   26012:	9b0d      	ldr	r3, [sp, #52]	; 0x34
            for(row = masked_a.y1; row <= masked_a.y2; row++) {
   26014:	3701      	adds	r7, #1
                map_p += map_width * px_size_byte; /*Next row on the map*/
   26016:	441d      	add	r5, r3
                vdb_buf_tmp += vdb_width;          /*Next row on the VDB*/
   26018:	44a3      	add	fp, r4
            for(row = masked_a.y1; row <= masked_a.y2; row++) {
   2601a:	b23f      	sxth	r7, r7
   2601c:	e7f0      	b.n	26000 <lv_draw_map+0x116>
                    lv_color_t px_color = *((lv_color_t *)&map_p[(uint32_t)col * px_size_byte]);
   2601e:	f855 2029 	ldr.w	r2, [r5, r9, lsl #2]
                    disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width, col + masked_a.x1, row,
   26022:	f8bd 1050 	ldrh.w	r1, [sp, #80]	; 0x50
   26026:	9700      	str	r7, [sp, #0]
   26028:	e9cd 2601 	strd	r2, r6, [sp, #4]
   2602c:	440b      	add	r3, r1
   2602e:	f8d8 4014 	ldr.w	r4, [r8, #20]
   26032:	9a05      	ldr	r2, [sp, #20]
   26034:	f8da 1008 	ldr.w	r1, [sl, #8]
   26038:	b21b      	sxth	r3, r3
   2603a:	4640      	mov	r0, r8
   2603c:	47a0      	blx	r4
   2603e:	f109 0901 	add.w	r9, r9, #1
                for(col = 0; col < map_useful_w; col++) {
   26042:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   26044:	fa0f f389 	sxth.w	r3, r9
   26048:	4293      	cmp	r3, r2
   2604a:	dbe8      	blt.n	2601e <lv_draw_map+0x134>
                map_p += map_width * px_size_byte; /*Next row on the map*/
   2604c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
            for(row = masked_a.y1; row <= masked_a.y2; row++) {
   2604e:	3701      	adds	r7, #1
                map_p += map_width * px_size_byte; /*Next row on the map*/
   26050:	441d      	add	r5, r3
            for(row = masked_a.y1; row <= masked_a.y2; row++) {
   26052:	b23f      	sxth	r7, r7
   26054:	f9bd 3056 	ldrsh.w	r3, [sp, #86]	; 0x56
   26058:	42bb      	cmp	r3, r7
   2605a:	da02      	bge.n	26062 <lv_draw_map+0x178>
}
   2605c:	b017      	add	sp, #92	; 0x5c
   2605e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   26062:	f04f 0900 	mov.w	r9, #0
   26066:	e7ec      	b.n	26042 <lv_draw_map+0x158>
        lv_color_t last_img_px  = LV_COLOR_BLACK;
   26068:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
   2606c:	9309      	str	r3, [sp, #36]	; 0x24
        lv_color_t recolored_px = lv_color_mix(recolor, last_img_px, recolor_opa);
   2606e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   26070:	9302      	str	r3, [sp, #8]
   26072:	2300      	movs	r3, #0
   26074:	e9cd 3300 	strd	r3, r3, [sp]
   26078:	e9dd 210f 	ldrd	r2, r1, [sp, #60]	; 0x3c
   2607c:	980e      	ldr	r0, [sp, #56]	; 0x38
   2607e:	f7ff fe43 	bl	25d08 <lv_color_mix.isra.0>
        for(row = masked_a.y1; row <= masked_a.y2; row++) {
   26082:	f9bd 3052 	ldrsh.w	r3, [sp, #82]	; 0x52
   26086:	9306      	str	r3, [sp, #24]
            vdb_buf_tmp += vdb_width;          /*Next row on the VDB*/
   26088:	9b05      	ldr	r3, [sp, #20]
   2608a:	009b      	lsls	r3, r3, #2
        lv_color_t recolored_px = lv_color_mix(recolor, last_img_px, recolor_opa);
   2608c:	4681      	mov	r9, r0
            vdb_buf_tmp += vdb_width;          /*Next row on the VDB*/
   2608e:	9313      	str	r3, [sp, #76]	; 0x4c
        for(row = masked_a.y1; row <= masked_a.y2; row++) {
   26090:	f9bd 3056 	ldrsh.w	r3, [sp, #86]	; 0x56
   26094:	9a06      	ldr	r2, [sp, #24]
   26096:	4293      	cmp	r3, r2
   26098:	dbe0      	blt.n	2605c <lv_draw_map+0x172>
   2609a:	2300      	movs	r3, #0
   2609c:	9508      	str	r5, [sp, #32]
   2609e:	465f      	mov	r7, fp
   260a0:	9307      	str	r3, [sp, #28]
   260a2:	e04e      	b.n	26142 <lv_draw_map+0x258>
                if(alpha_byte) {
   260a4:	9b12      	ldr	r3, [sp, #72]	; 0x48
   260a6:	2b00      	cmp	r3, #0
   260a8:	d03c      	beq.n	26124 <lv_draw_map+0x23a>
                    px_color = *((lv_color_t *)px_color_p);
   260aa:	9b08      	ldr	r3, [sp, #32]
                    lv_opa_t px_opa = *(px_color_p + LV_IMG_PX_SIZE_ALPHA_BYTE - 1);
   260ac:	78dc      	ldrb	r4, [r3, #3]
                    px_color = *((lv_color_t *)px_color_p);
   260ae:	6818      	ldr	r0, [r3, #0]
                    if(px_opa == LV_OPA_TRANSP)
   260b0:	2c00      	cmp	r4, #0
   260b2:	d03f      	beq.n	26134 <lv_draw_map+0x24a>
                    else if(px_opa != LV_OPA_COVER)
   260b4:	2cff      	cmp	r4, #255	; 0xff
   260b6:	d037      	beq.n	26128 <lv_draw_map+0x23e>
                        opa_result = (uint32_t)((uint32_t)px_opa * opa_result) >> 8;
   260b8:	fb14 f406 	smulbb	r4, r4, r6
   260bc:	f3c4 2407 	ubfx	r4, r4, #8, #8
                if(chroma_key && px_color.full == disp->driver.color_chroma_key.full) continue;
   260c0:	9b11      	ldr	r3, [sp, #68]	; 0x44
   260c2:	b11b      	cbz	r3, 260cc <lv_draw_map+0x1e2>
   260c4:	f8d8 301c 	ldr.w	r3, [r8, #28]
   260c8:	4298      	cmp	r0, r3
   260ca:	d033      	beq.n	26134 <lv_draw_map+0x24a>
                if(recolor_opa != LV_OPA_TRANSP) {
   260cc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   260ce:	2b00      	cmp	r3, #0
   260d0:	d059      	beq.n	26186 <lv_draw_map+0x29c>
                    if(last_img_px.full != px_color.full) { /*Minor acceleration: calculate only for
   260d2:	9b09      	ldr	r3, [sp, #36]	; 0x24
   260d4:	4283      	cmp	r3, r0
   260d6:	d010      	beq.n	260fa <lv_draw_map+0x210>
                        recolored_px = lv_color_mix(recolor, last_img_px, recolor_opa);
   260d8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   260da:	9302      	str	r3, [sp, #8]
   260dc:	f3c0 4307 	ubfx	r3, r0, #16, #8
                        last_img_px  = px_color;
   260e0:	9009      	str	r0, [sp, #36]	; 0x24
                        recolored_px = lv_color_mix(recolor, last_img_px, recolor_opa);
   260e2:	9301      	str	r3, [sp, #4]
   260e4:	f3c0 2307 	ubfx	r3, r0, #8, #8
   260e8:	9300      	str	r3, [sp, #0]
   260ea:	e9dd 210f 	ldrd	r2, r1, [sp, #60]	; 0x3c
   260ee:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
   260f2:	980e      	ldr	r0, [sp, #56]	; 0x38
   260f4:	f7ff fe08 	bl	25d08 <lv_color_mix.isra.0>
   260f8:	4681      	mov	r9, r0
                    if(disp->driver.set_px_cb) {
   260fa:	f8d8 3014 	ldr.w	r3, [r8, #20]
   260fe:	469c      	mov	ip, r3
   26100:	b1a3      	cbz	r3, 2612c <lv_draw_map+0x242>
                        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width, col + masked_a.x1,
   26102:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
   26106:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   26108:	e9cd 9401 	strd	r9, r4, [sp, #4]
   2610c:	441a      	add	r2, r3
   2610e:	4613      	mov	r3, r2
                        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width, col + masked_a.x1,
   26110:	9a06      	ldr	r2, [sp, #24]
   26112:	9200      	str	r2, [sp, #0]
   26114:	b21b      	sxth	r3, r3
   26116:	9a05      	ldr	r2, [sp, #20]
   26118:	f8da 1008 	ldr.w	r1, [sl, #8]
   2611c:	4640      	mov	r0, r8
   2611e:	4664      	mov	r4, ip
   26120:	47a0      	blx	r4
   26122:	e007      	b.n	26134 <lv_draw_map+0x24a>
                    px_color = *((lv_color_t *)px_color_p);
   26124:	9b08      	ldr	r3, [sp, #32]
   26126:	6818      	ldr	r0, [r3, #0]
   26128:	4634      	mov	r4, r6
   2612a:	e7c9      	b.n	260c0 <lv_draw_map+0x1d6>
                        if(opa_result == LV_OPA_COVER)
   2612c:	2cff      	cmp	r4, #255	; 0xff
   2612e:	d118      	bne.n	26162 <lv_draw_map+0x278>
                            vdb_buf_tmp[col].full = recolored_px.full;
   26130:	f8c7 9000 	str.w	r9, [r7]
                            }
   26134:	9b07      	ldr	r3, [sp, #28]
   26136:	3301      	adds	r3, #1
   26138:	9307      	str	r3, [sp, #28]
   2613a:	9b08      	ldr	r3, [sp, #32]
   2613c:	3304      	adds	r3, #4
   2613e:	3704      	adds	r7, #4
   26140:	9308      	str	r3, [sp, #32]
   26142:	f9bd 301c 	ldrsh.w	r3, [sp, #28]
   26146:	930b      	str	r3, [sp, #44]	; 0x2c
            for(col = 0; col < map_useful_w; col++) {
   26148:	e9dd 230b 	ldrd	r2, r3, [sp, #44]	; 0x2c
   2614c:	4293      	cmp	r3, r2
   2614e:	dca9      	bgt.n	260a4 <lv_draw_map+0x1ba>
            map_p += map_width * px_size_byte; /*Next row on the map*/
   26150:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   26152:	441d      	add	r5, r3
            vdb_buf_tmp += vdb_width;          /*Next row on the VDB*/
   26154:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   26156:	449b      	add	fp, r3
        for(row = masked_a.y1; row <= masked_a.y2; row++) {
   26158:	9b06      	ldr	r3, [sp, #24]
   2615a:	3301      	adds	r3, #1
   2615c:	b21b      	sxth	r3, r3
   2615e:	9306      	str	r3, [sp, #24]
   26160:	e796      	b.n	26090 <lv_draw_map+0x1a6>
                            vdb_buf_tmp[col] = lv_color_mix(recolored_px, vdb_buf_tmp[col], opa_result);
   26162:	783b      	ldrb	r3, [r7, #0]
   26164:	9402      	str	r4, [sp, #8]
   26166:	78ba      	ldrb	r2, [r7, #2]
   26168:	9201      	str	r2, [sp, #4]
   2616a:	787a      	ldrb	r2, [r7, #1]
   2616c:	9200      	str	r2, [sp, #0]
   2616e:	f3c9 2107 	ubfx	r1, r9, #8, #8
   26172:	f3c9 4207 	ubfx	r2, r9, #16, #8
   26176:	fa5f f089 	uxtb.w	r0, r9
                                vdb_buf_tmp[col] = lv_color_mix(px_color, vdb_buf_tmp[col], opa_result);
   2617a:	f7ff fdc5 	bl	25d08 <lv_color_mix.isra.0>
   2617e:	9b07      	ldr	r3, [sp, #28]
   26180:	f84b 0023 	str.w	r0, [fp, r3, lsl #2]
   26184:	e7d6      	b.n	26134 <lv_draw_map+0x24a>
                    if(disp->driver.set_px_cb) {
   26186:	f8d8 3014 	ldr.w	r3, [r8, #20]
   2618a:	469c      	mov	ip, r3
   2618c:	b13b      	cbz	r3, 2619e <lv_draw_map+0x2b4>
                        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width, col + masked_a.x1,
   2618e:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
   26192:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   26194:	441a      	add	r2, r3
   26196:	4613      	mov	r3, r2
   26198:	e9cd 0401 	strd	r0, r4, [sp, #4]
   2619c:	e7b8      	b.n	26110 <lv_draw_map+0x226>
                        if(opa_result == LV_OPA_COVER)
   2619e:	2cff      	cmp	r4, #255	; 0xff
   261a0:	d101      	bne.n	261a6 <lv_draw_map+0x2bc>
                            vdb_buf_tmp[col] = px_color;
   261a2:	6038      	str	r0, [r7, #0]
   261a4:	e7c6      	b.n	26134 <lv_draw_map+0x24a>
                                vdb_buf_tmp[col] = lv_color_mix(px_color, vdb_buf_tmp[col], opa_result);
   261a6:	783b      	ldrb	r3, [r7, #0]
   261a8:	9402      	str	r4, [sp, #8]
   261aa:	78ba      	ldrb	r2, [r7, #2]
   261ac:	9201      	str	r2, [sp, #4]
   261ae:	787a      	ldrb	r2, [r7, #1]
   261b0:	9200      	str	r2, [sp, #0]
   261b2:	f3c0 2107 	ubfx	r1, r0, #8, #8
   261b6:	f3c0 4207 	ubfx	r2, r0, #16, #8
   261ba:	b2c0      	uxtb	r0, r0
   261bc:	e7dd      	b.n	2617a <lv_draw_map+0x290>

000261be <lv_draw_cont_radius_corr>:
}

#endif

static uint16_t lv_draw_cont_radius_corr(uint16_t r, lv_coord_t w, lv_coord_t h)
{
   261be:	b570      	push	{r4, r5, r6, lr}
   261c0:	460e      	mov	r6, r1
   261c2:	4604      	mov	r4, r0
   261c4:	4615      	mov	r5, r2
    bool aa = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
   261c6:	f7f4 ff5b 	bl	1b080 <lv_refr_get_disp_refreshing>
   261ca:	f000 ff14 	bl	26ff6 <lv_disp_get_antialiasing>

    if(r >= (w >> 1)) {
   261ce:	1071      	asrs	r1, r6, #1
   261d0:	428c      	cmp	r4, r1
   261d2:	db03      	blt.n	261dc <lv_draw_cont_radius_corr+0x1e>
        r = (w >> 1);
   261d4:	b28c      	uxth	r4, r1
        if(r != 0) r--;
   261d6:	b10c      	cbz	r4, 261dc <lv_draw_cont_radius_corr+0x1e>
   261d8:	3c01      	subs	r4, #1
   261da:	b2a4      	uxth	r4, r4
    }
    if(r >= (h >> 1)) {
   261dc:	106a      	asrs	r2, r5, #1
   261de:	4294      	cmp	r4, r2
   261e0:	db03      	blt.n	261ea <lv_draw_cont_radius_corr+0x2c>
        r = (h >> 1);
   261e2:	b294      	uxth	r4, r2
        if(r != 0) r--;
   261e4:	b124      	cbz	r4, 261f0 <lv_draw_cont_radius_corr+0x32>
   261e6:	3c01      	subs	r4, #1
   261e8:	b2a4      	uxth	r4, r4
    }

    if(r > 0) r -= aa;
   261ea:	b10c      	cbz	r4, 261f0 <lv_draw_cont_radius_corr+0x32>
   261ec:	1a24      	subs	r4, r4, r0
   261ee:	b2a4      	uxth	r4, r4

    return r;
}
   261f0:	4620      	mov	r0, r4
   261f2:	bd70      	pop	{r4, r5, r6, pc}

000261f4 <lv_color_mix.isra.0>:
#elif LV_COLOR_DEPTH == 32
    return color.full;
#endif
}

static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
   261f4:	b530      	push	{r4, r5, lr}
   261f6:	f89d 5014 	ldrb.w	r5, [sp, #20]
{
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
   261fa:	b2ac      	uxth	r4, r5
   261fc:	f1c5 05ff 	rsb	r5, r5, #255	; 0xff
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
    LV_COLOR_SET_B(ret, (uint16_t)((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) * (255 - mix)) >> 8);
   26200:	436b      	muls	r3, r5
   26202:	fb00 3304 	mla	r3, r0, r4, r3
   26206:	f3c3 2307 	ubfx	r3, r3, #8, #8
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
   2620a:	2000      	movs	r0, #0
   2620c:	f363 0007 	bfi	r0, r3, #0, #8
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
   26210:	f89d 300c 	ldrb.w	r3, [sp, #12]
   26214:	fb13 f305 	smulbb	r3, r3, r5
   26218:	fb01 3104 	mla	r1, r1, r4, r3
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
   2621c:	f89d 3010 	ldrb.w	r3, [sp, #16]
   26220:	fb13 f505 	smulbb	r5, r3, r5
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
   26224:	f3c1 2107 	ubfx	r1, r1, #8, #8
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
   26228:	fb02 5204 	mla	r2, r2, r4, r5
    return ret;
   2622c:	f361 200f 	bfi	r0, r1, #8, #8
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
   26230:	f3c2 2207 	ubfx	r2, r2, #8, #8
    return ret;
   26234:	f362 4017 	bfi	r0, r2, #16, #8
}
   26238:	f040 407f 	orr.w	r0, r0, #4278190080	; 0xff000000
   2623c:	bd30      	pop	{r4, r5, pc}

0002623e <lv_draw_rect>:
{
   2623e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   26242:	b09d      	sub	sp, #116	; 0x74
   26244:	e9cd 1205 	strd	r1, r2, [sp, #20]
   26248:	9307      	str	r3, [sp, #28]
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   2624a:	88c3      	ldrh	r3, [r0, #6]
   2624c:	8842      	ldrh	r2, [r0, #2]
   2624e:	3301      	adds	r3, #1
   26250:	1a9b      	subs	r3, r3, r2
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
   26252:	b21b      	sxth	r3, r3
   26254:	2b00      	cmp	r3, #0
{
   26256:	4681      	mov	r9, r0
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
   26258:	f340 8236 	ble.w	266c8 <lv_draw_rect+0x48a>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   2625c:	8883      	ldrh	r3, [r0, #4]
   2625e:	8802      	ldrh	r2, [r0, #0]
   26260:	3301      	adds	r3, #1
   26262:	1a9b      	subs	r3, r3, r2
   26264:	b21b      	sxth	r3, r3
   26266:	2b00      	cmp	r3, #0
   26268:	f340 822e 	ble.w	266c8 <lv_draw_rect+0x48a>
    if(lv_area_is_on(coords, mask) == false) return;
   2626c:	f000 ff79 	bl	27162 <lv_area_is_on>
   26270:	2800      	cmp	r0, #0
   26272:	f000 8229 	beq.w	266c8 <lv_draw_rect+0x48a>
    if(style->body.opa > LV_OPA_MIN) {
   26276:	9b06      	ldr	r3, [sp, #24]
   26278:	7b9b      	ldrb	r3, [r3, #14]
   2627a:	2b10      	cmp	r3, #16
   2627c:	f240 80fd 	bls.w	2647a <lv_draw_rect+0x23c>
    uint16_t radius = style->body.radius;
   26280:	9b06      	ldr	r3, [sp, #24]
   26282:	899d      	ldrh	r5, [r3, #12]
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
   26284:	f7f4 fefc 	bl	1b080 <lv_refr_get_disp_refreshing>
   26288:	f000 feb5 	bl	26ff6 <lv_disp_get_antialiasing>
    lv_color_t mcolor = style->body.main_color;
   2628c:	9b06      	ldr	r3, [sp, #24]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   2628e:	f8b9 6006 	ldrh.w	r6, [r9, #6]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   26292:	f8b9 1004 	ldrh.w	r1, [r9, #4]
    lv_color_t gcolor = style->body.grad_color;
   26296:	e9d3 8a01 	ldrd	r8, sl, [r3, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   2629a:	f8b9 3002 	ldrh.w	r3, [r9, #2]
   2629e:	3601      	adds	r6, #1
   262a0:	1af6      	subs	r6, r6, r3
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   262a2:	f8b9 3000 	ldrh.w	r3, [r9]
   262a6:	3101      	adds	r1, #1
   262a8:	1ac9      	subs	r1, r1, r3
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
   262aa:	9b07      	ldr	r3, [sp, #28]
   262ac:	2bff      	cmp	r3, #255	; 0xff
   262ae:	9b06      	ldr	r3, [sp, #24]
   262b0:	7b9f      	ldrb	r7, [r3, #14]
   262b2:	bf18      	it	ne
   262b4:	9b07      	ldrne	r3, [sp, #28]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   262b6:	b236      	sxth	r6, r6
   262b8:	bf18      	it	ne
   262ba:	435f      	mulne	r7, r3
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
   262bc:	4604      	mov	r4, r0
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   262be:	b209      	sxth	r1, r1
    radius = lv_draw_cont_radius_corr(radius, width, height);
   262c0:	4632      	mov	r2, r6
   262c2:	4628      	mov	r0, r5
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
   262c4:	bf18      	it	ne
   262c6:	0a3f      	lsrne	r7, r7, #8
    radius = lv_draw_cont_radius_corr(radius, width, height);
   262c8:	f7ff ff79 	bl	261be <lv_draw_cont_radius_corr>
    if(radius > height / 2) return;
   262cc:	eb06 73d6 	add.w	r3, r6, r6, lsr #31
   262d0:	ebb0 0f63 	cmp.w	r0, r3, asr #1
   262d4:	f340 81fb 	ble.w	266ce <lv_draw_rect+0x490>
        if(style->body.radius != 0) {
   262d8:	9b06      	ldr	r3, [sp, #24]
   262da:	f9b3 700c 	ldrsh.w	r7, [r3, #12]
   262de:	2f00      	cmp	r7, #0
   262e0:	f000 80cb 	beq.w	2647a <lv_draw_rect+0x23c>
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
   262e4:	f7f4 fecc 	bl	1b080 <lv_refr_get_disp_refreshing>
   262e8:	f000 fe85 	bl	26ff6 <lv_disp_get_antialiasing>
    lv_color_t mcolor = style->body.main_color;
   262ec:	9b06      	ldr	r3, [sp, #24]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   262ee:	f8b9 a006 	ldrh.w	sl, [r9, #6]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   262f2:	f8b9 1004 	ldrh.w	r1, [r9, #4]
    lv_color_t gcolor = style->body.grad_color;
   262f6:	e9d3 4501 	ldrd	r4, r5, [r3, #4]
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
   262fa:	9b07      	ldr	r3, [sp, #28]
   262fc:	2bff      	cmp	r3, #255	; 0xff
   262fe:	9b06      	ldr	r3, [sp, #24]
   26300:	7b9e      	ldrb	r6, [r3, #14]
   26302:	bf1c      	itt	ne
   26304:	9b07      	ldrne	r3, [sp, #28]
   26306:	435e      	mulne	r6, r3
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   26308:	f8b9 3002 	ldrh.w	r3, [r9, #2]
   2630c:	f10a 0a01 	add.w	sl, sl, #1
   26310:	ebaa 0a03 	sub.w	sl, sl, r3
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   26314:	f8b9 3000 	ldrh.w	r3, [r9]
   26318:	f101 0101 	add.w	r1, r1, #1
   2631c:	eba1 0103 	sub.w	r1, r1, r3
    uint16_t radius = style->body.radius;
   26320:	b2bf      	uxth	r7, r7
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   26322:	fa0f fa8a 	sxth.w	sl, sl
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
   26326:	4683      	mov	fp, r0
    radius = lv_draw_cont_radius_corr(radius, width, height);
   26328:	4652      	mov	r2, sl
   2632a:	b209      	sxth	r1, r1
   2632c:	4638      	mov	r0, r7
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
   2632e:	bf18      	it	ne
   26330:	0a36      	lsrne	r6, r6, #8
    radius = lv_draw_cont_radius_corr(radius, width, height);
   26332:	f7ff ff44 	bl	261be <lv_draw_cont_radius_corr>
    lt_origo.x = coords->x1 + radius + aa;
   26336:	f8b9 3000 	ldrh.w	r3, [r9]
   2633a:	fa0f f18b 	sxth.w	r1, fp
   2633e:	b202      	sxth	r2, r0
   26340:	440b      	add	r3, r1
   26342:	4413      	add	r3, r2
   26344:	fa0f f883 	sxth.w	r8, r3
    lt_origo.y = coords->y1 + radius + aa;
   26348:	f8b9 3002 	ldrh.w	r3, [r9, #2]
    rt_origo.x = coords->x2 - radius - aa;
   2634c:	f8b9 b004 	ldrh.w	fp, [r9, #4]
    lt_origo.y = coords->y1 + radius + aa;
   26350:	440b      	add	r3, r1
   26352:	4413      	add	r3, r2
   26354:	b21b      	sxth	r3, r3
   26356:	9308      	str	r3, [sp, #32]
    lb_origo.y = coords->y2 - radius - aa;
   26358:	f8b9 3006 	ldrh.w	r3, [r9, #6]
   2635c:	1a5b      	subs	r3, r3, r1
   2635e:	1a9b      	subs	r3, r3, r2
   26360:	b21b      	sxth	r3, r3
    rt_origo.x = coords->x2 - radius - aa;
   26362:	ebab 0b01 	sub.w	fp, fp, r1
    lv_circ_init(&cir, &cir_tmp, radius);
   26366:	a813      	add	r0, sp, #76	; 0x4c
   26368:	f10d 014a 	add.w	r1, sp, #74	; 0x4a
    rt_origo.x = coords->x2 - radius - aa;
   2636c:	ebab 0b02 	sub.w	fp, fp, r2
    lb_origo.y = coords->y2 - radius - aa;
   26370:	9309      	str	r3, [sp, #36]	; 0x24
    lv_circ_init(&cir, &cir_tmp, radius);
   26372:	f000 fe6b 	bl	2704c <lv_circ_init>
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
   26376:	9b09      	ldr	r3, [sp, #36]	; 0x24
   26378:	f8bd 204e 	ldrh.w	r2, [sp, #78]	; 0x4e
   2637c:	f9bd 104c 	ldrsh.w	r1, [sp, #76]	; 0x4c
    rt_origo.x = coords->x2 - radius - aa;
   26380:	fa0f fb8b 	sxth.w	fp, fp
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
   26384:	441a      	add	r2, r3
   26386:	b212      	sxth	r2, r2
   26388:	eb0b 0301 	add.w	r3, fp, r1
   2638c:	eba8 0101 	sub.w	r1, r8, r1
   26390:	9200      	str	r2, [sp, #0]
   26392:	b21b      	sxth	r3, r3
   26394:	b209      	sxth	r1, r1
   26396:	a818      	add	r0, sp, #96	; 0x60
   26398:	f000 fe7d 	bl	27096 <lv_area_set>
    lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
   2639c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2639e:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
   263a2:	f9bd 104e 	ldrsh.w	r1, [sp, #78]	; 0x4e
   263a6:	441a      	add	r2, r3
   263a8:	b212      	sxth	r2, r2
   263aa:	eb0b 0301 	add.w	r3, fp, r1
   263ae:	eba8 0101 	sub.w	r1, r8, r1
   263b2:	9200      	str	r2, [sp, #0]
   263b4:	b21b      	sxth	r3, r3
   263b6:	b209      	sxth	r1, r1
   263b8:	a81a      	add	r0, sp, #104	; 0x68
   263ba:	f000 fe6c 	bl	27096 <lv_area_set>
    lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
   263be:	9b08      	ldr	r3, [sp, #32]
   263c0:	f8bd 204e 	ldrh.w	r2, [sp, #78]	; 0x4e
   263c4:	f9bd 104c 	ldrsh.w	r1, [sp, #76]	; 0x4c
   263c8:	1a9a      	subs	r2, r3, r2
   263ca:	b212      	sxth	r2, r2
   263cc:	eb0b 0301 	add.w	r3, fp, r1
   263d0:	eba8 0101 	sub.w	r1, r8, r1
   263d4:	9200      	str	r2, [sp, #0]
   263d6:	b21b      	sxth	r3, r3
   263d8:	b209      	sxth	r1, r1
   263da:	a816      	add	r0, sp, #88	; 0x58
   263dc:	f000 fe5b 	bl	27096 <lv_area_set>
    lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
   263e0:	9b08      	ldr	r3, [sp, #32]
   263e2:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
   263e6:	f9bd 104e 	ldrsh.w	r1, [sp, #78]	; 0x4e
   263ea:	1a9a      	subs	r2, r3, r2
   263ec:	b212      	sxth	r2, r2
   263ee:	eb0b 0301 	add.w	r3, fp, r1
   263f2:	af14      	add	r7, sp, #80	; 0x50
   263f4:	eba8 0101 	sub.w	r1, r8, r1
   263f8:	b21b      	sxth	r3, r3
   263fa:	9200      	str	r2, [sp, #0]
   263fc:	b209      	sxth	r1, r1
   263fe:	4638      	mov	r0, r7
   26400:	f000 fe49 	bl	27096 <lv_area_set>
    while(lv_circ_cont(&cir)) {
   26404:	ab13      	add	r3, sp, #76	; 0x4c
            lv_draw_fill(&edge_top_area, mask, act_color, opa);
   26406:	e9cd 370b 	strd	r3, r7, [sp, #44]	; 0x2c
                act_color = lv_color_mix(mcolor, gcolor, mix);
   2640a:	b2eb      	uxtb	r3, r5
   2640c:	930a      	str	r3, [sp, #40]	; 0x28
    while(lv_circ_cont(&cir)) {
   2640e:	980b      	ldr	r0, [sp, #44]	; 0x2c
   26410:	f000 fe23 	bl	2705a <lv_circ_cont>
   26414:	2800      	cmp	r0, #0
   26416:	f040 81c3 	bne.w	267a0 <lv_draw_rect+0x562>
    if(mcolor.full == gcolor.full)
   2641a:	42ac      	cmp	r4, r5
   2641c:	f040 82bd 	bne.w	2699a <lv_draw_rect+0x75c>
        act_color = mcolor;
   26420:	4622      	mov	r2, r4
    lv_draw_fill(&edge_top_area, mask, act_color, opa);
   26422:	4633      	mov	r3, r6
   26424:	9905      	ldr	r1, [sp, #20]
   26426:	a814      	add	r0, sp, #80	; 0x50
   26428:	f7ff fc93 	bl	25d52 <lv_draw_fill>
    if(edge_top_area.y1 != mid_top_area.y1) {
   2642c:	f9bd 205a 	ldrsh.w	r2, [sp, #90]	; 0x5a
   26430:	f9bd 3052 	ldrsh.w	r3, [sp, #82]	; 0x52
   26434:	4293      	cmp	r3, r2
   26436:	d008      	beq.n	2644a <lv_draw_rect+0x20c>
        if(mcolor.full == gcolor.full)
   26438:	42ac      	cmp	r4, r5
   2643a:	f040 82c9 	bne.w	269d0 <lv_draw_rect+0x792>
            act_color = mcolor;
   2643e:	4622      	mov	r2, r4
        lv_draw_fill(&mid_top_area, mask, act_color, opa);
   26440:	4633      	mov	r3, r6
   26442:	9905      	ldr	r1, [sp, #20]
   26444:	a816      	add	r0, sp, #88	; 0x58
   26446:	f7ff fc84 	bl	25d52 <lv_draw_fill>
    if(mcolor.full == gcolor.full)
   2644a:	42ac      	cmp	r4, r5
   2644c:	f040 82d9 	bne.w	26a02 <lv_draw_rect+0x7c4>
        act_color = mcolor;
   26450:	4622      	mov	r2, r4
    lv_draw_fill(&mid_bot_area, mask, act_color, opa);
   26452:	4633      	mov	r3, r6
   26454:	9905      	ldr	r1, [sp, #20]
   26456:	a818      	add	r0, sp, #96	; 0x60
   26458:	f7ff fc7b 	bl	25d52 <lv_draw_fill>
    if(edge_bot_area.y1 != mid_bot_area.y1) {
   2645c:	f9bd 206a 	ldrsh.w	r2, [sp, #106]	; 0x6a
   26460:	f9bd 3062 	ldrsh.w	r3, [sp, #98]	; 0x62
   26464:	4293      	cmp	r3, r2
   26466:	d008      	beq.n	2647a <lv_draw_rect+0x23c>
        if(mcolor.full == gcolor.full)
   26468:	42ac      	cmp	r4, r5
   2646a:	f040 82e5 	bne.w	26a38 <lv_draw_rect+0x7fa>
            act_color = mcolor;
   2646e:	4622      	mov	r2, r4
        lv_draw_fill(&edge_bot_area, mask, act_color, opa);
   26470:	4633      	mov	r3, r6
   26472:	9905      	ldr	r1, [sp, #20]
   26474:	a81a      	add	r0, sp, #104	; 0x68
   26476:	f7ff fc6c 	bl	25d52 <lv_draw_fill>
    if(style->body.border.width != 0 && style->body.border.part != LV_BORDER_NONE &&
   2647a:	9b06      	ldr	r3, [sp, #24]
   2647c:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
   26480:	2b00      	cmp	r3, #0
   26482:	f000 8121 	beq.w	266c8 <lv_draw_rect+0x48a>
   26486:	9b06      	ldr	r3, [sp, #24]
   26488:	7d9b      	ldrb	r3, [r3, #22]
   2648a:	2b00      	cmp	r3, #0
   2648c:	f000 811c 	beq.w	266c8 <lv_draw_rect+0x48a>
   26490:	9b06      	ldr	r3, [sp, #24]
   26492:	7ddb      	ldrb	r3, [r3, #23]
   26494:	2b0f      	cmp	r3, #15
   26496:	f240 8117 	bls.w	266c8 <lv_draw_rect+0x48a>
    uint16_t radius = style->body.radius;
   2649a:	9b06      	ldr	r3, [sp, #24]
   2649c:	f8b3 a00c 	ldrh.w	sl, [r3, #12]
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
   264a0:	f7f4 fdee 	bl	1b080 <lv_refr_get_disp_refreshing>
   264a4:	f000 fda7 	bl	26ff6 <lv_disp_get_antialiasing>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   264a8:	f8b9 1004 	ldrh.w	r1, [r9, #4]
   264ac:	f8b9 3000 	ldrh.w	r3, [r9]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   264b0:	f8b9 2006 	ldrh.w	r2, [r9, #6]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   264b4:	3101      	adds	r1, #1
   264b6:	1ac9      	subs	r1, r1, r3
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   264b8:	f8b9 3002 	ldrh.w	r3, [r9, #2]
   264bc:	3201      	adds	r2, #1
   264be:	1ad2      	subs	r2, r2, r3
    lv_coord_t bwidth = style->body.border.width;
   264c0:	9b06      	ldr	r3, [sp, #24]
   264c2:	f9b3 b014 	ldrsh.w	fp, [r3, #20]
    lv_opa_t opa      = opa_scale == LV_OPA_COVER ? style->body.border.opa
   264c6:	9b07      	ldr	r3, [sp, #28]
   264c8:	2bff      	cmp	r3, #255	; 0xff
   264ca:	9b06      	ldr	r3, [sp, #24]
   264cc:	7ddc      	ldrb	r4, [r3, #23]
   264ce:	bf1c      	itt	ne
   264d0:	9b07      	ldrne	r3, [sp, #28]
   264d2:	435c      	mulne	r4, r3
    lv_border_part_t part = style->body.border.part;
   264d4:	9b06      	ldr	r3, [sp, #24]
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
   264d6:	4680      	mov	r8, r0
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   264d8:	b209      	sxth	r1, r1
    radius = lv_draw_cont_radius_corr(radius, width, height);
   264da:	4650      	mov	r0, sl
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   264dc:	b212      	sxth	r2, r2
    lv_opa_t opa      = opa_scale == LV_OPA_COVER ? style->body.border.opa
   264de:	bf18      	it	ne
   264e0:	0a24      	lsrne	r4, r4, #8
    lv_border_part_t part = style->body.border.part;
   264e2:	7d9e      	ldrb	r6, [r3, #22]
    lv_color_t color      = style->body.border.color;
   264e4:	691f      	ldr	r7, [r3, #16]
    radius = lv_draw_cont_radius_corr(radius, width, height);
   264e6:	f7ff fe6a 	bl	261be <lv_draw_cont_radius_corr>
    bwidth--;
   264ea:	f10b 35ff 	add.w	r5, fp, #4294967295	; 0xffffffff
   264ee:	b22d      	sxth	r5, r5
    if(radius < bwidth) {
   264f0:	42a8      	cmp	r0, r5
    radius = lv_draw_cont_radius_corr(radius, width, height);
   264f2:	4682      	mov	sl, r0
    if(radius < bwidth) {
   264f4:	f280 82b9 	bge.w	26a6a <lv_draw_rect+0x82c>
        length_corr = bwidth - radius - aa;
   264f8:	eba5 0308 	sub.w	r3, r5, r8
   264fc:	1a1b      	subs	r3, r3, r0
   264fe:	b21b      	sxth	r3, r3
   26500:	9309      	str	r3, [sp, #36]	; 0x24
        corner_size = bwidth;
   26502:	462b      	mov	r3, r5
    if(style->body.radius == 0) {
   26504:	9a06      	ldr	r2, [sp, #24]
   26506:	f9b2 200c 	ldrsh.w	r2, [r2, #12]
   2650a:	f006 0102 	and.w	r1, r6, #2
   2650e:	9108      	str	r1, [sp, #32]
   26510:	2a00      	cmp	r2, #0
   26512:	f040 82b0 	bne.w	26a76 <lv_draw_rect+0x838>
        if(part & LV_BORDER_TOP) {
   26516:	b1a1      	cbz	r1, 26542 <lv_draw_rect+0x304>
            work_area.x1 = coords->x1;
   26518:	f8b9 3000 	ldrh.w	r3, [r9]
   2651c:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            work_area.x2 = coords->x2;
   26520:	f8b9 3004 	ldrh.w	r3, [r9, #4]
   26524:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.y1 = coords->y1;
   26528:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
   2652c:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            work_area.y2 = coords->y1 + bwidth;
   26530:	442b      	add	r3, r5
   26532:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
   26536:	463a      	mov	r2, r7
   26538:	4623      	mov	r3, r4
   2653a:	9905      	ldr	r1, [sp, #20]
   2653c:	a81a      	add	r0, sp, #104	; 0x68
   2653e:	f7ff fc08 	bl	25d52 <lv_draw_fill>
        if(part & LV_BORDER_RIGHT) {
   26542:	0731      	lsls	r1, r6, #28
   26544:	d520      	bpl.n	26588 <lv_draw_rect+0x34a>
            work_area.x1 = coords->x2 - bwidth;
   26546:	f9b9 3004 	ldrsh.w	r3, [r9, #4]
            work_area.x2 = coords->x2;
   2654a:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.x1 = coords->x2 - bwidth;
   2654e:	1b5a      	subs	r2, r3, r5
   26550:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
   26554:	9a08      	ldr	r2, [sp, #32]
   26556:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
            lv_draw_fill(&work_area, mask, color, opa);
   2655a:	9905      	ldr	r1, [sp, #20]
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
   2655c:	2a00      	cmp	r2, #0
   2655e:	bf14      	ite	ne
   26560:	465a      	movne	r2, fp
   26562:	2200      	moveq	r2, #0
   26564:	4413      	add	r3, r2
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
   26566:	f016 0f01 	tst.w	r6, #1
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
   2656a:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
   2656e:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
   26572:	bf14      	ite	ne
   26574:	465a      	movne	r2, fp
   26576:	2200      	moveq	r2, #0
   26578:	1a9b      	subs	r3, r3, r2
   2657a:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
   2657e:	463a      	mov	r2, r7
   26580:	4623      	mov	r3, r4
   26582:	a81a      	add	r0, sp, #104	; 0x68
   26584:	f7ff fbe5 	bl	25d52 <lv_draw_fill>
        if(part & LV_BORDER_LEFT) {
   26588:	f016 0f04 	tst.w	r6, #4
   2658c:	f006 0601 	and.w	r6, r6, #1
   26590:	d020      	beq.n	265d4 <lv_draw_rect+0x396>
            work_area.x1 = coords->x1;
   26592:	f9b9 3000 	ldrsh.w	r3, [r9]
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
   26596:	9a08      	ldr	r2, [sp, #32]
            work_area.x1 = coords->x1;
   26598:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            work_area.x2 = coords->x1 + bwidth;
   2659c:	442b      	add	r3, r5
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
   2659e:	2a00      	cmp	r2, #0
            work_area.x2 = coords->x1 + bwidth;
   265a0:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
   265a4:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
            lv_draw_fill(&work_area, mask, color, opa);
   265a8:	9905      	ldr	r1, [sp, #20]
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
   265aa:	bf14      	ite	ne
   265ac:	465a      	movne	r2, fp
   265ae:	2200      	moveq	r2, #0
   265b0:	4413      	add	r3, r2
   265b2:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
   265b6:	2e00      	cmp	r6, #0
   265b8:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
   265bc:	bf08      	it	eq
   265be:	f04f 0b00 	moveq.w	fp, #0
   265c2:	eba3 0b0b 	sub.w	fp, r3, fp
            lv_draw_fill(&work_area, mask, color, opa);
   265c6:	463a      	mov	r2, r7
   265c8:	4623      	mov	r3, r4
   265ca:	a81a      	add	r0, sp, #104	; 0x68
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
   265cc:	f8ad b06e 	strh.w	fp, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
   265d0:	f7ff fbbf 	bl	25d52 <lv_draw_fill>
        if(part & LV_BORDER_BOTTOM) {
   265d4:	b1a6      	cbz	r6, 26600 <lv_draw_rect+0x3c2>
            work_area.x1 = coords->x1;
   265d6:	f8b9 3000 	ldrh.w	r3, [r9]
   265da:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            work_area.x2 = coords->x2;
   265de:	f8b9 3004 	ldrh.w	r3, [r9, #4]
   265e2:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.y1 = coords->y2 - bwidth;
   265e6:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
   265ea:	1b5d      	subs	r5, r3, r5
   265ec:	f8ad 506a 	strh.w	r5, [sp, #106]	; 0x6a
            work_area.y2 = coords->y2;
   265f0:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
   265f4:	463a      	mov	r2, r7
   265f6:	4623      	mov	r3, r4
   265f8:	9905      	ldr	r1, [sp, #20]
   265fa:	a81a      	add	r0, sp, #104	; 0x68
   265fc:	f7ff fba9 	bl	25d52 <lv_draw_fill>
        if(style->body.radius != 0) {
   26600:	9b06      	ldr	r3, [sp, #24]
   26602:	f9b3 400c 	ldrsh.w	r4, [r3, #12]
   26606:	2c00      	cmp	r4, #0
   26608:	d05e      	beq.n	266c8 <lv_draw_rect+0x48a>
    bool aa               = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
   2660a:	f7f4 fd39 	bl	1b080 <lv_refr_get_disp_refreshing>
   2660e:	f000 fcf2 	bl	26ff6 <lv_disp_get_antialiasing>
    lv_coord_t bwidth     = style->body.border.width;
   26612:	9b06      	ldr	r3, [sp, #24]
   26614:	f8b9 2006 	ldrh.w	r2, [r9, #6]
   26618:	f9b3 a014 	ldrsh.w	sl, [r3, #20]
    lv_color_t color      = style->body.border.color;
   2661c:	f8d3 b010 	ldr.w	fp, [r3, #16]
    lv_border_part_t part = style->body.border.part;
   26620:	7d9b      	ldrb	r3, [r3, #22]
   26622:	9308      	str	r3, [sp, #32]
    lv_opa_t opa          = opa_scale == LV_OPA_COVER ? style->body.border.opa
   26624:	9b07      	ldr	r3, [sp, #28]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   26626:	f8b9 1004 	ldrh.w	r1, [r9, #4]
   2662a:	2bff      	cmp	r3, #255	; 0xff
   2662c:	9b06      	ldr	r3, [sp, #24]
   2662e:	7ddd      	ldrb	r5, [r3, #23]
   26630:	bf1c      	itt	ne
   26632:	9b07      	ldrne	r3, [sp, #28]
   26634:	435d      	mulne	r5, r3
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   26636:	f8b9 3002 	ldrh.w	r3, [r9, #2]
   2663a:	f102 0201 	add.w	r2, r2, #1
   2663e:	eba2 0203 	sub.w	r2, r2, r3
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   26642:	f8b9 3000 	ldrh.w	r3, [r9]
   26646:	f101 0101 	add.w	r1, r1, #1
   2664a:	eba1 0103 	sub.w	r1, r1, r3
    uint16_t radius       = style->body.radius;
   2664e:	b2a4      	uxth	r4, r4
    bool aa               = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
   26650:	4606      	mov	r6, r0
    radius = lv_draw_cont_radius_corr(radius, width, height);
   26652:	b212      	sxth	r2, r2
   26654:	b209      	sxth	r1, r1
   26656:	4620      	mov	r0, r4
    lv_opa_t opa          = opa_scale == LV_OPA_COVER ? style->body.border.opa
   26658:	bf18      	it	ne
   2665a:	0a2d      	lsrne	r5, r5, #8
    radius = lv_draw_cont_radius_corr(radius, width, height);
   2665c:	f7ff fdaf 	bl	261be <lv_draw_cont_radius_corr>
    lb_origo.y = coords->y2 - radius - aa;
   26660:	f8b9 3006 	ldrh.w	r3, [r9, #6]
    lt_origo.x = coords->x1 + radius + aa;
   26664:	f8b9 7000 	ldrh.w	r7, [r9]
    lt_origo.y = coords->y1 + radius + aa;
   26668:	f8b9 8002 	ldrh.w	r8, [r9, #2]
    rt_origo.x = coords->x2 - radius - aa;
   2666c:	f8b9 9004 	ldrh.w	r9, [r9, #4]
    lt_origo.x = coords->x1 + radius + aa;
   26670:	b232      	sxth	r2, r6
   26672:	b204      	sxth	r4, r0
    lb_origo.y = coords->y2 - radius - aa;
   26674:	1a9b      	subs	r3, r3, r2
   26676:	1b1b      	subs	r3, r3, r4
    lt_origo.x = coords->x1 + radius + aa;
   26678:	4417      	add	r7, r2
    lt_origo.y = coords->y1 + radius + aa;
   2667a:	4490      	add	r8, r2
    rt_origo.x = coords->x2 - radius - aa;
   2667c:	eba9 0902 	sub.w	r9, r9, r2
    lv_circ_init(&cir_out, &tmp_out, radius);
   26680:	a913      	add	r1, sp, #76	; 0x4c
   26682:	4622      	mov	r2, r4
   26684:	a816      	add	r0, sp, #88	; 0x58
    lb_origo.y = coords->y2 - radius - aa;
   26686:	b21e      	sxth	r6, r3
    lv_circ_init(&cir_out, &tmp_out, radius);
   26688:	f000 fce0 	bl	2704c <lv_circ_init>
    lv_coord_t radius_in = radius - bwidth;
   2668c:	f1ca 0201 	rsb	r2, sl, #1
   26690:	4422      	add	r2, r4
   26692:	b212      	sxth	r2, r2
    lv_circ_init(&cir_in, &tmp_in, radius_in);
   26694:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
   26698:	a914      	add	r1, sp, #80	; 0x50
   2669a:	a818      	add	r0, sp, #96	; 0x60
   2669c:	f000 fcd6 	bl	2704c <lv_circ_init>
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
   266a0:	9b08      	ldr	r3, [sp, #32]
    lt_origo.x = coords->x1 + radius + aa;
   266a2:	4427      	add	r7, r4
    lt_origo.y = coords->y1 + radius + aa;
   266a4:	44a0      	add	r8, r4
    rt_origo.x = coords->x2 - radius - aa;
   266a6:	eba9 0904 	sub.w	r9, r9, r4
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
   266aa:	f003 0309 	and.w	r3, r3, #9
    lt_origo.x = coords->x1 + radius + aa;
   266ae:	b23f      	sxth	r7, r7
    lt_origo.y = coords->y1 + radius + aa;
   266b0:	fa0f f888 	sxth.w	r8, r8
    rt_origo.x = coords->x2 - radius - aa;
   266b4:	fa0f f989 	sxth.w	r9, r9
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
   266b8:	9306      	str	r3, [sp, #24]
    while(cir_out.y <= cir_out.x) {
   266ba:	f9bd 305a 	ldrsh.w	r3, [sp, #90]	; 0x5a
   266be:	f9bd 2058 	ldrsh.w	r2, [sp, #88]	; 0x58
   266c2:	429a      	cmp	r2, r3
   266c4:	f280 8330 	bge.w	26d28 <lv_draw_rect+0xaea>
}
   266c8:	b01d      	add	sp, #116	; 0x74
   266ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    work_area.x1 = coords->x1;
   266ce:	f8b9 3000 	ldrh.w	r3, [r9]
   266d2:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    work_area.x2 = coords->x2;
   266d6:	f8b9 3004 	ldrh.w	r3, [r9, #4]
   266da:	f8b9 5006 	ldrh.w	r5, [r9, #6]
   266de:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
    if(mcolor.full == gcolor.full) {
   266e2:	f8b9 3002 	ldrh.w	r3, [r9, #2]
   266e6:	9a06      	ldr	r2, [sp, #24]
   266e8:	b200      	sxth	r0, r0
   266ea:	4403      	add	r3, r0
   266ec:	45d0      	cmp	r8, sl
   266ee:	eba5 0000 	sub.w	r0, r5, r0
   266f2:	b21b      	sxth	r3, r3
   266f4:	b205      	sxth	r5, r0
   266f6:	f9b2 200c 	ldrsh.w	r2, [r2, #12]
   266fa:	d117      	bne.n	2672c <lv_draw_rect+0x4ee>
        work_area.y1 = coords->y1 + radius;
   266fc:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
        work_area.y2 = coords->y2 - radius;
   26700:	f8ad 506e 	strh.w	r5, [sp, #110]	; 0x6e
        if(style->body.radius != 0) {
   26704:	b132      	cbz	r2, 26714 <lv_draw_rect+0x4d6>
            if(aa) {
   26706:	b164      	cbz	r4, 26722 <lv_draw_rect+0x4e4>
                work_area.y1 += 2;
   26708:	1c9c      	adds	r4, r3, #2
   2670a:	f8ad 406a 	strh.w	r4, [sp, #106]	; 0x6a
                work_area.y2 -= 2;
   2670e:	3d02      	subs	r5, #2
                work_area.y2 -= 1;
   26710:	f8ad 506e 	strh.w	r5, [sp, #110]	; 0x6e
        lv_draw_fill(&work_area, mask, mcolor, opa);
   26714:	463b      	mov	r3, r7
   26716:	4642      	mov	r2, r8
   26718:	9905      	ldr	r1, [sp, #20]
   2671a:	a81a      	add	r0, sp, #104	; 0x68
   2671c:	f7ff fb19 	bl	25d52 <lv_draw_fill>
   26720:	e5da      	b.n	262d8 <lv_draw_rect+0x9a>
                work_area.y1 += 1;
   26722:	1c5c      	adds	r4, r3, #1
   26724:	f8ad 406a 	strh.w	r4, [sp, #106]	; 0x6a
                work_area.y2 -= 1;
   26728:	3d01      	subs	r5, #1
   2672a:	e7f1      	b.n	26710 <lv_draw_rect+0x4d2>
        if(style->body.radius != 0) {
   2672c:	b122      	cbz	r2, 26738 <lv_draw_rect+0x4fa>
            if(aa) {
   2672e:	b39c      	cbz	r4, 26798 <lv_draw_rect+0x55a>
                row_start += 2;
   26730:	1c9c      	adds	r4, r3, #2
   26732:	b223      	sxth	r3, r4
                row_end -= 2;
   26734:	3d02      	subs	r5, #2
                row_end -= 1;
   26736:	b22d      	sxth	r5, r5
        if(row_start < 0) row_start = 0;
   26738:	ea23 74e3 	bic.w	r4, r3, r3, asr #31
            act_color    = lv_color_mix(mcolor, gcolor, mix);
   2673c:	fa5f f38a 	uxtb.w	r3, sl
   26740:	9308      	str	r3, [sp, #32]
   26742:	f3c8 4307 	ubfx	r3, r8, #16, #8
   26746:	9309      	str	r3, [sp, #36]	; 0x24
   26748:	f3c8 2b07 	ubfx	fp, r8, #8, #8
        for(row = row_start; row <= row_end; row++) {
   2674c:	42ac      	cmp	r4, r5
   2674e:	f73f adc3 	bgt.w	262d8 <lv_draw_rect+0x9a>
            mix          = (uint32_t)((uint32_t)(coords->y2 - work_area.y1) * 255) / height;
   26752:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
            work_area.y1 = row;
   26756:	f8ad 406a 	strh.w	r4, [sp, #106]	; 0x6a
            mix          = (uint32_t)((uint32_t)(coords->y2 - work_area.y1) * 255) / height;
   2675a:	1b1b      	subs	r3, r3, r4
   2675c:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
   26760:	fbb3 f3f6 	udiv	r3, r3, r6
            act_color    = lv_color_mix(mcolor, gcolor, mix);
   26764:	b2db      	uxtb	r3, r3
   26766:	9302      	str	r3, [sp, #8]
   26768:	f3ca 4307 	ubfx	r3, sl, #16, #8
   2676c:	9301      	str	r3, [sp, #4]
   2676e:	f3ca 2307 	ubfx	r3, sl, #8, #8
   26772:	9300      	str	r3, [sp, #0]
   26774:	4659      	mov	r1, fp
   26776:	e9dd 3208 	ldrd	r3, r2, [sp, #32]
   2677a:	fa5f f088 	uxtb.w	r0, r8
            work_area.y2 = row;
   2677e:	f8ad 406e 	strh.w	r4, [sp, #110]	; 0x6e
            act_color    = lv_color_mix(mcolor, gcolor, mix);
   26782:	f7ff fd37 	bl	261f4 <lv_color_mix.isra.0>
        for(row = row_start; row <= row_end; row++) {
   26786:	3401      	adds	r4, #1
            lv_draw_fill(&work_area, mask, act_color, opa);
   26788:	4602      	mov	r2, r0
   2678a:	463b      	mov	r3, r7
   2678c:	9905      	ldr	r1, [sp, #20]
   2678e:	a81a      	add	r0, sp, #104	; 0x68
   26790:	f7ff fadf 	bl	25d52 <lv_draw_fill>
        for(row = row_start; row <= row_end; row++) {
   26794:	b224      	sxth	r4, r4
   26796:	e7d9      	b.n	2674c <lv_draw_rect+0x50e>
                row_start += 1;
   26798:	1c5c      	adds	r4, r3, #1
   2679a:	b223      	sxth	r3, r4
                row_end -= 1;
   2679c:	3d01      	subs	r5, #1
   2679e:	e7ca      	b.n	26736 <lv_draw_rect+0x4f8>
        if(mid_bot_area.y1 != LV_CIRC_OCT4_Y(cir) + lb_origo.y) mid_bot_refr = 1;
   267a0:	f9bd 3062 	ldrsh.w	r3, [sp, #98]	; 0x62
   267a4:	f9bd 704e 	ldrsh.w	r7, [sp, #78]	; 0x4e
   267a8:	930d      	str	r3, [sp, #52]	; 0x34
   267aa:	9b09      	ldr	r3, [sp, #36]	; 0x24
        if(edge_bot_area.y1 != LV_CIRC_OCT2_Y(cir) + lb_origo.y) edge_bot_refr = 1;
   267ac:	f9bd 204c 	ldrsh.w	r2, [sp, #76]	; 0x4c
        if(edge_top_area.y1 != LV_CIRC_OCT7_Y(cir) + lt_origo.y) edge_top_refr = 1;
   267b0:	f9bd 1052 	ldrsh.w	r1, [sp, #82]	; 0x52
        if(mid_bot_area.y1 != LV_CIRC_OCT4_Y(cir) + lb_origo.y) mid_bot_refr = 1;
   267b4:	18fb      	adds	r3, r7, r3
   267b6:	930e      	str	r3, [sp, #56]	; 0x38
        if(edge_bot_area.y1 != LV_CIRC_OCT2_Y(cir) + lb_origo.y) edge_bot_refr = 1;
   267b8:	f9bd 306a 	ldrsh.w	r3, [sp, #106]	; 0x6a
   267bc:	930f      	str	r3, [sp, #60]	; 0x3c
   267be:	9b09      	ldr	r3, [sp, #36]	; 0x24
   267c0:	4413      	add	r3, r2
   267c2:	9310      	str	r3, [sp, #64]	; 0x40
        if(mid_top_area.y1 != LV_CIRC_OCT8_Y(cir) + lt_origo.y) mid_top_refr = 1;
   267c4:	f9bd 305a 	ldrsh.w	r3, [sp, #90]	; 0x5a
   267c8:	9311      	str	r3, [sp, #68]	; 0x44
   267ca:	9b08      	ldr	r3, [sp, #32]
        if(edge_top_area.y1 != LV_CIRC_OCT7_Y(cir) + lt_origo.y) edge_top_refr = 1;
   267cc:	1a9a      	subs	r2, r3, r2
   267ce:	4291      	cmp	r1, r2
        if(mid_top_area.y1 != LV_CIRC_OCT8_Y(cir) + lt_origo.y) mid_top_refr = 1;
   267d0:	eba3 0707 	sub.w	r7, r3, r7
        if(edge_top_area.y1 != LV_CIRC_OCT7_Y(cir) + lt_origo.y) edge_top_refr = 1;
   267d4:	d007      	beq.n	267e6 <lv_draw_rect+0x5a8>
            if(mcolor.full == gcolor.full)
   267d6:	42ac      	cmp	r4, r5
   267d8:	d175      	bne.n	268c6 <lv_draw_rect+0x688>
                act_color = mcolor;
   267da:	4622      	mov	r2, r4
            lv_draw_fill(&edge_top_area, mask, act_color, opa);
   267dc:	4633      	mov	r3, r6
   267de:	9905      	ldr	r1, [sp, #20]
   267e0:	980c      	ldr	r0, [sp, #48]	; 0x30
   267e2:	f7ff fab6 	bl	25d52 <lv_draw_fill>
        if(mid_top_refr != 0) {
   267e6:	9b11      	ldr	r3, [sp, #68]	; 0x44
   267e8:	42bb      	cmp	r3, r7
   267ea:	d008      	beq.n	267fe <lv_draw_rect+0x5c0>
            if(mcolor.full == gcolor.full)
   267ec:	42ac      	cmp	r4, r5
   267ee:	f040 8083 	bne.w	268f8 <lv_draw_rect+0x6ba>
                act_color = mcolor;
   267f2:	4622      	mov	r2, r4
            lv_draw_fill(&mid_top_area, mask, act_color, opa);
   267f4:	4633      	mov	r3, r6
   267f6:	9905      	ldr	r1, [sp, #20]
   267f8:	a816      	add	r0, sp, #88	; 0x58
   267fa:	f7ff faaa 	bl	25d52 <lv_draw_fill>
        if(mid_bot_refr != 0) {
   267fe:	e9dd 320d 	ldrd	r3, r2, [sp, #52]	; 0x34
   26802:	4293      	cmp	r3, r2
   26804:	d008      	beq.n	26818 <lv_draw_rect+0x5da>
            if(mcolor.full == gcolor.full)
   26806:	42ac      	cmp	r4, r5
   26808:	f040 8091 	bne.w	2692e <lv_draw_rect+0x6f0>
                act_color = mcolor;
   2680c:	4622      	mov	r2, r4
            lv_draw_fill(&mid_bot_area, mask, act_color, opa);
   2680e:	4633      	mov	r3, r6
   26810:	9905      	ldr	r1, [sp, #20]
   26812:	a818      	add	r0, sp, #96	; 0x60
   26814:	f7ff fa9d 	bl	25d52 <lv_draw_fill>
        if(edge_bot_refr != 0) {
   26818:	e9dd 320f 	ldrd	r3, r2, [sp, #60]	; 0x3c
   2681c:	4293      	cmp	r3, r2
   2681e:	d008      	beq.n	26832 <lv_draw_rect+0x5f4>
            if(mcolor.full == gcolor.full)
   26820:	42ac      	cmp	r4, r5
   26822:	f040 809f 	bne.w	26964 <lv_draw_rect+0x726>
                act_color = mcolor;
   26826:	4622      	mov	r2, r4
            lv_draw_fill(&edge_bot_area, mask, act_color, opa);
   26828:	4633      	mov	r3, r6
   2682a:	9905      	ldr	r1, [sp, #20]
   2682c:	a81a      	add	r0, sp, #104	; 0x68
   2682e:	f7ff fa90 	bl	25d52 <lv_draw_fill>
        lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
   26832:	9b09      	ldr	r3, [sp, #36]	; 0x24
   26834:	f8bd 204e 	ldrh.w	r2, [sp, #78]	; 0x4e
   26838:	f9bd 104c 	ldrsh.w	r1, [sp, #76]	; 0x4c
   2683c:	441a      	add	r2, r3
   2683e:	b212      	sxth	r2, r2
   26840:	eb0b 0301 	add.w	r3, fp, r1
   26844:	eba8 0101 	sub.w	r1, r8, r1
   26848:	9200      	str	r2, [sp, #0]
   2684a:	a818      	add	r0, sp, #96	; 0x60
   2684c:	b21b      	sxth	r3, r3
   2684e:	b209      	sxth	r1, r1
   26850:	f000 fc21 	bl	27096 <lv_area_set>
        lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
   26854:	9b09      	ldr	r3, [sp, #36]	; 0x24
   26856:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
   2685a:	f9bd 104e 	ldrsh.w	r1, [sp, #78]	; 0x4e
   2685e:	441a      	add	r2, r3
   26860:	b212      	sxth	r2, r2
   26862:	eb0b 0301 	add.w	r3, fp, r1
   26866:	eba8 0101 	sub.w	r1, r8, r1
   2686a:	9200      	str	r2, [sp, #0]
   2686c:	a81a      	add	r0, sp, #104	; 0x68
   2686e:	b21b      	sxth	r3, r3
   26870:	b209      	sxth	r1, r1
   26872:	f000 fc10 	bl	27096 <lv_area_set>
        lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
   26876:	9b08      	ldr	r3, [sp, #32]
   26878:	f8bd 204e 	ldrh.w	r2, [sp, #78]	; 0x4e
   2687c:	f9bd 104c 	ldrsh.w	r1, [sp, #76]	; 0x4c
   26880:	1a9a      	subs	r2, r3, r2
   26882:	b212      	sxth	r2, r2
   26884:	eb0b 0301 	add.w	r3, fp, r1
   26888:	eba8 0101 	sub.w	r1, r8, r1
   2688c:	9200      	str	r2, [sp, #0]
   2688e:	a816      	add	r0, sp, #88	; 0x58
   26890:	b21b      	sxth	r3, r3
   26892:	b209      	sxth	r1, r1
   26894:	f000 fbff 	bl	27096 <lv_area_set>
        lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
   26898:	9b08      	ldr	r3, [sp, #32]
   2689a:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
   2689e:	f9bd 104e 	ldrsh.w	r1, [sp, #78]	; 0x4e
   268a2:	980c      	ldr	r0, [sp, #48]	; 0x30
   268a4:	1a9a      	subs	r2, r3, r2
   268a6:	b212      	sxth	r2, r2
   268a8:	eb0b 0301 	add.w	r3, fp, r1
   268ac:	eba8 0101 	sub.w	r1, r8, r1
   268b0:	9200      	str	r2, [sp, #0]
   268b2:	b21b      	sxth	r3, r3
   268b4:	b209      	sxth	r1, r1
   268b6:	f000 fbee 	bl	27096 <lv_area_set>
        lv_circ_next(&cir, &cir_tmp);
   268ba:	f10d 014a 	add.w	r1, sp, #74	; 0x4a
   268be:	980b      	ldr	r0, [sp, #44]	; 0x2c
   268c0:	f000 fbd4 	bl	2706c <lv_circ_next>
   268c4:	e5a3      	b.n	2640e <lv_draw_rect+0x1d0>
                mix       = (uint32_t)((uint32_t)(coords->y2 - edge_top_area.y1) * 255) / height;
   268c6:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
   268ca:	1a5b      	subs	r3, r3, r1
   268cc:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
   268d0:	fbb3 f3fa 	udiv	r3, r3, sl
                act_color = lv_color_mix(mcolor, gcolor, mix);
   268d4:	b2db      	uxtb	r3, r3
   268d6:	9302      	str	r3, [sp, #8]
   268d8:	f3c5 4307 	ubfx	r3, r5, #16, #8
   268dc:	9301      	str	r3, [sp, #4]
   268de:	f3c5 2307 	ubfx	r3, r5, #8, #8
   268e2:	9300      	str	r3, [sp, #0]
   268e4:	f3c4 4207 	ubfx	r2, r4, #16, #8
   268e8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   268ea:	f3c4 2107 	ubfx	r1, r4, #8, #8
   268ee:	b2e0      	uxtb	r0, r4
   268f0:	f7ff fc80 	bl	261f4 <lv_color_mix.isra.0>
   268f4:	4602      	mov	r2, r0
   268f6:	e771      	b.n	267dc <lv_draw_rect+0x59e>
                mix       = (uint32_t)((uint32_t)(coords->y2 - mid_top_area.y1) * 255) / height;
   268f8:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
   268fc:	f9bd 205a 	ldrsh.w	r2, [sp, #90]	; 0x5a
   26900:	1a9b      	subs	r3, r3, r2
   26902:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
   26906:	fbb3 f3fa 	udiv	r3, r3, sl
                act_color = lv_color_mix(mcolor, gcolor, mix);
   2690a:	b2db      	uxtb	r3, r3
   2690c:	9302      	str	r3, [sp, #8]
   2690e:	f3c5 4307 	ubfx	r3, r5, #16, #8
   26912:	9301      	str	r3, [sp, #4]
   26914:	f3c5 2307 	ubfx	r3, r5, #8, #8
   26918:	9300      	str	r3, [sp, #0]
   2691a:	f3c4 4207 	ubfx	r2, r4, #16, #8
   2691e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   26920:	f3c4 2107 	ubfx	r1, r4, #8, #8
   26924:	b2e0      	uxtb	r0, r4
   26926:	f7ff fc65 	bl	261f4 <lv_color_mix.isra.0>
   2692a:	4602      	mov	r2, r0
   2692c:	e762      	b.n	267f4 <lv_draw_rect+0x5b6>
                mix       = (uint32_t)((uint32_t)(coords->y2 - mid_bot_area.y1) * 255) / height;
   2692e:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
   26932:	f9bd 2062 	ldrsh.w	r2, [sp, #98]	; 0x62
   26936:	1a9b      	subs	r3, r3, r2
   26938:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
   2693c:	fbb3 f3fa 	udiv	r3, r3, sl
                act_color = lv_color_mix(mcolor, gcolor, mix);
   26940:	b2db      	uxtb	r3, r3
   26942:	9302      	str	r3, [sp, #8]
   26944:	f3c5 4307 	ubfx	r3, r5, #16, #8
   26948:	9301      	str	r3, [sp, #4]
   2694a:	f3c5 2307 	ubfx	r3, r5, #8, #8
   2694e:	9300      	str	r3, [sp, #0]
   26950:	f3c4 4207 	ubfx	r2, r4, #16, #8
   26954:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   26956:	f3c4 2107 	ubfx	r1, r4, #8, #8
   2695a:	b2e0      	uxtb	r0, r4
   2695c:	f7ff fc4a 	bl	261f4 <lv_color_mix.isra.0>
   26960:	4602      	mov	r2, r0
   26962:	e754      	b.n	2680e <lv_draw_rect+0x5d0>
                mix       = (uint32_t)((uint32_t)(coords->y2 - edge_bot_area.y1) * 255) / height;
   26964:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
   26968:	f9bd 206a 	ldrsh.w	r2, [sp, #106]	; 0x6a
   2696c:	1a9b      	subs	r3, r3, r2
   2696e:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
   26972:	fbb3 f3fa 	udiv	r3, r3, sl
                act_color = lv_color_mix(mcolor, gcolor, mix);
   26976:	b2db      	uxtb	r3, r3
   26978:	9302      	str	r3, [sp, #8]
   2697a:	f3c5 4307 	ubfx	r3, r5, #16, #8
   2697e:	9301      	str	r3, [sp, #4]
   26980:	f3c5 2307 	ubfx	r3, r5, #8, #8
   26984:	9300      	str	r3, [sp, #0]
   26986:	f3c4 4207 	ubfx	r2, r4, #16, #8
   2698a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2698c:	f3c4 2107 	ubfx	r1, r4, #8, #8
   26990:	b2e0      	uxtb	r0, r4
   26992:	f7ff fc2f 	bl	261f4 <lv_color_mix.isra.0>
   26996:	4602      	mov	r2, r0
   26998:	e746      	b.n	26828 <lv_draw_rect+0x5ea>
        mix       = (uint32_t)((uint32_t)(coords->y2 - edge_top_area.y1) * 255) / height;
   2699a:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
   2699e:	f9bd 2052 	ldrsh.w	r2, [sp, #82]	; 0x52
   269a2:	1a9b      	subs	r3, r3, r2
   269a4:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
   269a8:	fbb3 f3fa 	udiv	r3, r3, sl
        act_color = lv_color_mix(mcolor, gcolor, mix);
   269ac:	b2db      	uxtb	r3, r3
   269ae:	9302      	str	r3, [sp, #8]
   269b0:	f3c5 4307 	ubfx	r3, r5, #16, #8
   269b4:	9301      	str	r3, [sp, #4]
   269b6:	f3c5 2307 	ubfx	r3, r5, #8, #8
   269ba:	9300      	str	r3, [sp, #0]
   269bc:	f3c4 4207 	ubfx	r2, r4, #16, #8
   269c0:	b2eb      	uxtb	r3, r5
   269c2:	f3c4 2107 	ubfx	r1, r4, #8, #8
   269c6:	b2e0      	uxtb	r0, r4
   269c8:	f7ff fc14 	bl	261f4 <lv_color_mix.isra.0>
   269cc:	4602      	mov	r2, r0
   269ce:	e528      	b.n	26422 <lv_draw_rect+0x1e4>
            mix       = (uint32_t)((uint32_t)(coords->y2 - mid_top_area.y1) * 255) / height;
   269d0:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
   269d4:	1a9b      	subs	r3, r3, r2
   269d6:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
   269da:	fbb3 f3fa 	udiv	r3, r3, sl
            act_color = lv_color_mix(mcolor, gcolor, mix);
   269de:	b2db      	uxtb	r3, r3
   269e0:	9302      	str	r3, [sp, #8]
   269e2:	f3c5 4307 	ubfx	r3, r5, #16, #8
   269e6:	9301      	str	r3, [sp, #4]
   269e8:	f3c5 2307 	ubfx	r3, r5, #8, #8
   269ec:	9300      	str	r3, [sp, #0]
   269ee:	f3c4 4207 	ubfx	r2, r4, #16, #8
   269f2:	b2eb      	uxtb	r3, r5
   269f4:	f3c4 2107 	ubfx	r1, r4, #8, #8
   269f8:	b2e0      	uxtb	r0, r4
   269fa:	f7ff fbfb 	bl	261f4 <lv_color_mix.isra.0>
   269fe:	4602      	mov	r2, r0
   26a00:	e51e      	b.n	26440 <lv_draw_rect+0x202>
        mix       = (uint32_t)((uint32_t)(coords->y2 - mid_bot_area.y1) * 255) / height;
   26a02:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
   26a06:	f9bd 2062 	ldrsh.w	r2, [sp, #98]	; 0x62
   26a0a:	1a9b      	subs	r3, r3, r2
   26a0c:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
   26a10:	fbb3 f3fa 	udiv	r3, r3, sl
        act_color = lv_color_mix(mcolor, gcolor, mix);
   26a14:	b2db      	uxtb	r3, r3
   26a16:	9302      	str	r3, [sp, #8]
   26a18:	f3c5 4307 	ubfx	r3, r5, #16, #8
   26a1c:	9301      	str	r3, [sp, #4]
   26a1e:	f3c5 2307 	ubfx	r3, r5, #8, #8
   26a22:	9300      	str	r3, [sp, #0]
   26a24:	f3c4 4207 	ubfx	r2, r4, #16, #8
   26a28:	b2eb      	uxtb	r3, r5
   26a2a:	f3c4 2107 	ubfx	r1, r4, #8, #8
   26a2e:	b2e0      	uxtb	r0, r4
   26a30:	f7ff fbe0 	bl	261f4 <lv_color_mix.isra.0>
   26a34:	4602      	mov	r2, r0
   26a36:	e50c      	b.n	26452 <lv_draw_rect+0x214>
            mix       = (uint32_t)((uint32_t)(coords->y2 - edge_bot_area.y1) * 255) / height;
   26a38:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
   26a3c:	1a9b      	subs	r3, r3, r2
   26a3e:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
   26a42:	fbb3 f3fa 	udiv	r3, r3, sl
            act_color = lv_color_mix(mcolor, gcolor, mix);
   26a46:	b2db      	uxtb	r3, r3
   26a48:	9302      	str	r3, [sp, #8]
   26a4a:	f3c5 4307 	ubfx	r3, r5, #16, #8
   26a4e:	9301      	str	r3, [sp, #4]
   26a50:	f3c5 2307 	ubfx	r3, r5, #8, #8
   26a54:	9300      	str	r3, [sp, #0]
   26a56:	f3c4 4207 	ubfx	r2, r4, #16, #8
   26a5a:	b2eb      	uxtb	r3, r5
   26a5c:	f3c4 2107 	ubfx	r1, r4, #8, #8
   26a60:	b2e0      	uxtb	r0, r4
   26a62:	f7ff fbc7 	bl	261f4 <lv_color_mix.isra.0>
   26a66:	4602      	mov	r2, r0
   26a68:	e502      	b.n	26470 <lv_draw_rect+0x232>
        corner_size = radius + aa;
   26a6a:	eb00 0308 	add.w	r3, r0, r8
    lv_coord_t length_corr = 0;
   26a6e:	2200      	movs	r2, #0
        corner_size = radius + aa;
   26a70:	b21b      	sxth	r3, r3
    lv_coord_t length_corr = 0;
   26a72:	9209      	str	r2, [sp, #36]	; 0x24
   26a74:	e546      	b.n	26504 <lv_draw_rect+0x2c6>
    if(part & LV_BORDER_TOP)
   26a76:	9a08      	ldr	r2, [sp, #32]
    corner_size++;
   26a78:	f103 0b01 	add.w	fp, r3, #1
   26a7c:	fa0f fb8b 	sxth.w	fp, fp
    if(part & LV_BORDER_TOP)
   26a80:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
   26a84:	2a00      	cmp	r2, #0
   26a86:	f000 814d 	beq.w	26d24 <lv_draw_rect+0xae6>
        work_area.y1 = coords->y1 + corner_size;
   26a8a:	445b      	add	r3, fp
        work_area.y1 = coords->y1 + radius;
   26a8c:	b21b      	sxth	r3, r3
   26a8e:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
    if(part & LV_BORDER_BOTTOM)
   26a92:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
   26a96:	f016 0201 	ands.w	r2, r6, #1
        work_area.y2 = coords->y2 - corner_size;
   26a9a:	bf14      	ite	ne
   26a9c:	eba3 030b 	subne.w	r3, r3, fp
        work_area.y2 = coords->y2 - radius;
   26aa0:	eba3 030a 	subeq.w	r3, r3, sl
    if(part & LV_BORDER_BOTTOM)
   26aa4:	920a      	str	r2, [sp, #40]	; 0x28
        work_area.y2 = coords->y2 - radius;
   26aa6:	b21b      	sxth	r3, r3
    if(part & LV_BORDER_LEFT) {
   26aa8:	0772      	lsls	r2, r6, #29
   26aaa:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
   26aae:	d50c      	bpl.n	26aca <lv_draw_rect+0x88c>
        work_area.x1 = coords->x1;
   26ab0:	f9b9 3000 	ldrsh.w	r3, [r9]
   26ab4:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
        work_area.x2 = work_area.x1 + bwidth;
   26ab8:	442b      	add	r3, r5
   26aba:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
        lv_draw_fill(&work_area, mask, color, opa);
   26abe:	463a      	mov	r2, r7
   26ac0:	4623      	mov	r3, r4
   26ac2:	9905      	ldr	r1, [sp, #20]
   26ac4:	a81a      	add	r0, sp, #104	; 0x68
   26ac6:	f7ff f944 	bl	25d52 <lv_draw_fill>
    if(part & LV_BORDER_RIGHT) {
   26aca:	0733      	lsls	r3, r6, #28
   26acc:	d50c      	bpl.n	26ae8 <lv_draw_rect+0x8aa>
   26ace:	f9b9 3004 	ldrsh.w	r3, [r9, #4]
        work_area.x2 = coords->x2;
   26ad2:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
        work_area.x1 = work_area.x2 - bwidth;
   26ad6:	1b5b      	subs	r3, r3, r5
   26ad8:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
        lv_draw_fill(&work_area, mask, color, opa);
   26adc:	463a      	mov	r2, r7
   26ade:	4623      	mov	r3, r4
   26ae0:	9905      	ldr	r1, [sp, #20]
   26ae2:	a81a      	add	r0, sp, #104	; 0x68
   26ae4:	f7ff f935 	bl	25d52 <lv_draw_fill>
    work_area.x1 = coords->x1 + corner_size - length_corr;
   26ae8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   26aea:	f8b9 2000 	ldrh.w	r2, [r9]
   26aee:	ebab 0303 	sub.w	r3, fp, r3
   26af2:	4413      	add	r3, r2
   26af4:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    work_area.x2 = coords->x2 - corner_size + length_corr;
   26af8:	9a09      	ldr	r2, [sp, #36]	; 0x24
   26afa:	f8b9 3004 	ldrh.w	r3, [r9, #4]
   26afe:	4413      	add	r3, r2
   26b00:	eba3 0b0b 	sub.w	fp, r3, fp
    if(part & LV_BORDER_TOP) {
   26b04:	9b08      	ldr	r3, [sp, #32]
    work_area.x2 = coords->x2 - corner_size + length_corr;
   26b06:	f8ad b06c 	strh.w	fp, [sp, #108]	; 0x6c
    if(part & LV_BORDER_TOP) {
   26b0a:	b163      	cbz	r3, 26b26 <lv_draw_rect+0x8e8>
        work_area.y1 = coords->y1;
   26b0c:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
   26b10:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
        work_area.y2 = coords->y1 + bwidth;
   26b14:	442b      	add	r3, r5
   26b16:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
        lv_draw_fill(&work_area, mask, color, opa);
   26b1a:	463a      	mov	r2, r7
   26b1c:	4623      	mov	r3, r4
   26b1e:	9905      	ldr	r1, [sp, #20]
   26b20:	a81a      	add	r0, sp, #104	; 0x68
   26b22:	f7ff f916 	bl	25d52 <lv_draw_fill>
    if(part & LV_BORDER_BOTTOM) {
   26b26:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   26b28:	b163      	cbz	r3, 26b44 <lv_draw_rect+0x906>
        work_area.y2 = coords->y2;
   26b2a:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
   26b2e:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
        work_area.y1 = work_area.y2 - bwidth;
   26b32:	1b5b      	subs	r3, r3, r5
   26b34:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
        lv_draw_fill(&work_area, mask, color, opa);
   26b38:	463a      	mov	r2, r7
   26b3a:	4623      	mov	r3, r4
   26b3c:	9905      	ldr	r1, [sp, #20]
   26b3e:	a81a      	add	r0, sp, #104	; 0x68
   26b40:	f7ff f907 	bl	25d52 <lv_draw_fill>
    if(length_corr != 0) {
   26b44:	9b09      	ldr	r3, [sp, #36]	; 0x24
   26b46:	2b00      	cmp	r3, #0
   26b48:	f000 8086 	beq.w	26c58 <lv_draw_rect+0xa1a>
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
   26b4c:	f006 0306 	and.w	r3, r6, #6
   26b50:	2b06      	cmp	r3, #6
   26b52:	d11c      	bne.n	26b8e <lv_draw_rect+0x950>
            work_area.x1 = coords->x1;
   26b54:	f9b9 3000 	ldrsh.w	r3, [r9]
   26b58:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            work_area.x2 = coords->x1 + radius + aa;
   26b5c:	fa0f f188 	sxth.w	r1, r8
   26b60:	fa0f f28a 	sxth.w	r2, sl
   26b64:	440b      	add	r3, r1
   26b66:	4413      	add	r3, r2
   26b68:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.y1 = coords->y1 + radius + 1 + aa;
   26b6c:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
            work_area.x2 = coords->x1 + radius + aa;
   26b70:	4610      	mov	r0, r2
            work_area.y1 = coords->y1 + radius + 1 + aa;
   26b72:	1c5a      	adds	r2, r3, #1
   26b74:	4411      	add	r1, r2
   26b76:	1842      	adds	r2, r0, r1
            work_area.y2 = coords->y1 + bwidth;
   26b78:	442b      	add	r3, r5
            work_area.y1 = coords->y1 + radius + 1 + aa;
   26b7a:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            work_area.y2 = coords->y1 + bwidth;
   26b7e:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
   26b82:	463a      	mov	r2, r7
   26b84:	4623      	mov	r3, r4
   26b86:	9905      	ldr	r1, [sp, #20]
   26b88:	a81a      	add	r0, sp, #104	; 0x68
   26b8a:	f7ff f8e2 	bl	25d52 <lv_draw_fill>
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
   26b8e:	f006 030a 	and.w	r3, r6, #10
   26b92:	2b0a      	cmp	r3, #10
   26b94:	d11d      	bne.n	26bd2 <lv_draw_rect+0x994>
            work_area.x1 = coords->x2 - radius - aa;
   26b96:	f9b9 c004 	ldrsh.w	ip, [r9, #4]
            work_area.x2 = coords->x2;
   26b9a:	f8ad c06c 	strh.w	ip, [sp, #108]	; 0x6c
            work_area.x1 = coords->x2 - radius - aa;
   26b9e:	fa0f f188 	sxth.w	r1, r8
   26ba2:	fa0f f28a 	sxth.w	r2, sl
   26ba6:	ebac 0301 	sub.w	r3, ip, r1
   26baa:	1a9b      	subs	r3, r3, r2
   26bac:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            work_area.y1 = coords->y1 + radius + 1 + aa;
   26bb0:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
            work_area.x1 = coords->x2 - radius - aa;
   26bb4:	4610      	mov	r0, r2
            work_area.y1 = coords->y1 + radius + 1 + aa;
   26bb6:	1c5a      	adds	r2, r3, #1
   26bb8:	4411      	add	r1, r2
   26bba:	1842      	adds	r2, r0, r1
            work_area.y2 = coords->y1 + bwidth;
   26bbc:	442b      	add	r3, r5
            work_area.y1 = coords->y1 + radius + 1 + aa;
   26bbe:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            work_area.y2 = coords->y1 + bwidth;
   26bc2:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
   26bc6:	463a      	mov	r2, r7
   26bc8:	4623      	mov	r3, r4
   26bca:	9905      	ldr	r1, [sp, #20]
   26bcc:	a81a      	add	r0, sp, #104	; 0x68
   26bce:	f7ff f8c0 	bl	25d52 <lv_draw_fill>
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
   26bd2:	f006 0305 	and.w	r3, r6, #5
   26bd6:	2b05      	cmp	r3, #5
   26bd8:	d11c      	bne.n	26c14 <lv_draw_rect+0x9d6>
            work_area.x1 = coords->x1;
   26bda:	f9b9 2000 	ldrsh.w	r2, [r9]
   26bde:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            work_area.x2 = coords->x1 + radius + aa;
   26be2:	fa0f f088 	sxth.w	r0, r8
   26be6:	fa0f f38a 	sxth.w	r3, sl
   26bea:	4402      	add	r2, r0
   26bec:	4619      	mov	r1, r3
   26bee:	441a      	add	r2, r3
            work_area.y1 = coords->y2 - bwidth;
   26bf0:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
            work_area.x2 = coords->x1 + radius + aa;
   26bf4:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
            work_area.y1 = coords->y2 - bwidth;
   26bf8:	1b5a      	subs	r2, r3, r5
            work_area.y2 = coords->y2 - radius - 1 - aa;
   26bfa:	3b01      	subs	r3, #1
   26bfc:	1a1b      	subs	r3, r3, r0
   26bfe:	1a5b      	subs	r3, r3, r1
            work_area.y1 = coords->y2 - bwidth;
   26c00:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            work_area.y2 = coords->y2 - radius - 1 - aa;
   26c04:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
   26c08:	463a      	mov	r2, r7
   26c0a:	4623      	mov	r3, r4
   26c0c:	9905      	ldr	r1, [sp, #20]
   26c0e:	a81a      	add	r0, sp, #104	; 0x68
   26c10:	f7ff f89f 	bl	25d52 <lv_draw_fill>
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
   26c14:	f006 0309 	and.w	r3, r6, #9
   26c18:	2b09      	cmp	r3, #9
   26c1a:	d11d      	bne.n	26c58 <lv_draw_rect+0xa1a>
            work_area.x1 = coords->x2 - radius - aa;
   26c1c:	f9b9 3004 	ldrsh.w	r3, [r9, #4]
            work_area.x2 = coords->x2;
   26c20:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.x1 = coords->x2 - radius - aa;
   26c24:	fa0f f188 	sxth.w	r1, r8
   26c28:	1a5a      	subs	r2, r3, r1
            work_area.y1 = coords->y2 - bwidth;
   26c2a:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
            work_area.x1 = coords->x2 - radius - aa;
   26c2e:	fa0f fa8a 	sxth.w	sl, sl
            work_area.y1 = coords->y2 - bwidth;
   26c32:	1b5d      	subs	r5, r3, r5
            work_area.y2 = coords->y2 - radius - 1 - aa;
   26c34:	3b01      	subs	r3, #1
            work_area.x1 = coords->x2 - radius - aa;
   26c36:	eba2 020a 	sub.w	r2, r2, sl
            work_area.y2 = coords->y2 - radius - 1 - aa;
   26c3a:	1a5b      	subs	r3, r3, r1
   26c3c:	eba3 0a0a 	sub.w	sl, r3, sl
            work_area.x1 = coords->x2 - radius - aa;
   26c40:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            lv_draw_fill(&work_area, mask, color, opa);
   26c44:	4623      	mov	r3, r4
   26c46:	463a      	mov	r2, r7
   26c48:	9905      	ldr	r1, [sp, #20]
            work_area.y1 = coords->y2 - bwidth;
   26c4a:	f8ad 506a 	strh.w	r5, [sp, #106]	; 0x6a
            lv_draw_fill(&work_area, mask, color, opa);
   26c4e:	a81a      	add	r0, sp, #104	; 0x68
            work_area.y2 = coords->y2 - radius - 1 - aa;
   26c50:	f8ad a06e 	strh.w	sl, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
   26c54:	f7ff f87d 	bl	25d52 <lv_draw_fill>
    if(style->body.radius == 0) {
   26c58:	9b06      	ldr	r3, [sp, #24]
   26c5a:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
   26c5e:	2b00      	cmp	r3, #0
   26c60:	f47f acce 	bne.w	26600 <lv_draw_rect+0x3c2>
        if(part & (LV_BORDER_TOP | LV_BORDER_LEFT)) {
   26c64:	f016 0f06 	tst.w	r6, #6
   26c68:	d015      	beq.n	26c96 <lv_draw_rect+0xa58>
            work_area.x1 = coords->x1;
   26c6a:	f9b9 2000 	ldrsh.w	r2, [r9]
   26c6e:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            work_area.x2 = coords->x1 + aa;
   26c72:	fa0f f388 	sxth.w	r3, r8
   26c76:	441a      	add	r2, r3
   26c78:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
            work_area.y1 = coords->y1;
   26c7c:	f9b9 2002 	ldrsh.w	r2, [r9, #2]
   26c80:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            work_area.y2 = coords->y1 + aa;
   26c84:	4413      	add	r3, r2
   26c86:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
   26c8a:	463a      	mov	r2, r7
   26c8c:	4623      	mov	r3, r4
   26c8e:	9905      	ldr	r1, [sp, #20]
   26c90:	a81a      	add	r0, sp, #104	; 0x68
   26c92:	f7ff f85e 	bl	25d52 <lv_draw_fill>
        if(part & (LV_BORDER_TOP | LV_BORDER_RIGHT)) {
   26c96:	f016 0f0a 	tst.w	r6, #10
   26c9a:	d015      	beq.n	26cc8 <lv_draw_rect+0xa8a>
            work_area.x1 = coords->x2 - aa;
   26c9c:	f9b9 2004 	ldrsh.w	r2, [r9, #4]
            work_area.x2 = coords->x2;
   26ca0:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
            work_area.x1 = coords->x2 - aa;
   26ca4:	fa0f f388 	sxth.w	r3, r8
   26ca8:	1ad1      	subs	r1, r2, r3
            work_area.y1 = coords->y1;
   26caa:	f9b9 2002 	ldrsh.w	r2, [r9, #2]
            work_area.x1 = coords->x2 - aa;
   26cae:	f8ad 1068 	strh.w	r1, [sp, #104]	; 0x68
            work_area.y2 = coords->y1 + aa;
   26cb2:	4413      	add	r3, r2
            work_area.y1 = coords->y1;
   26cb4:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            work_area.y2 = coords->y1 + aa;
   26cb8:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&work_area, mask, color, opa);
   26cbc:	463a      	mov	r2, r7
   26cbe:	4623      	mov	r3, r4
   26cc0:	9905      	ldr	r1, [sp, #20]
   26cc2:	a81a      	add	r0, sp, #104	; 0x68
   26cc4:	f7ff f845 	bl	25d52 <lv_draw_fill>
        if(part & (LV_BORDER_BOTTOM | LV_BORDER_LEFT)) {
   26cc8:	f016 0f05 	tst.w	r6, #5
   26ccc:	d015      	beq.n	26cfa <lv_draw_rect+0xabc>
            work_area.x1 = coords->x1;
   26cce:	f9b9 2000 	ldrsh.w	r2, [r9]
   26cd2:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            work_area.x2 = coords->x1 + aa;
   26cd6:	fa0f f388 	sxth.w	r3, r8
   26cda:	441a      	add	r2, r3
   26cdc:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
            work_area.y1 = coords->y2 - aa;
   26ce0:	f9b9 2006 	ldrsh.w	r2, [r9, #6]
            work_area.y2 = coords->y2;
   26ce4:	f8ad 206e 	strh.w	r2, [sp, #110]	; 0x6e
            work_area.y1 = coords->y2 - aa;
   26ce8:	1ad3      	subs	r3, r2, r3
   26cea:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            lv_draw_fill(&work_area, mask, color, opa);
   26cee:	463a      	mov	r2, r7
   26cf0:	4623      	mov	r3, r4
   26cf2:	9905      	ldr	r1, [sp, #20]
   26cf4:	a81a      	add	r0, sp, #104	; 0x68
   26cf6:	f7ff f82c 	bl	25d52 <lv_draw_fill>
        if(part & (LV_BORDER_BOTTOM | LV_BORDER_RIGHT)) {
   26cfa:	f016 0f09 	tst.w	r6, #9
   26cfe:	f43f ac7f 	beq.w	26600 <lv_draw_rect+0x3c2>
            work_area.x1 = coords->x2 - aa;
   26d02:	f9b9 3004 	ldrsh.w	r3, [r9, #4]
            work_area.x2 = coords->x2;
   26d06:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            work_area.x1 = coords->x2 - aa;
   26d0a:	fa0f f888 	sxth.w	r8, r8
   26d0e:	eba3 0208 	sub.w	r2, r3, r8
            work_area.y1 = coords->y2 - aa;
   26d12:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
            work_area.x1 = coords->x2 - aa;
   26d16:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
            work_area.y1 = coords->y2 - aa;
   26d1a:	eba3 0808 	sub.w	r8, r3, r8
   26d1e:	f8ad 806a 	strh.w	r8, [sp, #106]	; 0x6a
            work_area.y2 = coords->y2;
   26d22:	e465      	b.n	265f0 <lv_draw_rect+0x3b2>
        work_area.y1 = coords->y1 + radius;
   26d24:	4453      	add	r3, sl
   26d26:	e6b1      	b.n	26a8c <lv_draw_rect+0x84e>
        if(cir_in.y < cir_in.x) {
   26d28:	f9bd 4060 	ldrsh.w	r4, [sp, #96]	; 0x60
   26d2c:	f9bd 1062 	ldrsh.w	r1, [sp, #98]	; 0x62
   26d30:	42a1      	cmp	r1, r4
            act_w1 = cir_out.x - cir_out.y;
   26d32:	bfaa      	itet	ge
   26d34:	1ad4      	subge	r4, r2, r3
            act_w1 = cir_out.x - cir_in.x;
   26d36:	1b14      	sublt	r4, r2, r4
            act_w1 = cir_out.x - cir_out.y;
   26d38:	b224      	sxthge	r4, r4
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
   26d3a:	9906      	ldr	r1, [sp, #24]
            act_w1 = cir_out.x - cir_in.x;
   26d3c:	bfb5      	itete	lt
   26d3e:	b224      	sxthlt	r4, r4
            act_w2 = act_w1 - 1;
   26d40:	f104 3aff 	addge.w	sl, r4, #4294967295	; 0xffffffff
            act_w2 = act_w1;
   26d44:	46a2      	movlt	sl, r4
            act_w2 = act_w1 - 1;
   26d46:	fa0f fa8a 	sxthge.w	sl, sl
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
   26d4a:	2909      	cmp	r1, #9
   26d4c:	d12a      	bne.n	26da4 <lv_draw_rect+0xb66>
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT1_X(cir_out) - act_w2;
   26d4e:	444a      	add	r2, r9
   26d50:	b212      	sxth	r2, r2
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
   26d52:	4433      	add	r3, r6
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT1_X(cir_out) - act_w2;
   26d54:	eba2 010a 	sub.w	r1, r2, sl
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
   26d58:	b21b      	sxth	r3, r3
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT1_X(cir_out) - act_w2;
   26d5a:	f8ad 1068 	strh.w	r1, [sp, #104]	; 0x68
            circ_area.x2 = rb_origo.x + LV_CIRC_OCT1_X(cir_out);
   26d5e:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
   26d62:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            circ_area.y2 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
   26d66:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
   26d6a:	465a      	mov	r2, fp
   26d6c:	462b      	mov	r3, r5
   26d6e:	9905      	ldr	r1, [sp, #20]
   26d70:	a81a      	add	r0, sp, #104	; 0x68
   26d72:	f7fe ffee 	bl	25d52 <lv_draw_fill>
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
   26d76:	f8bd 305a 	ldrh.w	r3, [sp, #90]	; 0x5a
            lv_draw_fill(&circ_area, mask, color, opa);
   26d7a:	9905      	ldr	r1, [sp, #20]
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
   26d7c:	444b      	add	r3, r9
   26d7e:	b21b      	sxth	r3, r3
   26d80:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            circ_area.x2 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
   26d84:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT2_Y(cir_out) - act_w1;
   26d88:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
   26d8c:	4433      	add	r3, r6
   26d8e:	b21b      	sxth	r3, r3
   26d90:	1b1a      	subs	r2, r3, r4
   26d92:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            circ_area.y2 = rb_origo.y + LV_CIRC_OCT2_Y(cir_out);
   26d96:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
   26d9a:	465a      	mov	r2, fp
   26d9c:	462b      	mov	r3, r5
   26d9e:	a81a      	add	r0, sp, #104	; 0x68
   26da0:	f7fe ffd7 	bl	25d52 <lv_draw_fill>
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
   26da4:	9b08      	ldr	r3, [sp, #32]
   26da6:	f003 0305 	and.w	r3, r3, #5
   26daa:	2b05      	cmp	r3, #5
   26dac:	d12e      	bne.n	26e0c <lv_draw_rect+0xbce>
            circ_area.x1 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
   26dae:	f8bd 305a 	ldrh.w	r3, [sp, #90]	; 0x5a
            lv_draw_fill(&circ_area, mask, color, opa);
   26db2:	9905      	ldr	r1, [sp, #20]
            circ_area.x1 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
   26db4:	1afb      	subs	r3, r7, r3
   26db6:	b21b      	sxth	r3, r3
   26db8:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            circ_area.x2 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
   26dbc:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            circ_area.y1 = lb_origo.y + LV_CIRC_OCT3_Y(cir_out) - act_w2;
   26dc0:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
   26dc4:	4433      	add	r3, r6
   26dc6:	b21b      	sxth	r3, r3
   26dc8:	eba3 020a 	sub.w	r2, r3, sl
   26dcc:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
            circ_area.y2 = lb_origo.y + LV_CIRC_OCT3_Y(cir_out);
   26dd0:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
   26dd4:	465a      	mov	r2, fp
   26dd6:	462b      	mov	r3, r5
   26dd8:	a81a      	add	r0, sp, #104	; 0x68
   26dda:	f7fe ffba 	bl	25d52 <lv_draw_fill>
            circ_area.x1 = lb_origo.x + LV_CIRC_OCT4_X(cir_out);
   26dde:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
            lv_draw_fill(&circ_area, mask, color, opa);
   26de2:	9905      	ldr	r1, [sp, #20]
            circ_area.x1 = lb_origo.x + LV_CIRC_OCT4_X(cir_out);
   26de4:	1afb      	subs	r3, r7, r3
   26de6:	b21b      	sxth	r3, r3
   26de8:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            circ_area.x2 = lb_origo.x + LV_CIRC_OCT4_X(cir_out) + act_w1;
   26dec:	4423      	add	r3, r4
   26dee:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            circ_area.y1 = lb_origo.y + LV_CIRC_OCT4_Y(cir_out);
   26df2:	f8bd 305a 	ldrh.w	r3, [sp, #90]	; 0x5a
   26df6:	4433      	add	r3, r6
   26df8:	b21b      	sxth	r3, r3
   26dfa:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            circ_area.y2 = lb_origo.y + LV_CIRC_OCT4_Y(cir_out);
   26dfe:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
   26e02:	465a      	mov	r2, fp
   26e04:	462b      	mov	r3, r5
   26e06:	a81a      	add	r0, sp, #104	; 0x68
   26e08:	f7fe ffa3 	bl	25d52 <lv_draw_fill>
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
   26e0c:	9b08      	ldr	r3, [sp, #32]
   26e0e:	f003 0306 	and.w	r3, r3, #6
   26e12:	2b06      	cmp	r3, #6
   26e14:	d132      	bne.n	26e7c <lv_draw_rect+0xc3e>
            if(lb_origo.y + LV_CIRC_OCT4_Y(cir_out) > lt_origo.y + LV_CIRC_OCT5_Y(cir_out)) {
   26e16:	f9bd 305a 	ldrsh.w	r3, [sp, #90]	; 0x5a
   26e1a:	18f2      	adds	r2, r6, r3
   26e1c:	eba8 0303 	sub.w	r3, r8, r3
   26e20:	429a      	cmp	r2, r3
   26e22:	dd13      	ble.n	26e4c <lv_draw_rect+0xc0e>
                circ_area.x1 = lt_origo.x + LV_CIRC_OCT5_X(cir_out);
   26e24:	f8bd 2058 	ldrh.w	r2, [sp, #88]	; 0x58
                lv_draw_fill(&circ_area, mask, color, opa);
   26e28:	9905      	ldr	r1, [sp, #20]
                circ_area.x1 = lt_origo.x + LV_CIRC_OCT5_X(cir_out);
   26e2a:	1aba      	subs	r2, r7, r2
   26e2c:	b212      	sxth	r2, r2
                circ_area.y1 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
   26e2e:	b21b      	sxth	r3, r3
                circ_area.x1 = lt_origo.x + LV_CIRC_OCT5_X(cir_out);
   26e30:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
                circ_area.x2 = lt_origo.x + LV_CIRC_OCT5_X(cir_out) + act_w2;
   26e34:	4452      	add	r2, sl
   26e36:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
                circ_area.y1 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
   26e3a:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
                circ_area.y2 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
   26e3e:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
                lv_draw_fill(&circ_area, mask, color, opa);
   26e42:	465a      	mov	r2, fp
   26e44:	462b      	mov	r3, r5
   26e46:	a81a      	add	r0, sp, #104	; 0x68
   26e48:	f7fe ff83 	bl	25d52 <lv_draw_fill>
            circ_area.x1 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
   26e4c:	f8bd 305a 	ldrh.w	r3, [sp, #90]	; 0x5a
            lv_draw_fill(&circ_area, mask, color, opa);
   26e50:	9905      	ldr	r1, [sp, #20]
            circ_area.x1 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
   26e52:	1afb      	subs	r3, r7, r3
   26e54:	b21b      	sxth	r3, r3
   26e56:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            circ_area.x2 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
   26e5a:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            circ_area.y1 = lt_origo.y + LV_CIRC_OCT6_Y(cir_out);
   26e5e:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
   26e62:	eba8 0303 	sub.w	r3, r8, r3
   26e66:	b21b      	sxth	r3, r3
   26e68:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            circ_area.y2 = lt_origo.y + LV_CIRC_OCT6_Y(cir_out) + act_w1;
   26e6c:	4423      	add	r3, r4
   26e6e:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
   26e72:	465a      	mov	r2, fp
   26e74:	462b      	mov	r3, r5
   26e76:	a81a      	add	r0, sp, #104	; 0x68
   26e78:	f7fe ff6b 	bl	25d52 <lv_draw_fill>
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
   26e7c:	9b08      	ldr	r3, [sp, #32]
   26e7e:	f003 030a 	and.w	r3, r3, #10
   26e82:	2b0a      	cmp	r3, #10
   26e84:	d132      	bne.n	26eec <lv_draw_rect+0xcae>
            circ_area.x1 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
   26e86:	f8bd 305a 	ldrh.w	r3, [sp, #90]	; 0x5a
            lv_draw_fill(&circ_area, mask, color, opa);
   26e8a:	9905      	ldr	r1, [sp, #20]
            circ_area.x1 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
   26e8c:	444b      	add	r3, r9
   26e8e:	b21b      	sxth	r3, r3
   26e90:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
            circ_area.x2 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
   26e94:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
            circ_area.y1 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out);
   26e98:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
   26e9c:	eba8 0303 	sub.w	r3, r8, r3
   26ea0:	b21b      	sxth	r3, r3
   26ea2:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            circ_area.y2 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out) + act_w2;
   26ea6:	449a      	add	sl, r3
            lv_draw_fill(&circ_area, mask, color, opa);
   26ea8:	465a      	mov	r2, fp
   26eaa:	462b      	mov	r3, r5
   26eac:	a81a      	add	r0, sp, #104	; 0x68
            circ_area.y2 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out) + act_w2;
   26eae:	f8ad a06e 	strh.w	sl, [sp, #110]	; 0x6e
            lv_draw_fill(&circ_area, mask, color, opa);
   26eb2:	f7fe ff4e 	bl	25d52 <lv_draw_fill>
            if(rb_origo.y + LV_CIRC_OCT1_Y(cir_out) > rt_origo.y + LV_CIRC_OCT8_Y(cir_out)) {
   26eb6:	f9bd 305a 	ldrsh.w	r3, [sp, #90]	; 0x5a
   26eba:	18f2      	adds	r2, r6, r3
   26ebc:	eba8 0303 	sub.w	r3, r8, r3
   26ec0:	429a      	cmp	r2, r3
   26ec2:	dd13      	ble.n	26eec <lv_draw_rect+0xcae>
                circ_area.x1 = rt_origo.x + LV_CIRC_OCT8_X(cir_out) - act_w1;
   26ec4:	f8bd 2058 	ldrh.w	r2, [sp, #88]	; 0x58
                lv_draw_fill(&circ_area, mask, color, opa);
   26ec8:	9905      	ldr	r1, [sp, #20]
                circ_area.x1 = rt_origo.x + LV_CIRC_OCT8_X(cir_out) - act_w1;
   26eca:	444a      	add	r2, r9
   26ecc:	b212      	sxth	r2, r2
                circ_area.y1 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
   26ece:	b21b      	sxth	r3, r3
                circ_area.x1 = rt_origo.x + LV_CIRC_OCT8_X(cir_out) - act_w1;
   26ed0:	1b14      	subs	r4, r2, r4
                circ_area.x2 = rt_origo.x + LV_CIRC_OCT8_X(cir_out);
   26ed2:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
                circ_area.y1 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
   26ed6:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
                circ_area.y2 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
   26eda:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
                lv_draw_fill(&circ_area, mask, color, opa);
   26ede:	465a      	mov	r2, fp
   26ee0:	462b      	mov	r3, r5
   26ee2:	a81a      	add	r0, sp, #104	; 0x68
                circ_area.x1 = rt_origo.x + LV_CIRC_OCT8_X(cir_out) - act_w1;
   26ee4:	f8ad 4068 	strh.w	r4, [sp, #104]	; 0x68
                lv_draw_fill(&circ_area, mask, color, opa);
   26ee8:	f7fe ff33 	bl	25d52 <lv_draw_fill>
        lv_circ_next(&cir_out, &tmp_out);
   26eec:	a913      	add	r1, sp, #76	; 0x4c
   26eee:	a816      	add	r0, sp, #88	; 0x58
   26ef0:	f000 f8bc 	bl	2706c <lv_circ_next>
        if(cir_in.y < cir_in.x) {
   26ef4:	f9bd 2062 	ldrsh.w	r2, [sp, #98]	; 0x62
   26ef8:	f9bd 3060 	ldrsh.w	r3, [sp, #96]	; 0x60
   26efc:	429a      	cmp	r2, r3
   26efe:	f6bf abdc 	bge.w	266ba <lv_draw_rect+0x47c>
            lv_circ_next(&cir_in, &tmp_in);
   26f02:	a914      	add	r1, sp, #80	; 0x50
   26f04:	a818      	add	r0, sp, #96	; 0x60
   26f06:	f000 f8b1 	bl	2706c <lv_circ_next>
   26f0a:	f7ff bbd6 	b.w	266ba <lv_draw_rect+0x47c>

00026f0e <lv_img_color_format_is_chroma_keyed>:
    switch(cf) {
   26f0e:	2803      	cmp	r0, #3
   26f10:	d003      	beq.n	26f1a <lv_img_color_format_is_chroma_keyed+0xc>
        default: is_chroma_keyed = false; break;
   26f12:	1f83      	subs	r3, r0, #6
   26f14:	4258      	negs	r0, r3
   26f16:	4158      	adcs	r0, r3
   26f18:	4770      	bx	lr
            is_chroma_keyed = true; break;
   26f1a:	2001      	movs	r0, #1
}
   26f1c:	4770      	bx	lr

00026f1e <lv_img_color_format_has_alpha>:
    switch(cf) {
   26f1e:	280e      	cmp	r0, #14
   26f20:	d808      	bhi.n	26f34 <lv_img_color_format_has_alpha+0x16>
bool lv_img_color_format_has_alpha(lv_img_cf_t cf)
   26f22:	2301      	movs	r3, #1
   26f24:	4083      	lsls	r3, r0
   26f26:	f647 72a4 	movw	r2, #32676	; 0x7fa4
   26f2a:	4213      	tst	r3, r2
   26f2c:	bf14      	ite	ne
   26f2e:	2001      	movne	r0, #1
   26f30:	2000      	moveq	r0, #0
   26f32:	4770      	bx	lr
        default: has_alpha = false; break;
   26f34:	2000      	movs	r0, #0
}
   26f36:	4770      	bx	lr

00026f38 <lv_img_src_get_type>:
    if(src == NULL) return img_src_type;
   26f38:	b150      	cbz	r0, 26f50 <lv_img_src_get_type+0x18>
    if(u8_p[0] >= 0x20 && u8_p[0] <= 0x7F) {
   26f3a:	7803      	ldrb	r3, [r0, #0]
   26f3c:	f1a3 0220 	sub.w	r2, r3, #32
   26f40:	2a5f      	cmp	r2, #95	; 0x5f
   26f42:	d907      	bls.n	26f54 <lv_img_src_get_type+0x1c>
    } else if(u8_p[0] >= 0x80) {
   26f44:	f013 0f80 	tst.w	r3, #128	; 0x80
        img_src_type = LV_IMG_SRC_SYMBOL; /*Symbols begins after 0x7F*/
   26f48:	bf0c      	ite	eq
   26f4a:	2000      	moveq	r0, #0
   26f4c:	2002      	movne	r0, #2
   26f4e:	4770      	bx	lr
    if(src == NULL) return img_src_type;
   26f50:	2003      	movs	r0, #3
   26f52:	4770      	bx	lr
        img_src_type = LV_IMG_SRC_FILE; /*If it's an ASCII character then it's file name*/
   26f54:	2001      	movs	r0, #1
}
   26f56:	4770      	bx	lr

00026f58 <lv_img_decoder_built_in_close>:
{
   26f58:	b538      	push	{r3, r4, r5, lr}
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
   26f5a:	6a0c      	ldr	r4, [r1, #32]
{
   26f5c:	460d      	mov	r5, r1
    if(user_data) {
   26f5e:	b144      	cbz	r4, 26f72 <lv_img_decoder_built_in_close+0x1a>
        if(user_data->palette) lv_mem_free(user_data->palette);
   26f60:	6820      	ldr	r0, [r4, #0]
   26f62:	b108      	cbz	r0, 26f68 <lv_img_decoder_built_in_close+0x10>
   26f64:	f7f5 fedc 	bl	1cd20 <lv_mem_free>
        lv_mem_free(user_data);
   26f68:	4620      	mov	r0, r4
   26f6a:	f7f5 fed9 	bl	1cd20 <lv_mem_free>
        dsc->user_data = NULL;
   26f6e:	2300      	movs	r3, #0
   26f70:	622b      	str	r3, [r5, #32]
}
   26f72:	bd38      	pop	{r3, r4, r5, pc}

00026f74 <lv_img_decoder_read_line>:
{
   26f74:	b573      	push	{r0, r1, r4, r5, r6, lr}
   26f76:	4605      	mov	r5, r0
    if(dsc->decoder->read_line_cb) res = dsc->decoder->read_line_cb(dsc->decoder, dsc, x, y, len, buf);
   26f78:	6800      	ldr	r0, [r0, #0]
   26f7a:	6884      	ldr	r4, [r0, #8]
   26f7c:	b144      	cbz	r4, 26f90 <lv_img_decoder_read_line+0x1c>
   26f7e:	9e06      	ldr	r6, [sp, #24]
   26f80:	e9cd 3600 	strd	r3, r6, [sp]
   26f84:	4613      	mov	r3, r2
   26f86:	460a      	mov	r2, r1
   26f88:	4629      	mov	r1, r5
   26f8a:	47a0      	blx	r4
}
   26f8c:	b002      	add	sp, #8
   26f8e:	bd70      	pop	{r4, r5, r6, pc}
    lv_res_t res = LV_RES_INV;
   26f90:	4620      	mov	r0, r4
   26f92:	e7fb      	b.n	26f8c <lv_img_decoder_read_line+0x18>

00026f94 <lv_img_decoder_close>:
{
   26f94:	b510      	push	{r4, lr}
   26f96:	4604      	mov	r4, r0
    if(dsc->decoder) {
   26f98:	6800      	ldr	r0, [r0, #0]
   26f9a:	b158      	cbz	r0, 26fb4 <lv_img_decoder_close+0x20>
        if(dsc->decoder->close_cb) dsc->decoder->close_cb(dsc->decoder, dsc);
   26f9c:	68c3      	ldr	r3, [r0, #12]
   26f9e:	b10b      	cbz	r3, 26fa4 <lv_img_decoder_close+0x10>
   26fa0:	4621      	mov	r1, r4
   26fa2:	4798      	blx	r3
        if(dsc->src_type == LV_IMG_SRC_FILE) {
   26fa4:	7b23      	ldrb	r3, [r4, #12]
   26fa6:	2b01      	cmp	r3, #1
   26fa8:	d104      	bne.n	26fb4 <lv_img_decoder_close+0x20>
            lv_mem_free(dsc->src);
   26faa:	6860      	ldr	r0, [r4, #4]
   26fac:	f7f5 feb8 	bl	1cd20 <lv_mem_free>
            dsc->src = NULL;
   26fb0:	2300      	movs	r3, #0
   26fb2:	6063      	str	r3, [r4, #4]
}
   26fb4:	bd10      	pop	{r4, pc}

00026fb6 <lv_disp_drv_init>:
{
   26fb6:	b510      	push	{r4, lr}
__ssp_bos_icheck3(memset, void *, int)
   26fb8:	2214      	movs	r2, #20
   26fba:	4604      	mov	r4, r0
   26fbc:	2100      	movs	r1, #0
   26fbe:	3008      	adds	r0, #8
   26fc0:	f7da fe35 	bl	1c2e <memset>
    driver->flush_cb         = NULL;
   26fc4:	2300      	movs	r3, #0
    driver->hor_res          = LV_HOR_RES_MAX;
   26fc6:	f04f 12f0 	mov.w	r2, #15728880	; 0xf000f0
    driver->buffer           = NULL;
   26fca:	e9c4 2300 	strd	r2, r3, [r4]
    driver->rotated          = 0;
   26fce:	f04f 0200 	mov.w	r2, #0
   26fd2:	f363 0200 	bfi	r2, r3, #0, #1
   26fd6:	7222      	strb	r2, [r4, #8]
    driver->color_chroma_key = LV_COLOR_TRANSP;
   26fd8:	f04f 22ff 	mov.w	r2, #4278255360	; 0xff00ff00
    driver->user_data = NULL;
   26fdc:	e9c4 2307 	strd	r2, r3, [r4, #28]
}
   26fe0:	bd10      	pop	{r4, pc}

00026fe2 <lv_disp_buf_init>:
{
   26fe2:	b530      	push	{r4, r5, lr}
   26fe4:	2400      	movs	r4, #0
   26fe6:	6104      	str	r4, [r0, #16]
   26fe8:	6144      	str	r4, [r0, #20]
   26fea:	6184      	str	r4, [r0, #24]
    disp_buf->buf2    = buf2;
   26fec:	e9c0 1200 	strd	r1, r2, [r0]
    disp_buf->size    = size_in_px_cnt;
   26ff0:	e9c0 1302 	strd	r1, r3, [r0, #8]
}
   26ff4:	bd30      	pop	{r4, r5, pc}

00026ff6 <lv_disp_get_antialiasing>:
    if(disp == NULL) disp = lv_disp_get_default();
    if(disp == NULL) return false;

    return disp->driver.antialiasing ? true : false;
#endif
}
   26ff6:	2000      	movs	r0, #0
   26ff8:	4770      	bx	lr

00026ffa <lv_disp_flush_ready>:
    if(disp_drv->screen_transp) {
        memset(disp_drv->buffer->buf_act, 0x00, disp_drv->buffer->size * sizeof(lv_color32_t));
    }
#endif

    disp_drv->buffer->flushing = 0;
   26ffa:	6842      	ldr	r2, [r0, #4]
   26ffc:	7e13      	ldrb	r3, [r2, #24]
   26ffe:	f36f 0300 	bfc	r3, #0, #1
   27002:	7613      	strb	r3, [r2, #24]
}
   27004:	4770      	bx	lr

00027006 <lv_disp_get_buf>:
 * @return pointer to the internal buffers
 */
lv_disp_buf_t * lv_disp_get_buf(lv_disp_t * disp)
{
    return disp->driver.buffer;
}
   27006:	6840      	ldr	r0, [r0, #4]
   27008:	4770      	bx	lr

0002700a <lv_disp_is_double_buf>:
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_double_buf(lv_disp_t * disp)
{
    if(disp->driver.buffer->buf1 && disp->driver.buffer->buf2)
   2700a:	6843      	ldr	r3, [r0, #4]
   2700c:	6818      	ldr	r0, [r3, #0]
   2700e:	b118      	cbz	r0, 27018 <lv_disp_is_double_buf+0xe>
   27010:	6858      	ldr	r0, [r3, #4]
   27012:	3000      	adds	r0, #0
   27014:	bf18      	it	ne
   27016:	2001      	movne	r0, #1
        return true;
    else
        return false;
}
   27018:	4770      	bx	lr

0002701a <lv_disp_is_true_double_buf>:
 * `size` is screen sized)
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_true_double_buf(lv_disp_t * disp)
{
   2701a:	b508      	push	{r3, lr}
   2701c:	4602      	mov	r2, r0
    uint32_t scr_size = disp->driver.hor_res * disp->driver.ver_res;

    if(lv_disp_is_double_buf(disp) && disp->driver.buffer->size == scr_size) {
   2701e:	f7ff fff4 	bl	2700a <lv_disp_is_double_buf>
   27022:	b140      	cbz	r0, 27036 <lv_disp_is_true_double_buf+0x1c>
    uint32_t scr_size = disp->driver.hor_res * disp->driver.ver_res;
   27024:	8853      	ldrh	r3, [r2, #2]
   27026:	8810      	ldrh	r0, [r2, #0]
   27028:	fb10 f003 	smulbb	r0, r0, r3
    if(lv_disp_is_double_buf(disp) && disp->driver.buffer->size == scr_size) {
   2702c:	6853      	ldr	r3, [r2, #4]
   2702e:	68db      	ldr	r3, [r3, #12]
   27030:	1ac3      	subs	r3, r0, r3
   27032:	4258      	negs	r0, r3
   27034:	4158      	adcs	r0, r3
        return true;
    } else {
        return false;
    }
}
   27036:	bd08      	pop	{r3, pc}

00027038 <lv_tick_get>:
/**
 * Get the elapsed milliseconds since start up
 * @return the elapsed milliseconds
 */
uint32_t lv_tick_get(void)
{
   27038:	b508      	push	{r3, lr}
	return z_impl_k_uptime_get();
   2703a:	f000 ffc5 	bl	27fc8 <z_impl_k_uptime_get>

    return result;
#else
    return LV_TICK_CUSTOM_SYS_TIME_EXPR;
#endif
}
   2703e:	bd08      	pop	{r3, pc}

00027040 <lv_tick_elaps>:
 * Get the elapsed milliseconds since a previous time stamp
 * @param prev_tick a previous time stamp (return value of systick_get() )
 * @return the elapsed milliseconds since 'prev_tick'
 */
uint32_t lv_tick_elaps(uint32_t prev_tick)
{
   27040:	b510      	push	{r4, lr}
   27042:	4604      	mov	r4, r0
   27044:	f000 ffc0 	bl	27fc8 <z_impl_k_uptime_get>
        prev_tick = UINT32_MAX - prev_tick + 1;
        prev_tick += act_time;
    }

    return prev_tick;
}
   27048:	1b00      	subs	r0, r0, r4
   2704a:	bd10      	pop	{r4, pc}

0002704c <lv_circ_init>:
 * @param tmp point to a variable. It will store temporary data
 * @param radius radius of the circle
 */
void lv_circ_init(lv_point_t * c, lv_coord_t * tmp, lv_coord_t radius)
{
    c->x = radius;
   2704c:	8002      	strh	r2, [r0, #0]
    c->y = 0;
   2704e:	2300      	movs	r3, #0
    *tmp = 1 - radius;
   27050:	f1c2 0201 	rsb	r2, r2, #1
    c->y = 0;
   27054:	8043      	strh	r3, [r0, #2]
    *tmp = 1 - radius;
   27056:	800a      	strh	r2, [r1, #0]
}
   27058:	4770      	bx	lr

0002705a <lv_circ_cont>:
 * @param c same as in circ_init
 * @return true if the circle is not ready yet
 */
bool lv_circ_cont(lv_point_t * c)
{
    return c->y <= c->x ? true : false;
   2705a:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
   2705e:	f9b0 0000 	ldrsh.w	r0, [r0]
}
   27062:	4282      	cmp	r2, r0
   27064:	bfcc      	ite	gt
   27066:	2000      	movgt	r0, #0
   27068:	2001      	movle	r0, #1
   2706a:	4770      	bx	lr

0002706c <lv_circ_next>:
 * @param c same as in circ_init. The next point stored here.
 * @param tmp same as in circ_init.
 */
void lv_circ_next(lv_point_t * c, lv_coord_t * tmp)
{
    c->y++;
   2706c:	8843      	ldrh	r3, [r0, #2]
   2706e:	3301      	adds	r3, #1
   27070:	b21b      	sxth	r3, r3
   27072:	8043      	strh	r3, [r0, #2]

    if(*tmp <= 0) {
   27074:	f9b1 2000 	ldrsh.w	r2, [r1]
   27078:	2a00      	cmp	r2, #0
        (*tmp) += 2 * c->y + 1; /*Change in decision criterion for y -> y+1*/
    } else {
        c->x--;
   2707a:	bfc1      	itttt	gt
   2707c:	8802      	ldrhgt	r2, [r0, #0]
   2707e:	f102 32ff 	addgt.w	r2, r2, #4294967295	; 0xffffffff
   27082:	b212      	sxthgt	r2, r2
   27084:	8002      	strhgt	r2, [r0, #0]
        (*tmp) += 2 * (c->y - c->x) + 1; /*Change for y -> y+1, x -> x-1*/
   27086:	bfc4      	itt	gt
   27088:	1a9b      	subgt	r3, r3, r2
   2708a:	880a      	ldrhgt	r2, [r1, #0]
   2708c:	3201      	adds	r2, #1
   2708e:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   27092:	800b      	strh	r3, [r1, #0]
    }
}
   27094:	4770      	bx	lr

00027096 <lv_area_set>:
 */
void lv_area_set(lv_area_t * area_p, lv_coord_t x1, lv_coord_t y1, lv_coord_t x2, lv_coord_t y2)
{
    area_p->x1 = x1;
    area_p->y1 = y1;
    area_p->x2 = x2;
   27096:	8083      	strh	r3, [r0, #4]
    area_p->y2 = y2;
   27098:	f9bd 3000 	ldrsh.w	r3, [sp]
    area_p->x1 = x1;
   2709c:	8001      	strh	r1, [r0, #0]
    area_p->y1 = y1;
   2709e:	8042      	strh	r2, [r0, #2]
    area_p->y2 = y2;
   270a0:	80c3      	strh	r3, [r0, #6]
}
   270a2:	4770      	bx	lr

000270a4 <lv_area_set_height>:
 * @param area_p pointer to an area
 * @param h the new height of the area (h == 1 makes y1 == y2)
 */
void lv_area_set_height(lv_area_t * area_p, lv_coord_t h)
{
    area_p->y2 = area_p->y1 + h - 1;
   270a4:	8843      	ldrh	r3, [r0, #2]
   270a6:	3901      	subs	r1, #1
   270a8:	4419      	add	r1, r3
   270aa:	80c1      	strh	r1, [r0, #6]
}
   270ac:	4770      	bx	lr

000270ae <lv_area_get_size>:
 */
uint32_t lv_area_get_size(const lv_area_t * area_p)
{
    uint32_t size;

    size = (uint32_t)(area_p->x2 - area_p->x1 + 1) * (area_p->y2 - area_p->y1 + 1);
   270ae:	f9b0 3000 	ldrsh.w	r3, [r0]
   270b2:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
   270b6:	1ad2      	subs	r2, r2, r3
   270b8:	f9b0 3006 	ldrsh.w	r3, [r0, #6]
   270bc:	f9b0 0002 	ldrsh.w	r0, [r0, #2]
   270c0:	3301      	adds	r3, #1
   270c2:	1a18      	subs	r0, r3, r0

    return size;
}
   270c4:	fb02 0000 	mla	r0, r2, r0, r0
   270c8:	4770      	bx	lr

000270ca <lv_area_intersect>:
 * @return false: the two area has NO common parts, res_p is invalid
 */
bool lv_area_intersect(lv_area_t * res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
    /* Get the smaller area from 'a1_p' and 'a2_p' */
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
   270ca:	f9b1 3000 	ldrsh.w	r3, [r1]
{
   270ce:	b570      	push	{r4, r5, r6, lr}
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
   270d0:	f9b2 5000 	ldrsh.w	r5, [r2]
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
   270d4:	f9b1 4002 	ldrsh.w	r4, [r1, #2]
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
   270d8:	f9b1 6004 	ldrsh.w	r6, [r1, #4]
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
   270dc:	f9b1 1006 	ldrsh.w	r1, [r1, #6]
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
   270e0:	429d      	cmp	r5, r3
   270e2:	bfb8      	it	lt
   270e4:	461d      	movlt	r5, r3
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
   270e6:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
   270ea:	8005      	strh	r5, [r0, #0]
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
   270ec:	42a3      	cmp	r3, r4
   270ee:	bfb8      	it	lt
   270f0:	4623      	movlt	r3, r4
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
   270f2:	f9b2 4004 	ldrsh.w	r4, [r2, #4]
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
   270f6:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
   270fa:	8043      	strh	r3, [r0, #2]
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
   270fc:	42b4      	cmp	r4, r6
   270fe:	bfa8      	it	ge
   27100:	4634      	movge	r4, r6
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
   27102:	428a      	cmp	r2, r1
   27104:	bfa8      	it	ge
   27106:	460a      	movge	r2, r1

    /*If x1 or y1 greater then x2 or y2 then the areas union is empty*/
    bool union_ok = true;
    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {
   27108:	42a5      	cmp	r5, r4
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
   2710a:	8084      	strh	r4, [r0, #4]
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
   2710c:	80c2      	strh	r2, [r0, #6]
    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {
   2710e:	dc04      	bgt.n	2711a <lv_area_intersect+0x50>
   27110:	4293      	cmp	r3, r2
   27112:	bfcc      	ite	gt
   27114:	2000      	movgt	r0, #0
   27116:	2001      	movle	r0, #1
        union_ok = false;
    }

    return union_ok;
}
   27118:	bd70      	pop	{r4, r5, r6, pc}
        union_ok = false;
   2711a:	2000      	movs	r0, #0
   2711c:	e7fc      	b.n	27118 <lv_area_intersect+0x4e>

0002711e <lv_area_join>:
 * @param a1_p pointer to the first area
 * @param a2_p pointer to the second area
 */
void lv_area_join(lv_area_t * a_res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
    a_res_p->x1 = LV_MATH_MIN(a1_p->x1, a2_p->x1);
   2711e:	f9b2 3000 	ldrsh.w	r3, [r2]
{
   27122:	b510      	push	{r4, lr}
    a_res_p->x1 = LV_MATH_MIN(a1_p->x1, a2_p->x1);
   27124:	f9b1 4000 	ldrsh.w	r4, [r1]
   27128:	42a3      	cmp	r3, r4
   2712a:	bfa8      	it	ge
   2712c:	4623      	movge	r3, r4
   2712e:	8003      	strh	r3, [r0, #0]
    a_res_p->y1 = LV_MATH_MIN(a1_p->y1, a2_p->y1);
   27130:	f9b1 4002 	ldrsh.w	r4, [r1, #2]
   27134:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
   27138:	42a3      	cmp	r3, r4
   2713a:	bfa8      	it	ge
   2713c:	4623      	movge	r3, r4
   2713e:	8043      	strh	r3, [r0, #2]
    a_res_p->x2 = LV_MATH_MAX(a1_p->x2, a2_p->x2);
   27140:	f9b1 4004 	ldrsh.w	r4, [r1, #4]
   27144:	f9b2 3004 	ldrsh.w	r3, [r2, #4]
   27148:	42a3      	cmp	r3, r4
   2714a:	bfb8      	it	lt
   2714c:	4623      	movlt	r3, r4
   2714e:	8083      	strh	r3, [r0, #4]
    a_res_p->y2 = LV_MATH_MAX(a1_p->y2, a2_p->y2);
   27150:	f9b2 3006 	ldrsh.w	r3, [r2, #6]
   27154:	f9b1 2006 	ldrsh.w	r2, [r1, #6]
   27158:	4293      	cmp	r3, r2
   2715a:	bfb8      	it	lt
   2715c:	4613      	movlt	r3, r2
   2715e:	80c3      	strh	r3, [r0, #6]
}
   27160:	bd10      	pop	{r4, pc}

00027162 <lv_area_is_on>:
 * @param a2_p pointer to an other area
 * @return false: a1_p and a2_p has no common parts
 */
bool lv_area_is_on(const lv_area_t * a1_p, const lv_area_t * a2_p)
{
    if((a1_p->x1 <= a2_p->x2) && (a1_p->x2 >= a2_p->x1) && (a1_p->y1 <= a2_p->y2) && (a1_p->y2 >= a2_p->y1)) {
   27162:	f9b0 2000 	ldrsh.w	r2, [r0]
   27166:	f9b1 3004 	ldrsh.w	r3, [r1, #4]
   2716a:	429a      	cmp	r2, r3
   2716c:	dc14      	bgt.n	27198 <lv_area_is_on+0x36>
   2716e:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
   27172:	f9b1 3000 	ldrsh.w	r3, [r1]
   27176:	429a      	cmp	r2, r3
   27178:	db0e      	blt.n	27198 <lv_area_is_on+0x36>
   2717a:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
   2717e:	f9b1 3006 	ldrsh.w	r3, [r1, #6]
   27182:	429a      	cmp	r2, r3
   27184:	dc08      	bgt.n	27198 <lv_area_is_on+0x36>
   27186:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
   2718a:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
   2718e:	4298      	cmp	r0, r3
   27190:	bfb4      	ite	lt
   27192:	2000      	movlt	r0, #0
   27194:	2001      	movge	r0, #1
   27196:	4770      	bx	lr
        return true;
    } else {
        return false;
   27198:	2000      	movs	r0, #0
    }
}
   2719a:	4770      	bx	lr

0002719c <lv_area_is_in>:
 */
bool lv_area_is_in(const lv_area_t * ain_p, const lv_area_t * aholder_p)
{
    bool is_in = false;

    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
   2719c:	f9b0 2000 	ldrsh.w	r2, [r0]
   271a0:	f9b1 3000 	ldrsh.w	r3, [r1]
   271a4:	429a      	cmp	r2, r3
   271a6:	db14      	blt.n	271d2 <lv_area_is_in+0x36>
   271a8:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
   271ac:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
   271b0:	429a      	cmp	r2, r3
   271b2:	db0e      	blt.n	271d2 <lv_area_is_in+0x36>
   271b4:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
   271b8:	f9b1 3004 	ldrsh.w	r3, [r1, #4]
   271bc:	429a      	cmp	r2, r3
   271be:	dc08      	bgt.n	271d2 <lv_area_is_in+0x36>
   271c0:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
   271c4:	f9b1 3006 	ldrsh.w	r3, [r1, #6]
   271c8:	4298      	cmp	r0, r3
   271ca:	bfcc      	ite	gt
   271cc:	2000      	movgt	r0, #0
   271ce:	2001      	movle	r0, #1
   271d0:	4770      	bx	lr
    bool is_in = false;
   271d2:	2000      	movs	r0, #0
       ain_p->y2 <= aholder_p->y2) {
        is_in = true;
    }

    return is_in;
}
   271d4:	4770      	bx	lr

000271d6 <lv_task_create>:
{
   271d6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   271da:	4680      	mov	r8, r0
   271dc:	460f      	mov	r7, r1
   271de:	4616      	mov	r6, r2
   271e0:	461d      	mov	r5, r3
    lv_task_t * new_task = lv_task_create_basic();
   271e2:	f7f5 fc45 	bl	1ca70 <lv_task_create_basic>
    if(new_task == NULL) return NULL;
   271e6:	4604      	mov	r4, r0
   271e8:	b130      	cbz	r0, 271f8 <lv_task_create+0x22>
    task->task_cb = task_cb;
   271ea:	f8c0 8008 	str.w	r8, [r0, #8]
    task->period = period;
   271ee:	6007      	str	r7, [r0, #0]
    lv_task_set_prio(new_task, prio);
   271f0:	4631      	mov	r1, r6
   271f2:	f7f5 fd49 	bl	1cc88 <lv_task_set_prio>
    new_task->user_data = user_data;
   271f6:	60e5      	str	r5, [r4, #12]
}
   271f8:	4620      	mov	r0, r4
   271fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000271fe <lv_task_ready>:
{
   271fe:	b510      	push	{r4, lr}
   27200:	4604      	mov	r4, r0
    task->last_run = lv_tick_get() - task->period - 1;
   27202:	f7ff ff19 	bl	27038 <lv_tick_get>
   27206:	6823      	ldr	r3, [r4, #0]
   27208:	43db      	mvns	r3, r3
   2720a:	4403      	add	r3, r0
   2720c:	6063      	str	r3, [r4, #4]
}
   2720e:	bd10      	pop	{r4, pc}

00027210 <lv_mem_init>:
}
   27210:	4770      	bx	lr

00027212 <node_set_next.isra.0>:
 * @param act pointer to a node which next node pointer should be set
 * @param next pointer to a node which should be the next node before 'act'
 */
static void node_set_next(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * next)
{
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
   27212:	b121      	cbz	r1, 2721e <node_set_next.isra.0+0xc>

    uint32_t node_p_size = sizeof(lv_ll_node_t *);
    if(next)
   27214:	6803      	ldr	r3, [r0, #0]
   27216:	3304      	adds	r3, #4
   27218:	50ca      	str	r2, [r1, r3]
   2721a:	b102      	cbz	r2, 2721e <node_set_next.isra.0+0xc>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   2721c:	4770      	bx	lr
        memcpy(act + LL_NEXT_P_OFFSET(ll_p), &next, node_p_size);
    else
        memset(act + LL_NEXT_P_OFFSET(ll_p), 0, node_p_size);
}
   2721e:	4770      	bx	lr

00027220 <node_set_prev.isra.2>:
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
   27220:	b119      	cbz	r1, 2722a <node_set_prev.isra.2+0xa>
    if(prev)
   27222:	6803      	ldr	r3, [r0, #0]
   27224:	50ca      	str	r2, [r1, r3]
   27226:	b102      	cbz	r2, 2722a <node_set_prev.isra.2+0xa>
   27228:	4770      	bx	lr
}
   2722a:	4770      	bx	lr

0002722c <lv_ll_init>:
    ll_p->head = NULL;
   2722c:	2300      	movs	r3, #0
    ll_p->tail = NULL;
   2722e:	e9c0 3301 	strd	r3, r3, [r0, #4]
    if(node_size & 0x3) {
   27232:	078b      	lsls	r3, r1, #30
        node_size = node_size & (~0x3);
   27234:	bf1c      	itt	ne
   27236:	f021 0103 	bicne.w	r1, r1, #3
        node_size += 4;
   2723a:	3104      	addne	r1, #4
    ll_p->n_size = node_size;
   2723c:	6001      	str	r1, [r0, #0]
}
   2723e:	4770      	bx	lr

00027240 <lv_ll_ins_head>:
{
   27240:	b538      	push	{r3, r4, r5, lr}
   27242:	4604      	mov	r4, r0
    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
   27244:	6800      	ldr	r0, [r0, #0]
   27246:	3008      	adds	r0, #8
   27248:	f7f5 fd44 	bl	1ccd4 <lv_mem_alloc>
    if(n_new != NULL) {
   2724c:	4605      	mov	r5, r0
   2724e:	b180      	cbz	r0, 27272 <lv_ll_ins_head+0x32>
        node_set_prev(ll_p, n_new, NULL);       /*No prev. before the new head*/
   27250:	4601      	mov	r1, r0
   27252:	2200      	movs	r2, #0
   27254:	4620      	mov	r0, r4
   27256:	f7ff ffe3 	bl	27220 <node_set_prev.isra.2>
        node_set_next(ll_p, n_new, ll_p->head); /*After new comes the old head*/
   2725a:	6862      	ldr	r2, [r4, #4]
   2725c:	f7ff ffd9 	bl	27212 <node_set_next.isra.0>
        if(ll_p->head != NULL) { /*If there is old head then before it goes the new*/
   27260:	6861      	ldr	r1, [r4, #4]
   27262:	b111      	cbz	r1, 2726a <lv_ll_ins_head+0x2a>
            node_set_prev(ll_p, ll_p->head, n_new);
   27264:	462a      	mov	r2, r5
   27266:	f7ff ffdb 	bl	27220 <node_set_prev.isra.2>
        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/
   2726a:	68a3      	ldr	r3, [r4, #8]
        ll_p->head = n_new;      /*Set the new head in the dsc.*/
   2726c:	6065      	str	r5, [r4, #4]
        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/
   2726e:	b903      	cbnz	r3, 27272 <lv_ll_ins_head+0x32>
            ll_p->tail = n_new;
   27270:	60a5      	str	r5, [r4, #8]
}
   27272:	4628      	mov	r0, r5
   27274:	bd38      	pop	{r3, r4, r5, pc}

00027276 <lv_ll_ins_tail>:
{
   27276:	b538      	push	{r3, r4, r5, lr}
   27278:	4604      	mov	r4, r0
    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
   2727a:	6800      	ldr	r0, [r0, #0]
   2727c:	3008      	adds	r0, #8
   2727e:	f7f5 fd29 	bl	1ccd4 <lv_mem_alloc>
    if(n_new == NULL) return NULL;
   27282:	4605      	mov	r5, r0
   27284:	b180      	cbz	r0, 272a8 <lv_ll_ins_tail+0x32>
        node_set_next(ll_p, n_new, NULL);       /*No next after the new tail*/
   27286:	4601      	mov	r1, r0
   27288:	2200      	movs	r2, #0
   2728a:	4620      	mov	r0, r4
   2728c:	f7ff ffc1 	bl	27212 <node_set_next.isra.0>
        node_set_prev(ll_p, n_new, ll_p->tail); /*The prev. before new is tho old tail*/
   27290:	68a2      	ldr	r2, [r4, #8]
   27292:	f7ff ffc5 	bl	27220 <node_set_prev.isra.2>
        if(ll_p->tail != NULL) {                /*If there is old tail then the new comes after it*/
   27296:	68a1      	ldr	r1, [r4, #8]
   27298:	b111      	cbz	r1, 272a0 <lv_ll_ins_tail+0x2a>
            node_set_next(ll_p, ll_p->tail, n_new);
   2729a:	462a      	mov	r2, r5
   2729c:	f7ff ffb9 	bl	27212 <node_set_next.isra.0>
        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/
   272a0:	6863      	ldr	r3, [r4, #4]
        ll_p->tail = n_new;      /*Set the new tail in the dsc.*/
   272a2:	60a5      	str	r5, [r4, #8]
        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/
   272a4:	b903      	cbnz	r3, 272a8 <lv_ll_ins_tail+0x32>
            ll_p->head = n_new;
   272a6:	6065      	str	r5, [r4, #4]
}
   272a8:	4628      	mov	r0, r5
   272aa:	bd38      	pop	{r3, r4, r5, pc}

000272ac <lv_ll_get_head>:
    if(ll_p != NULL) {
   272ac:	b100      	cbz	r0, 272b0 <lv_ll_get_head+0x4>
        head = ll_p->head;
   272ae:	6840      	ldr	r0, [r0, #4]
}
   272b0:	4770      	bx	lr

000272b2 <lv_ll_get_tail>:
    if(ll_p != NULL) {
   272b2:	b100      	cbz	r0, 272b6 <lv_ll_get_tail+0x4>
        tail = ll_p->tail;
   272b4:	6880      	ldr	r0, [r0, #8]
}
   272b6:	4770      	bx	lr

000272b8 <lv_ll_get_next>:
    if(ll_p != NULL) {
   272b8:	b110      	cbz	r0, 272c0 <lv_ll_get_next+0x8>
        memcpy(&next, n_act_d + LL_NEXT_P_OFFSET(ll_p), sizeof(void *));
   272ba:	6803      	ldr	r3, [r0, #0]
   272bc:	4419      	add	r1, r3
   272be:	6848      	ldr	r0, [r1, #4]
}
   272c0:	4770      	bx	lr

000272c2 <lv_ll_get_prev>:
    if(ll_p != NULL) {
   272c2:	b108      	cbz	r0, 272c8 <lv_ll_get_prev+0x6>
        memcpy(&prev, n_act_d + LL_PREV_P_OFFSET(ll_p), sizeof(void *));
   272c4:	6803      	ldr	r3, [r0, #0]
   272c6:	58c8      	ldr	r0, [r1, r3]
}
   272c8:	4770      	bx	lr

000272ca <lv_ll_ins_prev>:
{
   272ca:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   272cc:	460e      	mov	r6, r1
    if(NULL == ll_p || NULL == n_act) return NULL;
   272ce:	4605      	mov	r5, r0
   272d0:	b328      	cbz	r0, 2731e <lv_ll_ins_prev+0x54>
   272d2:	b331      	cbz	r1, 27322 <lv_ll_ins_prev+0x58>
    if(lv_ll_get_head(ll_p) == n_act) {
   272d4:	6843      	ldr	r3, [r0, #4]
   272d6:	4299      	cmp	r1, r3
   272d8:	d103      	bne.n	272e2 <lv_ll_ins_prev+0x18>
}
   272da:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        n_new = lv_ll_ins_head(ll_p);
   272de:	f7ff bfaf 	b.w	27240 <lv_ll_ins_head>
        n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
   272e2:	6800      	ldr	r0, [r0, #0]
   272e4:	3008      	adds	r0, #8
   272e6:	f7f5 fcf5 	bl	1ccd4 <lv_mem_alloc>
        if(n_new == NULL) return NULL;
   272ea:	4604      	mov	r4, r0
   272ec:	b1a8      	cbz	r0, 2731a <lv_ll_ins_prev+0x50>
        n_prev = lv_ll_get_prev(ll_p, n_act);
   272ee:	4631      	mov	r1, r6
   272f0:	4628      	mov	r0, r5
   272f2:	f7ff ffe6 	bl	272c2 <lv_ll_get_prev>
        node_set_next(ll_p, n_prev, n_new);
   272f6:	4622      	mov	r2, r4
   272f8:	4601      	mov	r1, r0
        n_prev = lv_ll_get_prev(ll_p, n_act);
   272fa:	4607      	mov	r7, r0
        node_set_next(ll_p, n_prev, n_new);
   272fc:	4628      	mov	r0, r5
   272fe:	f7ff ff88 	bl	27212 <node_set_next.isra.0>
        node_set_prev(ll_p, n_new, n_prev);
   27302:	463a      	mov	r2, r7
   27304:	4621      	mov	r1, r4
   27306:	f7ff ff8b 	bl	27220 <node_set_prev.isra.2>
        node_set_prev(ll_p, n_act, n_new);
   2730a:	4622      	mov	r2, r4
   2730c:	4631      	mov	r1, r6
   2730e:	f7ff ff87 	bl	27220 <node_set_prev.isra.2>
        node_set_next(ll_p, n_new, n_act);
   27312:	4632      	mov	r2, r6
   27314:	4621      	mov	r1, r4
   27316:	f7ff ff7c 	bl	27212 <node_set_next.isra.0>
}
   2731a:	4620      	mov	r0, r4
   2731c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(NULL == ll_p || NULL == n_act) return NULL;
   2731e:	4604      	mov	r4, r0
   27320:	e7fb      	b.n	2731a <lv_ll_ins_prev+0x50>
   27322:	460c      	mov	r4, r1
   27324:	e7f9      	b.n	2731a <lv_ll_ins_prev+0x50>

00027326 <lv_ll_rem>:
{
   27326:	b570      	push	{r4, r5, r6, lr}
   27328:	460a      	mov	r2, r1
    if(ll_p != NULL) {
   2732a:	4604      	mov	r4, r0
   2732c:	b308      	cbz	r0, 27372 <lv_ll_rem+0x4c>
    if(lv_ll_get_head(ll_p) == node_p) {
   2732e:	6843      	ldr	r3, [r0, #4]
   27330:	4299      	cmp	r1, r3
   27332:	d10e      	bne.n	27352 <lv_ll_rem+0x2c>
        ll_p->head = lv_ll_get_next(ll_p, node_p);
   27334:	4611      	mov	r1, r2
   27336:	4620      	mov	r0, r4
   27338:	f7ff ffbe 	bl	272b8 <lv_ll_get_next>
   2733c:	4601      	mov	r1, r0
   2733e:	6060      	str	r0, [r4, #4]
        if(ll_p->head == NULL) {
   27340:	b908      	cbnz	r0, 27346 <lv_ll_rem+0x20>
            ll_p->tail = NULL;
   27342:	60a0      	str	r0, [r4, #8]
}
   27344:	bd70      	pop	{r4, r5, r6, pc}
            node_set_prev(ll_p, ll_p->head, NULL);
   27346:	2200      	movs	r2, #0
        node_set_prev(ll_p, n_next, n_prev);
   27348:	4620      	mov	r0, r4
}
   2734a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        node_set_prev(ll_p, n_next, n_prev);
   2734e:	f7ff bf67 	b.w	27220 <node_set_prev.isra.2>
    } else if(lv_ll_get_tail(ll_p) == node_p) {
   27352:	6883      	ldr	r3, [r0, #8]
   27354:	4299      	cmp	r1, r3
   27356:	d10e      	bne.n	27376 <lv_ll_rem+0x50>
   27358:	f7ff ffb3 	bl	272c2 <lv_ll_get_prev>
   2735c:	4601      	mov	r1, r0
        ll_p->tail = lv_ll_get_prev(ll_p, node_p);
   2735e:	60a0      	str	r0, [r4, #8]
        if(ll_p->tail == NULL) {
   27360:	b908      	cbnz	r0, 27366 <lv_ll_rem+0x40>
            ll_p->head = NULL;
   27362:	6060      	str	r0, [r4, #4]
   27364:	e7ee      	b.n	27344 <lv_ll_rem+0x1e>
            node_set_next(ll_p, ll_p->tail, NULL);
   27366:	4620      	mov	r0, r4
   27368:	2200      	movs	r2, #0
}
   2736a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            node_set_next(ll_p, ll_p->tail, NULL);
   2736e:	f7ff bf50 	b.w	27212 <node_set_next.isra.0>
    if(lv_ll_get_head(ll_p) == node_p) {
   27372:	2900      	cmp	r1, #0
   27374:	d0de      	beq.n	27334 <lv_ll_rem+0xe>
        lv_ll_node_t * n_prev = lv_ll_get_prev(ll_p, node_p);
   27376:	4611      	mov	r1, r2
   27378:	4620      	mov	r0, r4
   2737a:	f7ff ffa2 	bl	272c2 <lv_ll_get_prev>
   2737e:	4606      	mov	r6, r0
        lv_ll_node_t * n_next = lv_ll_get_next(ll_p, node_p);
   27380:	4620      	mov	r0, r4
   27382:	f7ff ff99 	bl	272b8 <lv_ll_get_next>
        node_set_next(ll_p, n_prev, n_next);
   27386:	4631      	mov	r1, r6
   27388:	4602      	mov	r2, r0
        lv_ll_node_t * n_next = lv_ll_get_next(ll_p, node_p);
   2738a:	4605      	mov	r5, r0
        node_set_next(ll_p, n_prev, n_next);
   2738c:	4620      	mov	r0, r4
   2738e:	f7ff ff40 	bl	27212 <node_set_next.isra.0>
        node_set_prev(ll_p, n_next, n_prev);
   27392:	4632      	mov	r2, r6
   27394:	4629      	mov	r1, r5
   27396:	e7d7      	b.n	27348 <lv_ll_rem+0x22>

00027398 <lv_ll_move_before>:
    if(n_act == n_after) return; /*Can't move before itself*/
   27398:	4291      	cmp	r1, r2
{
   2739a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2739c:	4604      	mov	r4, r0
   2739e:	460d      	mov	r5, r1
   273a0:	4617      	mov	r7, r2
    if(n_act == n_after) return; /*Can't move before itself*/
   273a2:	d01f      	beq.n	273e4 <lv_ll_move_before+0x4c>
    if(n_after != NULL)
   273a4:	b1fa      	cbz	r2, 273e6 <lv_ll_move_before+0x4e>
        n_before = lv_ll_get_prev(ll_p, n_after);
   273a6:	4611      	mov	r1, r2
   273a8:	f7ff ff8b 	bl	272c2 <lv_ll_get_prev>
   273ac:	4606      	mov	r6, r0
    if(n_act == n_before) return; /*Already before `n_after`*/
   273ae:	42ae      	cmp	r6, r5
   273b0:	d018      	beq.n	273e4 <lv_ll_move_before+0x4c>
    lv_ll_rem(ll_p, n_act);
   273b2:	4629      	mov	r1, r5
   273b4:	4620      	mov	r0, r4
   273b6:	f7ff ffb6 	bl	27326 <lv_ll_rem>
    node_set_next(ll_p, n_before, n_act);
   273ba:	4620      	mov	r0, r4
   273bc:	462a      	mov	r2, r5
   273be:	4631      	mov	r1, r6
   273c0:	f7ff ff27 	bl	27212 <node_set_next.isra.0>
    node_set_prev(ll_p, n_act, n_before);
   273c4:	4632      	mov	r2, r6
   273c6:	4629      	mov	r1, r5
   273c8:	f7ff ff2a 	bl	27220 <node_set_prev.isra.2>
    node_set_prev(ll_p, n_after, n_act);
   273cc:	462a      	mov	r2, r5
   273ce:	4639      	mov	r1, r7
   273d0:	f7ff ff26 	bl	27220 <node_set_prev.isra.2>
    node_set_next(ll_p, n_act, n_after);
   273d4:	463a      	mov	r2, r7
   273d6:	4629      	mov	r1, r5
   273d8:	f7ff ff1b 	bl	27212 <node_set_next.isra.0>
    if(n_after == NULL) ll_p->tail = n_act;
   273dc:	b907      	cbnz	r7, 273e0 <lv_ll_move_before+0x48>
   273de:	60a5      	str	r5, [r4, #8]
    if(n_before == NULL) ll_p->head = n_act;
   273e0:	b906      	cbnz	r6, 273e4 <lv_ll_move_before+0x4c>
   273e2:	6065      	str	r5, [r4, #4]
}
   273e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(ll_p != NULL) {
   273e6:	b108      	cbz	r0, 273ec <lv_ll_move_before+0x54>
        tail = ll_p->tail;
   273e8:	6886      	ldr	r6, [r0, #8]
   273ea:	e7e0      	b.n	273ae <lv_ll_move_before+0x16>
    void * tail = NULL;
   273ec:	4606      	mov	r6, r0
   273ee:	e7de      	b.n	273ae <lv_ll_move_before+0x16>

000273f0 <lv_txt_iso8859_1_size>:
}
   273f0:	2001      	movs	r0, #1
   273f2:	4770      	bx	lr

000273f4 <lv_txt_iso8859_1_next>:
    if(i == NULL) return txt[1]; /*Get the next char */
   273f4:	b909      	cbnz	r1, 273fa <lv_txt_iso8859_1_next+0x6>
   273f6:	7840      	ldrb	r0, [r0, #1]
   273f8:	4770      	bx	lr
    uint8_t letter = txt[*i];
   273fa:	680b      	ldr	r3, [r1, #0]
   273fc:	5cc0      	ldrb	r0, [r0, r3]
    (*i)++;
   273fe:	3301      	adds	r3, #1
   27400:	600b      	str	r3, [r1, #0]
}
   27402:	4770      	bx	lr

00027404 <lv_txt_iso8859_1_prev>:
    if(i == NULL) return *(txt - 1); /*Get the prev. char */
   27404:	b911      	cbnz	r1, 2740c <lv_txt_iso8859_1_prev+0x8>
   27406:	f810 0c01 	ldrb.w	r0, [r0, #-1]
   2740a:	4770      	bx	lr
    (*i)--;
   2740c:	680b      	ldr	r3, [r1, #0]
   2740e:	3b01      	subs	r3, #1
   27410:	600b      	str	r3, [r1, #0]
    return letter;
   27412:	5cc0      	ldrb	r0, [r0, r3]
}
   27414:	4770      	bx	lr

00027416 <lv_txt_iso8859_1_get_byte_id>:
}
   27416:	4608      	mov	r0, r1
   27418:	4770      	bx	lr

0002741a <lv_txt_iso8859_1_get_length>:
    return strlen(txt);
   2741a:	f7da bc45 	b.w	1ca8 <strlen>

0002741e <lv_txt_iso8859_1_get_char_id>:
   2741e:	4608      	mov	r0, r1
   27420:	4770      	bx	lr

00027422 <lv_txt_is_cmd>:
    if(c == (uint32_t)LV_TXT_COLOR_CMD[0]) {
   27422:	2923      	cmp	r1, #35	; 0x23
{
   27424:	4602      	mov	r2, r0
    if(c == (uint32_t)LV_TXT_COLOR_CMD[0]) {
   27426:	d117      	bne.n	27458 <lv_txt_is_cmd+0x36>
   27428:	7803      	ldrb	r3, [r0, #0]
        if(*state == LV_TXT_CMD_STATE_WAIT) { /*Start char*/
   2742a:	b91b      	cbnz	r3, 27434 <lv_txt_is_cmd+0x12>
            *state = LV_TXT_CMD_STATE_PAR;
   2742c:	2301      	movs	r3, #1
   2742e:	7003      	strb	r3, [r0, #0]
            ret    = true;
   27430:	2001      	movs	r0, #1
   27432:	e004      	b.n	2743e <lv_txt_is_cmd+0x1c>
        else if(*state == LV_TXT_CMD_STATE_PAR) {
   27434:	2b01      	cmp	r3, #1
   27436:	f04f 0000 	mov.w	r0, #0
   2743a:	d109      	bne.n	27450 <lv_txt_is_cmd+0x2e>
            *state = LV_TXT_CMD_STATE_WAIT;
   2743c:	7010      	strb	r0, [r2, #0]
    if(*state == LV_TXT_CMD_STATE_PAR) {
   2743e:	7813      	ldrb	r3, [r2, #0]
   27440:	2b01      	cmp	r3, #1
   27442:	d104      	bne.n	2744e <lv_txt_is_cmd+0x2c>
        if(c == ' ') {
   27444:	2920      	cmp	r1, #32
            *state = LV_TXT_CMD_STATE_IN; /*After the parameter the text is in the command*/
   27446:	bf04      	itt	eq
   27448:	2102      	moveq	r1, #2
   2744a:	7011      	strbeq	r1, [r2, #0]
        ret = true;
   2744c:	4618      	mov	r0, r3
}
   2744e:	4770      	bx	lr
        else if(*state == LV_TXT_CMD_STATE_IN) {
   27450:	2b02      	cmp	r3, #2
   27452:	d1f4      	bne.n	2743e <lv_txt_is_cmd+0x1c>
            *state = LV_TXT_CMD_STATE_WAIT;
   27454:	7010      	strb	r0, [r2, #0]
   27456:	e7eb      	b.n	27430 <lv_txt_is_cmd+0xe>
    bool ret = false;
   27458:	2000      	movs	r0, #0
   2745a:	e7f0      	b.n	2743e <lv_txt_is_cmd+0x1c>

0002745c <lv_txt_get_size>:
{
   2745c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   27460:	b087      	sub	sp, #28
    size_res->x = 0;
   27462:	2500      	movs	r5, #0
{
   27464:	9304      	str	r3, [sp, #16]
   27466:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
   2746a:	f9bd b040 	ldrsh.w	fp, [sp, #64]	; 0x40
   2746e:	f9bd a044 	ldrsh.w	sl, [sp, #68]	; 0x44
   27472:	9303      	str	r3, [sp, #12]
   27474:	4604      	mov	r4, r0
   27476:	4616      	mov	r6, r2
    size_res->x = 0;
   27478:	8005      	strh	r5, [r0, #0]
    size_res->y = 0;
   2747a:	8045      	strh	r5, [r0, #2]
    if(text == NULL) return;
   2747c:	4689      	mov	r9, r1
   2747e:	b1f9      	cbz	r1, 274c0 <lv_txt_get_size+0x64>
    if(font == NULL) return;
   27480:	b1f2      	cbz	r2, 274c0 <lv_txt_get_size+0x64>
    uint8_t letter_height = lv_font_get_line_height(font);
   27482:	7a17      	ldrb	r7, [r2, #8]
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
   27484:	f013 0f02 	tst.w	r3, #2
   27488:	f647 4318 	movw	r3, #31768	; 0x7c18
   2748c:	bf18      	it	ne
   2748e:	469a      	movne	sl, r3
        size_res->y += line_space;
   27490:	eb0b 0307 	add.w	r3, fp, r7
   27494:	9305      	str	r3, [sp, #20]
    while(text[line_start] != '\0') {
   27496:	f819 3005 	ldrb.w	r3, [r9, r5]
   2749a:	eb09 0805 	add.w	r8, r9, r5
   2749e:	b993      	cbnz	r3, 274c6 <lv_txt_get_size+0x6a>
    if((line_start != 0) && (text[line_start - 1] == '\n' || text[line_start - 1] == '\r')) {
   274a0:	b155      	cbz	r5, 274b8 <lv_txt_get_size+0x5c>
   274a2:	f818 3c01 	ldrb.w	r3, [r8, #-1]
   274a6:	2b0a      	cmp	r3, #10
   274a8:	d001      	beq.n	274ae <lv_txt_get_size+0x52>
   274aa:	2b0d      	cmp	r3, #13
   274ac:	d104      	bne.n	274b8 <lv_txt_get_size+0x5c>
        size_res->y += letter_height + line_space;
   274ae:	8862      	ldrh	r2, [r4, #2]
   274b0:	eb0b 0307 	add.w	r3, fp, r7
   274b4:	4413      	add	r3, r2
   274b6:	8063      	strh	r3, [r4, #2]
    if(size_res->y == 0)
   274b8:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
   274bc:	b9fb      	cbnz	r3, 274fe <lv_txt_get_size+0xa2>
        size_res->y = letter_height;
   274be:	8067      	strh	r7, [r4, #2]
}
   274c0:	b007      	add	sp, #28
   274c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        new_line_start += lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
   274c6:	9b03      	ldr	r3, [sp, #12]
   274c8:	9300      	str	r3, [sp, #0]
   274ca:	9a04      	ldr	r2, [sp, #16]
   274cc:	4653      	mov	r3, sl
   274ce:	4631      	mov	r1, r6
   274d0:	4640      	mov	r0, r8
   274d2:	f7f5 fcc5 	bl	1ce60 <lv_txt_get_next_line>
        size_res->y += line_space;
   274d6:	8863      	ldrh	r3, [r4, #2]
   274d8:	9a05      	ldr	r2, [sp, #20]
   274da:	4413      	add	r3, r2
   274dc:	8063      	strh	r3, [r4, #2]
        act_line_length = lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space, flag);
   274de:	9b03      	ldr	r3, [sp, #12]
   274e0:	9300      	str	r3, [sp, #0]
        new_line_start += lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
   274e2:	4601      	mov	r1, r0
        act_line_length = lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space, flag);
   274e4:	9b04      	ldr	r3, [sp, #16]
        new_line_start += lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
   274e6:	4405      	add	r5, r0
        act_line_length = lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space, flag);
   274e8:	4632      	mov	r2, r6
   274ea:	4640      	mov	r0, r8
   274ec:	f7f5 fc68 	bl	1cdc0 <lv_txt_get_width>
        size_res->x = LV_MATH_MAX(act_line_length, size_res->x);
   274f0:	f9b4 3000 	ldrsh.w	r3, [r4]
   274f4:	4298      	cmp	r0, r3
   274f6:	bfb8      	it	lt
   274f8:	4618      	movlt	r0, r3
   274fa:	8020      	strh	r0, [r4, #0]
        line_start  = new_line_start;
   274fc:	e7cb      	b.n	27496 <lv_txt_get_size+0x3a>
        size_res->y -= line_space;
   274fe:	eba3 030b 	sub.w	r3, r3, fp
   27502:	8063      	strh	r3, [r4, #2]
   27504:	e7dc      	b.n	274c0 <lv_txt_get_size+0x64>

00027506 <lv_utils_bsearch>:
 *
 * @return a pointer to a matching item, or NULL if none exists.
 */
void * lv_utils_bsearch(const void * key, const void * base, uint32_t n, uint32_t size,
                        int32_t (*cmp)(const void * pRef, const void * pElement))
{
   27506:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2750a:	9d08      	ldr	r5, [sp, #32]
   2750c:	4681      	mov	r9, r0
   2750e:	4688      	mov	r8, r1
   27510:	4614      	mov	r4, r2
   27512:	469a      	mov	sl, r3
    const char * middle;
    int32_t c;

    for(middle = base; n != 0;) {
   27514:	b90c      	cbnz	r4, 2751a <lv_utils_bsearch+0x14>
            middle = base;
        } else {
            return (char *)middle;
        }
    }
    return NULL;
   27516:	4626      	mov	r6, r4
   27518:	e010      	b.n	2753c <lv_utils_bsearch+0x36>
        middle += (n / 2) * size;
   2751a:	0867      	lsrs	r7, r4, #1
   2751c:	fb0a 8607 	mla	r6, sl, r7, r8
        if((c = (*cmp)(key, middle)) > 0) {
   27520:	4631      	mov	r1, r6
   27522:	4648      	mov	r0, r9
   27524:	47a8      	blx	r5
   27526:	2800      	cmp	r0, #0
   27528:	dd07      	ble.n	2753a <lv_utils_bsearch+0x34>
            n    = (n / 2) - ((n & 1) == 0);
   2752a:	43e4      	mvns	r4, r4
   2752c:	f004 0401 	and.w	r4, r4, #1
   27530:	1b3f      	subs	r7, r7, r4
            base = (middle += size);
   27532:	eb06 080a 	add.w	r8, r6, sl
{
   27536:	463c      	mov	r4, r7
   27538:	e7ec      	b.n	27514 <lv_utils_bsearch+0xe>
        } else if(c < 0) {
   2753a:	d1fc      	bne.n	27536 <lv_utils_bsearch+0x30>
}
   2753c:	4630      	mov	r0, r6
   2753e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00027542 <lv_label_dot_tmp_free>:
 * Free the dot_tmp_ptr field if it was previously allocated.
 * Always clears the field
 * @param label pointer to label object.
 */
static void lv_label_dot_tmp_free(lv_obj_t * label)
{
   27542:	b510      	push	{r4, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   27544:	f7fe fad2 	bl	25aec <lv_obj_get_ext_attr>
    if(ext->dot_tmp_alloc && ext->dot.tmp_ptr) {
   27548:	7bc3      	ldrb	r3, [r0, #15]
   2754a:	079b      	lsls	r3, r3, #30
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   2754c:	4604      	mov	r4, r0
    if(ext->dot_tmp_alloc && ext->dot.tmp_ptr) {
   2754e:	d503      	bpl.n	27558 <lv_label_dot_tmp_free+0x16>
   27550:	6840      	ldr	r0, [r0, #4]
   27552:	b108      	cbz	r0, 27558 <lv_label_dot_tmp_free+0x16>
        lv_mem_free(ext->dot.tmp_ptr);
   27554:	f7f5 fbe4 	bl	1cd20 <lv_mem_free>
    }
    ext->dot_tmp_alloc = false;
   27558:	7be3      	ldrb	r3, [r4, #15]
   2755a:	f36f 0341 	bfc	r3, #1, #1
   2755e:	73e3      	strb	r3, [r4, #15]
    ext->dot.tmp_ptr   = NULL;
   27560:	2300      	movs	r3, #0
   27562:	6063      	str	r3, [r4, #4]
}
   27564:	bd10      	pop	{r4, pc}

00027566 <lv_label_set_align>:
{
   27566:	b538      	push	{r3, r4, r5, lr}
   27568:	460c      	mov	r4, r1
   2756a:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   2756c:	f7fe fabe 	bl	25aec <lv_obj_get_ext_attr>
    if(ext->align == align) return;
   27570:	7b83      	ldrb	r3, [r0, #14]
   27572:	f3c3 1201 	ubfx	r2, r3, #4, #2
   27576:	42a2      	cmp	r2, r4
   27578:	d007      	beq.n	2758a <lv_label_set_align+0x24>
    ext->align = align;
   2757a:	f364 1305 	bfi	r3, r4, #4, #2
   2757e:	7383      	strb	r3, [r0, #14]
    lv_obj_invalidate(label); /*Enough to invalidate because alignment is only drawing related
   27580:	4628      	mov	r0, r5
}
   27582:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    lv_obj_invalidate(label); /*Enough to invalidate because alignment is only drawing related
   27586:	f7fd bff0 	b.w	2556a <lv_obj_invalidate>
}
   2758a:	bd38      	pop	{r3, r4, r5, pc}

0002758c <lv_label_set_body_draw>:
{
   2758c:	b538      	push	{r3, r4, r5, lr}
   2758e:	460d      	mov	r5, r1
   27590:	4604      	mov	r4, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   27592:	f7fe faab 	bl	25aec <lv_obj_get_ext_attr>
    if(ext->body_draw == en) return;
   27596:	7bc3      	ldrb	r3, [r0, #15]
   27598:	f003 0201 	and.w	r2, r3, #1
   2759c:	42aa      	cmp	r2, r5
   2759e:	d00a      	beq.n	275b6 <lv_label_set_body_draw+0x2a>
    ext->body_draw = en == false ? 0 : 1;
   275a0:	f365 0300 	bfi	r3, r5, #0, #1
   275a4:	73c3      	strb	r3, [r0, #15]
    lv_obj_refresh_ext_draw_pad(label);
   275a6:	4620      	mov	r0, r4
   275a8:	f7fe f873 	bl	25692 <lv_obj_refresh_ext_draw_pad>
    lv_obj_invalidate(label);
   275ac:	4620      	mov	r0, r4
}
   275ae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    lv_obj_invalidate(label);
   275b2:	f7fd bfda 	b.w	2556a <lv_obj_invalidate>
}
   275b6:	bd38      	pop	{r3, r4, r5, pc}

000275b8 <lv_label_get_text>:
{
   275b8:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   275ba:	f7fe fa97 	bl	25aec <lv_obj_get_ext_attr>
}
   275be:	6800      	ldr	r0, [r0, #0]
   275c0:	bd08      	pop	{r3, pc}

000275c2 <lv_label_get_long_mode>:
{
   275c2:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   275c4:	f7fe fa92 	bl	25aec <lv_obj_get_ext_attr>
    return ext->long_mode;
   275c8:	7b80      	ldrb	r0, [r0, #14]
}
   275ca:	f000 0007 	and.w	r0, r0, #7
   275ce:	bd08      	pop	{r3, pc}

000275d0 <lv_label_get_align>:
{
   275d0:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   275d2:	f7fe fa8b 	bl	25aec <lv_obj_get_ext_attr>
    lv_label_align_t align = ext->align;
   275d6:	7b80      	ldrb	r0, [r0, #14]
   275d8:	f3c0 1001 	ubfx	r0, r0, #4, #2
    if(align == LV_LABEL_ALIGN_AUTO) {
   275dc:	2803      	cmp	r0, #3
}
   275de:	bf08      	it	eq
   275e0:	2000      	moveq	r0, #0
   275e2:	bd08      	pop	{r3, pc}

000275e4 <lv_label_design>:
{
   275e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(mode == LV_DESIGN_COVER_CHK)
   275e8:	2a02      	cmp	r2, #2
{
   275ea:	b08f      	sub	sp, #60	; 0x3c
   275ec:	4606      	mov	r6, r0
   275ee:	4689      	mov	r9, r1
    if(mode == LV_DESIGN_COVER_CHK)
   275f0:	f000 8102 	beq.w	277f8 <lv_label_design+0x214>
    else if(mode == LV_DESIGN_DRAW_MAIN) {
   275f4:	2a00      	cmp	r2, #0
   275f6:	f040 80f8 	bne.w	277ea <lv_label_design+0x206>
        const lv_style_t * style = lv_obj_get_style(label);
   275fa:	f7f3 fc87 	bl	1af0c <lv_obj_get_style>
   275fe:	4604      	mov	r4, r0
        lv_opa_t opa_scale       = lv_obj_get_opa_scale(label);
   27600:	4630      	mov	r0, r6
   27602:	f7fe fa15 	bl	25a30 <lv_obj_get_opa_scale>
        lv_obj_get_coords(label, &coords);
   27606:	a90a      	add	r1, sp, #40	; 0x28
        lv_opa_t opa_scale       = lv_obj_get_opa_scale(label);
   27608:	4682      	mov	sl, r0
        lv_obj_get_coords(label, &coords);
   2760a:	4630      	mov	r0, r6
   2760c:	f7fe f8cc 	bl	257a8 <lv_obj_get_coords>
        lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   27610:	4630      	mov	r0, r6
   27612:	f7fe fa6b 	bl	25aec <lv_obj_get_ext_attr>
        if(ext->body_draw) {
   27616:	7bc3      	ldrb	r3, [r0, #15]
   27618:	07d9      	lsls	r1, r3, #31
        lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   2761a:	4680      	mov	r8, r0
        if(ext->body_draw) {
   2761c:	d524      	bpl.n	27668 <lv_label_design+0x84>
            lv_obj_get_coords(label, &bg);
   2761e:	a90c      	add	r1, sp, #48	; 0x30
   27620:	4630      	mov	r0, r6
   27622:	f7fe f8c1 	bl	257a8 <lv_obj_get_coords>
            bg.x1 -= style->body.padding.left;
   27626:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
   27628:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   2762c:	1a9b      	subs	r3, r3, r2
   2762e:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
            bg.x2 += style->body.padding.right;
   27632:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
   27634:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
   27638:	4413      	add	r3, r2
   2763a:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
            bg.y1 -= style->body.padding.top;
   2763e:	8c22      	ldrh	r2, [r4, #32]
   27640:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
   27644:	1a9b      	subs	r3, r3, r2
   27646:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
            bg.y2 += style->body.padding.bottom;
   2764a:	8c62      	ldrh	r2, [r4, #34]	; 0x22
   2764c:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
            lv_draw_rect(&bg, mask, style, lv_obj_get_opa_scale(label));
   27650:	4630      	mov	r0, r6
            bg.y2 += style->body.padding.bottom;
   27652:	4413      	add	r3, r2
   27654:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
            lv_draw_rect(&bg, mask, style, lv_obj_get_opa_scale(label));
   27658:	f7fe f9ea 	bl	25a30 <lv_obj_get_opa_scale>
   2765c:	4622      	mov	r2, r4
   2765e:	4603      	mov	r3, r0
   27660:	4649      	mov	r1, r9
   27662:	a80c      	add	r0, sp, #48	; 0x30
   27664:	f7fe fdeb 	bl	2623e <lv_draw_rect>
        lv_label_align_t align = lv_label_get_align(label);
   27668:	4630      	mov	r0, r6
   2766a:	f7ff ffb1 	bl	275d0 <lv_label_get_align>
        if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
   2766e:	f898 300e 	ldrb.w	r3, [r8, #14]
        if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
   27672:	061a      	lsls	r2, r3, #24
        if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
   27674:	f3c3 1580 	ubfx	r5, r3, #6, #1
        if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
   27678:	bf48      	it	mi
   2767a:	f045 0502 	orrmi.w	r5, r5, #2
        if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
   2767e:	2801      	cmp	r0, #1
   27680:	f040 80b5 	bne.w	277ee <lv_label_design+0x20a>
   27684:	f045 0504 	orr.w	r5, r5, #4
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
   27688:	f003 0207 	and.w	r2, r3, #7
   2768c:	3a03      	subs	r2, #3
   2768e:	2a01      	cmp	r2, #1
   27690:	d81d      	bhi.n	276ce <lv_label_design+0xea>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
   27692:	f003 0330 	and.w	r3, r3, #48	; 0x30
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
   27696:	2b10      	cmp	r3, #16
   27698:	d001      	beq.n	2769e <lv_label_design+0xba>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
   2769a:	2b20      	cmp	r3, #32
   2769c:	d117      	bne.n	276ce <lv_label_design+0xea>
            lv_txt_get_size(&size, ext->text, style->text.font, style->text.letter_space, style->text.line_space,
   2769e:	f647 4218 	movw	r2, #31768	; 0x7c18
   276a2:	f9b4 3038 	ldrsh.w	r3, [r4, #56]	; 0x38
   276a6:	9502      	str	r5, [sp, #8]
   276a8:	9201      	str	r2, [sp, #4]
   276aa:	f9b4 203a 	ldrsh.w	r2, [r4, #58]	; 0x3a
   276ae:	9200      	str	r2, [sp, #0]
   276b0:	6b62      	ldr	r2, [r4, #52]	; 0x34
   276b2:	f8d8 1000 	ldr.w	r1, [r8]
   276b6:	a80c      	add	r0, sp, #48	; 0x30
   276b8:	f7ff fed0 	bl	2745c <lv_txt_get_size>
            if(size.x > lv_obj_get_width(label)) {
   276bc:	4630      	mov	r0, r6
   276be:	f9bd 7030 	ldrsh.w	r7, [sp, #48]	; 0x30
   276c2:	f7fe f9a7 	bl	25a14 <lv_obj_get_width>
   276c6:	4287      	cmp	r7, r0
                flag &= ~LV_TXT_FLAG_CENTER;
   276c8:	bfc8      	it	gt
   276ca:	f005 05f3 	andgt.w	r5, r5, #243	; 0xf3
        sel.start = lv_label_get_text_sel_start(label);
   276ce:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   276d2:	9308      	str	r3, [sp, #32]
        lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ext->offset, &sel, hint, lv_obj_get_base_dir(label));
   276d4:	4643      	mov	r3, r8
   276d6:	4630      	mov	r0, r6
   276d8:	f853 2b0a 	ldr.w	r2, [r3], #10
   276dc:	e9cd 2306 	strd	r2, r3, [sp, #24]
   276e0:	f7fe f9a4 	bl	25a2c <lv_obj_get_base_dir>
   276e4:	9b07      	ldr	r3, [sp, #28]
   276e6:	9a06      	ldr	r2, [sp, #24]
   276e8:	9005      	str	r0, [sp, #20]
   276ea:	f04f 0b00 	mov.w	fp, #0
   276ee:	af08      	add	r7, sp, #32
   276f0:	e9cd 5301 	strd	r5, r3, [sp, #4]
   276f4:	9200      	str	r2, [sp, #0]
   276f6:	4653      	mov	r3, sl
   276f8:	f8cd b010 	str.w	fp, [sp, #16]
   276fc:	9703      	str	r7, [sp, #12]
   276fe:	4622      	mov	r2, r4
   27700:	4649      	mov	r1, r9
   27702:	a80a      	add	r0, sp, #40	; 0x28
   27704:	f7f4 fa1e 	bl	1bb44 <lv_draw_label>
        if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
   27708:	f898 300e 	ldrb.w	r3, [r8, #14]
   2770c:	f003 0307 	and.w	r3, r3, #7
   27710:	2b04      	cmp	r3, #4
   27712:	d16a      	bne.n	277ea <lv_label_design+0x206>
            lv_txt_get_size(&size, ext->text, style->text.font, style->text.letter_space, style->text.line_space,
   27714:	f647 4218 	movw	r2, #31768	; 0x7c18
   27718:	f9b4 3038 	ldrsh.w	r3, [r4, #56]	; 0x38
   2771c:	9502      	str	r5, [sp, #8]
   2771e:	9201      	str	r2, [sp, #4]
   27720:	f9b4 203a 	ldrsh.w	r2, [r4, #58]	; 0x3a
   27724:	9200      	str	r2, [sp, #0]
   27726:	6b62      	ldr	r2, [r4, #52]	; 0x34
   27728:	f8d8 1000 	ldr.w	r1, [r8]
   2772c:	a809      	add	r0, sp, #36	; 0x24
   2772e:	f7ff fe95 	bl	2745c <lv_txt_get_size>
            if(size.x > lv_obj_get_width(label)) {
   27732:	f9bd 3024 	ldrsh.w	r3, [sp, #36]	; 0x24
   27736:	9306      	str	r3, [sp, #24]
   27738:	4630      	mov	r0, r6
   2773a:	f7fe f96b 	bl	25a14 <lv_obj_get_width>
   2773e:	9b06      	ldr	r3, [sp, #24]
   27740:	4283      	cmp	r3, r0
   27742:	dd29      	ble.n	27798 <lv_label_design+0x1b4>
                ofs.x = ext->offset.x + size.x +
   27744:	f8bd 0024 	ldrh.w	r0, [sp, #36]	; 0x24
   27748:	f8b8 300a 	ldrh.w	r3, [r8, #10]
                        lv_font_get_glyph_width(style->text.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
   2774c:	2220      	movs	r2, #32
                ofs.x = ext->offset.x + size.x +
   2774e:	4403      	add	r3, r0
                        lv_font_get_glyph_width(style->text.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
   27750:	4611      	mov	r1, r2
                ofs.x = ext->offset.x + size.x +
   27752:	b21b      	sxth	r3, r3
                        lv_font_get_glyph_width(style->text.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
   27754:	6b60      	ldr	r0, [r4, #52]	; 0x34
                ofs.x = ext->offset.x + size.x +
   27756:	9306      	str	r3, [sp, #24]
                        lv_font_get_glyph_width(style->text.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
   27758:	f000 f8fd 	bl	27956 <lv_font_get_glyph_width>
                ofs.x = ext->offset.x + size.x +
   2775c:	9b06      	ldr	r3, [sp, #24]
   2775e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   27762:	4403      	add	r3, r0
   27764:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
                ofs.y = ext->offset.y;
   27768:	f8b8 300c 	ldrh.w	r3, [r8, #12]
   2776c:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs, &sel, NULL, lv_obj_get_base_dir(label));
   27770:	4630      	mov	r0, r6
   27772:	f8d8 3000 	ldr.w	r3, [r8]
   27776:	9306      	str	r3, [sp, #24]
   27778:	f7fe f958 	bl	25a2c <lv_obj_get_base_dir>
   2777c:	aa0c      	add	r2, sp, #48	; 0x30
   2777e:	9b06      	ldr	r3, [sp, #24]
   27780:	9300      	str	r3, [sp, #0]
   27782:	e9cd b004 	strd	fp, r0, [sp, #16]
   27786:	e9cd 5201 	strd	r5, r2, [sp, #4]
   2778a:	9703      	str	r7, [sp, #12]
   2778c:	4653      	mov	r3, sl
   2778e:	4622      	mov	r2, r4
   27790:	4649      	mov	r1, r9
   27792:	a80a      	add	r0, sp, #40	; 0x28
   27794:	f7f4 f9d6 	bl	1bb44 <lv_draw_label>
            if(size.y > lv_obj_get_height(label)) {
   27798:	4630      	mov	r0, r6
   2779a:	f9bd 7026 	ldrsh.w	r7, [sp, #38]	; 0x26
   2779e:	f7fe f93f 	bl	25a20 <lv_obj_get_height>
   277a2:	4287      	cmp	r7, r0
   277a4:	dd21      	ble.n	277ea <lv_label_design+0x206>
                ofs.x = ext->offset.x;
   277a6:	f8b8 300a 	ldrh.w	r3, [r8, #10]
   277aa:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
                ofs.y = ext->offset.y + size.y + lv_font_get_line_height(style->text.font);
   277ae:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
   277b2:	f8b8 300c 	ldrh.w	r3, [r8, #12]
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs, &sel, NULL, lv_obj_get_base_dir(label));
   277b6:	f8d8 7000 	ldr.w	r7, [r8]
                ofs.y = ext->offset.y + size.y + lv_font_get_line_height(style->text.font);
   277ba:	441a      	add	r2, r3
   277bc:	6b63      	ldr	r3, [r4, #52]	; 0x34
   277be:	7a1b      	ldrb	r3, [r3, #8]
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs, &sel, NULL, lv_obj_get_base_dir(label));
   277c0:	4630      	mov	r0, r6
                ofs.y = ext->offset.y + size.y + lv_font_get_line_height(style->text.font);
   277c2:	4413      	add	r3, r2
   277c4:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs, &sel, NULL, lv_obj_get_base_dir(label));
   277c8:	f7fe f930 	bl	25a2c <lv_obj_get_base_dir>
   277cc:	2300      	movs	r3, #0
   277ce:	9304      	str	r3, [sp, #16]
   277d0:	ab08      	add	r3, sp, #32
   277d2:	9303      	str	r3, [sp, #12]
   277d4:	ab0c      	add	r3, sp, #48	; 0x30
   277d6:	9005      	str	r0, [sp, #20]
   277d8:	e9cd 5301 	strd	r5, r3, [sp, #4]
   277dc:	9700      	str	r7, [sp, #0]
   277de:	4653      	mov	r3, sl
   277e0:	4622      	mov	r2, r4
   277e2:	4649      	mov	r1, r9
   277e4:	a80a      	add	r0, sp, #40	; 0x28
   277e6:	f7f4 f9ad 	bl	1bb44 <lv_draw_label>
    return true;
   277ea:	2001      	movs	r0, #1
   277ec:	e005      	b.n	277fa <lv_label_design+0x216>
        if(align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
   277ee:	2802      	cmp	r0, #2
   277f0:	bf08      	it	eq
   277f2:	f045 0508 	orreq.w	r5, r5, #8
   277f6:	e747      	b.n	27688 <lv_label_design+0xa4>
        return false;
   277f8:	2000      	movs	r0, #0
}
   277fa:	b00f      	add	sp, #60	; 0x3c
   277fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00027800 <lv_label_get_recolor>:
{
   27800:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   27802:	f7fe f973 	bl	25aec <lv_obj_get_ext_attr>
    return ext->recolor == 0 ? false : true;
   27806:	7b80      	ldrb	r0, [r0, #14]
}
   27808:	f3c0 1080 	ubfx	r0, r0, #6, #1
   2780c:	bd08      	pop	{r3, pc}

0002780e <lv_label_get_body_draw>:
{
   2780e:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   27810:	f7fe f96c 	bl	25aec <lv_obj_get_ext_attr>
    return ext->body_draw == 0 ? false : true;
   27814:	7bc0      	ldrb	r0, [r0, #15]
}
   27816:	f000 0001 	and.w	r0, r0, #1
   2781a:	bd08      	pop	{r3, pc}

0002781c <lv_label_set_text>:
{
   2781c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   27820:	4607      	mov	r7, r0
   27822:	460d      	mov	r5, r1
    lv_obj_invalidate(label);
   27824:	f7fd fea1 	bl	2556a <lv_obj_invalidate>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   27828:	4638      	mov	r0, r7
   2782a:	f7fe f95f 	bl	25aec <lv_obj_get_ext_attr>
   2782e:	4604      	mov	r4, r0
    if(text == NULL) {
   27830:	b925      	cbnz	r5, 2783c <lv_label_set_text+0x20>
        lv_label_refr_text(label);
   27832:	4638      	mov	r0, r7
}
   27834:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        lv_label_refr_text(label);
   27838:	f7f5 bd7a 	b.w	1d330 <lv_label_refr_text>
    if(ext->text == text) {
   2783c:	6806      	ldr	r6, [r0, #0]
   2783e:	42ae      	cmp	r6, r5
   27840:	d10b      	bne.n	2785a <lv_label_set_text+0x3e>
        ext->text = lv_mem_realloc(ext->text, strlen(ext->text) + 1);
   27842:	4630      	mov	r0, r6
   27844:	f7da fa30 	bl	1ca8 <strlen>
   27848:	1c41      	adds	r1, r0, #1
   2784a:	4630      	mov	r0, r6
   2784c:	f7f5 fa86 	bl	1cd5c <lv_mem_realloc>
   27850:	6020      	str	r0, [r4, #0]
        if(ext->text == NULL) return;
   27852:	2800      	cmp	r0, #0
   27854:	d1ed      	bne.n	27832 <lv_label_set_text+0x16>
}
   27856:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        size_t len = strlen(text) + 1;
   2785a:	4628      	mov	r0, r5
   2785c:	f7da fa24 	bl	1ca8 <strlen>
   27860:	f100 0801 	add.w	r8, r0, #1
        if(ext->text != NULL && ext->static_txt == 0) {
   27864:	6820      	ldr	r0, [r4, #0]
   27866:	b130      	cbz	r0, 27876 <lv_label_set_text+0x5a>
   27868:	7ba3      	ldrb	r3, [r4, #14]
   2786a:	f013 0608 	ands.w	r6, r3, #8
   2786e:	d102      	bne.n	27876 <lv_label_set_text+0x5a>
            lv_mem_free(ext->text);
   27870:	f7f5 fa56 	bl	1cd20 <lv_mem_free>
            ext->text = NULL;
   27874:	6026      	str	r6, [r4, #0]
        ext->text = lv_mem_alloc(len);
   27876:	4640      	mov	r0, r8
   27878:	f7f5 fa2c 	bl	1ccd4 <lv_mem_alloc>
   2787c:	6020      	str	r0, [r4, #0]
        if(ext->text == NULL) return;
   2787e:	2800      	cmp	r0, #0
   27880:	d0e9      	beq.n	27856 <lv_label_set_text+0x3a>
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
   27882:	4629      	mov	r1, r5
   27884:	f7da fa08 	bl	1c98 <strcpy>
        ext->static_txt = 0;
   27888:	7ba3      	ldrb	r3, [r4, #14]
   2788a:	f36f 03c3 	bfc	r3, #3, #1
   2788e:	73a3      	strb	r3, [r4, #14]
   27890:	e7cf      	b.n	27832 <lv_label_set_text+0x16>

00027892 <lv_label_set_static_text>:
{
   27892:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   27894:	4607      	mov	r7, r0
   27896:	460e      	mov	r6, r1
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   27898:	f7fe f928 	bl	25aec <lv_obj_get_ext_attr>
    if(ext->static_txt == 0 && ext->text != NULL) {
   2789c:	7b83      	ldrb	r3, [r0, #14]
   2789e:	f013 0508 	ands.w	r5, r3, #8
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   278a2:	4604      	mov	r4, r0
    if(ext->static_txt == 0 && ext->text != NULL) {
   278a4:	d104      	bne.n	278b0 <lv_label_set_static_text+0x1e>
   278a6:	6800      	ldr	r0, [r0, #0]
   278a8:	b110      	cbz	r0, 278b0 <lv_label_set_static_text+0x1e>
        lv_mem_free(ext->text);
   278aa:	f7f5 fa39 	bl	1cd20 <lv_mem_free>
        ext->text = NULL;
   278ae:	6025      	str	r5, [r4, #0]
    if(text != NULL) {
   278b0:	b126      	cbz	r6, 278bc <lv_label_set_static_text+0x2a>
        ext->static_txt = 1;
   278b2:	7ba3      	ldrb	r3, [r4, #14]
        ext->text       = (char *)text;
   278b4:	6026      	str	r6, [r4, #0]
        ext->static_txt = 1;
   278b6:	f043 0308 	orr.w	r3, r3, #8
   278ba:	73a3      	strb	r3, [r4, #14]
    lv_label_refr_text(label);
   278bc:	4638      	mov	r0, r7
}
   278be:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    lv_label_refr_text(label);
   278c2:	f7f5 bd35 	b.w	1d330 <lv_label_refr_text>

000278c6 <lv_label_set_long_mode>:
{
   278c6:	b570      	push	{r4, r5, r6, lr}
   278c8:	460e      	mov	r6, r1
   278ca:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   278cc:	f7fe f90e 	bl	25aec <lv_obj_get_ext_attr>
    if(long_mode == LV_LABEL_LONG_SROLL || long_mode == LV_LABEL_LONG_SROLL_CIRC || long_mode == LV_LABEL_LONG_CROP)
   278d0:	1ef2      	subs	r2, r6, #3
    ext->offset.x = 0;
   278d2:	2300      	movs	r3, #0
    if(long_mode == LV_LABEL_LONG_SROLL || long_mode == LV_LABEL_LONG_SROLL_CIRC || long_mode == LV_LABEL_LONG_CROP)
   278d4:	2a02      	cmp	r2, #2
    ext->offset.x = 0;
   278d6:	8143      	strh	r3, [r0, #10]
    ext->offset.y = 0;
   278d8:	8183      	strh	r3, [r0, #12]
   278da:	7b83      	ldrb	r3, [r0, #14]
    if(long_mode == LV_LABEL_LONG_SROLL || long_mode == LV_LABEL_LONG_SROLL_CIRC || long_mode == LV_LABEL_LONG_CROP)
   278dc:	bf8c      	ite	hi
   278de:	2200      	movhi	r2, #0
   278e0:	2201      	movls	r2, #1
   278e2:	f362 13c7 	bfi	r3, r2, #7, #1
   278e6:	7383      	strb	r3, [r0, #14]
    if(ext->long_mode == LV_LABEL_LONG_DOT && ext->dot_end != LV_LABEL_DOT_END_INV) {
   278e8:	f003 0307 	and.w	r3, r3, #7
   278ec:	2b02      	cmp	r3, #2
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   278ee:	4604      	mov	r4, r0
    if(ext->long_mode == LV_LABEL_LONG_DOT && ext->dot_end != LV_LABEL_DOT_END_INV) {
   278f0:	d107      	bne.n	27902 <lv_label_set_long_mode+0x3c>
   278f2:	8902      	ldrh	r2, [r0, #8]
   278f4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   278f8:	429a      	cmp	r2, r3
   278fa:	d002      	beq.n	27902 <lv_label_set_long_mode+0x3c>
        lv_label_revert_dots(label);
   278fc:	4628      	mov	r0, r5
   278fe:	f7f5 fbbb 	bl	1d078 <lv_label_revert_dots>
    ext->long_mode = long_mode;
   27902:	7ba3      	ldrb	r3, [r4, #14]
   27904:	f366 0302 	bfi	r3, r6, #0, #3
   27908:	73a3      	strb	r3, [r4, #14]
    lv_label_refr_text(label);
   2790a:	4628      	mov	r0, r5
}
   2790c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    lv_label_refr_text(label);
   27910:	f7f5 bd0e 	b.w	1d330 <lv_label_refr_text>

00027914 <lv_label_set_recolor>:
{
   27914:	b538      	push	{r3, r4, r5, lr}
   27916:	460c      	mov	r4, r1
   27918:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   2791a:	f7fe f8e7 	bl	25aec <lv_obj_get_ext_attr>
    if(ext->recolor == en) return;
   2791e:	7b83      	ldrb	r3, [r0, #14]
   27920:	f3c3 1280 	ubfx	r2, r3, #6, #1
   27924:	42a2      	cmp	r2, r4
   27926:	d007      	beq.n	27938 <lv_label_set_recolor+0x24>
    ext->recolor = en == false ? 0 : 1;
   27928:	f364 1386 	bfi	r3, r4, #6, #1
   2792c:	7383      	strb	r3, [r0, #14]
    lv_label_refr_text(label); /*Refresh the text because the potential colo codes in text needs to
   2792e:	4628      	mov	r0, r5
}
   27930:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    lv_label_refr_text(label); /*Refresh the text because the potential colo codes in text needs to
   27934:	f7f5 bcfc 	b.w	1d330 <lv_label_refr_text>
}
   27938:	bd38      	pop	{r3, r4, r5, pc}

0002793a <lv_img_get_auto_size>:
{
   2793a:	b508      	push	{r3, lr}
    lv_img_ext_t * ext = lv_obj_get_ext_attr(img);
   2793c:	f7fe f8d6 	bl	25aec <lv_obj_get_ext_attr>
    return ext->auto_size == 0 ? false : true;
   27940:	7b00      	ldrb	r0, [r0, #12]
}
   27942:	f3c0 0080 	ubfx	r0, r0, #2, #1
   27946:	bd08      	pop	{r3, pc}

00027948 <lv_font_get_glyph_bitmap>:
 * @param letter an UNICODE character code
 * @return  pointer to the bitmap of the letter
 */
const uint8_t * lv_font_get_glyph_bitmap(const lv_font_t * font_p, uint32_t letter)
{
    return font_p->get_glyph_bitmap(font_p, letter);
   27948:	6843      	ldr	r3, [r0, #4]
   2794a:	4718      	bx	r3

0002794c <lv_font_get_glyph_dsc>:
 * @param letter an UNICODE letter code
 * @return true: descriptor is successfully loaded into `dsc_out`.
 *         false: the letter was not found, no data is loaded to `dsc_out`
 */
bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_out, uint32_t letter, uint32_t letter_next)
{
   2794c:	b410      	push	{r4}
    return font_p->get_glyph_dsc(font_p, dsc_out, letter, letter_next);
   2794e:	6804      	ldr	r4, [r0, #0]
   27950:	46a4      	mov	ip, r4
}
   27952:	bc10      	pop	{r4}
    return font_p->get_glyph_dsc(font_p, dsc_out, letter, letter_next);
   27954:	4760      	bx	ip

00027956 <lv_font_get_glyph_width>:
 * @param letter an UNICODE letter
 * @param letter_next the next letter after `letter`. Used for kerning
 * @return the width of the glyph
 */
uint16_t lv_font_get_glyph_width(const lv_font_t * font, uint32_t letter, uint32_t letter_next)
{
   27956:	b507      	push	{r0, r1, r2, lr}
    lv_font_glyph_dsc_t g;
    bool ret;
    ret = lv_font_get_glyph_dsc(font, &g, letter, letter_next);
   27958:	4613      	mov	r3, r2
   2795a:	460a      	mov	r2, r1
   2795c:	4669      	mov	r1, sp
   2795e:	f7ff fff5 	bl	2794c <lv_font_get_glyph_dsc>
    if(ret) return g.adv_w;
   27962:	b108      	cbz	r0, 27968 <lv_font_get_glyph_width+0x12>
   27964:	f8bd 0000 	ldrh.w	r0, [sp]
    else return 0;
}
   27968:	b003      	add	sp, #12
   2796a:	f85d fb04 	ldr.w	pc, [sp], #4

0002796e <kern_pair_8_compare>:
    if(ref8_p[0] != element8_p[0]) return (int32_t)ref8_p[0] - element8_p[0];
   2796e:	7803      	ldrb	r3, [r0, #0]
   27970:	780a      	ldrb	r2, [r1, #0]
   27972:	4293      	cmp	r3, r2
   27974:	bf11      	iteee	ne
   27976:	1a98      	subne	r0, r3, r2
    else return (int32_t) ref8_p[1] - element8_p[1];
   27978:	784b      	ldrbeq	r3, [r1, #1]
   2797a:	7840      	ldrbeq	r0, [r0, #1]
   2797c:	1ac0      	subeq	r0, r0, r3
}
   2797e:	4770      	bx	lr

00027980 <kern_pair_16_compare>:
    if(ref16_p[0] != element16_p[0]) return (int32_t)ref16_p[0] - element16_p[0];
   27980:	8803      	ldrh	r3, [r0, #0]
   27982:	880a      	ldrh	r2, [r1, #0]
   27984:	4293      	cmp	r3, r2
   27986:	bf11      	iteee	ne
   27988:	1a98      	subne	r0, r3, r2
    else return (int32_t) ref16_p[1] - element16_p[1];
   2798a:	884b      	ldrheq	r3, [r1, #2]
   2798c:	8840      	ldrheq	r0, [r0, #2]
   2798e:	1ac0      	subeq	r0, r0, r3
}
   27990:	4770      	bx	lr

00027992 <get_bits>:
{
   27992:	b510      	push	{r4, lr}
    uint32_t byte_pos = bit_pos >> 3;
   27994:	08cb      	lsrs	r3, r1, #3
    bit_pos = bit_pos & 0x7;
   27996:	f001 0107 	and.w	r1, r1, #7
    uint16_t in16 = (in[byte_pos] << 8) + in[byte_pos + 1];
   2799a:	5cc4      	ldrb	r4, [r0, r3]
   2799c:	4418      	add	r0, r3
    uint8_t bit_mask = (uint16_t)((uint16_t) 1 << len) - 1;
   2799e:	2301      	movs	r3, #1
    uint16_t in16 = (in[byte_pos] << 8) + in[byte_pos + 1];
   279a0:	7840      	ldrb	r0, [r0, #1]
   279a2:	eb00 2004 	add.w	r0, r0, r4, lsl #8
    res = (in16 >> (16 - bit_pos - len)) & bit_mask;
   279a6:	f1c2 0410 	rsb	r4, r2, #16
   279aa:	1a61      	subs	r1, r4, r1
    uint8_t bit_mask = (uint16_t)((uint16_t) 1 << len) - 1;
   279ac:	4093      	lsls	r3, r2
    res = (in16 >> (16 - bit_pos - len)) & bit_mask;
   279ae:	b280      	uxth	r0, r0
   279b0:	4108      	asrs	r0, r1
    uint8_t bit_mask = (uint16_t)((uint16_t) 1 << len) - 1;
   279b2:	3b01      	subs	r3, #1
    res = (in16 >> (16 - bit_pos - len)) & bit_mask;
   279b4:	4018      	ands	r0, r3
}
   279b6:	b2c0      	uxtb	r0, r0
   279b8:	bd10      	pop	{r4, pc}

000279ba <unicode_list_compare>:
 *  @retval > 0   Reference is less than element.
 *
 */
static int32_t unicode_list_compare(const void * ref, const void * element)
{
    return (*(uint16_t *)ref) - (*(uint16_t *)element);
   279ba:	8800      	ldrh	r0, [r0, #0]
   279bc:	880b      	ldrh	r3, [r1, #0]
}
   279be:	1ac0      	subs	r0, r0, r3
   279c0:	4770      	bx	lr

000279c2 <arch_system_halt>:
	__asm__ volatile(
   279c2:	f04f 0220 	mov.w	r2, #32
   279c6:	f3ef 8311 	mrs	r3, BASEPRI
   279ca:	f382 8811 	msr	BASEPRI, r2
   279ce:	f3bf 8f6f 	isb	sy
	}
   279d2:	e7fe      	b.n	279d2 <arch_system_halt+0x10>

000279d4 <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
   279d4:	f7fa ba56 	b.w	21e84 <z_clock_idle_exit>

000279d8 <k_mem_slab_init>:
{
   279d8:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
   279da:	2400      	movs	r4, #0
	slab->block_size = block_size;
   279dc:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->free_list = NULL;
   279e0:	e9c0 4405 	strd	r4, r4, [r0, #20]
	slab->buffer = buffer;
   279e4:	6101      	str	r1, [r0, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
   279e6:	42a3      	cmp	r3, r4
   279e8:	d102      	bne.n	279f0 <k_mem_slab_init+0x18>
	list->tail = (sys_dnode_t *)list;
   279ea:	e9c0 0000 	strd	r0, r0, [r0]
}
   279ee:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
   279f0:	6945      	ldr	r5, [r0, #20]
   279f2:	600d      	str	r5, [r1, #0]
	for (j = 0U; j < slab->num_blocks; j++) {
   279f4:	3401      	adds	r4, #1
		slab->free_list = p;
   279f6:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
   279f8:	4411      	add	r1, r2
   279fa:	e7f4      	b.n	279e6 <k_mem_slab_init+0xe>

000279fc <k_mem_pool_malloc>:
{
   279fc:	b507      	push	{r0, r1, r2, lr}
   279fe:	2204      	movs	r2, #4
   27a00:	188a      	adds	r2, r1, r2
   27a02:	d204      	bcs.n	27a0e <k_mem_pool_malloc+0x12>
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
   27a04:	2300      	movs	r3, #0
   27a06:	4669      	mov	r1, sp
   27a08:	f7f6 fd1c 	bl	1e444 <k_mem_pool_alloc>
   27a0c:	b118      	cbz	r0, 27a16 <k_mem_pool_malloc+0x1a>
		return NULL;
   27a0e:	2000      	movs	r0, #0
}
   27a10:	b003      	add	sp, #12
   27a12:	f85d fb04 	ldr.w	pc, [sp], #4
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   27a16:	e9dd 3200 	ldrd	r3, r2, [sp]
   27a1a:	601a      	str	r2, [r3, #0]
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
   27a1c:	9800      	ldr	r0, [sp, #0]
   27a1e:	3004      	adds	r0, #4
   27a20:	e7f6      	b.n	27a10 <k_mem_pool_malloc+0x14>

00027a22 <k_free>:
	if (ptr != NULL) {
   27a22:	b110      	cbz	r0, 27a2a <k_free+0x8>
		k_mem_pool_free_id(ptr);
   27a24:	3804      	subs	r0, #4
   27a26:	f7f6 bd59 	b.w	1e4dc <k_mem_pool_free_id>
}
   27a2a:	4770      	bx	lr

00027a2c <z_impl_k_mutex_init>:
	mutex->owner = NULL;
   27a2c:	2300      	movs	r3, #0
	mutex->lock_count = 0U;
   27a2e:	e9c0 3302 	strd	r3, r3, [r0, #8]
   27a32:	e9c0 0000 	strd	r0, r0, [r0]
}
   27a36:	4770      	bx	lr

00027a38 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static s32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			  bool alloc)
{
   27a38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   27a3c:	4604      	mov	r4, r0
   27a3e:	460f      	mov	r7, r1
   27a40:	4690      	mov	r8, r2
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   27a42:	f100 0608 	add.w	r6, r0, #8
   27a46:	f04f 0220 	mov.w	r2, #32
   27a4a:	f3ef 8511 	mrs	r5, BASEPRI
   27a4e:	f382 8811 	msr	BASEPRI, r2
   27a52:	f3bf 8f6f 	isb	sy
		return 0;
	}
#endif /* !CONFIG_POLL */

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
   27a56:	b1db      	cbz	r3, 27a90 <queue_insert+0x58>
		struct alloc_node *anode;

		anode = z_thread_malloc(sizeof(*anode));
   27a58:	2008      	movs	r0, #8
   27a5a:	f7f6 fd71 	bl	1e540 <z_thread_malloc>
		if (anode == NULL) {
   27a5e:	b938      	cbnz	r0, 27a70 <queue_insert+0x38>
	__asm__ volatile(
   27a60:	f385 8811 	msr	BASEPRI, r5
   27a64:	f3bf 8f6f 	isb	sy
			k_spin_unlock(&queue->lock, key);
			return -ENOMEM;
   27a68:	f06f 000b 	mvn.w	r0, #11
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
#endif /* CONFIG_POLL */

	z_reschedule(&queue->lock, key);
	return 0;
}
   27a6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, u8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
   27a70:	2301      	movs	r3, #1
		anode->data = data;
   27a72:	f8c0 8004 	str.w	r8, [r0, #4]
   27a76:	6003      	str	r3, [r0, #0]
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
   27a78:	6803      	ldr	r3, [r0, #0]
   27a7a:	f003 0203 	and.w	r2, r3, #3
   27a7e:	b95f      	cbnz	r7, 27a98 <queue_insert+0x60>
	parent->next_and_flags = cur_flags | (unative_t)child;
   27a80:	6823      	ldr	r3, [r4, #0]
   27a82:	4313      	orrs	r3, r2
   27a84:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   27a86:	6863      	ldr	r3, [r4, #4]
	list->head = node;
   27a88:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   27a8a:	b973      	cbnz	r3, 27aaa <queue_insert+0x72>
	list->tail = node;
   27a8c:	6060      	str	r0, [r4, #4]
   27a8e:	e00c      	b.n	27aaa <queue_insert+0x72>
	node->next_and_flags = flags;
   27a90:	f8c8 3000 	str.w	r3, [r8]
   27a94:	4640      	mov	r0, r8
   27a96:	e7ef      	b.n	27a78 <queue_insert+0x40>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   27a98:	683b      	ldr	r3, [r7, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   27a9a:	f033 0303 	bics.w	r3, r3, #3
   27a9e:	d115      	bne.n	27acc <queue_insert+0x94>
	parent->next_and_flags = cur_flags | (unative_t)child;
   27aa0:	6002      	str	r2, [r0, #0]
Z_GENLIST_APPEND(sflist, sfnode)
   27aa2:	6862      	ldr	r2, [r4, #4]
   27aa4:	b962      	cbnz	r2, 27ac0 <queue_insert+0x88>
	list->head = node;
   27aa6:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   27aaa:	2104      	movs	r1, #4
   27aac:	f104 000c 	add.w	r0, r4, #12
   27ab0:	f000 fbbd 	bl	2822e <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   27ab4:	4630      	mov	r0, r6
   27ab6:	4629      	mov	r1, r5
   27ab8:	f000 f8ee 	bl	27c98 <z_reschedule>
	return 0;
   27abc:	2000      	movs	r0, #0
   27abe:	e7d5      	b.n	27a6c <queue_insert+0x34>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   27ac0:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   27ac2:	f003 0303 	and.w	r3, r3, #3
   27ac6:	4303      	orrs	r3, r0
   27ac8:	6013      	str	r3, [r2, #0]
   27aca:	e7df      	b.n	27a8c <queue_insert+0x54>
   27acc:	4313      	orrs	r3, r2
   27ace:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   27ad0:	683b      	ldr	r3, [r7, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   27ad2:	f003 0303 	and.w	r3, r3, #3
   27ad6:	4318      	orrs	r0, r3
   27ad8:	6038      	str	r0, [r7, #0]
   27ada:	e7e6      	b.n	27aaa <queue_insert+0x72>

00027adc <z_queue_node_peek>:
{
   27adc:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (u8_t)0)) {
   27ade:	4604      	mov	r4, r0
   27ae0:	b130      	cbz	r0, 27af0 <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   27ae2:	6802      	ldr	r2, [r0, #0]
   27ae4:	0793      	lsls	r3, r2, #30
   27ae6:	d003      	beq.n	27af0 <z_queue_node_peek+0x14>
		ret = anode->data;
   27ae8:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   27aea:	b109      	cbz	r1, 27af0 <z_queue_node_peek+0x14>
			k_free(anode);
   27aec:	f7ff ff99 	bl	27a22 <k_free>
}
   27af0:	4620      	mov	r0, r4
   27af2:	bd10      	pop	{r4, pc}

00027af4 <z_impl_k_queue_init>:
	list->head = NULL;
   27af4:	2300      	movs	r3, #0
	list->tail = NULL;
   27af6:	e9c0 3300 	strd	r3, r3, [r0]
	queue->lock = (struct k_spinlock) {};
   27afa:	7203      	strb	r3, [r0, #8]
	sys_dlist_init(&queue->poll_events);
   27afc:	f100 030c 	add.w	r3, r0, #12
   27b00:	e9c0 3303 	strd	r3, r3, [r0, #12]
}
   27b04:	4770      	bx	lr

00027b06 <k_queue_append>:
	(void)queue_insert(queue, prev, data, false);
}

void k_queue_append(struct k_queue *queue, void *data)
{
	(void)queue_insert(queue, sys_sflist_peek_tail(&queue->data_q),
   27b06:	460a      	mov	r2, r1
   27b08:	2300      	movs	r3, #0
   27b0a:	6841      	ldr	r1, [r0, #4]
   27b0c:	f7ff bf94 	b.w	27a38 <queue_insert>

00027b10 <k_queue_prepend>:
			   data, false);
}

void k_queue_prepend(struct k_queue *queue, void *data)
{
	(void)queue_insert(queue, NULL, data, false);
   27b10:	2300      	movs	r3, #0
   27b12:	460a      	mov	r2, r1
   27b14:	4619      	mov	r1, r3
   27b16:	f7ff bf8f 	b.w	27a38 <queue_insert>

00027b1a <k_queue_append_list>:
}
#include <syscalls/k_queue_alloc_prepend_mrsh.c>
#endif

void k_queue_append_list(struct k_queue *queue, void *head, void *tail)
{
   27b1a:	b570      	push	{r4, r5, r6, lr}
	__ASSERT(head && tail, "invalid head or tail");

	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   27b1c:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
   27b20:	f04f 0320 	mov.w	r3, #32
   27b24:	f3ef 8611 	mrs	r6, BASEPRI
   27b28:	f383 8811 	msr	BASEPRI, r3
   27b2c:	f3bf 8f6f 	isb	sy
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   27b30:	6843      	ldr	r3, [r0, #4]
   27b32:	b95b      	cbnz	r3, 27b4c <k_queue_append_list+0x32>
	list->head = node;
   27b34:	6001      	str	r1, [r0, #0]
	list->tail = node;
   27b36:	6042      	str	r2, [r0, #4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   27b38:	2104      	movs	r1, #4
   27b3a:	300c      	adds	r0, #12
   27b3c:	f000 fb77 	bl	2822e <z_handle_obj_poll_events>
#else
	sys_sflist_append_list(&queue->data_q, head, tail);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
#endif /* !CONFIG_POLL */

	z_reschedule(&queue->lock, key);
   27b40:	4631      	mov	r1, r6
   27b42:	4628      	mov	r0, r5
}
   27b44:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&queue->lock, key);
   27b48:	f000 b8a6 	b.w	27c98 <z_reschedule>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   27b4c:	681c      	ldr	r4, [r3, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   27b4e:	f004 0403 	and.w	r4, r4, #3
   27b52:	4321      	orrs	r1, r4
   27b54:	6019      	str	r1, [r3, #0]
   27b56:	e7ee      	b.n	27b36 <k_queue_append_list+0x1c>

00027b58 <z_impl_k_queue_get>:
	return val;
}
#endif /* CONFIG_POLL */

void *z_impl_k_queue_get(struct k_queue *queue, s32_t timeout)
{
   27b58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   27b5c:	4604      	mov	r4, r0
   27b5e:	b086      	sub	sp, #24
   27b60:	460d      	mov	r5, r1
   27b62:	f04f 0320 	mov.w	r3, #32
   27b66:	f3ef 8711 	mrs	r7, BASEPRI
   27b6a:	f383 8811 	msr	BASEPRI, r3
   27b6e:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(sflist)
   27b72:	6800      	ldr	r0, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   27b74:	b188      	cbz	r0, 27b9a <z_impl_k_queue_get+0x42>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   27b76:	6803      	ldr	r3, [r0, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   27b78:	6862      	ldr	r2, [r4, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   27b7a:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   27b7e:	4290      	cmp	r0, r2
	list->head = node;
   27b80:	6023      	str	r3, [r4, #0]
	list->tail = node;
   27b82:	bf08      	it	eq
   27b84:	6063      	streq	r3, [r4, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   27b86:	2101      	movs	r1, #1
   27b88:	f7ff ffa8 	bl	27adc <z_queue_node_peek>
	__asm__ volatile(
   27b8c:	f387 8811 	msr	BASEPRI, r7
   27b90:	f3bf 8f6f 	isb	sy
#else
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);

	return (ret != 0) ? NULL : _current->base.swap_data;
#endif /* CONFIG_POLL */
}
   27b94:	b006      	add	sp, #24
   27b96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (timeout == K_NO_WAIT) {
   27b9a:	2900      	cmp	r1, #0
   27b9c:	d0f6      	beq.n	27b8c <z_impl_k_queue_get+0x34>
   27b9e:	f387 8811 	msr	BASEPRI, r7
   27ba2:	f3bf 8f6f 	isb	sy
	k_poll_event_init(&event, K_POLL_TYPE_FIFO_DATA_AVAILABLE,
   27ba6:	2104      	movs	r1, #4
   27ba8:	4602      	mov	r2, r0
   27baa:	4623      	mov	r3, r4
   27bac:	eb0d 0001 	add.w	r0, sp, r1
   27bb0:	f7f7 fc06 	bl	1f3c0 <k_poll_event_init>
	if (timeout != K_FOREVER) {
   27bb4:	1c6a      	adds	r2, r5, #1
   27bb6:	d002      	beq.n	27bbe <z_impl_k_queue_get+0x66>
   27bb8:	f000 fa06 	bl	27fc8 <z_impl_k_uptime_get>
   27bbc:	4606      	mov	r6, r0
{
   27bbe:	2700      	movs	r7, #0
		event.state = K_POLL_STATE_NOT_READY;
   27bc0:	9b04      	ldr	r3, [sp, #16]
   27bc2:	f36f 3310 	bfc	r3, #12, #5
   27bc6:	9304      	str	r3, [sp, #16]
	return z_impl_k_poll(events, num_events, timeout);
   27bc8:	2101      	movs	r1, #1
   27bca:	1bea      	subs	r2, r5, r7
   27bcc:	a801      	add	r0, sp, #4
   27bce:	f7f7 fc0b 	bl	1f3e8 <z_impl_k_poll>
		if (err && err != -EAGAIN) {
   27bd2:	b118      	cbz	r0, 27bdc <z_impl_k_queue_get+0x84>
   27bd4:	300b      	adds	r0, #11
   27bd6:	d001      	beq.n	27bdc <z_impl_k_queue_get+0x84>
			return NULL;
   27bd8:	2000      	movs	r0, #0
   27bda:	e7db      	b.n	27b94 <z_impl_k_queue_get+0x3c>
	__asm__ volatile(
   27bdc:	f04f 0320 	mov.w	r3, #32
   27be0:	f3ef 8811 	mrs	r8, BASEPRI
   27be4:	f383 8811 	msr	BASEPRI, r3
   27be8:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(sflist)
   27bec:	6820      	ldr	r0, [r4, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_sfnode_t *sys_sflist_get(sys_sflist_t *list);

Z_GENLIST_GET(sflist, sfnode)
   27bee:	b138      	cbz	r0, 27c00 <z_impl_k_queue_get+0xa8>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   27bf0:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   27bf2:	6862      	ldr	r2, [r4, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   27bf4:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   27bf8:	4290      	cmp	r0, r2
	list->head = node;
   27bfa:	6023      	str	r3, [r4, #0]
	list->tail = node;
   27bfc:	bf08      	it	eq
   27bfe:	6063      	streq	r3, [r4, #4]
		val = z_queue_node_peek(sys_sflist_get(&queue->data_q), true);
   27c00:	2101      	movs	r1, #1
   27c02:	f7ff ff6b 	bl	27adc <z_queue_node_peek>
	__asm__ volatile(
   27c06:	f388 8811 	msr	BASEPRI, r8
   27c0a:	f3bf 8f6f 	isb	sy
		if ((val == NULL) && (timeout != K_FOREVER)) {
   27c0e:	2800      	cmp	r0, #0
   27c10:	d1c0      	bne.n	27b94 <z_impl_k_queue_get+0x3c>
   27c12:	1c6b      	adds	r3, r5, #1
   27c14:	d0d4      	beq.n	27bc0 <z_impl_k_queue_get+0x68>
	return z_impl_k_uptime_get();
   27c16:	f000 f9d7 	bl	27fc8 <z_impl_k_uptime_get>
			elapsed = k_uptime_get_32() - start;
   27c1a:	1b87      	subs	r7, r0, r6
	} while (!val && !done);
   27c1c:	42bd      	cmp	r5, r7
   27c1e:	dacf      	bge.n	27bc0 <z_impl_k_queue_get+0x68>
   27c20:	e7da      	b.n	27bd8 <z_impl_k_queue_get+0x80>

00027c22 <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   27c22:	7b43      	ldrb	r3, [r0, #13]
   27c24:	06db      	lsls	r3, r3, #27
   27c26:	bf03      	ittte	eq
   27c28:	6980      	ldreq	r0, [r0, #24]
   27c2a:	fab0 f080 	clzeq	r0, r0
   27c2e:	0940      	lsreq	r0, r0, #5
   27c30:	2000      	movne	r0, #0
}
   27c32:	4770      	bx	lr

00027c34 <z_is_t1_higher_prio_than_t2>:
	if (thread_1->base.prio < thread_2->base.prio) {
   27c34:	f990 000e 	ldrsb.w	r0, [r0, #14]
   27c38:	f991 300e 	ldrsb.w	r3, [r1, #14]
}
   27c3c:	4298      	cmp	r0, r3
   27c3e:	bfac      	ite	ge
   27c40:	2000      	movge	r0, #0
   27c42:	2001      	movlt	r0, #1
   27c44:	4770      	bx	lr

00027c46 <z_find_first_thread_to_unpend>:
{
   27c46:	b510      	push	{r4, lr}
	__asm__ volatile(
   27c48:	f04f 0320 	mov.w	r3, #32
   27c4c:	f3ef 8411 	mrs	r4, BASEPRI
   27c50:	f383 8811 	msr	BASEPRI, r3
   27c54:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
   27c58:	f000 f85d 	bl	27d16 <z_priq_dumb_best>
	__asm__ volatile(
   27c5c:	f384 8811 	msr	BASEPRI, r4
   27c60:	f3bf 8f6f 	isb	sy
}
   27c64:	bd10      	pop	{r4, pc}

00027c66 <z_unpend_thread_no_timeout>:
{
   27c66:	b538      	push	{r3, r4, r5, lr}
   27c68:	4604      	mov	r4, r0
	__asm__ volatile(
   27c6a:	f04f 0320 	mov.w	r3, #32
   27c6e:	f3ef 8511 	mrs	r5, BASEPRI
   27c72:	f383 8811 	msr	BASEPRI, r3
   27c76:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   27c7a:	4601      	mov	r1, r0
   27c7c:	6880      	ldr	r0, [r0, #8]
   27c7e:	f7f6 fd71 	bl	1e764 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   27c82:	7b63      	ldrb	r3, [r4, #13]
   27c84:	f023 0302 	bic.w	r3, r3, #2
   27c88:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   27c8a:	f385 8811 	msr	BASEPRI, r5
   27c8e:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   27c92:	2300      	movs	r3, #0
   27c94:	60a3      	str	r3, [r4, #8]
}
   27c96:	bd38      	pop	{r3, r4, r5, pc}

00027c98 <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   27c98:	b921      	cbnz	r1, 27ca4 <z_reschedule+0xc>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   27c9a:	f3ef 8005 	mrs	r0, IPSR
   27c9e:	b908      	cbnz	r0, 27ca4 <z_reschedule+0xc>
   27ca0:	f7de beda 	b.w	6a58 <arch_swap>
   27ca4:	f381 8811 	msr	BASEPRI, r1
   27ca8:	f3bf 8f6f 	isb	sy
}
   27cac:	4770      	bx	lr

00027cae <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   27cae:	4603      	mov	r3, r0
   27cb0:	b920      	cbnz	r0, 27cbc <z_reschedule_irqlock+0xe>
   27cb2:	f3ef 8205 	mrs	r2, IPSR
   27cb6:	b90a      	cbnz	r2, 27cbc <z_reschedule_irqlock+0xe>
   27cb8:	f7de bece 	b.w	6a58 <arch_swap>
   27cbc:	f383 8811 	msr	BASEPRI, r3
   27cc0:	f3bf 8f6f 	isb	sy
}
   27cc4:	4770      	bx	lr

00027cc6 <z_reschedule_unlocked>:
	__asm__ volatile(
   27cc6:	f04f 0320 	mov.w	r3, #32
   27cca:	f3ef 8011 	mrs	r0, BASEPRI
   27cce:	f383 8811 	msr	BASEPRI, r3
   27cd2:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   27cd6:	f7ff bfea 	b.w	27cae <z_reschedule_irqlock>

00027cda <z_unpend_thread>:
{
   27cda:	b538      	push	{r3, r4, r5, lr}
   27cdc:	4604      	mov	r4, r0
   27cde:	f04f 0320 	mov.w	r3, #32
   27ce2:	f3ef 8511 	mrs	r5, BASEPRI
   27ce6:	f383 8811 	msr	BASEPRI, r3
   27cea:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   27cee:	4601      	mov	r1, r0
   27cf0:	6880      	ldr	r0, [r0, #8]
   27cf2:	f7f6 fd37 	bl	1e764 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   27cf6:	7b63      	ldrb	r3, [r4, #13]
   27cf8:	f023 0302 	bic.w	r3, r3, #2
   27cfc:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   27cfe:	f385 8811 	msr	BASEPRI, r5
   27d02:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   27d06:	2300      	movs	r3, #0
   27d08:	60a3      	str	r3, [r4, #8]
	return z_abort_timeout(&thread->base.timeout);
   27d0a:	f104 0018 	add.w	r0, r4, #24
}
   27d0e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   27d12:	f000 b915 	b.w	27f40 <z_abort_timeout>

00027d16 <z_priq_dumb_best>:
	return list->head == list;
   27d16:	6803      	ldr	r3, [r0, #0]
}
   27d18:	4298      	cmp	r0, r3
   27d1a:	bf14      	ite	ne
   27d1c:	4618      	movne	r0, r3
   27d1e:	2000      	moveq	r0, #0
   27d20:	4770      	bx	lr

00027d22 <z_thread_timeout>:
	if (thread->base.pended_on != NULL) {
   27d22:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
   27d26:	b570      	push	{r4, r5, r6, lr}
   27d28:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
   27d2a:	f1a0 0518 	sub.w	r5, r0, #24
	if (thread->base.pended_on != NULL) {
   27d2e:	b1cb      	cbz	r3, 27d64 <z_thread_timeout+0x42>
	__asm__ volatile(
   27d30:	f04f 0320 	mov.w	r3, #32
   27d34:	f3ef 8611 	mrs	r6, BASEPRI
   27d38:	f383 8811 	msr	BASEPRI, r3
   27d3c:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   27d40:	4629      	mov	r1, r5
   27d42:	f850 0c10 	ldr.w	r0, [r0, #-16]
   27d46:	f7f6 fd0d 	bl	1e764 <z_priq_dumb_remove>
   27d4a:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   27d4e:	f023 0302 	bic.w	r3, r3, #2
   27d52:	f804 3c0b 	strb.w	r3, [r4, #-11]
	__asm__ volatile(
   27d56:	f386 8811 	msr	BASEPRI, r6
   27d5a:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   27d5e:	2300      	movs	r3, #0
   27d60:	f844 3c10 	str.w	r3, [r4, #-16]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   27d64:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   27d68:	f023 0314 	bic.w	r3, r3, #20
   27d6c:	f804 3c0b 	strb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
   27d70:	4628      	mov	r0, r5
   27d72:	f7ff ff56 	bl	27c22 <z_is_thread_ready>
   27d76:	b120      	cbz	r0, 27d82 <z_thread_timeout+0x60>
		z_add_thread_to_ready_q(thread);
   27d78:	4628      	mov	r0, r5
}
   27d7a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   27d7e:	f7f6 bd41 	b.w	1e804 <z_add_thread_to_ready_q>
   27d82:	bd70      	pop	{r4, r5, r6, pc}

00027d84 <z_unpend_first_thread>:
{
   27d84:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   27d86:	f04f 0320 	mov.w	r3, #32
   27d8a:	f3ef 8211 	mrs	r2, BASEPRI
   27d8e:	f383 8811 	msr	BASEPRI, r3
   27d92:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
   27d96:	f7ff ffbe 	bl	27d16 <z_priq_dumb_best>
   27d9a:	4604      	mov	r4, r0
	__asm__ volatile(
   27d9c:	f382 8811 	msr	BASEPRI, r2
   27da0:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   27da4:	b1c8      	cbz	r0, 27dda <z_unpend_first_thread+0x56>
	__asm__ volatile(
   27da6:	f04f 0320 	mov.w	r3, #32
   27daa:	f3ef 8511 	mrs	r5, BASEPRI
   27dae:	f383 8811 	msr	BASEPRI, r3
   27db2:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   27db6:	4601      	mov	r1, r0
   27db8:	6880      	ldr	r0, [r0, #8]
   27dba:	f7f6 fcd3 	bl	1e764 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   27dbe:	7b63      	ldrb	r3, [r4, #13]
   27dc0:	f023 0302 	bic.w	r3, r3, #2
   27dc4:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   27dc6:	f385 8811 	msr	BASEPRI, r5
   27dca:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   27dce:	2300      	movs	r3, #0
   27dd0:	60a3      	str	r3, [r4, #8]
   27dd2:	f104 0018 	add.w	r0, r4, #24
   27dd6:	f000 f8b3 	bl	27f40 <z_abort_timeout>
}
   27dda:	4620      	mov	r0, r4
   27ddc:	bd38      	pop	{r3, r4, r5, pc}

00027dde <z_unpend_all>:
{
   27dde:	b570      	push	{r4, r5, r6, lr}
   27de0:	4606      	mov	r6, r0
	int need_sched = 0;
   27de2:	2500      	movs	r5, #0
   27de4:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   27de6:	42a6      	cmp	r6, r4
   27de8:	d000      	beq.n	27dec <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   27dea:	b90c      	cbnz	r4, 27df0 <z_unpend_all+0x12>
}
   27dec:	4628      	mov	r0, r5
   27dee:	bd70      	pop	{r4, r5, r6, pc}
		z_unpend_thread(thread);
   27df0:	4620      	mov	r0, r4
   27df2:	f7ff ff72 	bl	27cda <z_unpend_thread>
	if (z_is_thread_ready(thread)) {
   27df6:	4620      	mov	r0, r4
   27df8:	f7ff ff13 	bl	27c22 <z_is_thread_ready>
		need_sched = 1;
   27dfc:	2501      	movs	r5, #1
   27dfe:	2800      	cmp	r0, #0
   27e00:	d0f0      	beq.n	27de4 <z_unpend_all+0x6>
		z_add_thread_to_ready_q(thread);
   27e02:	4620      	mov	r0, r4
   27e04:	f7f6 fcfe 	bl	1e804 <z_add_thread_to_ready_q>
   27e08:	e7ec      	b.n	27de4 <z_unpend_all+0x6>

00027e0a <z_impl_k_sem_init>:
	sys_dlist_init(&sem->poll_events);
   27e0a:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
   27e0e:	e9c0 1202 	strd	r1, r2, [r0, #8]
	list->tail = (sys_dnode_t *)list;
   27e12:	e9c0 0000 	strd	r0, r0, [r0]
   27e16:	e9c0 3304 	strd	r3, r3, [r0, #16]
}
   27e1a:	4770      	bx	lr

00027e1c <z_impl_k_busy_wait>:
	arch_busy_wait(usec_to_wait);
   27e1c:	f7df bcb8 	b.w	7790 <arch_busy_wait>

00027e20 <z_impl_k_thread_name_set>:
}
   27e20:	f06f 0057 	mvn.w	r0, #87	; 0x57
   27e24:	4770      	bx	lr

00027e26 <k_thread_name_get>:
}
   27e26:	2000      	movs	r0, #0
   27e28:	4770      	bx	lr

00027e2a <z_new_thread_init>:
{
   27e2a:	b510      	push	{r4, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
   27e2c:	9c02      	ldr	r4, [sp, #8]
   27e2e:	7304      	strb	r4, [r0, #12]
	thread_base->thread_state = (u8_t)initial_state;

	thread_base->prio = priority;
   27e30:	7383      	strb	r3, [r0, #14]
	thread_base->thread_state = (u8_t)initial_state;
   27e32:	2404      	movs	r4, #4

	thread_base->sched_locked = 0U;
   27e34:	2300      	movs	r3, #0
	thread_base->thread_state = (u8_t)initial_state;
   27e36:	7344      	strb	r4, [r0, #13]
	thread_base->sched_locked = 0U;
   27e38:	73c3      	strb	r3, [r0, #15]
	node->prev = NULL;
   27e3a:	e9c0 3306 	strd	r3, r3, [r0, #24]
	thread->fn_abort = NULL;
   27e3e:	e9c0 3313 	strd	r3, r3, [r0, #76]	; 0x4c
	thread->stack_info.size = (u32_t)stackSize;
   27e42:	e9c0 1216 	strd	r1, r2, [r0, #88]	; 0x58
}
   27e46:	bd10      	pop	{r4, pc}

00027e48 <k_work_submit_to_queue>:
{
   27e48:	b500      	push	{lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   27e4a:	f101 0308 	add.w	r3, r1, #8
   27e4e:	f3bf 8f5b 	dmb	ish
   27e52:	e853 2f00 	ldrex	r2, [r3]
   27e56:	f042 0c01 	orr.w	ip, r2, #1
   27e5a:	e843 ce00 	strex	lr, ip, [r3]
   27e5e:	f1be 0f00 	cmp.w	lr, #0
   27e62:	d1f6      	bne.n	27e52 <k_work_submit_to_queue+0xa>
   27e64:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   27e68:	07d3      	lsls	r3, r2, #31
   27e6a:	d403      	bmi.n	27e74 <k_work_submit_to_queue+0x2c>
}
   27e6c:	f85d eb04 	ldr.w	lr, [sp], #4
		k_queue_append(&work_q->queue, work);
   27e70:	f7ff be49 	b.w	27b06 <k_queue_append>
}
   27e74:	f85d fb04 	ldr.w	pc, [sp], #4

00027e78 <work_timeout>:
	k_work_submit_to_queue(w->work_q, &w->work);
   27e78:	f1a0 010c 	sub.w	r1, r0, #12
   27e7c:	6900      	ldr	r0, [r0, #16]
   27e7e:	f7ff bfe3 	b.w	27e48 <k_work_submit_to_queue>

00027e82 <work_cancel>:
{
   27e82:	b570      	push	{r4, r5, r6, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   27e84:	f3bf 8f5b 	dmb	ish
   27e88:	6883      	ldr	r3, [r0, #8]
   27e8a:	f3bf 8f5b 	dmb	ish
	if (k_work_pending(&work->work)) {
   27e8e:	07db      	lsls	r3, r3, #31
{
   27e90:	4604      	mov	r4, r0
	return atomic_test_bit(work->flags, K_WORK_STATE_PENDING);
   27e92:	f100 0508 	add.w	r5, r0, #8
	if (k_work_pending(&work->work)) {
   27e96:	d532      	bpl.n	27efe <work_cancel+0x7c>
		if (!k_queue_remove(&work->work_q->queue, &work->work)) {
   27e98:	69c2      	ldr	r2, [r0, #28]
 * @return true if node was removed
 */
static inline bool sys_sflist_find_and_remove(sys_sflist_t *list,
					      sys_sfnode_t *node);

Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   27e9a:	6813      	ldr	r3, [r2, #0]
   27e9c:	2100      	movs	r1, #0
   27e9e:	b913      	cbnz	r3, 27ea6 <work_cancel+0x24>
			return -EINVAL;
   27ea0:	f06f 0015 	mvn.w	r0, #21
}
   27ea4:	bd70      	pop	{r4, r5, r6, pc}
   27ea6:	429c      	cmp	r4, r3
   27ea8:	d124      	bne.n	27ef4 <work_cancel+0x72>
Z_GENLIST_REMOVE(sflist, sfnode)
   27eaa:	6823      	ldr	r3, [r4, #0]
   27eac:	6856      	ldr	r6, [r2, #4]
   27eae:	f023 0003 	bic.w	r0, r3, #3
   27eb2:	b9b1      	cbnz	r1, 27ee2 <work_cancel+0x60>
   27eb4:	42b4      	cmp	r4, r6
	list->head = node;
   27eb6:	6010      	str	r0, [r2, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
   27eb8:	d100      	bne.n	27ebc <work_cancel+0x3a>
	list->tail = node;
   27eba:	6050      	str	r0, [r2, #4]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   27ebc:	6823      	ldr	r3, [r4, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   27ebe:	f003 0303 	and.w	r3, r3, #3
   27ec2:	6023      	str	r3, [r4, #0]
	work->work_q = NULL;
   27ec4:	2000      	movs	r0, #0
   27ec6:	61e0      	str	r0, [r4, #28]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   27ec8:	f3bf 8f5b 	dmb	ish
   27ecc:	e855 3f00 	ldrex	r3, [r5]
   27ed0:	f023 0301 	bic.w	r3, r3, #1
   27ed4:	e845 3200 	strex	r2, r3, [r5]
   27ed8:	2a00      	cmp	r2, #0
   27eda:	d1f7      	bne.n	27ecc <work_cancel+0x4a>
   27edc:	f3bf 8f5b 	dmb	ish
   27ee0:	e7e0      	b.n	27ea4 <work_cancel+0x22>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   27ee2:	680b      	ldr	r3, [r1, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   27ee4:	f003 0303 	and.w	r3, r3, #3
   27ee8:	4303      	orrs	r3, r0
Z_GENLIST_REMOVE(sflist, sfnode)
   27eea:	42b4      	cmp	r4, r6
	parent->next_and_flags = cur_flags | (unative_t)child;
   27eec:	600b      	str	r3, [r1, #0]
	list->tail = node;
   27eee:	bf08      	it	eq
   27ef0:	6051      	streq	r1, [r2, #4]
   27ef2:	e7e3      	b.n	27ebc <work_cancel+0x3a>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   27ef4:	6818      	ldr	r0, [r3, #0]
Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   27ef6:	4619      	mov	r1, r3
   27ef8:	f020 0303 	bic.w	r3, r0, #3
   27efc:	e7cf      	b.n	27e9e <work_cancel+0x1c>
		(void)z_abort_timeout(&work->timeout);
   27efe:	300c      	adds	r0, #12
   27f00:	f000 f81e 	bl	27f40 <z_abort_timeout>
   27f04:	e7de      	b.n	27ec4 <work_cancel+0x42>

00027f06 <k_delayed_work_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   27f06:	2300      	movs	r3, #0
   27f08:	e9c0 3100 	strd	r3, r1, [r0]
	node->next = NULL;
   27f0c:	e9c0 3302 	strd	r3, r3, [r0, #8]
	node->prev = NULL;
   27f10:	6103      	str	r3, [r0, #16]
	work->work_q = NULL;
   27f12:	61c3      	str	r3, [r0, #28]
}
   27f14:	4770      	bx	lr

00027f16 <k_delayed_work_cancel>:

int k_delayed_work_cancel(struct k_delayed_work *work)
{
	if (!work->work_q) {
   27f16:	69c3      	ldr	r3, [r0, #28]
{
   27f18:	b510      	push	{r4, lr}
	if (!work->work_q) {
   27f1a:	b173      	cbz	r3, 27f3a <k_delayed_work_cancel+0x24>
	__asm__ volatile(
   27f1c:	f04f 0320 	mov.w	r3, #32
   27f20:	f3ef 8411 	mrs	r4, BASEPRI
   27f24:	f383 8811 	msr	BASEPRI, r3
   27f28:	f3bf 8f6f 	isb	sy
		return -EINVAL;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	int ret = work_cancel(work);
   27f2c:	f7ff ffa9 	bl	27e82 <work_cancel>
	__asm__ volatile(
   27f30:	f384 8811 	msr	BASEPRI, r4
   27f34:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
   27f38:	bd10      	pop	{r4, pc}
		return -EINVAL;
   27f3a:	f06f 0015 	mvn.w	r0, #21
   27f3e:	e7fb      	b.n	27f38 <k_delayed_work_cancel+0x22>

00027f40 <z_abort_timeout>:
{
   27f40:	b510      	push	{r4, lr}
	__asm__ volatile(
   27f42:	f04f 0220 	mov.w	r2, #32
   27f46:	f3ef 8411 	mrs	r4, BASEPRI
   27f4a:	f382 8811 	msr	BASEPRI, r2
   27f4e:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   27f52:	6803      	ldr	r3, [r0, #0]
   27f54:	b13b      	cbz	r3, 27f66 <z_abort_timeout+0x26>
			remove_timeout(to);
   27f56:	f7f7 f8d1 	bl	1f0fc <remove_timeout>
			ret = 0;
   27f5a:	2000      	movs	r0, #0
	__asm__ volatile(
   27f5c:	f384 8811 	msr	BASEPRI, r4
   27f60:	f3bf 8f6f 	isb	sy
}
   27f64:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   27f66:	f06f 0015 	mvn.w	r0, #21
   27f6a:	e7f7      	b.n	27f5c <z_abort_timeout+0x1c>

00027f6c <z_get_next_timeout_expiry>:
{
   27f6c:	b510      	push	{r4, lr}
	__asm__ volatile(
   27f6e:	f04f 0320 	mov.w	r3, #32
   27f72:	f3ef 8411 	mrs	r4, BASEPRI
   27f76:	f383 8811 	msr	BASEPRI, r3
   27f7a:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   27f7e:	f7f7 f8d1 	bl	1f124 <next_timeout>
	__asm__ volatile(
   27f82:	f384 8811 	msr	BASEPRI, r4
   27f86:	f3bf 8f6f 	isb	sy
}
   27f8a:	bd10      	pop	{r4, pc}

00027f8c <z_set_timeout_expiry>:
{
   27f8c:	b570      	push	{r4, r5, r6, lr}
   27f8e:	4604      	mov	r4, r0
   27f90:	460e      	mov	r6, r1
	__asm__ volatile(
   27f92:	f04f 0320 	mov.w	r3, #32
   27f96:	f3ef 8511 	mrs	r5, BASEPRI
   27f9a:	f383 8811 	msr	BASEPRI, r3
   27f9e:	f3bf 8f6f 	isb	sy
		int next = next_timeout();
   27fa2:	f7f7 f8bf 	bl	1f124 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   27fa6:	2801      	cmp	r0, #1
   27fa8:	dd05      	ble.n	27fb6 <z_set_timeout_expiry+0x2a>
   27faa:	42a0      	cmp	r0, r4
   27fac:	dd03      	ble.n	27fb6 <z_set_timeout_expiry+0x2a>
			z_clock_set_timeout(ticks, idle);
   27fae:	4631      	mov	r1, r6
   27fb0:	4620      	mov	r0, r4
   27fb2:	f7de fc33 	bl	681c <z_clock_set_timeout>
	__asm__ volatile(
   27fb6:	f385 8811 	msr	BASEPRI, r5
   27fba:	f3bf 8f6f 	isb	sy
}
   27fbe:	bd70      	pop	{r4, r5, r6, pc}

00027fc0 <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
   27fc0:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
   27fc2:	f7f7 f98d 	bl	1f2e0 <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
   27fc6:	bd08      	pop	{r3, pc}

00027fc8 <z_impl_k_uptime_get>:

s64_t z_impl_k_uptime_get(void)
{
   27fc8:	b510      	push	{r4, lr}
	return k_ticks_to_ms_floor64(z_tick_get());
   27fca:	f7f7 f989 	bl	1f2e0 <z_tick_get>
			return (t * to_hz + off) / from_hz;
   27fce:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   27fd2:	fba0 2304 	umull	r2, r3, r0, r4
   27fd6:	fb04 3301 	mla	r3, r4, r1, r3
   27fda:	0bd0      	lsrs	r0, r2, #15
}
   27fdc:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
   27fe0:	0bd9      	lsrs	r1, r3, #15
   27fe2:	bd10      	pop	{r4, pc}

00027fe4 <k_timer_init>:
	timer->status = 0U;
   27fe4:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   27fe6:	e9c0 1206 	strd	r1, r2, [r0, #24]
   27fea:	f100 0210 	add.w	r2, r0, #16
	timer->status = 0U;
   27fee:	6243      	str	r3, [r0, #36]	; 0x24
	list->tail = (sys_dnode_t *)list;
   27ff0:	e9c0 2204 	strd	r2, r2, [r0, #16]
	node->prev = NULL;
   27ff4:	e9c0 3300 	strd	r3, r3, [r0]
	timer->user_data = NULL;
   27ff8:	6283      	str	r3, [r0, #40]	; 0x28
}
   27ffa:	4770      	bx	lr

00027ffc <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   27ffc:	b510      	push	{r4, lr}
   27ffe:	4604      	mov	r4, r0
	int inactive = z_abort_timeout(&timer->timeout) != 0;
   28000:	f7ff ff9e 	bl	27f40 <z_abort_timeout>

	if (inactive) {
   28004:	bb00      	cbnz	r0, 28048 <z_impl_k_timer_stop+0x4c>
		return;
	}

	if (timer->stop_fn != NULL) {
   28006:	69e3      	ldr	r3, [r4, #28]
   28008:	b10b      	cbz	r3, 2800e <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   2800a:	4620      	mov	r0, r4
   2800c:	4798      	blx	r3
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
   2800e:	f104 0010 	add.w	r0, r4, #16
   28012:	2100      	movs	r1, #0
   28014:	f7ff fe17 	bl	27c46 <z_find_first_thread_to_unpend>
	if (thread != NULL) {
   28018:	4604      	mov	r4, r0
   2801a:	b1a8      	cbz	r0, 28048 <z_impl_k_timer_stop+0x4c>
		z_unpend_thread_no_timeout(thread);
   2801c:	f7ff fe23 	bl	27c66 <z_unpend_thread_no_timeout>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   28020:	7b63      	ldrb	r3, [r4, #13]
   28022:	06db      	lsls	r3, r3, #27
   28024:	d104      	bne.n	28030 <z_impl_k_timer_stop+0x34>
	if (z_is_thread_ready(thread)) {
   28026:	69a3      	ldr	r3, [r4, #24]
   28028:	b913      	cbnz	r3, 28030 <z_impl_k_timer_stop+0x34>
		z_add_thread_to_ready_q(thread);
   2802a:	4620      	mov	r0, r4
   2802c:	f7f6 fbea 	bl	1e804 <z_add_thread_to_ready_q>
	__asm__ volatile(
   28030:	f04f 0320 	mov.w	r3, #32
   28034:	f3ef 8011 	mrs	r0, BASEPRI
   28038:	f383 8811 	msr	BASEPRI, r3
   2803c:	f3bf 8f6f 	isb	sy

	if (pending_thread != NULL) {
		z_ready_thread(pending_thread);
		z_reschedule_unlocked();
	}
}
   28040:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   28044:	f7ff be33 	b.w	27cae <z_reschedule_irqlock>
   28048:	bd10      	pop	{r4, pc}

0002804a <clear_event_registrations>:
	while (num_events--) {
   2804a:	2314      	movs	r3, #20
{
   2804c:	b570      	push	{r4, r5, r6, lr}
   2804e:	fb03 0101 	mla	r1, r3, r1, r0
	event->poller = NULL;
   28052:	2400      	movs	r4, #0
   28054:	2601      	movs	r6, #1
	while (num_events--) {
   28056:	4281      	cmp	r1, r0
   28058:	d100      	bne.n	2805c <clear_event_registrations+0x12>
}
   2805a:	bd70      	pop	{r4, r5, r6, pc}
	switch (event->type) {
   2805c:	f811 3c07 	ldrb.w	r3, [r1, #-7]
	event->poller = NULL;
   28060:	f841 4c0c 	str.w	r4, [r1, #-12]
	switch (event->type) {
   28064:	f003 030f 	and.w	r3, r3, #15
   28068:	2b04      	cmp	r3, #4
   2806a:	d80d      	bhi.n	28088 <clear_event_registrations+0x3e>
   2806c:	fa06 f303 	lsl.w	r3, r6, r3
   28070:	f013 0f16 	tst.w	r3, #22
   28074:	d008      	beq.n	28088 <clear_event_registrations+0x3e>
	if (remove && sys_dnode_is_linked(&event->_node)) {
   28076:	f851 3c14 	ldr.w	r3, [r1, #-20]
   2807a:	b12b      	cbz	r3, 28088 <clear_event_registrations+0x3e>
	node->prev->next = node->next;
   2807c:	f851 5c10 	ldr.w	r5, [r1, #-16]
   28080:	602b      	str	r3, [r5, #0]
	node->next->prev = node->prev;
   28082:	605d      	str	r5, [r3, #4]
	node->prev = NULL;
   28084:	e941 4405 	strd	r4, r4, [r1, #-20]
	__asm__ volatile(
   28088:	f382 8811 	msr	BASEPRI, r2
   2808c:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   28090:	f04f 0320 	mov.w	r3, #32
   28094:	f3ef 8211 	mrs	r2, BASEPRI
   28098:	f383 8811 	msr	BASEPRI, r3
   2809c:	f3bf 8f6f 	isb	sy
   280a0:	3914      	subs	r1, #20
   280a2:	e7d8      	b.n	28056 <clear_event_registrations+0xc>

000280a4 <signal_poll_event>:
{
   280a4:	b570      	push	{r4, r5, r6, lr}
	struct _poller *poller = event->poller;
   280a6:	6884      	ldr	r4, [r0, #8]
{
   280a8:	4605      	mov	r5, r0
   280aa:	460e      	mov	r6, r1
	if (poller) {
   280ac:	b19c      	cbz	r4, 280d6 <signal_poll_event+0x32>
		if (poller->cb != NULL) {
   280ae:	68a3      	ldr	r3, [r4, #8]
   280b0:	b95b      	cbnz	r3, 280ca <signal_poll_event+0x26>
		poller->is_polling = false;
   280b2:	7023      	strb	r3, [r4, #0]
	int retcode = 0;
   280b4:	4618      	mov	r0, r3
	event->poller = NULL;
   280b6:	2300      	movs	r3, #0
   280b8:	60ab      	str	r3, [r5, #8]
	event->state |= state;
   280ba:	68eb      	ldr	r3, [r5, #12]
   280bc:	f3c3 3204 	ubfx	r2, r3, #12, #5
   280c0:	4316      	orrs	r6, r2
   280c2:	f366 3310 	bfi	r3, r6, #12, #5
   280c6:	60eb      	str	r3, [r5, #12]
	return retcode;
   280c8:	e004      	b.n	280d4 <signal_poll_event+0x30>
			retcode = poller->cb(event, state);
   280ca:	4798      	blx	r3
		poller->is_polling = false;
   280cc:	2300      	movs	r3, #0
		if (retcode < 0) {
   280ce:	2800      	cmp	r0, #0
		poller->is_polling = false;
   280d0:	7023      	strb	r3, [r4, #0]
		if (retcode < 0) {
   280d2:	daf0      	bge.n	280b6 <signal_poll_event+0x12>
}
   280d4:	bd70      	pop	{r4, r5, r6, pc}
	int retcode = 0;
   280d6:	4620      	mov	r0, r4
   280d8:	e7ed      	b.n	280b6 <signal_poll_event+0x12>

000280da <k_poll_poller_cb>:
{
   280da:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = event->poller->thread;
   280dc:	6883      	ldr	r3, [r0, #8]
   280de:	685c      	ldr	r4, [r3, #4]
	if (!z_is_thread_pending(thread)) {
   280e0:	7b63      	ldrb	r3, [r4, #13]
   280e2:	079a      	lsls	r2, r3, #30
{
   280e4:	460d      	mov	r5, r1
	if (!z_is_thread_pending(thread)) {
   280e6:	d401      	bmi.n	280ec <k_poll_poller_cb+0x12>
		return 0;
   280e8:	2000      	movs	r0, #0
}
   280ea:	bd38      	pop	{r3, r4, r5, pc}
	if (z_is_thread_timeout_expired(thread)) {
   280ec:	6a23      	ldr	r3, [r4, #32]
   280ee:	3302      	adds	r3, #2
   280f0:	d012      	beq.n	28118 <k_poll_poller_cb+0x3e>
	z_unpend_thread(thread);
   280f2:	4620      	mov	r0, r4
   280f4:	f7ff fdf1 	bl	27cda <z_unpend_thread>
	arch_thread_return_value_set(thread,
   280f8:	2d08      	cmp	r5, #8
   280fa:	bf0c      	ite	eq
   280fc:	f06f 0303 	mvneq.w	r3, #3
   28100:	2300      	movne	r3, #0
   28102:	66a3      	str	r3, [r4, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   28104:	7b63      	ldrb	r3, [r4, #13]
   28106:	06db      	lsls	r3, r3, #27
   28108:	d1ee      	bne.n	280e8 <k_poll_poller_cb+0xe>
	if (!z_is_thread_ready(thread)) {
   2810a:	69a5      	ldr	r5, [r4, #24]
   2810c:	2d00      	cmp	r5, #0
   2810e:	d1eb      	bne.n	280e8 <k_poll_poller_cb+0xe>
		z_add_thread_to_ready_q(thread);
   28110:	4620      	mov	r0, r4
   28112:	f7f6 fb77 	bl	1e804 <z_add_thread_to_ready_q>
	return 0;
   28116:	e7e7      	b.n	280e8 <k_poll_poller_cb+0xe>
		return -EAGAIN;
   28118:	f06f 000a 	mvn.w	r0, #10
   2811c:	e7e5      	b.n	280ea <k_poll_poller_cb+0x10>

0002811e <add_event>:
{
   2811e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   28120:	4617      	mov	r7, r2
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   28122:	e9d0 2300 	ldrd	r2, r3, [r0]
   28126:	4290      	cmp	r0, r2
   28128:	4604      	mov	r4, r0
   2812a:	460d      	mov	r5, r1
   2812c:	d106      	bne.n	2813c <add_event+0x1e>
	node->prev = list->tail;
   2812e:	6863      	ldr	r3, [r4, #4]
   28130:	606b      	str	r3, [r5, #4]
	list->tail->next = node;
   28132:	6863      	ldr	r3, [r4, #4]
	node->next = list;
   28134:	602c      	str	r4, [r5, #0]
	list->tail->next = node;
   28136:	601d      	str	r5, [r3, #0]
	list->tail = node;
   28138:	6065      	str	r5, [r4, #4]
}
   2813a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
   2813c:	2b00      	cmp	r3, #0
   2813e:	d0f6      	beq.n	2812e <add_event+0x10>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
   28140:	689b      	ldr	r3, [r3, #8]
   28142:	6879      	ldr	r1, [r7, #4]
   28144:	6858      	ldr	r0, [r3, #4]
   28146:	f7ff fd75 	bl	27c34 <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
   2814a:	2800      	cmp	r0, #0
   2814c:	d1ef      	bne.n	2812e <add_event+0x10>
	return list->head == list;
   2814e:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   28150:	42b4      	cmp	r4, r6
   28152:	d0ec      	beq.n	2812e <add_event+0x10>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   28154:	2e00      	cmp	r6, #0
   28156:	d0ea      	beq.n	2812e <add_event+0x10>
		if (z_is_t1_higher_prio_than_t2(poller->thread,
   28158:	68b3      	ldr	r3, [r6, #8]
   2815a:	6878      	ldr	r0, [r7, #4]
   2815c:	6859      	ldr	r1, [r3, #4]
   2815e:	f7ff fd69 	bl	27c34 <z_is_t1_higher_prio_than_t2>
   28162:	b128      	cbz	r0, 28170 <add_event+0x52>
	node->prev = successor->prev;
   28164:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   28166:	e9c5 6300 	strd	r6, r3, [r5]
	successor->prev->next = node;
   2816a:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   2816c:	6075      	str	r5, [r6, #4]
			return;
   2816e:	e7e4      	b.n	2813a <add_event+0x1c>
	return (node == list->tail) ? NULL : node->next;
   28170:	6863      	ldr	r3, [r4, #4]
   28172:	429e      	cmp	r6, r3
   28174:	d0db      	beq.n	2812e <add_event+0x10>
   28176:	6836      	ldr	r6, [r6, #0]
   28178:	e7ec      	b.n	28154 <add_event+0x36>

0002817a <register_events>:
{
   2817a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
   2817e:	f04f 0b00 	mov.w	fp, #0
{
   28182:	4688      	mov	r8, r1
   28184:	4615      	mov	r5, r2
   28186:	4699      	mov	r9, r3
   28188:	4604      	mov	r4, r0
	int events_registered = 0;
   2818a:	465e      	mov	r6, fp
	event->poller = NULL;
   2818c:	465f      	mov	r7, fp
	for (int ii = 0; ii < num_events; ii++) {
   2818e:	45c3      	cmp	fp, r8
   28190:	db02      	blt.n	28198 <register_events+0x1e>
}
   28192:	4630      	mov	r0, r6
   28194:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   28198:	f04f 0320 	mov.w	r3, #32
   2819c:	f3ef 8a11 	mrs	sl, BASEPRI
   281a0:	f383 8811 	msr	BASEPRI, r3
   281a4:	f3bf 8f6f 	isb	sy
	switch (event->type) {
   281a8:	7b63      	ldrb	r3, [r4, #13]
   281aa:	f003 030f 	and.w	r3, r3, #15
   281ae:	2b02      	cmp	r3, #2
   281b0:	d005      	beq.n	281be <register_events+0x44>
   281b2:	2b04      	cmp	r3, #4
   281b4:	d006      	beq.n	281c4 <register_events+0x4a>
   281b6:	2b01      	cmp	r3, #1
   281b8:	d118      	bne.n	281ec <register_events+0x72>
		if (event->signal->signaled != 0U) {
   281ba:	6922      	ldr	r2, [r4, #16]
   281bc:	e000      	b.n	281c0 <register_events+0x46>
		if (k_sem_count_get(event->sem) > 0) {
   281be:	6922      	ldr	r2, [r4, #16]
		if (event->signal->signaled != 0U) {
   281c0:	6892      	ldr	r2, [r2, #8]
   281c2:	e001      	b.n	281c8 <register_events+0x4e>
		if (!k_queue_is_empty(event->queue)) {
   281c4:	6922      	ldr	r2, [r4, #16]
   281c6:	6812      	ldr	r2, [r2, #0]
		if (event->signal->signaled != 0U) {
   281c8:	b182      	cbz	r2, 281ec <register_events+0x72>
	event->state |= state;
   281ca:	68e2      	ldr	r2, [r4, #12]
	event->poller = NULL;
   281cc:	60a7      	str	r7, [r4, #8]
	event->state |= state;
   281ce:	f3c2 3104 	ubfx	r1, r2, #12, #5
   281d2:	430b      	orrs	r3, r1
   281d4:	f363 3210 	bfi	r2, r3, #12, #5
   281d8:	60e2      	str	r2, [r4, #12]
			poller->is_polling = false;
   281da:	702f      	strb	r7, [r5, #0]
	__asm__ volatile(
   281dc:	f38a 8811 	msr	BASEPRI, sl
   281e0:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
   281e4:	f10b 0b01 	add.w	fp, fp, #1
   281e8:	3414      	adds	r4, #20
   281ea:	e7d0      	b.n	2818e <register_events+0x14>
		} else if (!just_check && poller->is_polling) {
   281ec:	f1b9 0f00 	cmp.w	r9, #0
   281f0:	d1f4      	bne.n	281dc <register_events+0x62>
   281f2:	782b      	ldrb	r3, [r5, #0]
   281f4:	2b00      	cmp	r3, #0
   281f6:	d0f1      	beq.n	281dc <register_events+0x62>
	switch (event->type) {
   281f8:	7b63      	ldrb	r3, [r4, #13]
   281fa:	f003 030f 	and.w	r3, r3, #15
   281fe:	2b02      	cmp	r3, #2
   28200:	d007      	beq.n	28212 <register_events+0x98>
   28202:	2b04      	cmp	r3, #4
   28204:	d00e      	beq.n	28224 <register_events+0xaa>
   28206:	2b01      	cmp	r3, #1
   28208:	d109      	bne.n	2821e <register_events+0xa4>
		add_event(&event->signal->poll_events, event, poller);
   2820a:	462a      	mov	r2, r5
   2820c:	4621      	mov	r1, r4
   2820e:	6920      	ldr	r0, [r4, #16]
   28210:	e003      	b.n	2821a <register_events+0xa0>
		add_event(&event->sem->poll_events, event, poller);
   28212:	6920      	ldr	r0, [r4, #16]
   28214:	462a      	mov	r2, r5
   28216:	4621      	mov	r1, r4
   28218:	3010      	adds	r0, #16
		add_event(&event->signal->poll_events, event, poller);
   2821a:	f7ff ff80 	bl	2811e <add_event>
	event->poller = poller;
   2821e:	60a5      	str	r5, [r4, #8]
				events_registered += 1;
   28220:	3601      	adds	r6, #1
   28222:	e7db      	b.n	281dc <register_events+0x62>
		add_event(&event->queue->poll_events, event, poller);
   28224:	6920      	ldr	r0, [r4, #16]
   28226:	462a      	mov	r2, r5
   28228:	4621      	mov	r1, r4
   2822a:	300c      	adds	r0, #12
   2822c:	e7f5      	b.n	2821a <register_events+0xa0>

0002822e <z_handle_obj_poll_events>:
	return list->head == list;
   2822e:	6803      	ldr	r3, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
   28230:	4298      	cmp	r0, r3
   28232:	d009      	beq.n	28248 <z_handle_obj_poll_events+0x1a>
	node->prev->next = node->next;
   28234:	e9d3 2000 	ldrd	r2, r0, [r3]
   28238:	6002      	str	r2, [r0, #0]
	node->next->prev = node->prev;
   2823a:	6050      	str	r0, [r2, #4]
	node->next = NULL;
   2823c:	2200      	movs	r2, #0
	node->prev = NULL;
   2823e:	e9c3 2200 	strd	r2, r2, [r3]
		(void) signal_poll_event(poll_event, state);
   28242:	4618      	mov	r0, r3
   28244:	f7ff bf2e 	b.w	280a4 <signal_poll_event>
}
   28248:	4770      	bx	lr

0002824a <_OffsetAbsSyms>:
					    sizeof(struct _preempt_float));
#else
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF, sizeof(struct k_thread));
#endif

GEN_ABS_SYM_END
   2824a:	4770      	bx	lr
