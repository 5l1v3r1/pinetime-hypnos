
zephyr.elf:     file format elf32-littlearm


Disassembly of section text:

00000000 <_vector_table>:

	return fd_entry->obj;
}

int z_reserve_fd(void)
{
   0:	20003770 	.word	0x20003770
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&mutex, *(uintptr_t *)&timeout, K_SYSCALL_K_MUTEX_LOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_lock(mutex, timeout);
   4:	000045cd 	.word	0x000045cd
   8:	0001ae53 	.word	0x0001ae53
		if (fdtable[fd].obj == NULL) {
   c:	000044a1 	.word	0x000044a1
  10:	000044a1 	.word	0x000044a1
  14:	000044a1 	.word	0x000044a1
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
  18:	000044a1 	.word	0x000044a1
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
  1c:	000044a1 	.word	0x000044a1
	errno = ENFILE;
  20:	000044a1 	.word	0x000044a1
	return -1;
  24:	000044a1 	.word	0x000044a1
		arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_mutex_unlock(mutex);
  28:	000044a1 	.word	0x000044a1
  2c:	00004339 	.word	0x00004339
	}

	k_mutex_unlock(&fdtable_lock);

	return fd;
}
  30:	000044a1 	.word	0x000044a1
		fdtable[fd].obj = FD_OBJ_RESERVED;
  34:	000044a1 	.word	0x000044a1
  38:	000042e5 	.word	0x000042e5
  3c:	0001ae43 	.word	0x0001ae43

00000040 <_irq_vector_table>:
  40:	0000458d 0001d38b 0000458d 0000458d     .E.......E...E..
		sys_pm_notify_power_state_exit(pm_state);
		_sys_pm_power_state_exit_post_ops(pm_state);
	}

	return pm_state;
}
  50:	0000458d 0000458d 0000458d 0000458d     .E...E...E...E..
  60:	0000458d 0000458d 0000458d 0000458d     .E...E...E...E..
  70:	0000458d 0000458d 0000458d 0000458d     .E...E...E...E..
  80:	0000458d 0000458d 0000458d 0000458d     .E...E...E...E..
  90:	0000458d 0000458d 0000458d 0000458d     .E...E...E...E..
  a0:	0000458d 0000458d 0000458d 0000458d     .E...E...E...E..
  b0:	0000458d 0000458d 0000458d 0000458d     .E...E...E...E..
  c0:	0000458d 0000458d 0000458d 0000458d     .E...E...E...E..
  d0:	0000458d 0000458d 0000458d              .E...E...E..

Disassembly of section _TEXT_SECTION_NAME_2:

000000e0 <__aeabi_uldivmod>:
      e0:	b953      	cbnz	r3, f8 <__aeabi_uldivmod+0x18>
      e2:	b94a      	cbnz	r2, f8 <__aeabi_uldivmod+0x18>
      e4:	2900      	cmp	r1, #0
      e6:	bf08      	it	eq
      e8:	2800      	cmpeq	r0, #0
      ea:	bf1c      	itt	ne
      ec:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
      f0:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
      f4:	f000 b80c 	b.w	110 <__aeabi_idiv0>
      f8:	f1ad 0c08 	sub.w	ip, sp, #8
      fc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     100:	f000 f808 	bl	114 <__udivmoddi4>
     104:	f8dd e004 	ldr.w	lr, [sp, #4]
     108:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     10c:	b004      	add	sp, #16
     10e:	4770      	bx	lr

00000110 <__aeabi_idiv0>:
     110:	4770      	bx	lr
     112:	bf00      	nop

00000114 <__udivmoddi4>:
     114:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     118:	9f09      	ldr	r7, [sp, #36]	; 0x24
     11a:	4615      	mov	r5, r2
     11c:	4604      	mov	r4, r0
     11e:	468e      	mov	lr, r1
     120:	461e      	mov	r6, r3
     122:	2b00      	cmp	r3, #0
     124:	f040 80cc 	bne.w	2c0 <CONFIG_BT_HCI_TX_STACK_SIZE+0x40>
     128:	428a      	cmp	r2, r1
     12a:	fab2 fc82 	clz	ip, r2
     12e:	d94c      	bls.n	1ca <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0xa>
     130:	f1bc 0f00 	cmp.w	ip, #0
     134:	d00b      	beq.n	14e <CONFIG_IDLE_STACK_SIZE+0xe>
     136:	f1cc 0820 	rsb	r8, ip, #32
     13a:	fa01 fe0c 	lsl.w	lr, r1, ip
     13e:	fa20 f808 	lsr.w	r8, r0, r8
     142:	fa02 f50c 	lsl.w	r5, r2, ip
     146:	ea48 0e0e 	orr.w	lr, r8, lr
     14a:	fa00 f40c 	lsl.w	r4, r0, ip
     14e:	ea4f 4915 	mov.w	r9, r5, lsr #16
     152:	fa1f f885 	uxth.w	r8, r5
     156:	fbbe faf9 	udiv	sl, lr, r9
     15a:	0c21      	lsrs	r1, r4, #16
     15c:	fb09 e31a 	mls	r3, r9, sl, lr
     160:	fb0a fb08 	mul.w	fp, sl, r8
     164:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
     168:	459b      	cmp	fp, r3
     16a:	d92a      	bls.n	1c2 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x2>
     16c:	18eb      	adds	r3, r5, r3
     16e:	f10a 30ff 	add.w	r0, sl, #4294967295	; 0xffffffff
     172:	d204      	bcs.n	17e <CONFIG_IDLE_STACK_SIZE+0x3e>
     174:	459b      	cmp	fp, r3
     176:	d902      	bls.n	17e <CONFIG_IDLE_STACK_SIZE+0x3e>
     178:	f1aa 0002 	sub.w	r0, sl, #2
     17c:	442b      	add	r3, r5
     17e:	eba3 030b 	sub.w	r3, r3, fp
     182:	b2a4      	uxth	r4, r4
     184:	fbb3 f2f9 	udiv	r2, r3, r9
     188:	fb09 3312 	mls	r3, r9, r2, r3
     18c:	fb02 f808 	mul.w	r8, r2, r8
     190:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     194:	45a0      	cmp	r8, r4
     196:	d916      	bls.n	1c6 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x6>
     198:	192c      	adds	r4, r5, r4
     19a:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
     19e:	d203      	bcs.n	1a8 <CONFIG_IDLE_STACK_SIZE+0x68>
     1a0:	45a0      	cmp	r8, r4
     1a2:	d901      	bls.n	1a8 <CONFIG_IDLE_STACK_SIZE+0x68>
     1a4:	1e93      	subs	r3, r2, #2
     1a6:	442c      	add	r4, r5
     1a8:	eba4 0408 	sub.w	r4, r4, r8
     1ac:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
     1b0:	b127      	cbz	r7, 1bc <CONFIG_IDLE_STACK_SIZE+0x7c>
     1b2:	fa24 f40c 	lsr.w	r4, r4, ip
     1b6:	2300      	movs	r3, #0
     1b8:	603c      	str	r4, [r7, #0]
     1ba:	607b      	str	r3, [r7, #4]
     1bc:	4631      	mov	r1, r6
     1be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     1c2:	4650      	mov	r0, sl
     1c4:	e7db      	b.n	17e <CONFIG_IDLE_STACK_SIZE+0x3e>
     1c6:	4613      	mov	r3, r2
     1c8:	e7ee      	b.n	1a8 <CONFIG_IDLE_STACK_SIZE+0x68>
     1ca:	b902      	cbnz	r2, 1ce <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0xe>
     1cc:	deff      	udf	#255	; 0xff
     1ce:	f1bc 0f00 	cmp.w	ip, #0
     1d2:	d12e      	bne.n	232 <CONFIG_FLASH_SIZE+0x32>
     1d4:	1a8b      	subs	r3, r1, r2
     1d6:	2601      	movs	r6, #1
     1d8:	ea4f 4e15 	mov.w	lr, r5, lsr #16
     1dc:	b2aa      	uxth	r2, r5
     1de:	fbb3 f8fe 	udiv	r8, r3, lr
     1e2:	0c21      	lsrs	r1, r4, #16
     1e4:	fb0e 3318 	mls	r3, lr, r8, r3
     1e8:	fb08 f902 	mul.w	r9, r8, r2
     1ec:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
     1f0:	4599      	cmp	r9, r3
     1f2:	d961      	bls.n	2b8 <CONFIG_BT_HCI_TX_STACK_SIZE+0x38>
     1f4:	18eb      	adds	r3, r5, r3
     1f6:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
     1fa:	d204      	bcs.n	206 <CONFIG_FLASH_SIZE+0x6>
     1fc:	4599      	cmp	r9, r3
     1fe:	d902      	bls.n	206 <CONFIG_FLASH_SIZE+0x6>
     200:	f1a8 0002 	sub.w	r0, r8, #2
     204:	442b      	add	r3, r5
     206:	eba3 0309 	sub.w	r3, r3, r9
     20a:	b2a4      	uxth	r4, r4
     20c:	fbb3 f1fe 	udiv	r1, r3, lr
     210:	fb0e 3311 	mls	r3, lr, r1, r3
     214:	434a      	muls	r2, r1
     216:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     21a:	42a2      	cmp	r2, r4
     21c:	d94e      	bls.n	2bc <CONFIG_BT_HCI_TX_STACK_SIZE+0x3c>
     21e:	192c      	adds	r4, r5, r4
     220:	f101 33ff 	add.w	r3, r1, #4294967295	; 0xffffffff
     224:	d203      	bcs.n	22e <CONFIG_FLASH_SIZE+0x2e>
     226:	42a2      	cmp	r2, r4
     228:	d901      	bls.n	22e <CONFIG_FLASH_SIZE+0x2e>
     22a:	1e8b      	subs	r3, r1, #2
     22c:	442c      	add	r4, r5
     22e:	1aa4      	subs	r4, r4, r2
     230:	e7bc      	b.n	1ac <CONFIG_IDLE_STACK_SIZE+0x6c>
     232:	f1cc 0e20 	rsb	lr, ip, #32
     236:	fa02 f50c 	lsl.w	r5, r2, ip
     23a:	fa21 f90e 	lsr.w	r9, r1, lr
     23e:	fa01 f30c 	lsl.w	r3, r1, ip
     242:	fa20 fe0e 	lsr.w	lr, r0, lr
     246:	ea4e 0303 	orr.w	r3, lr, r3
     24a:	ea4f 4815 	mov.w	r8, r5, lsr #16
     24e:	fa00 f40c 	lsl.w	r4, r0, ip
     252:	fbb9 f1f8 	udiv	r1, r9, r8
     256:	fa1f fe85 	uxth.w	lr, r5
     25a:	fb08 9211 	mls	r2, r8, r1, r9
     25e:	0c18      	lsrs	r0, r3, #16
     260:	fb01 f60e 	mul.w	r6, r1, lr
     264:	ea40 4202 	orr.w	r2, r0, r2, lsl #16
     268:	4296      	cmp	r6, r2
     26a:	d921      	bls.n	2b0 <CONFIG_BT_HCI_TX_STACK_SIZE+0x30>
     26c:	18aa      	adds	r2, r5, r2
     26e:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
     272:	d203      	bcs.n	27c <CONFIG_FLASH_SIZE+0x7c>
     274:	4296      	cmp	r6, r2
     276:	d901      	bls.n	27c <CONFIG_FLASH_SIZE+0x7c>
     278:	1e88      	subs	r0, r1, #2
     27a:	442a      	add	r2, r5
     27c:	1b92      	subs	r2, r2, r6
     27e:	b29b      	uxth	r3, r3
     280:	fbb2 f9f8 	udiv	r9, r2, r8
     284:	fb08 2219 	mls	r2, r8, r9, r2
     288:	fb09 fe0e 	mul.w	lr, r9, lr
     28c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
     290:	459e      	cmp	lr, r3
     292:	d90f      	bls.n	2b4 <CONFIG_BT_HCI_TX_STACK_SIZE+0x34>
     294:	18eb      	adds	r3, r5, r3
     296:	f109 36ff 	add.w	r6, r9, #4294967295	; 0xffffffff
     29a:	d204      	bcs.n	2a6 <CONFIG_BT_HCI_TX_STACK_SIZE+0x26>
     29c:	459e      	cmp	lr, r3
     29e:	d902      	bls.n	2a6 <CONFIG_BT_HCI_TX_STACK_SIZE+0x26>
     2a0:	f1a9 0602 	sub.w	r6, r9, #2
     2a4:	442b      	add	r3, r5
     2a6:	eba3 030e 	sub.w	r3, r3, lr
     2aa:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     2ae:	e793      	b.n	1d8 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x18>
     2b0:	4608      	mov	r0, r1
     2b2:	e7e3      	b.n	27c <CONFIG_FLASH_SIZE+0x7c>
     2b4:	464e      	mov	r6, r9
     2b6:	e7f6      	b.n	2a6 <CONFIG_BT_HCI_TX_STACK_SIZE+0x26>
     2b8:	4640      	mov	r0, r8
     2ba:	e7a4      	b.n	206 <CONFIG_FLASH_SIZE+0x6>
     2bc:	460b      	mov	r3, r1
     2be:	e7b6      	b.n	22e <CONFIG_FLASH_SIZE+0x2e>
     2c0:	428b      	cmp	r3, r1
     2c2:	d905      	bls.n	2d0 <CONFIG_BT_HCI_TX_STACK_SIZE+0x50>
     2c4:	b10f      	cbz	r7, 2ca <CONFIG_BT_HCI_TX_STACK_SIZE+0x4a>
     2c6:	e9c7 0100 	strd	r0, r1, [r7]
     2ca:	2600      	movs	r6, #0
     2cc:	4630      	mov	r0, r6
     2ce:	e775      	b.n	1bc <CONFIG_IDLE_STACK_SIZE+0x7c>
     2d0:	fab3 fc83 	clz	ip, r3
     2d4:	f1bc 0f00 	cmp.w	ip, #0
     2d8:	d10f      	bne.n	2fa <CONFIG_BT_HCI_TX_STACK_SIZE+0x7a>
     2da:	428b      	cmp	r3, r1
     2dc:	d301      	bcc.n	2e2 <CONFIG_BT_HCI_TX_STACK_SIZE+0x62>
     2de:	4282      	cmp	r2, r0
     2e0:	d809      	bhi.n	2f6 <CONFIG_BT_HCI_TX_STACK_SIZE+0x76>
     2e2:	1a84      	subs	r4, r0, r2
     2e4:	eb61 0e03 	sbc.w	lr, r1, r3
     2e8:	2001      	movs	r0, #1
     2ea:	2f00      	cmp	r7, #0
     2ec:	d06a      	beq.n	3c4 <CONFIG_BT_RPA_TIMEOUT+0x40>
     2ee:	e9c7 4e00 	strd	r4, lr, [r7]
     2f2:	2600      	movs	r6, #0
     2f4:	e762      	b.n	1bc <CONFIG_IDLE_STACK_SIZE+0x7c>
     2f6:	4660      	mov	r0, ip
     2f8:	e7f7      	b.n	2ea <CONFIG_BT_HCI_TX_STACK_SIZE+0x6a>
     2fa:	f1cc 0e20 	rsb	lr, ip, #32
     2fe:	fa03 f30c 	lsl.w	r3, r3, ip
     302:	fa22 f50e 	lsr.w	r5, r2, lr
     306:	fa21 f40e 	lsr.w	r4, r1, lr
     30a:	431d      	orrs	r5, r3
     30c:	fa01 f30c 	lsl.w	r3, r1, ip
     310:	fa20 f10e 	lsr.w	r1, r0, lr
     314:	430b      	orrs	r3, r1
     316:	ea4f 4a15 	mov.w	sl, r5, lsr #16
     31a:	fa00 f60c 	lsl.w	r6, r0, ip
     31e:	fbb4 f9fa 	udiv	r9, r4, sl
     322:	fa1f f885 	uxth.w	r8, r5
     326:	fb0a 4019 	mls	r0, sl, r9, r4
     32a:	0c1c      	lsrs	r4, r3, #16
     32c:	fb09 f108 	mul.w	r1, r9, r8
     330:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
     334:	42a1      	cmp	r1, r4
     336:	fa02 f20c 	lsl.w	r2, r2, ip
     33a:	d93f      	bls.n	3bc <CONFIG_BT_RPA_TIMEOUT+0x38>
     33c:	192c      	adds	r4, r5, r4
     33e:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
     342:	d204      	bcs.n	34e <CONFIG_BT_DEVICE_APPEARANCE+0xd>
     344:	42a1      	cmp	r1, r4
     346:	d902      	bls.n	34e <CONFIG_BT_DEVICE_APPEARANCE+0xd>
     348:	f1a9 0002 	sub.w	r0, r9, #2
     34c:	442c      	add	r4, r5
     34e:	1a64      	subs	r4, r4, r1
     350:	b29b      	uxth	r3, r3
     352:	fbb4 f9fa 	udiv	r9, r4, sl
     356:	fb0a 4419 	mls	r4, sl, r9, r4
     35a:	fb09 f808 	mul.w	r8, r9, r8
     35e:	ea43 4104 	orr.w	r1, r3, r4, lsl #16
     362:	4588      	cmp	r8, r1
     364:	d92c      	bls.n	3c0 <CONFIG_BT_RPA_TIMEOUT+0x3c>
     366:	1869      	adds	r1, r5, r1
     368:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
     36c:	d204      	bcs.n	378 <CONFIG_BT_DEVICE_APPEARANCE+0x37>
     36e:	4588      	cmp	r8, r1
     370:	d902      	bls.n	378 <CONFIG_BT_DEVICE_APPEARANCE+0x37>
     372:	f1a9 0302 	sub.w	r3, r9, #2
     376:	4429      	add	r1, r5
     378:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
     37c:	eba1 0108 	sub.w	r1, r1, r8
     380:	fba0 8902 	umull	r8, r9, r0, r2
     384:	4549      	cmp	r1, r9
     386:	46c2      	mov	sl, r8
     388:	464c      	mov	r4, r9
     38a:	d302      	bcc.n	392 <CONFIG_BT_RPA_TIMEOUT+0xe>
     38c:	d106      	bne.n	39c <CONFIG_BT_RPA_TIMEOUT+0x18>
     38e:	4546      	cmp	r6, r8
     390:	d204      	bcs.n	39c <CONFIG_BT_RPA_TIMEOUT+0x18>
     392:	ebb8 0a02 	subs.w	sl, r8, r2
     396:	eb69 0405 	sbc.w	r4, r9, r5
     39a:	3801      	subs	r0, #1
     39c:	b197      	cbz	r7, 3c4 <CONFIG_BT_RPA_TIMEOUT+0x40>
     39e:	ebb6 030a 	subs.w	r3, r6, sl
     3a2:	eb61 0604 	sbc.w	r6, r1, r4
     3a6:	fa06 fe0e 	lsl.w	lr, r6, lr
     3aa:	fa23 f30c 	lsr.w	r3, r3, ip
     3ae:	ea4e 0303 	orr.w	r3, lr, r3
     3b2:	fa26 f60c 	lsr.w	r6, r6, ip
     3b6:	e9c7 3600 	strd	r3, r6, [r7]
     3ba:	e79a      	b.n	2f2 <CONFIG_BT_HCI_TX_STACK_SIZE+0x72>
     3bc:	4648      	mov	r0, r9
     3be:	e7c6      	b.n	34e <CONFIG_BT_DEVICE_APPEARANCE+0xd>
     3c0:	464b      	mov	r3, r9
     3c2:	e7d9      	b.n	378 <CONFIG_BT_DEVICE_APPEARANCE+0x37>
     3c4:	463e      	mov	r6, r7
     3c6:	e6f9      	b.n	1bc <CONFIG_IDLE_STACK_SIZE+0x7c>

000003c8 <bt_init>:

	bt_dev_show_info();
}

static int bt_init(void)
{
     3c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
     3cc:	4d45      	ldr	r5, [pc, #276]	; (4e4 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x98>)
     3ce:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
     3d2:	6899      	ldr	r1, [r3, #8]
     3d4:	f011 0101 	ands.w	r1, r1, #1
{
     3d8:	b086      	sub	sp, #24
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
     3da:	d121      	bne.n	420 <CONFIG_LOG_BUFFER_SIZE+0x20>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
     3dc:	aa01      	add	r2, sp, #4
     3de:	f640 4003 	movw	r0, #3075	; 0xc03
     3e2:	f005 fe97 	bl	6114 <bt_hci_cmd_send_sync>
		if (err) {
     3e6:	4604      	mov	r4, r0
     3e8:	2800      	cmp	r0, #0
     3ea:	d177      	bne.n	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
		hci_reset_complete(rsp);
     3ec:	9b01      	ldr	r3, [sp, #4]
	u8_t status = buf->data[0];
     3ee:	689b      	ldr	r3, [r3, #8]
	if (status) {
     3f0:	781b      	ldrb	r3, [r3, #0]
     3f2:	b993      	cbnz	r3, 41a <CONFIG_LOG_BUFFER_SIZE+0x1a>
 * @return Value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_get(const atomic_t *target)
{
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
     3f4:	f3bf 8f5b 	dmb	ish
     3f8:	462b      	mov	r3, r5
     3fa:	f853 2f70 	ldr.w	r2, [r3, #112]!
     3fe:	f3bf 8f5b 	dmb	ish
	flags = (atomic_get(bt_dev.flags) & BT_DEV_PERSISTENT_FLAGS);
     402:	f002 0205 	and.w	r2, r2, #5
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
     406:	f3bf 8f5b 	dmb	ish
     40a:	e853 1f00 	ldrex	r1, [r3]
     40e:	e843 2000 	strex	r0, r2, [r3]
     412:	2800      	cmp	r0, #0
     414:	d1f9      	bne.n	40a <CONFIG_LOG_BUFFER_SIZE+0xa>
     416:	f3bf 8f5b 	dmb	ish
		net_buf_unref(rsp);
     41a:	9801      	ldr	r0, [sp, #4]
     41c:	f016 f880 	bl	16520 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
     420:	aa01      	add	r2, sp, #4
     422:	2100      	movs	r1, #0
     424:	f241 0003 	movw	r0, #4099	; 0x1003
     428:	f005 fe74 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
     42c:	4604      	mov	r4, r0
     42e:	2800      	cmp	r0, #0
     430:	d154      	bne.n	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
	read_local_features_complete(rsp);
     432:	9b01      	ldr	r3, [sp, #4]
	memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
     434:	482c      	ldr	r0, [pc, #176]	; (4e8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x9c>)
     436:	6899      	ldr	r1, [r3, #8]
     438:	2208      	movs	r2, #8
     43a:	3101      	adds	r1, #1
     43c:	f01a fddd 	bl	1affa <memcpy>
	net_buf_unref(rsp);
     440:	9801      	ldr	r0, [sp, #4]
     442:	f016 f86d 	bl	16520 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
     446:	4621      	mov	r1, r4
     448:	aa01      	add	r2, sp, #4
     44a:	f241 0001 	movw	r0, #4097	; 0x1001
     44e:	f005 fe61 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
     452:	4604      	mov	r4, r0
     454:	2800      	cmp	r0, #0
     456:	d141      	bne.n	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
	read_local_ver_complete(rsp);
     458:	9801      	ldr	r0, [sp, #4]
     45a:	6883      	ldr	r3, [r0, #8]
	bt_dev.hci_version = rp->hci_version;
     45c:	785a      	ldrb	r2, [r3, #1]
     45e:	742a      	strb	r2, [r5, #16]
	bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
     460:	78d9      	ldrb	r1, [r3, #3]
     462:	789a      	ldrb	r2, [r3, #2]
     464:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
     468:	826a      	strh	r2, [r5, #18]
	bt_dev.lmp_version = rp->lmp_version;
     46a:	791a      	ldrb	r2, [r3, #4]
     46c:	746a      	strb	r2, [r5, #17]
	bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
     46e:	7a19      	ldrb	r1, [r3, #8]
     470:	79da      	ldrb	r2, [r3, #7]
     472:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
     476:	82aa      	strh	r2, [r5, #20]
	bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
     478:	795a      	ldrb	r2, [r3, #5]
     47a:	799b      	ldrb	r3, [r3, #6]
     47c:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
     480:	82eb      	strh	r3, [r5, #22]
	net_buf_unref(rsp);
     482:	f016 f84d 	bl	16520 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
     486:	4621      	mov	r1, r4
     488:	aa01      	add	r2, sp, #4
     48a:	f241 0002 	movw	r0, #4098	; 0x1002
     48e:	f005 fe41 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
     492:	4604      	mov	r4, r0
     494:	bb10      	cbnz	r0, 4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
	read_supported_commands_complete(rsp);
     496:	9b01      	ldr	r3, [sp, #4]
	memcpy(bt_dev.supported_commands, rp->commands,
     498:	4814      	ldr	r0, [pc, #80]	; (4ec <CONFIG_BT_HCI_ECC_STACK_SIZE+0xa0>)
     49a:	6899      	ldr	r1, [r3, #8]
     49c:	2240      	movs	r2, #64	; 0x40
     49e:	3101      	adds	r1, #1
     4a0:	f01a fdab 	bl	1affa <memcpy>
		bt_dev.supported_commands[34] |= 0x04;
     4a4:	f895 3042 	ldrb.w	r3, [r5, #66]	; 0x42
	net_buf_unref(rsp);
     4a8:	9801      	ldr	r0, [sp, #4]
		bt_dev.supported_commands[34] |= 0x04;
     4aa:	f043 0306 	orr.w	r3, r3, #6
     4ae:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
	net_buf_unref(rsp);
     4b2:	f016 f835 	bl	16520 <net_buf_unref>
	if (!BT_FEAT_LE(bt_dev.features)) {
     4b6:	7f2b      	ldrb	r3, [r5, #28]
     4b8:	0659      	lsls	r1, r3, #25
     4ba:	d41f      	bmi.n	4fc <CONFIG_BT_HCI_ECC_STACK_SIZE+0xb0>
		BT_ERR("Non-LE capable controller detected!");
     4bc:	2301      	movs	r3, #1
     4be:	f04f 0100 	mov.w	r1, #0
     4c2:	f363 0107 	bfi	r1, r3, #0, #8
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
     4c6:	4a0a      	ldr	r2, [pc, #40]	; (4f0 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xa4>)
     4c8:	4b0a      	ldr	r3, [pc, #40]	; (4f4 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xa8>)
     4ca:	480b      	ldr	r0, [pc, #44]	; (4f8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xac>)
     4cc:	1a9b      	subs	r3, r3, r2
     4ce:	08db      	lsrs	r3, r3, #3
     4d0:	f363 118f 	bfi	r1, r3, #6, #10
     4d4:	f01a f89d 	bl	1a612 <log_0>
		return -ENODEV;
     4d8:	f06f 0412 	mvn.w	r4, #18
		atomic_set_bit(bt_dev.flags, BT_DEV_PRESET_ID);
	}

	bt_finalize_init();
	return 0;
}
     4dc:	4620      	mov	r0, r4
     4de:	b006      	add	sp, #24
     4e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     4e4:	20005438 	.word	0x20005438
     4e8:	20005450 	.word	0x20005450
     4ec:	20005458 	.word	0x20005458
     4f0:	0001ed28 	.word	0x0001ed28
     4f4:	0001ede8 	.word	0x0001ede8
     4f8:	00020545 	.word	0x00020545
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
     4fc:	4621      	mov	r1, r4
     4fe:	aa01      	add	r2, sp, #4
     500:	f242 0003 	movw	r0, #8195	; 0x2003
     504:	f005 fe06 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
     508:	4604      	mov	r4, r0
     50a:	2800      	cmp	r0, #0
     50c:	d1e6      	bne.n	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
	read_le_features_complete(rsp);
     50e:	9b01      	ldr	r3, [sp, #4]
	memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
     510:	48bd      	ldr	r0, [pc, #756]	; (808 <CONFIG_ISR_STACK_SIZE+0x8>)
     512:	6899      	ldr	r1, [r3, #8]
     514:	2208      	movs	r2, #8
     516:	3101      	adds	r1, #1
     518:	f01a fd6f 	bl	1affa <memcpy>
	net_buf_unref(rsp);
     51c:	9801      	ldr	r0, [sp, #4]
     51e:	f015 ffff 	bl	16520 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE,
     522:	4621      	mov	r1, r4
     524:	aa01      	add	r2, sp, #4
     526:	f242 0002 	movw	r0, #8194	; 0x2002
     52a:	f005 fdf3 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
     52e:	4604      	mov	r4, r0
     530:	2800      	cmp	r0, #0
     532:	d1d3      	bne.n	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
	le_read_buffer_size_complete(rsp);
     534:	9b01      	ldr	r3, [sp, #4]
     536:	689b      	ldr	r3, [r3, #8]
	bt_dev.le.mtu = sys_le16_to_cpu(rp->le_max_len);
     538:	f8b3 2001 	ldrh.w	r2, [r3, #1]
     53c:	f8a5 2088 	strh.w	r2, [r5, #136]	; 0x88
     540:	b291      	uxth	r1, r2
	if (!bt_dev.le.mtu) {
     542:	b121      	cbz	r1, 54e <CONFIG_BT_HCI_ECC_STACK_SIZE+0x102>
	k_sem_init(&bt_dev.le.pkts, rp->le_max_num, rp->le_max_num);
     544:	78da      	ldrb	r2, [r3, #3]
		arch_syscall_invoke3(*(uintptr_t *)&sem, *(uintptr_t *)&initial_count, *(uintptr_t *)&limit, K_SYSCALL_K_SEM_INIT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_init(sem, initial_count, limit);
     546:	48b1      	ldr	r0, [pc, #708]	; (80c <CONFIG_ISR_STACK_SIZE+0xc>)
     548:	4611      	mov	r1, r2
     54a:	f01e f881 	bl	1e650 <z_impl_k_sem_init>
	net_buf_unref(rsp);
     54e:	9801      	ldr	r0, [sp, #4]
     550:	f015 ffe6 	bl	16520 <net_buf_unref>
	if (BT_FEAT_BREDR(bt_dev.features)) {
     554:	7f2c      	ldrb	r4, [r5, #28]
     556:	f014 0420 	ands.w	r4, r4, #32
     55a:	f000 80d5 	beq.w	708 <CONFIG_BT_COMPANY_ID+0x117>
	if (BT_CMD_LE_STATES(bt_dev.supported_commands)) {
     55e:	f895 303c 	ldrb.w	r3, [r5, #60]	; 0x3c
     562:	071a      	lsls	r2, r3, #28
     564:	d511      	bpl.n	58a <CONFIG_BT_HCI_ECC_STACK_SIZE+0x13e>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
     566:	aa01      	add	r2, sp, #4
     568:	2100      	movs	r1, #0
     56a:	f242 001c 	movw	r0, #8220	; 0x201c
     56e:	f005 fdd1 	bl	6114 <bt_hci_cmd_send_sync>
		if (err) {
     572:	4604      	mov	r4, r0
     574:	2800      	cmp	r0, #0
     576:	d1b1      	bne.n	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
		le_read_supp_states_complete(rsp);
     578:	9801      	ldr	r0, [sp, #4]
 *
 *  @return 64-bit integer in host endianness.
 */
static inline u64_t sys_get_le64(const u8_t src[8])
{
	return ((u64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
     57a:	6883      	ldr	r3, [r0, #8]
     57c:	f853 2f01 	ldr.w	r2, [r3, #1]!
     580:	685b      	ldr	r3, [r3, #4]
	bt_dev.le.states = sys_get_le64(rp->le_states);
     582:	e9c5 2320 	strd	r2, r3, [r5, #128]	; 0x80
		net_buf_unref(rsp);
     586:	f015 ffcb 	bl	16520 <net_buf_unref>
	if (IS_ENABLED(CONFIG_BT_CONN) &&
     58a:	f895 3078 	ldrb.w	r3, [r5, #120]	; 0x78
     58e:	069b      	lsls	r3, r3, #26
     590:	f100 80d6 	bmi.w	740 <CONFIG_BT_COMPANY_ID+0x14f>
	if (BT_FEAT_LE_PRIVACY(bt_dev.le.features)) {
     594:	f895 3078 	ldrb.w	r3, [r5, #120]	; 0x78
     598:	065f      	lsls	r7, r3, #25
     59a:	f100 80fd 	bmi.w	798 <CONFIG_BT_COMPANY_ID+0x1a7>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
     59e:	2108      	movs	r1, #8
     5a0:	f242 0001 	movw	r0, #8193	; 0x2001
     5a4:	f005 fc48 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
     5a8:	4604      	mov	r4, r0
     5aa:	2800      	cmp	r0, #0
     5ac:	f000 80b3 	beq.w	716 <CONFIG_BT_COMPANY_ID+0x125>
	cp_mask = net_buf_add(buf, sizeof(*cp_mask));
     5b0:	2108      	movs	r1, #8
     5b2:	4408      	add	r0, r1
     5b4:	f01d fb4a 	bl	1dc4c <net_buf_simple_add>
		    BT_FEAT_LE_PRIVACY(bt_dev.le.features)) {
     5b8:	f895 1078 	ldrb.w	r1, [r5, #120]	; 0x78
			mask |= BT_EVT_MASK_LE_CONN_COMPLETE;
     5bc:	f011 0f40 	tst.w	r1, #64	; 0x40
     5c0:	f240 2302 	movw	r3, #514	; 0x202
     5c4:	bf08      	it	eq
     5c6:	2303      	moveq	r3, #3
		if (BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features)) {
     5c8:	078e      	lsls	r6, r1, #30
			mask |= BT_EVT_MASK_LE_CONN_PARAM_REQ;
     5ca:	bf4c      	ite	mi
     5cc:	f043 032c 	orrmi.w	r3, r3, #44	; 0x2c
		mask |= BT_EVT_MASK_LE_REMOTE_FEAT_COMPLETE;
     5d0:	f043 030c 	orrpl.w	r3, r3, #12
	cp_mask = net_buf_add(buf, sizeof(*cp_mask));
     5d4:	4602      	mov	r2, r0
		if (IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
     5d6:	0688      	lsls	r0, r1, #26
		if (IS_ENABLED(CONFIG_BT_PHY_UPDATE) &&
     5d8:	f895 0079 	ldrb.w	r0, [r5, #121]	; 0x79
			mask |= BT_EVT_MASK_LE_DATA_LEN_CHANGE;
     5dc:	bf48      	it	mi
     5de:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
		if (IS_ENABLED(CONFIG_BT_PHY_UPDATE) &&
     5e2:	f010 0f09 	tst.w	r0, #9
			mask |= BT_EVT_MASK_LE_PHY_UPDATE_COMPLETE;
     5e6:	bf18      	it	ne
     5e8:	f443 6300 	orrne.w	r3, r3, #2048	; 0x800
	if (IS_ENABLED(CONFIG_BT_SMP) &&
     5ec:	07c9      	lsls	r1, r1, #31
	if (IS_ENABLED(CONFIG_BT_ECC) &&
     5ee:	f895 1042 	ldrb.w	r1, [r5, #66]	; 0x42
     5f2:	f001 0106 	and.w	r1, r1, #6
		mask |= BT_EVT_MASK_LE_LTK_REQUEST;
     5f6:	bf48      	it	mi
     5f8:	f043 0310 	orrmi.w	r3, r3, #16
	if (IS_ENABLED(CONFIG_BT_ECC) &&
     5fc:	2906      	cmp	r1, #6
		mask |= BT_EVT_MASK_LE_GENERATE_DHKEY_COMPLETE;
     5fe:	bf08      	it	eq
     600:	f443 73c0 	orreq.w	r3, r3, #384	; 0x180
	sys_put_le64(mask, cp_mask->events);
     604:	4618      	mov	r0, r3
     606:	2100      	movs	r1, #0
     608:	f01a fea4 	bl	1b354 <sys_put_le64>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
     60c:	4621      	mov	r1, r4
     60e:	2200      	movs	r2, #0
     610:	f242 0001 	movw	r0, #8193	; 0x2001
     614:	f005 fd7e 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
     618:	4604      	mov	r4, r0
     61a:	2800      	cmp	r0, #0
     61c:	f47f af5e 	bne.w	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
	if (BT_FEAT_BREDR(bt_dev.features)) {
     620:	7f2b      	ldrb	r3, [r5, #28]
     622:	069a      	lsls	r2, r3, #26
     624:	d41e      	bmi.n	664 <CONFIG_BT_COMPANY_ID+0x73>
	if (bt_dev.le.mtu) {
     626:	f8b5 1088 	ldrh.w	r1, [r5, #136]	; 0x88
     62a:	b9d9      	cbnz	r1, 664 <CONFIG_BT_COMPANY_ID+0x73>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BUFFER_SIZE, NULL, &rsp);
     62c:	aa01      	add	r2, sp, #4
     62e:	f241 0005 	movw	r0, #4101	; 0x1005
     632:	f005 fd6f 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
     636:	4604      	mov	r4, r0
     638:	2800      	cmp	r0, #0
     63a:	f47f af4f 	bne.w	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
	if (bt_dev.le.mtu) {
     63e:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
     642:	b963      	cbnz	r3, 65e <CONFIG_BT_COMPANY_ID+0x6d>
	read_buffer_size_complete(rsp);
     644:	9b01      	ldr	r3, [sp, #4]
     646:	689b      	ldr	r3, [r3, #8]
	bt_dev.le.mtu = sys_le16_to_cpu(rp->acl_max_len);
     648:	785a      	ldrb	r2, [r3, #1]
     64a:	7899      	ldrb	r1, [r3, #2]
     64c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
     650:	f8a5 2088 	strh.w	r2, [r5, #136]	; 0x88
	k_sem_init(&bt_dev.le.pkts, pkts, pkts);
     654:	889a      	ldrh	r2, [r3, #4]
     656:	486d      	ldr	r0, [pc, #436]	; (80c <CONFIG_ISR_STACK_SIZE+0xc>)
     658:	4611      	mov	r1, r2
     65a:	f01d fff9 	bl	1e650 <z_impl_k_sem_init>
	net_buf_unref(rsp);
     65e:	9801      	ldr	r0, [sp, #4]
     660:	f015 ff5e 	bl	16520 <net_buf_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
     664:	2108      	movs	r1, #8
     666:	f640 4001 	movw	r0, #3073	; 0xc01
     66a:	f005 fbe5 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
     66e:	4604      	mov	r4, r0
     670:	2800      	cmp	r0, #0
     672:	d050      	beq.n	716 <CONFIG_BT_COMPANY_ID+0x125>
	ev = net_buf_add(buf, sizeof(*ev));
     674:	2108      	movs	r1, #8
     676:	4408      	add	r0, r1
     678:	f01d fae8 	bl	1dc4c <net_buf_simple_add>
	if (IS_ENABLED(CONFIG_BT_SMP) &&
     67c:	f895 3078 	ldrb.w	r3, [r5, #120]	; 0x78
     680:	07db      	lsls	r3, r3, #31
	ev = net_buf_add(buf, sizeof(*ev));
     682:	4602      	mov	r2, r0
	if (IS_ENABLED(CONFIG_BT_SMP) &&
     684:	f140 80b5 	bpl.w	7f2 <CONFIG_BT_COMPANY_ID+0x201>
		mask |= BT_EVT_MASK_ENCRYPT_KEY_REFRESH_COMPLETE;
     688:	a15d      	add	r1, pc, #372	; (adr r1, 800 <CONFIG_ISR_STACK_SIZE>)
     68a:	e9d1 0100 	ldrd	r0, r1, [r1]
	sys_put_le64(mask, ev->events);
     68e:	f01a fe61 	bl	1b354 <sys_put_le64>
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
     692:	4621      	mov	r1, r4
     694:	2200      	movs	r2, #0
     696:	f640 4001 	movw	r0, #3073	; 0xc01
     69a:	f005 fd3b 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
     69e:	4604      	mov	r4, r0
     6a0:	2800      	cmp	r0, #0
     6a2:	f47f af1b 	bne.w	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_VERSION_INFO, NULL, &rsp);
     6a6:	4601      	mov	r1, r0
     6a8:	466a      	mov	r2, sp
     6aa:	f64f 4001 	movw	r0, #64513	; 0xfc01
     6ae:	f005 fd31 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
     6b2:	4e57      	ldr	r6, [pc, #348]	; (810 <CONFIG_ISR_STACK_SIZE+0x10>)
     6b4:	4b57      	ldr	r3, [pc, #348]	; (814 <CONFIG_ISR_STACK_SIZE+0x14>)
     6b6:	1af6      	subs	r6, r6, r3
     6b8:	f3c6 06c9 	ubfx	r6, r6, #3, #10
     6bc:	2800      	cmp	r0, #0
     6be:	f000 80b5 	beq.w	82c <CONFIG_ISR_STACK_SIZE+0x2c>
		BT_WARN("Vendor HCI extensions not available");
     6c2:	f04f 0100 	mov.w	r1, #0
     6c6:	2302      	movs	r3, #2
     6c8:	f363 0107 	bfi	r1, r3, #0, #8
     6cc:	4852      	ldr	r0, [pc, #328]	; (818 <CONFIG_ISR_STACK_SIZE+0x18>)
     6ce:	f366 118f 	bfi	r1, r6, #6, #10
		BT_WARN("Failed to read supported vendor commands");
     6d2:	f019 ff9e 	bl	1a612 <log_0>
		err = bt_conn_init();
     6d6:	f008 f80d 	bl	86f4 <bt_conn_init>
		if (err) {
     6da:	4604      	mov	r4, r0
     6dc:	2800      	cmp	r0, #0
     6de:	f47f aefd 	bne.w	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
	k_delayed_work_init(&bt_dev.rpa_update, rpa_timeout);
     6e2:	494e      	ldr	r1, [pc, #312]	; (81c <CONFIG_ISR_STACK_SIZE+0x1c>)
     6e4:	484e      	ldr	r0, [pc, #312]	; (820 <CONFIG_ISR_STACK_SIZE+0x20>)
     6e6:	f01e f82f 	bl	1e748 <k_delayed_work_init>
		if (!bt_dev.id_count) {
     6ea:	79eb      	ldrb	r3, [r5, #7]
     6ec:	2b00      	cmp	r3, #0
     6ee:	f040 811e 	bne.w	92e <CONFIG_BT_RX_STACK_SIZE+0x96>
			BT_INFO("No ID address. App must call settings_load()");
     6f2:	2303      	movs	r3, #3
     6f4:	f04f 0100 	mov.w	r1, #0
     6f8:	f363 0107 	bfi	r1, r3, #0, #8
     6fc:	f366 118f 	bfi	r1, r6, #6, #10
     700:	4848      	ldr	r0, [pc, #288]	; (824 <CONFIG_ISR_STACK_SIZE+0x24>)
     702:	f019 ff86 	bl	1a612 <log_0>
			return 0;
     706:	e6e9      	b.n	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
     708:	2102      	movs	r1, #2
     70a:	f640 406d 	movw	r0, #3181	; 0xc6d
     70e:	f005 fb93 	bl	5e38 <bt_hci_cmd_create>
		if (!buf) {
     712:	4606      	mov	r6, r0
     714:	b910      	cbnz	r0, 71c <CONFIG_BT_COMPANY_ID+0x12b>
		return -ENOBUFS;
     716:	f06f 0436 	mvn.w	r4, #54	; 0x36
     71a:	e6df      	b.n	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
		cp_le = net_buf_add(buf, sizeof(*cp_le));
     71c:	2102      	movs	r1, #2
     71e:	3008      	adds	r0, #8
     720:	f01d fa94 	bl	1dc4c <net_buf_simple_add>
		cp_le->le = 0x01;
     724:	2301      	movs	r3, #1
		cp_le->simul = 0x00;
     726:	7044      	strb	r4, [r0, #1]
		cp_le->le = 0x01;
     728:	7003      	strb	r3, [r0, #0]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
     72a:	4622      	mov	r2, r4
     72c:	4631      	mov	r1, r6
     72e:	f640 406d 	movw	r0, #3181	; 0xc6d
     732:	f005 fcef 	bl	6114 <bt_hci_cmd_send_sync>
		if (err) {
     736:	4604      	mov	r4, r0
     738:	2800      	cmp	r0, #0
     73a:	f43f af10 	beq.w	55e <CONFIG_BT_HCI_ECC_STACK_SIZE+0x112>
     73e:	e6cd      	b.n	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_MAX_DATA_LEN, NULL,
     740:	aa01      	add	r2, sp, #4
     742:	2100      	movs	r1, #0
     744:	f242 002f 	movw	r0, #8239	; 0x202f
     748:	f005 fce4 	bl	6114 <bt_hci_cmd_send_sync>
		if (err) {
     74c:	4604      	mov	r4, r0
     74e:	2800      	cmp	r0, #0
     750:	f47f aec4 	bne.w	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
		rp = (void *)rsp->data;
     754:	9801      	ldr	r0, [sp, #4]
     756:	6883      	ldr	r3, [r0, #8]
		tx_octets = sys_le16_to_cpu(rp->max_tx_octets);
     758:	f8b3 8001 	ldrh.w	r8, [r3, #1]
		tx_time = sys_le16_to_cpu(rp->max_tx_time);
     75c:	f8b3 7003 	ldrh.w	r7, [r3, #3]
		net_buf_unref(rsp);
     760:	f015 fede 	bl	16520 <net_buf_unref>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
     764:	2104      	movs	r1, #4
     766:	f242 0024 	movw	r0, #8228	; 0x2024
     76a:	f005 fb65 	bl	5e38 <bt_hci_cmd_create>
		if (!buf) {
     76e:	4606      	mov	r6, r0
     770:	2800      	cmp	r0, #0
     772:	d0d0      	beq.n	716 <CONFIG_BT_COMPANY_ID+0x125>
		cp = net_buf_add(buf, sizeof(*cp));
     774:	2104      	movs	r1, #4
     776:	3008      	adds	r0, #8
     778:	f01d fa68 	bl	1dc4c <net_buf_simple_add>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
     77c:	4622      	mov	r2, r4
		cp->max_tx_octets = sys_cpu_to_le16(tx_octets);
     77e:	f8a0 8000 	strh.w	r8, [r0]
		cp->max_tx_time = sys_cpu_to_le16(tx_time);
     782:	8047      	strh	r7, [r0, #2]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
     784:	4631      	mov	r1, r6
     786:	f242 0024 	movw	r0, #8228	; 0x2024
     78a:	f005 fcc3 	bl	6114 <bt_hci_cmd_send_sync>
		if (err) {
     78e:	4604      	mov	r4, r0
     790:	2800      	cmp	r0, #0
     792:	f43f aeff 	beq.w	594 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x148>
     796:	e6a1      	b.n	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RPA_TIMEOUT,
     798:	2102      	movs	r1, #2
     79a:	f242 002e 	movw	r0, #8238	; 0x202e
     79e:	f005 fb4b 	bl	5e38 <bt_hci_cmd_create>
		if (!buf) {
     7a2:	4604      	mov	r4, r0
     7a4:	2800      	cmp	r0, #0
     7a6:	d0b6      	beq.n	716 <CONFIG_BT_COMPANY_ID+0x125>
		cp = net_buf_add(buf, sizeof(*cp));
     7a8:	2102      	movs	r1, #2
     7aa:	3008      	adds	r0, #8
     7ac:	f01d fa4e 	bl	1dc4c <net_buf_simple_add>
		cp->rpa_timeout = sys_cpu_to_le16(CONFIG_BT_RPA_TIMEOUT);
     7b0:	f06f 037b 	mvn.w	r3, #123	; 0x7b
     7b4:	7003      	strb	r3, [r0, #0]
     7b6:	2303      	movs	r3, #3
     7b8:	7043      	strb	r3, [r0, #1]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RPA_TIMEOUT, buf,
     7ba:	4621      	mov	r1, r4
     7bc:	2200      	movs	r2, #0
     7be:	f242 002e 	movw	r0, #8238	; 0x202e
     7c2:	f005 fca7 	bl	6114 <bt_hci_cmd_send_sync>
		if (err) {
     7c6:	4604      	mov	r4, r0
     7c8:	2800      	cmp	r0, #0
     7ca:	f47f ae87 	bne.w	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_RL_SIZE, NULL,
     7ce:	4601      	mov	r1, r0
     7d0:	aa01      	add	r2, sp, #4
     7d2:	f242 002a 	movw	r0, #8234	; 0x202a
     7d6:	f005 fc9d 	bl	6114 <bt_hci_cmd_send_sync>
		if (err) {
     7da:	4604      	mov	r4, r0
     7dc:	2800      	cmp	r0, #0
     7de:	f47f ae7d 	bne.w	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
		le_read_resolving_list_size_complete(rsp);
     7e2:	9801      	ldr	r0, [sp, #4]
	bt_dev.le.rl_size = rp->rl_size;
     7e4:	6883      	ldr	r3, [r0, #8]
     7e6:	785b      	ldrb	r3, [r3, #1]
     7e8:	f885 30a4 	strb.w	r3, [r5, #164]	; 0xa4
		net_buf_unref(rsp);
     7ec:	f015 fe98 	bl	16520 <net_buf_unref>
     7f0:	e6d5      	b.n	59e <CONFIG_BT_HCI_ECC_STACK_SIZE+0x152>
		mask |= BT_EVT_MASK_REMOTE_VERSION_INFO;
     7f2:	480d      	ldr	r0, [pc, #52]	; (828 <CONFIG_ISR_STACK_SIZE+0x28>)
     7f4:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
     7f8:	e749      	b.n	68e <CONFIG_BT_COMPANY_ID+0x9d>
     7fa:	bf00      	nop
     7fc:	f3af 8000 	nop.w
     800:	02008890 	.word	0x02008890
     804:	20008000 	.word	0x20008000
     808:	200054b0 	.word	0x200054b0
     80c:	200054c4 	.word	0x200054c4
     810:	0001ede8 	.word	0x0001ede8
     814:	0001ed28 	.word	0x0001ed28
     818:	00020569 	.word	0x00020569
     81c:	000062b5 	.word	0x000062b5
     820:	20005520 	.word	0x20005520
     824:	0002063d 	.word	0x0002063d
     828:	02008810 	.word	0x02008810
	rp.info = (void *)rsp->data;
     82c:	9b00      	ldr	r3, [sp, #0]
	BT_INFO("HW Platform: %s (0x%04x)",
     82e:	4843      	ldr	r0, [pc, #268]	; (93c <CONFIG_BT_RX_STACK_SIZE+0xa4>)
	rp.info = (void *)rsp->data;
     830:	689c      	ldr	r4, [r3, #8]
	BT_INFO("HW Platform: %s (0x%04x)",
     832:	2203      	movs	r2, #3
     834:	f04f 0300 	mov.w	r3, #0
     838:	f362 0307 	bfi	r3, r2, #0, #8
     83c:	f8b4 2001 	ldrh.w	r2, [r4, #1]
	if (platform < ARRAY_SIZE(plat_str)) {
     840:	2a03      	cmp	r2, #3
		return plat_str[platform];
     842:	bf96      	itet	ls
     844:	493e      	ldrls	r1, [pc, #248]	; (940 <CONFIG_BT_RX_STACK_SIZE+0xa8>)
	return "unknown";
     846:	493f      	ldrhi	r1, [pc, #252]	; (944 <CONFIG_BT_RX_STACK_SIZE+0xac>)
		return plat_str[platform];
     848:	f851 1022 	ldrls.w	r1, [r1, r2, lsl #2]
	BT_INFO("HW Platform: %s (0x%04x)",
     84c:	f366 138f 	bfi	r3, r6, #6, #10
     850:	f019 ff00 	bl	1a654 <log_2>
	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
     854:	f8b4 1001 	ldrh.w	r1, [r4, #1]
	BT_INFO("HW Variant: %s (0x%04x)",
     858:	2203      	movs	r2, #3
     85a:	f04f 0300 	mov.w	r3, #0
     85e:	f362 0307 	bfi	r3, r2, #0, #8
	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
     862:	2902      	cmp	r1, #2
	BT_INFO("HW Variant: %s (0x%04x)",
     864:	f366 138f 	bfi	r3, r6, #6, #10
     868:	f8b4 2003 	ldrh.w	r2, [r4, #3]
	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
     86c:	d138      	bne.n	8e0 <CONFIG_BT_RX_STACK_SIZE+0x48>
	if (variant < ARRAY_SIZE(nordic_str)) {
     86e:	2a03      	cmp	r2, #3
     870:	d836      	bhi.n	8e0 <CONFIG_BT_RX_STACK_SIZE+0x48>
		return nordic_str[variant];
     872:	4935      	ldr	r1, [pc, #212]	; (948 <CONFIG_BT_RX_STACK_SIZE+0xb0>)
     874:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
	BT_INFO("HW Variant: %s (0x%04x)",
     878:	4834      	ldr	r0, [pc, #208]	; (94c <CONFIG_BT_RX_STACK_SIZE+0xb4>)
     87a:	f019 feeb 	bl	1a654 <log_2>
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
     87e:	2203      	movs	r2, #3
     880:	f04f 0300 	mov.w	r3, #0
     884:	f362 0307 	bfi	r3, r2, #0, #8
     888:	7962      	ldrb	r2, [r4, #5]
     88a:	4831      	ldr	r0, [pc, #196]	; (950 <CONFIG_BT_RX_STACK_SIZE+0xb8>)
	if (variant < ARRAY_SIZE(var_str)) {
     88c:	2a03      	cmp	r2, #3
		return var_str[variant];
     88e:	bf96      	itet	ls
     890:	4930      	ldrls	r1, [pc, #192]	; (954 <CONFIG_BT_RX_STACK_SIZE+0xbc>)
	return "unknown";
     892:	492c      	ldrhi	r1, [pc, #176]	; (944 <CONFIG_BT_RX_STACK_SIZE+0xac>)
		return var_str[variant];
     894:	f851 1022 	ldrls.w	r1, [r1, r2, lsl #2]
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
     898:	e9cd 1201 	strd	r1, r2, [sp, #4]
     89c:	79a2      	ldrb	r2, [r4, #6]
     89e:	9203      	str	r2, [sp, #12]
     8a0:	f8b4 2007 	ldrh.w	r2, [r4, #7]
     8a4:	9204      	str	r2, [sp, #16]
     8a6:	f8d4 2009 	ldr.w	r2, [r4, #9]
     8aa:	9205      	str	r2, [sp, #20]
     8ac:	f366 138f 	bfi	r3, r6, #6, #10
     8b0:	2205      	movs	r2, #5
     8b2:	a901      	add	r1, sp, #4
     8b4:	f019 ff01 	bl	1a6ba <log_n>
	net_buf_unref(rsp);
     8b8:	9800      	ldr	r0, [sp, #0]
     8ba:	f015 fe31 	bl	16520 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_COMMANDS,
     8be:	466a      	mov	r2, sp
     8c0:	2100      	movs	r1, #0
     8c2:	f64f 4002 	movw	r0, #64514	; 0xfc02
     8c6:	f005 fc25 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
     8ca:	4604      	mov	r4, r0
     8cc:	b150      	cbz	r0, 8e4 <CONFIG_BT_RX_STACK_SIZE+0x4c>
		BT_WARN("Failed to read supported vendor features");
     8ce:	f04f 0100 	mov.w	r1, #0
     8d2:	2302      	movs	r3, #2
     8d4:	f363 0107 	bfi	r1, r3, #0, #8
     8d8:	f366 118f 	bfi	r1, r6, #6, #10
     8dc:	481e      	ldr	r0, [pc, #120]	; (958 <CONFIG_BT_RX_STACK_SIZE+0xc0>)
     8de:	e6f8      	b.n	6d2 <CONFIG_BT_COMPANY_ID+0xe1>
		return "unknown";
     8e0:	4918      	ldr	r1, [pc, #96]	; (944 <CONFIG_BT_RX_STACK_SIZE+0xac>)
     8e2:	e7c9      	b.n	878 <CONFIG_ISR_STACK_SIZE+0x78>
	rp.cmds = (void *)rsp->data;
     8e4:	9b00      	ldr	r3, [sp, #0]
	memcpy(bt_dev.vs_commands, rp.cmds->commands, BT_DEV_VS_CMDS_MAX);
     8e6:	481d      	ldr	r0, [pc, #116]	; (95c <CONFIG_BT_RX_STACK_SIZE+0xc4>)
     8e8:	6899      	ldr	r1, [r3, #8]
     8ea:	2202      	movs	r2, #2
     8ec:	3101      	adds	r1, #1
     8ee:	f01a fb84 	bl	1affa <memcpy>
	net_buf_unref(rsp);
     8f2:	9800      	ldr	r0, [sp, #0]
     8f4:	f015 fe14 	bl	16520 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_FEATURES,
     8f8:	466a      	mov	r2, sp
     8fa:	4621      	mov	r1, r4
     8fc:	f64f 4003 	movw	r0, #64515	; 0xfc03
     900:	f005 fc08 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
     904:	b140      	cbz	r0, 918 <CONFIG_BT_RX_STACK_SIZE+0x80>
		BT_WARN("Failed to read supported vendor commands");
     906:	f04f 0100 	mov.w	r1, #0
     90a:	2302      	movs	r3, #2
     90c:	f363 0107 	bfi	r1, r3, #0, #8
     910:	f366 118f 	bfi	r1, r6, #6, #10
     914:	4812      	ldr	r0, [pc, #72]	; (960 <CONFIG_BT_RX_STACK_SIZE+0xc8>)
     916:	e6dc      	b.n	6d2 <CONFIG_BT_COMPANY_ID+0xe1>
	rp.feat = (void *)rsp->data;
     918:	9b00      	ldr	r3, [sp, #0]
	memcpy(bt_dev.vs_features, rp.feat->features, BT_DEV_VS_FEAT_MAX);
     91a:	4812      	ldr	r0, [pc, #72]	; (964 <CONFIG_BT_RX_STACK_SIZE+0xcc>)
     91c:	6899      	ldr	r1, [r3, #8]
     91e:	2201      	movs	r2, #1
     920:	4411      	add	r1, r2
     922:	f01a fb6a 	bl	1affa <memcpy>
	net_buf_unref(rsp);
     926:	9800      	ldr	r0, [sp, #0]
     928:	f015 fdfa 	bl	16520 <net_buf_unref>
	if (err) {
     92c:	e6d3      	b.n	6d6 <CONFIG_BT_COMPANY_ID+0xe5>
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
     92e:	2104      	movs	r1, #4
     930:	480d      	ldr	r0, [pc, #52]	; (968 <CONFIG_BT_RX_STACK_SIZE+0xd0>)
     932:	f01a fcb6 	bl	1b2a2 <atomic_or>
	bt_finalize_init();
     936:	f006 fa19 	bl	6d6c <bt_finalize_init>
	return 0;
     93a:	e5cf      	b.n	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
     93c:	0002058d 	.word	0x0002058d
     940:	0001f380 	.word	0x0001f380
     944:	00020cbe 	.word	0x00020cbe
     948:	0001f348 	.word	0x0001f348
     94c:	000205a6 	.word	0x000205a6
     950:	000205be 	.word	0x000205be
     954:	0001f3b0 	.word	0x0001f3b0
     958:	000205eb 	.word	0x000205eb
     95c:	20005499 	.word	0x20005499
     960:	00020614 	.word	0x00020614
     964:	20005498 	.word	0x20005498
     968:	200054a8 	.word	0x200054a8
     96c:	00000000 	.word	0x00000000

00000970 <ll_adv_enable>:
{
	u32_t ticks_anchor;
#endif /* !CONFIG_BT_HCI_MESH_EXT */
#else /* !CONFIG_BT_CTLR_ADV_EXT || !CONFIG_BT_HCI_MESH_EXT */
u8_t ll_adv_enable(u8_t enable)
{
     970:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     974:	b091      	sub	sp, #68	; 0x44
	u16_t const handle = 0;
	u32_t ticks_anchor;
#endif /* !CONFIG_BT_CTLR_ADV_EXT || !CONFIG_BT_HCI_MESH_EXT */
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
     976:	2302      	movs	r3, #2
     978:	930f      	str	r3, [sp, #60]	; 0x3c
	u32_t ticks_slot_offset;
	struct ll_adv_set *adv;
	struct lll_adv *lll;
	u32_t ret;

	if (!enable) {
     97a:	b930      	cbnz	r0, 98a <ll_adv_enable+0x1a>
		return disable(handle);
     97c:	f010 fdec 	bl	11558 <disable.constprop.5>
     980:	4606      	mov	r6, r0
		conn_release(adv);
	}
#endif /* CONFIG_BT_PERIPHERAL */

	return BT_HCI_ERR_CMD_DISALLOWED;
}
     982:	4630      	mov	r0, r6
     984:	b011      	add	sp, #68	; 0x44
     986:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
static inline struct ll_adv_set *is_disabled_get(u16_t handle)
{
	struct ll_adv_set *adv;

	adv = ull_adv_set_get(handle);
	if (!adv || adv->is_enabled) {
     98a:	4f89      	ldr	r7, [pc, #548]	; (bb0 <ll_adv_enable+0x240>)
     98c:	f897 60cc 	ldrb.w	r6, [r7, #204]	; 0xcc
     990:	f016 0601 	ands.w	r6, r6, #1
     994:	463d      	mov	r5, r7
     996:	d001      	beq.n	99c <ll_adv_enable+0x2c>
	return BT_HCI_ERR_CMD_DISALLOWED;
     998:	260c      	movs	r6, #12
     99a:	e7f2      	b.n	982 <ll_adv_enable+0x12>
	lll_adv_pdu_enqueue(&lll->adv_data, idx);
}

static inline struct pdu_adv *lll_adv_data_peek(struct lll_adv *lll)
{
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
     99c:	f897 802c 	ldrb.w	r8, [r7, #44]	; 0x2c
		ull_filter_adv_update(lll->filter_policy);
     9a0:	f897 0029 	ldrb.w	r0, [r7, #41]	; 0x29
     9a4:	2227      	movs	r2, #39	; 0x27
     9a6:	232d      	movs	r3, #45	; 0x2d
     9a8:	fb12 3808 	smlabb	r8, r2, r8, r3
	lll_adv_pdu_enqueue(&lll->scan_rsp, idx);
}

static inline struct pdu_adv *lll_adv_scan_rsp_peek(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
     9ac:	f897 307c 	ldrb.w	r3, [r7, #124]	; 0x7c
     9b0:	fb02 7303 	mla	r3, r2, r3, r7
     9b4:	337d      	adds	r3, #125	; 0x7d
     9b6:	f000 0003 	and.w	r0, r0, #3
     9ba:	930b      	str	r3, [sp, #44]	; 0x2c
     9bc:	f014 facc 	bl	14f58 <ull_filter_adv_update>
		if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
     9c0:	f897 00da 	ldrb.w	r0, [r7, #218]	; 0xda
     9c4:	0784      	lsls	r4, r0, #30
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
     9c6:	eb07 0b08 	add.w	fp, r7, r8
     9ca:	f140 80b1 	bpl.w	b30 <ll_adv_enable+0x1c0>
			rl_idx = ull_filter_rl_find(adv->id_addr_type,
     9ce:	4632      	mov	r2, r6
     9d0:	f107 01dc 	add.w	r1, r7, #220	; 0xdc
     9d4:	f3c0 0080 	ubfx	r0, r0, #2, #1
     9d8:	f014 fb34 	bl	15044 <ull_filter_rl_find>
			if (rl_idx != FILTER_IDX_NONE) {
     9dc:	28ff      	cmp	r0, #255	; 0xff
			rl_idx = ull_filter_rl_find(adv->id_addr_type,
     9de:	4681      	mov	r9, r0
			if (rl_idx != FILTER_IDX_NONE) {
     9e0:	d002      	beq.n	9e8 <ll_adv_enable+0x78>
				ull_filter_rpa_update(false);
     9e2:	4630      	mov	r0, r6
     9e4:	f014 fd56 	bl	15494 <ull_filter_rpa_update>
			ull_filter_adv_pdu_update(adv, rl_idx, pdu_adv);
     9e8:	465a      	mov	r2, fp
     9ea:	4649      	mov	r1, r9
     9ec:	4870      	ldr	r0, [pc, #448]	; (bb0 <ll_adv_enable+0x240>)
     9ee:	f014 fabf 	bl	14f70 <ull_filter_adv_pdu_update>
			ull_filter_adv_pdu_update(adv, rl_idx, pdu_scan);
     9f2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
     9f4:	486e      	ldr	r0, [pc, #440]	; (bb0 <ll_adv_enable+0x240>)
     9f6:	4649      	mov	r1, r9
     9f8:	f014 faba 	bl	14f70 <ull_filter_adv_pdu_update>
		if (pdu_adv->tx_addr &&
     9fc:	f817 3008 	ldrb.w	r3, [r7, r8]
     a00:	0658      	lsls	r0, r3, #25
     a02:	f100 80ac 	bmi.w	b5e <ll_adv_enable+0x1ee>
	if ((pdu_adv->type == PDU_ADV_TYPE_ADV_IND) ||
     a06:	f817 3008 	ldrb.w	r3, [r7, r8]
     a0a:	f013 0f0e 	tst.w	r3, #14
     a0e:	f000 80b0 	beq.w	b72 <ll_adv_enable+0x202>
	u8_t ch_map = lll->chan_map;
     a12:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
	adv->rl_idx = rl_idx;
     a16:	f885 90db 	strb.w	r9, [r5, #219]	; 0xdb
	u8_t ch_map = lll->chan_map;
     a1a:	f3c3 0342 	ubfx	r3, r3, #1, #3
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
     a1e:	2101      	movs	r1, #1
     a20:	f10d 003b 	add.w	r0, sp, #59	; 0x3b
	u8_t ch_map = lll->chan_map;
     a24:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
     a28:	f01c fa9c 	bl	1cf64 <util_ones_count_get>
	if (adv_chn_cnt == 0) {
     a2c:	2800      	cmp	r0, #0
     a2e:	f000 81b1 	beq.w	d94 <ll_adv_enable+0x424>
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
     a32:	f817 4008 	ldrb.w	r4, [r7, r8]
		const u8_t rsp_data_len = pdu_scan->len;
     a36:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
		const u8_t adv_data_len = pdu_adv->len;
     a38:	f89b 3001 	ldrb.w	r3, [fp, #1]
		const u8_t rsp_data_len = pdu_scan->len;
     a3c:	7852      	ldrb	r2, [r2, #1]
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
     a3e:	f004 040f 	and.w	r4, r4, #15
     a42:	2c02      	cmp	r4, #2
     a44:	f100 31ff 	add.w	r1, r0, #4294967295	; 0xffffffff
     a48:	f040 8173 	bne.w	d32 <ll_adv_enable+0x3c2>
			adv_size += adv_data_len;
     a4c:	3310      	adds	r3, #16
			slot_us += BYTES2US(adv_size, phy) * adv_chn_cnt +
     a4e:	00db      	lsls	r3, r3, #3
     a50:	4358      	muls	r0, r3
     a52:	f500 70aa 	add.w	r0, r0, #340	; 0x154
     a56:	2364      	movs	r3, #100	; 0x64
			slot_us += (BYTES2US(adv_size, phy) + EVENT_IFS_MAX_US
     a58:	fb01 0003 	mla	r0, r1, r3, r0
static inline void lll_hdr_init(void *lll, void *parent)
{
	struct lll_hdr *hdr = lll;

	hdr->parent = parent;
	hdr->is_stop = 0U;
     a5c:	f895 3020 	ldrb.w	r3, [r5, #32]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
     a60:	4954      	ldr	r1, [pc, #336]	; (bb4 <ll_adv_enable+0x244>)
	hdr->parent = parent;
     a62:	61ed      	str	r5, [r5, #28]
	return hdr->ref--;
}

static inline void ull_hdr_init(struct ull_hdr *hdr)
{
	hdr->disabled_cb = hdr->disabled_param = NULL;
     a64:	2400      	movs	r4, #0
	hdr->is_stop = 0U;
     a66:	f364 0300 	bfi	r3, r4, #0, #1
     a6a:	f885 3020 	strb.w	r3, [r5, #32]
	adv->evt.ticks_xtal_to_start =
     a6e:	2331      	movs	r3, #49	; 0x31
     a70:	602b      	str	r3, [r5, #0]
     a72:	e9c5 4405 	strd	r4, r4, [r5, #20]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
     a76:	a34c      	add	r3, pc, #304	; (adr r3, ba8 <ll_adv_enable+0x238>)
     a78:	e9d3 2300 	ldrd	r2, r3, [r3]
	adv->evt.ticks_active_to_start = 0;
     a7c:	606c      	str	r4, [r5, #4]
	adv->evt.ticks_preempt_to_start =
     a7e:	60ac      	str	r4, [r5, #8]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
     a80:	fba0 0101 	umull	r0, r1, r0, r1
     a84:	f7ff fb2c 	bl	e0 <__aeabi_uldivmod>
     a88:	60e8      	str	r0, [r5, #12]
	u16_t interval = adv->interval;
     a8a:	f8b5 90d8 	ldrh.w	r9, [r5, #216]	; 0xd8
	ticks_anchor = ticker_ticks_now_get();
     a8e:	f01c fb96 	bl	1d1be <ticker_ticks_now_get>
     a92:	4682      	mov	sl, r0
	lll->is_hdcd = !interval && (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND);
     a94:	f1b9 0f00 	cmp.w	r9, #0
     a98:	d106      	bne.n	aa8 <ll_adv_enable+0x138>
     a9a:	f817 4008 	ldrb.w	r4, [r7, r8]
     a9e:	f004 040f 	and.w	r4, r4, #15
     aa2:	1e63      	subs	r3, r4, #1
     aa4:	425c      	negs	r4, r3
     aa6:	415c      	adcs	r4, r3
     aa8:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
     aac:	f8df 8110 	ldr.w	r8, [pc, #272]	; bc0 <ll_adv_enable+0x250>
     ab0:	68ea      	ldr	r2, [r5, #12]
     ab2:	f364 0300 	bfi	r3, r4, #0, #1
     ab6:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
	if (lll->is_hdcd) {
     aba:	f013 0401 	ands.w	r4, r3, #1
     abe:	4b3e      	ldr	r3, [pc, #248]	; (bb8 <ll_adv_enable+0x248>)
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     ac0:	9204      	str	r2, [sp, #16]
     ac2:	af0f      	add	r7, sp, #60	; 0x3c
     ac4:	e9cd 8707 	strd	r8, r7, [sp, #28]
     ac8:	e9cd 3505 	strd	r3, r5, [sp, #20]
	if (lll->is_hdcd) {
     acc:	f000 814a 	beq.w	d64 <ll_adv_enable+0x3f4>
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     ad0:	2000      	movs	r0, #0
     ad2:	e9cd 0200 	strd	r0, r2, [sp]
     ad6:	2103      	movs	r1, #3
     ad8:	e9cd 0002 	strd	r0, r0, [sp, #8]
     adc:	4653      	mov	r3, sl
     ade:	2202      	movs	r2, #2
     ae0:	f00d fc7a 	bl	e3d8 <ticker_start>
		ret = ull_ticker_status_take(ret, &ret_cb);
     ae4:	4639      	mov	r1, r7
     ae6:	f00f fcbd 	bl	10464 <ull_ticker_status_take>
		if (ret != TICKER_STATUS_SUCCESS) {
     aea:	2800      	cmp	r0, #0
     aec:	f040 8152 	bne.w	d94 <ll_adv_enable+0x424>
		ret_cb = TICKER_STATUS_BUSY;
     af0:	2202      	movs	r2, #2
     af2:	920f      	str	r2, [sp, #60]	; 0x3c
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     af4:	e9cd 8707 	strd	r8, r7, [sp, #28]
     af8:	4a30      	ldr	r2, [pc, #192]	; (bbc <ll_adv_enable+0x24c>)
     afa:	9506      	str	r5, [sp, #24]
     afc:	e9cd 0002 	strd	r0, r0, [sp, #8]
     b00:	f24a 33d8 	movw	r3, #41944	; 0xa3d8
     b04:	e9cd 0204 	strd	r0, r2, [sp, #16]
     b08:	9300      	str	r3, [sp, #0]
     b0a:	9001      	str	r0, [sp, #4]
     b0c:	4653      	mov	r3, sl
     b0e:	2201      	movs	r2, #1
     b10:	2103      	movs	r1, #3
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     b12:	f00d fc61 	bl	e3d8 <ticker_start>
	ret = ull_ticker_status_take(ret, &ret_cb);
     b16:	4639      	mov	r1, r7
     b18:	f00f fca4 	bl	10464 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
     b1c:	2800      	cmp	r0, #0
     b1e:	f040 8139 	bne.w	d94 <ll_adv_enable+0x424>
	adv->is_enabled = 1;
     b22:	f895 30cc 	ldrb.w	r3, [r5, #204]	; 0xcc
     b26:	f043 0301 	orr.w	r3, r3, #1
     b2a:	f885 30cc 	strb.w	r3, [r5, #204]	; 0xcc
	return 0;
     b2e:	e728      	b.n	982 <ll_adv_enable+0x12>
			u8_t *tx_addr = ll_addr_get(pdu_adv->tx_addr, NULL);
     b30:	f817 0008 	ldrb.w	r0, [r7, r8]
     b34:	4631      	mov	r1, r6
     b36:	f3c0 1080 	ubfx	r0, r0, #6, #1
     b3a:	f00d fd19 	bl	e570 <ll_addr_get>
			memcpy(&pdu_adv->adv_ind.addr[0], tx_addr,
     b3e:	2206      	movs	r2, #6
     b40:	4601      	mov	r1, r0
			u8_t *tx_addr = ll_addr_get(pdu_adv->tx_addr, NULL);
     b42:	4604      	mov	r4, r0
			memcpy(&pdu_adv->adv_ind.addr[0], tx_addr,
     b44:	f10b 0002 	add.w	r0, fp, #2
     b48:	f01a fa57 	bl	1affa <memcpy>
			memcpy(&pdu_scan->scan_rsp.addr[0], tx_addr,
     b4c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
     b4e:	2206      	movs	r2, #6
     b50:	4621      	mov	r1, r4
     b52:	1c98      	adds	r0, r3, #2
     b54:	f01a fa51 	bl	1affa <memcpy>
	u8_t   rl_idx = FILTER_IDX_NONE;
     b58:	f04f 09ff 	mov.w	r9, #255	; 0xff
     b5c:	e74e      	b.n	9fc <ll_adv_enable+0x8c>
		    !mem_nz(pdu_adv->adv_ind.addr, BDADDR_SIZE)) {
     b5e:	2106      	movs	r1, #6
     b60:	f10b 0002 	add.w	r0, fp, #2
     b64:	f01c f9c7 	bl	1cef6 <mem_nz>
		if (pdu_adv->tx_addr &&
     b68:	2800      	cmp	r0, #0
     b6a:	f47f af4c 	bne.w	a06 <ll_adv_enable+0x96>
			return BT_HCI_ERR_INVALID_PARAM;
     b6e:	2612      	movs	r6, #18
     b70:	e707      	b.n	982 <ll_adv_enable+0x12>
		if (lll->conn) {
     b72:	6a6b      	ldr	r3, [r5, #36]	; 0x24
     b74:	2b00      	cmp	r3, #0
     b76:	f47f af0f 	bne.w	998 <ll_adv_enable+0x28>
		link = ll_rx_link_alloc();
     b7a:	f00f fbcb 	bl	10314 <ll_rx_link_alloc>
		if (!link) {
     b7e:	4682      	mov	sl, r0
     b80:	b128      	cbz	r0, b8e <ll_adv_enable+0x21e>
		node_rx = ll_rx_alloc();
     b82:	f00f fbd3 	bl	1032c <ll_rx_alloc>
		if (!node_rx) {
     b86:	b920      	cbnz	r0, b92 <ll_adv_enable+0x222>
			ll_rx_link_release(link);
     b88:	4650      	mov	r0, sl
     b8a:	f00f fbc9 	bl	10320 <ll_rx_link_release>
			return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
     b8e:	2607      	movs	r6, #7
     b90:	e6f7      	b.n	982 <ll_adv_enable+0x12>
     b92:	900c      	str	r0, [sp, #48]	; 0x30
		conn = ll_conn_acquire();
     b94:	f011 fba4 	bl	122e0 <ll_conn_acquire>
		if (!conn) {
     b98:	9b0c      	ldr	r3, [sp, #48]	; 0x30
     b9a:	4604      	mov	r4, r0
     b9c:	b990      	cbnz	r0, bc4 <ll_adv_enable+0x254>
			ll_rx_release(node_rx);
     b9e:	4618      	mov	r0, r3
     ba0:	f00f fbca 	bl	10338 <ll_rx_release>
     ba4:	e7f0      	b.n	b88 <ll_adv_enable+0x218>
     ba6:	bf00      	nop
     ba8:	1afd498d 	.word	0x1afd498d
     bac:	00000007 	.word	0x00000007
     bb0:	20001094 	.word	0x20001094
     bb4:	3b9aca00 	.word	0x3b9aca00
     bb8:	00010fed 	.word	0x00010fed
     bbc:	00011249 	.word	0x00011249
     bc0:	00010459 	.word	0x00010459
		conn_lll = &conn->lll;
     bc4:	f100 021c 	add.w	r2, r0, #28
     bc8:	920c      	str	r2, [sp, #48]	; 0x30
		conn_lll->handle = 0xFFFF;
     bca:	f64f 72ff 	movw	r2, #65535	; 0xffff
     bce:	8582      	strh	r2, [r0, #44]	; 0x2c
		if (!conn_lll->link_tx_free) {
     bd0:	6f82      	ldr	r2, [r0, #120]	; 0x78
     bd2:	b912      	cbnz	r2, bda <ll_adv_enable+0x26a>
			conn_lll->link_tx_free = &conn_lll->link_tx;
     bd4:	f100 0270 	add.w	r2, r0, #112	; 0x70
     bd8:	6782      	str	r2, [r0, #120]	; 0x78
		memq_init(conn_lll->link_tx_free, &conn_lll->memq_tx.head,
     bda:	f104 026c 	add.w	r2, r4, #108	; 0x6c
     bde:	f104 0168 	add.w	r1, r4, #104	; 0x68
     be2:	6fa0      	ldr	r0, [r4, #120]	; 0x78
     be4:	930d      	str	r3, [sp, #52]	; 0x34
     be6:	f01c f991 	bl	1cf0c <memq_init>
		conn_lll->max_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0);
     bea:	4a71      	ldr	r2, [pc, #452]	; (db0 <ll_adv_enable+0x440>)
		conn->llcp_terminate.node_rx.hdr.link = link;
     bec:	f8c4 a12c 	str.w	sl, [r4, #300]	; 0x12c
		conn_lll->max_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0);
     bf0:	f04f 111b 	mov.w	r1, #1769499	; 0x1b001b
     bf4:	e9c4 1217 	strd	r1, r2, [r4, #92]	; 0x5c
		conn_lll->phy_tx = BIT(0);
     bf8:	f8b4 2064 	ldrh.w	r2, [r4, #100]	; 0x64
		conn_lll->slave.latency_enabled = 0;
     bfc:	f894 1040 	ldrb.w	r1, [r4, #64]	; 0x40
		conn_lll->phy_tx = BIT(0);
     c00:	f422 62ef 	bic.w	r2, r2, #1912	; 0x778
     c04:	f022 0207 	bic.w	r2, r2, #7
     c08:	f442 7288 	orr.w	r2, r2, #272	; 0x110
     c0c:	f042 0201 	orr.w	r2, r2, #1
     c10:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64
		conn_lll->data_chan_sel = 0;
     c14:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
     c18:	f002 023f 	and.w	r2, r2, #63	; 0x3f
     c1c:	f062 027f 	orn	r2, r2, #127	; 0x7f
     c20:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
		conn_lll->data_chan_use = 0;
     c24:	2200      	movs	r2, #0
		conn_lll->slave.latency_enabled = 0;
     c26:	f362 0100 	bfi	r1, r2, #0, #1
     c2a:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
		conn->connect_expire = 6;
     c2e:	2106      	movs	r1, #6
     c30:	f8a4 10c4 	strh.w	r1, [r4, #196]	; 0xc4
		conn->common.fex_valid = 0;
     c34:	f894 10dc 	ldrb.w	r1, [r4, #220]	; 0xdc
		conn_lll->data_chan_use = 0;
     c38:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
		conn->common.fex_valid = 0;
     c3c:	f021 0103 	bic.w	r1, r1, #3
     c40:	f884 10dc 	strb.w	r1, [r4, #220]	; 0xdc
		conn->llcp_feature.features = LL_FEAT;
     c44:	495b      	ldr	r1, [pc, #364]	; (db4 <ll_adv_enable+0x444>)
     c46:	f8c4 111c 	str.w	r1, [r4, #284]	; 0x11c
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
     c4a:	f894 1122 	ldrb.w	r1, [r4, #290]	; 0x122
		conn_lll->latency_prepare = 0;
     c4e:	8662      	strh	r2, [r4, #50]	; 0x32
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
     c50:	f021 0103 	bic.w	r1, r1, #3
		conn_lll->latency_event = 0;
     c54:	6362      	str	r2, [r4, #52]	; 0x34
		conn_lll->slave.window_widening_event_us = 0;
     c56:	e9c4 2213 	strd	r2, r2, [r4, #76]	; 0x4c
		conn_lll->slave.window_size_prepare_us = 0;
     c5a:	6562      	str	r2, [r4, #84]	; 0x54
		conn->supervision_expire = 0;
     c5c:	f8a4 20c8 	strh.w	r2, [r4, #200]	; 0xc8
		conn->procedure_expire = 0;
     c60:	f8a4 20cc 	strh.w	r2, [r4, #204]	; 0xcc
		conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0;
     c64:	f8a4 20e8 	strh.w	r2, [r4, #232]	; 0xe8
     c68:	f884 20ea 	strb.w	r2, [r4, #234]	; 0xea
		conn->llcp_rx = NULL;
     c6c:	f8c4 2100 	str.w	r2, [r4, #256]	; 0x100
		conn->llcp_cu.req = conn->llcp_cu.ack = 0;
     c70:	f8a4 2104 	strh.w	r2, [r4, #260]	; 0x104
		conn->llcp_feature.req = conn->llcp_feature.ack = 0;
     c74:	f8a4 2118 	strh.w	r2, [r4, #280]	; 0x118
		conn->llcp_version.req = conn->llcp_version.ack = 0;
     c78:	f8a4 2120 	strh.w	r2, [r4, #288]	; 0x120
		conn->llcp_terminate.reason_peer = 0;
     c7c:	f884 212b 	strb.w	r2, [r4, #299]	; 0x12b
		conn_lll->link_tx_free = NULL;
     c80:	67a2      	str	r2, [r4, #120]	; 0x78
		conn_lll->packet_tx_head_len = 0;
     c82:	f8a4 207c 	strh.w	r2, [r4, #124]	; 0x7c
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
     c86:	f884 1122 	strb.w	r1, [r4, #290]	; 0x122
		conn_lll->sn = 0;
     c8a:	f894 107e 	ldrb.w	r1, [r4, #126]	; 0x7e
		conn->llcp_enc.req = conn->llcp_enc.ack = 0U;
     c8e:	f8a4 2150 	strh.w	r2, [r4, #336]	; 0x150
		conn_lll->sn = 0;
     c92:	f021 011f 	bic.w	r1, r1, #31
     c96:	f884 107e 	strb.w	r1, [r4, #126]	; 0x7e
		conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
     c9a:	f894 1152 	ldrb.w	r1, [r4, #338]	; 0x152
		conn->llcp_conn_param.req = 0;
     c9e:	f8a4 2170 	strh.w	r2, [r4, #368]	; 0x170
		conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
     ca2:	f021 0107 	bic.w	r1, r1, #7
     ca6:	f884 1152 	strb.w	r1, [r4, #338]	; 0x152
		conn->llcp_conn_param.disabled = 0;
     caa:	f894 1172 	ldrb.w	r1, [r4, #370]	; 0x172
		conn->llcp_length.req = conn->llcp_length.ack = 0U;
     cae:	f8a4 2198 	strh.w	r2, [r4, #408]	; 0x198
		conn->llcp_conn_param.disabled = 0;
     cb2:	f362 1104 	bfi	r1, r2, #4, #1
		conn->llcp_length.cache.tx_octets = 0U;
     cb6:	f8a4 21a4 	strh.w	r2, [r4, #420]	; 0x1a4
		conn->llcp_conn_param.disabled = 0;
     cba:	f884 1172 	strb.w	r1, [r4, #370]	; 0x172
		conn->default_tx_octets = ull_conn_default_tx_octets_get();
     cbe:	f011 fc43 	bl	12548 <ull_conn_default_tx_octets_get>
     cc2:	f8a4 00d6 	strh.w	r0, [r4, #214]	; 0xd6
		conn->default_tx_time = ull_conn_default_tx_time_get();
     cc6:	f011 fc45 	bl	12554 <ull_conn_default_tx_time_get>
		conn->llcp_phy.req = conn->llcp_phy.ack = 0;
     cca:	493b      	ldr	r1, [pc, #236]	; (db8 <ll_adv_enable+0x448>)
		conn->default_tx_time = ull_conn_default_tx_time_get();
     ccc:	f8a4 00d8 	strh.w	r0, [r4, #216]	; 0xd8
		conn->llcp_phy.req = conn->llcp_phy.ack = 0;
     cd0:	f8d4 01a8 	ldr.w	r0, [r4, #424]	; 0x1a8
     cd4:	4001      	ands	r1, r0
     cd6:	f8c4 11a8 	str.w	r1, [r4, #424]	; 0x1a8
		conn->phy_pref_tx = ull_conn_default_phy_tx_get();
     cda:	f011 fc41 	bl	12560 <ull_conn_default_phy_tx_get>
     cde:	f894 11ac 	ldrb.w	r1, [r4, #428]	; 0x1ac
     ce2:	f360 0102 	bfi	r1, r0, #0, #3
     ce6:	f884 11ac 	strb.w	r1, [r4, #428]	; 0x1ac
		conn->phy_pref_rx = ull_conn_default_phy_rx_get();
     cea:	f011 fc3f 	bl	1256c <ull_conn_default_phy_rx_get>
		adv->node_rx_cc_free = node_rx;
     cee:	9b0d      	ldr	r3, [sp, #52]	; 0x34
     cf0:	f8c5 30d4 	str.w	r3, [r5, #212]	; 0xd4
		lll->conn = conn_lll;
     cf4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
		adv->link_cc_free = link;
     cf6:	f8c5 a0d0 	str.w	sl, [r5, #208]	; 0xd0
		lll->conn = conn_lll;
     cfa:	626b      	str	r3, [r5, #36]	; 0x24
		conn->phy_pref_rx = ull_conn_default_phy_rx_get();
     cfc:	f894 11ac 	ldrb.w	r1, [r4, #428]	; 0x1ac
     d00:	f894 3020 	ldrb.w	r3, [r4, #32]
	hdr->parent = parent;
     d04:	61e4      	str	r4, [r4, #28]
		conn->phy_pref_flags = 0;
     d06:	2200      	movs	r2, #0
		conn->phy_pref_rx = ull_conn_default_phy_rx_get();
     d08:	f360 1106 	bfi	r1, r0, #4, #3
		conn->phy_pref_flags = 0;
     d0c:	f362 01c3 	bfi	r1, r2, #3, #1
	hdr->is_stop = 0U;
     d10:	f362 0300 	bfi	r3, r2, #0, #1
     d14:	f884 11ac 	strb.w	r1, [r4, #428]	; 0x1ac
		conn->tx_data = conn->tx_data_last = 0;
     d18:	e9c4 226f 	strd	r2, r2, [r4, #444]	; 0x1bc
		conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
     d1c:	e9c4 226d 	strd	r2, r2, [r4, #436]	; 0x1b4
     d20:	f8c4 21b0 	str.w	r2, [r4, #432]	; 0x1b0
     d24:	e9c4 2205 	strd	r2, r2, [r4, #20]
     d28:	f884 3020 	strb.w	r3, [r4, #32]
		lll_clock_wait();
     d2c:	f013 fade 	bl	142ec <lll_clock_wait>
     d30:	e66f      	b.n	a12 <ll_adv_enable+0xa2>
			if (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND) {
     d32:	2c01      	cmp	r4, #1
     d34:	d012      	beq.n	d5c <ll_adv_enable+0x3ec>
					  BYTES2US(ADVA_SIZE + rsp_data_len,
     d36:	00d2      	lsls	r2, r2, #3
		const u16_t scan_rsp_us  = ll_hdr_us +
     d38:	3280      	adds	r2, #128	; 0x80
			} else if (pdu_adv->type == PDU_ADV_TYPE_ADV_IND) {
     d3a:	b94c      	cbnz	r4, d50 <ll_adv_enable+0x3e0>
				adv_size += adv_data_len;
     d3c:	3310      	adds	r3, #16
				slot_us += scan_req_us + EVENT_IFS_MAX_US +
     d3e:	f502 7227 	add.w	r2, r2, #668	; 0x29c
			slot_us += (BYTES2US(adv_size, phy) + EVENT_IFS_MAX_US
     d42:	00db      	lsls	r3, r3, #3
     d44:	f102 0098 	add.w	r0, r2, #152	; 0x98
     d48:	4418      	add	r0, r3
				  + rx_to_us + rxtx_turn_us) * (adv_chn_cnt-1)
     d4a:	f503 739a 	add.w	r3, r3, #308	; 0x134
     d4e:	e683      	b.n	a58 <ll_adv_enable+0xe8>
			} else if (pdu_adv->type == PDU_ADV_TYPE_SCAN_IND) {
     d50:	2c06      	cmp	r4, #6
     d52:	d0f3      	beq.n	d3c <ll_adv_enable+0x3cc>
		u32_t adv_size		= ll_hdr_size + ADVA_SIZE;
     d54:	2310      	movs	r3, #16
	u32_t slot_us	= EVENT_OVERHEAD_START_US + EVENT_OVERHEAD_END_US;
     d56:	f44f 72aa 	mov.w	r2, #340	; 0x154
     d5a:	e7f2      	b.n	d42 <ll_adv_enable+0x3d2>
				adv_size += TARGETA_SIZE;
     d5c:	2316      	movs	r3, #22
				slot_us += conn_ind_us;
     d5e:	f44f 722d 	mov.w	r2, #692	; 0x2b4
     d62:	e7ee      	b.n	d42 <ll_adv_enable+0x3d2>
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
     d64:	4815      	ldr	r0, [pc, #84]	; (dbc <ll_adv_enable+0x44c>)
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     d66:	f64f 73ff 	movw	r3, #65535	; 0xffff
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
     d6a:	fa1f f889 	uxth.w	r8, r9
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     d6e:	e9cd 4302 	strd	r4, r3, [sp, #8]
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
     d72:	fba8 0100 	umull	r0, r1, r8, r0
     d76:	2391      	movs	r3, #145	; 0x91
     d78:	fb03 1108 	mla	r1, r3, r8, r1
     d7c:	a30a      	add	r3, pc, #40	; (adr r3, da8 <ll_adv_enable+0x438>)
     d7e:	e9d3 2300 	ldrd	r2, r3, [r3]
     d82:	f7ff f9ad 	bl	e0 <__aeabi_uldivmod>
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     d86:	4653      	mov	r3, sl
     d88:	e9cd 4000 	strd	r4, r0, [sp]
     d8c:	2202      	movs	r2, #2
     d8e:	2103      	movs	r1, #3
     d90:	4620      	mov	r0, r4
     d92:	e6be      	b.n	b12 <ll_adv_enable+0x1a2>
	if (adv->lll.conn) {
     d94:	6a6b      	ldr	r3, [r5, #36]	; 0x24
     d96:	2b00      	cmp	r3, #0
     d98:	f43f adfe 	beq.w	998 <ll_adv_enable+0x28>
		conn_release(adv);
     d9c:	4808      	ldr	r0, [pc, #32]	; (dc0 <ll_adv_enable+0x450>)
     d9e:	f010 f9a7 	bl	110f0 <conn_release>
     da2:	e5f9      	b.n	998 <ll_adv_enable+0x28>
     da4:	f3af 8000 	nop.w
     da8:	1afd498d 	.word	0x1afd498d
     dac:	00000007 	.word	0x00000007
     db0:	01480148 	.word	0x01480148
     db4:	0001417f 	.word	0x0001417f
     db8:	feff0000 	.word	0xfeff0000
     dbc:	84e72a00 	.word	0x84e72a00
     dc0:	20001094 	.word	0x20001094
     dc4:	00000000 	.word	0x00000000

00000dc8 <ull_conn_llcp>:

	return 0;
}

int ull_conn_llcp(struct ll_conn *conn, u32_t ticks_at_expire, u16_t lazy)
{
     dc8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     dcc:	4692      	mov	sl, r2
	LL_ASSERT(conn->lll.handle != 0xFFFF);
     dce:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
     dd0:	f64f 73ff 	movw	r3, #65535	; 0xffff
     dd4:	429a      	cmp	r2, r3
{
     dd6:	b08d      	sub	sp, #52	; 0x34
     dd8:	4604      	mov	r4, r0
     dda:	4688      	mov	r8, r1
	LL_ASSERT(conn->lll.handle != 0xFFFF);
     ddc:	d10c      	bne.n	df8 <ull_conn_llcp+0x30>
     dde:	f240 3303 	movw	r3, #771	; 0x303
     de2:	4aca      	ldr	r2, [pc, #808]	; (110c <ull_conn_llcp+0x344>)
     de4:	49ca      	ldr	r1, [pc, #808]	; (1110 <ull_conn_llcp+0x348>)
     de6:	48cb      	ldr	r0, [pc, #812]	; (1114 <ull_conn_llcp+0x34c>)
     de8:	f018 fac4 	bl	19374 <printk>
     dec:	4040      	eors	r0, r0
     dee:	f380 8811 	msr	BASEPRI, r0
     df2:	f04f 0003 	mov.w	r0, #3
     df6:	df02      	svc	2

	/* Check if no other procedure with instant is requested and not in
	 * Encryption setup.
	 */
	if ((conn->llcp_ack == conn->llcp_req) &&
     df8:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
     dfc:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
     e00:	4293      	cmp	r3, r2
     e02:	d110      	bne.n	e26 <ull_conn_llcp+0x5e>
#if defined(CONFIG_BT_CTLR_LE_ENC)
	    !conn->llcp_enc.pause_rx) {
     e04:	f894 1152 	ldrb.w	r1, [r4, #338]	; 0x152
	if ((conn->llcp_ack == conn->llcp_req) &&
     e08:	f011 0501 	ands.w	r5, r1, #1
     e0c:	d10b      	bne.n	e26 <ull_conn_llcp+0x5e>
#endif /* !CONFIG_BT_CTLR_LE_ENC */

		/* TODO: Optimize the checks below, maybe have common flag */

		/* check if connection update procedure is requested */
		if (conn->llcp_cu.ack != conn->llcp_cu.req) {
     e0e:	f894 0105 	ldrb.w	r0, [r4, #261]	; 0x105
     e12:	f894 6104 	ldrb.w	r6, [r4, #260]	; 0x104
     e16:	4286      	cmp	r6, r0
     e18:	d01d      	beq.n	e56 <ull_conn_llcp+0x8e>
			/* switch to LLCP_CONN_UPD state machine */
			conn->llcp_type = LLCP_CONN_UPD;
     e1a:	2201      	movs	r2, #1
			conn->llcp_ack -= 2U;
     e1c:	3b02      	subs	r3, #2
			conn->llcp_type = LLCP_CONN_UPD;
     e1e:	f884 20ea 	strb.w	r2, [r4, #234]	; 0xea
			conn->llcp_ack -= 2U;
     e22:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
#endif /* CONFIG_BT_CTLR_PHY */
		}
	}

	/* check if procedure is requested */
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
     e26:	f894 10e8 	ldrb.w	r1, [r4, #232]	; 0xe8
     e2a:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
     e2e:	1acb      	subs	r3, r1, r3
     e30:	f003 0303 	and.w	r3, r3, #3
     e34:	2b02      	cmp	r3, #2
     e36:	f040 83bd 	bne.w	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
		switch (conn->llcp_type) {
     e3a:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
     e3e:	3b01      	subs	r3, #1
     e40:	2b05      	cmp	r3, #5
     e42:	f201 808c 	bhi.w	1f5e <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xbd6>
     e46:	e8df f013 	tbh	[pc, r3, lsl #1]
     e4a:	0363      	.short	0x0363
     e4c:	05d90589 	.word	0x05d90589
     e50:	0710088a 	.word	0x0710088a
     e54:	072f      	.short	0x072f
		} else if (conn->llcp_feature.ack != conn->llcp_feature.req) {
     e56:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
     e5a:	f894 6118 	ldrb.w	r6, [r4, #280]	; 0x118
     e5e:	42b3      	cmp	r3, r6
     e60:	d063      	beq.n	f2a <ull_conn_llcp+0x162>
static inline void event_fex_prep(struct ll_conn *conn)
{
	struct node_tx *tx;

	/* If waiting for response, do nothing */
	if (!((conn->llcp_feature.ack - conn->llcp_feature.req) & 0x01)) {
     e62:	1b9b      	subs	r3, r3, r6
     e64:	07de      	lsls	r6, r3, #31
     e66:	d5de      	bpl.n	e26 <ull_conn_llcp+0x5e>
		return;
	}

	if (conn->common.fex_valid) {
     e68:	f894 10dc 	ldrb.w	r1, [r4, #220]	; 0xdc
     e6c:	f011 0601 	ands.w	r6, r1, #1
     e70:	d02e      	beq.n	ed0 <ull_conn_llcp+0x108>
		struct node_rx_pdu *rx;
		struct pdu_data *pdu;

		/* get a rx node for ULL->LL */
		rx = ll_pdu_rx_alloc();
     e72:	f00f fa8f 	bl	10394 <ll_pdu_rx_alloc>
		if (!rx) {
     e76:	4606      	mov	r6, r0
     e78:	2800      	cmp	r0, #0
     e7a:	d0d4      	beq.n	e26 <ull_conn_llcp+0x5e>
			return;
		}

		/* procedure request acked */
		conn->llcp_feature.ack = conn->llcp_feature.req;
     e7c:	f894 3118 	ldrb.w	r3, [r4, #280]	; 0x118
     e80:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119

		/* prepare feature rsp structure */
		rx->hdr.handle = conn->lll.handle;
     e84:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
     e86:	80c3      	strh	r3, [r0, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
     e88:	2302      	movs	r3, #2
     e8a:	7103      	strb	r3, [r0, #4]
		pdu = (void *)rx->pdu;
		pdu->ll_id = PDU_DATA_LLID_CTRL;
     e8c:	f890 3020 	ldrb.w	r3, [r0, #32]
     e90:	f043 0303 	orr.w	r3, r3, #3
     e94:	f880 3020 	strb.w	r3, [r0, #32]
		pdu->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
     e98:	2309      	movs	r3, #9
     e9a:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
			   sizeof(struct pdu_data_llctrl_feature_rsp);
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
     e9e:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
		(void)memset(&pdu->llctrl.feature_rsp.features[0], 0x00,
     ea2:	2208      	movs	r2, #8
     ea4:	4629      	mov	r1, r5
     ea6:	3024      	adds	r0, #36	; 0x24
     ea8:	f01a f8d1 	bl	1b04e <memset>
			sizeof(pdu->llctrl.feature_rsp.features));
		sys_put_le24(conn->llcp_feature.features,
     eac:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
	dst[0] = val;
     eb0:	f886 3024 	strb.w	r3, [r6, #36]	; 0x24
	dst[1] = val >> 8;
     eb4:	f3c3 2207 	ubfx	r2, r3, #8, #8
	dst[2] = val >> 16;
     eb8:	0c1b      	lsrs	r3, r3, #16
	dst[1] = val >> 8;
     eba:	f886 2025 	strb.w	r2, [r6, #37]	; 0x25
	dst[2] = val >> 16;
     ebe:	f886 3026 	strb.w	r3, [r6, #38]	; 0x26
			     pdu->llctrl.feature_req.features);

		/* enqueue feature rsp structure into rx queue */
		ll_rx_put(rx->hdr.link, rx);
     ec2:	4631      	mov	r1, r6
			sys_cpu_to_le16(conn->llcp_version.company_id);
		pdu->llctrl.version_ind.sub_version_number =
			sys_cpu_to_le16(conn->llcp_version.sub_version_number);

		/* enqueue version ind structure into rx queue */
		ll_rx_put(rx->hdr.link, rx);
     ec4:	6808      	ldr	r0, [r1, #0]
     ec6:	f00f fa3d 	bl	10344 <ll_rx_put>
		ll_rx_sched();
     eca:	f00f fa45 	bl	10358 <ll_rx_sched>
     ece:	e7aa      	b.n	e26 <ull_conn_llcp+0x5e>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
     ed0:	4891      	ldr	r0, [pc, #580]	; (1118 <ull_conn_llcp+0x350>)
     ed2:	f01b ffcb 	bl	1ce6c <mem_acquire>
	if (tx) {
     ed6:	4605      	mov	r5, r0
     ed8:	2800      	cmp	r0, #0
     eda:	d0a4      	beq.n	e26 <ull_conn_llcp+0x5e>
		conn->llcp_feature.ack--;
     edc:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
     ee0:	3b01      	subs	r3, #1
     ee2:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
		conn->llcp_feature.features = LL_FEAT;
     ee6:	4b8d      	ldr	r3, [pc, #564]	; (111c <ull_conn_llcp+0x354>)
     ee8:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
		pdu->ll_id = PDU_DATA_LLID_CTRL;
     eec:	7903      	ldrb	r3, [r0, #4]
     eee:	f043 0303 	orr.w	r3, r3, #3
     ef2:	7103      	strb	r3, [r0, #4]
		pdu->len = offsetof(struct pdu_data_llctrl, feature_req) +
     ef4:	2309      	movs	r3, #9
     ef6:	7143      	strb	r3, [r0, #5]
		pdu->llctrl.opcode = !conn->lll.role ?
     ef8:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
     efc:	2b00      	cmp	r3, #0
     efe:	bfac      	ite	ge
     f00:	2308      	movge	r3, #8
     f02:	230e      	movlt	r3, #14
		(void)memset(&pdu->llctrl.feature_req.features[0],
     f04:	2208      	movs	r2, #8
		pdu->llctrl.opcode = !conn->lll.role ?
     f06:	71c3      	strb	r3, [r0, #7]
		(void)memset(&pdu->llctrl.feature_req.features[0],
     f08:	4631      	mov	r1, r6
     f0a:	4410      	add	r0, r2
     f0c:	f01a f89f 	bl	1b04e <memset>
		sys_put_le24(conn->llcp_feature.features,
     f10:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
	dst[0] = val;
     f14:	722b      	strb	r3, [r5, #8]
	dst[1] = val >> 8;
     f16:	f3c3 2207 	ubfx	r2, r3, #8, #8
	dst[2] = val >> 16;
     f1a:	0c1b      	lsrs	r3, r3, #16
	dst[1] = val >> 8;
     f1c:	726a      	strb	r2, [r5, #9]
	dst[2] = val >> 16;
     f1e:	72ab      	strb	r3, [r5, #10]
		ctrl_tx_enqueue(conn, tx);
     f20:	4629      	mov	r1, r5

		pr = &pdu_ctrl_tx->llctrl.phy_req;
		pr->tx_phys = conn->llcp_phy.tx;
		pr->rx_phys = conn->llcp_phy.rx;

		ctrl_tx_enqueue(conn, tx);
     f22:	4620      	mov	r0, r4
     f24:	f01c fb6b 	bl	1d5fe <ctrl_tx_enqueue>
     f28:	e0ca      	b.n	10c0 <ull_conn_llcp+0x2f8>
		} else if (conn->llcp_version.ack != conn->llcp_version.req) {
     f2a:	f894 3121 	ldrb.w	r3, [r4, #289]	; 0x121
     f2e:	f894 5120 	ldrb.w	r5, [r4, #288]	; 0x120
     f32:	42ab      	cmp	r3, r5
     f34:	d064      	beq.n	1000 <ull_conn_llcp+0x238>
	if (!((conn->llcp_version.ack - conn->llcp_version.req) & 0x01)) {
     f36:	1b5b      	subs	r3, r3, r5
     f38:	07d8      	lsls	r0, r3, #31
     f3a:	f57f af74 	bpl.w	e26 <ull_conn_llcp+0x5e>
	if (conn->llcp_version.tx == 0U) {
     f3e:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
     f42:	07d9      	lsls	r1, r3, #31
     f44:	d425      	bmi.n	f92 <ull_conn_llcp+0x1ca>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
     f46:	4874      	ldr	r0, [pc, #464]	; (1118 <ull_conn_llcp+0x350>)
     f48:	f01b ff90 	bl	1ce6c <mem_acquire>
		if (tx) {
     f4c:	4601      	mov	r1, r0
     f4e:	2800      	cmp	r0, #0
     f50:	f43f af69 	beq.w	e26 <ull_conn_llcp+0x5e>
			conn->llcp_version.ack--;
     f54:	f894 3121 	ldrb.w	r3, [r4, #289]	; 0x121
     f58:	3b01      	subs	r3, #1
     f5a:	f884 3121 	strb.w	r3, [r4, #289]	; 0x121
			conn->llcp_version.tx = 1U;
     f5e:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
     f62:	f043 0301 	orr.w	r3, r3, #1
     f66:	f884 3122 	strb.w	r3, [r4, #290]	; 0x122
			pdu->ll_id = PDU_DATA_LLID_CTRL;
     f6a:	7903      	ldrb	r3, [r0, #4]
     f6c:	f043 0303 	orr.w	r3, r3, #3
     f70:	7103      	strb	r3, [r0, #4]
			pdu->len =
     f72:	2306      	movs	r3, #6
     f74:	7143      	strb	r3, [r0, #5]
			pdu->llctrl.opcode =
     f76:	230c      	movs	r3, #12
     f78:	71c3      	strb	r3, [r0, #7]
			pdu->llctrl.version_ind.version_number =
     f7a:	230a      	movs	r3, #10
     f7c:	7203      	strb	r3, [r0, #8]
			pdu->llctrl.version_ind.company_id = cid;
     f7e:	f06f 030e 	mvn.w	r3, #14
     f82:	7243      	strb	r3, [r0, #9]
     f84:	2305      	movs	r3, #5
     f86:	7283      	strb	r3, [r0, #10]
			pdu->llctrl.version_ind.sub_version_number = svn;
     f88:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
     f8c:	72c3      	strb	r3, [r0, #11]
     f8e:	7303      	strb	r3, [r0, #12]
			ctrl_tx_enqueue(conn, tx);
     f90:	e7c7      	b.n	f22 <ull_conn_llcp+0x15a>
	} else if (conn->llcp_version.rx) {
     f92:	079a      	lsls	r2, r3, #30
     f94:	d526      	bpl.n	fe4 <ull_conn_llcp+0x21c>
		rx = ll_pdu_rx_alloc();
     f96:	f00f f9fd 	bl	10394 <ll_pdu_rx_alloc>
		if (!rx) {
     f9a:	4601      	mov	r1, r0
     f9c:	2800      	cmp	r0, #0
     f9e:	f43f af42 	beq.w	e26 <ull_conn_llcp+0x5e>
		conn->llcp_version.ack = conn->llcp_version.req;
     fa2:	f894 3120 	ldrb.w	r3, [r4, #288]	; 0x120
     fa6:	f884 3121 	strb.w	r3, [r4, #289]	; 0x121
		rx->hdr.handle = conn->lll.handle;
     faa:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
     fac:	80c3      	strh	r3, [r0, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
     fae:	2302      	movs	r3, #2
     fb0:	7103      	strb	r3, [r0, #4]
		pdu->ll_id = PDU_DATA_LLID_CTRL;
     fb2:	f890 3020 	ldrb.w	r3, [r0, #32]
     fb6:	f043 0303 	orr.w	r3, r3, #3
     fba:	f880 3020 	strb.w	r3, [r0, #32]
		pdu->len = offsetof(struct pdu_data_llctrl, version_ind) +
     fbe:	2306      	movs	r3, #6
     fc0:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
     fc4:	230c      	movs	r3, #12
     fc6:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
		pdu->llctrl.version_ind.version_number =
     fca:	f894 3123 	ldrb.w	r3, [r4, #291]	; 0x123
     fce:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
		pdu->llctrl.version_ind.company_id =
     fd2:	f8b4 3124 	ldrh.w	r3, [r4, #292]	; 0x124
     fd6:	f8a0 3025 	strh.w	r3, [r0, #37]	; 0x25
		pdu->llctrl.version_ind.sub_version_number =
     fda:	f8b4 3126 	ldrh.w	r3, [r4, #294]	; 0x126
     fde:	f8a0 3027 	strh.w	r3, [r0, #39]	; 0x27
     fe2:	e76f      	b.n	ec4 <ull_conn_llcp+0xfc>
		LL_ASSERT(0);
     fe4:	f640 3302 	movw	r3, #2818	; 0xb02
	case LLCP_PHY_STATE_RSP_WAIT:
		/* no nothing */
		break;

	default:
		LL_ASSERT(0);
     fe8:	4a48      	ldr	r2, [pc, #288]	; (110c <ull_conn_llcp+0x344>)
     fea:	494d      	ldr	r1, [pc, #308]	; (1120 <ull_conn_llcp+0x358>)
     fec:	4849      	ldr	r0, [pc, #292]	; (1114 <ull_conn_llcp+0x34c>)
     fee:	f018 f9c1 	bl	19374 <printk>
     ff2:	4040      	eors	r0, r0
     ff4:	f380 8811 	msr	BASEPRI, r0
     ff8:	f04f 0003 	mov.w	r0, #3
     ffc:	df02      	svc	2
		break;
     ffe:	e712      	b.n	e26 <ull_conn_llcp+0x5e>
		} else if (conn->llcp_conn_param.ack !=
    1000:	f894 5171 	ldrb.w	r5, [r4, #369]	; 0x171
    1004:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
    1008:	429d      	cmp	r5, r3
    100a:	f000 8138 	beq.w	127e <ull_conn_llcp+0x4b6>
	conn_upd = conn_upd_curr;
    100e:	4d45      	ldr	r5, [pc, #276]	; (1124 <ull_conn_llcp+0x35c>)
    1010:	682b      	ldr	r3, [r5, #0]
	if (conn_upd && (conn_upd != conn)) {
    1012:	b113      	cbz	r3, 101a <ull_conn_llcp+0x252>
    1014:	429c      	cmp	r4, r3
    1016:	f47f af06 	bne.w	e26 <ull_conn_llcp+0x5e>
	switch (conn->llcp_conn_param.state) {
    101a:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
    101e:	f003 0307 	and.w	r3, r3, #7
    1022:	2b05      	cmp	r3, #5
    1024:	f200 8128 	bhi.w	1278 <ull_conn_llcp+0x4b0>
    1028:	a201      	add	r2, pc, #4	; (adr r2, 1030 <ull_conn_llcp+0x268>)
    102a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    102e:	bf00      	nop
    1030:	00001049 	.word	0x00001049
    1034:	000010cb 	.word	0x000010cb
    1038:	00001221 	.word	0x00001221
    103c:	00000e27 	.word	0x00000e27
    1040:	00000e27 	.word	0x00000e27
    1044:	00000e27 	.word	0x00000e27
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    1048:	4833      	ldr	r0, [pc, #204]	; (1118 <ull_conn_llcp+0x350>)
			event_counter = lll->event_counter +
    104a:	8ee6      	ldrh	r6, [r4, #54]	; 0x36
					lll->latency_prepare + lazy;
    104c:	8e67      	ldrh	r7, [r4, #50]	; 0x32
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    104e:	f01b ff0d 	bl	1ce6c <mem_acquire>
	if (!tx) {
    1052:	4601      	mov	r1, r0
    1054:	2800      	cmp	r0, #0
    1056:	f43f aee6 	beq.w	e26 <ull_conn_llcp+0x5e>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP_WAIT;
    105a:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
    105e:	2204      	movs	r2, #4
    1060:	f362 0302 	bfi	r3, r2, #0, #3
    1064:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    1068:	7903      	ldrb	r3, [r0, #4]
    106a:	f043 0303 	orr.w	r3, r3, #3
    106e:	7103      	strb	r3, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
    1070:	2318      	movs	r3, #24
    1072:	7143      	strb	r3, [r0, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
    1074:	230f      	movs	r3, #15
    1076:	71c3      	strb	r3, [r0, #7]
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
    1078:	f8b4 3174 	ldrh.w	r3, [r4, #372]	; 0x174
    107c:	8103      	strh	r3, [r0, #8]
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
    107e:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
    1082:	8143      	strh	r3, [r0, #10]
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
    1084:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
    1088:	8183      	strh	r3, [r0, #12]
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
    108a:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
    108e:	81c3      	strh	r3, [r0, #14]
			event_counter = lll->event_counter +
    1090:	443e      	add	r6, r7
	p->preferred_periodicity = 0U;
    1092:	2300      	movs	r3, #0
    1094:	7403      	strb	r3, [r0, #16]
	p->offset0 = sys_cpu_to_le16(0x0000);
    1096:	74c3      	strb	r3, [r0, #19]
    1098:	7503      	strb	r3, [r0, #20]
	p->reference_conn_event_count = sys_cpu_to_le16(event_counter);
    109a:	4456      	add	r6, sl
	p->offset1 = sys_cpu_to_le16(0xffff);
    109c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	p->reference_conn_event_count = sys_cpu_to_le16(event_counter);
    10a0:	f8a0 6011 	strh.w	r6, [r0, #17]
	p->offset1 = sys_cpu_to_le16(0xffff);
    10a4:	7543      	strb	r3, [r0, #21]
    10a6:	7583      	strb	r3, [r0, #22]
	p->offset2 = sys_cpu_to_le16(0xffff);
    10a8:	75c3      	strb	r3, [r0, #23]
    10aa:	7603      	strb	r3, [r0, #24]
	p->offset3 = sys_cpu_to_le16(0xffff);
    10ac:	7643      	strb	r3, [r0, #25]
    10ae:	7683      	strb	r3, [r0, #26]
	p->offset4 = sys_cpu_to_le16(0xffff);
    10b0:	76c3      	strb	r3, [r0, #27]
    10b2:	7703      	strb	r3, [r0, #28]
	p->offset5 = sys_cpu_to_le16(0xffff);
    10b4:	7743      	strb	r3, [r0, #29]
    10b6:	7783      	strb	r3, [r0, #30]
	ctrl_tx_enqueue(conn, tx);
    10b8:	4620      	mov	r0, r4
    10ba:	f01c faa0 	bl	1d5fe <ctrl_tx_enqueue>
	conn_upd_curr = conn;
    10be:	602c      	str	r4, [r5, #0]
		conn->procedure_expire = conn->procedure_reload;
    10c0:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
    10c4:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	break;
    10c8:	e6ad      	b.n	e26 <ull_conn_llcp+0x5e>
	if (conn->llcp_conn_param.status) {
    10ca:	f894 6173 	ldrb.w	r6, [r4, #371]	; 0x173
    10ce:	b35e      	cbz	r6, 1128 <ull_conn_llcp+0x360>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    10d0:	4811      	ldr	r0, [pc, #68]	; (1118 <ull_conn_llcp+0x350>)
    10d2:	f01b fecb 	bl	1ce6c <mem_acquire>
		if (!tx) {
    10d6:	4601      	mov	r1, r0
    10d8:	2800      	cmp	r0, #0
    10da:	f43f aea4 	beq.w	e26 <ull_conn_llcp+0x5e>
		pdu->ll_id = PDU_DATA_LLID_CTRL;
    10de:	7903      	ldrb	r3, [r0, #4]
    10e0:	f043 0303 	orr.w	r3, r3, #3
    10e4:	7103      	strb	r3, [r0, #4]
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
    10e6:	2311      	movs	r3, #17
    10e8:	71c3      	strb	r3, [r0, #7]
		pdu->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
    10ea:	2303      	movs	r3, #3
    10ec:	7143      	strb	r3, [r0, #5]
		rej->reject_opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
    10ee:	230f      	movs	r3, #15
    10f0:	7203      	strb	r3, [r0, #8]
		rej->error_code = conn->llcp_conn_param.status;
    10f2:	f894 3173 	ldrb.w	r3, [r4, #371]	; 0x173
    10f6:	7243      	strb	r3, [r0, #9]
		ctrl_tx_enqueue(conn, tx);
    10f8:	4620      	mov	r0, r4
    10fa:	f01c fa80 	bl	1d5fe <ctrl_tx_enqueue>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
    10fe:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
    1102:	f884 3171 	strb.w	r3, [r4, #369]	; 0x171
		conn_upd_curr = NULL;
    1106:	2300      	movs	r3, #0
    1108:	602b      	str	r3, [r5, #0]
		return;
    110a:	e68c      	b.n	e26 <ull_conn_llcp+0x5e>
    110c:	00021f06 	.word	0x00021f06
    1110:	00021fb2 	.word	0x00021fb2
    1114:	00020aa4 	.word	0x00020aa4
    1118:	200013d4 	.word	0x200013d4
    111c:	0001417f 	.word	0x0001417f
    1120:	00022577 	.word	0x00022577
    1124:	20001354 	.word	0x20001354
	if (!conn->lll.role) {
    1128:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
    112c:	2b00      	cmp	r3, #0
    112e:	db34      	blt.n	119a <ull_conn_llcp+0x3d2>
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
    1130:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
		conn->llcp_cu.win_offset_us = 0U;
    1134:	f8c4 6110 	str.w	r6, [r4, #272]	; 0x110
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
    1138:	2205      	movs	r2, #5
    113a:	f362 0302 	bfi	r3, r2, #0, #3
		if (conn->llcp_conn_param.preferred_periodicity) {
    113e:	f894 217c 	ldrb.w	r2, [r4, #380]	; 0x17c
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
    1142:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
		conn->llcp_cu.win_size = 1U;
    1146:	2301      	movs	r3, #1
    1148:	f884 3114 	strb.w	r3, [r4, #276]	; 0x114
		if (conn->llcp_conn_param.preferred_periodicity) {
    114c:	b312      	cbz	r2, 1194 <ull_conn_llcp+0x3cc>
				((conn->llcp_conn_param.interval_min /
    114e:	f8b4 3174 	ldrh.w	r3, [r4, #372]	; 0x174
    1152:	fbb3 f3f2 	udiv	r3, r3, r2
				  conn->llcp_conn_param.preferred_periodicity) +
    1156:	3301      	adds	r3, #1
			conn->llcp_cu.interval =
    1158:	fb13 f302 	smulbb	r3, r3, r2
    115c:	b29b      	uxth	r3, r3
    115e:	f8a4 3108 	strh.w	r3, [r4, #264]	; 0x108
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
    1162:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
    1166:	f8a4 310a 	strh.w	r3, [r4, #266]	; 0x10a
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
    116a:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
    116e:	f8a4 310c 	strh.w	r3, [r4, #268]	; 0x10c
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
    1172:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
    1176:	2202      	movs	r2, #2
    1178:	f362 0301 	bfi	r3, r2, #0, #2
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
    117c:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
    1180:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    1184:	f362 0382 	bfi	r3, r2, #2, #1
		conn->llcp_cu.ack--;
    1188:	3801      	subs	r0, #1
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
    118a:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
		conn->llcp_cu.ack--;
    118e:	f884 0105 	strb.w	r0, [r4, #261]	; 0x105
		return;
    1192:	e648      	b.n	e26 <ull_conn_llcp+0x5e>
				conn->llcp_conn_param.interval_max;
    1194:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
    1198:	e7e1      	b.n	115e <ull_conn_llcp+0x396>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    119a:	48d9      	ldr	r0, [pc, #868]	; (1500 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x178>)
    119c:	f01b fe66 	bl	1ce6c <mem_acquire>
	if (!tx) {
    11a0:	4601      	mov	r1, r0
    11a2:	2800      	cmp	r0, #0
    11a4:	f43f ae3f 	beq.w	e26 <ull_conn_llcp+0x5e>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
    11a8:	7903      	ldrb	r3, [r0, #4]
    11aa:	f043 0303 	orr.w	r3, r3, #3
    11ae:	7103      	strb	r3, [r0, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_rsp) +
    11b0:	2318      	movs	r3, #24
    11b2:	7143      	strb	r3, [r0, #5]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_RSP;
    11b4:	2310      	movs	r3, #16
    11b6:	71c3      	strb	r3, [r0, #7]
	rsp->interval_min =
    11b8:	f8b4 3174 	ldrh.w	r3, [r4, #372]	; 0x174
    11bc:	8103      	strh	r3, [r0, #8]
	rsp->interval_max =
    11be:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
    11c2:	8143      	strh	r3, [r0, #10]
	rsp->latency =
    11c4:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
    11c8:	8183      	strh	r3, [r0, #12]
	rsp->timeout =
    11ca:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
    11ce:	81c3      	strh	r3, [r0, #14]
	rsp->preferred_periodicity =
    11d0:	f894 317c 	ldrb.w	r3, [r4, #380]	; 0x17c
    11d4:	7403      	strb	r3, [r0, #16]
	rsp->reference_conn_event_count =
    11d6:	f8b4 317e 	ldrh.w	r3, [r4, #382]	; 0x17e
    11da:	f8a0 3011 	strh.w	r3, [r0, #17]
	rsp->offset0 = sys_cpu_to_le16(conn->llcp_conn_param.offset0);
    11de:	f8b4 3180 	ldrh.w	r3, [r4, #384]	; 0x180
    11e2:	f8a0 3013 	strh.w	r3, [r0, #19]
	rsp->offset1 = sys_cpu_to_le16(conn->llcp_conn_param.offset1);
    11e6:	f8b4 3182 	ldrh.w	r3, [r4, #386]	; 0x182
    11ea:	f8a0 3015 	strh.w	r3, [r0, #21]
	rsp->offset2 = sys_cpu_to_le16(conn->llcp_conn_param.offset2);
    11ee:	f8b4 3184 	ldrh.w	r3, [r4, #388]	; 0x184
    11f2:	f8a0 3017 	strh.w	r3, [r0, #23]
	rsp->offset3 = sys_cpu_to_le16(conn->llcp_conn_param.offset3);
    11f6:	f8b4 3186 	ldrh.w	r3, [r4, #390]	; 0x186
    11fa:	f8a0 3019 	strh.w	r3, [r0, #25]
	rsp->offset4 = sys_cpu_to_le16(conn->llcp_conn_param.offset4);
    11fe:	f8b4 3188 	ldrh.w	r3, [r4, #392]	; 0x188
    1202:	f8a0 301b 	strh.w	r3, [r0, #27]
	rsp->offset5 = sys_cpu_to_le16(conn->llcp_conn_param.offset5);
    1206:	f8b4 318a 	ldrh.w	r3, [r4, #394]	; 0x18a
    120a:	f8a0 301d 	strh.w	r3, [r0, #29]
	ctrl_tx_enqueue(conn, tx);
    120e:	4620      	mov	r0, r4
    1210:	f01c f9f5 	bl	1d5fe <ctrl_tx_enqueue>
	conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
    1214:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
    1218:	f884 3171 	strb.w	r3, [r4, #369]	; 0x171
	conn_upd_curr = NULL;
    121c:	602e      	str	r6, [r5, #0]
    121e:	e602      	b.n	e26 <ull_conn_llcp+0x5e>
	if (conn->llcp_enc.pause_tx) {
    1220:	078b      	lsls	r3, r1, #30
    1222:	f53f ae00 	bmi.w	e26 <ull_conn_llcp+0x5e>
	rx = ll_pdu_rx_alloc();
    1226:	f00f f8b5 	bl	10394 <ll_pdu_rx_alloc>
	if (!rx) {
    122a:	4601      	mov	r1, r0
    122c:	2800      	cmp	r0, #0
    122e:	f43f adfa 	beq.w	e26 <ull_conn_llcp+0x5e>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_APP_WAIT;
    1232:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
    1236:	2203      	movs	r2, #3
    1238:	f362 0302 	bfi	r3, r2, #0, #3
    123c:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
	rx->hdr.handle = conn->lll.handle;
    1240:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    1242:	80c3      	strh	r3, [r0, #6]
	rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    1244:	2302      	movs	r3, #2
    1246:	7103      	strb	r3, [r0, #4]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
    1248:	f890 3020 	ldrb.w	r3, [r0, #32]
    124c:	4313      	orrs	r3, r2
    124e:	f880 3020 	strb.w	r3, [r0, #32]
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
    1252:	2318      	movs	r3, #24
    1254:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
    1258:	230f      	movs	r3, #15
    125a:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
    125e:	f8b4 3174 	ldrh.w	r3, [r4, #372]	; 0x174
    1262:	8483      	strh	r3, [r0, #36]	; 0x24
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
    1264:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
    1268:	84c3      	strh	r3, [r0, #38]	; 0x26
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
    126a:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
    126e:	8503      	strh	r3, [r0, #40]	; 0x28
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
    1270:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
    1274:	8543      	strh	r3, [r0, #42]	; 0x2a
	ll_rx_put(rx->hdr.link, rx);
    1276:	e625      	b.n	ec4 <ull_conn_llcp+0xfc>
		LL_ASSERT(0);
    1278:	f640 430f 	movw	r3, #3087	; 0xc0f
    127c:	e6b4      	b.n	fe8 <ull_conn_llcp+0x220>
		} else if (conn->llcp_length.ack != conn->llcp_length.req) {
    127e:	f894 0198 	ldrb.w	r0, [r4, #408]	; 0x198
    1282:	f894 3199 	ldrb.w	r3, [r4, #409]	; 0x199
    1286:	4283      	cmp	r3, r0
    1288:	f000 8099 	beq.w	13be <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x36>
	switch (conn->llcp_length.state) {
    128c:	f894 319a 	ldrb.w	r3, [r4, #410]	; 0x19a
    1290:	f3c3 0502 	ubfx	r5, r3, #0, #3
    1294:	b2e9      	uxtb	r1, r5
    1296:	2907      	cmp	r1, #7
    1298:	f000 808e 	beq.w	13b8 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x30>
    129c:	2201      	movs	r2, #1
    129e:	408a      	lsls	r2, r1
    12a0:	f012 0f4e 	tst.w	r2, #78	; 0x4e
    12a4:	f47f adbf 	bne.w	e26 <ull_conn_llcp+0x5e>
    12a8:	f012 0f30 	tst.w	r2, #48	; 0x30
    12ac:	d12d      	bne.n	130a <ull_conn_llcp+0x542>
    12ae:	2900      	cmp	r1, #0
    12b0:	f040 8082 	bne.w	13b8 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x30>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    12b4:	4892      	ldr	r0, [pc, #584]	; (1500 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x178>)
    12b6:	f01b fdd9 	bl	1ce6c <mem_acquire>
		if (!tx) {
    12ba:	4601      	mov	r1, r0
    12bc:	2800      	cmp	r0, #0
    12be:	f43f adb2 	beq.w	e26 <ull_conn_llcp+0x5e>
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
    12c2:	f894 319a 	ldrb.w	r3, [r4, #410]	; 0x19a
		conn->default_tx_time = conn->llcp_length.tx_time;
    12c6:	f8b4 01a2 	ldrh.w	r0, [r4, #418]	; 0x1a2
    12ca:	f8a4 00d8 	strh.w	r0, [r4, #216]	; 0xd8
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
    12ce:	2201      	movs	r2, #1
    12d0:	f362 0302 	bfi	r3, r2, #0, #3
    12d4:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
		conn->default_tx_octets = conn->llcp_length.tx_octets;
    12d8:	f8b4 319e 	ldrh.w	r3, [r4, #414]	; 0x19e
    12dc:	f8a4 30d6 	strh.w	r3, [r4, #214]	; 0xd6
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    12e0:	790a      	ldrb	r2, [r1, #4]
		lr->max_tx_octets = sys_cpu_to_le16(conn->default_tx_octets);
    12e2:	818b      	strh	r3, [r1, #12]
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    12e4:	f042 0203 	orr.w	r2, r2, #3
    12e8:	710a      	strb	r2, [r1, #4]
		pdu_ctrl_tx->len =
    12ea:	2209      	movs	r2, #9
		lr->max_rx_time = sys_cpu_to_le16(rx_time);
    12ec:	f045 0348 	orr.w	r3, r5, #72	; 0x48
		pdu_ctrl_tx->len =
    12f0:	714a      	strb	r2, [r1, #5]
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_REQ;
    12f2:	2214      	movs	r2, #20
    12f4:	71ca      	strb	r2, [r1, #7]
		lr->max_rx_time = sys_cpu_to_le16(rx_time);
    12f6:	728b      	strb	r3, [r1, #10]
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
    12f8:	f045 021b 	orr.w	r2, r5, #27
		lr->max_rx_time = sys_cpu_to_le16(rx_time);
    12fc:	f045 0301 	orr.w	r3, r5, #1
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
    1300:	720a      	strb	r2, [r1, #8]
    1302:	724d      	strb	r5, [r1, #9]
		lr->max_rx_time = sys_cpu_to_le16(rx_time);
    1304:	72cb      	strb	r3, [r1, #11]
		lr->max_tx_time = sys_cpu_to_le16(tx_time);
    1306:	81c8      	strh	r0, [r1, #14]
		ctrl_tx_enqueue(conn, tx);
    1308:	e60b      	b.n	f22 <ull_conn_llcp+0x15a>
		lll->max_rx_octets = conn->llcp_length.rx_octets;
    130a:	f8b4 219c 	ldrh.w	r2, [r4, #412]	; 0x19c
    130e:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
		lll->max_rx_time = conn->llcp_length.rx_time;
    1312:	f8b4 21a0 	ldrh.w	r2, [r4, #416]	; 0x1a0
    1316:	f8a4 2062 	strh.w	r2, [r4, #98]	; 0x62
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
    131a:	f003 0207 	and.w	r2, r3, #7
    131e:	2a04      	cmp	r2, #4
		tx_octets = conn->llcp_length.tx_octets;
    1320:	f8b4 619e 	ldrh.w	r6, [r4, #414]	; 0x19e
		u16_t tx_time = conn->llcp_length.tx_time;
    1324:	f8b4 51a2 	ldrh.w	r5, [r4, #418]	; 0x1a2
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
    1328:	d144      	bne.n	13b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2c>
			if (!conn->llcp_length.cache.tx_octets) {
    132a:	f8b4 21a4 	ldrh.w	r2, [r4, #420]	; 0x1a4
    132e:	bb9a      	cbnz	r2, 1398 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x10>
				conn->llcp_length.ack = conn->llcp_length.req;
    1330:	f884 0199 	strb.w	r0, [r4, #409]	; 0x199
				conn->procedure_expire = 0U;
    1334:	f8a4 20cc 	strh.w	r2, [r4, #204]	; 0xcc
		rx = conn->llcp_rx;
    1338:	f8d4 7100 	ldr.w	r7, [r4, #256]	; 0x100
		LL_ASSERT(rx && rx->hdr.link);
    133c:	b10f      	cbz	r7, 1342 <ull_conn_llcp+0x57a>
    133e:	683b      	ldr	r3, [r7, #0]
    1340:	b963      	cbnz	r3, 135c <ull_conn_llcp+0x594>
    1342:	f640 43ce 	movw	r3, #3278	; 0xcce
    1346:	4a6f      	ldr	r2, [pc, #444]	; (1504 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x17c>)
    1348:	496f      	ldr	r1, [pc, #444]	; (1508 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x180>)
    134a:	4870      	ldr	r0, [pc, #448]	; (150c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x184>)
    134c:	f018 f812 	bl	19374 <printk>
    1350:	4040      	eors	r0, r0
    1352:	f380 8811 	msr	BASEPRI, r0
    1356:	f04f 0003 	mov.w	r0, #3
    135a:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
    135c:	6838      	ldr	r0, [r7, #0]
    135e:	6843      	ldr	r3, [r0, #4]
    1360:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		rx->hdr.handle = conn->lll.handle;
    1364:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    1366:	80fb      	strh	r3, [r7, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    1368:	2302      	movs	r3, #2
    136a:	713b      	strb	r3, [r7, #4]
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
    136c:	f897 3020 	ldrb.w	r3, [r7, #32]
    1370:	f043 0303 	orr.w	r3, r3, #3
    1374:	f887 3020 	strb.w	r3, [r7, #32]
		pdu_ctrl_rx->len =
    1378:	2309      	movs	r3, #9
    137a:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
		pdu_ctrl_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
    137e:	2315      	movs	r3, #21
    1380:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
    1384:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
    1388:	84bb      	strh	r3, [r7, #36]	; 0x24
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
    138a:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
		lr->max_tx_octets = sys_cpu_to_le16(tx_octets);
    138e:	853e      	strh	r6, [r7, #40]	; 0x28
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
    1390:	84fb      	strh	r3, [r7, #38]	; 0x26
		lr->max_tx_time = sys_cpu_to_le16(tx_time);
    1392:	857d      	strh	r5, [r7, #42]	; 0x2a
		ll_rx_put(rx->hdr.link, rx);
    1394:	4639      	mov	r1, r7
    1396:	e596      	b.n	ec6 <ull_conn_llcp+0xfe>
				conn->llcp_length.tx_octets =
    1398:	f8a4 219e 	strh.w	r2, [r4, #414]	; 0x19e
				conn->llcp_length.tx_time =
    139c:	f8b4 11a6 	ldrh.w	r1, [r4, #422]	; 0x1a6
    13a0:	f8a4 11a2 	strh.w	r1, [r4, #418]	; 0x1a2
				conn->llcp_length.cache.tx_octets = 0;
    13a4:	2200      	movs	r2, #0
    13a6:	f8a4 21a4 	strh.w	r2, [r4, #420]	; 0x1a4
			conn->llcp_length.state =
    13aa:	f362 0302 	bfi	r3, r2, #0, #3
    13ae:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
    13b2:	e7c1      	b.n	1338 <ull_conn_llcp+0x570>
    13b4:	2206      	movs	r2, #6
    13b6:	e7f8      	b.n	13aa <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22>
		LL_ASSERT(0);
    13b8:	f640 43f6 	movw	r3, #3318	; 0xcf6
    13bc:	e614      	b.n	fe8 <ull_conn_llcp+0x220>
		} else if (conn->llcp_phy.ack != conn->llcp_phy.req) {
    13be:	f894 11a8 	ldrb.w	r1, [r4, #424]	; 0x1a8
    13c2:	f894 31a9 	ldrb.w	r3, [r4, #425]	; 0x1a9
    13c6:	428b      	cmp	r3, r1
    13c8:	f43f ad2d 	beq.w	e26 <ull_conn_llcp+0x5e>
	switch (conn->llcp_phy.state) {
    13cc:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
    13d0:	f003 0003 	and.w	r0, r3, #3
    13d4:	2803      	cmp	r0, #3
    13d6:	f200 808f 	bhi.w	14f8 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x170>
    13da:	a501      	add	r5, pc, #4	; (adr r5, 13e0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x58>)
    13dc:	f855 f020 	ldr.w	pc, [r5, r0, lsl #2]
    13e0:	000013f1 	.word	0x000013f1
    13e4:	00000e27 	.word	0x00000e27
    13e8:	00000e27 	.word	0x00000e27
    13ec:	00001455 	.word	0x00001455
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    13f0:	4843      	ldr	r0, [pc, #268]	; (1500 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x178>)
    13f2:	f01b fd3b 	bl	1ce6c <mem_acquire>
		if (!tx) {
    13f6:	4601      	mov	r1, r0
    13f8:	2800      	cmp	r0, #0
    13fa:	f43f ad14 	beq.w	e26 <ull_conn_llcp+0x5e>
		conn->phy_pref_tx = conn->llcp_phy.tx;
    13fe:	f894 21aa 	ldrb.w	r2, [r4, #426]	; 0x1aa
    1402:	f894 31ac 	ldrb.w	r3, [r4, #428]	; 0x1ac
		conn->phy_pref_flags = conn->llcp_phy.flags;
    1406:	f894 51ab 	ldrb.w	r5, [r4, #427]	; 0x1ab
		conn->phy_pref_tx = conn->llcp_phy.tx;
    140a:	f3c2 0082 	ubfx	r0, r2, #2, #3
    140e:	f360 0302 	bfi	r3, r0, #0, #3
		conn->phy_pref_rx = conn->llcp_phy.rx;
    1412:	f3c2 1242 	ubfx	r2, r2, #5, #3
    1416:	f362 1306 	bfi	r3, r2, #4, #3
		conn->phy_pref_flags = conn->llcp_phy.flags;
    141a:	f3c5 0540 	ubfx	r5, r5, #1, #1
    141e:	f365 03c3 	bfi	r3, r5, #3, #1
    1422:	f884 31ac 	strb.w	r3, [r4, #428]	; 0x1ac
		conn->llcp_phy.state = LLCP_PHY_STATE_ACK_WAIT;
    1426:	f8b4 31aa 	ldrh.w	r3, [r4, #426]	; 0x1aa
    142a:	f423 7381 	bic.w	r3, r3, #258	; 0x102
    142e:	f023 0301 	bic.w	r3, r3, #1
    1432:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    1436:	f043 0301 	orr.w	r3, r3, #1
    143a:	f8a4 31aa 	strh.w	r3, [r4, #426]	; 0x1aa
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    143e:	790b      	ldrb	r3, [r1, #4]
		pr->tx_phys = conn->llcp_phy.tx;
    1440:	7208      	strb	r0, [r1, #8]
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    1442:	f043 0303 	orr.w	r3, r3, #3
    1446:	710b      	strb	r3, [r1, #4]
		pdu_ctrl_tx->len =
    1448:	2303      	movs	r3, #3
    144a:	714b      	strb	r3, [r1, #5]
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_REQ;
    144c:	2316      	movs	r3, #22
    144e:	71cb      	strb	r3, [r1, #7]
		pr->rx_phys = conn->llcp_phy.rx;
    1450:	724a      	strb	r2, [r1, #9]
    1452:	e566      	b.n	f22 <ull_conn_llcp+0x15a>
		conn->llcp_phy.ack = conn->llcp_phy.req;
    1454:	f884 11a9 	strb.w	r1, [r4, #425]	; 0x1a9
		if (conn->llcp_phy.tx & BIT(1)) {
    1458:	f3c3 0182 	ubfx	r1, r3, #2, #3
    145c:	078f      	lsls	r7, r1, #30
    145e:	d539      	bpl.n	14d4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x14c>
			conn->llcp_phy.tx = BIT(1);
    1460:	2102      	movs	r1, #2
			conn->llcp_phy.tx = 0U;
    1462:	f361 0384 	bfi	r3, r1, #2, #3
    1466:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
		if (conn->llcp_phy.rx & BIT(1)) {
    146a:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
    146e:	0959      	lsrs	r1, r3, #5
    1470:	078d      	lsls	r5, r1, #30
    1472:	d538      	bpl.n	14e6 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x15e>
			conn->llcp_phy.rx = BIT(1);
    1474:	2102      	movs	r1, #2
			conn->llcp_phy.rx = 0U;
    1476:	f361 1347 	bfi	r3, r1, #5, #3
    147a:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
		if (conn->llcp_phy.tx != conn->lll.phy_tx) {
    147e:	f894 11aa 	ldrb.w	r1, [r4, #426]	; 0x1aa
    1482:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
    1486:	f3c1 0082 	ubfx	r0, r1, #2, #3
    148a:	f003 0307 	and.w	r3, r3, #7
			conn->llcp.phy_upd_ind.tx = 0U;
    148e:	4283      	cmp	r3, r0
    1490:	bf08      	it	eq
    1492:	2000      	moveq	r0, #0
    1494:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    1498:	f360 0384 	bfi	r3, r0, #2, #3
		if (conn->llcp_phy.rx != conn->lll.phy_rx) {
    149c:	f894 0065 	ldrb.w	r0, [r4, #101]	; 0x65
    14a0:	0949      	lsrs	r1, r1, #5
    14a2:	f000 0007 	and.w	r0, r0, #7
			conn->llcp.phy_upd_ind.rx = 0U;
    14a6:	4288      	cmp	r0, r1
    14a8:	bf08      	it	eq
    14aa:	2100      	moveq	r1, #0
    14ac:	f361 1347 	bfi	r3, r1, #5, #3
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
    14b0:	f894 11ab 	ldrb.w	r1, [r4, #427]	; 0x1ab
		conn->llcp.phy_upd_ind.initiate = 1U;
    14b4:	b2db      	uxtb	r3, r3
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
    14b6:	f3c1 0180 	ubfx	r1, r1, #2, #1
    14ba:	f043 0301 	orr.w	r3, r3, #1
    14be:	f361 0341 	bfi	r3, r1, #1, #1
    14c2:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
		conn->llcp_ack -= 2U;
    14c6:	3a02      	subs	r2, #2
		conn->llcp_type = LLCP_PHY_UPD;
    14c8:	2306      	movs	r3, #6
    14ca:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
		conn->llcp_ack -= 2U;
    14ce:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
	break;
    14d2:	e4a8      	b.n	e26 <ull_conn_llcp+0x5e>
		} else if (conn->llcp_phy.tx & BIT(0)) {
    14d4:	07ce      	lsls	r6, r1, #31
    14d6:	d501      	bpl.n	14dc <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x154>
			conn->llcp_phy.tx = BIT(0);
    14d8:	2101      	movs	r1, #1
    14da:	e7c2      	b.n	1462 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xda>
		} else if (conn->llcp_phy.tx & BIT(2)) {
    14dc:	f011 0104 	ands.w	r1, r1, #4
			conn->llcp_phy.tx = BIT(2);
    14e0:	bf18      	it	ne
    14e2:	2104      	movne	r1, #4
    14e4:	e7bd      	b.n	1462 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xda>
		} else if (conn->llcp_phy.rx & BIT(0)) {
    14e6:	07c8      	lsls	r0, r1, #31
    14e8:	d501      	bpl.n	14ee <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x166>
			conn->llcp_phy.rx = BIT(0);
    14ea:	2101      	movs	r1, #1
    14ec:	e7c3      	b.n	1476 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xee>
		} else if (conn->llcp_phy.rx & BIT(2)) {
    14ee:	f011 0104 	ands.w	r1, r1, #4
			conn->llcp_phy.rx = BIT(2);
    14f2:	bf18      	it	ne
    14f4:	2104      	movne	r1, #4
    14f6:	e7be      	b.n	1476 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xee>
		LL_ASSERT(0);
    14f8:	f640 5377 	movw	r3, #3447	; 0xd77
    14fc:	e574      	b.n	fe8 <ull_conn_llcp+0x220>
    14fe:	bf00      	nop
    1500:	200013d4 	.word	0x200013d4
    1504:	00021f06 	.word	0x00021f06
    1508:	00021fcd 	.word	0x00021fcd
    150c:	00020aa4 	.word	0x00020aa4
	conn_upd = conn_upd_curr;
    1510:	4a2e      	ldr	r2, [pc, #184]	; (15cc <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x244>)
	if (!conn_upd) {
    1512:	6813      	ldr	r3, [r2, #0]
    1514:	b903      	cbnz	r3, 1518 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x190>
		conn_upd_curr = conn;
    1516:	6014      	str	r4, [r2, #0]
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
    1518:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    151a:	8ee6      	ldrh	r6, [r4, #54]	; 0x36
    151c:	441e      	add	r6, r3
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
    151e:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
    1522:	4456      	add	r6, sl
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
    1524:	f013 0003 	ands.w	r0, r3, #3
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
    1528:	b2b6      	uxth	r6, r6
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
    152a:	d053      	beq.n	15d4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x24c>
		rx = ll_pdu_rx_alloc_peek(1);
    152c:	2001      	movs	r0, #1
    152e:	f00e ff19 	bl	10364 <ll_pdu_rx_alloc_peek>
		if (!rx) {
    1532:	4607      	mov	r7, r0
    1534:	2800      	cmp	r0, #0
    1536:	d03d      	beq.n	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    1538:	4825      	ldr	r0, [pc, #148]	; (15d0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x248>)
    153a:	f01b fc97 	bl	1ce6c <mem_acquire>
		if (!tx) {
    153e:	4605      	mov	r5, r0
    1540:	b3c0      	cbz	r0, 15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
		(void)ll_pdu_rx_alloc();
    1542:	f00e ff27 	bl	10394 <ll_pdu_rx_alloc>
		rx->hdr.link->mem = conn->llcp_rx;
    1546:	683b      	ldr	r3, [r7, #0]
    1548:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
    154c:	605a      	str	r2, [r3, #4]
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
    154e:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
		conn->llcp_rx = rx;
    1552:	f8c4 7100 	str.w	r7, [r4, #256]	; 0x100
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
    1556:	f36f 0301 	bfc	r3, #0, #2
    155a:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
    155e:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    1560:	441e      	add	r6, r3
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    1562:	792b      	ldrb	r3, [r5, #4]
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
    1564:	3606      	adds	r6, #6
    1566:	b2b6      	uxth	r6, r6
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    1568:	f043 0303 	orr.w	r3, r3, #3
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
    156c:	f8a4 60ec 	strh.w	r6, [r4, #236]	; 0xec
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    1570:	712b      	strb	r3, [r5, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_update_ind) +
    1572:	230c      	movs	r3, #12
    1574:	716b      	strb	r3, [r5, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND;
    1576:	2300      	movs	r3, #0
    1578:	71eb      	strb	r3, [r5, #7]
	pdu_ctrl_tx->llctrl.conn_update_ind.win_size = conn->llcp_cu.win_size;
    157a:	f894 3114 	ldrb.w	r3, [r4, #276]	; 0x114
    157e:	722b      	strb	r3, [r5, #8]
	pdu_ctrl_tx->llctrl.conn_update_ind.win_offset =
    1580:	f240 42e2 	movw	r2, #1250	; 0x4e2
		sys_cpu_to_le16(conn->llcp_cu.win_offset_us / 1250U);
    1584:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
	pdu_ctrl_tx->llctrl.conn_update_ind.win_offset =
    1588:	fbb3 f3f2 	udiv	r3, r3, r2
    158c:	f8a5 3009 	strh.w	r3, [r5, #9]
	pdu_ctrl_tx->llctrl.conn_update_ind.interval =
    1590:	f8b4 3108 	ldrh.w	r3, [r4, #264]	; 0x108
    1594:	f8a5 300b 	strh.w	r3, [r5, #11]
	pdu_ctrl_tx->llctrl.conn_update_ind.latency =
    1598:	f8b4 310a 	ldrh.w	r3, [r4, #266]	; 0x10a
    159c:	f8a5 300d 	strh.w	r3, [r5, #13]
	pdu_ctrl_tx->llctrl.conn_update_ind.timeout =
    15a0:	f8b4 310c 	ldrh.w	r3, [r4, #268]	; 0x10c
    15a4:	f8a5 300f 	strh.w	r3, [r5, #15]
	pdu_ctrl_tx->llctrl.conn_update_ind.instant =
    15a8:	f8a5 6011 	strh.w	r6, [r5, #17]
			ctrl_tx_enqueue(conn, tx);
    15ac:	4629      	mov	r1, r5
    15ae:	4620      	mov	r0, r4
    15b0:	f01c f825 	bl	1d5fe <ctrl_tx_enqueue>
	if (conn->llcp_terminate.ack != conn->llcp_terminate.req) {
    15b4:	f894 2129 	ldrb.w	r2, [r4, #297]	; 0x129
    15b8:	f894 3128 	ldrb.w	r3, [r4, #296]	; 0x128
    15bc:	429a      	cmp	r2, r3
    15be:	f040 84dd 	bne.w	1f7c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xbf4>
	return 0;
    15c2:	2000      	movs	r0, #0
}
    15c4:	b00d      	add	sp, #52	; 0x34
    15c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    15ca:	bf00      	nop
    15cc:	20001354 	.word	0x20001354
    15d0:	200013d4 	.word	0x200013d4
	instant_latency = (event_counter - conn->llcp.conn_upd.instant) &
    15d4:	f8b4 30ec 	ldrh.w	r3, [r4, #236]	; 0xec
    15d8:	930b      	str	r3, [sp, #44]	; 0x2c
    15da:	1af7      	subs	r7, r6, r3
    15dc:	b2bf      	uxth	r7, r7
	} else if (instant_latency <= 0x7FFF) {
    15de:	043b      	lsls	r3, r7, #16
    15e0:	d4e8      	bmi.n	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
		conn->llcp_cu.ack = conn->llcp_cu.req;
    15e2:	f894 3104 	ldrb.w	r3, [r4, #260]	; 0x104
    15e6:	f884 3105 	strb.w	r3, [r4, #261]	; 0x105
		conn->llcp_ack = conn->llcp_req;
    15ea:	f884 10e9 	strb.w	r1, [r4, #233]	; 0xe9
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
    15ee:	f894 3171 	ldrb.w	r3, [r4, #369]	; 0x171
    15f2:	f894 1170 	ldrb.w	r1, [r4, #368]	; 0x170
    15f6:	428b      	cmp	r3, r1
    15f8:	d009      	beq.n	160e <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x286>
		    (conn->llcp_conn_param.state == LLCP_CPR_STATE_UPD)) {
    15fa:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
    15fe:	f003 0307 	and.w	r3, r3, #7
    1602:	2b05      	cmp	r3, #5
			conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
    1604:	bf04      	itt	eq
    1606:	f884 1171 	strbeq.w	r1, [r4, #369]	; 0x171
			conn->procedure_expire = 0U;
    160a:	f8a4 00cc 	strheq.w	r0, [r4, #204]	; 0xcc
		if (conn_upd_curr == conn) {
    160e:	6813      	ldr	r3, [r2, #0]
		rx = conn->llcp_rx;
    1610:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
		if (conn_upd_curr == conn) {
    1614:	429c      	cmp	r4, r3
			conn_upd_curr = NULL;
    1616:	bf04      	itt	eq
    1618:	2300      	moveq	r3, #0
    161a:	6013      	streq	r3, [r2, #0]
		LL_ASSERT(rx && rx->hdr.link);
    161c:	b10d      	cbz	r5, 1622 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x29a>
    161e:	682b      	ldr	r3, [r5, #0]
    1620:	b963      	cbnz	r3, 163c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2b4>
    1622:	f640 039b 	movw	r3, #2203	; 0x89b
    1626:	4ac0      	ldr	r2, [pc, #768]	; (1928 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5a0>)
    1628:	49c0      	ldr	r1, [pc, #768]	; (192c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5a4>)
    162a:	48c1      	ldr	r0, [pc, #772]	; (1930 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5a8>)
    162c:	f017 fea2 	bl	19374 <printk>
    1630:	4040      	eors	r0, r0
    1632:	f380 8811 	msr	BASEPRI, r0
    1636:	f04f 0003 	mov.w	r0, #3
    163a:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
    163c:	6828      	ldr	r0, [r5, #0]
		if ((conn->llcp_cu.interval != lll->interval) ||
    163e:	f8b4 2108 	ldrh.w	r2, [r4, #264]	; 0x108
		conn->llcp_rx = rx->hdr.link->mem;
    1642:	6843      	ldr	r3, [r0, #4]
    1644:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		if ((conn->llcp_cu.interval != lll->interval) ||
    1648:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
    164a:	f8b4 c10a 	ldrh.w	ip, [r4, #266]	; 0x10a
    164e:	f8b4 110c 	ldrh.w	r1, [r4, #268]	; 0x10c
    1652:	429a      	cmp	r2, r3
    1654:	d113      	bne.n	167e <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2f6>
    1656:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    1658:	4563      	cmp	r3, ip
    165a:	d110      	bne.n	167e <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2f6>
		    (RADIO_CONN_EVENTS(conn->llcp_cu.timeout * 10000U,
    165c:	f240 43e2 	movw	r3, #1250	; 0x4e2
    1660:	fb03 fe02 	mul.w	lr, r3, r2
    1664:	f242 7310 	movw	r3, #10000	; 0x2710
    1668:	fb03 e301 	mla	r3, r3, r1, lr
    166c:	3b01      	subs	r3, #1
    166e:	fbb3 f3fe 	udiv	r3, r3, lr
		    (conn->llcp_cu.latency != lll->latency) ||
    1672:	f8b4 e0c6 	ldrh.w	lr, [r4, #198]	; 0xc6
    1676:	b29b      	uxth	r3, r3
    1678:	459e      	cmp	lr, r3
    167a:	f000 812e 	beq.w	18da <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x552>
			rx->hdr.handle = lll->handle;
    167e:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    1680:	80eb      	strh	r3, [r5, #6]
			rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
    1682:	230a      	movs	r3, #10
    1684:	712b      	strb	r3, [r5, #4]
			cu->status = 0x00;
    1686:	2300      	movs	r3, #0
    1688:	f885 3020 	strb.w	r3, [r5, #32]
			cu->interval = conn->llcp_cu.interval;
    168c:	846a      	strh	r2, [r5, #34]	; 0x22
			cu->latency = conn->llcp_cu.latency;
    168e:	f8a5 c024 	strh.w	ip, [r5, #36]	; 0x24
			cu->timeout = conn->llcp_cu.timeout;
    1692:	84e9      	strh	r1, [r5, #38]	; 0x26
		ll_rx_put(rx->hdr.link, rx);
    1694:	4629      	mov	r1, r5
    1696:	f00e fe55 	bl	10344 <ll_rx_put>
		ll_rx_sched();
    169a:	f00e fe5d 	bl	10358 <ll_rx_sched>
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
    169e:	6823      	ldr	r3, [r4, #0]
    16a0:	2b00      	cmp	r3, #0
    16a2:	da0a      	bge.n	16ba <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x332>
			u32_t ticks_prepare_to_start =
    16a4:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
			conn->evt.ticks_xtal_to_start &= ~XON_BITMASK;
    16a8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
			ticks_at_expire -= (conn->evt.ticks_xtal_to_start -
    16ac:	4290      	cmp	r0, r2
    16ae:	bf2c      	ite	cs
    16b0:	4480      	addcs	r8, r0
    16b2:	4490      	addcc	r8, r2
			conn->evt.ticks_xtal_to_start &= ~XON_BITMASK;
    16b4:	6023      	str	r3, [r4, #0]
			ticks_at_expire -= (conn->evt.ticks_xtal_to_start -
    16b6:	eba8 0803 	sub.w	r8, r8, r3
		conn_interval_old = instant_latency * lll->interval;
    16ba:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
		latency = conn_interval_old / conn->llcp_cu.interval;
    16bc:	f8b4 5108 	ldrh.w	r5, [r4, #264]	; 0x108
    16c0:	f8df b294 	ldr.w	fp, [pc, #660]	; 1958 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5d0>
		conn_interval_old = instant_latency * lll->interval;
    16c4:	fb13 f307 	smulbb	r3, r3, r7
    16c8:	b29b      	uxth	r3, r3
		latency = conn_interval_old / conn->llcp_cu.interval;
    16ca:	fbb3 f1f5 	udiv	r1, r3, r5
    16ce:	fa1f f981 	uxth.w	r9, r1
		conn_interval_new = latency * conn->llcp_cu.interval;
    16d2:	fb15 f209 	smulbb	r2, r5, r9
    16d6:	b292      	uxth	r2, r2
		if (conn_interval_new > conn_interval_old) {
    16d8:	4293      	cmp	r3, r2
    16da:	f240 40e2 	movw	r0, #1250	; 0x4e2
    16de:	f080 80ff 	bcs.w	18e0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x558>
			ticks_at_expire += HAL_TICKER_US_TO_TICKS(
    16e2:	1ad3      	subs	r3, r2, r3
    16e4:	4358      	muls	r0, r3
    16e6:	fba0 010b 	umull	r0, r1, r0, fp
    16ea:	a38d      	add	r3, pc, #564	; (adr r3, 1920 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x598>)
    16ec:	e9d3 2300 	ldrd	r2, r3, [r3]
    16f0:	f7fe fcf6 	bl	e0 <__aeabi_uldivmod>
    16f4:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    16f8:	4480      	add	r8, r0
		lll->latency_prepare += lazy;
    16fa:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    16fc:	449a      	add	sl, r3
		lll->latency_prepare -= (instant_latency - latency);
    16fe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1700:	1b9e      	subs	r6, r3, r6
		} else if (lll->role) {
    1702:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
		lll->latency_prepare -= (instant_latency - latency);
    1706:	444e      	add	r6, r9
    1708:	4456      	add	r6, sl
		} else if (lll->role) {
    170a:	2b00      	cmp	r3, #0
		conn_interval_us = conn->llcp_cu.interval * 1250U;
    170c:	f240 4ae2 	movw	sl, #1250	; 0x4e2
		lll->latency_prepare -= (instant_latency - latency);
    1710:	8666      	strh	r6, [r4, #50]	; 0x32
		conn_interval_us = conn->llcp_cu.interval * 1250U;
    1712:	fb0a f505 	mul.w	r5, sl, r5
		} else if (lll->role) {
    1716:	f280 80f1 	bge.w	18fc <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x574>
			lll->slave.window_widening_prepare_us -=
    171a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
				lll->slave.window_widening_periodic_us *
    171c:	6c63      	ldr	r3, [r4, #68]	; 0x44
			lll->slave.window_widening_prepare_us -=
    171e:	fb03 2717 	mls	r7, r3, r7, r2
    1722:	64e7      	str	r7, [r4, #76]	; 0x4c
				(((lll_conn_ppm_local_get() +
    1724:	f01c f933 	bl	1d98e <lll_conn_ppm_local_get>
    1728:	4606      	mov	r6, r0
				   lll_conn_ppm_get(conn->slave.sca)) *
    172a:	f894 00dc 	ldrb.w	r0, [r4, #220]	; 0xdc
    172e:	f3c0 0082 	ubfx	r0, r0, #2, #3
    1732:	f012 fe8b 	bl	1444c <lll_conn_ppm_get>
				conn->llcp_cu.win_size * 1250U;
    1736:	f894 2114 	ldrb.w	r2, [r4, #276]	; 0x114
				(((lll_conn_ppm_local_get() +
    173a:	4406      	add	r6, r0
				conn->llcp_cu.win_size * 1250U;
    173c:	fb0a f202 	mul.w	r2, sl, r2
			lll->slave.window_size_prepare_us =
    1740:	6562      	str	r2, [r4, #84]	; 0x54
				   lll_conn_ppm_get(conn->slave.sca)) *
    1742:	436e      	muls	r6, r5
			conn->slave.ticks_to_offset = 0U;
    1744:	2200      	movs	r2, #0
    1746:	f8c4 20e4 	str.w	r2, [r4, #228]	; 0xe4
				  conn_interval_us) + (1000000 - 1)) / 1000000U;
    174a:	f506 2674 	add.w	r6, r6, #999424	; 0xf4000
			lll->slave.window_widening_prepare_us +=
    174e:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
				  conn_interval_us) + (1000000 - 1)) / 1000000U;
    1750:	4878      	ldr	r0, [pc, #480]	; (1934 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5ac>)
    1752:	f206 263f 	addw	r6, r6, #575	; 0x23f
				(conn_interval_us >> 1) - EVENT_IFS_US;
    1756:	086b      	lsrs	r3, r5, #1
				  conn_interval_us) + (1000000 - 1)) / 1000000U;
    1758:	fbb6 f6f0 	udiv	r6, r6, r0
				lll->slave.window_widening_periodic_us *
    175c:	fb06 f009 	mul.w	r0, r6, r9
				(conn_interval_us >> 1) - EVENT_IFS_US;
    1760:	3b96      	subs	r3, #150	; 0x96
			lll->slave.window_widening_prepare_us +=
    1762:	4402      	add	r2, r0
			lll->slave.window_widening_periodic_us =
    1764:	6466      	str	r6, [r4, #68]	; 0x44
			lll->slave.window_widening_max_us =
    1766:	64a3      	str	r3, [r4, #72]	; 0x48
			lll->slave.window_widening_prepare_us +=
    1768:	429a      	cmp	r2, r3
    176a:	bf94      	ite	ls
    176c:	64e2      	strls	r2, [r4, #76]	; 0x4c
    176e:	64e3      	strhi	r3, [r4, #76]	; 0x4c
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
    1770:	fba0 010b 	umull	r0, r1, r0, fp
    1774:	a36a      	add	r3, pc, #424	; (adr r3, 1920 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x598>)
    1776:	e9d3 2300 	ldrd	r2, r3, [r3]
    177a:	f7fe fcb1 	bl	e0 <__aeabi_uldivmod>
    177e:	eba8 0800 	sub.w	r8, r8, r0
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
    1782:	f8d4 0110 	ldr.w	r0, [r4, #272]	; 0x110
    1786:	fbb0 f0fa 	udiv	r0, r0, sl
    178a:	fb0a f000 	mul.w	r0, sl, r0
    178e:	a364      	add	r3, pc, #400	; (adr r3, 1920 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x598>)
    1790:	e9d3 2300 	ldrd	r2, r3, [r3]
    1794:	fba0 010b 	umull	r0, r1, r0, fp
    1798:	f7fe fca2 	bl	e0 <__aeabi_uldivmod>
			periodic_us -= lll->slave.window_widening_periodic_us;
    179c:	1bae      	subs	r6, r5, r6
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
    179e:	f020 497f 	bic.w	r9, r0, #4278190080	; 0xff000000
		lll->interval = conn->llcp_cu.interval;
    17a2:	f8b4 3108 	ldrh.w	r3, [r4, #264]	; 0x108
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
    17a6:	f8b4 210c 	ldrh.w	r2, [r4, #268]	; 0x10c
		lll->interval = conn->llcp_cu.interval;
    17aa:	85e3      	strh	r3, [r4, #46]	; 0x2e
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
    17ac:	f242 7310 	movw	r3, #10000	; 0x2710
    17b0:	fb03 5202 	mla	r2, r3, r2, r5
		lll->latency = conn->llcp_cu.latency;
    17b4:	f8b4 110a 	ldrh.w	r1, [r4, #266]	; 0x10a
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    17b8:	4b5f      	ldr	r3, [pc, #380]	; (1938 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5b0>)
		lll->latency = conn->llcp_cu.latency;
    17ba:	8621      	strh	r1, [r4, #48]	; 0x30
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
    17bc:	3a01      	subs	r2, #1
    17be:	fbb2 f2f5 	udiv	r2, r2, r5
    17c2:	f8a4 20c6 	strh.w	r2, [r4, #198]	; 0xc6
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    17c6:	4a5d      	ldr	r2, [pc, #372]	; (193c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5b4>)
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    17c8:	442b      	add	r3, r5
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    17ca:	442a      	add	r2, r5
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    17cc:	fbb3 f3f5 	udiv	r3, r3, r5
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    17d0:	fbb2 f5f5 	udiv	r5, r2, r5
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    17d4:	f8a4 30ca 	strh.w	r3, [r4, #202]	; 0xca
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    17d8:	1d8a      	adds	r2, r1, #6
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    17da:	b2ab      	uxth	r3, r5
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    17dc:	4293      	cmp	r3, r2
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    17de:	f8a4 30d2 	strh.w	r3, [r4, #210]	; 0xd2
				     (conn->apto_reload - (lll->latency + 6)) :
    17e2:	bfc2      	ittt	gt
    17e4:	1a5b      	subgt	r3, r3, r1
    17e6:	3b06      	subgt	r3, #6
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    17e8:	b29b      	uxthgt	r3, r3
    17ea:	f8a4 30ce 	strh.w	r3, [r4, #206]	; 0xce
		if (conn->llcp_cu.cmd) {
    17ee:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
    17f2:	075d      	lsls	r5, r3, #29
			conn->supervision_expire = 0U;
    17f4:	bf44      	itt	mi
    17f6:	2300      	movmi	r3, #0
    17f8:	f8a4 30c8 	strhmi.w	r3, [r4, #200]	; 0xc8
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
    17fc:	2102      	movs	r1, #2
    17fe:	2001      	movs	r0, #1
    1800:	f014 fd1e 	bl	16240 <mayfly_is_enabled>
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW,
    1804:	2200      	movs	r2, #0
    1806:	2102      	movs	r1, #2
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
    1808:	4682      	mov	sl, r0
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW,
    180a:	2001      	movs	r0, #1
    180c:	f00c f93e 	bl	da8c <mayfly_enable>
		ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    1810:	4620      	mov	r0, r4
    1812:	f010 fd71 	bl	122f8 <ll_conn_handle_get>
    1816:	3003      	adds	r0, #3
    1818:	b2c5      	uxtb	r5, r0
		ticker_status =	ticker_stop(TICKER_INSTANCE_ID_CTLR,
    181a:	4b49      	ldr	r3, [pc, #292]	; (1940 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5b8>)
    181c:	9400      	str	r4, [sp, #0]
    181e:	462a      	mov	r2, r5
    1820:	2101      	movs	r1, #1
    1822:	2000      	movs	r0, #0
    1824:	f00c fe6a 	bl	e4fc <ticker_stop>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    1828:	f030 0302 	bics.w	r3, r0, #2
    182c:	d00c      	beq.n	1848 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x4c0>
    182e:	f44f 6314 	mov.w	r3, #2368	; 0x940
    1832:	4a3d      	ldr	r2, [pc, #244]	; (1928 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5a0>)
    1834:	4943      	ldr	r1, [pc, #268]	; (1944 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5bc>)
    1836:	483e      	ldr	r0, [pc, #248]	; (1930 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5a8>)
    1838:	f017 fd9c 	bl	19374 <printk>
    183c:	4040      	eors	r0, r0
    183e:	f380 8811 	msr	BASEPRI, r0
    1842:	f04f 0003 	mov.w	r0, #3
    1846:	df02      	svc	2
				     HAL_TICKER_US_TO_TICKS(periodic_us),
    1848:	fba6 670b 	umull	r6, r7, r6, fp
    184c:	a334      	add	r3, pc, #208	; (adr r3, 1920 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x598>)
    184e:	e9d3 2300 	ldrd	r2, r3, [r3]
    1852:	4630      	mov	r0, r6
    1854:	4639      	mov	r1, r7
    1856:	f7fe fc43 	bl	e0 <__aeabi_uldivmod>
			ticker_start(TICKER_INSTANCE_ID_CTLR,
    185a:	4b3b      	ldr	r3, [pc, #236]	; (1948 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5c0>)
    185c:	9408      	str	r4, [sp, #32]
    185e:	e9cd 4306 	strd	r4, r3, [sp, #24]
    1862:	4b3a      	ldr	r3, [pc, #232]	; (194c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5c4>)
    1864:	9305      	str	r3, [sp, #20]
    1866:	68e3      	ldr	r3, [r4, #12]
    1868:	9304      	str	r3, [sp, #16]
    186a:	2300      	movs	r3, #0
    186c:	9303      	str	r3, [sp, #12]
				     HAL_TICKER_REMAINDER(periodic_us),
    186e:	4b38      	ldr	r3, [pc, #224]	; (1950 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5c8>)
    1870:	f020 447f 	bic.w	r4, r0, #4278190080	; 0xff000000
    1874:	fba4 bc03 	umull	fp, ip, r4, r3
    1878:	2307      	movs	r3, #7
    187a:	fb03 cc04 	mla	ip, r3, r4, ip
    187e:	ebb6 000b 	subs.w	r0, r6, fp
    1882:	eb67 010c 	sbc.w	r1, r7, ip
    1886:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    188a:	2300      	movs	r3, #0
    188c:	f7fe fc28 	bl	e0 <__aeabi_uldivmod>
			ticker_start(TICKER_INSTANCE_ID_CTLR,
    1890:	4643      	mov	r3, r8
    1892:	e9cd 4001 	strd	r4, r0, [sp, #4]
    1896:	f8cd 9000 	str.w	r9, [sp]
    189a:	462a      	mov	r2, r5
    189c:	2101      	movs	r1, #1
    189e:	2000      	movs	r0, #0
    18a0:	f00c fd9a 	bl	e3d8 <ticker_start>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    18a4:	f030 0302 	bics.w	r3, r0, #2
    18a8:	d00c      	beq.n	18c4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x53c>
    18aa:	f640 135a 	movw	r3, #2394	; 0x95a
    18ae:	4a1e      	ldr	r2, [pc, #120]	; (1928 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5a0>)
    18b0:	4924      	ldr	r1, [pc, #144]	; (1944 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5bc>)
    18b2:	481f      	ldr	r0, [pc, #124]	; (1930 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5a8>)
    18b4:	f017 fd5e 	bl	19374 <printk>
    18b8:	4040      	eors	r0, r0
    18ba:	f380 8811 	msr	BASEPRI, r0
    18be:	f04f 0003 	mov.w	r0, #3
    18c2:	df02      	svc	2
		if (mayfly_was_enabled) {
    18c4:	f1ba 0f00 	cmp.w	sl, #0
    18c8:	d004      	beq.n	18d4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x54c>
			mayfly_enable(TICKER_USER_ID_ULL_HIGH,
    18ca:	2201      	movs	r2, #1
    18cc:	2102      	movs	r1, #2
    18ce:	4610      	mov	r0, r2
    18d0:	f00c f8dc 	bl	da8c <mayfly_enable>
				return -ECANCELED;
    18d4:	f06f 0047 	mvn.w	r0, #71	; 0x47
    18d8:	e674      	b.n	15c4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x23c>
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
    18da:	2303      	movs	r3, #3
    18dc:	712b      	strb	r3, [r5, #4]
    18de:	e6d9      	b.n	1694 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x30c>
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
    18e0:	fb05 3111 	mls	r1, r5, r1, r3
    18e4:	b289      	uxth	r1, r1
    18e6:	4348      	muls	r0, r1
    18e8:	a30d      	add	r3, pc, #52	; (adr r3, 1920 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x598>)
    18ea:	e9d3 2300 	ldrd	r2, r3, [r3]
    18ee:	fba0 010b 	umull	r0, r1, r0, fp
    18f2:	f7fe fbf5 	bl	e0 <__aeabi_uldivmod>
    18f6:	eba8 0800 	sub.w	r8, r8, r0
    18fa:	e6fe      	b.n	16fa <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x372>
			LL_ASSERT(0);
    18fc:	f44f 6311 	mov.w	r3, #2320	; 0x910
    1900:	4a09      	ldr	r2, [pc, #36]	; (1928 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5a0>)
    1902:	4914      	ldr	r1, [pc, #80]	; (1954 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5cc>)
    1904:	480a      	ldr	r0, [pc, #40]	; (1930 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x5a8>)
    1906:	f017 fd35 	bl	19374 <printk>
    190a:	4040      	eors	r0, r0
    190c:	f380 8811 	msr	BASEPRI, r0
    1910:	f04f 0003 	mov.w	r0, #3
    1914:	df02      	svc	2
		u32_t ticks_win_offset = 0;
    1916:	f04f 0900 	mov.w	r9, #0
		periodic_us = conn_interval_us;
    191a:	462e      	mov	r6, r5
    191c:	e741      	b.n	17a2 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x41a>
    191e:	bf00      	nop
    1920:	1afd498d 	.word	0x1afd498d
    1924:	00000007 	.word	0x00000007
    1928:	00021f06 	.word	0x00021f06
    192c:	00021fcd 	.word	0x00021fcd
    1930:	00020aa4 	.word	0x00020aa4
    1934:	000f4240 	.word	0x000f4240
    1938:	026259ff 	.word	0x026259ff
    193c:	01c9c37f 	.word	0x01c9c37f
    1940:	00011ee1 	.word	0x00011ee1
    1944:	00021e65 	.word	0x00021e65
    1948:	00011e89 	.word	0x00011e89
    194c:	000149ed 	.word	0x000149ed
    1950:	1afd498d 	.word	0x1afd498d
    1954:	00022577 	.word	0x00022577
    1958:	3b9aca00 	.word	0x3b9aca00
			event_counter = lll->event_counter +
    195c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    195e:	8e62      	ldrh	r2, [r4, #50]	; 0x32
    1960:	4413      	add	r3, r2
					lll->latency_prepare + lazy;
    1962:	449a      	add	sl, r3
	if (conn->llcp.chan_map.initiate) {
    1964:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    1968:	07d8      	lsls	r0, r3, #31
			event_counter = lll->event_counter +
    196a:	fa1f fa8a 	uxth.w	sl, sl
	if (conn->llcp.chan_map.initiate) {
    196e:	d525      	bpl.n	19bc <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x634>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    1970:	48cb      	ldr	r0, [pc, #812]	; (1ca0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x918>)
    1972:	f01b fa7b 	bl	1ce6c <mem_acquire>
		if (tx) {
    1976:	4605      	mov	r5, r0
    1978:	2800      	cmp	r0, #0
    197a:	f43f ae1b 	beq.w	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
			conn->llcp.chan_map.initiate = 0U;
    197e:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    1982:	f36f 0300 	bfc	r3, #0, #1
    1986:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
			conn->llcp.chan_map.instant = event_counter +
    198a:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    198c:	449a      	add	sl, r3
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    198e:	7903      	ldrb	r3, [r0, #4]
						      conn->lll.latency + 6;
    1990:	f10a 0a06 	add.w	sl, sl, #6
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    1994:	f043 0303 	orr.w	r3, r3, #3
			conn->llcp.chan_map.instant = event_counter +
    1998:	f8a4 a0f2 	strh.w	sl, [r4, #242]	; 0xf2
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    199c:	7103      	strb	r3, [r0, #4]
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
    199e:	2308      	movs	r3, #8
    19a0:	7143      	strb	r3, [r0, #5]
			pdu_ctrl_tx->llctrl.opcode =
    19a2:	2301      	movs	r3, #1
    19a4:	71c3      	strb	r3, [r0, #7]
			memcpy(&pdu_ctrl_tx->llctrl.chan_map_ind.chm[0],
    19a6:	2205      	movs	r2, #5
    19a8:	f104 01ed 	add.w	r1, r4, #237	; 0xed
    19ac:	3008      	adds	r0, #8
    19ae:	f019 fb24 	bl	1affa <memcpy>
			pdu_ctrl_tx->llctrl.chan_map_ind.instant =
    19b2:	f8b4 30f2 	ldrh.w	r3, [r4, #242]	; 0xf2
    19b6:	f8a5 300d 	strh.w	r3, [r5, #13]
    19ba:	e5f7      	b.n	15ac <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x224>
	} else if (((event_counter - conn->llcp.chan_map.instant) & 0xFFFF)
    19bc:	f8b4 30f2 	ldrh.w	r3, [r4, #242]	; 0xf2
    19c0:	ebaa 0a03 	sub.w	sl, sl, r3
    19c4:	f41a 4f00 	tst.w	sl, #32768	; 0x8000
    19c8:	f47f adf4 	bne.w	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
		memcpy(&lll->data_chan_map[0],
    19cc:	f104 0538 	add.w	r5, r4, #56	; 0x38
		conn->llcp_ack = conn->llcp_req;
    19d0:	f884 10e9 	strb.w	r1, [r4, #233]	; 0xe9
		memcpy(&lll->data_chan_map[0],
    19d4:	2205      	movs	r2, #5
    19d6:	f104 01ed 	add.w	r1, r4, #237	; 0xed
    19da:	4628      	mov	r0, r5
    19dc:	f019 fb0d 	bl	1affa <memcpy>
			util_ones_count_get(&lll->data_chan_map[0],
    19e0:	2105      	movs	r1, #5
    19e2:	4628      	mov	r0, r5
    19e4:	f01b fabe 	bl	1cf64 <util_ones_count_get>
		lll->data_chan_count =
    19e8:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
    19ec:	f360 0305 	bfi	r3, r0, #0, #6
    19f0:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
		conn->chm_updated = 1U;
    19f4:	2301      	movs	r3, #1
    19f6:	f884 31c4 	strb.w	r3, [r4, #452]	; 0x1c4
    19fa:	e5db      	b.n	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
	if (conn->llcp.encryption.state) {
    19fc:	f894 60ec 	ldrb.w	r6, [r4, #236]	; 0xec
    1a00:	f016 0603 	ands.w	r6, r6, #3
    1a04:	d063      	beq.n	1ace <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x746>
		if (lll->role &&
    1a06:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
    1a0a:	2b00      	cmp	r3, #0
    1a0c:	f6bf add2 	bge.w	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
    1a10:	2e01      	cmp	r6, #1
    1a12:	f47f adcf 	bne.w	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
{
	struct pdu_data *pdu_ctrl_tx;
	struct node_tx *tx;

	/* acquire tx mem */
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    1a16:	48a2      	ldr	r0, [pc, #648]	; (1ca0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x918>)
    1a18:	f01b fa28 	bl	1ce6c <mem_acquire>
	if (!tx) {
    1a1c:	4607      	mov	r7, r0
    1a1e:	2800      	cmp	r0, #0
    1a20:	f43f adc8 	beq.w	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
		return -ENOBUFS;
	}

	pdu_ctrl_tx = (void *)tx->pdu;
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    1a24:	7903      	ldrb	r3, [r0, #4]
    1a26:	f043 0303 	orr.w	r3, r3, #3
    1a2a:	7103      	strb	r3, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp) +
    1a2c:	230d      	movs	r3, #13
    1a2e:	7143      	strb	r3, [r0, #5]
			   sizeof(struct pdu_data_llctrl_enc_rsp);
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_RSP;
    1a30:	2304      	movs	r3, #4
    1a32:	71c3      	strb	r3, [r0, #7]
	BUILD_ASSERT(offsetof(__typeof(pdu_ctrl_tx->llctrl.enc_rsp), ivs) ==
		     (offsetof(__typeof(pdu_ctrl_tx->llctrl.enc_rsp), skds) +
		     sizeof(pdu_ctrl_tx->llctrl.enc_rsp.skds)));

	/* NOTE: if not sufficient random numbers, ignore waiting */
	entropy_get_entropy_isr(entropy, pdu_ctrl_tx->llctrl.enc_rsp.skds,
    1a34:	4b9b      	ldr	r3, [pc, #620]	; (1ca4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x91c>)
    1a36:	6818      	ldr	r0, [r3, #0]
					  u32_t flags)
{
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->driver_api;

	if (unlikely(!api->get_entropy_isr)) {
    1a38:	6843      	ldr	r3, [r0, #4]
    1a3a:	685e      	ldr	r6, [r3, #4]
    1a3c:	f107 0508 	add.w	r5, r7, #8
    1a40:	b11e      	cbz	r6, 1a4a <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x6c2>
		return -ENOTSUP;
	}

	return api->get_entropy_isr(dev, buffer, length, flags);
    1a42:	2300      	movs	r3, #0
    1a44:	220c      	movs	r2, #12
    1a46:	4629      	mov	r1, r5
    1a48:	47b0      	blx	r6
				sizeof(pdu_ctrl_tx->llctrl.enc_rsp.skds) +
				sizeof(pdu_ctrl_tx->llctrl.enc_rsp.ivs), 0);

	/* things from slave stored for session key calculation */
	memcpy(&conn->llcp.encryption.skd[8],
    1a4a:	4629      	mov	r1, r5
    1a4c:	2208      	movs	r2, #8
    1a4e:	f104 00f6 	add.w	r0, r4, #246	; 0xf6
    1a52:	f019 fad2 	bl	1affa <memcpy>
	       &pdu_ctrl_tx->llctrl.enc_rsp.skds[0], 8);
	memcpy(&conn->lll.ccm_rx.iv[4],
    1a56:	2204      	movs	r2, #4
    1a58:	f107 0110 	add.w	r1, r7, #16
    1a5c:	f104 009c 	add.w	r0, r4, #156	; 0x9c
    1a60:	f019 facb 	bl	1affa <memcpy>
	       &pdu_ctrl_tx->llctrl.enc_rsp.ivs[0], 4);

	ctrl_tx_enqueue(conn, tx);
    1a64:	4639      	mov	r1, r7
    1a66:	4620      	mov	r0, r4
    1a68:	f01b fdc9 	bl	1d5fe <ctrl_tx_enqueue>
			rx = ll_pdu_rx_alloc();
    1a6c:	f00e fc92 	bl	10394 <ll_pdu_rx_alloc>
			if (!rx) {
    1a70:	4605      	mov	r5, r0
    1a72:	2800      	cmp	r0, #0
    1a74:	f43f ad9e 	beq.w	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
			rx->hdr.handle = conn->lll.handle;
    1a78:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    1a7a:	80c3      	strh	r3, [r0, #6]
			pdu->ll_id = PDU_DATA_LLID_CTRL;
    1a7c:	f890 3020 	ldrb.w	r3, [r0, #32]
    1a80:	f043 0303 	orr.w	r3, r3, #3
    1a84:	f880 3020 	strb.w	r3, [r0, #32]
			pdu->len = offsetof(struct pdu_data_llctrl, enc_req) +
    1a88:	2317      	movs	r3, #23
    1a8a:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
			rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    1a8e:	2602      	movs	r6, #2
			pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
    1a90:	2303      	movs	r3, #3
    1a92:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
			memcpy(&pdu->llctrl.enc_req.rand[0],
    1a96:	2208      	movs	r2, #8
			rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    1a98:	7106      	strb	r6, [r0, #4]
			memcpy(&pdu->llctrl.enc_req.rand[0],
    1a9a:	f204 1155 	addw	r1, r4, #341	; 0x155
    1a9e:	3024      	adds	r0, #36	; 0x24
    1aa0:	f019 faab 	bl	1affa <memcpy>
			pdu->llctrl.enc_req.ediv[0] = conn->llcp_enc.ediv[0];
    1aa4:	f894 3153 	ldrb.w	r3, [r4, #339]	; 0x153
    1aa8:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
			pdu->llctrl.enc_req.ediv[1] = conn->llcp_enc.ediv[1];
    1aac:	f894 3154 	ldrb.w	r3, [r4, #340]	; 0x154
    1ab0:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
			ll_rx_put(rx->hdr.link, rx);
    1ab4:	4629      	mov	r1, r5
    1ab6:	6828      	ldr	r0, [r5, #0]
    1ab8:	f00e fc44 	bl	10344 <ll_rx_put>
			ll_rx_sched();
    1abc:	f00e fc4c 	bl	10358 <ll_rx_sched>
			conn->llcp.encryption.state = LLCP_ENC_STATE_LTK_WAIT;
    1ac0:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    1ac4:	f366 0301 	bfi	r3, r6, #0, #2
    1ac8:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
    1acc:	e572      	b.n	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    1ace:	4874      	ldr	r0, [pc, #464]	; (1ca0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x918>)
    1ad0:	f01b f9cc 	bl	1ce6c <mem_acquire>
	if (!tx) {
    1ad4:	4605      	mov	r5, r0
    1ad6:	2800      	cmp	r0, #0
    1ad8:	f43f ad6c 	beq.w	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
	if (!lll->role) {
    1adc:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
    1ae0:	2b00      	cmp	r3, #0
	pdu_ctrl_tx = (void *)tx->pdu;
    1ae2:	f100 0704 	add.w	r7, r0, #4
	if (!lll->role) {
    1ae6:	db47      	blt.n	1b78 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x7f0>
		ecb_encrypt(&conn->llcp_enc.ltk[0],
    1ae8:	f104 087f 	add.w	r8, r4, #127	; 0x7f
    1aec:	4643      	mov	r3, r8
    1aee:	4632      	mov	r2, r6
    1af0:	f104 01ee 	add.w	r1, r4, #238	; 0xee
    1af4:	f204 105d 	addw	r0, r4, #349	; 0x15d
    1af8:	f01c f828 	bl	1db4c <ecb_encrypt>
		memcpy(&lll->ccm_tx.key[0], &lll->ccm_rx.key[0],
    1afc:	2210      	movs	r2, #16
    1afe:	4641      	mov	r1, r8
    1b00:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
    1b04:	f019 fa79 	bl	1affa <memcpy>
		memcpy(&lll->ccm_tx.iv[0], &lll->ccm_rx.iv[0],
    1b08:	f104 0198 	add.w	r1, r4, #152	; 0x98
    1b0c:	2208      	movs	r2, #8
    1b0e:	f104 00b9 	add.w	r0, r4, #185	; 0xb9
    1b12:	f019 fa72 	bl	1affa <memcpy>
		lll->ccm_rx.direction = 0;
    1b16:	f894 3097 	ldrb.w	r3, [r4, #151]	; 0x97
		lll->ccm_rx.counter = 0;
    1b1a:	f884 608f 	strb.w	r6, [r4, #143]	; 0x8f
		lll->ccm_rx.direction = 0;
    1b1e:	f366 0300 	bfi	r3, r6, #0, #1
    1b22:	f884 3097 	strb.w	r3, [r4, #151]	; 0x97
		lll->ccm_tx.direction = 1;
    1b26:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
		lll->ccm_rx.counter = 0;
    1b2a:	f884 6090 	strb.w	r6, [r4, #144]	; 0x90
		lll->ccm_tx.direction = 1;
    1b2e:	f043 0301 	orr.w	r3, r3, #1
    1b32:	f884 30b8 	strb.w	r3, [r4, #184]	; 0xb8
		lll->enc_rx = 1;
    1b36:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
		lll->ccm_rx.counter = 0;
    1b3a:	f884 6091 	strb.w	r6, [r4, #145]	; 0x91
		lll->enc_rx = 1;
    1b3e:	f043 0308 	orr.w	r3, r3, #8
		lll->ccm_rx.counter = 0;
    1b42:	f884 6092 	strb.w	r6, [r4, #146]	; 0x92
    1b46:	f884 6093 	strb.w	r6, [r4, #147]	; 0x93
    1b4a:	f884 6094 	strb.w	r6, [r4, #148]	; 0x94
    1b4e:	f884 6095 	strb.w	r6, [r4, #149]	; 0x95
    1b52:	f884 6096 	strb.w	r6, [r4, #150]	; 0x96
		lll->ccm_tx.counter = 0;
    1b56:	e9c4 662c 	strd	r6, r6, [r4, #176]	; 0xb0
		lll->enc_rx = 1;
    1b5a:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
		start_enc_rsp_send(conn, pdu_ctrl_tx);
    1b5e:	4639      	mov	r1, r7
    1b60:	4620      	mov	r0, r4
    1b62:	f01b fd4f 	bl	1d604 <start_enc_rsp_send>
			ctrl_tx_enqueue(conn, tx);
    1b66:	4629      	mov	r1, r5
    1b68:	4620      	mov	r0, r4
    1b6a:	f01b fd48 	bl	1d5fe <ctrl_tx_enqueue>
	conn->llcp_ack = conn->llcp_req;
    1b6e:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
    1b72:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
    1b76:	e51d      	b.n	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
	else if (!lll->enc_rx) {
    1b78:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
    1b7c:	071a      	lsls	r2, r3, #28
    1b7e:	d465      	bmi.n	1c4c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x8c4>
		if (conn->llcp.encryption.error_code) {
    1b80:	f894 60ed 	ldrb.w	r6, [r4, #237]	; 0xed
    1b84:	b1f6      	cbz	r6, 1bc4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x83c>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
    1b86:	7903      	ldrb	r3, [r0, #4]
    1b88:	f043 0303 	orr.w	r3, r3, #3
    1b8c:	7103      	strb	r3, [r0, #4]
	if (conn->common.fex_valid &&
    1b8e:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
    1b92:	07db      	lsls	r3, r3, #31
    1b94:	d511      	bpl.n	1bba <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x832>
	    (conn->llcp_feature.features & BIT(BT_LE_FEAT_BIT_EXT_REJ_IND))) {
    1b96:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
	if (conn->common.fex_valid &&
    1b9a:	075f      	lsls	r7, r3, #29
    1b9c:	d50d      	bpl.n	1bba <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x832>
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
    1b9e:	2311      	movs	r3, #17
    1ba0:	71c3      	strb	r3, [r0, #7]
		p->reject_opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
    1ba2:	2303      	movs	r3, #3
    1ba4:	7203      	strb	r3, [r0, #8]
		p->error_code = conn->llcp.encryption.error_code;
    1ba6:	7246      	strb	r6, [r0, #9]
		pdu->len = sizeof(struct pdu_data_llctrl_reject_ext_ind);
    1ba8:	2302      	movs	r3, #2
		pdu->len = sizeof(struct pdu_data_llctrl_reject_ind);
    1baa:	716b      	strb	r3, [r5, #5]
	pdu->len += offsetof(struct pdu_data_llctrl, reject_ind);
    1bac:	796b      	ldrb	r3, [r5, #5]
    1bae:	3301      	adds	r3, #1
    1bb0:	716b      	strb	r3, [r5, #5]
	conn->llcp.encryption.error_code = 0U;
    1bb2:	2300      	movs	r3, #0
    1bb4:	f884 30ed 	strb.w	r3, [r4, #237]	; 0xed
    1bb8:	e7d5      	b.n	1b66 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x7de>
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
    1bba:	230d      	movs	r3, #13
    1bbc:	71eb      	strb	r3, [r5, #7]
		p->error_code =	conn->llcp.encryption.error_code;
    1bbe:	722e      	strb	r6, [r5, #8]
		pdu->len = sizeof(struct pdu_data_llctrl_reject_ind);
    1bc0:	2301      	movs	r3, #1
    1bc2:	e7f2      	b.n	1baa <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x822>
			ecb_encrypt(&conn->llcp_enc.ltk[0],
    1bc4:	f104 077f 	add.w	r7, r4, #127	; 0x7f
    1bc8:	463b      	mov	r3, r7
    1bca:	4632      	mov	r2, r6
    1bcc:	f104 01ee 	add.w	r1, r4, #238	; 0xee
    1bd0:	f204 105d 	addw	r0, r4, #349	; 0x15d
    1bd4:	f01b ffba 	bl	1db4c <ecb_encrypt>
			memcpy(&lll->ccm_tx.key[0],
    1bd8:	2210      	movs	r2, #16
    1bda:	4639      	mov	r1, r7
    1bdc:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
    1be0:	f019 fa0b 	bl	1affa <memcpy>
			memcpy(&lll->ccm_tx.iv[0], &lll->ccm_rx.iv[0],
    1be4:	2208      	movs	r2, #8
    1be6:	f104 0198 	add.w	r1, r4, #152	; 0x98
    1bea:	f104 00b9 	add.w	r0, r4, #185	; 0xb9
    1bee:	f019 fa04 	bl	1affa <memcpy>
			lll->ccm_rx.direction = 1U;
    1bf2:	f894 3097 	ldrb.w	r3, [r4, #151]	; 0x97
			lll->ccm_rx.counter = 0U;
    1bf6:	f884 608f 	strb.w	r6, [r4, #143]	; 0x8f
			lll->ccm_rx.direction = 1U;
    1bfa:	f043 0301 	orr.w	r3, r3, #1
    1bfe:	f884 3097 	strb.w	r3, [r4, #151]	; 0x97
			lll->ccm_tx.direction = 0U;
    1c02:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
			lll->ccm_rx.counter = 0U;
    1c06:	f884 6090 	strb.w	r6, [r4, #144]	; 0x90
			lll->ccm_tx.direction = 0U;
    1c0a:	f366 0300 	bfi	r3, r6, #0, #1
    1c0e:	f884 30b8 	strb.w	r3, [r4, #184]	; 0xb8
			lll->enc_rx = 1U;
    1c12:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
			lll->ccm_rx.counter = 0U;
    1c16:	f884 6091 	strb.w	r6, [r4, #145]	; 0x91
			lll->enc_rx = 1U;
    1c1a:	f043 0308 	orr.w	r3, r3, #8
    1c1e:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    1c22:	792b      	ldrb	r3, [r5, #4]
			lll->ccm_rx.counter = 0U;
    1c24:	f884 6092 	strb.w	r6, [r4, #146]	; 0x92
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    1c28:	f043 0303 	orr.w	r3, r3, #3
			lll->ccm_rx.counter = 0U;
    1c2c:	f884 6093 	strb.w	r6, [r4, #147]	; 0x93
    1c30:	f884 6094 	strb.w	r6, [r4, #148]	; 0x94
    1c34:	f884 6095 	strb.w	r6, [r4, #149]	; 0x95
    1c38:	f884 6096 	strb.w	r6, [r4, #150]	; 0x96
			lll->ccm_tx.counter = 0U;
    1c3c:	e9c4 662c 	strd	r6, r6, [r4, #176]	; 0xb0
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    1c40:	712b      	strb	r3, [r5, #4]
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
    1c42:	2301      	movs	r3, #1
    1c44:	716b      	strb	r3, [r5, #5]
			pdu_ctrl_tx->llctrl.opcode =
    1c46:	2305      	movs	r3, #5
    1c48:	71eb      	strb	r3, [r5, #7]
			ctrl_tx_enqueue(conn, tx);
    1c4a:	e78c      	b.n	1b66 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x7de>
		start_enc_rsp_send(conn, pdu_ctrl_tx);
    1c4c:	4639      	mov	r1, r7
    1c4e:	4620      	mov	r0, r4
    1c50:	f01b fcd8 	bl	1d604 <start_enc_rsp_send>
		ctrl_tx_enqueue(conn, tx);
    1c54:	4629      	mov	r1, r5
    1c56:	4620      	mov	r0, r4
    1c58:	f01b fcd1 	bl	1d5fe <ctrl_tx_enqueue>
		conn->llcp_enc.pause_rx = 0U;
    1c5c:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
    1c60:	f023 0303 	bic.w	r3, r3, #3
    1c64:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
    1c68:	e781      	b.n	1b6e <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x7e6>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    1c6a:	480d      	ldr	r0, [pc, #52]	; (1ca0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x918>)
    1c6c:	f01b f8fe 	bl	1ce6c <mem_acquire>
	if (tx) {
    1c70:	4601      	mov	r1, r0
    1c72:	2800      	cmp	r0, #0
    1c74:	f43f ac9e 	beq.w	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
		conn->llcp_ack = conn->llcp_req;
    1c78:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
    1c7c:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    1c80:	7903      	ldrb	r3, [r0, #4]
    1c82:	f043 0303 	orr.w	r3, r3, #3
    1c86:	7103      	strb	r3, [r0, #4]
		pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, ping_req) +
    1c88:	2301      	movs	r3, #1
    1c8a:	7143      	strb	r3, [r0, #5]
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_REQ;
    1c8c:	2312      	movs	r3, #18
    1c8e:	71c3      	strb	r3, [r0, #7]
		ctrl_tx_enqueue(conn, tx);
    1c90:	4620      	mov	r0, r4
    1c92:	f01b fcb4 	bl	1d5fe <ctrl_tx_enqueue>
		conn->procedure_expire = conn->procedure_reload;
    1c96:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
    1c9a:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
    1c9e:	e489      	b.n	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
    1ca0:	200013d4 	.word	0x200013d4
    1ca4:	20001358 	.word	0x20001358
			event_counter = lll->event_counter +
    1ca8:	8e62      	ldrh	r2, [r4, #50]	; 0x32
    1caa:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    1cac:	4413      	add	r3, r2
	if (conn->llcp.phy_upd_ind.initiate) {
    1cae:	f894 20ec 	ldrb.w	r2, [r4, #236]	; 0xec
					lll->latency_prepare + lazy;
    1cb2:	449a      	add	sl, r3
	if (conn->llcp.phy_upd_ind.initiate) {
    1cb4:	07d0      	lsls	r0, r2, #31
			event_counter = lll->event_counter +
    1cb6:	fa1f fa8a 	uxth.w	sl, sl
	if (conn->llcp.phy_upd_ind.initiate) {
    1cba:	d568      	bpl.n	1d8e <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xa06>
		rx = ll_pdu_rx_alloc_peek(2);
    1cbc:	2002      	movs	r0, #2
    1cbe:	f00e fb51 	bl	10364 <ll_pdu_rx_alloc_peek>
		if (!rx) {
    1cc2:	4606      	mov	r6, r0
    1cc4:	2800      	cmp	r0, #0
    1cc6:	f43f ac75 	beq.w	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    1cca:	48c0      	ldr	r0, [pc, #768]	; (1fcc <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xc44>)
    1ccc:	f01b f8ce 	bl	1ce6c <mem_acquire>
		if (!tx) {
    1cd0:	4605      	mov	r5, r0
    1cd2:	2800      	cmp	r0, #0
    1cd4:	f43f ac6e 	beq.w	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
		conn->llcp.phy_upd_ind.initiate = 0U;
    1cd8:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    1cdc:	f36f 0300 	bfc	r3, #0, #1
    1ce0:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
		if (!((conn->llcp.phy_upd_ind.tx |
    1ce4:	b2db      	uxtb	r3, r3
    1ce6:	f3c3 0782 	ubfx	r7, r3, #2, #3
    1cea:	ea57 1753 	orrs.w	r7, r7, r3, lsr #5
    1cee:	d137      	bne.n	1d60 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x9d8>
			conn->llcp_ack = conn->llcp_req;
    1cf0:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
    1cf4:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
			if (conn->llcp.phy_upd_ind.cmd) {
    1cf8:	079b      	lsls	r3, r3, #30
			conn->llcp.phy_upd_ind.instant = 0U;
    1cfa:	f8a4 70ee 	strh.w	r7, [r4, #238]	; 0xee
			if (conn->llcp.phy_upd_ind.cmd) {
    1cfe:	d519      	bpl.n	1d34 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x9ac>
				(void)ll_pdu_rx_alloc();
    1d00:	f00e fb48 	bl	10394 <ll_pdu_rx_alloc>
				rx->hdr.handle = lll->handle;
    1d04:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    1d06:	80f3      	strh	r3, [r6, #6]
				upd->status = 0U;
    1d08:	f886 7020 	strb.w	r7, [r6, #32]
				rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
    1d0c:	230e      	movs	r3, #14
    1d0e:	7133      	strb	r3, [r6, #4]
				upd->tx = lll->phy_tx;
    1d10:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
				ll_rx_put(rx->hdr.link, rx);
    1d14:	6830      	ldr	r0, [r6, #0]
				upd->tx = lll->phy_tx;
    1d16:	f3c3 0302 	ubfx	r3, r3, #0, #3
    1d1a:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
				upd->rx = lll->phy_rx;
    1d1e:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
    1d22:	f3c3 0302 	ubfx	r3, r3, #0, #3
    1d26:	f886 3022 	strb.w	r3, [r6, #34]	; 0x22
				ll_rx_put(rx->hdr.link, rx);
    1d2a:	4631      	mov	r1, r6
    1d2c:	f00e fb0a 	bl	10344 <ll_rx_put>
				ll_rx_sched();
    1d30:	f00e fb12 	bl	10358 <ll_rx_sched>
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    1d34:	792b      	ldrb	r3, [r5, #4]
    1d36:	f043 0303 	orr.w	r3, r3, #3
    1d3a:	712b      	strb	r3, [r5, #4]
		pdu_ctrl_tx->len =
    1d3c:	2305      	movs	r3, #5
    1d3e:	716b      	strb	r3, [r5, #5]
		pdu_ctrl_tx->llctrl.opcode =
    1d40:	2318      	movs	r3, #24
    1d42:	71eb      	strb	r3, [r5, #7]
		ind->m_to_s_phy = conn->llcp.phy_upd_ind.tx;
    1d44:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    1d48:	f3c3 0382 	ubfx	r3, r3, #2, #3
    1d4c:	722b      	strb	r3, [r5, #8]
		ind->s_to_m_phy = conn->llcp.phy_upd_ind.rx;
    1d4e:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    1d52:	f3c3 1342 	ubfx	r3, r3, #5, #3
    1d56:	726b      	strb	r3, [r5, #9]
		ind->instant = sys_cpu_to_le16(conn->llcp.phy_upd_ind.instant);
    1d58:	f8b4 30ee 	ldrh.w	r3, [r4, #238]	; 0xee
    1d5c:	816b      	strh	r3, [r5, #10]
		ctrl_tx_enqueue(conn, tx);
    1d5e:	e425      	b.n	15ac <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x224>
			conn->llcp.phy_upd_ind.instant = event_counter +
    1d60:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    1d62:	449a      	add	sl, r3
							 lll->latency +
    1d64:	f10a 0a06 	add.w	sl, sl, #6
			conn->llcp.phy_upd_ind.instant = event_counter +
    1d68:	f8a4 a0ee 	strh.w	sl, [r4, #238]	; 0xee
			(void)ll_pdu_rx_alloc();
    1d6c:	f00e fb12 	bl	10394 <ll_pdu_rx_alloc>
			rx->hdr.link->mem = conn->llcp_rx;
    1d70:	6833      	ldr	r3, [r6, #0]
    1d72:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
    1d76:	605a      	str	r2, [r3, #4]
			conn->llcp_rx = rx;
    1d78:	f8c4 6100 	str.w	r6, [r4, #256]	; 0x100
			rx = ll_pdu_rx_alloc();
    1d7c:	f00e fb0a 	bl	10394 <ll_pdu_rx_alloc>
			rx->hdr.link->mem = conn->llcp_rx;
    1d80:	6803      	ldr	r3, [r0, #0]
    1d82:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
    1d86:	605a      	str	r2, [r3, #4]
			conn->llcp_rx = rx;
    1d88:	f8c4 0100 	str.w	r0, [r4, #256]	; 0x100
    1d8c:	e7d2      	b.n	1d34 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x9ac>
	} else if (((event_counter - conn->llcp.phy_upd_ind.instant) &
    1d8e:	f8b4 30ee 	ldrh.w	r3, [r4, #238]	; 0xee
    1d92:	ebaa 0a03 	sub.w	sl, sl, r3
    1d96:	f41a 4f00 	tst.w	sl, #32768	; 0x8000
    1d9a:	f47f ac0b 	bne.w	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
		old_tx = lll->phy_tx;
    1d9e:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
		old_rx = lll->phy_rx;
    1da2:	f894 5065 	ldrb.w	r5, [r4, #101]	; 0x65
		conn->llcp_ack = conn->llcp_req;
    1da6:	f884 10e9 	strb.w	r1, [r4, #233]	; 0xe9
		if (conn->llcp.phy_upd_ind.tx) {
    1daa:	f012 0f1c 	tst.w	r2, #28
		old_tx = lll->phy_tx;
    1dae:	f003 0707 	and.w	r7, r3, #7
		old_rx = lll->phy_rx;
    1db2:	f005 0507 	and.w	r5, r5, #7
		u16_t eff_rx_time = lll->max_rx_time;
    1db6:	f8b4 6062 	ldrh.w	r6, [r4, #98]	; 0x62
		if (conn->llcp.phy_upd_ind.tx) {
    1dba:	d16a      	bne.n	1e92 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xb0a>
		u16_t eff_tx_time = lll->max_tx_time;
    1dbc:	f8b4 8060 	ldrh.w	r8, [r4, #96]	; 0x60
		if (conn->llcp.phy_upd_ind.rx) {
    1dc0:	f012 0fe0 	tst.w	r2, #224	; 0xe0
    1dc4:	d008      	beq.n	1dd8 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xa50>
			lll->phy_rx = conn->llcp.phy_upd_ind.rx;
    1dc6:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
    1dca:	0952      	lsrs	r2, r2, #5
    1dcc:	f362 0302 	bfi	r3, r2, #0, #3
    1dd0:	f884 3065 	strb.w	r3, [r4, #101]	; 0x65
		eff_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0);
    1dd4:	f44f 76a4 	mov.w	r6, #328	; 0x148
		lll->phy_flags = conn->phy_pref_flags;
    1dd8:	f894 31ac 	ldrb.w	r3, [r4, #428]	; 0x1ac
    1ddc:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
		rx = conn->llcp_rx;
    1de0:	f8d4 9100 	ldr.w	r9, [r4, #256]	; 0x100
		lll->phy_flags = conn->phy_pref_flags;
    1de4:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    1de8:	f363 02c3 	bfi	r2, r3, #3, #1
    1dec:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
		LL_ASSERT(rx && rx->hdr.link);
    1df0:	f1b9 0f00 	cmp.w	r9, #0
    1df4:	d002      	beq.n	1dfc <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xa74>
    1df6:	f8d9 3000 	ldr.w	r3, [r9]
    1dfa:	b963      	cbnz	r3, 1e16 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xa8e>
    1dfc:	f44f 6360 	mov.w	r3, #3584	; 0xe00
    1e00:	4a73      	ldr	r2, [pc, #460]	; (1fd0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xc48>)
    1e02:	4974      	ldr	r1, [pc, #464]	; (1fd4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xc4c>)
    1e04:	4874      	ldr	r0, [pc, #464]	; (1fd8 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xc50>)
    1e06:	f017 fab5 	bl	19374 <printk>
    1e0a:	4040      	eors	r0, r0
    1e0c:	f380 8811 	msr	BASEPRI, r0
    1e10:	f04f 0003 	mov.w	r0, #3
    1e14:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
    1e16:	f8d9 0000 	ldr.w	r0, [r9]
    1e1a:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
    1e1e:	6843      	ldr	r3, [r0, #4]
    1e20:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		if (!conn->llcp.phy_upd_ind.cmd && (lll->phy_tx == old_tx) &&
    1e24:	f894 e0ec 	ldrb.w	lr, [r4, #236]	; 0xec
    1e28:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
    1e2c:	f3c2 0202 	ubfx	r2, r2, #0, #3
    1e30:	f3c3 0302 	ubfx	r3, r3, #0, #3
    1e34:	f01e 0f02 	tst.w	lr, #2
    1e38:	fa5f fc82 	uxtb.w	ip, r2
    1e3c:	b2d9      	uxtb	r1, r3
    1e3e:	d142      	bne.n	1ec6 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xb3e>
    1e40:	4567      	cmp	r7, ip
    1e42:	d140      	bne.n	1ec6 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xb3e>
    1e44:	428d      	cmp	r5, r1
    1e46:	d13e      	bne.n	1ec6 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xb3e>
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
    1e48:	2303      	movs	r3, #3
    1e4a:	f889 3004 	strb.w	r3, [r9, #4]
			ll_rx_put(rx->hdr.link, rx);
    1e4e:	4649      	mov	r1, r9
    1e50:	f00e fa78 	bl	10344 <ll_rx_put>
				rx = conn->llcp_rx;
    1e54:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
				LL_ASSERT(rx && rx->hdr.link);
    1e58:	b10d      	cbz	r5, 1e5e <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xad6>
    1e5a:	682b      	ldr	r3, [r5, #0]
    1e5c:	b963      	cbnz	r3, 1e78 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xaf0>
    1e5e:	f640 630f 	movw	r3, #3599	; 0xe0f
    1e62:	4a5b      	ldr	r2, [pc, #364]	; (1fd0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xc48>)
    1e64:	495b      	ldr	r1, [pc, #364]	; (1fd4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xc4c>)
    1e66:	485c      	ldr	r0, [pc, #368]	; (1fd8 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xc50>)
    1e68:	f017 fa84 	bl	19374 <printk>
    1e6c:	4040      	eors	r0, r0
    1e6e:	f380 8811 	msr	BASEPRI, r0
    1e72:	f04f 0003 	mov.w	r0, #3
    1e76:	df02      	svc	2
				conn->llcp_rx = rx->hdr.link->mem;
    1e78:	6828      	ldr	r0, [r5, #0]
    1e7a:	6843      	ldr	r3, [r0, #4]
    1e7c:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
    1e80:	2303      	movs	r3, #3
    1e82:	712b      	strb	r3, [r5, #4]
		ll_rx_put(rx->hdr.link, rx);
    1e84:	4629      	mov	r1, r5
    1e86:	f00e fa5d 	bl	10344 <ll_rx_put>
		ll_rx_sched();
    1e8a:	f00e fa65 	bl	10358 <ll_rx_sched>
    1e8e:	f7ff bb91 	b.w	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
			lll->phy_tx = conn->llcp.phy_upd_ind.tx;
    1e92:	f3c2 0182 	ubfx	r1, r2, #2, #3
    1e96:	f361 0302 	bfi	r3, r1, #0, #3
    1e9a:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
	u16_t time = PKT_US(max_octets, phy);
    1e9e:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
    1ea2:	330e      	adds	r3, #14
    1ea4:	00db      	lsls	r3, r3, #3
    1ea6:	f3c1 0140 	ubfx	r1, r1, #1, #1
    1eaa:	40cb      	lsrs	r3, r1
	if (time >= PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0)) {
    1eac:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
    1eb0:	d306      	bcc.n	1ec0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xb38>
		eff_time = MIN(time, default_time);
    1eb2:	f8b4 80d8 	ldrh.w	r8, [r4, #216]	; 0xd8
    1eb6:	b29b      	uxth	r3, r3
    1eb8:	4598      	cmp	r8, r3
    1eba:	bf28      	it	cs
    1ebc:	4698      	movcs	r8, r3
    1ebe:	e77f      	b.n	1dc0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xa38>
		eff_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0);
    1ec0:	f44f 78a4 	mov.w	r8, #328	; 0x148
    1ec4:	e77c      	b.n	1dc0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xa38>
		rx->hdr.handle = lll->handle;
    1ec6:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
    1ec8:	f8a9 1006 	strh.w	r1, [r9, #6]
		rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
    1ecc:	210e      	movs	r1, #14
    1ece:	f889 1004 	strb.w	r1, [r9, #4]
		upd->status = 0U;
    1ed2:	2100      	movs	r1, #0
    1ed4:	f889 1020 	strb.w	r1, [r9, #32]
		upd->tx = lll->phy_tx;
    1ed8:	f889 2021 	strb.w	r2, [r9, #33]	; 0x21
		upd->rx = lll->phy_rx;
    1edc:	f889 3022 	strb.w	r3, [r9, #34]	; 0x22
		ll_rx_put(rx->hdr.link, rx);
    1ee0:	4649      	mov	r1, r9
    1ee2:	f00e fa2f 	bl	10344 <ll_rx_put>
		rx = conn->llcp_rx;
    1ee6:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
		LL_ASSERT(rx && rx->hdr.link);
    1eea:	b10d      	cbz	r5, 1ef0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xb68>
    1eec:	682b      	ldr	r3, [r5, #0]
    1eee:	b963      	cbnz	r3, 1f0a <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xb82>
    1ef0:	f640 632c 	movw	r3, #3628	; 0xe2c
    1ef4:	4a36      	ldr	r2, [pc, #216]	; (1fd0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xc48>)
    1ef6:	4937      	ldr	r1, [pc, #220]	; (1fd4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xc4c>)
    1ef8:	4837      	ldr	r0, [pc, #220]	; (1fd8 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xc50>)
    1efa:	f017 fa3b 	bl	19374 <printk>
    1efe:	4040      	eors	r0, r0
    1f00:	f380 8811 	msr	BASEPRI, r0
    1f04:	f04f 0003 	mov.w	r0, #3
    1f08:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
    1f0a:	6828      	ldr	r0, [r5, #0]
    1f0c:	6843      	ldr	r3, [r0, #4]
    1f0e:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		if ((eff_tx_time <= lll->max_tx_time) &&
    1f12:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
    1f16:	4543      	cmp	r3, r8
    1f18:	d303      	bcc.n	1f22 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xb9a>
    1f1a:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
    1f1e:	42b3      	cmp	r3, r6
    1f20:	d2ae      	bcs.n	1e80 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xaf8>
		rx->hdr.handle = lll->handle;
    1f22:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
		lll->max_tx_time = eff_tx_time;
    1f24:	f8a4 8060 	strh.w	r8, [r4, #96]	; 0x60
		lll->max_rx_time = eff_rx_time;
    1f28:	f8a4 6062 	strh.w	r6, [r4, #98]	; 0x62
		rx->hdr.handle = lll->handle;
    1f2c:	80eb      	strh	r3, [r5, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    1f2e:	2302      	movs	r3, #2
    1f30:	712b      	strb	r3, [r5, #4]
		pdu_rx->ll_id = PDU_DATA_LLID_CTRL;
    1f32:	f895 3020 	ldrb.w	r3, [r5, #32]
    1f36:	f043 0303 	orr.w	r3, r3, #3
    1f3a:	f885 3020 	strb.w	r3, [r5, #32]
		pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
    1f3e:	2309      	movs	r3, #9
    1f40:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
		pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
    1f44:	2315      	movs	r3, #21
    1f46:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
    1f4a:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
    1f4e:	84ab      	strh	r3, [r5, #36]	; 0x24
		lr->max_tx_octets = sys_cpu_to_le16(lll->max_tx_octets);
    1f50:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
    1f54:	852b      	strh	r3, [r5, #40]	; 0x28
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
    1f56:	84ee      	strh	r6, [r5, #38]	; 0x26
		lr->max_tx_time = sys_cpu_to_le16(lll->max_tx_time);
    1f58:	f8a5 802a 	strh.w	r8, [r5, #42]	; 0x2a
    1f5c:	e792      	b.n	1e84 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xafc>
			LL_ASSERT(0);
    1f5e:	f240 3376 	movw	r3, #886	; 0x376
    1f62:	4a1b      	ldr	r2, [pc, #108]	; (1fd0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xc48>)
    1f64:	491d      	ldr	r1, [pc, #116]	; (1fdc <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xc54>)
    1f66:	481c      	ldr	r0, [pc, #112]	; (1fd8 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xc50>)
    1f68:	f017 fa04 	bl	19374 <printk>
    1f6c:	4040      	eors	r0, r0
    1f6e:	f380 8811 	msr	BASEPRI, r0
    1f72:	f04f 0003 	mov.w	r0, #3
    1f76:	df02      	svc	2
			break;
    1f78:	f7ff bb1c 	b.w	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    1f7c:	4813      	ldr	r0, [pc, #76]	; (1fcc <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xc44>)
    1f7e:	f01a ff75 	bl	1ce6c <mem_acquire>
		if (tx) {
    1f82:	4601      	mov	r1, r0
    1f84:	b180      	cbz	r0, 1fa8 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xc20>
			conn->llcp_terminate.ack = conn->llcp_terminate.req;
    1f86:	f894 3128 	ldrb.w	r3, [r4, #296]	; 0x128
    1f8a:	f884 3129 	strb.w	r3, [r4, #297]	; 0x129
			pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
    1f8e:	7903      	ldrb	r3, [r0, #4]
    1f90:	f043 0303 	orr.w	r3, r3, #3
    1f94:	7103      	strb	r3, [r0, #4]
			pdu_tx->len = offsetof(struct pdu_data_llctrl,
    1f96:	2302      	movs	r3, #2
    1f98:	7143      	strb	r3, [r0, #5]
			pdu_tx->llctrl.opcode =
    1f9a:	71c3      	strb	r3, [r0, #7]
			pdu_tx->llctrl.terminate_ind.error_code =
    1f9c:	f894 312a 	ldrb.w	r3, [r4, #298]	; 0x12a
    1fa0:	7203      	strb	r3, [r0, #8]
			ctrl_tx_enqueue(conn, tx);
    1fa2:	4620      	mov	r0, r4
    1fa4:	f01b fb2b 	bl	1d5fe <ctrl_tx_enqueue>
		if (!conn->procedure_expire) {
    1fa8:	f8b4 00cc 	ldrh.w	r0, [r4, #204]	; 0xcc
    1fac:	2800      	cmp	r0, #0
    1fae:	f47f ab08 	bne.w	15c2 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x23a>
			conn->procedure_expire = conn->supervision_reload;
    1fb2:	f8b4 30c6 	ldrh.w	r3, [r4, #198]	; 0xc6
			if (conn->procedure_expire <= 1U) {
    1fb6:	2b01      	cmp	r3, #1
    1fb8:	d903      	bls.n	1fc2 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xc3a>
			conn->procedure_expire = conn->supervision_reload;
    1fba:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
    1fbe:	f7ff bb00 	b.w	15c2 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x23a>
				conn->procedure_expire++;
    1fc2:	3301      	adds	r3, #1
    1fc4:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
    1fc8:	f7ff bafc 	b.w	15c4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x23c>
    1fcc:	200013d4 	.word	0x200013d4
    1fd0:	00021f06 	.word	0x00021f06
    1fd4:	00021fcd 	.word	0x00021fcd
    1fd8:	00020aa4 	.word	0x00020aa4
    1fdc:	00022577 	.word	0x00022577

00001fe0 <ull_slave_setup>:
static void ticker_op_stop_adv_cb(u32_t status, void *param);
static void ticker_op_cb(u32_t status, void *param);

void ull_slave_setup(memq_link_t *link, struct node_rx_hdr *rx,
		     struct node_rx_ftr *ftr, struct lll_conn *lll)
{
    1fe0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1fe4:	b097      	sub	sp, #92	; 0x5c
    1fe6:	461d      	mov	r5, r3
    1fe8:	900e      	str	r0, [sp, #56]	; 0x38
	u16_t win_offset;
	u16_t timeout;
	u16_t interval;
	u8_t chan_sel;

	((struct lll_adv *)ftr->param)->conn = NULL;
    1fea:	6813      	ldr	r3, [r2, #0]

	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
	conn = lll->hdr.parent;
    1fec:	4628      	mov	r0, r5
{
    1fee:	4690      	mov	r8, r2
	((struct lll_adv *)ftr->param)->conn = NULL;
    1ff0:	2200      	movs	r2, #0
{
    1ff2:	460c      	mov	r4, r1
	conn = lll->hdr.parent;
    1ff4:	f850 6b0c 	ldr.w	r6, [r0], #12
	((struct lll_adv *)ftr->param)->conn = NULL;
    1ff8:	609a      	str	r2, [r3, #8]

	/* Populate the slave context */
	pdu_adv = (void *)((struct node_rx_pdu *)rx)->pdu;
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
    1ffa:	f105 0a08 	add.w	sl, r5, #8
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
    1ffe:	2203      	movs	r2, #3
    2000:	3132      	adds	r1, #50	; 0x32
	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
    2002:	f8d3 9000 	ldr.w	r9, [r3]
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
    2006:	f105 071c 	add.w	r7, r5, #28
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
    200a:	f018 fff6 	bl	1affa <memcpy>
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
    200e:	2204      	movs	r2, #4
    2010:	f104 012e 	add.w	r1, r4, #46	; 0x2e
    2014:	4650      	mov	r0, sl
    2016:	f018 fff0 	bl	1affa <memcpy>
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
    201a:	2205      	movs	r2, #5
    201c:	f104 013e 	add.w	r1, r4, #62	; 0x3e
    2020:	4638      	mov	r0, r7
    2022:	f018 ffea 	bl	1affa <memcpy>
	       sizeof(lll->data_chan_map));
	lll->data_chan_count = util_ones_count_get(&lll->data_chan_map[0],
    2026:	2105      	movs	r1, #5
    2028:	4638      	mov	r0, r7
    202a:	f01a ff9b 	bl	1cf64 <util_ones_count_get>
    202e:	f895 3021 	ldrb.w	r3, [r5, #33]	; 0x21
    2032:	f360 0305 	bfi	r3, r0, #0, #6
    2036:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
			       sizeof(lll->data_chan_map));
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
    203a:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    203e:	f3c3 0304 	ubfx	r3, r3, #0, #5
    2042:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
	interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);
    2046:	8f27      	ldrh	r7, [r4, #56]	; 0x38
	lll->interval = interval;
    2048:	826f      	strh	r7, [r5, #18]
	lll->latency = sys_le16_to_cpu(pdu_adv->connect_ind.latency);
    204a:	f894 203b 	ldrb.w	r2, [r4, #59]	; 0x3b
    204e:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
    2052:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    2056:	82ab      	strh	r3, [r5, #20]

	win_offset = sys_le16_to_cpu(pdu_adv->connect_ind.win_offset);
    2058:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    205a:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
	conn_interval_us = interval * 1250U;

	/* calculate the window widening */
	conn->slave.sca = pdu_adv->connect_ind.sca;
    205e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    2062:	f896 20dc 	ldrb.w	r2, [r6, #220]	; 0xdc
    2066:	095b      	lsrs	r3, r3, #5
    2068:	f363 0284 	bfi	r2, r3, #2, #3
    206c:	f886 20dc 	strb.w	r2, [r6, #220]	; 0xdc
	lll->slave.window_widening_periodic_us =
		(((lll_conn_ppm_local_get() +
    2070:	f01b fc8d 	bl	1d98e <lll_conn_ppm_local_get>
    2074:	900a      	str	r0, [sp, #40]	; 0x28
		   lll_conn_ppm_get(conn->slave.sca)) *
    2076:	f896 00dc 	ldrb.w	r0, [r6, #220]	; 0xdc
    207a:	f3c0 0082 	ubfx	r0, r0, #2, #3
    207e:	f012 f9e5 	bl	1444c <lll_conn_ppm_get>
		(((lll_conn_ppm_local_get() +
    2082:	9b0a      	ldr	r3, [sp, #40]	; 0x28
					      conn_interval_us);
	/* Dispatch LE Ping PDU 6 connection events (that peer would
	 * listen to) before 30s timeout
	 * TODO: "peer listens to" is greater than 30s due to latency
	 */
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    2084:	8aa9      	ldrh	r1, [r5, #20]
	conn_interval_us = interval * 1250U;
    2086:	f240 4be2 	movw	fp, #1250	; 0x4e2
    208a:	fb0b f707 	mul.w	r7, fp, r7
		(((lll_conn_ppm_local_get() +
    208e:	4418      	add	r0, r3
		   lll_conn_ppm_get(conn->slave.sca)) *
    2090:	4378      	muls	r0, r7
		  conn_interval_us) + (1000000 - 1)) / 1000000U;
    2092:	f500 2074 	add.w	r0, r0, #999424	; 0xf4000
    2096:	4bb8      	ldr	r3, [pc, #736]	; (2378 <ull_slave_setup+0x398>)
    2098:	f200 203f 	addw	r0, r0, #575	; 0x23f
    209c:	fbb0 f0f3 	udiv	r0, r0, r3
	lll->slave.window_widening_max_us = (conn_interval_us >> 1) -
    20a0:	087b      	lsrs	r3, r7, #1
    20a2:	3b96      	subs	r3, #150	; 0x96
    20a4:	62eb      	str	r3, [r5, #44]	; 0x2c
	lll->slave.window_size_event_us = pdu_adv->connect_ind.win_size * 1250U;
    20a6:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
	lll->slave.window_widening_periodic_us =
    20aa:	62a8      	str	r0, [r5, #40]	; 0x28
	lll->slave.window_size_event_us = pdu_adv->connect_ind.win_size * 1250U;
    20ac:	fb0b f303 	mul.w	r3, fp, r3
    20b0:	63eb      	str	r3, [r5, #60]	; 0x3c
	timeout = sys_le16_to_cpu(pdu_adv->connect_ind.timeout);
    20b2:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
    20b4:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
    20b8:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
    20bc:	f242 7310 	movw	r3, #10000	; 0x2710
    20c0:	fb03 7302 	mla	r3, r3, r2, r7
    20c4:	3b01      	subs	r3, #1
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    20c6:	4aad      	ldr	r2, [pc, #692]	; (237c <ull_slave_setup+0x39c>)
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
    20c8:	fbb3 f3f7 	udiv	r3, r3, r7
    20cc:	f8a6 30c6 	strh.w	r3, [r6, #198]	; 0xc6
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    20d0:	4bab      	ldr	r3, [pc, #684]	; (2380 <ull_slave_setup+0x3a0>)
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    20d2:	1d88      	adds	r0, r1, #6
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    20d4:	443b      	add	r3, r7
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    20d6:	443a      	add	r2, r7
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    20d8:	fbb3 f3f7 	udiv	r3, r3, r7
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    20dc:	fbb2 f2f7 	udiv	r2, r2, r7
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    20e0:	f8a6 30ca 	strh.w	r3, [r6, #202]	; 0xca
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    20e4:	b293      	uxth	r3, r2
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    20e6:	4283      	cmp	r3, r0
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    20e8:	f8a6 30d2 	strh.w	r3, [r6, #210]	; 0xd2
			     (conn->apto_reload - (lll->latency + 6)) :
    20ec:	bfc2      	ittt	gt
    20ee:	1a5b      	subgt	r3, r3, r1
    20f0:	3b06      	subgt	r3, #6
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    20f2:	b29b      	uxthgt	r3, r3
			     conn->apto_reload;
#endif /* CONFIG_BT_CTLR_LE_PING */

	memcpy((void *)&conn->slave.force, &lll->access_addr[0],
    20f4:	4651      	mov	r1, sl
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    20f6:	f8a6 30ce 	strh.w	r3, [r6, #206]	; 0xce
	memcpy((void *)&conn->slave.force, &lll->access_addr[0],
    20fa:	2204      	movs	r2, #4
    20fc:	f106 00e0 	add.w	r0, r6, #224	; 0xe0
    2100:	f018 ff7b 	bl	1affa <memcpy>
	       sizeof(conn->slave.force));

#if defined(CONFIG_BT_CTLR_PRIVACY)
	u8_t own_addr_type = pdu_adv->rx_addr;
	u8_t own_addr[BDADDR_SIZE];
	u8_t rl_idx = ftr->rl_idx;
    2104:	f898 3015 	ldrb.w	r3, [r8, #21]
	u8_t own_addr_type = pdu_adv->rx_addr;
    2108:	f894 a020 	ldrb.w	sl, [r4, #32]
	u8_t rl_idx = ftr->rl_idx;
    210c:	930a      	str	r3, [sp, #40]	; 0x28

	memcpy(own_addr, &pdu_adv->connect_ind.adv_addr[0], BDADDR_SIZE);
    210e:	2206      	movs	r2, #6
    2110:	f104 0128 	add.w	r1, r4, #40	; 0x28
    2114:	a814      	add	r0, sp, #80	; 0x50
    2116:	f018 ff70 	bl	1affa <memcpy>
#endif

	peer_addr_type = pdu_adv->tx_addr;
    211a:	f894 3020 	ldrb.w	r3, [r4, #32]
    211e:	f3c3 1380 	ubfx	r3, r3, #6, #1
    2122:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
    2126:	f104 0322 	add.w	r3, r4, #34	; 0x22
    212a:	4619      	mov	r1, r3
    212c:	2206      	movs	r2, #6
    212e:	a812      	add	r0, sp, #72	; 0x48
    2130:	9311      	str	r3, [sp, #68]	; 0x44
    2132:	f018 ff62 	bl	1affa <memcpy>

	chan_sel = pdu_adv->chan_sel;
    2136:	f894 2020 	ldrb.w	r2, [r4, #32]
	u8_t own_addr_type = pdu_adv->rx_addr;
    213a:	f3ca 1ac0 	ubfx	sl, sl, #7, #1
	chan_sel = pdu_adv->chan_sel;
    213e:	f3c2 1340 	ubfx	r3, r2, #5, #1

	cc = (void *)pdu_adv;
	cc->status = 0U;
    2142:	f44f 7280 	mov.w	r2, #256	; 0x100
	chan_sel = pdu_adv->chan_sel;
    2146:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	cc->status = 0U;
    214a:	8422      	strh	r2, [r4, #32]
	chan_sel = pdu_adv->chan_sel;
    214c:	b2db      	uxtb	r3, r3
	cc->role = 1U;

#if defined(CONFIG_BT_CTLR_PRIVACY)
	cc->own_addr_type = own_addr_type;
    214e:	f884 a02f 	strb.w	sl, [r4, #47]	; 0x2f
	memcpy(&cc->own_addr[0], &own_addr[0], BDADDR_SIZE);
    2152:	2206      	movs	r2, #6
    2154:	a914      	add	r1, sp, #80	; 0x50
    2156:	f104 0030 	add.w	r0, r4, #48	; 0x30
	chan_sel = pdu_adv->chan_sel;
    215a:	930d      	str	r3, [sp, #52]	; 0x34
	memcpy(&cc->own_addr[0], &own_addr[0], BDADDR_SIZE);
    215c:	f018 ff4d 	bl	1affa <memcpy>

	if (rl_idx != FILTER_IDX_NONE) {
    2160:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    2162:	2bff      	cmp	r3, #255	; 0xff
    2164:	f104 0b29 	add.w	fp, r4, #41	; 0x29
    2168:	f104 0a23 	add.w	sl, r4, #35	; 0x23
    216c:	f000 80ee 	beq.w	234c <ull_slave_setup+0x36c>
		/* TODO: store rl_idx instead if safe */
		/* Store identity address */
		ll_rl_id_addr_get(rl_idx, &cc->peer_addr_type,
    2170:	9b11      	ldr	r3, [sp, #68]	; 0x44
    2172:	980a      	ldr	r0, [sp, #40]	; 0x28
    2174:	4619      	mov	r1, r3
    2176:	4652      	mov	r2, sl
    2178:	f012 fe40 	bl	14dfc <ll_rl_id_addr_get>
				  &cc->peer_addr[0]);
		/* Mark it as identity address from RPA (0x02, 0x03) */
		cc->peer_addr_type += 2;
    217c:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    2180:	3302      	adds	r3, #2
    2182:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22

		/* Store peer RPA */
		memcpy(&cc->peer_rpa[0], &peer_addr[0], BDADDR_SIZE);
    2186:	2206      	movs	r2, #6
    2188:	a912      	add	r1, sp, #72	; 0x48
    218a:	4658      	mov	r0, fp
		memset(&cc->peer_rpa[0], 0x0, BDADDR_SIZE);
#else
	if (1) {
#endif /* CONFIG_BT_CTLR_PRIVACY */
		cc->peer_addr_type = peer_addr_type;
		memcpy(cc->peer_addr, peer_addr, BDADDR_SIZE);
    218c:	f018 ff35 	bl	1affa <memcpy>
	}

	cc->interval = lll->interval;
    2190:	8a6b      	ldrh	r3, [r5, #18]
    2192:	86e3      	strh	r3, [r4, #54]	; 0x36
	cc->latency = lll->latency;
    2194:	8aab      	ldrh	r3, [r5, #20]
    2196:	8723      	strh	r3, [r4, #56]	; 0x38
	cc->timeout = timeout;
    2198:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
    219c:	8763      	strh	r3, [r4, #58]	; 0x3a
	cc->sca = conn->slave.sca;
    219e:	f896 30dc 	ldrb.w	r3, [r6, #220]	; 0xdc
    21a2:	f3c3 0382 	ubfx	r3, r3, #2, #3
    21a6:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c

	lll->handle = ll_conn_handle_get(conn);
    21aa:	4630      	mov	r0, r6
    21ac:	f010 f8a4 	bl	122f8 <ll_conn_handle_get>
		struct node_rx_cs *cs;

		/* pick the rx node instance stored within the connection
		 * rx node.
		 */
		rx_csa = (void *)ftr->extra;
    21b0:	f8d8 a004 	ldr.w	sl, [r8, #4]
	lll->handle = ll_conn_handle_get(conn);
    21b4:	8228      	strh	r0, [r5, #16]

		/* Enqueue the connection event */
		ll_rx_put(link, rx);
    21b6:	4621      	mov	r1, r4
	rx->handle = lll->handle;
    21b8:	80e0      	strh	r0, [r4, #6]
		ll_rx_put(link, rx);
    21ba:	980e      	ldr	r0, [sp, #56]	; 0x38
    21bc:	f00e f8c2 	bl	10344 <ll_rx_put>

		/* use the rx node for CSA event */
		rx = (void *)rx_csa;
		link = rx->link;

		rx->handle = lll->handle;
    21c0:	8a2b      	ldrh	r3, [r5, #16]
    21c2:	f8aa 3006 	strh.w	r3, [sl, #6]
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
    21c6:	230d      	movs	r3, #13
    21c8:	f88a 3004 	strb.w	r3, [sl, #4]

		cs = (void *)rx_csa->pdu;

		if (chan_sel) {
    21cc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
		link = rx->link;
    21ce:	f8da 0000 	ldr.w	r0, [sl]
		if (chan_sel) {
    21d2:	2b00      	cmp	r3, #0
    21d4:	f000 80c7 	beq.w	2366 <ull_slave_setup+0x386>
			u16_t aa_ls = ((u16_t)lll->access_addr[1] << 8) |
    21d8:	7a6a      	ldrb	r2, [r5, #9]
				      lll->access_addr[0];
    21da:	7a2b      	ldrb	r3, [r5, #8]
			u16_t aa_ms = ((u16_t)lll->access_addr[3] << 8) |
    21dc:	7ae9      	ldrb	r1, [r5, #11]
			u16_t aa_ls = ((u16_t)lll->access_addr[1] << 8) |
    21de:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
				      lll->access_addr[2];
    21e2:	7aaa      	ldrb	r2, [r5, #10]
			u16_t aa_ms = ((u16_t)lll->access_addr[3] << 8) |
    21e4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8

			lll->data_chan_sel = 1;
    21e8:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
			lll->data_chan_id = aa_ms ^ aa_ls;
    21ec:	4053      	eors	r3, r2
			lll->data_chan_sel = 1;
    21ee:	f041 0140 	orr.w	r1, r1, #64	; 0x40
			lll->data_chan_id = aa_ms ^ aa_ls;
    21f2:	846b      	strh	r3, [r5, #34]	; 0x22
			lll->data_chan_sel = 1;
    21f4:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21

			cs->csa = 0x01;
    21f8:	2301      	movs	r3, #1
		} else {
			cs->csa = 0x00;
    21fa:	f88a 3020 	strb.w	r3, [sl, #32]
		}
	}

	ll_rx_put(link, rx);
    21fe:	4651      	mov	r1, sl
    2200:	f00e f8a0 	bl	10344 <ll_rx_put>
	ll_rx_sched();
    2204:	f00e f8a8 	bl	10358 <ll_rx_sched>
	conn->evt.ticks_xtal_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US);
	conn->evt.ticks_preempt_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_PREEMPT_MIN_US);
	conn->evt.ticks_slot =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    2208:	f8d8 b010 	ldr.w	fp, [r8, #16]
    220c:	f8df a190 	ldr.w	sl, [pc, #400]	; 23a0 <ull_slave_setup+0x3c0>
	conn->evt.ticks_xtal_to_start =
    2210:	2400      	movs	r4, #0
    2212:	2331      	movs	r3, #49	; 0x31
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    2214:	f20b 4052 	addw	r0, fp, #1106	; 0x452
	conn->evt.ticks_xtal_to_start =
    2218:	e9c6 3400 	strd	r3, r4, [r6]
	conn->evt.ticks_preempt_to_start =
    221c:	60b4      	str	r4, [r6, #8]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    221e:	a354      	add	r3, pc, #336	; (adr r3, 2370 <ull_slave_setup+0x390>)
    2220:	e9d3 2300 	ldrd	r2, r3, [r3]
    2224:	fba0 010a 	umull	r0, r1, r0, sl
    2228:	f7fd ff5a 	bl	e0 <__aeabi_uldivmod>
		ticks_slot_overhead = ticks_slot_offset;
	} else {
		ticks_slot_overhead = 0U;
	}

	conn_interval_us -= lll->slave.window_widening_periodic_us;
    222c:	6aab      	ldr	r3, [r5, #40]	; 0x28

	conn_offset_us = ftr->us_radio_end;
	conn_offset_us += ((u64_t)win_offset + 1) * 1250U;
    222e:	f8bd 203c 	ldrh.w	r2, [sp, #60]	; 0x3c
	conn_interval_us -= lll->slave.window_widening_periodic_us;
    2232:	1aff      	subs	r7, r7, r3
    2234:	f8d8 300c 	ldr.w	r3, [r8, #12]
    2238:	f5a3 73ae 	sub.w	r3, r3, #348	; 0x15c
    223c:	eba3 030b 	sub.w	r3, r3, fp
	conn_offset_us += ((u64_t)win_offset + 1) * 1250U;
    2240:	f240 4be2 	movw	fp, #1250	; 0x4e2
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    2244:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	conn_offset_us += ((u64_t)win_offset + 1) * 1250U;
    2248:	fb0b bb02 	mla	fp, fp, r2, fp
	conn_offset_us -= EVENT_OVERHEAD_START_US;
	conn_offset_us -= EVENT_TICKER_RES_MARGIN_US;
	conn_offset_us -= EVENT_JITTER_US;
	conn_offset_us -= ftr->us_radio_rdy;
    224c:	445b      	add	r3, fp

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	/* disable ticker job, in order to chain stop and start to avoid RTC
	 * being stopped if no tickers active.
	 */
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    224e:	4622      	mov	r2, r4
    2250:	2102      	movs	r1, #2
	conn->evt.ticks_slot =
    2252:	60f0      	str	r0, [r6, #12]
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    2254:	2001      	movs	r0, #1
	conn_offset_us -= ftr->us_radio_rdy;
    2256:	930a      	str	r3, [sp, #40]	; 0x28
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    2258:	f00b fc18 	bl	da8c <mayfly_enable>
#endif

	/* Stop Advertiser */
	ticker_id_adv = TICKER_ID_ADV_BASE + ull_adv_handle_get(adv);
    225c:	4648      	mov	r0, r9
    225e:	f00f f959 	bl	11514 <ull_adv_handle_get>
    2262:	1c82      	adds	r2, r0, #2
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
    2264:	4b47      	ldr	r3, [pc, #284]	; (2384 <ull_slave_setup+0x3a4>)
    2266:	f8cd 9000 	str.w	r9, [sp]
    226a:	b2d2      	uxtb	r2, r2
    226c:	2101      	movs	r1, #1
    226e:	4620      	mov	r0, r4
    2270:	f00c f944 	bl	e4fc <ticker_stop>
				    TICKER_USER_ID_ULL_HIGH,
				    ticker_id_adv, ticker_op_stop_adv_cb, adv);
	ticker_op_stop_adv_cb(ticker_status, adv);
    2274:	4649      	mov	r1, r9
    2276:	f012 fb9d 	bl	149b4 <ticker_op_stop_adv_cb>

	/* Stop Direct Adv Stop */
	if (adv->lll.is_hdcd) {
    227a:	f899 3028 	ldrb.w	r3, [r9, #40]	; 0x28
    227e:	07db      	lsls	r3, r3, #31
    2280:	d506      	bpl.n	2290 <ull_slave_setup+0x2b0>
		/* Advertiser stop can expire while here in this ISR.
		 * Deferred attempt to stop can fail as it would have
		 * expired, hence ignore failure.
		 */
		ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
    2282:	2201      	movs	r2, #1
    2284:	9400      	str	r4, [sp, #0]
    2286:	4623      	mov	r3, r4
    2288:	4611      	mov	r1, r2
    228a:	4620      	mov	r0, r4
    228c:	f00c f936 	bl	e4fc <ticker_stop>
			    TICKER_ID_ADV_STOP, NULL, NULL);
	}

	/* Start Slave */
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    2290:	4630      	mov	r0, r6
    2292:	f010 f831 	bl	122f8 <ll_conn_handle_get>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
				     TICKER_USER_ID_ULL_HIGH,
				     ticker_id_conn,
				     ftr->ticks_anchor - ticks_slot_offset,
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
    2296:	fba7 450a 	umull	r4, r5, r7, sl
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    229a:	4681      	mov	r9, r0
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
    229c:	a334      	add	r3, pc, #208	; (adr r3, 2370 <ull_slave_setup+0x390>)
    229e:	e9d3 2300 	ldrd	r2, r3, [r3]
    22a2:	4620      	mov	r0, r4
    22a4:	4629      	mov	r1, r5
    22a6:	f7fd ff1b 	bl	e0 <__aeabi_uldivmod>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    22aa:	f8d8 3008 	ldr.w	r3, [r8, #8]
    22ae:	f1a3 0831 	sub.w	r8, r3, #49	; 0x31
    22b2:	f240 131d 	movw	r3, #285	; 0x11d
    22b6:	9308      	str	r3, [sp, #32]
    22b8:	4b33      	ldr	r3, [pc, #204]	; (2388 <ull_slave_setup+0x3a8>)
    22ba:	e9cd 6306 	strd	r6, r3, [sp, #24]
    22be:	4b33      	ldr	r3, [pc, #204]	; (238c <ull_slave_setup+0x3ac>)
    22c0:	9305      	str	r3, [sp, #20]
    22c2:	68f3      	ldr	r3, [r6, #12]
    22c4:	9304      	str	r3, [sp, #16]
				     HAL_TICKER_REMAINDER(conn_interval_us),
    22c6:	4b32      	ldr	r3, [pc, #200]	; (2390 <ull_slave_setup+0x3b0>)
    22c8:	f020 467f 	bic.w	r6, r0, #4278190080	; 0xff000000
    22cc:	fba6 bc03 	umull	fp, ip, r6, r3
    22d0:	2307      	movs	r3, #7
    22d2:	fb03 cc06 	mla	ip, r3, r6, ip
    22d6:	ebb4 000b 	subs.w	r0, r4, fp
    22da:	eb65 010c 	sbc.w	r1, r5, ip
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    22de:	f109 0703 	add.w	r7, r9, #3
				     HAL_TICKER_REMAINDER(conn_interval_us),
    22e2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    22e6:	f04f 0900 	mov.w	r9, #0
				     HAL_TICKER_REMAINDER(conn_interval_us),
    22ea:	2300      	movs	r3, #0
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    22ec:	f8cd 900c 	str.w	r9, [sp, #12]
				     HAL_TICKER_REMAINDER(conn_interval_us),
    22f0:	f7fd fef6 	bl	e0 <__aeabi_uldivmod>
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
    22f4:	990a      	ldr	r1, [sp, #40]	; 0x28
    22f6:	a31e      	add	r3, pc, #120	; (adr r3, 2370 <ull_slave_setup+0x390>)
    22f8:	e9d3 2300 	ldrd	r2, r3, [r3]
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    22fc:	e9cd 6001 	strd	r6, r0, [sp, #4]
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
    2300:	fba1 010a 	umull	r0, r1, r1, sl
    2304:	f7fd feec 	bl	e0 <__aeabi_uldivmod>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    2308:	b2ff      	uxtb	r7, r7
    230a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    230e:	9000      	str	r0, [sp, #0]
    2310:	4643      	mov	r3, r8
    2312:	463a      	mov	r2, r7
    2314:	2101      	movs	r1, #1
    2316:	4648      	mov	r0, r9
    2318:	f00c f85e 	bl	e3d8 <ticker_start>
#endif /* CONFIG_BT_CTLR_CONN_META */
				     (conn->evt.ticks_slot +
				      ticks_slot_overhead),
				     ull_slave_ticker_cb, conn, ticker_op_cb,
				     (void *)__LINE__);
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    231c:	f030 0302 	bics.w	r3, r0, #2
    2320:	d00c      	beq.n	233c <ull_slave_setup+0x35c>
    2322:	f240 131f 	movw	r3, #287	; 0x11f
    2326:	4a1b      	ldr	r2, [pc, #108]	; (2394 <ull_slave_setup+0x3b4>)
    2328:	491b      	ldr	r1, [pc, #108]	; (2398 <ull_slave_setup+0x3b8>)
    232a:	481c      	ldr	r0, [pc, #112]	; (239c <ull_slave_setup+0x3bc>)
    232c:	f017 f822 	bl	19374 <printk>
    2330:	4040      	eors	r0, r0
    2332:	f380 8811 	msr	BASEPRI, r0
    2336:	f04f 0003 	mov.w	r0, #3
    233a:	df02      	svc	2

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	/* enable ticker job, irrespective of disabled in this function so
	 * first connection event can be scheduled as soon as possible.
	 */
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1);
    233c:	2201      	movs	r2, #1
    233e:	2102      	movs	r1, #2
    2340:	4610      	mov	r0, r2
    2342:	f00b fba3 	bl	da8c <mayfly_enable>
#endif
}
    2346:	b017      	add	sp, #92	; 0x5c
    2348:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		memset(&cc->peer_rpa[0], 0x0, BDADDR_SIZE);
    234c:	2206      	movs	r2, #6
    234e:	2100      	movs	r1, #0
    2350:	4658      	mov	r0, fp
    2352:	f018 fe7c 	bl	1b04e <memset>
		cc->peer_addr_type = peer_addr_type;
    2356:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
    235a:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
		memcpy(cc->peer_addr, peer_addr, BDADDR_SIZE);
    235e:	2206      	movs	r2, #6
    2360:	a912      	add	r1, sp, #72	; 0x48
    2362:	4650      	mov	r0, sl
    2364:	e712      	b.n	218c <ull_slave_setup+0x1ac>
			cs->csa = 0x00;
    2366:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    236a:	e746      	b.n	21fa <ull_slave_setup+0x21a>
    236c:	f3af 8000 	nop.w
    2370:	1afd498d 	.word	0x1afd498d
    2374:	00000007 	.word	0x00000007
    2378:	000f4240 	.word	0x000f4240
    237c:	01c9c37f 	.word	0x01c9c37f
    2380:	026259ff 	.word	0x026259ff
    2384:	000149b5 	.word	0x000149b5
    2388:	00014989 	.word	0x00014989
    238c:	000149ed 	.word	0x000149ed
    2390:	1afd498d 	.word	0x1afd498d
    2394:	0002215e 	.word	0x0002215e
    2398:	00021e65 	.word	0x00021e65
    239c:	00020aa4 	.word	0x00020aa4
    23a0:	3b9aca00 	.word	0x3b9aca00
    23a4:	00000000 	.word	0x00000000

000023a8 <ull_slave_done>:
 * @param ticks_drift_plus[out]  Positive part of drift uncertainty window
 * @param ticks_drift_minus[out] Negative part of drift uncertainty window
 */
void ull_slave_done(struct node_rx_event_done *done, u32_t *ticks_drift_plus,
		    u32_t *ticks_drift_minus)
{
    23a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    23ac:	4689      	mov	r9, r1
	u32_t window_widening_event_us;
	u32_t preamble_to_addr_us;

	start_to_address_actual_us =
		done->extra.slave.start_to_address_actual_us;
	window_widening_event_us =
    23ae:	e9d0 710b 	ldrd	r7, r1, [r0, #44]	; 0x2c
		done->extra.slave.window_widening_event_us;
	preamble_to_addr_us =
    23b2:	6b46      	ldr	r6, [r0, #52]	; 0x34
		done->extra.slave.preamble_to_addr_us;

	start_to_address_expected_us = EVENT_JITTER_US +
    23b4:	4d16      	ldr	r5, [pc, #88]	; (2410 <ull_slave_done+0x68>)
				       EVENT_TICKER_RES_MARGIN_US +
				       window_widening_event_us +
    23b6:	198c      	adds	r4, r1, r6
	start_to_address_expected_us = EVENT_JITTER_US +
    23b8:	3430      	adds	r4, #48	; 0x30
				       preamble_to_addr_us;

	if (start_to_address_actual_us <= start_to_address_expected_us) {
    23ba:	42a7      	cmp	r7, r4
{
    23bc:	4690      	mov	r8, r2
		*ticks_drift_plus =
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
    23be:	a312      	add	r3, pc, #72	; (adr r3, 2408 <ull_slave_done+0x60>)
    23c0:	e9d3 2300 	ldrd	r2, r3, [r3]
	if (start_to_address_actual_us <= start_to_address_expected_us) {
    23c4:	d815      	bhi.n	23f2 <ull_slave_done+0x4a>
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
    23c6:	fba1 0105 	umull	r0, r1, r1, r5
    23ca:	f7fd fe89 	bl	e0 <__aeabi_uldivmod>
    23ce:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_plus =
    23d2:	f8c9 0000 	str.w	r0, [r9]
		*ticks_drift_minus =
			HAL_TICKER_US_TO_TICKS((start_to_address_expected_us -
    23d6:	1be0      	subs	r0, r4, r7
					       start_to_address_actual_us));
	} else {
		*ticks_drift_plus =
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
		*ticks_drift_minus =
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
    23d8:	a30b      	add	r3, pc, #44	; (adr r3, 2408 <ull_slave_done+0x60>)
    23da:	e9d3 2300 	ldrd	r2, r3, [r3]
    23de:	fba0 0105 	umull	r0, r1, r0, r5
    23e2:	f7fd fe7d 	bl	e0 <__aeabi_uldivmod>
    23e6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_minus =
    23ea:	f8c8 0000 	str.w	r0, [r8]
					       EVENT_TICKER_RES_MARGIN_US +
					       preamble_to_addr_us);
	}
}
    23ee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
    23f2:	fba7 0105 	umull	r0, r1, r7, r5
    23f6:	f7fd fe73 	bl	e0 <__aeabi_uldivmod>
    23fa:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_plus =
    23fe:	f8c9 0000 	str.w	r0, [r9]
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
    2402:	f106 0030 	add.w	r0, r6, #48	; 0x30
    2406:	e7e7      	b.n	23d8 <ull_slave_done+0x30>
    2408:	1afd498d 	.word	0x1afd498d
    240c:	00000007 	.word	0x00000007
    2410:	3b9aca00 	.word	0x3b9aca00
    2414:	00000000 	.word	0x00000000

00002418 <erase_op>:
}

#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

static int erase_op(void *context)
{
    2418:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    241c:	4604      	mov	r4, r0
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
    241e:	f01b fe4c 	bl	1e0ba <nrfx_nvmc_flash_page_size_get>
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
	u32_t ticks_begin = 0U;
	u32_t ticks_diff;
	u32_t i = 0U;

	if (e_ctx->enable_time_limit) {
    2422:	7b25      	ldrb	r5, [r4, #12]
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
    2424:	4682      	mov	sl, r0
	if (e_ctx->enable_time_limit) {
    2426:	b115      	cbz	r5, 242e <erase_op+0x16>
		ticks_begin = ticker_ticks_now_get();
    2428:	f01a fec9 	bl	1d1be <ticker_ticks_now_get>
    242c:	4605      	mov	r5, r0
		if (e_ctx->enable_time_limit) {
			ticks_diff =
				ticker_ticks_diff_get(ticker_ticks_now_get(),
						      ticks_begin);
			if (ticks_diff + ticks_diff/i >
			    HAL_TICKER_US_TO_TICKS(e_ctx->slot)) {
    242e:	f20f 0968 	addw	r9, pc, #104	; 0x68
    2432:	e9d9 8900 	ldrd	r8, r9, [r9]
    2436:	f8df b068 	ldr.w	fp, [pc, #104]	; 24a0 <erase_op+0x88>
	u32_t ticks_begin = 0U;
    243a:	2700      	movs	r7, #0
		(void)nrfx_nvmc_page_erase(e_ctx->flash_addr);
    243c:	6860      	ldr	r0, [r4, #4]
    243e:	f014 fedb 	bl	171f8 <nrfx_nvmc_page_erase>
		e_ctx->len -= pg_size;
    2442:	68a3      	ldr	r3, [r4, #8]
    2444:	eba3 030a 	sub.w	r3, r3, sl
    2448:	60a3      	str	r3, [r4, #8]
		e_ctx->flash_addr += pg_size;
    244a:	6863      	ldr	r3, [r4, #4]
    244c:	4453      	add	r3, sl
    244e:	6063      	str	r3, [r4, #4]
		if (e_ctx->enable_time_limit) {
    2450:	7b23      	ldrb	r3, [r4, #12]
		i++;
    2452:	3701      	adds	r7, #1
		if (e_ctx->enable_time_limit) {
    2454:	b94b      	cbnz	r3, 246a <erase_op+0x52>
				break;
			}
		}
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

	} while (e_ctx->len > 0);
    2456:	68a3      	ldr	r3, [r4, #8]
    2458:	2b00      	cmp	r3, #0
    245a:	d1ef      	bne.n	243c <erase_op+0x24>

	return (e_ctx->len > 0) ? FLASH_OP_ONGOING : FLASH_OP_DONE;
    245c:	68a0      	ldr	r0, [r4, #8]
    245e:	3000      	adds	r0, #0
    2460:	bf18      	it	ne
    2462:	2001      	movne	r0, #1
}
    2464:	4240      	negs	r0, r0
    2466:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				ticker_ticks_diff_get(ticker_ticks_now_get(),
    246a:	f01a fea8 	bl	1d1be <ticker_ticks_now_get>
    246e:	4629      	mov	r1, r5
    2470:	f01a fea7 	bl	1d1c2 <ticker_ticks_diff_get>
			if (ticks_diff + ticks_diff/i >
    2474:	fbb0 f6f7 	udiv	r6, r0, r7
    2478:	4406      	add	r6, r0
			    HAL_TICKER_US_TO_TICKS(e_ctx->slot)) {
    247a:	6960      	ldr	r0, [r4, #20]
    247c:	4642      	mov	r2, r8
    247e:	464b      	mov	r3, r9
    2480:	fba0 010b 	umull	r0, r1, r0, fp
    2484:	f7fd fe2c 	bl	e0 <__aeabi_uldivmod>
    2488:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			if (ticks_diff + ticks_diff/i >
    248c:	4286      	cmp	r6, r0
    248e:	d9e2      	bls.n	2456 <erase_op+0x3e>
    2490:	e7e4      	b.n	245c <erase_op+0x44>
    2492:	bf00      	nop
    2494:	f3af 8000 	nop.w
    2498:	1afd498d 	.word	0x1afd498d
    249c:	00000007 	.word	0x00000007
    24a0:	3b9aca00 	.word	0x3b9aca00
    24a4:	00000000 	.word	0x00000000

000024a8 <work_in_time_slice>:
{
    24a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    24ac:	b08f      	sub	sp, #60	; 0x3c
	struct flash_context *context = p_flash_op_desc->context;
    24ae:	f8d0 a004 	ldr.w	sl, [r0, #4]
			   HAL_TICKER_US_TO_TICKS(context->interval),
    24b2:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 258c <work_in_time_slice+0xe4>
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
    24b6:	f10d 0137 	add.w	r1, sp, #55	; 0x37
{
    24ba:	4680      	mov	r8, r0
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
    24bc:	f10d 0036 	add.w	r0, sp, #54	; 0x36
    24c0:	f01a ff1d 	bl	1d2fe <ll_timeslice_ticker_id_get>
	err = ticker_start(instance_index,
    24c4:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
    24c8:	930a      	str	r3, [sp, #40]	; 0x28
    24ca:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
    24ce:	930b      	str	r3, [sp, #44]	; 0x2c
    24d0:	f01a fe75 	bl	1d1be <ticker_ticks_now_get>
			   HAL_TICKER_US_TO_TICKS(context->interval),
    24d4:	f8da 4010 	ldr.w	r4, [sl, #16]
    24d8:	fba4 4509 	umull	r4, r5, r4, r9
    24dc:	a326      	add	r3, pc, #152	; (adr r3, 2578 <work_in_time_slice+0xd0>)
    24de:	e9d3 2300 	ldrd	r2, r3, [r3]
	err = ticker_start(instance_index,
    24e2:	2700      	movs	r7, #0
    24e4:	4683      	mov	fp, r0
			   HAL_TICKER_US_TO_TICKS(context->interval),
    24e6:	4629      	mov	r1, r5
    24e8:	4620      	mov	r0, r4
    24ea:	f7fd fdf9 	bl	e0 <__aeabi_uldivmod>
	err = ticker_start(instance_index,
    24ee:	e9cd 7707 	strd	r7, r7, [sp, #28]
    24f2:	4b23      	ldr	r3, [pc, #140]	; (2580 <work_in_time_slice+0xd8>)
    24f4:	9305      	str	r3, [sp, #20]
    24f6:	f8cd 8018 	str.w	r8, [sp, #24]
			   HAL_TICKER_US_TO_TICKS(context->interval),
    24fa:	4606      	mov	r6, r0
			   HAL_TICKER_US_TO_TICKS(context->slot),
    24fc:	f8da 0014 	ldr.w	r0, [sl, #20]
    2500:	a31d      	add	r3, pc, #116	; (adr r3, 2578 <work_in_time_slice+0xd0>)
    2502:	e9d3 2300 	ldrd	r2, r3, [r3]
    2506:	fba0 0109 	umull	r0, r1, r0, r9
    250a:	f7fd fde9 	bl	e0 <__aeabi_uldivmod>
			   HAL_TICKER_REMAINDER(context->interval),
    250e:	4b1d      	ldr	r3, [pc, #116]	; (2584 <work_in_time_slice+0xdc>)
    2510:	f026 467f 	bic.w	r6, r6, #4278190080	; 0xff000000
    2514:	fba6 9a03 	umull	r9, sl, r6, r3
	err = ticker_start(instance_index,
    2518:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			   HAL_TICKER_REMAINDER(context->interval),
    251c:	2307      	movs	r3, #7
	err = ticker_start(instance_index,
    251e:	e9cd 7003 	strd	r7, r0, [sp, #12]
			   HAL_TICKER_REMAINDER(context->interval),
    2522:	fb03 aa06 	mla	sl, r3, r6, sl
    2526:	ebb4 0009 	subs.w	r0, r4, r9
    252a:	eb65 010a 	sbc.w	r1, r5, sl
    252e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    2532:	2300      	movs	r3, #0
    2534:	f7fd fdd4 	bl	e0 <__aeabi_uldivmod>
	err = ticker_start(instance_index,
    2538:	465b      	mov	r3, fp
    253a:	e9cd 6001 	strd	r6, r0, [sp, #4]
    253e:	9700      	str	r7, [sp, #0]
    2540:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    2542:	980a      	ldr	r0, [sp, #40]	; 0x28
    2544:	2103      	movs	r1, #3
    2546:	f00b ff47 	bl	e3d8 <ticker_start>
	if (err != TICKER_STATUS_SUCCESS && err != TICKER_STATUS_BUSY) {
    254a:	f030 0302 	bics.w	r3, r0, #2
    254e:	d10a      	bne.n	2566 <work_in_time_slice+0xbe>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&sem, *(uintptr_t *)&timeout, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
    2550:	f645 11b3 	movw	r1, #22963	; 0x59b3
    2554:	480c      	ldr	r0, [pc, #48]	; (2588 <work_in_time_slice+0xe0>)
    2556:	f015 ffc1 	bl	184dc <z_impl_k_sem_take>
	} else if (k_sem_take(&sem_sync, K_MSEC(FLASH_TIMEOUT_MS)) != 0) {
    255a:	b938      	cbnz	r0, 256c <work_in_time_slice+0xc4>
		result = p_flash_op_desc->result;
    255c:	f8d8 0008 	ldr.w	r0, [r8, #8]
}
    2560:	b00f      	add	sp, #60	; 0x3c
    2562:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		result = -ECANCELED;
    2566:	f06f 0047 	mvn.w	r0, #71	; 0x47
    256a:	e7f9      	b.n	2560 <work_in_time_slice+0xb8>
		result = -ETIMEDOUT;
    256c:	f06f 003b 	mvn.w	r0, #59	; 0x3b
	return result;
    2570:	e7f6      	b.n	2560 <work_in_time_slice+0xb8>
    2572:	bf00      	nop
    2574:	f3af 8000 	nop.w
    2578:	1afd498d 	.word	0x1afd498d
    257c:	00000007 	.word	0x00000007
    2580:	00016a8d 	.word	0x00016a8d
    2584:	1afd498d 	.word	0x1afd498d
    2588:	200018a4 	.word	0x200018a4
    258c:	3b9aca00 	.word	0x3b9aca00

00002590 <write_op>:
	w_ctx->data_addr += shift;
	w_ctx->len -= shift;
}

static int write_op(void *context)
{
    2590:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
	u32_t ticks_begin = 0U;
	u32_t ticks_diff;
	u32_t i = 1U;

	if (w_ctx->enable_time_limit) {
    2594:	7b06      	ldrb	r6, [r0, #12]
{
    2596:	4604      	mov	r4, r0
	if (w_ctx->enable_time_limit) {
    2598:	b116      	cbz	r6, 25a0 <write_op+0x10>
		ticks_begin = ticker_ticks_now_get();
    259a:	f01a fe10 	bl	1d1be <ticker_ticks_now_get>
    259e:	4606      	mov	r6, r0
	}
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

	/* If not aligned, write unaligned beginning */
	if (!is_aligned_32(w_ctx->flash_addr)) {
    25a0:	6860      	ldr	r0, [r4, #4]
    25a2:	f010 0503 	ands.w	r5, r0, #3
    25a6:	d067      	beq.n	2678 <write_op+0xe8>
		count = sizeof(u32_t) - (w_ctx->flash_addr & 0x3);
    25a8:	68a3      	ldr	r3, [r4, #8]
		if (count > w_ctx->len) {
			count = w_ctx->len;
		}

		nrfx_nvmc_bytes_write(w_ctx->flash_addr,
    25aa:	6821      	ldr	r1, [r4, #0]
		count = sizeof(u32_t) - (w_ctx->flash_addr & 0x3);
    25ac:	f1c5 0504 	rsb	r5, r5, #4
		if (count > w_ctx->len) {
    25b0:	429d      	cmp	r5, r3
    25b2:	bf28      	it	cs
    25b4:	461d      	movcs	r5, r3
		nrfx_nvmc_bytes_write(w_ctx->flash_addr,
    25b6:	462a      	mov	r2, r5
    25b8:	f014 fe4c 	bl	17254 <nrfx_nvmc_bytes_write>
	w_ctx->flash_addr += shift;
    25bc:	6863      	ldr	r3, [r4, #4]
    25be:	442b      	add	r3, r5
    25c0:	6063      	str	r3, [r4, #4]
	w_ctx->data_addr += shift;
    25c2:	6823      	ldr	r3, [r4, #0]
    25c4:	442b      	add	r3, r5
    25c6:	6023      	str	r3, [r4, #0]
	w_ctx->len -= shift;
    25c8:	68a3      	ldr	r3, [r4, #8]
    25ca:	1b5d      	subs	r5, r3, r5
				      count);

		shift_write_context(count, w_ctx);

#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
		if (w_ctx->enable_time_limit) {
    25cc:	7b23      	ldrb	r3, [r4, #12]
	w_ctx->len -= shift;
    25ce:	60a5      	str	r5, [r4, #8]
		if (w_ctx->enable_time_limit) {
    25d0:	2b00      	cmp	r3, #0
    25d2:	d051      	beq.n	2678 <write_op+0xe8>
			ticks_diff =
				ticker_ticks_diff_get(ticker_ticks_now_get(),
    25d4:	f01a fdf3 	bl	1d1be <ticker_ticks_now_get>
    25d8:	4631      	mov	r1, r6
    25da:	f01a fdf2 	bl	1d1c2 <ticker_ticks_diff_get>
						      ticks_begin);
			if (ticks_diff * 2U >
			    HAL_TICKER_US_TO_TICKS(w_ctx->slot)) {
    25de:	492c      	ldr	r1, [pc, #176]	; (2690 <write_op+0x100>)
			if (ticks_diff * 2U >
    25e0:	0045      	lsls	r5, r0, #1
			    HAL_TICKER_US_TO_TICKS(w_ctx->slot)) {
    25e2:	6960      	ldr	r0, [r4, #20]
    25e4:	a328      	add	r3, pc, #160	; (adr r3, 2688 <write_op+0xf8>)
    25e6:	e9d3 2300 	ldrd	r2, r3, [r3]
    25ea:	fba0 0101 	umull	r0, r1, r0, r1
    25ee:	f7fd fd77 	bl	e0 <__aeabi_uldivmod>
    25f2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			if (ticks_diff * 2U >
    25f6:	4285      	cmp	r5, r0
    25f8:	d93e      	bls.n	2678 <write_op+0xe8>
				nvmc_wait_ready();
    25fa:	f014 fa37 	bl	16a6c <nvmc_wait_ready>
				return FLASH_OP_ONGOING;
    25fe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}

	nvmc_wait_ready();

	return FLASH_OP_DONE;
}
    2602:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				     UNALIGNED_GET((u32_t *)w_ctx->data_addr));
    2606:	6823      	ldr	r3, [r4, #0]
		nrfx_nvmc_word_write(w_ctx->flash_addr,
    2608:	6860      	ldr	r0, [r4, #4]
    260a:	6819      	ldr	r1, [r3, #0]
    260c:	f014 fe14 	bl	17238 <nrfx_nvmc_word_write>
	w_ctx->flash_addr += shift;
    2610:	6863      	ldr	r3, [r4, #4]
    2612:	3304      	adds	r3, #4
    2614:	6063      	str	r3, [r4, #4]
	w_ctx->data_addr += shift;
    2616:	6823      	ldr	r3, [r4, #0]
    2618:	3304      	adds	r3, #4
    261a:	6023      	str	r3, [r4, #0]
	w_ctx->len -= shift;
    261c:	68a3      	ldr	r3, [r4, #8]
    261e:	3b04      	subs	r3, #4
    2620:	60a3      	str	r3, [r4, #8]
		if (w_ctx->enable_time_limit) {
    2622:	7b23      	ldrb	r3, [r4, #12]
		i++;
    2624:	3501      	adds	r5, #1
		if (w_ctx->enable_time_limit) {
    2626:	b193      	cbz	r3, 264e <write_op+0xbe>
				ticker_ticks_diff_get(ticker_ticks_now_get(),
    2628:	f01a fdc9 	bl	1d1be <ticker_ticks_now_get>
    262c:	4631      	mov	r1, r6
    262e:	f01a fdc8 	bl	1d1c2 <ticker_ticks_diff_get>
			if (ticks_diff + ticks_diff/i >
    2632:	fbb0 f7f5 	udiv	r7, r0, r5
    2636:	4407      	add	r7, r0
			    HAL_TICKER_US_TO_TICKS(w_ctx->slot)) {
    2638:	6960      	ldr	r0, [r4, #20]
    263a:	4642      	mov	r2, r8
    263c:	464b      	mov	r3, r9
    263e:	fba0 010a 	umull	r0, r1, r0, sl
    2642:	f7fd fd4d 	bl	e0 <__aeabi_uldivmod>
    2646:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			if (ticks_diff + ticks_diff/i >
    264a:	4287      	cmp	r7, r0
    264c:	d8d5      	bhi.n	25fa <write_op+0x6a>
	while (w_ctx->len >= sizeof(u32_t)) {
    264e:	68a2      	ldr	r2, [r4, #8]
    2650:	2a03      	cmp	r2, #3
    2652:	d8d8      	bhi.n	2606 <write_op+0x76>
	if (w_ctx->len) {
    2654:	b162      	cbz	r2, 2670 <write_op+0xe0>
		nrfx_nvmc_bytes_write(w_ctx->flash_addr,
    2656:	e9d4 1000 	ldrd	r1, r0, [r4]
    265a:	f014 fdfb 	bl	17254 <nrfx_nvmc_bytes_write>
	w_ctx->flash_addr += shift;
    265e:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
	w_ctx->data_addr += shift;
    2662:	6823      	ldr	r3, [r4, #0]
    2664:	440b      	add	r3, r1
	w_ctx->flash_addr += shift;
    2666:	440a      	add	r2, r1
	w_ctx->data_addr += shift;
    2668:	6023      	str	r3, [r4, #0]
	w_ctx->len -= shift;
    266a:	2300      	movs	r3, #0
	w_ctx->flash_addr += shift;
    266c:	6062      	str	r2, [r4, #4]
	w_ctx->len -= shift;
    266e:	60a3      	str	r3, [r4, #8]
	nvmc_wait_ready();
    2670:	f014 f9fc 	bl	16a6c <nvmc_wait_ready>
	return FLASH_OP_DONE;
    2674:	2000      	movs	r0, #0
    2676:	e7c4      	b.n	2602 <write_op+0x72>
	u32_t ticks_begin = 0U;
    2678:	2501      	movs	r5, #1
			    HAL_TICKER_US_TO_TICKS(w_ctx->slot)) {
    267a:	f8df a014 	ldr.w	sl, [pc, #20]	; 2690 <write_op+0x100>
    267e:	f20f 0908 	addw	r9, pc, #8
    2682:	e9d9 8900 	ldrd	r8, r9, [r9]
    2686:	e7e2      	b.n	264e <write_op+0xbe>
    2688:	1afd498d 	.word	0x1afd498d
    268c:	00000007 	.word	0x00000007
    2690:	3b9aca00 	.word	0x3b9aca00

00002694 <main>:
}



void main(void)
{
    2694:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	cts_datetime_t internal_datetime;
	int err;

	//bt_ctlr_set_public_addr(addr);
	err = bt_enable(NULL);
    2696:	2000      	movs	r0, #0
    2698:	f004 fbf8 	bl	6e8c <bt_enable>
	if (err) {
    269c:	4604      	mov	r4, r0
    269e:	b128      	cbz	r0, 26ac <main+0x18>
		printk("Bluetooth init failed (err %d)\n", err);
    26a0:	4601      	mov	r1, r0
    26a2:	4818      	ldr	r0, [pc, #96]	; (2704 <main+0x70>)
    26a4:	f016 fe66 	bl	19374 <printk>
	while (1) {
		k_sleep(MSEC_PER_SEC);
		cts_sync_loop();

	}
}
    26a8:	b004      	add	sp, #16
    26aa:	bd10      	pop	{r4, pc}
	printk("Bluetooth initialized\n");
    26ac:	4816      	ldr	r0, [pc, #88]	; (2708 <main+0x74>)
    26ae:	f016 fe61 	bl	19374 <printk>
		settings_load();
    26b2:	f018 f9d9 	bl	1aa68 <settings_load>
	printk("bt_le_adv_start\n");
    26b6:	4815      	ldr	r0, [pc, #84]	; (270c <main+0x78>)
    26b8:	f016 fe5c 	bl	19374 <printk>
	err = bt_le_adv_start(BT_LE_ADV_CONN_NAME, ad, ARRAY_SIZE(ad), NULL, 0);
    26bc:	2309      	movs	r3, #9
    26be:	f8ad 4008 	strh.w	r4, [sp, #8]
    26c2:	f88d 3009 	strb.w	r3, [sp, #9]
    26c6:	23a0      	movs	r3, #160	; 0xa0
    26c8:	f8ad 300a 	strh.w	r3, [sp, #10]
    26cc:	23f0      	movs	r3, #240	; 0xf0
    26ce:	f8ad 300c 	strh.w	r3, [sp, #12]
    26d2:	490f      	ldr	r1, [pc, #60]	; (2710 <main+0x7c>)
    26d4:	9400      	str	r4, [sp, #0]
    26d6:	4623      	mov	r3, r4
    26d8:	2203      	movs	r2, #3
    26da:	a802      	add	r0, sp, #8
    26dc:	f018 feb8 	bl	1b450 <bt_le_adv_start>
	if (err) {
    26e0:	4601      	mov	r1, r0
    26e2:	b158      	cbz	r0, 26fc <main+0x68>
		printk("Advertising failed to start (err %d)\n", err);
    26e4:	480b      	ldr	r0, [pc, #44]	; (2714 <main+0x80>)
    26e6:	f016 fe45 	bl	19374 <printk>
	cts_sync_init(); 
    26ea:	f000 f8c5 	bl	2878 <cts_sync_init>
	return z_impl_k_sleep(ms);
    26ee:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    26f2:	f015 fe99 	bl	18428 <z_impl_k_sleep>
		cts_sync_loop();
    26f6:	f000 f8c5 	bl	2884 <cts_sync_loop>
    26fa:	e7f8      	b.n	26ee <main+0x5a>
	printk("Advertising successfully started\n");
    26fc:	4806      	ldr	r0, [pc, #24]	; (2718 <main+0x84>)
    26fe:	f016 fe39 	bl	19374 <printk>
    2702:	e7f2      	b.n	26ea <main+0x56>
    2704:	0001f7ac 	.word	0x0001f7ac
    2708:	0001f7cc 	.word	0x0001f7cc
    270c:	0001f7e3 	.word	0x0001f7e3
    2710:	0001eefc 	.word	0x0001eefc
    2714:	0001f7f4 	.word	0x0001f7f4
    2718:	0001f81a 	.word	0x0001f81a

0000271c <cts_sync_service_discovered>:
    return BT_GATT_ITER_CONTINUE;
}

u8_t cts_sync_service_discovered(struct bt_conn* conn, const struct bt_gatt_attr* attr,
        struct bt_gatt_discover_params* params)
{
    271c:	b570      	push	{r4, r5, r6, lr}
    271e:	4606      	mov	r6, r0
    if (!attr) {
    2720:	460d      	mov	r5, r1
    2722:	b921      	cbnz	r1, 272e <cts_sync_service_discovered+0x12>
        printk("CTS Service Discovery completed");
    2724:	4811      	ldr	r0, [pc, #68]	; (276c <cts_sync_service_discovered+0x50>)
    read_params.by_uuid.uuid = &uuid;
    read_params.by_uuid.start_handle = attr->handle;
    read_params.by_uuid.end_handle = 0xffff;
    offset = 0;
    if (bt_gatt_read(conn, &read_params) < 0) {
        printk("Could not initiate read of CCC data.");
    2726:	f016 fe25 	bl	19374 <printk>
    }

    return BT_GATT_ITER_STOP;
}
    272a:	2000      	movs	r0, #0
    272c:	bd70      	pop	{r4, r5, r6, pc}
    memset(&read_params, 0, sizeof(read_params));
    272e:	4c10      	ldr	r4, [pc, #64]	; (2770 <cts_sync_service_discovered+0x54>)
    printk("Discovered attribute, handle: %u\n", attr->handle);
    2730:	8a09      	ldrh	r1, [r1, #16]
    2732:	4810      	ldr	r0, [pc, #64]	; (2774 <cts_sync_service_discovered+0x58>)
    2734:	f016 fe1e 	bl	19374 <printk>
    memset(&read_params, 0, sizeof(read_params));
    2738:	2210      	movs	r2, #16
    273a:	2100      	movs	r1, #0
    273c:	4620      	mov	r0, r4
    273e:	f018 fc86 	bl	1b04e <memset>
    read_params.func = cts_sync_read;
    2742:	4b0d      	ldr	r3, [pc, #52]	; (2778 <cts_sync_service_discovered+0x5c>)
    2744:	6023      	str	r3, [r4, #0]
    read_params.by_uuid.uuid = &uuid;
    2746:	4b0d      	ldr	r3, [pc, #52]	; (277c <cts_sync_service_discovered+0x60>)
    2748:	60e3      	str	r3, [r4, #12]
    read_params.by_uuid.start_handle = attr->handle;
    274a:	8a2b      	ldrh	r3, [r5, #16]
    274c:	8123      	strh	r3, [r4, #8]
    read_params.by_uuid.end_handle = 0xffff;
    274e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    2752:	8163      	strh	r3, [r4, #10]
    offset = 0;
    2754:	4b0a      	ldr	r3, [pc, #40]	; (2780 <cts_sync_service_discovered+0x64>)
    2756:	2200      	movs	r2, #0
    if (bt_gatt_read(conn, &read_params) < 0) {
    2758:	4621      	mov	r1, r4
    275a:	4630      	mov	r0, r6
    offset = 0;
    275c:	601a      	str	r2, [r3, #0]
    if (bt_gatt_read(conn, &read_params) < 0) {
    275e:	f008 fef9 	bl	b554 <bt_gatt_read>
    2762:	2800      	cmp	r0, #0
    2764:	dae1      	bge.n	272a <cts_sync_service_discovered+0xe>
        printk("Could not initiate read of CCC data.");
    2766:	4807      	ldr	r0, [pc, #28]	; (2784 <cts_sync_service_discovered+0x68>)
    2768:	e7dd      	b.n	2726 <cts_sync_service_discovered+0xa>
    276a:	bf00      	nop
    276c:	0001f8df 	.word	0x0001f8df
    2770:	20000030 	.word	0x20000030
    2774:	0001f8ff 	.word	0x0001f8ff
    2778:	000027e1 	.word	0x000027e1
    277c:	20001aea 	.word	0x20001aea
    2780:	2000002c 	.word	0x2000002c
    2784:	0001f921 	.word	0x0001f921

00002788 <cts_sync_processor>:
 //#define BT_UUID_CTS                       BT_UUID_DECLARE_16(0x1805)
 //#define BT_UUID_CTS_CURRENT_TIME          BT_UUID_DECLARE_16(0x2a2b)


static void cts_sync_processor(struct bt_conn *conn, void *data)
{
    2788:	b537      	push	{r0, r1, r2, r4, r5, lr}
    memcpy(&uuid, BT_UUID_CTS_CURRENT_TIME, sizeof(uuid));
    278a:	4c11      	ldr	r4, [pc, #68]	; (27d0 <cts_sync_processor+0x48>)
    278c:	2300      	movs	r3, #0
    278e:	2204      	movs	r2, #4
{
    2790:	4605      	mov	r5, r0
    memcpy(&uuid, BT_UUID_CTS_CURRENT_TIME, sizeof(uuid));
    2792:	f88d 3004 	strb.w	r3, [sp, #4]
    2796:	eb0d 0102 	add.w	r1, sp, r2
    279a:	f642 232b 	movw	r3, #10795	; 0x2a2b
    279e:	4620      	mov	r0, r4
    27a0:	f8ad 3006 	strh.w	r3, [sp, #6]
    27a4:	f018 fc29 	bl	1affa <memcpy>
    cts_discovery_params.func = cts_sync_service_discovered;
    27a8:	490a      	ldr	r1, [pc, #40]	; (27d4 <cts_sync_processor+0x4c>)
    27aa:	4b0b      	ldr	r3, [pc, #44]	; (27d8 <cts_sync_processor+0x50>)
    27ac:	604b      	str	r3, [r1, #4]
    cts_discovery_params.start_handle = 0x0001;
    27ae:	2301      	movs	r3, #1
    27b0:	810b      	strh	r3, [r1, #8]
    cts_discovery_params.end_handle = 0xFFFF;
    27b2:	f64f 73ff 	movw	r3, #65535	; 0xffff
    27b6:	81cb      	strh	r3, [r1, #14]
    cts_discovery_params.type = BT_GATT_DISCOVER_CHARACTERISTIC;
    cts_discovery_params.uuid = &uuid;

    if (bt_gatt_discover(conn, &cts_discovery_params) != 0) {
    27b8:	4628      	mov	r0, r5
    cts_discovery_params.type = BT_GATT_DISCOVER_CHARACTERISTIC;
    27ba:	2303      	movs	r3, #3
    27bc:	740b      	strb	r3, [r1, #16]
    cts_discovery_params.uuid = &uuid;
    27be:	600c      	str	r4, [r1, #0]
    if (bt_gatt_discover(conn, &cts_discovery_params) != 0) {
    27c0:	f008 fb12 	bl	ade8 <bt_gatt_discover>
    27c4:	b110      	cbz	r0, 27cc <cts_sync_processor+0x44>
        printk("CTS Sync > GATT discovery FAILED.\n");
    27c6:	4805      	ldr	r0, [pc, #20]	; (27dc <cts_sync_processor+0x54>)
    27c8:	f016 fdd4 	bl	19374 <printk>
    }
}
    27cc:	b003      	add	sp, #12
    27ce:	bd30      	pop	{r4, r5, pc}
    27d0:	20001aea 	.word	0x20001aea
    27d4:	20000018 	.word	0x20000018
    27d8:	0000271d 	.word	0x0000271d
    27dc:	0001f83c 	.word	0x0001f83c

000027e0 <cts_sync_read>:
{
    27e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    27e2:	b087      	sub	sp, #28
    printk("Reading CCC data: err %d, %d bytes, offset %d.", err, length, offset);
    27e4:	4d1e      	ldr	r5, [pc, #120]	; (2860 <cts_sync_read+0x80>)
{
    27e6:	f8bd 6030 	ldrh.w	r6, [sp, #48]	; 0x30
    printk("Reading CCC data: err %d, %d bytes, offset %d.", err, length, offset);
    27ea:	481e      	ldr	r0, [pc, #120]	; (2864 <cts_sync_read+0x84>)
    27ec:	4c1e      	ldr	r4, [pc, #120]	; (2868 <cts_sync_read+0x88>)
{
    27ee:	461f      	mov	r7, r3
    printk("Reading CCC data: err %d, %d bytes, offset %d.", err, length, offset);
    27f0:	4632      	mov	r2, r6
    27f2:	682b      	ldr	r3, [r5, #0]
    27f4:	f016 fdbe 	bl	19374 <printk>
    if (!data || length <= 0) {
    27f8:	b107      	cbz	r7, 27fc <cts_sync_read+0x1c>
    27fa:	bb1e      	cbnz	r6, 2844 <cts_sync_read+0x64>
    printk("CTS sync to clock started.\n Y%04d D%03d T%2d:%2d:%2d",
    27fc:	79a3      	ldrb	r3, [r4, #6]
    27fe:	9301      	str	r3, [sp, #4]
    2800:	7963      	ldrb	r3, [r4, #5]
    2802:	9300      	str	r3, [sp, #0]
    2804:	78e2      	ldrb	r2, [r4, #3]
    2806:	7923      	ldrb	r3, [r4, #4]
    2808:	8821      	ldrh	r1, [r4, #0]
    280a:	4818      	ldr	r0, [pc, #96]	; (286c <cts_sync_read+0x8c>)
    280c:	f016 fdb2 	bl	19374 <printk>
    memset(&clock_datetime, 0, sizeof(cts_datetime_t));
    2810:	220a      	movs	r2, #10
    2812:	2100      	movs	r1, #0
    2814:	a803      	add	r0, sp, #12
    2816:	f018 fc1a 	bl	1b04e <memset>
    clock_datetime.year = cts_datetime->year;
    281a:	8822      	ldrh	r2, [r4, #0]
    281c:	f8ad 200c 	strh.w	r2, [sp, #12]
    clock_datetime.month = cts_datetime->month;
    2820:	8862      	ldrh	r2, [r4, #2]
    clock_datetime.seconds = cts_datetime->seconds;
    2822:	79a3      	ldrb	r3, [r4, #6]
    clock_datetime.month = cts_datetime->month;
    2824:	f8ad 200e 	strh.w	r2, [sp, #14]
    printk("CTS sync to clock complete.");
    2828:	4811      	ldr	r0, [pc, #68]	; (2870 <cts_sync_read+0x90>)
    clock_datetime.hours = cts_datetime->hours;
    282a:	88a2      	ldrh	r2, [r4, #4]
    282c:	f8ad 2010 	strh.w	r2, [sp, #16]
    clock_datetime.seconds = cts_datetime->seconds;
    2830:	f88d 3012 	strb.w	r3, [sp, #18]
    printk("CTS sync to clock complete.");
    2834:	f016 fd9e 	bl	19374 <printk>
    time_sync_timeout = TIME_SYNC_WAIT;
    2838:	4b0e      	ldr	r3, [pc, #56]	; (2874 <cts_sync_read+0x94>)
    283a:	223c      	movs	r2, #60	; 0x3c
    283c:	601a      	str	r2, [r3, #0]
        return BT_GATT_ITER_STOP;
    283e:	2000      	movs	r0, #0
}
    2840:	b007      	add	sp, #28
    2842:	bdf0      	pop	{r4, r5, r6, r7, pc}
    memcpy(&datetime_buf + offset, data, length);
    2844:	682b      	ldr	r3, [r5, #0]
    2846:	200a      	movs	r0, #10
    2848:	4632      	mov	r2, r6
    284a:	fb00 4003 	mla	r0, r0, r3, r4
    284e:	4639      	mov	r1, r7
    2850:	f018 fbd3 	bl	1affa <memcpy>
    offset += length;
    2854:	682b      	ldr	r3, [r5, #0]
    2856:	441e      	add	r6, r3
    2858:	602e      	str	r6, [r5, #0]
    return BT_GATT_ITER_CONTINUE;
    285a:	2001      	movs	r0, #1
    285c:	e7f0      	b.n	2840 <cts_sync_read+0x60>
    285e:	bf00      	nop
    2860:	2000002c 	.word	0x2000002c
    2864:	0001f85f 	.word	0x0001f85f
    2868:	20001ae0 	.word	0x20001ae0
    286c:	0001f88e 	.word	0x0001f88e
    2870:	0001f8c3 	.word	0x0001f8c3
    2874:	200055b4 	.word	0x200055b4

00002878 <cts_sync_init>:
	.disconnected = disconnected,
};

void cts_sync_init()
{
    bt_conn_cb_register(&conn_callbacks);
    2878:	4801      	ldr	r0, [pc, #4]	; (2880 <cts_sync_init+0x8>)
    287a:	f005 baef 	b.w	7e5c <bt_conn_cb_register>
    287e:	bf00      	nop
    2880:	20005598 	.word	0x20005598

00002884 <cts_sync_loop>:
 //   cts_register_write_cb(cts_write_cb);
 //  sync_local_cts_to_clock();
}

void cts_sync_loop()
{
    2884:	b510      	push	{r4, lr}
    if (time_sync_timeout > 0) {
    2886:	4c07      	ldr	r4, [pc, #28]	; (28a4 <cts_sync_loop+0x20>)
    2888:	6823      	ldr	r3, [r4, #0]
    288a:	2b00      	cmp	r3, #0
    288c:	dd02      	ble.n	2894 <cts_sync_loop+0x10>
        time_sync_timeout--;
    288e:	3b01      	subs	r3, #1
    } else {
        bt_conn_foreach(BT_CONN_TYPE_ALL, cts_sync_processor, NULL);
        time_sync_timeout = TIME_SYNC_WAIT;
    2890:	6023      	str	r3, [r4, #0]
    }
}
    2892:	bd10      	pop	{r4, pc}
        bt_conn_foreach(BT_CONN_TYPE_ALL, cts_sync_processor, NULL);
    2894:	2200      	movs	r2, #0
    2896:	4904      	ldr	r1, [pc, #16]	; (28a8 <cts_sync_loop+0x24>)
    2898:	2007      	movs	r0, #7
    289a:	f005 fdaf 	bl	83fc <bt_conn_foreach>
        time_sync_timeout = TIME_SYNC_WAIT;
    289e:	233c      	movs	r3, #60	; 0x3c
    28a0:	e7f6      	b.n	2890 <cts_sync_loop+0xc>
    28a2:	bf00      	nop
    28a4:	200055b4 	.word	0x200055b4
    28a8:	00002789 	.word	0x00002789

000028ac <crc8_ccitt>:
	0x00, 0x07, 0x0e, 0x09, 0x1c, 0x1b, 0x12, 0x15,
	0x38, 0x3f, 0x36, 0x31, 0x24, 0x23, 0x2a, 0x2d
};

u8_t crc8_ccitt(u8_t val, const void *buf, size_t cnt)
{
    28ac:	b510      	push	{r4, lr}
	int i;
	const u8_t *p = buf;

	for (i = 0; i < cnt; i++) {
		val ^= p[i];
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
    28ae:	4c09      	ldr	r4, [pc, #36]	; (28d4 <crc8_ccitt+0x28>)
    28b0:	440a      	add	r2, r1
	for (i = 0; i < cnt; i++) {
    28b2:	4291      	cmp	r1, r2
    28b4:	d100      	bne.n	28b8 <crc8_ccitt+0xc>
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
	}
	return val;
}
    28b6:	bd10      	pop	{r4, pc}
		val ^= p[i];
    28b8:	f811 3b01 	ldrb.w	r3, [r1], #1
    28bc:	4043      	eors	r3, r0
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
    28be:	0918      	lsrs	r0, r3, #4
    28c0:	5c20      	ldrb	r0, [r4, r0]
    28c2:	ea80 1003 	eor.w	r0, r0, r3, lsl #4
    28c6:	b2c3      	uxtb	r3, r0
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
    28c8:	0918      	lsrs	r0, r3, #4
    28ca:	5c20      	ldrb	r0, [r4, r0]
    28cc:	ea80 1003 	eor.w	r0, r0, r3, lsl #4
    28d0:	b2c0      	uxtb	r0, r0
    28d2:	e7ee      	b.n	28b2 <crc8_ccitt+0x6>
    28d4:	0001f946 	.word	0x0001f946

000028d8 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
    28d8:	680b      	ldr	r3, [r1, #0]
    28da:	3301      	adds	r3, #1
    28dc:	600b      	str	r3, [r1, #0]
	return _char_out(c);
    28de:	4b01      	ldr	r3, [pc, #4]	; (28e4 <char_out+0xc>)
    28e0:	681b      	ldr	r3, [r3, #0]
    28e2:	4718      	bx	r3
    28e4:	200055b8 	.word	0x200055b8

000028e8 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
    28e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    28ec:	b085      	sub	sp, #20
    28ee:	469b      	mov	fp, r3
    28f0:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    28f2:	f8df 9088 	ldr.w	r9, [pc, #136]	; 297c <_printk_dec_ulong+0x94>
    28f6:	2c01      	cmp	r4, #1
    28f8:	bfb8      	it	lt
    28fa:	2401      	movlt	r4, #1
    28fc:	2b01      	cmp	r3, #1
    28fe:	bf0c      	ite	eq
    2900:	2330      	moveq	r3, #48	; 0x30
    2902:	2320      	movne	r3, #32
    2904:	4616      	mov	r6, r2
    2906:	4682      	mov	sl, r0
    2908:	4688      	mov	r8, r1
    290a:	9302      	str	r3, [sp, #8]
    290c:	2501      	movs	r5, #1
    290e:	270a      	movs	r7, #10
    2910:	2200      	movs	r2, #0
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
    2912:	fbb6 f3f9 	udiv	r3, r6, r9
    2916:	9301      	str	r3, [sp, #4]
    2918:	b90a      	cbnz	r2, 291e <_printk_dec_ulong+0x36>
    291a:	45b1      	cmp	r9, r6
    291c:	d81d      	bhi.n	295a <_printk_dec_ulong+0x72>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
    291e:	9b01      	ldr	r3, [sp, #4]
    2920:	4641      	mov	r1, r8
    2922:	f103 0030 	add.w	r0, r3, #48	; 0x30
    2926:	47d0      	blx	sl
			digits++;
    2928:	3501      	adds	r5, #1
			found_largest_digit = 1;
    292a:	2201      	movs	r2, #1
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= pos;
    292c:	9b01      	ldr	r3, [sp, #4]
		remaining--;
    292e:	3f01      	subs	r7, #1
	while (pos >= 10) {
    2930:	2f01      	cmp	r7, #1
		remainder %= pos;
    2932:	fb09 6613 	mls	r6, r9, r3, r6
		pos /= 10;
    2936:	f04f 030a 	mov.w	r3, #10
    293a:	fbb9 f9f3 	udiv	r9, r9, r3
	while (pos >= 10) {
    293e:	d1e8      	bne.n	2912 <_printk_dec_ulong+0x2a>
	}
	out((int)(remainder + 48), ctx);
    2940:	4641      	mov	r1, r8
    2942:	f106 0030 	add.w	r0, r6, #48	; 0x30
    2946:	47d0      	blx	sl

	if (padding == PAD_SPACE_AFTER) {
    2948:	f1bb 0f03 	cmp.w	fp, #3
    294c:	d102      	bne.n	2954 <_printk_dec_ulong+0x6c>
		remaining = min_width - digits;
    294e:	1b64      	subs	r4, r4, r5
		while (remaining-- > 0) {
    2950:	2c00      	cmp	r4, #0
    2952:	dc0e      	bgt.n	2972 <_printk_dec_ulong+0x8a>
			out(' ', ctx);
		}
	}
}
    2954:	b005      	add	sp, #20
    2956:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
    295a:	42bc      	cmp	r4, r7
    295c:	dbe6      	blt.n	292c <_printk_dec_ulong+0x44>
				&& padding < PAD_SPACE_AFTER) {
    295e:	f1bb 0f02 	cmp.w	fp, #2
    2962:	d8e3      	bhi.n	292c <_printk_dec_ulong+0x44>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    2964:	4641      	mov	r1, r8
    2966:	9802      	ldr	r0, [sp, #8]
    2968:	9203      	str	r2, [sp, #12]
			digits++;
    296a:	3501      	adds	r5, #1
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    296c:	47d0      	blx	sl
			digits++;
    296e:	9a03      	ldr	r2, [sp, #12]
    2970:	e7dc      	b.n	292c <_printk_dec_ulong+0x44>
			out(' ', ctx);
    2972:	4641      	mov	r1, r8
    2974:	2020      	movs	r0, #32
    2976:	47d0      	blx	sl
    2978:	3c01      	subs	r4, #1
    297a:	e7e9      	b.n	2950 <_printk_dec_ulong+0x68>
    297c:	3b9aca00 	.word	0x3b9aca00

00002980 <vprintk>:
{
    2980:	b507      	push	{r0, r1, r2, lr}
	struct out_context ctx = { 0 };
    2982:	2300      	movs	r3, #0
    2984:	9301      	str	r3, [sp, #4]
	z_vprintk(char_out, &ctx, fmt, ap);
    2986:	4602      	mov	r2, r0
    2988:	460b      	mov	r3, r1
    298a:	4803      	ldr	r0, [pc, #12]	; (2998 <vprintk+0x18>)
    298c:	a901      	add	r1, sp, #4
    298e:	f016 fb81 	bl	19094 <z_vprintk>
}
    2992:	b003      	add	sp, #12
    2994:	f85d fb04 	ldr.w	pc, [sp], #4
    2998:	000028d9 	.word	0x000028d9

0000299c <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
    299c:	b530      	push	{r4, r5, lr}
    299e:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
    29a0:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
    29a4:	4604      	mov	r4, r0
	struct str_context ctx = { str, size, 0 };
    29a6:	2500      	movs	r5, #0

	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    29a8:	a901      	add	r1, sp, #4
    29aa:	4805      	ldr	r0, [pc, #20]	; (29c0 <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
    29ac:	9503      	str	r5, [sp, #12]
	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    29ae:	f016 fb71 	bl	19094 <z_vprintk>

	if (ctx.count < ctx.max) {
    29b2:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
    29b6:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
    29b8:	bfb8      	it	lt
    29ba:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
    29bc:	b005      	add	sp, #20
    29be:	bd30      	pop	{r4, r5, pc}
    29c0:	0001906f 	.word	0x0001906f

000029c4 <uECC_get_rng>:
}

uECC_RNG_Function uECC_get_rng(void)
{
	return g_rng_function;
}
    29c4:	4b01      	ldr	r3, [pc, #4]	; (29cc <uECC_get_rng+0x8>)
    29c6:	6818      	ldr	r0, [r3, #0]
    29c8:	4770      	bx	lr
    29ca:	bf00      	nop
    29cc:	200055bc 	.word	0x200055bc

000029d0 <vli_mmod_fast_secp256r1>:
{
	return &curve_secp256r1;
}

void vli_mmod_fast_secp256r1(unsigned int *result, unsigned int*product)
{
    29d0:	b5f0      	push	{r4, r5, r6, r7, lr}
	unsigned int tmp[NUM_ECC_WORDS];
	int carry;

	/* t */
	uECC_vli_set(result, product, NUM_ECC_WORDS);
    29d2:	2208      	movs	r2, #8
{
    29d4:	b089      	sub	sp, #36	; 0x24
    29d6:	460c      	mov	r4, r1
    29d8:	4606      	mov	r6, r0
	uECC_vli_set(result, product, NUM_ECC_WORDS);
    29da:	f016 fece 	bl	1977a <uECC_vli_set>

	/* s1 */
	tmp[0] = tmp[1] = tmp[2] = 0;
	tmp[3] = product[11];
    29de:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    29e0:	9303      	str	r3, [sp, #12]
	tmp[4] = product[12];
    29e2:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    29e4:	9304      	str	r3, [sp, #16]
	tmp[5] = product[13];
    29e6:	6b4b      	ldr	r3, [r1, #52]	; 0x34
    29e8:	9305      	str	r3, [sp, #20]
	tmp[6] = product[14];
    29ea:	6b8b      	ldr	r3, [r1, #56]	; 0x38
    29ec:	9306      	str	r3, [sp, #24]
	tmp[7] = product[15];
    29ee:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
    29f0:	9307      	str	r3, [sp, #28]
	tmp[0] = tmp[1] = tmp[2] = 0;
    29f2:	2700      	movs	r7, #0
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    29f4:	2308      	movs	r3, #8
    29f6:	466a      	mov	r2, sp
    29f8:	4669      	mov	r1, sp
    29fa:	4668      	mov	r0, sp
	tmp[0] = tmp[1] = tmp[2] = 0;
    29fc:	e9cd 7701 	strd	r7, r7, [sp, #4]
    2a00:	9700      	str	r7, [sp, #0]
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    2a02:	f016 fdbf 	bl	19584 <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    2a06:	2308      	movs	r3, #8
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    2a08:	4605      	mov	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    2a0a:	466a      	mov	r2, sp
    2a0c:	4631      	mov	r1, r6
    2a0e:	4630      	mov	r0, r6
    2a10:	f016 fdb8 	bl	19584 <uECC_vli_add>

	/* s2 */
	tmp[3] = product[12];
    2a14:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2a16:	9303      	str	r3, [sp, #12]
	tmp[4] = product[13];
    2a18:	6b63      	ldr	r3, [r4, #52]	; 0x34
    2a1a:	9304      	str	r3, [sp, #16]
	tmp[5] = product[14];
    2a1c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    2a1e:	9305      	str	r3, [sp, #20]
	tmp[6] = product[15];
    2a20:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    2a22:	4405      	add	r5, r0
	tmp[7] = 0;
    2a24:	e9cd 3706 	strd	r3, r7, [sp, #24]
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    2a28:	466a      	mov	r2, sp
    2a2a:	2308      	movs	r3, #8
    2a2c:	4669      	mov	r1, sp
    2a2e:	4668      	mov	r0, sp
    2a30:	f016 fda8 	bl	19584 <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    2a34:	4631      	mov	r1, r6
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    2a36:	4405      	add	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    2a38:	2308      	movs	r3, #8
    2a3a:	466a      	mov	r2, sp
    2a3c:	4630      	mov	r0, r6
    2a3e:	f016 fda1 	bl	19584 <uECC_vli_add>

	/* s3 */
	tmp[0] = product[8];
    2a42:	6a23      	ldr	r3, [r4, #32]
    2a44:	9300      	str	r3, [sp, #0]
	tmp[1] = product[9];
    2a46:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2a48:	9301      	str	r3, [sp, #4]
	tmp[2] = product[10];
    2a4a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2a4c:	9302      	str	r3, [sp, #8]
	tmp[3] = tmp[4] = tmp[5] = 0;
	tmp[6] = product[14];
    2a4e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    2a50:	9306      	str	r3, [sp, #24]
	tmp[7] = product[15];
    2a52:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    2a54:	9307      	str	r3, [sp, #28]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    2a56:	4405      	add	r5, r0
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    2a58:	2308      	movs	r3, #8
    2a5a:	466a      	mov	r2, sp
    2a5c:	4630      	mov	r0, r6
	tmp[3] = tmp[4] = tmp[5] = 0;
    2a5e:	e9cd 7704 	strd	r7, r7, [sp, #16]
    2a62:	9703      	str	r7, [sp, #12]
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    2a64:	f016 fd8e 	bl	19584 <uECC_vli_add>

	/* s4 */
	tmp[0] = product[9];
    2a68:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2a6a:	9300      	str	r3, [sp, #0]
	tmp[1] = product[10];
    2a6c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[2] = product[11];
	tmp[3] = product[13];
	tmp[4] = product[14];
    2a6e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
	tmp[1] = product[10];
    2a70:	9301      	str	r3, [sp, #4]
	tmp[2] = product[11];
    2a72:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2a74:	9302      	str	r3, [sp, #8]
	tmp[4] = product[14];
    2a76:	9204      	str	r2, [sp, #16]
	tmp[3] = product[13];
    2a78:	6b63      	ldr	r3, [r4, #52]	; 0x34
	tmp[5] = product[15];
    2a7a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	tmp[3] = product[13];
    2a7c:	9303      	str	r3, [sp, #12]
	tmp[6] = product[13];
    2a7e:	e9cd 2305 	strd	r2, r3, [sp, #20]
	tmp[7] = product[8];
    2a82:	6a23      	ldr	r3, [r4, #32]
    2a84:	9307      	str	r3, [sp, #28]
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    2a86:	4405      	add	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    2a88:	2308      	movs	r3, #8
    2a8a:	466a      	mov	r2, sp
    2a8c:	4630      	mov	r0, r6
    2a8e:	f016 fd79 	bl	19584 <uECC_vli_add>

	/* d1 */
	tmp[0] = product[11];
    2a92:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2a94:	9300      	str	r3, [sp, #0]
	tmp[1] = product[12];
    2a96:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2a98:	9301      	str	r3, [sp, #4]
	tmp[2] = product[13];
    2a9a:	6b63      	ldr	r3, [r4, #52]	; 0x34
    2a9c:	9302      	str	r3, [sp, #8]
	tmp[3] = tmp[4] = tmp[5] = 0;
	tmp[6] = product[8];
    2a9e:	6a23      	ldr	r3, [r4, #32]
    2aa0:	9306      	str	r3, [sp, #24]
	tmp[7] = product[10];
    2aa2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2aa4:	9307      	str	r3, [sp, #28]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    2aa6:	4405      	add	r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    2aa8:	2308      	movs	r3, #8
    2aaa:	466a      	mov	r2, sp
    2aac:	4630      	mov	r0, r6
	tmp[3] = tmp[4] = tmp[5] = 0;
    2aae:	e9cd 7704 	strd	r7, r7, [sp, #16]
    2ab2:	9703      	str	r7, [sp, #12]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    2ab4:	f016 fe97 	bl	197e6 <uECC_vli_sub>

	/* d2 */
	tmp[0] = product[12];
    2ab8:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2aba:	9300      	str	r3, [sp, #0]
	tmp[1] = product[13];
    2abc:	6b63      	ldr	r3, [r4, #52]	; 0x34
    2abe:	9301      	str	r3, [sp, #4]
	tmp[2] = product[14];
    2ac0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    2ac2:	9302      	str	r3, [sp, #8]
	tmp[3] = product[15];
    2ac4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    2ac6:	9303      	str	r3, [sp, #12]
	tmp[4] = tmp[5] = 0;
	tmp[6] = product[9];
    2ac8:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2aca:	9306      	str	r3, [sp, #24]
	tmp[7] = product[11];
    2acc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2ace:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    2ad0:	1a2d      	subs	r5, r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    2ad2:	2308      	movs	r3, #8
    2ad4:	466a      	mov	r2, sp
    2ad6:	4630      	mov	r0, r6
	tmp[4] = tmp[5] = 0;
    2ad8:	e9cd 7704 	strd	r7, r7, [sp, #16]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    2adc:	f016 fe83 	bl	197e6 <uECC_vli_sub>

	/* d3 */
	tmp[0] = product[13];
    2ae0:	6b63      	ldr	r3, [r4, #52]	; 0x34
    2ae2:	9300      	str	r3, [sp, #0]
	tmp[1] = product[14];
    2ae4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    2ae6:	9301      	str	r3, [sp, #4]
	tmp[2] = product[15];
    2ae8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    2aea:	9302      	str	r3, [sp, #8]
	tmp[3] = product[8];
    2aec:	6a23      	ldr	r3, [r4, #32]
    2aee:	9303      	str	r3, [sp, #12]
	tmp[4] = product[9];
    2af0:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2af2:	9304      	str	r3, [sp, #16]
	tmp[5] = product[10];
    2af4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[6] = 0;
    2af6:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[12];
    2afa:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2afc:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    2afe:	1a2d      	subs	r5, r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    2b00:	2308      	movs	r3, #8
    2b02:	466a      	mov	r2, sp
    2b04:	4630      	mov	r0, r6
    2b06:	f016 fe6e 	bl	197e6 <uECC_vli_sub>

	/* d4 */
	tmp[0] = product[14];
    2b0a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    2b0c:	9300      	str	r3, [sp, #0]
	tmp[1] = product[15];
    2b0e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	tmp[2] = 0;
    2b10:	e9cd 3701 	strd	r3, r7, [sp, #4]
	tmp[3] = product[9];
    2b14:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2b16:	9303      	str	r3, [sp, #12]
	tmp[4] = product[10];
    2b18:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2b1a:	9304      	str	r3, [sp, #16]
	tmp[5] = product[11];
    2b1c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	tmp[6] = 0;
    2b1e:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[13];
    2b22:	6b63      	ldr	r3, [r4, #52]	; 0x34
    2b24:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    2b26:	1a2d      	subs	r5, r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    2b28:	2308      	movs	r3, #8
    2b2a:	466a      	mov	r2, sp
    2b2c:	4630      	mov	r0, r6
    2b2e:	f016 fe5a 	bl	197e6 <uECC_vli_sub>

	if (carry < 0) {
    2b32:	1a2d      	subs	r5, r5, r0
		do {
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
    2b34:	4c0d      	ldr	r4, [pc, #52]	; (2b6c <vli_mmod_fast_secp256r1+0x19c>)
	if (carry < 0) {
    2b36:	d40f      	bmi.n	2b58 <vli_mmod_fast_secp256r1+0x188>
		}
		while (carry < 0);
	} else  {
		while (carry || 
    2b38:	b935      	cbnz	r5, 2b48 <vli_mmod_fast_secp256r1+0x178>
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
    2b3a:	2208      	movs	r2, #8
    2b3c:	4631      	mov	r1, r6
    2b3e:	4620      	mov	r0, r4
    2b40:	f016 fe27 	bl	19792 <uECC_vli_cmp_unsafe>
		while (carry || 
    2b44:	2801      	cmp	r0, #1
    2b46:	d00f      	beq.n	2b68 <vli_mmod_fast_secp256r1+0x198>
			carry -= uECC_vli_sub(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
    2b48:	2308      	movs	r3, #8
    2b4a:	4622      	mov	r2, r4
    2b4c:	4631      	mov	r1, r6
    2b4e:	4630      	mov	r0, r6
    2b50:	f016 fe49 	bl	197e6 <uECC_vli_sub>
    2b54:	1a2d      	subs	r5, r5, r0
    2b56:	e7ef      	b.n	2b38 <vli_mmod_fast_secp256r1+0x168>
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
    2b58:	2308      	movs	r3, #8
    2b5a:	4622      	mov	r2, r4
    2b5c:	4631      	mov	r1, r6
    2b5e:	4630      	mov	r0, r6
    2b60:	f016 fd10 	bl	19584 <uECC_vli_add>
		while (carry < 0);
    2b64:	182d      	adds	r5, r5, r0
    2b66:	d4f7      	bmi.n	2b58 <vli_mmod_fast_secp256r1+0x188>
		}
	}
}
    2b68:	b009      	add	sp, #36	; 0x24
    2b6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2b6c:	0001ef18 	.word	0x0001ef18

00002b70 <tc_aes128_set_encrypt_key>:

#define subbyte(a, o)(sbox[((a) >> (o))&0xff] << (o))
#define subword(a)(subbyte(a, 24)|subbyte(a, 16)|subbyte(a, 8)|subbyte(a, 0))

int tc_aes128_set_encrypt_key(TCAesKeySched_t s, const uint8_t *k)
{
    2b70:	b5f0      	push	{r4, r5, r6, r7, lr}
	const unsigned int rconst[11] = {
    2b72:	4e28      	ldr	r6, [pc, #160]	; (2c14 <tc_aes128_set_encrypt_key+0xa4>)
{
    2b74:	4607      	mov	r7, r0
    2b76:	460c      	mov	r4, r1
	const unsigned int rconst[11] = {
    2b78:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
{
    2b7a:	b08d      	sub	sp, #52	; 0x34
	const unsigned int rconst[11] = {
    2b7c:	ad01      	add	r5, sp, #4
    2b7e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2b80:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    2b82:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2b84:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
    2b88:	e885 0007 	stmia.w	r5, {r0, r1, r2}
		0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000
	};
	unsigned int i;
	unsigned int t;

	if (s == (TCAesKeySched_t) 0) {
    2b8c:	2f00      	cmp	r7, #0
    2b8e:	d03c      	beq.n	2c0a <tc_aes128_set_encrypt_key+0x9a>
		return TC_CRYPTO_FAIL;
	} else if (k == (const uint8_t *) 0) {
    2b90:	2c00      	cmp	r4, #0
    2b92:	d03c      	beq.n	2c0e <tc_aes128_set_encrypt_key+0x9e>
    2b94:	1f38      	subs	r0, r7, #4
    2b96:	4621      	mov	r1, r4
    2b98:	4602      	mov	r2, r0
    2b9a:	3410      	adds	r4, #16
		return TC_CRYPTO_FAIL;
	}

	for (i = 0; i < Nk; ++i) {
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
    2b9c:	784b      	ldrb	r3, [r1, #1]
    2b9e:	780d      	ldrb	r5, [r1, #0]
    2ba0:	041b      	lsls	r3, r3, #16
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
    2ba2:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
    2ba6:	78cd      	ldrb	r5, [r1, #3]
    2ba8:	432b      	orrs	r3, r5
    2baa:	788d      	ldrb	r5, [r1, #2]
    2bac:	3104      	adds	r1, #4
    2bae:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
	for (i = 0; i < Nk; ++i) {
    2bb2:	428c      	cmp	r4, r1
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
    2bb4:	f842 3f04 	str.w	r3, [r2, #4]!
	for (i = 0; i < Nk; ++i) {
    2bb8:	d1f0      	bne.n	2b9c <tc_aes128_set_encrypt_key+0x2c>
	}

	for (; i < (Nb * (Nr + 1)); ++i) {
		t = s->words[i-1];
		if ((i % Nk) == 0) {
			t = subword(rotword(t)) ^ rconst[i/Nk];
    2bba:	4c17      	ldr	r4, [pc, #92]	; (2c18 <tc_aes128_set_encrypt_key+0xa8>)
    2bbc:	2104      	movs	r1, #4
		if ((i % Nk) == 0) {
    2bbe:	078a      	lsls	r2, r1, #30
		t = s->words[i-1];
    2bc0:	6903      	ldr	r3, [r0, #16]
		if ((i % Nk) == 0) {
    2bc2:	d118      	bne.n	2bf6 <tc_aes128_set_encrypt_key+0x86>
	return (((a) >> 24)|((a) << 8));
    2bc4:	ea4f 6333 	mov.w	r3, r3, ror #24
			t = subword(rotword(t)) ^ rconst[i/Nk];
    2bc8:	0e1a      	lsrs	r2, r3, #24
    2bca:	5ca5      	ldrb	r5, [r4, r2]
    2bcc:	b2da      	uxtb	r2, r3
    2bce:	5ca2      	ldrb	r2, [r4, r2]
    2bd0:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
    2bd4:	f3c3 4507 	ubfx	r5, r3, #16, #8
    2bd8:	f3c3 2307 	ubfx	r3, r3, #8, #8
    2bdc:	5d65      	ldrb	r5, [r4, r5]
    2bde:	5ce3      	ldrb	r3, [r4, r3]
    2be0:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    2be4:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
    2be8:	ad0c      	add	r5, sp, #48	; 0x30
    2bea:	f021 0303 	bic.w	r3, r1, #3
    2bee:	442b      	add	r3, r5
    2bf0:	f853 3c2c 	ldr.w	r3, [r3, #-44]
    2bf4:	4053      	eors	r3, r2
		}
		s->words[i] = s->words[i-Nk] ^ t;
    2bf6:	f850 2f04 	ldr.w	r2, [r0, #4]!
	for (; i < (Nb * (Nr + 1)); ++i) {
    2bfa:	3101      	adds	r1, #1
		s->words[i] = s->words[i-Nk] ^ t;
    2bfc:	4053      	eors	r3, r2
	for (; i < (Nb * (Nr + 1)); ++i) {
    2bfe:	292c      	cmp	r1, #44	; 0x2c
		s->words[i] = s->words[i-Nk] ^ t;
    2c00:	6103      	str	r3, [r0, #16]
	for (; i < (Nb * (Nr + 1)); ++i) {
    2c02:	d1dc      	bne.n	2bbe <tc_aes128_set_encrypt_key+0x4e>
	}

	return TC_CRYPTO_SUCCESS;
    2c04:	2001      	movs	r0, #1
}
    2c06:	b00d      	add	sp, #52	; 0x34
    2c08:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return TC_CRYPTO_FAIL;
    2c0a:	4638      	mov	r0, r7
    2c0c:	e7fb      	b.n	2c06 <tc_aes128_set_encrypt_key+0x96>
    2c0e:	4620      	mov	r0, r4
    2c10:	e7f9      	b.n	2c06 <tc_aes128_set_encrypt_key+0x96>
    2c12:	bf00      	nop
    2c14:	0001ee78 	.word	0x0001ee78
    2c18:	0001f956 	.word	0x0001f956

00002c1c <tc_aes_encrypt>:
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
	(void) _copy(s, sizeof(t), t, sizeof(t));
}

int tc_aes_encrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
    2c1c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    2c20:	4615      	mov	r5, r2
    2c22:	b089      	sub	sp, #36	; 0x24
	uint8_t state[Nk*Nb];
	unsigned int i;

	if (out == (uint8_t *) 0) {
    2c24:	4607      	mov	r7, r0
    2c26:	2800      	cmp	r0, #0
    2c28:	d059      	beq.n	2cde <tc_aes_encrypt+0xc2>
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
    2c2a:	2900      	cmp	r1, #0
    2c2c:	d05a      	beq.n	2ce4 <tc_aes_encrypt+0xc8>
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
    2c2e:	2a00      	cmp	r2, #0
    2c30:	d05a      	beq.n	2ce8 <tc_aes_encrypt+0xcc>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
    2c32:	2310      	movs	r3, #16
    2c34:	460a      	mov	r2, r1
    2c36:	4668      	mov	r0, sp
    2c38:	4619      	mov	r1, r3
    2c3a:	f016 fbdf 	bl	193fc <_copy>
	add_round_key(state, s->words);
    2c3e:	4629      	mov	r1, r5
    2c40:	4668      	mov	r0, sp
		s[i] = sbox[s[i]];
    2c42:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 2cec <tc_aes_encrypt+0xd0>
	add_round_key(state, s->words);
    2c46:	f017 fae5 	bl	1a214 <add_round_key>

	for (i = 0; i < (Nr - 1); ++i) {
    2c4a:	f105 0610 	add.w	r6, r5, #16
    2c4e:	46c8      	mov	r8, r9
    2c50:	35a0      	adds	r5, #160	; 0xa0
    2c52:	466c      	mov	r4, sp
{
    2c54:	466a      	mov	r2, sp
    2c56:	2310      	movs	r3, #16
		s[i] = sbox[s[i]];
    2c58:	7811      	ldrb	r1, [r2, #0]
	for (i = 0; i < (Nb * Nk); ++i) {
    2c5a:	3b01      	subs	r3, #1
		s[i] = sbox[s[i]];
    2c5c:	f819 1001 	ldrb.w	r1, [r9, r1]
    2c60:	f802 1b01 	strb.w	r1, [r2], #1
	for (i = 0; i < (Nb * Nk); ++i) {
    2c64:	d1f8      	bne.n	2c58 <tc_aes_encrypt+0x3c>
		sub_bytes(state);
		shift_rows(state);
    2c66:	4668      	mov	r0, sp
    2c68:	f017 fb19 	bl	1a29e <shift_rows>
	mult_row_column(t, s);
    2c6c:	4669      	mov	r1, sp
    2c6e:	a804      	add	r0, sp, #16
    2c70:	f017 fb4e 	bl	1a310 <mult_row_column>
	mult_row_column(&t[Nb], s+Nb);
    2c74:	a901      	add	r1, sp, #4
    2c76:	a805      	add	r0, sp, #20
    2c78:	f017 fb4a 	bl	1a310 <mult_row_column>
	mult_row_column(&t[2 * Nb], s + (2 * Nb));
    2c7c:	a902      	add	r1, sp, #8
    2c7e:	a806      	add	r0, sp, #24
    2c80:	f017 fb46 	bl	1a310 <mult_row_column>
	mult_row_column(&t[3 * Nb], s + (3 * Nb));
    2c84:	a903      	add	r1, sp, #12
    2c86:	a807      	add	r0, sp, #28
    2c88:	f017 fb42 	bl	1a310 <mult_row_column>
	(void) _copy(s, sizeof(t), t, sizeof(t));
    2c8c:	2310      	movs	r3, #16
    2c8e:	4619      	mov	r1, r3
    2c90:	eb0d 0203 	add.w	r2, sp, r3
    2c94:	4668      	mov	r0, sp
    2c96:	f016 fbb1 	bl	193fc <_copy>
		mix_columns(state);
		add_round_key(state, s->words + Nb*(i+1));
    2c9a:	4631      	mov	r1, r6
    2c9c:	4668      	mov	r0, sp
    2c9e:	3610      	adds	r6, #16
    2ca0:	f017 fab8 	bl	1a214 <add_round_key>
	for (i = 0; i < (Nr - 1); ++i) {
    2ca4:	42ae      	cmp	r6, r5
    2ca6:	d1d4      	bne.n	2c52 <tc_aes_encrypt+0x36>
    2ca8:	2610      	movs	r6, #16
		s[i] = sbox[s[i]];
    2caa:	7823      	ldrb	r3, [r4, #0]
	for (i = 0; i < (Nb * Nk); ++i) {
    2cac:	3e01      	subs	r6, #1
		s[i] = sbox[s[i]];
    2cae:	f818 3003 	ldrb.w	r3, [r8, r3]
    2cb2:	f804 3b01 	strb.w	r3, [r4], #1
	for (i = 0; i < (Nb * Nk); ++i) {
    2cb6:	d1f8      	bne.n	2caa <tc_aes_encrypt+0x8e>
	}

	sub_bytes(state);
	shift_rows(state);
    2cb8:	4668      	mov	r0, sp
    2cba:	f017 faf0 	bl	1a29e <shift_rows>
	add_round_key(state, s->words + Nb*(i+1));
    2cbe:	4629      	mov	r1, r5
    2cc0:	4668      	mov	r0, sp
    2cc2:	f017 faa7 	bl	1a214 <add_round_key>

	(void)_copy(out, sizeof(state), state, sizeof(state));
    2cc6:	2310      	movs	r3, #16
    2cc8:	4619      	mov	r1, r3
    2cca:	466a      	mov	r2, sp
    2ccc:	4638      	mov	r0, r7
    2cce:	f016 fb95 	bl	193fc <_copy>

	/* zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
    2cd2:	4668      	mov	r0, sp
    2cd4:	2210      	movs	r2, #16
    2cd6:	4631      	mov	r1, r6
    2cd8:	f016 fb9d 	bl	19416 <_set>

	return TC_CRYPTO_SUCCESS;
    2cdc:	2001      	movs	r0, #1
}
    2cde:	b009      	add	sp, #36	; 0x24
    2ce0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return TC_CRYPTO_FAIL;
    2ce4:	4608      	mov	r0, r1
    2ce6:	e7fa      	b.n	2cde <tc_aes_encrypt+0xc2>
    2ce8:	4610      	mov	r0, r2
    2cea:	e7f8      	b.n	2cde <tc_aes_encrypt+0xc2>
    2cec:	0001f956 	.word	0x0001f956

00002cf0 <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
    2cf0:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
    2cf2:	2200      	movs	r2, #0
{
    2cf4:	b087      	sub	sp, #28
		k_timer_init(&log_process_thread_timer,
    2cf6:	490d      	ldr	r1, [pc, #52]	; (2d2c <enable_logger+0x3c>)
    2cf8:	480d      	ldr	r0, [pc, #52]	; (2d30 <enable_logger+0x40>)
    2cfa:	f01b fd94 	bl	1e826 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    2cfe:	4d0d      	ldr	r5, [pc, #52]	; (2d34 <enable_logger+0x44>)
    2d00:	490d      	ldr	r1, [pc, #52]	; (2d38 <enable_logger+0x48>)
    2d02:	2400      	movs	r4, #0
    2d04:	230e      	movs	r3, #14
    2d06:	e9cd 4302 	strd	r4, r3, [sp, #8]
    2d0a:	e9cd 4404 	strd	r4, r4, [sp, #16]
    2d0e:	e9cd 4400 	strd	r4, r4, [sp]
    2d12:	4b0a      	ldr	r3, [pc, #40]	; (2d3c <enable_logger+0x4c>)
    2d14:	f44f 7240 	mov.w	r2, #768	; 0x300
    2d18:	4628      	mov	r0, r5
    2d1a:	f015 fc57 	bl	185cc <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    2d1e:	4908      	ldr	r1, [pc, #32]	; (2d40 <enable_logger+0x50>)
    2d20:	4628      	mov	r0, r5
    2d22:	f01b fc9e 	bl	1e662 <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
    2d26:	4620      	mov	r0, r4
    2d28:	b007      	add	sp, #28
    2d2a:	bd30      	pop	{r4, r5, pc}
    2d2c:	00002d45 	.word	0x00002d45
    2d30:	20000054 	.word	0x20000054
    2d34:	2000009c 	.word	0x2000009c
    2d38:	20001f48 	.word	0x20001f48
    2d3c:	00003119 	.word	0x00003119
    2d40:	0001fa56 	.word	0x0001fa56

00002d44 <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    2d44:	4801      	ldr	r0, [pc, #4]	; (2d4c <log_process_thread_timer_expiry_fn+0x8>)
    2d46:	f015 bb9d 	b.w	18484 <z_impl_k_sem_give>
    2d4a:	bf00      	nop
    2d4c:	20005c00 	.word	0x20005c00

00002d50 <log_core_init>:
{
    2d50:	b508      	push	{r3, lr}
		log_msg_pool_init();
    2d52:	f000 fa41 	bl	31d8 <log_msg_pool_init>
		log_list_init(&list);
    2d56:	4809      	ldr	r0, [pc, #36]	; (2d7c <log_core_init+0x2c>)
    2d58:	f017 fc18 	bl	1a58c <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
    2d5c:	2304      	movs	r3, #4
    2d5e:	2228      	movs	r2, #40	; 0x28
    2d60:	4807      	ldr	r0, [pc, #28]	; (2d80 <log_core_init+0x30>)
    2d62:	4908      	ldr	r1, [pc, #32]	; (2d84 <log_core_init+0x34>)
    2d64:	f01b fa5c 	bl	1e220 <k_mem_slab_init>
		timestamp_func = k_cycle_get_32_wrapper;
    2d68:	4b07      	ldr	r3, [pc, #28]	; (2d88 <log_core_init+0x38>)
    2d6a:	4a08      	ldr	r2, [pc, #32]	; (2d8c <log_core_init+0x3c>)
    2d6c:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
    2d6e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
}
    2d72:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	log_output_timestamp_freq_set(freq);
    2d76:	f000 baa5 	b.w	32c4 <log_output_timestamp_freq_set>
    2d7a:	bf00      	nop
    2d7c:	2000004c 	.word	0x2000004c
    2d80:	20000080 	.word	0x20000080
    2d84:	200048b0 	.word	0x200048b0
    2d88:	200055c0 	.word	0x200055c0
    2d8c:	0001a5cb 	.word	0x0001a5cb

00002d90 <dropped_notify>:
{
    2d90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    2d92:	4b0f      	ldr	r3, [pc, #60]	; (2dd0 <dropped_notify+0x40>)
    2d94:	f3bf 8f5b 	dmb	ish
    2d98:	2500      	movs	r5, #0
    2d9a:	e853 7f00 	ldrex	r7, [r3]
    2d9e:	e843 5200 	strex	r2, r5, [r3]
    2da2:	2a00      	cmp	r2, #0
    2da4:	d1f9      	bne.n	2d9a <dropped_notify+0xa>
    2da6:	f3bf 8f5b 	dmb	ish
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
    2daa:	4c0a      	ldr	r4, [pc, #40]	; (2dd4 <dropped_notify+0x44>)
    2dac:	4e0a      	ldr	r6, [pc, #40]	; (2dd8 <dropped_notify+0x48>)
    2dae:	1b36      	subs	r6, r6, r4
    2db0:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
    2db2:	42b5      	cmp	r5, r6
    2db4:	db00      	blt.n	2db8 <dropped_notify+0x28>
}
    2db6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
    2db8:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
    2dba:	795b      	ldrb	r3, [r3, #5]
    2dbc:	b12b      	cbz	r3, 2dca <dropped_notify+0x3a>
	if (backend->api->dropped != NULL) {
    2dbe:	6823      	ldr	r3, [r4, #0]
    2dc0:	68db      	ldr	r3, [r3, #12]
    2dc2:	b113      	cbz	r3, 2dca <dropped_notify+0x3a>
		backend->api->dropped(backend, cnt);
    2dc4:	4639      	mov	r1, r7
    2dc6:	4620      	mov	r0, r4
    2dc8:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
    2dca:	3501      	adds	r5, #1
    2dcc:	3410      	adds	r4, #16
    2dce:	e7f0      	b.n	2db2 <dropped_notify+0x22>
    2dd0:	20000044 	.word	0x20000044
    2dd4:	0001ee78 	.word	0x0001ee78
    2dd8:	0001ee78 	.word	0x0001ee78

00002ddc <log_dropped>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    2ddc:	4b06      	ldr	r3, [pc, #24]	; (2df8 <log_dropped+0x1c>)
    2dde:	f3bf 8f5b 	dmb	ish
    2de2:	e853 2f00 	ldrex	r2, [r3]
    2de6:	3201      	adds	r2, #1
    2de8:	e843 2100 	strex	r1, r2, [r3]
    2dec:	2900      	cmp	r1, #0
    2dee:	d1f8      	bne.n	2de2 <log_dropped+0x6>
    2df0:	f3bf 8f5b 	dmb	ish
}
    2df4:	4770      	bx	lr
    2df6:	bf00      	nop
    2df8:	20000044 	.word	0x20000044

00002dfc <log_backend_enable>:
	id += backend - log_backend_get(0);
    2dfc:	4b09      	ldr	r3, [pc, #36]	; (2e24 <log_backend_enable+0x28>)
	log_backend_id_set(backend, id);
    2dfe:	6842      	ldr	r2, [r0, #4]
	id += backend - log_backend_get(0);
    2e00:	1ac3      	subs	r3, r0, r3
    2e02:	111b      	asrs	r3, r3, #4
    2e04:	3301      	adds	r3, #1
{
    2e06:	b510      	push	{r4, lr}
	log_backend_id_set(backend, id);
    2e08:	7113      	strb	r3, [r2, #4]
	log_backend_activate(backend, ctx);
    2e0a:	6843      	ldr	r3, [r0, #4]
	if (!backend_attached) {
    2e0c:	4c06      	ldr	r4, [pc, #24]	; (2e28 <log_backend_enable+0x2c>)
	backend->cb->ctx = ctx;
    2e0e:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
    2e10:	2201      	movs	r2, #1
    2e12:	715a      	strb	r2, [r3, #5]
    2e14:	7822      	ldrb	r2, [r4, #0]
    2e16:	b912      	cbnz	r2, 2e1e <log_backend_enable+0x22>
    2e18:	4804      	ldr	r0, [pc, #16]	; (2e2c <log_backend_enable+0x30>)
    2e1a:	f015 fb33 	bl	18484 <z_impl_k_sem_give>
	backend_attached = true;
    2e1e:	2301      	movs	r3, #1
    2e20:	7023      	strb	r3, [r4, #0]
}
    2e22:	bd10      	pop	{r4, pc}
    2e24:	0001ee78 	.word	0x0001ee78
    2e28:	20001b10 	.word	0x20001b10
    2e2c:	20005c00 	.word	0x20005c00

00002e30 <log_init>:
{
    2e30:	b570      	push	{r4, r5, r6, lr}
    2e32:	4b11      	ldr	r3, [pc, #68]	; (2e78 <log_init+0x48>)
    2e34:	f3bf 8f5b 	dmb	ish
    2e38:	e853 5f00 	ldrex	r5, [r3]
    2e3c:	1c6a      	adds	r2, r5, #1
    2e3e:	e843 2100 	strex	r1, r2, [r3]
    2e42:	2900      	cmp	r1, #0
    2e44:	d1f8      	bne.n	2e38 <log_init+0x8>
    2e46:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&initialized) != 0) {
    2e4a:	b92d      	cbnz	r5, 2e58 <log_init+0x28>
	return __log_backends_end - __log_backends_start;
    2e4c:	4c0b      	ldr	r4, [pc, #44]	; (2e7c <log_init+0x4c>)
    2e4e:	4e0c      	ldr	r6, [pc, #48]	; (2e80 <log_init+0x50>)
    2e50:	1b36      	subs	r6, r6, r4
    2e52:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
    2e54:	42b5      	cmp	r5, r6
    2e56:	db00      	blt.n	2e5a <log_init+0x2a>
}
    2e58:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
    2e5a:	7b23      	ldrb	r3, [r4, #12]
    2e5c:	b143      	cbz	r3, 2e70 <log_init+0x40>
			if (backend->api->init != NULL) {
    2e5e:	6823      	ldr	r3, [r4, #0]
    2e60:	695b      	ldr	r3, [r3, #20]
    2e62:	b103      	cbz	r3, 2e66 <log_init+0x36>
				backend->api->init();
    2e64:	4798      	blx	r3
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
    2e66:	2204      	movs	r2, #4
    2e68:	2100      	movs	r1, #0
    2e6a:	4620      	mov	r0, r4
    2e6c:	f7ff ffc6 	bl	2dfc <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
    2e70:	3501      	adds	r5, #1
    2e72:	3410      	adds	r4, #16
    2e74:	e7ee      	b.n	2e54 <log_init+0x24>
    2e76:	bf00      	nop
    2e78:	20000048 	.word	0x20000048
    2e7c:	0001ee78 	.word	0x0001ee78
    2e80:	0001ee78 	.word	0x0001ee78

00002e84 <log_strdup>:
	return (((const char *)addr >= (const char *)RO_START) &&
    2e84:	4b16      	ldr	r3, [pc, #88]	; (2ee0 <log_strdup+0x5c>)
    2e86:	4298      	cmp	r0, r3
{
    2e88:	b537      	push	{r0, r1, r2, r4, r5, lr}
    2e8a:	4604      	mov	r4, r0
	return (((const char *)addr >= (const char *)RO_START) &&
    2e8c:	d302      	bcc.n	2e94 <log_strdup+0x10>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
    2e8e:	4b15      	ldr	r3, [pc, #84]	; (2ee4 <log_strdup+0x60>)
    2e90:	4298      	cmp	r0, r3
    2e92:	d31f      	bcc.n	2ed4 <log_strdup+0x50>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
    2e94:	2200      	movs	r2, #0
    2e96:	a901      	add	r1, sp, #4
    2e98:	4813      	ldr	r0, [pc, #76]	; (2ee8 <log_strdup+0x64>)
    2e9a:	f014 fdef 	bl	17a7c <k_mem_slab_alloc>
	if (err != 0) {
    2e9e:	4605      	mov	r5, r0
    2ea0:	b9d8      	cbnz	r0, 2eda <log_strdup+0x56>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    2ea2:	2201      	movs	r2, #1
    2ea4:	9b01      	ldr	r3, [sp, #4]
    2ea6:	f3bf 8f5b 	dmb	ish
    2eaa:	e853 1f00 	ldrex	r1, [r3]
    2eae:	e843 2000 	strex	r0, r2, [r3]
    2eb2:	2800      	cmp	r0, #0
    2eb4:	d1f9      	bne.n	2eaa <log_strdup+0x26>
    2eb6:	f3bf 8f5b 	dmb	ish
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
    2eba:	9801      	ldr	r0, [sp, #4]
    2ebc:	4621      	mov	r1, r4
    2ebe:	221f      	movs	r2, #31
    2ec0:	3004      	adds	r0, #4
    2ec2:	f018 f855 	bl	1af70 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
    2ec6:	9c01      	ldr	r4, [sp, #4]
    2ec8:	237e      	movs	r3, #126	; 0x7e
    2eca:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
    2ece:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
	return dup->buf;
    2ed2:	3404      	adds	r4, #4
}
    2ed4:	4620      	mov	r0, r4
    2ed6:	b003      	add	sp, #12
    2ed8:	bd30      	pop	{r4, r5, pc}
		return (char *)log_strdup_fail_msg;
    2eda:	4c04      	ldr	r4, [pc, #16]	; (2eec <log_strdup+0x68>)
    2edc:	e7fa      	b.n	2ed4 <log_strdup+0x50>
    2ede:	bf00      	nop
    2ee0:	0001ea98 	.word	0x0001ea98
    2ee4:	000226f4 	.word	0x000226f4
    2ee8:	20000080 	.word	0x20000080
    2eec:	0001fa5e 	.word	0x0001fa5e

00002ef0 <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (u8_t *)buf);
    2ef0:	b148      	cbz	r0, 2f06 <log_is_strdup+0x16>
    2ef2:	4b05      	ldr	r3, [pc, #20]	; (2f08 <log_is_strdup+0x18>)
    2ef4:	4298      	cmp	r0, r3
    2ef6:	d305      	bcc.n	2f04 <log_is_strdup+0x14>
    2ef8:	33a0      	adds	r3, #160	; 0xa0
    2efa:	4298      	cmp	r0, r3
    2efc:	bf2c      	ite	cs
    2efe:	2000      	movcs	r0, #0
    2f00:	2001      	movcc	r0, #1
    2f02:	4770      	bx	lr
    2f04:	2000      	movs	r0, #0
}
    2f06:	4770      	bx	lr
    2f08:	200048b0 	.word	0x200048b0

00002f0c <z_impl_log_process>:
{
    2f0c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!backend_attached && !bypass) {
    2f10:	4b46      	ldr	r3, [pc, #280]	; (302c <z_impl_log_process+0x120>)
    2f12:	781b      	ldrb	r3, [r3, #0]
{
    2f14:	4605      	mov	r5, r0
	if (!backend_attached && !bypass) {
    2f16:	b903      	cbnz	r3, 2f1a <z_impl_log_process+0xe>
    2f18:	b360      	cbz	r0, 2f74 <z_impl_log_process+0x68>
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
    2f1a:	f04f 0320 	mov.w	r3, #32
    2f1e:	f3ef 8611 	mrs	r6, BASEPRI
    2f22:	f383 8811 	msr	BASEPRI, r3
    2f26:	f3bf 8f6f 	isb	sy
	msg = log_list_head_get(&list);
    2f2a:	4841      	ldr	r0, [pc, #260]	; (3030 <z_impl_log_process+0x124>)
    2f2c:	f017 fb3e 	bl	1a5ac <log_list_head_get>
    2f30:	4604      	mov	r4, r0
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
    2f32:	f386 8811 	msr	BASEPRI, r6
    2f36:	f3bf 8f6f 	isb	sy
	if (msg != NULL) {
    2f3a:	b178      	cbz	r0, 2f5c <z_impl_log_process+0x50>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    2f3c:	f3bf 8f5b 	dmb	ish
    2f40:	4b3c      	ldr	r3, [pc, #240]	; (3034 <z_impl_log_process+0x128>)
    2f42:	e853 2f00 	ldrex	r2, [r3]
    2f46:	3a01      	subs	r2, #1
    2f48:	e843 2100 	strex	r1, r2, [r3]
    2f4c:	2900      	cmp	r1, #0
    2f4e:	d1f8      	bne.n	2f42 <z_impl_log_process+0x36>
    2f50:	f3bf 8f5b 	dmb	ish
	if (!bypass) {
    2f54:	b18d      	cbz	r5, 2f7a <z_impl_log_process+0x6e>
	log_msg_put(msg);
    2f56:	4620      	mov	r0, r4
    2f58:	f017 fbda 	bl	1a710 <log_msg_put>
	if (!bypass && dropped_cnt) {
    2f5c:	b925      	cbnz	r5, 2f68 <z_impl_log_process+0x5c>
    2f5e:	4b36      	ldr	r3, [pc, #216]	; (3038 <z_impl_log_process+0x12c>)
    2f60:	681b      	ldr	r3, [r3, #0]
    2f62:	b10b      	cbz	r3, 2f68 <z_impl_log_process+0x5c>
		dropped_notify();
    2f64:	f7ff ff14 	bl	2d90 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
    2f68:	4831      	ldr	r0, [pc, #196]	; (3030 <z_impl_log_process+0x124>)
    2f6a:	f017 fb1d 	bl	1a5a8 <log_list_head_peek>
    2f6e:	1c05      	adds	r5, r0, #0
    2f70:	bf18      	it	ne
    2f72:	2501      	movne	r5, #1
}
    2f74:	4628      	mov	r0, r5
    2f76:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    !panic_mode) {
    2f7a:	4b30      	ldr	r3, [pc, #192]	; (303c <z_impl_log_process+0x130>)
		if (IS_ENABLED(CONFIG_LOG_DETECT_MISSED_STRDUP) &&
    2f7c:	781b      	ldrb	r3, [r3, #0]
    2f7e:	b9ab      	cbnz	r3, 2fac <z_impl_log_process+0xa0>
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    2f80:	7a23      	ldrb	r3, [r4, #8]
	if (!log_msg_is_std(msg)) {
    2f82:	07db      	lsls	r3, r3, #31
    2f84:	d412      	bmi.n	2fac <z_impl_log_process+0xa0>
	msg_str = log_msg_str_get(msg);
    2f86:	f017 fbd6 	bl	1a736 <log_msg_str_get>
    2f8a:	4681      	mov	r9, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    2f8c:	4620      	mov	r0, r4
    2f8e:	f017 fb9f 	bl	1a6d0 <log_msg_nargs_get>
    2f92:	4601      	mov	r1, r0
    2f94:	4648      	mov	r0, r9
    2f96:	f017 fb1c 	bl	1a5d2 <z_log_get_s_mask>
    2f9a:	4b29      	ldr	r3, [pc, #164]	; (3040 <z_impl_log_process+0x134>)
				LOG_ERR(ERR_MSG, idx, msg_str);
    2f9c:	4a29      	ldr	r2, [pc, #164]	; (3044 <z_impl_log_process+0x138>)
    2f9e:	f8df b0bc 	ldr.w	fp, [pc, #188]	; 305c <z_impl_log_process+0x150>
    2fa2:	1a9b      	subs	r3, r3, r2
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    2fa4:	4607      	mov	r7, r0
				LOG_ERR(ERR_MSG, idx, msg_str);
    2fa6:	f3c3 0ac9 	ubfx	sl, r3, #3, #10
	while (mask) {
    2faa:	b937      	cbnz	r7, 2fba <z_impl_log_process+0xae>
    2fac:	4e26      	ldr	r6, [pc, #152]	; (3048 <z_impl_log_process+0x13c>)
    2fae:	4f27      	ldr	r7, [pc, #156]	; (304c <z_impl_log_process+0x140>)
    2fb0:	1bbf      	subs	r7, r7, r6
    2fb2:	113f      	asrs	r7, r7, #4
    2fb4:	f04f 0800 	mov.w	r8, #0
    2fb8:	e034      	b.n	3024 <z_impl_log_process+0x118>
		idx = 31 - __builtin_clz(mask);
    2fba:	fab7 f687 	clz	r6, r7
    2fbe:	f1c6 061f 	rsb	r6, r6, #31
		str = (const char *)log_msg_arg_get(msg, idx);
    2fc2:	4631      	mov	r1, r6
    2fc4:	4620      	mov	r0, r4
    2fc6:	f017 fb86 	bl	1a6d6 <log_msg_arg_get>
	return (((const char *)addr >= (const char *)RO_START) &&
    2fca:	4b21      	ldr	r3, [pc, #132]	; (3050 <z_impl_log_process+0x144>)
    2fcc:	4298      	cmp	r0, r3
		str = (const char *)log_msg_arg_get(msg, idx);
    2fce:	4602      	mov	r2, r0
	return (((const char *)addr >= (const char *)RO_START) &&
    2fd0:	d302      	bcc.n	2fd8 <z_impl_log_process+0xcc>
		if (!is_rodata(str) && !log_is_strdup(str) &&
    2fd2:	4b20      	ldr	r3, [pc, #128]	; (3054 <z_impl_log_process+0x148>)
    2fd4:	4298      	cmp	r0, r3
    2fd6:	d314      	bcc.n	3002 <z_impl_log_process+0xf6>
    2fd8:	4610      	mov	r0, r2
    2fda:	f7ff ff89 	bl	2ef0 <log_is_strdup>
    2fde:	b980      	cbnz	r0, 3002 <z_impl_log_process+0xf6>
    2fe0:	4b1d      	ldr	r3, [pc, #116]	; (3058 <z_impl_log_process+0x14c>)
    2fe2:	429a      	cmp	r2, r3
    2fe4:	d00d      	beq.n	3002 <z_impl_log_process+0xf6>
				LOG_ERR(ERR_MSG, idx, msg_str);
    2fe6:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
    2fea:	f043 0301 	orr.w	r3, r3, #1
    2fee:	f363 0807 	bfi	r8, r3, #0, #8
    2ff2:	f36a 188f 	bfi	r8, sl, #6, #10
    2ff6:	4643      	mov	r3, r8
    2ff8:	464a      	mov	r2, r9
    2ffa:	4631      	mov	r1, r6
    2ffc:	4658      	mov	r0, fp
    2ffe:	f017 fb29 	bl	1a654 <log_2>
		mask &= ~BIT(idx);
    3002:	2301      	movs	r3, #1
    3004:	fa03 f606 	lsl.w	r6, r3, r6
    3008:	ea27 0706 	bic.w	r7, r7, r6
    300c:	e7cd      	b.n	2faa <z_impl_log_process+0x9e>
	return backend->cb->active;
    300e:	6873      	ldr	r3, [r6, #4]
			if (log_backend_is_active(backend) &&
    3010:	795b      	ldrb	r3, [r3, #5]
    3012:	b123      	cbz	r3, 301e <z_impl_log_process+0x112>
	backend->api->put(backend, msg);
    3014:	6833      	ldr	r3, [r6, #0]
    3016:	4621      	mov	r1, r4
    3018:	681b      	ldr	r3, [r3, #0]
    301a:	4630      	mov	r0, r6
    301c:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
    301e:	f108 0801 	add.w	r8, r8, #1
    3022:	3610      	adds	r6, #16
    3024:	45b8      	cmp	r8, r7
    3026:	dbf2      	blt.n	300e <z_impl_log_process+0x102>
    3028:	e795      	b.n	2f56 <z_impl_log_process+0x4a>
    302a:	bf00      	nop
    302c:	20001b10 	.word	0x20001b10
    3030:	2000004c 	.word	0x2000004c
    3034:	20000040 	.word	0x20000040
    3038:	20000044 	.word	0x20000044
    303c:	20001b11 	.word	0x20001b11
    3040:	0001ee40 	.word	0x0001ee40
    3044:	0001ed28 	.word	0x0001ed28
    3048:	0001ee78 	.word	0x0001ee78
    304c:	0001ee78 	.word	0x0001ee78
    3050:	0001ea98 	.word	0x0001ea98
    3054:	000226f4 	.word	0x000226f4
    3058:	0001fa5e 	.word	0x0001fa5e
    305c:	0001fa7c 	.word	0x0001fa7c

00003060 <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
    3060:	4b26      	ldr	r3, [pc, #152]	; (30fc <msg_finalize+0x9c>)
{
    3062:	b570      	push	{r4, r5, r6, lr}
	msg->hdr.timestamp = timestamp_func();
    3064:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
    3066:	8141      	strh	r1, [r0, #10]
{
    3068:	4605      	mov	r5, r0
	msg->hdr.timestamp = timestamp_func();
    306a:	4798      	blx	r3
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    306c:	4c24      	ldr	r4, [pc, #144]	; (3100 <msg_finalize+0xa0>)
    306e:	60e8      	str	r0, [r5, #12]
    3070:	f3bf 8f5b 	dmb	ish
    3074:	e854 3f00 	ldrex	r3, [r4]
    3078:	3301      	adds	r3, #1
    307a:	e844 3200 	strex	r2, r3, [r4]
    307e:	2a00      	cmp	r2, #0
    3080:	d1f8      	bne.n	3074 <msg_finalize+0x14>
    3082:	f3bf 8f5b 	dmb	ish
	__asm__ volatile(
    3086:	f04f 0320 	mov.w	r3, #32
    308a:	f3ef 8611 	mrs	r6, BASEPRI
    308e:	f383 8811 	msr	BASEPRI, r3
    3092:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    3096:	481b      	ldr	r0, [pc, #108]	; (3104 <msg_finalize+0xa4>)
    3098:	4629      	mov	r1, r5
    309a:	f017 fa7b 	bl	1a594 <log_list_add_tail>
	__asm__ volatile(
    309e:	f386 8811 	msr	BASEPRI, r6
    30a2:	f3bf 8f6f 	isb	sy
	if (panic_mode) {
    30a6:	4b18      	ldr	r3, [pc, #96]	; (3108 <msg_finalize+0xa8>)
    30a8:	781a      	ldrb	r2, [r3, #0]
    30aa:	b17a      	cbz	r2, 30cc <msg_finalize+0x6c>
	__asm__ volatile(
    30ac:	f04f 0320 	mov.w	r3, #32
    30b0:	f3ef 8411 	mrs	r4, BASEPRI
    30b4:	f383 8811 	msr	BASEPRI, r3
    30b8:	f3bf 8f6f 	isb	sy
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
    30bc:	2000      	movs	r0, #0
    30be:	f7ff ff25 	bl	2f0c <z_impl_log_process>
	__asm__ volatile(
    30c2:	f384 8811 	msr	BASEPRI, r4
    30c6:	f3bf 8f6f 	isb	sy
}
    30ca:	bd70      	pop	{r4, r5, r6, pc}
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    30cc:	490f      	ldr	r1, [pc, #60]	; (310c <msg_finalize+0xac>)
    30ce:	6823      	ldr	r3, [r4, #0]
    30d0:	6809      	ldr	r1, [r1, #0]
    30d2:	2900      	cmp	r1, #0
    30d4:	d0f9      	beq.n	30ca <msg_finalize+0x6a>
    30d6:	2b01      	cmp	r3, #1
    30d8:	d106      	bne.n	30e8 <msg_finalize+0x88>
	z_impl_k_timer_start(timer, duration, period);
    30da:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    30de:	480c      	ldr	r0, [pc, #48]	; (3110 <msg_finalize+0xb0>)
}
    30e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    30e4:	f015 bcc2 	b.w	18a6c <z_impl_k_timer_start>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    30e8:	2b0a      	cmp	r3, #10
    30ea:	d1ee      	bne.n	30ca <msg_finalize+0x6a>
	z_impl_k_timer_stop(timer);
    30ec:	4808      	ldr	r0, [pc, #32]	; (3110 <msg_finalize+0xb0>)
    30ee:	f01b fba6 	bl	1e83e <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
    30f2:	4808      	ldr	r0, [pc, #32]	; (3114 <msg_finalize+0xb4>)
}
    30f4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    30f8:	f015 b9c4 	b.w	18484 <z_impl_k_sem_give>
    30fc:	200055c0 	.word	0x200055c0
    3100:	20000040 	.word	0x20000040
    3104:	2000004c 	.word	0x2000004c
    3108:	20001b11 	.word	0x20001b11
    310c:	20000108 	.word	0x20000108
    3110:	20000054 	.word	0x20000054
    3114:	20005c00 	.word	0x20005c00

00003118 <log_process_thread_func>:
{
    3118:	b508      	push	{r3, lr}
	log_init();
    311a:	f7ff fe89 	bl	2e30 <log_init>
	return z_impl_k_current_get();
    311e:	f015 f9ab 	bl	18478 <z_impl_k_current_get>
	proc_tid = process_tid;
    3122:	4b0b      	ldr	r3, [pc, #44]	; (3150 <log_process_thread_func+0x38>)
    3124:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    3126:	b130      	cbz	r0, 3136 <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
    3128:	4b0a      	ldr	r3, [pc, #40]	; (3154 <log_process_thread_func+0x3c>)
	    process_tid &&
    312a:	681b      	ldr	r3, [r3, #0]
    312c:	2b09      	cmp	r3, #9
    312e:	dd02      	ble.n	3136 <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
    3130:	4809      	ldr	r0, [pc, #36]	; (3158 <log_process_thread_func+0x40>)
    3132:	f015 f9a7 	bl	18484 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
    3136:	4c08      	ldr	r4, [pc, #32]	; (3158 <log_process_thread_func+0x40>)
    3138:	2000      	movs	r0, #0
    313a:	f7ff fee7 	bl	2f0c <z_impl_log_process>
		if (log_process(false) == false) {
    313e:	2800      	cmp	r0, #0
    3140:	d1fa      	bne.n	3138 <log_process_thread_func+0x20>
    3142:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3146:	4620      	mov	r0, r4
    3148:	f015 f9c8 	bl	184dc <z_impl_k_sem_take>
    314c:	e7f4      	b.n	3138 <log_process_thread_func+0x20>
    314e:	bf00      	nop
    3150:	20000108 	.word	0x20000108
    3154:	20000040 	.word	0x20000040
    3158:	20005c00 	.word	0x20005c00

0000315c <z_impl_log_panic>:
{
    315c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
    315e:	4f0e      	ldr	r7, [pc, #56]	; (3198 <z_impl_log_panic+0x3c>)
    3160:	783d      	ldrb	r5, [r7, #0]
    3162:	b975      	cbnz	r5, 3182 <z_impl_log_panic+0x26>
	return __log_backends_end - __log_backends_start;
    3164:	4c0d      	ldr	r4, [pc, #52]	; (319c <z_impl_log_panic+0x40>)
    3166:	4e0e      	ldr	r6, [pc, #56]	; (31a0 <z_impl_log_panic+0x44>)
	log_init();
    3168:	f7ff fe62 	bl	2e30 <log_init>
    316c:	1b36      	subs	r6, r6, r4
    316e:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
    3170:	42b5      	cmp	r5, r6
    3172:	db07      	blt.n	3184 <z_impl_log_panic+0x28>
    3174:	2000      	movs	r0, #0
    3176:	f7ff fec9 	bl	2f0c <z_impl_log_process>
		while (log_process(false) == true) {
    317a:	2800      	cmp	r0, #0
    317c:	d1fa      	bne.n	3174 <z_impl_log_panic+0x18>
	panic_mode = true;
    317e:	2301      	movs	r3, #1
    3180:	703b      	strb	r3, [r7, #0]
}
    3182:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
    3184:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
    3186:	795b      	ldrb	r3, [r3, #5]
    3188:	b11b      	cbz	r3, 3192 <z_impl_log_panic+0x36>
	backend->api->panic(backend);
    318a:	6823      	ldr	r3, [r4, #0]
    318c:	4620      	mov	r0, r4
    318e:	691b      	ldr	r3, [r3, #16]
    3190:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
    3192:	3501      	adds	r5, #1
    3194:	3410      	adds	r4, #16
    3196:	e7eb      	b.n	3170 <z_impl_log_panic+0x14>
    3198:	20001b11 	.word	0x20001b11
    319c:	0001ee78 	.word	0x0001ee78
    31a0:	0001ee78 	.word	0x0001ee78

000031a4 <log_free>:
{
    31a4:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
    31a6:	3804      	subs	r0, #4
    31a8:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    31aa:	f3bf 8f5b 	dmb	ish
    31ae:	e850 3f00 	ldrex	r3, [r0]
    31b2:	1e5a      	subs	r2, r3, #1
    31b4:	e840 2100 	strex	r1, r2, [r0]
    31b8:	2900      	cmp	r1, #0
    31ba:	d1f8      	bne.n	31ae <log_free+0xa>
    31bc:	f3bf 8f5b 	dmb	ish
	if (atomic_dec(&dup->refcount) == 1) {
    31c0:	2b01      	cmp	r3, #1
    31c2:	d103      	bne.n	31cc <log_free+0x28>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
    31c4:	a901      	add	r1, sp, #4
    31c6:	4803      	ldr	r0, [pc, #12]	; (31d4 <log_free+0x30>)
    31c8:	f014 fc84 	bl	17ad4 <k_mem_slab_free>
}
    31cc:	b003      	add	sp, #12
    31ce:	f85d fb04 	ldr.w	pc, [sp], #4
    31d2:	bf00      	nop
    31d4:	20000080 	.word	0x20000080

000031d8 <log_msg_pool_init>:
static u8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
    31d8:	2320      	movs	r3, #32
    31da:	461a      	mov	r2, r3
    31dc:	4901      	ldr	r1, [pc, #4]	; (31e4 <log_msg_pool_init+0xc>)
    31de:	4802      	ldr	r0, [pc, #8]	; (31e8 <log_msg_pool_init+0x10>)
    31e0:	f01b b81e 	b.w	1e220 <k_mem_slab_init>
    31e4:	20004950 	.word	0x20004950
    31e8:	2000010c 	.word	0x2000010c

000031ec <log_msg_no_space_handle>:

	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
    31ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
	union log_msg_chunk *msg = NULL;
    31ee:	2300      	movs	r3, #0

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
    31f0:	4d09      	ldr	r5, [pc, #36]	; (3218 <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
    31f2:	9301      	str	r3, [sp, #4]
    31f4:	2001      	movs	r0, #1
    31f6:	f7ff fe89 	bl	2f0c <z_impl_log_process>
    31fa:	4604      	mov	r4, r0
			log_dropped();
    31fc:	f7ff fdee 	bl	2ddc <log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
    3200:	2200      	movs	r2, #0
    3202:	a901      	add	r1, sp, #4
    3204:	4628      	mov	r0, r5
    3206:	f014 fc39 	bl	17a7c <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
    320a:	b108      	cbz	r0, 3210 <log_msg_no_space_handle+0x24>
    320c:	2c00      	cmp	r4, #0
    320e:	d1f1      	bne.n	31f4 <log_msg_no_space_handle+0x8>
	} else {
		log_dropped();
	}
	return msg;

}
    3210:	9801      	ldr	r0, [sp, #4]
    3212:	b003      	add	sp, #12
    3214:	bd30      	pop	{r4, r5, pc}
    3216:	bf00      	nop
    3218:	2000010c 	.word	0x2000010c

0000321c <log_msg_chunk_alloc>:
{
    321c:	b507      	push	{r0, r1, r2, lr}
	union log_msg_chunk *msg = NULL;
    321e:	2200      	movs	r2, #0
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    3220:	a901      	add	r1, sp, #4
    3222:	4806      	ldr	r0, [pc, #24]	; (323c <log_msg_chunk_alloc+0x20>)
	union log_msg_chunk *msg = NULL;
    3224:	9201      	str	r2, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    3226:	f014 fc29 	bl	17a7c <k_mem_slab_alloc>
	if (err != 0) {
    322a:	b110      	cbz	r0, 3232 <log_msg_chunk_alloc+0x16>
		msg = log_msg_no_space_handle();
    322c:	f7ff ffde 	bl	31ec <log_msg_no_space_handle>
    3230:	9001      	str	r0, [sp, #4]
}
    3232:	9801      	ldr	r0, [sp, #4]
    3234:	b003      	add	sp, #12
    3236:	f85d fb04 	ldr.w	pc, [sp], #4
    323a:	bf00      	nop
    323c:	2000010c 	.word	0x2000010c

00003240 <msg_free>:
{
    3240:	b5f0      	push	{r4, r5, r6, r7, lr}
    3242:	7a04      	ldrb	r4, [r0, #8]
	}
}

u32_t log_msg_nargs_get(struct log_msg *msg)
{
	return msg->hdr.params.std.nargs;
    3244:	7a46      	ldrb	r6, [r0, #9]
{
    3246:	b085      	sub	sp, #20
	if (log_msg_is_std(msg) && nargs) {
    3248:	f014 0401 	ands.w	r4, r4, #1
{
    324c:	9001      	str	r0, [sp, #4]
	return msg->hdr.params.std.nargs;
    324e:	ea4f 1616 	mov.w	r6, r6, lsr #4
	if (log_msg_is_std(msg) && nargs) {
    3252:	d00e      	beq.n	3272 <msg_free+0x32>
	if (msg->hdr.params.generic.ext == 1) {
    3254:	9b01      	ldr	r3, [sp, #4]
    3256:	7a1a      	ldrb	r2, [r3, #8]
    3258:	0792      	lsls	r2, r2, #30
    325a:	d504      	bpl.n	3266 <msg_free+0x26>
		cont_free(msg->payload.ext.next);
    325c:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    325e:	4c18      	ldr	r4, [pc, #96]	; (32c0 <msg_free+0x80>)
    3260:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
    3262:	9b03      	ldr	r3, [sp, #12]
    3264:	bb2b      	cbnz	r3, 32b2 <msg_free+0x72>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
    3266:	a901      	add	r1, sp, #4
    3268:	4815      	ldr	r0, [pc, #84]	; (32c0 <msg_free+0x80>)
    326a:	f014 fc33 	bl	17ad4 <k_mem_slab_free>
}
    326e:	b005      	add	sp, #20
    3270:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (log_msg_is_std(msg) && nargs) {
    3272:	2e00      	cmp	r6, #0
    3274:	d0ee      	beq.n	3254 <msg_free+0x14>
		for (i = 0; i < nargs; i++) {
    3276:	4625      	mov	r5, r4
    3278:	e017      	b.n	32aa <msg_free+0x6a>
			void *buf = (void *)log_msg_arg_get(msg, i);
    327a:	4629      	mov	r1, r5
    327c:	f017 fa2b 	bl	1a6d6 <log_msg_arg_get>
    3280:	4607      	mov	r7, r0
			if (log_is_strdup(buf)) {
    3282:	f7ff fe35 	bl	2ef0 <log_is_strdup>
    3286:	b178      	cbz	r0, 32a8 <msg_free+0x68>
				if (smask == 0) {
    3288:	b93c      	cbnz	r4, 329a <msg_free+0x5a>
					smask = z_log_get_s_mask(
    328a:	9b01      	ldr	r3, [sp, #4]
    328c:	4631      	mov	r1, r6
    328e:	6918      	ldr	r0, [r3, #16]
    3290:	f017 f99f 	bl	1a5d2 <z_log_get_s_mask>
					if (smask == 0) {
    3294:	4604      	mov	r4, r0
    3296:	2800      	cmp	r0, #0
    3298:	d0dc      	beq.n	3254 <msg_free+0x14>
				if (smask & BIT(i)) {
    329a:	fa24 f305 	lsr.w	r3, r4, r5
    329e:	07db      	lsls	r3, r3, #31
    32a0:	d502      	bpl.n	32a8 <msg_free+0x68>
					log_free(buf);
    32a2:	4638      	mov	r0, r7
    32a4:	f7ff ff7e 	bl	31a4 <log_free>
		for (i = 0; i < nargs; i++) {
    32a8:	3501      	adds	r5, #1
    32aa:	42ae      	cmp	r6, r5
    32ac:	9801      	ldr	r0, [sp, #4]
    32ae:	d8e4      	bhi.n	327a <msg_free+0x3a>
    32b0:	e7d0      	b.n	3254 <msg_free+0x14>
		next = cont->next;
    32b2:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    32b4:	a903      	add	r1, sp, #12
    32b6:	4620      	mov	r0, r4
    32b8:	f014 fc0c 	bl	17ad4 <k_mem_slab_free>
		cont = next;
    32bc:	9503      	str	r5, [sp, #12]
    32be:	e7d0      	b.n	3262 <msg_free+0x22>
    32c0:	2000010c 	.word	0x2000010c

000032c4 <log_output_timestamp_freq_set>:
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
}

void log_output_timestamp_freq_set(u32_t frequency)
{
	timestamp_div = 1U;
    32c4:	4a08      	ldr	r2, [pc, #32]	; (32e8 <log_output_timestamp_freq_set+0x24>)
{
    32c6:	b510      	push	{r4, lr}
	timestamp_div = 1U;
    32c8:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
    32ca:	4c08      	ldr	r4, [pc, #32]	; (32ec <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
    32cc:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
    32ce:	2100      	movs	r1, #0
    32d0:	42a0      	cmp	r0, r4
    32d2:	d804      	bhi.n	32de <log_output_timestamp_freq_set+0x1a>
    32d4:	b101      	cbz	r1, 32d8 <log_output_timestamp_freq_set+0x14>
    32d6:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
    32d8:	4b05      	ldr	r3, [pc, #20]	; (32f0 <log_output_timestamp_freq_set+0x2c>)
    32da:	6018      	str	r0, [r3, #0]
}
    32dc:	bd10      	pop	{r4, pc}
		frequency /= 2U;
    32de:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
    32e0:	005b      	lsls	r3, r3, #1
    32e2:	2101      	movs	r1, #1
    32e4:	e7f4      	b.n	32d0 <log_output_timestamp_freq_set+0xc>
    32e6:	bf00      	nop
    32e8:	2000012c 	.word	0x2000012c
    32ec:	000f4240 	.word	0x000f4240
    32f0:	20000128 	.word	0x20000128

000032f4 <read_pnp_id>:

#if CONFIG_BT_GATT_DIS_PNP
static ssize_t read_pnp_id(struct bt_conn *conn,
			   const struct bt_gatt_attr *attr, void *buf,
			   u16_t len, u16_t offset)
{
    32f4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &dis_pnp_id,
    32f6:	2407      	movs	r4, #7
    32f8:	9402      	str	r4, [sp, #8]
    32fa:	4c04      	ldr	r4, [pc, #16]	; (330c <read_pnp_id+0x18>)
    32fc:	9401      	str	r4, [sp, #4]
    32fe:	f8bd 4018 	ldrh.w	r4, [sp, #24]
    3302:	9400      	str	r4, [sp, #0]
    3304:	f019 f83b 	bl	1c37e <bt_gatt_attr_read>
				 sizeof(dis_pnp_id));
}
    3308:	b004      	add	sp, #16
    330a:	bd10      	pop	{r4, pc}
    330c:	20005b02 	.word	0x20005b02

00003310 <blvl_ccc_cfg_changed>:
{
	ARG_UNUSED(attr);

	bool notif_enabled = (value == BT_GATT_CCC_NOTIFY);

	LOG_INF("BAS Notifications %s", notif_enabled ? "enabled" : "disabled");
    3310:	2303      	movs	r3, #3
    3312:	f04f 0200 	mov.w	r2, #0
    3316:	f363 0207 	bfi	r2, r3, #0, #8
    331a:	4807      	ldr	r0, [pc, #28]	; (3338 <blvl_ccc_cfg_changed+0x28>)
    331c:	4b07      	ldr	r3, [pc, #28]	; (333c <blvl_ccc_cfg_changed+0x2c>)
    331e:	1a1b      	subs	r3, r3, r0
    3320:	08db      	lsrs	r3, r3, #3
    3322:	4807      	ldr	r0, [pc, #28]	; (3340 <blvl_ccc_cfg_changed+0x30>)
    3324:	f363 128f 	bfi	r2, r3, #6, #10
    3328:	4b06      	ldr	r3, [pc, #24]	; (3344 <blvl_ccc_cfg_changed+0x34>)
    332a:	2901      	cmp	r1, #1
    332c:	bf14      	ite	ne
    332e:	4601      	movne	r1, r0
    3330:	4619      	moveq	r1, r3
    3332:	4805      	ldr	r0, [pc, #20]	; (3348 <blvl_ccc_cfg_changed+0x38>)
    3334:	f017 b97a 	b.w	1a62c <log_1>
    3338:	0001ed28 	.word	0x0001ed28
    333c:	0001ed28 	.word	0x0001ed28
    3340:	0001fadc 	.word	0x0001fadc
    3344:	0001fad4 	.word	0x0001fad4
    3348:	0001fae5 	.word	0x0001fae5

0000334c <read_blvl>:
}

static ssize_t read_blvl(struct bt_conn *conn,
			       const struct bt_gatt_attr *attr, void *buf,
			       u16_t len, u16_t offset)
{
    334c:	b510      	push	{r4, lr}
	u8_t lvl8 = battery_level;
    334e:	4c08      	ldr	r4, [pc, #32]	; (3370 <read_blvl+0x24>)
{
    3350:	b086      	sub	sp, #24
	u8_t lvl8 = battery_level;
    3352:	7824      	ldrb	r4, [r4, #0]
    3354:	f88d 4017 	strb.w	r4, [sp, #23]

	return bt_gatt_attr_read(conn, attr, buf, len, offset, &lvl8,
    3358:	2401      	movs	r4, #1
    335a:	9402      	str	r4, [sp, #8]
    335c:	f10d 0417 	add.w	r4, sp, #23
    3360:	9401      	str	r4, [sp, #4]
    3362:	f8bd 4020 	ldrh.w	r4, [sp, #32]
    3366:	9400      	str	r4, [sp, #0]
    3368:	f019 f809 	bl	1c37e <bt_gatt_attr_read>
				 sizeof(lvl8));
}
    336c:	b006      	add	sp, #24
    336e:	bd10      	pop	{r4, pc}
    3370:	20005b09 	.word	0x20005b09

00003374 <hrs_init>:

static int hrs_init(struct device *dev)
{
	ARG_UNUSED(dev);

	hrs_blsc = 0x01;
    3374:	4b02      	ldr	r3, [pc, #8]	; (3380 <hrs_init+0xc>)
    3376:	2201      	movs	r2, #1
    3378:	701a      	strb	r2, [r3, #0]

	return 0;
}
    337a:	2000      	movs	r0, #0
    337c:	4770      	bx	lr
    337e:	bf00      	nop
    3380:	20001b12 	.word	0x20001b12

00003384 <read_blsc>:
{
    3384:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &hrs_blsc,
    3386:	2401      	movs	r4, #1
    3388:	9402      	str	r4, [sp, #8]
    338a:	4c04      	ldr	r4, [pc, #16]	; (339c <read_blsc+0x18>)
    338c:	9401      	str	r4, [sp, #4]
    338e:	f8bd 4018 	ldrh.w	r4, [sp, #24]
    3392:	9400      	str	r4, [sp, #0]
    3394:	f018 fff3 	bl	1c37e <bt_gatt_attr_read>
}
    3398:	b004      	add	sp, #16
    339a:	bd10      	pop	{r4, pc}
    339c:	20001b12 	.word	0x20001b12

000033a0 <hrmc_ccc_cfg_changed>:
	LOG_INF("HRS notifications %s", notif_enabled ? "enabled" : "disabled");
    33a0:	2303      	movs	r3, #3
    33a2:	f04f 0200 	mov.w	r2, #0
    33a6:	f363 0207 	bfi	r2, r3, #0, #8
    33aa:	4807      	ldr	r0, [pc, #28]	; (33c8 <hrmc_ccc_cfg_changed+0x28>)
    33ac:	4b07      	ldr	r3, [pc, #28]	; (33cc <hrmc_ccc_cfg_changed+0x2c>)
    33ae:	1a1b      	subs	r3, r3, r0
    33b0:	08db      	lsrs	r3, r3, #3
    33b2:	4807      	ldr	r0, [pc, #28]	; (33d0 <hrmc_ccc_cfg_changed+0x30>)
    33b4:	f363 128f 	bfi	r2, r3, #6, #10
    33b8:	4b06      	ldr	r3, [pc, #24]	; (33d4 <hrmc_ccc_cfg_changed+0x34>)
    33ba:	2901      	cmp	r1, #1
    33bc:	bf14      	ite	ne
    33be:	4601      	movne	r1, r0
    33c0:	4619      	moveq	r1, r3
    33c2:	4805      	ldr	r0, [pc, #20]	; (33d8 <hrmc_ccc_cfg_changed+0x38>)
    33c4:	f017 b932 	b.w	1a62c <log_1>
    33c8:	0001ed28 	.word	0x0001ed28
    33cc:	0001ee30 	.word	0x0001ee30
    33d0:	0001fadc 	.word	0x0001fadc
    33d4:	0001fad4 	.word	0x0001fad4
    33d8:	0001fafe 	.word	0x0001fafe

000033dc <nvs_prev_ate>:

/* walking through allocation entry list, from newest to oldest entries
 * read ate from addr, modify addr to the previous ate
 */
static int nvs_prev_ate(struct nvs_fs *fs, u32_t *addr, struct nvs_ate *ate)
{
    33dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    33e0:	2308      	movs	r3, #8
{
    33e2:	b085      	sub	sp, #20
    33e4:	460d      	mov	r5, r1
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    33e6:	6809      	ldr	r1, [r1, #0]
	int rc;
	struct nvs_ate close_ate, end_ate;
	u32_t data_end_addr, ate_end_addr;
	size_t ate_size;

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    33e8:	7c04      	ldrb	r4, [r0, #16]
{
    33ea:	4607      	mov	r7, r0
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    33ec:	f017 fa17 	bl	1a81e <nvs_flash_rd>

	rc = nvs_flash_ate_rd(fs, *addr, ate);
	if (rc) {
    33f0:	b968      	cbnz	r0, 340e <nvs_prev_ate+0x32>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    33f2:	2108      	movs	r1, #8
    33f4:	4620      	mov	r0, r4
    33f6:	f017 fa5d 	bl	1a8b4 <nvs_al_size.isra.1>
		return rc;
	}

	*addr += ate_size;
    33fa:	6829      	ldr	r1, [r5, #0]
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
    33fc:	89bb      	ldrh	r3, [r7, #12]
	*addr += ate_size;
    33fe:	4401      	add	r1, r0
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
    3400:	b28a      	uxth	r2, r1
    3402:	1a1b      	subs	r3, r3, r0
    3404:	429a      	cmp	r2, r3
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    3406:	4606      	mov	r6, r0
	*addr += ate_size;
    3408:	6029      	str	r1, [r5, #0]
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
    340a:	d003      	beq.n	3414 <nvs_prev_ate+0x38>
		return 0;
    340c:	2000      	movs	r0, #0
	/* remark: if there was absolutely no valid data in the sector *addr
	 * is kept at sector_end - 2*ate_size, the next read will contain
	 * invalid data and continue with a sector jump
	 */
	return 0;
}
    340e:	b005      	add	sp, #20
    3410:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (((*addr) >> ADDR_SECT_SHIFT) == 0U) {
    3414:	0c0b      	lsrs	r3, r1, #16
		*addr += ((fs->sector_count - 1) << ADDR_SECT_SHIFT);
    3416:	bf03      	ittte	eq
    3418:	89fb      	ldrheq	r3, [r7, #14]
    341a:	f103 33ff 	addeq.w	r3, r3, #4294967295	; 0xffffffff
    341e:	eb01 4103 	addeq.w	r1, r1, r3, lsl #16
		*addr -= (1 << ADDR_SECT_SHIFT);
    3422:	f5a1 3180 	subne.w	r1, r1, #65536	; 0x10000
    3426:	6029      	str	r1, [r5, #0]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    3428:	2308      	movs	r3, #8
    342a:	466a      	mov	r2, sp
    342c:	4638      	mov	r0, r7
    342e:	f017 f9f6 	bl	1a81e <nvs_flash_rd>
	if (rc) {
    3432:	2800      	cmp	r0, #0
    3434:	d1eb      	bne.n	340e <nvs_prev_ate+0x32>
    3436:	466a      	mov	r2, sp
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
    3438:	4603      	mov	r3, r0
		if (data8[i] != value) {
    343a:	f812 1b01 	ldrb.w	r1, [r2], #1
    343e:	29ff      	cmp	r1, #255	; 0xff
    3440:	d115      	bne.n	346e <nvs_prev_ate+0x92>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
    3442:	3301      	adds	r3, #1
    3444:	2b08      	cmp	r3, #8
    3446:	d1f8      	bne.n	343a <nvs_prev_ate+0x5e>
		*addr = fs->ate_wra;
    3448:	687b      	ldr	r3, [r7, #4]
    344a:	602b      	str	r3, [r5, #0]
		return 0;
    344c:	e7df      	b.n	340e <nvs_prev_ate+0x32>
		if (close_ate.offset < (fs->sector_size - ate_size) &&
    344e:	89ba      	ldrh	r2, [r7, #12]
    3450:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    3454:	1b92      	subs	r2, r2, r6
    3456:	4293      	cmp	r3, r2
    3458:	d20f      	bcs.n	347a <nvs_prev_ate+0x9e>
		    !(close_ate.offset % ate_size)) {
    345a:	fbb3 f2f6 	udiv	r2, r3, r6
    345e:	fb06 3212 	mls	r2, r6, r2, r3
		if (close_ate.offset < (fs->sector_size - ate_size) &&
    3462:	b952      	cbnz	r2, 347a <nvs_prev_ate+0x9e>
			(*addr) &= ADDR_SECT_MASK;
    3464:	0c24      	lsrs	r4, r4, #16
    3466:	0424      	lsls	r4, r4, #16
			(*addr) += close_ate.offset;
    3468:	441c      	add	r4, r3
    346a:	602c      	str	r4, [r5, #0]
			return 0;
    346c:	e7cf      	b.n	340e <nvs_prev_ate+0x32>
	if (!nvs_ate_crc8_check(&close_ate)) {
    346e:	4668      	mov	r0, sp
    3470:	f017 fa0b 	bl	1a88a <nvs_ate_crc8_check>
    3474:	682c      	ldr	r4, [r5, #0]
    3476:	2800      	cmp	r0, #0
    3478:	d0e9      	beq.n	344e <nvs_prev_ate+0x72>
	data_end_addr = *addr & ADDR_SECT_MASK;
    347a:	4b10      	ldr	r3, [pc, #64]	; (34bc <nvs_prev_ate+0xe0>)
	*addr -= ate_size;
    347c:	1ba4      	subs	r4, r4, r6
    347e:	602c      	str	r4, [r5, #0]
	data_end_addr = *addr & ADDR_SECT_MASK;
    3480:	ea04 0803 	and.w	r8, r4, r3
			data_end_addr &= ADDR_SECT_MASK;
    3484:	4699      	mov	r9, r3
	while (ate_end_addr > data_end_addr) {
    3486:	45a0      	cmp	r8, r4
    3488:	d2c0      	bcs.n	340c <nvs_prev_ate+0x30>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    348a:	2308      	movs	r3, #8
    348c:	eb0d 0203 	add.w	r2, sp, r3
    3490:	4621      	mov	r1, r4
    3492:	4638      	mov	r0, r7
    3494:	f017 f9c3 	bl	1a81e <nvs_flash_rd>
		if (rc) {
    3498:	2800      	cmp	r0, #0
    349a:	d1b8      	bne.n	340e <nvs_prev_ate+0x32>
		if (!nvs_ate_crc8_check(&end_ate)) {
    349c:	a802      	add	r0, sp, #8
    349e:	f017 f9f4 	bl	1a88a <nvs_ate_crc8_check>
    34a2:	b940      	cbnz	r0, 34b6 <nvs_prev_ate+0xda>
			data_end_addr += end_ate.offset + end_ate.len;
    34a4:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    34a8:	f8bd 200c 	ldrh.w	r2, [sp, #12]
			*addr = ate_end_addr;
    34ac:	602c      	str	r4, [r5, #0]
			data_end_addr &= ADDR_SECT_MASK;
    34ae:	ea08 0809 	and.w	r8, r8, r9
			data_end_addr += end_ate.offset + end_ate.len;
    34b2:	4413      	add	r3, r2
    34b4:	4498      	add	r8, r3
		ate_end_addr -= ate_size;
    34b6:	1ba4      	subs	r4, r4, r6
    34b8:	e7e5      	b.n	3486 <nvs_prev_ate+0xaa>
    34ba:	bf00      	nop
    34bc:	ffff0000 	.word	0xffff0000

000034c0 <nvs_gc>:
/* garbage collection: the address ate_wra has been updated to the new sector
 * that has just been started. The data to gc is in the sector after this new
 * sector.
 */
static int nvs_gc(struct nvs_fs *fs)
{
    34c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    34c4:	4604      	mov	r4, r0
    34c6:	b093      	sub	sp, #76	; 0x4c
	struct nvs_ate close_ate, gc_ate, wlk_ate;
	u32_t sec_addr, gc_addr, gc_prev_addr, wlk_addr, wlk_prev_addr,
	      data_addr, stop_addr;
	size_t ate_size;

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    34c8:	2108      	movs	r1, #8
    34ca:	7c00      	ldrb	r0, [r0, #16]
    34cc:	f017 f9f2 	bl	1a8b4 <nvs_al_size.isra.1>

	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
    34d0:	6863      	ldr	r3, [r4, #4]
    34d2:	0c1b      	lsrs	r3, r3, #16
    34d4:	041b      	lsls	r3, r3, #16
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    34d6:	4681      	mov	r9, r0
	nvs_sector_advance(fs, &sec_addr);
    34d8:	a901      	add	r1, sp, #4
    34da:	89e0      	ldrh	r0, [r4, #14]
	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
    34dc:	9301      	str	r3, [sp, #4]
	nvs_sector_advance(fs, &sec_addr);
    34de:	f017 f9f2 	bl	1a8c6 <nvs_sector_advance.isra.2>
	gc_addr = sec_addr + fs->sector_size - ate_size;
    34e2:	9b01      	ldr	r3, [sp, #4]
    34e4:	89a1      	ldrh	r1, [r4, #12]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    34e6:	ad04      	add	r5, sp, #16
	gc_addr = sec_addr + fs->sector_size - ate_size;
    34e8:	4419      	add	r1, r3
    34ea:	eba1 0109 	sub.w	r1, r1, r9
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    34ee:	462a      	mov	r2, r5
    34f0:	2308      	movs	r3, #8
    34f2:	4620      	mov	r0, r4
	gc_addr = sec_addr + fs->sector_size - ate_size;
    34f4:	9102      	str	r1, [sp, #8]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    34f6:	f017 f992 	bl	1a81e <nvs_flash_rd>

	/* if the sector is not closed don't do gc */
	rc = nvs_flash_ate_rd(fs, gc_addr, &close_ate);
	if (rc < 0) {
    34fa:	1e02      	subs	r2, r0, #0
    34fc:	db70      	blt.n	35e0 <nvs_gc+0x120>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
    34fe:	2300      	movs	r3, #0
		if (data8[i] != value) {
    3500:	5cea      	ldrb	r2, [r5, r3]
    3502:	2aff      	cmp	r2, #255	; 0xff
    3504:	d170      	bne.n	35e8 <nvs_gc+0x128>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
    3506:	3301      	adds	r3, #1
    3508:	2b08      	cmp	r3, #8
    350a:	d1f9      	bne.n	3500 <nvs_gc+0x40>
		return rc;
	}

	rc = nvs_ate_cmp_const(&close_ate, 0xff);
	if (!rc) {
		rc = nvs_flash_erase_sector(fs, sec_addr);
    350c:	9901      	ldr	r1, [sp, #4]
    350e:	4620      	mov	r0, r4
    3510:	f017 fa06 	bl	1a920 <nvs_flash_erase_sector>
    3514:	4602      	mov	r2, r0
		if (rc) {
    3516:	e063      	b.n	35e0 <nvs_gc+0x120>
		bytes_to_copy = MIN(block_size, len);
    3518:	4556      	cmp	r6, sl
    351a:	4635      	mov	r5, r6
    351c:	bf28      	it	cs
    351e:	4655      	movcs	r5, sl
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_copy);
    3520:	aa0a      	add	r2, sp, #40	; 0x28
    3522:	462b      	mov	r3, r5
    3524:	4639      	mov	r1, r7
    3526:	4620      	mov	r0, r4
    3528:	f017 f979 	bl	1a81e <nvs_flash_rd>
		if (rc) {
    352c:	4602      	mov	r2, r0
    352e:	2800      	cmp	r0, #0
    3530:	d156      	bne.n	35e0 <nvs_gc+0x120>
	if (!len) {
    3532:	b135      	cbz	r5, 3542 <nvs_gc+0x82>
    3534:	aa0a      	add	r2, sp, #40	; 0x28
    3536:	462b      	mov	r3, r5
    3538:	68a1      	ldr	r1, [r4, #8]
    353a:	4620      	mov	r0, r4
    353c:	f017 fa16 	bl	1a96c <nvs_flash_al_wrt.part.4>
    3540:	4602      	mov	r2, r0
	fs->data_wra += nvs_al_size(fs, len);
    3542:	4629      	mov	r1, r5
    3544:	7c20      	ldrb	r0, [r4, #16]
    3546:	f017 f9b5 	bl	1a8b4 <nvs_al_size.isra.1>
    354a:	68a3      	ldr	r3, [r4, #8]
    354c:	4418      	add	r0, r3
    354e:	60a0      	str	r0, [r4, #8]
		if (rc) {
    3550:	2a00      	cmp	r2, #0
    3552:	d145      	bne.n	35e0 <nvs_gc+0x120>
		len -= bytes_to_copy;
    3554:	ebaa 0a05 	sub.w	sl, sl, r5
		addr += bytes_to_copy;
    3558:	442f      	add	r7, r5
    355a:	e037      	b.n	35cc <nvs_gc+0x10c>
				return rc;
			}
		}

		/* stop gc at end of the sector */
		if (gc_prev_addr == stop_addr) {
    355c:	45d9      	cmp	r9, fp
    355e:	d0d5      	beq.n	350c <nvs_gc+0x4c>
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
    3560:	aa06      	add	r2, sp, #24
    3562:	a902      	add	r1, sp, #8
    3564:	4620      	mov	r0, r4
		gc_prev_addr = gc_addr;
    3566:	f8dd b008 	ldr.w	fp, [sp, #8]
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
    356a:	f7ff ff37 	bl	33dc <nvs_prev_ate>
		if (rc) {
    356e:	4602      	mov	r2, r0
    3570:	2800      	cmp	r0, #0
    3572:	d135      	bne.n	35e0 <nvs_gc+0x120>
		wlk_addr = fs->ate_wra;
    3574:	6863      	ldr	r3, [r4, #4]
    3576:	9303      	str	r3, [sp, #12]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    3578:	aa08      	add	r2, sp, #32
    357a:	a903      	add	r1, sp, #12
    357c:	4620      	mov	r0, r4
			wlk_prev_addr = wlk_addr;
    357e:	9d03      	ldr	r5, [sp, #12]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    3580:	f7ff ff2c 	bl	33dc <nvs_prev_ate>
			if (rc) {
    3584:	4602      	mov	r2, r0
    3586:	bb58      	cbnz	r0, 35e0 <nvs_gc+0x120>
			if ((wlk_ate.id == gc_ate.id) &&
    3588:	f8bd 2020 	ldrh.w	r2, [sp, #32]
    358c:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    3590:	429a      	cmp	r2, r3
    3592:	d1f1      	bne.n	3578 <nvs_gc+0xb8>
			    (!nvs_ate_crc8_check(&wlk_ate))) {
    3594:	a808      	add	r0, sp, #32
    3596:	f017 f978 	bl	1a88a <nvs_ate_crc8_check>
			if ((wlk_ate.id == gc_ate.id) &&
    359a:	2800      	cmp	r0, #0
    359c:	d1ec      	bne.n	3578 <nvs_gc+0xb8>
		if ((wlk_prev_addr == gc_prev_addr) && gc_ate.len) {
    359e:	455d      	cmp	r5, fp
    35a0:	d1dc      	bne.n	355c <nvs_gc+0x9c>
    35a2:	f8bd 301c 	ldrh.w	r3, [sp, #28]
    35a6:	2b00      	cmp	r3, #0
    35a8:	d0d8      	beq.n	355c <nvs_gc+0x9c>
			data_addr += gc_ate.offset;
    35aa:	f8bd 301a 	ldrh.w	r3, [sp, #26]
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
    35ae:	ea0b 0708 	and.w	r7, fp, r8
			data_addr += gc_ate.offset;
    35b2:	441f      	add	r7, r3
			nvs_ate_crc8_update(&gc_ate);
    35b4:	a806      	add	r0, sp, #24
			gc_ate.offset = (u16_t)(fs->data_wra & ADDR_OFFS_MASK);
    35b6:	68a3      	ldr	r3, [r4, #8]
    35b8:	f8ad 301a 	strh.w	r3, [sp, #26]
			nvs_ate_crc8_update(&gc_ate);
    35bc:	f017 f971 	bl	1a8a2 <nvs_ate_crc8_update>
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
    35c0:	7c26      	ldrb	r6, [r4, #16]
			rc = nvs_flash_block_move(fs, data_addr, gc_ate.len);
    35c2:	f8bd a01c 	ldrh.w	sl, [sp, #28]
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
    35c6:	4276      	negs	r6, r6
    35c8:	f006 0620 	and.w	r6, r6, #32
	while (len) {
    35cc:	f1ba 0f00 	cmp.w	sl, #0
    35d0:	d1a2      	bne.n	3518 <nvs_gc+0x58>
			rc = nvs_flash_ate_wrt(fs, &gc_ate);
    35d2:	a906      	add	r1, sp, #24
    35d4:	4620      	mov	r0, r4
    35d6:	f017 fa0d 	bl	1a9f4 <nvs_flash_ate_wrt>
			if (rc) {
    35da:	4602      	mov	r2, r0
    35dc:	2800      	cmp	r0, #0
    35de:	d0bd      	beq.n	355c <nvs_gc+0x9c>
	rc = nvs_flash_erase_sector(fs, sec_addr);
	if (rc) {
		return rc;
	}
	return 0;
}
    35e0:	4610      	mov	r0, r2
    35e2:	b013      	add	sp, #76	; 0x4c
    35e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	stop_addr = gc_addr - ate_size;
    35e8:	9b02      	ldr	r3, [sp, #8]
	gc_addr &= ADDR_SECT_MASK;
    35ea:	4a05      	ldr	r2, [pc, #20]	; (3600 <nvs_gc+0x140>)
	gc_addr += close_ate.offset;
    35ec:	f8bd 1012 	ldrh.w	r1, [sp, #18]
	stop_addr = gc_addr - ate_size;
    35f0:	eba3 0909 	sub.w	r9, r3, r9
	gc_addr &= ADDR_SECT_MASK;
    35f4:	4013      	ands	r3, r2
	gc_addr += close_ate.offset;
    35f6:	440b      	add	r3, r1
    35f8:	9302      	str	r3, [sp, #8]
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
    35fa:	4690      	mov	r8, r2
    35fc:	e7b0      	b.n	3560 <nvs_gc+0xa0>
    35fe:	bf00      	nop
    3600:	ffff0000 	.word	0xffff0000

00003604 <nvs_init>:
	}
	return 0;
}

int nvs_init(struct nvs_fs *fs, const char *dev_name)
{
    3604:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    3608:	4604      	mov	r4, r0
    360a:	b087      	sub	sp, #28
    360c:	460d      	mov	r5, r1

	int rc;
	struct flash_pages_info info;

	k_mutex_init(&fs->nvs_lock);
    360e:	f100 0614 	add.w	r6, r0, #20
	z_impl_k_mutex_init(mutex);
    3612:	4630      	mov	r0, r6
    3614:	f01a fe2f 	bl	1e276 <z_impl_k_mutex_init>
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    3618:	4628      	mov	r0, r5
    361a:	f014 f889 	bl	17730 <z_impl_device_get_binding>

	fs->flash_device = device_get_binding(dev_name);
    361e:	62a0      	str	r0, [r4, #40]	; 0x28
	if (!fs->flash_device) {
    3620:	b998      	cbnz	r0, 364a <nvs_init+0x46>
		LOG_ERR("No valid flash device found");
    3622:	2301      	movs	r3, #1
    3624:	f04f 0100 	mov.w	r1, #0
    3628:	f363 0107 	bfi	r1, r3, #0, #8
    362c:	4aa0      	ldr	r2, [pc, #640]	; (38b0 <nvs_init+0x2ac>)
    362e:	4ba1      	ldr	r3, [pc, #644]	; (38b4 <nvs_init+0x2b0>)
    3630:	48a1      	ldr	r0, [pc, #644]	; (38b8 <nvs_init+0x2b4>)
    3632:	1a9b      	subs	r3, r3, r2
    3634:	08db      	lsrs	r3, r3, #3
    3636:	f363 118f 	bfi	r1, r3, #6, #10
    363a:	f016 ffea 	bl	1a612 <log_0>
		return -ENXIO;
    363e:	f06f 0505 	mvn.w	r5, #5
	LOG_INF("data wra: %d, %x",
		(fs->data_wra >> ADDR_SECT_SHIFT),
		(fs->data_wra & ADDR_OFFS_MASK));

	return 0;
}
    3642:	4628      	mov	r0, r5
    3644:	b007      	add	sp, #28
    3646:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
static inline size_t z_impl_flash_get_write_block_size(struct device *dev)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->driver_api;

	return api->write_block_size;
    364a:	6843      	ldr	r3, [r0, #4]
	fs->write_block_size = flash_get_write_block_size(fs->flash_device);
    364c:	7d1b      	ldrb	r3, [r3, #20]
    364e:	7423      	strb	r3, [r4, #16]
	if (fs->write_block_size > NVS_BLOCK_SIZE) {
    3650:	2b20      	cmp	r3, #32
    3652:	d910      	bls.n	3676 <nvs_init+0x72>
		LOG_ERR("Unsupported write block size");
    3654:	2301      	movs	r3, #1
    3656:	f04f 0100 	mov.w	r1, #0
    365a:	f363 0107 	bfi	r1, r3, #0, #8
    365e:	4a94      	ldr	r2, [pc, #592]	; (38b0 <nvs_init+0x2ac>)
    3660:	4b94      	ldr	r3, [pc, #592]	; (38b4 <nvs_init+0x2b0>)
    3662:	4896      	ldr	r0, [pc, #600]	; (38bc <nvs_init+0x2b8>)
    3664:	1a9b      	subs	r3, r3, r2
    3666:	08db      	lsrs	r3, r3, #3
    3668:	f363 118f 	bfi	r1, r3, #6, #10
		LOG_ERR("Unable to get page info");
    366c:	f016 ffd1 	bl	1a612 <log_0>
		return -EINVAL;
    3670:	f06f 0515 	mvn.w	r5, #21
    3674:	e7e5      	b.n	3642 <nvs_init+0x3e>
	rc = flash_get_page_info_by_offs(fs->flash_device, fs->offset, &info);
    3676:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    3678:	6821      	ldr	r1, [r4, #0]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&dev, *(uintptr_t *)&offset, *(uintptr_t *)&info, K_SYSCALL_FLASH_GET_PAGE_INFO_BY_OFFS);
	}
#endif
	compiler_barrier();
	return z_impl_flash_get_page_info_by_offs(dev, offset, info);
    367a:	aa03      	add	r2, sp, #12
    367c:	f01a fcd3 	bl	1e026 <z_impl_flash_get_page_info_by_offs>
	if (rc) {
    3680:	b160      	cbz	r0, 369c <nvs_init+0x98>
		LOG_ERR("Unable to get page info");
    3682:	2301      	movs	r3, #1
    3684:	f04f 0100 	mov.w	r1, #0
    3688:	f363 0107 	bfi	r1, r3, #0, #8
    368c:	4a88      	ldr	r2, [pc, #544]	; (38b0 <nvs_init+0x2ac>)
    368e:	4b89      	ldr	r3, [pc, #548]	; (38b4 <nvs_init+0x2b0>)
    3690:	488b      	ldr	r0, [pc, #556]	; (38c0 <nvs_init+0x2bc>)
    3692:	1a9b      	subs	r3, r3, r2
    3694:	08db      	lsrs	r3, r3, #3
    3696:	f363 118f 	bfi	r1, r3, #6, #10
    369a:	e7e7      	b.n	366c <nvs_init+0x68>
	if (!fs->sector_size || fs->sector_size % info.size) {
    369c:	89a3      	ldrh	r3, [r4, #12]
    369e:	b12b      	cbz	r3, 36ac <nvs_init+0xa8>
    36a0:	9a04      	ldr	r2, [sp, #16]
    36a2:	fbb3 f5f2 	udiv	r5, r3, r2
    36a6:	fb02 3515 	mls	r5, r2, r5, r3
    36aa:	b165      	cbz	r5, 36c6 <nvs_init+0xc2>
		LOG_ERR("Invalid sector size");
    36ac:	2301      	movs	r3, #1
    36ae:	f04f 0100 	mov.w	r1, #0
    36b2:	f363 0107 	bfi	r1, r3, #0, #8
    36b6:	4a7e      	ldr	r2, [pc, #504]	; (38b0 <nvs_init+0x2ac>)
    36b8:	4b7e      	ldr	r3, [pc, #504]	; (38b4 <nvs_init+0x2b0>)
    36ba:	4882      	ldr	r0, [pc, #520]	; (38c4 <nvs_init+0x2c0>)
    36bc:	1a9b      	subs	r3, r3, r2
    36be:	08db      	lsrs	r3, r3, #3
    36c0:	f363 118f 	bfi	r1, r3, #6, #10
    36c4:	e7d2      	b.n	366c <nvs_init+0x68>
	if (fs->sector_count < 2) {
    36c6:	89e3      	ldrh	r3, [r4, #14]
    36c8:	2b01      	cmp	r3, #1
    36ca:	d80c      	bhi.n	36e6 <nvs_init+0xe2>
		LOG_ERR("Configuration error - sector count");
    36cc:	2301      	movs	r3, #1
    36ce:	f04f 0100 	mov.w	r1, #0
    36d2:	f363 0107 	bfi	r1, r3, #0, #8
    36d6:	4a76      	ldr	r2, [pc, #472]	; (38b0 <nvs_init+0x2ac>)
    36d8:	4b76      	ldr	r3, [pc, #472]	; (38b4 <nvs_init+0x2b0>)
    36da:	487b      	ldr	r0, [pc, #492]	; (38c8 <nvs_init+0x2c4>)
    36dc:	1a9b      	subs	r3, r3, r2
    36de:	08db      	lsrs	r3, r3, #3
    36e0:	f363 118f 	bfi	r1, r3, #6, #10
    36e4:	e7c2      	b.n	366c <nvs_init+0x68>
	u32_t addr = 0U;
    36e6:	9500      	str	r5, [sp, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
    36e8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    36ec:	4630      	mov	r0, r6
    36ee:	f014 fab5 	bl	17c5c <z_impl_k_mutex_lock>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    36f2:	2108      	movs	r1, #8
    36f4:	7c20      	ldrb	r0, [r4, #16]
    36f6:	f017 f8dd 	bl	1a8b4 <nvs_al_size.isra.1>
	u16_t i, closed_sectors = 0;
    36fa:	46a9      	mov	r9, r5
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    36fc:	4607      	mov	r7, r0
	for (i = 0; i < fs->sector_count; i++) {
    36fe:	89e3      	ldrh	r3, [r4, #14]
    3700:	fa1f f885 	uxth.w	r8, r5
    3704:	4543      	cmp	r3, r8
    3706:	d805      	bhi.n	3714 <nvs_init+0x110>
	if (closed_sectors == fs->sector_count) {
    3708:	89e3      	ldrh	r3, [r4, #14]
    370a:	454b      	cmp	r3, r9
    370c:	d11e      	bne.n	374c <nvs_init+0x148>
		return -EDEADLK;
    370e:	f06f 0520 	mvn.w	r5, #32
    3712:	e796      	b.n	3642 <nvs_init+0x3e>
		       (u16_t)(fs->sector_size - ate_size);
    3714:	89a1      	ldrh	r1, [r4, #12]
		addr = (i << ADDR_SECT_SHIFT) +
    3716:	042b      	lsls	r3, r5, #16
		       (u16_t)(fs->sector_size - ate_size);
    3718:	1bc9      	subs	r1, r1, r7
		addr = (i << ADDR_SECT_SHIFT) +
    371a:	fa13 f181 	uxtah	r1, r3, r1
		rc = nvs_flash_cmp_const(fs, addr, 0xff,
    371e:	2208      	movs	r2, #8
    3720:	4620      	mov	r0, r4
		addr = (i << ADDR_SECT_SHIFT) +
    3722:	9100      	str	r1, [sp, #0]
		rc = nvs_flash_cmp_const(fs, addr, 0xff,
    3724:	f017 f8d9 	bl	1a8da <nvs_flash_cmp_const.constprop.6>
		if (rc) {
    3728:	b170      	cbz	r0, 3748 <nvs_init+0x144>
			nvs_sector_advance(fs, &addr);
    372a:	4669      	mov	r1, sp
    372c:	89e0      	ldrh	r0, [r4, #14]
    372e:	f017 f8ca 	bl	1a8c6 <nvs_sector_advance.isra.2>
			closed_sectors++;
    3732:	f109 0901 	add.w	r9, r9, #1
			rc = nvs_flash_cmp_const(fs, addr, 0xff,
    3736:	2208      	movs	r2, #8
    3738:	9900      	ldr	r1, [sp, #0]
    373a:	4620      	mov	r0, r4
			closed_sectors++;
    373c:	fa1f f989 	uxth.w	r9, r9
			rc = nvs_flash_cmp_const(fs, addr, 0xff,
    3740:	f017 f8cb 	bl	1a8da <nvs_flash_cmp_const.constprop.6>
			if (!rc) {
    3744:	2800      	cmp	r0, #0
    3746:	d0df      	beq.n	3708 <nvs_init+0x104>
    3748:	3501      	adds	r5, #1
    374a:	e7d8      	b.n	36fe <nvs_init+0xfa>
	if (i == fs->sector_count) {
    374c:	4598      	cmp	r8, r3
    374e:	d10a      	bne.n	3766 <nvs_init+0x162>
		rc = nvs_flash_cmp_const(fs, addr - ate_size, 0xff,
    3750:	9900      	ldr	r1, [sp, #0]
    3752:	2208      	movs	r2, #8
    3754:	1bc9      	subs	r1, r1, r7
    3756:	4620      	mov	r0, r4
    3758:	f017 f8bf 	bl	1a8da <nvs_flash_cmp_const.constprop.6>
		if (!rc) {
    375c:	b918      	cbnz	r0, 3766 <nvs_init+0x162>
			nvs_sector_advance(fs, &addr);
    375e:	4669      	mov	r1, sp
    3760:	89e0      	ldrh	r0, [r4, #14]
    3762:	f017 f8b0 	bl	1a8c6 <nvs_sector_advance.isra.2>
	fs->ate_wra = addr - ate_size;
    3766:	9b00      	ldr	r3, [sp, #0]
    3768:	1bda      	subs	r2, r3, r7
    376a:	6062      	str	r2, [r4, #4]
	fs->data_wra = addr & ADDR_SECT_MASK;
    376c:	4a57      	ldr	r2, [pc, #348]	; (38cc <nvs_init+0x2c8>)
    376e:	4013      	ands	r3, r2
    3770:	60a3      	str	r3, [r4, #8]
			fs->data_wra = addr & ADDR_SECT_MASK;
    3772:	4690      	mov	r8, r2
	while (fs->ate_wra >= fs->data_wra) {
    3774:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
    3778:	4299      	cmp	r1, r3
    377a:	d30e      	bcc.n	379a <nvs_init+0x196>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    377c:	2308      	movs	r3, #8
    377e:	aa01      	add	r2, sp, #4
    3780:	4620      	mov	r0, r4
    3782:	f017 f84c 	bl	1a81e <nvs_flash_rd>
		if (rc) {
    3786:	4605      	mov	r5, r0
    3788:	bb18      	cbnz	r0, 37d2 <nvs_init+0x1ce>
    378a:	ab01      	add	r3, sp, #4
		if (data8[i] != value) {
    378c:	f813 2b01 	ldrb.w	r2, [r3], #1
    3790:	2aff      	cmp	r2, #255	; 0xff
    3792:	d175      	bne.n	3880 <nvs_init+0x27c>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
    3794:	3501      	adds	r5, #1
    3796:	2d08      	cmp	r5, #8
    3798:	d1f8      	bne.n	378c <nvs_init+0x188>
	while (fs->ate_wra > fs->data_wra) {
    379a:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
    379e:	428a      	cmp	r2, r1
    37a0:	d906      	bls.n	37b0 <nvs_init+0x1ac>
		rc = nvs_flash_cmp_const(fs, fs->data_wra, 0xff, empty_len);
    37a2:	1a52      	subs	r2, r2, r1
    37a4:	4620      	mov	r0, r4
    37a6:	f017 f898 	bl	1a8da <nvs_flash_cmp_const.constprop.6>
		if (rc < 0) {
    37aa:	1e05      	subs	r5, r0, #0
    37ac:	db11      	blt.n	37d2 <nvs_init+0x1ce>
		if (!rc) {
    37ae:	d14a      	bne.n	3846 <nvs_init+0x242>
	addr = fs->ate_wra & ADDR_SECT_MASK;
    37b0:	6863      	ldr	r3, [r4, #4]
    37b2:	f8df 8118 	ldr.w	r8, [pc, #280]	; 38cc <nvs_init+0x2c8>
	nvs_sector_advance(fs, &addr);
    37b6:	89e0      	ldrh	r0, [r4, #14]
	addr = fs->ate_wra & ADDR_SECT_MASK;
    37b8:	ea03 0308 	and.w	r3, r3, r8
	nvs_sector_advance(fs, &addr);
    37bc:	4669      	mov	r1, sp
	addr = fs->ate_wra & ADDR_SECT_MASK;
    37be:	9300      	str	r3, [sp, #0]
	nvs_sector_advance(fs, &addr);
    37c0:	f017 f881 	bl	1a8c6 <nvs_sector_advance.isra.2>
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
    37c4:	89a2      	ldrh	r2, [r4, #12]
    37c6:	9900      	ldr	r1, [sp, #0]
    37c8:	4620      	mov	r0, r4
    37ca:	f017 f886 	bl	1a8da <nvs_flash_cmp_const.constprop.6>
	if (rc < 0) {
    37ce:	1e05      	subs	r5, r0, #0
    37d0:	da3e      	bge.n	3850 <nvs_init+0x24c>
	z_impl_k_mutex_unlock(mutex);
    37d2:	4630      	mov	r0, r6
    37d4:	f014 fab4 	bl	17d40 <z_impl_k_mutex_unlock>
	if (rc) {
    37d8:	2d00      	cmp	r5, #0
    37da:	f47f af32 	bne.w	3642 <nvs_init+0x3e>
	fs->ready = true;
    37de:	2301      	movs	r3, #1
    37e0:	7463      	strb	r3, [r4, #17]
	LOG_INF("%d Sectors of %d bytes", fs->sector_count, fs->sector_size);
    37e2:	2203      	movs	r2, #3
    37e4:	f04f 0300 	mov.w	r3, #0
    37e8:	f362 0307 	bfi	r3, r2, #0, #8
    37ec:	4e31      	ldr	r6, [pc, #196]	; (38b4 <nvs_init+0x2b0>)
    37ee:	4a30      	ldr	r2, [pc, #192]	; (38b0 <nvs_init+0x2ac>)
    37f0:	89e1      	ldrh	r1, [r4, #14]
    37f2:	4837      	ldr	r0, [pc, #220]	; (38d0 <nvs_init+0x2cc>)
    37f4:	1ab6      	subs	r6, r6, r2
    37f6:	f3c6 06c9 	ubfx	r6, r6, #3, #10
    37fa:	f366 138f 	bfi	r3, r6, #6, #10
    37fe:	89a2      	ldrh	r2, [r4, #12]
    3800:	f016 ff28 	bl	1a654 <log_2>
	LOG_INF("alloc wra: %d, %x",
    3804:	6861      	ldr	r1, [r4, #4]
    3806:	4833      	ldr	r0, [pc, #204]	; (38d4 <nvs_init+0x2d0>)
    3808:	2203      	movs	r2, #3
    380a:	f04f 0300 	mov.w	r3, #0
    380e:	f362 0307 	bfi	r3, r2, #0, #8
    3812:	f366 138f 	bfi	r3, r6, #6, #10
    3816:	b28a      	uxth	r2, r1
    3818:	0c09      	lsrs	r1, r1, #16
    381a:	f016 ff1b 	bl	1a654 <log_2>
	LOG_INF("data wra: %d, %x",
    381e:	68a1      	ldr	r1, [r4, #8]
    3820:	482d      	ldr	r0, [pc, #180]	; (38d8 <nvs_init+0x2d4>)
    3822:	2203      	movs	r2, #3
    3824:	f04f 0300 	mov.w	r3, #0
    3828:	f362 0307 	bfi	r3, r2, #0, #8
    382c:	f366 138f 	bfi	r3, r6, #6, #10
    3830:	b28a      	uxth	r2, r1
    3832:	0c09      	lsrs	r1, r1, #16
    3834:	f016 ff0e 	bl	1a654 <log_2>
	return 0;
    3838:	e703      	b.n	3642 <nvs_init+0x3e>
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
    383a:	f1b9 0f00 	cmp.w	r9, #0
    383e:	d034      	beq.n	38aa <nvs_init+0x2a6>
				return -ESPIPE;
    3840:	f06f 051c 	mvn.w	r5, #28
    3844:	e6fd      	b.n	3642 <nvs_init+0x3e>
		fs->data_wra += fs->write_block_size;
    3846:	68a3      	ldr	r3, [r4, #8]
    3848:	7c22      	ldrb	r2, [r4, #16]
    384a:	4413      	add	r3, r2
    384c:	60a3      	str	r3, [r4, #8]
    384e:	e7a4      	b.n	379a <nvs_init+0x196>
	if (rc) {
    3850:	d0bf      	beq.n	37d2 <nvs_init+0x1ce>
		rc = nvs_flash_erase_sector(fs, fs->ate_wra);
    3852:	6861      	ldr	r1, [r4, #4]
    3854:	4620      	mov	r0, r4
    3856:	f017 f863 	bl	1a920 <nvs_flash_erase_sector>
		if (rc) {
    385a:	4605      	mov	r5, r0
    385c:	2800      	cmp	r0, #0
    385e:	d1b8      	bne.n	37d2 <nvs_init+0x1ce>
		fs->ate_wra &= ADDR_SECT_MASK;
    3860:	6860      	ldr	r0, [r4, #4]
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
    3862:	89a3      	ldrh	r3, [r4, #12]
		fs->ate_wra &= ADDR_SECT_MASK;
    3864:	ea00 0008 	and.w	r0, r0, r8
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
    3868:	4418      	add	r0, r3
    386a:	eba0 0047 	sub.w	r0, r0, r7, lsl #1
    386e:	6060      	str	r0, [r4, #4]
		fs->data_wra = (fs->ate_wra & ADDR_SECT_MASK);
    3870:	ea00 0008 	and.w	r0, r0, r8
    3874:	60a0      	str	r0, [r4, #8]
		rc = nvs_gc(fs);
    3876:	4620      	mov	r0, r4
    3878:	f7ff fe22 	bl	34c0 <nvs_gc>
    387c:	4605      	mov	r5, r0
		if (rc) {
    387e:	e7a8      	b.n	37d2 <nvs_init+0x1ce>
		if (!nvs_ate_crc8_check(&last_ate)) {
    3880:	a801      	add	r0, sp, #4
    3882:	f017 f802 	bl	1a88a <nvs_ate_crc8_check>
    3886:	6865      	ldr	r5, [r4, #4]
    3888:	b978      	cbnz	r0, 38aa <nvs_init+0x2a6>
			fs->data_wra = addr & ADDR_SECT_MASK;
    388a:	9800      	ldr	r0, [sp, #0]
			fs->data_wra += last_ate.offset;
    388c:	f8bd 2006 	ldrh.w	r2, [sp, #6]
			fs->data_wra += nvs_al_size(fs, last_ate.len);
    3890:	f8bd 9008 	ldrh.w	r9, [sp, #8]
			fs->data_wra = addr & ADDR_SECT_MASK;
    3894:	ea00 0008 	and.w	r0, r0, r8
			fs->data_wra += last_ate.offset;
    3898:	4402      	add	r2, r0
			fs->data_wra += nvs_al_size(fs, last_ate.len);
    389a:	4649      	mov	r1, r9
    389c:	7c20      	ldrb	r0, [r4, #16]
    389e:	f017 f809 	bl	1a8b4 <nvs_al_size.isra.1>
    38a2:	4410      	add	r0, r2
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
    38a4:	42a8      	cmp	r0, r5
			fs->data_wra += nvs_al_size(fs, last_ate.len);
    38a6:	60a0      	str	r0, [r4, #8]
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
    38a8:	d0c7      	beq.n	383a <nvs_init+0x236>
		fs->ate_wra -= ate_size;
    38aa:	1bed      	subs	r5, r5, r7
    38ac:	6065      	str	r5, [r4, #4]
    38ae:	e761      	b.n	3774 <nvs_init+0x170>
    38b0:	0001ed28 	.word	0x0001ed28
    38b4:	0001ee28 	.word	0x0001ee28
    38b8:	0001fb2b 	.word	0x0001fb2b
    38bc:	0001fb47 	.word	0x0001fb47
    38c0:	0001fb64 	.word	0x0001fb64
    38c4:	0001fb7c 	.word	0x0001fb7c
    38c8:	0001fb90 	.word	0x0001fb90
    38cc:	ffff0000 	.word	0xffff0000
    38d0:	0001fbb3 	.word	0x0001fbb3
    38d4:	0001fbca 	.word	0x0001fbca
    38d8:	0001fbdc 	.word	0x0001fbdc

000038dc <nvs_write>:

ssize_t nvs_write(struct nvs_fs *fs, u16_t id, const void *data, size_t len)
{
    38dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    38e0:	461e      	mov	r6, r3
	struct nvs_ate wlk_ate;
	u32_t wlk_addr, rd_addr;
	u16_t required_space = 0U; /* no space, appropriate for delete ate */
	bool prev_found = false;

	if (!fs->ready) {
    38e2:	7c43      	ldrb	r3, [r0, #17]
{
    38e4:	b089      	sub	sp, #36	; 0x24
    38e6:	4604      	mov	r4, r0
    38e8:	4689      	mov	r9, r1
    38ea:	4690      	mov	r8, r2
	if (!fs->ready) {
    38ec:	b99b      	cbnz	r3, 3916 <nvs_write+0x3a>
		LOG_ERR("NVS not initialized");
    38ee:	2301      	movs	r3, #1
    38f0:	f04f 0100 	mov.w	r1, #0
    38f4:	f363 0107 	bfi	r1, r3, #0, #8
    38f8:	4a67      	ldr	r2, [pc, #412]	; (3a98 <nvs_write+0x1bc>)
    38fa:	4b68      	ldr	r3, [pc, #416]	; (3a9c <nvs_write+0x1c0>)
    38fc:	4868      	ldr	r0, [pc, #416]	; (3aa0 <nvs_write+0x1c4>)
    38fe:	1a9b      	subs	r3, r3, r2
    3900:	08db      	lsrs	r3, r3, #3
    3902:	f363 118f 	bfi	r1, r3, #6, #10
    3906:	f016 fe84 	bl	1a612 <log_0>
		return -EACCES;
    390a:	f06f 050c 	mvn.w	r5, #12
	}
	rc = len;
end:
	k_mutex_unlock(&fs->nvs_lock);
	return rc;
}
    390e:	4628      	mov	r0, r5
    3910:	b009      	add	sp, #36	; 0x24
    3912:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    3916:	f890 a010 	ldrb.w	sl, [r0, #16]
    391a:	2108      	movs	r1, #8
    391c:	4650      	mov	r0, sl
    391e:	f016 ffc9 	bl	1a8b4 <nvs_al_size.isra.1>
	if ((len > (fs->sector_size - 3 * ate_size)) ||
    3922:	89a3      	ldrh	r3, [r4, #12]
    3924:	eb00 0240 	add.w	r2, r0, r0, lsl #1
    3928:	1a9b      	subs	r3, r3, r2
    392a:	42b3      	cmp	r3, r6
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    392c:	4607      	mov	r7, r0
	if ((len > (fs->sector_size - 3 * ate_size)) ||
    392e:	f0c0 80ae 	bcc.w	3a8e <nvs_write+0x1b2>
    3932:	b11e      	cbz	r6, 393c <nvs_write+0x60>
	    ((len > 0) && (data == NULL))) {
    3934:	f1b8 0f00 	cmp.w	r8, #0
    3938:	f000 80a9 	beq.w	3a8e <nvs_write+0x1b2>
	wlk_addr = fs->ate_wra;
    393c:	6863      	ldr	r3, [r4, #4]
    393e:	9303      	str	r3, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    3940:	aa04      	add	r2, sp, #16
    3942:	a903      	add	r1, sp, #12
    3944:	4620      	mov	r0, r4
		rd_addr = wlk_addr;
    3946:	f8dd b00c 	ldr.w	fp, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    394a:	f7ff fd47 	bl	33dc <nvs_prev_ate>
		if (rc) {
    394e:	4605      	mov	r5, r0
    3950:	2800      	cmp	r0, #0
    3952:	d1dc      	bne.n	390e <nvs_write+0x32>
		if ((wlk_ate.id == id) && (!nvs_ate_crc8_check(&wlk_ate))) {
    3954:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    3958:	454b      	cmp	r3, r9
    395a:	d005      	beq.n	3968 <nvs_write+0x8c>
		if (wlk_addr == fs->ate_wra) {
    395c:	6862      	ldr	r2, [r4, #4]
    395e:	9b03      	ldr	r3, [sp, #12]
    3960:	429a      	cmp	r2, r3
    3962:	d1ed      	bne.n	3940 <nvs_write+0x64>
		if (len == 0) {
    3964:	b9de      	cbnz	r6, 399e <nvs_write+0xc2>
    3966:	e7d2      	b.n	390e <nvs_write+0x32>
		if ((wlk_ate.id == id) && (!nvs_ate_crc8_check(&wlk_ate))) {
    3968:	a804      	add	r0, sp, #16
    396a:	f016 ff8e 	bl	1a88a <nvs_ate_crc8_check>
    396e:	2800      	cmp	r0, #0
    3970:	d1f4      	bne.n	395c <nvs_write+0x80>
		if (len == 0) {
    3972:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    3976:	b186      	cbz	r6, 399a <nvs_write+0xbe>
		} else if (len == wlk_ate.len) {
    3978:	42b3      	cmp	r3, r6
    397a:	d110      	bne.n	399e <nvs_write+0xc2>
		rd_addr += wlk_ate.offset;
    397c:	f8bd 0012 	ldrh.w	r0, [sp, #18]
		rd_addr &= ADDR_SECT_MASK;
    3980:	ea4f 411b 	mov.w	r1, fp, lsr #16
    3984:	0409      	lsls	r1, r1, #16
			rc = nvs_flash_block_cmp(fs, rd_addr, data, len);
    3986:	4401      	add	r1, r0
    3988:	4633      	mov	r3, r6
    398a:	4642      	mov	r2, r8
    398c:	4620      	mov	r0, r4
    398e:	f016 ff54 	bl	1a83a <nvs_flash_block_cmp>
			if (rc <= 0) {
    3992:	2800      	cmp	r0, #0
    3994:	dc03      	bgt.n	399e <nvs_write+0xc2>
    3996:	4605      	mov	r5, r0
    3998:	e7b9      	b.n	390e <nvs_write+0x32>
			if (wlk_ate.len == 0U) {
    399a:	2b00      	cmp	r3, #0
    399c:	d0b7      	beq.n	390e <nvs_write+0x32>
	data_size = nvs_al_size(fs, len);
    399e:	4631      	mov	r1, r6
    39a0:	4650      	mov	r0, sl
    39a2:	f016 ff87 	bl	1a8b4 <nvs_al_size.isra.1>
	if (data_size) {
    39a6:	2800      	cmp	r0, #0
    39a8:	d13e      	bne.n	3a28 <nvs_write+0x14c>
	u16_t required_space = 0U; /* no space, appropriate for delete ate */
    39aa:	4607      	mov	r7, r0
	k_mutex_lock(&fs->nvs_lock, K_FOREVER);
    39ac:	f104 0a14 	add.w	sl, r4, #20
	return z_impl_k_mutex_lock(mutex, timeout);
    39b0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    39b4:	4650      	mov	r0, sl
	fs->ate_wra &= ADDR_SECT_MASK;
    39b6:	f8df b0ec 	ldr.w	fp, [pc, #236]	; 3aa4 <nvs_write+0x1c8>
    39ba:	f014 f94f 	bl	17c5c <z_impl_k_mutex_lock>
	gc_count = 0;
    39be:	2300      	movs	r3, #0
		if (gc_count == fs->sector_count) {
    39c0:	89e2      	ldrh	r2, [r4, #14]
    39c2:	4293      	cmp	r3, r2
    39c4:	d060      	beq.n	3a88 <nvs_write+0x1ac>
		if (fs->ate_wra >= fs->data_wra + required_space) {
    39c6:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
    39ca:	1878      	adds	r0, r7, r1
    39cc:	4282      	cmp	r2, r0
    39ce:	d32e      	bcc.n	3a2e <nvs_write+0x152>
	entry.part = 0xff;
    39d0:	23ff      	movs	r3, #255	; 0xff
	nvs_ate_crc8_update(&entry);
    39d2:	a806      	add	r0, sp, #24
	entry.id = id;
    39d4:	f8ad 9018 	strh.w	r9, [sp, #24]
	entry.offset = (u16_t)(fs->data_wra & ADDR_OFFS_MASK);
    39d8:	f8ad 101a 	strh.w	r1, [sp, #26]
	entry.len = (u16_t)len;
    39dc:	f8ad 601c 	strh.w	r6, [sp, #28]
	entry.part = 0xff;
    39e0:	f88d 301e 	strb.w	r3, [sp, #30]
	nvs_ate_crc8_update(&entry);
    39e4:	f016 ff5d 	bl	1a8a2 <nvs_ate_crc8_update>
	if (!len) {
    39e8:	b136      	cbz	r6, 39f8 <nvs_write+0x11c>
    39ea:	4633      	mov	r3, r6
    39ec:	4642      	mov	r2, r8
    39ee:	68a1      	ldr	r1, [r4, #8]
    39f0:	4620      	mov	r0, r4
    39f2:	f016 ffbb 	bl	1a96c <nvs_flash_al_wrt.part.4>
    39f6:	4605      	mov	r5, r0
	fs->data_wra += nvs_al_size(fs, len);
    39f8:	4631      	mov	r1, r6
    39fa:	7c20      	ldrb	r0, [r4, #16]
    39fc:	f016 ff5a 	bl	1a8b4 <nvs_al_size.isra.1>
    3a00:	68a3      	ldr	r3, [r4, #8]
    3a02:	4418      	add	r0, r3
    3a04:	60a0      	str	r0, [r4, #8]
	if (rc) {
    3a06:	2d00      	cmp	r5, #0
    3a08:	d144      	bne.n	3a94 <nvs_write+0x1b8>
	rc = nvs_flash_ate_wrt(fs, &entry);
    3a0a:	a906      	add	r1, sp, #24
    3a0c:	4620      	mov	r0, r4
    3a0e:	f016 fff1 	bl	1a9f4 <nvs_flash_ate_wrt>
	if (rc) {
    3a12:	4605      	mov	r5, r0
    3a14:	2800      	cmp	r0, #0
    3a16:	d13d      	bne.n	3a94 <nvs_write+0x1b8>
	rc = len;
    3a18:	4632      	mov	r2, r6
    3a1a:	9201      	str	r2, [sp, #4]
	z_impl_k_mutex_unlock(mutex);
    3a1c:	4650      	mov	r0, sl
    3a1e:	f014 f98f 	bl	17d40 <z_impl_k_mutex_unlock>
	return rc;
    3a22:	9a01      	ldr	r2, [sp, #4]
    3a24:	4615      	mov	r5, r2
    3a26:	e772      	b.n	390e <nvs_write+0x32>
		required_space = data_size + ate_size;
    3a28:	4407      	add	r7, r0
    3a2a:	b2bf      	uxth	r7, r7
    3a2c:	e7be      	b.n	39ac <nvs_write+0xd0>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    3a2e:	2108      	movs	r1, #8
    3a30:	7c20      	ldrb	r0, [r4, #16]
    3a32:	9301      	str	r3, [sp, #4]
    3a34:	f016 ff3e 	bl	1a8b4 <nvs_al_size.isra.1>
	close_ate.id = 0xFFFF;
    3a38:	f64f 71ff 	movw	r1, #65535	; 0xffff
    3a3c:	f8ad 1018 	strh.w	r1, [sp, #24]
	close_ate.len = 0U;
    3a40:	2100      	movs	r1, #0
    3a42:	f8ad 101c 	strh.w	r1, [sp, #28]
	close_ate.offset = (u16_t)((fs->ate_wra + ate_size) & ADDR_OFFS_MASK);
    3a46:	1811      	adds	r1, r2, r0
    3a48:	f8ad 101a 	strh.w	r1, [sp, #26]
	fs->ate_wra += (fs->sector_size - ate_size);
    3a4c:	89a1      	ldrh	r1, [r4, #12]
	fs->ate_wra &= ADDR_SECT_MASK;
    3a4e:	ea02 020b 	and.w	r2, r2, fp
	fs->ate_wra += (fs->sector_size - ate_size);
    3a52:	440a      	add	r2, r1
    3a54:	1a12      	subs	r2, r2, r0
    3a56:	6062      	str	r2, [r4, #4]
	nvs_ate_crc8_update(&close_ate);
    3a58:	a806      	add	r0, sp, #24
    3a5a:	f016 ff22 	bl	1a8a2 <nvs_ate_crc8_update>
	rc = nvs_flash_ate_wrt(fs, &close_ate);
    3a5e:	a906      	add	r1, sp, #24
    3a60:	4620      	mov	r0, r4
    3a62:	f016 ffc7 	bl	1a9f4 <nvs_flash_ate_wrt>
	nvs_sector_advance(fs, &fs->ate_wra);
    3a66:	1d21      	adds	r1, r4, #4
    3a68:	89e0      	ldrh	r0, [r4, #14]
    3a6a:	f016 ff2c 	bl	1a8c6 <nvs_sector_advance.isra.2>
	fs->data_wra = fs->ate_wra & ADDR_SECT_MASK;
    3a6e:	6862      	ldr	r2, [r4, #4]
    3a70:	ea02 020b 	and.w	r2, r2, fp
    3a74:	60a2      	str	r2, [r4, #8]
		rc = nvs_gc(fs);
    3a76:	4620      	mov	r0, r4
    3a78:	f7ff fd22 	bl	34c0 <nvs_gc>
		if (rc) {
    3a7c:	4602      	mov	r2, r0
    3a7e:	2800      	cmp	r0, #0
    3a80:	d1cb      	bne.n	3a1a <nvs_write+0x13e>
		gc_count++;
    3a82:	9b01      	ldr	r3, [sp, #4]
    3a84:	3301      	adds	r3, #1
		if (gc_count == fs->sector_count) {
    3a86:	e79b      	b.n	39c0 <nvs_write+0xe4>
			rc = -ENOSPC;
    3a88:	f06f 021b 	mvn.w	r2, #27
    3a8c:	e7c5      	b.n	3a1a <nvs_write+0x13e>
		return -EINVAL;
    3a8e:	f06f 0515 	mvn.w	r5, #21
    3a92:	e73c      	b.n	390e <nvs_write+0x32>
			if (rc) {
    3a94:	462a      	mov	r2, r5
    3a96:	e7c0      	b.n	3a1a <nvs_write+0x13e>
    3a98:	0001ed28 	.word	0x0001ed28
    3a9c:	0001ee28 	.word	0x0001ee28
    3aa0:	0001fb17 	.word	0x0001fb17
    3aa4:	ffff0000 	.word	0xffff0000

00003aa8 <nvs_read_hist>:
	return nvs_write(fs, id, NULL, 0);
}

ssize_t nvs_read_hist(struct nvs_fs *fs, u16_t id, void *data, size_t len,
		      u16_t cnt)
{
    3aa8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    3aac:	461f      	mov	r7, r3
	u32_t wlk_addr, rd_addr;
	u16_t cnt_his;
	struct nvs_ate wlk_ate;
	size_t ate_size;

	if (!fs->ready) {
    3aae:	7c43      	ldrb	r3, [r0, #17]
{
    3ab0:	f8bd 8030 	ldrh.w	r8, [sp, #48]	; 0x30
    3ab4:	4604      	mov	r4, r0
    3ab6:	468a      	mov	sl, r1
    3ab8:	4691      	mov	r9, r2
	if (!fs->ready) {
    3aba:	b993      	cbnz	r3, 3ae2 <nvs_read_hist+0x3a>
		LOG_ERR("NVS not initialized");
    3abc:	2301      	movs	r3, #1
    3abe:	f04f 0100 	mov.w	r1, #0
    3ac2:	f363 0107 	bfi	r1, r3, #0, #8
    3ac6:	4a29      	ldr	r2, [pc, #164]	; (3b6c <nvs_read_hist+0xc4>)
    3ac8:	4b29      	ldr	r3, [pc, #164]	; (3b70 <nvs_read_hist+0xc8>)
    3aca:	482a      	ldr	r0, [pc, #168]	; (3b74 <nvs_read_hist+0xcc>)
    3acc:	1a9b      	subs	r3, r3, r2
    3ace:	08db      	lsrs	r3, r3, #3
    3ad0:	f363 118f 	bfi	r1, r3, #6, #10
    3ad4:	f016 fd9d 	bl	1a612 <log_0>
		return -EACCES;
    3ad8:	f06f 000c 	mvn.w	r0, #12

	return wlk_ate.len;

err:
	return rc;
}
    3adc:	b004      	add	sp, #16
    3ade:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    3ae2:	2108      	movs	r1, #8
    3ae4:	7c00      	ldrb	r0, [r0, #16]
    3ae6:	f016 fee5 	bl	1a8b4 <nvs_al_size.isra.1>
	if (len > (fs->sector_size - 2 * ate_size)) {
    3aea:	89a3      	ldrh	r3, [r4, #12]
    3aec:	eba3 0040 	sub.w	r0, r3, r0, lsl #1
    3af0:	42b8      	cmp	r0, r7
    3af2:	d338      	bcc.n	3b66 <nvs_read_hist+0xbe>
	wlk_addr = fs->ate_wra;
    3af4:	6863      	ldr	r3, [r4, #4]
    3af6:	9301      	str	r3, [sp, #4]
	cnt_his = 0U;
    3af8:	2500      	movs	r5, #0
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    3afa:	aa02      	add	r2, sp, #8
    3afc:	a901      	add	r1, sp, #4
    3afe:	4620      	mov	r0, r4
		rd_addr = wlk_addr;
    3b00:	9e01      	ldr	r6, [sp, #4]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    3b02:	f7ff fc6b 	bl	33dc <nvs_prev_ate>
		if (rc) {
    3b06:	2800      	cmp	r0, #0
    3b08:	d1e8      	bne.n	3adc <nvs_read_hist+0x34>
		if ((wlk_ate.id == id) &&  (!nvs_ate_crc8_check(&wlk_ate))) {
    3b0a:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    3b0e:	4553      	cmp	r3, sl
    3b10:	d105      	bne.n	3b1e <nvs_read_hist+0x76>
    3b12:	a802      	add	r0, sp, #8
    3b14:	f016 feb9 	bl	1a88a <nvs_ate_crc8_check>
    3b18:	b908      	cbnz	r0, 3b1e <nvs_read_hist+0x76>
			cnt_his++;
    3b1a:	3501      	adds	r5, #1
    3b1c:	b2ad      	uxth	r5, r5
		if (wlk_addr == fs->ate_wra) {
    3b1e:	6862      	ldr	r2, [r4, #4]
    3b20:	9b01      	ldr	r3, [sp, #4]
    3b22:	429a      	cmp	r2, r3
    3b24:	d018      	beq.n	3b58 <nvs_read_hist+0xb0>
	while (cnt_his <= cnt) {
    3b26:	4545      	cmp	r5, r8
    3b28:	d9e7      	bls.n	3afa <nvs_read_hist+0x52>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
    3b2a:	f8bd 300c 	ldrh.w	r3, [sp, #12]
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
    3b2e:	b1bb      	cbz	r3, 3b60 <nvs_read_hist+0xb8>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
    3b30:	4545      	cmp	r5, r8
    3b32:	d315      	bcc.n	3b60 <nvs_read_hist+0xb8>
	rd_addr += wlk_ate.offset;
    3b34:	f8bd 000a 	ldrh.w	r0, [sp, #10]
	rd_addr &= ADDR_SECT_MASK;
    3b38:	0c31      	lsrs	r1, r6, #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
    3b3a:	42bb      	cmp	r3, r7
	rd_addr &= ADDR_SECT_MASK;
    3b3c:	ea4f 4101 	mov.w	r1, r1, lsl #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
    3b40:	bf28      	it	cs
    3b42:	463b      	movcs	r3, r7
    3b44:	4401      	add	r1, r0
    3b46:	464a      	mov	r2, r9
    3b48:	4620      	mov	r0, r4
    3b4a:	f016 fe68 	bl	1a81e <nvs_flash_rd>
	if (rc) {
    3b4e:	2800      	cmp	r0, #0
    3b50:	d1c4      	bne.n	3adc <nvs_read_hist+0x34>
	return wlk_ate.len;
    3b52:	f8bd 000c 	ldrh.w	r0, [sp, #12]
    3b56:	e7c1      	b.n	3adc <nvs_read_hist+0x34>
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
    3b58:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    3b5c:	4553      	cmp	r3, sl
    3b5e:	d0e4      	beq.n	3b2a <nvs_read_hist+0x82>
		return -ENOENT;
    3b60:	f06f 0001 	mvn.w	r0, #1
    3b64:	e7ba      	b.n	3adc <nvs_read_hist+0x34>
		return -EINVAL;
    3b66:	f06f 0015 	mvn.w	r0, #21
    3b6a:	e7b7      	b.n	3adc <nvs_read_hist+0x34>
    3b6c:	0001ed28 	.word	0x0001ed28
    3b70:	0001ee28 	.word	0x0001ee28
    3b74:	0001fb17 	.word	0x0001fb17

00003b78 <get_flash_area_from_id>:
extern const struct flash_area *flash_map;
extern const int flash_map_entries;

static struct flash_area const *get_flash_area_from_id(int idx)
{
	for (int i = 0; i < flash_map_entries; i++) {
    3b78:	4b08      	ldr	r3, [pc, #32]	; (3b9c <get_flash_area_from_id+0x24>)
{
    3b7a:	b530      	push	{r4, r5, lr}
	for (int i = 0; i < flash_map_entries; i++) {
    3b7c:	681d      	ldr	r5, [r3, #0]
		if (flash_map[i].fa_id == idx) {
    3b7e:	4b08      	ldr	r3, [pc, #32]	; (3ba0 <get_flash_area_from_id+0x28>)
    3b80:	6819      	ldr	r1, [r3, #0]
	for (int i = 0; i < flash_map_entries; i++) {
    3b82:	2300      	movs	r3, #0
    3b84:	429d      	cmp	r5, r3
    3b86:	dc02      	bgt.n	3b8e <get_flash_area_from_id+0x16>
			return &flash_map[i];
		}
	}

	return NULL;
    3b88:	2200      	movs	r2, #0
}
    3b8a:	4610      	mov	r0, r2
    3b8c:	bd30      	pop	{r4, r5, pc}
		if (flash_map[i].fa_id == idx) {
    3b8e:	011c      	lsls	r4, r3, #4
    3b90:	190a      	adds	r2, r1, r4
    3b92:	5d0c      	ldrb	r4, [r1, r4]
    3b94:	4284      	cmp	r4, r0
    3b96:	d0f8      	beq.n	3b8a <get_flash_area_from_id+0x12>
	for (int i = 0; i < flash_map_entries; i++) {
    3b98:	3301      	adds	r3, #1
    3b9a:	e7f3      	b.n	3b84 <get_flash_area_from_id+0xc>
    3b9c:	0001f190 	.word	0x0001f190
    3ba0:	2000562c 	.word	0x2000562c

00003ba4 <flash_area_open>:

int flash_area_open(u8_t id, const struct flash_area **fap)
{
	const struct flash_area *area;

	if (flash_map == NULL) {
    3ba4:	4b08      	ldr	r3, [pc, #32]	; (3bc8 <flash_area_open+0x24>)
    3ba6:	681b      	ldr	r3, [r3, #0]
{
    3ba8:	b510      	push	{r4, lr}
    3baa:	460c      	mov	r4, r1
	if (flash_map == NULL) {
    3bac:	b12b      	cbz	r3, 3bba <flash_area_open+0x16>
		return -EACCES;
	}

	area = get_flash_area_from_id(id);
    3bae:	f7ff ffe3 	bl	3b78 <get_flash_area_from_id>
	if (area == NULL) {
    3bb2:	b128      	cbz	r0, 3bc0 <flash_area_open+0x1c>
		return -ENOENT;
	}

	*fap = area;
    3bb4:	6020      	str	r0, [r4, #0]
	return 0;
    3bb6:	2000      	movs	r0, #0
}
    3bb8:	bd10      	pop	{r4, pc}
		return -EACCES;
    3bba:	f06f 000c 	mvn.w	r0, #12
    3bbe:	e7fb      	b.n	3bb8 <flash_area_open+0x14>
		return -ENOENT;
    3bc0:	f06f 0001 	mvn.w	r0, #1
    3bc4:	e7f8      	b.n	3bb8 <flash_area_open+0x14>
    3bc6:	bf00      	nop
    3bc8:	2000562c 	.word	0x2000562c

00003bcc <flash_area_get_sectors>:

	return true;
}

int flash_area_get_sectors(int idx, u32_t *cnt, struct flash_sector *ret)
{
    3bcc:	b530      	push	{r4, r5, lr}
    3bce:	b089      	sub	sp, #36	; 0x24
    3bd0:	460c      	mov	r4, r1
    3bd2:	4615      	mov	r5, r2
	cb_data->area_idx = idx;
    3bd4:	9001      	str	r0, [sp, #4]
	fa = get_flash_area_from_id(idx);
    3bd6:	f7ff ffcf 	bl	3b78 <get_flash_area_from_id>
	if (fa == NULL) {
    3bda:	b1b8      	cbz	r0, 3c0c <flash_area_get_sectors+0x40>
	cb_data->area_off = fa->fa_off;
    3bdc:	6843      	ldr	r3, [r0, #4]
    3bde:	9302      	str	r3, [sp, #8]
	cb_data->area_len = fa->fa_size;
    3be0:	6883      	ldr	r3, [r0, #8]
	cb_data->ret_len = *cnt;
    3be2:	6822      	ldr	r2, [r4, #0]
	flash_dev = device_get_binding(fa->fa_dev_name);
    3be4:	68c0      	ldr	r0, [r0, #12]
	cb_data->ret = ret;
    3be6:	e9cd 3503 	strd	r3, r5, [sp, #12]
	cb_data->ret_idx = 0U;
    3bea:	2300      	movs	r3, #0
    3bec:	9305      	str	r3, [sp, #20]
	cb_data->status = 0;
    3bee:	e9cd 2306 	strd	r2, r3, [sp, #24]
    3bf2:	f013 fd9d 	bl	17730 <z_impl_device_get_binding>
	if (flash_dev == NULL) {
    3bf6:	b160      	cbz	r0, 3c12 <flash_area_get_sectors+0x46>
	flash_page_foreach(flash_dev, cb, cb_data);
    3bf8:	aa01      	add	r2, sp, #4
    3bfa:	4907      	ldr	r1, [pc, #28]	; (3c18 <flash_area_get_sectors+0x4c>)
    3bfc:	f01a fa17 	bl	1e02e <flash_page_foreach>
	if (cb_data->status == 0) {
    3c00:	9807      	ldr	r0, [sp, #28]
    3c02:	b908      	cbnz	r0, 3c08 <flash_area_get_sectors+0x3c>
		*cnt = cb_data->ret_idx;
    3c04:	9b05      	ldr	r3, [sp, #20]
    3c06:	6023      	str	r3, [r4, #0]
	struct layout_data data;

	return flash_area_layout(idx, cnt, ret, get_sectors_cb, &data);
}
    3c08:	b009      	add	sp, #36	; 0x24
    3c0a:	bd30      	pop	{r4, r5, pc}
		return -EINVAL;
    3c0c:	f06f 0015 	mvn.w	r0, #21
    3c10:	e7fa      	b.n	3c08 <flash_area_get_sectors+0x3c>
		return -ENODEV;
    3c12:	f06f 0012 	mvn.w	r0, #18
	return flash_area_layout(idx, cnt, ret, get_sectors_cb, &data);
    3c16:	e7f7      	b.n	3c08 <flash_area_get_sectors+0x3c>
    3c18:	0001aa2d 	.word	0x0001aa2d

00003c1c <settings_save_one>:
int settings_save_one(const char *name, const void *value, size_t val_len)
{
	int rc;
	struct settings_store *cs;

	cs = settings_save_dst;
    3c1c:	4b0e      	ldr	r3, [pc, #56]	; (3c58 <settings_save_one+0x3c>)
{
    3c1e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	cs = settings_save_dst;
    3c22:	681c      	ldr	r4, [r3, #0]
{
    3c24:	4606      	mov	r6, r0
    3c26:	460f      	mov	r7, r1
    3c28:	4690      	mov	r8, r2
	if (!cs) {
    3c2a:	b194      	cbz	r4, 3c52 <settings_save_one+0x36>
	return z_impl_k_mutex_lock(mutex, timeout);
    3c2c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3c30:	480a      	ldr	r0, [pc, #40]	; (3c5c <settings_save_one+0x40>)
    3c32:	f014 f813 	bl	17c5c <z_impl_k_mutex_lock>
		return -ENOENT;
	}

	k_mutex_lock(&settings_lock, K_FOREVER);

	rc = cs->cs_itf->csi_save(cs, name, (char *)value, val_len);
    3c36:	6863      	ldr	r3, [r4, #4]
    3c38:	463a      	mov	r2, r7
    3c3a:	689d      	ldr	r5, [r3, #8]
    3c3c:	4631      	mov	r1, r6
    3c3e:	4643      	mov	r3, r8
    3c40:	4620      	mov	r0, r4
    3c42:	47a8      	blx	r5
    3c44:	4604      	mov	r4, r0
	z_impl_k_mutex_unlock(mutex);
    3c46:	4805      	ldr	r0, [pc, #20]	; (3c5c <settings_save_one+0x40>)
    3c48:	f014 f87a 	bl	17d40 <z_impl_k_mutex_unlock>

	k_mutex_unlock(&settings_lock);

	return rc;
}
    3c4c:	4620      	mov	r0, r4
    3c4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENOENT;
    3c52:	f06f 0401 	mvn.w	r4, #1
    3c56:	e7f9      	b.n	3c4c <settings_save_one+0x30>
    3c58:	20000138 	.word	0x20000138
    3c5c:	20005c74 	.word	0x20005c74

00003c60 <settings_src_register>:
	SYS_SLIST_FOR_EACH_NODE(&settings_load_srcs, cur) {
    3c60:	4b0e      	ldr	r3, [pc, #56]	; (3c9c <settings_src_register+0x3c>)
{
    3c62:	b510      	push	{r4, lr}
	SYS_SLIST_FOR_EACH_NODE(&settings_load_srcs, cur) {
    3c64:	681c      	ldr	r4, [r3, #0]
	prev = NULL;
    3c66:	2100      	movs	r1, #0
	SYS_SLIST_FOR_EACH_NODE(&settings_load_srcs, cur) {
    3c68:	4622      	mov	r2, r4
    3c6a:	b932      	cbnz	r2, 3c7a <settings_src_register+0x1a>
 */
static inline void sys_slist_insert(sys_slist_t *list,
				    sys_snode_t *prev,
				    sys_snode_t *node);

Z_GENLIST_INSERT(slist, snode)
    3c6c:	b941      	cbnz	r1, 3c80 <settings_src_register+0x20>
	parent->next = child;
    3c6e:	6004      	str	r4, [r0, #0]
Z_GENLIST_PREPEND(slist, snode)
    3c70:	685a      	ldr	r2, [r3, #4]
	list->head = node;
    3c72:	6018      	str	r0, [r3, #0]
Z_GENLIST_PREPEND(slist, snode)
    3c74:	b95a      	cbnz	r2, 3c8e <settings_src_register+0x2e>
	list->tail = node;
    3c76:	6058      	str	r0, [r3, #4]
    3c78:	e009      	b.n	3c8e <settings_src_register+0x2e>
    3c7a:	4611      	mov	r1, r2
    3c7c:	6812      	ldr	r2, [r2, #0]
    3c7e:	e7f4      	b.n	3c6a <settings_src_register+0xa>
Z_GENLIST_INSERT(slist, snode)
    3c80:	680c      	ldr	r4, [r1, #0]
    3c82:	b93c      	cbnz	r4, 3c94 <settings_src_register+0x34>
	parent->next = child;
    3c84:	6002      	str	r2, [r0, #0]
Z_GENLIST_APPEND(slist, snode)
    3c86:	685a      	ldr	r2, [r3, #4]
    3c88:	b912      	cbnz	r2, 3c90 <settings_src_register+0x30>
	list->head = node;
    3c8a:	e9c3 0000 	strd	r0, r0, [r3]
}
    3c8e:	bd10      	pop	{r4, pc}
	parent->next = child;
    3c90:	6010      	str	r0, [r2, #0]
    3c92:	e7f0      	b.n	3c76 <settings_src_register+0x16>
    3c94:	6004      	str	r4, [r0, #0]
    3c96:	6008      	str	r0, [r1, #0]
    3c98:	e7f9      	b.n	3c8e <settings_src_register+0x2e>
    3c9a:	bf00      	nop
    3c9c:	20000130 	.word	0x20000130

00003ca0 <settings_dst_register>:
	settings_save_dst = cs;
    3ca0:	4b01      	ldr	r3, [pc, #4]	; (3ca8 <settings_dst_register+0x8>)
    3ca2:	6018      	str	r0, [r3, #0]
}
    3ca4:	4770      	bx	lr
    3ca6:	bf00      	nop
    3ca8:	20000138 	.word	0x20000138

00003cac <settings_load_subtree>:
{
    3cac:	b530      	push	{r4, r5, lr}
    3cae:	b085      	sub	sp, #20
	const struct settings_load_arg arg = {
    3cb0:	2300      	movs	r3, #0
{
    3cb2:	4605      	mov	r5, r0
	const struct settings_load_arg arg = {
    3cb4:	e9cd 3302 	strd	r3, r3, [sp, #8]
    3cb8:	9001      	str	r0, [sp, #4]
	return z_impl_k_mutex_lock(mutex, timeout);
    3cba:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3cbe:	480b      	ldr	r0, [pc, #44]	; (3cec <settings_load_subtree+0x40>)
    3cc0:	f013 ffcc 	bl	17c5c <z_impl_k_mutex_lock>
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
    3cc4:	4b0a      	ldr	r3, [pc, #40]	; (3cf0 <settings_load_subtree+0x44>)
    3cc6:	681c      	ldr	r4, [r3, #0]
    3cc8:	b134      	cbz	r4, 3cd8 <settings_load_subtree+0x2c>
		cs->cs_itf->csi_load(cs, &arg);
    3cca:	6863      	ldr	r3, [r4, #4]
    3ccc:	4620      	mov	r0, r4
    3cce:	681b      	ldr	r3, [r3, #0]
    3cd0:	a901      	add	r1, sp, #4
    3cd2:	4798      	blx	r3
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    3cd4:	6824      	ldr	r4, [r4, #0]
	return node->next;
    3cd6:	e7f7      	b.n	3cc8 <settings_load_subtree+0x1c>
	rc = settings_commit_subtree(subtree);
    3cd8:	4628      	mov	r0, r5
    3cda:	f000 f8cb 	bl	3e74 <settings_commit_subtree>
    3cde:	4604      	mov	r4, r0
	z_impl_k_mutex_unlock(mutex);
    3ce0:	4802      	ldr	r0, [pc, #8]	; (3cec <settings_load_subtree+0x40>)
    3ce2:	f014 f82d 	bl	17d40 <z_impl_k_mutex_unlock>
}
    3ce6:	4620      	mov	r0, r4
    3ce8:	b005      	add	sp, #20
    3cea:	bd30      	pop	{r4, r5, pc}
    3cec:	20005c74 	.word	0x20005c74
    3cf0:	20000130 	.word	0x20000130

00003cf4 <settings_load_subtree_direct>:
{
    3cf4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	const struct settings_load_arg arg = {
    3cf6:	e9cd 0101 	strd	r0, r1, [sp, #4]
    3cfa:	9203      	str	r2, [sp, #12]
	return z_impl_k_mutex_lock(mutex, timeout);
    3cfc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3d00:	4809      	ldr	r0, [pc, #36]	; (3d28 <settings_load_subtree_direct+0x34>)
    3d02:	f013 ffab 	bl	17c5c <z_impl_k_mutex_lock>
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
    3d06:	4b09      	ldr	r3, [pc, #36]	; (3d2c <settings_load_subtree_direct+0x38>)
    3d08:	681c      	ldr	r4, [r3, #0]
    3d0a:	b134      	cbz	r4, 3d1a <settings_load_subtree_direct+0x26>
		cs->cs_itf->csi_load(cs, &arg);
    3d0c:	6863      	ldr	r3, [r4, #4]
    3d0e:	4620      	mov	r0, r4
    3d10:	681b      	ldr	r3, [r3, #0]
    3d12:	a901      	add	r1, sp, #4
    3d14:	4798      	blx	r3
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    3d16:	6824      	ldr	r4, [r4, #0]
	return node->next;
    3d18:	e7f7      	b.n	3d0a <settings_load_subtree_direct+0x16>
	z_impl_k_mutex_unlock(mutex);
    3d1a:	4803      	ldr	r0, [pc, #12]	; (3d28 <settings_load_subtree_direct+0x34>)
    3d1c:	f014 f810 	bl	17d40 <z_impl_k_mutex_unlock>
}
    3d20:	2000      	movs	r0, #0
    3d22:	b004      	add	sp, #16
    3d24:	bd10      	pop	{r4, pc}
    3d26:	bf00      	nop
    3d28:	20005c74 	.word	0x20005c74
    3d2c:	20000130 	.word	0x20000130

00003d30 <settings_store_init>:
	list->head = NULL;
    3d30:	4b02      	ldr	r3, [pc, #8]	; (3d3c <settings_store_init+0xc>)
    3d32:	2200      	movs	r2, #0
	list->tail = NULL;
    3d34:	e9c3 2200 	strd	r2, r2, [r3]
}

void settings_store_init(void)
{
	sys_slist_init(&settings_load_srcs);
}
    3d38:	4770      	bx	lr
    3d3a:	bf00      	nop
    3d3c:	20000130 	.word	0x20000130

00003d40 <settings_init>:
	list->head = NULL;
    3d40:	4b02      	ldr	r3, [pc, #8]	; (3d4c <settings_init+0xc>)
    3d42:	2200      	movs	r2, #0
	list->tail = NULL;
    3d44:	e9c3 2200 	strd	r2, r2, [r3]
void settings_init(void)
{
#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	sys_slist_init(&settings_handlers);
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */
	settings_store_init();
    3d48:	f7ff bff2 	b.w	3d30 <settings_store_init>
    3d4c:	2000013c 	.word	0x2000013c

00003d50 <settings_parse_and_lookup>:
	return rc;
}

struct settings_handler_static *settings_parse_and_lookup(const char *name,
							const char **next)
{
    3d50:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    3d54:	4607      	mov	r7, r0
	struct settings_handler_static *bestmatch;
	const char *tmpnext;

	bestmatch = NULL;
	if (next) {
    3d56:	460e      	mov	r6, r1
    3d58:	b109      	cbz	r1, 3d5e <settings_parse_and_lookup+0xe>
		*next = NULL;
    3d5a:	2300      	movs	r3, #0
    3d5c:	600b      	str	r3, [r1, #0]
    3d5e:	4c1c      	ldr	r4, [pc, #112]	; (3dd0 <settings_parse_and_lookup+0x80>)
	}

	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    3d60:	f8df 8074 	ldr.w	r8, [pc, #116]	; 3dd8 <settings_parse_and_lookup+0x88>
    3d64:	2500      	movs	r5, #0
    3d66:	4544      	cmp	r4, r8
    3d68:	d308      	bcc.n	3d7c <settings_parse_and_lookup+0x2c>
	}

#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	struct settings_handler *ch;

	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
    3d6a:	4b1a      	ldr	r3, [pc, #104]	; (3dd4 <settings_parse_and_lookup+0x84>)
    3d6c:	681c      	ldr	r4, [r3, #0]
    3d6e:	b10c      	cbz	r4, 3d74 <settings_parse_and_lookup+0x24>
    3d70:	3c14      	subs	r4, #20
    3d72:	b9c4      	cbnz	r4, 3da6 <settings_parse_and_lookup+0x56>
			}
		}
	}
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */
	return bestmatch;
}
    3d74:	4628      	mov	r0, r5
    3d76:	b002      	add	sp, #8
    3d78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
    3d7c:	aa01      	add	r2, sp, #4
    3d7e:	6821      	ldr	r1, [r4, #0]
    3d80:	4638      	mov	r0, r7
    3d82:	f016 fe78 	bl	1aa76 <settings_name_steq>
    3d86:	b160      	cbz	r0, 3da2 <settings_parse_and_lookup+0x52>
		if (!bestmatch) {
    3d88:	b925      	cbnz	r5, 3d94 <settings_parse_and_lookup+0x44>
			if (next) {
    3d8a:	b10e      	cbz	r6, 3d90 <settings_parse_and_lookup+0x40>
				*next = tmpnext;
    3d8c:	9b01      	ldr	r3, [sp, #4]
    3d8e:	6033      	str	r3, [r6, #0]
    3d90:	4625      	mov	r5, r4
    3d92:	e006      	b.n	3da2 <settings_parse_and_lookup+0x52>
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
    3d94:	2200      	movs	r2, #0
    3d96:	6829      	ldr	r1, [r5, #0]
    3d98:	6820      	ldr	r0, [r4, #0]
    3d9a:	f016 fe6c 	bl	1aa76 <settings_name_steq>
    3d9e:	2800      	cmp	r0, #0
    3da0:	d1f3      	bne.n	3d8a <settings_parse_and_lookup+0x3a>
	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    3da2:	3414      	adds	r4, #20
    3da4:	e7df      	b.n	3d66 <settings_parse_and_lookup+0x16>
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
    3da6:	aa01      	add	r2, sp, #4
    3da8:	6821      	ldr	r1, [r4, #0]
    3daa:	4638      	mov	r0, r7
    3dac:	f016 fe63 	bl	1aa76 <settings_name_steq>
    3db0:	b160      	cbz	r0, 3dcc <settings_parse_and_lookup+0x7c>
		if (!bestmatch) {
    3db2:	b925      	cbnz	r5, 3dbe <settings_parse_and_lookup+0x6e>
			if (next) {
    3db4:	b10e      	cbz	r6, 3dba <settings_parse_and_lookup+0x6a>
				*next = tmpnext;
    3db6:	9b01      	ldr	r3, [sp, #4]
    3db8:	6033      	str	r3, [r6, #0]
    3dba:	4625      	mov	r5, r4
    3dbc:	e006      	b.n	3dcc <settings_parse_and_lookup+0x7c>
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
    3dbe:	2200      	movs	r2, #0
    3dc0:	6829      	ldr	r1, [r5, #0]
    3dc2:	6820      	ldr	r0, [r4, #0]
    3dc4:	f016 fe57 	bl	1aa76 <settings_name_steq>
    3dc8:	2800      	cmp	r0, #0
    3dca:	d1f3      	bne.n	3db4 <settings_parse_and_lookup+0x64>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    3dcc:	6964      	ldr	r4, [r4, #20]
    3dce:	e7ce      	b.n	3d6e <settings_parse_and_lookup+0x1e>
    3dd0:	0001ecc4 	.word	0x0001ecc4
    3dd4:	2000013c 	.word	0x2000013c
    3dd8:	0001ed28 	.word	0x0001ed28

00003ddc <settings_call_set_handler>:
int settings_call_set_handler(const char *name,
			      size_t len,
			      settings_read_cb read_cb,
			      void *read_cb_arg,
			      const struct settings_load_arg *load_arg)
{
    3ddc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    3de0:	b085      	sub	sp, #20
    3de2:	4605      	mov	r5, r0
    3de4:	9c0c      	ldr	r4, [sp, #48]	; 0x30
	int rc;
	const char *name_key = name;
    3de6:	9003      	str	r0, [sp, #12]
{
    3de8:	460e      	mov	r6, r1
    3dea:	4617      	mov	r7, r2
    3dec:	4698      	mov	r8, r3

	if (load_arg && load_arg->subtree &&
    3dee:	b1b4      	cbz	r4, 3e1e <settings_call_set_handler+0x42>
    3df0:	6821      	ldr	r1, [r4, #0]
    3df2:	b179      	cbz	r1, 3e14 <settings_call_set_handler+0x38>
	    !settings_name_steq(name, load_arg->subtree, &name_key)) {
    3df4:	aa03      	add	r2, sp, #12
    3df6:	f016 fe3e 	bl	1aa76 <settings_name_steq>
	if (load_arg && load_arg->subtree &&
    3dfa:	b958      	cbnz	r0, 3e14 <settings_call_set_handler+0x38>

		if (rc != 0) {
			LOG_ERR("set-value failure. key: %s error(%d)",
				log_strdup(name), rc);
			/* Ignoring the error */
			rc = 0;
    3dfc:	2000      	movs	r0, #0
    3dfe:	e006      	b.n	3e0e <settings_call_set_handler+0x32>
		rc = load_arg->cb(name_key, len, read_cb, read_cb_arg,
    3e00:	68a3      	ldr	r3, [r4, #8]
    3e02:	9300      	str	r3, [sp, #0]
    3e04:	463a      	mov	r2, r7
    3e06:	4643      	mov	r3, r8
    3e08:	4631      	mov	r1, r6
    3e0a:	9803      	ldr	r0, [sp, #12]
    3e0c:	47c8      	blx	r9
			LOG_DBG("set-value OK. key: %s",
				log_strdup(name));
		}
	}
	return rc;
}
    3e0e:	b005      	add	sp, #20
    3e10:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (load_arg && load_arg->cb) {
    3e14:	f8d4 9004 	ldr.w	r9, [r4, #4]
    3e18:	f1b9 0f00 	cmp.w	r9, #0
    3e1c:	d1f0      	bne.n	3e00 <settings_call_set_handler+0x24>
		ch = settings_parse_and_lookup(name, &name_key);
    3e1e:	a903      	add	r1, sp, #12
    3e20:	4628      	mov	r0, r5
    3e22:	f7ff ff95 	bl	3d50 <settings_parse_and_lookup>
		if (!ch) {
    3e26:	2800      	cmp	r0, #0
    3e28:	d0e8      	beq.n	3dfc <settings_call_set_handler+0x20>
		rc = ch->h_set(name_key, len, read_cb, read_cb_arg);
    3e2a:	6884      	ldr	r4, [r0, #8]
    3e2c:	9803      	ldr	r0, [sp, #12]
    3e2e:	4631      	mov	r1, r6
    3e30:	4643      	mov	r3, r8
    3e32:	463a      	mov	r2, r7
    3e34:	47a0      	blx	r4
		if (rc != 0) {
    3e36:	4606      	mov	r6, r0
    3e38:	2800      	cmp	r0, #0
    3e3a:	d0df      	beq.n	3dfc <settings_call_set_handler+0x20>
			LOG_ERR("set-value failure. key: %s error(%d)",
    3e3c:	2301      	movs	r3, #1
    3e3e:	f04f 0400 	mov.w	r4, #0
    3e42:	f363 0407 	bfi	r4, r3, #0, #8
    3e46:	4908      	ldr	r1, [pc, #32]	; (3e68 <settings_call_set_handler+0x8c>)
    3e48:	4b08      	ldr	r3, [pc, #32]	; (3e6c <settings_call_set_handler+0x90>)
    3e4a:	1ac9      	subs	r1, r1, r3
    3e4c:	08c9      	lsrs	r1, r1, #3
    3e4e:	4628      	mov	r0, r5
    3e50:	f361 148f 	bfi	r4, r1, #6, #10
    3e54:	f7ff f816 	bl	2e84 <log_strdup>
    3e58:	4623      	mov	r3, r4
    3e5a:	4601      	mov	r1, r0
    3e5c:	4632      	mov	r2, r6
    3e5e:	4804      	ldr	r0, [pc, #16]	; (3e70 <settings_call_set_handler+0x94>)
    3e60:	f016 fbf8 	bl	1a654 <log_2>
    3e64:	e7ca      	b.n	3dfc <settings_call_set_handler+0x20>
    3e66:	bf00      	nop
    3e68:	0001ee68 	.word	0x0001ee68
    3e6c:	0001ed28 	.word	0x0001ed28
    3e70:	0001fc07 	.word	0x0001fc07

00003e74 <settings_commit_subtree>:
{
	return settings_commit_subtree(NULL);
}

int settings_commit_subtree(const char *subtree)
{
    3e74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int rc;
	int rc2;

	rc = 0;

	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    3e76:	4c18      	ldr	r4, [pc, #96]	; (3ed8 <settings_commit_subtree+0x64>)
    3e78:	4f18      	ldr	r7, [pc, #96]	; (3edc <settings_commit_subtree+0x68>)
{
    3e7a:	4606      	mov	r6, r0
	rc = 0;
    3e7c:	2500      	movs	r5, #0
	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    3e7e:	42bc      	cmp	r4, r7
    3e80:	d306      	bcc.n	3e90 <settings_commit_subtree+0x1c>
		}
	}

#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	struct settings_handler *ch;
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
    3e82:	4b17      	ldr	r3, [pc, #92]	; (3ee0 <settings_commit_subtree+0x6c>)
    3e84:	681c      	ldr	r4, [r3, #0]
    3e86:	b10c      	cbz	r4, 3e8c <settings_commit_subtree+0x18>
    3e88:	3c14      	subs	r4, #20
    3e8a:	b99c      	cbnz	r4, 3eb4 <settings_commit_subtree+0x40>
		}
	}
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */

	return rc;
}
    3e8c:	4628      	mov	r0, r5
    3e8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
    3e90:	b91e      	cbnz	r6, 3e9a <settings_commit_subtree+0x26>
		if (ch->h_commit) {
    3e92:	68e3      	ldr	r3, [r4, #12]
    3e94:	b94b      	cbnz	r3, 3eaa <settings_commit_subtree+0x36>
	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    3e96:	3414      	adds	r4, #20
    3e98:	e7f1      	b.n	3e7e <settings_commit_subtree+0xa>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
    3e9a:	2200      	movs	r2, #0
    3e9c:	4631      	mov	r1, r6
    3e9e:	6820      	ldr	r0, [r4, #0]
    3ea0:	f016 fde9 	bl	1aa76 <settings_name_steq>
    3ea4:	2800      	cmp	r0, #0
    3ea6:	d1f4      	bne.n	3e92 <settings_commit_subtree+0x1e>
    3ea8:	e7f5      	b.n	3e96 <settings_commit_subtree+0x22>
			rc2 = ch->h_commit();
    3eaa:	4798      	blx	r3
				rc = rc2;
    3eac:	2d00      	cmp	r5, #0
    3eae:	bf08      	it	eq
    3eb0:	4605      	moveq	r5, r0
    3eb2:	e7f0      	b.n	3e96 <settings_commit_subtree+0x22>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
    3eb4:	b91e      	cbnz	r6, 3ebe <settings_commit_subtree+0x4a>
		if (ch->h_commit) {
    3eb6:	68e3      	ldr	r3, [r4, #12]
    3eb8:	b94b      	cbnz	r3, 3ece <settings_commit_subtree+0x5a>
    3eba:	6964      	ldr	r4, [r4, #20]
    3ebc:	e7e3      	b.n	3e86 <settings_commit_subtree+0x12>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
    3ebe:	2200      	movs	r2, #0
    3ec0:	4631      	mov	r1, r6
    3ec2:	6820      	ldr	r0, [r4, #0]
    3ec4:	f016 fdd7 	bl	1aa76 <settings_name_steq>
    3ec8:	2800      	cmp	r0, #0
    3eca:	d1f4      	bne.n	3eb6 <settings_commit_subtree+0x42>
    3ecc:	e7f5      	b.n	3eba <settings_commit_subtree+0x46>
			rc2 = ch->h_commit();
    3ece:	4798      	blx	r3
				rc = rc2;
    3ed0:	2d00      	cmp	r5, #0
    3ed2:	bf08      	it	eq
    3ed4:	4605      	moveq	r5, r0
    3ed6:	e7f0      	b.n	3eba <settings_commit_subtree+0x46>
    3ed8:	0001ecc4 	.word	0x0001ecc4
    3edc:	0001ed28 	.word	0x0001ed28
    3ee0:	2000013c 	.word	0x2000013c

00003ee4 <settings_subsys_init>:
void settings_init(void);

int settings_backend_init(void);

int settings_subsys_init(void)
{
    3ee4:	b510      	push	{r4, lr}

	int err = 0;

	if (settings_subsys_initialized) {
    3ee6:	4c06      	ldr	r4, [pc, #24]	; (3f00 <settings_subsys_init+0x1c>)
    3ee8:	7823      	ldrb	r3, [r4, #0]
    3eea:	b93b      	cbnz	r3, 3efc <settings_subsys_init+0x18>
		return 0;
	}

	settings_init();
    3eec:	f7ff ff28 	bl	3d40 <settings_init>

	err = settings_backend_init(); /* func rises kernel panic once error */
    3ef0:	f000 f864 	bl	3fbc <settings_backend_init>

	if (!err) {
    3ef4:	b908      	cbnz	r0, 3efa <settings_subsys_init+0x16>
		settings_subsys_initialized = true;
    3ef6:	2301      	movs	r3, #1
    3ef8:	7023      	strb	r3, [r4, #0]
	}

	return err;
}
    3efa:	bd10      	pop	{r4, pc}
		return 0;
    3efc:	2000      	movs	r0, #0
    3efe:	e7fc      	b.n	3efa <settings_subsys_init+0x16>
    3f00:	20001b13 	.word	0x20001b13

00003f04 <settings_nvs_load>:
	return 0;
}

static int settings_nvs_load(struct settings_store *cs,
			     const struct settings_load_arg *arg)
{
    3f04:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	char name[SETTINGS_MAX_NAME_LEN + SETTINGS_EXTRA_LEN + 1];
	char buf;
	ssize_t rc1, rc2;
	u16_t name_id = NVS_NAMECNT_ID;

	name_id = cf->last_name_id + 1;
    3f08:	8e84      	ldrh	r4, [r0, #52]	; 0x34
		/* Found a name, this might not include a trailing \0 */
		name[rc1] = '\0';
		read_fn_arg.fs = &cf->cf_nvs;
		read_fn_arg.id = name_id + NVS_NAME_ID_OFFSET;

		ret = settings_call_set_handler(
    3f0a:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 3fb8 <settings_nvs_load+0xb4>
	name_id = cf->last_name_id + 1;
    3f0e:	3401      	adds	r4, #1
{
    3f10:	b098      	sub	sp, #96	; 0x60
    3f12:	4680      	mov	r8, r0
    3f14:	468a      	mov	sl, r1
	name_id = cf->last_name_id + 1;
    3f16:	b2a4      	uxth	r4, r4
		rc1 = nvs_read(&cf->cf_nvs, name_id, &name, sizeof(name));
    3f18:	f100 0608 	add.w	r6, r0, #8
		name_id--;
    3f1c:	1e65      	subs	r5, r4, #1
    3f1e:	b2ad      	uxth	r5, r5
		if (name_id == NVS_NAMECNT_ID) {
    3f20:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
    3f24:	d045      	beq.n	3fb2 <settings_nvs_load+0xae>
		rc1 = nvs_read(&cf->cf_nvs, name_id, &name, sizeof(name));
    3f26:	234a      	movs	r3, #74	; 0x4a
    3f28:	aa05      	add	r2, sp, #20
    3f2a:	4629      	mov	r1, r5
    3f2c:	4630      	mov	r0, r6
    3f2e:	f016 fd76 	bl	1aa1e <nvs_read>
    3f32:	f504 547f 	add.w	r4, r4, #16320	; 0x3fc0
    3f36:	343f      	adds	r4, #63	; 0x3f
    3f38:	b2a4      	uxth	r4, r4
    3f3a:	4607      	mov	r7, r0
		rc2 = nvs_read(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET,
    3f3c:	4621      	mov	r1, r4
    3f3e:	2301      	movs	r3, #1
    3f40:	f10d 020b 	add.w	r2, sp, #11
    3f44:	4630      	mov	r0, r6
    3f46:	f016 fd6a 	bl	1aa1e <nvs_read>
		if ((rc1 <= 0) && (rc2 <= 0)) {
    3f4a:	2f00      	cmp	r7, #0
		rc2 = nvs_read(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET,
    3f4c:	4601      	mov	r1, r0
		if ((rc1 <= 0) && (rc2 <= 0)) {
    3f4e:	dc03      	bgt.n	3f58 <settings_nvs_load+0x54>
    3f50:	2800      	cmp	r0, #0
    3f52:	dc03      	bgt.n	3f5c <settings_nvs_load+0x58>
{
    3f54:	462c      	mov	r4, r5
    3f56:	e7e1      	b.n	3f1c <settings_nvs_load+0x18>
		if ((rc1 <= 0) || (rc2 <= 0)) {
    3f58:	2800      	cmp	r0, #0
    3f5a:	dc16      	bgt.n	3f8a <settings_nvs_load+0x86>
			if (name_id == cf->last_name_id) {
    3f5c:	f8b8 3034 	ldrh.w	r3, [r8, #52]	; 0x34
    3f60:	42ab      	cmp	r3, r5
    3f62:	d109      	bne.n	3f78 <settings_nvs_load+0x74>
				cf->last_name_id--;
    3f64:	4642      	mov	r2, r8
    3f66:	1e6b      	subs	r3, r5, #1
    3f68:	f822 3f34 	strh.w	r3, [r2, #52]!
				nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID,
    3f6c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    3f70:	2302      	movs	r3, #2
    3f72:	4630      	mov	r0, r6
    3f74:	f7ff fcb2 	bl	38dc <nvs_write>
			nvs_delete(&cf->cf_nvs, name_id);
    3f78:	4629      	mov	r1, r5
    3f7a:	4630      	mov	r0, r6
    3f7c:	f016 fd4b 	bl	1aa16 <nvs_delete>
			nvs_delete(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET);
    3f80:	4621      	mov	r1, r4
    3f82:	4630      	mov	r0, r6
    3f84:	f016 fd47 	bl	1aa16 <nvs_delete>
			continue;
    3f88:	e7e4      	b.n	3f54 <settings_nvs_load+0x50>
		name[rc1] = '\0';
    3f8a:	ab18      	add	r3, sp, #96	; 0x60
    3f8c:	441f      	add	r7, r3
    3f8e:	2300      	movs	r3, #0
    3f90:	f807 3c4c 	strb.w	r3, [r7, #-76]
		ret = settings_call_set_handler(
    3f94:	464a      	mov	r2, r9
    3f96:	f8cd a000 	str.w	sl, [sp]
    3f9a:	ab03      	add	r3, sp, #12
    3f9c:	a805      	add	r0, sp, #20
		read_fn_arg.fs = &cf->cf_nvs;
    3f9e:	9603      	str	r6, [sp, #12]
		read_fn_arg.id = name_id + NVS_NAME_ID_OFFSET;
    3fa0:	f8ad 4010 	strh.w	r4, [sp, #16]
		ret = settings_call_set_handler(
    3fa4:	f7ff ff1a 	bl	3ddc <settings_call_set_handler>
			name, rc2,
			settings_nvs_read_fn, &read_fn_arg,
			(void *)arg);
		if (ret) {
    3fa8:	2800      	cmp	r0, #0
    3faa:	d0d3      	beq.n	3f54 <settings_nvs_load+0x50>
			break;
		}
	}
	return ret;
}
    3fac:	b018      	add	sp, #96	; 0x60
    3fae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    3fb2:	2000      	movs	r0, #0
	return ret;
    3fb4:	e7fa      	b.n	3fac <settings_nvs_load+0xa8>
    3fb6:	bf00      	nop
    3fb8:	0001aae3 	.word	0x0001aae3

00003fbc <settings_backend_init>:
	LOG_DBG("Initialized");
	return 0;
}

int settings_backend_init(void)
{
    3fbc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	int rc;
	u16_t cnt = 0;
	size_t nvs_sector_size, nvs_size = 0;
	const struct flash_area *fa;
	struct flash_sector hw_flash_sector;
	u32_t sector_cnt = 1;
    3fbe:	2301      	movs	r3, #1

	rc = flash_area_open(DT_FLASH_AREA_STORAGE_ID, &fa);
    3fc0:	4669      	mov	r1, sp
    3fc2:	2004      	movs	r0, #4
	u32_t sector_cnt = 1;
    3fc4:	9301      	str	r3, [sp, #4]
	rc = flash_area_open(DT_FLASH_AREA_STORAGE_ID, &fa);
    3fc6:	f7ff fded 	bl	3ba4 <flash_area_open>
	if (rc) {
    3fca:	4604      	mov	r4, r0
    3fcc:	2800      	cmp	r0, #0
    3fce:	d137      	bne.n	4040 <settings_backend_init+0x84>
		return rc;
	}

	rc = flash_area_get_sectors(DT_FLASH_AREA_STORAGE_ID, &sector_cnt,
    3fd0:	aa02      	add	r2, sp, #8
    3fd2:	a901      	add	r1, sp, #4
    3fd4:	2004      	movs	r0, #4
    3fd6:	f7ff fdf9 	bl	3bcc <flash_area_get_sectors>
				    &hw_flash_sector);
	if (rc == -ENODEV) {
    3fda:	f110 0f13 	cmn.w	r0, #19
	rc = flash_area_get_sectors(DT_FLASH_AREA_STORAGE_ID, &sector_cnt,
    3fde:	4604      	mov	r4, r0
	if (rc == -ENODEV) {
    3fe0:	d02e      	beq.n	4040 <settings_backend_init+0x84>
		return rc;
	} else if (rc != 0 && rc != -ENOMEM) {
    3fe2:	b140      	cbz	r0, 3ff6 <settings_backend_init+0x3a>
    3fe4:	f110 040c 	adds.w	r4, r0, #12
    3fe8:	d005      	beq.n	3ff6 <settings_backend_init+0x3a>
		k_panic();
    3fea:	4040      	eors	r0, r0
    3fec:	f380 8811 	msr	BASEPRI, r0
    3ff0:	f04f 0004 	mov.w	r0, #4
    3ff4:	df02      	svc	2
	}

	nvs_sector_size = CONFIG_SETTINGS_NVS_SECTOR_SIZE_MULT *
    3ff6:	9903      	ldr	r1, [sp, #12]
			  hw_flash_sector.fs_size;

	if (nvs_sector_size > UINT16_MAX) {
    3ff8:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
    3ffc:	d223      	bcs.n	4046 <settings_backend_init+0x8a>
		return -EDOM;
	}

	while (cnt < CONFIG_SETTINGS_NVS_SECTOR_COUNT) {
		nvs_size += nvs_sector_size;
		if (nvs_size > fa->fa_size) {
    3ffe:	9a00      	ldr	r2, [sp, #0]
    4000:	2300      	movs	r3, #0
    4002:	6895      	ldr	r5, [r2, #8]
	size_t nvs_sector_size, nvs_size = 0;
    4004:	4618      	mov	r0, r3
		nvs_size += nvs_sector_size;
    4006:	4408      	add	r0, r1
		if (nvs_size > fa->fa_size) {
    4008:	4285      	cmp	r5, r0
    400a:	b29c      	uxth	r4, r3
    400c:	d303      	bcc.n	4016 <settings_backend_init+0x5a>
			break;
		}
		cnt++;
    400e:	3301      	adds	r3, #1
	while (cnt < CONFIG_SETTINGS_NVS_SECTOR_COUNT) {
    4010:	2b08      	cmp	r3, #8
    4012:	d1f8      	bne.n	4006 <settings_backend_init+0x4a>
    4014:	461c      	mov	r4, r3
	}

	/* define the nvs file system using the page_info */
	default_settings_nvs.cf_nvs.sector_size = nvs_sector_size;
    4016:	4d0d      	ldr	r5, [pc, #52]	; (404c <settings_backend_init+0x90>)
	default_settings_nvs.cf_nvs.sector_count = cnt;
	default_settings_nvs.cf_nvs.offset = fa->fa_off;
    4018:	6853      	ldr	r3, [r2, #4]
    401a:	60ab      	str	r3, [r5, #8]
	default_settings_nvs.flash_dev_name = fa->fa_dev_name;

	rc = settings_nvs_backend_init(&default_settings_nvs);
    401c:	4628      	mov	r0, r5
	default_settings_nvs.flash_dev_name = fa->fa_dev_name;
    401e:	68d3      	ldr	r3, [r2, #12]
	default_settings_nvs.cf_nvs.sector_count = cnt;
    4020:	82ec      	strh	r4, [r5, #22]
	default_settings_nvs.cf_nvs.sector_size = nvs_sector_size;
    4022:	82a9      	strh	r1, [r5, #20]
	default_settings_nvs.flash_dev_name = fa->fa_dev_name;
    4024:	63ab      	str	r3, [r5, #56]	; 0x38
	rc = settings_nvs_backend_init(&default_settings_nvs);
    4026:	f016 fdf1 	bl	1ac0c <settings_nvs_backend_init>
	if (rc) {
    402a:	4604      	mov	r4, r0
    402c:	b940      	cbnz	r0, 4040 <settings_backend_init+0x84>
	cf->cf_store.cs_itf = &settings_nvs_itf;
    402e:	4e08      	ldr	r6, [pc, #32]	; (4050 <settings_backend_init+0x94>)
    4030:	606e      	str	r6, [r5, #4]
	settings_src_register(&cf->cf_store);
    4032:	4628      	mov	r0, r5
    4034:	f7ff fe14 	bl	3c60 <settings_src_register>
	settings_dst_register(&cf->cf_store);
    4038:	4628      	mov	r0, r5
	cf->cf_store.cs_itf = &settings_nvs_itf;
    403a:	606e      	str	r6, [r5, #4]
	settings_dst_register(&cf->cf_store);
    403c:	f7ff fe30 	bl	3ca0 <settings_dst_register>
	}

	rc = settings_nvs_dst(&default_settings_nvs);

	return rc;
}
    4040:	4620      	mov	r0, r4
    4042:	b004      	add	sp, #16
    4044:	bd70      	pop	{r4, r5, r6, pc}
		return -EDOM;
    4046:	f06f 0424 	mvn.w	r4, #36	; 0x24
    404a:	e7f9      	b.n	4040 <settings_backend_init+0x84>
    404c:	20000144 	.word	0x20000144
    4050:	20005630 	.word	0x20005630

00004054 <nrf_power_clock_isr>:
#endif
}

NRF_STATIC_INLINE bool nrf_clock_event_check(NRF_CLOCK_Type const * p_reg, nrf_clock_event_t event)
{
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    4054:	4b16      	ldr	r3, [pc, #88]	; (40b0 <nrf_power_clock_isr+0x5c>)
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
    4056:	b507      	push	{r0, r1, r2, lr}
    4058:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
    405a:	b182      	cbz	r2, 407e <nrf_power_clock_isr+0x2a>
    return p_reg->INTENSET & mask;
    405c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    4060:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
    4064:	07d1      	lsls	r1, r2, #31
    4066:	d50a      	bpl.n	407e <nrf_power_clock_isr+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    4068:	2200      	movs	r2, #0
    406a:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    406c:	681b      	ldr	r3, [r3, #0]
	struct device *dev = DEVICE_GET(clock_nrf);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    406e:	4811      	ldr	r0, [pc, #68]	; (40b4 <nrf_power_clock_isr+0x60>)
    4070:	9300      	str	r3, [sp, #0]
    (void)dummy;
    4072:	9b00      	ldr	r3, [sp, #0]

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
    4074:	6883      	ldr	r3, [r0, #8]
    4076:	7a59      	ldrb	r1, [r3, #9]
    4078:	b909      	cbnz	r1, 407e <nrf_power_clock_isr+0x2a>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    407a:	f016 fdf1 	bl	1ac60 <clkstarted_handle>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    407e:	4b0e      	ldr	r3, [pc, #56]	; (40b8 <nrf_power_clock_isr+0x64>)
    4080:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
    4082:	b18a      	cbz	r2, 40a8 <nrf_power_clock_isr+0x54>
    return p_reg->INTENSET & mask;
    4084:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    4088:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
    408c:	0792      	lsls	r2, r2, #30
    408e:	d50b      	bpl.n	40a8 <nrf_power_clock_isr+0x54>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    4090:	2200      	movs	r2, #0
    4092:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    4094:	681b      	ldr	r3, [r3, #0]
    4096:	9301      	str	r3, [sp, #4]
    (void)dummy;
    4098:	9b01      	ldr	r3, [sp, #4]
					NRF_CLOCK_INT_LF_STARTED_MASK)) {
		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started(dev);
		}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    409a:	4806      	ldr	r0, [pc, #24]	; (40b4 <nrf_power_clock_isr+0x60>)
    409c:	2101      	movs	r1, #1
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
    409e:	b003      	add	sp, #12
    40a0:	f85d eb04 	ldr.w	lr, [sp], #4
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    40a4:	f016 bddc 	b.w	1ac60 <clkstarted_handle>
}
    40a8:	b003      	add	sp, #12
    40aa:	f85d fb04 	ldr.w	pc, [sp], #4
    40ae:	bf00      	nop
    40b0:	40000100 	.word	0x40000100
    40b4:	20005b44 	.word	0x20005b44
    40b8:	40000104 	.word	0x40000104

000040bc <rtc1_nrf_isr>:
 * symbol.
 */
void rtc1_nrf_isr(void *arg)
{
	ARG_UNUSED(arg);
	RTC->EVENTS_COMPARE[0] = 0;
    40bc:	4b0d      	ldr	r3, [pc, #52]	; (40f4 <rtc1_nrf_isr+0x38>)
    40be:	2200      	movs	r2, #0
    40c0:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
	__asm__ volatile(
    40c4:	f04f 0220 	mov.w	r2, #32
    40c8:	f3ef 8111 	mrs	r1, BASEPRI
    40cc:	f382 8811 	msr	BASEPRI, r2
    40d0:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t t = counter();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
    40d4:	4a08      	ldr	r2, [pc, #32]	; (40f8 <rtc1_nrf_isr+0x3c>)
#endif
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
    40d6:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
    40da:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
    40dc:	1ac0      	subs	r0, r0, r3
    40de:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
    40e2:	4403      	add	r3, r0
    40e4:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
    40e6:	f381 8811 	msr	BASEPRI, r1
    40ea:	f3bf 8f6f 	isb	sy
		}
		set_comparator(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    40ee:	f014 bc25 	b.w	1893c <z_clock_announce>
    40f2:	bf00      	nop
    40f4:	40011000 	.word	0x40011000
    40f8:	20000198 	.word	0x20000198

000040fc <z_clock_driver_init>:
}

int z_clock_driver_init(struct device *device)
{
    40fc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    40fe:	481c      	ldr	r0, [pc, #112]	; (4170 <z_clock_driver_init+0x74>)
    4100:	f013 fb16 	bl	17730 <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_INST_0_NORDIC_NRF_CLOCK_LABEL);
	if (!clock) {
    4104:	b380      	cbz	r0, 4168 <z_clock_driver_init+0x6c>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
    4106:	6843      	ldr	r3, [r0, #4]
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
    4108:	4d1a      	ldr	r5, [pc, #104]	; (4174 <z_clock_driver_init+0x78>)
    410a:	681b      	ldr	r3, [r3, #0]
    410c:	2101      	movs	r1, #1
    410e:	4798      	blx	r3
    p_reg->CC[ch] = cc_val;
    4110:	2601      	movs	r6, #1
    p_reg->PRESCALER = val;
    4112:	2400      	movs	r4, #0
    p_reg->INTENSET = mask;
    4114:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->PRESCALER = val;
    4118:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
    411c:	f8c5 6540 	str.w	r6, [r5, #1344]	; 0x540
    p_reg->INTENSET = mask;
    4120:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    4124:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    4128:	f503 538a 	add.w	r3, r3, #4416	; 0x1140
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    412c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    4130:	601c      	str	r4, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    4132:	681b      	ldr	r3, [r3, #0]
    4134:	9301      	str	r3, [sp, #4]
    (void)dummy;
    4136:	9b01      	ldr	r3, [sp, #4]
    4138:	4b0f      	ldr	r3, [pc, #60]	; (4178 <z_clock_driver_init+0x7c>)

	/* Clear the event flag and possible pending interrupt */
	nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_COMPARE_0);
	NVIC_ClearPendingIRQ(RTC1_IRQn);

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
    413a:	4631      	mov	r1, r6
    413c:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    4140:	2011      	movs	r0, #17
    4142:	4622      	mov	r2, r4
    4144:	f000 f93a 	bl	43bc <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
    4148:	2011      	movs	r0, #17
    414a:	f000 f905 	bl	4358 <arch_irq_enable>
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    414e:	4b0b      	ldr	r3, [pc, #44]	; (417c <z_clock_driver_init+0x80>)
    4150:	601e      	str	r6, [r3, #0]
    4152:	602e      	str	r6, [r5, #0]
     return p_reg->COUNTER;
    4154:	f8d5 3504 	ldr.w	r3, [r5, #1284]	; 0x504

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	if (!IS_ENABLED(TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
    4158:	4433      	add	r3, r6
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    415a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    415e:	f8c5 3540 	str.w	r3, [r5, #1344]	; 0x540
	}

	return 0;
    4162:	4620      	mov	r0, r4
}
    4164:	b002      	add	sp, #8
    4166:	bd70      	pop	{r4, r5, r6, pc}
		return -1;
    4168:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    416c:	e7fa      	b.n	4164 <z_clock_driver_init+0x68>
    416e:	bf00      	nop
    4170:	0001fc32 	.word	0x0001fc32
    4174:	40011000 	.word	0x40011000
    4178:	e000e100 	.word	0xe000e100
    417c:	40011008 	.word	0x40011008

00004180 <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
    4180:	b5f0      	push	{r4, r5, r6, r7, lr}
	ARG_UNUSED(idle);

#ifdef CONFIG_TICKLESS_KERNEL
	ticks = (ticks == K_FOREVER) ? MAX_TICKS : ticks;
    4182:	4e25      	ldr	r6, [pc, #148]	; (4218 <z_clock_set_timeout+0x98>)
    4184:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    4188:	bf08      	it	eq
    418a:	4630      	moveq	r0, r6
	__asm__ volatile(
    418c:	f04f 0320 	mov.w	r3, #32
    4190:	f3ef 8511 	mrs	r5, BASEPRI
    4194:	f383 8811 	msr	BASEPRI, r3
    4198:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
    419c:	491f      	ldr	r1, [pc, #124]	; (421c <z_clock_set_timeout+0x9c>)
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t cyc, dt, t = counter();
	u32_t unannounced = counter_sub(t, last_count);
    419e:	4b20      	ldr	r3, [pc, #128]	; (4220 <z_clock_set_timeout+0xa0>)
    41a0:	f8d1 4504 	ldr.w	r4, [r1, #1284]	; 0x504
    41a4:	681b      	ldr	r3, [r3, #0]
	return (a - b) & COUNTER_MAX;
    41a6:	1ae2      	subs	r2, r4, r3
    41a8:	f022 477f 	bic.w	r7, r2, #4278190080	; 0xff000000
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
    41ac:	0212      	lsls	r2, r2, #8
    41ae:	d419      	bmi.n	41e4 <z_clock_set_timeout+0x64>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
    41b0:	1e42      	subs	r2, r0, #1
    41b2:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    41b6:	42b2      	cmp	r2, r6
    41b8:	bfa8      	it	ge
    41ba:	4632      	movge	r2, r6
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    41bc:	1c78      	adds	r0, r7, #1
    41be:	4410      	add	r0, r2
	 */
	if (cyc > MAX_CYCLES) {
		cyc = MAX_CYCLES;
	}

	cyc += last_count;
    41c0:	42b0      	cmp	r0, r6
    41c2:	bf94      	ite	ls
    41c4:	1818      	addls	r0, r3, r0
    41c6:	1998      	addhi	r0, r3, r6
	return (a - b) & COUNTER_MAX;
    41c8:	1b04      	subs	r4, r0, r4
    41ca:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
    41ce:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
	 * least on nRF52.  Some experimentation on nrf52840 shows
	 * that you need to be early by about 400 processor cycles
	 * (about 1/5th of a RTC cycle) in order to reliably get the
	 * interrupt.  The docs say two cycles, they mean two cycles.
	 */
	if (counter_sub(cyc, t) > 2) {
    41d2:	2c02      	cmp	r4, #2
    p_reg->CC[ch] = cc_val;
    41d4:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
    41d8:	d906      	bls.n	41e8 <z_clock_set_timeout+0x68>
	__asm__ volatile(
    41da:	f385 8811 	msr	BASEPRI, r5
    41de:	f3bf 8f6f 	isb	sy
	}
#endif

	k_spin_unlock(&lock, key);
#endif /* CONFIG_TICKLESS_KERNEL */
}
    41e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		ticks = 0;
    41e4:	2200      	movs	r2, #0
    41e6:	e7e9      	b.n	41bc <z_clock_set_timeout+0x3c>
     return p_reg->COUNTER;
    41e8:	f8d1 3504 	ldr.w	r3, [r1, #1284]	; 0x504
		if (dt == 0 || dt > 0x7fffff) {
    41ec:	4a0d      	ldr	r2, [pc, #52]	; (4224 <z_clock_set_timeout+0xa4>)
	return (a - b) & COUNTER_MAX;
    41ee:	1ac3      	subs	r3, r0, r3
    41f0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		if (dt == 0 || dt > 0x7fffff) {
    41f4:	1e5c      	subs	r4, r3, #1
    41f6:	4294      	cmp	r4, r2
    41f8:	d905      	bls.n	4206 <z_clock_set_timeout+0x86>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    41fa:	4b0b      	ldr	r3, [pc, #44]	; (4228 <z_clock_set_timeout+0xa8>)
    41fc:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    4200:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    4204:	e7e9      	b.n	41da <z_clock_set_timeout+0x5a>
		} else if (dt == 1) {
    4206:	2b01      	cmp	r3, #1
			set_comparator(cyc + 2);
    4208:	bf02      	ittt	eq
    420a:	3002      	addeq	r0, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    420c:	f020 407f 	biceq.w	r0, r0, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    4210:	f8c1 0540 	streq.w	r0, [r1, #1344]	; 0x540
    4214:	e7e1      	b.n	41da <z_clock_set_timeout+0x5a>
    4216:	bf00      	nop
    4218:	00fffffe 	.word	0x00fffffe
    421c:	40011000 	.word	0x40011000
    4220:	20000198 	.word	0x20000198
    4224:	007ffffe 	.word	0x007ffffe
    4228:	e000e100 	.word	0xe000e100

0000422c <z_clock_elapsed>:
	__asm__ volatile(
    422c:	f04f 0220 	mov.w	r2, #32
    4230:	f3ef 8311 	mrs	r3, BASEPRI
    4234:	f382 8811 	msr	BASEPRI, r2
    4238:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
    423c:	4a06      	ldr	r2, [pc, #24]	; (4258 <z_clock_elapsed+0x2c>)
    423e:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
    4242:	4a06      	ldr	r2, [pc, #24]	; (425c <z_clock_elapsed+0x30>)
	return (a - b) & COUNTER_MAX;
    4244:	6812      	ldr	r2, [r2, #0]
    4246:	1a80      	subs	r0, r0, r2
    4248:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	__asm__ volatile(
    424c:	f383 8811 	msr	BASEPRI, r3
    4250:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    4254:	4770      	bx	lr
    4256:	bf00      	nop
    4258:	40011000 	.word	0x40011000
    425c:	20000198 	.word	0x20000198

00004260 <z_timer_cycle_get_32>:
	__asm__ volatile(
    4260:	f04f 0320 	mov.w	r3, #32
    4264:	f3ef 8211 	mrs	r2, BASEPRI
    4268:	f383 8811 	msr	BASEPRI, r3
    426c:	f3bf 8f6f 	isb	sy

u32_t z_timer_cycle_get_32(void)
{
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) + last_count;
    4270:	4906      	ldr	r1, [pc, #24]	; (428c <z_timer_cycle_get_32+0x2c>)
    4272:	4b07      	ldr	r3, [pc, #28]	; (4290 <z_timer_cycle_get_32+0x30>)
    4274:	6808      	ldr	r0, [r1, #0]
    4276:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	__asm__ volatile(
    427a:	f382 8811 	msr	BASEPRI, r2
    427e:	f3bf 8f6f 	isb	sy
	return (a - b) & COUNTER_MAX;
    4282:	1a1b      	subs	r3, r3, r0
    4284:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000

	k_spin_unlock(&lock, key);
	return ret;
}
    4288:	4418      	add	r0, r3
    428a:	4770      	bx	lr
    428c:	20000198 	.word	0x20000198
    4290:	40011000 	.word	0x40011000

00004294 <z_arm_exc_exit>:
    /* r0 contains the caller mode */
    push {r0, lr}
#endif

#ifdef CONFIG_PREEMPT_ENABLED
    ldr r0, =_kernel
    4294:	4804      	ldr	r0, [pc, #16]	; (42a8 <_EXIT_EXC+0x2>)

    ldr r1, [r0, #_kernel_offset_to_current]
    4296:	6881      	ldr	r1, [r0, #8]

    ldr r0, [r0, #_kernel_offset_to_ready_q_cache]
    4298:	6a40      	ldr	r0, [r0, #36]	; 0x24
    cmp r0, r1
    429a:	4288      	cmp	r0, r1
    beq _EXIT_EXC
    429c:	d003      	beq.n	42a6 <_EXIT_EXC>

#if defined(CONFIG_CPU_CORTEX_M)
    /* context switch required, pend the PendSV exception */
    ldr r1, =_SCS_ICSR
    429e:	4903      	ldr	r1, [pc, #12]	; (42ac <_EXIT_EXC+0x6>)
    ldr r2, =_SCS_ICSR_PENDSV
    42a0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    str r2, [r1]
    42a4:	600a      	str	r2, [r1, #0]

000042a6 <_EXIT_EXC>:
    bl z_check_stack_sentinel
#endif /* CONFIG_CPU_CORTEX_M */
#endif /* CONFIG_STACK_SENTINEL */

#if defined(CONFIG_CPU_CORTEX_M)
    bx lr
    42a6:	4770      	bx	lr
    ldr r0, =_kernel
    42a8:	20001a24 	.word	0x20001a24
    ldr r1, =_SCS_ICSR
    42ac:	e000ed04 	.word	0xe000ed04

000042b0 <arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
    42b0:	4a09      	ldr	r2, [pc, #36]	; (42d8 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
    42b2:	490a      	ldr	r1, [pc, #40]	; (42dc <arch_swap+0x2c>)
	_current->arch.basepri = key;
    42b4:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    42b6:	6809      	ldr	r1, [r1, #0]
    42b8:	6699      	str	r1, [r3, #104]	; 0x68

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    42ba:	4909      	ldr	r1, [pc, #36]	; (42e0 <arch_swap+0x30>)
	_current->arch.basepri = key;
    42bc:	6658      	str	r0, [r3, #100]	; 0x64
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    42be:	684b      	ldr	r3, [r1, #4]
    42c0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    42c4:	604b      	str	r3, [r1, #4]
    42c6:	2300      	movs	r3, #0
    42c8:	f383 8811 	msr	BASEPRI, r3
    42cc:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    42d0:	6893      	ldr	r3, [r2, #8]
}
    42d2:	6e98      	ldr	r0, [r3, #104]	; 0x68
    42d4:	4770      	bx	lr
    42d6:	bf00      	nop
    42d8:	20001a24 	.word	0x20001a24
    42dc:	0001f784 	.word	0x0001f784
    42e0:	e000ed00 	.word	0xe000ed00

000042e4 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    42e4:	4912      	ldr	r1, [pc, #72]	; (4330 <z_arm_pendsv+0x4c>)
    ldr r2, [r1, #_kernel_offset_to_current]
    42e6:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    42e8:	f04f 0028 	mov.w	r0, #40	; 0x28
    add r0, r2
    42ec:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    42ee:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    42f2:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    42f6:	2020      	movs	r0, #32
    msr BASEPRI, r0
    42f8:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    42fc:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    4300:	4f0c      	ldr	r7, [pc, #48]	; (4334 <z_arm_pendsv+0x50>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    4302:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    4306:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
    4308:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    430a:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    430c:	6e50      	ldr	r0, [r2, #100]	; 0x64
    movs r3, #0
    430e:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    4310:	6653      	str	r3, [r2, #100]	; 0x64
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    4312:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined (CONFIG_ARM_MPU)
    /* Re-program dynamic memory map */
    push {r2,lr}
    4316:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
    4318:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
    431a:	f016 fda1 	bl	1ae60 <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
    431e:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    4322:	f102 0028 	add.w	r0, r2, #40	; 0x28
    ldmia r0, {v1-v8, ip}
    4326:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
    mov r0, #0
    msr PSPLIM, r0
#endif /* CONFIG_BUILTIN_STACK_GUARD */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    432a:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
    432e:	4770      	bx	lr
    ldr r1, =_kernel
    4330:	20001a24 	.word	0x20001a24
    ldr v4, =_SCS_ICSR
    4334:	e000ed04 	.word	0xe000ed04

00004338 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
    4338:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    433c:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    433e:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    4342:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    4346:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    4348:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    434c:	2902      	cmp	r1, #2
    beq _oops
    434e:	d0ff      	beq.n	4350 <_oops>

00004350 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    4350:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    4352:	f016 fd7a 	bl	1ae4a <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    4356:	bd01      	pop	{r0, pc}

00004358 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    4358:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    435a:	2b00      	cmp	r3, #0
    435c:	db08      	blt.n	4370 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    435e:	2201      	movs	r2, #1
    4360:	f000 001f 	and.w	r0, r0, #31
    4364:	fa02 f000 	lsl.w	r0, r2, r0
    4368:	095b      	lsrs	r3, r3, #5
    436a:	4a02      	ldr	r2, [pc, #8]	; (4374 <arch_irq_enable+0x1c>)
    436c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    4370:	4770      	bx	lr
    4372:	bf00      	nop
    4374:	e000e100 	.word	0xe000e100

00004378 <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
    4378:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    437a:	2b00      	cmp	r3, #0
    437c:	db0d      	blt.n	439a <arch_irq_disable+0x22>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    437e:	2201      	movs	r2, #1
    4380:	095b      	lsrs	r3, r3, #5
    4382:	f000 001f 	and.w	r0, r0, #31
    4386:	fa02 f000 	lsl.w	r0, r2, r0
    438a:	3320      	adds	r3, #32
    438c:	4a03      	ldr	r2, [pc, #12]	; (439c <arch_irq_disable+0x24>)
    438e:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    4392:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    4396:	f3bf 8f6f 	isb	sy
}
    439a:	4770      	bx	lr
    439c:	e000e100 	.word	0xe000e100

000043a0 <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    43a0:	0942      	lsrs	r2, r0, #5
    43a2:	4b05      	ldr	r3, [pc, #20]	; (43b8 <arch_irq_is_enabled+0x18>)
    43a4:	f000 001f 	and.w	r0, r0, #31
    43a8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    43ac:	2301      	movs	r3, #1
    43ae:	fa03 f000 	lsl.w	r0, r3, r0
}
    43b2:	4010      	ands	r0, r2
    43b4:	4770      	bx	lr
    43b6:	bf00      	nop
    43b8:	e000e100 	.word	0xe000e100

000043bc <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(DT_NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    43bc:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    43be:	2b00      	cmp	r3, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    43c0:	bfa8      	it	ge
    43c2:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
	prio += _IRQ_PRIO_OFFSET;
    43c6:	f101 0101 	add.w	r1, r1, #1
    43ca:	ea4f 1141 	mov.w	r1, r1, lsl #5
    43ce:	bfae      	itee	ge
    43d0:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    43d4:	f000 000f 	andlt.w	r0, r0, #15
    43d8:	4b03      	ldrlt	r3, [pc, #12]	; (43e8 <z_arm_irq_priority_set+0x2c>)
    43da:	b2c9      	uxtb	r1, r1
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    43dc:	bfac      	ite	ge
    43de:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    43e2:	5419      	strblt	r1, [r3, r0]
}
    43e4:	4770      	bx	lr
    43e6:	bf00      	nop
    43e8:	e000ed14 	.word	0xe000ed14

000043ec <_arch_isr_direct_pm>:
	z_arm_reserved();
}

#ifdef CONFIG_SYS_POWER_MANAGEMENT
void _arch_isr_direct_pm(void)
{
    43ec:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
    43ee:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
    43f0:	4b04      	ldr	r3, [pc, #16]	; (4404 <_arch_isr_direct_pm+0x18>)
    43f2:	6a18      	ldr	r0, [r3, #32]
    43f4:	b118      	cbz	r0, 43fe <_arch_isr_direct_pm+0x12>
		s32_t idle_val = _kernel.idle;

		_kernel.idle = 0;
    43f6:	2200      	movs	r2, #0
    43f8:	621a      	str	r2, [r3, #32]
		z_sys_power_save_idle_exit(idle_val);
    43fa:	f019 ff0f 	bl	1e21c <z_sys_power_save_idle_exit>

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
    43fe:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
    4400:	bd08      	pop	{r3, pc}
    4402:	bf00      	nop
    4404:	20001a24 	.word	0x20001a24

00004408 <arch_new_thread>:
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     size_t stackSize, k_thread_entry_t pEntry,
		     void *parameter1, void *parameter2, void *parameter3,
		     int priority, unsigned int options)
{
    4408:	b573      	push	{r0, r1, r4, r5, r6, lr}
    440a:	461e      	mov	r6, r3
#endif
	stackEnd = pStackMem + stackSize;

	struct __esf *pInitCtx;

	z_new_thread_init(thread, pStackMem, stackSize, priority,
    440c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    440e:	9300      	str	r3, [sp, #0]
	stackEnd = pStackMem + stackSize;
    4410:	188c      	adds	r4, r1, r2
	z_new_thread_init(thread, pStackMem, stackSize, priority,
    4412:	9b09      	ldr	r3, [sp, #36]	; 0x24
{
    4414:	4605      	mov	r5, r0
	z_new_thread_init(thread, pStackMem, stackSize, priority,
    4416:	f01a f929 	bl	1e66c <z_new_thread_init>
	 *
	 * The initial carved stack frame only needs to contain the basic
	 * stack frame (state context), because no FP operations have been
	 * performed yet for this thread.
	 */
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
    441a:	f1a4 0320 	sub.w	r3, r4, #32
	pInitCtx->basic.pc = (u32_t)z_thread_entry;
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
    441e:	4a0a      	ldr	r2, [pc, #40]	; (4448 <arch_new_thread+0x40>)
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
    4420:	f023 0307 	bic.w	r3, r3, #7
	pInitCtx->basic.pc &= 0xfffffffe;
    4424:	f022 0201 	bic.w	r2, r2, #1
    4428:	619a      	str	r2, [r3, #24]
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
	pInitCtx->basic.a2 = (u32_t)parameter1;
    442a:	9a06      	ldr	r2, [sp, #24]
    442c:	605a      	str	r2, [r3, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
    442e:	9a07      	ldr	r2, [sp, #28]
    4430:	609a      	str	r2, [r3, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
    4432:	9a08      	ldr	r2, [sp, #32]
    4434:	60da      	str	r2, [r3, #12]
	pInitCtx->basic.xpsr =
    4436:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
	pInitCtx->basic.a1 = (u32_t)pEntry;
    443a:	601e      	str	r6, [r3, #0]
	pInitCtx->basic.xpsr =
    443c:	61da      	str	r2, [r3, #28]
		0x01000000UL; /* clear all, thumb bit is 1, even if RO */

	thread->callee_saved.psp = (u32_t)pInitCtx;
    443e:	64ab      	str	r3, [r5, #72]	; 0x48
#if defined(CONFIG_CPU_CORTEX_R)
	pInitCtx->basic.lr = (u32_t)pInitCtx->basic.pc;
	thread->callee_saved.spsr = A_BIT | T_BIT | MODE_SYS;
	thread->callee_saved.lr = (u32_t)pInitCtx->basic.pc;
#endif
	thread->arch.basepri = 0;
    4440:	2300      	movs	r3, #0
    4442:	666b      	str	r3, [r5, #100]	; 0x64

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    4444:	b002      	add	sp, #8
    4446:	bd70      	pop	{r4, r5, r6, pc}
    4448:	000193a9 	.word	0x000193a9

0000444c <arch_switch_to_main_thread>:

void arch_switch_to_main_thread(struct k_thread *main_thread,
				k_thread_stack_t *main_stack,
				size_t main_stack_size,
				k_thread_entry_t _main)
{
    444c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    444e:	4605      	mov	r5, r0
    4450:	460c      	mov	r4, r1
    4452:	4617      	mov	r7, r2
    4454:	461e      	mov	r6, r3
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    4456:	f000 fb93 	bl	4b80 <z_arm_configure_static_mpu_regions>
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);

	_current = main_thread;
    445a:	4b0a      	ldr	r3, [pc, #40]	; (4484 <arch_switch_to_main_thread+0x38>)
	start_of_main_stack =
    445c:	443c      	add	r4, r7
#ifdef CONFIG_ARM_MPU
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
    445e:	4628      	mov	r0, r5
	_current = main_thread;
    4460:	609d      	str	r5, [r3, #8]
	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);
    4462:	f024 0407 	bic.w	r4, r4, #7
	z_arm_configure_dynamic_mpu_regions(main_thread);
    4466:	f016 fcfb 	bl	1ae60 <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    446a:	4630      	mov	r0, r6
    446c:	f384 8809 	msr	PSP, r4
    4470:	2100      	movs	r1, #0
    4472:	b663      	cpsie	if
    4474:	f381 8811 	msr	BASEPRI, r1
    4478:	f3bf 8f6f 	isb	sy
    447c:	2200      	movs	r2, #0
    447e:	2300      	movs	r3, #0
    4480:	f014 ff92 	bl	193a8 <z_thread_entry>
	:
	: "r" (_main), "r" (start_of_main_stack)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    4484:	20001a24 	.word	0x20001a24

00004488 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr r1, =_SCB_SCR
    4488:	4901      	ldr	r1, [pc, #4]	; (4490 <z_arm_cpu_idle_init+0x8>)
	movs.n r2, #_SCR_INIT_BITS
    448a:	2210      	movs	r2, #16
	str r2, [r1]
    448c:	600a      	str	r2, [r1, #0]
#endif
	bx lr
    448e:	4770      	bx	lr
	ldr r1, =_SCB_SCR
    4490:	e000ed10 	.word	0xe000ed10

00004494 <arch_cpu_idle>:
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	cpsie i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* clear BASEPRI so wfi is awakened by incoming interrupts */
	eors.n r0, r0
    4494:	4040      	eors	r0, r0
	msr BASEPRI, r0
    4496:	f380 8811 	msr	BASEPRI, r0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	wfi
    449a:	bf30      	wfi

	bx lr
    449c:	4770      	bx	lr
    449e:	bf00      	nop

000044a0 <z_arm_bus_fault>:
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_reserved)

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) || \
	defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	mrs r0, MSP
    44a0:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    44a4:	f3ef 8109 	mrs	r1, PSP
	mov r2, lr /* EXC_RETURN */
    44a8:	4672      	mov	r2, lr

	push {r0, lr}
    44aa:	b501      	push	{r0, lr}
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE || CONFIG_ARMv7_M_ARMV8_M_MAINLINE */

	bl z_arm_fault
    44ac:	f000 fa46 	bl	493c <z_arm_fault>

#if defined(CONFIG_CPU_CORTEX_M)
	pop {r0, pc}
    44b0:	bd01      	pop	{r0, pc}
    44b2:	bf00      	nop

000044b4 <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    44b4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    44b6:	4606      	mov	r6, r0

	if (esf != NULL) {
    44b8:	460c      	mov	r4, r1
    44ba:	2900      	cmp	r1, #0
    44bc:	d038      	beq.n	4530 <z_arm_fatal_error+0x7c>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
    44be:	2201      	movs	r2, #1
    44c0:	f04f 0300 	mov.w	r3, #0
    44c4:	f362 0307 	bfi	r3, r2, #0, #8
    44c8:	4d1d      	ldr	r5, [pc, #116]	; (4540 <z_arm_fatal_error+0x8c>)
    44ca:	4a1e      	ldr	r2, [pc, #120]	; (4544 <z_arm_fatal_error+0x90>)
    44cc:	481e      	ldr	r0, [pc, #120]	; (4548 <z_arm_fatal_error+0x94>)
    44ce:	1aad      	subs	r5, r5, r2
    44d0:	f3c5 05c9 	ubfx	r5, r5, #3, #10
    44d4:	f365 138f 	bfi	r3, r5, #6, #10
    44d8:	f8ad 3000 	strh.w	r3, [sp]
    44dc:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
    44e0:	6809      	ldr	r1, [r1, #0]
    44e2:	f016 f8cf 	bl	1a684 <log_3>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
    44e6:	2201      	movs	r2, #1
    44e8:	f04f 0300 	mov.w	r3, #0
    44ec:	f362 0307 	bfi	r3, r2, #0, #8
    44f0:	f365 138f 	bfi	r3, r5, #6, #10
    44f4:	f8ad 3000 	strh.w	r3, [sp]
    44f8:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    44fc:	68e1      	ldr	r1, [r4, #12]
    44fe:	4813      	ldr	r0, [pc, #76]	; (454c <z_arm_fatal_error+0x98>)
    4500:	f016 f8c0 	bl	1a684 <log_3>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
    4504:	2301      	movs	r3, #1
    4506:	f04f 0200 	mov.w	r2, #0
    450a:	f363 0207 	bfi	r2, r3, #0, #8
    450e:	f365 128f 	bfi	r2, r5, #6, #10
    4512:	69e1      	ldr	r1, [r4, #28]
    4514:	480e      	ldr	r0, [pc, #56]	; (4550 <z_arm_fatal_error+0x9c>)
    4516:	f016 f889 	bl	1a62c <log_1>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    451a:	f04f 0200 	mov.w	r2, #0
    451e:	2301      	movs	r3, #1
    4520:	f363 0207 	bfi	r2, r3, #0, #8
    4524:	f365 128f 	bfi	r2, r5, #6, #10
    4528:	69a1      	ldr	r1, [r4, #24]
    452a:	480a      	ldr	r0, [pc, #40]	; (4554 <z_arm_fatal_error+0xa0>)
    452c:	f016 f87e 	bl	1a62c <log_1>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
    4530:	4621      	mov	r1, r4
    4532:	4630      	mov	r0, r6
}
    4534:	b002      	add	sp, #8
    4536:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_fatal_error(reason, esf);
    453a:	f013 b941 	b.w	177c0 <z_fatal_error>
    453e:	bf00      	nop
    4540:	0001ee58 	.word	0x0001ee58
    4544:	0001ed28 	.word	0x0001ed28
    4548:	0001fc5c 	.word	0x0001fc5c
    454c:	0001fc8b 	.word	0x0001fc8b
    4550:	0001fcba 	.word	0x0001fcba
    4554:	0001fcc9 	.word	0x0001fcc9

00004558 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    4558:	bf30      	wfi
    b z_SysNmiOnReset
    455a:	f7ff bffd 	b.w	4558 <z_SysNmiOnReset>
    455e:	bf00      	nop

00004560 <z_arm_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    4560:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    4562:	4b08      	ldr	r3, [pc, #32]	; (4584 <z_arm_prep_c+0x24>)
    4564:	4a08      	ldr	r2, [pc, #32]	; (4588 <z_arm_prep_c+0x28>)
    4566:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    456a:	6093      	str	r3, [r2, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    456c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    4570:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
	enable_floating_point();
	z_bss_zero();
    4574:	f013 f9a2 	bl	178bc <z_bss_zero>
	z_data_copy();
    4578:	f013 f9aa 	bl	178d0 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_int_lib_init();
    457c:	f000 face 	bl	4b1c <z_arm_int_lib_init>
	z_cstart();
    4580:	f013 f9d8 	bl	17934 <z_cstart>
    4584:	00000000 	.word	0x00000000
    4588:	e000ed00 	.word	0xe000ed00

0000458c <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    458c:	b501      	push	{r0, lr}
      * FIXME: Remove the Cortex-M conditional compilation checks for `cpsid i`
      *        and `cpsie i` after the Cortex-R port is updated to support
      *        interrupt nesting.  For more details, refer to the issue #21758.
      */
#if defined(CONFIG_CPU_CORTEX_M)
	cpsid i  /* PRIMASK = 1 */
    458e:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    4590:	4a0b      	ldr	r2, [pc, #44]	; (45c0 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    4592:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
    4594:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    4596:	bf1e      	ittt	ne
	movne	r1, #0
    4598:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    459a:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
    459c:	f019 fe3e 	blne	1e21c <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    45a0:	b662      	cpsie	i
#endif

#endif /* CONFIG_SYS_POWER_MANAGEMENT */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    45a2:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    45a6:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    45aa:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 */
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldr r1, =_sw_isr_table
    45ae:	4905      	ldr	r1, [pc, #20]	; (45c4 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    45b0:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    45b2:	c909      	ldmia	r1!, {r0, r3}
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldm sp!,{r0-r3} /* Restore r0 to r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
    45b4:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    45b6:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    45ba:	4903      	ldr	r1, [pc, #12]	; (45c8 <_isr_wrapper+0x3c>)
	bx r1
    45bc:	4708      	bx	r1
    45be:	0000      	.short	0x0000
	ldr r2, =_kernel
    45c0:	20001a24 	.word	0x20001a24
	ldr r1, =_sw_isr_table
    45c4:	0001ea98 	.word	0x0001ea98
	ldr r1, =z_arm_int_exit
    45c8:	00004295 	.word	0x00004295

000045cc <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
    45cc:	f016 fd61 	bl	1b092 <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    45d0:	2020      	movs	r0, #32
    msr BASEPRI, r0
    45d2:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to _interrupt_stack during initialization.
     */
    ldr r0, =_interrupt_stack
    45d6:	4808      	ldr	r0, [pc, #32]	; (45f8 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
    45d8:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
    45dc:	1840      	adds	r0, r0, r1
    msr PSP, r0
    45de:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    45e2:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    45e6:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    45e8:	4308      	orrs	r0, r1
    msr CONTROL, r0
    45ea:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    45ee:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    45f2:	f7ff ffb5 	bl	4560 <z_arm_prep_c>
    45f6:	0000      	.short	0x0000
    ldr r0, =_interrupt_stack
    45f8:	200038b0 	.word	0x200038b0

000045fc <usage_fault.isra.2>:
 */
static u32_t usage_fault(const z_arch_esf_t *esf)
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
    45fc:	2301      	movs	r3, #1
    45fe:	f04f 0100 	mov.w	r1, #0
static u32_t usage_fault(const z_arch_esf_t *esf)
    4602:	b510      	push	{r4, lr}
	PR_FAULT_INFO("***** USAGE FAULT *****");
    4604:	f363 0107 	bfi	r1, r3, #0, #8
    4608:	4c33      	ldr	r4, [pc, #204]	; (46d8 <usage_fault.isra.2+0xdc>)
    460a:	4b34      	ldr	r3, [pc, #208]	; (46dc <usage_fault.isra.2+0xe0>)
    460c:	4834      	ldr	r0, [pc, #208]	; (46e0 <usage_fault.isra.2+0xe4>)
    460e:	1ae4      	subs	r4, r4, r3
    4610:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    4614:	f364 118f 	bfi	r1, r4, #6, #10
    4618:	f015 fffb 	bl	1a612 <log_0>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    461c:	4b31      	ldr	r3, [pc, #196]	; (46e4 <usage_fault.isra.2+0xe8>)
    461e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4620:	019a      	lsls	r2, r3, #6
    4622:	d509      	bpl.n	4638 <usage_fault.isra.2+0x3c>
		PR_FAULT_INFO("  Division by zero");
    4624:	f04f 0100 	mov.w	r1, #0
    4628:	2301      	movs	r3, #1
    462a:	f363 0107 	bfi	r1, r3, #0, #8
    462e:	f364 118f 	bfi	r1, r4, #6, #10
    4632:	482d      	ldr	r0, [pc, #180]	; (46e8 <usage_fault.isra.2+0xec>)
    4634:	f015 ffed 	bl	1a612 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    4638:	4b2a      	ldr	r3, [pc, #168]	; (46e4 <usage_fault.isra.2+0xe8>)
    463a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    463c:	01db      	lsls	r3, r3, #7
    463e:	d509      	bpl.n	4654 <usage_fault.isra.2+0x58>
		PR_FAULT_INFO("  Unaligned memory access");
    4640:	f04f 0100 	mov.w	r1, #0
    4644:	2301      	movs	r3, #1
    4646:	f363 0107 	bfi	r1, r3, #0, #8
    464a:	f364 118f 	bfi	r1, r4, #6, #10
    464e:	4827      	ldr	r0, [pc, #156]	; (46ec <usage_fault.isra.2+0xf0>)
    4650:	f015 ffdf 	bl	1a612 <log_0>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    4654:	4b23      	ldr	r3, [pc, #140]	; (46e4 <usage_fault.isra.2+0xe8>)
    4656:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4658:	0318      	lsls	r0, r3, #12
    465a:	d509      	bpl.n	4670 <usage_fault.isra.2+0x74>
		PR_FAULT_INFO("  No coprocessor instructions");
    465c:	f04f 0100 	mov.w	r1, #0
    4660:	2301      	movs	r3, #1
    4662:	f363 0107 	bfi	r1, r3, #0, #8
    4666:	f364 118f 	bfi	r1, r4, #6, #10
    466a:	4821      	ldr	r0, [pc, #132]	; (46f0 <usage_fault.isra.2+0xf4>)
    466c:	f015 ffd1 	bl	1a612 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    4670:	4b1c      	ldr	r3, [pc, #112]	; (46e4 <usage_fault.isra.2+0xe8>)
    4672:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4674:	0359      	lsls	r1, r3, #13
    4676:	d509      	bpl.n	468c <usage_fault.isra.2+0x90>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
    4678:	f04f 0100 	mov.w	r1, #0
    467c:	2301      	movs	r3, #1
    467e:	f363 0107 	bfi	r1, r3, #0, #8
    4682:	f364 118f 	bfi	r1, r4, #6, #10
    4686:	481b      	ldr	r0, [pc, #108]	; (46f4 <usage_fault.isra.2+0xf8>)
    4688:	f015 ffc3 	bl	1a612 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    468c:	4b15      	ldr	r3, [pc, #84]	; (46e4 <usage_fault.isra.2+0xe8>)
    468e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4690:	039a      	lsls	r2, r3, #14
    4692:	d509      	bpl.n	46a8 <usage_fault.isra.2+0xac>
		PR_FAULT_INFO("  Illegal use of the EPSR");
    4694:	f04f 0100 	mov.w	r1, #0
    4698:	2301      	movs	r3, #1
    469a:	f363 0107 	bfi	r1, r3, #0, #8
    469e:	f364 118f 	bfi	r1, r4, #6, #10
    46a2:	4815      	ldr	r0, [pc, #84]	; (46f8 <usage_fault.isra.2+0xfc>)
    46a4:	f015 ffb5 	bl	1a612 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    46a8:	4b0e      	ldr	r3, [pc, #56]	; (46e4 <usage_fault.isra.2+0xe8>)
    46aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    46ac:	03db      	lsls	r3, r3, #15
    46ae:	d509      	bpl.n	46c4 <usage_fault.isra.2+0xc8>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
    46b0:	f04f 0100 	mov.w	r1, #0
    46b4:	2301      	movs	r3, #1
    46b6:	f363 0107 	bfi	r1, r3, #0, #8
    46ba:	f364 118f 	bfi	r1, r4, #6, #10
    46be:	480f      	ldr	r0, [pc, #60]	; (46fc <usage_fault.isra.2+0x100>)
    46c0:	f015 ffa7 	bl	1a612 <log_0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    46c4:	4a07      	ldr	r2, [pc, #28]	; (46e4 <usage_fault.isra.2+0xe8>)
    46c6:	6a93      	ldr	r3, [r2, #40]	; 0x28
    46c8:	ea6f 4303 	mvn.w	r3, r3, lsl #16
    46cc:	ea6f 4313 	mvn.w	r3, r3, lsr #16
    46d0:	6293      	str	r3, [r2, #40]	; 0x28

	return reason;
}
    46d2:	2000      	movs	r0, #0
    46d4:	bd10      	pop	{r4, pc}
    46d6:	bf00      	nop
    46d8:	0001ee58 	.word	0x0001ee58
    46dc:	0001ed28 	.word	0x0001ed28
    46e0:	0001fe57 	.word	0x0001fe57
    46e4:	e000ed00 	.word	0xe000ed00
    46e8:	0001fe6f 	.word	0x0001fe6f
    46ec:	0001fe82 	.word	0x0001fe82
    46f0:	0001fe9c 	.word	0x0001fe9c
    46f4:	0001feba 	.word	0x0001feba
    46f8:	0001fedf 	.word	0x0001fedf
    46fc:	0001fef9 	.word	0x0001fef9

00004700 <mem_manage_fault.isra.4>:
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
    4700:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	PR_FAULT_INFO("***** MPU FAULT *****");
    4702:	2301      	movs	r3, #1
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
    4704:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
    4706:	f04f 0100 	mov.w	r1, #0
    470a:	f363 0107 	bfi	r1, r3, #0, #8
    470e:	4c36      	ldr	r4, [pc, #216]	; (47e8 <mem_manage_fault.isra.4+0xe8>)
    4710:	4b36      	ldr	r3, [pc, #216]	; (47ec <mem_manage_fault.isra.4+0xec>)
    4712:	1ae4      	subs	r4, r4, r3
    4714:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    4718:	f364 118f 	bfi	r1, r4, #6, #10
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
    471c:	4607      	mov	r7, r0
	PR_FAULT_INFO("***** MPU FAULT *****");
    471e:	4834      	ldr	r0, [pc, #208]	; (47f0 <mem_manage_fault.isra.4+0xf0>)
    4720:	f015 ff77 	bl	1a612 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    4724:	4b33      	ldr	r3, [pc, #204]	; (47f4 <mem_manage_fault.isra.4+0xf4>)
    4726:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4728:	06d9      	lsls	r1, r3, #27
    472a:	d509      	bpl.n	4740 <mem_manage_fault.isra.4+0x40>
		PR_FAULT_INFO("  Stacking error (context area might be"
    472c:	f04f 0100 	mov.w	r1, #0
    4730:	2301      	movs	r3, #1
    4732:	f363 0107 	bfi	r1, r3, #0, #8
    4736:	f364 118f 	bfi	r1, r4, #6, #10
    473a:	482f      	ldr	r0, [pc, #188]	; (47f8 <mem_manage_fault.isra.4+0xf8>)
    473c:	f015 ff69 	bl	1a612 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    4740:	4b2c      	ldr	r3, [pc, #176]	; (47f4 <mem_manage_fault.isra.4+0xf4>)
    4742:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4744:	071a      	lsls	r2, r3, #28
    4746:	d509      	bpl.n	475c <mem_manage_fault.isra.4+0x5c>
		PR_FAULT_INFO("  Unstacking error");
    4748:	f04f 0100 	mov.w	r1, #0
    474c:	2301      	movs	r3, #1
    474e:	f363 0107 	bfi	r1, r3, #0, #8
    4752:	f364 118f 	bfi	r1, r4, #6, #10
    4756:	4829      	ldr	r0, [pc, #164]	; (47fc <mem_manage_fault.isra.4+0xfc>)
    4758:	f015 ff5b 	bl	1a612 <log_0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    475c:	4d25      	ldr	r5, [pc, #148]	; (47f4 <mem_manage_fault.isra.4+0xf4>)
    475e:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4760:	079b      	lsls	r3, r3, #30
    4762:	d51c      	bpl.n	479e <mem_manage_fault.isra.4+0x9e>
		PR_FAULT_INFO("  Data Access Violation");
    4764:	2301      	movs	r3, #1
    4766:	f04f 0100 	mov.w	r1, #0
    476a:	f363 0107 	bfi	r1, r3, #0, #8
    476e:	f364 118f 	bfi	r1, r4, #6, #10
    4772:	4823      	ldr	r0, [pc, #140]	; (4800 <mem_manage_fault.isra.4+0x100>)
    4774:	f015 ff4d 	bl	1a612 <log_0>
		mmfar = SCB->MMFAR;
    4778:	6b69      	ldr	r1, [r5, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    477a:	6aab      	ldr	r3, [r5, #40]	; 0x28
    477c:	0618      	lsls	r0, r3, #24
    477e:	d50e      	bpl.n	479e <mem_manage_fault.isra.4+0x9e>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
    4780:	f04f 0200 	mov.w	r2, #0
    4784:	2301      	movs	r3, #1
    4786:	f363 0207 	bfi	r2, r3, #0, #8
    478a:	f364 128f 	bfi	r2, r4, #6, #10
    478e:	481d      	ldr	r0, [pc, #116]	; (4804 <mem_manage_fault.isra.4+0x104>)
    4790:	f015 ff4c 	bl	1a62c <log_1>
			if (from_hard_fault) {
    4794:	b11f      	cbz	r7, 479e <mem_manage_fault.isra.4+0x9e>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    4796:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4798:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    479c:	62ab      	str	r3, [r5, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    479e:	4b15      	ldr	r3, [pc, #84]	; (47f4 <mem_manage_fault.isra.4+0xf4>)
    47a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    47a2:	07da      	lsls	r2, r3, #31
    47a4:	d509      	bpl.n	47ba <mem_manage_fault.isra.4+0xba>
		PR_FAULT_INFO("  Instruction Access Violation");
    47a6:	f04f 0100 	mov.w	r1, #0
    47aa:	2301      	movs	r3, #1
    47ac:	f363 0107 	bfi	r1, r3, #0, #8
    47b0:	f364 118f 	bfi	r1, r4, #6, #10
    47b4:	4814      	ldr	r0, [pc, #80]	; (4808 <mem_manage_fault.isra.4+0x108>)
    47b6:	f015 ff2c 	bl	1a612 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    47ba:	4b0e      	ldr	r3, [pc, #56]	; (47f4 <mem_manage_fault.isra.4+0xf4>)
    47bc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    47be:	069b      	lsls	r3, r3, #26
    47c0:	d509      	bpl.n	47d6 <mem_manage_fault.isra.4+0xd6>
		PR_FAULT_INFO(
    47c2:	f04f 0100 	mov.w	r1, #0
    47c6:	2301      	movs	r3, #1
    47c8:	f363 0107 	bfi	r1, r3, #0, #8
    47cc:	f364 118f 	bfi	r1, r4, #6, #10
    47d0:	480e      	ldr	r0, [pc, #56]	; (480c <mem_manage_fault.isra.4+0x10c>)
    47d2:	f015 ff1e 	bl	1a612 <log_0>
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
    47d6:	4b07      	ldr	r3, [pc, #28]	; (47f4 <mem_manage_fault.isra.4+0xf4>)
    47d8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    47da:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    47dc:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    47de:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
    47e2:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    47e4:	7030      	strb	r0, [r6, #0]
}
    47e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    47e8:	0001ee58 	.word	0x0001ee58
    47ec:	0001ed28 	.word	0x0001ed28
    47f0:	0001fd7f 	.word	0x0001fd7f
    47f4:	e000ed00 	.word	0xe000ed00
    47f8:	0001fd95 	.word	0x0001fd95
    47fc:	0001fdc8 	.word	0x0001fdc8
    4800:	0001fddb 	.word	0x0001fddb
    4804:	0001fdf3 	.word	0x0001fdf3
    4808:	0001fe09 	.word	0x0001fe09
    480c:	0001fe28 	.word	0x0001fe28

00004810 <bus_fault.isra.5>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    4810:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	PR_FAULT_INFO("***** BUS FAULT *****");
    4812:	2301      	movs	r3, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    4814:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
    4816:	f04f 0100 	mov.w	r1, #0
    481a:	f363 0107 	bfi	r1, r3, #0, #8
    481e:	4c3c      	ldr	r4, [pc, #240]	; (4910 <bus_fault.isra.5+0x100>)
    4820:	4b3c      	ldr	r3, [pc, #240]	; (4914 <bus_fault.isra.5+0x104>)
    4822:	1ae4      	subs	r4, r4, r3
    4824:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    4828:	f364 118f 	bfi	r1, r4, #6, #10
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    482c:	4607      	mov	r7, r0
	PR_FAULT_INFO("***** BUS FAULT *****");
    482e:	483a      	ldr	r0, [pc, #232]	; (4918 <bus_fault.isra.5+0x108>)
    4830:	f015 feef 	bl	1a612 <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    4834:	4b39      	ldr	r3, [pc, #228]	; (491c <bus_fault.isra.5+0x10c>)
    4836:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4838:	04d9      	lsls	r1, r3, #19
    483a:	d509      	bpl.n	4850 <bus_fault.isra.5+0x40>
		PR_FAULT_INFO("  Stacking error");
    483c:	f04f 0100 	mov.w	r1, #0
    4840:	2301      	movs	r3, #1
    4842:	f363 0107 	bfi	r1, r3, #0, #8
    4846:	f364 118f 	bfi	r1, r4, #6, #10
    484a:	4835      	ldr	r0, [pc, #212]	; (4920 <bus_fault.isra.5+0x110>)
    484c:	f015 fee1 	bl	1a612 <log_0>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    4850:	4b32      	ldr	r3, [pc, #200]	; (491c <bus_fault.isra.5+0x10c>)
    4852:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4854:	051a      	lsls	r2, r3, #20
    4856:	d509      	bpl.n	486c <bus_fault.isra.5+0x5c>
		PR_FAULT_INFO("  Unstacking error");
    4858:	f04f 0100 	mov.w	r1, #0
    485c:	2301      	movs	r3, #1
    485e:	f363 0107 	bfi	r1, r3, #0, #8
    4862:	f364 118f 	bfi	r1, r4, #6, #10
    4866:	482f      	ldr	r0, [pc, #188]	; (4924 <bus_fault.isra.5+0x114>)
    4868:	f015 fed3 	bl	1a612 <log_0>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    486c:	4d2b      	ldr	r5, [pc, #172]	; (491c <bus_fault.isra.5+0x10c>)
    486e:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4870:	059b      	lsls	r3, r3, #22
    4872:	d51c      	bpl.n	48ae <bus_fault.isra.5+0x9e>
		PR_FAULT_INFO("  Precise data bus error");
    4874:	2301      	movs	r3, #1
    4876:	f04f 0100 	mov.w	r1, #0
    487a:	f363 0107 	bfi	r1, r3, #0, #8
    487e:	f364 118f 	bfi	r1, r4, #6, #10
    4882:	4829      	ldr	r0, [pc, #164]	; (4928 <bus_fault.isra.5+0x118>)
    4884:	f015 fec5 	bl	1a612 <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
    4888:	6ba9      	ldr	r1, [r5, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    488a:	6aab      	ldr	r3, [r5, #40]	; 0x28
    488c:	0418      	lsls	r0, r3, #16
    488e:	d50e      	bpl.n	48ae <bus_fault.isra.5+0x9e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
    4890:	f04f 0200 	mov.w	r2, #0
    4894:	2301      	movs	r3, #1
    4896:	f363 0207 	bfi	r2, r3, #0, #8
    489a:	f364 128f 	bfi	r2, r4, #6, #10
    489e:	4823      	ldr	r0, [pc, #140]	; (492c <bus_fault.isra.5+0x11c>)
    48a0:	f015 fec4 	bl	1a62c <log_1>
			if (from_hard_fault) {
    48a4:	b11f      	cbz	r7, 48ae <bus_fault.isra.5+0x9e>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    48a6:	6aab      	ldr	r3, [r5, #40]	; 0x28
    48a8:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    48ac:	62ab      	str	r3, [r5, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    48ae:	4b1b      	ldr	r3, [pc, #108]	; (491c <bus_fault.isra.5+0x10c>)
    48b0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    48b2:	0559      	lsls	r1, r3, #21
    48b4:	d509      	bpl.n	48ca <bus_fault.isra.5+0xba>
		PR_FAULT_INFO("  Imprecise data bus error");
    48b6:	f04f 0100 	mov.w	r1, #0
    48ba:	2301      	movs	r3, #1
    48bc:	f363 0107 	bfi	r1, r3, #0, #8
    48c0:	f364 118f 	bfi	r1, r4, #6, #10
    48c4:	481a      	ldr	r0, [pc, #104]	; (4930 <bus_fault.isra.5+0x120>)
    48c6:	f015 fea4 	bl	1a612 <log_0>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    48ca:	4b14      	ldr	r3, [pc, #80]	; (491c <bus_fault.isra.5+0x10c>)
    48cc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    48ce:	05d2      	lsls	r2, r2, #23
    48d0:	d511      	bpl.n	48f6 <bus_fault.isra.5+0xe6>
		PR_FAULT_INFO("  Instruction bus error");
    48d2:	f04f 0100 	mov.w	r1, #0
    48d6:	2301      	movs	r3, #1
    48d8:	f363 0107 	bfi	r1, r3, #0, #8
    48dc:	4815      	ldr	r0, [pc, #84]	; (4934 <bus_fault.isra.5+0x124>)
    48de:	f364 118f 	bfi	r1, r4, #6, #10
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    48e2:	f015 fe96 	bl	1a612 <log_0>
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    48e6:	4a0d      	ldr	r2, [pc, #52]	; (491c <bus_fault.isra.5+0x10c>)
    48e8:	6a93      	ldr	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    48ea:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    48ec:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
    48f0:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    48f2:	7030      	strb	r0, [r6, #0]
}
    48f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    48f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    48f8:	049b      	lsls	r3, r3, #18
    48fa:	d5f4      	bpl.n	48e6 <bus_fault.isra.5+0xd6>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    48fc:	f04f 0100 	mov.w	r1, #0
    4900:	2301      	movs	r3, #1
    4902:	f363 0107 	bfi	r1, r3, #0, #8
    4906:	f364 118f 	bfi	r1, r4, #6, #10
    490a:	480b      	ldr	r0, [pc, #44]	; (4938 <bus_fault.isra.5+0x128>)
    490c:	e7e9      	b.n	48e2 <bus_fault.isra.5+0xd2>
    490e:	bf00      	nop
    4910:	0001ee58 	.word	0x0001ee58
    4914:	0001ed28 	.word	0x0001ed28
    4918:	0001fcf7 	.word	0x0001fcf7
    491c:	e000ed00 	.word	0xe000ed00
    4920:	0001fd0d 	.word	0x0001fd0d
    4924:	0001fdc8 	.word	0x0001fdc8
    4928:	0001fd1e 	.word	0x0001fd1e
    492c:	0001fd37 	.word	0x0001fd37
    4930:	0001fd4c 	.word	0x0001fd4c
    4934:	0001fd67 	.word	0x0001fd67
    4938:	0001fe28 	.word	0x0001fe28

0000493c <z_arm_fault>:
 * @param psp PSP value immediately after the exception occurred
 * @param exc_return EXC_RETURN value present in LR after exception entry.
 *
 */
void z_arm_fault(u32_t msp, u32_t psp, u32_t exc_return)
{
    493c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    4940:	4b64      	ldr	r3, [pc, #400]	; (4ad4 <z_arm_fault+0x198>)
    4942:	685e      	ldr	r6, [r3, #4]
{
    4944:	b08a      	sub	sp, #40	; 0x28
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    4946:	f3c6 0408 	ubfx	r4, r6, #0, #9
    494a:	2500      	movs	r5, #0
    494c:	f385 8811 	msr	BASEPRI, r5
    4950:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    4954:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
    4958:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
    495c:	d111      	bne.n	4982 <z_arm_fault+0x46>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    495e:	f002 030c 	and.w	r3, r2, #12
    4962:	2b08      	cmp	r3, #8
    4964:	d10f      	bne.n	4986 <z_arm_fault+0x4a>
		PR_EXC("SPSEL in thread mode does not indicate PSP");
    4966:	2301      	movs	r3, #1
    4968:	f04f 0100 	mov.w	r1, #0
    496c:	f363 0107 	bfi	r1, r3, #0, #8
    4970:	4a59      	ldr	r2, [pc, #356]	; (4ad8 <z_arm_fault+0x19c>)
    4972:	4b5a      	ldr	r3, [pc, #360]	; (4adc <z_arm_fault+0x1a0>)
    4974:	485a      	ldr	r0, [pc, #360]	; (4ae0 <z_arm_fault+0x1a4>)
    4976:	1a9b      	subs	r3, r3, r2
    4978:	08db      	lsrs	r3, r3, #3
    497a:	f363 118f 	bfi	r1, r3, #6, #10
    497e:	f015 fe48 	bl	1a612 <log_0>
		return NULL;
    4982:	462f      	mov	r7, r5
    4984:	e004      	b.n	4990 <z_arm_fault+0x54>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    4986:	0712      	lsls	r2, r2, #28
			ptr_esf =  (z_arch_esf_t *)psp;
    4988:	bf4e      	itee	mi
    498a:	460f      	movmi	r7, r1
			ptr_esf = (z_arch_esf_t *)msp;
    498c:	4607      	movpl	r7, r0
			*nested_exc = true;
    498e:	2501      	movpl	r5, #1
	*recoverable = false;
    4990:	2300      	movs	r3, #0
    4992:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
    4996:	1ee3      	subs	r3, r4, #3
    4998:	2b09      	cmp	r3, #9
    499a:	d87f      	bhi.n	4a9c <z_arm_fault+0x160>
    499c:	e8df f003 	tbb	[pc, r3]
    49a0:	4c6d6905 	.word	0x4c6d6905
    49a4:	7e7e7e7e 	.word	0x7e7e7e7e
    49a8:	717e      	.short	0x717e
	PR_FAULT_INFO("***** HARD FAULT *****");
    49aa:	2301      	movs	r3, #1
    49ac:	f04f 0100 	mov.w	r1, #0
    49b0:	f363 0107 	bfi	r1, r3, #0, #8
    49b4:	4e49      	ldr	r6, [pc, #292]	; (4adc <z_arm_fault+0x1a0>)
    49b6:	4b48      	ldr	r3, [pc, #288]	; (4ad8 <z_arm_fault+0x19c>)
    49b8:	484a      	ldr	r0, [pc, #296]	; (4ae4 <z_arm_fault+0x1a8>)
    49ba:	1af6      	subs	r6, r6, r3
    49bc:	f3c6 06c9 	ubfx	r6, r6, #3, #10
    49c0:	f366 118f 	bfi	r1, r6, #6, #10
    49c4:	f015 fe25 	bl	1a612 <log_0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    49c8:	4b42      	ldr	r3, [pc, #264]	; (4ad4 <z_arm_fault+0x198>)
    49ca:	6adc      	ldr	r4, [r3, #44]	; 0x2c
	*recoverable = false;
    49cc:	f04f 0800 	mov.w	r8, #0
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    49d0:	f014 0402 	ands.w	r4, r4, #2
	*recoverable = false;
    49d4:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    49d8:	d00b      	beq.n	49f2 <z_arm_fault+0xb6>
		PR_EXC("  Bus fault on vector table read");
    49da:	f04f 0100 	mov.w	r1, #0
    49de:	2301      	movs	r3, #1
    49e0:	f363 0107 	bfi	r1, r3, #0, #8
    49e4:	4840      	ldr	r0, [pc, #256]	; (4ae8 <z_arm_fault+0x1ac>)
    49e6:	f366 118f 	bfi	r1, r6, #6, #10
	PR_FAULT_INFO(
    49ea:	f015 fe12 	bl	1a612 <log_0>
	u32_t reason = K_ERR_CPU_EXCEPTION;
    49ee:	2400      	movs	r4, #0
    49f0:	e025      	b.n	4a3e <z_arm_fault+0x102>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    49f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    49f4:	005b      	lsls	r3, r3, #1
    49f6:	d522      	bpl.n	4a3e <z_arm_fault+0x102>
		PR_EXC("  Fault escalation (see below)");
    49f8:	2301      	movs	r3, #1
    49fa:	f04f 0100 	mov.w	r1, #0
    49fe:	f363 0107 	bfi	r1, r3, #0, #8
    4a02:	f366 118f 	bfi	r1, r6, #6, #10
    4a06:	4839      	ldr	r0, [pc, #228]	; (4aec <z_arm_fault+0x1b0>)
    4a08:	f015 fe03 	bl	1a612 <log_0>
		if (SCB_MMFSR != 0) {
    4a0c:	4b38      	ldr	r3, [pc, #224]	; (4af0 <z_arm_fault+0x1b4>)
    4a0e:	781b      	ldrb	r3, [r3, #0]
    4a10:	b12b      	cbz	r3, 4a1e <z_arm_fault+0xe2>
			reason = mem_manage_fault(esf, 1, recoverable);
    4a12:	f10d 0107 	add.w	r1, sp, #7
    4a16:	2001      	movs	r0, #1
		reason = mem_manage_fault(esf, 0, recoverable);
    4a18:	f7ff fe72 	bl	4700 <mem_manage_fault.isra.4>
    4a1c:	e00e      	b.n	4a3c <z_arm_fault+0x100>
		} else if (SCB_BFSR != 0) {
    4a1e:	4b35      	ldr	r3, [pc, #212]	; (4af4 <z_arm_fault+0x1b8>)
    4a20:	781b      	ldrb	r3, [r3, #0]
    4a22:	b12b      	cbz	r3, 4a30 <z_arm_fault+0xf4>
			reason = bus_fault(esf, 1, recoverable);
    4a24:	f10d 0107 	add.w	r1, sp, #7
    4a28:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
    4a2a:	f7ff fef1 	bl	4810 <bus_fault.isra.5>
    4a2e:	e005      	b.n	4a3c <z_arm_fault+0x100>
		} else if (SCB_UFSR != 0) {
    4a30:	4b31      	ldr	r3, [pc, #196]	; (4af8 <z_arm_fault+0x1bc>)
    4a32:	881b      	ldrh	r3, [r3, #0]
    4a34:	b29b      	uxth	r3, r3
    4a36:	b113      	cbz	r3, 4a3e <z_arm_fault+0x102>
			reason = usage_fault(esf);
    4a38:	f7ff fde0 	bl	45fc <usage_fault.isra.2>
    4a3c:	4604      	mov	r4, r0
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
		"ESF could not be retrieved successfully. Shall never occur.");

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
    4a3e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    4a42:	b99b      	cbnz	r3, 4a6c <z_arm_fault+0x130>
		return;
	}

	/* Copy ESF */
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    4a44:	2220      	movs	r2, #32
    4a46:	4639      	mov	r1, r7
    4a48:	a802      	add	r0, sp, #8
    4a4a:	f016 fad6 	bl	1affa <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    4a4e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4a50:	2d00      	cmp	r5, #0
    4a52:	d03a      	beq.n	4aca <z_arm_fault+0x18e>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    4a54:	f3c3 0208 	ubfx	r2, r3, #0, #9
    4a58:	b922      	cbnz	r2, 4a64 <z_arm_fault+0x128>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    4a5a:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    4a5e:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    4a62:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
    4a64:	a902      	add	r1, sp, #8
    4a66:	4620      	mov	r0, r4
    4a68:	f7ff fd24 	bl	44b4 <z_arm_fatal_error>
}
    4a6c:	b00a      	add	sp, #40	; 0x28
    4a6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
    4a72:	f10d 0107 	add.w	r1, sp, #7
    4a76:	2000      	movs	r0, #0
    4a78:	e7ce      	b.n	4a18 <z_arm_fault+0xdc>
		reason = bus_fault(esf, 0, recoverable);
    4a7a:	f10d 0107 	add.w	r1, sp, #7
    4a7e:	2000      	movs	r0, #0
    4a80:	e7d3      	b.n	4a2a <z_arm_fault+0xee>
	PR_FAULT_INFO(
    4a82:	2301      	movs	r3, #1
    4a84:	f04f 0100 	mov.w	r1, #0
    4a88:	f363 0107 	bfi	r1, r3, #0, #8
    4a8c:	4a12      	ldr	r2, [pc, #72]	; (4ad8 <z_arm_fault+0x19c>)
    4a8e:	4b13      	ldr	r3, [pc, #76]	; (4adc <z_arm_fault+0x1a0>)
    4a90:	481a      	ldr	r0, [pc, #104]	; (4afc <z_arm_fault+0x1c0>)
    4a92:	1a9b      	subs	r3, r3, r2
    4a94:	08db      	lsrs	r3, r3, #3
    4a96:	f363 118f 	bfi	r1, r3, #6, #10
    4a9a:	e7a6      	b.n	49ea <z_arm_fault+0xae>
	PR_FAULT_INFO("***** %s %d) *****",
    4a9c:	2201      	movs	r2, #1
    4a9e:	f04f 0300 	mov.w	r3, #0
    4aa2:	f362 0307 	bfi	r3, r2, #0, #8
    4aa6:	490d      	ldr	r1, [pc, #52]	; (4adc <z_arm_fault+0x1a0>)
    4aa8:	4a0b      	ldr	r2, [pc, #44]	; (4ad8 <z_arm_fault+0x19c>)
    4aaa:	4815      	ldr	r0, [pc, #84]	; (4b00 <z_arm_fault+0x1c4>)
    4aac:	1a89      	subs	r1, r1, r2
    4aae:	08c9      	lsrs	r1, r1, #3
    4ab0:	f416 7ff8 	tst.w	r6, #496	; 0x1f0
    4ab4:	f361 138f 	bfi	r3, r1, #6, #10
    4ab8:	f1a4 0210 	sub.w	r2, r4, #16
    4abc:	4911      	ldr	r1, [pc, #68]	; (4b04 <z_arm_fault+0x1c8>)
    4abe:	bf18      	it	ne
    4ac0:	4601      	movne	r1, r0
    4ac2:	4811      	ldr	r0, [pc, #68]	; (4b08 <z_arm_fault+0x1cc>)
    4ac4:	f015 fdc6 	bl	1a654 <log_2>
    4ac8:	e791      	b.n	49ee <z_arm_fault+0xb2>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    4aca:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    4ace:	f023 0301 	bic.w	r3, r3, #1
    4ad2:	e7c6      	b.n	4a62 <z_arm_fault+0x126>
    4ad4:	e000ed00 	.word	0xe000ed00
    4ad8:	0001ed28 	.word	0x0001ed28
    4adc:	0001ee58 	.word	0x0001ee58
    4ae0:	0001ff24 	.word	0x0001ff24
    4ae4:	0001ff4f 	.word	0x0001ff4f
    4ae8:	0001ff66 	.word	0x0001ff66
    4aec:	0001ff87 	.word	0x0001ff87
    4af0:	e000ed28 	.word	0xe000ed28
    4af4:	e000ed29 	.word	0xe000ed29
    4af8:	e000ed2a 	.word	0xe000ed2a
    4afc:	0001ffa6 	.word	0x0001ffa6
    4b00:	0001fff1 	.word	0x0001fff1
    4b04:	0001ffdc 	.word	0x0001ffdc
    4b08:	0002000a 	.word	0x0002000a

00004b0c <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    4b0c:	4a02      	ldr	r2, [pc, #8]	; (4b18 <z_arm_fault_init+0xc>)
    4b0e:	6953      	ldr	r3, [r2, #20]
    4b10:	f043 0310 	orr.w	r3, r3, #16
    4b14:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    4b16:	4770      	bx	lr
    4b18:	e000ed00 	.word	0xe000ed00

00004b1c <z_arm_int_lib_init>:
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    4b1c:	4804      	ldr	r0, [pc, #16]	; (4b30 <z_arm_int_lib_init+0x14>)
 * @return N/A
 */

void z_arm_int_lib_init(void)
{
	int irq = 0;
    4b1e:	2300      	movs	r3, #0
    4b20:	2120      	movs	r1, #32
    4b22:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    4b24:	3301      	adds	r3, #1
    4b26:	2b27      	cmp	r3, #39	; 0x27
    4b28:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    4b2c:	d1f9      	bne.n	4b22 <z_arm_int_lib_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    4b2e:	4770      	bx	lr
    4b30:	e000e100 	.word	0xe000e100

00004b34 <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
    4b34:	b538      	push	{r3, r4, r5, lr}
    4b36:	4605      	mov	r5, r0
	__asm__ volatile(
    4b38:	f04f 0320 	mov.w	r3, #32
    4b3c:	f3ef 8411 	mrs	r4, BASEPRI
    4b40:	f383 8811 	msr	BASEPRI, r3
    4b44:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
		 "essential thread aborted");

	z_thread_single_abort(thread);
    4b48:	f013 fac2 	bl	180d0 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
    4b4c:	4b0a      	ldr	r3, [pc, #40]	; (4b78 <z_impl_k_thread_abort+0x44>)
    4b4e:	689b      	ldr	r3, [r3, #8]
    4b50:	42ab      	cmp	r3, r5
    4b52:	d10b      	bne.n	4b6c <z_impl_k_thread_abort+0x38>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
    4b54:	4b09      	ldr	r3, [pc, #36]	; (4b7c <z_impl_k_thread_abort+0x48>)
    4b56:	685a      	ldr	r2, [r3, #4]
    4b58:	f3c2 0208 	ubfx	r2, r2, #0, #9
    4b5c:	b912      	cbnz	r2, 4b64 <z_impl_k_thread_abort+0x30>
	int ret;
	z_check_stack_sentinel();
#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
    4b5e:	4620      	mov	r0, r4
    4b60:	f7ff fba6 	bl	42b0 <arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    4b64:	685a      	ldr	r2, [r3, #4]
    4b66:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    4b6a:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
    4b6c:	4620      	mov	r0, r4
}
    4b6e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
    4b72:	f019 bcbf 	b.w	1e4f4 <z_reschedule_irqlock>
    4b76:	bf00      	nop
    4b78:	20001a24 	.word	0x20001a24
    4b7c:	e000ed00 	.word	0xe000ed00

00004b80 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    4b80:	b51f      	push	{r0, r1, r2, r3, r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
    4b82:	4b08      	ldr	r3, [pc, #32]	; (4ba4 <z_arm_configure_static_mpu_regions+0x24>)
    4b84:	9301      	str	r3, [sp, #4]
    4b86:	4b08      	ldr	r3, [pc, #32]	; (4ba8 <z_arm_configure_static_mpu_regions+0x28>)
    4b88:	9302      	str	r3, [sp, #8]
    4b8a:	4b08      	ldr	r3, [pc, #32]	; (4bac <z_arm_configure_static_mpu_regions+0x2c>)
    4b8c:	9303      	str	r3, [sp, #12]

	/* Define a constant array of k_mem_partition objects
	 * to hold the configuration of the respective static
	 * MPU regions.
	 */
	const struct k_mem_partition *static_regions[] = {
    4b8e:	ab01      	add	r3, sp, #4
    4b90:	9300      	str	r3, [sp, #0]
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    4b92:	4a07      	ldr	r2, [pc, #28]	; (4bb0 <z_arm_configure_static_mpu_regions+0x30>)
    4b94:	4b07      	ldr	r3, [pc, #28]	; (4bb4 <z_arm_configure_static_mpu_regions+0x34>)
    4b96:	2101      	movs	r1, #1
    4b98:	4668      	mov	r0, sp
    4b9a:	f000 f8b5 	bl	4d08 <arm_core_mpu_configure_static_mpu_regions>
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    4b9e:	b005      	add	sp, #20
    4ba0:	f85d fb04 	ldr.w	pc, [sp], #4
    4ba4:	20000000 	.word	0x20000000
    4ba8:	00000000 	.word	0x00000000
    4bac:	060b0000 	.word	0x060b0000
    4bb0:	20000000 	.word	0x20000000
    4bb4:	20010000 	.word	0x20010000

00004bb8 <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct k_mem_partition
	*regions[], u8_t regions_num, u8_t start_reg_index,
	bool do_sanity_check)
{
    4bb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Select the region you want to access */
	MPU->RNR = index;
    4bba:	4f2e      	ldr	r7, [pc, #184]	; (4c74 <mpu_configure_regions+0xbc>)
    4bbc:	460e      	mov	r6, r1
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
    4bbe:	2100      	movs	r1, #0
    4bc0:	42b1      	cmp	r1, r6
    4bc2:	da22      	bge.n	4c0a <mpu_configure_regions+0x52>
		if (regions[i]->size == 0U) {
    4bc4:	f850 c021 	ldr.w	ip, [r0, r1, lsl #2]
    4bc8:	f8dc 4004 	ldr.w	r4, [ip, #4]
    4bcc:	2c00      	cmp	r4, #0
    4bce:	d04f      	beq.n	4c70 <mpu_configure_regions+0xb8>
			continue;
		}
		/* Non-empty region. */

		if (do_sanity_check &&
    4bd0:	b1eb      	cbz	r3, 4c0e <mpu_configure_regions+0x56>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1)) == 0U)
    4bd2:	f104 3eff 	add.w	lr, r4, #4294967295	; 0xffffffff
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
    4bd6:	ea14 0f0e 	tst.w	r4, lr
    4bda:	d106      	bne.n	4bea <mpu_configure_regions+0x32>
		&&
    4bdc:	2c1f      	cmp	r4, #31
    4bde:	d904      	bls.n	4bea <mpu_configure_regions+0x32>
		((part->start & (part->size - 1)) == 0U);
    4be0:	f8dc 5000 	ldr.w	r5, [ip]
		&&
    4be4:	ea1e 0f05 	tst.w	lr, r5
    4be8:	d011      	beq.n	4c0e <mpu_configure_regions+0x56>
				(!mpu_partition_is_valid(regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
    4bea:	2301      	movs	r3, #1
    4bec:	f04f 0200 	mov.w	r2, #0
    4bf0:	f363 0207 	bfi	r2, r3, #0, #8
    4bf4:	4820      	ldr	r0, [pc, #128]	; (4c78 <mpu_configure_regions+0xc0>)
    4bf6:	4b21      	ldr	r3, [pc, #132]	; (4c7c <mpu_configure_regions+0xc4>)
    4bf8:	1a1b      	subs	r3, r3, r0
    4bfa:	08db      	lsrs	r3, r3, #3
    4bfc:	4820      	ldr	r0, [pc, #128]	; (4c80 <mpu_configure_regions+0xc8>)
    4bfe:	f363 128f 	bfi	r2, r3, #6, #10
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    4c02:	f015 fd13 	bl	1a62c <log_1>
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, regions[i]);
    4c06:	f06f 0215 	mvn.w	r2, #21
		/* Increment number of programmed MPU indices. */
		reg_index++;
	}

	return reg_index;
}
    4c0a:	4610      	mov	r0, r2
    4c0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * to that power-of-two value.
 */
static inline u32_t size_to_mpu_rasr_size(u32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
    4c0e:	2c20      	cmp	r4, #32
		reg_index = mpu_configure_region(reg_index, regions[i]);
    4c10:	b2d5      	uxtb	r5, r2
	region_conf.base = new_region->start;
    4c12:	f8dc 2000 	ldr.w	r2, [ip]
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
    4c16:	f8dc c008 	ldr.w	ip, [ip, #8]
    4c1a:	d91a      	bls.n	4c52 <mpu_configure_regions+0x9a>
	/*
	 * A size value greater than 2^31 could not be handled by
	 * round_up_to_next_power_of_two() properly. We handle
	 * it separately here.
	 */
	if (size > (1UL << 31)) {
    4c1c:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
    4c20:	d819      	bhi.n	4c56 <mpu_configure_regions+0x9e>
		return REGION_4G;
	}

	return ((32 - __builtin_clz(size - 1) - 2 + 1) << MPU_RASR_SIZE_Pos) &
    4c22:	3c01      	subs	r4, #1
    4c24:	fab4 f484 	clz	r4, r4
    4c28:	f1c4 041f 	rsb	r4, r4, #31
    4c2c:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1)) {
    4c2e:	2d07      	cmp	r5, #7
	/* in ARMv7-M MPU the base address is not required
	 * to determine region attributes
	 */
	(void) base;

	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    4c30:	ea4c 0404 	orr.w	r4, ip, r4
    4c34:	d911      	bls.n	4c5a <mpu_configure_regions+0xa2>
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    4c36:	2301      	movs	r3, #1
    4c38:	f04f 0200 	mov.w	r2, #0
    4c3c:	f363 0207 	bfi	r2, r3, #0, #8
    4c40:	490d      	ldr	r1, [pc, #52]	; (4c78 <mpu_configure_regions+0xc0>)
    4c42:	4b0e      	ldr	r3, [pc, #56]	; (4c7c <mpu_configure_regions+0xc4>)
    4c44:	480f      	ldr	r0, [pc, #60]	; (4c84 <mpu_configure_regions+0xcc>)
    4c46:	1a5b      	subs	r3, r3, r1
    4c48:	08db      	lsrs	r3, r3, #3
    4c4a:	f363 128f 	bfi	r2, r3, #6, #10
    4c4e:	4629      	mov	r1, r5
    4c50:	e7d7      	b.n	4c02 <mpu_configure_regions+0x4a>
		return REGION_32B;
    4c52:	2408      	movs	r4, #8
    4c54:	e7eb      	b.n	4c2e <mpu_configure_regions+0x76>
		return REGION_4G;
    4c56:	243e      	movs	r4, #62	; 0x3e
    4c58:	e7e9      	b.n	4c2e <mpu_configure_regions+0x76>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    4c5a:	f022 021f 	bic.w	r2, r2, #31
				| MPU_RBAR_VALID_Msk | index;
    4c5e:	432a      	orrs	r2, r5
    4c60:	f042 0210 	orr.w	r2, r2, #16
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    4c64:	f044 0401 	orr.w	r4, r4, #1
	MPU->RNR = index;
    4c68:	60bd      	str	r5, [r7, #8]
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    4c6a:	60fa      	str	r2, [r7, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    4c6c:	613c      	str	r4, [r7, #16]
		reg_index++;
    4c6e:	1c6a      	adds	r2, r5, #1
	for (i = 0; i < regions_num; i++) {
    4c70:	3101      	adds	r1, #1
    4c72:	e7a5      	b.n	4bc0 <mpu_configure_regions+0x8>
    4c74:	e000ed90 	.word	0xe000ed90
    4c78:	0001ed28 	.word	0x0001ed28
    4c7c:	0001ee48 	.word	0x0001ee48
    4c80:	00020021 	.word	0x00020021
    4c84:	00020044 	.word	0x00020044

00004c88 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    4c88:	4b03      	ldr	r3, [pc, #12]	; (4c98 <arm_core_mpu_enable+0x10>)
    4c8a:	2205      	movs	r2, #5
    4c8c:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    4c8e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    4c92:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    4c96:	4770      	bx	lr
    4c98:	e000ed90 	.word	0xe000ed90

00004c9c <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    4c9c:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    4ca0:	4b01      	ldr	r3, [pc, #4]	; (4ca8 <arm_core_mpu_disable+0xc>)
    4ca2:	2200      	movs	r2, #0
    4ca4:	605a      	str	r2, [r3, #4]
}
    4ca6:	4770      	bx	lr
    4ca8:	e000ed90 	.word	0xe000ed90

00004cac <arm_mpu_init>:
 */
static int arm_mpu_init(struct device *arg)
{
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    4cac:	4913      	ldr	r1, [pc, #76]	; (4cfc <arm_mpu_init+0x50>)
    4cae:	6808      	ldr	r0, [r1, #0]
    4cb0:	2808      	cmp	r0, #8
{
    4cb2:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
    4cb4:	d81e      	bhi.n	4cf4 <arm_mpu_init+0x48>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    4cb6:	f7ff fff1 	bl	4c9c <arm_core_mpu_disable>
	MPU->RNR = index;
    4cba:	4c11      	ldr	r4, [pc, #68]	; (4d00 <arm_mpu_init+0x54>)
    4cbc:	6849      	ldr	r1, [r1, #4]

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    4cbe:	2200      	movs	r2, #0
    4cc0:	4290      	cmp	r0, r2
    4cc2:	f101 010c 	add.w	r1, r1, #12
    4cc6:	d105      	bne.n	4cd4 <arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    4cc8:	4b0e      	ldr	r3, [pc, #56]	; (4d04 <arm_mpu_init+0x58>)
    4cca:	7018      	strb	r0, [r3, #0]


	arm_core_mpu_enable();
    4ccc:	f7ff ffdc 	bl	4c88 <arm_core_mpu_enable>
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		DT_NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
    4cd0:	2000      	movs	r0, #0
}
    4cd2:	bd10      	pop	{r4, pc}
    4cd4:	60a2      	str	r2, [r4, #8]
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    4cd6:	f851 3c0c 	ldr.w	r3, [r1, #-12]
    4cda:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
    4cde:	4313      	orrs	r3, r2
    4ce0:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    4ce4:	60e3      	str	r3, [r4, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    4ce6:	f851 3c04 	ldr.w	r3, [r1, #-4]
    4cea:	f043 0301 	orr.w	r3, r3, #1
    4cee:	6123      	str	r3, [r4, #16]
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    4cf0:	3201      	adds	r2, #1
    4cf2:	e7e5      	b.n	4cc0 <arm_mpu_init+0x14>
		return -1;
    4cf4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4cf8:	e7eb      	b.n	4cd2 <arm_mpu_init+0x26>
    4cfa:	bf00      	nop
    4cfc:	0001f1c8 	.word	0x0001f1c8
    4d00:	e000ed90 	.word	0xe000ed90
    4d04:	20001b14 	.word	0x20001b14

00004d08 <arm_core_mpu_configure_static_mpu_regions>:
{
    4d08:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    4d0a:	4c03      	ldr	r4, [pc, #12]	; (4d18 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    4d0c:	2301      	movs	r3, #1
    4d0e:	7822      	ldrb	r2, [r4, #0]
    4d10:	f7ff ff52 	bl	4bb8 <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    4d14:	7020      	strb	r0, [r4, #0]
}
    4d16:	bd10      	pop	{r4, pc}
    4d18:	20001b14 	.word	0x20001b14

00004d1c <arm_core_mpu_configure_dynamic_mpu_regions>:
{
    4d1c:	b508      	push	{r3, lr}

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
    4d1e:	4a08      	ldr	r2, [pc, #32]	; (4d40 <arm_core_mpu_configure_dynamic_mpu_regions+0x24>)
    4d20:	2300      	movs	r3, #0
    4d22:	7812      	ldrb	r2, [r2, #0]
    4d24:	f7ff ff48 	bl	4bb8 <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
    4d28:	f110 0f16 	cmn.w	r0, #22
    4d2c:	d003      	beq.n	4d36 <arm_core_mpu_configure_dynamic_mpu_regions+0x1a>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
    4d2e:	4b05      	ldr	r3, [pc, #20]	; (4d44 <arm_core_mpu_configure_dynamic_mpu_regions+0x28>)
  MPU->RASR = 0U;
    4d30:	2200      	movs	r2, #0

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    4d32:	2807      	cmp	r0, #7
    4d34:	dd00      	ble.n	4d38 <arm_core_mpu_configure_dynamic_mpu_regions+0x1c>
}
    4d36:	bd08      	pop	{r3, pc}
  MPU->RNR = rnr;
    4d38:	6098      	str	r0, [r3, #8]
  MPU->RASR = 0U;
    4d3a:	611a      	str	r2, [r3, #16]
    4d3c:	3001      	adds	r0, #1
    4d3e:	e7f8      	b.n	4d32 <arm_core_mpu_configure_dynamic_mpu_regions+0x16>
    4d40:	20001b14 	.word	0x20001b14
    4d44:	e000ed90 	.word	0xe000ed90

00004d48 <nordicsemi_nrf52_init>:
    4d48:	f04f 0320 	mov.w	r3, #32
    4d4c:	f3ef 8211 	mrs	r2, BASEPRI
    4d50:	f383 8811 	msr	BASEPRI, r3
    4d54:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    4d58:	4906      	ldr	r1, [pc, #24]	; (4d74 <nordicsemi_nrf52_init+0x2c>)
    4d5a:	2301      	movs	r3, #1
    4d5c:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
#endif

#if NRF_POWER_HAS_DCDCEN
NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable)
{
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
    4d60:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    4d64:	f8c1 3578 	str.w	r3, [r1, #1400]	; 0x578
	__asm__ volatile(
    4d68:	f382 8811 	msr	BASEPRI, r2
    4d6c:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    4d70:	2000      	movs	r0, #0
    4d72:	4770      	bx	lr
    4d74:	4001e000 	.word	0x4001e000

00004d78 <bt_hex_real>:
	static const char hex[] = "0123456789abcdef";
	static char str[129];
	const u8_t *b = buf;
	int i;

	len = MIN(len, (sizeof(str) - 1) / 2);
    4d78:	2940      	cmp	r1, #64	; 0x40
    4d7a:	4b0e      	ldr	r3, [pc, #56]	; (4db4 <bt_hex_real+0x3c>)
{
    4d7c:	b570      	push	{r4, r5, r6, lr}
	len = MIN(len, (sizeof(str) - 1) / 2);
    4d7e:	bf28      	it	cs
    4d80:	2140      	movcs	r1, #64	; 0x40

	for (i = 0; i < len; i++) {
		str[i * 2]     = hex[b[i] >> 4];
    4d82:	4c0d      	ldr	r4, [pc, #52]	; (4db8 <bt_hex_real+0x40>)
    4d84:	1846      	adds	r6, r0, r1
    4d86:	461d      	mov	r5, r3
	for (i = 0; i < len; i++) {
    4d88:	42b0      	cmp	r0, r6
    4d8a:	f103 0302 	add.w	r3, r3, #2
    4d8e:	d104      	bne.n	4d9a <bt_hex_real+0x22>
		str[i * 2 + 1] = hex[b[i] & 0xf];
	}

	str[i * 2] = '\0';
    4d90:	2300      	movs	r3, #0
    4d92:	f805 3011 	strb.w	r3, [r5, r1, lsl #1]

	return str;
}
    4d96:	4807      	ldr	r0, [pc, #28]	; (4db4 <bt_hex_real+0x3c>)
    4d98:	bd70      	pop	{r4, r5, r6, pc}
		str[i * 2]     = hex[b[i] >> 4];
    4d9a:	7802      	ldrb	r2, [r0, #0]
    4d9c:	0912      	lsrs	r2, r2, #4
    4d9e:	5ca2      	ldrb	r2, [r4, r2]
    4da0:	f803 2c02 	strb.w	r2, [r3, #-2]
		str[i * 2 + 1] = hex[b[i] & 0xf];
    4da4:	f810 2b01 	ldrb.w	r2, [r0], #1
    4da8:	f002 020f 	and.w	r2, r2, #15
    4dac:	5ca2      	ldrb	r2, [r4, r2]
    4dae:	f803 2c01 	strb.w	r2, [r3, #-1]
    4db2:	e7e9      	b.n	4d88 <bt_hex_real+0x10>
    4db4:	20001b15 	.word	0x20001b15
    4db8:	000200c2 	.word	0x000200c2

00004dbc <bt_addr_le_str_real>:

	return str;
}

const char *bt_addr_le_str_real(const bt_addr_le_t *addr)
{
    4dbc:	b530      	push	{r4, r5, lr}
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
				    size_t len)
{
	char type[10];

	switch (addr->type) {
    4dbe:	7803      	ldrb	r3, [r0, #0]
    4dc0:	b08b      	sub	sp, #44	; 0x2c
    4dc2:	4604      	mov	r4, r0
    4dc4:	ad07      	add	r5, sp, #28
    4dc6:	2b03      	cmp	r3, #3
    4dc8:	d821      	bhi.n	4e0e <bt_addr_le_str_real+0x52>
    4dca:	e8df f003 	tbb	[pc, r3]
    4dce:	1a02      	.short	0x1a02
    4dd0:	1e1c      	.short	0x1e1c
	case BT_ADDR_LE_PUBLIC:
		strcpy(type, "public");
    4dd2:	4912      	ldr	r1, [pc, #72]	; (4e1c <bt_addr_le_str_real+0x60>)
		break;
	case BT_ADDR_LE_RANDOM:
		strcpy(type, "random");
    4dd4:	4628      	mov	r0, r5
    4dd6:	f016 f8c1 	bl	1af5c <strcpy>
	default:
		snprintk(type, sizeof(type), "0x%02x", addr->type);
		break;
	}

	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
    4dda:	7863      	ldrb	r3, [r4, #1]
    4ddc:	9304      	str	r3, [sp, #16]
    4dde:	78a3      	ldrb	r3, [r4, #2]
    4de0:	9303      	str	r3, [sp, #12]
    4de2:	78e3      	ldrb	r3, [r4, #3]
    4de4:	9302      	str	r3, [sp, #8]
    4de6:	7923      	ldrb	r3, [r4, #4]
    4de8:	9301      	str	r3, [sp, #4]
    4dea:	7963      	ldrb	r3, [r4, #5]
    4dec:	9300      	str	r3, [sp, #0]
    4dee:	9505      	str	r5, [sp, #20]
    4df0:	79a3      	ldrb	r3, [r4, #6]
    4df2:	4a0b      	ldr	r2, [pc, #44]	; (4e20 <bt_addr_le_str_real+0x64>)
    4df4:	480b      	ldr	r0, [pc, #44]	; (4e24 <bt_addr_le_str_real+0x68>)
    4df6:	211e      	movs	r1, #30
    4df8:	f014 fac9 	bl	1938e <snprintk>
	static char str[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(addr, str, sizeof(str));

	return str;
}
    4dfc:	4809      	ldr	r0, [pc, #36]	; (4e24 <bt_addr_le_str_real+0x68>)
    4dfe:	b00b      	add	sp, #44	; 0x2c
    4e00:	bd30      	pop	{r4, r5, pc}
		strcpy(type, "random");
    4e02:	4909      	ldr	r1, [pc, #36]	; (4e28 <bt_addr_le_str_real+0x6c>)
    4e04:	e7e6      	b.n	4dd4 <bt_addr_le_str_real+0x18>
		strcpy(type, "public-id");
    4e06:	4909      	ldr	r1, [pc, #36]	; (4e2c <bt_addr_le_str_real+0x70>)
    4e08:	e7e4      	b.n	4dd4 <bt_addr_le_str_real+0x18>
		strcpy(type, "random-id");
    4e0a:	4909      	ldr	r1, [pc, #36]	; (4e30 <bt_addr_le_str_real+0x74>)
    4e0c:	e7e2      	b.n	4dd4 <bt_addr_le_str_real+0x18>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
    4e0e:	4a09      	ldr	r2, [pc, #36]	; (4e34 <bt_addr_le_str_real+0x78>)
    4e10:	210a      	movs	r1, #10
    4e12:	4628      	mov	r0, r5
    4e14:	f014 fabb 	bl	1938e <snprintk>
		break;
    4e18:	e7df      	b.n	4dda <bt_addr_le_str_real+0x1e>
    4e1a:	bf00      	nop
    4e1c:	0002007d 	.word	0x0002007d
    4e20:	0002009f 	.word	0x0002009f
    4e24:	20001b96 	.word	0x20001b96
    4e28:	00020084 	.word	0x00020084
    4e2c:	0002008b 	.word	0x0002008b
    4e30:	00020095 	.word	0x00020095
    4e34:	00021aa7 	.word	0x00021aa7

00004e38 <ecc_thread>:

	bt_recv(buf);
}

static void ecc_thread(void *p1, void *p2, void *p3)
{
    4e38:	e92d 4888 	stmdb	sp!, {r3, r7, fp, lr}
    4e3c:	4c69      	ldr	r4, [pc, #420]	; (4fe4 <ecc_thread+0x1ac>)
		BT_ERR("public key is not valid (ret %d)", ret);
    4e3e:	4b6a      	ldr	r3, [pc, #424]	; (4fe8 <ecc_thread+0x1b0>)
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    4e40:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 5004 <ecc_thread+0x1cc>
    4e44:	1ae4      	subs	r4, r4, r3
    4e46:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    4e4a:	4645      	mov	r5, r8
	return z_impl_k_sem_take(sem, timeout);
    4e4c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    4e50:	4866      	ldr	r0, [pc, #408]	; (4fec <ecc_thread+0x1b4>)
    4e52:	f013 fb43 	bl	184dc <z_impl_k_sem_take>
    4e56:	f3bf 8f5b 	dmb	ish
    4e5a:	f8d8 3000 	ldr.w	r3, [r8]
    4e5e:	f3bf 8f5b 	dmb	ish
	while (true) {
		k_sem_take(&cmd_sem, K_FOREVER);

		if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
    4e62:	f013 0901 	ands.w	r9, r3, #1
    4e66:	d061      	beq.n	4f2c <ecc_thread+0xf4>
		rc = uECC_make_key(ecc.pk, ecc.private_key, &curve_secp256r1);
    4e68:	f8df b190 	ldr.w	fp, [pc, #400]	; 4ffc <ecc_thread+0x1c4>
    4e6c:	f8df 9198 	ldr.w	r9, [pc, #408]	; 5008 <ecc_thread+0x1d0>
	} while (memcmp(ecc.private_key, debug_private_key, 32) == 0);
    4e70:	f8df a198 	ldr.w	sl, [pc, #408]	; 500c <ecc_thread+0x1d4>
		rc = uECC_make_key(ecc.pk, ecc.private_key, &curve_secp256r1);
    4e74:	485e      	ldr	r0, [pc, #376]	; (4ff0 <ecc_thread+0x1b8>)
    4e76:	465a      	mov	r2, fp
    4e78:	4649      	mov	r1, r9
    4e7a:	f014 fad7 	bl	1942c <uECC_make_key>
		if (rc == TC_CRYPTO_FAIL) {
    4e7e:	2800      	cmp	r0, #0
    4e80:	d141      	bne.n	4f06 <ecc_thread+0xce>
			BT_ERR("Failed to create ECC public/private pair");
    4e82:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
    4e86:	f043 0301 	orr.w	r3, r3, #1
    4e8a:	f363 0707 	bfi	r7, r3, #0, #8
    4e8e:	f364 178f 	bfi	r7, r4, #6, #10
    4e92:	4639      	mov	r1, r7
    4e94:	4857      	ldr	r0, [pc, #348]	; (4ff4 <ecc_thread+0x1bc>)
    4e96:	f015 fbbc 	bl	1a612 <log_0>
			return BT_HCI_ERR_UNSPECIFIED;
    4e9a:	f04f 0a1f 	mov.w	sl, #31
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    4e9e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    4ea2:	2001      	movs	r0, #1
    4ea4:	f002 fd72 	bl	798c <bt_buf_get_rx>
	hdr = net_buf_add(buf, sizeof(*hdr));
    4ea8:	f100 0b08 	add.w	fp, r0, #8
    4eac:	2102      	movs	r1, #2
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    4eae:	4681      	mov	r9, r0
	hdr = net_buf_add(buf, sizeof(*hdr));
    4eb0:	4658      	mov	r0, fp
    4eb2:	f018 fecb 	bl	1dc4c <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
    4eb6:	233e      	movs	r3, #62	; 0x3e
    4eb8:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
    4eba:	2342      	movs	r3, #66	; 0x42
    4ebc:	7043      	strb	r3, [r0, #1]
	meta = net_buf_add(buf, sizeof(*meta));
    4ebe:	2101      	movs	r1, #1
    4ec0:	4658      	mov	r0, fp
    4ec2:	f018 fec3 	bl	1dc4c <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_P256_PUBLIC_KEY_COMPLETE;
    4ec6:	2308      	movs	r3, #8
    4ec8:	7003      	strb	r3, [r0, #0]
	evt = net_buf_add(buf, sizeof(*evt));
    4eca:	2141      	movs	r1, #65	; 0x41
    4ecc:	4658      	mov	r0, fp
    4ece:	f018 febd 	bl	1dc4c <net_buf_simple_add>
    4ed2:	4683      	mov	fp, r0
	evt->status = status;
    4ed4:	f800 ab01 	strb.w	sl, [r0], #1
	if (status) {
    4ed8:	f1ba 0f00 	cmp.w	sl, #0
    4edc:	d01d      	beq.n	4f1a <ecc_thread+0xe2>
		(void)memset(evt->key, 0, sizeof(evt->key));
    4ede:	2240      	movs	r2, #64	; 0x40
    4ee0:	2100      	movs	r1, #0
    4ee2:	f016 f8b4 	bl	1b04e <memset>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    4ee6:	f3bf 8f5b 	dmb	ish
    4eea:	e855 3f00 	ldrex	r3, [r5]
    4eee:	f023 0301 	bic.w	r3, r3, #1
    4ef2:	e845 3200 	strex	r2, r3, [r5]
    4ef6:	2a00      	cmp	r2, #0
    4ef8:	d1f7      	bne.n	4eea <ecc_thread+0xb2>
    4efa:	f3bf 8f5b 	dmb	ish
	bt_recv(buf);
    4efe:	4648      	mov	r0, r9
	bt_recv(buf);
    4f00:	f001 fe14 	bl	6b2c <bt_recv>
    4f04:	e7a2      	b.n	4e4c <ecc_thread+0x14>
	} while (memcmp(ecc.private_key, debug_private_key, 32) == 0);
    4f06:	2220      	movs	r2, #32
    4f08:	4651      	mov	r1, sl
    4f0a:	4648      	mov	r0, r9
    4f0c:	f016 f865 	bl	1afda <memcmp>
    4f10:	2800      	cmp	r0, #0
    4f12:	d0af      	beq.n	4e74 <ecc_thread+0x3c>
	return 0;
    4f14:	f04f 0a00 	mov.w	sl, #0
    4f18:	e7c1      	b.n	4e9e <ecc_thread+0x66>
		sys_memcpy_swap(evt->key, ecc.pk, 32);
    4f1a:	4935      	ldr	r1, [pc, #212]	; (4ff0 <ecc_thread+0x1b8>)
    4f1c:	f016 f925 	bl	1b16a <sys_memcpy_swap.constprop.2>
		sys_memcpy_swap(&evt->key[32], &ecc.pk[32], 32);
    4f20:	4935      	ldr	r1, [pc, #212]	; (4ff8 <ecc_thread+0x1c0>)
    4f22:	f10b 0021 	add.w	r0, fp, #33	; 0x21
    4f26:	f016 f920 	bl	1b16a <sys_memcpy_swap.constprop.2>
    4f2a:	e7dc      	b.n	4ee6 <ecc_thread+0xae>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    4f2c:	f3bf 8f5b 	dmb	ish
    4f30:	f8d8 3000 	ldr.w	r3, [r8]
    4f34:	f3bf 8f5b 	dmb	ish
			emulate_le_p256_public_key_cmd();
		} else if (atomic_test_bit(flags, PENDING_DHKEY)) {
    4f38:	079b      	lsls	r3, r3, #30
    4f3a:	d587      	bpl.n	4e4c <ecc_thread+0x14>
	ret = uECC_valid_public_key(ecc.pk, &curve_secp256r1);
    4f3c:	492f      	ldr	r1, [pc, #188]	; (4ffc <ecc_thread+0x1c4>)
    4f3e:	482c      	ldr	r0, [pc, #176]	; (4ff0 <ecc_thread+0x1b8>)
    4f40:	f015 f945 	bl	1a1ce <uECC_valid_public_key>
	if (ret < 0) {
    4f44:	1e01      	subs	r1, r0, #0
    4f46:	da3e      	bge.n	4fc6 <ecc_thread+0x18e>
		BT_ERR("public key is not valid (ret %d)", ret);
    4f48:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
    4f4c:	f043 0301 	orr.w	r3, r3, #1
    4f50:	f363 0607 	bfi	r6, r3, #0, #8
    4f54:	f364 168f 	bfi	r6, r4, #6, #10
    4f58:	4632      	mov	r2, r6
    4f5a:	4829      	ldr	r0, [pc, #164]	; (5000 <ecc_thread+0x1c8>)
    4f5c:	f015 fb66 	bl	1a62c <log_1>
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    4f60:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    4f64:	2001      	movs	r0, #1
    4f66:	f002 fd11 	bl	798c <bt_buf_get_rx>
	hdr = net_buf_add(buf, sizeof(*hdr));
    4f6a:	f100 0b08 	add.w	fp, r0, #8
    4f6e:	2102      	movs	r1, #2
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    4f70:	4682      	mov	sl, r0
	hdr = net_buf_add(buf, sizeof(*hdr));
    4f72:	4658      	mov	r0, fp
    4f74:	f018 fe6a 	bl	1dc4c <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
    4f78:	233e      	movs	r3, #62	; 0x3e
    4f7a:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
    4f7c:	2322      	movs	r3, #34	; 0x22
    4f7e:	7043      	strb	r3, [r0, #1]
	meta = net_buf_add(buf, sizeof(*meta));
    4f80:	2101      	movs	r1, #1
    4f82:	4658      	mov	r0, fp
    4f84:	f018 fe62 	bl	1dc4c <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_GENERATE_DHKEY_COMPLETE;
    4f88:	2309      	movs	r3, #9
    4f8a:	7003      	strb	r3, [r0, #0]
	evt = net_buf_add(buf, sizeof(*evt));
    4f8c:	2121      	movs	r1, #33	; 0x21
    4f8e:	4658      	mov	r0, fp
    4f90:	f018 fe5c 	bl	1dc4c <net_buf_simple_add>
    4f94:	4603      	mov	r3, r0
	if (ret == TC_CRYPTO_FAIL) {
    4f96:	3001      	adds	r0, #1
    4f98:	f1b9 0f00 	cmp.w	r9, #0
    4f9c:	d11c      	bne.n	4fd8 <ecc_thread+0x1a0>
		evt->status = BT_HCI_ERR_UNSPECIFIED;
    4f9e:	221f      	movs	r2, #31
    4fa0:	701a      	strb	r2, [r3, #0]
		(void)memset(evt->dhkey, 0, sizeof(evt->dhkey));
    4fa2:	4649      	mov	r1, r9
    4fa4:	2220      	movs	r2, #32
    4fa6:	f016 f852 	bl	1b04e <memset>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    4faa:	f3bf 8f5b 	dmb	ish
    4fae:	e855 3f00 	ldrex	r3, [r5]
    4fb2:	f023 0302 	bic.w	r3, r3, #2
    4fb6:	e845 3200 	strex	r2, r3, [r5]
    4fba:	2a00      	cmp	r2, #0
    4fbc:	d1f7      	bne.n	4fae <ecc_thread+0x176>
    4fbe:	f3bf 8f5b 	dmb	ish
	bt_recv(buf);
    4fc2:	4650      	mov	r0, sl
    4fc4:	e79c      	b.n	4f00 <ecc_thread+0xc8>
		ret = uECC_shared_secret(ecc.pk, ecc.private_key, ecc.dhkey,
    4fc6:	4a0a      	ldr	r2, [pc, #40]	; (4ff0 <ecc_thread+0x1b8>)
    4fc8:	4b0c      	ldr	r3, [pc, #48]	; (4ffc <ecc_thread+0x1c4>)
    4fca:	f1a2 0120 	sub.w	r1, r2, #32
    4fce:	4610      	mov	r0, r2
    4fd0:	f014 fa7b 	bl	194ca <uECC_shared_secret>
    4fd4:	4681      	mov	r9, r0
    4fd6:	e7c3      	b.n	4f60 <ecc_thread+0x128>
		evt->status = 0U;
    4fd8:	2200      	movs	r2, #0
    4fda:	701a      	strb	r2, [r3, #0]
		sys_memcpy_swap(evt->dhkey, ecc.dhkey, sizeof(ecc.dhkey));
    4fdc:	4904      	ldr	r1, [pc, #16]	; (4ff0 <ecc_thread+0x1b8>)
    4fde:	f016 f8c4 	bl	1b16a <sys_memcpy_swap.constprop.2>
    4fe2:	e7e2      	b.n	4faa <ecc_thread+0x172>
    4fe4:	0001edf0 	.word	0x0001edf0
    4fe8:	0001ed28 	.word	0x0001ed28
    4fec:	20005c18 	.word	0x20005c18
    4ff0:	20001bd4 	.word	0x20001bd4
    4ff4:	000200e1 	.word	0x000200e1
    4ff8:	20001bf4 	.word	0x20001bf4
    4ffc:	0001f1e8 	.word	0x0001f1e8
    5000:	0002010a 	.word	0x0002010a
    5004:	20000208 	.word	0x20000208
    5008:	20001bb4 	.word	0x20001bb4
    500c:	0001f298 	.word	0x0001f298

00005010 <bt_hci_ecc_send>:

	send_cmd_status(BT_HCI_OP_LE_P256_PUBLIC_KEY, status);
}

int bt_hci_ecc_send(struct net_buf *buf)
{
    5010:	b570      	push	{r4, r5, r6, lr}
	 * pointer to an enum causes issues on qemu_x86 because the true
	 * size is 8-bit, but the enum is 32-bit on qemu_x86. So we put in
	 * a temporary cast to 8-bit to ensure only 8 bits are read from
	 * the pointer.
	 */
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
    5012:	7d05      	ldrb	r5, [r0, #20]
    5014:	4604      	mov	r4, r0
	if (bt_buf_get_type(buf) == BT_BUF_CMD) {
    5016:	b9ad      	cbnz	r5, 5044 <bt_hci_ecc_send+0x34>
		struct bt_hci_cmd_hdr *chdr = (void *)buf->data;
    5018:	6883      	ldr	r3, [r0, #8]

		switch (sys_le16_to_cpu(chdr->opcode)) {
    501a:	881a      	ldrh	r2, [r3, #0]
    501c:	f242 0125 	movw	r1, #8229	; 0x2025
    5020:	428a      	cmp	r2, r1
    5022:	d017      	beq.n	5054 <bt_hci_ecc_send+0x44>
    5024:	f242 0126 	movw	r1, #8230	; 0x2026
    5028:	428a      	cmp	r2, r1
    502a:	d03c      	beq.n	50a6 <bt_hci_ecc_send+0x96>
    502c:	f242 0101 	movw	r1, #8193	; 0x2001
    5030:	428a      	cmp	r2, r1
    5032:	d107      	bne.n	5044 <bt_hci_ecc_send+0x34>
	cmd->events[0] &= ~0x80; /* LE Read Local P-256 PKey Compl */
    5034:	78da      	ldrb	r2, [r3, #3]
    5036:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    503a:	70da      	strb	r2, [r3, #3]
	cmd->events[1] &= ~0x01; /* LE Generate DHKey Compl Event */
    503c:	791a      	ldrb	r2, [r3, #4]
    503e:	f022 0201 	bic.w	r2, r2, #1
    5042:	711a      	strb	r2, [r3, #4]
		default:
			break;
		}
	}

	return bt_dev.drv->send(buf);
    5044:	4b32      	ldr	r3, [pc, #200]	; (5110 <bt_hci_ecc_send+0x100>)
    5046:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
    504a:	4620      	mov	r0, r4
    504c:	691b      	ldr	r3, [r3, #16]
}
    504e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_dev.drv->send(buf);
    5052:	4718      	bx	r3
			net_buf_pull(buf, sizeof(*chdr));
    5054:	2103      	movs	r1, #3
    5056:	3008      	adds	r0, #8
    5058:	f018 fe21 	bl	1dc9e <net_buf_simple_pull>
	net_buf_unref(buf);
    505c:	4620      	mov	r0, r4
    505e:	f011 fa5f 	bl	16520 <net_buf_unref>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    5062:	f3bf 8f5b 	dmb	ish
    5066:	4b2b      	ldr	r3, [pc, #172]	; (5114 <bt_hci_ecc_send+0x104>)
    5068:	681a      	ldr	r2, [r3, #0]
    506a:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(flags, PENDING_DHKEY)) {
    506e:	0790      	lsls	r0, r2, #30
    5070:	d507      	bpl.n	5082 <bt_hci_ecc_send+0x72>
		status = BT_HCI_ERR_CMD_DISALLOWED;
    5072:	250c      	movs	r5, #12
	send_cmd_status(BT_HCI_OP_LE_P256_PUBLIC_KEY, status);
    5074:	4629      	mov	r1, r5
    5076:	f242 0025 	movw	r0, #8229	; 0x2025
	send_cmd_status(BT_HCI_OP_LE_GENERATE_DHKEY, status);
    507a:	f016 f853 	bl	1b124 <send_cmd_status>
}
    507e:	2000      	movs	r0, #0
    5080:	bd70      	pop	{r4, r5, r6, pc}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    5082:	f3bf 8f5b 	dmb	ish
    5086:	e853 2f00 	ldrex	r2, [r3]
    508a:	f042 0101 	orr.w	r1, r2, #1
    508e:	e843 1000 	strex	r0, r1, [r3]
    5092:	2800      	cmp	r0, #0
    5094:	d1f7      	bne.n	5086 <bt_hci_ecc_send+0x76>
    5096:	f3bf 8f5b 	dmb	ish
	} else if (atomic_test_and_set_bit(flags, PENDING_PUB_KEY)) {
    509a:	07d1      	lsls	r1, r2, #31
    509c:	d4e9      	bmi.n	5072 <bt_hci_ecc_send+0x62>
	z_impl_k_sem_give(sem);
    509e:	481e      	ldr	r0, [pc, #120]	; (5118 <bt_hci_ecc_send+0x108>)
    50a0:	f013 f9f0 	bl	18484 <z_impl_k_sem_give>
    50a4:	e7e6      	b.n	5074 <bt_hci_ecc_send+0x64>
			net_buf_pull(buf, sizeof(*chdr));
    50a6:	2103      	movs	r1, #3
    50a8:	3008      	adds	r0, #8
    50aa:	f018 fdf8 	bl	1dc9e <net_buf_simple_pull>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    50ae:	f3bf 8f5b 	dmb	ish
    50b2:	4b18      	ldr	r3, [pc, #96]	; (5114 <bt_hci_ecc_send+0x104>)
    50b4:	681a      	ldr	r2, [r3, #0]
    50b6:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
    50ba:	07d2      	lsls	r2, r2, #31
    50bc:	d507      	bpl.n	50ce <bt_hci_ecc_send+0xbe>
		status = BT_HCI_ERR_CMD_DISALLOWED;
    50be:	250c      	movs	r5, #12
	net_buf_unref(buf);
    50c0:	4620      	mov	r0, r4
    50c2:	f011 fa2d 	bl	16520 <net_buf_unref>
	send_cmd_status(BT_HCI_OP_LE_GENERATE_DHKEY, status);
    50c6:	4629      	mov	r1, r5
    50c8:	f242 0026 	movw	r0, #8230	; 0x2026
    50cc:	e7d5      	b.n	507a <bt_hci_ecc_send+0x6a>
	if (buf->len < sizeof(struct bt_hci_cp_le_generate_dhkey)) {
    50ce:	89a2      	ldrh	r2, [r4, #12]
    50d0:	2a3f      	cmp	r2, #63	; 0x3f
    50d2:	d91b      	bls.n	510c <bt_hci_ecc_send+0xfc>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    50d4:	f3bf 8f5b 	dmb	ish
    50d8:	e853 2f00 	ldrex	r2, [r3]
    50dc:	f042 0102 	orr.w	r1, r2, #2
    50e0:	e843 1000 	strex	r0, r1, [r3]
    50e4:	2800      	cmp	r0, #0
    50e6:	d1f7      	bne.n	50d8 <bt_hci_ecc_send+0xc8>
    50e8:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_set_bit(flags, PENDING_DHKEY)) {
    50ec:	0793      	lsls	r3, r2, #30
    50ee:	d4e6      	bmi.n	50be <bt_hci_ecc_send+0xae>
	cmd = (void *)buf->data;
    50f0:	68a6      	ldr	r6, [r4, #8]
	sys_memcpy_swap(ecc.pk, cmd->key, 32);
    50f2:	480a      	ldr	r0, [pc, #40]	; (511c <bt_hci_ecc_send+0x10c>)
    50f4:	4631      	mov	r1, r6
    50f6:	f016 f838 	bl	1b16a <sys_memcpy_swap.constprop.2>
	sys_memcpy_swap(&ecc.pk[32], &cmd->key[32], 32);
    50fa:	f106 0120 	add.w	r1, r6, #32
    50fe:	4808      	ldr	r0, [pc, #32]	; (5120 <bt_hci_ecc_send+0x110>)
    5100:	f016 f833 	bl	1b16a <sys_memcpy_swap.constprop.2>
    5104:	4804      	ldr	r0, [pc, #16]	; (5118 <bt_hci_ecc_send+0x108>)
    5106:	f013 f9bd 	bl	18484 <z_impl_k_sem_give>
    510a:	e7d9      	b.n	50c0 <bt_hci_ecc_send+0xb0>
		status = BT_HCI_ERR_INVALID_PARAM;
    510c:	2512      	movs	r5, #18
    510e:	e7d7      	b.n	50c0 <bt_hci_ecc_send+0xb0>
    5110:	20005438 	.word	0x20005438
    5114:	20000208 	.word	0x20000208
    5118:	20005c18 	.word	0x20005c18
    511c:	20001bd4 	.word	0x20001bd4
    5120:	20001bf4 	.word	0x20001bf4

00005124 <bt_hci_ecc_init>:
{
	return !bt_rand(dst, len);
}

void bt_hci_ecc_init(void)
{
    5124:	b510      	push	{r4, lr}
    5126:	b086      	sub	sp, #24
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    5128:	4c0b      	ldr	r4, [pc, #44]	; (5158 <bt_hci_ecc_init+0x34>)
    512a:	490c      	ldr	r1, [pc, #48]	; (515c <bt_hci_ecc_init+0x38>)
    512c:	2300      	movs	r3, #0
    512e:	220a      	movs	r2, #10
    5130:	e9cd 3202 	strd	r3, r2, [sp, #8]
    5134:	e9cd 3304 	strd	r3, r3, [sp, #16]
    5138:	e9cd 3300 	strd	r3, r3, [sp]
    513c:	f240 424c 	movw	r2, #1100	; 0x44c
    5140:	4b07      	ldr	r3, [pc, #28]	; (5160 <bt_hci_ecc_init+0x3c>)
    5142:	4620      	mov	r0, r4
    5144:	f013 fa42 	bl	185cc <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    5148:	4906      	ldr	r1, [pc, #24]	; (5164 <bt_hci_ecc_init+0x40>)
    514a:	4620      	mov	r0, r4
	k_thread_create(&ecc_thread_data, ecc_thread_stack,
			K_THREAD_STACK_SIZEOF(ecc_thread_stack), ecc_thread,
			NULL, NULL, NULL, K_PRIO_PREEMPT(10), 0, K_NO_WAIT);
	k_thread_name_set(&ecc_thread_data, "BT ECC");
}
    514c:	b006      	add	sp, #24
    514e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    5152:	f019 ba86 	b.w	1e662 <z_impl_k_thread_name_set>
    5156:	bf00      	nop
    5158:	2000019c 	.word	0x2000019c
    515c:	20002248 	.word	0x20002248
    5160:	00004e39 	.word	0x00004e39
    5164:	000200da 	.word	0x000200da

00005168 <save_id>:
}

#define ID_DATA_LEN(array) (bt_dev.id_count * sizeof(array[0]))

static void save_id(struct k_work *work)
{
    5168:	b538      	push	{r3, r4, r5, lr}
	int err;
	BT_INFO("Saving ID");
    516a:	f04f 0100 	mov.w	r1, #0
    516e:	2303      	movs	r3, #3
    5170:	f363 0107 	bfi	r1, r3, #0, #8
    5174:	4c19      	ldr	r4, [pc, #100]	; (51dc <save_id+0x74>)
    5176:	4b1a      	ldr	r3, [pc, #104]	; (51e0 <save_id+0x78>)
	err = settings_save_one("bt/id", &bt_dev.id_addr,
				ID_DATA_LEN(bt_dev.id_addr));
    5178:	4d1a      	ldr	r5, [pc, #104]	; (51e4 <save_id+0x7c>)
	BT_INFO("Saving ID");
    517a:	481b      	ldr	r0, [pc, #108]	; (51e8 <save_id+0x80>)
    517c:	1ae4      	subs	r4, r4, r3
    517e:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    5182:	f364 118f 	bfi	r1, r4, #6, #10
    5186:	f015 fa44 	bl	1a612 <log_0>
	err = settings_save_one("bt/id", &bt_dev.id_addr,
    518a:	79ea      	ldrb	r2, [r5, #7]
    518c:	4817      	ldr	r0, [pc, #92]	; (51ec <save_id+0x84>)
    518e:	4629      	mov	r1, r5
    5190:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
    5194:	f7fe fd42 	bl	3c1c <settings_save_one>
	if (err) {
    5198:	4601      	mov	r1, r0
    519a:	b148      	cbz	r0, 51b0 <save_id+0x48>
		BT_ERR("Failed to save ID (err %d)", err);
    519c:	f04f 0200 	mov.w	r2, #0
    51a0:	2301      	movs	r3, #1
    51a2:	f363 0207 	bfi	r2, r3, #0, #8
    51a6:	f364 128f 	bfi	r2, r4, #6, #10
    51aa:	4811      	ldr	r0, [pc, #68]	; (51f0 <save_id+0x88>)
    51ac:	f015 fa3e 	bl	1a62c <log_1>
	}

#if defined(CONFIG_BT_PRIVACY)
	err = settings_save_one("bt/irk", bt_dev.irk, ID_DATA_LEN(bt_dev.irk));
    51b0:	79ea      	ldrb	r2, [r5, #7]
    51b2:	4910      	ldr	r1, [pc, #64]	; (51f4 <save_id+0x8c>)
    51b4:	4810      	ldr	r0, [pc, #64]	; (51f8 <save_id+0x90>)
    51b6:	0112      	lsls	r2, r2, #4
    51b8:	f7fe fd30 	bl	3c1c <settings_save_one>
	if (err) {
    51bc:	4601      	mov	r1, r0
    51be:	b158      	cbz	r0, 51d8 <save_id+0x70>
		BT_ERR("Failed to save IRK (err %d)", err);
    51c0:	2301      	movs	r3, #1
    51c2:	f04f 0200 	mov.w	r2, #0
    51c6:	f363 0207 	bfi	r2, r3, #0, #8
    51ca:	f364 128f 	bfi	r2, r4, #6, #10
    51ce:	480b      	ldr	r0, [pc, #44]	; (51fc <save_id+0x94>)
	}
#endif
}
    51d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		BT_ERR("Failed to save IRK (err %d)", err);
    51d4:	f015 ba2a 	b.w	1a62c <log_1>
}
    51d8:	bd38      	pop	{r3, r4, r5, pc}
    51da:	bf00      	nop
    51dc:	0001ee10 	.word	0x0001ee10
    51e0:	0001ed28 	.word	0x0001ed28
    51e4:	20005438 	.word	0x20005438
    51e8:	000201d4 	.word	0x000201d4
    51ec:	000201de 	.word	0x000201de
    51f0:	000201e4 	.word	0x000201e4
    51f4:	20005510 	.word	0x20005510
    51f8:	000201ff 	.word	0x000201ff
    51fc:	00020206 	.word	0x00020206

00005200 <set>:
{
    5200:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    5204:	4616      	mov	r6, r2
    5206:	461f      	mov	r7, r3
	if (!name) {
    5208:	4605      	mov	r5, r0
    520a:	b980      	cbnz	r0, 522e <set+0x2e>
		BT_ERR("Insufficient number of arguments");
    520c:	2301      	movs	r3, #1
    520e:	f04f 0100 	mov.w	r1, #0
    5212:	f363 0107 	bfi	r1, r3, #0, #8
    5216:	4a4c      	ldr	r2, [pc, #304]	; (5348 <set+0x148>)
    5218:	4b4c      	ldr	r3, [pc, #304]	; (534c <set+0x14c>)
    521a:	484d      	ldr	r0, [pc, #308]	; (5350 <set+0x150>)
    521c:	1a9b      	subs	r3, r3, r2
    521e:	08db      	lsrs	r3, r3, #3
    5220:	f363 118f 	bfi	r1, r3, #6, #10
    5224:	f015 f9f5 	bl	1a612 <log_0>
	return -ENOENT;
    5228:	f06f 0401 	mvn.w	r4, #1
    522c:	e023      	b.n	5276 <set+0x76>
	len = settings_name_next(name, &next);
    522e:	a901      	add	r1, sp, #4
    5230:	f015 fc41 	bl	1aab6 <settings_name_next>
	if (!strncmp(name, "id", len)) {
    5234:	4947      	ldr	r1, [pc, #284]	; (5354 <set+0x154>)
    5236:	4602      	mov	r2, r0
	len = settings_name_next(name, &next);
    5238:	4680      	mov	r8, r0
	if (!strncmp(name, "id", len)) {
    523a:	4628      	mov	r0, r5
    523c:	f015 febe 	bl	1afbc <strncmp>
    5240:	4681      	mov	r9, r0
    5242:	2800      	cmp	r0, #0
    5244:	d13c      	bne.n	52c0 <set+0xc0>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    5246:	f3bf 8f5b 	dmb	ish
    524a:	4d43      	ldr	r5, [pc, #268]	; (5358 <set+0x158>)
    524c:	682c      	ldr	r4, [r5, #0]
    524e:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    5252:	f3c4 0480 	ubfx	r4, r4, #2, #1
		if (atomic_test_bit(bt_dev.flags, BT_DEV_PRESET_ID)) {
    5256:	b194      	cbz	r4, 527e <set+0x7e>
			BT_WARN("Ignoring identities stored in flash");
    5258:	2302      	movs	r3, #2
    525a:	f04f 0100 	mov.w	r1, #0
    525e:	f363 0107 	bfi	r1, r3, #0, #8
    5262:	4a39      	ldr	r2, [pc, #228]	; (5348 <set+0x148>)
    5264:	4b39      	ldr	r3, [pc, #228]	; (534c <set+0x14c>)
    5266:	483d      	ldr	r0, [pc, #244]	; (535c <set+0x15c>)
    5268:	1a9b      	subs	r3, r3, r2
    526a:	08db      	lsrs	r3, r3, #3
    526c:	f363 118f 	bfi	r1, r3, #6, #10
    5270:	f015 f9cf 	bl	1a612 <log_0>
			return 0;
    5274:	464c      	mov	r4, r9
}
    5276:	4620      	mov	r0, r4
    5278:	b003      	add	sp, #12
    527a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		len = read_cb(cb_arg, &bt_dev.id_addr, sizeof(bt_dev.id_addr));
    527e:	3d70      	subs	r5, #112	; 0x70
    5280:	2207      	movs	r2, #7
    5282:	4629      	mov	r1, r5
    5284:	4638      	mov	r0, r7
    5286:	47b0      	blx	r6
		if (len < sizeof(bt_dev.id_addr[0])) {
    5288:	2806      	cmp	r0, #6
    528a:	d814      	bhi.n	52b6 <set+0xb6>
				BT_ERR("Invalid length ID address in storage");
    528c:	2301      	movs	r3, #1
    528e:	f04f 0100 	mov.w	r1, #0
    5292:	4a2d      	ldr	r2, [pc, #180]	; (5348 <set+0x148>)
    5294:	4832      	ldr	r0, [pc, #200]	; (5360 <set+0x160>)
    5296:	f363 0107 	bfi	r1, r3, #0, #8
    529a:	4b2c      	ldr	r3, [pc, #176]	; (534c <set+0x14c>)
    529c:	1a9b      	subs	r3, r3, r2
    529e:	08db      	lsrs	r3, r3, #3
    52a0:	f363 118f 	bfi	r1, r3, #6, #10
    52a4:	f015 f9b5 	bl	1a612 <log_0>
			(void)memset(bt_dev.id_addr, 0,
    52a8:	2207      	movs	r2, #7
    52aa:	4621      	mov	r1, r4
    52ac:	4628      	mov	r0, r5
    52ae:	f015 fece 	bl	1b04e <memset>
			bt_dev.id_count = 0U;
    52b2:	71ec      	strb	r4, [r5, #7]
    52b4:	e7df      	b.n	5276 <set+0x76>
			bt_dev.id_count = len / sizeof(bt_dev.id_addr[0]);
    52b6:	2307      	movs	r3, #7
    52b8:	fbb0 f0f3 	udiv	r0, r0, r3
    52bc:	71e8      	strb	r0, [r5, #7]
			for (i = 0; i < bt_dev.id_count; i++) {
    52be:	e7da      	b.n	5276 <set+0x76>
	if (!strncmp(name, "name", len)) {
    52c0:	4642      	mov	r2, r8
    52c2:	4928      	ldr	r1, [pc, #160]	; (5364 <set+0x164>)
    52c4:	4628      	mov	r0, r5
    52c6:	f015 fe79 	bl	1afbc <strncmp>
    52ca:	4604      	mov	r4, r0
    52cc:	b9c8      	cbnz	r0, 5302 <set+0x102>
		len = read_cb(cb_arg, &bt_dev.name, sizeof(bt_dev.name) - 1);
    52ce:	4926      	ldr	r1, [pc, #152]	; (5368 <set+0x168>)
    52d0:	2241      	movs	r2, #65	; 0x41
    52d2:	4638      	mov	r0, r7
    52d4:	47b0      	blx	r6
		if (len < 0) {
    52d6:	1e01      	subs	r1, r0, #0
    52d8:	da0e      	bge.n	52f8 <set+0xf8>
			BT_ERR("Failed to read device name from storage"
    52da:	2301      	movs	r3, #1
    52dc:	f04f 0200 	mov.w	r2, #0
    52e0:	f363 0207 	bfi	r2, r3, #0, #8
    52e4:	4818      	ldr	r0, [pc, #96]	; (5348 <set+0x148>)
    52e6:	4b19      	ldr	r3, [pc, #100]	; (534c <set+0x14c>)
    52e8:	1a1b      	subs	r3, r3, r0
    52ea:	08db      	lsrs	r3, r3, #3
    52ec:	f363 128f 	bfi	r2, r3, #6, #10
    52f0:	481e      	ldr	r0, [pc, #120]	; (536c <set+0x16c>)
    52f2:	f015 f99b 	bl	1a62c <log_1>
    52f6:	e7be      	b.n	5276 <set+0x76>
			bt_dev.name[len] = '\0';
    52f8:	4b1d      	ldr	r3, [pc, #116]	; (5370 <set+0x170>)
    52fa:	440b      	add	r3, r1
    52fc:	f883 4108 	strb.w	r4, [r3, #264]	; 0x108
			BT_DBG("Name set to %s", log_strdup(bt_dev.name));
    5300:	e7b9      	b.n	5276 <set+0x76>
	if (!strncmp(name, "irk", len)) {
    5302:	4642      	mov	r2, r8
    5304:	491b      	ldr	r1, [pc, #108]	; (5374 <set+0x174>)
    5306:	4628      	mov	r0, r5
    5308:	f015 fe58 	bl	1afbc <strncmp>
    530c:	4604      	mov	r4, r0
    530e:	2800      	cmp	r0, #0
    5310:	d18a      	bne.n	5228 <set+0x28>
		len = read_cb(cb_arg, bt_dev.irk, sizeof(bt_dev.irk));
    5312:	2210      	movs	r2, #16
    5314:	4918      	ldr	r1, [pc, #96]	; (5378 <set+0x178>)
    5316:	4638      	mov	r0, r7
    5318:	47b0      	blx	r6
		if (len < sizeof(bt_dev.irk[0])) {
    531a:	280f      	cmp	r0, #15
    531c:	d8ab      	bhi.n	5276 <set+0x76>
				BT_ERR("Invalid length IRK in storage");
    531e:	2301      	movs	r3, #1
    5320:	f04f 0100 	mov.w	r1, #0
    5324:	4a08      	ldr	r2, [pc, #32]	; (5348 <set+0x148>)
    5326:	4815      	ldr	r0, [pc, #84]	; (537c <set+0x17c>)
    5328:	f363 0107 	bfi	r1, r3, #0, #8
    532c:	4b07      	ldr	r3, [pc, #28]	; (534c <set+0x14c>)
    532e:	1a9b      	subs	r3, r3, r2
    5330:	08db      	lsrs	r3, r3, #3
    5332:	f363 118f 	bfi	r1, r3, #6, #10
    5336:	f015 f96c 	bl	1a612 <log_0>
				(void)memset(bt_dev.irk, 0, sizeof(bt_dev.irk));
    533a:	2210      	movs	r2, #16
    533c:	4621      	mov	r1, r4
    533e:	480e      	ldr	r0, [pc, #56]	; (5378 <set+0x178>)
    5340:	f015 fe85 	bl	1b04e <memset>
    5344:	e797      	b.n	5276 <set+0x76>
    5346:	bf00      	nop
    5348:	0001ed28 	.word	0x0001ed28
    534c:	0001ee10 	.word	0x0001ee10
    5350:	00020222 	.word	0x00020222
    5354:	00020092 	.word	0x00020092
    5358:	200054a8 	.word	0x200054a8
    535c:	00020243 	.word	0x00020243
    5360:	00020267 	.word	0x00020267
    5364:	000207d8 	.word	0x000207d8
    5368:	20005540 	.word	0x20005540
    536c:	0002028c 	.word	0x0002028c
    5370:	20005438 	.word	0x20005438
    5374:	00020202 	.word	0x00020202
    5378:	20005510 	.word	0x20005510
    537c:	000202be 	.word	0x000202be

00005380 <bt_settings_encode_key>:
{
    5380:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5384:	b088      	sub	sp, #32
    5386:	799c      	ldrb	r4, [r3, #6]
    5388:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
    538c:	795d      	ldrb	r5, [r3, #5]
    538e:	791e      	ldrb	r6, [r3, #4]
    5390:	78df      	ldrb	r7, [r3, #3]
    5392:	f893 c002 	ldrb.w	ip, [r3, #2]
    5396:	f893 e001 	ldrb.w	lr, [r3, #1]
    539a:	781b      	ldrb	r3, [r3, #0]
	if (key) {
    539c:	f1b8 0f00 	cmp.w	r8, #0
    53a0:	d00e      	beq.n	53c0 <bt_settings_encode_key+0x40>
		snprintk(path, path_size,
    53a2:	e9cd 3806 	strd	r3, r8, [sp, #24]
    53a6:	e9cd ce04 	strd	ip, lr, [sp, #16]
    53aa:	4613      	mov	r3, r2
    53ac:	e9cd 6702 	strd	r6, r7, [sp, #8]
    53b0:	e9cd 4500 	strd	r4, r5, [sp]
    53b4:	4a08      	ldr	r2, [pc, #32]	; (53d8 <bt_settings_encode_key+0x58>)
    53b6:	f013 ffea 	bl	1938e <snprintk>
}
    53ba:	b008      	add	sp, #32
    53bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		snprintk(path, path_size,
    53c0:	e9cd e305 	strd	lr, r3, [sp, #20]
    53c4:	e9cd 7c03 	strd	r7, ip, [sp, #12]
    53c8:	4613      	mov	r3, r2
    53ca:	e9cd 5601 	strd	r5, r6, [sp, #4]
    53ce:	9400      	str	r4, [sp, #0]
    53d0:	4a02      	ldr	r2, [pc, #8]	; (53dc <bt_settings_encode_key+0x5c>)
    53d2:	f013 ffdc 	bl	1938e <snprintk>
}
    53d6:	e7f0      	b.n	53ba <bt_settings_encode_key+0x3a>
    53d8:	00020136 	.word	0x00020136
    53dc:	0002015a 	.word	0x0002015a

000053e0 <bt_settings_save_id>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    53e0:	4909      	ldr	r1, [pc, #36]	; (5408 <bt_settings_save_id+0x28>)
    53e2:	f3bf 8f5b 	dmb	ish
    53e6:	e851 3f00 	ldrex	r3, [r1]
    53ea:	f043 0201 	orr.w	r2, r3, #1
    53ee:	e841 2000 	strex	r0, r2, [r1]
    53f2:	2800      	cmp	r0, #0
    53f4:	d1f7      	bne.n	53e6 <bt_settings_save_id+0x6>
    53f6:	f3bf 8f5b 	dmb	ish
 * @req K-WORK-001
 */
static inline void k_work_submit_to_queue(struct k_work_q *work_q,
					  struct k_work *work)
{
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    53fa:	07db      	lsls	r3, r3, #31
    53fc:	d403      	bmi.n	5406 <bt_settings_save_id+0x26>
		k_queue_append(&work_q->queue, work);
    53fe:	3908      	subs	r1, #8
    5400:	4802      	ldr	r0, [pc, #8]	; (540c <bt_settings_save_id+0x2c>)
    5402:	f018 bfa3 	b.w	1e34c <k_queue_append>
K_WORK_DEFINE(save_id_work, save_id);

void bt_settings_save_id(void)
{
	k_work_submit(&save_id_work);
}
    5406:	4770      	bx	lr
    5408:	20005648 	.word	0x20005648
    540c:	20001a60 	.word	0x20001a60

00005410 <commit>:

static int commit(void)
{
    5410:	b538      	push	{r3, r4, r5, lr}
	BT_DBG("");

#if defined(CONFIG_BT_DEVICE_NAME_DYNAMIC)
	if (bt_dev.name[0] == '\0') {
    5412:	4c1f      	ldr	r4, [pc, #124]	; (5490 <commit+0x80>)
    5414:	f894 3108 	ldrb.w	r3, [r4, #264]	; 0x108
    5418:	b913      	cbnz	r3, 5420 <commit+0x10>
		bt_set_name(CONFIG_BT_DEVICE_NAME);
    541a:	481e      	ldr	r0, [pc, #120]	; (5494 <commit+0x84>)
    541c:	f001 fdb6 	bl	6f8c <bt_set_name>
	}
#endif
	if (!bt_dev.id_count) {
    5420:	79e3      	ldrb	r3, [r4, #7]
    5422:	b9bb      	cbnz	r3, 5454 <commit+0x44>
		bt_setup_public_id_addr();
    5424:	f001 fe50 	bl	70c8 <bt_setup_public_id_addr>
	}

	if (!bt_dev.id_count) {
    5428:	79e3      	ldrb	r3, [r4, #7]
    542a:	b99b      	cbnz	r3, 5454 <commit+0x44>
		int err;

		err = bt_setup_random_id_addr();
    542c:	f001 fed8 	bl	71e0 <bt_setup_random_id_addr>
		if (err) {
    5430:	4604      	mov	r4, r0
    5432:	b178      	cbz	r0, 5454 <commit+0x44>
			BT_ERR("Unable to setup an identity address");
    5434:	2301      	movs	r3, #1
    5436:	f04f 0100 	mov.w	r1, #0
    543a:	f363 0107 	bfi	r1, r3, #0, #8
    543e:	4a16      	ldr	r2, [pc, #88]	; (5498 <commit+0x88>)
    5440:	4b16      	ldr	r3, [pc, #88]	; (549c <commit+0x8c>)
    5442:	4817      	ldr	r0, [pc, #92]	; (54a0 <commit+0x90>)
    5444:	1a9b      	subs	r3, r3, r2
    5446:	08db      	lsrs	r3, r3, #3
    5448:	f363 118f 	bfi	r1, r3, #6, #10
    544c:	f015 f8e1 	bl	1a612 <log_0>
		BT_DBG("Storing Identity Information");
		bt_settings_save_id();
	}

	return 0;
}
    5450:	4620      	mov	r0, r4
    5452:	bd38      	pop	{r3, r4, r5, pc}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    5454:	4d13      	ldr	r5, [pc, #76]	; (54a4 <commit+0x94>)
    5456:	f3bf 8f5b 	dmb	ish
    545a:	682b      	ldr	r3, [r5, #0]
    545c:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    5460:	079b      	lsls	r3, r3, #30
    5462:	d401      	bmi.n	5468 <commit+0x58>
		bt_finalize_init();
    5464:	f001 fc82 	bl	6d6c <bt_finalize_init>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    5468:	f3bf 8f5b 	dmb	ish
    546c:	e855 4f00 	ldrex	r4, [r5]
    5470:	f424 3300 	bic.w	r3, r4, #131072	; 0x20000
    5474:	e845 3200 	strex	r2, r3, [r5]
    5478:	2a00      	cmp	r2, #0
    547a:	d1f7      	bne.n	546c <commit+0x5c>
    547c:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_STORE_ID)) {
    5480:	f414 3400 	ands.w	r4, r4, #131072	; 0x20000
    5484:	d0e4      	beq.n	5450 <commit+0x40>
		bt_settings_save_id();
    5486:	f7ff ffab 	bl	53e0 <bt_settings_save_id>
	return 0;
    548a:	2400      	movs	r4, #0
    548c:	e7e0      	b.n	5450 <commit+0x40>
    548e:	bf00      	nop
    5490:	20005438 	.word	0x20005438
    5494:	000201a0 	.word	0x000201a0
    5498:	0001ed28 	.word	0x0001ed28
    549c:	0001ee10 	.word	0x0001ee10
    54a0:	000201b0 	.word	0x000201b0
    54a4:	200054a8 	.word	0x200054a8

000054a8 <bt_settings_init>:

SETTINGS_STATIC_HANDLER_DEFINE(bt, "bt", NULL, set, commit, NULL);

int bt_settings_init(void)
{
    54a8:	b510      	push	{r4, lr}
	int err;

	BT_DBG("");

	err = settings_subsys_init();
    54aa:	f7fe fd1b 	bl	3ee4 <settings_subsys_init>
	if (err) {
    54ae:	4604      	mov	r4, r0
    54b0:	b170      	cbz	r0, 54d0 <bt_settings_init+0x28>
		BT_ERR("settings_subsys_init failed (err %d)", err);
    54b2:	2301      	movs	r3, #1
    54b4:	f04f 0200 	mov.w	r2, #0
    54b8:	f363 0207 	bfi	r2, r3, #0, #8
    54bc:	4905      	ldr	r1, [pc, #20]	; (54d4 <bt_settings_init+0x2c>)
    54be:	4b06      	ldr	r3, [pc, #24]	; (54d8 <bt_settings_init+0x30>)
    54c0:	1a5b      	subs	r3, r3, r1
    54c2:	08db      	lsrs	r3, r3, #3
    54c4:	4601      	mov	r1, r0
    54c6:	f363 128f 	bfi	r2, r3, #6, #10
    54ca:	4804      	ldr	r0, [pc, #16]	; (54dc <bt_settings_init+0x34>)
    54cc:	f015 f8ae 	bl	1a62c <log_1>
		return err;
	}

	return 0;
}
    54d0:	4620      	mov	r0, r4
    54d2:	bd10      	pop	{r4, pc}
    54d4:	0001ed28 	.word	0x0001ed28
    54d8:	0001ee10 	.word	0x0001ee10
    54dc:	0002017b 	.word	0x0002017b

000054e0 <uuid_to_uuid128>:
	.val = { BT_UUID_128_ENCODE(
		0x00000000, 0x0000, 0x1000, 0x8000, 0x00805F9B34FB) }
};

static void uuid_to_uuid128(const struct bt_uuid *src, struct bt_uuid_128 *dst)
{
    54e0:	b4f0      	push	{r4, r5, r6, r7}
	switch (src->type) {
    54e2:	7802      	ldrb	r2, [r0, #0]
    54e4:	2a01      	cmp	r2, #1
{
    54e6:	4604      	mov	r4, r0
    54e8:	460b      	mov	r3, r1
	switch (src->type) {
    54ea:	d017      	beq.n	551c <uuid_to_uuid128+0x3c>
    54ec:	b11a      	cbz	r2, 54f6 <uuid_to_uuid128+0x16>
    54ee:	2a02      	cmp	r2, #2
    54f0:	d02c      	beq.n	554c <uuid_to_uuid128+0x6c>
		return;
	case BT_UUID_TYPE_128:
		memcpy(dst, src, sizeof(*dst));
		return;
	}
}
    54f2:	bcf0      	pop	{r4, r5, r6, r7}
    54f4:	4770      	bx	lr
		*dst = uuid128_base;
    54f6:	4a18      	ldr	r2, [pc, #96]	; (5558 <uuid_to_uuid128+0x78>)
    54f8:	460d      	mov	r5, r1
    54fa:	f102 0710 	add.w	r7, r2, #16
    54fe:	6810      	ldr	r0, [r2, #0]
    5500:	6851      	ldr	r1, [r2, #4]
    5502:	462e      	mov	r6, r5
    5504:	c603      	stmia	r6!, {r0, r1}
    5506:	3208      	adds	r2, #8
    5508:	42ba      	cmp	r2, r7
    550a:	4635      	mov	r5, r6
    550c:	d1f7      	bne.n	54fe <uuid_to_uuid128+0x1e>
    550e:	7812      	ldrb	r2, [r2, #0]
    5510:	7032      	strb	r2, [r6, #0]
		sys_put_le16(BT_UUID_16(src)->val,
    5512:	8862      	ldrh	r2, [r4, #2]
	dst[0] = val;
    5514:	735a      	strb	r2, [r3, #13]
	dst[1] = val >> 8;
    5516:	0a12      	lsrs	r2, r2, #8
    5518:	739a      	strb	r2, [r3, #14]
    551a:	e7ea      	b.n	54f2 <uuid_to_uuid128+0x12>
		*dst = uuid128_base;
    551c:	4a0e      	ldr	r2, [pc, #56]	; (5558 <uuid_to_uuid128+0x78>)
    551e:	460d      	mov	r5, r1
    5520:	f102 0710 	add.w	r7, r2, #16
    5524:	6810      	ldr	r0, [r2, #0]
    5526:	6851      	ldr	r1, [r2, #4]
    5528:	462e      	mov	r6, r5
    552a:	c603      	stmia	r6!, {r0, r1}
    552c:	3208      	adds	r2, #8
    552e:	42ba      	cmp	r2, r7
    5530:	4635      	mov	r5, r6
    5532:	d1f7      	bne.n	5524 <uuid_to_uuid128+0x44>
    5534:	7812      	ldrb	r2, [r2, #0]
    5536:	7032      	strb	r2, [r6, #0]
		sys_put_le32(BT_UUID_32(src)->val,
    5538:	6862      	ldr	r2, [r4, #4]
	dst[0] = val;
    553a:	735a      	strb	r2, [r3, #13]
	dst[1] = val >> 8;
    553c:	f3c2 2107 	ubfx	r1, r2, #8, #8
	sys_put_le16(val >> 16, &dst[2]);
    5540:	0c12      	lsrs	r2, r2, #16
	dst[0] = val;
    5542:	73da      	strb	r2, [r3, #15]
	dst[1] = val >> 8;
    5544:	0a12      	lsrs	r2, r2, #8
    5546:	7399      	strb	r1, [r3, #14]
    5548:	741a      	strb	r2, [r3, #16]
    554a:	e7d2      	b.n	54f2 <uuid_to_uuid128+0x12>
		memcpy(dst, src, sizeof(*dst));
    554c:	4601      	mov	r1, r0
    554e:	2211      	movs	r2, #17
    5550:	4618      	mov	r0, r3
}
    5552:	bcf0      	pop	{r4, r5, r6, r7}
		memcpy(dst, src, sizeof(*dst));
    5554:	f015 bd51 	b.w	1affa <memcpy>
    5558:	000202eb 	.word	0x000202eb

0000555c <le_dhkey_complete>:
{
    555c:	b510      	push	{r4, lr}
	if (dh_key_cb) {
    555e:	4c06      	ldr	r4, [pc, #24]	; (5578 <le_dhkey_complete+0x1c>)
    5560:	6822      	ldr	r2, [r4, #0]
    5562:	b132      	cbz	r2, 5572 <le_dhkey_complete+0x16>
	struct bt_hci_evt_le_generate_dhkey_complete *evt = (void *)buf->data;
    5564:	6880      	ldr	r0, [r0, #8]
		dh_key_cb(evt->status ? NULL : evt->dhkey);
    5566:	7803      	ldrb	r3, [r0, #0]
    5568:	b923      	cbnz	r3, 5574 <le_dhkey_complete+0x18>
    556a:	3001      	adds	r0, #1
    556c:	4790      	blx	r2
		dh_key_cb = NULL;
    556e:	2300      	movs	r3, #0
    5570:	6023      	str	r3, [r4, #0]
}
    5572:	bd10      	pop	{r4, pc}
		dh_key_cb(evt->status ? NULL : evt->dhkey);
    5574:	2000      	movs	r0, #0
    5576:	e7f9      	b.n	556c <le_dhkey_complete+0x10>
    5578:	20000224 	.word	0x20000224

0000557c <ver_str>:
{
    557c:	b570      	push	{r4, r5, r6, lr}
	const char * const str[] = {
    557e:	4d0b      	ldr	r5, [pc, #44]	; (55ac <ver_str+0x30>)
{
    5580:	4606      	mov	r6, r0
	const char * const str[] = {
    5582:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
    5584:	b08c      	sub	sp, #48	; 0x30
	const char * const str[] = {
    5586:	ac01      	add	r4, sp, #4
    5588:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    558a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    558c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    558e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
	if (ver < ARRAY_SIZE(str)) {
    5592:	2e0a      	cmp	r6, #10
	const char * const str[] = {
    5594:	e884 0007 	stmia.w	r4, {r0, r1, r2}
		return str[ver];
    5598:	bf9b      	ittet	ls
    559a:	ab0c      	addls	r3, sp, #48	; 0x30
    559c:	eb03 0686 	addls.w	r6, r3, r6, lsl #2
	return "unknown";
    55a0:	4803      	ldrhi	r0, [pc, #12]	; (55b0 <ver_str+0x34>)
		return str[ver];
    55a2:	f856 0c2c 	ldrls.w	r0, [r6, #-44]
}
    55a6:	b00c      	add	sp, #48	; 0x30
    55a8:	bd70      	pop	{r4, r5, r6, pc}
    55aa:	bf00      	nop
    55ac:	0001eea4 	.word	0x0001eea4
    55b0:	00020cbe 	.word	0x00020cbe

000055b4 <le_pkey_complete>:
{
    55b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_hci_evt_le_p256_public_key_complete *evt = (void *)buf->data;
    55b6:	6886      	ldr	r6, [r0, #8]
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    55b8:	480f      	ldr	r0, [pc, #60]	; (55f8 <le_pkey_complete+0x44>)
    55ba:	f06f 0110 	mvn.w	r1, #16
    55be:	f015 fe5b 	bl	1b278 <atomic_and>
	if (!evt->status) {
    55c2:	7833      	ldrb	r3, [r6, #0]
    55c4:	b943      	cbnz	r3, 55d8 <le_pkey_complete+0x24>
		memcpy(pub_key, evt->key, 64);
    55c6:	1c71      	adds	r1, r6, #1
    55c8:	2240      	movs	r2, #64	; 0x40
    55ca:	480c      	ldr	r0, [pc, #48]	; (55fc <le_pkey_complete+0x48>)
    55cc:	f015 fd15 	bl	1affa <memcpy>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    55d0:	2108      	movs	r1, #8
    55d2:	4809      	ldr	r0, [pc, #36]	; (55f8 <le_pkey_complete+0x44>)
    55d4:	f015 fe65 	bl	1b2a2 <atomic_or>
	for (cb = pub_key_cb; cb; cb = cb->_next) {
    55d8:	4d09      	ldr	r5, [pc, #36]	; (5600 <le_pkey_complete+0x4c>)
		cb->func(evt->status ? NULL : pub_key);
    55da:	4f08      	ldr	r7, [pc, #32]	; (55fc <le_pkey_complete+0x48>)
	for (cb = pub_key_cb; cb; cb = cb->_next) {
    55dc:	682c      	ldr	r4, [r5, #0]
    55de:	b90c      	cbnz	r4, 55e4 <le_pkey_complete+0x30>
	pub_key_cb = NULL;
    55e0:	602c      	str	r4, [r5, #0]
}
    55e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		cb->func(evt->status ? NULL : pub_key);
    55e4:	7832      	ldrb	r2, [r6, #0]
    55e6:	6823      	ldr	r3, [r4, #0]
    55e8:	2a00      	cmp	r2, #0
    55ea:	bf0c      	ite	eq
    55ec:	4638      	moveq	r0, r7
    55ee:	2000      	movne	r0, #0
    55f0:	4798      	blx	r3
	for (cb = pub_key_cb; cb; cb = cb->_next) {
    55f2:	6864      	ldr	r4, [r4, #4]
    55f4:	e7f3      	b.n	55de <le_pkey_complete+0x2a>
    55f6:	bf00      	nop
    55f8:	200054a8 	.word	0x200054a8
    55fc:	20001c14 	.word	0x20001c14
    5600:	20000228 	.word	0x20000228

00005604 <hci_data_buf_overflow>:
	BT_WARN("Data buffer overflow (link type 0x%02x)", evt->link_type);
    5604:	2302      	movs	r3, #2
    5606:	f04f 0200 	mov.w	r2, #0
	struct bt_hci_evt_data_buf_overflow *evt = (void *)buf->data;
    560a:	6881      	ldr	r1, [r0, #8]
    560c:	4805      	ldr	r0, [pc, #20]	; (5624 <hci_data_buf_overflow+0x20>)
	BT_WARN("Data buffer overflow (link type 0x%02x)", evt->link_type);
    560e:	7809      	ldrb	r1, [r1, #0]
    5610:	f363 0207 	bfi	r2, r3, #0, #8
    5614:	4b04      	ldr	r3, [pc, #16]	; (5628 <hci_data_buf_overflow+0x24>)
    5616:	1a1b      	subs	r3, r3, r0
    5618:	08db      	lsrs	r3, r3, #3
    561a:	f363 128f 	bfi	r2, r3, #6, #10
    561e:	4803      	ldr	r0, [pc, #12]	; (562c <hci_data_buf_overflow+0x28>)
    5620:	f015 b804 	b.w	1a62c <log_1>
    5624:	0001ed28 	.word	0x0001ed28
    5628:	0001ede8 	.word	0x0001ede8
    562c:	000209ed 	.word	0x000209ed

00005630 <le_data_len_change>:
	u16_t handle = sys_le16_to_cpu(evt->handle);
    5630:	6883      	ldr	r3, [r0, #8]
{
    5632:	b510      	push	{r4, lr}
	u16_t handle = sys_le16_to_cpu(evt->handle);
    5634:	881c      	ldrh	r4, [r3, #0]
	conn = bt_conn_lookup_handle(handle);
    5636:	4620      	mov	r0, r4
    5638:	f002 fe86 	bl	8348 <bt_conn_lookup_handle>
	if (!conn) {
    563c:	b980      	cbnz	r0, 5660 <le_data_len_change+0x30>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    563e:	2301      	movs	r3, #1
    5640:	f04f 0200 	mov.w	r2, #0
    5644:	f363 0207 	bfi	r2, r3, #0, #8
    5648:	4907      	ldr	r1, [pc, #28]	; (5668 <le_data_len_change+0x38>)
    564a:	4b08      	ldr	r3, [pc, #32]	; (566c <le_data_len_change+0x3c>)
    564c:	4808      	ldr	r0, [pc, #32]	; (5670 <le_data_len_change+0x40>)
    564e:	1a5b      	subs	r3, r3, r1
    5650:	08db      	lsrs	r3, r3, #3
    5652:	4621      	mov	r1, r4
    5654:	f363 128f 	bfi	r2, r3, #6, #10
}
    5658:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		BT_ERR("Unable to lookup conn for handle %u", handle);
    565c:	f014 bfe6 	b.w	1a62c <log_1>
}
    5660:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_conn_unref(conn);
    5664:	f015 bfab 	b.w	1b5be <bt_conn_unref>
    5668:	0001ed28 	.word	0x0001ed28
    566c:	0001ede8 	.word	0x0001ede8
    5670:	00020b5d 	.word	0x00020b5d

00005674 <le_conn_update_complete>:
{
    5674:	b573      	push	{r0, r1, r4, r5, r6, lr}
	struct bt_hci_evt_le_conn_update_complete *evt = (void *)buf->data;
    5676:	6885      	ldr	r5, [r0, #8]
	handle = sys_le16_to_cpu(evt->handle);
    5678:	f8b5 6001 	ldrh.w	r6, [r5, #1]
	conn = bt_conn_lookup_handle(handle);
    567c:	4630      	mov	r0, r6
    567e:	f002 fe63 	bl	8348 <bt_conn_lookup_handle>
	if (!conn) {
    5682:	4604      	mov	r4, r0
    5684:	b980      	cbnz	r0, 56a8 <le_conn_update_complete+0x34>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    5686:	2301      	movs	r3, #1
    5688:	f04f 0200 	mov.w	r2, #0
    568c:	f363 0207 	bfi	r2, r3, #0, #8
    5690:	491e      	ldr	r1, [pc, #120]	; (570c <le_conn_update_complete+0x98>)
    5692:	4b1f      	ldr	r3, [pc, #124]	; (5710 <le_conn_update_complete+0x9c>)
    5694:	481f      	ldr	r0, [pc, #124]	; (5714 <le_conn_update_complete+0xa0>)
    5696:	1a5b      	subs	r3, r3, r1
    5698:	08db      	lsrs	r3, r3, #3
    569a:	f363 128f 	bfi	r2, r3, #6, #10
    569e:	4631      	mov	r1, r6
    56a0:	f014 ffc4 	bl	1a62c <log_1>
}
    56a4:	b002      	add	sp, #8
    56a6:	bd70      	pop	{r4, r5, r6, pc}
	if (!evt->status) {
    56a8:	782b      	ldrb	r3, [r5, #0]
    56aa:	b9bb      	cbnz	r3, 56dc <le_conn_update_complete+0x68>
		conn->le.interval = sys_le16_to_cpu(evt->interval);
    56ac:	792a      	ldrb	r2, [r5, #4]
    56ae:	78eb      	ldrb	r3, [r5, #3]
    56b0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    56b4:	f8a0 3086 	strh.w	r3, [r0, #134]	; 0x86
		conn->le.latency = sys_le16_to_cpu(evt->latency);
    56b8:	79aa      	ldrb	r2, [r5, #6]
    56ba:	796b      	ldrb	r3, [r5, #5]
    56bc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    56c0:	f8a0 308c 	strh.w	r3, [r0, #140]	; 0x8c
		conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
    56c4:	79eb      	ldrb	r3, [r5, #7]
    56c6:	7a2a      	ldrb	r2, [r5, #8]
    56c8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    56cc:	f8a0 308e 	strh.w	r3, [r0, #142]	; 0x8e
		notify_le_param_updated(conn);
    56d0:	f002 fb3a 	bl	7d48 <notify_le_param_updated>
	bt_conn_unref(conn);
    56d4:	4620      	mov	r0, r4
    56d6:	f015 ff72 	bl	1b5be <bt_conn_unref>
    56da:	e7e3      	b.n	56a4 <le_conn_update_complete+0x30>
	} else if (evt->status == BT_HCI_ERR_UNSUPP_REMOTE_FEATURE &&
    56dc:	2b1a      	cmp	r3, #26
    56de:	d1f9      	bne.n	56d4 <le_conn_update_complete+0x60>
    56e0:	78c3      	ldrb	r3, [r0, #3]
    56e2:	2b01      	cmp	r3, #1
    56e4:	d1f6      	bne.n	56d4 <le_conn_update_complete+0x60>
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    56e6:	f44f 6180 	mov.w	r1, #1024	; 0x400
    56ea:	3004      	adds	r0, #4
    56ec:	f015 fdd9 	bl	1b2a2 <atomic_or>
		   conn->role == BT_HCI_ROLE_SLAVE &&
    56f0:	0543      	lsls	r3, r0, #21
    56f2:	d4ef      	bmi.n	56d4 <le_conn_update_complete+0x60>
		param.interval_min = conn->le.interval_min;
    56f4:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    56f8:	9300      	str	r3, [sp, #0]
		bt_l2cap_update_conn_param(conn, &param);
    56fa:	4669      	mov	r1, sp
		param.latency = conn->le.pending_latency;
    56fc:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
    5700:	9301      	str	r3, [sp, #4]
		bt_l2cap_update_conn_param(conn, &param);
    5702:	4620      	mov	r0, r4
    5704:	f003 f9a0 	bl	8a48 <bt_l2cap_update_conn_param>
    5708:	e7e4      	b.n	56d4 <le_conn_update_complete+0x60>
    570a:	bf00      	nop
    570c:	0001ed28 	.word	0x0001ed28
    5710:	0001ede8 	.word	0x0001ede8
    5714:	00020b5d 	.word	0x00020b5d

00005718 <hci_vendor_event>:
{
    5718:	b510      	push	{r4, lr}
		BT_WARN("Unhandled vendor-specific event: %s",
    571a:	2302      	movs	r3, #2
    571c:	f04f 0400 	mov.w	r4, #0
    5720:	4a0a      	ldr	r2, [pc, #40]	; (574c <hci_vendor_event+0x34>)
    5722:	8981      	ldrh	r1, [r0, #12]
    5724:	6880      	ldr	r0, [r0, #8]
    5726:	f363 0407 	bfi	r4, r3, #0, #8
    572a:	4b09      	ldr	r3, [pc, #36]	; (5750 <hci_vendor_event+0x38>)
    572c:	1a9b      	subs	r3, r3, r2
    572e:	08db      	lsrs	r3, r3, #3
    5730:	f363 148f 	bfi	r4, r3, #6, #10
    5734:	f7ff fb20 	bl	4d78 <bt_hex_real>
    5738:	f7fd fba4 	bl	2e84 <log_strdup>
    573c:	4622      	mov	r2, r4
    573e:	4601      	mov	r1, r0
}
    5740:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		BT_WARN("Unhandled vendor-specific event: %s",
    5744:	4803      	ldr	r0, [pc, #12]	; (5754 <hci_vendor_event+0x3c>)
    5746:	f014 bf71 	b.w	1a62c <log_1>
    574a:	bf00      	nop
    574c:	0001ed28 	.word	0x0001ed28
    5750:	0001ede8 	.word	0x0001ede8
    5754:	00020b1f 	.word	0x00020b1f

00005758 <update_sec_level>:
{
    5758:	b510      	push	{r4, lr}
	if (!conn->encrypt) {
    575a:	7ac3      	ldrb	r3, [r0, #11]
{
    575c:	4604      	mov	r4, r0
	if (!conn->encrypt) {
    575e:	b913      	cbnz	r3, 5766 <update_sec_level+0xe>
		conn->sec_level = BT_SECURITY_L1;
    5760:	2301      	movs	r3, #1
    5762:	7243      	strb	r3, [r0, #9]
}
    5764:	bd10      	pop	{r4, pc}
	if (conn->le.keys && (conn->le.keys->flags & BT_KEYS_AUTHENTICATED)) {
    5766:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
    576a:	b31b      	cbz	r3, 57b4 <update_sec_level+0x5c>
    576c:	7a5a      	ldrb	r2, [r3, #9]
    576e:	07d1      	lsls	r1, r2, #31
    5770:	d520      	bpl.n	57b4 <update_sec_level+0x5c>
		if (conn->le.keys->flags & BT_KEYS_SC &&
    5772:	06d2      	lsls	r2, r2, #27
    5774:	d51c      	bpl.n	57b0 <update_sec_level+0x58>
    5776:	7a1b      	ldrb	r3, [r3, #8]
    5778:	2b10      	cmp	r3, #16
    577a:	d119      	bne.n	57b0 <update_sec_level+0x58>
			conn->sec_level = BT_SECURITY_L4;
    577c:	2304      	movs	r3, #4
		conn->sec_level = BT_SECURITY_L2;
    577e:	7263      	strb	r3, [r4, #9]
	if (conn->required_sec_level > conn->sec_level) {
    5780:	7aa2      	ldrb	r2, [r4, #10]
    5782:	7a63      	ldrb	r3, [r4, #9]
    5784:	429a      	cmp	r2, r3
    5786:	d9ed      	bls.n	5764 <update_sec_level+0xc>
		BT_ERR("Failed to set required security level");
    5788:	2301      	movs	r3, #1
    578a:	f04f 0100 	mov.w	r1, #0
    578e:	f363 0107 	bfi	r1, r3, #0, #8
    5792:	4a09      	ldr	r2, [pc, #36]	; (57b8 <update_sec_level+0x60>)
    5794:	4b09      	ldr	r3, [pc, #36]	; (57bc <update_sec_level+0x64>)
    5796:	480a      	ldr	r0, [pc, #40]	; (57c0 <update_sec_level+0x68>)
    5798:	1a9b      	subs	r3, r3, r2
    579a:	08db      	lsrs	r3, r3, #3
    579c:	f363 118f 	bfi	r1, r3, #6, #10
    57a0:	f014 ff37 	bl	1a612 <log_0>
		bt_conn_disconnect(conn, BT_HCI_ERR_AUTH_FAIL);
    57a4:	4620      	mov	r0, r4
    57a6:	2105      	movs	r1, #5
}
    57a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		bt_conn_disconnect(conn, BT_HCI_ERR_AUTH_FAIL);
    57ac:	f015 bf0a 	b.w	1b5c4 <bt_conn_disconnect>
			conn->sec_level = BT_SECURITY_L3;
    57b0:	2303      	movs	r3, #3
    57b2:	e7e4      	b.n	577e <update_sec_level+0x26>
		conn->sec_level = BT_SECURITY_L2;
    57b4:	2302      	movs	r3, #2
    57b6:	e7e2      	b.n	577e <update_sec_level+0x26>
    57b8:	0001ed28 	.word	0x0001ed28
    57bc:	0001ede8 	.word	0x0001ede8
    57c0:	00020c98 	.word	0x00020c98

000057c4 <hci_encrypt_key_refresh_complete>:
{
    57c4:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_encrypt_key_refresh_complete *evt = (void *)buf->data;
    57c6:	6885      	ldr	r5, [r0, #8]
	handle = sys_le16_to_cpu(evt->handle);
    57c8:	f8b5 6001 	ldrh.w	r6, [r5, #1]
	conn = bt_conn_lookup_handle(handle);
    57cc:	4630      	mov	r0, r6
    57ce:	f002 fdbb 	bl	8348 <bt_conn_lookup_handle>
	if (!conn) {
    57d2:	4604      	mov	r4, r0
    57d4:	b980      	cbnz	r0, 57f8 <hci_encrypt_key_refresh_complete+0x34>
		BT_ERR("Unable to look up conn with handle %u", handle);
    57d6:	2301      	movs	r3, #1
    57d8:	f04f 0200 	mov.w	r2, #0
    57dc:	f363 0207 	bfi	r2, r3, #0, #8
    57e0:	4917      	ldr	r1, [pc, #92]	; (5840 <hci_encrypt_key_refresh_complete+0x7c>)
    57e2:	4b18      	ldr	r3, [pc, #96]	; (5844 <hci_encrypt_key_refresh_complete+0x80>)
    57e4:	4818      	ldr	r0, [pc, #96]	; (5848 <hci_encrypt_key_refresh_complete+0x84>)
    57e6:	1a5b      	subs	r3, r3, r1
    57e8:	08db      	lsrs	r3, r3, #3
    57ea:	4631      	mov	r1, r6
    57ec:	f363 128f 	bfi	r2, r3, #6, #10
}
    57f0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_ERR("Unable to look up conn with handle %u", handle);
    57f4:	f014 bf1a 	b.w	1a62c <log_1>
	if (evt->status) {
    57f8:	7829      	ldrb	r1, [r5, #0]
    57fa:	b189      	cbz	r1, 5820 <hci_encrypt_key_refresh_complete+0x5c>
	conn->required_sec_level = conn->sec_level;
    57fc:	7a43      	ldrb	r3, [r0, #9]
    57fe:	7283      	strb	r3, [r0, #10]
		bt_l2cap_encrypt_change(conn, evt->status);
    5800:	f015 ff95 	bl	1b72e <bt_l2cap_encrypt_change>
		bt_conn_security_changed(conn, security_err_get(evt->status));
    5804:	782b      	ldrb	r3, [r5, #0]
	switch (hci_err) {
    5806:	2b29      	cmp	r3, #41	; 0x29
    5808:	bf9a      	itte	ls
    580a:	4a10      	ldrls	r2, [pc, #64]	; (584c <hci_encrypt_key_refresh_complete+0x88>)
    580c:	5cd1      	ldrbls	r1, [r2, r3]
		bt_conn_security_changed(conn, security_err_get(evt->status));
    580e:	2108      	movhi	r1, #8
	bt_conn_security_changed(conn, BT_SECURITY_ERR_SUCCESS);
    5810:	4620      	mov	r0, r4
    5812:	f002 fb07 	bl	7e24 <bt_conn_security_changed>
	bt_conn_unref(conn);
    5816:	4620      	mov	r0, r4
}
    5818:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_conn_unref(conn);
    581c:	f015 becf 	b.w	1b5be <bt_conn_unref>
	if (conn->type == BT_CONN_TYPE_LE) {
    5820:	7883      	ldrb	r3, [r0, #2]
    5822:	2b01      	cmp	r3, #1
    5824:	d104      	bne.n	5830 <hci_encrypt_key_refresh_complete+0x6c>
		bt_smp_update_keys(conn);
    5826:	f007 fe49 	bl	d4bc <bt_smp_update_keys>
		update_sec_level(conn);
    582a:	4620      	mov	r0, r4
    582c:	f7ff ff94 	bl	5758 <update_sec_level>
	conn->required_sec_level = conn->sec_level;
    5830:	7a63      	ldrb	r3, [r4, #9]
    5832:	72a3      	strb	r3, [r4, #10]
	bt_l2cap_encrypt_change(conn, evt->status);
    5834:	7829      	ldrb	r1, [r5, #0]
    5836:	4620      	mov	r0, r4
    5838:	f015 ff79 	bl	1b72e <bt_l2cap_encrypt_change>
	bt_conn_security_changed(conn, BT_SECURITY_ERR_SUCCESS);
    583c:	2100      	movs	r1, #0
    583e:	e7e7      	b.n	5810 <hci_encrypt_key_refresh_complete+0x4c>
    5840:	0001ed28 	.word	0x0001ed28
    5844:	0001ede8 	.word	0x0001ede8
    5848:	00020a15 	.word	0x00020a15
    584c:	000202fc 	.word	0x000202fc

00005850 <hci_encrypt_change>:
{
    5850:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_encrypt_change *evt = (void *)buf->data;
    5852:	6885      	ldr	r5, [r0, #8]
	u16_t handle = sys_le16_to_cpu(evt->handle);
    5854:	f8b5 6001 	ldrh.w	r6, [r5, #1]
	conn = bt_conn_lookup_handle(handle);
    5858:	4630      	mov	r0, r6
    585a:	f002 fd75 	bl	8348 <bt_conn_lookup_handle>
	if (!conn) {
    585e:	4604      	mov	r4, r0
    5860:	b980      	cbnz	r0, 5884 <hci_encrypt_change+0x34>
		BT_ERR("Unable to look up conn with handle %u", handle);
    5862:	2301      	movs	r3, #1
    5864:	f04f 0200 	mov.w	r2, #0
    5868:	f363 0207 	bfi	r2, r3, #0, #8
    586c:	4919      	ldr	r1, [pc, #100]	; (58d4 <hci_encrypt_change+0x84>)
    586e:	4b1a      	ldr	r3, [pc, #104]	; (58d8 <hci_encrypt_change+0x88>)
    5870:	481a      	ldr	r0, [pc, #104]	; (58dc <hci_encrypt_change+0x8c>)
    5872:	1a5b      	subs	r3, r3, r1
    5874:	08db      	lsrs	r3, r3, #3
    5876:	4631      	mov	r1, r6
    5878:	f363 128f 	bfi	r2, r3, #6, #10
}
    587c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_ERR("Unable to look up conn with handle %u", handle);
    5880:	f014 bed4 	b.w	1a62c <log_1>
	if (evt->status) {
    5884:	7829      	ldrb	r1, [r5, #0]
    5886:	b189      	cbz	r1, 58ac <hci_encrypt_change+0x5c>
	conn->required_sec_level = conn->sec_level;
    5888:	7a43      	ldrb	r3, [r0, #9]
    588a:	7283      	strb	r3, [r0, #10]
		bt_l2cap_encrypt_change(conn, evt->status);
    588c:	f015 ff4f 	bl	1b72e <bt_l2cap_encrypt_change>
		bt_conn_security_changed(conn, security_err_get(evt->status));
    5890:	782b      	ldrb	r3, [r5, #0]
	switch (hci_err) {
    5892:	2b29      	cmp	r3, #41	; 0x29
    5894:	bf9a      	itte	ls
    5896:	4a12      	ldrls	r2, [pc, #72]	; (58e0 <hci_encrypt_change+0x90>)
    5898:	5cd1      	ldrbls	r1, [r2, r3]
		bt_conn_security_changed(conn, security_err_get(evt->status));
    589a:	2108      	movhi	r1, #8
	bt_conn_security_changed(conn, BT_SECURITY_ERR_SUCCESS);
    589c:	4620      	mov	r0, r4
    589e:	f002 fac1 	bl	7e24 <bt_conn_security_changed>
	bt_conn_unref(conn);
    58a2:	4620      	mov	r0, r4
}
    58a4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_conn_unref(conn);
    58a8:	f015 be89 	b.w	1b5be <bt_conn_unref>
	if (conn->type == BT_CONN_TYPE_LE) {
    58ac:	7882      	ldrb	r2, [r0, #2]
	conn->encrypt = evt->encrypt;
    58ae:	78eb      	ldrb	r3, [r5, #3]
    58b0:	72c3      	strb	r3, [r0, #11]
	if (conn->type == BT_CONN_TYPE_LE) {
    58b2:	2a01      	cmp	r2, #1
    58b4:	d105      	bne.n	58c2 <hci_encrypt_change+0x72>
		if (conn->encrypt) {
    58b6:	b10b      	cbz	r3, 58bc <hci_encrypt_change+0x6c>
			bt_smp_update_keys(conn);
    58b8:	f007 fe00 	bl	d4bc <bt_smp_update_keys>
		update_sec_level(conn);
    58bc:	4620      	mov	r0, r4
    58be:	f7ff ff4b 	bl	5758 <update_sec_level>
	conn->required_sec_level = conn->sec_level;
    58c2:	7a63      	ldrb	r3, [r4, #9]
    58c4:	72a3      	strb	r3, [r4, #10]
	bt_l2cap_encrypt_change(conn, evt->status);
    58c6:	7829      	ldrb	r1, [r5, #0]
    58c8:	4620      	mov	r0, r4
    58ca:	f015 ff30 	bl	1b72e <bt_l2cap_encrypt_change>
	bt_conn_security_changed(conn, BT_SECURITY_ERR_SUCCESS);
    58ce:	2100      	movs	r1, #0
    58d0:	e7e4      	b.n	589c <hci_encrypt_change+0x4c>
    58d2:	bf00      	nop
    58d4:	0001ed28 	.word	0x0001ed28
    58d8:	0001ede8 	.word	0x0001ede8
    58dc:	00020a15 	.word	0x00020a15
    58e0:	000202fc 	.word	0x000202fc

000058e4 <find_pending_connect.part.18>:
static struct bt_conn *find_pending_connect(u8_t role, bt_addr_le_t *peer_addr)
    58e4:	b507      	push	{r0, r1, r2, lr}
		conn = bt_conn_lookup_state_le(peer_addr,
    58e6:	2104      	movs	r1, #4
    58e8:	f002 fd66 	bl	83b8 <bt_conn_lookup_state_le>
		if (!conn) {
    58ec:	b960      	cbnz	r0, 5908 <find_pending_connect.part.18+0x24>
			conn = bt_conn_lookup_state_le(BT_ADDR_LE_NONE,
    58ee:	4b08      	ldr	r3, [pc, #32]	; (5910 <find_pending_connect.part.18+0x2c>)
    58f0:	6818      	ldr	r0, [r3, #0]
    58f2:	889a      	ldrh	r2, [r3, #4]
    58f4:	9000      	str	r0, [sp, #0]
    58f6:	799b      	ldrb	r3, [r3, #6]
    58f8:	f8ad 2004 	strh.w	r2, [sp, #4]
    58fc:	2103      	movs	r1, #3
    58fe:	4668      	mov	r0, sp
    5900:	f88d 3006 	strb.w	r3, [sp, #6]
    5904:	f002 fd58 	bl	83b8 <bt_conn_lookup_state_le>
}
    5908:	b003      	add	sp, #12
    590a:	f85d fb04 	ldr.w	pc, [sp], #4
    590e:	bf00      	nop
    5910:	0001eed0 	.word	0x0001eed0

00005914 <handle_event>:
{
    5914:	b573      	push	{r0, r1, r4, r5, r6, lr}
    5916:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    591a:	4604      	mov	r4, r0
    591c:	4608      	mov	r0, r1
		if (handler->event != event) {
    591e:	7811      	ldrb	r1, [r2, #0]
    5920:	42a1      	cmp	r1, r4
    5922:	d01e      	beq.n	5962 <handle_event+0x4e>
			continue;
    5924:	3208      	adds	r2, #8
	for (i = 0; i < num_handlers; i++) {
    5926:	429a      	cmp	r2, r3
    5928:	d1f9      	bne.n	591e <handle_event+0xa>
	BT_WARN("Unhandled event 0x%02x len %u: %s", event,
    592a:	2302      	movs	r3, #2
    592c:	f04f 0500 	mov.w	r5, #0
    5930:	4a19      	ldr	r2, [pc, #100]	; (5998 <handle_event+0x84>)
    5932:	8986      	ldrh	r6, [r0, #12]
    5934:	6880      	ldr	r0, [r0, #8]
    5936:	f363 0507 	bfi	r5, r3, #0, #8
    593a:	4b18      	ldr	r3, [pc, #96]	; (599c <handle_event+0x88>)
    593c:	1a9b      	subs	r3, r3, r2
    593e:	08db      	lsrs	r3, r3, #3
    5940:	4631      	mov	r1, r6
    5942:	f363 158f 	bfi	r5, r3, #6, #10
    5946:	f7ff fa17 	bl	4d78 <bt_hex_real>
    594a:	f7fd fa9b 	bl	2e84 <log_strdup>
    594e:	f8ad 5000 	strh.w	r5, [sp]
    5952:	4603      	mov	r3, r0
    5954:	4632      	mov	r2, r6
    5956:	4621      	mov	r1, r4
    5958:	4811      	ldr	r0, [pc, #68]	; (59a0 <handle_event+0x8c>)
    595a:	f014 fe93 	bl	1a684 <log_3>
}
    595e:	b002      	add	sp, #8
    5960:	bd70      	pop	{r4, r5, r6, pc}
		if (buf->len < handler->min_len) {
    5962:	8981      	ldrh	r1, [r0, #12]
    5964:	7853      	ldrb	r3, [r2, #1]
    5966:	428b      	cmp	r3, r1
    5968:	d911      	bls.n	598e <handle_event+0x7a>
			BT_ERR("Too small (%u bytes) event 0x%02x",
    596a:	2201      	movs	r2, #1
    596c:	f04f 0300 	mov.w	r3, #0
    5970:	f362 0307 	bfi	r3, r2, #0, #8
    5974:	4808      	ldr	r0, [pc, #32]	; (5998 <handle_event+0x84>)
    5976:	4a09      	ldr	r2, [pc, #36]	; (599c <handle_event+0x88>)
    5978:	1a12      	subs	r2, r2, r0
    597a:	08d2      	lsrs	r2, r2, #3
    597c:	4809      	ldr	r0, [pc, #36]	; (59a4 <handle_event+0x90>)
    597e:	f362 138f 	bfi	r3, r2, #6, #10
    5982:	4622      	mov	r2, r4
}
    5984:	b002      	add	sp, #8
    5986:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			BT_ERR("Too small (%u bytes) event 0x%02x",
    598a:	f014 be63 	b.w	1a654 <log_2>
		handler->handler(buf);
    598e:	6853      	ldr	r3, [r2, #4]
}
    5990:	b002      	add	sp, #8
    5992:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		handler->handler(buf);
    5996:	4718      	bx	r3
    5998:	0001ed28 	.word	0x0001ed28
    599c:	0001ede8 	.word	0x0001ede8
    59a0:	00020963 	.word	0x00020963
    59a4:	00020941 	.word	0x00020941

000059a8 <hci_le_meta_event>:
{
    59a8:	b510      	push	{r4, lr}
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    59aa:	2101      	movs	r1, #1
{
    59ac:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    59ae:	3008      	adds	r0, #8
    59b0:	f018 f97d 	bl	1dcae <net_buf_simple_pull_mem>
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    59b4:	4621      	mov	r1, r4
    59b6:	230a      	movs	r3, #10
    59b8:	4a02      	ldr	r2, [pc, #8]	; (59c4 <hci_le_meta_event+0x1c>)
    59ba:	7800      	ldrb	r0, [r0, #0]
}
    59bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    59c0:	f7ff bfa8 	b.w	5914 <handle_event>
    59c4:	0001f2b8 	.word	0x0001f2b8

000059c8 <hci_cmd_done>:
{
    59c8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    59cc:	4606      	mov	r6, r0
    59ce:	b085      	sub	sp, #20
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    59d0:	7990      	ldrb	r0, [r2, #6]
    59d2:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 5ac4 <hci_cmd_done+0xfc>
{
    59d6:	460f      	mov	r7, r1
    59d8:	4615      	mov	r5, r2
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    59da:	f010 fd05 	bl	163e8 <net_buf_pool_get>
    59de:	4580      	cmp	r8, r0
    59e0:	d01a      	beq.n	5a18 <hci_cmd_done+0x50>
		BT_WARN("opcode 0x%04x pool id %u pool %p != &hci_cmd_pool %p",
    59e2:	2302      	movs	r3, #2
    59e4:	f04f 0400 	mov.w	r4, #0
    59e8:	f363 0407 	bfi	r4, r3, #0, #8
    59ec:	4a30      	ldr	r2, [pc, #192]	; (5ab0 <hci_cmd_done+0xe8>)
    59ee:	4b31      	ldr	r3, [pc, #196]	; (5ab4 <hci_cmd_done+0xec>)
    59f0:	79a8      	ldrb	r0, [r5, #6]
    59f2:	9600      	str	r6, [sp, #0]
    59f4:	1ad2      	subs	r2, r2, r3
    59f6:	08d2      	lsrs	r2, r2, #3
    59f8:	f362 148f 	bfi	r4, r2, #6, #10
    59fc:	9001      	str	r0, [sp, #4]
    59fe:	f010 fcf3 	bl	163e8 <net_buf_pool_get>
    5a02:	4623      	mov	r3, r4
    5a04:	e9cd 0802 	strd	r0, r8, [sp, #8]
    5a08:	2204      	movs	r2, #4
    5a0a:	4669      	mov	r1, sp
    5a0c:	482a      	ldr	r0, [pc, #168]	; (5ab8 <hci_cmd_done+0xf0>)
    5a0e:	f014 fe54 	bl	1a6ba <log_n>
}
    5a12:	b005      	add	sp, #20
    5a14:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (cmd(buf)->opcode != opcode) {
    5a18:	4628      	mov	r0, r5
    5a1a:	f010 fceb 	bl	163f4 <net_buf_id>
    5a1e:	4c27      	ldr	r4, [pc, #156]	; (5abc <hci_cmd_done+0xf4>)
    5a20:	f04f 080c 	mov.w	r8, #12
    5a24:	fb08 4000 	mla	r0, r8, r0, r4
    5a28:	8843      	ldrh	r3, [r0, #2]
    5a2a:	42b3      	cmp	r3, r6
    5a2c:	d015      	beq.n	5a5a <hci_cmd_done+0x92>
		BT_WARN("OpCode 0x%04x completed instead of expected 0x%04x",
    5a2e:	2302      	movs	r3, #2
    5a30:	f04f 0900 	mov.w	r9, #0
    5a34:	f363 0907 	bfi	r9, r3, #0, #8
    5a38:	4a1d      	ldr	r2, [pc, #116]	; (5ab0 <hci_cmd_done+0xe8>)
    5a3a:	4b1e      	ldr	r3, [pc, #120]	; (5ab4 <hci_cmd_done+0xec>)
    5a3c:	1ad2      	subs	r2, r2, r3
    5a3e:	08d2      	lsrs	r2, r2, #3
    5a40:	4628      	mov	r0, r5
    5a42:	f362 198f 	bfi	r9, r2, #6, #10
    5a46:	f010 fcd5 	bl	163f4 <net_buf_id>
    5a4a:	fb08 4000 	mla	r0, r8, r0, r4
    5a4e:	464b      	mov	r3, r9
    5a50:	8842      	ldrh	r2, [r0, #2]
    5a52:	481b      	ldr	r0, [pc, #108]	; (5ac0 <hci_cmd_done+0xf8>)
    5a54:	4631      	mov	r1, r6
    5a56:	f014 fdfd 	bl	1a654 <log_2>
	if (cmd(buf)->state && !status) {
    5a5a:	4628      	mov	r0, r5
    5a5c:	f010 fcca 	bl	163f4 <net_buf_id>
    5a60:	260c      	movs	r6, #12
    5a62:	fb06 4000 	mla	r0, r6, r0, r4
    5a66:	6843      	ldr	r3, [r0, #4]
    5a68:	b15b      	cbz	r3, 5a82 <hci_cmd_done+0xba>
    5a6a:	b957      	cbnz	r7, 5a82 <hci_cmd_done+0xba>
		struct cmd_state_set *update = cmd(buf)->state;
    5a6c:	4628      	mov	r0, r5
    5a6e:	f010 fcc1 	bl	163f4 <net_buf_id>
    5a72:	fb06 4000 	mla	r0, r6, r0, r4
    5a76:	6843      	ldr	r3, [r0, #4]
		atomic_set_bit_to(update->target, update->bit, update->val);
    5a78:	7a1a      	ldrb	r2, [r3, #8]
    5a7a:	e9d3 0100 	ldrd	r0, r1, [r3]
    5a7e:	f015 fc1f 	bl	1b2c0 <atomic_set_bit_to>
	if (cmd(buf)->sync) {
    5a82:	4628      	mov	r0, r5
    5a84:	f010 fcb6 	bl	163f4 <net_buf_id>
    5a88:	260c      	movs	r6, #12
    5a8a:	fb06 4000 	mla	r0, r6, r0, r4
    5a8e:	6883      	ldr	r3, [r0, #8]
    5a90:	2b00      	cmp	r3, #0
    5a92:	d0be      	beq.n	5a12 <hci_cmd_done+0x4a>
		cmd(buf)->status = status;
    5a94:	4628      	mov	r0, r5
    5a96:	f010 fcad 	bl	163f4 <net_buf_id>
    5a9a:	4370      	muls	r0, r6
    5a9c:	5427      	strb	r7, [r4, r0]
		k_sem_give(cmd(buf)->sync);
    5a9e:	4628      	mov	r0, r5
    5aa0:	f010 fca8 	bl	163f4 <net_buf_id>
    5aa4:	fb06 4000 	mla	r0, r6, r0, r4
    5aa8:	6880      	ldr	r0, [r0, #8]
	z_impl_k_sem_give(sem);
    5aaa:	f012 fceb 	bl	18484 <z_impl_k_sem_give>
    5aae:	e7b0      	b.n	5a12 <hci_cmd_done+0x4a>
    5ab0:	0001ede8 	.word	0x0001ede8
    5ab4:	0001ed28 	.word	0x0001ed28
    5ab8:	00020985 	.word	0x00020985
    5abc:	2000020c 	.word	0x2000020c
    5ac0:	000209ba 	.word	0x000209ba
    5ac4:	20005d28 	.word	0x20005d28

00005ac8 <id_find>:
	memcpy(addrs, bt_dev.id_addr, to_copy * sizeof(bt_addr_le_t));
	*count = to_copy;
}

static int id_find(const bt_addr_le_t *addr)
{
    5ac8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u8_t id;

	for (id = 0U; id < bt_dev.id_count; id++) {
    5aca:	4e0b      	ldr	r6, [pc, #44]	; (5af8 <id_find+0x30>)
{
    5acc:	4607      	mov	r7, r0
	for (id = 0U; id < bt_dev.id_count; id++) {
    5ace:	2500      	movs	r5, #0
    5ad0:	79f3      	ldrb	r3, [r6, #7]
    5ad2:	b2ec      	uxtb	r4, r5
    5ad4:	42a3      	cmp	r3, r4
    5ad6:	d802      	bhi.n	5ade <id_find+0x16>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
			return id;
		}
	}

	return -ENOENT;
    5ad8:	f06f 0401 	mvn.w	r4, #1
    5adc:	e009      	b.n	5af2 <id_find+0x2a>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
    5ade:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
	return memcmp(a, b, sizeof(*a));
}

static inline int bt_addr_le_cmp(const bt_addr_le_t *a, const bt_addr_le_t *b)
{
	return memcmp(a, b, sizeof(*a));
    5ae2:	2207      	movs	r2, #7
    5ae4:	4431      	add	r1, r6
    5ae6:	4638      	mov	r0, r7
    5ae8:	f015 fa77 	bl	1afda <memcmp>
    5aec:	3501      	adds	r5, #1
    5aee:	2800      	cmp	r0, #0
    5af0:	d1ee      	bne.n	5ad0 <id_find+0x8>
}
    5af2:	4620      	mov	r0, r4
    5af4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5af6:	bf00      	nop
    5af8:	20005438 	.word	0x20005438

00005afc <hci_tx_thread>:
{
    5afc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		BT_ERR("Uncleared pending sent_cmd");
    5b00:	4a52      	ldr	r2, [pc, #328]	; (5c4c <hci_tx_thread+0x150>)
    5b02:	4b53      	ldr	r3, [pc, #332]	; (5c50 <hci_tx_thread+0x154>)
    5b04:	1a9b      	subs	r3, r3, r2
    5b06:	f3c3 0bc9 	ubfx	fp, r3, #3, #10
		events[0].state = K_POLL_STATE_NOT_READY;
    5b0a:	4a52      	ldr	r2, [pc, #328]	; (5c54 <hci_tx_thread+0x158>)
    5b0c:	68d3      	ldr	r3, [r2, #12]
    5b0e:	f36f 3310 	bfc	r3, #12, #5
    5b12:	60d3      	str	r3, [r2, #12]
			ev_count += bt_conn_prepare_events(&events[1]);
    5b14:	f102 0014 	add.w	r0, r2, #20
    5b18:	f002 fad0 	bl	80bc <bt_conn_prepare_events>
    5b1c:	1c47      	adds	r7, r0, #1
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&events, *(uintptr_t *)&num_events, *(uintptr_t *)&timeout, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
    5b1e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    5b22:	4639      	mov	r1, r7
    5b24:	484b      	ldr	r0, [pc, #300]	; (5c54 <hci_tx_thread+0x158>)
    5b26:	f012 ffe3 	bl	18af0 <z_impl_k_poll>
		BT_ASSERT(err == 0);
    5b2a:	b160      	cbz	r0, 5b46 <hci_tx_thread+0x4a>
    5b2c:	f640 73ab 	movw	r3, #4011	; 0xfab
    5b30:	4a49      	ldr	r2, [pc, #292]	; (5c58 <hci_tx_thread+0x15c>)
    5b32:	494a      	ldr	r1, [pc, #296]	; (5c5c <hci_tx_thread+0x160>)
    5b34:	484a      	ldr	r0, [pc, #296]	; (5c60 <hci_tx_thread+0x164>)
    5b36:	f013 fc1d 	bl	19374 <printk>
    5b3a:	4040      	eors	r0, r0
    5b3c:	f380 8811 	msr	BASEPRI, r0
    5b40:	f04f 0003 	mov.w	r0, #3
    5b44:	df02      	svc	2
{
    5b46:	4d43      	ldr	r5, [pc, #268]	; (5c54 <hci_tx_thread+0x158>)
	return z_impl_k_sem_take(sem, timeout);
    5b48:	4c46      	ldr	r4, [pc, #280]	; (5c64 <hci_tx_thread+0x168>)
	for (; count; ev++, count--) {
    5b4a:	b917      	cbnz	r7, 5b52 <hci_tx_thread+0x56>
	z_impl_k_yield();
    5b4c:	f012 fc20 	bl	18390 <z_impl_k_yield>
    5b50:	e7db      	b.n	5b0a <hci_tx_thread+0xe>
		switch (ev->state) {
    5b52:	68e9      	ldr	r1, [r5, #12]
    5b54:	f3c1 3104 	ubfx	r1, r1, #12, #5
    5b58:	2901      	cmp	r1, #1
    5b5a:	d960      	bls.n	5c1e <hci_tx_thread+0x122>
    5b5c:	2904      	cmp	r1, #4
    5b5e:	d168      	bne.n	5c32 <hci_tx_thread+0x136>
			if (ev->tag == BT_EVENT_CMD_TX) {
    5b60:	7b29      	ldrb	r1, [r5, #12]
    5b62:	2900      	cmp	r1, #0
    5b64:	d15e      	bne.n	5c24 <hci_tx_thread+0x128>
	buf = net_buf_get(&bt_dev.cmd_tx_queue, K_NO_WAIT);
    5b66:	4840      	ldr	r0, [pc, #256]	; (5c68 <hci_tx_thread+0x16c>)
    5b68:	f018 f842 	bl	1dbf0 <net_buf_get>
	BT_ASSERT(buf);
    5b6c:	4606      	mov	r6, r0
    5b6e:	b960      	cbnz	r0, 5b8a <hci_tx_thread+0x8e>
    5b70:	f640 734c 	movw	r3, #3916	; 0xf4c
    5b74:	4a38      	ldr	r2, [pc, #224]	; (5c58 <hci_tx_thread+0x15c>)
    5b76:	493d      	ldr	r1, [pc, #244]	; (5c6c <hci_tx_thread+0x170>)
    5b78:	4839      	ldr	r0, [pc, #228]	; (5c60 <hci_tx_thread+0x164>)
    5b7a:	f013 fbfb 	bl	19374 <printk>
    5b7e:	4040      	eors	r0, r0
    5b80:	f380 8811 	msr	BASEPRI, r0
    5b84:	f04f 0003 	mov.w	r0, #3
    5b88:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
    5b8a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    5b8e:	4838      	ldr	r0, [pc, #224]	; (5c70 <hci_tx_thread+0x174>)
    5b90:	f012 fca4 	bl	184dc <z_impl_k_sem_take>
	if (bt_dev.sent_cmd) {
    5b94:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
    5b98:	b193      	cbz	r3, 5bc0 <hci_tx_thread+0xc4>
		BT_ERR("Uncleared pending sent_cmd");
    5b9a:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
    5b9e:	f043 0301 	orr.w	r3, r3, #1
    5ba2:	f363 0807 	bfi	r8, r3, #0, #8
    5ba6:	f36b 188f 	bfi	r8, fp, #6, #10
    5baa:	4641      	mov	r1, r8
    5bac:	4831      	ldr	r0, [pc, #196]	; (5c74 <hci_tx_thread+0x178>)
    5bae:	f014 fd30 	bl	1a612 <log_0>
		net_buf_unref(bt_dev.sent_cmd);
    5bb2:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
    5bb6:	f010 fcb3 	bl	16520 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    5bba:	2300      	movs	r3, #0
    5bbc:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
	bt_dev.sent_cmd = net_buf_ref(buf);
    5bc0:	4630      	mov	r0, r6
    5bc2:	f018 f83f 	bl	1dc44 <net_buf_ref>
    5bc6:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
		return bt_hci_ecc_send(buf);
    5bca:	4630      	mov	r0, r6
    5bcc:	f7ff fa20 	bl	5010 <bt_hci_ecc_send>
	if (err) {
    5bd0:	4601      	mov	r1, r0
    5bd2:	b320      	cbz	r0, 5c1e <hci_tx_thread+0x122>
		BT_ERR("Unable to send to driver (err %d)", err);
    5bd4:	f029 033f 	bic.w	r3, r9, #63	; 0x3f
    5bd8:	f043 0301 	orr.w	r3, r3, #1
    5bdc:	f363 0907 	bfi	r9, r3, #0, #8
    5be0:	f36b 198f 	bfi	r9, fp, #6, #10
    5be4:	464a      	mov	r2, r9
    5be6:	4824      	ldr	r0, [pc, #144]	; (5c78 <hci_tx_thread+0x17c>)
    5be8:	f014 fd20 	bl	1a62c <log_1>
	z_impl_k_sem_give(sem);
    5bec:	4820      	ldr	r0, [pc, #128]	; (5c70 <hci_tx_thread+0x174>)
    5bee:	f012 fc49 	bl	18484 <z_impl_k_sem_give>
		hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED,
    5bf2:	4630      	mov	r0, r6
    5bf4:	f010 fbfe 	bl	163f4 <net_buf_id>
    5bf8:	4a20      	ldr	r2, [pc, #128]	; (5c7c <hci_tx_thread+0x180>)
    5bfa:	230c      	movs	r3, #12
    5bfc:	fb03 2000 	mla	r0, r3, r0, r2
    5c00:	211f      	movs	r1, #31
    5c02:	2200      	movs	r2, #0
    5c04:	8840      	ldrh	r0, [r0, #2]
    5c06:	f7ff fedf 	bl	59c8 <hci_cmd_done>
		net_buf_unref(bt_dev.sent_cmd);
    5c0a:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
    5c0e:	f010 fc87 	bl	16520 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    5c12:	2300      	movs	r3, #0
		net_buf_unref(buf);
    5c14:	4630      	mov	r0, r6
		bt_dev.sent_cmd = NULL;
    5c16:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
		net_buf_unref(buf);
    5c1a:	f010 fc81 	bl	16520 <net_buf_unref>
	for (; count; ev++, count--) {
    5c1e:	3514      	adds	r5, #20
    5c20:	3f01      	subs	r7, #1
    5c22:	e792      	b.n	5b4a <hci_tx_thread+0x4e>
				if (ev->tag == BT_EVENT_CONN_TX_QUEUE) {
    5c24:	2901      	cmp	r1, #1
    5c26:	d1fa      	bne.n	5c1e <hci_tx_thread+0x122>
					conn = CONTAINER_OF(ev->fifo,
    5c28:	6928      	ldr	r0, [r5, #16]
					bt_conn_process_tx(conn);
    5c2a:	3834      	subs	r0, #52	; 0x34
    5c2c:	f002 fcee 	bl	860c <bt_conn_process_tx>
    5c30:	e7f5      	b.n	5c1e <hci_tx_thread+0x122>
			BT_WARN("Unexpected k_poll event state %u", ev->state);
    5c32:	f02a 033f 	bic.w	r3, sl, #63	; 0x3f
    5c36:	f043 0302 	orr.w	r3, r3, #2
    5c3a:	f363 0a07 	bfi	sl, r3, #0, #8
    5c3e:	f36b 1a8f 	bfi	sl, fp, #6, #10
    5c42:	4652      	mov	r2, sl
    5c44:	480e      	ldr	r0, [pc, #56]	; (5c80 <hci_tx_thread+0x184>)
    5c46:	f014 fcf1 	bl	1a62c <log_1>
    5c4a:	e7e8      	b.n	5c1e <hci_tx_thread+0x122>
    5c4c:	0001ed28 	.word	0x0001ed28
    5c50:	0001ede8 	.word	0x0001ede8
    5c54:	2000564c 	.word	0x2000564c
    5c58:	00020a6e 	.word	0x00020a6e
    5c5c:	00020a9b 	.word	0x00020a9b
    5c60:	00020aa4 	.word	0x00020aa4
    5c64:	20005438 	.word	0x20005438
    5c68:	200054fc 	.word	0x200054fc
    5c6c:	00022590 	.word	0x00022590
    5c70:	200054e0 	.word	0x200054e0
    5c74:	00020ac1 	.word	0x00020ac1
    5c78:	00020adc 	.word	0x00020adc
    5c7c:	2000020c 	.word	0x2000020c
    5c80:	00020afe 	.word	0x00020afe

00005c84 <hci_num_completed_packets>:
{
    5c84:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
				BT_ERR("packets count mismatch");
    5c88:	4b4f      	ldr	r3, [pc, #316]	; (5dc8 <hci_num_completed_packets+0x144>)
    5c8a:	4c50      	ldr	r4, [pc, #320]	; (5dcc <hci_num_completed_packets+0x148>)
	struct bt_hci_evt_num_completed_packets *evt = (void *)buf->data;
    5c8c:	f8d0 9008 	ldr.w	r9, [r0, #8]
				BT_ERR("packets count mismatch");
    5c90:	1ae4      	subs	r4, r4, r3
    5c92:	f3c4 04c9 	ubfx	r4, r4, #3, #10
	for (i = 0; i < evt->num_handles; i++) {
    5c96:	2500      	movs	r5, #0
    5c98:	f899 3000 	ldrb.w	r3, [r9]
    5c9c:	429d      	cmp	r5, r3
    5c9e:	db02      	blt.n	5ca6 <hci_num_completed_packets+0x22>
}
    5ca0:	b003      	add	sp, #12
    5ca2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		handle = sys_le16_to_cpu(evt->h[i].handle);
    5ca6:	eb09 0385 	add.w	r3, r9, r5, lsl #2
    5caa:	f8b3 b001 	ldrh.w	fp, [r3, #1]
		count = sys_le16_to_cpu(evt->h[i].count);
    5cae:	f8b3 6003 	ldrh.w	r6, [r3, #3]
	__asm__ volatile(
    5cb2:	f04f 0320 	mov.w	r3, #32
    5cb6:	f3ef 8211 	mrs	r2, BASEPRI
    5cba:	f383 8811 	msr	BASEPRI, r3
    5cbe:	f3bf 8f6f 	isb	sy
		conn = bt_conn_lookup_handle(handle);
    5cc2:	4658      	mov	r0, fp
    5cc4:	9201      	str	r2, [sp, #4]
    5cc6:	f002 fb3f 	bl	8348 <bt_conn_lookup_handle>
		if (!conn) {
    5cca:	9a01      	ldr	r2, [sp, #4]
    5ccc:	4682      	mov	sl, r0
    5cce:	b990      	cbnz	r0, 5cf6 <hci_num_completed_packets+0x72>
	__asm__ volatile(
    5cd0:	f382 8811 	msr	BASEPRI, r2
    5cd4:	f3bf 8f6f 	isb	sy
			BT_ERR("No connection for handle %u", handle);
    5cd8:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
    5cdc:	f043 0301 	orr.w	r3, r3, #1
    5ce0:	f363 0707 	bfi	r7, r3, #0, #8
    5ce4:	f364 178f 	bfi	r7, r4, #6, #10
    5ce8:	463a      	mov	r2, r7
    5cea:	4659      	mov	r1, fp
    5cec:	4838      	ldr	r0, [pc, #224]	; (5dd0 <hci_num_completed_packets+0x14c>)
    5cee:	f014 fc9d 	bl	1a62c <log_1>
	for (i = 0; i < evt->num_handles; i++) {
    5cf2:	3501      	adds	r5, #1
    5cf4:	e7d0      	b.n	5c98 <hci_num_completed_packets+0x14>
    5cf6:	f382 8811 	msr	BASEPRI, r2
    5cfa:	f3bf 8f6f 	isb	sy
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    5cfe:	f100 0b28 	add.w	fp, r0, #40	; 0x28
		while (count--) {
    5d02:	b3b6      	cbz	r6, 5d72 <hci_num_completed_packets+0xee>
	__asm__ volatile(
    5d04:	f04f 0220 	mov.w	r2, #32
    5d08:	f3ef 8111 	mrs	r1, BASEPRI
    5d0c:	f382 8811 	msr	BASEPRI, r2
    5d10:	f3bf 8f6f 	isb	sy
			if (conn->pending_no_cb) {
    5d14:	f8da 201c 	ldr.w	r2, [sl, #28]
    5d18:	b172      	cbz	r2, 5d38 <hci_num_completed_packets+0xb4>
				conn->pending_no_cb--;
    5d1a:	3a01      	subs	r2, #1
    5d1c:	f8ca 201c 	str.w	r2, [sl, #28]
	__asm__ volatile(
    5d20:	f381 8811 	msr	BASEPRI, r1
    5d24:	f3bf 8f6f 	isb	sy
			k_sem_give(bt_conn_get_pkts(conn));
    5d28:	4650      	mov	r0, sl
    5d2a:	f002 f809 	bl	7d40 <bt_conn_get_pkts>
    5d2e:	3e01      	subs	r6, #1
    5d30:	f012 fba8 	bl	18484 <z_impl_k_sem_give>
    5d34:	b2b6      	uxth	r6, r6
    5d36:	e7e4      	b.n	5d02 <hci_num_completed_packets+0x7e>
Z_GENLIST_IS_EMPTY(slist)
    5d38:	f8da 2014 	ldr.w	r2, [sl, #20]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    5d3c:	b142      	cbz	r2, 5d50 <hci_num_completed_packets+0xcc>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    5d3e:	f8da 0018 	ldr.w	r0, [sl, #24]
    5d42:	6813      	ldr	r3, [r2, #0]
	list->head = node;
    5d44:	f8ca 3014 	str.w	r3, [sl, #20]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    5d48:	4282      	cmp	r2, r0
	list->tail = node;
    5d4a:	bf08      	it	eq
    5d4c:	f8ca 3018 	streq.w	r3, [sl, #24]
    5d50:	f381 8811 	msr	BASEPRI, r1
    5d54:	f3bf 8f6f 	isb	sy
			if (!node) {
    5d58:	b97a      	cbnz	r2, 5d7a <hci_num_completed_packets+0xf6>
				BT_ERR("packets count mismatch");
    5d5a:	f028 023f 	bic.w	r2, r8, #63	; 0x3f
    5d5e:	f042 0201 	orr.w	r2, r2, #1
    5d62:	f362 0807 	bfi	r8, r2, #0, #8
    5d66:	f364 188f 	bfi	r8, r4, #6, #10
    5d6a:	4641      	mov	r1, r8
    5d6c:	4819      	ldr	r0, [pc, #100]	; (5dd4 <hci_num_completed_packets+0x150>)
    5d6e:	f014 fc50 	bl	1a612 <log_0>
		bt_conn_unref(conn);
    5d72:	4650      	mov	r0, sl
    5d74:	f015 fc23 	bl	1b5be <bt_conn_unref>
    5d78:	e7bb      	b.n	5cf2 <hci_num_completed_packets+0x6e>
	__asm__ volatile(
    5d7a:	f04f 0120 	mov.w	r1, #32
    5d7e:	f3ef 8011 	mrs	r0, BASEPRI
    5d82:	f381 8811 	msr	BASEPRI, r1
    5d86:	f3bf 8f6f 	isb	sy
			tx->pending_no_cb = 0U;
    5d8a:	2300      	movs	r3, #0
			conn->pending_no_cb = tx->pending_no_cb;
    5d8c:	68d1      	ldr	r1, [r2, #12]
    5d8e:	f8ca 101c 	str.w	r1, [sl, #28]
	parent->next = child;
    5d92:	6013      	str	r3, [r2, #0]
Z_GENLIST_APPEND(slist, snode)
    5d94:	f8da 1024 	ldr.w	r1, [sl, #36]	; 0x24
			tx->pending_no_cb = 0U;
    5d98:	60d3      	str	r3, [r2, #12]
    5d9a:	b989      	cbnz	r1, 5dc0 <hci_num_completed_packets+0x13c>
	list->head = node;
    5d9c:	e9ca 2208 	strd	r2, r2, [sl, #32]
	__asm__ volatile(
    5da0:	f380 8811 	msr	BASEPRI, r0
    5da4:	f3bf 8f6f 	isb	sy
    5da8:	2101      	movs	r1, #1
    5daa:	f10a 0030 	add.w	r0, sl, #48	; 0x30
    5dae:	f015 fa78 	bl	1b2a2 <atomic_or>
    5db2:	07c3      	lsls	r3, r0, #31
    5db4:	d4b8      	bmi.n	5d28 <hci_num_completed_packets+0xa4>
		k_queue_append(&work_q->queue, work);
    5db6:	4659      	mov	r1, fp
    5db8:	4807      	ldr	r0, [pc, #28]	; (5dd8 <hci_num_completed_packets+0x154>)
    5dba:	f018 fac7 	bl	1e34c <k_queue_append>
    5dbe:	e7b3      	b.n	5d28 <hci_num_completed_packets+0xa4>
	parent->next = child;
    5dc0:	600a      	str	r2, [r1, #0]
	list->tail = node;
    5dc2:	f8ca 2024 	str.w	r2, [sl, #36]	; 0x24
    5dc6:	e7eb      	b.n	5da0 <hci_num_completed_packets+0x11c>
    5dc8:	0001ed28 	.word	0x0001ed28
    5dcc:	0001ede8 	.word	0x0001ede8
    5dd0:	00020a3b 	.word	0x00020a3b
    5dd4:	00020a57 	.word	0x00020a57
    5dd8:	20001a60 	.word	0x20001a60

00005ddc <hci_cmd_status>:
{
    5ddc:	b538      	push	{r3, r4, r5, lr}
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    5dde:	2104      	movs	r1, #4
{
    5de0:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    5de2:	3008      	adds	r0, #8
    5de4:	f017 ff63 	bl	1dcae <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
    5de8:	7845      	ldrb	r5, [r0, #1]
	hci_cmd_done(opcode, evt->status, buf);
    5dea:	7801      	ldrb	r1, [r0, #0]
    5dec:	8840      	ldrh	r0, [r0, #2]
    5dee:	4622      	mov	r2, r4
    5df0:	f7ff fdea 	bl	59c8 <hci_cmd_done>
	if (ncmd) {
    5df4:	b125      	cbz	r5, 5e00 <hci_cmd_status+0x24>
    5df6:	4803      	ldr	r0, [pc, #12]	; (5e04 <hci_cmd_status+0x28>)
}
    5df8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    5dfc:	f012 bb42 	b.w	18484 <z_impl_k_sem_give>
    5e00:	bd38      	pop	{r3, r4, r5, pc}
    5e02:	bf00      	nop
    5e04:	200054e0 	.word	0x200054e0

00005e08 <hci_cmd_complete>:
{
    5e08:	b538      	push	{r3, r4, r5, lr}
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    5e0a:	2103      	movs	r1, #3
{
    5e0c:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    5e0e:	3008      	adds	r0, #8
    5e10:	f017 ff4d 	bl	1dcae <net_buf_simple_pull_mem>
	status = buf->data[0];
    5e14:	68a3      	ldr	r3, [r4, #8]
	ncmd = evt->ncmd;
    5e16:	7805      	ldrb	r5, [r0, #0]
	hci_cmd_done(opcode, status, buf);
    5e18:	7819      	ldrb	r1, [r3, #0]
    5e1a:	f8b0 0001 	ldrh.w	r0, [r0, #1]
    5e1e:	4622      	mov	r2, r4
    5e20:	f7ff fdd2 	bl	59c8 <hci_cmd_done>
	if (ncmd) {
    5e24:	b125      	cbz	r5, 5e30 <hci_cmd_complete+0x28>
    5e26:	4803      	ldr	r0, [pc, #12]	; (5e34 <hci_cmd_complete+0x2c>)
}
    5e28:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    5e2c:	f012 bb2a 	b.w	18484 <z_impl_k_sem_give>
    5e30:	bd38      	pop	{r3, r4, r5, pc}
    5e32:	bf00      	nop
    5e34:	200054e0 	.word	0x200054e0

00005e38 <bt_hci_cmd_create>:
{
    5e38:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5e3c:	4681      	mov	r9, r0
    5e3e:	468a      	mov	sl, r1
	buf = net_buf_alloc(&hci_cmd_pool, K_FOREVER);
    5e40:	4816      	ldr	r0, [pc, #88]	; (5e9c <bt_hci_cmd_create+0x64>)
	cmd(buf)->opcode = opcode;
    5e42:	4f17      	ldr	r7, [pc, #92]	; (5ea0 <bt_hci_cmd_create+0x68>)
	buf = net_buf_alloc(&hci_cmd_pool, K_FOREVER);
    5e44:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    5e48:	f017 fecc 	bl	1dbe4 <net_buf_alloc_fixed>
    5e4c:	4604      	mov	r4, r0
	net_buf_reserve(buf, BT_BUF_RESERVE);
    5e4e:	f100 0808 	add.w	r8, r0, #8
    5e52:	2100      	movs	r1, #0
	*(u8_t *)net_buf_user_data(buf) = type;
    5e54:	2600      	movs	r6, #0
    5e56:	4640      	mov	r0, r8
    5e58:	f017 fee3 	bl	1dc22 <net_buf_simple_reserve>
    5e5c:	7526      	strb	r6, [r4, #20]
	cmd(buf)->opcode = opcode;
    5e5e:	4620      	mov	r0, r4
    5e60:	f010 fac8 	bl	163f4 <net_buf_id>
    5e64:	250c      	movs	r5, #12
    5e66:	fb05 7000 	mla	r0, r5, r0, r7
    5e6a:	f8a0 9002 	strh.w	r9, [r0, #2]
	cmd(buf)->sync = NULL;
    5e6e:	4620      	mov	r0, r4
    5e70:	f010 fac0 	bl	163f4 <net_buf_id>
    5e74:	fb05 7000 	mla	r0, r5, r0, r7
    5e78:	6086      	str	r6, [r0, #8]
	cmd(buf)->state = NULL;
    5e7a:	4620      	mov	r0, r4
    5e7c:	f010 faba 	bl	163f4 <net_buf_id>
    5e80:	fb05 7000 	mla	r0, r5, r0, r7
	hdr = net_buf_add(buf, sizeof(*hdr));
    5e84:	2103      	movs	r1, #3
	cmd(buf)->state = NULL;
    5e86:	6046      	str	r6, [r0, #4]
	hdr = net_buf_add(buf, sizeof(*hdr));
    5e88:	4640      	mov	r0, r8
    5e8a:	f017 fedf 	bl	1dc4c <net_buf_simple_add>
	hdr->param_len = param_len;
    5e8e:	f880 a002 	strb.w	sl, [r0, #2]
	hdr->opcode = sys_cpu_to_le16(opcode);
    5e92:	f8a0 9000 	strh.w	r9, [r0]
}
    5e96:	4620      	mov	r0, r4
    5e98:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5e9c:	20005d28 	.word	0x20005d28
    5ea0:	2000020c 	.word	0x2000020c

00005ea4 <bt_hci_cmd_send>:
{
    5ea4:	b538      	push	{r3, r4, r5, lr}
    5ea6:	4604      	mov	r4, r0
	if (!buf) {
    5ea8:	460d      	mov	r5, r1
    5eaa:	b919      	cbnz	r1, 5eb4 <bt_hci_cmd_send+0x10>
		buf = bt_hci_cmd_create(opcode, 0);
    5eac:	f7ff ffc4 	bl	5e38 <bt_hci_cmd_create>
		if (!buf) {
    5eb0:	4605      	mov	r5, r0
    5eb2:	b310      	cbz	r0, 5efa <bt_hci_cmd_send+0x56>
	if (opcode == BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS) {
    5eb4:	f640 4335 	movw	r3, #3125	; 0xc35
    5eb8:	429c      	cmp	r4, r3
    5eba:	d118      	bne.n	5eee <bt_hci_cmd_send+0x4a>
		return bt_hci_ecc_send(buf);
    5ebc:	4628      	mov	r0, r5
    5ebe:	f7ff f8a7 	bl	5010 <bt_hci_ecc_send>
		if (err) {
    5ec2:	4604      	mov	r4, r0
    5ec4:	b188      	cbz	r0, 5eea <bt_hci_cmd_send+0x46>
			BT_ERR("Unable to send to driver (err %d)", err);
    5ec6:	2301      	movs	r3, #1
    5ec8:	f04f 0200 	mov.w	r2, #0
    5ecc:	f363 0207 	bfi	r2, r3, #0, #8
    5ed0:	490b      	ldr	r1, [pc, #44]	; (5f00 <bt_hci_cmd_send+0x5c>)
    5ed2:	4b0c      	ldr	r3, [pc, #48]	; (5f04 <bt_hci_cmd_send+0x60>)
    5ed4:	1a5b      	subs	r3, r3, r1
    5ed6:	08db      	lsrs	r3, r3, #3
    5ed8:	4601      	mov	r1, r0
    5eda:	f363 128f 	bfi	r2, r3, #6, #10
    5ede:	480a      	ldr	r0, [pc, #40]	; (5f08 <bt_hci_cmd_send+0x64>)
    5ee0:	f014 fba4 	bl	1a62c <log_1>
			net_buf_unref(buf);
    5ee4:	4628      	mov	r0, r5
    5ee6:	f010 fb1b 	bl	16520 <net_buf_unref>
}
    5eea:	4620      	mov	r0, r4
    5eec:	bd38      	pop	{r3, r4, r5, pc}
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
    5eee:	4629      	mov	r1, r5
    5ef0:	4806      	ldr	r0, [pc, #24]	; (5f0c <bt_hci_cmd_send+0x68>)
    5ef2:	f017 fe9a 	bl	1dc2a <net_buf_put>
	return 0;
    5ef6:	2400      	movs	r4, #0
    5ef8:	e7f7      	b.n	5eea <bt_hci_cmd_send+0x46>
			return -ENOBUFS;
    5efa:	f06f 0436 	mvn.w	r4, #54	; 0x36
    5efe:	e7f4      	b.n	5eea <bt_hci_cmd_send+0x46>
    5f00:	0001ed28 	.word	0x0001ed28
    5f04:	0001ede8 	.word	0x0001ede8
    5f08:	00020adc 	.word	0x00020adc
    5f0c:	200054fc 	.word	0x200054fc

00005f10 <le_ltk_request>:
{
    5f10:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_hci_evt_le_ltk_request *evt = (void *)buf->data;
    5f12:	6884      	ldr	r4, [r0, #8]
	handle = sys_le16_to_cpu(evt->handle);
    5f14:	8826      	ldrh	r6, [r4, #0]
    5f16:	b2b7      	uxth	r7, r6
{
    5f18:	b087      	sub	sp, #28
	conn = bt_conn_lookup_handle(handle);
    5f1a:	4638      	mov	r0, r7
    5f1c:	f002 fa14 	bl	8348 <bt_conn_lookup_handle>
	if (!conn) {
    5f20:	4605      	mov	r5, r0
    5f22:	b980      	cbnz	r0, 5f46 <le_ltk_request+0x36>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    5f24:	2301      	movs	r3, #1
    5f26:	f04f 0200 	mov.w	r2, #0
    5f2a:	f363 0207 	bfi	r2, r3, #0, #8
    5f2e:	4928      	ldr	r1, [pc, #160]	; (5fd0 <le_ltk_request+0xc0>)
    5f30:	4b28      	ldr	r3, [pc, #160]	; (5fd4 <le_ltk_request+0xc4>)
    5f32:	4829      	ldr	r0, [pc, #164]	; (5fd8 <le_ltk_request+0xc8>)
    5f34:	1a5b      	subs	r3, r3, r1
    5f36:	08db      	lsrs	r3, r3, #3
    5f38:	f363 128f 	bfi	r2, r3, #6, #10
    5f3c:	4639      	mov	r1, r7
    5f3e:	f014 fb75 	bl	1a62c <log_1>
}
    5f42:	b007      	add	sp, #28
    5f44:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (bt_smp_request_ltk(conn, evt->rand, evt->ediv, ltk)) {
    5f46:	af02      	add	r7, sp, #8
    5f48:	f8d4 2002 	ldr.w	r2, [r4, #2]
    5f4c:	f8d4 3006 	ldr.w	r3, [r4, #6]
    5f50:	9701      	str	r7, [sp, #4]
    5f52:	8961      	ldrh	r1, [r4, #10]
    5f54:	9100      	str	r1, [sp, #0]
    5f56:	f016 fe82 	bl	1cc5e <bt_smp_request_ltk>
    5f5a:	b340      	cbz	r0, 5fae <le_ltk_request+0x9e>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_LTK_REQ_REPLY,
    5f5c:	2112      	movs	r1, #18
    5f5e:	f242 001a 	movw	r0, #8218	; 0x201a
    5f62:	f7ff ff69 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
    5f66:	4604      	mov	r4, r0
    5f68:	b988      	cbnz	r0, 5f8e <le_ltk_request+0x7e>
		BT_ERR("Out of command buffers");
    5f6a:	2301      	movs	r3, #1
    5f6c:	f04f 0100 	mov.w	r1, #0
    5f70:	f363 0107 	bfi	r1, r3, #0, #8
    5f74:	4a16      	ldr	r2, [pc, #88]	; (5fd0 <le_ltk_request+0xc0>)
    5f76:	4b17      	ldr	r3, [pc, #92]	; (5fd4 <le_ltk_request+0xc4>)
    5f78:	4818      	ldr	r0, [pc, #96]	; (5fdc <le_ltk_request+0xcc>)
    5f7a:	1a9b      	subs	r3, r3, r2
    5f7c:	08db      	lsrs	r3, r3, #3
    5f7e:	f363 118f 	bfi	r1, r3, #6, #10
    5f82:	f014 fb46 	bl	1a612 <log_0>
	bt_conn_unref(conn);
    5f86:	4628      	mov	r0, r5
    5f88:	f015 fb19 	bl	1b5be <bt_conn_unref>
    5f8c:	e7d9      	b.n	5f42 <le_ltk_request+0x32>
	cp = net_buf_add(buf, sizeof(*cp));
    5f8e:	2112      	movs	r1, #18
    5f90:	3008      	adds	r0, #8
    5f92:	f017 fe5b 	bl	1dc4c <net_buf_simple_add>
	memcpy(cp->ltk, ltk, sizeof(cp->ltk));
    5f96:	4639      	mov	r1, r7
	cp->handle = sys_cpu_to_le16(handle);
    5f98:	f820 6b02 	strh.w	r6, [r0], #2
	memcpy(cp->ltk, ltk, sizeof(cp->ltk));
    5f9c:	2210      	movs	r2, #16
    5f9e:	f015 f82c 	bl	1affa <memcpy>
	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_REPLY, buf);
    5fa2:	4621      	mov	r1, r4
    5fa4:	f242 001a 	movw	r0, #8218	; 0x201a
	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_NEG_REPLY, buf);
    5fa8:	f7ff ff7c 	bl	5ea4 <bt_hci_cmd_send>
    5fac:	e7eb      	b.n	5f86 <le_ltk_request+0x76>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_LTK_REQ_NEG_REPLY, sizeof(*cp));
    5fae:	2102      	movs	r1, #2
    5fb0:	f242 001b 	movw	r0, #8219	; 0x201b
    5fb4:	f7ff ff40 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
    5fb8:	4604      	mov	r4, r0
    5fba:	2800      	cmp	r0, #0
    5fbc:	d0d5      	beq.n	5f6a <le_ltk_request+0x5a>
	cp = net_buf_add(buf, sizeof(*cp));
    5fbe:	2102      	movs	r1, #2
    5fc0:	3008      	adds	r0, #8
    5fc2:	f017 fe43 	bl	1dc4c <net_buf_simple_add>
	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_NEG_REPLY, buf);
    5fc6:	4621      	mov	r1, r4
	cp->handle = sys_cpu_to_le16(handle);
    5fc8:	8006      	strh	r6, [r0, #0]
	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_NEG_REPLY, buf);
    5fca:	f242 001b 	movw	r0, #8219	; 0x201b
    5fce:	e7eb      	b.n	5fa8 <le_ltk_request+0x98>
    5fd0:	0001ed28 	.word	0x0001ed28
    5fd4:	0001ede8 	.word	0x0001ede8
    5fd8:	00020b5d 	.word	0x00020b5d
    5fdc:	00020b81 	.word	0x00020b81

00005fe0 <le_conn_param_neg_reply>:
{
    5fe0:	b570      	push	{r4, r5, r6, lr}
    5fe2:	4606      	mov	r6, r0
    5fe4:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY,
    5fe6:	f242 0021 	movw	r0, #8225	; 0x2021
    5fea:	2103      	movs	r1, #3
    5fec:	f7ff ff24 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
    5ff0:	4604      	mov	r4, r0
    5ff2:	b978      	cbnz	r0, 6014 <le_conn_param_neg_reply+0x34>
		BT_ERR("Unable to allocate buffer");
    5ff4:	2301      	movs	r3, #1
    5ff6:	f04f 0100 	mov.w	r1, #0
    5ffa:	f363 0107 	bfi	r1, r3, #0, #8
    5ffe:	4a0c      	ldr	r2, [pc, #48]	; (6030 <le_conn_param_neg_reply+0x50>)
    6000:	4b0c      	ldr	r3, [pc, #48]	; (6034 <le_conn_param_neg_reply+0x54>)
    6002:	480d      	ldr	r0, [pc, #52]	; (6038 <le_conn_param_neg_reply+0x58>)
    6004:	1a9b      	subs	r3, r3, r2
    6006:	08db      	lsrs	r3, r3, #3
    6008:	f363 118f 	bfi	r1, r3, #6, #10
}
    600c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_ERR("Unable to allocate buffer");
    6010:	f014 baff 	b.w	1a612 <log_0>
	cp = net_buf_add(buf, sizeof(*cp));
    6014:	2103      	movs	r1, #3
    6016:	3008      	adds	r0, #8
    6018:	f017 fe18 	bl	1dc4c <net_buf_simple_add>
	cp->reason = sys_cpu_to_le16(reason);
    601c:	7085      	strb	r5, [r0, #2]
	cp->handle = sys_cpu_to_le16(handle);
    601e:	8006      	strh	r6, [r0, #0]
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
    6020:	4621      	mov	r1, r4
    6022:	f242 0021 	movw	r0, #8225	; 0x2021
}
    6026:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
    602a:	f7ff bf3b 	b.w	5ea4 <bt_hci_cmd_send>
    602e:	bf00      	nop
    6030:	0001ed28 	.word	0x0001ed28
    6034:	0001ede8 	.word	0x0001ede8
    6038:	00020b43 	.word	0x00020b43

0000603c <le_conn_param_req>:
{
    603c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct bt_hci_evt_le_conn_param_req *evt = (void *)buf->data;
    603e:	6883      	ldr	r3, [r0, #8]
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
    6040:	78d9      	ldrb	r1, [r3, #3]
    6042:	789a      	ldrb	r2, [r3, #2]
	handle = sys_le16_to_cpu(evt->handle);
    6044:	881e      	ldrh	r6, [r3, #0]
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
    6046:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    604a:	f8ad 2000 	strh.w	r2, [sp]
	param.interval_max = sys_le16_to_cpu(evt->interval_max);
    604e:	7959      	ldrb	r1, [r3, #5]
    6050:	791a      	ldrb	r2, [r3, #4]
    6052:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    6056:	f8ad 2002 	strh.w	r2, [sp, #2]
	param.latency = sys_le16_to_cpu(evt->latency);
    605a:	799a      	ldrb	r2, [r3, #6]
    605c:	79d9      	ldrb	r1, [r3, #7]
    605e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    6062:	f8ad 2004 	strh.w	r2, [sp, #4]
	param.timeout = sys_le16_to_cpu(evt->timeout);
    6066:	7a1a      	ldrb	r2, [r3, #8]
    6068:	7a5b      	ldrb	r3, [r3, #9]
	handle = sys_le16_to_cpu(evt->handle);
    606a:	b2b4      	uxth	r4, r6
	param.timeout = sys_le16_to_cpu(evt->timeout);
    606c:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
	conn = bt_conn_lookup_handle(handle);
    6070:	4620      	mov	r0, r4
	param.timeout = sys_le16_to_cpu(evt->timeout);
    6072:	f8ad 3006 	strh.w	r3, [sp, #6]
	conn = bt_conn_lookup_handle(handle);
    6076:	f002 f967 	bl	8348 <bt_conn_lookup_handle>
	if (!conn) {
    607a:	4607      	mov	r7, r0
    607c:	b9a0      	cbnz	r0, 60a8 <le_conn_param_req+0x6c>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    607e:	2301      	movs	r3, #1
    6080:	f04f 0200 	mov.w	r2, #0
    6084:	f363 0207 	bfi	r2, r3, #0, #8
    6088:	491f      	ldr	r1, [pc, #124]	; (6108 <le_conn_param_req+0xcc>)
    608a:	4b20      	ldr	r3, [pc, #128]	; (610c <le_conn_param_req+0xd0>)
    608c:	4820      	ldr	r0, [pc, #128]	; (6110 <le_conn_param_req+0xd4>)
    608e:	1a5b      	subs	r3, r3, r1
    6090:	08db      	lsrs	r3, r3, #3
    6092:	4621      	mov	r1, r4
    6094:	f363 128f 	bfi	r2, r3, #6, #10
    6098:	f014 fac8 	bl	1a62c <log_1>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_UNKNOWN_CONN_ID);
    609c:	2102      	movs	r1, #2
    609e:	4620      	mov	r0, r4
    60a0:	f7ff ff9e 	bl	5fe0 <le_conn_param_neg_reply>
}
    60a4:	b003      	add	sp, #12
    60a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!le_param_req(conn, &param)) {
    60a8:	4669      	mov	r1, sp
    60aa:	f001 fe81 	bl	7db0 <le_param_req>
    60ae:	b938      	cbnz	r0, 60c0 <le_conn_param_req+0x84>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_INVALID_LL_PARAM);
    60b0:	211e      	movs	r1, #30
    60b2:	4620      	mov	r0, r4
    60b4:	f7ff ff94 	bl	5fe0 <le_conn_param_neg_reply>
	bt_conn_unref(conn);
    60b8:	4638      	mov	r0, r7
    60ba:	f015 fa80 	bl	1b5be <bt_conn_unref>
    60be:	e7f1      	b.n	60a4 <le_conn_param_req+0x68>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, sizeof(*cp));
    60c0:	210e      	movs	r1, #14
    60c2:	f242 0020 	movw	r0, #8224	; 0x2020
    60c6:	f7ff feb7 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
    60ca:	4605      	mov	r5, r0
    60cc:	2800      	cmp	r0, #0
    60ce:	d0f3      	beq.n	60b8 <le_conn_param_req+0x7c>
	cp = net_buf_add(buf, sizeof(*cp));
    60d0:	210e      	movs	r1, #14
    60d2:	3008      	adds	r0, #8
    60d4:	f017 fdba 	bl	1dc4c <net_buf_simple_add>
	(void)memset(cp, 0, sizeof(*cp));
    60d8:	220e      	movs	r2, #14
	cp = net_buf_add(buf, sizeof(*cp));
    60da:	4604      	mov	r4, r0
	(void)memset(cp, 0, sizeof(*cp));
    60dc:	2100      	movs	r1, #0
    60de:	f014 ffb6 	bl	1b04e <memset>
	cp->interval_min = sys_cpu_to_le16(param->interval_min);
    60e2:	f8bd 3000 	ldrh.w	r3, [sp]
    60e6:	8063      	strh	r3, [r4, #2]
	cp->interval_max = sys_cpu_to_le16(param->interval_max);
    60e8:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    60ec:	80a3      	strh	r3, [r4, #4]
	cp->latency = sys_cpu_to_le16(param->latency);
    60ee:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    60f2:	80e3      	strh	r3, [r4, #6]
	cp->timeout = sys_cpu_to_le16(param->timeout);
    60f4:	f8bd 3006 	ldrh.w	r3, [sp, #6]
	cp->handle = sys_cpu_to_le16(handle);
    60f8:	8026      	strh	r6, [r4, #0]
	cp->timeout = sys_cpu_to_le16(param->timeout);
    60fa:	8123      	strh	r3, [r4, #8]
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
    60fc:	4629      	mov	r1, r5
    60fe:	f242 0020 	movw	r0, #8224	; 0x2020
    6102:	f7ff fecf 	bl	5ea4 <bt_hci_cmd_send>
    6106:	e7d7      	b.n	60b8 <le_conn_param_req+0x7c>
    6108:	0001ed28 	.word	0x0001ed28
    610c:	0001ede8 	.word	0x0001ede8
    6110:	00020b5d 	.word	0x00020b5d

00006114 <bt_hci_cmd_send_sync>:
{
    6114:	b5f0      	push	{r4, r5, r6, r7, lr}
    6116:	4615      	mov	r5, r2
    6118:	b087      	sub	sp, #28
	if (!buf) {
    611a:	460c      	mov	r4, r1
    611c:	b919      	cbnz	r1, 6126 <bt_hci_cmd_send_sync+0x12>
		buf = bt_hci_cmd_create(opcode, 0);
    611e:	f7ff fe8b 	bl	5e38 <bt_hci_cmd_create>
		if (!buf) {
    6122:	4604      	mov	r4, r0
    6124:	b3a8      	cbz	r0, 6192 <bt_hci_cmd_send_sync+0x7e>
	z_impl_k_sem_init(sem, initial_count, limit);
    6126:	2201      	movs	r2, #1
    6128:	2100      	movs	r1, #0
    612a:	4668      	mov	r0, sp
    612c:	f018 fa90 	bl	1e650 <z_impl_k_sem_init>
	cmd(buf)->sync = &sync_sem;
    6130:	4620      	mov	r0, r4
    6132:	f010 f95f 	bl	163f4 <net_buf_id>
    6136:	4f18      	ldr	r7, [pc, #96]	; (6198 <bt_hci_cmd_send_sync+0x84>)
    6138:	260c      	movs	r6, #12
    613a:	fb06 7000 	mla	r0, r6, r0, r7
    613e:	f8c0 d008 	str.w	sp, [r0, #8]
	net_buf_ref(buf);
    6142:	4620      	mov	r0, r4
    6144:	f017 fd7e 	bl	1dc44 <net_buf_ref>
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
    6148:	4621      	mov	r1, r4
    614a:	4814      	ldr	r0, [pc, #80]	; (619c <bt_hci_cmd_send_sync+0x88>)
    614c:	f017 fd6d 	bl	1dc2a <net_buf_put>
	return z_impl_k_sem_take(sem, timeout);
    6150:	f242 7110 	movw	r1, #10000	; 0x2710
    6154:	4668      	mov	r0, sp
    6156:	f012 f9c1 	bl	184dc <z_impl_k_sem_take>
	if (cmd(buf)->status) {
    615a:	4620      	mov	r0, r4
    615c:	f010 f94a 	bl	163f4 <net_buf_id>
    6160:	4370      	muls	r0, r6
    6162:	5c3b      	ldrb	r3, [r7, r0]
    6164:	b173      	cbz	r3, 6184 <bt_hci_cmd_send_sync+0x70>
		switch (cmd(buf)->status) {
    6166:	4620      	mov	r0, r4
    6168:	f010 f944 	bl	163f4 <net_buf_id>
    616c:	4370      	muls	r0, r6
    616e:	5c3b      	ldrb	r3, [r7, r0]
    6170:	2b09      	cmp	r3, #9
			err = -EIO;
    6172:	bf0c      	ite	eq
    6174:	f06f 053c 	mvneq.w	r5, #60	; 0x3c
    6178:	f06f 0504 	mvnne.w	r5, #4
			net_buf_unref(buf);
    617c:	4620      	mov	r0, r4
    617e:	f010 f9cf 	bl	16520 <net_buf_unref>
    6182:	e003      	b.n	618c <bt_hci_cmd_send_sync+0x78>
		if (rsp) {
    6184:	2d00      	cmp	r5, #0
    6186:	d0f9      	beq.n	617c <bt_hci_cmd_send_sync+0x68>
			*rsp = buf;
    6188:	602c      	str	r4, [r5, #0]
		err = 0;
    618a:	461d      	mov	r5, r3
}
    618c:	4628      	mov	r0, r5
    618e:	b007      	add	sp, #28
    6190:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return -ENOBUFS;
    6192:	f06f 0536 	mvn.w	r5, #54	; 0x36
    6196:	e7f9      	b.n	618c <bt_hci_cmd_send_sync+0x78>
    6198:	2000020c 	.word	0x2000020c
    619c:	200054fc 	.word	0x200054fc

000061a0 <set_advertise_enable>:
{
    61a0:	b530      	push	{r4, r5, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
    61a2:	2101      	movs	r1, #1
{
    61a4:	b085      	sub	sp, #20
    61a6:	4605      	mov	r5, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
    61a8:	f242 000a 	movw	r0, #8202	; 0x200a
    61ac:	f7ff fe44 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
    61b0:	4604      	mov	r4, r0
    61b2:	b1e8      	cbz	r0, 61f0 <set_advertise_enable+0x50>
	if (enable) {
    61b4:	3008      	adds	r0, #8
    61b6:	b1cd      	cbz	r5, 61ec <set_advertise_enable+0x4c>
		net_buf_add_u8(buf, BT_HCI_LE_ADV_ENABLE);
    61b8:	2101      	movs	r1, #1
		net_buf_add_u8(buf, BT_HCI_LE_ADV_DISABLE);
    61ba:	f017 fd56 	bl	1dc6a <net_buf_simple_add_u8>
	state->target = target;
    61be:	4b0e      	ldr	r3, [pc, #56]	; (61f8 <set_advertise_enable+0x58>)
    61c0:	9301      	str	r3, [sp, #4]
	cmd(buf)->state = &state;
    61c2:	4620      	mov	r0, r4
	state->bit = bit;
    61c4:	2305      	movs	r3, #5
    61c6:	9302      	str	r3, [sp, #8]
	state->val = val;
    61c8:	f88d 500c 	strb.w	r5, [sp, #12]
	cmd(buf)->state = &state;
    61cc:	f010 f912 	bl	163f4 <net_buf_id>
    61d0:	4a0a      	ldr	r2, [pc, #40]	; (61fc <set_advertise_enable+0x5c>)
    61d2:	230c      	movs	r3, #12
    61d4:	fb03 2000 	mla	r0, r3, r0, r2
    61d8:	ab01      	add	r3, sp, #4
    61da:	6043      	str	r3, [r0, #4]
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
    61dc:	2200      	movs	r2, #0
    61de:	4621      	mov	r1, r4
    61e0:	f242 000a 	movw	r0, #8202	; 0x200a
    61e4:	f7ff ff96 	bl	6114 <bt_hci_cmd_send_sync>
}
    61e8:	b005      	add	sp, #20
    61ea:	bd30      	pop	{r4, r5, pc}
		net_buf_add_u8(buf, BT_HCI_LE_ADV_DISABLE);
    61ec:	4629      	mov	r1, r5
    61ee:	e7e4      	b.n	61ba <set_advertise_enable+0x1a>
		return -ENOBUFS;
    61f0:	f06f 0036 	mvn.w	r0, #54	; 0x36
    61f4:	e7f8      	b.n	61e8 <set_advertise_enable+0x48>
    61f6:	bf00      	nop
    61f8:	200054a8 	.word	0x200054a8
    61fc:	2000020c 	.word	0x2000020c

00006200 <set_random_address>:
{
    6200:	b570      	push	{r4, r5, r6, lr}
	return memcmp(a, b, sizeof(*a));
    6202:	4d14      	ldr	r5, [pc, #80]	; (6254 <set_random_address+0x54>)
    6204:	2206      	movs	r2, #6
    6206:	f105 010a 	add.w	r1, r5, #10
    620a:	4606      	mov	r6, r0
    620c:	f014 fee5 	bl	1afda <memcmp>
	if (!bt_addr_cmp(addr, &bt_dev.random_addr.a)) {
    6210:	4604      	mov	r4, r0
    6212:	b1d0      	cbz	r0, 624a <set_random_address+0x4a>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, sizeof(*addr));
    6214:	2106      	movs	r1, #6
    6216:	f242 0005 	movw	r0, #8197	; 0x2005
    621a:	f7ff fe0d 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
    621e:	4604      	mov	r4, r0
    6220:	b1a8      	cbz	r0, 624e <set_random_address+0x4e>
	net_buf_add_mem(buf, addr, sizeof(*addr));
    6222:	2206      	movs	r2, #6
    6224:	4631      	mov	r1, r6
    6226:	3008      	adds	r0, #8
    6228:	f017 fd16 	bl	1dc58 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
    622c:	4621      	mov	r1, r4
    622e:	2200      	movs	r2, #0
    6230:	f242 0005 	movw	r0, #8197	; 0x2005
    6234:	f7ff ff6e 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
    6238:	4604      	mov	r4, r0
    623a:	b930      	cbnz	r0, 624a <set_random_address+0x4a>
	bt_addr_copy(&bt_dev.random_addr.a, addr);
    623c:	4631      	mov	r1, r6
    623e:	f105 000a 	add.w	r0, r5, #10
    6242:	f015 f828 	bl	1b296 <bt_addr_copy>
	bt_dev.random_addr.type = BT_ADDR_LE_RANDOM;
    6246:	2301      	movs	r3, #1
    6248:	726b      	strb	r3, [r5, #9]
}
    624a:	4620      	mov	r0, r4
    624c:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOBUFS;
    624e:	f06f 0436 	mvn.w	r4, #54	; 0x36
    6252:	e7fa      	b.n	624a <set_random_address+0x4a>
    6254:	20005438 	.word	0x20005438

00006258 <le_set_private_addr>:
{
    6258:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (atomic_test_bit(bt_dev.flags, BT_DEV_RPA_VALID)) {
    625a:	4d12      	ldr	r5, [pc, #72]	; (62a4 <le_set_private_addr+0x4c>)
{
    625c:	4603      	mov	r3, r0
	if (atomic_test_bit(bt_dev.flags, BT_DEV_RPA_VALID)) {
    625e:	210f      	movs	r1, #15
    6260:	f105 0070 	add.w	r0, r5, #112	; 0x70
    6264:	f015 f86d 	bl	1b342 <atomic_test_bit>
    6268:	b9d0      	cbnz	r0, 62a0 <le_set_private_addr+0x48>
	err = bt_rpa_create(bt_dev.irk[id], &rpa);
    626a:	eb05 1003 	add.w	r0, r5, r3, lsl #4
    626e:	4669      	mov	r1, sp
    6270:	30d8      	adds	r0, #216	; 0xd8
    6272:	f014 ff40 	bl	1b0f6 <bt_rpa_create>
	if (!err) {
    6276:	4604      	mov	r4, r0
    6278:	b950      	cbnz	r0, 6290 <le_set_private_addr+0x38>
		err = set_random_address(&rpa);
    627a:	4668      	mov	r0, sp
    627c:	f7ff ffc0 	bl	6200 <set_random_address>
		if (!err) {
    6280:	4604      	mov	r4, r0
    6282:	b928      	cbnz	r0, 6290 <le_set_private_addr+0x38>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    6284:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    6288:	f105 0070 	add.w	r0, r5, #112	; 0x70
    628c:	f015 f809 	bl	1b2a2 <atomic_or>
 * @req K-DWORK-001
 */
static inline int k_delayed_work_submit(struct k_delayed_work *work,
					s32_t delay)
{
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    6290:	4a05      	ldr	r2, [pc, #20]	; (62a8 <le_set_private_addr+0x50>)
    6292:	4906      	ldr	r1, [pc, #24]	; (62ac <le_set_private_addr+0x54>)
    6294:	4806      	ldr	r0, [pc, #24]	; (62b0 <le_set_private_addr+0x58>)
    6296:	f012 fa67 	bl	18768 <k_delayed_work_submit_to_queue>
}
    629a:	4620      	mov	r0, r4
    629c:	b003      	add	sp, #12
    629e:	bd30      	pop	{r4, r5, pc}
		return 0;
    62a0:	2400      	movs	r4, #0
    62a2:	e7fa      	b.n	629a <le_set_private_addr+0x42>
    62a4:	20005438 	.word	0x20005438
    62a8:	000dbba0 	.word	0x000dbba0
    62ac:	20005520 	.word	0x20005520
    62b0:	20001a60 	.word	0x20001a60

000062b4 <rpa_timeout>:
{
    62b4:	b510      	push	{r4, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    62b6:	4c17      	ldr	r4, [pc, #92]	; (6314 <rpa_timeout+0x60>)
    62b8:	f46f 4100 	mvn.w	r1, #32768	; 0x8000
    62bc:	f104 0070 	add.w	r0, r4, #112	; 0x70
    62c0:	f014 ffda 	bl	1b278 <atomic_and>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING)) {
    62c4:	2105      	movs	r1, #5
    62c6:	f104 0070 	add.w	r0, r4, #112	; 0x70
    62ca:	f015 f83a 	bl	1b342 <atomic_test_bit>
    62ce:	b1d8      	cbz	r0, 6308 <rpa_timeout+0x54>
		set_advertise_enable(false);
    62d0:	2000      	movs	r0, #0
    62d2:	f7ff ff65 	bl	61a0 <set_advertise_enable>
		err_adv = le_set_private_addr(bt_dev.adv_id);
    62d6:	7a20      	ldrb	r0, [r4, #8]
    62d8:	f7ff ffbe 	bl	6258 <le_set_private_addr>
    62dc:	4604      	mov	r4, r0
		set_advertise_enable(true);
    62de:	2001      	movs	r0, #1
    62e0:	f7ff ff5e 	bl	61a0 <set_advertise_enable>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_ACTIVE_SCAN)) {
    62e4:	210b      	movs	r1, #11
    62e6:	480c      	ldr	r0, [pc, #48]	; (6318 <rpa_timeout+0x64>)
    62e8:	f015 f82b 	bl	1b342 <atomic_test_bit>
    62ec:	b170      	cbz	r0, 630c <rpa_timeout+0x58>
		err_scan = le_set_private_addr(BT_ID_DEFAULT);
    62ee:	2000      	movs	r0, #0
    62f0:	f7ff ffb2 	bl	6258 <le_set_private_addr>
	if (err_adv || err_scan) {
    62f4:	ea54 0300 	orrs.w	r3, r4, r0
    62f8:	d00a      	beq.n	6310 <rpa_timeout+0x5c>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    62fa:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    62fe:	4806      	ldr	r0, [pc, #24]	; (6318 <rpa_timeout+0x64>)
}
    6300:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    6304:	f014 bfcd 	b.w	1b2a2 <atomic_or>
	int err_adv = 0, err_scan = 0;
    6308:	4604      	mov	r4, r0
    630a:	e7eb      	b.n	62e4 <rpa_timeout+0x30>
	if (err_adv || err_scan) {
    630c:	2c00      	cmp	r4, #0
    630e:	d1f4      	bne.n	62fa <rpa_timeout+0x46>
}
    6310:	bd10      	pop	{r4, pc}
    6312:	bf00      	nop
    6314:	20005438 	.word	0x20005438
    6318:	200054a8 	.word	0x200054a8

0000631c <hci_id_add>:
{
    631c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    631e:	4607      	mov	r7, r0
    6320:	460e      	mov	r6, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_ADD_DEV_TO_RL, sizeof(*cp));
    6322:	f242 0027 	movw	r0, #8231	; 0x2027
    6326:	2127      	movs	r1, #39	; 0x27
    6328:	f7ff fd86 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
    632c:	4604      	mov	r4, r0
    632e:	b1d0      	cbz	r0, 6366 <hci_id_add+0x4a>
	cp = net_buf_add(buf, sizeof(*cp));
    6330:	2127      	movs	r1, #39	; 0x27
    6332:	3008      	adds	r0, #8
    6334:	f017 fc8a 	bl	1dc4c <net_buf_simple_add>
	bt_addr_le_copy(&cp->peer_id_addr, addr);
    6338:	4639      	mov	r1, r7
	cp = net_buf_add(buf, sizeof(*cp));
    633a:	4605      	mov	r5, r0
	bt_addr_le_copy(&cp->peer_id_addr, addr);
    633c:	f014 ffae 	bl	1b29c <bt_addr_le_copy>
	memcpy(cp->peer_irk, val, 16);
    6340:	4631      	mov	r1, r6
    6342:	2210      	movs	r2, #16
    6344:	1de8      	adds	r0, r5, #7
    6346:	f014 fe58 	bl	1affa <memcpy>
	memcpy(cp->local_irk, bt_dev.irk, 16);
    634a:	2210      	movs	r2, #16
    634c:	4907      	ldr	r1, [pc, #28]	; (636c <hci_id_add+0x50>)
    634e:	f105 0017 	add.w	r0, r5, #23
    6352:	f014 fe52 	bl	1affa <memcpy>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_ADD_DEV_TO_RL, buf, NULL);
    6356:	4621      	mov	r1, r4
    6358:	2200      	movs	r2, #0
    635a:	f242 0027 	movw	r0, #8231	; 0x2027
}
    635e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_ADD_DEV_TO_RL, buf, NULL);
    6362:	f7ff bed7 	b.w	6114 <bt_hci_cmd_send_sync>
}
    6366:	f06f 0036 	mvn.w	r0, #54	; 0x36
    636a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    636c:	20005510 	.word	0x20005510

00006370 <set_ad>:
{
    6370:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6374:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
    6376:	2120      	movs	r1, #32
{
    6378:	4682      	mov	sl, r0
    637a:	4691      	mov	r9, r2
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
    637c:	f7ff fd5c 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
    6380:	4607      	mov	r7, r0
    6382:	2800      	cmp	r0, #0
    6384:	d05a      	beq.n	643c <set_ad+0xcc>
	set_data = net_buf_add(buf, sizeof(*set_data));
    6386:	2120      	movs	r1, #32
    6388:	3008      	adds	r0, #8
    638a:	f017 fc5f 	bl	1dc4c <net_buf_simple_add>
	(void)memset(set_data, 0, sizeof(*set_data));
    638e:	2220      	movs	r2, #32
    6390:	2100      	movs	r1, #0
	set_data = net_buf_add(buf, sizeof(*set_data));
    6392:	4605      	mov	r5, r0
	(void)memset(set_data, 0, sizeof(*set_data));
    6394:	f014 fe5b 	bl	1b04e <memset>
	for (c = 0; c < ad_len; c++) {
    6398:	eb04 09c9 	add.w	r9, r4, r9, lsl #3
    639c:	454c      	cmp	r4, r9
    639e:	d106      	bne.n	63ae <set_ad+0x3e>
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
    63a0:	4639      	mov	r1, r7
    63a2:	4650      	mov	r0, sl
    63a4:	2200      	movs	r2, #0
}
    63a6:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
    63aa:	f7ff beb3 	b.w	6114 <bt_hci_cmd_send_sync>
		for (i = 0; i < ad[c].len; i++) {
    63ae:	6826      	ldr	r6, [r4, #0]
    63b0:	f04f 0b00 	mov.w	fp, #0
    63b4:	6863      	ldr	r3, [r4, #4]
    63b6:	459b      	cmp	fp, r3
    63b8:	d301      	bcc.n	63be <set_ad+0x4e>
    63ba:	3408      	adds	r4, #8
    63bc:	e7ee      	b.n	639c <set_ad+0x2c>
			if (set_data->len + len + 2 > 31) {
    63be:	782b      	ldrb	r3, [r5, #0]
			int len = data[i].data_len;
    63c0:	7872      	ldrb	r2, [r6, #1]
			u8_t type = data[i].type;
    63c2:	7831      	ldrb	r1, [r6, #0]
			if (set_data->len + len + 2 > 31) {
    63c4:	1c98      	adds	r0, r3, #2
    63c6:	eb00 0c02 	add.w	ip, r0, r2
    63ca:	f1bc 0f1f 	cmp.w	ip, #31
    63ce:	dd1a      	ble.n	6406 <set_ad+0x96>
				if (type != BT_DATA_NAME_COMPLETE || !len) {
    63d0:	2909      	cmp	r1, #9
				len = 31 - (set_data->len + 2);
    63d2:	f1c3 021d 	rsb	r2, r3, #29
				if (type != BT_DATA_NAME_COMPLETE || !len) {
    63d6:	d100      	bne.n	63da <set_ad+0x6a>
    63d8:	b9a2      	cbnz	r2, 6404 <set_ad+0x94>
					net_buf_unref(buf);
    63da:	4638      	mov	r0, r7
    63dc:	f010 f8a0 	bl	16520 <net_buf_unref>
					BT_ERR("Too big advertising data");
    63e0:	2301      	movs	r3, #1
    63e2:	f04f 0100 	mov.w	r1, #0
    63e6:	f363 0107 	bfi	r1, r3, #0, #8
    63ea:	4a16      	ldr	r2, [pc, #88]	; (6444 <set_ad+0xd4>)
    63ec:	4b16      	ldr	r3, [pc, #88]	; (6448 <set_ad+0xd8>)
    63ee:	4817      	ldr	r0, [pc, #92]	; (644c <set_ad+0xdc>)
    63f0:	1a9b      	subs	r3, r3, r2
    63f2:	08db      	lsrs	r3, r3, #3
    63f4:	f363 118f 	bfi	r1, r3, #6, #10
    63f8:	f014 f90b 	bl	1a612 <log_0>
					return -EINVAL;
    63fc:	f06f 0015 	mvn.w	r0, #21
}
    6400:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				type = BT_DATA_NAME_SHORTENED;
    6404:	2108      	movs	r1, #8
			set_data->data[set_data->len++] = len + 1;
    6406:	eb05 0c03 	add.w	ip, r5, r3
    640a:	3301      	adds	r3, #1
    640c:	fa4f f882 	sxtb.w	r8, r2
			set_data->data[set_data->len++] = type;
    6410:	fa55 f383 	uxtab	r3, r5, r3
			set_data->data[set_data->len++] = len + 1;
    6414:	f108 0e01 	add.w	lr, r8, #1
			set_data->data[set_data->len++] = type;
    6418:	b2c0      	uxtb	r0, r0
			set_data->data[set_data->len++] = len + 1;
    641a:	f88c e001 	strb.w	lr, [ip, #1]
			set_data->data[set_data->len++] = type;
    641e:	7028      	strb	r0, [r5, #0]
    6420:	7059      	strb	r1, [r3, #1]
			memcpy(&set_data->data[set_data->len], data[i].data,
    6422:	3001      	adds	r0, #1
    6424:	6871      	ldr	r1, [r6, #4]
    6426:	4428      	add	r0, r5
    6428:	f014 fde7 	bl	1affa <memcpy>
			set_data->len += len;
    642c:	782b      	ldrb	r3, [r5, #0]
    642e:	4498      	add	r8, r3
    6430:	f885 8000 	strb.w	r8, [r5]
		for (i = 0; i < ad[c].len; i++) {
    6434:	f10b 0b01 	add.w	fp, fp, #1
    6438:	3608      	adds	r6, #8
    643a:	e7bb      	b.n	63b4 <set_ad+0x44>
		return -ENOBUFS;
    643c:	f06f 0036 	mvn.w	r0, #54	; 0x36
    6440:	e7de      	b.n	6400 <set_ad+0x90>
    6442:	bf00      	nop
    6444:	0001ed28 	.word	0x0001ed28
    6448:	0001ede8 	.word	0x0001ede8
    644c:	00020b98 	.word	0x00020b98

00006450 <le_adv_update>:
}

static int le_adv_update(const struct bt_data *ad, size_t ad_len,
			 const struct bt_data *sd, size_t sd_len,
			 bool connectable, bool use_name)
{
    6450:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6454:	b086      	sub	sp, #24
	struct bt_ad d[2] = {};
	struct bt_data data;
	int err;

	d[0].data = ad;
	d[0].len = ad_len;
    6456:	e9cd 0102 	strd	r0, r1, [sp, #8]
{
    645a:	4615      	mov	r5, r2
    645c:	461e      	mov	r6, r3

	err = set_ad(BT_HCI_OP_LE_SET_ADV_DATA, d, 1);
    645e:	2201      	movs	r2, #1
	struct bt_ad d[2] = {};
    6460:	2300      	movs	r3, #0
	err = set_ad(BT_HCI_OP_LE_SET_ADV_DATA, d, 1);
    6462:	a902      	add	r1, sp, #8
    6464:	f242 0008 	movw	r0, #8200	; 0x2008
{
    6468:	f89d 7030 	ldrb.w	r7, [sp, #48]	; 0x30
    646c:	f89d 8034 	ldrb.w	r8, [sp, #52]	; 0x34
	struct bt_ad d[2] = {};
    6470:	e9cd 3304 	strd	r3, r3, [sp, #16]
	err = set_ad(BT_HCI_OP_LE_SET_ADV_DATA, d, 1);
    6474:	f7ff ff7c 	bl	6370 <set_ad>
	if (err) {
    6478:	4604      	mov	r4, r0
    647a:	bb10      	cbnz	r0, 64c2 <le_adv_update+0x72>
		return err;
	}

	d[0].data = sd;
	d[0].len = sd_len;
    647c:	e9cd 5602 	strd	r5, r6, [sp, #8]

	if (use_name) {
    6480:	f1b8 0f00 	cmp.w	r8, #0
    6484:	d011      	beq.n	64aa <le_adv_update+0x5a>
		const char *name;

		if (sd) {
    6486:	b115      	cbz	r5, 648e <le_adv_update+0x3e>
	for (i = 0; i < ad_len; i++) {
    6488:	4602      	mov	r2, r0
    648a:	42b2      	cmp	r2, r6
    648c:	d11d      	bne.n	64ca <le_adv_update+0x7a>
				return -EINVAL;
			}
		}

		name = bt_get_name();
		data = (struct bt_data)BT_DATA(
    648e:	4d14      	ldr	r5, [pc, #80]	; (64e0 <le_adv_update+0x90>)
    6490:	4628      	mov	r0, r5
    6492:	f014 fd80 	bl	1af96 <strlen>
    6496:	2309      	movs	r3, #9
    6498:	f88d 3000 	strb.w	r3, [sp]
			BT_DATA_NAME_COMPLETE,
			name, strlen(name));

		d[1].data = &data;
		d[1].len = 1;
    649c:	2301      	movs	r3, #1
		data = (struct bt_data)BT_DATA(
    649e:	f88d 0001 	strb.w	r0, [sp, #1]
    64a2:	9501      	str	r5, [sp, #4]
		d[1].data = &data;
    64a4:	f8cd d010 	str.w	sp, [sp, #16]
		d[1].len = 1;
    64a8:	9305      	str	r3, [sp, #20]
	 * by previous calls.
	 * Clearing sd is done by calling set_ad() with NULL data and
	 * zero len.
	 * So following condition check is unusual but correct.
	 */
	if (d[0].data || d[1].data || connectable) {
    64aa:	9b02      	ldr	r3, [sp, #8]
    64ac:	b913      	cbnz	r3, 64b4 <le_adv_update+0x64>
    64ae:	9b04      	ldr	r3, [sp, #16]
    64b0:	b903      	cbnz	r3, 64b4 <le_adv_update+0x64>
    64b2:	b137      	cbz	r7, 64c2 <le_adv_update+0x72>
		err = set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, d, 2);
    64b4:	2202      	movs	r2, #2
    64b6:	a902      	add	r1, sp, #8
    64b8:	f242 0009 	movw	r0, #8201	; 0x2009
    64bc:	f7ff ff58 	bl	6370 <set_ad>
    64c0:	4604      	mov	r4, r0
			return err;
		}
	}

	return 0;
}
    64c2:	4620      	mov	r0, r4
    64c4:	b006      	add	sp, #24
    64c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
    64ca:	f815 1032 	ldrb.w	r1, [r5, r2, lsl #3]
    64ce:	3908      	subs	r1, #8
    64d0:	2901      	cmp	r1, #1
    64d2:	d901      	bls.n	64d8 <le_adv_update+0x88>
	for (i = 0; i < ad_len; i++) {
    64d4:	3201      	adds	r2, #1
    64d6:	e7d8      	b.n	648a <le_adv_update+0x3a>
				return -EINVAL;
    64d8:	f06f 0415 	mvn.w	r4, #21
    64dc:	e7f1      	b.n	64c2 <le_adv_update+0x72>
    64de:	bf00      	nop
    64e0:	20005540 	.word	0x20005540

000064e4 <conn_auto_initiate>:
	if (conn->state != BT_CONN_CONNECTED) {
    64e4:	7b43      	ldrb	r3, [r0, #13]
    64e6:	2b06      	cmp	r3, #6
{
    64e8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    64ec:	4604      	mov	r4, r0
	if (conn->state != BT_CONN_CONNECTED) {
    64ee:	d11e      	bne.n	652e <conn_auto_initiate+0x4a>
	if (!atomic_test_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH) &&
    64f0:	1d05      	adds	r5, r0, #4
    64f2:	210d      	movs	r1, #13
    64f4:	4628      	mov	r0, r5
    64f6:	f014 ff24 	bl	1b342 <atomic_test_bit>
    64fa:	b9d8      	cbnz	r0, 6534 <conn_auto_initiate+0x50>
    64fc:	78e3      	ldrb	r3, [r4, #3]
    64fe:	b123      	cbz	r3, 650a <conn_auto_initiate+0x26>
	     BT_FEAT_LE_SLAVE_FEATURE_XCHG(bt_dev.le.features))) {
    6500:	4b52      	ldr	r3, [pc, #328]	; (664c <conn_auto_initiate+0x168>)
	    ((conn->role == BT_HCI_ROLE_MASTER) ||
    6502:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
    6506:	0719      	lsls	r1, r3, #28
    6508:	d514      	bpl.n	6534 <conn_auto_initiate+0x50>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_READ_REMOTE_FEATURES,
    650a:	2102      	movs	r1, #2
    650c:	f242 0016 	movw	r0, #8214	; 0x2016
    6510:	f7ff fc92 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
    6514:	4606      	mov	r6, r0
    6516:	b168      	cbz	r0, 6534 <conn_auto_initiate+0x50>
	cp = net_buf_add(buf, sizeof(*cp));
    6518:	2102      	movs	r1, #2
    651a:	3008      	adds	r0, #8
    651c:	f017 fb96 	bl	1dc4c <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
    6520:	8823      	ldrh	r3, [r4, #0]
    6522:	8003      	strh	r3, [r0, #0]
	bt_hci_cmd_send(BT_HCI_OP_LE_READ_REMOTE_FEATURES, buf);
    6524:	4631      	mov	r1, r6
    6526:	f242 0016 	movw	r0, #8214	; 0x2016
    652a:	f7ff fcbb 	bl	5ea4 <bt_hci_cmd_send>
}
    652e:	b002      	add	sp, #8
    6530:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	    !atomic_test_bit(conn->flags, BT_CONN_AUTO_PHY_COMPLETE) &&
    6534:	210c      	movs	r1, #12
    6536:	4628      	mov	r0, r5
    6538:	f014 ff03 	bl	1b342 <atomic_test_bit>
    653c:	f8df 810c 	ldr.w	r8, [pc, #268]	; 664c <conn_auto_initiate+0x168>
	if (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) &&
    6540:	4606      	mov	r6, r0
    6542:	bb00      	cbnz	r0, 6586 <conn_auto_initiate+0xa2>
	    !atomic_test_bit(conn->flags, BT_CONN_AUTO_PHY_COMPLETE) &&
    6544:	f898 3079 	ldrb.w	r3, [r8, #121]	; 0x79
    6548:	07da      	lsls	r2, r3, #31
    654a:	d51c      	bpl.n	6586 <conn_auto_initiate+0xa2>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PHY, sizeof(*cp));
    654c:	2107      	movs	r1, #7
    654e:	f242 0032 	movw	r0, #8242	; 0x2032
    6552:	f7ff fc71 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
    6556:	4607      	mov	r7, r0
    6558:	b1a8      	cbz	r0, 6586 <conn_auto_initiate+0xa2>
	cp = net_buf_add(buf, sizeof(*cp));
    655a:	2107      	movs	r1, #7
    655c:	3008      	adds	r0, #8
    655e:	f017 fb75 	bl	1dc4c <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
    6562:	8823      	ldrh	r3, [r4, #0]
    6564:	8003      	strh	r3, [r0, #0]
	cp->tx_phys = BT_HCI_LE_PHY_PREFER_2M;
    6566:	2302      	movs	r3, #2
	cp->all_phys = 0U;
    6568:	7086      	strb	r6, [r0, #2]
	cp->tx_phys = BT_HCI_LE_PHY_PREFER_2M;
    656a:	70c3      	strb	r3, [r0, #3]
	cp->rx_phys = BT_HCI_LE_PHY_PREFER_2M;
    656c:	7103      	strb	r3, [r0, #4]
	cp->phy_opts = BT_HCI_LE_PHY_CODED_ANY;
    656e:	7146      	strb	r6, [r0, #5]
    6570:	7186      	strb	r6, [r0, #6]
	bt_hci_cmd_send(BT_HCI_OP_LE_SET_PHY, buf);
    6572:	4639      	mov	r1, r7
    6574:	f242 0032 	movw	r0, #8242	; 0x2032
    6578:	f7ff fc94 	bl	5ea4 <bt_hci_cmd_send>
    657c:	2180      	movs	r1, #128	; 0x80
    657e:	4628      	mov	r0, r5
    6580:	f014 fe8f 	bl	1b2a2 <atomic_or>
			return;
    6584:	e7d3      	b.n	652e <conn_auto_initiate+0x4a>
	if (IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
    6586:	f898 3078 	ldrb.w	r3, [r8, #120]	; 0x78
    658a:	069b      	lsls	r3, r3, #26
    658c:	d514      	bpl.n	65b8 <conn_auto_initiate+0xd4>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_MAX_DATA_LEN, NULL, &rsp);
    658e:	aa01      	add	r2, sp, #4
    6590:	2100      	movs	r1, #0
    6592:	f242 002f 	movw	r0, #8239	; 0x202f
    6596:	f7ff fdbd 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
    659a:	b1f0      	cbz	r0, 65da <conn_auto_initiate+0xf6>
		BT_ERR("Failed to read DLE max data len");
    659c:	2301      	movs	r3, #1
    659e:	f04f 0100 	mov.w	r1, #0
    65a2:	f363 0107 	bfi	r1, r3, #0, #8
    65a6:	4a2a      	ldr	r2, [pc, #168]	; (6650 <conn_auto_initiate+0x16c>)
    65a8:	4b2a      	ldr	r3, [pc, #168]	; (6654 <conn_auto_initiate+0x170>)
    65aa:	482b      	ldr	r0, [pc, #172]	; (6658 <conn_auto_initiate+0x174>)
    65ac:	1a9b      	subs	r3, r3, r2
    65ae:	08db      	lsrs	r3, r3, #3
    65b0:	f363 118f 	bfi	r1, r3, #6, #10
		BT_ERR("Failed to send LE Set Data Length Command");
    65b4:	f014 f82d 	bl	1a612 <log_0>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    65b8:	78e3      	ldrb	r3, [r4, #3]
    65ba:	2b01      	cmp	r3, #1
    65bc:	d1b7      	bne.n	652e <conn_auto_initiate+0x4a>
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_UPDATE)) {
    65be:	2108      	movs	r1, #8
    65c0:	4628      	mov	r0, r5
    65c2:	f014 febe 	bl	1b342 <atomic_test_bit>
    65c6:	2800      	cmp	r0, #0
    65c8:	d1b1      	bne.n	652e <conn_auto_initiate+0x4a>
    65ca:	f241 3288 	movw	r2, #5000	; 0x1388
    65ce:	f104 0150 	add.w	r1, r4, #80	; 0x50
    65d2:	4822      	ldr	r0, [pc, #136]	; (665c <conn_auto_initiate+0x178>)
    65d4:	f012 f8c8 	bl	18768 <k_delayed_work_submit_to_queue>
    65d8:	e7a9      	b.n	652e <conn_auto_initiate+0x4a>
	rp = (void *)rsp->data;
    65da:	9801      	ldr	r0, [sp, #4]
    65dc:	6883      	ldr	r3, [r0, #8]
	tx_octets = sys_le16_to_cpu(rp->max_tx_octets);
    65de:	f8b3 8001 	ldrh.w	r8, [r3, #1]
	tx_time = sys_le16_to_cpu(rp->max_tx_time);
    65e2:	f8b3 7003 	ldrh.w	r7, [r3, #3]
	net_buf_unref(rsp);
    65e6:	f00f ff9b 	bl	16520 <net_buf_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_DATA_LEN, sizeof(*cp));
    65ea:	2106      	movs	r1, #6
    65ec:	f242 0022 	movw	r0, #8226	; 0x2022
    65f0:	f7ff fc22 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
    65f4:	4606      	mov	r6, r0
    65f6:	b960      	cbnz	r0, 6612 <conn_auto_initiate+0x12e>
		BT_ERR("Failed to create LE Set Data Length Command");
    65f8:	2301      	movs	r3, #1
    65fa:	f04f 0100 	mov.w	r1, #0
    65fe:	f363 0107 	bfi	r1, r3, #0, #8
    6602:	4a13      	ldr	r2, [pc, #76]	; (6650 <conn_auto_initiate+0x16c>)
    6604:	4b13      	ldr	r3, [pc, #76]	; (6654 <conn_auto_initiate+0x170>)
    6606:	4816      	ldr	r0, [pc, #88]	; (6660 <conn_auto_initiate+0x17c>)
    6608:	1a9b      	subs	r3, r3, r2
    660a:	08db      	lsrs	r3, r3, #3
    660c:	f363 118f 	bfi	r1, r3, #6, #10
    6610:	e7d0      	b.n	65b4 <conn_auto_initiate+0xd0>
	cp = net_buf_add(buf, sizeof(*cp));
    6612:	2106      	movs	r1, #6
    6614:	3008      	adds	r0, #8
    6616:	f017 fb19 	bl	1dc4c <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
    661a:	8823      	ldrh	r3, [r4, #0]
    661c:	8003      	strh	r3, [r0, #0]
	cp->tx_octets = sys_cpu_to_le16(tx_octets);
    661e:	f8a0 8002 	strh.w	r8, [r0, #2]
	cp->tx_time = sys_cpu_to_le16(tx_time);
    6622:	8087      	strh	r7, [r0, #4]
	err = bt_hci_cmd_send(BT_HCI_OP_LE_SET_DATA_LEN, buf);
    6624:	4631      	mov	r1, r6
    6626:	f242 0022 	movw	r0, #8226	; 0x2022
    662a:	f7ff fc3b 	bl	5ea4 <bt_hci_cmd_send>
	if (err) {
    662e:	2800      	cmp	r0, #0
    6630:	d0c2      	beq.n	65b8 <conn_auto_initiate+0xd4>
		BT_ERR("Failed to send LE Set Data Length Command");
    6632:	2301      	movs	r3, #1
    6634:	f04f 0100 	mov.w	r1, #0
    6638:	f363 0107 	bfi	r1, r3, #0, #8
    663c:	4a04      	ldr	r2, [pc, #16]	; (6650 <conn_auto_initiate+0x16c>)
    663e:	4b05      	ldr	r3, [pc, #20]	; (6654 <conn_auto_initiate+0x170>)
    6640:	4808      	ldr	r0, [pc, #32]	; (6664 <conn_auto_initiate+0x180>)
    6642:	1a9b      	subs	r3, r3, r2
    6644:	08db      	lsrs	r3, r3, #3
    6646:	f363 118f 	bfi	r1, r3, #6, #10
    664a:	e7b3      	b.n	65b4 <conn_auto_initiate+0xd0>
    664c:	20005438 	.word	0x20005438
    6650:	0001ed28 	.word	0x0001ed28
    6654:	0001ede8 	.word	0x0001ede8
    6658:	0002088d 	.word	0x0002088d
    665c:	20001a60 	.word	0x20001a60
    6660:	000208ad 	.word	0x000208ad
    6664:	000208d9 	.word	0x000208d9

00006668 <le_phy_update_complete>:
{
    6668:	b538      	push	{r3, r4, r5, lr}
	u16_t handle = sys_le16_to_cpu(evt->handle);
    666a:	6883      	ldr	r3, [r0, #8]
    666c:	f8b3 5001 	ldrh.w	r5, [r3, #1]
	conn = bt_conn_lookup_handle(handle);
    6670:	4628      	mov	r0, r5
    6672:	f001 fe69 	bl	8348 <bt_conn_lookup_handle>
	if (!conn) {
    6676:	4604      	mov	r4, r0
    6678:	b980      	cbnz	r0, 669c <le_phy_update_complete+0x34>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    667a:	2301      	movs	r3, #1
    667c:	f04f 0200 	mov.w	r2, #0
    6680:	f363 0207 	bfi	r2, r3, #0, #8
    6684:	4910      	ldr	r1, [pc, #64]	; (66c8 <le_phy_update_complete+0x60>)
    6686:	4b11      	ldr	r3, [pc, #68]	; (66cc <le_phy_update_complete+0x64>)
    6688:	4811      	ldr	r0, [pc, #68]	; (66d0 <le_phy_update_complete+0x68>)
    668a:	1a5b      	subs	r3, r3, r1
    668c:	08db      	lsrs	r3, r3, #3
    668e:	f363 128f 	bfi	r2, r3, #6, #10
    6692:	4629      	mov	r1, r5
}
    6694:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		BT_ERR("Unable to lookup conn for handle %u", handle);
    6698:	f013 bfc8 	b.w	1a62c <log_1>
	    !atomic_test_and_clear_bit(conn->flags, BT_CONN_AUTO_PHY_UPDATE)) {
    669c:	1d05      	adds	r5, r0, #4
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    669e:	f06f 0180 	mvn.w	r1, #128	; 0x80
    66a2:	4628      	mov	r0, r5
    66a4:	f014 fde8 	bl	1b278 <atomic_and>
	if (!IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) ||
    66a8:	0603      	lsls	r3, r0, #24
    66aa:	d507      	bpl.n	66bc <le_phy_update_complete+0x54>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    66ac:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    66b0:	4628      	mov	r0, r5
    66b2:	f014 fdf6 	bl	1b2a2 <atomic_or>
	conn_auto_initiate(conn);
    66b6:	4620      	mov	r0, r4
    66b8:	f7ff ff14 	bl	64e4 <conn_auto_initiate>
	bt_conn_unref(conn);
    66bc:	4620      	mov	r0, r4
}
    66be:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_conn_unref(conn);
    66c2:	f014 bf7c 	b.w	1b5be <bt_conn_unref>
    66c6:	bf00      	nop
    66c8:	0001ed28 	.word	0x0001ed28
    66cc:	0001ede8 	.word	0x0001ede8
    66d0:	00020b5d 	.word	0x00020b5d

000066d4 <le_remote_feat_complete>:
{
    66d4:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_le_remote_feat_complete *evt = (void *)buf->data;
    66d6:	6885      	ldr	r5, [r0, #8]
	u16_t handle = sys_le16_to_cpu(evt->handle);
    66d8:	f8b5 6001 	ldrh.w	r6, [r5, #1]
	conn = bt_conn_lookup_handle(handle);
    66dc:	4630      	mov	r0, r6
    66de:	f001 fe33 	bl	8348 <bt_conn_lookup_handle>
	if (!conn) {
    66e2:	4604      	mov	r4, r0
    66e4:	b980      	cbnz	r0, 6708 <le_remote_feat_complete+0x34>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    66e6:	2301      	movs	r3, #1
    66e8:	f04f 0200 	mov.w	r2, #0
    66ec:	f363 0207 	bfi	r2, r3, #0, #8
    66f0:	490f      	ldr	r1, [pc, #60]	; (6730 <le_remote_feat_complete+0x5c>)
    66f2:	4b10      	ldr	r3, [pc, #64]	; (6734 <le_remote_feat_complete+0x60>)
    66f4:	4810      	ldr	r0, [pc, #64]	; (6738 <le_remote_feat_complete+0x64>)
    66f6:	1a5b      	subs	r3, r3, r1
    66f8:	08db      	lsrs	r3, r3, #3
    66fa:	4631      	mov	r1, r6
    66fc:	f363 128f 	bfi	r2, r3, #6, #10
}
    6700:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_ERR("Unable to lookup conn for handle %u", handle);
    6704:	f013 bf92 	b.w	1a62c <log_1>
	if (!evt->status) {
    6708:	782b      	ldrb	r3, [r5, #0]
    670a:	b923      	cbnz	r3, 6716 <le_remote_feat_complete+0x42>
		memcpy(conn->le.features, evt->features,
    670c:	2208      	movs	r2, #8
    670e:	1ce9      	adds	r1, r5, #3
    6710:	3094      	adds	r0, #148	; 0x94
    6712:	f014 fc72 	bl	1affa <memcpy>
    6716:	f44f 5100 	mov.w	r1, #8192	; 0x2000
    671a:	1d20      	adds	r0, r4, #4
    671c:	f014 fdc1 	bl	1b2a2 <atomic_or>
	conn_auto_initiate(conn);
    6720:	4620      	mov	r0, r4
    6722:	f7ff fedf 	bl	64e4 <conn_auto_initiate>
	bt_conn_unref(conn);
    6726:	4620      	mov	r0, r4
}
    6728:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_conn_unref(conn);
    672c:	f014 bf47 	b.w	1b5be <bt_conn_unref>
    6730:	0001ed28 	.word	0x0001ed28
    6734:	0001ede8 	.word	0x0001ede8
    6738:	00020b5d 	.word	0x00020b5d

0000673c <bt_unpair>:
{
    673c:	b530      	push	{r4, r5, lr}
    673e:	b085      	sub	sp, #20
    6740:	460d      	mov	r5, r1
    6742:	f88d 0007 	strb.w	r0, [sp, #7]
	if (id >= CONFIG_BT_ID_MAX) {
    6746:	b9d0      	cbnz	r0, 677e <bt_unpair+0x42>
	if (!addr || !bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    6748:	b949      	cbnz	r1, 675e <bt_unpair+0x22>
		bt_foreach_bond(id, unpair_remote, &id);
    674a:	f10d 0207 	add.w	r2, sp, #7
    674e:	490d      	ldr	r1, [pc, #52]	; (6784 <bt_unpair+0x48>)
    6750:	f89d 0007 	ldrb.w	r0, [sp, #7]
    6754:	f006 ffa2 	bl	d69c <bt_foreach_bond>
		return 0;
    6758:	2000      	movs	r0, #0
}
    675a:	b005      	add	sp, #20
    675c:	bd30      	pop	{r4, r5, pc}
	if (!addr || !bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    675e:	9002      	str	r0, [sp, #8]
	return memcmp(a, b, sizeof(*a));
    6760:	2207      	movs	r2, #7
    6762:	f8cd 000b 	str.w	r0, [sp, #11]
    6766:	a902      	add	r1, sp, #8
    6768:	4628      	mov	r0, r5
    676a:	f014 fc36 	bl	1afda <memcmp>
    676e:	2800      	cmp	r0, #0
    6770:	d0eb      	beq.n	674a <bt_unpair+0xe>
	unpair(id, addr);
    6772:	4629      	mov	r1, r5
    6774:	f89d 0007 	ldrb.w	r0, [sp, #7]
    6778:	f014 fdb3 	bl	1b2e2 <unpair>
	return 0;
    677c:	e7ec      	b.n	6758 <bt_unpair+0x1c>
		return -EINVAL;
    677e:	f06f 0015 	mvn.w	r0, #21
    6782:	e7ea      	b.n	675a <bt_unpair+0x1e>
    6784:	0001b339 	.word	0x0001b339

00006788 <bt_id_add>:
{
    6788:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (!bt_dev.le.rl_size || bt_dev.le.rl_entries > bt_dev.le.rl_size) {
    678a:	4e65      	ldr	r6, [pc, #404]	; (6920 <bt_id_add+0x198>)
    678c:	f896 20a4 	ldrb.w	r2, [r6, #164]	; 0xa4
    6790:	f896 30a5 	ldrb.w	r3, [r6, #165]	; 0xa5
{
    6794:	4605      	mov	r5, r0
    6796:	4634      	mov	r4, r6
	if (!bt_dev.le.rl_size || bt_dev.le.rl_entries > bt_dev.le.rl_size) {
    6798:	b10a      	cbz	r2, 679e <bt_id_add+0x16>
    679a:	429a      	cmp	r2, r3
    679c:	d204      	bcs.n	67a8 <bt_id_add+0x20>
		bt_dev.le.rl_entries++;
    679e:	3301      	adds	r3, #1
    67a0:	f884 30a5 	strb.w	r3, [r4, #165]	; 0xa5
}
    67a4:	b003      	add	sp, #12
    67a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	conn = bt_conn_lookup_state_le(NULL, BT_CONN_CONNECT);
    67a8:	2105      	movs	r1, #5
    67aa:	2000      	movs	r0, #0
    67ac:	f001 fe04 	bl	83b8 <bt_conn_lookup_state_le>
	if (conn) {
    67b0:	4607      	mov	r7, r0
    67b2:	b168      	cbz	r0, 67d0 <bt_id_add+0x48>
    67b4:	f44f 3180 	mov.w	r1, #65536	; 0x10000
    67b8:	f106 0070 	add.w	r0, r6, #112	; 0x70
    67bc:	f014 fd71 	bl	1b2a2 <atomic_or>
		keys->flags |= BT_KEYS_ID_PENDING_ADD;
    67c0:	7a6b      	ldrb	r3, [r5, #9]
    67c2:	f043 0304 	orr.w	r3, r3, #4
    67c6:	726b      	strb	r3, [r5, #9]
		bt_conn_unref(conn);
    67c8:	4638      	mov	r0, r7
    67ca:	f014 fef8 	bl	1b5be <bt_conn_unref>
		return;
    67ce:	e7e9      	b.n	67a4 <bt_id_add+0x1c>
	adv_enabled = atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING);
    67d0:	f106 0070 	add.w	r0, r6, #112	; 0x70
    67d4:	2105      	movs	r1, #5
    67d6:	f014 fdb4 	bl	1b342 <atomic_test_bit>
	if (adv_enabled) {
    67da:	4606      	mov	r6, r0
    67dc:	b110      	cbz	r0, 67e4 <bt_id_add+0x5c>
		set_advertise_enable(false);
    67de:	4638      	mov	r0, r7
    67e0:	f7ff fcde 	bl	61a0 <set_advertise_enable>
	if (bt_dev.le.rl_entries) {
    67e4:	f894 30a5 	ldrb.w	r3, [r4, #165]	; 0xa5
    67e8:	b193      	cbz	r3, 6810 <bt_id_add+0x88>
		err = addr_res_enable(BT_HCI_ADDR_RES_DISABLE);
    67ea:	2000      	movs	r0, #0
    67ec:	f014 fdc7 	bl	1b37e <addr_res_enable>
		if (err) {
    67f0:	b170      	cbz	r0, 6810 <bt_id_add+0x88>
			BT_WARN("Failed to disable address resolution");
    67f2:	2302      	movs	r3, #2
    67f4:	f04f 0100 	mov.w	r1, #0
    67f8:	f363 0107 	bfi	r1, r3, #0, #8
    67fc:	4a49      	ldr	r2, [pc, #292]	; (6924 <bt_id_add+0x19c>)
    67fe:	4b4a      	ldr	r3, [pc, #296]	; (6928 <bt_id_add+0x1a0>)
    6800:	484a      	ldr	r0, [pc, #296]	; (692c <bt_id_add+0x1a4>)
    6802:	1a9b      	subs	r3, r3, r2
    6804:	08db      	lsrs	r3, r3, #3
    6806:	f363 118f 	bfi	r1, r3, #6, #10
		BT_WARN("Set privacy mode command is not supported");
    680a:	f013 ff02 	bl	1a612 <log_0>
	if (err) {
    680e:	e029      	b.n	6864 <bt_id_add+0xdc>
	if (bt_dev.le.rl_entries == bt_dev.le.rl_size) {
    6810:	f894 20a5 	ldrb.w	r2, [r4, #165]	; 0xa5
    6814:	f894 30a4 	ldrb.w	r3, [r4, #164]	; 0xa4
    6818:	429a      	cmp	r2, r3
    681a:	d12c      	bne.n	6876 <bt_id_add+0xee>
		BT_WARN("Resolving list size exceeded. Switching to host.");
    681c:	2302      	movs	r3, #2
    681e:	f04f 0100 	mov.w	r1, #0
    6822:	f363 0107 	bfi	r1, r3, #0, #8
    6826:	4d40      	ldr	r5, [pc, #256]	; (6928 <bt_id_add+0x1a0>)
    6828:	4b3e      	ldr	r3, [pc, #248]	; (6924 <bt_id_add+0x19c>)
    682a:	4841      	ldr	r0, [pc, #260]	; (6930 <bt_id_add+0x1a8>)
    682c:	1aed      	subs	r5, r5, r3
    682e:	f3c5 05c9 	ubfx	r5, r5, #3, #10
    6832:	f365 118f 	bfi	r1, r5, #6, #10
    6836:	f013 feec 	bl	1a612 <log_0>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_CLEAR_RL, NULL, NULL);
    683a:	2200      	movs	r2, #0
    683c:	4611      	mov	r1, r2
    683e:	f242 0029 	movw	r0, #8233	; 0x2029
    6842:	f7ff fc67 	bl	6114 <bt_hci_cmd_send_sync>
		if (err) {
    6846:	b140      	cbz	r0, 685a <bt_id_add+0xd2>
			BT_ERR("Failed to clear resolution list");
    6848:	f04f 0100 	mov.w	r1, #0
    684c:	2301      	movs	r3, #1
    684e:	f363 0107 	bfi	r1, r3, #0, #8
    6852:	f365 118f 	bfi	r1, r5, #6, #10
    6856:	4837      	ldr	r0, [pc, #220]	; (6934 <bt_id_add+0x1ac>)
    6858:	e7d7      	b.n	680a <bt_id_add+0x82>
		bt_dev.le.rl_entries++;
    685a:	f894 30a5 	ldrb.w	r3, [r4, #165]	; 0xa5
    685e:	3301      	adds	r3, #1
    6860:	f884 30a5 	strb.w	r3, [r4, #165]	; 0xa5
	addr_res_enable(BT_HCI_ADDR_RES_ENABLE);
    6864:	2001      	movs	r0, #1
    6866:	f014 fd8a 	bl	1b37e <addr_res_enable>
	if (adv_enabled) {
    686a:	2e00      	cmp	r6, #0
    686c:	d09a      	beq.n	67a4 <bt_id_add+0x1c>
		set_advertise_enable(true);
    686e:	2001      	movs	r0, #1
    6870:	f7ff fc96 	bl	61a0 <set_advertise_enable>
    6874:	e796      	b.n	67a4 <bt_id_add+0x1c>
	err = hci_id_add(&keys->addr, keys->irk.val);
    6876:	1c6f      	adds	r7, r5, #1
    6878:	f105 0126 	add.w	r1, r5, #38	; 0x26
    687c:	4638      	mov	r0, r7
    687e:	f7ff fd4d 	bl	631c <hci_id_add>
	if (err) {
    6882:	4605      	mov	r5, r0
    6884:	b160      	cbz	r0, 68a0 <bt_id_add+0x118>
		BT_ERR("Failed to add IRK to controller");
    6886:	2301      	movs	r3, #1
    6888:	f04f 0100 	mov.w	r1, #0
    688c:	f363 0107 	bfi	r1, r3, #0, #8
    6890:	4a24      	ldr	r2, [pc, #144]	; (6924 <bt_id_add+0x19c>)
    6892:	4b25      	ldr	r3, [pc, #148]	; (6928 <bt_id_add+0x1a0>)
    6894:	4828      	ldr	r0, [pc, #160]	; (6938 <bt_id_add+0x1b0>)
    6896:	1a9b      	subs	r3, r3, r2
    6898:	08db      	lsrs	r3, r3, #3
    689a:	f363 118f 	bfi	r1, r3, #6, #10
    689e:	e7b4      	b.n	680a <bt_id_add+0x82>
	bt_dev.le.rl_entries++;
    68a0:	f894 30a5 	ldrb.w	r3, [r4, #165]	; 0xa5
    68a4:	3301      	adds	r3, #1
    68a6:	f884 30a5 	strb.w	r3, [r4, #165]	; 0xa5
	if (!BT_CMD_TEST(bt_dev.supported_commands, 39, 2)) {
    68aa:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
    68ae:	075b      	lsls	r3, r3, #29
    68b0:	d40c      	bmi.n	68cc <bt_id_add+0x144>
		BT_WARN("Set privacy mode command is not supported");
    68b2:	2302      	movs	r3, #2
    68b4:	f04f 0100 	mov.w	r1, #0
    68b8:	f363 0107 	bfi	r1, r3, #0, #8
    68bc:	4a19      	ldr	r2, [pc, #100]	; (6924 <bt_id_add+0x19c>)
    68be:	4b1a      	ldr	r3, [pc, #104]	; (6928 <bt_id_add+0x1a0>)
    68c0:	481e      	ldr	r0, [pc, #120]	; (693c <bt_id_add+0x1b4>)
    68c2:	1a9b      	subs	r3, r3, r2
    68c4:	08db      	lsrs	r3, r3, #3
    68c6:	f363 118f 	bfi	r1, r3, #6, #10
    68ca:	e79e      	b.n	680a <bt_id_add+0x82>
	bt_addr_le_copy(&cp.id_addr, addr);
    68cc:	4639      	mov	r1, r7
    68ce:	4668      	mov	r0, sp
    68d0:	f014 fce4 	bl	1b29c <bt_addr_le_copy>
	cp.mode = mode;
    68d4:	2301      	movs	r3, #1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PRIVACY_MODE, sizeof(cp));
    68d6:	2108      	movs	r1, #8
    68d8:	f242 004e 	movw	r0, #8270	; 0x204e
	cp.mode = mode;
    68dc:	f88d 3007 	strb.w	r3, [sp, #7]
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PRIVACY_MODE, sizeof(cp));
    68e0:	f7ff faaa 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
    68e4:	4604      	mov	r4, r0
    68e6:	b960      	cbnz	r0, 6902 <bt_id_add+0x17a>
		BT_ERR("Failed to set privacy mode");
    68e8:	2301      	movs	r3, #1
    68ea:	f04f 0100 	mov.w	r1, #0
    68ee:	f363 0107 	bfi	r1, r3, #0, #8
    68f2:	4a0c      	ldr	r2, [pc, #48]	; (6924 <bt_id_add+0x19c>)
    68f4:	4b0c      	ldr	r3, [pc, #48]	; (6928 <bt_id_add+0x1a0>)
    68f6:	4812      	ldr	r0, [pc, #72]	; (6940 <bt_id_add+0x1b8>)
    68f8:	1a9b      	subs	r3, r3, r2
    68fa:	08db      	lsrs	r3, r3, #3
    68fc:	f363 118f 	bfi	r1, r3, #6, #10
    6900:	e783      	b.n	680a <bt_id_add+0x82>
	net_buf_add_mem(buf, &cp, sizeof(cp));
    6902:	2208      	movs	r2, #8
    6904:	4669      	mov	r1, sp
    6906:	4410      	add	r0, r2
    6908:	f017 f9a6 	bl	1dc58 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_PRIVACY_MODE, buf, NULL);
    690c:	462a      	mov	r2, r5
    690e:	4621      	mov	r1, r4
    6910:	f242 004e 	movw	r0, #8270	; 0x204e
    6914:	f7ff fbfe 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
    6918:	2800      	cmp	r0, #0
    691a:	d0a3      	beq.n	6864 <bt_id_add+0xdc>
    691c:	e7e4      	b.n	68e8 <bt_id_add+0x160>
    691e:	bf00      	nop
    6920:	20005438 	.word	0x20005438
    6924:	0001ed28 	.word	0x0001ed28
    6928:	0001ede8 	.word	0x0001ede8
    692c:	000203ea 	.word	0x000203ea
    6930:	0002040f 	.word	0x0002040f
    6934:	00020440 	.word	0x00020440
    6938:	00020460 	.word	0x00020460
    693c:	00020480 	.word	0x00020480
    6940:	000204aa 	.word	0x000204aa

00006944 <bt_id_del>:
{
    6944:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!bt_dev.le.rl_size ||
    6948:	4e46      	ldr	r6, [pc, #280]	; (6a64 <bt_id_del+0x120>)
    694a:	f896 20a4 	ldrb.w	r2, [r6, #164]	; 0xa4
    694e:	f896 30a5 	ldrb.w	r3, [r6, #165]	; 0xa5
{
    6952:	4605      	mov	r5, r0
    6954:	4634      	mov	r4, r6
	if (!bt_dev.le.rl_size ||
    6956:	b112      	cbz	r2, 695e <bt_id_del+0x1a>
	    bt_dev.le.rl_entries > bt_dev.le.rl_size + 1) {
    6958:	3201      	adds	r2, #1
	if (!bt_dev.le.rl_size ||
    695a:	4293      	cmp	r3, r2
    695c:	dd04      	ble.n	6968 <bt_id_del+0x24>
		bt_dev.le.rl_entries--;
    695e:	3b01      	subs	r3, #1
    6960:	f884 30a5 	strb.w	r3, [r4, #165]	; 0xa5
}
    6964:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	conn = bt_conn_lookup_state_le(NULL, BT_CONN_CONNECT);
    6968:	2105      	movs	r1, #5
    696a:	2000      	movs	r0, #0
    696c:	f001 fd24 	bl	83b8 <bt_conn_lookup_state_le>
	if (conn) {
    6970:	4607      	mov	r7, r0
    6972:	b170      	cbz	r0, 6992 <bt_id_del+0x4e>
    6974:	f106 0070 	add.w	r0, r6, #112	; 0x70
    6978:	f44f 3180 	mov.w	r1, #65536	; 0x10000
    697c:	f014 fc91 	bl	1b2a2 <atomic_or>
		keys->flags |= BT_KEYS_ID_PENDING_DEL;
    6980:	7a6b      	ldrb	r3, [r5, #9]
    6982:	f043 0308 	orr.w	r3, r3, #8
    6986:	726b      	strb	r3, [r5, #9]
		bt_conn_unref(conn);
    6988:	4638      	mov	r0, r7
}
    698a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		bt_conn_unref(conn);
    698e:	f014 be16 	b.w	1b5be <bt_conn_unref>
	adv_enabled = atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING);
    6992:	f106 0070 	add.w	r0, r6, #112	; 0x70
    6996:	2105      	movs	r1, #5
    6998:	f014 fcd3 	bl	1b342 <atomic_test_bit>
	if (adv_enabled) {
    699c:	4606      	mov	r6, r0
    699e:	b110      	cbz	r0, 69a6 <bt_id_del+0x62>
		set_advertise_enable(false);
    69a0:	4638      	mov	r0, r7
    69a2:	f7ff fbfd 	bl	61a0 <set_advertise_enable>
	err = addr_res_enable(BT_HCI_ADDR_RES_DISABLE);
    69a6:	2000      	movs	r0, #0
    69a8:	f014 fce9 	bl	1b37e <addr_res_enable>
	if (err) {
    69ac:	4607      	mov	r7, r0
    69ae:	b1d8      	cbz	r0, 69e8 <bt_id_del+0xa4>
		BT_ERR("Disabling address resolution failed (err %d)", err);
    69b0:	2301      	movs	r3, #1
    69b2:	f04f 0200 	mov.w	r2, #0
    69b6:	f363 0207 	bfi	r2, r3, #0, #8
    69ba:	492b      	ldr	r1, [pc, #172]	; (6a68 <bt_id_del+0x124>)
    69bc:	4b2b      	ldr	r3, [pc, #172]	; (6a6c <bt_id_del+0x128>)
    69be:	1a5b      	subs	r3, r3, r1
    69c0:	08db      	lsrs	r3, r3, #3
    69c2:	4601      	mov	r1, r0
    69c4:	f363 128f 	bfi	r2, r3, #6, #10
    69c8:	4829      	ldr	r0, [pc, #164]	; (6a70 <bt_id_del+0x12c>)
    69ca:	f013 fe2f 	bl	1a62c <log_1>
	if (bt_dev.le.rl_entries) {
    69ce:	f894 30a5 	ldrb.w	r3, [r4, #165]	; 0xa5
    69d2:	b113      	cbz	r3, 69da <bt_id_del+0x96>
		addr_res_enable(BT_HCI_ADDR_RES_ENABLE);
    69d4:	2001      	movs	r0, #1
    69d6:	f014 fcd2 	bl	1b37e <addr_res_enable>
	if (adv_enabled) {
    69da:	2e00      	cmp	r6, #0
    69dc:	d0c2      	beq.n	6964 <bt_id_del+0x20>
		set_advertise_enable(true);
    69de:	2001      	movs	r0, #1
}
    69e0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		set_advertise_enable(true);
    69e4:	f7ff bbdc 	b.w	61a0 <set_advertise_enable>
	if (bt_dev.le.rl_entries > bt_dev.le.rl_size) {
    69e8:	f894 30a5 	ldrb.w	r3, [r4, #165]	; 0xa5
    69ec:	f894 20a4 	ldrb.w	r2, [r4, #164]	; 0xa4
    69f0:	429a      	cmp	r2, r3
    69f2:	d20c      	bcs.n	6a0e <bt_id_del+0xca>
		bt_dev.le.rl_entries--;
    69f4:	3b01      	subs	r3, #1
    69f6:	f884 30a5 	strb.w	r3, [r4, #165]	; 0xa5
		keys->keys &= ~BT_KEYS_IRK;
    69fa:	896b      	ldrh	r3, [r5, #10]
		bt_keys_foreach(BT_KEYS_IRK, keys_add_id, NULL);
    69fc:	491d      	ldr	r1, [pc, #116]	; (6a74 <bt_id_del+0x130>)
		keys->keys &= ~BT_KEYS_IRK;
    69fe:	f023 0302 	bic.w	r3, r3, #2
		bt_keys_foreach(BT_KEYS_IRK, keys_add_id, NULL);
    6a02:	4602      	mov	r2, r0
		keys->keys &= ~BT_KEYS_IRK;
    6a04:	816b      	strh	r3, [r5, #10]
		bt_keys_foreach(BT_KEYS_IRK, keys_add_id, NULL);
    6a06:	2002      	movs	r0, #2
    6a08:	f006 fe5e 	bl	d6c8 <bt_keys_foreach>
		goto done;
    6a0c:	e7df      	b.n	69ce <bt_id_del+0x8a>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_REM_DEV_FROM_RL, sizeof(*cp));
    6a0e:	2107      	movs	r1, #7
    6a10:	f242 0028 	movw	r0, #8232	; 0x2028
    6a14:	f7ff fa10 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
    6a18:	4680      	mov	r8, r0
    6a1a:	2800      	cmp	r0, #0
    6a1c:	d0d7      	beq.n	69ce <bt_id_del+0x8a>
	cp = net_buf_add(buf, sizeof(*cp));
    6a1e:	2107      	movs	r1, #7
    6a20:	3008      	adds	r0, #8
    6a22:	f017 f913 	bl	1dc4c <net_buf_simple_add>
	bt_addr_le_copy(&cp->peer_id_addr, &keys->addr);
    6a26:	1c69      	adds	r1, r5, #1
    6a28:	f014 fc38 	bl	1b29c <bt_addr_le_copy>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_REM_DEV_FROM_RL, buf, NULL);
    6a2c:	463a      	mov	r2, r7
    6a2e:	4641      	mov	r1, r8
    6a30:	f242 0028 	movw	r0, #8232	; 0x2028
    6a34:	f7ff fb6e 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
    6a38:	b170      	cbz	r0, 6a58 <bt_id_del+0x114>
		BT_ERR("Failed to remove IRK from controller");
    6a3a:	2301      	movs	r3, #1
    6a3c:	f04f 0100 	mov.w	r1, #0
    6a40:	f363 0107 	bfi	r1, r3, #0, #8
    6a44:	4a08      	ldr	r2, [pc, #32]	; (6a68 <bt_id_del+0x124>)
    6a46:	4b09      	ldr	r3, [pc, #36]	; (6a6c <bt_id_del+0x128>)
    6a48:	480b      	ldr	r0, [pc, #44]	; (6a78 <bt_id_del+0x134>)
    6a4a:	1a9b      	subs	r3, r3, r2
    6a4c:	08db      	lsrs	r3, r3, #3
    6a4e:	f363 118f 	bfi	r1, r3, #6, #10
    6a52:	f013 fdde 	bl	1a612 <log_0>
		goto done;
    6a56:	e7ba      	b.n	69ce <bt_id_del+0x8a>
	bt_dev.le.rl_entries--;
    6a58:	f894 30a5 	ldrb.w	r3, [r4, #165]	; 0xa5
    6a5c:	3b01      	subs	r3, #1
    6a5e:	f884 30a5 	strb.w	r3, [r4, #165]	; 0xa5
    6a62:	e7b4      	b.n	69ce <bt_id_del+0x8a>
    6a64:	20005438 	.word	0x20005438
    6a68:	0001ed28 	.word	0x0001ed28
    6a6c:	0001ede8 	.word	0x0001ede8
    6a70:	000204f3 	.word	0x000204f3
    6a74:	0001b375 	.word	0x0001b375
    6a78:	00020520 	.word	0x00020520

00006a7c <id_create>:
{
    6a7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6a80:	4b28      	ldr	r3, [pc, #160]	; (6b24 <id_create+0xa8>)
    6a82:	ebc0 07c0 	rsb	r7, r0, r0, lsl #3
    6a86:	b086      	sub	sp, #24
    6a88:	4604      	mov	r4, r0
    6a8a:	4615      	mov	r5, r2
    6a8c:	441f      	add	r7, r3
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    6a8e:	460e      	mov	r6, r1
    6a90:	4698      	mov	r8, r3
    6a92:	b361      	cbz	r1, 6aee <id_create+0x72>
    6a94:	2300      	movs	r3, #0
    6a96:	2207      	movs	r2, #7
    6a98:	4669      	mov	r1, sp
    6a9a:	4630      	mov	r0, r6
    6a9c:	9300      	str	r3, [sp, #0]
    6a9e:	f8cd 3003 	str.w	r3, [sp, #3]
    6aa2:	f014 fa9a 	bl	1afda <memcmp>
    6aa6:	b310      	cbz	r0, 6aee <id_create+0x72>
		bt_addr_le_copy(&bt_dev.id_addr[id], addr);
    6aa8:	4631      	mov	r1, r6
    6aaa:	4638      	mov	r0, r7
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
    6aac:	f014 fbf6 	bl	1b29c <bt_addr_le_copy>
		u8_t zero_irk[16] = { 0 };
    6ab0:	2610      	movs	r6, #16
    6ab2:	4632      	mov	r2, r6
    6ab4:	2100      	movs	r1, #0
    6ab6:	a802      	add	r0, sp, #8
    6ab8:	fb06 8404 	mla	r4, r6, r4, r8
    6abc:	f014 fac7 	bl	1b04e <memset>
		if (irk && memcmp(irk, zero_irk, 16)) {
    6ac0:	34d8      	adds	r4, #216	; 0xd8
    6ac2:	b32d      	cbz	r5, 6b10 <id_create+0x94>
    6ac4:	4632      	mov	r2, r6
    6ac6:	a902      	add	r1, sp, #8
    6ac8:	4628      	mov	r0, r5
    6aca:	f014 fa86 	bl	1afda <memcmp>
    6ace:	b1f8      	cbz	r0, 6b10 <id_create+0x94>
			memcpy(&bt_dev.irk[id], irk, 16);
    6ad0:	4632      	mov	r2, r6
    6ad2:	4629      	mov	r1, r5
    6ad4:	4620      	mov	r0, r4
				memcpy(irk, &bt_dev.irk[id], 16);
    6ad6:	f014 fa90 	bl	1affa <memcpy>
	    atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    6ada:	2101      	movs	r1, #1
    6adc:	4812      	ldr	r0, [pc, #72]	; (6b28 <id_create+0xac>)
    6ade:	f014 fc30 	bl	1b342 <atomic_test_bit>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
    6ae2:	b108      	cbz	r0, 6ae8 <id_create+0x6c>
		bt_settings_save_id();
    6ae4:	f7fe fc7c 	bl	53e0 <bt_settings_save_id>
}
    6ae8:	b006      	add	sp, #24
    6aea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			bt_addr_le_create_static(&new_addr);
    6aee:	a802      	add	r0, sp, #8
    6af0:	f014 fc95 	bl	1b41e <bt_addr_le_create_static>
		} while (id_find(&new_addr) >= 0);
    6af4:	a802      	add	r0, sp, #8
    6af6:	f7fe ffe7 	bl	5ac8 <id_find>
    6afa:	2800      	cmp	r0, #0
    6afc:	daf7      	bge.n	6aee <id_create+0x72>
		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);
    6afe:	a902      	add	r1, sp, #8
    6b00:	4638      	mov	r0, r7
    6b02:	f014 fbcb 	bl	1b29c <bt_addr_le_copy>
		if (addr) {
    6b06:	2e00      	cmp	r6, #0
    6b08:	d0d2      	beq.n	6ab0 <id_create+0x34>
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
    6b0a:	4639      	mov	r1, r7
    6b0c:	4630      	mov	r0, r6
    6b0e:	e7cd      	b.n	6aac <id_create+0x30>
			bt_rand(&bt_dev.irk[id], 16);
    6b10:	2110      	movs	r1, #16
    6b12:	4620      	mov	r0, r4
    6b14:	f008 ffa4 	bl	fa60 <bt_rand>
			if (irk) {
    6b18:	2d00      	cmp	r5, #0
    6b1a:	d0de      	beq.n	6ada <id_create+0x5e>
				memcpy(irk, &bt_dev.irk[id], 16);
    6b1c:	2210      	movs	r2, #16
    6b1e:	4621      	mov	r1, r4
    6b20:	4628      	mov	r0, r5
    6b22:	e7d8      	b.n	6ad6 <id_create+0x5a>
    6b24:	20005438 	.word	0x20005438
    6b28:	200054a8 	.word	0x200054a8

00006b2c <bt_recv>:
{
    6b2c:	b570      	push	{r4, r5, r6, lr}
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
    6b2e:	7d01      	ldrb	r1, [r0, #20]
	switch (bt_buf_get_type(buf)) {
    6b30:	2901      	cmp	r1, #1
{
    6b32:	4604      	mov	r4, r0
	switch (bt_buf_get_type(buf)) {
    6b34:	d054      	beq.n	6be0 <bt_recv+0xb4>
    6b36:	2903      	cmp	r1, #3
    6b38:	f040 8084 	bne.w	6c44 <bt_recv+0x118>
	BT_ASSERT(buf->len >= sizeof(*hdr));
    6b3c:	8983      	ldrh	r3, [r0, #12]
    6b3e:	2b03      	cmp	r3, #3
    6b40:	d80c      	bhi.n	6b5c <bt_recv+0x30>
    6b42:	f240 237f 	movw	r3, #639	; 0x27f
    6b46:	4a49      	ldr	r2, [pc, #292]	; (6c6c <bt_recv+0x140>)
    6b48:	4949      	ldr	r1, [pc, #292]	; (6c70 <bt_recv+0x144>)
    6b4a:	484a      	ldr	r0, [pc, #296]	; (6c74 <bt_recv+0x148>)
    6b4c:	f012 fc12 	bl	19374 <printk>
    6b50:	4040      	eors	r0, r0
    6b52:	f380 8811 	msr	BASEPRI, r0
    6b56:	f04f 0003 	mov.w	r0, #3
    6b5a:	df02      	svc	2
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    6b5c:	2104      	movs	r1, #4
    6b5e:	f104 0008 	add.w	r0, r4, #8
    6b62:	f017 f8a4 	bl	1dcae <net_buf_simple_pull_mem>
	if (buf->len != len) {
    6b66:	89a1      	ldrh	r1, [r4, #12]
	len = sys_le16_to_cpu(hdr->len);
    6b68:	8842      	ldrh	r2, [r0, #2]
	handle = sys_le16_to_cpu(hdr->handle);
    6b6a:	8806      	ldrh	r6, [r0, #0]
	acl(buf)->id = BT_CONN_ID_INVALID;
    6b6c:	23ff      	movs	r3, #255	; 0xff
	acl(buf)->handle = bt_acl_handle(handle);
    6b6e:	f3c6 000b 	ubfx	r0, r6, #0, #12
	if (buf->len != len) {
    6b72:	428a      	cmp	r2, r1
	acl(buf)->handle = bt_acl_handle(handle);
    6b74:	82e0      	strh	r0, [r4, #22]
	acl(buf)->id = BT_CONN_ID_INVALID;
    6b76:	7563      	strb	r3, [r4, #21]
	if (buf->len != len) {
    6b78:	d011      	beq.n	6b9e <bt_recv+0x72>
		BT_ERR("ACL data length mismatch (%u != %u)", buf->len, len);
    6b7a:	2001      	movs	r0, #1
    6b7c:	f04f 0300 	mov.w	r3, #0
    6b80:	f360 0307 	bfi	r3, r0, #0, #8
    6b84:	4d3c      	ldr	r5, [pc, #240]	; (6c78 <bt_recv+0x14c>)
    6b86:	483d      	ldr	r0, [pc, #244]	; (6c7c <bt_recv+0x150>)
    6b88:	1b40      	subs	r0, r0, r5
    6b8a:	08c0      	lsrs	r0, r0, #3
    6b8c:	f360 138f 	bfi	r3, r0, #6, #10
    6b90:	483b      	ldr	r0, [pc, #236]	; (6c80 <bt_recv+0x154>)
    6b92:	f013 fd5f 	bl	1a654 <log_2>
	net_buf_unref(buf);
    6b96:	4620      	mov	r0, r4
    6b98:	f00f fcc2 	bl	16520 <net_buf_unref>
    6b9c:	e01e      	b.n	6bdc <bt_recv+0xb0>
	conn = bt_conn_lookup_handle(acl(buf)->handle);
    6b9e:	f001 fbd3 	bl	8348 <bt_conn_lookup_handle>
	if (!conn) {
    6ba2:	4605      	mov	r5, r0
    6ba4:	b978      	cbnz	r0, 6bc6 <bt_recv+0x9a>
		BT_ERR("Unable to find conn for handle %u", acl(buf)->handle);
    6ba6:	2301      	movs	r3, #1
    6ba8:	f04f 0200 	mov.w	r2, #0
    6bac:	f363 0207 	bfi	r2, r3, #0, #8
    6bb0:	4931      	ldr	r1, [pc, #196]	; (6c78 <bt_recv+0x14c>)
    6bb2:	4b32      	ldr	r3, [pc, #200]	; (6c7c <bt_recv+0x150>)
    6bb4:	4833      	ldr	r0, [pc, #204]	; (6c84 <bt_recv+0x158>)
    6bb6:	1a5b      	subs	r3, r3, r1
    6bb8:	08db      	lsrs	r3, r3, #3
    6bba:	f363 128f 	bfi	r2, r3, #6, #10
    6bbe:	8ae1      	ldrh	r1, [r4, #22]
    6bc0:	f013 fd34 	bl	1a62c <log_1>
		net_buf_unref(buf);
    6bc4:	e7e7      	b.n	6b96 <bt_recv+0x6a>
	acl(buf)->id = bt_conn_index(conn);
    6bc6:	f001 fd89 	bl	86dc <bt_conn_index>
	bt_conn_recv(conn, buf, flags);
    6bca:	0b32      	lsrs	r2, r6, #12
	acl(buf)->id = bt_conn_index(conn);
    6bcc:	7560      	strb	r0, [r4, #21]
	bt_conn_recv(conn, buf, flags);
    6bce:	4621      	mov	r1, r4
    6bd0:	4628      	mov	r0, r5
    6bd2:	f001 f94b 	bl	7e6c <bt_conn_recv>
	bt_conn_unref(conn);
    6bd6:	4628      	mov	r0, r5
    6bd8:	f014 fcf1 	bl	1b5be <bt_conn_unref>
		return 0;
    6bdc:	2000      	movs	r0, #0
}
    6bde:	bd70      	pop	{r4, r5, r6, pc}
	BT_ASSERT(buf->len >= sizeof(*hdr));
    6be0:	8983      	ldrh	r3, [r0, #12]
    6be2:	2b01      	cmp	r3, #1
    6be4:	d80c      	bhi.n	6c00 <bt_recv+0xd4>
    6be6:	f640 7339 	movw	r3, #3897	; 0xf39
    6bea:	4a20      	ldr	r2, [pc, #128]	; (6c6c <bt_recv+0x140>)
    6bec:	4920      	ldr	r1, [pc, #128]	; (6c70 <bt_recv+0x144>)
    6bee:	4821      	ldr	r0, [pc, #132]	; (6c74 <bt_recv+0x148>)
    6bf0:	f012 fbc0 	bl	19374 <printk>
    6bf4:	4040      	eors	r0, r0
    6bf6:	f380 8811 	msr	BASEPRI, r0
    6bfa:	f04f 0003 	mov.w	r0, #3
    6bfe:	df02      	svc	2
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    6c00:	2102      	movs	r1, #2
    6c02:	f104 0008 	add.w	r0, r4, #8
    6c06:	f017 f852 	bl	1dcae <net_buf_simple_pull_mem>
	BT_ASSERT(!bt_hci_evt_is_prio(hdr->evt));
    6c0a:	7802      	ldrb	r2, [r0, #0]
    6c0c:	2a1a      	cmp	r2, #26
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    6c0e:	4605      	mov	r5, r0
 * @return true if the event can be processed in the RX thread, false
 *         if it cannot.
 */
static inline bool bt_hci_evt_is_prio(u8_t evt)
{
	switch (evt) {
    6c10:	d811      	bhi.n	6c36 <bt_recv+0x10a>
    6c12:	2301      	movs	r3, #1
    6c14:	4093      	lsls	r3, r2
    6c16:	4a1c      	ldr	r2, [pc, #112]	; (6c88 <bt_recv+0x15c>)
    6c18:	4213      	tst	r3, r2
    6c1a:	d00c      	beq.n	6c36 <bt_recv+0x10a>
	BT_ASSERT(!bt_hci_evt_is_prio(hdr->evt));
    6c1c:	f640 733d 	movw	r3, #3901	; 0xf3d
    6c20:	4a12      	ldr	r2, [pc, #72]	; (6c6c <bt_recv+0x140>)
    6c22:	491a      	ldr	r1, [pc, #104]	; (6c8c <bt_recv+0x160>)
    6c24:	4813      	ldr	r0, [pc, #76]	; (6c74 <bt_recv+0x148>)
    6c26:	f012 fba5 	bl	19374 <printk>
    6c2a:	4040      	eors	r0, r0
    6c2c:	f380 8811 	msr	BASEPRI, r0
    6c30:	f04f 0003 	mov.w	r0, #3
    6c34:	df02      	svc	2
	handle_event(hdr->evt, buf, normal_events, ARRAY_SIZE(normal_events));
    6c36:	2305      	movs	r3, #5
    6c38:	4a15      	ldr	r2, [pc, #84]	; (6c90 <bt_recv+0x164>)
    6c3a:	7828      	ldrb	r0, [r5, #0]
    6c3c:	4621      	mov	r1, r4
    6c3e:	f7fe fe69 	bl	5914 <handle_event>
    6c42:	e7a8      	b.n	6b96 <bt_recv+0x6a>
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
    6c44:	2301      	movs	r3, #1
    6c46:	f04f 0200 	mov.w	r2, #0
    6c4a:	f363 0207 	bfi	r2, r3, #0, #8
    6c4e:	480a      	ldr	r0, [pc, #40]	; (6c78 <bt_recv+0x14c>)
    6c50:	4b0a      	ldr	r3, [pc, #40]	; (6c7c <bt_recv+0x150>)
    6c52:	1a1b      	subs	r3, r3, r0
    6c54:	08db      	lsrs	r3, r3, #3
    6c56:	f363 128f 	bfi	r2, r3, #6, #10
    6c5a:	480e      	ldr	r0, [pc, #56]	; (6c94 <bt_recv+0x168>)
    6c5c:	f013 fce6 	bl	1a62c <log_1>
		net_buf_unref(buf);
    6c60:	4620      	mov	r0, r4
    6c62:	f00f fc5d 	bl	16520 <net_buf_unref>
		return -EINVAL;
    6c66:	f06f 0015 	mvn.w	r0, #21
    6c6a:	e7b8      	b.n	6bde <bt_recv+0xb2>
    6c6c:	00020a6e 	.word	0x00020a6e
    6c70:	0002070c 	.word	0x0002070c
    6c74:	00020aa4 	.word	0x00020aa4
    6c78:	0001ed28 	.word	0x0001ed28
    6c7c:	0001ede8 	.word	0x0001ede8
    6c80:	00020725 	.word	0x00020725
    6c84:	00020749 	.word	0x00020749
    6c88:	0408c000 	.word	0x0408c000
    6c8c:	0002076b 	.word	0x0002076b
    6c90:	0001f358 	.word	0x0001f358
    6c94:	00020789 	.word	0x00020789

00006c98 <bt_recv_prio>:
{
    6c98:	b538      	push	{r3, r4, r5, lr}
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
    6c9a:	7d03      	ldrb	r3, [r0, #20]
    6c9c:	2b01      	cmp	r3, #1
{
    6c9e:	4604      	mov	r4, r0
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
    6ca0:	d00c      	beq.n	6cbc <bt_recv_prio+0x24>
    6ca2:	f241 33a6 	movw	r3, #5030	; 0x13a6
    6ca6:	4a20      	ldr	r2, [pc, #128]	; (6d28 <bt_recv_prio+0x90>)
    6ca8:	4920      	ldr	r1, [pc, #128]	; (6d2c <bt_recv_prio+0x94>)
    6caa:	4821      	ldr	r0, [pc, #132]	; (6d30 <bt_recv_prio+0x98>)
    6cac:	f012 fb62 	bl	19374 <printk>
    6cb0:	4040      	eors	r0, r0
    6cb2:	f380 8811 	msr	BASEPRI, r0
    6cb6:	f04f 0003 	mov.w	r0, #3
    6cba:	df02      	svc	2
	BT_ASSERT(buf->len >= sizeof(*hdr));
    6cbc:	89a3      	ldrh	r3, [r4, #12]
    6cbe:	2b01      	cmp	r3, #1
    6cc0:	d80c      	bhi.n	6cdc <bt_recv_prio+0x44>
    6cc2:	f241 33a7 	movw	r3, #5031	; 0x13a7
    6cc6:	4a18      	ldr	r2, [pc, #96]	; (6d28 <bt_recv_prio+0x90>)
    6cc8:	491a      	ldr	r1, [pc, #104]	; (6d34 <bt_recv_prio+0x9c>)
    6cca:	4819      	ldr	r0, [pc, #100]	; (6d30 <bt_recv_prio+0x98>)
    6ccc:	f012 fb52 	bl	19374 <printk>
    6cd0:	4040      	eors	r0, r0
    6cd2:	f380 8811 	msr	BASEPRI, r0
    6cd6:	f04f 0003 	mov.w	r0, #3
    6cda:	df02      	svc	2
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    6cdc:	2102      	movs	r1, #2
    6cde:	f104 0008 	add.w	r0, r4, #8
    6ce2:	f016 ffe4 	bl	1dcae <net_buf_simple_pull_mem>
	BT_ASSERT(bt_hci_evt_is_prio(hdr->evt));
    6ce6:	7802      	ldrb	r2, [r0, #0]
    6ce8:	2a1a      	cmp	r2, #26
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    6cea:	4605      	mov	r5, r0
    6cec:	d804      	bhi.n	6cf8 <bt_recv_prio+0x60>
    6cee:	2301      	movs	r3, #1
    6cf0:	4093      	lsls	r3, r2
    6cf2:	4a11      	ldr	r2, [pc, #68]	; (6d38 <bt_recv_prio+0xa0>)
    6cf4:	4213      	tst	r3, r2
    6cf6:	d10c      	bne.n	6d12 <bt_recv_prio+0x7a>
	BT_ASSERT(bt_hci_evt_is_prio(hdr->evt));
    6cf8:	f241 33aa 	movw	r3, #5034	; 0x13aa
    6cfc:	4a0a      	ldr	r2, [pc, #40]	; (6d28 <bt_recv_prio+0x90>)
    6cfe:	490f      	ldr	r1, [pc, #60]	; (6d3c <bt_recv_prio+0xa4>)
    6d00:	480b      	ldr	r0, [pc, #44]	; (6d30 <bt_recv_prio+0x98>)
    6d02:	f012 fb37 	bl	19374 <printk>
    6d06:	4040      	eors	r0, r0
    6d08:	f380 8811 	msr	BASEPRI, r0
    6d0c:	f04f 0003 	mov.w	r0, #3
    6d10:	df02      	svc	2
	handle_event(hdr->evt, buf, prio_events, ARRAY_SIZE(prio_events));
    6d12:	2304      	movs	r3, #4
    6d14:	4a0a      	ldr	r2, [pc, #40]	; (6d40 <bt_recv_prio+0xa8>)
    6d16:	7828      	ldrb	r0, [r5, #0]
    6d18:	4621      	mov	r1, r4
    6d1a:	f7fe fdfb 	bl	5914 <handle_event>
	net_buf_unref(buf);
    6d1e:	4620      	mov	r0, r4
    6d20:	f00f fbfe 	bl	16520 <net_buf_unref>
}
    6d24:	2000      	movs	r0, #0
    6d26:	bd38      	pop	{r3, r4, r5, pc}
    6d28:	00020a6e 	.word	0x00020a6e
    6d2c:	0002079d 	.word	0x0002079d
    6d30:	00020aa4 	.word	0x00020aa4
    6d34:	0002070c 	.word	0x0002070c
    6d38:	0408c000 	.word	0x0408c000
    6d3c:	0002076c 	.word	0x0002076c
    6d40:	0001f390 	.word	0x0001f390

00006d44 <bt_hci_driver_register>:
	if (bt_dev.drv) {
    6d44:	4a08      	ldr	r2, [pc, #32]	; (6d68 <bt_hci_driver_register+0x24>)
    6d46:	f8d2 30d4 	ldr.w	r3, [r2, #212]	; 0xd4
    6d4a:	b93b      	cbnz	r3, 6d5c <bt_hci_driver_register+0x18>
	if (!drv->open || !drv->send) {
    6d4c:	68c1      	ldr	r1, [r0, #12]
    6d4e:	b141      	cbz	r1, 6d62 <bt_hci_driver_register+0x1e>
    6d50:	6901      	ldr	r1, [r0, #16]
    6d52:	b131      	cbz	r1, 6d62 <bt_hci_driver_register+0x1e>
	bt_dev.drv = drv;
    6d54:	f8c2 00d4 	str.w	r0, [r2, #212]	; 0xd4
	return 0;
    6d58:	4618      	mov	r0, r3
    6d5a:	4770      	bx	lr
		return -EALREADY;
    6d5c:	f06f 0044 	mvn.w	r0, #68	; 0x44
    6d60:	4770      	bx	lr
		return -EINVAL;
    6d62:	f06f 0015 	mvn.w	r0, #21
}
    6d66:	4770      	bx	lr
    6d68:	20005438 	.word	0x20005438

00006d6c <bt_finalize_init>:
{
    6d6c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6d70:	4c37      	ldr	r4, [pc, #220]	; (6e50 <bt_finalize_init+0xe4>)
    6d72:	4d38      	ldr	r5, [pc, #224]	; (6e54 <bt_finalize_init+0xe8>)
	BT_INFO("Identity%s: %s", bt_dev.id_count > 1 ? "[0]" : "",
    6d74:	4e38      	ldr	r6, [pc, #224]	; (6e58 <bt_finalize_init+0xec>)
		BT_INFO("Identity[%d]: %s",
    6d76:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 6e70 <bt_finalize_init+0x104>
{
    6d7a:	b087      	sub	sp, #28
    6d7c:	2102      	movs	r1, #2
    6d7e:	f104 0070 	add.w	r0, r4, #112	; 0x70
    6d82:	f014 fa8e 	bl	1b2a2 <atomic_or>
	BT_INFO("Identity%s: %s", bt_dev.id_count > 1 ? "[0]" : "",
    6d86:	f04f 0700 	mov.w	r7, #0
    6d8a:	2303      	movs	r3, #3
    6d8c:	f363 0707 	bfi	r7, r3, #0, #8
    6d90:	4b32      	ldr	r3, [pc, #200]	; (6e5c <bt_finalize_init+0xf0>)
    6d92:	4933      	ldr	r1, [pc, #204]	; (6e60 <bt_finalize_init+0xf4>)
    6d94:	1aed      	subs	r5, r5, r3
    6d96:	79e3      	ldrb	r3, [r4, #7]
    6d98:	4620      	mov	r0, r4
    6d9a:	2b01      	cmp	r3, #1
    6d9c:	bf88      	it	hi
    6d9e:	460e      	movhi	r6, r1
    6da0:	f7fe f80c 	bl	4dbc <bt_addr_le_str_real>
    6da4:	f7fc f86e 	bl	2e84 <log_strdup>
    6da8:	f3c5 05c9 	ubfx	r5, r5, #3, #10
    6dac:	f365 178f 	bfi	r7, r5, #6, #10
    6db0:	463b      	mov	r3, r7
    6db2:	4602      	mov	r2, r0
    6db4:	4631      	mov	r1, r6
    6db6:	482b      	ldr	r0, [pc, #172]	; (6e64 <bt_finalize_init+0xf8>)
    6db8:	f013 fc4c 	bl	1a654 <log_2>
	for (i = 1; i < bt_dev.id_count; i++) {
    6dbc:	4627      	mov	r7, r4
    6dbe:	2601      	movs	r6, #1
    6dc0:	79e3      	ldrb	r3, [r4, #7]
    6dc2:	429e      	cmp	r6, r3
    6dc4:	f107 0707 	add.w	r7, r7, #7
    6dc8:	db2c      	blt.n	6e24 <bt_finalize_init+0xb8>
	BT_INFO("HCI: version %s (0x%02x) revision 0x%04x, manufacturer 0x%04x",
    6dca:	7c27      	ldrb	r7, [r4, #16]
    6dcc:	2303      	movs	r3, #3
    6dce:	4638      	mov	r0, r7
    6dd0:	f04f 0600 	mov.w	r6, #0
    6dd4:	f363 0607 	bfi	r6, r3, #0, #8
    6dd8:	f7fe fbd0 	bl	557c <ver_str>
    6ddc:	8a63      	ldrh	r3, [r4, #18]
    6dde:	9304      	str	r3, [sp, #16]
    6de0:	f365 168f 	bfi	r6, r5, #6, #10
    6de4:	8ae3      	ldrh	r3, [r4, #22]
    6de6:	9305      	str	r3, [sp, #20]
    6de8:	a902      	add	r1, sp, #8
    6dea:	e9cd 0702 	strd	r0, r7, [sp, #8]
    6dee:	4633      	mov	r3, r6
    6df0:	2204      	movs	r2, #4
    6df2:	481d      	ldr	r0, [pc, #116]	; (6e68 <bt_finalize_init+0xfc>)
    6df4:	f013 fc61 	bl	1a6ba <log_n>
	BT_INFO("LMP: version %s (0x%02x) subver 0x%04x",
    6df8:	f04f 0600 	mov.w	r6, #0
    6dfc:	2303      	movs	r3, #3
    6dfe:	f363 0607 	bfi	r6, r3, #0, #8
    6e02:	f365 168f 	bfi	r6, r5, #6, #10
    6e06:	7c65      	ldrb	r5, [r4, #17]
    6e08:	4628      	mov	r0, r5
    6e0a:	f7fe fbb7 	bl	557c <ver_str>
    6e0e:	f8ad 6000 	strh.w	r6, [sp]
    6e12:	4601      	mov	r1, r0
    6e14:	8aa3      	ldrh	r3, [r4, #20]
    6e16:	4815      	ldr	r0, [pc, #84]	; (6e6c <bt_finalize_init+0x100>)
    6e18:	462a      	mov	r2, r5
    6e1a:	f013 fc33 	bl	1a684 <log_3>
}
    6e1e:	b007      	add	sp, #28
    6e20:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		BT_INFO("Identity[%d]: %s",
    6e24:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
    6e28:	f043 0303 	orr.w	r3, r3, #3
    6e2c:	4638      	mov	r0, r7
    6e2e:	f363 0807 	bfi	r8, r3, #0, #8
    6e32:	f7fd ffc3 	bl	4dbc <bt_addr_le_str_real>
    6e36:	f7fc f825 	bl	2e84 <log_strdup>
    6e3a:	f365 188f 	bfi	r8, r5, #6, #10
    6e3e:	4602      	mov	r2, r0
    6e40:	4631      	mov	r1, r6
    6e42:	4643      	mov	r3, r8
    6e44:	4648      	mov	r0, r9
    6e46:	f013 fc05 	bl	1a654 <log_2>
	for (i = 1; i < bt_dev.id_count; i++) {
    6e4a:	3601      	adds	r6, #1
    6e4c:	e7b8      	b.n	6dc0 <bt_finalize_init+0x54>
    6e4e:	bf00      	nop
    6e50:	20005438 	.word	0x20005438
    6e54:	0001ede8 	.word	0x0001ede8
    6e58:	0001f7cb 	.word	0x0001f7cb
    6e5c:	0001ed28 	.word	0x0001ed28
    6e60:	00020361 	.word	0x00020361
    6e64:	00020365 	.word	0x00020365
    6e68:	00020385 	.word	0x00020385
    6e6c:	000203c3 	.word	0x000203c3
    6e70:	00020374 	.word	0x00020374

00006e74 <init_work>:
{
    6e74:	b510      	push	{r4, lr}
	err = bt_init();
    6e76:	f7f9 faa7 	bl	3c8 <bt_init>
	if (ready_cb) {
    6e7a:	4b03      	ldr	r3, [pc, #12]	; (6e88 <init_work+0x14>)
    6e7c:	681b      	ldr	r3, [r3, #0]
    6e7e:	b113      	cbz	r3, 6e86 <init_work+0x12>
}
    6e80:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ready_cb(err);
    6e84:	4718      	bx	r3
}
    6e86:	bd10      	pop	{r4, pc}
    6e88:	2000022c 	.word	0x2000022c

00006e8c <bt_enable>:
{
    6e8c:	b570      	push	{r4, r5, r6, lr}
	if (!bt_dev.drv) {
    6e8e:	4d34      	ldr	r5, [pc, #208]	; (6f60 <bt_enable+0xd4>)
    6e90:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
{
    6e94:	b086      	sub	sp, #24
    6e96:	4606      	mov	r6, r0
	if (!bt_dev.drv) {
    6e98:	b993      	cbnz	r3, 6ec0 <bt_enable+0x34>
		BT_ERR("No HCI driver registered");
    6e9a:	2301      	movs	r3, #1
    6e9c:	f04f 0100 	mov.w	r1, #0
    6ea0:	f363 0107 	bfi	r1, r3, #0, #8
    6ea4:	4a2f      	ldr	r2, [pc, #188]	; (6f64 <bt_enable+0xd8>)
    6ea6:	4b30      	ldr	r3, [pc, #192]	; (6f68 <bt_enable+0xdc>)
    6ea8:	4830      	ldr	r0, [pc, #192]	; (6f6c <bt_enable+0xe0>)
    6eaa:	1a9b      	subs	r3, r3, r2
    6eac:	08db      	lsrs	r3, r3, #3
    6eae:	f363 118f 	bfi	r1, r3, #6, #10
    6eb2:	f013 fbae 	bl	1a612 <log_0>
		return -ENODEV;
    6eb6:	f06f 0412 	mvn.w	r4, #18
}
    6eba:	4620      	mov	r0, r4
    6ebc:	b006      	add	sp, #24
    6ebe:	bd70      	pop	{r4, r5, r6, pc}
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    6ec0:	2101      	movs	r1, #1
    6ec2:	f105 0070 	add.w	r0, r5, #112	; 0x70
    6ec6:	f014 f9ec 	bl	1b2a2 <atomic_or>
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_ENABLE)) {
    6eca:	07c2      	lsls	r2, r0, #31
    6ecc:	d444      	bmi.n	6f58 <bt_enable+0xcc>
		err = bt_settings_init();
    6ece:	f7fe faeb 	bl	54a8 <bt_settings_init>
		if (err) {
    6ed2:	4604      	mov	r4, r0
    6ed4:	2800      	cmp	r0, #0
    6ed6:	d1f0      	bne.n	6eba <bt_enable+0x2e>
	ready_cb = cb;
    6ed8:	4b25      	ldr	r3, [pc, #148]	; (6f70 <bt_enable+0xe4>)
    6eda:	601e      	str	r6, [r3, #0]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    6edc:	f06f 0308 	mvn.w	r3, #8
    6ee0:	e9cd 0302 	strd	r0, r3, [sp, #8]
    6ee4:	e9cd 0004 	strd	r0, r0, [sp, #16]
    6ee8:	e9cd 0000 	strd	r0, r0, [sp]
    6eec:	4b21      	ldr	r3, [pc, #132]	; (6f74 <bt_enable+0xe8>)
    6eee:	4922      	ldr	r1, [pc, #136]	; (6f78 <bt_enable+0xec>)
    6ef0:	4822      	ldr	r0, [pc, #136]	; (6f7c <bt_enable+0xf0>)
    6ef2:	f44f 7220 	mov.w	r2, #640	; 0x280
    6ef6:	f011 fb69 	bl	185cc <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    6efa:	4921      	ldr	r1, [pc, #132]	; (6f80 <bt_enable+0xf4>)
    6efc:	481f      	ldr	r0, [pc, #124]	; (6f7c <bt_enable+0xf0>)
    6efe:	f017 fbb0 	bl	1e662 <z_impl_k_thread_name_set>
		bt_hci_ecc_init();
    6f02:	f7fe f90f 	bl	5124 <bt_hci_ecc_init>
	err = bt_dev.drv->open();
    6f06:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
    6f0a:	68db      	ldr	r3, [r3, #12]
    6f0c:	4798      	blx	r3
	if (err) {
    6f0e:	4604      	mov	r4, r0
    6f10:	b178      	cbz	r0, 6f32 <bt_enable+0xa6>
		BT_ERR("HCI driver open failed (%d)", err);
    6f12:	2301      	movs	r3, #1
    6f14:	f04f 0200 	mov.w	r2, #0
    6f18:	f363 0207 	bfi	r2, r3, #0, #8
    6f1c:	4911      	ldr	r1, [pc, #68]	; (6f64 <bt_enable+0xd8>)
    6f1e:	4b12      	ldr	r3, [pc, #72]	; (6f68 <bt_enable+0xdc>)
    6f20:	1a5b      	subs	r3, r3, r1
    6f22:	08db      	lsrs	r3, r3, #3
    6f24:	4601      	mov	r1, r0
    6f26:	f363 128f 	bfi	r2, r3, #6, #10
    6f2a:	4816      	ldr	r0, [pc, #88]	; (6f84 <bt_enable+0xf8>)
    6f2c:	f013 fb7e 	bl	1a62c <log_1>
		return err;
    6f30:	e7c3      	b.n	6eba <bt_enable+0x2e>
	if (!cb) {
    6f32:	b926      	cbnz	r6, 6f3e <bt_enable+0xb2>
}
    6f34:	b006      	add	sp, #24
    6f36:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_init();
    6f3a:	f7f9 ba45 	b.w	3c8 <bt_init>
    6f3e:	2101      	movs	r1, #1
    6f40:	f105 006c 	add.w	r0, r5, #108	; 0x6c
    6f44:	f014 f9ad 	bl	1b2a2 <atomic_or>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    6f48:	07c3      	lsls	r3, r0, #31
    6f4a:	d4b6      	bmi.n	6eba <bt_enable+0x2e>
		k_queue_append(&work_q->queue, work);
    6f4c:	f105 0164 	add.w	r1, r5, #100	; 0x64
    6f50:	480d      	ldr	r0, [pc, #52]	; (6f88 <bt_enable+0xfc>)
    6f52:	f017 f9fb 	bl	1e34c <k_queue_append>
    6f56:	e7b0      	b.n	6eba <bt_enable+0x2e>
		return -EALREADY;
    6f58:	f06f 0444 	mvn.w	r4, #68	; 0x44
    6f5c:	e7ad      	b.n	6eba <bt_enable+0x2e>
    6f5e:	bf00      	nop
    6f60:	20005438 	.word	0x20005438
    6f64:	0001ed28 	.word	0x0001ed28
    6f68:	0001ede8 	.word	0x0001ede8
    6f6c:	00020326 	.word	0x00020326
    6f70:	2000022c 	.word	0x2000022c
    6f74:	00005afd 	.word	0x00005afd
    6f78:	20002698 	.word	0x20002698
    6f7c:	20000230 	.word	0x20000230
    6f80:	0002033f 	.word	0x0002033f
    6f84:	00020345 	.word	0x00020345
    6f88:	20001a60 	.word	0x20001a60

00006f8c <bt_set_name>:
{
    6f8c:	b530      	push	{r4, r5, lr}
    6f8e:	b085      	sub	sp, #20
    6f90:	4604      	mov	r4, r0
	size_t len = strlen(name);
    6f92:	f014 f800 	bl	1af96 <strlen>
	if (len >= sizeof(bt_dev.name)) {
    6f96:	2841      	cmp	r0, #65	; 0x41
	size_t len = strlen(name);
    6f98:	4605      	mov	r5, r0
	if (len >= sizeof(bt_dev.name)) {
    6f9a:	d839      	bhi.n	7010 <bt_set_name+0x84>
	if (!strcmp(bt_dev.name, name)) {
    6f9c:	4621      	mov	r1, r4
    6f9e:	481e      	ldr	r0, [pc, #120]	; (7018 <bt_set_name+0x8c>)
    6fa0:	f014 f800 	bl	1afa4 <strcmp>
    6fa4:	b910      	cbnz	r0, 6fac <bt_set_name+0x20>
	return 0;
    6fa6:	2000      	movs	r0, #0
}
    6fa8:	b005      	add	sp, #20
    6faa:	bd30      	pop	{r4, r5, pc}
	strncpy(bt_dev.name, name, sizeof(bt_dev.name));
    6fac:	4621      	mov	r1, r4
    6fae:	2242      	movs	r2, #66	; 0x42
    6fb0:	4819      	ldr	r0, [pc, #100]	; (7018 <bt_set_name+0x8c>)
    6fb2:	f013 ffdd 	bl	1af70 <strncpy>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING_NAME)) {
    6fb6:	2106      	movs	r1, #6
    6fb8:	4818      	ldr	r0, [pc, #96]	; (701c <bt_set_name+0x90>)
    6fba:	f014 f9c2 	bl	1b342 <atomic_test_bit>
    6fbe:	b188      	cbz	r0, 6fe4 <bt_set_name+0x58>
		struct bt_data data[] = { BT_DATA(BT_DATA_NAME_COMPLETE, name,
    6fc0:	2309      	movs	r3, #9
    6fc2:	4620      	mov	r0, r4
    6fc4:	f88d 3000 	strb.w	r3, [sp]
    6fc8:	f013 ffe5 	bl	1af96 <strlen>
		struct bt_ad sd = { data, ARRAY_SIZE(data) };
    6fcc:	2201      	movs	r2, #1
		struct bt_data data[] = { BT_DATA(BT_DATA_NAME_COMPLETE, name,
    6fce:	f88d 0001 	strb.w	r0, [sp, #1]
		set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, &sd, 1);
    6fd2:	a902      	add	r1, sp, #8
    6fd4:	f242 0009 	movw	r0, #8201	; 0x2009
		struct bt_data data[] = { BT_DATA(BT_DATA_NAME_COMPLETE, name,
    6fd8:	9401      	str	r4, [sp, #4]
		struct bt_ad sd = { data, ARRAY_SIZE(data) };
    6fda:	f8cd d008 	str.w	sp, [sp, #8]
    6fde:	9203      	str	r2, [sp, #12]
		set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, &sd, 1);
    6fe0:	f7ff f9c6 	bl	6370 <set_ad>
		err = settings_save_one("bt/name", bt_dev.name, len);
    6fe4:	462a      	mov	r2, r5
    6fe6:	490c      	ldr	r1, [pc, #48]	; (7018 <bt_set_name+0x8c>)
    6fe8:	480d      	ldr	r0, [pc, #52]	; (7020 <bt_set_name+0x94>)
    6fea:	f7fc fe17 	bl	3c1c <settings_save_one>
		if (err) {
    6fee:	2800      	cmp	r0, #0
    6ff0:	d0d9      	beq.n	6fa6 <bt_set_name+0x1a>
			BT_WARN("Unable to store name");
    6ff2:	2302      	movs	r3, #2
    6ff4:	f04f 0100 	mov.w	r1, #0
    6ff8:	f363 0107 	bfi	r1, r3, #0, #8
    6ffc:	4a09      	ldr	r2, [pc, #36]	; (7024 <bt_set_name+0x98>)
    6ffe:	4b0a      	ldr	r3, [pc, #40]	; (7028 <bt_set_name+0x9c>)
    7000:	480a      	ldr	r0, [pc, #40]	; (702c <bt_set_name+0xa0>)
    7002:	1a9b      	subs	r3, r3, r2
    7004:	08db      	lsrs	r3, r3, #3
    7006:	f363 118f 	bfi	r1, r3, #6, #10
    700a:	f013 fb02 	bl	1a612 <log_0>
    700e:	e7ca      	b.n	6fa6 <bt_set_name+0x1a>
		return -ENOMEM;
    7010:	f06f 000b 	mvn.w	r0, #11
    7014:	e7c8      	b.n	6fa8 <bt_set_name+0x1c>
    7016:	bf00      	nop
    7018:	20005540 	.word	0x20005540
    701c:	200054a8 	.word	0x200054a8
    7020:	000207c0 	.word	0x000207c0
    7024:	0001ed28 	.word	0x0001ed28
    7028:	0001ede8 	.word	0x0001ede8
    702c:	000207c8 	.word	0x000207c8

00007030 <bt_get_name>:
}
    7030:	4800      	ldr	r0, [pc, #0]	; (7034 <bt_get_name+0x4>)
    7032:	4770      	bx	lr
    7034:	20005540 	.word	0x20005540

00007038 <bt_id_create>:
{
    7038:	b573      	push	{r0, r1, r4, r5, r6, lr}
    703a:	460e      	mov	r6, r1
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    703c:	4605      	mov	r5, r0
    703e:	b930      	cbnz	r0, 704e <bt_id_create+0x16>
	if (bt_dev.id_count == ARRAY_SIZE(bt_dev.id_addr)) {
    7040:	4b1d      	ldr	r3, [pc, #116]	; (70b8 <bt_id_create+0x80>)
    7042:	79dc      	ldrb	r4, [r3, #7]
    7044:	2c01      	cmp	r4, #1
    7046:	d12f      	bne.n	70a8 <bt_id_create+0x70>
		return -ENOMEM;
    7048:	f06f 040b 	mvn.w	r4, #11
    704c:	e021      	b.n	7092 <bt_id_create+0x5a>
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    704e:	2300      	movs	r3, #0
    7050:	2207      	movs	r2, #7
    7052:	4669      	mov	r1, sp
    7054:	9300      	str	r3, [sp, #0]
    7056:	f8cd 3003 	str.w	r3, [sp, #3]
    705a:	f013 ffbe 	bl	1afda <memcmp>
    705e:	2800      	cmp	r0, #0
    7060:	d0ee      	beq.n	7040 <bt_id_create+0x8>
		if (addr->type != BT_ADDR_LE_RANDOM ||
    7062:	782b      	ldrb	r3, [r5, #0]
    7064:	2b01      	cmp	r3, #1
    7066:	d104      	bne.n	7072 <bt_id_create+0x3a>
    7068:	79ab      	ldrb	r3, [r5, #6]
    706a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    706e:	2bc0      	cmp	r3, #192	; 0xc0
    7070:	d012      	beq.n	7098 <bt_id_create+0x60>
			BT_ERR("Only static random identity address supported");
    7072:	2301      	movs	r3, #1
    7074:	f04f 0100 	mov.w	r1, #0
    7078:	f363 0107 	bfi	r1, r3, #0, #8
    707c:	4a0f      	ldr	r2, [pc, #60]	; (70bc <bt_id_create+0x84>)
    707e:	4b10      	ldr	r3, [pc, #64]	; (70c0 <bt_id_create+0x88>)
    7080:	4810      	ldr	r0, [pc, #64]	; (70c4 <bt_id_create+0x8c>)
    7082:	1a9b      	subs	r3, r3, r2
    7084:	08db      	lsrs	r3, r3, #3
    7086:	f363 118f 	bfi	r1, r3, #6, #10
    708a:	f013 fac2 	bl	1a612 <log_0>
			return -EINVAL;
    708e:	f06f 0415 	mvn.w	r4, #21
}
    7092:	4620      	mov	r0, r4
    7094:	b002      	add	sp, #8
    7096:	bd70      	pop	{r4, r5, r6, pc}
		if (id_find(addr) >= 0) {
    7098:	4628      	mov	r0, r5
    709a:	f7fe fd15 	bl	5ac8 <id_find>
    709e:	2800      	cmp	r0, #0
    70a0:	dbce      	blt.n	7040 <bt_id_create+0x8>
			return -EALREADY;
    70a2:	f06f 0444 	mvn.w	r4, #68	; 0x44
    70a6:	e7f4      	b.n	7092 <bt_id_create+0x5a>
	new_id = bt_dev.id_count++;
    70a8:	1c62      	adds	r2, r4, #1
    70aa:	71da      	strb	r2, [r3, #7]
	id_create(new_id, addr, irk);
    70ac:	4629      	mov	r1, r5
    70ae:	4632      	mov	r2, r6
    70b0:	4620      	mov	r0, r4
    70b2:	f7ff fce3 	bl	6a7c <id_create>
	return new_id;
    70b6:	e7ec      	b.n	7092 <bt_id_create+0x5a>
    70b8:	20005438 	.word	0x20005438
    70bc:	0001ed28 	.word	0x0001ed28
    70c0:	0001ede8 	.word	0x0001ede8
    70c4:	000204c5 	.word	0x000204c5

000070c8 <bt_setup_public_id_addr>:
{
    70c8:	b570      	push	{r4, r5, r6, lr}
    70ca:	b08e      	sub	sp, #56	; 0x38
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
    70cc:	aa0a      	add	r2, sp, #40	; 0x28
    70ce:	2100      	movs	r1, #0
    70d0:	f241 0009 	movw	r0, #4105	; 0x1009
    70d4:	f7ff f81e 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
    70d8:	4e3b      	ldr	r6, [pc, #236]	; (71c8 <bt_setup_public_id_addr+0x100>)
    70da:	4604      	mov	r4, r0
    70dc:	b188      	cbz	r0, 7102 <bt_setup_public_id_addr+0x3a>
		BT_WARN("Failed to read public address");
    70de:	2302      	movs	r3, #2
    70e0:	f04f 0100 	mov.w	r1, #0
    70e4:	f363 0107 	bfi	r1, r3, #0, #8
    70e8:	4a38      	ldr	r2, [pc, #224]	; (71cc <bt_setup_public_id_addr+0x104>)
    70ea:	4b39      	ldr	r3, [pc, #228]	; (71d0 <bt_setup_public_id_addr+0x108>)
    70ec:	4839      	ldr	r0, [pc, #228]	; (71d4 <bt_setup_public_id_addr+0x10c>)
    70ee:	1a9b      	subs	r3, r3, r2
    70f0:	08db      	lsrs	r3, r3, #3
    70f2:	f363 118f 	bfi	r1, r3, #6, #10
    70f6:	f013 fa8c 	bl	1a612 <log_0>
	bt_dev.id_count = bt_read_public_addr(&addr);
    70fa:	2300      	movs	r3, #0
    70fc:	71f3      	strb	r3, [r6, #7]
}
    70fe:	b00e      	add	sp, #56	; 0x38
    7100:	bd70      	pop	{r4, r5, r6, pc}
	rp = (void *)rsp->data;
    7102:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    7104:	9002      	str	r0, [sp, #8]
    7106:	689d      	ldr	r5, [r3, #8]
    7108:	f8ad 000c 	strh.w	r0, [sp, #12]
    710c:	3501      	adds	r5, #1
	return memcmp(a, b, sizeof(*a));
    710e:	2206      	movs	r2, #6
    7110:	a902      	add	r1, sp, #8
    7112:	4628      	mov	r0, r5
    7114:	f013 ff61 	bl	1afda <memcmp>
    7118:	b918      	cbnz	r0, 7122 <bt_setup_public_id_addr+0x5a>
		net_buf_unref(rsp);
    711a:	980a      	ldr	r0, [sp, #40]	; 0x28
    711c:	f00f fa00 	bl	16520 <net_buf_unref>
    7120:	e7eb      	b.n	70fa <bt_setup_public_id_addr+0x32>
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
    7122:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    7126:	2206      	movs	r2, #6
    7128:	4669      	mov	r1, sp
    712a:	4628      	mov	r0, r5
    712c:	9300      	str	r3, [sp, #0]
    712e:	f8ad 3004 	strh.w	r3, [sp, #4]
    7132:	f013 ff52 	bl	1afda <memcmp>
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    7136:	2800      	cmp	r0, #0
    7138:	d0ef      	beq.n	711a <bt_setup_public_id_addr+0x52>
	bt_addr_copy(&addr->a, &rp->bdaddr);
    713a:	4629      	mov	r1, r5
    713c:	f10d 0011 	add.w	r0, sp, #17
    7140:	f014 f8a9 	bl	1b296 <bt_addr_copy>
	net_buf_unref(rsp);
    7144:	980a      	ldr	r0, [sp, #40]	; 0x28
	addr->type = BT_ADDR_LE_PUBLIC;
    7146:	f88d 4010 	strb.w	r4, [sp, #16]
	net_buf_unref(rsp);
    714a:	f00f f9e9 	bl	16520 <net_buf_unref>
	bt_dev.id_count = bt_read_public_addr(&addr);
    714e:	2301      	movs	r3, #1
	memset(ir, 0, 16);
    7150:	2210      	movs	r2, #16
    7152:	4621      	mov	r1, r4
    7154:	a80a      	add	r0, sp, #40	; 0x28
	bt_dev.id_count = bt_read_public_addr(&addr);
    7156:	71f3      	strb	r3, [r6, #7]
	memset(ir, 0, 16);
    7158:	f013 ff79 	bl	1b04e <memset>
	if (!(bt_dev.vs_commands[1] & BIT(1))) {
    715c:	f896 3062 	ldrb.w	r3, [r6, #98]	; 0x62
    7160:	079b      	lsls	r3, r3, #30
    7162:	d514      	bpl.n	718e <bt_setup_public_id_addr+0xc6>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_KEY_HIERARCHY_ROOTS, NULL,
    7164:	aa06      	add	r2, sp, #24
    7166:	4621      	mov	r1, r4
    7168:	f64f 400a 	movw	r0, #64522	; 0xfc0a
    716c:	f7fe ffd2 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
    7170:	b1e8      	cbz	r0, 71ae <bt_setup_public_id_addr+0xe6>
		BT_WARN("Failed to read identity root");
    7172:	2302      	movs	r3, #2
    7174:	f04f 0100 	mov.w	r1, #0
    7178:	f363 0107 	bfi	r1, r3, #0, #8
    717c:	4a13      	ldr	r2, [pc, #76]	; (71cc <bt_setup_public_id_addr+0x104>)
    717e:	4b14      	ldr	r3, [pc, #80]	; (71d0 <bt_setup_public_id_addr+0x108>)
    7180:	4815      	ldr	r0, [pc, #84]	; (71d8 <bt_setup_public_id_addr+0x110>)
    7182:	1a9b      	subs	r3, r3, r2
    7184:	08db      	lsrs	r3, r3, #3
    7186:	f363 118f 	bfi	r1, r3, #6, #10
    718a:	f013 fa42 	bl	1a612 <log_0>
	if (!bt_smp_irk_get(ir, ir_irk)) {
    718e:	a906      	add	r1, sp, #24
    7190:	a80a      	add	r0, sp, #40	; 0x28
    7192:	f015 fe0e 	bl	1cdb2 <bt_smp_irk_get>
    7196:	b1a8      	cbz	r0, 71c4 <bt_setup_public_id_addr+0xfc>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    7198:	f44f 3100 	mov.w	r1, #131072	; 0x20000
    719c:	480f      	ldr	r0, [pc, #60]	; (71dc <bt_setup_public_id_addr+0x114>)
    719e:	f014 f880 	bl	1b2a2 <atomic_or>
	u8_t *irk = NULL;
    71a2:	2200      	movs	r2, #0
	id_create(BT_ID_DEFAULT, &addr, irk);
    71a4:	a904      	add	r1, sp, #16
    71a6:	2000      	movs	r0, #0
    71a8:	f7ff fc68 	bl	6a7c <id_create>
    71ac:	e7a7      	b.n	70fe <bt_setup_public_id_addr+0x36>
	rp = (void *)rsp->data;
    71ae:	9b06      	ldr	r3, [sp, #24]
	memcpy(ir, rp->ir, 16);
    71b0:	6899      	ldr	r1, [r3, #8]
    71b2:	2210      	movs	r2, #16
    71b4:	3101      	adds	r1, #1
    71b6:	a80a      	add	r0, sp, #40	; 0x28
    71b8:	f013 ff1f 	bl	1affa <memcpy>
	net_buf_unref(rsp);
    71bc:	9806      	ldr	r0, [sp, #24]
    71be:	f00f f9af 	bl	16520 <net_buf_unref>
    71c2:	e7e4      	b.n	718e <bt_setup_public_id_addr+0xc6>
		irk = ir_irk;
    71c4:	aa06      	add	r2, sp, #24
    71c6:	e7ed      	b.n	71a4 <bt_setup_public_id_addr+0xdc>
    71c8:	20005438 	.word	0x20005438
    71cc:	0001ed28 	.word	0x0001ed28
    71d0:	0001ede8 	.word	0x0001ede8
    71d4:	000207dd 	.word	0x000207dd
    71d8:	000207fb 	.word	0x000207fb
    71dc:	200054a8 	.word	0x200054a8

000071e0 <bt_setup_random_id_addr>:
{
    71e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (!bt_dev.id_count) {
    71e4:	4c47      	ldr	r4, [pc, #284]	; (7304 <bt_setup_random_id_addr+0x124>)
    71e6:	79e7      	ldrb	r7, [r4, #7]
{
    71e8:	b08d      	sub	sp, #52	; 0x34
    71ea:	4626      	mov	r6, r4
	if (!bt_dev.id_count) {
    71ec:	b99f      	cbnz	r7, 7216 <bt_setup_random_id_addr+0x36>
	if (!(bt_dev.vs_commands[1] & BIT(0))) {
    71ee:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
    71f2:	f013 0501 	ands.w	r5, r3, #1
    71f6:	d118      	bne.n	722a <bt_setup_random_id_addr+0x4a>
		BT_WARN("Read Static Addresses command not available");
    71f8:	2302      	movs	r3, #2
    71fa:	f04f 0100 	mov.w	r1, #0
    71fe:	f363 0107 	bfi	r1, r3, #0, #8
    7202:	4a41      	ldr	r2, [pc, #260]	; (7308 <bt_setup_random_id_addr+0x128>)
    7204:	4b41      	ldr	r3, [pc, #260]	; (730c <bt_setup_random_id_addr+0x12c>)
    7206:	4842      	ldr	r0, [pc, #264]	; (7310 <bt_setup_random_id_addr+0x130>)
    7208:	1a9b      	subs	r3, r3, r2
    720a:	08db      	lsrs	r3, r3, #3
    720c:	f363 118f 	bfi	r1, r3, #6, #10
    7210:	f013 f9ff 	bl	1a612 <log_0>
		bt_dev.id_count = bt_read_static_addr(addrs);
    7214:	71e5      	strb	r5, [r4, #7]
    7216:	f44f 3100 	mov.w	r1, #131072	; 0x20000
    721a:	483e      	ldr	r0, [pc, #248]	; (7314 <bt_setup_random_id_addr+0x134>)
    721c:	f014 f841 	bl	1b2a2 <atomic_or>
	return bt_id_create(NULL, NULL);
    7220:	2100      	movs	r1, #0
    7222:	4608      	mov	r0, r1
    7224:	f7ff ff08 	bl	7038 <bt_id_create>
    7228:	e05e      	b.n	72e8 <bt_setup_random_id_addr+0x108>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_STATIC_ADDRS, NULL, &rsp);
    722a:	aa02      	add	r2, sp, #8
    722c:	4639      	mov	r1, r7
    722e:	f64f 4009 	movw	r0, #64521	; 0xfc09
    7232:	f7fe ff6f 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
    7236:	b178      	cbz	r0, 7258 <bt_setup_random_id_addr+0x78>
		BT_WARN("Failed to read static addresses");
    7238:	2302      	movs	r3, #2
    723a:	f04f 0100 	mov.w	r1, #0
    723e:	f363 0107 	bfi	r1, r3, #0, #8
    7242:	4a31      	ldr	r2, [pc, #196]	; (7308 <bt_setup_random_id_addr+0x128>)
    7244:	4b31      	ldr	r3, [pc, #196]	; (730c <bt_setup_random_id_addr+0x12c>)
    7246:	4834      	ldr	r0, [pc, #208]	; (7318 <bt_setup_random_id_addr+0x138>)
    7248:	1a9b      	subs	r3, r3, r2
    724a:	08db      	lsrs	r3, r3, #3
    724c:	f363 118f 	bfi	r1, r3, #6, #10
    7250:	f013 f9df 	bl	1a612 <log_0>
		bt_dev.id_count = bt_read_static_addr(addrs);
    7254:	71e7      	strb	r7, [r4, #7]
		if (bt_dev.id_count) {
    7256:	e7de      	b.n	7216 <bt_setup_random_id_addr+0x36>
	rp = (void *)rsp->data;
    7258:	9b02      	ldr	r3, [sp, #8]
    725a:	689c      	ldr	r4, [r3, #8]
	cnt = MIN(rp->num_addrs, CONFIG_BT_ID_MAX);
    725c:	7865      	ldrb	r5, [r4, #1]
    725e:	1c2f      	adds	r7, r5, #0
    7260:	bf18      	it	ne
    7262:	2701      	movne	r7, #1
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
    7264:	3402      	adds	r4, #2
	for (i = 0; i < cnt; i++) {
    7266:	4287      	cmp	r7, r0
    7268:	dc41      	bgt.n	72ee <bt_setup_random_id_addr+0x10e>
	net_buf_unref(rsp);
    726a:	9802      	ldr	r0, [sp, #8]
    726c:	f00f f958 	bl	16520 <net_buf_unref>
	if (!cnt) {
    7270:	b96d      	cbnz	r5, 728e <bt_setup_random_id_addr+0xae>
		BT_WARN("No static addresses stored in controller");
    7272:	2302      	movs	r3, #2
    7274:	f04f 0100 	mov.w	r1, #0
    7278:	f363 0107 	bfi	r1, r3, #0, #8
    727c:	4a22      	ldr	r2, [pc, #136]	; (7308 <bt_setup_random_id_addr+0x128>)
    727e:	4b23      	ldr	r3, [pc, #140]	; (730c <bt_setup_random_id_addr+0x12c>)
    7280:	4826      	ldr	r0, [pc, #152]	; (731c <bt_setup_random_id_addr+0x13c>)
    7282:	1a9b      	subs	r3, r3, r2
    7284:	08db      	lsrs	r3, r3, #3
    7286:	f363 118f 	bfi	r1, r3, #6, #10
    728a:	f013 f9c2 	bl	1a612 <log_0>
		bt_dev.id_count = bt_read_static_addr(addrs);
    728e:	71f7      	strb	r7, [r6, #7]
		if (bt_dev.id_count) {
    7290:	2d00      	cmp	r5, #0
    7292:	d0c0      	beq.n	7216 <bt_setup_random_id_addr+0x36>
    7294:	f8df 907c 	ldr.w	r9, [pc, #124]	; 7314 <bt_setup_random_id_addr+0x134>
    7298:	2400      	movs	r4, #0
    729a:	b2e7      	uxtb	r7, r4
				if (!bt_smp_irk_get(addrs[i].ir, ir_irk)) {
    729c:	2516      	movs	r5, #22
    729e:	437d      	muls	r5, r7
    72a0:	1da8      	adds	r0, r5, #6
    72a2:	ab06      	add	r3, sp, #24
    72a4:	a902      	add	r1, sp, #8
    72a6:	4418      	add	r0, r3
    72a8:	f015 fd83 	bl	1cdb2 <bt_smp_irk_get>
    72ac:	b330      	cbz	r0, 72fc <bt_setup_random_id_addr+0x11c>
    72ae:	f44f 3100 	mov.w	r1, #131072	; 0x20000
    72b2:	4648      	mov	r0, r9
    72b4:	f013 fff5 	bl	1b2a2 <atomic_or>
				u8_t *irk = NULL;
    72b8:	f04f 0800 	mov.w	r8, #0
				bt_addr_copy(&addr.a, &addrs[i].bdaddr);
    72bc:	ab06      	add	r3, sp, #24
    72be:	1959      	adds	r1, r3, r5
    72c0:	f10d 0001 	add.w	r0, sp, #1
    72c4:	f013 ffe7 	bl	1b296 <bt_addr_copy>
				addr.type = BT_ADDR_LE_RANDOM;
    72c8:	2301      	movs	r3, #1
				id_create(i, &addr, irk);
    72ca:	4642      	mov	r2, r8
    72cc:	4669      	mov	r1, sp
    72ce:	4638      	mov	r0, r7
				addr.type = BT_ADDR_LE_RANDOM;
    72d0:	f88d 3000 	strb.w	r3, [sp]
				id_create(i, &addr, irk);
    72d4:	3401      	adds	r4, #1
    72d6:	f7ff fbd1 	bl	6a7c <id_create>
			for (u8_t i = 0; i < bt_dev.id_count; i++) {
    72da:	79f2      	ldrb	r2, [r6, #7]
    72dc:	b2e3      	uxtb	r3, r4
    72de:	429a      	cmp	r2, r3
    72e0:	d8db      	bhi.n	729a <bt_setup_random_id_addr+0xba>
			return set_random_address(&bt_dev.id_addr[0].a);
    72e2:	480f      	ldr	r0, [pc, #60]	; (7320 <bt_setup_random_id_addr+0x140>)
    72e4:	f7fe ff8c 	bl	6200 <set_random_address>
}
    72e8:	b00d      	add	sp, #52	; 0x34
    72ea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
    72ee:	2216      	movs	r2, #22
    72f0:	4621      	mov	r1, r4
    72f2:	a806      	add	r0, sp, #24
    72f4:	f013 fe81 	bl	1affa <memcpy>
	for (i = 0; i < cnt; i++) {
    72f8:	2001      	movs	r0, #1
    72fa:	e7b4      	b.n	7266 <bt_setup_random_id_addr+0x86>
					irk = ir_irk;
    72fc:	f10d 0808 	add.w	r8, sp, #8
    7300:	e7dc      	b.n	72bc <bt_setup_random_id_addr+0xdc>
    7302:	bf00      	nop
    7304:	20005438 	.word	0x20005438
    7308:	0001ed28 	.word	0x0001ed28
    730c:	0001ede8 	.word	0x0001ede8
    7310:	00020818 	.word	0x00020818
    7314:	200054a8 	.word	0x200054a8
    7318:	00020844 	.word	0x00020844
    731c:	00020864 	.word	0x00020864
    7320:	20005439 	.word	0x20005439

00007324 <bt_le_adv_start_internal>:

int bt_le_adv_start_internal(const struct bt_le_adv_param *param,
			     const struct bt_data *ad, size_t ad_len,
			     const struct bt_data *sd, size_t sd_len,
			     const bt_addr_le_t *peer)
{
    7324:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct bt_conn *conn = NULL;
	struct net_buf *buf;
	bool dir_adv = (peer != NULL);
	int err = 0;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    7328:	4ea7      	ldr	r6, [pc, #668]	; (75c8 <bt_le_adv_start_internal+0x2a4>)
{
    732a:	b08d      	sub	sp, #52	; 0x34
    732c:	4605      	mov	r5, r0
    732e:	9102      	str	r1, [sp, #8]
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    7330:	f106 0070 	add.w	r0, r6, #112	; 0x70
    7334:	2101      	movs	r1, #1
{
    7336:	4693      	mov	fp, r2
    7338:	4699      	mov	r9, r3
    733a:	f8dd 805c 	ldr.w	r8, [sp, #92]	; 0x5c
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    733e:	f014 f800 	bl	1b342 <atomic_test_bit>
    7342:	2800      	cmp	r0, #0
    7344:	f000 8133 	beq.w	75ae <bt_le_adv_start_internal+0x28a>
	if (param->id >= bt_dev.id_count ||
    7348:	7828      	ldrb	r0, [r5, #0]
    734a:	79f3      	ldrb	r3, [r6, #7]
    734c:	4283      	cmp	r3, r0
    734e:	d805      	bhi.n	735c <bt_le_adv_start_internal+0x38>
		return -EAGAIN;
	}

	if (!valid_adv_param(param, dir_adv)) {
		return -EINVAL;
    7350:	f06f 0415 	mvn.w	r4, #21

	atomic_set_bit_to(bt_dev.flags, BT_DEV_ADVERTISING_CONNECTABLE,
			  param->options & BT_LE_ADV_OPT_CONNECTABLE);

	return 0;
}
    7354:	4620      	mov	r0, r4
    7356:	b00d      	add	sp, #52	; 0x34
    7358:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    !bt_addr_le_cmp(&bt_dev.id_addr[param->id], BT_ADDR_LE_ANY)) {
    735c:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    7360:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
    7362:	2207      	movs	r2, #7
    7364:	a906      	add	r1, sp, #24
    7366:	4430      	add	r0, r6
    7368:	9306      	str	r3, [sp, #24]
    736a:	f8cd 301b 	str.w	r3, [sp, #27]
    736e:	f013 fe34 	bl	1afda <memcmp>
	if (param->id >= bt_dev.id_count ||
    7372:	2800      	cmp	r0, #0
    7374:	d0ec      	beq.n	7350 <bt_le_adv_start_internal+0x2c>
	if (!(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    7376:	786b      	ldrb	r3, [r5, #1]
    7378:	07d8      	lsls	r0, r3, #31
    737a:	d405      	bmi.n	7388 <bt_le_adv_start_internal+0x64>
		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
    737c:	7c32      	ldrb	r2, [r6, #16]
    737e:	2a08      	cmp	r2, #8
    7380:	d802      	bhi.n	7388 <bt_le_adv_start_internal+0x64>
    7382:	886a      	ldrh	r2, [r5, #2]
    7384:	2a9f      	cmp	r2, #159	; 0x9f
    7386:	d9e3      	bls.n	7350 <bt_le_adv_start_internal+0x2c>
	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) || !dir_adv) {
    7388:	06d9      	lsls	r1, r3, #27
    738a:	d402      	bmi.n	7392 <bt_le_adv_start_internal+0x6e>
    738c:	f1b8 0f00 	cmp.w	r8, #0
    7390:	d108      	bne.n	73a4 <bt_le_adv_start_internal+0x80>
		if (param->interval_min > param->interval_max ||
    7392:	886a      	ldrh	r2, [r5, #2]
    7394:	88ab      	ldrh	r3, [r5, #4]
    7396:	429a      	cmp	r2, r3
    7398:	d8da      	bhi.n	7350 <bt_le_adv_start_internal+0x2c>
    739a:	2a1f      	cmp	r2, #31
    739c:	d9d8      	bls.n	7350 <bt_le_adv_start_internal+0x2c>
		    param->interval_min < 0x0020 ||
    739e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    73a2:	d8d5      	bhi.n	7350 <bt_le_adv_start_internal+0x2c>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING)) {
    73a4:	2105      	movs	r1, #5
    73a6:	4889      	ldr	r0, [pc, #548]	; (75cc <bt_le_adv_start_internal+0x2a8>)
    73a8:	f013 ffcb 	bl	1b342 <atomic_test_bit>
    73ac:	4601      	mov	r1, r0
    73ae:	2800      	cmp	r0, #0
    73b0:	f040 8100 	bne.w	75b4 <bt_le_adv_start_internal+0x290>
	(void)memset(&set_param, 0, sizeof(set_param));
    73b4:	220f      	movs	r2, #15
    73b6:	a808      	add	r0, sp, #32
    73b8:	f013 fe49 	bl	1b04e <memset>
	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
    73bc:	886b      	ldrh	r3, [r5, #2]
    73be:	f8ad 3020 	strh.w	r3, [sp, #32]
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
    73c2:	88ab      	ldrh	r3, [r5, #4]
    73c4:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
	set_param.channel_map  = 0x07;
    73c8:	2307      	movs	r3, #7
    73ca:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
	if (bt_dev.adv_id != param->id) {
    73ce:	7a32      	ldrb	r2, [r6, #8]
    73d0:	782b      	ldrb	r3, [r5, #0]
    73d2:	429a      	cmp	r2, r3
    73d4:	d004      	beq.n	73e0 <bt_le_adv_start_internal+0xbc>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    73d6:	f46f 4100 	mvn.w	r1, #32768	; 0x8000
    73da:	487c      	ldr	r0, [pc, #496]	; (75cc <bt_le_adv_start_internal+0x2a8>)
    73dc:	f013 ff4c 	bl	1b278 <atomic_and>
	bt_dev.adv_id = param->id;
    73e0:	782f      	ldrb	r7, [r5, #0]
    73e2:	7237      	strb	r7, [r6, #8]
		set_param.filter_policy = BT_LE_ADV_FP_NO_WHITELIST;
    73e4:	2300      	movs	r3, #0
    73e6:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
    73ea:	786b      	ldrb	r3, [r5, #1]
    73ec:	f013 0a01 	ands.w	sl, r3, #1
    73f0:	f003 0204 	and.w	r2, r3, #4
    73f4:	d071      	beq.n	74da <bt_le_adv_start_internal+0x1b6>
		if (IS_ENABLED(CONFIG_BT_PRIVACY) &&
    73f6:	2a00      	cmp	r2, #0
    73f8:	d158      	bne.n	74ac <bt_le_adv_start_internal+0x188>
			err = le_set_private_addr(param->id);
    73fa:	4638      	mov	r0, r7
    73fc:	f7fe ff2c 	bl	6258 <le_set_private_addr>
			if (err) {
    7400:	4604      	mov	r4, r0
    7402:	2800      	cmp	r0, #0
    7404:	d1a6      	bne.n	7354 <bt_le_adv_start_internal+0x30>
			if (BT_FEAT_LE_PRIVACY(bt_dev.le.features)) {
    7406:	f896 2078 	ldrb.w	r2, [r6, #120]	; 0x78
    740a:	0652      	lsls	r2, r2, #25
				set_param.own_addr_type =
    740c:	bf4c      	ite	mi
    740e:	2203      	movmi	r2, #3
				set_param.own_addr_type = BT_ADDR_LE_RANDOM;
    7410:	2201      	movpl	r2, #1
    7412:	f88d 2025 	strb.w	r2, [sp, #37]	; 0x25
		if (dir_adv) {
    7416:	f1b8 0f00 	cmp.w	r8, #0
    741a:	d05b      	beq.n	74d4 <bt_le_adv_start_internal+0x1b0>
			if (param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) {
    741c:	786a      	ldrb	r2, [r5, #1]
				set_param.type = BT_LE_ADV_DIRECT_IND_LOW_DUTY;
    741e:	f012 0f10 	tst.w	r2, #16
    7422:	bf18      	it	ne
    7424:	f04f 0a04 	movne.w	sl, #4
			bt_addr_le_copy(&set_param.direct_addr, peer);
    7428:	4641      	mov	r1, r8
    742a:	f10d 0026 	add.w	r0, sp, #38	; 0x26
    742e:	f88d a024 	strb.w	sl, [sp, #36]	; 0x24
    7432:	f013 ff33 	bl	1b29c <bt_addr_le_copy>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_PARAM, sizeof(set_param));
    7436:	210f      	movs	r1, #15
    7438:	f242 0006 	movw	r0, #8198	; 0x2006
    743c:	f7fe fcfc 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
    7440:	4604      	mov	r4, r0
    7442:	2800      	cmp	r0, #0
    7444:	f000 80b9 	beq.w	75ba <bt_le_adv_start_internal+0x296>
	net_buf_add_mem(buf, &set_param, sizeof(set_param));
    7448:	220f      	movs	r2, #15
    744a:	a908      	add	r1, sp, #32
    744c:	3008      	adds	r0, #8
    744e:	f016 fc03 	bl	1dc58 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_PARAM, buf, NULL);
    7452:	4621      	mov	r1, r4
    7454:	2200      	movs	r2, #0
    7456:	f242 0006 	movw	r0, #8198	; 0x2006
    745a:	f7fe fe5b 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
    745e:	4604      	mov	r4, r0
    7460:	2800      	cmp	r0, #0
    7462:	f47f af77 	bne.w	7354 <bt_le_adv_start_internal+0x30>
	if (!dir_adv) {
    7466:	f1b8 0f00 	cmp.w	r8, #0
    746a:	d05d      	beq.n	7528 <bt_le_adv_start_internal+0x204>
	struct bt_conn *conn = NULL;
    746c:	2600      	movs	r6, #0
	err = set_advertise_enable(true);
    746e:	2001      	movs	r0, #1
    7470:	f7fe fe96 	bl	61a0 <set_advertise_enable>
	if (err) {
    7474:	4604      	mov	r4, r0
    7476:	2800      	cmp	r0, #0
    7478:	d07d      	beq.n	7576 <bt_le_adv_start_internal+0x252>
		BT_ERR("Failed to start advertiser");
    747a:	2301      	movs	r3, #1
    747c:	f04f 0100 	mov.w	r1, #0
    7480:	f363 0107 	bfi	r1, r3, #0, #8
    7484:	4a52      	ldr	r2, [pc, #328]	; (75d0 <bt_le_adv_start_internal+0x2ac>)
    7486:	4b53      	ldr	r3, [pc, #332]	; (75d4 <bt_le_adv_start_internal+0x2b0>)
    7488:	4853      	ldr	r0, [pc, #332]	; (75d8 <bt_le_adv_start_internal+0x2b4>)
    748a:	1a9b      	subs	r3, r3, r2
    748c:	08db      	lsrs	r3, r3, #3
    748e:	f363 118f 	bfi	r1, r3, #6, #10
    7492:	f013 f8be 	bl	1a612 <log_0>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
    7496:	2e00      	cmp	r6, #0
    7498:	f43f af5c 	beq.w	7354 <bt_le_adv_start_internal+0x30>
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    749c:	4630      	mov	r0, r6
    749e:	2100      	movs	r1, #0
    74a0:	f000 fe88 	bl	81b4 <bt_conn_set_state>
			bt_conn_unref(conn);
    74a4:	4630      	mov	r0, r6
    74a6:	f014 f88a 	bl	1b5be <bt_conn_unref>
    74aa:	e753      	b.n	7354 <bt_le_adv_start_internal+0x30>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    74ac:	00fa      	lsls	r2, r7, #3
    74ae:	1bd1      	subs	r1, r2, r7
    74b0:	5c71      	ldrb	r1, [r6, r1]
    74b2:	2901      	cmp	r1, #1
    74b4:	d002      	beq.n	74bc <bt_le_adv_start_internal+0x198>
			set_param.own_addr_type = id_addr->type;
    74b6:	1bd7      	subs	r7, r2, r7
    74b8:	5df2      	ldrb	r2, [r6, r7]
    74ba:	e7aa      	b.n	7412 <bt_le_adv_start_internal+0xee>
				err = set_random_address(&id_addr->a);
    74bc:	2007      	movs	r0, #7
    74be:	fb10 1007 	smlabb	r0, r0, r7, r1
    74c2:	4430      	add	r0, r6
    74c4:	9203      	str	r2, [sp, #12]
    74c6:	f7fe fe9b 	bl	6200 <set_random_address>
				if (err) {
    74ca:	9a03      	ldr	r2, [sp, #12]
    74cc:	4604      	mov	r4, r0
    74ce:	2800      	cmp	r0, #0
    74d0:	d0f1      	beq.n	74b6 <bt_le_adv_start_internal+0x192>
    74d2:	e73f      	b.n	7354 <bt_le_adv_start_internal+0x30>
			set_param.type = BT_LE_ADV_IND;
    74d4:	f88d 8024 	strb.w	r8, [sp, #36]	; 0x24
    74d8:	e7ad      	b.n	7436 <bt_le_adv_start_internal+0x112>
		if (param->options & BT_LE_ADV_OPT_USE_IDENTITY) {
    74da:	b1ea      	cbz	r2, 7518 <bt_le_adv_start_internal+0x1f4>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    74dc:	00fa      	lsls	r2, r7, #3
    74de:	1bd1      	subs	r1, r2, r7
    74e0:	5c71      	ldrb	r1, [r6, r1]
    74e2:	2901      	cmp	r1, #1
    74e4:	d116      	bne.n	7514 <bt_le_adv_start_internal+0x1f0>
				err = set_random_address(&id_addr->a);
    74e6:	2007      	movs	r0, #7
    74e8:	fb10 1007 	smlabb	r0, r0, r7, r1
    74ec:	4430      	add	r0, r6
    74ee:	9203      	str	r2, [sp, #12]
    74f0:	f7fe fe86 	bl	6200 <set_random_address>
    74f4:	9a03      	ldr	r2, [sp, #12]
    74f6:	4604      	mov	r4, r0
			set_param.own_addr_type = id_addr->type;
    74f8:	1bd7      	subs	r7, r2, r7
    74fa:	5df3      	ldrb	r3, [r6, r7]
			set_param.own_addr_type = BT_ADDR_LE_RANDOM;
    74fc:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
		if (err) {
    7500:	2c00      	cmp	r4, #0
    7502:	f47f af27 	bne.w	7354 <bt_le_adv_start_internal+0x30>
		if (sd) {
    7506:	f1b9 0f00 	cmp.w	r9, #0
    750a:	d00b      	beq.n	7524 <bt_le_adv_start_internal+0x200>
			set_param.type = BT_LE_ADV_SCAN_IND;
    750c:	2302      	movs	r3, #2
			set_param.type = BT_LE_ADV_NONCONN_IND;
    750e:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    7512:	e790      	b.n	7436 <bt_le_adv_start_internal+0x112>
	int err = 0;
    7514:	4654      	mov	r4, sl
    7516:	e7ef      	b.n	74f8 <bt_le_adv_start_internal+0x1d4>
			err = le_set_private_addr(param->id);
    7518:	4638      	mov	r0, r7
    751a:	f7fe fe9d 	bl	6258 <le_set_private_addr>
			set_param.own_addr_type = BT_ADDR_LE_RANDOM;
    751e:	2301      	movs	r3, #1
			err = le_set_private_addr(param->id);
    7520:	4604      	mov	r4, r0
			set_param.own_addr_type = BT_ADDR_LE_RANDOM;
    7522:	e7eb      	b.n	74fc <bt_le_adv_start_internal+0x1d8>
			set_param.type = BT_LE_ADV_NONCONN_IND;
    7524:	2303      	movs	r3, #3
    7526:	e7f2      	b.n	750e <bt_le_adv_start_internal+0x1ea>
				    param->options & BT_LE_ADV_OPT_CONNECTABLE,
    7528:	786b      	ldrb	r3, [r5, #1]
		err = le_adv_update(ad, ad_len, sd, sd_len,
    752a:	9802      	ldr	r0, [sp, #8]
    752c:	f3c3 02c0 	ubfx	r2, r3, #3, #1
    7530:	f003 0301 	and.w	r3, r3, #1
    7534:	9201      	str	r2, [sp, #4]
    7536:	9300      	str	r3, [sp, #0]
    7538:	464a      	mov	r2, r9
    753a:	9b16      	ldr	r3, [sp, #88]	; 0x58
    753c:	4659      	mov	r1, fp
    753e:	f7fe ff87 	bl	6450 <le_adv_update>
		if (err) {
    7542:	4604      	mov	r4, r0
    7544:	2800      	cmp	r0, #0
    7546:	f47f af05 	bne.w	7354 <bt_le_adv_start_internal+0x30>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    754a:	786b      	ldrb	r3, [r5, #1]
    754c:	07db      	lsls	r3, r3, #31
    754e:	d58d      	bpl.n	746c <bt_le_adv_start_internal+0x148>
			conn = bt_conn_add_le(param->id, BT_ADDR_LE_NONE);
    7550:	f06f 03ff 	mvn.w	r3, #255	; 0xff
    7554:	9304      	str	r3, [sp, #16]
    7556:	a904      	add	r1, sp, #16
    7558:	f64f 73ff 	movw	r3, #65535	; 0xffff
    755c:	7828      	ldrb	r0, [r5, #0]
    755e:	f8ad 3014 	strh.w	r3, [sp, #20]
    7562:	f88d 3016 	strb.w	r3, [sp, #22]
    7566:	f000 fde5 	bl	8134 <bt_conn_add_le>
			if (!conn) {
    756a:	4606      	mov	r6, r0
    756c:	b340      	cbz	r0, 75c0 <bt_le_adv_start_internal+0x29c>
			bt_conn_set_state(conn, BT_CONN_CONNECT_ADV);
    756e:	2103      	movs	r1, #3
    7570:	f000 fe20 	bl	81b4 <bt_conn_set_state>
    7574:	e77b      	b.n	746e <bt_le_adv_start_internal+0x14a>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
    7576:	b116      	cbz	r6, 757e <bt_le_adv_start_internal+0x25a>
		bt_conn_unref(conn);
    7578:	4630      	mov	r0, r6
    757a:	f014 f820 	bl	1b5be <bt_conn_unref>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_KEEP_ADVERTISING,
    757e:	786a      	ldrb	r2, [r5, #1]
    7580:	4812      	ldr	r0, [pc, #72]	; (75cc <bt_le_adv_start_internal+0x2a8>)
    7582:	f082 0202 	eor.w	r2, r2, #2
    7586:	f3c2 0240 	ubfx	r2, r2, #1, #1
    758a:	2108      	movs	r1, #8
    758c:	f013 fe98 	bl	1b2c0 <atomic_set_bit_to>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_ADVERTISING_NAME,
    7590:	786a      	ldrb	r2, [r5, #1]
    7592:	480e      	ldr	r0, [pc, #56]	; (75cc <bt_le_adv_start_internal+0x2a8>)
    7594:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    7598:	2106      	movs	r1, #6
    759a:	f013 fe91 	bl	1b2c0 <atomic_set_bit_to>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_ADVERTISING_CONNECTABLE,
    759e:	786a      	ldrb	r2, [r5, #1]
    75a0:	480a      	ldr	r0, [pc, #40]	; (75cc <bt_le_adv_start_internal+0x2a8>)
    75a2:	f002 0201 	and.w	r2, r2, #1
    75a6:	2107      	movs	r1, #7
    75a8:	f013 fe8a 	bl	1b2c0 <atomic_set_bit_to>
	return 0;
    75ac:	e6d2      	b.n	7354 <bt_le_adv_start_internal+0x30>
		return -EAGAIN;
    75ae:	f06f 040a 	mvn.w	r4, #10
    75b2:	e6cf      	b.n	7354 <bt_le_adv_start_internal+0x30>
		return -EALREADY;
    75b4:	f06f 0444 	mvn.w	r4, #68	; 0x44
    75b8:	e6cc      	b.n	7354 <bt_le_adv_start_internal+0x30>
		return -ENOBUFS;
    75ba:	f06f 0436 	mvn.w	r4, #54	; 0x36
    75be:	e6c9      	b.n	7354 <bt_le_adv_start_internal+0x30>
				return -ENOMEM;
    75c0:	f06f 040b 	mvn.w	r4, #11
    75c4:	e6c6      	b.n	7354 <bt_le_adv_start_internal+0x30>
    75c6:	bf00      	nop
    75c8:	20005438 	.word	0x20005438
    75cc:	200054a8 	.word	0x200054a8
    75d0:	0001ed28 	.word	0x0001ed28
    75d4:	0001ede8 	.word	0x0001ede8
    75d8:	000206a8 	.word	0x000206a8

000075dc <bt_le_adv_stop>:

	return bt_le_adv_start_internal(param, ad, ad_len, sd, sd_len, NULL);
}

int bt_le_adv_stop(void)
{
    75dc:	b513      	push	{r0, r1, r4, lr}
    75de:	f46f 7180 	mvn.w	r1, #256	; 0x100
    75e2:	4817      	ldr	r0, [pc, #92]	; (7640 <bt_le_adv_stop+0x64>)
    75e4:	f013 fe48 	bl	1b278 <atomic_and>
	/* Make sure advertising is not re-enabled later even if it's not
	 * currently enabled (i.e. BT_DEV_ADVERTISING is not set).
	 */
	atomic_clear_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING);

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING)) {
    75e8:	2105      	movs	r1, #5
    75ea:	4815      	ldr	r0, [pc, #84]	; (7640 <bt_le_adv_stop+0x64>)
    75ec:	f013 fea9 	bl	1b342 <atomic_test_bit>
    75f0:	b318      	cbz	r0, 763a <bt_le_adv_stop+0x5e>
	}

	if (IS_ENABLED(CONFIG_BT_PERIPHERAL)) {
		struct bt_conn *conn;

		conn = bt_conn_lookup_state_le(BT_ADDR_LE_NONE,
    75f2:	4b14      	ldr	r3, [pc, #80]	; (7644 <bt_le_adv_stop+0x68>)
    75f4:	6818      	ldr	r0, [r3, #0]
    75f6:	889a      	ldrh	r2, [r3, #4]
    75f8:	9000      	str	r0, [sp, #0]
    75fa:	799b      	ldrb	r3, [r3, #6]
    75fc:	f8ad 2004 	strh.w	r2, [sp, #4]
    7600:	2103      	movs	r1, #3
    7602:	4668      	mov	r0, sp
    7604:	f88d 3006 	strb.w	r3, [sp, #6]
    7608:	f000 fed6 	bl	83b8 <bt_conn_lookup_state_le>
					       BT_CONN_CONNECT_ADV);
		if (conn) {
    760c:	4604      	mov	r4, r0
    760e:	b128      	cbz	r0, 761c <bt_le_adv_stop+0x40>
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    7610:	2100      	movs	r1, #0
    7612:	f000 fdcf 	bl	81b4 <bt_conn_set_state>
			bt_conn_unref(conn);
    7616:	4620      	mov	r0, r4
    7618:	f013 ffd1 	bl	1b5be <bt_conn_unref>
		}

		conn = bt_conn_lookup_state_le(NULL, BT_CONN_CONNECT_DIR_ADV);
    761c:	2104      	movs	r1, #4
    761e:	2000      	movs	r0, #0
    7620:	f000 feca 	bl	83b8 <bt_conn_lookup_state_le>
		if (conn) {
    7624:	4604      	mov	r4, r0
    7626:	b128      	cbz	r0, 7634 <bt_le_adv_stop+0x58>
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    7628:	2100      	movs	r1, #0
    762a:	f000 fdc3 	bl	81b4 <bt_conn_set_state>
			bt_conn_unref(conn);
    762e:	4620      	mov	r0, r4
    7630:	f013 ffc5 	bl	1b5be <bt_conn_unref>
		}
	}

	err = set_advertise_enable(false);
    7634:	2000      	movs	r0, #0
    7636:	f7fe fdb3 	bl	61a0 <set_advertise_enable>
			le_set_private_addr(bt_dev.adv_id);
		}
	}

	return 0;
}
    763a:	b002      	add	sp, #8
    763c:	bd10      	pop	{r4, pc}
    763e:	bf00      	nop
    7640:	200054a8 	.word	0x200054a8
    7644:	0001eed0 	.word	0x0001eed0

00007648 <bt_le_adv_resume>:

#if defined(CONFIG_BT_PERIPHERAL)
void bt_le_adv_resume(void)
{
    7648:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct bt_conn *adv_conn;
	int err;

	BT_ASSERT(atomic_test_bit(bt_dev.flags,
    764a:	2107      	movs	r1, #7
    764c:	4819      	ldr	r0, [pc, #100]	; (76b4 <bt_le_adv_resume+0x6c>)
    764e:	f013 fe78 	bl	1b342 <atomic_test_bit>
    7652:	b960      	cbnz	r0, 766e <bt_le_adv_resume+0x26>
    7654:	f241 73a4 	movw	r3, #6052	; 0x17a4
    7658:	4a17      	ldr	r2, [pc, #92]	; (76b8 <bt_le_adv_resume+0x70>)
    765a:	4918      	ldr	r1, [pc, #96]	; (76bc <bt_le_adv_resume+0x74>)
    765c:	4818      	ldr	r0, [pc, #96]	; (76c0 <bt_le_adv_resume+0x78>)
    765e:	f011 fe89 	bl	19374 <printk>
    7662:	4040      	eors	r0, r0
    7664:	f380 8811 	msr	BASEPRI, r0
    7668:	f04f 0003 	mov.w	r0, #3
    766c:	df02      	svc	2
				  BT_DEV_ADVERTISING_CONNECTABLE));

	adv_conn = bt_conn_add_le(bt_dev.adv_id, BT_ADDR_LE_NONE);
    766e:	4b15      	ldr	r3, [pc, #84]	; (76c4 <bt_le_adv_resume+0x7c>)
    7670:	4d15      	ldr	r5, [pc, #84]	; (76c8 <bt_le_adv_resume+0x80>)
    7672:	6818      	ldr	r0, [r3, #0]
    7674:	889a      	ldrh	r2, [r3, #4]
    7676:	9000      	str	r0, [sp, #0]
    7678:	799b      	ldrb	r3, [r3, #6]
    767a:	7a28      	ldrb	r0, [r5, #8]
    767c:	f8ad 2004 	strh.w	r2, [sp, #4]
    7680:	4669      	mov	r1, sp
    7682:	f88d 3006 	strb.w	r3, [sp, #6]
    7686:	f000 fd55 	bl	8134 <bt_conn_add_le>
	if (!adv_conn) {
    768a:	4604      	mov	r4, r0
    768c:	b180      	cbz	r0, 76b0 <bt_le_adv_resume+0x68>
		return;
	}

	bt_conn_set_state(adv_conn, BT_CONN_CONNECT_ADV);
    768e:	2103      	movs	r1, #3
    7690:	f000 fd90 	bl	81b4 <bt_conn_set_state>

	if (IS_ENABLED(CONFIG_BT_PRIVACY)) {
		le_set_private_addr(bt_dev.adv_id);
    7694:	7a28      	ldrb	r0, [r5, #8]
    7696:	f7fe fddf 	bl	6258 <le_set_private_addr>
	}

	err = set_advertise_enable(true);
    769a:	2001      	movs	r0, #1
    769c:	f7fe fd80 	bl	61a0 <set_advertise_enable>
	if (err) {
    76a0:	b118      	cbz	r0, 76aa <bt_le_adv_resume+0x62>
		bt_conn_set_state(adv_conn, BT_CONN_DISCONNECTED);
    76a2:	2100      	movs	r1, #0
    76a4:	4620      	mov	r0, r4
    76a6:	f000 fd85 	bl	81b4 <bt_conn_set_state>
	}

	/* Since we don't give the application a reference to manage in
	 * this case, we need to release this reference here.
	 */
	bt_conn_unref(adv_conn);
    76aa:	4620      	mov	r0, r4
    76ac:	f013 ff87 	bl	1b5be <bt_conn_unref>
}
    76b0:	b003      	add	sp, #12
    76b2:	bd30      	pop	{r4, r5, pc}
    76b4:	200054a8 	.word	0x200054a8
    76b8:	00020a6e 	.word	0x00020a6e
    76bc:	0002066a 	.word	0x0002066a
    76c0:	00020aa4 	.word	0x00020aa4
    76c4:	0001eed0 	.word	0x0001eed0
    76c8:	20005438 	.word	0x20005438

000076cc <hci_disconn_complete>:
{
    76cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
    76ce:	6886      	ldr	r6, [r0, #8]
	if (evt->status) {
    76d0:	7835      	ldrb	r5, [r6, #0]
    76d2:	bba5      	cbnz	r5, 773e <hci_disconn_complete+0x72>
	u16_t handle = sys_le16_to_cpu(evt->handle);
    76d4:	f8b6 7001 	ldrh.w	r7, [r6, #1]
	conn = bt_conn_lookup_handle(handle);
    76d8:	4638      	mov	r0, r7
    76da:	f000 fe35 	bl	8348 <bt_conn_lookup_handle>
	if (!conn) {
    76de:	4604      	mov	r4, r0
    76e0:	b9e0      	cbnz	r0, 771c <hci_disconn_complete+0x50>
		BT_ERR("Unable to look up conn with handle %u", handle);
    76e2:	2301      	movs	r3, #1
    76e4:	f04f 0200 	mov.w	r2, #0
    76e8:	f363 0207 	bfi	r2, r3, #0, #8
    76ec:	4914      	ldr	r1, [pc, #80]	; (7740 <hci_disconn_complete+0x74>)
    76ee:	4b15      	ldr	r3, [pc, #84]	; (7744 <hci_disconn_complete+0x78>)
    76f0:	4815      	ldr	r0, [pc, #84]	; (7748 <hci_disconn_complete+0x7c>)
    76f2:	1a5b      	subs	r3, r3, r1
    76f4:	08db      	lsrs	r3, r3, #3
    76f6:	f363 128f 	bfi	r2, r3, #6, #10
    76fa:	4639      	mov	r1, r7
    76fc:	f012 ff96 	bl	1a62c <log_1>
	    atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    7700:	2108      	movs	r1, #8
    7702:	4812      	ldr	r0, [pc, #72]	; (774c <hci_disconn_complete+0x80>)
    7704:	f013 fe1d 	bl	1b342 <atomic_test_bit>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    7708:	b1c8      	cbz	r0, 773e <hci_disconn_complete+0x72>
	    !atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING)) {
    770a:	2105      	movs	r1, #5
    770c:	480f      	ldr	r0, [pc, #60]	; (774c <hci_disconn_complete+0x80>)
    770e:	f013 fe18 	bl	1b342 <atomic_test_bit>
	    atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    7712:	b9a0      	cbnz	r0, 773e <hci_disconn_complete+0x72>
}
    7714:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		bt_le_adv_resume();
    7718:	f7ff bf96 	b.w	7648 <bt_le_adv_resume>
	conn->err = evt->reason;
    771c:	78f3      	ldrb	r3, [r6, #3]
    771e:	7303      	strb	r3, [r0, #12]
	bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    7720:	4629      	mov	r1, r5
    7722:	f000 fd47 	bl	81b4 <bt_conn_set_state>
	if (conn->type != BT_CONN_TYPE_LE) {
    7726:	78a3      	ldrb	r3, [r4, #2]
	conn->handle = 0U;
    7728:	8025      	strh	r5, [r4, #0]
	if (conn->type != BT_CONN_TYPE_LE) {
    772a:	2b01      	cmp	r3, #1
		bt_conn_unref(conn);
    772c:	4620      	mov	r0, r4
	if (conn->type != BT_CONN_TYPE_LE) {
    772e:	d003      	beq.n	7738 <hci_disconn_complete+0x6c>
}
    7730:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		bt_conn_unref(conn);
    7734:	f013 bf43 	b.w	1b5be <bt_conn_unref>
	bt_conn_unref(conn);
    7738:	f013 ff41 	bl	1b5be <bt_conn_unref>
    773c:	e7e0      	b.n	7700 <hci_disconn_complete+0x34>
}
    773e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7740:	0001ed28 	.word	0x0001ed28
    7744:	0001ede8 	.word	0x0001ede8
    7748:	00020a15 	.word	0x00020a15
    774c:	200054a8 	.word	0x200054a8

00007750 <enh_conn_complete>:
{
    7750:	b5f0      	push	{r4, r5, r6, r7, lr}
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    7752:	f46f 3180 	mvn.w	r1, #65536	; 0x10000
	u16_t handle = sys_le16_to_cpu(evt->handle);
    7756:	f8b0 7001 	ldrh.w	r7, [r0, #1]
{
    775a:	b085      	sub	sp, #20
    775c:	4605      	mov	r5, r0
    775e:	485a      	ldr	r0, [pc, #360]	; (78c8 <enh_conn_complete+0x178>)
    7760:	f013 fd8a 	bl	1b278 <atomic_and>
	if (atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_ID_PENDING)) {
    7764:	03c3      	lsls	r3, r0, #15
	u16_t handle = sys_le16_to_cpu(evt->handle);
    7766:	b2be      	uxth	r6, r7
	if (atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_ID_PENDING)) {
    7768:	d504      	bpl.n	7774 <enh_conn_complete+0x24>
		bt_keys_foreach(BT_KEYS_IRK, update_pending_id, NULL);
    776a:	2200      	movs	r2, #0
    776c:	4957      	ldr	r1, [pc, #348]	; (78cc <enh_conn_complete+0x17c>)
    776e:	2002      	movs	r0, #2
    7770:	f005 ffaa 	bl	d6c8 <bt_keys_foreach>
	if (evt->status) {
    7774:	782b      	ldrb	r3, [r5, #0]
    7776:	b343      	cbz	r3, 77ca <enh_conn_complete+0x7a>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_SLAVE) {
    7778:	78eb      	ldrb	r3, [r5, #3]
    777a:	2b01      	cmp	r3, #1
    777c:	d15a      	bne.n	7834 <enh_conn_complete+0xe4>
    777e:	2000      	movs	r0, #0
    7780:	f7fe f8b0 	bl	58e4 <find_pending_connect.part.18>
		if (!conn) {
    7784:	4604      	mov	r4, r0
    7786:	2800      	cmp	r0, #0
    7788:	d054      	beq.n	7834 <enh_conn_complete+0xe4>
		conn->err = evt->status;
    778a:	7829      	ldrb	r1, [r5, #0]
    778c:	7301      	strb	r1, [r0, #12]
			if (conn->err == BT_HCI_ERR_ADV_TIMEOUT) {
    778e:	293c      	cmp	r1, #60	; 0x3c
    7790:	d10c      	bne.n	77ac <enh_conn_complete+0x5c>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    7792:	f06f 0120 	mvn.w	r1, #32
    7796:	484c      	ldr	r0, [pc, #304]	; (78c8 <enh_conn_complete+0x178>)
    7798:	f013 fd6e 	bl	1b278 <atomic_and>
				bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    779c:	2100      	movs	r1, #0
    779e:	4620      	mov	r0, r4
    77a0:	f000 fd08 	bl	81b4 <bt_conn_set_state>
	bt_conn_unref(conn);
    77a4:	4620      	mov	r0, r4
    77a6:	f013 ff0a 	bl	1b5be <bt_conn_unref>
	if (IS_ENABLED(CONFIG_BT_CENTRAL)) {
    77aa:	e043      	b.n	7834 <enh_conn_complete+0xe4>
		BT_WARN("Unexpected status 0x%02x", evt->status);
    77ac:	2302      	movs	r3, #2
    77ae:	f04f 0200 	mov.w	r2, #0
    77b2:	f363 0207 	bfi	r2, r3, #0, #8
    77b6:	4846      	ldr	r0, [pc, #280]	; (78d0 <enh_conn_complete+0x180>)
    77b8:	4b46      	ldr	r3, [pc, #280]	; (78d4 <enh_conn_complete+0x184>)
    77ba:	1a1b      	subs	r3, r3, r0
    77bc:	08db      	lsrs	r3, r3, #3
    77be:	f363 128f 	bfi	r2, r3, #6, #10
    77c2:	4845      	ldr	r0, [pc, #276]	; (78d8 <enh_conn_complete+0x188>)
    77c4:	f012 ff32 	bl	1a62c <log_1>
		bt_conn_unref(conn);
    77c8:	e7ec      	b.n	77a4 <enh_conn_complete+0x54>
	bt_addr_le_copy(&id_addr, &evt->peer_addr);
    77ca:	1d2c      	adds	r4, r5, #4
    77cc:	4621      	mov	r1, r4
    77ce:	a802      	add	r0, sp, #8
    77d0:	f013 fd64 	bl	1b29c <bt_addr_le_copy>
	if (id_addr.type == BT_ADDR_LE_PUBLIC_ID ||
    77d4:	f89d 3008 	ldrb.w	r3, [sp, #8]
    77d8:	3b02      	subs	r3, #2
    77da:	b2db      	uxtb	r3, r3
    77dc:	2b01      	cmp	r3, #1
    77de:	d82b      	bhi.n	7838 <enh_conn_complete+0xe8>
		bt_addr_copy(&peer_addr.a, &evt->peer_rpa);
    77e0:	f105 0111 	add.w	r1, r5, #17
    77e4:	f10d 0001 	add.w	r0, sp, #1
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
    77e8:	f88d 3008 	strb.w	r3, [sp, #8]
		bt_addr_copy(&peer_addr.a, &evt->peer_rpa);
    77ec:	f013 fd53 	bl	1b296 <bt_addr_copy>
		peer_addr.type = BT_ADDR_LE_RANDOM;
    77f0:	2301      	movs	r3, #1
    77f2:	f88d 3000 	strb.w	r3, [sp]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_SLAVE) {
    77f6:	78eb      	ldrb	r3, [r5, #3]
    77f8:	2b01      	cmp	r3, #1
    77fa:	d10c      	bne.n	7816 <enh_conn_complete+0xc6>
    77fc:	a802      	add	r0, sp, #8
    77fe:	f7fe f871 	bl	58e4 <find_pending_connect.part.18>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    7802:	78eb      	ldrb	r3, [r5, #3]
    7804:	2b01      	cmp	r3, #1
    7806:	4604      	mov	r4, r0
    7808:	d104      	bne.n	7814 <enh_conn_complete+0xc4>
    780a:	f06f 0120 	mvn.w	r1, #32
    780e:	482e      	ldr	r0, [pc, #184]	; (78c8 <enh_conn_complete+0x178>)
    7810:	f013 fd32 	bl	1b278 <atomic_and>
	if (!conn) {
    7814:	b9ac      	cbnz	r4, 7842 <enh_conn_complete+0xf2>
		BT_ERR("Unable to add new conn for handle %u", handle);
    7816:	2301      	movs	r3, #1
    7818:	f04f 0200 	mov.w	r2, #0
    781c:	f363 0207 	bfi	r2, r3, #0, #8
    7820:	492b      	ldr	r1, [pc, #172]	; (78d0 <enh_conn_complete+0x180>)
    7822:	4b2c      	ldr	r3, [pc, #176]	; (78d4 <enh_conn_complete+0x184>)
    7824:	482d      	ldr	r0, [pc, #180]	; (78dc <enh_conn_complete+0x18c>)
    7826:	1a5b      	subs	r3, r3, r1
    7828:	08db      	lsrs	r3, r3, #3
    782a:	f363 128f 	bfi	r2, r3, #6, #10
    782e:	4631      	mov	r1, r6
    7830:	f012 fefc 	bl	1a62c <log_1>
}
    7834:	b005      	add	sp, #20
    7836:	bdf0      	pop	{r4, r5, r6, r7, pc}
		bt_addr_le_copy(&peer_addr, &evt->peer_addr);
    7838:	4621      	mov	r1, r4
    783a:	4668      	mov	r0, sp
    783c:	f013 fd2e 	bl	1b29c <bt_addr_le_copy>
    7840:	e7d9      	b.n	77f6 <enh_conn_complete+0xa6>
	conn->handle = handle;
    7842:	4620      	mov	r0, r4
	bt_addr_le_copy(&conn->le.dst, &id_addr);
    7844:	a902      	add	r1, sp, #8
	conn->handle = handle;
    7846:	f820 7b70 	strh.w	r7, [r0], #112
	bt_addr_le_copy(&conn->le.dst, &id_addr);
    784a:	f013 fd27 	bl	1b29c <bt_addr_le_copy>
	conn->le.interval = sys_le16_to_cpu(evt->interval);
    784e:	7e2a      	ldrb	r2, [r5, #24]
    7850:	7deb      	ldrb	r3, [r5, #23]
    7852:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    7856:	f8a4 3086 	strh.w	r3, [r4, #134]	; 0x86
	conn->le.latency = sys_le16_to_cpu(evt->latency);
    785a:	7eaa      	ldrb	r2, [r5, #26]
    785c:	7e6b      	ldrb	r3, [r5, #25]
    785e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    7862:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
	conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
    7866:	7eeb      	ldrb	r3, [r5, #27]
    7868:	7f2a      	ldrb	r2, [r5, #28]
    786a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    786e:	f8a4 308e 	strh.w	r3, [r4, #142]	; 0x8e
	conn->role = evt->role;
    7872:	78ee      	ldrb	r6, [r5, #3]
    7874:	70e6      	strb	r6, [r4, #3]
	conn->err = 0U;
    7876:	2700      	movs	r7, #0
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    7878:	2e01      	cmp	r6, #1
	conn->err = 0U;
    787a:	7327      	strb	r7, [r4, #12]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    787c:	d11c      	bne.n	78b8 <enh_conn_complete+0x168>
		bt_addr_le_copy(&conn->le.init_addr, &peer_addr);
    787e:	4669      	mov	r1, sp
    7880:	f104 0077 	add.w	r0, r4, #119	; 0x77
    7884:	f013 fd0a 	bl	1b29c <bt_addr_le_copy>
			bt_addr_copy(&conn->le.resp_addr.a, &evt->local_rpa);
    7888:	f105 010b 	add.w	r1, r5, #11
    788c:	f104 007f 	add.w	r0, r4, #127	; 0x7f
    7890:	f013 fd01 	bl	1b296 <bt_addr_copy>
		if (atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    7894:	4b12      	ldr	r3, [pc, #72]	; (78e0 <enh_conn_complete+0x190>)
			conn->le.resp_addr.type = BT_ADDR_LE_RANDOM;
    7896:	f884 607e 	strb.w	r6, [r4, #126]	; 0x7e
		if (atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    789a:	2108      	movs	r1, #8
    789c:	f103 0070 	add.w	r0, r3, #112	; 0x70
    78a0:	f013 fd4f 	bl	1b342 <atomic_test_bit>
    78a4:	b140      	cbz	r0, 78b8 <enh_conn_complete+0x168>
		    BT_LE_STATES_SLAVE_CONN_ADV(bt_dev.le.states)) {
    78a6:	f8d3 1084 	ldr.w	r1, [r3, #132]	; 0x84
    78aa:	463a      	mov	r2, r7
    78ac:	f001 0340 	and.w	r3, r1, #64	; 0x40
		if (atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    78b0:	4313      	orrs	r3, r2
    78b2:	d001      	beq.n	78b8 <enh_conn_complete+0x168>
			bt_le_adv_resume();
    78b4:	f7ff fec8 	bl	7648 <bt_le_adv_resume>
	bt_conn_set_state(conn, BT_CONN_CONNECTED);
    78b8:	4620      	mov	r0, r4
    78ba:	2106      	movs	r1, #6
    78bc:	f000 fc7a 	bl	81b4 <bt_conn_set_state>
	conn_auto_initiate(conn);
    78c0:	4620      	mov	r0, r4
    78c2:	f7fe fe0f 	bl	64e4 <conn_auto_initiate>
    78c6:	e76d      	b.n	77a4 <enh_conn_complete+0x54>
    78c8:	200054a8 	.word	0x200054a8
    78cc:	0001b3ff 	.word	0x0001b3ff
    78d0:	0001ed28 	.word	0x0001ed28
    78d4:	0001ede8 	.word	0x0001ede8
    78d8:	00020903 	.word	0x00020903
    78dc:	0002091c 	.word	0x0002091c
    78e0:	20005438 	.word	0x20005438

000078e4 <le_legacy_conn_complete>:
{
    78e4:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_le_conn_complete *evt = (void *)buf->data;
    78e6:	6884      	ldr	r4, [r0, #8]
		bt_addr_copy(&enh.local_rpa, &bt_dev.random_addr.a);
    78e8:	4e27      	ldr	r6, [pc, #156]	; (7988 <le_legacy_conn_complete+0xa4>)
	enh.status         = evt->status;
    78ea:	7823      	ldrb	r3, [r4, #0]
{
    78ec:	b08a      	sub	sp, #40	; 0x28
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
    78ee:	ad03      	add	r5, sp, #12
	enh.status         = evt->status;
    78f0:	f88d 3008 	strb.w	r3, [sp, #8]
	enh.handle         = evt->handle;
    78f4:	f8b4 3001 	ldrh.w	r3, [r4, #1]
    78f8:	f8ad 3009 	strh.w	r3, [sp, #9]
	enh.role           = evt->role;
    78fc:	78e3      	ldrb	r3, [r4, #3]
    78fe:	f88d 300b 	strb.w	r3, [sp, #11]
	enh.interval       = evt->interval;
    7902:	f8b4 300b 	ldrh.w	r3, [r4, #11]
    7906:	f8ad 301f 	strh.w	r3, [sp, #31]
	enh.latency        = evt->latency;
    790a:	f8b4 300d 	ldrh.w	r3, [r4, #13]
    790e:	f8ad 3021 	strh.w	r3, [sp, #33]	; 0x21
	enh.supv_timeout   = evt->supv_timeout;
    7912:	f8b4 300f 	ldrh.w	r3, [r4, #15]
    7916:	f8ad 3023 	strh.w	r3, [sp, #35]	; 0x23
	enh.clock_accuracy = evt->clock_accuracy;
    791a:	7c63      	ldrb	r3, [r4, #17]
    791c:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
    7920:	1d21      	adds	r1, r4, #4
    7922:	4628      	mov	r0, r5
    7924:	f013 fcba 	bl	1b29c <bt_addr_le_copy>
		bt_addr_copy(&enh.local_rpa, &bt_dev.random_addr.a);
    7928:	f10d 0013 	add.w	r0, sp, #19
    792c:	f106 010a 	add.w	r1, r6, #10
    7930:	f013 fcb1 	bl	1b296 <bt_addr_copy>
	if (evt->role == BT_HCI_ROLE_SLAVE) {
    7934:	78e3      	ldrb	r3, [r4, #3]
    7936:	2b01      	cmp	r3, #1
		id_addr = bt_lookup_id_addr(bt_dev.adv_id, &enh.peer_addr);
    7938:	bf0c      	ite	eq
    793a:	7a30      	ldrbeq	r0, [r6, #8]
		id_addr = bt_lookup_id_addr(BT_ID_DEFAULT, &enh.peer_addr);
    793c:	2000      	movne	r0, #0
		id_addr = bt_lookup_id_addr(bt_dev.adv_id, &enh.peer_addr);
    793e:	4629      	mov	r1, r5
		id_addr = bt_lookup_id_addr(BT_ID_DEFAULT, &enh.peer_addr);
    7940:	f013 fd35 	bl	1b3ae <bt_lookup_id_addr>
	if (id_addr != &enh.peer_addr) {
    7944:	42a8      	cmp	r0, r5
		id_addr = bt_lookup_id_addr(BT_ID_DEFAULT, &enh.peer_addr);
    7946:	4604      	mov	r4, r0
	if (id_addr != &enh.peer_addr) {
    7948:	d013      	beq.n	7972 <le_legacy_conn_complete+0x8e>
		bt_addr_copy(&enh.peer_rpa, &enh.peer_addr.a);
    794a:	f10d 010d 	add.w	r1, sp, #13
    794e:	f10d 0019 	add.w	r0, sp, #25
    7952:	f013 fca0 	bl	1b296 <bt_addr_copy>
		bt_addr_le_copy(&enh.peer_addr, id_addr);
    7956:	4621      	mov	r1, r4
    7958:	4628      	mov	r0, r5
    795a:	f013 fc9f 	bl	1b29c <bt_addr_le_copy>
		enh.peer_addr.type += BT_ADDR_LE_PUBLIC_ID;
    795e:	f89d 300c 	ldrb.w	r3, [sp, #12]
    7962:	3302      	adds	r3, #2
    7964:	f88d 300c 	strb.w	r3, [sp, #12]
	enh_conn_complete(&enh);
    7968:	a802      	add	r0, sp, #8
    796a:	f7ff fef1 	bl	7750 <enh_conn_complete>
}
    796e:	b00a      	add	sp, #40	; 0x28
    7970:	bd70      	pop	{r4, r5, r6, pc}
		bt_addr_copy(&enh.peer_rpa, BT_ADDR_ANY);
    7972:	2300      	movs	r3, #0
    7974:	4669      	mov	r1, sp
    7976:	f10d 0019 	add.w	r0, sp, #25
    797a:	9300      	str	r3, [sp, #0]
    797c:	f8ad 3004 	strh.w	r3, [sp, #4]
    7980:	f013 fc89 	bl	1b296 <bt_addr_copy>
    7984:	e7f0      	b.n	7968 <le_legacy_conn_complete+0x84>
    7986:	bf00      	nop
    7988:	20005438 	.word	0x20005438

0000798c <bt_buf_get_rx>:
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_HOST_CHAN_CLASSIF,
				    buf, NULL);
}

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, s32_t timeout)
{
    798c:	b538      	push	{r3, r4, r5, lr}
    798e:	4605      	mov	r5, r0
		buf = net_buf_alloc(&hci_rx_pool, timeout);
	} else {
		buf = net_buf_alloc(&acl_in_pool, timeout);
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
    7990:	4805      	ldr	r0, [pc, #20]	; (79a8 <bt_buf_get_rx+0x1c>)
    7992:	f016 f927 	bl	1dbe4 <net_buf_alloc_fixed>
#endif

	if (buf) {
    7996:	4604      	mov	r4, r0
    7998:	b120      	cbz	r0, 79a4 <bt_buf_get_rx+0x18>
		net_buf_reserve(buf, BT_BUF_RESERVE);
    799a:	2100      	movs	r1, #0
    799c:	3008      	adds	r0, #8
    799e:	f016 f940 	bl	1dc22 <net_buf_simple_reserve>
	*(u8_t *)net_buf_user_data(buf) = type;
    79a2:	7525      	strb	r5, [r4, #20]
		bt_buf_set_type(buf, type);
	}

	return buf;
}
    79a4:	4620      	mov	r0, r4
    79a6:	bd38      	pop	{r3, r4, r5, pc}
    79a8:	20005d48 	.word	0x20005d48

000079ac <bt_buf_get_cmd_complete>:

struct net_buf *bt_buf_get_cmd_complete(s32_t timeout)
{
    79ac:	b510      	push	{r4, lr}
    79ae:	4601      	mov	r1, r0
	__asm__ volatile(
    79b0:	f04f 0320 	mov.w	r3, #32
    79b4:	f3ef 8011 	mrs	r0, BASEPRI
    79b8:	f383 8811 	msr	BASEPRI, r3
    79bc:	f3bf 8f6f 	isb	sy
	struct net_buf *buf;
	unsigned int key;

	key = irq_lock();
	buf = bt_dev.sent_cmd;
    79c0:	4a0c      	ldr	r2, [pc, #48]	; (79f4 <bt_buf_get_cmd_complete+0x48>)
	bt_dev.sent_cmd = NULL;
    79c2:	2300      	movs	r3, #0
	buf = bt_dev.sent_cmd;
    79c4:	f8d2 40c0 	ldr.w	r4, [r2, #192]	; 0xc0
	bt_dev.sent_cmd = NULL;
    79c8:	f8c2 30c0 	str.w	r3, [r2, #192]	; 0xc0
	__asm__ volatile(
    79cc:	f380 8811 	msr	BASEPRI, r0
    79d0:	f3bf 8f6f 	isb	sy
	irq_unlock(key);

	BT_DBG("sent_cmd %p", buf);

	if (buf) {
    79d4:	b924      	cbnz	r4, 79e0 <bt_buf_get_cmd_complete+0x34>
		net_buf_reserve(buf, BT_BUF_RESERVE);

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
    79d6:	2001      	movs	r0, #1
}
    79d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
    79dc:	f7ff bfd6 	b.w	798c <bt_buf_get_rx>
    79e0:	2201      	movs	r2, #1
		net_buf_reserve(buf, BT_BUF_RESERVE);
    79e2:	f104 0008 	add.w	r0, r4, #8
    79e6:	7522      	strb	r2, [r4, #20]
		buf->len = 0U;
    79e8:	81a3      	strh	r3, [r4, #12]
		net_buf_reserve(buf, BT_BUF_RESERVE);
    79ea:	4619      	mov	r1, r3
    79ec:	f016 f919 	bl	1dc22 <net_buf_simple_reserve>
}
    79f0:	4620      	mov	r0, r4
    79f2:	bd10      	pop	{r4, pc}
    79f4:	20005438 	.word	0x20005438

000079f8 <bt_buf_get_evt>:

struct net_buf *bt_buf_get_evt(u8_t evt, bool discardable, s32_t timeout)
{
	switch (evt) {
    79f8:	280e      	cmp	r0, #14
{
    79fa:	460b      	mov	r3, r1
    79fc:	b510      	push	{r4, lr}
    79fe:	4611      	mov	r1, r2
	switch (evt) {
    7a00:	d315      	bcc.n	7a2e <bt_buf_get_evt+0x36>
    7a02:	280f      	cmp	r0, #15
    7a04:	d90e      	bls.n	7a24 <bt_buf_get_evt+0x2c>
    7a06:	2813      	cmp	r0, #19
    7a08:	d111      	bne.n	7a2e <bt_buf_get_evt+0x36>
#if defined(CONFIG_BT_CONN)
	case BT_HCI_EVT_NUM_COMPLETED_PACKETS:
		{
			struct net_buf *buf;

			buf = net_buf_alloc(&num_complete_pool, timeout);
    7a0a:	480d      	ldr	r0, [pc, #52]	; (7a40 <bt_buf_get_evt+0x48>)
	default:
#if defined(CONFIG_BT_DISCARDABLE_BUF_COUNT)
		if (discardable) {
			struct net_buf *buf;

			buf = net_buf_alloc(&discardable_pool, timeout);
    7a0c:	f016 f8ea 	bl	1dbe4 <net_buf_alloc_fixed>
			if (buf) {
    7a10:	4604      	mov	r4, r0
    7a12:	b128      	cbz	r0, 7a20 <bt_buf_get_evt+0x28>
				net_buf_reserve(buf, BT_BUF_RESERVE);
    7a14:	2100      	movs	r1, #0
    7a16:	3008      	adds	r0, #8
    7a18:	f016 f903 	bl	1dc22 <net_buf_simple_reserve>
    7a1c:	2301      	movs	r3, #1
    7a1e:	7523      	strb	r3, [r4, #20]
		}
#endif /* CONFIG_BT_DISCARDABLE_BUF_COUNT */

		return bt_buf_get_rx(BT_BUF_EVT, timeout);
	}
}
    7a20:	4620      	mov	r0, r4
    7a22:	bd10      	pop	{r4, pc}
		return bt_buf_get_cmd_complete(timeout);
    7a24:	4610      	mov	r0, r2
}
    7a26:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return bt_buf_get_cmd_complete(timeout);
    7a2a:	f7ff bfbf 	b.w	79ac <bt_buf_get_cmd_complete>
		if (discardable) {
    7a2e:	b10b      	cbz	r3, 7a34 <bt_buf_get_evt+0x3c>
			buf = net_buf_alloc(&discardable_pool, timeout);
    7a30:	4804      	ldr	r0, [pc, #16]	; (7a44 <bt_buf_get_evt+0x4c>)
    7a32:	e7eb      	b.n	7a0c <bt_buf_get_evt+0x14>
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
    7a34:	2001      	movs	r0, #1
}
    7a36:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
    7a3a:	f7ff bfa7 	b.w	798c <bt_buf_get_rx>
    7a3e:	bf00      	nop
    7a40:	20005d68 	.word	0x20005d68
    7a44:	20005ce8 	.word	0x20005ce8

00007a48 <bt_pub_key_gen>:
}
#endif /* CONFIG_BT_BREDR */

#if defined(CONFIG_BT_ECC)
int bt_pub_key_gen(struct bt_pub_key_cb *new_cb)
{
    7a48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	 * We check for both "LE Read Local P-256 Public Key" and
	 * "LE Generate DH Key" support here since both commands are needed for
	 * ECC support. If "LE Generate DH Key" is not supported then there
	 * is no point in reading local public key.
	 */
	if (!BT_CMD_TEST(bt_dev.supported_commands, 34, 1) ||
    7a4a:	4d26      	ldr	r5, [pc, #152]	; (7ae4 <bt_pub_key_gen+0x9c>)
    7a4c:	f895 3042 	ldrb.w	r3, [r5, #66]	; 0x42
    7a50:	f003 0306 	and.w	r3, r3, #6
    7a54:	2b06      	cmp	r3, #6
    7a56:	d011      	beq.n	7a7c <bt_pub_key_gen+0x34>
	    !BT_CMD_TEST(bt_dev.supported_commands, 34, 2)) {
		BT_WARN("ECC HCI commands not available");
    7a58:	2302      	movs	r3, #2
    7a5a:	f04f 0100 	mov.w	r1, #0
    7a5e:	f363 0107 	bfi	r1, r3, #0, #8
    7a62:	4a21      	ldr	r2, [pc, #132]	; (7ae8 <bt_pub_key_gen+0xa0>)
    7a64:	4b21      	ldr	r3, [pc, #132]	; (7aec <bt_pub_key_gen+0xa4>)
    7a66:	4822      	ldr	r0, [pc, #136]	; (7af0 <bt_pub_key_gen+0xa8>)
    7a68:	1a9b      	subs	r3, r3, r2
    7a6a:	08db      	lsrs	r3, r3, #3
    7a6c:	f363 118f 	bfi	r1, r3, #6, #10
    7a70:	f012 fdcf 	bl	1a612 <log_0>
		return -ENOTSUP;
    7a74:	f06f 0422 	mvn.w	r4, #34	; 0x22
		pub_key_cb = NULL;
		return err;
	}

	return 0;
}
    7a78:	4620      	mov	r0, r4
    7a7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	new_cb->_next = pub_key_cb;
    7a7c:	4e1d      	ldr	r6, [pc, #116]	; (7af4 <bt_pub_key_gen+0xac>)
    7a7e:	6833      	ldr	r3, [r6, #0]
    7a80:	6043      	str	r3, [r0, #4]
	pub_key_cb = new_cb;
    7a82:	6030      	str	r0, [r6, #0]
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    7a84:	2110      	movs	r1, #16
    7a86:	f105 0070 	add.w	r0, r5, #112	; 0x70
    7a8a:	f013 fc0a 	bl	1b2a2 <atomic_or>
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
    7a8e:	f010 0710 	ands.w	r7, r0, #16
    7a92:	d124      	bne.n	7ade <bt_pub_key_gen+0x96>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    7a94:	f06f 0108 	mvn.w	r1, #8
    7a98:	f105 0070 	add.w	r0, r5, #112	; 0x70
    7a9c:	f013 fbec 	bl	1b278 <atomic_and>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_P256_PUBLIC_KEY, NULL, NULL);
    7aa0:	463a      	mov	r2, r7
    7aa2:	4639      	mov	r1, r7
    7aa4:	f242 0025 	movw	r0, #8229	; 0x2025
    7aa8:	f7fe fb34 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
    7aac:	4604      	mov	r4, r0
    7aae:	2800      	cmp	r0, #0
    7ab0:	d0e2      	beq.n	7a78 <bt_pub_key_gen+0x30>
		BT_ERR("Sending LE P256 Public Key command failed");
    7ab2:	2301      	movs	r3, #1
    7ab4:	f04f 0100 	mov.w	r1, #0
    7ab8:	4a0b      	ldr	r2, [pc, #44]	; (7ae8 <bt_pub_key_gen+0xa0>)
    7aba:	480f      	ldr	r0, [pc, #60]	; (7af8 <bt_pub_key_gen+0xb0>)
    7abc:	f363 0107 	bfi	r1, r3, #0, #8
    7ac0:	4b0a      	ldr	r3, [pc, #40]	; (7aec <bt_pub_key_gen+0xa4>)
    7ac2:	1a9b      	subs	r3, r3, r2
    7ac4:	08db      	lsrs	r3, r3, #3
    7ac6:	f363 118f 	bfi	r1, r3, #6, #10
    7aca:	f012 fda2 	bl	1a612 <log_0>
    7ace:	f06f 0110 	mvn.w	r1, #16
    7ad2:	f105 0070 	add.w	r0, r5, #112	; 0x70
    7ad6:	f013 fbcf 	bl	1b278 <atomic_and>
		pub_key_cb = NULL;
    7ada:	6037      	str	r7, [r6, #0]
		return err;
    7adc:	e7cc      	b.n	7a78 <bt_pub_key_gen+0x30>
		return 0;
    7ade:	2400      	movs	r4, #0
    7ae0:	e7ca      	b.n	7a78 <bt_pub_key_gen+0x30>
    7ae2:	bf00      	nop
    7ae4:	20005438 	.word	0x20005438
    7ae8:	0001ed28 	.word	0x0001ed28
    7aec:	0001ede8 	.word	0x0001ede8
    7af0:	000206c3 	.word	0x000206c3
    7af4:	20000228 	.word	0x20000228
    7af8:	000206e2 	.word	0x000206e2

00007afc <bt_pub_key_get>:

const u8_t *bt_pub_key_get(void)
{
    7afc:	b508      	push	{r3, lr}
	if (atomic_test_bit(bt_dev.flags, BT_DEV_HAS_PUB_KEY)) {
    7afe:	2103      	movs	r1, #3
    7b00:	4803      	ldr	r0, [pc, #12]	; (7b10 <bt_pub_key_get+0x14>)
    7b02:	f013 fc1e 	bl	1b342 <atomic_test_bit>
    7b06:	2800      	cmp	r0, #0
		return pub_key;
	}

	return NULL;
}
    7b08:	4802      	ldr	r0, [pc, #8]	; (7b14 <bt_pub_key_get+0x18>)
    7b0a:	bf08      	it	eq
    7b0c:	2000      	moveq	r0, #0
    7b0e:	bd08      	pop	{r3, pc}
    7b10:	200054a8 	.word	0x200054a8
    7b14:	20001c14 	.word	0x20001c14

00007b18 <bt_dh_key_gen>:

int bt_dh_key_gen(const u8_t remote_pk[64], bt_dh_key_cb_t cb)
{
    7b18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_hci_cp_le_generate_dhkey *cp;
	struct net_buf *buf;
	int err;

	if (dh_key_cb || atomic_test_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
    7b1a:	4c1a      	ldr	r4, [pc, #104]	; (7b84 <bt_dh_key_gen+0x6c>)
    7b1c:	6822      	ldr	r2, [r4, #0]
{
    7b1e:	4607      	mov	r7, r0
    7b20:	460b      	mov	r3, r1
	if (dh_key_cb || atomic_test_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
    7b22:	b112      	cbz	r2, 7b2a <bt_dh_key_gen+0x12>
		return -EBUSY;
    7b24:	f06f 000f 	mvn.w	r0, #15
		dh_key_cb = NULL;
		return err;
	}

	return 0;
}
    7b28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (dh_key_cb || atomic_test_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
    7b2a:	2104      	movs	r1, #4
    7b2c:	4816      	ldr	r0, [pc, #88]	; (7b88 <bt_dh_key_gen+0x70>)
    7b2e:	f013 fc08 	bl	1b342 <atomic_test_bit>
    7b32:	4606      	mov	r6, r0
    7b34:	2800      	cmp	r0, #0
    7b36:	d1f5      	bne.n	7b24 <bt_dh_key_gen+0xc>
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_HAS_PUB_KEY)) {
    7b38:	2103      	movs	r1, #3
    7b3a:	4813      	ldr	r0, [pc, #76]	; (7b88 <bt_dh_key_gen+0x70>)
    7b3c:	f013 fc01 	bl	1b342 <atomic_test_bit>
    7b40:	b1e8      	cbz	r0, 7b7e <bt_dh_key_gen+0x66>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_GENERATE_DHKEY, sizeof(*cp));
    7b42:	2140      	movs	r1, #64	; 0x40
    7b44:	f242 0026 	movw	r0, #8230	; 0x2026
	dh_key_cb = cb;
    7b48:	6023      	str	r3, [r4, #0]
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_GENERATE_DHKEY, sizeof(*cp));
    7b4a:	f7fe f975 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
    7b4e:	4605      	mov	r5, r0
    7b50:	b918      	cbnz	r0, 7b5a <bt_dh_key_gen+0x42>
		dh_key_cb = NULL;
    7b52:	6020      	str	r0, [r4, #0]
		return -ENOBUFS;
    7b54:	f06f 0036 	mvn.w	r0, #54	; 0x36
    7b58:	e7e6      	b.n	7b28 <bt_dh_key_gen+0x10>
	cp = net_buf_add(buf, sizeof(*cp));
    7b5a:	2140      	movs	r1, #64	; 0x40
    7b5c:	3008      	adds	r0, #8
    7b5e:	f016 f875 	bl	1dc4c <net_buf_simple_add>
	memcpy(cp->key, remote_pk, sizeof(cp->key));
    7b62:	2240      	movs	r2, #64	; 0x40
    7b64:	4639      	mov	r1, r7
    7b66:	f013 fa48 	bl	1affa <memcpy>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_GENERATE_DHKEY, buf, NULL);
    7b6a:	4632      	mov	r2, r6
    7b6c:	4629      	mov	r1, r5
    7b6e:	f242 0026 	movw	r0, #8230	; 0x2026
    7b72:	f7fe facf 	bl	6114 <bt_hci_cmd_send_sync>
	if (err) {
    7b76:	2800      	cmp	r0, #0
    7b78:	d0d6      	beq.n	7b28 <bt_dh_key_gen+0x10>
		dh_key_cb = NULL;
    7b7a:	6026      	str	r6, [r4, #0]
		return err;
    7b7c:	e7d4      	b.n	7b28 <bt_dh_key_gen+0x10>
		return -EADDRNOTAVAIL;
    7b7e:	f06f 0030 	mvn.w	r0, #48	; 0x30
    7b82:	e7d1      	b.n	7b28 <bt_dh_key_gen+0x10>
    7b84:	20000224 	.word	0x20000224
    7b88:	200054a8 	.word	0x200054a8

00007b8c <tx_free>:
	return bt_l2cap_update_conn_param(conn, param);
}

static void tx_free(struct bt_conn_tx *tx)
{
	tx->cb = NULL;
    7b8c:	2300      	movs	r3, #0
{
    7b8e:	4601      	mov	r1, r0
	tx->user_data = NULL;
    7b90:	e9c0 3301 	strd	r3, r3, [r0, #4]
	tx->pending_no_cb = 0U;
    7b94:	60c3      	str	r3, [r0, #12]
	k_fifo_put(&free_tx, tx);
    7b96:	4801      	ldr	r0, [pc, #4]	; (7b9c <tx_free+0x10>)
    7b98:	f016 bbd8 	b.w	1e34c <k_queue_append>
    7b9c:	20005c88 	.word	0x20005c88

00007ba0 <notify_connected>:
{
    7ba0:	b538      	push	{r3, r4, r5, lr}
	for (cb = callback_list; cb; cb = cb->_next) {
    7ba2:	4b09      	ldr	r3, [pc, #36]	; (7bc8 <notify_connected+0x28>)
    7ba4:	681c      	ldr	r4, [r3, #0]
{
    7ba6:	4605      	mov	r5, r0
    7ba8:	7b29      	ldrb	r1, [r5, #12]
	for (cb = callback_list; cb; cb = cb->_next) {
    7baa:	b92c      	cbnz	r4, 7bb8 <notify_connected+0x18>
	if (!conn->err) {
    7bac:	b951      	cbnz	r1, 7bc4 <notify_connected+0x24>
		bt_gatt_connected(conn);
    7bae:	4628      	mov	r0, r5
}
    7bb0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		bt_gatt_connected(conn);
    7bb4:	f003 bdd2 	b.w	b75c <bt_gatt_connected>
		if (cb->connected) {
    7bb8:	6823      	ldr	r3, [r4, #0]
    7bba:	b10b      	cbz	r3, 7bc0 <notify_connected+0x20>
			cb->connected(conn, conn->err);
    7bbc:	4628      	mov	r0, r5
    7bbe:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
    7bc0:	69a4      	ldr	r4, [r4, #24]
    7bc2:	e7f1      	b.n	7ba8 <notify_connected+0x8>
}
    7bc4:	bd38      	pop	{r3, r4, r5, pc}
    7bc6:	bf00      	nop
    7bc8:	200002a0 	.word	0x200002a0

00007bcc <send_frag>:
	return 0;
}

static bool send_frag(struct bt_conn *conn, struct net_buf *buf, u8_t flags,
		      bool always_consume)
{
    7bcc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    7bd0:	4604      	mov	r4, r0
    7bd2:	460e      	mov	r6, r1
    7bd4:	4691      	mov	r9, r2
    7bd6:	461f      	mov	r7, r3
	struct bt_conn_tx *tx = tx_data(buf)->tx;
    7bd8:	694d      	ldr	r5, [r1, #20]
	return z_impl_k_sem_take(sem, timeout);
    7bda:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    7bde:	4844      	ldr	r0, [pc, #272]	; (7cf0 <send_frag+0x124>)
    7be0:	f010 fc7c 	bl	184dc <z_impl_k_sem_take>

	/* Wait until the controller can accept ACL packets */
	k_sem_take(bt_conn_get_pkts(conn), K_FOREVER);

	/* Check for disconnection while waiting for pkts_sem */
	if (conn->state != BT_CONN_CONNECTED) {
    7be4:	7b63      	ldrb	r3, [r4, #13]
    7be6:	2b06      	cmp	r3, #6
    7be8:	d152      	bne.n	7c90 <send_frag+0xc4>
		goto fail;
	}

	hdr = net_buf_push(buf, sizeof(*hdr));
    7bea:	2104      	movs	r1, #4
    7bec:	f106 0008 	add.w	r0, r6, #8
    7bf0:	f016 f84d 	bl	1dc8e <net_buf_simple_push>
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
    7bf4:	8822      	ldrh	r2, [r4, #0]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
    7bf6:	89b3      	ldrh	r3, [r6, #12]
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
    7bf8:	ea42 3209 	orr.w	r2, r2, r9, lsl #12
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
    7bfc:	3b04      	subs	r3, #4
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
    7bfe:	8002      	strh	r2, [r0, #0]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
    7c00:	8043      	strh	r3, [r0, #2]
	__asm__ volatile(
    7c02:	f04f 0320 	mov.w	r3, #32
    7c06:	f3ef 8211 	mrs	r2, BASEPRI
    7c0a:	f383 8811 	msr	BASEPRI, r3
    7c0e:	f3bf 8f6f 	isb	sy

	/* Add to pending, it must be done before bt_buf_set_type */
	key = irq_lock();
	if (tx) {
    7c12:	2d00      	cmp	r5, #0
    7c14:	d04e      	beq.n	7cb4 <send_frag+0xe8>
	parent->next = child;
    7c16:	2300      	movs	r3, #0
    7c18:	602b      	str	r3, [r5, #0]
Z_GENLIST_APPEND(slist, snode)
    7c1a:	69a3      	ldr	r3, [r4, #24]
    7c1c:	2b00      	cmp	r3, #0
    7c1e:	d146      	bne.n	7cae <send_frag+0xe2>
	list->head = node;
    7c20:	e9c4 5505 	strd	r5, r5, [r4, #20]
	__asm__ volatile(
    7c24:	f382 8811 	msr	BASEPRI, r2
    7c28:	f3bf 8f6f 	isb	sy
    7c2c:	2302      	movs	r3, #2
    7c2e:	7533      	strb	r3, [r6, #20]
	}
	irq_unlock(key);

	bt_buf_set_type(buf, BT_BUF_ACL_OUT);

	err = bt_send(buf);
    7c30:	4630      	mov	r0, r6
    7c32:	f013 fc02 	bl	1b43a <bt_send>
	if (err) {
    7c36:	4601      	mov	r1, r0
    7c38:	2800      	cmp	r0, #0
    7c3a:	d057      	beq.n	7cec <send_frag+0x120>
		BT_ERR("Unable to send to driver (err %d)", err);
    7c3c:	2301      	movs	r3, #1
    7c3e:	f04f 0200 	mov.w	r2, #0
    7c42:	f363 0207 	bfi	r2, r3, #0, #8
    7c46:	482b      	ldr	r0, [pc, #172]	; (7cf4 <send_frag+0x128>)
    7c48:	4b2b      	ldr	r3, [pc, #172]	; (7cf8 <send_frag+0x12c>)
    7c4a:	1a1b      	subs	r3, r3, r0
    7c4c:	08db      	lsrs	r3, r3, #3
    7c4e:	f363 128f 	bfi	r2, r3, #6, #10
    7c52:	482a      	ldr	r0, [pc, #168]	; (7cfc <send_frag+0x130>)
    7c54:	f012 fcea 	bl	1a62c <log_1>
	__asm__ volatile(
    7c58:	f04f 0320 	mov.w	r3, #32
    7c5c:	f3ef 8111 	mrs	r1, BASEPRI
    7c60:	f383 8811 	msr	BASEPRI, r3
    7c64:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		/* Roll back the pending TX info */
		if (tx) {
    7c68:	2d00      	cmp	r5, #0
    7c6a:	d039      	beq.n	7ce0 <send_frag+0x114>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    7c6c:	6963      	ldr	r3, [r4, #20]
    7c6e:	2200      	movs	r2, #0
    7c70:	b153      	cbz	r3, 7c88 <send_frag+0xbc>
    7c72:	429d      	cmp	r5, r3
    7c74:	d131      	bne.n	7cda <send_frag+0x10e>
Z_GENLIST_REMOVE(slist, snode)
    7c76:	682b      	ldr	r3, [r5, #0]
    7c78:	bb4a      	cbnz	r2, 7cce <send_frag+0x102>
    7c7a:	69a2      	ldr	r2, [r4, #24]
	list->head = node;
    7c7c:	6163      	str	r3, [r4, #20]
Z_GENLIST_REMOVE(slist, snode)
    7c7e:	4295      	cmp	r5, r2
    7c80:	d100      	bne.n	7c84 <send_frag+0xb8>
	list->tail = node;
    7c82:	61a3      	str	r3, [r4, #24]
	parent->next = child;
    7c84:	2300      	movs	r3, #0
    7c86:	602b      	str	r3, [r5, #0]
	__asm__ volatile(
    7c88:	f381 8811 	msr	BASEPRI, r1
    7c8c:	f3bf 8f6f 	isb	sy
	z_impl_k_sem_give(sem);
    7c90:	4817      	ldr	r0, [pc, #92]	; (7cf0 <send_frag+0x124>)
    7c92:	f010 fbf7 	bl	18484 <z_impl_k_sem_give>

	return true;

fail:
	k_sem_give(bt_conn_get_pkts(conn));
	if (tx) {
    7c96:	b115      	cbz	r5, 7c9e <send_frag+0xd2>
		tx_free(tx);
    7c98:	4628      	mov	r0, r5
    7c9a:	f7ff ff77 	bl	7b8c <tx_free>
	}

	if (always_consume) {
    7c9e:	b11f      	cbz	r7, 7ca8 <send_frag+0xdc>
		net_buf_unref(buf);
    7ca0:	4630      	mov	r0, r6
    7ca2:	f00e fc3d 	bl	16520 <net_buf_unref>
	}
	return false;
    7ca6:	2700      	movs	r7, #0
}
    7ca8:	4638      	mov	r0, r7
    7caa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    7cae:	601d      	str	r5, [r3, #0]
	list->tail = node;
    7cb0:	61a5      	str	r5, [r4, #24]
    7cb2:	e7b7      	b.n	7c24 <send_frag+0x58>
		tail_tx = (void *)sys_slist_peek_tail(&conn->tx_pending);
    7cb4:	69a3      	ldr	r3, [r4, #24]
		if (tail_tx) {
    7cb6:	b133      	cbz	r3, 7cc6 <send_frag+0xfa>
			pending_no_cb = &tail_tx->pending_no_cb;
    7cb8:	f103 080c 	add.w	r8, r3, #12
    7cbc:	68db      	ldr	r3, [r3, #12]
		(*pending_no_cb)++;
    7cbe:	3301      	adds	r3, #1
    7cc0:	f8c8 3000 	str.w	r3, [r8]
    7cc4:	e7ae      	b.n	7c24 <send_frag+0x58>
			pending_no_cb = &conn->pending_no_cb;
    7cc6:	f104 081c 	add.w	r8, r4, #28
    7cca:	69e3      	ldr	r3, [r4, #28]
    7ccc:	e7f7      	b.n	7cbe <send_frag+0xf2>
	parent->next = child;
    7cce:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
    7cd0:	69a3      	ldr	r3, [r4, #24]
    7cd2:	429d      	cmp	r5, r3
	list->tail = node;
    7cd4:	bf08      	it	eq
    7cd6:	61a2      	streq	r2, [r4, #24]
    7cd8:	e7d4      	b.n	7c84 <send_frag+0xb8>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    7cda:	461a      	mov	r2, r3
    7cdc:	681b      	ldr	r3, [r3, #0]
    7cde:	e7c7      	b.n	7c70 <send_frag+0xa4>
			(*pending_no_cb)--;
    7ce0:	f8d8 3000 	ldr.w	r3, [r8]
    7ce4:	3b01      	subs	r3, #1
    7ce6:	f8c8 3000 	str.w	r3, [r8]
    7cea:	e7cd      	b.n	7c88 <send_frag+0xbc>
	return true;
    7cec:	2701      	movs	r7, #1
    7cee:	e7db      	b.n	7ca8 <send_frag+0xdc>
    7cf0:	200054c4 	.word	0x200054c4
    7cf4:	0001ed28 	.word	0x0001ed28
    7cf8:	0001ed38 	.word	0x0001ed38
    7cfc:	00020adc 	.word	0x00020adc

00007d00 <conn_cleanup>:

static struct k_poll_signal conn_change =
		K_POLL_SIGNAL_INITIALIZER(conn_change);

static void conn_cleanup(struct bt_conn *conn)
{
    7d00:	b570      	push	{r4, r5, r6, lr}
    7d02:	4605      	mov	r5, r0
	struct net_buf *buf;

	/* Give back any allocated buffers */
	while ((buf = net_buf_get(&conn->tx_queue, K_NO_WAIT))) {
    7d04:	f100 0634 	add.w	r6, r0, #52	; 0x34
    7d08:	2100      	movs	r1, #0
    7d0a:	4630      	mov	r0, r6
    7d0c:	f015 ff70 	bl	1dbf0 <net_buf_get>
    7d10:	4604      	mov	r4, r0
    7d12:	b950      	cbnz	r0, 7d2a <conn_cleanup+0x2a>
	}

	__ASSERT(sys_slist_is_empty(&conn->tx_pending), "Pending TX packets");
	__ASSERT_NO_MSG(conn->pending_no_cb == 0);

	bt_conn_reset_rx_state(conn);
    7d14:	4628      	mov	r0, r5
    7d16:	f013 fbba 	bl	1b48e <bt_conn_reset_rx_state>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    7d1a:	4622      	mov	r2, r4
    7d1c:	f105 0150 	add.w	r1, r5, #80	; 0x50
    7d20:	4806      	ldr	r0, [pc, #24]	; (7d3c <conn_cleanup+0x3c>)

	k_delayed_work_submit(&conn->update_work, K_NO_WAIT);
}
    7d22:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    7d26:	f010 bd1f 	b.w	18768 <k_delayed_work_submit_to_queue>
		if (tx_data(buf)->tx) {
    7d2a:	6960      	ldr	r0, [r4, #20]
    7d2c:	b108      	cbz	r0, 7d32 <conn_cleanup+0x32>
			tx_free(tx_data(buf)->tx);
    7d2e:	f7ff ff2d 	bl	7b8c <tx_free>
		net_buf_unref(buf);
    7d32:	4620      	mov	r0, r4
    7d34:	f00e fbf4 	bl	16520 <net_buf_unref>
    7d38:	e7e6      	b.n	7d08 <conn_cleanup+0x8>
    7d3a:	bf00      	nop
    7d3c:	20001a60 	.word	0x20001a60

00007d40 <bt_conn_get_pkts>:
}
    7d40:	4800      	ldr	r0, [pc, #0]	; (7d44 <bt_conn_get_pkts+0x4>)
    7d42:	4770      	bx	lr
    7d44:	200054c4 	.word	0x200054c4

00007d48 <notify_le_param_updated>:
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
    7d48:	1d02      	adds	r2, r0, #4
{
    7d4a:	b570      	push	{r4, r5, r6, lr}
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
    7d4c:	2109      	movs	r1, #9
{
    7d4e:	4604      	mov	r4, r0
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
    7d50:	4610      	mov	r0, r2
    7d52:	f013 fb95 	bl	1b480 <atomic_test_bit>
    7d56:	b1c8      	cbz	r0, 7d8c <notify_le_param_updated+0x44>
	    conn->le.interval >= conn->le.interval_min &&
    7d58:	f8b4 3086 	ldrh.w	r3, [r4, #134]	; 0x86
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
    7d5c:	f8b4 1088 	ldrh.w	r1, [r4, #136]	; 0x88
    7d60:	4299      	cmp	r1, r3
    7d62:	d813      	bhi.n	7d8c <notify_le_param_updated+0x44>
	    conn->le.interval >= conn->le.interval_min &&
    7d64:	f8b4 108a 	ldrh.w	r1, [r4, #138]	; 0x8a
    7d68:	4299      	cmp	r1, r3
    7d6a:	d30f      	bcc.n	7d8c <notify_le_param_updated+0x44>
	    conn->le.latency == conn->le.pending_latency &&
    7d6c:	e9d4 1323 	ldrd	r1, r3, [r4, #140]	; 0x8c
    7d70:	4299      	cmp	r1, r3
    7d72:	d10b      	bne.n	7d8c <notify_le_param_updated+0x44>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    7d74:	f3bf 8f5b 	dmb	ish
    7d78:	e852 3f00 	ldrex	r3, [r2]
    7d7c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    7d80:	e842 3100 	strex	r1, r3, [r2]
    7d84:	2900      	cmp	r1, #0
    7d86:	d1f7      	bne.n	7d78 <notify_le_param_updated+0x30>
    7d88:	f3bf 8f5b 	dmb	ish
	for (cb = callback_list; cb; cb = cb->_next) {
    7d8c:	4b07      	ldr	r3, [pc, #28]	; (7dac <notify_le_param_updated+0x64>)
    7d8e:	681d      	ldr	r5, [r3, #0]
    7d90:	b905      	cbnz	r5, 7d94 <notify_le_param_updated+0x4c>
}
    7d92:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->le_param_updated) {
    7d94:	68ee      	ldr	r6, [r5, #12]
    7d96:	b13e      	cbz	r6, 7da8 <notify_le_param_updated+0x60>
			cb->le_param_updated(conn, conn->le.interval,
    7d98:	f8b4 308e 	ldrh.w	r3, [r4, #142]	; 0x8e
    7d9c:	f8b4 208c 	ldrh.w	r2, [r4, #140]	; 0x8c
    7da0:	f8b4 1086 	ldrh.w	r1, [r4, #134]	; 0x86
    7da4:	4620      	mov	r0, r4
    7da6:	47b0      	blx	r6
	for (cb = callback_list; cb; cb = cb->_next) {
    7da8:	69ad      	ldr	r5, [r5, #24]
    7daa:	e7f1      	b.n	7d90 <notify_le_param_updated+0x48>
    7dac:	200002a0 	.word	0x200002a0

00007db0 <le_param_req>:
{
    7db0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7db2:	4607      	mov	r7, r0
	if (!bt_le_conn_params_valid(param)) {
    7db4:	4608      	mov	r0, r1
{
    7db6:	460e      	mov	r6, r1
	if (!bt_le_conn_params_valid(param)) {
    7db8:	f013 fb01 	bl	1b3be <bt_le_conn_params_valid>
    7dbc:	4605      	mov	r5, r0
    7dbe:	b910      	cbnz	r0, 7dc6 <le_param_req+0x16>
		return false;
    7dc0:	2500      	movs	r5, #0
}
    7dc2:	4628      	mov	r0, r5
    7dc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (cb = callback_list; cb; cb = cb->_next) {
    7dc6:	4b09      	ldr	r3, [pc, #36]	; (7dec <le_param_req+0x3c>)
    7dc8:	681c      	ldr	r4, [r3, #0]
    7dca:	2c00      	cmp	r4, #0
    7dcc:	d0f9      	beq.n	7dc2 <le_param_req+0x12>
		if (!cb->le_param_req) {
    7dce:	68a3      	ldr	r3, [r4, #8]
    7dd0:	b90b      	cbnz	r3, 7dd6 <le_param_req+0x26>
	for (cb = callback_list; cb; cb = cb->_next) {
    7dd2:	69a4      	ldr	r4, [r4, #24]
    7dd4:	e7f9      	b.n	7dca <le_param_req+0x1a>
		if (!cb->le_param_req(conn, param)) {
    7dd6:	4631      	mov	r1, r6
    7dd8:	4638      	mov	r0, r7
    7dda:	4798      	blx	r3
    7ddc:	2800      	cmp	r0, #0
    7dde:	d0ef      	beq.n	7dc0 <le_param_req+0x10>
		if (!bt_le_conn_params_valid(param)) {
    7de0:	4630      	mov	r0, r6
    7de2:	f013 faec 	bl	1b3be <bt_le_conn_params_valid>
    7de6:	2800      	cmp	r0, #0
    7de8:	d1f3      	bne.n	7dd2 <le_param_req+0x22>
    7dea:	e7e9      	b.n	7dc0 <le_param_req+0x10>
    7dec:	200002a0 	.word	0x200002a0

00007df0 <bt_conn_identity_resolved>:
{
    7df0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (conn->role == BT_HCI_ROLE_MASTER) {
    7df2:	78c3      	ldrb	r3, [r0, #3]
{
    7df4:	4604      	mov	r4, r0
	if (conn->role == BT_HCI_ROLE_MASTER) {
    7df6:	b93b      	cbnz	r3, 7e08 <bt_conn_identity_resolved+0x18>
		rpa = &conn->le.resp_addr;
    7df8:	f100 067e 	add.w	r6, r0, #126	; 0x7e
	for (cb = callback_list; cb; cb = cb->_next) {
    7dfc:	4b08      	ldr	r3, [pc, #32]	; (7e20 <bt_conn_identity_resolved+0x30>)
    7dfe:	681d      	ldr	r5, [r3, #0]
			cb->identity_resolved(conn, rpa, &conn->le.dst);
    7e00:	f104 0770 	add.w	r7, r4, #112	; 0x70
	for (cb = callback_list; cb; cb = cb->_next) {
    7e04:	b91d      	cbnz	r5, 7e0e <bt_conn_identity_resolved+0x1e>
}
    7e06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		rpa = &conn->le.init_addr;
    7e08:	f100 0677 	add.w	r6, r0, #119	; 0x77
    7e0c:	e7f6      	b.n	7dfc <bt_conn_identity_resolved+0xc>
		if (cb->identity_resolved) {
    7e0e:	692b      	ldr	r3, [r5, #16]
    7e10:	b11b      	cbz	r3, 7e1a <bt_conn_identity_resolved+0x2a>
			cb->identity_resolved(conn, rpa, &conn->le.dst);
    7e12:	463a      	mov	r2, r7
    7e14:	4631      	mov	r1, r6
    7e16:	4620      	mov	r0, r4
    7e18:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
    7e1a:	69ad      	ldr	r5, [r5, #24]
    7e1c:	e7f2      	b.n	7e04 <bt_conn_identity_resolved+0x14>
    7e1e:	bf00      	nop
    7e20:	200002a0 	.word	0x200002a0

00007e24 <bt_conn_security_changed>:
	for (cb = callback_list; cb; cb = cb->_next) {
    7e24:	4b0c      	ldr	r3, [pc, #48]	; (7e58 <bt_conn_security_changed+0x34>)
{
    7e26:	b570      	push	{r4, r5, r6, lr}
	for (cb = callback_list; cb; cb = cb->_next) {
    7e28:	681d      	ldr	r5, [r3, #0]
{
    7e2a:	4604      	mov	r4, r0
    7e2c:	460e      	mov	r6, r1
	for (cb = callback_list; cb; cb = cb->_next) {
    7e2e:	b955      	cbnz	r5, 7e46 <bt_conn_security_changed+0x22>
	if (!err && conn->sec_level >= BT_SECURITY_L2) {
    7e30:	b98e      	cbnz	r6, 7e56 <bt_conn_security_changed+0x32>
    7e32:	7a63      	ldrb	r3, [r4, #9]
    7e34:	2b01      	cmp	r3, #1
    7e36:	d90e      	bls.n	7e56 <bt_conn_security_changed+0x32>
		bt_keys_update_usage(conn->id, bt_conn_get_dst(conn));
    7e38:	f104 0170 	add.w	r1, r4, #112	; 0x70
    7e3c:	7a20      	ldrb	r0, [r4, #8]
}
    7e3e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		bt_keys_update_usage(conn->id, bt_conn_get_dst(conn));
    7e42:	f005 bde5 	b.w	da10 <bt_keys_update_usage>
		if (cb->security_changed) {
    7e46:	696b      	ldr	r3, [r5, #20]
    7e48:	b11b      	cbz	r3, 7e52 <bt_conn_security_changed+0x2e>
			cb->security_changed(conn, conn->sec_level, err);
    7e4a:	4632      	mov	r2, r6
    7e4c:	7a61      	ldrb	r1, [r4, #9]
    7e4e:	4620      	mov	r0, r4
    7e50:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
    7e52:	69ad      	ldr	r5, [r5, #24]
    7e54:	e7eb      	b.n	7e2e <bt_conn_security_changed+0xa>
}
    7e56:	bd70      	pop	{r4, r5, r6, pc}
    7e58:	200002a0 	.word	0x200002a0

00007e5c <bt_conn_cb_register>:
	cb->_next = callback_list;
    7e5c:	4b02      	ldr	r3, [pc, #8]	; (7e68 <bt_conn_cb_register+0xc>)
    7e5e:	681a      	ldr	r2, [r3, #0]
    7e60:	6182      	str	r2, [r0, #24]
	callback_list = cb;
    7e62:	6018      	str	r0, [r3, #0]
}
    7e64:	4770      	bx	lr
    7e66:	bf00      	nop
    7e68:	200002a0 	.word	0x200002a0

00007e6c <bt_conn_recv>:
{
    7e6c:	b570      	push	{r4, r5, r6, lr}
    7e6e:	4616      	mov	r6, r2
    7e70:	4604      	mov	r4, r0
    7e72:	460d      	mov	r5, r1
	tx_notify(conn);
    7e74:	f013 fb30 	bl	1b4d8 <tx_notify>
	switch (flags) {
    7e78:	2e01      	cmp	r6, #1
    7e7a:	d020      	beq.n	7ebe <bt_conn_recv+0x52>
    7e7c:	2e02      	cmp	r6, #2
    7e7e:	f040 8081 	bne.w	7f84 <bt_conn_recv+0x118>
		len = sys_le16_to_cpu(hdr->len);
    7e82:	68ab      	ldr	r3, [r5, #8]
    7e84:	881e      	ldrh	r6, [r3, #0]
		if (conn->rx_len) {
    7e86:	89e3      	ldrh	r3, [r4, #14]
    7e88:	b183      	cbz	r3, 7eac <bt_conn_recv+0x40>
			BT_ERR("Unexpected first L2CAP frame");
    7e8a:	2301      	movs	r3, #1
    7e8c:	f04f 0100 	mov.w	r1, #0
    7e90:	f363 0107 	bfi	r1, r3, #0, #8
    7e94:	4a46      	ldr	r2, [pc, #280]	; (7fb0 <bt_conn_recv+0x144>)
    7e96:	4b47      	ldr	r3, [pc, #284]	; (7fb4 <bt_conn_recv+0x148>)
    7e98:	4847      	ldr	r0, [pc, #284]	; (7fb8 <bt_conn_recv+0x14c>)
    7e9a:	1a9b      	subs	r3, r3, r2
    7e9c:	08db      	lsrs	r3, r3, #3
    7e9e:	f363 118f 	bfi	r1, r3, #6, #10
    7ea2:	f012 fbb6 	bl	1a612 <log_0>
			bt_conn_reset_rx_state(conn);
    7ea6:	4620      	mov	r0, r4
    7ea8:	f013 faf1 	bl	1b48e <bt_conn_reset_rx_state>
		conn->rx_len = (sizeof(*hdr) + len) - buf->len;
    7eac:	89ab      	ldrh	r3, [r5, #12]
    7eae:	1af3      	subs	r3, r6, r3
    7eb0:	3304      	adds	r3, #4
    7eb2:	b29b      	uxth	r3, r3
    7eb4:	81e3      	strh	r3, [r4, #14]
		if (conn->rx_len) {
    7eb6:	2b00      	cmp	r3, #0
    7eb8:	d04f      	beq.n	7f5a <bt_conn_recv+0xee>
			conn->rx = buf;
    7eba:	6125      	str	r5, [r4, #16]
}
    7ebc:	bd70      	pop	{r4, r5, r6, pc}
		if (!conn->rx_len) {
    7ebe:	89e3      	ldrh	r3, [r4, #14]
    7ec0:	b9ab      	cbnz	r3, 7eee <bt_conn_recv+0x82>
			BT_ERR("Unexpected L2CAP continuation");
    7ec2:	2301      	movs	r3, #1
    7ec4:	f04f 0100 	mov.w	r1, #0
    7ec8:	f363 0107 	bfi	r1, r3, #0, #8
    7ecc:	4a38      	ldr	r2, [pc, #224]	; (7fb0 <bt_conn_recv+0x144>)
    7ece:	4b39      	ldr	r3, [pc, #228]	; (7fb4 <bt_conn_recv+0x148>)
    7ed0:	483a      	ldr	r0, [pc, #232]	; (7fbc <bt_conn_recv+0x150>)
    7ed2:	1a9b      	subs	r3, r3, r2
    7ed4:	08db      	lsrs	r3, r3, #3
    7ed6:	f363 118f 	bfi	r1, r3, #6, #10
			BT_ERR("L2CAP data overflow");
    7eda:	f012 fb9a 	bl	1a612 <log_0>
			bt_conn_reset_rx_state(conn);
    7ede:	4620      	mov	r0, r4
    7ee0:	f013 fad5 	bl	1b48e <bt_conn_reset_rx_state>
			net_buf_unref(buf);
    7ee4:	4628      	mov	r0, r5
}
    7ee6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			net_buf_unref(buf);
    7eea:	f00e bb19 	b.w	16520 <net_buf_unref>
		if (buf->len > conn->rx_len) {
    7eee:	89ae      	ldrh	r6, [r5, #12]
    7ef0:	42b3      	cmp	r3, r6
    7ef2:	d20c      	bcs.n	7f0e <bt_conn_recv+0xa2>
			BT_ERR("L2CAP data overflow");
    7ef4:	2301      	movs	r3, #1
    7ef6:	f04f 0100 	mov.w	r1, #0
    7efa:	f363 0107 	bfi	r1, r3, #0, #8
    7efe:	4a2c      	ldr	r2, [pc, #176]	; (7fb0 <bt_conn_recv+0x144>)
    7f00:	4b2c      	ldr	r3, [pc, #176]	; (7fb4 <bt_conn_recv+0x148>)
    7f02:	482f      	ldr	r0, [pc, #188]	; (7fc0 <bt_conn_recv+0x154>)
    7f04:	1a9b      	subs	r3, r3, r2
    7f06:	08db      	lsrs	r3, r3, #3
    7f08:	f363 118f 	bfi	r1, r3, #6, #10
    7f0c:	e7e5      	b.n	7eda <bt_conn_recv+0x6e>
		if (buf->len > net_buf_tailroom(conn->rx)) {
    7f0e:	6920      	ldr	r0, [r4, #16]
    7f10:	3008      	adds	r0, #8
    7f12:	f015 fee0 	bl	1dcd6 <net_buf_simple_tailroom>
    7f16:	4286      	cmp	r6, r0
    7f18:	d90c      	bls.n	7f34 <bt_conn_recv+0xc8>
			BT_ERR("Not enough buffer space for L2CAP data");
    7f1a:	2301      	movs	r3, #1
    7f1c:	f04f 0100 	mov.w	r1, #0
    7f20:	f363 0107 	bfi	r1, r3, #0, #8
    7f24:	4a22      	ldr	r2, [pc, #136]	; (7fb0 <bt_conn_recv+0x144>)
    7f26:	4b23      	ldr	r3, [pc, #140]	; (7fb4 <bt_conn_recv+0x148>)
    7f28:	4826      	ldr	r0, [pc, #152]	; (7fc4 <bt_conn_recv+0x158>)
    7f2a:	1a9b      	subs	r3, r3, r2
    7f2c:	08db      	lsrs	r3, r3, #3
    7f2e:	f363 118f 	bfi	r1, r3, #6, #10
    7f32:	e7d2      	b.n	7eda <bt_conn_recv+0x6e>
		net_buf_add_mem(conn->rx, buf->data, buf->len);
    7f34:	6920      	ldr	r0, [r4, #16]
    7f36:	89aa      	ldrh	r2, [r5, #12]
    7f38:	68a9      	ldr	r1, [r5, #8]
    7f3a:	3008      	adds	r0, #8
    7f3c:	f015 fe8c 	bl	1dc58 <net_buf_simple_add_mem>
		conn->rx_len -= buf->len;
    7f40:	89e3      	ldrh	r3, [r4, #14]
    7f42:	89aa      	ldrh	r2, [r5, #12]
    7f44:	1a9b      	subs	r3, r3, r2
    7f46:	81e3      	strh	r3, [r4, #14]
		net_buf_unref(buf);
    7f48:	4628      	mov	r0, r5
    7f4a:	f00e fae9 	bl	16520 <net_buf_unref>
		if (conn->rx_len) {
    7f4e:	89e3      	ldrh	r3, [r4, #14]
    7f50:	2b00      	cmp	r3, #0
    7f52:	d1b3      	bne.n	7ebc <bt_conn_recv+0x50>
		buf = conn->rx;
    7f54:	6925      	ldr	r5, [r4, #16]
		conn->rx_len = 0U;
    7f56:	81e3      	strh	r3, [r4, #14]
		conn->rx = NULL;
    7f58:	6123      	str	r3, [r4, #16]
	len = sys_le16_to_cpu(hdr->len);
    7f5a:	68ab      	ldr	r3, [r5, #8]
	if (sizeof(*hdr) + len != buf->len) {
    7f5c:	89aa      	ldrh	r2, [r5, #12]
    7f5e:	8819      	ldrh	r1, [r3, #0]
    7f60:	1d0b      	adds	r3, r1, #4
    7f62:	4293      	cmp	r3, r2
    7f64:	d01e      	beq.n	7fa4 <bt_conn_recv+0x138>
		BT_ERR("ACL len mismatch (%u != %u)", len, buf->len);
    7f66:	2001      	movs	r0, #1
    7f68:	f04f 0300 	mov.w	r3, #0
    7f6c:	f360 0307 	bfi	r3, r0, #0, #8
    7f70:	4c0f      	ldr	r4, [pc, #60]	; (7fb0 <bt_conn_recv+0x144>)
    7f72:	4810      	ldr	r0, [pc, #64]	; (7fb4 <bt_conn_recv+0x148>)
    7f74:	1b00      	subs	r0, r0, r4
    7f76:	08c0      	lsrs	r0, r0, #3
    7f78:	f360 138f 	bfi	r3, r0, #6, #10
    7f7c:	4812      	ldr	r0, [pc, #72]	; (7fc8 <bt_conn_recv+0x15c>)
    7f7e:	f012 fb69 	bl	1a654 <log_2>
		net_buf_unref(buf);
    7f82:	e7af      	b.n	7ee4 <bt_conn_recv+0x78>
		BT_ERR("Unexpected ACL flags (0x%02x)", flags);
    7f84:	2301      	movs	r3, #1
    7f86:	f04f 0200 	mov.w	r2, #0
    7f8a:	f363 0207 	bfi	r2, r3, #0, #8
    7f8e:	4908      	ldr	r1, [pc, #32]	; (7fb0 <bt_conn_recv+0x144>)
    7f90:	4b08      	ldr	r3, [pc, #32]	; (7fb4 <bt_conn_recv+0x148>)
    7f92:	480e      	ldr	r0, [pc, #56]	; (7fcc <bt_conn_recv+0x160>)
    7f94:	1a5b      	subs	r3, r3, r1
    7f96:	08db      	lsrs	r3, r3, #3
    7f98:	f363 128f 	bfi	r2, r3, #6, #10
    7f9c:	4631      	mov	r1, r6
    7f9e:	f012 fb45 	bl	1a62c <log_1>
		bt_conn_reset_rx_state(conn);
    7fa2:	e79c      	b.n	7ede <bt_conn_recv+0x72>
	bt_l2cap_recv(conn, buf);
    7fa4:	4629      	mov	r1, r5
    7fa6:	4620      	mov	r0, r4
}
    7fa8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_l2cap_recv(conn, buf);
    7fac:	f000 bd0a 	b.w	89c4 <bt_l2cap_recv>
    7fb0:	0001ed28 	.word	0x0001ed28
    7fb4:	0001ed38 	.word	0x0001ed38
    7fb8:	00020d15 	.word	0x00020d15
    7fbc:	00020d32 	.word	0x00020d32
    7fc0:	00020d50 	.word	0x00020d50
    7fc4:	00020d64 	.word	0x00020d64
    7fc8:	00020da9 	.word	0x00020da9
    7fcc:	00020d8b 	.word	0x00020d8b

00007fd0 <bt_conn_send_cb>:
{
    7fd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7fd4:	4698      	mov	r8, r3
	if (conn->state != BT_CONN_CONNECTED) {
    7fd6:	7b43      	ldrb	r3, [r0, #13]
    7fd8:	2b06      	cmp	r3, #6
{
    7fda:	4606      	mov	r6, r0
    7fdc:	460d      	mov	r5, r1
    7fde:	4617      	mov	r7, r2
	if (conn->state != BT_CONN_CONNECTED) {
    7fe0:	d013      	beq.n	800a <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xa>
		BT_ERR("not connected!");
    7fe2:	2301      	movs	r3, #1
    7fe4:	f04f 0100 	mov.w	r1, #0
    7fe8:	f363 0107 	bfi	r1, r3, #0, #8
    7fec:	4a2c      	ldr	r2, [pc, #176]	; (80a0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xa0>)
    7fee:	4b2d      	ldr	r3, [pc, #180]	; (80a4 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xa4>)
    7ff0:	482d      	ldr	r0, [pc, #180]	; (80a8 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xa8>)
    7ff2:	1a9b      	subs	r3, r3, r2
    7ff4:	08db      	lsrs	r3, r3, #3
    7ff6:	f363 118f 	bfi	r1, r3, #6, #10
    7ffa:	f012 fb0a 	bl	1a612 <log_0>
		net_buf_unref(buf);
    7ffe:	4628      	mov	r0, r5
    8000:	f00e fa8e 	bl	16520 <net_buf_unref>
			return -ENOTCONN;
    8004:	f06f 0038 	mvn.w	r0, #56	; 0x38
    8008:	e021      	b.n	804e <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x4e>
	if (cb) {
    800a:	2a00      	cmp	r2, #0
    800c:	d045      	beq.n	809a <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x9a>
	return z_impl_k_current_get();
    800e:	f010 fa33 	bl	18478 <z_impl_k_current_get>
	if (k_current_get() == &k_sys_work_q.thread) {
    8012:	4b26      	ldr	r3, [pc, #152]	; (80ac <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xac>)
    8014:	4283      	cmp	r3, r0
	return z_impl_k_queue_get(queue, timeout);
    8016:	4826      	ldr	r0, [pc, #152]	; (80b0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xb0>)
    8018:	bf0c      	ite	eq
    801a:	2100      	moveq	r1, #0
    801c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
    8020:	f016 f9bd 	bl	1e39e <z_impl_k_queue_get>
    8024:	4604      	mov	r4, r0
		if (!tx) {
    8026:	b9a0      	cbnz	r0, 8052 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x52>
			BT_ERR("Unable to allocate TX context");
    8028:	2301      	movs	r3, #1
    802a:	f04f 0100 	mov.w	r1, #0
    802e:	4a1c      	ldr	r2, [pc, #112]	; (80a0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xa0>)
    8030:	4820      	ldr	r0, [pc, #128]	; (80b4 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xb4>)
    8032:	f363 0107 	bfi	r1, r3, #0, #8
    8036:	4b1b      	ldr	r3, [pc, #108]	; (80a4 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xa4>)
    8038:	1a9b      	subs	r3, r3, r2
    803a:	08db      	lsrs	r3, r3, #3
    803c:	f363 118f 	bfi	r1, r3, #6, #10
    8040:	f012 fae7 	bl	1a612 <log_0>
			net_buf_unref(buf);
    8044:	4628      	mov	r0, r5
    8046:	f00e fa6b 	bl	16520 <net_buf_unref>
			return -ENOBUFS;
    804a:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
    804e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (conn->state != BT_CONN_CONNECTED) {
    8052:	7b73      	ldrb	r3, [r6, #13]
    8054:	2b06      	cmp	r3, #6
    8056:	d014      	beq.n	8082 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x82>
			BT_WARN("Disconnected while allocating context");
    8058:	2302      	movs	r3, #2
    805a:	f04f 0100 	mov.w	r1, #0
    805e:	4a10      	ldr	r2, [pc, #64]	; (80a0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xa0>)
    8060:	4815      	ldr	r0, [pc, #84]	; (80b8 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xb8>)
    8062:	f363 0107 	bfi	r1, r3, #0, #8
    8066:	4b0f      	ldr	r3, [pc, #60]	; (80a4 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xa4>)
    8068:	1a9b      	subs	r3, r3, r2
    806a:	08db      	lsrs	r3, r3, #3
    806c:	f363 118f 	bfi	r1, r3, #6, #10
    8070:	f012 facf 	bl	1a612 <log_0>
			net_buf_unref(buf);
    8074:	4628      	mov	r0, r5
    8076:	f00e fa53 	bl	16520 <net_buf_unref>
			tx_free(tx);
    807a:	4620      	mov	r0, r4
    807c:	f7ff fd86 	bl	7b8c <tx_free>
    8080:	e7c0      	b.n	8004 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x4>
		tx->pending_no_cb = 0U;
    8082:	2300      	movs	r3, #0
		tx->user_data = user_data;
    8084:	e9c0 7801 	strd	r7, r8, [r0, #4]
		tx->pending_no_cb = 0U;
    8088:	60c3      	str	r3, [r0, #12]
		tx_data(buf)->tx = tx;
    808a:	6168      	str	r0, [r5, #20]
	net_buf_put(&conn->tx_queue, buf);
    808c:	f106 0034 	add.w	r0, r6, #52	; 0x34
    8090:	4629      	mov	r1, r5
    8092:	f015 fdca 	bl	1dc2a <net_buf_put>
	return 0;
    8096:	2000      	movs	r0, #0
    8098:	e7d9      	b.n	804e <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x4e>
		tx_data(buf)->tx = NULL;
    809a:	616a      	str	r2, [r5, #20]
    809c:	e7f6      	b.n	808c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x8c>
    809e:	bf00      	nop
    80a0:	0001ed28 	.word	0x0001ed28
    80a4:	0001ed38 	.word	0x0001ed38
    80a8:	00020dc5 	.word	0x00020dc5
    80ac:	20001a70 	.word	0x20001a70
    80b0:	20005c88 	.word	0x20005c88
    80b4:	00020dd4 	.word	0x00020dd4
    80b8:	00020df2 	.word	0x00020df2

000080bc <bt_conn_prepare_events>:
{
	int i, ev_count = 0;

	BT_DBG("");

	conn_change.signaled = 0U;
    80bc:	4b1a      	ldr	r3, [pc, #104]	; (8128 <bt_conn_prepare_events+0x6c>)
{
    80be:	b510      	push	{r4, lr}
	conn_change.signaled = 0U;
    80c0:	2200      	movs	r2, #0
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
    80c2:	2101      	movs	r1, #1
	conn_change.signaled = 0U;
    80c4:	609a      	str	r2, [r3, #8]
{
    80c6:	4604      	mov	r4, r0
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
    80c8:	f010 fcfe 	bl	18ac8 <k_poll_event_init>
			  K_POLL_MODE_NOTIFY_ONLY, &conn_change);

	for (i = 0; i < ARRAY_SIZE(conns); i++) {
		struct bt_conn *conn = &conns[i];

		if (!atomic_get(&conn->ref)) {
    80cc:	4b17      	ldr	r3, [pc, #92]	; (812c <bt_conn_prepare_events+0x70>)
    80ce:	f103 004c 	add.w	r0, r3, #76	; 0x4c
    80d2:	f013 f9cf 	bl	1b474 <atomic_get>
    80d6:	4619      	mov	r1, r3
    80d8:	b908      	cbnz	r0, 80de <bt_conn_prepare_events+0x22>
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
    80da:	2001      	movs	r0, #1
				  &conn->tx_queue);
		events[ev_count++].tag = BT_EVENT_CONN_TX_QUEUE;
	}

	return ev_count;
}
    80dc:	bd10      	pop	{r4, pc}
		if (conn->state == BT_CONN_DISCONNECTED &&
    80de:	7b5a      	ldrb	r2, [r3, #13]
    80e0:	b99a      	cbnz	r2, 810a <bt_conn_prepare_events+0x4e>
    80e2:	f3bf 8f5b 	dmb	ish
    80e6:	1d1a      	adds	r2, r3, #4
    80e8:	e852 0f00 	ldrex	r0, [r2]
    80ec:	f020 0c40 	bic.w	ip, r0, #64	; 0x40
    80f0:	e842 ce00 	strex	lr, ip, [r2]
    80f4:	f1be 0f00 	cmp.w	lr, #0
    80f8:	d1f6      	bne.n	80e8 <bt_conn_prepare_events+0x2c>
    80fa:	f3bf 8f5b 	dmb	ish
    80fe:	0642      	lsls	r2, r0, #25
    8100:	d503      	bpl.n	810a <bt_conn_prepare_events+0x4e>
			conn_cleanup(conn);
    8102:	4618      	mov	r0, r3
    8104:	f7ff fdfc 	bl	7d00 <conn_cleanup>
    8108:	e7e7      	b.n	80da <bt_conn_prepare_events+0x1e>
		if (conn->state != BT_CONN_CONNECTED) {
    810a:	7b4b      	ldrb	r3, [r1, #13]
    810c:	2b06      	cmp	r3, #6
    810e:	d1e4      	bne.n	80da <bt_conn_prepare_events+0x1e>
		k_poll_event_init(&events[ev_count],
    8110:	4b07      	ldr	r3, [pc, #28]	; (8130 <bt_conn_prepare_events+0x74>)
    8112:	f104 0014 	add.w	r0, r4, #20
    8116:	2200      	movs	r2, #0
    8118:	2104      	movs	r1, #4
    811a:	f010 fcd5 	bl	18ac8 <k_poll_event_init>
		events[ev_count++].tag = BT_EVENT_CONN_TX_QUEUE;
    811e:	2301      	movs	r3, #1
    8120:	f884 3020 	strb.w	r3, [r4, #32]
    8124:	2002      	movs	r0, #2
	return ev_count;
    8126:	e7d9      	b.n	80dc <bt_conn_prepare_events+0x20>
    8128:	20005688 	.word	0x20005688
    812c:	200002d4 	.word	0x200002d4
    8130:	20000308 	.word	0x20000308

00008134 <bt_conn_add_le>:
		net_buf_unref(buf);
	}
}

struct bt_conn *bt_conn_add_le(u8_t id, const bt_addr_le_t *peer)
{
    8134:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if (!atomic_get(&conns[i].ref)) {
    8138:	4c1a      	ldr	r4, [pc, #104]	; (81a4 <bt_conn_add_le+0x70>)
    813a:	f104 064c 	add.w	r6, r4, #76	; 0x4c
{
    813e:	4680      	mov	r8, r0
		if (!atomic_get(&conns[i].ref)) {
    8140:	4630      	mov	r0, r6
{
    8142:	460f      	mov	r7, r1
		if (!atomic_get(&conns[i].ref)) {
    8144:	f013 f996 	bl	1b474 <atomic_get>
    8148:	4605      	mov	r5, r0
    814a:	b110      	cbz	r0, 8152 <bt_conn_add_le+0x1e>
	struct bt_conn *conn = conn_new();

	if (!conn) {
		return NULL;
    814c:	2000      	movs	r0, #0
	conn->type = BT_CONN_TYPE_LE;
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
	conn->le.interval_max = BT_GAP_INIT_CONN_INT_MAX;

	return conn;
}
    814e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	(void)memset(conn, 0, sizeof(*conn));
    8152:	4601      	mov	r1, r0
    8154:	22a0      	movs	r2, #160	; 0xa0
    8156:	4620      	mov	r0, r4
    8158:	f012 ff79 	bl	1b04e <memset>
	k_delayed_work_init(&conn->update_work, conn_update_timeout);
    815c:	4912      	ldr	r1, [pc, #72]	; (81a8 <bt_conn_add_le+0x74>)
    815e:	f104 0050 	add.w	r0, r4, #80	; 0x50
    8162:	f016 faf1 	bl	1e748 <k_delayed_work_init>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    8166:	4b11      	ldr	r3, [pc, #68]	; (81ac <bt_conn_add_le+0x78>)
    8168:	62a5      	str	r5, [r4, #40]	; 0x28
    816a:	e9c4 350b 	strd	r3, r5, [r4, #44]	; 0x2c
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    816e:	2501      	movs	r5, #1
    8170:	f3bf 8f5b 	dmb	ish
    8174:	e856 3f00 	ldrex	r3, [r6]
    8178:	e846 5200 	strex	r2, r5, [r6]
    817c:	2a00      	cmp	r2, #0
    817e:	d1f9      	bne.n	8174 <bt_conn_add_le+0x40>
    8180:	f3bf 8f5b 	dmb	ish
	memcpy(dst, src, sizeof(*dst));
}

static inline void bt_addr_le_copy(bt_addr_le_t *dst, const bt_addr_le_t *src)
{
	memcpy(dst, src, sizeof(*dst));
    8184:	2207      	movs	r2, #7
    8186:	4639      	mov	r1, r7
    8188:	f104 0070 	add.w	r0, r4, #112	; 0x70
	conn->id = id;
    818c:	f884 8008 	strb.w	r8, [r4, #8]
    8190:	f012 ff33 	bl	1affa <memcpy>
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
    8194:	4b06      	ldr	r3, [pc, #24]	; (81b0 <bt_conn_add_le+0x7c>)
	conn->sec_level = BT_SECURITY_L1;
    8196:	7265      	strb	r5, [r4, #9]
	conn->required_sec_level = BT_SECURITY_L1;
    8198:	72a5      	strb	r5, [r4, #10]
	conn->type = BT_CONN_TYPE_LE;
    819a:	70a5      	strb	r5, [r4, #2]
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
    819c:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
			conn = &conns[i];
    81a0:	4620      	mov	r0, r4
	return conn;
    81a2:	e7d4      	b.n	814e <bt_conn_add_le+0x1a>
    81a4:	200002d4 	.word	0x200002d4
    81a8:	00008489 	.word	0x00008489
    81ac:	0001b51f 	.word	0x0001b51f
    81b0:	00280018 	.word	0x00280018

000081b4 <bt_conn_set_state>:
		k_sem_give(bt_conn_get_pkts(conn));
	}
}

void bt_conn_set_state(struct bt_conn *conn, bt_conn_state_t state)
{
    81b4:	b570      	push	{r4, r5, r6, lr}
	bt_conn_state_t old_state;

	BT_DBG("%s -> %s", state2str(conn->state), state2str(state));

	if (conn->state == state) {
    81b6:	7b45      	ldrb	r5, [r0, #13]
    81b8:	428d      	cmp	r5, r1
{
    81ba:	4604      	mov	r4, r0
    81bc:	460e      	mov	r6, r1
	if (conn->state == state) {
    81be:	d10f      	bne.n	81e0 <bt_conn_set_state+0x2c>
		BT_WARN("no transition");
    81c0:	2302      	movs	r3, #2
    81c2:	f04f 0100 	mov.w	r1, #0
    81c6:	f363 0107 	bfi	r1, r3, #0, #8
    81ca:	4a59      	ldr	r2, [pc, #356]	; (8330 <bt_conn_set_state+0x17c>)
    81cc:	4b59      	ldr	r3, [pc, #356]	; (8334 <bt_conn_set_state+0x180>)
    81ce:	485a      	ldr	r0, [pc, #360]	; (8338 <bt_conn_set_state+0x184>)
    81d0:	1a9b      	subs	r3, r3, r2
    81d2:	08db      	lsrs	r3, r3, #3
    81d4:	f363 118f 	bfi	r1, r3, #6, #10
	default:
		BT_WARN("no valid (%u) state was set", state);

		break;
	}
}
    81d8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_WARN("no transition");
    81dc:	f012 ba19 	b.w	1a612 <log_0>
	conn->state = state;
    81e0:	7361      	strb	r1, [r4, #13]
	switch (old_state) {
    81e2:	b915      	cbnz	r5, 81ea <bt_conn_set_state+0x36>
#endif /* defined(CONFIG_BT_BREDR) */
}

struct bt_conn *bt_conn_ref(struct bt_conn *conn)
{
	atomic_inc(&conn->ref);
    81e4:	304c      	adds	r0, #76	; 0x4c
    81e6:	f013 f96a 	bl	1b4be <atomic_inc>
	switch (conn->state) {
    81ea:	7b63      	ldrb	r3, [r4, #13]
    81ec:	2b07      	cmp	r3, #7
    81ee:	f200 808d 	bhi.w	830c <bt_conn_set_state+0x158>
    81f2:	e8df f003 	tbb	[pc, r3]
    81f6:	8a1b      	.short	0x8a1b
    81f8:	8a8a8a8a 	.word	0x8a8a8a8a
    81fc:	8a04      	.short	0x8a04
		if (conn->type == BT_CONN_TYPE_SCO) {
    81fe:	78a3      	ldrb	r3, [r4, #2]
    8200:	2b04      	cmp	r3, #4
    8202:	f000 8082 	beq.w	830a <bt_conn_set_state+0x156>
	z_impl_k_queue_init(queue);
    8206:	f104 0034 	add.w	r0, r4, #52	; 0x34
    820a:	f016 f897 	bl	1e33c <z_impl_k_queue_init>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&signal, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(signal, result);
    820e:	2100      	movs	r1, #0
    8210:	484a      	ldr	r0, [pc, #296]	; (833c <bt_conn_set_state+0x188>)
    8212:	f010 fcc1 	bl	18b98 <z_impl_k_poll_signal_raise>
	list->head = NULL;
    8216:	2300      	movs	r3, #0
		bt_l2cap_connected(conn);
    8218:	4620      	mov	r0, r4
	list->tail = NULL;
    821a:	e9c4 3311 	strd	r3, r3, [r4, #68]	; 0x44
    821e:	f000 faff 	bl	8820 <bt_l2cap_connected>
		notify_connected(conn);
    8222:	4620      	mov	r0, r4
}
    8224:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		notify_connected(conn);
    8228:	f7ff bcba 	b.w	7ba0 <notify_connected>
		if (conn->type == BT_CONN_TYPE_SCO) {
    822c:	78a3      	ldrb	r3, [r4, #2]
    822e:	2b04      	cmp	r3, #4
    8230:	d105      	bne.n	823e <bt_conn_set_state+0x8a>
	return conn;
}

void bt_conn_unref(struct bt_conn *conn)
{
	atomic_dec(&conn->ref);
    8232:	f104 004c 	add.w	r0, r4, #76	; 0x4c
}
    8236:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	atomic_dec(&conn->ref);
    823a:	f013 b933 	b.w	1b4a4 <atomic_dec>
		if (old_state == BT_CONN_CONNECTED ||
    823e:	1fab      	subs	r3, r5, #6
    8240:	2b01      	cmp	r3, #1
    8242:	d851      	bhi.n	82e8 <bt_conn_set_state+0x134>
	z_impl_k_sem_give(sem);
    8244:	4d3e      	ldr	r5, [pc, #248]	; (8340 <bt_conn_set_state+0x18c>)
		tx->pending_no_cb = 0U;
    8246:	2600      	movs	r6, #0
	__asm__ volatile(
    8248:	f04f 0320 	mov.w	r3, #32
    824c:	f3ef 8211 	mrs	r2, BASEPRI
    8250:	f383 8811 	msr	BASEPRI, r3
    8254:	f3bf 8f6f 	isb	sy
		if (conn->pending_no_cb) {
    8258:	69e3      	ldr	r3, [r4, #28]
    825a:	b14b      	cbz	r3, 8270 <bt_conn_set_state+0xbc>
			conn->pending_no_cb--;
    825c:	3b01      	subs	r3, #1
    825e:	61e3      	str	r3, [r4, #28]
	__asm__ volatile(
    8260:	f382 8811 	msr	BASEPRI, r2
    8264:	f3bf 8f6f 	isb	sy
    8268:	4628      	mov	r0, r5
    826a:	f010 f90b 	bl	18484 <z_impl_k_sem_give>
    826e:	e7eb      	b.n	8248 <bt_conn_set_state+0x94>
Z_GENLIST_IS_EMPTY(slist)
    8270:	6960      	ldr	r0, [r4, #20]
Z_GENLIST_GET(slist, snode)
    8272:	b128      	cbz	r0, 8280 <bt_conn_set_state+0xcc>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    8274:	69a1      	ldr	r1, [r4, #24]
    8276:	6803      	ldr	r3, [r0, #0]
	list->head = node;
    8278:	6163      	str	r3, [r4, #20]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    827a:	4288      	cmp	r0, r1
	list->tail = node;
    827c:	bf08      	it	eq
    827e:	61a3      	streq	r3, [r4, #24]
    8280:	f382 8811 	msr	BASEPRI, r2
    8284:	f3bf 8f6f 	isb	sy
		if (!node) {
    8288:	b188      	cbz	r0, 82ae <bt_conn_set_state+0xfa>
	__asm__ volatile(
    828a:	f04f 0220 	mov.w	r2, #32
    828e:	f3ef 8311 	mrs	r3, BASEPRI
    8292:	f382 8811 	msr	BASEPRI, r2
    8296:	f3bf 8f6f 	isb	sy
		conn->pending_no_cb = tx->pending_no_cb;
    829a:	68c2      	ldr	r2, [r0, #12]
    829c:	61e2      	str	r2, [r4, #28]
		tx->pending_no_cb = 0U;
    829e:	60c6      	str	r6, [r0, #12]
	__asm__ volatile(
    82a0:	f383 8811 	msr	BASEPRI, r3
    82a4:	f3bf 8f6f 	isb	sy
		tx_free(tx);
    82a8:	f7ff fc70 	bl	7b8c <tx_free>
    82ac:	e7dc      	b.n	8268 <bt_conn_set_state+0xb4>
			tx_notify(conn);
    82ae:	4620      	mov	r0, r4
    82b0:	f013 f912 	bl	1b4d8 <tx_notify>
			if (conn->type == BT_CONN_TYPE_LE) {
    82b4:	78a3      	ldrb	r3, [r4, #2]
    82b6:	2b01      	cmp	r3, #1
    82b8:	d103      	bne.n	82c2 <bt_conn_set_state+0x10e>
				k_delayed_work_cancel(&conn->update_work);
    82ba:	f104 0050 	add.w	r0, r4, #80	; 0x50
    82be:	f016 fa4b 	bl	1e758 <k_delayed_work_cancel>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    82c2:	f3bf 8f5b 	dmb	ish
    82c6:	3404      	adds	r4, #4
    82c8:	e854 3f00 	ldrex	r3, [r4]
    82cc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    82d0:	e844 3200 	strex	r2, r3, [r4]
    82d4:	2a00      	cmp	r2, #0
    82d6:	d1f7      	bne.n	82c8 <bt_conn_set_state+0x114>
    82d8:	f3bf 8f5b 	dmb	ish
	return z_impl_k_poll_signal_raise(signal, result);
    82dc:	2100      	movs	r1, #0
    82de:	4817      	ldr	r0, [pc, #92]	; (833c <bt_conn_set_state+0x188>)
}
    82e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    82e4:	f010 bc58 	b.w	18b98 <z_impl_k_poll_signal_raise>
		} else if (old_state == BT_CONN_CONNECT) {
    82e8:	2d05      	cmp	r5, #5
    82ea:	d103      	bne.n	82f4 <bt_conn_set_state+0x140>
			notify_connected(conn);
    82ec:	4620      	mov	r0, r4
    82ee:	f7ff fc57 	bl	7ba0 <notify_connected>
    82f2:	e79e      	b.n	8232 <bt_conn_set_state+0x7e>
		} else if (old_state == BT_CONN_CONNECT_SCAN) {
    82f4:	2d01      	cmp	r5, #1
    82f6:	d103      	bne.n	8300 <bt_conn_set_state+0x14c>
			if (conn->err) {
    82f8:	7b23      	ldrb	r3, [r4, #12]
    82fa:	2b00      	cmp	r3, #0
    82fc:	d099      	beq.n	8232 <bt_conn_set_state+0x7e>
    82fe:	e7f5      	b.n	82ec <bt_conn_set_state+0x138>
		} else if (old_state == BT_CONN_CONNECT_DIR_ADV) {
    8300:	2d04      	cmp	r5, #4
    8302:	d0f9      	beq.n	82f8 <bt_conn_set_state+0x144>
		} else if (old_state == BT_CONN_CONNECT_AUTO) {
    8304:	3d02      	subs	r5, #2
    8306:	2d01      	cmp	r5, #1
    8308:	d993      	bls.n	8232 <bt_conn_set_state+0x7e>
}
    830a:	bd70      	pop	{r4, r5, r6, pc}
		BT_WARN("no valid (%u) state was set", state);
    830c:	2302      	movs	r3, #2
    830e:	f04f 0200 	mov.w	r2, #0
    8312:	f363 0207 	bfi	r2, r3, #0, #8
    8316:	4906      	ldr	r1, [pc, #24]	; (8330 <bt_conn_set_state+0x17c>)
    8318:	4b06      	ldr	r3, [pc, #24]	; (8334 <bt_conn_set_state+0x180>)
    831a:	480a      	ldr	r0, [pc, #40]	; (8344 <bt_conn_set_state+0x190>)
    831c:	1a5b      	subs	r3, r3, r1
    831e:	08db      	lsrs	r3, r3, #3
    8320:	4631      	mov	r1, r6
    8322:	f363 128f 	bfi	r2, r3, #6, #10
}
    8326:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_WARN("no valid (%u) state was set", state);
    832a:	f012 b97f 	b.w	1a62c <log_1>
    832e:	bf00      	nop
    8330:	0001ed28 	.word	0x0001ed28
    8334:	0001ed38 	.word	0x0001ed38
    8338:	00020e18 	.word	0x00020e18
    833c:	20005688 	.word	0x20005688
    8340:	200054c4 	.word	0x200054c4
    8344:	00020e26 	.word	0x00020e26

00008348 <bt_conn_lookup_handle>:
{
    8348:	b510      	push	{r4, lr}
		if (!atomic_get(&conns[i].ref)) {
    834a:	4c0b      	ldr	r4, [pc, #44]	; (8378 <bt_conn_lookup_handle+0x30>)
{
    834c:	4602      	mov	r2, r0
		if (!atomic_get(&conns[i].ref)) {
    834e:	f104 004c 	add.w	r0, r4, #76	; 0x4c
    8352:	f013 f88f 	bl	1b474 <atomic_get>
    8356:	b158      	cbz	r0, 8370 <bt_conn_lookup_handle+0x28>
		if (conns[i].state != BT_CONN_CONNECTED &&
    8358:	7b63      	ldrb	r3, [r4, #13]
    835a:	3b06      	subs	r3, #6
    835c:	2b01      	cmp	r3, #1
    835e:	d808      	bhi.n	8372 <bt_conn_lookup_handle+0x2a>
		if (conns[i].handle == handle) {
    8360:	8823      	ldrh	r3, [r4, #0]
    8362:	4293      	cmp	r3, r2
    8364:	d105      	bne.n	8372 <bt_conn_lookup_handle+0x2a>
	atomic_inc(&conn->ref);
    8366:	f104 004c 	add.w	r0, r4, #76	; 0x4c
    836a:	f013 f8a8 	bl	1b4be <atomic_inc>
			return bt_conn_ref(&conns[i]);
    836e:	4620      	mov	r0, r4
}
    8370:	bd10      	pop	{r4, pc}
	return NULL;
    8372:	2000      	movs	r0, #0
    8374:	e7fc      	b.n	8370 <bt_conn_lookup_handle+0x28>
    8376:	bf00      	nop
    8378:	200002d4 	.word	0x200002d4

0000837c <bt_conn_lookup_addr_le>:
{
    837c:	b510      	push	{r4, lr}
		if (!atomic_get(&conns[i].ref)) {
    837e:	4c0d      	ldr	r4, [pc, #52]	; (83b4 <bt_conn_lookup_addr_le+0x38>)
{
    8380:	4603      	mov	r3, r0
		if (!atomic_get(&conns[i].ref)) {
    8382:	f104 004c 	add.w	r0, r4, #76	; 0x4c
    8386:	f013 f875 	bl	1b474 <atomic_get>
    838a:	b908      	cbnz	r0, 8390 <bt_conn_lookup_addr_le+0x14>
	return NULL;
    838c:	2000      	movs	r0, #0
}
    838e:	bd10      	pop	{r4, pc}
		if (conns[i].type != BT_CONN_TYPE_LE) {
    8390:	78a2      	ldrb	r2, [r4, #2]
    8392:	2a01      	cmp	r2, #1
    8394:	d1fa      	bne.n	838c <bt_conn_lookup_addr_le+0x10>
		if (conns[i].id == id &&
    8396:	7a22      	ldrb	r2, [r4, #8]
    8398:	429a      	cmp	r2, r3
    839a:	d1f7      	bne.n	838c <bt_conn_lookup_addr_le+0x10>
		    !bt_conn_addr_le_cmp(&conns[i], peer)) {
    839c:	4620      	mov	r0, r4
    839e:	f013 f8f6 	bl	1b58e <bt_conn_addr_le_cmp>
		if (conns[i].id == id &&
    83a2:	2800      	cmp	r0, #0
    83a4:	d1f2      	bne.n	838c <bt_conn_lookup_addr_le+0x10>
	atomic_inc(&conn->ref);
    83a6:	f104 004c 	add.w	r0, r4, #76	; 0x4c
    83aa:	f013 f888 	bl	1b4be <atomic_inc>
		    !bt_conn_addr_le_cmp(&conns[i], peer)) {
    83ae:	4620      	mov	r0, r4
			return bt_conn_ref(&conns[i]);
    83b0:	e7ed      	b.n	838e <bt_conn_lookup_addr_le+0x12>
    83b2:	bf00      	nop
    83b4:	200002d4 	.word	0x200002d4

000083b8 <bt_conn_lookup_state_le>:
{
    83b8:	b538      	push	{r3, r4, r5, lr}
		if (!atomic_get(&conns[i].ref)) {
    83ba:	4c0e      	ldr	r4, [pc, #56]	; (83f4 <bt_conn_lookup_state_le+0x3c>)
{
    83bc:	4603      	mov	r3, r0
		if (!atomic_get(&conns[i].ref)) {
    83be:	f104 004c 	add.w	r0, r4, #76	; 0x4c
{
    83c2:	460d      	mov	r5, r1
		if (!atomic_get(&conns[i].ref)) {
    83c4:	f013 f856 	bl	1b474 <atomic_get>
    83c8:	b908      	cbnz	r0, 83ce <bt_conn_lookup_state_le+0x16>
	return NULL;
    83ca:	2000      	movs	r0, #0
}
    83cc:	bd38      	pop	{r3, r4, r5, pc}
		if (conns[i].type != BT_CONN_TYPE_LE) {
    83ce:	78a2      	ldrb	r2, [r4, #2]
    83d0:	2a01      	cmp	r2, #1
    83d2:	d1fa      	bne.n	83ca <bt_conn_lookup_state_le+0x12>
		if (peer && bt_conn_addr_le_cmp(&conns[i], peer)) {
    83d4:	b93b      	cbnz	r3, 83e6 <bt_conn_lookup_state_le+0x2e>
		if (conns[i].state == state) {
    83d6:	7b63      	ldrb	r3, [r4, #13]
    83d8:	42ab      	cmp	r3, r5
    83da:	d1f6      	bne.n	83ca <bt_conn_lookup_state_le+0x12>
	atomic_inc(&conn->ref);
    83dc:	4806      	ldr	r0, [pc, #24]	; (83f8 <bt_conn_lookup_state_le+0x40>)
    83de:	f013 f86e 	bl	1b4be <atomic_inc>
			return bt_conn_ref(&conns[i]);
    83e2:	4804      	ldr	r0, [pc, #16]	; (83f4 <bt_conn_lookup_state_le+0x3c>)
    83e4:	e7f2      	b.n	83cc <bt_conn_lookup_state_le+0x14>
		if (peer && bt_conn_addr_le_cmp(&conns[i], peer)) {
    83e6:	4619      	mov	r1, r3
    83e8:	4620      	mov	r0, r4
    83ea:	f013 f8d0 	bl	1b58e <bt_conn_addr_le_cmp>
    83ee:	2800      	cmp	r0, #0
    83f0:	d0f1      	beq.n	83d6 <bt_conn_lookup_state_le+0x1e>
    83f2:	e7ea      	b.n	83ca <bt_conn_lookup_state_le+0x12>
    83f4:	200002d4 	.word	0x200002d4
    83f8:	20000320 	.word	0x20000320

000083fc <bt_conn_foreach>:
		if (!atomic_get(&conns[i].ref)) {
    83fc:	4b09      	ldr	r3, [pc, #36]	; (8424 <bt_conn_foreach+0x28>)
{
    83fe:	b570      	push	{r4, r5, r6, lr}
    8400:	4605      	mov	r5, r0
		if (!atomic_get(&conns[i].ref)) {
    8402:	f103 004c 	add.w	r0, r3, #76	; 0x4c
{
    8406:	460c      	mov	r4, r1
		if (!atomic_get(&conns[i].ref)) {
    8408:	f013 f834 	bl	1b474 <atomic_get>
    840c:	b140      	cbz	r0, 8420 <bt_conn_foreach+0x24>
		if (!(conns[i].type & type)) {
    840e:	7899      	ldrb	r1, [r3, #2]
    8410:	4229      	tst	r1, r5
    8412:	d005      	beq.n	8420 <bt_conn_foreach+0x24>
		func(&conns[i], data);
    8414:	4618      	mov	r0, r3
    8416:	4611      	mov	r1, r2
    8418:	4623      	mov	r3, r4
}
    841a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		func(&conns[i], data);
    841e:	4718      	bx	r3
}
    8420:	bd70      	pop	{r4, r5, r6, pc}
    8422:	bf00      	nop
    8424:	200002d4 	.word	0x200002d4

00008428 <send_conn_le_param_update>:
{
    8428:	b538      	push	{r3, r4, r5, lr}
    842a:	4604      	mov	r4, r0
	if (!bt_le_conn_params_valid(param)) {
    842c:	4608      	mov	r0, r1
{
    842e:	460d      	mov	r5, r1
	if (!bt_le_conn_params_valid(param)) {
    8430:	f012 ffc5 	bl	1b3be <bt_le_conn_params_valid>
    8434:	b310      	cbz	r0, 847c <send_conn_le_param_update+0x54>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
    8436:	4b13      	ldr	r3, [pc, #76]	; (8484 <send_conn_le_param_update+0x5c>)
    8438:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
    843c:	079a      	lsls	r2, r3, #30
    843e:	d407      	bmi.n	8450 <send_conn_le_param_update+0x28>
	     !atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_L2CAP)) ||
    8440:	78e3      	ldrb	r3, [r4, #3]
    8442:	b17b      	cbz	r3, 8464 <send_conn_le_param_update+0x3c>
	return bt_l2cap_update_conn_param(conn, param);
    8444:	4629      	mov	r1, r5
    8446:	4620      	mov	r0, r4
}
    8448:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return bt_l2cap_update_conn_param(conn, param);
    844c:	f000 bafc 	b.w	8a48 <bt_l2cap_update_conn_param>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
    8450:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
    8454:	079b      	lsls	r3, r3, #30
    8456:	d5f3      	bpl.n	8440 <send_conn_le_param_update+0x18>
	     !atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_L2CAP)) ||
    8458:	210a      	movs	r1, #10
    845a:	1d20      	adds	r0, r4, #4
    845c:	f013 f810 	bl	1b480 <atomic_test_bit>
	     BT_FEAT_LE_CONN_PARAM_REQ_PROC(conn->le.features) &&
    8460:	2800      	cmp	r0, #0
    8462:	d1ed      	bne.n	8440 <send_conn_le_param_update+0x18>
		rc = bt_conn_le_conn_update(conn, param);
    8464:	4629      	mov	r1, r5
    8466:	4620      	mov	r0, r4
    8468:	f013 f8e9 	bl	1b63e <bt_conn_le_conn_update>
		if (rc == 0) {
    846c:	b928      	cbnz	r0, 847a <send_conn_le_param_update+0x52>
			conn->le.pending_latency = param->latency;
    846e:	88ab      	ldrh	r3, [r5, #4]
    8470:	f8a4 3090 	strh.w	r3, [r4, #144]	; 0x90
			conn->le.pending_timeout = param->timeout;
    8474:	88eb      	ldrh	r3, [r5, #6]
    8476:	f8a4 3092 	strh.w	r3, [r4, #146]	; 0x92
}
    847a:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
    847c:	f06f 0015 	mvn.w	r0, #21
    8480:	e7fb      	b.n	847a <send_conn_le_param_update+0x52>
    8482:	bf00      	nop
    8484:	20005438 	.word	0x20005438

00008488 <conn_update_timeout>:
{
    8488:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	if (conn->state == BT_CONN_DISCONNECTED) {
    848a:	f810 3c43 	ldrb.w	r3, [r0, #-67]
{
    848e:	4604      	mov	r4, r0
	struct bt_conn *conn = CONTAINER_OF(work, struct bt_conn, update_work);
    8490:	f1a0 0650 	sub.w	r6, r0, #80	; 0x50
	if (conn->state == BT_CONN_DISCONNECTED) {
    8494:	b9f3      	cbnz	r3, 84d4 <conn_update_timeout+0x4c>
		bt_l2cap_disconnected(conn);
    8496:	4630      	mov	r0, r6
    8498:	f013 f936 	bl	1b708 <bt_l2cap_disconnected>
	for (cb = callback_list; cb; cb = cb->_next) {
    849c:	4b25      	ldr	r3, [pc, #148]	; (8534 <conn_update_timeout+0xac>)
    849e:	681d      	ldr	r5, [r3, #0]
    84a0:	b985      	cbnz	r5, 84c4 <conn_update_timeout+0x3c>
	atomic_dec(&conn->ref);
    84a2:	1f20      	subs	r0, r4, #4
    84a4:	f012 fffe 	bl	1b4a4 <atomic_dec>
		    atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    84a8:	2108      	movs	r1, #8
    84aa:	4823      	ldr	r0, [pc, #140]	; (8538 <conn_update_timeout+0xb0>)
    84ac:	f012 ffe8 	bl	1b480 <atomic_test_bit>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    84b0:	b130      	cbz	r0, 84c0 <conn_update_timeout+0x38>
		    !atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING)) {
    84b2:	2105      	movs	r1, #5
    84b4:	4820      	ldr	r0, [pc, #128]	; (8538 <conn_update_timeout+0xb0>)
    84b6:	f012 ffe3 	bl	1b480 <atomic_test_bit>
		    atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    84ba:	b908      	cbnz	r0, 84c0 <conn_update_timeout+0x38>
			bt_le_adv_resume();
    84bc:	f7ff f8c4 	bl	7648 <bt_le_adv_resume>
}
    84c0:	b004      	add	sp, #16
    84c2:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->disconnected) {
    84c4:	686b      	ldr	r3, [r5, #4]
    84c6:	b11b      	cbz	r3, 84d0 <conn_update_timeout+0x48>
			cb->disconnected(conn, conn->err);
    84c8:	f814 1c44 	ldrb.w	r1, [r4, #-68]
    84cc:	4630      	mov	r0, r6
    84ce:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
    84d0:	69ad      	ldr	r5, [r5, #24]
    84d2:	e7e5      	b.n	84a0 <conn_update_timeout+0x18>
	if (conn->type != BT_CONN_TYPE_LE) {
    84d4:	f810 3c4e 	ldrb.w	r3, [r0, #-78]
    84d8:	2b01      	cmp	r3, #1
    84da:	d1f1      	bne.n	84c0 <conn_update_timeout+0x38>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    84dc:	f3bf 8f5b 	dmb	ish
		if (atomic_test_and_clear_bit(conn->flags,
    84e0:	f1a0 054c 	sub.w	r5, r0, #76	; 0x4c
    84e4:	e855 3f00 	ldrex	r3, [r5]
    84e8:	f423 7200 	bic.w	r2, r3, #512	; 0x200
    84ec:	e845 2100 	strex	r1, r2, [r5]
    84f0:	2900      	cmp	r1, #0
    84f2:	d1f7      	bne.n	84e4 <conn_update_timeout+0x5c>
    84f4:	f3bf 8f5b 	dmb	ish
    84f8:	059b      	lsls	r3, r3, #22
    84fa:	d514      	bpl.n	8526 <conn_update_timeout+0x9e>
			param = BT_LE_CONN_PARAM(conn->le.interval_min,
    84fc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    84fe:	9300      	str	r3, [sp, #0]
    8500:	6c23      	ldr	r3, [r4, #64]	; 0x40
    8502:	9301      	str	r3, [sp, #4]
			send_conn_le_param_update(conn, param);
    8504:	4669      	mov	r1, sp
			send_conn_le_param_update(conn, param);
    8506:	4630      	mov	r0, r6
    8508:	f7ff ff8e 	bl	8428 <send_conn_le_param_update>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    850c:	f3bf 8f5b 	dmb	ish
    8510:	e855 3f00 	ldrex	r3, [r5]
    8514:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    8518:	e845 3200 	strex	r2, r3, [r5]
    851c:	2a00      	cmp	r2, #0
    851e:	d1f7      	bne.n	8510 <conn_update_timeout+0x88>
    8520:	f3bf 8f5b 	dmb	ish
    8524:	e7cc      	b.n	84c0 <conn_update_timeout+0x38>
			param = BT_LE_CONN_PARAM(
    8526:	4a05      	ldr	r2, [pc, #20]	; (853c <conn_update_timeout+0xb4>)
    8528:	6851      	ldr	r1, [r2, #4]
    852a:	6810      	ldr	r0, [r2, #0]
    852c:	ab02      	add	r3, sp, #8
    852e:	c303      	stmia	r3!, {r0, r1}
			send_conn_le_param_update(conn, param);
    8530:	a902      	add	r1, sp, #8
    8532:	e7e8      	b.n	8506 <conn_update_timeout+0x7e>
    8534:	200002a0 	.word	0x200002a0
    8538:	200054a8 	.word	0x200054a8
    853c:	0001eed8 	.word	0x0001eed8

00008540 <bt_conn_create_pdu_timeout>:
	} else {
#if defined(CONFIG_NET_BUF_LOG)
		buf = net_buf_alloc_fixed_debug(pool, timeout, func,
							line);
#else
		buf = net_buf_alloc(pool, timeout);
    8540:	4b10      	ldr	r3, [pc, #64]	; (8584 <bt_conn_create_pdu_timeout+0x44>)
{
    8542:	b570      	push	{r4, r5, r6, lr}
		buf = net_buf_alloc(pool, timeout);
    8544:	2800      	cmp	r0, #0
    8546:	bf08      	it	eq
    8548:	4618      	moveq	r0, r3
{
    854a:	460e      	mov	r6, r1
		buf = net_buf_alloc(pool, timeout);
    854c:	4611      	mov	r1, r2
{
    854e:	4615      	mov	r5, r2
		buf = net_buf_alloc(pool, timeout);
    8550:	f015 fb48 	bl	1dbe4 <net_buf_alloc_fixed>
#endif
	}

	if (!buf) {
    8554:	4604      	mov	r4, r0
    8556:	b980      	cbnz	r0, 857a <bt_conn_create_pdu_timeout+0x3a>
		BT_WARN("Unable to allocate buffer: timeout %d", timeout);
    8558:	2302      	movs	r3, #2
    855a:	f04f 0200 	mov.w	r2, #0
    855e:	f363 0207 	bfi	r2, r3, #0, #8
    8562:	4909      	ldr	r1, [pc, #36]	; (8588 <bt_conn_create_pdu_timeout+0x48>)
    8564:	4b09      	ldr	r3, [pc, #36]	; (858c <bt_conn_create_pdu_timeout+0x4c>)
    8566:	480a      	ldr	r0, [pc, #40]	; (8590 <bt_conn_create_pdu_timeout+0x50>)
    8568:	1a5b      	subs	r3, r3, r1
    856a:	08db      	lsrs	r3, r3, #3
    856c:	f363 128f 	bfi	r2, r3, #6, #10
    8570:	4629      	mov	r1, r5
    8572:	f012 f85b 	bl	1a62c <log_1>

	reserve += sizeof(struct bt_hci_acl_hdr) + BT_BUF_RESERVE;
	net_buf_reserve(buf, reserve);

	return buf;
}
    8576:	4620      	mov	r0, r4
    8578:	bd70      	pop	{r4, r5, r6, pc}
	net_buf_reserve(buf, reserve);
    857a:	1d31      	adds	r1, r6, #4
    857c:	3008      	adds	r0, #8
    857e:	f015 fb50 	bl	1dc22 <net_buf_simple_reserve>
	return buf;
    8582:	e7f8      	b.n	8576 <bt_conn_create_pdu_timeout+0x36>
    8584:	20005ca8 	.word	0x20005ca8
    8588:	0001ed28 	.word	0x0001ed28
    858c:	0001ed38 	.word	0x0001ed38
    8590:	00020cc6 	.word	0x00020cc6

00008594 <bt_conn_create_frag_timeout>:
	return bt_conn_create_pdu_timeout(pool, reserve, timeout);
    8594:	460a      	mov	r2, r1
    8596:	4601      	mov	r1, r0
    8598:	4801      	ldr	r0, [pc, #4]	; (85a0 <bt_conn_create_frag_timeout+0xc>)
    859a:	f7ff bfd1 	b.w	8540 <bt_conn_create_pdu_timeout>
    859e:	bf00      	nop
    85a0:	20005d08 	.word	0x20005d08

000085a4 <create_frag.isra.11>:
static struct net_buf *create_frag(struct bt_conn *conn, struct net_buf *buf)
    85a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    85a8:	4606      	mov	r6, r0
    85aa:	460c      	mov	r4, r1
	frag = bt_conn_create_frag(0);
    85ac:	2000      	movs	r0, #0
    85ae:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    85b2:	f7ff ffef 	bl	8594 <bt_conn_create_frag_timeout>
	if (conn->state != BT_CONN_CONNECTED) {
    85b6:	7833      	ldrb	r3, [r6, #0]
    85b8:	2b06      	cmp	r3, #6
	frag = bt_conn_create_frag(0);
    85ba:	4605      	mov	r5, r0
	if (conn->state != BT_CONN_CONNECTED) {
    85bc:	f04f 0600 	mov.w	r6, #0
    85c0:	d005      	beq.n	85ce <create_frag.isra.11+0x2a>
		net_buf_unref(frag);
    85c2:	f00d ffad 	bl	16520 <net_buf_unref>
		return NULL;
    85c6:	4635      	mov	r5, r6
}
    85c8:	4628      	mov	r0, r5
    85ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	tx_data(frag)->tx = NULL;
    85ce:	6146      	str	r6, [r0, #20]
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
    85d0:	f100 0708 	add.w	r7, r0, #8
	return bt_dev.le.mtu;
    85d4:	4e0c      	ldr	r6, [pc, #48]	; (8608 <create_frag.isra.11+0x64>)
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
    85d6:	4638      	mov	r0, r7
    85d8:	f8b6 8088 	ldrh.w	r8, [r6, #136]	; 0x88
    85dc:	f015 fb7b 	bl	1dcd6 <net_buf_simple_tailroom>
    85e0:	4580      	cmp	r8, r0
    85e2:	d20c      	bcs.n	85fe <create_frag.isra.11+0x5a>
	return bt_dev.le.mtu;
    85e4:	f8b6 6088 	ldrh.w	r6, [r6, #136]	; 0x88
	net_buf_add_mem(frag, buf->data, frag_len);
    85e8:	f854 1f08 	ldr.w	r1, [r4, #8]!
    85ec:	4632      	mov	r2, r6
    85ee:	4638      	mov	r0, r7
    85f0:	f015 fb32 	bl	1dc58 <net_buf_simple_add_mem>
	net_buf_pull(buf, frag_len);
    85f4:	4631      	mov	r1, r6
    85f6:	4620      	mov	r0, r4
    85f8:	f015 fb51 	bl	1dc9e <net_buf_simple_pull>
	return frag;
    85fc:	e7e4      	b.n	85c8 <create_frag.isra.11+0x24>
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
    85fe:	4638      	mov	r0, r7
    8600:	f015 fb69 	bl	1dcd6 <net_buf_simple_tailroom>
    8604:	b286      	uxth	r6, r0
    8606:	e7ef      	b.n	85e8 <create_frag.isra.11+0x44>
    8608:	20005438 	.word	0x20005438

0000860c <bt_conn_process_tx>:
{
    860c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (conn->state == BT_CONN_DISCONNECTED &&
    860e:	7b43      	ldrb	r3, [r0, #13]
{
    8610:	4605      	mov	r5, r0
	if (conn->state == BT_CONN_DISCONNECTED &&
    8612:	b993      	cbnz	r3, 863a <bt_conn_process_tx+0x2e>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    8614:	f3bf 8f5b 	dmb	ish
    8618:	1d03      	adds	r3, r0, #4
    861a:	e853 2f00 	ldrex	r2, [r3]
    861e:	f022 0140 	bic.w	r1, r2, #64	; 0x40
    8622:	e843 1400 	strex	r4, r1, [r3]
    8626:	2c00      	cmp	r4, #0
    8628:	d1f7      	bne.n	861a <bt_conn_process_tx+0xe>
    862a:	f3bf 8f5b 	dmb	ish
    862e:	0653      	lsls	r3, r2, #25
    8630:	d503      	bpl.n	863a <bt_conn_process_tx+0x2e>
}
    8632:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		conn_cleanup(conn);
    8636:	f7ff bb63 	b.w	7d00 <conn_cleanup>
	buf = net_buf_get(&conn->tx_queue, K_NO_WAIT);
    863a:	2100      	movs	r1, #0
    863c:	f105 0034 	add.w	r0, r5, #52	; 0x34
    8640:	f015 fad6 	bl	1dbf0 <net_buf_get>
	BT_ASSERT(buf);
    8644:	4604      	mov	r4, r0
    8646:	b960      	cbnz	r0, 8662 <bt_conn_process_tx+0x56>
    8648:	f240 6316 	movw	r3, #1558	; 0x616
    864c:	4a1f      	ldr	r2, [pc, #124]	; (86cc <bt_conn_process_tx+0xc0>)
    864e:	4920      	ldr	r1, [pc, #128]	; (86d0 <bt_conn_process_tx+0xc4>)
    8650:	4820      	ldr	r0, [pc, #128]	; (86d4 <bt_conn_process_tx+0xc8>)
    8652:	f010 fe8f 	bl	19374 <printk>
    8656:	4040      	eors	r0, r0
    8658:	f380 8811 	msr	BASEPRI, r0
    865c:	f04f 0003 	mov.w	r0, #3
    8660:	df02      	svc	2
	return bt_dev.le.mtu;
    8662:	4e1d      	ldr	r6, [pc, #116]	; (86d8 <bt_conn_process_tx+0xcc>)
	if (buf->len <= conn_mtu(conn)) {
    8664:	89a1      	ldrh	r1, [r4, #12]
    8666:	f8b6 2088 	ldrh.w	r2, [r6, #136]	; 0x88
    866a:	4291      	cmp	r1, r2
    866c:	d807      	bhi.n	867e <bt_conn_process_tx+0x72>
		return send_frag(conn, buf, BT_ACL_START_NO_FLUSH, false);
    866e:	2300      	movs	r3, #0
    8670:	461a      	mov	r2, r3
	return send_frag(conn, buf, BT_ACL_CONT, false);
    8672:	4621      	mov	r1, r4
    8674:	4628      	mov	r0, r5
    8676:	f7ff faa9 	bl	7bcc <send_frag>
	if (!send_buf(conn, buf)) {
    867a:	b140      	cbz	r0, 868e <bt_conn_process_tx+0x82>
}
    867c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	frag = create_frag(conn, buf);
    867e:	f105 070d 	add.w	r7, r5, #13
    8682:	4621      	mov	r1, r4
    8684:	4638      	mov	r0, r7
    8686:	f7ff ff8d 	bl	85a4 <create_frag.isra.11>
	if (!frag) {
    868a:	4601      	mov	r1, r0
    868c:	b920      	cbnz	r0, 8698 <bt_conn_process_tx+0x8c>
		net_buf_unref(buf);
    868e:	4620      	mov	r0, r4
}
    8690:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		net_buf_unref(buf);
    8694:	f00d bf44 	b.w	16520 <net_buf_unref>
	if (!send_frag(conn, frag, BT_ACL_START_NO_FLUSH, true)) {
    8698:	2301      	movs	r3, #1
    869a:	2200      	movs	r2, #0
		if (!send_frag(conn, frag, BT_ACL_CONT, true)) {
    869c:	4628      	mov	r0, r5
    869e:	f7ff fa95 	bl	7bcc <send_frag>
    86a2:	2800      	cmp	r0, #0
    86a4:	d0f3      	beq.n	868e <bt_conn_process_tx+0x82>
	while (buf->len > conn_mtu(conn)) {
    86a6:	89a2      	ldrh	r2, [r4, #12]
    86a8:	f8b6 3088 	ldrh.w	r3, [r6, #136]	; 0x88
    86ac:	429a      	cmp	r2, r3
    86ae:	d802      	bhi.n	86b6 <bt_conn_process_tx+0xaa>
	return send_frag(conn, buf, BT_ACL_CONT, false);
    86b0:	2300      	movs	r3, #0
    86b2:	2201      	movs	r2, #1
    86b4:	e7dd      	b.n	8672 <bt_conn_process_tx+0x66>
		frag = create_frag(conn, buf);
    86b6:	4621      	mov	r1, r4
    86b8:	4638      	mov	r0, r7
    86ba:	f7ff ff73 	bl	85a4 <create_frag.isra.11>
		if (!frag) {
    86be:	4601      	mov	r1, r0
    86c0:	2800      	cmp	r0, #0
    86c2:	d0e4      	beq.n	868e <bt_conn_process_tx+0x82>
		if (!send_frag(conn, frag, BT_ACL_CONT, true)) {
    86c4:	2301      	movs	r3, #1
    86c6:	461a      	mov	r2, r3
    86c8:	e7e8      	b.n	869c <bt_conn_process_tx+0x90>
    86ca:	bf00      	nop
    86cc:	00020cec 	.word	0x00020cec
    86d0:	00022590 	.word	0x00022590
    86d4:	00020aa4 	.word	0x00020aa4
    86d8:	20005438 	.word	0x20005438

000086dc <bt_conn_index>:
}
#endif /* CONFIG_BT_SMP || CONFIG_BT_BREDR */

u8_t bt_conn_index(struct bt_conn *conn)
{
	u8_t index = conn - conns;
    86dc:	4b03      	ldr	r3, [pc, #12]	; (86ec <bt_conn_index+0x10>)
    86de:	1ac0      	subs	r0, r0, r3
    86e0:	4b03      	ldr	r3, [pc, #12]	; (86f0 <bt_conn_index+0x14>)
    86e2:	1140      	asrs	r0, r0, #5
    86e4:	4358      	muls	r0, r3

	__ASSERT(index < CONFIG_BT_MAX_CONN, "Invalid bt_conn pointer");
	return index;
}
    86e6:	b2c0      	uxtb	r0, r0
    86e8:	4770      	bx	lr
    86ea:	bf00      	nop
    86ec:	200002d4 	.word	0x200002d4
    86f0:	cccccccd 	.word	0xcccccccd

000086f4 <bt_conn_init>:

	return bt_conn_ref(conn);
}

int bt_conn_init(void)
{
    86f4:	b510      	push	{r4, lr}
	int err, i;

	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
		k_fifo_put(&free_tx, &conn_tx[i]);
    86f6:	490b      	ldr	r1, [pc, #44]	; (8724 <bt_conn_init+0x30>)
    86f8:	480b      	ldr	r0, [pc, #44]	; (8728 <bt_conn_init+0x34>)
    86fa:	f015 fe27 	bl	1e34c <k_queue_append>
    86fe:	490b      	ldr	r1, [pc, #44]	; (872c <bt_conn_init+0x38>)
    8700:	4809      	ldr	r0, [pc, #36]	; (8728 <bt_conn_init+0x34>)
    8702:	f015 fe23 	bl	1e34c <k_queue_append>
    8706:	490a      	ldr	r1, [pc, #40]	; (8730 <bt_conn_init+0x3c>)
    8708:	4807      	ldr	r0, [pc, #28]	; (8728 <bt_conn_init+0x34>)
    870a:	f015 fe1f 	bl	1e34c <k_queue_append>
	}

	bt_att_init();
    870e:	f013 fb05 	bl	1bd1c <bt_att_init>

	err = bt_smp_init();
    8712:	f004 ff69 	bl	d5e8 <bt_smp_init>
	if (err) {
    8716:	4604      	mov	r4, r0
    8718:	b908      	cbnz	r0, 871e <bt_conn_init+0x2a>
		return err;
	}

	bt_l2cap_init();
    871a:	f013 f848 	bl	1b7ae <bt_l2cap_init>
			}
		}
	}

	return 0;
}
    871e:	4620      	mov	r0, r4
    8720:	bd10      	pop	{r4, pc}
    8722:	bf00      	nop
    8724:	200002a4 	.word	0x200002a4
    8728:	20005c88 	.word	0x20005c88
    872c:	200002b4 	.word	0x200002b4
    8730:	200002c4 	.word	0x200002c4

00008734 <l2cap_accept>:
	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
		struct bt_l2cap *l2cap = &bt_l2cap_pool[i];

		if (l2cap->chan.chan.conn) {
    8734:	4a0d      	ldr	r2, [pc, #52]	; (876c <l2cap_accept+0x38>)
{
    8736:	b508      	push	{r3, lr}
		if (l2cap->chan.chan.conn) {
    8738:	6813      	ldr	r3, [r2, #0]
    873a:	b923      	cbnz	r3, 8746 <l2cap_accept+0x12>
			continue;
		}

		l2cap->chan.chan.ops = &ops;
    873c:	480c      	ldr	r0, [pc, #48]	; (8770 <l2cap_accept+0x3c>)
    873e:	6050      	str	r0, [r2, #4]
		*chan = &l2cap->chan.chan;
    8740:	600a      	str	r2, [r1, #0]

		return 0;
    8742:	4618      	mov	r0, r3
	}

	BT_ERR("No available L2CAP context for conn %p", conn);

	return -ENOMEM;
}
    8744:	bd08      	pop	{r3, pc}
	BT_ERR("No available L2CAP context for conn %p", conn);
    8746:	2301      	movs	r3, #1
    8748:	f04f 0200 	mov.w	r2, #0
    874c:	f363 0207 	bfi	r2, r3, #0, #8
    8750:	4908      	ldr	r1, [pc, #32]	; (8774 <l2cap_accept+0x40>)
    8752:	4b09      	ldr	r3, [pc, #36]	; (8778 <l2cap_accept+0x44>)
    8754:	1a5b      	subs	r3, r3, r1
    8756:	08db      	lsrs	r3, r3, #3
    8758:	4601      	mov	r1, r0
    875a:	f363 128f 	bfi	r2, r3, #6, #10
    875e:	4807      	ldr	r0, [pc, #28]	; (877c <l2cap_accept+0x48>)
    8760:	f011 ff64 	bl	1a62c <log_1>
	return -ENOMEM;
    8764:	f06f 000b 	mvn.w	r0, #11
    8768:	e7ec      	b.n	8744 <l2cap_accept+0x10>
    876a:	bf00      	nop
    876c:	20000374 	.word	0x20000374
    8770:	0001f3f0 	.word	0x0001f3f0
    8774:	0001ed28 	.word	0x0001ed28
    8778:	0001ee00 	.word	0x0001ee00
    877c:	00020ecd 	.word	0x00020ecd

00008780 <l2cap_create_le_sig_pdu.isra.8>:
static struct net_buf *l2cap_create_le_sig_pdu(struct net_buf *buf,
    8780:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8782:	4605      	mov	r5, r0
    8784:	460f      	mov	r7, r1
    8786:	4616      	mov	r6, r2
	return bt_conn_create_pdu_timeout(pool,
    8788:	2104      	movs	r1, #4
    878a:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
    878e:	2000      	movs	r0, #0
    8790:	f7ff fed6 	bl	8540 <bt_conn_create_pdu_timeout>
	if (!buf) {
    8794:	4604      	mov	r4, r0
    8796:	b980      	cbnz	r0, 87ba <l2cap_create_le_sig_pdu.isra.8+0x3a>
		BT_ERR("Unable to allocate buffer for op 0x%02x", code);
    8798:	2301      	movs	r3, #1
    879a:	f04f 0200 	mov.w	r2, #0
    879e:	f363 0207 	bfi	r2, r3, #0, #8
    87a2:	490a      	ldr	r1, [pc, #40]	; (87cc <l2cap_create_le_sig_pdu.isra.8+0x4c>)
    87a4:	4b0a      	ldr	r3, [pc, #40]	; (87d0 <l2cap_create_le_sig_pdu.isra.8+0x50>)
    87a6:	480b      	ldr	r0, [pc, #44]	; (87d4 <l2cap_create_le_sig_pdu.isra.8+0x54>)
    87a8:	1a5b      	subs	r3, r3, r1
    87aa:	08db      	lsrs	r3, r3, #3
    87ac:	f363 128f 	bfi	r2, r3, #6, #10
    87b0:	4629      	mov	r1, r5
    87b2:	f011 ff3b 	bl	1a62c <log_1>
}
    87b6:	4620      	mov	r0, r4
    87b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	hdr = net_buf_add(buf, sizeof(*hdr));
    87ba:	2104      	movs	r1, #4
    87bc:	3008      	adds	r0, #8
    87be:	f015 fa45 	bl	1dc4c <net_buf_simple_add>
	hdr->code = code;
    87c2:	7005      	strb	r5, [r0, #0]
	hdr->ident = ident;
    87c4:	7047      	strb	r7, [r0, #1]
	hdr->len = sys_cpu_to_le16(len);
    87c6:	8046      	strh	r6, [r0, #2]
	return buf;
    87c8:	e7f5      	b.n	87b6 <l2cap_create_le_sig_pdu.isra.8+0x36>
    87ca:	bf00      	nop
    87cc:	0001ed28 	.word	0x0001ed28
    87d0:	0001ee00 	.word	0x0001ee00
    87d4:	00020ef4 	.word	0x00020ef4

000087d8 <l2cap_rtx_timeout>:
{
    87d8:	b538      	push	{r3, r4, r5, lr}
	BT_ERR("chan %p timeout", chan);
    87da:	f04f 0200 	mov.w	r2, #0
    87de:	2301      	movs	r3, #1
    87e0:	f363 0207 	bfi	r2, r3, #0, #8
    87e4:	490b      	ldr	r1, [pc, #44]	; (8814 <l2cap_rtx_timeout+0x3c>)
    87e6:	4b0c      	ldr	r3, [pc, #48]	; (8818 <l2cap_rtx_timeout+0x40>)
    87e8:	1a5b      	subs	r3, r3, r1
	struct bt_l2cap_le_chan *chan = LE_CHAN_RTX(work);
    87ea:	f1a0 0410 	sub.w	r4, r0, #16
    87ee:	08db      	lsrs	r3, r3, #3
{
    87f0:	4605      	mov	r5, r0
	BT_ERR("chan %p timeout", chan);
    87f2:	f363 128f 	bfi	r2, r3, #6, #10
    87f6:	4621      	mov	r1, r4
    87f8:	4808      	ldr	r0, [pc, #32]	; (881c <l2cap_rtx_timeout+0x44>)
    87fa:	f011 ff17 	bl	1a62c <log_1>
	bt_l2cap_chan_remove(chan->chan.conn, &chan->chan);
    87fe:	f855 0c10 	ldr.w	r0, [r5, #-16]
    8802:	4621      	mov	r1, r4
    8804:	f012 ff45 	bl	1b692 <bt_l2cap_chan_remove>
	bt_l2cap_chan_del(&chan->chan);
    8808:	4620      	mov	r0, r4
}
    880a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_l2cap_chan_del(&chan->chan);
    880e:	f012 bf60 	b.w	1b6d2 <bt_l2cap_chan_del>
    8812:	bf00      	nop
    8814:	0001ed28 	.word	0x0001ed28
    8818:	0001ee00 	.word	0x0001ee00
    881c:	00020fb6 	.word	0x00020fb6

00008820 <bt_l2cap_connected>:
{
    8820:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
    8824:	4e21      	ldr	r6, [pc, #132]	; (88ac <bt_l2cap_connected+0x8c>)
    8826:	4f22      	ldr	r7, [pc, #136]	; (88b0 <bt_l2cap_connected+0x90>)
	k_delayed_work_init(&chan->rtx_work, l2cap_rtx_timeout);
    8828:	f8df 8088 	ldr.w	r8, [pc, #136]	; 88b4 <bt_l2cap_connected+0x94>
{
    882c:	4605      	mov	r5, r0
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
    882e:	42be      	cmp	r6, r7
    8830:	d302      	bcc.n	8838 <bt_l2cap_connected+0x18>
}
    8832:	b002      	add	sp, #8
    8834:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (fchan->accept(conn, &chan) < 0) {
    8838:	6873      	ldr	r3, [r6, #4]
    883a:	a901      	add	r1, sp, #4
    883c:	4628      	mov	r0, r5
    883e:	4798      	blx	r3
    8840:	2800      	cmp	r0, #0
    8842:	db2d      	blt.n	88a0 <bt_l2cap_connected+0x80>
		ch = BT_L2CAP_LE_CHAN(chan);
    8844:	9c01      	ldr	r4, [sp, #4]
		ch->rx.cid = fchan->cid;
    8846:	8833      	ldrh	r3, [r6, #0]
    8848:	86a3      	strh	r3, [r4, #52]	; 0x34
		ch->tx.cid = fchan->cid;
    884a:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
	k_delayed_work_init(&chan->rtx_work, l2cap_rtx_timeout);
    884e:	4641      	mov	r1, r8
    8850:	f104 0010 	add.w	r0, r4, #16
    8854:	f015 ff78 	bl	1e748 <k_delayed_work_init>
	parent->next = child;
    8858:	2300      	movs	r3, #0
    885a:	60a3      	str	r3, [r4, #8]
Z_GENLIST_APPEND(slist, snode)
    885c:	6ca9      	ldr	r1, [r5, #72]	; 0x48
	sys_slist_append(&conn->channels, &chan->node);
    885e:	f104 0208 	add.w	r2, r4, #8
    8862:	b9f9      	cbnz	r1, 88a4 <bt_l2cap_connected+0x84>
	list->head = node;
    8864:	e9c5 2211 	strd	r2, r2, [r5, #68]	; 0x44
		if (chan->ops->connected) {
    8868:	9801      	ldr	r0, [sp, #4]
	chan->destroy = destroy;
    886a:	60e3      	str	r3, [r4, #12]
		if (chan->ops->connected) {
    886c:	6843      	ldr	r3, [r0, #4]
	chan->conn = conn;
    886e:	6025      	str	r5, [r4, #0]
		if (chan->ops->connected) {
    8870:	681b      	ldr	r3, [r3, #0]
    8872:	b103      	cbz	r3, 8876 <bt_l2cap_connected+0x56>
			chan->ops->connected(chan);
    8874:	4798      	blx	r3
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    8876:	9b01      	ldr	r3, [sp, #4]
    8878:	f3bf 8f5b 	dmb	ish
    887c:	3330      	adds	r3, #48	; 0x30
    887e:	e853 2f00 	ldrex	r2, [r3]
    8882:	f042 0201 	orr.w	r2, r2, #1
    8886:	e843 2100 	strex	r1, r2, [r3]
    888a:	2900      	cmp	r1, #0
    888c:	d1f7      	bne.n	887e <bt_l2cap_connected+0x5e>
    888e:	f3bf 8f5b 	dmb	ish
		if (chan->ops->status) {
    8892:	9801      	ldr	r0, [sp, #4]
    8894:	6843      	ldr	r3, [r0, #4]
    8896:	699b      	ldr	r3, [r3, #24]
    8898:	b113      	cbz	r3, 88a0 <bt_l2cap_connected+0x80>
			chan->ops->status(chan, chan->status);
    889a:	f100 0130 	add.w	r1, r0, #48	; 0x30
    889e:	4798      	blx	r3
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
    88a0:	3608      	adds	r6, #8
    88a2:	e7c4      	b.n	882e <bt_l2cap_connected+0xe>
	parent->next = child;
    88a4:	600a      	str	r2, [r1, #0]
	list->tail = node;
    88a6:	64aa      	str	r2, [r5, #72]	; 0x48
    88a8:	e7de      	b.n	8868 <bt_l2cap_connected+0x48>
    88aa:	bf00      	nop
    88ac:	0001ec84 	.word	0x0001ec84
    88b0:	0001ec9c 	.word	0x0001ec9c
    88b4:	000087d9 	.word	0x000087d9

000088b8 <l2cap_recv>:
	if (buf->len < sizeof(*hdr)) {
    88b8:	898b      	ldrh	r3, [r1, #12]
    88ba:	2b03      	cmp	r3, #3
{
    88bc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    88be:	4605      	mov	r5, r0
    88c0:	460e      	mov	r6, r1
	if (buf->len < sizeof(*hdr)) {
    88c2:	d80e      	bhi.n	88e2 <l2cap_recv+0x2a>
		BT_ERR("Too small L2CAP signaling PDU");
    88c4:	2301      	movs	r3, #1
    88c6:	f04f 0100 	mov.w	r1, #0
    88ca:	f363 0107 	bfi	r1, r3, #0, #8
    88ce:	4a36      	ldr	r2, [pc, #216]	; (89a8 <l2cap_recv+0xf0>)
    88d0:	4b36      	ldr	r3, [pc, #216]	; (89ac <l2cap_recv+0xf4>)
    88d2:	4837      	ldr	r0, [pc, #220]	; (89b0 <l2cap_recv+0xf8>)
    88d4:	1a9b      	subs	r3, r3, r2
    88d6:	08db      	lsrs	r3, r3, #3
    88d8:	f363 118f 	bfi	r1, r3, #6, #10
		BT_ERR("Invalid ident value in L2CAP PDU");
    88dc:	f011 fe99 	bl	1a612 <log_0>
		return 0;
    88e0:	e017      	b.n	8912 <l2cap_recv+0x5a>
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    88e2:	2104      	movs	r1, #4
    88e4:	f106 0008 	add.w	r0, r6, #8
    88e8:	f015 f9e1 	bl	1dcae <net_buf_simple_pull_mem>
	if (buf->len != len) {
    88ec:	89b1      	ldrh	r1, [r6, #12]
	len = sys_le16_to_cpu(hdr->len);
    88ee:	8842      	ldrh	r2, [r0, #2]
	if (buf->len != len) {
    88f0:	428a      	cmp	r2, r1
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    88f2:	4604      	mov	r4, r0
	if (buf->len != len) {
    88f4:	d010      	beq.n	8918 <l2cap_recv+0x60>
		BT_ERR("L2CAP length mismatch (%u != %u)", buf->len, len);
    88f6:	2001      	movs	r0, #1
    88f8:	f04f 0300 	mov.w	r3, #0
    88fc:	f360 0307 	bfi	r3, r0, #0, #8
    8900:	4c29      	ldr	r4, [pc, #164]	; (89a8 <l2cap_recv+0xf0>)
    8902:	482a      	ldr	r0, [pc, #168]	; (89ac <l2cap_recv+0xf4>)
    8904:	1b00      	subs	r0, r0, r4
    8906:	08c0      	lsrs	r0, r0, #3
    8908:	f360 138f 	bfi	r3, r0, #6, #10
    890c:	4829      	ldr	r0, [pc, #164]	; (89b4 <l2cap_recv+0xfc>)
    890e:	f011 fea1 	bl	1a654 <log_2>
}
    8912:	2000      	movs	r0, #0
    8914:	b002      	add	sp, #8
    8916:	bd70      	pop	{r4, r5, r6, pc}
	if (!hdr->ident) {
    8918:	7843      	ldrb	r3, [r0, #1]
    891a:	b963      	cbnz	r3, 8936 <l2cap_recv+0x7e>
		BT_ERR("Invalid ident value in L2CAP PDU");
    891c:	2301      	movs	r3, #1
    891e:	f04f 0100 	mov.w	r1, #0
    8922:	f363 0107 	bfi	r1, r3, #0, #8
    8926:	4a20      	ldr	r2, [pc, #128]	; (89a8 <l2cap_recv+0xf0>)
    8928:	4b20      	ldr	r3, [pc, #128]	; (89ac <l2cap_recv+0xf4>)
    892a:	4823      	ldr	r0, [pc, #140]	; (89b8 <l2cap_recv+0x100>)
    892c:	1a9b      	subs	r3, r3, r2
    892e:	08db      	lsrs	r3, r3, #3
    8930:	f363 118f 	bfi	r1, r3, #6, #10
    8934:	e7d2      	b.n	88dc <l2cap_recv+0x24>
	switch (hdr->code) {
    8936:	7801      	ldrb	r1, [r0, #0]
    8938:	2901      	cmp	r1, #1
    893a:	d0ea      	beq.n	8912 <l2cap_recv+0x5a>
    893c:	2913      	cmp	r1, #19
    893e:	d10e      	bne.n	895e <l2cap_recv+0xa6>
	if (buf->len < sizeof(*rsp)) {
    8940:	2a01      	cmp	r2, #1
    8942:	d8e6      	bhi.n	8912 <l2cap_recv+0x5a>
		BT_ERR("Too small LE conn param rsp");
    8944:	2301      	movs	r3, #1
    8946:	f04f 0100 	mov.w	r1, #0
    894a:	f363 0107 	bfi	r1, r3, #0, #8
    894e:	4a16      	ldr	r2, [pc, #88]	; (89a8 <l2cap_recv+0xf0>)
    8950:	4b16      	ldr	r3, [pc, #88]	; (89ac <l2cap_recv+0xf4>)
    8952:	481a      	ldr	r0, [pc, #104]	; (89bc <l2cap_recv+0x104>)
    8954:	1a9b      	subs	r3, r3, r2
    8956:	08db      	lsrs	r3, r3, #3
    8958:	f363 118f 	bfi	r1, r3, #6, #10
    895c:	e7be      	b.n	88dc <l2cap_recv+0x24>
		BT_WARN("Unknown L2CAP PDU code 0x%02x", hdr->code);
    895e:	2302      	movs	r3, #2
    8960:	f04f 0200 	mov.w	r2, #0
    8964:	f363 0207 	bfi	r2, r3, #0, #8
    8968:	480f      	ldr	r0, [pc, #60]	; (89a8 <l2cap_recv+0xf0>)
    896a:	4b10      	ldr	r3, [pc, #64]	; (89ac <l2cap_recv+0xf4>)
    896c:	1a1b      	subs	r3, r3, r0
    896e:	08db      	lsrs	r3, r3, #3
    8970:	f363 128f 	bfi	r2, r3, #6, #10
    8974:	4812      	ldr	r0, [pc, #72]	; (89c0 <l2cap_recv+0x108>)
    8976:	f011 fe59 	bl	1a62c <log_1>
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
    897a:	7861      	ldrb	r1, [r4, #1]
		l2cap_send_reject(chan->conn, hdr->ident,
    897c:	682d      	ldr	r5, [r5, #0]
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
    897e:	2202      	movs	r2, #2
    8980:	2001      	movs	r0, #1
    8982:	f7ff fefd 	bl	8780 <l2cap_create_le_sig_pdu.isra.8>
	if (!buf) {
    8986:	4604      	mov	r4, r0
    8988:	2800      	cmp	r0, #0
    898a:	d0c2      	beq.n	8912 <l2cap_recv+0x5a>
	rej = net_buf_add(buf, sizeof(*rej));
    898c:	2102      	movs	r1, #2
    898e:	3008      	adds	r0, #8
    8990:	f015 f95c 	bl	1dc4c <net_buf_simple_add>
	rej->reason = sys_cpu_to_le16(reason);
    8994:	2300      	movs	r3, #0
    8996:	7003      	strb	r3, [r0, #0]
    8998:	7043      	strb	r3, [r0, #1]
		     bt_conn_tx_cb_t cb, void *user_data);

static inline void bt_l2cap_send(struct bt_conn *conn, u16_t cid,
				 struct net_buf *buf)
{
	bt_l2cap_send_cb(conn, cid, buf, NULL, NULL);
    899a:	4622      	mov	r2, r4
    899c:	9300      	str	r3, [sp, #0]
    899e:	2105      	movs	r1, #5
    89a0:	4628      	mov	r0, r5
    89a2:	f012 fed6 	bl	1b752 <bt_l2cap_send_cb>
    89a6:	e7b4      	b.n	8912 <l2cap_recv+0x5a>
    89a8:	0001ed28 	.word	0x0001ed28
    89ac:	0001ee00 	.word	0x0001ee00
    89b0:	00020f1c 	.word	0x00020f1c
    89b4:	00020f3a 	.word	0x00020f3a
    89b8:	00020f5b 	.word	0x00020f5b
    89bc:	00020f7c 	.word	0x00020f7c
    89c0:	00020f98 	.word	0x00020f98

000089c4 <bt_l2cap_recv>:
	if (buf->len < sizeof(*hdr)) {
    89c4:	898b      	ldrh	r3, [r1, #12]
    89c6:	2b03      	cmp	r3, #3
{
    89c8:	b570      	push	{r4, r5, r6, lr}
    89ca:	4606      	mov	r6, r0
    89cc:	460c      	mov	r4, r1
	if (buf->len < sizeof(*hdr)) {
    89ce:	d812      	bhi.n	89f6 <bt_l2cap_recv+0x32>
		BT_ERR("Too small L2CAP PDU received");
    89d0:	2301      	movs	r3, #1
    89d2:	f04f 0100 	mov.w	r1, #0
    89d6:	f363 0107 	bfi	r1, r3, #0, #8
    89da:	4a17      	ldr	r2, [pc, #92]	; (8a38 <bt_l2cap_recv+0x74>)
    89dc:	4b17      	ldr	r3, [pc, #92]	; (8a3c <bt_l2cap_recv+0x78>)
    89de:	4818      	ldr	r0, [pc, #96]	; (8a40 <bt_l2cap_recv+0x7c>)
    89e0:	1a9b      	subs	r3, r3, r2
    89e2:	08db      	lsrs	r3, r3, #3
    89e4:	f363 118f 	bfi	r1, r3, #6, #10
    89e8:	f011 fe13 	bl	1a612 <log_0>
	net_buf_unref(buf);
    89ec:	4620      	mov	r0, r4
}
    89ee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	net_buf_unref(buf);
    89f2:	f00d bd95 	b.w	16520 <net_buf_unref>
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    89f6:	2104      	movs	r1, #4
    89f8:	f104 0008 	add.w	r0, r4, #8
    89fc:	f015 f957 	bl	1dcae <net_buf_simple_pull_mem>
	cid = sys_le16_to_cpu(hdr->cid);
    8a00:	8845      	ldrh	r5, [r0, #2]
	chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
    8a02:	4630      	mov	r0, r6
    8a04:	4629      	mov	r1, r5
    8a06:	f012 fec8 	bl	1b79a <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
    8a0a:	b978      	cbnz	r0, 8a2c <bt_l2cap_recv+0x68>
		BT_WARN("Ignoring data for unknown CID 0x%04x", cid);
    8a0c:	2302      	movs	r3, #2
    8a0e:	f04f 0200 	mov.w	r2, #0
    8a12:	f363 0207 	bfi	r2, r3, #0, #8
    8a16:	4908      	ldr	r1, [pc, #32]	; (8a38 <bt_l2cap_recv+0x74>)
    8a18:	4b08      	ldr	r3, [pc, #32]	; (8a3c <bt_l2cap_recv+0x78>)
    8a1a:	480a      	ldr	r0, [pc, #40]	; (8a44 <bt_l2cap_recv+0x80>)
    8a1c:	1a5b      	subs	r3, r3, r1
    8a1e:	08db      	lsrs	r3, r3, #3
    8a20:	f363 128f 	bfi	r2, r3, #6, #10
    8a24:	4629      	mov	r1, r5
    8a26:	f011 fe01 	bl	1a62c <log_1>
		net_buf_unref(buf);
    8a2a:	e7df      	b.n	89ec <bt_l2cap_recv+0x28>
	chan->ops->recv(chan, buf);
    8a2c:	6843      	ldr	r3, [r0, #4]
    8a2e:	4621      	mov	r1, r4
    8a30:	691b      	ldr	r3, [r3, #16]
    8a32:	4798      	blx	r3
    8a34:	e7da      	b.n	89ec <bt_l2cap_recv+0x28>
    8a36:	bf00      	nop
    8a38:	0001ed28 	.word	0x0001ed28
    8a3c:	0001ee00 	.word	0x0001ee00
    8a40:	00020e8b 	.word	0x00020e8b
    8a44:	00020ea8 	.word	0x00020ea8

00008a48 <bt_l2cap_update_conn_param>:
{
    8a48:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ident++;
    8a4a:	4b15      	ldr	r3, [pc, #84]	; (8aa0 <bt_l2cap_update_conn_param+0x58>)
    8a4c:	781a      	ldrb	r2, [r3, #0]
    8a4e:	3201      	adds	r2, #1
	if (!ident) {
    8a50:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
		ident++;
    8a54:	bf08      	it	eq
    8a56:	2201      	moveq	r2, #1
    8a58:	701a      	strb	r2, [r3, #0]
{
    8a5a:	4605      	mov	r5, r0
    8a5c:	460c      	mov	r4, r1
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CONN_PARAM_REQ,
    8a5e:	2208      	movs	r2, #8
    8a60:	7819      	ldrb	r1, [r3, #0]
    8a62:	2012      	movs	r0, #18
    8a64:	f7ff fe8c 	bl	8780 <l2cap_create_le_sig_pdu.isra.8>
	if (!buf) {
    8a68:	4606      	mov	r6, r0
    8a6a:	b1b0      	cbz	r0, 8a9a <bt_l2cap_update_conn_param+0x52>
	req = net_buf_add(buf, sizeof(*req));
    8a6c:	2108      	movs	r1, #8
    8a6e:	4408      	add	r0, r1
    8a70:	f015 f8ec 	bl	1dc4c <net_buf_simple_add>
	req->min_interval = sys_cpu_to_le16(param->interval_min);
    8a74:	8823      	ldrh	r3, [r4, #0]
    8a76:	8003      	strh	r3, [r0, #0]
	req->max_interval = sys_cpu_to_le16(param->interval_max);
    8a78:	8863      	ldrh	r3, [r4, #2]
    8a7a:	8043      	strh	r3, [r0, #2]
	req->latency = sys_cpu_to_le16(param->latency);
    8a7c:	88a3      	ldrh	r3, [r4, #4]
    8a7e:	8083      	strh	r3, [r0, #4]
	req->timeout = sys_cpu_to_le16(param->timeout);
    8a80:	88e3      	ldrh	r3, [r4, #6]
    8a82:	80c3      	strh	r3, [r0, #6]
    8a84:	2400      	movs	r4, #0
    8a86:	9400      	str	r4, [sp, #0]
    8a88:	4623      	mov	r3, r4
    8a8a:	4632      	mov	r2, r6
    8a8c:	2105      	movs	r1, #5
    8a8e:	4628      	mov	r0, r5
    8a90:	f012 fe5f 	bl	1b752 <bt_l2cap_send_cb>
	return 0;
    8a94:	4620      	mov	r0, r4
}
    8a96:	b002      	add	sp, #8
    8a98:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOMEM;
    8a9a:	f06f 000b 	mvn.w	r0, #11
    8a9e:	e7fa      	b.n	8a96 <bt_l2cap_update_conn_param+0x4e>
    8aa0:	20001c54 	.word	0x20001c54

00008aa4 <find_type_cb>:
	u8_t value_len;
	u8_t err;
};

static u8_t find_type_cb(const struct bt_gatt_attr *attr, void *user_data)
{
    8aa4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct find_type_data *data = user_data;
	struct bt_att *att = data->att;
    8aa8:	680e      	ldr	r6, [r1, #0]
{
    8aaa:	b092      	sub	sp, #72	; 0x48
    8aac:	4605      	mov	r5, r0
    8aae:	460c      	mov	r4, r1
	struct bt_conn *conn = att->chan.chan.conn;
	int read;
	u8_t uuid[16];

	/* Skip secondary services */
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
    8ab0:	2700      	movs	r7, #0
    8ab2:	f642 0301 	movw	r3, #10241	; 0x2801
    8ab6:	a902      	add	r1, sp, #8
    8ab8:	6800      	ldr	r0, [r0, #0]
	struct bt_conn *conn = att->chan.chan.conn;
    8aba:	f8d6 8000 	ldr.w	r8, [r6]
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
    8abe:	f88d 7008 	strb.w	r7, [sp, #8]
    8ac2:	f8ad 300a 	strh.w	r3, [sp, #10]
    8ac6:	f012 fb85 	bl	1b1d4 <bt_uuid_cmp>
    8aca:	2800      	cmp	r0, #0
    8acc:	d03e      	beq.n	8b4c <find_type_cb+0xa8>
		goto skip;
	}

	/* Update group end_handle if not a primary service */
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY)) {
    8ace:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    8ad2:	a903      	add	r1, sp, #12
    8ad4:	6828      	ldr	r0, [r5, #0]
    8ad6:	f88d 700c 	strb.w	r7, [sp, #12]
    8ada:	f8ad 300e 	strh.w	r3, [sp, #14]
    8ade:	f012 fb79 	bl	1b1d4 <bt_uuid_cmp>
    8ae2:	b150      	cbz	r0, 8afa <find_type_cb+0x56>
		if (data->group &&
    8ae4:	68a3      	ldr	r3, [r4, #8]
    8ae6:	b123      	cbz	r3, 8af2 <find_type_cb+0x4e>
		    attr->handle > sys_le16_to_cpu(data->group->end_handle)) {
    8ae8:	8a2a      	ldrh	r2, [r5, #16]
		if (data->group &&
    8aea:	8859      	ldrh	r1, [r3, #2]
    8aec:	4291      	cmp	r1, r2
    8aee:	d200      	bcs.n	8af2 <find_type_cb+0x4e>
			data->group->end_handle = sys_cpu_to_le16(attr->handle);
    8af0:	805a      	strh	r2, [r3, #2]
		}
		return BT_GATT_ITER_CONTINUE;
    8af2:	2001      	movs	r0, #1
	return BT_GATT_ITER_CONTINUE;

skip:
	data->group = NULL;
	return BT_GATT_ITER_CONTINUE;
}
    8af4:	b012      	add	sp, #72	; 0x48
    8af6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (att->chan.tx.mtu - data->buf->len < sizeof(*data->group)) {
    8afa:	6862      	ldr	r2, [r4, #4]
    8afc:	f8b6 3042 	ldrh.w	r3, [r6, #66]	; 0x42
    8b00:	8992      	ldrh	r2, [r2, #12]
    8b02:	1a9b      	subs	r3, r3, r2
    8b04:	2b03      	cmp	r3, #3
    8b06:	d9f5      	bls.n	8af4 <find_type_cb+0x50>
	read = attr->read(conn, attr, uuid, sizeof(uuid), 0);
    8b08:	2310      	movs	r3, #16
    8b0a:	9000      	str	r0, [sp, #0]
    8b0c:	686e      	ldr	r6, [r5, #4]
    8b0e:	eb0d 0203 	add.w	r2, sp, r3
    8b12:	4629      	mov	r1, r5
    8b14:	4640      	mov	r0, r8
    8b16:	47b0      	blx	r6
	if (read < 0) {
    8b18:	1e06      	subs	r6, r0, #0
    8b1a:	db17      	blt.n	8b4c <find_type_cb+0xa8>
	if (read != data->value_len) {
    8b1c:	7c22      	ldrb	r2, [r4, #16]
    8b1e:	68e0      	ldr	r0, [r4, #12]
    8b20:	4296      	cmp	r6, r2
    8b22:	d03c      	beq.n	8b9e <find_type_cb+0xfa>
		if (!bt_uuid_create(&recvd_uuid.uuid, data->value, data->value_len)) {
    8b24:	4601      	mov	r1, r0
    8b26:	a80d      	add	r0, sp, #52	; 0x34
    8b28:	f012 fb7e 	bl	1b228 <bt_uuid_create>
    8b2c:	b988      	cbnz	r0, 8b52 <find_type_cb+0xae>
			BT_WARN("Unable to create UUID: size %u", data->value_len);
    8b2e:	2302      	movs	r3, #2
    8b30:	f04f 0200 	mov.w	r2, #0
    8b34:	f363 0207 	bfi	r2, r3, #0, #8
    8b38:	491b      	ldr	r1, [pc, #108]	; (8ba8 <find_type_cb+0x104>)
    8b3a:	4b1c      	ldr	r3, [pc, #112]	; (8bac <find_type_cb+0x108>)
    8b3c:	481c      	ldr	r0, [pc, #112]	; (8bb0 <find_type_cb+0x10c>)
    8b3e:	1a5b      	subs	r3, r3, r1
    8b40:	08db      	lsrs	r3, r3, #3
    8b42:	7c21      	ldrb	r1, [r4, #16]
    8b44:	f363 128f 	bfi	r2, r3, #6, #10
			BT_WARN("Unable to create UUID: size %d", read);
    8b48:	f011 fd70 	bl	1a62c <log_1>
	data->group = NULL;
    8b4c:	2300      	movs	r3, #0
    8b4e:	60a3      	str	r3, [r4, #8]
	return BT_GATT_ITER_CONTINUE;
    8b50:	e7cf      	b.n	8af2 <find_type_cb+0x4e>
		if (!bt_uuid_create(&ref_uuid.uuid, uuid, read)) {
    8b52:	b2f2      	uxtb	r2, r6
    8b54:	a904      	add	r1, sp, #16
    8b56:	a808      	add	r0, sp, #32
    8b58:	f012 fb66 	bl	1b228 <bt_uuid_create>
    8b5c:	b968      	cbnz	r0, 8b7a <find_type_cb+0xd6>
			BT_WARN("Unable to create UUID: size %d", read);
    8b5e:	2302      	movs	r3, #2
    8b60:	f04f 0200 	mov.w	r2, #0
    8b64:	f363 0207 	bfi	r2, r3, #0, #8
    8b68:	490f      	ldr	r1, [pc, #60]	; (8ba8 <find_type_cb+0x104>)
    8b6a:	4b10      	ldr	r3, [pc, #64]	; (8bac <find_type_cb+0x108>)
    8b6c:	4811      	ldr	r0, [pc, #68]	; (8bb4 <find_type_cb+0x110>)
    8b6e:	1a5b      	subs	r3, r3, r1
    8b70:	08db      	lsrs	r3, r3, #3
    8b72:	f363 128f 	bfi	r2, r3, #6, #10
    8b76:	4631      	mov	r1, r6
    8b78:	e7e6      	b.n	8b48 <find_type_cb+0xa4>
		if (bt_uuid_cmp(&recvd_uuid.uuid, &ref_uuid.uuid)) {
    8b7a:	a908      	add	r1, sp, #32
    8b7c:	a80d      	add	r0, sp, #52	; 0x34
    8b7e:	f012 fb29 	bl	1b1d4 <bt_uuid_cmp>
	} else if (memcmp(data->value, uuid, read)) {
    8b82:	2800      	cmp	r0, #0
    8b84:	d1e2      	bne.n	8b4c <find_type_cb+0xa8>
	data->group = net_buf_add(data->buf, sizeof(*data->group));
    8b86:	6860      	ldr	r0, [r4, #4]
	data->err = 0x00;
    8b88:	2300      	movs	r3, #0
    8b8a:	7463      	strb	r3, [r4, #17]
	data->group = net_buf_add(data->buf, sizeof(*data->group));
    8b8c:	2104      	movs	r1, #4
    8b8e:	3008      	adds	r0, #8
    8b90:	f015 f85c 	bl	1dc4c <net_buf_simple_add>
	data->group->start_handle = sys_cpu_to_le16(attr->handle);
    8b94:	8a2b      	ldrh	r3, [r5, #16]
	data->group = net_buf_add(data->buf, sizeof(*data->group));
    8b96:	60a0      	str	r0, [r4, #8]
	data->group->start_handle = sys_cpu_to_le16(attr->handle);
    8b98:	8003      	strh	r3, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(attr->handle);
    8b9a:	8043      	strh	r3, [r0, #2]
	return BT_GATT_ITER_CONTINUE;
    8b9c:	e7a9      	b.n	8af2 <find_type_cb+0x4e>
	} else if (memcmp(data->value, uuid, read)) {
    8b9e:	4632      	mov	r2, r6
    8ba0:	a904      	add	r1, sp, #16
    8ba2:	f012 fa1a 	bl	1afda <memcmp>
    8ba6:	e7ec      	b.n	8b82 <find_type_cb+0xde>
    8ba8:	0001ed28 	.word	0x0001ed28
    8bac:	0001ed30 	.word	0x0001ed30
    8bb0:	00021154 	.word	0x00021154
    8bb4:	00021173 	.word	0x00021173

00008bb8 <att_cb.isra.6>:
static bt_conn_tx_cb_t att_cb(struct net_buf *buf)
    8bb8:	b508      	push	{r3, lr}
	switch (att_op_get_type(buf->data[0])) {
    8bba:	7800      	ldrb	r0, [r0, #0]
    8bbc:	f012 fdf8 	bl	1b7b0 <att_op_get_type>
    8bc0:	3801      	subs	r0, #1
    8bc2:	b2c0      	uxtb	r0, r0
    8bc4:	2804      	cmp	r0, #4
    8bc6:	bf96      	itet	ls
    8bc8:	4b02      	ldrls	r3, [pc, #8]	; (8bd4 <att_cb.isra.6+0x1c>)
    8bca:	4803      	ldrhi	r0, [pc, #12]	; (8bd8 <att_cb.isra.6+0x20>)
    8bcc:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
}
    8bd0:	bd08      	pop	{r3, pc}
    8bd2:	bf00      	nop
    8bd4:	0001f40c 	.word	0x0001f40c
    8bd8:	0001bb09 	.word	0x0001bb09

00008bdc <att_send>:
{
    8bdc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    8be0:	4698      	mov	r8, r3
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
    8be2:	688b      	ldr	r3, [r1, #8]
    8be4:	781b      	ldrb	r3, [r3, #0]
    8be6:	2bd2      	cmp	r3, #210	; 0xd2
{
    8be8:	4607      	mov	r7, r0
    8bea:	460c      	mov	r4, r1
    8bec:	4616      	mov	r6, r2
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
    8bee:	d118      	bne.n	8c22 <att_send+0x46>
		err = bt_smp_sign(conn, buf);
    8bf0:	f004 fb44 	bl	d27c <bt_smp_sign>
		if (err) {
    8bf4:	4605      	mov	r5, r0
    8bf6:	b1a0      	cbz	r0, 8c22 <att_send+0x46>
			BT_ERR("Error signing data");
    8bf8:	2301      	movs	r3, #1
    8bfa:	f04f 0100 	mov.w	r1, #0
    8bfe:	f363 0107 	bfi	r1, r3, #0, #8
    8c02:	4a0f      	ldr	r2, [pc, #60]	; (8c40 <att_send+0x64>)
    8c04:	4b0f      	ldr	r3, [pc, #60]	; (8c44 <att_send+0x68>)
    8c06:	4810      	ldr	r0, [pc, #64]	; (8c48 <att_send+0x6c>)
    8c08:	1a9b      	subs	r3, r3, r2
    8c0a:	08db      	lsrs	r3, r3, #3
    8c0c:	f363 118f 	bfi	r1, r3, #6, #10
    8c10:	f011 fcff 	bl	1a612 <log_0>
			net_buf_unref(buf);
    8c14:	4620      	mov	r0, r4
    8c16:	f00d fc83 	bl	16520 <net_buf_unref>
}
    8c1a:	4628      	mov	r0, r5
    8c1c:	b002      	add	sp, #8
    8c1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf,
    8c22:	b91e      	cbnz	r6, 8c2c <att_send+0x50>
				cb ? cb : att_cb(buf),
    8c24:	68a0      	ldr	r0, [r4, #8]
    8c26:	f7ff ffc7 	bl	8bb8 <att_cb.isra.6>
    8c2a:	4606      	mov	r6, r0
	return bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf,
    8c2c:	f8cd 8000 	str.w	r8, [sp]
    8c30:	4633      	mov	r3, r6
    8c32:	4622      	mov	r2, r4
    8c34:	2104      	movs	r1, #4
    8c36:	4638      	mov	r0, r7
    8c38:	f012 fd8b 	bl	1b752 <bt_l2cap_send_cb>
    8c3c:	4605      	mov	r5, r0
    8c3e:	e7ec      	b.n	8c1a <att_send+0x3e>
    8c40:	0001ed28 	.word	0x0001ed28
    8c44:	0001ed30 	.word	0x0001ed30
    8c48:	0002103a 	.word	0x0002103a

00008c4c <bt_att_accept>:
	att->req->buf = NULL;
}
#endif /* CONFIG_BT_SMP */

static int bt_att_accept(struct bt_conn *conn, struct bt_l2cap_chan **chan)
{
    8c4c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	};
	struct bt_att *att;

	BT_DBG("conn %p handle %u", conn, conn->handle);

	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
    8c4e:	2200      	movs	r2, #0
{
    8c50:	4606      	mov	r6, r0
    8c52:	460d      	mov	r5, r1
	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
    8c54:	4814      	ldr	r0, [pc, #80]	; (8ca8 <bt_att_accept+0x5c>)
    8c56:	a901      	add	r1, sp, #4
    8c58:	f00e ff10 	bl	17a7c <k_mem_slab_alloc>
    8c5c:	4604      	mov	r4, r0
    8c5e:	b198      	cbz	r0, 8c88 <bt_att_accept+0x3c>
		BT_ERR("No available ATT context for conn %p", conn);
    8c60:	2301      	movs	r3, #1
    8c62:	f04f 0200 	mov.w	r2, #0
    8c66:	f363 0207 	bfi	r2, r3, #0, #8
    8c6a:	4910      	ldr	r1, [pc, #64]	; (8cac <bt_att_accept+0x60>)
    8c6c:	4b10      	ldr	r3, [pc, #64]	; (8cb0 <bt_att_accept+0x64>)
    8c6e:	4811      	ldr	r0, [pc, #68]	; (8cb4 <bt_att_accept+0x68>)
    8c70:	1a5b      	subs	r3, r3, r1
    8c72:	08db      	lsrs	r3, r3, #3
    8c74:	f363 128f 	bfi	r2, r3, #6, #10
    8c78:	4631      	mov	r1, r6
    8c7a:	f011 fcd7 	bl	1a62c <log_1>
		return -ENOMEM;
    8c7e:	f06f 040b 	mvn.w	r4, #11
	att->chan.chan.ops = &ops;
	k_sem_init(&att->tx_sem, CONFIG_BT_ATT_TX_MAX, CONFIG_BT_ATT_TX_MAX);
	*chan = &att->chan.chan;

	return 0;
}
    8c82:	4620      	mov	r0, r4
    8c84:	b002      	add	sp, #8
    8c86:	bd70      	pop	{r4, r5, r6, pc}
	(void)memset(att, 0, sizeof(*att));
    8c88:	4601      	mov	r1, r0
    8c8a:	22f8      	movs	r2, #248	; 0xf8
    8c8c:	9801      	ldr	r0, [sp, #4]
    8c8e:	f012 f9de 	bl	1b04e <memset>
	att->chan.chan.ops = &ops;
    8c92:	9801      	ldr	r0, [sp, #4]
    8c94:	4b08      	ldr	r3, [pc, #32]	; (8cb8 <bt_att_accept+0x6c>)
    8c96:	6043      	str	r3, [r0, #4]
	z_impl_k_sem_init(sem, initial_count, limit);
    8c98:	2203      	movs	r2, #3
    8c9a:	4611      	mov	r1, r2
    8c9c:	30c0      	adds	r0, #192	; 0xc0
    8c9e:	f015 fcd7 	bl	1e650 <z_impl_k_sem_init>
	*chan = &att->chan.chan;
    8ca2:	9b01      	ldr	r3, [sp, #4]
    8ca4:	602b      	str	r3, [r5, #0]
	return 0;
    8ca6:	e7ec      	b.n	8c82 <bt_att_accept+0x36>
    8ca8:	20005bc8 	.word	0x20005bc8
    8cac:	0001ed28 	.word	0x0001ed28
    8cb0:	0001ed30 	.word	0x0001ed30
    8cb4:	0002106e 	.word	0x0002106e
    8cb8:	0001f510 	.word	0x0001f510

00008cbc <bt_att_connected>:
{
    8cbc:	b510      	push	{r4, lr}
    8cbe:	4604      	mov	r4, r0
	z_impl_k_queue_init(queue);
    8cc0:	30d8      	adds	r0, #216	; 0xd8
    8cc2:	f015 fb3b 	bl	1e33c <z_impl_k_queue_init>
    8cc6:	f104 00e8 	add.w	r0, r4, #232	; 0xe8
    8cca:	f015 fb37 	bl	1e33c <z_impl_k_queue_init>
	ch->tx.mtu = BT_ATT_DEFAULT_LE_MTU;
    8cce:	2317      	movs	r3, #23
    8cd0:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
	ch->rx.mtu = BT_ATT_DEFAULT_LE_MTU;
    8cd4:	86e3      	strh	r3, [r4, #54]	; 0x36
	k_delayed_work_init(&att->timeout_work, att_timeout);
    8cd6:	4904      	ldr	r1, [pc, #16]	; (8ce8 <bt_att_connected+0x2c>)
    8cd8:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
    8cdc:	f015 fd34 	bl	1e748 <k_delayed_work_init>
	list->head = NULL;
    8ce0:	2300      	movs	r3, #0
	list->tail = NULL;
    8ce2:	e9c4 3326 	strd	r3, r3, [r4, #152]	; 0x98
}
    8ce6:	bd10      	pop	{r4, pc}
    8ce8:	00009a7d 	.word	0x00009a7d

00008cec <att_req_sent>:
{
    8cec:	b538      	push	{r3, r4, r5, lr}
    8cee:	460d      	mov	r5, r1
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
    8cf0:	2104      	movs	r1, #4
{
    8cf2:	4604      	mov	r4, r0
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
    8cf4:	f012 fd46 	bl	1b784 <bt_l2cap_le_lookup_tx_cid>
	if (att->req) {
    8cf8:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
    8cfc:	b133      	cbz	r3, 8d0c <att_req_sent+0x20>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    8cfe:	f100 01a0 	add.w	r1, r0, #160	; 0xa0
    8d02:	f247 5230 	movw	r2, #30000	; 0x7530
    8d06:	4804      	ldr	r0, [pc, #16]	; (8d18 <att_req_sent+0x2c>)
    8d08:	f00f fd2e 	bl	18768 <k_delayed_work_submit_to_queue>
	att_pdu_sent(conn, user_data);
    8d0c:	4629      	mov	r1, r5
    8d0e:	4620      	mov	r0, r4
}
    8d10:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	att_pdu_sent(conn, user_data);
    8d14:	f012 bef8 	b.w	1bb08 <att_pdu_sent>
    8d18:	20001a60 	.word	0x20001a60

00008d1c <att_chan_get>:
	if (conn->state != BT_CONN_CONNECTED) {
    8d1c:	7b43      	ldrb	r3, [r0, #13]
    8d1e:	2b06      	cmp	r3, #6
{
    8d20:	b510      	push	{r4, lr}
	if (conn->state != BT_CONN_CONNECTED) {
    8d22:	d00f      	beq.n	8d44 <att_chan_get+0x28>
		BT_WARN("Not connected");
    8d24:	2302      	movs	r3, #2
    8d26:	f04f 0100 	mov.w	r1, #0
    8d2a:	f363 0107 	bfi	r1, r3, #0, #8
    8d2e:	4a1a      	ldr	r2, [pc, #104]	; (8d98 <att_chan_get+0x7c>)
    8d30:	4b1a      	ldr	r3, [pc, #104]	; (8d9c <att_chan_get+0x80>)
    8d32:	481b      	ldr	r0, [pc, #108]	; (8da0 <att_chan_get+0x84>)
    8d34:	1a9b      	subs	r3, r3, r2
    8d36:	08db      	lsrs	r3, r3, #3
    8d38:	f363 118f 	bfi	r1, r3, #6, #10
		BT_WARN("ATT context flagged as disconnected");
    8d3c:	f011 fc69 	bl	1a612 <log_0>
		return NULL;
    8d40:	2400      	movs	r4, #0
    8d42:	e012      	b.n	8d6a <att_chan_get+0x4e>
	chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_ATT);
    8d44:	2104      	movs	r1, #4
    8d46:	f012 fd28 	bl	1b79a <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
    8d4a:	4604      	mov	r4, r0
    8d4c:	b978      	cbnz	r0, 8d6e <att_chan_get+0x52>
		BT_ERR("Unable to find ATT channel");
    8d4e:	2301      	movs	r3, #1
    8d50:	f04f 0100 	mov.w	r1, #0
    8d54:	f363 0107 	bfi	r1, r3, #0, #8
    8d58:	4a0f      	ldr	r2, [pc, #60]	; (8d98 <att_chan_get+0x7c>)
    8d5a:	4b10      	ldr	r3, [pc, #64]	; (8d9c <att_chan_get+0x80>)
    8d5c:	4811      	ldr	r0, [pc, #68]	; (8da4 <att_chan_get+0x88>)
    8d5e:	1a9b      	subs	r3, r3, r2
    8d60:	08db      	lsrs	r3, r3, #3
    8d62:	f363 118f 	bfi	r1, r3, #6, #10
    8d66:	f011 fc54 	bl	1a612 <log_0>
}
    8d6a:	4620      	mov	r0, r4
    8d6c:	bd10      	pop	{r4, pc}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    8d6e:	f3bf 8f5b 	dmb	ish
    8d72:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
    8d76:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(att->flags, ATT_DISCONNECTED)) {
    8d7a:	075b      	lsls	r3, r3, #29
    8d7c:	d5f5      	bpl.n	8d6a <att_chan_get+0x4e>
		BT_WARN("ATT context flagged as disconnected");
    8d7e:	2302      	movs	r3, #2
    8d80:	f04f 0100 	mov.w	r1, #0
    8d84:	f363 0107 	bfi	r1, r3, #0, #8
    8d88:	4a03      	ldr	r2, [pc, #12]	; (8d98 <att_chan_get+0x7c>)
    8d8a:	4b04      	ldr	r3, [pc, #16]	; (8d9c <att_chan_get+0x80>)
    8d8c:	4806      	ldr	r0, [pc, #24]	; (8da8 <att_chan_get+0x8c>)
    8d8e:	1a9b      	subs	r3, r3, r2
    8d90:	08db      	lsrs	r3, r3, #3
    8d92:	f363 118f 	bfi	r1, r3, #6, #10
    8d96:	e7d1      	b.n	8d3c <att_chan_get+0x20>
    8d98:	0001ed28 	.word	0x0001ed28
    8d9c:	0001ed30 	.word	0x0001ed30
    8da0:	00020fd6 	.word	0x00020fd6
    8da4:	00020fe4 	.word	0x00020fe4
    8da8:	00020fff 	.word	0x00020fff

00008dac <prep_write_cb>:
{
    8dac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    8dae:	460c      	mov	r4, r1
    8db0:	4606      	mov	r6, r0
	data->err = bt_gatt_check_perm(data->conn, attr,
    8db2:	4601      	mov	r1, r0
    8db4:	222a      	movs	r2, #42	; 0x2a
    8db6:	6820      	ldr	r0, [r4, #0]
    8db8:	f013 fb37 	bl	1c42a <bt_gatt_check_perm>
    8dbc:	4605      	mov	r5, r0
    8dbe:	7420      	strb	r0, [r4, #16]
	if (data->err) {
    8dc0:	2800      	cmp	r0, #0
    8dc2:	d12d      	bne.n	8e20 <prep_write_cb+0x74>
	if (!(attr->perm & BT_GATT_PERM_PREPARE_WRITE)) {
    8dc4:	7cb3      	ldrb	r3, [r6, #18]
    8dc6:	065b      	lsls	r3, r3, #25
    8dc8:	d514      	bpl.n	8df4 <prep_write_cb+0x48>
	write = attr->write(data->conn, attr, data->value, data->len,
    8dca:	2301      	movs	r3, #1
    8dcc:	9301      	str	r3, [sp, #4]
    8dce:	89e3      	ldrh	r3, [r4, #14]
    8dd0:	9300      	str	r3, [sp, #0]
    8dd2:	68b7      	ldr	r7, [r6, #8]
    8dd4:	89a3      	ldrh	r3, [r4, #12]
    8dd6:	68a2      	ldr	r2, [r4, #8]
    8dd8:	6820      	ldr	r0, [r4, #0]
    8dda:	4631      	mov	r1, r6
    8ddc:	47b8      	blx	r7
	if (write != 0) {
    8dde:	b148      	cbz	r0, 8df4 <prep_write_cb+0x48>
	if (err < 0 && err >= -0xff) {
    8de0:	f110 0fff 	cmn.w	r0, #255	; 0xff
		return -err;
    8de4:	bf26      	itte	cs
    8de6:	4240      	negcs	r0, r0
    8de8:	b2c0      	uxtbcs	r0, r0
	return BT_ATT_ERR_UNLIKELY;
    8dea:	200e      	movcc	r0, #14
		data->err = err_to_att(write);
    8dec:	7420      	strb	r0, [r4, #16]
}
    8dee:	4628      	mov	r0, r5
    8df0:	b003      	add	sp, #12
    8df2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	data->buf = net_buf_alloc(&prep_pool, K_NO_WAIT);
    8df4:	2100      	movs	r1, #0
    8df6:	480b      	ldr	r0, [pc, #44]	; (8e24 <prep_write_cb+0x78>)
    8df8:	f014 fef4 	bl	1dbe4 <net_buf_alloc_fixed>
    8dfc:	6060      	str	r0, [r4, #4]
	if (!data->buf) {
    8dfe:	b910      	cbnz	r0, 8e06 <prep_write_cb+0x5a>
		data->err = BT_ATT_ERR_PREPARE_QUEUE_FULL;
    8e00:	2309      	movs	r3, #9
    8e02:	7423      	strb	r3, [r4, #16]
		return BT_GATT_ITER_STOP;
    8e04:	e7f3      	b.n	8dee <prep_write_cb+0x42>
	attr_data->handle = attr->handle;
    8e06:	8a33      	ldrh	r3, [r6, #16]
    8e08:	8283      	strh	r3, [r0, #20]
	attr_data->offset = data->offset;
    8e0a:	89e3      	ldrh	r3, [r4, #14]
    8e0c:	82c3      	strh	r3, [r0, #22]
	net_buf_add_mem(data->buf, data->value, data->len);
    8e0e:	89a2      	ldrh	r2, [r4, #12]
    8e10:	68a1      	ldr	r1, [r4, #8]
    8e12:	3008      	adds	r0, #8
    8e14:	f014 ff20 	bl	1dc58 <net_buf_simple_add_mem>
	data->err = 0U;
    8e18:	2300      	movs	r3, #0
    8e1a:	7423      	strb	r3, [r4, #16]
	return BT_GATT_ITER_CONTINUE;
    8e1c:	2501      	movs	r5, #1
    8e1e:	e7e6      	b.n	8dee <prep_write_cb+0x42>
		return BT_GATT_ITER_STOP;
    8e20:	2500      	movs	r5, #0
    8e22:	e7e4      	b.n	8dee <prep_write_cb+0x42>
    8e24:	20005d88 	.word	0x20005d88

00008e28 <bt_att_create_pdu>:
{
    8e28:	b570      	push	{r4, r5, r6, lr}
    8e2a:	460e      	mov	r6, r1
    8e2c:	4615      	mov	r5, r2
	att = att_chan_get(conn);
    8e2e:	f7ff ff75 	bl	8d1c <att_chan_get>
	if (!att) {
    8e32:	4604      	mov	r4, r0
    8e34:	b198      	cbz	r0, 8e5e <bt_att_create_pdu+0x36>
	if (len + sizeof(op) > att->chan.tx.mtu) {
    8e36:	f8b0 1042 	ldrh.w	r1, [r0, #66]	; 0x42
    8e3a:	1c6a      	adds	r2, r5, #1
    8e3c:	428a      	cmp	r2, r1
    8e3e:	d910      	bls.n	8e62 <bt_att_create_pdu+0x3a>
		BT_WARN("ATT MTU exceeded, max %u, wanted %zu",
    8e40:	2002      	movs	r0, #2
    8e42:	f04f 0300 	mov.w	r3, #0
    8e46:	f360 0307 	bfi	r3, r0, #0, #8
    8e4a:	4c1a      	ldr	r4, [pc, #104]	; (8eb4 <bt_att_create_pdu+0x8c>)
    8e4c:	481a      	ldr	r0, [pc, #104]	; (8eb8 <bt_att_create_pdu+0x90>)
    8e4e:	1b00      	subs	r0, r0, r4
    8e50:	08c0      	lsrs	r0, r0, #3
    8e52:	f360 138f 	bfi	r3, r0, #6, #10
    8e56:	4819      	ldr	r0, [pc, #100]	; (8ebc <bt_att_create_pdu+0x94>)
    8e58:	f011 fbfc 	bl	1a654 <log_2>
		return NULL;
    8e5c:	2400      	movs	r4, #0
}
    8e5e:	4620      	mov	r0, r4
    8e60:	bd70      	pop	{r4, r5, r6, pc}
	switch (att_op_get_type(op)) {
    8e62:	4630      	mov	r0, r6
    8e64:	f012 fca4 	bl	1b7b0 <att_op_get_type>
    8e68:	2802      	cmp	r0, #2
    8e6a:	d001      	beq.n	8e70 <bt_att_create_pdu+0x48>
    8e6c:	2804      	cmp	r0, #4
    8e6e:	d117      	bne.n	8ea0 <bt_att_create_pdu+0x78>
		buf = bt_l2cap_create_pdu_timeout(NULL, 0, BT_ATT_TIMEOUT);
    8e70:	f247 5230 	movw	r2, #30000	; 0x7530
		buf = bt_l2cap_create_pdu(NULL, 0);
    8e74:	2100      	movs	r1, #0
    8e76:	4608      	mov	r0, r1
    8e78:	f012 fc68 	bl	1b74c <bt_l2cap_create_pdu_timeout>
    8e7c:	4604      	mov	r4, r0
	if (!buf) {
    8e7e:	b990      	cbnz	r0, 8ea6 <bt_att_create_pdu+0x7e>
		BT_ERR("Unable to allocate buffer for op 0x%02x", op);
    8e80:	2301      	movs	r3, #1
    8e82:	f04f 0200 	mov.w	r2, #0
    8e86:	f363 0207 	bfi	r2, r3, #0, #8
    8e8a:	490a      	ldr	r1, [pc, #40]	; (8eb4 <bt_att_create_pdu+0x8c>)
    8e8c:	4b0a      	ldr	r3, [pc, #40]	; (8eb8 <bt_att_create_pdu+0x90>)
    8e8e:	480c      	ldr	r0, [pc, #48]	; (8ec0 <bt_att_create_pdu+0x98>)
    8e90:	1a5b      	subs	r3, r3, r1
    8e92:	08db      	lsrs	r3, r3, #3
    8e94:	f363 128f 	bfi	r2, r3, #6, #10
    8e98:	4631      	mov	r1, r6
    8e9a:	f011 fbc7 	bl	1a62c <log_1>
		return NULL;
    8e9e:	e7de      	b.n	8e5e <bt_att_create_pdu+0x36>
		buf = bt_l2cap_create_pdu(NULL, 0);
    8ea0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    8ea4:	e7e6      	b.n	8e74 <bt_att_create_pdu+0x4c>
	hdr = net_buf_add(buf, sizeof(*hdr));
    8ea6:	2101      	movs	r1, #1
    8ea8:	3008      	adds	r0, #8
    8eaa:	f014 fecf 	bl	1dc4c <net_buf_simple_add>
	hdr->code = op;
    8eae:	7006      	strb	r6, [r0, #0]
	return buf;
    8eb0:	e7d5      	b.n	8e5e <bt_att_create_pdu+0x36>
    8eb2:	bf00      	nop
    8eb4:	0001ed28 	.word	0x0001ed28
    8eb8:	0001ed30 	.word	0x0001ed30
    8ebc:	00021093 	.word	0x00021093
    8ec0:	00020ef4 	.word	0x00020ef4

00008ec4 <att_indicate>:
{
    8ec4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct bt_conn *conn = att->chan.chan.conn;
    8ec6:	6804      	ldr	r4, [r0, #0]
	handle = net_buf_pull_le16(buf);
    8ec8:	f101 0008 	add.w	r0, r1, #8
{
    8ecc:	460d      	mov	r5, r1
	handle = net_buf_pull_le16(buf);
    8ece:	f014 fef6 	bl	1dcbe <net_buf_simple_pull_le16>
	bt_gatt_notification(conn, handle, buf->data, buf->len);
    8ed2:	89ab      	ldrh	r3, [r5, #12]
    8ed4:	68aa      	ldr	r2, [r5, #8]
    8ed6:	4601      	mov	r1, r0
    8ed8:	4620      	mov	r0, r4
    8eda:	f013 fbac 	bl	1c636 <bt_gatt_notification>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_CONFIRM, 0);
    8ede:	2200      	movs	r2, #0
    8ee0:	211e      	movs	r1, #30
    8ee2:	4620      	mov	r0, r4
    8ee4:	f7ff ffa0 	bl	8e28 <bt_att_create_pdu>
	if (!buf) {
    8ee8:	4602      	mov	r2, r0
    8eea:	b130      	cbz	r0, 8efa <att_indicate+0x36>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, att_cfm_sent, NULL);
    8eec:	2300      	movs	r3, #0
    8eee:	9300      	str	r3, [sp, #0]
    8ef0:	2104      	movs	r1, #4
    8ef2:	4b03      	ldr	r3, [pc, #12]	; (8f00 <att_indicate+0x3c>)
    8ef4:	4620      	mov	r0, r4
    8ef6:	f012 fc2c 	bl	1b752 <bt_l2cap_send_cb>
}
    8efa:	2000      	movs	r0, #0
    8efc:	b003      	add	sp, #12
    8efe:	bd30      	pop	{r4, r5, pc}
    8f00:	0001bb61 	.word	0x0001bb61

00008f04 <att_mtu_req>:
	mtu_client = sys_le16_to_cpu(req->mtu);
    8f04:	688b      	ldr	r3, [r1, #8]
{
    8f06:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	mtu_client = sys_le16_to_cpu(req->mtu);
    8f0a:	881d      	ldrh	r5, [r3, #0]
	if (mtu_client < BT_ATT_DEFAULT_LE_MTU) {
    8f0c:	2d16      	cmp	r5, #22
{
    8f0e:	4606      	mov	r6, r0
	if (mtu_client < BT_ATT_DEFAULT_LE_MTU) {
    8f10:	d921      	bls.n	8f56 <att_mtu_req+0x52>
	struct bt_conn *conn = att->chan.chan.conn;
    8f12:	f8d0 8000 	ldr.w	r8, [r0]
	pdu = bt_att_create_pdu(conn, BT_ATT_OP_MTU_RSP, sizeof(*rsp));
    8f16:	2202      	movs	r2, #2
    8f18:	2103      	movs	r1, #3
    8f1a:	4640      	mov	r0, r8
    8f1c:	f7ff ff84 	bl	8e28 <bt_att_create_pdu>
	if (!pdu) {
    8f20:	4607      	mov	r7, r0
    8f22:	b1d0      	cbz	r0, 8f5a <att_mtu_req+0x56>
	rsp = net_buf_add(pdu, sizeof(*rsp));
    8f24:	2102      	movs	r1, #2
    8f26:	3008      	adds	r0, #8
    8f28:	f014 fe90 	bl	1dc4c <net_buf_simple_add>
	rsp->mtu = sys_cpu_to_le16(mtu_server);
    8f2c:	2400      	movs	r4, #0
    8f2e:	2341      	movs	r3, #65	; 0x41
    8f30:	7003      	strb	r3, [r0, #0]
    8f32:	7044      	strb	r4, [r0, #1]
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, pdu, att_rsp_sent, NULL);
    8f34:	4b0a      	ldr	r3, [pc, #40]	; (8f60 <att_mtu_req+0x5c>)
    8f36:	9400      	str	r4, [sp, #0]
    8f38:	463a      	mov	r2, r7
    8f3a:	2104      	movs	r1, #4
    8f3c:	4640      	mov	r0, r8
    8f3e:	f012 fc08 	bl	1b752 <bt_l2cap_send_cb>
	att->chan.rx.mtu = MIN(mtu_client, mtu_server);
    8f42:	2d41      	cmp	r5, #65	; 0x41
    8f44:	bf28      	it	cs
    8f46:	2541      	movcs	r5, #65	; 0x41
    8f48:	86f5      	strh	r5, [r6, #54]	; 0x36
	att->chan.tx.mtu = att->chan.rx.mtu;
    8f4a:	f8a6 5042 	strh.w	r5, [r6, #66]	; 0x42
	return 0;
    8f4e:	4620      	mov	r0, r4
}
    8f50:	b002      	add	sp, #8
    8f52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_ATT_ERR_INVALID_PDU;
    8f56:	2004      	movs	r0, #4
    8f58:	e7fa      	b.n	8f50 <att_mtu_req+0x4c>
		return BT_ATT_ERR_UNLIKELY;
    8f5a:	200e      	movs	r0, #14
    8f5c:	e7f8      	b.n	8f50 <att_mtu_req+0x4c>
    8f5e:	bf00      	nop
    8f60:	0001bb93 	.word	0x0001bb93

00008f64 <send_err_rsp.part.11>:
static void send_err_rsp(struct bt_conn *conn, u8_t req, u16_t handle,
    8f64:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    8f68:	4688      	mov	r8, r1
    8f6a:	4617      	mov	r7, r2
	buf = bt_att_create_pdu(conn, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
    8f6c:	2101      	movs	r1, #1
    8f6e:	2204      	movs	r2, #4
static void send_err_rsp(struct bt_conn *conn, u8_t req, u16_t handle,
    8f70:	4605      	mov	r5, r0
    8f72:	461e      	mov	r6, r3
	buf = bt_att_create_pdu(conn, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
    8f74:	f7ff ff58 	bl	8e28 <bt_att_create_pdu>
	if (!buf) {
    8f78:	4604      	mov	r4, r0
    8f7a:	b180      	cbz	r0, 8f9e <send_err_rsp.part.11+0x3a>
	rsp = net_buf_add(buf, sizeof(*rsp));
    8f7c:	2104      	movs	r1, #4
    8f7e:	3008      	adds	r0, #8
    8f80:	f014 fe64 	bl	1dc4c <net_buf_simple_add>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, att_rsp_sent, NULL);
    8f84:	2300      	movs	r3, #0
	rsp->request = req;
    8f86:	f880 8000 	strb.w	r8, [r0]
	rsp->handle = sys_cpu_to_le16(handle);
    8f8a:	f8a0 7001 	strh.w	r7, [r0, #1]
	rsp->error = err;
    8f8e:	70c6      	strb	r6, [r0, #3]
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, att_rsp_sent, NULL);
    8f90:	4622      	mov	r2, r4
    8f92:	9300      	str	r3, [sp, #0]
    8f94:	2104      	movs	r1, #4
    8f96:	4b03      	ldr	r3, [pc, #12]	; (8fa4 <send_err_rsp.part.11+0x40>)
    8f98:	4628      	mov	r0, r5
    8f9a:	f012 fbda 	bl	1b752 <bt_l2cap_send_cb>
}
    8f9e:	b002      	add	sp, #8
    8fa0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8fa4:	0001bb93 	.word	0x0001bb93

00008fa8 <bt_att_recv>:
{
    8fa8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (buf->len < sizeof(*hdr)) {
    8faa:	898b      	ldrh	r3, [r1, #12]
{
    8fac:	4604      	mov	r4, r0
    8fae:	460f      	mov	r7, r1
	if (buf->len < sizeof(*hdr)) {
    8fb0:	b97b      	cbnz	r3, 8fd2 <bt_att_recv+0x2a>
		BT_ERR("Too small ATT PDU received");
    8fb2:	2301      	movs	r3, #1
    8fb4:	f04f 0100 	mov.w	r1, #0
    8fb8:	f363 0107 	bfi	r1, r3, #0, #8
    8fbc:	4a51      	ldr	r2, [pc, #324]	; (9104 <bt_att_recv+0x15c>)
    8fbe:	4b52      	ldr	r3, [pc, #328]	; (9108 <bt_att_recv+0x160>)
    8fc0:	4852      	ldr	r0, [pc, #328]	; (910c <bt_att_recv+0x164>)
    8fc2:	1a9b      	subs	r3, r3, r2
    8fc4:	08db      	lsrs	r3, r3, #3
    8fc6:	f363 118f 	bfi	r1, r3, #6, #10
			BT_WARN("Ignoring unexpected indication");
    8fca:	f011 fb22 	bl	1a612 <log_0>
}
    8fce:	2000      	movs	r0, #0
    8fd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    8fd2:	2101      	movs	r1, #1
    8fd4:	f107 0008 	add.w	r0, r7, #8
    8fd8:	f014 fe69 	bl	1dcae <net_buf_simple_pull_mem>
		if (hdr->code == handlers[i].op) {
    8fdc:	4a4c      	ldr	r2, [pc, #304]	; (9110 <bt_att_recv+0x168>)
    8fde:	7801      	ldrb	r1, [r0, #0]
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    8fe0:	4605      	mov	r5, r0
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
    8fe2:	2300      	movs	r3, #0
    8fe4:	4610      	mov	r0, r2
		if (hdr->code == handlers[i].op) {
    8fe6:	f812 6033 	ldrb.w	r6, [r2, r3, lsl #3]
    8fea:	428e      	cmp	r6, r1
    8fec:	d122      	bne.n	9034 <bt_att_recv+0x8c>
		if (handler->type == ATT_REQUEST &&
    8fee:	00db      	lsls	r3, r3, #3
    8ff0:	441a      	add	r2, r3
    8ff2:	7896      	ldrb	r6, [r2, #2]
    8ff4:	2e01      	cmp	r6, #1
    8ff6:	d13c      	bne.n	9072 <bt_att_recv+0xca>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    8ff8:	f3bf 8f5b 	dmb	ish
    8ffc:	f104 0290 	add.w	r2, r4, #144	; 0x90
    9000:	e852 1f00 	ldrex	r1, [r2]
    9004:	f041 0c01 	orr.w	ip, r1, #1
    9008:	e842 ce00 	strex	lr, ip, [r2]
    900c:	f1be 0f00 	cmp.w	lr, #0
    9010:	d1f6      	bne.n	9000 <bt_att_recv+0x58>
    9012:	f3bf 8f5b 	dmb	ish
    9016:	07c9      	lsls	r1, r1, #31
    9018:	d54b      	bpl.n	90b2 <bt_att_recv+0x10a>
			BT_WARN("Ignoring unexpected request");
    901a:	2302      	movs	r3, #2
    901c:	f04f 0100 	mov.w	r1, #0
    9020:	f363 0107 	bfi	r1, r3, #0, #8
    9024:	4a37      	ldr	r2, [pc, #220]	; (9104 <bt_att_recv+0x15c>)
    9026:	4b38      	ldr	r3, [pc, #224]	; (9108 <bt_att_recv+0x160>)
    9028:	483a      	ldr	r0, [pc, #232]	; (9114 <bt_att_recv+0x16c>)
    902a:	1a9b      	subs	r3, r3, r2
    902c:	08db      	lsrs	r3, r3, #3
    902e:	f363 118f 	bfi	r1, r3, #6, #10
    9032:	e7ca      	b.n	8fca <bt_att_recv+0x22>
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
    9034:	3301      	adds	r3, #1
    9036:	2b1c      	cmp	r3, #28
    9038:	d1d5      	bne.n	8fe6 <bt_att_recv+0x3e>
		BT_WARN("Unhandled ATT code 0x%02x", hdr->code);
    903a:	2302      	movs	r3, #2
    903c:	f04f 0200 	mov.w	r2, #0
    9040:	f363 0207 	bfi	r2, r3, #0, #8
    9044:	482f      	ldr	r0, [pc, #188]	; (9104 <bt_att_recv+0x15c>)
    9046:	4b30      	ldr	r3, [pc, #192]	; (9108 <bt_att_recv+0x160>)
    9048:	1a1b      	subs	r3, r3, r0
    904a:	08db      	lsrs	r3, r3, #3
    904c:	4832      	ldr	r0, [pc, #200]	; (9118 <bt_att_recv+0x170>)
    904e:	f363 128f 	bfi	r2, r3, #6, #10
    9052:	f011 faeb 	bl	1a62c <log_1>
		if (att_op_get_type(hdr->code) != ATT_COMMAND) {
    9056:	7829      	ldrb	r1, [r5, #0]
    9058:	4608      	mov	r0, r1
    905a:	f012 fba9 	bl	1b7b0 <att_op_get_type>
    905e:	2800      	cmp	r0, #0
    9060:	d0b5      	beq.n	8fce <bt_att_recv+0x26>
	if (!req) {
    9062:	2900      	cmp	r1, #0
    9064:	d0b3      	beq.n	8fce <bt_att_recv+0x26>
    9066:	2306      	movs	r3, #6
    9068:	2200      	movs	r2, #0
    906a:	6820      	ldr	r0, [r4, #0]
    906c:	f7ff ff7a 	bl	8f64 <send_err_rsp.part.11>
    9070:	e7ad      	b.n	8fce <bt_att_recv+0x26>
		} else if (handler->type == ATT_INDICATION &&
    9072:	2e05      	cmp	r6, #5
    9074:	d11d      	bne.n	90b2 <bt_att_recv+0x10a>
    9076:	f3bf 8f5b 	dmb	ish
    907a:	f104 0290 	add.w	r2, r4, #144	; 0x90
    907e:	e852 1f00 	ldrex	r1, [r2]
    9082:	f041 0c02 	orr.w	ip, r1, #2
    9086:	e842 ce00 	strex	lr, ip, [r2]
    908a:	f1be 0f00 	cmp.w	lr, #0
    908e:	d1f6      	bne.n	907e <bt_att_recv+0xd6>
    9090:	f3bf 8f5b 	dmb	ish
    9094:	078a      	lsls	r2, r1, #30
    9096:	d50c      	bpl.n	90b2 <bt_att_recv+0x10a>
			BT_WARN("Ignoring unexpected indication");
    9098:	2302      	movs	r3, #2
    909a:	f04f 0100 	mov.w	r1, #0
    909e:	f363 0107 	bfi	r1, r3, #0, #8
    90a2:	4a18      	ldr	r2, [pc, #96]	; (9104 <bt_att_recv+0x15c>)
    90a4:	4b18      	ldr	r3, [pc, #96]	; (9108 <bt_att_recv+0x160>)
    90a6:	481d      	ldr	r0, [pc, #116]	; (911c <bt_att_recv+0x174>)
    90a8:	1a9b      	subs	r3, r3, r2
    90aa:	08db      	lsrs	r3, r3, #3
    90ac:	f363 118f 	bfi	r1, r3, #6, #10
    90b0:	e78b      	b.n	8fca <bt_att_recv+0x22>
	if (buf->len < handler->expect_len) {
    90b2:	4403      	add	r3, r0
    90b4:	89b9      	ldrh	r1, [r7, #12]
    90b6:	785a      	ldrb	r2, [r3, #1]
    90b8:	428a      	cmp	r2, r1
    90ba:	d913      	bls.n	90e4 <bt_att_recv+0x13c>
		BT_ERR("Invalid len %u for code 0x%02x", buf->len, hdr->code);
    90bc:	2201      	movs	r2, #1
    90be:	f04f 0300 	mov.w	r3, #0
    90c2:	f362 0307 	bfi	r3, r2, #0, #8
    90c6:	480f      	ldr	r0, [pc, #60]	; (9104 <bt_att_recv+0x15c>)
    90c8:	4a0f      	ldr	r2, [pc, #60]	; (9108 <bt_att_recv+0x160>)
    90ca:	1a12      	subs	r2, r2, r0
    90cc:	08d2      	lsrs	r2, r2, #3
    90ce:	f362 138f 	bfi	r3, r2, #6, #10
    90d2:	4813      	ldr	r0, [pc, #76]	; (9120 <bt_att_recv+0x178>)
    90d4:	782a      	ldrb	r2, [r5, #0]
    90d6:	f011 fabd 	bl	1a654 <log_2>
	if (handler->type == ATT_REQUEST && err) {
    90da:	2e01      	cmp	r6, #1
    90dc:	f47f af77 	bne.w	8fce <bt_att_recv+0x26>
		err = BT_ATT_ERR_INVALID_PDU;
    90e0:	2304      	movs	r3, #4
    90e2:	e00a      	b.n	90fa <bt_att_recv+0x152>
		err = handler->func(att, buf);
    90e4:	685b      	ldr	r3, [r3, #4]
    90e6:	4639      	mov	r1, r7
    90e8:	4620      	mov	r0, r4
    90ea:	4798      	blx	r3
	if (handler->type == ATT_REQUEST && err) {
    90ec:	2e01      	cmp	r6, #1
		err = handler->func(att, buf);
    90ee:	4603      	mov	r3, r0
	if (handler->type == ATT_REQUEST && err) {
    90f0:	f47f af6d 	bne.w	8fce <bt_att_recv+0x26>
    90f4:	2800      	cmp	r0, #0
    90f6:	f43f af6a 	beq.w	8fce <bt_att_recv+0x26>
		send_err_rsp(chan->conn, hdr->code, 0, err);
    90fa:	7829      	ldrb	r1, [r5, #0]
	if (!req) {
    90fc:	2900      	cmp	r1, #0
    90fe:	f43f af66 	beq.w	8fce <bt_att_recv+0x26>
    9102:	e7b1      	b.n	9068 <bt_att_recv+0xc0>
    9104:	0001ed28 	.word	0x0001ed28
    9108:	0001ed30 	.word	0x0001ed30
    910c:	000210c5 	.word	0x000210c5
    9110:	0001f420 	.word	0x0001f420
    9114:	000210e0 	.word	0x000210e0
    9118:	0002113a 	.word	0x0002113a
    911c:	000210fc 	.word	0x000210fc
    9120:	0002111b 	.word	0x0002111b

00009124 <att_write_rsp>:
{
    9124:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
    9128:	460e      	mov	r6, r1
    912a:	3100      	adds	r1, #0
{
    912c:	b088      	sub	sp, #32
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
    912e:	bf18      	it	ne
    9130:	2101      	movne	r1, #1
{
    9132:	4605      	mov	r5, r0
    9134:	4690      	mov	r8, r2
    9136:	461f      	mov	r7, r3
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
    9138:	f013 faa6 	bl	1c688 <bt_gatt_change_aware>
    913c:	2800      	cmp	r0, #0
    913e:	d04e      	beq.n	91de <att_write_rsp+0xba>
	if (!handle) {
    9140:	2f00      	cmp	r7, #0
    9142:	d04e      	beq.n	91e2 <att_write_rsp+0xbe>
	(void)memset(&data, 0, sizeof(data));
    9144:	2218      	movs	r2, #24
    9146:	2100      	movs	r1, #0
    9148:	a802      	add	r0, sp, #8
    914a:	f011 ff80 	bl	1b04e <memset>
	if (rsp) {
    914e:	f1b8 0f00 	cmp.w	r8, #0
    9152:	d124      	bne.n	919e <att_write_rsp+0x7a>
	data.offset = offset;
    9154:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
    9158:	f8ad 301a 	strh.w	r3, [sp, #26]
	data.value = value;
    915c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    915e:	9305      	str	r3, [sp, #20]
	data.len = len;
    9160:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
    9164:	f8ad 3018 	strh.w	r3, [sp, #24]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    9168:	2301      	movs	r3, #1
    916a:	f88d 301c 	strb.w	r3, [sp, #28]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    916e:	4a1e      	ldr	r2, [pc, #120]	; (91e8 <att_write_rsp+0xc4>)
	data.conn = conn;
    9170:	9502      	str	r5, [sp, #8]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    9172:	ab02      	add	r3, sp, #8
    9174:	4639      	mov	r1, r7
    9176:	4638      	mov	r0, r7
	data.req = req;
    9178:	f88d 6010 	strb.w	r6, [sp, #16]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    917c:	f012 fb74 	bl	1b868 <bt_gatt_foreach_attr>
	if (data.err) {
    9180:	f89d 401c 	ldrb.w	r4, [sp, #28]
    9184:	b30c      	cbz	r4, 91ca <att_write_rsp+0xa6>
		if (rsp) {
    9186:	f1b8 0f00 	cmp.w	r8, #0
    918a:	d019      	beq.n	91c0 <att_write_rsp+0x9c>
			net_buf_unref(data.buf);
    918c:	9803      	ldr	r0, [sp, #12]
    918e:	f00d f9c7 	bl	16520 <net_buf_unref>
	if (!req) {
    9192:	b976      	cbnz	r6, 91b2 <att_write_rsp+0x8e>
		return req == BT_ATT_OP_EXEC_WRITE_REQ ? data.err : 0;
    9194:	2400      	movs	r4, #0
}
    9196:	4620      	mov	r0, r4
    9198:	b008      	add	sp, #32
    919a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		data.buf = bt_att_create_pdu(conn, rsp, 0);
    919e:	2200      	movs	r2, #0
    91a0:	4641      	mov	r1, r8
    91a2:	4628      	mov	r0, r5
    91a4:	f7ff fe40 	bl	8e28 <bt_att_create_pdu>
    91a8:	9003      	str	r0, [sp, #12]
		if (!data.buf) {
    91aa:	2800      	cmp	r0, #0
    91ac:	d1d2      	bne.n	9154 <att_write_rsp+0x30>
			return BT_ATT_ERR_UNLIKELY;
    91ae:	240e      	movs	r4, #14
    91b0:	e7f1      	b.n	9196 <att_write_rsp+0x72>
    91b2:	f89d 301c 	ldrb.w	r3, [sp, #28]
    91b6:	463a      	mov	r2, r7
    91b8:	4631      	mov	r1, r6
    91ba:	4628      	mov	r0, r5
    91bc:	f7ff fed2 	bl	8f64 <send_err_rsp.part.11>
		return req == BT_ATT_OP_EXEC_WRITE_REQ ? data.err : 0;
    91c0:	2e18      	cmp	r6, #24
    91c2:	d1e7      	bne.n	9194 <att_write_rsp+0x70>
    91c4:	f89d 401c 	ldrb.w	r4, [sp, #28]
    91c8:	e7e5      	b.n	9196 <att_write_rsp+0x72>
	if (data.buf) {
    91ca:	9a03      	ldr	r2, [sp, #12]
    91cc:	2a00      	cmp	r2, #0
    91ce:	d0e1      	beq.n	9194 <att_write_rsp+0x70>
		(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf,
    91d0:	9400      	str	r4, [sp, #0]
    91d2:	4b06      	ldr	r3, [pc, #24]	; (91ec <att_write_rsp+0xc8>)
    91d4:	2104      	movs	r1, #4
    91d6:	4628      	mov	r0, r5
    91d8:	f012 fabb 	bl	1b752 <bt_l2cap_send_cb>
    91dc:	e7db      	b.n	9196 <att_write_rsp+0x72>
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
    91de:	2412      	movs	r4, #18
    91e0:	e7d9      	b.n	9196 <att_write_rsp+0x72>
		return BT_ATT_ERR_INVALID_HANDLE;
    91e2:	2401      	movs	r4, #1
    91e4:	e7d7      	b.n	9196 <att_write_rsp+0x72>
    91e6:	bf00      	nop
    91e8:	0001bbc5 	.word	0x0001bbc5
    91ec:	0001bb93 	.word	0x0001bb93

000091f0 <att_signed_write_cmd>:
{
    91f0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	handle = sys_le16_to_cpu(req->handle);
    91f4:	460c      	mov	r4, r1
	struct bt_conn *conn = att->chan.chan.conn;
    91f6:	6807      	ldr	r7, [r0, #0]
	handle = sys_le16_to_cpu(req->handle);
    91f8:	f854 3f08 	ldr.w	r3, [r4, #8]!
{
    91fc:	460d      	mov	r5, r1
	net_buf_push(buf, sizeof(struct bt_att_hdr));
    91fe:	4620      	mov	r0, r4
    9200:	2101      	movs	r1, #1
	handle = sys_le16_to_cpu(req->handle);
    9202:	f8b3 8000 	ldrh.w	r8, [r3]
	net_buf_push(buf, sizeof(struct bt_att_hdr));
    9206:	f014 fd42 	bl	1dc8e <net_buf_simple_push>
	err = bt_smp_sign_verify(conn, buf);
    920a:	4629      	mov	r1, r5
    920c:	4638      	mov	r0, r7
    920e:	f003 ffad 	bl	d16c <bt_smp_sign_verify>
	if (err) {
    9212:	4606      	mov	r6, r0
    9214:	b188      	cbz	r0, 923a <att_signed_write_cmd+0x4a>
		BT_ERR("Error verifying data");
    9216:	2301      	movs	r3, #1
    9218:	f04f 0100 	mov.w	r1, #0
    921c:	f363 0107 	bfi	r1, r3, #0, #8
    9220:	4a11      	ldr	r2, [pc, #68]	; (9268 <att_signed_write_cmd+0x78>)
    9222:	4b12      	ldr	r3, [pc, #72]	; (926c <att_signed_write_cmd+0x7c>)
    9224:	4812      	ldr	r0, [pc, #72]	; (9270 <att_signed_write_cmd+0x80>)
    9226:	1a9b      	subs	r3, r3, r2
    9228:	08db      	lsrs	r3, r3, #3
    922a:	f363 118f 	bfi	r1, r3, #6, #10
    922e:	f011 f9f0 	bl	1a612 <log_0>
		return 0;
    9232:	2000      	movs	r0, #0
}
    9234:	b004      	add	sp, #16
    9236:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	net_buf_pull(buf, sizeof(struct bt_att_hdr));
    923a:	2101      	movs	r1, #1
    923c:	4620      	mov	r0, r4
    923e:	f014 fd2e 	bl	1dc9e <net_buf_simple_pull>
	net_buf_pull(buf, sizeof(*req));
    9242:	2102      	movs	r1, #2
    9244:	4620      	mov	r0, r4
    9246:	f014 fd2a 	bl	1dc9e <net_buf_simple_pull>
	return att_write_rsp(conn, 0, 0, handle, 0, buf->data,
    924a:	89ab      	ldrh	r3, [r5, #12]
    924c:	3b0c      	subs	r3, #12
    924e:	b29b      	uxth	r3, r3
    9250:	9302      	str	r3, [sp, #8]
    9252:	68ab      	ldr	r3, [r5, #8]
    9254:	4632      	mov	r2, r6
    9256:	e9cd 6300 	strd	r6, r3, [sp]
    925a:	4631      	mov	r1, r6
    925c:	4643      	mov	r3, r8
    925e:	4638      	mov	r0, r7
    9260:	f7ff ff60 	bl	9124 <att_write_rsp>
    9264:	e7e6      	b.n	9234 <att_signed_write_cmd+0x44>
    9266:	bf00      	nop
    9268:	0001ed28 	.word	0x0001ed28
    926c:	0001ed30 	.word	0x0001ed30
    9270:	0002104d 	.word	0x0002104d

00009274 <att_exec_write_req>:
{
    9274:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	return att_exec_write_rsp(att, req->flags);
    9278:	688b      	ldr	r3, [r1, #8]
	struct bt_conn *conn = att->chan.chan.conn;
    927a:	4607      	mov	r7, r0
	return att_exec_write_rsp(att, req->flags);
    927c:	f893 8000 	ldrb.w	r8, [r3]
	struct bt_conn *conn = att->chan.chan.conn;
    9280:	f857 6be8 	ldr.w	r6, [r7], #232
	u8_t err = 0U;
    9284:	2400      	movs	r4, #0
	while ((buf = net_buf_get(&att->prep_queue, K_NO_WAIT))) {
    9286:	2100      	movs	r1, #0
    9288:	4638      	mov	r0, r7
    928a:	f014 fcb1 	bl	1dbf0 <net_buf_get>
    928e:	4605      	mov	r5, r0
    9290:	b988      	cbnz	r0, 92b6 <att_exec_write_req+0x42>
	if (err) {
    9292:	bb64      	cbnz	r4, 92ee <att_exec_write_req+0x7a>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_EXEC_WRITE_RSP, 0);
    9294:	4622      	mov	r2, r4
    9296:	2119      	movs	r1, #25
    9298:	4630      	mov	r0, r6
    929a:	f7ff fdc5 	bl	8e28 <bt_att_create_pdu>
	if (!buf) {
    929e:	4602      	mov	r2, r0
    92a0:	b338      	cbz	r0, 92f2 <att_exec_write_req+0x7e>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, att_rsp_sent, NULL);
    92a2:	9400      	str	r4, [sp, #0]
    92a4:	4b14      	ldr	r3, [pc, #80]	; (92f8 <att_exec_write_req+0x84>)
    92a6:	2104      	movs	r1, #4
    92a8:	4630      	mov	r0, r6
    92aa:	f012 fa52 	bl	1b752 <bt_l2cap_send_cb>
}
    92ae:	4620      	mov	r0, r4
    92b0:	b004      	add	sp, #16
    92b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!err && flags == BT_ATT_FLAG_EXEC) {
    92b6:	b9b4      	cbnz	r4, 92e6 <att_exec_write_req+0x72>
    92b8:	f1b8 0f01 	cmp.w	r8, #1
    92bc:	d113      	bne.n	92e6 <att_exec_write_req+0x72>
			err = att_write_rsp(conn, BT_ATT_OP_EXEC_WRITE_REQ, 0,
    92be:	89aa      	ldrh	r2, [r5, #12]
    92c0:	8aab      	ldrh	r3, [r5, #20]
    92c2:	9202      	str	r2, [sp, #8]
    92c4:	68aa      	ldr	r2, [r5, #8]
    92c6:	9201      	str	r2, [sp, #4]
    92c8:	8aea      	ldrh	r2, [r5, #22]
    92ca:	9200      	str	r2, [sp, #0]
    92cc:	2118      	movs	r1, #24
    92ce:	4622      	mov	r2, r4
    92d0:	4630      	mov	r0, r6
    92d2:	f7ff ff27 	bl	9124 <att_write_rsp>
			if (err) {
    92d6:	4604      	mov	r4, r0
    92d8:	b128      	cbz	r0, 92e6 <att_exec_write_req+0x72>
	if (!req) {
    92da:	4603      	mov	r3, r0
    92dc:	8aaa      	ldrh	r2, [r5, #20]
    92de:	2118      	movs	r1, #24
    92e0:	4630      	mov	r0, r6
    92e2:	f7ff fe3f 	bl	8f64 <send_err_rsp.part.11>
		net_buf_unref(buf);
    92e6:	4628      	mov	r0, r5
    92e8:	f00d f91a 	bl	16520 <net_buf_unref>
    92ec:	e7cb      	b.n	9286 <att_exec_write_req+0x12>
		return 0;
    92ee:	4604      	mov	r4, r0
    92f0:	e7dd      	b.n	92ae <att_exec_write_req+0x3a>
		return BT_ATT_ERR_UNLIKELY;
    92f2:	240e      	movs	r4, #14
    92f4:	e7db      	b.n	92ae <att_exec_write_req+0x3a>
    92f6:	bf00      	nop
    92f8:	0001bb93 	.word	0x0001bb93

000092fc <att_prepare_write_req>:
{
    92fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9300:	460c      	mov	r4, r1
    9302:	b089      	sub	sp, #36	; 0x24
    9304:	4683      	mov	fp, r0
	req = net_buf_pull_mem(buf, sizeof(*req));
    9306:	2104      	movs	r1, #4
    9308:	f104 0008 	add.w	r0, r4, #8
    930c:	f014 fccf 	bl	1dcae <net_buf_simple_pull_mem>
	struct bt_conn *conn = att->chan.chan.conn;
    9310:	f8db 5000 	ldr.w	r5, [fp]
	handle = sys_le16_to_cpu(req->handle);
    9314:	f8b0 a000 	ldrh.w	sl, [r0]
	offset = sys_le16_to_cpu(req->offset);
    9318:	f8b0 9002 	ldrh.w	r9, [r0, #2]
	return att_prep_write_rsp(att, handle, offset, buf->data, buf->len);
    931c:	f8d4 8008 	ldr.w	r8, [r4, #8]
    9320:	89a7      	ldrh	r7, [r4, #12]
	if (!bt_gatt_change_aware(conn, true)) {
    9322:	2101      	movs	r1, #1
    9324:	4628      	mov	r0, r5
	handle = sys_le16_to_cpu(req->handle);
    9326:	fa1f f68a 	uxth.w	r6, sl
	if (!bt_gatt_change_aware(conn, true)) {
    932a:	f013 f9ad 	bl	1c688 <bt_gatt_change_aware>
    932e:	2800      	cmp	r0, #0
    9330:	d04b      	beq.n	93ca <att_prepare_write_req+0xce>
	if (!handle) {
    9332:	2e00      	cmp	r6, #0
    9334:	d04b      	beq.n	93ce <att_prepare_write_req+0xd2>
	(void)memset(&data, 0, sizeof(data));
    9336:	2214      	movs	r2, #20
    9338:	2100      	movs	r1, #0
    933a:	a803      	add	r0, sp, #12
    933c:	f011 fe87 	bl	1b04e <memset>
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    9340:	2301      	movs	r3, #1
    9342:	f88d 301c 	strb.w	r3, [sp, #28]
	bt_gatt_foreach_attr(handle, handle, prep_write_cb, &data);
    9346:	4a24      	ldr	r2, [pc, #144]	; (93d8 <att_prepare_write_req+0xdc>)
	data.conn = conn;
    9348:	9503      	str	r5, [sp, #12]
	bt_gatt_foreach_attr(handle, handle, prep_write_cb, &data);
    934a:	ab03      	add	r3, sp, #12
    934c:	4631      	mov	r1, r6
    934e:	4630      	mov	r0, r6
	data.offset = offset;
    9350:	f8ad 901a 	strh.w	r9, [sp, #26]
	data.value = value;
    9354:	f8cd 8014 	str.w	r8, [sp, #20]
	data.len = len;
    9358:	f8ad 7018 	strh.w	r7, [sp, #24]
	bt_gatt_foreach_attr(handle, handle, prep_write_cb, &data);
    935c:	f012 fa84 	bl	1b868 <bt_gatt_foreach_attr>
	if (data.err) {
    9360:	f89d 401c 	ldrb.w	r4, [sp, #28]
    9364:	b154      	cbz	r4, 937c <att_prepare_write_req+0x80>
	if (!req) {
    9366:	4623      	mov	r3, r4
    9368:	4632      	mov	r2, r6
    936a:	2116      	movs	r1, #22
    936c:	4628      	mov	r0, r5
    936e:	f7ff fdf9 	bl	8f64 <send_err_rsp.part.11>
		return 0;
    9372:	2400      	movs	r4, #0
}
    9374:	4620      	mov	r0, r4
    9376:	b009      	add	sp, #36	; 0x24
    9378:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	net_buf_put(&att->prep_queue, data.buf);
    937c:	9904      	ldr	r1, [sp, #16]
    937e:	f10b 00e8 	add.w	r0, fp, #232	; 0xe8
    9382:	f014 fc52 	bl	1dc2a <net_buf_put>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_PREPARE_WRITE_RSP, 0);
    9386:	4622      	mov	r2, r4
    9388:	2117      	movs	r1, #23
    938a:	4628      	mov	r0, r5
    938c:	f7ff fd4c 	bl	8e28 <bt_att_create_pdu>
    9390:	9004      	str	r0, [sp, #16]
	if (!data.buf) {
    9392:	b1f0      	cbz	r0, 93d2 <att_prepare_write_req+0xd6>
	rsp = net_buf_add(data.buf, sizeof(*rsp));
    9394:	2104      	movs	r1, #4
    9396:	3008      	adds	r0, #8
    9398:	f014 fc58 	bl	1dc4c <net_buf_simple_add>
    939c:	4606      	mov	r6, r0
	rsp->handle = sys_cpu_to_le16(handle);
    939e:	f8a0 a000 	strh.w	sl, [r0]
	rsp->offset = sys_cpu_to_le16(offset);
    93a2:	f8a0 9002 	strh.w	r9, [r0, #2]
	net_buf_add(data.buf, len);
    93a6:	9804      	ldr	r0, [sp, #16]
    93a8:	4639      	mov	r1, r7
    93aa:	3008      	adds	r0, #8
    93ac:	f014 fc4e 	bl	1dc4c <net_buf_simple_add>
	memcpy(rsp->value, value, len);
    93b0:	463a      	mov	r2, r7
    93b2:	4641      	mov	r1, r8
    93b4:	1d30      	adds	r0, r6, #4
    93b6:	f011 fe20 	bl	1affa <memcpy>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    93ba:	9400      	str	r4, [sp, #0]
    93bc:	4b07      	ldr	r3, [pc, #28]	; (93dc <att_prepare_write_req+0xe0>)
    93be:	9a04      	ldr	r2, [sp, #16]
    93c0:	2104      	movs	r1, #4
    93c2:	4628      	mov	r0, r5
    93c4:	f012 f9c5 	bl	1b752 <bt_l2cap_send_cb>
	return 0;
    93c8:	e7d4      	b.n	9374 <att_prepare_write_req+0x78>
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
    93ca:	2412      	movs	r4, #18
    93cc:	e7d2      	b.n	9374 <att_prepare_write_req+0x78>
		return BT_ATT_ERR_INVALID_HANDLE;
    93ce:	2401      	movs	r4, #1
    93d0:	e7d0      	b.n	9374 <att_prepare_write_req+0x78>
		return BT_ATT_ERR_UNLIKELY;
    93d2:	240e      	movs	r4, #14
    93d4:	e7ce      	b.n	9374 <att_prepare_write_req+0x78>
    93d6:	bf00      	nop
    93d8:	00008dad 	.word	0x00008dad
    93dc:	0001bb93 	.word	0x0001bb93

000093e0 <att_read_group_req>:
{
    93e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u8_t uuid_len = buf->len - sizeof(*req);
    93e4:	7b0c      	ldrb	r4, [r1, #12]
    93e6:	3c04      	subs	r4, #4
    93e8:	b2e4      	uxtb	r4, r4
	if (uuid_len != 2 && uuid_len != 16) {
    93ea:	2c02      	cmp	r4, #2
{
    93ec:	4680      	mov	r8, r0
    93ee:	b08f      	sub	sp, #60	; 0x3c
    93f0:	4608      	mov	r0, r1
	if (uuid_len != 2 && uuid_len != 16) {
    93f2:	d001      	beq.n	93f8 <att_read_group_req+0x18>
    93f4:	2c10      	cmp	r4, #16
    93f6:	d16e      	bne.n	94d6 <att_read_group_req+0xf6>
	req = net_buf_pull_mem(buf, sizeof(*req));
    93f8:	2104      	movs	r1, #4
    93fa:	3008      	adds	r0, #8
	struct bt_conn *conn = att->chan.chan.conn;
    93fc:	f8d8 9000 	ldr.w	r9, [r8]
	req = net_buf_pull_mem(buf, sizeof(*req));
    9400:	f014 fc55 	bl	1dcae <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    9404:	ae04      	add	r6, sp, #16
	start_handle = sys_le16_to_cpu(req->start_handle);
    9406:	8805      	ldrh	r5, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
    9408:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    940a:	1d01      	adds	r1, r0, #4
    940c:	4622      	mov	r2, r4
    940e:	4630      	mov	r0, r6
    9410:	f011 ff0a 	bl	1b228 <bt_uuid_create>
    9414:	2800      	cmp	r0, #0
    9416:	d060      	beq.n	94da <att_read_group_req+0xfa>
	if (!start || !end) {
    9418:	2d00      	cmp	r5, #0
    941a:	d036      	beq.n	948a <att_read_group_req+0xaa>
    941c:	2400      	movs	r4, #0
    941e:	b39f      	cbz	r7, 9488 <att_read_group_req+0xa8>
	if (start > end) {
    9420:	42bd      	cmp	r5, r7
    9422:	d832      	bhi.n	948a <att_read_group_req+0xaa>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
    9424:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    9428:	a902      	add	r1, sp, #8
    942a:	4630      	mov	r0, r6
    942c:	f88d 4008 	strb.w	r4, [sp, #8]
    9430:	f8ad 300a 	strh.w	r3, [sp, #10]
    9434:	f011 fece 	bl	1b1d4 <bt_uuid_cmp>
    9438:	bb90      	cbnz	r0, 94a0 <att_read_group_req+0xc0>
	struct bt_conn *conn = att->chan.chan.conn;
    943a:	f8d8 9000 	ldr.w	r9, [r8]
	(void)memset(&data, 0, sizeof(data));
    943e:	2214      	movs	r2, #20
    9440:	2100      	movs	r1, #0
    9442:	a809      	add	r0, sp, #36	; 0x24
    9444:	f011 fe03 	bl	1b04e <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_RSP,
    9448:	2201      	movs	r2, #1
    944a:	2111      	movs	r1, #17
    944c:	4648      	mov	r0, r9
    944e:	f7ff fceb 	bl	8e28 <bt_att_create_pdu>
    9452:	900b      	str	r0, [sp, #44]	; 0x2c
	if (!data.buf) {
    9454:	2800      	cmp	r0, #0
    9456:	d040      	beq.n	94da <att_read_group_req+0xfa>
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    9458:	2101      	movs	r1, #1
    945a:	3008      	adds	r0, #8
	data.uuid = uuid;
    945c:	e9cd 8609 	strd	r8, r6, [sp, #36]	; 0x24
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    9460:	f014 fbf4 	bl	1dc4c <net_buf_simple_add>
	data.rsp->len = 0U;
    9464:	2600      	movs	r6, #0
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    9466:	900c      	str	r0, [sp, #48]	; 0x30
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
    9468:	ab09      	add	r3, sp, #36	; 0x24
	data.rsp->len = 0U;
    946a:	7006      	strb	r6, [r0, #0]
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
    946c:	4a1c      	ldr	r2, [pc, #112]	; (94e0 <att_read_group_req+0x100>)
	data.group = NULL;
    946e:	960d      	str	r6, [sp, #52]	; 0x34
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
    9470:	4639      	mov	r1, r7
    9472:	4628      	mov	r0, r5
    9474:	f012 f9f8 	bl	1b868 <bt_gatt_foreach_attr>
	if (!data.rsp->len) {
    9478:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    947a:	781c      	ldrb	r4, [r3, #0]
    947c:	bb1c      	cbnz	r4, 94c6 <att_read_group_req+0xe6>
		net_buf_unref(data.buf);
    947e:	980b      	ldr	r0, [sp, #44]	; 0x2c
    9480:	f00d f84e 	bl	16520 <net_buf_unref>
	if (!req) {
    9484:	230a      	movs	r3, #10
    9486:	e018      	b.n	94ba <att_read_group_req+0xda>
			*err = 0U;
    9488:	463d      	mov	r5, r7
	if (!req) {
    948a:	2301      	movs	r3, #1
    948c:	462a      	mov	r2, r5
    948e:	2110      	movs	r1, #16
    9490:	4648      	mov	r0, r9
    9492:	f7ff fd67 	bl	8f64 <send_err_rsp.part.11>
		return 0;
    9496:	2400      	movs	r4, #0
}
    9498:	4620      	mov	r0, r4
    949a:	b00f      	add	sp, #60	; 0x3c
    949c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	    bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY)) {
    94a0:	f642 0301 	movw	r3, #10241	; 0x2801
    94a4:	a903      	add	r1, sp, #12
    94a6:	4630      	mov	r0, r6
    94a8:	f88d 400c 	strb.w	r4, [sp, #12]
    94ac:	f8ad 300e 	strh.w	r3, [sp, #14]
    94b0:	f011 fe90 	bl	1b1d4 <bt_uuid_cmp>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
    94b4:	2800      	cmp	r0, #0
    94b6:	d0c0      	beq.n	943a <att_read_group_req+0x5a>
	if (!req) {
    94b8:	2310      	movs	r3, #16
    94ba:	462a      	mov	r2, r5
    94bc:	2110      	movs	r1, #16
    94be:	4648      	mov	r0, r9
    94c0:	f7ff fd50 	bl	8f64 <send_err_rsp.part.11>
		return 0;
    94c4:	e7e8      	b.n	9498 <att_read_group_req+0xb8>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    94c6:	9600      	str	r6, [sp, #0]
    94c8:	4b06      	ldr	r3, [pc, #24]	; (94e4 <att_read_group_req+0x104>)
    94ca:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    94cc:	2104      	movs	r1, #4
    94ce:	4648      	mov	r0, r9
    94d0:	f012 f93f 	bl	1b752 <bt_l2cap_send_cb>
	return 0;
    94d4:	e7df      	b.n	9496 <att_read_group_req+0xb6>
		return BT_ATT_ERR_INVALID_PDU;
    94d6:	2404      	movs	r4, #4
    94d8:	e7de      	b.n	9498 <att_read_group_req+0xb8>
		return BT_ATT_ERR_UNLIKELY;
    94da:	240e      	movs	r4, #14
    94dc:	e7dc      	b.n	9498 <att_read_group_req+0xb8>
    94de:	bf00      	nop
    94e0:	0001b919 	.word	0x0001b919
    94e4:	0001bb93 	.word	0x0001bb93

000094e8 <att_read_mult_req>:
{
    94e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct bt_conn *conn = att->chan.chan.conn;
    94ec:	6805      	ldr	r5, [r0, #0]
{
    94ee:	b089      	sub	sp, #36	; 0x24
	(void)memset(&data, 0, sizeof(data));
    94f0:	2214      	movs	r2, #20
{
    94f2:	4606      	mov	r6, r0
    94f4:	460c      	mov	r4, r1
	(void)memset(&data, 0, sizeof(data));
    94f6:	a803      	add	r0, sp, #12
    94f8:	2100      	movs	r1, #0
    94fa:	f011 fda8 	bl	1b04e <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_RSP, 0);
    94fe:	2200      	movs	r2, #0
    9500:	210f      	movs	r1, #15
    9502:	4628      	mov	r0, r5
    9504:	f7ff fc90 	bl	8e28 <bt_att_create_pdu>
    9508:	9005      	str	r0, [sp, #20]
	if (!data.buf) {
    950a:	b378      	cbz	r0, 956c <att_read_mult_req+0x84>
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    950c:	f8df 9064 	ldr.w	r9, [pc, #100]	; 9574 <att_read_mult_req+0x8c>
	data.att = att;
    9510:	9603      	str	r6, [sp, #12]
		handle = net_buf_pull_le16(buf);
    9512:	f104 0708 	add.w	r7, r4, #8
		data.err = BT_ATT_ERR_INVALID_HANDLE;
    9516:	f04f 0801 	mov.w	r8, #1
	while (buf->len >= sizeof(u16_t)) {
    951a:	89a3      	ldrh	r3, [r4, #12]
    951c:	2b01      	cmp	r3, #1
    951e:	d808      	bhi.n	9532 <att_read_mult_req+0x4a>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    9520:	2400      	movs	r4, #0
    9522:	9400      	str	r4, [sp, #0]
    9524:	4b12      	ldr	r3, [pc, #72]	; (9570 <att_read_mult_req+0x88>)
    9526:	9a05      	ldr	r2, [sp, #20]
    9528:	2104      	movs	r1, #4
    952a:	4628      	mov	r0, r5
    952c:	f012 f911 	bl	1b752 <bt_l2cap_send_cb>
	return 0;
    9530:	e018      	b.n	9564 <att_read_mult_req+0x7c>
		handle = net_buf_pull_le16(buf);
    9532:	4638      	mov	r0, r7
    9534:	f014 fbc3 	bl	1dcbe <net_buf_simple_pull_le16>
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    9538:	ab03      	add	r3, sp, #12
    953a:	464a      	mov	r2, r9
    953c:	4601      	mov	r1, r0
		handle = net_buf_pull_le16(buf);
    953e:	4606      	mov	r6, r0
		data.err = BT_ATT_ERR_INVALID_HANDLE;
    9540:	f88d 801c 	strb.w	r8, [sp, #28]
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    9544:	f012 f990 	bl	1b868 <bt_gatt_foreach_attr>
		if (data.err) {
    9548:	f89d 301c 	ldrb.w	r3, [sp, #28]
    954c:	2b00      	cmp	r3, #0
    954e:	d0e4      	beq.n	951a <att_read_mult_req+0x32>
			net_buf_unref(data.buf);
    9550:	9805      	ldr	r0, [sp, #20]
    9552:	f00c ffe5 	bl	16520 <net_buf_unref>
	if (!req) {
    9556:	f89d 301c 	ldrb.w	r3, [sp, #28]
    955a:	4632      	mov	r2, r6
    955c:	210e      	movs	r1, #14
    955e:	4628      	mov	r0, r5
    9560:	f7ff fd00 	bl	8f64 <send_err_rsp.part.11>
			return 0;
    9564:	2000      	movs	r0, #0
}
    9566:	b009      	add	sp, #36	; 0x24
    9568:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return BT_ATT_ERR_UNLIKELY;
    956c:	200e      	movs	r0, #14
    956e:	e7fa      	b.n	9566 <att_read_mult_req+0x7e>
    9570:	0001bb93 	.word	0x0001bb93
    9574:	0001bc21 	.word	0x0001bc21

00009578 <att_read_rsp>:
{
    9578:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct bt_conn *conn = att->chan.chan.conn;
    957c:	6805      	ldr	r5, [r0, #0]
{
    957e:	b088      	sub	sp, #32
    9580:	4604      	mov	r4, r0
    9582:	460f      	mov	r7, r1
	if (!bt_gatt_change_aware(conn, true)) {
    9584:	4628      	mov	r0, r5
    9586:	2101      	movs	r1, #1
{
    9588:	4690      	mov	r8, r2
    958a:	461e      	mov	r6, r3
	if (!bt_gatt_change_aware(conn, true)) {
    958c:	f013 f87c 	bl	1c688 <bt_gatt_change_aware>
    9590:	b3a0      	cbz	r0, 95fc <att_read_rsp+0x84>
	if (!handle) {
    9592:	b3ae      	cbz	r6, 9600 <att_read_rsp+0x88>
	(void)memset(&data, 0, sizeof(data));
    9594:	2214      	movs	r2, #20
    9596:	2100      	movs	r1, #0
    9598:	a803      	add	r0, sp, #12
    959a:	f011 fd58 	bl	1b04e <memset>
	data.buf = bt_att_create_pdu(conn, rsp, 0);
    959e:	2200      	movs	r2, #0
    95a0:	4641      	mov	r1, r8
    95a2:	4628      	mov	r0, r5
    95a4:	f7ff fc40 	bl	8e28 <bt_att_create_pdu>
    95a8:	9005      	str	r0, [sp, #20]
	if (!data.buf) {
    95aa:	b358      	cbz	r0, 9604 <att_read_rsp+0x8c>
	data.offset = offset;
    95ac:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
    95b0:	f8ad 3010 	strh.w	r3, [sp, #16]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    95b4:	2301      	movs	r3, #1
    95b6:	f88d 301c 	strb.w	r3, [sp, #28]
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    95ba:	4a13      	ldr	r2, [pc, #76]	; (9608 <att_read_rsp+0x90>)
	data.att = att;
    95bc:	9403      	str	r4, [sp, #12]
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    95be:	ab03      	add	r3, sp, #12
    95c0:	4631      	mov	r1, r6
    95c2:	4630      	mov	r0, r6
    95c4:	f012 f950 	bl	1b868 <bt_gatt_foreach_attr>
	if (data.err) {
    95c8:	f89d 401c 	ldrb.w	r4, [sp, #28]
    95cc:	b174      	cbz	r4, 95ec <att_read_rsp+0x74>
		net_buf_unref(data.buf);
    95ce:	9805      	ldr	r0, [sp, #20]
    95d0:	f00c ffa6 	bl	16520 <net_buf_unref>
	if (!req) {
    95d4:	f89d 301c 	ldrb.w	r3, [sp, #28]
    95d8:	4632      	mov	r2, r6
    95da:	4639      	mov	r1, r7
    95dc:	4628      	mov	r0, r5
    95de:	f7ff fcc1 	bl	8f64 <send_err_rsp.part.11>
		return 0;
    95e2:	2400      	movs	r4, #0
}
    95e4:	4620      	mov	r0, r4
    95e6:	b008      	add	sp, #32
    95e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    95ec:	9400      	str	r4, [sp, #0]
    95ee:	4b07      	ldr	r3, [pc, #28]	; (960c <att_read_rsp+0x94>)
    95f0:	9a05      	ldr	r2, [sp, #20]
    95f2:	2104      	movs	r1, #4
    95f4:	4628      	mov	r0, r5
    95f6:	f012 f8ac 	bl	1b752 <bt_l2cap_send_cb>
	return 0;
    95fa:	e7f3      	b.n	95e4 <att_read_rsp+0x6c>
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
    95fc:	2412      	movs	r4, #18
    95fe:	e7f1      	b.n	95e4 <att_read_rsp+0x6c>
		return BT_ATT_ERR_INVALID_HANDLE;
    9600:	2401      	movs	r4, #1
    9602:	e7ef      	b.n	95e4 <att_read_rsp+0x6c>
		return BT_ATT_ERR_UNLIKELY;
    9604:	240e      	movs	r4, #14
    9606:	e7ed      	b.n	95e4 <att_read_rsp+0x6c>
    9608:	0001bc21 	.word	0x0001bc21
    960c:	0001bb93 	.word	0x0001bb93

00009610 <att_read_type_req>:
{
    9610:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u8_t uuid_len = buf->len - sizeof(*req);
    9614:	7b0c      	ldrb	r4, [r1, #12]
    9616:	3c04      	subs	r4, #4
    9618:	b2e4      	uxtb	r4, r4
	if (uuid_len != 2 && uuid_len != 16) {
    961a:	2c02      	cmp	r4, #2
{
    961c:	4680      	mov	r8, r0
    961e:	b08f      	sub	sp, #60	; 0x3c
    9620:	4608      	mov	r0, r1
	if (uuid_len != 2 && uuid_len != 16) {
    9622:	d001      	beq.n	9628 <att_read_type_req+0x18>
    9624:	2c10      	cmp	r4, #16
    9626:	d154      	bne.n	96d2 <att_read_type_req+0xc2>
	req = net_buf_pull_mem(buf, sizeof(*req));
    9628:	2104      	movs	r1, #4
    962a:	3008      	adds	r0, #8
	struct bt_conn *conn = att->chan.chan.conn;
    962c:	f8d8 7000 	ldr.w	r7, [r8]
	req = net_buf_pull_mem(buf, sizeof(*req));
    9630:	f014 fb3d 	bl	1dcae <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    9634:	f10d 090c 	add.w	r9, sp, #12
	start_handle = sys_le16_to_cpu(req->start_handle);
    9638:	8805      	ldrh	r5, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
    963a:	8846      	ldrh	r6, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    963c:	1d01      	adds	r1, r0, #4
    963e:	4622      	mov	r2, r4
    9640:	4648      	mov	r0, r9
    9642:	f011 fdf1 	bl	1b228 <bt_uuid_create>
    9646:	b188      	cbz	r0, 966c <att_read_type_req+0x5c>
	if (!start || !end) {
    9648:	b19d      	cbz	r5, 9672 <att_read_type_req+0x62>
    964a:	b18e      	cbz	r6, 9670 <att_read_type_req+0x60>
	if (start > end) {
    964c:	42b5      	cmp	r5, r6
    964e:	d810      	bhi.n	9672 <att_read_type_req+0x62>
	struct bt_conn *conn = att->chan.chan.conn;
    9650:	f8d8 7000 	ldr.w	r7, [r8]
	(void)memset(&data, 0, sizeof(data));
    9654:	2218      	movs	r2, #24
    9656:	2100      	movs	r1, #0
    9658:	a808      	add	r0, sp, #32
    965a:	f011 fcf8 	bl	1b04e <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_RSP,
    965e:	2201      	movs	r2, #1
    9660:	2109      	movs	r1, #9
    9662:	4638      	mov	r0, r7
    9664:	f7ff fbe0 	bl	8e28 <bt_att_create_pdu>
    9668:	900a      	str	r0, [sp, #40]	; 0x28
	if (!data.buf) {
    966a:	b968      	cbnz	r0, 9688 <att_read_type_req+0x78>
		return BT_ATT_ERR_UNLIKELY;
    966c:	240e      	movs	r4, #14
    966e:	e007      	b.n	9680 <att_read_type_req+0x70>
			*err = 0U;
    9670:	4635      	mov	r5, r6
	if (!req) {
    9672:	2301      	movs	r3, #1
    9674:	462a      	mov	r2, r5
    9676:	2108      	movs	r1, #8
    9678:	4638      	mov	r0, r7
    967a:	f7ff fc73 	bl	8f64 <send_err_rsp.part.11>
		return 0;
    967e:	2400      	movs	r4, #0
}
    9680:	4620      	mov	r0, r4
    9682:	b00f      	add	sp, #60	; 0x3c
    9684:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    9688:	2101      	movs	r1, #1
    968a:	3008      	adds	r0, #8
	data.uuid = uuid;
    968c:	e9cd 8908 	strd	r8, r9, [sp, #32]
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    9690:	f014 fadc 	bl	1dc4c <net_buf_simple_add>
	data.rsp->len = 0U;
    9694:	f04f 0800 	mov.w	r8, #0
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    9698:	230a      	movs	r3, #10
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    969a:	900b      	str	r0, [sp, #44]	; 0x2c
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
    969c:	4a0e      	ldr	r2, [pc, #56]	; (96d8 <att_read_type_req+0xc8>)
	data.rsp->len = 0U;
    969e:	f880 8000 	strb.w	r8, [r0]
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
    96a2:	4631      	mov	r1, r6
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    96a4:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
    96a8:	4628      	mov	r0, r5
    96aa:	ab08      	add	r3, sp, #32
    96ac:	f012 f8dc 	bl	1b868 <bt_gatt_foreach_attr>
	if (data.err) {
    96b0:	f89d 4034 	ldrb.w	r4, [sp, #52]	; 0x34
    96b4:	b12c      	cbz	r4, 96c2 <att_read_type_req+0xb2>
		net_buf_unref(data.buf);
    96b6:	980a      	ldr	r0, [sp, #40]	; 0x28
    96b8:	f00c ff32 	bl	16520 <net_buf_unref>
	if (!req) {
    96bc:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
    96c0:	e7d8      	b.n	9674 <att_read_type_req+0x64>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    96c2:	9400      	str	r4, [sp, #0]
    96c4:	4b05      	ldr	r3, [pc, #20]	; (96dc <att_read_type_req+0xcc>)
    96c6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    96c8:	2104      	movs	r1, #4
    96ca:	4638      	mov	r0, r7
    96cc:	f012 f841 	bl	1b752 <bt_l2cap_send_cb>
	return 0;
    96d0:	e7d6      	b.n	9680 <att_read_type_req+0x70>
		return BT_ATT_ERR_INVALID_PDU;
    96d2:	2404      	movs	r4, #4
    96d4:	e7d4      	b.n	9680 <att_read_type_req+0x70>
    96d6:	bf00      	nop
    96d8:	0001b9e7 	.word	0x0001b9e7
    96dc:	0001bb93 	.word	0x0001bb93

000096e0 <att_find_type_req>:
{
    96e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    96e4:	4688      	mov	r8, r1
	struct bt_conn *conn = att->chan.chan.conn;
    96e6:	f8d0 b000 	ldr.w	fp, [r0]
{
    96ea:	b08b      	sub	sp, #44	; 0x2c
    96ec:	4681      	mov	r9, r0
	req = net_buf_pull_mem(buf, sizeof(*req));
    96ee:	2106      	movs	r1, #6
    96f0:	f108 0008 	add.w	r0, r8, #8
    96f4:	f014 fadb 	bl	1dcae <net_buf_simple_pull_mem>
	start_handle = sys_le16_to_cpu(req->start_handle);
    96f8:	8805      	ldrh	r5, [r0, #0]
	if (!start || !end) {
    96fa:	b1fd      	cbz	r5, 973c <att_find_type_req+0x5c>
	end_handle = sys_le16_to_cpu(req->end_handle);
    96fc:	8847      	ldrh	r7, [r0, #2]
	if (!start || !end) {
    96fe:	b1e7      	cbz	r7, 973a <att_find_type_req+0x5a>
	if (start > end) {
    9700:	42bd      	cmp	r5, r7
    9702:	d81b      	bhi.n	973c <att_find_type_req+0x5c>
	type = sys_le16_to_cpu(req->type);
    9704:	8883      	ldrh	r3, [r0, #4]
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
    9706:	f8ad 300e 	strh.w	r3, [sp, #14]
    970a:	2400      	movs	r4, #0
    970c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    9710:	a904      	add	r1, sp, #16
    9712:	a803      	add	r0, sp, #12
	value = buf->data;
    9714:	f8d8 a008 	ldr.w	sl, [r8, #8]
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
    9718:	f88d 400c 	strb.w	r4, [sp, #12]
    971c:	f88d 4010 	strb.w	r4, [sp, #16]
    9720:	f8ad 3012 	strh.w	r3, [sp, #18]
    9724:	f011 fd56 	bl	1b1d4 <bt_uuid_cmp>
    9728:	4606      	mov	r6, r0
    972a:	b190      	cbz	r0, 9752 <att_find_type_req+0x72>
	if (!req) {
    972c:	230a      	movs	r3, #10
    972e:	462a      	mov	r2, r5
    9730:	2106      	movs	r1, #6
    9732:	4658      	mov	r0, fp
    9734:	f7ff fc16 	bl	8f64 <send_err_rsp.part.11>
		return 0;
    9738:	e007      	b.n	974a <att_find_type_req+0x6a>
			*err = 0U;
    973a:	463d      	mov	r5, r7
	if (!req) {
    973c:	2301      	movs	r3, #1
    973e:	462a      	mov	r2, r5
    9740:	2106      	movs	r1, #6
    9742:	4658      	mov	r0, fp
    9744:	f7ff fc0e 	bl	8f64 <send_err_rsp.part.11>
		return 0;
    9748:	2400      	movs	r4, #0
}
    974a:	4620      	mov	r0, r4
    974c:	b00b      	add	sp, #44	; 0x2c
    974e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	(void)memset(&data, 0, sizeof(data));
    9752:	2214      	movs	r2, #20
	return att_find_type_rsp(att, start_handle, end_handle, value,
    9754:	f898 400c 	ldrb.w	r4, [r8, #12]
	struct bt_conn *conn = att->chan.chan.conn;
    9758:	f8d9 8000 	ldr.w	r8, [r9]
	(void)memset(&data, 0, sizeof(data));
    975c:	4601      	mov	r1, r0
    975e:	eb0d 0002 	add.w	r0, sp, r2
    9762:	f011 fc74 	bl	1b04e <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_RSP, 0);
    9766:	4632      	mov	r2, r6
    9768:	2107      	movs	r1, #7
    976a:	4640      	mov	r0, r8
    976c:	f7ff fb5c 	bl	8e28 <bt_att_create_pdu>
    9770:	9006      	str	r0, [sp, #24]
	if (!data.buf) {
    9772:	b310      	cbz	r0, 97ba <att_find_type_req+0xda>
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    9774:	230a      	movs	r3, #10
    9776:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
    977a:	4a11      	ldr	r2, [pc, #68]	; (97c0 <att_find_type_req+0xe0>)
	data.value_len = value_len;
    977c:	f88d 4024 	strb.w	r4, [sp, #36]	; 0x24
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
    9780:	ab05      	add	r3, sp, #20
    9782:	4639      	mov	r1, r7
    9784:	4628      	mov	r0, r5
	data.att = att;
    9786:	f8cd 9014 	str.w	r9, [sp, #20]
	data.value = value;
    978a:	e9cd 6a07 	strd	r6, sl, [sp, #28]
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
    978e:	f012 f86b 	bl	1b868 <bt_gatt_foreach_attr>
	if (data.err) {
    9792:	f89d 4025 	ldrb.w	r4, [sp, #37]	; 0x25
    9796:	b144      	cbz	r4, 97aa <att_find_type_req+0xca>
		net_buf_unref(data.buf);
    9798:	9806      	ldr	r0, [sp, #24]
    979a:	f00c fec1 	bl	16520 <net_buf_unref>
	if (!req) {
    979e:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
    97a2:	462a      	mov	r2, r5
    97a4:	2106      	movs	r1, #6
    97a6:	4640      	mov	r0, r8
    97a8:	e7cc      	b.n	9744 <att_find_type_req+0x64>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    97aa:	9400      	str	r4, [sp, #0]
    97ac:	4b05      	ldr	r3, [pc, #20]	; (97c4 <att_find_type_req+0xe4>)
    97ae:	9a06      	ldr	r2, [sp, #24]
    97b0:	2104      	movs	r1, #4
    97b2:	4640      	mov	r0, r8
    97b4:	f011 ffcd 	bl	1b752 <bt_l2cap_send_cb>
	return 0;
    97b8:	e7c7      	b.n	974a <att_find_type_req+0x6a>
		return BT_ATT_ERR_UNLIKELY;
    97ba:	240e      	movs	r4, #14
	return att_find_type_rsp(att, start_handle, end_handle, value,
    97bc:	e7c5      	b.n	974a <att_find_type_req+0x6a>
    97be:	bf00      	nop
    97c0:	00008aa5 	.word	0x00008aa5
    97c4:	0001bb93 	.word	0x0001bb93

000097c8 <att_find_info_req>:
{
    97c8:	b5f0      	push	{r4, r5, r6, r7, lr}
	req = (void *)buf->data;
    97ca:	688b      	ldr	r3, [r1, #8]
	struct bt_conn *conn = att->chan.chan.conn;
    97cc:	6806      	ldr	r6, [r0, #0]
	start_handle = sys_le16_to_cpu(req->start_handle);
    97ce:	881d      	ldrh	r5, [r3, #0]
{
    97d0:	b087      	sub	sp, #28
    97d2:	4607      	mov	r7, r0
	if (!start || !end) {
    97d4:	b195      	cbz	r5, 97fc <att_find_info_req+0x34>
	end_handle = sys_le16_to_cpu(req->end_handle);
    97d6:	885c      	ldrh	r4, [r3, #2]
	if (!start || !end) {
    97d8:	b17c      	cbz	r4, 97fa <att_find_info_req+0x32>
	if (start > end) {
    97da:	42a5      	cmp	r5, r4
    97dc:	d80e      	bhi.n	97fc <att_find_info_req+0x34>
	(void)memset(&data, 0, sizeof(data));
    97de:	2210      	movs	r2, #16
    97e0:	2100      	movs	r1, #0
    97e2:	a802      	add	r0, sp, #8
    97e4:	f011 fc33 	bl	1b04e <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_RSP, 0);
    97e8:	2200      	movs	r2, #0
    97ea:	2105      	movs	r1, #5
    97ec:	4630      	mov	r0, r6
    97ee:	f7ff fb1b 	bl	8e28 <bt_att_create_pdu>
    97f2:	9003      	str	r0, [sp, #12]
	if (!data.buf) {
    97f4:	b958      	cbnz	r0, 980e <att_find_info_req+0x46>
		return BT_ATT_ERR_UNLIKELY;
    97f6:	200e      	movs	r0, #14
	return att_find_info_rsp(att, start_handle, end_handle);
    97f8:	e007      	b.n	980a <att_find_info_req+0x42>
			*err = 0U;
    97fa:	4625      	mov	r5, r4
	if (!req) {
    97fc:	2301      	movs	r3, #1
    97fe:	462a      	mov	r2, r5
    9800:	2104      	movs	r1, #4
    9802:	4630      	mov	r0, r6
    9804:	f7ff fbae 	bl	8f64 <send_err_rsp.part.11>
		return 0;
    9808:	2000      	movs	r0, #0
}
    980a:	b007      	add	sp, #28
    980c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
    980e:	4621      	mov	r1, r4
    9810:	ab02      	add	r3, sp, #8
    9812:	4a0a      	ldr	r2, [pc, #40]	; (983c <att_find_info_req+0x74>)
	data.att = att;
    9814:	9702      	str	r7, [sp, #8]
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
    9816:	4628      	mov	r0, r5
    9818:	f012 f826 	bl	1b868 <bt_gatt_foreach_attr>
	if (!data.rsp) {
    981c:	9c04      	ldr	r4, [sp, #16]
    981e:	b924      	cbnz	r4, 982a <att_find_info_req+0x62>
		net_buf_unref(data.buf);
    9820:	9803      	ldr	r0, [sp, #12]
    9822:	f00c fe7d 	bl	16520 <net_buf_unref>
	if (!req) {
    9826:	230a      	movs	r3, #10
    9828:	e7e9      	b.n	97fe <att_find_info_req+0x36>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    982a:	2400      	movs	r4, #0
    982c:	9400      	str	r4, [sp, #0]
    982e:	4b04      	ldr	r3, [pc, #16]	; (9840 <att_find_info_req+0x78>)
    9830:	9a03      	ldr	r2, [sp, #12]
    9832:	2104      	movs	r1, #4
    9834:	4630      	mov	r0, r6
    9836:	f011 ff8c 	bl	1b752 <bt_l2cap_send_cb>
	return 0;
    983a:	e7e5      	b.n	9808 <att_find_info_req+0x40>
    983c:	0001b87f 	.word	0x0001b87f
    9840:	0001bb93 	.word	0x0001bb93

00009844 <bt_att_req_alloc>:
	/* tx and rx MTU shall be symmetric */
	return att->chan.tx.mtu;
}

struct bt_att_req *bt_att_req_alloc(s32_t timeout)
{
    9844:	b513      	push	{r0, r1, r4, lr}
	struct bt_att_req *req = NULL;

	/* Reserve space for request */
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
    9846:	4602      	mov	r2, r0
	struct bt_att_req *req = NULL;
    9848:	2400      	movs	r4, #0
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
    984a:	a901      	add	r1, sp, #4
    984c:	4806      	ldr	r0, [pc, #24]	; (9868 <bt_att_req_alloc+0x24>)
	struct bt_att_req *req = NULL;
    984e:	9401      	str	r4, [sp, #4]
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
    9850:	f00e f914 	bl	17a7c <k_mem_slab_alloc>
    9854:	4603      	mov	r3, r0
    9856:	b928      	cbnz	r0, 9864 <bt_att_req_alloc+0x20>
		return NULL;
	}

	BT_DBG("req %p", req);

	req->func = NULL;
    9858:	9801      	ldr	r0, [sp, #4]
	req->destroy = NULL;
    985a:	e9c0 3301 	strd	r3, r3, [r0, #4]
	req->user_data = NULL;
    985e:	6183      	str	r3, [r0, #24]

	return req;
}
    9860:	b002      	add	sp, #8
    9862:	bd10      	pop	{r4, pc}
		return NULL;
    9864:	4620      	mov	r0, r4
    9866:	e7fb      	b.n	9860 <bt_att_req_alloc+0x1c>
    9868:	20005be4 	.word	0x20005be4

0000986c <bt_att_req_free>:

void bt_att_req_free(struct bt_att_req *req)
{
    986c:	b507      	push	{r0, r1, r2, lr}
    986e:	9001      	str	r0, [sp, #4]
	BT_DBG("req %p", req);

	k_mem_slab_free(&req_slab, (void **)&req);
    9870:	a901      	add	r1, sp, #4
    9872:	4803      	ldr	r0, [pc, #12]	; (9880 <bt_att_req_free+0x14>)
    9874:	f00e f92e 	bl	17ad4 <k_mem_slab_free>
}
    9878:	b003      	add	sp, #12
    987a:	f85d fb04 	ldr.w	pc, [sp], #4
    987e:	bf00      	nop
    9880:	20005be4 	.word	0x20005be4

00009884 <att_handle_rsp>:
{
    9884:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    9888:	4604      	mov	r4, r0
	k_delayed_work_cancel(&att->timeout_work);
    988a:	30a0      	adds	r0, #160	; 0xa0
{
    988c:	461e      	mov	r6, r3
    988e:	460f      	mov	r7, r1
    9890:	4690      	mov	r8, r2
	k_delayed_work_cancel(&att->timeout_work);
    9892:	f014 ff61 	bl	1e758 <k_delayed_work_cancel>
	if (!att->req) {
    9896:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    989a:	bb03      	cbnz	r3, 98de <att_handle_rsp+0x5a>
		BT_WARN("No pending ATT request");
    989c:	2302      	movs	r3, #2
    989e:	f04f 0100 	mov.w	r1, #0
    98a2:	f363 0107 	bfi	r1, r3, #0, #8
    98a6:	4a1f      	ldr	r2, [pc, #124]	; (9924 <att_handle_rsp+0xa0>)
    98a8:	4b1f      	ldr	r3, [pc, #124]	; (9928 <att_handle_rsp+0xa4>)
    98aa:	4820      	ldr	r0, [pc, #128]	; (992c <att_handle_rsp+0xa8>)
    98ac:	1a9b      	subs	r3, r3, r2
    98ae:	08db      	lsrs	r3, r3, #3
    98b0:	f363 118f 	bfi	r1, r3, #6, #10
    98b4:	f010 fead 	bl	1a612 <log_0>
Z_GENLIST_IS_EMPTY(slist)
    98b8:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
Z_GENLIST_GET(slist, snode)
    98bc:	b159      	cbz	r1, 98d6 <att_handle_rsp+0x52>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    98be:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
    98c2:	680b      	ldr	r3, [r1, #0]
	list->head = node;
    98c4:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    98c8:	4291      	cmp	r1, r2
	list->tail = node;
    98ca:	bf08      	it	eq
    98cc:	f8c4 309c 	streq.w	r3, [r4, #156]	; 0x9c
	att_send_req(att, ATT_REQ(node));
    98d0:	4620      	mov	r0, r4
    98d2:	f012 f8e5 	bl	1baa0 <att_send_req>
}
    98d6:	2000      	movs	r0, #0
    98d8:	b002      	add	sp, #8
    98da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (att->req == &cancel) {
    98de:	4a14      	ldr	r2, [pc, #80]	; (9930 <att_handle_rsp+0xac>)
    98e0:	4293      	cmp	r3, r2
    98e2:	d103      	bne.n	98ec <att_handle_rsp+0x68>
		att->req = NULL;
    98e4:	2300      	movs	r3, #0
    98e6:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
		goto process;
    98ea:	e7e5      	b.n	98b8 <att_handle_rsp+0x34>
	if (att->req->buf) {
    98ec:	6918      	ldr	r0, [r3, #16]
    98ee:	b128      	cbz	r0, 98fc <att_handle_rsp+0x78>
		net_buf_unref(att->req->buf);
    98f0:	f00c fe16 	bl	16520 <net_buf_unref>
		att->req->buf = NULL;
    98f4:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    98f8:	2200      	movs	r2, #0
    98fa:	611a      	str	r2, [r3, #16]
	func = att->req->func;
    98fc:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
	att->req->func = NULL;
    9900:	2500      	movs	r5, #0
	func = att->req->func;
    9902:	f8d0 9004 	ldr.w	r9, [r0, #4]
	params = att->req->user_data;
    9906:	f8d0 a018 	ldr.w	sl, [r0, #24]
	att->req->func = NULL;
    990a:	6045      	str	r5, [r0, #4]
	att_req_destroy(att->req);
    990c:	f012 fa0f 	bl	1bd2e <att_req_destroy>
	att->req = NULL;
    9910:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
	func(att->chan.chan.conn, err, pdu, len, params);
    9914:	f8cd a000 	str.w	sl, [sp]
    9918:	4643      	mov	r3, r8
    991a:	463a      	mov	r2, r7
    991c:	4631      	mov	r1, r6
    991e:	6820      	ldr	r0, [r4, #0]
    9920:	47c8      	blx	r9
    9922:	e7c9      	b.n	98b8 <att_handle_rsp+0x34>
    9924:	0001ed28 	.word	0x0001ed28
    9928:	0001ed30 	.word	0x0001ed30
    992c:	00021023 	.word	0x00021023
    9930:	20000404 	.word	0x20000404

00009934 <att_error_rsp>:
	if (!att->req || att->req == &cancel) {
    9934:	f8d0 2094 	ldr.w	r2, [r0, #148]	; 0x94
{
    9938:	b570      	push	{r4, r5, r6, lr}
    993a:	4605      	mov	r5, r0
	if (!att->req || att->req == &cancel) {
    993c:	b352      	cbz	r2, 9994 <att_error_rsp+0x60>
    993e:	4b1a      	ldr	r3, [pc, #104]	; (99a8 <att_error_rsp+0x74>)
    9940:	429a      	cmp	r2, r3
    9942:	d027      	beq.n	9994 <att_error_rsp+0x60>
	if (att->req->buf) {
    9944:	6913      	ldr	r3, [r2, #16]
	rsp = (void *)buf->data;
    9946:	6888      	ldr	r0, [r1, #8]
	if (att->req->buf) {
    9948:	b12b      	cbz	r3, 9956 <att_error_rsp+0x22>
 * @param state Stored state.
 */
static inline void net_buf_simple_restore(struct net_buf_simple *buf,
					  struct net_buf_simple_state *state)
{
	buf->data = buf->__buf + state->offset;
    994a:	8994      	ldrh	r4, [r2, #12]
    994c:	6919      	ldr	r1, [r3, #16]
    994e:	4421      	add	r1, r4
    9950:	6099      	str	r1, [r3, #8]
	buf->len = state->len;
    9952:	89d1      	ldrh	r1, [r2, #14]
    9954:	8199      	strh	r1, [r3, #12]
	if (att->req->retrying) {
    9956:	7d13      	ldrb	r3, [r2, #20]
	err = rsp->error;
    9958:	78c4      	ldrb	r4, [r0, #3]
	if (att->req->retrying) {
    995a:	b9e3      	cbnz	r3, 9996 <att_error_rsp+0x62>
	switch (err) {
    995c:	2c05      	cmp	r4, #5
	if (!att_change_security(att->chan.chan.conn, err)) {
    995e:	6828      	ldr	r0, [r5, #0]
	switch (err) {
    9960:	d006      	beq.n	9970 <att_error_rsp+0x3c>
    9962:	2c0f      	cmp	r4, #15
    9964:	d117      	bne.n	9996 <att_error_rsp+0x62>
		if (conn->sec_level >= BT_SECURITY_L2)
    9966:	7a43      	ldrb	r3, [r0, #9]
    9968:	2b01      	cmp	r3, #1
    996a:	d814      	bhi.n	9996 <att_error_rsp+0x62>
		sec = BT_SECURITY_L2;
    996c:	2102      	movs	r1, #2
    996e:	e007      	b.n	9980 <att_error_rsp+0x4c>
		if (conn->sec_level < BT_SECURITY_L2) {
    9970:	7a43      	ldrb	r3, [r0, #9]
    9972:	2b01      	cmp	r3, #1
    9974:	d9fa      	bls.n	996c <att_error_rsp+0x38>
		} else if (conn->sec_level < BT_SECURITY_L3) {
    9976:	2b02      	cmp	r3, #2
    9978:	d00a      	beq.n	9990 <att_error_rsp+0x5c>
		} else if (conn->sec_level < BT_SECURITY_L4) {
    997a:	2b03      	cmp	r3, #3
    997c:	d10b      	bne.n	9996 <att_error_rsp+0x62>
			sec = BT_SECURITY_L4;
    997e:	2104      	movs	r1, #4
	return bt_conn_set_security(conn, sec);
    9980:	f011 fdd0 	bl	1b524 <bt_conn_set_security>
	if (!att_change_security(att->chan.chan.conn, err)) {
    9984:	b938      	cbnz	r0, 9996 <att_error_rsp+0x62>
		att->req->retrying = true;
    9986:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
    998a:	2201      	movs	r2, #1
    998c:	751a      	strb	r2, [r3, #20]
}
    998e:	bd70      	pop	{r4, r5, r6, pc}
			sec = BT_SECURITY_L3;
    9990:	2103      	movs	r1, #3
    9992:	e7f5      	b.n	9980 <att_error_rsp+0x4c>
		err = BT_ATT_ERR_UNLIKELY;
    9994:	240e      	movs	r4, #14
	return att_handle_rsp(att, NULL, 0, err);
    9996:	2200      	movs	r2, #0
    9998:	4623      	mov	r3, r4
    999a:	4628      	mov	r0, r5
    999c:	4611      	mov	r1, r2
}
    999e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return att_handle_rsp(att, NULL, 0, err);
    99a2:	f7ff bf6f 	b.w	9884 <att_handle_rsp>
    99a6:	bf00      	nop
    99a8:	20000404 	.word	0x20000404

000099ac <bt_att_encrypt_change>:
{
    99ac:	b573      	push	{r0, r1, r4, r5, r6, lr}
    99ae:	4604      	mov	r4, r0
	if (hci_status) {
    99b0:	b139      	cbz	r1, 99c2 <bt_att_encrypt_change+0x16>
		att_handle_rsp(att, NULL, 0, BT_ATT_ERR_AUTHENTICATION);
    99b2:	2200      	movs	r2, #0
    99b4:	2305      	movs	r3, #5
    99b6:	4611      	mov	r1, r2
}
    99b8:	b002      	add	sp, #8
    99ba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		att_handle_rsp(att, NULL, 0, BT_ATT_ERR_AUTHENTICATION);
    99be:	f7ff bf61 	b.w	9884 <att_handle_rsp>
	struct bt_conn *conn = ch->chan.conn;
    99c2:	6805      	ldr	r5, [r0, #0]
	bt_gatt_encrypt_change(conn);
    99c4:	4628      	mov	r0, r5
    99c6:	f001 ff21 	bl	b80c <bt_gatt_encrypt_change>
	if (conn->sec_level == BT_SECURITY_L1) {
    99ca:	7a6b      	ldrb	r3, [r5, #9]
    99cc:	2b01      	cmp	r3, #1
    99ce:	d03d      	beq.n	9a4c <bt_att_encrypt_change+0xa0>
	if (!att->req || !att->req->retrying) {
    99d0:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    99d4:	2b00      	cmp	r3, #0
    99d6:	d039      	beq.n	9a4c <bt_att_encrypt_change+0xa0>
    99d8:	7d1b      	ldrb	r3, [r3, #20]
    99da:	2b00      	cmp	r3, #0
    99dc:	d036      	beq.n	9a4c <bt_att_encrypt_change+0xa0>
	k_sem_take(&att->tx_sem, K_FOREVER);
    99de:	f104 06c0 	add.w	r6, r4, #192	; 0xc0
	return z_impl_k_sem_take(sem, timeout);
    99e2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    99e6:	4630      	mov	r0, r6
    99e8:	f00e fd78 	bl	184dc <z_impl_k_sem_take>
	return (att->chan.chan.conn->state != BT_CONN_CONNECTED ||
    99ec:	6823      	ldr	r3, [r4, #0]
    99ee:	7b5b      	ldrb	r3, [r3, #13]
    99f0:	2b06      	cmp	r3, #6
    99f2:	d11b      	bne.n	9a2c <bt_att_encrypt_change+0x80>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    99f4:	f3bf 8f5b 	dmb	ish
    99f8:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
    99fc:	f3bf 8f5b 	dmb	ish
	if (!att_is_connected(att)) {
    9a00:	075b      	lsls	r3, r3, #29
    9a02:	d513      	bpl.n	9a2c <bt_att_encrypt_change+0x80>
		BT_WARN("Disconnected");
    9a04:	2302      	movs	r3, #2
    9a06:	f04f 0100 	mov.w	r1, #0
    9a0a:	4a11      	ldr	r2, [pc, #68]	; (9a50 <bt_att_encrypt_change+0xa4>)
    9a0c:	4811      	ldr	r0, [pc, #68]	; (9a54 <bt_att_encrypt_change+0xa8>)
    9a0e:	f363 0107 	bfi	r1, r3, #0, #8
    9a12:	4b11      	ldr	r3, [pc, #68]	; (9a58 <bt_att_encrypt_change+0xac>)
    9a14:	1a9b      	subs	r3, r3, r2
    9a16:	08db      	lsrs	r3, r3, #3
    9a18:	f363 118f 	bfi	r1, r3, #6, #10
    9a1c:	f010 fdf9 	bl	1a612 <log_0>
	z_impl_k_sem_give(sem);
    9a20:	4630      	mov	r0, r6
}
    9a22:	b002      	add	sp, #8
    9a24:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    9a28:	f00e bd2c 	b.w	18484 <z_impl_k_sem_give>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, att->req->buf,
    9a2c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    9a30:	691a      	ldr	r2, [r3, #16]
    9a32:	6890      	ldr	r0, [r2, #8]
    9a34:	f7ff f8c0 	bl	8bb8 <att_cb.isra.6>
    9a38:	2600      	movs	r6, #0
    9a3a:	4603      	mov	r3, r0
    9a3c:	9600      	str	r6, [sp, #0]
    9a3e:	2104      	movs	r1, #4
    9a40:	4628      	mov	r0, r5
    9a42:	f011 fe86 	bl	1b752 <bt_l2cap_send_cb>
	att->req->buf = NULL;
    9a46:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    9a4a:	611e      	str	r6, [r3, #16]
}
    9a4c:	b002      	add	sp, #8
    9a4e:	bd70      	pop	{r4, r5, r6, pc}
    9a50:	0001ed28 	.word	0x0001ed28
    9a54:	000210b8 	.word	0x000210b8
    9a58:	0001ed30 	.word	0x0001ed30

00009a5c <bt_att_disconnected>:
{
    9a5c:	b513      	push	{r0, r1, r4, lr}
    9a5e:	4604      	mov	r4, r0
	struct bt_att *att = ATT_CHAN(chan);
    9a60:	9001      	str	r0, [sp, #4]
	att_reset(att);
    9a62:	f012 f9a4 	bl	1bdae <att_reset>
	bt_gatt_disconnected(ch->chan.conn);
    9a66:	6820      	ldr	r0, [r4, #0]
    9a68:	f001 ff5c 	bl	b924 <bt_gatt_disconnected>
	k_mem_slab_free(&att_slab, (void **)&att);
    9a6c:	a901      	add	r1, sp, #4
    9a6e:	4802      	ldr	r0, [pc, #8]	; (9a78 <bt_att_disconnected+0x1c>)
    9a70:	f00e f830 	bl	17ad4 <k_mem_slab_free>
}
    9a74:	b002      	add	sp, #8
    9a76:	bd10      	pop	{r4, pc}
    9a78:	20005bc8 	.word	0x20005bc8

00009a7c <att_timeout>:
{
    9a7c:	b513      	push	{r0, r1, r4, lr}
	struct bt_att *att = CONTAINER_OF(work, struct bt_att, timeout_work);
    9a7e:	f1a0 03a0 	sub.w	r3, r0, #160	; 0xa0
    9a82:	9301      	str	r3, [sp, #4]
	BT_ERR("ATT Timeout");
    9a84:	f04f 0100 	mov.w	r1, #0
    9a88:	2301      	movs	r3, #1
    9a8a:	4a0e      	ldr	r2, [pc, #56]	; (9ac4 <att_timeout+0x48>)
    9a8c:	f363 0107 	bfi	r1, r3, #0, #8
    9a90:	4b0d      	ldr	r3, [pc, #52]	; (9ac8 <att_timeout+0x4c>)
    9a92:	1a9b      	subs	r3, r3, r2
    9a94:	08db      	lsrs	r3, r3, #3
    9a96:	f363 118f 	bfi	r1, r3, #6, #10
{
    9a9a:	4604      	mov	r4, r0
	BT_ERR("ATT Timeout");
    9a9c:	480b      	ldr	r0, [pc, #44]	; (9acc <att_timeout+0x50>)
    9a9e:	f010 fdb8 	bl	1a612 <log_0>
	att_reset(att);
    9aa2:	9801      	ldr	r0, [sp, #4]
    9aa4:	f012 f983 	bl	1bdae <att_reset>
	bt_gatt_disconnected(ch->chan.conn);
    9aa8:	f854 0ca0 	ldr.w	r0, [r4, #-160]
    9aac:	f001 ff3a 	bl	b924 <bt_gatt_disconnected>
	ch->chan.conn = NULL;
    9ab0:	2300      	movs	r3, #0
    9ab2:	f844 3ca0 	str.w	r3, [r4, #-160]
	k_mem_slab_free(&att_slab, (void **)&att);
    9ab6:	a901      	add	r1, sp, #4
    9ab8:	4805      	ldr	r0, [pc, #20]	; (9ad0 <att_timeout+0x54>)
    9aba:	f00e f80b 	bl	17ad4 <k_mem_slab_free>
}
    9abe:	b002      	add	sp, #8
    9ac0:	bd10      	pop	{r4, pc}
    9ac2:	bf00      	nop
    9ac4:	0001ed28 	.word	0x0001ed28
    9ac8:	0001ed30 	.word	0x0001ed30
    9acc:	00021062 	.word	0x00021062
    9ad0:	20005bc8 	.word	0x20005bc8

00009ad4 <bt_att_req_cancel>:

	return att_send_req(att, req);
}

void bt_att_req_cancel(struct bt_conn *conn, struct bt_att_req *req)
{
    9ad4:	b510      	push	{r4, lr}
    9ad6:	460c      	mov	r4, r1
	struct bt_att *att;

	BT_DBG("req %p", req);

	if (!conn || !req) {
    9ad8:	b370      	cbz	r0, 9b38 <bt_att_req_cancel+0x64>
    9ada:	b369      	cbz	r1, 9b38 <bt_att_req_cancel+0x64>
		return;
	}

	att = att_chan_get(conn);
    9adc:	f7ff f91e 	bl	8d1c <att_chan_get>
	if (!att) {
    9ae0:	b350      	cbz	r0, 9b38 <bt_att_req_cancel+0x64>
		return;
	}

	/* Check if request is outstanding */
	if (att->req == req) {
    9ae2:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
    9ae6:	429c      	cmp	r4, r3
    9ae8:	d107      	bne.n	9afa <bt_att_req_cancel+0x26>
		att->req = &cancel;
    9aea:	4b14      	ldr	r3, [pc, #80]	; (9b3c <bt_att_req_cancel+0x68>)
    9aec:	f8c0 3094 	str.w	r3, [r0, #148]	; 0x94
	} else {
		/* Remove request from the list */
		sys_slist_find_and_remove(&att->reqs, &req->node);
	}

	att_req_destroy(req);
    9af0:	4620      	mov	r0, r4
}
    9af2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	att_req_destroy(req);
    9af6:	f012 b91a 	b.w	1bd2e <att_req_destroy>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    9afa:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
    9afe:	2200      	movs	r2, #0
    9b00:	2b00      	cmp	r3, #0
    9b02:	d0f5      	beq.n	9af0 <bt_att_req_cancel+0x1c>
    9b04:	429c      	cmp	r4, r3
    9b06:	d114      	bne.n	9b32 <bt_att_req_cancel+0x5e>
Z_GENLIST_REMOVE(slist, snode)
    9b08:	6823      	ldr	r3, [r4, #0]
    9b0a:	b952      	cbnz	r2, 9b22 <bt_att_req_cancel+0x4e>
    9b0c:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
	list->head = node;
    9b10:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
Z_GENLIST_REMOVE(slist, snode)
    9b14:	4294      	cmp	r4, r2
    9b16:	d101      	bne.n	9b1c <bt_att_req_cancel+0x48>
	list->tail = node;
    9b18:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
	parent->next = child;
    9b1c:	2300      	movs	r3, #0
    9b1e:	6023      	str	r3, [r4, #0]
    9b20:	e7e6      	b.n	9af0 <bt_att_req_cancel+0x1c>
    9b22:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
    9b24:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
    9b28:	429c      	cmp	r4, r3
	list->tail = node;
    9b2a:	bf08      	it	eq
    9b2c:	f8c0 209c 	streq.w	r2, [r0, #156]	; 0x9c
    9b30:	e7f4      	b.n	9b1c <bt_att_req_cancel+0x48>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    9b32:	461a      	mov	r2, r3
    9b34:	681b      	ldr	r3, [r3, #0]
    9b36:	e7e3      	b.n	9b00 <bt_att_req_cancel+0x2c>
}
    9b38:	bd10      	pop	{r4, pc}
    9b3a:	bf00      	nop
    9b3c:	20000404 	.word	0x20000404

00009b40 <find_static_attr>:

	return BT_GATT_ITER_CONTINUE;
}

static u16_t find_static_attr(const struct bt_gatt_attr *attr)
{
    9b40:	b5f0      	push	{r4, r5, r6, r7, lr}
    9b42:	490f      	ldr	r1, [pc, #60]	; (9b80 <find_static_attr+0x40>)
	u16_t handle = 1;

	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    9b44:	4f0f      	ldr	r7, [pc, #60]	; (9b84 <find_static_attr+0x44>)
	u16_t handle = 1;
    9b46:	2501      	movs	r5, #1
		for (int i = 0; i < static_svc->attr_count; i++, handle++) {
			if (attr == &static_svc->attrs[i]) {
    9b48:	f04f 0c14 	mov.w	ip, #20
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    9b4c:	f1a1 0308 	sub.w	r3, r1, #8
    9b50:	42bb      	cmp	r3, r7
    9b52:	d211      	bcs.n	9b78 <find_static_attr+0x38>
    9b54:	f851 6c04 	ldr.w	r6, [r1, #-4]
		for (int i = 0; i < static_svc->attr_count; i++, handle++) {
    9b58:	2200      	movs	r2, #0
    9b5a:	e006      	b.n	9b6a <find_static_attr+0x2a>
			if (attr == &static_svc->attrs[i]) {
    9b5c:	f851 4c08 	ldr.w	r4, [r1, #-8]
    9b60:	fb0c 4402 	mla	r4, ip, r2, r4
    9b64:	42a0      	cmp	r0, r4
    9b66:	d008      	beq.n	9b7a <find_static_attr+0x3a>
		for (int i = 0; i < static_svc->attr_count; i++, handle++) {
    9b68:	3201      	adds	r2, #1
    9b6a:	18ab      	adds	r3, r5, r2
    9b6c:	42b2      	cmp	r2, r6
    9b6e:	b29b      	uxth	r3, r3
    9b70:	d1f4      	bne.n	9b5c <find_static_attr+0x1c>
    9b72:	3108      	adds	r1, #8
    9b74:	461d      	mov	r5, r3
    9b76:	e7e9      	b.n	9b4c <find_static_attr+0xc>
				return handle;
			}
		}
	}

	return 0;
    9b78:	2300      	movs	r3, #0
}
    9b7a:	4618      	mov	r0, r3
    9b7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9b7e:	bf00      	nop
    9b80:	0001eca4 	.word	0x0001eca4
    9b84:	0001ecc4 	.word	0x0001ecc4

00009b88 <db_hash_store>:
	err = settings_save_one("bt/hash", &db_hash, sizeof(db_hash));
    9b88:	490c      	ldr	r1, [pc, #48]	; (9bbc <db_hash_store+0x34>)
    9b8a:	480d      	ldr	r0, [pc, #52]	; (9bc0 <db_hash_store+0x38>)
{
    9b8c:	b508      	push	{r3, lr}
	err = settings_save_one("bt/hash", &db_hash, sizeof(db_hash));
    9b8e:	2210      	movs	r2, #16
    9b90:	f7fa f844 	bl	3c1c <settings_save_one>
	if (err) {
    9b94:	4601      	mov	r1, r0
    9b96:	b178      	cbz	r0, 9bb8 <db_hash_store+0x30>
		BT_ERR("Failed to save Database Hash (err %d)", err);
    9b98:	2301      	movs	r3, #1
    9b9a:	f04f 0200 	mov.w	r2, #0
    9b9e:	f363 0207 	bfi	r2, r3, #0, #8
    9ba2:	4808      	ldr	r0, [pc, #32]	; (9bc4 <db_hash_store+0x3c>)
    9ba4:	4b08      	ldr	r3, [pc, #32]	; (9bc8 <db_hash_store+0x40>)
    9ba6:	1a1b      	subs	r3, r3, r0
    9ba8:	08db      	lsrs	r3, r3, #3
    9baa:	f363 128f 	bfi	r2, r3, #6, #10
    9bae:	4807      	ldr	r0, [pc, #28]	; (9bcc <db_hash_store+0x44>)
}
    9bb0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		BT_ERR("Failed to save Database Hash (err %d)", err);
    9bb4:	f010 bd3a 	b.w	1a62c <log_1>
}
    9bb8:	bd08      	pop	{r3, pc}
    9bba:	bf00      	nop
    9bbc:	20001c55 	.word	0x20001c55
    9bc0:	000212dd 	.word	0x000212dd
    9bc4:	0001ed28 	.word	0x0001ed28
    9bc8:	0001ede0 	.word	0x0001ede0
    9bcc:	000212e5 	.word	0x000212e5

00009bd0 <db_hash_set>:

static u8_t stored_hash[16];

static int db_hash_set(const char *name, size_t len_rd,
		       settings_read_cb read_cb, void *cb_arg)
{
    9bd0:	b510      	push	{r4, lr}
	int len;

	len = read_cb(cb_arg, stored_hash, sizeof(stored_hash));
    9bd2:	490d      	ldr	r1, [pc, #52]	; (9c08 <db_hash_set+0x38>)
{
    9bd4:	4614      	mov	r4, r2
	len = read_cb(cb_arg, stored_hash, sizeof(stored_hash));
    9bd6:	4618      	mov	r0, r3
    9bd8:	2210      	movs	r2, #16
    9bda:	47a0      	blx	r4
	if (len < 0) {
    9bdc:	1e04      	subs	r4, r0, #0
    9bde:	da10      	bge.n	9c02 <db_hash_set+0x32>
		BT_ERR("Failed to decode value (err %d)", len);
    9be0:	2301      	movs	r3, #1
    9be2:	f04f 0200 	mov.w	r2, #0
    9be6:	f363 0207 	bfi	r2, r3, #0, #8
    9bea:	4908      	ldr	r1, [pc, #32]	; (9c0c <db_hash_set+0x3c>)
    9bec:	4b08      	ldr	r3, [pc, #32]	; (9c10 <db_hash_set+0x40>)
    9bee:	4809      	ldr	r0, [pc, #36]	; (9c14 <db_hash_set+0x44>)
    9bf0:	1a5b      	subs	r3, r3, r1
    9bf2:	08db      	lsrs	r3, r3, #3
    9bf4:	f363 128f 	bfi	r2, r3, #6, #10
    9bf8:	4621      	mov	r1, r4
    9bfa:	f010 fd17 	bl	1a62c <log_1>
	}

	BT_HEXDUMP_DBG(stored_hash, sizeof(stored_hash), "Stored Hash: ");

	return 0;
}
    9bfe:	4620      	mov	r0, r4
    9c00:	bd10      	pop	{r4, pc}
	return 0;
    9c02:	2400      	movs	r4, #0
    9c04:	e7fb      	b.n	9bfe <db_hash_set+0x2e>
    9c06:	bf00      	nop
    9c08:	20001c65 	.word	0x20001c65
    9c0c:	0001ed28 	.word	0x0001ed28
    9c10:	0001ede0 	.word	0x0001ede0
    9c14:	000212bd 	.word	0x000212bd

00009c18 <sc_store>:
{
    9c18:	b570      	push	{r4, r5, r6, lr}
	if (cfg->id) {
    9c1a:	4604      	mov	r4, r0
{
    9c1c:	b08c      	sub	sp, #48	; 0x30
	if (cfg->id) {
    9c1e:	f814 2b01 	ldrb.w	r2, [r4], #1
{
    9c22:	4605      	mov	r5, r0
	if (cfg->id) {
    9c24:	b31a      	cbz	r2, 9c6e <sc_store+0x56>
		u8_to_dec(id_str, sizeof(id_str), cfg->id);
    9c26:	ae02      	add	r6, sp, #8
    9c28:	2104      	movs	r1, #4
    9c2a:	4630      	mov	r0, r6
    9c2c:	f00e ffe3 	bl	18bf6 <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "sc",
    9c30:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "sc",
    9c32:	4623      	mov	r3, r4
    9c34:	4a0f      	ldr	r2, [pc, #60]	; (9c74 <sc_store+0x5c>)
    9c36:	2124      	movs	r1, #36	; 0x24
    9c38:	a803      	add	r0, sp, #12
    9c3a:	f7fb fba1 	bl	5380 <bt_settings_encode_key>
	err = settings_save_one(key, (char *)&cfg->data, sizeof(cfg->data));
    9c3e:	f105 0108 	add.w	r1, r5, #8
    9c42:	2204      	movs	r2, #4
    9c44:	a803      	add	r0, sp, #12
    9c46:	f7f9 ffe9 	bl	3c1c <settings_save_one>
	if (err) {
    9c4a:	4601      	mov	r1, r0
    9c4c:	b168      	cbz	r0, 9c6a <sc_store+0x52>
		BT_ERR("failed to store SC (err %d)", err);
    9c4e:	2301      	movs	r3, #1
    9c50:	f04f 0200 	mov.w	r2, #0
    9c54:	f363 0207 	bfi	r2, r3, #0, #8
    9c58:	4807      	ldr	r0, [pc, #28]	; (9c78 <sc_store+0x60>)
    9c5a:	4b08      	ldr	r3, [pc, #32]	; (9c7c <sc_store+0x64>)
    9c5c:	1a1b      	subs	r3, r3, r0
    9c5e:	08db      	lsrs	r3, r3, #3
    9c60:	f363 128f 	bfi	r2, r3, #6, #10
    9c64:	4806      	ldr	r0, [pc, #24]	; (9c80 <sc_store+0x68>)
    9c66:	f010 fce1 	bl	1a62c <log_1>
}
    9c6a:	b00c      	add	sp, #48	; 0x30
    9c6c:	bd70      	pop	{r4, r5, r6, pc}
		bt_settings_encode_key(key, sizeof(key), "sc",
    9c6e:	9200      	str	r2, [sp, #0]
    9c70:	e7df      	b.n	9c32 <sc_store+0x1a>
    9c72:	bf00      	nop
    9c74:	00021449 	.word	0x00021449
    9c78:	0001ed28 	.word	0x0001ed28
    9c7c:	0001ede0 	.word	0x0001ede0
    9c80:	00021424 	.word	0x00021424

00009c84 <sc_clear>:
{
    9c84:	b570      	push	{r4, r5, r6, lr}
		if (cfg->data.start || cfg->data.end) {
    9c86:	8903      	ldrh	r3, [r0, #8]
{
    9c88:	b08c      	sub	sp, #48	; 0x30
    9c8a:	4604      	mov	r4, r0
		if (cfg->data.start || cfg->data.end) {
    9c8c:	b90b      	cbnz	r3, 9c92 <sc_clear+0xe>
    9c8e:	8943      	ldrh	r3, [r0, #10]
    9c90:	b33b      	cbz	r3, 9ce2 <sc_clear+0x5e>
		if (modified && bt_addr_le_is_bonded(cfg->id, &cfg->peer)) {
    9c92:	4625      	mov	r5, r4
    9c94:	f815 0b01 	ldrb.w	r0, [r5], #1
    9c98:	4629      	mov	r1, r5
    9c9a:	f011 fbd0 	bl	1b43e <bt_addr_le_is_bonded>
    9c9e:	b300      	cbz	r0, 9ce2 <sc_clear+0x5e>
			if (cfg->id) {
    9ca0:	7822      	ldrb	r2, [r4, #0]
    9ca2:	b32a      	cbz	r2, 9cf0 <sc_clear+0x6c>
				u8_to_dec(id_str, sizeof(id_str), cfg->id);
    9ca4:	ae02      	add	r6, sp, #8
    9ca6:	2104      	movs	r1, #4
    9ca8:	4630      	mov	r0, r6
    9caa:	f00e ffa4 	bl	18bf6 <u8_to_dec>
				bt_settings_encode_key(key, sizeof(key), "sc",
    9cae:	9600      	str	r6, [sp, #0]
				bt_settings_encode_key(key, sizeof(key), "sc",
    9cb0:	2124      	movs	r1, #36	; 0x24
    9cb2:	462b      	mov	r3, r5
    9cb4:	4a0f      	ldr	r2, [pc, #60]	; (9cf4 <sc_clear+0x70>)
    9cb6:	a803      	add	r0, sp, #12
    9cb8:	f7fb fb62 	bl	5380 <bt_settings_encode_key>
			err = settings_delete(key);
    9cbc:	a803      	add	r0, sp, #12
    9cbe:	f010 fed6 	bl	1aa6e <settings_delete>
			if (err) {
    9cc2:	4601      	mov	r1, r0
    9cc4:	b168      	cbz	r0, 9ce2 <sc_clear+0x5e>
				BT_ERR("failed to delete SC (err %d)", err);
    9cc6:	2301      	movs	r3, #1
    9cc8:	f04f 0200 	mov.w	r2, #0
    9ccc:	f363 0207 	bfi	r2, r3, #0, #8
    9cd0:	4809      	ldr	r0, [pc, #36]	; (9cf8 <sc_clear+0x74>)
    9cd2:	4b0a      	ldr	r3, [pc, #40]	; (9cfc <sc_clear+0x78>)
    9cd4:	1a1b      	subs	r3, r3, r0
    9cd6:	08db      	lsrs	r3, r3, #3
    9cd8:	f363 128f 	bfi	r2, r3, #6, #10
    9cdc:	4808      	ldr	r0, [pc, #32]	; (9d00 <sc_clear+0x7c>)
    9cde:	f010 fca5 	bl	1a62c <log_1>
	memset(cfg, 0, sizeof(*cfg));
    9ce2:	220c      	movs	r2, #12
    9ce4:	2100      	movs	r1, #0
    9ce6:	4620      	mov	r0, r4
    9ce8:	f011 f9b1 	bl	1b04e <memset>
}
    9cec:	b00c      	add	sp, #48	; 0x30
    9cee:	bd70      	pop	{r4, r5, r6, pc}
				bt_settings_encode_key(key, sizeof(key), "sc",
    9cf0:	9200      	str	r2, [sp, #0]
    9cf2:	e7dd      	b.n	9cb0 <sc_clear+0x2c>
    9cf4:	00021449 	.word	0x00021449
    9cf8:	0001ed28 	.word	0x0001ed28
    9cfc:	0001ede0 	.word	0x0001ede0
    9d00:	000213aa 	.word	0x000213aa

00009d04 <disconnected_cb>:
	if (attr->write != bt_gatt_attr_write_ccc) {
    9d04:	6882      	ldr	r2, [r0, #8]
    9d06:	4b1f      	ldr	r3, [pc, #124]	; (9d84 <disconnected_cb+0x80>)
    9d08:	429a      	cmp	r2, r3
{
    9d0a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9d0e:	4607      	mov	r7, r0
    9d10:	460e      	mov	r6, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
    9d12:	d102      	bne.n	9d1a <disconnected_cb+0x16>
	ccc = attr->user_data;
    9d14:	68c4      	ldr	r4, [r0, #12]
	if (!ccc->value) {
    9d16:	8963      	ldrh	r3, [r4, #10]
    9d18:	b9eb      	cbnz	r3, 9d56 <disconnected_cb+0x52>
}
    9d1a:	2001      	movs	r0, #1
    9d1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		    bt_conn_addr_le_cmp(conn, &cfg->peer)) {
    9d20:	4629      	mov	r1, r5
    9d22:	4630      	mov	r0, r6
    9d24:	f011 fc33 	bl	1b58e <bt_conn_addr_le_cmp>
		if (conn->id != cfg->id ||
    9d28:	b9e8      	cbnz	r0, 9d66 <disconnected_cb+0x62>
			if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    9d2a:	f106 0870 	add.w	r8, r6, #112	; 0x70
    9d2e:	4641      	mov	r1, r8
    9d30:	7a30      	ldrb	r0, [r6, #8]
    9d32:	f011 fb84 	bl	1b43e <bt_addr_le_is_bonded>
    9d36:	b948      	cbnz	r0, 9d4c <disconnected_cb+0x48>
				clear_ccc_cfg(cfg);
    9d38:	4620      	mov	r0, r4
    9d3a:	f012 f8f2 	bl	1bf22 <clear_ccc_cfg>
    9d3e:	e018      	b.n	9d72 <disconnected_cb+0x6e>
				if (tmp->state == BT_CONN_CONNECTED) {
    9d40:	7b45      	ldrb	r5, [r0, #13]
				bt_conn_unref(tmp);
    9d42:	f011 fc3c 	bl	1b5be <bt_conn_unref>
	if (!value_used) {
    9d46:	2d06      	cmp	r5, #6
    9d48:	d0e7      	beq.n	9d1a <disconnected_cb+0x16>
    9d4a:	e012      	b.n	9d72 <disconnected_cb+0x6e>
				bt_addr_le_copy(&cfg->peer, &conn->le.dst);
    9d4c:	4641      	mov	r1, r8
    9d4e:	4628      	mov	r0, r5
    9d50:	f012 f8e4 	bl	1bf1c <bt_addr_le_copy>
    9d54:	e00d      	b.n	9d72 <disconnected_cb+0x6e>
		if (!cfg->value) {
    9d56:	8923      	ldrh	r3, [r4, #8]
    9d58:	b15b      	cbz	r3, 9d72 <disconnected_cb+0x6e>
		if (conn->id != cfg->id ||
    9d5a:	4625      	mov	r5, r4
    9d5c:	7a32      	ldrb	r2, [r6, #8]
    9d5e:	f815 3b01 	ldrb.w	r3, [r5], #1
    9d62:	429a      	cmp	r2, r3
    9d64:	d0dc      	beq.n	9d20 <disconnected_cb+0x1c>
			tmp = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
    9d66:	4629      	mov	r1, r5
    9d68:	7820      	ldrb	r0, [r4, #0]
    9d6a:	f7fe fb07 	bl	837c <bt_conn_lookup_addr_le>
			if (tmp) {
    9d6e:	2800      	cmp	r0, #0
    9d70:	d1e6      	bne.n	9d40 <disconnected_cb+0x3c>
		if (ccc->cfg_changed) {
    9d72:	68e3      	ldr	r3, [r4, #12]
		ccc->value = 0U;
    9d74:	2100      	movs	r1, #0
    9d76:	8161      	strh	r1, [r4, #10]
		if (ccc->cfg_changed) {
    9d78:	2b00      	cmp	r3, #0
    9d7a:	d0ce      	beq.n	9d1a <disconnected_cb+0x16>
			ccc->cfg_changed(attr, ccc->value);
    9d7c:	4638      	mov	r0, r7
    9d7e:	4798      	blx	r3
    9d80:	e7cb      	b.n	9d1a <disconnected_cb+0x16>
    9d82:	bf00      	nop
    9d84:	0000a031 	.word	0x0000a031

00009d88 <gatt_notify>:
{
    9d88:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    9d8c:	4614      	mov	r4, r2
				sizeof(*nfy) + params->len);
    9d8e:	8992      	ldrh	r2, [r2, #12]
{
    9d90:	4689      	mov	r9, r1
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
    9d92:	3202      	adds	r2, #2
    9d94:	211b      	movs	r1, #27
{
    9d96:	4680      	mov	r8, r0
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
    9d98:	f7ff f846 	bl	8e28 <bt_att_create_pdu>
	if (!buf) {
    9d9c:	4605      	mov	r5, r0
    9d9e:	b1c8      	cbz	r0, 9dd4 <gatt_notify+0x4c>
	nfy = net_buf_add(buf, sizeof(*nfy));
    9da0:	f100 0708 	add.w	r7, r0, #8
    9da4:	2102      	movs	r1, #2
    9da6:	4638      	mov	r0, r7
    9da8:	f013 ff50 	bl	1dc4c <net_buf_simple_add>
	nfy->handle = sys_cpu_to_le16(handle);
    9dac:	4606      	mov	r6, r0
	net_buf_add(buf, params->len);
    9dae:	89a1      	ldrh	r1, [r4, #12]
	nfy->handle = sys_cpu_to_le16(handle);
    9db0:	f826 9b02 	strh.w	r9, [r6], #2
	net_buf_add(buf, params->len);
    9db4:	4638      	mov	r0, r7
    9db6:	f013 ff49 	bl	1dc4c <net_buf_simple_add>
	memcpy(nfy->value, params->data, params->len);
    9dba:	89a2      	ldrh	r2, [r4, #12]
    9dbc:	68a1      	ldr	r1, [r4, #8]
    9dbe:	4630      	mov	r0, r6
    9dc0:	f011 f91b 	bl	1affa <memcpy>
	return bt_att_send(conn, buf, params->func, params->user_data);
    9dc4:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    9dc8:	4629      	mov	r1, r5
    9dca:	4640      	mov	r0, r8
}
    9dcc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return bt_att_send(conn, buf, params->func, params->user_data);
    9dd0:	f012 b840 	b.w	1be54 <bt_att_send>
		BT_WARN("No buffer available to send notification");
    9dd4:	2302      	movs	r3, #2
    9dd6:	f04f 0100 	mov.w	r1, #0
    9dda:	4a07      	ldr	r2, [pc, #28]	; (9df8 <gatt_notify+0x70>)
    9ddc:	4807      	ldr	r0, [pc, #28]	; (9dfc <gatt_notify+0x74>)
    9dde:	f363 0107 	bfi	r1, r3, #0, #8
    9de2:	4b07      	ldr	r3, [pc, #28]	; (9e00 <gatt_notify+0x78>)
    9de4:	1a9b      	subs	r3, r3, r2
    9de6:	08db      	lsrs	r3, r3, #3
    9de8:	f363 118f 	bfi	r1, r3, #6, #10
    9dec:	f010 fc11 	bl	1a612 <log_0>
}
    9df0:	f06f 000b 	mvn.w	r0, #11
    9df4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    9df8:	0001ed28 	.word	0x0001ed28
    9dfc:	00021344 	.word	0x00021344
    9e00:	0001ede0 	.word	0x0001ede0

00009e04 <gatt_send.constprop.37>:
static int gatt_send(struct bt_conn *conn, struct net_buf *buf,
    9e04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9e08:	4606      	mov	r6, r0
    9e0a:	4688      	mov	r8, r1
    9e0c:	4617      	mov	r7, r2
	if (params) {
    9e0e:	461c      	mov	r4, r3
    9e10:	b343      	cbz	r3, 9e64 <gatt_send.constprop.37+0x60>
		req = bt_att_req_alloc(BT_ATT_TIMEOUT);
    9e12:	f247 5030 	movw	r0, #30000	; 0x7530
    9e16:	f7ff fd15 	bl	9844 <bt_att_req_alloc>
		if (!req) {
    9e1a:	4605      	mov	r5, r0
    9e1c:	b348      	cbz	r0, 9e72 <gatt_send.constprop.37+0x6e>
		req->destroy = destroy;
    9e1e:	2300      	movs	r3, #0
		req->user_data = params;
    9e20:	6184      	str	r4, [r0, #24]
		req->buf = buf;
    9e22:	f8c0 8010 	str.w	r8, [r0, #16]
		req->func = func;
    9e26:	6047      	str	r7, [r0, #4]
		req->destroy = destroy;
    9e28:	6083      	str	r3, [r0, #8]
		err = bt_att_req_send(conn, req);
    9e2a:	4601      	mov	r1, r0
    9e2c:	4630      	mov	r0, r6
    9e2e:	f012 f841 	bl	1beb4 <bt_att_req_send>
		if (err) {
    9e32:	4604      	mov	r4, r0
    9e34:	b918      	cbnz	r0, 9e3e <gatt_send.constprop.37+0x3a>
static int gatt_send(struct bt_conn *conn, struct net_buf *buf,
    9e36:	2400      	movs	r4, #0
}
    9e38:	4620      	mov	r0, r4
    9e3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			bt_att_req_free(req);
    9e3e:	4628      	mov	r0, r5
    9e40:	f7ff fd14 	bl	986c <bt_att_req_free>
		BT_ERR("Error sending ATT PDU: %d", err);
    9e44:	2301      	movs	r3, #1
    9e46:	f04f 0200 	mov.w	r2, #0
    9e4a:	f363 0207 	bfi	r2, r3, #0, #8
    9e4e:	490a      	ldr	r1, [pc, #40]	; (9e78 <gatt_send.constprop.37+0x74>)
    9e50:	4b0a      	ldr	r3, [pc, #40]	; (9e7c <gatt_send.constprop.37+0x78>)
    9e52:	480b      	ldr	r0, [pc, #44]	; (9e80 <gatt_send.constprop.37+0x7c>)
    9e54:	1a5b      	subs	r3, r3, r1
    9e56:	08db      	lsrs	r3, r3, #3
    9e58:	f363 128f 	bfi	r2, r3, #6, #10
    9e5c:	4621      	mov	r1, r4
    9e5e:	f010 fbe5 	bl	1a62c <log_1>
    9e62:	e7e9      	b.n	9e38 <gatt_send.constprop.37+0x34>
		err = bt_att_send(conn, buf, NULL, NULL);
    9e64:	461a      	mov	r2, r3
    9e66:	f011 fff5 	bl	1be54 <bt_att_send>
	if (err) {
    9e6a:	4604      	mov	r4, r0
    9e6c:	2800      	cmp	r0, #0
    9e6e:	d0e2      	beq.n	9e36 <gatt_send.constprop.37+0x32>
    9e70:	e7e8      	b.n	9e44 <gatt_send.constprop.37+0x40>
			return -ENOMEM;
    9e72:	f06f 040b 	mvn.w	r4, #11
    9e76:	e7df      	b.n	9e38 <gatt_send.constprop.37+0x34>
    9e78:	0001ed28 	.word	0x0001ed28
    9e7c:	0001ede0 	.word	0x0001ede0
    9e80:	00021390 	.word	0x00021390

00009e84 <gatt_indicate>:
{
    9e84:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    9e88:	4614      	mov	r4, r2
				sizeof(*ind) + params->len);
    9e8a:	8a12      	ldrh	r2, [r2, #16]
{
    9e8c:	4689      	mov	r9, r1
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE,
    9e8e:	3202      	adds	r2, #2
    9e90:	211d      	movs	r1, #29
{
    9e92:	4680      	mov	r8, r0
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE,
    9e94:	f7fe ffc8 	bl	8e28 <bt_att_create_pdu>
	if (!buf) {
    9e98:	4605      	mov	r5, r0
    9e9a:	b1e8      	cbz	r0, 9ed8 <gatt_indicate+0x54>
	ind = net_buf_add(buf, sizeof(*ind));
    9e9c:	f100 0608 	add.w	r6, r0, #8
    9ea0:	2102      	movs	r1, #2
    9ea2:	4630      	mov	r0, r6
    9ea4:	f013 fed2 	bl	1dc4c <net_buf_simple_add>
	ind->handle = sys_cpu_to_le16(handle);
    9ea8:	4607      	mov	r7, r0
	net_buf_add(buf, params->len);
    9eaa:	8a21      	ldrh	r1, [r4, #16]
	ind->handle = sys_cpu_to_le16(handle);
    9eac:	f827 9b02 	strh.w	r9, [r7], #2
	net_buf_add(buf, params->len);
    9eb0:	4630      	mov	r0, r6
    9eb2:	f013 fecb 	bl	1dc4c <net_buf_simple_add>
	memcpy(ind->value, params->data, params->len);
    9eb6:	8a22      	ldrh	r2, [r4, #16]
    9eb8:	68e1      	ldr	r1, [r4, #12]
    9eba:	4638      	mov	r0, r7
    9ebc:	f011 f89d 	bl	1affa <memcpy>
	if (!params->func) {
    9ec0:	68a3      	ldr	r3, [r4, #8]
    9ec2:	b933      	cbnz	r3, 9ed2 <gatt_indicate+0x4e>
		return gatt_send(conn, buf, NULL, NULL, NULL);
    9ec4:	461a      	mov	r2, r3
	return gatt_send(conn, buf, gatt_indicate_rsp, params, NULL);
    9ec6:	4629      	mov	r1, r5
    9ec8:	4640      	mov	r0, r8
}
    9eca:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return gatt_send(conn, buf, gatt_indicate_rsp, params, NULL);
    9ece:	f7ff bf99 	b.w	9e04 <gatt_send.constprop.37>
    9ed2:	4623      	mov	r3, r4
    9ed4:	4a09      	ldr	r2, [pc, #36]	; (9efc <gatt_indicate+0x78>)
    9ed6:	e7f6      	b.n	9ec6 <gatt_indicate+0x42>
		BT_WARN("No buffer available to send indication");
    9ed8:	2302      	movs	r3, #2
    9eda:	f04f 0100 	mov.w	r1, #0
    9ede:	4a08      	ldr	r2, [pc, #32]	; (9f00 <gatt_indicate+0x7c>)
    9ee0:	4808      	ldr	r0, [pc, #32]	; (9f04 <gatt_indicate+0x80>)
    9ee2:	f363 0107 	bfi	r1, r3, #0, #8
    9ee6:	4b08      	ldr	r3, [pc, #32]	; (9f08 <gatt_indicate+0x84>)
    9ee8:	1a9b      	subs	r3, r3, r2
    9eea:	08db      	lsrs	r3, r3, #3
    9eec:	f363 118f 	bfi	r1, r3, #6, #10
    9ef0:	f010 fb8f 	bl	1a612 <log_0>
}
    9ef4:	f06f 000b 	mvn.w	r0, #11
    9ef8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    9efc:	0001bf0d 	.word	0x0001bf0d
    9f00:	0001ed28 	.word	0x0001ed28
    9f04:	0002131d 	.word	0x0002131d
    9f08:	0001ede0 	.word	0x0001ede0

00009f0c <ccc_load>:
	if (attr->write != bt_gatt_attr_write_ccc) {
    9f0c:	6882      	ldr	r2, [r0, #8]
    9f0e:	4b22      	ldr	r3, [pc, #136]	; (9f98 <ccc_load+0x8c>)
    9f10:	429a      	cmp	r2, r3
{
    9f12:	b573      	push	{r0, r1, r4, r5, r6, lr}
    9f14:	460c      	mov	r4, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
    9f16:	d002      	beq.n	9f1e <ccc_load+0x12>
		return BT_GATT_ITER_CONTINUE;
    9f18:	2001      	movs	r0, #1
}
    9f1a:	b002      	add	sp, #8
    9f1c:	bd70      	pop	{r4, r5, r6, pc}
	if (!load->entry) {
    9f1e:	688a      	ldr	r2, [r1, #8]
	ccc = attr->user_data;
    9f20:	68c6      	ldr	r6, [r0, #12]
	if (!load->entry) {
    9f22:	b94a      	cbnz	r2, 9f38 <ccc_load+0x2c>
	cfg = ccc_find_cfg(ccc, addr, id);
    9f24:	790a      	ldrb	r2, [r1, #4]
    9f26:	6809      	ldr	r1, [r1, #0]
    9f28:	4630      	mov	r0, r6
    9f2a:	f012 f8db 	bl	1c0e4 <ccc_find_cfg>
	if (!cfg) {
    9f2e:	2800      	cmp	r0, #0
    9f30:	d0f2      	beq.n	9f18 <ccc_load+0xc>
	clear_ccc_cfg(cfg);
    9f32:	f011 fff6 	bl	1bf22 <clear_ccc_cfg>
    9f36:	e7ef      	b.n	9f18 <ccc_load+0xc>
	} else if (!load->count) {
    9f38:	68cb      	ldr	r3, [r1, #12]
    9f3a:	b353      	cbz	r3, 9f92 <ccc_load+0x86>
	if (load->entry->handle != attr->handle) {
    9f3c:	8812      	ldrh	r2, [r2, #0]
    9f3e:	8a03      	ldrh	r3, [r0, #16]
    9f40:	429a      	cmp	r2, r3
    9f42:	d00a      	beq.n	9f5a <ccc_load+0x4e>
		if (load->entry->handle < attr->handle) {
    9f44:	d2e8      	bcs.n	9f18 <ccc_load+0xc>
	load->count--;
    9f46:	68e0      	ldr	r0, [r4, #12]
	load->entry++;
    9f48:	68a3      	ldr	r3, [r4, #8]
	load->count--;
    9f4a:	3801      	subs	r0, #1
	load->entry++;
    9f4c:	3304      	adds	r3, #4
	load->count--;
    9f4e:	60e0      	str	r0, [r4, #12]
	return load->count ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
    9f50:	3000      	adds	r0, #0
	load->entry++;
    9f52:	60a3      	str	r3, [r4, #8]
	return load->count ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
    9f54:	bf18      	it	ne
    9f56:	2001      	movne	r0, #1
    9f58:	e7df      	b.n	9f1a <ccc_load+0xe>
	cfg = ccc_find_cfg(ccc, load->addr_with_id.addr, load->addr_with_id.id);
    9f5a:	790a      	ldrb	r2, [r1, #4]
    9f5c:	6809      	ldr	r1, [r1, #0]
    9f5e:	4630      	mov	r0, r6
    9f60:	f012 f8c0 	bl	1c0e4 <ccc_find_cfg>
	if (!cfg) {
    9f64:	4605      	mov	r5, r0
    9f66:	b980      	cbnz	r0, 9f8a <ccc_load+0x7e>
		cfg = ccc_find_cfg(ccc, BT_ADDR_LE_ANY, 0);
    9f68:	9000      	str	r0, [sp, #0]
    9f6a:	4602      	mov	r2, r0
    9f6c:	f8cd 0003 	str.w	r0, [sp, #3]
    9f70:	4669      	mov	r1, sp
    9f72:	4630      	mov	r0, r6
    9f74:	f012 f8b6 	bl	1c0e4 <ccc_find_cfg>
		if (!cfg) {
    9f78:	4605      	mov	r5, r0
    9f7a:	2800      	cmp	r0, #0
    9f7c:	d0e3      	beq.n	9f46 <ccc_load+0x3a>
		bt_addr_le_copy(&cfg->peer, load->addr_with_id.addr);
    9f7e:	6821      	ldr	r1, [r4, #0]
    9f80:	3001      	adds	r0, #1
    9f82:	f011 ffcb 	bl	1bf1c <bt_addr_le_copy>
		cfg->id = load->addr_with_id.id;
    9f86:	7923      	ldrb	r3, [r4, #4]
    9f88:	702b      	strb	r3, [r5, #0]
	cfg->value = load->entry->value;
    9f8a:	68a3      	ldr	r3, [r4, #8]
    9f8c:	885b      	ldrh	r3, [r3, #2]
    9f8e:	812b      	strh	r3, [r5, #8]
    9f90:	e7d9      	b.n	9f46 <ccc_load+0x3a>
		return BT_GATT_ITER_STOP;
    9f92:	4618      	mov	r0, r3
    9f94:	e7c1      	b.n	9f1a <ccc_load+0xe>
    9f96:	bf00      	nop
    9f98:	0000a031 	.word	0x0000a031

00009f9c <ccc_save>:
{
    9f9c:	b538      	push	{r3, r4, r5, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
    9f9e:	6882      	ldr	r2, [r0, #8]
    9fa0:	4b0b      	ldr	r3, [pc, #44]	; (9fd0 <ccc_save+0x34>)
    9fa2:	429a      	cmp	r2, r3
{
    9fa4:	4605      	mov	r5, r0
    9fa6:	460c      	mov	r4, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
    9fa8:	d110      	bne.n	9fcc <ccc_save+0x30>
	cfg = ccc_find_cfg(ccc, save->addr_with_id.addr, save->addr_with_id.id);
    9faa:	790a      	ldrb	r2, [r1, #4]
    9fac:	68c0      	ldr	r0, [r0, #12]
    9fae:	6809      	ldr	r1, [r1, #0]
    9fb0:	f012 f898 	bl	1c0e4 <ccc_find_cfg>
	if (!cfg) {
    9fb4:	b150      	cbz	r0, 9fcc <ccc_save+0x30>
	save->store[save->count].handle = attr->handle;
    9fb6:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
    9fba:	8a29      	ldrh	r1, [r5, #16]
    9fbc:	eb04 0283 	add.w	r2, r4, r3, lsl #2
	save->count++;
    9fc0:	3301      	adds	r3, #1
	save->store[save->count].handle = attr->handle;
    9fc2:	8111      	strh	r1, [r2, #8]
	save->store[save->count].value = cfg->value;
    9fc4:	8901      	ldrh	r1, [r0, #8]
    9fc6:	8151      	strh	r1, [r2, #10]
	save->count++;
    9fc8:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
}
    9fcc:	2001      	movs	r0, #1
    9fce:	bd38      	pop	{r3, r4, r5, pc}
    9fd0:	0000a031 	.word	0x0000a031

00009fd4 <remove_peer_from_attr>:
{
    9fd4:	b508      	push	{r3, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
    9fd6:	6882      	ldr	r2, [r0, #8]
    9fd8:	4b07      	ldr	r3, [pc, #28]	; (9ff8 <remove_peer_from_attr+0x24>)
    9fda:	429a      	cmp	r2, r3
    9fdc:	d109      	bne.n	9ff2 <remove_peer_from_attr+0x1e>
	cfg = ccc_find_cfg(ccc, addr_with_id->addr, addr_with_id->id);
    9fde:	790a      	ldrb	r2, [r1, #4]
    9fe0:	68c0      	ldr	r0, [r0, #12]
    9fe2:	6809      	ldr	r1, [r1, #0]
    9fe4:	f012 f87e 	bl	1c0e4 <ccc_find_cfg>
	if (cfg) {
    9fe8:	b118      	cbz	r0, 9ff2 <remove_peer_from_attr+0x1e>
		memset(cfg, 0, sizeof(*cfg));
    9fea:	220a      	movs	r2, #10
    9fec:	2100      	movs	r1, #0
    9fee:	f011 f82e 	bl	1b04e <memset>
}
    9ff2:	2001      	movs	r0, #1
    9ff4:	bd08      	pop	{r3, pc}
    9ff6:	bf00      	nop
    9ff8:	0000a031 	.word	0x0000a031

00009ffc <find_cf_cfg_by_addr.part.14>:
static struct gatt_cf_cfg *find_cf_cfg_by_addr(const bt_addr_le_t *addr)
    9ffc:	b538      	push	{r3, r4, r5, lr}
	return memcmp(a, b, sizeof(*a));
    9ffe:	2207      	movs	r2, #7
    a000:	4909      	ldr	r1, [pc, #36]	; (a028 <find_cf_cfg_by_addr.part.14+0x2c>)
    a002:	4c0a      	ldr	r4, [pc, #40]	; (a02c <find_cf_cfg_by_addr.part.14+0x30>)
    a004:	4605      	mov	r5, r0
    a006:	f010 ffe8 	bl	1afda <memcmp>
		if (!bt_addr_le_cmp(addr, &cf_cfg[i].peer)) {
    a00a:	b138      	cbz	r0, a01c <find_cf_cfg_by_addr.part.14+0x20>
    a00c:	2207      	movs	r2, #7
    a00e:	f104 0111 	add.w	r1, r4, #17
    a012:	4628      	mov	r0, r5
    a014:	f010 ffe1 	bl	1afda <memcmp>
    a018:	b918      	cbnz	r0, a022 <find_cf_cfg_by_addr.part.14+0x26>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    a01a:	2001      	movs	r0, #1
			return &cf_cfg[i];
    a01c:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}
    a020:	bd38      	pop	{r3, r4, r5, pc}
	return NULL;
    a022:	2000      	movs	r0, #0
    a024:	e7fc      	b.n	a020 <find_cf_cfg_by_addr.part.14+0x24>
    a026:	bf00      	nop
    a028:	20000421 	.word	0x20000421
    a02c:	20000420 	.word	0x20000420

0000a030 <bt_gatt_attr_write_ccc>:
{
    a030:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    a034:	4698      	mov	r8, r3
    a036:	f8bd 3020 	ldrh.w	r3, [sp, #32]
	struct _bt_gatt_ccc *ccc = attr->user_data;
    a03a:	68ce      	ldr	r6, [r1, #12]
{
    a03c:	4607      	mov	r7, r0
    a03e:	4689      	mov	r9, r1
	if (offset) {
    a040:	2b00      	cmp	r3, #0
    a042:	d14e      	bne.n	a0e2 <bt_gatt_attr_write_ccc+0xb2>
	if (!len || len > sizeof(u16_t)) {
    a044:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
    a048:	2b01      	cmp	r3, #1
    a04a:	d84d      	bhi.n	a0e8 <bt_gatt_attr_write_ccc+0xb8>
	if (len < sizeof(u16_t)) {
    a04c:	f1b8 0f01 	cmp.w	r8, #1
		value = *(u8_t *)buf;
    a050:	7814      	ldrb	r4, [r2, #0]
	return ((u16_t)src[1] << 8) | src[0];
    a052:	bf18      	it	ne
    a054:	7853      	ldrbne	r3, [r2, #1]
	cfg = find_ccc_cfg(conn, ccc);
    a056:	4631      	mov	r1, r6
		value = *(u8_t *)buf;
    a058:	bf0c      	ite	eq
    a05a:	b2a4      	uxtheq	r4, r4
    a05c:	ea44 2403 	orrne.w	r4, r4, r3, lsl #8
	cfg = find_ccc_cfg(conn, ccc);
    a060:	f012 f84f 	bl	1c102 <find_ccc_cfg>
	if (!cfg) {
    a064:	4605      	mov	r5, r0
    a066:	bb00      	cbnz	r0, a0aa <bt_gatt_attr_write_ccc+0x7a>
		if (!value) {
    a068:	b914      	cbnz	r4, a070 <bt_gatt_attr_write_ccc+0x40>
			return len;
    a06a:	4640      	mov	r0, r8
}
    a06c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		cfg = find_ccc_cfg(NULL, ccc);
    a070:	4631      	mov	r1, r6
    a072:	f012 f846 	bl	1c102 <find_ccc_cfg>
		if (!cfg) {
    a076:	4605      	mov	r5, r0
    a078:	b980      	cbnz	r0, a09c <bt_gatt_attr_write_ccc+0x6c>
			BT_WARN("No space to store CCC cfg");
    a07a:	2302      	movs	r3, #2
    a07c:	f04f 0100 	mov.w	r1, #0
    a080:	f363 0107 	bfi	r1, r3, #0, #8
    a084:	4a1a      	ldr	r2, [pc, #104]	; (a0f0 <bt_gatt_attr_write_ccc+0xc0>)
    a086:	4b1b      	ldr	r3, [pc, #108]	; (a0f4 <bt_gatt_attr_write_ccc+0xc4>)
    a088:	481b      	ldr	r0, [pc, #108]	; (a0f8 <bt_gatt_attr_write_ccc+0xc8>)
    a08a:	1a9b      	subs	r3, r3, r2
    a08c:	08db      	lsrs	r3, r3, #3
    a08e:	f363 118f 	bfi	r1, r3, #6, #10
    a092:	f010 fabe 	bl	1a612 <log_0>
			return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
    a096:	f06f 0010 	mvn.w	r0, #16
    a09a:	e7e7      	b.n	a06c <bt_gatt_attr_write_ccc+0x3c>
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
    a09c:	f107 0170 	add.w	r1, r7, #112	; 0x70
    a0a0:	3001      	adds	r0, #1
    a0a2:	f011 ff3b 	bl	1bf1c <bt_addr_le_copy>
		cfg->id = conn->id;
    a0a6:	7a3b      	ldrb	r3, [r7, #8]
    a0a8:	702b      	strb	r3, [r5, #0]
	if (ccc->cfg_write) {
    a0aa:	6933      	ldr	r3, [r6, #16]
    a0ac:	b96b      	cbnz	r3, a0ca <bt_gatt_attr_write_ccc+0x9a>
	if (cfg->value != ccc->value) {
    a0ae:	8973      	ldrh	r3, [r6, #10]
	cfg->value = value;
    a0b0:	812c      	strh	r4, [r5, #8]
	if (cfg->value != ccc->value) {
    a0b2:	42a3      	cmp	r3, r4
    a0b4:	d003      	beq.n	a0be <bt_gatt_attr_write_ccc+0x8e>
		gatt_ccc_changed(attr, ccc);
    a0b6:	4631      	mov	r1, r6
    a0b8:	4648      	mov	r0, r9
    a0ba:	f011 ff1d 	bl	1bef8 <gatt_ccc_changed>
	if (!value) {
    a0be:	2c00      	cmp	r4, #0
    a0c0:	d1d3      	bne.n	a06a <bt_gatt_attr_write_ccc+0x3a>
		clear_ccc_cfg(cfg);
    a0c2:	4628      	mov	r0, r5
    a0c4:	f011 ff2d 	bl	1bf22 <clear_ccc_cfg>
    a0c8:	e7cf      	b.n	a06a <bt_gatt_attr_write_ccc+0x3a>
		ssize_t write = ccc->cfg_write(conn, attr, value);
    a0ca:	4622      	mov	r2, r4
    a0cc:	4649      	mov	r1, r9
    a0ce:	4638      	mov	r0, r7
    a0d0:	4798      	blx	r3
		if (write < 0) {
    a0d2:	2800      	cmp	r0, #0
    a0d4:	dbca      	blt.n	a06c <bt_gatt_attr_write_ccc+0x3c>
		if (write != sizeof(value) && write != 1) {
    a0d6:	3801      	subs	r0, #1
    a0d8:	2801      	cmp	r0, #1
    a0da:	d9e8      	bls.n	a0ae <bt_gatt_attr_write_ccc+0x7e>
			return BT_GATT_ERR(BT_ATT_ERR_UNLIKELY);
    a0dc:	f06f 000d 	mvn.w	r0, #13
    a0e0:	e7c4      	b.n	a06c <bt_gatt_attr_write_ccc+0x3c>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
    a0e2:	f06f 0006 	mvn.w	r0, #6
    a0e6:	e7c1      	b.n	a06c <bt_gatt_attr_write_ccc+0x3c>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
    a0e8:	f06f 000c 	mvn.w	r0, #12
    a0ec:	e7be      	b.n	a06c <bt_gatt_attr_write_ccc+0x3c>
    a0ee:	bf00      	nop
    a0f0:	0001ed28 	.word	0x0001ed28
    a0f4:	0001ede0 	.word	0x0001ede0
    a0f8:	00021199 	.word	0x00021199

0000a0fc <sc_commit>:
{
    a0fc:	b508      	push	{r3, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    a0fe:	f06f 0102 	mvn.w	r1, #2
    a102:	4807      	ldr	r0, [pc, #28]	; (a120 <sc_commit+0x24>)
    a104:	f011 ff99 	bl	1c03a <atomic_and>
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
    a108:	2100      	movs	r1, #0
    a10a:	4805      	ldr	r0, [pc, #20]	; (a120 <sc_commit+0x24>)
    a10c:	f011 ff8c 	bl	1c028 <atomic_test_bit>
    a110:	b120      	cbz	r0, a11c <sc_commit+0x20>
    a112:	220a      	movs	r2, #10
    a114:	4903      	ldr	r1, [pc, #12]	; (a124 <sc_commit+0x28>)
    a116:	4804      	ldr	r0, [pc, #16]	; (a128 <sc_commit+0x2c>)
    a118:	f00e fb26 	bl	18768 <k_delayed_work_submit_to_queue>
}
    a11c:	2000      	movs	r0, #0
    a11e:	bd08      	pop	{r3, pc}
    a120:	20000498 	.word	0x20000498
    a124:	20000478 	.word	0x20000478
    a128:	20001a60 	.word	0x20001a60

0000a12c <gatt_write_ccc.constprop.33>:
static int gatt_write_ccc(struct bt_conn *conn, u16_t handle, u16_t value,
    a12c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a130:	4689      	mov	r9, r1
    a132:	4690      	mov	r8, r2
	buf = bt_att_create_pdu(conn, BT_ATT_OP_WRITE_REQ,
    a134:	2112      	movs	r1, #18
    a136:	2204      	movs	r2, #4
static int gatt_write_ccc(struct bt_conn *conn, u16_t handle, u16_t value,
    a138:	4607      	mov	r7, r0
    a13a:	461d      	mov	r5, r3
	buf = bt_att_create_pdu(conn, BT_ATT_OP_WRITE_REQ,
    a13c:	f7fe fe74 	bl	8e28 <bt_att_create_pdu>
	if (!buf) {
    a140:	4604      	mov	r4, r0
    a142:	b308      	cbz	r0, a188 <gatt_write_ccc.constprop.33+0x5c>
	req = net_buf_add(buf, sizeof(*req));
    a144:	f100 0608 	add.w	r6, r0, #8
    a148:	2102      	movs	r1, #2
    a14a:	4630      	mov	r0, r6
    a14c:	f013 fd7e 	bl	1dc4c <net_buf_simple_add>
	net_buf_add_le16(buf, value);
    a150:	4641      	mov	r1, r8
	req->handle = sys_cpu_to_le16(handle);
    a152:	f8a0 9000 	strh.w	r9, [r0]
	net_buf_add_le16(buf, value);
    a156:	4630      	mov	r0, r6
    a158:	f013 fd8f 	bl	1dc7a <net_buf_simple_add_le16>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    a15c:	f3bf 8f5b 	dmb	ish
    a160:	f105 030c 	add.w	r3, r5, #12
    a164:	e853 2f00 	ldrex	r2, [r3]
    a168:	f042 0204 	orr.w	r2, r2, #4
    a16c:	e843 2100 	strex	r1, r2, [r3]
    a170:	2900      	cmp	r1, #0
    a172:	d1f7      	bne.n	a164 <gatt_write_ccc.constprop.33+0x38>
    a174:	f3bf 8f5b 	dmb	ish
	return gatt_send(conn, buf, func, params, NULL);
    a178:	462b      	mov	r3, r5
    a17a:	4621      	mov	r1, r4
    a17c:	4638      	mov	r0, r7
    a17e:	4a04      	ldr	r2, [pc, #16]	; (a190 <gatt_write_ccc.constprop.33+0x64>)
}
    a180:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return gatt_send(conn, buf, func, params, NULL);
    a184:	f7ff be3e 	b.w	9e04 <gatt_send.constprop.37>
}
    a188:	f06f 000b 	mvn.w	r0, #11
    a18c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a190:	0001c325 	.word	0x0001c325

0000a194 <gatt_sub_find_free>:
{
    a194:	b573      	push	{r0, r1, r4, r5, r6, lr}
    a196:	4606      	mov	r6, r0
	if (free_sub) {
    a198:	460d      	mov	r5, r1
    a19a:	b109      	cbz	r1, a1a0 <gatt_sub_find_free+0xc>
		*free_sub = NULL;
    a19c:	2300      	movs	r3, #0
    a19e:	600b      	str	r3, [r1, #0]
		if (!bt_conn_addr_le_cmp(conn, &sub->peer)) {
    a1a0:	4c14      	ldr	r4, [pc, #80]	; (a1f4 <gatt_sub_find_free+0x60>)
    a1a2:	4630      	mov	r0, r6
    a1a4:	4621      	mov	r1, r4
    a1a6:	f011 f9f2 	bl	1b58e <bt_conn_addr_le_cmp>
    a1aa:	b300      	cbz	r0, a1ee <gatt_sub_find_free+0x5a>
		} else if (free_sub &&
    a1ac:	b155      	cbz	r5, a1c4 <gatt_sub_find_free+0x30>
			   !bt_addr_le_cmp(BT_ADDR_LE_ANY, &sub->peer)) {
    a1ae:	2300      	movs	r3, #0
    a1b0:	2207      	movs	r2, #7
    a1b2:	4621      	mov	r1, r4
    a1b4:	4668      	mov	r0, sp
    a1b6:	9300      	str	r3, [sp, #0]
    a1b8:	f8cd 3003 	str.w	r3, [sp, #3]
    a1bc:	f010 ff0d 	bl	1afda <memcmp>
		} else if (free_sub &&
    a1c0:	b900      	cbnz	r0, a1c4 <gatt_sub_find_free+0x30>
			*free_sub = sub;
    a1c2:	602c      	str	r4, [r5, #0]
		if (!bt_conn_addr_le_cmp(conn, &sub->peer)) {
    a1c4:	4c0c      	ldr	r4, [pc, #48]	; (a1f8 <gatt_sub_find_free+0x64>)
    a1c6:	4630      	mov	r0, r6
    a1c8:	4621      	mov	r1, r4
    a1ca:	f011 f9e0 	bl	1b58e <bt_conn_addr_le_cmp>
    a1ce:	b170      	cbz	r0, a1ee <gatt_sub_find_free+0x5a>
		} else if (free_sub &&
    a1d0:	b155      	cbz	r5, a1e8 <gatt_sub_find_free+0x54>
			   !bt_addr_le_cmp(BT_ADDR_LE_ANY, &sub->peer)) {
    a1d2:	2300      	movs	r3, #0
    a1d4:	2207      	movs	r2, #7
    a1d6:	4621      	mov	r1, r4
    a1d8:	4668      	mov	r0, sp
    a1da:	9300      	str	r3, [sp, #0]
    a1dc:	f8cd 3003 	str.w	r3, [sp, #3]
    a1e0:	f010 fefb 	bl	1afda <memcmp>
		} else if (free_sub &&
    a1e4:	b900      	cbnz	r0, a1e8 <gatt_sub_find_free+0x54>
			*free_sub = sub;
    a1e6:	602c      	str	r4, [r5, #0]
	return NULL;
    a1e8:	2000      	movs	r0, #0
}
    a1ea:	b002      	add	sp, #8
    a1ec:	bd70      	pop	{r4, r5, r6, pc}
		struct gatt_sub *sub = &subscriptions[i];
    a1ee:	4620      	mov	r0, r4
    a1f0:	e7fb      	b.n	a1ea <gatt_sub_find_free+0x56>
    a1f2:	bf00      	nop
    a1f4:	200004b4 	.word	0x200004b4
    a1f8:	200004c4 	.word	0x200004c4

0000a1fc <find_sc_cfg.part.11>:
static struct gatt_sc_cfg *find_sc_cfg(u8_t id, bt_addr_le_t *addr)
    a1fc:	b570      	push	{r4, r5, r6, lr}
		if (id == sc_cfg[i].id &&
    a1fe:	4c0e      	ldr	r4, [pc, #56]	; (a238 <find_sc_cfg.part.11+0x3c>)
    a200:	7823      	ldrb	r3, [r4, #0]
    a202:	4283      	cmp	r3, r0
static struct gatt_sc_cfg *find_sc_cfg(u8_t id, bt_addr_le_t *addr)
    a204:	4605      	mov	r5, r0
    a206:	460e      	mov	r6, r1
		if (id == sc_cfg[i].id &&
    a208:	d00a      	beq.n	a220 <find_sc_cfg.part.11+0x24>
    a20a:	7b23      	ldrb	r3, [r4, #12]
    a20c:	42ab      	cmp	r3, r5
    a20e:	d111      	bne.n	a234 <find_sc_cfg.part.11+0x38>
    a210:	2207      	movs	r2, #7
    a212:	4631      	mov	r1, r6
    a214:	4809      	ldr	r0, [pc, #36]	; (a23c <find_sc_cfg.part.11+0x40>)
    a216:	f010 fee0 	bl	1afda <memcmp>
    a21a:	b958      	cbnz	r0, a234 <find_sc_cfg.part.11+0x38>
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    a21c:	2001      	movs	r0, #1
    a21e:	e005      	b.n	a22c <find_sc_cfg.part.11+0x30>
    a220:	2207      	movs	r2, #7
    a222:	1c60      	adds	r0, r4, #1
    a224:	f010 fed9 	bl	1afda <memcmp>
		if (id == sc_cfg[i].id &&
    a228:	2800      	cmp	r0, #0
    a22a:	d1ee      	bne.n	a20a <find_sc_cfg.part.11+0xe>
			return &sc_cfg[i];
    a22c:	230c      	movs	r3, #12
    a22e:	fb03 4000 	mla	r0, r3, r0, r4
    a232:	e000      	b.n	a236 <find_sc_cfg.part.11+0x3a>
	return NULL;
    a234:	2000      	movs	r0, #0
}
    a236:	bd70      	pop	{r4, r5, r6, pc}
    a238:	20001af0 	.word	0x20001af0
    a23c:	20001afd 	.word	0x20001afd

0000a240 <sc_save>:
{
    a240:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    a244:	4680      	mov	r8, r0
    a246:	460f      	mov	r7, r1
    a248:	4616      	mov	r6, r2
    a24a:	461d      	mov	r5, r3
    a24c:	f7ff ffd6 	bl	a1fc <find_sc_cfg.part.11>
	if (!cfg) {
    a250:	4604      	mov	r4, r0
    a252:	b9e8      	cbnz	r0, a290 <sc_save+0x50>
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
    a254:	4669      	mov	r1, sp
    a256:	9000      	str	r0, [sp, #0]
    a258:	f8cd 0003 	str.w	r0, [sp, #3]
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    a25c:	f7ff ffce 	bl	a1fc <find_sc_cfg.part.11>
		if (!cfg) {
    a260:	4604      	mov	r4, r0
    a262:	b980      	cbnz	r0, a286 <sc_save+0x46>
			BT_ERR("unable to save SC: no cfg left");
    a264:	2301      	movs	r3, #1
    a266:	f04f 0100 	mov.w	r1, #0
    a26a:	f363 0107 	bfi	r1, r3, #0, #8
    a26e:	4a15      	ldr	r2, [pc, #84]	; (a2c4 <sc_save+0x84>)
    a270:	4b15      	ldr	r3, [pc, #84]	; (a2c8 <sc_save+0x88>)
    a272:	4816      	ldr	r0, [pc, #88]	; (a2cc <sc_save+0x8c>)
    a274:	1a9b      	subs	r3, r3, r2
    a276:	08db      	lsrs	r3, r3, #3
    a278:	f363 118f 	bfi	r1, r3, #6, #10
    a27c:	f010 f9c9 	bl	1a612 <log_0>
}
    a280:	b002      	add	sp, #8
    a282:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cfg->id = id;
    a286:	f800 8b01 	strb.w	r8, [r0], #1
		bt_addr_le_copy(&cfg->peer, peer);
    a28a:	4639      	mov	r1, r7
    a28c:	f011 fe46 	bl	1bf1c <bt_addr_le_copy>
	if (!(cfg->data.start || cfg->data.end)) {
    a290:	8922      	ldrh	r2, [r4, #8]
    a292:	8963      	ldrh	r3, [r4, #10]
    a294:	b96a      	cbnz	r2, a2b2 <sc_save+0x72>
    a296:	b973      	cbnz	r3, a2b6 <sc_save+0x76>
		cfg->data.start = start;
    a298:	8126      	strh	r6, [r4, #8]
		*end = new_end;
    a29a:	8165      	strh	r5, [r4, #10]
	    modified && bt_addr_le_is_bonded(cfg->id, &cfg->peer)) {
    a29c:	4621      	mov	r1, r4
    a29e:	f811 0b01 	ldrb.w	r0, [r1], #1
    a2a2:	f011 f8cc 	bl	1b43e <bt_addr_le_is_bonded>
    a2a6:	2800      	cmp	r0, #0
    a2a8:	d0ea      	beq.n	a280 <sc_save+0x40>
		sc_store(cfg);
    a2aa:	4620      	mov	r0, r4
    a2ac:	f7ff fcb4 	bl	9c18 <sc_store>
    a2b0:	e7e6      	b.n	a280 <sc_save+0x40>
	if (new_start >= *start && new_end <= *end) {
    a2b2:	4296      	cmp	r6, r2
    a2b4:	d302      	bcc.n	a2bc <sc_save+0x7c>
    a2b6:	429d      	cmp	r5, r3
    a2b8:	d8ef      	bhi.n	a29a <sc_save+0x5a>
    a2ba:	e7e1      	b.n	a280 <sc_save+0x40>
	if (*end < new_end) {
    a2bc:	429d      	cmp	r5, r3
		*start = new_start;
    a2be:	8126      	strh	r6, [r4, #8]
	if (*end < new_end) {
    a2c0:	d9ec      	bls.n	a29c <sc_save+0x5c>
    a2c2:	e7ea      	b.n	a29a <sc_save+0x5a>
    a2c4:	0001ed28 	.word	0x0001ed28
    a2c8:	0001ede0 	.word	0x0001ede0
    a2cc:	000213c7 	.word	0x000213c7

0000a2d0 <notify_cb>:
	if (attr->write != bt_gatt_attr_write_ccc) {
    a2d0:	6882      	ldr	r2, [r0, #8]
    a2d2:	4b33      	ldr	r3, [pc, #204]	; (a3a0 <notify_cb+0xd0>)
    a2d4:	429a      	cmp	r2, r3
{
    a2d6:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    a2da:	4607      	mov	r7, r0
    a2dc:	460c      	mov	r4, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
    a2de:	d003      	beq.n	a2e8 <notify_cb+0x18>
		return BT_GATT_ITER_CONTINUE;
    a2e0:	2001      	movs	r0, #1
}
    a2e2:	b002      	add	sp, #8
    a2e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ccc = attr->user_data;
    a2e8:	68c6      	ldr	r6, [r0, #12]
	if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) && ccc == &sc_ccc) {
    a2ea:	4b2e      	ldr	r3, [pc, #184]	; (a3a4 <notify_cb+0xd4>)
    a2ec:	429e      	cmp	r6, r3
    a2ee:	d02f      	beq.n	a350 <notify_cb+0x80>
		if (cfg->value != data->type) {
    a2f0:	88a2      	ldrh	r2, [r4, #4]
    a2f2:	8933      	ldrh	r3, [r6, #8]
    a2f4:	429a      	cmp	r2, r3
    a2f6:	d1f3      	bne.n	a2e0 <notify_cb+0x10>
		conn = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
    a2f8:	4631      	mov	r1, r6
    a2fa:	f811 0b01 	ldrb.w	r0, [r1], #1
    a2fe:	f7fe f83d 	bl	837c <bt_conn_lookup_addr_le>
		if (!conn) {
    a302:	4605      	mov	r5, r0
    a304:	2800      	cmp	r0, #0
    a306:	d0eb      	beq.n	a2e0 <notify_cb+0x10>
		if (conn->state != BT_CONN_CONNECTED) {
    a308:	7b43      	ldrb	r3, [r0, #13]
    a30a:	2b06      	cmp	r3, #6
    a30c:	d11d      	bne.n	a34a <notify_cb+0x7a>
		if (ccc->cfg_match && !ccc->cfg_match(conn, attr)) {
    a30e:	6973      	ldr	r3, [r6, #20]
    a310:	b9b3      	cbnz	r3, a340 <notify_cb+0x70>
		if (data->type == BT_GATT_CCC_INDICATE) {
    a312:	8a39      	ldrh	r1, [r7, #16]
    a314:	88a3      	ldrh	r3, [r4, #4]
    a316:	68a2      	ldr	r2, [r4, #8]
    a318:	3901      	subs	r1, #1
    a31a:	2b02      	cmp	r3, #2
    a31c:	b289      	uxth	r1, r1
			err = gatt_indicate(conn, attr->handle - 1,
    a31e:	4628      	mov	r0, r5
		if (data->type == BT_GATT_CCC_INDICATE) {
    a320:	d10b      	bne.n	a33a <notify_cb+0x6a>
			err = gatt_indicate(conn, attr->handle - 1,
    a322:	f7ff fdaf 	bl	9e84 <gatt_indicate>
			err = gatt_notify(conn, attr->handle - 1,
    a326:	4606      	mov	r6, r0
		bt_conn_unref(conn);
    a328:	4628      	mov	r0, r5
    a32a:	f011 f948 	bl	1b5be <bt_conn_unref>
		if (err < 0) {
    a32e:	2e00      	cmp	r6, #0
    a330:	f04f 0000 	mov.w	r0, #0
    a334:	dbd5      	blt.n	a2e2 <notify_cb+0x12>
		data->err = 0;
    a336:	6020      	str	r0, [r4, #0]
    a338:	e7d2      	b.n	a2e0 <notify_cb+0x10>
			err = gatt_notify(conn, attr->handle - 1,
    a33a:	f7ff fd25 	bl	9d88 <gatt_notify>
    a33e:	e7f2      	b.n	a326 <notify_cb+0x56>
		if (ccc->cfg_match && !ccc->cfg_match(conn, attr)) {
    a340:	4639      	mov	r1, r7
    a342:	4798      	blx	r3
    a344:	2800      	cmp	r0, #0
    a346:	d1e4      	bne.n	a312 <notify_cb+0x42>
			bt_conn_unref(conn);
    a348:	4628      	mov	r0, r5
			bt_conn_unref(conn);
    a34a:	f011 f938 	bl	1b5be <bt_conn_unref>
			continue;
    a34e:	e7c7      	b.n	a2e0 <notify_cb+0x10>
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    a350:	f04f 0800 	mov.w	r8, #0
    a354:	4d14      	ldr	r5, [pc, #80]	; (a3a8 <notify_cb+0xd8>)
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
    a356:	46c2      	mov	sl, r8
    a358:	f105 0901 	add.w	r9, r5, #1
    a35c:	2207      	movs	r2, #7
    a35e:	4669      	mov	r1, sp
    a360:	4648      	mov	r0, r9
    a362:	f8cd a000 	str.w	sl, [sp]
    a366:	f8cd a003 	str.w	sl, [sp, #3]
    a36a:	f010 fe36 	bl	1afda <memcmp>
    a36e:	b160      	cbz	r0, a38a <notify_cb+0xba>
			conn = bt_conn_lookup_state_le(&cfg->peer,
    a370:	2106      	movs	r1, #6
    a372:	4648      	mov	r0, r9
    a374:	f7fe f820 	bl	83b8 <bt_conn_lookup_state_le>
			if (!conn) {
    a378:	b970      	cbnz	r0, a398 <notify_cb+0xc8>
				sc = (struct sc_data *)data->ind_params->data;
    a37a:	68a3      	ldr	r3, [r4, #8]
				sc_save(cfg->id, &cfg->peer,
    a37c:	7828      	ldrb	r0, [r5, #0]
				sc = (struct sc_data *)data->ind_params->data;
    a37e:	68da      	ldr	r2, [r3, #12]
				sc_save(cfg->id, &cfg->peer,
    a380:	4649      	mov	r1, r9
    a382:	8853      	ldrh	r3, [r2, #2]
    a384:	8812      	ldrh	r2, [r2, #0]
    a386:	f7ff ff5b 	bl	a240 <sc_save>
				continue;
    a38a:	350c      	adds	r5, #12
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    a38c:	f1b8 0f00 	cmp.w	r8, #0
    a390:	d1ae      	bne.n	a2f0 <notify_cb+0x20>
    a392:	f04f 0801 	mov.w	r8, #1
    a396:	e7df      	b.n	a358 <notify_cb+0x88>
			bt_conn_unref(conn);
    a398:	f011 f911 	bl	1b5be <bt_conn_unref>
    a39c:	e7f5      	b.n	a38a <notify_cb+0xba>
    a39e:	bf00      	nop
    a3a0:	0000a031 	.word	0x0000a031
    a3a4:	200056c8 	.word	0x200056c8
    a3a8:	20001af0 	.word	0x20001af0

0000a3ac <sc_set>:
{
    a3ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    a3b0:	460e      	mov	r6, r1
    a3b2:	b087      	sub	sp, #28
    a3b4:	4690      	mov	r8, r2
    a3b6:	4699      	mov	r9, r3
	if (!name) {
    a3b8:	4605      	mov	r5, r0
    a3ba:	b998      	cbnz	r0, a3e4 <sc_set+0x38>
		BT_ERR("Insufficient number of arguments");
    a3bc:	2301      	movs	r3, #1
    a3be:	f04f 0100 	mov.w	r1, #0
    a3c2:	f363 0107 	bfi	r1, r3, #0, #8
    a3c6:	4a3d      	ldr	r2, [pc, #244]	; (a4bc <sc_set+0x110>)
    a3c8:	4b3d      	ldr	r3, [pc, #244]	; (a4c0 <sc_set+0x114>)
    a3ca:	483e      	ldr	r0, [pc, #248]	; (a4c4 <sc_set+0x118>)
    a3cc:	1a9b      	subs	r3, r3, r2
    a3ce:	08db      	lsrs	r3, r3, #3
    a3d0:	f363 118f 	bfi	r1, r3, #6, #10
    a3d4:	f010 f91d 	bl	1a612 <log_0>
		return -EINVAL;
    a3d8:	f06f 0415 	mvn.w	r4, #21
}
    a3dc:	4620      	mov	r0, r4
    a3de:	b007      	add	sp, #28
    a3e0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	err = bt_settings_decode_key(name, &addr);
    a3e4:	a902      	add	r1, sp, #8
    a3e6:	f010 fed1 	bl	1b18c <bt_settings_decode_key>
	if (err) {
    a3ea:	4604      	mov	r4, r0
    a3ec:	b198      	cbz	r0, a416 <sc_set+0x6a>
		BT_ERR("Unable to decode address %s", log_strdup(name));
    a3ee:	2301      	movs	r3, #1
    a3f0:	f04f 0400 	mov.w	r4, #0
    a3f4:	4a31      	ldr	r2, [pc, #196]	; (a4bc <sc_set+0x110>)
    a3f6:	f363 0407 	bfi	r4, r3, #0, #8
    a3fa:	4b31      	ldr	r3, [pc, #196]	; (a4c0 <sc_set+0x114>)
    a3fc:	1a9b      	subs	r3, r3, r2
    a3fe:	08db      	lsrs	r3, r3, #3
    a400:	4628      	mov	r0, r5
    a402:	f363 148f 	bfi	r4, r3, #6, #10
    a406:	f7f8 fd3d 	bl	2e84 <log_strdup>
    a40a:	4622      	mov	r2, r4
    a40c:	4601      	mov	r1, r0
    a40e:	482e      	ldr	r0, [pc, #184]	; (a4c8 <sc_set+0x11c>)
    a410:	f010 f90c 	bl	1a62c <log_1>
    a414:	e7e0      	b.n	a3d8 <sc_set+0x2c>
	settings_name_next(name, &next);
    a416:	a901      	add	r1, sp, #4
    a418:	4628      	mov	r0, r5
    a41a:	f010 fb4c 	bl	1aab6 <settings_name_next>
	if (!next) {
    a41e:	9801      	ldr	r0, [sp, #4]
    a420:	b330      	cbz	r0, a470 <sc_set+0xc4>
		id = strtol(next, NULL, 10);
    a422:	220a      	movs	r2, #10
    a424:	4621      	mov	r1, r4
    a426:	f010 fd23 	bl	1ae70 <strtol>
    a42a:	b2c7      	uxtb	r7, r0
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    a42c:	a902      	add	r1, sp, #8
    a42e:	4638      	mov	r0, r7
    a430:	f7ff fee4 	bl	a1fc <find_sc_cfg.part.11>
	if (!cfg && len_rd) {
    a434:	4605      	mov	r5, r0
    a436:	2800      	cmp	r0, #0
    a438:	d139      	bne.n	a4ae <sc_set+0x102>
    a43a:	2e00      	cmp	r6, #0
    a43c:	d0ce      	beq.n	a3dc <sc_set+0x30>
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
    a43e:	a904      	add	r1, sp, #16
    a440:	9004      	str	r0, [sp, #16]
    a442:	f8cd 0013 	str.w	r0, [sp, #19]
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    a446:	f7ff fed9 	bl	a1fc <find_sc_cfg.part.11>
		if (!cfg) {
    a44a:	4605      	mov	r5, r0
    a44c:	b990      	cbnz	r0, a474 <sc_set+0xc8>
			BT_ERR("Unable to restore SC: no cfg left");
    a44e:	2301      	movs	r3, #1
    a450:	f04f 0100 	mov.w	r1, #0
    a454:	f363 0107 	bfi	r1, r3, #0, #8
    a458:	4a18      	ldr	r2, [pc, #96]	; (a4bc <sc_set+0x110>)
    a45a:	4b19      	ldr	r3, [pc, #100]	; (a4c0 <sc_set+0x114>)
    a45c:	481b      	ldr	r0, [pc, #108]	; (a4cc <sc_set+0x120>)
    a45e:	1a9b      	subs	r3, r3, r2
    a460:	08db      	lsrs	r3, r3, #3
    a462:	f363 118f 	bfi	r1, r3, #6, #10
    a466:	f010 f8d4 	bl	1a612 <log_0>
			return -ENOMEM;
    a46a:	f06f 040b 	mvn.w	r4, #11
    a46e:	e7b5      	b.n	a3dc <sc_set+0x30>
		id = BT_ID_DEFAULT;
    a470:	4627      	mov	r7, r4
    a472:	e7db      	b.n	a42c <sc_set+0x80>
		cfg->id = id;
    a474:	f800 7b01 	strb.w	r7, [r0], #1
		bt_addr_le_copy(&cfg->peer, &addr);
    a478:	a902      	add	r1, sp, #8
    a47a:	f011 fd4f 	bl	1bf1c <bt_addr_le_copy>
		len = read_cb(cb_arg, &cfg->data, sizeof(cfg->data));
    a47e:	f105 0108 	add.w	r1, r5, #8
    a482:	2204      	movs	r2, #4
    a484:	4648      	mov	r0, r9
    a486:	47c0      	blx	r8
		if (len < 0) {
    a488:	1e05      	subs	r5, r0, #0
    a48a:	daa7      	bge.n	a3dc <sc_set+0x30>
			BT_ERR("Failed to decode value (err %d)", len);
    a48c:	2301      	movs	r3, #1
    a48e:	f04f 0200 	mov.w	r2, #0
    a492:	f363 0207 	bfi	r2, r3, #0, #8
    a496:	4909      	ldr	r1, [pc, #36]	; (a4bc <sc_set+0x110>)
    a498:	4b09      	ldr	r3, [pc, #36]	; (a4c0 <sc_set+0x114>)
    a49a:	480d      	ldr	r0, [pc, #52]	; (a4d0 <sc_set+0x124>)
    a49c:	1a5b      	subs	r3, r3, r1
    a49e:	08db      	lsrs	r3, r3, #3
    a4a0:	f363 128f 	bfi	r2, r3, #6, #10
    a4a4:	4629      	mov	r1, r5
    a4a6:	f010 f8c1 	bl	1a62c <log_1>
			return len;
    a4aa:	462c      	mov	r4, r5
    a4ac:	e796      	b.n	a3dc <sc_set+0x30>
	if (len_rd) {
    a4ae:	2e00      	cmp	r6, #0
    a4b0:	d1e5      	bne.n	a47e <sc_set+0xd2>
		memset(cfg, 0, sizeof(*cfg));
    a4b2:	220c      	movs	r2, #12
    a4b4:	4631      	mov	r1, r6
    a4b6:	f010 fdca 	bl	1b04e <memset>
		BT_DBG("Removed SC for %s", bt_addr_le_str(&addr));
    a4ba:	e78f      	b.n	a3dc <sc_set+0x30>
    a4bc:	0001ed28 	.word	0x0001ed28
    a4c0:	0001ede0 	.word	0x0001ede0
    a4c4:	00020222 	.word	0x00020222
    a4c8:	000213e6 	.word	0x000213e6
    a4cc:	00021402 	.word	0x00021402
    a4d0:	000212bd 	.word	0x000212bd

0000a4d4 <find_cf_cfg.part.10>:
static struct gatt_cf_cfg *find_cf_cfg(struct bt_conn *conn)
    a4d4:	b537      	push	{r0, r1, r2, r4, r5, lr}
		if (!conn) {
    a4d6:	4605      	mov	r5, r0
    a4d8:	4c13      	ldr	r4, [pc, #76]	; (a528 <find_cf_cfg.part.10+0x54>)
    a4da:	b130      	cbz	r0, a4ea <find_cf_cfg.part.10+0x16>
		} else if (!bt_conn_addr_le_cmp(conn, &cf_cfg[i].peer)) {
    a4dc:	1c61      	adds	r1, r4, #1
    a4de:	f011 f856 	bl	1b58e <bt_conn_addr_le_cmp>
    a4e2:	b9c0      	cbnz	r0, a516 <find_cf_cfg.part.10+0x42>
			return &cf_cfg[i];
    a4e4:	4420      	add	r0, r4
}
    a4e6:	b003      	add	sp, #12
    a4e8:	bd30      	pop	{r4, r5, pc}
			if (!bt_addr_le_cmp(&cf_cfg[i].peer, BT_ADDR_LE_ANY)) {
    a4ea:	9000      	str	r0, [sp, #0]
    a4ec:	2207      	movs	r2, #7
    a4ee:	f8cd 0003 	str.w	r0, [sp, #3]
    a4f2:	4669      	mov	r1, sp
    a4f4:	1c60      	adds	r0, r4, #1
    a4f6:	f010 fd70 	bl	1afda <memcmp>
    a4fa:	2800      	cmp	r0, #0
    a4fc:	d0f2      	beq.n	a4e4 <find_cf_cfg.part.10+0x10>
    a4fe:	2207      	movs	r2, #7
    a500:	4669      	mov	r1, sp
    a502:	f104 0011 	add.w	r0, r4, #17
    a506:	9500      	str	r5, [sp, #0]
    a508:	f8cd 5003 	str.w	r5, [sp, #3]
    a50c:	f010 fd65 	bl	1afda <memcmp>
    a510:	e006      	b.n	a520 <find_cf_cfg.part.10+0x4c>
	return NULL;
    a512:	2000      	movs	r0, #0
    a514:	e7e7      	b.n	a4e6 <find_cf_cfg.part.10+0x12>
		} else if (!bt_conn_addr_le_cmp(conn, &cf_cfg[i].peer)) {
    a516:	f104 0111 	add.w	r1, r4, #17
    a51a:	4628      	mov	r0, r5
    a51c:	f011 f837 	bl	1b58e <bt_conn_addr_le_cmp>
			if (!bt_addr_le_cmp(&cf_cfg[i].peer, BT_ADDR_LE_ANY)) {
    a520:	2800      	cmp	r0, #0
    a522:	d1f6      	bne.n	a512 <find_cf_cfg.part.10+0x3e>
		} else if (!bt_conn_addr_le_cmp(conn, &cf_cfg[i].peer)) {
    a524:	2010      	movs	r0, #16
    a526:	e7dd      	b.n	a4e4 <find_cf_cfg.part.10+0x10>
    a528:	20000420 	.word	0x20000420

0000a52c <cf_write>:
{
    a52c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a530:	4690      	mov	r8, r2
    a532:	f8bd 2018 	ldrh.w	r2, [sp, #24]
	if (offset > sizeof(cfg->data)) {
    a536:	2a01      	cmp	r2, #1
{
    a538:	4606      	mov	r6, r0
    a53a:	461f      	mov	r7, r3
	if (offset > sizeof(cfg->data)) {
    a53c:	d844      	bhi.n	a5c8 <cf_write+0x9c>
	if (offset + len > sizeof(cfg->data)) {
    a53e:	441a      	add	r2, r3
    a540:	2a01      	cmp	r2, #1
    a542:	461d      	mov	r5, r3
    a544:	dc43      	bgt.n	a5ce <cf_write+0xa2>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    a546:	f7ff ffc5 	bl	a4d4 <find_cf_cfg.part.10>
	if (!cfg) {
    a54a:	4604      	mov	r4, r0
    a54c:	b9b0      	cbnz	r0, a57c <cf_write+0x50>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    a54e:	f7ff ffc1 	bl	a4d4 <find_cf_cfg.part.10>
	if (!cfg) {
    a552:	4604      	mov	r4, r0
    a554:	b990      	cbnz	r0, a57c <cf_write+0x50>
		BT_WARN("No space to store Client Supported Features");
    a556:	2302      	movs	r3, #2
    a558:	f04f 0100 	mov.w	r1, #0
    a55c:	f363 0107 	bfi	r1, r3, #0, #8
    a560:	4a1c      	ldr	r2, [pc, #112]	; (a5d4 <cf_write+0xa8>)
    a562:	4b1d      	ldr	r3, [pc, #116]	; (a5d8 <cf_write+0xac>)
    a564:	481d      	ldr	r0, [pc, #116]	; (a5dc <cf_write+0xb0>)
    a566:	1a9b      	subs	r3, r3, r2
    a568:	08db      	lsrs	r3, r3, #3
    a56a:	f363 118f 	bfi	r1, r3, #6, #10
    a56e:	f010 f850 	bl	1a612 <log_0>
		return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
    a572:	f06f 0510 	mvn.w	r5, #16
}
    a576:	4628      	mov	r0, r5
    a578:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (i = 0U; i < len && i < last_byte; i++) {
    a57c:	2300      	movs	r3, #0
    a57e:	429f      	cmp	r7, r3
    a580:	d915      	bls.n	a5ae <cf_write+0x82>
    a582:	b13b      	cbz	r3, a594 <cf_write+0x68>
		cfg->data[i] |= value[i] & ((1 << last_bit) - 1);
    a584:	f898 3000 	ldrb.w	r3, [r8]
    a588:	7a22      	ldrb	r2, [r4, #8]
    a58a:	f003 0301 	and.w	r3, r3, #1
    a58e:	4313      	orrs	r3, r2
    a590:	7223      	strb	r3, [r4, #8]
		BT_DBG("byte %u: data 0x%02x value 0x%02x", i, cfg->data[i],
    a592:	e00e      	b.n	a5b2 <cf_write+0x86>
    a594:	7a21      	ldrb	r1, [r4, #8]
		u8_t chg_bits = value[i] ^ cfg->data[i];
    a596:	f898 2000 	ldrb.w	r2, [r8]
    a59a:	404a      	eors	r2, r1
			if ((BIT(bit) & chg_bits) &&
    a59c:	07d0      	lsls	r0, r2, #31
	for (i = 0U; i < len && i < last_byte; i++) {
    a59e:	f04f 0301 	mov.w	r3, #1
			if ((BIT(bit) & chg_bits) &&
    a5a2:	d5ec      	bpl.n	a57e <cf_write+0x52>
    a5a4:	07ca      	lsls	r2, r1, #31
    a5a6:	d5ea      	bpl.n	a57e <cf_write+0x52>
		return BT_GATT_ERR(BT_ATT_ERR_VALUE_NOT_ALLOWED);
    a5a8:	f06f 0512 	mvn.w	r5, #18
    a5ac:	e7e3      	b.n	a576 <cf_write+0x4a>
	for (i = 0U; i < len && i < last_byte; i++) {
    a5ae:	2f00      	cmp	r7, #0
    a5b0:	d1e8      	bne.n	a584 <cf_write+0x58>
	bt_addr_le_copy(&cfg->peer, &conn->le.dst);
    a5b2:	f106 0170 	add.w	r1, r6, #112	; 0x70
    a5b6:	1c60      	adds	r0, r4, #1
    a5b8:	f011 fcb0 	bl	1bf1c <bt_addr_le_copy>
	atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
    a5bc:	2100      	movs	r1, #0
    a5be:	f104 000c 	add.w	r0, r4, #12
    a5c2:	f011 fdb8 	bl	1c136 <atomic_set_bit>
	return len;
    a5c6:	e7d6      	b.n	a576 <cf_write+0x4a>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
    a5c8:	f06f 0506 	mvn.w	r5, #6
    a5cc:	e7d3      	b.n	a576 <cf_write+0x4a>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
    a5ce:	f06f 050c 	mvn.w	r5, #12
    a5d2:	e7d0      	b.n	a576 <cf_write+0x4a>
    a5d4:	0001ed28 	.word	0x0001ed28
    a5d8:	0001ede0 	.word	0x0001ede0
    a5dc:	0002125f 	.word	0x0002125f

0000a5e0 <sc_indicate_rsp>:
{
    a5e0:	b510      	push	{r4, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    a5e2:	f06f 0102 	mvn.w	r1, #2
    a5e6:	4604      	mov	r4, r0
    a5e8:	480d      	ldr	r0, [pc, #52]	; (a620 <sc_indicate_rsp+0x40>)
    a5ea:	f011 fd26 	bl	1c03a <atomic_and>
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
    a5ee:	2100      	movs	r1, #0
    a5f0:	480b      	ldr	r0, [pc, #44]	; (a620 <sc_indicate_rsp+0x40>)
    a5f2:	f011 fd19 	bl	1c028 <atomic_test_bit>
    a5f6:	b120      	cbz	r0, a602 <sc_indicate_rsp+0x22>
    a5f8:	2200      	movs	r2, #0
    a5fa:	490a      	ldr	r1, [pc, #40]	; (a624 <sc_indicate_rsp+0x44>)
    a5fc:	480a      	ldr	r0, [pc, #40]	; (a628 <sc_indicate_rsp+0x48>)
    a5fe:	f00e f8b3 	bl	18768 <k_delayed_work_submit_to_queue>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    a602:	4620      	mov	r0, r4
    a604:	f7ff ff66 	bl	a4d4 <find_cf_cfg.part.10>
	if (cfg && CF_ROBUST_CACHING(cfg)) {
    a608:	b140      	cbz	r0, a61c <sc_indicate_rsp+0x3c>
    a60a:	7a03      	ldrb	r3, [r0, #8]
    a60c:	07db      	lsls	r3, r3, #31
    a60e:	d505      	bpl.n	a61c <sc_indicate_rsp+0x3c>
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
    a610:	2100      	movs	r1, #0
    a612:	300c      	adds	r0, #12
}
    a614:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
    a618:	f011 bd8d 	b.w	1c136 <atomic_set_bit>
}
    a61c:	bd10      	pop	{r4, pc}
    a61e:	bf00      	nop
    a620:	20000498 	.word	0x20000498
    a624:	20000478 	.word	0x20000478
    a628:	20001a60 	.word	0x20001a60

0000a62c <cf_set>:
{
    a62c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    a630:	460f      	mov	r7, r1
    a632:	4615      	mov	r5, r2
    a634:	461e      	mov	r6, r3
	if (!name) {
    a636:	4680      	mov	r8, r0
    a638:	b998      	cbnz	r0, a662 <cf_set+0x36>
		BT_ERR("Insufficient number of arguments");
    a63a:	2301      	movs	r3, #1
    a63c:	f04f 0100 	mov.w	r1, #0
    a640:	f363 0107 	bfi	r1, r3, #0, #8
    a644:	4a2c      	ldr	r2, [pc, #176]	; (a6f8 <cf_set+0xcc>)
    a646:	4b2d      	ldr	r3, [pc, #180]	; (a6fc <cf_set+0xd0>)
    a648:	482d      	ldr	r0, [pc, #180]	; (a700 <cf_set+0xd4>)
    a64a:	1a9b      	subs	r3, r3, r2
    a64c:	08db      	lsrs	r3, r3, #3
    a64e:	f363 118f 	bfi	r1, r3, #6, #10
    a652:	f00f ffde 	bl	1a612 <log_0>
		return -EINVAL;
    a656:	f06f 0415 	mvn.w	r4, #21
}
    a65a:	4620      	mov	r0, r4
    a65c:	b002      	add	sp, #8
    a65e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	err = bt_settings_decode_key(name, &addr);
    a662:	4669      	mov	r1, sp
    a664:	f010 fd92 	bl	1b18c <bt_settings_decode_key>
	if (err) {
    a668:	4604      	mov	r4, r0
    a66a:	b198      	cbz	r0, a694 <cf_set+0x68>
		BT_ERR("Unable to decode address %s", log_strdup(name));
    a66c:	2301      	movs	r3, #1
    a66e:	f04f 0400 	mov.w	r4, #0
    a672:	4a21      	ldr	r2, [pc, #132]	; (a6f8 <cf_set+0xcc>)
    a674:	f363 0407 	bfi	r4, r3, #0, #8
    a678:	4b20      	ldr	r3, [pc, #128]	; (a6fc <cf_set+0xd0>)
    a67a:	1a9b      	subs	r3, r3, r2
    a67c:	08db      	lsrs	r3, r3, #3
    a67e:	4640      	mov	r0, r8
    a680:	f363 148f 	bfi	r4, r3, #6, #10
    a684:	f7f8 fbfe 	bl	2e84 <log_strdup>
    a688:	4622      	mov	r2, r4
    a68a:	4601      	mov	r1, r0
    a68c:	481d      	ldr	r0, [pc, #116]	; (a704 <cf_set+0xd8>)
    a68e:	f00f ffcd 	bl	1a62c <log_1>
    a692:	e7e0      	b.n	a656 <cf_set+0x2a>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    a694:	4668      	mov	r0, sp
    a696:	f7ff fcb1 	bl	9ffc <find_cf_cfg_by_addr.part.14>
	if (!cfg) {
    a69a:	4601      	mov	r1, r0
    a69c:	b980      	cbnz	r0, a6c0 <cf_set+0x94>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    a69e:	f7ff ff19 	bl	a4d4 <find_cf_cfg.part.10>
		if (!cfg) {
    a6a2:	4601      	mov	r1, r0
    a6a4:	b960      	cbnz	r0, a6c0 <cf_set+0x94>
			BT_ERR("Unable to restore CF: no cfg left");
    a6a6:	2301      	movs	r3, #1
    a6a8:	f363 0107 	bfi	r1, r3, #0, #8
    a6ac:	4a12      	ldr	r2, [pc, #72]	; (a6f8 <cf_set+0xcc>)
    a6ae:	4b13      	ldr	r3, [pc, #76]	; (a6fc <cf_set+0xd0>)
    a6b0:	4815      	ldr	r0, [pc, #84]	; (a708 <cf_set+0xdc>)
    a6b2:	1a9b      	subs	r3, r3, r2
    a6b4:	08db      	lsrs	r3, r3, #3
    a6b6:	f363 118f 	bfi	r1, r3, #6, #10
    a6ba:	f00f ffaa 	bl	1a612 <log_0>
			return 0;
    a6be:	e7cc      	b.n	a65a <cf_set+0x2e>
	if (len_rd) {
    a6c0:	b1b7      	cbz	r7, a6f0 <cf_set+0xc4>
		len = read_cb(cb_arg, cfg->data, sizeof(cfg->data));
    a6c2:	2201      	movs	r2, #1
    a6c4:	3108      	adds	r1, #8
    a6c6:	4630      	mov	r0, r6
    a6c8:	47a8      	blx	r5
		if (len < 0) {
    a6ca:	1e05      	subs	r5, r0, #0
    a6cc:	dac5      	bge.n	a65a <cf_set+0x2e>
			BT_ERR("Failed to decode value (err %d)", len);
    a6ce:	2301      	movs	r3, #1
    a6d0:	f04f 0200 	mov.w	r2, #0
    a6d4:	f363 0207 	bfi	r2, r3, #0, #8
    a6d8:	4907      	ldr	r1, [pc, #28]	; (a6f8 <cf_set+0xcc>)
    a6da:	4b08      	ldr	r3, [pc, #32]	; (a6fc <cf_set+0xd0>)
    a6dc:	480b      	ldr	r0, [pc, #44]	; (a70c <cf_set+0xe0>)
    a6de:	1a5b      	subs	r3, r3, r1
    a6e0:	08db      	lsrs	r3, r3, #3
    a6e2:	f363 128f 	bfi	r2, r3, #6, #10
    a6e6:	4629      	mov	r1, r5
    a6e8:	f00f ffa0 	bl	1a62c <log_1>
			return len;
    a6ec:	462c      	mov	r4, r5
    a6ee:	e7b4      	b.n	a65a <cf_set+0x2e>
		clear_cf_cfg(cfg);
    a6f0:	4608      	mov	r0, r1
    a6f2:	f011 fcd7 	bl	1c0a4 <clear_cf_cfg>
    a6f6:	e7b0      	b.n	a65a <cf_set+0x2e>
    a6f8:	0001ed28 	.word	0x0001ed28
    a6fc:	0001ede0 	.word	0x0001ede0
    a700:	00020222 	.word	0x00020222
    a704:	000213e6 	.word	0x000213e6
    a708:	0002123d 	.word	0x0002123d
    a70c:	000212bd 	.word	0x000212bd

0000a710 <read_ppcp>:
{
    a710:	b513      	push	{r0, r1, r4, lr}
    a712:	f8bd 1010 	ldrh.w	r1, [sp, #16]
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_SLAVE_LATENCY);
    a716:	4c0b      	ldr	r4, [pc, #44]	; (a744 <read_ppcp+0x34>)
{
    a718:	4610      	mov	r0, r2
	if (offset > value_len) {
    a71a:	2908      	cmp	r1, #8
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_SLAVE_LATENCY);
    a71c:	f44f 1228 	mov.w	r2, #2752512	; 0x2a0000
    a720:	e9cd 4200 	strd	r4, r2, [sp]
	if (offset > value_len) {
    a724:	d80b      	bhi.n	a73e <read_ppcp+0x2e>
	len = MIN(buf_len, value_len - offset);
    a726:	f1c1 0408 	rsb	r4, r1, #8
    a72a:	429c      	cmp	r4, r3
    a72c:	bfa8      	it	ge
    a72e:	461c      	movge	r4, r3
	memcpy(buf, (u8_t *)value + offset, len);
    a730:	4622      	mov	r2, r4
    a732:	4469      	add	r1, sp
    a734:	f010 fc61 	bl	1affa <memcpy>
}
    a738:	4620      	mov	r0, r4
    a73a:	b002      	add	sp, #8
    a73c:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
    a73e:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &ppcp,
    a742:	e7f9      	b.n	a738 <read_ppcp+0x28>
    a744:	00280018 	.word	0x00280018

0000a748 <bt_gatt_init>:
{
    a748:	b510      	push	{r4, lr}
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    a74a:	4b1c      	ldr	r3, [pc, #112]	; (a7bc <bt_gatt_init+0x74>)
    a74c:	f3bf 8f5b 	dmb	ish
    a750:	2201      	movs	r2, #1
    a752:	e853 1f00 	ldrex	r1, [r3]
    a756:	2900      	cmp	r1, #0
    a758:	d103      	bne.n	a762 <bt_gatt_init+0x1a>
    a75a:	e843 2000 	strex	r0, r2, [r3]
    a75e:	2800      	cmp	r0, #0
    a760:	d1f7      	bne.n	a752 <bt_gatt_init+0xa>
    a762:	f3bf 8f5b 	dmb	ish
	if (!atomic_cas(&init, 0, 1)) {
    a766:	d122      	bne.n	a7ae <bt_gatt_init+0x66>
    a768:	4a15      	ldr	r2, [pc, #84]	; (a7c0 <bt_gatt_init+0x78>)
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
    a76a:	4916      	ldr	r1, [pc, #88]	; (a7c4 <bt_gatt_init+0x7c>)
    a76c:	8813      	ldrh	r3, [r2, #0]
    a76e:	4c16      	ldr	r4, [pc, #88]	; (a7c8 <bt_gatt_init+0x80>)
	if (!atomic_cas(&init, 0, 1)) {
    a770:	2000      	movs	r0, #0
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
    a772:	42a1      	cmp	r1, r4
    a774:	d31c      	bcc.n	a7b0 <bt_gatt_init+0x68>
    a776:	b100      	cbz	r0, a77a <bt_gatt_init+0x32>
    a778:	8013      	strh	r3, [r2, #0]
	k_delayed_work_init(&db_hash_work, db_hash_process);
    a77a:	4914      	ldr	r1, [pc, #80]	; (a7cc <bt_gatt_init+0x84>)
    a77c:	4814      	ldr	r0, [pc, #80]	; (a7d0 <bt_gatt_init+0x88>)
    a77e:	f013 ffe3 	bl	1e748 <k_delayed_work_init>
    a782:	220a      	movs	r2, #10
    a784:	4912      	ldr	r1, [pc, #72]	; (a7d0 <bt_gatt_init+0x88>)
    a786:	4813      	ldr	r0, [pc, #76]	; (a7d4 <bt_gatt_init+0x8c>)
    a788:	f00d ffee 	bl	18768 <k_delayed_work_submit_to_queue>
		k_delayed_work_init(&gatt_sc.work, sc_process);
    a78c:	4912      	ldr	r1, [pc, #72]	; (a7d8 <bt_gatt_init+0x90>)
    a78e:	4813      	ldr	r0, [pc, #76]	; (a7dc <bt_gatt_init+0x94>)
    a790:	f013 ffda 	bl	1e748 <k_delayed_work_init>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    a794:	f3bf 8f5b 	dmb	ish
    a798:	4b11      	ldr	r3, [pc, #68]	; (a7e0 <bt_gatt_init+0x98>)
    a79a:	e853 2f00 	ldrex	r2, [r3]
    a79e:	f042 0202 	orr.w	r2, r2, #2
    a7a2:	e843 2100 	strex	r1, r2, [r3]
    a7a6:	2900      	cmp	r1, #0
    a7a8:	d1f7      	bne.n	a79a <bt_gatt_init+0x52>
    a7aa:	f3bf 8f5b 	dmb	ish
}
    a7ae:	bd10      	pop	{r4, pc}
		last_static_handle += svc->attr_count;
    a7b0:	6848      	ldr	r0, [r1, #4]
    a7b2:	4403      	add	r3, r0
    a7b4:	b29b      	uxth	r3, r3
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
    a7b6:	3108      	adds	r1, #8
    a7b8:	2001      	movs	r0, #1
    a7ba:	e7da      	b.n	a772 <bt_gatt_init+0x2a>
    a7bc:	2000049c 	.word	0x2000049c
    a7c0:	20001aee 	.word	0x20001aee
    a7c4:	0001ec9c 	.word	0x0001ec9c
    a7c8:	0001ecc4 	.word	0x0001ecc4
    a7cc:	0001c425 	.word	0x0001c425
    a7d0:	20000440 	.word	0x20000440
    a7d4:	20001a60 	.word	0x20001a60
    a7d8:	0000ac61 	.word	0x0000ac61
    a7dc:	20000478 	.word	0x20000478
    a7e0:	20000498 	.word	0x20000498

0000a7e4 <bt_gatt_attr_value_handle>:
{
    a7e4:	b508      	push	{r3, lr}
	if ((attr != NULL)
    a7e6:	b188      	cbz	r0, a80c <bt_gatt_attr_value_handle+0x28>
	    && (attr->read == bt_gatt_attr_read_chrc)) {
    a7e8:	6841      	ldr	r1, [r0, #4]
    a7ea:	4b09      	ldr	r3, [pc, #36]	; (a810 <bt_gatt_attr_value_handle+0x2c>)
    a7ec:	4299      	cmp	r1, r3
    a7ee:	d10d      	bne.n	a80c <bt_gatt_attr_value_handle+0x28>
		handle = chrc->value_handle;
    a7f0:	68c3      	ldr	r3, [r0, #12]
    a7f2:	889b      	ldrh	r3, [r3, #4]
		if (handle == 0) {
    a7f4:	b91b      	cbnz	r3, a7fe <bt_gatt_attr_value_handle+0x1a>
			handle = (attr->handle ? : find_static_attr(attr)) + 1U;
    a7f6:	8a03      	ldrh	r3, [r0, #16]
    a7f8:	b11b      	cbz	r3, a802 <bt_gatt_attr_value_handle+0x1e>
    a7fa:	3301      	adds	r3, #1
    a7fc:	b29b      	uxth	r3, r3
}
    a7fe:	4618      	mov	r0, r3
    a800:	bd08      	pop	{r3, pc}
			handle = (attr->handle ? : find_static_attr(attr)) + 1U;
    a802:	f7ff f99d 	bl	9b40 <find_static_attr>
    a806:	3001      	adds	r0, #1
    a808:	b283      	uxth	r3, r0
	return handle;
    a80a:	e7f8      	b.n	a7fe <bt_gatt_attr_value_handle+0x1a>
	u16_t handle = 0;
    a80c:	2300      	movs	r3, #0
    a80e:	e7f6      	b.n	a7fe <bt_gatt_attr_value_handle+0x1a>
    a810:	0001c3ad 	.word	0x0001c3ad

0000a814 <bt_gatt_foreach_attr_type>:
{
    a814:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a818:	b089      	sub	sp, #36	; 0x24
    a81a:	4699      	mov	r9, r3
    a81c:	f8bd 5048 	ldrh.w	r5, [sp, #72]	; 0x48
    a820:	9101      	str	r1, [sp, #4]
		num_matches = UINT16_MAX;
    a822:	f64f 73ff 	movw	r3, #65535	; 0xffff
    a826:	2d00      	cmp	r5, #0
    a828:	bf08      	it	eq
    a82a:	461d      	moveq	r5, r3
	if (start_handle <= last_static_handle) {
    a82c:	4b25      	ldr	r3, [pc, #148]	; (a8c4 <bt_gatt_foreach_attr_type+0xb0>)
    a82e:	881b      	ldrh	r3, [r3, #0]
    a830:	4283      	cmp	r3, r0
{
    a832:	4607      	mov	r7, r0
    a834:	4690      	mov	r8, r2
	if (start_handle <= last_static_handle) {
    a836:	d33c      	bcc.n	a8b2 <bt_gatt_foreach_attr_type+0x9e>
    a838:	f8df a090 	ldr.w	sl, [pc, #144]	; a8cc <bt_gatt_foreach_attr_type+0xb8>
		u16_t handle = 1;
    a83c:	2401      	movs	r4, #1
				memcpy(&attr, &static_svc->attrs[i],
    a83e:	f04f 0b14 	mov.w	fp, #20
		Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    a842:	4b21      	ldr	r3, [pc, #132]	; (a8c8 <bt_gatt_foreach_attr_type+0xb4>)
    a844:	f1aa 0208 	sub.w	r2, sl, #8
    a848:	429a      	cmp	r2, r3
    a84a:	d232      	bcs.n	a8b2 <bt_gatt_foreach_attr_type+0x9e>
			if (handle + static_svc->attr_count < start_handle) {
    a84c:	f85a 2c04 	ldr.w	r2, [sl, #-4]
    a850:	4422      	add	r2, r4
    a852:	42ba      	cmp	r2, r7
    a854:	d234      	bcs.n	a8c0 <bt_gatt_foreach_attr_type+0xac>
				handle += static_svc->attr_count;
    a856:	b294      	uxth	r4, r2
				continue;
    a858:	f10a 0a08 	add.w	sl, sl, #8
    a85c:	e7f1      	b.n	a842 <bt_gatt_foreach_attr_type+0x2e>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
    a85e:	9903      	ldr	r1, [sp, #12]
    a860:	4640      	mov	r0, r8
    a862:	f010 fcb7 	bl	1b1d4 <bt_uuid_cmp>
    a866:	b1c0      	cbz	r0, a89a <bt_gatt_foreach_attr_type+0x86>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
    a868:	3401      	adds	r4, #1
    a86a:	3601      	adds	r6, #1
    a86c:	b2a4      	uxth	r4, r4
    a86e:	f85a 2c04 	ldr.w	r2, [sl, #-4]
    a872:	42b2      	cmp	r2, r6
    a874:	d9f0      	bls.n	a858 <bt_gatt_foreach_attr_type+0x44>
				memcpy(&attr, &static_svc->attrs[i],
    a876:	f85a 1c08 	ldr.w	r1, [sl, #-8]
    a87a:	2214      	movs	r2, #20
    a87c:	fb0b 1106 	mla	r1, fp, r6, r1
    a880:	a803      	add	r0, sp, #12
    a882:	f010 fbba 	bl	1affa <memcpy>
	if (attr->handle > end_handle) {
    a886:	9b01      	ldr	r3, [sp, #4]
				attr.handle = handle;
    a888:	f8ad 401c 	strh.w	r4, [sp, #28]
	if (attr->handle > end_handle) {
    a88c:	429c      	cmp	r4, r3
    a88e:	d810      	bhi.n	a8b2 <bt_gatt_foreach_attr_type+0x9e>
	if (attr->handle < start_handle) {
    a890:	42bc      	cmp	r4, r7
    a892:	d3e9      	bcc.n	a868 <bt_gatt_foreach_attr_type+0x54>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
    a894:	f1b8 0f00 	cmp.w	r8, #0
    a898:	d1e1      	bne.n	a85e <bt_gatt_foreach_attr_type+0x4a>
	if (attr_data && attr_data != attr->user_data) {
    a89a:	f1b9 0f00 	cmp.w	r9, #0
    a89e:	d10b      	bne.n	a8b8 <bt_gatt_foreach_attr_type+0xa4>
	*num_matches -= 1;
    a8a0:	3d01      	subs	r5, #1
    a8a2:	b2ad      	uxth	r5, r5
	result = func(attr, user_data);
    a8a4:	9914      	ldr	r1, [sp, #80]	; 0x50
    a8a6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    a8a8:	a803      	add	r0, sp, #12
    a8aa:	4798      	blx	r3
	if (!*num_matches) {
    a8ac:	b10d      	cbz	r5, a8b2 <bt_gatt_foreach_attr_type+0x9e>
				if (gatt_foreach_iter(&attr, start_handle,
    a8ae:	2800      	cmp	r0, #0
    a8b0:	d1da      	bne.n	a868 <bt_gatt_foreach_attr_type+0x54>
}
    a8b2:	b009      	add	sp, #36	; 0x24
    a8b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (attr_data && attr_data != attr->user_data) {
    a8b8:	9a06      	ldr	r2, [sp, #24]
    a8ba:	4591      	cmp	r9, r2
    a8bc:	d1d4      	bne.n	a868 <bt_gatt_foreach_attr_type+0x54>
    a8be:	e7ef      	b.n	a8a0 <bt_gatt_foreach_attr_type+0x8c>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
    a8c0:	2600      	movs	r6, #0
    a8c2:	e7d4      	b.n	a86e <bt_gatt_foreach_attr_type+0x5a>
    a8c4:	20001aee 	.word	0x20001aee
    a8c8:	0001ecc4 	.word	0x0001ecc4
    a8cc:	0001eca4 	.word	0x0001eca4

0000a8d0 <db_hash_gen>:
{
    a8d0:	b530      	push	{r4, r5, lr}
    a8d2:	b0c9      	sub	sp, #292	; 0x124
	u8_t key[16] = {};
    a8d4:	2210      	movs	r2, #16
    a8d6:	2100      	movs	r1, #0
{
    a8d8:	4604      	mov	r4, r0
	u8_t key[16] = {};
    a8da:	4668      	mov	r0, sp
    a8dc:	f010 fbb7 	bl	1b04e <memset>
	if (tc_cmac_setup(&state.state, key, &sched) == TC_CRYPTO_FAIL) {
    a8e0:	aa1c      	add	r2, sp, #112	; 0x70
    a8e2:	4669      	mov	r1, sp
    a8e4:	a804      	add	r0, sp, #16
    a8e6:	f00f fd86 	bl	1a3f6 <tc_cmac_setup>
    a8ea:	b978      	cbnz	r0, a90c <db_hash_gen+0x3c>
		BT_ERR("Unable to setup AES CMAC");
    a8ec:	2301      	movs	r3, #1
    a8ee:	f04f 0100 	mov.w	r1, #0
    a8f2:	f363 0107 	bfi	r1, r3, #0, #8
    a8f6:	4a1a      	ldr	r2, [pc, #104]	; (a960 <db_hash_gen+0x90>)
    a8f8:	4b1a      	ldr	r3, [pc, #104]	; (a964 <db_hash_gen+0x94>)
    a8fa:	481b      	ldr	r0, [pc, #108]	; (a968 <db_hash_gen+0x98>)
    a8fc:	1a9b      	subs	r3, r3, r2
    a8fe:	08db      	lsrs	r3, r3, #3
    a900:	f363 118f 	bfi	r1, r3, #6, #10
		BT_ERR("Unable to calculate hash");
    a904:	f00f fe85 	bl	1a612 <log_0>
}
    a908:	b049      	add	sp, #292	; 0x124
    a90a:	bd30      	pop	{r4, r5, pc}
	bt_gatt_foreach_attr(0x0001, 0xffff, gen_hash_m, &state);
    a90c:	f64f 71ff 	movw	r1, #65535	; 0xffff
    a910:	2001      	movs	r0, #1
    a912:	ab04      	add	r3, sp, #16
    a914:	4a15      	ldr	r2, [pc, #84]	; (a96c <db_hash_gen+0x9c>)
    a916:	f011 fd7a 	bl	1c40e <bt_gatt_foreach_attr>
	if (tc_cmac_final(db_hash, &state.state) == TC_CRYPTO_FAIL) {
    a91a:	a904      	add	r1, sp, #16
    a91c:	4814      	ldr	r0, [pc, #80]	; (a970 <db_hash_gen+0xa0>)
    a91e:	f00f fe00 	bl	1a522 <tc_cmac_final>
    a922:	b960      	cbnz	r0, a93e <db_hash_gen+0x6e>
		BT_ERR("Unable to calculate hash");
    a924:	2301      	movs	r3, #1
    a926:	f04f 0100 	mov.w	r1, #0
    a92a:	f363 0107 	bfi	r1, r3, #0, #8
    a92e:	4a0c      	ldr	r2, [pc, #48]	; (a960 <db_hash_gen+0x90>)
    a930:	4b0c      	ldr	r3, [pc, #48]	; (a964 <db_hash_gen+0x94>)
    a932:	4810      	ldr	r0, [pc, #64]	; (a974 <db_hash_gen+0xa4>)
    a934:	1a9b      	subs	r3, r3, r2
    a936:	08db      	lsrs	r3, r3, #3
    a938:	f363 118f 	bfi	r1, r3, #6, #10
    a93c:	e7e2      	b.n	a904 <db_hash_gen+0x34>
    a93e:	4b0c      	ldr	r3, [pc, #48]	; (a970 <db_hash_gen+0xa0>)
	if (tc_cmac_final(db_hash, &state.state) == TC_CRYPTO_FAIL) {
    a940:	2208      	movs	r2, #8
    a942:	f103 0110 	add.w	r1, r3, #16
static inline void sys_mem_swap(void *buf, size_t length)
{
	size_t i;

	for (i = 0; i < (length/2); i++) {
		u8_t tmp = ((u8_t *)buf)[i];
    a946:	7818      	ldrb	r0, [r3, #0]

		((u8_t *)buf)[i] = ((u8_t *)buf)[length - 1 - i];
    a948:	f811 5d01 	ldrb.w	r5, [r1, #-1]!
    a94c:	f803 5b01 	strb.w	r5, [r3], #1
	for (i = 0; i < (length/2); i++) {
    a950:	3a01      	subs	r2, #1
		((u8_t *)buf)[length - 1 - i] = tmp;
    a952:	7008      	strb	r0, [r1, #0]
	for (i = 0; i < (length/2); i++) {
    a954:	d1f7      	bne.n	a946 <db_hash_gen+0x76>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) && store) {
    a956:	2c00      	cmp	r4, #0
    a958:	d0d6      	beq.n	a908 <db_hash_gen+0x38>
		db_hash_store();
    a95a:	f7ff f915 	bl	9b88 <db_hash_store>
    a95e:	e7d3      	b.n	a908 <db_hash_gen+0x38>
    a960:	0001ed28 	.word	0x0001ed28
    a964:	0001ede0 	.word	0x0001ede0
    a968:	0002128b 	.word	0x0002128b
    a96c:	0001bf7d 	.word	0x0001bf7d
    a970:	20001c55 	.word	0x20001c55
    a974:	000212a4 	.word	0x000212a4

0000a978 <db_hash_commit>:

static int db_hash_commit(void)
{
    a978:	b508      	push	{r3, lr}
 * @return Remaining time (in milliseconds).
 * @req K-DWORK-001
 */
static inline s32_t k_delayed_work_remaining_get(struct k_delayed_work *work)
{
	return k_ticks_to_ms_floor64(z_timeout_remaining(&work->timeout));
    a97a:	4828      	ldr	r0, [pc, #160]	; (aa1c <db_hash_commit+0xa4>)
    a97c:	f00d ffb4 	bl	188e8 <z_timeout_remaining>
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
    a980:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    a984:	fb80 0103 	smull	r0, r1, r0, r3
    a988:	0bc3      	lsrs	r3, r0, #15
	/* Stop work and generate the hash */
	if (k_delayed_work_remaining_get(&db_hash_work)) {
    a98a:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
    a98e:	d005      	beq.n	a99c <db_hash_commit+0x24>
		k_delayed_work_cancel(&db_hash_work);
    a990:	4823      	ldr	r0, [pc, #140]	; (aa20 <db_hash_commit+0xa8>)
    a992:	f013 fee1 	bl	1e758 <k_delayed_work_cancel>
		db_hash_gen(false);
    a996:	2000      	movs	r0, #0
    a998:	f7ff ff9a 	bl	a8d0 <db_hash_gen>
	}

	/* Check if hash matches then skip SC update */
	if (!memcmp(stored_hash, db_hash, sizeof(stored_hash))) {
    a99c:	2210      	movs	r2, #16
    a99e:	4921      	ldr	r1, [pc, #132]	; (aa24 <db_hash_commit+0xac>)
    a9a0:	4821      	ldr	r0, [pc, #132]	; (aa28 <db_hash_commit+0xb0>)
    a9a2:	f010 fb1a 	bl	1afda <memcmp>
    a9a6:	b920      	cbnz	r0, a9b2 <db_hash_commit+0x3a>
		BT_DBG("Database Hash matches");
		k_delayed_work_cancel(&gatt_sc.work);
    a9a8:	4820      	ldr	r0, [pc, #128]	; (aa2c <db_hash_commit+0xb4>)
    a9aa:	f013 fed5 	bl	1e758 <k_delayed_work_cancel>

	/* Hash did not match overwrite with current hash */
	db_hash_store();

	return 0;
}
    a9ae:	2000      	movs	r0, #0
    a9b0:	bd08      	pop	{r3, pc}
    a9b2:	4a1f      	ldr	r2, [pc, #124]	; (aa30 <db_hash_commit+0xb8>)
    a9b4:	f3bf 8f5b 	dmb	ish
    a9b8:	f102 0338 	add.w	r3, r2, #56	; 0x38
    a9bc:	e853 1f00 	ldrex	r1, [r3]
    a9c0:	f041 0001 	orr.w	r0, r1, #1
    a9c4:	e843 0c00 	strex	ip, r0, [r3]
    a9c8:	f1bc 0f00 	cmp.w	ip, #0
    a9cc:	d1f6      	bne.n	a9bc <db_hash_commit+0x44>
    a9ce:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
    a9d2:	f011 0f01 	tst.w	r1, #1
    a9d6:	4613      	mov	r3, r2
    a9d8:	d10e      	bne.n	a9f8 <db_hash_commit+0x80>
		gatt_sc.start = start;
    a9da:	4b16      	ldr	r3, [pc, #88]	; (aa34 <db_hash_commit+0xbc>)
    a9dc:	6153      	str	r3, [r2, #20]
	if (atomic_test_bit(gatt_sc.flags, SC_INDICATE_PENDING)) {
    a9de:	2101      	movs	r1, #1
    a9e0:	4815      	ldr	r0, [pc, #84]	; (aa38 <db_hash_commit+0xc0>)
    a9e2:	f011 fb21 	bl	1c028 <atomic_test_bit>
    a9e6:	b920      	cbnz	r0, a9f2 <db_hash_commit+0x7a>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    a9e8:	220a      	movs	r2, #10
    a9ea:	4910      	ldr	r1, [pc, #64]	; (aa2c <db_hash_commit+0xb4>)
    a9ec:	4813      	ldr	r0, [pc, #76]	; (aa3c <db_hash_commit+0xc4>)
    a9ee:	f00d febb 	bl	18768 <k_delayed_work_submit_to_queue>
	db_hash_store();
    a9f2:	f7ff f8c9 	bl	9b88 <db_hash_store>
	return 0;
    a9f6:	e7da      	b.n	a9ae <db_hash_commit+0x36>
	if (new_start >= *start && new_end <= *end) {
    a9f8:	8ad1      	ldrh	r1, [r2, #22]
    a9fa:	8a92      	ldrh	r2, [r2, #20]
    a9fc:	2a01      	cmp	r2, #1
    a9fe:	f64f 72ff 	movw	r2, #65535	; 0xffff
    aa02:	d805      	bhi.n	aa10 <db_hash_commit+0x98>
    aa04:	4291      	cmp	r1, r2
    aa06:	d0f4      	beq.n	a9f2 <db_hash_commit+0x7a>
		*end = new_end;
    aa08:	f64f 72ff 	movw	r2, #65535	; 0xffff
    aa0c:	82da      	strh	r2, [r3, #22]
    aa0e:	e7e6      	b.n	a9de <db_hash_commit+0x66>
		*start = new_start;
    aa10:	2001      	movs	r0, #1
	if (*end < new_end) {
    aa12:	4291      	cmp	r1, r2
		*start = new_start;
    aa14:	8298      	strh	r0, [r3, #20]
	if (*end < new_end) {
    aa16:	d0e2      	beq.n	a9de <db_hash_commit+0x66>
    aa18:	e7f6      	b.n	aa08 <db_hash_commit+0x90>
    aa1a:	bf00      	nop
    aa1c:	2000044c 	.word	0x2000044c
    aa20:	20000440 	.word	0x20000440
    aa24:	20001c55 	.word	0x20001c55
    aa28:	20001c65 	.word	0x20001c65
    aa2c:	20000478 	.word	0x20000478
    aa30:	20000460 	.word	0x20000460
    aa34:	ffff0001 	.word	0xffff0001
    aa38:	20000498 	.word	0x20000498
    aa3c:	20001a60 	.word	0x20001a60

0000aa40 <ccc_set_direct>:
{
    aa40:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    aa44:	b0b9      	sub	sp, #228	; 0xe4
    aa46:	4689      	mov	r9, r1
    aa48:	4617      	mov	r7, r2
		if (!settings_name_steq((const char *)param, "bt/ccc", &name)) {
    aa4a:	4940      	ldr	r1, [pc, #256]	; (ab4c <ccc_set_direct+0x10c>)
    aa4c:	9840      	ldr	r0, [sp, #256]	; 0x100
    aa4e:	466a      	mov	r2, sp
{
    aa50:	4698      	mov	r8, r3
		if (!settings_name_steq((const char *)param, "bt/ccc", &name)) {
    aa52:	f010 f810 	bl	1aa76 <settings_name_steq>
    aa56:	b998      	cbnz	r0, aa80 <ccc_set_direct+0x40>
			BT_ERR("Invalid key");
    aa58:	2301      	movs	r3, #1
    aa5a:	f04f 0100 	mov.w	r1, #0
    aa5e:	f363 0107 	bfi	r1, r3, #0, #8
    aa62:	4a3b      	ldr	r2, [pc, #236]	; (ab50 <ccc_set_direct+0x110>)
    aa64:	4b3b      	ldr	r3, [pc, #236]	; (ab54 <ccc_set_direct+0x114>)
    aa66:	483c      	ldr	r0, [pc, #240]	; (ab58 <ccc_set_direct+0x118>)
    aa68:	1a9b      	subs	r3, r3, r2
    aa6a:	08db      	lsrs	r3, r3, #3
    aa6c:	f363 118f 	bfi	r1, r3, #6, #10
    aa70:	f00f fdcf 	bl	1a612 <log_0>
			return -EINVAL;
    aa74:	f06f 0515 	mvn.w	r5, #21
}
    aa78:	4628      	mov	r0, r5
    aa7a:	b039      	add	sp, #228	; 0xe4
    aa7c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return ccc_set(name, len, read_cb, cb_arg);
    aa80:	9c00      	ldr	r4, [sp, #0]
		settings_name_next(name, &next);
    aa82:	a901      	add	r1, sp, #4
    aa84:	4620      	mov	r0, r4
    aa86:	f010 f816 	bl	1aab6 <settings_name_next>
		if (!name) {
    aa8a:	b98c      	cbnz	r4, aab0 <ccc_set_direct+0x70>
			BT_ERR("Insufficient number of arguments");
    aa8c:	2301      	movs	r3, #1
    aa8e:	f04f 0100 	mov.w	r1, #0
    aa92:	f363 0107 	bfi	r1, r3, #0, #8
    aa96:	4a2e      	ldr	r2, [pc, #184]	; (ab50 <ccc_set_direct+0x110>)
    aa98:	4b2e      	ldr	r3, [pc, #184]	; (ab54 <ccc_set_direct+0x114>)
    aa9a:	4830      	ldr	r0, [pc, #192]	; (ab5c <ccc_set_direct+0x11c>)
    aa9c:	1a9b      	subs	r3, r3, r2
    aa9e:	08db      	lsrs	r3, r3, #3
    aaa0:	f363 118f 	bfi	r1, r3, #6, #10
    aaa4:	f00f fdb5 	bl	1a612 <log_0>
			return -EINVAL;
    aaa8:	f06f 0415 	mvn.w	r4, #21
			return -EINVAL;
    aaac:	4625      	mov	r5, r4
    aaae:	e7e3      	b.n	aa78 <ccc_set_direct+0x38>
		} else if (!next) {
    aab0:	9801      	ldr	r0, [sp, #4]
    aab2:	b9e0      	cbnz	r0, aaee <ccc_set_direct+0xae>
		err = bt_settings_decode_key(name, &addr);
    aab4:	ae02      	add	r6, sp, #8
			load.addr_with_id.id = strtol(next, NULL, 10);
    aab6:	f88d 0014 	strb.w	r0, [sp, #20]
		err = bt_settings_decode_key(name, &addr);
    aaba:	4631      	mov	r1, r6
    aabc:	4620      	mov	r0, r4
    aabe:	f010 fb65 	bl	1b18c <bt_settings_decode_key>
		if (err) {
    aac2:	4605      	mov	r5, r0
    aac4:	b1c0      	cbz	r0, aaf8 <ccc_set_direct+0xb8>
			BT_ERR("Unable to decode address %s", log_strdup(name));
    aac6:	2301      	movs	r3, #1
    aac8:	f04f 0500 	mov.w	r5, #0
    aacc:	4a20      	ldr	r2, [pc, #128]	; (ab50 <ccc_set_direct+0x110>)
    aace:	f363 0507 	bfi	r5, r3, #0, #8
    aad2:	4b20      	ldr	r3, [pc, #128]	; (ab54 <ccc_set_direct+0x114>)
    aad4:	1a9b      	subs	r3, r3, r2
    aad6:	08db      	lsrs	r3, r3, #3
    aad8:	4620      	mov	r0, r4
    aada:	f363 158f 	bfi	r5, r3, #6, #10
    aade:	f7f8 f9d1 	bl	2e84 <log_strdup>
    aae2:	462a      	mov	r2, r5
    aae4:	4601      	mov	r1, r0
    aae6:	481e      	ldr	r0, [pc, #120]	; (ab60 <ccc_set_direct+0x120>)
    aae8:	f00f fda0 	bl	1a62c <log_1>
    aaec:	e7dc      	b.n	aaa8 <ccc_set_direct+0x68>
			load.addr_with_id.id = strtol(next, NULL, 10);
    aaee:	220a      	movs	r2, #10
    aaf0:	2100      	movs	r1, #0
    aaf2:	f010 f9bd 	bl	1ae70 <strtol>
    aaf6:	e7dd      	b.n	aab4 <ccc_set_direct+0x74>
		load.addr_with_id.addr = &addr;
    aaf8:	9604      	str	r6, [sp, #16]
		if (len_rd) {
    aafa:	f1b9 0f00 	cmp.w	r9, #0
    aafe:	d021      	beq.n	ab44 <ccc_set_direct+0x104>
			len = read_cb(cb_arg, ccc_store, sizeof(ccc_store));
    ab00:	ae08      	add	r6, sp, #32
    ab02:	22c0      	movs	r2, #192	; 0xc0
    ab04:	4631      	mov	r1, r6
    ab06:	4640      	mov	r0, r8
    ab08:	47b8      	blx	r7
			if (len < 0) {
    ab0a:	1e04      	subs	r4, r0, #0
    ab0c:	da0f      	bge.n	ab2e <ccc_set_direct+0xee>
				BT_ERR("Failed to decode value (err %d)", len);
    ab0e:	2301      	movs	r3, #1
    ab10:	f04f 0200 	mov.w	r2, #0
    ab14:	f363 0207 	bfi	r2, r3, #0, #8
    ab18:	490d      	ldr	r1, [pc, #52]	; (ab50 <ccc_set_direct+0x110>)
    ab1a:	4b0e      	ldr	r3, [pc, #56]	; (ab54 <ccc_set_direct+0x114>)
    ab1c:	4811      	ldr	r0, [pc, #68]	; (ab64 <ccc_set_direct+0x124>)
    ab1e:	1a5b      	subs	r3, r3, r1
    ab20:	08db      	lsrs	r3, r3, #3
    ab22:	f363 128f 	bfi	r2, r3, #6, #10
    ab26:	4621      	mov	r1, r4
    ab28:	f00f fd80 	bl	1a62c <log_1>
				return len;
    ab2c:	e7be      	b.n	aaac <ccc_set_direct+0x6c>
			load.count = len / sizeof(*ccc_store);
    ab2e:	08a4      	lsrs	r4, r4, #2
			load.entry = ccc_store;
    ab30:	9606      	str	r6, [sp, #24]
			load.count = len / sizeof(*ccc_store);
    ab32:	9407      	str	r4, [sp, #28]
		bt_gatt_foreach_attr(0x0001, 0xffff, ccc_load, &load);
    ab34:	ab04      	add	r3, sp, #16
    ab36:	4a0c      	ldr	r2, [pc, #48]	; (ab68 <ccc_set_direct+0x128>)
    ab38:	f64f 71ff 	movw	r1, #65535	; 0xffff
    ab3c:	2001      	movs	r0, #1
    ab3e:	f011 fc66 	bl	1c40e <bt_gatt_foreach_attr>
	return 0;
    ab42:	e799      	b.n	aa78 <ccc_set_direct+0x38>
			load.count = 0;
    ab44:	e9cd 0006 	strd	r0, r0, [sp, #24]
    ab48:	e7f4      	b.n	ab34 <ccc_set_direct+0xf4>
    ab4a:	bf00      	nop
    ab4c:	0002122a 	.word	0x0002122a
    ab50:	0001ed28 	.word	0x0001ed28
    ab54:	0001ede0 	.word	0x0001ede0
    ab58:	00021231 	.word	0x00021231
    ab5c:	00020222 	.word	0x00020222
    ab60:	000213e6 	.word	0x000213e6
    ab64:	000212bd 	.word	0x000212bd
    ab68:	00009f0d 	.word	0x00009f0d

0000ab6c <bt_gatt_indicate>:
{
    ab6c:	b570      	push	{r4, r5, r6, lr}
    ab6e:	4605      	mov	r5, r0
    ab70:	b08a      	sub	sp, #40	; 0x28
    ab72:	460e      	mov	r6, r1
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    ab74:	4837      	ldr	r0, [pc, #220]	; (ac54 <bt_gatt_indicate+0xe8>)
    ab76:	2101      	movs	r1, #1
    ab78:	f011 fa56 	bl	1c028 <atomic_test_bit>
    ab7c:	2800      	cmp	r0, #0
    ab7e:	d060      	beq.n	ac42 <bt_gatt_indicate+0xd6>
	attr = params->attr;
    ab80:	6870      	ldr	r0, [r6, #4]
    ab82:	9004      	str	r0, [sp, #16]
	if (conn && conn->state != BT_CONN_CONNECTED) {
    ab84:	b115      	cbz	r5, ab8c <bt_gatt_indicate+0x20>
    ab86:	7b6b      	ldrb	r3, [r5, #13]
    ab88:	2b06      	cmp	r3, #6
    ab8a:	d15d      	bne.n	ac48 <bt_gatt_indicate+0xdc>
	handle = attr->handle ? : find_static_attr(attr);
    ab8c:	8a04      	ldrh	r4, [r0, #16]
    ab8e:	b93c      	cbnz	r4, aba0 <bt_gatt_indicate+0x34>
    ab90:	f7fe ffd6 	bl	9b40 <find_static_attr>
	if (!handle) {
    ab94:	4604      	mov	r4, r0
    ab96:	b918      	cbnz	r0, aba0 <bt_gatt_indicate+0x34>
		return -ENOENT;
    ab98:	f06f 0001 	mvn.w	r0, #1
}
    ab9c:	b00a      	add	sp, #40	; 0x28
    ab9e:	bd70      	pop	{r4, r5, r6, pc}
	if (params->uuid) {
    aba0:	6832      	ldr	r2, [r6, #0]
    aba2:	b1b2      	cbz	r2, abd2 <bt_gatt_indicate+0x66>
		bt_gatt_foreach_attr_type(handle, 0xffff, params->uuid,
    aba4:	a904      	add	r1, sp, #16
    aba6:	9102      	str	r1, [sp, #8]
    aba8:	492b      	ldr	r1, [pc, #172]	; (ac58 <bt_gatt_indicate+0xec>)
    abaa:	9101      	str	r1, [sp, #4]
    abac:	2101      	movs	r1, #1
		attr = NULL;
    abae:	2300      	movs	r3, #0
		bt_gatt_foreach_attr_type(handle, 0xffff, params->uuid,
    abb0:	9100      	str	r1, [sp, #0]
    abb2:	4620      	mov	r0, r4
    abb4:	f64f 71ff 	movw	r1, #65535	; 0xffff
		attr = NULL;
    abb8:	9304      	str	r3, [sp, #16]
		bt_gatt_foreach_attr_type(handle, 0xffff, params->uuid,
    abba:	f7ff fe2b 	bl	a814 <bt_gatt_foreach_attr_type>
		if (!attr) {
    abbe:	9804      	ldr	r0, [sp, #16]
    abc0:	2800      	cmp	r0, #0
    abc2:	d0e9      	beq.n	ab98 <bt_gatt_indicate+0x2c>
		handle = attr->handle ? : find_static_attr(attr);
    abc4:	8a04      	ldrh	r4, [r0, #16]
    abc6:	b924      	cbnz	r4, abd2 <bt_gatt_indicate+0x66>
    abc8:	f7fe ffba 	bl	9b40 <find_static_attr>
		if (!handle) {
    abcc:	4604      	mov	r4, r0
    abce:	2800      	cmp	r0, #0
    abd0:	d0e2      	beq.n	ab98 <bt_gatt_indicate+0x2c>
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC)) {
    abd2:	9b04      	ldr	r3, [sp, #16]
    abd4:	6818      	ldr	r0, [r3, #0]
    abd6:	2300      	movs	r3, #0
    abd8:	f88d 3014 	strb.w	r3, [sp, #20]
    abdc:	a905      	add	r1, sp, #20
    abde:	f642 0303 	movw	r3, #10243	; 0x2803
    abe2:	f8ad 3016 	strh.w	r3, [sp, #22]
    abe6:	f010 faf5 	bl	1b1d4 <bt_uuid_cmp>
    abea:	b938      	cbnz	r0, abfc <bt_gatt_indicate+0x90>
		struct bt_gatt_chrc *chrc = params->attr->user_data;
    abec:	6870      	ldr	r0, [r6, #4]
		if (!(chrc->properties & BT_GATT_CHRC_INDICATE)) {
    abee:	68c3      	ldr	r3, [r0, #12]
    abf0:	799b      	ldrb	r3, [r3, #6]
    abf2:	069b      	lsls	r3, r3, #26
    abf4:	d52b      	bpl.n	ac4e <bt_gatt_indicate+0xe2>
		handle = bt_gatt_attr_value_handle(params->attr);
    abf6:	f7ff fdf5 	bl	a7e4 <bt_gatt_attr_value_handle>
    abfa:	4604      	mov	r4, r0
	if (conn) {
    abfc:	b12d      	cbz	r5, ac0a <bt_gatt_indicate+0x9e>
		return gatt_indicate(conn, handle, params);
    abfe:	4632      	mov	r2, r6
    ac00:	4621      	mov	r1, r4
    ac02:	4628      	mov	r0, r5
    ac04:	f7ff f93e 	bl	9e84 <gatt_indicate>
    ac08:	e7c8      	b.n	ab9c <bt_gatt_indicate+0x30>
	data.err = -ENOTCONN;
    ac0a:	f06f 0338 	mvn.w	r3, #56	; 0x38
    ac0e:	9307      	str	r3, [sp, #28]
	data.type = BT_GATT_CCC_INDICATE;
    ac10:	2302      	movs	r3, #2
    ac12:	f8ad 3020 	strh.w	r3, [sp, #32]
	bt_gatt_foreach_attr_type(handle, 0xffff, BT_UUID_GATT_CCC, NULL, 1,
    ac16:	f642 1302 	movw	r3, #10498	; 0x2902
    ac1a:	f8ad 301a 	strh.w	r3, [sp, #26]
    ac1e:	ab07      	add	r3, sp, #28
    ac20:	9302      	str	r3, [sp, #8]
    ac22:	4b0e      	ldr	r3, [pc, #56]	; (ac5c <bt_gatt_indicate+0xf0>)
    ac24:	9301      	str	r3, [sp, #4]
    ac26:	2301      	movs	r3, #1
    ac28:	9300      	str	r3, [sp, #0]
    ac2a:	4620      	mov	r0, r4
    ac2c:	462b      	mov	r3, r5
    ac2e:	aa06      	add	r2, sp, #24
    ac30:	f64f 71ff 	movw	r1, #65535	; 0xffff
	data.ind_params = params;
    ac34:	9609      	str	r6, [sp, #36]	; 0x24
	bt_gatt_foreach_attr_type(handle, 0xffff, BT_UUID_GATT_CCC, NULL, 1,
    ac36:	f88d 5018 	strb.w	r5, [sp, #24]
    ac3a:	f7ff fdeb 	bl	a814 <bt_gatt_foreach_attr_type>
	return data.err;
    ac3e:	9807      	ldr	r0, [sp, #28]
    ac40:	e7ac      	b.n	ab9c <bt_gatt_indicate+0x30>
		return -EAGAIN;
    ac42:	f06f 000a 	mvn.w	r0, #10
    ac46:	e7a9      	b.n	ab9c <bt_gatt_indicate+0x30>
		return -ENOTCONN;
    ac48:	f06f 0038 	mvn.w	r0, #56	; 0x38
    ac4c:	e7a6      	b.n	ab9c <bt_gatt_indicate+0x30>
			return -EINVAL;
    ac4e:	f06f 0015 	mvn.w	r0, #21
    ac52:	e7a3      	b.n	ab9c <bt_gatt_indicate+0x30>
    ac54:	200054a8 	.word	0x200054a8
    ac58:	0001c0df 	.word	0x0001c0df
    ac5c:	0000a2d1 	.word	0x0000a2d1

0000ac60 <sc_process>:
{
    ac60:	b573      	push	{r0, r1, r4, r5, r6, lr}
	atomic_clear_bit(sc->flags, SC_RANGE_CHANGED);
    ac62:	f100 0520 	add.w	r5, r0, #32
{
    ac66:	4604      	mov	r4, r0
	sc_range[0] = sys_cpu_to_le16(sc->start);
    ac68:	f850 3c04 	ldr.w	r3, [r0, #-4]
    ac6c:	9301      	str	r3, [sp, #4]
	atomic_clear_bit(sc->flags, SC_RANGE_CHANGED);
    ac6e:	f1a0 0618 	sub.w	r6, r0, #24
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    ac72:	f06f 0101 	mvn.w	r1, #1
    ac76:	4628      	mov	r0, r5
    ac78:	f011 f9df 	bl	1c03a <atomic_and>
	sc->params.attr = &_1_gatt_svc.attrs[2];
    ac7c:	4b0d      	ldr	r3, [pc, #52]	; (acb4 <sc_process+0x54>)
    ac7e:	f844 3c14 	str.w	r3, [r4, #-20]
	sc->params.func = sc_indicate_rsp;
    ac82:	4b0d      	ldr	r3, [pc, #52]	; (acb8 <sc_process+0x58>)
    ac84:	f844 3c10 	str.w	r3, [r4, #-16]
	sc->params.data = &sc_range[0];
    ac88:	ab01      	add	r3, sp, #4
	sc->start = 0U;
    ac8a:	2000      	movs	r0, #0
	sc->params.data = &sc_range[0];
    ac8c:	f844 3c0c 	str.w	r3, [r4, #-12]
	sc->params.len = sizeof(sc_range);
    ac90:	2304      	movs	r3, #4
	sc->start = 0U;
    ac92:	f824 0c04 	strh.w	r0, [r4, #-4]
	sc->end = 0U;
    ac96:	f824 0c02 	strh.w	r0, [r4, #-2]
	sc->params.len = sizeof(sc_range);
    ac9a:	f824 3c08 	strh.w	r3, [r4, #-8]
	if (bt_gatt_indicate(NULL, &sc->params)) {
    ac9e:	4631      	mov	r1, r6
    aca0:	f7ff ff64 	bl	ab6c <bt_gatt_indicate>
    aca4:	b918      	cbnz	r0, acae <sc_process+0x4e>
	atomic_set_bit(sc->flags, SC_INDICATE_PENDING);
    aca6:	2101      	movs	r1, #1
    aca8:	4628      	mov	r0, r5
    acaa:	f011 fa44 	bl	1c136 <atomic_set_bit>
}
    acae:	b002      	add	sp, #8
    acb0:	bd70      	pop	{r4, r5, r6, pc}
    acb2:	bf00      	nop
    acb4:	0001f554 	.word	0x0001f554
    acb8:	0000a5e1 	.word	0x0000a5e1

0000acbc <update_ccc>:
{
    acbc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
    acc0:	4b40      	ldr	r3, [pc, #256]	; (adc4 <update_ccc+0x108>)
    acc2:	6882      	ldr	r2, [r0, #8]
    acc4:	429a      	cmp	r2, r3
{
    acc6:	4606      	mov	r6, r0
    acc8:	4688      	mov	r8, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
    acca:	d126      	bne.n	ad1a <update_ccc+0x5e>
				BT_WARN("CCC %p not writable", attr);
    accc:	4b3e      	ldr	r3, [pc, #248]	; (adc8 <update_ccc+0x10c>)
	ccc = attr->user_data;
    acce:	68c7      	ldr	r7, [r0, #12]
    acd0:	4d3e      	ldr	r5, [pc, #248]	; (adcc <update_ccc+0x110>)
	struct bt_conn *conn = data->conn;
    acd2:	680c      	ldr	r4, [r1, #0]
				BT_WARN("CCC %p not writable", attr);
    acd4:	1aed      	subs	r5, r5, r3
		if (!ccc->cfg[i].value ||
    acd6:	893b      	ldrh	r3, [r7, #8]
				BT_WARN("CCC %p not writable", attr);
    acd8:	f3c5 05c9 	ubfx	r5, r5, #3, #10
		if (!ccc->cfg[i].value ||
    acdc:	b1eb      	cbz	r3, ad1a <update_ccc+0x5e>
		    bt_conn_addr_le_cmp(conn, &ccc->cfg[i].peer)) {
    acde:	1c79      	adds	r1, r7, #1
    ace0:	4620      	mov	r0, r4
    ace2:	f010 fc54 	bl	1b58e <bt_conn_addr_le_cmp>
		if (!ccc->cfg[i].value ||
    ace6:	b9c0      	cbnz	r0, ad1a <update_ccc+0x5e>
		err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_WRITE_MASK);
    ace8:	222a      	movs	r2, #42	; 0x2a
    acea:	4631      	mov	r1, r6
    acec:	4620      	mov	r0, r4
    acee:	f011 fb9c 	bl	1c42a <bt_gatt_check_perm>
		if (err) {
    acf2:	b310      	cbz	r0, ad3a <update_ccc+0x7e>
			if (err == BT_ATT_ERR_WRITE_NOT_PERMITTED) {
    acf4:	2803      	cmp	r0, #3
    acf6:	d014      	beq.n	ad22 <update_ccc+0x66>
				sec = BT_SECURITY_L3;
    acf8:	2805      	cmp	r0, #5
			    bt_conn_get_security(conn) < sec) {
    acfa:	4620      	mov	r0, r4
				sec = BT_SECURITY_L3;
    acfc:	bf14      	ite	ne
    acfe:	f04f 0902 	movne.w	r9, #2
    ad02:	f04f 0903 	moveq.w	r9, #3
			    bt_conn_get_security(conn) < sec) {
    ad06:	f010 fc40 	bl	1b58a <bt_conn_get_security>
			if (IS_ENABLED(CONFIG_BT_SMP) &&
    ad0a:	4581      	cmp	r9, r0
    ad0c:	d915      	bls.n	ad3a <update_ccc+0x7e>
				if (data->sec < sec) {
    ad0e:	f898 3004 	ldrb.w	r3, [r8, #4]
    ad12:	454b      	cmp	r3, r9
    ad14:	d201      	bcs.n	ad1a <update_ccc+0x5e>
					data->sec = sec;
    ad16:	f888 9004 	strb.w	r9, [r8, #4]
}
    ad1a:	2001      	movs	r0, #1
    ad1c:	b003      	add	sp, #12
    ad1e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
				BT_WARN("CCC %p not writable", attr);
    ad22:	2302      	movs	r3, #2
    ad24:	f04f 0200 	mov.w	r2, #0
    ad28:	f363 0207 	bfi	r2, r3, #0, #8
    ad2c:	f365 128f 	bfi	r2, r5, #6, #10
    ad30:	4631      	mov	r1, r6
    ad32:	4827      	ldr	r0, [pc, #156]	; (add0 <update_ccc+0x114>)
    ad34:	f00f fc7a 	bl	1a62c <log_1>
				continue;
    ad38:	e7ef      	b.n	ad1a <update_ccc+0x5e>
		gatt_ccc_changed(attr, ccc);
    ad3a:	4639      	mov	r1, r7
    ad3c:	4630      	mov	r0, r6
    ad3e:	f011 f8db 	bl	1bef8 <gatt_ccc_changed>
		if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) &&
    ad42:	4b24      	ldr	r3, [pc, #144]	; (add4 <update_ccc+0x118>)
    ad44:	429f      	cmp	r7, r3
    ad46:	d1e8      	bne.n	ad1a <update_ccc+0x5e>
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    ad48:	f104 0170 	add.w	r1, r4, #112	; 0x70
    ad4c:	7a20      	ldrb	r0, [r4, #8]
    ad4e:	f7ff fa55 	bl	a1fc <find_sc_cfg.part.11>
	if (!cfg) {
    ad52:	4606      	mov	r6, r0
    ad54:	2800      	cmp	r0, #0
    ad56:	d0e0      	beq.n	ad1a <update_ccc+0x5e>
	if (!(cfg->data.start || cfg->data.end)) {
    ad58:	8902      	ldrh	r2, [r0, #8]
    ad5a:	8943      	ldrh	r3, [r0, #10]
    ad5c:	ea53 0102 	orrs.w	r1, r3, r2
    ad60:	d0db      	beq.n	ad1a <update_ccc+0x5e>
	index = bt_conn_index(conn);
    ad62:	4620      	mov	r0, r4
	sc_range[0] = sys_cpu_to_le16(cfg->data.start);
    ad64:	f8ad 2004 	strh.w	r2, [sp, #4]
	sc_range[1] = sys_cpu_to_le16(cfg->data.end);
    ad68:	f8ad 3006 	strh.w	r3, [sp, #6]
	index = bt_conn_index(conn);
    ad6c:	f7fd fcb6 	bl	86dc <bt_conn_index>
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
    ad70:	4919      	ldr	r1, [pc, #100]	; (add8 <update_ccc+0x11c>)
    ad72:	4a1a      	ldr	r2, [pc, #104]	; (addc <update_ccc+0x120>)
    ad74:	2314      	movs	r3, #20
    ad76:	fb03 1300 	mla	r3, r3, r0, r1
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
    ad7a:	b200      	sxth	r0, r0
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
    ad7c:	605a      	str	r2, [r3, #4]
	sc_restore_params[index].func = sc_restore_rsp;
    ad7e:	4a18      	ldr	r2, [pc, #96]	; (ade0 <update_ccc+0x124>)
    ad80:	609a      	str	r2, [r3, #8]
	sc_restore_params[index].data = &sc_range[0];
    ad82:	aa01      	add	r2, sp, #4
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
    ad84:	eb00 0080 	add.w	r0, r0, r0, lsl #2
	sc_restore_params[index].data = &sc_range[0];
    ad88:	60da      	str	r2, [r3, #12]
	sc_restore_params[index].len = sizeof(sc_range);
    ad8a:	2204      	movs	r2, #4
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
    ad8c:	eb01 0180 	add.w	r1, r1, r0, lsl #2
	sc_restore_params[index].len = sizeof(sc_range);
    ad90:	821a      	strh	r2, [r3, #16]
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
    ad92:	4620      	mov	r0, r4
    ad94:	f7ff feea 	bl	ab6c <bt_gatt_indicate>
    ad98:	b148      	cbz	r0, adae <update_ccc+0xf2>
		BT_ERR("SC restore indication failed");
    ad9a:	f04f 0100 	mov.w	r1, #0
    ad9e:	2301      	movs	r3, #1
    ada0:	f363 0107 	bfi	r1, r3, #0, #8
    ada4:	f365 118f 	bfi	r1, r5, #6, #10
    ada8:	480e      	ldr	r0, [pc, #56]	; (ade4 <update_ccc+0x128>)
    adaa:	f00f fc32 	bl	1a612 <log_0>
	memset(&cfg->data, 0, sizeof(cfg->data));
    adae:	2204      	movs	r2, #4
    adb0:	2100      	movs	r1, #0
    adb2:	f106 0008 	add.w	r0, r6, #8
    adb6:	f010 f94a 	bl	1b04e <memset>
		sc_store(cfg);
    adba:	4630      	mov	r0, r6
    adbc:	f7fe ff2c 	bl	9c18 <sc_store>
    adc0:	e7ab      	b.n	ad1a <update_ccc+0x5e>
    adc2:	bf00      	nop
    adc4:	0000a031 	.word	0x0000a031
    adc8:	0001ed28 	.word	0x0001ed28
    adcc:	0001ede0 	.word	0x0001ede0
    add0:	00021454 	.word	0x00021454
    add4:	200056c8 	.word	0x200056c8
    add8:	200004a0 	.word	0x200004a0
    addc:	0001f554 	.word	0x0001f554
    ade0:	0001c17d 	.word	0x0001c17d
    ade4:	00021468 	.word	0x00021468

0000ade8 <bt_gatt_discover>:
{
    ade8:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (conn->state != BT_CONN_CONNECTED) {
    adea:	7b43      	ldrb	r3, [r0, #13]
    adec:	2b06      	cmp	r3, #6
{
    adee:	b085      	sub	sp, #20
    adf0:	4605      	mov	r5, r0
    adf2:	460c      	mov	r4, r1
	if (conn->state != BT_CONN_CONNECTED) {
    adf4:	f040 80e4 	bne.w	afc0 <bt_gatt_discover+0x1d8>
	switch (params->type) {
    adf8:	7c09      	ldrb	r1, [r1, #16]
    adfa:	2905      	cmp	r1, #5
    adfc:	f200 80d1 	bhi.w	afa2 <bt_gatt_discover+0x1ba>
    ae00:	e8df f001 	tbb	[pc, r1]
    ae04:	6a6a0303 	.word	0x6a6a0303
    ae08:	bb88      	.short	0xbb88
		if (params->uuid) {
    ae0a:	6823      	ldr	r3, [r4, #0]
    ae0c:	2b00      	cmp	r3, #0
    ae0e:	d045      	beq.n	ae9c <bt_gatt_discover+0xb4>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_REQ, sizeof(*req));
    ae10:	2206      	movs	r2, #6
    ae12:	4611      	mov	r1, r2
    ae14:	f7fe f808 	bl	8e28 <bt_att_create_pdu>
	if (!buf) {
    ae18:	4606      	mov	r6, r0
    ae1a:	b918      	cbnz	r0, ae24 <bt_gatt_discover+0x3c>
		return -ENOMEM;
    ae1c:	f06f 000b 	mvn.w	r0, #11
}
    ae20:	b005      	add	sp, #20
    ae22:	bdf0      	pop	{r4, r5, r6, r7, pc}
	req = net_buf_add(buf, sizeof(*req));
    ae24:	f100 0708 	add.w	r7, r0, #8
    ae28:	2106      	movs	r1, #6
    ae2a:	4638      	mov	r0, r7
    ae2c:	f012 ff0e 	bl	1dc4c <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
    ae30:	8923      	ldrh	r3, [r4, #8]
    ae32:	8003      	strh	r3, [r0, #0]
	req->end_handle = sys_cpu_to_le16(params->end_handle);
    ae34:	89e3      	ldrh	r3, [r4, #14]
    ae36:	8043      	strh	r3, [r0, #2]
	if (params->type == BT_GATT_DISCOVER_PRIMARY) {
    ae38:	7c23      	ldrb	r3, [r4, #16]
		uuid_val = BT_UUID_16(BT_UUID_GATT_SECONDARY)->val;
    ae3a:	2b00      	cmp	r3, #0
	req->type = sys_cpu_to_le16(uuid_val);
    ae3c:	f642 0301 	movw	r3, #10241	; 0x2801
    ae40:	bf08      	it	eq
    ae42:	f44f 5320 	moveq.w	r3, #10240	; 0x2800
    ae46:	8083      	strh	r3, [r0, #4]
	switch (params->uuid->type) {
    ae48:	6823      	ldr	r3, [r4, #0]
    ae4a:	7819      	ldrb	r1, [r3, #0]
    ae4c:	b1a9      	cbz	r1, ae7a <bt_gatt_discover+0x92>
    ae4e:	2902      	cmp	r1, #2
    ae50:	d01e      	beq.n	ae90 <bt_gatt_discover+0xa8>
		BT_ERR("Unknown UUID type %u", params->uuid->type);
    ae52:	2301      	movs	r3, #1
    ae54:	f04f 0200 	mov.w	r2, #0
    ae58:	f363 0207 	bfi	r2, r3, #0, #8
    ae5c:	485a      	ldr	r0, [pc, #360]	; (afc8 <bt_gatt_discover+0x1e0>)
    ae5e:	4b5b      	ldr	r3, [pc, #364]	; (afcc <bt_gatt_discover+0x1e4>)
    ae60:	1a1b      	subs	r3, r3, r0
    ae62:	08db      	lsrs	r3, r3, #3
    ae64:	485a      	ldr	r0, [pc, #360]	; (afd0 <bt_gatt_discover+0x1e8>)
    ae66:	f363 128f 	bfi	r2, r3, #6, #10
    ae6a:	f00f fbdf 	bl	1a62c <log_1>
		net_buf_unref(buf);
    ae6e:	4630      	mov	r0, r6
    ae70:	f00b fb56 	bl	16520 <net_buf_unref>
	return -EINVAL;
    ae74:	f06f 0015 	mvn.w	r0, #21
    ae78:	e7d2      	b.n	ae20 <bt_gatt_discover+0x38>
		net_buf_add_le16(buf, BT_UUID_16(params->uuid)->val);
    ae7a:	8859      	ldrh	r1, [r3, #2]
    ae7c:	4638      	mov	r0, r7
    ae7e:	f012 fefc 	bl	1dc7a <net_buf_simple_add_le16>
	return gatt_send(conn, buf, gatt_find_type_rsp, params, NULL);
    ae82:	4a54      	ldr	r2, [pc, #336]	; (afd4 <bt_gatt_discover+0x1ec>)
    ae84:	4623      	mov	r3, r4
	return gatt_send(conn, buf, gatt_find_info_rsp, params, NULL);
    ae86:	4631      	mov	r1, r6
    ae88:	4628      	mov	r0, r5
    ae8a:	f7fe ffbb 	bl	9e04 <gatt_send.constprop.37>
    ae8e:	e7c7      	b.n	ae20 <bt_gatt_discover+0x38>
		net_buf_add_mem(buf, BT_UUID_128(params->uuid)->val, 16);
    ae90:	2210      	movs	r2, #16
    ae92:	1c59      	adds	r1, r3, #1
    ae94:	4638      	mov	r0, r7
    ae96:	f012 fedf 	bl	1dc58 <net_buf_simple_add_mem>
		break;
    ae9a:	e7f2      	b.n	ae82 <bt_gatt_discover+0x9a>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_REQ, sizeof(*req));
    ae9c:	2204      	movs	r2, #4
    ae9e:	2110      	movs	r1, #16
    aea0:	f7fd ffc2 	bl	8e28 <bt_att_create_pdu>
	if (!buf) {
    aea4:	4606      	mov	r6, r0
    aea6:	2800      	cmp	r0, #0
    aea8:	d0b8      	beq.n	ae1c <bt_gatt_discover+0x34>
	req = net_buf_add(buf, sizeof(*req));
    aeaa:	f100 0708 	add.w	r7, r0, #8
    aeae:	2104      	movs	r1, #4
    aeb0:	4638      	mov	r0, r7
    aeb2:	f012 fecb 	bl	1dc4c <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
    aeb6:	8923      	ldrh	r3, [r4, #8]
    aeb8:	8003      	strh	r3, [r0, #0]
	req->end_handle = sys_cpu_to_le16(params->end_handle);
    aeba:	89e3      	ldrh	r3, [r4, #14]
    aebc:	8043      	strh	r3, [r0, #2]
	if (params->type == BT_GATT_DISCOVER_PRIMARY) {
    aebe:	7c23      	ldrb	r3, [r4, #16]
    aec0:	b93b      	cbnz	r3, aed2 <bt_gatt_discover+0xea>
		net_buf_add_le16(buf, BT_UUID_16(BT_UUID_GATT_PRIMARY)->val);
    aec2:	f44f 5120 	mov.w	r1, #10240	; 0x2800
		net_buf_add_le16(buf, BT_UUID_16(BT_UUID_GATT_SECONDARY)->val);
    aec6:	4638      	mov	r0, r7
    aec8:	f012 fed7 	bl	1dc7a <net_buf_simple_add_le16>
	return gatt_send(conn, buf, gatt_read_group_rsp, params, NULL);
    aecc:	4623      	mov	r3, r4
    aece:	4a42      	ldr	r2, [pc, #264]	; (afd8 <bt_gatt_discover+0x1f0>)
    aed0:	e7d9      	b.n	ae86 <bt_gatt_discover+0x9e>
		net_buf_add_le16(buf, BT_UUID_16(BT_UUID_GATT_SECONDARY)->val);
    aed2:	f642 0101 	movw	r1, #10241	; 0x2801
    aed6:	e7f6      	b.n	aec6 <bt_gatt_discover+0xde>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_REQ, sizeof(*req));
    aed8:	2204      	movs	r2, #4
    aeda:	2108      	movs	r1, #8
    aedc:	f7fd ffa4 	bl	8e28 <bt_att_create_pdu>
	if (!buf) {
    aee0:	4606      	mov	r6, r0
    aee2:	2800      	cmp	r0, #0
    aee4:	d09a      	beq.n	ae1c <bt_gatt_discover+0x34>
	req = net_buf_add(buf, sizeof(*req));
    aee6:	f100 0708 	add.w	r7, r0, #8
    aeea:	2104      	movs	r1, #4
    aeec:	4638      	mov	r0, r7
    aeee:	f012 fead 	bl	1dc4c <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
    aef2:	8923      	ldrh	r3, [r4, #8]
    aef4:	8003      	strh	r3, [r0, #0]
	req->end_handle = sys_cpu_to_le16(params->end_handle);
    aef6:	89e3      	ldrh	r3, [r4, #14]
    aef8:	8043      	strh	r3, [r0, #2]
	if (params->type == BT_GATT_DISCOVER_INCLUDE) {
    aefa:	7c23      	ldrb	r3, [r4, #16]
    aefc:	2b02      	cmp	r3, #2
		net_buf_add_le16(buf, BT_UUID_16(BT_UUID_GATT_INCLUDE)->val);
    aefe:	bf0c      	ite	eq
    af00:	f642 0102 	movweq	r1, #10242	; 0x2802
		net_buf_add_le16(buf, BT_UUID_16(BT_UUID_GATT_CHRC)->val);
    af04:	f642 0103 	movwne	r1, #10243	; 0x2803
    af08:	4638      	mov	r0, r7
    af0a:	f012 feb6 	bl	1dc7a <net_buf_simple_add_le16>
	return gatt_send(conn, buf, gatt_read_type_rsp, params, NULL);
    af0e:	4623      	mov	r3, r4
    af10:	4a32      	ldr	r2, [pc, #200]	; (afdc <bt_gatt_discover+0x1f4>)
    af12:	e7b8      	b.n	ae86 <bt_gatt_discover+0x9e>
		if (params->uuid &&
    af14:	6820      	ldr	r0, [r4, #0]
    af16:	b380      	cbz	r0, af7a <bt_gatt_discover+0x192>
		    (!bt_uuid_cmp(params->uuid, BT_UUID_GATT_PRIMARY) ||
    af18:	2600      	movs	r6, #0
    af1a:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    af1e:	4669      	mov	r1, sp
    af20:	f88d 6000 	strb.w	r6, [sp]
    af24:	f8ad 3002 	strh.w	r3, [sp, #2]
    af28:	f010 f954 	bl	1b1d4 <bt_uuid_cmp>
		if (params->uuid &&
    af2c:	2800      	cmp	r0, #0
    af2e:	d0a1      	beq.n	ae74 <bt_gatt_discover+0x8c>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_SECONDARY) ||
    af30:	f642 0301 	movw	r3, #10241	; 0x2801
    af34:	a901      	add	r1, sp, #4
    af36:	6820      	ldr	r0, [r4, #0]
    af38:	f88d 6004 	strb.w	r6, [sp, #4]
    af3c:	f8ad 3006 	strh.w	r3, [sp, #6]
    af40:	f010 f948 	bl	1b1d4 <bt_uuid_cmp>
		    (!bt_uuid_cmp(params->uuid, BT_UUID_GATT_PRIMARY) ||
    af44:	2800      	cmp	r0, #0
    af46:	d095      	beq.n	ae74 <bt_gatt_discover+0x8c>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_INCLUDE) ||
    af48:	f642 0302 	movw	r3, #10242	; 0x2802
    af4c:	a902      	add	r1, sp, #8
    af4e:	6820      	ldr	r0, [r4, #0]
    af50:	f88d 6008 	strb.w	r6, [sp, #8]
    af54:	f8ad 300a 	strh.w	r3, [sp, #10]
    af58:	f010 f93c 	bl	1b1d4 <bt_uuid_cmp>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_SECONDARY) ||
    af5c:	2800      	cmp	r0, #0
    af5e:	d089      	beq.n	ae74 <bt_gatt_discover+0x8c>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_CHRC))) {
    af60:	f642 0303 	movw	r3, #10243	; 0x2803
    af64:	a903      	add	r1, sp, #12
    af66:	6820      	ldr	r0, [r4, #0]
    af68:	f88d 600c 	strb.w	r6, [sp, #12]
    af6c:	f8ad 300e 	strh.w	r3, [sp, #14]
    af70:	f010 f930 	bl	1b1d4 <bt_uuid_cmp>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_INCLUDE) ||
    af74:	2800      	cmp	r0, #0
    af76:	f43f af7d 	beq.w	ae74 <bt_gatt_discover+0x8c>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_REQ, sizeof(*req));
    af7a:	2204      	movs	r2, #4
    af7c:	4611      	mov	r1, r2
    af7e:	4628      	mov	r0, r5
    af80:	f7fd ff52 	bl	8e28 <bt_att_create_pdu>
	if (!buf) {
    af84:	4606      	mov	r6, r0
    af86:	2800      	cmp	r0, #0
    af88:	f43f af48 	beq.w	ae1c <bt_gatt_discover+0x34>
	req = net_buf_add(buf, sizeof(*req));
    af8c:	2104      	movs	r1, #4
    af8e:	3008      	adds	r0, #8
    af90:	f012 fe5c 	bl	1dc4c <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
    af94:	8923      	ldrh	r3, [r4, #8]
    af96:	8003      	strh	r3, [r0, #0]
	req->end_handle = sys_cpu_to_le16(params->end_handle);
    af98:	89e3      	ldrh	r3, [r4, #14]
    af9a:	8043      	strh	r3, [r0, #2]
	return gatt_send(conn, buf, gatt_find_info_rsp, params, NULL);
    af9c:	4a10      	ldr	r2, [pc, #64]	; (afe0 <bt_gatt_discover+0x1f8>)
    af9e:	4623      	mov	r3, r4
    afa0:	e771      	b.n	ae86 <bt_gatt_discover+0x9e>
		BT_ERR("Invalid discovery type: %u", params->type);
    afa2:	2301      	movs	r3, #1
    afa4:	f04f 0200 	mov.w	r2, #0
    afa8:	f363 0207 	bfi	r2, r3, #0, #8
    afac:	4806      	ldr	r0, [pc, #24]	; (afc8 <bt_gatt_discover+0x1e0>)
    afae:	4b07      	ldr	r3, [pc, #28]	; (afcc <bt_gatt_discover+0x1e4>)
    afb0:	1a1b      	subs	r3, r3, r0
    afb2:	08db      	lsrs	r3, r3, #3
    afb4:	f363 128f 	bfi	r2, r3, #6, #10
    afb8:	480a      	ldr	r0, [pc, #40]	; (afe4 <bt_gatt_discover+0x1fc>)
    afba:	f00f fb37 	bl	1a62c <log_1>
    afbe:	e759      	b.n	ae74 <bt_gatt_discover+0x8c>
		return -ENOTCONN;
    afc0:	f06f 0038 	mvn.w	r0, #56	; 0x38
    afc4:	e72c      	b.n	ae20 <bt_gatt_discover+0x38>
    afc6:	bf00      	nop
    afc8:	0001ed28 	.word	0x0001ed28
    afcc:	0001ede0 	.word	0x0001ede0
    afd0:	000211dc 	.word	0x000211dc
    afd4:	0001c4bb 	.word	0x0001c4bb
    afd8:	0000afe9 	.word	0x0000afe9
    afdc:	0000b101 	.word	0x0000b101
    afe0:	0000b3f9 	.word	0x0000b3f9
    afe4:	000211f1 	.word	0x000211f1

0000afe8 <gatt_read_group_rsp>:
{
    afe8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    afec:	b08f      	sub	sp, #60	; 0x3c
    afee:	4690      	mov	r8, r2
    aff0:	4681      	mov	r9, r0
    aff2:	9d18      	ldr	r5, [sp, #96]	; 0x60
	if (err) {
    aff4:	460a      	mov	r2, r1
    aff6:	b131      	cbz	r1, b006 <gatt_read_group_rsp+0x1e>
		params->func(conn, NULL, params);
    aff8:	686b      	ldr	r3, [r5, #4]
    affa:	462a      	mov	r2, r5
    affc:	2100      	movs	r1, #0
	params->func(conn, NULL, params);
    affe:	4798      	blx	r3
}
    b000:	b00f      	add	sp, #60	; 0x3c
    b002:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (rsp->len) {
    b006:	f898 1000 	ldrb.w	r1, [r8]
    b00a:	2906      	cmp	r1, #6
    b00c:	d015      	beq.n	b03a <gatt_read_group_rsp+0x52>
    b00e:	2914      	cmp	r1, #20
    b010:	d012      	beq.n	b038 <gatt_read_group_rsp+0x50>
		BT_ERR("Invalid data len %u", rsp->len);
    b012:	2301      	movs	r3, #1
    b014:	f04f 0200 	mov.w	r2, #0
    b018:	f363 0207 	bfi	r2, r3, #0, #8
    b01c:	4835      	ldr	r0, [pc, #212]	; (b0f4 <gatt_read_group_rsp+0x10c>)
    b01e:	4b36      	ldr	r3, [pc, #216]	; (b0f8 <gatt_read_group_rsp+0x110>)
    b020:	1a1b      	subs	r3, r3, r0
    b022:	08db      	lsrs	r3, r3, #3
    b024:	f363 128f 	bfi	r2, r3, #6, #10
    b028:	4834      	ldr	r0, [pc, #208]	; (b0fc <gatt_read_group_rsp+0x114>)
    b02a:	f00f faff 	bl	1a62c <log_1>
	params->func(conn, NULL, params);
    b02e:	686b      	ldr	r3, [r5, #4]
    b030:	462a      	mov	r2, r5
    b032:	2100      	movs	r1, #0
    b034:	4648      	mov	r0, r9
    b036:	e7e2      	b.n	affe <gatt_read_group_rsp+0x16>
		u.uuid.type = BT_UUID_TYPE_128;
    b038:	2202      	movs	r2, #2
	for (length--, pdu = rsp->data; length >= rsp->len;
    b03a:	3b01      	subs	r3, #1
		u.uuid.type = BT_UUID_TYPE_128;
    b03c:	f88d 2010 	strb.w	r2, [sp, #16]
	for (length--, pdu = rsp->data; length >= rsp->len;
    b040:	b29c      	uxth	r4, r3
    b042:	f108 0701 	add.w	r7, r8, #1
	u16_t start_handle, end_handle = 0U;
    b046:	2600      	movs	r6, #0
	for (length--, pdu = rsp->data; length >= rsp->len;
    b048:	f898 3000 	ldrb.w	r3, [r8]
    b04c:	42a3      	cmp	r3, r4
    b04e:	d909      	bls.n	b064 <gatt_read_group_rsp+0x7c>
	if (length == 0U && end_handle) {
    b050:	2c00      	cmp	r4, #0
    b052:	d1ec      	bne.n	b02e <gatt_read_group_rsp+0x46>
    b054:	2e00      	cmp	r6, #0
    b056:	d0ea      	beq.n	b02e <gatt_read_group_rsp+0x46>
	gatt_discover_next(conn, handle, params);
    b058:	462a      	mov	r2, r5
    b05a:	4631      	mov	r1, r6
    b05c:	4648      	mov	r0, r9
    b05e:	f011 fa0f 	bl	1c480 <gatt_discover_next>
    b062:	e7cd      	b.n	b000 <gatt_read_group_rsp+0x18>
		struct bt_gatt_attr attr = {};
    b064:	2214      	movs	r2, #20
    b066:	2100      	movs	r1, #0
    b068:	a809      	add	r0, sp, #36	; 0x24
    b06a:	f00f fff0 	bl	1b04e <memset>
		start_handle = sys_le16_to_cpu(data->start_handle);
    b06e:	f8b7 a000 	ldrh.w	sl, [r7]
    b072:	fa1f f38a 	uxth.w	r3, sl
		if (!start_handle) {
    b076:	2b00      	cmp	r3, #0
    b078:	d0d9      	beq.n	b02e <gatt_read_group_rsp+0x46>
		end_handle = sys_le16_to_cpu(data->end_handle);
    b07a:	f8b7 b002 	ldrh.w	fp, [r7, #2]
    b07e:	fa1f f68b 	uxth.w	r6, fp
		if (!end_handle || end_handle < start_handle) {
    b082:	2e00      	cmp	r6, #0
    b084:	d0d3      	beq.n	b02e <gatt_read_group_rsp+0x46>
    b086:	42b3      	cmp	r3, r6
    b088:	d8d1      	bhi.n	b02e <gatt_read_group_rsp+0x46>
		switch (u.uuid.type) {
    b08a:	f89d 3010 	ldrb.w	r3, [sp, #16]
    b08e:	b32b      	cbz	r3, b0dc <gatt_read_group_rsp+0xf4>
    b090:	2b02      	cmp	r3, #2
    b092:	d02a      	beq.n	b0ea <gatt_read_group_rsp+0x102>
		uuid_svc.uuid.type = BT_UUID_TYPE_16;
    b094:	f04f 0300 	mov.w	r3, #0
    b098:	f88d 3004 	strb.w	r3, [sp, #4]
		if (params->type == BT_GATT_DISCOVER_PRIMARY) {
    b09c:	7c2b      	ldrb	r3, [r5, #16]
		value.end_handle = end_handle;
    b09e:	f8ad b00c 	strh.w	fp, [sp, #12]
			uuid_svc.val = BT_UUID_16(BT_UUID_GATT_SECONDARY)->val;
    b0a2:	2b00      	cmp	r3, #0
    b0a4:	f642 0301 	movw	r3, #10241	; 0x2801
    b0a8:	bf08      	it	eq
    b0aa:	f44f 5320 	moveq.w	r3, #10240	; 0x2800
    b0ae:	f8ad 3006 	strh.w	r3, [sp, #6]
		value.uuid = &u.uuid;
    b0b2:	ab04      	add	r3, sp, #16
    b0b4:	9302      	str	r3, [sp, #8]
		attr.uuid = &uuid_svc.uuid;
    b0b6:	ab01      	add	r3, sp, #4
    b0b8:	9309      	str	r3, [sp, #36]	; 0x24
		attr.user_data = &value;
    b0ba:	ab02      	add	r3, sp, #8
    b0bc:	930c      	str	r3, [sp, #48]	; 0x30
		attr.handle = start_handle;
    b0be:	f8ad a034 	strh.w	sl, [sp, #52]	; 0x34
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
    b0c2:	686b      	ldr	r3, [r5, #4]
    b0c4:	462a      	mov	r2, r5
    b0c6:	a909      	add	r1, sp, #36	; 0x24
    b0c8:	4648      	mov	r0, r9
    b0ca:	4798      	blx	r3
    b0cc:	2800      	cmp	r0, #0
    b0ce:	d097      	beq.n	b000 <gatt_read_group_rsp+0x18>
	     length -= rsp->len, pdu = (const u8_t *)pdu + rsp->len) {
    b0d0:	f898 2000 	ldrb.w	r2, [r8]
    b0d4:	1aa4      	subs	r4, r4, r2
    b0d6:	b2a4      	uxth	r4, r4
    b0d8:	4417      	add	r7, r2
    b0da:	e7b5      	b.n	b048 <gatt_read_group_rsp+0x60>
			memcpy(&u.u16.val, data->value, sizeof(u.u16.val));
    b0dc:	2202      	movs	r2, #2
    b0de:	1d39      	adds	r1, r7, #4
    b0e0:	f10d 0012 	add.w	r0, sp, #18
			memcpy(u.u128.val, data->value, sizeof(u.u128.val));
    b0e4:	f00f ff89 	bl	1affa <memcpy>
			break;
    b0e8:	e7d4      	b.n	b094 <gatt_read_group_rsp+0xac>
			memcpy(u.u128.val, data->value, sizeof(u.u128.val));
    b0ea:	2210      	movs	r2, #16
    b0ec:	1d39      	adds	r1, r7, #4
    b0ee:	f10d 0011 	add.w	r0, sp, #17
    b0f2:	e7f7      	b.n	b0e4 <gatt_read_group_rsp+0xfc>
    b0f4:	0001ed28 	.word	0x0001ed28
    b0f8:	0001ede0 	.word	0x0001ede0
    b0fc:	0002136d 	.word	0x0002136d

0000b100 <gatt_read_type_rsp>:
{
    b100:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b104:	b091      	sub	sp, #68	; 0x44
    b106:	4690      	mov	r8, r2
    b108:	4607      	mov	r7, r0
    b10a:	9e1a      	ldr	r6, [sp, #104]	; 0x68
	if (err) {
    b10c:	460a      	mov	r2, r1
    b10e:	b121      	cbz	r1, b11a <gatt_read_type_rsp+0x1a>
		params->func(conn, NULL, params);
    b110:	6873      	ldr	r3, [r6, #4]
    b112:	4632      	mov	r2, r6
    b114:	2100      	movs	r1, #0
	params->func(conn, NULL, params);
    b116:	4798      	blx	r3
	if (!handle) {
    b118:	e084      	b.n	b224 <gatt_read_type_rsp+0x124>
	if (params->type == BT_GATT_DISCOVER_INCLUDE) {
    b11a:	7c30      	ldrb	r0, [r6, #16]
    b11c:	f898 1000 	ldrb.w	r1, [r8]
    b120:	2802      	cmp	r0, #2
    b122:	f040 808b 	bne.w	b23c <gatt_read_type_rsp+0x13c>
	switch (rsp->len) {
    b126:	2906      	cmp	r1, #6
    b128:	d01d      	beq.n	b166 <gatt_read_type_rsp+0x66>
    b12a:	2908      	cmp	r1, #8
    b12c:	f040 808a 	bne.w	b244 <gatt_read_type_rsp+0x144>
		u.uuid.type = BT_UUID_TYPE_16;
    b130:	f88d 202c 	strb.w	r2, [sp, #44]	; 0x2c
	for (length--, pdu = rsp->data; length >= rsp->len;
    b134:	1e5c      	subs	r4, r3, #1
    b136:	b2a4      	uxth	r4, r4
    b138:	f108 0501 	add.w	r5, r8, #1
	u16_t handle = 0U;
    b13c:	f04f 0900 	mov.w	r9, #0
			value.uuid = &u.uuid;
    b140:	f10d 0a2c 	add.w	sl, sp, #44	; 0x2c
	for (length--, pdu = rsp->data; length >= rsp->len;
    b144:	f898 3000 	ldrb.w	r3, [r8]
    b148:	42a3      	cmp	r3, r4
    b14a:	d90f      	bls.n	b16c <gatt_read_type_rsp+0x6c>
	if (length == 0U && handle) {
    b14c:	2c00      	cmp	r4, #0
    b14e:	f040 8087 	bne.w	b260 <gatt_read_type_rsp+0x160>
    b152:	f1b9 0f00 	cmp.w	r9, #0
    b156:	f000 8083 	beq.w	b260 <gatt_read_type_rsp+0x160>
	gatt_discover_next(conn, handle, params);
    b15a:	4632      	mov	r2, r6
    b15c:	4649      	mov	r1, r9
    b15e:	4638      	mov	r0, r7
    b160:	f011 f98e 	bl	1c480 <gatt_discover_next>
    b164:	e05e      	b.n	b224 <gatt_read_type_rsp+0x124>
		u.uuid.type = BT_UUID_TYPE_128;
    b166:	f88d 002c 	strb.w	r0, [sp, #44]	; 0x2c
		break;
    b16a:	e7e3      	b.n	b134 <gatt_read_type_rsp+0x34>
		handle = sys_le16_to_cpu(data->handle);
    b16c:	f8b5 b000 	ldrh.w	fp, [r5]
    b170:	fa1f f98b 	uxth.w	r9, fp
		if (!handle) {
    b174:	f1b9 0f00 	cmp.w	r9, #0
    b178:	d072      	beq.n	b260 <gatt_read_type_rsp+0x160>
		value.start_handle = sys_le16_to_cpu(incl->start_handle);
    b17a:	886b      	ldrh	r3, [r5, #2]
    b17c:	f8ad 3014 	strh.w	r3, [sp, #20]
    b180:	b299      	uxth	r1, r3
		value.end_handle = sys_le16_to_cpu(incl->end_handle);
    b182:	88ab      	ldrh	r3, [r5, #4]
    b184:	f8ad 3016 	strh.w	r3, [sp, #22]
    b188:	b29a      	uxth	r2, r3
		switch (u.uuid.type) {
    b18a:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    b18e:	b313      	cbz	r3, b1d6 <gatt_read_type_rsp+0xd6>
    b190:	2b02      	cmp	r3, #2
    b192:	d029      	beq.n	b1e8 <gatt_read_type_rsp+0xe8>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
    b194:	6831      	ldr	r1, [r6, #0]
    b196:	2900      	cmp	r1, #0
    b198:	d14a      	bne.n	b230 <gatt_read_type_rsp+0x130>
		attr = (&(struct bt_gatt_attr) {
    b19a:	2210      	movs	r2, #16
    b19c:	2100      	movs	r1, #0
    b19e:	a807      	add	r0, sp, #28
    b1a0:	f00f ff55 	bl	1b04e <memset>
			.uuid = BT_UUID_GATT_INCLUDE,
    b1a4:	2300      	movs	r3, #0
    b1a6:	f88d 3008 	strb.w	r3, [sp, #8]
    b1aa:	f642 0302 	movw	r3, #10242	; 0x2802
    b1ae:	f8ad 300a 	strh.w	r3, [sp, #10]
		attr = (&(struct bt_gatt_attr) {
    b1b2:	ab02      	add	r3, sp, #8
    b1b4:	9306      	str	r3, [sp, #24]
    b1b6:	ab04      	add	r3, sp, #16
    b1b8:	9309      	str	r3, [sp, #36]	; 0x24
		attr->handle = handle;
    b1ba:	f8ad b028 	strh.w	fp, [sp, #40]	; 0x28
		if (params->func(conn, attr, params) == BT_GATT_ITER_STOP) {
    b1be:	6873      	ldr	r3, [r6, #4]
    b1c0:	4632      	mov	r2, r6
    b1c2:	a906      	add	r1, sp, #24
    b1c4:	4638      	mov	r0, r7
    b1c6:	4798      	blx	r3
    b1c8:	b360      	cbz	r0, b224 <gatt_read_type_rsp+0x124>
	     length -= rsp->len, pdu = (const u8_t *)pdu + rsp->len) {
    b1ca:	f898 2000 	ldrb.w	r2, [r8]
    b1ce:	1aa4      	subs	r4, r4, r2
    b1d0:	b2a4      	uxth	r4, r4
    b1d2:	4415      	add	r5, r2
    b1d4:	e7b6      	b.n	b144 <gatt_read_type_rsp+0x44>
			value.uuid = &u.uuid;
    b1d6:	f8cd a010 	str.w	sl, [sp, #16]
			u.u16.val = sys_le16_to_cpu(incl->uuid16);
    b1da:	79ab      	ldrb	r3, [r5, #6]
    b1dc:	79ea      	ldrb	r2, [r5, #7]
    b1de:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    b1e2:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
			break;
    b1e6:	e7d5      	b.n	b194 <gatt_read_type_rsp+0x94>
			params->_included.start_handle = value.start_handle;
    b1e8:	8171      	strh	r1, [r6, #10]
			params->_included.end_handle = value.end_handle;
    b1ea:	81b2      	strh	r2, [r6, #12]
			params->_included.attr_handle = handle;
    b1ec:	f8a6 9008 	strh.w	r9, [r6, #8]
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_REQ, sizeof(*req));
    b1f0:	461a      	mov	r2, r3
    b1f2:	210a      	movs	r1, #10
    b1f4:	4638      	mov	r0, r7
    b1f6:	9301      	str	r3, [sp, #4]
    b1f8:	f7fd fe16 	bl	8e28 <bt_att_create_pdu>
	if (!buf) {
    b1fc:	4604      	mov	r4, r0
    b1fe:	b1a0      	cbz	r0, b22a <gatt_read_type_rsp+0x12a>
	req = net_buf_add(buf, sizeof(*req));
    b200:	9b01      	ldr	r3, [sp, #4]
    b202:	3008      	adds	r0, #8
    b204:	4619      	mov	r1, r3
    b206:	f012 fd21 	bl	1dc4c <net_buf_simple_add>
	req->handle = sys_cpu_to_le16(params->_included.start_handle);
    b20a:	8973      	ldrh	r3, [r6, #10]
    b20c:	8003      	strh	r3, [r0, #0]
	return gatt_send(conn, buf, read_included_uuid_cb, params, NULL);
    b20e:	4a47      	ldr	r2, [pc, #284]	; (b32c <gatt_read_type_rsp+0x22c>)
    b210:	4633      	mov	r3, r6
    b212:	4621      	mov	r1, r4
    b214:	4638      	mov	r0, r7
    b216:	f7fe fdf5 	bl	9e04 <gatt_send.constprop.37>
			return read_included_uuid(conn, params);
    b21a:	fa1f f980 	uxth.w	r9, r0
	if (!handle) {
    b21e:	f1b9 0f00 	cmp.w	r9, #0
    b222:	d19a      	bne.n	b15a <gatt_read_type_rsp+0x5a>
}
    b224:	b011      	add	sp, #68	; 0x44
    b226:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return -ENOMEM;
    b22a:	f06f 000b 	mvn.w	r0, #11
    b22e:	e7f4      	b.n	b21a <gatt_read_type_rsp+0x11a>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
    b230:	4650      	mov	r0, sl
    b232:	f00f ffcf 	bl	1b1d4 <bt_uuid_cmp>
    b236:	2800      	cmp	r0, #0
    b238:	d0af      	beq.n	b19a <gatt_read_type_rsp+0x9a>
    b23a:	e7c6      	b.n	b1ca <gatt_read_type_rsp+0xca>
	switch (rsp->len) {
    b23c:	2907      	cmp	r1, #7
    b23e:	d015      	beq.n	b26c <gatt_read_type_rsp+0x16c>
    b240:	2915      	cmp	r1, #21
    b242:	d012      	beq.n	b26a <gatt_read_type_rsp+0x16a>
		BT_ERR("Invalid data len %u", rsp->len);
    b244:	2301      	movs	r3, #1
    b246:	f04f 0200 	mov.w	r2, #0
    b24a:	f363 0207 	bfi	r2, r3, #0, #8
    b24e:	4838      	ldr	r0, [pc, #224]	; (b330 <gatt_read_type_rsp+0x230>)
    b250:	4b38      	ldr	r3, [pc, #224]	; (b334 <gatt_read_type_rsp+0x234>)
    b252:	1a1b      	subs	r3, r3, r0
    b254:	08db      	lsrs	r3, r3, #3
    b256:	f363 128f 	bfi	r2, r3, #6, #10
    b25a:	4837      	ldr	r0, [pc, #220]	; (b338 <gatt_read_type_rsp+0x238>)
    b25c:	f00f f9e6 	bl	1a62c <log_1>
	params->func(conn, NULL, params);
    b260:	6873      	ldr	r3, [r6, #4]
    b262:	4632      	mov	r2, r6
    b264:	2100      	movs	r1, #0
    b266:	4638      	mov	r0, r7
    b268:	e755      	b.n	b116 <gatt_read_type_rsp+0x16>
		u.uuid.type = BT_UUID_TYPE_128;
    b26a:	2202      	movs	r2, #2
	for (length--, pdu = rsp->data; length >= rsp->len;
    b26c:	1e5c      	subs	r4, r3, #1
		u.uuid.type = BT_UUID_TYPE_128;
    b26e:	f88d 2018 	strb.w	r2, [sp, #24]
	for (length--, pdu = rsp->data; length >= rsp->len;
    b272:	b2a4      	uxth	r4, r4
    b274:	f108 0501 	add.w	r5, r8, #1
	u16_t handle = 0U;
    b278:	f04f 0900 	mov.w	r9, #0
	for (length--, pdu = rsp->data; length >= rsp->len;
    b27c:	f898 3000 	ldrb.w	r3, [r8]
    b280:	42a3      	cmp	r3, r4
    b282:	f63f af63 	bhi.w	b14c <gatt_read_type_rsp+0x4c>
		handle = sys_le16_to_cpu(data->handle);
    b286:	f8b5 b000 	ldrh.w	fp, [r5]
    b28a:	fa1f f98b 	uxth.w	r9, fp
		if (!handle) {
    b28e:	f1b9 0f00 	cmp.w	r9, #0
    b292:	d0e5      	beq.n	b260 <gatt_read_type_rsp+0x160>
		switch (u.uuid.type) {
    b294:	f89d 3018 	ldrb.w	r3, [sp, #24]
    b298:	2b00      	cmp	r3, #0
    b29a:	d032      	beq.n	b302 <gatt_read_type_rsp+0x202>
    b29c:	2b02      	cmp	r3, #2
    b29e:	d037      	beq.n	b310 <gatt_read_type_rsp+0x210>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
    b2a0:	6831      	ldr	r1, [r6, #0]
    b2a2:	f10d 0a18 	add.w	sl, sp, #24
    b2a6:	2900      	cmp	r1, #0
    b2a8:	d139      	bne.n	b31e <gatt_read_type_rsp+0x21e>
		attr = (&(struct bt_gatt_attr)BT_GATT_CHRC(&u.uuid,
    b2aa:	2300      	movs	r3, #0
    b2ac:	930f      	str	r3, [sp, #60]	; 0x3c
    b2ae:	930d      	str	r3, [sp, #52]	; 0x34
    b2b0:	f88d 300c 	strb.w	r3, [sp, #12]
    b2b4:	f642 0303 	movw	r3, #10243	; 0x2803
    b2b8:	f8ad 300e 	strh.w	r3, [sp, #14]
    b2bc:	ab03      	add	r3, sp, #12
    b2be:	930b      	str	r3, [sp, #44]	; 0x2c
    b2c0:	4b1e      	ldr	r3, [pc, #120]	; (b33c <gatt_read_type_rsp+0x23c>)
    b2c2:	930c      	str	r3, [sp, #48]	; 0x30
    b2c4:	f8cd a010 	str.w	sl, [sp, #16]
    b2c8:	792a      	ldrb	r2, [r5, #4]
    b2ca:	78eb      	ldrb	r3, [r5, #3]
		attr->handle = handle;
    b2cc:	f8ad b03c 	strh.w	fp, [sp, #60]	; 0x3c
		attr = (&(struct bt_gatt_attr)BT_GATT_CHRC(&u.uuid,
    b2d0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    b2d4:	f8ad 3014 	strh.w	r3, [sp, #20]
    b2d8:	78ab      	ldrb	r3, [r5, #2]
    b2da:	f88d 3016 	strb.w	r3, [sp, #22]
    b2de:	ab04      	add	r3, sp, #16
    b2e0:	930e      	str	r3, [sp, #56]	; 0x38
    b2e2:	2301      	movs	r3, #1
    b2e4:	f88d 303e 	strb.w	r3, [sp, #62]	; 0x3e
		if (params->func(conn, attr, params) == BT_GATT_ITER_STOP) {
    b2e8:	4632      	mov	r2, r6
    b2ea:	6873      	ldr	r3, [r6, #4]
    b2ec:	a90b      	add	r1, sp, #44	; 0x2c
    b2ee:	4638      	mov	r0, r7
    b2f0:	4798      	blx	r3
    b2f2:	2800      	cmp	r0, #0
    b2f4:	d096      	beq.n	b224 <gatt_read_type_rsp+0x124>
	     length -= rsp->len, pdu = (const u8_t *)pdu + rsp->len) {
    b2f6:	f898 2000 	ldrb.w	r2, [r8]
    b2fa:	1aa4      	subs	r4, r4, r2
    b2fc:	b2a4      	uxth	r4, r4
    b2fe:	4415      	add	r5, r2
    b300:	e7bc      	b.n	b27c <gatt_read_type_rsp+0x17c>
			u.u16.val = sys_le16_to_cpu(chrc->uuid16);
    b302:	796b      	ldrb	r3, [r5, #5]
    b304:	79aa      	ldrb	r2, [r5, #6]
    b306:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    b30a:	f8ad 301a 	strh.w	r3, [sp, #26]
			break;
    b30e:	e7c7      	b.n	b2a0 <gatt_read_type_rsp+0x1a0>
			memcpy(u.u128.val, chrc->uuid, sizeof(chrc->uuid));
    b310:	2210      	movs	r2, #16
    b312:	1d69      	adds	r1, r5, #5
    b314:	f10d 0019 	add.w	r0, sp, #25
    b318:	f00f fe6f 	bl	1affa <memcpy>
			break;
    b31c:	e7c0      	b.n	b2a0 <gatt_read_type_rsp+0x1a0>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
    b31e:	4650      	mov	r0, sl
    b320:	f00f ff58 	bl	1b1d4 <bt_uuid_cmp>
    b324:	2800      	cmp	r0, #0
    b326:	d0c0      	beq.n	b2aa <gatt_read_type_rsp+0x1aa>
    b328:	e7e5      	b.n	b2f6 <gatt_read_type_rsp+0x1f6>
    b32a:	bf00      	nop
    b32c:	0000b341 	.word	0x0000b341
    b330:	0001ed28 	.word	0x0001ed28
    b334:	0001ede0 	.word	0x0001ede0
    b338:	0002136d 	.word	0x0002136d
    b33c:	0001c3ad 	.word	0x0001c3ad

0000b340 <read_included_uuid_cb>:
{
    b340:	b570      	push	{r4, r5, r6, lr}
    b342:	b08e      	sub	sp, #56	; 0x38
	if (length != 16U) {
    b344:	2b10      	cmp	r3, #16
{
    b346:	4605      	mov	r5, r0
    b348:	4611      	mov	r1, r2
    b34a:	9c12      	ldr	r4, [sp, #72]	; 0x48
	if (length != 16U) {
    b34c:	d015      	beq.n	b37a <read_included_uuid_cb+0x3a>
		BT_ERR("Invalid data len %u", length);
    b34e:	2101      	movs	r1, #1
    b350:	f04f 0200 	mov.w	r2, #0
    b354:	f361 0207 	bfi	r2, r1, #0, #8
    b358:	4824      	ldr	r0, [pc, #144]	; (b3ec <read_included_uuid_cb+0xac>)
    b35a:	4925      	ldr	r1, [pc, #148]	; (b3f0 <read_included_uuid_cb+0xb0>)
    b35c:	1a40      	subs	r0, r0, r1
    b35e:	08c0      	lsrs	r0, r0, #3
    b360:	f360 128f 	bfi	r2, r0, #6, #10
    b364:	4619      	mov	r1, r3
    b366:	4823      	ldr	r0, [pc, #140]	; (b3f4 <read_included_uuid_cb+0xb4>)
    b368:	f00f f960 	bl	1a62c <log_1>
		params->func(conn, NULL, params);
    b36c:	6863      	ldr	r3, [r4, #4]
    b36e:	4622      	mov	r2, r4
    b370:	2100      	movs	r1, #0
    b372:	4628      	mov	r0, r5
    b374:	4798      	blx	r3
}
    b376:	b00e      	add	sp, #56	; 0x38
    b378:	bd70      	pop	{r4, r5, r6, pc}
	value.start_handle = params->_included.start_handle;
    b37a:	8962      	ldrh	r2, [r4, #10]
    b37c:	f8ad 200c 	strh.w	r2, [sp, #12]
	value.end_handle = params->_included.end_handle;
    b380:	89a2      	ldrh	r2, [r4, #12]
    b382:	f8ad 200e 	strh.w	r2, [sp, #14]
	u.uuid.type = BT_UUID_TYPE_128;
    b386:	2202      	movs	r2, #2
    b388:	f88d 2010 	strb.w	r2, [sp, #16]
	value.uuid = &u.uuid;
    b38c:	ae04      	add	r6, sp, #16
	memcpy(u.u128.val, pdu, length);
    b38e:	461a      	mov	r2, r3
    b390:	f10d 0011 	add.w	r0, sp, #17
	value.uuid = &u.uuid;
    b394:	9602      	str	r6, [sp, #8]
	memcpy(u.u128.val, pdu, length);
    b396:	f00f fe30 	bl	1affa <memcpy>
	if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
    b39a:	6821      	ldr	r1, [r4, #0]
    b39c:	b9f9      	cbnz	r1, b3de <read_included_uuid_cb+0x9e>
	attr = (&(struct bt_gatt_attr) {
    b39e:	2210      	movs	r2, #16
    b3a0:	2100      	movs	r1, #0
    b3a2:	a80a      	add	r0, sp, #40	; 0x28
    b3a4:	f00f fe53 	bl	1b04e <memset>
		.uuid = BT_UUID_GATT_INCLUDE,
    b3a8:	2300      	movs	r3, #0
    b3aa:	f88d 3004 	strb.w	r3, [sp, #4]
    b3ae:	f642 0302 	movw	r3, #10242	; 0x2802
    b3b2:	f8ad 3006 	strh.w	r3, [sp, #6]
	attr = (&(struct bt_gatt_attr) {
    b3b6:	ab01      	add	r3, sp, #4
    b3b8:	9309      	str	r3, [sp, #36]	; 0x24
    b3ba:	ab02      	add	r3, sp, #8
    b3bc:	930c      	str	r3, [sp, #48]	; 0x30
	attr->handle = params->_included.attr_handle;
    b3be:	8923      	ldrh	r3, [r4, #8]
    b3c0:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
	if (params->func(conn, attr, params) == BT_GATT_ITER_STOP) {
    b3c4:	4622      	mov	r2, r4
    b3c6:	6863      	ldr	r3, [r4, #4]
    b3c8:	a909      	add	r1, sp, #36	; 0x24
    b3ca:	4628      	mov	r0, r5
    b3cc:	4798      	blx	r3
    b3ce:	2800      	cmp	r0, #0
    b3d0:	d0d1      	beq.n	b376 <read_included_uuid_cb+0x36>
	gatt_discover_next(conn, params->start_handle, params);
    b3d2:	4622      	mov	r2, r4
    b3d4:	8921      	ldrh	r1, [r4, #8]
    b3d6:	4628      	mov	r0, r5
    b3d8:	f011 f852 	bl	1c480 <gatt_discover_next>
	return;
    b3dc:	e7cb      	b.n	b376 <read_included_uuid_cb+0x36>
	if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
    b3de:	4630      	mov	r0, r6
    b3e0:	f00f fef8 	bl	1b1d4 <bt_uuid_cmp>
    b3e4:	2800      	cmp	r0, #0
    b3e6:	d0da      	beq.n	b39e <read_included_uuid_cb+0x5e>
    b3e8:	e7f3      	b.n	b3d2 <read_included_uuid_cb+0x92>
    b3ea:	bf00      	nop
    b3ec:	0001ede0 	.word	0x0001ede0
    b3f0:	0001ed28 	.word	0x0001ed28
    b3f4:	0002136d 	.word	0x0002136d

0000b3f8 <gatt_find_info_rsp>:
{
    b3f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b3fc:	b091      	sub	sp, #68	; 0x44
    b3fe:	4682      	mov	sl, r0
    b400:	9e1a      	ldr	r6, [sp, #104]	; 0x68
	if (err) {
    b402:	4608      	mov	r0, r1
    b404:	b991      	cbnz	r1, b42c <gatt_find_info_rsp+0x34>
	switch (rsp->format) {
    b406:	7811      	ldrb	r1, [r2, #0]
    b408:	2901      	cmp	r1, #1
    b40a:	d015      	beq.n	b438 <gatt_find_info_rsp+0x40>
    b40c:	2902      	cmp	r1, #2
    b40e:	d029      	beq.n	b464 <gatt_find_info_rsp+0x6c>
		BT_ERR("Invalid format %u", rsp->format);
    b410:	2301      	movs	r3, #1
    b412:	f04f 0200 	mov.w	r2, #0
    b416:	f363 0207 	bfi	r2, r3, #0, #8
    b41a:	484b      	ldr	r0, [pc, #300]	; (b548 <gatt_find_info_rsp+0x150>)
    b41c:	4b4b      	ldr	r3, [pc, #300]	; (b54c <gatt_find_info_rsp+0x154>)
    b41e:	1a1b      	subs	r3, r3, r0
    b420:	08db      	lsrs	r3, r3, #3
    b422:	f363 128f 	bfi	r2, r3, #6, #10
    b426:	484a      	ldr	r0, [pc, #296]	; (b550 <gatt_find_info_rsp+0x158>)
    b428:	f00f f900 	bl	1a62c <log_1>
	params->func(conn, NULL, params);
    b42c:	6873      	ldr	r3, [r6, #4]
    b42e:	4632      	mov	r2, r6
    b430:	2100      	movs	r1, #0
    b432:	4650      	mov	r0, sl
    b434:	4798      	blx	r3
    b436:	e084      	b.n	b542 <gatt_find_info_rsp+0x14a>
		u.uuid.type = BT_UUID_TYPE_16;
    b438:	f88d 0018 	strb.w	r0, [sp, #24]
		len = sizeof(*info.i16);
    b43c:	f04f 0804 	mov.w	r8, #4
	length--;
    b440:	1e5c      	subs	r4, r3, #1
    b442:	b2a4      	uxth	r4, r4
	if (length < len) {
    b444:	4544      	cmp	r4, r8
    b446:	d3f1      	bcc.n	b42c <gatt_find_info_rsp+0x34>
	for (i = length / len, pdu = rsp->info; i != 0;
    b448:	fbb4 f4f8 	udiv	r4, r4, r8
	bool skip = false;
    b44c:	2300      	movs	r3, #0
	for (i = length / len, pdu = rsp->info; i != 0;
    b44e:	1c55      	adds	r5, r2, #1
	u16_t handle = 0U;
    b450:	9301      	str	r3, [sp, #4]
    b452:	af06      	add	r7, sp, #24
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) ||
    b454:	4699      	mov	r9, r3
	for (i = length / len, pdu = rsp->info; i != 0;
    b456:	b954      	cbnz	r4, b46e <gatt_find_info_rsp+0x76>
	gatt_discover_next(conn, handle, params);
    b458:	4632      	mov	r2, r6
    b45a:	9901      	ldr	r1, [sp, #4]
    b45c:	4650      	mov	r0, sl
    b45e:	f011 f80f 	bl	1c480 <gatt_discover_next>
	return;
    b462:	e06e      	b.n	b542 <gatt_find_info_rsp+0x14a>
		u.uuid.type = BT_UUID_TYPE_128;
    b464:	f88d 1018 	strb.w	r1, [sp, #24]
		len = sizeof(*info.i128);
    b468:	f04f 0812 	mov.w	r8, #18
		break;
    b46c:	e7e8      	b.n	b440 <gatt_find_info_rsp+0x48>
		handle = sys_le16_to_cpu(info.i16->handle);
    b46e:	f8b5 b000 	ldrh.w	fp, [r5]
    b472:	fa1f f28b 	uxth.w	r2, fp
    b476:	9201      	str	r2, [sp, #4]
		if (skip) {
    b478:	b11b      	cbz	r3, b482 <gatt_find_info_rsp+0x8a>
			skip = false;
    b47a:	2300      	movs	r3, #0
	     i--, pdu = (const u8_t *)pdu + len) {
    b47c:	3c01      	subs	r4, #1
    b47e:	4445      	add	r5, r8
    b480:	e7e9      	b.n	b456 <gatt_find_info_rsp+0x5e>
		switch (u.uuid.type) {
    b482:	f89d 3018 	ldrb.w	r3, [sp, #24]
    b486:	2b00      	cmp	r3, #0
    b488:	d038      	beq.n	b4fc <gatt_find_info_rsp+0x104>
    b48a:	2b02      	cmp	r3, #2
    b48c:	d03d      	beq.n	b50a <gatt_find_info_rsp+0x112>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
    b48e:	6831      	ldr	r1, [r6, #0]
    b490:	2900      	cmp	r1, #0
    b492:	d141      	bne.n	b518 <gatt_find_info_rsp+0x120>
		if (params->type == BT_GATT_DISCOVER_DESCRIPTOR) {
    b494:	7c33      	ldrb	r3, [r6, #16]
    b496:	2b04      	cmp	r3, #4
    b498:	d144      	bne.n	b524 <gatt_find_info_rsp+0x12c>
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) ||
    b49a:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    b49e:	a902      	add	r1, sp, #8
    b4a0:	4638      	mov	r0, r7
    b4a2:	f88d 9008 	strb.w	r9, [sp, #8]
    b4a6:	f8ad 300a 	strh.w	r3, [sp, #10]
    b4aa:	f00f fe93 	bl	1b1d4 <bt_uuid_cmp>
    b4ae:	2800      	cmp	r0, #0
    b4b0:	d0e3      	beq.n	b47a <gatt_find_info_rsp+0x82>
			    !bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY) ||
    b4b2:	f642 0301 	movw	r3, #10241	; 0x2801
    b4b6:	a903      	add	r1, sp, #12
    b4b8:	4638      	mov	r0, r7
    b4ba:	f88d 900c 	strb.w	r9, [sp, #12]
    b4be:	f8ad 300e 	strh.w	r3, [sp, #14]
    b4c2:	f00f fe87 	bl	1b1d4 <bt_uuid_cmp>
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) ||
    b4c6:	2800      	cmp	r0, #0
    b4c8:	d0d7      	beq.n	b47a <gatt_find_info_rsp+0x82>
			    !bt_uuid_cmp(&u.uuid, BT_UUID_GATT_INCLUDE)) {
    b4ca:	f642 0302 	movw	r3, #10242	; 0x2802
    b4ce:	a904      	add	r1, sp, #16
    b4d0:	4638      	mov	r0, r7
    b4d2:	f88d 9010 	strb.w	r9, [sp, #16]
    b4d6:	f8ad 3012 	strh.w	r3, [sp, #18]
    b4da:	f00f fe7b 	bl	1b1d4 <bt_uuid_cmp>
			    !bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY) ||
    b4de:	2800      	cmp	r0, #0
    b4e0:	d0cb      	beq.n	b47a <gatt_find_info_rsp+0x82>
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_CHRC)) {
    b4e2:	f642 0303 	movw	r3, #10243	; 0x2803
    b4e6:	a905      	add	r1, sp, #20
    b4e8:	4638      	mov	r0, r7
    b4ea:	f88d 9014 	strb.w	r9, [sp, #20]
    b4ee:	f8ad 3016 	strh.w	r3, [sp, #22]
    b4f2:	f00f fe6f 	bl	1b1d4 <bt_uuid_cmp>
    b4f6:	b9a8      	cbnz	r0, b524 <gatt_find_info_rsp+0x12c>
				skip = true;
    b4f8:	2301      	movs	r3, #1
    b4fa:	e7bf      	b.n	b47c <gatt_find_info_rsp+0x84>
			u.u16.val = sys_le16_to_cpu(info.i16->uuid);
    b4fc:	78ab      	ldrb	r3, [r5, #2]
    b4fe:	78ea      	ldrb	r2, [r5, #3]
    b500:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    b504:	f8ad 301a 	strh.w	r3, [sp, #26]
			break;
    b508:	e7c1      	b.n	b48e <gatt_find_info_rsp+0x96>
			memcpy(u.u128.val, info.i128->uuid, 16);
    b50a:	2210      	movs	r2, #16
    b50c:	1ca9      	adds	r1, r5, #2
    b50e:	f10d 0019 	add.w	r0, sp, #25
    b512:	f00f fd72 	bl	1affa <memcpy>
			break;
    b516:	e7ba      	b.n	b48e <gatt_find_info_rsp+0x96>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
    b518:	4638      	mov	r0, r7
    b51a:	f00f fe5b 	bl	1b1d4 <bt_uuid_cmp>
    b51e:	2800      	cmp	r0, #0
    b520:	d0b8      	beq.n	b494 <gatt_find_info_rsp+0x9c>
    b522:	e7aa      	b.n	b47a <gatt_find_info_rsp+0x82>
			BT_GATT_DESCRIPTOR(&u.uuid, 0, NULL, NULL, NULL));
    b524:	2210      	movs	r2, #16
    b526:	2100      	movs	r1, #0
    b528:	a80c      	add	r0, sp, #48	; 0x30
    b52a:	f00f fd90 	bl	1b04e <memset>
    b52e:	970b      	str	r7, [sp, #44]	; 0x2c
		attr->handle = handle;
    b530:	f8ad b03c 	strh.w	fp, [sp, #60]	; 0x3c
		if (params->func(conn, attr, params) == BT_GATT_ITER_STOP) {
    b534:	6873      	ldr	r3, [r6, #4]
    b536:	4632      	mov	r2, r6
    b538:	a90b      	add	r1, sp, #44	; 0x2c
    b53a:	4650      	mov	r0, sl
    b53c:	4798      	blx	r3
    b53e:	2800      	cmp	r0, #0
    b540:	d19b      	bne.n	b47a <gatt_find_info_rsp+0x82>
}
    b542:	b011      	add	sp, #68	; 0x44
    b544:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b548:	0001ed28 	.word	0x0001ed28
    b54c:	0001ede0 	.word	0x0001ede0
    b550:	0002130b 	.word	0x0002130b

0000b554 <bt_gatt_read>:
	if (conn->state != BT_CONN_CONNECTED) {
    b554:	7b43      	ldrb	r3, [r0, #13]
    b556:	2b06      	cmp	r3, #6
{
    b558:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b55c:	4605      	mov	r5, r0
    b55e:	460c      	mov	r4, r1
	if (conn->state != BT_CONN_CONNECTED) {
    b560:	d166      	bne.n	b630 <bt_gatt_read+0xdc>
	if (params->handle_count == 0) {
    b562:	684a      	ldr	r2, [r1, #4]
    b564:	bb1a      	cbnz	r2, b5ae <bt_gatt_read+0x5a>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_REQ, sizeof(*req));
    b566:	2204      	movs	r2, #4
    b568:	2108      	movs	r1, #8
    b56a:	f7fd fc5d 	bl	8e28 <bt_att_create_pdu>
	if (!buf) {
    b56e:	4606      	mov	r6, r0
    b570:	b918      	cbnz	r0, b57a <bt_gatt_read+0x26>
		return -ENOMEM;
    b572:	f06f 000b 	mvn.w	r0, #11
}
    b576:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	req = net_buf_add(buf, sizeof(*req));
    b57a:	f100 0708 	add.w	r7, r0, #8
    b57e:	2104      	movs	r1, #4
    b580:	4638      	mov	r0, r7
    b582:	f012 fb63 	bl	1dc4c <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->by_uuid.start_handle);
    b586:	8923      	ldrh	r3, [r4, #8]
    b588:	8003      	strh	r3, [r0, #0]
	if (params->by_uuid.uuid->type == BT_UUID_TYPE_16) {
    b58a:	68e1      	ldr	r1, [r4, #12]
	req->end_handle = sys_cpu_to_le16(params->by_uuid.end_handle);
    b58c:	8963      	ldrh	r3, [r4, #10]
    b58e:	8043      	strh	r3, [r0, #2]
	if (params->by_uuid.uuid->type == BT_UUID_TYPE_16) {
    b590:	780b      	ldrb	r3, [r1, #0]
    b592:	b933      	cbnz	r3, b5a2 <bt_gatt_read+0x4e>
		net_buf_add_le16(buf, BT_UUID_16(params->by_uuid.uuid)->val);
    b594:	8849      	ldrh	r1, [r1, #2]
    b596:	4638      	mov	r0, r7
    b598:	f012 fb6f 	bl	1dc7a <net_buf_simple_add_le16>
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
    b59c:	4623      	mov	r3, r4
    b59e:	4a26      	ldr	r2, [pc, #152]	; (b638 <bt_gatt_read+0xe4>)
    b5a0:	e019      	b.n	b5d6 <bt_gatt_read+0x82>
		net_buf_add_mem(buf, BT_UUID_128(params->by_uuid.uuid)->val, 16);
    b5a2:	2210      	movs	r2, #16
    b5a4:	3101      	adds	r1, #1
    b5a6:	4638      	mov	r0, r7
    b5a8:	f012 fb56 	bl	1dc58 <net_buf_simple_add_mem>
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
    b5ac:	e7f6      	b.n	b59c <bt_gatt_read+0x48>
	if (params->handle_count > 1) {
    b5ae:	2a01      	cmp	r2, #1
    b5b0:	d91e      	bls.n	b5f0 <bt_gatt_read+0x9c>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_REQ,
    b5b2:	0052      	lsls	r2, r2, #1
    b5b4:	210e      	movs	r1, #14
    b5b6:	f7fd fc37 	bl	8e28 <bt_att_create_pdu>
	if (!buf) {
    b5ba:	4606      	mov	r6, r0
    b5bc:	2800      	cmp	r0, #0
    b5be:	d0d8      	beq.n	b572 <bt_gatt_read+0x1e>
    b5c0:	2700      	movs	r7, #0
		net_buf_add_le16(buf, params->handles[i]);
    b5c2:	f100 0808 	add.w	r8, r0, #8
	for (i = 0U; i < params->handle_count; i++) {
    b5c6:	6862      	ldr	r2, [r4, #4]
    b5c8:	b2fb      	uxtb	r3, r7
    b5ca:	429a      	cmp	r2, r3
    b5cc:	f107 0701 	add.w	r7, r7, #1
    b5d0:	d807      	bhi.n	b5e2 <bt_gatt_read+0x8e>
	return gatt_send(conn, buf, gatt_read_multiple_rsp, params, NULL);
    b5d2:	4a1a      	ldr	r2, [pc, #104]	; (b63c <bt_gatt_read+0xe8>)
    b5d4:	4623      	mov	r3, r4
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
    b5d6:	4631      	mov	r1, r6
    b5d8:	4628      	mov	r0, r5
}
    b5da:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
    b5de:	f7fe bc11 	b.w	9e04 <gatt_send.constprop.37>
		net_buf_add_le16(buf, params->handles[i]);
    b5e2:	68a2      	ldr	r2, [r4, #8]
    b5e4:	4640      	mov	r0, r8
    b5e6:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
    b5ea:	f012 fb46 	bl	1dc7a <net_buf_simple_add_le16>
    b5ee:	e7ea      	b.n	b5c6 <bt_gatt_read+0x72>
	if (params->single.offset) {
    b5f0:	894b      	ldrh	r3, [r1, #10]
    b5f2:	b17b      	cbz	r3, b614 <bt_gatt_read+0xc0>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_BLOB_REQ, sizeof(*req));
    b5f4:	2204      	movs	r2, #4
    b5f6:	210c      	movs	r1, #12
    b5f8:	f7fd fc16 	bl	8e28 <bt_att_create_pdu>
	if (!buf) {
    b5fc:	4606      	mov	r6, r0
    b5fe:	2800      	cmp	r0, #0
    b600:	d0b7      	beq.n	b572 <bt_gatt_read+0x1e>
	req = net_buf_add(buf, sizeof(*req));
    b602:	2104      	movs	r1, #4
    b604:	3008      	adds	r0, #8
    b606:	f012 fb21 	bl	1dc4c <net_buf_simple_add>
	req->handle = sys_cpu_to_le16(params->single.handle);
    b60a:	8923      	ldrh	r3, [r4, #8]
    b60c:	8003      	strh	r3, [r0, #0]
	req->offset = sys_cpu_to_le16(params->single.offset);
    b60e:	8963      	ldrh	r3, [r4, #10]
    b610:	8043      	strh	r3, [r0, #2]
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
    b612:	e7c3      	b.n	b59c <bt_gatt_read+0x48>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_REQ, sizeof(*req));
    b614:	2202      	movs	r2, #2
    b616:	210a      	movs	r1, #10
    b618:	f7fd fc06 	bl	8e28 <bt_att_create_pdu>
	if (!buf) {
    b61c:	4606      	mov	r6, r0
    b61e:	2800      	cmp	r0, #0
    b620:	d0a7      	beq.n	b572 <bt_gatt_read+0x1e>
	req = net_buf_add(buf, sizeof(*req));
    b622:	2102      	movs	r1, #2
    b624:	3008      	adds	r0, #8
    b626:	f012 fb11 	bl	1dc4c <net_buf_simple_add>
	req->handle = sys_cpu_to_le16(params->single.handle);
    b62a:	8923      	ldrh	r3, [r4, #8]
    b62c:	8003      	strh	r3, [r0, #0]
    b62e:	e7b5      	b.n	b59c <bt_gatt_read+0x48>
		return -ENOTCONN;
    b630:	f06f 0038 	mvn.w	r0, #56	; 0x38
    b634:	e79f      	b.n	b576 <bt_gatt_read+0x22>
    b636:	bf00      	nop
    b638:	0000b641 	.word	0x0000b641
    b63c:	0001c059 	.word	0x0001c059

0000b640 <gatt_read_rsp>:
{
    b640:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    b644:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    b646:	4606      	mov	r6, r0
    b648:	4690      	mov	r8, r2
    b64a:	4699      	mov	r9, r3
	if (err || !length) {
    b64c:	460f      	mov	r7, r1
    b64e:	b901      	cbnz	r1, b652 <gatt_read_rsp+0x12>
    b650:	b953      	cbnz	r3, b668 <gatt_read_rsp+0x28>
		params->func(conn, err, params, NULL, 0);
    b652:	2300      	movs	r3, #0
    b654:	930a      	str	r3, [sp, #40]	; 0x28
    b656:	6825      	ldr	r5, [r4, #0]
    b658:	4622      	mov	r2, r4
    b65a:	4639      	mov	r1, r7
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
    b65c:	4630      	mov	r0, r6
    b65e:	46ac      	mov	ip, r5
}
    b660:	b003      	add	sp, #12
    b662:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
    b666:	4760      	bx	ip
	if (!params->handle_count) {
    b668:	6863      	ldr	r3, [r4, #4]
    b66a:	2b00      	cmp	r3, #0
    b66c:	d14d      	bne.n	b70a <gatt_read_rsp+0xca>
	for (length--, pdu = rsp->data; length;
    b66e:	f109 35ff 	add.w	r5, r9, #4294967295	; 0xffffffff
    b672:	b2ad      	uxth	r5, r5
    b674:	f102 0901 	add.w	r9, r2, #1
    b678:	b35d      	cbz	r5, b6d2 <gatt_read_rsp+0x92>
		handle = sys_le16_to_cpu(data->handle);
    b67a:	f8b9 2000 	ldrh.w	r2, [r9]
    b67e:	b293      	uxth	r3, r2
		if (!handle) {
    b680:	b983      	cbnz	r3, b6a4 <gatt_read_rsp+0x64>
			BT_ERR("Invalid handle");
    b682:	2301      	movs	r3, #1
    b684:	f04f 0100 	mov.w	r1, #0
    b688:	f363 0107 	bfi	r1, r3, #0, #8
    b68c:	4a30      	ldr	r2, [pc, #192]	; (b750 <gatt_read_rsp+0x110>)
    b68e:	4b31      	ldr	r3, [pc, #196]	; (b754 <gatt_read_rsp+0x114>)
    b690:	4831      	ldr	r0, [pc, #196]	; (b758 <gatt_read_rsp+0x118>)
    b692:	1a9b      	subs	r3, r3, r2
    b694:	08db      	lsrs	r3, r3, #3
    b696:	f363 118f 	bfi	r1, r3, #6, #10
}
    b69a:	b003      	add	sp, #12
    b69c:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
			BT_ERR("Invalid handle");
    b6a0:	f00e bfb7 	b.w	1a612 <log_0>
		len = rsp->len > length ? length - 2 : rsp->len - 2;
    b6a4:	f898 3000 	ldrb.w	r3, [r8]
		params->by_uuid.start_handle = handle;
    b6a8:	8122      	strh	r2, [r4, #8]
		len = rsp->len > length ? length - 2 : rsp->len - 2;
    b6aa:	42ab      	cmp	r3, r5
    b6ac:	bf8c      	ite	hi
    b6ae:	1eab      	subhi	r3, r5, #2
    b6b0:	3b02      	subls	r3, #2
    b6b2:	b29b      	uxth	r3, r3
		if (params->func(conn, 0, params, data->value, len) ==
    b6b4:	9300      	str	r3, [sp, #0]
    b6b6:	6827      	ldr	r7, [r4, #0]
    b6b8:	f109 0302 	add.w	r3, r9, #2
    b6bc:	4622      	mov	r2, r4
    b6be:	2100      	movs	r1, #0
    b6c0:	4630      	mov	r0, r6
    b6c2:	47b8      	blx	r7
    b6c4:	2800      	cmp	r0, #0
    b6c6:	d03f      	beq.n	b748 <gatt_read_rsp+0x108>
		if (rsp->len > length) {
    b6c8:	f898 1000 	ldrb.w	r1, [r8]
    b6cc:	b28b      	uxth	r3, r1
    b6ce:	429d      	cmp	r5, r3
    b6d0:	d20b      	bcs.n	b6ea <gatt_read_rsp+0xaa>
	if (bt_gatt_read(conn, params) < 0) {
    b6d2:	4621      	mov	r1, r4
    b6d4:	4630      	mov	r0, r6
    b6d6:	f7ff ff3d 	bl	b554 <bt_gatt_read>
    b6da:	2800      	cmp	r0, #0
    b6dc:	da34      	bge.n	b748 <gatt_read_rsp+0x108>
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
    b6de:	2300      	movs	r3, #0
    b6e0:	930a      	str	r3, [sp, #40]	; 0x28
    b6e2:	6825      	ldr	r5, [r4, #0]
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
    b6e4:	4622      	mov	r2, r4
    b6e6:	210e      	movs	r1, #14
    b6e8:	e7b8      	b.n	b65c <gatt_read_rsp+0x1c>
		if (params->by_uuid.start_handle == params->by_uuid.end_handle) {
    b6ea:	8922      	ldrh	r2, [r4, #8]
    b6ec:	8960      	ldrh	r0, [r4, #10]
    b6ee:	4290      	cmp	r0, r2
    b6f0:	d105      	bne.n	b6fe <gatt_read_rsp+0xbe>
			params->func(conn, 0, params, NULL, 0);
    b6f2:	2300      	movs	r3, #0
    b6f4:	930a      	str	r3, [sp, #40]	; 0x28
    b6f6:	6825      	ldr	r5, [r4, #0]
		params->func(conn, 0, params, NULL, 0);
    b6f8:	4622      	mov	r2, r4
    b6fa:	4619      	mov	r1, r3
    b6fc:	e7ae      	b.n	b65c <gatt_read_rsp+0x1c>
		params->by_uuid.start_handle++;
    b6fe:	3201      	adds	r2, #1
	     length -= rsp->len, pdu = (const u8_t *)pdu + rsp->len) {
    b700:	1aed      	subs	r5, r5, r3
		params->by_uuid.start_handle++;
    b702:	8122      	strh	r2, [r4, #8]
	     length -= rsp->len, pdu = (const u8_t *)pdu + rsp->len) {
    b704:	b2ad      	uxth	r5, r5
    b706:	4489      	add	r9, r1
    b708:	e7b6      	b.n	b678 <gatt_read_rsp+0x38>
	if (params->func(conn, 0, params, pdu, length) == BT_GATT_ITER_STOP) {
    b70a:	f8cd 9000 	str.w	r9, [sp]
    b70e:	4613      	mov	r3, r2
    b710:	6825      	ldr	r5, [r4, #0]
    b712:	4622      	mov	r2, r4
    b714:	47a8      	blx	r5
    b716:	b1b8      	cbz	r0, b748 <gatt_read_rsp+0x108>
	if (length < (bt_att_get_mtu(conn) - 1)) {
    b718:	4630      	mov	r0, r6
    b71a:	f010 fb01 	bl	1bd20 <bt_att_get_mtu>
    b71e:	3801      	subs	r0, #1
    b720:	4581      	cmp	r9, r0
    b722:	da03      	bge.n	b72c <gatt_read_rsp+0xec>
		params->func(conn, 0, params, NULL, 0);
    b724:	970a      	str	r7, [sp, #40]	; 0x28
    b726:	6825      	ldr	r5, [r4, #0]
    b728:	463b      	mov	r3, r7
    b72a:	e7e5      	b.n	b6f8 <gatt_read_rsp+0xb8>
	params->single.offset += length;
    b72c:	8963      	ldrh	r3, [r4, #10]
    b72e:	eb09 0503 	add.w	r5, r9, r3
    b732:	8165      	strh	r5, [r4, #10]
	if (bt_gatt_read(conn, params) < 0) {
    b734:	4621      	mov	r1, r4
    b736:	4630      	mov	r0, r6
    b738:	f7ff ff0c 	bl	b554 <bt_gatt_read>
    b73c:	2800      	cmp	r0, #0
    b73e:	da03      	bge.n	b748 <gatt_read_rsp+0x108>
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
    b740:	970a      	str	r7, [sp, #40]	; 0x28
    b742:	6825      	ldr	r5, [r4, #0]
    b744:	463b      	mov	r3, r7
    b746:	e7cd      	b.n	b6e4 <gatt_read_rsp+0xa4>
}
    b748:	b003      	add	sp, #12
    b74a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    b74e:	bf00      	nop
    b750:	0001ed28 	.word	0x0001ed28
    b754:	0001ede0 	.word	0x0001ede0
    b758:	00021381 	.word	0x00021381

0000b75c <bt_gatt_connected>:
{
    b75c:	b570      	push	{r4, r5, r6, lr}
    b75e:	b08e      	sub	sp, #56	; 0x38
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    b760:	f100 0670 	add.w	r6, r0, #112	; 0x70
{
    b764:	4605      	mov	r5, r0
	data.conn = conn;
    b766:	9003      	str	r0, [sp, #12]
	data.sec = BT_SECURITY_L1;
    b768:	2301      	movs	r3, #1
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    b76a:	4631      	mov	r1, r6
    b76c:	7a00      	ldrb	r0, [r0, #8]
	data.sec = BT_SECURITY_L1;
    b76e:	f88d 3010 	strb.w	r3, [sp, #16]
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    b772:	f00f fe64 	bl	1b43e <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS_CCC_LAZY_LOADING) &&
    b776:	b190      	cbz	r0, b79e <bt_gatt_connected+0x42>
		if (conn->id) {
    b778:	7a2a      	ldrb	r2, [r5, #8]
    b77a:	b362      	cbz	r2, b7d6 <bt_gatt_connected+0x7a>
			u8_to_dec(id_str, sizeof(id_str), conn->id);
    b77c:	ac02      	add	r4, sp, #8
    b77e:	2104      	movs	r1, #4
    b780:	4620      	mov	r0, r4
    b782:	f00d fa38 	bl	18bf6 <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "ccc",
    b786:	9400      	str	r4, [sp, #0]
			bt_settings_encode_key(key, sizeof(key), "ccc",
    b788:	4a1d      	ldr	r2, [pc, #116]	; (b800 <bt_gatt_connected+0xa4>)
    b78a:	2124      	movs	r1, #36	; 0x24
    b78c:	a805      	add	r0, sp, #20
    b78e:	4633      	mov	r3, r6
    b790:	f7f9 fdf6 	bl	5380 <bt_settings_encode_key>
		settings_load_subtree_direct(key, ccc_set_direct, (void *)key);
    b794:	aa05      	add	r2, sp, #20
    b796:	491b      	ldr	r1, [pc, #108]	; (b804 <bt_gatt_connected+0xa8>)
    b798:	4610      	mov	r0, r2
    b79a:	f7f8 faab 	bl	3cf4 <settings_load_subtree_direct>
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
    b79e:	f64f 71ff 	movw	r1, #65535	; 0xffff
    b7a2:	ab03      	add	r3, sp, #12
    b7a4:	4a18      	ldr	r2, [pc, #96]	; (b808 <bt_gatt_connected+0xac>)
    b7a6:	2001      	movs	r0, #1
    b7a8:	f010 fe31 	bl	1c40e <bt_gatt_foreach_attr>
	    bt_conn_get_security(conn) < data.sec) {
    b7ac:	4628      	mov	r0, r5
    b7ae:	f00f feec 	bl	1b58a <bt_conn_get_security>
    b7b2:	f89d 1010 	ldrb.w	r1, [sp, #16]
	if (IS_ENABLED(CONFIG_BT_SMP) &&
    b7b6:	4288      	cmp	r0, r1
    b7b8:	d202      	bcs.n	b7c0 <bt_gatt_connected+0x64>
		bt_conn_set_security(conn, data.sec);
    b7ba:	4628      	mov	r0, r5
    b7bc:	f00f feb2 	bl	1b524 <bt_conn_set_security>
	sub = gatt_sub_find(conn);
    b7c0:	2100      	movs	r1, #0
    b7c2:	4628      	mov	r0, r5
    b7c4:	f7fe fce6 	bl	a194 <gatt_sub_find_free>
	if (!sub) {
    b7c8:	b118      	cbz	r0, b7d2 <bt_gatt_connected+0x76>
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, params, node) {
    b7ca:	6884      	ldr	r4, [r0, #8]
    b7cc:	b10c      	cbz	r4, b7d2 <bt_gatt_connected+0x76>
    b7ce:	3c10      	subs	r4, #16
    b7d0:	b91c      	cbnz	r4, b7da <bt_gatt_connected+0x7e>
}
    b7d2:	b00e      	add	sp, #56	; 0x38
    b7d4:	bd70      	pop	{r4, r5, r6, pc}
			bt_settings_encode_key(key, sizeof(key), "ccc",
    b7d6:	9200      	str	r2, [sp, #0]
    b7d8:	e7d6      	b.n	b788 <bt_gatt_connected+0x2c>
		if (bt_addr_le_is_bonded(conn->id, &conn->le.dst) &&
    b7da:	4631      	mov	r1, r6
    b7dc:	7a28      	ldrb	r0, [r5, #8]
    b7de:	f00f fe2e 	bl	1b43e <bt_addr_le_is_bonded>
    b7e2:	b158      	cbz	r0, b7fc <bt_gatt_connected+0xa0>
		    !atomic_test_bit(params->flags,
    b7e4:	2101      	movs	r1, #1
    b7e6:	f104 000c 	add.w	r0, r4, #12
    b7ea:	f010 fc1d 	bl	1c028 <atomic_test_bit>
		if (bt_addr_le_is_bonded(conn->id, &conn->le.dst) &&
    b7ee:	b928      	cbnz	r0, b7fc <bt_gatt_connected+0xa0>
			gatt_write_ccc(conn, params->ccc_handle, params->value,
    b7f0:	4623      	mov	r3, r4
    b7f2:	8922      	ldrh	r2, [r4, #8]
    b7f4:	88e1      	ldrh	r1, [r4, #6]
    b7f6:	4628      	mov	r0, r5
    b7f8:	f7fe fc98 	bl	a12c <gatt_write_ccc.constprop.33>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    b7fc:	6924      	ldr	r4, [r4, #16]
    b7fe:	e7e5      	b.n	b7cc <bt_gatt_connected+0x70>
    b800:	0002122d 	.word	0x0002122d
    b804:	0000aa41 	.word	0x0000aa41
    b808:	0000acbd 	.word	0x0000acbd

0000b80c <bt_gatt_encrypt_change>:
{
    b80c:	b507      	push	{r0, r1, r2, lr}
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
    b80e:	4a06      	ldr	r2, [pc, #24]	; (b828 <bt_gatt_encrypt_change+0x1c>)
	data.conn = conn;
    b810:	9000      	str	r0, [sp, #0]
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
    b812:	466b      	mov	r3, sp
	data.sec = BT_SECURITY_L1;
    b814:	2001      	movs	r0, #1
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
    b816:	f64f 71ff 	movw	r1, #65535	; 0xffff
	data.sec = BT_SECURITY_L1;
    b81a:	f88d 0004 	strb.w	r0, [sp, #4]
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
    b81e:	f010 fdf6 	bl	1c40e <bt_gatt_foreach_attr>
}
    b822:	b003      	add	sp, #12
    b824:	f85d fb04 	ldr.w	pc, [sp], #4
    b828:	0000acbd 	.word	0x0000acbd

0000b82c <db_hash_read>:
{
    b82c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b82e:	4604      	mov	r4, r0
	return k_ticks_to_ms_floor64(z_timeout_remaining(&work->timeout));
    b830:	4815      	ldr	r0, [pc, #84]	; (b888 <db_hash_read+0x5c>)
    b832:	f8bd 5018 	ldrh.w	r5, [sp, #24]
    b836:	461f      	mov	r7, r3
    b838:	4616      	mov	r6, r2
    b83a:	f00d f855 	bl	188e8 <z_timeout_remaining>
    b83e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    b842:	fb80 0103 	smull	r0, r1, r0, r3
    b846:	0bc3      	lsrs	r3, r0, #15
	if (k_delayed_work_remaining_get(&db_hash_work)) {
    b848:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
    b84c:	d005      	beq.n	b85a <db_hash_read+0x2e>
		k_delayed_work_cancel(&db_hash_work);
    b84e:	480f      	ldr	r0, [pc, #60]	; (b88c <db_hash_read+0x60>)
    b850:	f012 ff82 	bl	1e758 <k_delayed_work_cancel>
		db_hash_gen(true);
    b854:	2001      	movs	r0, #1
    b856:	f7ff f83b 	bl	a8d0 <db_hash_gen>
	bt_gatt_change_aware(conn, true);
    b85a:	2101      	movs	r1, #1
    b85c:	4620      	mov	r0, r4
    b85e:	f010 ff13 	bl	1c688 <bt_gatt_change_aware>
	if (offset > value_len) {
    b862:	2d10      	cmp	r5, #16
    b864:	d80c      	bhi.n	b880 <db_hash_read+0x54>
	len = MIN(buf_len, value_len - offset);
    b866:	f1c5 0410 	rsb	r4, r5, #16
    b86a:	42bc      	cmp	r4, r7
	memcpy(buf, (u8_t *)value + offset, len);
    b86c:	4908      	ldr	r1, [pc, #32]	; (b890 <db_hash_read+0x64>)
	len = MIN(buf_len, value_len - offset);
    b86e:	bfa8      	it	ge
    b870:	463c      	movge	r4, r7
	memcpy(buf, (u8_t *)value + offset, len);
    b872:	4622      	mov	r2, r4
    b874:	4429      	add	r1, r5
    b876:	4630      	mov	r0, r6
    b878:	f00f fbbf 	bl	1affa <memcpy>
}
    b87c:	4620      	mov	r0, r4
    b87e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
    b880:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, db_hash,
    b884:	e7fa      	b.n	b87c <db_hash_read+0x50>
    b886:	bf00      	nop
    b888:	2000044c 	.word	0x2000044c
    b88c:	20000440 	.word	0x20000440
    b890:	20001c55 	.word	0x20001c55

0000b894 <bt_gatt_store_ccc>:
{
    b894:	b570      	push	{r4, r5, r6, lr}
    b896:	b0c0      	sub	sp, #256	; 0x100
	save.count = 0;
    b898:	2300      	movs	r3, #0
{
    b89a:	4604      	mov	r4, r0
    b89c:	460d      	mov	r5, r1
	save.addr_with_id.addr = addr;
    b89e:	910d      	str	r1, [sp, #52]	; 0x34
	save.addr_with_id.id = id;
    b8a0:	f88d 0038 	strb.w	r0, [sp, #56]	; 0x38
	save.count = 0;
    b8a4:	933f      	str	r3, [sp, #252]	; 0xfc
	bt_gatt_foreach_attr(0x0001, 0xffff, ccc_save, &save);
    b8a6:	4a1a      	ldr	r2, [pc, #104]	; (b910 <bt_gatt_store_ccc+0x7c>)
    b8a8:	ab0d      	add	r3, sp, #52	; 0x34
    b8aa:	f64f 71ff 	movw	r1, #65535	; 0xffff
    b8ae:	2001      	movs	r0, #1
    b8b0:	f010 fdad 	bl	1c40e <bt_gatt_foreach_attr>
	if (id) {
    b8b4:	b33c      	cbz	r4, b906 <bt_gatt_store_ccc+0x72>
		u8_to_dec(id_str, sizeof(id_str), id);
    b8b6:	ae03      	add	r6, sp, #12
    b8b8:	4622      	mov	r2, r4
    b8ba:	2104      	movs	r1, #4
    b8bc:	4630      	mov	r0, r6
    b8be:	f00d f99a 	bl	18bf6 <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "ccc",
    b8c2:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "ccc",
    b8c4:	4a13      	ldr	r2, [pc, #76]	; (b914 <bt_gatt_store_ccc+0x80>)
    b8c6:	462b      	mov	r3, r5
    b8c8:	2124      	movs	r1, #36	; 0x24
    b8ca:	a804      	add	r0, sp, #16
    b8cc:	f7f9 fd58 	bl	5380 <bt_settings_encode_key>
	if (save.count) {
    b8d0:	9a3f      	ldr	r2, [sp, #252]	; 0xfc
    b8d2:	b1d2      	cbz	r2, b90a <bt_gatt_store_ccc+0x76>
		len = save.count * sizeof(*save.store);
    b8d4:	0092      	lsls	r2, r2, #2
		str = (char *)save.store;
    b8d6:	a90f      	add	r1, sp, #60	; 0x3c
	err = settings_save_one(key, str, len);
    b8d8:	a804      	add	r0, sp, #16
    b8da:	f7f8 f99f 	bl	3c1c <settings_save_one>
	if (err) {
    b8de:	4604      	mov	r4, r0
    b8e0:	b170      	cbz	r0, b900 <bt_gatt_store_ccc+0x6c>
		BT_ERR("Failed to store CCCs (err %d)", err);
    b8e2:	2301      	movs	r3, #1
    b8e4:	f04f 0200 	mov.w	r2, #0
    b8e8:	f363 0207 	bfi	r2, r3, #0, #8
    b8ec:	490a      	ldr	r1, [pc, #40]	; (b918 <bt_gatt_store_ccc+0x84>)
    b8ee:	4b0b      	ldr	r3, [pc, #44]	; (b91c <bt_gatt_store_ccc+0x88>)
    b8f0:	1a5b      	subs	r3, r3, r1
    b8f2:	08db      	lsrs	r3, r3, #3
    b8f4:	4601      	mov	r1, r0
    b8f6:	f363 128f 	bfi	r2, r3, #6, #10
    b8fa:	4809      	ldr	r0, [pc, #36]	; (b920 <bt_gatt_store_ccc+0x8c>)
    b8fc:	f00e fe96 	bl	1a62c <log_1>
}
    b900:	4620      	mov	r0, r4
    b902:	b040      	add	sp, #256	; 0x100
    b904:	bd70      	pop	{r4, r5, r6, pc}
		bt_settings_encode_key(key, sizeof(key), "ccc",
    b906:	9400      	str	r4, [sp, #0]
    b908:	e7dc      	b.n	b8c4 <bt_gatt_store_ccc+0x30>
		str = NULL;
    b90a:	4611      	mov	r1, r2
    b90c:	e7e4      	b.n	b8d8 <bt_gatt_store_ccc+0x44>
    b90e:	bf00      	nop
    b910:	00009f9d 	.word	0x00009f9d
    b914:	0002122d 	.word	0x0002122d
    b918:	0001ed28 	.word	0x0001ed28
    b91c:	0001ede0 	.word	0x0001ede0
    b920:	0002120c 	.word	0x0002120c

0000b924 <bt_gatt_disconnected>:
{
    b924:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    b928:	4604      	mov	r4, r0
    b92a:	b08c      	sub	sp, #48	; 0x30
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
    b92c:	4603      	mov	r3, r0
    b92e:	f64f 71ff 	movw	r1, #65535	; 0xffff
    b932:	2001      	movs	r0, #1
    b934:	4a49      	ldr	r2, [pc, #292]	; (ba5c <bt_gatt_disconnected+0x138>)
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    b936:	f104 0570 	add.w	r5, r4, #112	; 0x70
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
    b93a:	f010 fd68 	bl	1c40e <bt_gatt_foreach_attr>
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    b93e:	4629      	mov	r1, r5
    b940:	7a20      	ldrb	r0, [r4, #8]
    b942:	f00f fd7c 	bl	1b43e <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
    b946:	2800      	cmp	r0, #0
    b948:	d039      	beq.n	b9be <bt_gatt_disconnected+0x9a>
		bt_gatt_store_ccc(conn->id, &conn->le.dst);
    b94a:	4629      	mov	r1, r5
    b94c:	7a20      	ldrb	r0, [r4, #8]
    b94e:	f7ff ffa1 	bl	b894 <bt_gatt_store_ccc>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    b952:	4620      	mov	r0, r4
    b954:	f7fe fdbe 	bl	a4d4 <find_cf_cfg.part.10>
	if (!cfg) {
    b958:	4606      	mov	r6, r0
    b95a:	2800      	cmp	r0, #0
    b95c:	d054      	beq.n	ba08 <bt_gatt_disconnected+0xe4>
		if (conn->id) {
    b95e:	7a22      	ldrb	r2, [r4, #8]
		str = (char *)cfg->data;
    b960:	3608      	adds	r6, #8
		if (conn->id) {
    b962:	2a00      	cmp	r2, #0
    b964:	d052      	beq.n	ba0c <bt_gatt_disconnected+0xe8>
			u8_to_dec(id_str, sizeof(id_str), conn->id);
    b966:	af02      	add	r7, sp, #8
    b968:	2104      	movs	r1, #4
    b96a:	4638      	mov	r0, r7
    b96c:	f00d f943 	bl	18bf6 <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "cf",
    b970:	9700      	str	r7, [sp, #0]
    b972:	462b      	mov	r3, r5
    b974:	4a3a      	ldr	r2, [pc, #232]	; (ba60 <bt_gatt_disconnected+0x13c>)
    b976:	2124      	movs	r1, #36	; 0x24
    b978:	a803      	add	r0, sp, #12
    b97a:	f7f9 fd01 	bl	5380 <bt_settings_encode_key>
	if (!cfg || !conn->id) {
    b97e:	7a23      	ldrb	r3, [r4, #8]
    b980:	2701      	movs	r7, #1
    b982:	b93b      	cbnz	r3, b994 <bt_gatt_disconnected+0x70>
		bt_settings_encode_key(key, sizeof(key), "cf",
    b984:	2300      	movs	r3, #0
    b986:	9300      	str	r3, [sp, #0]
    b988:	4a35      	ldr	r2, [pc, #212]	; (ba60 <bt_gatt_disconnected+0x13c>)
    b98a:	462b      	mov	r3, r5
    b98c:	2124      	movs	r1, #36	; 0x24
    b98e:	a803      	add	r0, sp, #12
    b990:	f7f9 fcf6 	bl	5380 <bt_settings_encode_key>
	err = settings_save_one(key, str, len);
    b994:	4631      	mov	r1, r6
    b996:	463a      	mov	r2, r7
    b998:	a803      	add	r0, sp, #12
    b99a:	f7f8 f93f 	bl	3c1c <settings_save_one>
	if (err) {
    b99e:	4601      	mov	r1, r0
    b9a0:	b168      	cbz	r0, b9be <bt_gatt_disconnected+0x9a>
		BT_ERR("Failed to store Client Features (err %d)", err);
    b9a2:	2301      	movs	r3, #1
    b9a4:	f04f 0200 	mov.w	r2, #0
    b9a8:	f363 0207 	bfi	r2, r3, #0, #8
    b9ac:	482d      	ldr	r0, [pc, #180]	; (ba64 <bt_gatt_disconnected+0x140>)
    b9ae:	4b2e      	ldr	r3, [pc, #184]	; (ba68 <bt_gatt_disconnected+0x144>)
    b9b0:	1a1b      	subs	r3, r3, r0
    b9b2:	08db      	lsrs	r3, r3, #3
    b9b4:	f363 128f 	bfi	r2, r3, #6, #10
    b9b8:	482c      	ldr	r0, [pc, #176]	; (ba6c <bt_gatt_disconnected+0x148>)
    b9ba:	f00e fe37 	bl	1a62c <log_1>
	sub = gatt_sub_find(conn);
    b9be:	2100      	movs	r1, #0
    b9c0:	4620      	mov	r0, r4
    b9c2:	f7fe fbe7 	bl	a194 <gatt_sub_find_free>
	if (!sub) {
    b9c6:	4680      	mov	r8, r0
    b9c8:	b398      	cbz	r0, ba32 <bt_gatt_disconnected+0x10e>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
    b9ca:	6883      	ldr	r3, [r0, #8]
    b9cc:	b38b      	cbz	r3, ba32 <bt_gatt_disconnected+0x10e>
    b9ce:	f1b3 0710 	subs.w	r7, r3, #16
    b9d2:	d02e      	beq.n	ba32 <bt_gatt_disconnected+0x10e>
    b9d4:	681e      	ldr	r6, [r3, #0]
    b9d6:	b106      	cbz	r6, b9da <bt_gatt_disconnected+0xb6>
    b9d8:	3e10      	subs	r6, #16
	if (!cfg || !conn->id) {
    b9da:	f04f 0900 	mov.w	r9, #0
		    (atomic_test_bit(params->flags,
    b9de:	46ca      	mov	sl, r9
		if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst) ||
    b9e0:	4629      	mov	r1, r5
    b9e2:	7a20      	ldrb	r0, [r4, #8]
    b9e4:	f00f fd2b 	bl	1b43e <bt_addr_le_is_bonded>
    b9e8:	b990      	cbnz	r0, ba10 <bt_gatt_disconnected+0xec>
			params->value = 0U;
    b9ea:	f8a7 a008 	strh.w	sl, [r7, #8]
			gatt_sub_remove(conn, sub, prev, params);
    b9ee:	463b      	mov	r3, r7
    b9f0:	464a      	mov	r2, r9
    b9f2:	4641      	mov	r1, r8
    b9f4:	4620      	mov	r0, r4
    b9f6:	f010 fc75 	bl	1c2e4 <gatt_sub_remove>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
    b9fa:	b1d6      	cbz	r6, ba32 <bt_gatt_disconnected+0x10e>
    b9fc:	6933      	ldr	r3, [r6, #16]
    b9fe:	b103      	cbz	r3, ba02 <bt_gatt_disconnected+0xde>
    ba00:	3b10      	subs	r3, #16
	if (!cfg || !conn->id) {
    ba02:	4637      	mov	r7, r6
    ba04:	461e      	mov	r6, r3
    ba06:	e7eb      	b.n	b9e0 <bt_gatt_disconnected+0xbc>
		len = 0;
    ba08:	4607      	mov	r7, r0
    ba0a:	e7bb      	b.n	b984 <bt_gatt_disconnected+0x60>
		if (conn->id) {
    ba0c:	2701      	movs	r7, #1
    ba0e:	e7b9      	b.n	b984 <bt_gatt_disconnected+0x60>
		    (atomic_test_bit(params->flags,
    ba10:	2100      	movs	r1, #0
    ba12:	f107 000c 	add.w	r0, r7, #12
    ba16:	f010 fb07 	bl	1c028 <atomic_test_bit>
		if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst) ||
    ba1a:	2800      	cmp	r0, #0
    ba1c:	d1e5      	bne.n	b9ea <bt_gatt_disconnected+0xc6>
	if (sub->peer.type == BT_ADDR_LE_PUBLIC) {
    ba1e:	f898 3000 	ldrb.w	r3, [r8]
    ba22:	b11b      	cbz	r3, ba2c <bt_gatt_disconnected+0x108>
	bt_addr_le_copy(&sub->peer, &conn->le.dst);
    ba24:	4629      	mov	r1, r5
    ba26:	4640      	mov	r0, r8
    ba28:	f010 fa78 	bl	1bf1c <bt_addr_le_copy>
			prev = &params->node;
    ba2c:	f107 0910 	add.w	r9, r7, #16
    ba30:	e7e3      	b.n	b9fa <bt_gatt_disconnected+0xd6>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    ba32:	4620      	mov	r0, r4
    ba34:	f7fe fd4e 	bl	a4d4 <find_cf_cfg.part.10>
	if (!cfg) {
    ba38:	4606      	mov	r6, r0
    ba3a:	b138      	cbz	r0, ba4c <bt_gatt_disconnected+0x128>
	if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    ba3c:	4629      	mov	r1, r5
    ba3e:	7a20      	ldrb	r0, [r4, #8]
    ba40:	f00f fcfd 	bl	1b43e <bt_addr_le_is_bonded>
    ba44:	b928      	cbnz	r0, ba52 <bt_gatt_disconnected+0x12e>
		clear_cf_cfg(cfg);
    ba46:	4630      	mov	r0, r6
    ba48:	f010 fb2c 	bl	1c0a4 <clear_cf_cfg>
}
    ba4c:	b00c      	add	sp, #48	; 0x30
    ba4e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
    ba52:	4629      	mov	r1, r5
    ba54:	1c70      	adds	r0, r6, #1
    ba56:	f010 fa61 	bl	1bf1c <bt_addr_le_copy>
}
    ba5a:	e7f7      	b.n	ba4c <bt_gatt_disconnected+0x128>
    ba5c:	00009d05 	.word	0x00009d05
    ba60:	00021443 	.word	0x00021443
    ba64:	0001ed28 	.word	0x0001ed28
    ba68:	0001ede0 	.word	0x0001ede0
    ba6c:	000211b3 	.word	0x000211b3

0000ba70 <bt_gatt_clear>:
{
    ba70:	b570      	push	{r4, r5, r6, lr}
    ba72:	b08e      	sub	sp, #56	; 0x38
    ba74:	4605      	mov	r5, r0
    ba76:	460c      	mov	r4, r1
	struct addr_with_id addr_with_id = {
    ba78:	9103      	str	r1, [sp, #12]
    ba7a:	f88d 0010 	strb.w	r0, [sp, #16]
	if (id) {
    ba7e:	2800      	cmp	r0, #0
    ba80:	d049      	beq.n	bb16 <bt_gatt_clear+0xa6>
		u8_to_dec(id_str, sizeof(id_str), id);
    ba82:	ae02      	add	r6, sp, #8
    ba84:	4602      	mov	r2, r0
    ba86:	2104      	movs	r1, #4
    ba88:	4630      	mov	r0, r6
    ba8a:	f00d f8b4 	bl	18bf6 <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "ccc",
    ba8e:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "ccc",
    ba90:	4623      	mov	r3, r4
    ba92:	4a30      	ldr	r2, [pc, #192]	; (bb54 <bt_gatt_clear+0xe4>)
    ba94:	2124      	movs	r1, #36	; 0x24
    ba96:	a805      	add	r0, sp, #20
	bt_gatt_foreach_attr(0x0001, 0xffff, remove_peer_from_attr,
    ba98:	ae03      	add	r6, sp, #12
		bt_settings_encode_key(key, sizeof(key), "ccc",
    ba9a:	f7f9 fc71 	bl	5380 <bt_settings_encode_key>
	bt_gatt_foreach_attr(0x0001, 0xffff, remove_peer_from_attr,
    ba9e:	4633      	mov	r3, r6
    baa0:	4a2d      	ldr	r2, [pc, #180]	; (bb58 <bt_gatt_clear+0xe8>)
    baa2:	f64f 71ff 	movw	r1, #65535	; 0xffff
    baa6:	2001      	movs	r0, #1
    baa8:	f010 fcb1 	bl	1c40e <bt_gatt_foreach_attr>
	return settings_delete(key);
    baac:	a805      	add	r0, sp, #20
    baae:	f00e ffde 	bl	1aa6e <settings_delete>
	if (err < 0) {
    bab2:	2800      	cmp	r0, #0
    bab4:	db2d      	blt.n	bb12 <bt_gatt_clear+0xa2>
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    bab6:	4621      	mov	r1, r4
    bab8:	4628      	mov	r0, r5
    baba:	f7fe fb9f 	bl	a1fc <find_sc_cfg.part.11>
		if (cfg) {
    babe:	b108      	cbz	r0, bac4 <bt_gatt_clear+0x54>
			sc_clear(cfg);
    bac0:	f7fe f8e0 	bl	9c84 <sc_clear>
	if (id) {
    bac4:	b34d      	cbz	r5, bb1a <bt_gatt_clear+0xaa>
		u8_to_dec(id_str, sizeof(id_str), id);
    bac6:	462a      	mov	r2, r5
    bac8:	2104      	movs	r1, #4
    baca:	4630      	mov	r0, r6
    bacc:	f00d f893 	bl	18bf6 <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "cf",
    bad0:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "cf",
    bad2:	a805      	add	r0, sp, #20
    bad4:	4623      	mov	r3, r4
    bad6:	4a21      	ldr	r2, [pc, #132]	; (bb5c <bt_gatt_clear+0xec>)
    bad8:	2124      	movs	r1, #36	; 0x24
    bada:	f7f9 fc51 	bl	5380 <bt_settings_encode_key>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    bade:	4620      	mov	r0, r4
    bae0:	f7fe fa8c 	bl	9ffc <find_cf_cfg_by_addr.part.14>
	if (cfg) {
    bae4:	b108      	cbz	r0, baea <bt_gatt_clear+0x7a>
		clear_cf_cfg(cfg);
    bae6:	f010 fadd 	bl	1c0a4 <clear_cf_cfg>
	return settings_delete(key);
    baea:	a805      	add	r0, sp, #20
    baec:	f00e ffbf 	bl	1aa6e <settings_delete>
	if (err < 0) {
    baf0:	2800      	cmp	r0, #0
    baf2:	db0e      	blt.n	bb12 <bt_gatt_clear+0xa2>
    baf4:	2207      	movs	r2, #7
    baf6:	491a      	ldr	r1, [pc, #104]	; (bb60 <bt_gatt_clear+0xf0>)
    baf8:	4d19      	ldr	r5, [pc, #100]	; (bb60 <bt_gatt_clear+0xf0>)
    bafa:	4620      	mov	r0, r4
    bafc:	f00f fa6d 	bl	1afda <memcmp>
		if (!bt_addr_le_cmp(addr, &subscriptions[i].peer)) {
    bb00:	b170      	cbz	r0, bb20 <bt_gatt_clear+0xb0>
    bb02:	2207      	movs	r2, #7
    bb04:	f105 0110 	add.w	r1, r5, #16
    bb08:	4620      	mov	r0, r4
    bb0a:	f00f fa66 	bl	1afda <memcmp>
    bb0e:	b130      	cbz	r0, bb1e <bt_gatt_clear+0xae>
	return 0;
    bb10:	2000      	movs	r0, #0
}
    bb12:	b00e      	add	sp, #56	; 0x38
    bb14:	bd70      	pop	{r4, r5, r6, pc}
		bt_settings_encode_key(key, sizeof(key), "ccc",
    bb16:	9000      	str	r0, [sp, #0]
    bb18:	e7ba      	b.n	ba90 <bt_gatt_clear+0x20>
		bt_settings_encode_key(key, sizeof(key), "cf",
    bb1a:	9500      	str	r5, [sp, #0]
    bb1c:	e7d9      	b.n	bad2 <bt_gatt_clear+0x62>
	for (i = 0; i < ARRAY_SIZE(subscriptions); i++) {
    bb1e:	2001      	movs	r0, #1
			sub = &subscriptions[i];
    bb20:	eb05 1500 	add.w	r5, r5, r0, lsl #4
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
    bb24:	68aa      	ldr	r2, [r5, #8]
    bb26:	2a00      	cmp	r2, #0
    bb28:	d0f2      	beq.n	bb10 <bt_gatt_clear+0xa0>
    bb2a:	f1b2 0310 	subs.w	r3, r2, #16
    bb2e:	d0ef      	beq.n	bb10 <bt_gatt_clear+0xa0>
    bb30:	6814      	ldr	r4, [r2, #0]
    bb32:	b104      	cbz	r4, bb36 <bt_gatt_clear+0xc6>
    bb34:	3c10      	subs	r4, #16
		params->value = 0U;
    bb36:	2600      	movs	r6, #0
		gatt_sub_remove(NULL, sub, prev, params);
    bb38:	2200      	movs	r2, #0
		params->value = 0U;
    bb3a:	811e      	strh	r6, [r3, #8]
		gatt_sub_remove(NULL, sub, prev, params);
    bb3c:	4629      	mov	r1, r5
    bb3e:	4610      	mov	r0, r2
    bb40:	f010 fbd0 	bl	1c2e4 <gatt_sub_remove>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
    bb44:	2c00      	cmp	r4, #0
    bb46:	d0e3      	beq.n	bb10 <bt_gatt_clear+0xa0>
    bb48:	6922      	ldr	r2, [r4, #16]
    bb4a:	b102      	cbz	r2, bb4e <bt_gatt_clear+0xde>
    bb4c:	3a10      	subs	r2, #16
	for (i = 0; i < ARRAY_SIZE(subscriptions); i++) {
    bb4e:	4623      	mov	r3, r4
    bb50:	4614      	mov	r4, r2
    bb52:	e7f1      	b.n	bb38 <bt_gatt_clear+0xc8>
    bb54:	0002122d 	.word	0x0002122d
    bb58:	00009fd5 	.word	0x00009fd5
    bb5c:	00021443 	.word	0x00021443
    bb60:	200004b4 	.word	0x200004b4

0000bb64 <get_io_capa>:
static const u8_t *sc_public_key;
static K_SEM_DEFINE(sc_local_pkey_ready, 0, 1);

static u8_t get_io_capa(void)
{
	if (!bt_auth) {
    bb64:	4b10      	ldr	r3, [pc, #64]	; (bba8 <get_io_capa+0x44>)
    bb66:	681b      	ldr	r3, [r3, #0]
    bb68:	b1bb      	cbz	r3, bb9a <get_io_capa+0x36>
		goto no_callbacks;
	}

	/* Passkey Confirmation is valid only for LE SC */
	if (bt_auth->passkey_display && bt_auth->passkey_entry &&
    bb6a:	681a      	ldr	r2, [r3, #0]
    bb6c:	b142      	cbz	r2, bb80 <get_io_capa+0x1c>
    bb6e:	6859      	ldr	r1, [r3, #4]
    bb70:	b131      	cbz	r1, bb80 <get_io_capa+0x1c>
    bb72:	6899      	ldr	r1, [r3, #8]
    bb74:	b911      	cbnz	r1, bb7c <get_io_capa+0x18>
	    (bt_auth->passkey_confirm || !sc_supported)) {
    bb76:	490d      	ldr	r1, [pc, #52]	; (bbac <get_io_capa+0x48>)
    bb78:	7809      	ldrb	r1, [r1, #0]
    bb7a:	b939      	cbnz	r1, bb8c <get_io_capa+0x28>
		return BT_SMP_IO_KEYBOARD_DISPLAY;
    bb7c:	2004      	movs	r0, #4
    bb7e:	4770      	bx	lr
	}

	/* DisplayYesNo is useful only for LE SC */
	if (sc_supported && bt_auth->passkey_display &&
    bb80:	490a      	ldr	r1, [pc, #40]	; (bbac <get_io_capa+0x48>)
    bb82:	7809      	ldrb	r1, [r1, #0]
    bb84:	b111      	cbz	r1, bb8c <get_io_capa+0x28>
    bb86:	b10a      	cbz	r2, bb8c <get_io_capa+0x28>
    bb88:	6899      	ldr	r1, [r3, #8]
    bb8a:	b941      	cbnz	r1, bb9e <get_io_capa+0x3a>
	    bt_auth->passkey_confirm) {
		return BT_SMP_IO_DISPLAY_YESNO;
	}

	if (bt_auth->passkey_entry) {
    bb8c:	685b      	ldr	r3, [r3, #4]
    bb8e:	b943      	cbnz	r3, bba2 <get_io_capa+0x3e>
			return BT_SMP_IO_KEYBOARD_ONLY;
		}
	}

	if (bt_auth->passkey_display) {
		return BT_SMP_IO_DISPLAY_ONLY;
    bb90:	2a00      	cmp	r2, #0
    bb92:	bf0c      	ite	eq
    bb94:	2003      	moveq	r0, #3
    bb96:	2000      	movne	r0, #0
    bb98:	4770      	bx	lr
no_callbacks:
	if (IS_ENABLED(CONFIG_BT_FIXED_PASSKEY) &&
	    fixed_passkey != BT_PASSKEY_INVALID) {
		return BT_SMP_IO_DISPLAY_ONLY;
	} else {
		return BT_SMP_IO_NO_INPUT_OUTPUT;
    bb9a:	2003      	movs	r0, #3
    bb9c:	4770      	bx	lr
		return BT_SMP_IO_DISPLAY_YESNO;
    bb9e:	2001      	movs	r0, #1
    bba0:	4770      	bx	lr
			return BT_SMP_IO_KEYBOARD_ONLY;
    bba2:	2002      	movs	r0, #2
	}
}
    bba4:	4770      	bx	lr
    bba6:	bf00      	nop
    bba8:	2000029c 	.word	0x2000029c
    bbac:	20001c76 	.word	0x20001c76

0000bbb0 <smp_sign_buf>:
 * msg buffer contains message itself, 32 bit count and signature,
 * so total buffer size is len + 4 + 8 octets.
 * API is Little Endian to make it suitable for Bluetooth.
 */
static int smp_sign_buf(const u8_t *key, u8_t *msg, u16_t len)
{
    bbb0:	b5f0      	push	{r4, r5, r6, r7, lr}
	u8_t *m = msg;
	u32_t cnt = UNALIGNED_GET((u32_t *)&msg[len]);
    bbb2:	188f      	adds	r7, r1, r2
{
    bbb4:	b08b      	sub	sp, #44	; 0x2c
	int err;

	BT_DBG("Signing msg %s len %u key %s", bt_hex(msg, len), len,
	       bt_hex(key, 16));

	sys_mem_swap(m, len + sizeof(cnt));
    bbb6:	1d14      	adds	r4, r2, #4
{
    bbb8:	460d      	mov	r5, r1
	u32_t cnt = UNALIGNED_GET((u32_t *)&msg[len]);
    bbba:	683b      	ldr	r3, [r7, #0]
    bbbc:	9301      	str	r3, [sp, #4]
{
    bbbe:	4606      	mov	r6, r0
	sys_mem_swap(m, len + sizeof(cnt));
    bbc0:	4621      	mov	r1, r4
    bbc2:	4628      	mov	r0, r5
    bbc4:	f010 fd92 	bl	1c6ec <sys_mem_swap>
	sys_memcpy_swap(key_s, key, 16);
    bbc8:	4631      	mov	r1, r6
    bbca:	2210      	movs	r2, #16
    bbcc:	a802      	add	r0, sp, #8
    bbce:	f010 fd83 	bl	1c6d8 <sys_memcpy_swap>

	err = bt_smp_aes_cmac(key_s, m, len + sizeof(cnt), tmp);
    bbd2:	ab06      	add	r3, sp, #24
    bbd4:	4622      	mov	r2, r4
    bbd6:	4629      	mov	r1, r5
    bbd8:	a802      	add	r0, sp, #8
    bbda:	f010 fdae 	bl	1c73a <bt_smp_aes_cmac>
	if (err) {
    bbde:	4606      	mov	r6, r0
    bbe0:	b180      	cbz	r0, bc04 <smp_sign_buf+0x54>
		BT_ERR("Data signing failed");
    bbe2:	2301      	movs	r3, #1
    bbe4:	f04f 0100 	mov.w	r1, #0
    bbe8:	f363 0107 	bfi	r1, r3, #0, #8
    bbec:	4a0f      	ldr	r2, [pc, #60]	; (bc2c <smp_sign_buf+0x7c>)
    bbee:	4b10      	ldr	r3, [pc, #64]	; (bc30 <smp_sign_buf+0x80>)
    bbf0:	4810      	ldr	r0, [pc, #64]	; (bc34 <smp_sign_buf+0x84>)
    bbf2:	1a9b      	subs	r3, r3, r2
    bbf4:	08db      	lsrs	r3, r3, #3
    bbf6:	f363 118f 	bfi	r1, r3, #6, #10
    bbfa:	f00e fd0a 	bl	1a612 <log_0>
	memcpy(sig, tmp + 4, 12);

	BT_DBG("sig %s", bt_hex(sig, 12));

	return 0;
}
    bbfe:	4630      	mov	r0, r6
    bc00:	b00b      	add	sp, #44	; 0x2c
    bc02:	bdf0      	pop	{r4, r5, r6, r7, pc}
	sys_mem_swap(tmp, sizeof(tmp));
    bc04:	a806      	add	r0, sp, #24
    bc06:	2110      	movs	r1, #16
    bc08:	f010 fd70 	bl	1c6ec <sys_mem_swap>
	memcpy(tmp + 4, &cnt, sizeof(cnt));
    bc0c:	2204      	movs	r2, #4
    bc0e:	eb0d 0102 	add.w	r1, sp, r2
    bc12:	a807      	add	r0, sp, #28
    bc14:	f00f f9f1 	bl	1affa <memcpy>
	sys_mem_swap(m, len + sizeof(cnt));
    bc18:	4621      	mov	r1, r4
    bc1a:	4628      	mov	r0, r5
    bc1c:	f010 fd66 	bl	1c6ec <sys_mem_swap>
	memcpy(sig, tmp + 4, 12);
    bc20:	220c      	movs	r2, #12
    bc22:	a907      	add	r1, sp, #28
    bc24:	4638      	mov	r0, r7
    bc26:	f00f f9e8 	bl	1affa <memcpy>
	return 0;
    bc2a:	e7e8      	b.n	bbfe <smp_sign_buf+0x4e>
    bc2c:	0001ed28 	.word	0x0001ed28
    bc30:	0001ee18 	.word	0x0001ee18
    bc34:	000217f3 	.word	0x000217f3

0000bc38 <smp_ident_info>:
{
    bc38:	b570      	push	{r4, r5, r6, lr}
    bc3a:	460b      	mov	r3, r1
    bc3c:	4604      	mov	r4, r0
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    bc3e:	210c      	movs	r1, #12
    bc40:	3094      	adds	r0, #148	; 0x94
    bc42:	f010 fd71 	bl	1c728 <atomic_test_bit>
    bc46:	b328      	cbz	r0, bc94 <smp_ident_info+0x5c>
		struct bt_smp_ident_info *req = (void *)buf->data;
    bc48:	689e      	ldr	r6, [r3, #8]
		struct bt_conn *conn = smp->chan.chan.conn;
    bc4a:	6823      	ldr	r3, [r4, #0]
		keys = bt_keys_get_type(BT_KEYS_IRK, conn->id, &conn->le.dst);
    bc4c:	f103 0570 	add.w	r5, r3, #112	; 0x70
    bc50:	462a      	mov	r2, r5
    bc52:	7a19      	ldrb	r1, [r3, #8]
    bc54:	2002      	movs	r0, #2
    bc56:	f011 f8d1 	bl	1cdfc <bt_keys_get_type>
		if (!keys) {
    bc5a:	b9b0      	cbnz	r0, bc8a <smp_ident_info+0x52>
			BT_ERR("Unable to get keys for %s",
    bc5c:	2301      	movs	r3, #1
    bc5e:	f04f 0400 	mov.w	r4, #0
    bc62:	4a10      	ldr	r2, [pc, #64]	; (bca4 <smp_ident_info+0x6c>)
    bc64:	f363 0407 	bfi	r4, r3, #0, #8
    bc68:	4b0f      	ldr	r3, [pc, #60]	; (bca8 <smp_ident_info+0x70>)
    bc6a:	1a9b      	subs	r3, r3, r2
    bc6c:	08db      	lsrs	r3, r3, #3
    bc6e:	4628      	mov	r0, r5
    bc70:	f363 148f 	bfi	r4, r3, #6, #10
    bc74:	f7f9 f8a2 	bl	4dbc <bt_addr_le_str_real>
    bc78:	f7f7 f904 	bl	2e84 <log_strdup>
    bc7c:	4622      	mov	r2, r4
    bc7e:	4601      	mov	r1, r0
    bc80:	480a      	ldr	r0, [pc, #40]	; (bcac <smp_ident_info+0x74>)
    bc82:	f00e fcd3 	bl	1a62c <log_1>
			return BT_SMP_ERR_UNSPECIFIED;
    bc86:	2008      	movs	r0, #8
}
    bc88:	bd70      	pop	{r4, r5, r6, pc}
		memcpy(keys->irk.val, req->irk, 16);
    bc8a:	2210      	movs	r2, #16
    bc8c:	4631      	mov	r1, r6
    bc8e:	3026      	adds	r0, #38	; 0x26
    bc90:	f00f f9b3 	bl	1affa <memcpy>
	atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_IDENT_ADDR_INFO);
    bc94:	f104 0090 	add.w	r0, r4, #144	; 0x90
    bc98:	2109      	movs	r1, #9
    bc9a:	f010 fd36 	bl	1c70a <atomic_set_bit>
	return 0;
    bc9e:	2000      	movs	r0, #0
    bca0:	e7f2      	b.n	bc88 <smp_ident_info+0x50>
    bca2:	bf00      	nop
    bca4:	0001ed28 	.word	0x0001ed28
    bca8:	0001ee18 	.word	0x0001ee18
    bcac:	00021763 	.word	0x00021763

0000bcb0 <smp_encrypt_info>:
{
    bcb0:	b570      	push	{r4, r5, r6, lr}
    bcb2:	460b      	mov	r3, r1
    bcb4:	4604      	mov	r4, r0
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    bcb6:	210c      	movs	r1, #12
    bcb8:	3094      	adds	r0, #148	; 0x94
    bcba:	f010 fd35 	bl	1c728 <atomic_test_bit>
    bcbe:	b328      	cbz	r0, bd0c <smp_encrypt_info+0x5c>
		struct bt_smp_encrypt_info *req = (void *)buf->data;
    bcc0:	689e      	ldr	r6, [r3, #8]
		struct bt_conn *conn = smp->chan.chan.conn;
    bcc2:	6823      	ldr	r3, [r4, #0]
		keys = bt_keys_get_type(BT_KEYS_LTK, conn->id, &conn->le.dst);
    bcc4:	f103 0570 	add.w	r5, r3, #112	; 0x70
    bcc8:	462a      	mov	r2, r5
    bcca:	7a19      	ldrb	r1, [r3, #8]
    bccc:	2004      	movs	r0, #4
    bcce:	f011 f895 	bl	1cdfc <bt_keys_get_type>
		if (!keys) {
    bcd2:	b9b0      	cbnz	r0, bd02 <smp_encrypt_info+0x52>
			BT_ERR("Unable to get keys for %s",
    bcd4:	2301      	movs	r3, #1
    bcd6:	f04f 0400 	mov.w	r4, #0
    bcda:	4a10      	ldr	r2, [pc, #64]	; (bd1c <smp_encrypt_info+0x6c>)
    bcdc:	f363 0407 	bfi	r4, r3, #0, #8
    bce0:	4b0f      	ldr	r3, [pc, #60]	; (bd20 <smp_encrypt_info+0x70>)
    bce2:	1a9b      	subs	r3, r3, r2
    bce4:	08db      	lsrs	r3, r3, #3
    bce6:	4628      	mov	r0, r5
    bce8:	f363 148f 	bfi	r4, r3, #6, #10
    bcec:	f7f9 f866 	bl	4dbc <bt_addr_le_str_real>
    bcf0:	f7f7 f8c8 	bl	2e84 <log_strdup>
    bcf4:	4622      	mov	r2, r4
    bcf6:	4601      	mov	r1, r0
    bcf8:	480a      	ldr	r0, [pc, #40]	; (bd24 <smp_encrypt_info+0x74>)
    bcfa:	f00e fc97 	bl	1a62c <log_1>
			return BT_SMP_ERR_UNSPECIFIED;
    bcfe:	2008      	movs	r0, #8
}
    bd00:	bd70      	pop	{r4, r5, r6, pc}
		memcpy(keys->ltk.val, req->ltk, 16);
    bd02:	2210      	movs	r2, #16
    bd04:	4631      	mov	r1, r6
    bd06:	3016      	adds	r0, #22
    bd08:	f00f f977 	bl	1affa <memcpy>
	atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_MASTER_IDENT);
    bd0c:	f104 0090 	add.w	r0, r4, #144	; 0x90
    bd10:	2107      	movs	r1, #7
    bd12:	f010 fcfa 	bl	1c70a <atomic_set_bit>
	return 0;
    bd16:	2000      	movs	r0, #0
    bd18:	e7f2      	b.n	bd00 <smp_encrypt_info+0x50>
    bd1a:	bf00      	nop
    bd1c:	0001ed28 	.word	0x0001ed28
    bd20:	0001ee18 	.word	0x0001ee18
    bd24:	00021763 	.word	0x00021763

0000bd28 <get_auth.isra.0>:
	if (sc_supported) {
    bd28:	4b0c      	ldr	r3, [pc, #48]	; (bd5c <get_auth.isra.0+0x34>)
    bd2a:	781b      	ldrb	r3, [r3, #0]
static u8_t get_auth(struct bt_conn *conn, u8_t auth)
    bd2c:	b510      	push	{r4, lr}
	if (sc_supported) {
    bd2e:	b17b      	cbz	r3, bd50 <get_auth.isra.0+0x28>
		auth &= BT_SMP_AUTH_MASK_SC;
    bd30:	f000 040f 	and.w	r4, r0, #15
	if ((get_io_capa() == BT_SMP_IO_NO_INPUT_OUTPUT) ||
    bd34:	f7ff ff16 	bl	bb64 <get_io_capa>
	if (bondable) {
    bd38:	4b09      	ldr	r3, [pc, #36]	; (bd60 <get_auth.isra.0+0x38>)
    bd3a:	781b      	ldrb	r3, [r3, #0]
	if ((get_io_capa() == BT_SMP_IO_NO_INPUT_OUTPUT) ||
    bd3c:	2803      	cmp	r0, #3
		auth &= ~(BT_SMP_AUTH_MITM);
    bd3e:	bf0c      	ite	eq
    bd40:	f004 040b 	andeq.w	r4, r4, #11
		auth |= BT_SMP_AUTH_MITM;
    bd44:	f044 0404 	orrne.w	r4, r4, #4
	if (bondable) {
    bd48:	b12b      	cbz	r3, bd56 <get_auth.isra.0+0x2e>
		auth |= BT_SMP_AUTH_BONDING;
    bd4a:	f044 0001 	orr.w	r0, r4, #1
}
    bd4e:	bd10      	pop	{r4, pc}
		auth &= BT_SMP_AUTH_MASK;
    bd50:	f000 0407 	and.w	r4, r0, #7
    bd54:	e7ee      	b.n	bd34 <get_auth.isra.0+0xc>
		auth &= ~BT_SMP_AUTH_BONDING;
    bd56:	f004 00fe 	and.w	r0, r4, #254	; 0xfe
    bd5a:	e7f8      	b.n	bd4e <get_auth.isra.0+0x26>
    bd5c:	20001c76 	.word	0x20001c76
    bd60:	20005b0a 	.word	0x20005b0a

0000bd64 <smp_chan_get>:
{
    bd64:	b510      	push	{r4, lr}
	chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_SMP);
    bd66:	2106      	movs	r1, #6
    bd68:	f00f fd17 	bl	1b79a <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
    bd6c:	4604      	mov	r4, r0
    bd6e:	b968      	cbnz	r0, bd8c <smp_chan_get+0x28>
		BT_ERR("Unable to find SMP channel");
    bd70:	2301      	movs	r3, #1
    bd72:	f04f 0100 	mov.w	r1, #0
    bd76:	f363 0107 	bfi	r1, r3, #0, #8
    bd7a:	4a05      	ldr	r2, [pc, #20]	; (bd90 <smp_chan_get+0x2c>)
    bd7c:	4b05      	ldr	r3, [pc, #20]	; (bd94 <smp_chan_get+0x30>)
    bd7e:	4806      	ldr	r0, [pc, #24]	; (bd98 <smp_chan_get+0x34>)
    bd80:	1a9b      	subs	r3, r3, r2
    bd82:	08db      	lsrs	r3, r3, #3
    bd84:	f363 118f 	bfi	r1, r3, #6, #10
    bd88:	f00e fc43 	bl	1a612 <log_0>
}
    bd8c:	4620      	mov	r0, r4
    bd8e:	bd10      	pop	{r4, pc}
    bd90:	0001ed28 	.word	0x0001ed28
    bd94:	0001ee18 	.word	0x0001ee18
    bd98:	00021734 	.word	0x00021734

0000bd9c <bt_smp_accept>:
	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
		struct bt_smp *smp = &bt_smp_pool[i];

		if (smp->chan.chan.conn) {
    bd9c:	4a0d      	ldr	r2, [pc, #52]	; (bdd4 <bt_smp_accept+0x38>)
{
    bd9e:	b508      	push	{r3, lr}
		if (smp->chan.chan.conn) {
    bda0:	6813      	ldr	r3, [r2, #0]
    bda2:	b923      	cbnz	r3, bdae <bt_smp_accept+0x12>
			continue;
		}

		smp->chan.chan.ops = &ops;
    bda4:	480c      	ldr	r0, [pc, #48]	; (bdd8 <bt_smp_accept+0x3c>)
    bda6:	6050      	str	r0, [r2, #4]

		*chan = &smp->chan.chan;
    bda8:	600a      	str	r2, [r1, #0]

		return 0;
    bdaa:	4618      	mov	r0, r3
	}

	BT_ERR("No available SMP context for conn %p", conn);

	return -ENOMEM;
}
    bdac:	bd08      	pop	{r3, pc}
	BT_ERR("No available SMP context for conn %p", conn);
    bdae:	2301      	movs	r3, #1
    bdb0:	f04f 0200 	mov.w	r2, #0
    bdb4:	f363 0207 	bfi	r2, r3, #0, #8
    bdb8:	4908      	ldr	r1, [pc, #32]	; (bddc <bt_smp_accept+0x40>)
    bdba:	4b09      	ldr	r3, [pc, #36]	; (bde0 <bt_smp_accept+0x44>)
    bdbc:	1a5b      	subs	r3, r3, r1
    bdbe:	08db      	lsrs	r3, r3, #3
    bdc0:	4601      	mov	r1, r0
    bdc2:	f363 128f 	bfi	r2, r3, #6, #10
    bdc6:	4807      	ldr	r0, [pc, #28]	; (bde4 <bt_smp_accept+0x48>)
    bdc8:	f00e fc30 	bl	1a62c <log_1>
	return -ENOMEM;
    bdcc:	f06f 000b 	mvn.w	r0, #11
    bdd0:	e7ec      	b.n	bdac <bt_smp_accept+0x10>
    bdd2:	bf00      	nop
    bdd4:	200004d4 	.word	0x200004d4
    bdd8:	0001f6c8 	.word	0x0001f6c8
    bddc:	0001ed28 	.word	0x0001ed28
    bde0:	0001ee18 	.word	0x0001ee18
    bde4:	00021493 	.word	0x00021493

0000bde8 <smp_init>:
{
    bde8:	b538      	push	{r3, r4, r5, lr}
	(void)memset((u8_t *)smp + sizeof(smp->chan), 0,
    bdea:	f100 0590 	add.w	r5, r0, #144	; 0x90
{
    bdee:	4604      	mov	r4, r0
	(void)memset((u8_t *)smp + sizeof(smp->chan), 0,
    bdf0:	22ec      	movs	r2, #236	; 0xec
    bdf2:	2100      	movs	r1, #0
    bdf4:	4628      	mov	r0, r5
    bdf6:	f00f f92a 	bl	1b04e <memset>
	if (bt_rand(smp->prnd, 16)) {
    bdfa:	f104 00b7 	add.w	r0, r4, #183	; 0xb7
    bdfe:	2110      	movs	r1, #16
    be00:	f003 fe2e 	bl	fa60 <bt_rand>
    be04:	4604      	mov	r4, r0
    be06:	b948      	cbnz	r0, be1c <smp_init+0x34>
	atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_FAIL);
    be08:	2105      	movs	r1, #5
    be0a:	4628      	mov	r0, r5
    be0c:	f010 fc7d 	bl	1c70a <atomic_set_bit>
	sc_public_key = bt_pub_key_get();
    be10:	f7fb fe74 	bl	7afc <bt_pub_key_get>
    be14:	4b02      	ldr	r3, [pc, #8]	; (be20 <smp_init+0x38>)
    be16:	6018      	str	r0, [r3, #0]
}
    be18:	4620      	mov	r0, r4
    be1a:	bd38      	pop	{r3, r4, r5, pc}
		return BT_SMP_ERR_UNSPECIFIED;
    be1c:	2408      	movs	r4, #8
    be1e:	e7fb      	b.n	be18 <smp_init+0x30>
    be20:	20000670 	.word	0x20000670

0000be24 <smp_send.isra.7>:
static void smp_send(struct bt_smp *smp, struct net_buf *buf,
    be24:	b513      	push	{r0, r1, r4, lr}
	bt_l2cap_send_cb(smp->chan.chan.conn, BT_L2CAP_CID_SMP, buf, cb, NULL);
    be26:	2300      	movs	r3, #0
    be28:	9300      	str	r3, [sp, #0]
static void smp_send(struct bt_smp *smp, struct net_buf *buf,
    be2a:	4604      	mov	r4, r0
	bt_l2cap_send_cb(smp->chan.chan.conn, BT_L2CAP_CID_SMP, buf, cb, NULL);
    be2c:	4613      	mov	r3, r2
    be2e:	6800      	ldr	r0, [r0, #0]
    be30:	460a      	mov	r2, r1
    be32:	2106      	movs	r1, #6
    be34:	f00f fc8d 	bl	1b752 <bt_l2cap_send_cb>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    be38:	4804      	ldr	r0, [pc, #16]	; (be4c <smp_send.isra.7+0x28>)
    be3a:	f247 5230 	movw	r2, #30000	; 0x7530
    be3e:	f504 71be 	add.w	r1, r4, #380	; 0x17c
}
    be42:	b002      	add	sp, #8
    be44:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    be48:	f00c bc8e 	b.w	18768 <k_delayed_work_submit_to_queue>
    be4c:	20001a60 	.word	0x20001a60

0000be50 <smp_send_pairing_confirm>:
{
    be50:	b573      	push	{r0, r1, r4, r5, r6, lr}
	switch (smp->method) {
    be52:	f890 3098 	ldrb.w	r3, [r0, #152]	; 0x98
{
    be56:	4605      	mov	r5, r0
	switch (smp->method) {
    be58:	2b03      	cmp	r3, #3
    be5a:	d826      	bhi.n	beaa <smp_send_pairing_confirm+0x5a>
    be5c:	e8df f003 	tbb	[pc, r3]
    be60:	27020227 	.word	0x27020227
		r = (smp->passkey >> smp->passkey_round) & 0x01;
    be64:	f890 316c 	ldrb.w	r3, [r0, #364]	; 0x16c
    be68:	f8d0 4168 	ldr.w	r4, [r0, #360]	; 0x168
    be6c:	40dc      	lsrs	r4, r3
    be6e:	f004 0401 	and.w	r4, r4, #1
		r |= 0x80;
    be72:	f064 047f 	orn	r4, r4, #127	; 0x7f
    be76:	b2e4      	uxtb	r4, r4
	buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_CONFIRM, sizeof(*req));
    be78:	2103      	movs	r1, #3
    be7a:	4628      	mov	r0, r5
    be7c:	f010 fd14 	bl	1c8a8 <smp_create_pdu.isra.6>
	if (!buf) {
    be80:	4606      	mov	r6, r0
    be82:	b190      	cbz	r0, beaa <smp_send_pairing_confirm+0x5a>
	req = net_buf_add(buf, sizeof(*req));
    be84:	2110      	movs	r1, #16
    be86:	3008      	adds	r0, #8
    be88:	f011 fee0 	bl	1dc4c <net_buf_simple_add>
	if (smp_f4(sc_public_key, smp->pkey, smp->prnd, r, req->val)) {
    be8c:	9000      	str	r0, [sp, #0]
    be8e:	480f      	ldr	r0, [pc, #60]	; (becc <smp_send_pairing_confirm+0x7c>)
    be90:	4623      	mov	r3, r4
    be92:	f105 02b7 	add.w	r2, r5, #183	; 0xb7
    be96:	f105 01e7 	add.w	r1, r5, #231	; 0xe7
    be9a:	6800      	ldr	r0, [r0, #0]
    be9c:	f010 fc69 	bl	1c772 <smp_f4>
    bea0:	4604      	mov	r4, r0
    bea2:	b130      	cbz	r0, beb2 <smp_send_pairing_confirm+0x62>
		net_buf_unref(buf);
    bea4:	4630      	mov	r0, r6
    bea6:	f00a fb3b 	bl	16520 <net_buf_unref>
		return BT_SMP_ERR_UNSPECIFIED;
    beaa:	2008      	movs	r0, #8
    beac:	e00c      	b.n	bec8 <smp_send_pairing_confirm+0x78>
		r = 0U;
    beae:	2400      	movs	r4, #0
    beb0:	e7e2      	b.n	be78 <smp_send_pairing_confirm+0x28>
	smp_send(smp, buf, NULL, NULL);
    beb2:	4602      	mov	r2, r0
    beb4:	4631      	mov	r1, r6
    beb6:	4628      	mov	r0, r5
    beb8:	f7ff ffb4 	bl	be24 <smp_send.isra.7>
	atomic_clear_bit(smp->flags, SMP_FLAG_CFM_DELAYED);
    bebc:	f105 0094 	add.w	r0, r5, #148	; 0x94
    bec0:	4621      	mov	r1, r4
    bec2:	f010 fcc7 	bl	1c854 <atomic_clear_bit>
	return 0;
    bec6:	4620      	mov	r0, r4
}
    bec8:	b002      	add	sp, #8
    beca:	bd70      	pop	{r4, r5, r6, pc}
    becc:	20000670 	.word	0x20000670

0000bed0 <smp_public_key_slave.part.13>:
static u8_t smp_public_key_slave(struct bt_smp *smp)
    bed0:	b538      	push	{r3, r4, r5, lr}
	switch (smp->method) {
    bed2:	f890 3098 	ldrb.w	r3, [r0, #152]	; 0x98
static u8_t smp_public_key_slave(struct bt_smp *smp)
    bed6:	4604      	mov	r4, r0
	switch (smp->method) {
    bed8:	2b05      	cmp	r3, #5
    beda:	d814      	bhi.n	bf06 <smp_public_key_slave.part.13+0x36>
    bedc:	e8df f003 	tbb	[pc, r3]
    bee0:	030d3603 	.word	0x030d3603
    bee4:	5313      	.short	0x5313
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
    bee6:	3090      	adds	r0, #144	; 0x90
    bee8:	2104      	movs	r1, #4
    beea:	f010 fc0e 	bl	1c70a <atomic_set_bit>
		err = smp_send_pairing_confirm(smp);
    beee:	4620      	mov	r0, r4
    bef0:	f7ff ffae 	bl	be50 <smp_send_pairing_confirm>
		if (err) {
    bef4:	2800      	cmp	r0, #0
    bef6:	d037      	beq.n	bf68 <smp_public_key_slave.part.13+0x98>
}
    bef8:	bd38      	pop	{r3, r4, r5, pc}
		if (bt_rand(&smp->passkey, sizeof(smp->passkey))) {
    befa:	2104      	movs	r1, #4
    befc:	f500 70b4 	add.w	r0, r0, #360	; 0x168
    bf00:	f003 fdae 	bl	fa60 <bt_rand>
    bf04:	b108      	cbz	r0, bf0a <smp_public_key_slave.part.13+0x3a>
		return BT_SMP_ERR_UNSPECIFIED;
    bf06:	2008      	movs	r0, #8
    bf08:	e7f6      	b.n	bef8 <smp_public_key_slave.part.13+0x28>
		smp->passkey %= 1000000;
    bf0a:	f8d4 1168 	ldr.w	r1, [r4, #360]	; 0x168
    bf0e:	4a1f      	ldr	r2, [pc, #124]	; (bf8c <smp_public_key_slave.part.13+0xbc>)
	if (bt_auth && bt_auth->passkey_display) {
    bf10:	4d1f      	ldr	r5, [pc, #124]	; (bf90 <smp_public_key_slave.part.13+0xc0>)
		smp->passkey %= 1000000;
    bf12:	fbb1 f3f2 	udiv	r3, r1, r2
    bf16:	fb02 1313 	mls	r3, r2, r3, r1
    bf1a:	f8c4 3168 	str.w	r3, [r4, #360]	; 0x168
	if (bt_auth && bt_auth->passkey_display) {
    bf1e:	682b      	ldr	r3, [r5, #0]
	smp->passkey_round = 0U;
    bf20:	f884 016c 	strb.w	r0, [r4, #364]	; 0x16c
	if (bt_auth && bt_auth->passkey_display) {
    bf24:	b163      	cbz	r3, bf40 <smp_public_key_slave.part.13+0x70>
    bf26:	681b      	ldr	r3, [r3, #0]
    bf28:	b153      	cbz	r3, bf40 <smp_public_key_slave.part.13+0x70>
		atomic_set_bit(smp->flags, SMP_FLAG_DISPLAY);
    bf2a:	210a      	movs	r1, #10
    bf2c:	f104 0094 	add.w	r0, r4, #148	; 0x94
    bf30:	f010 fbeb 	bl	1c70a <atomic_set_bit>
		bt_auth->passkey_display(smp->chan.chan.conn, smp->passkey);
    bf34:	682b      	ldr	r3, [r5, #0]
    bf36:	f8d4 1168 	ldr.w	r1, [r4, #360]	; 0x168
    bf3a:	681b      	ldr	r3, [r3, #0]
    bf3c:	6820      	ldr	r0, [r4, #0]
    bf3e:	4798      	blx	r3
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
    bf40:	2103      	movs	r1, #3
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
    bf42:	f104 0090 	add.w	r0, r4, #144	; 0x90
    bf46:	f010 fbe0 	bl	1c70a <atomic_set_bit>
		break;
    bf4a:	e00d      	b.n	bf68 <smp_public_key_slave.part.13+0x98>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
    bf4c:	2103      	movs	r1, #3
    bf4e:	3090      	adds	r0, #144	; 0x90
    bf50:	f010 fbdb 	bl	1c70a <atomic_set_bit>
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
    bf54:	f104 0094 	add.w	r0, r4, #148	; 0x94
    bf58:	2109      	movs	r1, #9
    bf5a:	f010 fbd6 	bl	1c70a <atomic_set_bit>
		bt_auth->passkey_entry(smp->chan.chan.conn);
    bf5e:	4b0c      	ldr	r3, [pc, #48]	; (bf90 <smp_public_key_slave.part.13+0xc0>)
    bf60:	6820      	ldr	r0, [r4, #0]
    bf62:	681b      	ldr	r3, [r3, #0]
    bf64:	685b      	ldr	r3, [r3, #4]
    bf66:	4798      	blx	r3
	if (bt_dh_key_gen(smp->pkey, bt_smp_dhkey_ready)) {
    bf68:	490a      	ldr	r1, [pc, #40]	; (bf94 <smp_public_key_slave.part.13+0xc4>)
    bf6a:	f104 00e7 	add.w	r0, r4, #231	; 0xe7
    bf6e:	f7fb fdd3 	bl	7b18 <bt_dh_key_gen>
    bf72:	4605      	mov	r5, r0
    bf74:	2800      	cmp	r0, #0
    bf76:	d1c6      	bne.n	bf06 <smp_public_key_slave.part.13+0x36>
	atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_PENDING);
    bf78:	f104 0094 	add.w	r0, r4, #148	; 0x94
    bf7c:	2107      	movs	r1, #7
    bf7e:	f010 fbc4 	bl	1c70a <atomic_set_bit>
	return 0;
    bf82:	4628      	mov	r0, r5
    bf84:	e7b8      	b.n	bef8 <smp_public_key_slave.part.13+0x28>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
    bf86:	2104      	movs	r1, #4
    bf88:	e7db      	b.n	bf42 <smp_public_key_slave.part.13+0x72>
    bf8a:	bf00      	nop
    bf8c:	000f4240 	.word	0x000f4240
    bf90:	2000029c 	.word	0x2000029c
    bf94:	0000c675 	.word	0x0000c675

0000bf98 <compute_and_check_and_send_slave_dhcheck>:
{
    bf98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	(void)memset(r, 0, sizeof(r));
    bf9c:	2210      	movs	r2, #16
{
    bf9e:	b0a3      	sub	sp, #140	; 0x8c
    bfa0:	4604      	mov	r4, r0
	(void)memset(r, 0, sizeof(r));
    bfa2:	2100      	movs	r1, #0
    bfa4:	eb0d 0002 	add.w	r0, sp, r2
    bfa8:	f00f f851 	bl	1b04e <memset>
	switch (smp->method) {
    bfac:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
    bfb0:	2b05      	cmp	r3, #5
    bfb2:	f200 8083 	bhi.w	c0bc <compute_and_check_and_send_slave_dhcheck+0x124>
    bfb6:	e8df f003 	tbb	[pc, r3]
    bfba:	0309      	.short	0x0309
    bfbc:	83810903 	.word	0x83810903
		memcpy(r, &smp->passkey, sizeof(smp->passkey));
    bfc0:	2204      	movs	r2, #4
    bfc2:	f504 71b4 	add.w	r1, r4, #360	; 0x168
    bfc6:	a804      	add	r0, sp, #16
			memcpy(r, smp->oobd_remote->r, sizeof(r));
    bfc8:	f00f f817 	bl	1affa <memcpy>
	u8_t m[53] = { 0x00, /* counter */
    bfcc:	ae14      	add	r6, sp, #80	; 0x50
    bfce:	2235      	movs	r2, #53	; 0x35
    bfd0:	2100      	movs	r1, #0
    bfd2:	4630      	mov	r0, r6
		   &smp->chan.chan.conn->le.init_addr,
    bfd4:	f8d4 a000 	ldr.w	sl, [r4]
	u8_t m[53] = { 0x00, /* counter */
    bfd8:	f00f f839 	bl	1b04e <memset>
    bfdc:	2362      	movs	r3, #98	; 0x62
    bfde:	f88d 3051 	strb.w	r3, [sp, #81]	; 0x51
	sys_memcpy_swap(ws, w, 32);
    bfe2:	ad0c      	add	r5, sp, #48	; 0x30
	u8_t m[53] = { 0x00, /* counter */
    bfe4:	f646 4374 	movw	r3, #27764	; 0x6c74
    bfe8:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
	sys_memcpy_swap(ws, w, 32);
    bfec:	2220      	movs	r2, #32
	u8_t m[53] = { 0x00, /* counter */
    bfee:	2365      	movs	r3, #101	; 0x65
	sys_memcpy_swap(ws, w, 32);
    bff0:	f204 1127 	addw	r1, r4, #295	; 0x127
    bff4:	4628      	mov	r0, r5
	u8_t m[53] = { 0x00, /* counter */
    bff6:	f04f 0b01 	mov.w	fp, #1
    bffa:	f88d 3054 	strb.w	r3, [sp, #84]	; 0x54
    bffe:	f88d b083 	strb.w	fp, [sp, #131]	; 0x83
	sys_memcpy_swap(ws, w, 32);
    c002:	f010 fb69 	bl	1c6d8 <sys_memcpy_swap>
	err = bt_smp_aes_cmac(salt, ws, 32, t);
    c006:	ab08      	add	r3, sp, #32
    c008:	2220      	movs	r2, #32
    c00a:	4629      	mov	r1, r5
    c00c:	4855      	ldr	r0, [pc, #340]	; (c164 <compute_and_check_and_send_slave_dhcheck+0x1cc>)
    c00e:	f010 fb94 	bl	1c73a <bt_smp_aes_cmac>
	if (err) {
    c012:	2800      	cmp	r0, #0
    c014:	d152      	bne.n	c0bc <compute_and_check_and_send_slave_dhcheck+0x124>
	if (smp_f5(smp->dhkey, smp->rrnd, smp->prnd,
    c016:	f104 08c7 	add.w	r8, r4, #199	; 0xc7
	sys_memcpy_swap(m + 5, n1, 16);
    c01a:	2210      	movs	r2, #16
    c01c:	4641      	mov	r1, r8
    c01e:	f10d 0055 	add.w	r0, sp, #85	; 0x55
	if (smp_f5(smp->dhkey, smp->rrnd, smp->prnd,
    c022:	f104 09b7 	add.w	r9, r4, #183	; 0xb7
	sys_memcpy_swap(m + 5, n1, 16);
    c026:	f010 fb57 	bl	1c6d8 <sys_memcpy_swap>
	sys_memcpy_swap(m + 21, n2, 16);
    c02a:	2210      	movs	r2, #16
    c02c:	4649      	mov	r1, r9
    c02e:	f10d 0065 	add.w	r0, sp, #101	; 0x65
    c032:	f010 fb51 	bl	1c6d8 <sys_memcpy_swap>
	m[37] = a1->type;
    c036:	f89a 3077 	ldrb.w	r3, [sl, #119]	; 0x77
    c03a:	f88d 3075 	strb.w	r3, [sp, #117]	; 0x75
	sys_memcpy_swap(m + 38, a1->a.val, 6);
    c03e:	2206      	movs	r2, #6
    c040:	f10a 0178 	add.w	r1, sl, #120	; 0x78
    c044:	f10d 0076 	add.w	r0, sp, #118	; 0x76
    c048:	f010 fb46 	bl	1c6d8 <sys_memcpy_swap>
		   &smp->chan.chan.conn->le.resp_addr, smp->mackey,
    c04c:	f204 1757 	addw	r7, r4, #343	; 0x157
	m[44] = a2->type;
    c050:	f89a 307e 	ldrb.w	r3, [sl, #126]	; 0x7e
    c054:	f88d 307c 	strb.w	r3, [sp, #124]	; 0x7c
	sys_memcpy_swap(m + 45, a2->a.val, 6);
    c058:	2206      	movs	r2, #6
    c05a:	f10a 017f 	add.w	r1, sl, #127	; 0x7f
    c05e:	f10d 007d 	add.w	r0, sp, #125	; 0x7d
    c062:	f010 fb39 	bl	1c6d8 <sys_memcpy_swap>
	err = bt_smp_aes_cmac(t, m, sizeof(m), mackey);
    c066:	463b      	mov	r3, r7
    c068:	2235      	movs	r2, #53	; 0x35
    c06a:	4631      	mov	r1, r6
    c06c:	a808      	add	r0, sp, #32
    c06e:	f010 fb64 	bl	1c73a <bt_smp_aes_cmac>
	if (err) {
    c072:	bb18      	cbnz	r0, c0bc <compute_and_check_and_send_slave_dhcheck+0x124>
	sys_mem_swap(mackey, 16);
    c074:	2110      	movs	r1, #16
    c076:	4638      	mov	r0, r7
		   smp->tk)) {
    c078:	f104 0ad7 	add.w	sl, r4, #215	; 0xd7
	sys_mem_swap(mackey, 16);
    c07c:	f010 fb36 	bl	1c6ec <sys_mem_swap>
	err = bt_smp_aes_cmac(t, m, sizeof(m), ltk);
    c080:	4653      	mov	r3, sl
    c082:	2235      	movs	r2, #53	; 0x35
    c084:	4631      	mov	r1, r6
    c086:	a808      	add	r0, sp, #32
	m[0] = 0x01;
    c088:	f88d b050 	strb.w	fp, [sp, #80]	; 0x50
	err = bt_smp_aes_cmac(t, m, sizeof(m), ltk);
    c08c:	f010 fb55 	bl	1c73a <bt_smp_aes_cmac>
	if (err) {
    c090:	b9a0      	cbnz	r0, c0bc <compute_and_check_and_send_slave_dhcheck+0x124>
	sys_mem_swap(ltk, 16);
    c092:	2110      	movs	r1, #16
    c094:	4650      	mov	r0, sl
    c096:	f010 fb29 	bl	1c6ec <sys_mem_swap>
		   &smp->chan.chan.conn->le.resp_addr,
    c09a:	4622      	mov	r2, r4
	if (smp_f6(smp->mackey, smp->prnd, smp->rrnd, r, &smp->prsp[1],
    c09c:	4638      	mov	r0, r7
		   &smp->chan.chan.conn->le.resp_addr,
    c09e:	f852 3ba1 	ldr.w	r3, [r2], #161
	if (smp_f6(smp->mackey, smp->prnd, smp->rrnd, r, &smp->prsp[1],
    c0a2:	9603      	str	r6, [sp, #12]
		   &smp->chan.chan.conn->le.init_addr, e)) {
    c0a4:	f103 0177 	add.w	r1, r3, #119	; 0x77
		   &smp->chan.chan.conn->le.resp_addr,
    c0a8:	337e      	adds	r3, #126	; 0x7e
	if (smp_f6(smp->mackey, smp->prnd, smp->rrnd, r, &smp->prsp[1],
    c0aa:	e9cd 2300 	strd	r2, r3, [sp]
    c0ae:	9102      	str	r1, [sp, #8]
    c0b0:	ab04      	add	r3, sp, #16
    c0b2:	4642      	mov	r2, r8
    c0b4:	4649      	mov	r1, r9
    c0b6:	f010 fb81 	bl	1c7bc <smp_f6>
    c0ba:	b148      	cbz	r0, c0d0 <compute_and_check_and_send_slave_dhcheck+0x138>
		return BT_SMP_ERR_UNSPECIFIED;
    c0bc:	2008      	movs	r0, #8
    c0be:	e048      	b.n	c152 <compute_and_check_and_send_slave_dhcheck+0x1ba>
		if (smp->oobd_remote) {
    c0c0:	f8d4 1174 	ldr.w	r1, [r4, #372]	; 0x174
    c0c4:	2900      	cmp	r1, #0
    c0c6:	d081      	beq.n	bfcc <compute_and_check_and_send_slave_dhcheck+0x34>
			memcpy(r, smp->oobd_remote->r, sizeof(r));
    c0c8:	2210      	movs	r2, #16
    c0ca:	eb0d 0002 	add.w	r0, sp, r2
    c0ce:	e77b      	b.n	bfc8 <compute_and_check_and_send_slave_dhcheck+0x30>
	if (smp->method == LE_SC_OOB) {
    c0d0:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
    c0d4:	2b05      	cmp	r3, #5
    c0d6:	d108      	bne.n	c0ea <compute_and_check_and_send_slave_dhcheck+0x152>
		if (smp->oobd_local) {
    c0d8:	f8d4 1170 	ldr.w	r1, [r4, #368]	; 0x170
			memcpy(r, smp->oobd_local->r, sizeof(r));
    c0dc:	2210      	movs	r2, #16
    c0de:	eb0d 0002 	add.w	r0, sp, r2
		if (smp->oobd_local) {
    c0e2:	2900      	cmp	r1, #0
    c0e4:	d038      	beq.n	c158 <compute_and_check_and_send_slave_dhcheck+0x1c0>
			memcpy(r, smp->oobd_local->r, sizeof(r));
    c0e6:	f00e ff88 	bl	1affa <memcpy>
		   &smp->chan.chan.conn->le.init_addr,
    c0ea:	4622      	mov	r2, r4
	if (smp_f6(smp->mackey, smp->rrnd, smp->prnd, r, &smp->preq[1],
    c0ec:	4638      	mov	r0, r7
		   &smp->chan.chan.conn->le.init_addr,
    c0ee:	f852 3b9a 	ldr.w	r3, [r2], #154
	if (smp_f6(smp->mackey, smp->rrnd, smp->prnd, r, &smp->preq[1],
    c0f2:	9503      	str	r5, [sp, #12]
		   &smp->chan.chan.conn->le.resp_addr, re)) {
    c0f4:	f103 017e 	add.w	r1, r3, #126	; 0x7e
		   &smp->chan.chan.conn->le.init_addr,
    c0f8:	3377      	adds	r3, #119	; 0x77
	if (smp_f6(smp->mackey, smp->rrnd, smp->prnd, r, &smp->preq[1],
    c0fa:	e9cd 2300 	strd	r2, r3, [sp]
    c0fe:	9102      	str	r1, [sp, #8]
    c100:	ab04      	add	r3, sp, #16
    c102:	464a      	mov	r2, r9
    c104:	4641      	mov	r1, r8
    c106:	f010 fb59 	bl	1c7bc <smp_f6>
    c10a:	2800      	cmp	r0, #0
    c10c:	d1d6      	bne.n	c0bc <compute_and_check_and_send_slave_dhcheck+0x124>
	if (memcmp(smp->e, re, 16)) {
    c10e:	4629      	mov	r1, r5
    c110:	2210      	movs	r2, #16
    c112:	f204 1047 	addw	r0, r4, #327	; 0x147
    c116:	f00e ff60 	bl	1afda <memcmp>
    c11a:	4605      	mov	r5, r0
    c11c:	b9f8      	cbnz	r0, c15e <compute_and_check_and_send_slave_dhcheck+0x1c6>
	buf = smp_create_pdu(smp, BT_SMP_DHKEY_CHECK, sizeof(*req));
    c11e:	210d      	movs	r1, #13
    c120:	4620      	mov	r0, r4
    c122:	f010 fbc1 	bl	1c8a8 <smp_create_pdu.isra.6>
	if (!buf) {
    c126:	4607      	mov	r7, r0
    c128:	2800      	cmp	r0, #0
    c12a:	d0c7      	beq.n	c0bc <compute_and_check_and_send_slave_dhcheck+0x124>
	req = net_buf_add(buf, sizeof(*req));
    c12c:	2110      	movs	r1, #16
    c12e:	3008      	adds	r0, #8
    c130:	f011 fd8c 	bl	1dc4c <net_buf_simple_add>
	memcpy(req->e, e, sizeof(req->e));
    c134:	2210      	movs	r2, #16
    c136:	4631      	mov	r1, r6
    c138:	f00e ff5f 	bl	1affa <memcpy>
	smp_send(smp, buf, NULL, NULL);
    c13c:	462a      	mov	r2, r5
    c13e:	4639      	mov	r1, r7
    c140:	4620      	mov	r0, r4
    c142:	f7ff fe6f 	bl	be24 <smp_send.isra.7>
	atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
    c146:	f104 0094 	add.w	r0, r4, #148	; 0x94
    c14a:	2101      	movs	r1, #1
    c14c:	f010 fadd 	bl	1c70a <atomic_set_bit>
	return 0;
    c150:	4628      	mov	r0, r5
}
    c152:	b023      	add	sp, #140	; 0x8c
    c154:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			memset(r, 0, sizeof(r));
    c158:	f00e ff79 	bl	1b04e <memset>
    c15c:	e7c5      	b.n	c0ea <compute_and_check_and_send_slave_dhcheck+0x152>
		return BT_SMP_ERR_DHKEY_CHECK_FAILED;
    c15e:	200b      	movs	r0, #11
    c160:	e7f7      	b.n	c152 <compute_and_check_and_send_slave_dhcheck+0x1ba>
    c162:	bf00      	nop
    c164:	000216e4 	.word	0x000216e4

0000c168 <smp_pairing_req>:
{
    c168:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	struct bt_smp_pairing *req = (void *)buf->data;
    c16c:	688d      	ldr	r5, [r1, #8]
	if ((req->max_key_size > BT_SMP_MAX_ENC_KEY_SIZE) ||
    c16e:	78eb      	ldrb	r3, [r5, #3]
    c170:	3b07      	subs	r3, #7
    c172:	2b09      	cmp	r3, #9
{
    c174:	4604      	mov	r4, r0
	if ((req->max_key_size > BT_SMP_MAX_ENC_KEY_SIZE) ||
    c176:	d904      	bls.n	c182 <smp_pairing_req+0x1a>
		return BT_SMP_ERR_ENC_KEY_SIZE;
    c178:	2506      	movs	r5, #6
}
    c17a:	4628      	mov	r0, r5
    c17c:	b002      	add	sp, #8
    c17e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	struct bt_conn *conn = smp->chan.chan.conn;
    c182:	6807      	ldr	r7, [r0, #0]
	if (!conn->le.keys) {
    c184:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
    c188:	b163      	cbz	r3, c1a4 <smp_pairing_req+0x3c>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ)) {
    c18a:	f104 0694 	add.w	r6, r4, #148	; 0x94
    c18e:	210e      	movs	r1, #14
    c190:	4630      	mov	r0, r6
    c192:	f010 fac9 	bl	1c728 <atomic_test_bit>
    c196:	b980      	cbnz	r0, c1ba <smp_pairing_req+0x52>
		int ret = smp_init(smp);
    c198:	4620      	mov	r0, r4
    c19a:	f7ff fe25 	bl	bde8 <smp_init>
		if (ret) {
    c19e:	b160      	cbz	r0, c1ba <smp_pairing_req+0x52>
			return ret;
    c1a0:	b2c5      	uxtb	r5, r0
    c1a2:	e7ea      	b.n	c17a <smp_pairing_req+0x12>
		conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
    c1a4:	f107 0170 	add.w	r1, r7, #112	; 0x70
    c1a8:	7a38      	ldrb	r0, [r7, #8]
    c1aa:	f001 fa33 	bl	d614 <bt_keys_get_addr>
    c1ae:	f8c7 009c 	str.w	r0, [r7, #156]	; 0x9c
		if (!conn->le.keys) {
    c1b2:	2800      	cmp	r0, #0
    c1b4:	d1e9      	bne.n	c18a <smp_pairing_req+0x22>
			return BT_SMP_ERR_UNSPECIFIED;
    c1b6:	2508      	movs	r5, #8
    c1b8:	e7df      	b.n	c17a <smp_pairing_req+0x12>
	smp->preq[0] = BT_SMP_CMD_PAIRING_REQ;
    c1ba:	2301      	movs	r3, #1
	memcpy(smp->preq + 1, req, sizeof(*req));
    c1bc:	2206      	movs	r2, #6
    c1be:	4629      	mov	r1, r5
	smp->preq[0] = BT_SMP_CMD_PAIRING_REQ;
    c1c0:	f884 3099 	strb.w	r3, [r4, #153]	; 0x99
	memcpy(smp->preq + 1, req, sizeof(*req));
    c1c4:	f104 009a 	add.w	r0, r4, #154	; 0x9a
    c1c8:	f00e ff17 	bl	1affa <memcpy>
	smp->prsp[0] = BT_SMP_CMD_PAIRING_RSP;
    c1cc:	2302      	movs	r3, #2
    c1ce:	f884 30a0 	strb.w	r3, [r4, #160]	; 0xa0
	rsp->auth_req = get_auth(conn, req->auth_req);
    c1d2:	78a8      	ldrb	r0, [r5, #2]
    c1d4:	f7ff fda8 	bl	bd28 <get_auth.isra.0>
    c1d8:	f884 00a3 	strb.w	r0, [r4, #163]	; 0xa3
    c1dc:	4680      	mov	r8, r0
	rsp->io_capability = get_io_capa();
    c1de:	f7ff fcc1 	bl	bb64 <get_io_capa>
	rsp->oob_flag = oobd_present ? BT_SMP_OOB_PRESENT :
    c1e2:	4bb6      	ldr	r3, [pc, #728]	; (c4bc <smp_pairing_req+0x354>)
	rsp->io_capability = get_io_capa();
    c1e4:	f884 00a1 	strb.w	r0, [r4, #161]	; 0xa1
	rsp->oob_flag = oobd_present ? BT_SMP_OOB_PRESENT :
    c1e8:	781b      	ldrb	r3, [r3, #0]
    c1ea:	f884 30a2 	strb.w	r3, [r4, #162]	; 0xa2
	rsp->max_key_size = BT_SMP_MAX_ENC_KEY_SIZE;
    c1ee:	2310      	movs	r3, #16
    c1f0:	f884 30a4 	strb.w	r3, [r4, #164]	; 0xa4
	rsp->init_key_dist = (req->init_key_dist & RECV_KEYS);
    c1f4:	792b      	ldrb	r3, [r5, #4]
    c1f6:	f003 0307 	and.w	r3, r3, #7
    c1fa:	f884 30a5 	strb.w	r3, [r4, #165]	; 0xa5
	rsp->resp_key_dist = (req->resp_key_dist & SEND_KEYS);
    c1fe:	796b      	ldrb	r3, [r5, #5]
	if ((rsp->auth_req & BT_SMP_AUTH_SC) &&
    c200:	f018 0f08 	tst.w	r8, #8
	rsp->resp_key_dist = (req->resp_key_dist & SEND_KEYS);
    c204:	f003 0307 	and.w	r3, r3, #7
    c208:	f884 30a6 	strb.w	r3, [r4, #166]	; 0xa6
	if ((rsp->auth_req & BT_SMP_AUTH_SC) &&
    c20c:	d012      	beq.n	c234 <smp_pairing_req+0xcc>
    c20e:	78ab      	ldrb	r3, [r5, #2]
    c210:	0718      	lsls	r0, r3, #28
    c212:	d50f      	bpl.n	c234 <smp_pairing_req+0xcc>
		atomic_set_bit(smp->flags, SMP_FLAG_SC);
    c214:	2105      	movs	r1, #5
    c216:	4630      	mov	r0, r6
    c218:	f010 fa77 	bl	1c70a <atomic_set_bit>
		rsp->init_key_dist &= RECV_KEYS_SC;
    c21c:	f894 30a5 	ldrb.w	r3, [r4, #165]	; 0xa5
    c220:	f003 0306 	and.w	r3, r3, #6
    c224:	f884 30a5 	strb.w	r3, [r4, #165]	; 0xa5
		rsp->resp_key_dist &= SEND_KEYS_SC;
    c228:	f894 30a6 	ldrb.w	r3, [r4, #166]	; 0xa6
    c22c:	f003 0306 	and.w	r3, r3, #6
    c230:	f884 30a6 	strb.w	r3, [r4, #166]	; 0xa6
	if ((rsp->auth_req & BT_SMP_AUTH_CT2) &&
    c234:	f894 30a3 	ldrb.w	r3, [r4, #163]	; 0xa3
    c238:	0699      	lsls	r1, r3, #26
    c23a:	d506      	bpl.n	c24a <smp_pairing_req+0xe2>
    c23c:	78ab      	ldrb	r3, [r5, #2]
    c23e:	069a      	lsls	r2, r3, #26
    c240:	d503      	bpl.n	c24a <smp_pairing_req+0xe2>
		atomic_set_bit(smp->flags, SMP_FLAG_CT2);
    c242:	2113      	movs	r1, #19
    c244:	4630      	mov	r0, r6
    c246:	f010 fa60 	bl	1c70a <atomic_set_bit>
	smp->local_dist = rsp->resp_key_dist;
    c24a:	f894 30a6 	ldrb.w	r3, [r4, #166]	; 0xa6
    c24e:	f884 3178 	strb.w	r3, [r4, #376]	; 0x178
	smp->remote_dist = rsp->init_key_dist;
    c252:	f894 30a5 	ldrb.w	r3, [r4, #165]	; 0xa5
    c256:	f884 3179 	strb.w	r3, [r4, #377]	; 0x179
	if ((rsp->auth_req & BT_SMP_AUTH_BONDING) &&
    c25a:	f894 30a3 	ldrb.w	r3, [r4, #163]	; 0xa3
    c25e:	07db      	lsls	r3, r3, #31
    c260:	d506      	bpl.n	c270 <smp_pairing_req+0x108>
    c262:	78ab      	ldrb	r3, [r5, #2]
    c264:	07d8      	lsls	r0, r3, #31
    c266:	d503      	bpl.n	c270 <smp_pairing_req+0x108>
		atomic_set_bit(smp->flags, SMP_FLAG_BOND);
    c268:	210c      	movs	r1, #12
    c26a:	4630      	mov	r0, r6
    c26c:	f010 fa4d 	bl	1c70a <atomic_set_bit>
	atomic_set_bit(smp->flags, SMP_FLAG_PAIRING);
    c270:	2103      	movs	r1, #3
    c272:	4630      	mov	r0, r6
    c274:	f010 fa49 	bl	1c70a <atomic_set_bit>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    c278:	2105      	movs	r1, #5
	smp->method = get_pair_method(smp, req->io_capability);
    c27a:	782d      	ldrb	r5, [r5, #0]
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    c27c:	f010 fa54 	bl	1c728 <atomic_test_bit>
    c280:	f8d4 8000 	ldr.w	r8, [r4]
    c284:	2800      	cmp	r0, #0
    c286:	d14b      	bne.n	c320 <smp_pairing_req+0x1b8>
	if (remote_io > BT_SMP_IO_KEYBOARD_DISPLAY) {
    c288:	2d04      	cmp	r5, #4
    c28a:	d816      	bhi.n	c2ba <smp_pairing_req+0x152>
	if (!((req->auth_req | rsp->auth_req) & BT_SMP_AUTH_MITM)) {
    c28c:	f894 009c 	ldrb.w	r0, [r4, #156]	; 0x9c
    c290:	f894 30a3 	ldrb.w	r3, [r4, #163]	; 0xa3
    c294:	4318      	orrs	r0, r3
    c296:	f010 0004 	ands.w	r0, r0, #4
    c29a:	d00e      	beq.n	c2ba <smp_pairing_req+0x152>
	method = gen_method_legacy[remote_io][get_io_capa()];
    c29c:	f7ff fc62 	bl	bb64 <get_io_capa>
    c2a0:	4b87      	ldr	r3, [pc, #540]	; (c4c0 <smp_pairing_req+0x358>)
    c2a2:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    c2a6:	441d      	add	r5, r3
    c2a8:	5c28      	ldrb	r0, [r5, r0]
	if (method == PASSKEY_ROLE) {
    c2aa:	2804      	cmp	r0, #4
    c2ac:	d105      	bne.n	c2ba <smp_pairing_req+0x152>
		if (smp->chan.chan.conn->role == BT_HCI_ROLE_MASTER) {
    c2ae:	f898 3003 	ldrb.w	r3, [r8, #3]
			method = PASSKEY_INPUT;
    c2b2:	2b00      	cmp	r3, #0
    c2b4:	bf0c      	ite	eq
    c2b6:	2002      	moveq	r0, #2
    c2b8:	2001      	movne	r0, #1
	smp->method = get_pair_method(smp, req->io_capability);
    c2ba:	f884 0098 	strb.w	r0, [r4, #152]	; 0x98
	if (!conn->le.keys) {
    c2be:	f8d8 309c 	ldr.w	r3, [r8, #156]	; 0x9c
    c2c2:	b93b      	cbnz	r3, c2d4 <smp_pairing_req+0x16c>
		conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
    c2c4:	f108 0170 	add.w	r1, r8, #112	; 0x70
    c2c8:	f898 0008 	ldrb.w	r0, [r8, #8]
    c2cc:	f001 f9a2 	bl	d614 <bt_keys_get_addr>
    c2d0:	f8c8 009c 	str.w	r0, [r8, #156]	; 0x9c
	if (!conn->le.keys ||
    c2d4:	f8d8 209c 	ldr.w	r2, [r8, #156]	; 0x9c
    c2d8:	2a00      	cmp	r2, #0
    c2da:	d142      	bne.n	c362 <smp_pairing_req+0x1fa>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    c2dc:	2105      	movs	r1, #5
    c2de:	4630      	mov	r0, r6
    c2e0:	f010 fa22 	bl	1c728 <atomic_test_bit>
    c2e4:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
    c2e8:	2800      	cmp	r0, #0
    c2ea:	f040 80cc 	bne.w	c486 <smp_pairing_req+0x31e>
	if ((DISPLAY_FIXED(smp) || smp->method == JUST_WORKS) &&
    c2ee:	461d      	mov	r5, r3
    c2f0:	2b00      	cmp	r3, #0
    c2f2:	d154      	bne.n	c39e <smp_pairing_req+0x236>
	    !atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) &&
    c2f4:	210e      	movs	r1, #14
    c2f6:	4630      	mov	r0, r6
    c2f8:	f010 fa16 	bl	1c728 <atomic_test_bit>
	if ((DISPLAY_FIXED(smp) || smp->method == JUST_WORKS) &&
    c2fc:	2800      	cmp	r0, #0
    c2fe:	d14e      	bne.n	c39e <smp_pairing_req+0x236>
	    !atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) &&
    c300:	4f70      	ldr	r7, [pc, #448]	; (c4c4 <smp_pairing_req+0x35c>)
    c302:	683b      	ldr	r3, [r7, #0]
    c304:	2b00      	cmp	r3, #0
    c306:	d04a      	beq.n	c39e <smp_pairing_req+0x236>
	    bt_auth && bt_auth->pairing_confirm) {
    c308:	695b      	ldr	r3, [r3, #20]
    c30a:	2b00      	cmp	r3, #0
    c30c:	d047      	beq.n	c39e <smp_pairing_req+0x236>
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
    c30e:	4630      	mov	r0, r6
    c310:	2109      	movs	r1, #9
    c312:	f010 f9fa 	bl	1c70a <atomic_set_bit>
		bt_auth->pairing_confirm(smp->chan.chan.conn);
    c316:	683b      	ldr	r3, [r7, #0]
    c318:	6820      	ldr	r0, [r4, #0]
    c31a:	695b      	ldr	r3, [r3, #20]
    c31c:	4798      	blx	r3
		return 0;
    c31e:	e72c      	b.n	c17a <smp_pairing_req+0x12>
	if ((req->auth_req & rsp->auth_req) & BT_SMP_AUTH_SC) {
    c320:	f894 009c 	ldrb.w	r0, [r4, #156]	; 0x9c
    c324:	f894 20a3 	ldrb.w	r2, [r4, #163]	; 0xa3
    c328:	ea00 0302 	and.w	r3, r0, r2
    c32c:	0719      	lsls	r1, r3, #28
    c32e:	d506      	bpl.n	c33e <smp_pairing_req+0x1d6>
		if ((req->oob_flag | rsp->oob_flag) & BT_SMP_OOB_DATA_MASK) {
    c330:	f894 309b 	ldrb.w	r3, [r4, #155]	; 0x9b
    c334:	f894 10a2 	ldrb.w	r1, [r4, #162]	; 0xa2
    c338:	430b      	orrs	r3, r1
    c33a:	07db      	lsls	r3, r3, #31
    c33c:	d40d      	bmi.n	c35a <smp_pairing_req+0x1f2>
	if (remote_io > BT_SMP_IO_KEYBOARD_DISPLAY) {
    c33e:	2d04      	cmp	r5, #4
    c340:	d80d      	bhi.n	c35e <smp_pairing_req+0x1f6>
	if (!((req->auth_req | rsp->auth_req) & BT_SMP_AUTH_MITM)) {
    c342:	4310      	orrs	r0, r2
    c344:	f010 0004 	ands.w	r0, r0, #4
    c348:	d0b7      	beq.n	c2ba <smp_pairing_req+0x152>
	return gen_method_sc[remote_io][get_io_capa()];
    c34a:	f7ff fc0b 	bl	bb64 <get_io_capa>
    c34e:	4b5e      	ldr	r3, [pc, #376]	; (c4c8 <smp_pairing_req+0x360>)
    c350:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    c354:	441d      	add	r5, r3
    c356:	5c28      	ldrb	r0, [r5, r0]
    c358:	e7af      	b.n	c2ba <smp_pairing_req+0x152>
			return LE_SC_OOB;
    c35a:	2005      	movs	r0, #5
    c35c:	e7ad      	b.n	c2ba <smp_pairing_req+0x152>
		return JUST_WORKS;
    c35e:	2000      	movs	r0, #0
    c360:	e7ab      	b.n	c2ba <smp_pairing_req+0x152>
	    !(conn->le.keys->keys & (BT_KEYS_LTK_P256 | BT_KEYS_LTK))) {
    c362:	8951      	ldrh	r1, [r2, #10]
	if (!conn->le.keys ||
    c364:	f011 0f24 	tst.w	r1, #36	; 0x24
    c368:	d0b8      	beq.n	c2dc <smp_pairing_req+0x174>
	return MIN(req->max_key_size, rsp->max_key_size);
    c36a:	f894 30a4 	ldrb.w	r3, [r4, #164]	; 0xa4
    c36e:	f894 009d 	ldrb.w	r0, [r4, #157]	; 0x9d
	if (conn->le.keys->enc_size > get_encryption_key_size(smp)) {
    c372:	7a12      	ldrb	r2, [r2, #8]
    c374:	4283      	cmp	r3, r0
    c376:	bf28      	it	cs
    c378:	4603      	movcs	r3, r0
    c37a:	429a      	cmp	r2, r3
    c37c:	d901      	bls.n	c382 <smp_pairing_req+0x21a>
		return BT_SMP_ERR_AUTH_REQUIREMENTS;
    c37e:	2503      	movs	r5, #3
    c380:	e6fb      	b.n	c17a <smp_pairing_req+0x12>
	if ((conn->le.keys->keys & BT_KEYS_LTK_P256) &&
    c382:	0689      	lsls	r1, r1, #26
    c384:	d404      	bmi.n	c390 <smp_pairing_req+0x228>
	if (!IS_ENABLED(CONFIG_BT_SMP_ALLOW_UNAUTH_OVERWRITE) &&
    c386:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
    c38a:	2b00      	cmp	r3, #0
    c38c:	d1a6      	bne.n	c2dc <smp_pairing_req+0x174>
    c38e:	e7f6      	b.n	c37e <smp_pairing_req+0x216>
	    !atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    c390:	2105      	movs	r1, #5
    c392:	4630      	mov	r0, r6
    c394:	f010 f9c8 	bl	1c728 <atomic_test_bit>
	if ((conn->le.keys->keys & BT_KEYS_LTK_P256) &&
    c398:	2800      	cmp	r0, #0
    c39a:	d1f4      	bne.n	c386 <smp_pairing_req+0x21e>
    c39c:	e7ef      	b.n	c37e <smp_pairing_req+0x216>
	ret = send_pairing_rsp(smp);
    c39e:	4620      	mov	r0, r4
    c3a0:	f010 fae3 	bl	1c96a <send_pairing_rsp>
	if (ret) {
    c3a4:	4605      	mov	r5, r0
    c3a6:	2800      	cmp	r0, #0
    c3a8:	f47f aee7 	bne.w	c17a <smp_pairing_req+0x12>
	atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
    c3ac:	2103      	movs	r1, #3
    c3ae:	f104 0090 	add.w	r0, r4, #144	; 0x90
    c3b2:	f010 f9aa 	bl	1c70a <atomic_set_bit>
	struct bt_conn *conn = smp->chan.chan.conn;
    c3b6:	6825      	ldr	r5, [r4, #0]
	keys = bt_keys_find_addr(conn->id, &conn->le.dst);
    c3b8:	f105 0170 	add.w	r1, r5, #112	; 0x70
    c3bc:	7a28      	ldrb	r0, [r5, #8]
    c3be:	f001 f9ef 	bl	d7a0 <bt_keys_find_addr>
	if (keys && (keys->flags & BT_KEYS_AUTHENTICATED) &&
    c3c2:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
    c3c6:	b198      	cbz	r0, c3f0 <smp_pairing_req+0x288>
    c3c8:	7a42      	ldrb	r2, [r0, #9]
    c3ca:	07d2      	lsls	r2, r2, #31
    c3cc:	d510      	bpl.n	c3f0 <smp_pairing_req+0x288>
    c3ce:	b97b      	cbnz	r3, c3f0 <smp_pairing_req+0x288>
		BT_ERR("JustWorks failed, authenticated keys present");
    c3d0:	2301      	movs	r3, #1
    c3d2:	f04f 0100 	mov.w	r1, #0
    c3d6:	f363 0107 	bfi	r1, r3, #0, #8
    c3da:	4a3c      	ldr	r2, [pc, #240]	; (c4cc <smp_pairing_req+0x364>)
    c3dc:	4b3c      	ldr	r3, [pc, #240]	; (c4d0 <smp_pairing_req+0x368>)
    c3de:	483d      	ldr	r0, [pc, #244]	; (c4d4 <smp_pairing_req+0x36c>)
    c3e0:	1a9b      	subs	r3, r3, r2
    c3e2:	08db      	lsrs	r3, r3, #3
    c3e4:	f363 118f 	bfi	r1, r3, #6, #10
    c3e8:	f00e f913 	bl	1a612 <log_0>
				return BT_SMP_ERR_UNSPECIFIED;
    c3ec:	2108      	movs	r1, #8
    c3ee:	e02f      	b.n	c450 <smp_pairing_req+0x2e8>
	switch (smp->method) {
    c3f0:	2b01      	cmp	r3, #1
    c3f2:	4619      	mov	r1, r3
    c3f4:	d02e      	beq.n	c454 <smp_pairing_req+0x2ec>
    c3f6:	b35b      	cbz	r3, c450 <smp_pairing_req+0x2e8>
    c3f8:	2b02      	cmp	r3, #2
    c3fa:	d135      	bne.n	c468 <smp_pairing_req+0x300>
			if (bt_rand(&passkey, sizeof(passkey))) {
    c3fc:	2104      	movs	r1, #4
    c3fe:	eb0d 0001 	add.w	r0, sp, r1
    c402:	f003 fb2d 	bl	fa60 <bt_rand>
    c406:	2800      	cmp	r0, #0
    c408:	d1f0      	bne.n	c3ec <smp_pairing_req+0x284>
			passkey %= 1000000;
    c40a:	9901      	ldr	r1, [sp, #4]
    c40c:	4a32      	ldr	r2, [pc, #200]	; (c4d8 <smp_pairing_req+0x370>)
		if (bt_auth && bt_auth->passkey_display) {
    c40e:	4f2d      	ldr	r7, [pc, #180]	; (c4c4 <smp_pairing_req+0x35c>)
			passkey %= 1000000;
    c410:	fbb1 f3f2 	udiv	r3, r1, r2
    c414:	fb02 1313 	mls	r3, r2, r3, r1
    c418:	9301      	str	r3, [sp, #4]
		if (bt_auth && bt_auth->passkey_display) {
    c41a:	683b      	ldr	r3, [r7, #0]
    c41c:	b153      	cbz	r3, c434 <smp_pairing_req+0x2cc>
    c41e:	681b      	ldr	r3, [r3, #0]
    c420:	b143      	cbz	r3, c434 <smp_pairing_req+0x2cc>
			atomic_set_bit(smp->flags, SMP_FLAG_DISPLAY);
    c422:	210a      	movs	r1, #10
    c424:	4630      	mov	r0, r6
    c426:	f010 f970 	bl	1c70a <atomic_set_bit>
			bt_auth->passkey_display(conn, passkey);
    c42a:	683b      	ldr	r3, [r7, #0]
    c42c:	9901      	ldr	r1, [sp, #4]
    c42e:	681b      	ldr	r3, [r3, #0]
    c430:	4628      	mov	r0, r5
    c432:	4798      	blx	r3
		sys_put_le32(passkey, smp->tk);
    c434:	9b01      	ldr	r3, [sp, #4]
	dst[0] = val;
    c436:	f884 30d7 	strb.w	r3, [r4, #215]	; 0xd7
	dst[1] = val >> 8;
    c43a:	f3c3 2207 	ubfx	r2, r3, #8, #8
	sys_put_le16(val >> 16, &dst[2]);
    c43e:	0c1b      	lsrs	r3, r3, #16
	dst[0] = val;
    c440:	f884 30d9 	strb.w	r3, [r4, #217]	; 0xd9
	dst[1] = val >> 8;
    c444:	0a1b      	lsrs	r3, r3, #8
    c446:	f884 20d8 	strb.w	r2, [r4, #216]	; 0xd8
    c44a:	f884 30da 	strb.w	r3, [r4, #218]	; 0xda
	return 0;
    c44e:	2100      	movs	r1, #0
	return legacy_request_tk(smp);
    c450:	460d      	mov	r5, r1
    c452:	e692      	b.n	c17a <smp_pairing_req+0x12>
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
    c454:	4630      	mov	r0, r6
    c456:	2109      	movs	r1, #9
    c458:	f010 f957 	bl	1c70a <atomic_set_bit>
		bt_auth->passkey_entry(conn);
    c45c:	4b19      	ldr	r3, [pc, #100]	; (c4c4 <smp_pairing_req+0x35c>)
    c45e:	681b      	ldr	r3, [r3, #0]
    c460:	4628      	mov	r0, r5
    c462:	685b      	ldr	r3, [r3, #4]
    c464:	4798      	blx	r3
    c466:	e7f2      	b.n	c44e <smp_pairing_req+0x2e6>
		BT_ERR("Unknown pairing method (%u)", smp->method);
    c468:	2301      	movs	r3, #1
    c46a:	f04f 0200 	mov.w	r2, #0
    c46e:	f363 0207 	bfi	r2, r3, #0, #8
    c472:	4816      	ldr	r0, [pc, #88]	; (c4cc <smp_pairing_req+0x364>)
    c474:	4b16      	ldr	r3, [pc, #88]	; (c4d0 <smp_pairing_req+0x368>)
    c476:	1a1b      	subs	r3, r3, r0
    c478:	08db      	lsrs	r3, r3, #3
    c47a:	f363 128f 	bfi	r2, r3, #6, #10
    c47e:	4817      	ldr	r0, [pc, #92]	; (c4dc <smp_pairing_req+0x374>)
    c480:	f00e f8d4 	bl	1a62c <log_1>
		return BT_SMP_ERR_UNSPECIFIED;
    c484:	e7b2      	b.n	c3ec <smp_pairing_req+0x284>
	if ((IS_ENABLED(CONFIG_BT_SMP_SC_ONLY) ||
    c486:	7aba      	ldrb	r2, [r7, #10]
    c488:	2a04      	cmp	r2, #4
    c48a:	461d      	mov	r5, r3
    c48c:	d128      	bne.n	c4e0 <smp_pairing_req+0x378>
	     conn->required_sec_level == BT_SECURITY_L4) &&
    c48e:	2b00      	cmp	r3, #0
    c490:	f43f af75 	beq.w	c37e <smp_pairing_req+0x216>
	return MIN(req->max_key_size, rsp->max_key_size);
    c494:	f894 309d 	ldrb.w	r3, [r4, #157]	; 0x9d
    c498:	f894 20a4 	ldrb.w	r2, [r4, #164]	; 0xa4
	     conn->required_sec_level == BT_SECURITY_L4) &&
    c49c:	4293      	cmp	r3, r2
    c49e:	bf28      	it	cs
    c4a0:	4613      	movcs	r3, r2
    c4a2:	2b10      	cmp	r3, #16
    c4a4:	f47f ae68 	bne.w	c178 <smp_pairing_req+0x10>
	atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PUBLIC_KEY);
    c4a8:	210c      	movs	r1, #12
    c4aa:	f104 0090 	add.w	r0, r4, #144	; 0x90
    c4ae:	f010 f92c 	bl	1c70a <atomic_set_bit>
	return send_pairing_rsp(smp);
    c4b2:	4620      	mov	r0, r4
    c4b4:	f010 fa59 	bl	1c96a <send_pairing_rsp>
    c4b8:	4605      	mov	r5, r0
    c4ba:	e65e      	b.n	c17a <smp_pairing_req+0x12>
    c4bc:	20001c75 	.word	0x20001c75
    c4c0:	000216b2 	.word	0x000216b2
    c4c4:	2000029c 	.word	0x2000029c
    c4c8:	000216cb 	.word	0x000216cb
    c4cc:	0001ed28 	.word	0x0001ed28
    c4d0:	0001ee18 	.word	0x0001ee18
    c4d4:	00021789 	.word	0x00021789
    c4d8:	000f4240 	.word	0x000f4240
    c4dc:	000217b6 	.word	0x000217b6
	if ((DISPLAY_FIXED(smp) || smp->method == JUST_WORKS) &&
    c4e0:	2b00      	cmp	r3, #0
    c4e2:	d1e1      	bne.n	c4a8 <smp_pairing_req+0x340>
	    !atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) &&
    c4e4:	210e      	movs	r1, #14
    c4e6:	4630      	mov	r0, r6
    c4e8:	f010 f91e 	bl	1c728 <atomic_test_bit>
	if ((DISPLAY_FIXED(smp) || smp->method == JUST_WORKS) &&
    c4ec:	2800      	cmp	r0, #0
    c4ee:	d1db      	bne.n	c4a8 <smp_pairing_req+0x340>
	    !atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) &&
    c4f0:	4f03      	ldr	r7, [pc, #12]	; (c500 <smp_pairing_req+0x398>)
    c4f2:	683b      	ldr	r3, [r7, #0]
    c4f4:	2b00      	cmp	r3, #0
    c4f6:	d0d7      	beq.n	c4a8 <smp_pairing_req+0x340>
	    bt_auth && bt_auth->pairing_confirm) {
    c4f8:	695b      	ldr	r3, [r3, #20]
    c4fa:	2b00      	cmp	r3, #0
    c4fc:	d0d4      	beq.n	c4a8 <smp_pairing_req+0x340>
    c4fe:	e706      	b.n	c30e <smp_pairing_req+0x1a6>
    c500:	2000029c 	.word	0x2000029c

0000c504 <sc_send_public_key>:
{
    c504:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	req_buf = smp_create_pdu(smp, BT_SMP_CMD_PUBLIC_KEY, sizeof(*req));
    c506:	210c      	movs	r1, #12
{
    c508:	4606      	mov	r6, r0
	req_buf = smp_create_pdu(smp, BT_SMP_CMD_PUBLIC_KEY, sizeof(*req));
    c50a:	f010 f9cd 	bl	1c8a8 <smp_create_pdu.isra.6>
	if (!req_buf) {
    c50e:	4604      	mov	r4, r0
    c510:	b1b0      	cbz	r0, c540 <sc_send_public_key+0x3c>
	req = net_buf_add(req_buf, sizeof(*req));
    c512:	2140      	movs	r1, #64	; 0x40
    c514:	3008      	adds	r0, #8
    c516:	f011 fb99 	bl	1dc4c <net_buf_simple_add>
	memcpy(req->x, sc_public_key, sizeof(req->x));
    c51a:	4d0a      	ldr	r5, [pc, #40]	; (c544 <sc_send_public_key+0x40>)
    c51c:	2220      	movs	r2, #32
    c51e:	6829      	ldr	r1, [r5, #0]
	req = net_buf_add(req_buf, sizeof(*req));
    c520:	4607      	mov	r7, r0
	memcpy(req->x, sc_public_key, sizeof(req->x));
    c522:	f00e fd6a 	bl	1affa <memcpy>
	memcpy(req->y, &sc_public_key[32], sizeof(req->y));
    c526:	6829      	ldr	r1, [r5, #0]
    c528:	2220      	movs	r2, #32
    c52a:	4411      	add	r1, r2
    c52c:	18b8      	adds	r0, r7, r2
    c52e:	f00e fd64 	bl	1affa <memcpy>
	smp_send(smp, req_buf, NULL, NULL);
    c532:	4630      	mov	r0, r6
    c534:	2200      	movs	r2, #0
    c536:	4621      	mov	r1, r4
    c538:	f7ff fc74 	bl	be24 <smp_send.isra.7>
	return 0;
    c53c:	2000      	movs	r0, #0
}
    c53e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_SMP_ERR_UNSPECIFIED;
    c540:	2008      	movs	r0, #8
    c542:	e7fc      	b.n	c53e <sc_send_public_key+0x3a>
    c544:	20000670 	.word	0x20000670

0000c548 <smp_public_key>:
{
    c548:	b570      	push	{r4, r5, r6, lr}
	struct bt_smp_public_key *req = (void *)buf->data;
    c54a:	688e      	ldr	r6, [r1, #8]
	memcpy(smp->pkey, req->x, 32);
    c54c:	f100 04e7 	add.w	r4, r0, #231	; 0xe7
{
    c550:	4605      	mov	r5, r0
	memcpy(smp->pkey, req->x, 32);
    c552:	2220      	movs	r2, #32
    c554:	4631      	mov	r1, r6
    c556:	4620      	mov	r0, r4
    c558:	f00e fd4f 	bl	1affa <memcpy>
	memcpy(&smp->pkey[32], req->y, 32);
    c55c:	2220      	movs	r2, #32
    c55e:	18b1      	adds	r1, r6, r2
    c560:	f205 1007 	addw	r0, r5, #263	; 0x107
    c564:	f00e fd49 	bl	1affa <memcpy>
	if (memcmp(smp->pkey, sc_debug_public_key, 64) == 0) {
    c568:	2240      	movs	r2, #64	; 0x40
    c56a:	4922      	ldr	r1, [pc, #136]	; (c5f4 <smp_public_key+0xac>)
    c56c:	4620      	mov	r0, r4
    c56e:	f00e fd34 	bl	1afda <memcmp>
    c572:	b148      	cbz	r0, c588 <smp_public_key+0x40>
	if (!sc_public_key) {
    c574:	4b20      	ldr	r3, [pc, #128]	; (c5f8 <smp_public_key+0xb0>)
    c576:	681c      	ldr	r4, [r3, #0]
    c578:	bb94      	cbnz	r4, c5e0 <smp_public_key+0x98>
		atomic_set_bit(smp->flags, SMP_FLAG_PKEY_SEND);
    c57a:	f105 0094 	add.w	r0, r5, #148	; 0x94
    c57e:	2106      	movs	r1, #6
    c580:	f010 f8c3 	bl	1c70a <atomic_set_bit>
		return 0;
    c584:	4620      	mov	r0, r4
}
    c586:	bd70      	pop	{r4, r5, r6, pc}
		BT_INFO("Remote is using Debug Public key");
    c588:	2303      	movs	r3, #3
    c58a:	f04f 0100 	mov.w	r1, #0
    c58e:	4a1b      	ldr	r2, [pc, #108]	; (c5fc <smp_public_key+0xb4>)
    c590:	481b      	ldr	r0, [pc, #108]	; (c600 <smp_public_key+0xb8>)
    c592:	f363 0107 	bfi	r1, r3, #0, #8
    c596:	4b1b      	ldr	r3, [pc, #108]	; (c604 <smp_public_key+0xbc>)
    c598:	1a9b      	subs	r3, r3, r2
    c59a:	08db      	lsrs	r3, r3, #3
    c59c:	f363 118f 	bfi	r1, r3, #6, #10
    c5a0:	f00e f837 	bl	1a612 <log_0>
		atomic_set_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY);
    c5a4:	210d      	movs	r1, #13
    c5a6:	f105 0094 	add.w	r0, r5, #148	; 0x94
    c5aa:	f010 f8ae 	bl	1c70a <atomic_set_bit>
		if (!update_debug_keys_check(smp)) {
    c5ae:	682c      	ldr	r4, [r5, #0]
	if (!conn->le.keys) {
    c5b0:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
    c5b4:	b933      	cbnz	r3, c5c4 <smp_public_key+0x7c>
		conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
    c5b6:	f104 0170 	add.w	r1, r4, #112	; 0x70
    c5ba:	7a20      	ldrb	r0, [r4, #8]
    c5bc:	f001 f82a 	bl	d614 <bt_keys_get_addr>
    c5c0:	f8c4 009c 	str.w	r0, [r4, #156]	; 0x9c
	if (!conn->le.keys ||
    c5c4:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
    c5c8:	2b00      	cmp	r3, #0
    c5ca:	d0d3      	beq.n	c574 <smp_public_key+0x2c>
    c5cc:	895a      	ldrh	r2, [r3, #10]
    c5ce:	f002 0224 	and.w	r2, r2, #36	; 0x24
    c5d2:	2a00      	cmp	r2, #0
    c5d4:	d0ce      	beq.n	c574 <smp_public_key+0x2c>
	if (conn->le.keys->flags & BT_KEYS_DEBUG) {
    c5d6:	7a5b      	ldrb	r3, [r3, #9]
    c5d8:	079b      	lsls	r3, r3, #30
    c5da:	d5cb      	bpl.n	c574 <smp_public_key+0x2c>
			return BT_SMP_ERR_AUTH_REQUIREMENTS;
    c5dc:	2003      	movs	r0, #3
    c5de:	e7d2      	b.n	c586 <smp_public_key+0x3e>
	err = sc_send_public_key(smp);
    c5e0:	4628      	mov	r0, r5
    c5e2:	f7ff ff8f 	bl	c504 <sc_send_public_key>
	if (err) {
    c5e6:	2800      	cmp	r0, #0
    c5e8:	d1cd      	bne.n	c586 <smp_public_key+0x3e>
    c5ea:	4628      	mov	r0, r5
}
    c5ec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    c5f0:	f7ff bc6e 	b.w	bed0 <smp_public_key_slave.part.13>
    c5f4:	000216f4 	.word	0x000216f4
    c5f8:	20000670 	.word	0x20000670
    c5fc:	0001ed28 	.word	0x0001ed28
    c600:	000217d2 	.word	0x000217d2
    c604:	0001ee18 	.word	0x0001ee18

0000c608 <smp_pairing_complete>:
{
    c608:	b570      	push	{r4, r5, r6, lr}
    c60a:	4604      	mov	r4, r0
    c60c:	4e17      	ldr	r6, [pc, #92]	; (c66c <smp_pairing_complete+0x64>)
    c60e:	3094      	adds	r0, #148	; 0x94
	if (!status) {
    c610:	b9a9      	cbnz	r1, c63e <smp_pairing_complete+0x36>
		bool bond_flag = atomic_test_bit(smp->flags, SMP_FLAG_BOND);
    c612:	210c      	movs	r1, #12
    c614:	f010 f888 	bl	1c728 <atomic_test_bit>
		if (bond_flag) {
    c618:	4605      	mov	r5, r0
    c61a:	b120      	cbz	r0, c626 <smp_pairing_complete+0x1e>
			bt_keys_store(smp->chan.chan.conn->le.keys);
    c61c:	6823      	ldr	r3, [r4, #0]
    c61e:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
    c622:	f001 f9bd 	bl	d9a0 <bt_keys_store>
		if (bt_auth && bt_auth->pairing_complete) {
    c626:	6833      	ldr	r3, [r6, #0]
    c628:	b123      	cbz	r3, c634 <smp_pairing_complete+0x2c>
    c62a:	699b      	ldr	r3, [r3, #24]
		if (bt_auth && bt_auth->pairing_failed) {
    c62c:	b113      	cbz	r3, c634 <smp_pairing_complete+0x2c>
			bt_auth->pairing_failed(smp->chan.chan.conn, auth_err);
    c62e:	4629      	mov	r1, r5
    c630:	6820      	ldr	r0, [r4, #0]
    c632:	4798      	blx	r3
	smp_reset(smp);
    c634:	4620      	mov	r0, r4
}
    c636:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	smp_reset(smp);
    c63a:	f010 b9cc 	b.w	1c9d6 <smp_reset>
	switch (smp_err) {
    c63e:	3901      	subs	r1, #1
    c640:	b2c9      	uxtb	r1, r1
    c642:	290d      	cmp	r1, #13
    c644:	bf9c      	itt	ls
    c646:	4b0a      	ldrls	r3, [pc, #40]	; (c670 <smp_pairing_complete+0x68>)
    c648:	5c5d      	ldrbls	r5, [r3, r1]
		if (!atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR)) {
    c64a:	f04f 0102 	mov.w	r1, #2
	if (!status) {
    c64e:	bf88      	it	hi
    c650:	2508      	movhi	r5, #8
		if (!atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR)) {
    c652:	f010 f869 	bl	1c728 <atomic_test_bit>
    c656:	b918      	cbnz	r0, c660 <smp_pairing_complete+0x58>
			bt_conn_security_changed(smp->chan.chan.conn, auth_err);
    c658:	4629      	mov	r1, r5
    c65a:	6820      	ldr	r0, [r4, #0]
    c65c:	f7fb fbe2 	bl	7e24 <bt_conn_security_changed>
		if (bt_auth && bt_auth->pairing_failed) {
    c660:	6833      	ldr	r3, [r6, #0]
    c662:	2b00      	cmp	r3, #0
    c664:	d0e6      	beq.n	c634 <smp_pairing_complete+0x2c>
    c666:	69db      	ldr	r3, [r3, #28]
    c668:	e7e0      	b.n	c62c <smp_pairing_complete+0x24>
    c66a:	bf00      	nop
    c66c:	2000029c 	.word	0x2000029c
    c670:	00021485 	.word	0x00021485

0000c674 <bt_smp_dhkey_ready>:
{
    c674:	b510      	push	{r4, lr}
		if (atomic_test_and_clear_bit(bt_smp_pool[i].flags,
    c676:	2107      	movs	r1, #7
{
    c678:	4604      	mov	r4, r0
		if (atomic_test_and_clear_bit(bt_smp_pool[i].flags,
    c67a:	4816      	ldr	r0, [pc, #88]	; (c6d4 <bt_smp_dhkey_ready+0x60>)
    c67c:	f010 f990 	bl	1c9a0 <atomic_test_and_clear_bit>
    c680:	b338      	cbz	r0, c6d2 <bt_smp_dhkey_ready+0x5e>
	if (!dhkey) {
    c682:	b92c      	cbnz	r4, c690 <bt_smp_dhkey_ready+0x1c>
		smp_error(smp, BT_SMP_ERR_DHKEY_CHECK_FAILED);
    c684:	210b      	movs	r1, #11
			smp_error(smp, err);
    c686:	4814      	ldr	r0, [pc, #80]	; (c6d8 <bt_smp_dhkey_ready+0x64>)
}
    c688:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			smp_error(smp, err);
    c68c:	f010 b9ce 	b.w	1ca2c <smp_error>
	memcpy(smp->dhkey, dhkey, 32);
    c690:	4621      	mov	r1, r4
    c692:	2220      	movs	r2, #32
    c694:	4811      	ldr	r0, [pc, #68]	; (c6dc <bt_smp_dhkey_ready+0x68>)
    c696:	f00e fcb0 	bl	1affa <memcpy>
	if (atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
    c69a:	2109      	movs	r1, #9
    c69c:	480d      	ldr	r0, [pc, #52]	; (c6d4 <bt_smp_dhkey_ready+0x60>)
    c69e:	f010 f843 	bl	1c728 <atomic_test_bit>
    c6a2:	b128      	cbz	r0, c6b0 <bt_smp_dhkey_ready+0x3c>
		atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_SEND);
    c6a4:	2108      	movs	r1, #8
    c6a6:	480b      	ldr	r0, [pc, #44]	; (c6d4 <bt_smp_dhkey_ready+0x60>)
}
    c6a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_SEND);
    c6ac:	f010 b82d 	b.w	1c70a <atomic_set_bit>
	if (atomic_test_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT)) {
    c6b0:	210f      	movs	r1, #15
    c6b2:	4808      	ldr	r0, [pc, #32]	; (c6d4 <bt_smp_dhkey_ready+0x60>)
    c6b4:	f010 f838 	bl	1c728 <atomic_test_bit>
    c6b8:	2800      	cmp	r0, #0
    c6ba:	d1f3      	bne.n	c6a4 <bt_smp_dhkey_ready+0x30>
	if (atomic_test_bit(smp->flags, SMP_FLAG_DHKEY_SEND)) {
    c6bc:	2108      	movs	r1, #8
    c6be:	4805      	ldr	r0, [pc, #20]	; (c6d4 <bt_smp_dhkey_ready+0x60>)
    c6c0:	f010 f832 	bl	1c728 <atomic_test_bit>
    c6c4:	b128      	cbz	r0, c6d2 <bt_smp_dhkey_ready+0x5e>
		err = compute_and_check_and_send_slave_dhcheck(smp);
    c6c6:	4804      	ldr	r0, [pc, #16]	; (c6d8 <bt_smp_dhkey_ready+0x64>)
    c6c8:	f7ff fc66 	bl	bf98 <compute_and_check_and_send_slave_dhcheck>
		if (err) {
    c6cc:	4601      	mov	r1, r0
    c6ce:	2800      	cmp	r0, #0
    c6d0:	d1d9      	bne.n	c686 <bt_smp_dhkey_ready+0x12>
}
    c6d2:	bd10      	pop	{r4, pc}
    c6d4:	20000568 	.word	0x20000568
    c6d8:	200004d4 	.word	0x200004d4
    c6dc:	200005fb 	.word	0x200005fb

0000c6e0 <bt_smp_recv>:
{
    c6e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (buf->len < sizeof(*hdr)) {
    c6e2:	898b      	ldrh	r3, [r1, #12]
{
    c6e4:	4604      	mov	r4, r0
    c6e6:	460d      	mov	r5, r1
	if (buf->len < sizeof(*hdr)) {
    c6e8:	b97b      	cbnz	r3, c70a <bt_smp_recv+0x2a>
		BT_ERR("Too small SMP PDU received");
    c6ea:	2301      	movs	r3, #1
    c6ec:	f04f 0100 	mov.w	r1, #0
    c6f0:	f363 0107 	bfi	r1, r3, #0, #8
    c6f4:	4a3c      	ldr	r2, [pc, #240]	; (c7e8 <bt_smp_recv+0x108>)
    c6f6:	4b3d      	ldr	r3, [pc, #244]	; (c7ec <bt_smp_recv+0x10c>)
    c6f8:	483d      	ldr	r0, [pc, #244]	; (c7f0 <bt_smp_recv+0x110>)
    c6fa:	1a9b      	subs	r3, r3, r2
    c6fc:	08db      	lsrs	r3, r3, #3
    c6fe:	f363 118f 	bfi	r1, r3, #6, #10
    c702:	f00d ff86 	bl	1a612 <log_0>
}
    c706:	2000      	movs	r0, #0
    c708:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    c70a:	2101      	movs	r1, #1
    c70c:	f105 0008 	add.w	r0, r5, #8
    c710:	f011 facd 	bl	1dcae <net_buf_simple_pull_mem>
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
    c714:	2104      	movs	r1, #4
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    c716:	4606      	mov	r6, r0
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
    c718:	f104 0094 	add.w	r0, r4, #148	; 0x94
    c71c:	f010 f804 	bl	1c728 <atomic_test_bit>
    c720:	7831      	ldrb	r1, [r6, #0]
    c722:	b170      	cbz	r0, c742 <bt_smp_recv+0x62>
		BT_WARN("SMP command (code 0x%02x) received after timeout",
    c724:	2302      	movs	r3, #2
    c726:	f04f 0200 	mov.w	r2, #0
    c72a:	f363 0207 	bfi	r2, r3, #0, #8
    c72e:	482e      	ldr	r0, [pc, #184]	; (c7e8 <bt_smp_recv+0x108>)
    c730:	4b2e      	ldr	r3, [pc, #184]	; (c7ec <bt_smp_recv+0x10c>)
    c732:	1a1b      	subs	r3, r3, r0
    c734:	08db      	lsrs	r3, r3, #3
    c736:	f363 128f 	bfi	r2, r3, #6, #10
    c73a:	482e      	ldr	r0, [pc, #184]	; (c7f4 <bt_smp_recv+0x114>)
    c73c:	f00d ff76 	bl	1a62c <log_1>
		return 0;
    c740:	e7e1      	b.n	c706 <bt_smp_recv+0x26>
	if (hdr->code >= ARRAY_SIZE(handlers) || !handlers[hdr->code].func) {
    c742:	290d      	cmp	r1, #13
    c744:	d803      	bhi.n	c74e <bt_smp_recv+0x6e>
    c746:	4f2c      	ldr	r7, [pc, #176]	; (c7f8 <bt_smp_recv+0x118>)
    c748:	f857 3031 	ldr.w	r3, [r7, r1, lsl #3]
    c74c:	b993      	cbnz	r3, c774 <bt_smp_recv+0x94>
		BT_WARN("Unhandled SMP code 0x%02x", hdr->code);
    c74e:	2302      	movs	r3, #2
    c750:	f04f 0200 	mov.w	r2, #0
    c754:	f363 0207 	bfi	r2, r3, #0, #8
    c758:	4823      	ldr	r0, [pc, #140]	; (c7e8 <bt_smp_recv+0x108>)
    c75a:	4b24      	ldr	r3, [pc, #144]	; (c7ec <bt_smp_recv+0x10c>)
    c75c:	1a1b      	subs	r3, r3, r0
    c75e:	08db      	lsrs	r3, r3, #3
    c760:	f363 128f 	bfi	r2, r3, #6, #10
    c764:	4825      	ldr	r0, [pc, #148]	; (c7fc <bt_smp_recv+0x11c>)
    c766:	f00d ff61 	bl	1a62c <log_1>
		smp_error(smp, BT_SMP_ERR_CMD_NOTSUPP);
    c76a:	2107      	movs	r1, #7
		smp_error(smp, err);
    c76c:	4620      	mov	r0, r4
    c76e:	f010 f95d 	bl	1ca2c <smp_error>
    c772:	e7c8      	b.n	c706 <bt_smp_recv+0x26>
	if (!atomic_test_and_clear_bit(&smp->allowed_cmds, hdr->code)) {
    c774:	f104 0090 	add.w	r0, r4, #144	; 0x90
    c778:	f010 f912 	bl	1c9a0 <atomic_test_and_clear_bit>
    c77c:	7831      	ldrb	r1, [r6, #0]
    c77e:	b990      	cbnz	r0, c7a6 <bt_smp_recv+0xc6>
		BT_WARN("Unexpected SMP code 0x%02x", hdr->code);
    c780:	2302      	movs	r3, #2
    c782:	f04f 0200 	mov.w	r2, #0
    c786:	f363 0207 	bfi	r2, r3, #0, #8
    c78a:	4817      	ldr	r0, [pc, #92]	; (c7e8 <bt_smp_recv+0x108>)
    c78c:	4b17      	ldr	r3, [pc, #92]	; (c7ec <bt_smp_recv+0x10c>)
    c78e:	1a1b      	subs	r3, r3, r0
    c790:	08db      	lsrs	r3, r3, #3
    c792:	f363 128f 	bfi	r2, r3, #6, #10
    c796:	481a      	ldr	r0, [pc, #104]	; (c800 <bt_smp_recv+0x120>)
    c798:	f00d ff48 	bl	1a62c <log_1>
		if (hdr->code != BT_SMP_CMD_PAIRING_FAIL) {
    c79c:	7833      	ldrb	r3, [r6, #0]
    c79e:	2b05      	cmp	r3, #5
    c7a0:	d0b1      	beq.n	c706 <bt_smp_recv+0x26>
			smp_error(smp, BT_SMP_ERR_UNSPECIFIED);
    c7a2:	2108      	movs	r1, #8
    c7a4:	e7e2      	b.n	c76c <bt_smp_recv+0x8c>
	if (buf->len != handlers[hdr->code].expect_len) {
    c7a6:	eb07 03c1 	add.w	r3, r7, r1, lsl #3
    c7aa:	89a8      	ldrh	r0, [r5, #12]
    c7ac:	791b      	ldrb	r3, [r3, #4]
    c7ae:	4283      	cmp	r3, r0
    c7b0:	d011      	beq.n	c7d6 <bt_smp_recv+0xf6>
		BT_ERR("Invalid len %u for code 0x%02x", buf->len, hdr->code);
    c7b2:	2201      	movs	r2, #1
    c7b4:	f04f 0300 	mov.w	r3, #0
    c7b8:	f362 0307 	bfi	r3, r2, #0, #8
    c7bc:	4d0a      	ldr	r5, [pc, #40]	; (c7e8 <bt_smp_recv+0x108>)
    c7be:	4a0b      	ldr	r2, [pc, #44]	; (c7ec <bt_smp_recv+0x10c>)
    c7c0:	1b52      	subs	r2, r2, r5
    c7c2:	08d2      	lsrs	r2, r2, #3
    c7c4:	f362 138f 	bfi	r3, r2, #6, #10
    c7c8:	460a      	mov	r2, r1
    c7ca:	4601      	mov	r1, r0
    c7cc:	480d      	ldr	r0, [pc, #52]	; (c804 <bt_smp_recv+0x124>)
    c7ce:	f00d ff41 	bl	1a654 <log_2>
		smp_error(smp, BT_SMP_ERR_INVALID_PARAMS);
    c7d2:	210a      	movs	r1, #10
    c7d4:	e7ca      	b.n	c76c <bt_smp_recv+0x8c>
	err = handlers[hdr->code].func(smp, buf);
    c7d6:	f857 3031 	ldr.w	r3, [r7, r1, lsl #3]
    c7da:	4620      	mov	r0, r4
    c7dc:	4629      	mov	r1, r5
    c7de:	4798      	blx	r3
	if (err) {
    c7e0:	4601      	mov	r1, r0
    c7e2:	2800      	cmp	r0, #0
    c7e4:	d08f      	beq.n	c706 <bt_smp_recv+0x26>
    c7e6:	e7c1      	b.n	c76c <bt_smp_recv+0x8c>
    c7e8:	0001ed28 	.word	0x0001ed28
    c7ec:	0001ee18 	.word	0x0001ee18
    c7f0:	000215aa 	.word	0x000215aa
    c7f4:	000215c5 	.word	0x000215c5
    c7f8:	0001f658 	.word	0x0001f658
    c7fc:	000215f6 	.word	0x000215f6
    c800:	00021610 	.word	0x00021610
    c804:	0002111b 	.word	0x0002111b

0000c808 <smp_pairing_failed>:
{
    c808:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	BT_ERR("reason 0x%x", req->reason);
    c80a:	f04f 0200 	mov.w	r2, #0
    c80e:	2301      	movs	r3, #1
	struct bt_smp_pairing_fail *req = (void *)buf->data;
    c810:	688e      	ldr	r6, [r1, #8]
    c812:	491b      	ldr	r1, [pc, #108]	; (c880 <smp_pairing_failed+0x78>)
	BT_ERR("reason 0x%x", req->reason);
    c814:	f363 0207 	bfi	r2, r3, #0, #8
    c818:	4b1a      	ldr	r3, [pc, #104]	; (c884 <smp_pairing_failed+0x7c>)
	struct bt_conn *conn = smp->chan.chan.conn;
    c81a:	4604      	mov	r4, r0
    c81c:	1a5b      	subs	r3, r3, r1
    c81e:	f854 7b94 	ldr.w	r7, [r4], #148
	BT_ERR("reason 0x%x", req->reason);
    c822:	7831      	ldrb	r1, [r6, #0]
    c824:	08db      	lsrs	r3, r3, #3
{
    c826:	4605      	mov	r5, r0
	BT_ERR("reason 0x%x", req->reason);
    c828:	f363 128f 	bfi	r2, r3, #6, #10
    c82c:	4816      	ldr	r0, [pc, #88]	; (c888 <smp_pairing_failed+0x80>)
    c82e:	f00d fefd 	bl	1a62c <log_1>
	if (atomic_test_and_clear_bit(smp->flags, SMP_FLAG_USER) ||
    c832:	2109      	movs	r1, #9
    c834:	4620      	mov	r0, r4
    c836:	f010 f8b3 	bl	1c9a0 <atomic_test_and_clear_bit>
    c83a:	b198      	cbz	r0, c864 <smp_pairing_failed+0x5c>
		if (bt_auth && bt_auth->cancel) {
    c83c:	4b13      	ldr	r3, [pc, #76]	; (c88c <smp_pairing_failed+0x84>)
    c83e:	681b      	ldr	r3, [r3, #0]
    c840:	b9bb      	cbnz	r3, c872 <smp_pairing_failed+0x6a>
	if (atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR) &&
    c842:	2102      	movs	r1, #2
    c844:	4620      	mov	r0, r4
    c846:	f00f ff6f 	bl	1c728 <atomic_test_bit>
    c84a:	b128      	cbz	r0, c858 <smp_pairing_failed+0x50>
	    smp->chan.chan.conn->le.keys) {
    c84c:	682b      	ldr	r3, [r5, #0]
    c84e:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
	if (atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR) &&
    c852:	b108      	cbz	r0, c858 <smp_pairing_failed+0x50>
		bt_keys_clear(smp->chan.chan.conn->le.keys);
    c854:	f000 ffb4 	bl	d7c0 <bt_keys_clear>
	smp_pairing_complete(smp, req->reason);
    c858:	4628      	mov	r0, r5
    c85a:	7831      	ldrb	r1, [r6, #0]
    c85c:	f7ff fed4 	bl	c608 <smp_pairing_complete>
}
    c860:	2000      	movs	r0, #0
    c862:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	    atomic_test_and_clear_bit(smp->flags, SMP_FLAG_DISPLAY)) {
    c864:	210a      	movs	r1, #10
    c866:	4620      	mov	r0, r4
    c868:	f010 f89a 	bl	1c9a0 <atomic_test_and_clear_bit>
	if (atomic_test_and_clear_bit(smp->flags, SMP_FLAG_USER) ||
    c86c:	2800      	cmp	r0, #0
    c86e:	d1e5      	bne.n	c83c <smp_pairing_failed+0x34>
    c870:	e7e7      	b.n	c842 <smp_pairing_failed+0x3a>
		if (bt_auth && bt_auth->cancel) {
    c872:	691b      	ldr	r3, [r3, #16]
    c874:	2b00      	cmp	r3, #0
    c876:	d0e4      	beq.n	c842 <smp_pairing_failed+0x3a>
			bt_auth->cancel(conn);
    c878:	4638      	mov	r0, r7
    c87a:	4798      	blx	r3
    c87c:	e7e1      	b.n	c842 <smp_pairing_failed+0x3a>
    c87e:	bf00      	nop
    c880:	0001ed28 	.word	0x0001ed28
    c884:	0001ee18 	.word	0x0001ee18
    c888:	0002177d 	.word	0x0002177d
    c88c:	2000029c 	.word	0x2000029c

0000c890 <smp_timeout>:
{
    c890:	b538      	push	{r3, r4, r5, lr}
	BT_ERR("SMP Timeout");
    c892:	f04f 0100 	mov.w	r1, #0
    c896:	2301      	movs	r3, #1
    c898:	f363 0107 	bfi	r1, r3, #0, #8
    c89c:	4a10      	ldr	r2, [pc, #64]	; (c8e0 <smp_timeout+0x50>)
    c89e:	4b11      	ldr	r3, [pc, #68]	; (c8e4 <smp_timeout+0x54>)
    c8a0:	1a9b      	subs	r3, r3, r2
{
    c8a2:	4604      	mov	r4, r0
    c8a4:	08db      	lsrs	r3, r3, #3
	BT_ERR("SMP Timeout");
    c8a6:	f363 118f 	bfi	r1, r3, #6, #10
	struct bt_smp *smp = CONTAINER_OF(work, struct bt_smp, work);
    c8aa:	f5a0 75be 	sub.w	r5, r0, #380	; 0x17c
	if (atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR) &&
    c8ae:	3ce8      	subs	r4, #232	; 0xe8
	BT_ERR("SMP Timeout");
    c8b0:	480d      	ldr	r0, [pc, #52]	; (c8e8 <smp_timeout+0x58>)
    c8b2:	f00d feae 	bl	1a612 <log_0>
	if (atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR) &&
    c8b6:	2102      	movs	r1, #2
    c8b8:	4620      	mov	r0, r4
    c8ba:	f00f ff35 	bl	1c728 <atomic_test_bit>
    c8be:	b128      	cbz	r0, c8cc <smp_timeout+0x3c>
	    smp->chan.chan.conn->le.keys) {
    c8c0:	682b      	ldr	r3, [r5, #0]
    c8c2:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
	if (atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR) &&
    c8c6:	b108      	cbz	r0, c8cc <smp_timeout+0x3c>
		bt_keys_clear(smp->chan.chan.conn->le.keys);
    c8c8:	f000 ff7a 	bl	d7c0 <bt_keys_clear>
	atomic_set_bit(smp->flags, SMP_FLAG_TIMEOUT);
    c8cc:	4620      	mov	r0, r4
    c8ce:	2104      	movs	r1, #4
    c8d0:	f00f ff1b 	bl	1c70a <atomic_set_bit>
	smp_pairing_complete(smp, BT_SMP_ERR_UNSPECIFIED);
    c8d4:	4628      	mov	r0, r5
    c8d6:	2108      	movs	r1, #8
}
    c8d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	smp_pairing_complete(smp, BT_SMP_ERR_UNSPECIFIED);
    c8dc:	f7ff be94 	b.w	c608 <smp_pairing_complete>
    c8e0:	0001ed28 	.word	0x0001ed28
    c8e4:	0001ee18 	.word	0x0001ee18
    c8e8:	00021807 	.word	0x00021807

0000c8ec <smp_signing_info>:
{
    c8ec:	b570      	push	{r4, r5, r6, lr}
    c8ee:	460a      	mov	r2, r1
    c8f0:	4605      	mov	r5, r0
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    c8f2:	210c      	movs	r1, #12
	struct bt_conn *conn = smp->chan.chan.conn;
    c8f4:	f850 3b94 	ldr.w	r3, [r0], #148
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    c8f8:	f00f ff16 	bl	1c728 <atomic_test_bit>
    c8fc:	b320      	cbz	r0, c948 <smp_signing_info+0x5c>
					&conn->le.dst);
    c8fe:	f103 0670 	add.w	r6, r3, #112	; 0x70
		struct bt_smp_signing_info *req = (void *)buf->data;
    c902:	6894      	ldr	r4, [r2, #8]
		keys = bt_keys_get_type(BT_KEYS_REMOTE_CSRK, conn->id,
    c904:	7a19      	ldrb	r1, [r3, #8]
    c906:	4632      	mov	r2, r6
    c908:	2010      	movs	r0, #16
    c90a:	f010 fa77 	bl	1cdfc <bt_keys_get_type>
		if (!keys) {
    c90e:	b9b0      	cbnz	r0, c93e <smp_signing_info+0x52>
			BT_ERR("Unable to get keys for %s",
    c910:	2301      	movs	r3, #1
    c912:	f04f 0400 	mov.w	r4, #0
    c916:	4a14      	ldr	r2, [pc, #80]	; (c968 <smp_signing_info+0x7c>)
    c918:	f363 0407 	bfi	r4, r3, #0, #8
    c91c:	4b13      	ldr	r3, [pc, #76]	; (c96c <smp_signing_info+0x80>)
    c91e:	1a9b      	subs	r3, r3, r2
    c920:	08db      	lsrs	r3, r3, #3
    c922:	4630      	mov	r0, r6
    c924:	f363 148f 	bfi	r4, r3, #6, #10
    c928:	f7f8 fa48 	bl	4dbc <bt_addr_le_str_real>
    c92c:	f7f6 faaa 	bl	2e84 <log_strdup>
    c930:	4622      	mov	r2, r4
    c932:	4601      	mov	r1, r0
    c934:	480e      	ldr	r0, [pc, #56]	; (c970 <smp_signing_info+0x84>)
    c936:	f00d fe79 	bl	1a62c <log_1>
			return BT_SMP_ERR_UNSPECIFIED;
    c93a:	2008      	movs	r0, #8
}
    c93c:	bd70      	pop	{r4, r5, r6, pc}
		memcpy(keys->remote_csrk.val, req->csrk,
    c93e:	2210      	movs	r2, #16
    c940:	4621      	mov	r1, r4
    c942:	3050      	adds	r0, #80	; 0x50
    c944:	f00e fb59 	bl	1affa <memcpy>
	smp->remote_dist &= ~BT_SMP_DIST_SIGN;
    c948:	f895 3179 	ldrb.w	r3, [r5, #377]	; 0x179
    c94c:	f023 0304 	bic.w	r3, r3, #4
    c950:	f885 3179 	strb.w	r3, [r5, #377]	; 0x179
	if (!smp->local_dist && !smp->remote_dist) {
    c954:	f8b5 4178 	ldrh.w	r4, [r5, #376]	; 0x178
    c958:	b91c      	cbnz	r4, c962 <smp_signing_info+0x76>
		smp_pairing_complete(smp, 0);
    c95a:	4621      	mov	r1, r4
    c95c:	4628      	mov	r0, r5
    c95e:	f7ff fe53 	bl	c608 <smp_pairing_complete>
	return 0;
    c962:	2000      	movs	r0, #0
    c964:	e7ea      	b.n	c93c <smp_signing_info+0x50>
    c966:	bf00      	nop
    c968:	0001ed28 	.word	0x0001ed28
    c96c:	0001ee18 	.word	0x0001ee18
    c970:	00021763 	.word	0x00021763

0000c974 <smp_master_ident>:
{
    c974:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c976:	460a      	mov	r2, r1
    c978:	4604      	mov	r4, r0
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    c97a:	210c      	movs	r1, #12
	struct bt_conn *conn = smp->chan.chan.conn;
    c97c:	f850 3b94 	ldr.w	r3, [r0], #148
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    c980:	f00f fed2 	bl	1c728 <atomic_test_bit>
    c984:	b388      	cbz	r0, c9ea <smp_master_ident+0x76>
		keys = bt_keys_get_type(BT_KEYS_LTK, conn->id, &conn->le.dst);
    c986:	f103 0770 	add.w	r7, r3, #112	; 0x70
		struct bt_smp_master_ident *req = (void *)buf->data;
    c98a:	6896      	ldr	r6, [r2, #8]
		keys = bt_keys_get_type(BT_KEYS_LTK, conn->id, &conn->le.dst);
    c98c:	7a19      	ldrb	r1, [r3, #8]
    c98e:	463a      	mov	r2, r7
    c990:	2004      	movs	r0, #4
    c992:	f010 fa33 	bl	1cdfc <bt_keys_get_type>
		if (!keys) {
    c996:	4605      	mov	r5, r0
    c998:	b9b0      	cbnz	r0, c9c8 <smp_master_ident+0x54>
			BT_ERR("Unable to get keys for %s",
    c99a:	2301      	movs	r3, #1
    c99c:	f04f 0400 	mov.w	r4, #0
    c9a0:	4a1d      	ldr	r2, [pc, #116]	; (ca18 <smp_master_ident+0xa4>)
    c9a2:	f363 0407 	bfi	r4, r3, #0, #8
    c9a6:	4b1d      	ldr	r3, [pc, #116]	; (ca1c <smp_master_ident+0xa8>)
    c9a8:	1a9b      	subs	r3, r3, r2
    c9aa:	08db      	lsrs	r3, r3, #3
    c9ac:	4638      	mov	r0, r7
    c9ae:	f363 148f 	bfi	r4, r3, #6, #10
    c9b2:	f7f8 fa03 	bl	4dbc <bt_addr_le_str_real>
    c9b6:	f7f6 fa65 	bl	2e84 <log_strdup>
    c9ba:	4622      	mov	r2, r4
    c9bc:	4601      	mov	r1, r0
    c9be:	4818      	ldr	r0, [pc, #96]	; (ca20 <smp_master_ident+0xac>)
    c9c0:	f00d fe34 	bl	1a62c <log_1>
			return BT_SMP_ERR_UNSPECIFIED;
    c9c4:	2008      	movs	r0, #8
}
    c9c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		memcpy(keys->ltk.ediv, req->ediv, sizeof(keys->ltk.ediv));
    c9c8:	2202      	movs	r2, #2
    c9ca:	4631      	mov	r1, r6
    c9cc:	3014      	adds	r0, #20
    c9ce:	f00e fb14 	bl	1affa <memcpy>
		memcpy(keys->ltk.rand, req->rand, sizeof(req->rand));
    c9d2:	2208      	movs	r2, #8
    c9d4:	1cb1      	adds	r1, r6, #2
    c9d6:	f105 000c 	add.w	r0, r5, #12
    c9da:	f00e fb0e 	bl	1affa <memcpy>
		smp->remote_dist &= ~BT_SMP_DIST_ENC_KEY;
    c9de:	f894 3179 	ldrb.w	r3, [r4, #377]	; 0x179
    c9e2:	f023 0301 	bic.w	r3, r3, #1
    c9e6:	f884 3179 	strb.w	r3, [r4, #377]	; 0x179
	if (smp->remote_dist & BT_SMP_DIST_ID_KEY) {
    c9ea:	f894 3179 	ldrb.w	r3, [r4, #377]	; 0x179
    c9ee:	079a      	lsls	r2, r3, #30
    c9f0:	d50d      	bpl.n	ca0e <smp_master_ident+0x9a>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_IDENT_INFO);
    c9f2:	2108      	movs	r1, #8
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
    c9f4:	f104 0090 	add.w	r0, r4, #144	; 0x90
    c9f8:	f00f fe87 	bl	1c70a <atomic_set_bit>
	if (!smp->local_dist && !smp->remote_dist) {
    c9fc:	f8b4 5178 	ldrh.w	r5, [r4, #376]	; 0x178
    ca00:	b91d      	cbnz	r5, ca0a <smp_master_ident+0x96>
		smp_pairing_complete(smp, 0);
    ca02:	4629      	mov	r1, r5
    ca04:	4620      	mov	r0, r4
    ca06:	f7ff fdff 	bl	c608 <smp_pairing_complete>
	return 0;
    ca0a:	2000      	movs	r0, #0
    ca0c:	e7db      	b.n	c9c6 <smp_master_ident+0x52>
	} else if (smp->remote_dist & BT_SMP_DIST_SIGN) {
    ca0e:	075b      	lsls	r3, r3, #29
    ca10:	d5f4      	bpl.n	c9fc <smp_master_ident+0x88>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
    ca12:	210a      	movs	r1, #10
    ca14:	e7ee      	b.n	c9f4 <smp_master_ident+0x80>
    ca16:	bf00      	nop
    ca18:	0001ed28 	.word	0x0001ed28
    ca1c:	0001ee18 	.word	0x0001ee18
    ca20:	00021763 	.word	0x00021763

0000ca24 <bt_smp_connected>:
{
    ca24:	b510      	push	{r4, lr}
	k_delayed_work_init(&smp->work, smp_timeout);
    ca26:	4905      	ldr	r1, [pc, #20]	; (ca3c <bt_smp_connected+0x18>)
{
    ca28:	4604      	mov	r4, r0
	k_delayed_work_init(&smp->work, smp_timeout);
    ca2a:	f500 70be 	add.w	r0, r0, #380	; 0x17c
    ca2e:	f011 fe8b 	bl	1e748 <k_delayed_work_init>
	smp_reset(smp);
    ca32:	4620      	mov	r0, r4
}
    ca34:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	smp_reset(smp);
    ca38:	f00f bfcd 	b.w	1c9d6 <smp_reset>
    ca3c:	0000c891 	.word	0x0000c891

0000ca40 <bt_smp_encrypt_change>:
{
    ca40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct bt_conn *conn = chan->conn;
    ca44:	4605      	mov	r5, r0
{
    ca46:	460f      	mov	r7, r1
	struct bt_conn *conn = chan->conn;
    ca48:	f855 6b94 	ldr.w	r6, [r5], #148
{
    ca4c:	b089      	sub	sp, #36	; 0x24
    ca4e:	4604      	mov	r4, r0
	atomic_clear_bit(smp->flags, SMP_FLAG_ENC_PENDING);
    ca50:	2101      	movs	r1, #1
    ca52:	4628      	mov	r0, r5
    ca54:	f00f fefe 	bl	1c854 <atomic_clear_bit>
	if (hci_status) {
    ca58:	b947      	cbnz	r7, ca6c <bt_smp_encrypt_change+0x2c>
	if (!conn->encrypt) {
    ca5a:	7af3      	ldrb	r3, [r6, #11]
    ca5c:	b133      	cbz	r3, ca6c <bt_smp_encrypt_change+0x2c>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
    ca5e:	2103      	movs	r1, #3
    ca60:	f00f fe62 	bl	1c728 <atomic_test_bit>
    ca64:	b928      	cbnz	r0, ca72 <bt_smp_encrypt_change+0x32>
		smp_reset(smp);
    ca66:	4620      	mov	r0, r4
    ca68:	f00f ffb5 	bl	1c9d6 <smp_reset>
}
    ca6c:	b009      	add	sp, #36	; 0x24
    ca6e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    ca72:	2105      	movs	r1, #5
    ca74:	4628      	mov	r0, r5
    ca76:	f00f fe57 	bl	1c728 <atomic_test_bit>
    ca7a:	b198      	cbz	r0, caa4 <bt_smp_encrypt_change+0x64>
		if ((smp->local_dist & BT_SMP_DIST_LINK_KEY) &&
    ca7c:	f894 3178 	ldrb.w	r3, [r4, #376]	; 0x178
    ca80:	071a      	lsls	r2, r3, #28
    ca82:	d507      	bpl.n	ca94 <bt_smp_encrypt_change+0x54>
    ca84:	f894 3179 	ldrb.w	r3, [r4, #377]	; 0x179
    ca88:	071b      	lsls	r3, r3, #28
    ca8a:	d503      	bpl.n	ca94 <bt_smp_encrypt_change+0x54>
			atomic_set_bit(smp->flags, SMP_FLAG_DERIVE_LK);
    ca8c:	2110      	movs	r1, #16
    ca8e:	4628      	mov	r0, r5
    ca90:	f00f fe3b 	bl	1c70a <atomic_set_bit>
		smp->local_dist &= ~BT_SMP_DIST_LINK_KEY;
    ca94:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
    ca98:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    ca9c:	f023 0308 	bic.w	r3, r3, #8
    caa0:	f8a4 3178 	strh.w	r3, [r4, #376]	; 0x178
	if (smp->remote_dist & BT_SMP_DIST_ENC_KEY) {
    caa4:	f894 3179 	ldrb.w	r3, [r4, #377]	; 0x179
    caa8:	07df      	lsls	r7, r3, #31
    caaa:	d524      	bpl.n	caf6 <bt_smp_encrypt_change+0xb6>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_ENCRYPT_INFO);
    caac:	2106      	movs	r1, #6
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
    caae:	f104 0090 	add.w	r0, r4, #144	; 0x90
    cab2:	f00f fe2a 	bl	1c70a <atomic_set_bit>
	atomic_set_bit(smp->flags, SMP_FLAG_KEYS_DISTR);
    cab6:	2102      	movs	r1, #2
    cab8:	4628      	mov	r0, r5
    caba:	f00f fe26 	bl	1c70a <atomic_set_bit>
	struct bt_conn *conn = smp->chan.chan.conn;
    cabe:	f8d4 8000 	ldr.w	r8, [r4]
	struct bt_keys *keys = conn->le.keys;
    cac2:	f8d8 709c 	ldr.w	r7, [r8, #156]	; 0x9c
	if (!keys) {
    cac6:	b9f7      	cbnz	r7, cb06 <bt_smp_encrypt_change+0xc6>
		BT_ERR("No keys space for %s", bt_addr_le_str(&conn->le.dst));
    cac8:	2301      	movs	r3, #1
    caca:	f04f 0400 	mov.w	r4, #0
    cace:	4a96      	ldr	r2, [pc, #600]	; (cd28 <bt_smp_encrypt_change+0x2e8>)
    cad0:	f363 0407 	bfi	r4, r3, #0, #8
    cad4:	4b95      	ldr	r3, [pc, #596]	; (cd2c <bt_smp_encrypt_change+0x2ec>)
    cad6:	1a9b      	subs	r3, r3, r2
    cad8:	08db      	lsrs	r3, r3, #3
    cada:	f108 0070 	add.w	r0, r8, #112	; 0x70
    cade:	f363 148f 	bfi	r4, r3, #6, #10
    cae2:	f7f8 f96b 	bl	4dbc <bt_addr_le_str_real>
    cae6:	f7f6 f9cd 	bl	2e84 <log_strdup>
    caea:	4622      	mov	r2, r4
    caec:	4601      	mov	r1, r0
    caee:	4890      	ldr	r0, [pc, #576]	; (cd30 <bt_smp_encrypt_change+0x2f0>)
    caf0:	f00d fd9c 	bl	1a62c <log_1>
		return BT_SMP_ERR_UNSPECIFIED;
    caf4:	e7ba      	b.n	ca6c <bt_smp_encrypt_change+0x2c>
	} else if (smp->remote_dist & BT_SMP_DIST_ID_KEY) {
    caf6:	079e      	lsls	r6, r3, #30
    caf8:	d501      	bpl.n	cafe <bt_smp_encrypt_change+0xbe>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_IDENT_INFO);
    cafa:	2108      	movs	r1, #8
    cafc:	e7d7      	b.n	caae <bt_smp_encrypt_change+0x6e>
	} else if (smp->remote_dist & BT_SMP_DIST_SIGN) {
    cafe:	0758      	lsls	r0, r3, #29
    cb00:	d5d9      	bpl.n	cab6 <bt_smp_encrypt_change+0x76>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
    cb02:	210a      	movs	r1, #10
    cb04:	e7d3      	b.n	caae <bt_smp_encrypt_change+0x6e>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    cb06:	2105      	movs	r1, #5
    cb08:	f00f fe0e 	bl	1c728 <atomic_test_bit>
    cb0c:	4682      	mov	sl, r0
    cb0e:	b9f0      	cbnz	r0, cb4e <bt_smp_encrypt_change+0x10e>
	if (smp->local_dist & BT_SMP_DIST_ENC_KEY) {
    cb10:	f894 3178 	ldrb.w	r3, [r4, #376]	; 0x178
    cb14:	07d9      	lsls	r1, r3, #31
    cb16:	d51a      	bpl.n	cb4e <bt_smp_encrypt_change+0x10e>
	struct bt_keys *keys = conn->le.keys;
    cb18:	6823      	ldr	r3, [r4, #0]
		bt_rand((void *)&rand, sizeof(rand));
    cb1a:	211a      	movs	r1, #26
    cb1c:	a801      	add	r0, sp, #4
	struct bt_keys *keys = conn->le.keys;
    cb1e:	f8d3 609c 	ldr.w	r6, [r3, #156]	; 0x9c
		bt_rand((void *)&rand, sizeof(rand));
    cb22:	f002 ff9d 	bl	fa60 <bt_rand>
		buf = smp_create_pdu(smp, BT_SMP_CMD_ENCRYPT_INFO,
    cb26:	2106      	movs	r1, #6
    cb28:	4620      	mov	r0, r4
    cb2a:	f00f febd 	bl	1c8a8 <smp_create_pdu.isra.6>
		if (!buf) {
    cb2e:	4681      	mov	r9, r0
    cb30:	bb40      	cbnz	r0, cb84 <bt_smp_encrypt_change+0x144>
			BT_ERR("Unable to allocate Encrypt Info buffer");
    cb32:	2301      	movs	r3, #1
    cb34:	f04f 0100 	mov.w	r1, #0
    cb38:	f363 0107 	bfi	r1, r3, #0, #8
    cb3c:	4a7a      	ldr	r2, [pc, #488]	; (cd28 <bt_smp_encrypt_change+0x2e8>)
    cb3e:	4b7b      	ldr	r3, [pc, #492]	; (cd2c <bt_smp_encrypt_change+0x2ec>)
    cb40:	487c      	ldr	r0, [pc, #496]	; (cd34 <bt_smp_encrypt_change+0x2f4>)
    cb42:	1a9b      	subs	r3, r3, r2
    cb44:	08db      	lsrs	r3, r3, #3
    cb46:	f363 118f 	bfi	r1, r3, #6, #10
			BT_ERR("Unable to allocate Master Ident buffer");
    cb4a:	f00d fd62 	bl	1a612 <log_0>
	if (smp->local_dist & BT_SMP_DIST_ID_KEY) {
    cb4e:	f894 3178 	ldrb.w	r3, [r4, #376]	; 0x178
    cb52:	079a      	lsls	r2, r3, #30
    cb54:	f140 80a9 	bpl.w	ccaa <bt_smp_encrypt_change+0x26a>
		buf = smp_create_pdu(smp, BT_SMP_CMD_IDENT_INFO,
    cb58:	2108      	movs	r1, #8
    cb5a:	4620      	mov	r0, r4
    cb5c:	f00f fea4 	bl	1c8a8 <smp_create_pdu.isra.6>
		if (!buf) {
    cb60:	4606      	mov	r6, r0
    cb62:	2800      	cmp	r0, #0
    cb64:	d169      	bne.n	cc3a <bt_smp_encrypt_change+0x1fa>
			BT_ERR("Unable to allocate Ident Info buffer");
    cb66:	2301      	movs	r3, #1
    cb68:	f04f 0100 	mov.w	r1, #0
    cb6c:	f363 0107 	bfi	r1, r3, #0, #8
    cb70:	4a6d      	ldr	r2, [pc, #436]	; (cd28 <bt_smp_encrypt_change+0x2e8>)
    cb72:	4b6e      	ldr	r3, [pc, #440]	; (cd2c <bt_smp_encrypt_change+0x2ec>)
    cb74:	4870      	ldr	r0, [pc, #448]	; (cd38 <bt_smp_encrypt_change+0x2f8>)
    cb76:	1a9b      	subs	r3, r3, r2
    cb78:	08db      	lsrs	r3, r3, #3
    cb7a:	f363 118f 	bfi	r1, r3, #6, #10
			BT_ERR("Unable to allocate Ident Addr Info buffer");
    cb7e:	f00d fd48 	bl	1a612 <log_0>
			return BT_SMP_ERR_UNSPECIFIED;
    cb82:	e773      	b.n	ca6c <bt_smp_encrypt_change+0x2c>
		info = net_buf_add(buf, sizeof(*info));
    cb84:	2110      	movs	r1, #16
    cb86:	3008      	adds	r0, #8
    cb88:	f011 f860 	bl	1dc4c <net_buf_simple_add>
		memcpy(info->ltk, rand.key, keys->enc_size);
    cb8c:	7a32      	ldrb	r2, [r6, #8]
    cb8e:	a901      	add	r1, sp, #4
		info = net_buf_add(buf, sizeof(*info));
    cb90:	4683      	mov	fp, r0
		memcpy(info->ltk, rand.key, keys->enc_size);
    cb92:	f00e fa32 	bl	1affa <memcpy>
		if (keys->enc_size < sizeof(info->ltk)) {
    cb96:	7a30      	ldrb	r0, [r6, #8]
    cb98:	280f      	cmp	r0, #15
    cb9a:	d805      	bhi.n	cba8 <bt_smp_encrypt_change+0x168>
			(void)memset(info->ltk + keys->enc_size, 0,
    cb9c:	f1c0 0210 	rsb	r2, r0, #16
    cba0:	4651      	mov	r1, sl
    cba2:	4458      	add	r0, fp
    cba4:	f00e fa53 	bl	1b04e <memset>
		smp_send(smp, buf, NULL, NULL);
    cba8:	4649      	mov	r1, r9
    cbaa:	2200      	movs	r2, #0
    cbac:	4620      	mov	r0, r4
    cbae:	f7ff f939 	bl	be24 <smp_send.isra.7>
		buf = smp_create_pdu(smp, BT_SMP_CMD_MASTER_IDENT,
    cbb2:	2107      	movs	r1, #7
    cbb4:	4620      	mov	r0, r4
    cbb6:	f00f fe77 	bl	1c8a8 <smp_create_pdu.isra.6>
		if (!buf) {
    cbba:	4681      	mov	r9, r0
    cbbc:	b960      	cbnz	r0, cbd8 <bt_smp_encrypt_change+0x198>
			BT_ERR("Unable to allocate Master Ident buffer");
    cbbe:	2301      	movs	r3, #1
    cbc0:	f04f 0100 	mov.w	r1, #0
    cbc4:	f363 0107 	bfi	r1, r3, #0, #8
    cbc8:	4a57      	ldr	r2, [pc, #348]	; (cd28 <bt_smp_encrypt_change+0x2e8>)
    cbca:	4b58      	ldr	r3, [pc, #352]	; (cd2c <bt_smp_encrypt_change+0x2ec>)
    cbcc:	485b      	ldr	r0, [pc, #364]	; (cd3c <bt_smp_encrypt_change+0x2fc>)
    cbce:	1a9b      	subs	r3, r3, r2
    cbd0:	08db      	lsrs	r3, r3, #3
    cbd2:	f363 118f 	bfi	r1, r3, #6, #10
    cbd6:	e7b8      	b.n	cb4a <bt_smp_encrypt_change+0x10a>
		ident = net_buf_add(buf, sizeof(*ident));
    cbd8:	210a      	movs	r1, #10
    cbda:	3008      	adds	r0, #8
    cbdc:	f011 f836 	bl	1dc4c <net_buf_simple_add>
		memcpy(ident->rand, rand.rand, sizeof(ident->rand));
    cbe0:	2208      	movs	r2, #8
		ident = net_buf_add(buf, sizeof(*ident));
    cbe2:	4682      	mov	sl, r0
		memcpy(ident->rand, rand.rand, sizeof(ident->rand));
    cbe4:	a905      	add	r1, sp, #20
    cbe6:	3002      	adds	r0, #2
    cbe8:	f00e fa07 	bl	1affa <memcpy>
		memcpy(ident->ediv, rand.ediv, sizeof(ident->ediv));
    cbec:	2202      	movs	r2, #2
    cbee:	a907      	add	r1, sp, #28
    cbf0:	4650      	mov	r0, sl
    cbf2:	f00e fa02 	bl	1affa <memcpy>
		smp_send(smp, buf, smp_ident_sent, NULL);
    cbf6:	4649      	mov	r1, r9
    cbf8:	4620      	mov	r0, r4
    cbfa:	4a51      	ldr	r2, [pc, #324]	; (cd40 <bt_smp_encrypt_change+0x300>)
    cbfc:	f7ff f912 	bl	be24 <smp_send.isra.7>
		if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    cc00:	210c      	movs	r1, #12
    cc02:	4628      	mov	r0, r5
    cc04:	f00f fd90 	bl	1c728 <atomic_test_bit>
    cc08:	2800      	cmp	r0, #0
    cc0a:	d0a0      	beq.n	cb4e <bt_smp_encrypt_change+0x10e>
			bt_keys_add_type(keys, BT_KEYS_SLAVE_LTK);
    cc0c:	4630      	mov	r0, r6
    cc0e:	2101      	movs	r1, #1
    cc10:	f010 f904 	bl	1ce1c <bt_keys_add_type>
			memcpy(keys->slave_ltk.val, rand.key,
    cc14:	a901      	add	r1, sp, #4
    cc16:	2210      	movs	r2, #16
    cc18:	f106 006e 	add.w	r0, r6, #110	; 0x6e
    cc1c:	f00e f9ed 	bl	1affa <memcpy>
			memcpy(keys->slave_ltk.rand, rand.rand,
    cc20:	a905      	add	r1, sp, #20
    cc22:	2208      	movs	r2, #8
    cc24:	f106 0064 	add.w	r0, r6, #100	; 0x64
    cc28:	f00e f9e7 	bl	1affa <memcpy>
			memcpy(keys->slave_ltk.ediv, rand.ediv,
    cc2c:	2202      	movs	r2, #2
    cc2e:	a907      	add	r1, sp, #28
    cc30:	f106 006c 	add.w	r0, r6, #108	; 0x6c
    cc34:	f00e f9e1 	bl	1affa <memcpy>
    cc38:	e789      	b.n	cb4e <bt_smp_encrypt_change+0x10e>
		id_info = net_buf_add(buf, sizeof(*id_info));
    cc3a:	2110      	movs	r1, #16
    cc3c:	3008      	adds	r0, #8
    cc3e:	f011 f805 	bl	1dc4c <net_buf_simple_add>
		memcpy(id_info->irk, bt_dev.irk[conn->id], 16);
    cc42:	f898 1008 	ldrb.w	r1, [r8, #8]
    cc46:	f8df 910c 	ldr.w	r9, [pc, #268]	; cd54 <bt_smp_encrypt_change+0x314>
    cc4a:	23d8      	movs	r3, #216	; 0xd8
    cc4c:	2210      	movs	r2, #16
    cc4e:	fb12 3101 	smlabb	r1, r2, r1, r3
    cc52:	4449      	add	r1, r9
    cc54:	f00e f9d1 	bl	1affa <memcpy>
		smp_send(smp, buf, NULL, NULL);
    cc58:	4631      	mov	r1, r6
    cc5a:	2200      	movs	r2, #0
    cc5c:	4620      	mov	r0, r4
    cc5e:	f7ff f8e1 	bl	be24 <smp_send.isra.7>
		buf = smp_create_pdu(smp, BT_SMP_CMD_IDENT_ADDR_INFO,
    cc62:	2109      	movs	r1, #9
    cc64:	4620      	mov	r0, r4
    cc66:	f00f fe1f 	bl	1c8a8 <smp_create_pdu.isra.6>
		if (!buf) {
    cc6a:	4606      	mov	r6, r0
    cc6c:	b960      	cbnz	r0, cc88 <bt_smp_encrypt_change+0x248>
			BT_ERR("Unable to allocate Ident Addr Info buffer");
    cc6e:	2301      	movs	r3, #1
    cc70:	f04f 0100 	mov.w	r1, #0
    cc74:	f363 0107 	bfi	r1, r3, #0, #8
    cc78:	4a2b      	ldr	r2, [pc, #172]	; (cd28 <bt_smp_encrypt_change+0x2e8>)
    cc7a:	4b2c      	ldr	r3, [pc, #176]	; (cd2c <bt_smp_encrypt_change+0x2ec>)
    cc7c:	4831      	ldr	r0, [pc, #196]	; (cd44 <bt_smp_encrypt_change+0x304>)
    cc7e:	1a9b      	subs	r3, r3, r2
    cc80:	08db      	lsrs	r3, r3, #3
    cc82:	f363 118f 	bfi	r1, r3, #6, #10
    cc86:	e77a      	b.n	cb7e <bt_smp_encrypt_change+0x13e>
		id_addr_info = net_buf_add(buf, sizeof(*id_addr_info));
    cc88:	2107      	movs	r1, #7
    cc8a:	3008      	adds	r0, #8
    cc8c:	f010 ffde 	bl	1dc4c <net_buf_simple_add>
		bt_addr_le_copy(&id_addr_info->addr, &bt_dev.id_addr[conn->id]);
    cc90:	f898 1008 	ldrb.w	r1, [r8, #8]
    cc94:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
	memcpy(dst, src, sizeof(*dst));
    cc98:	2207      	movs	r2, #7
    cc9a:	4449      	add	r1, r9
    cc9c:	f00e f9ad 	bl	1affa <memcpy>
		smp_send(smp, buf, smp_id_sent, NULL);
    cca0:	4a29      	ldr	r2, [pc, #164]	; (cd48 <bt_smp_encrypt_change+0x308>)
    cca2:	4631      	mov	r1, r6
    cca4:	4620      	mov	r0, r4
    cca6:	f7ff f8bd 	bl	be24 <smp_send.isra.7>
	if (smp->local_dist & BT_SMP_DIST_SIGN) {
    ccaa:	f894 3178 	ldrb.w	r3, [r4, #376]	; 0x178
    ccae:	075b      	lsls	r3, r3, #29
    ccb0:	d530      	bpl.n	cd14 <bt_smp_encrypt_change+0x2d4>
		buf = smp_create_pdu(smp, BT_SMP_CMD_SIGNING_INFO,
    ccb2:	210a      	movs	r1, #10
    ccb4:	4620      	mov	r0, r4
    ccb6:	f00f fdf7 	bl	1c8a8 <smp_create_pdu.isra.6>
		if (!buf) {
    ccba:	4606      	mov	r6, r0
    ccbc:	b960      	cbnz	r0, ccd8 <bt_smp_encrypt_change+0x298>
			BT_ERR("Unable to allocate Signing Info buffer");
    ccbe:	2301      	movs	r3, #1
    ccc0:	f04f 0100 	mov.w	r1, #0
    ccc4:	f363 0107 	bfi	r1, r3, #0, #8
    ccc8:	4a17      	ldr	r2, [pc, #92]	; (cd28 <bt_smp_encrypt_change+0x2e8>)
    ccca:	4b18      	ldr	r3, [pc, #96]	; (cd2c <bt_smp_encrypt_change+0x2ec>)
    cccc:	481f      	ldr	r0, [pc, #124]	; (cd4c <bt_smp_encrypt_change+0x30c>)
    ccce:	1a9b      	subs	r3, r3, r2
    ccd0:	08db      	lsrs	r3, r3, #3
    ccd2:	f363 118f 	bfi	r1, r3, #6, #10
    ccd6:	e752      	b.n	cb7e <bt_smp_encrypt_change+0x13e>
		info = net_buf_add(buf, sizeof(*info));
    ccd8:	2110      	movs	r1, #16
    ccda:	3008      	adds	r0, #8
    ccdc:	f010 ffb6 	bl	1dc4c <net_buf_simple_add>
		bt_rand(info->csrk, sizeof(info->csrk));
    cce0:	2110      	movs	r1, #16
		info = net_buf_add(buf, sizeof(*info));
    cce2:	4680      	mov	r8, r0
		bt_rand(info->csrk, sizeof(info->csrk));
    cce4:	f002 febc 	bl	fa60 <bt_rand>
		if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    cce8:	210c      	movs	r1, #12
    ccea:	4628      	mov	r0, r5
    ccec:	f00f fd1c 	bl	1c728 <atomic_test_bit>
    ccf0:	b158      	cbz	r0, cd0a <bt_smp_encrypt_change+0x2ca>
			bt_keys_add_type(keys, BT_KEYS_LOCAL_CSRK);
    ccf2:	2108      	movs	r1, #8
    ccf4:	4638      	mov	r0, r7
    ccf6:	f010 f891 	bl	1ce1c <bt_keys_add_type>
			memcpy(keys->local_csrk.val, info->csrk, 16);
    ccfa:	2210      	movs	r2, #16
    ccfc:	4641      	mov	r1, r8
    ccfe:	f107 003c 	add.w	r0, r7, #60	; 0x3c
    cd02:	f00e f97a 	bl	1affa <memcpy>
			keys->local_csrk.cnt = 0U;
    cd06:	2300      	movs	r3, #0
    cd08:	64fb      	str	r3, [r7, #76]	; 0x4c
		smp_send(smp, buf, smp_sign_info_sent, NULL);
    cd0a:	4a11      	ldr	r2, [pc, #68]	; (cd50 <bt_smp_encrypt_change+0x310>)
    cd0c:	4631      	mov	r1, r6
    cd0e:	4620      	mov	r0, r4
    cd10:	f7ff f888 	bl	be24 <smp_send.isra.7>
	if (!smp->local_dist && !smp->remote_dist) {
    cd14:	f8b4 1178 	ldrh.w	r1, [r4, #376]	; 0x178
    cd18:	2900      	cmp	r1, #0
    cd1a:	f47f aea7 	bne.w	ca6c <bt_smp_encrypt_change+0x2c>
		smp_pairing_complete(smp, 0);
    cd1e:	4620      	mov	r0, r4
    cd20:	f7ff fc72 	bl	c608 <smp_pairing_complete>
    cd24:	e6a2      	b.n	ca6c <bt_smp_encrypt_change+0x2c>
    cd26:	bf00      	nop
    cd28:	0001ed28 	.word	0x0001ed28
    cd2c:	0001ee18 	.word	0x0001ee18
    cd30:	000214b8 	.word	0x000214b8
    cd34:	000214cd 	.word	0x000214cd
    cd38:	0002151b 	.word	0x0002151b
    cd3c:	000214f4 	.word	0x000214f4
    cd40:	0001ca8f 	.word	0x0001ca8f
    cd44:	00021540 	.word	0x00021540
    cd48:	0001caa9 	.word	0x0001caa9
    cd4c:	0002156a 	.word	0x0002156a
    cd50:	0001ca9b 	.word	0x0001ca9b
    cd54:	20005438 	.word	0x20005438

0000cd58 <smp_pairing_random>:
{
    cd58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    cd5c:	4604      	mov	r4, r0
	memcpy(smp->rrnd, req->val, sizeof(smp->rrnd));
    cd5e:	f100 07c7 	add.w	r7, r0, #199	; 0xc7
{
    cd62:	b09e      	sub	sp, #120	; 0x78
	memcpy(smp->rrnd, req->val, sizeof(smp->rrnd));
    cd64:	6889      	ldr	r1, [r1, #8]
    cd66:	2210      	movs	r2, #16
    cd68:	4638      	mov	r0, r7
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    cd6a:	f104 0694 	add.w	r6, r4, #148	; 0x94
	memcpy(smp->rrnd, req->val, sizeof(smp->rrnd));
    cd6e:	f00e f944 	bl	1affa <memcpy>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    cd72:	2105      	movs	r1, #5
    cd74:	4630      	mov	r0, r6
    cd76:	f00f fcd7 	bl	1c728 <atomic_test_bit>
    cd7a:	2800      	cmp	r0, #0
    cd7c:	d13d      	bne.n	cdfa <smp_pairing_random+0xa2>
	struct bt_conn *conn = smp->chan.chan.conn;
    cd7e:	46a0      	mov	r8, r4
	err = smp_c1(smp->tk, smp->rrnd, smp->preq, smp->prsp,
    cd80:	ad0a      	add	r5, sp, #40	; 0x28
	struct bt_conn *conn = smp->chan.chan.conn;
    cd82:	f858 3bd7 	ldr.w	r3, [r8], #215
	err = smp_c1(smp->tk, smp->rrnd, smp->preq, smp->prsp,
    cd86:	9502      	str	r5, [sp, #8]
		     &conn->le.init_addr, &conn->le.resp_addr, tmp);
    cd88:	f103 027e 	add.w	r2, r3, #126	; 0x7e
    cd8c:	3377      	adds	r3, #119	; 0x77
	err = smp_c1(smp->tk, smp->rrnd, smp->preq, smp->prsp,
    cd8e:	9201      	str	r2, [sp, #4]
    cd90:	9300      	str	r3, [sp, #0]
    cd92:	f104 0299 	add.w	r2, r4, #153	; 0x99
    cd96:	f104 03a0 	add.w	r3, r4, #160	; 0xa0
    cd9a:	4639      	mov	r1, r7
    cd9c:	4640      	mov	r0, r8
    cd9e:	f00f fe8a 	bl	1cab6 <smp_c1>
	if (err) {
    cda2:	b108      	cbz	r0, cda8 <smp_pairing_random+0x50>
		return BT_SMP_ERR_UNSPECIFIED;
    cda4:	2508      	movs	r5, #8
    cda6:	e096      	b.n	ced6 <smp_pairing_random+0x17e>
	if (memcmp(smp->pcnf, tmp, sizeof(smp->pcnf))) {
    cda8:	2210      	movs	r2, #16
    cdaa:	4629      	mov	r1, r5
    cdac:	f104 00a7 	add.w	r0, r4, #167	; 0xa7
    cdb0:	f00e f913 	bl	1afda <memcmp>
    cdb4:	2800      	cmp	r0, #0
    cdb6:	f040 808d 	bne.w	ced4 <smp_pairing_random+0x17c>
	memcpy(out, r2, 8);
    cdba:	2208      	movs	r2, #8
    cdbc:	4639      	mov	r1, r7
    cdbe:	4628      	mov	r0, r5
    cdc0:	f00e f91b 	bl	1affa <memcpy>
	memcpy(out + 8, r1, 8);
    cdc4:	2208      	movs	r2, #8
    cdc6:	f104 01b7 	add.w	r1, r4, #183	; 0xb7
    cdca:	a80c      	add	r0, sp, #48	; 0x30
    cdcc:	f00e f915 	bl	1affa <memcpy>
	return bt_encrypt_le(k, out, out);
    cdd0:	462a      	mov	r2, r5
    cdd2:	4629      	mov	r1, r5
    cdd4:	4640      	mov	r0, r8
    cdd6:	f010 fa63 	bl	1d2a0 <bt_encrypt_le>
		if (err) {
    cdda:	2800      	cmp	r0, #0
    cddc:	d1e2      	bne.n	cda4 <smp_pairing_random+0x4c>
		memcpy(smp->tk, tmp, sizeof(smp->tk));
    cdde:	4629      	mov	r1, r5
    cde0:	2210      	movs	r2, #16
    cde2:	4640      	mov	r0, r8
    cde4:	f00e f909 	bl	1affa <memcpy>
		atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
    cde8:	2101      	movs	r1, #1
	atomic_set_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT);
    cdea:	4630      	mov	r0, r6
    cdec:	f00f fc8d 	bl	1c70a <atomic_set_bit>
	return smp_send_pairing_random(smp);
    cdf0:	4620      	mov	r0, r4
    cdf2:	f00f fda1 	bl	1c938 <smp_send_pairing_random>
    cdf6:	4605      	mov	r5, r0
    cdf8:	e06d      	b.n	ced6 <smp_pairing_random+0x17e>
	switch (smp->method) {
    cdfa:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
    cdfe:	2b05      	cmp	r3, #5
    ce00:	d8d0      	bhi.n	cda4 <smp_pairing_random+0x4c>
    ce02:	a201      	add	r2, pc, #4	; (adr r2, ce08 <smp_pairing_random+0xb0>)
    ce04:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    ce08:	0000ce8f 	.word	0x0000ce8f
    ce0c:	0000ce9d 	.word	0x0000ce9d
    ce10:	0000ce9d 	.word	0x0000ce9d
    ce14:	0000ce21 	.word	0x0000ce21
    ce18:	0000cda5 	.word	0x0000cda5
    ce1c:	0000cf29 	.word	0x0000cf29
		if (smp_g2(smp->pkey, sc_public_key, smp->rrnd, smp->prnd,
    ce20:	4b5a      	ldr	r3, [pc, #360]	; (cf8c <smp_pairing_random+0x234>)
    ce22:	681d      	ldr	r5, [r3, #0]
	sys_memcpy_swap(m, u, 32);
    ce24:	2220      	movs	r2, #32
    ce26:	f104 01e7 	add.w	r1, r4, #231	; 0xe7
    ce2a:	a80a      	add	r0, sp, #40	; 0x28
    ce2c:	f00f fc54 	bl	1c6d8 <sys_memcpy_swap>
	sys_memcpy_swap(m + 32, v, 32);
    ce30:	2220      	movs	r2, #32
    ce32:	4629      	mov	r1, r5
    ce34:	a812      	add	r0, sp, #72	; 0x48
    ce36:	f00f fc4f 	bl	1c6d8 <sys_memcpy_swap>
	sys_memcpy_swap(m + 64, y, 16);
    ce3a:	2210      	movs	r2, #16
    ce3c:	f104 01b7 	add.w	r1, r4, #183	; 0xb7
    ce40:	a81a      	add	r0, sp, #104	; 0x68
    ce42:	f00f fc49 	bl	1c6d8 <sys_memcpy_swap>
	sys_memcpy_swap(xs, x, 16);
    ce46:	2210      	movs	r2, #16
    ce48:	4639      	mov	r1, r7
    ce4a:	a806      	add	r0, sp, #24
    ce4c:	f00f fc44 	bl	1c6d8 <sys_memcpy_swap>
	err = bt_smp_aes_cmac(xs, m, sizeof(m), xs);
    ce50:	ab06      	add	r3, sp, #24
    ce52:	2250      	movs	r2, #80	; 0x50
    ce54:	a90a      	add	r1, sp, #40	; 0x28
    ce56:	4618      	mov	r0, r3
    ce58:	f00f fc6f 	bl	1c73a <bt_smp_aes_cmac>
	if (err) {
    ce5c:	2800      	cmp	r0, #0
    ce5e:	d1a1      	bne.n	cda4 <smp_pairing_random+0x4c>
	memcpy(passkey, xs + 12, 4);
    ce60:	2204      	movs	r2, #4
    ce62:	a909      	add	r1, sp, #36	; 0x24
    ce64:	a805      	add	r0, sp, #20
    ce66:	f00e f8c8 	bl	1affa <memcpy>
	*passkey = sys_be32_to_cpu(*passkey) % 1000000;
    ce6a:	9b05      	ldr	r3, [sp, #20]
    ce6c:	4948      	ldr	r1, [pc, #288]	; (cf90 <smp_pairing_random+0x238>)
    ce6e:	ba1b      	rev	r3, r3
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
    ce70:	4630      	mov	r0, r6
	*passkey = sys_be32_to_cpu(*passkey) % 1000000;
    ce72:	fbb3 f2f1 	udiv	r2, r3, r1
    ce76:	fb01 3312 	mls	r3, r1, r2, r3
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
    ce7a:	2109      	movs	r1, #9
	*passkey = sys_be32_to_cpu(*passkey) % 1000000;
    ce7c:	9305      	str	r3, [sp, #20]
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
    ce7e:	f00f fc44 	bl	1c70a <atomic_set_bit>
		bt_auth->passkey_confirm(smp->chan.chan.conn, passkey);
    ce82:	4b44      	ldr	r3, [pc, #272]	; (cf94 <smp_pairing_random+0x23c>)
    ce84:	9905      	ldr	r1, [sp, #20]
    ce86:	681b      	ldr	r3, [r3, #0]
    ce88:	6820      	ldr	r0, [r4, #0]
    ce8a:	689b      	ldr	r3, [r3, #8]
    ce8c:	4798      	blx	r3
	atomic_set_bit(&smp->allowed_cmds, BT_SMP_DHKEY_CHECK);
    ce8e:	210d      	movs	r1, #13
    ce90:	f104 0090 	add.w	r0, r4, #144	; 0x90
    ce94:	f00f fc39 	bl	1c70a <atomic_set_bit>
	atomic_set_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT);
    ce98:	210f      	movs	r1, #15
    ce9a:	e7a6      	b.n	cdea <smp_pairing_random+0x92>
		r = (smp->passkey >> smp->passkey_round) & 0x01;
    ce9c:	f894 216c 	ldrb.w	r2, [r4, #364]	; 0x16c
    cea0:	f8d4 3168 	ldr.w	r3, [r4, #360]	; 0x168
	if (smp_f4(smp->pkey, sc_public_key, smp->rrnd, r, cfm)) {
    cea4:	4939      	ldr	r1, [pc, #228]	; (cf8c <smp_pairing_random+0x234>)
		r = (smp->passkey >> smp->passkey_round) & 0x01;
    cea6:	40d3      	lsrs	r3, r2
	if (smp_f4(smp->pkey, sc_public_key, smp->rrnd, r, cfm)) {
    cea8:	ad0a      	add	r5, sp, #40	; 0x28
		r = (smp->passkey >> smp->passkey_round) & 0x01;
    ceaa:	f003 0301 	and.w	r3, r3, #1
	if (smp_f4(smp->pkey, sc_public_key, smp->rrnd, r, cfm)) {
    ceae:	9500      	str	r5, [sp, #0]
    ceb0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    ceb4:	463a      	mov	r2, r7
    ceb6:	6809      	ldr	r1, [r1, #0]
    ceb8:	f104 00e7 	add.w	r0, r4, #231	; 0xe7
    cebc:	f00f fc59 	bl	1c772 <smp_f4>
    cec0:	2800      	cmp	r0, #0
    cec2:	f47f af6f 	bne.w	cda4 <smp_pairing_random+0x4c>
	if (memcmp(smp->pcnf, cfm, 16)) {
    cec6:	2210      	movs	r2, #16
    cec8:	4629      	mov	r1, r5
    ceca:	f104 00a7 	add.w	r0, r4, #167	; 0xa7
    cece:	f00e f884 	bl	1afda <memcmp>
    ced2:	b120      	cbz	r0, cede <smp_pairing_random+0x186>
		return BT_SMP_ERR_CONFIRM_FAILED;
    ced4:	2504      	movs	r5, #4
}
    ced6:	4628      	mov	r0, r5
    ced8:	b01e      	add	sp, #120	; 0x78
    ceda:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		atomic_set_bit(&smp->allowed_cmds,
    cede:	f104 0790 	add.w	r7, r4, #144	; 0x90
    cee2:	2103      	movs	r1, #3
    cee4:	4638      	mov	r0, r7
    cee6:	f00f fc10 	bl	1c70a <atomic_set_bit>
		err = smp_send_pairing_random(smp);
    ceea:	4620      	mov	r0, r4
    ceec:	f00f fd24 	bl	1c938 <smp_send_pairing_random>
		if (err) {
    cef0:	4605      	mov	r5, r0
    cef2:	2800      	cmp	r0, #0
    cef4:	d1ef      	bne.n	ced6 <smp_pairing_random+0x17e>
		smp->passkey_round++;
    cef6:	f894 316c 	ldrb.w	r3, [r4, #364]	; 0x16c
    cefa:	3301      	adds	r3, #1
    cefc:	b2db      	uxtb	r3, r3
		if (smp->passkey_round == 20U) {
    cefe:	2b14      	cmp	r3, #20
		smp->passkey_round++;
    cf00:	f884 316c 	strb.w	r3, [r4, #364]	; 0x16c
		if (smp->passkey_round == 20U) {
    cf04:	d108      	bne.n	cf18 <smp_pairing_random+0x1c0>
			atomic_set_bit(&smp->allowed_cmds, BT_SMP_DHKEY_CHECK);
    cf06:	4638      	mov	r0, r7
    cf08:	210d      	movs	r1, #13
    cf0a:	f00f fbfe 	bl	1c70a <atomic_set_bit>
			atomic_set_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT);
    cf0e:	210f      	movs	r1, #15
    cf10:	4630      	mov	r0, r6
    cf12:	f00f fbfa 	bl	1c70a <atomic_set_bit>
			return 0;
    cf16:	e7de      	b.n	ced6 <smp_pairing_random+0x17e>
		if (bt_rand(smp->prnd, 16)) {
    cf18:	2110      	movs	r1, #16
    cf1a:	f104 00b7 	add.w	r0, r4, #183	; 0xb7
    cf1e:	f002 fd9f 	bl	fa60 <bt_rand>
    cf22:	2800      	cmp	r0, #0
    cf24:	d0d7      	beq.n	ced6 <smp_pairing_random+0x17e>
    cf26:	e73d      	b.n	cda4 <smp_pairing_random+0x4c>
		if (bt_rand(smp->prnd, 16)) {
    cf28:	2110      	movs	r1, #16
    cf2a:	f104 00b7 	add.w	r0, r4, #183	; 0xb7
    cf2e:	f002 fd97 	bl	fa60 <bt_rand>
    cf32:	2800      	cmp	r0, #0
    cf34:	f47f af36 	bne.w	cda4 <smp_pairing_random+0x4c>
		if (bt_auth && bt_auth->oob_data_request) {
    cf38:	4f16      	ldr	r7, [pc, #88]	; (cf94 <smp_pairing_random+0x23c>)
    cf3a:	683b      	ldr	r3, [r7, #0]
    cf3c:	b303      	cbz	r3, cf80 <smp_pairing_random+0x228>
    cf3e:	68db      	ldr	r3, [r3, #12]
    cf40:	b1f3      	cbz	r3, cf80 <smp_pairing_random+0x228>
			struct bt_conn_oob_info info = {
    cf42:	4b15      	ldr	r3, [pc, #84]	; (cf98 <smp_pairing_random+0x240>)
		oob_config = req_oob_present ? BT_CONN_OOB_LOCAL_ONLY :
    cf44:	f894 209b 	ldrb.w	r2, [r4, #155]	; 0x9b
			struct bt_conn_oob_info info = {
    cf48:	881b      	ldrh	r3, [r3, #0]
    cf4a:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
	return ((rsp->oob_flag & BT_SMP_OOB_DATA_MASK) == BT_SMP_OOB_PRESENT);
    cf4e:	f894 30a2 	ldrb.w	r3, [r4, #162]	; 0xa2
		oob_config = req_oob_present ? BT_CONN_OOB_LOCAL_ONLY :
    cf52:	07d2      	lsls	r2, r2, #31
    cf54:	f003 0301 	and.w	r3, r3, #1
    cf58:	d414      	bmi.n	cf84 <smp_pairing_random+0x22c>
    cf5a:	2b00      	cmp	r3, #0
    cf5c:	bf14      	ite	ne
    cf5e:	2001      	movne	r0, #1
    cf60:	2003      	moveq	r0, #3
			smp->oobd_local = NULL;
    cf62:	2500      	movs	r5, #0
	info->lesc.oob_config = oob_config;
    cf64:	f88d 0029 	strb.w	r0, [sp, #41]	; 0x29
			smp->oobd_remote = NULL;
    cf68:	e9c4 555c 	strd	r5, r5, [r4, #368]	; 0x170
			atomic_set_bit(smp->flags, SMP_FLAG_OOB_PENDING);
    cf6c:	4630      	mov	r0, r6
    cf6e:	210b      	movs	r1, #11
    cf70:	f00f fbcb 	bl	1c70a <atomic_set_bit>
			bt_auth->oob_data_request(smp->chan.chan.conn, &info);
    cf74:	683b      	ldr	r3, [r7, #0]
    cf76:	6820      	ldr	r0, [r4, #0]
    cf78:	68db      	ldr	r3, [r3, #12]
    cf7a:	a90a      	add	r1, sp, #40	; 0x28
    cf7c:	4798      	blx	r3
			return 0;
    cf7e:	e7aa      	b.n	ced6 <smp_pairing_random+0x17e>
			return BT_SMP_ERR_OOB_NOT_AVAIL;
    cf80:	2502      	movs	r5, #2
    cf82:	e7a8      	b.n	ced6 <smp_pairing_random+0x17e>
				     BT_CONN_OOB_BOTH_PEERS :
    cf84:	2b00      	cmp	r3, #0
    cf86:	bf18      	it	ne
    cf88:	2002      	movne	r0, #2
    cf8a:	e7ea      	b.n	cf62 <smp_pairing_random+0x20a>
    cf8c:	20000670 	.word	0x20000670
    cf90:	000f4240 	.word	0x000f4240
    cf94:	2000029c 	.word	0x2000029c
    cf98:	0001eee0 	.word	0x0001eee0

0000cf9c <bt_smp_pkey_ready>:
{
    cf9c:	b508      	push	{r3, lr}
	sc_public_key = pkey;
    cf9e:	4b15      	ldr	r3, [pc, #84]	; (cff4 <bt_smp_pkey_ready+0x58>)
    cfa0:	6018      	str	r0, [r3, #0]
	if (!pkey) {
    cfa2:	b978      	cbnz	r0, cfc4 <bt_smp_pkey_ready+0x28>
		BT_WARN("Public key not available");
    cfa4:	2302      	movs	r3, #2
    cfa6:	f04f 0100 	mov.w	r1, #0
    cfaa:	f363 0107 	bfi	r1, r3, #0, #8
    cfae:	4a12      	ldr	r2, [pc, #72]	; (cff8 <bt_smp_pkey_ready+0x5c>)
    cfb0:	4b12      	ldr	r3, [pc, #72]	; (cffc <bt_smp_pkey_ready+0x60>)
    cfb2:	4813      	ldr	r0, [pc, #76]	; (d000 <bt_smp_pkey_ready+0x64>)
    cfb4:	1a9b      	subs	r3, r3, r2
    cfb6:	08db      	lsrs	r3, r3, #3
    cfb8:	f363 118f 	bfi	r1, r3, #6, #10
}
    cfbc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		BT_WARN("Public key not available");
    cfc0:	f00d bb27 	b.w	1a612 <log_0>
    cfc4:	480f      	ldr	r0, [pc, #60]	; (d004 <bt_smp_pkey_ready+0x68>)
    cfc6:	f00b fa5d 	bl	18484 <z_impl_k_sem_give>
		if (!atomic_test_bit(smp->flags, SMP_FLAG_PKEY_SEND)) {
    cfca:	2106      	movs	r1, #6
    cfcc:	480e      	ldr	r0, [pc, #56]	; (d008 <bt_smp_pkey_ready+0x6c>)
    cfce:	f00f fbab 	bl	1c728 <atomic_test_bit>
    cfd2:	b168      	cbz	r0, cff0 <bt_smp_pkey_ready+0x54>
	err = sc_send_public_key(smp);
    cfd4:	480d      	ldr	r0, [pc, #52]	; (d00c <bt_smp_pkey_ready+0x70>)
    cfd6:	f7ff fa95 	bl	c504 <sc_send_public_key>
	if (err) {
    cfda:	b918      	cbnz	r0, cfe4 <bt_smp_pkey_ready+0x48>
    cfdc:	480b      	ldr	r0, [pc, #44]	; (d00c <bt_smp_pkey_ready+0x70>)
    cfde:	f7fe ff77 	bl	bed0 <smp_public_key_slave.part.13>
		if (err) {
    cfe2:	b128      	cbz	r0, cff0 <bt_smp_pkey_ready+0x54>
			smp_error(smp, err);
    cfe4:	4601      	mov	r1, r0
}
    cfe6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
			smp_error(smp, err);
    cfea:	4808      	ldr	r0, [pc, #32]	; (d00c <bt_smp_pkey_ready+0x70>)
    cfec:	f00f bd1e 	b.w	1ca2c <smp_error>
}
    cff0:	bd08      	pop	{r3, pc}
    cff2:	bf00      	nop
    cff4:	20000670 	.word	0x20000670
    cff8:	0001ed28 	.word	0x0001ed28
    cffc:	0001ee18 	.word	0x0001ee18
    d000:	00021591 	.word	0x00021591
    d004:	20005c30 	.word	0x20005c30
    d008:	20000568 	.word	0x20000568
    d00c:	200004d4 	.word	0x200004d4

0000d010 <smp_ident_addr_info>:
{
    d010:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct bt_smp_ident_addr_info *req = (void *)buf->data;
    d014:	688e      	ldr	r6, [r1, #8]
	struct bt_conn *conn = smp->chan.chan.conn;
    d016:	6804      	ldr	r4, [r0, #0]
	return BT_ADDR_IS_RPA(&addr->a);
}

static inline bool bt_addr_le_is_identity(const bt_addr_le_t *addr)
{
	if (addr->type == BT_ADDR_LE_PUBLIC) {
    d018:	7833      	ldrb	r3, [r6, #0]
{
    d01a:	4605      	mov	r5, r0
    d01c:	b37b      	cbz	r3, d07e <smp_ident_addr_info+0x6e>
	if (!bt_addr_le_is_identity(&req->addr)) {
    d01e:	79b3      	ldrb	r3, [r6, #6]
    d020:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    d024:	2bc0      	cmp	r3, #192	; 0xc0
    d026:	d02a      	beq.n	d07e <smp_ident_addr_info+0x6e>
		BT_ERR("Invalid identity %s", bt_addr_le_str(&req->addr));
    d028:	2301      	movs	r3, #1
    d02a:	f04f 0700 	mov.w	r7, #0
    d02e:	f363 0707 	bfi	r7, r3, #0, #8
    d032:	4d49      	ldr	r5, [pc, #292]	; (d158 <smp_ident_addr_info+0x148>)
    d034:	4b49      	ldr	r3, [pc, #292]	; (d15c <smp_ident_addr_info+0x14c>)
    d036:	4630      	mov	r0, r6
    d038:	1aed      	subs	r5, r5, r3
    d03a:	f7f7 febf 	bl	4dbc <bt_addr_le_str_real>
    d03e:	f7f5 ff21 	bl	2e84 <log_strdup>
    d042:	f3c5 05c9 	ubfx	r5, r5, #3, #10
    d046:	f365 178f 	bfi	r7, r5, #6, #10
    d04a:	4601      	mov	r1, r0
    d04c:	463a      	mov	r2, r7
    d04e:	4844      	ldr	r0, [pc, #272]	; (d160 <smp_ident_addr_info+0x150>)
    d050:	f00d faec 	bl	1a62c <log_1>
		BT_ERR(" for %s", bt_addr_le_str(&conn->le.dst));
    d054:	f04f 0600 	mov.w	r6, #0
    d058:	2301      	movs	r3, #1
    d05a:	f104 0070 	add.w	r0, r4, #112	; 0x70
    d05e:	f363 0607 	bfi	r6, r3, #0, #8
    d062:	f7f7 feab 	bl	4dbc <bt_addr_le_str_real>
    d066:	f7f5 ff0d 	bl	2e84 <log_strdup>
    d06a:	f365 168f 	bfi	r6, r5, #6, #10
    d06e:	4601      	mov	r1, r0
    d070:	4632      	mov	r2, r6
    d072:	483c      	ldr	r0, [pc, #240]	; (d164 <smp_ident_addr_info+0x154>)
    d074:	f00d fada 	bl	1a62c <log_1>
		return BT_SMP_ERR_INVALID_PARAMS;
    d078:	200a      	movs	r0, #10
}
    d07a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    d07e:	210c      	movs	r1, #12
    d080:	f105 0094 	add.w	r0, r5, #148	; 0x94
    d084:	f00f fb50 	bl	1c728 <atomic_test_bit>
    d088:	2800      	cmp	r0, #0
    d08a:	d04b      	beq.n	d124 <smp_ident_addr_info+0x114>
		keys = bt_keys_get_type(BT_KEYS_IRK, conn->id, &conn->le.dst);
    d08c:	f104 0870 	add.w	r8, r4, #112	; 0x70
    d090:	4642      	mov	r2, r8
    d092:	7a21      	ldrb	r1, [r4, #8]
    d094:	2002      	movs	r0, #2
    d096:	f00f feb1 	bl	1cdfc <bt_keys_get_type>
		if (!keys) {
    d09a:	4607      	mov	r7, r0
    d09c:	b9b0      	cbnz	r0, d0cc <smp_ident_addr_info+0xbc>
			BT_ERR("Unable to get keys for %s",
    d09e:	2301      	movs	r3, #1
    d0a0:	f04f 0400 	mov.w	r4, #0
    d0a4:	4a2d      	ldr	r2, [pc, #180]	; (d15c <smp_ident_addr_info+0x14c>)
    d0a6:	f363 0407 	bfi	r4, r3, #0, #8
    d0aa:	4b2b      	ldr	r3, [pc, #172]	; (d158 <smp_ident_addr_info+0x148>)
    d0ac:	1a9b      	subs	r3, r3, r2
    d0ae:	08db      	lsrs	r3, r3, #3
    d0b0:	4640      	mov	r0, r8
    d0b2:	f363 148f 	bfi	r4, r3, #6, #10
    d0b6:	f7f7 fe81 	bl	4dbc <bt_addr_le_str_real>
    d0ba:	f7f5 fee3 	bl	2e84 <log_strdup>
    d0be:	4622      	mov	r2, r4
    d0c0:	4601      	mov	r1, r0
    d0c2:	4829      	ldr	r0, [pc, #164]	; (d168 <smp_ident_addr_info+0x158>)
    d0c4:	f00d fab2 	bl	1a62c <log_1>
			return BT_SMP_ERR_UNSPECIFIED;
    d0c8:	2008      	movs	r0, #8
    d0ca:	e7d6      	b.n	d07a <smp_ident_addr_info+0x6a>
		if (conn->role == BT_HCI_ROLE_MASTER) {
    d0cc:	78e3      	ldrb	r3, [r4, #3]
    d0ce:	2b00      	cmp	r3, #0
    d0d0:	d13e      	bne.n	d150 <smp_ident_addr_info+0x140>
			dst = &conn->le.resp_addr;
    d0d2:	f104 017e 	add.w	r1, r4, #126	; 0x7e
	if (addr->type != BT_ADDR_LE_RANDOM) {
    d0d6:	780b      	ldrb	r3, [r1, #0]
    d0d8:	2b01      	cmp	r3, #1
    d0da:	d120      	bne.n	d11e <smp_ident_addr_info+0x10e>
		if (bt_addr_le_is_rpa(dst)) {
    d0dc:	798b      	ldrb	r3, [r1, #6]
    d0de:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    d0e2:	2b40      	cmp	r3, #64	; 0x40
    d0e4:	d11b      	bne.n	d11e <smp_ident_addr_info+0x10e>
	memcpy(dst, src, sizeof(*dst));
    d0e6:	2206      	movs	r2, #6
    d0e8:	3101      	adds	r1, #1
    d0ea:	f107 0036 	add.w	r0, r7, #54	; 0x36
    d0ee:	f00d ff84 	bl	1affa <memcpy>
	if (addr->type == BT_ADDR_LE_PUBLIC) {
    d0f2:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    d0f6:	b193      	cbz	r3, d11e <smp_ident_addr_info+0x10e>
			if (!bt_addr_le_is_identity(&conn->le.dst)) {
    d0f8:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
    d0fc:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    d100:	2bc0      	cmp	r3, #192	; 0xc0
    d102:	d00c      	beq.n	d11e <smp_ident_addr_info+0x10e>
	memcpy(dst, src, sizeof(*dst));
    d104:	2207      	movs	r2, #7
    d106:	4631      	mov	r1, r6
    d108:	1c78      	adds	r0, r7, #1
    d10a:	f00d ff76 	bl	1affa <memcpy>
    d10e:	2207      	movs	r2, #7
    d110:	4631      	mov	r1, r6
    d112:	4640      	mov	r0, r8
    d114:	f00d ff71 	bl	1affa <memcpy>
				bt_conn_identity_resolved(conn);
    d118:	4620      	mov	r0, r4
    d11a:	f7fa fe69 	bl	7df0 <bt_conn_identity_resolved>
		bt_id_add(keys);
    d11e:	4638      	mov	r0, r7
    d120:	f7f9 fb32 	bl	6788 <bt_id_add>
	smp->remote_dist &= ~BT_SMP_DIST_ID_KEY;
    d124:	f895 3179 	ldrb.w	r3, [r5, #377]	; 0x179
    d128:	f023 0202 	bic.w	r2, r3, #2
	if (smp->remote_dist & BT_SMP_DIST_SIGN) {
    d12c:	075b      	lsls	r3, r3, #29
	smp->remote_dist &= ~BT_SMP_DIST_ID_KEY;
    d12e:	f885 2179 	strb.w	r2, [r5, #377]	; 0x179
	if (smp->remote_dist & BT_SMP_DIST_SIGN) {
    d132:	d504      	bpl.n	d13e <smp_ident_addr_info+0x12e>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
    d134:	210a      	movs	r1, #10
    d136:	f105 0090 	add.w	r0, r5, #144	; 0x90
    d13a:	f00f fae6 	bl	1c70a <atomic_set_bit>
	if (!smp->local_dist && !smp->remote_dist) {
    d13e:	f8b5 4178 	ldrh.w	r4, [r5, #376]	; 0x178
    d142:	b91c      	cbnz	r4, d14c <smp_ident_addr_info+0x13c>
		smp_pairing_complete(smp, 0);
    d144:	4621      	mov	r1, r4
    d146:	4628      	mov	r0, r5
    d148:	f7ff fa5e 	bl	c608 <smp_pairing_complete>
	return 0;
    d14c:	2000      	movs	r0, #0
    d14e:	e794      	b.n	d07a <smp_ident_addr_info+0x6a>
			dst = &conn->le.init_addr;
    d150:	f104 0177 	add.w	r1, r4, #119	; 0x77
    d154:	e7bf      	b.n	d0d6 <smp_ident_addr_info+0xc6>
    d156:	bf00      	nop
    d158:	0001ee18 	.word	0x0001ee18
    d15c:	0001ed28 	.word	0x0001ed28
    d160:	0002174f 	.word	0x0002174f
    d164:	00021666 	.word	0x00021666
    d168:	00021763 	.word	0x00021763

0000d16c <bt_smp_sign_verify>:
{
    d16c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	return buf->data + buf->len;
    d16e:	898b      	ldrh	r3, [r1, #12]
    d170:	460c      	mov	r4, r1
	memcpy(sig, net_buf_tail(buf) - sizeof(sig), sizeof(sig));
    d172:	6889      	ldr	r1, [r1, #8]
{
    d174:	4605      	mov	r5, r0
	memcpy(sig, net_buf_tail(buf) - sizeof(sig), sizeof(sig));
    d176:	3b0c      	subs	r3, #12
    d178:	4419      	add	r1, r3
    d17a:	220c      	movs	r2, #12
	keys = bt_keys_find(BT_KEYS_REMOTE_CSRK, conn->id, &conn->le.dst);
    d17c:	f105 0670 	add.w	r6, r5, #112	; 0x70
	memcpy(sig, net_buf_tail(buf) - sizeof(sig), sizeof(sig));
    d180:	a801      	add	r0, sp, #4
    d182:	f00d ff3a 	bl	1affa <memcpy>
	keys = bt_keys_find(BT_KEYS_REMOTE_CSRK, conn->id, &conn->le.dst);
    d186:	7a29      	ldrb	r1, [r5, #8]
    d188:	4632      	mov	r2, r6
    d18a:	2010      	movs	r0, #16
    d18c:	f000 fab6 	bl	d6fc <bt_keys_find>
	if (!keys) {
    d190:	4605      	mov	r5, r0
    d192:	b9c0      	cbnz	r0, d1c6 <bt_smp_sign_verify+0x5a>
		BT_ERR("Unable to find Remote CSRK for %s",
    d194:	2301      	movs	r3, #1
    d196:	f04f 0400 	mov.w	r4, #0
    d19a:	4a33      	ldr	r2, [pc, #204]	; (d268 <bt_smp_sign_verify+0xfc>)
    d19c:	f363 0407 	bfi	r4, r3, #0, #8
    d1a0:	4b32      	ldr	r3, [pc, #200]	; (d26c <bt_smp_sign_verify+0x100>)
    d1a2:	1a9b      	subs	r3, r3, r2
    d1a4:	08db      	lsrs	r3, r3, #3
    d1a6:	4630      	mov	r0, r6
    d1a8:	f363 148f 	bfi	r4, r3, #6, #10
    d1ac:	f7f7 fe06 	bl	4dbc <bt_addr_le_str_real>
    d1b0:	f7f5 fe68 	bl	2e84 <log_strdup>
    d1b4:	4622      	mov	r2, r4
    d1b6:	4601      	mov	r1, r0
    d1b8:	482d      	ldr	r0, [pc, #180]	; (d270 <bt_smp_sign_verify+0x104>)
    d1ba:	f00d fa37 	bl	1a62c <log_1>
		return -ENOENT;
    d1be:	f06f 0001 	mvn.w	r0, #1
}
    d1c2:	b004      	add	sp, #16
    d1c4:	bd70      	pop	{r4, r5, r6, pc}
	cnt = sys_cpu_to_le32(keys->remote_csrk.cnt);
    d1c6:	6e03      	ldr	r3, [r0, #96]	; 0x60
    d1c8:	9300      	str	r3, [sp, #0]
    d1ca:	89a3      	ldrh	r3, [r4, #12]
	memcpy(net_buf_tail(buf) - sizeof(sig), &cnt, sizeof(cnt));
    d1cc:	68a0      	ldr	r0, [r4, #8]
    d1ce:	3b0c      	subs	r3, #12
    d1d0:	2204      	movs	r2, #4
    d1d2:	4669      	mov	r1, sp
    d1d4:	4418      	add	r0, r3
    d1d6:	f00d ff10 	bl	1affa <memcpy>
	err = smp_sign_buf(keys->remote_csrk.val, buf->data,
    d1da:	89a2      	ldrh	r2, [r4, #12]
    d1dc:	68a1      	ldr	r1, [r4, #8]
    d1de:	3a0c      	subs	r2, #12
    d1e0:	b292      	uxth	r2, r2
    d1e2:	f105 0050 	add.w	r0, r5, #80	; 0x50
    d1e6:	f7fe fce3 	bl	bbb0 <smp_sign_buf>
	if (err) {
    d1ea:	b1b8      	cbz	r0, d21c <bt_smp_sign_verify+0xb0>
		BT_ERR("Unable to create signature for %s",
    d1ec:	2301      	movs	r3, #1
    d1ee:	f04f 0400 	mov.w	r4, #0
    d1f2:	4a1d      	ldr	r2, [pc, #116]	; (d268 <bt_smp_sign_verify+0xfc>)
    d1f4:	f363 0407 	bfi	r4, r3, #0, #8
    d1f8:	4b1c      	ldr	r3, [pc, #112]	; (d26c <bt_smp_sign_verify+0x100>)
    d1fa:	1a9b      	subs	r3, r3, r2
    d1fc:	08db      	lsrs	r3, r3, #3
    d1fe:	4630      	mov	r0, r6
    d200:	f363 148f 	bfi	r4, r3, #6, #10
    d204:	f7f7 fdda 	bl	4dbc <bt_addr_le_str_real>
    d208:	f7f5 fe3c 	bl	2e84 <log_strdup>
    d20c:	4622      	mov	r2, r4
    d20e:	4601      	mov	r1, r0
    d210:	4818      	ldr	r0, [pc, #96]	; (d274 <bt_smp_sign_verify+0x108>)
    d212:	f00d fa0b 	bl	1a62c <log_1>
		return -EIO;
    d216:	f06f 0004 	mvn.w	r0, #4
    d21a:	e7d2      	b.n	d1c2 <bt_smp_sign_verify+0x56>
    d21c:	89a3      	ldrh	r3, [r4, #12]
	if (memcmp(sig, net_buf_tail(buf) - sizeof(sig), sizeof(sig))) {
    d21e:	68a1      	ldr	r1, [r4, #8]
    d220:	3b0c      	subs	r3, #12
    d222:	220c      	movs	r2, #12
    d224:	4419      	add	r1, r3
    d226:	a801      	add	r0, sp, #4
    d228:	f00d fed7 	bl	1afda <memcmp>
    d22c:	b1b8      	cbz	r0, d25e <bt_smp_sign_verify+0xf2>
		BT_ERR("Unable to verify signature for %s",
    d22e:	2301      	movs	r3, #1
    d230:	f04f 0400 	mov.w	r4, #0
    d234:	4a0c      	ldr	r2, [pc, #48]	; (d268 <bt_smp_sign_verify+0xfc>)
    d236:	f363 0407 	bfi	r4, r3, #0, #8
    d23a:	4b0c      	ldr	r3, [pc, #48]	; (d26c <bt_smp_sign_verify+0x100>)
    d23c:	1a9b      	subs	r3, r3, r2
    d23e:	08db      	lsrs	r3, r3, #3
    d240:	4630      	mov	r0, r6
    d242:	f363 148f 	bfi	r4, r3, #6, #10
    d246:	f7f7 fdb9 	bl	4dbc <bt_addr_le_str_real>
    d24a:	f7f5 fe1b 	bl	2e84 <log_strdup>
    d24e:	4622      	mov	r2, r4
    d250:	4601      	mov	r1, r0
    d252:	4809      	ldr	r0, [pc, #36]	; (d278 <bt_smp_sign_verify+0x10c>)
    d254:	f00d f9ea 	bl	1a62c <log_1>
		return -EBADMSG;
    d258:	f06f 004c 	mvn.w	r0, #76	; 0x4c
    d25c:	e7b1      	b.n	d1c2 <bt_smp_sign_verify+0x56>
	keys->remote_csrk.cnt++;
    d25e:	6e2b      	ldr	r3, [r5, #96]	; 0x60
    d260:	3301      	adds	r3, #1
    d262:	662b      	str	r3, [r5, #96]	; 0x60
	return 0;
    d264:	e7ad      	b.n	d1c2 <bt_smp_sign_verify+0x56>
    d266:	bf00      	nop
    d268:	0001ed28 	.word	0x0001ed28
    d26c:	0001ee18 	.word	0x0001ee18
    d270:	0002164c 	.word	0x0002164c
    d274:	0002166e 	.word	0x0002166e
    d278:	00021690 	.word	0x00021690

0000d27c <bt_smp_sign>:
{
    d27c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	keys = bt_keys_find(BT_KEYS_LOCAL_CSRK, conn->id, &conn->le.dst);
    d27e:	f100 0670 	add.w	r6, r0, #112	; 0x70
{
    d282:	460d      	mov	r5, r1
	keys = bt_keys_find(BT_KEYS_LOCAL_CSRK, conn->id, &conn->le.dst);
    d284:	4632      	mov	r2, r6
    d286:	7a01      	ldrb	r1, [r0, #8]
    d288:	2008      	movs	r0, #8
    d28a:	f000 fa37 	bl	d6fc <bt_keys_find>
	if (!keys) {
    d28e:	4604      	mov	r4, r0
    d290:	b9b0      	cbnz	r0, d2c0 <bt_smp_sign+0x44>
		BT_ERR("Unable to find local CSRK for %s",
    d292:	2301      	movs	r3, #1
    d294:	4a25      	ldr	r2, [pc, #148]	; (d32c <bt_smp_sign+0xb0>)
    d296:	f363 0407 	bfi	r4, r3, #0, #8
    d29a:	4b25      	ldr	r3, [pc, #148]	; (d330 <bt_smp_sign+0xb4>)
    d29c:	1a9b      	subs	r3, r3, r2
    d29e:	08db      	lsrs	r3, r3, #3
    d2a0:	4630      	mov	r0, r6
    d2a2:	f363 148f 	bfi	r4, r3, #6, #10
    d2a6:	f7f7 fd89 	bl	4dbc <bt_addr_le_str_real>
    d2aa:	f7f5 fdeb 	bl	2e84 <log_strdup>
    d2ae:	4622      	mov	r2, r4
    d2b0:	4601      	mov	r1, r0
    d2b2:	4820      	ldr	r0, [pc, #128]	; (d334 <bt_smp_sign+0xb8>)
    d2b4:	f00d f9ba 	bl	1a62c <log_1>
		return -ENOENT;
    d2b8:	f06f 0001 	mvn.w	r0, #1
}
    d2bc:	b002      	add	sp, #8
    d2be:	bd70      	pop	{r4, r5, r6, pc}
	net_buf_add(buf, 12);
    d2c0:	210c      	movs	r1, #12
    d2c2:	f105 0008 	add.w	r0, r5, #8
    d2c6:	f010 fcc1 	bl	1dc4c <net_buf_simple_add>
	cnt = sys_cpu_to_le32(keys->local_csrk.cnt);
    d2ca:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    d2cc:	9301      	str	r3, [sp, #4]
    d2ce:	89ab      	ldrh	r3, [r5, #12]
	memcpy(net_buf_tail(buf) - 12, &cnt, sizeof(cnt));
    d2d0:	68a8      	ldr	r0, [r5, #8]
    d2d2:	2204      	movs	r2, #4
    d2d4:	3b0c      	subs	r3, #12
    d2d6:	eb0d 0102 	add.w	r1, sp, r2
    d2da:	4418      	add	r0, r3
    d2dc:	f00d fe8d 	bl	1affa <memcpy>
	err = smp_sign_buf(keys->local_csrk.val, buf->data, buf->len - 12);
    d2e0:	89aa      	ldrh	r2, [r5, #12]
    d2e2:	68a9      	ldr	r1, [r5, #8]
    d2e4:	3a0c      	subs	r2, #12
    d2e6:	b292      	uxth	r2, r2
    d2e8:	f104 003c 	add.w	r0, r4, #60	; 0x3c
    d2ec:	f7fe fc60 	bl	bbb0 <smp_sign_buf>
	if (err) {
    d2f0:	b1b8      	cbz	r0, d322 <bt_smp_sign+0xa6>
		BT_ERR("Unable to create signature for %s",
    d2f2:	2301      	movs	r3, #1
    d2f4:	f04f 0400 	mov.w	r4, #0
    d2f8:	4a0c      	ldr	r2, [pc, #48]	; (d32c <bt_smp_sign+0xb0>)
    d2fa:	f363 0407 	bfi	r4, r3, #0, #8
    d2fe:	4b0c      	ldr	r3, [pc, #48]	; (d330 <bt_smp_sign+0xb4>)
    d300:	1a9b      	subs	r3, r3, r2
    d302:	08db      	lsrs	r3, r3, #3
    d304:	4630      	mov	r0, r6
    d306:	f363 148f 	bfi	r4, r3, #6, #10
    d30a:	f7f7 fd57 	bl	4dbc <bt_addr_le_str_real>
    d30e:	f7f5 fdb9 	bl	2e84 <log_strdup>
    d312:	4622      	mov	r2, r4
    d314:	4601      	mov	r1, r0
    d316:	4808      	ldr	r0, [pc, #32]	; (d338 <bt_smp_sign+0xbc>)
    d318:	f00d f988 	bl	1a62c <log_1>
		return -EIO;
    d31c:	f06f 0004 	mvn.w	r0, #4
    d320:	e7cc      	b.n	d2bc <bt_smp_sign+0x40>
	keys->local_csrk.cnt++;
    d322:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    d324:	3301      	adds	r3, #1
    d326:	64e3      	str	r3, [r4, #76]	; 0x4c
	return 0;
    d328:	e7c8      	b.n	d2bc <bt_smp_sign+0x40>
    d32a:	bf00      	nop
    d32c:	0001ed28 	.word	0x0001ed28
    d330:	0001ee18 	.word	0x0001ee18
    d334:	0002162b 	.word	0x0002162b
    d338:	0002166e 	.word	0x0002166e

0000d33c <bt_smp_start_security>:
{
    d33c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	switch (conn->role) {
    d340:	78c7      	ldrb	r7, [r0, #3]
    d342:	2f01      	cmp	r7, #1
{
    d344:	4604      	mov	r4, r0
	switch (conn->role) {
    d346:	d005      	beq.n	d354 <bt_smp_start_security+0x18>
		return -EINVAL;
    d348:	f06f 0715 	mvn.w	r7, #21
}
    d34c:	4638      	mov	r0, r7
    d34e:	b003      	add	sp, #12
    d350:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	smp = smp_chan_get(conn);
    d354:	f7fe fd06 	bl	bd64 <smp_chan_get>
	if (!smp) {
    d358:	4605      	mov	r5, r0
    d35a:	2800      	cmp	r0, #0
    d35c:	f000 80a2 	beq.w	d4a4 <bt_smp_start_security+0x168>
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
    d360:	f100 0694 	add.w	r6, r0, #148	; 0x94
    d364:	2104      	movs	r1, #4
    d366:	4630      	mov	r0, r6
    d368:	f00f f9de 	bl	1c728 <atomic_test_bit>
    d36c:	2800      	cmp	r0, #0
    d36e:	f040 809c 	bne.w	d4aa <bt_smp_start_security+0x16e>
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
    d372:	2103      	movs	r1, #3
    d374:	4630      	mov	r0, r6
    d376:	f00f f9d7 	bl	1c728 <atomic_test_bit>
    d37a:	b110      	cbz	r0, d382 <bt_smp_start_security+0x46>
		return -EBUSY;
    d37c:	f06f 070f 	mvn.w	r7, #15
    d380:	e7e4      	b.n	d34c <bt_smp_start_security+0x10>
	if (atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
    d382:	4639      	mov	r1, r7
    d384:	4630      	mov	r0, r6
    d386:	f00f f9cf 	bl	1c728 <atomic_test_bit>
    d38a:	2800      	cmp	r0, #0
    d38c:	d1f6      	bne.n	d37c <bt_smp_start_security+0x40>
	switch (conn->required_sec_level) {
    d38e:	7aa3      	ldrb	r3, [r4, #10]
    d390:	3b01      	subs	r3, #1
    d392:	2b03      	cmp	r3, #3
    d394:	d813      	bhi.n	d3be <bt_smp_start_security+0x82>
    d396:	e8df f003 	tbb	[pc, r3]
    d39a:	3b3b      	.short	0x3b3b
    d39c:	4602      	.short	0x4602
		return get_io_capa() != BT_SMP_IO_NO_INPUT_OUTPUT ||
    d39e:	f7fe fbe1 	bl	bb64 <get_io_capa>
    d3a2:	2803      	cmp	r0, #3
    d3a4:	d107      	bne.n	d3b6 <bt_smp_start_security+0x7a>
		       (bt_auth && bt_auth->oob_data_request && oobd_present);
    d3a6:	4b42      	ldr	r3, [pc, #264]	; (d4b0 <bt_smp_start_security+0x174>)
    d3a8:	681b      	ldr	r3, [r3, #0]
		return get_io_capa() != BT_SMP_IO_NO_INPUT_OUTPUT ||
    d3aa:	b12b      	cbz	r3, d3b8 <bt_smp_start_security+0x7c>
		       (bt_auth && bt_auth->oob_data_request && oobd_present);
    d3ac:	68db      	ldr	r3, [r3, #12]
    d3ae:	b11b      	cbz	r3, d3b8 <bt_smp_start_security+0x7c>
    d3b0:	4b40      	ldr	r3, [pc, #256]	; (d4b4 <bt_smp_start_security+0x178>)
			 oobd_present)) &&
    d3b2:	781b      	ldrb	r3, [r3, #0]
    d3b4:	e000      	b.n	d3b8 <bt_smp_start_security+0x7c>
		return get_io_capa() != BT_SMP_IO_NO_INPUT_OUTPUT ||
    d3b6:	2301      	movs	r3, #1
			 oobd_present)) &&
    d3b8:	f003 0301 	and.w	r3, r3, #1
	if (!(sec_level_reachable(conn) || smp_keys_check(conn))) {
    d3bc:	bb43      	cbnz	r3, d410 <bt_smp_start_security+0xd4>
	if (atomic_test_bit(conn->flags, BT_CONN_FORCE_PAIR)) {
    d3be:	210b      	movs	r1, #11
    d3c0:	1d20      	adds	r0, r4, #4
    d3c2:	f00f f9b1 	bl	1c728 <atomic_test_bit>
    d3c6:	2800      	cmp	r0, #0
    d3c8:	d1be      	bne.n	d348 <bt_smp_start_security+0xc>
	if (!conn->le.keys) {
    d3ca:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
    d3ce:	b983      	cbnz	r3, d3f2 <bt_smp_start_security+0xb6>
						     conn->id, &conn->le.dst);
    d3d0:	f104 0770 	add.w	r7, r4, #112	; 0x70
		conn->le.keys = bt_keys_find(BT_KEYS_LTK_P256,
    d3d4:	463a      	mov	r2, r7
    d3d6:	7a21      	ldrb	r1, [r4, #8]
    d3d8:	2020      	movs	r0, #32
    d3da:	f000 f98f 	bl	d6fc <bt_keys_find>
    d3de:	f8c4 009c 	str.w	r0, [r4, #156]	; 0x9c
		if (!conn->le.keys) {
    d3e2:	b930      	cbnz	r0, d3f2 <bt_smp_start_security+0xb6>
			conn->le.keys = bt_keys_find(BT_KEYS_LTK,
    d3e4:	463a      	mov	r2, r7
    d3e6:	7a21      	ldrb	r1, [r4, #8]
    d3e8:	2004      	movs	r0, #4
    d3ea:	f000 f987 	bl	d6fc <bt_keys_find>
    d3ee:	f8c4 009c 	str.w	r0, [r4, #156]	; 0x9c
	if (!conn->le.keys ||
    d3f2:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
    d3f6:	2b00      	cmp	r3, #0
    d3f8:	d0a6      	beq.n	d348 <bt_smp_start_security+0xc>
    d3fa:	895a      	ldrh	r2, [r3, #10]
    d3fc:	f002 0224 	and.w	r2, r2, #36	; 0x24
    d400:	2a00      	cmp	r2, #0
    d402:	d0a1      	beq.n	d348 <bt_smp_start_security+0xc>
	if (conn->required_sec_level > BT_SECURITY_L2 &&
    d404:	7aa2      	ldrb	r2, [r4, #10]
    d406:	2a02      	cmp	r2, #2
    d408:	d902      	bls.n	d410 <bt_smp_start_security+0xd4>
    d40a:	7a5b      	ldrb	r3, [r3, #9]
    d40c:	07db      	lsls	r3, r3, #31
    d40e:	d59b      	bpl.n	d348 <bt_smp_start_security+0xc>
	if (!conn->le.keys) {
    d410:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
    d414:	b1c3      	cbz	r3, d448 <bt_smp_start_security+0x10c>
	if (smp_init(smp) != 0) {
    d416:	4628      	mov	r0, r5
    d418:	f7fe fce6 	bl	bde8 <smp_init>
    d41c:	4607      	mov	r7, r0
    d41e:	b1f8      	cbz	r0, d460 <bt_smp_start_security+0x124>
		return -ENOBUFS;
    d420:	f06f 0736 	mvn.w	r7, #54	; 0x36
    d424:	e792      	b.n	d34c <bt_smp_start_security+0x10>
		return (get_io_capa() != BT_SMP_IO_NO_INPUT_OUTPUT ||
    d426:	f7fe fb9d 	bl	bb64 <get_io_capa>
			 oobd_present)) &&
    d42a:	2803      	cmp	r0, #3
    d42c:	d10a      	bne.n	d444 <bt_smp_start_security+0x108>
			(bt_auth && bt_auth->oob_data_request &&
    d42e:	4b20      	ldr	r3, [pc, #128]	; (d4b0 <bt_smp_start_security+0x174>)
    d430:	681b      	ldr	r3, [r3, #0]
		return (get_io_capa() != BT_SMP_IO_NO_INPUT_OUTPUT ||
    d432:	2b00      	cmp	r3, #0
    d434:	d0c0      	beq.n	d3b8 <bt_smp_start_security+0x7c>
			(bt_auth && bt_auth->oob_data_request &&
    d436:	68db      	ldr	r3, [r3, #12]
    d438:	2b00      	cmp	r3, #0
    d43a:	d0bd      	beq.n	d3b8 <bt_smp_start_security+0x7c>
    d43c:	4b1d      	ldr	r3, [pc, #116]	; (d4b4 <bt_smp_start_security+0x178>)
    d43e:	781b      	ldrb	r3, [r3, #0]
    d440:	2b00      	cmp	r3, #0
    d442:	d0b9      	beq.n	d3b8 <bt_smp_start_security+0x7c>
			 oobd_present)) &&
    d444:	4b1c      	ldr	r3, [pc, #112]	; (d4b8 <bt_smp_start_security+0x17c>)
    d446:	e7b4      	b.n	d3b2 <bt_smp_start_security+0x76>
		conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
    d448:	f104 0170 	add.w	r1, r4, #112	; 0x70
    d44c:	7a20      	ldrb	r0, [r4, #8]
    d44e:	f000 f8e1 	bl	d614 <bt_keys_get_addr>
    d452:	f8c4 009c 	str.w	r0, [r4, #156]	; 0x9c
		if (!conn->le.keys) {
    d456:	2800      	cmp	r0, #0
    d458:	d1dd      	bne.n	d416 <bt_smp_start_security+0xda>
			return -ENOMEM;
    d45a:	f06f 070b 	mvn.w	r7, #11
    d45e:	e775      	b.n	d34c <bt_smp_start_security+0x10>
	req_buf = smp_create_pdu(smp, BT_SMP_CMD_SECURITY_REQUEST,
    d460:	210b      	movs	r1, #11
    d462:	4628      	mov	r0, r5
    d464:	f00f fa20 	bl	1c8a8 <smp_create_pdu.isra.6>
	if (!req_buf) {
    d468:	4680      	mov	r8, r0
    d46a:	2800      	cmp	r0, #0
    d46c:	d0d8      	beq.n	d420 <bt_smp_start_security+0xe4>
	req = net_buf_add(req_buf, sizeof(*req));
    d46e:	2101      	movs	r1, #1
    d470:	3008      	adds	r0, #8
    d472:	f010 fbeb 	bl	1dc4c <net_buf_simple_add>
    d476:	4681      	mov	r9, r0
	req->auth_req = get_auth(conn, BT_SMP_AUTH_DEFAULT);
    d478:	2009      	movs	r0, #9
    d47a:	f7fe fc55 	bl	bd28 <get_auth.isra.0>
    d47e:	463b      	mov	r3, r7
    d480:	f889 0000 	strb.w	r0, [r9]
    d484:	4642      	mov	r2, r8
    d486:	9700      	str	r7, [sp, #0]
    d488:	2106      	movs	r1, #6
    d48a:	4620      	mov	r0, r4
    d48c:	f00e f961 	bl	1b752 <bt_l2cap_send_cb>
	atomic_set_bit(smp->flags, SMP_FLAG_SEC_REQ);
    d490:	4630      	mov	r0, r6
    d492:	210e      	movs	r1, #14
    d494:	f00f f939 	bl	1c70a <atomic_set_bit>
	atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_REQ);
    d498:	2101      	movs	r1, #1
    d49a:	f105 0090 	add.w	r0, r5, #144	; 0x90
    d49e:	f00f f934 	bl	1c70a <atomic_set_bit>
	return 0;
    d4a2:	e753      	b.n	d34c <bt_smp_start_security+0x10>
		return -ENOTCONN;
    d4a4:	f06f 0738 	mvn.w	r7, #56	; 0x38
    d4a8:	e750      	b.n	d34c <bt_smp_start_security+0x10>
		return -EIO;
    d4aa:	f06f 0704 	mvn.w	r7, #4
    d4ae:	e74d      	b.n	d34c <bt_smp_start_security+0x10>
    d4b0:	2000029c 	.word	0x2000029c
    d4b4:	20001c75 	.word	0x20001c75
    d4b8:	20001c76 	.word	0x20001c76

0000d4bc <bt_smp_update_keys>:
{
    d4bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d4be:	4604      	mov	r4, r0
	smp = smp_chan_get(conn);
    d4c0:	f7fe fc50 	bl	bd64 <smp_chan_get>
	if (!smp) {
    d4c4:	4605      	mov	r5, r0
    d4c6:	2800      	cmp	r0, #0
    d4c8:	f000 8086 	beq.w	d5d8 <bt_smp_update_keys+0x11c>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
    d4cc:	f100 0694 	add.w	r6, r0, #148	; 0x94
    d4d0:	2103      	movs	r1, #3
    d4d2:	4630      	mov	r0, r6
    d4d4:	f00f f928 	bl	1c728 <atomic_test_bit>
    d4d8:	2800      	cmp	r0, #0
    d4da:	d07d      	beq.n	d5d8 <bt_smp_update_keys+0x11c>
	if (conn->le.keys) {
    d4dc:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
    d4e0:	b108      	cbz	r0, d4e6 <bt_smp_update_keys+0x2a>
		bt_keys_clear(conn->le.keys);
    d4e2:	f000 f96d 	bl	d7c0 <bt_keys_clear>
	conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
    d4e6:	f104 0770 	add.w	r7, r4, #112	; 0x70
    d4ea:	4639      	mov	r1, r7
    d4ec:	7a20      	ldrb	r0, [r4, #8]
    d4ee:	f000 f891 	bl	d614 <bt_keys_get_addr>
    d4f2:	f8c4 009c 	str.w	r0, [r4, #156]	; 0x9c
	if (!conn->le.keys) {
    d4f6:	b9d0      	cbnz	r0, d52e <bt_smp_update_keys+0x72>
		BT_ERR("Unable to get keys for %s",
    d4f8:	2301      	movs	r3, #1
    d4fa:	f04f 0400 	mov.w	r4, #0
    d4fe:	4a37      	ldr	r2, [pc, #220]	; (d5dc <bt_smp_update_keys+0x120>)
    d500:	f363 0407 	bfi	r4, r3, #0, #8
    d504:	4b36      	ldr	r3, [pc, #216]	; (d5e0 <bt_smp_update_keys+0x124>)
    d506:	1a9b      	subs	r3, r3, r2
    d508:	08db      	lsrs	r3, r3, #3
    d50a:	4638      	mov	r0, r7
    d50c:	f363 148f 	bfi	r4, r3, #6, #10
    d510:	f7f7 fc54 	bl	4dbc <bt_addr_le_str_real>
    d514:	f7f5 fcb6 	bl	2e84 <log_strdup>
    d518:	4622      	mov	r2, r4
    d51a:	4601      	mov	r1, r0
    d51c:	4831      	ldr	r0, [pc, #196]	; (d5e4 <bt_smp_update_keys+0x128>)
    d51e:	f00d f885 	bl	1a62c <log_1>
		smp_error(smp, BT_SMP_ERR_UNSPECIFIED);
    d522:	4628      	mov	r0, r5
    d524:	2108      	movs	r1, #8
}
    d526:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		smp_error(smp, BT_SMP_ERR_UNSPECIFIED);
    d52a:	f00f ba7f 	b.w	1ca2c <smp_error>
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY)) {
    d52e:	210d      	movs	r1, #13
    d530:	4630      	mov	r0, r6
    d532:	f00f f8f9 	bl	1c728 <atomic_test_bit>
    d536:	b128      	cbz	r0, d544 <bt_smp_update_keys+0x88>
		conn->le.keys->flags |= BT_KEYS_DEBUG;
    d538:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
    d53c:	7a53      	ldrb	r3, [r2, #9]
    d53e:	f043 0302 	orr.w	r3, r3, #2
    d542:	7253      	strb	r3, [r2, #9]
	switch (smp->method) {
    d544:	f895 0098 	ldrb.w	r0, [r5, #152]	; 0x98
    d548:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
    d54c:	2805      	cmp	r0, #5
    d54e:	7a53      	ldrb	r3, [r2, #9]
    d550:	d83c      	bhi.n	d5cc <bt_smp_update_keys+0x110>
    d552:	2101      	movs	r1, #1
    d554:	4081      	lsls	r1, r0
    d556:	f011 0f2e 	tst.w	r1, #46	; 0x2e
    d55a:	d037      	beq.n	d5cc <bt_smp_update_keys+0x110>
		conn->le.keys->flags |= BT_KEYS_AUTHENTICATED;
    d55c:	f043 0301 	orr.w	r3, r3, #1
		conn->le.keys->flags &= ~BT_KEYS_AUTHENTICATED;
    d560:	7253      	strb	r3, [r2, #9]
	return MIN(req->max_key_size, rsp->max_key_size);
    d562:	f895 30a4 	ldrb.w	r3, [r5, #164]	; 0xa4
    d566:	f895 109d 	ldrb.w	r1, [r5, #157]	; 0x9d
    d56a:	428b      	cmp	r3, r1
    d56c:	bf28      	it	cs
    d56e:	460b      	movcs	r3, r1
	conn->le.keys->enc_size = get_encryption_key_size(smp);
    d570:	7213      	strb	r3, [r2, #8]
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    d572:	2105      	movs	r1, #5
    d574:	4630      	mov	r0, r6
    d576:	f00f f8d7 	bl	1c728 <atomic_test_bit>
    d57a:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
		conn->le.keys->flags |= BT_KEYS_SC;
    d57e:	7a5a      	ldrb	r2, [r3, #9]
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
    d580:	b338      	cbz	r0, d5d2 <bt_smp_update_keys+0x116>
		conn->le.keys->flags |= BT_KEYS_SC;
    d582:	f042 0210 	orr.w	r2, r2, #16
    d586:	725a      	strb	r2, [r3, #9]
		if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
    d588:	210c      	movs	r1, #12
    d58a:	4630      	mov	r0, r6
    d58c:	f00f f8cc 	bl	1c728 <atomic_test_bit>
    d590:	b310      	cbz	r0, d5d8 <bt_smp_update_keys+0x11c>
			bt_keys_add_type(conn->le.keys, BT_KEYS_LTK_P256);
    d592:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
    d596:	2120      	movs	r1, #32
    d598:	f00f fc40 	bl	1ce1c <bt_keys_add_type>
			memcpy(conn->le.keys->ltk.val, smp->tk,
    d59c:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
    d5a0:	f105 01d7 	add.w	r1, r5, #215	; 0xd7
    d5a4:	2210      	movs	r2, #16
    d5a6:	3016      	adds	r0, #22
    d5a8:	f00d fd27 	bl	1affa <memcpy>
			(void)memset(conn->le.keys->ltk.rand, 0,
    d5ac:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
    d5b0:	2208      	movs	r2, #8
    d5b2:	2100      	movs	r1, #0
    d5b4:	300c      	adds	r0, #12
    d5b6:	f00d fd4a 	bl	1b04e <memset>
			(void)memset(conn->le.keys->ltk.ediv, 0,
    d5ba:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
    d5be:	2202      	movs	r2, #2
    d5c0:	2100      	movs	r1, #0
    d5c2:	3014      	adds	r0, #20
}
    d5c4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			(void)memset(conn->le.keys->ltk.ediv, 0,
    d5c8:	f00d bd41 	b.w	1b04e <memset>
		conn->le.keys->flags &= ~BT_KEYS_AUTHENTICATED;
    d5cc:	f023 0301 	bic.w	r3, r3, #1
    d5d0:	e7c6      	b.n	d560 <bt_smp_update_keys+0xa4>
		conn->le.keys->flags &= ~BT_KEYS_SC;
    d5d2:	f022 0210 	bic.w	r2, r2, #16
    d5d6:	725a      	strb	r2, [r3, #9]
}
    d5d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    d5da:	bf00      	nop
    d5dc:	0001ed28 	.word	0x0001ed28
    d5e0:	0001ee18 	.word	0x0001ee18
    d5e4:	00021763 	.word	0x00021763

0000d5e8 <bt_smp_init>:
BT_L2CAP_CHANNEL_DEFINE(smp_br_fixed_chan, BT_L2CAP_CID_BR_SMP,
			bt_smp_br_accept);
#endif /* CONFIG_BT_BREDR */

int bt_smp_init(void)
{
    d5e8:	b508      	push	{r3, lr}
	return BT_CMD_TEST(bt_dev.supported_commands, 34, 1) &&
    d5ea:	4b07      	ldr	r3, [pc, #28]	; (d608 <bt_smp_init+0x20>)
		return -ENOENT;
	}

	BT_DBG("LE SC %s", sc_supported ? "enabled" : "disabled");

	bt_pub_key_gen(&pub_key_cb);
    d5ec:	4807      	ldr	r0, [pc, #28]	; (d60c <bt_smp_init+0x24>)
	return BT_CMD_TEST(bt_dev.supported_commands, 34, 1) &&
    d5ee:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
    d5f2:	f003 0306 	and.w	r3, r3, #6
    d5f6:	1f9a      	subs	r2, r3, #6
    d5f8:	4253      	negs	r3, r2
    d5fa:	4153      	adcs	r3, r2
    d5fc:	4a04      	ldr	r2, [pc, #16]	; (d610 <bt_smp_init+0x28>)
    d5fe:	7013      	strb	r3, [r2, #0]
	bt_pub_key_gen(&pub_key_cb);
    d600:	f7fa fa22 	bl	7a48 <bt_pub_key_gen>

	return smp_self_test();
}
    d604:	2000      	movs	r0, #0
    d606:	bd08      	pop	{r3, pc}
    d608:	20005438 	.word	0x20005438
    d60c:	200056e0 	.word	0x200056e0
    d610:	20001c76 	.word	0x20001c76

0000d614 <bt_keys_get_addr>:
static u32_t aging_counter_val;
static struct bt_keys *last_keys_updated;
#endif /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */

struct bt_keys *bt_keys_get_addr(u8_t id, const bt_addr_le_t *addr)
{
    d614:	b5f0      	push	{r4, r5, r6, r7, lr}
	BT_DBG("%s", bt_addr_le_str(addr));

	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
		keys = &key_pool[i];

		if (keys->id == id && !bt_addr_le_cmp(&keys->addr, addr)) {
    d616:	4c1d      	ldr	r4, [pc, #116]	; (d68c <bt_keys_get_addr+0x78>)
    d618:	7823      	ldrb	r3, [r4, #0]
    d61a:	4283      	cmp	r3, r0
{
    d61c:	b085      	sub	sp, #20
    d61e:	4606      	mov	r6, r0
    d620:	460f      	mov	r7, r1
    d622:	4625      	mov	r5, r4
		if (keys->id == id && !bt_addr_le_cmp(&keys->addr, addr)) {
    d624:	d029      	beq.n	d67a <bt_keys_get_addr+0x66>
			return keys;
		}

		if (first_free_slot == ARRAY_SIZE(key_pool) &&
		    (!bt_addr_le_cmp(&keys->addr, BT_ADDR_LE_ANY) ||
    d626:	2400      	movs	r4, #0
	return memcmp(a, b, sizeof(*a));
    d628:	2207      	movs	r2, #7
    d62a:	4669      	mov	r1, sp
    d62c:	4818      	ldr	r0, [pc, #96]	; (d690 <bt_keys_get_addr+0x7c>)
    d62e:	9400      	str	r4, [sp, #0]
    d630:	f8cd 4003 	str.w	r4, [sp, #3]
    d634:	f00d fcd1 	bl	1afda <memcmp>
		if (first_free_slot == ARRAY_SIZE(key_pool) &&
    d638:	b170      	cbz	r0, d658 <bt_keys_get_addr+0x44>
		    (!bt_addr_le_cmp(&keys->addr, BT_ADDR_LE_ANY) ||
    d63a:	7a2b      	ldrb	r3, [r5, #8]
    d63c:	b163      	cbz	r3, d658 <bt_keys_get_addr+0x44>
			if (current->aging_counter < oldest->aging_counter) {
				oldest = current;
			}
		}

		bt_unpair(oldest->id, &oldest->addr);
    d63e:	4914      	ldr	r1, [pc, #80]	; (d690 <bt_keys_get_addr+0x7c>)
    d640:	7828      	ldrb	r0, [r5, #0]
    d642:	f7f9 f87b 	bl	673c <bt_unpair>
    d646:	2207      	movs	r2, #7
    d648:	a902      	add	r1, sp, #8
    d64a:	4811      	ldr	r0, [pc, #68]	; (d690 <bt_keys_get_addr+0x7c>)
		if (!bt_addr_le_cmp(&oldest->addr, BT_ADDR_LE_ANY)) {
    d64c:	9402      	str	r4, [sp, #8]
    d64e:	f8cd 400b 	str.w	r4, [sp, #11]
    d652:	f00d fcc2 	bl	1afda <memcmp>
    d656:	b9b0      	cbnz	r0, d686 <bt_keys_get_addr+0x72>
	memcpy(dst, src, sizeof(*dst));
    d658:	2207      	movs	r2, #7
	}

#endif  /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
	if (first_free_slot < ARRAY_SIZE(key_pool)) {
		keys = &key_pool[first_free_slot];
		keys->id = id;
    d65a:	702e      	strb	r6, [r5, #0]
    d65c:	4639      	mov	r1, r7
    d65e:	480c      	ldr	r0, [pc, #48]	; (d690 <bt_keys_get_addr+0x7c>)
    d660:	f00d fccb 	bl	1affa <memcpy>
		bt_addr_le_copy(&keys->addr, addr);
#if IS_ENABLED(CONFIG_BT_KEYS_OVERWRITE_OLDEST)
		keys->aging_counter = ++aging_counter_val;
    d664:	4a0b      	ldr	r2, [pc, #44]	; (d694 <bt_keys_get_addr+0x80>)
		last_keys_updated = keys;
#endif  /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
		BT_DBG("created %p for %s", keys, bt_addr_le_str(addr));
		return keys;
    d666:	4809      	ldr	r0, [pc, #36]	; (d68c <bt_keys_get_addr+0x78>)
		keys->aging_counter = ++aging_counter_val;
    d668:	6813      	ldr	r3, [r2, #0]
    d66a:	3301      	adds	r3, #1
    d66c:	6013      	str	r3, [r2, #0]
    d66e:	f8c5 3080 	str.w	r3, [r5, #128]	; 0x80
		last_keys_updated = keys;
    d672:	4b09      	ldr	r3, [pc, #36]	; (d698 <bt_keys_get_addr+0x84>)
    d674:	601d      	str	r5, [r3, #0]
	}

	BT_DBG("unable to create keys for %s", bt_addr_le_str(addr));

	return NULL;
}
    d676:	b005      	add	sp, #20
    d678:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return memcmp(a, b, sizeof(*a));
    d67a:	2207      	movs	r2, #7
    d67c:	1c60      	adds	r0, r4, #1
    d67e:	f00d fcac 	bl	1afda <memcmp>
		if (keys->id == id && !bt_addr_le_cmp(&keys->addr, addr)) {
    d682:	2800      	cmp	r0, #0
    d684:	d1cf      	bne.n	d626 <bt_keys_get_addr+0x12>
	return NULL;
    d686:	4620      	mov	r0, r4
    d688:	e7f5      	b.n	d676 <bt_keys_get_addr+0x62>
    d68a:	bf00      	nop
    d68c:	20000678 	.word	0x20000678
    d690:	20000679 	.word	0x20000679
    d694:	20000674 	.word	0x20000674
    d698:	200006fc 	.word	0x200006fc

0000d69c <bt_foreach_bond>:

void bt_foreach_bond(u8_t id, void (*func)(const struct bt_bond_info *info,
					   void *user_data),
		     void *user_data)
{
    d69c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    d69e:	460c      	mov	r4, r1
	int i;

	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
		struct bt_keys *keys = &key_pool[i];

		if (keys->keys && keys->id == id) {
    d6a0:	4908      	ldr	r1, [pc, #32]	; (d6c4 <bt_foreach_bond+0x28>)
    d6a2:	894b      	ldrh	r3, [r1, #10]
{
    d6a4:	4615      	mov	r5, r2
		if (keys->keys && keys->id == id) {
    d6a6:	b153      	cbz	r3, d6be <bt_foreach_bond+0x22>
    d6a8:	780b      	ldrb	r3, [r1, #0]
    d6aa:	4283      	cmp	r3, r0
    d6ac:	d107      	bne.n	d6be <bt_foreach_bond+0x22>
	memcpy(dst, src, sizeof(*dst));
    d6ae:	3101      	adds	r1, #1
    d6b0:	2207      	movs	r2, #7
    d6b2:	4668      	mov	r0, sp
    d6b4:	f00d fca1 	bl	1affa <memcpy>
			struct bt_bond_info info;

			bt_addr_le_copy(&info.addr, &keys->addr);
			func(&info, user_data);
    d6b8:	4629      	mov	r1, r5
    d6ba:	4668      	mov	r0, sp
    d6bc:	47a0      	blx	r4
		}
	}
}
    d6be:	b003      	add	sp, #12
    d6c0:	bd30      	pop	{r4, r5, pc}
    d6c2:	bf00      	nop
    d6c4:	20000678 	.word	0x20000678

0000d6c8 <bt_keys_foreach>:
		     void *data)
{
	int i;

	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
		if ((key_pool[i].keys & type)) {
    d6c8:	4b06      	ldr	r3, [pc, #24]	; (d6e4 <bt_keys_foreach+0x1c>)
{
    d6ca:	b410      	push	{r4}
    d6cc:	460c      	mov	r4, r1
		if ((key_pool[i].keys & type)) {
    d6ce:	8959      	ldrh	r1, [r3, #10]
    d6d0:	4201      	tst	r1, r0
    d6d2:	d004      	beq.n	d6de <bt_keys_foreach+0x16>
			func(&key_pool[i], data);
    d6d4:	4618      	mov	r0, r3
    d6d6:	4611      	mov	r1, r2
    d6d8:	4623      	mov	r3, r4
		}
	}
}
    d6da:	bc10      	pop	{r4}
			func(&key_pool[i], data);
    d6dc:	4718      	bx	r3
}
    d6de:	bc10      	pop	{r4}
    d6e0:	4770      	bx	lr
    d6e2:	bf00      	nop
    d6e4:	20000678 	.word	0x20000678

0000d6e8 <keys_commit>:
{
	bt_id_add(keys);
}

static int keys_commit(void)
{
    d6e8:	b508      	push	{r3, lr}

	/* We do this in commit() rather than add() since add() may get
	 * called multiple times for the same address, especially if
	 * the keys were already removed.
	 */
	bt_keys_foreach(BT_KEYS_IRK, id_add, NULL);
    d6ea:	2200      	movs	r2, #0
    d6ec:	4902      	ldr	r1, [pc, #8]	; (d6f8 <keys_commit+0x10>)
    d6ee:	2002      	movs	r0, #2
    d6f0:	f7ff ffea 	bl	d6c8 <bt_keys_foreach>

	return 0;
}
    d6f4:	2000      	movs	r0, #0
    d6f6:	bd08      	pop	{r3, pc}
    d6f8:	0001cdf9 	.word	0x0001cdf9

0000d6fc <bt_keys_find>:
{
    d6fc:	b538      	push	{r3, r4, r5, lr}
		if ((key_pool[i].keys & type) && key_pool[i].id == id &&
    d6fe:	4c0a      	ldr	r4, [pc, #40]	; (d728 <bt_keys_find+0x2c>)
    d700:	8963      	ldrh	r3, [r4, #10]
    d702:	4018      	ands	r0, r3
{
    d704:	460d      	mov	r5, r1
    d706:	4611      	mov	r1, r2
		if ((key_pool[i].keys & type) && key_pool[i].id == id &&
    d708:	d00a      	beq.n	d720 <bt_keys_find+0x24>
    d70a:	7823      	ldrb	r3, [r4, #0]
    d70c:	42ab      	cmp	r3, r5
    d70e:	d108      	bne.n	d722 <bt_keys_find+0x26>
	return memcmp(a, b, sizeof(*a));
    d710:	2207      	movs	r2, #7
    d712:	1c60      	adds	r0, r4, #1
    d714:	f00d fc61 	bl	1afda <memcmp>
    d718:	2800      	cmp	r0, #0
			return &key_pool[i];
    d71a:	bf0c      	ite	eq
    d71c:	4620      	moveq	r0, r4
    d71e:	2000      	movne	r0, #0
}
    d720:	bd38      	pop	{r3, r4, r5, pc}
	return NULL;
    d722:	2000      	movs	r0, #0
    d724:	e7fc      	b.n	d720 <bt_keys_find+0x24>
    d726:	bf00      	nop
    d728:	20000678 	.word	0x20000678

0000d72c <bt_keys_find_irk>:
{
    d72c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (addr->type != BT_ADDR_LE_RANDOM) {
    d72e:	780b      	ldrb	r3, [r1, #0]
    d730:	2b01      	cmp	r3, #1
    d732:	4606      	mov	r6, r0
    d734:	460d      	mov	r5, r1
    d736:	d001      	beq.n	d73c <bt_keys_find_irk+0x10>
		return NULL;
    d738:	2000      	movs	r0, #0
}
    d73a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!bt_addr_le_is_rpa(addr)) {
    d73c:	798b      	ldrb	r3, [r1, #6]
    d73e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    d742:	2b40      	cmp	r3, #64	; 0x40
    d744:	d1f8      	bne.n	d738 <bt_keys_find_irk+0xc>
		if (!(key_pool[i].keys & BT_KEYS_IRK)) {
    d746:	4c13      	ldr	r4, [pc, #76]	; (d794 <bt_keys_find_irk+0x68>)
    d748:	8963      	ldrh	r3, [r4, #10]
    d74a:	f013 0f02 	tst.w	r3, #2
    d74e:	4627      	mov	r7, r4
    d750:	d00b      	beq.n	d76a <bt_keys_find_irk+0x3e>
		if (key_pool[i].id == id &&
    d752:	7823      	ldrb	r3, [r4, #0]
    d754:	4283      	cmp	r3, r0
    d756:	d108      	bne.n	d76a <bt_keys_find_irk+0x3e>
	return memcmp(a, b, sizeof(*a));
    d758:	2206      	movs	r2, #6
    d75a:	f104 0136 	add.w	r1, r4, #54	; 0x36
    d75e:	1c68      	adds	r0, r5, #1
    d760:	f00d fc3b 	bl	1afda <memcmp>
    d764:	b908      	cbnz	r0, d76a <bt_keys_find_irk+0x3e>
			return &key_pool[i];
    d766:	4620      	mov	r0, r4
    d768:	e7e7      	b.n	d73a <bt_keys_find_irk+0xe>
		if (!(key_pool[i].keys & BT_KEYS_IRK)) {
    d76a:	897b      	ldrh	r3, [r7, #10]
    d76c:	079b      	lsls	r3, r3, #30
    d76e:	d5e3      	bpl.n	d738 <bt_keys_find_irk+0xc>
		if (key_pool[i].id != id) {
    d770:	783b      	ldrb	r3, [r7, #0]
    d772:	42b3      	cmp	r3, r6
    d774:	d1e0      	bne.n	d738 <bt_keys_find_irk+0xc>
		if (bt_rpa_irk_matches(key_pool[i].irk.val, &addr->a)) {
    d776:	3501      	adds	r5, #1
    d778:	4629      	mov	r1, r5
    d77a:	4807      	ldr	r0, [pc, #28]	; (d798 <bt_keys_find_irk+0x6c>)
    d77c:	f00d fca8 	bl	1b0d0 <bt_rpa_irk_matches>
    d780:	2800      	cmp	r0, #0
    d782:	d0d9      	beq.n	d738 <bt_keys_find_irk+0xc>
	memcpy(dst, src, sizeof(*dst));
    d784:	2206      	movs	r2, #6
    d786:	4629      	mov	r1, r5
    d788:	4804      	ldr	r0, [pc, #16]	; (d79c <bt_keys_find_irk+0x70>)
    d78a:	f00d fc36 	bl	1affa <memcpy>
			return &key_pool[i];
    d78e:	4801      	ldr	r0, [pc, #4]	; (d794 <bt_keys_find_irk+0x68>)
    d790:	e7d3      	b.n	d73a <bt_keys_find_irk+0xe>
    d792:	bf00      	nop
    d794:	20000678 	.word	0x20000678
    d798:	2000069e 	.word	0x2000069e
    d79c:	200006ae 	.word	0x200006ae

0000d7a0 <bt_keys_find_addr>:
{
    d7a0:	b510      	push	{r4, lr}
		if (key_pool[i].id == id &&
    d7a2:	4c06      	ldr	r4, [pc, #24]	; (d7bc <bt_keys_find_addr+0x1c>)
    d7a4:	7823      	ldrb	r3, [r4, #0]
    d7a6:	4283      	cmp	r3, r0
    d7a8:	d104      	bne.n	d7b4 <bt_keys_find_addr+0x14>
	return memcmp(a, b, sizeof(*a));
    d7aa:	2207      	movs	r2, #7
    d7ac:	1c60      	adds	r0, r4, #1
    d7ae:	f00d fc14 	bl	1afda <memcmp>
    d7b2:	b108      	cbz	r0, d7b8 <bt_keys_find_addr+0x18>
	return NULL;
    d7b4:	2000      	movs	r0, #0
}
    d7b6:	bd10      	pop	{r4, pc}
			return &key_pool[i];
    d7b8:	4620      	mov	r0, r4
    d7ba:	e7fc      	b.n	d7b6 <bt_keys_find_addr+0x16>
    d7bc:	20000678 	.word	0x20000678

0000d7c0 <bt_keys_clear>:
{
    d7c0:	b570      	push	{r4, r5, r6, lr}
	if (keys->keys & BT_KEYS_IRK) {
    d7c2:	8943      	ldrh	r3, [r0, #10]
    d7c4:	079b      	lsls	r3, r3, #30
{
    d7c6:	b08c      	sub	sp, #48	; 0x30
    d7c8:	4605      	mov	r5, r0
	if (keys->keys & BT_KEYS_IRK) {
    d7ca:	d501      	bpl.n	d7d0 <bt_keys_clear+0x10>
		bt_id_del(keys);
    d7cc:	f7f9 f8ba 	bl	6944 <bt_id_del>
		if (keys->id) {
    d7d0:	462c      	mov	r4, r5
    d7d2:	f814 2b01 	ldrb.w	r2, [r4], #1
    d7d6:	b1aa      	cbz	r2, d804 <bt_keys_clear+0x44>
			u8_to_dec(id, sizeof(id), keys->id);
    d7d8:	ae02      	add	r6, sp, #8
    d7da:	2104      	movs	r1, #4
    d7dc:	4630      	mov	r0, r6
    d7de:	f00b fa0a 	bl	18bf6 <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "keys",
    d7e2:	9600      	str	r6, [sp, #0]
			bt_settings_encode_key(key, sizeof(key), "keys",
    d7e4:	4623      	mov	r3, r4
    d7e6:	4a08      	ldr	r2, [pc, #32]	; (d808 <bt_keys_clear+0x48>)
    d7e8:	2124      	movs	r1, #36	; 0x24
    d7ea:	a803      	add	r0, sp, #12
    d7ec:	f7f7 fdc8 	bl	5380 <bt_settings_encode_key>
		settings_delete(key);
    d7f0:	a803      	add	r0, sp, #12
    d7f2:	f00d f93c 	bl	1aa6e <settings_delete>
	(void)memset(keys, 0, sizeof(*keys));
    d7f6:	2284      	movs	r2, #132	; 0x84
    d7f8:	2100      	movs	r1, #0
    d7fa:	4628      	mov	r0, r5
    d7fc:	f00d fc27 	bl	1b04e <memset>
}
    d800:	b00c      	add	sp, #48	; 0x30
    d802:	bd70      	pop	{r4, r5, r6, pc}
			bt_settings_encode_key(key, sizeof(key), "keys",
    d804:	9200      	str	r2, [sp, #0]
    d806:	e7ed      	b.n	d7e4 <bt_keys_clear+0x24>
    d808:	000218bc 	.word	0x000218bc

0000d80c <keys_set>:
{
    d80c:	b5f0      	push	{r4, r5, r6, r7, lr}
    d80e:	4614      	mov	r4, r2
    d810:	b0a3      	sub	sp, #140	; 0x8c
	if (!name) {
    d812:	4606      	mov	r6, r0
    d814:	b990      	cbnz	r0, d83c <keys_set+0x30>
		BT_ERR("Insufficient number of arguments");
    d816:	2301      	movs	r3, #1
    d818:	f04f 0100 	mov.w	r1, #0
    d81c:	f363 0107 	bfi	r1, r3, #0, #8
    d820:	4a56      	ldr	r2, [pc, #344]	; (d97c <keys_set+0x170>)
    d822:	4b57      	ldr	r3, [pc, #348]	; (d980 <keys_set+0x174>)
    d824:	4857      	ldr	r0, [pc, #348]	; (d984 <keys_set+0x178>)
    d826:	1a9b      	subs	r3, r3, r2
    d828:	08db      	lsrs	r3, r3, #3
    d82a:	f363 118f 	bfi	r1, r3, #6, #10
    d82e:	f00c fef0 	bl	1a612 <log_0>
		return -EINVAL;
    d832:	f06f 0415 	mvn.w	r4, #21
}
    d836:	4620      	mov	r0, r4
    d838:	b023      	add	sp, #140	; 0x8c
    d83a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	len = read_cb(cb_arg, val, sizeof(val));
    d83c:	227c      	movs	r2, #124	; 0x7c
    d83e:	a903      	add	r1, sp, #12
    d840:	4618      	mov	r0, r3
    d842:	47a0      	blx	r4
	err = bt_settings_decode_key(name, &addr);
    d844:	a901      	add	r1, sp, #4
	len = read_cb(cb_arg, val, sizeof(val));
    d846:	4605      	mov	r5, r0
	err = bt_settings_decode_key(name, &addr);
    d848:	4630      	mov	r0, r6
    d84a:	f00d fc9f 	bl	1b18c <bt_settings_decode_key>
	if (err) {
    d84e:	4604      	mov	r4, r0
    d850:	b178      	cbz	r0, d872 <keys_set+0x66>
		BT_ERR("Unable to decode address %s", name);
    d852:	2301      	movs	r3, #1
    d854:	f04f 0200 	mov.w	r2, #0
    d858:	f363 0207 	bfi	r2, r3, #0, #8
    d85c:	4947      	ldr	r1, [pc, #284]	; (d97c <keys_set+0x170>)
    d85e:	4b48      	ldr	r3, [pc, #288]	; (d980 <keys_set+0x174>)
    d860:	4849      	ldr	r0, [pc, #292]	; (d988 <keys_set+0x17c>)
    d862:	1a5b      	subs	r3, r3, r1
    d864:	08db      	lsrs	r3, r3, #3
    d866:	f363 128f 	bfi	r2, r3, #6, #10
    d86a:	4631      	mov	r1, r6
    d86c:	f00c fede 	bl	1a62c <log_1>
    d870:	e7df      	b.n	d832 <keys_set+0x26>
	settings_name_next(name, &next);
    d872:	4669      	mov	r1, sp
    d874:	4630      	mov	r0, r6
    d876:	f00d f91e 	bl	1aab6 <settings_name_next>
	if (!next) {
    d87a:	9800      	ldr	r0, [sp, #0]
    d87c:	b180      	cbz	r0, d8a0 <keys_set+0x94>
		id = strtol(next, NULL, 10);
    d87e:	220a      	movs	r2, #10
    d880:	4621      	mov	r1, r4
    d882:	f00d faf5 	bl	1ae70 <strtol>
    d886:	b2c0      	uxtb	r0, r0
	if (!len) {
    d888:	bb15      	cbnz	r5, d8d0 <keys_set+0xc4>
		keys = bt_keys_find(BT_KEYS_ALL, id, &addr);
    d88a:	4601      	mov	r1, r0
    d88c:	aa01      	add	r2, sp, #4
    d88e:	203f      	movs	r0, #63	; 0x3f
    d890:	f7ff ff34 	bl	d6fc <bt_keys_find>
		if (keys) {
    d894:	b130      	cbz	r0, d8a4 <keys_set+0x98>
			(void)memset(keys, 0, sizeof(*keys));
    d896:	2284      	movs	r2, #132	; 0x84
    d898:	4629      	mov	r1, r5
    d89a:	f00d fbd8 	bl	1b04e <memset>
			BT_DBG("Cleared keys for %s", bt_addr_le_str(&addr));
    d89e:	e7ca      	b.n	d836 <keys_set+0x2a>
		id = BT_ID_DEFAULT;
    d8a0:	4620      	mov	r0, r4
    d8a2:	e7f1      	b.n	d888 <keys_set+0x7c>
			BT_WARN("Unable to find deleted keys for %s",
    d8a4:	2302      	movs	r3, #2
    d8a6:	f04f 0500 	mov.w	r5, #0
    d8aa:	4a34      	ldr	r2, [pc, #208]	; (d97c <keys_set+0x170>)
    d8ac:	f363 0507 	bfi	r5, r3, #0, #8
    d8b0:	4b33      	ldr	r3, [pc, #204]	; (d980 <keys_set+0x174>)
    d8b2:	1a9b      	subs	r3, r3, r2
    d8b4:	08db      	lsrs	r3, r3, #3
    d8b6:	a801      	add	r0, sp, #4
    d8b8:	f363 158f 	bfi	r5, r3, #6, #10
    d8bc:	f7f7 fa7e 	bl	4dbc <bt_addr_le_str_real>
    d8c0:	f7f5 fae0 	bl	2e84 <log_strdup>
    d8c4:	462a      	mov	r2, r5
    d8c6:	4601      	mov	r1, r0
    d8c8:	4830      	ldr	r0, [pc, #192]	; (d98c <keys_set+0x180>)
    d8ca:	f00c feaf 	bl	1a62c <log_1>
    d8ce:	e7b2      	b.n	d836 <keys_set+0x2a>
	keys = bt_keys_get_addr(id, &addr);
    d8d0:	a901      	add	r1, sp, #4
    d8d2:	f7ff fe9f 	bl	d614 <bt_keys_get_addr>
	if (!keys) {
    d8d6:	4606      	mov	r6, r0
    d8d8:	b9b8      	cbnz	r0, d90a <keys_set+0xfe>
		BT_ERR("Failed to allocate keys for %s", bt_addr_le_str(&addr));
    d8da:	2301      	movs	r3, #1
    d8dc:	f04f 0400 	mov.w	r4, #0
    d8e0:	4a26      	ldr	r2, [pc, #152]	; (d97c <keys_set+0x170>)
    d8e2:	f363 0407 	bfi	r4, r3, #0, #8
    d8e6:	4b26      	ldr	r3, [pc, #152]	; (d980 <keys_set+0x174>)
    d8e8:	1a9b      	subs	r3, r3, r2
    d8ea:	08db      	lsrs	r3, r3, #3
    d8ec:	a801      	add	r0, sp, #4
    d8ee:	f363 148f 	bfi	r4, r3, #6, #10
    d8f2:	f7f7 fa63 	bl	4dbc <bt_addr_le_str_real>
    d8f6:	f7f5 fac5 	bl	2e84 <log_strdup>
    d8fa:	4622      	mov	r2, r4
    d8fc:	4601      	mov	r1, r0
    d8fe:	4824      	ldr	r0, [pc, #144]	; (d990 <keys_set+0x184>)
    d900:	f00c fe94 	bl	1a62c <log_1>
		return -ENOMEM;
    d904:	f06f 040b 	mvn.w	r4, #11
    d908:	e795      	b.n	d836 <keys_set+0x2a>
	if (len != BT_KEYS_STORAGE_LEN) {
    d90a:	2d7c      	cmp	r5, #124	; 0x7c
    d90c:	d018      	beq.n	d940 <keys_set+0x134>
			if (IS_ENABLED(CONFIG_BT_KEYS_OVERWRITE_OLDEST) &&
    d90e:	491c      	ldr	r1, [pc, #112]	; (d980 <keys_set+0x174>)
    d910:	4b1a      	ldr	r3, [pc, #104]	; (d97c <keys_set+0x170>)
    d912:	2d78      	cmp	r5, #120	; 0x78
    d914:	eba1 0103 	sub.w	r1, r1, r3
    d918:	f3c1 01c9 	ubfx	r1, r1, #3, #10
    d91c:	d11e      	bne.n	d95c <keys_set+0x150>
				BT_WARN("Keys for %s have no aging counter",
    d91e:	2302      	movs	r3, #2
    d920:	f04f 0700 	mov.w	r7, #0
    d924:	f363 0707 	bfi	r7, r3, #0, #8
    d928:	a801      	add	r0, sp, #4
    d92a:	f361 178f 	bfi	r7, r1, #6, #10
    d92e:	f7f7 fa45 	bl	4dbc <bt_addr_le_str_real>
    d932:	f7f5 faa7 	bl	2e84 <log_strdup>
    d936:	463a      	mov	r2, r7
    d938:	4601      	mov	r1, r0
    d93a:	4816      	ldr	r0, [pc, #88]	; (d994 <keys_set+0x188>)
    d93c:	f00c fe76 	bl	1a62c <log_1>
		memcpy(keys->storage_start, val, len);
    d940:	462a      	mov	r2, r5
    d942:	a903      	add	r1, sp, #12
    d944:	f106 0008 	add.w	r0, r6, #8
    d948:	f00d fb57 	bl	1affa <memcpy>
	if (aging_counter_val < keys->aging_counter) {
    d94c:	4b12      	ldr	r3, [pc, #72]	; (d998 <keys_set+0x18c>)
    d94e:	f8d6 2080 	ldr.w	r2, [r6, #128]	; 0x80
    d952:	6819      	ldr	r1, [r3, #0]
    d954:	428a      	cmp	r2, r1
		aging_counter_val = keys->aging_counter;
    d956:	bf88      	it	hi
    d958:	601a      	strhi	r2, [r3, #0]
    d95a:	e76c      	b.n	d836 <keys_set+0x2a>
			BT_ERR("Invalid key length %zu != %zu", len,
    d95c:	2201      	movs	r2, #1
    d95e:	f04f 0300 	mov.w	r3, #0
    d962:	f362 0307 	bfi	r3, r2, #0, #8
    d966:	f361 138f 	bfi	r3, r1, #6, #10
    d96a:	227c      	movs	r2, #124	; 0x7c
    d96c:	4629      	mov	r1, r5
    d96e:	480b      	ldr	r0, [pc, #44]	; (d99c <keys_set+0x190>)
    d970:	f00c fe70 	bl	1a654 <log_2>
			bt_keys_clear(keys);
    d974:	4630      	mov	r0, r6
    d976:	f7ff ff23 	bl	d7c0 <bt_keys_clear>
			return -EINVAL;
    d97a:	e75a      	b.n	d832 <keys_set+0x26>
    d97c:	0001ed28 	.word	0x0001ed28
    d980:	0001edf8 	.word	0x0001edf8
    d984:	00020222 	.word	0x00020222
    d988:	000213e6 	.word	0x000213e6
    d98c:	00021837 	.word	0x00021837
    d990:	0002185a 	.word	0x0002185a
    d994:	00021879 	.word	0x00021879
    d998:	20000674 	.word	0x20000674
    d99c:	0002189b 	.word	0x0002189b

0000d9a0 <bt_keys_store>:
{
    d9a0:	b570      	push	{r4, r5, r6, lr}
	if (keys->id) {
    d9a2:	4604      	mov	r4, r0
{
    d9a4:	b08c      	sub	sp, #48	; 0x30
	if (keys->id) {
    d9a6:	f814 2b01 	ldrb.w	r2, [r4], #1
{
    d9aa:	4605      	mov	r5, r0
	if (keys->id) {
    d9ac:	b32a      	cbz	r2, d9fa <bt_keys_store+0x5a>
		u8_to_dec(id, sizeof(id), keys->id);
    d9ae:	ae02      	add	r6, sp, #8
    d9b0:	2104      	movs	r1, #4
    d9b2:	4630      	mov	r0, r6
    d9b4:	f00b f91f 	bl	18bf6 <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "keys", &keys->addr,
    d9b8:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "keys", &keys->addr,
    d9ba:	4623      	mov	r3, r4
    d9bc:	4a10      	ldr	r2, [pc, #64]	; (da00 <bt_keys_store+0x60>)
    d9be:	2124      	movs	r1, #36	; 0x24
    d9c0:	a803      	add	r0, sp, #12
    d9c2:	f7f7 fcdd 	bl	5380 <bt_settings_encode_key>
	err = settings_save_one(key, keys->storage_start, BT_KEYS_STORAGE_LEN);
    d9c6:	227c      	movs	r2, #124	; 0x7c
    d9c8:	f105 0108 	add.w	r1, r5, #8
    d9cc:	a803      	add	r0, sp, #12
    d9ce:	f7f6 f925 	bl	3c1c <settings_save_one>
	if (err) {
    d9d2:	4604      	mov	r4, r0
    d9d4:	b170      	cbz	r0, d9f4 <bt_keys_store+0x54>
		BT_ERR("Failed to save keys (err %d)", err);
    d9d6:	2301      	movs	r3, #1
    d9d8:	f04f 0200 	mov.w	r2, #0
    d9dc:	f363 0207 	bfi	r2, r3, #0, #8
    d9e0:	4908      	ldr	r1, [pc, #32]	; (da04 <bt_keys_store+0x64>)
    d9e2:	4b09      	ldr	r3, [pc, #36]	; (da08 <bt_keys_store+0x68>)
    d9e4:	1a5b      	subs	r3, r3, r1
    d9e6:	08db      	lsrs	r3, r3, #3
    d9e8:	4601      	mov	r1, r0
    d9ea:	f363 128f 	bfi	r2, r3, #6, #10
    d9ee:	4807      	ldr	r0, [pc, #28]	; (da0c <bt_keys_store+0x6c>)
    d9f0:	f00c fe1c 	bl	1a62c <log_1>
}
    d9f4:	4620      	mov	r0, r4
    d9f6:	b00c      	add	sp, #48	; 0x30
    d9f8:	bd70      	pop	{r4, r5, r6, pc}
		bt_settings_encode_key(key, sizeof(key), "keys", &keys->addr,
    d9fa:	9200      	str	r2, [sp, #0]
    d9fc:	e7dd      	b.n	d9ba <bt_keys_store+0x1a>
    d9fe:	bf00      	nop
    da00:	000218bc 	.word	0x000218bc
    da04:	0001ed28 	.word	0x0001ed28
    da08:	0001edf8 	.word	0x0001edf8
    da0c:	0002181a 	.word	0x0002181a

0000da10 <bt_keys_update_usage>:

#endif /* CONFIG_BT_SETTINGS */

#if IS_ENABLED(CONFIG_BT_KEYS_OVERWRITE_OLDEST)
void bt_keys_update_usage(u8_t id, const bt_addr_le_t *addr)
{
    da10:	b508      	push	{r3, lr}
	struct bt_keys *keys = bt_keys_find_addr(id, addr);
    da12:	f7ff fec5 	bl	d7a0 <bt_keys_find_addr>

	if (!keys) {
    da16:	b150      	cbz	r0, da2e <bt_keys_update_usage+0x1e>
		return;
	}

	if (last_keys_updated == keys) {
    da18:	4a05      	ldr	r2, [pc, #20]	; (da30 <bt_keys_update_usage+0x20>)
    da1a:	6813      	ldr	r3, [r2, #0]
    da1c:	4283      	cmp	r3, r0
    da1e:	d006      	beq.n	da2e <bt_keys_update_usage+0x1e>
		return;
	}

	keys->aging_counter = ++aging_counter_val;
    da20:	4904      	ldr	r1, [pc, #16]	; (da34 <bt_keys_update_usage+0x24>)
	last_keys_updated = keys;
    da22:	6010      	str	r0, [r2, #0]
	keys->aging_counter = ++aging_counter_val;
    da24:	680b      	ldr	r3, [r1, #0]
    da26:	3301      	adds	r3, #1
    da28:	600b      	str	r3, [r1, #0]
    da2a:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
	       keys->aging_counter);

	if (IS_ENABLED(CONFIG_BT_KEYS_SAVE_AGING_COUNTER_ON_PAIRING)) {
		bt_keys_store(keys);
	}
}
    da2e:	bd08      	pop	{r3, pc}
    da30:	200006fc 	.word	0x200006fc
    da34:	20000674 	.word	0x20000674

0000da38 <mayfly_init>:
#if defined(MAYFLY_UT)
static u8_t _state;
#endif /* MAYFLY_UT */

void mayfly_init(void)
{
    da38:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	while (callee_id--) {
		u8_t caller_id;

		caller_id = MAYFLY_CALLER_COUNT;
		while (caller_id--) {
			memq_init(&mfl[callee_id][caller_id],
    da3c:	4f11      	ldr	r7, [pc, #68]	; (da84 <mayfly_init+0x4c>)
    da3e:	f8df 9048 	ldr.w	r9, [pc, #72]	; da88 <mayfly_init+0x50>
	callee_id = MAYFLY_CALLEE_COUNT;
    da42:	2604      	movs	r6, #4
	while (callee_id--) {
    da44:	3e01      	subs	r6, #1
    da46:	b2f6      	uxtb	r6, r6
    da48:	2eff      	cmp	r6, #255	; 0xff
    da4a:	d019      	beq.n	da80 <mayfly_init+0x48>
    da4c:	b233      	sxth	r3, r6
    da4e:	ea4f 0883 	mov.w	r8, r3, lsl #2
    da52:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    da56:	011d      	lsls	r5, r3, #4
		caller_id = MAYFLY_CALLER_COUNT;
    da58:	2404      	movs	r4, #4
    da5a:	f04f 0a0c 	mov.w	sl, #12
    da5e:	e00a      	b.n	da76 <mayfly_init+0x3e>
			memq_init(&mfl[callee_id][caller_id],
    da60:	fb1a 5104 	smlabb	r1, sl, r4, r5
    da64:	1d0a      	adds	r2, r1, #4
    da66:	eb04 0008 	add.w	r0, r4, r8
    da6a:	443a      	add	r2, r7
    da6c:	4439      	add	r1, r7
    da6e:	eb09 00c0 	add.w	r0, r9, r0, lsl #3
    da72:	f00f fa4b 	bl	1cf0c <memq_init>
		while (caller_id--) {
    da76:	3c01      	subs	r4, #1
    da78:	b2e4      	uxtb	r4, r4
    da7a:	2cff      	cmp	r4, #255	; 0xff
    da7c:	d1f0      	bne.n	da60 <mayfly_init+0x28>
    da7e:	e7e1      	b.n	da44 <mayfly_init+0xc>
				  &mft[callee_id][caller_id].head,
				  &mft[callee_id][caller_id].tail);
		}
	}
}
    da80:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    da84:	20000780 	.word	0x20000780
    da88:	20000700 	.word	0x20000700

0000da8c <mayfly_enable>:

void mayfly_enable(u8_t caller_id, u8_t callee_id, u8_t enable)
{
    da8c:	b4f0      	push	{r4, r5, r6, r7}
    da8e:	2430      	movs	r4, #48	; 0x30
    da90:	4b10      	ldr	r3, [pc, #64]	; (dad4 <mayfly_enable+0x48>)
    da92:	270c      	movs	r7, #12
	if (enable) {
		if (mft[callee_id][caller_id].enable_req ==
    da94:	434c      	muls	r4, r1
    da96:	fb07 4400 	mla	r4, r7, r0, r4
{
    da9a:	4605      	mov	r5, r0
    da9c:	460e      	mov	r6, r1
		if (mft[callee_id][caller_id].enable_req ==
    da9e:	4423      	add	r3, r4
	if (enable) {
    daa0:	b152      	cbz	r2, dab8 <mayfly_enable+0x2c>
		if (mft[callee_id][caller_id].enable_req ==
    daa2:	7a59      	ldrb	r1, [r3, #9]
    daa4:	7a18      	ldrb	r0, [r3, #8]
    daa6:	4281      	cmp	r1, r0
		    mft[callee_id][caller_id].enable_ack) {
			mft[callee_id][caller_id].enable_req++;
    daa8:	bf04      	itt	eq
    daaa:	3101      	addeq	r1, #1
    daac:	7219      	strbeq	r1, [r3, #8]
		}

		mayfly_enable_cb(caller_id, callee_id, enable);
    daae:	4628      	mov	r0, r5
    dab0:	4631      	mov	r1, r6

			/* pend the callee for execution */
			mayfly_pend(caller_id, callee_id);
		}
	}
}
    dab2:	bcf0      	pop	{r4, r5, r6, r7}
		mayfly_enable_cb(caller_id, callee_id, enable);
    dab4:	f008 bba4 	b.w	16200 <mayfly_enable_cb>
		if (mft[callee_id][caller_id].disable_req ==
    dab8:	7a9c      	ldrb	r4, [r3, #10]
    daba:	7ada      	ldrb	r2, [r3, #11]
    dabc:	42a2      	cmp	r2, r4
    dabe:	d107      	bne.n	dad0 <mayfly_enable+0x44>
			mft[callee_id][caller_id].disable_req++;
    dac0:	3201      	adds	r2, #1
    dac2:	729a      	strb	r2, [r3, #10]
			mfp[callee_id] = 1U;
    dac4:	4b04      	ldr	r3, [pc, #16]	; (dad8 <mayfly_enable+0x4c>)
    dac6:	2201      	movs	r2, #1
    dac8:	545a      	strb	r2, [r3, r1]
}
    daca:	bcf0      	pop	{r4, r5, r6, r7}
			mayfly_pend(caller_id, callee_id);
    dacc:	f008 bbda 	b.w	16284 <mayfly_pend>
}
    dad0:	bcf0      	pop	{r4, r5, r6, r7}
    dad2:	4770      	bx	lr
    dad4:	20000780 	.word	0x20000780
    dad8:	20001c77 	.word	0x20001c77

0000dadc <mayfly_enqueue>:

u32_t mayfly_enqueue(u8_t caller_id, u8_t callee_id, u8_t chain,
			struct mayfly *m)
{
    dadc:	b570      	push	{r4, r5, r6, lr}
    dade:	4606      	mov	r6, r0
    dae0:	460d      	mov	r5, r1
    dae2:	461c      	mov	r4, r3
	u8_t state;
	u8_t ack;

	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
		!mayfly_is_enabled(caller_id, callee_id) ||
    dae4:	b1a2      	cbz	r2, db10 <mayfly_enqueue+0x34>
    dae6:	2301      	movs	r3, #1
		(mft[callee_id][caller_id].disable_req !=
		 mft[callee_id][caller_id].disable_ack);

	/* shadow the ack */
	ack = m->_ack;
    dae8:	7862      	ldrb	r2, [r4, #1]

	/* already in queue */
	state = (m->_req - ack) & 0x03;
    daea:	7820      	ldrb	r0, [r4, #0]
    daec:	1a80      	subs	r0, r0, r2
	if (state != 0U) {
    daee:	f010 0003 	ands.w	r0, r0, #3
    daf2:	d02c      	beq.n	db4e <mayfly_enqueue+0x72>
		if (chain) {
    daf4:	b31b      	cbz	r3, db3e <mayfly_enqueue+0x62>
			if (state != 1U) {
    daf6:	2801      	cmp	r0, #1
    daf8:	d028      	beq.n	db4c <mayfly_enqueue+0x70>
				/* mark as ready in queue */
				m->_req = ack + 1;
    dafa:	3201      	adds	r2, #1
    dafc:	b2d2      	uxtb	r2, r2
    dafe:	7022      	strb	r2, [r4, #0]
	m->_req = ack + 1;
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);

mayfly_enqueue_pend:
	/* set mayfly callee pending */
	mfp[callee_id] = 1U;
    db00:	4b1c      	ldr	r3, [pc, #112]	; (db74 <mayfly_enqueue+0x98>)
    db02:	2201      	movs	r2, #1

	/* pend the callee for execution */
	mayfly_pend(caller_id, callee_id);
    db04:	4629      	mov	r1, r5
    db06:	4630      	mov	r0, r6
	mfp[callee_id] = 1U;
    db08:	555a      	strb	r2, [r3, r5]
	mayfly_pend(caller_id, callee_id);
    db0a:	f008 fbbb 	bl	16284 <mayfly_pend>
    db0e:	e01c      	b.n	db4a <mayfly_enqueue+0x6e>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
    db10:	f010 f846 	bl	1dba0 <mayfly_prio_is_equal>
    db14:	2800      	cmp	r0, #0
    db16:	d0e6      	beq.n	dae6 <mayfly_enqueue+0xa>
		!mayfly_is_enabled(caller_id, callee_id) ||
    db18:	4629      	mov	r1, r5
    db1a:	4630      	mov	r0, r6
    db1c:	f008 fb90 	bl	16240 <mayfly_is_enabled>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
    db20:	2800      	cmp	r0, #0
    db22:	d0e0      	beq.n	dae6 <mayfly_enqueue+0xa>
		(mft[callee_id][caller_id].disable_req !=
    db24:	2330      	movs	r3, #48	; 0x30
    db26:	220c      	movs	r2, #12
    db28:	436b      	muls	r3, r5
    db2a:	fb02 3306 	mla	r3, r2, r6, r3
    db2e:	4a12      	ldr	r2, [pc, #72]	; (db78 <mayfly_enqueue+0x9c>)
    db30:	441a      	add	r2, r3
		!mayfly_is_enabled(caller_id, callee_id) ||
    db32:	7a93      	ldrb	r3, [r2, #10]
    db34:	7ad2      	ldrb	r2, [r2, #11]
    db36:	1a9b      	subs	r3, r3, r2
    db38:	bf18      	it	ne
    db3a:	2301      	movne	r3, #1
    db3c:	e7d4      	b.n	dae8 <mayfly_enqueue+0xc>
		m->_req = ack + 2;
    db3e:	3202      	adds	r2, #2
    db40:	b2d2      	uxtb	r2, r2
    db42:	7022      	strb	r2, [r4, #0]
		m->fp(m->param);
    db44:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
    db48:	4798      	blx	r3

	return 0;
    db4a:	2000      	movs	r0, #0
}
    db4c:	bd70      	pop	{r4, r5, r6, pc}
	if (!chain) {
    db4e:	2b00      	cmp	r3, #0
    db50:	d0f8      	beq.n	db44 <mayfly_enqueue+0x68>
	m->_req = ack + 1;
    db52:	3201      	adds	r2, #1
    db54:	b2d2      	uxtb	r2, r2
    db56:	7022      	strb	r2, [r4, #0]
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
    db58:	2304      	movs	r3, #4
    db5a:	2230      	movs	r2, #48	; 0x30
    db5c:	fb12 3205 	smlabb	r2, r2, r5, r3
    db60:	230c      	movs	r3, #12
    db62:	fb13 2306 	smlabb	r3, r3, r6, r2
    db66:	4a04      	ldr	r2, [pc, #16]	; (db78 <mayfly_enqueue+0x9c>)
    db68:	6860      	ldr	r0, [r4, #4]
    db6a:	441a      	add	r2, r3
    db6c:	4621      	mov	r1, r4
    db6e:	f00f f9db 	bl	1cf28 <memq_enqueue>
    db72:	e7c5      	b.n	db00 <mayfly_enqueue+0x24>
    db74:	20001c77 	.word	0x20001c77
    db78:	20000780 	.word	0x20000780

0000db7c <mayfly_run>:
		}
	}
}

void mayfly_run(u8_t callee_id)
{
    db7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8_t disable = 0U;
	u8_t enable = 0U;
	u8_t caller_id;

	if (!mfp[callee_id]) {
    db80:	4b57      	ldr	r3, [pc, #348]	; (dce0 <mayfly_run+0x164>)
    db82:	5c1a      	ldrb	r2, [r3, r0]
{
    db84:	b089      	sub	sp, #36	; 0x24
    db86:	4605      	mov	r5, r0
	if (!mfp[callee_id]) {
    db88:	2a00      	cmp	r2, #0
    db8a:	f000 80a2 	beq.w	dcd2 <mayfly_run+0x156>
		return;
	}
	mfp[callee_id] = 0U;
    db8e:	2600      	movs	r6, #0
    db90:	541e      	strb	r6, [r3, r0]

	/* iterate through each caller queue to this callee_id */
	caller_id = MAYFLY_CALLER_COUNT;
	while (caller_id--) {
    db92:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    db96:	011b      	lsls	r3, r3, #4
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
    db98:	f8df b148 	ldr.w	fp, [pc, #328]	; dce4 <mayfly_run+0x168>
    db9c:	9304      	str	r3, [sp, #16]
    db9e:	2404      	movs	r4, #4
    dba0:	233c      	movs	r3, #60	; 0x3c
    dba2:	fb13 4300 	smlabb	r3, r3, r0, r4
    dba6:	445b      	add	r3, fp
    dba8:	9303      	str	r3, [sp, #12]
	u8_t disable = 0U;
    dbaa:	9600      	str	r6, [sp, #0]
    dbac:	46d9      	mov	r9, fp
	while (caller_id--) {
    dbae:	3c01      	subs	r4, #1
    dbb0:	b2e4      	uxtb	r4, r4
    dbb2:	2cff      	cmp	r4, #255	; 0xff
    dbb4:	d10c      	bne.n	dbd0 <mayfly_run+0x54>
			mft[callee_id][caller_id].enable_ack =
				mft[callee_id][caller_id].enable_req;
		}
	}

	if (disable && !enable) {
    dbb6:	9b00      	ldr	r3, [sp, #0]
    dbb8:	2b00      	cmp	r3, #0
    dbba:	f000 808a 	beq.w	dcd2 <mayfly_run+0x156>
    dbbe:	2e00      	cmp	r6, #0
    dbc0:	f040 8087 	bne.w	dcd2 <mayfly_run+0x156>
		mayfly_enable_cb(callee_id, callee_id, 0);
    dbc4:	4632      	mov	r2, r6
    dbc6:	4629      	mov	r1, r5
    dbc8:	4628      	mov	r0, r5
    dbca:	f008 fb19 	bl	16200 <mayfly_enable_cb>
    dbce:	e080      	b.n	dcd2 <mayfly_run+0x156>
		struct mayfly *m = 0;
    dbd0:	2300      	movs	r3, #0
		link = memq_peek(mft[callee_id][caller_id].head,
    dbd2:	270c      	movs	r7, #12
		struct mayfly *m = 0;
    dbd4:	9307      	str	r3, [sp, #28]
		link = memq_peek(mft[callee_id][caller_id].head,
    dbd6:	4367      	muls	r7, r4
    dbd8:	2330      	movs	r3, #48	; 0x30
    dbda:	fb03 7305 	mla	r3, r3, r5, r7
    dbde:	eb09 0103 	add.w	r1, r9, r3
    dbe2:	aa07      	add	r2, sp, #28
    dbe4:	f859 0003 	ldr.w	r0, [r9, r3]
    dbe8:	6849      	ldr	r1, [r1, #4]
    dbea:	f00f f9a4 	bl	1cf36 <memq_peek>
		memq_dequeue(mft[callee_id][caller_id].tail,
    dbee:	9a04      	ldr	r2, [sp, #16]
    dbf0:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    dbf4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    dbf8:	444b      	add	r3, r9
    dbfa:	e9cd 7301 	strd	r7, r3, [sp, #4]
		link = memq_peek(mft[callee_id][caller_id].head,
    dbfe:	4682      	mov	sl, r0
		while (link) {
    dc00:	f1ba 0f00 	cmp.w	sl, #0
    dc04:	d047      	beq.n	dc96 <mayfly_run+0x11a>
			state = (m->_req - m->_ack) & 0x03;
    dc06:	9b07      	ldr	r3, [sp, #28]
    dc08:	f893 8000 	ldrb.w	r8, [r3]
    dc0c:	785a      	ldrb	r2, [r3, #1]
    dc0e:	eba8 0802 	sub.w	r8, r8, r2
    dc12:	f008 0803 	and.w	r8, r8, #3
			if (state == 1U) {
    dc16:	f1b8 0f01 	cmp.w	r8, #1
    dc1a:	d104      	bne.n	dc26 <mayfly_run+0xaa>
				m->_ack--;
    dc1c:	3a01      	subs	r2, #1
    dc1e:	705a      	strb	r2, [r3, #1]
				m->fp(m->param);
    dc20:	e9d3 0202 	ldrd	r0, r2, [r3, #8]
    dc24:	4790      	blx	r2
			dequeue(callee_id, caller_id, link, m);
    dc26:	9f07      	ldr	r7, [sp, #28]
	req = m->_req;
    dc28:	783b      	ldrb	r3, [r7, #0]
	if (((req - m->_ack) & 0x03) != 1U) {
    dc2a:	787a      	ldrb	r2, [r7, #1]
	req = m->_req;
    dc2c:	b2db      	uxtb	r3, r3
	if (((req - m->_ack) & 0x03) != 1U) {
    dc2e:	1a9a      	subs	r2, r3, r2
    dc30:	f002 0203 	and.w	r2, r2, #3
    dc34:	2a01      	cmp	r2, #1
    dc36:	9305      	str	r3, [sp, #20]
    dc38:	d01b      	beq.n	dc72 <mayfly_run+0xf6>
		memq_dequeue(mft[callee_id][caller_id].tail,
    dc3a:	9b01      	ldr	r3, [sp, #4]
    dc3c:	9902      	ldr	r1, [sp, #8]
    dc3e:	2030      	movs	r0, #48	; 0x30
    dc40:	fb00 3005 	mla	r0, r0, r5, r3
    dc44:	4b27      	ldr	r3, [pc, #156]	; (dce4 <mayfly_run+0x168>)
    dc46:	4418      	add	r0, r3
    dc48:	2200      	movs	r2, #0
    dc4a:	6840      	ldr	r0, [r0, #4]
    dc4c:	f00f f97b 	bl	1cf46 <memq_dequeue>
		m->_ack = req;
    dc50:	9b05      	ldr	r3, [sp, #20]
		ack = m->_ack;
    dc52:	787a      	ldrb	r2, [r7, #1]
		m->_ack = req;
    dc54:	707b      	strb	r3, [r7, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
    dc56:	783b      	ldrb	r3, [r7, #0]
		m->_link = link;
    dc58:	f8c7 a004 	str.w	sl, [r7, #4]
		if (((m->_req - ack) & 0x03) == 1U) {
    dc5c:	1a9b      	subs	r3, r3, r2
    dc5e:	f003 0303 	and.w	r3, r3, #3
    dc62:	2b01      	cmp	r3, #1
    dc64:	d105      	bne.n	dc72 <mayfly_run+0xf6>
			m->_ack = ack;
    dc66:	707a      	strb	r2, [r7, #1]
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
    dc68:	4639      	mov	r1, r7
    dc6a:	9a03      	ldr	r2, [sp, #12]
    dc6c:	4650      	mov	r0, sl
    dc6e:	f00f f95b 	bl	1cf28 <memq_enqueue>
			link = memq_peek(mft[callee_id][caller_id].head,
    dc72:	9a01      	ldr	r2, [sp, #4]
    dc74:	2330      	movs	r3, #48	; 0x30
    dc76:	fb03 2305 	mla	r3, r3, r5, r2
    dc7a:	eb09 0103 	add.w	r1, r9, r3
    dc7e:	aa07      	add	r2, sp, #28
    dc80:	6849      	ldr	r1, [r1, #4]
    dc82:	f859 0003 	ldr.w	r0, [r9, r3]
    dc86:	f00f f956 	bl	1cf36 <memq_peek>
			if (state == 1U) {
    dc8a:	f1b8 0f01 	cmp.w	r8, #1
			link = memq_peek(mft[callee_id][caller_id].head,
    dc8e:	4682      	mov	sl, r0
			if (state == 1U) {
    dc90:	d1b6      	bne.n	dc00 <mayfly_run+0x84>
				if (caller_id || link) {
    dc92:	b9bc      	cbnz	r4, dcc4 <mayfly_run+0x148>
    dc94:	b9b0      	cbnz	r0, dcc4 <mayfly_run+0x148>
		if (mft[callee_id][caller_id].disable_req !=
    dc96:	2230      	movs	r2, #48	; 0x30
    dc98:	4912      	ldr	r1, [pc, #72]	; (dce4 <mayfly_run+0x168>)
    dc9a:	230c      	movs	r3, #12
    dc9c:	436a      	muls	r2, r5
    dc9e:	fb03 2204 	mla	r2, r3, r4, r2
    dca2:	440a      	add	r2, r1
    dca4:	7a91      	ldrb	r1, [r2, #10]
    dca6:	7ad0      	ldrb	r0, [r2, #11]
    dca8:	4288      	cmp	r0, r1
    dcaa:	d115      	bne.n	dcd8 <mayfly_run+0x15c>
		if (mft[callee_id][caller_id].enable_req !=
    dcac:	2230      	movs	r2, #48	; 0x30
    dcae:	436a      	muls	r2, r5
    dcb0:	fb03 2304 	mla	r3, r3, r4, r2
    dcb4:	445b      	add	r3, fp
    dcb6:	7a1a      	ldrb	r2, [r3, #8]
    dcb8:	7a59      	ldrb	r1, [r3, #9]
    dcba:	4291      	cmp	r1, r2
			mft[callee_id][caller_id].enable_ack =
    dcbc:	bf1c      	itt	ne
    dcbe:	725a      	strbne	r2, [r3, #9]
			enable = 1U;
    dcc0:	2601      	movne	r6, #1
    dcc2:	e774      	b.n	dbae <mayfly_run+0x32>
					mfp[callee_id] = 1U;
    dcc4:	4b06      	ldr	r3, [pc, #24]	; (dce0 <mayfly_run+0x164>)
    dcc6:	2201      	movs	r2, #1
					mayfly_pend(callee_id, callee_id);
    dcc8:	4629      	mov	r1, r5
    dcca:	4628      	mov	r0, r5
					mfp[callee_id] = 1U;
    dccc:	555a      	strb	r2, [r3, r5]
					mayfly_pend(callee_id, callee_id);
    dcce:	f008 fad9 	bl	16284 <mayfly_pend>
	}
}
    dcd2:	b009      	add	sp, #36	; 0x24
    dcd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mft[callee_id][caller_id].disable_ack =
    dcd8:	72d1      	strb	r1, [r2, #11]
			disable = 1U;
    dcda:	2201      	movs	r2, #1
    dcdc:	9200      	str	r2, [sp, #0]
    dcde:	e7e5      	b.n	dcac <mayfly_run+0x130>
    dce0:	20001c77 	.word	0x20001c77
    dce4:	20000780 	.word	0x20000780

0000dce8 <ticker_job>:
 * @param param Pointer to ticker instance
 *
 * @internal
 */
void ticker_job(void *param)
{
    dce8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8_t flag_compare_update;

	DEBUG_TICKER_JOB(1);

	/* Defer worker, as job is now running */
	if (instance->worker_trigger) {
    dcec:	7fc2      	ldrb	r2, [r0, #31]
{
    dcee:	b08f      	sub	sp, #60	; 0x3c
    dcf0:	4604      	mov	r4, r0
	if (instance->worker_trigger) {
    dcf2:	2a00      	cmp	r2, #0
    dcf4:	f040 830c 	bne.w	e310 <ticker_job+0x628>
		return;
	}
	instance->job_guard = 1U;

	/* Back up the previous known tick */
	ticks_previous = instance->ticks_current;
    dcf8:	6943      	ldr	r3, [r0, #20]
    dcfa:	9304      	str	r3, [sp, #16]
	instance->job_guard = 1U;
    dcfc:	2101      	movs	r1, #1

	/* Update current tick with the elapsed value from queue, and dequeue */
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
    dcfe:	7a83      	ldrb	r3, [r0, #10]
	instance->job_guard = 1U;
    dd00:	7781      	strb	r1, [r0, #30]
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
    dd02:	7ac0      	ldrb	r0, [r0, #11]
    dd04:	4298      	cmp	r0, r3
    dd06:	d077      	beq.n	ddf8 <ticker_job+0x110>
	u8_t idx = *ticks_elapsed_index + 1;
    dd08:	440b      	add	r3, r1
    dd0a:	b2db      	uxtb	r3, r3
		idx = 0U;
    dd0c:	2b02      	cmp	r3, #2
    dd0e:	bf08      	it	eq
    dd10:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
    dd12:	72a3      	strb	r3, [r4, #10]
		ticker_next_elapsed(&instance->ticks_elapsed_first);

		ticks_elapsed =
    dd14:	eb04 0383 	add.w	r3, r4, r3, lsl #2
		    instance->ticks_elapsed[instance->ticks_elapsed_first];

		instance->ticks_current += ticks_elapsed;
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;

		flag_elapsed = 1U;
    dd18:	9101      	str	r1, [sp, #4]
		ticks_elapsed =
    dd1a:	f8d3 a00c 	ldr.w	sl, [r3, #12]
		instance->ticks_current += ticks_elapsed;
    dd1e:	9b04      	ldr	r3, [sp, #16]
    dd20:	4453      	add	r3, sl
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;
    dd22:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    dd26:	6163      	str	r3, [r4, #20]
	flag_compare_update = 0U;

	/* Remember the old head, so as to decide if new compare needs to be
	 * set.
	 */
	ticker_id_old_head = instance->ticker_id_head;
    dd28:	7f63      	ldrb	r3, [r4, #29]
    dd2a:	9303      	str	r3, [sp, #12]
	node = &instance->nodes[0];
    dd2c:	6823      	ldr	r3, [r4, #0]
    dd2e:	9305      	str	r3, [sp, #20]
	users = &instance->users[0];
    dd30:	6863      	ldr	r3, [r4, #4]
    dd32:	930c      	str	r3, [sp, #48]	; 0x30
	count_user = instance->count_user;
    dd34:	7a63      	ldrb	r3, [r4, #9]
    dd36:	9302      	str	r3, [sp, #8]
	pending = 0U;
    dd38:	2300      	movs	r3, #0
    dd3a:	9308      	str	r3, [sp, #32]
	insert_head = TICKER_NULL;
    dd3c:	f04f 0bff 	mov.w	fp, #255	; 0xff
	while (count_user--) {
    dd40:	9b02      	ldr	r3, [sp, #8]
    dd42:	3b01      	subs	r3, #1
    dd44:	b2db      	uxtb	r3, r3
    dd46:	2bff      	cmp	r3, #255	; 0xff
    dd48:	9302      	str	r3, [sp, #8]
    dd4a:	d158      	bne.n	ddfe <ticker_job+0x116>

	/* Manage user operations (updates and deletions) in ticker list */
	pending = ticker_job_list_manage(instance, ticks_elapsed, &insert_head);

	/* Detect change in head of the list */
	if (instance->ticker_id_head != ticker_id_old_head) {
    dd4c:	7f63      	ldrb	r3, [r4, #29]
		flag_compare_update = 1U;
    dd4e:	9a03      	ldr	r2, [sp, #12]
    dd50:	1a9b      	subs	r3, r3, r2
    dd52:	bf18      	it	ne
    dd54:	2301      	movne	r3, #1
    dd56:	9302      	str	r3, [sp, #8]
	}

	/* Handle expired tickers */
	if (flag_elapsed) {
    dd58:	9b01      	ldr	r3, [sp, #4]
    dd5a:	b1cb      	cbz	r3, dd90 <ticker_job+0xa8>
    dd5c:	f8d4 9000 	ldr.w	r9, [r4]
	ticks_expired = 0U;
    dd60:	f04f 0800 	mov.w	r8, #0
	while (instance->ticker_id_head != TICKER_NULL) {
    dd64:	7f66      	ldrb	r6, [r4, #29]
    dd66:	2eff      	cmp	r6, #255	; 0xff
    dd68:	d00b      	beq.n	dd82 <ticker_job+0x9a>
		ticker = &node[id_expired];
    dd6a:	272c      	movs	r7, #44	; 0x2c
    dd6c:	fb16 f707 	smulbb	r7, r6, r7
    dd70:	eb09 0507 	add.w	r5, r9, r7
		ticks_to_expire = ticker->ticks_to_expire;
    dd74:	68aa      	ldr	r2, [r5, #8]
		if (ticks_elapsed < ticks_to_expire) {
    dd76:	4552      	cmp	r2, sl
    dd78:	f240 8105 	bls.w	df86 <ticker_job+0x29e>
			ticker->ticks_to_expire -= ticks_elapsed;
    dd7c:	eba2 020a 	sub.w	r2, r2, sl
    dd80:	60aa      	str	r2, [r5, #8]
		ticker_job_worker_bh(instance, ticks_previous, ticks_elapsed,
				     &insert_head);

		/* detect change in head of the list */
		if (instance->ticker_id_head != ticker_id_old_head) {
			flag_compare_update = 1U;
    dd82:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
    dd86:	9903      	ldr	r1, [sp, #12]
    dd88:	42b1      	cmp	r1, r6
    dd8a:	bf18      	it	ne
    dd8c:	4613      	movne	r3, r2
    dd8e:	9302      	str	r3, [sp, #8]
	node = &instance->nodes[0];
    dd90:	6823      	ldr	r3, [r4, #0]
    dd92:	9305      	str	r3, [sp, #20]
	users = &instance->users[0];
    dd94:	6863      	ldr	r3, [r4, #4]
    dd96:	930b      	str	r3, [sp, #44]	; 0x2c
	count_user = instance->count_user;
    dd98:	7a63      	ldrb	r3, [r4, #9]
    dd9a:	9301      	str	r3, [sp, #4]
				ticker = &node[id_insert];
    dd9c:	f04f 092c 	mov.w	r9, #44	; 0x2c
	while (count_user--) {
    dda0:	9b01      	ldr	r3, [sp, #4]
    dda2:	3b01      	subs	r3, #1
    dda4:	b2db      	uxtb	r3, r3
    dda6:	2bff      	cmp	r3, #255	; 0xff
    dda8:	9301      	str	r3, [sp, #4]
    ddaa:	f040 8137 	bne.w	e01c <ticker_job+0x334>
	/* Handle insertions */
	ticker_job_list_insert(instance, insert_head);

	/* detect change in head of the list */
	if (instance->ticker_id_head != ticker_id_old_head) {
		flag_compare_update = 1U;
    ddae:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
	if (instance->ticker_id_head != ticker_id_old_head) {
    ddb2:	7f63      	ldrb	r3, [r4, #29]
		flag_compare_update = 1U;
    ddb4:	428b      	cmp	r3, r1
    ddb6:	bf18      	it	ne
    ddb8:	2201      	movne	r2, #1
	}

	/* Process any list inquiries */
	if (!pending) {
    ddba:	9b08      	ldr	r3, [sp, #32]
		flag_compare_update = 1U;
    ddbc:	9202      	str	r2, [sp, #8]
	if (!pending) {
    ddbe:	2b00      	cmp	r3, #0
    ddc0:	f000 81d7 	beq.w	e172 <ticker_job+0x48a>
		/* Handle inquiries */
		ticker_job_list_inquire(instance);
	}

	/* Permit worker job to run */
	instance->job_guard = 0U;
    ddc4:	2300      	movs	r3, #0
    ddc6:	77a3      	strb	r3, [r4, #30]

	/* update compare if head changed */
	if (flag_compare_update) {
    ddc8:	9b02      	ldr	r3, [sp, #8]
    ddca:	b13b      	cbz	r3, dddc <ticker_job+0xf4>
	if (instance->ticker_id_head == TICKER_NULL) {
    ddcc:	7f63      	ldrb	r3, [r4, #29]
    ddce:	2bff      	cmp	r3, #255	; 0xff
    ddd0:	f040 823c 	bne.w	e24c <ticker_job+0x564>
		if (cntr_stop() == 0) {
    ddd4:	f007 fdd4 	bl	15980 <cntr_stop>
    ddd8:	b900      	cbnz	r0, dddc <ticker_job+0xf4>
			instance->ticks_slot_previous = 0U;
    ddda:	61a0      	str	r0, [r4, #24]
		ticker_job_compare_update(instance, ticker_id_old_head);
	}

	/* trigger worker if deferred */
	if (instance->worker_trigger) {
    dddc:	7fe3      	ldrb	r3, [r4, #31]
    ddde:	2b00      	cmp	r3, #0
    dde0:	f000 8296 	beq.w	e310 <ticker_job+0x628>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
    dde4:	6a65      	ldr	r5, [r4, #36]	; 0x24
    dde6:	4623      	mov	r3, r4
    dde8:	2201      	movs	r2, #1
    ddea:	2103      	movs	r1, #3
    ddec:	2004      	movs	r0, #4
    ddee:	46ac      	mov	ip, r5
				   instance);
	}

	DEBUG_TICKER_JOB(0);
}
    ddf0:	b00f      	add	sp, #60	; 0x3c
    ddf2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
    ddf6:	4760      	bx	ip
		flag_elapsed = 0U;
    ddf8:	9201      	str	r2, [sp, #4]
		ticks_elapsed = 0U;
    ddfa:	4692      	mov	sl, r2
    ddfc:	e794      	b.n	dd28 <ticker_job+0x40>
		user = &users[count_user];
    ddfe:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    de00:	9a02      	ldr	r2, [sp, #8]
    de02:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
		user_ops = &user->user_op[0];
    de06:	687b      	ldr	r3, [r7, #4]
    de08:	9306      	str	r3, [sp, #24]
		while (user->middle != user->last) {
    de0a:	78f9      	ldrb	r1, [r7, #3]
    de0c:	f897 8002 	ldrb.w	r8, [r7, #2]
    de10:	4588      	cmp	r8, r1
    de12:	d095      	beq.n	dd40 <ticker_job+0x58>
			user_op = &user_ops[user->middle];
    de14:	9b06      	ldr	r3, [sp, #24]
			if (middle == user->count_user_op) {
    de16:	7838      	ldrb	r0, [r7, #0]
			user_op = &user_ops[user->middle];
    de18:	eb08 0248 	add.w	r2, r8, r8, lsl #1
    de1c:	0112      	lsls	r2, r2, #4
    de1e:	189e      	adds	r6, r3, r2
			middle = user->middle + 1;
    de20:	f108 0301 	add.w	r3, r8, #1
    de24:	b2db      	uxtb	r3, r3
				middle = 0U;
    de26:	4298      	cmp	r0, r3
    de28:	bf08      	it	eq
    de2a:	2300      	moveq	r3, #0
			user->middle = middle;
    de2c:	70bb      	strb	r3, [r7, #2]
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
    de2e:	9b06      	ldr	r3, [sp, #24]
    de30:	5c9a      	ldrb	r2, [r3, r2]
    de32:	2a04      	cmp	r2, #4
    de34:	d9ea      	bls.n	de0c <ticker_job+0x124>
			ticker = &node[user_op->id];
    de36:	7873      	ldrb	r3, [r6, #1]
    de38:	212c      	movs	r1, #44	; 0x2c
    de3a:	fb13 f101 	smulbb	r1, r3, r1
    de3e:	910b      	str	r1, [sp, #44]	; 0x2c
    de40:	980b      	ldr	r0, [sp, #44]	; 0x2c
    de42:	9905      	ldr	r1, [sp, #20]
    de44:	180d      	adds	r5, r1, r0
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP) ||
    de46:	2a06      	cmp	r2, #6
			state = (ticker->req - ticker->ack) & 0xff;
    de48:	78a9      	ldrb	r1, [r5, #2]
    de4a:	f895 c001 	ldrb.w	ip, [r5, #1]
    de4e:	9107      	str	r1, [sp, #28]
    de50:	ebac 0c01 	sub.w	ip, ip, r1
    de54:	fa5f f18c 	uxtb.w	r1, ip
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP) ||
    de58:	d80e      	bhi.n	de78 <ticker_job+0x190>
    de5a:	b169      	cbz	r1, de78 <ticker_job+0x190>
			    (state == 0U) ||
    de5c:	2a05      	cmp	r2, #5
    de5e:	d110      	bne.n	de82 <ticker_job+0x19a>
			    ((user_op->op == TICKER_USER_OP_TYPE_UPDATE) &&
    de60:	6870      	ldr	r0, [r6, #4]
    de62:	b970      	cbnz	r0, de82 <ticker_job+0x19a>
			     (user_op->params.update.ticks_drift_plus == 0U) &&
    de64:	68b0      	ldr	r0, [r6, #8]
    de66:	b960      	cbnz	r0, de82 <ticker_job+0x19a>
			     (user_op->params.update.ticks_drift_minus == 0U) &&
    de68:	68f0      	ldr	r0, [r6, #12]
    de6a:	b950      	cbnz	r0, de82 <ticker_job+0x19a>
			     (user_op->params.update.ticks_slot_plus == 0U) &&
    de6c:	6930      	ldr	r0, [r6, #16]
    de6e:	b940      	cbnz	r0, de82 <ticker_job+0x19a>
			     (user_op->params.update.lazy == 0U) &&
    de70:	6970      	ldr	r0, [r6, #20]
    de72:	f030 407f 	bics.w	r0, r0, #4278190080	; 0xff000000
    de76:	d104      	bne.n	de82 <ticker_job+0x19a>
				ticker_job_op_cb(user_op,
    de78:	2101      	movs	r1, #1
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
    de7a:	4630      	mov	r0, r6
    de7c:	f00f f8a3 	bl	1cfc6 <ticker_job_op_cb>
    de80:	e7c3      	b.n	de0a <ticker_job+0x122>
			if (state == 1U) {
    de82:	2901      	cmp	r1, #1
    de84:	d174      	bne.n	df70 <ticker_job+0x288>
	previous = instance->ticker_id_head;
    de86:	f894 c01d 	ldrb.w	ip, [r4, #29]
	node = &instance->nodes[0];
    de8a:	6821      	ldr	r1, [r4, #0]
	previous = instance->ticker_id_head;
    de8c:	46e6      	mov	lr, ip
	total = 0U;
    de8e:	f04f 0800 	mov.w	r8, #0
	while (current != TICKER_NULL) {
    de92:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
    de96:	d146      	bne.n	df26 <ticker_job+0x23e>
		return 0;
    de98:	f04f 0800 	mov.w	r8, #0
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
    de9c:	2a05      	cmp	r2, #5
	ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
    de9e:	f8c5 8008 	str.w	r8, [r5, #8]
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
    dea2:	d151      	bne.n	df48 <ticker_job+0x260>
		ticker_job_node_update(ticker, user_op, instance->ticks_current,
    dea4:	f8d4 9014 	ldr.w	r9, [r4, #20]
	ticks_now = cntr_cnt_get();
    dea8:	f007 fd90 	bl	159cc <cntr_cnt_get>
 * @param ticks_now Highest tick count (now)
 * @param ticks_old Tick count to subtract from ticks_now
 */
u32_t ticker_ticks_diff_get(u32_t ticks_now, u32_t ticks_old)
{
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    deac:	eba0 0109 	sub.w	r1, r0, r9
    deb0:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
    deb4:	4451      	add	r1, sl
	if (ticks_to_expire > ticks_elapsed) {
    deb6:	4588      	cmp	r8, r1
		ticker->ticks_to_expire_minus += ticks_elapsed -
    deb8:	bf98      	it	ls
    deba:	696b      	ldrls	r3, [r5, #20]
	ticks_now = cntr_cnt_get();
    debc:	4602      	mov	r2, r0
		ticker->ticks_to_expire_minus += ticks_elapsed -
    debe:	bf98      	it	ls
    dec0:	eba3 0808 	subls.w	r8, r3, r8
	if ((ticker->ticks_periodic != 0U) &&
    dec4:	6868      	ldr	r0, [r5, #4]
		ticker->ticks_to_expire_minus += ticks_elapsed -
    dec6:	bf97      	itett	ls
    dec8:	4441      	addls	r1, r8
		ticks_to_expire -= ticks_elapsed;
    deca:	eba8 0801 	subhi.w	r8, r8, r1
		ticker->ticks_to_expire_minus += ticks_elapsed -
    dece:	6169      	strls	r1, [r5, #20]
		ticks_to_expire = 0U;
    ded0:	f04f 0800 	movls.w	r8, #0
	if ((ticker->ticks_periodic != 0U) &&
    ded4:	b128      	cbz	r0, dee2 <ticker_job+0x1fa>
	    (user_op->params.update.lazy != 0U)) {
    ded6:	8ab3      	ldrh	r3, [r6, #20]
	if ((ticker->ticks_periodic != 0U) &&
    ded8:	b11b      	cbz	r3, dee2 <ticker_job+0x1fa>
		user_op->params.update.lazy--;
    deda:	3b01      	subs	r3, #1
    dedc:	b29b      	uxth	r3, r3
    dede:	82b3      	strh	r3, [r6, #20]
		ticker->lazy_periodic = user_op->params.update.lazy;
    dee0:	83ab      	strh	r3, [r5, #28]
	ticker->ticks_to_expire = ticks_to_expire +
    dee2:	6871      	ldr	r1, [r6, #4]
	ticker->ticks_to_expire_minus +=
    dee4:	696b      	ldr	r3, [r5, #20]
	ticker->ticks_to_expire = ticks_to_expire +
    dee6:	4441      	add	r1, r8
    dee8:	60a9      	str	r1, [r5, #8]
	ticker->ticks_to_expire_minus +=
    deea:	68b1      	ldr	r1, [r6, #8]
    deec:	440b      	add	r3, r1
    deee:	616b      	str	r3, [r5, #20]
	ticks_to_expire_prep(ticker, ticks_current, ticks_now);
    def0:	4649      	mov	r1, r9
    def2:	4628      	mov	r0, r5
    def4:	f00f f849 	bl	1cf8a <ticks_to_expire_prep>
	ticker->ticks_slot += user_op->params.update.ticks_slot_plus;
    def8:	68f2      	ldr	r2, [r6, #12]
    defa:	69ab      	ldr	r3, [r5, #24]
    defc:	4413      	add	r3, r2
	if (ticker->ticks_slot > user_op->params.update.ticks_slot_minus) {
    defe:	6932      	ldr	r2, [r6, #16]
    df00:	4293      	cmp	r3, r2
		ticker->ticks_slot -= user_op->params.update.ticks_slot_minus;
    df02:	bf8c      	ite	hi
    df04:	1a9b      	subhi	r3, r3, r2
		ticker->ticks_slot = 0U;
    df06:	2300      	movls	r3, #0
    df08:	61ab      	str	r3, [r5, #24]
	if (user_op->params.update.force != 0U) {
    df0a:	7db3      	ldrb	r3, [r6, #22]
    df0c:	b103      	cbz	r3, df10 <ticker_job+0x228>
		ticker->force = user_op->params.update.force;
    df0e:	70eb      	strb	r3, [r5, #3]
	ticker->next = *insert_head;
    df10:	9b05      	ldr	r3, [sp, #20]
    df12:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    df14:	f803 b002 	strb.w	fp, [r3, r2]
		ticker->req++;
    df18:	786b      	ldrb	r3, [r5, #1]
	*insert_head = user_op->id;
    df1a:	f896 b001 	ldrb.w	fp, [r6, #1]
		ticker->req++;
    df1e:	3301      	adds	r3, #1
    df20:	706b      	strb	r3, [r5, #1]
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
    df22:	2100      	movs	r1, #0
    df24:	e7a9      	b.n	de7a <ticker_job+0x192>
		ticker_current = &node[current];
    df26:	202c      	movs	r0, #44	; 0x2c
    df28:	fb1c f900 	smulbb	r9, ip, r0
    df2c:	eb01 0009 	add.w	r0, r1, r9
    df30:	9009      	str	r0, [sp, #36]	; 0x24
		if (current == id) {
    df32:	6880      	ldr	r0, [r0, #8]
    df34:	900a      	str	r0, [sp, #40]	; 0x28
    df36:	4563      	cmp	r3, ip
    df38:	4480      	add	r8, r0
    df3a:	f811 9009 	ldrb.w	r9, [r1, r9]
    df3e:	f000 81cd 	beq.w	e2dc <ticker_job+0x5f4>
    df42:	46e6      	mov	lr, ip
    df44:	46cc      	mov	ip, r9
    df46:	e7a4      	b.n	de92 <ticker_job+0x1aa>
		ticker->req = ticker->ack;
    df48:	9a07      	ldr	r2, [sp, #28]
    df4a:	706a      	strb	r2, [r5, #1]
		if (instance->ticker_id_slot_previous == user_op->id) {
    df4c:	7f22      	ldrb	r2, [r4, #28]
    df4e:	429a      	cmp	r2, r3
    df50:	d1e7      	bne.n	df22 <ticker_job+0x23a>
			u32_t ticks_now = cntr_cnt_get();
    df52:	f007 fd3b 	bl	159cc <cntr_cnt_get>
			instance->ticker_id_slot_previous = TICKER_NULL;
    df56:	23ff      	movs	r3, #255	; 0xff
    df58:	7723      	strb	r3, [r4, #28]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    df5a:	6963      	ldr	r3, [r4, #20]
    df5c:	1ac0      	subs	r0, r0, r3
    df5e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticks_used = ticks_elapsed +
    df62:	4450      	add	r0, sl
			instance->ticks_slot_previous =	MIN(ticker->ticks_slot,
    df64:	69ab      	ldr	r3, [r5, #24]
    df66:	4298      	cmp	r0, r3
    df68:	bf94      	ite	ls
    df6a:	61a0      	strls	r0, [r4, #24]
    df6c:	61a3      	strhi	r3, [r4, #24]
    df6e:	e7d8      	b.n	df22 <ticker_job+0x23a>
				instance->sched_cb(TICKER_CALL_ID_JOB,
    df70:	2104      	movs	r1, #4
    df72:	4623      	mov	r3, r4
    df74:	6a65      	ldr	r5, [r4, #36]	; 0x24
    df76:	2201      	movs	r2, #1
    df78:	4608      	mov	r0, r1
    df7a:	47a8      	blx	r5
				pending = 1U;
    df7c:	2301      	movs	r3, #1
				user->middle = prev;
    df7e:	f887 8002 	strb.w	r8, [r7, #2]
				pending = 1U;
    df82:	9308      	str	r3, [sp, #32]
    df84:	e6dc      	b.n	dd40 <ticker_job+0x58>
		if (ticker->lazy_current != 0U) {
    df86:	8be8      	ldrh	r0, [r5, #30]
		ticks_elapsed -= ticks_to_expire;
    df88:	ebaa 0a02 	sub.w	sl, sl, r2
		ticks_expired += ticks_to_expire;
    df8c:	4490      	add	r8, r2
		if (ticker->lazy_current != 0U) {
    df8e:	2800      	cmp	r0, #0
    df90:	d032      	beq.n	dff8 <ticker_job+0x310>
			instance->ticker_id_slot_previous = TICKER_NULL;
    df92:	22ff      	movs	r2, #255	; 0xff
    df94:	7722      	strb	r2, [r4, #28]
			instance->ticks_slot_previous = 0U;
    df96:	2200      	movs	r2, #0
				instance->ticks_slot_previous =
    df98:	61a2      	str	r2, [r4, #24]
		ticker->ticks_to_expire = 0U;
    df9a:	f04f 0c00 	mov.w	ip, #0
    df9e:	f8c5 c008 	str.w	ip, [r5, #8]
		instance->ticker_id_head = ticker->next;
    dfa2:	f819 1007 	ldrb.w	r1, [r9, r7]
    dfa6:	7761      	strb	r1, [r4, #29]
		if (ticker->ticks_periodic != 0U) {
    dfa8:	686b      	ldr	r3, [r5, #4]
    dfaa:	2b00      	cmp	r3, #0
    dfac:	d032      	beq.n	e014 <ticker_job+0x32c>
	ticker->remainder_current += ticker->remainder_periodic;
    dfae:	e9d5 0108 	ldrd	r0, r1, [r5, #32]
    dfb2:	4401      	add	r1, r0
	if ((ticker->remainder_current < BIT(31)) &&
    dfb4:	48a3      	ldr	r0, [pc, #652]	; (e244 <ticker_job+0x55c>)
    dfb6:	4aa4      	ldr	r2, [pc, #656]	; (e248 <ticker_job+0x560>)
			ticker->ticks_to_expire  = ticker->ticks_periodic;
    dfb8:	60ab      	str	r3, [r5, #8]
	if ((ticker->remainder_current < BIT(31)) &&
    dfba:	1808      	adds	r0, r1, r0
    dfbc:	4290      	cmp	r0, r2
		return 1;
    dfbe:	bf95      	itete	ls
    dfc0:	9a01      	ldrls	r2, [sp, #4]
	ticker->remainder_current += ticker->remainder_periodic;
    dfc2:	6269      	strhi	r1, [r5, #36]	; 0x24
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    dfc4:	f1a1 71e8 	subls.w	r1, r1, #30408704	; 0x1d00000
	return 0;
    dfc8:	4662      	movhi	r2, ip
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    dfca:	bf98      	it	ls
    dfcc:	f5a1 31d4 	subls.w	r1, r1, #108544	; 0x1a800
			ticker->ticks_to_expire += ticker_remainder_inc(ticker);
    dfd0:	441a      	add	r2, r3
			ticks_to_expire_prep(ticker, instance->ticks_current,
    dfd2:	9b04      	ldr	r3, [sp, #16]
			ticker->ticks_to_expire += ticker_remainder_inc(ticker);
    dfd4:	60aa      	str	r2, [r5, #8]
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    dfd6:	bf9c      	itt	ls
    dfd8:	f5a1 71a5 	subls.w	r1, r1, #330	; 0x14a
    dfdc:	6269      	strls	r1, [r5, #36]	; 0x24
			ticks_to_expire_prep(ticker, instance->ticks_current,
    dfde:	eb03 0208 	add.w	r2, r3, r8
    dfe2:	6961      	ldr	r1, [r4, #20]
    dfe4:	4628      	mov	r0, r5
    dfe6:	f00e ffd0 	bl	1cf8a <ticks_to_expire_prep>
			ticker->next = *insert_head;
    dfea:	f809 b007 	strb.w	fp, [r9, r7]
			ticker->req++;
    dfee:	786a      	ldrb	r2, [r5, #1]
    dff0:	3201      	adds	r2, #1
    dff2:	706a      	strb	r2, [r5, #1]
			ticker->req = ticker->ack;
    dff4:	46b3      	mov	fp, r6
    dff6:	e6b5      	b.n	dd64 <ticker_job+0x7c>
			if (instance->ticks_slot_previous > ticks_to_expire) {
    dff8:	69a1      	ldr	r1, [r4, #24]
    dffa:	428a      	cmp	r2, r1
				instance->ticker_id_slot_previous = TICKER_NULL;
    dffc:	bf2b      	itete	cs
    dffe:	22ff      	movcs	r2, #255	; 0xff
				instance->ticks_slot_previous -=
    e000:	1a8a      	subcc	r2, r1, r2
				instance->ticker_id_slot_previous = TICKER_NULL;
    e002:	7722      	strbcs	r2, [r4, #28]
				instance->ticks_slot_previous -=
    e004:	61a2      	strcc	r2, [r4, #24]
			if (ticker->ticks_slot != 0U) {
    e006:	69aa      	ldr	r2, [r5, #24]
				instance->ticks_slot_previous = 0U;
    e008:	bf28      	it	cs
    e00a:	61a0      	strcs	r0, [r4, #24]
			if (ticker->ticks_slot != 0U) {
    e00c:	2a00      	cmp	r2, #0
    e00e:	d0c4      	beq.n	df9a <ticker_job+0x2b2>
				instance->ticker_id_slot_previous = id_expired;
    e010:	7726      	strb	r6, [r4, #28]
    e012:	e7c1      	b.n	df98 <ticker_job+0x2b0>
			ticker->req = ticker->ack;
    e014:	78aa      	ldrb	r2, [r5, #2]
    e016:	706a      	strb	r2, [r5, #1]
    e018:	465e      	mov	r6, fp
    e01a:	e7eb      	b.n	dff4 <ticker_job+0x30c>
		user = &users[count_user];
    e01c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    e01e:	9a01      	ldr	r2, [sp, #4]
    e020:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    e024:	9304      	str	r3, [sp, #16]
		user_ops = (void *)&user->user_op[0];
    e026:	685b      	ldr	r3, [r3, #4]
    e028:	9307      	str	r3, [sp, #28]
		user_ops_first = user->first;
    e02a:	9b04      	ldr	r3, [sp, #16]
    e02c:	785f      	ldrb	r7, [r3, #1]
		while ((insert_head != TICKER_NULL) ||
    e02e:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
    e032:	d05e      	beq.n	e0f2 <ticker_job+0x40a>
				ticker = &node[id_insert];
    e034:	fb1b f309 	smulbb	r3, fp, r9
    e038:	9a05      	ldr	r2, [sp, #20]
				insert_head = ticker->next;
    e03a:	46da      	mov	sl, fp
    e03c:	f812 b003 	ldrb.w	fp, [r2, r3]
				ticker = &node[id_insert];
    e040:	18d5      	adds	r5, r2, r3
				user_op = NULL;
    e042:	2600      	movs	r6, #0
	ticker->next = TICKER_NULL;
    e044:	22ff      	movs	r2, #255	; 0xff
    e046:	702a      	strb	r2, [r5, #0]
	node = &instance->nodes[0];
    e048:	6820      	ldr	r0, [r4, #0]
	previous = TICKER_NULL;
    e04a:	9206      	str	r2, [sp, #24]
	ticker_new = &node[id];
    e04c:	fb1a f309 	smulbb	r3, sl, r9
    e050:	eb00 0e03 	add.w	lr, r0, r3
    e054:	9309      	str	r3, [sp, #36]	; 0x24
	ticks_to_expire = ticker_new->ticks_to_expire;
    e056:	f8de 1008 	ldr.w	r1, [lr, #8]
	current = instance->ticker_id_head;
    e05a:	7f63      	ldrb	r3, [r4, #29]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
    e05c:	2bff      	cmp	r3, #255	; 0xff
    e05e:	d008      	beq.n	e072 <ticker_job+0x38a>
		(ticker_current = &node[current])->ticks_to_expire))) {
    e060:	fb13 f209 	smulbb	r2, r3, r9
    e064:	920a      	str	r2, [sp, #40]	; 0x28
    e066:	1882      	adds	r2, r0, r2
    e068:	4690      	mov	r8, r2
		(ticks_to_expire_current =
    e06a:	f8d2 c008 	ldr.w	ip, [r2, #8]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
    e06e:	4561      	cmp	r1, ip
    e070:	d26b      	bcs.n	e14a <ticker_job+0x462>
	ticker_new->next = current;
    e072:	9a09      	ldr	r2, [sp, #36]	; 0x24
	ticker_new->ticks_to_expire = ticks_to_expire;
    e074:	f8ce 1008 	str.w	r1, [lr, #8]
	ticker_new->next = current;
    e078:	5483      	strb	r3, [r0, r2]
	if (previous == TICKER_NULL) {
    e07a:	9a06      	ldr	r2, [sp, #24]
    e07c:	2aff      	cmp	r2, #255	; 0xff
		node[previous].next = id;
    e07e:	bf17      	itett	ne
    e080:	9a06      	ldrne	r2, [sp, #24]
		instance->ticker_id_head = id;
    e082:	f884 a01d 	strbeq.w	sl, [r4, #29]
		node[previous].next = id;
    e086:	fb12 f209 	smulbbne	r2, r2, r9
    e08a:	f800 a002 	strbne.w	sl, [r0, r2]
	if (current != TICKER_NULL) {
    e08e:	2bff      	cmp	r3, #255	; 0xff
		node[current].ticks_to_expire -= ticks_to_expire;
    e090:	bf1f      	itttt	ne
    e092:	fb03 0309 	mlane	r3, r3, r9, r0
    e096:	689a      	ldrne	r2, [r3, #8]
    e098:	1a51      	subne	r1, r2, r1
    e09a:	6099      	strne	r1, [r3, #8]
	ticker->req = ticker->ack + 1;
    e09c:	78ab      	ldrb	r3, [r5, #2]
    e09e:	3301      	adds	r3, #1
    e0a0:	706b      	strb	r3, [r5, #1]
			if (user_op) {
    e0a2:	2e00      	cmp	r6, #0
    e0a4:	d0c3      	beq.n	e02e <ticker_job+0x346>
				ticker_job_op_cb(user_op, status);
    e0a6:	2100      	movs	r1, #0
    e0a8:	4630      	mov	r0, r6
    e0aa:	f00e ff8c 	bl	1cfc6 <ticker_job_op_cb>
    e0ae:	e7be      	b.n	e02e <ticker_job+0x346>
				user_op = &user_ops[user_ops_first];
    e0b0:	eb07 0347 	add.w	r3, r7, r7, lsl #1
    e0b4:	9a07      	ldr	r2, [sp, #28]
    e0b6:	011b      	lsls	r3, r3, #4
    e0b8:	18d6      	adds	r6, r2, r3
				if (first == user->count_user_op) {
    e0ba:	9a04      	ldr	r2, [sp, #16]
				first = user_ops_first + 1;
    e0bc:	3701      	adds	r7, #1
				if (first == user->count_user_op) {
    e0be:	7812      	ldrb	r2, [r2, #0]
				first = user_ops_first + 1;
    e0c0:	b2ff      	uxtb	r7, r7
					first = 0U;
    e0c2:	42ba      	cmp	r2, r7
    e0c4:	bf08      	it	eq
    e0c6:	2700      	moveq	r7, #0
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
    e0c8:	9a07      	ldr	r2, [sp, #28]
    e0ca:	5cd3      	ldrb	r3, [r2, r3]
    e0cc:	2b04      	cmp	r3, #4
    e0ce:	d110      	bne.n	e0f2 <ticker_job+0x40a>
				ticker = &node[id_insert];
    e0d0:	9b05      	ldr	r3, [sp, #20]
				id_insert = user_op->id;
    e0d2:	f896 a001 	ldrb.w	sl, [r6, #1]
				ticker = &node[id_insert];
    e0d6:	fb0a 3509 	mla	r5, sl, r9, r3
				if (((ticker->req -
    e0da:	f895 8001 	ldrb.w	r8, [r5, #1]
				      ticker->ack) & 0xff) != 0U) {
    e0de:	78ab      	ldrb	r3, [r5, #2]
				if (((ticker->req -
    e0e0:	eba8 0803 	sub.w	r8, r8, r3
    e0e4:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
    e0e8:	d008      	beq.n	e0fc <ticker_job+0x414>
					ticker_job_op_cb(user_op,
    e0ea:	2101      	movs	r1, #1
    e0ec:	4630      	mov	r0, r6
    e0ee:	f00e ff6a 	bl	1cfc6 <ticker_job_op_cb>
		while ((insert_head != TICKER_NULL) ||
    e0f2:	9b04      	ldr	r3, [sp, #16]
    e0f4:	789b      	ldrb	r3, [r3, #2]
    e0f6:	42bb      	cmp	r3, r7
    e0f8:	d1da      	bne.n	e0b0 <ticker_job+0x3c8>
    e0fa:	e651      	b.n	dda0 <ticker_job+0xb8>
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
    e0fc:	8ab3      	ldrh	r3, [r6, #20]
				ticker_job_op_start(ticker, user_op,
    e0fe:	6961      	ldr	r1, [r4, #20]
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
    e100:	f64f 72ff 	movw	r2, #65535	; 0xffff
    e104:	4293      	cmp	r3, r2
    e106:	bf0c      	ite	eq
    e108:	2201      	moveq	r2, #1
    e10a:	2200      	movne	r2, #0
    e10c:	f885 2028 	strb.w	r2, [r5, #40]	; 0x28
	ticker->ticks_periodic = start->ticks_periodic;
    e110:	68f2      	ldr	r2, [r6, #12]
    e112:	606a      	str	r2, [r5, #4]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
    e114:	bf08      	it	eq
    e116:	2300      	moveq	r3, #0
	ticker->remainder_periodic = start->remainder_periodic;
    e118:	6932      	ldr	r2, [r6, #16]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
    e11a:	83ab      	strh	r3, [r5, #28]
	ticker->ticks_slot = start->ticks_slot;
    e11c:	69b3      	ldr	r3, [r6, #24]
    e11e:	61ab      	str	r3, [r5, #24]
	ticker->timeout_func = start->fp_timeout_func;
    e120:	69f3      	ldr	r3, [r6, #28]
    e122:	60eb      	str	r3, [r5, #12]
	ticker->context = start->context;
    e124:	6a33      	ldr	r3, [r6, #32]
    e126:	612b      	str	r3, [r5, #16]
	ticker->ticks_to_expire = start->ticks_first;
    e128:	68b3      	ldr	r3, [r6, #8]
	ticker->remainder_periodic = start->remainder_periodic;
    e12a:	622a      	str	r2, [r5, #32]
	ticker->ticks_to_expire = start->ticks_first;
    e12c:	60ab      	str	r3, [r5, #8]
	ticker->ticks_to_expire_minus = 0U;
    e12e:	f8c5 8014 	str.w	r8, [r5, #20]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
    e132:	6872      	ldr	r2, [r6, #4]
    e134:	4628      	mov	r0, r5
    e136:	f00e ff28 	bl	1cf8a <ticks_to_expire_prep>
	ticker->force = 1U;
    e13a:	f04f 0301 	mov.w	r3, #1
	ticker->remainder_current = 0U;
    e13e:	f8c5 8024 	str.w	r8, [r5, #36]	; 0x24
	ticker->lazy_current = 0U;
    e142:	f8a5 801e 	strh.w	r8, [r5, #30]
	ticker->force = 1U;
    e146:	70eb      	strb	r3, [r5, #3]
    e148:	e77c      	b.n	e044 <ticker_job+0x35c>
		if (ticks_to_expire == 0 && (ticker_new->lazy_current >
    e14a:	ebb1 010c 	subs.w	r1, r1, ip
    e14e:	d10a      	bne.n	e166 <ticker_job+0x47e>
    e150:	f8be 201e 	ldrh.w	r2, [lr, #30]
    e154:	920c      	str	r2, [sp, #48]	; 0x30
    e156:	f8b8 201e 	ldrh.w	r2, [r8, #30]
    e15a:	920d      	str	r2, [sp, #52]	; 0x34
    e15c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    e15e:	4690      	mov	r8, r2
    e160:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    e162:	4590      	cmp	r8, r2
    e164:	d803      	bhi.n	e16e <ticker_job+0x486>
		current = ticker_current->next;
    e166:	9306      	str	r3, [sp, #24]
    e168:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    e16a:	5cc3      	ldrb	r3, [r0, r3]
    e16c:	e776      	b.n	e05c <ticker_job+0x374>
		(ticks_to_expire_current =
    e16e:	4661      	mov	r1, ip
    e170:	e77f      	b.n	e072 <ticker_job+0x38a>
	users = &instance->users[0];
    e172:	6863      	ldr	r3, [r4, #4]
	count_user = instance->count_user;
    e174:	7a65      	ldrb	r5, [r4, #9]
	users = &instance->users[0];
    e176:	9301      	str	r3, [sp, #4]
	       ((ticker = &node[_ticker_id_head])->ticks_slot == 0U)) {
    e178:	272c      	movs	r7, #44	; 0x2c
	while (count_user--) {
    e17a:	3d01      	subs	r5, #1
    e17c:	b2ed      	uxtb	r5, r5
    e17e:	2dff      	cmp	r5, #255	; 0xff
    e180:	f43f ae20 	beq.w	ddc4 <ticker_job+0xdc>
		user = &users[count_user];
    e184:	9b01      	ldr	r3, [sp, #4]
    e186:	eb03 06c5 	add.w	r6, r3, r5, lsl #3
		user_op = &user->user_op[0];
    e18a:	f8d6 8004 	ldr.w	r8, [r6, #4]
		while (user->first != user->last) {
    e18e:	7873      	ldrb	r3, [r6, #1]
    e190:	78f2      	ldrb	r2, [r6, #3]
    e192:	429a      	cmp	r2, r3
    e194:	d0f1      	beq.n	e17a <ticker_job+0x492>
			ticker_job_op_inquire(instance, &user_op[user->first]);
    e196:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    e19a:	011a      	lsls	r2, r3, #4
    e19c:	eb08 0302 	add.w	r3, r8, r2
	switch (uop->op) {
    e1a0:	f818 2002 	ldrb.w	r2, [r8, r2]
    e1a4:	2a02      	cmp	r2, #2
    e1a6:	d013      	beq.n	e1d0 <ticker_job+0x4e8>
    e1a8:	2a03      	cmp	r2, #3
    e1aa:	d03e      	beq.n	e22a <ticker_job+0x542>
    e1ac:	2a01      	cmp	r2, #1
    e1ae:	d106      	bne.n	e1be <ticker_job+0x4d6>
			uop->status = TICKER_STATUS_SUCCESS;
    e1b0:	2200      	movs	r2, #0
			uop->status = TICKER_STATUS_FAILURE;
    e1b2:	625a      	str	r2, [r3, #36]	; 0x24
		fp_op_func = uop->fp_op_func;
    e1b4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if (fp_op_func) {
    e1b6:	b112      	cbz	r2, e1be <ticker_job+0x4d6>
		fp_op_func(uop->status, uop->op_context);
    e1b8:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
    e1ba:	6a58      	ldr	r0, [r3, #36]	; 0x24
    e1bc:	4790      	blx	r2
			first = user->first + 1;
    e1be:	7873      	ldrb	r3, [r6, #1]
			if (first == user->count_user_op) {
    e1c0:	7832      	ldrb	r2, [r6, #0]
			first = user->first + 1;
    e1c2:	3301      	adds	r3, #1
    e1c4:	b2db      	uxtb	r3, r3
				first = 0U;
    e1c6:	429a      	cmp	r2, r3
    e1c8:	bf08      	it	eq
    e1ca:	2300      	moveq	r3, #0
			user->first = first;
    e1cc:	7073      	strb	r3, [r6, #1]
    e1ce:	e7de      	b.n	e18e <ticker_job+0x4a6>
		ticker_by_next_slot_get(instance,
    e1d0:	e9d3 9001 	ldrd	r9, r0, [r3, #4]
	_ticker_id_head = *ticker_id_head;
    e1d4:	f899 a000 	ldrb.w	sl, [r9]
		ticker_by_next_slot_get(instance,
    e1d8:	f8d3 e00c 	ldr.w	lr, [r3, #12]
	node = instance->nodes;
    e1dc:	f8d4 c000 	ldr.w	ip, [r4]
	if ((_ticker_id_head == TICKER_NULL) ||
    e1e0:	6961      	ldr	r1, [r4, #20]
    e1e2:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
    e1e6:	d002      	beq.n	e1ee <ticker_job+0x506>
    e1e8:	6802      	ldr	r2, [r0, #0]
    e1ea:	428a      	cmp	r2, r1
    e1ec:	d013      	beq.n	e216 <ticker_job+0x52e>
		_ticker_id_head = instance->ticker_id_head;
    e1ee:	7f62      	ldrb	r2, [r4, #29]
		*ticks_current = instance->ticks_current;
    e1f0:	6001      	str	r1, [r0, #0]
		_ticks_to_expire = 0U;
    e1f2:	2100      	movs	r1, #0
	while ((_ticker_id_head != TICKER_NULL) &&
    e1f4:	2aff      	cmp	r2, #255	; 0xff
    e1f6:	d009      	beq.n	e20c <ticker_job+0x524>
	       ((ticker = &node[_ticker_id_head])->ticks_slot == 0U)) {
    e1f8:	fb12 fb07 	smulbb	fp, r2, r7
    e1fc:	eb0c 0a0b 	add.w	sl, ip, fp
    e200:	f8da 0008 	ldr.w	r0, [sl, #8]
    e204:	4401      	add	r1, r0
	while ((_ticker_id_head != TICKER_NULL) &&
    e206:	f8da 0018 	ldr.w	r0, [sl, #24]
    e20a:	b158      	cbz	r0, e224 <ticker_job+0x53c>
	*ticker_id_head = _ticker_id_head;
    e20c:	f889 2000 	strb.w	r2, [r9]
	*ticks_to_expire = _ticks_to_expire;
    e210:	f8ce 1000 	str.w	r1, [lr]
		uop->status = TICKER_STATUS_SUCCESS;
    e214:	e7cc      	b.n	e1b0 <ticker_job+0x4c8>
		ticker = &node[_ticker_id_head];
    e216:	fb1a f207 	smulbb	r2, sl, r7
	_ticks_to_expire = *ticks_to_expire;
    e21a:	f8de 1000 	ldr.w	r1, [lr]
		_ticker_id_head = ticker->next;
    e21e:	f81c 2002 	ldrb.w	r2, [ip, r2]
    e222:	e7e7      	b.n	e1f4 <ticker_job+0x50c>
		_ticker_id_head = ticker->next;
    e224:	f81c 200b 	ldrb.w	r2, [ip, fp]
    e228:	e7e4      	b.n	e1f4 <ticker_job+0x50c>
		if (uop->id < instance->count_node) {
    e22a:	7859      	ldrb	r1, [r3, #1]
    e22c:	7a22      	ldrb	r2, [r4, #8]
    e22e:	428a      	cmp	r2, r1
    e230:	d906      	bls.n	e240 <ticker_job+0x558>
			node[uop->id].priority =
    e232:	6822      	ldr	r2, [r4, #0]
    e234:	fb01 2207 	mla	r2, r1, r7, r2
    e238:	7919      	ldrb	r1, [r3, #4]
    e23a:	f882 1029 	strb.w	r1, [r2, #41]	; 0x29
    e23e:	e7b7      	b.n	e1b0 <ticker_job+0x4c8>
			uop->status = TICKER_STATUS_FAILURE;
    e240:	2201      	movs	r2, #1
    e242:	e7b6      	b.n	e1b2 <ticker_job+0x4ca>
    e244:	ff172b5a 	.word	0xff172b5a
    e248:	7f172b59 	.word	0x7f172b59
	if (ticker_id_old_head == TICKER_NULL) {
    e24c:	9b03      	ldr	r3, [sp, #12]
    e24e:	2bff      	cmp	r3, #255	; 0xff
    e250:	d106      	bne.n	e260 <ticker_job+0x578>
		ticks_current = cntr_cnt_get();
    e252:	f007 fbbb 	bl	159cc <cntr_cnt_get>
    e256:	4605      	mov	r5, r0
		if (cntr_start() == 0) {
    e258:	f007 fb84 	bl	15964 <cntr_start>
    e25c:	b900      	cbnz	r0, e260 <ticker_job+0x578>
			instance->ticks_current = ticks_current;
    e25e:	6165      	str	r5, [r4, #20]
	ticker = &instance->nodes[instance->ticker_id_head];
    e260:	7f61      	ldrb	r1, [r4, #29]
	ticks_to_expire = ticker->ticks_to_expire;
    e262:	6822      	ldr	r2, [r4, #0]
		LL_ASSERT(i);
    e264:	f8df 80b0 	ldr.w	r8, [pc, #176]	; e318 <ticker_job+0x630>
    e268:	f8df 90b0 	ldr.w	r9, [pc, #176]	; e31c <ticker_job+0x634>
    e26c:	f8df a0b0 	ldr.w	sl, [pc, #176]	; e320 <ticker_job+0x638>
	ticks_to_expire = ticker->ticks_to_expire;
    e270:	232c      	movs	r3, #44	; 0x2c
    e272:	fb01 2303 	mla	r3, r1, r3, r2
	i = 10U;
    e276:	260a      	movs	r6, #10
	ticks_to_expire = ticker->ticks_to_expire;
    e278:	689f      	ldr	r7, [r3, #8]
		ctr = cntr_cnt_get();
    e27a:	f007 fba7 	bl	159cc <cntr_cnt_get>
		cc = instance->ticks_current;
    e27e:	6965      	ldr	r5, [r4, #20]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    e280:	1b43      	subs	r3, r0, r5
    e282:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		ticks_elapsed = ticker_ticks_diff_get(ctr, cc) +
    e286:	3303      	adds	r3, #3
		cc += MAX(ticks_elapsed, ticks_to_expire);
    e288:	42bb      	cmp	r3, r7
    e28a:	bf2c      	ite	cs
    e28c:	18ed      	addcs	r5, r5, r3
    e28e:	19ed      	addcc	r5, r5, r7
		cc &= HAL_TICKER_CNTR_MASK;
    e290:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		ctr = cntr_cnt_get();
    e294:	4683      	mov	fp, r0
		instance->trigger_set_cb(cc);
    e296:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    e298:	4628      	mov	r0, r5
    e29a:	4798      	blx	r3
		ctr_post = cntr_cnt_get();
    e29c:	f007 fb96 	bl	159cc <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    e2a0:	eba0 000b 	sub.w	r0, r0, fp
    e2a4:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    e2a8:	eba5 050b 	sub.w	r5, r5, fp
	} while ((ticker_ticks_diff_get(ctr_post, ctr) +
    e2ac:	3003      	adds	r0, #3
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    e2ae:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		  ticker_ticks_diff_get(cc, ctr));
    e2b2:	42a8      	cmp	r0, r5
		i--;
    e2b4:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
		  ticker_ticks_diff_get(cc, ctr));
    e2b8:	f67f ad90 	bls.w	dddc <ticker_job+0xf4>
		LL_ASSERT(i);
    e2bc:	2e00      	cmp	r6, #0
    e2be:	d1dc      	bne.n	e27a <ticker_job+0x592>
    e2c0:	f240 63f4 	movw	r3, #1780	; 0x6f4
    e2c4:	4642      	mov	r2, r8
    e2c6:	4649      	mov	r1, r9
    e2c8:	4650      	mov	r0, sl
    e2ca:	f00b f853 	bl	19374 <printk>
    e2ce:	4040      	eors	r0, r0
    e2d0:	f380 8811 	msr	BASEPRI, r0
    e2d4:	f04f 0003 	mov.w	r0, #3
    e2d8:	df02      	svc	2
    e2da:	e7ce      	b.n	e27a <ticker_job+0x592>
	if (previous == current) {
    e2dc:	4573      	cmp	r3, lr
    e2de:	d101      	bne.n	e2e4 <ticker_job+0x5fc>
		instance->ticker_id_head = ticker_current->next;
    e2e0:	f884 901d 	strb.w	r9, [r4, #29]
	node[previous].next = ticker_current->next;
    e2e4:	202c      	movs	r0, #44	; 0x2c
    e2e6:	fb1e fe00 	smulbb	lr, lr, r0
	if (ticker_current->next != TICKER_NULL) {
    e2ea:	9809      	ldr	r0, [sp, #36]	; 0x24
	node[previous].next = ticker_current->next;
    e2ec:	f801 900e 	strb.w	r9, [r1, lr]
	if (ticker_current->next != TICKER_NULL) {
    e2f0:	f890 c000 	ldrb.w	ip, [r0]
    e2f4:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
    e2f8:	f43f add0 	beq.w	de9c <ticker_job+0x1b4>
		node[ticker_current->next].ticks_to_expire += timeout;
    e2fc:	202c      	movs	r0, #44	; 0x2c
    e2fe:	fb0c 1c00 	mla	ip, ip, r0, r1
    e302:	980a      	ldr	r0, [sp, #40]	; 0x28
    e304:	f8dc 1008 	ldr.w	r1, [ip, #8]
    e308:	4401      	add	r1, r0
    e30a:	f8cc 1008 	str.w	r1, [ip, #8]
	return (total + timeout);
    e30e:	e5c5      	b.n	de9c <ticker_job+0x1b4>
}
    e310:	b00f      	add	sp, #60	; 0x3c
    e312:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e316:	bf00      	nop
    e318:	000218d8 	.word	0x000218d8
    e31c:	00021aca 	.word	0x00021aca
    e320:	00020aa4 	.word	0x00020aa4

0000e324 <ticker_init>:
{
    e324:	b5f0      	push	{r4, r5, r6, r7, lr}
    e326:	9e05      	ldr	r6, [sp, #20]
    e328:	f89d 5018 	ldrb.w	r5, [sp, #24]
    e32c:	9f07      	ldr	r7, [sp, #28]
	if (instance_index >= TICKER_INSTANCE_MAX) {
    e32e:	b108      	cbz	r0, e334 <ticker_init+0x10>
		return TICKER_STATUS_FAILURE;
    e330:	2001      	movs	r0, #1
}
    e332:	bdf0      	pop	{r4, r5, r6, r7, pc}
	instance->count_node = count_node;
    e334:	4c18      	ldr	r4, [pc, #96]	; (e398 <ticker_init+0x74>)
		instance->nodes[count_node].priority = 0;
    e336:	f04f 0c2c 	mov.w	ip, #44	; 0x2c
	instance->count_node = count_node;
    e33a:	7221      	strb	r1, [r4, #8]
	instance->nodes = node;
    e33c:	6022      	str	r2, [r4, #0]
	while (count_node--) {
    e33e:	3901      	subs	r1, #1
    e340:	b2c9      	uxtb	r1, r1
    e342:	29ff      	cmp	r1, #255	; 0xff
    e344:	d115      	bne.n	e372 <ticker_init+0x4e>
	instance->count_user = count_user;
    e346:	7263      	strb	r3, [r4, #9]
	instance->users = user;
    e348:	6066      	str	r6, [r4, #4]
	while (count_user--) {
    e34a:	3b01      	subs	r3, #1
    e34c:	b2db      	uxtb	r3, r3
    e34e:	2bff      	cmp	r3, #255	; 0xff
    e350:	d114      	bne.n	e37c <ticker_init+0x58>
	if (count_op) {
    e352:	2d00      	cmp	r5, #0
    e354:	d1ec      	bne.n	e330 <ticker_init+0xc>
	instance->caller_id_get_cb = caller_id_get_cb;
    e356:	9b08      	ldr	r3, [sp, #32]
    e358:	6223      	str	r3, [r4, #32]
	instance->sched_cb = sched_cb;
    e35a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    e35c:	6263      	str	r3, [r4, #36]	; 0x24
	instance->trigger_set_cb = trigger_set_cb;
    e35e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    e360:	62a3      	str	r3, [r4, #40]	; 0x28
	instance->ticker_id_slot_previous = TICKER_NULL;
    e362:	f64f 73ff 	movw	r3, #65535	; 0xffff
	instance->ticks_slot_previous = 0U;
    e366:	e9c4 5505 	strd	r5, r5, [r4, #20]
	instance->ticker_id_slot_previous = TICKER_NULL;
    e36a:	83a3      	strh	r3, [r4, #28]
	instance->ticks_elapsed_first = 0U;
    e36c:	8165      	strh	r5, [r4, #10]
	return TICKER_STATUS_SUCCESS;
    e36e:	4628      	mov	r0, r5
    e370:	e7df      	b.n	e332 <ticker_init+0xe>
		instance->nodes[count_node].priority = 0;
    e372:	fb01 2e0c 	mla	lr, r1, ip, r2
    e376:	f88e 0029 	strb.w	r0, [lr, #41]	; 0x29
    e37a:	e7e0      	b.n	e33e <ticker_init+0x1a>
		users[count_user].user_op = user_op_;
    e37c:	b21a      	sxth	r2, r3
    e37e:	eb06 01c2 	add.w	r1, r6, r2, lsl #3
    e382:	604f      	str	r7, [r1, #4]
		user_op_ += users[count_user].count_user_op;
    e384:	f816 0032 	ldrb.w	r0, [r6, r2, lsl #3]
    e388:	eb00 0240 	add.w	r2, r0, r0, lsl #1
		count_op -= users[count_user].count_user_op;
    e38c:	1a28      	subs	r0, r5, r0
		user_op_ += users[count_user].count_user_op;
    e38e:	eb07 1702 	add.w	r7, r7, r2, lsl #4
		count_op -= users[count_user].count_user_op;
    e392:	b2c5      	uxtb	r5, r0
    e394:	e7d9      	b.n	e34a <ticker_init+0x26>
    e396:	bf00      	nop
    e398:	20000840 	.word	0x20000840

0000e39c <ticker_is_initialized>:
	return !!(_instance[instance_index].count_node);
    e39c:	4a04      	ldr	r2, [pc, #16]	; (e3b0 <ticker_is_initialized+0x14>)
    e39e:	232c      	movs	r3, #44	; 0x2c
    e3a0:	fb03 2000 	mla	r0, r3, r0, r2
    e3a4:	7a00      	ldrb	r0, [r0, #8]
}
    e3a6:	3000      	adds	r0, #0
    e3a8:	bf18      	it	ne
    e3aa:	2001      	movne	r0, #1
    e3ac:	4770      	bx	lr
    e3ae:	bf00      	nop
    e3b0:	20000840 	.word	0x20000840

0000e3b4 <ticker_trigger>:
	if (instance->sched_cb) {
    e3b4:	4a07      	ldr	r2, [pc, #28]	; (e3d4 <ticker_trigger+0x20>)
    e3b6:	232c      	movs	r3, #44	; 0x2c
    e3b8:	fb03 2100 	mla	r1, r3, r0, r2
{
    e3bc:	b410      	push	{r4}
	if (instance->sched_cb) {
    e3be:	6a4c      	ldr	r4, [r1, #36]	; 0x24
    e3c0:	b134      	cbz	r4, e3d0 <ticker_trigger+0x1c>
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
    e3c2:	460b      	mov	r3, r1
    e3c4:	46a4      	mov	ip, r4
    e3c6:	2201      	movs	r2, #1
    e3c8:	2103      	movs	r1, #3
    e3ca:	2002      	movs	r0, #2
}
    e3cc:	bc10      	pop	{r4}
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
    e3ce:	4760      	bx	ip
}
    e3d0:	bc10      	pop	{r4}
    e3d2:	4770      	bx	lr
    e3d4:	20000840 	.word	0x20000840

0000e3d8 <ticker_start>:
{
    e3d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct ticker_instance *instance = &_instance[instance_index];
    e3dc:	4c22      	ldr	r4, [pc, #136]	; (e468 <ticker_start+0x90>)
    e3de:	272c      	movs	r7, #44	; 0x2c
    e3e0:	fb00 4907 	mla	r9, r0, r7, r4
	user = &instance->users[user_id];
    e3e4:	b20d      	sxth	r5, r1
    e3e6:	f8d9 0004 	ldr.w	r0, [r9, #4]
    e3ea:	eb00 0cc5 	add.w	ip, r0, r5, lsl #3
	if (last >= user->count_user_op) {
    e3ee:	f810 0035 	ldrb.w	r0, [r0, r5, lsl #3]
	last = user->last + 1;
    e3f2:	f89c 4003 	ldrb.w	r4, [ip, #3]
    e3f6:	1c66      	adds	r6, r4, #1
    e3f8:	b2f6      	uxtb	r6, r6
		last = 0U;
    e3fa:	42b0      	cmp	r0, r6
    e3fc:	bf98      	it	ls
    e3fe:	2600      	movls	r6, #0
	if (last == user->first) {
    e400:	f89c 0001 	ldrb.w	r0, [ip, #1]
    e404:	42b0      	cmp	r0, r6
    e406:	d02d      	beq.n	e464 <ticker_start+0x8c>
	user_op = &user->user_op[user->last];
    e408:	f8dc 0004 	ldr.w	r0, [ip, #4]
    e40c:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    e410:	0125      	lsls	r5, r4, #4
    e412:	1944      	adds	r4, r0, r5
	user_op->op = TICKER_USER_OP_TYPE_START;
    e414:	f04f 0804 	mov.w	r8, #4
    e418:	f800 8005 	strb.w	r8, [r0, r5]
	user_op->params.start.ticks_at_start = ticks_anchor;
    e41c:	6063      	str	r3, [r4, #4]
	user_op->params.start.ticks_first = ticks_first;
    e41e:	9b08      	ldr	r3, [sp, #32]
    e420:	60a3      	str	r3, [r4, #8]
	user_op->params.start.ticks_periodic = ticks_periodic;
    e422:	9b09      	ldr	r3, [sp, #36]	; 0x24
    e424:	60e3      	str	r3, [r4, #12]
	user_op->params.start.remainder_periodic = remainder_periodic;
    e426:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    e428:	6123      	str	r3, [r4, #16]
	user_op->params.start.ticks_slot = ticks_slot;
    e42a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    e42c:	61a3      	str	r3, [r4, #24]
	user_op->params.start.lazy = lazy;
    e42e:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
    e432:	82a3      	strh	r3, [r4, #20]
	user_op->params.start.fp_timeout_func = fp_timeout_func;
    e434:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    e436:	61e3      	str	r3, [r4, #28]
	user_op->params.start.context = context;
    e438:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    e43a:	6223      	str	r3, [r4, #32]
	user_op->status = TICKER_STATUS_BUSY;
    e43c:	2302      	movs	r3, #2
    e43e:	6263      	str	r3, [r4, #36]	; 0x24
	user_op->fp_op_func = fp_op_func;
    e440:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    e442:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->op_context = op_context;
    e444:	9b10      	ldr	r3, [sp, #64]	; 0x40
	user_op->id = ticker_id;
    e446:	7062      	strb	r2, [r4, #1]
	user_op->op_context = op_context;
    e448:	62e3      	str	r3, [r4, #44]	; 0x2c
	user->last = last;
    e44a:	f88c 6003 	strb.w	r6, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    e44e:	e9d9 3508 	ldrd	r3, r5, [r9, #32]
    e452:	4608      	mov	r0, r1
    e454:	4798      	blx	r3
    e456:	464b      	mov	r3, r9
    e458:	2200      	movs	r2, #0
    e45a:	4641      	mov	r1, r8
    e45c:	47a8      	blx	r5
	return user_op->status;
    e45e:	6a60      	ldr	r0, [r4, #36]	; 0x24
}
    e460:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return TICKER_STATUS_FAILURE;
    e464:	2001      	movs	r0, #1
    e466:	e7fb      	b.n	e460 <ticker_start+0x88>
    e468:	20000840 	.word	0x20000840

0000e46c <ticker_update>:
{
    e46c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct ticker_instance *instance = &_instance[instance_index];
    e470:	4c21      	ldr	r4, [pc, #132]	; (e4f8 <ticker_update+0x8c>)
    e472:	272c      	movs	r7, #44	; 0x2c
    e474:	fb00 4807 	mla	r8, r0, r7, r4
	user = &instance->users[user_id];
    e478:	b20d      	sxth	r5, r1
    e47a:	f8d8 0004 	ldr.w	r0, [r8, #4]
    e47e:	eb00 0cc5 	add.w	ip, r0, r5, lsl #3
	if (last >= user->count_user_op) {
    e482:	f810 0035 	ldrb.w	r0, [r0, r5, lsl #3]
	last = user->last + 1;
    e486:	f89c 4003 	ldrb.w	r4, [ip, #3]
    e48a:	1c66      	adds	r6, r4, #1
    e48c:	b2f6      	uxtb	r6, r6
		last = 0U;
    e48e:	42b0      	cmp	r0, r6
    e490:	bf98      	it	ls
    e492:	2600      	movls	r6, #0
	if (last == user->first) {
    e494:	f89c 0001 	ldrb.w	r0, [ip, #1]
    e498:	42b0      	cmp	r0, r6
    e49a:	d02a      	beq.n	e4f2 <ticker_update+0x86>
	user_op = &user->user_op[user->last];
    e49c:	f8dc 0004 	ldr.w	r0, [ip, #4]
    e4a0:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    e4a4:	0125      	lsls	r5, r4, #4
    e4a6:	1944      	adds	r4, r0, r5
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
    e4a8:	f04f 0e05 	mov.w	lr, #5
    e4ac:	f800 e005 	strb.w	lr, [r0, r5]
	user_op->params.update.ticks_drift_plus = ticks_drift_plus;
    e4b0:	6063      	str	r3, [r4, #4]
	user_op->params.update.ticks_drift_minus = ticks_drift_minus;
    e4b2:	9b06      	ldr	r3, [sp, #24]
    e4b4:	60a3      	str	r3, [r4, #8]
	user_op->params.update.ticks_slot_plus = ticks_slot_plus;
    e4b6:	9b07      	ldr	r3, [sp, #28]
    e4b8:	60e3      	str	r3, [r4, #12]
	user_op->params.update.ticks_slot_minus = ticks_slot_minus;
    e4ba:	9b08      	ldr	r3, [sp, #32]
    e4bc:	6123      	str	r3, [r4, #16]
	user_op->params.update.lazy = lazy;
    e4be:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    e4c2:	82a3      	strh	r3, [r4, #20]
	user_op->params.update.force = force;
    e4c4:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
    e4c8:	75a3      	strb	r3, [r4, #22]
	user_op->status = TICKER_STATUS_BUSY;
    e4ca:	2302      	movs	r3, #2
    e4cc:	6263      	str	r3, [r4, #36]	; 0x24
	user_op->fp_op_func = fp_op_func;
    e4ce:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    e4d0:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->op_context = op_context;
    e4d2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	user_op->id = ticker_id;
    e4d4:	7062      	strb	r2, [r4, #1]
	user_op->op_context = op_context;
    e4d6:	62e3      	str	r3, [r4, #44]	; 0x2c
	user->last = last;
    e4d8:	f88c 6003 	strb.w	r6, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    e4dc:	e9d8 3508 	ldrd	r3, r5, [r8, #32]
    e4e0:	4608      	mov	r0, r1
    e4e2:	4798      	blx	r3
    e4e4:	4643      	mov	r3, r8
    e4e6:	2200      	movs	r2, #0
    e4e8:	2104      	movs	r1, #4
    e4ea:	47a8      	blx	r5
	return user_op->status;
    e4ec:	6a60      	ldr	r0, [r4, #36]	; 0x24
}
    e4ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
    e4f2:	2001      	movs	r0, #1
    e4f4:	e7fb      	b.n	e4ee <ticker_update+0x82>
    e4f6:	bf00      	nop
    e4f8:	20000840 	.word	0x20000840

0000e4fc <ticker_stop>:
{
    e4fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct ticker_instance *instance = &_instance[instance_index];
    e500:	4c1a      	ldr	r4, [pc, #104]	; (e56c <ticker_stop+0x70>)
    e502:	262c      	movs	r6, #44	; 0x2c
    e504:	fb00 4806 	mla	r8, r0, r6, r4
	user = &instance->users[user_id];
    e508:	b20f      	sxth	r7, r1
    e50a:	f8d8 0004 	ldr.w	r0, [r8, #4]
    e50e:	eb00 0cc7 	add.w	ip, r0, r7, lsl #3
	if (last >= user->count_user_op) {
    e512:	f810 0037 	ldrb.w	r0, [r0, r7, lsl #3]
	last = user->last + 1;
    e516:	f89c 4003 	ldrb.w	r4, [ip, #3]
    e51a:	1c65      	adds	r5, r4, #1
    e51c:	b2ed      	uxtb	r5, r5
		last = 0U;
    e51e:	42a8      	cmp	r0, r5
    e520:	bf98      	it	ls
    e522:	2500      	movls	r5, #0
	if (last == user->first) {
    e524:	f89c 0001 	ldrb.w	r0, [ip, #1]
    e528:	42a8      	cmp	r0, r5
    e52a:	d01c      	beq.n	e566 <ticker_stop+0x6a>
	user_op = &user->user_op[user->last];
    e52c:	f8dc 0004 	ldr.w	r0, [ip, #4]
    e530:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    e534:	0124      	lsls	r4, r4, #4
    e536:	1907      	adds	r7, r0, r4
	user_op->op = TICKER_USER_OP_TYPE_STOP;
    e538:	f04f 0e06 	mov.w	lr, #6
    e53c:	f800 e004 	strb.w	lr, [r0, r4]
	user_op->id = ticker_id;
    e540:	707a      	strb	r2, [r7, #1]
	user_op->status = TICKER_STATUS_BUSY;
    e542:	2202      	movs	r2, #2
	user_op->fp_op_func = fp_op_func;
    e544:	e9c7 2309 	strd	r2, r3, [r7, #36]	; 0x24
	user_op->op_context = op_context;
    e548:	9b06      	ldr	r3, [sp, #24]
    e54a:	62fb      	str	r3, [r7, #44]	; 0x2c
	user->last = last;
    e54c:	f88c 5003 	strb.w	r5, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    e550:	e9d8 3408 	ldrd	r3, r4, [r8, #32]
    e554:	4608      	mov	r0, r1
    e556:	4798      	blx	r3
    e558:	4643      	mov	r3, r8
    e55a:	2200      	movs	r2, #0
    e55c:	2104      	movs	r1, #4
    e55e:	47a0      	blx	r4
	return user_op->status;
    e560:	6a78      	ldr	r0, [r7, #36]	; 0x24
}
    e562:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
    e566:	2001      	movs	r0, #1
    e568:	e7fb      	b.n	e562 <ticker_stop+0x66>
    e56a:	bf00      	nop
    e56c:	20000840 	.word	0x20000840

0000e570 <ll_addr_get>:

static u8_t pub_addr[BDADDR_SIZE];
static u8_t rnd_addr[BDADDR_SIZE];

u8_t *ll_addr_get(u8_t addr_type, u8_t *bdaddr)
{
    e570:	b508      	push	{r3, lr}
    e572:	4603      	mov	r3, r0
	if (addr_type > 1) {
    e574:	2b01      	cmp	r3, #1
{
    e576:	4608      	mov	r0, r1
	if (addr_type > 1) {
    e578:	d80e      	bhi.n	e598 <ll_addr_get+0x28>
		return NULL;
	}

	if (addr_type) {
    e57a:	b133      	cbz	r3, e58a <ll_addr_get+0x1a>
		if (bdaddr) {
    e57c:	b119      	cbz	r1, e586 <ll_addr_get+0x16>
			memcpy(bdaddr, rnd_addr, BDADDR_SIZE);
    e57e:	2206      	movs	r2, #6
    e580:	4906      	ldr	r1, [pc, #24]	; (e59c <ll_addr_get+0x2c>)
    e582:	f00c fd3a 	bl	1affa <memcpy>
		}

		return rnd_addr;
    e586:	4805      	ldr	r0, [pc, #20]	; (e59c <ll_addr_get+0x2c>)
    e588:	e007      	b.n	e59a <ll_addr_get+0x2a>
	}

	if (bdaddr) {
    e58a:	b119      	cbz	r1, e594 <ll_addr_get+0x24>
		memcpy(bdaddr, pub_addr, BDADDR_SIZE);
    e58c:	2206      	movs	r2, #6
    e58e:	4904      	ldr	r1, [pc, #16]	; (e5a0 <ll_addr_get+0x30>)
    e590:	f00c fd33 	bl	1affa <memcpy>
	}

	return pub_addr;
    e594:	4802      	ldr	r0, [pc, #8]	; (e5a0 <ll_addr_get+0x30>)
    e596:	e000      	b.n	e59a <ll_addr_get+0x2a>
		return NULL;
    e598:	2000      	movs	r0, #0
}
    e59a:	bd08      	pop	{r3, pc}
    e59c:	20001c81 	.word	0x20001c81
    e5a0:	20001c7b 	.word	0x20001c7b

0000e5a4 <ll_addr_set>:

u32_t ll_addr_set(u8_t addr_type, u8_t const *const bdaddr)
{
    e5a4:	b570      	push	{r4, r5, r6, lr}
    e5a6:	4606      	mov	r6, r0
	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
	    ull_adv_is_enabled(0)) {
    e5a8:	2000      	movs	r0, #0
{
    e5aa:	460d      	mov	r5, r1
	    ull_adv_is_enabled(0)) {
    e5ac:	f00e ff2f 	bl	1d40e <ull_adv_is_enabled>
	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
    e5b0:	4604      	mov	r4, r0
    e5b2:	b948      	cbnz	r0, e5c8 <ll_addr_set+0x24>
	    (ull_scan_is_enabled(0) & (BIT(1) | BIT(2)))) {
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	if (addr_type) {
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
    e5b4:	2206      	movs	r2, #6
    e5b6:	4629      	mov	r1, r5
	if (addr_type) {
    e5b8:	b126      	cbz	r6, e5c4 <ll_addr_set+0x20>
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
    e5ba:	4804      	ldr	r0, [pc, #16]	; (e5cc <ll_addr_set+0x28>)
	} else {
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
    e5bc:	f00c fd1d 	bl	1affa <memcpy>
	}

	return 0;
}
    e5c0:	4620      	mov	r0, r4
    e5c2:	bd70      	pop	{r4, r5, r6, pc}
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
    e5c4:	4802      	ldr	r0, [pc, #8]	; (e5d0 <ll_addr_set+0x2c>)
    e5c6:	e7f9      	b.n	e5bc <ll_addr_set+0x18>
		return BT_HCI_ERR_CMD_DISALLOWED;
    e5c8:	240c      	movs	r4, #12
    e5ca:	e7f9      	b.n	e5c0 <ll_addr_set+0x1c>
    e5cc:	20001c81 	.word	0x20001c81
    e5d0:	20001c7b 	.word	0x20001c7b

0000e5d4 <hci_driver_init>:
	.open	= hci_driver_open,
	.send	= hci_driver_send,
};

static int hci_driver_init(struct device *unused)
{
    e5d4:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	bt_hci_driver_register(&drv);
    e5d6:	4802      	ldr	r0, [pc, #8]	; (e5e0 <hci_driver_init+0xc>)
    e5d8:	f7f8 fbb4 	bl	6d44 <bt_hci_driver_register>

	return 0;
}
    e5dc:	2000      	movs	r0, #0
    e5de:	bd08      	pop	{r3, pc}
    e5e0:	0001f6e4 	.word	0x0001f6e4

0000e5e4 <hci_driver_send>:
	if (!buf->len) {
    e5e4:	8983      	ldrh	r3, [r0, #12]
{
    e5e6:	b537      	push	{r0, r1, r2, r4, r5, lr}
    e5e8:	4605      	mov	r5, r0
	if (!buf->len) {
    e5ea:	b993      	cbnz	r3, e612 <hci_driver_send+0x2e>
		BT_ERR("Empty HCI packet");
    e5ec:	2301      	movs	r3, #1
    e5ee:	f04f 0100 	mov.w	r1, #0
    e5f2:	f363 0107 	bfi	r1, r3, #0, #8
    e5f6:	4a22      	ldr	r2, [pc, #136]	; (e680 <hci_driver_send+0x9c>)
    e5f8:	4b22      	ldr	r3, [pc, #136]	; (e684 <hci_driver_send+0xa0>)
    e5fa:	4823      	ldr	r0, [pc, #140]	; (e688 <hci_driver_send+0xa4>)
    e5fc:	1a9b      	subs	r3, r3, r2
    e5fe:	08db      	lsrs	r3, r3, #3
    e600:	f363 118f 	bfi	r1, r3, #6, #10
    e604:	f00c f805 	bl	1a612 <log_0>
		return -EINVAL;
    e608:	f06f 0415 	mvn.w	r4, #21
}
    e60c:	4620      	mov	r0, r4
    e60e:	b003      	add	sp, #12
    e610:	bd30      	pop	{r4, r5, pc}
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
    e612:	7d01      	ldrb	r1, [r0, #20]
	switch (type) {
    e614:	b181      	cbz	r1, e638 <hci_driver_send+0x54>
    e616:	2902      	cmp	r1, #2
    e618:	d122      	bne.n	e660 <hci_driver_send+0x7c>
	err = hci_acl_handle(buf, &evt);
    e61a:	a901      	add	r1, sp, #4
    e61c:	f000 fec4 	bl	f3a8 <hci_acl_handle>
    e620:	4604      	mov	r4, r0
	if (evt) {
    e622:	9801      	ldr	r0, [sp, #4]
    e624:	b108      	cbz	r0, e62a <hci_driver_send+0x46>
		bt_recv_prio(evt);
    e626:	f7f8 fb37 	bl	6c98 <bt_recv_prio>
	if (!err) {
    e62a:	2c00      	cmp	r4, #0
    e62c:	d1ee      	bne.n	e60c <hci_driver_send+0x28>
		net_buf_unref(buf);
    e62e:	4628      	mov	r0, r5
    e630:	f007 ff76 	bl	16520 <net_buf_unref>
    e634:	2400      	movs	r4, #0
    e636:	e7e9      	b.n	e60c <hci_driver_send+0x28>
	struct node_rx_pdu *node_rx = NULL;
    e638:	9101      	str	r1, [sp, #4]
	evt = hci_cmd_handle(buf, (void **) &node_rx);
    e63a:	a901      	add	r1, sp, #4
    e63c:	f000 fab0 	bl	eba0 <hci_cmd_handle>
	if (evt) {
    e640:	2800      	cmp	r0, #0
    e642:	d0f4      	beq.n	e62e <hci_driver_send+0x4a>
		bt_recv_prio(evt);
    e644:	f7f8 fb28 	bl	6c98 <bt_recv_prio>
		if (node_rx) {
    e648:	9c01      	ldr	r4, [sp, #4]
    e64a:	2c00      	cmp	r4, #0
    e64c:	d0ef      	beq.n	e62e <hci_driver_send+0x4a>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
    e64e:	4620      	mov	r0, r4
    e650:	f00e fe0e 	bl	1d270 <hci_get_class>
    e654:	7160      	strb	r0, [r4, #5]
			k_fifo_put(&recv_fifo, node_rx);
    e656:	9901      	ldr	r1, [sp, #4]
    e658:	480c      	ldr	r0, [pc, #48]	; (e68c <hci_driver_send+0xa8>)
    e65a:	f00f fe77 	bl	1e34c <k_queue_append>
	if (!err) {
    e65e:	e7e6      	b.n	e62e <hci_driver_send+0x4a>
		BT_ERR("Unknown HCI type %u", type);
    e660:	2301      	movs	r3, #1
    e662:	f04f 0200 	mov.w	r2, #0
    e666:	f363 0207 	bfi	r2, r3, #0, #8
    e66a:	4805      	ldr	r0, [pc, #20]	; (e680 <hci_driver_send+0x9c>)
    e66c:	4b05      	ldr	r3, [pc, #20]	; (e684 <hci_driver_send+0xa0>)
    e66e:	1a1b      	subs	r3, r3, r0
    e670:	08db      	lsrs	r3, r3, #3
    e672:	f363 128f 	bfi	r2, r3, #6, #10
    e676:	4806      	ldr	r0, [pc, #24]	; (e690 <hci_driver_send+0xac>)
    e678:	f00b ffd8 	bl	1a62c <log_1>
    e67c:	e7c4      	b.n	e608 <hci_driver_send+0x24>
    e67e:	bf00      	nop
    e680:	0001ed28 	.word	0x0001ed28
    e684:	0001ed70 	.word	0x0001ed70
    e688:	0002193d 	.word	0x0002193d
    e68c:	20005c98 	.word	0x20005c98
    e690:	0002194e 	.word	0x0002194e

0000e694 <recv_thread>:
{
    e694:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return z_impl_k_queue_get(queue, timeout);
    e696:	4d27      	ldr	r5, [pc, #156]	; (e734 <recv_thread+0xa0>)
		LL_ASSERT(0);
    e698:	4e27      	ldr	r6, [pc, #156]	; (e738 <recv_thread+0xa4>)
    e69a:	4f28      	ldr	r7, [pc, #160]	; (e73c <recv_thread+0xa8>)
    e69c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    e6a0:	4628      	mov	r0, r5
    e6a2:	f00f fe7c 	bl	1e39e <z_impl_k_queue_get>
		if (node_rx && !buf) {
    e6a6:	b368      	cbz	r0, e704 <recv_thread+0x70>
	u8_t class = node_rx->hdr.user_meta;
    e6a8:	7943      	ldrb	r3, [r0, #5]
	buf = encode_node(node_rx, class);
    e6aa:	9001      	str	r0, [sp, #4]
	switch (class) {
    e6ac:	b11b      	cbz	r3, e6b6 <recv_thread+0x22>
    e6ae:	2b04      	cmp	r3, #4
    e6b0:	d90f      	bls.n	e6d2 <recv_thread+0x3e>
    e6b2:	2b05      	cmp	r3, #5
    e6b4:	d02f      	beq.n	e716 <recv_thread+0x82>
		LL_ASSERT(0);
    e6b6:	23c4      	movs	r3, #196	; 0xc4
    e6b8:	4632      	mov	r2, r6
    e6ba:	4639      	mov	r1, r7
    e6bc:	4820      	ldr	r0, [pc, #128]	; (e740 <recv_thread+0xac>)
    e6be:	f00a fe59 	bl	19374 <printk>
    e6c2:	4040      	eors	r0, r0
    e6c4:	f380 8811 	msr	BASEPRI, r0
    e6c8:	f04f 0003 	mov.w	r0, #3
    e6cc:	df02      	svc	2
	struct net_buf *buf = NULL;
    e6ce:	2400      	movs	r4, #0
    e6d0:	e00c      	b.n	e6ec <recv_thread+0x58>
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
    e6d2:	2b02      	cmp	r3, #2
    e6d4:	d119      	bne.n	e70a <recv_thread+0x76>
			buf = bt_buf_get_evt(BT_HCI_EVT_UNKNOWN, true,
    e6d6:	2200      	movs	r2, #0
    e6d8:	2101      	movs	r1, #1
    e6da:	4610      	mov	r0, r2
    e6dc:	f7f9 f98c 	bl	79f8 <bt_buf_get_evt>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    e6e0:	4604      	mov	r4, r0
		if (buf) {
    e6e2:	b118      	cbz	r0, e6ec <recv_thread+0x58>
			hci_evt_encode(node_rx, buf);
    e6e4:	4601      	mov	r1, r0
    e6e6:	9801      	ldr	r0, [sp, #4]
    e6e8:	f000 ff3a 	bl	f560 <hci_evt_encode>
	node_rx->hdr.next = NULL;
    e6ec:	9b01      	ldr	r3, [sp, #4]
    e6ee:	2200      	movs	r2, #0
    e6f0:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
    e6f2:	a801      	add	r0, sp, #4
    e6f4:	f001 fd72 	bl	101dc <ll_rx_mem_release>
		if (buf) {
    e6f8:	b124      	cbz	r4, e704 <recv_thread+0x70>
			if (buf->len) {
    e6fa:	89a3      	ldrh	r3, [r4, #12]
				bt_recv(buf);
    e6fc:	4620      	mov	r0, r4
			if (buf->len) {
    e6fe:	b1ab      	cbz	r3, e72c <recv_thread+0x98>
				bt_recv(buf);
    e700:	f7f8 fa14 	bl	6b2c <bt_recv>
	z_impl_k_yield();
    e704:	f009 fe44 	bl	18390 <z_impl_k_yield>
    e708:	e7c8      	b.n	e69c <recv_thread+0x8>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    e70a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    e70e:	2001      	movs	r0, #1
    e710:	f7f9 f93c 	bl	798c <bt_buf_get_rx>
    e714:	e7e4      	b.n	e6e0 <recv_thread+0x4c>
		buf = bt_buf_get_rx(BT_BUF_ACL_IN, K_FOREVER);
    e716:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    e71a:	2003      	movs	r0, #3
    e71c:	f7f9 f936 	bl	798c <bt_buf_get_rx>
    e720:	4604      	mov	r4, r0
		hci_acl_encode(node_rx, buf);
    e722:	4601      	mov	r1, r0
    e724:	9801      	ldr	r0, [sp, #4]
    e726:	f000 fedd 	bl	f4e4 <hci_acl_encode>
		break;
    e72a:	e7df      	b.n	e6ec <recv_thread+0x58>
				net_buf_unref(buf);
    e72c:	f007 fef8 	bl	16520 <net_buf_unref>
    e730:	e7e8      	b.n	e704 <recv_thread+0x70>
    e732:	bf00      	nop
    e734:	20005c98 	.word	0x20005c98
    e738:	00021962 	.word	0x00021962
    e73c:	00022577 	.word	0x00022577
    e740:	00020aa4 	.word	0x00020aa4

0000e744 <prio_recv_thread>:
{
    e744:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return z_impl_k_sem_take(sem, timeout);
    e746:	4d17      	ldr	r5, [pc, #92]	; (e7a4 <prio_recv_thread+0x60>)
				k_fifo_put(&recv_fifo, node_rx);
    e748:	4e17      	ldr	r6, [pc, #92]	; (e7a8 <prio_recv_thread+0x64>)
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
    e74a:	f10d 0102 	add.w	r1, sp, #2
    e74e:	a801      	add	r0, sp, #4
    e750:	f001 fc2e 	bl	ffb0 <ll_rx_get>
    e754:	4604      	mov	r4, r0
    e756:	b968      	cbnz	r0, e774 <prio_recv_thread+0x30>
		if (node_rx) {
    e758:	9b01      	ldr	r3, [sp, #4]
    e75a:	b1eb      	cbz	r3, e798 <prio_recv_thread+0x54>
			ll_rx_dequeue();
    e75c:	f001 fc80 	bl	10060 <ll_rx_dequeue>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
    e760:	9c01      	ldr	r4, [sp, #4]
    e762:	4620      	mov	r0, r4
    e764:	f00e fd84 	bl	1d270 <hci_get_class>
				k_fifo_put(&recv_fifo, node_rx);
    e768:	9901      	ldr	r1, [sp, #4]
			node_rx->hdr.user_meta = hci_get_class(node_rx);
    e76a:	7160      	strb	r0, [r4, #5]
				k_fifo_put(&recv_fifo, node_rx);
    e76c:	4630      	mov	r0, r6
    e76e:	f00f fded 	bl	1e34c <k_queue_append>
			continue;
    e772:	e7ea      	b.n	e74a <prio_recv_thread+0x6>
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
    e774:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    e778:	2100      	movs	r1, #0
    e77a:	2013      	movs	r0, #19
    e77c:	f7f9 f93c 	bl	79f8 <bt_buf_get_evt>
			hci_num_cmplt_encode(buf, handle, num_cmplt);
    e780:	4622      	mov	r2, r4
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
    e782:	4607      	mov	r7, r0
			hci_num_cmplt_encode(buf, handle, num_cmplt);
    e784:	f8bd 1002 	ldrh.w	r1, [sp, #2]
    e788:	f00e fd5e 	bl	1d248 <hci_num_cmplt_encode>
			bt_recv_prio(buf);
    e78c:	4638      	mov	r0, r7
    e78e:	f7f8 fa83 	bl	6c98 <bt_recv_prio>
	z_impl_k_yield();
    e792:	f009 fdfd 	bl	18390 <z_impl_k_yield>
    e796:	e7d8      	b.n	e74a <prio_recv_thread+0x6>
	return z_impl_k_sem_take(sem, timeout);
    e798:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    e79c:	4628      	mov	r0, r5
    e79e:	f009 fe9d 	bl	184dc <z_impl_k_sem_take>
		BT_DBG("sem taken");
    e7a2:	e7d2      	b.n	e74a <prio_recv_thread+0x6>
    e7a4:	20005c48 	.word	0x20005c48
    e7a8:	20005c98 	.word	0x20005c98

0000e7ac <hci_driver_open>:
{
    e7ac:	b510      	push	{r4, lr}
	err = ll_init(&sem_prio_recv);
    e7ae:	4820      	ldr	r0, [pc, #128]	; (e830 <hci_driver_open+0x84>)
{
    e7b0:	b086      	sub	sp, #24
	err = ll_init(&sem_prio_recv);
    e7b2:	f001 fb1f 	bl	fdf4 <ll_init>
	if (err) {
    e7b6:	4604      	mov	r4, r0
    e7b8:	b188      	cbz	r0, e7de <hci_driver_open+0x32>
		BT_ERR("LL initialization failed: %u", err);
    e7ba:	2301      	movs	r3, #1
    e7bc:	f04f 0200 	mov.w	r2, #0
    e7c0:	f363 0207 	bfi	r2, r3, #0, #8
    e7c4:	491b      	ldr	r1, [pc, #108]	; (e834 <hci_driver_open+0x88>)
    e7c6:	4b1c      	ldr	r3, [pc, #112]	; (e838 <hci_driver_open+0x8c>)
    e7c8:	1a5b      	subs	r3, r3, r1
    e7ca:	08db      	lsrs	r3, r3, #3
    e7cc:	4601      	mov	r1, r0
    e7ce:	f363 128f 	bfi	r2, r3, #6, #10
    e7d2:	481a      	ldr	r0, [pc, #104]	; (e83c <hci_driver_open+0x90>)
    e7d4:	f00b ff2a 	bl	1a62c <log_1>
}
    e7d8:	4620      	mov	r0, r4
    e7da:	b006      	add	sp, #24
    e7dc:	bd10      	pop	{r4, pc}
	hci_init(NULL);
    e7de:	f001 f927 	bl	fa30 <hci_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    e7e2:	f06f 0309 	mvn.w	r3, #9
    e7e6:	e9cd 4302 	strd	r4, r3, [sp, #8]
    e7ea:	e9cd 4404 	strd	r4, r4, [sp, #16]
    e7ee:	e9cd 4400 	strd	r4, r4, [sp]
    e7f2:	4b13      	ldr	r3, [pc, #76]	; (e840 <hci_driver_open+0x94>)
    e7f4:	4913      	ldr	r1, [pc, #76]	; (e844 <hci_driver_open+0x98>)
    e7f6:	4814      	ldr	r0, [pc, #80]	; (e848 <hci_driver_open+0x9c>)
    e7f8:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
    e7fc:	f009 fee6 	bl	185cc <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    e800:	4912      	ldr	r1, [pc, #72]	; (e84c <hci_driver_open+0xa0>)
    e802:	4811      	ldr	r0, [pc, #68]	; (e848 <hci_driver_open+0x9c>)
    e804:	f00f ff2d 	bl	1e662 <z_impl_k_thread_name_set>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    e808:	f06f 0307 	mvn.w	r3, #7
    e80c:	e9cd 4302 	strd	r4, r3, [sp, #8]
    e810:	e9cd 4404 	strd	r4, r4, [sp, #16]
    e814:	e9cd 4400 	strd	r4, r4, [sp]
    e818:	4b0d      	ldr	r3, [pc, #52]	; (e850 <hci_driver_open+0xa4>)
    e81a:	490e      	ldr	r1, [pc, #56]	; (e854 <hci_driver_open+0xa8>)
    e81c:	480e      	ldr	r0, [pc, #56]	; (e858 <hci_driver_open+0xac>)
    e81e:	f640 0298 	movw	r2, #2200	; 0x898
    e822:	f009 fed3 	bl	185cc <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    e826:	490d      	ldr	r1, [pc, #52]	; (e85c <hci_driver_open+0xb0>)
    e828:	480b      	ldr	r0, [pc, #44]	; (e858 <hci_driver_open+0xac>)
    e82a:	f00f ff1a 	bl	1e662 <z_impl_k_thread_name_set>
	return 0;
    e82e:	e7d3      	b.n	e7d8 <hci_driver_open+0x2c>
    e830:	20005c48 	.word	0x20005c48
    e834:	0001ed28 	.word	0x0001ed28
    e838:	0001ed70 	.word	0x0001ed70
    e83c:	00021910 	.word	0x00021910
    e840:	0000e745 	.word	0x0000e745
    e844:	20002918 	.word	0x20002918
    e848:	2000086c 	.word	0x2000086c
    e84c:	0002192d 	.word	0x0002192d
    e850:	0000e695 	.word	0x0000e695
    e854:	20002ad8 	.word	0x20002ad8
    e858:	200008d8 	.word	0x200008d8
    e85c:	00021937 	.word	0x00021937

0000e860 <cmd_status>:
	return net_buf_add(*buf, plen);
}

#if defined(CONFIG_BT_CONN)
static struct net_buf *cmd_status(u8_t status)
{
    e860:	b538      	push	{r3, r4, r5, lr}
	struct bt_hci_evt_cmd_status *cs;
	struct net_buf *buf;

	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
    e862:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
    e866:	4605      	mov	r5, r0
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
    e868:	2100      	movs	r1, #0
    e86a:	200f      	movs	r0, #15
    e86c:	f7f9 f8c4 	bl	79f8 <bt_buf_get_evt>
	hci_evt_create(buf, BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
    e870:	2204      	movs	r2, #4
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
    e872:	4604      	mov	r4, r0
	hci_evt_create(buf, BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
    e874:	210f      	movs	r1, #15
    e876:	f00e fcc8 	bl	1d20a <hci_evt_create>

	cs = net_buf_add(buf, sizeof(*cs));
    e87a:	2104      	movs	r1, #4
    e87c:	f104 0008 	add.w	r0, r4, #8
    e880:	f00f f9e4 	bl	1dc4c <net_buf_simple_add>
	cs->status = status;
	cs->ncmd = 1U;
    e884:	2301      	movs	r3, #1
    e886:	7043      	strb	r3, [r0, #1]
	cs->opcode = sys_cpu_to_le16(_opcode);
    e888:	4b02      	ldr	r3, [pc, #8]	; (e894 <cmd_status+0x34>)
	cs->status = status;
    e88a:	7005      	strb	r5, [r0, #0]
	cs->opcode = sys_cpu_to_le16(_opcode);
    e88c:	881b      	ldrh	r3, [r3, #0]
    e88e:	8043      	strh	r3, [r0, #2]

	return buf;
}
    e890:	4620      	mov	r0, r4
    e892:	bd38      	pop	{r3, r4, r5, pc}
    e894:	20001b08 	.word	0x20001b08

0000e898 <le_remote_feat_complete>:
}
#endif /* CONFIG_BT_CTLR_LE_ENC */

static void le_remote_feat_complete(u8_t status, struct pdu_data *pdu_data,
				    u16_t handle, struct net_buf *buf)
{
    e898:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e89a:	4605      	mov	r5, r0
    e89c:	4618      	mov	r0, r3
	struct bt_hci_evt_le_remote_feat_complete *sep;

	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    e89e:	4b13      	ldr	r3, [pc, #76]	; (e8ec <le_remote_feat_complete+0x54>)
{
    e8a0:	460e      	mov	r6, r1
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    e8a2:	6859      	ldr	r1, [r3, #4]
    e8a4:	2400      	movs	r4, #0
{
    e8a6:	4617      	mov	r7, r2
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    e8a8:	f001 5300 	and.w	r3, r1, #536870912	; 0x20000000
    e8ac:	4622      	mov	r2, r4
    e8ae:	4313      	orrs	r3, r2
    e8b0:	d01a      	beq.n	e8e8 <le_remote_feat_complete+0x50>
	    !(le_event_mask & BT_EVT_MASK_LE_REMOTE_FEAT_COMPLETE)) {
    e8b2:	4b0f      	ldr	r3, [pc, #60]	; (e8f0 <le_remote_feat_complete+0x58>)
    e8b4:	6819      	ldr	r1, [r3, #0]
    e8b6:	4623      	mov	r3, r4
    e8b8:	f001 0208 	and.w	r2, r1, #8
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    e8bc:	4313      	orrs	r3, r2
    e8be:	d013      	beq.n	e8e8 <le_remote_feat_complete+0x50>
		return;
	}

	sep = meta_evt(buf, BT_HCI_EV_LE_REMOTE_FEAT_COMPLETE, sizeof(*sep));
    e8c0:	220b      	movs	r2, #11
    e8c2:	2104      	movs	r1, #4
    e8c4:	f00e fcab 	bl	1d21e <meta_evt>

	sep->status = status;
	sep->handle = sys_cpu_to_le16(handle);
	if (!status) {
		memcpy(&sep->features[0],
    e8c8:	2208      	movs	r2, #8
	sep->status = status;
    e8ca:	7005      	strb	r5, [r0, #0]
	sep->handle = sys_cpu_to_le16(handle);
    e8cc:	f8a0 7001 	strh.w	r7, [r0, #1]
	if (!status) {
    e8d0:	3003      	adds	r0, #3
    e8d2:	b925      	cbnz	r5, e8de <le_remote_feat_complete+0x46>
		memcpy(&sep->features[0],
    e8d4:	1d31      	adds	r1, r6, #4
		       &pdu_data->llctrl.feature_rsp.features[0],
		       sizeof(sep->features));
	} else {
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
	}
}
    e8d6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		memcpy(&sep->features[0],
    e8da:	f00c bb8e 	b.w	1affa <memcpy>
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
    e8de:	4621      	mov	r1, r4
}
    e8e0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
    e8e4:	f00c bbb3 	b.w	1b04e <memset>
}
    e8e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e8ea:	bf00      	nop
    e8ec:	20005588 	.word	0x20005588
    e8f0:	20005590 	.word	0x20005590

0000e8f4 <encrypt_change>:
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
    e8f4:	4b0e      	ldr	r3, [pc, #56]	; (e930 <encrypt_change+0x3c>)
{
    e8f6:	b570      	push	{r4, r5, r6, lr}
    e8f8:	460e      	mov	r6, r1
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
    e8fa:	6819      	ldr	r1, [r3, #0]
{
    e8fc:	4615      	mov	r5, r2
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
    e8fe:	2300      	movs	r3, #0
    e900:	f001 0280 	and.w	r2, r1, #128	; 0x80
    e904:	4313      	orrs	r3, r2
{
    e906:	4604      	mov	r4, r0
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
    e908:	d010      	beq.n	e92c <encrypt_change+0x38>
	hci_evt_create(buf, BT_HCI_EVT_ENCRYPT_CHANGE, sizeof(*ep));
    e90a:	2204      	movs	r2, #4
    e90c:	2108      	movs	r1, #8
    e90e:	4628      	mov	r0, r5
    e910:	f00e fc7b 	bl	1d20a <hci_evt_create>
	ep = net_buf_add(buf, sizeof(*ep));
    e914:	2104      	movs	r1, #4
    e916:	f105 0008 	add.w	r0, r5, #8
    e91a:	f00f f997 	bl	1dc4c <net_buf_simple_add>
	ep->encrypt = !err ? 1 : 0;
    e91e:	fab4 f384 	clz	r3, r4
    e922:	095b      	lsrs	r3, r3, #5
	ep->status = err;
    e924:	7004      	strb	r4, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
    e926:	f8a0 6001 	strh.w	r6, [r0, #1]
	ep->encrypt = !err ? 1 : 0;
    e92a:	70c3      	strb	r3, [r0, #3]
}
    e92c:	bd70      	pop	{r4, r5, r6, pc}
    e92e:	bf00      	nop
    e930:	20005588 	.word	0x20005588

0000e934 <hci_cmd_complete>:
{
    e934:	b538      	push	{r3, r4, r5, lr}
	*buf = bt_buf_get_evt(BT_HCI_EVT_CMD_COMPLETE, false, K_FOREVER);
    e936:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
    e93a:	4604      	mov	r4, r0
    e93c:	460d      	mov	r5, r1
	*buf = bt_buf_get_evt(BT_HCI_EVT_CMD_COMPLETE, false, K_FOREVER);
    e93e:	200e      	movs	r0, #14
    e940:	2100      	movs	r1, #0
    e942:	f7f9 f859 	bl	79f8 <bt_buf_get_evt>
	hci_evt_create(*buf, BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
    e946:	1cea      	adds	r2, r5, #3
	*buf = bt_buf_get_evt(BT_HCI_EVT_CMD_COMPLETE, false, K_FOREVER);
    e948:	6020      	str	r0, [r4, #0]
	hci_evt_create(*buf, BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
    e94a:	b2d2      	uxtb	r2, r2
    e94c:	210e      	movs	r1, #14
    e94e:	f00e fc5c 	bl	1d20a <hci_evt_create>
	cc = net_buf_add(*buf, sizeof(*cc));
    e952:	6820      	ldr	r0, [r4, #0]
    e954:	2103      	movs	r1, #3
    e956:	3008      	adds	r0, #8
    e958:	f00f f978 	bl	1dc4c <net_buf_simple_add>
	cc->ncmd = 1U;
    e95c:	2301      	movs	r3, #1
    e95e:	7003      	strb	r3, [r0, #0]
	cc->opcode = sys_cpu_to_le16(_opcode);
    e960:	4b05      	ldr	r3, [pc, #20]	; (e978 <hci_cmd_complete+0x44>)
    e962:	881b      	ldrh	r3, [r3, #0]
    e964:	f8a0 3001 	strh.w	r3, [r0, #1]
	return net_buf_add(*buf, plen);
    e968:	6820      	ldr	r0, [r4, #0]
    e96a:	4629      	mov	r1, r5
    e96c:	3008      	adds	r0, #8
}
    e96e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return net_buf_add(*buf, plen);
    e972:	f00f b96b 	b.w	1dc4c <net_buf_simple_add>
    e976:	bf00      	nop
    e978:	20001b08 	.word	0x20001b08

0000e97c <hci_vendor_cmd_handle_common>:
{
    e97c:	b5f0      	push	{r4, r5, r6, r7, lr}
	switch (ocf) {
    e97e:	3801      	subs	r0, #1
{
    e980:	b087      	sub	sp, #28
    e982:	4615      	mov	r5, r2
	switch (ocf) {
    e984:	2809      	cmp	r0, #9
    e986:	f200 8105 	bhi.w	eb94 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x134>
    e98a:	e8df f010 	tbh	[pc, r0, lsl #1]
    e98e:	000a      	.short	0x000a
    e990:	00380021 	.word	0x00380021
    e994:	01030103 	.word	0x01030103
    e998:	0103005f 	.word	0x0103005f
    e99c:	006a0044 	.word	0x006a0044
    e9a0:	00c5      	.short	0x00c5
	rp = hci_cmd_complete(evt, sizeof(*rp));
    e9a2:	4610      	mov	r0, r2
    e9a4:	210d      	movs	r1, #13
    e9a6:	f7ff ffc5 	bl	e934 <hci_cmd_complete>
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
    e9aa:	2202      	movs	r2, #2
    e9ac:	7042      	strb	r2, [r0, #1]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
    e9ae:	70c2      	strb	r2, [r0, #3]
	rp->fw_version = (KERNEL_VERSION_MAJOR & 0xff);
    e9b0:	7182      	strb	r2, [r0, #6]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
    e9b2:	2201      	movs	r2, #1
	rp->status = 0x00;
    e9b4:	2300      	movs	r3, #0
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
    e9b6:	71c2      	strb	r2, [r0, #7]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
    e9b8:	2263      	movs	r2, #99	; 0x63
	rp->status = 0x00;
    e9ba:	7003      	strb	r3, [r0, #0]
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
    e9bc:	7083      	strb	r3, [r0, #2]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
    e9be:	7103      	strb	r3, [r0, #4]
	rp->fw_variant = 0U;
    e9c0:	7143      	strb	r3, [r0, #5]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
    e9c2:	7203      	strb	r3, [r0, #8]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
    e9c4:	7242      	strb	r2, [r0, #9]
    e9c6:	7283      	strb	r3, [r0, #10]
    e9c8:	72c3      	strb	r3, [r0, #11]
    e9ca:	7303      	strb	r3, [r0, #12]
	return 0;
    e9cc:	2400      	movs	r4, #0
    e9ce:	e013      	b.n	e9f8 <hci_vendor_cmd_handle_common+0x7c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    e9d0:	2141      	movs	r1, #65	; 0x41
    e9d2:	4610      	mov	r0, r2
    e9d4:	f7ff ffae 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    e9d8:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    e9da:	4605      	mov	r5, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
    e9dc:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
    e9de:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
    e9e2:	4621      	mov	r1, r4
    e9e4:	f00c fb33 	bl	1b04e <memset>
	rp->commands[0] |= BIT(5) | BIT(7);
    e9e8:	786b      	ldrb	r3, [r5, #1]
    e9ea:	f063 0358 	orn	r3, r3, #88	; 0x58
    e9ee:	706b      	strb	r3, [r5, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
    e9f0:	78ab      	ldrb	r3, [r5, #2]
    e9f2:	f043 0303 	orr.w	r3, r3, #3
    e9f6:	70ab      	strb	r3, [r5, #2]
}
    e9f8:	4620      	mov	r0, r4
    e9fa:	b007      	add	sp, #28
    e9fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp));
    e9fe:	2109      	movs	r1, #9
    ea00:	4610      	mov	r0, r2
    ea02:	f7ff ff97 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    ea06:	2400      	movs	r4, #0
    ea08:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    ea0c:	2208      	movs	r2, #8
    ea0e:	4621      	mov	r1, r4
    ea10:	f00c fb1d 	bl	1b04e <memset>
    ea14:	e7f0      	b.n	e9f8 <hci_vendor_cmd_handle_common+0x7c>
	const char build_info[] = HCI_VS_BUILD_INFO;
    ea16:	4b61      	ldr	r3, [pc, #388]	; (eb9c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x13c>)
    ea18:	aa01      	add	r2, sp, #4
    ea1a:	f103 0710 	add.w	r7, r3, #16
    ea1e:	4616      	mov	r6, r2
    ea20:	6818      	ldr	r0, [r3, #0]
    ea22:	6859      	ldr	r1, [r3, #4]
    ea24:	4614      	mov	r4, r2
    ea26:	c403      	stmia	r4!, {r0, r1}
    ea28:	3308      	adds	r3, #8
    ea2a:	42bb      	cmp	r3, r7
    ea2c:	4622      	mov	r2, r4
    ea2e:	d1f7      	bne.n	ea20 <hci_vendor_cmd_handle_common+0xa4>
    ea30:	881b      	ldrh	r3, [r3, #0]
    ea32:	8023      	strh	r3, [r4, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(build_info));
    ea34:	2113      	movs	r1, #19
    ea36:	4628      	mov	r0, r5
    ea38:	f7ff ff7c 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    ea3c:	2400      	movs	r4, #0
    ea3e:	f800 4b01 	strb.w	r4, [r0], #1
	memcpy(rp->info, build_info, sizeof(build_info));
    ea42:	2212      	movs	r2, #18
    ea44:	4631      	mov	r1, r6
    ea46:	f00c fad8 	bl	1affa <memcpy>
    ea4a:	e7d5      	b.n	e9f8 <hci_vendor_cmd_handle_common+0x7c>
	ll_addr_set(0, &cmd->bdaddr.val[0]);
    ea4c:	6889      	ldr	r1, [r1, #8]
    ea4e:	2000      	movs	r0, #0
    ea50:	f7ff fda8 	bl	e5a4 <ll_addr_set>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    ea54:	2101      	movs	r1, #1
    ea56:	4628      	mov	r0, r5
    ea58:	f7ff ff6c 	bl	e934 <hci_cmd_complete>
	ccst->status = 0x00;
    ea5c:	2300      	movs	r3, #0
    ea5e:	7003      	strb	r3, [r0, #0]
    ea60:	e7b4      	b.n	e9cc <hci_vendor_cmd_handle_common+0x50>
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
    ea62:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    ea66:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
    ea6a:	3201      	adds	r2, #1
    ea6c:	d106      	bne.n	ea7c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x1c>
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
    ea6e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
    ea72:	f64f 72ff 	movw	r2, #65535	; 0xffff
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
    ea76:	b29b      	uxth	r3, r3
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
    ea78:	4293      	cmp	r3, r2
    ea7a:	d045      	beq.n	eb08 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa8>
	      (NRF_FICR->DEVICEADDRTYPE & 0x01)) {
    ea7c:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
    ea80:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
    ea84:	07db      	lsls	r3, r3, #31
    ea86:	d53f      	bpl.n	eb08 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa8>
		rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(*addr));
    ea88:	2118      	movs	r1, #24
    ea8a:	4628      	mov	r0, r5
    ea8c:	f7ff ff52 	bl	e934 <hci_cmd_complete>
		rp->num_addrs = 1U;
    ea90:	2301      	movs	r3, #1
		rp->status = 0x00;
    ea92:	2200      	movs	r2, #0
		rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(*addr));
    ea94:	4605      	mov	r5, r0
		rp->num_addrs = 1U;
    ea96:	7043      	strb	r3, [r0, #1]
		rp->status = 0x00;
    ea98:	7002      	strb	r2, [r0, #0]
		sys_put_le32(NRF_FICR->DEVICEADDR[0], &addr->bdaddr.val[0]);
    ea9a:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
    ea9e:	1ca9      	adds	r1, r5, #2
    eaa0:	f00e fba6 	bl	1d1f0 <sys_put_le32>
		sys_put_le16(NRF_FICR->DEVICEADDR[1], &addr->bdaddr.val[4]);
    eaa4:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
	dst[0] = val;
    eaa8:	71ab      	strb	r3, [r5, #6]
	dst[1] = val >> 8;
    eaaa:	f3c3 2307 	ubfx	r3, r3, #8, #8
		BT_ADDR_SET_STATIC(&addr->bdaddr);
    eaae:	f063 033f 	orn	r3, r3, #63	; 0x3f
    eab2:	71eb      	strb	r3, [r5, #7]
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
    eab4:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
    eab8:	3301      	adds	r3, #1
    eaba:	f105 0308 	add.w	r3, r5, #8
    eabe:	d063      	beq.n	eb88 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x128>
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
    eac0:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
    eac4:	3101      	adds	r1, #1
    eac6:	d05f      	beq.n	eb88 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x128>
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
    eac8:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
    eacc:	3101      	adds	r1, #1
    eace:	d05b      	beq.n	eb88 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x128>
		    (NRF_FICR->IR[3] != UINT32_MAX)) {
    ead0:	f8d4 109c 	ldr.w	r1, [r4, #156]	; 0x9c
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
    ead4:	3101      	adds	r1, #1
    ead6:	d057      	beq.n	eb88 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x128>
			sys_put_le32(NRF_FICR->IR[0], &addr->ir[0]);
    ead8:	4619      	mov	r1, r3
    eada:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
    eade:	f00e fb87 	bl	1d1f0 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[1], &addr->ir[4]);
    eae2:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
    eae6:	f105 010c 	add.w	r1, r5, #12
    eaea:	f00e fb81 	bl	1d1f0 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[2], &addr->ir[8]);
    eaee:	f8d4 0098 	ldr.w	r0, [r4, #152]	; 0x98
    eaf2:	f105 0110 	add.w	r1, r5, #16
    eaf6:	f00e fb7b 	bl	1d1f0 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[3], &addr->ir[12]);
    eafa:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
    eafe:	f105 0114 	add.w	r1, r5, #20
    eb02:	f00e fb75 	bl	1d1f0 <sys_put_le32>
    eb06:	e761      	b.n	e9cc <hci_vendor_cmd_handle_common+0x50>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    eb08:	2102      	movs	r1, #2
    eb0a:	4628      	mov	r0, r5
    eb0c:	f7ff ff12 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    eb10:	2300      	movs	r3, #0
    eb12:	7003      	strb	r3, [r0, #0]
	rp->num_addrs = 0U;
    eb14:	7043      	strb	r3, [r0, #1]
    eb16:	e759      	b.n	e9cc <hci_vendor_cmd_handle_common+0x50>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    eb18:	2121      	movs	r1, #33	; 0x21
    eb1a:	4610      	mov	r0, r2
    eb1c:	f7ff ff0a 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    eb20:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    eb22:	4605      	mov	r5, r0
	(void)memset(rp->ir, 0x00, sizeof(rp->ir));
    eb24:	2210      	movs	r2, #16
	rp->status = 0x00;
    eb26:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(rp->ir, 0x00, sizeof(rp->ir));
    eb2a:	4621      	mov	r1, r4
    eb2c:	f00c fa8f 	bl	1b04e <memset>
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
    eb30:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    eb34:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
    eb38:	3301      	adds	r3, #1
    eb3a:	f105 0311 	add.w	r3, r5, #17
    eb3e:	d023      	beq.n	eb88 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x128>
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
    eb40:	f8d2 1084 	ldr.w	r1, [r2, #132]	; 0x84
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
    eb44:	3101      	adds	r1, #1
    eb46:	d01f      	beq.n	eb88 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x128>
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
    eb48:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
    eb4c:	3101      	adds	r1, #1
    eb4e:	d01b      	beq.n	eb88 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x128>
	    (NRF_FICR->ER[3] != UINT32_MAX)) {
    eb50:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
    eb54:	3101      	adds	r1, #1
    eb56:	d017      	beq.n	eb88 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x128>
		sys_put_le32(NRF_FICR->ER[0], &rp->er[0]);
    eb58:	f8d2 0080 	ldr.w	r0, [r2, #128]	; 0x80
    eb5c:	4619      	mov	r1, r3
    eb5e:	f00e fb47 	bl	1d1f0 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[1], &rp->er[4]);
    eb62:	f105 0115 	add.w	r1, r5, #21
    eb66:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
    eb6a:	f00e fb41 	bl	1d1f0 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[2], &rp->er[8]);
    eb6e:	f105 0119 	add.w	r1, r5, #25
    eb72:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88
    eb76:	f00e fb3b 	bl	1d1f0 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[3], &rp->er[12]);
    eb7a:	f105 011d 	add.w	r1, r5, #29
    eb7e:	f8d2 008c 	ldr.w	r0, [r2, #140]	; 0x8c
    eb82:	f00e fb35 	bl	1d1f0 <sys_put_le32>
    eb86:	e737      	b.n	e9f8 <hci_vendor_cmd_handle_common+0x7c>
		(void)memset(rp->er, 0x00, sizeof(rp->er));
    eb88:	2210      	movs	r2, #16
    eb8a:	2100      	movs	r1, #0
    eb8c:	4618      	mov	r0, r3
    eb8e:	f00c fa5e 	bl	1b04e <memset>
    eb92:	e71b      	b.n	e9cc <hci_vendor_cmd_handle_common+0x50>
		return -EINVAL;
    eb94:	f06f 0415 	mvn.w	r4, #21
    eb98:	e72e      	b.n	e9f8 <hci_vendor_cmd_handle_common+0x7c>
    eb9a:	bf00      	nop
    eb9c:	00021aae 	.word	0x00021aae

0000eba0 <hci_cmd_handle>:
{
    eba0:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (cmd->len < sizeof(*chdr)) {
    eba2:	8983      	ldrh	r3, [r0, #12]
{
    eba4:	b08d      	sub	sp, #52	; 0x34
	struct net_buf *evt = NULL;
    eba6:	2600      	movs	r6, #0
	if (cmd->len < sizeof(*chdr)) {
    eba8:	2b02      	cmp	r3, #2
{
    ebaa:	4604      	mov	r4, r0
	struct net_buf *evt = NULL;
    ebac:	9607      	str	r6, [sp, #28]
	if (cmd->len < sizeof(*chdr)) {
    ebae:	d810      	bhi.n	ebd2 <hci_cmd_handle+0x32>
		BT_ERR("No HCI Command header");
    ebb0:	2301      	movs	r3, #1
    ebb2:	f04f 0100 	mov.w	r1, #0
    ebb6:	f363 0107 	bfi	r1, r3, #0, #8
    ebba:	4ab3      	ldr	r2, [pc, #716]	; (ee88 <hci_cmd_handle+0x2e8>)
    ebbc:	4bb3      	ldr	r3, [pc, #716]	; (ee8c <hci_cmd_handle+0x2ec>)
    ebbe:	48b4      	ldr	r0, [pc, #720]	; (ee90 <hci_cmd_handle+0x2f0>)
    ebc0:	1a9b      	subs	r3, r3, r2
    ebc2:	08db      	lsrs	r3, r3, #3
    ebc4:	f363 118f 	bfi	r1, r3, #6, #10
		BT_ERR("Invalid HCI CMD packet length");
    ebc8:	f00b fd23 	bl	1a612 <log_0>
		return NULL;
    ebcc:	4630      	mov	r0, r6
}
    ebce:	b00d      	add	sp, #52	; 0x34
    ebd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	chdr = net_buf_pull_mem(cmd, sizeof(*chdr));
    ebd2:	2103      	movs	r1, #3
    ebd4:	3008      	adds	r0, #8
    ebd6:	f00f f86a 	bl	1dcae <net_buf_simple_pull_mem>
	if (cmd->len < chdr->param_len) {
    ebda:	89a2      	ldrh	r2, [r4, #12]
    ebdc:	7883      	ldrb	r3, [r0, #2]
    ebde:	429a      	cmp	r2, r3
    ebe0:	d20c      	bcs.n	ebfc <hci_cmd_handle+0x5c>
		BT_ERR("Invalid HCI CMD packet length");
    ebe2:	2301      	movs	r3, #1
    ebe4:	f04f 0100 	mov.w	r1, #0
    ebe8:	f363 0107 	bfi	r1, r3, #0, #8
    ebec:	4aa6      	ldr	r2, [pc, #664]	; (ee88 <hci_cmd_handle+0x2e8>)
    ebee:	4ba7      	ldr	r3, [pc, #668]	; (ee8c <hci_cmd_handle+0x2ec>)
    ebf0:	48a8      	ldr	r0, [pc, #672]	; (ee94 <hci_cmd_handle+0x2f4>)
    ebf2:	1a9b      	subs	r3, r3, r2
    ebf4:	08db      	lsrs	r3, r3, #3
    ebf6:	f363 118f 	bfi	r1, r3, #6, #10
    ebfa:	e7e5      	b.n	ebc8 <hci_cmd_handle+0x28>
	_opcode = sys_le16_to_cpu(chdr->opcode);
    ebfc:	8802      	ldrh	r2, [r0, #0]
    ebfe:	49a6      	ldr	r1, [pc, #664]	; (ee98 <hci_cmd_handle+0x2f8>)
    ec00:	b293      	uxth	r3, r2
	ocf = BT_OCF(_opcode);
    ec02:	f3c3 0509 	ubfx	r5, r3, #0, #10
	switch (BT_OGF(_opcode)) {
    ec06:	0a9b      	lsrs	r3, r3, #10
    ec08:	2b04      	cmp	r3, #4
	_opcode = sys_le16_to_cpu(chdr->opcode);
    ec0a:	800a      	strh	r2, [r1, #0]
	switch (BT_OGF(_opcode)) {
    ec0c:	f000 809a 	beq.w	ed44 <hci_cmd_handle+0x1a4>
    ec10:	d809      	bhi.n	ec26 <hci_cmd_handle+0x86>
    ec12:	2b01      	cmp	r3, #1
    ec14:	d014      	beq.n	ec40 <hci_cmd_handle+0xa0>
    ec16:	2b03      	cmp	r3, #3
    ec18:	d024      	beq.n	ec64 <hci_cmd_handle+0xc4>
		ccst = hci_cmd_complete(&evt, sizeof(*ccst));
    ec1a:	2101      	movs	r1, #1
    ec1c:	a807      	add	r0, sp, #28
    ec1e:	f7ff fe89 	bl	e934 <hci_cmd_complete>
		ccst->status = BT_HCI_ERR_UNKNOWN_CMD;
    ec22:	2301      	movs	r3, #1
    ec24:	e03d      	b.n	eca2 <hci_cmd_handle+0x102>
	switch (BT_OGF(_opcode)) {
    ec26:	2b08      	cmp	r3, #8
    ec28:	f000 813e 	beq.w	eea8 <hci_cmd_handle+0x308>
    ec2c:	2b3f      	cmp	r3, #63	; 0x3f
    ec2e:	d1f4      	bne.n	ec1a <hci_cmd_handle+0x7a>

/* Map vendor command handler directly to common implementation */
inline int hci_vendor_cmd_handle(u16_t ocf, struct net_buf *cmd,
				 struct net_buf **evt)
{
	return hci_vendor_cmd_handle_common(ocf, cmd, evt);
    ec30:	aa07      	add	r2, sp, #28
    ec32:	4621      	mov	r1, r4
    ec34:	4628      	mov	r0, r5
    ec36:	f7ff fea1 	bl	e97c <hci_vendor_cmd_handle_common>
	if (err == -EINVAL) {
    ec3a:	3016      	adds	r0, #22
    ec3c:	d0ed      	beq.n	ec1a <hci_cmd_handle+0x7a>
    ec3e:	e04a      	b.n	ecd6 <hci_cmd_handle+0x136>
	switch (ocf) {
    ec40:	2d06      	cmp	r5, #6
    ec42:	d006      	beq.n	ec52 <hci_cmd_handle+0xb2>
    ec44:	2d1d      	cmp	r5, #29
    ec46:	d1e8      	bne.n	ec1a <hci_cmd_handle+0x7a>
	handle = sys_le16_to_cpu(cmd->handle);
    ec48:	68a3      	ldr	r3, [r4, #8]
	status = ll_version_ind_send(handle);
    ec4a:	8818      	ldrh	r0, [r3, #0]
    ec4c:	f00e fda2 	bl	1d794 <ll_version_ind_send>
	*evt = cmd_status(status);
    ec50:	e004      	b.n	ec5c <hci_cmd_handle+0xbc>
		disconnect(cmd, evt);
    ec52:	68a3      	ldr	r3, [r4, #8]
	status = ll_terminate_ind_send(handle, cmd->reason);
    ec54:	7899      	ldrb	r1, [r3, #2]
    ec56:	8818      	ldrh	r0, [r3, #0]
    ec58:	f00e fd7b 	bl	1d752 <ll_terminate_ind_send>
	*evt = cmd_status(status);
    ec5c:	f7ff fe00 	bl	e860 <cmd_status>
    ec60:	9007      	str	r0, [sp, #28]
	if (err == -EINVAL) {
    ec62:	e038      	b.n	ecd6 <hci_cmd_handle+0x136>
	switch (ocf) {
    ec64:	2d2d      	cmp	r5, #45	; 0x2d
    ec66:	d038      	beq.n	ecda <hci_cmd_handle+0x13a>
    ec68:	d81d      	bhi.n	eca6 <hci_cmd_handle+0x106>
    ec6a:	2d01      	cmp	r5, #1
    ec6c:	d028      	beq.n	ecc0 <hci_cmd_handle+0x120>
    ec6e:	2d03      	cmp	r5, #3
    ec70:	d1d3      	bne.n	ec1a <hci_cmd_handle+0x7a>
	event_mask = DEFAULT_EVENT_MASK;
    ec72:	4b8a      	ldr	r3, [pc, #552]	; (ee9c <hci_cmd_handle+0x2fc>)
    ec74:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    ec78:	f641 71ff 	movw	r1, #8191	; 0x1fff
    ec7c:	e9c3 0100 	strd	r0, r1, [r3]
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
    ec80:	4b87      	ldr	r3, [pc, #540]	; (eea0 <hci_cmd_handle+0x300>)
    ec82:	2000      	movs	r0, #0
    ec84:	2100      	movs	r1, #0
    ec86:	e9c3 0100 	strd	r0, r1, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
    ec8a:	4b86      	ldr	r3, [pc, #536]	; (eea4 <hci_cmd_handle+0x304>)
    ec8c:	201f      	movs	r0, #31
    ec8e:	2100      	movs	r1, #0
    ec90:	e9c3 0100 	strd	r0, r1, [r3]
		ll_reset();
    ec94:	f001 f916 	bl	fec4 <ll_reset>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    ec98:	2101      	movs	r1, #1
    ec9a:	a807      	add	r0, sp, #28
    ec9c:	f7ff fe4a 	bl	e934 <hci_cmd_complete>
	ccst->status = 0x00;
    eca0:	2300      	movs	r3, #0
		ccst->status = BT_HCI_ERR_UNKNOWN_CMD;
    eca2:	7003      	strb	r3, [r0, #0]
    eca4:	e017      	b.n	ecd6 <hci_cmd_handle+0x136>
	switch (ocf) {
    eca6:	2d7b      	cmp	r5, #123	; 0x7b
    eca8:	d02a      	beq.n	ed00 <hci_cmd_handle+0x160>
    ecaa:	2d7c      	cmp	r5, #124	; 0x7c
    ecac:	d03b      	beq.n	ed26 <hci_cmd_handle+0x186>
    ecae:	2d63      	cmp	r5, #99	; 0x63
    ecb0:	d1b3      	bne.n	ec1a <hci_cmd_handle+0x7a>
	event_mask_page_2 = sys_get_le64(cmd->events_page_2);
    ecb2:	68a0      	ldr	r0, [r4, #8]
    ecb4:	f00e faa5 	bl	1d202 <sys_get_le64>
    ecb8:	4b79      	ldr	r3, [pc, #484]	; (eea0 <hci_cmd_handle+0x300>)
	le_event_mask = sys_get_le64(cmd->events);
    ecba:	e9c3 0100 	strd	r0, r1, [r3]
    ecbe:	e7eb      	b.n	ec98 <hci_cmd_handle+0xf8>
	event_mask = sys_get_le64(cmd->events);
    ecc0:	68a0      	ldr	r0, [r4, #8]
    ecc2:	f00e fa9e 	bl	1d202 <sys_get_le64>
    ecc6:	4b75      	ldr	r3, [pc, #468]	; (ee9c <hci_cmd_handle+0x2fc>)
    ecc8:	e9c3 0100 	strd	r0, r1, [r3]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    eccc:	4629      	mov	r1, r5
    ecce:	a807      	add	r0, sp, #28
    ecd0:	f7ff fe30 	bl	e934 <hci_cmd_complete>
	ccst->status = 0x00;
    ecd4:	7006      	strb	r6, [r0, #0]
	return evt;
    ecd6:	9807      	ldr	r0, [sp, #28]
    ecd8:	e779      	b.n	ebce <hci_cmd_handle+0x2e>
		read_tx_power_level(cmd, evt);
    ecda:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ecdc:	2104      	movs	r1, #4
    ecde:	a807      	add	r0, sp, #28
	handle = sys_le16_to_cpu(cmd->handle);
    ece0:	881d      	ldrh	r5, [r3, #0]
	type = cmd->type;
    ece2:	789f      	ldrb	r7, [r3, #2]
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ece4:	f7ff fe26 	bl	e934 <hci_cmd_complete>
	handle = sys_le16_to_cpu(cmd->handle);
    ece8:	b2ae      	uxth	r6, r5
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ecea:	4604      	mov	r4, r0
	status = ll_tx_pwr_lvl_get(BT_HCI_VS_LL_HANDLE_TYPE_CONN,
    ecec:	1cc3      	adds	r3, r0, #3
    ecee:	463a      	mov	r2, r7
    ecf0:	4631      	mov	r1, r6
    ecf2:	2002      	movs	r0, #2
    ecf4:	f00e fa69 	bl	1d1ca <ll_tx_pwr_lvl_get>
	rp->status = status;
    ecf8:	7020      	strb	r0, [r4, #0]
	rp->handle = sys_le16_to_cpu(handle);
    ecfa:	f8a4 5001 	strh.w	r5, [r4, #1]
	if (err == -EINVAL) {
    ecfe:	e7ea      	b.n	ecd6 <hci_cmd_handle+0x136>
	handle = sys_le16_to_cpu(cmd->handle);
    ed00:	68a3      	ldr	r3, [r4, #8]
    ed02:	881c      	ldrh	r4, [r3, #0]
	status = ll_apto_get(handle, &auth_payload_timeout);
    ed04:	a908      	add	r1, sp, #32
    ed06:	4620      	mov	r0, r4
    ed08:	f00e fdd8 	bl	1d8bc <ll_apto_get>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ed0c:	2105      	movs	r1, #5
	status = ll_apto_get(handle, &auth_payload_timeout);
    ed0e:	4605      	mov	r5, r0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ed10:	a807      	add	r0, sp, #28
    ed12:	f7ff fe0f 	bl	e934 <hci_cmd_complete>
	rp->status = status;
    ed16:	7005      	strb	r5, [r0, #0]
	rp->handle = sys_cpu_to_le16(handle);
    ed18:	f8a0 4001 	strh.w	r4, [r0, #1]
	rp->auth_payload_timeout = sys_cpu_to_le16(auth_payload_timeout);
    ed1c:	f8bd 3020 	ldrh.w	r3, [sp, #32]
    ed20:	f8a0 3003 	strh.w	r3, [r0, #3]
    ed24:	e7d7      	b.n	ecd6 <hci_cmd_handle+0x136>
		write_auth_payload_timeout(cmd, evt);
    ed26:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
    ed28:	881c      	ldrh	r4, [r3, #0]
	status = ll_apto_set(handle, auth_payload_timeout);
    ed2a:	8859      	ldrh	r1, [r3, #2]
    ed2c:	4620      	mov	r0, r4
    ed2e:	f00e fdd9 	bl	1d8e4 <ll_apto_set>
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
    ed32:	4605      	mov	r5, r0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ed34:	2103      	movs	r1, #3
    ed36:	a807      	add	r0, sp, #28
    ed38:	f7ff fdfc 	bl	e934 <hci_cmd_complete>
	rp->status = status;
    ed3c:	7005      	strb	r5, [r0, #0]
	rp->handle = sys_cpu_to_le16(handle);
    ed3e:	f8a0 4001 	strh.w	r4, [r0, #1]
	if (err == -EINVAL) {
    ed42:	e7c8      	b.n	ecd6 <hci_cmd_handle+0x136>
	switch (ocf) {
    ed44:	3d01      	subs	r5, #1
    ed46:	2d08      	cmp	r5, #8
    ed48:	f63f af67 	bhi.w	ec1a <hci_cmd_handle+0x7a>
    ed4c:	a301      	add	r3, pc, #4	; (adr r3, ed54 <hci_cmd_handle+0x1b4>)
    ed4e:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
    ed52:	bf00      	nop
    ed54:	0000ed79 	.word	0x0000ed79
    ed58:	0000eda3 	.word	0x0000eda3
    ed5c:	0000ee53 	.word	0x0000ee53
    ed60:	0000ec1b 	.word	0x0000ec1b
    ed64:	0000ec1b 	.word	0x0000ec1b
    ed68:	0000ec1b 	.word	0x0000ec1b
    ed6c:	0000ec1b 	.word	0x0000ec1b
    ed70:	0000ec1b 	.word	0x0000ec1b
    ed74:	0000ee6f 	.word	0x0000ee6f
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ed78:	2109      	movs	r1, #9
    ed7a:	a807      	add	r0, sp, #28
    ed7c:	f7ff fdda 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    ed80:	2300      	movs	r3, #0
    ed82:	7003      	strb	r3, [r0, #0]
	rp->hci_revision = sys_cpu_to_le16(0);
    ed84:	7083      	strb	r3, [r0, #2]
    ed86:	70c3      	strb	r3, [r0, #3]
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
    ed88:	f06f 030e 	mvn.w	r3, #14
    ed8c:	7143      	strb	r3, [r0, #5]
    ed8e:	2305      	movs	r3, #5
	rp->hci_version = LL_VERSION_NUMBER;
    ed90:	220a      	movs	r2, #10
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
    ed92:	7183      	strb	r3, [r0, #6]
	rp->lmp_subversion = sys_cpu_to_le16(ll_settings_subversion_number());
    ed94:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	rp->hci_version = LL_VERSION_NUMBER;
    ed98:	7042      	strb	r2, [r0, #1]
	rp->lmp_version = LL_VERSION_NUMBER;
    ed9a:	7102      	strb	r2, [r0, #4]
	rp->lmp_subversion = sys_cpu_to_le16(ll_settings_subversion_number());
    ed9c:	71c3      	strb	r3, [r0, #7]
    ed9e:	7203      	strb	r3, [r0, #8]
	if (err == -EINVAL) {
    eda0:	e799      	b.n	ecd6 <hci_cmd_handle+0x136>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    eda2:	2141      	movs	r1, #65	; 0x41
    eda4:	a807      	add	r0, sp, #28
    eda6:	f7ff fdc5 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    edaa:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    edac:	4604      	mov	r4, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
    edae:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
    edb0:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
    edb4:	f00c f94b 	bl	1b04e <memset>
	rp->commands[5] |= BIT(6) | BIT(7);
    edb8:	79a3      	ldrb	r3, [r4, #6]
	rp->commands[28] |= BIT(3);
    edba:	7f62      	ldrb	r2, [r4, #29]
	rp->commands[26] |= BIT(6) | BIT(7);
    edbc:	7ee1      	ldrb	r1, [r4, #27]
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
    edbe:	7ea0      	ldrb	r0, [r4, #26]
	rp->commands[5] |= BIT(6) | BIT(7);
    edc0:	f063 033f 	orn	r3, r3, #63	; 0x3f
    edc4:	71a3      	strb	r3, [r4, #6]
	rp->commands[10] |= BIT(2);
    edc6:	7ae3      	ldrb	r3, [r4, #11]
    edc8:	f043 0304 	orr.w	r3, r3, #4
    edcc:	72e3      	strb	r3, [r4, #11]
	rp->commands[14] |= BIT(3) | BIT(5);
    edce:	7be3      	ldrb	r3, [r4, #15]
    edd0:	f043 0328 	orr.w	r3, r3, #40	; 0x28
    edd4:	73e3      	strb	r3, [r4, #15]
	rp->commands[15] |= BIT(1);
    edd6:	7c23      	ldrb	r3, [r4, #16]
    edd8:	f043 0302 	orr.w	r3, r3, #2
    eddc:	7423      	strb	r3, [r4, #16]
	rp->commands[22] |= BIT(2);
    edde:	7de3      	ldrb	r3, [r4, #23]
    ede0:	f043 0304 	orr.w	r3, r3, #4
    ede4:	75e3      	strb	r3, [r4, #23]
	rp->commands[27] |= BIT(0) | BIT(1);
    ede6:	7f23      	ldrb	r3, [r4, #28]
	rp->commands[27] |= BIT(2) | BIT(4) | BIT(5);
    ede8:	f063 0308 	orn	r3, r3, #8
    edec:	7723      	strb	r3, [r4, #28]
	rp->commands[33] |= BIT(4) | BIT(5);
    edee:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
	rp->commands[28] |= BIT(1) | BIT(2);
    edf2:	f042 020e 	orr.w	r2, r2, #14
	rp->commands[33] |= BIT(6) | BIT(7);
    edf6:	f063 030f 	orn	r3, r3, #15
	rp->commands[28] |= BIT(1) | BIT(2);
    edfa:	7762      	strb	r2, [r4, #29]
	rp->commands[33] |= BIT(6) | BIT(7);
    edfc:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	rp->commands[0] |= BIT(5);
    ee00:	7862      	ldrb	r2, [r4, #1]
	rp->commands[35] |= BIT(3);
    ee02:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
	rp->commands[0] |= BIT(5);
    ee06:	f042 0220 	orr.w	r2, r2, #32
	rp->commands[35] |= BIT(0) | BIT(1) | BIT(2);
    ee0a:	f043 037f 	orr.w	r3, r3, #127	; 0x7f
	rp->commands[0] |= BIT(5);
    ee0e:	7062      	strb	r2, [r4, #1]
	rp->commands[35] |= BIT(0) | BIT(1) | BIT(2);
    ee10:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
	rp->commands[32] |= BIT(4) | BIT(5);
    ee14:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
	rp->commands[39] |= BIT(2);
    ee18:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
	rp->commands[32] |= BIT(4) | BIT(5);
    ee1c:	f042 0230 	orr.w	r2, r2, #48	; 0x30
	rp->commands[39] |= BIT(2);
    ee20:	f043 0304 	orr.w	r3, r3, #4
	rp->commands[32] |= BIT(4) | BIT(5);
    ee24:	f884 2021 	strb.w	r2, [r4, #33]	; 0x21
	rp->commands[39] |= BIT(2);
    ee28:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	rp->commands[34] |= BIT(3) | BIT(4) | BIT(5) | BIT(6) | BIT(7);
    ee2c:	f894 2023 	ldrb.w	r2, [r4, #35]	; 0x23
	rp->commands[38] |= BIT(7);
    ee30:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
    ee34:	f060 0008 	orn	r0, r0, #8
	rp->commands[26] |= BIT(0) | BIT(1);
    ee38:	f061 013c 	orn	r1, r1, #60	; 0x3c
	rp->commands[34] |= BIT(3) | BIT(4) | BIT(5) | BIT(6) | BIT(7);
    ee3c:	f062 0206 	orn	r2, r2, #6
	rp->commands[38] |= BIT(7);
    ee40:	f063 037f 	orn	r3, r3, #127	; 0x7f
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
    ee44:	76a0      	strb	r0, [r4, #26]
	rp->commands[26] |= BIT(0) | BIT(1);
    ee46:	76e1      	strb	r1, [r4, #27]
	rp->commands[34] |= BIT(3) | BIT(4) | BIT(5) | BIT(6) | BIT(7);
    ee48:	f884 2023 	strb.w	r2, [r4, #35]	; 0x23
	rp->commands[38] |= BIT(7);
    ee4c:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
	if (err == -EINVAL) {
    ee50:	e741      	b.n	ecd6 <hci_cmd_handle+0x136>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ee52:	2109      	movs	r1, #9
    ee54:	a807      	add	r0, sp, #28
    ee56:	f7ff fd6d 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    ee5a:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ee5c:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    ee5e:	2208      	movs	r2, #8
	rp->status = 0x00;
    ee60:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    ee64:	f00c f8f3 	bl	1b04e <memset>
	rp->features[4] = (1 << 5) | (1 << 6);
    ee68:	2360      	movs	r3, #96	; 0x60
    ee6a:	7163      	strb	r3, [r4, #5]
	if (err == -EINVAL) {
    ee6c:	e733      	b.n	ecd6 <hci_cmd_handle+0x136>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ee6e:	2107      	movs	r1, #7
    ee70:	a807      	add	r0, sp, #28
    ee72:	f7ff fd5f 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    ee76:	4601      	mov	r1, r0
    ee78:	2300      	movs	r3, #0
    ee7a:	f801 3b01 	strb.w	r3, [r1], #1
	ll_addr_get(0, &rp->bdaddr.val[0]);
    ee7e:	4618      	mov	r0, r3
    ee80:	f7ff fb76 	bl	e570 <ll_addr_get>
	if (err == -EINVAL) {
    ee84:	e727      	b.n	ecd6 <hci_cmd_handle+0x136>
    ee86:	bf00      	nop
    ee88:	0001ed28 	.word	0x0001ed28
    ee8c:	0001ed68 	.word	0x0001ed68
    ee90:	00021a41 	.word	0x00021a41
    ee94:	00021a57 	.word	0x00021a57
    ee98:	20001b08 	.word	0x20001b08
    ee9c:	20005588 	.word	0x20005588
    eea0:	20000000 	.word	0x20000000
    eea4:	20005590 	.word	0x20005590
	switch (ocf) {
    eea8:	3d01      	subs	r5, #1
    eeaa:	2d4d      	cmp	r5, #77	; 0x4d
    eeac:	f63f aeb5 	bhi.w	ec1a <hci_cmd_handle+0x7a>
    eeb0:	a301      	add	r3, pc, #4	; (adr r3, eeb8 <hci_cmd_handle+0x318>)
    eeb2:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
    eeb6:	bf00      	nop
    eeb8:	0000eff1 	.word	0x0000eff1
    eebc:	0000effb 	.word	0x0000effb
    eec0:	0000f013 	.word	0x0000f013
    eec4:	0000ec1b 	.word	0x0000ec1b
    eec8:	0000f037 	.word	0x0000f037
    eecc:	0000f0e5 	.word	0x0000f0e5
    eed0:	0000f101 	.word	0x0000f101
    eed4:	0000f111 	.word	0x0000f111
    eed8:	0000f11d 	.word	0x0000f11d
    eedc:	0000f129 	.word	0x0000f129
    eee0:	0000ec1b 	.word	0x0000ec1b
    eee4:	0000ec1b 	.word	0x0000ec1b
    eee8:	0000ec1b 	.word	0x0000ec1b
    eeec:	0000ec1b 	.word	0x0000ec1b
    eef0:	0000f04d 	.word	0x0000f04d
    eef4:	0000f063 	.word	0x0000f063
    eef8:	0000f075 	.word	0x0000f075
    eefc:	0000f07d 	.word	0x0000f07d
    ef00:	0000f171 	.word	0x0000f171
    ef04:	0000ec1b 	.word	0x0000ec1b
    ef08:	0000f14d 	.word	0x0000f14d
    ef0c:	0000f167 	.word	0x0000f167
    ef10:	0000f085 	.word	0x0000f085
    ef14:	0000f0ab 	.word	0x0000f0ab
    ef18:	0000ec1b 	.word	0x0000ec1b
    ef1c:	0000f133 	.word	0x0000f133
    ef20:	0000f143 	.word	0x0000f143
    ef24:	0000f0c1 	.word	0x0000f0c1
    ef28:	0000ec1b 	.word	0x0000ec1b
    ef2c:	0000ec1b 	.word	0x0000ec1b
    ef30:	0000ec1b 	.word	0x0000ec1b
    ef34:	0000f18d 	.word	0x0000f18d
    ef38:	0000f1ab 	.word	0x0000f1ab
    ef3c:	0000f1bb 	.word	0x0000f1bb
    ef40:	0000f1cb 	.word	0x0000f1cb
    ef44:	0000f1f5 	.word	0x0000f1f5
    ef48:	0000ec1b 	.word	0x0000ec1b
    ef4c:	0000ec1b 	.word	0x0000ec1b
    ef50:	0000f2eb 	.word	0x0000f2eb
    ef54:	0000f301 	.word	0x0000f301
    ef58:	0000f309 	.word	0x0000f309
    ef5c:	0000f319 	.word	0x0000f319
    ef60:	0000f32b 	.word	0x0000f32b
    ef64:	0000f349 	.word	0x0000f349
    ef68:	0000f367 	.word	0x0000f367
    ef6c:	0000f37d 	.word	0x0000f37d
    ef70:	0000f201 	.word	0x0000f201
    ef74:	0000f229 	.word	0x0000f229
    ef78:	0000f277 	.word	0x0000f277
    ef7c:	0000f295 	.word	0x0000f295
    ef80:	0000ec1b 	.word	0x0000ec1b
    ef84:	0000ec1b 	.word	0x0000ec1b
    ef88:	0000ec1b 	.word	0x0000ec1b
    ef8c:	0000ec1b 	.word	0x0000ec1b
    ef90:	0000ec1b 	.word	0x0000ec1b
    ef94:	0000ec1b 	.word	0x0000ec1b
    ef98:	0000ec1b 	.word	0x0000ec1b
    ef9c:	0000ec1b 	.word	0x0000ec1b
    efa0:	0000ec1b 	.word	0x0000ec1b
    efa4:	0000ec1b 	.word	0x0000ec1b
    efa8:	0000ec1b 	.word	0x0000ec1b
    efac:	0000ec1b 	.word	0x0000ec1b
    efb0:	0000ec1b 	.word	0x0000ec1b
    efb4:	0000ec1b 	.word	0x0000ec1b
    efb8:	0000ec1b 	.word	0x0000ec1b
    efbc:	0000ec1b 	.word	0x0000ec1b
    efc0:	0000ec1b 	.word	0x0000ec1b
    efc4:	0000ec1b 	.word	0x0000ec1b
    efc8:	0000ec1b 	.word	0x0000ec1b
    efcc:	0000ec1b 	.word	0x0000ec1b
    efd0:	0000ec1b 	.word	0x0000ec1b
    efd4:	0000ec1b 	.word	0x0000ec1b
    efd8:	0000ec1b 	.word	0x0000ec1b
    efdc:	0000ec1b 	.word	0x0000ec1b
    efe0:	0000f391 	.word	0x0000f391
    efe4:	0000ec1b 	.word	0x0000ec1b
    efe8:	0000ec1b 	.word	0x0000ec1b
    efec:	0000f387 	.word	0x0000f387
	le_event_mask = sys_get_le64(cmd->events);
    eff0:	68a0      	ldr	r0, [r4, #8]
    eff2:	f00e f906 	bl	1d202 <sys_get_le64>
    eff6:	4bc0      	ldr	r3, [pc, #768]	; (f2f8 <hci_cmd_handle+0x758>)
    eff8:	e65f      	b.n	ecba <hci_cmd_handle+0x11a>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    effa:	2104      	movs	r1, #4
    effc:	a807      	add	r0, sp, #28
    effe:	f7ff fc99 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    f002:	2300      	movs	r3, #0
    f004:	7003      	strb	r3, [r0, #0]
	rp->le_max_len = sys_cpu_to_le16(CONFIG_BT_CTLR_TX_BUFFER_SIZE);
    f006:	221b      	movs	r2, #27
    f008:	7083      	strb	r3, [r0, #2]
	rp->le_max_num = CONFIG_BT_CTLR_TX_BUFFERS;
    f00a:	2303      	movs	r3, #3
	rp->le_max_len = sys_cpu_to_le16(CONFIG_BT_CTLR_TX_BUFFER_SIZE);
    f00c:	7042      	strb	r2, [r0, #1]
	rp->le_max_num = CONFIG_BT_CTLR_TX_BUFFERS;
    f00e:	70c3      	strb	r3, [r0, #3]
	if (err == -EINVAL) {
    f010:	e661      	b.n	ecd6 <hci_cmd_handle+0x136>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f012:	2109      	movs	r1, #9
    f014:	a807      	add	r0, sp, #28
    f016:	f7ff fc8d 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    f01a:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f01c:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    f01e:	2208      	movs	r2, #8
	rp->status = 0x00;
    f020:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    f024:	f00c f813 	bl	1b04e <memset>
	dst[0] = val;
    f028:	237f      	movs	r3, #127	; 0x7f
    f02a:	7063      	strb	r3, [r4, #1]
	dst[1] = val >> 8;
    f02c:	2341      	movs	r3, #65	; 0x41
    f02e:	70a3      	strb	r3, [r4, #2]
	dst[2] = val >> 16;
    f030:	2301      	movs	r3, #1
    f032:	70e3      	strb	r3, [r4, #3]
	if (err == -EINVAL) {
    f034:	e64f      	b.n	ecd6 <hci_cmd_handle+0x136>
	status = ll_addr_set(1, &cmd->bdaddr.val[0]);
    f036:	68a1      	ldr	r1, [r4, #8]
    f038:	2001      	movs	r0, #1
    f03a:	f7ff fab3 	bl	e5a4 <ll_addr_set>
	status = ll_wl_add(&cmd->addr);
    f03e:	4604      	mov	r4, r0
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    f040:	2101      	movs	r1, #1
    f042:	a807      	add	r0, sp, #28
    f044:	f7ff fc76 	bl	e934 <hci_cmd_complete>
	ccst->status = status;
    f048:	7004      	strb	r4, [r0, #0]
	if (err == -EINVAL) {
    f04a:	e644      	b.n	ecd6 <hci_cmd_handle+0x136>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f04c:	2102      	movs	r1, #2
    f04e:	a807      	add	r0, sp, #28
    f050:	f7ff fc70 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    f054:	2300      	movs	r3, #0
    f056:	7003      	strb	r3, [r0, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f058:	4604      	mov	r4, r0
	rp->wl_size = ll_wl_size_get();
    f05a:	f00e fd73 	bl	1db44 <ll_wl_size_get>
    f05e:	7060      	strb	r0, [r4, #1]
	if (err == -EINVAL) {
    f060:	e639      	b.n	ecd6 <hci_cmd_handle+0x136>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    f062:	2101      	movs	r1, #1
    f064:	a807      	add	r0, sp, #28
    f066:	f7ff fc65 	bl	e934 <hci_cmd_complete>
    f06a:	4604      	mov	r4, r0
	ccst->status = ll_wl_clear();
    f06c:	f005 fe5a 	bl	14d24 <ll_wl_clear>
	ccst->status = ll_rl_clear();
    f070:	7020      	strb	r0, [r4, #0]
	if (err == -EINVAL) {
    f072:	e630      	b.n	ecd6 <hci_cmd_handle+0x136>
	status = ll_wl_add(&cmd->addr);
    f074:	68a0      	ldr	r0, [r4, #8]
    f076:	f006 f81b 	bl	150b0 <ll_wl_add>
    f07a:	e7e0      	b.n	f03e <hci_cmd_handle+0x49e>
	status = ll_wl_remove(&cmd->addr);
    f07c:	68a0      	ldr	r0, [r4, #8]
    f07e:	f005 fe89 	bl	14d94 <ll_wl_remove>
    f082:	e7dc      	b.n	f03e <hci_cmd_handle+0x49e>
		le_encrypt(cmd, evt);
    f084:	68a0      	ldr	r0, [r4, #8]
	ecb_encrypt(cmd->key, cmd->plaintext, enc_data, NULL);
    f086:	aa08      	add	r2, sp, #32
    f088:	2300      	movs	r3, #0
    f08a:	f100 0110 	add.w	r1, r0, #16
    f08e:	f00e fd5d 	bl	1db4c <ecb_encrypt>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f092:	2111      	movs	r1, #17
    f094:	a807      	add	r0, sp, #28
    f096:	f7ff fc4d 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    f09a:	2300      	movs	r3, #0
    f09c:	f800 3b01 	strb.w	r3, [r0], #1
	memcpy(rp->enc_data, enc_data, 16);
    f0a0:	2210      	movs	r2, #16
    f0a2:	a908      	add	r1, sp, #32
    f0a4:	f00b ffa9 	bl	1affa <memcpy>
	if (err == -EINVAL) {
    f0a8:	e615      	b.n	ecd6 <hci_cmd_handle+0x136>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f0aa:	2109      	movs	r1, #9
    f0ac:	a807      	add	r0, sp, #28
    f0ae:	f7ff fc41 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    f0b2:	2300      	movs	r3, #0
    f0b4:	f800 3b01 	strb.w	r3, [r0], #1
	bt_rand(rp->rand, count);
    f0b8:	2108      	movs	r1, #8
    f0ba:	f000 fcd1 	bl	fa60 <bt_rand>
	if (err == -EINVAL) {
    f0be:	e60a      	b.n	ecd6 <hci_cmd_handle+0x136>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f0c0:	2109      	movs	r1, #9
    f0c2:	a807      	add	r0, sp, #28
    f0c4:	f7ff fc36 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    f0c8:	4601      	mov	r1, r0
    f0ca:	2300      	movs	r3, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f0cc:	4602      	mov	r2, r0
	rp->status = 0x00;
    f0ce:	f801 3b01 	strb.w	r3, [r1], #1
	sys_put_le32(val, dst);
    f0d2:	488a      	ldr	r0, [pc, #552]	; (f2fc <hci_cmd_handle+0x75c>)
    f0d4:	f00e f88c 	bl	1d1f0 <sys_put_le32>
	sys_put_le32(val >> 32, &dst[4]);
    f0d8:	f44f 70e0 	mov.w	r0, #448	; 0x1c0
    f0dc:	1d51      	adds	r1, r2, #5
    f0de:	f00e f887 	bl	1d1f0 <sys_put_le32>
	if (err == -EINVAL) {
    f0e2:	e5f8      	b.n	ecd6 <hci_cmd_handle+0x136>
		le_set_adv_param(cmd, evt);
    f0e4:	68a4      	ldr	r4, [r4, #8]
	status = ll_adv_params_set(min_interval, cmd->type,
    f0e6:	7ba5      	ldrb	r5, [r4, #14]
    f0e8:	79a3      	ldrb	r3, [r4, #6]
    f0ea:	7962      	ldrb	r2, [r4, #5]
    f0ec:	7921      	ldrb	r1, [r4, #4]
    f0ee:	8820      	ldrh	r0, [r4, #0]
    f0f0:	9502      	str	r5, [sp, #8]
    f0f2:	7b65      	ldrb	r5, [r4, #13]
    f0f4:	9501      	str	r5, [sp, #4]
				   &cmd->direct_addr.a.val[0], cmd->channel_map,
    f0f6:	3407      	adds	r4, #7
	status = ll_adv_params_set(min_interval, cmd->type,
    f0f8:	9400      	str	r4, [sp, #0]
    f0fa:	f002 f8e1 	bl	112c0 <ll_adv_params_set>
    f0fe:	e79e      	b.n	f03e <hci_cmd_handle+0x49e>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f100:	2102      	movs	r1, #2
    f102:	a807      	add	r0, sp, #28
    f104:	f7ff fc16 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    f108:	2300      	movs	r3, #0
    f10a:	7003      	strb	r3, [r0, #0]
	rp->tx_power_level = 0;
    f10c:	7043      	strb	r3, [r0, #1]
	if (err == -EINVAL) {
    f10e:	e5e2      	b.n	ecd6 <hci_cmd_handle+0x136>
	status = ll_adv_data_set(cmd->len, &cmd->data[0]);
    f110:	68a1      	ldr	r1, [r4, #8]
    f112:	f811 0b01 	ldrb.w	r0, [r1], #1
    f116:	f002 f963 	bl	113e0 <ll_adv_data_set>
    f11a:	e790      	b.n	f03e <hci_cmd_handle+0x49e>
	status = ll_adv_scan_rsp_set(cmd->len, &cmd->data[0]);
    f11c:	68a1      	ldr	r1, [r4, #8]
    f11e:	f811 0b01 	ldrb.w	r0, [r1], #1
    f122:	f002 f9b5 	bl	11490 <ll_adv_scan_rsp_set>
    f126:	e78a      	b.n	f03e <hci_cmd_handle+0x49e>
	status = ll_adv_enable(cmd->enable);
    f128:	68a3      	ldr	r3, [r4, #8]
    f12a:	7818      	ldrb	r0, [r3, #0]
    f12c:	f7f1 fc20 	bl	970 <ll_adv_enable>
    f130:	e785      	b.n	f03e <hci_cmd_handle+0x49e>
	handle = sys_le16_to_cpu(cmd->handle);
    f132:	68a2      	ldr	r2, [r4, #8]
    f134:	f832 4b02 	ldrh.w	r4, [r2], #2
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
    f138:	2100      	movs	r1, #0
    f13a:	4620      	mov	r0, r4
    f13c:	f00e fcba 	bl	1dab4 <ll_start_enc_req_send>
    f140:	e5f7      	b.n	ed32 <hci_cmd_handle+0x192>
	handle = sys_le16_to_cpu(cmd->handle);
    f142:	68a3      	ldr	r3, [r4, #8]
	status = ll_start_enc_req_send(handle, BT_HCI_ERR_PIN_OR_KEY_MISSING,
    f144:	2200      	movs	r2, #0
	handle = sys_le16_to_cpu(cmd->handle);
    f146:	881c      	ldrh	r4, [r3, #0]
	status = ll_start_enc_req_send(handle, BT_HCI_ERR_PIN_OR_KEY_MISSING,
    f148:	2106      	movs	r1, #6
    f14a:	e7f6      	b.n	f13a <hci_cmd_handle+0x59a>
	handle = sys_le16_to_cpu(cmd->handle);
    f14c:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f14e:	2108      	movs	r1, #8
    f150:	a807      	add	r0, sp, #28
	handle = sys_le16_to_cpu(cmd->handle);
    f152:	881d      	ldrh	r5, [r3, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f154:	f7ff fbee 	bl	e934 <hci_cmd_complete>
	handle = sys_le16_to_cpu(cmd->handle);
    f158:	b2ae      	uxth	r6, r5
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f15a:	4604      	mov	r4, r0
	status = ll_chm_get(handle, rp->ch_map);
    f15c:	1cc1      	adds	r1, r0, #3
    f15e:	4630      	mov	r0, r6
    f160:	f00e fae0 	bl	1d724 <ll_chm_get>
    f164:	e5c8      	b.n	ecf8 <hci_cmd_handle+0x158>
	handle = sys_le16_to_cpu(cmd->handle);
    f166:	68a3      	ldr	r3, [r4, #8]
	status = ll_feature_req_send(handle);
    f168:	8818      	ldrh	r0, [r3, #0]
    f16a:	f00e fb02 	bl	1d772 <ll_feature_req_send>
    f16e:	e575      	b.n	ec5c <hci_cmd_handle+0xbc>
		le_conn_update(cmd, evt);
    f170:	68a2      	ldr	r2, [r4, #8]
	status = ll_conn_update(handle, 0, 0, conn_interval_min,
    f172:	8911      	ldrh	r1, [r2, #8]
    f174:	8853      	ldrh	r3, [r2, #2]
    f176:	8810      	ldrh	r0, [r2, #0]
    f178:	9102      	str	r1, [sp, #8]
    f17a:	88d1      	ldrh	r1, [r2, #6]
    f17c:	9101      	str	r1, [sp, #4]
    f17e:	8892      	ldrh	r2, [r2, #4]
    f180:	9200      	str	r2, [sp, #0]
    f182:	2200      	movs	r2, #0
    f184:	4611      	mov	r1, r2
    f186:	f00e fa55 	bl	1d634 <ll_conn_update>
	*evt = cmd_status(status);
    f18a:	e567      	b.n	ec5c <hci_cmd_handle+0xbc>
		le_conn_param_req_reply(cmd, evt);
    f18c:	68a2      	ldr	r2, [r4, #8]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
    f18e:	8911      	ldrh	r1, [r2, #8]
	handle = sys_le16_to_cpu(cmd->handle);
    f190:	8814      	ldrh	r4, [r2, #0]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
    f192:	8853      	ldrh	r3, [r2, #2]
    f194:	9102      	str	r1, [sp, #8]
    f196:	88d1      	ldrh	r1, [r2, #6]
    f198:	9101      	str	r1, [sp, #4]
    f19a:	8892      	ldrh	r2, [r2, #4]
    f19c:	9200      	str	r2, [sp, #0]
    f19e:	2200      	movs	r2, #0
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
    f1a0:	2102      	movs	r1, #2
    f1a2:	4620      	mov	r0, r4
    f1a4:	f00e fa46 	bl	1d634 <ll_conn_update>
    f1a8:	e5c3      	b.n	ed32 <hci_cmd_handle+0x192>
		le_conn_param_req_neg_reply(cmd, evt);
    f1aa:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
    f1ac:	881c      	ldrh	r4, [r3, #0]
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
    f1ae:	789a      	ldrb	r2, [r3, #2]
    f1b0:	2300      	movs	r3, #0
    f1b2:	e9cd 3301 	strd	r3, r3, [sp, #4]
    f1b6:	9300      	str	r3, [sp, #0]
    f1b8:	e7f2      	b.n	f1a0 <hci_cmd_handle+0x600>
		le_set_data_len(cmd, evt);
    f1ba:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
    f1bc:	881c      	ldrh	r4, [r3, #0]
	status = ll_length_req_send(handle, tx_octets, tx_time);
    f1be:	889a      	ldrh	r2, [r3, #4]
    f1c0:	8859      	ldrh	r1, [r3, #2]
    f1c2:	4620      	mov	r0, r4
    f1c4:	f00e faf7 	bl	1d7b6 <ll_length_req_send>
    f1c8:	e5b3      	b.n	ed32 <hci_cmd_handle+0x192>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f1ca:	2105      	movs	r1, #5
    f1cc:	a807      	add	r0, sp, #28
    f1ce:	f7ff fbb1 	bl	e934 <hci_cmd_complete>
	ll_length_default_get(&max_tx_octets, &max_tx_time);
    f1d2:	a908      	add	r1, sp, #32
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f1d4:	4604      	mov	r4, r0
	ll_length_default_get(&max_tx_octets, &max_tx_time);
    f1d6:	f10d 001a 	add.w	r0, sp, #26
    f1da:	f003 f90d 	bl	123f8 <ll_length_default_get>
	rp->max_tx_octets = sys_cpu_to_le16(max_tx_octets);
    f1de:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    f1e2:	f8a4 3001 	strh.w	r3, [r4, #1]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
    f1e6:	f8bd 3020 	ldrh.w	r3, [sp, #32]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
    f1ea:	f8a4 3003 	strh.w	r3, [r4, #3]
	rp->status = 0x00;
    f1ee:	2300      	movs	r3, #0
    f1f0:	7023      	strb	r3, [r4, #0]
	if (err == -EINVAL) {
    f1f2:	e570      	b.n	ecd6 <hci_cmd_handle+0x136>
		le_write_default_data_len(cmd, evt);
    f1f4:	68a3      	ldr	r3, [r4, #8]
	status = ll_length_default_set(max_tx_octets, max_tx_time);
    f1f6:	8859      	ldrh	r1, [r3, #2]
    f1f8:	8818      	ldrh	r0, [r3, #0]
    f1fa:	f003 f909 	bl	12410 <ll_length_default_set>
    f1fe:	e71e      	b.n	f03e <hci_cmd_handle+0x49e>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f200:	2109      	movs	r1, #9
    f202:	a807      	add	r0, sp, #28
    f204:	f7ff fb96 	bl	e934 <hci_cmd_complete>
	ll_length_max_get(&max_tx_octets, &max_tx_time,
    f208:	ab08      	add	r3, sp, #32
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f20a:	4604      	mov	r4, r0
	ll_length_max_get(&max_tx_octets, &max_tx_time,
    f20c:	f10d 021a 	add.w	r2, sp, #26
    f210:	a906      	add	r1, sp, #24
    f212:	f10d 0016 	add.w	r0, sp, #22
    f216:	f00e fb01 	bl	1d81c <ll_length_max_get>
	rp->max_tx_octets = sys_cpu_to_le16(max_tx_octets);
    f21a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    f21e:	f8a4 3001 	strh.w	r3, [r4, #1]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
    f222:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    f226:	e7e0      	b.n	f1ea <hci_cmd_handle+0x64a>
	handle = sys_le16_to_cpu(cmd->handle);
    f228:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f22a:	2105      	movs	r1, #5
    f22c:	a807      	add	r0, sp, #28
	handle = sys_le16_to_cpu(cmd->handle);
    f22e:	881d      	ldrh	r5, [r3, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f230:	f7ff fb80 	bl	e934 <hci_cmd_complete>
	handle = sys_le16_to_cpu(cmd->handle);
    f234:	b2ae      	uxth	r6, r5
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f236:	4604      	mov	r4, r0
	status = ll_phy_get(handle, &rp->tx_phy, &rp->rx_phy);
    f238:	1d02      	adds	r2, r0, #4
    f23a:	1cc1      	adds	r1, r0, #3
    f23c:	4630      	mov	r0, r6
    f23e:	f00e faf6 	bl	1d82e <ll_phy_get>
 * @return least significant bit set, 0 if @a op is 0
 */

static ALWAYS_INLINE unsigned int find_lsb_set(u32_t op)
{
	return __builtin_ffs(op);
    f242:	78e2      	ldrb	r2, [r4, #3]
	rp->status = status;
    f244:	7020      	strb	r0, [r4, #0]
    f246:	2a00      	cmp	r2, #0
    f248:	fa92 f3a2 	rbit	r3, r2
    f24c:	fab3 f383 	clz	r3, r3
    f250:	7922      	ldrb	r2, [r4, #4]
	rp->handle = sys_cpu_to_le16(handle);
    f252:	f8a4 5001 	strh.w	r5, [r4, #1]
    f256:	bf08      	it	eq
    f258:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
    f25c:	3301      	adds	r3, #1
	rp->tx_phy = find_lsb_set(rp->tx_phy);
    f25e:	70e3      	strb	r3, [r4, #3]
    f260:	2a00      	cmp	r2, #0
    f262:	fa92 f3a2 	rbit	r3, r2
    f266:	fab3 f383 	clz	r3, r3
    f26a:	bf08      	it	eq
    f26c:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
    f270:	3301      	adds	r3, #1
	rp->rx_phy = find_lsb_set(rp->rx_phy);
    f272:	7123      	strb	r3, [r4, #4]
	if (err == -EINVAL) {
    f274:	e52f      	b.n	ecd6 <hci_cmd_handle+0x136>
		le_set_default_phy(cmd, evt);
    f276:	68a3      	ldr	r3, [r4, #8]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
    f278:	781a      	ldrb	r2, [r3, #0]
    f27a:	07d1      	lsls	r1, r2, #31
		cmd->tx_phys = 0x07;
    f27c:	bf44      	itt	mi
    f27e:	2107      	movmi	r1, #7
    f280:	7059      	strbmi	r1, [r3, #1]
	if (cmd->all_phys & BT_HCI_LE_PHY_RX_ANY) {
    f282:	0792      	lsls	r2, r2, #30
		cmd->rx_phys = 0x07;
    f284:	bf44      	itt	mi
    f286:	2207      	movmi	r2, #7
    f288:	709a      	strbmi	r2, [r3, #2]
	status = ll_phy_default_set(cmd->tx_phys, cmd->rx_phys);
    f28a:	7899      	ldrb	r1, [r3, #2]
    f28c:	7858      	ldrb	r0, [r3, #1]
    f28e:	f003 f8c9 	bl	12424 <ll_phy_default_set>
    f292:	e6d4      	b.n	f03e <hci_cmd_handle+0x49e>
		le_set_phy(cmd, evt);
    f294:	68a3      	ldr	r3, [r4, #8]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
    f296:	7899      	ldrb	r1, [r3, #2]
	handle = sys_le16_to_cpu(cmd->handle);
    f298:	8818      	ldrh	r0, [r3, #0]
	phy_opts = sys_le16_to_cpu(cmd->phy_opts);
    f29a:	f8b3 4005 	ldrh.w	r4, [r3, #5]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
    f29e:	07cf      	lsls	r7, r1, #31
		cmd->tx_phys |= mask_phys;
    f2a0:	bf42      	ittt	mi
    f2a2:	78da      	ldrbmi	r2, [r3, #3]
    f2a4:	f042 0203 	orrmi.w	r2, r2, #3
    f2a8:	70da      	strbmi	r2, [r3, #3]
	if (cmd->all_phys & BT_HCI_LE_PHY_RX_ANY) {
    f2aa:	078e      	lsls	r6, r1, #30
		cmd->rx_phys |= mask_phys;
    f2ac:	bf48      	it	mi
    f2ae:	791a      	ldrbmi	r2, [r3, #4]
	if ((cmd->tx_phys | cmd->rx_phys) & ~mask_phys) {
    f2b0:	78d9      	ldrb	r1, [r3, #3]
		cmd->rx_phys |= mask_phys;
    f2b2:	bf44      	itt	mi
    f2b4:	f042 0203 	orrmi.w	r2, r2, #3
    f2b8:	711a      	strbmi	r2, [r3, #4]
	if ((cmd->tx_phys | cmd->rx_phys) & ~mask_phys) {
    f2ba:	791b      	ldrb	r3, [r3, #4]
    f2bc:	ea41 0203 	orr.w	r2, r1, r3
    f2c0:	f012 0ffc 	tst.w	r2, #252	; 0xfc
    f2c4:	d001      	beq.n	f2ca <hci_cmd_handle+0x72a>
		*evt = cmd_status(BT_HCI_ERR_UNSUPP_FEATURE_PARAM_VAL);
    f2c6:	2011      	movs	r0, #17
    f2c8:	e4c8      	b.n	ec5c <hci_cmd_handle+0xbc>
	if (!(cmd->tx_phys & 0x07) ||
    f2ca:	074d      	lsls	r5, r1, #29
    f2cc:	d001      	beq.n	f2d2 <hci_cmd_handle+0x732>
    f2ce:	075a      	lsls	r2, r3, #29
    f2d0:	d101      	bne.n	f2d6 <hci_cmd_handle+0x736>
		*evt = cmd_status(BT_HCI_ERR_INVALID_PARAM);
    f2d2:	2012      	movs	r0, #18
    f2d4:	e4c2      	b.n	ec5c <hci_cmd_handle+0xbc>
	if (phy_opts & 0x03) {
    f2d6:	f014 0203 	ands.w	r2, r4, #3
		phy_opts -= 1U;
    f2da:	bf1c      	itt	ne
    f2dc:	f104 34ff 	addne.w	r4, r4, #4294967295	; 0xffffffff
		phy_opts &= 1;
    f2e0:	f004 0201 	andne.w	r2, r4, #1
	status = ll_phy_req_send(handle, cmd->tx_phys, phy_opts,
    f2e4:	f00e fab7 	bl	1d856 <ll_phy_req_send>
	*evt = cmd_status(status);
    f2e8:	e4b8      	b.n	ec5c <hci_cmd_handle+0xbc>
		le_add_dev_to_rl(cmd, evt);
    f2ea:	68a0      	ldr	r0, [r4, #8]
	status = ll_rl_add(&cmd->peer_id_addr, cmd->peer_irk, cmd->local_irk);
    f2ec:	f100 0217 	add.w	r2, r0, #23
    f2f0:	1dc1      	adds	r1, r0, #7
    f2f2:	f005 ff33 	bl	1515c <ll_rl_add>
    f2f6:	e6a2      	b.n	f03e <hci_cmd_handle+0x49e>
    f2f8:	20005590 	.word	0x20005590
    f2fc:	ec30cc8f 	.word	0xec30cc8f
	status = ll_rl_remove(&cmd->peer_id_addr);
    f300:	68a0      	ldr	r0, [r4, #8]
    f302:	f005 ffcd 	bl	152a0 <ll_rl_remove>
    f306:	e69a      	b.n	f03e <hci_cmd_handle+0x49e>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    f308:	2101      	movs	r1, #1
    f30a:	a807      	add	r0, sp, #28
    f30c:	f7ff fb12 	bl	e934 <hci_cmd_complete>
    f310:	4604      	mov	r4, r0
	ccst->status = ll_rl_clear();
    f312:	f005 fdb3 	bl	14e7c <ll_rl_clear>
    f316:	e6ab      	b.n	f070 <hci_cmd_handle+0x4d0>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f318:	2102      	movs	r1, #2
    f31a:	a807      	add	r0, sp, #28
    f31c:	f7ff fb0a 	bl	e934 <hci_cmd_complete>
    f320:	4604      	mov	r4, r0
	rp->rl_size = ll_rl_size_get();
    f322:	f00e fc11 	bl	1db48 <ll_rl_size_get>
    f326:	7060      	strb	r0, [r4, #1]
    f328:	e761      	b.n	f1ee <hci_cmd_handle+0x64e>
	memcpy(dst, src, sizeof(*dst));
    f32a:	2207      	movs	r2, #7
    f32c:	68a1      	ldr	r1, [r4, #8]
    f32e:	a808      	add	r0, sp, #32
    f330:	f00b fe63 	bl	1affa <memcpy>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f334:	2107      	movs	r1, #7
    f336:	a807      	add	r0, sp, #28
    f338:	f7ff fafc 	bl	e934 <hci_cmd_complete>
    f33c:	4604      	mov	r4, r0
	rp->status = ll_rl_crpa_get(&peer_id_addr, &rp->peer_rpa);
    f33e:	1c41      	adds	r1, r0, #1
    f340:	a808      	add	r0, sp, #32
    f342:	f006 f83d 	bl	153c0 <ll_rl_crpa_get>
    f346:	e693      	b.n	f070 <hci_cmd_handle+0x4d0>
    f348:	2207      	movs	r2, #7
    f34a:	68a1      	ldr	r1, [r4, #8]
    f34c:	a808      	add	r0, sp, #32
    f34e:	f00b fe54 	bl	1affa <memcpy>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f352:	2107      	movs	r1, #7
    f354:	a807      	add	r0, sp, #28
    f356:	f7ff faed 	bl	e934 <hci_cmd_complete>
    f35a:	4604      	mov	r4, r0
	rp->status = ll_rl_lrpa_get(&peer_id_addr, &rp->local_rpa);
    f35c:	1c41      	adds	r1, r0, #1
    f35e:	a808      	add	r0, sp, #32
    f360:	f006 f850 	bl	15404 <ll_rl_lrpa_get>
    f364:	e684      	b.n	f070 <hci_cmd_handle+0x4d0>
	u8_t enable = cmd->enable;
    f366:	68a3      	ldr	r3, [r4, #8]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    f368:	2101      	movs	r1, #1
    f36a:	a807      	add	r0, sp, #28
	u8_t enable = cmd->enable;
    f36c:	781d      	ldrb	r5, [r3, #0]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    f36e:	f7ff fae1 	bl	e934 <hci_cmd_complete>
    f372:	4604      	mov	r4, r0
	ccst->status = ll_rl_enable(enable);
    f374:	4628      	mov	r0, r5
    f376:	f005 fdbf 	bl	14ef8 <ll_rl_enable>
    f37a:	e679      	b.n	f070 <hci_cmd_handle+0x4d0>
	u16_t timeout = sys_le16_to_cpu(cmd->rpa_timeout);
    f37c:	68a3      	ldr	r3, [r4, #8]
	ll_rl_timeout_set(timeout);
    f37e:	8818      	ldrh	r0, [r3, #0]
    f380:	f005 fdd2 	bl	14f28 <ll_rl_timeout_set>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    f384:	e488      	b.n	ec98 <hci_cmd_handle+0xf8>
		le_set_privacy_mode(cmd, evt);
    f386:	68a0      	ldr	r0, [r4, #8]
	status = ll_priv_mode_set(&cmd->id_addr, cmd->mode);
    f388:	79c1      	ldrb	r1, [r0, #7]
    f38a:	f006 f855 	bl	15438 <ll_priv_mode_set>
    f38e:	e656      	b.n	f03e <hci_cmd_handle+0x49e>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    f390:	2103      	movs	r1, #3
    f392:	a807      	add	r0, sp, #28
    f394:	f7ff face 	bl	e934 <hci_cmd_complete>
	rp->status = 0x00;
    f398:	4601      	mov	r1, r0
    f39a:	2300      	movs	r3, #0
    f39c:	f801 3b02 	strb.w	r3, [r1], #2
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
    f3a0:	3001      	adds	r0, #1
    f3a2:	f00d ff21 	bl	1d1e8 <ll_tx_pwr_get>
	if (err == -EINVAL) {
    f3a6:	e496      	b.n	ecd6 <hci_cmd_handle+0x136>

0000f3a8 <hci_acl_handle>:
{
    f3a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	*evt = NULL;
    f3ac:	2300      	movs	r3, #0
    f3ae:	600b      	str	r3, [r1, #0]
	if (buf->len < sizeof(*acl)) {
    f3b0:	8983      	ldrh	r3, [r0, #12]
    f3b2:	2b03      	cmp	r3, #3
{
    f3b4:	4605      	mov	r5, r0
    f3b6:	4688      	mov	r8, r1
	if (buf->len < sizeof(*acl)) {
    f3b8:	d810      	bhi.n	f3dc <hci_acl_handle+0x34>
		BT_ERR("No HCI ACL header");
    f3ba:	2301      	movs	r3, #1
    f3bc:	f04f 0100 	mov.w	r1, #0
    f3c0:	f363 0107 	bfi	r1, r3, #0, #8
    f3c4:	4a40      	ldr	r2, [pc, #256]	; (f4c8 <hci_acl_handle+0x120>)
    f3c6:	4b41      	ldr	r3, [pc, #260]	; (f4cc <hci_acl_handle+0x124>)
    f3c8:	4841      	ldr	r0, [pc, #260]	; (f4d0 <hci_acl_handle+0x128>)
    f3ca:	1a9b      	subs	r3, r3, r2
    f3cc:	08db      	lsrs	r3, r3, #3
    f3ce:	f363 118f 	bfi	r1, r3, #6, #10
		BT_ERR("Invalid HCI ACL packet length");
    f3d2:	f00b f91e 	bl	1a612 <log_0>
		return -EINVAL;
    f3d6:	f06f 0015 	mvn.w	r0, #21
    f3da:	e046      	b.n	f46a <hci_acl_handle+0xc2>
	acl = net_buf_pull_mem(buf, sizeof(*acl));
    f3dc:	2104      	movs	r1, #4
    f3de:	3008      	adds	r0, #8
    f3e0:	f00e fc65 	bl	1dcae <net_buf_simple_pull_mem>
	if (buf->len < len) {
    f3e4:	89ab      	ldrh	r3, [r5, #12]
	len = sys_le16_to_cpu(acl->len);
    f3e6:	8847      	ldrh	r7, [r0, #2]
	handle = sys_le16_to_cpu(acl->handle);
    f3e8:	f8b0 9000 	ldrh.w	r9, [r0]
	if (buf->len < len) {
    f3ec:	42bb      	cmp	r3, r7
    f3ee:	d20c      	bcs.n	f40a <hci_acl_handle+0x62>
		BT_ERR("Invalid HCI ACL packet length");
    f3f0:	2301      	movs	r3, #1
    f3f2:	f04f 0100 	mov.w	r1, #0
    f3f6:	f363 0107 	bfi	r1, r3, #0, #8
    f3fa:	4a33      	ldr	r2, [pc, #204]	; (f4c8 <hci_acl_handle+0x120>)
    f3fc:	4b33      	ldr	r3, [pc, #204]	; (f4cc <hci_acl_handle+0x124>)
    f3fe:	4835      	ldr	r0, [pc, #212]	; (f4d4 <hci_acl_handle+0x12c>)
    f400:	1a9b      	subs	r3, r3, r2
    f402:	08db      	lsrs	r3, r3, #3
    f404:	f363 118f 	bfi	r1, r3, #6, #10
    f408:	e7e3      	b.n	f3d2 <hci_acl_handle+0x2a>
	node_tx = ll_tx_mem_acquire();
    f40a:	f002 ff85 	bl	12318 <ll_tx_mem_acquire>
	flags = bt_acl_flags(handle);
    f40e:	ea4f 3619 	mov.w	r6, r9, lsr #12
	if (!node_tx) {
    f412:	4604      	mov	r4, r0
    f414:	bb58      	cbnz	r0, f46e <hci_acl_handle+0xc6>
		BT_ERR("Tx Buffer Overflow");
    f416:	2301      	movs	r3, #1
    f418:	f04f 0100 	mov.w	r1, #0
    f41c:	4a2a      	ldr	r2, [pc, #168]	; (f4c8 <hci_acl_handle+0x120>)
    f41e:	482e      	ldr	r0, [pc, #184]	; (f4d8 <hci_acl_handle+0x130>)
    f420:	f363 0107 	bfi	r1, r3, #0, #8
    f424:	4b29      	ldr	r3, [pc, #164]	; (f4cc <hci_acl_handle+0x124>)
    f426:	1a9b      	subs	r3, r3, r2
    f428:	08db      	lsrs	r3, r3, #3
    f42a:	f363 118f 	bfi	r1, r3, #6, #10
    f42e:	f00b f8f0 	bl	1a612 <log_0>
	if (!(event_mask & BT_EVT_MASK_DATA_BUFFER_OVERFLOW)) {
    f432:	4b2a      	ldr	r3, [pc, #168]	; (f4dc <hci_acl_handle+0x134>)
    f434:	6819      	ldr	r1, [r3, #0]
    f436:	4623      	mov	r3, r4
    f438:	f001 7200 	and.w	r2, r1, #33554432	; 0x2000000
    f43c:	4313      	orrs	r3, r2
    f43e:	d012      	beq.n	f466 <hci_acl_handle+0xbe>
	*buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    f440:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    f444:	2001      	movs	r0, #1
    f446:	f7f8 faa1 	bl	798c <bt_buf_get_rx>
	hci_evt_create(*buf, BT_HCI_EVT_DATA_BUF_OVERFLOW, sizeof(*ep));
    f44a:	2201      	movs	r2, #1
	*buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    f44c:	f8c8 0000 	str.w	r0, [r8]
	hci_evt_create(*buf, BT_HCI_EVT_DATA_BUF_OVERFLOW, sizeof(*ep));
    f450:	211a      	movs	r1, #26
    f452:	f00d feda 	bl	1d20a <hci_evt_create>
	ep = net_buf_add(*buf, sizeof(*ep));
    f456:	f8d8 0000 	ldr.w	r0, [r8]
    f45a:	2101      	movs	r1, #1
    f45c:	3008      	adds	r0, #8
    f45e:	f00e fbf5 	bl	1dc4c <net_buf_simple_add>
	ep->link_type = BT_OVERFLOW_LINK_ACL;
    f462:	2301      	movs	r3, #1
    f464:	7003      	strb	r3, [r0, #0]
		return -ENOBUFS;
    f466:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
    f46a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (bt_acl_flags_bc(flags) != BT_ACL_POINT_TO_POINT) {
    f46e:	08b3      	lsrs	r3, r6, #2
    f470:	d1b1      	bne.n	f3d6 <hci_acl_handle+0x2e>
	switch (bt_acl_flags_pb(flags)) {
    f472:	b12e      	cbz	r6, f480 <hci_acl_handle+0xd8>
    f474:	2e01      	cmp	r6, #1
    f476:	d1ae      	bne.n	f3d6 <hci_acl_handle+0x2e>
		pdu_data->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
    f478:	7903      	ldrb	r3, [r0, #4]
    f47a:	f366 0301 	bfi	r3, r6, #0, #2
    f47e:	e003      	b.n	f488 <hci_acl_handle+0xe0>
		pdu_data->ll_id = PDU_DATA_LLID_DATA_START;
    f480:	7903      	ldrb	r3, [r0, #4]
    f482:	2202      	movs	r2, #2
    f484:	f362 0301 	bfi	r3, r2, #0, #2
	pdu_data->len = len;
    f488:	7167      	strb	r7, [r4, #5]
	memcpy(&pdu_data->lldata[0], buf->data, len);
    f48a:	68a9      	ldr	r1, [r5, #8]
		pdu_data->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
    f48c:	7123      	strb	r3, [r4, #4]
	memcpy(&pdu_data->lldata[0], buf->data, len);
    f48e:	463a      	mov	r2, r7
    f490:	1de0      	adds	r0, r4, #7
    f492:	f00b fdb2 	bl	1affa <memcpy>
	if (ll_tx_mem_enqueue(handle, node_tx)) {
    f496:	4621      	mov	r1, r4
    f498:	f3c9 000b 	ubfx	r0, r9, #0, #12
    f49c:	f002 ff48 	bl	12330 <ll_tx_mem_enqueue>
    f4a0:	2800      	cmp	r0, #0
    f4a2:	d0e2      	beq.n	f46a <hci_acl_handle+0xc2>
		BT_ERR("Invalid Tx Enqueue");
    f4a4:	2301      	movs	r3, #1
    f4a6:	f04f 0100 	mov.w	r1, #0
    f4aa:	4a07      	ldr	r2, [pc, #28]	; (f4c8 <hci_acl_handle+0x120>)
    f4ac:	480c      	ldr	r0, [pc, #48]	; (f4e0 <hci_acl_handle+0x138>)
    f4ae:	f363 0107 	bfi	r1, r3, #0, #8
    f4b2:	4b06      	ldr	r3, [pc, #24]	; (f4cc <hci_acl_handle+0x124>)
    f4b4:	1a9b      	subs	r3, r3, r2
    f4b6:	08db      	lsrs	r3, r3, #3
    f4b8:	f363 118f 	bfi	r1, r3, #6, #10
    f4bc:	f00b f8a9 	bl	1a612 <log_0>
		ll_tx_mem_release(node_tx);
    f4c0:	4620      	mov	r0, r4
    f4c2:	f002 ff2f 	bl	12324 <ll_tx_mem_release>
		return -EINVAL;
    f4c6:	e786      	b.n	f3d6 <hci_acl_handle+0x2e>
    f4c8:	0001ed28 	.word	0x0001ed28
    f4cc:	0001ed68 	.word	0x0001ed68
    f4d0:	000219eb 	.word	0x000219eb
    f4d4:	000219fd 	.word	0x000219fd
    f4d8:	00021a1b 	.word	0x00021a1b
    f4dc:	20005588 	.word	0x20005588
    f4e0:	00021a2e 	.word	0x00021a2e

0000f4e4 <hci_acl_encode>:
	u16_t handle;
	u8_t *data;

	handle = node_rx->hdr.handle;

	switch (pdu_data->ll_id) {
    f4e4:	f890 3020 	ldrb.w	r3, [r0, #32]
    f4e8:	f003 0303 	and.w	r3, r3, #3
    f4ec:	3b01      	subs	r3, #1
    f4ee:	2b01      	cmp	r3, #1
{
    f4f0:	b570      	push	{r4, r5, r6, lr}
    f4f2:	4604      	mov	r4, r0
	switch (pdu_data->ll_id) {
    f4f4:	d81f      	bhi.n	f536 <hci_acl_encode+0x52>
	case PDU_DATA_LLID_DATA_CONTINUE:
	case PDU_DATA_LLID_DATA_START:
		acl = (void *)net_buf_add(buf, sizeof(*acl));
    f4f6:	f101 0608 	add.w	r6, r1, #8
	handle = node_rx->hdr.handle;
    f4fa:	88c5      	ldrh	r5, [r0, #6]
		acl = (void *)net_buf_add(buf, sizeof(*acl));
    f4fc:	2104      	movs	r1, #4
    f4fe:	4630      	mov	r0, r6
    f500:	f00e fba4 	bl	1dc4c <net_buf_simple_add>
		if (pdu_data->ll_id == PDU_DATA_LLID_DATA_START) {
    f504:	f894 3020 	ldrb.w	r3, [r4, #32]
    f508:	f003 0303 	and.w	r3, r3, #3
    f50c:	2b02      	cmp	r3, #2
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_START);
    f50e:	bf0c      	ite	eq
    f510:	f445 5500 	orreq.w	r5, r5, #8192	; 0x2000
		} else {
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_CONT);
    f514:	f445 5580 	orrne.w	r5, r5, #4096	; 0x1000
		}
		acl->handle = sys_cpu_to_le16(handle_flags);
    f518:	8005      	strh	r5, [r0, #0]
		acl->len = sys_cpu_to_le16(pdu_data->len);
    f51a:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
    f51e:	8041      	strh	r1, [r0, #2]
		data = (void *)net_buf_add(buf, pdu_data->len);
    f520:	4630      	mov	r0, r6
    f522:	f00e fb93 	bl	1dc4c <net_buf_simple_add>
		memcpy(data, pdu_data->lldata, pdu_data->len);
    f526:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
    f52a:	f104 0123 	add.w	r1, r4, #35	; 0x23

	default:
		LL_ASSERT(0);
		break;
	}
}
    f52e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		memcpy(data, pdu_data->lldata, pdu_data->len);
    f532:	f00b bd62 	b.w	1affa <memcpy>
		LL_ASSERT(0);
    f536:	f640 539e 	movw	r3, #3486	; 0xd9e
    f53a:	4a06      	ldr	r2, [pc, #24]	; (f554 <hci_acl_encode+0x70>)
    f53c:	4906      	ldr	r1, [pc, #24]	; (f558 <hci_acl_encode+0x74>)
    f53e:	4807      	ldr	r0, [pc, #28]	; (f55c <hci_acl_encode+0x78>)
    f540:	f009 ff18 	bl	19374 <printk>
    f544:	4040      	eors	r0, r0
    f546:	f380 8811 	msr	BASEPRI, r0
    f54a:	f04f 0003 	mov.w	r0, #3
    f54e:	df02      	svc	2
}
    f550:	bd70      	pop	{r4, r5, r6, pc}
    f552:	bf00      	nop
    f554:	000219b9 	.word	0x000219b9
    f558:	00022577 	.word	0x00022577
    f55c:	00020aa4 	.word	0x00020aa4

0000f560 <hci_evt_encode>:
#endif /* CONFIG_BT_CONN */

void hci_evt_encode(struct node_rx_pdu *node_rx, struct net_buf *buf)
{
    f560:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct pdu_data *pdu_data = PDU_DATA(node_rx);

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
    f562:	7903      	ldrb	r3, [r0, #4]
    f564:	88c6      	ldrh	r6, [r0, #6]
    f566:	2b02      	cmp	r3, #2
{
    f568:	b089      	sub	sp, #36	; 0x24
    f56a:	4604      	mov	r4, r0
    f56c:	460d      	mov	r5, r1
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
    f56e:	f000 81a7 	beq.w	f8c0 <hci_evt_encode+0x360>
	switch (node_rx->hdr.type) {
    f572:	3b08      	subs	r3, #8
    f574:	2b06      	cmp	r3, #6
    f576:	f200 8180 	bhi.w	f87a <hci_evt_encode+0x31a>
    f57a:	e8df f013 	tbh	[pc, r3, lsl #1]
    f57e:	0007      	.short	0x0007
    f580:	00b7009a 	.word	0x00b7009a
    f584:	00f000da 	.word	0x00f000da
    f588:	011f0104 	.word	0x011f0104
	u8_t status = node_rx->status;
    f58c:	f890 7020 	ldrb.w	r7, [r0, #32]
	if (!status) {
    f590:	b947      	cbnz	r7, f5a4 <hci_evt_encode+0x44>
		ll_rl_crpa_set(node_rx->peer_addr_type,
    f592:	f100 0329 	add.w	r3, r0, #41	; 0x29
    f596:	f100 0123 	add.w	r1, r0, #35	; 0x23
    f59a:	22ff      	movs	r2, #255	; 0xff
    f59c:	f890 0022 	ldrb.w	r0, [r0, #34]	; 0x22
    f5a0:	f005 feec 	bl	1537c <ll_rl_crpa_set>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    f5a4:	4bbc      	ldr	r3, [pc, #752]	; (f898 <hci_evt_encode+0x338>)
    f5a6:	6859      	ldr	r1, [r3, #4]
    f5a8:	f04f 0c00 	mov.w	ip, #0
    f5ac:	4662      	mov	r2, ip
    f5ae:	f001 5300 	and.w	r3, r1, #536870912	; 0x20000000
    f5b2:	4313      	orrs	r3, r2
    f5b4:	d052      	beq.n	f65c <hci_evt_encode+0xfc>
	    (!(le_event_mask & BT_EVT_MASK_LE_CONN_COMPLETE) &&
    f5b6:	4bb9      	ldr	r3, [pc, #740]	; (f89c <hci_evt_encode+0x33c>)
    f5b8:	f8d3 e000 	ldr.w	lr, [r3]
    f5bc:	f240 2001 	movw	r0, #513	; 0x201
    f5c0:	ea0e 0000 	and.w	r0, lr, r0
    f5c4:	4661      	mov	r1, ip
    f5c6:	4301      	orrs	r1, r0
	     !(le_event_mask & BT_EVT_MASK_LE_ENH_CONN_COMPLETE))) {
    f5c8:	f40e 7200 	and.w	r2, lr, #512	; 0x200
    f5cc:	4663      	mov	r3, ip
	    (!(le_event_mask & BT_EVT_MASK_LE_CONN_COMPLETE) &&
    f5ce:	d045      	beq.n	f65c <hci_evt_encode+0xfc>
	if (!status) {
    f5d0:	b91f      	cbnz	r7, f5da <hci_evt_encode+0x7a>
		conn_count++;
    f5d2:	48b3      	ldr	r0, [pc, #716]	; (f8a0 <hci_evt_encode+0x340>)
    f5d4:	6801      	ldr	r1, [r0, #0]
    f5d6:	3101      	adds	r1, #1
    f5d8:	6001      	str	r1, [r0, #0]
	if (le_event_mask & BT_EVT_MASK_LE_ENH_CONN_COMPLETE) {
    f5da:	4313      	orrs	r3, r2
    f5dc:	d044      	beq.n	f668 <hci_evt_encode+0x108>
		leecc = meta_evt(buf, BT_HCI_EVT_LE_ENH_CONN_COMPLETE,
    f5de:	4628      	mov	r0, r5
    f5e0:	221e      	movs	r2, #30
    f5e2:	210a      	movs	r1, #10
    f5e4:	f00d fe1b 	bl	1d21e <meta_evt>
    f5e8:	4605      	mov	r5, r0
		if (status) {
    f5ea:	b12f      	cbz	r7, f5f8 <hci_evt_encode+0x98>
			(void)memset(leecc, 0x00, sizeof(*leecc));
    f5ec:	221e      	movs	r2, #30
		(void)memset(lecc, 0x00, sizeof(*lecc));
    f5ee:	2100      	movs	r1, #0
    f5f0:	f00b fd2d 	bl	1b04e <memset>
		lecc->status = status;
    f5f4:	702f      	strb	r7, [r5, #0]
		return;
    f5f6:	e031      	b.n	f65c <hci_evt_encode+0xfc>
		leecc->status = 0x00;
    f5f8:	7007      	strb	r7, [r0, #0]
		leecc->handle = sys_cpu_to_le16(handle);
    f5fa:	f8a0 6001 	strh.w	r6, [r0, #1]
		leecc->role = node_rx->role;
    f5fe:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    f602:	70c3      	strb	r3, [r0, #3]
		leecc->peer_addr.type = node_rx->peer_addr_type;
    f604:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    f608:	7103      	strb	r3, [r0, #4]
		memcpy(&leecc->peer_addr.a.val[0], &node_rx->peer_addr[0],
    f60a:	2206      	movs	r2, #6
    f60c:	f104 0123 	add.w	r1, r4, #35	; 0x23
    f610:	3005      	adds	r0, #5
    f612:	f00b fcf2 	bl	1affa <memcpy>
		if ((node_rx->own_addr_type) &&
    f616:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
    f61a:	f105 000b 	add.w	r0, r5, #11
			memcpy(&leecc->local_rpa.val[0], &node_rx->own_addr[0],
    f61e:	2206      	movs	r2, #6
		if ((node_rx->own_addr_type) &&
    f620:	b1f3      	cbz	r3, f660 <hci_evt_encode+0x100>
    f622:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    f626:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    f62a:	2b40      	cmp	r3, #64	; 0x40
    f62c:	d118      	bne.n	f660 <hci_evt_encode+0x100>
			memcpy(&leecc->local_rpa.val[0], &node_rx->own_addr[0],
    f62e:	f104 0130 	add.w	r1, r4, #48	; 0x30
    f632:	f00b fce2 	bl	1affa <memcpy>
		memcpy(&leecc->peer_rpa.val[0], &node_rx->peer_rpa[0],
    f636:	2206      	movs	r2, #6
    f638:	f104 0129 	add.w	r1, r4, #41	; 0x29
    f63c:	f105 0011 	add.w	r0, r5, #17
    f640:	f00b fcdb 	bl	1affa <memcpy>
		leecc->interval = sys_cpu_to_le16(node_rx->interval);
    f644:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    f646:	f8a5 3017 	strh.w	r3, [r5, #23]
		leecc->latency = sys_cpu_to_le16(node_rx->latency);
    f64a:	8f23      	ldrh	r3, [r4, #56]	; 0x38
    f64c:	f8a5 3019 	strh.w	r3, [r5, #25]
		leecc->supv_timeout = sys_cpu_to_le16(node_rx->timeout);
    f650:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
    f652:	f8a5 301b 	strh.w	r3, [r5, #27]
		leecc->clock_accuracy = node_rx->sca;
    f656:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
    f65a:	776b      	strb	r3, [r5, #29]
		encode_control(node_rx, pdu_data, buf);
	} else if (IS_ENABLED(CONFIG_BT_CONN)) {
		encode_data_ctrl(node_rx, pdu_data, buf);
	}
}
    f65c:	b009      	add	sp, #36	; 0x24
    f65e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			(void)memset(&leecc->local_rpa.val[0], 0x0,
    f660:	2100      	movs	r1, #0
    f662:	f00b fcf4 	bl	1b04e <memset>
    f666:	e7e6      	b.n	f636 <hci_evt_encode+0xd6>
	lecc = meta_evt(buf, BT_HCI_EVT_LE_CONN_COMPLETE, sizeof(*lecc));
    f668:	4628      	mov	r0, r5
    f66a:	2212      	movs	r2, #18
    f66c:	2101      	movs	r1, #1
    f66e:	f00d fdd6 	bl	1d21e <meta_evt>
    f672:	4605      	mov	r5, r0
	if (status) {
    f674:	b10f      	cbz	r7, f67a <hci_evt_encode+0x11a>
		(void)memset(lecc, 0x00, sizeof(*lecc));
    f676:	2212      	movs	r2, #18
    f678:	e7b9      	b.n	f5ee <hci_evt_encode+0x8e>
	lecc->status = 0x00;
    f67a:	7007      	strb	r7, [r0, #0]
	lecc->handle = sys_cpu_to_le16(handle);
    f67c:	f8a0 6001 	strh.w	r6, [r0, #1]
	lecc->role = node_rx->role;
    f680:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    f684:	70c3      	strb	r3, [r0, #3]
	lecc->peer_addr.type = node_rx->peer_addr_type;
    f686:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    f68a:	7103      	strb	r3, [r0, #4]
	memcpy(&lecc->peer_addr.a.val[0], &node_rx->peer_addr[0], BDADDR_SIZE);
    f68c:	2206      	movs	r2, #6
    f68e:	f104 0123 	add.w	r1, r4, #35	; 0x23
    f692:	3005      	adds	r0, #5
    f694:	f00b fcb1 	bl	1affa <memcpy>
	lecc->interval = sys_cpu_to_le16(node_rx->interval);
    f698:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    f69a:	f8a5 300b 	strh.w	r3, [r5, #11]
	lecc->latency = sys_cpu_to_le16(node_rx->latency);
    f69e:	8f23      	ldrh	r3, [r4, #56]	; 0x38
    f6a0:	f8a5 300d 	strh.w	r3, [r5, #13]
	lecc->supv_timeout = sys_cpu_to_le16(node_rx->timeout);
    f6a4:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
    f6a6:	f8a5 300f 	strh.w	r3, [r5, #15]
	lecc->clock_accuracy = node_rx->sca;
    f6aa:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
    f6ae:	746b      	strb	r3, [r5, #17]
    f6b0:	e7d4      	b.n	f65c <hci_evt_encode+0xfc>
	if (!(event_mask & BT_EVT_MASK_DISCONN_COMPLETE)) {
    f6b2:	4b79      	ldr	r3, [pc, #484]	; (f898 <hci_evt_encode+0x338>)
    f6b4:	6819      	ldr	r1, [r3, #0]
    f6b6:	2700      	movs	r7, #0
    f6b8:	f001 0210 	and.w	r2, r1, #16
    f6bc:	463b      	mov	r3, r7
    f6be:	4313      	orrs	r3, r2
    f6c0:	d0cc      	beq.n	f65c <hci_evt_encode+0xfc>
	hci_evt_create(buf, BT_HCI_EVT_DISCONN_COMPLETE, sizeof(*ep));
    f6c2:	2204      	movs	r2, #4
    f6c4:	2105      	movs	r1, #5
    f6c6:	4628      	mov	r0, r5
    f6c8:	f00d fd9f 	bl	1d20a <hci_evt_create>
	ep = net_buf_add(buf, sizeof(*ep));
    f6cc:	2104      	movs	r1, #4
    f6ce:	f105 0008 	add.w	r0, r5, #8
    f6d2:	f00e fabb 	bl	1dc4c <net_buf_simple_add>
	conn_count--;
    f6d6:	4a72      	ldr	r2, [pc, #456]	; (f8a0 <hci_evt_encode+0x340>)
	ep->status = 0x00;
    f6d8:	7007      	strb	r7, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
    f6da:	f8a0 6001 	strh.w	r6, [r0, #1]
	ep->reason = *((u8_t *)pdu_data);
    f6de:	f894 3020 	ldrb.w	r3, [r4, #32]
    f6e2:	70c3      	strb	r3, [r0, #3]
	conn_count--;
    f6e4:	6813      	ldr	r3, [r2, #0]
    f6e6:	3b01      	subs	r3, #1
    f6e8:	6013      	str	r3, [r2, #0]
    f6ea:	e7b7      	b.n	f65c <hci_evt_encode+0xfc>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    f6ec:	4b6a      	ldr	r3, [pc, #424]	; (f898 <hci_evt_encode+0x338>)
    f6ee:	6858      	ldr	r0, [r3, #4]
    f6f0:	2100      	movs	r1, #0
    f6f2:	460a      	mov	r2, r1
    f6f4:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
    f6f8:	4313      	orrs	r3, r2
    f6fa:	d0af      	beq.n	f65c <hci_evt_encode+0xfc>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_UPDATE_COMPLETE)) {
    f6fc:	4b67      	ldr	r3, [pc, #412]	; (f89c <hci_evt_encode+0x33c>)
    f6fe:	6818      	ldr	r0, [r3, #0]
    f700:	460b      	mov	r3, r1
    f702:	f000 0204 	and.w	r2, r0, #4
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    f706:	4313      	orrs	r3, r2
    f708:	d0a8      	beq.n	f65c <hci_evt_encode+0xfc>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CONN_UPDATE_COMPLETE, sizeof(*sep));
    f70a:	2209      	movs	r2, #9
    f70c:	2103      	movs	r1, #3
    f70e:	4628      	mov	r0, r5
    f710:	f00d fd85 	bl	1d21e <meta_evt>
	sep->status = cu->status;
    f714:	f894 3020 	ldrb.w	r3, [r4, #32]
    f718:	7003      	strb	r3, [r0, #0]
	sep->interval = sys_cpu_to_le16(cu->interval);
    f71a:	8c63      	ldrh	r3, [r4, #34]	; 0x22
    f71c:	f8a0 3003 	strh.w	r3, [r0, #3]
	sep->latency = sys_cpu_to_le16(cu->latency);
    f720:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
    f722:	f8a0 3005 	strh.w	r3, [r0, #5]
	sep->supv_timeout = sys_cpu_to_le16(cu->timeout);
    f726:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
	sep->handle = sys_cpu_to_le16(handle);
    f728:	f8a0 6001 	strh.w	r6, [r0, #1]
	sep->supv_timeout = sys_cpu_to_le16(cu->timeout);
    f72c:	f8a0 3007 	strh.w	r3, [r0, #7]
    f730:	e794      	b.n	f65c <hci_evt_encode+0xfc>
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_KEY_REFRESH_COMPLETE)) {
    f732:	4b59      	ldr	r3, [pc, #356]	; (f898 <hci_evt_encode+0x338>)
    f734:	6859      	ldr	r1, [r3, #4]
    f736:	2400      	movs	r4, #0
    f738:	4622      	mov	r2, r4
    f73a:	f401 4300 	and.w	r3, r1, #32768	; 0x8000
    f73e:	4313      	orrs	r3, r2
    f740:	d08c      	beq.n	f65c <hci_evt_encode+0xfc>
	hci_evt_create(buf, BT_HCI_EVT_ENCRYPT_KEY_REFRESH_COMPLETE,
    f742:	2203      	movs	r2, #3
    f744:	2130      	movs	r1, #48	; 0x30
    f746:	4628      	mov	r0, r5
    f748:	f00d fd5f 	bl	1d20a <hci_evt_create>
	ep = net_buf_add(buf, sizeof(*ep));
    f74c:	2103      	movs	r1, #3
    f74e:	f105 0008 	add.w	r0, r5, #8
    f752:	f00e fa7b 	bl	1dc4c <net_buf_simple_add>
	ep->status = 0x00;
    f756:	7004      	strb	r4, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
    f758:	f8a0 6001 	strh.w	r6, [r0, #1]
    f75c:	e77e      	b.n	f65c <hci_evt_encode+0xfc>
	if (!(event_mask_page_2 & BT_EVT_MASK_AUTH_PAYLOAD_TIMEOUT_EXP)) {
    f75e:	4b51      	ldr	r3, [pc, #324]	; (f8a4 <hci_evt_encode+0x344>)
    f760:	6819      	ldr	r1, [r3, #0]
    f762:	2300      	movs	r3, #0
    f764:	f401 0200 	and.w	r2, r1, #8388608	; 0x800000
    f768:	4313      	orrs	r3, r2
    f76a:	f43f af77 	beq.w	f65c <hci_evt_encode+0xfc>
	hci_evt_create(buf, BT_HCI_EVT_AUTH_PAYLOAD_TIMEOUT_EXP, sizeof(*ep));
    f76e:	2202      	movs	r2, #2
    f770:	2157      	movs	r1, #87	; 0x57
    f772:	4628      	mov	r0, r5
    f774:	f00d fd49 	bl	1d20a <hci_evt_create>
	ep = net_buf_add(buf, sizeof(*ep));
    f778:	2102      	movs	r1, #2
    f77a:	f105 0008 	add.w	r0, r5, #8
    f77e:	f00e fa65 	bl	1dc4c <net_buf_simple_add>
	ep->handle = sys_cpu_to_le16(handle);
    f782:	8006      	strh	r6, [r0, #0]
    f784:	e76a      	b.n	f65c <hci_evt_encode+0xfc>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    f786:	4b44      	ldr	r3, [pc, #272]	; (f898 <hci_evt_encode+0x338>)
    f788:	6858      	ldr	r0, [r3, #4]
    f78a:	2100      	movs	r1, #0
    f78c:	460a      	mov	r2, r1
    f78e:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
    f792:	4313      	orrs	r3, r2
    f794:	f43f af62 	beq.w	f65c <hci_evt_encode+0xfc>
	    !(le_event_mask & BT_EVT_MASK_LE_CHAN_SEL_ALGO)) {
    f798:	4b40      	ldr	r3, [pc, #256]	; (f89c <hci_evt_encode+0x33c>)
    f79a:	6818      	ldr	r0, [r3, #0]
    f79c:	460b      	mov	r3, r1
    f79e:	f400 2200 	and.w	r2, r0, #524288	; 0x80000
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    f7a2:	4313      	orrs	r3, r2
    f7a4:	f43f af5a 	beq.w	f65c <hci_evt_encode+0xfc>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CHAN_SEL_ALGO, sizeof(*sep));
    f7a8:	2203      	movs	r2, #3
    f7aa:	2114      	movs	r1, #20
    f7ac:	4628      	mov	r0, r5
    f7ae:	f00d fd36 	bl	1d21e <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
    f7b2:	8006      	strh	r6, [r0, #0]
	sep->chan_sel_algo = cs->csa;
    f7b4:	f894 3020 	ldrb.w	r3, [r4, #32]
    f7b8:	7083      	strb	r3, [r0, #2]
    f7ba:	e74f      	b.n	f65c <hci_evt_encode+0xfc>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    f7bc:	4b36      	ldr	r3, [pc, #216]	; (f898 <hci_evt_encode+0x338>)
    f7be:	6858      	ldr	r0, [r3, #4]
    f7c0:	2100      	movs	r1, #0
    f7c2:	460a      	mov	r2, r1
    f7c4:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
    f7c8:	4313      	orrs	r3, r2
    f7ca:	d006      	beq.n	f7da <hci_evt_encode+0x27a>
	    !(le_event_mask & BT_EVT_MASK_LE_PHY_UPDATE_COMPLETE)) {
    f7cc:	4b33      	ldr	r3, [pc, #204]	; (f89c <hci_evt_encode+0x33c>)
    f7ce:	6818      	ldr	r0, [r3, #0]
    f7d0:	460b      	mov	r3, r1
    f7d2:	f400 6200 	and.w	r2, r0, #2048	; 0x800
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    f7d6:	4313      	orrs	r3, r2
    f7d8:	d12c      	bne.n	f834 <hci_evt_encode+0x2d4>
		BT_WARN("handle: 0x%04x, status: %x, tx: %x, rx: %x.", handle,
    f7da:	2202      	movs	r2, #2
    f7dc:	f04f 0300 	mov.w	r3, #0
    f7e0:	f362 0307 	bfi	r3, r2, #0, #8
    f7e4:	4930      	ldr	r1, [pc, #192]	; (f8a8 <hci_evt_encode+0x348>)
    f7e6:	4a31      	ldr	r2, [pc, #196]	; (f8ac <hci_evt_encode+0x34c>)
    f7e8:	4831      	ldr	r0, [pc, #196]	; (f8b0 <hci_evt_encode+0x350>)
    f7ea:	9604      	str	r6, [sp, #16]
    f7ec:	1a52      	subs	r2, r2, r1
    f7ee:	08d2      	lsrs	r2, r2, #3
    f7f0:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
    f7f4:	f362 138f 	bfi	r3, r2, #6, #10
    f7f8:	f894 2020 	ldrb.w	r2, [r4, #32]
    f7fc:	9205      	str	r2, [sp, #20]
    f7fe:	2900      	cmp	r1, #0
    f800:	fa91 f2a1 	rbit	r2, r1
    f804:	fab2 f282 	clz	r2, r2
    f808:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
    f80c:	bf08      	it	eq
    f80e:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
    f812:	3201      	adds	r2, #1
    f814:	2900      	cmp	r1, #0
    f816:	9206      	str	r2, [sp, #24]
    f818:	fa91 f2a1 	rbit	r2, r1
    f81c:	fab2 f282 	clz	r2, r2
    f820:	bf08      	it	eq
    f822:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
    f826:	3201      	adds	r2, #1
    f828:	9207      	str	r2, [sp, #28]
    f82a:	a904      	add	r1, sp, #16
    f82c:	2204      	movs	r2, #4
    f82e:	f00a ff44 	bl	1a6ba <log_n>
		return;
    f832:	e713      	b.n	f65c <hci_evt_encode+0xfc>
	sep = meta_evt(buf, BT_HCI_EVT_LE_PHY_UPDATE_COMPLETE, sizeof(*sep));
    f834:	2205      	movs	r2, #5
    f836:	210c      	movs	r1, #12
    f838:	4628      	mov	r0, r5
    f83a:	f00d fcf0 	bl	1d21e <meta_evt>
	sep->status = pu->status;
    f83e:	f894 3020 	ldrb.w	r3, [r4, #32]
    f842:	7003      	strb	r3, [r0, #0]
	sep->handle = sys_cpu_to_le16(handle);
    f844:	f8a0 6001 	strh.w	r6, [r0, #1]
    f848:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
    f84c:	2a00      	cmp	r2, #0
    f84e:	fa92 f3a2 	rbit	r3, r2
    f852:	fab3 f383 	clz	r3, r3
    f856:	bf08      	it	eq
    f858:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
    f85c:	3301      	adds	r3, #1
	sep->tx_phy = find_lsb_set(pu->tx);
    f85e:	70c3      	strb	r3, [r0, #3]
    f860:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
    f864:	fa92 f3a2 	rbit	r3, r2
    f868:	2a00      	cmp	r2, #0
    f86a:	fab3 f383 	clz	r3, r3
    f86e:	bf08      	it	eq
    f870:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
    f874:	3301      	adds	r3, #1
	sep->rx_phy = find_lsb_set(pu->rx);
    f876:	7103      	strb	r3, [r0, #4]
    f878:	e6f0      	b.n	f65c <hci_evt_encode+0xfc>
		LL_ASSERT(0);
    f87a:	f640 43a9 	movw	r3, #3241	; 0xca9
		LL_ASSERT(0);
    f87e:	4a0d      	ldr	r2, [pc, #52]	; (f8b4 <hci_evt_encode+0x354>)
    f880:	490d      	ldr	r1, [pc, #52]	; (f8b8 <hci_evt_encode+0x358>)
    f882:	480e      	ldr	r0, [pc, #56]	; (f8bc <hci_evt_encode+0x35c>)
    f884:	f009 fd76 	bl	19374 <printk>
    f888:	4040      	eors	r0, r0
    f88a:	f380 8811 	msr	BASEPRI, r0
    f88e:	f04f 0003 	mov.w	r0, #3
    f892:	df02      	svc	2
}
    f894:	e6e2      	b.n	f65c <hci_evt_encode+0xfc>
    f896:	bf00      	nop
    f898:	20005588 	.word	0x20005588
    f89c:	20005590 	.word	0x20005590
    f8a0:	20000944 	.word	0x20000944
    f8a4:	20000000 	.word	0x20000000
    f8a8:	0001ed28 	.word	0x0001ed28
    f8ac:	0001ed68 	.word	0x0001ed68
    f8b0:	00021a75 	.word	0x00021a75
    f8b4:	000219b9 	.word	0x000219b9
    f8b8:	00022577 	.word	0x00022577
    f8bc:	00020aa4 	.word	0x00020aa4
	switch (pdu_data->llctrl.opcode) {
    f8c0:	f890 3023 	ldrb.w	r3, [r0, #35]	; 0x23
    f8c4:	3b03      	subs	r3, #3
    f8c6:	2b12      	cmp	r3, #18
    f8c8:	f200 80a4 	bhi.w	fa14 <hci_evt_encode+0x4b4>
    f8cc:	e8df f003 	tbb	[pc, r3]
    f8d0:	30a2a20a 	.word	0x30a2a20a
    f8d4:	a236a28a 	.word	0xa236a28a
    f8d8:	a23ea2a2 	.word	0xa23ea2a2
    f8dc:	a2a2a243 	.word	0xa2a2a243
    f8e0:	6ba2      	.short	0x6ba2
    f8e2:	6b          	.byte	0x6b
    f8e3:	00          	.byte	0x00
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    f8e4:	4b4d      	ldr	r3, [pc, #308]	; (fa1c <hci_evt_encode+0x4bc>)
    f8e6:	6858      	ldr	r0, [r3, #4]
    f8e8:	2100      	movs	r1, #0
    f8ea:	460a      	mov	r2, r1
    f8ec:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
    f8f0:	4313      	orrs	r3, r2
    f8f2:	f43f aeb3 	beq.w	f65c <hci_evt_encode+0xfc>
	    !(le_event_mask & BT_EVT_MASK_LE_LTK_REQUEST)) {
    f8f6:	4b4a      	ldr	r3, [pc, #296]	; (fa20 <hci_evt_encode+0x4c0>)
    f8f8:	6818      	ldr	r0, [r3, #0]
    f8fa:	460b      	mov	r3, r1
    f8fc:	f000 0210 	and.w	r2, r0, #16
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    f900:	4313      	orrs	r3, r2
    f902:	f43f aeab 	beq.w	f65c <hci_evt_encode+0xfc>
	sep = meta_evt(buf, BT_HCI_EVT_LE_LTK_REQUEST, sizeof(*sep));
    f906:	220c      	movs	r2, #12
    f908:	2105      	movs	r1, #5
    f90a:	4628      	mov	r0, r5
    f90c:	f00d fc87 	bl	1d21e <meta_evt>
	memcpy(&sep->rand, pdu_data->llctrl.enc_req.rand, sizeof(u64_t));
    f910:	f104 0124 	add.w	r1, r4, #36	; 0x24
	sep = meta_evt(buf, BT_HCI_EVT_LE_LTK_REQUEST, sizeof(*sep));
    f914:	4605      	mov	r5, r0
	memcpy(&sep->rand, pdu_data->llctrl.enc_req.rand, sizeof(u64_t));
    f916:	2208      	movs	r2, #8
	sep->handle = sys_cpu_to_le16(handle);
    f918:	f820 6b02 	strh.w	r6, [r0], #2
	memcpy(&sep->rand, pdu_data->llctrl.enc_req.rand, sizeof(u64_t));
    f91c:	f00b fb6d 	bl	1affa <memcpy>
	memcpy(&sep->ediv, pdu_data->llctrl.enc_req.ediv, sizeof(u16_t));
    f920:	2202      	movs	r2, #2
    f922:	f104 012c 	add.w	r1, r4, #44	; 0x2c
    f926:	f105 000a 	add.w	r0, r5, #10
    f92a:	f00b fb66 	bl	1affa <memcpy>
    f92e:	e695      	b.n	f65c <hci_evt_encode+0xfc>
		encrypt_change(0x00, handle, buf);
    f930:	460a      	mov	r2, r1
    f932:	2000      	movs	r0, #0
    f934:	4631      	mov	r1, r6
		encrypt_change(pdu_data->llctrl.reject_ind.error_code, handle,
    f936:	f7fe ffdd 	bl	e8f4 <encrypt_change>
		break;
    f93a:	e68f      	b.n	f65c <hci_evt_encode+0xfc>
		le_remote_feat_complete(0x00, pdu_data, handle, buf);
    f93c:	460b      	mov	r3, r1
    f93e:	4632      	mov	r2, r6
    f940:	f100 0120 	add.w	r1, r0, #32
    f944:	2000      	movs	r0, #0
		le_remote_feat_complete(BT_HCI_ERR_UNSUPP_REMOTE_FEATURE,
    f946:	f7fe ffa7 	bl	e898 <le_remote_feat_complete>
		break;
    f94a:	e687      	b.n	f65c <hci_evt_encode+0xfc>
		encrypt_change(pdu_data->llctrl.reject_ind.error_code, handle,
    f94c:	460a      	mov	r2, r1
    f94e:	f890 0024 	ldrb.w	r0, [r0, #36]	; 0x24
    f952:	4631      	mov	r1, r6
    f954:	e7ef      	b.n	f936 <hci_evt_encode+0x3d6>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    f956:	4b31      	ldr	r3, [pc, #196]	; (fa1c <hci_evt_encode+0x4bc>)
    f958:	6858      	ldr	r0, [r3, #4]
    f95a:	2100      	movs	r1, #0
    f95c:	460a      	mov	r2, r1
    f95e:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
    f962:	4313      	orrs	r3, r2
    f964:	d006      	beq.n	f974 <hci_evt_encode+0x414>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_PARAM_REQ)) {
    f966:	4b2e      	ldr	r3, [pc, #184]	; (fa20 <hci_evt_encode+0x4c0>)
    f968:	6818      	ldr	r0, [r3, #0]
    f96a:	460b      	mov	r3, r1
    f96c:	f000 0220 	and.w	r2, r0, #32
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    f970:	4313      	orrs	r3, r2
    f972:	d109      	bne.n	f988 <hci_evt_encode+0x428>
		ll_conn_update(handle, 2, BT_HCI_ERR_UNSUPP_REMOTE_FEATURE, 0,
    f974:	2300      	movs	r3, #0
    f976:	e9cd 3301 	strd	r3, r3, [sp, #4]
    f97a:	9300      	str	r3, [sp, #0]
    f97c:	221a      	movs	r2, #26
    f97e:	2102      	movs	r1, #2
    f980:	4630      	mov	r0, r6
    f982:	f00d fe57 	bl	1d634 <ll_conn_update>
		return;
    f986:	e669      	b.n	f65c <hci_evt_encode+0xfc>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CONN_PARAM_REQ, sizeof(*sep));
    f988:	220a      	movs	r2, #10
    f98a:	2106      	movs	r1, #6
    f98c:	4628      	mov	r0, r5
    f98e:	f00d fc46 	bl	1d21e <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
    f992:	8006      	strh	r6, [r0, #0]
	sep->interval_min = pdu_data->llctrl.conn_param_req.interval_min;
    f994:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
    f996:	8043      	strh	r3, [r0, #2]
	sep->interval_max = pdu_data->llctrl.conn_param_req.interval_max;
    f998:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
    f99a:	8083      	strh	r3, [r0, #4]
	sep->latency = pdu_data->llctrl.conn_param_req.latency;
    f99c:	8d23      	ldrh	r3, [r4, #40]	; 0x28
    f99e:	80c3      	strh	r3, [r0, #6]
	sep->timeout = pdu_data->llctrl.conn_param_req.timeout;
    f9a0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
	sep->max_rx_time = pdu_data->llctrl.length_rsp.max_rx_time;
    f9a2:	8103      	strh	r3, [r0, #8]
    f9a4:	e65a      	b.n	f65c <hci_evt_encode+0xfc>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    f9a6:	4b1d      	ldr	r3, [pc, #116]	; (fa1c <hci_evt_encode+0x4bc>)
    f9a8:	6858      	ldr	r0, [r3, #4]
    f9aa:	2100      	movs	r1, #0
    f9ac:	460a      	mov	r2, r1
    f9ae:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
    f9b2:	4313      	orrs	r3, r2
    f9b4:	f43f ae52 	beq.w	f65c <hci_evt_encode+0xfc>
	    !(le_event_mask & BT_EVT_MASK_LE_DATA_LEN_CHANGE)) {
    f9b8:	4b19      	ldr	r3, [pc, #100]	; (fa20 <hci_evt_encode+0x4c0>)
    f9ba:	6818      	ldr	r0, [r3, #0]
    f9bc:	460b      	mov	r3, r1
    f9be:	f000 0240 	and.w	r2, r0, #64	; 0x40
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    f9c2:	4313      	orrs	r3, r2
    f9c4:	f43f ae4a 	beq.w	f65c <hci_evt_encode+0xfc>
	sep = meta_evt(buf, BT_HCI_EVT_LE_DATA_LEN_CHANGE, sizeof(*sep));
    f9c8:	220a      	movs	r2, #10
    f9ca:	2107      	movs	r1, #7
    f9cc:	4628      	mov	r0, r5
    f9ce:	f00d fc26 	bl	1d21e <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
    f9d2:	8006      	strh	r6, [r0, #0]
	sep->max_tx_octets = pdu_data->llctrl.length_rsp.max_tx_octets;
    f9d4:	8d23      	ldrh	r3, [r4, #40]	; 0x28
    f9d6:	8043      	strh	r3, [r0, #2]
	sep->max_tx_time = pdu_data->llctrl.length_rsp.max_tx_time;
    f9d8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    f9da:	8083      	strh	r3, [r0, #4]
	sep->max_rx_octets = pdu_data->llctrl.length_rsp.max_rx_octets;
    f9dc:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
    f9de:	80c3      	strh	r3, [r0, #6]
	sep->max_rx_time = pdu_data->llctrl.length_rsp.max_rx_time;
    f9e0:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
    f9e2:	e7de      	b.n	f9a2 <hci_evt_encode+0x442>
		le_unknown_rsp(pdu_data, handle, buf);
    f9e4:	f890 1024 	ldrb.w	r1, [r0, #36]	; 0x24
	switch (pdu_data->llctrl.unknown_rsp.type) {
    f9e8:	290e      	cmp	r1, #14
    f9ea:	d104      	bne.n	f9f6 <hci_evt_encode+0x496>
		le_remote_feat_complete(BT_HCI_ERR_UNSUPP_REMOTE_FEATURE,
    f9ec:	462b      	mov	r3, r5
    f9ee:	4632      	mov	r2, r6
    f9f0:	2100      	movs	r1, #0
    f9f2:	201a      	movs	r0, #26
    f9f4:	e7a7      	b.n	f946 <hci_evt_encode+0x3e6>
		BT_WARN("type: 0x%02x",	pdu_data->llctrl.unknown_rsp.type);
    f9f6:	2302      	movs	r3, #2
    f9f8:	f04f 0200 	mov.w	r2, #0
    f9fc:	f363 0207 	bfi	r2, r3, #0, #8
    fa00:	4808      	ldr	r0, [pc, #32]	; (fa24 <hci_evt_encode+0x4c4>)
    fa02:	4b09      	ldr	r3, [pc, #36]	; (fa28 <hci_evt_encode+0x4c8>)
    fa04:	1a1b      	subs	r3, r3, r0
    fa06:	08db      	lsrs	r3, r3, #3
    fa08:	f363 128f 	bfi	r2, r3, #6, #10
    fa0c:	4807      	ldr	r0, [pc, #28]	; (fa2c <hci_evt_encode+0x4cc>)
    fa0e:	f00a fe0d 	bl	1a62c <log_1>
    fa12:	e623      	b.n	f65c <hci_evt_encode+0xfc>
		LL_ASSERT(0);
    fa14:	f640 5372 	movw	r3, #3442	; 0xd72
    fa18:	e731      	b.n	f87e <hci_evt_encode+0x31e>
    fa1a:	bf00      	nop
    fa1c:	20005588 	.word	0x20005588
    fa20:	20005590 	.word	0x20005590
    fa24:	0001ed28 	.word	0x0001ed28
    fa28:	0001ed68 	.word	0x0001ed68
    fa2c:	00021aa1 	.word	0x00021aa1

0000fa30 <hci_init>:
	event_mask = DEFAULT_EVENT_MASK;
    fa30:	4b08      	ldr	r3, [pc, #32]	; (fa54 <hci_init+0x24>)
    fa32:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    fa36:	f641 71ff 	movw	r1, #8191	; 0x1fff
    fa3a:	e9c3 0100 	strd	r0, r1, [r3]
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
    fa3e:	4b06      	ldr	r3, [pc, #24]	; (fa58 <hci_init+0x28>)
    fa40:	2000      	movs	r0, #0
    fa42:	2100      	movs	r1, #0
    fa44:	e9c3 0100 	strd	r0, r1, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
    fa48:	4b04      	ldr	r3, [pc, #16]	; (fa5c <hci_init+0x2c>)
    fa4a:	201f      	movs	r0, #31
    fa4c:	2100      	movs	r1, #0
    fa4e:	e9c3 0100 	strd	r0, r1, [r3]
{
#if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
	hbuf_signal = signal_host_buf;
#endif
	reset(NULL, NULL);
}
    fa52:	4770      	bx	lr
    fa54:	20005588 	.word	0x20005588
    fa58:	20000000 	.word	0x20000000
    fa5c:	20005590 	.word	0x20005590

0000fa60 <bt_rand>:
#include "hal/ecb.h"

static struct device *entropy_driver;

int bt_rand(void *buf, size_t len)
{
    fa60:	b570      	push	{r4, r5, r6, lr}
	struct device *dev = entropy_driver;
    fa62:	4c08      	ldr	r4, [pc, #32]	; (fa84 <bt_rand+0x24>)
{
    fa64:	4605      	mov	r5, r0
	struct device *dev = entropy_driver;
    fa66:	6820      	ldr	r0, [r4, #0]
{
    fa68:	460e      	mov	r6, r1

	if (unlikely(!dev)) {
    fa6a:	b918      	cbnz	r0, fa74 <bt_rand+0x14>
    fa6c:	4806      	ldr	r0, [pc, #24]	; (fa88 <bt_rand+0x28>)
    fa6e:	f007 fe5f 	bl	17730 <z_impl_device_get_binding>
		dev = device_get_binding(CONFIG_ENTROPY_NAME);
		__ASSERT((dev != NULL),
			"Device driver for %s (CONFIG_ENTROPY_NAME) not found. "
			"Check your build configuration!",
			CONFIG_ENTROPY_NAME);
		entropy_driver = dev;
    fa72:	6020      	str	r0, [r4, #0]
	return api->get_entropy(dev, buffer, length);
    fa74:	6843      	ldr	r3, [r0, #4]
    fa76:	b2b2      	uxth	r2, r6
    fa78:	4629      	mov	r1, r5
    fa7a:	681b      	ldr	r3, [r3, #0]
	}

	return entropy_get_entropy(dev, (u8_t *)buf, len);
}
    fa7c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    fa80:	4718      	bx	r3
    fa82:	bf00      	nop
    fa84:	20000948 	.word	0x20000948
    fa88:	00021acc 	.word	0x00021acc

0000fa8c <ll_rx_link_inc_quota>:
	rx_alloc(UINT8_MAX);
}

static inline void ll_rx_link_inc_quota(int8_t delta)
{
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
    fa8c:	2801      	cmp	r0, #1
{
    fa8e:	b538      	push	{r3, r4, r5, lr}
    fa90:	4604      	mov	r4, r0
    fa92:	4d0b      	ldr	r5, [pc, #44]	; (fac0 <ll_rx_link_inc_quota+0x34>)
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
    fa94:	d10f      	bne.n	fab6 <ll_rx_link_inc_quota+0x2a>
    fa96:	782b      	ldrb	r3, [r5, #0]
    fa98:	2b06      	cmp	r3, #6
    fa9a:	d90c      	bls.n	fab6 <ll_rx_link_inc_quota+0x2a>
    fa9c:	f240 3369 	movw	r3, #873	; 0x369
    faa0:	4a08      	ldr	r2, [pc, #32]	; (fac4 <ll_rx_link_inc_quota+0x38>)
    faa2:	4909      	ldr	r1, [pc, #36]	; (fac8 <ll_rx_link_inc_quota+0x3c>)
    faa4:	4809      	ldr	r0, [pc, #36]	; (facc <ll_rx_link_inc_quota+0x40>)
    faa6:	f009 fc65 	bl	19374 <printk>
    faaa:	4040      	eors	r0, r0
    faac:	f380 8811 	msr	BASEPRI, r0
    fab0:	f04f 0003 	mov.w	r0, #3
    fab4:	df02      	svc	2
	mem_link_rx.quota_pdu += delta;
    fab6:	782b      	ldrb	r3, [r5, #0]
    fab8:	441c      	add	r4, r3
    faba:	702c      	strb	r4, [r5, #0]
}
    fabc:	bd38      	pop	{r3, r4, r5, pc}
    fabe:	bf00      	nop
    fac0:	20000a44 	.word	0x20000a44
    fac4:	00021b31 	.word	0x00021b31
    fac8:	00021b65 	.word	0x00021b65
    facc:	00020aa4 	.word	0x00020aa4

0000fad0 <rx_alloc>:

	return done;
}

static inline void rx_alloc(u8_t max)
{
    fad0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	u8_t idx;

#if defined(CONFIG_BT_CONN)
	while (mem_link_rx.quota_pdu &&
    fad4:	4e31      	ldr	r6, [pc, #196]	; (fb9c <rx_alloc+0xcc>)
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
    fad6:	4f32      	ldr	r7, [pc, #200]	; (fba0 <rx_alloc+0xd0>)
{
    fad8:	4680      	mov	r8, r0
    fada:	46b1      	mov	r9, r6
	while (mem_link_rx.quota_pdu &&
    fadc:	7833      	ldrb	r3, [r6, #0]
    fade:	b1b3      	cbz	r3, fb0e <rx_alloc+0x3e>
 */
static inline bool mfifo_enqueue_idx_get(u8_t count, u8_t first, u8_t last,
					 u8_t *idx)
{
	/* Non-destructive: Advance write-index modulo 'count' */
	last = last + 1;
    fae0:	78fc      	ldrb	r4, [r7, #3]
	if (last == count) {
    fae2:	787a      	ldrb	r2, [r7, #1]
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
    fae4:	78bb      	ldrb	r3, [r7, #2]
	last = last + 1;
    fae6:	3401      	adds	r4, #1
    fae8:	b2e4      	uxtb	r4, r4
		last = 0U;
    faea:	42a2      	cmp	r2, r4
    faec:	bf08      	it	eq
    faee:	2400      	moveq	r4, #0
	 * We want to maintain the invariant of emptiness defined by
	 * first == last, but we just advanced a copy of the write-index before
	 * and may have wrapped. So if first == last the queue is full and we
	 * can not continue
	 */
	if (last == first) {
    faf0:	42a3      	cmp	r3, r4
    faf2:	d00c      	beq.n	fb0e <rx_alloc+0x3e>
		memq_link_t *link;
		struct node_rx_hdr *rx;

		link = mem_acquire(&mem_link_rx.free);
    faf4:	482b      	ldr	r0, [pc, #172]	; (fba4 <rx_alloc+0xd4>)
    faf6:	f00d f9b9 	bl	1ce6c <mem_acquire>
		if (!link) {
    fafa:	4605      	mov	r5, r0
    fafc:	b138      	cbz	r0, fb0e <rx_alloc+0x3e>
			break;
		}

		rx = mem_acquire(&mem_pdu_rx.free);
    fafe:	482a      	ldr	r0, [pc, #168]	; (fba8 <rx_alloc+0xd8>)
    fb00:	f00d f9b4 	bl	1ce6c <mem_acquire>
		if (!rx) {
    fb04:	bb00      	cbnz	r0, fb48 <rx_alloc+0x78>
			mem_release(link, &mem_link_rx.free);
    fb06:	4927      	ldr	r1, [pc, #156]	; (fba4 <rx_alloc+0xd4>)
    fb08:	4628      	mov	r0, r5
    fb0a:	f00d f9c8 	bl	1ce9e <mem_release>

		ll_rx_link_inc_quota(-1);
	}
#endif /* CONFIG_BT_CONN */

	if (max > mem_link_rx.quota_pdu) {
    fb0e:	f899 6000 	ldrb.w	r6, [r9]

	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
		memq_link_t *link;
		struct node_rx_hdr *rx;

		link = mem_acquire(&mem_link_rx.free);
    fb12:	4f24      	ldr	r7, [pc, #144]	; (fba4 <rx_alloc+0xd4>)
    fb14:	4546      	cmp	r6, r8
    fb16:	bf28      	it	cs
    fb18:	4646      	movcs	r6, r8
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
    fb1a:	f8df 8090 	ldr.w	r8, [pc, #144]	; fbac <rx_alloc+0xdc>
    fb1e:	b18e      	cbz	r6, fb44 <rx_alloc+0x74>
	last = last + 1;
    fb20:	f898 4003 	ldrb.w	r4, [r8, #3]
	if (last == count) {
    fb24:	f898 2001 	ldrb.w	r2, [r8, #1]
    fb28:	f898 3002 	ldrb.w	r3, [r8, #2]
	last = last + 1;
    fb2c:	3401      	adds	r4, #1
    fb2e:	b2e4      	uxtb	r4, r4
		last = 0U;
    fb30:	42a2      	cmp	r2, r4
    fb32:	bf08      	it	eq
    fb34:	2400      	moveq	r4, #0
	if (last == first) {
    fb36:	42a3      	cmp	r3, r4
    fb38:	d004      	beq.n	fb44 <rx_alloc+0x74>
		link = mem_acquire(&mem_link_rx.free);
    fb3a:	4638      	mov	r0, r7
    fb3c:	f00d f996 	bl	1ce6c <mem_acquire>
		if (!link) {
    fb40:	4605      	mov	r5, r0
    fb42:	b978      	cbnz	r0, fb64 <rx_alloc+0x94>

		MFIFO_BY_IDX_ENQUEUE(pdu_rx_free, idx, rx);

		ll_rx_link_inc_quota(-1);
	}
}
    fb44:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		link->mem = NULL;
    fb48:	2300      	movs	r3, #0
    fb4a:	606b      	str	r3, [r5, #4]
		rx->link = link;
    fb4c:	6005      	str	r5, [r0, #0]
 */
static inline void mfifo_by_idx_enqueue(u8_t *fifo, u8_t size, u8_t idx,
					void *mem, u8_t *last)
{
	/* API 2: fifo is array of void-ptrs */
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    fb4e:	78fa      	ldrb	r2, [r7, #3]
    fb50:	783b      	ldrb	r3, [r7, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    fb52:	fb02 7303 	mla	r3, r2, r3, r7
    fb56:	6058      	str	r0, [r3, #4]

	*last = idx; /* Commit: Update write index */
    fb58:	70fc      	strb	r4, [r7, #3]
		ll_rx_link_inc_quota(-1);
    fb5a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    fb5e:	f7ff ff95 	bl	fa8c <ll_rx_link_inc_quota>
    fb62:	e7bb      	b.n	fadc <rx_alloc+0xc>
		rx = mem_acquire(&mem_pdu_rx.free);
    fb64:	4810      	ldr	r0, [pc, #64]	; (fba8 <rx_alloc+0xd8>)
    fb66:	f00d f981 	bl	1ce6c <mem_acquire>
		if (!rx) {
    fb6a:	b928      	cbnz	r0, fb78 <rx_alloc+0xa8>
			mem_release(link, &mem_link_rx.free);
    fb6c:	4628      	mov	r0, r5
    fb6e:	490d      	ldr	r1, [pc, #52]	; (fba4 <rx_alloc+0xd4>)
}
    fb70:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			mem_release(link, &mem_link_rx.free);
    fb74:	f00d b993 	b.w	1ce9e <mem_release>
		rx->link = link;
    fb78:	6005      	str	r5, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    fb7a:	f898 2003 	ldrb.w	r2, [r8, #3]
    fb7e:	f898 3000 	ldrb.w	r3, [r8]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    fb82:	fb02 8303 	mla	r3, r2, r3, r8
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
    fb86:	3e01      	subs	r6, #1
    fb88:	6058      	str	r0, [r3, #4]
	*last = idx; /* Commit: Update write index */
    fb8a:	f888 4003 	strb.w	r4, [r8, #3]
		ll_rx_link_inc_quota(-1);
    fb8e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
    fb92:	b2f6      	uxtb	r6, r6
		ll_rx_link_inc_quota(-1);
    fb94:	f7ff ff7a 	bl	fa8c <ll_rx_link_inc_quota>
    fb98:	e7c1      	b.n	fb1e <rx_alloc+0x4e>
    fb9a:	bf00      	nop
    fb9c:	20000a44 	.word	0x20000a44
    fba0:	200056fc 	.word	0x200056fc
    fba4:	20000a48 	.word	0x20000a48
    fba8:	20000a9c 	.word	0x20000a9c
    fbac:	20005710 	.word	0x20005710

0000fbb0 <init_reset>:
	mem_init(mem_done.pool, sizeof(struct node_rx_event_done),
    fbb0:	4b3a      	ldr	r3, [pc, #232]	; (fc9c <init_reset+0xec>)
{
    fbb2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	mem_init(mem_done.pool, sizeof(struct node_rx_event_done),
    fbb6:	1d18      	adds	r0, r3, #4
    fbb8:	2203      	movs	r2, #3
    fbba:	2138      	movs	r1, #56	; 0x38
    fbbc:	f00d f932 	bl	1ce24 <mem_init>
	mem_init(mem_link_done.pool, sizeof(memq_link_t), EVENT_DONE_MAX,
    fbc0:	4b37      	ldr	r3, [pc, #220]	; (fca0 <init_reset+0xf0>)
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
    fbc2:	4d38      	ldr	r5, [pc, #224]	; (fca4 <init_reset+0xf4>)
		link = mem_acquire(&mem_link_done.free);
    fbc4:	f8df 80d8 	ldr.w	r8, [pc, #216]	; fca0 <init_reset+0xf0>
	mem_init(mem_link_done.pool, sizeof(memq_link_t), EVENT_DONE_MAX,
    fbc8:	2203      	movs	r2, #3
    fbca:	2108      	movs	r1, #8
    fbcc:	1d18      	adds	r0, r3, #4
    fbce:	f00d f929 	bl	1ce24 <mem_init>
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
    fbd2:	462e      	mov	r6, r5
	last = last + 1;
    fbd4:	78ec      	ldrb	r4, [r5, #3]
	if (last == count) {
    fbd6:	786a      	ldrb	r2, [r5, #1]
    fbd8:	78ab      	ldrb	r3, [r5, #2]
	last = last + 1;
    fbda:	3401      	adds	r4, #1
    fbdc:	b2e4      	uxtb	r4, r4
		last = 0U;
    fbde:	42a2      	cmp	r2, r4
    fbe0:	bf08      	it	eq
    fbe2:	2400      	moveq	r4, #0
	if (last == first) {
    fbe4:	429c      	cmp	r4, r3
    fbe6:	d00d      	beq.n	fc04 <init_reset+0x54>
		link = mem_acquire(&mem_link_done.free);
    fbe8:	4640      	mov	r0, r8
    fbea:	f00d f93f 	bl	1ce6c <mem_acquire>
		if (!link) {
    fbee:	4607      	mov	r7, r0
    fbf0:	b140      	cbz	r0, fc04 <init_reset+0x54>
		rx = mem_acquire(&mem_done.free);
    fbf2:	482a      	ldr	r0, [pc, #168]	; (fc9c <init_reset+0xec>)
    fbf4:	f00d f93a 	bl	1ce6c <mem_acquire>
		if (!rx) {
    fbf8:	2800      	cmp	r0, #0
    fbfa:	d146      	bne.n	fc8a <init_reset+0xda>
			mem_release(link, &mem_link_done.free);
    fbfc:	4928      	ldr	r1, [pc, #160]	; (fca0 <init_reset+0xf0>)
    fbfe:	4638      	mov	r0, r7
    fc00:	f00d f94d 	bl	1ce9e <mem_release>
	mem_init(mem_pdu_rx.pool, (PDU_RX_NODE_POOL_ELEMENT_SIZE),
    fc04:	4b28      	ldr	r3, [pc, #160]	; (fca8 <init_reset+0xf8>)
    fc06:	2208      	movs	r2, #8
    fc08:	1d18      	adds	r0, r3, #4
    fc0a:	214c      	movs	r1, #76	; 0x4c
    fc0c:	f00d f90a 	bl	1ce24 <mem_init>
	mem_init(mem_link_rx.pool, sizeof(memq_link_t),
    fc10:	4b26      	ldr	r3, [pc, #152]	; (fcac <init_reset+0xfc>)
    fc12:	220a      	movs	r2, #10
    fc14:	1d18      	adds	r0, r3, #4
    fc16:	2108      	movs	r1, #8
    fc18:	f00d f904 	bl	1ce24 <mem_init>
	link = mem_acquire(&mem_link_rx.free);
    fc1c:	4823      	ldr	r0, [pc, #140]	; (fcac <init_reset+0xfc>)
    fc1e:	f00d f925 	bl	1ce6c <mem_acquire>
	LL_ASSERT(link);
    fc22:	4604      	mov	r4, r0
    fc24:	b960      	cbnz	r0, fc40 <init_reset+0x90>
    fc26:	f240 43bb 	movw	r3, #1211	; 0x4bb
    fc2a:	4a21      	ldr	r2, [pc, #132]	; (fcb0 <init_reset+0x100>)
    fc2c:	4921      	ldr	r1, [pc, #132]	; (fcb4 <init_reset+0x104>)
    fc2e:	4822      	ldr	r0, [pc, #136]	; (fcb8 <init_reset+0x108>)
    fc30:	f009 fba0 	bl	19374 <printk>
    fc34:	4040      	eors	r0, r0
    fc36:	f380 8811 	msr	BASEPRI, r0
    fc3a:	f04f 0003 	mov.w	r0, #3
    fc3e:	df02      	svc	2
	MEMQ_INIT(ull_rx, link);
    fc40:	4a1e      	ldr	r2, [pc, #120]	; (fcbc <init_reset+0x10c>)
    fc42:	4620      	mov	r0, r4
    fc44:	1f11      	subs	r1, r2, #4
    fc46:	f00d f961 	bl	1cf0c <memq_init>
	link = mem_acquire(&mem_link_rx.free);
    fc4a:	4818      	ldr	r0, [pc, #96]	; (fcac <init_reset+0xfc>)
    fc4c:	f00d f90e 	bl	1ce6c <mem_acquire>
	LL_ASSERT(link);
    fc50:	4604      	mov	r4, r0
    fc52:	b960      	cbnz	r0, fc6e <init_reset+0xbe>
    fc54:	f240 43c2 	movw	r3, #1218	; 0x4c2
    fc58:	4a15      	ldr	r2, [pc, #84]	; (fcb0 <init_reset+0x100>)
    fc5a:	4916      	ldr	r1, [pc, #88]	; (fcb4 <init_reset+0x104>)
    fc5c:	4816      	ldr	r0, [pc, #88]	; (fcb8 <init_reset+0x108>)
    fc5e:	f009 fb89 	bl	19374 <printk>
    fc62:	4040      	eors	r0, r0
    fc64:	f380 8811 	msr	BASEPRI, r0
    fc68:	f04f 0003 	mov.w	r0, #3
    fc6c:	df02      	svc	2
	MEMQ_INIT(ll_rx, link);
    fc6e:	4a14      	ldr	r2, [pc, #80]	; (fcc0 <init_reset+0x110>)
    fc70:	4620      	mov	r0, r4
    fc72:	1f11      	subs	r1, r2, #4
    fc74:	f00d f94a 	bl	1cf0c <memq_init>
	mem_link_rx.quota_pdu = RX_CNT;
    fc78:	4b12      	ldr	r3, [pc, #72]	; (fcc4 <init_reset+0x114>)
    fc7a:	2207      	movs	r2, #7
	rx_alloc(UINT8_MAX);
    fc7c:	20ff      	movs	r0, #255	; 0xff
	mem_link_rx.quota_pdu = RX_CNT;
    fc7e:	701a      	strb	r2, [r3, #0]
	rx_alloc(UINT8_MAX);
    fc80:	f7ff ff26 	bl	fad0 <rx_alloc>
}
    fc84:	2000      	movs	r0, #0
    fc86:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		rx->link = link;
    fc8a:	6007      	str	r7, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    fc8c:	78f2      	ldrb	r2, [r6, #3]
    fc8e:	7833      	ldrb	r3, [r6, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    fc90:	fb02 6303 	mla	r3, r2, r3, r6
    fc94:	6058      	str	r0, [r3, #4]
	*last = idx; /* Commit: Update write index */
    fc96:	70f4      	strb	r4, [r6, #3]
    fc98:	e79c      	b.n	fbd4 <init_reset+0x24>
    fc9a:	bf00      	nop
    fc9c:	2000097c 	.word	0x2000097c
    fca0:	20000a28 	.word	0x20000a28
    fca4:	200056e8 	.word	0x200056e8
    fca8:	20000a9c 	.word	0x20000a9c
    fcac:	20000a48 	.word	0x20000a48
    fcb0:	00021b31 	.word	0x00021b31
    fcb4:	00021fdb 	.word	0x00021fdb
    fcb8:	00020aa4 	.word	0x00020aa4
    fcbc:	20000d0c 	.word	0x20000d0c
    fcc0:	20000d04 	.word	0x20000d04
    fcc4:	20000a44 	.word	0x20000a44

0000fcc8 <perform_lll_reset>:
{
    fcc8:	b510      	push	{r4, lr}
    fcca:	4604      	mov	r4, r0
	err = lll_reset();
    fccc:	f00d fb6c 	bl	1d3a8 <lll_reset>
	LL_ASSERT(!err);
    fcd0:	b160      	cbz	r0, fcec <perform_lll_reset+0x24>
    fcd2:	f240 43d4 	movw	r3, #1236	; 0x4d4
    fcd6:	4a18      	ldr	r2, [pc, #96]	; (fd38 <perform_lll_reset+0x70>)
    fcd8:	4918      	ldr	r1, [pc, #96]	; (fd3c <perform_lll_reset+0x74>)
    fcda:	4819      	ldr	r0, [pc, #100]	; (fd40 <perform_lll_reset+0x78>)
    fcdc:	f009 fb4a 	bl	19374 <printk>
    fce0:	4040      	eors	r0, r0
    fce2:	f380 8811 	msr	BASEPRI, r0
    fce6:	f04f 0003 	mov.w	r0, #3
    fcea:	df02      	svc	2
	err = lll_adv_reset();
    fcec:	f00d fc18 	bl	1d520 <lll_adv_reset>
	LL_ASSERT(!err);
    fcf0:	b160      	cbz	r0, fd0c <perform_lll_reset+0x44>
    fcf2:	f240 43d9 	movw	r3, #1241	; 0x4d9
    fcf6:	4a10      	ldr	r2, [pc, #64]	; (fd38 <perform_lll_reset+0x70>)
    fcf8:	4910      	ldr	r1, [pc, #64]	; (fd3c <perform_lll_reset+0x74>)
    fcfa:	4811      	ldr	r0, [pc, #68]	; (fd40 <perform_lll_reset+0x78>)
    fcfc:	f009 fb3a 	bl	19374 <printk>
    fd00:	4040      	eors	r0, r0
    fd02:	f380 8811 	msr	BASEPRI, r0
    fd06:	f04f 0003 	mov.w	r0, #3
    fd0a:	df02      	svc	2
	err = lll_conn_reset();
    fd0c:	f00d fe3d 	bl	1d98a <lll_conn_reset>
	LL_ASSERT(!err);
    fd10:	b160      	cbz	r0, fd2c <perform_lll_reset+0x64>
    fd12:	f240 43e5 	movw	r3, #1253	; 0x4e5
    fd16:	4a08      	ldr	r2, [pc, #32]	; (fd38 <perform_lll_reset+0x70>)
    fd18:	4908      	ldr	r1, [pc, #32]	; (fd3c <perform_lll_reset+0x74>)
    fd1a:	4809      	ldr	r0, [pc, #36]	; (fd40 <perform_lll_reset+0x78>)
    fd1c:	f009 fb2a 	bl	19374 <printk>
    fd20:	4040      	eors	r0, r0
    fd22:	f380 8811 	msr	BASEPRI, r0
    fd26:	f04f 0003 	mov.w	r0, #3
    fd2a:	df02      	svc	2
	z_impl_k_sem_give(sem);
    fd2c:	4620      	mov	r0, r4
}
    fd2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fd32:	f008 bba7 	b.w	18484 <z_impl_k_sem_give>
    fd36:	bf00      	nop
    fd38:	00021b31 	.word	0x00021b31
    fd3c:	00021bdb 	.word	0x00021bdb
    fd40:	00020aa4 	.word	0x00020aa4

0000fd44 <tx_cmplt_get>:

#if defined(CONFIG_BT_CONN)
static u8_t tx_cmplt_get(u16_t *handle, u8_t *first, u8_t last)
{
    fd44:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    fd48:	460d      	mov	r5, r1
	struct lll_tx *tx;
	u8_t cmplt;

	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
    fd4a:	4e28      	ldr	r6, [pc, #160]	; (fdec <tx_cmplt_get+0xa8>)
					   u8_t first, u8_t last, u8_t *idx)
{
	void *p;
	u8_t i;

	if (*idx >= count) {
    fd4c:	782b      	ldrb	r3, [r5, #0]
    fd4e:	7871      	ldrb	r1, [r6, #1]
    fd50:	428b      	cmp	r3, r1
    fd52:	bf28      	it	cs
    fd54:	78b3      	ldrbcs	r3, [r6, #2]
{
    fd56:	4680      	mov	r8, r0
	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
    fd58:	7830      	ldrb	r0, [r6, #0]
		*idx = first;
    fd5a:	bf28      	it	cs
    fd5c:	702b      	strbcs	r3, [r5, #0]
	}

	if (*idx == last) {
    fd5e:	782b      	ldrb	r3, [r5, #0]
    fd60:	429a      	cmp	r2, r3
{
    fd62:	4691      	mov	r9, r2
    fd64:	d103      	bne.n	fd6e <tx_cmplt_get+0x2a>
				    mfifo_tx_ack.n, mfifo_tx_ack.f, last,
				    first);
	if (!tx) {
		return 0;
    fd66:	2700      	movs	r7, #0
					    mfifo_tx_ack.n, mfifo_tx_ack.f,
					    last, first);
	} while (tx && tx->handle == *handle);

	return cmplt;
}
    fd68:	4638      	mov	r0, r7
    fd6a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return NULL;
	}

	i = *idx + 1;
    fd6e:	1c5a      	adds	r2, r3, #1
    fd70:	b2d2      	uxtb	r2, r2
	if (i == count) {
		i = 0U;
	}

	p = (void *)(fifo + (*idx) * size);
    fd72:	4c1f      	ldr	r4, [pc, #124]	; (fdf0 <tx_cmplt_get+0xac>)
		i = 0U;
    fd74:	4291      	cmp	r1, r2
    fd76:	bf08      	it	eq
    fd78:	2200      	moveq	r2, #0
	p = (void *)(fifo + (*idx) * size);
    fd7a:	fb13 f300 	smulbb	r3, r3, r0

	*idx = i;
    fd7e:	702a      	strb	r2, [r5, #0]
	if (!tx) {
    fd80:	18e2      	adds	r2, r4, r3
    fd82:	d0f0      	beq.n	fd66 <tx_cmplt_get+0x22>
	*handle = tx->handle;
    fd84:	5ae3      	ldrh	r3, [r4, r3]
    fd86:	f8a8 3000 	strh.w	r3, [r8]
	cmplt = 0U;
    fd8a:	2700      	movs	r7, #0
		node_tx = tx->node;
    fd8c:	6850      	ldr	r0, [r2, #4]
		if (!node_tx || (node_tx == (void *)1) ||
    fd8e:	2801      	cmp	r0, #1
    fd90:	f020 0103 	bic.w	r1, r0, #3
    fd94:	d906      	bls.n	fda4 <tx_cmplt_get+0x60>
    fd96:	b331      	cbz	r1, fde6 <tx_cmplt_get+0xa2>
		     (p->ll_id == PDU_DATA_LLID_DATA_START ||
    fd98:	7903      	ldrb	r3, [r0, #4]
    fd9a:	f003 0303 	and.w	r3, r3, #3
		    (((u32_t)node_tx & ~3) &&
    fd9e:	3b01      	subs	r3, #1
    fda0:	2b01      	cmp	r3, #1
    fda2:	d820      	bhi.n	fde6 <tx_cmplt_get+0xa2>
			cmplt++;
    fda4:	3701      	adds	r7, #1
    fda6:	b2ff      	uxtb	r7, r7
			tx->node = (void *)1;
    fda8:	2301      	movs	r3, #1
    fdaa:	6053      	str	r3, [r2, #4]
		if (((u32_t)node_tx & ~3)) {
    fdac:	b109      	cbz	r1, fdb2 <tx_cmplt_get+0x6e>
			ll_tx_mem_release(node_tx);
    fdae:	f002 fab9 	bl	12324 <ll_tx_mem_release>
	if (*idx >= count) {
    fdb2:	782b      	ldrb	r3, [r5, #0]
		tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
    fdb4:	7872      	ldrb	r2, [r6, #1]
    fdb6:	7830      	ldrb	r0, [r6, #0]
    fdb8:	4293      	cmp	r3, r2
    fdba:	bf24      	itt	cs
    fdbc:	78b3      	ldrbcs	r3, [r6, #2]
		*idx = first;
    fdbe:	702b      	strbcs	r3, [r5, #0]
	if (*idx == last) {
    fdc0:	782b      	ldrb	r3, [r5, #0]
    fdc2:	4599      	cmp	r9, r3
    fdc4:	d0d0      	beq.n	fd68 <tx_cmplt_get+0x24>
	i = *idx + 1;
    fdc6:	1c59      	adds	r1, r3, #1
    fdc8:	b2c9      	uxtb	r1, r1
	p = (void *)(fifo + (*idx) * size);
    fdca:	fb13 f300 	smulbb	r3, r3, r0
		i = 0U;
    fdce:	428a      	cmp	r2, r1
    fdd0:	bf08      	it	eq
    fdd2:	2100      	moveq	r1, #0
	} while (tx && tx->handle == *handle);
    fdd4:	18e2      	adds	r2, r4, r3
	*idx = i;
    fdd6:	7029      	strb	r1, [r5, #0]
    fdd8:	d0c6      	beq.n	fd68 <tx_cmplt_get+0x24>
    fdda:	5ae3      	ldrh	r3, [r4, r3]
    fddc:	f8b8 1000 	ldrh.w	r1, [r8]
    fde0:	4299      	cmp	r1, r3
    fde2:	d0d3      	beq.n	fd8c <tx_cmplt_get+0x48>
    fde4:	e7c0      	b.n	fd68 <tx_cmplt_get+0x24>
			tx->node = (void *)2;
    fde6:	2302      	movs	r3, #2
    fde8:	e7df      	b.n	fdaa <tx_cmplt_get+0x66>
    fdea:	bf00      	nop
    fdec:	2000584c 	.word	0x2000584c
    fdf0:	20005850 	.word	0x20005850

0000fdf4 <ll_init>:
{
    fdf4:	b510      	push	{r4, lr}
	sem_recv = sem_rx;
    fdf6:	4b28      	ldr	r3, [pc, #160]	; (fe98 <ll_init+0xa4>)
{
    fdf8:	b086      	sub	sp, #24
	sem_recv = sem_rx;
    fdfa:	6018      	str	r0, [r3, #0]
	cntr_init();
    fdfc:	f005 fda4 	bl	15948 <cntr_init>
	mayfly_init();
    fe00:	f7fd fe1a 	bl	da38 <mayfly_init>
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
    fe04:	4a25      	ldr	r2, [pc, #148]	; (fe9c <ll_init+0xa8>)
    fe06:	2103      	movs	r1, #3
    fe08:	7011      	strb	r1, [r2, #0]
	ticker_users[MAYFLY_CALL_ID_PROGRAM][0] = TICKER_USER_APP_OPS;
    fe0a:	7611      	strb	r1, [r2, #24]
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
    fe0c:	2002      	movs	r0, #2
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
    fe0e:	4924      	ldr	r1, [pc, #144]	; (fea0 <ll_init+0xac>)
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
    fe10:	7410      	strb	r0, [r2, #16]
	ticker_users[MAYFLY_CALL_ID_1][0] = TICKER_USER_ULL_HIGH_OPS;
    fe12:	2304      	movs	r3, #4
    fe14:	7213      	strb	r3, [r2, #8]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
    fe16:	9105      	str	r1, [sp, #20]
    fe18:	4922      	ldr	r1, [pc, #136]	; (fea4 <ll_init+0xb0>)
    fe1a:	9104      	str	r1, [sp, #16]
    fe1c:	4922      	ldr	r1, [pc, #136]	; (fea8 <ll_init+0xb4>)
    fe1e:	9103      	str	r1, [sp, #12]
    fe20:	4922      	ldr	r1, [pc, #136]	; (feac <ll_init+0xb8>)
    fe22:	9102      	str	r1, [sp, #8]
    fe24:	210c      	movs	r1, #12
    fe26:	e9cd 2100 	strd	r2, r1, [sp]
    fe2a:	2000      	movs	r0, #0
    fe2c:	4a20      	ldr	r2, [pc, #128]	; (feb0 <ll_init+0xbc>)
    fe2e:	2105      	movs	r1, #5
    fe30:	f7fe fa78 	bl	e324 <ticker_init>
	LL_ASSERT(!err);
    fe34:	b160      	cbz	r0, fe50 <ll_init+0x5c>
    fe36:	f240 130f 	movw	r3, #271	; 0x10f
    fe3a:	4a1e      	ldr	r2, [pc, #120]	; (feb4 <ll_init+0xc0>)
    fe3c:	491e      	ldr	r1, [pc, #120]	; (feb8 <ll_init+0xc4>)
    fe3e:	481f      	ldr	r0, [pc, #124]	; (febc <ll_init+0xc8>)
    fe40:	f009 fa98 	bl	19374 <printk>
    fe44:	4040      	eors	r0, r0
    fe46:	f380 8811 	msr	BASEPRI, r0
    fe4a:	f04f 0003 	mov.w	r0, #3
    fe4e:	df02      	svc	2
	z_impl_k_sem_init(sem, initial_count, limit);
    fe50:	2201      	movs	r2, #1
    fe52:	2100      	movs	r1, #0
    fe54:	481a      	ldr	r0, [pc, #104]	; (fec0 <ll_init+0xcc>)
    fe56:	f00e fbfb 	bl	1e650 <z_impl_k_sem_init>
	err = lll_init();
    fe5a:	f000 ff3b 	bl	10cd4 <lll_init>
	if (err) {
    fe5e:	4604      	mov	r4, r0
    fe60:	b9b0      	cbnz	r0, fe90 <ll_init+0x9c>
	err = init_reset();
    fe62:	f7ff fea5 	bl	fbb0 <init_reset>
	if (err) {
    fe66:	4604      	mov	r4, r0
    fe68:	b990      	cbnz	r0, fe90 <ll_init+0x9c>
	err = lll_adv_init();
    fe6a:	f00d fb57 	bl	1d51c <lll_adv_init>
	if (err) {
    fe6e:	4604      	mov	r4, r0
    fe70:	b970      	cbnz	r0, fe90 <ll_init+0x9c>
	err = ull_adv_init();
    fe72:	f00d fac5 	bl	1d400 <ull_adv_init>
	if (err) {
    fe76:	4604      	mov	r4, r0
    fe78:	b950      	cbnz	r0, fe90 <ll_init+0x9c>
	err = lll_conn_init();
    fe7a:	f00d fd84 	bl	1d986 <lll_conn_init>
	if (err) {
    fe7e:	4604      	mov	r4, r0
    fe80:	b930      	cbnz	r0, fe90 <ll_init+0x9c>
	err = ull_conn_init();
    fe82:	f002 fad9 	bl	12438 <ull_conn_init>
	if (err) {
    fe86:	4604      	mov	r4, r0
    fe88:	b910      	cbnz	r0, fe90 <ll_init+0x9c>
		ull_filter_reset(true);
    fe8a:	2001      	movs	r0, #1
    fe8c:	f005 fc08 	bl	156a0 <ull_filter_reset>
}
    fe90:	4620      	mov	r0, r4
    fe92:	b006      	add	sp, #24
    fe94:	bd10      	pop	{r4, pc}
    fe96:	bf00      	nop
    fe98:	20000d10 	.word	0x20000d10
    fe9c:	20001048 	.word	0x20001048
    fea0:	0001dbd3 	.word	0x0001dbd3
    fea4:	00016329 	.word	0x00016329
    fea8:	000162d1 	.word	0x000162d1
    feac:	20000e08 	.word	0x20000e08
    feb0:	20000d2c 	.word	0x20000d2c
    feb4:	00021b31 	.word	0x00021b31
    feb8:	00021bdb 	.word	0x00021bdb
    febc:	00020aa4 	.word	0x00020aa4
    fec0:	20000d14 	.word	0x20000d14

0000fec4 <ll_reset>:
{
    fec4:	b510      	push	{r4, lr}
    fec6:	b086      	sub	sp, #24
	err = ull_adv_reset();
    fec8:	f00d fa9c 	bl	1d404 <ull_adv_reset>
	LL_ASSERT(!err);
    fecc:	b160      	cbz	r0, fee8 <ll_reset+0x24>
    fece:	f240 135d 	movw	r3, #349	; 0x15d
    fed2:	4a2d      	ldr	r2, [pc, #180]	; (ff88 <ll_reset+0xc4>)
    fed4:	492d      	ldr	r1, [pc, #180]	; (ff8c <ll_reset+0xc8>)
    fed6:	482e      	ldr	r0, [pc, #184]	; (ff90 <ll_reset+0xcc>)
    fed8:	f009 fa4c 	bl	19374 <printk>
    fedc:	4040      	eors	r0, r0
    fede:	f380 8811 	msr	BASEPRI, r0
    fee2:	f04f 0003 	mov.w	r0, #3
    fee6:	df02      	svc	2
	err = ull_conn_reset();
    fee8:	f002 fab8 	bl	1245c <ull_conn_reset>
	LL_ASSERT(!err);
    feec:	b160      	cbz	r0, ff08 <ll_reset+0x44>
    feee:	f240 137d 	movw	r3, #381	; 0x17d
    fef2:	4a25      	ldr	r2, [pc, #148]	; (ff88 <ll_reset+0xc4>)
    fef4:	4925      	ldr	r1, [pc, #148]	; (ff8c <ll_reset+0xc8>)
    fef6:	4826      	ldr	r0, [pc, #152]	; (ff90 <ll_reset+0xcc>)
    fef8:	f009 fa3c 	bl	19374 <printk>
    fefc:	4040      	eors	r0, r0
    fefe:	f380 8811 	msr	BASEPRI, r0
    ff02:	f04f 0003 	mov.w	r0, #3
    ff06:	df02      	svc	2
	MFIFO_INIT(tx_ack);
    ff08:	4b22      	ldr	r3, [pc, #136]	; (ff94 <ll_reset+0xd0>)
    ff0a:	2400      	movs	r4, #0
    ff0c:	805c      	strh	r4, [r3, #2]
		ull_filter_reset(false);
    ff0e:	4620      	mov	r0, r4
    ff10:	f005 fbc6 	bl	156a0 <ull_filter_reset>
	MFIFO_INIT(prep);
    ff14:	4b20      	ldr	r3, [pc, #128]	; (ff98 <ll_reset+0xd4>)
    ff16:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(done);
    ff18:	4b20      	ldr	r3, [pc, #128]	; (ff9c <ll_reset+0xd8>)
    ff1a:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(pdu_rx_free);
    ff1c:	4b20      	ldr	r3, [pc, #128]	; (ffa0 <ll_reset+0xdc>)
    ff1e:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(ll_pdu_rx_free);
    ff20:	4b20      	ldr	r3, [pc, #128]	; (ffa4 <ll_reset+0xe0>)
    ff22:	805c      	strh	r4, [r3, #2]
    ff24:	2201      	movs	r2, #1
    ff26:	4621      	mov	r1, r4
    ff28:	4668      	mov	r0, sp
    ff2a:	f00e fb91 	bl	1e650 <z_impl_k_sem_init>
		mfy.param = &sem;
    ff2e:	4b1e      	ldr	r3, [pc, #120]	; (ffa8 <ll_reset+0xe4>)
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
    ff30:	4622      	mov	r2, r4
    ff32:	4621      	mov	r1, r4
    ff34:	2003      	movs	r0, #3
		mfy.param = &sem;
    ff36:	f8c3 d008 	str.w	sp, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
    ff3a:	f7fd fdcf 	bl	dadc <mayfly_enqueue>
		LL_ASSERT(!retval);
    ff3e:	b160      	cbz	r0, ff5a <ll_reset+0x96>
    ff40:	f240 13af 	movw	r3, #431	; 0x1af
    ff44:	4a10      	ldr	r2, [pc, #64]	; (ff88 <ll_reset+0xc4>)
    ff46:	4919      	ldr	r1, [pc, #100]	; (ffac <ll_reset+0xe8>)
    ff48:	4811      	ldr	r0, [pc, #68]	; (ff90 <ll_reset+0xcc>)
    ff4a:	f009 fa13 	bl	19374 <printk>
    ff4e:	4040      	eors	r0, r0
    ff50:	f380 8811 	msr	BASEPRI, r0
    ff54:	f04f 0003 	mov.w	r0, #3
    ff58:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
    ff5a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    ff5e:	4668      	mov	r0, sp
    ff60:	f008 fabc 	bl	184dc <z_impl_k_sem_take>
	err = init_reset();
    ff64:	f7ff fe24 	bl	fbb0 <init_reset>
	LL_ASSERT(!err);
    ff68:	b160      	cbz	r0, ff84 <ll_reset+0xc0>
    ff6a:	f240 13bb 	movw	r3, #443	; 0x1bb
    ff6e:	4a06      	ldr	r2, [pc, #24]	; (ff88 <ll_reset+0xc4>)
    ff70:	4906      	ldr	r1, [pc, #24]	; (ff8c <ll_reset+0xc8>)
    ff72:	4807      	ldr	r0, [pc, #28]	; (ff90 <ll_reset+0xcc>)
    ff74:	f009 f9fe 	bl	19374 <printk>
    ff78:	4040      	eors	r0, r0
    ff7a:	f380 8811 	msr	BASEPRI, r0
    ff7e:	f04f 0003 	mov.w	r0, #3
    ff82:	df02      	svc	2
}
    ff84:	b006      	add	sp, #24
    ff86:	bd10      	pop	{r4, pc}
    ff88:	00021b31 	.word	0x00021b31
    ff8c:	00021bdb 	.word	0x00021bdb
    ff90:	00020aa4 	.word	0x00020aa4
    ff94:	2000584c 	.word	0x2000584c
    ff98:	20005728 	.word	0x20005728
    ff9c:	200056e8 	.word	0x200056e8
    ffa0:	20005710 	.word	0x20005710
    ffa4:	200056fc 	.word	0x200056fc
    ffa8:	20005870 	.word	0x20005870
    ffac:	00021aea 	.word	0x00021aea

0000ffb0 <ll_rx_get>:
{
    ffb0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
    ffb4:	4d25      	ldr	r5, [pc, #148]	; (1004c <__kernel_ram_size+0x4c>)
    ffb6:	4e26      	ldr	r6, [pc, #152]	; (10050 <__kernel_ram_size+0x50>)
{
    ffb8:	4680      	mov	r8, r0
    ffba:	460f      	mov	r7, r1
    ffbc:	46aa      	mov	sl, r5
	*node_rx = NULL;
    ffbe:	2300      	movs	r3, #0
    ffc0:	f8c8 3000 	str.w	r3, [r8]
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
    ffc4:	aa01      	add	r2, sp, #4
    ffc6:	e9d5 0100 	ldrd	r0, r1, [r5]
    ffca:	f00c ffb4 	bl	1cf36 <memq_peek>
	if (link) {
    ffce:	4681      	mov	r9, r0
    ffd0:	b3a0      	cbz	r0, 1003c <__kernel_ram_size+0x3c>
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
    ffd2:	9b01      	ldr	r3, [sp, #4]
    ffd4:	491f      	ldr	r1, [pc, #124]	; (10054 <__kernel_ram_size+0x54>)
    ffd6:	781a      	ldrb	r2, [r3, #0]
    ffd8:	4638      	mov	r0, r7
    ffda:	f7ff feb3 	bl	fd44 <tx_cmplt_get>
		if (!cmplt) {
    ffde:	4604      	mov	r4, r0
    ffe0:	bb40      	cbnz	r0, 10034 <__kernel_ram_size+0x34>
			f = mfifo_tx_ack.f;
    ffe2:	78b3      	ldrb	r3, [r6, #2]
    ffe4:	f88d 3001 	strb.w	r3, [sp, #1]
				cmplt_curr = tx_cmplt_get(&h, &f,
    ffe8:	78f2      	ldrb	r2, [r6, #3]
    ffea:	f10d 0101 	add.w	r1, sp, #1
    ffee:	f10d 0002 	add.w	r0, sp, #2
    fff2:	f7ff fea7 	bl	fd44 <tx_cmplt_get>
				 (cmplt_prev != cmplt_curr));
    fff6:	b9cc      	cbnz	r4, 1002c <__kernel_ram_size+0x2c>
			} while ((cmplt_prev != 0U) ||
    fff8:	b9c0      	cbnz	r0, 1002c <__kernel_ram_size+0x2c>
			if (rx->type == NODE_RX_TYPE_DC_PDU_RELEASE) {
    fffa:	9b01      	ldr	r3, [sp, #4]
    fffc:	791a      	ldrb	r2, [r3, #4]
    fffe:	2a03      	cmp	r2, #3
   10000:	d116      	bne.n	10030 <__kernel_ram_size+0x30>
				(void)memq_dequeue(memq_ll_rx.tail,
   10002:	4622      	mov	r2, r4
   10004:	4629      	mov	r1, r5
   10006:	f8da 0004 	ldr.w	r0, [sl, #4]
   1000a:	f00c ff9c 	bl	1cf46 <memq_dequeue>
				mem_release(link, &mem_link_rx.free);
   1000e:	4912      	ldr	r1, [pc, #72]	; (10058 <__kernel_ram_size+0x58>)
   10010:	4648      	mov	r0, r9
   10012:	f00c ff44 	bl	1ce9e <mem_release>
				ll_rx_link_inc_quota(1);
   10016:	2001      	movs	r0, #1
   10018:	f7ff fd38 	bl	fa8c <ll_rx_link_inc_quota>
				mem_release(rx, &mem_pdu_rx.free);
   1001c:	9801      	ldr	r0, [sp, #4]
   1001e:	490f      	ldr	r1, [pc, #60]	; (1005c <__kernel_ram_size+0x5c>)
   10020:	f00c ff3d 	bl	1ce9e <mem_release>
				rx_alloc(1);
   10024:	2001      	movs	r0, #1
   10026:	f7ff fd53 	bl	fad0 <rx_alloc>
				goto ll_rx_get_again;
   1002a:	e7c8      	b.n	ffbe <ll_rx_get+0xe>
{
   1002c:	4604      	mov	r4, r0
   1002e:	e7db      	b.n	ffe8 <ll_rx_get+0x38>
			*node_rx = rx;
   10030:	f8c8 3000 	str.w	r3, [r8]
}
   10034:	4620      	mov	r0, r4
   10036:	b002      	add	sp, #8
   10038:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, mfifo_tx_ack.l);
   1003c:	78f2      	ldrb	r2, [r6, #3]
   1003e:	4905      	ldr	r1, [pc, #20]	; (10054 <__kernel_ram_size+0x54>)
   10040:	4638      	mov	r0, r7
   10042:	f7ff fe7f 	bl	fd44 <tx_cmplt_get>
   10046:	4604      	mov	r4, r0
   10048:	e7f4      	b.n	10034 <__kernel_ram_size+0x34>
   1004a:	bf00      	nop
   1004c:	20000d00 	.word	0x20000d00
   10050:	2000584c 	.word	0x2000584c
   10054:	2000584e 	.word	0x2000584e
   10058:	20000a48 	.word	0x20000a48
   1005c:	20000a9c 	.word	0x20000a9c

00010060 <ll_rx_dequeue>:
{
   10060:	b573      	push	{r0, r1, r4, r5, r6, lr}
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   10062:	4954      	ldr	r1, [pc, #336]	; (101b4 <ll_rx_dequeue+0x154>)
	struct node_rx_hdr *rx = NULL;
   10064:	2300      	movs	r3, #0
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   10066:	aa01      	add	r2, sp, #4
   10068:	6848      	ldr	r0, [r1, #4]
	struct node_rx_hdr *rx = NULL;
   1006a:	9301      	str	r3, [sp, #4]
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   1006c:	f00c ff6b 	bl	1cf46 <memq_dequeue>
	LL_ASSERT(link);
   10070:	4604      	mov	r4, r0
   10072:	b960      	cbnz	r0, 1008e <ll_rx_dequeue+0x2e>
   10074:	f240 230d 	movw	r3, #525	; 0x20d
   10078:	4a4f      	ldr	r2, [pc, #316]	; (101b8 <ll_rx_dequeue+0x158>)
   1007a:	4950      	ldr	r1, [pc, #320]	; (101bc <ll_rx_dequeue+0x15c>)
   1007c:	4850      	ldr	r0, [pc, #320]	; (101c0 <ll_rx_dequeue+0x160>)
   1007e:	f009 f979 	bl	19374 <printk>
   10082:	4040      	eors	r0, r0
   10084:	f380 8811 	msr	BASEPRI, r0
   10088:	f04f 0003 	mov.w	r0, #3
   1008c:	df02      	svc	2
	mem_release(link, &mem_link_rx.free);
   1008e:	494d      	ldr	r1, [pc, #308]	; (101c4 <ll_rx_dequeue+0x164>)
   10090:	4620      	mov	r0, r4
   10092:	f00c ff04 	bl	1ce9e <mem_release>
	switch (rx->type) {
   10096:	9b01      	ldr	r3, [sp, #4]
   10098:	7919      	ldrb	r1, [r3, #4]
   1009a:	290e      	cmp	r1, #14
   1009c:	f200 8084 	bhi.w	101a8 <ll_rx_dequeue+0x148>
   100a0:	2201      	movs	r2, #1
   100a2:	408a      	lsls	r2, r1
   100a4:	f647 6005 	movw	r0, #32261	; 0x7e05
   100a8:	4202      	tst	r2, r0
   100aa:	d16d      	bne.n	10188 <ll_rx_dequeue+0x128>
   100ac:	05d2      	lsls	r2, r2, #23
   100ae:	d57b      	bpl.n	101a8 <ll_rx_dequeue+0x148>
		} else if ((cc->status == BT_HCI_ERR_ADV_TIMEOUT) || cc->role) {
   100b0:	f893 2020 	ldrb.w	r2, [r3, #32]
   100b4:	2a3c      	cmp	r2, #60	; 0x3c
   100b6:	d003      	beq.n	100c0 <ll_rx_dequeue+0x60>
   100b8:	f893 1021 	ldrb.w	r1, [r3, #33]	; 0x21
   100bc:	2900      	cmp	r1, #0
   100be:	d055      	beq.n	1016c <ll_rx_dequeue+0x10c>
			struct lll_adv *lll = ftr->param;
   100c0:	689e      	ldr	r6, [r3, #8]
			if (cc->status == BT_HCI_ERR_ADV_TIMEOUT) {
   100c2:	2a3c      	cmp	r2, #60	; 0x3c
			struct ll_adv_set *adv = (void *)HDR_LLL2EVT(lll);
   100c4:	6835      	ldr	r5, [r6, #0]
			if (cc->status == BT_HCI_ERR_ADV_TIMEOUT) {
   100c6:	d146      	bne.n	10156 <ll_rx_dequeue+0xf6>
				conn_lll = lll->conn;
   100c8:	68b4      	ldr	r4, [r6, #8]
				LL_ASSERT(conn_lll);
   100ca:	b964      	cbnz	r4, 100e6 <ll_rx_dequeue+0x86>
   100cc:	f240 2326 	movw	r3, #550	; 0x226
   100d0:	4a39      	ldr	r2, [pc, #228]	; (101b8 <ll_rx_dequeue+0x158>)
   100d2:	493d      	ldr	r1, [pc, #244]	; (101c8 <ll_rx_dequeue+0x168>)
   100d4:	483a      	ldr	r0, [pc, #232]	; (101c0 <ll_rx_dequeue+0x160>)
   100d6:	f009 f94d 	bl	19374 <printk>
   100da:	4040      	eors	r0, r0
   100dc:	f380 8811 	msr	BASEPRI, r0
   100e0:	f04f 0003 	mov.w	r0, #3
   100e4:	df02      	svc	2
				lll->conn = NULL;
   100e6:	2300      	movs	r3, #0
   100e8:	60b3      	str	r3, [r6, #8]
				LL_ASSERT(!conn_lll->link_tx_free);
   100ea:	6de3      	ldr	r3, [r4, #92]	; 0x5c
   100ec:	b163      	cbz	r3, 10108 <ll_rx_dequeue+0xa8>
   100ee:	f240 2329 	movw	r3, #553	; 0x229
   100f2:	4a31      	ldr	r2, [pc, #196]	; (101b8 <ll_rx_dequeue+0x158>)
   100f4:	4935      	ldr	r1, [pc, #212]	; (101cc <ll_rx_dequeue+0x16c>)
   100f6:	4832      	ldr	r0, [pc, #200]	; (101c0 <ll_rx_dequeue+0x160>)
   100f8:	f009 f93c 	bl	19374 <printk>
   100fc:	4040      	eors	r0, r0
   100fe:	f380 8811 	msr	BASEPRI, r0
   10102:	f04f 0003 	mov.w	r0, #3
   10106:	df02      	svc	2
				link = memq_deinit(&conn_lll->memq_tx.head,
   10108:	f104 0150 	add.w	r1, r4, #80	; 0x50
   1010c:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   10110:	f00c feff 	bl	1cf12 <memq_deinit>
				LL_ASSERT(link);
   10114:	4606      	mov	r6, r0
   10116:	b960      	cbnz	r0, 10132 <ll_rx_dequeue+0xd2>
   10118:	f44f 730b 	mov.w	r3, #556	; 0x22c
   1011c:	4a26      	ldr	r2, [pc, #152]	; (101b8 <ll_rx_dequeue+0x158>)
   1011e:	4927      	ldr	r1, [pc, #156]	; (101bc <ll_rx_dequeue+0x15c>)
   10120:	4827      	ldr	r0, [pc, #156]	; (101c0 <ll_rx_dequeue+0x160>)
   10122:	f009 f927 	bl	19374 <printk>
   10126:	4040      	eors	r0, r0
   10128:	f380 8811 	msr	BASEPRI, r0
   1012c:	f04f 0003 	mov.w	r0, #3
   10130:	df02      	svc	2
				conn_lll->link_tx_free = link;
   10132:	65e6      	str	r6, [r4, #92]	; 0x5c
				ll_conn_release(conn);
   10134:	6820      	ldr	r0, [r4, #0]
   10136:	f002 f8d9 	bl	122ec <ll_conn_release>
			adv->is_enabled = 0U;
   1013a:	f895 30cc 	ldrb.w	r3, [r5, #204]	; 0xcc
   1013e:	f36f 0300 	bfc	r3, #0, #1
   10142:	f885 30cc 	strb.w	r3, [r5, #204]	; 0xcc
			      ull_adv_is_enabled(0));
   10146:	2000      	movs	r0, #0
   10148:	f00d f961 	bl	1d40e <ull_adv_is_enabled>
			if (!bm) {
   1014c:	b908      	cbnz	r0, 10152 <ll_rx_dequeue+0xf2>
				ull_filter_adv_scan_state_cb(0);
   1014e:	f004 fef3 	bl	14f38 <ull_filter_adv_scan_state_cb>
}
   10152:	b002      	add	sp, #8
   10154:	bd70      	pop	{r4, r5, r6, pc}
				if (adv->node_rx_cc_free) {
   10156:	f8d5 00d4 	ldr.w	r0, [r5, #212]	; 0xd4
   1015a:	2800      	cmp	r0, #0
   1015c:	d0ed      	beq.n	1013a <ll_rx_dequeue+0xda>
					adv->node_rx_cc_free = NULL;
   1015e:	2300      	movs	r3, #0
   10160:	f8c5 30d4 	str.w	r3, [r5, #212]	; 0xd4
					mem_release(rx_free, &mem_pdu_rx.free);
   10164:	491a      	ldr	r1, [pc, #104]	; (101d0 <ll_rx_dequeue+0x170>)
   10166:	f00c fe9a 	bl	1ce9e <mem_release>
   1016a:	e7e6      	b.n	1013a <ll_rx_dequeue+0xda>
			LL_ASSERT(0);
   1016c:	f44f 7312 	mov.w	r3, #584	; 0x248
   10170:	4a11      	ldr	r2, [pc, #68]	; (101b8 <ll_rx_dequeue+0x158>)
   10172:	4918      	ldr	r1, [pc, #96]	; (101d4 <ll_rx_dequeue+0x174>)
   10174:	4812      	ldr	r0, [pc, #72]	; (101c0 <ll_rx_dequeue+0x160>)
   10176:	f009 f8fd 	bl	19374 <printk>
   1017a:	4040      	eors	r0, r0
   1017c:	f380 8811 	msr	BASEPRI, r0
   10180:	f04f 0003 	mov.w	r0, #3
   10184:	df02      	svc	2
   10186:	e7de      	b.n	10146 <ll_rx_dequeue+0xe6>
		LL_ASSERT(rx->type != NODE_RX_TYPE_NONE);
   10188:	2900      	cmp	r1, #0
   1018a:	d1e2      	bne.n	10152 <ll_rx_dequeue+0xf2>
   1018c:	4a0a      	ldr	r2, [pc, #40]	; (101b8 <ll_rx_dequeue+0x158>)
   1018e:	4912      	ldr	r1, [pc, #72]	; (101d8 <ll_rx_dequeue+0x178>)
   10190:	f240 2399 	movw	r3, #665	; 0x299
		LL_ASSERT(0);
   10194:	480a      	ldr	r0, [pc, #40]	; (101c0 <ll_rx_dequeue+0x160>)
   10196:	f009 f8ed 	bl	19374 <printk>
   1019a:	4040      	eors	r0, r0
   1019c:	f380 8811 	msr	BASEPRI, r0
   101a0:	f04f 0003 	mov.w	r0, #3
   101a4:	df02      	svc	2
}
   101a6:	e7d4      	b.n	10152 <ll_rx_dequeue+0xf2>
		LL_ASSERT(0);
   101a8:	f240 239d 	movw	r3, #669	; 0x29d
   101ac:	4a02      	ldr	r2, [pc, #8]	; (101b8 <ll_rx_dequeue+0x158>)
   101ae:	4909      	ldr	r1, [pc, #36]	; (101d4 <ll_rx_dequeue+0x174>)
   101b0:	e7f0      	b.n	10194 <ll_rx_dequeue+0x134>
   101b2:	bf00      	nop
   101b4:	20000d00 	.word	0x20000d00
   101b8:	00021b31 	.word	0x00021b31
   101bc:	00021fdb 	.word	0x00021fdb
   101c0:	00020aa4 	.word	0x00020aa4
   101c4:	20000a48 	.word	0x20000a48
   101c8:	00021af2 	.word	0x00021af2
   101cc:	00021afb 	.word	0x00021afb
   101d0:	20000a9c 	.word	0x20000a9c
   101d4:	00022577 	.word	0x00022577
   101d8:	00021b13 	.word	0x00021b13

000101dc <ll_rx_mem_release>:
{
   101dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx = *node_rx;
   101e0:	6804      	ldr	r4, [r0, #0]
			LL_ASSERT(0);
   101e2:	4d44      	ldr	r5, [pc, #272]	; (102f4 <ll_rx_mem_release+0x118>)
   101e4:	f8df 8128 	ldr.w	r8, [pc, #296]	; 10310 <ll_rx_mem_release+0x134>
   101e8:	4e43      	ldr	r6, [pc, #268]	; (102f8 <ll_rx_mem_release+0x11c>)
{
   101ea:	4607      	mov	r7, r0
	while (rx) {
   101ec:	b92c      	cbnz	r4, 101fa <ll_rx_mem_release+0x1e>
	*node_rx = rx;
   101ee:	603c      	str	r4, [r7, #0]
	rx_alloc(UINT8_MAX);
   101f0:	20ff      	movs	r0, #255	; 0xff
}
   101f2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx_alloc(UINT8_MAX);
   101f6:	f7ff bc6b 	b.w	fad0 <rx_alloc>
		switch (rx_free->type) {
   101fa:	7922      	ldrb	r2, [r4, #4]
		rx = rx->next;
   101fc:	f8d4 9000 	ldr.w	r9, [r4]
		switch (rx_free->type) {
   10200:	2a0e      	cmp	r2, #14
   10202:	d868      	bhi.n	102d6 <ll_rx_mem_release+0xfa>
   10204:	2301      	movs	r3, #1
   10206:	4093      	lsls	r3, r2
   10208:	f647 4205 	movw	r2, #31749	; 0x7c05
   1020c:	4213      	tst	r3, r2
   1020e:	d11b      	bne.n	10248 <ll_rx_mem_release+0x6c>
   10210:	059a      	lsls	r2, r3, #22
   10212:	d42c      	bmi.n	1026e <ll_rx_mem_release+0x92>
   10214:	05db      	lsls	r3, r3, #23
   10216:	d55e      	bpl.n	102d6 <ll_rx_mem_release+0xfa>
			} else if (cc->status == BT_HCI_ERR_ADV_TIMEOUT) {
   10218:	f894 3020 	ldrb.w	r3, [r4, #32]
   1021c:	2b3c      	cmp	r3, #60	; 0x3c
   1021e:	d105      	bne.n	1022c <ll_rx_mem_release+0x50>
			mem_release(rx_free, &mem_pdu_rx.free);
   10220:	4936      	ldr	r1, [pc, #216]	; (102fc <ll_rx_mem_release+0x120>)
   10222:	4620      	mov	r0, r4
   10224:	f00c fe3b 	bl	1ce9e <mem_release>
{
   10228:	464c      	mov	r4, r9
   1022a:	e7df      	b.n	101ec <ll_rx_mem_release+0x10>
				LL_ASSERT(!cc->status);
   1022c:	b163      	cbz	r3, 10248 <ll_rx_mem_release+0x6c>
   1022e:	f240 23f5 	movw	r3, #757	; 0x2f5
   10232:	462a      	mov	r2, r5
   10234:	4932      	ldr	r1, [pc, #200]	; (10300 <ll_rx_mem_release+0x124>)
   10236:	4630      	mov	r0, r6
   10238:	f009 f89c 	bl	19374 <printk>
   1023c:	4040      	eors	r0, r0
   1023e:	f380 8811 	msr	BASEPRI, r0
   10242:	f04f 0003 	mov.w	r0, #3
   10246:	df02      	svc	2
			LL_ASSERT(rx_free->type != NODE_RX_TYPE_NONE);
   10248:	7923      	ldrb	r3, [r4, #4]
   1024a:	b963      	cbnz	r3, 10266 <ll_rx_mem_release+0x8a>
   1024c:	f240 3336 	movw	r3, #822	; 0x336
   10250:	462a      	mov	r2, r5
   10252:	492c      	ldr	r1, [pc, #176]	; (10304 <ll_rx_mem_release+0x128>)
   10254:	4630      	mov	r0, r6
   10256:	f009 f88d 	bl	19374 <printk>
   1025a:	4040      	eors	r0, r0
   1025c:	f380 8811 	msr	BASEPRI, r0
   10260:	f04f 0003 	mov.w	r0, #3
   10264:	df02      	svc	2
			ll_rx_link_inc_quota(1);
   10266:	2001      	movs	r0, #1
   10268:	f7ff fc10 	bl	fa8c <ll_rx_link_inc_quota>
   1026c:	e7d8      	b.n	10220 <ll_rx_mem_release+0x44>
			conn = ll_conn_get(rx_free->handle);
   1026e:	88e0      	ldrh	r0, [r4, #6]
   10270:	f002 f84a 	bl	12308 <ll_conn_get>
			lll->handle = 0xFFFF;
   10274:	f64f 73ff 	movw	r3, #65535	; 0xffff
			conn = ll_conn_get(rx_free->handle);
   10278:	4604      	mov	r4, r0
			lll->handle = 0xFFFF;
   1027a:	8583      	strh	r3, [r0, #44]	; 0x2c
			ull_conn_tx_demux(UINT8_MAX);
   1027c:	20ff      	movs	r0, #255	; 0xff
   1027e:	f003 fd5b 	bl	13d38 <ull_conn_tx_demux>
			LL_ASSERT(!lll->link_tx_free);
   10282:	6fa3      	ldr	r3, [r4, #120]	; 0x78
   10284:	b163      	cbz	r3, 102a0 <ll_rx_mem_release+0xc4>
   10286:	f240 334f 	movw	r3, #847	; 0x34f
   1028a:	462a      	mov	r2, r5
   1028c:	491e      	ldr	r1, [pc, #120]	; (10308 <ll_rx_mem_release+0x12c>)
   1028e:	4630      	mov	r0, r6
   10290:	f009 f870 	bl	19374 <printk>
   10294:	4040      	eors	r0, r0
   10296:	f380 8811 	msr	BASEPRI, r0
   1029a:	f04f 0003 	mov.w	r0, #3
   1029e:	df02      	svc	2
			link = memq_deinit(&lll->memq_tx.head,
   102a0:	f104 016c 	add.w	r1, r4, #108	; 0x6c
   102a4:	f104 0068 	add.w	r0, r4, #104	; 0x68
   102a8:	f00c fe33 	bl	1cf12 <memq_deinit>
			LL_ASSERT(link);
   102ac:	4682      	mov	sl, r0
   102ae:	b960      	cbnz	r0, 102ca <ll_rx_mem_release+0xee>
   102b0:	f240 3352 	movw	r3, #850	; 0x352
   102b4:	462a      	mov	r2, r5
   102b6:	4915      	ldr	r1, [pc, #84]	; (1030c <ll_rx_mem_release+0x130>)
   102b8:	4630      	mov	r0, r6
   102ba:	f009 f85b 	bl	19374 <printk>
   102be:	4040      	eors	r0, r0
   102c0:	f380 8811 	msr	BASEPRI, r0
   102c4:	f04f 0003 	mov.w	r0, #3
   102c8:	df02      	svc	2
			lll->link_tx_free = link;
   102ca:	f8c4 a078 	str.w	sl, [r4, #120]	; 0x78
			ll_conn_release(conn);
   102ce:	4620      	mov	r0, r4
   102d0:	f002 f80c 	bl	122ec <ll_conn_release>
		break;
   102d4:	e7a8      	b.n	10228 <ll_rx_mem_release+0x4c>
			LL_ASSERT(0);
   102d6:	f240 335d 	movw	r3, #861	; 0x35d
   102da:	462a      	mov	r2, r5
   102dc:	4641      	mov	r1, r8
   102de:	4630      	mov	r0, r6
   102e0:	f009 f848 	bl	19374 <printk>
   102e4:	4040      	eors	r0, r0
   102e6:	f380 8811 	msr	BASEPRI, r0
   102ea:	f04f 0003 	mov.w	r0, #3
   102ee:	df02      	svc	2
			break;
   102f0:	e79a      	b.n	10228 <ll_rx_mem_release+0x4c>
   102f2:	bf00      	nop
   102f4:	00021b31 	.word	0x00021b31
   102f8:	00020aa4 	.word	0x00020aa4
   102fc:	20000a9c 	.word	0x20000a9c
   10300:	00021b99 	.word	0x00021b99
   10304:	00021ba5 	.word	0x00021ba5
   10308:	00021bc8 	.word	0x00021bc8
   1030c:	00021fdb 	.word	0x00021fdb
   10310:	00022577 	.word	0x00022577

00010314 <ll_rx_link_alloc>:
	return mem_acquire(&mem_link_rx.free);
   10314:	4801      	ldr	r0, [pc, #4]	; (1031c <ll_rx_link_alloc+0x8>)
   10316:	f00c bda9 	b.w	1ce6c <mem_acquire>
   1031a:	bf00      	nop
   1031c:	20000a48 	.word	0x20000a48

00010320 <ll_rx_link_release>:
	mem_release(link, &mem_link_rx.free);
   10320:	4901      	ldr	r1, [pc, #4]	; (10328 <ll_rx_link_release+0x8>)
   10322:	f00c bdbc 	b.w	1ce9e <mem_release>
   10326:	bf00      	nop
   10328:	20000a48 	.word	0x20000a48

0001032c <ll_rx_alloc>:
	return mem_acquire(&mem_pdu_rx.free);
   1032c:	4801      	ldr	r0, [pc, #4]	; (10334 <ll_rx_alloc+0x8>)
   1032e:	f00c bd9d 	b.w	1ce6c <mem_acquire>
   10332:	bf00      	nop
   10334:	20000a9c 	.word	0x20000a9c

00010338 <ll_rx_release>:
	mem_release(node_rx, &mem_pdu_rx.free);
   10338:	4901      	ldr	r1, [pc, #4]	; (10340 <ll_rx_release+0x8>)
   1033a:	f00c bdb0 	b.w	1ce9e <mem_release>
   1033e:	bf00      	nop
   10340:	20000a9c 	.word	0x20000a9c

00010344 <ll_rx_put>:
	rx_hdr->ack_last = mfifo_tx_ack.l;
   10344:	4b02      	ldr	r3, [pc, #8]	; (10350 <ll_rx_put+0xc>)
	memq_enqueue(link, rx, &memq_ll_rx.tail);
   10346:	4a03      	ldr	r2, [pc, #12]	; (10354 <ll_rx_put+0x10>)
	rx_hdr->ack_last = mfifo_tx_ack.l;
   10348:	78db      	ldrb	r3, [r3, #3]
   1034a:	700b      	strb	r3, [r1, #0]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
   1034c:	f00c bdec 	b.w	1cf28 <memq_enqueue>
   10350:	2000584c 	.word	0x2000584c
   10354:	20000d04 	.word	0x20000d04

00010358 <ll_rx_sched>:
	k_sem_give(sem_recv);
   10358:	4b01      	ldr	r3, [pc, #4]	; (10360 <ll_rx_sched+0x8>)
   1035a:	6818      	ldr	r0, [r3, #0]
	z_impl_k_sem_give(sem);
   1035c:	f008 b892 	b.w	18484 <z_impl_k_sem_give>
   10360:	20000d10 	.word	0x20000d10

00010364 <ll_pdu_rx_alloc_peek>:
{
   10364:	b510      	push	{r4, lr}
	if (count > MFIFO_AVAIL_COUNT_GET(ll_pdu_rx_free)) {
   10366:	4a0a      	ldr	r2, [pc, #40]	; (10390 <ll_pdu_rx_alloc_peek+0x2c>)
   10368:	7891      	ldrb	r1, [r2, #2]
   1036a:	78d4      	ldrb	r4, [r2, #3]
   1036c:	7853      	ldrb	r3, [r2, #1]
	if (last >= first) {
   1036e:	42a1      	cmp	r1, r4
		return count - first + last;
   10370:	bf8a      	itet	hi
   10372:	1a5b      	subhi	r3, r3, r1
		return last - first;
   10374:	1a63      	subls	r3, r4, r1
		return count - first + last;
   10376:	191b      	addhi	r3, r3, r4
   10378:	b2db      	uxtb	r3, r3
   1037a:	4298      	cmp	r0, r3
   1037c:	d806      	bhi.n	1038c <ll_pdu_rx_alloc_peek+0x28>
	if (first == last) {
   1037e:	42a1      	cmp	r1, r4
	return MFIFO_DEQUEUE_PEEK(ll_pdu_rx_free);
   10380:	7813      	ldrb	r3, [r2, #0]
   10382:	d003      	beq.n	1038c <ll_pdu_rx_alloc_peek+0x28>
	return *((void **)(fifo + first * size));
   10384:	fb01 2203 	mla	r2, r1, r3, r2
   10388:	6850      	ldr	r0, [r2, #4]
}
   1038a:	bd10      	pop	{r4, pc}
		return NULL;
   1038c:	2000      	movs	r0, #0
   1038e:	e7fc      	b.n	1038a <ll_pdu_rx_alloc_peek+0x26>
   10390:	200056fc 	.word	0x200056fc

00010394 <ll_pdu_rx_alloc>:
{
   10394:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(ll_pdu_rx_free);
   10396:	4a09      	ldr	r2, [pc, #36]	; (103bc <ll_pdu_rx_alloc+0x28>)
 * @return              Head buffer; or NULL if queue was empty
 */
static inline void *mfifo_dequeue(u8_t *fifo, u8_t size, u8_t count,
				  u8_t last, u8_t *first)
{
	u8_t _first = *first; /* Copy read-index */
   10398:	7893      	ldrb	r3, [r2, #2]
	void *mem;

	/* Queue is empty if first == last */
	if (_first == last) {
   1039a:	78d0      	ldrb	r0, [r2, #3]
   1039c:	7811      	ldrb	r1, [r2, #0]
   1039e:	7854      	ldrb	r4, [r2, #1]
   103a0:	4298      	cmp	r0, r3
   103a2:	d009      	beq.n	103b8 <ll_pdu_rx_alloc+0x24>
	}

	/* Obtain address of head buffer.
	 * API 2: fifo is array of void-ptrs
	 */
	mem = *((void **)(fifo + _first * size));
   103a4:	fb03 2101 	mla	r1, r3, r1, r2

	/* Circular buffer increment read-index modulo 'count' */
	_first += 1U;
   103a8:	3301      	adds	r3, #1
   103aa:	b2db      	uxtb	r3, r3
	if (_first == count) {
		_first = 0U;
   103ac:	429c      	cmp	r4, r3
   103ae:	bf08      	it	eq
   103b0:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
   103b2:	6848      	ldr	r0, [r1, #4]
	}

	*first = _first; /* Write back read-index */
   103b4:	7093      	strb	r3, [r2, #2]
}
   103b6:	bd10      	pop	{r4, pc}
		return NULL;
   103b8:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(ll_pdu_rx_free);
   103ba:	e7fc      	b.n	103b6 <ll_pdu_rx_alloc+0x22>
   103bc:	200056fc 	.word	0x200056fc

000103c0 <ll_tx_ack_put>:
{
   103c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	idx = MFIFO_ENQUEUE_GET(tx_ack, (void **)&tx);
   103c2:	4a12      	ldr	r2, [pc, #72]	; (1040c <ll_tx_ack_put+0x4c>)
   103c4:	78d4      	ldrb	r4, [r2, #3]
	if (last == count) {
   103c6:	7857      	ldrb	r7, [r2, #1]
   103c8:	7895      	ldrb	r5, [r2, #2]
   103ca:	7816      	ldrb	r6, [r2, #0]
	last = last + 1;
   103cc:	1c63      	adds	r3, r4, #1
   103ce:	b2db      	uxtb	r3, r3
		last = 0U;
   103d0:	429f      	cmp	r7, r3
   103d2:	bf08      	it	eq
   103d4:	2300      	moveq	r3, #0
	if (last == first) {
   103d6:	429d      	cmp	r5, r3
   103d8:	d004      	beq.n	103e4 <ll_tx_ack_put+0x24>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   103da:	1d15      	adds	r5, r2, #4
   103dc:	fb14 f406 	smulbb	r4, r4, r6
	LL_ASSERT(tx);
   103e0:	192e      	adds	r6, r5, r4
   103e2:	d10f      	bne.n	10404 <ll_tx_ack_put+0x44>
   103e4:	f240 33b3 	movw	r3, #947	; 0x3b3
   103e8:	4a09      	ldr	r2, [pc, #36]	; (10410 <ll_tx_ack_put+0x50>)
   103ea:	490a      	ldr	r1, [pc, #40]	; (10414 <ll_tx_ack_put+0x54>)
   103ec:	480a      	ldr	r0, [pc, #40]	; (10418 <ll_tx_ack_put+0x58>)
   103ee:	f008 ffc1 	bl	19374 <printk>
   103f2:	4040      	eors	r0, r0
   103f4:	f380 8811 	msr	BASEPRI, r0
   103f8:	f04f 0003 	mov.w	r0, #3
   103fc:	df02      	svc	2
	tx->handle = handle;
   103fe:	2300      	movs	r3, #0
   10400:	801b      	strh	r3, [r3, #0]
   10402:	deff      	udf	#255	; 0xff
   10404:	5328      	strh	r0, [r5, r4]
	*last = idx; /* Commit: Update write index */
   10406:	70d3      	strb	r3, [r2, #3]
	tx->node = node_tx;
   10408:	6071      	str	r1, [r6, #4]
}
   1040a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1040c:	2000584c 	.word	0x2000584c
   10410:	00021b31 	.word	0x00021b31
   10414:	00021f56 	.word	0x00021f56
   10418:	00020aa4 	.word	0x00020aa4

0001041c <ll_radio_state_abort>:
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
   1041c:	2200      	movs	r2, #0
{
   1041e:	b508      	push	{r3, lr}
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
   10420:	4611      	mov	r1, r2
   10422:	4b09      	ldr	r3, [pc, #36]	; (10448 <ll_radio_state_abort+0x2c>)
   10424:	2001      	movs	r0, #1
   10426:	f7fd fb59 	bl	dadc <mayfly_enqueue>
	LL_ASSERT(!ret);
   1042a:	b160      	cbz	r0, 10446 <ll_radio_state_abort+0x2a>
   1042c:	f240 33cb 	movw	r3, #971	; 0x3cb
   10430:	4a06      	ldr	r2, [pc, #24]	; (1044c <ll_radio_state_abort+0x30>)
   10432:	4907      	ldr	r1, [pc, #28]	; (10450 <ll_radio_state_abort+0x34>)
   10434:	4807      	ldr	r0, [pc, #28]	; (10454 <ll_radio_state_abort+0x38>)
   10436:	f008 ff9d 	bl	19374 <printk>
   1043a:	4040      	eors	r0, r0
   1043c:	f380 8811 	msr	BASEPRI, r0
   10440:	f04f 0003 	mov.w	r0, #3
   10444:	df02      	svc	2
}
   10446:	bd08      	pop	{r3, pc}
   10448:	20005880 	.word	0x20005880
   1044c:	00021b31 	.word	0x00021b31
   10450:	00021ae5 	.word	0x00021ae5
   10454:	00020aa4 	.word	0x00020aa4

00010458 <ull_ticker_status_give>:
	*((u32_t volatile *)param) = status;
   10458:	6008      	str	r0, [r1, #0]
   1045a:	4801      	ldr	r0, [pc, #4]	; (10460 <ull_ticker_status_give+0x8>)
   1045c:	f008 b812 	b.w	18484 <z_impl_k_sem_give>
   10460:	20000d14 	.word	0x20000d14

00010464 <ull_ticker_status_take>:
{
   10464:	b510      	push	{r4, lr}
   10466:	460c      	mov	r4, r1
	return z_impl_k_sem_take(sem, timeout);
   10468:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1046c:	4802      	ldr	r0, [pc, #8]	; (10478 <ull_ticker_status_take+0x14>)
   1046e:	f008 f835 	bl	184dc <z_impl_k_sem_take>
	return *ret_cb;
   10472:	6820      	ldr	r0, [r4, #0]
}
   10474:	bd10      	pop	{r4, pc}
   10476:	bf00      	nop
   10478:	20000d14 	.word	0x20000d14

0001047c <ull_disable_mark>:
	if (!*m) {
   1047c:	4b02      	ldr	r3, [pc, #8]	; (10488 <ull_disable_mark+0xc>)
   1047e:	681a      	ldr	r2, [r3, #0]
   10480:	b902      	cbnz	r2, 10484 <ull_disable_mark+0x8>
		*m = param;
   10482:	6018      	str	r0, [r3, #0]
}
   10484:	6818      	ldr	r0, [r3, #0]
   10486:	4770      	bx	lr
   10488:	20000974 	.word	0x20000974

0001048c <ull_disable_unmark>:
	if (*m && *m == param) {
   1048c:	4905      	ldr	r1, [pc, #20]	; (104a4 <ull_disable_unmark+0x18>)
   1048e:	680b      	ldr	r3, [r1, #0]
   10490:	b12b      	cbz	r3, 1049e <ull_disable_unmark+0x12>
   10492:	4298      	cmp	r0, r3
   10494:	f04f 0200 	mov.w	r2, #0
		*m = NULL;
   10498:	bf0c      	ite	eq
   1049a:	600a      	streq	r2, [r1, #0]
	return NULL;
   1049c:	4613      	movne	r3, r2
}
   1049e:	4618      	mov	r0, r3
   104a0:	4770      	bx	lr
   104a2:	bf00      	nop
   104a4:	20000974 	.word	0x20000974

000104a8 <ull_disable_mark_get>:
}
   104a8:	4b01      	ldr	r3, [pc, #4]	; (104b0 <ull_disable_mark_get+0x8>)
   104aa:	6818      	ldr	r0, [r3, #0]
   104ac:	4770      	bx	lr
   104ae:	bf00      	nop
   104b0:	20000974 	.word	0x20000974

000104b4 <ull_update_mark>:
	if (!*m) {
   104b4:	4b02      	ldr	r3, [pc, #8]	; (104c0 <ull_update_mark+0xc>)
   104b6:	681a      	ldr	r2, [r3, #0]
   104b8:	b902      	cbnz	r2, 104bc <ull_update_mark+0x8>
		*m = param;
   104ba:	6018      	str	r0, [r3, #0]
}
   104bc:	6818      	ldr	r0, [r3, #0]
   104be:	4770      	bx	lr
   104c0:	20000978 	.word	0x20000978

000104c4 <ull_update_unmark>:
	if (*m && *m == param) {
   104c4:	4905      	ldr	r1, [pc, #20]	; (104dc <ull_update_unmark+0x18>)
   104c6:	680b      	ldr	r3, [r1, #0]
   104c8:	b12b      	cbz	r3, 104d6 <ull_update_unmark+0x12>
   104ca:	4298      	cmp	r0, r3
   104cc:	f04f 0200 	mov.w	r2, #0
		*m = NULL;
   104d0:	bf0c      	ite	eq
   104d2:	600a      	streq	r2, [r1, #0]
	return NULL;
   104d4:	4613      	movne	r3, r2
}
   104d6:	4618      	mov	r0, r3
   104d8:	4770      	bx	lr
   104da:	bf00      	nop
   104dc:	20000978 	.word	0x20000978

000104e0 <ull_update_mark_get>:
}
   104e0:	4b01      	ldr	r3, [pc, #4]	; (104e8 <ull_update_mark_get+0x8>)
   104e2:	6818      	ldr	r0, [r3, #0]
   104e4:	4770      	bx	lr
   104e6:	bf00      	nop
   104e8:	20000978 	.word	0x20000978

000104ec <ull_disable>:
{
   104ec:	b530      	push	{r4, r5, lr}
	hdr = HDR_ULL(((struct lll_hdr *)lll)->parent);
   104ee:	6804      	ldr	r4, [r0, #0]
	if (!hdr) {
   104f0:	f114 0f10 	cmn.w	r4, #16
{
   104f4:	b087      	sub	sp, #28
   104f6:	4605      	mov	r5, r0
	if (!hdr) {
   104f8:	d102      	bne.n	10500 <ull_disable+0x14>
		return ULL_STATUS_SUCCESS;
   104fa:	2000      	movs	r0, #0
}
   104fc:	b007      	add	sp, #28
   104fe:	bd30      	pop	{r4, r5, pc}
	z_impl_k_sem_init(sem, initial_count, limit);
   10500:	2201      	movs	r2, #1
   10502:	2100      	movs	r1, #0
   10504:	4668      	mov	r0, sp
   10506:	f00e f8a3 	bl	1e650 <z_impl_k_sem_init>
	hdr->disabled_cb = disabled_cb;
   1050a:	4b11      	ldr	r3, [pc, #68]	; (10550 <ull_disable+0x64>)
   1050c:	6163      	str	r3, [r4, #20]
	if (!hdr->ref) {
   1050e:	7c23      	ldrb	r3, [r4, #16]
	hdr->disabled_param = &sem;
   10510:	f8c4 d018 	str.w	sp, [r4, #24]
	if (!hdr->ref) {
   10514:	2b00      	cmp	r3, #0
   10516:	d0f0      	beq.n	104fa <ull_disable+0xe>
	mfy.param = lll;
   10518:	4b0e      	ldr	r3, [pc, #56]	; (10554 <ull_disable+0x68>)
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
   1051a:	2200      	movs	r2, #0
   1051c:	4611      	mov	r1, r2
   1051e:	2003      	movs	r0, #3
	mfy.param = lll;
   10520:	609d      	str	r5, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
   10522:	f7fd fadb 	bl	dadc <mayfly_enqueue>
	LL_ASSERT(!ret);
   10526:	b160      	cbz	r0, 10542 <ull_disable+0x56>
   10528:	f240 431e 	movw	r3, #1054	; 0x41e
   1052c:	4a0a      	ldr	r2, [pc, #40]	; (10558 <ull_disable+0x6c>)
   1052e:	490b      	ldr	r1, [pc, #44]	; (1055c <ull_disable+0x70>)
   10530:	480b      	ldr	r0, [pc, #44]	; (10560 <ull_disable+0x74>)
   10532:	f008 ff1f 	bl	19374 <printk>
   10536:	4040      	eors	r0, r0
   10538:	f380 8811 	msr	BASEPRI, r0
   1053c:	f04f 0003 	mov.w	r0, #3
   10540:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
   10542:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   10546:	4668      	mov	r0, sp
   10548:	f007 ffc8 	bl	184dc <z_impl_k_sem_take>
	return k_sem_take(&sem, K_FOREVER);
   1054c:	e7d6      	b.n	104fc <ull_disable+0x10>
   1054e:	bf00      	nop
   10550:	0001d2ad 	.word	0x0001d2ad
   10554:	20005890 	.word	0x20005890
   10558:	00021b31 	.word	0x00021b31
   1055c:	00021ae5 	.word	0x00021ae5
   10560:	00020aa4 	.word	0x00020aa4

00010564 <ull_pdu_rx_alloc_peek>:
{
   10564:	b510      	push	{r4, lr}
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
   10566:	4a0a      	ldr	r2, [pc, #40]	; (10590 <ull_pdu_rx_alloc_peek+0x2c>)
   10568:	7891      	ldrb	r1, [r2, #2]
   1056a:	78d4      	ldrb	r4, [r2, #3]
   1056c:	7853      	ldrb	r3, [r2, #1]
	if (last >= first) {
   1056e:	42a1      	cmp	r1, r4
		return count - first + last;
   10570:	bf8a      	itet	hi
   10572:	1a5b      	subhi	r3, r3, r1
		return last - first;
   10574:	1a63      	subls	r3, r4, r1
		return count - first + last;
   10576:	191b      	addhi	r3, r3, r4
   10578:	b2db      	uxtb	r3, r3
   1057a:	4298      	cmp	r0, r3
   1057c:	d806      	bhi.n	1058c <ull_pdu_rx_alloc_peek+0x28>
	if (first == last) {
   1057e:	42a1      	cmp	r1, r4
	return MFIFO_DEQUEUE_PEEK(pdu_rx_free);
   10580:	7813      	ldrb	r3, [r2, #0]
   10582:	d003      	beq.n	1058c <ull_pdu_rx_alloc_peek+0x28>
	return *((void **)(fifo + first * size));
   10584:	fb01 2203 	mla	r2, r1, r3, r2
   10588:	6850      	ldr	r0, [r2, #4]
}
   1058a:	bd10      	pop	{r4, pc}
		return NULL;
   1058c:	2000      	movs	r0, #0
   1058e:	e7fc      	b.n	1058a <ull_pdu_rx_alloc_peek+0x26>
   10590:	20005710 	.word	0x20005710

00010594 <ull_pdu_rx_alloc>:
{
   10594:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(pdu_rx_free);
   10596:	4a09      	ldr	r2, [pc, #36]	; (105bc <ull_pdu_rx_alloc+0x28>)
	u8_t _first = *first; /* Copy read-index */
   10598:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
   1059a:	78d0      	ldrb	r0, [r2, #3]
   1059c:	7811      	ldrb	r1, [r2, #0]
   1059e:	7854      	ldrb	r4, [r2, #1]
   105a0:	4298      	cmp	r0, r3
   105a2:	d009      	beq.n	105b8 <ull_pdu_rx_alloc+0x24>
	mem = *((void **)(fifo + _first * size));
   105a4:	fb03 2101 	mla	r1, r3, r1, r2
	_first += 1U;
   105a8:	3301      	adds	r3, #1
   105aa:	b2db      	uxtb	r3, r3
		_first = 0U;
   105ac:	429c      	cmp	r4, r3
   105ae:	bf08      	it	eq
   105b0:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
   105b2:	6848      	ldr	r0, [r1, #4]
	*first = _first; /* Write back read-index */
   105b4:	7093      	strb	r3, [r2, #2]
}
   105b6:	bd10      	pop	{r4, pc}
		return NULL;
   105b8:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(pdu_rx_free);
   105ba:	e7fc      	b.n	105b6 <ull_pdu_rx_alloc+0x22>
   105bc:	20005710 	.word	0x20005710

000105c0 <ull_rx_put>:
{
   105c0:	b538      	push	{r3, r4, r5, lr}
   105c2:	460c      	mov	r4, r1
   105c4:	4605      	mov	r5, r0
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
   105c6:	f003 fcbb 	bl	13f40 <ull_conn_ack_last_idx_get>
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   105ca:	4621      	mov	r1, r4
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
   105cc:	7020      	strb	r0, [r4, #0]
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   105ce:	4a03      	ldr	r2, [pc, #12]	; (105dc <ull_rx_put+0x1c>)
   105d0:	4628      	mov	r0, r5
}
   105d2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   105d6:	f00c bca7 	b.w	1cf28 <memq_enqueue>
   105da:	bf00      	nop
   105dc:	20000d0c 	.word	0x20000d0c

000105e0 <ull_rx_sched>:
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
   105e0:	2201      	movs	r2, #1
   105e2:	4b02      	ldr	r3, [pc, #8]	; (105ec <ull_rx_sched+0xc>)
   105e4:	4611      	mov	r1, r2
   105e6:	2000      	movs	r0, #0
   105e8:	f7fd ba78 	b.w	dadc <mayfly_enqueue>
   105ec:	200058a0 	.word	0x200058a0

000105f0 <ull_prepare_enqueue>:
{
   105f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   105f4:	4e16      	ldr	r6, [pc, #88]	; (10650 <ull_prepare_enqueue+0x60>)
{
   105f6:	460f      	mov	r7, r1
   105f8:	4611      	mov	r1, r2
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   105fa:	78f2      	ldrb	r2, [r6, #3]
   105fc:	7834      	ldrb	r4, [r6, #0]
{
   105fe:	4680      	mov	r8, r0
	last = last + 1;
   10600:	1c55      	adds	r5, r2, #1
	if (last == count) {
   10602:	7870      	ldrb	r0, [r6, #1]
   10604:	4699      	mov	r9, r3
	last = last + 1;
   10606:	b2ed      	uxtb	r5, r5
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   10608:	78b3      	ldrb	r3, [r6, #2]
		last = 0U;
   1060a:	42a8      	cmp	r0, r5
   1060c:	bf08      	it	eq
   1060e:	2500      	moveq	r5, #0
	if (last == first) {
   10610:	42ab      	cmp	r3, r5
   10612:	d01a      	beq.n	1064a <ull_prepare_enqueue+0x5a>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   10614:	1d33      	adds	r3, r6, #4
   10616:	fb02 3404 	mla	r4, r2, r4, r3
	if (!e) {
   1061a:	b1b4      	cbz	r4, 1064a <ull_prepare_enqueue+0x5a>
	memcpy(&e->prepare_param, prepare_param, sizeof(e->prepare_param));
   1061c:	2210      	movs	r2, #16
   1061e:	4620      	mov	r0, r4
   10620:	f00a fceb 	bl	1affa <memcpy>
	e->prio = prio;
   10624:	9b08      	ldr	r3, [sp, #32]
   10626:	61e3      	str	r3, [r4, #28]
	e->is_resume = is_resume;
   10628:	f89d 2024 	ldrb.w	r2, [sp, #36]	; 0x24
   1062c:	f894 3020 	ldrb.w	r3, [r4, #32]
	e->abort_cb = abort_cb;
   10630:	61a7      	str	r7, [r4, #24]
	e->is_resume = is_resume;
   10632:	f362 0300 	bfi	r3, r2, #0, #1
	e->is_abort_cb = is_abort_cb;
   10636:	e9c4 9804 	strd	r9, r8, [r4, #16]
	e->is_aborted = 0U;
   1063a:	f36f 0341 	bfc	r3, #1, #1
   1063e:	f884 3020 	strb.w	r3, [r4, #32]
	*last = idx; /* Commit: Update write index */
   10642:	70f5      	strb	r5, [r6, #3]
	return 0;
   10644:	2000      	movs	r0, #0
}
   10646:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return -ENOBUFS;
   1064a:	f06f 0036 	mvn.w	r0, #54	; 0x36
   1064e:	e7fa      	b.n	10646 <ull_prepare_enqueue+0x56>
   10650:	20005728 	.word	0x20005728

00010654 <ull_prepare_dequeue_get>:
	return MFIFO_DEQUEUE_GET(prep);
   10654:	4b05      	ldr	r3, [pc, #20]	; (1066c <ull_prepare_dequeue_get+0x18>)
   10656:	789a      	ldrb	r2, [r3, #2]
	if (first == last) {
   10658:	78d9      	ldrb	r1, [r3, #3]
   1065a:	7818      	ldrb	r0, [r3, #0]
   1065c:	4291      	cmp	r1, r2
	return (void *)(fifo + first * size);
   1065e:	bf1a      	itte	ne
   10660:	3304      	addne	r3, #4
   10662:	fb02 3000 	mlane	r0, r2, r0, r3
		return NULL;
   10666:	2000      	moveq	r0, #0
}
   10668:	4770      	bx	lr
   1066a:	bf00      	nop
   1066c:	20005728 	.word	0x20005728

00010670 <rx_demux>:
		}
}
#endif /* CONFIG_BT_CONN */

static void rx_demux(void *param)
{
   10670:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
					     TICKER_USER_ID_LLL, 0, &mfy);
			LL_ASSERT(!ret);
		}

		MFIFO_DEQUEUE(prep);
   10674:	4e8b      	ldr	r6, [pc, #556]	; (108a4 <rx_demux+0x234>)
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
   10676:	4c8c      	ldr	r4, [pc, #560]	; (108a8 <rx_demux+0x238>)
   10678:	aa01      	add	r2, sp, #4
   1067a:	e9d4 0100 	ldrd	r0, r1, [r4]
   1067e:	f00c fc5a 	bl	1cf36 <memq_peek>
		if (link) {
   10682:	4605      	mov	r5, r0
   10684:	2800      	cmp	r0, #0
   10686:	f000 80ee 	beq.w	10866 <rx_demux+0x1f6>
			LL_ASSERT(rx);
   1068a:	9b01      	ldr	r3, [sp, #4]
   1068c:	b963      	cbnz	r3, 106a8 <rx_demux+0x38>
   1068e:	f240 53d6 	movw	r3, #1494	; 0x5d6
   10692:	4a86      	ldr	r2, [pc, #536]	; (108ac <rx_demux+0x23c>)
   10694:	4986      	ldr	r1, [pc, #536]	; (108b0 <rx_demux+0x240>)
   10696:	4887      	ldr	r0, [pc, #540]	; (108b4 <rx_demux+0x244>)
   10698:	f008 fe6c 	bl	19374 <printk>
   1069c:	4040      	eors	r0, r0
   1069e:	f380 8811 	msr	BASEPRI, r0
   106a2:	f04f 0003 	mov.w	r0, #3
   106a6:	df02      	svc	2
			link_tx = ull_conn_ack_by_last_peek(rx->ack_last,
   106a8:	9b01      	ldr	r3, [sp, #4]
   106aa:	aa02      	add	r2, sp, #8
   106ac:	f10d 0102 	add.w	r1, sp, #2
   106b0:	7818      	ldrb	r0, [r3, #0]
   106b2:	f003 fc63 	bl	13f7c <ull_conn_ack_by_last_peek>
			if (link_tx) {
   106b6:	9f01      	ldr	r7, [sp, #4]
   106b8:	4602      	mov	r2, r0
   106ba:	b130      	cbz	r0, 106ca <rx_demux+0x5a>
				rx_demux_conn_tx_ack(rx->ack_last, handle,
   106bc:	9b02      	ldr	r3, [sp, #8]
   106be:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   106c2:	7838      	ldrb	r0, [r7, #0]
				rx_demux_conn_tx_ack(ack_last, handle,
   106c4:	f00c fdf4 	bl	1d2b0 <rx_demux_conn_tx_ack>
   106c8:	e7d5      	b.n	10676 <rx_demux+0x6>
	switch (rx->type) {
   106ca:	793b      	ldrb	r3, [r7, #4]
   106cc:	9703      	str	r7, [sp, #12]
   106ce:	3b01      	subs	r3, #1
   106d0:	2b08      	cmp	r3, #8
   106d2:	f200 80ba 	bhi.w	1084a <rx_demux+0x1da>
   106d6:	e8df f003 	tbb	[pc, r3]
   106da:	9c05      	.short	0x9c05
   106dc:	b8b8b8b8 	.word	0xb8b8b8b8
   106e0:	92b8      	.short	0x92b8
   106e2:	b1          	.byte	0xb1
   106e3:	00          	.byte	0x00
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   106e4:	6860      	ldr	r0, [r4, #4]
   106e6:	4970      	ldr	r1, [pc, #448]	; (108a8 <rx_demux+0x238>)
   106e8:	2200      	movs	r2, #0
   106ea:	f00c fc2c 	bl	1cf46 <memq_dequeue>
		rx_demux_event_done(link, rx);
   106ee:	9f03      	ldr	r7, [sp, #12]
	switch (done->extra.type) {
   106f0:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
	ull_hdr = done->param;
   106f4:	6a3c      	ldr	r4, [r7, #32]
	switch (done->extra.type) {
   106f6:	b123      	cbz	r3, 10702 <rx_demux+0x92>
   106f8:	2b01      	cmp	r3, #1
   106fa:	d169      	bne.n	107d0 <rx_demux+0x160>
		ull_conn_done(done);
   106fc:	4638      	mov	r0, r7
   106fe:	f003 f9dd 	bl	13abc <ull_conn_done>
	if (!MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
   10702:	4a6d      	ldr	r2, [pc, #436]	; (108b8 <rx_demux+0x248>)
   10704:	78d1      	ldrb	r1, [r2, #3]
	if (last == count) {
   10706:	f892 c001 	ldrb.w	ip, [r2, #1]
   1070a:	7890      	ldrb	r0, [r2, #2]
	done->extra.type = 0U;
   1070c:	2300      	movs	r3, #0
   1070e:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	last = last + 1;
   10712:	1c4b      	adds	r3, r1, #1
   10714:	b2db      	uxtb	r3, r3
		last = 0U;
   10716:	459c      	cmp	ip, r3
   10718:	bf08      	it	eq
   1071a:	2300      	moveq	r3, #0
	if (last == first) {
   1071c:	4298      	cmp	r0, r3
   1071e:	f000 80b0 	beq.w	10882 <rx_demux+0x212>
	done->hdr.link = link;
   10722:	603d      	str	r5, [r7, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   10724:	7810      	ldrb	r0, [r2, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   10726:	fb00 2101 	mla	r1, r0, r1, r2
   1072a:	604f      	str	r7, [r1, #4]
	*last = idx; /* Commit: Update write index */
   1072c:	70d3      	strb	r3, [r2, #3]
	next = ull_prepare_dequeue_get();
   1072e:	f7ff ff91 	bl	10654 <ull_prepare_dequeue_get>
			mfy.param = next;
   10732:	f8df 8188 	ldr.w	r8, [pc, #392]	; 108bc <rx_demux+0x24c>
	while (next) {
   10736:	b358      	cbz	r0, 10790 <rx_demux+0x120>
		u8_t is_aborted = next->is_aborted;
   10738:	f890 5020 	ldrb.w	r5, [r0, #32]
   1073c:	f3c5 0740 	ubfx	r7, r5, #1, #1
		u8_t is_resume = next->is_resume;
   10740:	f005 0501 	and.w	r5, r5, #1
		if (!is_aborted) {
   10744:	b9af      	cbnz	r7, 10772 <rx_demux+0x102>
			mfy.param = next;
   10746:	f8c8 0008 	str.w	r0, [r8, #8]
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1074a:	4b5c      	ldr	r3, [pc, #368]	; (108bc <rx_demux+0x24c>)
   1074c:	463a      	mov	r2, r7
   1074e:	4639      	mov	r1, r7
   10750:	2001      	movs	r0, #1
   10752:	f7fd f9c3 	bl	dadc <mayfly_enqueue>
			LL_ASSERT(!ret);
   10756:	b160      	cbz	r0, 10772 <rx_demux+0x102>
   10758:	f240 63a7 	movw	r3, #1703	; 0x6a7
   1075c:	4a53      	ldr	r2, [pc, #332]	; (108ac <rx_demux+0x23c>)
   1075e:	4958      	ldr	r1, [pc, #352]	; (108c0 <rx_demux+0x250>)
   10760:	4854      	ldr	r0, [pc, #336]	; (108b4 <rx_demux+0x244>)
   10762:	f008 fe07 	bl	19374 <printk>
   10766:	4040      	eors	r0, r0
   10768:	f380 8811 	msr	BASEPRI, r0
   1076c:	f04f 0003 	mov.w	r0, #3
   10770:	df02      	svc	2
	u8_t _first = *first; /* Copy read-index */
   10772:	78b3      	ldrb	r3, [r6, #2]
	if (_first == last) {
   10774:	78f1      	ldrb	r1, [r6, #3]
		MFIFO_DEQUEUE(prep);
   10776:	7872      	ldrb	r2, [r6, #1]
   10778:	4299      	cmp	r1, r3
   1077a:	d005      	beq.n	10788 <rx_demux+0x118>
	_first += 1U;
   1077c:	3301      	adds	r3, #1
   1077e:	b2db      	uxtb	r3, r3
		_first = 0U;
   10780:	429a      	cmp	r2, r3
   10782:	bf08      	it	eq
   10784:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   10786:	70b3      	strb	r3, [r6, #2]

		next = ull_prepare_dequeue_get();
   10788:	f7ff ff64 	bl	10654 <ull_prepare_dequeue_get>

		if (!next || (!is_aborted && (!is_resume || next->is_resume))) {
   1078c:	2800      	cmp	r0, #0
   1078e:	d12d      	bne.n	107ec <rx_demux+0x17c>
			break;
		}
	}

	/* ull instance will resume, dont decrement ref */
	if (!ull_hdr) {
   10790:	2c00      	cmp	r4, #0
   10792:	f43f af70 	beq.w	10676 <rx_demux+0x6>
		return;
	}

	/* Decrement prepare reference */
	LL_ASSERT(ull_hdr->ref);
   10796:	7823      	ldrb	r3, [r4, #0]
   10798:	b963      	cbnz	r3, 107b4 <rx_demux+0x144>
   1079a:	f240 63b9 	movw	r3, #1721	; 0x6b9
   1079e:	4a43      	ldr	r2, [pc, #268]	; (108ac <rx_demux+0x23c>)
   107a0:	4948      	ldr	r1, [pc, #288]	; (108c4 <rx_demux+0x254>)
   107a2:	4844      	ldr	r0, [pc, #272]	; (108b4 <rx_demux+0x244>)
   107a4:	f008 fde6 	bl	19374 <printk>
   107a8:	4040      	eors	r0, r0
   107aa:	f380 8811 	msr	BASEPRI, r0
   107ae:	f04f 0003 	mov.w	r0, #3
   107b2:	df02      	svc	2
	return hdr->ref--;
   107b4:	7823      	ldrb	r3, [r4, #0]
   107b6:	3b01      	subs	r3, #1
   107b8:	b2db      	uxtb	r3, r3
   107ba:	7023      	strb	r3, [r4, #0]
	ull_ref_dec(ull_hdr);

	/* If disable initiated, signal the semaphore */
	if (!ull_hdr->ref && ull_hdr->disabled_cb) {
   107bc:	2b00      	cmp	r3, #0
   107be:	f47f af5a 	bne.w	10676 <rx_demux+0x6>
   107c2:	6863      	ldr	r3, [r4, #4]
   107c4:	2b00      	cmp	r3, #0
   107c6:	f43f af56 	beq.w	10676 <rx_demux+0x6>
		ull_hdr->disabled_cb(ull_hdr->disabled_param);
   107ca:	68a0      	ldr	r0, [r4, #8]
   107cc:	4798      	blx	r3
			if (nack) {
   107ce:	e752      	b.n	10676 <rx_demux+0x6>
		LL_ASSERT(0);
   107d0:	f240 638f 	movw	r3, #1679	; 0x68f
   107d4:	4a35      	ldr	r2, [pc, #212]	; (108ac <rx_demux+0x23c>)
   107d6:	493c      	ldr	r1, [pc, #240]	; (108c8 <rx_demux+0x258>)
   107d8:	4836      	ldr	r0, [pc, #216]	; (108b4 <rx_demux+0x244>)
   107da:	f008 fdcb 	bl	19374 <printk>
   107de:	4040      	eors	r0, r0
   107e0:	f380 8811 	msr	BASEPRI, r0
   107e4:	f04f 0003 	mov.w	r0, #3
   107e8:	df02      	svc	2
		break;
   107ea:	e78a      	b.n	10702 <rx_demux+0x92>
		if (!next || (!is_aborted && (!is_resume || next->is_resume))) {
   107ec:	2f00      	cmp	r7, #0
   107ee:	d1a2      	bne.n	10736 <rx_demux+0xc6>
   107f0:	2d00      	cmp	r5, #0
   107f2:	d0cd      	beq.n	10790 <rx_demux+0x120>
   107f4:	f890 3020 	ldrb.w	r3, [r0, #32]
   107f8:	07db      	lsls	r3, r3, #31
   107fa:	d4c9      	bmi.n	10790 <rx_demux+0x120>
   107fc:	e79b      	b.n	10736 <rx_demux+0xc6>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   107fe:	2200      	movs	r2, #0
   10800:	4929      	ldr	r1, [pc, #164]	; (108a8 <rx_demux+0x238>)
   10802:	6860      	ldr	r0, [r4, #4]
   10804:	f00c fb9f 	bl	1cf46 <memq_dequeue>
		ull_conn_setup(link, rx);
   10808:	9903      	ldr	r1, [sp, #12]
   1080a:	4628      	mov	r0, r5
   1080c:	f001 feb4 	bl	12578 <ull_conn_setup>
			if (nack) {
   10810:	e731      	b.n	10676 <rx_demux+0x6>
		nack = ull_conn_rx(link, (void *)&rx);
   10812:	a903      	add	r1, sp, #12
   10814:	4628      	mov	r0, r5
   10816:	f001 fed1 	bl	125bc <ull_conn_rx>
		if (nack) {
   1081a:	4602      	mov	r2, r0
   1081c:	2800      	cmp	r0, #0
   1081e:	d13e      	bne.n	1089e <rx_demux+0x22e>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   10820:	4921      	ldr	r1, [pc, #132]	; (108a8 <rx_demux+0x238>)
   10822:	6860      	ldr	r0, [r4, #4]
   10824:	f00c fb8f 	bl	1cf46 <memq_dequeue>
		if (rx) {
   10828:	9903      	ldr	r1, [sp, #12]
   1082a:	2900      	cmp	r1, #0
   1082c:	f43f af23 	beq.w	10676 <rx_demux+0x6>
		ll_rx_put(link, rx);
   10830:	4628      	mov	r0, r5
   10832:	f7ff fd87 	bl	10344 <ll_rx_put>
		ll_rx_sched();
   10836:	f7ff fd8f 	bl	10358 <ll_rx_sched>
			if (nack) {
   1083a:	e71c      	b.n	10676 <rx_demux+0x6>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   1083c:	491a      	ldr	r1, [pc, #104]	; (108a8 <rx_demux+0x238>)
   1083e:	6860      	ldr	r0, [r4, #4]
   10840:	2200      	movs	r2, #0
   10842:	f00c fb80 	bl	1cf46 <memq_dequeue>
		ll_rx_put(link, rx);
   10846:	9903      	ldr	r1, [sp, #12]
   10848:	e7f2      	b.n	10830 <rx_demux+0x1c0>
		LL_ASSERT(0);
   1084a:	f240 6367 	movw	r3, #1639	; 0x667
   1084e:	4a17      	ldr	r2, [pc, #92]	; (108ac <rx_demux+0x23c>)
   10850:	491d      	ldr	r1, [pc, #116]	; (108c8 <rx_demux+0x258>)
   10852:	4818      	ldr	r0, [pc, #96]	; (108b4 <rx_demux+0x244>)
   10854:	f008 fd8e 	bl	19374 <printk>
   10858:	4040      	eors	r0, r0
   1085a:	f380 8811 	msr	BASEPRI, r0
   1085e:	f04f 0003 	mov.w	r0, #3
   10862:	df02      	svc	2
			if (nack) {
   10864:	e707      	b.n	10676 <rx_demux+0x6>
			link = ull_conn_ack_peek(&ack_last, &handle, &node_tx);
   10866:	aa03      	add	r2, sp, #12
   10868:	a902      	add	r1, sp, #8
   1086a:	f10d 0002 	add.w	r0, sp, #2
   1086e:	f003 fb6d 	bl	13f4c <ull_conn_ack_peek>
			if (link) {
   10872:	4602      	mov	r2, r0
   10874:	b198      	cbz	r0, 1089e <rx_demux+0x22e>
				rx_demux_conn_tx_ack(ack_last, handle,
   10876:	9b03      	ldr	r3, [sp, #12]
   10878:	f8bd 1008 	ldrh.w	r1, [sp, #8]
   1087c:	f89d 0002 	ldrb.w	r0, [sp, #2]
   10880:	e720      	b.n	106c4 <rx_demux+0x54>
	LL_ASSERT(release == done);
   10882:	f240 6396 	movw	r3, #1686	; 0x696
   10886:	4a09      	ldr	r2, [pc, #36]	; (108ac <rx_demux+0x23c>)
   10888:	4910      	ldr	r1, [pc, #64]	; (108cc <rx_demux+0x25c>)
   1088a:	480a      	ldr	r0, [pc, #40]	; (108b4 <rx_demux+0x244>)
   1088c:	f008 fd72 	bl	19374 <printk>
   10890:	4040      	eors	r0, r0
   10892:	f380 8811 	msr	BASEPRI, r0
   10896:	f04f 0003 	mov.w	r0, #3
   1089a:	df02      	svc	2
   1089c:	e747      	b.n	1072e <rx_demux+0xbe>
}
   1089e:	b004      	add	sp, #16
   108a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   108a4:	20005728 	.word	0x20005728
   108a8:	20000d08 	.word	0x20000d08
   108ac:	00021b31 	.word	0x00021b31
   108b0:	00022138 	.word	0x00022138
   108b4:	00020aa4 	.word	0x00020aa4
   108b8:	200056e8 	.word	0x200056e8
   108bc:	200058b0 	.word	0x200058b0
   108c0:	00021ae5 	.word	0x00021ae5
   108c4:	00021be0 	.word	0x00021be0
   108c8:	00022577 	.word	0x00022577
   108cc:	00021bed 	.word	0x00021bed

000108d0 <ull_prepare_dequeue_iter>:
{
   108d0:	b530      	push	{r4, r5, lr}
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
   108d2:	4b0c      	ldr	r3, [pc, #48]	; (10904 <ull_prepare_dequeue_iter+0x34>)
	if (*idx >= count) {
   108d4:	7801      	ldrb	r1, [r0, #0]
   108d6:	785c      	ldrb	r4, [r3, #1]
   108d8:	78dd      	ldrb	r5, [r3, #3]
   108da:	781a      	ldrb	r2, [r3, #0]
   108dc:	42a1      	cmp	r1, r4
   108de:	bf24      	itt	cs
   108e0:	789b      	ldrbcs	r3, [r3, #2]
		*idx = first;
   108e2:	7003      	strbcs	r3, [r0, #0]
	if (*idx == last) {
   108e4:	7801      	ldrb	r1, [r0, #0]
   108e6:	428d      	cmp	r5, r1
   108e8:	d00a      	beq.n	10900 <ull_prepare_dequeue_iter+0x30>
	i = *idx + 1;
   108ea:	1c4b      	adds	r3, r1, #1
   108ec:	b2db      	uxtb	r3, r3
		i = 0U;
   108ee:	429c      	cmp	r4, r3
   108f0:	bf08      	it	eq
   108f2:	2300      	moveq	r3, #0
	p = (void *)(fifo + (*idx) * size);
   108f4:	4c04      	ldr	r4, [pc, #16]	; (10908 <ull_prepare_dequeue_iter+0x38>)
	*idx = i;
   108f6:	7003      	strb	r3, [r0, #0]
	p = (void *)(fifo + (*idx) * size);
   108f8:	fb01 4202 	mla	r2, r1, r2, r4
}
   108fc:	4610      	mov	r0, r2
   108fe:	bd30      	pop	{r4, r5, pc}
		return NULL;
   10900:	2200      	movs	r2, #0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
   10902:	e7fb      	b.n	108fc <ull_prepare_dequeue_iter+0x2c>
   10904:	20005728 	.word	0x20005728
   10908:	2000572c 	.word	0x2000572c

0001090c <ull_event_done_extra_get>:
	evdone = MFIFO_DEQUEUE_PEEK(done);
   1090c:	4b06      	ldr	r3, [pc, #24]	; (10928 <ull_event_done_extra_get+0x1c>)
   1090e:	7899      	ldrb	r1, [r3, #2]
	if (first == last) {
   10910:	78d8      	ldrb	r0, [r3, #3]
   10912:	781a      	ldrb	r2, [r3, #0]
   10914:	4288      	cmp	r0, r1
   10916:	d005      	beq.n	10924 <ull_event_done_extra_get+0x18>
	return *((void **)(fifo + first * size));
   10918:	fb01 3302 	mla	r3, r1, r2, r3
   1091c:	6858      	ldr	r0, [r3, #4]
	if (!evdone) {
   1091e:	b110      	cbz	r0, 10926 <ull_event_done_extra_get+0x1a>
	return &evdone->extra;
   10920:	3024      	adds	r0, #36	; 0x24
   10922:	4770      	bx	lr
		return NULL;
   10924:	2000      	movs	r0, #0
}
   10926:	4770      	bx	lr
   10928:	200056e8 	.word	0x200056e8

0001092c <ull_event_done>:
{
   1092c:	b538      	push	{r3, r4, r5, lr}
	evdone = MFIFO_DEQUEUE(done);
   1092e:	4a10      	ldr	r2, [pc, #64]	; (10970 <ull_event_done+0x44>)
	u8_t _first = *first; /* Copy read-index */
   10930:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
   10932:	78d4      	ldrb	r4, [r2, #3]
   10934:	7811      	ldrb	r1, [r2, #0]
   10936:	7855      	ldrb	r5, [r2, #1]
   10938:	429c      	cmp	r4, r3
   1093a:	d017      	beq.n	1096c <ull_event_done+0x40>
	mem = *((void **)(fifo + _first * size));
   1093c:	fb03 2101 	mla	r1, r3, r1, r2
	_first += 1U;
   10940:	3301      	adds	r3, #1
	mem = *((void **)(fifo + _first * size));
   10942:	684c      	ldr	r4, [r1, #4]
	_first += 1U;
   10944:	b2db      	uxtb	r3, r3
		_first = 0U;
   10946:	429d      	cmp	r5, r3
   10948:	bf08      	it	eq
   1094a:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   1094c:	7093      	strb	r3, [r2, #2]
	if (!evdone) {
   1094e:	b15c      	cbz	r4, 10968 <ull_event_done+0x3c>
	link = evdone->hdr.link;
   10950:	6823      	ldr	r3, [r4, #0]
	evdone->param = param;
   10952:	6220      	str	r0, [r4, #32]
	evdone->hdr.link = NULL;
   10954:	2200      	movs	r2, #0
   10956:	6022      	str	r2, [r4, #0]
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
   10958:	2201      	movs	r2, #1
   1095a:	7122      	strb	r2, [r4, #4]
	ull_rx_put(link, evdone);
   1095c:	4621      	mov	r1, r4
   1095e:	4618      	mov	r0, r3
   10960:	f7ff fe2e 	bl	105c0 <ull_rx_put>
	ull_rx_sched();
   10964:	f7ff fe3c 	bl	105e0 <ull_rx_sched>
}
   10968:	4620      	mov	r0, r4
   1096a:	bd38      	pop	{r3, r4, r5, pc}
		return NULL;
   1096c:	2400      	movs	r4, #0
   1096e:	e7fb      	b.n	10968 <ull_event_done+0x3c>
   10970:	200056e8 	.word	0x200056e8

00010974 <lll_chan_sel_2>:
}

#if defined(CONFIG_BT_CTLR_CHAN_SEL_2)
u8_t lll_chan_sel_2(u16_t counter, u16_t chan_id, u8_t *chan_map,
		    u8_t chan_count)
{
   10974:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
/* Attribution:
 * http://graphics.stanford.edu/%7Eseander/bithacks.html#ReverseByteWith32Bits
 */
static u8_t chan_rev_8(u8_t b)
{
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   10978:	4f25      	ldr	r7, [pc, #148]	; (10a10 <lll_chan_sel_2+0x9c>)
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   1097a:	4d26      	ldr	r5, [pc, #152]	; (10a14 <lll_chan_sel_2+0xa0>)
static u16_t chan_prn(u16_t counter, u16_t chan_id)
{
	u8_t iterate;
	u16_t prn_e;

	prn_e = counter ^ chan_id;
   1097c:	4048      	eors	r0, r1
   1097e:	2403      	movs	r4, #3
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   10980:	f640 0c02 	movw	ip, #2050	; 0x802
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   10984:	f248 0620 	movw	r6, #32800	; 0x8020
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   10988:	ea4f 2e10 	mov.w	lr, r0, lsr #8
   1098c:	fb0c f80e 	mul.w	r8, ip, lr
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   10990:	fb06 fe0e 	mul.w	lr, r6, lr
   10994:	ea0e 0e05 	and.w	lr, lr, r5
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   10998:	ea08 0807 	and.w	r8, r8, r7
   1099c:	ea48 080e 	orr.w	r8, r8, lr
   109a0:	b2c0      	uxtb	r0, r0
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   109a2:	eb08 2e08 	add.w	lr, r8, r8, lsl #8
   109a6:	eb08 280e 	add.w	r8, r8, lr, lsl #8
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   109aa:	fb0c fe00 	mul.w	lr, ip, r0
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   109ae:	4370      	muls	r0, r6
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   109b0:	ea0e 0e07 	and.w	lr, lr, r7
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   109b4:	4028      	ands	r0, r5
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   109b6:	ea4e 0000 	orr.w	r0, lr, r0
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   109ba:	eb00 2e00 	add.w	lr, r0, r0, lsl #8
   109be:	eb00 200e 	add.w	r0, r0, lr, lsl #8
   109c2:	ea4f 4818 	mov.w	r8, r8, lsr #16
	return (chan_rev_8((i >> 8) & 0xFF) << 8) | chan_rev_8(i & 0xFF);
   109c6:	f3c0 4007 	ubfx	r0, r0, #16, #8
   109ca:	ea40 2008 	orr.w	r0, r0, r8, lsl #8
	return ((u32_t)a * 17U + b) & 0xFFFF;
   109ce:	eb00 1000 	add.w	r0, r0, r0, lsl #4
   109d2:	3c01      	subs	r4, #1
   109d4:	4408      	add	r0, r1

	for (iterate = 0U; iterate < 3; iterate++) {
   109d6:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
	return ((u32_t)a * 17U + b) & 0xFFFF;
   109da:	b280      	uxth	r0, r0
	for (iterate = 0U; iterate < 3; iterate++) {
   109dc:	d1d4      	bne.n	10988 <lll_chan_sel_2+0x14>
	chan_next = prn_e % 37;
   109de:	2425      	movs	r4, #37	; 0x25
		prn_e = chan_perm(prn_e);
		prn_e = chan_mam(prn_e, chan_id);
	}

	prn_e ^= chan_id;
   109e0:	4041      	eors	r1, r0
	chan_next = prn_e % 37;
   109e2:	fbb1 f0f4 	udiv	r0, r1, r4
   109e6:	fb04 1010 	mls	r0, r4, r0, r1
   109ea:	b2c0      	uxtb	r0, r0
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
   109ec:	08c4      	lsrs	r4, r0, #3
   109ee:	f000 0507 	and.w	r5, r0, #7
   109f2:	5d14      	ldrb	r4, [r2, r4]
   109f4:	412c      	asrs	r4, r5
   109f6:	07e4      	lsls	r4, r4, #31
   109f8:	d407      	bmi.n	10a0a <lll_chan_sel_2+0x96>
		chan_index = ((u32_t)chan_count * prn_e) >> 16;
   109fa:	4359      	muls	r1, r3
		chan_next = chan_sel_remap(chan_map, chan_index);
   109fc:	f3c1 4107 	ubfx	r1, r1, #16, #8
   10a00:	4610      	mov	r0, r2
}
   10a02:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		chan_next = chan_sel_remap(chan_map, chan_index);
   10a06:	f00c bc7f 	b.w	1d308 <chan_sel_remap>
}
   10a0a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10a0e:	bf00      	nop
   10a10:	00022110 	.word	0x00022110
   10a14:	00088440 	.word	0x00088440

00010a18 <rtc0_nrf5_isr>:
	DEBUG_RADIO_ISR(0);
	return 1;
}

static void rtc0_nrf5_isr(void *arg)
{
   10a18:	b508      	push	{r3, lr}
	DEBUG_TICKER_ISR(1);

	/* On compare0 run ticker worker instance0 */
	if (NRF_RTC0->EVENTS_COMPARE[0]) {
   10a1a:	4b08      	ldr	r3, [pc, #32]	; (10a3c <rtc0_nrf5_isr+0x24>)
   10a1c:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
   10a20:	b122      	cbz	r2, 10a2c <rtc0_nrf5_isr+0x14>
		NRF_RTC0->EVENTS_COMPARE[0] = 0;
   10a22:	2000      	movs	r0, #0
   10a24:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140

		ticker_trigger(0);
   10a28:	f7fd fcc4 	bl	e3b4 <ticker_trigger>
	}

	mayfly_run(TICKER_USER_ID_ULL_HIGH);
   10a2c:	2001      	movs	r0, #1
   10a2e:	f7fd f8a5 	bl	db7c <mayfly_run>

#if !defined(CONFIG_BT_CTLR_LOW_LAT) && \
	(CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	mayfly_run(TICKER_USER_ID_ULL_LOW);
   10a32:	2002      	movs	r0, #2
#endif

	DEBUG_TICKER_ISR(0);
}
   10a34:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	mayfly_run(TICKER_USER_ID_ULL_LOW);
   10a38:	f7fd b8a0 	b.w	db7c <mayfly_run>
   10a3c:	4000b000 	.word	0x4000b000

00010a40 <prepare>:
}

static int prepare(lll_is_abort_cb_t is_abort_cb, lll_abort_cb_t abort_cb,
		   lll_prepare_cb_t prepare_cb, int prio,
		   struct lll_prepare_param *prepare_param, u8_t is_resume)
{
   10a40:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   10a44:	b08d      	sub	sp, #52	; 0x34
   10a46:	4699      	mov	r9, r3
   10a48:	9d14      	ldr	r5, [sp, #80]	; 0x50
   10a4a:	f89d 4054 	ldrb.w	r4, [sp, #84]	; 0x54
	u8_t idx = UINT8_MAX;
   10a4e:	23ff      	movs	r3, #255	; 0xff
{
   10a50:	4680      	mov	r8, r0
   10a52:	460f      	mov	r7, r1
   10a54:	4616      	mov	r6, r2
	u8_t idx = UINT8_MAX;
   10a56:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
	int ret, err;

	/* Find the ready prepare in the pipeline */
	p = ull_prepare_dequeue_iter(&idx);
	while (p && (p->is_aborted || p->is_resume)) {
		p = ull_prepare_dequeue_iter(&idx);
   10a5a:	f10d 002f 	add.w	r0, sp, #47	; 0x2f
   10a5e:	f7ff ff37 	bl	108d0 <ull_prepare_dequeue_iter>
	while (p && (p->is_aborted || p->is_resume)) {
   10a62:	b118      	cbz	r0, 10a6c <prepare+0x2c>
   10a64:	f890 3020 	ldrb.w	r3, [r0, #32]
   10a68:	079b      	lsls	r3, r3, #30
   10a6a:	d1f6      	bne.n	10a5a <prepare+0x1a>
	}

	/* Current event active or another prepare is ready in the pipeline */
	if (event.curr.abort_cb || (p && is_resume)) {
   10a6c:	4b36      	ldr	r3, [pc, #216]	; (10b48 <prepare+0x108>)
   10a6e:	689a      	ldr	r2, [r3, #8]
   10a70:	b91a      	cbnz	r2, 10a7a <prepare+0x3a>
   10a72:	2800      	cmp	r0, #0
   10a74:	d04a      	beq.n	10b0c <prepare+0xcc>
   10a76:	2c00      	cmp	r4, #0
   10a78:	d048      	beq.n	10b0c <prepare+0xcc>
			/* early abort */
			event.curr.abort_cb(NULL, event.curr.param);
		}

		/* Store the next prepare for deferred call */
		ret = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
   10a7a:	e9cd 9400 	strd	r9, r4, [sp]
   10a7e:	4633      	mov	r3, r6
   10a80:	462a      	mov	r2, r5
   10a82:	4639      	mov	r1, r7
   10a84:	4640      	mov	r0, r8
   10a86:	f7ff fdb3 	bl	105f0 <ull_prepare_enqueue>
					  prepare_cb, prio, is_resume);
		LL_ASSERT(!ret);
   10a8a:	b160      	cbz	r0, 10aa6 <prepare+0x66>
   10a8c:	f240 13e5 	movw	r3, #485	; 0x1e5
   10a90:	4a2e      	ldr	r2, [pc, #184]	; (10b4c <prepare+0x10c>)
   10a92:	492f      	ldr	r1, [pc, #188]	; (10b50 <prepare+0x110>)
   10a94:	482f      	ldr	r0, [pc, #188]	; (10b54 <prepare+0x114>)
   10a96:	f008 fc6d 	bl	19374 <printk>
   10a9a:	4040      	eors	r0, r0
   10a9c:	f380 8811 	msr	BASEPRI, r0
   10aa0:	f04f 0003 	mov.w	r0, #3
   10aa4:	df02      	svc	2

#if !defined(CONFIG_BT_CTLR_LOW_LAT)
		if (is_resume) {
   10aa6:	b12c      	cbz	r4, 10ab4 <prepare+0x74>
				LL_ASSERT(ret == -ECANCELED);
			}
		}
#endif /* CONFIG_BT_CTLR_LOW_LAT */

		return -EINPROGRESS;
   10aa8:	f06f 0443 	mvn.w	r4, #67	; 0x43
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
		  (ret == TICKER_STATUS_FAILURE) ||
		  (ret == TICKER_STATUS_BUSY));

	return err;
}
   10aac:	4620      	mov	r0, r4
   10aae:	b00d      	add	sp, #52	; 0x34
   10ab0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		evt = HDR_LLL2EVT(prepare_param->param);
   10ab4:	68eb      	ldr	r3, [r5, #12]
   10ab6:	681a      	ldr	r2, [r3, #0]
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   10ab8:	4b27      	ldr	r3, [pc, #156]	; (10b58 <prepare+0x118>)
   10aba:	9408      	str	r4, [sp, #32]
   10abc:	e9cd 4306 	strd	r4, r3, [sp, #24]
   10ac0:	4b26      	ldr	r3, [pc, #152]	; (10b5c <prepare+0x11c>)
   10ac2:	9401      	str	r4, [sp, #4]
   10ac4:	e9cd 4304 	strd	r4, r3, [sp, #16]
   10ac8:	e9cd 4402 	strd	r4, r4, [sp, #8]
		preempt_to = MAX(evt->ticks_active_to_start,
   10acc:	e9d2 0100 	ldrd	r0, r1, [r2]
   10ad0:	6893      	ldr	r3, [r2, #8]
   10ad2:	4288      	cmp	r0, r1
   10ad4:	bf2c      	ite	cs
   10ad6:	ebc3 0300 	rsbcs	r3, r3, r0
   10ada:	ebc3 0301 	rsbcc	r3, r3, r1
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   10ade:	9300      	str	r3, [sp, #0]
   10ae0:	682b      	ldr	r3, [r5, #0]
   10ae2:	4622      	mov	r2, r4
   10ae4:	4621      	mov	r1, r4
   10ae6:	4620      	mov	r0, r4
   10ae8:	f7fd fc76 	bl	e3d8 <ticker_start>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   10aec:	2802      	cmp	r0, #2
   10aee:	d9db      	bls.n	10aa8 <prepare+0x68>
   10af0:	f240 2301 	movw	r3, #513	; 0x201
   10af4:	4a15      	ldr	r2, [pc, #84]	; (10b4c <prepare+0x10c>)
   10af6:	491a      	ldr	r1, [pc, #104]	; (10b60 <prepare+0x120>)
   10af8:	4816      	ldr	r0, [pc, #88]	; (10b54 <prepare+0x114>)
   10afa:	f008 fc3b 	bl	19374 <printk>
   10afe:	4040      	eors	r0, r0
   10b00:	f380 8811 	msr	BASEPRI, r0
   10b04:	f04f 0003 	mov.w	r0, #3
   10b08:	df02      	svc	2
   10b0a:	e7cd      	b.n	10aa8 <prepare+0x68>
	event.curr.param = prepare_param->param;
   10b0c:	68ea      	ldr	r2, [r5, #12]
	event.curr.abort_cb = abort_cb;
   10b0e:	609f      	str	r7, [r3, #8]
	event.curr.is_abort_cb = is_abort_cb;
   10b10:	e9c3 2800 	strd	r2, r8, [r3]
	err = prepare_cb(prepare_param);
   10b14:	4628      	mov	r0, r5
   10b16:	47b0      	blx	r6
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
   10b18:	2300      	movs	r3, #0
	err = prepare_cb(prepare_param);
   10b1a:	4604      	mov	r4, r0
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
   10b1c:	9300      	str	r3, [sp, #0]
   10b1e:	461a      	mov	r2, r3
   10b20:	4619      	mov	r1, r3
   10b22:	4618      	mov	r0, r3
   10b24:	f7fd fcea 	bl	e4fc <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   10b28:	2802      	cmp	r0, #2
   10b2a:	d9bf      	bls.n	10aac <prepare+0x6c>
   10b2c:	f240 2331 	movw	r3, #561	; 0x231
   10b30:	4a06      	ldr	r2, [pc, #24]	; (10b4c <prepare+0x10c>)
   10b32:	490b      	ldr	r1, [pc, #44]	; (10b60 <prepare+0x120>)
   10b34:	4807      	ldr	r0, [pc, #28]	; (10b54 <prepare+0x114>)
   10b36:	f008 fc1d 	bl	19374 <printk>
   10b3a:	4040      	eors	r0, r0
   10b3c:	f380 8811 	msr	BASEPRI, r0
   10b40:	f04f 0003 	mov.w	r0, #3
   10b44:	df02      	svc	2
   10b46:	e7b1      	b.n	10aac <prepare+0x6c>
   10b48:	2000106c 	.word	0x2000106c
   10b4c:	00021c69 	.word	0x00021c69
   10b50:	00021ae5 	.word	0x00021ae5
   10b54:	00020aa4 	.word	0x00020aa4
   10b58:	00010c69 	.word	0x00010c69
   10b5c:	00010c99 	.word	0x00010c99
   10b60:	00021ca8 	.word	0x00021ca8

00010b64 <preempt>:
			     0, &mfy);
	LL_ASSERT(!ret);
}

static void preempt(void *param)
{
   10b64:	b5f0      	push	{r4, r5, r6, r7, lr}
   10b66:	b08b      	sub	sp, #44	; 0x2c
	struct lll_event *next = ull_prepare_dequeue_get();
   10b68:	f7ff fd74 	bl	10654 <ull_prepare_dequeue_get>
	lll_prepare_cb_t resume_cb;
	u8_t idx = UINT8_MAX;
   10b6c:	23ff      	movs	r3, #255	; 0xff
	int resume_prio;
	int ret;

	next = ull_prepare_dequeue_iter(&idx);
   10b6e:	f10d 000e 	add.w	r0, sp, #14
	u8_t idx = UINT8_MAX;
   10b72:	f88d 300e 	strb.w	r3, [sp, #14]
	next = ull_prepare_dequeue_iter(&idx);
   10b76:	f7ff feab 	bl	108d0 <ull_prepare_dequeue_iter>
	if (!next || !event.curr.abort_cb || !event.curr.param) {
   10b7a:	4605      	mov	r5, r0
   10b7c:	b120      	cbz	r0, 10b88 <preempt+0x24>
   10b7e:	4c35      	ldr	r4, [pc, #212]	; (10c54 <preempt+0xf0>)
   10b80:	68a3      	ldr	r3, [r4, #8]
   10b82:	b10b      	cbz	r3, 10b88 <preempt+0x24>
   10b84:	6823      	ldr	r3, [r4, #0]
   10b86:	b943      	cbnz	r3, 10b9a <preempt+0x36>
		ret = resume_enqueue(resume_cb, resume_prio);
		LL_ASSERT(!ret);
	} else {
		LL_ASSERT(ret == -ECANCELED);
	}
}
   10b88:	b00b      	add	sp, #44	; 0x2c
   10b8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next = ull_prepare_dequeue_iter(&idx);
   10b8c:	f10d 000e 	add.w	r0, sp, #14
   10b90:	f7ff fe9e 	bl	108d0 <ull_prepare_dequeue_iter>
	while (next && (next->is_aborted || next->is_resume)) {
   10b94:	4605      	mov	r5, r0
   10b96:	2800      	cmp	r0, #0
   10b98:	d0f6      	beq.n	10b88 <preempt+0x24>
   10b9a:	f895 0020 	ldrb.w	r0, [r5, #32]
   10b9e:	f010 0603 	ands.w	r6, r0, #3
   10ba2:	d1f3      	bne.n	10b8c <preempt+0x28>
	ret = event.curr.is_abort_cb(next->prepare_param.param, next->prio,
   10ba4:	ab05      	add	r3, sp, #20
   10ba6:	9300      	str	r3, [sp, #0]
   10ba8:	6867      	ldr	r7, [r4, #4]
   10baa:	6822      	ldr	r2, [r4, #0]
   10bac:	69e9      	ldr	r1, [r5, #28]
   10bae:	68e8      	ldr	r0, [r5, #12]
   10bb0:	ab04      	add	r3, sp, #16
   10bb2:	47b8      	blx	r7
	if (!ret) {
   10bb4:	4607      	mov	r7, r0
   10bb6:	b950      	cbnz	r0, 10bce <preempt+0x6a>
		next->is_aborted = 1;
   10bb8:	f895 3020 	ldrb.w	r3, [r5, #32]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
   10bbc:	68e9      	ldr	r1, [r5, #12]
		next->is_aborted = 1;
   10bbe:	f043 0302 	orr.w	r3, r3, #2
   10bc2:	f885 3020 	strb.w	r3, [r5, #32]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
   10bc6:	4628      	mov	r0, r5
   10bc8:	69ab      	ldr	r3, [r5, #24]
   10bca:	4798      	blx	r3
		return;
   10bcc:	e7dc      	b.n	10b88 <preempt+0x24>
	event.curr.abort_cb(NULL, event.curr.param);
   10bce:	68a3      	ldr	r3, [r4, #8]
   10bd0:	6821      	ldr	r1, [r4, #0]
   10bd2:	4630      	mov	r0, r6
   10bd4:	4798      	blx	r3
	if (ret == -EAGAIN) {
   10bd6:	f117 0f0b 	cmn.w	r7, #11
   10bda:	d133      	bne.n	10c44 <preempt+0xe0>
		u8_t idx = UINT8_MAX;
   10bdc:	23ff      	movs	r3, #255	; 0xff
   10bde:	f88d 300f 	strb.w	r3, [sp, #15]
			iter = ull_prepare_dequeue_iter(&idx);
   10be2:	f10d 000f 	add.w	r0, sp, #15
   10be6:	f7ff fe73 	bl	108d0 <ull_prepare_dequeue_iter>
		while (iter) {
   10bea:	b9e0      	cbnz	r0, 10c26 <preempt+0xc2>
	prepare_param.param = event.curr.param;
   10bec:	6823      	ldr	r3, [r4, #0]
   10bee:	9309      	str	r3, [sp, #36]	; 0x24
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
   10bf0:	2301      	movs	r3, #1
   10bf2:	9301      	str	r3, [sp, #4]
   10bf4:	9b05      	ldr	r3, [sp, #20]
	event.curr.param = NULL;
   10bf6:	6020      	str	r0, [r4, #0]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
   10bf8:	9300      	str	r3, [sp, #0]
   10bfa:	aa06      	add	r2, sp, #24
   10bfc:	9b04      	ldr	r3, [sp, #16]
   10bfe:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
   10c02:	f7ff fcf5 	bl	105f0 <ull_prepare_enqueue>
		LL_ASSERT(!ret);
   10c06:	2800      	cmp	r0, #0
   10c08:	d0be      	beq.n	10b88 <preempt+0x24>
   10c0a:	4a13      	ldr	r2, [pc, #76]	; (10c58 <preempt+0xf4>)
   10c0c:	4913      	ldr	r1, [pc, #76]	; (10c5c <preempt+0xf8>)
   10c0e:	f44f 7323 	mov.w	r3, #652	; 0x28c
		LL_ASSERT(ret == -ECANCELED);
   10c12:	4813      	ldr	r0, [pc, #76]	; (10c60 <preempt+0xfc>)
   10c14:	f008 fbae 	bl	19374 <printk>
   10c18:	4040      	eors	r0, r0
   10c1a:	f380 8811 	msr	BASEPRI, r0
   10c1e:	f04f 0003 	mov.w	r0, #3
   10c22:	df02      	svc	2
   10c24:	e7b0      	b.n	10b88 <preempt+0x24>
			if (!iter->is_aborted &&
   10c26:	f890 3020 	ldrb.w	r3, [r0, #32]
   10c2a:	079a      	lsls	r2, r3, #30
   10c2c:	d4d9      	bmi.n	10be2 <preempt+0x7e>
			    event.curr.param == iter->prepare_param.param) {
   10c2e:	68c2      	ldr	r2, [r0, #12]
			if (!iter->is_aborted &&
   10c30:	6821      	ldr	r1, [r4, #0]
   10c32:	4291      	cmp	r1, r2
   10c34:	d1d5      	bne.n	10be2 <preempt+0x7e>
				iter->is_aborted = 1;
   10c36:	f043 0302 	orr.w	r3, r3, #2
   10c3a:	f880 3020 	strb.w	r3, [r0, #32]
				iter->abort_cb(&iter->prepare_param,
   10c3e:	6983      	ldr	r3, [r0, #24]
   10c40:	4798      	blx	r3
   10c42:	e7ce      	b.n	10be2 <preempt+0x7e>
		LL_ASSERT(ret == -ECANCELED);
   10c44:	3748      	adds	r7, #72	; 0x48
   10c46:	d09f      	beq.n	10b88 <preempt+0x24>
   10c48:	f240 238e 	movw	r3, #654	; 0x28e
   10c4c:	4a02      	ldr	r2, [pc, #8]	; (10c58 <preempt+0xf4>)
   10c4e:	4905      	ldr	r1, [pc, #20]	; (10c64 <preempt+0x100>)
   10c50:	e7df      	b.n	10c12 <preempt+0xae>
   10c52:	bf00      	nop
   10c54:	2000106c 	.word	0x2000106c
   10c58:	00021c69 	.word	0x00021c69
   10c5c:	00021ae5 	.word	0x00021ae5
   10c60:	00020aa4 	.word	0x00020aa4
   10c64:	00021c5e 	.word	0x00021c5e

00010c68 <ticker_start_op_cb>:
	LL_ASSERT((status == TICKER_STATUS_SUCCESS) ||
   10c68:	2801      	cmp	r0, #1
{
   10c6a:	b508      	push	{r3, lr}
	LL_ASSERT((status == TICKER_STATUS_SUCCESS) ||
   10c6c:	d90c      	bls.n	10c88 <ticker_start_op_cb+0x20>
   10c6e:	f240 234a 	movw	r3, #586	; 0x24a
   10c72:	4a06      	ldr	r2, [pc, #24]	; (10c8c <ticker_start_op_cb+0x24>)
   10c74:	4906      	ldr	r1, [pc, #24]	; (10c90 <ticker_start_op_cb+0x28>)
   10c76:	4807      	ldr	r0, [pc, #28]	; (10c94 <ticker_start_op_cb+0x2c>)
   10c78:	f008 fb7c 	bl	19374 <printk>
   10c7c:	4040      	eors	r0, r0
   10c7e:	f380 8811 	msr	BASEPRI, r0
   10c82:	f04f 0003 	mov.w	r0, #3
   10c86:	df02      	svc	2
}
   10c88:	bd08      	pop	{r3, pc}
   10c8a:	bf00      	nop
   10c8c:	00021c69 	.word	0x00021c69
   10c90:	00021cdb 	.word	0x00021cdb
   10c94:	00020aa4 	.word	0x00020aa4

00010c98 <preempt_ticker_cb>:
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   10c98:	2200      	movs	r2, #0
{
   10c9a:	b508      	push	{r3, lr}
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   10c9c:	4611      	mov	r1, r2
   10c9e:	4b09      	ldr	r3, [pc, #36]	; (10cc4 <preempt_ticker_cb+0x2c>)
   10ca0:	2001      	movs	r0, #1
   10ca2:	f7fc ff1b 	bl	dadc <mayfly_enqueue>
	LL_ASSERT(!ret);
   10ca6:	b160      	cbz	r0, 10cc2 <preempt_ticker_cb+0x2a>
   10ca8:	f240 2356 	movw	r3, #598	; 0x256
   10cac:	4a06      	ldr	r2, [pc, #24]	; (10cc8 <preempt_ticker_cb+0x30>)
   10cae:	4907      	ldr	r1, [pc, #28]	; (10ccc <preempt_ticker_cb+0x34>)
   10cb0:	4807      	ldr	r0, [pc, #28]	; (10cd0 <preempt_ticker_cb+0x38>)
   10cb2:	f008 fb5f 	bl	19374 <printk>
   10cb6:	4040      	eors	r0, r0
   10cb8:	f380 8811 	msr	BASEPRI, r0
   10cbc:	f04f 0003 	mov.w	r0, #3
   10cc0:	df02      	svc	2
}
   10cc2:	bd08      	pop	{r3, pc}
   10cc4:	200058c0 	.word	0x200058c0
   10cc8:	00021c69 	.word	0x00021c69
   10ccc:	00021ae5 	.word	0x00021ae5
   10cd0:	00020aa4 	.word	0x00020aa4

00010cd4 <lll_init>:
{
   10cd4:	b538      	push	{r3, r4, r5, lr}
   10cd6:	4818      	ldr	r0, [pc, #96]	; (10d38 <lll_init+0x64>)
   10cd8:	f006 fd2a 	bl	17730 <z_impl_device_get_binding>
	dev_entropy = device_get_binding(CONFIG_ENTROPY_NAME);
   10cdc:	4b17      	ldr	r3, [pc, #92]	; (10d3c <lll_init+0x68>)
   10cde:	6018      	str	r0, [r3, #0]
	if (!dev_entropy) {
   10ce0:	b910      	cbnz	r0, 10ce8 <lll_init+0x14>
		return -ENODEV;
   10ce2:	f06f 0012 	mvn.w	r0, #18
}
   10ce6:	bd38      	pop	{r3, r4, r5, pc}
	event.curr.abort_cb = NULL;
   10ce8:	4b15      	ldr	r3, [pc, #84]	; (10d40 <lll_init+0x6c>)
   10cea:	2400      	movs	r4, #0
   10cec:	609c      	str	r4, [r3, #8]
   10cee:	4815      	ldr	r0, [pc, #84]	; (10d44 <lll_init+0x70>)
   10cf0:	f006 fd1e 	bl	17730 <z_impl_device_get_binding>
	if (!clk) {
   10cf4:	4605      	mov	r5, r0
   10cf6:	2800      	cmp	r0, #0
   10cf8:	d0f3      	beq.n	10ce2 <lll_init+0xe>
	clock_control_on(clk, CLOCK_CONTROL_NRF_SUBSYS_LF);
   10cfa:	2101      	movs	r1, #1
   10cfc:	f00c fb3f 	bl	1d37e <clock_control_on>
	lll.clk = clk;
   10d00:	4b11      	ldr	r3, [pc, #68]	; (10d48 <lll_init+0x74>)
	IRQ_DIRECT_CONNECT(RADIO_IRQn, CONFIG_BT_CTLR_LLL_PRIO,
   10d02:	4622      	mov	r2, r4
   10d04:	4621      	mov	r1, r4
   10d06:	2001      	movs	r0, #1
	lll.clk = clk;
   10d08:	601d      	str	r5, [r3, #0]
	IRQ_DIRECT_CONNECT(RADIO_IRQn, CONFIG_BT_CTLR_LLL_PRIO,
   10d0a:	f7f3 fb57 	bl	43bc <z_arm_irq_priority_set>
	IRQ_CONNECT(RTC0_IRQn, CONFIG_BT_CTLR_ULL_HIGH_PRIO,
   10d0e:	4622      	mov	r2, r4
   10d10:	4621      	mov	r1, r4
   10d12:	200b      	movs	r0, #11
   10d14:	f7f3 fb52 	bl	43bc <z_arm_irq_priority_set>
	IRQ_CONNECT(HAL_SWI_RADIO_IRQ, CONFIG_BT_CTLR_LLL_PRIO,
   10d18:	4622      	mov	r2, r4
   10d1a:	4621      	mov	r1, r4
   10d1c:	2018      	movs	r0, #24
   10d1e:	f7f3 fb4d 	bl	43bc <z_arm_irq_priority_set>
	irq_enable(RADIO_IRQn);
   10d22:	2001      	movs	r0, #1
   10d24:	f7f3 fb18 	bl	4358 <arch_irq_enable>
	irq_enable(RTC0_IRQn);
   10d28:	200b      	movs	r0, #11
   10d2a:	f7f3 fb15 	bl	4358 <arch_irq_enable>
	irq_enable(HAL_SWI_RADIO_IRQ);
   10d2e:	2018      	movs	r0, #24
   10d30:	f7f3 fb12 	bl	4358 <arch_irq_enable>
	return 0;
   10d34:	4620      	mov	r0, r4
   10d36:	e7d6      	b.n	10ce6 <lll_init+0x12>
   10d38:	00021acc 	.word	0x00021acc
   10d3c:	20001068 	.word	0x20001068
   10d40:	2000106c 	.word	0x2000106c
   10d44:	0001fc32 	.word	0x0001fc32
   10d48:	20001080 	.word	0x20001080

00010d4c <lll_entropy_get>:
{
   10d4c:	b538      	push	{r3, r4, r5, lr}
	return entropy_get_entropy_isr(dev_entropy, rand, len, 0);
   10d4e:	4b07      	ldr	r3, [pc, #28]	; (10d6c <lll_entropy_get+0x20>)
   10d50:	681d      	ldr	r5, [r3, #0]
	if (unlikely(!api->get_entropy_isr)) {
   10d52:	686b      	ldr	r3, [r5, #4]
   10d54:	685c      	ldr	r4, [r3, #4]
   10d56:	4602      	mov	r2, r0
   10d58:	b124      	cbz	r4, 10d64 <lll_entropy_get+0x18>
	return api->get_entropy_isr(dev, buffer, length, flags);
   10d5a:	2300      	movs	r3, #0
   10d5c:	4628      	mov	r0, r5
   10d5e:	47a0      	blx	r4
}
   10d60:	b2c0      	uxtb	r0, r0
   10d62:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOTSUP;
   10d64:	f06f 0022 	mvn.w	r0, #34	; 0x22
   10d68:	e7fa      	b.n	10d60 <lll_entropy_get+0x14>
   10d6a:	bf00      	nop
   10d6c:	20001068 	.word	0x20001068

00010d70 <lll_resume>:
{
   10d70:	b507      	push	{r0, r1, r2, lr}
		      next->prio, &next->prepare_param, next->is_resume);
   10d72:	f890 3020 	ldrb.w	r3, [r0, #32]
	ret = prepare(next->is_abort_cb, next->abort_cb, next->prepare_cb,
   10d76:	f003 0301 	and.w	r3, r3, #1
   10d7a:	e9cd 0300 	strd	r0, r3, [sp]
   10d7e:	69c3      	ldr	r3, [r0, #28]
   10d80:	6902      	ldr	r2, [r0, #16]
   10d82:	e9d0 0105 	ldrd	r0, r1, [r0, #20]
   10d86:	f7ff fe5b 	bl	10a40 <prepare>
	LL_ASSERT(!ret || ret == -EINPROGRESS);
   10d8a:	b168      	cbz	r0, 10da8 <lll_resume+0x38>
   10d8c:	3044      	adds	r0, #68	; 0x44
   10d8e:	d00b      	beq.n	10da8 <lll_resume+0x38>
   10d90:	23da      	movs	r3, #218	; 0xda
   10d92:	4a07      	ldr	r2, [pc, #28]	; (10db0 <lll_resume+0x40>)
   10d94:	4907      	ldr	r1, [pc, #28]	; (10db4 <lll_resume+0x44>)
   10d96:	4808      	ldr	r0, [pc, #32]	; (10db8 <lll_resume+0x48>)
   10d98:	f008 faec 	bl	19374 <printk>
   10d9c:	4040      	eors	r0, r0
   10d9e:	f380 8811 	msr	BASEPRI, r0
   10da2:	f04f 0003 	mov.w	r0, #3
   10da6:	df02      	svc	2
}
   10da8:	b003      	add	sp, #12
   10daa:	f85d fb04 	ldr.w	pc, [sp], #4
   10dae:	bf00      	nop
   10db0:	00021c69 	.word	0x00021c69
   10db4:	00021c4b 	.word	0x00021c4b
   10db8:	00020aa4 	.word	0x00020aa4

00010dbc <lll_disable>:
{
   10dbc:	b513      	push	{r0, r1, r4, lr}
   10dbe:	4b1b      	ldr	r3, [pc, #108]	; (10e2c <lll_disable+0x70>)
	if (!param || (param == event.curr.param)) {
   10dc0:	4604      	mov	r4, r0
   10dc2:	b110      	cbz	r0, 10dca <lll_disable+0xe>
   10dc4:	681a      	ldr	r2, [r3, #0]
   10dc6:	4282      	cmp	r2, r0
   10dc8:	d105      	bne.n	10dd6 <lll_disable+0x1a>
		if (event.curr.abort_cb && event.curr.param) {
   10dca:	689a      	ldr	r2, [r3, #8]
   10dcc:	b16a      	cbz	r2, 10dea <lll_disable+0x2e>
   10dce:	6819      	ldr	r1, [r3, #0]
   10dd0:	b159      	cbz	r1, 10dea <lll_disable+0x2e>
			event.curr.abort_cb(NULL, event.curr.param);
   10dd2:	2000      	movs	r0, #0
   10dd4:	4790      	blx	r2
		u8_t idx = UINT8_MAX;
   10dd6:	23ff      	movs	r3, #255	; 0xff
   10dd8:	f88d 3007 	strb.w	r3, [sp, #7]
			next = ull_prepare_dequeue_iter(&idx);
   10ddc:	f10d 0007 	add.w	r0, sp, #7
   10de0:	f7ff fd76 	bl	108d0 <ull_prepare_dequeue_iter>
		while (next) {
   10de4:	b980      	cbnz	r0, 10e08 <lll_disable+0x4c>
}
   10de6:	b002      	add	sp, #8
   10de8:	bd10      	pop	{r4, pc}
			LL_ASSERT(!param);
   10dea:	2c00      	cmp	r4, #0
   10dec:	d0f3      	beq.n	10dd6 <lll_disable+0x1a>
   10dee:	23e4      	movs	r3, #228	; 0xe4
   10df0:	4a0f      	ldr	r2, [pc, #60]	; (10e30 <lll_disable+0x74>)
   10df2:	4910      	ldr	r1, [pc, #64]	; (10e34 <lll_disable+0x78>)
   10df4:	4810      	ldr	r0, [pc, #64]	; (10e38 <lll_disable+0x7c>)
   10df6:	f008 fabd 	bl	19374 <printk>
   10dfa:	4040      	eors	r0, r0
   10dfc:	f380 8811 	msr	BASEPRI, r0
   10e00:	f04f 0003 	mov.w	r0, #3
   10e04:	df02      	svc	2
   10e06:	e7e6      	b.n	10dd6 <lll_disable+0x1a>
			if (!next->is_aborted &&
   10e08:	f890 3020 	ldrb.w	r3, [r0, #32]
   10e0c:	079b      	lsls	r3, r3, #30
   10e0e:	d4e5      	bmi.n	10ddc <lll_disable+0x20>
   10e10:	68c1      	ldr	r1, [r0, #12]
   10e12:	b10c      	cbz	r4, 10e18 <lll_disable+0x5c>
			    (!param || (param == next->prepare_param.param))) {
   10e14:	428c      	cmp	r4, r1
   10e16:	d1e1      	bne.n	10ddc <lll_disable+0x20>
				next->is_aborted = 1;
   10e18:	f890 3020 	ldrb.w	r3, [r0, #32]
   10e1c:	f043 0302 	orr.w	r3, r3, #2
   10e20:	f880 3020 	strb.w	r3, [r0, #32]
				next->abort_cb(&next->prepare_param,
   10e24:	6983      	ldr	r3, [r0, #24]
   10e26:	4798      	blx	r3
   10e28:	e7d8      	b.n	10ddc <lll_disable+0x20>
   10e2a:	bf00      	nop
   10e2c:	2000106c 	.word	0x2000106c
   10e30:	00021c69 	.word	0x00021c69
   10e34:	00021c1a 	.word	0x00021c1a
   10e38:	00020aa4 	.word	0x00020aa4

00010e3c <lll_done>:
{
   10e3c:	b510      	push	{r4, lr}
   10e3e:	4604      	mov	r4, r0
	struct lll_event *next = ull_prepare_dequeue_get();
   10e40:	f7ff fc08 	bl	10654 <ull_prepare_dequeue_get>
	LL_ASSERT(!param || next);
   10e44:	b17c      	cbz	r4, 10e66 <lll_done+0x2a>
   10e46:	b960      	cbnz	r0, 10e62 <lll_done+0x26>
   10e48:	f240 1313 	movw	r3, #275	; 0x113
   10e4c:	4a1a      	ldr	r2, [pc, #104]	; (10eb8 <lll_done+0x7c>)
   10e4e:	491b      	ldr	r1, [pc, #108]	; (10ebc <lll_done+0x80>)
   10e50:	481b      	ldr	r0, [pc, #108]	; (10ec0 <lll_done+0x84>)
   10e52:	f008 fa8f 	bl	19374 <printk>
   10e56:	4040      	eors	r0, r0
   10e58:	f380 8811 	msr	BASEPRI, r0
   10e5c:	f04f 0003 	mov.w	r0, #3
   10e60:	df02      	svc	2
		ull = HDR_ULL(((struct lll_hdr *)param)->parent);
   10e62:	6820      	ldr	r0, [r4, #0]
   10e64:	e015      	b.n	10e92 <lll_done+0x56>
		LL_ASSERT(event.curr.abort_cb);
   10e66:	4c17      	ldr	r4, [pc, #92]	; (10ec4 <lll_done+0x88>)
   10e68:	68a3      	ldr	r3, [r4, #8]
   10e6a:	b963      	cbnz	r3, 10e86 <lll_done+0x4a>
   10e6c:	f44f 738c 	mov.w	r3, #280	; 0x118
   10e70:	4a11      	ldr	r2, [pc, #68]	; (10eb8 <lll_done+0x7c>)
   10e72:	4915      	ldr	r1, [pc, #84]	; (10ec8 <lll_done+0x8c>)
   10e74:	4812      	ldr	r0, [pc, #72]	; (10ec0 <lll_done+0x84>)
   10e76:	f008 fa7d 	bl	19374 <printk>
   10e7a:	4040      	eors	r0, r0
   10e7c:	f380 8811 	msr	BASEPRI, r0
   10e80:	f04f 0003 	mov.w	r0, #3
   10e84:	df02      	svc	2
		param = event.curr.param;
   10e86:	6820      	ldr	r0, [r4, #0]
		event.curr.abort_cb = NULL;
   10e88:	2300      	movs	r3, #0
   10e8a:	60a3      	str	r3, [r4, #8]
		event.curr.param = NULL;
   10e8c:	6023      	str	r3, [r4, #0]
		if (param) {
   10e8e:	b108      	cbz	r0, 10e94 <lll_done+0x58>
			ull = HDR_ULL(((struct lll_hdr *)param)->parent);
   10e90:	6800      	ldr	r0, [r0, #0]
   10e92:	3010      	adds	r0, #16
	evdone = ull_event_done(ull);
   10e94:	f7ff fd4a 	bl	1092c <ull_event_done>
	LL_ASSERT(evdone);
   10e98:	b960      	cbnz	r0, 10eb4 <lll_done+0x78>
   10e9a:	f44f 7398 	mov.w	r3, #304	; 0x130
   10e9e:	4a06      	ldr	r2, [pc, #24]	; (10eb8 <lll_done+0x7c>)
   10ea0:	490a      	ldr	r1, [pc, #40]	; (10ecc <lll_done+0x90>)
   10ea2:	4807      	ldr	r0, [pc, #28]	; (10ec0 <lll_done+0x84>)
   10ea4:	f008 fa66 	bl	19374 <printk>
   10ea8:	4040      	eors	r0, r0
   10eaa:	f380 8811 	msr	BASEPRI, r0
   10eae:	f04f 0003 	mov.w	r0, #3
   10eb2:	df02      	svc	2
}
   10eb4:	2000      	movs	r0, #0
   10eb6:	bd10      	pop	{r4, pc}
   10eb8:	00021c69 	.word	0x00021c69
   10ebc:	00021c21 	.word	0x00021c21
   10ec0:	00020aa4 	.word	0x00020aa4
   10ec4:	2000106c 	.word	0x2000106c
   10ec8:	00021c30 	.word	0x00021c30
   10ecc:	00021c44 	.word	0x00021c44

00010ed0 <lll_clk_on>:
	err = clock_control_on(lll.clk, CLOCK_CONTROL_NRF_SUBSYS_HF);
   10ed0:	4b02      	ldr	r3, [pc, #8]	; (10edc <lll_clk_on+0xc>)
   10ed2:	2100      	movs	r1, #0
   10ed4:	6818      	ldr	r0, [r3, #0]
   10ed6:	f00c ba52 	b.w	1d37e <clock_control_on>
   10eda:	bf00      	nop
   10edc:	20001080 	.word	0x20001080

00010ee0 <lll_clk_off>:
	err = clock_control_off(lll.clk, CLOCK_CONTROL_NRF_SUBSYS_HF);
   10ee0:	4b02      	ldr	r3, [pc, #8]	; (10eec <lll_clk_off+0xc>)
   10ee2:	6818      	ldr	r0, [r3, #0]
				    clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->off(dev, sys);
   10ee4:	6843      	ldr	r3, [r0, #4]
   10ee6:	2100      	movs	r1, #0
   10ee8:	685b      	ldr	r3, [r3, #4]
   10eea:	4718      	bx	r3
   10eec:	20001080 	.word	0x20001080

00010ef0 <lll_chan_set>:
	switch (chan) {
   10ef0:	2826      	cmp	r0, #38	; 0x26
{
   10ef2:	b510      	push	{r4, lr}
   10ef4:	4604      	mov	r4, r0
	switch (chan) {
   10ef6:	d00b      	beq.n	10f10 <lll_chan_set+0x20>
   10ef8:	2827      	cmp	r0, #39	; 0x27
   10efa:	d00b      	beq.n	10f14 <lll_chan_set+0x24>
   10efc:	2825      	cmp	r0, #37	; 0x25
   10efe:	d10b      	bne.n	10f18 <lll_chan_set+0x28>
		radio_freq_chan_set(2);
   10f00:	2002      	movs	r0, #2
		radio_freq_chan_set(26);
   10f02:	f004 fe81 	bl	15c08 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
   10f06:	4620      	mov	r0, r4
}
   10f08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
   10f0c:	f004 be82 	b.w	15c14 <radio_whiten_iv_set>
		radio_freq_chan_set(26);
   10f10:	201a      	movs	r0, #26
   10f12:	e7f6      	b.n	10f02 <lll_chan_set+0x12>
		radio_freq_chan_set(80);
   10f14:	2050      	movs	r0, #80	; 0x50
   10f16:	e7f4      	b.n	10f02 <lll_chan_set+0x12>
		if (chan < 11) {
   10f18:	280a      	cmp	r0, #10
   10f1a:	d802      	bhi.n	10f22 <lll_chan_set+0x32>
			radio_freq_chan_set(4 + (chan * 2U));
   10f1c:	3002      	adds	r0, #2
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
   10f1e:	0040      	lsls	r0, r0, #1
   10f20:	e7ef      	b.n	10f02 <lll_chan_set+0x12>
		} else if (chan < 40) {
   10f22:	2827      	cmp	r0, #39	; 0x27
   10f24:	d801      	bhi.n	10f2a <lll_chan_set+0x3a>
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
   10f26:	3003      	adds	r0, #3
   10f28:	e7f9      	b.n	10f1e <lll_chan_set+0x2e>
			LL_ASSERT(0);
   10f2a:	f240 13a1 	movw	r3, #417	; 0x1a1
   10f2e:	4a06      	ldr	r2, [pc, #24]	; (10f48 <lll_chan_set+0x58>)
   10f30:	4906      	ldr	r1, [pc, #24]	; (10f4c <lll_chan_set+0x5c>)
   10f32:	4807      	ldr	r0, [pc, #28]	; (10f50 <lll_chan_set+0x60>)
   10f34:	f008 fa1e 	bl	19374 <printk>
   10f38:	4040      	eors	r0, r0
   10f3a:	f380 8811 	msr	BASEPRI, r0
   10f3e:	f04f 0003 	mov.w	r0, #3
   10f42:	df02      	svc	2
   10f44:	e7df      	b.n	10f06 <lll_chan_set+0x16>
   10f46:	bf00      	nop
   10f48:	00021c69 	.word	0x00021c69
   10f4c:	00022577 	.word	0x00022577
   10f50:	00020aa4 	.word	0x00020aa4

00010f54 <disabled_cb>:
		LL_ASSERT(!ret);
	}
}

static void disabled_cb(void *param)
{
   10f54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct ll_adv_set *adv;
	struct node_rx_pdu *rx;
	struct node_rx_cc *cc;
	memq_link_t *link;

	adv = ((struct lll_hdr *)param)->parent;
   10f56:	6805      	ldr	r5, [r0, #0]

	LL_ASSERT(adv->link_cc_free);
   10f58:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
{
   10f5c:	4606      	mov	r6, r0
	LL_ASSERT(adv->link_cc_free);
   10f5e:	b963      	cbnz	r3, 10f7a <disabled_cb+0x26>
   10f60:	f240 4396 	movw	r3, #1174	; 0x496
   10f64:	4a1d      	ldr	r2, [pc, #116]	; (10fdc <disabled_cb+0x88>)
   10f66:	491e      	ldr	r1, [pc, #120]	; (10fe0 <disabled_cb+0x8c>)
   10f68:	481e      	ldr	r0, [pc, #120]	; (10fe4 <disabled_cb+0x90>)
   10f6a:	f008 fa03 	bl	19374 <printk>
   10f6e:	4040      	eors	r0, r0
   10f70:	f380 8811 	msr	BASEPRI, r0
   10f74:	f04f 0003 	mov.w	r0, #3
   10f78:	df02      	svc	2
	link = adv->link_cc_free;
	adv->link_cc_free = NULL;
   10f7a:	2300      	movs	r3, #0
	link = adv->link_cc_free;
   10f7c:	f8d5 70d0 	ldr.w	r7, [r5, #208]	; 0xd0
	adv->link_cc_free = NULL;
   10f80:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0

	LL_ASSERT(adv->node_rx_cc_free);
   10f84:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
   10f88:	b963      	cbnz	r3, 10fa4 <disabled_cb+0x50>
   10f8a:	f240 439a 	movw	r3, #1178	; 0x49a
   10f8e:	4a13      	ldr	r2, [pc, #76]	; (10fdc <disabled_cb+0x88>)
   10f90:	4915      	ldr	r1, [pc, #84]	; (10fe8 <disabled_cb+0x94>)
   10f92:	4814      	ldr	r0, [pc, #80]	; (10fe4 <disabled_cb+0x90>)
   10f94:	f008 f9ee 	bl	19374 <printk>
   10f98:	4040      	eors	r0, r0
   10f9a:	f380 8811 	msr	BASEPRI, r0
   10f9e:	f04f 0003 	mov.w	r0, #3
   10fa2:	df02      	svc	2
	rx = adv->node_rx_cc_free;
   10fa4:	f8d5 40d4 	ldr.w	r4, [r5, #212]	; 0xd4
	adv->node_rx_cc_free = NULL;
   10fa8:	2100      	movs	r1, #0

	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   10faa:	2308      	movs	r3, #8
	adv->node_rx_cc_free = NULL;
   10fac:	f8c5 10d4 	str.w	r1, [r5, #212]	; 0xd4
	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   10fb0:	7123      	strb	r3, [r4, #4]
	rx->hdr.handle = 0xffff;
   10fb2:	f64f 73ff 	movw	r3, #65535	; 0xffff
   10fb6:	80e3      	strh	r3, [r4, #6]

	cc = (void *)rx->pdu;
	memset(cc, 0x00, sizeof(struct node_rx_cc));
   10fb8:	221e      	movs	r2, #30
   10fba:	f104 0020 	add.w	r0, r4, #32
   10fbe:	f00a f846 	bl	1b04e <memset>
	cc->status = BT_HCI_ERR_ADV_TIMEOUT;
   10fc2:	233c      	movs	r3, #60	; 0x3c
   10fc4:	f884 3020 	strb.w	r3, [r4, #32]

	ftr = &(rx->hdr.rx_ftr);
	ftr->param = param;
   10fc8:	60a6      	str	r6, [r4, #8]

	ll_rx_put(link, rx);
   10fca:	4621      	mov	r1, r4
   10fcc:	4638      	mov	r0, r7
   10fce:	f7ff f9b9 	bl	10344 <ll_rx_put>
	ll_rx_sched();
}
   10fd2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	ll_rx_sched();
   10fd6:	f7ff b9bf 	b.w	10358 <ll_rx_sched>
   10fda:	bf00      	nop
   10fdc:	00021d06 	.word	0x00021d06
   10fe0:	00021d3e 	.word	0x00021d3e
   10fe4:	00020aa4 	.word	0x00020aa4
   10fe8:	00021d50 	.word	0x00021d50

00010fec <ticker_cb>:
{
   10fec:	b5f0      	push	{r4, r5, r6, r7, lr}
   10fee:	461d      	mov	r5, r3
	if (IS_ENABLED(CONFIG_BT_TICKER_COMPATIBILITY_MODE) ||
   10ff0:	f64f 73ff 	movw	r3, #65535	; 0xffff
   10ff4:	429a      	cmp	r2, r3
{
   10ff6:	b08b      	sub	sp, #44	; 0x2c
   10ff8:	4607      	mov	r7, r0
   10ffa:	460e      	mov	r6, r1
   10ffc:	4614      	mov	r4, r2
	if (IS_ENABLED(CONFIG_BT_TICKER_COMPATIBILITY_MODE) ||
   10ffe:	d02d      	beq.n	1105c <ticker_cb+0x70>
	return ++hdr->ref;
   11000:	7c2b      	ldrb	r3, [r5, #16]
   11002:	3301      	adds	r3, #1
   11004:	b2db      	uxtb	r3, r3
   11006:	742b      	strb	r3, [r5, #16]
		LL_ASSERT(ref);
   11008:	b963      	cbnz	r3, 11024 <ticker_cb+0x38>
   1100a:	f240 4312 	movw	r3, #1042	; 0x412
   1100e:	4a2f      	ldr	r2, [pc, #188]	; (110cc <ticker_cb+0xe0>)
   11010:	492f      	ldr	r1, [pc, #188]	; (110d0 <ticker_cb+0xe4>)
   11012:	4830      	ldr	r0, [pc, #192]	; (110d4 <ticker_cb+0xe8>)
   11014:	f008 f9ae 	bl	19374 <printk>
   11018:	4040      	eors	r0, r0
   1101a:	f380 8811 	msr	BASEPRI, r0
   1101e:	f04f 0003 	mov.w	r0, #3
   11022:	df02      	svc	2
		p.ticks_at_expire = ticks_at_expire;
   11024:	4a2c      	ldr	r2, [pc, #176]	; (110d8 <ticker_cb+0xec>)
	lll = &adv->lll;
   11026:	f105 031c 	add.w	r3, r5, #28
		p.param = lll;
   1102a:	60d3      	str	r3, [r2, #12]
		mfy.param = &p;
   1102c:	4b2b      	ldr	r3, [pc, #172]	; (110dc <ticker_cb+0xf0>)
		p.lazy = lazy;
   1102e:	8114      	strh	r4, [r2, #8]
		p.remainder = remainder;
   11030:	e9c2 7600 	strd	r7, r6, [r2]
		mfy.param = &p;
   11034:	609a      	str	r2, [r3, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   11036:	2200      	movs	r2, #0
   11038:	4611      	mov	r1, r2
   1103a:	2001      	movs	r0, #1
   1103c:	f7fc fd4e 	bl	dadc <mayfly_enqueue>
		LL_ASSERT(!ret);
   11040:	b160      	cbz	r0, 1105c <ticker_cb+0x70>
   11042:	f240 431e 	movw	r3, #1054	; 0x41e
   11046:	4a21      	ldr	r2, [pc, #132]	; (110cc <ticker_cb+0xe0>)
   11048:	4925      	ldr	r1, [pc, #148]	; (110e0 <ticker_cb+0xf4>)
   1104a:	4822      	ldr	r0, [pc, #136]	; (110d4 <ticker_cb+0xe8>)
   1104c:	f008 f992 	bl	19374 <printk>
   11050:	4040      	eors	r0, r0
   11052:	f380 8811 	msr	BASEPRI, r0
   11056:	f04f 0003 	mov.w	r0, #3
   1105a:	df02      	svc	2
	if (!lll->is_hdcd)
   1105c:	f895 4028 	ldrb.w	r4, [r5, #40]	; 0x28
   11060:	f014 0401 	ands.w	r4, r4, #1
   11064:	d12f      	bne.n	110c6 <ticker_cb+0xda>
		lll_entropy_get(sizeof(random_delay), &random_delay);
   11066:	a909      	add	r1, sp, #36	; 0x24
   11068:	2004      	movs	r0, #4
   1106a:	f7ff fe6f 	bl	10d4c <lll_entropy_get>
		random_delay %= HAL_TICKER_US_TO_TICKS(10000);
   1106e:	9909      	ldr	r1, [sp, #36]	; 0x24
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   11070:	9506      	str	r5, [sp, #24]
		random_delay %= HAL_TICKER_US_TO_TICKS(10000);
   11072:	f240 1247 	movw	r2, #327	; 0x147
   11076:	fbb1 f3f2 	udiv	r3, r1, r2
   1107a:	fb02 1313 	mls	r3, r2, r3, r1
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   1107e:	4a19      	ldr	r2, [pc, #100]	; (110e4 <ticker_cb+0xf8>)
   11080:	21e4      	movs	r1, #228	; 0xe4
   11082:	1aaa      	subs	r2, r5, r2
   11084:	fbb2 f2f1 	udiv	r2, r2, r1
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   11088:	4917      	ldr	r1, [pc, #92]	; (110e8 <ticker_cb+0xfc>)
				    (TICKER_ID_ADV_BASE +
   1108a:	3202      	adds	r2, #2
		random_delay += 1;
   1108c:	3301      	adds	r3, #1
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1108e:	e9cd 4104 	strd	r4, r1, [sp, #16]
   11092:	e9cd 4402 	strd	r4, r4, [sp, #8]
   11096:	e9cd 4400 	strd	r4, r4, [sp]
   1109a:	b2d2      	uxtb	r2, r2
   1109c:	2101      	movs	r1, #1
   1109e:	4620      	mov	r0, r4
		random_delay += 1;
   110a0:	9309      	str	r3, [sp, #36]	; 0x24
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   110a2:	f7fd f9e3 	bl	e46c <ticker_update>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   110a6:	f030 0302 	bics.w	r3, r0, #2
   110aa:	d00c      	beq.n	110c6 <ticker_cb+0xda>
   110ac:	f240 4335 	movw	r3, #1077	; 0x435
   110b0:	4a06      	ldr	r2, [pc, #24]	; (110cc <ticker_cb+0xe0>)
   110b2:	490e      	ldr	r1, [pc, #56]	; (110ec <ticker_cb+0x100>)
   110b4:	4807      	ldr	r0, [pc, #28]	; (110d4 <ticker_cb+0xe8>)
   110b6:	f008 f95d 	bl	19374 <printk>
   110ba:	4040      	eors	r0, r0
   110bc:	f380 8811 	msr	BASEPRI, r0
   110c0:	f04f 0003 	mov.w	r0, #3
   110c4:	df02      	svc	2
}
   110c6:	b00b      	add	sp, #44	; 0x2c
   110c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   110ca:	bf00      	nop
   110cc:	00021d06 	.word	0x00021d06
   110d0:	00021be9 	.word	0x00021be9
   110d4:	00020aa4 	.word	0x00020aa4
   110d8:	20001178 	.word	0x20001178
   110dc:	200058d0 	.word	0x200058d0
   110e0:	00021ae5 	.word	0x00021ae5
   110e4:	20001094 	.word	0x20001094
   110e8:	00011211 	.word	0x00011211
   110ec:	00021d75 	.word	0x00021d75

000110f0 <conn_release>:

static inline void conn_release(struct ll_adv_set *adv)
{
   110f0:	b570      	push	{r4, r5, r6, lr}
	struct lll_conn *lll = adv->lll.conn;
   110f2:	6a45      	ldr	r5, [r0, #36]	; 0x24
	memq_link_t *link;

	LL_ASSERT(!lll->link_tx_free);
   110f4:	6deb      	ldr	r3, [r5, #92]	; 0x5c
{
   110f6:	4604      	mov	r4, r0
	LL_ASSERT(!lll->link_tx_free);
   110f8:	b163      	cbz	r3, 11114 <conn_release+0x24>
   110fa:	f240 43b1 	movw	r3, #1201	; 0x4b1
   110fe:	4a19      	ldr	r2, [pc, #100]	; (11164 <conn_release+0x74>)
   11100:	4919      	ldr	r1, [pc, #100]	; (11168 <conn_release+0x78>)
   11102:	481a      	ldr	r0, [pc, #104]	; (1116c <conn_release+0x7c>)
   11104:	f008 f936 	bl	19374 <printk>
   11108:	4040      	eors	r0, r0
   1110a:	f380 8811 	msr	BASEPRI, r0
   1110e:	f04f 0003 	mov.w	r0, #3
   11112:	df02      	svc	2
	link = memq_deinit(&lll->memq_tx.head, &lll->memq_tx.tail);
   11114:	f105 0150 	add.w	r1, r5, #80	; 0x50
   11118:	f105 004c 	add.w	r0, r5, #76	; 0x4c
   1111c:	f00b fef9 	bl	1cf12 <memq_deinit>
	LL_ASSERT(link);
   11120:	4606      	mov	r6, r0
   11122:	b960      	cbnz	r0, 1113e <conn_release+0x4e>
   11124:	f240 43b3 	movw	r3, #1203	; 0x4b3
   11128:	4a0e      	ldr	r2, [pc, #56]	; (11164 <conn_release+0x74>)
   1112a:	4911      	ldr	r1, [pc, #68]	; (11170 <conn_release+0x80>)
   1112c:	480f      	ldr	r0, [pc, #60]	; (1116c <conn_release+0x7c>)
   1112e:	f008 f921 	bl	19374 <printk>
   11132:	4040      	eors	r0, r0
   11134:	f380 8811 	msr	BASEPRI, r0
   11138:	f04f 0003 	mov.w	r0, #3
   1113c:	df02      	svc	2
	lll->link_tx_free = link;

	ll_conn_release(lll->hdr.parent);
   1113e:	6828      	ldr	r0, [r5, #0]
	lll->link_tx_free = link;
   11140:	65ee      	str	r6, [r5, #92]	; 0x5c
	adv->lll.conn = NULL;
   11142:	2500      	movs	r5, #0
	ll_conn_release(lll->hdr.parent);
   11144:	f001 f8d2 	bl	122ec <ll_conn_release>

	ll_rx_release(adv->node_rx_cc_free);
   11148:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
	adv->lll.conn = NULL;
   1114c:	6265      	str	r5, [r4, #36]	; 0x24
	ll_rx_release(adv->node_rx_cc_free);
   1114e:	f7ff f8f3 	bl	10338 <ll_rx_release>
	adv->node_rx_cc_free = NULL;
   11152:	f8c4 50d4 	str.w	r5, [r4, #212]	; 0xd4
	ll_rx_link_release(adv->link_cc_free);
   11156:	f8d4 00d0 	ldr.w	r0, [r4, #208]	; 0xd0
   1115a:	f7ff f8e1 	bl	10320 <ll_rx_link_release>
	adv->link_cc_free = NULL;
   1115e:	f8c4 50d0 	str.w	r5, [r4, #208]	; 0xd0
}
   11162:	bd70      	pop	{r4, r5, r6, pc}
   11164:	00021d06 	.word	0x00021d06
   11168:	00021bc8 	.word	0x00021bc8
   1116c:	00020aa4 	.word	0x00020aa4
   11170:	00021fdb 	.word	0x00021fdb

00011174 <ticker_op_stop_cb>:
{
   11174:	b570      	push	{r4, r5, r6, lr}
   11176:	460c      	mov	r4, r1
	if (status != TICKER_STATUS_SUCCESS) {
   11178:	2800      	cmp	r0, #0
   1117a:	d12f      	bne.n	111dc <ticker_op_stop_cb+0x68>
	mfy.param = &adv->lll;
   1117c:	4b1d      	ldr	r3, [pc, #116]	; (111f4 <ticker_op_stop_cb+0x80>)
   1117e:	4d1e      	ldr	r5, [pc, #120]	; (111f8 <ticker_op_stop_cb+0x84>)
   11180:	f101 021c 	add.w	r2, r1, #28
   11184:	609a      	str	r2, [r3, #8]
	if (hdr->ref) {
   11186:	7c0a      	ldrb	r2, [r1, #16]
   11188:	461e      	mov	r6, r3
   1118a:	b342      	cbz	r2, 111de <ticker_op_stop_cb+0x6a>
		LL_ASSERT(!hdr->disabled_cb);
   1118c:	694b      	ldr	r3, [r1, #20]
   1118e:	b163      	cbz	r3, 111aa <ticker_op_stop_cb+0x36>
   11190:	f240 437c 	movw	r3, #1148	; 0x47c
   11194:	4a19      	ldr	r2, [pc, #100]	; (111fc <ticker_op_stop_cb+0x88>)
   11196:	491a      	ldr	r1, [pc, #104]	; (11200 <ticker_op_stop_cb+0x8c>)
   11198:	481a      	ldr	r0, [pc, #104]	; (11204 <ticker_op_stop_cb+0x90>)
   1119a:	f008 f8eb 	bl	19374 <printk>
   1119e:	4040      	eors	r0, r0
   111a0:	f380 8811 	msr	BASEPRI, r0
   111a4:	f04f 0003 	mov.w	r0, #3
   111a8:	df02      	svc	2
		hdr->disabled_param = mfy.param;
   111aa:	68b3      	ldr	r3, [r6, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   111ac:	2200      	movs	r2, #0
		hdr->disabled_cb = disabled_cb;
   111ae:	e9c4 5305 	strd	r5, r3, [r4, #20]
		mfy.fp = lll_disable;
   111b2:	4b15      	ldr	r3, [pc, #84]	; (11208 <ticker_op_stop_cb+0x94>)
   111b4:	60f3      	str	r3, [r6, #12]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   111b6:	4611      	mov	r1, r2
   111b8:	4b0e      	ldr	r3, [pc, #56]	; (111f4 <ticker_op_stop_cb+0x80>)
   111ba:	2002      	movs	r0, #2
   111bc:	f7fc fc8e 	bl	dadc <mayfly_enqueue>
		LL_ASSERT(!ret);
   111c0:	b160      	cbz	r0, 111dc <ticker_op_stop_cb+0x68>
   111c2:	f240 4383 	movw	r3, #1155	; 0x483
		LL_ASSERT(!ret);
   111c6:	4a0d      	ldr	r2, [pc, #52]	; (111fc <ticker_op_stop_cb+0x88>)
   111c8:	4910      	ldr	r1, [pc, #64]	; (1120c <ticker_op_stop_cb+0x98>)
   111ca:	480e      	ldr	r0, [pc, #56]	; (11204 <ticker_op_stop_cb+0x90>)
   111cc:	f008 f8d2 	bl	19374 <printk>
   111d0:	4040      	eors	r0, r0
   111d2:	f380 8811 	msr	BASEPRI, r0
   111d6:	f04f 0003 	mov.w	r0, #3
   111da:	df02      	svc	2
}
   111dc:	bd70      	pop	{r4, r5, r6, pc}
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   111de:	2101      	movs	r1, #1
   111e0:	2002      	movs	r0, #2
		mfy.fp = disabled_cb;
   111e2:	60dd      	str	r5, [r3, #12]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   111e4:	f7fc fc7a 	bl	dadc <mayfly_enqueue>
		LL_ASSERT(!ret);
   111e8:	2800      	cmp	r0, #0
   111ea:	d0f7      	beq.n	111dc <ticker_op_stop_cb+0x68>
   111ec:	f44f 6391 	mov.w	r3, #1160	; 0x488
   111f0:	e7e9      	b.n	111c6 <ticker_op_stop_cb+0x52>
   111f2:	bf00      	nop
   111f4:	200058e0 	.word	0x200058e0
   111f8:	00010f55 	.word	0x00010f55
   111fc:	00021d06 	.word	0x00021d06
   11200:	00021d8e 	.word	0x00021d8e
   11204:	00020aa4 	.word	0x00020aa4
   11208:	00010dbd 	.word	0x00010dbd
   1120c:	00021ae5 	.word	0x00021ae5

00011210 <ticker_op_update_cb>:
{
   11210:	b510      	push	{r4, lr}
   11212:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
   11214:	b180      	cbz	r0, 11238 <ticker_op_update_cb+0x28>
   11216:	f7ff f947 	bl	104a8 <ull_disable_mark_get>
   1121a:	4284      	cmp	r4, r0
   1121c:	d00c      	beq.n	11238 <ticker_op_update_cb+0x28>
   1121e:	f240 433e 	movw	r3, #1086	; 0x43e
   11222:	4a06      	ldr	r2, [pc, #24]	; (1123c <ticker_op_update_cb+0x2c>)
   11224:	4906      	ldr	r1, [pc, #24]	; (11240 <ticker_op_update_cb+0x30>)
   11226:	4807      	ldr	r0, [pc, #28]	; (11244 <ticker_op_update_cb+0x34>)
   11228:	f008 f8a4 	bl	19374 <printk>
   1122c:	4040      	eors	r0, r0
   1122e:	f380 8811 	msr	BASEPRI, r0
   11232:	f04f 0003 	mov.w	r0, #3
   11236:	df02      	svc	2
}
   11238:	bd10      	pop	{r4, pc}
   1123a:	bf00      	nop
   1123c:	00021d06 	.word	0x00021d06
   11240:	00021da0 	.word	0x00021da0
   11244:	00020aa4 	.word	0x00020aa4

00011248 <ticker_stop_cb>:
{
   11248:	b537      	push	{r0, r1, r2, r4, r5, lr}
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   1124a:	4c17      	ldr	r4, [pc, #92]	; (112a8 <ticker_stop_cb+0x60>)
{
   1124c:	461d      	mov	r5, r3
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   1124e:	1b1c      	subs	r4, r3, r4
   11250:	22e4      	movs	r2, #228	; 0xe4
   11252:	fbb4 f4f2 	udiv	r4, r4, r2
	LL_ASSERT(handle < BT_CTLR_ADV_MAX);
   11256:	b2a3      	uxth	r3, r4
   11258:	b163      	cbz	r3, 11274 <ticker_stop_cb+0x2c>
   1125a:	f240 4359 	movw	r3, #1113	; 0x459
   1125e:	4a13      	ldr	r2, [pc, #76]	; (112ac <ticker_stop_cb+0x64>)
   11260:	4913      	ldr	r1, [pc, #76]	; (112b0 <ticker_stop_cb+0x68>)
   11262:	4814      	ldr	r0, [pc, #80]	; (112b4 <ticker_stop_cb+0x6c>)
   11264:	f008 f886 	bl	19374 <printk>
   11268:	4040      	eors	r0, r0
   1126a:	f380 8811 	msr	BASEPRI, r0
   1126e:	f04f 0003 	mov.w	r0, #3
   11272:	df02      	svc	2
			  TICKER_ID_ADV_BASE + handle,
   11274:	1ca2      	adds	r2, r4, #2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
   11276:	4b10      	ldr	r3, [pc, #64]	; (112b8 <ticker_stop_cb+0x70>)
   11278:	9500      	str	r5, [sp, #0]
   1127a:	b2d2      	uxtb	r2, r2
   1127c:	2101      	movs	r1, #1
   1127e:	2000      	movs	r0, #0
   11280:	f7fd f93c 	bl	e4fc <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   11284:	f030 0302 	bics.w	r3, r0, #2
   11288:	d00c      	beq.n	112a4 <ticker_stop_cb+0x5c>
   1128a:	f240 435f 	movw	r3, #1119	; 0x45f
   1128e:	4a07      	ldr	r2, [pc, #28]	; (112ac <ticker_stop_cb+0x64>)
   11290:	490a      	ldr	r1, [pc, #40]	; (112bc <ticker_stop_cb+0x74>)
   11292:	4808      	ldr	r0, [pc, #32]	; (112b4 <ticker_stop_cb+0x6c>)
   11294:	f008 f86e 	bl	19374 <printk>
   11298:	4040      	eors	r0, r0
   1129a:	f380 8811 	msr	BASEPRI, r0
   1129e:	f04f 0003 	mov.w	r0, #3
   112a2:	df02      	svc	2
}
   112a4:	b003      	add	sp, #12
   112a6:	bd30      	pop	{r4, r5, pc}
   112a8:	20001094 	.word	0x20001094
   112ac:	00021d06 	.word	0x00021d06
   112b0:	00021dcf 	.word	0x00021dcf
   112b4:	00020aa4 	.word	0x00020aa4
   112b8:	00011175 	.word	0x00011175
   112bc:	00021d75 	.word	0x00021d75

000112c0 <ll_adv_params_set>:
{
   112c0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	if (!adv || adv->is_enabled) {
   112c4:	4c44      	ldr	r4, [pc, #272]	; (113d8 <ll_adv_params_set+0x118>)
{
   112c6:	4699      	mov	r9, r3
	if (!adv || adv->is_enabled) {
   112c8:	f894 60cc 	ldrb.w	r6, [r4, #204]	; 0xcc
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
   112cc:	4b43      	ldr	r3, [pc, #268]	; (113dc <ll_adv_params_set+0x11c>)
   112ce:	9300      	str	r3, [sp, #0]
   112d0:	2301      	movs	r3, #1
	if (!adv || adv->is_enabled) {
   112d2:	401e      	ands	r6, r3
{
   112d4:	4617      	mov	r7, r2
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
   112d6:	f88d 3004 	strb.w	r3, [sp, #4]
	if (!adv || adv->is_enabled) {
   112da:	d17a      	bne.n	113d2 <ll_adv_params_set+0x112>
		adv->interval = 0;
   112dc:	4299      	cmp	r1, r3
	adv->lll.chan_map = chan_map;
   112de:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
   112e2:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
   112e6:	f362 0343 	bfi	r3, r2, #1, #3
   112ea:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	adv->lll.filter_policy = filter_policy;
   112ee:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   112f2:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
   112f6:	f362 0301 	bfi	r3, r2, #0, #2
   112fa:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
   112fe:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
   11302:	f04f 0527 	mov.w	r5, #39	; 0x27
   11306:	f04f 032d 	mov.w	r3, #45	; 0x2d
   1130a:	fb15 3502 	smlabb	r5, r5, r2, r3
	pdu->type = pdu_adv_type[adv_type];
   1130e:	ab02      	add	r3, sp, #8
		adv->interval = 0;
   11310:	bf08      	it	eq
   11312:	2000      	moveq	r0, #0
	pdu->type = pdu_adv_type[adv_type];
   11314:	4419      	add	r1, r3
   11316:	f8a4 00d8 	strh.w	r0, [r4, #216]	; 0xd8
   1131a:	f811 2c08 	ldrb.w	r2, [r1, #-8]
   1131e:	5d63      	ldrb	r3, [r4, r5]
   11320:	f362 0303 	bfi	r3, r2, #0, #4
	pdu->rfu = 0;
   11324:	f366 1304 	bfi	r3, r6, #4, #1
	    ((pdu->type == PDU_ADV_TYPE_ADV_IND) ||
   11328:	b2db      	uxtb	r3, r3
	if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2) &&
   1132a:	f013 0f0e 	tst.w	r3, #14
   1132e:	bf0c      	ite	eq
   11330:	2201      	moveq	r2, #1
   11332:	2200      	movne	r2, #0
   11334:	f362 1345 	bfi	r3, r2, #5, #1
   11338:	5563      	strb	r3, [r4, r5]
	adv->own_addr_type = own_addr_type;
   1133a:	f894 30da 	ldrb.w	r3, [r4, #218]	; 0xda
   1133e:	f367 0301 	bfi	r3, r7, #0, #2
   11342:	f884 30da 	strb.w	r3, [r4, #218]	; 0xda
	if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
   11346:	b2db      	uxtb	r3, r3
   11348:	079a      	lsls	r2, r3, #30
   1134a:	eb04 0805 	add.w	r8, r4, r5
   1134e:	d509      	bpl.n	11364 <ll_adv_params_set+0xa4>
		adv->id_addr_type = direct_addr_type;
   11350:	f369 0382 	bfi	r3, r9, #2, #1
		memcpy(&adv->id_addr, direct_addr, BDADDR_SIZE);
   11354:	2206      	movs	r2, #6
   11356:	990a      	ldr	r1, [sp, #40]	; 0x28
		adv->id_addr_type = direct_addr_type;
   11358:	f884 30da 	strb.w	r3, [r4, #218]	; 0xda
		memcpy(&adv->id_addr, direct_addr, BDADDR_SIZE);
   1135c:	f104 00dc 	add.w	r0, r4, #220	; 0xdc
   11360:	f009 fe4b 	bl	1affa <memcpy>
	pdu->tx_addr = own_addr_type & 0x1;
   11364:	5d61      	ldrb	r1, [r4, r5]
   11366:	f007 0701 	and.w	r7, r7, #1
   1136a:	f367 1186 	bfi	r1, r7, #6, #1
	pdu->rx_addr = 0;
   1136e:	f36f 11c7 	bfc	r1, #7, #1
   11372:	5561      	strb	r1, [r4, r5]
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   11374:	b2c9      	uxtb	r1, r1
   11376:	f001 030f 	and.w	r3, r1, #15
   1137a:	2b01      	cmp	r3, #1
   1137c:	d123      	bne.n	113c6 <ll_adv_params_set+0x106>
		pdu->rx_addr = direct_addr_type;
   1137e:	f369 11c7 	bfi	r1, r9, #7, #1
   11382:	5561      	strb	r1, [r4, r5]
		memcpy(&pdu->direct_ind.tgt_addr[0], direct_addr, BDADDR_SIZE);
   11384:	2206      	movs	r2, #6
   11386:	990a      	ldr	r1, [sp, #40]	; 0x28
   11388:	f108 0008 	add.w	r0, r8, #8
   1138c:	f009 fe35 	bl	1affa <memcpy>
		pdu->len = sizeof(struct pdu_adv_direct_ind);
   11390:	230c      	movs	r3, #12
		pdu->len = BDADDR_SIZE;
   11392:	f888 3001 	strb.w	r3, [r8, #1]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   11396:	f894 107c 	ldrb.w	r1, [r4, #124]	; 0x7c
   1139a:	237d      	movs	r3, #125	; 0x7d
   1139c:	2227      	movs	r2, #39	; 0x27
   1139e:	fb12 3201 	smlabb	r2, r2, r1, r3
   113a2:	18a1      	adds	r1, r4, r2
	pdu->tx_addr = own_addr_type & 0x1;
   113a4:	5ca3      	ldrb	r3, [r4, r2]
   113a6:	f367 1386 	bfi	r3, r7, #6, #1
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
   113aa:	f003 0340 	and.w	r3, r3, #64	; 0x40
   113ae:	f043 0304 	orr.w	r3, r3, #4
   113b2:	54a3      	strb	r3, [r4, r2]
	if (pdu->len == 0) {
   113b4:	784b      	ldrb	r3, [r1, #1]
   113b6:	b913      	cbnz	r3, 113be <ll_adv_params_set+0xfe>
		pdu->len = BDADDR_SIZE;
   113b8:	2206      	movs	r2, #6
   113ba:	704a      	strb	r2, [r1, #1]
	return 0;
   113bc:	461e      	mov	r6, r3
}
   113be:	4630      	mov	r0, r6
   113c0:	b003      	add	sp, #12
   113c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if (pdu->len == 0) {
   113c6:	f898 3001 	ldrb.w	r3, [r8, #1]
   113ca:	2b00      	cmp	r3, #0
   113cc:	d1e3      	bne.n	11396 <ll_adv_params_set+0xd6>
		pdu->len = BDADDR_SIZE;
   113ce:	2306      	movs	r3, #6
   113d0:	e7df      	b.n	11392 <ll_adv_params_set+0xd2>
		return BT_HCI_ERR_CMD_DISALLOWED;
   113d2:	260c      	movs	r6, #12
   113d4:	e7f3      	b.n	113be <ll_adv_params_set+0xfe>
   113d6:	bf00      	nop
   113d8:	20001094 	.word	0x20001094
   113dc:	02060100 	.word	0x02060100

000113e0 <ll_adv_data_set>:
{
   113e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   113e4:	4a29      	ldr	r2, [pc, #164]	; (1148c <ll_adv_data_set+0xac>)
   113e6:	f892 402c 	ldrb.w	r4, [r2, #44]	; 0x2c
   113ea:	232d      	movs	r3, #45	; 0x2d
   113ec:	4607      	mov	r7, r0
   113ee:	2027      	movs	r0, #39	; 0x27
   113f0:	fb10 3004 	smlabb	r0, r0, r4, r3
   113f4:	4689      	mov	r9, r1
	if ((prev->type == PDU_ADV_TYPE_DIRECT_IND) ||
   113f6:	f812 c000 	ldrb.w	ip, [r2, r0]
   113fa:	f00c 030f 	and.w	r3, ip, #15
   113fe:	2b01      	cmp	r3, #1
   11400:	eb02 0100 	add.w	r1, r2, r0
   11404:	4615      	mov	r5, r2
   11406:	d03e      	beq.n	11486 <ll_adv_data_set+0xa6>
	if (pdu->first == pdu->last) {
   11408:	f892 302b 	ldrb.w	r3, [r2, #43]	; 0x2b
   1140c:	42a3      	cmp	r3, r4
   1140e:	d104      	bne.n	1141a <ll_adv_data_set+0x3a>
		last = pdu->last + 1;
   11410:	3401      	adds	r4, #1
   11412:	b2e4      	uxtb	r4, r4
			last = 0U;
   11414:	2c02      	cmp	r4, #2
   11416:	bf08      	it	eq
   11418:	2400      	moveq	r4, #0
	return (void *)pdu->pdu[last];
   1141a:	2627      	movs	r6, #39	; 0x27
   1141c:	232d      	movs	r3, #45	; 0x2d
   1141e:	fb16 3304 	smlabb	r3, r6, r4, r3
   11422:	eb05 0803 	add.w	r8, r5, r3
	pdu->type = prev->type;
   11426:	5cee      	ldrb	r6, [r5, r3]
   11428:	f36c 0603 	bfi	r6, ip, #0, #4
	pdu->rfu = 0U;
   1142c:	f36f 1604 	bfc	r6, #4, #1
   11430:	54ee      	strb	r6, [r5, r3]
		pdu->chan_sel = prev->chan_sel;
   11432:	5c16      	ldrb	r6, [r2, r0]
   11434:	f815 c003 	ldrb.w	ip, [r5, r3]
   11438:	f3c6 1640 	ubfx	r6, r6, #5, #1
   1143c:	f366 1c45 	bfi	ip, r6, #5, #1
   11440:	f805 c003 	strb.w	ip, [r5, r3]
	pdu->tx_addr = prev->tx_addr;
   11444:	5c16      	ldrb	r6, [r2, r0]
   11446:	fa5f fc8c 	uxtb.w	ip, ip
   1144a:	f3c6 1680 	ubfx	r6, r6, #6, #1
   1144e:	f366 1c86 	bfi	ip, r6, #6, #1
   11452:	f805 c003 	strb.w	ip, [r5, r3]
	pdu->rx_addr = prev->rx_addr;
   11456:	5c12      	ldrb	r2, [r2, r0]
   11458:	fa5f f08c 	uxtb.w	r0, ip
   1145c:	09d2      	lsrs	r2, r2, #7
   1145e:	f362 10c7 	bfi	r0, r2, #7, #1
   11462:	54e8      	strb	r0, [r5, r3]
	memcpy(&pdu->adv_ind.addr[0], &prev->adv_ind.addr[0], BDADDR_SIZE);
   11464:	2206      	movs	r2, #6
   11466:	3102      	adds	r1, #2
   11468:	f108 0002 	add.w	r0, r8, #2
   1146c:	f009 fdc5 	bl	1affa <memcpy>
	memcpy(&pdu->adv_ind.data[0], data, len);
   11470:	463a      	mov	r2, r7
   11472:	4649      	mov	r1, r9
   11474:	f108 0008 	add.w	r0, r8, #8
	pdu->len = BDADDR_SIZE + len;
   11478:	3706      	adds	r7, #6
	memcpy(&pdu->adv_ind.data[0], data, len);
   1147a:	f009 fdbe 	bl	1affa <memcpy>
	pdu->len = BDADDR_SIZE + len;
   1147e:	f888 7001 	strb.w	r7, [r8, #1]
	pdu->last = idx;
   11482:	f885 402c 	strb.w	r4, [r5, #44]	; 0x2c
}
   11486:	2000      	movs	r0, #0
   11488:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1148c:	20001094 	.word	0x20001094

00011490 <ll_adv_scan_rsp_set>:
{
   11490:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   11494:	4a1e      	ldr	r2, [pc, #120]	; (11510 <ll_adv_scan_rsp_set+0x80>)
   11496:	f892 407c 	ldrb.w	r4, [r2, #124]	; 0x7c
   1149a:	237d      	movs	r3, #125	; 0x7d
   1149c:	f04f 0c27 	mov.w	ip, #39	; 0x27
   114a0:	fb1c 3c04 	smlabb	ip, ip, r4, r3
	if (pdu->first == pdu->last) {
   114a4:	f892 307b 	ldrb.w	r3, [r2, #123]	; 0x7b
   114a8:	42a3      	cmp	r3, r4
   114aa:	4688      	mov	r8, r1
   114ac:	4607      	mov	r7, r0
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   114ae:	eb02 010c 	add.w	r1, r2, ip
	if (pdu->first == pdu->last) {
   114b2:	4615      	mov	r5, r2
   114b4:	d104      	bne.n	114c0 <ll_adv_scan_rsp_set+0x30>
		last = pdu->last + 1;
   114b6:	3401      	adds	r4, #1
   114b8:	b2e4      	uxtb	r4, r4
			last = 0U;
   114ba:	2c02      	cmp	r4, #2
   114bc:	bf08      	it	eq
   114be:	2400      	moveq	r4, #0
	return (void *)pdu->pdu[last];
   114c0:	2027      	movs	r0, #39	; 0x27
   114c2:	237d      	movs	r3, #125	; 0x7d
   114c4:	fb10 3304 	smlabb	r3, r0, r4, r3
   114c8:	18ee      	adds	r6, r5, r3
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
   114ca:	5ce8      	ldrb	r0, [r5, r3]
   114cc:	f020 003f 	bic.w	r0, r0, #63	; 0x3f
   114d0:	f040 0004 	orr.w	r0, r0, #4
   114d4:	54e8      	strb	r0, [r5, r3]
	pdu->tx_addr = prev->tx_addr;
   114d6:	f812 000c 	ldrb.w	r0, [r2, ip]
   114da:	5cea      	ldrb	r2, [r5, r3]
   114dc:	f3c0 1080 	ubfx	r0, r0, #6, #1
   114e0:	f360 1286 	bfi	r2, r0, #6, #1
	pdu->rx_addr = 0;
   114e4:	f36f 12c7 	bfc	r2, #7, #1
   114e8:	54ea      	strb	r2, [r5, r3]
	pdu->len = BDADDR_SIZE + len;
   114ea:	1dbb      	adds	r3, r7, #6
   114ec:	7073      	strb	r3, [r6, #1]
	memcpy(&pdu->scan_rsp.addr[0], &prev->scan_rsp.addr[0], BDADDR_SIZE);
   114ee:	2206      	movs	r2, #6
   114f0:	3102      	adds	r1, #2
   114f2:	1cb0      	adds	r0, r6, #2
   114f4:	f009 fd81 	bl	1affa <memcpy>
	memcpy(&pdu->scan_rsp.data[0], data, len);
   114f8:	463a      	mov	r2, r7
   114fa:	4641      	mov	r1, r8
   114fc:	f106 0008 	add.w	r0, r6, #8
   11500:	f009 fd7b 	bl	1affa <memcpy>
	pdu->last = idx;
   11504:	f885 407c 	strb.w	r4, [r5, #124]	; 0x7c
}
   11508:	2000      	movs	r0, #0
   1150a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1150e:	bf00      	nop
   11510:	20001094 	.word	0x20001094

00011514 <ull_adv_handle_get>:
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   11514:	4b03      	ldr	r3, [pc, #12]	; (11524 <ull_adv_handle_get+0x10>)
   11516:	1ac0      	subs	r0, r0, r3
   11518:	23e4      	movs	r3, #228	; 0xe4
   1151a:	fbb0 f0f3 	udiv	r0, r0, r3
}
   1151e:	b280      	uxth	r0, r0
   11520:	4770      	bx	lr
   11522:	bf00      	nop
   11524:	20001094 	.word	0x20001094

00011528 <ull_adv_lll_handle_get>:
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   11528:	6800      	ldr	r0, [r0, #0]
   1152a:	4b03      	ldr	r3, [pc, #12]	; (11538 <ull_adv_lll_handle_get+0x10>)
   1152c:	1ac0      	subs	r0, r0, r3
   1152e:	23e4      	movs	r3, #228	; 0xe4
   11530:	fbb0 f0f3 	udiv	r0, r0, r3
}
   11534:	b280      	uxth	r0, r0
   11536:	4770      	bx	lr
   11538:	20001094 	.word	0x20001094

0001153c <ull_adv_is_enabled_get>:
	if (handle >= BT_CTLR_ADV_MAX) {
   1153c:	b938      	cbnz	r0, 1154e <ull_adv_is_enabled_get+0x12>
	if (!adv || !adv->is_enabled) {
   1153e:	4805      	ldr	r0, [pc, #20]	; (11554 <ull_adv_is_enabled_get+0x18>)
   11540:	f890 30cc 	ldrb.w	r3, [r0, #204]	; 0xcc
	return &ll_adv[handle];
   11544:	f013 0f01 	tst.w	r3, #1
   11548:	bf08      	it	eq
   1154a:	2000      	moveq	r0, #0
   1154c:	4770      	bx	lr
		return NULL;
   1154e:	2000      	movs	r0, #0
}
   11550:	4770      	bx	lr
   11552:	bf00      	nop
   11554:	20001094 	.word	0x20001094

00011558 <disable.constprop.5>:
#endif /* CONFIG_BT_PERIPHERAL */

static inline u8_t disable(u16_t handle)
   11558:	b530      	push	{r4, r5, lr}
   1155a:	b085      	sub	sp, #20
{
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   1155c:	2302      	movs	r3, #2
	struct ll_adv_set *adv;
	void *mark;
	u32_t ret;

	adv = ull_adv_is_enabled_get(handle);
   1155e:	2000      	movs	r0, #0
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   11560:	9303      	str	r3, [sp, #12]
	adv = ull_adv_is_enabled_get(handle);
   11562:	f7ff ffeb 	bl	1153c <ull_adv_is_enabled_get>
	if (!adv) {
   11566:	4604      	mov	r4, r0
   11568:	b910      	cbnz	r0, 11570 <disable.constprop.5+0x18>
		ret = ull_ticker_status_take(ret, &ret_cb);
		if (ret) {
			mark = ull_disable_mark(adv);
			LL_ASSERT(mark == adv);

			return BT_HCI_ERR_CMD_DISALLOWED;
   1156a:	200c      	movs	r0, #12
		ull_filter_adv_scan_state_cb(0);
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	return 0;
}
   1156c:	b005      	add	sp, #20
   1156e:	bd30      	pop	{r4, r5, pc}
	mark = ull_disable_mark(adv);
   11570:	f7fe ff84 	bl	1047c <ull_disable_mark>
	LL_ASSERT(mark == adv);
   11574:	4284      	cmp	r4, r0
   11576:	d00c      	beq.n	11592 <disable.constprop.5+0x3a>
   11578:	f240 43cd 	movw	r3, #1229	; 0x4cd
   1157c:	4a3a      	ldr	r2, [pc, #232]	; (11668 <disable.constprop.5+0x110>)
   1157e:	493b      	ldr	r1, [pc, #236]	; (1166c <disable.constprop.5+0x114>)
   11580:	483b      	ldr	r0, [pc, #236]	; (11670 <disable.constprop.5+0x118>)
   11582:	f007 fef7 	bl	19374 <printk>
   11586:	4040      	eors	r0, r0
   11588:	f380 8811 	msr	BASEPRI, r0
   1158c:	f04f 0003 	mov.w	r0, #3
   11590:	df02      	svc	2
	if (adv->lll.is_hdcd) {
   11592:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
   11596:	f013 0f01 	tst.w	r3, #1
   1159a:	ad03      	add	r5, sp, #12
   1159c:	d01f      	beq.n	115de <disable.constprop.5+0x86>
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   1159e:	2103      	movs	r1, #3
   115a0:	9500      	str	r5, [sp, #0]
   115a2:	4b34      	ldr	r3, [pc, #208]	; (11674 <disable.constprop.5+0x11c>)
   115a4:	2201      	movs	r2, #1
   115a6:	2000      	movs	r0, #0
   115a8:	f7fc ffa8 	bl	e4fc <ticker_stop>
		ret = ull_ticker_status_take(ret, &ret_cb);
   115ac:	4629      	mov	r1, r5
   115ae:	f7fe ff59 	bl	10464 <ull_ticker_status_take>
		if (ret) {
   115b2:	b190      	cbz	r0, 115da <disable.constprop.5+0x82>
			mark = ull_disable_mark(adv);
   115b4:	4620      	mov	r0, r4
   115b6:	f7fe ff61 	bl	1047c <ull_disable_mark>
			LL_ASSERT(mark == adv);
   115ba:	4284      	cmp	r4, r0
   115bc:	d0d5      	beq.n	1156a <disable.constprop.5+0x12>
   115be:	f240 43d7 	movw	r3, #1239	; 0x4d7
   115c2:	4a29      	ldr	r2, [pc, #164]	; (11668 <disable.constprop.5+0x110>)
   115c4:	4929      	ldr	r1, [pc, #164]	; (1166c <disable.constprop.5+0x114>)
   115c6:	482a      	ldr	r0, [pc, #168]	; (11670 <disable.constprop.5+0x118>)
   115c8:	f007 fed4 	bl	19374 <printk>
   115cc:	4040      	eors	r0, r0
   115ce:	f380 8811 	msr	BASEPRI, r0
   115d2:	f04f 0003 	mov.w	r0, #3
   115d6:	df02      	svc	2
   115d8:	e7c7      	b.n	1156a <disable.constprop.5+0x12>
		ret_cb = TICKER_STATUS_BUSY;
   115da:	2302      	movs	r3, #2
   115dc:	9303      	str	r3, [sp, #12]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   115de:	2103      	movs	r1, #3
   115e0:	9500      	str	r5, [sp, #0]
   115e2:	4b24      	ldr	r3, [pc, #144]	; (11674 <disable.constprop.5+0x11c>)
   115e4:	2202      	movs	r2, #2
   115e6:	2000      	movs	r0, #0
   115e8:	f7fc ff88 	bl	e4fc <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
   115ec:	4629      	mov	r1, r5
   115ee:	f7fe ff39 	bl	10464 <ull_ticker_status_take>
	if (ret) {
   115f2:	b138      	cbz	r0, 11604 <disable.constprop.5+0xac>
		mark = ull_disable_mark(adv);
   115f4:	4620      	mov	r0, r4
   115f6:	f7fe ff41 	bl	1047c <ull_disable_mark>
		LL_ASSERT(mark == adv);
   115fa:	4284      	cmp	r4, r0
   115fc:	d0b5      	beq.n	1156a <disable.constprop.5+0x12>
   115fe:	f240 43e6 	movw	r3, #1254	; 0x4e6
   11602:	e7de      	b.n	115c2 <disable.constprop.5+0x6a>
	ret = ull_disable(&adv->lll);
   11604:	f104 001c 	add.w	r0, r4, #28
   11608:	f7fe ff70 	bl	104ec <ull_disable>
	LL_ASSERT(!ret);
   1160c:	b160      	cbz	r0, 11628 <disable.constprop.5+0xd0>
   1160e:	f240 43ec 	movw	r3, #1260	; 0x4ec
   11612:	4a15      	ldr	r2, [pc, #84]	; (11668 <disable.constprop.5+0x110>)
   11614:	4918      	ldr	r1, [pc, #96]	; (11678 <disable.constprop.5+0x120>)
   11616:	4816      	ldr	r0, [pc, #88]	; (11670 <disable.constprop.5+0x118>)
   11618:	f007 feac 	bl	19374 <printk>
   1161c:	4040      	eors	r0, r0
   1161e:	f380 8811 	msr	BASEPRI, r0
   11622:	f04f 0003 	mov.w	r0, #3
   11626:	df02      	svc	2
	mark = ull_disable_unmark(adv);
   11628:	4620      	mov	r0, r4
   1162a:	f7fe ff2f 	bl	1048c <ull_disable_unmark>
	LL_ASSERT(mark == adv);
   1162e:	4284      	cmp	r4, r0
   11630:	d00c      	beq.n	1164c <disable.constprop.5+0xf4>
   11632:	f240 43ef 	movw	r3, #1263	; 0x4ef
   11636:	4a0c      	ldr	r2, [pc, #48]	; (11668 <disable.constprop.5+0x110>)
   11638:	490c      	ldr	r1, [pc, #48]	; (1166c <disable.constprop.5+0x114>)
   1163a:	480d      	ldr	r0, [pc, #52]	; (11670 <disable.constprop.5+0x118>)
   1163c:	f007 fe9a 	bl	19374 <printk>
   11640:	4040      	eors	r0, r0
   11642:	f380 8811 	msr	BASEPRI, r0
   11646:	f04f 0003 	mov.w	r0, #3
   1164a:	df02      	svc	2
	if (adv->lll.conn) {
   1164c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1164e:	b113      	cbz	r3, 11656 <disable.constprop.5+0xfe>
		conn_release(adv);
   11650:	4620      	mov	r0, r4
   11652:	f7ff fd4d 	bl	110f0 <conn_release>
	adv->is_enabled = 0U;
   11656:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
   1165a:	f36f 0300 	bfc	r3, #0, #1
   1165e:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
	return 0;
   11662:	2000      	movs	r0, #0
   11664:	e782      	b.n	1156c <disable.constprop.5+0x14>
   11666:	bf00      	nop
   11668:	00021d06 	.word	0x00021d06
   1166c:	00021cfa 	.word	0x00021cfa
   11670:	00020aa4 	.word	0x00020aa4
   11674:	00010459 	.word	0x00010459
   11678:	00021ae5 	.word	0x00021ae5

0001167c <isr_cleanup>:

	isr_cleanup(param);
}

static void isr_cleanup(void *param)
{
   1167c:	b508      	push	{r3, lr}
	int err;

	radio_isr_set(isr_race, param);
   1167e:	4601      	mov	r1, r0
   11680:	480d      	ldr	r0, [pc, #52]	; (116b8 <isr_cleanup+0x3c>)
   11682:	f004 fa67 	bl	15b54 <radio_isr_set>
	radio_tmr_stop();
   11686:	f004 fc8f 	bl	15fa8 <radio_tmr_stop>

	err = lll_clk_off();
   1168a:	f7ff fc29 	bl	10ee0 <lll_clk_off>
	LL_ASSERT(!err || err == -EBUSY);
   1168e:	b170      	cbz	r0, 116ae <isr_cleanup+0x32>
   11690:	3010      	adds	r0, #16
   11692:	d00c      	beq.n	116ae <isr_cleanup+0x32>
   11694:	f44f 7311 	mov.w	r3, #580	; 0x244
   11698:	4a08      	ldr	r2, [pc, #32]	; (116bc <isr_cleanup+0x40>)
   1169a:	4909      	ldr	r1, [pc, #36]	; (116c0 <isr_cleanup+0x44>)
   1169c:	4809      	ldr	r0, [pc, #36]	; (116c4 <isr_cleanup+0x48>)
   1169e:	f007 fe69 	bl	19374 <printk>
   116a2:	4040      	eors	r0, r0
   116a4:	f380 8811 	msr	BASEPRI, r0
   116a8:	f04f 0003 	mov.w	r0, #3
   116ac:	df02      	svc	2

	lll_done(NULL);
   116ae:	2000      	movs	r0, #0
}
   116b0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
   116b4:	f7ff bbc2 	b.w	10e3c <lll_done>
   116b8:	0001d42f 	.word	0x0001d42f
   116bc:	00021ded 	.word	0x00021ded
   116c0:	00021e30 	.word	0x00021e30
   116c4:	00020aa4 	.word	0x00020aa4

000116c8 <isr_tx>:
{
   116c8:	b537      	push	{r0, r1, r2, r4, r5, lr}
   116ca:	4604      	mov	r4, r0
	radio_status_reset();
   116cc:	f004 fb1c 	bl	15d08 <radio_status_reset>
	radio_tmr_status_reset();
   116d0:	f004 fbd8 	bl	15e84 <radio_tmr_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
   116d4:	2096      	movs	r0, #150	; 0x96
   116d6:	f004 fbe5 	bl	15ea4 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
   116da:	2300      	movs	r3, #0
   116dc:	461a      	mov	r2, r3
   116de:	4619      	mov	r1, r3
   116e0:	4618      	mov	r0, r3
   116e2:	f004 fb5b 	bl	15d9c <radio_switch_complete_and_tx>
	radio_pkt_rx_set(radio_pkt_scratch_get());
   116e6:	f004 fb49 	bl	15d7c <radio_pkt_scratch_get>
   116ea:	f004 fae9 	bl	15cc0 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
   116ee:	f004 fb17 	bl	15d20 <radio_is_ready>
   116f2:	b160      	cbz	r0, 1170e <isr_tx+0x46>
   116f4:	f44f 73ab 	mov.w	r3, #342	; 0x156
   116f8:	4a17      	ldr	r2, [pc, #92]	; (11758 <isr_tx+0x90>)
   116fa:	4918      	ldr	r1, [pc, #96]	; (1175c <isr_tx+0x94>)
   116fc:	4818      	ldr	r0, [pc, #96]	; (11760 <isr_tx+0x98>)
   116fe:	f007 fe39 	bl	19374 <printk>
   11702:	4040      	eors	r0, r0
   11704:	f380 8811 	msr	BASEPRI, r0
   11708:	f04f 0003 	mov.w	r0, #3
   1170c:	df02      	svc	2
	radio_isr_set(isr_rx, param);
   1170e:	4621      	mov	r1, r4
   11710:	4814      	ldr	r0, [pc, #80]	; (11764 <isr_tx+0x9c>)
   11712:	f004 fa1f 	bl	15b54 <radio_isr_set>
	if (ull_filter_lll_rl_enabled()) {
   11716:	f004 f90f 	bl	15938 <ull_filter_lll_rl_enabled>
   1171a:	b140      	cbz	r0, 1172e <isr_tx+0x66>
		u8_t count, *irks = ull_filter_lll_irks_get(&count);
   1171c:	f10d 0007 	add.w	r0, sp, #7
   11720:	f004 f846 	bl	157b0 <ull_filter_lll_irks_get>
		radio_ar_configure(count, irks);
   11724:	4601      	mov	r1, r0
   11726:	f89d 0007 	ldrb.w	r0, [sp, #7]
   1172a:	f004 fd17 	bl	1615c <radio_ar_configure>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   1172e:	f004 fc8d 	bl	1604c <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
   11732:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   11734:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
   11736:	4608      	mov	r0, r1
   11738:	f00c fa2d 	bl	1db96 <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
   1173c:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
   1173e:	4605      	mov	r5, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
   11740:	4608      	mov	r0, r1
   11742:	f00c fa24 	bl	1db8e <radio_tx_chain_delay_get>
   11746:	442c      	add	r4, r5
   11748:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
   1174a:	1a20      	subs	r0, r4, r0
   1174c:	f004 fc38 	bl	15fc0 <radio_tmr_hcto_configure>
	radio_tmr_end_capture();
   11750:	f004 fc6e 	bl	16030 <radio_tmr_end_capture>
}
   11754:	b003      	add	sp, #12
   11756:	bd30      	pop	{r4, r5, pc}
   11758:	00021ded 	.word	0x00021ded
   1175c:	00021e43 	.word	0x00021e43
   11760:	00020aa4 	.word	0x00020aa4
   11764:	0001182d 	.word	0x0001182d

00011768 <is_abort_cb>:
	if (next != curr) {
   11768:	4282      	cmp	r2, r0
{
   1176a:	b508      	push	{r3, lr}
	if (next != curr) {
   1176c:	d01c      	beq.n	117a8 <is_abort_cb+0x40>
		} else if (lll->is_hdcd) {
   1176e:	7b12      	ldrb	r2, [r2, #12]
   11770:	07d2      	lsls	r2, r2, #31
   11772:	d526      	bpl.n	117c2 <is_abort_cb+0x5a>
			*resume_cb = resume_prepare_cb;
   11774:	4a14      	ldr	r2, [pc, #80]	; (117c8 <is_abort_cb+0x60>)
   11776:	601a      	str	r2, [r3, #0]
			*resume_prio = 0; /* TODO: */
   11778:	9b02      	ldr	r3, [sp, #8]
   1177a:	2200      	movs	r2, #0
   1177c:	601a      	str	r2, [r3, #0]
			err = lll_clk_on();
   1177e:	f7ff fba7 	bl	10ed0 <lll_clk_on>
			LL_ASSERT(!err || err == -EINPROGRESS);
   11782:	b170      	cbz	r0, 117a2 <is_abort_cb+0x3a>
   11784:	3044      	adds	r0, #68	; 0x44
   11786:	d00c      	beq.n	117a2 <is_abort_cb+0x3a>
   11788:	f44f 7389 	mov.w	r3, #274	; 0x112
   1178c:	4a0f      	ldr	r2, [pc, #60]	; (117cc <is_abort_cb+0x64>)
   1178e:	4910      	ldr	r1, [pc, #64]	; (117d0 <is_abort_cb+0x68>)
   11790:	4810      	ldr	r0, [pc, #64]	; (117d4 <is_abort_cb+0x6c>)
   11792:	f007 fdef 	bl	19374 <printk>
   11796:	4040      	eors	r0, r0
   11798:	f380 8811 	msr	BASEPRI, r0
   1179c:	f04f 0003 	mov.w	r0, #3
   117a0:	df02      	svc	2
   117a2:	f06f 000a 	mvn.w	r0, #10
   117a6:	e00b      	b.n	117c0 <is_abort_cb+0x58>
	return lll_adv_pdu_latest_get(&lll->scan_rsp, is_modified);
}

static inline struct pdu_adv *lll_adv_data_curr_get(struct lll_adv *lll)
{
	return (void *)lll->adv_data.pdu[lll->adv_data.first];
   117a8:	7bd3      	ldrb	r3, [r2, #15]
   117aa:	2127      	movs	r1, #39	; 0x27
   117ac:	fb01 2203 	mla	r2, r1, r3, r2
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   117b0:	7c53      	ldrb	r3, [r2, #17]
   117b2:	f003 030f 	and.w	r3, r3, #15
   117b6:	2b01      	cmp	r3, #1
		return 0;
   117b8:	bf14      	ite	ne
   117ba:	f06f 0047 	mvnne.w	r0, #71	; 0x47
   117be:	2000      	moveq	r0, #0
}
   117c0:	bd08      	pop	{r3, pc}
			return -ECANCELED;
   117c2:	f06f 0047 	mvn.w	r0, #71	; 0x47
   117c6:	e7fb      	b.n	117c0 <is_abort_cb+0x58>
   117c8:	0001d4a1 	.word	0x0001d4a1
   117cc:	00021ded 	.word	0x00021ded
   117d0:	00021dda 	.word	0x00021dda
   117d4:	00020aa4 	.word	0x00020aa4

000117d8 <abort_cb>:
{
   117d8:	b510      	push	{r4, lr}
   117da:	460c      	mov	r4, r1
	if (!prepare_param) {
   117dc:	b930      	cbnz	r0, 117ec <abort_cb+0x14>
		radio_isr_set(isr_abort, param);
   117de:	480f      	ldr	r0, [pc, #60]	; (1181c <abort_cb+0x44>)
   117e0:	f004 f9b8 	bl	15b54 <radio_isr_set>
}
   117e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
   117e8:	f004 ba7c 	b.w	15ce4 <radio_disable>
	err = lll_clk_off();
   117ec:	f7ff fb78 	bl	10ee0 <lll_clk_off>
	LL_ASSERT(!err || err == -EBUSY);
   117f0:	b170      	cbz	r0, 11810 <abort_cb+0x38>
   117f2:	3010      	adds	r0, #16
   117f4:	d00c      	beq.n	11810 <abort_cb+0x38>
   117f6:	f44f 739c 	mov.w	r3, #312	; 0x138
   117fa:	4a09      	ldr	r2, [pc, #36]	; (11820 <abort_cb+0x48>)
   117fc:	4909      	ldr	r1, [pc, #36]	; (11824 <abort_cb+0x4c>)
   117fe:	480a      	ldr	r0, [pc, #40]	; (11828 <abort_cb+0x50>)
   11800:	f007 fdb8 	bl	19374 <printk>
   11804:	4040      	eors	r0, r0
   11806:	f380 8811 	msr	BASEPRI, r0
   1180a:	f04f 0003 	mov.w	r0, #3
   1180e:	df02      	svc	2
	lll_done(param);
   11810:	4620      	mov	r0, r4
}
   11812:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
   11816:	f7ff bb11 	b.w	10e3c <lll_done>
   1181a:	bf00      	nop
   1181c:	0001d433 	.word	0x0001d433
   11820:	00021ded 	.word	0x00021ded
   11824:	00021e30 	.word	0x00021e30
   11828:	00020aa4 	.word	0x00020aa4

0001182c <isr_rx>:
{
   1182c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   11830:	4604      	mov	r4, r0
	trx_done = radio_is_done();
   11832:	f004 fa7f 	bl	15d34 <radio_is_done>
   11836:	b2c5      	uxtb	r5, r0
	if (trx_done) {
   11838:	2d00      	cmp	r5, #0
   1183a:	d04d      	beq.n	118d8 <isr_rx+0xac>
		crc_ok = radio_crc_is_valid();
   1183c:	f004 fa90 	bl	15d60 <radio_crc_is_valid>
   11840:	fa5f f880 	uxtb.w	r8, r0
		devmatch_ok = radio_filter_has_match();
   11844:	f004 fb02 	bl	15e4c <radio_filter_has_match>
   11848:	fa5f f980 	uxtb.w	r9, r0
		devmatch_id = radio_filter_match_get();
   1184c:	f004 fb08 	bl	15e60 <radio_filter_match_get>
		irkmatch_ok = radio_ar_has_match();
   11850:	f004 fcc2 	bl	161d8 <radio_ar_has_match>
   11854:	b2c6      	uxtb	r6, r0
		irkmatch_id = radio_ar_match_get();
   11856:	f004 fcad 	bl	161b4 <radio_ar_match_get>
   1185a:	b2c7      	uxtb	r7, r0
		rssi_ready = radio_rssi_is_ready();
   1185c:	f004 fabe 	bl	15ddc <radio_rssi_is_ready>
	radio_status_reset();
   11860:	f004 fa52 	bl	15d08 <radio_status_reset>
	radio_tmr_status_reset();
   11864:	f004 fb0e 	bl	15e84 <radio_tmr_status_reset>
	radio_filter_status_reset();
   11868:	f004 fae8 	bl	15e3c <radio_filter_status_reset>
	radio_ar_status_reset();
   1186c:	f004 fca8 	bl	161c0 <radio_ar_status_reset>
	radio_rssi_status_reset();
   11870:	f004 faac 	bl	15dcc <radio_rssi_status_reset>
	if (!trx_done) {
   11874:	2d00      	cmp	r5, #0
   11876:	f000 8131 	beq.w	11adc <isr_rx+0x2b0>
	if (crc_ok) {
   1187a:	f1b8 0f00 	cmp.w	r8, #0
   1187e:	f000 812d 	beq.w	11adc <isr_rx+0x2b0>
{
	struct pdu_adv *pdu_rx, *pdu_adv;

#if defined(CONFIG_BT_CTLR_PRIVACY)
	/* An IRK match implies address resolution enabled */
	u8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
   11882:	b376      	cbz	r6, 118e2 <isr_rx+0xb6>
   11884:	4638      	mov	r0, r7
   11886:	f003 ff9d 	bl	157c4 <ull_filter_lll_rl_irk_idx>
   1188a:	f88d 0007 	strb.w	r0, [sp, #7]
				    FILTER_IDX_NONE;
#else
	u8_t rl_idx = FILTER_IDX_NONE;
#endif /* CONFIG_BT_CTLR_PRIVACY */

	pdu_rx = (void *)radio_pkt_scratch_get();
   1188e:	f004 fa75 	bl	15d7c <radio_pkt_scratch_get>
   11892:	7be2      	ldrb	r2, [r4, #15]
   11894:	4605      	mov	r5, r0
	pdu_adv = lll_adv_data_curr_get(lll);

	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
   11896:	7800      	ldrb	r0, [r0, #0]
   11898:	2311      	movs	r3, #17
   1189a:	2727      	movs	r7, #39	; 0x27
   1189c:	fb17 3702 	smlabb	r7, r7, r2, r3
   118a0:	f000 030f 	and.w	r3, r0, #15
   118a4:	2b03      	cmp	r3, #3
   118a6:	eb04 0807 	add.w	r8, r4, r7
   118aa:	d157      	bne.n	1195c <isr_rx+0x130>
   118ac:	786b      	ldrb	r3, [r5, #1]
   118ae:	2b0c      	cmp	r3, #12
   118b0:	f040 8114 	bne.w	11adc <isr_rx+0x2b0>
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
	    (pdu_adv->type != PDU_ADV_TYPE_DIRECT_IND) &&
   118b4:	5de3      	ldrb	r3, [r4, r7]
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
   118b6:	f003 030f 	and.w	r3, r3, #15
   118ba:	2b01      	cmp	r3, #1
   118bc:	f000 810e 	beq.w	11adc <isr_rx+0x2b0>
static inline bool isr_rx_sr_check(struct lll_adv *lll, struct pdu_adv *adv,
				   struct pdu_adv *sr, u8_t devmatch_ok,
				   u8_t *rl_idx)
{
#if defined(CONFIG_BT_CTLR_PRIVACY)
	return ((((lll->filter_policy & 0x01) == 0) &&
   118c0:	7b63      	ldrb	r3, [r4, #13]
		 ull_filter_lll_rl_addr_allowed(sr->tx_addr,
						sr->scan_req.scan_addr,
						rl_idx)) ||
		(((lll->filter_policy & 0x01) != 0) &&
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   118c2:	07da      	lsls	r2, r3, #31
   118c4:	d50f      	bpl.n	118e6 <isr_rx+0xba>
		(((lll->filter_policy & 0x01) != 0) &&
   118c6:	f1b9 0f00 	cmp.w	r9, #0
   118ca:	d114      	bne.n	118f6 <isr_rx+0xca>
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   118cc:	f89d 0007 	ldrb.w	r0, [sp, #7]
   118d0:	f003 ffc2 	bl	15858 <ull_filter_lll_irk_whitelisted>
   118d4:	b978      	cbnz	r0, 118f6 <isr_rx+0xca>
   118d6:	e041      	b.n	1195c <isr_rx+0x130>
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
   118d8:	462e      	mov	r6, r5
   118da:	46a9      	mov	r9, r5
   118dc:	46a8      	mov	r8, r5
		devmatch_id = irkmatch_id = 0xFF;
   118de:	27ff      	movs	r7, #255	; 0xff
   118e0:	e7be      	b.n	11860 <isr_rx+0x34>
	u8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
   118e2:	20ff      	movs	r0, #255	; 0xff
   118e4:	e7d1      	b.n	1188a <isr_rx+0x5e>
		 ull_filter_lll_rl_addr_allowed(sr->tx_addr,
   118e6:	f10d 0207 	add.w	r2, sp, #7
   118ea:	1ca9      	adds	r1, r5, #2
   118ec:	f3c0 1080 	ubfx	r0, r0, #6, #1
   118f0:	f003 ffe6 	bl	158c0 <ull_filter_lll_rl_addr_allowed>
	return ((((lll->filter_policy & 0x01) == 0) &&
   118f4:	b378      	cbz	r0, 11956 <isr_rx+0x12a>
}

static inline bool isr_rx_sr_adva_check(struct pdu_adv *adv,
					struct pdu_adv *sr)
{
	return (adv->tx_addr == sr->rx_addr) &&
   118f6:	5de3      	ldrb	r3, [r4, r7]
   118f8:	782a      	ldrb	r2, [r5, #0]
   118fa:	f3c3 1380 	ubfx	r3, r3, #6, #1
   118fe:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
   11902:	d12b      	bne.n	1195c <isr_rx+0x130>
		!memcmp(adv->adv_ind.addr, sr->scan_req.adv_addr, BDADDR_SIZE);
   11904:	2206      	movs	r2, #6
   11906:	f105 0108 	add.w	r1, r5, #8
   1190a:	f108 0002 	add.w	r0, r8, #2
   1190e:	f009 fb64 	bl	1afda <memcmp>
	    (pdu_adv->type != PDU_ADV_TYPE_DIRECT_IND) &&
   11912:	bb18      	cbnz	r0, 1195c <isr_rx+0x130>
		radio_isr_set(isr_done, lll);
   11914:	4621      	mov	r1, r4
   11916:	4875      	ldr	r0, [pc, #468]	; (11aec <isr_rx+0x2c0>)
   11918:	f004 f91c 	bl	15b54 <radio_isr_set>
		radio_switch_complete_and_disable();
   1191c:	f004 fa48 	bl	15db0 <radio_switch_complete_and_disable>
}

static inline struct pdu_adv *lll_adv_scan_rsp_curr_get(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.first];
   11920:	f894 005f 	ldrb.w	r0, [r4, #95]	; 0x5f
   11924:	2327      	movs	r3, #39	; 0x27
   11926:	fb03 4000 	mla	r0, r3, r0, r4
		radio_pkt_tx_set(lll_adv_scan_rsp_curr_get(lll));
   1192a:	3061      	adds	r0, #97	; 0x61
   1192c:	f004 f9ce 	bl	15ccc <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
   11930:	f004 f9f6 	bl	15d20 <radio_is_ready>
   11934:	b160      	cbz	r0, 11950 <isr_rx+0x124>
   11936:	f240 2396 	movw	r3, #662	; 0x296
   1193a:	4a6d      	ldr	r2, [pc, #436]	; (11af0 <isr_rx+0x2c4>)
   1193c:	496d      	ldr	r1, [pc, #436]	; (11af4 <isr_rx+0x2c8>)
   1193e:	486e      	ldr	r0, [pc, #440]	; (11af8 <isr_rx+0x2cc>)
   11940:	f007 fd18 	bl	19374 <printk>
   11944:	4040      	eors	r0, r0
   11946:	f380 8811 	msr	BASEPRI, r0
   1194a:	f04f 0003 	mov.w	r0, #3
   1194e:	df02      	svc	2
}
   11950:	b003      	add	sp, #12
   11952:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		(((lll->filter_policy & 0x01) != 0) &&
   11956:	7b63      	ldrb	r3, [r4, #13]
						rl_idx)) ||
   11958:	07db      	lsls	r3, r3, #31
   1195a:	d4b4      	bmi.n	118c6 <isr_rx+0x9a>
	} else if ((pdu_rx->type == PDU_ADV_TYPE_CONNECT_IND) &&
   1195c:	7828      	ldrb	r0, [r5, #0]
   1195e:	f000 030f 	and.w	r3, r0, #15
   11962:	2b05      	cmp	r3, #5
   11964:	f040 80ba 	bne.w	11adc <isr_rx+0x2b0>
   11968:	786b      	ldrb	r3, [r5, #1]
   1196a:	2b22      	cmp	r3, #34	; 0x22
   1196c:	f040 80b6 	bne.w	11adc <isr_rx+0x2b0>
static inline bool isr_rx_ci_check(struct lll_adv *lll, struct pdu_adv *adv,
				   struct pdu_adv *ci, u8_t devmatch_ok,
				   u8_t *rl_idx)
{
	/* LL 4.3.2: filter policy shall be ignored for directed adv */
	if (adv->type == PDU_ADV_TYPE_DIRECT_IND) {
   11970:	5de3      	ldrb	r3, [r4, r7]
   11972:	f003 030f 	and.w	r3, r3, #15
   11976:	2b01      	cmp	r3, #1
   11978:	f040 8091 	bne.w	11a9e <isr_rx+0x272>
#if defined(CONFIG_BT_CTLR_PRIVACY)
		return ull_filter_lll_rl_addr_allowed(ci->tx_addr,
						      ci->connect_ind.init_addr,
   1197c:	f105 0902 	add.w	r9, r5, #2
		return ull_filter_lll_rl_addr_allowed(ci->tx_addr,
   11980:	f10d 0207 	add.w	r2, sp, #7
   11984:	4649      	mov	r1, r9
   11986:	f3c0 1080 	ubfx	r0, r0, #6, #1
   1198a:	f003 ff99 	bl	158c0 <ull_filter_lll_rl_addr_allowed>
						      rl_idx) &&
#else
		return (1) &&
#endif
		       isr_rx_ci_adva_check(adv, ci) &&
   1198e:	b908      	cbnz	r0, 11994 <isr_rx+0x168>
	return ((((lll->filter_policy & 0x02) == 0) &&
		 ull_filter_lll_rl_addr_allowed(ci->tx_addr,
						ci->connect_ind.init_addr,
						rl_idx)) ||
		(((lll->filter_policy & 0x02) != 0) &&
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   11990:	2000      	movs	r0, #0
   11992:	e00d      	b.n	119b0 <isr_rx+0x184>
		       isr_rx_ci_adva_check(adv, ci) &&
   11994:	4629      	mov	r1, r5
   11996:	4640      	mov	r0, r8
   11998:	f00b fd5e 	bl	1d458 <isr_rx_ci_adva_check>
						      rl_idx) &&
   1199c:	2800      	cmp	r0, #0
   1199e:	d0f7      	beq.n	11990 <isr_rx+0x164>
		       isr_rx_ci_tgta_check(lll, adv, ci, *rl_idx);
   119a0:	f89d 3007 	ldrb.w	r3, [sp, #7]
static inline bool isr_rx_ci_tgta_check(struct lll_adv *lll,
					struct pdu_adv *adv, struct pdu_adv *ci,
					u8_t rl_idx)
{
#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (rl_idx != FILTER_IDX_NONE) {
   119a4:	2bff      	cmp	r3, #255	; 0xff
   119a6:	d069      	beq.n	11a7c <isr_rx+0x250>
		return rl_idx == lll->rl_idx;
   119a8:	7ba0      	ldrb	r0, [r4, #14]
   119aa:	1ac7      	subs	r7, r0, r3
   119ac:	4278      	negs	r0, r7
   119ae:	4178      	adcs	r0, r7
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   119b0:	f000 0001 	and.w	r0, r0, #1
		   (pdu_rx->len == sizeof(struct pdu_adv_connect_ind)) &&
   119b4:	2800      	cmp	r0, #0
   119b6:	f000 8091 	beq.w	11adc <isr_rx+0x2b0>
				   &rl_idx) &&
   119ba:	68a3      	ldr	r3, [r4, #8]
   119bc:	2b00      	cmp	r3, #0
   119be:	f000 808d 	beq.w	11adc <isr_rx+0x2b0>
			rx = ull_pdu_rx_alloc_peek(4);
   119c2:	2004      	movs	r0, #4
   119c4:	f7fe fdce 	bl	10564 <ull_pdu_rx_alloc_peek>
		if (!rx) {
   119c8:	2800      	cmp	r0, #0
   119ca:	f000 8087 	beq.w	11adc <isr_rx+0x2b0>
		radio_isr_set(isr_abort, lll);
   119ce:	4621      	mov	r1, r4
   119d0:	484a      	ldr	r0, [pc, #296]	; (11afc <isr_rx+0x2d0>)
   119d2:	f004 f8bf 	bl	15b54 <radio_isr_set>
		radio_disable();
   119d6:	f004 f985 	bl	15ce4 <radio_disable>
		LL_ASSERT(!radio_is_ready());
   119da:	f004 f9a1 	bl	15d20 <radio_is_ready>
   119de:	b160      	cbz	r0, 119fa <isr_rx+0x1ce>
   119e0:	f240 23d2 	movw	r3, #722	; 0x2d2
   119e4:	4a42      	ldr	r2, [pc, #264]	; (11af0 <isr_rx+0x2c4>)
   119e6:	4943      	ldr	r1, [pc, #268]	; (11af4 <isr_rx+0x2c8>)
   119e8:	4843      	ldr	r0, [pc, #268]	; (11af8 <isr_rx+0x2cc>)
   119ea:	f007 fcc3 	bl	19374 <printk>
   119ee:	4040      	eors	r0, r0
   119f0:	f380 8811 	msr	BASEPRI, r0
   119f4:	f04f 0003 	mov.w	r0, #3
   119f8:	df02      	svc	2
}

static inline int lll_stop(void *lll)
{
	struct lll_hdr *hdr = lll;
	int ret = !!hdr->is_stop;
   119fa:	7923      	ldrb	r3, [r4, #4]

	hdr->is_stop = 1U;
   119fc:	f043 0201 	orr.w	r2, r3, #1
		LL_ASSERT(!ret);
   11a00:	07db      	lsls	r3, r3, #31
   11a02:	7122      	strb	r2, [r4, #4]
   11a04:	d50c      	bpl.n	11a20 <isr_rx+0x1f4>
   11a06:	f44f 7338 	mov.w	r3, #736	; 0x2e0
   11a0a:	4a39      	ldr	r2, [pc, #228]	; (11af0 <isr_rx+0x2c4>)
   11a0c:	493c      	ldr	r1, [pc, #240]	; (11b00 <isr_rx+0x2d4>)
   11a0e:	483a      	ldr	r0, [pc, #232]	; (11af8 <isr_rx+0x2cc>)
   11a10:	f007 fcb0 	bl	19374 <printk>
   11a14:	4040      	eors	r0, r0
   11a16:	f380 8811 	msr	BASEPRI, r0
   11a1a:	f04f 0003 	mov.w	r0, #3
   11a1e:	df02      	svc	2
		rx = ull_pdu_rx_alloc();
   11a20:	f7fe fdb8 	bl	10594 <ull_pdu_rx_alloc>
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   11a24:	2308      	movs	r3, #8
		rx = ull_pdu_rx_alloc();
   11a26:	4607      	mov	r7, r0
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   11a28:	7103      	strb	r3, [r0, #4]
		rx->hdr.handle = 0xffff;
   11a2a:	f64f 73ff 	movw	r3, #65535	; 0xffff
   11a2e:	80c3      	strh	r3, [r0, #6]
		memcpy(rx->pdu, pdu_rx, (offsetof(struct pdu_adv, connect_ind) +
   11a30:	2224      	movs	r2, #36	; 0x24
   11a32:	4629      	mov	r1, r5
   11a34:	3020      	adds	r0, #32
   11a36:	f009 fae0 	bl	1affa <memcpy>
		ftr->param = lll;
   11a3a:	60bc      	str	r4, [r7, #8]
		ftr->ticks_anchor = radio_tmr_start_get();
   11a3c:	f004 faae 	bl	15f9c <radio_tmr_start_get>
   11a40:	6138      	str	r0, [r7, #16]
		ftr->us_radio_end = radio_tmr_end_get() -
   11a42:	f004 fafd 	bl	16040 <radio_tmr_end_get>
				    radio_tx_chain_delay_get(0, 0);
   11a46:	2100      	movs	r1, #0
		ftr->us_radio_end = radio_tmr_end_get() -
   11a48:	4604      	mov	r4, r0
				    radio_tx_chain_delay_get(0, 0);
   11a4a:	4608      	mov	r0, r1
   11a4c:	f00c f89f 	bl	1db8e <radio_tx_chain_delay_get>
		ftr->us_radio_rdy = radio_rx_ready_delay_get(0, 0);
   11a50:	2100      	movs	r1, #0
		ftr->us_radio_end = radio_tmr_end_get() -
   11a52:	1a20      	subs	r0, r4, r0
   11a54:	6178      	str	r0, [r7, #20]
		ftr->us_radio_rdy = radio_rx_ready_delay_get(0, 0);
   11a56:	4608      	mov	r0, r1
   11a58:	f00c f89b 	bl	1db92 <radio_rx_ready_delay_get>
   11a5c:	61b8      	str	r0, [r7, #24]
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
   11a5e:	2e00      	cmp	r6, #0
   11a60:	d03a      	beq.n	11ad8 <isr_rx+0x2ac>
   11a62:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11a66:	777b      	strb	r3, [r7, #29]
			ftr->extra = ull_pdu_rx_alloc();
   11a68:	f7fe fd94 	bl	10594 <ull_pdu_rx_alloc>
		ull_rx_put(rx->hdr.link, rx);
   11a6c:	4639      	mov	r1, r7
			ftr->extra = ull_pdu_rx_alloc();
   11a6e:	60f8      	str	r0, [r7, #12]
		ull_rx_put(rx->hdr.link, rx);
   11a70:	6838      	ldr	r0, [r7, #0]
   11a72:	f7fe fda5 	bl	105c0 <ull_rx_put>
		ull_rx_sched();
   11a76:	f7fe fdb3 	bl	105e0 <ull_rx_sched>
		if (!err) {
   11a7a:	e769      	b.n	11950 <isr_rx+0x124>
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */
	return (adv->rx_addr == ci->tx_addr) &&
   11a7c:	782b      	ldrb	r3, [r5, #0]
   11a7e:	5de2      	ldrb	r2, [r4, r7]
   11a80:	f3c3 1380 	ubfx	r3, r3, #6, #1
   11a84:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
   11a88:	d182      	bne.n	11990 <isr_rx+0x164>
	       !memcmp(adv->direct_ind.tgt_addr, ci->connect_ind.init_addr,
   11a8a:	2206      	movs	r2, #6
   11a8c:	4649      	mov	r1, r9
   11a8e:	f108 0008 	add.w	r0, r8, #8
   11a92:	f009 faa2 	bl	1afda <memcmp>
	return (adv->rx_addr == ci->tx_addr) &&
   11a96:	fab0 f080 	clz	r0, r0
   11a9a:	0940      	lsrs	r0, r0, #5
   11a9c:	e788      	b.n	119b0 <isr_rx+0x184>
	return ((((lll->filter_policy & 0x02) == 0) &&
   11a9e:	7b63      	ldrb	r3, [r4, #13]
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   11aa0:	0799      	lsls	r1, r3, #30
   11aa2:	d508      	bpl.n	11ab6 <isr_rx+0x28a>
		(((lll->filter_policy & 0x02) != 0) &&
   11aa4:	f1b9 0f00 	cmp.w	r9, #0
   11aa8:	d10d      	bne.n	11ac6 <isr_rx+0x29a>
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   11aaa:	f89d 0007 	ldrb.w	r0, [sp, #7]
   11aae:	f003 fed3 	bl	15858 <ull_filter_lll_irk_whitelisted>
   11ab2:	b940      	cbnz	r0, 11ac6 <isr_rx+0x29a>
   11ab4:	e76c      	b.n	11990 <isr_rx+0x164>
		 ull_filter_lll_rl_addr_allowed(ci->tx_addr,
   11ab6:	f10d 0207 	add.w	r2, sp, #7
   11aba:	1ca9      	adds	r1, r5, #2
   11abc:	f3c0 1080 	ubfx	r0, r0, #6, #1
   11ac0:	f003 fefe 	bl	158c0 <ull_filter_lll_rl_addr_allowed>
	return ((((lll->filter_policy & 0x02) == 0) &&
   11ac4:	b120      	cbz	r0, 11ad0 <isr_rx+0x2a4>
	       isr_rx_ci_adva_check(adv, ci);
   11ac6:	4629      	mov	r1, r5
   11ac8:	4640      	mov	r0, r8
   11aca:	f00b fcc5 	bl	1d458 <isr_rx_ci_adva_check>
   11ace:	e76f      	b.n	119b0 <isr_rx+0x184>
		(((lll->filter_policy & 0x02) != 0) &&
   11ad0:	7b63      	ldrb	r3, [r4, #13]
						rl_idx)) ||
   11ad2:	079a      	lsls	r2, r3, #30
   11ad4:	d4e6      	bmi.n	11aa4 <isr_rx+0x278>
   11ad6:	e75b      	b.n	11990 <isr_rx+0x164>
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
   11ad8:	23ff      	movs	r3, #255	; 0xff
   11ada:	e7c4      	b.n	11a66 <isr_rx+0x23a>
	radio_isr_set(isr_done, param);
   11adc:	4621      	mov	r1, r4
   11ade:	4803      	ldr	r0, [pc, #12]	; (11aec <isr_rx+0x2c0>)
   11ae0:	f004 f838 	bl	15b54 <radio_isr_set>
	radio_disable();
   11ae4:	f004 f8fe 	bl	15ce4 <radio_disable>
   11ae8:	e732      	b.n	11950 <isr_rx+0x124>
   11aea:	bf00      	nop
   11aec:	0001d4c9 	.word	0x0001d4c9
   11af0:	00021ded 	.word	0x00021ded
   11af4:	00021e43 	.word	0x00021e43
   11af8:	00020aa4 	.word	0x00020aa4
   11afc:	0001d433 	.word	0x0001d433
   11b00:	00021ae5 	.word	0x00021ae5

00011b04 <chan_prepare>:
{
   11b04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	first = pdu->first;
   11b06:	7bc3      	ldrb	r3, [r0, #15]
	if (first != pdu->last) {
   11b08:	7c05      	ldrb	r5, [r0, #16]
   11b0a:	42ab      	cmp	r3, r5
   11b0c:	4604      	mov	r4, r0
   11b0e:	d060      	beq.n	11bd2 <chan_prepare+0xce>
		first += 1U;
   11b10:	1c5d      	adds	r5, r3, #1
   11b12:	b2ed      	uxtb	r5, r5
			first = 0U;
   11b14:	2d02      	cmp	r5, #2
   11b16:	bf08      	it	eq
   11b18:	2500      	moveq	r5, #0
		pdu->first = first;
   11b1a:	73c5      	strb	r5, [r0, #15]
		*is_modified = 1U;
   11b1c:	f04f 0e01 	mov.w	lr, #1
	first = pdu->first;
   11b20:	4620      	mov	r0, r4
	if (first != pdu->last) {
   11b22:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
	first = pdu->first;
   11b26:	f810 2f5f 	ldrb.w	r2, [r0, #95]!
	return (void *)pdu->pdu[first];
   11b2a:	2127      	movs	r1, #39	; 0x27
   11b2c:	f04f 0c02 	mov.w	ip, #2
   11b30:	f104 060f 	add.w	r6, r4, #15
   11b34:	fb11 c505 	smlabb	r5, r1, r5, ip
	if (first != pdu->last) {
   11b38:	4293      	cmp	r3, r2
	return (void *)pdu->pdu[first];
   11b3a:	eb06 0705 	add.w	r7, r6, r5
	if (first != pdu->last) {
   11b3e:	d04b      	beq.n	11bd8 <chan_prepare+0xd4>
		first += 1U;
   11b40:	3201      	adds	r2, #1
   11b42:	b2d3      	uxtb	r3, r2
			first = 0U;
   11b44:	4563      	cmp	r3, ip
   11b46:	bf08      	it	eq
   11b48:	2300      	moveq	r3, #0
		pdu->first = first;
   11b4a:	f884 305f 	strb.w	r3, [r4, #95]	; 0x5f
	return (void *)pdu->pdu[first];
   11b4e:	fb11 c303 	smlabb	r3, r1, r3, ip
   11b52:	4418      	add	r0, r3
		memcpy(&scan_pdu->scan_rsp.addr[0],
   11b54:	2206      	movs	r2, #6
   11b56:	1cb9      	adds	r1, r7, #2
   11b58:	3002      	adds	r0, #2
   11b5a:	f009 fa4e 	bl	1affa <memcpy>
	radio_pkt_tx_set(pdu);
   11b5e:	4638      	mov	r0, r7
   11b60:	f004 f8b4 	bl	15ccc <radio_pkt_tx_set>
	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
   11b64:	5d73      	ldrb	r3, [r6, r5]
   11b66:	f003 030f 	and.w	r3, r3, #15
   11b6a:	2b02      	cmp	r3, #2
		radio_isr_set(isr_tx, lll);
   11b6c:	4621      	mov	r1, r4
	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
   11b6e:	d03a      	beq.n	11be6 <chan_prepare+0xe2>
		radio_isr_set(isr_tx, lll);
   11b70:	4820      	ldr	r0, [pc, #128]	; (11bf4 <chan_prepare+0xf0>)
   11b72:	f003 ffef 	bl	15b54 <radio_isr_set>
		radio_tmr_tifs_set(EVENT_IFS_US);
   11b76:	2096      	movs	r0, #150	; 0x96
   11b78:	f004 f994 	bl	15ea4 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
   11b7c:	2000      	movs	r0, #0
   11b7e:	f004 f901 	bl	15d84 <radio_switch_complete_and_rx>
	chan = find_lsb_set(lll->chan_map_curr);
   11b82:	7b23      	ldrb	r3, [r4, #12]
   11b84:	f3c3 1302 	ubfx	r3, r3, #4, #3
   11b88:	2b00      	cmp	r3, #0
   11b8a:	fa93 f0a3 	rbit	r0, r3
   11b8e:	fab0 f080 	clz	r0, r0
   11b92:	bf08      	it	eq
   11b94:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
	LL_ASSERT(chan);
   11b98:	1c45      	adds	r5, r0, #1
   11b9a:	d10c      	bne.n	11bb6 <chan_prepare+0xb2>
   11b9c:	f44f 731d 	mov.w	r3, #628	; 0x274
   11ba0:	4a15      	ldr	r2, [pc, #84]	; (11bf8 <chan_prepare+0xf4>)
   11ba2:	4916      	ldr	r1, [pc, #88]	; (11bfc <chan_prepare+0xf8>)
   11ba4:	4816      	ldr	r0, [pc, #88]	; (11c00 <chan_prepare+0xfc>)
   11ba6:	f007 fbe5 	bl	19374 <printk>
   11baa:	4040      	eors	r0, r0
   11bac:	f380 8811 	msr	BASEPRI, r0
   11bb0:	f04f 0003 	mov.w	r0, #3
   11bb4:	df02      	svc	2
	lll->chan_map_curr &= (lll->chan_map_curr - 1);
   11bb6:	7b23      	ldrb	r3, [r4, #12]
   11bb8:	f3c3 1202 	ubfx	r2, r3, #4, #3
   11bbc:	1e51      	subs	r1, r2, #1
   11bbe:	400a      	ands	r2, r1
   11bc0:	f362 1306 	bfi	r3, r2, #4, #3
   11bc4:	7323      	strb	r3, [r4, #12]
	lll_chan_set(36 + chan);
   11bc6:	f105 0024 	add.w	r0, r5, #36	; 0x24
}
   11bca:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	lll_chan_set(36 + chan);
   11bce:	f7ff b98f 	b.w	10ef0 <lll_chan_set>
	u8_t upd = 0U;
   11bd2:	f04f 0e00 	mov.w	lr, #0
   11bd6:	e7a3      	b.n	11b20 <chan_prepare+0x1c>
	if (upd) {
   11bd8:	f1be 0f00 	cmp.w	lr, #0
   11bdc:	d0bf      	beq.n	11b5e <chan_prepare+0x5a>
   11bde:	fb11 c103 	smlabb	r1, r1, r3, ip
   11be2:	4408      	add	r0, r1
   11be4:	e7b6      	b.n	11b54 <chan_prepare+0x50>
		radio_isr_set(isr_done, lll);
   11be6:	4807      	ldr	r0, [pc, #28]	; (11c04 <chan_prepare+0x100>)
   11be8:	f003 ffb4 	bl	15b54 <radio_isr_set>
		radio_switch_complete_and_disable();
   11bec:	f004 f8e0 	bl	15db0 <radio_switch_complete_and_disable>
   11bf0:	e7c7      	b.n	11b82 <chan_prepare+0x7e>
   11bf2:	bf00      	nop
   11bf4:	000116c9 	.word	0x000116c9
   11bf8:	00021ded 	.word	0x00021ded
   11bfc:	00021c15 	.word	0x00021c15
   11c00:	00020aa4 	.word	0x00020aa4
   11c04:	0001d4c9 	.word	0x0001d4c9

00011c08 <prepare_cb>:
{
   11c08:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct lll_adv *lll = prepare_param->param;
   11c0a:	68c4      	ldr	r4, [r0, #12]
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
   11c0c:	4b40      	ldr	r3, [pc, #256]	; (11d10 <prepare_cb+0x108>)

static inline int lll_is_stop(void *lll)
{
	struct lll_hdr *hdr = lll;

	return !!hdr->is_stop;
   11c0e:	7925      	ldrb	r5, [r4, #4]
   11c10:	9301      	str	r3, [sp, #4]
	if (lll_is_stop(lll)) {
   11c12:	f015 0501 	ands.w	r5, r5, #1
{
   11c16:	4606      	mov	r6, r0
	if (lll_is_stop(lll)) {
   11c18:	d016      	beq.n	11c48 <prepare_cb+0x40>
		err = lll_clk_off();
   11c1a:	f7ff f961 	bl	10ee0 <lll_clk_off>
		LL_ASSERT(!err || err == -EBUSY);
   11c1e:	b168      	cbz	r0, 11c3c <prepare_cb+0x34>
   11c20:	3010      	adds	r0, #16
   11c22:	d00b      	beq.n	11c3c <prepare_cb+0x34>
   11c24:	238a      	movs	r3, #138	; 0x8a
   11c26:	4a3b      	ldr	r2, [pc, #236]	; (11d14 <prepare_cb+0x10c>)
   11c28:	493b      	ldr	r1, [pc, #236]	; (11d18 <prepare_cb+0x110>)
   11c2a:	483c      	ldr	r0, [pc, #240]	; (11d1c <prepare_cb+0x114>)
   11c2c:	f007 fba2 	bl	19374 <printk>
   11c30:	4040      	eors	r0, r0
   11c32:	f380 8811 	msr	BASEPRI, r0
   11c36:	f04f 0003 	mov.w	r0, #3
   11c3a:	df02      	svc	2
		lll_done(NULL);
   11c3c:	2000      	movs	r0, #0
   11c3e:	f7ff f8fd 	bl	10e3c <lll_done>
}
   11c42:	2000      	movs	r0, #0
   11c44:	b003      	add	sp, #12
   11c46:	bdf0      	pop	{r4, r5, r6, r7, pc}
	radio_reset();
   11c48:	f003 ffa4 	bl	15b94 <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   11c4c:	4628      	mov	r0, r5
   11c4e:	f003 ffd5 	bl	15bfc <radio_tx_power_set>
	radio_phy_set(0, 0);
   11c52:	4629      	mov	r1, r5
   11c54:	4628      	mov	r0, r5
   11c56:	f003 ffc1 	bl	15bdc <radio_phy_set>
	radio_pkt_configure(8, PDU_AC_PAYLOAD_SIZE_MAX, 0);
   11c5a:	462a      	mov	r2, r5
   11c5c:	2125      	movs	r1, #37	; 0x25
   11c5e:	2008      	movs	r0, #8
   11c60:	f004 f802 	bl	15c68 <radio_pkt_configure>
	radio_aa_set((u8_t *)&aa);
   11c64:	a801      	add	r0, sp, #4
   11c66:	f003 ffe7 	bl	15c38 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
   11c6a:	492d      	ldr	r1, [pc, #180]	; (11d20 <prepare_cb+0x118>)
   11c6c:	f240 605b 	movw	r0, #1627	; 0x65b
   11c70:	f004 f86a 	bl	15d48 <radio_crc_configure>
	lll->chan_map_curr = lll->chan_map;
   11c74:	7b23      	ldrb	r3, [r4, #12]
   11c76:	f3c3 0242 	ubfx	r2, r3, #1, #3
   11c7a:	f362 1306 	bfi	r3, r2, #4, #3
   11c7e:	7323      	strb	r3, [r4, #12]
	chan_prepare(lll);
   11c80:	4620      	mov	r0, r4
   11c82:	f7ff ff3f 	bl	11b04 <chan_prepare>
	if (ull_filter_lll_rl_enabled()) {
   11c86:	f003 fe57 	bl	15938 <ull_filter_lll_rl_enabled>
   11c8a:	7b63      	ldrb	r3, [r4, #13]
   11c8c:	b348      	cbz	r0, 11ce2 <prepare_cb+0xda>
			ull_filter_lll_get(!!(lll->filter_policy));
   11c8e:	f013 0003 	ands.w	r0, r3, #3
   11c92:	bf18      	it	ne
   11c94:	2001      	movne	r0, #1
		struct lll_filter *wl = ull_filter_lll_get(true);
   11c96:	f003 fe07 	bl	158a8 <ull_filter_lll_get>
		radio_filter_configure(wl->enable_bitmask,
   11c9a:	1c82      	adds	r2, r0, #2
   11c9c:	7841      	ldrb	r1, [r0, #1]
   11c9e:	7800      	ldrb	r0, [r0, #0]
   11ca0:	f004 f8a6 	bl	15df0 <radio_filter_configure>
	evt = HDR_LLL2EVT(lll);
   11ca4:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
   11ca6:	6835      	ldr	r5, [r6, #0]
	ticks_at_event += lll_evt_offset_get(evt);
   11ca8:	4638      	mov	r0, r7
   11caa:	f00b fb8a 	bl	1d3c2 <lll_evt_offset_get>
   11cae:	4405      	add	r5, r0
	remainder_us = radio_tmr_start(1, ticks_at_start, remainder);
   11cb0:	6872      	ldr	r2, [r6, #4]
   11cb2:	f105 0109 	add.w	r1, r5, #9
   11cb6:	2001      	movs	r0, #1
   11cb8:	f004 f900 	bl	15ebc <radio_tmr_start>
	radio_tmr_end_capture();
   11cbc:	f004 f9b8 	bl	16030 <radio_tmr_end_capture>
				   ull_adv_lll_handle_get(lll)),
   11cc0:	4620      	mov	r0, r4
   11cc2:	f7ff fc31 	bl	11528 <ull_adv_lll_handle_get>
	if (lll_preempt_calc(evt, (TICKER_ID_ADV_BASE +
   11cc6:	1c81      	adds	r1, r0, #2
   11cc8:	462a      	mov	r2, r5
   11cca:	b2c9      	uxtb	r1, r1
   11ccc:	4638      	mov	r0, r7
   11cce:	f00b fb86 	bl	1d3de <lll_preempt_calc>
   11cd2:	b150      	cbz	r0, 11cea <prepare_cb+0xe2>
		radio_isr_set(isr_abort, lll);
   11cd4:	4621      	mov	r1, r4
   11cd6:	4813      	ldr	r0, [pc, #76]	; (11d24 <prepare_cb+0x11c>)
   11cd8:	f003 ff3c 	bl	15b54 <radio_isr_set>
		radio_disable();
   11cdc:	f004 f802 	bl	15ce4 <radio_disable>
   11ce0:	e7af      	b.n	11c42 <prepare_cb+0x3a>
	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER) && lll->filter_policy) {
   11ce2:	079b      	lsls	r3, r3, #30
   11ce4:	d0de      	beq.n	11ca4 <prepare_cb+0x9c>
		struct lll_filter *wl = ull_filter_lll_get(true);
   11ce6:	2001      	movs	r0, #1
   11ce8:	e7d5      	b.n	11c96 <prepare_cb+0x8e>
		ret = lll_prepare_done(lll);
   11cea:	4620      	mov	r0, r4
   11cec:	f00b fb67 	bl	1d3be <lll_prepare_done>
		LL_ASSERT(!ret);
   11cf0:	2800      	cmp	r0, #0
   11cf2:	d0a6      	beq.n	11c42 <prepare_cb+0x3a>
   11cf4:	23e8      	movs	r3, #232	; 0xe8
   11cf6:	4a07      	ldr	r2, [pc, #28]	; (11d14 <prepare_cb+0x10c>)
   11cf8:	490b      	ldr	r1, [pc, #44]	; (11d28 <prepare_cb+0x120>)
   11cfa:	4808      	ldr	r0, [pc, #32]	; (11d1c <prepare_cb+0x114>)
   11cfc:	f007 fb3a 	bl	19374 <printk>
   11d00:	4040      	eors	r0, r0
   11d02:	f380 8811 	msr	BASEPRI, r0
   11d06:	f04f 0003 	mov.w	r0, #3
   11d0a:	df02      	svc	2
   11d0c:	e799      	b.n	11c42 <prepare_cb+0x3a>
   11d0e:	bf00      	nop
   11d10:	8e89bed6 	.word	0x8e89bed6
   11d14:	00021ded 	.word	0x00021ded
   11d18:	00021e30 	.word	0x00021e30
   11d1c:	00020aa4 	.word	0x00020aa4
   11d20:	00555555 	.word	0x00555555
   11d24:	0001d433 	.word	0x0001d433
   11d28:	00021ae5 	.word	0x00021ae5

00011d2c <lll_adv_prepare>:
{
   11d2c:	b513      	push	{r0, r1, r4, lr}
   11d2e:	4604      	mov	r4, r0
	err = lll_clk_on();
   11d30:	f7ff f8ce 	bl	10ed0 <lll_clk_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
   11d34:	b168      	cbz	r0, 11d52 <lll_adv_prepare+0x26>
   11d36:	3044      	adds	r0, #68	; 0x44
   11d38:	d00b      	beq.n	11d52 <lll_adv_prepare+0x26>
   11d3a:	236d      	movs	r3, #109	; 0x6d
   11d3c:	4a11      	ldr	r2, [pc, #68]	; (11d84 <lll_adv_prepare+0x58>)
   11d3e:	4912      	ldr	r1, [pc, #72]	; (11d88 <lll_adv_prepare+0x5c>)
   11d40:	4812      	ldr	r0, [pc, #72]	; (11d8c <lll_adv_prepare+0x60>)
   11d42:	f007 fb17 	bl	19374 <printk>
   11d46:	4040      	eors	r0, r0
   11d48:	f380 8811 	msr	BASEPRI, r0
   11d4c:	f04f 0003 	mov.w	r0, #3
   11d50:	df02      	svc	2
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, p);
   11d52:	9400      	str	r4, [sp, #0]
   11d54:	2300      	movs	r3, #0
   11d56:	4a0e      	ldr	r2, [pc, #56]	; (11d90 <lll_adv_prepare+0x64>)
   11d58:	490e      	ldr	r1, [pc, #56]	; (11d94 <lll_adv_prepare+0x68>)
   11d5a:	480f      	ldr	r0, [pc, #60]	; (11d98 <lll_adv_prepare+0x6c>)
   11d5c:	f00b fb26 	bl	1d3ac <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   11d60:	b168      	cbz	r0, 11d7e <lll_adv_prepare+0x52>
   11d62:	3044      	adds	r0, #68	; 0x44
   11d64:	d00b      	beq.n	11d7e <lll_adv_prepare+0x52>
   11d66:	2370      	movs	r3, #112	; 0x70
   11d68:	4a06      	ldr	r2, [pc, #24]	; (11d84 <lll_adv_prepare+0x58>)
   11d6a:	4907      	ldr	r1, [pc, #28]	; (11d88 <lll_adv_prepare+0x5c>)
   11d6c:	4807      	ldr	r0, [pc, #28]	; (11d8c <lll_adv_prepare+0x60>)
   11d6e:	f007 fb01 	bl	19374 <printk>
   11d72:	4040      	eors	r0, r0
   11d74:	f380 8811 	msr	BASEPRI, r0
   11d78:	f04f 0003 	mov.w	r0, #3
   11d7c:	df02      	svc	2
}
   11d7e:	b002      	add	sp, #8
   11d80:	bd10      	pop	{r4, pc}
   11d82:	bf00      	nop
   11d84:	00021ded 	.word	0x00021ded
   11d88:	00021dda 	.word	0x00021dda
   11d8c:	00020aa4 	.word	0x00020aa4
   11d90:	00011c09 	.word	0x00011c09
   11d94:	000117d9 	.word	0x000117d9
   11d98:	00011769 	.word	0x00011769

00011d9c <pdu_len_cmp>:
		break;
	}
}

static inline bool pdu_len_cmp(u8_t opcode, u8_t len)
{
   11d9c:	b5f0      	push	{r4, r5, r6, r7, lr}
	const u8_t ctrl_len_lut[] = {
   11d9e:	4b0d      	ldr	r3, [pc, #52]	; (11dd4 <pdu_len_cmp+0x38>)
{
   11da0:	b089      	sub	sp, #36	; 0x24
   11da2:	4605      	mov	r5, r0
   11da4:	460e      	mov	r6, r1
	const u8_t ctrl_len_lut[] = {
   11da6:	aa01      	add	r2, sp, #4
   11da8:	f103 0718 	add.w	r7, r3, #24
   11dac:	6818      	ldr	r0, [r3, #0]
   11dae:	6859      	ldr	r1, [r3, #4]
   11db0:	4614      	mov	r4, r2
   11db2:	c403      	stmia	r4!, {r0, r1}
   11db4:	3308      	adds	r3, #8
   11db6:	42bb      	cmp	r3, r7
   11db8:	4622      	mov	r2, r4
   11dba:	d1f7      	bne.n	11dac <pdu_len_cmp+0x10>
   11dbc:	881b      	ldrh	r3, [r3, #0]
   11dbe:	8023      	strh	r3, [r4, #0]
		 sizeof(struct pdu_data_llctrl_phy_upd_ind)),
		(offsetof(struct pdu_data_llctrl, min_used_chans_ind) +
		 sizeof(struct pdu_data_llctrl_min_used_chans_ind)),
	};

	return ctrl_len_lut[opcode] == len;
   11dc0:	ab08      	add	r3, sp, #32
   11dc2:	441d      	add	r5, r3
   11dc4:	f815 0c1c 	ldrb.w	r0, [r5, #-28]
}
   11dc8:	1b83      	subs	r3, r0, r6
   11dca:	4258      	negs	r0, r3
   11dcc:	4158      	adcs	r0, r3
   11dce:	b009      	add	sp, #36	; 0x24
   11dd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11dd2:	bf00      	nop
   11dd4:	0001eee2 	.word	0x0001eee2

00011dd8 <ticker_update_latency_cancel_op_cb>:
{
   11dd8:	b510      	push	{r4, lr}
   11dda:	460c      	mov	r4, r1
	LL_ASSERT(ticker_status == TICKER_STATUS_SUCCESS);
   11ddc:	b160      	cbz	r0, 11df8 <ticker_update_latency_cancel_op_cb+0x20>
   11dde:	f240 633a 	movw	r3, #1594	; 0x63a
   11de2:	4a09      	ldr	r2, [pc, #36]	; (11e08 <ticker_update_latency_cancel_op_cb+0x30>)
   11de4:	4909      	ldr	r1, [pc, #36]	; (11e0c <ticker_update_latency_cancel_op_cb+0x34>)
   11de6:	480a      	ldr	r0, [pc, #40]	; (11e10 <ticker_update_latency_cancel_op_cb+0x38>)
   11de8:	f007 fac4 	bl	19374 <printk>
   11dec:	4040      	eors	r0, r0
   11dee:	f380 8811 	msr	BASEPRI, r0
   11df2:	f04f 0003 	mov.w	r0, #3
   11df6:	df02      	svc	2
	conn->slave.latency_cancel = 0U;
   11df8:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
   11dfc:	f36f 0341 	bfc	r3, #1, #1
   11e00:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
}
   11e04:	bd10      	pop	{r4, pc}
   11e06:	bf00      	nop
   11e08:	00021f06 	.word	0x00021f06
   11e0c:	00021f3f 	.word	0x00021f3f
   11e10:	00020aa4 	.word	0x00020aa4

00011e14 <init_reset>:
{
   11e14:	b508      	push	{r3, lr}
	mem_init(conn_pool, sizeof(struct ll_conn),
   11e16:	2201      	movs	r2, #1
   11e18:	4b12      	ldr	r3, [pc, #72]	; (11e64 <init_reset+0x50>)
   11e1a:	4813      	ldr	r0, [pc, #76]	; (11e68 <init_reset+0x54>)
   11e1c:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
   11e20:	f00b f800 	bl	1ce24 <mem_init>
	mem_init(mem_conn_tx.pool, CONN_TX_BUF_SIZE, CONFIG_BT_CTLR_TX_BUFFERS,
   11e24:	4b11      	ldr	r3, [pc, #68]	; (11e6c <init_reset+0x58>)
   11e26:	2203      	movs	r2, #3
   11e28:	1d18      	adds	r0, r3, #4
   11e2a:	2124      	movs	r1, #36	; 0x24
   11e2c:	f00a fffa 	bl	1ce24 <mem_init>
	mem_init(mem_conn_tx_ctrl.pool, CONN_TX_CTRL_BUF_SIZE,
   11e30:	4b0f      	ldr	r3, [pc, #60]	; (11e70 <init_reset+0x5c>)
   11e32:	2204      	movs	r2, #4
   11e34:	1898      	adds	r0, r3, r2
   11e36:	2120      	movs	r1, #32
   11e38:	f00a fff4 	bl	1ce24 <mem_init>
	mem_init(mem_link_tx.pool, sizeof(memq_link_t),
   11e3c:	4b0d      	ldr	r3, [pc, #52]	; (11e74 <init_reset+0x60>)
   11e3e:	2207      	movs	r2, #7
   11e40:	1d18      	adds	r0, r3, #4
   11e42:	2108      	movs	r1, #8
   11e44:	f00a ffee 	bl	1ce24 <mem_init>
	default_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
   11e48:	4b0b      	ldr	r3, [pc, #44]	; (11e78 <init_reset+0x64>)
   11e4a:	221b      	movs	r2, #27
   11e4c:	801a      	strh	r2, [r3, #0]
	default_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0);
   11e4e:	4b0b      	ldr	r3, [pc, #44]	; (11e7c <init_reset+0x68>)
   11e50:	f44f 72a4 	mov.w	r2, #328	; 0x148
   11e54:	801a      	strh	r2, [r3, #0]
	default_phy_tx |= BIT(1);
   11e56:	4a0a      	ldr	r2, [pc, #40]	; (11e80 <init_reset+0x6c>)
   11e58:	2303      	movs	r3, #3
   11e5a:	7013      	strb	r3, [r2, #0]
	default_phy_rx |= BIT(1);
   11e5c:	4a09      	ldr	r2, [pc, #36]	; (11e84 <init_reset+0x70>)
   11e5e:	7013      	strb	r3, [r2, #0]
}
   11e60:	2000      	movs	r0, #0
   11e62:	bd08      	pop	{r3, pc}
   11e64:	20001188 	.word	0x20001188
   11e68:	2000118c 	.word	0x2000118c
   11e6c:	20001364 	.word	0x20001364
   11e70:	200013d4 	.word	0x200013d4
   11e74:	20001458 	.word	0x20001458
   11e78:	20001b0a 	.word	0x20001b0a
   11e7c:	20001b0c 	.word	0x20001b0c
   11e80:	20001c88 	.word	0x20001c88
   11e84:	20001c87 	.word	0x20001c87

00011e88 <ticker_start_conn_op_cb>:
{
   11e88:	b510      	push	{r4, lr}
   11e8a:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   11e8c:	b160      	cbz	r0, 11ea8 <ticker_start_conn_op_cb+0x20>
   11e8e:	f240 6356 	movw	r3, #1622	; 0x656
   11e92:	4a0f      	ldr	r2, [pc, #60]	; (11ed0 <ticker_start_conn_op_cb+0x48>)
   11e94:	490f      	ldr	r1, [pc, #60]	; (11ed4 <ticker_start_conn_op_cb+0x4c>)
   11e96:	4810      	ldr	r0, [pc, #64]	; (11ed8 <ticker_start_conn_op_cb+0x50>)
   11e98:	f007 fa6c 	bl	19374 <printk>
   11e9c:	4040      	eors	r0, r0
   11e9e:	f380 8811 	msr	BASEPRI, r0
   11ea2:	f04f 0003 	mov.w	r0, #3
   11ea6:	df02      	svc	2
	void *p = ull_update_unmark(param);
   11ea8:	4620      	mov	r0, r4
   11eaa:	f7fe fb0b 	bl	104c4 <ull_update_unmark>
	LL_ASSERT(p == param);
   11eae:	4284      	cmp	r4, r0
   11eb0:	d00c      	beq.n	11ecc <ticker_start_conn_op_cb+0x44>
   11eb2:	f240 635a 	movw	r3, #1626	; 0x65a
   11eb6:	4a06      	ldr	r2, [pc, #24]	; (11ed0 <ticker_start_conn_op_cb+0x48>)
   11eb8:	4908      	ldr	r1, [pc, #32]	; (11edc <ticker_start_conn_op_cb+0x54>)
   11eba:	4807      	ldr	r0, [pc, #28]	; (11ed8 <ticker_start_conn_op_cb+0x50>)
   11ebc:	f007 fa5a 	bl	19374 <printk>
   11ec0:	4040      	eors	r0, r0
   11ec2:	f380 8811 	msr	BASEPRI, r0
   11ec6:	f04f 0003 	mov.w	r0, #3
   11eca:	df02      	svc	2
}
   11ecc:	bd10      	pop	{r4, pc}
   11ece:	bf00      	nop
   11ed0:	00021f06 	.word	0x00021f06
   11ed4:	00021f46 	.word	0x00021f46
   11ed8:	00020aa4 	.word	0x00020aa4
   11edc:	00021eaa 	.word	0x00021eaa

00011ee0 <ticker_stop_conn_op_cb>:
{
   11ee0:	b510      	push	{r4, lr}
   11ee2:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   11ee4:	b160      	cbz	r0, 11f00 <ticker_stop_conn_op_cb+0x20>
   11ee6:	f240 634d 	movw	r3, #1613	; 0x64d
   11eea:	4a0f      	ldr	r2, [pc, #60]	; (11f28 <ticker_stop_conn_op_cb+0x48>)
   11eec:	490f      	ldr	r1, [pc, #60]	; (11f2c <ticker_stop_conn_op_cb+0x4c>)
   11eee:	4810      	ldr	r0, [pc, #64]	; (11f30 <ticker_stop_conn_op_cb+0x50>)
   11ef0:	f007 fa40 	bl	19374 <printk>
   11ef4:	4040      	eors	r0, r0
   11ef6:	f380 8811 	msr	BASEPRI, r0
   11efa:	f04f 0003 	mov.w	r0, #3
   11efe:	df02      	svc	2
	void *p = ull_update_mark(param);
   11f00:	4620      	mov	r0, r4
   11f02:	f7fe fad7 	bl	104b4 <ull_update_mark>
	LL_ASSERT(p == param);
   11f06:	4284      	cmp	r4, r0
   11f08:	d00c      	beq.n	11f24 <ticker_stop_conn_op_cb+0x44>
   11f0a:	f240 6351 	movw	r3, #1617	; 0x651
   11f0e:	4a06      	ldr	r2, [pc, #24]	; (11f28 <ticker_stop_conn_op_cb+0x48>)
   11f10:	4908      	ldr	r1, [pc, #32]	; (11f34 <ticker_stop_conn_op_cb+0x54>)
   11f12:	4807      	ldr	r0, [pc, #28]	; (11f30 <ticker_stop_conn_op_cb+0x50>)
   11f14:	f007 fa2e 	bl	19374 <printk>
   11f18:	4040      	eors	r0, r0
   11f1a:	f380 8811 	msr	BASEPRI, r0
   11f1e:	f04f 0003 	mov.w	r0, #3
   11f22:	df02      	svc	2
}
   11f24:	bd10      	pop	{r4, pc}
   11f26:	bf00      	nop
   11f28:	00021f06 	.word	0x00021f06
   11f2c:	00021f46 	.word	0x00021f46
   11f30:	00020aa4 	.word	0x00020aa4
   11f34:	00021eaa 	.word	0x00021eaa

00011f38 <ticker_update_conn_op_cb>:
{
   11f38:	b510      	push	{r4, lr}
   11f3a:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
   11f3c:	b1a0      	cbz	r0, 11f68 <ticker_update_conn_op_cb+0x30>
   11f3e:	f7fe facf 	bl	104e0 <ull_update_mark_get>
   11f42:	4284      	cmp	r4, r0
   11f44:	d010      	beq.n	11f68 <ticker_update_conn_op_cb+0x30>
   11f46:	f7fe faaf 	bl	104a8 <ull_disable_mark_get>
   11f4a:	4284      	cmp	r4, r0
   11f4c:	d00c      	beq.n	11f68 <ticker_update_conn_op_cb+0x30>
   11f4e:	f44f 63c9 	mov.w	r3, #1608	; 0x648
   11f52:	4a06      	ldr	r2, [pc, #24]	; (11f6c <ticker_update_conn_op_cb+0x34>)
   11f54:	4906      	ldr	r1, [pc, #24]	; (11f70 <ticker_update_conn_op_cb+0x38>)
   11f56:	4807      	ldr	r0, [pc, #28]	; (11f74 <ticker_update_conn_op_cb+0x3c>)
   11f58:	f007 fa0c 	bl	19374 <printk>
   11f5c:	4040      	eors	r0, r0
   11f5e:	f380 8811 	msr	BASEPRI, r0
   11f62:	f04f 0003 	mov.w	r0, #3
   11f66:	df02      	svc	2
}
   11f68:	bd10      	pop	{r4, pc}
   11f6a:	bf00      	nop
   11f6c:	00021f06 	.word	0x00021f06
   11f70:	00021eb5 	.word	0x00021eb5
   11f74:	00020aa4 	.word	0x00020aa4

00011f78 <ticker_op_stop_cb>:
{
   11f78:	b510      	push	{r4, lr}
   11f7a:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   11f7c:	b160      	cbz	r0, 11f98 <ticker_op_stop_cb+0x20>
   11f7e:	f240 6363 	movw	r3, #1635	; 0x663
   11f82:	4a10      	ldr	r2, [pc, #64]	; (11fc4 <ticker_op_stop_cb+0x4c>)
   11f84:	4910      	ldr	r1, [pc, #64]	; (11fc8 <ticker_op_stop_cb+0x50>)
   11f86:	4811      	ldr	r0, [pc, #68]	; (11fcc <ticker_op_stop_cb+0x54>)
   11f88:	f007 f9f4 	bl	19374 <printk>
   11f8c:	4040      	eors	r0, r0
   11f8e:	f380 8811 	msr	BASEPRI, r0
   11f92:	f04f 0003 	mov.w	r0, #3
   11f96:	df02      	svc	2
	mfy.param = param;
   11f98:	4b0d      	ldr	r3, [pc, #52]	; (11fd0 <ticker_op_stop_cb+0x58>)
	retval = mayfly_enqueue(TICKER_USER_ID_ULL_LOW, TICKER_USER_ID_LLL, 0,
   11f9a:	2200      	movs	r2, #0
   11f9c:	4611      	mov	r1, r2
   11f9e:	2002      	movs	r0, #2
	mfy.param = param;
   11fa0:	609c      	str	r4, [r3, #8]
	retval = mayfly_enqueue(TICKER_USER_ID_ULL_LOW, TICKER_USER_ID_LLL, 0,
   11fa2:	f7fb fd9b 	bl	dadc <mayfly_enqueue>
	LL_ASSERT(!retval);
   11fa6:	b160      	cbz	r0, 11fc2 <ticker_op_stop_cb+0x4a>
   11fa8:	f240 636a 	movw	r3, #1642	; 0x66a
   11fac:	4a05      	ldr	r2, [pc, #20]	; (11fc4 <ticker_op_stop_cb+0x4c>)
   11fae:	4909      	ldr	r1, [pc, #36]	; (11fd4 <ticker_op_stop_cb+0x5c>)
   11fb0:	4806      	ldr	r0, [pc, #24]	; (11fcc <ticker_op_stop_cb+0x54>)
   11fb2:	f007 f9df 	bl	19374 <printk>
   11fb6:	4040      	eors	r0, r0
   11fb8:	f380 8811 	msr	BASEPRI, r0
   11fbc:	f04f 0003 	mov.w	r0, #3
   11fc0:	df02      	svc	2
}
   11fc2:	bd10      	pop	{r4, pc}
   11fc4:	00021f06 	.word	0x00021f06
   11fc8:	00021f46 	.word	0x00021f46
   11fcc:	00020aa4 	.word	0x00020aa4
   11fd0:	20005958 	.word	0x20005958
   11fd4:	00021aea 	.word	0x00021aea

00011fd8 <conn_cleanup>:
	rx->hdr.handle = conn->lll.handle;
   11fd8:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
{
   11fda:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	rx->hdr.handle = conn->lll.handle;
   11fde:	f8a0 3132 	strh.w	r3, [r0, #306]	; 0x132
	*((u8_t *)rx->pdu) = reason;
   11fe2:	f880 114c 	strb.w	r1, [r0, #332]	; 0x14c
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
   11fe6:	2309      	movs	r3, #9
	rx = conn->llcp_rx;
   11fe8:	f8d0 1100 	ldr.w	r1, [r0, #256]	; 0x100
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
   11fec:	f880 3130 	strb.w	r3, [r0, #304]	; 0x130
{
   11ff0:	4604      	mov	r4, r0
	struct lll_conn *lll = &conn->lll;
   11ff2:	f100 061c 	add.w	r6, r0, #28
		hdr->type = NODE_RX_TYPE_DC_PDU_RELEASE;
   11ff6:	2503      	movs	r5, #3
	while (rx) {
   11ff8:	bb19      	cbnz	r1, 12042 <conn_cleanup+0x6a>
		link = mem_acquire(&mem_link_tx.free);
   11ffa:	4f24      	ldr	r7, [pc, #144]	; (1208c <conn_cleanup+0xb4>)
		LL_ASSERT(link);
   11ffc:	f8df 8094 	ldr.w	r8, [pc, #148]	; 12094 <conn_cleanup+0xbc>
   12000:	f8df 909c 	ldr.w	r9, [pc, #156]	; 120a0 <conn_cleanup+0xc8>
	while (conn->tx_head) {
   12004:	f8d4 01b0 	ldr.w	r0, [r4, #432]	; 0x1b0
   12008:	bb10      	cbnz	r0, 12050 <conn_cleanup+0x78>
				    TICKER_ID_CONN_BASE + lll->handle,
   1200a:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   1200e:	4b20      	ldr	r3, [pc, #128]	; (12090 <conn_cleanup+0xb8>)
   12010:	9600      	str	r6, [sp, #0]
				    TICKER_ID_CONN_BASE + lll->handle,
   12012:	3203      	adds	r2, #3
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   12014:	b2d2      	uxtb	r2, r2
   12016:	2101      	movs	r1, #1
   12018:	f7fc fa70 	bl	e4fc <ticker_stop>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   1201c:	f030 0302 	bics.w	r3, r0, #2
   12020:	d00c      	beq.n	1203c <conn_cleanup+0x64>
   12022:	f240 63b3 	movw	r3, #1715	; 0x6b3
   12026:	4a1b      	ldr	r2, [pc, #108]	; (12094 <conn_cleanup+0xbc>)
   12028:	491b      	ldr	r1, [pc, #108]	; (12098 <conn_cleanup+0xc0>)
   1202a:	481c      	ldr	r0, [pc, #112]	; (1209c <conn_cleanup+0xc4>)
   1202c:	f007 f9a2 	bl	19374 <printk>
   12030:	4040      	eors	r0, r0
   12032:	f380 8811 	msr	BASEPRI, r0
   12036:	f04f 0003 	mov.w	r0, #3
   1203a:	df02      	svc	2
}
   1203c:	b002      	add	sp, #8
   1203e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		rx = hdr->link->mem;
   12042:	6808      	ldr	r0, [r1, #0]
   12044:	6847      	ldr	r7, [r0, #4]
		hdr->type = NODE_RX_TYPE_DC_PDU_RELEASE;
   12046:	710d      	strb	r5, [r1, #4]
		ll_rx_put(hdr->link, hdr);
   12048:	f7fe f97c 	bl	10344 <ll_rx_put>
		rx = hdr->link->mem;
   1204c:	4639      	mov	r1, r7
   1204e:	e7d3      	b.n	11ff8 <conn_cleanup+0x20>
		tx = tx_ull_dequeue(conn, conn->tx_head);
   12050:	4601      	mov	r1, r0
   12052:	4620      	mov	r0, r4
   12054:	f00b fa66 	bl	1d524 <tx_ull_dequeue>
   12058:	4682      	mov	sl, r0
		link = mem_acquire(&mem_link_tx.free);
   1205a:	4638      	mov	r0, r7
   1205c:	f00a ff06 	bl	1ce6c <mem_acquire>
		LL_ASSERT(link);
   12060:	4605      	mov	r5, r0
   12062:	b960      	cbnz	r0, 1207e <conn_cleanup+0xa6>
   12064:	f240 63bf 	movw	r3, #1727	; 0x6bf
   12068:	4642      	mov	r2, r8
   1206a:	4649      	mov	r1, r9
   1206c:	480b      	ldr	r0, [pc, #44]	; (1209c <conn_cleanup+0xc4>)
   1206e:	f007 f981 	bl	19374 <printk>
   12072:	4040      	eors	r0, r0
   12074:	f380 8811 	msr	BASEPRI, r0
   12078:	f04f 0003 	mov.w	r0, #3
   1207c:	df02      	svc	2
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
   1207e:	f104 026c 	add.w	r2, r4, #108	; 0x6c
   12082:	4651      	mov	r1, sl
   12084:	4628      	mov	r0, r5
   12086:	f00a ff4f 	bl	1cf28 <memq_enqueue>
   1208a:	e7bb      	b.n	12004 <conn_cleanup+0x2c>
   1208c:	20001458 	.word	0x20001458
   12090:	00011f79 	.word	0x00011f79
   12094:	00021f06 	.word	0x00021f06
   12098:	00021e65 	.word	0x00021e65
   1209c:	00020aa4 	.word	0x00020aa4
   120a0:	00021fdb 	.word	0x00021fdb

000120a4 <tx_lll_flush>:
{
   120a4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	struct ll_conn *conn = (void *)HDR_LLL2EVT(param);
   120a8:	4606      	mov	r6, r0
{
   120aa:	4607      	mov	r7, r0
	struct ll_conn *conn = (void *)HDR_LLL2EVT(param);
   120ac:	f856 5b4c 	ldr.w	r5, [r6], #76
		idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   120b0:	4c2e      	ldr	r4, [pc, #184]	; (1216c <tx_lll_flush+0xc8>)
	lll_conn_flush(lll);
   120b2:	f00b fcfe 	bl	1dab2 <lll_conn_flush>
	link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
   120b6:	aa01      	add	r2, sp, #4
   120b8:	4631      	mov	r1, r6
   120ba:	6d38      	ldr	r0, [r7, #80]	; 0x50
   120bc:	f00a ff43 	bl	1cf46 <memq_dequeue>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   120c0:	f104 0804 	add.w	r8, r4, #4
	while (link) {
   120c4:	b9f0      	cbnz	r0, 12104 <tx_lll_flush+0x60>
	LL_ASSERT(rx->hdr.link);
   120c6:	f8d5 312c 	ldr.w	r3, [r5, #300]	; 0x12c
	rx = (void *)&conn->llcp_terminate.node_rx;
   120ca:	f505 7496 	add.w	r4, r5, #300	; 0x12c
	LL_ASSERT(rx->hdr.link);
   120ce:	b963      	cbnz	r3, 120ea <tx_lll_flush+0x46>
   120d0:	f240 63ea 	movw	r3, #1770	; 0x6ea
   120d4:	4a26      	ldr	r2, [pc, #152]	; (12170 <tx_lll_flush+0xcc>)
   120d6:	4927      	ldr	r1, [pc, #156]	; (12174 <tx_lll_flush+0xd0>)
   120d8:	4827      	ldr	r0, [pc, #156]	; (12178 <tx_lll_flush+0xd4>)
   120da:	f007 f94b 	bl	19374 <printk>
   120de:	4040      	eors	r0, r0
   120e0:	f380 8811 	msr	BASEPRI, r0
   120e4:	f04f 0003 	mov.w	r0, #3
   120e8:	df02      	svc	2
	rx->hdr.link = NULL;
   120ea:	2300      	movs	r3, #0
	link = rx->hdr.link;
   120ec:	f8d5 012c 	ldr.w	r0, [r5, #300]	; 0x12c
	rx->hdr.link = NULL;
   120f0:	f8c5 312c 	str.w	r3, [r5, #300]	; 0x12c
	ull_rx_put(link, rx);
   120f4:	4621      	mov	r1, r4
   120f6:	f7fe fa63 	bl	105c0 <ull_rx_put>
	ull_rx_sched();
   120fa:	f7fe fa71 	bl	105e0 <ull_rx_sched>
}
   120fe:	b002      	add	sp, #8
   12100:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   12104:	78e2      	ldrb	r2, [r4, #3]
	if (last == count) {
   12106:	f894 e001 	ldrb.w	lr, [r4, #1]
   1210a:	f894 c002 	ldrb.w	ip, [r4, #2]
   1210e:	7821      	ldrb	r1, [r4, #0]
	last = last + 1;
   12110:	1c53      	adds	r3, r2, #1
   12112:	b2db      	uxtb	r3, r3
		last = 0U;
   12114:	459e      	cmp	lr, r3
   12116:	bf08      	it	eq
   12118:	2300      	moveq	r3, #0
	if (last == first) {
   1211a:	459c      	cmp	ip, r3
   1211c:	d004      	beq.n	12128 <tx_lll_flush+0x84>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1211e:	fb12 f201 	smulbb	r2, r2, r1
		LL_ASSERT(lll_tx);
   12122:	eb18 0c02 	adds.w	ip, r8, r2
   12126:	d10f      	bne.n	12148 <tx_lll_flush+0xa4>
   12128:	f240 63d6 	movw	r3, #1750	; 0x6d6
   1212c:	4a10      	ldr	r2, [pc, #64]	; (12170 <tx_lll_flush+0xcc>)
   1212e:	4913      	ldr	r1, [pc, #76]	; (1217c <tx_lll_flush+0xd8>)
   12130:	4811      	ldr	r0, [pc, #68]	; (12178 <tx_lll_flush+0xd4>)
   12132:	f007 f91f 	bl	19374 <printk>
   12136:	4040      	eors	r0, r0
   12138:	f380 8811 	msr	BASEPRI, r0
   1213c:	f04f 0003 	mov.w	r0, #3
   12140:	df02      	svc	2
		lll_tx->handle = 0xFFFF;
   12142:	2300      	movs	r3, #0
   12144:	801b      	strh	r3, [r3, #0]
   12146:	deff      	udf	#255	; 0xff
   12148:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1214c:	f828 1002 	strh.w	r1, [r8, r2]
		lll_tx->node = tx;
   12150:	9901      	ldr	r1, [sp, #4]
   12152:	f8cc 1004 	str.w	r1, [ip, #4]
		link->next = tx->next; /* Indicates ctrl pool or data pool */
   12156:	680a      	ldr	r2, [r1, #0]
   12158:	6002      	str	r2, [r0, #0]
		tx->next = link;
   1215a:	6008      	str	r0, [r1, #0]
		link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
   1215c:	aa01      	add	r2, sp, #4
	*last = idx; /* Commit: Update write index */
   1215e:	70e3      	strb	r3, [r4, #3]
   12160:	4631      	mov	r1, r6
   12162:	6d38      	ldr	r0, [r7, #80]	; 0x50
   12164:	f00a feef 	bl	1cf46 <memq_dequeue>
   12168:	e7ac      	b.n	120c4 <tx_lll_flush+0x20>
   1216a:	bf00      	nop
   1216c:	200058f0 	.word	0x200058f0
   12170:	00021f06 	.word	0x00021f06
   12174:	00021fd3 	.word	0x00021fd3
   12178:	00020aa4 	.word	0x00020aa4
   1217c:	00021f52 	.word	0x00021f52

00012180 <ctrl_tx_pause_enqueue>:
{
   12180:	b538      	push	{r3, r4, r5, lr}
   12182:	460d      	mov	r5, r1
   12184:	e9d0 316c 	ldrd	r3, r1, [r0, #432]	; 0x1b0
   12188:	4604      	mov	r4, r0
	if (
   1218a:	2b00      	cmp	r3, #0
   1218c:	d030      	beq.n	121f0 <ctrl_tx_pause_enqueue+0x70>
	    !conn->llcp_enc.pause_tx &&
   1218e:	f890 0152 	ldrb.w	r0, [r0, #338]	; 0x152
	    conn->tx_head &&
   12192:	0780      	lsls	r0, r0, #30
   12194:	d42c      	bmi.n	121f0 <ctrl_tx_pause_enqueue+0x70>
	    !conn->llcp_phy.pause_tx &&
   12196:	f894 01ab 	ldrb.w	r0, [r4, #427]	; 0x1ab
   1219a:	07c0      	lsls	r0, r0, #31
   1219c:	d428      	bmi.n	121f0 <ctrl_tx_pause_enqueue+0x70>
		if (conn->tx_head == conn->tx_data) {
   1219e:	f8d4 01bc 	ldr.w	r0, [r4, #444]	; 0x1bc
   121a2:	4283      	cmp	r3, r0
			conn->tx_data = conn->tx_data->next;
   121a4:	bf04      	itt	eq
   121a6:	6818      	ldreq	r0, [r3, #0]
   121a8:	f8c4 01bc 	streq.w	r0, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
   121ac:	b961      	cbnz	r1, 121c8 <ctrl_tx_pause_enqueue+0x48>
			tx->next = conn->tx_head->next;
   121ae:	6819      	ldr	r1, [r3, #0]
   121b0:	6029      	str	r1, [r5, #0]
			conn->tx_head->next = tx;
   121b2:	601d      	str	r5, [r3, #0]
			if (!pause) {
   121b4:	b91a      	cbnz	r2, 121be <ctrl_tx_pause_enqueue+0x3e>
				conn->tx_ctrl = tx;
   121b6:	f8c4 51b4 	str.w	r5, [r4, #436]	; 0x1b4
	conn->tx_ctrl_last = tx;
   121ba:	f8c4 51b8 	str.w	r5, [r4, #440]	; 0x1b8
	if (!tx->next) {
   121be:	682b      	ldr	r3, [r5, #0]
   121c0:	b90b      	cbnz	r3, 121c6 <ctrl_tx_pause_enqueue+0x46>
		conn->tx_data_last = tx;
   121c2:	f8c4 51c0 	str.w	r5, [r4, #448]	; 0x1c0
}
   121c6:	bd38      	pop	{r3, r4, r5, pc}
			LL_ASSERT(!pause);
   121c8:	b162      	cbz	r2, 121e4 <ctrl_tx_pause_enqueue+0x64>
   121ca:	f240 7345 	movw	r3, #1861	; 0x745
			LL_ASSERT(!pause);
   121ce:	4a0d      	ldr	r2, [pc, #52]	; (12204 <ctrl_tx_pause_enqueue+0x84>)
   121d0:	490d      	ldr	r1, [pc, #52]	; (12208 <ctrl_tx_pause_enqueue+0x88>)
   121d2:	480e      	ldr	r0, [pc, #56]	; (1220c <ctrl_tx_pause_enqueue+0x8c>)
   121d4:	f007 f8ce 	bl	19374 <printk>
   121d8:	4040      	eors	r0, r0
   121da:	f380 8811 	msr	BASEPRI, r0
   121de:	f04f 0003 	mov.w	r0, #3
   121e2:	df02      	svc	2
	tx->next = conn->tx_ctrl_last->next;
   121e4:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
   121e8:	681a      	ldr	r2, [r3, #0]
   121ea:	602a      	str	r2, [r5, #0]
	conn->tx_ctrl_last->next = tx;
   121ec:	601d      	str	r5, [r3, #0]
   121ee:	e7e4      	b.n	121ba <ctrl_tx_pause_enqueue+0x3a>
		if (!conn->tx_ctrl) {
   121f0:	b919      	cbnz	r1, 121fa <ctrl_tx_pause_enqueue+0x7a>
			tx->next = conn->tx_head;
   121f2:	602b      	str	r3, [r5, #0]
			conn->tx_head = tx;
   121f4:	f8c4 51b0 	str.w	r5, [r4, #432]	; 0x1b0
			if (!pause) {
   121f8:	e7dc      	b.n	121b4 <ctrl_tx_pause_enqueue+0x34>
			LL_ASSERT(!pause);
   121fa:	2a00      	cmp	r2, #0
   121fc:	d0f2      	beq.n	121e4 <ctrl_tx_pause_enqueue+0x64>
   121fe:	f240 7357 	movw	r3, #1879	; 0x757
   12202:	e7e4      	b.n	121ce <ctrl_tx_pause_enqueue+0x4e>
   12204:	00021f06 	.word	0x00021f06
   12208:	00021e92 	.word	0x00021e92
   1220c:	00020aa4 	.word	0x00020aa4

00012210 <feature_rsp_send.isra.15>:
static int feature_rsp_send(struct ll_conn *conn, struct node_rx_pdu *rx,
   12210:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12212:	4606      	mov	r6, r0
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   12214:	4820      	ldr	r0, [pc, #128]	; (12298 <feature_rsp_send.isra.15+0x88>)
static int feature_rsp_send(struct ll_conn *conn, struct node_rx_pdu *rx,
   12216:	460d      	mov	r5, r1
   12218:	4617      	mov	r7, r2
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   1221a:	f00a fe27 	bl	1ce6c <mem_acquire>
	if (!tx) {
   1221e:	4604      	mov	r4, r0
   12220:	b3b8      	cbz	r0, 12292 <feature_rsp_send.isra.15+0x82>
	       (features[1] << 8) | (features[2] << 16);
   12222:	79bb      	ldrb	r3, [r7, #6]
   12224:	797a      	ldrb	r2, [r7, #5]
   12226:	041b      	lsls	r3, r3, #16
   12228:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	feat = ~LL_FEAT_BIT_MASK_VALID | features[0] |
   1222c:	793a      	ldrb	r2, [r7, #4]
	       (features[1] << 8) | (features[2] << 16);
   1222e:	4313      	orrs	r3, r2
   12230:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
   12234:	f443 037e 	orr.w	r3, r3, #16646144	; 0xfe0000
	conn->llcp_feature.features &= feat_get(&req->features[0]);
   12238:	f8d6 211c 	ldr.w	r2, [r6, #284]	; 0x11c
	       (features[1] << 8) | (features[2] << 16);
   1223c:	f443 5343 	orr.w	r3, r3, #12480	; 0x30c0
   12240:	f043 0310 	orr.w	r3, r3, #16
	conn->llcp_feature.features &= feat_get(&req->features[0]);
   12244:	4013      	ands	r3, r2
   12246:	f3c3 0310 	ubfx	r3, r3, #0, #17
   1224a:	f8c6 311c 	str.w	r3, [r6, #284]	; 0x11c
	conn->common.fex_valid = 1U;
   1224e:	f896 30dc 	ldrb.w	r3, [r6, #220]	; 0xdc
   12252:	f043 0301 	orr.w	r3, r3, #1
   12256:	f886 30dc 	strb.w	r3, [r6, #220]	; 0xdc
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   1225a:	7903      	ldrb	r3, [r0, #4]
   1225c:	f043 0303 	orr.w	r3, r3, #3
   12260:	7103      	strb	r3, [r0, #4]
	(void)memset(&pdu_tx->llctrl.feature_rsp.features[0], 0x00,
   12262:	2208      	movs	r2, #8
	pdu_tx->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
   12264:	2309      	movs	r3, #9
   12266:	7143      	strb	r3, [r0, #5]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
   12268:	71c3      	strb	r3, [r0, #7]
	(void)memset(&pdu_tx->llctrl.feature_rsp.features[0], 0x00,
   1226a:	2100      	movs	r1, #0
   1226c:	4410      	add	r0, r2
   1226e:	f008 feee 	bl	1b04e <memset>
	sys_put_le24(conn->llcp_feature.features,
   12272:	f8d6 311c 	ldr.w	r3, [r6, #284]	; 0x11c
	dst[0] = val;
   12276:	7223      	strb	r3, [r4, #8]
	dst[1] = val >> 8;
   12278:	f3c3 2207 	ubfx	r2, r3, #8, #8
	dst[2] = val >> 16;
   1227c:	0c1b      	lsrs	r3, r3, #16
   1227e:	72a3      	strb	r3, [r4, #10]
	ctrl_tx_sec_enqueue(conn, tx);
   12280:	4630      	mov	r0, r6
	dst[1] = val >> 8;
   12282:	7262      	strb	r2, [r4, #9]
   12284:	4621      	mov	r1, r4
   12286:	f00b f980 	bl	1d58a <ctrl_tx_sec_enqueue>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1228a:	2303      	movs	r3, #3
   1228c:	702b      	strb	r3, [r5, #0]
	return 0;
   1228e:	2000      	movs	r0, #0
}
   12290:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -ENOBUFS;
   12292:	f06f 0036 	mvn.w	r0, #54	; 0x36
   12296:	e7fb      	b.n	12290 <feature_rsp_send.isra.15+0x80>
   12298:	200013d4 	.word	0x200013d4

0001229c <reject_ext_ind_send.isra.9>:
static int reject_ext_ind_send(struct ll_conn *conn, struct node_rx_pdu *rx,
   1229c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   122a0:	4606      	mov	r6, r0
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   122a2:	480e      	ldr	r0, [pc, #56]	; (122dc <reject_ext_ind_send.isra.9+0x40>)
static int reject_ext_ind_send(struct ll_conn *conn, struct node_rx_pdu *rx,
   122a4:	460d      	mov	r5, r1
   122a6:	4690      	mov	r8, r2
   122a8:	461f      	mov	r7, r3
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   122aa:	f00a fddf 	bl	1ce6c <mem_acquire>
	if (!tx) {
   122ae:	4601      	mov	r1, r0
   122b0:	b188      	cbz	r0, 122d6 <reject_ext_ind_send.isra.9+0x3a>
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   122b2:	7900      	ldrb	r0, [r0, #4]
	pdu_ctrl_tx->llctrl.reject_ext_ind.reject_opcode = reject_opcode;
   122b4:	f881 8008 	strb.w	r8, [r1, #8]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   122b8:	f040 0003 	orr.w	r0, r0, #3
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
   122bc:	2403      	movs	r4, #3
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
   122be:	2311      	movs	r3, #17
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   122c0:	7108      	strb	r0, [r1, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
   122c2:	714c      	strb	r4, [r1, #5]
	ctrl_tx_enqueue(conn, tx);
   122c4:	4630      	mov	r0, r6
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
   122c6:	71cb      	strb	r3, [r1, #7]
	pdu_ctrl_tx->llctrl.reject_ext_ind.error_code = error_code;
   122c8:	724f      	strb	r7, [r1, #9]
	ctrl_tx_enqueue(conn, tx);
   122ca:	f00b f998 	bl	1d5fe <ctrl_tx_enqueue>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   122ce:	702c      	strb	r4, [r5, #0]
	return 0;
   122d0:	2000      	movs	r0, #0
}
   122d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENOBUFS;
   122d6:	f06f 0036 	mvn.w	r0, #54	; 0x36
   122da:	e7fa      	b.n	122d2 <reject_ext_ind_send.isra.9+0x36>
   122dc:	200013d4 	.word	0x200013d4

000122e0 <ll_conn_acquire>:
	return mem_acquire(&conn_free);
   122e0:	4801      	ldr	r0, [pc, #4]	; (122e8 <ll_conn_acquire+0x8>)
   122e2:	f00a bdc3 	b.w	1ce6c <mem_acquire>
   122e6:	bf00      	nop
   122e8:	20001188 	.word	0x20001188

000122ec <ll_conn_release>:
	mem_release(conn, &conn_free);
   122ec:	4901      	ldr	r1, [pc, #4]	; (122f4 <ll_conn_release+0x8>)
   122ee:	f00a bdd6 	b.w	1ce9e <mem_release>
   122f2:	bf00      	nop
   122f4:	20001188 	.word	0x20001188

000122f8 <ll_conn_handle_get>:
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
   122f8:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
   122fc:	4901      	ldr	r1, [pc, #4]	; (12304 <ll_conn_handle_get+0xc>)
   122fe:	f00a bde6 	b.w	1cece <mem_index_get>
   12302:	bf00      	nop
   12304:	2000118c 	.word	0x2000118c

00012308 <ll_conn_get>:
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   12308:	4602      	mov	r2, r0
   1230a:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
   1230e:	4801      	ldr	r0, [pc, #4]	; (12314 <ll_conn_get+0xc>)
   12310:	f00a bdda 	b.w	1cec8 <mem_get>
   12314:	2000118c 	.word	0x2000118c

00012318 <ll_tx_mem_acquire>:
	return mem_acquire(&mem_conn_tx.free);
   12318:	4801      	ldr	r0, [pc, #4]	; (12320 <ll_tx_mem_acquire+0x8>)
   1231a:	f00a bda7 	b.w	1ce6c <mem_acquire>
   1231e:	bf00      	nop
   12320:	20001364 	.word	0x20001364

00012324 <ll_tx_mem_release>:
	mem_release(tx, &mem_conn_tx.free);
   12324:	4901      	ldr	r1, [pc, #4]	; (1232c <ll_tx_mem_release+0x8>)
   12326:	f00a bdba 	b.w	1ce9e <mem_release>
   1232a:	bf00      	nop
   1232c:	20001364 	.word	0x20001364

00012330 <ll_tx_mem_enqueue>:
{
   12330:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12334:	b088      	sub	sp, #32
   12336:	4606      	mov	r6, r0
   12338:	4688      	mov	r8, r1
	conn = ll_connected_get(handle);
   1233a:	f00b f973 	bl	1d624 <ll_connected_get>
	if (!conn) {
   1233e:	2800      	cmp	r0, #0
   12340:	d049      	beq.n	123d6 <ll_tx_mem_enqueue+0xa6>
	idx = MFIFO_ENQUEUE_GET(conn_tx, (void **) &lll_tx);
   12342:	4c28      	ldr	r4, [pc, #160]	; (123e4 <ll_tx_mem_enqueue+0xb4>)
   12344:	78e5      	ldrb	r5, [r4, #3]
	if (last == count) {
   12346:	7867      	ldrb	r7, [r4, #1]
   12348:	78a2      	ldrb	r2, [r4, #2]
   1234a:	7821      	ldrb	r1, [r4, #0]
	last = last + 1;
   1234c:	1c6b      	adds	r3, r5, #1
   1234e:	b2db      	uxtb	r3, r3
		last = 0U;
   12350:	429f      	cmp	r7, r3
   12352:	bf08      	it	eq
   12354:	2300      	moveq	r3, #0
	if (last == first) {
   12356:	429a      	cmp	r2, r3
   12358:	d040      	beq.n	123dc <ll_tx_mem_enqueue+0xac>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1235a:	1d22      	adds	r2, r4, #4
   1235c:	fb15 f501 	smulbb	r5, r5, r1
	if (!lll_tx) {
   12360:	1957      	adds	r7, r2, r5
   12362:	d03b      	beq.n	123dc <ll_tx_mem_enqueue+0xac>
	lll_tx->handle = handle;
   12364:	5356      	strh	r6, [r2, r5]
	*last = idx; /* Commit: Update write index */
   12366:	70e3      	strb	r3, [r4, #3]
	if (conn->lll.role && conn->lll.latency_event &&
   12368:	f990 303d 	ldrsb.w	r3, [r0, #61]	; 0x3d
	lll_tx->node = tx;
   1236c:	f8c7 8004 	str.w	r8, [r7, #4]
	if (conn->lll.role && conn->lll.latency_event &&
   12370:	2b00      	cmp	r3, #0
   12372:	db03      	blt.n	1237c <ll_tx_mem_enqueue+0x4c>
	return 0;
   12374:	2000      	movs	r0, #0
}
   12376:	b008      	add	sp, #32
   12378:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (conn->lll.role && conn->lll.latency_event &&
   1237c:	8e83      	ldrh	r3, [r0, #52]	; 0x34
   1237e:	2b00      	cmp	r3, #0
   12380:	d0f8      	beq.n	12374 <ll_tx_mem_enqueue+0x44>
	    !conn->slave.latency_cancel) {
   12382:	f890 30dc 	ldrb.w	r3, [r0, #220]	; 0xdc
	if (conn->lll.role && conn->lll.latency_event &&
   12386:	f013 0402 	ands.w	r4, r3, #2
   1238a:	d1f3      	bne.n	12374 <ll_tx_mem_enqueue+0x44>
		conn->slave.latency_cancel = 1U;
   1238c:	f043 0302 	orr.w	r3, r3, #2
   12390:	f880 30dc 	strb.w	r3, [r0, #220]	; 0xdc
			ticker_update(TICKER_INSTANCE_ID_CTLR,
   12394:	4b14      	ldr	r3, [pc, #80]	; (123e8 <ll_tx_mem_enqueue+0xb8>)
   12396:	9006      	str	r0, [sp, #24]
   12398:	e9cd 4304 	strd	r4, r3, [sp, #16]
				      (TICKER_ID_CONN_BASE + handle),
   1239c:	1cf2      	adds	r2, r6, #3
			ticker_update(TICKER_INSTANCE_ID_CTLR,
   1239e:	2301      	movs	r3, #1
   123a0:	e9cd 4302 	strd	r4, r3, [sp, #8]
   123a4:	e9cd 4400 	strd	r4, r4, [sp]
   123a8:	4623      	mov	r3, r4
   123aa:	b2d2      	uxtb	r2, r2
   123ac:	2103      	movs	r1, #3
   123ae:	4620      	mov	r0, r4
   123b0:	f7fc f85c 	bl	e46c <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   123b4:	f030 0302 	bics.w	r3, r0, #2
   123b8:	d0dc      	beq.n	12374 <ll_tx_mem_enqueue+0x44>
   123ba:	f240 1301 	movw	r3, #257	; 0x101
   123be:	4a0b      	ldr	r2, [pc, #44]	; (123ec <ll_tx_mem_enqueue+0xbc>)
   123c0:	490b      	ldr	r1, [pc, #44]	; (123f0 <ll_tx_mem_enqueue+0xc0>)
   123c2:	480c      	ldr	r0, [pc, #48]	; (123f4 <ll_tx_mem_enqueue+0xc4>)
   123c4:	f006 ffd6 	bl	19374 <printk>
   123c8:	4040      	eors	r0, r0
   123ca:	f380 8811 	msr	BASEPRI, r0
   123ce:	f04f 0003 	mov.w	r0, #3
   123d2:	df02      	svc	2
   123d4:	e7ce      	b.n	12374 <ll_tx_mem_enqueue+0x44>
		return -EINVAL;
   123d6:	f06f 0015 	mvn.w	r0, #21
   123da:	e7cc      	b.n	12376 <ll_tx_mem_enqueue+0x46>
		return -ENOBUFS;
   123dc:	f06f 0036 	mvn.w	r0, #54	; 0x36
   123e0:	e7c9      	b.n	12376 <ll_tx_mem_enqueue+0x46>
   123e2:	bf00      	nop
   123e4:	20005934 	.word	0x20005934
   123e8:	00011dd9 	.word	0x00011dd9
   123ec:	00021f06 	.word	0x00021f06
   123f0:	00021e65 	.word	0x00021e65
   123f4:	00020aa4 	.word	0x00020aa4

000123f8 <ll_length_default_get>:
	*max_tx_octets = default_tx_octets;
   123f8:	4b03      	ldr	r3, [pc, #12]	; (12408 <ll_length_default_get+0x10>)
   123fa:	881b      	ldrh	r3, [r3, #0]
   123fc:	8003      	strh	r3, [r0, #0]
	*max_tx_time = default_tx_time;
   123fe:	4b03      	ldr	r3, [pc, #12]	; (1240c <ll_length_default_get+0x14>)
   12400:	881b      	ldrh	r3, [r3, #0]
   12402:	800b      	strh	r3, [r1, #0]
}
   12404:	4770      	bx	lr
   12406:	bf00      	nop
   12408:	20001b0a 	.word	0x20001b0a
   1240c:	20001b0c 	.word	0x20001b0c

00012410 <ll_length_default_set>:
	default_tx_octets = max_tx_octets;
   12410:	4b02      	ldr	r3, [pc, #8]	; (1241c <ll_length_default_set+0xc>)
   12412:	8018      	strh	r0, [r3, #0]
	default_tx_time = max_tx_time;
   12414:	4b02      	ldr	r3, [pc, #8]	; (12420 <ll_length_default_set+0x10>)
}
   12416:	2000      	movs	r0, #0
	default_tx_time = max_tx_time;
   12418:	8019      	strh	r1, [r3, #0]
}
   1241a:	4770      	bx	lr
   1241c:	20001b0a 	.word	0x20001b0a
   12420:	20001b0c 	.word	0x20001b0c

00012424 <ll_phy_default_set>:
	default_phy_tx = tx;
   12424:	4b02      	ldr	r3, [pc, #8]	; (12430 <ll_phy_default_set+0xc>)
   12426:	7018      	strb	r0, [r3, #0]
	default_phy_rx = rx;
   12428:	4b02      	ldr	r3, [pc, #8]	; (12434 <ll_phy_default_set+0x10>)
}
   1242a:	2000      	movs	r0, #0
	default_phy_rx = rx;
   1242c:	7019      	strb	r1, [r3, #0]
}
   1242e:	4770      	bx	lr
   12430:	20001c88 	.word	0x20001c88
   12434:	20001c87 	.word	0x20001c87

00012438 <ull_conn_init>:
{
   12438:	b508      	push	{r3, lr}
   1243a:	4806      	ldr	r0, [pc, #24]	; (12454 <ull_conn_init+0x1c>)
   1243c:	f005 f978 	bl	17730 <z_impl_device_get_binding>
	entropy = device_get_binding(CONFIG_ENTROPY_NAME);
   12440:	4b05      	ldr	r3, [pc, #20]	; (12458 <ull_conn_init+0x20>)
   12442:	6018      	str	r0, [r3, #0]
	if (!entropy) {
   12444:	b118      	cbz	r0, 1244e <ull_conn_init+0x16>
}
   12446:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	err = init_reset();
   1244a:	f7ff bce3 	b.w	11e14 <init_reset>
}
   1244e:	f06f 0012 	mvn.w	r0, #18
   12452:	bd08      	pop	{r3, pc}
   12454:	00021acc 	.word	0x00021acc
   12458:	20001358 	.word	0x20001358

0001245c <ull_conn_reset>:
{
   1245c:	b530      	push	{r4, r5, lr}
   1245e:	b085      	sub	sp, #20
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   12460:	2302      	movs	r3, #2
	conn = ll_conn_get(handle);
   12462:	2000      	movs	r0, #0
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   12464:	9303      	str	r3, [sp, #12]
	conn = ll_conn_get(handle);
   12466:	f7ff ff4f 	bl	12308 <ll_conn_get>
   1246a:	4604      	mov	r4, r0
	mark = ull_disable_mark(conn);
   1246c:	f7fe f806 	bl	1047c <ull_disable_mark>
	LL_ASSERT(mark == conn);
   12470:	4284      	cmp	r4, r0
   12472:	d00c      	beq.n	1248e <ull_conn_reset+0x32>
   12474:	f240 6377 	movw	r3, #1655	; 0x677
   12478:	4a29      	ldr	r2, [pc, #164]	; (12520 <ull_conn_reset+0xc4>)
   1247a:	492a      	ldr	r1, [pc, #168]	; (12524 <ull_conn_reset+0xc8>)
   1247c:	482a      	ldr	r0, [pc, #168]	; (12528 <ull_conn_reset+0xcc>)
   1247e:	f006 ff79 	bl	19374 <printk>
   12482:	4040      	eors	r0, r0
   12484:	f380 8811 	msr	BASEPRI, r0
   12488:	f04f 0003 	mov.w	r0, #3
   1248c:	df02      	svc	2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   1248e:	ad03      	add	r5, sp, #12
   12490:	2203      	movs	r2, #3
   12492:	4611      	mov	r1, r2
   12494:	9500      	str	r5, [sp, #0]
   12496:	4b25      	ldr	r3, [pc, #148]	; (1252c <ull_conn_reset+0xd0>)
   12498:	2000      	movs	r0, #0
   1249a:	f7fc f82f 	bl	e4fc <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
   1249e:	4629      	mov	r1, r5
   124a0:	f7fd ffe0 	bl	10464 <ull_ticker_status_take>
	if (!ret) {
   124a4:	b988      	cbnz	r0, 124ca <ull_conn_reset+0x6e>
		ret = ull_disable(&conn->lll);
   124a6:	f104 001c 	add.w	r0, r4, #28
   124aa:	f7fe f81f 	bl	104ec <ull_disable>
		LL_ASSERT(!ret);
   124ae:	b160      	cbz	r0, 124ca <ull_conn_reset+0x6e>
   124b0:	f44f 63d0 	mov.w	r3, #1664	; 0x680
   124b4:	4a1a      	ldr	r2, [pc, #104]	; (12520 <ull_conn_reset+0xc4>)
   124b6:	491e      	ldr	r1, [pc, #120]	; (12530 <ull_conn_reset+0xd4>)
   124b8:	481b      	ldr	r0, [pc, #108]	; (12528 <ull_conn_reset+0xcc>)
   124ba:	f006 ff5b 	bl	19374 <printk>
   124be:	4040      	eors	r0, r0
   124c0:	f380 8811 	msr	BASEPRI, r0
   124c4:	f04f 0003 	mov.w	r0, #3
   124c8:	df02      	svc	2
	conn->lll.link_tx_free = NULL;
   124ca:	2300      	movs	r3, #0
   124cc:	67a3      	str	r3, [r4, #120]	; 0x78
	mark = ull_disable_unmark(conn);
   124ce:	4620      	mov	r0, r4
   124d0:	f7fd ffdc 	bl	1048c <ull_disable_unmark>
	LL_ASSERT(mark == conn);
   124d4:	4284      	cmp	r4, r0
   124d6:	d00c      	beq.n	124f2 <ull_conn_reset+0x96>
   124d8:	f240 6386 	movw	r3, #1670	; 0x686
   124dc:	4a10      	ldr	r2, [pc, #64]	; (12520 <ull_conn_reset+0xc4>)
   124de:	4911      	ldr	r1, [pc, #68]	; (12524 <ull_conn_reset+0xc8>)
   124e0:	4811      	ldr	r0, [pc, #68]	; (12528 <ull_conn_reset+0xcc>)
   124e2:	f006 ff47 	bl	19374 <printk>
   124e6:	4040      	eors	r0, r0
   124e8:	f380 8811 	msr	BASEPRI, r0
   124ec:	f04f 0003 	mov.w	r0, #3
   124f0:	df02      	svc	2
	data_chan_map[0] = 0xFF;
   124f2:	4b10      	ldr	r3, [pc, #64]	; (12534 <ull_conn_reset+0xd8>)
   124f4:	22ff      	movs	r2, #255	; 0xff
   124f6:	701a      	strb	r2, [r3, #0]
	data_chan_map[1] = 0xFF;
   124f8:	705a      	strb	r2, [r3, #1]
	data_chan_map[2] = 0xFF;
   124fa:	709a      	strb	r2, [r3, #2]
	data_chan_map[3] = 0xFF;
   124fc:	70da      	strb	r2, [r3, #3]
	data_chan_map[4] = 0x1F;
   124fe:	221f      	movs	r2, #31
   12500:	711a      	strb	r2, [r3, #4]
	data_chan_count = 37U;
   12502:	4b0d      	ldr	r3, [pc, #52]	; (12538 <ull_conn_reset+0xdc>)
   12504:	2225      	movs	r2, #37	; 0x25
   12506:	701a      	strb	r2, [r3, #0]
	MFIFO_INIT(conn_tx);
   12508:	4a0c      	ldr	r2, [pc, #48]	; (1253c <ull_conn_reset+0xe0>)
   1250a:	2300      	movs	r3, #0
   1250c:	8053      	strh	r3, [r2, #2]
	MFIFO_INIT(conn_ack);
   1250e:	4a0c      	ldr	r2, [pc, #48]	; (12540 <ull_conn_reset+0xe4>)
   12510:	8053      	strh	r3, [r2, #2]
	conn_upd_curr = NULL;
   12512:	4a0c      	ldr	r2, [pc, #48]	; (12544 <ull_conn_reset+0xe8>)
   12514:	6013      	str	r3, [r2, #0]
	err = init_reset();
   12516:	f7ff fc7d 	bl	11e14 <init_reset>
}
   1251a:	b005      	add	sp, #20
   1251c:	bd30      	pop	{r4, r5, pc}
   1251e:	bf00      	nop
   12520:	00021f06 	.word	0x00021f06
   12524:	00021fe0 	.word	0x00021fe0
   12528:	00020aa4 	.word	0x00020aa4
   1252c:	00010459 	.word	0x00010459
   12530:	00021ae5 	.word	0x00021ae5
   12534:	20005b0c 	.word	0x20005b0c
   12538:	20005b0b 	.word	0x20005b0b
   1253c:	20005934 	.word	0x20005934
   12540:	200058f0 	.word	0x200058f0
   12544:	20001354 	.word	0x20001354

00012548 <ull_conn_default_tx_octets_get>:
}
   12548:	4b01      	ldr	r3, [pc, #4]	; (12550 <ull_conn_default_tx_octets_get+0x8>)
   1254a:	8818      	ldrh	r0, [r3, #0]
   1254c:	4770      	bx	lr
   1254e:	bf00      	nop
   12550:	20001b0a 	.word	0x20001b0a

00012554 <ull_conn_default_tx_time_get>:
}
   12554:	4b01      	ldr	r3, [pc, #4]	; (1255c <ull_conn_default_tx_time_get+0x8>)
   12556:	8818      	ldrh	r0, [r3, #0]
   12558:	4770      	bx	lr
   1255a:	bf00      	nop
   1255c:	20001b0c 	.word	0x20001b0c

00012560 <ull_conn_default_phy_tx_get>:
}
   12560:	4b01      	ldr	r3, [pc, #4]	; (12568 <ull_conn_default_phy_tx_get+0x8>)
   12562:	7818      	ldrb	r0, [r3, #0]
   12564:	4770      	bx	lr
   12566:	bf00      	nop
   12568:	20001c88 	.word	0x20001c88

0001256c <ull_conn_default_phy_rx_get>:
}
   1256c:	4b01      	ldr	r3, [pc, #4]	; (12574 <ull_conn_default_phy_rx_get+0x8>)
   1256e:	7818      	ldrb	r0, [r3, #0]
   12570:	4770      	bx	lr
   12572:	bf00      	nop
   12574:	20001c87 	.word	0x20001c87

00012578 <ull_conn_setup>:
	lll = *((struct lll_conn **)((u8_t *)ftr->param +
   12578:	688b      	ldr	r3, [r1, #8]
   1257a:	689b      	ldr	r3, [r3, #8]
{
   1257c:	b510      	push	{r4, lr}
	switch (lll->role) {
   1257e:	f893 4021 	ldrb.w	r4, [r3, #33]	; 0x21
   12582:	09e4      	lsrs	r4, r4, #7
{
   12584:	460a      	mov	r2, r1
	switch (lll->role) {
   12586:	d004      	beq.n	12592 <ull_conn_setup+0x1a>
		ull_slave_setup(link, rx, ftr, lll);
   12588:	3208      	adds	r2, #8
}
   1258a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ull_slave_setup(link, rx, ftr, lll);
   1258e:	f7ef bd27 	b.w	1fe0 <ull_slave_setup>
		LL_ASSERT(0);
   12592:	f240 23c2 	movw	r3, #706	; 0x2c2
   12596:	4a06      	ldr	r2, [pc, #24]	; (125b0 <ull_conn_setup+0x38>)
   12598:	4906      	ldr	r1, [pc, #24]	; (125b4 <ull_conn_setup+0x3c>)
   1259a:	4807      	ldr	r0, [pc, #28]	; (125b8 <ull_conn_setup+0x40>)
   1259c:	f006 feea 	bl	19374 <printk>
   125a0:	4040      	eors	r0, r0
   125a2:	f380 8811 	msr	BASEPRI, r0
   125a6:	f04f 0003 	mov.w	r0, #3
   125aa:	df02      	svc	2
}
   125ac:	bd10      	pop	{r4, pc}
   125ae:	bf00      	nop
   125b0:	00021f06 	.word	0x00021f06
   125b4:	00022577 	.word	0x00022577
   125b8:	00020aa4 	.word	0x00020aa4

000125bc <ull_conn_rx>:
	conn = ll_connected_get((*rx)->hdr.handle);
   125bc:	680b      	ldr	r3, [r1, #0]
{
   125be:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   125c2:	4680      	mov	r8, r0
	conn = ll_connected_get((*rx)->hdr.handle);
   125c4:	88d8      	ldrh	r0, [r3, #6]
{
   125c6:	460e      	mov	r6, r1
	conn = ll_connected_get((*rx)->hdr.handle);
   125c8:	f00b f82c 	bl	1d624 <ll_connected_get>
	if (!conn) {
   125cc:	6835      	ldr	r5, [r6, #0]
   125ce:	4604      	mov	r4, r0
   125d0:	b910      	cbnz	r0, 125d8 <ull_conn_rx+0x1c>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   125d2:	2303      	movs	r3, #3
   125d4:	712b      	strb	r3, [r5, #4]
	return 0;
   125d6:	e1a5      	b.n	12924 <ull_conn_rx+0x368>
	switch (pdu_rx->ll_id) {
   125d8:	f895 3020 	ldrb.w	r3, [r5, #32]
   125dc:	f890 7152 	ldrb.w	r7, [r0, #338]	; 0x152
   125e0:	f3c3 0301 	ubfx	r3, r3, #0, #2
   125e4:	b2d9      	uxtb	r1, r3
   125e6:	b25b      	sxtb	r3, r3
   125e8:	f007 0201 	and.w	r2, r7, #1
   125ec:	2b00      	cmp	r3, #0
   125ee:	f001 820e 	beq.w	13a0e <ull_conn_rx+0x1452>
   125f2:	2902      	cmp	r1, #2
   125f4:	f241 8206 	bls.w	13a04 <ull_conn_rx+0x1448>
			  struct pdu_data *pdu_rx, struct ll_conn *conn)
{
	int nack = 0;
	u8_t opcode;

	opcode = pdu_rx->llctrl.opcode;
   125f8:	f895 9023 	ldrb.w	r9, [r5, #35]	; 0x23

#if defined(CONFIG_BT_CTLR_LE_ENC)
	/* FIXME: do check in individual case to reduce CPU time */
	if (conn->llcp_enc.pause_rx && ctrl_is_unexpected(conn, opcode)) {
   125fc:	b14a      	cbz	r2, 12612 <ull_conn_rx+0x56>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)))) ||
   125fe:	f990 203d 	ldrsb.w	r2, [r0, #61]	; 0x3d
   12602:	2a00      	cmp	r2, #0
   12604:	f007 0304 	and.w	r3, r7, #4
   12608:	db3d      	blt.n	12686 <ull_conn_rx+0xca>
	return (!conn->lll.role &&
   1260a:	bb23      	cbnz	r3, 12656 <ull_conn_rx+0x9a>
		((!conn->llcp_enc.refresh &&
   1260c:	f1b9 0f02 	cmp.w	r9, #2
   12610:	d132      	bne.n	12678 <ull_conn_rx+0xbc>
	pdu_rx = (void *)(*rx)->pdu;
   12612:	f105 0a20 	add.w	sl, r5, #32

		return 0;
	}
#endif /* CONFIG_BT_CTLR_LE_ENC */

	switch (opcode) {
   12616:	f1b9 0f19 	cmp.w	r9, #25
   1261a:	f201 81e0 	bhi.w	139de <ull_conn_rx+0x1422>
   1261e:	e8df f019 	tbh	[pc, r9, lsl #1]
   12622:	008e      	.short	0x008e
   12624:	003a0108 	.word	0x003a0108
   12628:	0183013c 	.word	0x0183013c
   1262c:	01cd01a8 	.word	0x01cd01a8
   12630:	0206060f 	.word	0x0206060f
   12634:	02500224 	.word	0x02500224
   12638:	02a50281 	.word	0x02a50281
   1263c:	021b02fb 	.word	0x021b02fb
   12640:	049f030e 	.word	0x049f030e
   12644:	05d8005d 	.word	0x05d8005d
   12648:	06d705f4 	.word	0x06d705f4
   1264c:	07c906d7 	.word	0x07c906d7
   12650:	08e6089d 	.word	0x08e6089d
   12654:	09a8      	.short	0x09a8
		 (conn->llcp_enc.refresh &&
   12656:	f1a9 0302 	sub.w	r3, r9, #2
   1265a:	b2db      	uxtb	r3, r3
   1265c:	2b09      	cmp	r3, #9
   1265e:	d80b      	bhi.n	12678 <ull_conn_rx+0xbc>
   12660:	f240 2205 	movw	r2, #517	; 0x205
   12664:	fa22 f303 	lsr.w	r3, r2, r3
   12668:	07da      	lsls	r2, r3, #31
   1266a:	d4d2      	bmi.n	12612 <ull_conn_rx+0x56>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)) ||
   1266c:	4bd1      	ldr	r3, [pc, #836]	; (129b4 <ull_conn_rx+0x3f8>)
   1266e:	fa23 f309 	lsr.w	r3, r3, r9
   12672:	07db      	lsls	r3, r3, #31
   12674:	d4cd      	bmi.n	12612 <ull_conn_rx+0x56>
   12676:	e002      	b.n	1267e <ull_conn_rx+0xc2>
   12678:	f1b9 0f11 	cmp.w	r9, #17
   1267c:	d9f6      	bls.n	1266c <ull_conn_rx+0xb0>
			conn->llcp_terminate.reason_peer =
   1267e:	233d      	movs	r3, #61	; 0x3d
   12680:	f884 312b 	strb.w	r3, [r4, #299]	; 0x12b
   12684:	e171      	b.n	1296a <ull_conn_rx+0x3ae>
	       (conn->lll.role &&
   12686:	b99b      	cbnz	r3, 126b0 <ull_conn_rx+0xf4>
		((!conn->llcp_enc.refresh &&
   12688:	f1b9 0f07 	cmp.w	r9, #7
   1268c:	f000 85d8 	beq.w	13240 <ull_conn_rx+0xc84>
		  (opcode != PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP) &&
   12690:	f1b9 0f02 	cmp.w	r9, #2
   12694:	d117      	bne.n	126c6 <ull_conn_rx+0x10a>
		}
	}
	break;

	case PDU_DATA_LLCTRL_TYPE_TERMINATE_IND:
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_TERMINATE_IND,
   12696:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1269a:	2002      	movs	r0, #2
   1269c:	f7ff fb7e 	bl	11d9c <pdu_len_cmp>
   126a0:	2800      	cmp	r0, #0
   126a2:	f001 819c 	beq.w	139de <ull_conn_rx+0x1422>
				 pdu_rx->len)) {
			goto ull_conn_rx_unknown_rsp_send;
		}

		terminate_ind_recv(conn, *rx, pdu_rx);
   126a6:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
	conn->llcp_terminate.reason_peer = pdu->llctrl.terminate_ind.error_code;
   126aa:	f884 312b 	strb.w	r3, [r4, #299]	; 0x12b
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   126ae:	e790      	b.n	125d2 <ull_conn_rx+0x16>
		 (conn->llcp_enc.refresh &&
   126b0:	f1b9 0f02 	cmp.w	r9, #2
   126b4:	d0ef      	beq.n	12696 <ull_conn_rx+0xda>
		  (opcode != PDU_DATA_LLCTRL_TYPE_TERMINATE_IND) &&
   126b6:	f1b9 0f0b 	cmp.w	r9, #11
   126ba:	f000 8233 	beq.w	12b24 <ull_conn_rx+0x568>
		  (opcode != PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP) &&
   126be:	f1b9 0f03 	cmp.w	r9, #3
   126c2:	f000 80ea 	beq.w	1289a <ull_conn_rx+0x2de>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)) ||
   126c6:	f1b9 0f06 	cmp.w	r9, #6
   126ca:	f000 8177 	beq.w	129bc <ull_conn_rx+0x400>
   126ce:	f1b9 0f0d 	cmp.w	r9, #13
   126d2:	f000 82a1 	beq.w	12c18 <ull_conn_rx+0x65c>
	if (conn->llcp_enc.pause_rx && ctrl_is_unexpected(conn, opcode)) {
   126d6:	f1b9 0f11 	cmp.w	r9, #17
   126da:	d1d0      	bne.n	1267e <ull_conn_rx+0xc2>

		break;
#endif /* CONFIG_BT_CTLR_CONN_PARAM_REQ */

	case PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND:
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND,
   126dc:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   126e0:	2011      	movs	r0, #17
   126e2:	f7ff fb5b 	bl	11d9c <pdu_len_cmp>
   126e6:	2800      	cmp	r0, #0
   126e8:	f001 8179 	beq.w	139de <ull_conn_rx+0x1422>
	switch (rej_ext_ind->reject_opcode) {
   126ec:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   126f0:	2b0f      	cmp	r3, #15
   126f2:	f000 8501 	beq.w	130f8 <ull_conn_rx+0xb3c>
   126f6:	f200 84c5 	bhi.w	13084 <ull_conn_rx+0xac8>
   126fa:	2b03      	cmp	r3, #3
   126fc:	f47f af69 	bne.w	125d2 <ull_conn_rx+0x16>
		if ((conn->llcp_ack != conn->llcp_req) &&
   12700:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
   12704:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   12708:	4293      	cmp	r3, r2
   1270a:	f43f af62 	beq.w	125d2 <ull_conn_rx+0x16>
   1270e:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
   12712:	2b03      	cmp	r3, #3
   12714:	f47f af5d 	bne.w	125d2 <ull_conn_rx+0x16>
	conn->llcp_enc.pause_rx = 0U;
   12718:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
	conn->llcp_ack = conn->llcp_req;
   1271c:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
	conn->llcp_enc.pause_rx = 0U;
   12720:	f023 0303 	bic.w	r3, r3, #3
	conn->procedure_expire = 0U;
   12724:	2000      	movs	r0, #0
	conn->llcp_enc.pause_rx = 0U;
   12726:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	conn->procedure_expire = 0U;
   1272a:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
   1272e:	230d      	movs	r3, #13
   12730:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
	pdu_rx->llctrl.reject_ind.error_code = rej_ext_ind->error_code;
   12734:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   12738:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
	if (err) {
   1273c:	e1d5      	b.n	12aea <ull_conn_rx+0x52e>
		if (!conn->lll.role ||
   1273e:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   12742:	2b00      	cmp	r3, #0
   12744:	f281 814b 	bge.w	139de <ull_conn_rx+0x1422>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND,
   12748:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1274c:	2000      	movs	r0, #0
   1274e:	f7ff fb25 	bl	11d9c <pdu_len_cmp>
		if (!conn->lll.role ||
   12752:	2800      	cmp	r0, #0
   12754:	f001 8143 	beq.w	139de <ull_conn_rx+0x1422>
	instant = sys_le16_to_cpu(pdu->llctrl.conn_update_ind.instant);
   12758:	f8b5 202d 	ldrh.w	r2, [r5, #45]	; 0x2d
	if (((instant - conn->lll.event_counter) & 0xFFFF) > 0x7FFF) {
   1275c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   1275e:	1ad3      	subs	r3, r2, r3
   12760:	041f      	lsls	r7, r3, #16
   12762:	d505      	bpl.n	12770 <ull_conn_rx+0x1b4>
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   12764:	2303      	movs	r3, #3
   12766:	712b      	strb	r3, [r5, #4]
		return BT_HCI_ERR_INSTANT_PASSED;
   12768:	2328      	movs	r3, #40	; 0x28
			goto ull_conn_rx_unknown_rsp_send;
		}

		err = phy_upd_ind_recv(conn, link, rx, pdu_rx);
		if (err) {
			conn->llcp_terminate.reason_peer = err;
   1276a:	f884 312b 	strb.w	r3, [r4, #299]	; 0x12b
   1276e:	e0d9      	b.n	12924 <ull_conn_rx+0x368>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   12770:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   12774:	f894 10e9 	ldrb.w	r1, [r4, #233]	; 0xe9
   12778:	1a5b      	subs	r3, r3, r1
   1277a:	f003 0303 	and.w	r3, r3, #3
   1277e:	2b02      	cmp	r3, #2
   12780:	d103      	bne.n	1278a <ull_conn_rx+0x1ce>
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   12782:	2303      	movs	r3, #3
   12784:	712b      	strb	r3, [r5, #4]
		return BT_HCI_ERR_DIFF_TRANS_COLLISION;
   12786:	232a      	movs	r3, #42	; 0x2a
   12788:	e7ef      	b.n	1276a <ull_conn_rx+0x1ae>
	if (!conn_upd_curr) {
   1278a:	4b8b      	ldr	r3, [pc, #556]	; (129b8 <ull_conn_rx+0x3fc>)
   1278c:	6819      	ldr	r1, [r3, #0]
   1278e:	b901      	cbnz	r1, 12792 <ull_conn_rx+0x1d6>
		conn_upd_curr = conn;
   12790:	601c      	str	r4, [r3, #0]
	conn->llcp_cu.win_size = pdu->llctrl.conn_update_ind.win_size;
   12792:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   12796:	f884 3114 	strb.w	r3, [r4, #276]	; 0x114
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.win_offset) * 1250;
   1279a:	f8b5 1025 	ldrh.w	r1, [r5, #37]	; 0x25
   1279e:	f240 43e2 	movw	r3, #1250	; 0x4e2
   127a2:	434b      	muls	r3, r1
	conn->llcp_cu.win_offset_us =
   127a4:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.interval);
   127a8:	f895 1028 	ldrb.w	r1, [r5, #40]	; 0x28
   127ac:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
   127b0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	conn->llcp_cu.interval =
   127b4:	f8a4 3108 	strh.w	r3, [r4, #264]	; 0x108
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.latency);
   127b8:	f895 102a 	ldrb.w	r1, [r5, #42]	; 0x2a
   127bc:	f895 3029 	ldrb.w	r3, [r5, #41]	; 0x29
   127c0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	conn->llcp_cu.latency =
   127c4:	f8a4 310a 	strh.w	r3, [r4, #266]	; 0x10a
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.timeout);
   127c8:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
   127cc:	f895 102c 	ldrb.w	r1, [r5, #44]	; 0x2c
	conn->llcp.conn_upd.instant = instant;
   127d0:	f8a4 20ec 	strh.w	r2, [r4, #236]	; 0xec
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.timeout);
   127d4:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	conn->llcp_cu.timeout =
   127d8:	f8a4 310c 	strh.w	r3, [r4, #268]	; 0x10c
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
   127dc:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
   127e0:	f023 0307 	bic.w	r3, r3, #7
   127e4:	f043 0304 	orr.w	r3, r3, #4
   127e8:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
	conn->llcp_cu.ack--;
   127ec:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
   127f0:	3b01      	subs	r3, #1
   127f2:	f884 3105 	strb.w	r3, [r4, #261]	; 0x105
	link->mem = conn->llcp_rx;
   127f6:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
   127fa:	f8c8 3004 	str.w	r3, [r8, #4]
	(*rx)->hdr.link = link;
   127fe:	6833      	ldr	r3, [r6, #0]
   12800:	f8c3 8000 	str.w	r8, [r3]
	conn->llcp_rx = *rx;
   12804:	6833      	ldr	r3, [r6, #0]
   12806:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
	*rx = NULL;
   1280a:	2300      	movs	r3, #0
   1280c:	6033      	str	r3, [r6, #0]
	if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
   1280e:	f894 2170 	ldrb.w	r2, [r4, #368]	; 0x170
   12812:	f894 3171 	ldrb.w	r3, [r4, #369]	; 0x171
   12816:	4293      	cmp	r3, r2
   12818:	d007      	beq.n	1282a <ull_conn_rx+0x26e>
	    (conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT)) {
   1281a:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
	if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
   1281e:	f003 0307 	and.w	r3, r3, #7
   12822:	2b04      	cmp	r3, #4
   12824:	d101      	bne.n	1282a <ull_conn_rx+0x26e>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   12826:	f884 2171 	strb.w	r2, [r4, #369]	; 0x171
		conn->procedure_expire = 0U;
   1282a:	2000      	movs	r0, #0
   1282c:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
		break;
   12830:	e15b      	b.n	12aea <ull_conn_rx+0x52e>
		if (!conn->lll.role ||
   12832:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   12836:	2b00      	cmp	r3, #0
   12838:	f281 80d1 	bge.w	139de <ull_conn_rx+0x1422>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CHAN_MAP_IND,
   1283c:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   12840:	2001      	movs	r0, #1
   12842:	f7ff faab 	bl	11d9c <pdu_len_cmp>
		if (!conn->lll.role ||
   12846:	2800      	cmp	r0, #0
   12848:	f001 80c9 	beq.w	139de <ull_conn_rx+0x1422>
	instant = sys_le16_to_cpu(pdu->llctrl.chan_map_ind.instant);
   1284c:	f8b5 6029 	ldrh.w	r6, [r5, #41]	; 0x29
	if (((instant - conn->lll.event_counter) & 0xffff) > 0x7fff) {
   12850:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   12852:	1af3      	subs	r3, r6, r3
   12854:	0418      	lsls	r0, r3, #16
   12856:	d485      	bmi.n	12764 <ull_conn_rx+0x1a8>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   12858:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   1285c:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
   12860:	1a9b      	subs	r3, r3, r2
   12862:	f003 0303 	and.w	r3, r3, #3
   12866:	2b02      	cmp	r3, #2
   12868:	d08b      	beq.n	12782 <ull_conn_rx+0x1c6>
	memcpy(&conn->llcp.chan_map.chm[0], &pdu->llctrl.chan_map_ind.chm[0],
   1286a:	2205      	movs	r2, #5
   1286c:	f105 0124 	add.w	r1, r5, #36	; 0x24
   12870:	f104 00ed 	add.w	r0, r4, #237	; 0xed
   12874:	f008 fbc1 	bl	1affa <memcpy>
	conn->llcp.chan_map.initiate = 0U;
   12878:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
	conn->llcp.chan_map.instant = instant;
   1287c:	f8a4 60f2 	strh.w	r6, [r4, #242]	; 0xf2
	conn->llcp.chan_map.initiate = 0U;
   12880:	f36f 0300 	bfc	r3, #0, #1
   12884:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
	conn->llcp_type = LLCP_CHAN_MAP;
   12888:	2302      	movs	r3, #2
   1288a:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
	conn->llcp_ack -= 2U;
   1288e:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   12892:	3b02      	subs	r3, #2
   12894:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   12898:	e69b      	b.n	125d2 <ull_conn_rx+0x16>
		if (!conn->lll.role ||
   1289a:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   1289e:	2b00      	cmp	r3, #0
   128a0:	f281 809d 	bge.w	139de <ull_conn_rx+0x1422>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_ENC_REQ, pdu_rx->len)) {
   128a4:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   128a8:	2003      	movs	r0, #3
   128aa:	f7ff fa77 	bl	11d9c <pdu_len_cmp>
		if (!conn->lll.role ||
   128ae:	2800      	cmp	r0, #0
   128b0:	f001 8095 	beq.w	139de <ull_conn_rx+0x1422>
		memcpy(&conn->llcp_enc.rand[0],
   128b4:	2208      	movs	r2, #8
   128b6:	f105 0124 	add.w	r1, r5, #36	; 0x24
   128ba:	f204 1055 	addw	r0, r4, #341	; 0x155
   128be:	f008 fb9c 	bl	1affa <memcpy>
		conn->llcp_enc.ediv[0] = pdu_rx->llctrl.enc_req.ediv[0];
   128c2:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
   128c6:	f884 3153 	strb.w	r3, [r4, #339]	; 0x153
		conn->llcp_enc.ediv[1] = pdu_rx->llctrl.enc_req.ediv[1];
   128ca:	f895 302d 	ldrb.w	r3, [r5, #45]	; 0x2d
   128ce:	f884 3154 	strb.w	r3, [r4, #340]	; 0x154
		conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
   128d2:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   128d6:	2201      	movs	r2, #1
   128d8:	f362 0301 	bfi	r3, r2, #0, #2
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   128dc:	6832      	ldr	r2, [r6, #0]
		conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
   128de:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   128e2:	2303      	movs	r3, #3
   128e4:	7113      	strb	r3, [r2, #4]
		conn->llcp_type = LLCP_ENCRYPTION;
   128e6:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
		conn->llcp_ack -= 2U;
   128ea:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   128ee:	3b02      	subs	r3, #2
   128f0:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		memcpy(&conn->llcp.encryption.skd[0],
   128f4:	2208      	movs	r2, #8
   128f6:	f105 012e 	add.w	r1, r5, #46	; 0x2e
   128fa:	f104 00ee 	add.w	r0, r4, #238	; 0xee
   128fe:	f008 fb7c 	bl	1affa <memcpy>
		memcpy(&conn->lll.ccm_rx.iv[0],
   12902:	2204      	movs	r2, #4
   12904:	f105 0136 	add.w	r1, r5, #54	; 0x36
   12908:	f104 0098 	add.w	r0, r4, #152	; 0x98
   1290c:	f008 fb75 	bl	1affa <memcpy>
		conn->llcp_enc.pause_rx = 1U;
   12910:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   12914:	f043 0301 	orr.w	r3, r3, #1
   12918:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		conn->procedure_expire = conn->procedure_reload;
   1291c:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
   12920:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	return 0;
   12924:	2000      	movs	r0, #0
		break;
   12926:	e0e0      	b.n	12aea <ull_conn_rx+0x52e>
		if (conn->lll.role ||
   12928:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   1292c:	2b00      	cmp	r3, #0
   1292e:	f2c1 8056 	blt.w	139de <ull_conn_rx+0x1422>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_ENC_RSP, pdu_rx->len)) {
   12932:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   12936:	2004      	movs	r0, #4
   12938:	f7ff fa30 	bl	11d9c <pdu_len_cmp>
		if (conn->lll.role ||
   1293c:	2800      	cmp	r0, #0
   1293e:	f001 804e 	beq.w	139de <ull_conn_rx+0x1422>
		memcpy(&conn->llcp.encryption.skd[8],
   12942:	2208      	movs	r2, #8
   12944:	f105 0124 	add.w	r1, r5, #36	; 0x24
   12948:	f104 00f6 	add.w	r0, r4, #246	; 0xf6
   1294c:	f008 fb55 	bl	1affa <memcpy>
		memcpy(&conn->lll.ccm_rx.iv[4],
   12950:	2204      	movs	r2, #4
   12952:	f105 012c 	add.w	r1, r5, #44	; 0x2c
   12956:	f104 009c 	add.w	r0, r4, #156	; 0x9c
   1295a:	f008 fb4e 	bl	1affa <memcpy>
		conn->llcp_enc.pause_rx = 1U;
   1295e:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   12962:	f043 0301 	orr.w	r3, r3, #1
   12966:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1296a:	6833      	ldr	r3, [r6, #0]
   1296c:	2203      	movs	r2, #3
   1296e:	711a      	strb	r2, [r3, #4]
   12970:	e7d8      	b.n	12924 <ull_conn_rx+0x368>
		if (conn->lll.role || (conn->llcp_req == conn->llcp_ack) ||
   12972:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   12976:	2b00      	cmp	r3, #0
   12978:	f2c1 8031 	blt.w	139de <ull_conn_rx+0x1422>
   1297c:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
   12980:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   12984:	429a      	cmp	r2, r3
   12986:	f001 802a 	beq.w	139de <ull_conn_rx+0x1422>
   1298a:	f894 60ea 	ldrb.w	r6, [r4, #234]	; 0xea
   1298e:	2e03      	cmp	r6, #3
   12990:	f041 8025 	bne.w	139de <ull_conn_rx+0x1422>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_START_ENC_REQ,
   12994:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   12998:	2005      	movs	r0, #5
   1299a:	f7ff f9ff 	bl	11d9c <pdu_len_cmp>
		    (conn->llcp_type != LLCP_ENCRYPTION) ||
   1299e:	2800      	cmp	r0, #0
   129a0:	f001 801d 	beq.w	139de <ull_conn_rx+0x1422>
		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   129a4:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   129a8:	f36f 0301 	bfc	r3, #0, #2
   129ac:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   129b0:	712e      	strb	r6, [r5, #4]
	return 0;
   129b2:	e7b7      	b.n	12924 <ull_conn_rx+0x368>
   129b4:	00022060 	.word	0x00022060
   129b8:	20001354 	.word	0x20001354
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_START_ENC_RSP,
   129bc:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   129c0:	2006      	movs	r0, #6
   129c2:	f7ff f9eb 	bl	11d9c <pdu_len_cmp>
   129c6:	2800      	cmp	r0, #0
   129c8:	f001 8009 	beq.w	139de <ull_conn_rx+0x1422>
		if (conn->lll.role) {
   129cc:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   129d0:	2b00      	cmp	r3, #0
   129d2:	da25      	bge.n	12a20 <ull_conn_rx+0x464>
			if ((conn->llcp_req != conn->llcp_ack) &&
   129d4:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   129d8:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
   129dc:	4293      	cmp	r3, r2
   129de:	d004      	beq.n	129ea <ull_conn_rx+0x42e>
   129e0:	f894 10ea 	ldrb.w	r1, [r4, #234]	; 0xea
   129e4:	2903      	cmp	r1, #3
   129e6:	f040 87fa 	bne.w	139de <ull_conn_rx+0x1422>
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   129ea:	f894 10ec 	ldrb.w	r1, [r4, #236]	; 0xec
			if (conn->llcp_req == conn->llcp_ack) {
   129ee:	4293      	cmp	r3, r2
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   129f0:	f36f 0101 	bfc	r1, #0, #2
   129f4:	f884 10ec 	strb.w	r1, [r4, #236]	; 0xec
			if (conn->llcp_req == conn->llcp_ack) {
   129f8:	d105      	bne.n	12a06 <ull_conn_rx+0x44a>
				conn->llcp_type = LLCP_ENCRYPTION;
   129fa:	2203      	movs	r2, #3
				conn->llcp_ack -= 2U;
   129fc:	3b02      	subs	r3, #2
				conn->llcp_type = LLCP_ENCRYPTION;
   129fe:	f884 20ea 	strb.w	r2, [r4, #234]	; 0xea
				conn->llcp_ack -= 2U;
   12a02:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		if (conn->llcp_enc.refresh) {
   12a06:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   12a0a:	0759      	lsls	r1, r3, #29
   12a0c:	f57f af0d 	bpl.w	1282a <ull_conn_rx+0x26e>
			conn->llcp_enc.refresh = 0U;
   12a10:	f36f 0382 	bfc	r3, #2, #1
   12a14:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
			(*rx)->hdr.type = NODE_RX_TYPE_ENC_REFRESH;
   12a18:	6833      	ldr	r3, [r6, #0]
   12a1a:	220b      	movs	r2, #11
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   12a1c:	711a      	strb	r2, [r3, #4]
   12a1e:	e704      	b.n	1282a <ull_conn_rx+0x26e>
			conn->llcp_enc.pause_rx = 0U;
   12a20:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   12a24:	f023 0303 	bic.w	r3, r3, #3
   12a28:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
   12a2c:	e7eb      	b.n	12a06 <ull_conn_rx+0x44a>
		if (!conn->lll.role ||
   12a2e:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   12a32:	2b00      	cmp	r3, #0
   12a34:	f280 87d3 	bge.w	139de <ull_conn_rx+0x1422>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_FEATURE_REQ,
   12a38:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   12a3c:	2008      	movs	r0, #8
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_SLAVE_FEATURE_REQ,
   12a3e:	f7ff f9ad 	bl	11d9c <pdu_len_cmp>
		if (conn->lll.role ||
   12a42:	2800      	cmp	r0, #0
   12a44:	f000 87cb 	beq.w	139de <ull_conn_rx+0x1422>
		nack = feature_rsp_send(conn, *rx, pdu_rx);
   12a48:	4652      	mov	r2, sl
   12a4a:	1d29      	adds	r1, r5, #4
   12a4c:	4620      	mov	r0, r4
}
   12a4e:	b003      	add	sp, #12
   12a50:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		nack = feature_rsp_send(conn, *rx, pdu_rx);
   12a54:	f7ff bbdc 	b.w	12210 <feature_rsp_send.isra.15>
		if (conn->lll.role ||
   12a58:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   12a5c:	2b00      	cmp	r3, #0
   12a5e:	f2c0 87be 	blt.w	139de <ull_conn_rx+0x1422>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_SLAVE_FEATURE_REQ,
   12a62:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   12a66:	200e      	movs	r0, #14
   12a68:	e7e9      	b.n	12a3e <ull_conn_rx+0x482>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_FEATURE_RSP,
   12a6a:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   12a6e:	2009      	movs	r0, #9
   12a70:	f7ff f994 	bl	11d9c <pdu_len_cmp>
   12a74:	2800      	cmp	r0, #0
   12a76:	f000 87b2 	beq.w	139de <ull_conn_rx+0x1422>
	       (features[1] << 8) | (features[2] << 16);
   12a7a:	f895 3026 	ldrb.w	r3, [r5, #38]	; 0x26
   12a7e:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   12a82:	041b      	lsls	r3, r3, #16
   12a84:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	feat = ~LL_FEAT_BIT_MASK_VALID | features[0] |
   12a88:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
	       (features[1] << 8) | (features[2] << 16);
   12a8c:	4313      	orrs	r3, r2
   12a8e:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
   12a92:	f443 037e 	orr.w	r3, r3, #16646144	; 0xfe0000
	conn->llcp_feature.features &= feat_get(&rsp->features[0]);
   12a96:	f8d4 211c 	ldr.w	r2, [r4, #284]	; 0x11c
	       (features[1] << 8) | (features[2] << 16);
   12a9a:	f443 5343 	orr.w	r3, r3, #12480	; 0x30c0
   12a9e:	f043 0310 	orr.w	r3, r3, #16
	conn->llcp_feature.features &= feat_get(&rsp->features[0]);
   12aa2:	4013      	ands	r3, r2
   12aa4:	f3c3 0310 	ubfx	r3, r3, #0, #17
   12aa8:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
	conn->common.fex_valid = 1U;
   12aac:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
   12ab0:	f043 0301 	orr.w	r3, r3, #1
   12ab4:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
	conn->llcp_feature.ack = conn->llcp_feature.req;
   12ab8:	f894 3118 	ldrb.w	r3, [r4, #280]	; 0x118
   12abc:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
	conn->procedure_expire = 0U;
   12ac0:	e6b3      	b.n	1282a <ull_conn_rx+0x26e>
		if (!conn->lll.role ||
   12ac2:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   12ac6:	2b00      	cmp	r3, #0
   12ac8:	f280 8789 	bge.w	139de <ull_conn_rx+0x1422>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_REQ,
   12acc:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   12ad0:	200a      	movs	r0, #10
   12ad2:	f7ff f963 	bl	11d9c <pdu_len_cmp>
		if (!conn->lll.role ||
   12ad6:	2800      	cmp	r0, #0
   12ad8:	f000 8781 	beq.w	139de <ull_conn_rx+0x1422>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   12adc:	48c3      	ldr	r0, [pc, #780]	; (12dec <ull_conn_rx+0x830>)
   12ade:	f00a f9c5 	bl	1ce6c <mem_acquire>
		if (!tx) {
   12ae2:	4601      	mov	r1, r0
   12ae4:	b920      	cbnz	r0, 12af0 <ull_conn_rx+0x534>
			return -ENOBUFS;
   12ae6:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
   12aea:	b003      	add	sp, #12
   12aec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	conn->llcp_enc.pause_rx = 1U;
   12af0:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   12af4:	f023 0305 	bic.w	r3, r3, #5
   12af8:	f043 0305 	orr.w	r3, r3, #5
   12afc:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	conn->lll.enc_rx = 0;
   12b00:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
   12b04:	f36f 03c3 	bfc	r3, #3, #1
   12b08:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   12b0c:	790b      	ldrb	r3, [r1, #4]
   12b0e:	f043 0303 	orr.w	r3, r3, #3
   12b12:	710b      	strb	r3, [r1, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
   12b14:	2301      	movs	r3, #1
   12b16:	714b      	strb	r3, [r1, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP;
   12b18:	230b      	movs	r3, #11
   12b1a:	71cb      	strb	r3, [r1, #7]
	ctrl_tx_enqueue(conn, tx);
   12b1c:	4620      	mov	r0, r4
   12b1e:	f00a fd6e 	bl	1d5fe <ctrl_tx_enqueue>
   12b22:	e556      	b.n	125d2 <ull_conn_rx+0x16>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP,
   12b24:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   12b28:	200b      	movs	r0, #11
   12b2a:	f7ff f937 	bl	11d9c <pdu_len_cmp>
   12b2e:	2800      	cmp	r0, #0
   12b30:	f000 8755 	beq.w	139de <ull_conn_rx+0x1422>
	} else if (!conn->lll.role) {
   12b34:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   12b38:	2b00      	cmp	r3, #0
   12b3a:	db10      	blt.n	12b5e <ull_conn_rx+0x5a2>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   12b3c:	48ab      	ldr	r0, [pc, #684]	; (12dec <ull_conn_rx+0x830>)
   12b3e:	f00a f995 	bl	1ce6c <mem_acquire>
		if (!tx) {
   12b42:	4601      	mov	r1, r0
   12b44:	2800      	cmp	r0, #0
   12b46:	d0ce      	beq.n	12ae6 <ull_conn_rx+0x52a>
	conn->llcp_enc.pause_rx = 1U;
   12b48:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   12b4c:	f043 0301 	orr.w	r3, r3, #1
   12b50:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	conn->lll.enc_rx = 0;
   12b54:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
   12b58:	f023 0318 	bic.w	r3, r3, #24
   12b5c:	e7d4      	b.n	12b08 <ull_conn_rx+0x54c>
		conn->lll.enc_tx = 0;
   12b5e:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
   12b62:	f36f 1304 	bfc	r3, #4, #1
   12b66:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   12b6a:	e532      	b.n	125d2 <ull_conn_rx+0x16>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_VERSION_IND,
   12b6c:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   12b70:	200c      	movs	r0, #12
   12b72:	f7ff f913 	bl	11d9c <pdu_len_cmp>
   12b76:	2800      	cmp	r0, #0
   12b78:	f000 8731 	beq.w	139de <ull_conn_rx+0x1422>
	if (!conn->llcp_version.tx) {
   12b7c:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
   12b80:	07da      	lsls	r2, r3, #31
   12b82:	d43e      	bmi.n	12c02 <ull_conn_rx+0x646>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   12b84:	4899      	ldr	r0, [pc, #612]	; (12dec <ull_conn_rx+0x830>)
   12b86:	f00a f971 	bl	1ce6c <mem_acquire>
		if (!tx) {
   12b8a:	4601      	mov	r1, r0
   12b8c:	2800      	cmp	r0, #0
   12b8e:	d0aa      	beq.n	12ae6 <ull_conn_rx+0x52a>
		conn->llcp_version.tx = 1U;
   12b90:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
   12b94:	f043 0301 	orr.w	r3, r3, #1
   12b98:	f884 3122 	strb.w	r3, [r4, #290]	; 0x122
		pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   12b9c:	7903      	ldrb	r3, [r0, #4]
   12b9e:	f043 0303 	orr.w	r3, r3, #3
   12ba2:	7103      	strb	r3, [r0, #4]
		pdu_tx->len =
   12ba4:	2306      	movs	r3, #6
   12ba6:	7143      	strb	r3, [r0, #5]
		pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
   12ba8:	230c      	movs	r3, #12
   12baa:	71c3      	strb	r3, [r0, #7]
		v->version_number = LL_VERSION_NUMBER;
   12bac:	230a      	movs	r3, #10
   12bae:	7203      	strb	r3, [r0, #8]
		v->company_id =	sys_cpu_to_le16(ll_settings_company_id());
   12bb0:	f06f 030e 	mvn.w	r3, #14
   12bb4:	7243      	strb	r3, [r0, #9]
   12bb6:	2305      	movs	r3, #5
   12bb8:	7283      	strb	r3, [r0, #10]
		v->sub_version_number =
   12bba:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12bbe:	72c3      	strb	r3, [r0, #11]
   12bc0:	7303      	strb	r3, [r0, #12]
		ctrl_tx_sec_enqueue(conn, tx);
   12bc2:	4620      	mov	r0, r4
   12bc4:	f00a fce1 	bl	1d58a <ctrl_tx_sec_enqueue>
		rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   12bc8:	2303      	movs	r3, #3
   12bca:	712b      	strb	r3, [r5, #4]
	conn->llcp_version.version_number = v->version_number;
   12bcc:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   12bd0:	f884 3123 	strb.w	r3, [r4, #291]	; 0x123
	conn->llcp_version.company_id = sys_le16_to_cpu(v->company_id);
   12bd4:	f895 2026 	ldrb.w	r2, [r5, #38]	; 0x26
   12bd8:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   12bdc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   12be0:	f8a4 3124 	strh.w	r3, [r4, #292]	; 0x124
		sys_le16_to_cpu(v->sub_version_number);
   12be4:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
   12be8:	f895 2028 	ldrb.w	r2, [r5, #40]	; 0x28
   12bec:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	conn->llcp_version.sub_version_number =
   12bf0:	f8a4 3126 	strh.w	r3, [r4, #294]	; 0x126
	conn->llcp_version.rx = 1U;
   12bf4:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
   12bf8:	f043 0302 	orr.w	r3, r3, #2
   12bfc:	f884 3122 	strb.w	r3, [r4, #290]	; 0x122
	return 0;
   12c00:	e690      	b.n	12924 <ull_conn_rx+0x368>
	} else if (!conn->llcp_version.rx) {
   12c02:	f013 0302 	ands.w	r3, r3, #2
   12c06:	f47f ace4 	bne.w	125d2 <ull_conn_rx+0x16>
		conn->llcp_version.ack = conn->llcp_version.req;
   12c0a:	f894 2120 	ldrb.w	r2, [r4, #288]	; 0x120
   12c0e:	f884 2121 	strb.w	r2, [r4, #289]	; 0x121
		conn->procedure_expire = 0U;
   12c12:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
   12c16:	e7d9      	b.n	12bcc <ull_conn_rx+0x610>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_REJECT_IND, pdu_rx->len)) {
   12c18:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   12c1c:	200d      	movs	r0, #13
   12c1e:	f7ff f8bd 	bl	11d9c <pdu_len_cmp>
   12c22:	2800      	cmp	r0, #0
   12c24:	f000 86db 	beq.w	139de <ull_conn_rx+0x1422>
		conn->llcp_enc.pause_rx = 0U;
   12c28:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   12c2c:	f023 0303 	bic.w	r3, r3, #3
   12c30:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		conn->llcp_ack = conn->llcp_req;
   12c34:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   12c38:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		conn->procedure_expire = 0U;
   12c3c:	e5f5      	b.n	1282a <ull_conn_rx+0x26e>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ,
   12c3e:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   12c42:	200f      	movs	r0, #15
   12c44:	f7ff f8aa 	bl	11d9c <pdu_len_cmp>
   12c48:	2800      	cmp	r0, #0
   12c4a:	f000 86c8 	beq.w	139de <ull_conn_rx+0x1422>
		if (conn_upd_curr && (conn_upd_curr != conn)) {
   12c4e:	4b68      	ldr	r3, [pc, #416]	; (12df0 <ull_conn_rx+0x834>)
   12c50:	6818      	ldr	r0, [r3, #0]
   12c52:	b150      	cbz	r0, 12c6a <ull_conn_rx+0x6ae>
   12c54:	4284      	cmp	r4, r0
   12c56:	d008      	beq.n	12c6a <ull_conn_rx+0x6ae>
			nack = reject_ext_ind_send(conn, *rx,
   12c58:	2320      	movs	r3, #32
				nack = reject_ext_ind_send(conn, *rx,
   12c5a:	220f      	movs	r2, #15
				nack = reject_ext_ind_send(conn, *rx,
   12c5c:	1d29      	adds	r1, r5, #4
   12c5e:	4620      	mov	r0, r4
}
   12c60:	b003      	add	sp, #12
   12c62:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
				nack = reject_ext_ind_send(conn, *rx,
   12c66:	f7ff bb19 	b.w	1229c <reject_ext_ind_send.isra.9>
		if (!conn->lll.role) {
   12c6a:	f994 103d 	ldrsb.w	r1, [r4, #61]	; 0x3d
   12c6e:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
   12c72:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
   12c76:	2900      	cmp	r1, #0
   12c78:	f2c0 80bc 	blt.w	12df4 <ull_conn_rx+0x838>
			if ((conn->llcp_conn_param.req !=
   12c7c:	4293      	cmp	r3, r2
   12c7e:	d009      	beq.n	12c94 <ull_conn_rx+0x6d8>
			    ((conn->llcp_conn_param.state ==
   12c80:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
					conn->llcp_conn_param.ack) &&
   12c84:	f013 0307 	ands.w	r3, r3, #7
   12c88:	d002      	beq.n	12c90 <ull_conn_rx+0x6d4>
			      LLCP_CPR_STATE_REQ) ||
   12c8a:	3b04      	subs	r3, #4
   12c8c:	2b01      	cmp	r3, #1
   12c8e:	d801      	bhi.n	12c94 <ull_conn_rx+0x6d8>
				nack = reject_ext_ind_send(conn, *rx,
   12c90:	2323      	movs	r3, #35	; 0x23
   12c92:	e7e2      	b.n	12c5a <ull_conn_rx+0x69e>
			} else if (((((conn->llcp_req - conn->llcp_ack) &
   12c94:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   12c98:	f894 10e9 	ldrb.w	r1, [r4, #233]	; 0xe9
   12c9c:	1a5b      	subs	r3, r3, r1
   12c9e:	f003 0303 	and.w	r3, r3, #3
   12ca2:	2b02      	cmp	r3, #2
   12ca4:	d103      	bne.n	12cae <ull_conn_rx+0x6f2>
				      0x03) == 0x02) &&
   12ca6:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
   12caa:	2b03      	cmp	r3, #3
   12cac:	d105      	bne.n	12cba <ull_conn_rx+0x6fe>
				    (conn->llcp_type != LLCP_ENCRYPTION)) ||
   12cae:	f894 11a8 	ldrb.w	r1, [r4, #424]	; 0x1a8
   12cb2:	f894 31a9 	ldrb.w	r3, [r4, #425]	; 0x1a9
   12cb6:	4299      	cmp	r1, r3
   12cb8:	d001      	beq.n	12cbe <ull_conn_rx+0x702>
				nack = reject_ext_ind_send(conn, *rx,
   12cba:	232a      	movs	r3, #42	; 0x2a
   12cbc:	e7cd      	b.n	12c5a <ull_conn_rx+0x69e>
				u16_t interval_min =
   12cbe:	f8b5 a024 	ldrh.w	sl, [r5, #36]	; 0x24
   12cc2:	fa1f f38a 	uxth.w	r3, sl
				if ((interval_min < 6) ||
   12cc6:	2b05      	cmp	r3, #5
   12cc8:	d925      	bls.n	12d16 <ull_conn_rx+0x75a>
				u16_t interval_max =
   12cca:	f8b5 9026 	ldrh.w	r9, [r5, #38]	; 0x26
   12cce:	fa1f f189 	uxth.w	r1, r9
				if ((interval_min < 6) ||
   12cd2:	f5b1 6f48 	cmp.w	r1, #3200	; 0xc80
   12cd6:	d81e      	bhi.n	12d16 <ull_conn_rx+0x75a>
				    (interval_max > 3200) ||
   12cd8:	428b      	cmp	r3, r1
   12cda:	d81c      	bhi.n	12d16 <ull_conn_rx+0x75a>
				u16_t latency =
   12cdc:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
   12cde:	f8ad 3000 	strh.w	r3, [sp]
   12ce2:	fa1f fc83 	uxth.w	ip, r3
				    (interval_min > interval_max) ||
   12ce6:	f5bc 7ffa 	cmp.w	ip, #500	; 0x1f4
   12cea:	d214      	bcs.n	12d16 <ull_conn_rx+0x75a>
				u16_t timeout =
   12cec:	f8b5 b02a 	ldrh.w	fp, [r5, #42]	; 0x2a
   12cf0:	fa1f f38b 	uxth.w	r3, fp
				    (latency > 499) ||
   12cf4:	f1a3 0e0a 	sub.w	lr, r3, #10
   12cf8:	fa1f fe8e 	uxth.w	lr, lr
   12cfc:	f640 4876 	movw	r8, #3190	; 0xc76
   12d00:	45c6      	cmp	lr, r8
   12d02:	d808      	bhi.n	12d16 <ull_conn_rx+0x75a>
				     ((latency + 1) * interval_max)) ||
   12d04:	fb0c 1e01 	mla	lr, ip, r1, r1
				    (timeout > 3200) ||
   12d08:	ebbe 0f83 	cmp.w	lr, r3, lsl #2
   12d0c:	d203      	bcs.n	12d16 <ull_conn_rx+0x75a>
					cpr->preferred_periodicity;
   12d0e:	f895 e02c 	ldrb.w	lr, [r5, #44]	; 0x2c
				     ((latency + 1) * interval_max)) ||
   12d12:	4571      	cmp	r1, lr
   12d14:	d201      	bcs.n	12d1a <ull_conn_rx+0x75e>
				nack = reject_ext_ind_send(conn, *rx,
   12d16:	231e      	movs	r3, #30
   12d18:	e79f      	b.n	12c5a <ull_conn_rx+0x69e>
				conn->llcp_conn_param.latency =	latency;
   12d1a:	f8bd 8000 	ldrh.w	r8, [sp]
				conn->llcp_conn_param.interval_min =
   12d1e:	f8a4 a174 	strh.w	sl, [r4, #372]	; 0x174
				conn->llcp_conn_param.interval_max =
   12d22:	f8a4 9176 	strh.w	r9, [r4, #374]	; 0x176
				conn->llcp_conn_param.latency =	latency;
   12d26:	f8a4 8178 	strh.w	r8, [r4, #376]	; 0x178
				conn->llcp_conn_param.timeout =	timeout;
   12d2a:	f8a4 b17a 	strh.w	fp, [r4, #378]	; 0x17a
				conn->llcp_conn_param.preferred_periodicity =
   12d2e:	f884 e17c 	strb.w	lr, [r4, #380]	; 0x17c
					sys_le16_to_cpu(cpr->reference_conn_event_count);
   12d32:	f895 802e 	ldrb.w	r8, [r5, #46]	; 0x2e
   12d36:	f895 e02d 	ldrb.w	lr, [r5, #45]	; 0x2d
   12d3a:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.reference_conn_event_count =
   12d3e:	f8a4 e17e 	strh.w	lr, [r4, #382]	; 0x17e
					sys_le16_to_cpu(cpr->offset0);
   12d42:	f895 8030 	ldrb.w	r8, [r5, #48]	; 0x30
   12d46:	f895 e02f 	ldrb.w	lr, [r5, #47]	; 0x2f
   12d4a:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.offset0 =
   12d4e:	f8a4 e180 	strh.w	lr, [r4, #384]	; 0x180
					sys_le16_to_cpu(cpr->offset1);
   12d52:	f895 8032 	ldrb.w	r8, [r5, #50]	; 0x32
   12d56:	f895 e031 	ldrb.w	lr, [r5, #49]	; 0x31
   12d5a:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.offset1 =
   12d5e:	f8a4 e182 	strh.w	lr, [r4, #386]	; 0x182
					sys_le16_to_cpu(cpr->offset2);
   12d62:	f895 8034 	ldrb.w	r8, [r5, #52]	; 0x34
   12d66:	f895 e033 	ldrb.w	lr, [r5, #51]	; 0x33
   12d6a:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.offset2 =
   12d6e:	f8a4 e184 	strh.w	lr, [r4, #388]	; 0x184
					sys_le16_to_cpu(cpr->offset3);
   12d72:	f895 8036 	ldrb.w	r8, [r5, #54]	; 0x36
   12d76:	f895 e035 	ldrb.w	lr, [r5, #53]	; 0x35
   12d7a:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.offset3 =
   12d7e:	f8a4 e186 	strh.w	lr, [r4, #390]	; 0x186
					sys_le16_to_cpu(cpr->offset4);
   12d82:	f895 e037 	ldrb.w	lr, [r5, #55]	; 0x37
   12d86:	f895 8038 	ldrb.w	r8, [r5, #56]	; 0x38
   12d8a:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.offset4 =
   12d8e:	f8a4 e188 	strh.w	lr, [r4, #392]	; 0x188
					sys_le16_to_cpu(cpr->offset5);
   12d92:	f895 e039 	ldrb.w	lr, [r5, #57]	; 0x39
   12d96:	f895 503a 	ldrb.w	r5, [r5, #58]	; 0x3a
   12d9a:	ea4e 2505 	orr.w	r5, lr, r5, lsl #8
				conn->llcp_conn_param.offset5 =
   12d9e:	f8a4 518a 	strh.w	r5, [r4, #394]	; 0x18a
				     lll->interval) ||
   12da2:	8de5      	ldrh	r5, [r4, #46]	; 0x2e
				if ((conn->llcp_conn_param.interval_max !=
   12da4:	42a9      	cmp	r1, r5
   12da6:	d112      	bne.n	12dce <ull_conn_rx+0x812>
				     lll->interval) ||
   12da8:	8e21      	ldrh	r1, [r4, #48]	; 0x30
   12daa:	4561      	cmp	r1, ip
   12dac:	d10f      	bne.n	12dce <ull_conn_rx+0x812>
				    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
   12dae:	f240 41e2 	movw	r1, #1250	; 0x4e2
   12db2:	4369      	muls	r1, r5
   12db4:	f242 7510 	movw	r5, #10000	; 0x2710
   12db8:	fb05 1303 	mla	r3, r5, r3, r1
   12dbc:	3b01      	subs	r3, #1
   12dbe:	fbb3 f3f1 	udiv	r3, r3, r1
				     lll->latency) ||
   12dc2:	f8b4 10c6 	ldrh.w	r1, [r4, #198]	; 0xc6
   12dc6:	b29b      	uxth	r3, r3
   12dc8:	4299      	cmp	r1, r3
   12dca:	f000 80b2 	beq.w	12f32 <ull_conn_rx+0x976>
					if (conn->llcp_enc.pause_tx) {
   12dce:	f017 0f02 	tst.w	r7, #2
   12dd2:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   12dd6:	f000 809e 	beq.w	12f16 <ull_conn_rx+0x95a>
						conn->llcp_conn_param.state =
   12dda:	2102      	movs	r1, #2
   12ddc:	f361 0302 	bfi	r3, r1, #0, #3
   12de0:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   12de4:	6833      	ldr	r3, [r6, #0]
   12de6:	2103      	movs	r1, #3
   12de8:	7119      	strb	r1, [r3, #4]
   12dea:	e099      	b.n	12f20 <ull_conn_rx+0x964>
   12dec:	200013d4 	.word	0x200013d4
   12df0:	20001354 	.word	0x20001354
		} else if ((conn->llcp_conn_param.req ==
   12df4:	4293      	cmp	r3, r2
   12df6:	d004      	beq.n	12e02 <ull_conn_rx+0x846>
			    conn->llcp_conn_param.ack) ||
   12df8:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   12dfc:	079f      	lsls	r7, r3, #30
   12dfe:	f040 80a1 	bne.w	12f44 <ull_conn_rx+0x988>
			u16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
   12e02:	f8b5 a024 	ldrh.w	sl, [r5, #36]	; 0x24
   12e06:	fa1f f38a 	uxth.w	r3, sl
			if ((interval_min < 6) ||
   12e0a:	2b05      	cmp	r3, #5
   12e0c:	d983      	bls.n	12d16 <ull_conn_rx+0x75a>
			u16_t interval_max = sys_le16_to_cpu(cpr->interval_max);
   12e0e:	f8b5 9026 	ldrh.w	r9, [r5, #38]	; 0x26
   12e12:	fa1f f189 	uxth.w	r1, r9
			if ((interval_min < 6) ||
   12e16:	f5b1 6f48 	cmp.w	r1, #3200	; 0xc80
   12e1a:	f63f af7c 	bhi.w	12d16 <ull_conn_rx+0x75a>
			    (interval_max > 3200) ||
   12e1e:	428b      	cmp	r3, r1
   12e20:	f63f af79 	bhi.w	12d16 <ull_conn_rx+0x75a>
			u16_t latency = sys_le16_to_cpu(cpr->latency);
   12e24:	f8b5 8028 	ldrh.w	r8, [r5, #40]	; 0x28
   12e28:	fa1f f788 	uxth.w	r7, r8
			    (interval_min > interval_max) ||
   12e2c:	f5b7 7ffa 	cmp.w	r7, #500	; 0x1f4
   12e30:	f4bf af71 	bcs.w	12d16 <ull_conn_rx+0x75a>
			u16_t timeout = sys_le16_to_cpu(cpr->timeout);
   12e34:	f8b5 e02a 	ldrh.w	lr, [r5, #42]	; 0x2a
   12e38:	fa1f f38e 	uxth.w	r3, lr
			    (latency > 499) ||
   12e3c:	f1a3 0c0a 	sub.w	ip, r3, #10
   12e40:	fa1f fc8c 	uxth.w	ip, ip
   12e44:	f640 4b76 	movw	fp, #3190	; 0xc76
   12e48:	45dc      	cmp	ip, fp
   12e4a:	f63f af64 	bhi.w	12d16 <ull_conn_rx+0x75a>
			     ((latency + 1) * interval_max)) ||
   12e4e:	fb07 1c01 	mla	ip, r7, r1, r1
			    (timeout < 10) || (timeout > 3200) ||
   12e52:	ebbc 0f83 	cmp.w	ip, r3, lsl #2
   12e56:	f4bf af5e 	bcs.w	12d16 <ull_conn_rx+0x75a>
				cpr->preferred_periodicity;
   12e5a:	f895 c02c 	ldrb.w	ip, [r5, #44]	; 0x2c
			     ((latency + 1) * interval_max)) ||
   12e5e:	4561      	cmp	r1, ip
   12e60:	f4ff af59 	bcc.w	12d16 <ull_conn_rx+0x75a>
			conn->llcp_conn_param.interval_min = interval_min;
   12e64:	f8a4 a174 	strh.w	sl, [r4, #372]	; 0x174
			conn->llcp_conn_param.interval_max = interval_max;
   12e68:	f8a4 9176 	strh.w	r9, [r4, #374]	; 0x176
			conn->llcp_conn_param.latency =	latency;
   12e6c:	f8a4 8178 	strh.w	r8, [r4, #376]	; 0x178
			conn->llcp_conn_param.timeout =	timeout;
   12e70:	f8a4 e17a 	strh.w	lr, [r4, #378]	; 0x17a
			conn->llcp_conn_param.preferred_periodicity =
   12e74:	f884 c17c 	strb.w	ip, [r4, #380]	; 0x17c
				sys_le16_to_cpu(cpr->reference_conn_event_count);
   12e78:	f895 e02e 	ldrb.w	lr, [r5, #46]	; 0x2e
   12e7c:	f895 c02d 	ldrb.w	ip, [r5, #45]	; 0x2d
   12e80:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.reference_conn_event_count =
   12e84:	f8a4 c17e 	strh.w	ip, [r4, #382]	; 0x17e
				sys_le16_to_cpu(cpr->offset0);
   12e88:	f895 e030 	ldrb.w	lr, [r5, #48]	; 0x30
   12e8c:	f895 c02f 	ldrb.w	ip, [r5, #47]	; 0x2f
   12e90:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.offset0 =
   12e94:	f8a4 c180 	strh.w	ip, [r4, #384]	; 0x180
				sys_le16_to_cpu(cpr->offset1);
   12e98:	f895 e032 	ldrb.w	lr, [r5, #50]	; 0x32
   12e9c:	f895 c031 	ldrb.w	ip, [r5, #49]	; 0x31
   12ea0:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.offset1 =
   12ea4:	f8a4 c182 	strh.w	ip, [r4, #386]	; 0x182
				sys_le16_to_cpu(cpr->offset2);
   12ea8:	f895 e034 	ldrb.w	lr, [r5, #52]	; 0x34
   12eac:	f895 c033 	ldrb.w	ip, [r5, #51]	; 0x33
   12eb0:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.offset2 =
   12eb4:	f8a4 c184 	strh.w	ip, [r4, #388]	; 0x184
				sys_le16_to_cpu(cpr->offset3);
   12eb8:	f895 e036 	ldrb.w	lr, [r5, #54]	; 0x36
   12ebc:	f895 c035 	ldrb.w	ip, [r5, #53]	; 0x35
   12ec0:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.offset3 =
   12ec4:	f8a4 c186 	strh.w	ip, [r4, #390]	; 0x186
				sys_le16_to_cpu(cpr->offset4);
   12ec8:	f895 c037 	ldrb.w	ip, [r5, #55]	; 0x37
   12ecc:	f895 e038 	ldrb.w	lr, [r5, #56]	; 0x38
   12ed0:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.offset4 =
   12ed4:	f8a4 c188 	strh.w	ip, [r4, #392]	; 0x188
				sys_le16_to_cpu(cpr->offset5);
   12ed8:	f895 c039 	ldrb.w	ip, [r5, #57]	; 0x39
   12edc:	f895 503a 	ldrb.w	r5, [r5, #58]	; 0x3a
   12ee0:	ea4c 2505 	orr.w	r5, ip, r5, lsl #8
			conn->llcp_conn_param.offset5 =
   12ee4:	f8a4 518a 	strh.w	r5, [r4, #394]	; 0x18a
			     lll->interval) ||
   12ee8:	8de5      	ldrh	r5, [r4, #46]	; 0x2e
			if ((conn->llcp_conn_param.interval_max !=
   12eea:	42a9      	cmp	r1, r5
   12eec:	d111      	bne.n	12f12 <ull_conn_rx+0x956>
			     lll->interval) ||
   12eee:	8e25      	ldrh	r5, [r4, #48]	; 0x30
   12ef0:	42bd      	cmp	r5, r7
   12ef2:	d10e      	bne.n	12f12 <ull_conn_rx+0x956>
			    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
   12ef4:	f240 45e2 	movw	r5, #1250	; 0x4e2
   12ef8:	4369      	muls	r1, r5
   12efa:	f242 7510 	movw	r5, #10000	; 0x2710
   12efe:	fb05 1303 	mla	r3, r5, r3, r1
   12f02:	3b01      	subs	r3, #1
   12f04:	fbb3 f3f1 	udiv	r3, r3, r1
			    (conn->llcp_conn_param.latency != lll->latency) ||
   12f08:	f8b4 10c6 	ldrh.w	r1, [r4, #198]	; 0xc6
   12f0c:	b29b      	uxth	r3, r3
   12f0e:	4299      	cmp	r1, r3
   12f10:	d00f      	beq.n	12f32 <ull_conn_rx+0x976>
				conn->llcp_conn_param.state =
   12f12:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   12f16:	2103      	movs	r1, #3
   12f18:	f361 0302 	bfi	r3, r1, #0, #3
   12f1c:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
			conn->llcp_conn_param.ack--;
   12f20:	3a01      	subs	r2, #1
   12f22:	f884 2171 	strb.w	r2, [r4, #369]	; 0x171
			if (!conn_upd_curr) {
   12f26:	2800      	cmp	r0, #0
   12f28:	f47f acfc 	bne.w	12924 <ull_conn_rx+0x368>
				conn_upd_curr = conn;
   12f2c:	4bbe      	ldr	r3, [pc, #760]	; (13228 <ull_conn_rx+0xc6c>)
   12f2e:	601c      	str	r4, [r3, #0]
   12f30:	e5db      	b.n	12aea <ull_conn_rx+0x52e>
				conn->llcp_conn_param.state =
   12f32:	f8b4 3172 	ldrh.w	r3, [r4, #370]	; 0x172
   12f36:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   12f3a:	f043 0301 	orr.w	r3, r3, #1
   12f3e:	f8a4 3172 	strh.w	r3, [r4, #370]	; 0x172
   12f42:	e74f      	b.n	12de4 <ull_conn_rx+0x828>
			LL_ASSERT(0);
   12f44:	f241 6311 	movw	r3, #5649	; 0x1611
   12f48:	4ab8      	ldr	r2, [pc, #736]	; (1322c <ull_conn_rx+0xc70>)
   12f4a:	49b9      	ldr	r1, [pc, #740]	; (13230 <ull_conn_rx+0xc74>)
   12f4c:	48b9      	ldr	r0, [pc, #740]	; (13234 <ull_conn_rx+0xc78>)
   12f4e:	f006 fa11 	bl	19374 <printk>
   12f52:	4040      	eors	r0, r0
   12f54:	f380 8811 	msr	BASEPRI, r0
   12f58:	f04f 0003 	mov.w	r0, #3
   12f5c:	df02      	svc	2
   12f5e:	e4e1      	b.n	12924 <ull_conn_rx+0x368>
		if (conn->lll.role ||
   12f60:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   12f64:	2b00      	cmp	r3, #0
   12f66:	f2c0 853a 	blt.w	139de <ull_conn_rx+0x1422>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CONN_PARAM_RSP,
   12f6a:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   12f6e:	2010      	movs	r0, #16
   12f70:	f7fe ff14 	bl	11d9c <pdu_len_cmp>
		if (conn->lll.role ||
   12f74:	2800      	cmp	r0, #0
   12f76:	f000 8532 	beq.w	139de <ull_conn_rx+0x1422>
		if (!conn->lll.role &&
   12f7a:	f894 2170 	ldrb.w	r2, [r4, #368]	; 0x170
   12f7e:	f894 3171 	ldrb.w	r3, [r4, #369]	; 0x171
   12f82:	429a      	cmp	r2, r3
   12f84:	f43f acf1 	beq.w	1296a <ull_conn_rx+0x3ae>
		    (conn->llcp_conn_param.state ==
   12f88:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
		     conn->llcp_conn_param.ack) &&
   12f8c:	f003 0307 	and.w	r3, r3, #7
   12f90:	2b04      	cmp	r3, #4
   12f92:	f47f acea 	bne.w	1296a <ull_conn_rx+0x3ae>
			u16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
   12f96:	f8b5 e024 	ldrh.w	lr, [r5, #36]	; 0x24
   12f9a:	fa1f f28e 	uxth.w	r2, lr
			if ((interval_min < 6) ||
   12f9e:	2a05      	cmp	r2, #5
   12fa0:	d920      	bls.n	12fe4 <ull_conn_rx+0xa28>
			u16_t interval_max = sys_le16_to_cpu(cpr->interval_max);
   12fa2:	f8b5 c026 	ldrh.w	ip, [r5, #38]	; 0x26
   12fa6:	fa1f f38c 	uxth.w	r3, ip
			if ((interval_min < 6) ||
   12faa:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   12fae:	d819      	bhi.n	12fe4 <ull_conn_rx+0xa28>
			    (interval_max > 3200) ||
   12fb0:	429a      	cmp	r2, r3
   12fb2:	d817      	bhi.n	12fe4 <ull_conn_rx+0xa28>
			u16_t latency = sys_le16_to_cpu(cpr->latency);
   12fb4:	8d2f      	ldrh	r7, [r5, #40]	; 0x28
   12fb6:	b2ba      	uxth	r2, r7
			    (interval_min > interval_max) ||
   12fb8:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
   12fbc:	d212      	bcs.n	12fe4 <ull_conn_rx+0xa28>
			u16_t timeout = sys_le16_to_cpu(cpr->timeout);
   12fbe:	8d68      	ldrh	r0, [r5, #42]	; 0x2a
   12fc0:	fa1f f880 	uxth.w	r8, r0
			    (latency > 499) ||
   12fc4:	f1a8 010a 	sub.w	r1, r8, #10
   12fc8:	b289      	uxth	r1, r1
   12fca:	f640 4976 	movw	r9, #3190	; 0xc76
   12fce:	4549      	cmp	r1, r9
   12fd0:	d808      	bhi.n	12fe4 <ull_conn_rx+0xa28>
			     ((latency + 1) * interval_max)) ||
   12fd2:	fb02 3203 	mla	r2, r2, r3, r3
			    (timeout < 10) || (timeout > 3200) ||
   12fd6:	ebb2 0f88 	cmp.w	r2, r8, lsl #2
   12fda:	d203      	bcs.n	12fe4 <ull_conn_rx+0xa28>
				cpr->preferred_periodicity;
   12fdc:	f895 202c 	ldrb.w	r2, [r5, #44]	; 0x2c
			     ((latency + 1) * interval_max)) ||
   12fe0:	4293      	cmp	r3, r2
   12fe2:	d202      	bcs.n	12fea <ull_conn_rx+0xa2e>
				nack = reject_ext_ind_send(conn, *rx,
   12fe4:	231e      	movs	r3, #30
   12fe6:	2210      	movs	r2, #16
   12fe8:	e638      	b.n	12c5c <ull_conn_rx+0x6a0>
			conn->procedure_expire = 0U;
   12fea:	2300      	movs	r3, #0
   12fec:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
			conn->llcp_conn_param.interval_min = interval_min;
   12ff0:	f8a4 e174 	strh.w	lr, [r4, #372]	; 0x174
			conn->llcp_conn_param.interval_max = interval_max;
   12ff4:	f8a4 c176 	strh.w	ip, [r4, #374]	; 0x176
			conn->llcp_conn_param.latency =	latency;
   12ff8:	f8a4 7178 	strh.w	r7, [r4, #376]	; 0x178
			conn->llcp_conn_param.timeout =	timeout;
   12ffc:	f8a4 017a 	strh.w	r0, [r4, #378]	; 0x17a
			conn->llcp_conn_param.preferred_periodicity =
   13000:	f884 217c 	strb.w	r2, [r4, #380]	; 0x17c
				sys_le16_to_cpu(cpr->reference_conn_event_count);
   13004:	f895 202e 	ldrb.w	r2, [r5, #46]	; 0x2e
   13008:	f895 302d 	ldrb.w	r3, [r5, #45]	; 0x2d
   1300c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.reference_conn_event_count =
   13010:	f8a4 317e 	strh.w	r3, [r4, #382]	; 0x17e
				sys_le16_to_cpu(cpr->offset0);
   13014:	f895 2030 	ldrb.w	r2, [r5, #48]	; 0x30
   13018:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
   1301c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset0 =
   13020:	f8a4 3180 	strh.w	r3, [r4, #384]	; 0x180
				sys_le16_to_cpu(cpr->offset1);
   13024:	f895 2032 	ldrb.w	r2, [r5, #50]	; 0x32
   13028:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
   1302c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset1 =
   13030:	f8a4 3182 	strh.w	r3, [r4, #386]	; 0x182
				sys_le16_to_cpu(cpr->offset2);
   13034:	f895 2034 	ldrb.w	r2, [r5, #52]	; 0x34
   13038:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
   1303c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset2 =
   13040:	f8a4 3184 	strh.w	r3, [r4, #388]	; 0x184
				sys_le16_to_cpu(cpr->offset3);
   13044:	f895 2036 	ldrb.w	r2, [r5, #54]	; 0x36
   13048:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
   1304c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset3 =
   13050:	f8a4 3186 	strh.w	r3, [r4, #390]	; 0x186
				sys_le16_to_cpu(cpr->offset4);
   13054:	f895 2038 	ldrb.w	r2, [r5, #56]	; 0x38
   13058:	f895 3037 	ldrb.w	r3, [r5, #55]	; 0x37
   1305c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset4 =
   13060:	f8a4 3188 	strh.w	r3, [r4, #392]	; 0x188
				sys_le16_to_cpu(cpr->offset5);
   13064:	f895 203a 	ldrb.w	r2, [r5, #58]	; 0x3a
   13068:	f895 3039 	ldrb.w	r3, [r5, #57]	; 0x39
   1306c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset5 =
   13070:	f8a4 318a 	strh.w	r3, [r4, #394]	; 0x18a
			conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP;
   13074:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   13078:	2201      	movs	r2, #1
   1307a:	f362 0302 	bfi	r3, r2, #0, #3
   1307e:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   13082:	e472      	b.n	1296a <ull_conn_rx+0x3ae>
	switch (rej_ext_ind->reject_opcode) {
   13084:	2b14      	cmp	r3, #20
   13086:	f000 8085 	beq.w	13194 <ull_conn_rx+0xbd8>
   1308a:	2b16      	cmp	r3, #22
   1308c:	f47f aaa1 	bne.w	125d2 <ull_conn_rx+0x16>
		if (conn->llcp_phy.ack != conn->llcp_phy.req) {
   13090:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
   13094:	f894 21a9 	ldrb.w	r2, [r4, #425]	; 0x1a9
   13098:	429a      	cmp	r2, r3
   1309a:	f43f aa9a 	beq.w	125d2 <ull_conn_rx+0x16>
	if (rej_ext_ind->error_code != BT_HCI_ERR_LL_PROC_COLLISION) {
   1309e:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   130a2:	2a23      	cmp	r2, #35	; 0x23
   130a4:	d012      	beq.n	130cc <ull_conn_rx+0xb10>
		conn->llcp_phy.ack = conn->llcp_phy.req;
   130a6:	f884 31a9 	strb.w	r3, [r4, #425]	; 0x1a9
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   130aa:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
   130ae:	f3c3 0102 	ubfx	r1, r3, #0, #3
   130b2:	f361 1306 	bfi	r3, r1, #4, #3
   130b6:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
   130ba:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   130be:	f36f 0300 	bfc	r3, #0, #1
   130c2:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		conn->procedure_expire = 0U;
   130c6:	2300      	movs	r3, #0
   130c8:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	if (!conn->llcp_phy.cmd) {
   130cc:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   130d0:	0759      	lsls	r1, r3, #29
   130d2:	f57f aa7e 	bpl.w	125d2 <ull_conn_rx+0x16>
	rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
   130d6:	230e      	movs	r3, #14
   130d8:	712b      	strb	r3, [r5, #4]
	p->status = rej_ext_ind->error_code;
   130da:	f885 2020 	strb.w	r2, [r5, #32]
	p->tx = conn->lll.phy_tx;
   130de:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
   130e2:	f3c3 0302 	ubfx	r3, r3, #0, #3
   130e6:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
	p->rx = conn->lll.phy_rx;
   130ea:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
   130ee:	f3c3 0302 	ubfx	r3, r3, #0, #3
   130f2:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
	if (err) {
   130f6:	e415      	b.n	12924 <ull_conn_rx+0x368>
		if (conn->llcp_conn_param.ack != conn->llcp_conn_param.req) {
   130f8:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
   130fc:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
   13100:	429a      	cmp	r2, r3
   13102:	f43f aa66 	beq.w	125d2 <ull_conn_rx+0x16>
	if (!lll->role && (rej_ext_ind->error_code ==
   13106:	f994 203d 	ldrsb.w	r2, [r4, #61]	; 0x3d
   1310a:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   1310e:	2a00      	cmp	r2, #0
   13110:	f2c0 848c 	blt.w	13a2c <ull_conn_rx+0x1470>
   13114:	2b1a      	cmp	r3, #26
   13116:	f040 848f 	bne.w	13a38 <ull_conn_rx+0x147c>
		LL_ASSERT(conn->llcp_cu.req == conn->llcp_cu.ack);
   1311a:	f894 2104 	ldrb.w	r2, [r4, #260]	; 0x104
   1311e:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
   13122:	429a      	cmp	r2, r3
   13124:	d00c      	beq.n	13140 <ull_conn_rx+0xb84>
   13126:	f241 0346 	movw	r3, #4166	; 0x1046
   1312a:	4a40      	ldr	r2, [pc, #256]	; (1322c <ull_conn_rx+0xc70>)
   1312c:	4942      	ldr	r1, [pc, #264]	; (13238 <ull_conn_rx+0xc7c>)
   1312e:	4841      	ldr	r0, [pc, #260]	; (13234 <ull_conn_rx+0xc78>)
   13130:	f006 f920 	bl	19374 <printk>
   13134:	4040      	eors	r0, r0
   13136:	f380 8811 	msr	BASEPRI, r0
   1313a:	f04f 0003 	mov.w	r0, #3
   1313e:	df02      	svc	2
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
   13140:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
   13144:	2305      	movs	r3, #5
   13146:	f363 0202 	bfi	r2, r3, #0, #3
		conn->llcp_cu.win_offset_us = 0U;
   1314a:	2300      	movs	r3, #0
   1314c:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
		conn->llcp_cu.interval = conn->llcp_conn_param.interval_max;
   13150:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
   13154:	f8a4 3108 	strh.w	r3, [r4, #264]	; 0x108
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
   13158:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
   1315c:	f8a4 310a 	strh.w	r3, [r4, #266]	; 0x10a
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
   13160:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
   13164:	f8a4 310c 	strh.w	r3, [r4, #268]	; 0x10c
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   13168:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
   1316c:	f884 2172 	strb.w	r2, [r4, #370]	; 0x172
		conn->llcp_cu.win_size = 1U;
   13170:	2101      	movs	r1, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   13172:	f361 0301 	bfi	r3, r1, #0, #2
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
   13176:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   1317a:	f362 0382 	bfi	r3, r2, #2, #1
   1317e:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
		conn->llcp_cu.ack--;
   13182:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
		conn->llcp_cu.win_size = 1U;
   13186:	f884 1114 	strb.w	r1, [r4, #276]	; 0x114
		conn->llcp_cu.ack--;
   1318a:	3b01      	subs	r3, #1
   1318c:	f884 3105 	strb.w	r3, [r4, #261]	; 0x105
	if (err) {
   13190:	f7ff ba1f 	b.w	125d2 <ull_conn_rx+0x16>
		if (conn->llcp_length.ack != conn->llcp_length.req) {
   13194:	f894 3198 	ldrb.w	r3, [r4, #408]	; 0x198
   13198:	f894 2199 	ldrb.w	r2, [r4, #409]	; 0x199
   1319c:	429a      	cmp	r2, r3
   1319e:	f43f aa18 	beq.w	125d2 <ull_conn_rx+0x16>
	conn->llcp_length.ack = conn->llcp_length.req;
   131a2:	f884 3199 	strb.w	r3, [r4, #409]	; 0x199
	conn->procedure_expire = 0U;
   131a6:	2000      	movs	r0, #0
	pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
   131a8:	2309      	movs	r3, #9
	conn->procedure_expire = 0U;
   131aa:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
	pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
   131ae:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
   131b2:	2315      	movs	r3, #21
   131b4:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
	lr->max_rx_octets = sys_cpu_to_le16(conn->lll.max_rx_octets);
   131b8:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
   131bc:	84ab      	strh	r3, [r5, #36]	; 0x24
	lr->max_tx_octets = sys_cpu_to_le16(conn->lll.max_tx_octets);
   131be:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
   131c2:	852b      	strh	r3, [r5, #40]	; 0x28
	lr->max_rx_time = sys_cpu_to_le16(conn->lll.max_rx_time);
   131c4:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
   131c8:	84eb      	strh	r3, [r5, #38]	; 0x26
	lr->max_tx_time = sys_cpu_to_le16(conn->lll.max_tx_time);
   131ca:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
   131ce:	856b      	strh	r3, [r5, #42]	; 0x2a
	if (err) {
   131d0:	e48b      	b.n	12aea <ull_conn_rx+0x52e>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PING_REQ, pdu_rx->len)) {
   131d2:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   131d6:	2012      	movs	r0, #18
   131d8:	f7fe fde0 	bl	11d9c <pdu_len_cmp>
   131dc:	2800      	cmp	r0, #0
   131de:	f000 83fe 	beq.w	139de <ull_conn_rx+0x1422>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   131e2:	4816      	ldr	r0, [pc, #88]	; (1323c <ull_conn_rx+0xc80>)
   131e4:	f009 fe42 	bl	1ce6c <mem_acquire>
	if (!tx) {
   131e8:	4601      	mov	r1, r0
   131ea:	2800      	cmp	r0, #0
   131ec:	f43f ac7b 	beq.w	12ae6 <ull_conn_rx+0x52a>
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   131f0:	7903      	ldrb	r3, [r0, #4]
   131f2:	f043 0303 	orr.w	r3, r3, #3
   131f6:	7103      	strb	r3, [r0, #4]
	pdu_tx->len = offsetof(struct pdu_data_llctrl, ping_rsp) +
   131f8:	2301      	movs	r3, #1
   131fa:	7143      	strb	r3, [r0, #5]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_RSP;
   131fc:	2313      	movs	r3, #19
   131fe:	71c3      	strb	r3, [r0, #7]
	ctrl_tx_sec_enqueue(conn, tx);
   13200:	4620      	mov	r0, r4
   13202:	f00a f9c2 	bl	1d58a <ctrl_tx_sec_enqueue>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   13206:	f7ff b9e4 	b.w	125d2 <ull_conn_rx+0x16>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PING_RSP, pdu_rx->len)) {
   1320a:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1320e:	2013      	movs	r0, #19
   13210:	f7fe fdc4 	bl	11d9c <pdu_len_cmp>
   13214:	2800      	cmp	r0, #0
   13216:	f000 83e2 	beq.w	139de <ull_conn_rx+0x1422>
		conn->procedure_expire = 0U;
   1321a:	2000      	movs	r0, #0
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1321c:	2303      	movs	r3, #3
		conn->procedure_expire = 0U;
   1321e:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   13222:	712b      	strb	r3, [r5, #4]
		break;
   13224:	e461      	b.n	12aea <ull_conn_rx+0x52e>
   13226:	bf00      	nop
   13228:	20001354 	.word	0x20001354
   1322c:	00021f06 	.word	0x00021f06
   13230:	00022577 	.word	0x00022577
   13234:	00020aa4 	.word	0x00020aa4
   13238:	00021fed 	.word	0x00021fed
   1323c:	200013d4 	.word	0x200013d4
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP,
   13240:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   13244:	2007      	movs	r0, #7
   13246:	f7fe fda9 	bl	11d9c <pdu_len_cmp>
   1324a:	2800      	cmp	r0, #0
   1324c:	f000 83c7 	beq.w	139de <ull_conn_rx+0x1422>
		} else if (conn->llcp_conn_param.ack !=
   13250:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
   13254:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
   13258:	429a      	cmp	r2, r3
   1325a:	d07b      	beq.n	13354 <ull_conn_rx+0xd98>
			conn->llcp_conn_param.disabled = 1U;
   1325c:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   13260:	f043 0310 	orr.w	r3, r3, #16
   13264:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
			if (!conn->lll.role) {
   13268:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   1326c:	2b00      	cmp	r3, #0
   1326e:	db3f      	blt.n	132f0 <ull_conn_rx+0xd34>
				LL_ASSERT(conn->llcp_cu.req ==
   13270:	f894 2104 	ldrb.w	r2, [r4, #260]	; 0x104
   13274:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
   13278:	429a      	cmp	r2, r3
   1327a:	d00c      	beq.n	13296 <ull_conn_rx+0xcda>
   1327c:	f241 6392 	movw	r3, #5778	; 0x1692
   13280:	4ac5      	ldr	r2, [pc, #788]	; (13598 <ull_conn_rx+0xfdc>)
   13282:	49c6      	ldr	r1, [pc, #792]	; (1359c <ull_conn_rx+0xfe0>)
   13284:	48c6      	ldr	r0, [pc, #792]	; (135a0 <ull_conn_rx+0xfe4>)
   13286:	f006 f875 	bl	19374 <printk>
   1328a:	4040      	eors	r0, r0
   1328c:	f380 8811 	msr	BASEPRI, r0
   13290:	f04f 0003 	mov.w	r0, #3
   13294:	df02      	svc	2
				conn->llcp_conn_param.state =
   13296:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
   1329a:	2305      	movs	r3, #5
   1329c:	f363 0202 	bfi	r2, r3, #0, #3
				conn->llcp_cu.interval =
   132a0:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
   132a4:	f8a4 3108 	strh.w	r3, [r4, #264]	; 0x108
				conn->llcp_cu.latency =
   132a8:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
   132ac:	f8a4 310a 	strh.w	r3, [r4, #266]	; 0x10a
				conn->llcp_cu.timeout =
   132b0:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
   132b4:	f8a4 310c 	strh.w	r3, [r4, #268]	; 0x10c
				conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   132b8:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
				conn->llcp_conn_param.state =
   132bc:	f884 2172 	strb.w	r2, [r4, #370]	; 0x172
				conn->llcp_cu.win_size = 1U;
   132c0:	2101      	movs	r1, #1
				conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   132c2:	f361 0301 	bfi	r3, r1, #0, #2
				conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
   132c6:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   132ca:	f362 0382 	bfi	r3, r2, #2, #1
   132ce:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
				conn->llcp_cu.ack--;
   132d2:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
				conn->llcp_cu.win_size = 1U;
   132d6:	f884 1114 	strb.w	r1, [r4, #276]	; 0x114
				conn->llcp_cu.ack--;
   132da:	3b01      	subs	r3, #1
   132dc:	f884 3105 	strb.w	r3, [r4, #261]	; 0x105
				conn->llcp_cu.win_offset_us = 0U;
   132e0:	2000      	movs	r0, #0
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   132e2:	6833      	ldr	r3, [r6, #0]
				conn->llcp_cu.win_offset_us = 0U;
   132e4:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   132e8:	2203      	movs	r2, #3
   132ea:	711a      	strb	r2, [r3, #4]
				break;
   132ec:	f7ff bbfd 	b.w	12aea <ull_conn_rx+0x52e>
			LL_ASSERT(conn_upd_curr == conn);
   132f0:	4fac      	ldr	r7, [pc, #688]	; (135a4 <ull_conn_rx+0xfe8>)
   132f2:	683a      	ldr	r2, [r7, #0]
   132f4:	4294      	cmp	r4, r2
   132f6:	d00c      	beq.n	13312 <ull_conn_rx+0xd56>
   132f8:	f241 63a9 	movw	r3, #5801	; 0x16a9
   132fc:	4aa6      	ldr	r2, [pc, #664]	; (13598 <ull_conn_rx+0xfdc>)
   132fe:	49aa      	ldr	r1, [pc, #680]	; (135a8 <ull_conn_rx+0xfec>)
   13300:	48a7      	ldr	r0, [pc, #668]	; (135a0 <ull_conn_rx+0xfe4>)
   13302:	f006 f837 	bl	19374 <printk>
   13306:	4040      	eors	r0, r0
   13308:	f380 8811 	msr	BASEPRI, r0
   1330c:	f04f 0003 	mov.w	r0, #3
   13310:	df02      	svc	2
			conn_upd_curr = NULL;
   13312:	2300      	movs	r3, #0
			if (!conn->llcp_conn_param.cmd) {
   13314:	f894 0172 	ldrb.w	r0, [r4, #370]	; 0x172
			conn_upd_curr = NULL;
   13318:	603b      	str	r3, [r7, #0]
			conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   1331a:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
   1331e:	f884 3171 	strb.w	r3, [r4, #369]	; 0x171
			if (!conn->llcp_conn_param.cmd) {
   13322:	f010 0008 	ands.w	r0, r0, #8
   13326:	6833      	ldr	r3, [r6, #0]
   13328:	d0de      	beq.n	132e8 <ull_conn_rx+0xd2c>
			(*rx)->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
   1332a:	220a      	movs	r2, #10
   1332c:	711a      	strb	r2, [r3, #4]
			cu->status = BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
   1332e:	231a      	movs	r3, #26
   13330:	f885 3020 	strb.w	r3, [r5, #32]
			cu->latency = lll->latency;
   13334:	8e22      	ldrh	r2, [r4, #48]	; 0x30
			cu->interval = lll->interval;
   13336:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
			cu->latency = lll->latency;
   13338:	84aa      	strh	r2, [r5, #36]	; 0x24
			cu->timeout = conn->supervision_reload *
   1333a:	f8b4 20c6 	ldrh.w	r2, [r4, #198]	; 0xc6
			cu->interval = lll->interval;
   1333e:	846b      	strh	r3, [r5, #34]	; 0x22
			cu->timeout = conn->supervision_reload *
   13340:	435a      	muls	r2, r3
				      lll->interval * 125U / 1000;
   13342:	237d      	movs	r3, #125	; 0x7d
   13344:	4353      	muls	r3, r2
   13346:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1334a:	fbb3 f3f2 	udiv	r3, r3, r2
			cu->timeout = conn->supervision_reload *
   1334e:	84eb      	strh	r3, [r5, #38]	; 0x26
   13350:	f7ff ba6b 	b.w	1282a <ull_conn_rx+0x26e>
		} else if (conn->llcp_length.req != conn->llcp_length.ack) {
   13354:	f894 3198 	ldrb.w	r3, [r4, #408]	; 0x198
   13358:	f894 2199 	ldrb.w	r2, [r4, #409]	; 0x199
   1335c:	429a      	cmp	r2, r3
   1335e:	d003      	beq.n	13368 <ull_conn_rx+0xdac>
			conn->llcp_length.ack = conn->llcp_length.req;
   13360:	f884 3199 	strb.w	r3, [r4, #409]	; 0x199
   13364:	f7ff ba61 	b.w	1282a <ull_conn_rx+0x26e>
		} else if (conn->llcp_phy.req !=
   13368:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
   1336c:	f894 21a9 	ldrb.w	r2, [r4, #425]	; 0x1a9
   13370:	429a      	cmp	r2, r3
   13372:	d025      	beq.n	133c0 <ull_conn_rx+0xe04>
			conn->llcp_phy.ack = conn->llcp_phy.req;
   13374:	f884 31a9 	strb.w	r3, [r4, #425]	; 0x1a9
			lll->phy_tx_time = lll->phy_tx;
   13378:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
			conn->llcp_phy.pause_tx = 0U;
   1337c:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
			lll->phy_tx_time = lll->phy_tx;
   13380:	f3c3 0102 	ubfx	r1, r3, #0, #3
			conn->llcp_phy.pause_tx = 0U;
   13384:	f36f 0200 	bfc	r2, #0, #1
			lll->phy_tx_time = lll->phy_tx;
   13388:	f361 1306 	bfi	r3, r1, #4, #3
			conn->llcp_phy.pause_tx = 0U;
   1338c:	f884 21ab 	strb.w	r2, [r4, #427]	; 0x1ab
			lll->phy_tx_time = lll->phy_tx;
   13390:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
			if (conn->llcp_phy.cmd) {
   13394:	f012 0f04 	tst.w	r2, #4
   13398:	6833      	ldr	r3, [r6, #0]
   1339a:	d00e      	beq.n	133ba <ull_conn_rx+0xdfe>
				(*rx)->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
   1339c:	220e      	movs	r2, #14
   1339e:	711a      	strb	r2, [r3, #4]
				p->status = 0U;
   133a0:	2300      	movs	r3, #0
   133a2:	f885 3020 	strb.w	r3, [r5, #32]
				p->tx = lll->phy_tx;
   133a6:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21
				p->rx = lll->phy_rx;
   133aa:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
   133ae:	f3c3 0302 	ubfx	r3, r3, #0, #3
   133b2:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   133b6:	f7ff ba38 	b.w	1282a <ull_conn_rx+0x26e>
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   133ba:	2203      	movs	r2, #3
   133bc:	f7ff bb2e 	b.w	12a1c <ull_conn_rx+0x460>
			switch (llctrl->unknown_rsp.type) {
   133c0:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   133c4:	2b12      	cmp	r3, #18
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   133c6:	bf04      	itt	eq
   133c8:	2303      	moveq	r3, #3
   133ca:	712b      	strbeq	r3, [r5, #4]
				break;
   133cc:	f7ff ba2d 	b.w	1282a <ull_conn_rx+0x26e>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_LENGTH_REQ,
   133d0:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   133d4:	2014      	movs	r0, #20
   133d6:	f7fe fce1 	bl	11d9c <pdu_len_cmp>
   133da:	2800      	cmp	r0, #0
   133dc:	f000 82ff 	beq.w	139de <ull_conn_rx+0x1422>
	if (pdu_rx->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_LENGTH_REQ) {
   133e0:	f1b9 0f14 	cmp.w	r9, #20
   133e4:	d176      	bne.n	134d4 <ull_conn_rx+0xf18>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   133e6:	4871      	ldr	r0, [pc, #452]	; (135ac <ull_conn_rx+0xff0>)
   133e8:	f009 fd40 	bl	1ce6c <mem_acquire>
		if (!tx) {
   133ec:	4607      	mov	r7, r0
   133ee:	2800      	cmp	r0, #0
   133f0:	f43f ab79 	beq.w	12ae6 <ull_conn_rx+0x52a>
	eff_rx_octets = conn->lll.max_rx_octets;
   133f4:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
   133f8:	9300      	str	r3, [sp, #0]
	    ((conn->llcp_length.req == conn->llcp_length.ack) &&
   133fa:	f894 3198 	ldrb.w	r3, [r4, #408]	; 0x198
   133fe:	9301      	str	r3, [sp, #4]
	if (/* Local idle, and Peer request then complete the Peer procedure
   13400:	f894 2199 	ldrb.w	r2, [r4, #409]	; 0x199
   13404:	9901      	ldr	r1, [sp, #4]
	eff_tx_octets = conn->lll.max_tx_octets;
   13406:	f8b4 905c 	ldrh.w	r9, [r4, #92]	; 0x5c
	eff_rx_time = conn->lll.max_rx_time;
   1340a:	f8b4 a062 	ldrh.w	sl, [r4, #98]	; 0x62
	eff_tx_time = conn->lll.max_tx_time;
   1340e:	f8b4 b060 	ldrh.w	fp, [r4, #96]	; 0x60
	if (/* Local idle, and Peer request then complete the Peer procedure
   13412:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
   13416:	428a      	cmp	r2, r1
   13418:	d15e      	bne.n	134d8 <ull_conn_rx+0xf1c>
	    ((conn->llcp_length.req == conn->llcp_length.ack) &&
   1341a:	2b14      	cmp	r3, #20
   1341c:	f040 80b4 	bne.w	13588 <ull_conn_rx+0xfcc>
		max_rx_octets = sys_le16_to_cpu(lr->max_rx_octets);
   13420:	8cab      	ldrh	r3, [r5, #36]	; 0x24
		if (max_rx_octets >= PDU_DC_PAYLOAD_SIZE_MIN) {
   13422:	2b1a      	cmp	r3, #26
   13424:	d974      	bls.n	13510 <ull_conn_rx+0xf54>
			eff_tx_octets = MIN(max_rx_octets,
   13426:	f8b4 20d6 	ldrh.w	r2, [r4, #214]	; 0xd6
   1342a:	429a      	cmp	r2, r3
   1342c:	bf28      	it	cs
   1342e:	461a      	movcs	r2, r3
		if (max_tx_octets >= PDU_DC_PAYLOAD_SIZE_MIN) {
   13430:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
			eff_rx_octets = MIN(max_tx_octets,
   13432:	2b1b      	cmp	r3, #27
   13434:	9b00      	ldr	r3, [sp, #0]
   13436:	bf38      	it	cc
   13438:	469c      	movcc	ip, r3
		max_rx_time = sys_le16_to_cpu(lr->max_rx_time);
   1343a:	8ceb      	ldrh	r3, [r5, #38]	; 0x26
			eff_rx_octets = MIN(max_tx_octets,
   1343c:	bf28      	it	cs
   1343e:	f04f 0c1b 	movcs.w	ip, #27
		if (max_rx_time >= PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0)) {
   13442:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
   13446:	d365      	bcc.n	13514 <ull_conn_rx+0xf58>
			eff_tx_time = MIN(max_rx_time,
   13448:	f8b4 10d8 	ldrh.w	r1, [r4, #216]	; 0xd8
   1344c:	428b      	cmp	r3, r1
   1344e:	bf28      	it	cs
   13450:	460b      	movcs	r3, r1
		if (max_tx_time >= PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0)) {
   13452:	8d69      	ldrh	r1, [r5, #42]	; 0x2a
		if (eff_rx_octets != conn->lll.max_rx_octets) {
   13454:	9800      	ldr	r0, [sp, #0]
			eff_rx_time = MIN(max_tx_time,
   13456:	f5b1 7fa4 	cmp.w	r1, #328	; 0x148
   1345a:	bf34      	ite	cc
   1345c:	4651      	movcc	r1, sl
   1345e:	f44f 71a4 	movcs.w	r1, #328	; 0x148
		if (eff_rx_octets != conn->lll.max_rx_octets) {
   13462:	4560      	cmp	r0, ip
   13464:	d05e      	beq.n	13524 <ull_conn_rx+0xf68>
			conn->llcp_length.ack = (conn->llcp_length.req -
   13466:	9801      	ldr	r0, [sp, #4]
			conn->llcp_length.rx_octets = eff_rx_octets;
   13468:	f8a4 c19c 	strh.w	ip, [r4, #412]	; 0x19c
			conn->llcp_length.ack = (conn->llcp_length.req -
   1346c:	3801      	subs	r0, #1
   1346e:	f884 0199 	strb.w	r0, [r4, #409]	; 0x199
			conn->llcp_length.tx_octets = eff_tx_octets;
   13472:	f8a4 219e 	strh.w	r2, [r4, #414]	; 0x19e
			conn->llcp_length.rx_time = eff_rx_time;
   13476:	f8a4 11a0 	strh.w	r1, [r4, #416]	; 0x1a0
			conn->llcp_length.tx_time = eff_tx_time;
   1347a:	f8a4 31a2 	strh.w	r3, [r4, #418]	; 0x1a2
			if (tx) {
   1347e:	f894 019a 	ldrb.w	r0, [r4, #410]	; 0x19a
   13482:	2f00      	cmp	r7, #0
   13484:	d048      	beq.n	13518 <ull_conn_rx+0xf5c>
				conn->llcp_length.state =
   13486:	2505      	movs	r5, #5
				conn->llcp_length.state =
   13488:	f365 0002 	bfi	r0, r5, #0, #3
   1348c:	f884 019a 	strb.w	r0, [r4, #410]	; 0x19a
			link->mem = conn->llcp_rx;
   13490:	f8d4 0100 	ldr.w	r0, [r4, #256]	; 0x100
   13494:	f8c8 0004 	str.w	r0, [r8, #4]
			(*rx)->hdr.link = link;
   13498:	6830      	ldr	r0, [r6, #0]
   1349a:	f8c0 8000 	str.w	r8, [r0]
			conn->llcp_rx = *rx;
   1349e:	6830      	ldr	r0, [r6, #0]
   134a0:	f8c4 0100 	str.w	r0, [r4, #256]	; 0x100
			*rx = NULL;
   134a4:	2000      	movs	r0, #0
   134a6:	6030      	str	r0, [r6, #0]
	if (tx) {
   134a8:	2f00      	cmp	r7, #0
   134aa:	f43f aa3b 	beq.w	12924 <ull_conn_rx+0x368>
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   134ae:	7938      	ldrb	r0, [r7, #4]
	pdu_tx->llctrl.length_rsp.max_rx_time = sys_cpu_to_le16(eff_rx_time);
   134b0:	8179      	strh	r1, [r7, #10]
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   134b2:	f040 0003 	orr.w	r0, r0, #3
   134b6:	7138      	strb	r0, [r7, #4]
	pdu_tx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
   134b8:	2009      	movs	r0, #9
   134ba:	7178      	strb	r0, [r7, #5]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
   134bc:	2015      	movs	r0, #21
   134be:	71f8      	strb	r0, [r7, #7]
	pdu_tx->llctrl.length_rsp.max_rx_octets =
   134c0:	f8a7 c008 	strh.w	ip, [r7, #8]
	pdu_tx->llctrl.length_rsp.max_tx_octets =
   134c4:	81ba      	strh	r2, [r7, #12]
	pdu_tx->llctrl.length_rsp.max_tx_time = sys_cpu_to_le16(eff_tx_time);
   134c6:	81fb      	strh	r3, [r7, #14]
	ctrl_tx_sec_enqueue(conn, tx);
   134c8:	4639      	mov	r1, r7
   134ca:	4620      	mov	r0, r4
   134cc:	f00a f85d 	bl	1d58a <ctrl_tx_sec_enqueue>
   134d0:	f7ff ba28 	b.w	12924 <ull_conn_rx+0x368>
	struct node_tx *tx = NULL;
   134d4:	2700      	movs	r7, #0
   134d6:	e78d      	b.n	133f4 <ull_conn_rx+0xe38>
	     ((((conn->llcp_length.state == LLCP_LENGTH_STATE_REQ) ||
   134d8:	f894 219a 	ldrb.w	r2, [r4, #410]	; 0x19a
	    ((conn->llcp_length.req != conn->llcp_length.ack) &&
   134dc:	f012 0f06 	tst.w	r2, #6
   134e0:	d101      	bne.n	134e6 <ull_conn_rx+0xf2a>
		(conn->llcp_length.state == LLCP_LENGTH_STATE_REQ_ACK_WAIT)) &&
   134e2:	2b14      	cmp	r3, #20
   134e4:	d09c      	beq.n	13420 <ull_conn_rx+0xe64>
		PDU_DATA_LLCTRL_TYPE_LENGTH_REQ)) ||
   134e6:	f002 0207 	and.w	r2, r2, #7
   134ea:	2a02      	cmp	r2, #2
   134ec:	d14c      	bne.n	13588 <ull_conn_rx+0xfcc>
	      ((conn->llcp_length.state == LLCP_LENGTH_STATE_RSP_WAIT) &&
   134ee:	3b14      	subs	r3, #20
   134f0:	2b01      	cmp	r3, #1
   134f2:	d995      	bls.n	13420 <ull_conn_rx+0xe64>
		LL_ASSERT(pdu_rx->llctrl.opcode ==
   134f4:	f241 2316 	movw	r3, #4630	; 0x1216
   134f8:	4a27      	ldr	r2, [pc, #156]	; (13598 <ull_conn_rx+0xfdc>)
   134fa:	492d      	ldr	r1, [pc, #180]	; (135b0 <ull_conn_rx+0xff4>)
   134fc:	4828      	ldr	r0, [pc, #160]	; (135a0 <ull_conn_rx+0xfe4>)
   134fe:	f005 ff39 	bl	19374 <printk>
   13502:	4040      	eors	r0, r0
   13504:	f380 8811 	msr	BASEPRI, r0
   13508:	f04f 0003 	mov.w	r0, #3
   1350c:	df02      	svc	2
   1350e:	e03d      	b.n	1358c <ull_conn_rx+0xfd0>
	eff_tx_octets = conn->lll.max_tx_octets;
   13510:	464a      	mov	r2, r9
   13512:	e78d      	b.n	13430 <ull_conn_rx+0xe74>
	eff_tx_time = conn->lll.max_tx_time;
   13514:	465b      	mov	r3, fp
   13516:	e79c      	b.n	13452 <ull_conn_rx+0xe96>
				conn->lll.max_tx_octets = eff_tx_octets;
   13518:	f8a4 205c 	strh.w	r2, [r4, #92]	; 0x5c
				conn->lll.max_tx_time = eff_tx_time;
   1351c:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
				conn->llcp_length.state =
   13520:	2504      	movs	r5, #4
   13522:	e7b1      	b.n	13488 <ull_conn_rx+0xecc>
			conn->llcp_length.ack = conn->llcp_length.req;
   13524:	9801      	ldr	r0, [sp, #4]
   13526:	f884 0199 	strb.w	r0, [r4, #409]	; 0x199
			conn->procedure_expire = 0U;
   1352a:	f04f 0e00 	mov.w	lr, #0
			if (eff_tx_octets == conn->lll.max_tx_octets &&
   1352e:	4591      	cmp	r9, r2
			conn->procedure_expire = 0U;
   13530:	f8a4 e0cc 	strh.w	lr, [r4, #204]	; 0xcc
			if (eff_tx_octets == conn->lll.max_tx_octets &&
   13534:	d107      	bne.n	13546 <ull_conn_rx+0xf8a>
   13536:	459b      	cmp	fp, r3
   13538:	d105      	bne.n	13546 <ull_conn_rx+0xf8a>
			    eff_rx_time == conn->lll.max_rx_time &&
   1353a:	458a      	cmp	sl, r1
   1353c:	d103      	bne.n	13546 <ull_conn_rx+0xf8a>
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1353e:	6830      	ldr	r0, [r6, #0]
   13540:	2503      	movs	r5, #3
   13542:	7105      	strb	r5, [r0, #4]
				goto send_length_resp;
   13544:	e7b0      	b.n	134a8 <ull_conn_rx+0xeec>
			conn->lll.max_rx_time = eff_rx_time;
   13546:	f8a4 1062 	strh.w	r1, [r4, #98]	; 0x62
			if (tx) {
   1354a:	b1c7      	cbz	r7, 1357e <ull_conn_rx+0xfc2>
					(conn->llcp_length.req - 1);
   1354c:	9801      	ldr	r0, [sp, #4]
				conn->llcp_length.rx_octets = eff_rx_octets;
   1354e:	f8a4 c19c 	strh.w	ip, [r4, #412]	; 0x19c
					(conn->llcp_length.req - 1);
   13552:	3801      	subs	r0, #1
				conn->llcp_length.ack =
   13554:	f884 0199 	strb.w	r0, [r4, #409]	; 0x199
				conn->llcp_length.state =
   13558:	f894 019a 	ldrb.w	r0, [r4, #410]	; 0x19a
				conn->llcp_length.tx_octets = eff_tx_octets;
   1355c:	f8a4 219e 	strh.w	r2, [r4, #414]	; 0x19e
				conn->llcp_length.state =
   13560:	2603      	movs	r6, #3
   13562:	f366 0002 	bfi	r0, r6, #0, #3
				conn->llcp_length.rx_time = eff_rx_time;
   13566:	f8a4 11a0 	strh.w	r1, [r4, #416]	; 0x1a0
				conn->llcp_length.tx_time = eff_tx_time;
   1356a:	f8a4 31a2 	strh.w	r3, [r4, #418]	; 0x1a2
				conn->llcp_length.state =
   1356e:	f884 019a 	strb.w	r0, [r4, #410]	; 0x19a
			lr->max_rx_octets = sys_cpu_to_le16(eff_rx_octets);
   13572:	f8a5 c024 	strh.w	ip, [r5, #36]	; 0x24
			lr->max_tx_octets = sys_cpu_to_le16(eff_tx_octets);
   13576:	852a      	strh	r2, [r5, #40]	; 0x28
			lr->max_rx_time = sys_cpu_to_le16(eff_rx_time);
   13578:	84e9      	strh	r1, [r5, #38]	; 0x26
			lr->max_tx_time = sys_cpu_to_le16(eff_tx_time);
   1357a:	856b      	strh	r3, [r5, #42]	; 0x2a
   1357c:	e794      	b.n	134a8 <ull_conn_rx+0xeec>
				conn->lll.max_tx_octets = eff_tx_octets;
   1357e:	f8a4 205c 	strh.w	r2, [r4, #92]	; 0x5c
				conn->lll.max_tx_time = eff_tx_time;
   13582:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
   13586:	e7f4      	b.n	13572 <ull_conn_rx+0xfb6>
		LL_ASSERT(pdu_rx->llctrl.opcode ==
   13588:	2b15      	cmp	r3, #21
   1358a:	d1b3      	bne.n	134f4 <ull_conn_rx+0xf38>
	eff_tx_time = conn->lll.max_tx_time;
   1358c:	465b      	mov	r3, fp
	eff_rx_time = conn->lll.max_rx_time;
   1358e:	4651      	mov	r1, sl
	eff_tx_octets = conn->lll.max_tx_octets;
   13590:	464a      	mov	r2, r9
	eff_rx_octets = conn->lll.max_rx_octets;
   13592:	f8dd c000 	ldr.w	ip, [sp]
   13596:	e787      	b.n	134a8 <ull_conn_rx+0xeec>
   13598:	00021f06 	.word	0x00021f06
   1359c:	00021fed 	.word	0x00021fed
   135a0:	00020aa4 	.word	0x00020aa4
   135a4:	20001354 	.word	0x20001354
   135a8:	00022014 	.word	0x00022014
   135ac:	200013d4 	.word	0x200013d4
   135b0:	0002202a 	.word	0x0002202a
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PHY_REQ, pdu_rx->len)) {
   135b4:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   135b8:	2016      	movs	r0, #22
   135ba:	f7fe fbef 	bl	11d9c <pdu_len_cmp>
   135be:	2800      	cmp	r0, #0
   135c0:	f000 820d 	beq.w	139de <ull_conn_rx+0x1422>
		if (!conn->lll.role) {
   135c4:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   135c8:	2b00      	cmp	r3, #0
   135ca:	db6d      	blt.n	136a8 <ull_conn_rx+0x10ec>
			if ((conn->llcp_phy.ack !=
   135cc:	f894 31a9 	ldrb.w	r3, [r4, #425]	; 0x1a9
			     conn->llcp_phy.req) &&
   135d0:	f894 11a8 	ldrb.w	r1, [r4, #424]	; 0x1a8
			if ((conn->llcp_phy.ack !=
   135d4:	428b      	cmp	r3, r1
   135d6:	d00a      	beq.n	135ee <ull_conn_rx+0x1032>
			      LLCP_PHY_STATE_RSP_WAIT) ||
   135d8:	f894 21aa 	ldrb.w	r2, [r4, #426]	; 0x1aa
   135dc:	f002 0203 	and.w	r2, r2, #3
			     conn->llcp_phy.req) &&
   135e0:	3a01      	subs	r2, #1
   135e2:	2a02      	cmp	r2, #2
   135e4:	d803      	bhi.n	135ee <ull_conn_rx+0x1032>
				nack = reject_ext_ind_send(conn, *rx,
   135e6:	2323      	movs	r3, #35	; 0x23
				nack = reject_ext_ind_send(conn, *rx,
   135e8:	2216      	movs	r2, #22
   135ea:	f7ff bb37 	b.w	12c5c <ull_conn_rx+0x6a0>
			} else if (((((conn->llcp_req - conn->llcp_ack) &
   135ee:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
   135f2:	f894 00e9 	ldrb.w	r0, [r4, #233]	; 0xe9
   135f6:	1a12      	subs	r2, r2, r0
   135f8:	f002 0203 	and.w	r2, r2, #3
   135fc:	2a02      	cmp	r2, #2
   135fe:	d103      	bne.n	13608 <ull_conn_rx+0x104c>
				      0x03) == 0x02) &&
   13600:	f894 20ea 	ldrb.w	r2, [r4, #234]	; 0xea
   13604:	2a03      	cmp	r2, #3
   13606:	d105      	bne.n	13614 <ull_conn_rx+0x1058>
				     LLCP_ENCRYPTION)) ||
   13608:	f894 0170 	ldrb.w	r0, [r4, #368]	; 0x170
   1360c:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
   13610:	4290      	cmp	r0, r2
   13612:	d001      	beq.n	13618 <ull_conn_rx+0x105c>
				nack = reject_ext_ind_send(conn, *rx,
   13614:	232a      	movs	r3, #42	; 0x2a
   13616:	e7e7      	b.n	135e8 <ull_conn_rx+0x102c>
				conn->llcp_phy.state =
   13618:	f894 21aa 	ldrb.w	r2, [r4, #426]	; 0x1aa
				if (conn->llcp_phy.ack ==
   1361c:	428b      	cmp	r3, r1
				conn->llcp_phy.state =
   1361e:	f042 0203 	orr.w	r2, r2, #3
   13622:	f884 21aa 	strb.w	r2, [r4, #426]	; 0x1aa
				if (conn->llcp_phy.ack ==
   13626:	d116      	bne.n	13656 <ull_conn_rx+0x109a>
					conn->llcp_phy.ack--;
   13628:	3b01      	subs	r3, #1
   1362a:	f884 31a9 	strb.w	r3, [r4, #425]	; 0x1a9
					conn->llcp_phy.cmd = 0U;
   1362e:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
						conn->phy_pref_tx;
   13632:	f894 21ac 	ldrb.w	r2, [r4, #428]	; 0x1ac
					conn->llcp_phy.cmd = 0U;
   13636:	f36f 0382 	bfc	r3, #2, #1
   1363a:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
					conn->llcp_phy.tx =
   1363e:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
						conn->phy_pref_tx;
   13642:	f3c2 0102 	ubfx	r1, r2, #0, #3
					conn->llcp_phy.tx =
   13646:	f361 0384 	bfi	r3, r1, #2, #3
						conn->phy_pref_rx;
   1364a:	f3c2 1202 	ubfx	r2, r2, #4, #3
					conn->llcp_phy.rx =
   1364e:	f362 1347 	bfi	r3, r2, #5, #3
   13652:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
				conn->llcp_phy.tx &= p->rx_phys;
   13656:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   1365a:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   1365e:	f3c3 0182 	ubfx	r1, r3, #2, #3
   13662:	400a      	ands	r2, r1
   13664:	f362 0384 	bfi	r3, r2, #2, #3
   13668:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
				conn->llcp_phy.rx &= p->tx_phys;
   1366c:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
   13670:	b2db      	uxtb	r3, r3
   13672:	ea02 1253 	and.w	r2, r2, r3, lsr #5
   13676:	f362 1347 	bfi	r3, r2, #5, #3
   1367a:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
				if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
   1367e:	b2db      	uxtb	r3, r3
   13680:	f013 0f1c 	tst.w	r3, #28
   13684:	d002      	beq.n	1368c <ull_conn_rx+0x10d0>
   13686:	f013 0fe0 	tst.w	r3, #224	; 0xe0
   1368a:	d105      	bne.n	13698 <ull_conn_rx+0x10dc>
					conn->llcp_phy.tx = 0;
   1368c:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   13690:	f003 0303 	and.w	r3, r3, #3
   13694:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
				conn->llcp_phy.pause_tx = 1U;
   13698:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   1369c:	f043 0301 	orr.w	r3, r3, #1
   136a0:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   136a4:	f7ff b961 	b.w	1296a <ull_conn_rx+0x3ae>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   136a8:	48db      	ldr	r0, [pc, #876]	; (13a18 <ull_conn_rx+0x145c>)
   136aa:	f009 fbdf 	bl	1ce6c <mem_acquire>
	if (!tx) {
   136ae:	4601      	mov	r1, r0
   136b0:	2800      	cmp	r0, #0
   136b2:	f43f aa18 	beq.w	12ae6 <ull_conn_rx+0x52a>
	conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
   136b6:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
	if (conn->llcp_phy.ack ==
   136ba:	f894 c1a9 	ldrb.w	ip, [r4, #425]	; 0x1a9
	conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
   136be:	2202      	movs	r2, #2
   136c0:	f362 0301 	bfi	r3, r2, #0, #2
   136c4:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
	if (conn->llcp_phy.ack ==
   136c8:	f894 21ac 	ldrb.w	r2, [r4, #428]	; 0x1ac
   136cc:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
   136d0:	f3c2 0002 	ubfx	r0, r2, #0, #3
   136d4:	4563      	cmp	r3, ip
   136d6:	f3c2 1202 	ubfx	r2, r2, #4, #3
   136da:	b2c7      	uxtb	r7, r0
   136dc:	b2d6      	uxtb	r6, r2
   136de:	d114      	bne.n	1370a <ull_conn_rx+0x114e>
		conn->llcp_phy.ack--;
   136e0:	3b01      	subs	r3, #1
   136e2:	f884 31a9 	strb.w	r3, [r4, #425]	; 0x1a9
		conn->llcp_phy.cmd = 0U;
   136e6:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   136ea:	f36f 0382 	bfc	r3, #2, #1
   136ee:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		conn->llcp_phy.tx =
   136f2:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   136f6:	f367 0384 	bfi	r3, r7, #2, #3
		conn->llcp_phy.rx =
   136fa:	f366 1347 	bfi	r3, r6, #5, #3
   136fe:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
		conn->procedure_expire =
   13702:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
   13706:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	conn->llcp_phy.tx &= p->rx_phys;
   1370a:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   1370e:	f895 6025 	ldrb.w	r6, [r5, #37]	; 0x25
   13712:	f3c3 0782 	ubfx	r7, r3, #2, #3
   13716:	403e      	ands	r6, r7
   13718:	f366 0384 	bfi	r3, r6, #2, #3
   1371c:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
	conn->llcp_phy.rx &= p->tx_phys;
   13720:	f895 6024 	ldrb.w	r6, [r5, #36]	; 0x24
   13724:	b2db      	uxtb	r3, r3
   13726:	ea06 1653 	and.w	r6, r6, r3, lsr #5
   1372a:	f366 1347 	bfi	r3, r6, #5, #3
   1372e:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
	conn->llcp_phy.pause_tx = 1U;
   13732:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   13736:	f043 0301 	orr.w	r3, r3, #1
   1373a:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   1373e:	790b      	ldrb	r3, [r1, #4]
	pdu_ctrl_tx->llctrl.phy_rsp.tx_phys = conn->phy_pref_tx;
   13740:	7208      	strb	r0, [r1, #8]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   13742:	f043 0303 	orr.w	r3, r3, #3
   13746:	710b      	strb	r3, [r1, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, phy_rsp) +
   13748:	2603      	movs	r6, #3
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_RSP;
   1374a:	2317      	movs	r3, #23
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, phy_rsp) +
   1374c:	714e      	strb	r6, [r1, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_RSP;
   1374e:	71cb      	strb	r3, [r1, #7]
	pdu_ctrl_tx->llctrl.phy_rsp.rx_phys = conn->phy_pref_rx;
   13750:	724a      	strb	r2, [r1, #9]
	ctrl_tx_enqueue(conn, tx);
   13752:	4620      	mov	r0, r4
   13754:	f009 ff53 	bl	1d5fe <ctrl_tx_enqueue>
   13758:	f7ff b92a 	b.w	129b0 <ull_conn_rx+0x3f4>
		if (conn->lll.role ||
   1375c:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   13760:	2b00      	cmp	r3, #0
   13762:	f2c0 813c 	blt.w	139de <ull_conn_rx+0x1422>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PHY_RSP, pdu_rx->len)) {
   13766:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1376a:	2017      	movs	r0, #23
   1376c:	f7fe fb16 	bl	11d9c <pdu_len_cmp>
		if (conn->lll.role ||
   13770:	2800      	cmp	r0, #0
   13772:	f000 8134 	beq.w	139de <ull_conn_rx+0x1422>
		if (!conn->lll.role &&
   13776:	f894 21a9 	ldrb.w	r2, [r4, #425]	; 0x1a9
   1377a:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
   1377e:	429a      	cmp	r2, r3
   13780:	f43e af27 	beq.w	125d2 <ull_conn_rx+0x16>
		    (conn->llcp_phy.state == LLCP_PHY_STATE_RSP_WAIT)) {
   13784:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
		    (conn->llcp_phy.ack != conn->llcp_phy.req) &&
   13788:	f003 0203 	and.w	r2, r3, #3
   1378c:	2a02      	cmp	r2, #2
   1378e:	f47e af20 	bne.w	125d2 <ull_conn_rx+0x16>
			conn->llcp_phy.state = LLCP_PHY_STATE_UPD;
   13792:	f043 0303 	orr.w	r3, r3, #3
   13796:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
			conn->llcp_phy.tx &= p->rx_phys;
   1379a:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   1379e:	f3c3 0182 	ubfx	r1, r3, #2, #3
   137a2:	400a      	ands	r2, r1
   137a4:	f362 0384 	bfi	r3, r2, #2, #3
   137a8:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
			conn->llcp_phy.rx &= p->tx_phys;
   137ac:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
   137b0:	b2db      	uxtb	r3, r3
   137b2:	ea02 1253 	and.w	r2, r2, r3, lsr #5
   137b6:	f362 1347 	bfi	r3, r2, #5, #3
   137ba:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
			if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
   137be:	b2db      	uxtb	r3, r3
   137c0:	f013 0f1c 	tst.w	r3, #28
   137c4:	d002      	beq.n	137cc <ull_conn_rx+0x1210>
   137c6:	f013 0fe0 	tst.w	r3, #224	; 0xe0
   137ca:	d105      	bne.n	137d8 <ull_conn_rx+0x121c>
				conn->llcp_phy.tx = 0;
   137cc:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   137d0:	f003 0303 	and.w	r3, r3, #3
   137d4:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
			conn->llcp_phy.pause_tx = 1U;
   137d8:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   137dc:	f043 0301 	orr.w	r3, r3, #1
   137e0:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
			conn->procedure_expire = 0U;
   137e4:	2300      	movs	r3, #0
   137e6:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   137ea:	f7fe bef2 	b.w	125d2 <ull_conn_rx+0x16>
		if (!conn->lll.role ||
   137ee:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   137f2:	2b00      	cmp	r3, #0
   137f4:	f280 80f3 	bge.w	139de <ull_conn_rx+0x1422>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PHY_UPD_IND,
   137f8:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   137fc:	2018      	movs	r0, #24
   137fe:	f7fe facd 	bl	11d9c <pdu_len_cmp>
		if (!conn->lll.role ||
   13802:	2800      	cmp	r0, #0
   13804:	f000 80eb 	beq.w	139de <ull_conn_rx+0x1422>
	if (!((ind->m_to_s_phy | ind->s_to_m_phy) & 0x07)) {
   13808:	f895 1024 	ldrb.w	r1, [r5, #36]	; 0x24
   1380c:	f895 7025 	ldrb.w	r7, [r5, #37]	; 0x25
   13810:	ea41 0007 	orr.w	r0, r1, r7
   13814:	f010 0007 	ands.w	r0, r0, #7
   13818:	d135      	bne.n	13886 <ull_conn_rx+0x12ca>
		if ((conn->llcp_phy.ack == conn->llcp_phy.req) ||
   1381a:	f894 21a8 	ldrb.w	r2, [r4, #424]	; 0x1a8
   1381e:	f894 31a9 	ldrb.w	r3, [r4, #425]	; 0x1a9
   13822:	4293      	cmp	r3, r2
   13824:	f43e aed5 	beq.w	125d2 <ull_conn_rx+0x16>
		    (conn->llcp_phy.state != LLCP_PHY_STATE_RSP_WAIT)) {
   13828:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
		if ((conn->llcp_phy.ack == conn->llcp_phy.req) ||
   1382c:	f003 0303 	and.w	r3, r3, #3
   13830:	2b02      	cmp	r3, #2
   13832:	f47e aece 	bne.w	125d2 <ull_conn_rx+0x16>
		conn->llcp_phy.ack = conn->llcp_phy.req;
   13836:	f884 21a9 	strb.w	r2, [r4, #425]	; 0x1a9
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   1383a:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
   1383e:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
		conn->procedure_expire = 0U;
   13842:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   13846:	f3c2 0102 	ubfx	r1, r2, #0, #3
		conn->llcp_phy.pause_tx = 0U;
   1384a:	f360 0300 	bfi	r3, r0, #0, #1
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   1384e:	f361 1206 	bfi	r2, r1, #4, #3
		conn->llcp_phy.pause_tx = 0U;
   13852:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   13856:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
		if (!conn->llcp_phy.cmd) {
   1385a:	f013 0304 	ands.w	r3, r3, #4
   1385e:	6832      	ldr	r2, [r6, #0]
   13860:	d103      	bne.n	1386a <ull_conn_rx+0x12ae>
			(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   13862:	2103      	movs	r1, #3
   13864:	7111      	strb	r1, [r2, #4]
		if (err) {
   13866:	f7ff b85d 	b.w	12924 <ull_conn_rx+0x368>
		(*rx)->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
   1386a:	230e      	movs	r3, #14
   1386c:	7113      	strb	r3, [r2, #4]
		p->status = 0U;
   1386e:	f885 0020 	strb.w	r0, [r5, #32]
		p->tx = conn->lll.phy_tx;
   13872:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21
		p->rx = conn->lll.phy_rx;
   13876:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
   1387a:	f3c3 0302 	ubfx	r3, r3, #0, #3
   1387e:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
		if (err) {
   13882:	f7ff b932 	b.w	12aea <ull_conn_rx+0x52e>
	instant = sys_le16_to_cpu(ind->instant);
   13886:	8cea      	ldrh	r2, [r5, #38]	; 0x26
	if (((instant - conn->lll.event_counter) & 0xffff) > 0x7fff) {
   13888:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   1388a:	1ad3      	subs	r3, r2, r3
   1388c:	041b      	lsls	r3, r3, #16
   1388e:	f53e af69 	bmi.w	12764 <ull_conn_rx+0x1a8>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   13892:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   13896:	f894 00e9 	ldrb.w	r0, [r4, #233]	; 0xe9
   1389a:	1a1b      	subs	r3, r3, r0
   1389c:	f003 0303 	and.w	r3, r3, #3
   138a0:	2b02      	cmp	r3, #2
   138a2:	f43e af6e 	beq.w	12782 <ull_conn_rx+0x1c6>
	if ((conn->llcp_phy.ack != conn->llcp_phy.req) &&
   138a6:	f894 01a8 	ldrb.w	r0, [r4, #424]	; 0x1a8
   138aa:	f894 31a9 	ldrb.w	r3, [r4, #425]	; 0x1a9
   138ae:	4283      	cmp	r3, r0
   138b0:	d018      	beq.n	138e4 <ull_conn_rx+0x1328>
	    (conn->llcp_phy.state == LLCP_PHY_STATE_RSP_WAIT)) {
   138b2:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
	if ((conn->llcp_phy.ack != conn->llcp_phy.req) &&
   138b6:	f003 0303 	and.w	r3, r3, #3
   138ba:	2b02      	cmp	r3, #2
   138bc:	d112      	bne.n	138e4 <ull_conn_rx+0x1328>
		conn->llcp_phy.pause_tx = 0U;
   138be:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
		conn->llcp_phy.ack = conn->llcp_phy.req;
   138c2:	f884 01a9 	strb.w	r0, [r4, #425]	; 0x1a9
		conn->procedure_expire = 0U;
   138c6:	2000      	movs	r0, #0
		conn->llcp_phy.pause_tx = 0U;
   138c8:	f36f 0300 	bfc	r3, #0, #1
		conn->procedure_expire = 0U;
   138cc:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
   138d0:	f894 00ec 	ldrb.w	r0, [r4, #236]	; 0xec
		conn->llcp_phy.pause_tx = 0U;
   138d4:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
   138d8:	f3c3 0380 	ubfx	r3, r3, #2, #1
   138dc:	f363 0041 	bfi	r0, r3, #1, #1
   138e0:	f884 00ec 	strb.w	r0, [r4, #236]	; 0xec
	conn->llcp.phy_upd_ind.tx = ind->s_to_m_phy;
   138e4:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
	conn->llcp.phy_upd_ind.instant = instant;
   138e8:	f8a4 20ee 	strh.w	r2, [r4, #238]	; 0xee
	conn->llcp.phy_upd_ind.tx = ind->s_to_m_phy;
   138ec:	f367 0384 	bfi	r3, r7, #2, #3
	conn->llcp.phy_upd_ind.rx = ind->m_to_s_phy;
   138f0:	f361 1347 	bfi	r3, r1, #5, #3
	conn->llcp.phy_upd_ind.initiate = 0U;
   138f4:	f36f 0300 	bfc	r3, #0, #1
   138f8:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
	link->mem = conn->llcp_rx;
   138fc:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
   13900:	f8c8 3004 	str.w	r3, [r8, #4]
	(*rx)->hdr.link = link;
   13904:	6833      	ldr	r3, [r6, #0]
   13906:	f8c3 8000 	str.w	r8, [r3]
	conn->llcp_rx = *rx;
   1390a:	6833      	ldr	r3, [r6, #0]
   1390c:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
	*rx = NULL;
   13910:	2300      	movs	r3, #0
   13912:	6033      	str	r3, [r6, #0]
	struct node_rx_pdu *rx_dle = ll_pdu_rx_alloc();
   13914:	f7fc fd3e 	bl	10394 <ll_pdu_rx_alloc>
	LL_ASSERT(rx_dle);
   13918:	4605      	mov	r5, r0
   1391a:	b960      	cbnz	r0, 13936 <ull_conn_rx+0x137a>
   1391c:	f241 23d9 	movw	r3, #4825	; 0x12d9
   13920:	4a3e      	ldr	r2, [pc, #248]	; (13a1c <ull_conn_rx+0x1460>)
   13922:	493f      	ldr	r1, [pc, #252]	; (13a20 <ull_conn_rx+0x1464>)
   13924:	483f      	ldr	r0, [pc, #252]	; (13a24 <ull_conn_rx+0x1468>)
   13926:	f005 fd25 	bl	19374 <printk>
   1392a:	4040      	eors	r0, r0
   1392c:	f380 8811 	msr	BASEPRI, r0
   13930:	f04f 0003 	mov.w	r0, #3
   13934:	df02      	svc	2
	rx_dle->hdr.link->mem = conn->llcp_rx;
   13936:	682b      	ldr	r3, [r5, #0]
   13938:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
   1393c:	605a      	str	r2, [r3, #4]
	conn->llcp_type = LLCP_PHY_UPD;
   1393e:	2306      	movs	r3, #6
   13940:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
	conn->llcp_ack -= 2U;
   13944:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
	conn->llcp_rx = rx_dle;
   13948:	f8c4 5100 	str.w	r5, [r4, #256]	; 0x100
	conn->llcp_ack -= 2U;
   1394c:	3b02      	subs	r3, #2
   1394e:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
	if (conn->llcp.phy_upd_ind.tx) {
   13952:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   13956:	f013 0f1c 	tst.w	r3, #28
   1395a:	f43e afe3 	beq.w	12924 <ull_conn_rx+0x368>
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
   1395e:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
   13962:	f3c3 0382 	ubfx	r3, r3, #2, #3
   13966:	f363 1206 	bfi	r2, r3, #4, #3
   1396a:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
		if (err) {
   1396e:	f7fe bfd9 	b.w	12924 <ull_conn_rx+0x368>
	break;
#endif /* CONFIG_BT_CTLR_PHY */

#if defined(CONFIG_BT_CTLR_MIN_USED_CHAN)
	case PDU_DATA_LLCTRL_TYPE_MIN_USED_CHAN_IND:
		if (conn->lll.role ||
   13972:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   13976:	2b00      	cmp	r3, #0
   13978:	db31      	blt.n	139de <ull_conn_rx+0x1422>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_MIN_USED_CHAN_IND,
   1397a:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1397e:	2019      	movs	r0, #25
   13980:	f7fe fa0c 	bl	11d9c <pdu_len_cmp>
		if (conn->lll.role ||
   13984:	b358      	cbz	r0, 139de <ull_conn_rx+0x1422>
		if (!conn->lll.role) {
			struct pdu_data_llctrl_min_used_chans_ind *p =
				&pdu_rx->llctrl.min_used_chans_ind;

#if defined(CONFIG_BT_CTLR_PHY)
			if (!(p->phys & (conn->lll.phy_tx |
   13986:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
					 conn->lll.phy_rx))) {
   1398a:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
			if (!(p->phys & (conn->lll.phy_tx |
   1398e:	4313      	orrs	r3, r2
   13990:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
   13994:	f003 0307 	and.w	r3, r3, #7
   13998:	4213      	tst	r3, r2
   1399a:	f43e afc3 	beq.w	12924 <ull_conn_rx+0x368>
			if (!(p->phys & 0x01)) {
#endif /* !CONFIG_BT_CTLR_PHY */
				break;
			}

			if (((conn->llcp_req - conn->llcp_ack) & 0x03) ==
   1399e:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   139a2:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
   139a6:	1a9b      	subs	r3, r3, r2
   139a8:	f003 0303 	and.w	r3, r3, #3
   139ac:	2b02      	cmp	r3, #2
   139ae:	f43e afb9 	beq.w	12924 <ull_conn_rx+0x368>
			    0x02) {
				break;
			}

			memcpy(&conn->llcp.chan_map.chm[0], data_chan_map,
   139b2:	2205      	movs	r2, #5
   139b4:	491c      	ldr	r1, [pc, #112]	; (13a28 <ull_conn_rx+0x146c>)
   139b6:	f104 00ed 	add.w	r0, r4, #237	; 0xed
   139ba:	f007 fb1e 	bl	1affa <memcpy>
			       sizeof(conn->llcp.chan_map.chm));
			/* conn->llcp.chan_map.instant     = 0; */
			conn->llcp.chan_map.initiate = 1U;
   139be:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   139c2:	f043 0301 	orr.w	r3, r3, #1
   139c6:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec

			conn->llcp_type = LLCP_CHAN_MAP;
   139ca:	2302      	movs	r3, #2
   139cc:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
			conn->llcp_ack -= 2U;
   139d0:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   139d4:	3b02      	subs	r3, #2
   139d6:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		}

		/* Mark for buffer for release */
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   139da:	f7fe bfc6 	b.w	1296a <ull_conn_rx+0x3ae>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   139de:	480e      	ldr	r0, [pc, #56]	; (13a18 <ull_conn_rx+0x145c>)
   139e0:	f009 fa44 	bl	1ce6c <mem_acquire>
	if (!tx) {
   139e4:	4601      	mov	r1, r0
   139e6:	2800      	cmp	r0, #0
   139e8:	f43f a87d 	beq.w	12ae6 <ull_conn_rx+0x52a>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
   139ec:	7903      	ldrb	r3, [r0, #4]
	pdu->llctrl.unknown_rsp.type = type;
   139ee:	f880 9008 	strb.w	r9, [r0, #8]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
   139f2:	f043 0303 	orr.w	r3, r3, #3
   139f6:	7103      	strb	r3, [r0, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, unknown_rsp) +
   139f8:	2302      	movs	r3, #2
   139fa:	7143      	strb	r3, [r0, #5]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP;
   139fc:	2307      	movs	r3, #7
   139fe:	71c3      	strb	r3, [r0, #7]
	pdu->llctrl.unknown_rsp.type = type;
   13a00:	f7ff b88c 	b.w	12b1c <ull_conn_rx+0x560>
		if (conn->llcp_enc.pause_rx) {
   13a04:	2a00      	cmp	r2, #0
   13a06:	f43e af8d 	beq.w	12924 <ull_conn_rx+0x368>
   13a0a:	f7fe be38 	b.w	1267e <ull_conn_rx+0xc2>
		if (conn->llcp_enc.pause_rx) {
   13a0e:	2a00      	cmp	r2, #0
   13a10:	f43e afab 	beq.w	1296a <ull_conn_rx+0x3ae>
   13a14:	f7fe be33 	b.w	1267e <ull_conn_rx+0xc2>
   13a18:	200013d4 	.word	0x200013d4
   13a1c:	00021f06 	.word	0x00021f06
   13a20:	00022063 	.word	0x00022063
   13a24:	00020aa4 	.word	0x00020aa4
   13a28:	20005b0c 	.word	0x20005b0c
	else if (rej_ext_ind->error_code != BT_HCI_ERR_LL_PROC_COLLISION) {
   13a2c:	2b23      	cmp	r3, #35	; 0x23
   13a2e:	d003      	beq.n	13a38 <ull_conn_rx+0x147c>
			conn->slave.ticks_to_offset =
   13a30:	f8d4 3194 	ldr.w	r3, [r4, #404]	; 0x194
   13a34:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4
	if (conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT) {
   13a38:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   13a3c:	f003 0307 	and.w	r3, r3, #7
   13a40:	2b04      	cmp	r3, #4
   13a42:	d118      	bne.n	13a76 <ull_conn_rx+0x14ba>
		LL_ASSERT(conn_upd_curr == conn);
   13a44:	4e19      	ldr	r6, [pc, #100]	; (13aac <ull_conn_rx+0x14f0>)
   13a46:	6832      	ldr	r2, [r6, #0]
   13a48:	4294      	cmp	r4, r2
   13a4a:	d00c      	beq.n	13a66 <ull_conn_rx+0x14aa>
   13a4c:	f241 0361 	movw	r3, #4193	; 0x1061
   13a50:	4a17      	ldr	r2, [pc, #92]	; (13ab0 <ull_conn_rx+0x14f4>)
   13a52:	4918      	ldr	r1, [pc, #96]	; (13ab4 <ull_conn_rx+0x14f8>)
   13a54:	4818      	ldr	r0, [pc, #96]	; (13ab8 <ull_conn_rx+0x14fc>)
   13a56:	f005 fc8d 	bl	19374 <printk>
   13a5a:	4040      	eors	r0, r0
   13a5c:	f380 8811 	msr	BASEPRI, r0
   13a60:	f04f 0003 	mov.w	r0, #3
   13a64:	df02      	svc	2
		conn_upd_curr = NULL;
   13a66:	2300      	movs	r3, #0
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   13a68:	f894 2170 	ldrb.w	r2, [r4, #368]	; 0x170
		conn_upd_curr = NULL;
   13a6c:	6033      	str	r3, [r6, #0]
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   13a6e:	f884 2171 	strb.w	r2, [r4, #369]	; 0x171
		conn->procedure_expire = 0U;
   13a72:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	if (!conn->llcp_conn_param.cmd) {
   13a76:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   13a7a:	071a      	lsls	r2, r3, #28
   13a7c:	f57e ada9 	bpl.w	125d2 <ull_conn_rx+0x16>
	rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
   13a80:	230a      	movs	r3, #10
   13a82:	712b      	strb	r3, [r5, #4]
	cu->status = rej_ext_ind->error_code;
   13a84:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   13a88:	f885 3020 	strb.w	r3, [r5, #32]
	cu->latency = lll->latency;
   13a8c:	8e22      	ldrh	r2, [r4, #48]	; 0x30
	cu->interval = lll->interval;
   13a8e:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
	cu->latency = lll->latency;
   13a90:	84aa      	strh	r2, [r5, #36]	; 0x24
	cu->timeout = conn->supervision_reload *
   13a92:	f8b4 20c6 	ldrh.w	r2, [r4, #198]	; 0xc6
	cu->interval = lll->interval;
   13a96:	846b      	strh	r3, [r5, #34]	; 0x22
	cu->timeout = conn->supervision_reload *
   13a98:	435a      	muls	r2, r3
		      lll->interval * 125U / 1000;
   13a9a:	237d      	movs	r3, #125	; 0x7d
   13a9c:	4353      	muls	r3, r2
   13a9e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   13aa2:	fbb3 f3f2 	udiv	r3, r3, r2
	cu->timeout = conn->supervision_reload *
   13aa6:	84eb      	strh	r3, [r5, #38]	; 0x26
	if (err) {
   13aa8:	f7fe bf3c 	b.w	12924 <ull_conn_rx+0x368>
   13aac:	20001354 	.word	0x20001354
   13ab0:	00021f06 	.word	0x00021f06
   13ab4:	00022014 	.word	0x00022014
   13ab8:	00020aa4 	.word	0x00020aa4

00013abc <ull_conn_done>:
{
   13abc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct lll_conn *lll = (void *)HDR_ULL2LLL(done->param);
   13ac0:	6a05      	ldr	r5, [r0, #32]
	if (lll->handle == 0xFFFF) {
   13ac2:	8baa      	ldrh	r2, [r5, #28]
   13ac4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   13ac8:	429a      	cmp	r2, r3
{
   13aca:	b08b      	sub	sp, #44	; 0x2c
   13acc:	4680      	mov	r8, r0
	if (lll->handle == 0xFFFF) {
   13ace:	d00f      	beq.n	13af0 <ull_conn_done+0x34>
	switch (done->extra.mic_state) {
   13ad0:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
	struct ll_conn *conn = (void *)HDR_LLL2EVT(lll);
   13ad4:	68ec      	ldr	r4, [r5, #12]
	switch (done->extra.mic_state) {
   13ad6:	2b01      	cmp	r3, #1
   13ad8:	d032      	beq.n	13b40 <ull_conn_done+0x84>
   13ada:	b163      	cbz	r3, 13af6 <ull_conn_done+0x3a>
   13adc:	2b02      	cmp	r3, #2
   13ade:	d035      	beq.n	13b4c <ull_conn_done+0x90>
	reason_peer = conn->llcp_terminate.reason_peer;
   13ae0:	f894 612b 	ldrb.w	r6, [r4, #299]	; 0x12b
	if (reason_peer && (
   13ae4:	2e00      	cmp	r6, #0
   13ae6:	d035      	beq.n	13b54 <ull_conn_done+0x98>
		conn_cleanup(conn, reason_peer);
   13ae8:	4631      	mov	r1, r6
			conn_cleanup(conn, BT_HCI_ERR_CONN_FAIL_TO_ESTAB);
   13aea:	4620      	mov	r0, r4
   13aec:	f7fe fa74 	bl	11fd8 <conn_cleanup>
}
   13af0:	b00b      	add	sp, #44	; 0x2c
   13af2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (lll->enc_rx || conn->llcp_enc.pause_rx) {
   13af6:	f895 306e 	ldrb.w	r3, [r5, #110]	; 0x6e
   13afa:	0719      	lsls	r1, r3, #28
   13afc:	d403      	bmi.n	13b06 <ull_conn_done+0x4a>
   13afe:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   13b02:	07da      	lsls	r2, r3, #31
   13b04:	d5ec      	bpl.n	13ae0 <ull_conn_done+0x24>
					    (lll->latency + 6)) ?
   13b06:	8c2b      	ldrh	r3, [r5, #32]
			appto_reload_new = (conn->apto_reload >
   13b08:	f8b4 20d2 	ldrh.w	r2, [r4, #210]	; 0xd2
					    (lll->latency + 6)) ?
   13b0c:	1d99      	adds	r1, r3, #6
			appto_reload_new = (conn->apto_reload >
   13b0e:	428a      	cmp	r2, r1
					   (conn->apto_reload -
   13b10:	bfc4      	itt	gt
   13b12:	1ad3      	subgt	r3, r2, r3
   13b14:	3b06      	subgt	r3, #6
			if (conn->appto_reload != appto_reload_new) {
   13b16:	f8b4 10ce 	ldrh.w	r1, [r4, #206]	; 0xce
			appto_reload_new = (conn->apto_reload >
   13b1a:	bfcc      	ite	gt
   13b1c:	b29b      	uxthgt	r3, r3
   13b1e:	4613      	movle	r3, r2
			if (conn->appto_reload != appto_reload_new) {
   13b20:	4299      	cmp	r1, r3
   13b22:	d008      	beq.n	13b36 <ull_conn_done+0x7a>
				conn->appto_reload = appto_reload_new;
   13b24:	f8a4 30ce 	strh.w	r3, [r4, #206]	; 0xce
				conn->appto_expire = conn->appto_reload;
   13b28:	f8b4 30ce 	ldrh.w	r3, [r4, #206]	; 0xce
   13b2c:	f8a4 30d0 	strh.w	r3, [r4, #208]	; 0xd0
				conn->apto_expire = conn->apto_reload;
   13b30:	f8a4 20d4 	strh.w	r2, [r4, #212]	; 0xd4
   13b34:	e7d4      	b.n	13ae0 <ull_conn_done+0x24>
			if (conn->apto_expire == 0U) {
   13b36:	f8b4 30d4 	ldrh.w	r3, [r4, #212]	; 0xd4
   13b3a:	2b00      	cmp	r3, #0
   13b3c:	d1d0      	bne.n	13ae0 <ull_conn_done+0x24>
   13b3e:	e7f3      	b.n	13b28 <ull_conn_done+0x6c>
		conn->appto_expire = conn->apto_expire = 0U;
   13b40:	2300      	movs	r3, #0
   13b42:	f8a4 30d4 	strh.w	r3, [r4, #212]	; 0xd4
   13b46:	f8a4 30d0 	strh.w	r3, [r4, #208]	; 0xd0
		break;
   13b4a:	e7c9      	b.n	13ae0 <ull_conn_done+0x24>
		conn->llcp_terminate.reason_peer =
   13b4c:	233d      	movs	r3, #61	; 0x3d
   13b4e:	f884 312b 	strb.w	r3, [r4, #299]	; 0x12b
		break;
   13b52:	e7c5      	b.n	13ae0 <ull_conn_done+0x24>
	latency_event = lll->latency_event;
   13b54:	f8b5 9024 	ldrh.w	r9, [r5, #36]	; 0x24
	if (done->extra.trx_cnt) {
   13b58:	f8b8 3028 	ldrh.w	r3, [r8, #40]	; 0x28
	elapsed_event = latency_event + 1;
   13b5c:	f109 0701 	add.w	r7, r9, #1
   13b60:	b2bf      	uxth	r7, r7
	ticks_drift_minus = 0U;
   13b62:	e9cd 6608 	strd	r6, r6, [sp, #32]
	if (done->extra.trx_cnt) {
   13b66:	b183      	cbz	r3, 13b8a <ull_conn_done+0xce>
		} else if (lll->role) {
   13b68:	f995 302d 	ldrsb.w	r3, [r5, #45]	; 0x2d
   13b6c:	2b00      	cmp	r3, #0
   13b6e:	da09      	bge.n	13b84 <ull_conn_done+0xc8>
			ull_slave_done(done, &ticks_drift_plus,
   13b70:	aa08      	add	r2, sp, #32
   13b72:	a909      	add	r1, sp, #36	; 0x24
   13b74:	4640      	mov	r0, r8
   13b76:	f7ee fc17 	bl	23a8 <ull_slave_done>
			if (conn->tx_head || memq_peek(lll->memq_tx.head,
   13b7a:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
   13b7e:	b15b      	cbz	r3, 13b98 <ull_conn_done+0xdc>
				lll->latency_event = 0;
   13b80:	2300      	movs	r3, #0
				lll->latency_event = lll->latency;
   13b82:	84ab      	strh	r3, [r5, #36]	; 0x24
		conn->connect_expire = 0U;
   13b84:	2300      	movs	r3, #0
   13b86:	f8a4 30c4 	strh.w	r3, [r4, #196]	; 0xc4
	if (done->extra.crc_valid) {
   13b8a:	f898 302a 	ldrb.w	r3, [r8, #42]	; 0x2a
   13b8e:	b183      	cbz	r3, 13bb2 <ull_conn_done+0xf6>
		conn->supervision_expire = 0U;
   13b90:	2300      	movs	r3, #0
			conn->supervision_expire = conn->supervision_reload;
   13b92:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
   13b96:	e014      	b.n	13bc2 <ull_conn_done+0x106>
			if (conn->tx_head || memq_peek(lll->memq_tx.head,
   13b98:	4632      	mov	r2, r6
   13b9a:	e9d5 0116 	ldrd	r0, r1, [r5, #88]	; 0x58
   13b9e:	f009 f9ca 	bl	1cf36 <memq_peek>
   13ba2:	2800      	cmp	r0, #0
   13ba4:	d1ec      	bne.n	13b80 <ull_conn_done+0xc4>
			} else if (lll->slave.latency_enabled) {
   13ba6:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
   13baa:	07db      	lsls	r3, r3, #31
   13bac:	d5ea      	bpl.n	13b84 <ull_conn_done+0xc8>
				lll->latency_event = lll->latency;
   13bae:	8c2b      	ldrh	r3, [r5, #32]
   13bb0:	e7e7      	b.n	13b82 <ull_conn_done+0xc6>
	else if (conn->connect_expire) {
   13bb2:	f8b4 30c4 	ldrh.w	r3, [r4, #196]	; 0xc4
   13bb6:	b3c3      	cbz	r3, 13c2a <ull_conn_done+0x16e>
		if (conn->connect_expire > elapsed_event) {
   13bb8:	42bb      	cmp	r3, r7
   13bba:	d934      	bls.n	13c26 <ull_conn_done+0x16a>
			conn->connect_expire -= elapsed_event;
   13bbc:	1bdb      	subs	r3, r3, r7
   13bbe:	f8a4 30c4 	strh.w	r3, [r4, #196]	; 0xc4
	if (conn->supervision_expire) {
   13bc2:	f8b4 30c8 	ldrh.w	r3, [r4, #200]	; 0xc8
   13bc6:	b1eb      	cbz	r3, 13c04 <ull_conn_done+0x148>
		if (conn->supervision_expire > elapsed_event) {
   13bc8:	42bb      	cmp	r3, r7
   13bca:	d935      	bls.n	13c38 <ull_conn_done+0x17c>
			conn->supervision_expire -= elapsed_event;
   13bcc:	1bdb      	subs	r3, r3, r7
   13bce:	b29b      	uxth	r3, r3
			lll->latency_event = 0;
   13bd0:	2200      	movs	r2, #0
			if (conn->supervision_expire <= 6U) {
   13bd2:	2b06      	cmp	r3, #6
			conn->supervision_expire -= elapsed_event;
   13bd4:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
			lll->latency_event = 0;
   13bd8:	84aa      	strh	r2, [r5, #36]	; 0x24
			if (conn->supervision_expire <= 6U) {
   13bda:	d92f      	bls.n	13c3c <ull_conn_done+0x180>
			else if (lll->role) {
   13bdc:	f995 302d 	ldrsb.w	r3, [r5, #45]	; 0x2d
   13be0:	4293      	cmp	r3, r2
   13be2:	da0f      	bge.n	13c04 <ull_conn_done+0x148>
				if (latency_event) {
   13be4:	f1b9 0f00 	cmp.w	r9, #0
   13be8:	d128      	bne.n	13c3c <ull_conn_done+0x180>
					force = conn->slave.force & 0x01;
   13bea:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
					conn->slave.force >>= 1;
   13bee:	085a      	lsrs	r2, r3, #1
					if (force) {
   13bf0:	f013 0301 	ands.w	r3, r3, #1
						conn->slave.force |= BIT(31);
   13bf4:	bf17      	itett	ne
   13bf6:	f042 4200 	orrne.w	r2, r2, #2147483648	; 0x80000000
					conn->slave.force >>= 1;
   13bfa:	f8c4 20e0 	streq.w	r2, [r4, #224]	; 0xe0
						conn->slave.force |= BIT(31);
   13bfe:	f8c4 20e0 	strne.w	r2, [r4, #224]	; 0xe0
					force = conn->slave.force & 0x01;
   13c02:	461e      	movne	r6, r3
	if (conn->procedure_expire != 0U) {
   13c04:	f8b4 30cc 	ldrh.w	r3, [r4, #204]	; 0xcc
   13c08:	b123      	cbz	r3, 13c14 <ull_conn_done+0x158>
		if (conn->procedure_expire > elapsed_event) {
   13c0a:	42bb      	cmp	r3, r7
   13c0c:	d918      	bls.n	13c40 <ull_conn_done+0x184>
			conn->procedure_expire -= elapsed_event;
   13c0e:	1bdb      	subs	r3, r3, r7
   13c10:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	if (conn->apto_expire != 0U) {
   13c14:	f8b4 30d4 	ldrh.w	r3, [r4, #212]	; 0xd4
   13c18:	b323      	cbz	r3, 13c64 <ull_conn_done+0x1a8>
		if (conn->apto_expire > elapsed_event) {
   13c1a:	42bb      	cmp	r3, r7
   13c1c:	d912      	bls.n	13c44 <ull_conn_done+0x188>
			conn->apto_expire -= elapsed_event;
   13c1e:	1bdb      	subs	r3, r3, r7
				conn->apto_expire = 1U;
   13c20:	f8a4 30d4 	strh.w	r3, [r4, #212]	; 0xd4
   13c24:	e01e      	b.n	13c64 <ull_conn_done+0x1a8>
			conn_cleanup(conn, BT_HCI_ERR_CONN_FAIL_TO_ESTAB);
   13c26:	213e      	movs	r1, #62	; 0x3e
   13c28:	e75f      	b.n	13aea <ull_conn_done+0x2e>
		if (!conn->supervision_expire) {
   13c2a:	f8b4 30c8 	ldrh.w	r3, [r4, #200]	; 0xc8
   13c2e:	2b00      	cmp	r3, #0
   13c30:	d1c7      	bne.n	13bc2 <ull_conn_done+0x106>
			conn->supervision_expire = conn->supervision_reload;
   13c32:	f8b4 30c6 	ldrh.w	r3, [r4, #198]	; 0xc6
   13c36:	e7ac      	b.n	13b92 <ull_conn_done+0xd6>
			conn_cleanup(conn, BT_HCI_ERR_CONN_TIMEOUT);
   13c38:	2108      	movs	r1, #8
   13c3a:	e756      	b.n	13aea <ull_conn_done+0x2e>
				force = 1U;
   13c3c:	2601      	movs	r6, #1
   13c3e:	e7e1      	b.n	13c04 <ull_conn_done+0x148>
			conn_cleanup(conn, BT_HCI_ERR_LL_RESP_TIMEOUT);
   13c40:	2122      	movs	r1, #34	; 0x22
   13c42:	e752      	b.n	13aea <ull_conn_done+0x2e>
			rx = ll_pdu_rx_alloc();
   13c44:	f7fc fba6 	bl	10394 <ll_pdu_rx_alloc>
			if (rx) {
   13c48:	4601      	mov	r1, r0
   13c4a:	b320      	cbz	r0, 13c96 <ull_conn_done+0x1da>
				conn->apto_expire = 0U;
   13c4c:	2300      	movs	r3, #0
   13c4e:	f8a4 30d4 	strh.w	r3, [r4, #212]	; 0xd4
				rx->handle = lll->handle;
   13c52:	8bab      	ldrh	r3, [r5, #28]
   13c54:	80c3      	strh	r3, [r0, #6]
				rx->type = NODE_RX_TYPE_APTO;
   13c56:	230c      	movs	r3, #12
   13c58:	7103      	strb	r3, [r0, #4]
				ll_rx_put(rx->link, rx);
   13c5a:	6800      	ldr	r0, [r0, #0]
   13c5c:	f7fc fb72 	bl	10344 <ll_rx_put>
				ll_rx_sched();
   13c60:	f7fc fb7a 	bl	10358 <ll_rx_sched>
	if (conn->appto_expire != 0U) {
   13c64:	f8b4 20d0 	ldrh.w	r2, [r4, #208]	; 0xd0
   13c68:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   13c6c:	f894 10e9 	ldrb.w	r1, [r4, #233]	; 0xe9
   13c70:	b122      	cbz	r2, 13c7c <ull_conn_done+0x1c0>
		if (conn->appto_expire > elapsed_event) {
   13c72:	42ba      	cmp	r2, r7
   13c74:	d911      	bls.n	13c9a <ull_conn_done+0x1de>
			conn->appto_expire -= elapsed_event;
   13c76:	1bd7      	subs	r7, r2, r7
   13c78:	f8a4 70d0 	strh.w	r7, [r4, #208]	; 0xd0
	if ((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   13c7c:	1a5b      	subs	r3, r3, r1
   13c7e:	f003 0303 	and.w	r3, r3, #3
   13c82:	2b02      	cmp	r3, #2
   13c84:	d118      	bne.n	13cb8 <ull_conn_done+0x1fc>
	    ((conn->llcp_type == LLCP_CONN_UPD) ||
   13c86:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
	if ((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   13c8a:	3b01      	subs	r3, #1
   13c8c:	2b01      	cmp	r3, #1
		lll->latency_event = 0;
   13c8e:	bf9c      	itt	ls
   13c90:	2300      	movls	r3, #0
   13c92:	84ab      	strhls	r3, [r5, #36]	; 0x24
   13c94:	e010      	b.n	13cb8 <ull_conn_done+0x1fc>
				conn->apto_expire = 1U;
   13c96:	2301      	movs	r3, #1
   13c98:	e7c2      	b.n	13c20 <ull_conn_done+0x164>
			conn->appto_expire = 0U;
   13c9a:	2200      	movs	r2, #0
   13c9c:	f8a4 20d0 	strh.w	r2, [r4, #208]	; 0xd0
			if ((conn->procedure_expire == 0U) &&
   13ca0:	f8b4 20cc 	ldrh.w	r2, [r4, #204]	; 0xcc
   13ca4:	2a00      	cmp	r2, #0
   13ca6:	d1e9      	bne.n	13c7c <ull_conn_done+0x1c0>
   13ca8:	428b      	cmp	r3, r1
   13caa:	d1e7      	bne.n	13c7c <ull_conn_done+0x1c0>
				conn->llcp_type = LLCP_PING;
   13cac:	2205      	movs	r2, #5
				conn->llcp_ack -= 2U;
   13cae:	3b02      	subs	r3, #2
				conn->llcp_type = LLCP_PING;
   13cb0:	f884 20ea 	strb.w	r2, [r4, #234]	; 0xea
				conn->llcp_ack -= 2U;
   13cb4:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
	if ((force) || (latency_event != lll->latency_event)) {
   13cb8:	8ca9      	ldrh	r1, [r5, #36]	; 0x24
   13cba:	b90e      	cbnz	r6, 13cc0 <ull_conn_done+0x204>
   13cbc:	4589      	cmp	r9, r1
   13cbe:	d031      	beq.n	13d24 <ull_conn_done+0x268>
		lazy = lll->latency_event + 1;
   13cc0:	3101      	adds	r1, #1
   13cc2:	b289      	uxth	r1, r1
	if ((ticks_drift_plus != 0U) || (ticks_drift_minus != 0U) ||
   13cc4:	e9dd 7308 	ldrd	r7, r3, [sp, #32]
   13cc8:	ea53 0207 	orrs.w	r2, r3, r7
   13ccc:	d103      	bne.n	13cd6 <ull_conn_done+0x21a>
   13cce:	b911      	cbnz	r1, 13cd6 <ull_conn_done+0x21a>
	    (lazy != 0U) || (force != 0U)) {
   13cd0:	2e00      	cmp	r6, #0
   13cd2:	f43f af0d 	beq.w	13af0 <ull_conn_done+0x34>
		u8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
   13cd6:	7f2a      	ldrb	r2, [r5, #28]
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   13cd8:	4813      	ldr	r0, [pc, #76]	; (13d28 <ull_conn_done+0x26c>)
		struct ll_conn *conn = lll->hdr.parent;
   13cda:	68ec      	ldr	r4, [r5, #12]
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   13cdc:	9406      	str	r4, [sp, #24]
   13cde:	e9cd 6004 	strd	r6, r0, [sp, #16]
		u8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
   13ce2:	3203      	adds	r2, #3
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   13ce4:	2000      	movs	r0, #0
   13ce6:	9103      	str	r1, [sp, #12]
   13ce8:	e9cd 0001 	strd	r0, r0, [sp, #4]
   13cec:	9700      	str	r7, [sp, #0]
   13cee:	b2d2      	uxtb	r2, r2
   13cf0:	2101      	movs	r1, #1
   13cf2:	f7fa fbbb 	bl	e46c <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   13cf6:	f030 0302 	bics.w	r3, r0, #2
   13cfa:	f43f aef9 	beq.w	13af0 <ull_conn_done+0x34>
   13cfe:	f7fc fbd3 	bl	104a8 <ull_disable_mark_get>
   13d02:	4284      	cmp	r4, r0
   13d04:	f43f aef4 	beq.w	13af0 <ull_conn_done+0x34>
   13d08:	f240 43cb 	movw	r3, #1227	; 0x4cb
   13d0c:	4a07      	ldr	r2, [pc, #28]	; (13d2c <ull_conn_done+0x270>)
   13d0e:	4908      	ldr	r1, [pc, #32]	; (13d30 <ull_conn_done+0x274>)
   13d10:	4808      	ldr	r0, [pc, #32]	; (13d34 <ull_conn_done+0x278>)
   13d12:	f005 fb2f 	bl	19374 <printk>
   13d16:	4040      	eors	r0, r0
   13d18:	f380 8811 	msr	BASEPRI, r0
   13d1c:	f04f 0003 	mov.w	r0, #3
   13d20:	df02      	svc	2
   13d22:	e6e5      	b.n	13af0 <ull_conn_done+0x34>
	lazy = 0U;
   13d24:	4631      	mov	r1, r6
   13d26:	e7cd      	b.n	13cc4 <ull_conn_done+0x208>
   13d28:	00011f39 	.word	0x00011f39
   13d2c:	00021f06 	.word	0x00021f06
   13d30:	00021f59 	.word	0x00021f59
   13d34:	00020aa4 	.word	0x00020aa4

00013d38 <ull_conn_tx_demux>:
{
   13d38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
   13d3c:	4e20      	ldr	r6, [pc, #128]	; (13dc0 <ull_conn_tx_demux+0x88>)
{
   13d3e:	4604      	mov	r4, r0
   13d40:	4637      	mov	r7, r6
	return (void *)(fifo + first * size);
   13d42:	1d35      	adds	r5, r6, #4
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
   13d44:	78b3      	ldrb	r3, [r6, #2]
	if (first == last) {
   13d46:	78f1      	ldrb	r1, [r6, #3]
   13d48:	7832      	ldrb	r2, [r6, #0]
   13d4a:	4299      	cmp	r1, r3
   13d4c:	d02d      	beq.n	13daa <ull_conn_tx_demux+0x72>
	return (void *)(fifo + first * size);
   13d4e:	fb13 f302 	smulbb	r3, r3, r2
		if (!lll_tx) {
   13d52:	eb15 0803 	adds.w	r8, r5, r3
   13d56:	d028      	beq.n	13daa <ull_conn_tx_demux+0x72>
		conn = ll_connected_get(lll_tx->handle);
   13d58:	5ae8      	ldrh	r0, [r5, r3]
   13d5a:	f009 fc63 	bl	1d624 <ll_connected_get>
		if (conn) {
   13d5e:	f8d8 1004 	ldr.w	r1, [r8, #4]
   13d62:	b320      	cbz	r0, 13dae <ull_conn_tx_demux+0x76>
			tx->next = NULL;
   13d64:	2300      	movs	r3, #0
   13d66:	600b      	str	r3, [r1, #0]
			if (!conn->tx_data) {
   13d68:	f8d0 31bc 	ldr.w	r3, [r0, #444]	; 0x1bc
   13d6c:	b943      	cbnz	r3, 13d80 <ull_conn_tx_demux+0x48>
				if (!conn->tx_head) {
   13d6e:	f8d0 31b0 	ldr.w	r3, [r0, #432]	; 0x1b0
				conn->tx_data = tx;
   13d72:	f8c0 11bc 	str.w	r1, [r0, #444]	; 0x1bc
				if (!conn->tx_head) {
   13d76:	b91b      	cbnz	r3, 13d80 <ull_conn_tx_demux+0x48>
					conn->tx_head = tx;
   13d78:	f8c0 11b0 	str.w	r1, [r0, #432]	; 0x1b0
					conn->tx_data_last = NULL;
   13d7c:	f8c0 31c0 	str.w	r3, [r0, #448]	; 0x1c0
			if (conn->tx_data_last) {
   13d80:	f8d0 31c0 	ldr.w	r3, [r0, #448]	; 0x1c0
   13d84:	b103      	cbz	r3, 13d88 <ull_conn_tx_demux+0x50>
				conn->tx_data_last->next = tx;
   13d86:	6019      	str	r1, [r3, #0]
			conn->tx_data_last = tx;
   13d88:	f8c0 11c0 	str.w	r1, [r0, #448]	; 0x1c0
	u8_t _first = *first; /* Copy read-index */
   13d8c:	78bb      	ldrb	r3, [r7, #2]
	if (_first == last) {
   13d8e:	78f9      	ldrb	r1, [r7, #3]
		MFIFO_DEQUEUE(conn_tx);
   13d90:	787a      	ldrb	r2, [r7, #1]
   13d92:	4299      	cmp	r1, r3
   13d94:	d005      	beq.n	13da2 <ull_conn_tx_demux+0x6a>
	_first += 1U;
   13d96:	3301      	adds	r3, #1
   13d98:	b2db      	uxtb	r3, r3
		_first = 0U;
   13d9a:	429a      	cmp	r2, r3
   13d9c:	bf08      	it	eq
   13d9e:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   13da0:	70bb      	strb	r3, [r7, #2]
	} while (--count);
   13da2:	3c01      	subs	r4, #1
   13da4:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
   13da8:	d1cc      	bne.n	13d44 <ull_conn_tx_demux+0xc>
}
   13daa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			p->ll_id = PDU_DATA_LLID_RESV;
   13dae:	790b      	ldrb	r3, [r1, #4]
   13db0:	f360 0301 	bfi	r3, r0, #0, #2
   13db4:	710b      	strb	r3, [r1, #4]
			ll_tx_ack_put(0xFFFF, tx);
   13db6:	f64f 70ff 	movw	r0, #65535	; 0xffff
   13dba:	f7fc fb01 	bl	103c0 <ll_tx_ack_put>
   13dbe:	e7e5      	b.n	13d8c <ull_conn_tx_demux+0x54>
   13dc0:	20005934 	.word	0x20005934

00013dc4 <ull_conn_tx_lll_enqueue>:
{
   13dc4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		link = mem_acquire(&mem_link_tx.free);
   13dc8:	4e56      	ldr	r6, [pc, #344]	; (13f24 <ull_conn_tx_lll_enqueue+0x160>)
		LL_ASSERT(link);
   13dca:	4f57      	ldr	r7, [pc, #348]	; (13f28 <ull_conn_tx_lll_enqueue+0x164>)
   13dcc:	f8df 8160 	ldr.w	r8, [pc, #352]	; 13f30 <ull_conn_tx_lll_enqueue+0x16c>
{
   13dd0:	4604      	mov	r4, r0
   13dd2:	460d      	mov	r5, r1
	while (conn->tx_head &&
   13dd4:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
   13dd8:	b1f3      	cbz	r3, 13e18 <ull_conn_tx_lll_enqueue+0x54>
		 !conn->llcp_phy.pause_tx &&
   13dda:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
	while (conn->tx_head &&
   13dde:	07d1      	lsls	r1, r2, #31
   13de0:	f100 809a 	bmi.w	13f18 <ull_conn_tx_lll_enqueue+0x154>
		 !conn->llcp_enc.pause_tx &&
   13de4:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
		 !conn->llcp_phy.pause_tx &&
   13de8:	0792      	lsls	r2, r2, #30
   13dea:	f100 8095 	bmi.w	13f18 <ull_conn_tx_lll_enqueue+0x154>
	if ((pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
   13dee:	791a      	ldrb	r2, [r3, #4]
   13df0:	f002 0203 	and.w	r2, r2, #3
   13df4:	2a03      	cmp	r2, #3
   13df6:	d10e      	bne.n	13e16 <ull_conn_tx_lll_enqueue+0x52>
	    ((pdu_data_tx->llctrl.opcode ==
   13df8:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
   13dfa:	2a03      	cmp	r2, #3
   13dfc:	d001      	beq.n	13e02 <ull_conn_tx_lll_enqueue+0x3e>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) ||
   13dfe:	2a0a      	cmp	r2, #10
   13e00:	d109      	bne.n	13e16 <ull_conn_tx_lll_enqueue+0x52>
		if (((conn->llcp_req != conn->llcp_ack) &&
   13e02:	f894 10e9 	ldrb.w	r1, [r4, #233]	; 0xe9
   13e06:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
   13e0a:	428a      	cmp	r2, r1
   13e0c:	d041      	beq.n	13e92 <ull_conn_tx_lll_enqueue+0xce>
   13e0e:	f894 20ea 	ldrb.w	r2, [r4, #234]	; 0xea
   13e12:	2a03      	cmp	r2, #3
   13e14:	d15b      	bne.n	13ece <ull_conn_tx_lll_enqueue+0x10a>
		(!pause_tx && (conn->tx_head == conn->tx_ctrl))) && count--) {
   13e16:	b90d      	cbnz	r5, 13e1c <ull_conn_tx_lll_enqueue+0x58>
}
   13e18:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		tx = tx_ull_dequeue(conn, conn->tx_head);
   13e1c:	f8d4 11b0 	ldr.w	r1, [r4, #432]	; 0x1b0
   13e20:	4620      	mov	r0, r4
   13e22:	f009 fb7f 	bl	1d524 <tx_ull_dequeue>
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
   13e26:	7903      	ldrb	r3, [r0, #4]
   13e28:	f003 0303 	and.w	r3, r3, #3
   13e2c:	2b03      	cmp	r3, #3
		tx = tx_ull_dequeue(conn, conn->tx_head);
   13e2e:	4681      	mov	r9, r0
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
   13e30:	d114      	bne.n	13e5c <ull_conn_tx_lll_enqueue+0x98>
	switch (pdu_tx->llctrl.opcode) {
   13e32:	79c3      	ldrb	r3, [r0, #7]
   13e34:	3b03      	subs	r3, #3
   13e36:	2b08      	cmp	r3, #8
   13e38:	d810      	bhi.n	13e5c <ull_conn_tx_lll_enqueue+0x98>
   13e3a:	e8df f003 	tbb	[pc, r3]
   13e3e:	0909      	.short	0x0909
   13e40:	0f0f0f0f 	.word	0x0f0f0f0f
   13e44:	090f      	.short	0x090f
   13e46:	05          	.byte	0x05
   13e47:	00          	.byte	0x00
		if (!conn->lll.role) {
   13e48:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   13e4c:	2b00      	cmp	r3, #0
   13e4e:	da05      	bge.n	13e5c <ull_conn_tx_lll_enqueue+0x98>
		conn->llcp_enc.pause_tx = 1U;
   13e50:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   13e54:	f043 0302 	orr.w	r3, r3, #2
   13e58:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		link = mem_acquire(&mem_link_tx.free);
   13e5c:	4630      	mov	r0, r6
   13e5e:	f009 f805 	bl	1ce6c <mem_acquire>
		LL_ASSERT(link);
   13e62:	4682      	mov	sl, r0
   13e64:	b960      	cbnz	r0, 13e80 <ull_conn_tx_lll_enqueue+0xbc>
   13e66:	f240 5345 	movw	r3, #1349	; 0x545
   13e6a:	463a      	mov	r2, r7
   13e6c:	4641      	mov	r1, r8
   13e6e:	482f      	ldr	r0, [pc, #188]	; (13f2c <ull_conn_tx_lll_enqueue+0x168>)
   13e70:	f005 fa80 	bl	19374 <printk>
   13e74:	4040      	eors	r0, r0
   13e76:	f380 8811 	msr	BASEPRI, r0
   13e7a:	f04f 0003 	mov.w	r0, #3
   13e7e:	df02      	svc	2
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
   13e80:	f104 026c 	add.w	r2, r4, #108	; 0x6c
   13e84:	4649      	mov	r1, r9
   13e86:	4650      	mov	r0, sl
   13e88:	3d01      	subs	r5, #1
   13e8a:	f009 f84d 	bl	1cf28 <memq_enqueue>
   13e8e:	b2ed      	uxtb	r5, r5
   13e90:	e7a0      	b.n	13dd4 <ull_conn_tx_lll_enqueue+0x10>
		    ((conn->llcp_req == conn->llcp_ack) &&
   13e92:	f894 0119 	ldrb.w	r0, [r4, #281]	; 0x119
   13e96:	f894 1118 	ldrb.w	r1, [r4, #280]	; 0x118
   13e9a:	4288      	cmp	r0, r1
   13e9c:	d117      	bne.n	13ece <ull_conn_tx_lll_enqueue+0x10a>
		     ((conn->llcp_feature.ack != conn->llcp_feature.req) ||
   13e9e:	f894 0121 	ldrb.w	r0, [r4, #289]	; 0x121
   13ea2:	f894 1120 	ldrb.w	r1, [r4, #288]	; 0x120
   13ea6:	4288      	cmp	r0, r1
   13ea8:	d111      	bne.n	13ece <ull_conn_tx_lll_enqueue+0x10a>
		      (conn->llcp_version.ack != conn->llcp_version.req) ||
   13eaa:	f894 0171 	ldrb.w	r0, [r4, #369]	; 0x171
   13eae:	f894 1170 	ldrb.w	r1, [r4, #368]	; 0x170
   13eb2:	4288      	cmp	r0, r1
   13eb4:	d10b      	bne.n	13ece <ull_conn_tx_lll_enqueue+0x10a>
		       conn->llcp_conn_param.req) ||
   13eb6:	f894 0199 	ldrb.w	r0, [r4, #409]	; 0x199
   13eba:	f894 1198 	ldrb.w	r1, [r4, #408]	; 0x198
   13ebe:	4288      	cmp	r0, r1
   13ec0:	d105      	bne.n	13ece <ull_conn_tx_lll_enqueue+0x10a>
		      (conn->llcp_phy.ack != conn->llcp_phy.req) ||
   13ec2:	f894 01a9 	ldrb.w	r0, [r4, #425]	; 0x1a9
   13ec6:	f894 11a8 	ldrb.w	r1, [r4, #424]	; 0x1a8
   13eca:	4288      	cmp	r0, r1
   13ecc:	d016      	beq.n	13efc <ull_conn_tx_lll_enqueue+0x138>
			if ((tx->next != NULL) &&
   13ece:	681a      	ldr	r2, [r3, #0]
   13ed0:	2a00      	cmp	r2, #0
   13ed2:	d0a1      	beq.n	13e18 <ull_conn_tx_lll_enqueue+0x54>
   13ed4:	f8d4 11b4 	ldr.w	r1, [r4, #436]	; 0x1b4
   13ed8:	428a      	cmp	r2, r1
   13eda:	d19d      	bne.n	13e18 <ull_conn_tx_lll_enqueue+0x54>
				conn->tx_head = tx->next;
   13edc:	f8c4 21b0 	str.w	r2, [r4, #432]	; 0x1b0
				tx->next = conn->tx_ctrl_last->next;
   13ee0:	f8d4 21b8 	ldr.w	r2, [r4, #440]	; 0x1b8
   13ee4:	6811      	ldr	r1, [r2, #0]
   13ee6:	6019      	str	r1, [r3, #0]
				conn->tx_ctrl_last->next = tx;
   13ee8:	6013      	str	r3, [r2, #0]
				if (!conn->tx_data_last) {
   13eea:	f8d4 21c0 	ldr.w	r2, [r4, #448]	; 0x1c0
				conn->tx_data = tx;
   13eee:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
				if (!conn->tx_data_last) {
   13ef2:	2a00      	cmp	r2, #0
   13ef4:	d18f      	bne.n	13e16 <ull_conn_tx_lll_enqueue+0x52>
					conn->tx_data_last = tx;
   13ef6:	f8c4 31c0 	str.w	r3, [r4, #448]	; 0x1c0
   13efa:	e78c      	b.n	13e16 <ull_conn_tx_lll_enqueue+0x52>
			conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
   13efc:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   13f00:	2101      	movs	r1, #1
   13f02:	f361 0301 	bfi	r3, r1, #0, #2
   13f06:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
			conn->llcp_ack -= 2U;
   13f0a:	3a02      	subs	r2, #2
			conn->llcp_type = LLCP_ENCRYPTION;
   13f0c:	2303      	movs	r3, #3
   13f0e:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
			conn->llcp_ack -= 2U;
   13f12:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
   13f16:	e77e      	b.n	13e16 <ull_conn_tx_lll_enqueue+0x52>
		(!pause_tx && (conn->tx_head == conn->tx_ctrl))) && count--) {
   13f18:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
   13f1c:	4293      	cmp	r3, r2
   13f1e:	f43f af7a 	beq.w	13e16 <ull_conn_tx_lll_enqueue+0x52>
   13f22:	e779      	b.n	13e18 <ull_conn_tx_lll_enqueue+0x54>
   13f24:	20001458 	.word	0x20001458
   13f28:	00021f06 	.word	0x00021f06
   13f2c:	00020aa4 	.word	0x00020aa4
   13f30:	00021fdb 	.word	0x00021fdb

00013f34 <ull_conn_link_tx_release>:
	mem_release(link, &mem_link_tx.free);
   13f34:	4901      	ldr	r1, [pc, #4]	; (13f3c <ull_conn_link_tx_release+0x8>)
   13f36:	f008 bfb2 	b.w	1ce9e <mem_release>
   13f3a:	bf00      	nop
   13f3c:	20001458 	.word	0x20001458

00013f40 <ull_conn_ack_last_idx_get>:
}
   13f40:	4b01      	ldr	r3, [pc, #4]	; (13f48 <ull_conn_ack_last_idx_get+0x8>)
   13f42:	78d8      	ldrb	r0, [r3, #3]
   13f44:	4770      	bx	lr
   13f46:	bf00      	nop
   13f48:	200058f0 	.word	0x200058f0

00013f4c <ull_conn_ack_peek>:
{
   13f4c:	b570      	push	{r4, r5, r6, lr}
	lll_tx = MFIFO_DEQUEUE_GET(conn_ack);
   13f4e:	4b0a      	ldr	r3, [pc, #40]	; (13f78 <ull_conn_ack_peek+0x2c>)
   13f50:	789c      	ldrb	r4, [r3, #2]
   13f52:	78dd      	ldrb	r5, [r3, #3]
	if (first == last) {
   13f54:	42ac      	cmp	r4, r5
{
   13f56:	4606      	mov	r6, r0
	lll_tx = MFIFO_DEQUEUE_GET(conn_ack);
   13f58:	7818      	ldrb	r0, [r3, #0]
   13f5a:	d00b      	beq.n	13f74 <ull_conn_ack_peek+0x28>
	return (void *)(fifo + first * size);
   13f5c:	3304      	adds	r3, #4
   13f5e:	fb14 f400 	smulbb	r4, r4, r0
	if (!lll_tx) {
   13f62:	1918      	adds	r0, r3, r4
   13f64:	d005      	beq.n	13f72 <ull_conn_ack_peek+0x26>
	*ack_last = mfifo_conn_ack.l;
   13f66:	7035      	strb	r5, [r6, #0]
	*handle = lll_tx->handle;
   13f68:	5b1b      	ldrh	r3, [r3, r4]
   13f6a:	800b      	strh	r3, [r1, #0]
	*tx = lll_tx->node;
   13f6c:	6843      	ldr	r3, [r0, #4]
   13f6e:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
   13f70:	6818      	ldr	r0, [r3, #0]
}
   13f72:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
   13f74:	2000      	movs	r0, #0
   13f76:	e7fc      	b.n	13f72 <ull_conn_ack_peek+0x26>
   13f78:	200058f0 	.word	0x200058f0

00013f7c <ull_conn_ack_by_last_peek>:
{
   13f7c:	b530      	push	{r4, r5, lr}
	lll_tx = mfifo_dequeue_get(mfifo_conn_ack.m, mfifo_conn_ack.s,
   13f7e:	4b09      	ldr	r3, [pc, #36]	; (13fa4 <ull_conn_ack_by_last_peek+0x28>)
   13f80:	789c      	ldrb	r4, [r3, #2]
   13f82:	781d      	ldrb	r5, [r3, #0]
	if (first == last) {
   13f84:	4284      	cmp	r4, r0
   13f86:	d00a      	beq.n	13f9e <ull_conn_ack_by_last_peek+0x22>
	return (void *)(fifo + first * size);
   13f88:	3304      	adds	r3, #4
   13f8a:	fb14 f405 	smulbb	r4, r4, r5
	if (!lll_tx) {
   13f8e:	1918      	adds	r0, r3, r4
   13f90:	d004      	beq.n	13f9c <ull_conn_ack_by_last_peek+0x20>
	*handle = lll_tx->handle;
   13f92:	5b1b      	ldrh	r3, [r3, r4]
   13f94:	800b      	strh	r3, [r1, #0]
	*tx = lll_tx->node;
   13f96:	6843      	ldr	r3, [r0, #4]
   13f98:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
   13f9a:	6818      	ldr	r0, [r3, #0]
}
   13f9c:	bd30      	pop	{r4, r5, pc}
		return NULL;
   13f9e:	2000      	movs	r0, #0
   13fa0:	e7fc      	b.n	13f9c <ull_conn_ack_by_last_peek+0x20>
   13fa2:	bf00      	nop
   13fa4:	200058f0 	.word	0x200058f0

00013fa8 <ull_conn_ack_dequeue>:
{
   13fa8:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(conn_ack);
   13faa:	4a09      	ldr	r2, [pc, #36]	; (13fd0 <ull_conn_ack_dequeue+0x28>)
	u8_t _first = *first; /* Copy read-index */
   13fac:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
   13fae:	78d0      	ldrb	r0, [r2, #3]
   13fb0:	7811      	ldrb	r1, [r2, #0]
   13fb2:	7854      	ldrb	r4, [r2, #1]
   13fb4:	4298      	cmp	r0, r3
   13fb6:	d009      	beq.n	13fcc <ull_conn_ack_dequeue+0x24>
	mem = *((void **)(fifo + _first * size));
   13fb8:	fb03 2101 	mla	r1, r3, r1, r2
	_first += 1U;
   13fbc:	3301      	adds	r3, #1
   13fbe:	b2db      	uxtb	r3, r3
		_first = 0U;
   13fc0:	429c      	cmp	r4, r3
   13fc2:	bf08      	it	eq
   13fc4:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
   13fc6:	6848      	ldr	r0, [r1, #4]
	*first = _first; /* Write back read-index */
   13fc8:	7093      	strb	r3, [r2, #2]
}
   13fca:	bd10      	pop	{r4, pc}
		return NULL;
   13fcc:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(conn_ack);
   13fce:	e7fc      	b.n	13fca <ull_conn_ack_dequeue+0x22>
   13fd0:	200058f0 	.word	0x200058f0

00013fd4 <ull_conn_lll_ack_enqueue>:
{
   13fd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   13fd6:	4a12      	ldr	r2, [pc, #72]	; (14020 <ull_conn_lll_ack_enqueue+0x4c>)
   13fd8:	78d4      	ldrb	r4, [r2, #3]
	if (last == count) {
   13fda:	7857      	ldrb	r7, [r2, #1]
   13fdc:	7895      	ldrb	r5, [r2, #2]
   13fde:	7816      	ldrb	r6, [r2, #0]
	last = last + 1;
   13fe0:	1c63      	adds	r3, r4, #1
   13fe2:	b2db      	uxtb	r3, r3
		last = 0U;
   13fe4:	429f      	cmp	r7, r3
   13fe6:	bf08      	it	eq
   13fe8:	2300      	moveq	r3, #0
	if (last == first) {
   13fea:	429d      	cmp	r5, r3
   13fec:	d004      	beq.n	13ff8 <ull_conn_lll_ack_enqueue+0x24>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   13fee:	1d15      	adds	r5, r2, #4
   13ff0:	fb14 f406 	smulbb	r4, r4, r6
	LL_ASSERT(lll_tx);
   13ff4:	192e      	adds	r6, r5, r4
   13ff6:	d10f      	bne.n	14018 <ull_conn_lll_ack_enqueue+0x44>
   13ff8:	f240 5383 	movw	r3, #1411	; 0x583
   13ffc:	4a09      	ldr	r2, [pc, #36]	; (14024 <ull_conn_lll_ack_enqueue+0x50>)
   13ffe:	490a      	ldr	r1, [pc, #40]	; (14028 <ull_conn_lll_ack_enqueue+0x54>)
   14000:	480a      	ldr	r0, [pc, #40]	; (1402c <ull_conn_lll_ack_enqueue+0x58>)
   14002:	f005 f9b7 	bl	19374 <printk>
   14006:	4040      	eors	r0, r0
   14008:	f380 8811 	msr	BASEPRI, r0
   1400c:	f04f 0003 	mov.w	r0, #3
   14010:	df02      	svc	2
	lll_tx->handle = handle;
   14012:	2300      	movs	r3, #0
   14014:	801b      	strh	r3, [r3, #0]
   14016:	deff      	udf	#255	; 0xff
   14018:	5328      	strh	r0, [r5, r4]
	*last = idx; /* Commit: Update write index */
   1401a:	70d3      	strb	r3, [r2, #3]
	lll_tx->node = tx;
   1401c:	6071      	str	r1, [r6, #4]
}
   1401e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   14020:	200058f0 	.word	0x200058f0
   14024:	00021f06 	.word	0x00021f06
   14028:	00021f52 	.word	0x00021f52
   1402c:	00020aa4 	.word	0x00020aa4

00014030 <ull_conn_tx_ack>:
{
   14030:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	LL_ASSERT(pdu_tx->len);
   14034:	7953      	ldrb	r3, [r2, #5]
{
   14036:	4606      	mov	r6, r0
   14038:	460f      	mov	r7, r1
   1403a:	4615      	mov	r5, r2
	LL_ASSERT(pdu_tx->len);
   1403c:	b963      	cbnz	r3, 14058 <ull_conn_tx_ack+0x28>
   1403e:	f240 5392 	movw	r3, #1426	; 0x592
   14042:	4aa2      	ldr	r2, [pc, #648]	; (142cc <ull_conn_tx_ack+0x29c>)
   14044:	49a2      	ldr	r1, [pc, #648]	; (142d0 <ull_conn_tx_ack+0x2a0>)
   14046:	48a3      	ldr	r0, [pc, #652]	; (142d4 <ull_conn_tx_ack+0x2a4>)
   14048:	f005 f994 	bl	19374 <printk>
   1404c:	4040      	eors	r0, r0
   1404e:	f380 8811 	msr	BASEPRI, r0
   14052:	f04f 0003 	mov.w	r0, #3
   14056:	df02      	svc	2
	if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
   14058:	792b      	ldrb	r3, [r5, #4]
   1405a:	f003 0203 	and.w	r2, r3, #3
   1405e:	2a03      	cmp	r2, #3
   14060:	f64f 72ff 	movw	r2, #65535	; 0xffff
   14064:	f040 8126 	bne.w	142b4 <ull_conn_tx_ack+0x284>
		if (handle != 0xFFFF) {
   14068:	4296      	cmp	r6, r2
   1406a:	f000 810b 	beq.w	14284 <ull_conn_tx_ack+0x254>
			conn = ll_conn_get(handle);
   1406e:	4630      	mov	r0, r6
   14070:	f7fe f94a 	bl	12308 <ll_conn_get>
	switch (pdu_tx->llctrl.opcode) {
   14074:	79eb      	ldrb	r3, [r5, #7]
   14076:	3b02      	subs	r3, #2
			conn = ll_conn_get(handle);
   14078:	4604      	mov	r4, r0
	switch (pdu_tx->llctrl.opcode) {
   1407a:	2b16      	cmp	r3, #22
   1407c:	d81e      	bhi.n	140bc <ull_conn_tx_ack+0x8c>
   1407e:	e8df f013 	tbh	[pc, r3, lsl #1]
   14082:	0017      	.short	0x0017
   14084:	00850037 	.word	0x00850037
   14088:	001d001d 	.word	0x001d001d
   1408c:	001d001d 	.word	0x001d001d
   14090:	0053001d 	.word	0x0053001d
   14094:	001d005a 	.word	0x001d005a
   14098:	001d008f 	.word	0x001d008f
   1409c:	001d001d 	.word	0x001d001d
   140a0:	001d008c 	.word	0x001d008c
   140a4:	0099001d 	.word	0x0099001d
   140a8:	00d300a1 	.word	0x00d300a1
   140ac:	00fa00da 	.word	0x00fa00da
		u8_t reason = (pdu_tx->llctrl.terminate_ind.error_code ==
   140b0:	7a29      	ldrb	r1, [r5, #8]
   140b2:	2913      	cmp	r1, #19
		conn_cleanup(conn, reason);
   140b4:	bf08      	it	eq
   140b6:	2116      	moveq	r1, #22
   140b8:	f7fd ff8e 	bl	11fd8 <conn_cleanup>
		if (link->next == (void *)tx) {
   140bc:	683b      	ldr	r3, [r7, #0]
   140be:	42ab      	cmp	r3, r5
   140c0:	f040 80e2 	bne.w	14288 <ull_conn_tx_ack+0x258>
			LL_ASSERT(link->next);
   140c4:	b965      	cbnz	r5, 140e0 <ull_conn_tx_ack+0xb0>
   140c6:	f240 539e 	movw	r3, #1438	; 0x59e
   140ca:	4a80      	ldr	r2, [pc, #512]	; (142cc <ull_conn_tx_ack+0x29c>)
   140cc:	4982      	ldr	r1, [pc, #520]	; (142d8 <ull_conn_tx_ack+0x2a8>)
   140ce:	4881      	ldr	r0, [pc, #516]	; (142d4 <ull_conn_tx_ack+0x2a4>)
   140d0:	f005 f950 	bl	19374 <printk>
   140d4:	4040      	eors	r0, r0
   140d6:	f380 8811 	msr	BASEPRI, r0
   140da:	f04f 0003 	mov.w	r0, #3
   140de:	df02      	svc	2
			mem_release(tx, &mem_conn_tx_ctrl.free);
   140e0:	497e      	ldr	r1, [pc, #504]	; (142dc <ull_conn_tx_ack+0x2ac>)
   140e2:	4628      	mov	r0, r5
   140e4:	f008 fedb 	bl	1ce9e <mem_release>
}
   140e8:	4620      	mov	r0, r4
   140ea:	b002      	add	sp, #8
   140ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		memcpy(&conn->llcp.encryption.skd[0],
   140f0:	2208      	movs	r2, #8
   140f2:	f105 0112 	add.w	r1, r5, #18
   140f6:	30ee      	adds	r0, #238	; 0xee
   140f8:	f006 ff7f 	bl	1affa <memcpy>
		memcpy(&conn->lll.ccm_rx.iv[0],
   140fc:	2204      	movs	r2, #4
   140fe:	f105 011a 	add.w	r1, r5, #26
   14102:	f104 0098 	add.w	r0, r4, #152	; 0x98
   14106:	f006 ff78 	bl	1affa <memcpy>
		conn->llcp_enc.pause_tx = 1U;
   1410a:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   1410e:	f043 0302 	orr.w	r3, r3, #2
		conn->llcp_enc.pause_tx = 1U;
   14112:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		conn->procedure_expire = conn->procedure_reload;
   14116:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
   1411a:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
		conn->llcp_enc.ack = conn->llcp_enc.req;
   1411e:	f894 3150 	ldrb.w	r3, [r4, #336]	; 0x150
   14122:	f884 3151 	strb.w	r3, [r4, #337]	; 0x151
		break;
   14126:	e7c9      	b.n	140bc <ull_conn_tx_ack+0x8c>
		conn->llcp_enc.pause_tx = 1U;
   14128:	f890 3152 	ldrb.w	r3, [r0, #338]	; 0x152
   1412c:	f023 0306 	bic.w	r3, r3, #6
   14130:	f043 0306 	orr.w	r3, r3, #6
   14134:	e7ed      	b.n	14112 <ull_conn_tx_ack+0xe2>
		if (!conn->lll.role) {
   14136:	f990 303d 	ldrsb.w	r3, [r0, #61]	; 0x3d
   1413a:	2b00      	cmp	r3, #0
   1413c:	db26      	blt.n	1418c <ull_conn_tx_ack+0x15c>
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   1413e:	792b      	ldrb	r3, [r5, #4]
   14140:	f043 0303 	orr.w	r3, r3, #3
   14144:	712b      	strb	r3, [r5, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_req) +
   14146:	2317      	movs	r3, #23
   14148:	716b      	strb	r3, [r5, #5]
	memcpy(&pdu_ctrl_tx->llctrl.enc_req.rand[0], &conn->llcp_enc.rand[0],
   1414a:	2208      	movs	r2, #8
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
   1414c:	2303      	movs	r3, #3
	memcpy(&pdu_ctrl_tx->llctrl.enc_req.rand[0], &conn->llcp_enc.rand[0],
   1414e:	f200 1155 	addw	r1, r0, #341	; 0x155
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
   14152:	71eb      	strb	r3, [r5, #7]
	memcpy(&pdu_ctrl_tx->llctrl.enc_req.rand[0], &conn->llcp_enc.rand[0],
   14154:	18a8      	adds	r0, r5, r2
   14156:	f006 ff50 	bl	1affa <memcpy>
	pdu_ctrl_tx->llctrl.enc_req.ediv[0] = conn->llcp_enc.ediv[0];
   1415a:	f894 3153 	ldrb.w	r3, [r4, #339]	; 0x153
   1415e:	742b      	strb	r3, [r5, #16]
	pdu_ctrl_tx->llctrl.enc_req.ediv[1] = conn->llcp_enc.ediv[1];
   14160:	f894 3154 	ldrb.w	r3, [r4, #340]	; 0x154
   14164:	746b      	strb	r3, [r5, #17]
	entropy_get_entropy_isr(entropy, pdu_ctrl_tx->llctrl.enc_req.skdm,
   14166:	4b5e      	ldr	r3, [pc, #376]	; (142e0 <ull_conn_tx_ack+0x2b0>)
   14168:	6818      	ldr	r0, [r3, #0]
	if (unlikely(!api->get_entropy_isr)) {
   1416a:	6843      	ldr	r3, [r0, #4]
   1416c:	f8d3 8004 	ldr.w	r8, [r3, #4]
   14170:	f105 0112 	add.w	r1, r5, #18
   14174:	f1b8 0f00 	cmp.w	r8, #0
   14178:	d002      	beq.n	14180 <ull_conn_tx_ack+0x150>
	return api->get_entropy_isr(dev, buffer, length, flags);
   1417a:	2300      	movs	r3, #0
   1417c:	220c      	movs	r2, #12
   1417e:	47c0      	blx	r8
	ctrl_tx_enqueue(conn, *tx);
   14180:	4629      	mov	r1, r5
   14182:	4620      	mov	r0, r4
   14184:	f009 fa3b 	bl	1d5fe <ctrl_tx_enqueue>
	*tx = NULL;
   14188:	2500      	movs	r5, #0
   1418a:	e797      	b.n	140bc <ull_conn_tx_ack+0x8c>
			conn->llcp_enc.pause_tx = 1U;
   1418c:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   14190:	f043 0302 	orr.w	r3, r3, #2
   14194:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
   14198:	e790      	b.n	140bc <ull_conn_tx_ack+0x8c>
		if (pdu_tx->llctrl.reject_ext_ind.reject_opcode !=
   1419a:	7a2b      	ldrb	r3, [r5, #8]
   1419c:	2b03      	cmp	r3, #3
   1419e:	d18d      	bne.n	140bc <ull_conn_tx_ack+0x8c>
		conn->llcp_enc.pause_rx = 0U;
   141a0:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   141a4:	f023 0303 	bic.w	r3, r3, #3
   141a8:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		conn->procedure_expire = 0U;
   141ac:	2300      	movs	r3, #0
   141ae:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
		break;
   141b2:	e783      	b.n	140bc <ull_conn_tx_ack+0x8c>
		conn->llcp_length.state = LLCP_LENGTH_STATE_RSP_WAIT;
   141b4:	f890 319a 	ldrb.w	r3, [r0, #410]	; 0x19a
   141b8:	2202      	movs	r2, #2
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   141ba:	f362 0302 	bfi	r3, r2, #0, #3
   141be:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
				break;
   141c2:	e77b      	b.n	140bc <ull_conn_tx_ack+0x8c>
		if (conn->llcp_length.req != conn->llcp_length.ack) {
   141c4:	f890 1198 	ldrb.w	r1, [r0, #408]	; 0x198
   141c8:	f890 3199 	ldrb.w	r3, [r0, #409]	; 0x199
   141cc:	428b      	cmp	r3, r1
   141ce:	f43f af75 	beq.w	140bc <ull_conn_tx_ack+0x8c>
			switch (conn->llcp_length.state) {
   141d2:	f890 319a 	ldrb.w	r3, [r0, #410]	; 0x19a
   141d6:	f003 0007 	and.w	r0, r3, #7
   141da:	2807      	cmp	r0, #7
   141dc:	f43f af6e 	beq.w	140bc <ull_conn_tx_ack+0x8c>
   141e0:	2201      	movs	r2, #1
   141e2:	4082      	lsls	r2, r0
   141e4:	f012 0f68 	tst.w	r2, #104	; 0x68
   141e8:	f43f af68 	beq.w	140bc <ull_conn_tx_ack+0x8c>
				conn->lll.max_tx_octets =
   141ec:	f8b4 219e 	ldrh.w	r2, [r4, #414]	; 0x19e
   141f0:	f8a4 205c 	strh.w	r2, [r4, #92]	; 0x5c
				if (conn->llcp_length.state ==
   141f4:	2805      	cmp	r0, #5
				conn->lll.max_tx_time =
   141f6:	f8b4 21a2 	ldrh.w	r2, [r4, #418]	; 0x1a2
   141fa:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
				if (conn->llcp_length.state ==
   141fe:	d101      	bne.n	14204 <ull_conn_tx_ack+0x1d4>
					conn->llcp_length.state =
   14200:	2204      	movs	r2, #4
   14202:	e7da      	b.n	141ba <ull_conn_tx_ack+0x18a>
				if (!conn->llcp_length.cache.tx_octets) {
   14204:	f8b4 21a4 	ldrh.w	r2, [r4, #420]	; 0x1a4
   14208:	b922      	cbnz	r2, 14214 <ull_conn_tx_ack+0x1e4>
					conn->llcp_length.ack =
   1420a:	f884 1199 	strb.w	r1, [r4, #409]	; 0x199
					conn->procedure_expire = 0U;
   1420e:	f8a4 20cc 	strh.w	r2, [r4, #204]	; 0xcc
					break;
   14212:	e753      	b.n	140bc <ull_conn_tx_ack+0x8c>
				conn->llcp_length.tx_octets =
   14214:	f8a4 219e 	strh.w	r2, [r4, #414]	; 0x19e
				conn->llcp_length.tx_time =
   14218:	f8b4 11a6 	ldrh.w	r1, [r4, #422]	; 0x1a6
   1421c:	f8a4 11a2 	strh.w	r1, [r4, #418]	; 0x1a2
				conn->llcp_length.cache.tx_octets = 0;
   14220:	2200      	movs	r2, #0
   14222:	f8a4 21a4 	strh.w	r2, [r4, #420]	; 0x1a4
				conn->llcp_length.tx_time =
   14226:	e7c8      	b.n	141ba <ull_conn_tx_ack+0x18a>
		conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
   14228:	f890 31aa 	ldrb.w	r3, [r0, #426]	; 0x1aa
   1422c:	2202      	movs	r2, #2
   1422e:	f362 0301 	bfi	r3, r2, #0, #2
   14232:	f880 31aa 	strb.w	r3, [r0, #426]	; 0x1aa
		if (conn->lll.role) {
   14236:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   1423a:	2b00      	cmp	r3, #0
   1423c:	da14      	bge.n	14268 <ull_conn_tx_ack+0x238>
			u8_t phy_tx_time[8] = {BIT(0), BIT(0), BIT(1), BIT(0),
   1423e:	4a29      	ldr	r2, [pc, #164]	; (142e4 <ull_conn_tx_ack+0x2b4>)
   14240:	f04f 3304 	mov.w	r3, #67372036	; 0x4040404
   14244:	e9cd 2300 	strd	r2, r3, [sp]
			phys = conn->llcp_phy.tx | lll->phy_tx;
   14248:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   1424c:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
   14250:	ea42 0393 	orr.w	r3, r2, r3, lsr #2
			lll->phy_tx_time = phy_tx_time[phys];
   14254:	f003 0307 	and.w	r3, r3, #7
   14258:	a902      	add	r1, sp, #8
   1425a:	440b      	add	r3, r1
   1425c:	f813 3c08 	ldrb.w	r3, [r3, #-8]
   14260:	f363 1206 	bfi	r2, r3, #4, #3
   14264:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
   14268:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   1426c:	f36f 0300 	bfc	r3, #0, #1
   14270:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		break;
   14274:	e722      	b.n	140bc <ull_conn_tx_ack+0x8c>
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
   14276:	f890 30ec 	ldrb.w	r3, [r0, #236]	; 0xec
   1427a:	f890 2064 	ldrb.w	r2, [r0, #100]	; 0x64
   1427e:	f3c3 0382 	ubfx	r3, r3, #2, #3
   14282:	e7ed      	b.n	14260 <ull_conn_tx_ack+0x230>
	struct ll_conn *conn = NULL;
   14284:	2400      	movs	r4, #0
   14286:	e719      	b.n	140bc <ull_conn_tx_ack+0x8c>
		} else if (!tx) {
   14288:	2d00      	cmp	r5, #0
   1428a:	f43f af2d 	beq.w	140e8 <ull_conn_tx_ack+0xb8>
			LL_ASSERT(!link->next);
   1428e:	b163      	cbz	r3, 142aa <ull_conn_tx_ack+0x27a>
   14290:	f240 53a5 	movw	r3, #1445	; 0x5a5
   14294:	4a0d      	ldr	r2, [pc, #52]	; (142cc <ull_conn_tx_ack+0x29c>)
   14296:	4914      	ldr	r1, [pc, #80]	; (142e8 <ull_conn_tx_ack+0x2b8>)
   14298:	480e      	ldr	r0, [pc, #56]	; (142d4 <ull_conn_tx_ack+0x2a4>)
   1429a:	f005 f86b 	bl	19374 <printk>
   1429e:	4040      	eors	r0, r0
   142a0:	f380 8811 	msr	BASEPRI, r0
   142a4:	f04f 0003 	mov.w	r0, #3
   142a8:	df02      	svc	2
	ll_tx_ack_put(handle, tx);
   142aa:	4629      	mov	r1, r5
   142ac:	4630      	mov	r0, r6
   142ae:	f7fc f887 	bl	103c0 <ll_tx_ack_put>
	return conn;
   142b2:	e719      	b.n	140e8 <ull_conn_tx_ack+0xb8>
	} else if (handle != 0xFFFF) {
   142b4:	4296      	cmp	r6, r2
   142b6:	d004      	beq.n	142c2 <ull_conn_tx_ack+0x292>
		conn = ll_conn_get(handle);
   142b8:	4630      	mov	r0, r6
   142ba:	f7fe f825 	bl	12308 <ll_conn_get>
   142be:	4604      	mov	r4, r0
   142c0:	e7f3      	b.n	142aa <ull_conn_tx_ack+0x27a>
		pdu_tx->ll_id = PDU_DATA_LLID_RESV;
   142c2:	f36f 0301 	bfc	r3, #0, #2
   142c6:	712b      	strb	r3, [r5, #4]
	struct ll_conn *conn = NULL;
   142c8:	2400      	movs	r4, #0
   142ca:	e7ee      	b.n	142aa <ull_conn_tx_ack+0x27a>
   142cc:	00021f06 	.word	0x00021f06
   142d0:	0002206a 	.word	0x0002206a
   142d4:	00020aa4 	.word	0x00020aa4
   142d8:	00022077 	.word	0x00022077
   142dc:	200013d4 	.word	0x200013d4
   142e0:	20001358 	.word	0x20001358
   142e4:	01020101 	.word	0x01020101
   142e8:	00022076 	.word	0x00022076

000142ec <lll_clock_wait>:

void lll_clock_wait(void)
{
	static bool done;

	if (done) {
   142ec:	4b13      	ldr	r3, [pc, #76]	; (1433c <lll_clock_wait+0x50>)
   142ee:	781a      	ldrb	r2, [r3, #0]
{
   142f0:	b510      	push	{r4, lr}
	if (done) {
   142f2:	b9fa      	cbnz	r2, 14334 <lll_clock_wait+0x48>
		return;
	}
	done = true;
   142f4:	2201      	movs	r2, #1
   142f6:	701a      	strb	r2, [r3, #0]
   142f8:	4811      	ldr	r0, [pc, #68]	; (14340 <lll_clock_wait+0x54>)
   142fa:	f003 fa19 	bl	17730 <z_impl_device_get_binding>

	struct device *clock =
			device_get_binding(DT_INST_0_NORDIC_NRF_CLOCK_LABEL);

	LL_ASSERT(clock);
   142fe:	4604      	mov	r4, r0
   14300:	b958      	cbnz	r0, 1431a <lll_clock_wait+0x2e>
   14302:	231e      	movs	r3, #30
   14304:	4a0f      	ldr	r2, [pc, #60]	; (14344 <lll_clock_wait+0x58>)
   14306:	4910      	ldr	r1, [pc, #64]	; (14348 <lll_clock_wait+0x5c>)
   14308:	4810      	ldr	r0, [pc, #64]	; (1434c <lll_clock_wait+0x60>)
   1430a:	f005 f833 	bl	19374 <printk>
   1430e:	4040      	eors	r0, r0
   14310:	f380 8811 	msr	BASEPRI, r0
   14314:	f04f 0003 	mov.w	r0, #3
   14318:	df02      	svc	2
	return api->on(dev, sys);
   1431a:	6863      	ldr	r3, [r4, #4]
   1431c:	2101      	movs	r1, #1
   1431e:	681b      	ldr	r3, [r3, #0]
   14320:	4620      	mov	r0, r4
   14322:	4798      	blx	r3
						clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	if (!api->get_status) {
   14324:	6863      	ldr	r3, [r4, #4]
   14326:	691b      	ldr	r3, [r3, #16]
   14328:	b12b      	cbz	r3, 14336 <lll_clock_wait+0x4a>
		return CLOCK_CONTROL_STATUS_UNKNOWN;
	}

	return api->get_status(dev, sys);
   1432a:	2101      	movs	r1, #1
   1432c:	4620      	mov	r0, r4
   1432e:	4798      	blx	r3

	clock_control_on(clock, CLOCK_CONTROL_NRF_SUBSYS_LF);
	while (clock_control_get_status(clock, CLOCK_CONTROL_NRF_SUBSYS_LF) !=
   14330:	2802      	cmp	r0, #2
   14332:	d100      	bne.n	14336 <lll_clock_wait+0x4a>
			CLOCK_CONTROL_STATUS_ON) {
		DEBUG_CPU_SLEEP(1);
		k_cpu_idle();
		DEBUG_CPU_SLEEP(0);
	}
}
   14334:	bd10      	pop	{r4, pc}
 * @return N/A
 * @req K-CPU-IDLE-001
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
   14336:	f7f0 f8ad 	bl	4494 <arch_cpu_idle>
   1433a:	e7f3      	b.n	14324 <lll_clock_wait+0x38>
   1433c:	20001c89 	.word	0x20001c89
   14340:	0001fc32 	.word	0x0001fc32
   14344:	00022082 	.word	0x00022082
   14348:	000220d3 	.word	0x000220d3
   1434c:	00020aa4 	.word	0x00020aa4

00014350 <isr_cleanup>:

	isr_cleanup(param);
}

static void isr_cleanup(void *param)
{
   14350:	b508      	push	{r3, lr}
	int err;

	radio_isr_set(isr_race, param);
   14352:	4601      	mov	r1, r0
   14354:	480d      	ldr	r0, [pc, #52]	; (1438c <isr_cleanup+0x3c>)
   14356:	f001 fbfd 	bl	15b54 <radio_isr_set>
	radio_tmr_stop();
   1435a:	f001 fe25 	bl	15fa8 <radio_tmr_stop>

	err = lll_clk_off();
   1435e:	f7fc fdbf 	bl	10ee0 <lll_clk_off>
	LL_ASSERT(!err || err == -EBUSY);
   14362:	b170      	cbz	r0, 14382 <isr_cleanup+0x32>
   14364:	3010      	adds	r0, #16
   14366:	d00c      	beq.n	14382 <isr_cleanup+0x32>
   14368:	f240 237e 	movw	r3, #638	; 0x27e
   1436c:	4a08      	ldr	r2, [pc, #32]	; (14390 <isr_cleanup+0x40>)
   1436e:	4909      	ldr	r1, [pc, #36]	; (14394 <isr_cleanup+0x44>)
   14370:	4809      	ldr	r0, [pc, #36]	; (14398 <isr_cleanup+0x48>)
   14372:	f004 ffff 	bl	19374 <printk>
   14376:	4040      	eors	r0, r0
   14378:	f380 8811 	msr	BASEPRI, r0
   1437c:	f04f 0003 	mov.w	r0, #3
   14380:	df02      	svc	2

	lll_done(NULL);
   14382:	2000      	movs	r0, #0
}
   14384:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
   14388:	f7fc bd58 	b.w	10e3c <lll_done>
   1438c:	0001d945 	.word	0x0001d945
   14390:	000220d9 	.word	0x000220d9
   14394:	00021e30 	.word	0x00021e30
   14398:	00020aa4 	.word	0x00020aa4

0001439c <isr_done>:
{
   1439c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1439e:	4605      	mov	r5, r0
	radio_status_reset();
   143a0:	f001 fcb2 	bl	15d08 <radio_status_reset>
	radio_tmr_status_reset();
   143a4:	f001 fd6e 	bl	15e84 <radio_tmr_status_reset>
	radio_filter_status_reset();
   143a8:	f001 fd48 	bl	15e3c <radio_filter_status_reset>
	radio_ar_status_reset();
   143ac:	f001 ff08 	bl	161c0 <radio_ar_status_reset>
	radio_rssi_status_reset();
   143b0:	f001 fd0c 	bl	15dcc <radio_rssi_status_reset>
	e = ull_event_done_extra_get();
   143b4:	f7fc faaa 	bl	1090c <ull_event_done_extra_get>
	LL_ASSERT(e);
   143b8:	4604      	mov	r4, r0
   143ba:	b960      	cbnz	r0, 143d6 <isr_done+0x3a>
   143bc:	f240 234d 	movw	r3, #589	; 0x24d
   143c0:	4a1c      	ldr	r2, [pc, #112]	; (14434 <isr_done+0x98>)
   143c2:	491d      	ldr	r1, [pc, #116]	; (14438 <isr_done+0x9c>)
   143c4:	481d      	ldr	r0, [pc, #116]	; (1443c <isr_done+0xa0>)
   143c6:	f004 ffd5 	bl	19374 <printk>
   143ca:	4040      	eors	r0, r0
   143cc:	f380 8811 	msr	BASEPRI, r0
   143d0:	f04f 0003 	mov.w	r0, #3
   143d4:	df02      	svc	2
	e->crc_valid = crc_valid;
   143d6:	4a1a      	ldr	r2, [pc, #104]	; (14440 <isr_done+0xa4>)
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
   143d8:	2301      	movs	r3, #1
	e->crc_valid = crc_valid;
   143da:	7812      	ldrb	r2, [r2, #0]
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
   143dc:	7023      	strb	r3, [r4, #0]
	e->trx_cnt = trx_cnt;
   143de:	4b19      	ldr	r3, [pc, #100]	; (14444 <isr_done+0xa8>)
	e->crc_valid = crc_valid;
   143e0:	71a2      	strb	r2, [r4, #6]
	e->mic_state = mic_state;
   143e2:	4a19      	ldr	r2, [pc, #100]	; (14448 <isr_done+0xac>)
	e->trx_cnt = trx_cnt;
   143e4:	881b      	ldrh	r3, [r3, #0]
	e->mic_state = mic_state;
   143e6:	7812      	ldrb	r2, [r2, #0]
	e->trx_cnt = trx_cnt;
   143e8:	80a3      	strh	r3, [r4, #4]
	e->mic_state = mic_state;
   143ea:	71e2      	strb	r2, [r4, #7]
	if (trx_cnt) {
   143ec:	b1db      	cbz	r3, 14426 <isr_done+0x8a>
		if (lll->role) {
   143ee:	f995 3021 	ldrsb.w	r3, [r5, #33]	; 0x21
   143f2:	2b00      	cmp	r3, #0
   143f4:	da17      	bge.n	14426 <isr_done+0x8a>
				addr_us_get(lll->phy_rx);
   143f6:	f895 3049 	ldrb.w	r3, [r5, #73]	; 0x49
   143fa:	f003 0307 	and.w	r3, r3, #7
#define RANGE_DISTANCE 1000 /* meters */
#define RANGE_DELAY_US (2 * RANGE_DISTANCE * 4 / 1000)

static inline u32_t addr_us_get(u8_t phy)
{
	switch (phy) {
   143fe:	2b02      	cmp	r3, #2
   14400:	d016      	beq.n	14430 <isr_done+0x94>
	default:
	case BIT(0):
		return 40;
   14402:	2b04      	cmp	r3, #4
   14404:	bf0c      	ite	eq
   14406:	f44f 77bc 	moveq.w	r7, #376	; 0x178
   1440a:	2728      	movne	r7, #40	; 0x28
				radio_tmr_aa_restore() - radio_tmr_ready_get();
   1440c:	f001 fe04 	bl	16018 <radio_tmr_aa_restore>
   14410:	4606      	mov	r6, r0
   14412:	f001 fe07 	bl	16024 <radio_tmr_ready_get>
			e->slave.window_widening_event_us =
   14416:	6b6b      	ldr	r3, [r5, #52]	; 0x34
				radio_tmr_aa_restore() - radio_tmr_ready_get();
   14418:	1a30      	subs	r0, r6, r0
			e->slave.preamble_to_addr_us = preamble_to_addr_us;
   1441a:	e9c4 3703 	strd	r3, r7, [r4, #12]
			lll->slave.window_widening_event_us = 0;
   1441e:	2300      	movs	r3, #0
			e->slave.start_to_address_actual_us =
   14420:	60a0      	str	r0, [r4, #8]
			lll->slave.window_widening_event_us = 0;
   14422:	636b      	str	r3, [r5, #52]	; 0x34
			lll->slave.window_size_event_us = 0;
   14424:	63eb      	str	r3, [r5, #60]	; 0x3c
	isr_cleanup(param);
   14426:	4628      	mov	r0, r5
}
   14428:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	isr_cleanup(param);
   1442c:	f7ff bf90 	b.w	14350 <isr_cleanup>
	case BIT(1):
		return 24;
   14430:	2718      	movs	r7, #24
   14432:	e7eb      	b.n	1440c <isr_done+0x70>
   14434:	000220d9 	.word	0x000220d9
   14438:	000204c3 	.word	0x000204c3
   1443c:	00020aa4 	.word	0x00020aa4
   14440:	20001c8b 	.word	0x20001c8b
   14444:	20001b0e 	.word	0x20001b0e
   14448:	20001c8c 	.word	0x20001c8c

0001444c <lll_conn_ppm_get>:
}
   1444c:	4b01      	ldr	r3, [pc, #4]	; (14454 <lll_conn_ppm_get+0x8>)
   1444e:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
   14452:	4770      	bx	lr
   14454:	0001f79c 	.word	0x0001f79c

00014458 <lll_conn_prepare_reset>:
	trx_cnt = 0U;
   14458:	4a04      	ldr	r2, [pc, #16]	; (1446c <lll_conn_prepare_reset+0x14>)
   1445a:	2300      	movs	r3, #0
   1445c:	8013      	strh	r3, [r2, #0]
	crc_expire = 0U;
   1445e:	4a04      	ldr	r2, [pc, #16]	; (14470 <lll_conn_prepare_reset+0x18>)
   14460:	7013      	strb	r3, [r2, #0]
	crc_valid = 0U;
   14462:	4a04      	ldr	r2, [pc, #16]	; (14474 <lll_conn_prepare_reset+0x1c>)
   14464:	7013      	strb	r3, [r2, #0]
	mic_state = LLL_CONN_MIC_NONE;
   14466:	4a04      	ldr	r2, [pc, #16]	; (14478 <lll_conn_prepare_reset+0x20>)
   14468:	7013      	strb	r3, [r2, #0]
}
   1446a:	4770      	bx	lr
   1446c:	20001b0e 	.word	0x20001b0e
   14470:	20001c8a 	.word	0x20001c8a
   14474:	20001c8b 	.word	0x20001c8b
   14478:	20001c8c 	.word	0x20001c8c

0001447c <lll_conn_abort_cb>:
{
   1447c:	b510      	push	{r4, lr}
   1447e:	460c      	mov	r4, r1
	if (!prepare_param) {
   14480:	b930      	cbnz	r0, 14490 <lll_conn_abort_cb+0x14>
		radio_isr_set(isr_done, param);
   14482:	480e      	ldr	r0, [pc, #56]	; (144bc <lll_conn_abort_cb+0x40>)
   14484:	f001 fb66 	bl	15b54 <radio_isr_set>
}
   14488:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
   1448c:	f001 bc2a 	b.w	15ce4 <radio_disable>
	err = lll_clk_off();
   14490:	f7fc fd26 	bl	10ee0 <lll_clk_off>
	LL_ASSERT(!err || err == -EBUSY);
   14494:	b168      	cbz	r0, 144b2 <lll_conn_abort_cb+0x36>
   14496:	3010      	adds	r0, #16
   14498:	d00b      	beq.n	144b2 <lll_conn_abort_cb+0x36>
   1449a:	2381      	movs	r3, #129	; 0x81
   1449c:	4a08      	ldr	r2, [pc, #32]	; (144c0 <lll_conn_abort_cb+0x44>)
   1449e:	4909      	ldr	r1, [pc, #36]	; (144c4 <lll_conn_abort_cb+0x48>)
   144a0:	4809      	ldr	r0, [pc, #36]	; (144c8 <lll_conn_abort_cb+0x4c>)
   144a2:	f004 ff67 	bl	19374 <printk>
   144a6:	4040      	eors	r0, r0
   144a8:	f380 8811 	msr	BASEPRI, r0
   144ac:	f04f 0003 	mov.w	r0, #3
   144b0:	df02      	svc	2
	lll_done(param);
   144b2:	4620      	mov	r0, r4
}
   144b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
   144b8:	f7fc bcc0 	b.w	10e3c <lll_done>
   144bc:	0001439d 	.word	0x0001439d
   144c0:	000220d9 	.word	0x000220d9
   144c4:	00021e30 	.word	0x00021e30
   144c8:	00020aa4 	.word	0x00020aa4

000144cc <lll_conn_rx_pkt_set>:
{
   144cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   144ce:	4607      	mov	r7, r0
	node_rx = ull_pdu_rx_alloc_peek(1);
   144d0:	2001      	movs	r0, #1
   144d2:	f7fc f847 	bl	10564 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   144d6:	4604      	mov	r4, r0
   144d8:	b960      	cbnz	r0, 144f4 <lll_conn_rx_pkt_set+0x28>
   144da:	f44f 73df 	mov.w	r3, #446	; 0x1be
   144de:	4a19      	ldr	r2, [pc, #100]	; (14544 <lll_conn_rx_pkt_set+0x78>)
   144e0:	4919      	ldr	r1, [pc, #100]	; (14548 <lll_conn_rx_pkt_set+0x7c>)
   144e2:	481a      	ldr	r0, [pc, #104]	; (1454c <lll_conn_rx_pkt_set+0x80>)
   144e4:	f004 ff46 	bl	19374 <printk>
   144e8:	4040      	eors	r0, r0
   144ea:	f380 8811 	msr	BASEPRI, r0
   144ee:	f04f 0003 	mov.w	r0, #3
   144f2:	df02      	svc	2
	phy = lll->phy_rx;
   144f4:	f897 5049 	ldrb.w	r5, [r7, #73]	; 0x49
	max_rx_octets = lll->max_rx_octets;
   144f8:	f8b7 6042 	ldrh.w	r6, [r7, #66]	; 0x42
	phy = lll->phy_rx;
   144fc:	f005 0507 	and.w	r5, r5, #7
	radio_phy_set(phy, 0);
   14500:	2100      	movs	r1, #0
   14502:	4628      	mov	r0, r5
   14504:	f001 fb6a 	bl	15bdc <radio_phy_set>
	} else if (lll->enc_rx) {
   14508:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
   1450c:	006a      	lsls	r2, r5, #1
   1450e:	071b      	lsls	r3, r3, #28
   14510:	f042 0201 	orr.w	r2, r2, #1
   14514:	f104 0420 	add.w	r4, r4, #32
   14518:	d50e      	bpl.n	14538 <lll_conn_rx_pkt_set+0x6c>
		radio_pkt_configure(8, (max_rx_octets + 4), (phy << 1) | 0x01);
   1451a:	1d31      	adds	r1, r6, #4
   1451c:	b2c9      	uxtb	r1, r1
   1451e:	2008      	movs	r0, #8
   14520:	f001 fba2 	bl	15c68 <radio_pkt_configure>
		radio_pkt_rx_set(radio_ccm_rx_pkt_set(&lll->ccm_rx, phy,
   14524:	4622      	mov	r2, r4
   14526:	4629      	mov	r1, r5
   14528:	f107 0063 	add.w	r0, r7, #99	; 0x63
   1452c:	f001 fd94 	bl	16058 <radio_ccm_rx_pkt_set>
}
   14530:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_rx_set(node_rx->pdu);
   14534:	f001 bbc4 	b.w	15cc0 <radio_pkt_rx_set>
		radio_pkt_configure(8, max_rx_octets, (phy << 1) | 0x01);
   14538:	2008      	movs	r0, #8
   1453a:	b2f1      	uxtb	r1, r6
   1453c:	f001 fb94 	bl	15c68 <radio_pkt_configure>
		radio_pkt_rx_set(node_rx->pdu);
   14540:	4620      	mov	r0, r4
   14542:	e7f5      	b.n	14530 <lll_conn_rx_pkt_set+0x64>
   14544:	000220d9 	.word	0x000220d9
   14548:	00022133 	.word	0x00022133
   1454c:	00020aa4 	.word	0x00020aa4

00014550 <lll_conn_isr_tx>:
{
   14550:	b538      	push	{r3, r4, r5, lr}
   14552:	4604      	mov	r4, r0
	radio_status_reset();
   14554:	f001 fbd8 	bl	15d08 <radio_status_reset>
	radio_tmr_status_reset();
   14558:	f001 fc94 	bl	15e84 <radio_tmr_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
   1455c:	2096      	movs	r0, #150	; 0x96
   1455e:	f001 fca1 	bl	15ea4 <radio_tmr_tifs_set>
				     lll->phy_flags);
   14562:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
	radio_switch_complete_and_tx(lll->phy_rx, 0,
   14566:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   1456a:	f3c2 03c0 	ubfx	r3, r2, #3, #1
   1456e:	2100      	movs	r1, #0
   14570:	f002 0207 	and.w	r2, r2, #7
   14574:	f000 0007 	and.w	r0, r0, #7
   14578:	f001 fc10 	bl	15d9c <radio_switch_complete_and_tx>
	lll_conn_rx_pkt_set(lll);
   1457c:	4620      	mov	r0, r4
   1457e:	f7ff ffa5 	bl	144cc <lll_conn_rx_pkt_set>
	LL_ASSERT(!radio_is_ready());
   14582:	f001 fbcd 	bl	15d20 <radio_is_ready>
   14586:	b160      	cbz	r0, 145a2 <lll_conn_isr_tx+0x52>
   14588:	f240 1379 	movw	r3, #377	; 0x179
   1458c:	4a1b      	ldr	r2, [pc, #108]	; (145fc <lll_conn_isr_tx+0xac>)
   1458e:	491c      	ldr	r1, [pc, #112]	; (14600 <lll_conn_isr_tx+0xb0>)
   14590:	481c      	ldr	r0, [pc, #112]	; (14604 <lll_conn_isr_tx+0xb4>)
   14592:	f004 feef 	bl	19374 <printk>
   14596:	4040      	eors	r0, r0
   14598:	f380 8811 	msr	BASEPRI, r0
   1459c:	f04f 0003 	mov.w	r0, #3
   145a0:	df02      	svc	2
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 +
   145a2:	f001 fd53 	bl	1604c <radio_tmr_tifs_base_get>
   145a6:	4605      	mov	r5, r0
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
   145a8:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   145ac:	2101      	movs	r1, #1
   145ae:	f000 0007 	and.w	r0, r0, #7
   145b2:	f009 faf0 	bl	1db96 <radio_rx_chain_delay_get>
	hcto += addr_us_get(lll->phy_rx);
   145b6:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
   145ba:	f003 0307 	and.w	r3, r3, #7
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
   145be:	4405      	add	r5, r0
	switch (phy) {
   145c0:	2b02      	cmp	r3, #2
   145c2:	f105 05a3 	add.w	r5, r5, #163	; 0xa3
   145c6:	d016      	beq.n	145f6 <lll_conn_isr_tx+0xa6>
		return 40;
   145c8:	2b04      	cmp	r3, #4
   145ca:	bf0c      	ite	eq
   145cc:	f44f 70bc 	moveq.w	r0, #376	; 0x178
   145d0:	2028      	movne	r0, #40	; 0x28
	hcto += addr_us_get(lll->phy_rx);
   145d2:	4405      	add	r5, r0
	hcto -= radio_tx_chain_delay_get(lll->phy_tx, lll->phy_flags);
   145d4:	f894 0048 	ldrb.w	r0, [r4, #72]	; 0x48
   145d8:	f3c0 01c0 	ubfx	r1, r0, #3, #1
   145dc:	f000 0007 	and.w	r0, r0, #7
   145e0:	f009 fad5 	bl	1db8e <radio_tx_chain_delay_get>
	radio_tmr_hcto_configure(hcto);
   145e4:	1a28      	subs	r0, r5, r0
   145e6:	f001 fceb 	bl	15fc0 <radio_tmr_hcto_configure>
	radio_isr_set(lll_conn_isr_rx, param);
   145ea:	4621      	mov	r1, r4
   145ec:	4806      	ldr	r0, [pc, #24]	; (14608 <lll_conn_isr_tx+0xb8>)
}
   145ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_isr_set(lll_conn_isr_rx, param);
   145f2:	f001 baaf 	b.w	15b54 <radio_isr_set>
		return 24;
   145f6:	2018      	movs	r0, #24
   145f8:	e7eb      	b.n	145d2 <lll_conn_isr_tx+0x82>
   145fa:	bf00      	nop
   145fc:	000220d9 	.word	0x000220d9
   14600:	00021e43 	.word	0x00021e43
   14604:	00020aa4 	.word	0x00020aa4
   14608:	0001460d 	.word	0x0001460d

0001460c <lll_conn_isr_rx>:
{
   1460c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   14610:	4604      	mov	r4, r0
	trx_done = radio_is_done();
   14612:	f001 fb8f 	bl	15d34 <radio_is_done>
   14616:	b2c5      	uxtb	r5, r0
	if (trx_done) {
   14618:	b1a5      	cbz	r5, 14644 <lll_conn_isr_rx+0x38>
		crc_ok = radio_crc_is_valid();
   1461a:	f001 fba1 	bl	15d60 <radio_crc_is_valid>
   1461e:	b2c7      	uxtb	r7, r0
		rssi_ready = radio_rssi_is_ready();
   14620:	f001 fbdc 	bl	15ddc <radio_rssi_is_ready>
	radio_status_reset();
   14624:	f001 fb70 	bl	15d08 <radio_status_reset>
	radio_tmr_status_reset();
   14628:	f001 fc2c 	bl	15e84 <radio_tmr_status_reset>
	radio_rssi_status_reset();
   1462c:	f001 fbce 	bl	15dcc <radio_rssi_status_reset>
	if (!trx_done) {
   14630:	b955      	cbnz	r5, 14648 <lll_conn_isr_rx+0x3c>
		radio_isr_set(isr_done, param);
   14632:	4621      	mov	r1, r4
   14634:	48bd      	ldr	r0, [pc, #756]	; (1492c <lll_conn_isr_rx+0x320>)
   14636:	f001 fa8d 	bl	15b54 <radio_isr_set>
		radio_disable();
   1463a:	f001 fb53 	bl	15ce4 <radio_disable>
}
   1463e:	b003      	add	sp, #12
   14640:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		crc_ok = rssi_ready = 0U;
   14644:	462f      	mov	r7, r5
   14646:	e7ed      	b.n	14624 <lll_conn_isr_rx+0x18>
	trx_cnt++;
   14648:	4ab9      	ldr	r2, [pc, #740]	; (14930 <lll_conn_isr_rx+0x324>)
   1464a:	8813      	ldrh	r3, [r2, #0]
	node_rx = ull_pdu_rx_alloc_peek(1);
   1464c:	2001      	movs	r0, #1
	trx_cnt++;
   1464e:	3301      	adds	r3, #1
   14650:	8013      	strh	r3, [r2, #0]
	node_rx = ull_pdu_rx_alloc_peek(1);
   14652:	f7fb ff87 	bl	10564 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   14656:	4606      	mov	r6, r0
   14658:	b958      	cbnz	r0, 14672 <lll_conn_isr_rx+0x66>
   1465a:	23b7      	movs	r3, #183	; 0xb7
   1465c:	4ab5      	ldr	r2, [pc, #724]	; (14934 <lll_conn_isr_rx+0x328>)
   1465e:	49b6      	ldr	r1, [pc, #728]	; (14938 <lll_conn_isr_rx+0x32c>)
   14660:	48b6      	ldr	r0, [pc, #728]	; (1493c <lll_conn_isr_rx+0x330>)
   14662:	f004 fe87 	bl	19374 <printk>
   14666:	4040      	eors	r0, r0
   14668:	f380 8811 	msr	BASEPRI, r0
   1466c:	f04f 0003 	mov.w	r0, #3
   14670:	df02      	svc	2
	if (crc_ok) {
   14672:	2f00      	cmp	r7, #0
   14674:	f000 814a 	beq.w	1490c <lll_conn_isr_rx+0x300>

static int isr_rx_pdu(struct lll_conn *lll, struct pdu_data *pdu_data_rx,
		      struct node_tx **tx_release, u8_t *is_rx_enqueue)
{
	/* Ack for tx-ed data */
	if (pdu_data_rx->nesn != lll->sn) {
   14678:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
   1467c:	f896 1020 	ldrb.w	r1, [r6, #32]
   14680:	f003 0201 	and.w	r2, r3, #1
   14684:	f3c1 0180 	ubfx	r1, r1, #2, #1
   14688:	4291      	cmp	r1, r2
   1468a:	f000 80dd 	beq.w	14848 <lll_conn_isr_rx+0x23c>
		/* Increment serial number */
		lll->sn++;
   1468e:	f082 0201 	eor.w	r2, r2, #1
   14692:	f362 0300 	bfi	r3, r2, #0, #1
   14696:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62

#if defined(CONFIG_BT_PERIPHERAL)
		/* First ack (and redundantly any other ack) enable use of
		 * slave latency.
		 */
		if (lll->role) {
   1469a:	f994 3021 	ldrsb.w	r3, [r4, #33]	; 0x21
   1469e:	2b00      	cmp	r3, #0
			lll->slave.latency_enabled = 1;
   146a0:	bfbe      	ittt	lt
   146a2:	f894 3024 	ldrblt.w	r3, [r4, #36]	; 0x24
   146a6:	f043 0301 	orrlt.w	r3, r3, #1
   146aa:	f884 3024 	strblt.w	r3, [r4, #36]	; 0x24
		}
#endif /* CONFIG_BT_PERIPHERAL */

		if (!lll->empty) {
   146ae:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
   146b2:	0758      	lsls	r0, r3, #29
   146b4:	f100 80c4 	bmi.w	14840 <lll_conn_isr_rx+0x234>
			struct pdu_data *pdu_data_tx;
			u8_t pdu_data_tx_len;
			struct node_tx *tx;
			memq_link_t *link;

			link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail,
   146b8:	aa01      	add	r2, sp, #4
   146ba:	e9d4 0113 	ldrd	r0, r1, [r4, #76]	; 0x4c
   146be:	f008 fc3a 	bl	1cf36 <memq_peek>
					 (void **)&tx);
			LL_ASSERT(link);
   146c2:	4605      	mov	r5, r0
   146c4:	b960      	cbnz	r0, 146e0 <lll_conn_isr_rx+0xd4>
   146c6:	f240 23a9 	movw	r3, #681	; 0x2a9
   146ca:	4a9a      	ldr	r2, [pc, #616]	; (14934 <lll_conn_isr_rx+0x328>)
   146cc:	499c      	ldr	r1, [pc, #624]	; (14940 <lll_conn_isr_rx+0x334>)
   146ce:	489b      	ldr	r0, [pc, #620]	; (1493c <lll_conn_isr_rx+0x330>)
   146d0:	f004 fe50 	bl	19374 <printk>
   146d4:	4040      	eors	r0, r0
   146d6:	f380 8811 	msr	BASEPRI, r0
   146da:	f04f 0003 	mov.w	r0, #3
   146de:	df02      	svc	2

			pdu_data_tx = (void *)(tx->pdu +
					       lll->packet_tx_head_offset);
   146e0:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61

			pdu_data_tx_len = pdu_data_tx->len;
   146e4:	9a01      	ldr	r2, [sp, #4]
   146e6:	441a      	add	r2, r3
   146e8:	7950      	ldrb	r0, [r2, #5]
#if defined(CONFIG_BT_CTLR_LE_ENC)
			if (pdu_data_tx_len != 0U) {
   146ea:	b150      	cbz	r0, 14702 <lll_conn_isr_rx+0xf6>
				/* if encrypted increment tx counter */
				if (lll->enc_tx) {
   146ec:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
   146f0:	06d1      	lsls	r1, r2, #27
   146f2:	d506      	bpl.n	14702 <lll_conn_isr_rx+0xf6>
					lll->ccm_tx.counter++;
   146f4:	e9d4 2125 	ldrd	r2, r1, [r4, #148]	; 0x94
   146f8:	3201      	adds	r2, #1
   146fa:	f141 0100 	adc.w	r1, r1, #0
   146fe:	e9c4 2125 	strd	r2, r1, [r4, #148]	; 0x94
				}
			}
#endif /* CONFIG_BT_CTLR_LE_ENC */

			lll->packet_tx_head_offset += pdu_data_tx_len;
			if (lll->packet_tx_head_offset ==
   14702:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
			lll->packet_tx_head_offset += pdu_data_tx_len;
   14706:	4403      	add	r3, r0
   14708:	b2db      	uxtb	r3, r3
			if (lll->packet_tx_head_offset ==
   1470a:	429a      	cmp	r2, r3
			lll->packet_tx_head_offset += pdu_data_tx_len;
   1470c:	f884 3061 	strb.w	r3, [r4, #97]	; 0x61
			if (lll->packet_tx_head_offset ==
   14710:	f04f 0200 	mov.w	r2, #0
   14714:	f040 8098 	bne.w	14848 <lll_conn_isr_rx+0x23c>
			    lll->packet_tx_head_len) {
				lll->packet_tx_head_len = 0;
   14718:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
				lll->packet_tx_head_offset = 0;

				memq_dequeue(lll->memq_tx.tail,
   1471c:	f104 014c 	add.w	r1, r4, #76	; 0x4c
   14720:	6d20      	ldr	r0, [r4, #80]	; 0x50
   14722:	f008 fc10 	bl	1cf46 <memq_dequeue>
					     &lll->memq_tx.head, NULL);

				/* TX node UPSTREAM, i.e. Tx node ack path */
				link->next = tx->next; /* Indicates ctrl or data
   14726:	f8dd 8004 	ldr.w	r8, [sp, #4]
   1472a:	f8d8 3000 	ldr.w	r3, [r8]
   1472e:	602b      	str	r3, [r5, #0]
							* pool.
							*/
				tx->next = link;
   14730:	f8c8 5000 	str.w	r5, [r8]
			lll->empty = 0;
		}
	}

	/* process received data */
	if ((pdu_data_rx->sn == lll->nesn) &&
   14734:	f896 2020 	ldrb.w	r2, [r6, #32]
   14738:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
   1473c:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   14740:	f3c3 0340 	ubfx	r3, r3, #1, #1
   14744:	429a      	cmp	r2, r3
   14746:	f000 8082 	beq.w	1484e <lll_conn_isr_rx+0x242>
	u8_t is_rx_enqueue = 0U;
   1474a:	f04f 0900 	mov.w	r9, #0
		crc_expire = 0U;
   1474e:	4b7d      	ldr	r3, [pc, #500]	; (14944 <lll_conn_isr_rx+0x338>)
   14750:	2500      	movs	r5, #0
   14752:	701d      	strb	r5, [r3, #0]
		crc_valid = 1U;
   14754:	4b7c      	ldr	r3, [pc, #496]	; (14948 <lll_conn_isr_rx+0x33c>)
   14756:	2201      	movs	r2, #1
   14758:	701a      	strb	r2, [r3, #0]
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
   1475a:	a901      	add	r1, sp, #4
   1475c:	4620      	mov	r0, r4
   1475e:	f009 f956 	bl	1da0e <lll_conn_pdu_tx_prep>
	is_done = is_crc_backoff || ((crc_ok) && (pdu_data_rx->md == 0) &&
   14762:	2d00      	cmp	r5, #0
   14764:	f040 80fc 	bne.w	14960 <lll_conn_isr_rx+0x354>
   14768:	b147      	cbz	r7, 1477c <lll_conn_isr_rx+0x170>
   1476a:	f896 3020 	ldrb.w	r3, [r6, #32]
   1476e:	06db      	lsls	r3, r3, #27
   14770:	d404      	bmi.n	1477c <lll_conn_isr_rx+0x170>
				     (pdu_data_tx->len == 0));
   14772:	9b01      	ldr	r3, [sp, #4]
	is_done = is_crc_backoff || ((crc_ok) && (pdu_data_rx->md == 0) &&
   14774:	785b      	ldrb	r3, [r3, #1]
   14776:	2b00      	cmp	r3, #0
   14778:	f000 80f2 	beq.w	14960 <lll_conn_isr_rx+0x354>
		radio_tmr_tifs_set(EVENT_IFS_US);
   1477c:	2096      	movs	r0, #150	; 0x96
   1477e:	f001 fb91 	bl	15ea4 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(lll->phy_rx);
   14782:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   14786:	f000 0007 	and.w	r0, r0, #7
   1478a:	f001 fafb 	bl	15d84 <radio_switch_complete_and_rx>
		radio_isr_set(lll_conn_isr_tx, param);
   1478e:	4621      	mov	r1, r4
   14790:	486e      	ldr	r0, [pc, #440]	; (1494c <lll_conn_isr_rx+0x340>)
   14792:	f001 f9df 	bl	15b54 <radio_isr_set>
		radio_tmr_end_capture();
   14796:	f001 fc4b 	bl	16030 <radio_tmr_end_capture>
	pdu_data_tx->sn = lll->sn;
   1479a:	9901      	ldr	r1, [sp, #4]
   1479c:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
   147a0:	780b      	ldrb	r3, [r1, #0]
   147a2:	f3c2 0200 	ubfx	r2, r2, #0, #1
   147a6:	f362 03c3 	bfi	r3, r2, #3, #1
	pdu_data_tx->nesn = lll->nesn;
   147aa:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
   147ae:	f3c2 0240 	ubfx	r2, r2, #1, #1
   147b2:	f362 0382 	bfi	r3, r2, #2, #1
   147b6:	700b      	strb	r3, [r1, #0]
	lll_conn_tx_pkt_set(lll, pdu_data_tx);
   147b8:	4620      	mov	r0, r4
   147ba:	f009 f8ff 	bl	1d9bc <lll_conn_tx_pkt_set>
	LL_ASSERT(!radio_is_ready());
   147be:	f001 faaf 	bl	15d20 <radio_is_ready>
   147c2:	b160      	cbz	r0, 147de <lll_conn_isr_rx+0x1d2>
   147c4:	f240 1321 	movw	r3, #289	; 0x121
   147c8:	4a5a      	ldr	r2, [pc, #360]	; (14934 <lll_conn_isr_rx+0x328>)
   147ca:	4961      	ldr	r1, [pc, #388]	; (14950 <lll_conn_isr_rx+0x344>)
   147cc:	485b      	ldr	r0, [pc, #364]	; (1493c <lll_conn_isr_rx+0x330>)
   147ce:	f004 fdd1 	bl	19374 <printk>
   147d2:	4040      	eors	r0, r0
   147d4:	f380 8811 	msr	BASEPRI, r0
   147d8:	f04f 0003 	mov.w	r0, #3
   147dc:	df02      	svc	2
	if (!radio_tmr_aa_restore()) {
   147de:	f001 fc1b 	bl	16018 <radio_tmr_aa_restore>
   147e2:	b918      	cbnz	r0, 147ec <lll_conn_isr_rx+0x1e0>
		radio_tmr_aa_save(radio_tmr_aa_get());
   147e4:	f001 fc0c 	bl	16000 <radio_tmr_aa_get>
   147e8:	f001 fc10 	bl	1600c <radio_tmr_aa_save>
	if (tx_release) {
   147ec:	f1b8 0f00 	cmp.w	r8, #0
   147f0:	f000 80bd 	beq.w	1496e <lll_conn_isr_rx+0x362>
		LL_ASSERT(lll->handle != 0xFFFF);
   147f4:	8a22      	ldrh	r2, [r4, #16]
   147f6:	f64f 73ff 	movw	r3, #65535	; 0xffff
   147fa:	429a      	cmp	r2, r3
   147fc:	d10c      	bne.n	14818 <lll_conn_isr_rx+0x20c>
   147fe:	f44f 7397 	mov.w	r3, #302	; 0x12e
   14802:	4a4c      	ldr	r2, [pc, #304]	; (14934 <lll_conn_isr_rx+0x328>)
   14804:	4953      	ldr	r1, [pc, #332]	; (14954 <lll_conn_isr_rx+0x348>)
   14806:	484d      	ldr	r0, [pc, #308]	; (1493c <lll_conn_isr_rx+0x330>)
   14808:	f004 fdb4 	bl	19374 <printk>
   1480c:	4040      	eors	r0, r0
   1480e:	f380 8811 	msr	BASEPRI, r0
   14812:	f04f 0003 	mov.w	r0, #3
   14816:	df02      	svc	2
		ull_conn_lll_ack_enqueue(lll->handle, tx_release);
   14818:	4641      	mov	r1, r8
   1481a:	8a20      	ldrh	r0, [r4, #16]
   1481c:	f7ff fbda 	bl	13fd4 <ull_conn_lll_ack_enqueue>
	if (is_rx_enqueue) {
   14820:	f1b9 0f00 	cmp.w	r9, #0
   14824:	d009      	beq.n	1483a <lll_conn_isr_rx+0x22e>
		ull_pdu_rx_alloc();
   14826:	f7fb feb5 	bl	10594 <ull_pdu_rx_alloc>
		node_rx->hdr.type = NODE_RX_TYPE_DC_PDU;
   1482a:	2302      	movs	r3, #2
   1482c:	7133      	strb	r3, [r6, #4]
		node_rx->hdr.handle = lll->handle;
   1482e:	8a23      	ldrh	r3, [r4, #16]
   14830:	80f3      	strh	r3, [r6, #6]
		ull_rx_put(node_rx->hdr.link, node_rx);
   14832:	4631      	mov	r1, r6
   14834:	6830      	ldr	r0, [r6, #0]
   14836:	f7fb fec3 	bl	105c0 <ull_rx_put>
		ull_rx_sched();
   1483a:	f7fb fed1 	bl	105e0 <ull_rx_sched>
	ARG_UNUSED(rssi_ready);
   1483e:	e6fe      	b.n	1463e <lll_conn_isr_rx+0x32>
			lll->empty = 0;
   14840:	f36f 0382 	bfc	r3, #2, #1
   14844:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62
	struct node_tx *tx_release = NULL;
   14848:	f04f 0800 	mov.w	r8, #0
   1484c:	e772      	b.n	14734 <lll_conn_isr_rx+0x128>
	    /* check so that we will NEVER use the rx buffer reserved for empty
	     * packet and internal control enqueue
	     */
	    (ull_pdu_rx_alloc_peek(3) != 0)) {
   1484e:	2003      	movs	r0, #3
   14850:	f7fb fe88 	bl	10564 <ull_pdu_rx_alloc_peek>
	if ((pdu_data_rx->sn == lll->nesn) &&
   14854:	2800      	cmp	r0, #0
   14856:	f43f af78 	beq.w	1474a <lll_conn_isr_rx+0x13e>
		/* Increment next expected serial number */
		lll->nesn++;
   1485a:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
   1485e:	f083 0302 	eor.w	r3, r3, #2
   14862:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62

		if (pdu_data_rx->len != 0) {
   14866:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
   1486a:	2b00      	cmp	r3, #0
   1486c:	f43f af6d 	beq.w	1474a <lll_conn_isr_rx+0x13e>
#if defined(CONFIG_BT_CTLR_LE_ENC)
			/* If required, wait for CCM to finish
			 */
			if (lll->enc_rx) {
   14870:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
   14874:	071a      	lsls	r2, r3, #28
   14876:	d546      	bpl.n	14906 <lll_conn_isr_rx+0x2fa>
				u32_t done;

				done = radio_ccm_is_done();
   14878:	f001 fc48 	bl	1610c <radio_ccm_is_done>
				LL_ASSERT(done);
   1487c:	b960      	cbnz	r0, 14898 <lll_conn_isr_rx+0x28c>
   1487e:	f240 23df 	movw	r3, #735	; 0x2df
   14882:	4a2c      	ldr	r2, [pc, #176]	; (14934 <lll_conn_isr_rx+0x328>)
   14884:	4934      	ldr	r1, [pc, #208]	; (14958 <lll_conn_isr_rx+0x34c>)
   14886:	482d      	ldr	r0, [pc, #180]	; (1493c <lll_conn_isr_rx+0x330>)
   14888:	f004 fd74 	bl	19374 <printk>
   1488c:	4040      	eors	r0, r0
   1488e:	f380 8811 	msr	BASEPRI, r0
   14892:	f04f 0003 	mov.w	r0, #3
   14896:	df02      	svc	2

				bool mic_failure = !radio_ccm_mic_is_valid();
   14898:	f001 fc56 	bl	16148 <radio_ccm_mic_is_valid>

				if (mic_failure &&
   1489c:	4d2f      	ldr	r5, [pc, #188]	; (1495c <lll_conn_isr_rx+0x350>)
   1489e:	bb10      	cbnz	r0, 148e6 <lll_conn_isr_rx+0x2da>
				    lll->ccm_rx.counter == 0 &&
   148a0:	f8d4 2073 	ldr.w	r2, [r4, #115]	; 0x73
   148a4:	f8d4 3077 	ldr.w	r3, [r4, #119]	; 0x77
				if (mic_failure &&
   148a8:	4313      	orrs	r3, r2
   148aa:	d165      	bne.n	14978 <lll_conn_isr_rx+0x36c>
				    (pdu_data_rx->ll_id ==
   148ac:	f896 3020 	ldrb.w	r3, [r6, #32]
				    lll->ccm_rx.counter == 0 &&
   148b0:	f003 0303 	and.w	r3, r3, #3
   148b4:	2b03      	cmp	r3, #3
   148b6:	d15f      	bne.n	14978 <lll_conn_isr_rx+0x36c>
					 * middle of the LL encryption procedure
					 * with MIC failure.
					 * This could be an unencrypted packet
					 */
					struct pdu_data *scratch_pkt =
						radio_pkt_scratch_get();
   148b8:	f001 fa60 	bl	15d7c <radio_pkt_scratch_get>

					if (ctrl_pdu_len_check(
   148bc:	7842      	ldrb	r2, [r0, #1]
   148be:	2a1b      	cmp	r2, #27
						radio_pkt_scratch_get();
   148c0:	4601      	mov	r1, r0
					if (ctrl_pdu_len_check(
   148c2:	d859      	bhi.n	14978 <lll_conn_isr_rx+0x36c>
						scratch_pkt->len)) {
						memcpy(pdu_data_rx,
   148c4:	3203      	adds	r2, #3
   148c6:	f106 0020 	add.w	r0, r6, #32
   148ca:	f006 fb96 	bl	1affa <memcpy>
						       scratch_pkt,
						       scratch_pkt->len +
						       offsetof(struct pdu_data,
							llctrl));
						mic_failure = false;
						lll->ccm_rx.counter--;
   148ce:	f8d4 3073 	ldr.w	r3, [r4, #115]	; 0x73
   148d2:	f8d4 2077 	ldr.w	r2, [r4, #119]	; 0x77
   148d6:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   148da:	f142 32ff 	adc.w	r2, r2, #4294967295	; 0xffffffff
   148de:	f8c4 3073 	str.w	r3, [r4, #115]	; 0x73
   148e2:	f8c4 2077 	str.w	r2, [r4, #119]	; 0x77

					return -EINVAL;
				}

				/* Increment counter */
				lll->ccm_rx.counter++;
   148e6:	f8d4 3073 	ldr.w	r3, [r4, #115]	; 0x73
   148ea:	f8d4 2077 	ldr.w	r2, [r4, #119]	; 0x77
   148ee:	3301      	adds	r3, #1
   148f0:	f142 0200 	adc.w	r2, r2, #0

				/* Record MIC valid */
				mic_state = LLL_CONN_MIC_PASS;
   148f4:	f04f 0901 	mov.w	r9, #1
				lll->ccm_rx.counter++;
   148f8:	f8c4 3073 	str.w	r3, [r4, #115]	; 0x73
   148fc:	f8c4 2077 	str.w	r2, [r4, #119]	; 0x77
				mic_state = LLL_CONN_MIC_PASS;
   14900:	f885 9000 	strb.w	r9, [r5]
		if (err) {
   14904:	e723      	b.n	1474e <lll_conn_isr_rx+0x142>
			}
#endif /* CONFIG_BT_CTLR_LE_ENC */

			/* Enqueue non-empty PDU */
			*is_rx_enqueue = 1U;
   14906:	f04f 0901 	mov.w	r9, #1
   1490a:	e720      	b.n	1474e <lll_conn_isr_rx+0x142>
		if (crc_expire == 0U) {
   1490c:	4b0d      	ldr	r3, [pc, #52]	; (14944 <lll_conn_isr_rx+0x338>)
   1490e:	781a      	ldrb	r2, [r3, #0]
   14910:	b90a      	cbnz	r2, 14916 <lll_conn_isr_rx+0x30a>
			crc_expire = 2U;
   14912:	2202      	movs	r2, #2
   14914:	701a      	strb	r2, [r3, #0]
		crc_expire--;
   14916:	781d      	ldrb	r5, [r3, #0]
   14918:	3d01      	subs	r5, #1
   1491a:	b2ed      	uxtb	r5, r5
   1491c:	701d      	strb	r5, [r3, #0]
	u8_t is_rx_enqueue = 0U;
   1491e:	f04f 0900 	mov.w	r9, #0
		is_crc_backoff = (crc_expire == 0U);
   14922:	fab5 f585 	clz	r5, r5
   14926:	096d      	lsrs	r5, r5, #5
	struct node_tx *tx_release = NULL;
   14928:	46c8      	mov	r8, r9
   1492a:	e716      	b.n	1475a <lll_conn_isr_rx+0x14e>
   1492c:	0001439d 	.word	0x0001439d
   14930:	20001b0e 	.word	0x20001b0e
   14934:	000220d9 	.word	0x000220d9
   14938:	00022133 	.word	0x00022133
   1493c:	00020aa4 	.word	0x00020aa4
   14940:	00021fdb 	.word	0x00021fdb
   14944:	20001c8a 	.word	0x20001c8a
   14948:	20001c8b 	.word	0x20001c8b
   1494c:	00014551 	.word	0x00014551
   14950:	00021e43 	.word	0x00021e43
   14954:	0002211d 	.word	0x0002211d
   14958:	00021bf8 	.word	0x00021bf8
   1495c:	20001c8c 	.word	0x20001c8c
		radio_isr_set(isr_done, param);
   14960:	4621      	mov	r1, r4
   14962:	4808      	ldr	r0, [pc, #32]	; (14984 <lll_conn_isr_rx+0x378>)
   14964:	f001 f8f6 	bl	15b54 <radio_isr_set>
			radio_switch_complete_and_disable();
   14968:	f001 fa22 	bl	15db0 <radio_switch_complete_and_disable>
   1496c:	e715      	b.n	1479a <lll_conn_isr_rx+0x18e>
	if (is_rx_enqueue) {
   1496e:	f1b9 0f00 	cmp.w	r9, #0
   14972:	f43f ae64 	beq.w	1463e <lll_conn_isr_rx+0x32>
   14976:	e756      	b.n	14826 <lll_conn_isr_rx+0x21a>
					mic_state = LLL_CONN_MIC_FAIL;
   14978:	2302      	movs	r3, #2
   1497a:	702b      	strb	r3, [r5, #0]
	u8_t is_rx_enqueue = 0U;
   1497c:	f04f 0900 	mov.w	r9, #0
   14980:	e72d      	b.n	147de <lll_conn_isr_rx+0x1d2>
   14982:	bf00      	nop
   14984:	0001439d 	.word	0x0001439d

00014988 <ticker_op_cb>:
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
		  param == ull_disable_mark_get());
}

static void ticker_op_cb(u32_t status, void *param)
{
   14988:	b508      	push	{r3, lr}
	ARG_UNUSED(param);

	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   1498a:	b160      	cbz	r0, 149a6 <ticker_op_cb+0x1e>
   1498c:	f240 13b9 	movw	r3, #441	; 0x1b9
   14990:	4a05      	ldr	r2, [pc, #20]	; (149a8 <ticker_op_cb+0x20>)
   14992:	4906      	ldr	r1, [pc, #24]	; (149ac <ticker_op_cb+0x24>)
   14994:	4806      	ldr	r0, [pc, #24]	; (149b0 <ticker_op_cb+0x28>)
   14996:	f004 fced 	bl	19374 <printk>
   1499a:	4040      	eors	r0, r0
   1499c:	f380 8811 	msr	BASEPRI, r0
   149a0:	f04f 0003 	mov.w	r0, #3
   149a4:	df02      	svc	2
}
   149a6:	bd08      	pop	{r3, pc}
   149a8:	0002215e 	.word	0x0002215e
   149ac:	00021f46 	.word	0x00021f46
   149b0:	00020aa4 	.word	0x00020aa4

000149b4 <ticker_op_stop_adv_cb>:
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
   149b4:	2801      	cmp	r0, #1
{
   149b6:	b510      	push	{r4, lr}
   149b8:	460c      	mov	r4, r1
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
   149ba:	d110      	bne.n	149de <ticker_op_stop_adv_cb+0x2a>
   149bc:	f7fb fd74 	bl	104a8 <ull_disable_mark_get>
   149c0:	4284      	cmp	r4, r0
   149c2:	d00c      	beq.n	149de <ticker_op_stop_adv_cb+0x2a>
   149c4:	f44f 73d9 	mov.w	r3, #434	; 0x1b2
   149c8:	4a05      	ldr	r2, [pc, #20]	; (149e0 <ticker_op_stop_adv_cb+0x2c>)
   149ca:	4906      	ldr	r1, [pc, #24]	; (149e4 <ticker_op_stop_adv_cb+0x30>)
   149cc:	4806      	ldr	r0, [pc, #24]	; (149e8 <ticker_op_stop_adv_cb+0x34>)
   149ce:	f004 fcd1 	bl	19374 <printk>
   149d2:	4040      	eors	r0, r0
   149d4:	f380 8811 	msr	BASEPRI, r0
   149d8:	f04f 0003 	mov.w	r0, #3
   149dc:	df02      	svc	2
}
   149de:	bd10      	pop	{r4, pc}
   149e0:	0002215e 	.word	0x0002215e
   149e4:	00022198 	.word	0x00022198
   149e8:	00020aa4 	.word	0x00020aa4

000149ec <ull_slave_ticker_cb>:
{
   149ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   149ee:	4605      	mov	r5, r0
   149f0:	460f      	mov	r7, r1
	ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
   149f2:	4601      	mov	r1, r0
   149f4:	4618      	mov	r0, r3
{
   149f6:	4616      	mov	r6, r2
   149f8:	461c      	mov	r4, r3
	ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
   149fa:	f7ec f9e5 	bl	dc8 <ull_conn_llcp>
	if (ret) {
   149fe:	2800      	cmp	r0, #0
   14a00:	d136      	bne.n	14a70 <ull_slave_ticker_cb+0x84>
   14a02:	7c23      	ldrb	r3, [r4, #16]
   14a04:	3301      	adds	r3, #1
   14a06:	b2db      	uxtb	r3, r3
   14a08:	7423      	strb	r3, [r4, #16]
	LL_ASSERT(ref);
   14a0a:	b963      	cbnz	r3, 14a26 <ull_slave_ticker_cb+0x3a>
   14a0c:	f240 1369 	movw	r3, #361	; 0x169
   14a10:	4a18      	ldr	r2, [pc, #96]	; (14a74 <ull_slave_ticker_cb+0x88>)
   14a12:	4919      	ldr	r1, [pc, #100]	; (14a78 <ull_slave_ticker_cb+0x8c>)
   14a14:	4819      	ldr	r0, [pc, #100]	; (14a7c <ull_slave_ticker_cb+0x90>)
   14a16:	f004 fcad 	bl	19374 <printk>
   14a1a:	4040      	eors	r0, r0
   14a1c:	f380 8811 	msr	BASEPRI, r0
   14a20:	f04f 0003 	mov.w	r0, #3
   14a24:	df02      	svc	2
	p.ticks_at_expire = ticks_at_expire;
   14a26:	4a16      	ldr	r2, [pc, #88]	; (14a80 <ull_slave_ticker_cb+0x94>)
	p.param = &conn->lll;
   14a28:	f104 031c 	add.w	r3, r4, #28
   14a2c:	60d3      	str	r3, [r2, #12]
	mfy.param = &p;
   14a2e:	4b15      	ldr	r3, [pc, #84]	; (14a84 <ull_slave_ticker_cb+0x98>)
	p.lazy = lazy;
   14a30:	8116      	strh	r6, [r2, #8]
	p.remainder = remainder;
   14a32:	e9c2 5700 	strd	r5, r7, [r2]
	mfy.param = &p;
   14a36:	609a      	str	r2, [r3, #8]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   14a38:	2200      	movs	r2, #0
   14a3a:	4611      	mov	r1, r2
   14a3c:	2001      	movs	r0, #1
   14a3e:	f7f9 f84d 	bl	dadc <mayfly_enqueue>
	LL_ASSERT(!err);
   14a42:	b160      	cbz	r0, 14a5e <ull_slave_ticker_cb+0x72>
   14a44:	f240 1375 	movw	r3, #373	; 0x175
   14a48:	4a0a      	ldr	r2, [pc, #40]	; (14a74 <ull_slave_ticker_cb+0x88>)
   14a4a:	490f      	ldr	r1, [pc, #60]	; (14a88 <ull_slave_ticker_cb+0x9c>)
   14a4c:	480b      	ldr	r0, [pc, #44]	; (14a7c <ull_slave_ticker_cb+0x90>)
   14a4e:	f004 fc91 	bl	19374 <printk>
   14a52:	4040      	eors	r0, r0
   14a54:	f380 8811 	msr	BASEPRI, r0
   14a58:	f04f 0003 	mov.w	r0, #3
   14a5c:	df02      	svc	2
	ull_conn_tx_demux(UINT8_MAX);
   14a5e:	20ff      	movs	r0, #255	; 0xff
   14a60:	f7ff f96a 	bl	13d38 <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
   14a64:	4620      	mov	r0, r4
   14a66:	21ff      	movs	r1, #255	; 0xff
}
   14a68:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
   14a6c:	f7ff b9aa 	b.w	13dc4 <ull_conn_tx_lll_enqueue>
}
   14a70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   14a72:	bf00      	nop
   14a74:	0002215e 	.word	0x0002215e
   14a78:	00021be9 	.word	0x00021be9
   14a7c:	00020aa4 	.word	0x00020aa4
   14a80:	2000149c 	.word	0x2000149c
   14a84:	20005968 	.word	0x20005968
   14a88:	00021bdb 	.word	0x00021bdb

00014a8c <prepare_cb>:
{
	return 0;
}

static int prepare_cb(struct lll_prepare_param *prepare_param)
{
   14a8c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	struct lll_conn *lll = prepare_param->param;
   14a90:	68c4      	ldr	r4, [r0, #12]

	DEBUG_RADIO_START_S(1);

	/* TODO: Do the below in ULL ?  */

	lazy = prepare_param->lazy;
   14a92:	8903      	ldrh	r3, [r0, #8]

	/* Calc window widening */
	if (lll->role) {
   14a94:	f994 2021 	ldrsb.w	r2, [r4, #33]	; 0x21
   14a98:	2a00      	cmp	r2, #0
{
   14a9a:	4605      	mov	r5, r0
	if (lll->role) {
   14a9c:	da09      	bge.n	14ab2 <prepare_cb+0x26>
		lll->slave.window_widening_prepare_us +=
		    lll->slave.window_widening_periodic_us * (lazy + 1);
   14a9e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
		lll->slave.window_widening_prepare_us +=
   14aa0:	6b21      	ldr	r1, [r4, #48]	; 0x30
		    lll->slave.window_widening_periodic_us * (lazy + 1);
   14aa2:	fb03 2202 	mla	r2, r3, r2, r2
		lll->slave.window_widening_prepare_us +=
   14aa6:	440a      	add	r2, r1
		if (lll->slave.window_widening_prepare_us >
		    lll->slave.window_widening_max_us) {
   14aa8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
			lll->slave.window_widening_prepare_us =
   14aaa:	4291      	cmp	r1, r2
   14aac:	bf94      	ite	ls
   14aae:	6321      	strls	r1, [r4, #48]	; 0x30
   14ab0:	6322      	strhi	r2, [r4, #48]	; 0x30
				lll->slave.window_widening_max_us;
		}
	}

	/* save the latency for use in event */
	lll->latency_prepare += lazy;
   14ab2:	8ae2      	ldrh	r2, [r4, #22]
   14ab4:	4413      	add	r3, r2

	/* calc current event counter value */
	event_counter = lll->event_counter + lll->latency_prepare;
   14ab6:	8b62      	ldrh	r2, [r4, #26]
	lll->latency_prepare += lazy;
   14ab8:	b29b      	uxth	r3, r3
   14aba:	82e3      	strh	r3, [r4, #22]
	event_counter = lll->event_counter + lll->latency_prepare;
   14abc:	4413      	add	r3, r2

	/* store the next event counter value */
	lll->event_counter = event_counter + 1;
   14abe:	3301      	adds	r3, #1
   14ac0:	8363      	strh	r3, [r4, #26]

	/* TODO: Do the above in ULL ?  */

	/* Reset connection event global variables */
	lll_conn_prepare_reset();
   14ac2:	f7ff fcc9 	bl	14458 <lll_conn_prepare_reset>

	/* TODO: can we do something in ULL? */
	lll->latency_event = lll->latency_prepare;
	lll->latency_prepare = 0;
   14ac6:	2300      	movs	r3, #0
	lll->latency_event = lll->latency_prepare;
   14ac8:	8ae2      	ldrh	r2, [r4, #22]
	lll->latency_prepare = 0;
   14aca:	82e3      	strh	r3, [r4, #22]

	if (lll->data_chan_sel) {
   14acc:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
	lll->latency_event = lll->latency_prepare;
   14ad0:	8322      	strh	r2, [r4, #24]
	if (lll->data_chan_sel) {
   14ad2:	0659      	lsls	r1, r3, #25
   14ad4:	f104 061c 	add.w	r6, r4, #28
   14ad8:	f140 808e 	bpl.w	14bf8 <prepare_cb+0x16c>
#if defined(CONFIG_BT_CTLR_CHAN_SEL_2)
		data_chan_use = lll_chan_sel_2(lll->event_counter - 1,
   14adc:	8b60      	ldrh	r0, [r4, #26]
   14ade:	8c61      	ldrh	r1, [r4, #34]	; 0x22
   14ae0:	3801      	subs	r0, #1
   14ae2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   14ae6:	4632      	mov	r2, r6
   14ae8:	b280      	uxth	r0, r0
   14aea:	f7fb ff43 	bl	10974 <lll_chan_sel_2>
					       &lll->data_chan_map[0],
					       lll->data_chan_count);
	}

	/* current window widening */
	lll->slave.window_widening_event_us +=
   14aee:	e9d4 230c 	ldrd	r2, r3, [r4, #48]	; 0x30
   14af2:	4413      	add	r3, r2
		lll->slave.window_widening_prepare_us;
	lll->slave.window_widening_prepare_us = 0;
	if (lll->slave.window_widening_event_us >
	    lll->slave.window_widening_max_us) {
   14af4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
		lll->slave.window_widening_event_us =
   14af6:	429a      	cmp	r2, r3
   14af8:	bf94      	ite	ls
   14afa:	6362      	strls	r2, [r4, #52]	; 0x34
   14afc:	6363      	strhi	r3, [r4, #52]	; 0x34
			lll->slave.window_widening_max_us;
	}

	/* current window size */
	lll->slave.window_size_event_us +=
   14afe:	e9d4 230e 	ldrd	r2, r3, [r4, #56]	; 0x38
	lll->slave.window_widening_prepare_us = 0;
   14b02:	f04f 0800 	mov.w	r8, #0
	lll->slave.window_size_event_us +=
   14b06:	4413      	add	r3, r2
		lll->slave.window_size_prepare_us;
	lll->slave.window_size_prepare_us = 0;
   14b08:	e9c4 830e 	strd	r8, r3, [r4, #56]	; 0x38
	lll->slave.window_widening_prepare_us = 0;
   14b0c:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
   14b10:	4606      	mov	r6, r0

	/* Start setting up Radio h/w */
	radio_reset();
   14b12:	f001 f83f 	bl	15b94 <radio_reset>
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	radio_tx_power_set(lll->tx_pwr_lvl);
#else
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   14b16:	4640      	mov	r0, r8
   14b18:	f001 f870 	bl	15bfc <radio_tx_power_set>
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */

	lll_conn_rx_pkt_set(lll);
   14b1c:	4620      	mov	r0, r4
   14b1e:	f7ff fcd5 	bl	144cc <lll_conn_rx_pkt_set>

	radio_aa_set(lll->access_addr);
   14b22:	f104 0008 	add.w	r0, r4, #8
   14b26:	f001 f887 	bl	15c38 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
			    (((u32_t)lll->crc_init[2] << 16) |
			     ((u32_t)lll->crc_init[1] << 8) |
   14b2a:	7b63      	ldrb	r3, [r4, #13]
			    (((u32_t)lll->crc_init[2] << 16) |
   14b2c:	7ba1      	ldrb	r1, [r4, #14]
			     ((u32_t)lll->crc_init[1] << 8) |
   14b2e:	021b      	lsls	r3, r3, #8
			    (((u32_t)lll->crc_init[2] << 16) |
   14b30:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
			     ((u32_t)lll->crc_init[0])));
   14b34:	7b21      	ldrb	r1, [r4, #12]
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
   14b36:	f240 605b 	movw	r0, #1627	; 0x65b
   14b3a:	4319      	orrs	r1, r3
   14b3c:	f001 f904 	bl	15d48 <radio_crc_configure>

	lll_chan_set(data_chan_use);
   14b40:	4630      	mov	r0, r6
   14b42:	f7fc f9d5 	bl	10ef0 <lll_chan_set>

	radio_isr_set(lll_conn_isr_rx, lll);
   14b46:	4621      	mov	r1, r4
   14b48:	483b      	ldr	r0, [pc, #236]	; (14c38 <prepare_cb+0x1ac>)
   14b4a:	f001 f803 	bl	15b54 <radio_isr_set>

	radio_tmr_tifs_set(EVENT_IFS_US);
   14b4e:	2096      	movs	r0, #150	; 0x96
   14b50:	f001 f9a8 	bl	15ea4 <radio_tmr_tifs_set>

#if defined(CONFIG_BT_CTLR_PHY)
	radio_switch_complete_and_tx(lll->phy_rx, 0, lll->phy_tx,
				     lll->phy_flags);
   14b54:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
	radio_switch_complete_and_tx(lll->phy_rx, 0, lll->phy_tx,
   14b58:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   14b5c:	f3c2 03c0 	ubfx	r3, r2, #3, #1
   14b60:	4641      	mov	r1, r8
   14b62:	f002 0207 	and.w	r2, r2, #7
   14b66:	f000 0007 	and.w	r0, r0, #7
   14b6a:	f001 f917 	bl	15d9c <radio_switch_complete_and_tx>
#else /* !CONFIG_BT_CTLR_PHY */
	radio_switch_complete_and_tx(0, 0, 0, 0);
#endif /* !CONFIG_BT_CTLR_PHY */

	ticks_at_event = prepare_param->ticks_at_expire;
	evt = HDR_LLL2EVT(lll);
   14b6e:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
   14b70:	682e      	ldr	r6, [r5, #0]
	ticks_at_event += lll_evt_offset_get(evt);
   14b72:	4638      	mov	r0, r7
   14b74:	f008 fc25 	bl	1d3c2 <lll_evt_offset_get>
   14b78:	4406      	add	r6, r0

	ticks_at_start = ticks_at_event;
	ticks_at_start += HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US);

	remainder = prepare_param->remainder;
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
   14b7a:	686a      	ldr	r2, [r5, #4]
   14b7c:	f106 0109 	add.w	r1, r6, #9
   14b80:	4640      	mov	r0, r8
   14b82:	f001 f99b 	bl	15ebc <radio_tmr_start>
   14b86:	4681      	mov	r9, r0

	radio_tmr_aa_capture();
   14b88:	f001 fa26 	bl	15fd8 <radio_tmr_aa_capture>
	radio_tmr_aa_save(0);
   14b8c:	4640      	mov	r0, r8
   14b8e:	f001 fa3d 	bl	1600c <radio_tmr_aa_save>

	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
   14b92:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	       (lll->slave.window_widening_event_us << 1) +
   14b94:	6b60      	ldr	r0, [r4, #52]	; 0x34
	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
   14b96:	f103 0550 	add.w	r5, r3, #80	; 0x50
   14b9a:	eb05 0540 	add.w	r5, r5, r0, lsl #1
	       lll->slave.window_size_event_us;

#if defined(CONFIG_BT_CTLR_PHY)
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
   14b9e:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   14ba2:	2101      	movs	r1, #1
   14ba4:	f000 0007 	and.w	r0, r0, #7
   14ba8:	f008 fff3 	bl	1db92 <radio_rx_ready_delay_get>
	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
   14bac:	444d      	add	r5, r9
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
   14bae:	4405      	add	r5, r0
	hcto += addr_us_get(lll->phy_rx);
   14bb0:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   14bb4:	f000 0007 	and.w	r0, r0, #7
	switch (phy) {
   14bb8:	2802      	cmp	r0, #2
   14bba:	d028      	beq.n	14c0e <prepare_cb+0x182>
		return 40;
   14bbc:	2804      	cmp	r0, #4
   14bbe:	bf0c      	ite	eq
   14bc0:	f44f 73bc 	moveq.w	r3, #376	; 0x178
   14bc4:	2328      	movne	r3, #40	; 0x28
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
   14bc6:	2101      	movs	r1, #1
	hcto += addr_us_get(lll->phy_rx);
   14bc8:	441d      	add	r5, r3
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
   14bca:	f008 ffe4 	bl	1db96 <radio_rx_chain_delay_get>
	hcto += radio_rx_ready_delay_get(0, 0);
	hcto += addr_us_get(0);
	hcto += radio_rx_chain_delay_get(0, 0);
#endif /* !CONFIG_BT_CTLR_PHY */

	radio_tmr_hcto_configure(hcto);
   14bce:	4428      	add	r0, r5
   14bd0:	f001 f9f6 	bl	15fc0 <radio_tmr_hcto_configure>
#endif /* CONFIG_BT_CTLR_CONN_RSSI */

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
	(EVENT_OVERHEAD_PREEMPT_US <= EVENT_OVERHEAD_PREEMPT_MIN_US)
	/* check if preempt to start has changed */
	if (lll_preempt_calc(evt, (TICKER_ID_CONN_BASE + lll->handle),
   14bd4:	7c21      	ldrb	r1, [r4, #16]
   14bd6:	3103      	adds	r1, #3
   14bd8:	4632      	mov	r2, r6
   14bda:	b2c9      	uxtb	r1, r1
   14bdc:	4638      	mov	r0, r7
   14bde:	f008 fbfe 	bl	1d3de <lll_preempt_calc>
   14be2:	b1b0      	cbz	r0, 14c12 <prepare_cb+0x186>
			     ticks_at_event)) {
		radio_isr_set(lll_conn_isr_abort, lll);
   14be4:	4621      	mov	r1, r4
   14be6:	4815      	ldr	r0, [pc, #84]	; (14c3c <prepare_cb+0x1b0>)
   14be8:	f000 ffb4 	bl	15b54 <radio_isr_set>
		radio_disable();
   14bec:	f001 f87a 	bl	15ce4 <radio_disable>
	}

	DEBUG_RADIO_START_S(1);

	return 0;
}
   14bf0:	2000      	movs	r0, #0
   14bf2:	b003      	add	sp, #12
   14bf4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
   14bf8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   14bfc:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
   14c00:	9300      	str	r3, [sp, #0]
   14c02:	f104 0023 	add.w	r0, r4, #35	; 0x23
   14c06:	4633      	mov	r3, r6
   14c08:	f008 fb97 	bl	1d33a <lll_chan_sel_1>
   14c0c:	e76f      	b.n	14aee <prepare_cb+0x62>
		return 24;
   14c0e:	2318      	movs	r3, #24
   14c10:	e7d9      	b.n	14bc6 <prepare_cb+0x13a>
		ret = lll_prepare_done(lll);
   14c12:	4620      	mov	r0, r4
   14c14:	f008 fbd3 	bl	1d3be <lll_prepare_done>
		LL_ASSERT(!ret);
   14c18:	2800      	cmp	r0, #0
   14c1a:	d0e9      	beq.n	14bf0 <prepare_cb+0x164>
   14c1c:	23ff      	movs	r3, #255	; 0xff
   14c1e:	4a08      	ldr	r2, [pc, #32]	; (14c40 <prepare_cb+0x1b4>)
   14c20:	4908      	ldr	r1, [pc, #32]	; (14c44 <prepare_cb+0x1b8>)
   14c22:	4809      	ldr	r0, [pc, #36]	; (14c48 <prepare_cb+0x1bc>)
   14c24:	f004 fba6 	bl	19374 <printk>
   14c28:	4040      	eors	r0, r0
   14c2a:	f380 8811 	msr	BASEPRI, r0
   14c2e:	f04f 0003 	mov.w	r0, #3
   14c32:	df02      	svc	2
   14c34:	e7dc      	b.n	14bf0 <prepare_cb+0x164>
   14c36:	bf00      	nop
   14c38:	0001460d 	.word	0x0001460d
   14c3c:	0001d99b 	.word	0x0001d99b
   14c40:	000221c7 	.word	0x000221c7
   14c44:	00021ae5 	.word	0x00021ae5
   14c48:	00020aa4 	.word	0x00020aa4

00014c4c <lll_slave_prepare>:
{
   14c4c:	b513      	push	{r0, r1, r4, lr}
   14c4e:	4604      	mov	r4, r0
	err = lll_clk_on();
   14c50:	f7fc f93e 	bl	10ed0 <lll_clk_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
   14c54:	b168      	cbz	r0, 14c72 <lll_slave_prepare+0x26>
   14c56:	3044      	adds	r0, #68	; 0x44
   14c58:	d00b      	beq.n	14c72 <lll_slave_prepare+0x26>
   14c5a:	2345      	movs	r3, #69	; 0x45
   14c5c:	4a11      	ldr	r2, [pc, #68]	; (14ca4 <lll_slave_prepare+0x58>)
   14c5e:	4912      	ldr	r1, [pc, #72]	; (14ca8 <lll_slave_prepare+0x5c>)
   14c60:	4812      	ldr	r0, [pc, #72]	; (14cac <lll_slave_prepare+0x60>)
   14c62:	f004 fb87 	bl	19374 <printk>
   14c66:	4040      	eors	r0, r0
   14c68:	f380 8811 	msr	BASEPRI, r0
   14c6c:	f04f 0003 	mov.w	r0, #3
   14c70:	df02      	svc	2
	err = lll_prepare(lll_conn_is_abort_cb, lll_conn_abort_cb, prepare_cb,
   14c72:	9400      	str	r4, [sp, #0]
   14c74:	2300      	movs	r3, #0
   14c76:	4a0e      	ldr	r2, [pc, #56]	; (14cb0 <lll_slave_prepare+0x64>)
   14c78:	490e      	ldr	r1, [pc, #56]	; (14cb4 <lll_slave_prepare+0x68>)
   14c7a:	480f      	ldr	r0, [pc, #60]	; (14cb8 <lll_slave_prepare+0x6c>)
   14c7c:	f008 fb96 	bl	1d3ac <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   14c80:	b168      	cbz	r0, 14c9e <lll_slave_prepare+0x52>
   14c82:	3044      	adds	r0, #68	; 0x44
   14c84:	d00b      	beq.n	14c9e <lll_slave_prepare+0x52>
   14c86:	2349      	movs	r3, #73	; 0x49
   14c88:	4a06      	ldr	r2, [pc, #24]	; (14ca4 <lll_slave_prepare+0x58>)
   14c8a:	4907      	ldr	r1, [pc, #28]	; (14ca8 <lll_slave_prepare+0x5c>)
   14c8c:	4807      	ldr	r0, [pc, #28]	; (14cac <lll_slave_prepare+0x60>)
   14c8e:	f004 fb71 	bl	19374 <printk>
   14c92:	4040      	eors	r0, r0
   14c94:	f380 8811 	msr	BASEPRI, r0
   14c98:	f04f 0003 	mov.w	r0, #3
   14c9c:	df02      	svc	2
}
   14c9e:	b002      	add	sp, #8
   14ca0:	bd10      	pop	{r4, pc}
   14ca2:	bf00      	nop
   14ca4:	000221c7 	.word	0x000221c7
   14ca8:	00021dda 	.word	0x00021dda
   14cac:	00020aa4 	.word	0x00020aa4
   14cb0:	00014a8d 	.word	0x00014a8d
   14cb4:	0001447d 	.word	0x0001447d
   14cb8:	0001d995 	.word	0x0001d995

00014cbc <wl_find>:
		wl[i].taken = 0U;
	}
}

static u8_t wl_find(u8_t addr_type, u8_t *addr, u8_t *free)
{
   14cbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14cc0:	4688      	mov	r8, r1
	int i;

	if (free) {
   14cc2:	4615      	mov	r5, r2
   14cc4:	b10a      	cbz	r2, 14cca <wl_find+0xe>
		*free = FILTER_IDX_NONE;
   14cc6:	23ff      	movs	r3, #255	; 0xff
   14cc8:	7013      	strb	r3, [r2, #0]
	}

	for (i = 0; i < WL_SIZE; i++) {
		if (LIST_MATCH(wl, i, addr_type, addr)) {
   14cca:	4f14      	ldr	r7, [pc, #80]	; (14d1c <wl_find+0x60>)
{
   14ccc:	2400      	movs	r4, #0
		if (LIST_MATCH(wl, i, addr_type, addr)) {
   14cce:	f000 0601 	and.w	r6, r0, #1
   14cd2:	f817 3034 	ldrb.w	r3, [r7, r4, lsl #3]
   14cd6:	07da      	lsls	r2, r3, #31
   14cd8:	d51c      	bpl.n	14d14 <wl_find+0x58>
   14cda:	f3c3 0340 	ubfx	r3, r3, #1, #1
   14cde:	42b3      	cmp	r3, r6
   14ce0:	d113      	bne.n	14d0a <wl_find+0x4e>
   14ce2:	480f      	ldr	r0, [pc, #60]	; (14d20 <wl_find+0x64>)
   14ce4:	2206      	movs	r2, #6
   14ce6:	4641      	mov	r1, r8
   14ce8:	eb00 00c4 	add.w	r0, r0, r4, lsl #3
   14cec:	f006 f975 	bl	1afda <memcmp>
   14cf0:	b910      	cbnz	r0, 14cf8 <wl_find+0x3c>
			return i;
   14cf2:	b2e0      	uxtb	r0, r4
			*free = i;
		}
	}

	return FILTER_IDX_NONE;
}
   14cf4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		} else if (free && !wl[i].taken && (*free == FILTER_IDX_NONE)) {
   14cf8:	b13d      	cbz	r5, 14d0a <wl_find+0x4e>
   14cfa:	f817 3034 	ldrb.w	r3, [r7, r4, lsl #3]
   14cfe:	07db      	lsls	r3, r3, #31
   14d00:	d403      	bmi.n	14d0a <wl_find+0x4e>
   14d02:	782b      	ldrb	r3, [r5, #0]
   14d04:	2bff      	cmp	r3, #255	; 0xff
			*free = i;
   14d06:	bf08      	it	eq
   14d08:	702c      	strbeq	r4, [r5, #0]
	for (i = 0; i < WL_SIZE; i++) {
   14d0a:	3401      	adds	r4, #1
   14d0c:	2c08      	cmp	r4, #8
   14d0e:	d1e0      	bne.n	14cd2 <wl_find+0x16>
	return FILTER_IDX_NONE;
   14d10:	20ff      	movs	r0, #255	; 0xff
   14d12:	e7ef      	b.n	14cf4 <wl_find+0x38>
		} else if (free && !wl[i].taken && (*free == FILTER_IDX_NONE)) {
   14d14:	2d00      	cmp	r5, #0
   14d16:	d1f4      	bne.n	14d02 <wl_find+0x46>
   14d18:	e7f7      	b.n	14d0a <wl_find+0x4e>
   14d1a:	bf00      	nop
   14d1c:	20001d79 	.word	0x20001d79
   14d20:	20001d7b 	.word	0x20001d7b

00014d24 <ll_wl_clear>:
{
   14d24:	b508      	push	{r3, lr}
	if (ull_adv_filter_pol_get(0)) {
   14d26:	2000      	movs	r0, #0
   14d28:	f008 fb78 	bl	1d41c <ull_adv_filter_pol_get>
   14d2c:	bb58      	cbnz	r0, 14d86 <ll_wl_clear+0x62>
		wl[i].taken = 0U;
   14d2e:	4b17      	ldr	r3, [pc, #92]	; (14d8c <ll_wl_clear+0x68>)
   14d30:	781a      	ldrb	r2, [r3, #0]
   14d32:	f360 0200 	bfi	r2, r0, #0, #1
   14d36:	701a      	strb	r2, [r3, #0]
   14d38:	7a1a      	ldrb	r2, [r3, #8]
   14d3a:	f360 0200 	bfi	r2, r0, #0, #1
   14d3e:	721a      	strb	r2, [r3, #8]
   14d40:	7c1a      	ldrb	r2, [r3, #16]
   14d42:	f360 0200 	bfi	r2, r0, #0, #1
   14d46:	741a      	strb	r2, [r3, #16]
   14d48:	7e1a      	ldrb	r2, [r3, #24]
   14d4a:	f360 0200 	bfi	r2, r0, #0, #1
   14d4e:	761a      	strb	r2, [r3, #24]
   14d50:	f893 2020 	ldrb.w	r2, [r3, #32]
   14d54:	f360 0200 	bfi	r2, r0, #0, #1
   14d58:	f883 2020 	strb.w	r2, [r3, #32]
   14d5c:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
   14d60:	f360 0200 	bfi	r2, r0, #0, #1
   14d64:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
   14d68:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
   14d6c:	f360 0200 	bfi	r2, r0, #0, #1
   14d70:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
   14d74:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
   14d78:	f360 0200 	bfi	r2, r0, #0, #1
   14d7c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
	wl_anon = 0U;
   14d80:	4b03      	ldr	r3, [pc, #12]	; (14d90 <ll_wl_clear+0x6c>)
   14d82:	7018      	strb	r0, [r3, #0]
}
   14d84:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   14d86:	200c      	movs	r0, #12
   14d88:	e7fc      	b.n	14d84 <ll_wl_clear+0x60>
   14d8a:	bf00      	nop
   14d8c:	20001d79 	.word	0x20001d79
   14d90:	20001db9 	.word	0x20001db9

00014d94 <ll_wl_remove>:
{
   14d94:	b538      	push	{r3, r4, r5, lr}
   14d96:	4605      	mov	r5, r0
	if (ull_adv_filter_pol_get(0)) {
   14d98:	2000      	movs	r0, #0
   14d9a:	f008 fb3f 	bl	1d41c <ull_adv_filter_pol_get>
   14d9e:	4604      	mov	r4, r0
   14da0:	bb18      	cbnz	r0, 14dea <ll_wl_remove+0x56>
	if (addr->type == ADDR_TYPE_ANON) {
   14da2:	7828      	ldrb	r0, [r5, #0]
   14da4:	28ff      	cmp	r0, #255	; 0xff
   14da6:	d103      	bne.n	14db0 <ll_wl_remove+0x1c>
		wl_anon = 0U;
   14da8:	4b11      	ldr	r3, [pc, #68]	; (14df0 <ll_wl_remove+0x5c>)
		return 0;
   14daa:	4620      	mov	r0, r4
		wl_anon = 0U;
   14dac:	701c      	strb	r4, [r3, #0]
}
   14dae:	bd38      	pop	{r3, r4, r5, pc}
}

static u32_t wl_remove(bt_addr_le_t *id_addr)
{
	/* find the device and mark it as empty */
	u8_t i = wl_find(id_addr->type, id_addr->a.val, NULL);
   14db0:	4622      	mov	r2, r4
   14db2:	1c69      	adds	r1, r5, #1
   14db4:	f7ff ff82 	bl	14cbc <wl_find>

	if (i < ARRAY_SIZE(wl)) {
   14db8:	2807      	cmp	r0, #7
   14dba:	d814      	bhi.n	14de6 <ll_wl_remove+0x52>
		u8_t j = wl[i].rl_idx;
   14dbc:	4b0d      	ldr	r3, [pc, #52]	; (14df4 <ll_wl_remove+0x60>)
   14dbe:	eb03 02c0 	add.w	r2, r3, r0, lsl #3
   14dc2:	7855      	ldrb	r5, [r2, #1]

		if (j < ARRAY_SIZE(rl)) {
   14dc4:	2d07      	cmp	r5, #7
   14dc6:	d806      	bhi.n	14dd6 <ll_wl_remove+0x42>
			rl[j].wl = 0U;
   14dc8:	2228      	movs	r2, #40	; 0x28
   14dca:	490b      	ldr	r1, [pc, #44]	; (14df8 <ll_wl_remove+0x64>)
   14dcc:	436a      	muls	r2, r5
   14dce:	5c8d      	ldrb	r5, [r1, r2]
   14dd0:	f364 1545 	bfi	r5, r4, #5, #1
   14dd4:	548d      	strb	r5, [r1, r2]
		}
		wl[i].taken = 0U;
   14dd6:	f813 2030 	ldrb.w	r2, [r3, r0, lsl #3]
   14dda:	f36f 0200 	bfc	r2, #0, #1
   14dde:	f803 2030 	strb.w	r2, [r3, r0, lsl #3]
	return wl_remove(addr);
   14de2:	b2e0      	uxtb	r0, r4
   14de4:	e7e3      	b.n	14dae <ll_wl_remove+0x1a>
		return 0;
	}

	return BT_HCI_ERR_UNKNOWN_CONN_ID;
   14de6:	2402      	movs	r4, #2
   14de8:	e7fb      	b.n	14de2 <ll_wl_remove+0x4e>
		return BT_HCI_ERR_CMD_DISALLOWED;
   14dea:	200c      	movs	r0, #12
   14dec:	e7df      	b.n	14dae <ll_wl_remove+0x1a>
   14dee:	bf00      	nop
   14df0:	20001db9 	.word	0x20001db9
   14df4:	20001d79 	.word	0x20001d79
   14df8:	200014ac 	.word	0x200014ac

00014dfc <ll_rl_id_addr_get>:
	LL_ASSERT(rl_idx < CONFIG_BT_CTLR_RL_SIZE);
   14dfc:	2807      	cmp	r0, #7
{
   14dfe:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   14e00:	4604      	mov	r4, r0
   14e02:	460f      	mov	r7, r1
   14e04:	4616      	mov	r6, r2
	LL_ASSERT(rl_idx < CONFIG_BT_CTLR_RL_SIZE);
   14e06:	d90b      	bls.n	14e20 <ll_rl_id_addr_get+0x24>
   14e08:	23ff      	movs	r3, #255	; 0xff
   14e0a:	4a17      	ldr	r2, [pc, #92]	; (14e68 <ll_rl_id_addr_get+0x6c>)
   14e0c:	4917      	ldr	r1, [pc, #92]	; (14e6c <ll_rl_id_addr_get+0x70>)
   14e0e:	4818      	ldr	r0, [pc, #96]	; (14e70 <ll_rl_id_addr_get+0x74>)
   14e10:	f004 fab0 	bl	19374 <printk>
   14e14:	4040      	eors	r0, r0
   14e16:	f380 8811 	msr	BASEPRI, r0
   14e1a:	f04f 0003 	mov.w	r0, #3
   14e1e:	df02      	svc	2
	LL_ASSERT(rl[rl_idx].taken);
   14e20:	2328      	movs	r3, #40	; 0x28
   14e22:	4d14      	ldr	r5, [pc, #80]	; (14e74 <ll_rl_id_addr_get+0x78>)
   14e24:	4363      	muls	r3, r4
   14e26:	5ceb      	ldrb	r3, [r5, r3]
   14e28:	07db      	lsls	r3, r3, #31
   14e2a:	d40c      	bmi.n	14e46 <ll_rl_id_addr_get+0x4a>
   14e2c:	f44f 7380 	mov.w	r3, #256	; 0x100
   14e30:	4a0d      	ldr	r2, [pc, #52]	; (14e68 <ll_rl_id_addr_get+0x6c>)
   14e32:	4911      	ldr	r1, [pc, #68]	; (14e78 <ll_rl_id_addr_get+0x7c>)
   14e34:	480e      	ldr	r0, [pc, #56]	; (14e70 <ll_rl_id_addr_get+0x74>)
   14e36:	f004 fa9d 	bl	19374 <printk>
   14e3a:	4040      	eors	r0, r0
   14e3c:	f380 8811 	msr	BASEPRI, r0
   14e40:	f04f 0003 	mov.w	r0, #3
   14e44:	df02      	svc	2
	*id_addr_type = rl[rl_idx].id_addr_type;
   14e46:	2128      	movs	r1, #40	; 0x28
   14e48:	fb01 f304 	mul.w	r3, r1, r4
	memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
   14e4c:	fb01 5104 	mla	r1, r1, r4, r5
	*id_addr_type = rl[rl_idx].id_addr_type;
   14e50:	5ceb      	ldrb	r3, [r5, r3]
   14e52:	f3c3 1380 	ubfx	r3, r3, #6, #1
   14e56:	703b      	strb	r3, [r7, #0]
	memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
   14e58:	4630      	mov	r0, r6
   14e5a:	2206      	movs	r2, #6
   14e5c:	3101      	adds	r1, #1
}
   14e5e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
   14e62:	f006 b8ca 	b.w	1affa <memcpy>
   14e66:	bf00      	nop
   14e68:	0002221e 	.word	0x0002221e
   14e6c:	00022259 	.word	0x00022259
   14e70:	00020aa4 	.word	0x00020aa4
   14e74:	200014ac 	.word	0x200014ac
   14e78:	00022264 	.word	0x00022264

00014e7c <ll_rl_clear>:
{
   14e7c:	b508      	push	{r3, lr}
		if (!rl_enable) {
			return -1;
		}
	}

	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
   14e7e:	2000      	movs	r0, #0
   14e80:	f008 fac5 	bl	1d40e <ull_adv_is_enabled>
	if (!rl_access_check(false)) {
   14e84:	bb88      	cbnz	r0, 14eea <ll_rl_clear+0x6e>
		rl[i].taken = 0U;
   14e86:	4b1a      	ldr	r3, [pc, #104]	; (14ef0 <ll_rl_clear+0x74>)
   14e88:	781a      	ldrb	r2, [r3, #0]
   14e8a:	f360 0200 	bfi	r2, r0, #0, #1
   14e8e:	701a      	strb	r2, [r3, #0]
   14e90:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
   14e94:	f360 0200 	bfi	r2, r0, #0, #1
   14e98:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
   14e9c:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
   14ea0:	f360 0200 	bfi	r2, r0, #0, #1
   14ea4:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
   14ea8:	f893 2078 	ldrb.w	r2, [r3, #120]	; 0x78
   14eac:	f360 0200 	bfi	r2, r0, #0, #1
   14eb0:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
   14eb4:	f893 20a0 	ldrb.w	r2, [r3, #160]	; 0xa0
   14eb8:	f360 0200 	bfi	r2, r0, #0, #1
   14ebc:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0
   14ec0:	f893 20c8 	ldrb.w	r2, [r3, #200]	; 0xc8
   14ec4:	f360 0200 	bfi	r2, r0, #0, #1
   14ec8:	f883 20c8 	strb.w	r2, [r3, #200]	; 0xc8
   14ecc:	f893 20f0 	ldrb.w	r2, [r3, #240]	; 0xf0
   14ed0:	f360 0200 	bfi	r2, r0, #0, #1
   14ed4:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
   14ed8:	f893 2118 	ldrb.w	r2, [r3, #280]	; 0x118
   14edc:	f360 0200 	bfi	r2, r0, #0, #1
   14ee0:	f883 2118 	strb.w	r2, [r3, #280]	; 0x118
	peer_irk_count = 0U;
   14ee4:	4b03      	ldr	r3, [pc, #12]	; (14ef4 <ll_rl_clear+0x78>)
   14ee6:	7018      	strb	r0, [r3, #0]
}
   14ee8:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   14eea:	200c      	movs	r0, #12
   14eec:	e7fc      	b.n	14ee8 <ll_rl_clear+0x6c>
   14eee:	bf00      	nop
   14ef0:	200014ac 	.word	0x200014ac
   14ef4:	20001cbd 	.word	0x20001cbd

00014ef8 <ll_rl_enable>:
{
   14ef8:	b510      	push	{r4, lr}
   14efa:	4604      	mov	r4, r0
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
   14efc:	2000      	movs	r0, #0
   14efe:	f008 fa86 	bl	1d40e <ull_adv_is_enabled>
	if (!rl_access_check(false)) {
   14f02:	b960      	cbnz	r0, 14f1e <ll_rl_enable+0x26>
	switch (enable) {
   14f04:	b124      	cbz	r4, 14f10 <ll_rl_enable+0x18>
   14f06:	2c01      	cmp	r4, #1
   14f08:	d005      	beq.n	14f16 <ll_rl_enable+0x1e>
		return BT_HCI_ERR_INVALID_PARAM;
   14f0a:	2412      	movs	r4, #18
}
   14f0c:	4620      	mov	r0, r4
   14f0e:	bd10      	pop	{r4, pc}
		rl_enable = 0U;
   14f10:	4b04      	ldr	r3, [pc, #16]	; (14f24 <ll_rl_enable+0x2c>)
   14f12:	701c      	strb	r4, [r3, #0]
		break;
   14f14:	e7fa      	b.n	14f0c <ll_rl_enable+0x14>
		rl_enable = 1U;
   14f16:	4b03      	ldr	r3, [pc, #12]	; (14f24 <ll_rl_enable+0x2c>)
   14f18:	701c      	strb	r4, [r3, #0]
	return 0;
   14f1a:	4604      	mov	r4, r0
		break;
   14f1c:	e7f6      	b.n	14f0c <ll_rl_enable+0x14>
		return BT_HCI_ERR_CMD_DISALLOWED;
   14f1e:	240c      	movs	r4, #12
   14f20:	e7f4      	b.n	14f0c <ll_rl_enable+0x14>
   14f22:	bf00      	nop
   14f24:	20001d46 	.word	0x20001d46

00014f28 <ll_rl_timeout_set>:
	rpa_timeout_ms = timeout * 1000U;
   14f28:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   14f2c:	4358      	muls	r0, r3
   14f2e:	4b01      	ldr	r3, [pc, #4]	; (14f34 <ll_rl_timeout_set+0xc>)
   14f30:	6018      	str	r0, [r3, #0]
}
   14f32:	4770      	bx	lr
   14f34:	200015ec 	.word	0x200015ec

00014f38 <ull_filter_adv_scan_state_cb>:
	if (bm) {
   14f38:	b128      	cbz	r0, 14f46 <ull_filter_adv_scan_state_cb+0xe>
}

static void rpa_refresh_start(void)
{
	BT_DBG("");
	k_delayed_work_submit(&rpa_work, rpa_timeout_ms);
   14f3a:	4b04      	ldr	r3, [pc, #16]	; (14f4c <ull_filter_adv_scan_state_cb+0x14>)
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   14f3c:	4904      	ldr	r1, [pc, #16]	; (14f50 <ull_filter_adv_scan_state_cb+0x18>)
   14f3e:	681a      	ldr	r2, [r3, #0]
   14f40:	4804      	ldr	r0, [pc, #16]	; (14f54 <ull_filter_adv_scan_state_cb+0x1c>)
   14f42:	f003 bc11 	b.w	18768 <k_delayed_work_submit_to_queue>
}

static void rpa_refresh_stop(void)
{
	k_delayed_work_cancel(&rpa_work);
   14f46:	4802      	ldr	r0, [pc, #8]	; (14f50 <ull_filter_adv_scan_state_cb+0x18>)
   14f48:	f009 bc06 	b.w	1e758 <k_delayed_work_cancel>
   14f4c:	200015ec 	.word	0x200015ec
   14f50:	200015f0 	.word	0x200015f0
   14f54:	20001a60 	.word	0x20001a60

00014f58 <ull_filter_adv_update>:
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
}

static void filter_clear(struct lll_filter *filter)
{
	filter->enable_bitmask = 0;
   14f58:	4a03      	ldr	r2, [pc, #12]	; (14f68 <ull_filter_adv_update+0x10>)
   14f5a:	2300      	movs	r3, #0
   14f5c:	7013      	strb	r3, [r2, #0]
	filter->addr_type_bitmask = 0;
   14f5e:	7053      	strb	r3, [r2, #1]
	filter->enable_bitmask = 0;
   14f60:	4a02      	ldr	r2, [pc, #8]	; (14f6c <ull_filter_adv_update+0x14>)
   14f62:	7013      	strb	r3, [r2, #0]
	filter->addr_type_bitmask = 0;
   14f64:	7053      	strb	r3, [r2, #1]
}
   14f66:	4770      	bx	lr
   14f68:	20001dba 	.word	0x20001dba
   14f6c:	20001d47 	.word	0x20001d47

00014f70 <ull_filter_adv_pdu_update>:
	if (idx < ARRAY_SIZE(rl) && rl[idx].lirk) {
   14f70:	2907      	cmp	r1, #7
{
   14f72:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14f76:	4607      	mov	r7, r0
   14f78:	460d      	mov	r5, r1
   14f7a:	4614      	mov	r4, r2
   14f7c:	f102 0802 	add.w	r8, r2, #2
	if (idx < ARRAY_SIZE(rl) && rl[idx].lirk) {
   14f80:	d83b      	bhi.n	14ffa <ull_filter_adv_pdu_update+0x8a>
   14f82:	2328      	movs	r3, #40	; 0x28
   14f84:	4e2b      	ldr	r6, [pc, #172]	; (15034 <ull_filter_adv_pdu_update+0xc4>)
   14f86:	434b      	muls	r3, r1
   14f88:	5cf3      	ldrb	r3, [r6, r3]
   14f8a:	071a      	lsls	r2, r3, #28
   14f8c:	d535      	bpl.n	14ffa <ull_filter_adv_pdu_update+0x8a>
		LL_ASSERT(rl[idx].rpas_ready);
   14f8e:	079b      	lsls	r3, r3, #30
   14f90:	d40c      	bmi.n	14fac <ull_filter_adv_pdu_update+0x3c>
   14f92:	f44f 7318 	mov.w	r3, #608	; 0x260
   14f96:	4a28      	ldr	r2, [pc, #160]	; (15038 <ull_filter_adv_pdu_update+0xc8>)
   14f98:	4928      	ldr	r1, [pc, #160]	; (1503c <ull_filter_adv_pdu_update+0xcc>)
   14f9a:	4829      	ldr	r0, [pc, #164]	; (15040 <ull_filter_adv_pdu_update+0xd0>)
   14f9c:	f004 f9ea 	bl	19374 <printk>
   14fa0:	4040      	eors	r0, r0
   14fa2:	f380 8811 	msr	BASEPRI, r0
   14fa6:	f04f 0003 	mov.w	r0, #3
   14faa:	df02      	svc	2
		pdu->tx_addr = 1;
   14fac:	7823      	ldrb	r3, [r4, #0]
   14fae:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   14fb2:	7023      	strb	r3, [r4, #0]
		memcpy(adva, rl[idx].local_rpa->val, BDADDR_SIZE);
   14fb4:	2328      	movs	r3, #40	; 0x28
   14fb6:	fb03 6605 	mla	r6, r3, r5, r6
   14fba:	2206      	movs	r2, #6
   14fbc:	6a71      	ldr	r1, [r6, #36]	; 0x24
   14fbe:	4640      	mov	r0, r8
   14fc0:	f006 f81b 	bl	1affa <memcpy>
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   14fc4:	7823      	ldrb	r3, [r4, #0]
   14fc6:	f003 020f 	and.w	r2, r3, #15
   14fca:	2a01      	cmp	r2, #1
   14fcc:	d12f      	bne.n	1502e <ull_filter_adv_pdu_update+0xbe>
		if (idx < ARRAY_SIZE(rl) && rl[idx].pirk) {
   14fce:	2d07      	cmp	r5, #7
   14fd0:	f104 0008 	add.w	r0, r4, #8
   14fd4:	d81f      	bhi.n	15016 <ull_filter_adv_pdu_update+0xa6>
   14fd6:	2228      	movs	r2, #40	; 0x28
   14fd8:	4916      	ldr	r1, [pc, #88]	; (15034 <ull_filter_adv_pdu_update+0xc4>)
   14fda:	fb02 f605 	mul.w	r6, r2, r5
   14fde:	5d8e      	ldrb	r6, [r1, r6]
   14fe0:	0776      	lsls	r6, r6, #29
   14fe2:	d518      	bpl.n	15016 <ull_filter_adv_pdu_update+0xa6>
			       rl[idx].peer_rpa.val, BDADDR_SIZE);
   14fe4:	fb02 1105 	mla	r1, r2, r5, r1
			pdu->rx_addr = 1;
   14fe8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   14fec:	7023      	strb	r3, [r4, #0]
			memcpy(&pdu->direct_ind.tgt_addr[0],
   14fee:	2206      	movs	r2, #6
   14ff0:	311e      	adds	r1, #30
}
   14ff2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			memcpy(&pdu->direct_ind.tgt_addr[0],
   14ff6:	f006 b800 	b.w	1affa <memcpy>
		pdu->tx_addr = adv->own_addr_type & 0x1;
   14ffa:	f897 00da 	ldrb.w	r0, [r7, #218]	; 0xda
   14ffe:	7823      	ldrb	r3, [r4, #0]
   15000:	f000 0003 	and.w	r0, r0, #3
   15004:	f360 1386 	bfi	r3, r0, #6, #1
   15008:	7023      	strb	r3, [r4, #0]
		ll_addr_get(adv->own_addr_type & 0x1, adva);
   1500a:	4641      	mov	r1, r8
   1500c:	f000 0001 	and.w	r0, r0, #1
   15010:	f7f9 faae 	bl	e570 <ll_addr_get>
   15014:	e7d6      	b.n	14fc4 <ull_filter_adv_pdu_update+0x54>
			pdu->rx_addr = adv->id_addr_type;
   15016:	f897 30da 	ldrb.w	r3, [r7, #218]	; 0xda
   1501a:	7822      	ldrb	r2, [r4, #0]
   1501c:	f3c3 0380 	ubfx	r3, r3, #2, #1
   15020:	f363 12c7 	bfi	r2, r3, #7, #1
   15024:	7022      	strb	r2, [r4, #0]
			memcpy(&pdu->direct_ind.tgt_addr[0],
   15026:	f107 01dc 	add.w	r1, r7, #220	; 0xdc
   1502a:	2206      	movs	r2, #6
   1502c:	e7e1      	b.n	14ff2 <ull_filter_adv_pdu_update+0x82>
}
   1502e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   15032:	bf00      	nop
   15034:	200014ac 	.word	0x200014ac
   15038:	0002221e 	.word	0x0002221e
   1503c:	00022288 	.word	0x00022288
   15040:	00020aa4 	.word	0x00020aa4

00015044 <ull_filter_rl_find>:
{
   15044:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   15048:	468a      	mov	sl, r1
	if (free) {
   1504a:	4614      	mov	r4, r2
   1504c:	b10a      	cbz	r2, 15052 <ull_filter_rl_find+0xe>
		*free = FILTER_IDX_NONE;
   1504e:	23ff      	movs	r3, #255	; 0xff
   15050:	7013      	strb	r3, [r2, #0]
		if (LIST_MATCH(rl, i, id_addr_type, id_addr)) {
   15052:	f8df 9058 	ldr.w	r9, [pc, #88]	; 150ac <ull_filter_rl_find+0x68>
{
   15056:	2500      	movs	r5, #0
		if (LIST_MATCH(rl, i, id_addr_type, id_addr)) {
   15058:	f000 0801 	and.w	r8, r0, #1
   1505c:	2628      	movs	r6, #40	; 0x28
   1505e:	436e      	muls	r6, r5
   15060:	b2ef      	uxtb	r7, r5
   15062:	f819 3006 	ldrb.w	r3, [r9, r6]
   15066:	07da      	lsls	r2, r3, #31
   15068:	d51a      	bpl.n	150a0 <ull_filter_rl_find+0x5c>
   1506a:	f3c3 1380 	ubfx	r3, r3, #6, #1
   1506e:	4543      	cmp	r3, r8
   15070:	d10f      	bne.n	15092 <ull_filter_rl_find+0x4e>
   15072:	480d      	ldr	r0, [pc, #52]	; (150a8 <ull_filter_rl_find+0x64>)
   15074:	2206      	movs	r2, #6
   15076:	4651      	mov	r1, sl
   15078:	4430      	add	r0, r6
   1507a:	f005 ffae 	bl	1afda <memcmp>
   1507e:	b160      	cbz	r0, 1509a <ull_filter_rl_find+0x56>
		} else if (free && !rl[i].taken && (*free == FILTER_IDX_NONE)) {
   15080:	b13c      	cbz	r4, 15092 <ull_filter_rl_find+0x4e>
   15082:	f819 3006 	ldrb.w	r3, [r9, r6]
   15086:	07db      	lsls	r3, r3, #31
   15088:	d403      	bmi.n	15092 <ull_filter_rl_find+0x4e>
   1508a:	7823      	ldrb	r3, [r4, #0]
   1508c:	2bff      	cmp	r3, #255	; 0xff
			*free = i;
   1508e:	bf08      	it	eq
   15090:	7027      	strbeq	r7, [r4, #0]
   15092:	3501      	adds	r5, #1
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
   15094:	2d08      	cmp	r5, #8
   15096:	d1e1      	bne.n	1505c <ull_filter_rl_find+0x18>
	return FILTER_IDX_NONE;
   15098:	27ff      	movs	r7, #255	; 0xff
}
   1509a:	4638      	mov	r0, r7
   1509c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		} else if (free && !rl[i].taken && (*free == FILTER_IDX_NONE)) {
   150a0:	2c00      	cmp	r4, #0
   150a2:	d1f2      	bne.n	1508a <ull_filter_rl_find+0x46>
   150a4:	e7f5      	b.n	15092 <ull_filter_rl_find+0x4e>
   150a6:	bf00      	nop
   150a8:	200014ad 	.word	0x200014ad
   150ac:	200014ac 	.word	0x200014ac

000150b0 <ll_wl_add>:
{
   150b0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   150b4:	4607      	mov	r7, r0
	if (ull_adv_filter_pol_get(0)) {
   150b6:	2000      	movs	r0, #0
   150b8:	f008 f9b0 	bl	1d41c <ull_adv_filter_pol_get>
   150bc:	4604      	mov	r4, r0
   150be:	2800      	cmp	r0, #0
   150c0:	d143      	bne.n	1514a <ll_wl_add+0x9a>
	if (addr->type == ADDR_TYPE_ANON) {
   150c2:	7838      	ldrb	r0, [r7, #0]
   150c4:	28ff      	cmp	r0, #255	; 0xff
   150c6:	d106      	bne.n	150d6 <ll_wl_add+0x26>
		wl_anon = 1U;
   150c8:	4b21      	ldr	r3, [pc, #132]	; (15150 <ll_wl_add+0xa0>)
   150ca:	2201      	movs	r2, #1
   150cc:	701a      	strb	r2, [r3, #0]
		return 0;
   150ce:	4620      	mov	r0, r4
}
   150d0:	b002      	add	sp, #8
   150d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	i = wl_find(id_addr->type, id_addr->a.val, &j);
   150d6:	f107 0801 	add.w	r8, r7, #1
   150da:	f10d 0207 	add.w	r2, sp, #7
   150de:	4641      	mov	r1, r8
   150e0:	f7ff fdec 	bl	14cbc <wl_find>
	if (i < ARRAY_SIZE(wl)) {
   150e4:	2807      	cmp	r0, #7
   150e6:	d929      	bls.n	1513c <ll_wl_add+0x8c>
	} else if (j >= ARRAY_SIZE(wl)) {
   150e8:	f89d 6007 	ldrb.w	r6, [sp, #7]
   150ec:	2e07      	cmp	r6, #7
   150ee:	d82a      	bhi.n	15146 <ll_wl_add+0x96>
	wl[i].id_addr_type = id_addr->type & 0x1;
   150f0:	4d18      	ldr	r5, [pc, #96]	; (15154 <ll_wl_add+0xa4>)
   150f2:	783a      	ldrb	r2, [r7, #0]
   150f4:	f815 3036 	ldrb.w	r3, [r5, r6, lsl #3]
	bt_addr_copy(&wl[i].id_addr, &id_addr->a);
   150f8:	eb05 00c6 	add.w	r0, r5, r6, lsl #3
	wl[i].id_addr_type = id_addr->type & 0x1;
   150fc:	f362 0341 	bfi	r3, r2, #1, #1
	memcpy(dst, src, sizeof(*dst));
   15100:	4641      	mov	r1, r8
   15102:	2206      	movs	r2, #6
   15104:	3002      	adds	r0, #2
   15106:	f805 3036 	strb.w	r3, [r5, r6, lsl #3]
   1510a:	f005 ff76 	bl	1affa <memcpy>
	j = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   1510e:	4622      	mov	r2, r4
   15110:	4641      	mov	r1, r8
   15112:	7838      	ldrb	r0, [r7, #0]
   15114:	f7ff ff96 	bl	15044 <ull_filter_rl_find>
	if (j < ARRAY_SIZE(rl)) {
   15118:	00f3      	lsls	r3, r6, #3
   1511a:	2807      	cmp	r0, #7
		wl[i].rl_idx = j;
   1511c:	442b      	add	r3, r5
	if (j < ARRAY_SIZE(rl)) {
   1511e:	d80f      	bhi.n	15140 <ll_wl_add+0x90>
		wl[i].rl_idx = j;
   15120:	7058      	strb	r0, [r3, #1]
		rl[j].wl = 1U;
   15122:	2328      	movs	r3, #40	; 0x28
   15124:	4a0c      	ldr	r2, [pc, #48]	; (15158 <ll_wl_add+0xa8>)
   15126:	4358      	muls	r0, r3
   15128:	5c13      	ldrb	r3, [r2, r0]
   1512a:	f043 0320 	orr.w	r3, r3, #32
   1512e:	5413      	strb	r3, [r2, r0]
	wl[i].taken = 1U;
   15130:	f815 3036 	ldrb.w	r3, [r5, r6, lsl #3]
   15134:	f043 0301 	orr.w	r3, r3, #1
   15138:	f805 3036 	strb.w	r3, [r5, r6, lsl #3]
	return wl_add(addr);
   1513c:	b2e0      	uxtb	r0, r4
   1513e:	e7c7      	b.n	150d0 <ll_wl_add+0x20>
		wl[i].rl_idx = FILTER_IDX_NONE;
   15140:	22ff      	movs	r2, #255	; 0xff
   15142:	705a      	strb	r2, [r3, #1]
   15144:	e7f4      	b.n	15130 <ll_wl_add+0x80>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
   15146:	2407      	movs	r4, #7
   15148:	e7f8      	b.n	1513c <ll_wl_add+0x8c>
		return BT_HCI_ERR_CMD_DISALLOWED;
   1514a:	200c      	movs	r0, #12
   1514c:	e7c0      	b.n	150d0 <ll_wl_add+0x20>
   1514e:	bf00      	nop
   15150:	20001db9 	.word	0x20001db9
   15154:	20001d79 	.word	0x20001d79
   15158:	200014ac 	.word	0x200014ac

0001515c <ll_rl_add>:
{
   1515c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15160:	4680      	mov	r8, r0
   15162:	b085      	sub	sp, #20
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
   15164:	2000      	movs	r0, #0
{
   15166:	4689      	mov	r9, r1
   15168:	4692      	mov	sl, r2
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
   1516a:	f008 f950 	bl	1d40e <ull_adv_is_enabled>
	if (!rl_access_check(false)) {
   1516e:	2800      	cmp	r0, #0
   15170:	f040 8086 	bne.w	15280 <ll_rl_add+0x124>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, &j);
   15174:	4647      	mov	r7, r8
   15176:	f10d 020f 	add.w	r2, sp, #15
   1517a:	f817 0b01 	ldrb.w	r0, [r7], #1
   1517e:	4639      	mov	r1, r7
   15180:	f7ff ff60 	bl	15044 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
   15184:	2807      	cmp	r0, #7
   15186:	d97d      	bls.n	15284 <ll_rl_add+0x128>
	} else if (j >= ARRAY_SIZE(rl)) {
   15188:	f89d 500f 	ldrb.w	r5, [sp, #15]
   1518c:	2d07      	cmp	r5, #7
   1518e:	d87b      	bhi.n	15288 <ll_rl_add+0x12c>
	bt_addr_copy(&rl[i].id_addr, &id_addr->a);
   15190:	eb05 0b85 	add.w	fp, r5, r5, lsl #2
   15194:	4c3d      	ldr	r4, [pc, #244]	; (1528c <ll_rl_add+0x130>)
   15196:	ea4f 0bcb 	mov.w	fp, fp, lsl #3
	rl[i].id_addr_type = id_addr->type & 0x1;
   1519a:	2628      	movs	r6, #40	; 0x28
   1519c:	436e      	muls	r6, r5
	bt_addr_copy(&rl[i].id_addr, &id_addr->a);
   1519e:	f10b 0001 	add.w	r0, fp, #1
   151a2:	2206      	movs	r2, #6
   151a4:	4639      	mov	r1, r7
   151a6:	4420      	add	r0, r4
   151a8:	f005 ff27 	bl	1affa <memcpy>
	rl[i].id_addr_type = id_addr->type & 0x1;
   151ac:	f898 1000 	ldrb.w	r1, [r8]
   151b0:	5da3      	ldrb	r3, [r4, r6]
   151b2:	19a2      	adds	r2, r4, r6
   151b4:	f361 1386 	bfi	r3, r1, #6, #1
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
   151b8:	4648      	mov	r0, r9
   151ba:	2110      	movs	r1, #16
	rl[i].id_addr_type = id_addr->type & 0x1;
   151bc:	9201      	str	r2, [sp, #4]
   151be:	55a3      	strb	r3, [r4, r6]
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
   151c0:	f007 fe99 	bl	1cef6 <mem_nz>
   151c4:	5da3      	ldrb	r3, [r4, r6]
	rl[i].lirk = mem_nz((u8_t *)lirk, IRK_SIZE);
   151c6:	2110      	movs	r1, #16
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
   151c8:	f360 0382 	bfi	r3, r0, #2, #1
	rl[i].lirk = mem_nz((u8_t *)lirk, IRK_SIZE);
   151cc:	4650      	mov	r0, sl
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
   151ce:	55a3      	strb	r3, [r4, r6]
	rl[i].lirk = mem_nz((u8_t *)lirk, IRK_SIZE);
   151d0:	f007 fe91 	bl	1cef6 <mem_nz>
   151d4:	5da3      	ldrb	r3, [r4, r6]
	if (rl[i].pirk) {
   151d6:	9a01      	ldr	r2, [sp, #4]
	rl[i].lirk = mem_nz((u8_t *)lirk, IRK_SIZE);
   151d8:	f000 0001 	and.w	r0, r0, #1
   151dc:	f360 03c3 	bfi	r3, r0, #3, #1
	if (rl[i].pirk) {
   151e0:	f013 0f04 	tst.w	r3, #4
	rl[i].lirk = mem_nz((u8_t *)lirk, IRK_SIZE);
   151e4:	55a3      	strb	r3, [r4, r6]
	if (rl[i].pirk) {
   151e6:	d137      	bne.n	15258 <ll_rl_add+0xfc>
	if (rl[i].lirk) {
   151e8:	b158      	cbz	r0, 15202 <ll_rl_add+0xa6>
		memcpy(rl[i].local_irk, lirk, IRK_SIZE);
   151ea:	f10b 0007 	add.w	r0, fp, #7
   151ee:	2210      	movs	r2, #16
   151f0:	4651      	mov	r1, sl
   151f2:	4420      	add	r0, r4
   151f4:	f005 ff01 	bl	1affa <memcpy>
		rl[i].local_rpa = NULL;
   151f8:	2328      	movs	r3, #40	; 0x28
   151fa:	fb03 4305 	mla	r3, r3, r5, r4
   151fe:	2200      	movs	r2, #0
   15200:	625a      	str	r2, [r3, #36]	; 0x24
	memset(rl[i].curr_rpa.val, 0x00, sizeof(rl[i].curr_rpa));
   15202:	2628      	movs	r6, #40	; 0x28
   15204:	436e      	muls	r6, r5
   15206:	f10b 0018 	add.w	r0, fp, #24
   1520a:	2206      	movs	r2, #6
   1520c:	2100      	movs	r1, #0
   1520e:	4420      	add	r0, r4
   15210:	f005 ff1d 	bl	1b04e <memset>
	rl[i].rpas_ready = 0U;
   15214:	5da3      	ldrb	r3, [r4, r6]
   15216:	f023 0312 	bic.w	r3, r3, #18
   1521a:	55a3      	strb	r3, [r4, r6]
	j = wl_find(id_addr->type, id_addr->a.val, NULL);
   1521c:	2200      	movs	r2, #0
   1521e:	4639      	mov	r1, r7
   15220:	f898 0000 	ldrb.w	r0, [r8]
   15224:	f7ff fd4a 	bl	14cbc <wl_find>
	if (j < ARRAY_SIZE(wl)) {
   15228:	2807      	cmp	r0, #7
   1522a:	5da3      	ldrb	r3, [r4, r6]
		wl[j].rl_idx = i;
   1522c:	bf9d      	ittte	ls
   1522e:	4a18      	ldrls	r2, [pc, #96]	; (15290 <ll_rl_add+0x134>)
		rl[i].wl = 1U;
   15230:	f043 0320 	orrls.w	r3, r3, #32
		wl[j].rl_idx = i;
   15234:	eb02 02c0 	addls.w	r2, r2, r0, lsl #3
		rl[i].wl = 0U;
   15238:	f36f 1345 	bfchi	r3, #5, #1
   1523c:	55a3      	strb	r3, [r4, r6]
	rl[i].taken = 1U;
   1523e:	f04f 0328 	mov.w	r3, #40	; 0x28
		wl[j].rl_idx = i;
   15242:	bf98      	it	ls
   15244:	7055      	strbls	r5, [r2, #1]
	rl[i].taken = 1U;
   15246:	435d      	muls	r5, r3
	return 0;
   15248:	2000      	movs	r0, #0
	rl[i].taken = 1U;
   1524a:	5d63      	ldrb	r3, [r4, r5]
   1524c:	f043 0301 	orr.w	r3, r3, #1
   15250:	5563      	strb	r3, [r4, r5]
}
   15252:	b005      	add	sp, #20
   15254:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		rl[i].pirk_idx = peer_irk_count;
   15258:	4b0e      	ldr	r3, [pc, #56]	; (15294 <ll_rl_add+0x138>)
   1525a:	7819      	ldrb	r1, [r3, #0]
   1525c:	75d1      	strb	r1, [r2, #23]
		peer_irk_rl_ids[peer_irk_count] = i;
   1525e:	4a0e      	ldr	r2, [pc, #56]	; (15298 <ll_rl_add+0x13c>)
   15260:	5455      	strb	r5, [r2, r1]
		sys_memcpy_swap(peer_irks[peer_irk_count++], pirk, IRK_SIZE);
   15262:	1c4a      	adds	r2, r1, #1
   15264:	701a      	strb	r2, [r3, #0]
	for (; length > 0; length--) {
   15266:	4b0d      	ldr	r3, [pc, #52]	; (1529c <ll_rl_add+0x140>)
   15268:	eb03 1301 	add.w	r3, r3, r1, lsl #4
   1526c:	f109 0210 	add.w	r2, r9, #16
   15270:	3b01      	subs	r3, #1
		*pdst++ = *psrc--;
   15272:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
   15276:	f803 1f01 	strb.w	r1, [r3, #1]!
	for (; length > 0; length--) {
   1527a:	454a      	cmp	r2, r9
   1527c:	d1f9      	bne.n	15272 <ll_rl_add+0x116>
   1527e:	e7b3      	b.n	151e8 <ll_rl_add+0x8c>
		return BT_HCI_ERR_CMD_DISALLOWED;
   15280:	200c      	movs	r0, #12
   15282:	e7e6      	b.n	15252 <ll_rl_add+0xf6>
		return BT_HCI_ERR_INVALID_PARAM;
   15284:	2012      	movs	r0, #18
   15286:	e7e4      	b.n	15252 <ll_rl_add+0xf6>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
   15288:	2007      	movs	r0, #7
   1528a:	e7e2      	b.n	15252 <ll_rl_add+0xf6>
   1528c:	200014ac 	.word	0x200014ac
   15290:	20001d79 	.word	0x20001d79
   15294:	20001cbd 	.word	0x20001cbd
   15298:	20001cbe 	.word	0x20001cbe
   1529c:	20001cc6 	.word	0x20001cc6

000152a0 <ll_rl_remove>:
{
   152a0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   152a4:	4683      	mov	fp, r0
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
   152a6:	2000      	movs	r0, #0
   152a8:	f008 f8b1 	bl	1d40e <ull_adv_is_enabled>
	if (!rl_access_check(false)) {
   152ac:	4606      	mov	r6, r0
   152ae:	2800      	cmp	r0, #0
   152b0:	d156      	bne.n	15360 <ll_rl_remove+0xc0>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   152b2:	46d8      	mov	r8, fp
   152b4:	4632      	mov	r2, r6
   152b6:	f818 0b01 	ldrb.w	r0, [r8], #1
   152ba:	4641      	mov	r1, r8
   152bc:	f7ff fec2 	bl	15044 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
   152c0:	2807      	cmp	r0, #7
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   152c2:	4682      	mov	sl, r0
	if (i < ARRAY_SIZE(rl)) {
   152c4:	d84e      	bhi.n	15364 <ll_rl_remove+0xc4>
		if (rl[i].pirk) {
   152c6:	2328      	movs	r3, #40	; 0x28
   152c8:	fb03 f200 	mul.w	r2, r3, r0
   152cc:	4c26      	ldr	r4, [pc, #152]	; (15368 <ll_rl_remove+0xc8>)
   152ce:	18a1      	adds	r1, r4, r2
   152d0:	5ca2      	ldrb	r2, [r4, r2]
   152d2:	0753      	lsls	r3, r2, #29
   152d4:	d527      	bpl.n	15326 <ll_rl_remove+0x86>
			u8_t pi = rl[i].pirk_idx, pj = peer_irk_count - 1;
   152d6:	4f25      	ldr	r7, [pc, #148]	; (1536c <ll_rl_remove+0xcc>)
   152d8:	783d      	ldrb	r5, [r7, #0]
   152da:	3d01      	subs	r5, #1
			if (pj && pi != pj) {
   152dc:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   152e0:	d01e      	beq.n	15320 <ll_rl_remove+0x80>
			u8_t pi = rl[i].pirk_idx, pj = peer_irk_count - 1;
   152e2:	f891 9017 	ldrb.w	r9, [r1, #23]
			if (pj && pi != pj) {
   152e6:	45a9      	cmp	r9, r5
   152e8:	d01a      	beq.n	15320 <ll_rl_remove+0x80>
				memcpy(peer_irks[pi], peer_irks[pj], IRK_SIZE);
   152ea:	4821      	ldr	r0, [pc, #132]	; (15370 <ll_rl_remove+0xd0>)
   152ec:	2210      	movs	r2, #16
   152ee:	eb00 1105 	add.w	r1, r0, r5, lsl #4
   152f2:	eb00 1009 	add.w	r0, r0, r9, lsl #4
   152f6:	f005 fe80 	bl	1affa <memcpy>
					if (rl[k].taken && rl[k].pirk &&
   152fa:	2328      	movs	r3, #40	; 0x28
   152fc:	fb03 f106 	mul.w	r1, r3, r6
   15300:	1862      	adds	r2, r4, r1
   15302:	5c61      	ldrb	r1, [r4, r1]
   15304:	f011 0f01 	tst.w	r1, #1
   15308:	b2f0      	uxtb	r0, r6
   1530a:	d025      	beq.n	15358 <ll_rl_remove+0xb8>
   1530c:	0749      	lsls	r1, r1, #29
   1530e:	d523      	bpl.n	15358 <ll_rl_remove+0xb8>
   15310:	7dd1      	ldrb	r1, [r2, #23]
   15312:	42a9      	cmp	r1, r5
   15314:	d120      	bne.n	15358 <ll_rl_remove+0xb8>
						peer_irk_rl_ids[pi] = k;
   15316:	4b17      	ldr	r3, [pc, #92]	; (15374 <ll_rl_remove+0xd4>)
						rl[k].pirk_idx = pi;
   15318:	f882 9017 	strb.w	r9, [r2, #23]
						peer_irk_rl_ids[pi] = k;
   1531c:	f803 0009 	strb.w	r0, [r3, r9]
			peer_irk_count--;
   15320:	783b      	ldrb	r3, [r7, #0]
   15322:	3b01      	subs	r3, #1
   15324:	703b      	strb	r3, [r7, #0]
		j = wl_find(id_addr->type, id_addr->a.val, NULL);
   15326:	2200      	movs	r2, #0
   15328:	4641      	mov	r1, r8
   1532a:	f89b 0000 	ldrb.w	r0, [fp]
   1532e:	f7ff fcc5 	bl	14cbc <wl_find>
		if (j < ARRAY_SIZE(wl)) {
   15332:	2807      	cmp	r0, #7
			wl[j].rl_idx = FILTER_IDX_NONE;
   15334:	bf9c      	itt	ls
   15336:	4b10      	ldrls	r3, [pc, #64]	; (15378 <ll_rl_remove+0xd8>)
   15338:	eb03 03c0 	addls.w	r3, r3, r0, lsl #3
		rl[i].taken = 0U;
   1533c:	f04f 0028 	mov.w	r0, #40	; 0x28
   15340:	fb00 f00a 	mul.w	r0, r0, sl
			wl[j].rl_idx = FILTER_IDX_NONE;
   15344:	bf9c      	itt	ls
   15346:	22ff      	movls	r2, #255	; 0xff
   15348:	705a      	strbls	r2, [r3, #1]
		rl[i].taken = 0U;
   1534a:	5c23      	ldrb	r3, [r4, r0]
   1534c:	f36f 0300 	bfc	r3, #0, #1
   15350:	5423      	strb	r3, [r4, r0]
		return 0;
   15352:	2000      	movs	r0, #0
}
   15354:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15358:	3601      	adds	r6, #1
				for (k = 0U;
   1535a:	2e08      	cmp	r6, #8
   1535c:	d1ce      	bne.n	152fc <ll_rl_remove+0x5c>
   1535e:	e7df      	b.n	15320 <ll_rl_remove+0x80>
		return BT_HCI_ERR_CMD_DISALLOWED;
   15360:	200c      	movs	r0, #12
   15362:	e7f7      	b.n	15354 <ll_rl_remove+0xb4>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
   15364:	2002      	movs	r0, #2
   15366:	e7f5      	b.n	15354 <ll_rl_remove+0xb4>
   15368:	200014ac 	.word	0x200014ac
   1536c:	20001cbd 	.word	0x20001cbd
   15370:	20001cc6 	.word	0x20001cc6
   15374:	20001cbe 	.word	0x20001cbe
   15378:	20001d79 	.word	0x20001d79

0001537c <ll_rl_crpa_set>:
{
   1537c:	b570      	push	{r4, r5, r6, lr}
	if ((crpa[5] & 0xc0) == 0x40) {
   1537e:	795c      	ldrb	r4, [r3, #5]
   15380:	f004 04c0 	and.w	r4, r4, #192	; 0xc0
   15384:	2c40      	cmp	r4, #64	; 0x40
{
   15386:	461d      	mov	r5, r3
	if ((crpa[5] & 0xc0) == 0x40) {
   15388:	d117      	bne.n	153ba <ll_rl_crpa_set+0x3e>
		if (id_addr) {
   1538a:	b119      	cbz	r1, 15394 <ll_rl_crpa_set+0x18>
			rl_idx = ull_filter_rl_find(id_addr_type, id_addr, NULL);
   1538c:	2200      	movs	r2, #0
   1538e:	f7ff fe59 	bl	15044 <ull_filter_rl_find>
   15392:	4602      	mov	r2, r0
		if (rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].taken) {
   15394:	2a07      	cmp	r2, #7
   15396:	d810      	bhi.n	153ba <ll_rl_crpa_set+0x3e>
   15398:	2128      	movs	r1, #40	; 0x28
   1539a:	4c08      	ldr	r4, [pc, #32]	; (153bc <ll_rl_crpa_set+0x40>)
   1539c:	fb01 f302 	mul.w	r3, r1, r2
   153a0:	5ce3      	ldrb	r3, [r4, r3]
   153a2:	07db      	lsls	r3, r3, #31
   153a4:	d509      	bpl.n	153ba <ll_rl_crpa_set+0x3e>
			memcpy(rl[rl_idx].curr_rpa.val, crpa,
   153a6:	2018      	movs	r0, #24
   153a8:	fb11 0002 	smlabb	r0, r1, r2, r0
   153ac:	4420      	add	r0, r4
   153ae:	4629      	mov	r1, r5
   153b0:	2206      	movs	r2, #6
}
   153b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			memcpy(rl[rl_idx].curr_rpa.val, crpa,
   153b6:	f005 be20 	b.w	1affa <memcpy>
}
   153ba:	bd70      	pop	{r4, r5, r6, pc}
   153bc:	200014ac 	.word	0x200014ac

000153c0 <ll_rl_crpa_get>:
{
   153c0:	b538      	push	{r3, r4, r5, lr}
   153c2:	460d      	mov	r5, r1
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   153c4:	4601      	mov	r1, r0
   153c6:	2200      	movs	r2, #0
   153c8:	f811 0b01 	ldrb.w	r0, [r1], #1
   153cc:	f7ff fe3a 	bl	15044 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl) &&
   153d0:	2807      	cmp	r0, #7
   153d2:	d901      	bls.n	153d8 <ll_rl_crpa_get+0x18>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
   153d4:	2002      	movs	r0, #2
}
   153d6:	bd38      	pop	{r3, r4, r5, pc}
	    mem_nz(rl[i].curr_rpa.val, sizeof(rl[i].curr_rpa.val))) {
   153d8:	2428      	movs	r4, #40	; 0x28
   153da:	2318      	movs	r3, #24
   153dc:	fb14 3000 	smlabb	r0, r4, r0, r3
   153e0:	4c07      	ldr	r4, [pc, #28]	; (15400 <ll_rl_crpa_get+0x40>)
   153e2:	4404      	add	r4, r0
   153e4:	2106      	movs	r1, #6
   153e6:	4620      	mov	r0, r4
   153e8:	f007 fd85 	bl	1cef6 <mem_nz>
	if (i < ARRAY_SIZE(rl) &&
   153ec:	2800      	cmp	r0, #0
   153ee:	d0f1      	beq.n	153d4 <ll_rl_crpa_get+0x14>
   153f0:	2206      	movs	r2, #6
   153f2:	4621      	mov	r1, r4
   153f4:	4628      	mov	r0, r5
   153f6:	f005 fe00 	bl	1affa <memcpy>
		return 0;
   153fa:	2000      	movs	r0, #0
   153fc:	e7eb      	b.n	153d6 <ll_rl_crpa_get+0x16>
   153fe:	bf00      	nop
   15400:	200014ac 	.word	0x200014ac

00015404 <ll_rl_lrpa_get>:
{
   15404:	b510      	push	{r4, lr}
   15406:	460c      	mov	r4, r1
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   15408:	4601      	mov	r1, r0
   1540a:	2200      	movs	r2, #0
   1540c:	f811 0b01 	ldrb.w	r0, [r1], #1
   15410:	f7ff fe18 	bl	15044 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
   15414:	2807      	cmp	r0, #7
   15416:	d80a      	bhi.n	1542e <ll_rl_lrpa_get+0x2a>
		bt_addr_copy(lrpa, rl[i].local_rpa);
   15418:	4b06      	ldr	r3, [pc, #24]	; (15434 <ll_rl_lrpa_get+0x30>)
   1541a:	2228      	movs	r2, #40	; 0x28
   1541c:	fb02 3000 	mla	r0, r2, r0, r3
   15420:	2206      	movs	r2, #6
   15422:	6a41      	ldr	r1, [r0, #36]	; 0x24
   15424:	4620      	mov	r0, r4
   15426:	f005 fde8 	bl	1affa <memcpy>
		return 0;
   1542a:	2000      	movs	r0, #0
}
   1542c:	bd10      	pop	{r4, pc}
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
   1542e:	2002      	movs	r0, #2
   15430:	e7fc      	b.n	1542c <ll_rl_lrpa_get+0x28>
   15432:	bf00      	nop
   15434:	200014ac 	.word	0x200014ac

00015438 <ll_priv_mode_set>:
{
   15438:	b570      	push	{r4, r5, r6, lr}
   1543a:	4605      	mov	r5, r0
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
   1543c:	2000      	movs	r0, #0
{
   1543e:	460c      	mov	r4, r1
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
   15440:	f007 ffe5 	bl	1d40e <ull_adv_is_enabled>
	if (!rl_access_check(false)) {
   15444:	4606      	mov	r6, r0
   15446:	b9f0      	cbnz	r0, 15486 <ll_priv_mode_set+0x4e>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   15448:	4629      	mov	r1, r5
   1544a:	4632      	mov	r2, r6
   1544c:	f811 0b01 	ldrb.w	r0, [r1], #1
   15450:	f7ff fdf8 	bl	15044 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
   15454:	2807      	cmp	r0, #7
   15456:	d818      	bhi.n	1548a <ll_priv_mode_set+0x52>
		switch (mode) {
   15458:	b124      	cbz	r4, 15464 <ll_priv_mode_set+0x2c>
   1545a:	2c01      	cmp	r4, #1
   1545c:	d00a      	beq.n	15474 <ll_priv_mode_set+0x3c>
			return BT_HCI_ERR_INVALID_PARAM;
   1545e:	2412      	movs	r4, #18
}
   15460:	4620      	mov	r0, r4
   15462:	bd70      	pop	{r4, r5, r6, pc}
			rl[i].dev = 0U;
   15464:	2328      	movs	r3, #40	; 0x28
   15466:	4a0a      	ldr	r2, [pc, #40]	; (15490 <ll_priv_mode_set+0x58>)
   15468:	4358      	muls	r0, r3
   1546a:	5c13      	ldrb	r3, [r2, r0]
   1546c:	f364 1304 	bfi	r3, r4, #4, #1
   15470:	5413      	strb	r3, [r2, r0]
			break;
   15472:	e7f5      	b.n	15460 <ll_priv_mode_set+0x28>
			rl[i].dev = 1U;
   15474:	2328      	movs	r3, #40	; 0x28
   15476:	4a06      	ldr	r2, [pc, #24]	; (15490 <ll_priv_mode_set+0x58>)
   15478:	4358      	muls	r0, r3
	return 0;
   1547a:	4634      	mov	r4, r6
			rl[i].dev = 1U;
   1547c:	5c13      	ldrb	r3, [r2, r0]
   1547e:	f043 0310 	orr.w	r3, r3, #16
   15482:	5413      	strb	r3, [r2, r0]
			break;
   15484:	e7ec      	b.n	15460 <ll_priv_mode_set+0x28>
		return BT_HCI_ERR_CMD_DISALLOWED;
   15486:	240c      	movs	r4, #12
   15488:	e7ea      	b.n	15460 <ll_priv_mode_set+0x28>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   1548a:	2402      	movs	r4, #2
   1548c:	e7e8      	b.n	15460 <ll_priv_mode_set+0x28>
   1548e:	bf00      	nop
   15490:	200014ac 	.word	0x200014ac

00015494 <ull_filter_rpa_update>:
{
   15494:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15498:	b087      	sub	sp, #28
   1549a:	9000      	str	r0, [sp, #0]
	return z_impl_k_uptime_get();
   1549c:	f009 f9b5 	bl	1e80a <z_impl_k_uptime_get>
	bool all = timeout || (rpa_last_ms == -1) ||
   154a0:	9b00      	ldr	r3, [sp, #0]
   154a2:	4680      	mov	r8, r0
   154a4:	468a      	mov	sl, r1
   154a6:	2b00      	cmp	r3, #0
   154a8:	f040 80d5 	bne.w	15656 <ull_filter_rpa_update+0x1c2>
   154ac:	4b6b      	ldr	r3, [pc, #428]	; (1565c <ull_filter_rpa_update+0x1c8>)
   154ae:	e9d3 2300 	ldrd	r2, r3, [r3]
   154b2:	1c59      	adds	r1, r3, #1
   154b4:	bf08      	it	eq
   154b6:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
   154ba:	f000 80cc 	beq.w	15656 <ull_filter_rpa_update+0x1c2>
		   (now - rpa_last_ms >= rpa_timeout_ms);
   154be:	ebb8 0402 	subs.w	r4, r8, r2
   154c2:	eb6a 0503 	sbc.w	r5, sl, r3
   154c6:	4b66      	ldr	r3, [pc, #408]	; (15660 <ull_filter_rpa_update+0x1cc>)
   154c8:	681a      	ldr	r2, [r3, #0]
   154ca:	2300      	movs	r3, #0
	bool all = timeout || (rpa_last_ms == -1) ||
   154cc:	4294      	cmp	r4, r2
   154ce:	eb75 0303 	sbcs.w	r3, r5, r3
   154d2:	bfac      	ite	ge
   154d4:	2701      	movge	r7, #1
   154d6:	2700      	movlt	r7, #0
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
   154d8:	4d62      	ldr	r5, [pc, #392]	; (15664 <ull_filter_rpa_update+0x1d0>)
				LL_ASSERT(!err);
   154da:	f8df 9198 	ldr.w	r9, [pc, #408]	; 15674 <ull_filter_rpa_update+0x1e0>
   154de:	f8df b198 	ldr.w	fp, [pc, #408]	; 15678 <ull_filter_rpa_update+0x1e4>
	bool all = timeout || (rpa_last_ms == -1) ||
   154e2:	2400      	movs	r4, #0
   154e4:	462e      	mov	r6, r5
		if ((rl[i].taken) && (all || !rl[i].rpas_ready)) {
   154e6:	2328      	movs	r3, #40	; 0x28
   154e8:	4363      	muls	r3, r4
   154ea:	5cf3      	ldrb	r3, [r6, r3]
   154ec:	07da      	lsls	r2, r3, #31
   154ee:	d551      	bpl.n	15594 <ull_filter_rpa_update+0x100>
   154f0:	b90f      	cbnz	r7, 154f6 <ull_filter_rpa_update+0x62>
   154f2:	0798      	lsls	r0, r3, #30
   154f4:	d44e      	bmi.n	15594 <ull_filter_rpa_update+0x100>
			if (rl[i].pirk) {
   154f6:	2328      	movs	r3, #40	; 0x28
   154f8:	4363      	muls	r3, r4
   154fa:	5cf3      	ldrb	r3, [r6, r3]
   154fc:	0759      	lsls	r1, r3, #29
   154fe:	d51f      	bpl.n	15540 <ull_filter_rpa_update+0xac>
				sys_memcpy_swap(irk, peer_irks[rl[i].pirk_idx],
   15500:	7dea      	ldrb	r2, [r5, #23]
   15502:	4b59      	ldr	r3, [pc, #356]	; (15668 <ull_filter_rpa_update+0x1d4>)
   15504:	a902      	add	r1, sp, #8
   15506:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   1550a:	f103 0210 	add.w	r2, r3, #16
   1550e:	4608      	mov	r0, r1
		*pdst++ = *psrc--;
   15510:	f812 cd01 	ldrb.w	ip, [r2, #-1]!
   15514:	f801 cb01 	strb.w	ip, [r1], #1
	for (; length > 0; length--) {
   15518:	429a      	cmp	r2, r3
   1551a:	d1f9      	bne.n	15510 <ull_filter_rpa_update+0x7c>
				err = bt_rpa_create(irk, &rl[i].peer_rpa);
   1551c:	f105 011e 	add.w	r1, r5, #30
   15520:	f005 fde9 	bl	1b0f6 <bt_rpa_create>
				LL_ASSERT(!err);
   15524:	b160      	cbz	r0, 15540 <ull_filter_rpa_update+0xac>
   15526:	f240 232a 	movw	r3, #554	; 0x22a
   1552a:	464a      	mov	r2, r9
   1552c:	4659      	mov	r1, fp
   1552e:	484f      	ldr	r0, [pc, #316]	; (1566c <ull_filter_rpa_update+0x1d8>)
   15530:	f003 ff20 	bl	19374 <printk>
   15534:	4040      	eors	r0, r0
   15536:	f380 8811 	msr	BASEPRI, r0
   1553a:	f04f 0003 	mov.w	r0, #3
   1553e:	df02      	svc	2
			if (rl[i].lirk) {
   15540:	2328      	movs	r3, #40	; 0x28
   15542:	4363      	muls	r3, r4
   15544:	5cf3      	ldrb	r3, [r6, r3]
   15546:	071a      	lsls	r2, r3, #28
   15548:	d51e      	bpl.n	15588 <ull_filter_rpa_update+0xf4>
				err = bt_rpa_create(rl[i].local_irk, &rpa);
   1554a:	a902      	add	r1, sp, #8
   1554c:	1de8      	adds	r0, r5, #7
   1554e:	f005 fdd2 	bl	1b0f6 <bt_rpa_create>
				LL_ASSERT(!err);
   15552:	b160      	cbz	r0, 1556e <ull_filter_rpa_update+0xda>
   15554:	f240 2337 	movw	r3, #567	; 0x237
   15558:	464a      	mov	r2, r9
   1555a:	4659      	mov	r1, fp
   1555c:	4843      	ldr	r0, [pc, #268]	; (1566c <ull_filter_rpa_update+0x1d8>)
   1555e:	f003 ff09 	bl	19374 <printk>
   15562:	4040      	eors	r0, r0
   15564:	f380 8811 	msr	BASEPRI, r0
   15568:	f04f 0003 	mov.w	r0, #3
   1556c:	df02      	svc	2
				rl[i].local_rpa = &rpa;
   1556e:	ab02      	add	r3, sp, #8
   15570:	626b      	str	r3, [r5, #36]	; 0x24
				bt_addr_copy(&local_rpas[i], &rpa);
   15572:	4b3f      	ldr	r3, [pc, #252]	; (15670 <ull_filter_rpa_update+0x1dc>)
   15574:	2206      	movs	r2, #6
   15576:	fb02 3304 	mla	r3, r2, r4, r3
   1557a:	4618      	mov	r0, r3
   1557c:	a902      	add	r1, sp, #8
   1557e:	9301      	str	r3, [sp, #4]
   15580:	f005 fd3b 	bl	1affa <memcpy>
				rl[i].local_rpa = &local_rpas[i];
   15584:	9b01      	ldr	r3, [sp, #4]
   15586:	626b      	str	r3, [r5, #36]	; 0x24
			rl[i].rpas_ready = 1U;
   15588:	2328      	movs	r3, #40	; 0x28
   1558a:	4363      	muls	r3, r4
   1558c:	5cf2      	ldrb	r2, [r6, r3]
   1558e:	f042 0202 	orr.w	r2, r2, #2
   15592:	54f2      	strb	r2, [r6, r3]
   15594:	3401      	adds	r4, #1
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
   15596:	2c08      	cmp	r4, #8
   15598:	f105 0528 	add.w	r5, r5, #40	; 0x28
   1559c:	d1a3      	bne.n	154e6 <ull_filter_rpa_update+0x52>
	if (all) {
   1559e:	b117      	cbz	r7, 155a6 <ull_filter_rpa_update+0x112>
		rpa_last_ms = now;
   155a0:	4b2e      	ldr	r3, [pc, #184]	; (1565c <ull_filter_rpa_update+0x1c8>)
   155a2:	e9c3 8a00 	strd	r8, sl, [r3]
	if (timeout) {
   155a6:	9b00      	ldr	r3, [sp, #0]
   155a8:	2b00      	cmp	r3, #0
   155aa:	d051      	beq.n	15650 <ull_filter_rpa_update+0x1bc>
		adv = ull_adv_is_enabled_get(0);
   155ac:	2000      	movs	r0, #0
   155ae:	f7fb ffc5 	bl	1153c <ull_adv_is_enabled_get>
		if (adv) {
   155b2:	4605      	mov	r5, r0
   155b4:	2800      	cmp	r0, #0
   155b6:	d04b      	beq.n	15650 <ull_filter_rpa_update+0x1bc>
	if (adv->own_addr_type != BT_ADDR_LE_PUBLIC_ID &&
   155b8:	f890 00da 	ldrb.w	r0, [r0, #218]	; 0xda
   155bc:	0783      	lsls	r3, r0, #30
   155be:	d547      	bpl.n	15650 <ull_filter_rpa_update+0x1bc>
	rl_idx = ull_filter_rl_find(adv->id_addr_type, adv->id_addr, NULL);
   155c0:	f105 01dc 	add.w	r1, r5, #220	; 0xdc
   155c4:	2200      	movs	r2, #0
   155c6:	f3c0 0080 	ubfx	r0, r0, #2, #1
   155ca:	f7ff fd3b 	bl	15044 <ull_filter_rl_find>
	if (rl_idx >= ARRAY_SIZE(rl)) {
   155ce:	2807      	cmp	r0, #7
	rl_idx = ull_filter_rl_find(adv->id_addr_type, adv->id_addr, NULL);
   155d0:	4601      	mov	r1, r0
	if (rl_idx >= ARRAY_SIZE(rl)) {
   155d2:	d83d      	bhi.n	15650 <ull_filter_rpa_update+0x1bc>
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   155d4:	f895 402c 	ldrb.w	r4, [r5, #44]	; 0x2c
   155d8:	2311      	movs	r3, #17
   155da:	2627      	movs	r6, #39	; 0x27
   155dc:	fb16 3604 	smlabb	r6, r6, r4, r3
	if (pdu->first == pdu->last) {
   155e0:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   155e4:	f105 0c1c 	add.w	ip, r5, #28
	if (pdu->first == pdu->last) {
   155e8:	42a3      	cmp	r3, r4
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   155ea:	eb0c 0906 	add.w	r9, ip, r6
	if (pdu->first == pdu->last) {
   155ee:	d104      	bne.n	155fa <ull_filter_rpa_update+0x166>
		last = pdu->last + 1;
   155f0:	3401      	adds	r4, #1
   155f2:	b2e4      	uxtb	r4, r4
			last = 0U;
   155f4:	2c02      	cmp	r4, #2
   155f6:	bf08      	it	eq
   155f8:	2400      	moveq	r4, #0
	return (void *)pdu->pdu[last];
   155fa:	2027      	movs	r0, #39	; 0x27
   155fc:	2302      	movs	r3, #2
   155fe:	fb10 3304 	smlabb	r3, r0, r4, r3
   15602:	f105 022b 	add.w	r2, r5, #43	; 0x2b
	pdu->type = prev->type;
   15606:	f81c 0006 	ldrb.w	r0, [ip, r6]
   1560a:	5cd7      	ldrb	r7, [r2, r3]
   1560c:	f360 0703 	bfi	r7, r0, #0, #4
	pdu->rfu = 0;
   15610:	f36f 1704 	bfc	r7, #4, #1
   15614:	54d7      	strb	r7, [r2, r3]
		pdu->chan_sel = prev->chan_sel;
   15616:	f81c 6006 	ldrb.w	r6, [ip, r6]
   1561a:	b2f8      	uxtb	r0, r7
   1561c:	f3c6 1640 	ubfx	r6, r6, #5, #1
   15620:	eb02 0803 	add.w	r8, r2, r3
   15624:	f366 1045 	bfi	r0, r6, #5, #1
   15628:	54d0      	strb	r0, [r2, r3]
	ull_filter_adv_pdu_update(adv, rl_idx, pdu);
   1562a:	4642      	mov	r2, r8
   1562c:	4628      	mov	r0, r5
   1562e:	f7ff fc9f 	bl	14f70 <ull_filter_adv_pdu_update>
	       prev->len - BDADDR_SIZE);
   15632:	f899 2001 	ldrb.w	r2, [r9, #1]
	memcpy(&pdu->adv_ind.data[0], &prev->adv_ind.data[0],
   15636:	f109 0108 	add.w	r1, r9, #8
   1563a:	3a06      	subs	r2, #6
   1563c:	f108 0008 	add.w	r0, r8, #8
   15640:	f005 fcdb 	bl	1affa <memcpy>
	pdu->len = prev->len;
   15644:	f899 3001 	ldrb.w	r3, [r9, #1]
   15648:	f888 3001 	strb.w	r3, [r8, #1]
	pdu->last = idx;
   1564c:	f885 402c 	strb.w	r4, [r5, #44]	; 0x2c
}
   15650:	b007      	add	sp, #28
   15652:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	bool all = timeout || (rpa_last_ms == -1) ||
   15656:	2701      	movs	r7, #1
   15658:	e73e      	b.n	154d8 <ull_filter_rpa_update+0x44>
   1565a:	bf00      	nop
   1565c:	20000008 	.word	0x20000008
   15660:	200015ec 	.word	0x200015ec
   15664:	200014ac 	.word	0x200014ac
   15668:	20001cc6 	.word	0x20001cc6
   1566c:	00020aa4 	.word	0x00020aa4
   15670:	20001c8d 	.word	0x20001c8d
   15674:	0002221e 	.word	0x0002221e
   15678:	00021bdb 	.word	0x00021bdb

0001567c <rpa_timeout>:
{
   1567c:	b508      	push	{r3, lr}
	ull_filter_rpa_update(true);
   1567e:	2001      	movs	r0, #1
   15680:	f7ff ff08 	bl	15494 <ull_filter_rpa_update>
   15684:	4b03      	ldr	r3, [pc, #12]	; (15694 <rpa_timeout+0x18>)
   15686:	4904      	ldr	r1, [pc, #16]	; (15698 <rpa_timeout+0x1c>)
   15688:	681a      	ldr	r2, [r3, #0]
   1568a:	4804      	ldr	r0, [pc, #16]	; (1569c <rpa_timeout+0x20>)
}
   1568c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   15690:	f003 b86a 	b.w	18768 <k_delayed_work_submit_to_queue>
   15694:	200015ec 	.word	0x200015ec
   15698:	200015f0 	.word	0x200015f0
   1569c:	20001a60 	.word	0x20001a60

000156a0 <ull_filter_reset>:
	wl_anon = 0U;
   156a0:	4a39      	ldr	r2, [pc, #228]	; (15788 <ull_filter_reset+0xe8>)
   156a2:	2300      	movs	r3, #0
{
   156a4:	b430      	push	{r4, r5}
	wl_anon = 0U;
   156a6:	7013      	strb	r3, [r2, #0]
		wl[i].taken = 0U;
   156a8:	4a38      	ldr	r2, [pc, #224]	; (1578c <ull_filter_reset+0xec>)
   156aa:	7811      	ldrb	r1, [r2, #0]
   156ac:	f363 0100 	bfi	r1, r3, #0, #1
   156b0:	7011      	strb	r1, [r2, #0]
   156b2:	7a11      	ldrb	r1, [r2, #8]
   156b4:	f363 0100 	bfi	r1, r3, #0, #1
   156b8:	7211      	strb	r1, [r2, #8]
   156ba:	7c11      	ldrb	r1, [r2, #16]
   156bc:	f363 0100 	bfi	r1, r3, #0, #1
   156c0:	7411      	strb	r1, [r2, #16]
   156c2:	7e11      	ldrb	r1, [r2, #24]
   156c4:	f363 0100 	bfi	r1, r3, #0, #1
   156c8:	7611      	strb	r1, [r2, #24]
   156ca:	f892 1020 	ldrb.w	r1, [r2, #32]
   156ce:	f363 0100 	bfi	r1, r3, #0, #1
   156d2:	f882 1020 	strb.w	r1, [r2, #32]
   156d6:	f892 1028 	ldrb.w	r1, [r2, #40]	; 0x28
   156da:	f363 0100 	bfi	r1, r3, #0, #1
   156de:	f882 1028 	strb.w	r1, [r2, #40]	; 0x28
   156e2:	f892 1030 	ldrb.w	r1, [r2, #48]	; 0x30
   156e6:	f363 0100 	bfi	r1, r3, #0, #1
   156ea:	f882 1030 	strb.w	r1, [r2, #48]	; 0x30
   156ee:	f892 1038 	ldrb.w	r1, [r2, #56]	; 0x38
   156f2:	f363 0100 	bfi	r1, r3, #0, #1
   156f6:	f882 1038 	strb.w	r1, [r2, #56]	; 0x38
	rl_enable = 0U;
   156fa:	4a25      	ldr	r2, [pc, #148]	; (15790 <ull_filter_reset+0xf0>)
	rpa_timeout_ms = DEFAULT_RPA_TIMEOUT_MS;
   156fc:	4925      	ldr	r1, [pc, #148]	; (15794 <ull_filter_reset+0xf4>)
	rl_enable = 0U;
   156fe:	7013      	strb	r3, [r2, #0]
	rpa_timeout_ms = DEFAULT_RPA_TIMEOUT_MS;
   15700:	4a25      	ldr	r2, [pc, #148]	; (15798 <ull_filter_reset+0xf8>)
   15702:	6011      	str	r1, [r2, #0]
	rpa_last_ms = -1;
   15704:	4a25      	ldr	r2, [pc, #148]	; (1579c <ull_filter_reset+0xfc>)
   15706:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1570a:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   1570e:	e9c2 4500 	strd	r4, r5, [r2]
		rl[i].taken = 0U;
   15712:	4a23      	ldr	r2, [pc, #140]	; (157a0 <ull_filter_reset+0x100>)
   15714:	7811      	ldrb	r1, [r2, #0]
   15716:	f363 0100 	bfi	r1, r3, #0, #1
   1571a:	7011      	strb	r1, [r2, #0]
   1571c:	f892 1028 	ldrb.w	r1, [r2, #40]	; 0x28
   15720:	f363 0100 	bfi	r1, r3, #0, #1
   15724:	f882 1028 	strb.w	r1, [r2, #40]	; 0x28
   15728:	f892 1050 	ldrb.w	r1, [r2, #80]	; 0x50
   1572c:	f363 0100 	bfi	r1, r3, #0, #1
   15730:	f882 1050 	strb.w	r1, [r2, #80]	; 0x50
   15734:	f892 1078 	ldrb.w	r1, [r2, #120]	; 0x78
   15738:	f363 0100 	bfi	r1, r3, #0, #1
   1573c:	f882 1078 	strb.w	r1, [r2, #120]	; 0x78
   15740:	f892 10a0 	ldrb.w	r1, [r2, #160]	; 0xa0
   15744:	f363 0100 	bfi	r1, r3, #0, #1
   15748:	f882 10a0 	strb.w	r1, [r2, #160]	; 0xa0
   1574c:	f892 10c8 	ldrb.w	r1, [r2, #200]	; 0xc8
   15750:	f363 0100 	bfi	r1, r3, #0, #1
   15754:	f882 10c8 	strb.w	r1, [r2, #200]	; 0xc8
   15758:	f892 10f0 	ldrb.w	r1, [r2, #240]	; 0xf0
   1575c:	f363 0100 	bfi	r1, r3, #0, #1
   15760:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
   15764:	f892 1118 	ldrb.w	r1, [r2, #280]	; 0x118
   15768:	f363 0100 	bfi	r1, r3, #0, #1
   1576c:	f882 1118 	strb.w	r1, [r2, #280]	; 0x118
	peer_irk_count = 0U;
   15770:	4a0c      	ldr	r2, [pc, #48]	; (157a4 <ull_filter_reset+0x104>)
   15772:	7013      	strb	r3, [r2, #0]
	if (init) {
   15774:	b120      	cbz	r0, 15780 <ull_filter_reset+0xe0>
		k_delayed_work_init(&rpa_work, rpa_timeout);
   15776:	490c      	ldr	r1, [pc, #48]	; (157a8 <ull_filter_reset+0x108>)
   15778:	480c      	ldr	r0, [pc, #48]	; (157ac <ull_filter_reset+0x10c>)
}
   1577a:	bc30      	pop	{r4, r5}
		k_delayed_work_init(&rpa_work, rpa_timeout);
   1577c:	f008 bfe4 	b.w	1e748 <k_delayed_work_init>
		k_delayed_work_cancel(&rpa_work);
   15780:	480a      	ldr	r0, [pc, #40]	; (157ac <ull_filter_reset+0x10c>)
}
   15782:	bc30      	pop	{r4, r5}
		k_delayed_work_cancel(&rpa_work);
   15784:	f008 bfe8 	b.w	1e758 <k_delayed_work_cancel>
   15788:	20001db9 	.word	0x20001db9
   1578c:	20001d79 	.word	0x20001d79
   15790:	20001d46 	.word	0x20001d46
   15794:	000dbba0 	.word	0x000dbba0
   15798:	200015ec 	.word	0x200015ec
   1579c:	20000008 	.word	0x20000008
   157a0:	200014ac 	.word	0x200014ac
   157a4:	20001cbd 	.word	0x20001cbd
   157a8:	0001567d 	.word	0x0001567d
   157ac:	200015f0 	.word	0x200015f0

000157b0 <ull_filter_lll_irks_get>:
	*count = peer_irk_count;
   157b0:	4b02      	ldr	r3, [pc, #8]	; (157bc <ull_filter_lll_irks_get+0xc>)
   157b2:	781b      	ldrb	r3, [r3, #0]
   157b4:	7003      	strb	r3, [r0, #0]
}
   157b6:	4802      	ldr	r0, [pc, #8]	; (157c0 <ull_filter_lll_irks_get+0x10>)
   157b8:	4770      	bx	lr
   157ba:	bf00      	nop
   157bc:	20001cbd 	.word	0x20001cbd
   157c0:	20001cc6 	.word	0x20001cc6

000157c4 <ull_filter_lll_rl_irk_idx>:
{
   157c4:	b510      	push	{r4, lr}
	LL_ASSERT(irkmatch_id < peer_irk_count);
   157c6:	4b1c      	ldr	r3, [pc, #112]	; (15838 <ull_filter_lll_rl_irk_idx+0x74>)
   157c8:	781b      	ldrb	r3, [r3, #0]
   157ca:	4283      	cmp	r3, r0
{
   157cc:	4604      	mov	r4, r0
	LL_ASSERT(irkmatch_id < peer_irk_count);
   157ce:	d80c      	bhi.n	157ea <ull_filter_lll_rl_irk_idx+0x26>
   157d0:	f240 23cd 	movw	r3, #717	; 0x2cd
   157d4:	4a19      	ldr	r2, [pc, #100]	; (1583c <ull_filter_lll_rl_irk_idx+0x78>)
   157d6:	491a      	ldr	r1, [pc, #104]	; (15840 <ull_filter_lll_rl_irk_idx+0x7c>)
   157d8:	481a      	ldr	r0, [pc, #104]	; (15844 <ull_filter_lll_rl_irk_idx+0x80>)
   157da:	f003 fdcb 	bl	19374 <printk>
   157de:	4040      	eors	r0, r0
   157e0:	f380 8811 	msr	BASEPRI, r0
   157e4:	f04f 0003 	mov.w	r0, #3
   157e8:	df02      	svc	2
	i = peer_irk_rl_ids[irkmatch_id];
   157ea:	4b17      	ldr	r3, [pc, #92]	; (15848 <ull_filter_lll_rl_irk_idx+0x84>)
   157ec:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(i < CONFIG_BT_CTLR_RL_SIZE);
   157ee:	2c07      	cmp	r4, #7
   157f0:	d90c      	bls.n	1580c <ull_filter_lll_rl_irk_idx+0x48>
   157f2:	f240 23cf 	movw	r3, #719	; 0x2cf
   157f6:	4a11      	ldr	r2, [pc, #68]	; (1583c <ull_filter_lll_rl_irk_idx+0x78>)
   157f8:	4914      	ldr	r1, [pc, #80]	; (1584c <ull_filter_lll_rl_irk_idx+0x88>)
   157fa:	4812      	ldr	r0, [pc, #72]	; (15844 <ull_filter_lll_rl_irk_idx+0x80>)
   157fc:	f003 fdba 	bl	19374 <printk>
   15800:	4040      	eors	r0, r0
   15802:	f380 8811 	msr	BASEPRI, r0
   15806:	f04f 0003 	mov.w	r0, #3
   1580a:	df02      	svc	2
	LL_ASSERT(rl[i].taken);
   1580c:	2328      	movs	r3, #40	; 0x28
   1580e:	4363      	muls	r3, r4
   15810:	4a0f      	ldr	r2, [pc, #60]	; (15850 <ull_filter_lll_rl_irk_idx+0x8c>)
   15812:	5cd3      	ldrb	r3, [r2, r3]
   15814:	07db      	lsls	r3, r3, #31
   15816:	d40c      	bmi.n	15832 <ull_filter_lll_rl_irk_idx+0x6e>
   15818:	f44f 7334 	mov.w	r3, #720	; 0x2d0
   1581c:	4a07      	ldr	r2, [pc, #28]	; (1583c <ull_filter_lll_rl_irk_idx+0x78>)
   1581e:	490d      	ldr	r1, [pc, #52]	; (15854 <ull_filter_lll_rl_irk_idx+0x90>)
   15820:	4808      	ldr	r0, [pc, #32]	; (15844 <ull_filter_lll_rl_irk_idx+0x80>)
   15822:	f003 fda7 	bl	19374 <printk>
   15826:	4040      	eors	r0, r0
   15828:	f380 8811 	msr	BASEPRI, r0
   1582c:	f04f 0003 	mov.w	r0, #3
   15830:	df02      	svc	2
}
   15832:	4620      	mov	r0, r4
   15834:	bd10      	pop	{r4, pc}
   15836:	bf00      	nop
   15838:	20001cbd 	.word	0x20001cbd
   1583c:	0002221e 	.word	0x0002221e
   15840:	00022403 	.word	0x00022403
   15844:	00020aa4 	.word	0x00020aa4
   15848:	20001cbe 	.word	0x20001cbe
   1584c:	00022420 	.word	0x00022420
   15850:	200014ac 	.word	0x200014ac
   15854:	000223f7 	.word	0x000223f7

00015858 <ull_filter_lll_irk_whitelisted>:
	if (rl_idx >= ARRAY_SIZE(rl)) {
   15858:	2807      	cmp	r0, #7
{
   1585a:	b538      	push	{r3, r4, r5, lr}
   1585c:	4605      	mov	r5, r0
	if (rl_idx >= ARRAY_SIZE(rl)) {
   1585e:	d818      	bhi.n	15892 <ull_filter_lll_irk_whitelisted+0x3a>
	LL_ASSERT(rl[rl_idx].taken);
   15860:	2228      	movs	r2, #40	; 0x28
   15862:	4c0d      	ldr	r4, [pc, #52]	; (15898 <ull_filter_lll_irk_whitelisted+0x40>)
   15864:	4342      	muls	r2, r0
   15866:	5ca2      	ldrb	r2, [r4, r2]
   15868:	07d3      	lsls	r3, r2, #31
   1586a:	d40c      	bmi.n	15886 <ull_filter_lll_irk_whitelisted+0x2e>
   1586c:	f240 23db 	movw	r3, #731	; 0x2db
   15870:	4a0a      	ldr	r2, [pc, #40]	; (1589c <ull_filter_lll_irk_whitelisted+0x44>)
   15872:	490b      	ldr	r1, [pc, #44]	; (158a0 <ull_filter_lll_irk_whitelisted+0x48>)
   15874:	480b      	ldr	r0, [pc, #44]	; (158a4 <ull_filter_lll_irk_whitelisted+0x4c>)
   15876:	f003 fd7d 	bl	19374 <printk>
   1587a:	4040      	eors	r0, r0
   1587c:	f380 8811 	msr	BASEPRI, r0
   15880:	f04f 0003 	mov.w	r0, #3
   15884:	df02      	svc	2
	return rl[rl_idx].wl;
   15886:	2028      	movs	r0, #40	; 0x28
   15888:	4368      	muls	r0, r5
   1588a:	5c20      	ldrb	r0, [r4, r0]
   1588c:	f3c0 1040 	ubfx	r0, r0, #5, #1
}
   15890:	bd38      	pop	{r3, r4, r5, pc}
		return false;
   15892:	2000      	movs	r0, #0
   15894:	e7fc      	b.n	15890 <ull_filter_lll_irk_whitelisted+0x38>
   15896:	bf00      	nop
   15898:	200014ac 	.word	0x200014ac
   1589c:	0002221e 	.word	0x0002221e
   158a0:	00022264 	.word	0x00022264
   158a4:	00020aa4 	.word	0x00020aa4

000158a8 <ull_filter_lll_get>:
}
   158a8:	4a03      	ldr	r2, [pc, #12]	; (158b8 <ull_filter_lll_get+0x10>)
   158aa:	4b04      	ldr	r3, [pc, #16]	; (158bc <ull_filter_lll_get+0x14>)
   158ac:	2800      	cmp	r0, #0
   158ae:	bf0c      	ite	eq
   158b0:	4610      	moveq	r0, r2
   158b2:	4618      	movne	r0, r3
   158b4:	4770      	bx	lr
   158b6:	bf00      	nop
   158b8:	20001d47 	.word	0x20001d47
   158bc:	20001dba 	.word	0x20001dba

000158c0 <ull_filter_lll_rl_addr_allowed>:
{
   158c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!rl_enable || *rl_idx != FILTER_IDX_NONE) {
   158c4:	4b1a      	ldr	r3, [pc, #104]	; (15930 <ull_filter_lll_rl_addr_allowed+0x70>)
   158c6:	781b      	ldrb	r3, [r3, #0]
   158c8:	b383      	cbz	r3, 1592c <ull_filter_lll_rl_addr_allowed+0x6c>
   158ca:	7813      	ldrb	r3, [r2, #0]
   158cc:	2bff      	cmp	r3, #255	; 0xff
   158ce:	d12d      	bne.n	1592c <ull_filter_lll_rl_addr_allowed+0x6c>
		if (rl[i].taken && (rl[i].id_addr_type == id_addr_type)) {
   158d0:	4e18      	ldr	r6, [pc, #96]	; (15934 <ull_filter_lll_rl_addr_allowed+0x74>)
   158d2:	2300      	movs	r3, #0
   158d4:	f04f 0828 	mov.w	r8, #40	; 0x28
   158d8:	46b4      	mov	ip, r6
   158da:	f106 0906 	add.w	r9, r6, #6
   158de:	fb08 f403 	mul.w	r4, r8, r3
   158e2:	fa5f fe83 	uxtb.w	lr, r3
   158e6:	5d37      	ldrb	r7, [r6, r4]
   158e8:	f017 0f01 	tst.w	r7, #1
   158ec:	eb06 0504 	add.w	r5, r6, r4
   158f0:	d019      	beq.n	15926 <ull_filter_lll_rl_addr_allowed+0x66>
   158f2:	f3c7 1780 	ubfx	r7, r7, #6, #1
   158f6:	4287      	cmp	r7, r0
   158f8:	d115      	bne.n	15926 <ull_filter_lll_rl_addr_allowed+0x66>
			for (j = 0U; j < BDADDR_SIZE; j++) {
   158fa:	1e4f      	subs	r7, r1, #1
   158fc:	444c      	add	r4, r9
				if (addr[j] != id_addr[j]) {
   158fe:	f815 bf01 	ldrb.w	fp, [r5, #1]!
   15902:	f817 af01 	ldrb.w	sl, [r7, #1]!
   15906:	45d3      	cmp	fp, sl
   15908:	d10d      	bne.n	15926 <ull_filter_lll_rl_addr_allowed+0x66>
			for (j = 0U; j < BDADDR_SIZE; j++) {
   1590a:	42a5      	cmp	r5, r4
   1590c:	d1f7      	bne.n	158fe <ull_filter_lll_rl_addr_allowed+0x3e>
				*rl_idx = i;
   1590e:	f882 e000 	strb.w	lr, [r2]
				return !rl[i].pirk || rl[i].dev;
   15912:	2228      	movs	r2, #40	; 0x28
   15914:	4353      	muls	r3, r2
   15916:	f81c 0003 	ldrb.w	r0, [ip, r3]
   1591a:	0743      	lsls	r3, r0, #29
   1591c:	d506      	bpl.n	1592c <ull_filter_lll_rl_addr_allowed+0x6c>
   1591e:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
   15922:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15926:	3301      	adds	r3, #1
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
   15928:	2b08      	cmp	r3, #8
   1592a:	d1d8      	bne.n	158de <ull_filter_lll_rl_addr_allowed+0x1e>
				return !rl[i].pirk || rl[i].dev;
   1592c:	2001      	movs	r0, #1
   1592e:	e7f8      	b.n	15922 <ull_filter_lll_rl_addr_allowed+0x62>
   15930:	20001d46 	.word	0x20001d46
   15934:	200014ac 	.word	0x200014ac

00015938 <ull_filter_lll_rl_enabled>:
	return rl_enable;
   15938:	4b02      	ldr	r3, [pc, #8]	; (15944 <ull_filter_lll_rl_enabled+0xc>)
   1593a:	7818      	ldrb	r0, [r3, #0]
}
   1593c:	3000      	adds	r0, #0
   1593e:	bf18      	it	ne
   15940:	2001      	movne	r0, #1
   15942:	4770      	bx	lr
   15944:	20001d46 	.word	0x20001d46

00015948 <cntr_init>:

static u8_t _refcount;

void cntr_init(void)
{
	NRF_RTC->PRESCALER = 0;
   15948:	4b05      	ldr	r3, [pc, #20]	; (15960 <cntr_init+0x18>)
   1594a:	2200      	movs	r2, #0
   1594c:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
   15950:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   15954:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
    p_reg->INTENSET = mask;
   15958:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	nrf_rtc_event_enable(NRF_RTC, RTC_EVTENSET_COMPARE0_Msk);
	nrf_rtc_int_enable(NRF_RTC, RTC_INTENSET_COMPARE0_Msk);
}
   1595c:	4770      	bx	lr
   1595e:	bf00      	nop
   15960:	4000b000 	.word	0x4000b000

00015964 <cntr_start>:

u32_t cntr_start(void)
{
	if (_refcount++) {
   15964:	4a04      	ldr	r2, [pc, #16]	; (15978 <cntr_start+0x14>)
   15966:	7813      	ldrb	r3, [r2, #0]
   15968:	1c59      	adds	r1, r3, #1
   1596a:	7011      	strb	r1, [r2, #0]
   1596c:	2001      	movs	r0, #1
   1596e:	b913      	cbnz	r3, 15976 <cntr_start+0x12>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   15970:	4a02      	ldr	r2, [pc, #8]	; (1597c <cntr_start+0x18>)
   15972:	6010      	str	r0, [r2, #0]
		return 1;
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_START);

	return 0;
   15974:	4618      	mov	r0, r3
}
   15976:	4770      	bx	lr
   15978:	20001dec 	.word	0x20001dec
   1597c:	4000b000 	.word	0x4000b000

00015980 <cntr_stop>:

u32_t cntr_stop(void)
{
   15980:	b510      	push	{r4, lr}
	LL_ASSERT(_refcount);
   15982:	4c0d      	ldr	r4, [pc, #52]	; (159b8 <cntr_stop+0x38>)
   15984:	7823      	ldrb	r3, [r4, #0]
   15986:	b95b      	cbnz	r3, 159a0 <cntr_stop+0x20>
   15988:	232e      	movs	r3, #46	; 0x2e
   1598a:	4a0c      	ldr	r2, [pc, #48]	; (159bc <cntr_stop+0x3c>)
   1598c:	490c      	ldr	r1, [pc, #48]	; (159c0 <cntr_stop+0x40>)
   1598e:	480d      	ldr	r0, [pc, #52]	; (159c4 <cntr_stop+0x44>)
   15990:	f003 fcf0 	bl	19374 <printk>
   15994:	4040      	eors	r0, r0
   15996:	f380 8811 	msr	BASEPRI, r0
   1599a:	f04f 0003 	mov.w	r0, #3
   1599e:	df02      	svc	2

	if (--_refcount) {
   159a0:	7820      	ldrb	r0, [r4, #0]
   159a2:	3801      	subs	r0, #1
   159a4:	b2c0      	uxtb	r0, r0
   159a6:	7020      	strb	r0, [r4, #0]
   159a8:	2301      	movs	r3, #1
   159aa:	b910      	cbnz	r0, 159b2 <cntr_stop+0x32>
   159ac:	4a06      	ldr	r2, [pc, #24]	; (159c8 <cntr_stop+0x48>)
   159ae:	6013      	str	r3, [r2, #0]
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_STOP);

	return 0;
}
   159b0:	bd10      	pop	{r4, pc}
		return 1;
   159b2:	4618      	mov	r0, r3
   159b4:	e7fc      	b.n	159b0 <cntr_stop+0x30>
   159b6:	bf00      	nop
   159b8:	20001dec 	.word	0x20001dec
   159bc:	00022426 	.word	0x00022426
   159c0:	0002246b 	.word	0x0002246b
   159c4:	00020aa4 	.word	0x00020aa4
   159c8:	4000b004 	.word	0x4000b004

000159cc <cntr_cnt_get>:
     return p_reg->COUNTER;
   159cc:	4b01      	ldr	r3, [pc, #4]	; (159d4 <cntr_cnt_get+0x8>)
   159ce:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

u32_t cntr_cnt_get(void)
{
	return nrf_rtc_counter_get(NRF_RTC);
}
   159d2:	4770      	bx	lr
   159d4:	4000b000 	.word	0x4000b000

000159d8 <cntr_cmp_set>:
    p_reg->CC[ch] = cc_val;
   159d8:	f500 70a8 	add.w	r0, r0, #336	; 0x150
   159dc:	4b01      	ldr	r3, [pc, #4]	; (159e4 <cntr_cmp_set+0xc>)
   159de:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

void cntr_cmp_set(u8_t cmp, u32_t value)
{
	nrf_rtc_cc_set(NRF_RTC, cmp, value);
}
   159e2:	4770      	bx	lr
   159e4:	4000b000 	.word	0x4000b000

000159e8 <do_ecb>:
	u8_t clear_text[16];
	u8_t cipher_text[16];
} __packed;

static void do_ecb(struct ecb_param *ecb)
{
   159e8:	b5f0      	push	{r4, r5, r6, r7, lr}
	do {
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
		NRF_ECB->ECBDATAPTR = (u32_t)ecb;
   159ea:	4b13      	ldr	r3, [pc, #76]	; (15a38 <do_ecb+0x50>)

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ecb_task_trigger(NRF_ECB_Type * p_reg, nrf_ecb_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   159ec:	4c13      	ldr	r4, [pc, #76]	; (15a3c <do_ecb+0x54>)
   159ee:	2501      	movs	r5, #1
{
   159f0:	4684      	mov	ip, r0
   159f2:	462e      	mov	r6, r5
		NRF_ECB->EVENTS_ENDECB = 0;
   159f4:	2700      	movs	r7, #0
   159f6:	46a6      	mov	lr, r4
   159f8:	461a      	mov	r2, r3
   159fa:	6026      	str	r6, [r4, #0]
		NRF_ECB->ECBDATAPTR = (u32_t)ecb;
   159fc:	f8c3 c504 	str.w	ip, [r3, #1284]	; 0x504
		NRF_ECB->EVENTS_ENDECB = 0;
   15a00:	f8c3 7100 	str.w	r7, [r3, #256]	; 0x100
		NRF_ECB->EVENTS_ERRORECB = 0;
   15a04:	f8c3 7104 	str.w	r7, [r3, #260]	; 0x104
   15a08:	601e      	str	r6, [r3, #0]
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STARTECB);
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
   15a0a:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
   15a0e:	b931      	cbnz	r1, 15a1e <do_ecb+0x36>
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
   15a10:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
   15a14:	b919      	cbnz	r1, 15a1e <do_ecb+0x36>
		       (NRF_ECB->ECBDATAPTR != 0)) {
   15a16:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
   15a1a:	2900      	cmp	r1, #0
   15a1c:	d1f5      	bne.n	15a0a <do_ecb+0x22>
   15a1e:	f8ce 5000 	str.w	r5, [lr]
#else
			/*__WFE();*/
#endif
		}
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
	} while ((NRF_ECB->EVENTS_ERRORECB != 0) || (NRF_ECB->ECBDATAPTR == 0));
   15a22:	f8d2 1104 	ldr.w	r1, [r2, #260]	; 0x104
   15a26:	2900      	cmp	r1, #0
   15a28:	d1e7      	bne.n	159fa <do_ecb+0x12>
   15a2a:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
   15a2e:	2800      	cmp	r0, #0
   15a30:	d0e3      	beq.n	159fa <do_ecb+0x12>

	NRF_ECB->ECBDATAPTR = 0;
   15a32:	f8c2 1504 	str.w	r1, [r2, #1284]	; 0x504
}
   15a36:	bdf0      	pop	{r4, r5, r6, r7, pc}
   15a38:	4000e000 	.word	0x4000e000
   15a3c:	4000e004 	.word	0x4000e004

00015a40 <hal_radio_enable_on_tick_ppi_config_and_enable>:
static inline void hal_radio_enable_on_tick_ppi_config_and_enable(u8_t trx)
{
	/* No need to configure anything for the pre-programmed channels.
	 * Just enable and disable them accordingly.
	 */
	nrf_ppi_channels_disable(
   15a40:	2800      	cmp	r0, #0
    p_reg->CHENSET = mask;
}

NRF_STATIC_INLINE void nrf_ppi_channels_disable(NRF_PPI_Type * p_reg, uint32_t mask)
{
    p_reg->CHENCLR = mask;
   15a42:	4b08      	ldr	r3, [pc, #32]	; (15a64 <hal_radio_enable_on_tick_ppi_config_and_enable+0x24>)
   15a44:	bf14      	ite	ne
   15a46:	f44f 1200 	movne.w	r2, #2097152	; 0x200000
   15a4a:	f44f 1280 	moveq.w	r2, #1048576	; 0x100000
   15a4e:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
		NRF_PPI,
		trx ? BIT(HAL_RADIO_ENABLE_RX_ON_TICK_PPI)
		    : BIT(HAL_RADIO_ENABLE_TX_ON_TICK_PPI));
	nrf_ppi_channels_enable(
   15a52:	bf14      	ite	ne
   15a54:	f44f 1280 	movne.w	r2, #1048576	; 0x100000
   15a58:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
    p_reg->CHENSET = mask;
   15a5c:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
		NRF_PPI,
		trx ? BIT(HAL_RADIO_ENABLE_TX_ON_TICK_PPI)
		    : BIT(HAL_RADIO_ENABLE_RX_ON_TICK_PPI));
}
   15a60:	4770      	bx	lr
   15a62:	bf00      	nop
   15a64:	4001f000 	.word	0x4001f000

00015a68 <sw_switch.isra.10>:
}

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
static u8_t sw_tifs_toggle;

static void sw_switch(u8_t dir, u8_t phy_curr, u8_t flags_curr, u8_t phy_next,
   15a68:	b5f0      	push	{r4, r5, r6, r7, lr}
		      u8_t flags_next)
{
	u8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
   15a6a:	4e2d      	ldr	r6, [pc, #180]	; (15b20 <sw_switch.isra.10+0xb8>)
NRF_STATIC_INLINE void nrf_ppi_channel_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                      nrf_ppi_channel_t channel,
                                                      uint32_t          eep,
                                                      uint32_t          tep)
{
    p_reg->CH[(uint32_t) channel].EEP = eep;
   15a6c:	4f2d      	ldr	r7, [pc, #180]	; (15b24 <sw_switch.isra.10+0xbc>)
   15a6e:	7835      	ldrb	r5, [r6, #0]
   15a70:	f8df c0bc 	ldr.w	ip, [pc, #188]	; 15b30 <sw_switch.isra.10+0xc8>
   15a74:	f8c7 c560 	str.w	ip, [r7, #1376]	; 0x560
	 */
	nrf_ppi_channel_endpoint_setup(
		NRF_PPI,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_EVT,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_TASK(ppi_group_index));
   15a78:	b22b      	sxth	r3, r5
   15a7a:	00dc      	lsls	r4, r3, #3
   15a7c:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
   15a80:	f504 34f8 	add.w	r4, r4, #126976	; 0x1f000
    p_reg->CH[(uint32_t) channel].TEP = tep;
   15a84:	f8c7 4564 	str.w	r4, [r7, #1380]	; 0x564
   15a88:	f105 040b 	add.w	r4, r5, #11
   15a8c:	b2e4      	uxtb	r4, r4
   15a8e:	00e4      	lsls	r4, r4, #3
	 * (TX/RX).
	 */
	nrf_ppi_event_endpoint_setup(
		NRF_PPI,
		radio_enable_ppi,
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(compare_reg));
   15a90:	f5a7 37af 	sub.w	r7, r7, #89600	; 0x15e00
   15a94:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
   15a98:	3fc0      	subs	r7, #192	; 0xc0
   15a9a:	f504 34f8 	add.w	r4, r4, #126976	; 0x1f000
   15a9e:	eb07 0783 	add.w	r7, r7, r3, lsl #2

NRF_STATIC_INLINE void nrf_ppi_event_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                    nrf_ppi_channel_t channel,
                                                    uint32_t          eep)
{
    p_reg->CH[(uint32_t) channel].EEP = eep;
   15aa2:	f8c4 7510 	str.w	r7, [r4, #1296]	; 0x510
	u8_t cc = SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle);
	u32_t delay;

	hal_radio_sw_switch_setup(cc, ppi, sw_tifs_toggle);

	if (dir) {
   15aa6:	2800      	cmp	r0, #0
   15aa8:	d034      	beq.n	15b14 <sw_switch.isra.10+0xac>
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF52832_TXEN_TXIDLE_TX_1M_NS;
	case BIT(1):
		return HAL_RADIO_NRF52832_TXEN_TXIDLE_TX_2M_NS;
   15aaa:	f649 4740 	movw	r7, #40000	; 0x9c40
   15aae:	f24a 005a 	movw	r0, #41050	; 0xa05a
   15ab2:	2a02      	cmp	r2, #2
   15ab4:	bf08      	it	eq
   15ab6:	4638      	moveq	r0, r7
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF52832_RX_CHAIN_DELAY_1M_NS;
	case BIT(1):
		return HAL_RADIO_NRF52832_RX_CHAIN_DELAY_2M_NS;
   15ab8:	f242 42b8 	movw	r2, #9400	; 0x24b8
   15abc:	f241 574a 	movw	r7, #5450	; 0x154a
   15ac0:	2902      	cmp	r1, #2
   15ac2:	bf14      	ite	ne
   15ac4:	4611      	movne	r1, r2
   15ac6:	4639      	moveq	r1, r7
		/* TX */

		/* Calculate delay with respect to current (RX) and next
		 * (TX) PHY. If RX PHY is LE Coded, assume S8 coding scheme.
		 */
		delay = HAL_RADIO_NS2US_ROUND(
   15ac8:	f500 70fa 	add.w	r0, r0, #500	; 0x1f4
   15acc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   15ad0:	4401      	add	r1, r0
   15ad2:	fbb1 f1f2 	udiv	r1, r1, r2

NRF_STATIC_INLINE void nrf_ppi_task_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                   nrf_ppi_channel_t channel,
                                                   uint32_t          tep)
{
    p_reg->CH[(uint32_t) channel].TEP = tep;
   15ad6:	4a14      	ldr	r2, [pc, #80]	; (15b28 <sw_switch.isra.10+0xc0>)
   15ad8:	f8c4 2514 	str.w	r2, [r4, #1300]	; 0x514
		}
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	}

	if (delay <
   15adc:	009b      	lsls	r3, r3, #2
   15ade:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   15ae2:	f503 4310 	add.w	r3, r3, #36864	; 0x9000
		SW_SWITCH_TIMER->CC[cc]) {
   15ae6:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
	if (delay <
   15aea:	428a      	cmp	r2, r1
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
				 SW_SWITCH_TIMER->CC[cc] - delay);
   15aec:	bf8b      	itete	hi
   15aee:	f8d3 2540 	ldrhi.w	r2, [r3, #1344]	; 0x540

NRF_STATIC_INLINE void nrf_timer_cc_set(NRF_TIMER_Type *       p_reg,
                                        nrf_timer_cc_channel_t cc_channel,
                                        uint32_t               cc_value)
{
    p_reg->CC[cc_channel] = cc_value;
   15af2:	2201      	movls	r2, #1
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
   15af4:	1a51      	subhi	r1, r2, r1
   15af6:	f8c3 2540 	strls.w	r2, [r3, #1344]	; 0x540
   15afa:	bf88      	it	hi
   15afc:	f8c3 1540 	strhi.w	r1, [r3, #1344]	; 0x540
    p_reg->CHENSET = mask;
   15b00:	4b08      	ldr	r3, [pc, #32]	; (15b24 <sw_switch.isra.10+0xbc>)
   15b02:	f44f 6290 	mov.w	r2, #1152	; 0x480
   15b06:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	 * always need to capture the PDU END time-stamp.
	 */
	radio_tmr_end_capture();
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */

	sw_tifs_toggle += 1U;
   15b0a:	1c6b      	adds	r3, r5, #1
	sw_tifs_toggle &= 1;
   15b0c:	f003 0301 	and.w	r3, r3, #1
   15b10:	7033      	strb	r3, [r6, #0]
}
   15b12:	bdf0      	pop	{r4, r5, r6, r7, pc}
    p_reg->CH[(uint32_t) channel].TEP = tep;
   15b14:	4a05      	ldr	r2, [pc, #20]	; (15b2c <sw_switch.isra.10+0xc4>)
   15b16:	f8c4 2514 	str.w	r2, [r4, #1300]	; 0x514
		delay = HAL_RADIO_NS2US_CEIL(
   15b1a:	2129      	movs	r1, #41	; 0x29
   15b1c:	e7de      	b.n	15adc <sw_switch.isra.10+0x74>
   15b1e:	bf00      	nop
   15b20:	20001ded 	.word	0x20001ded
   15b24:	4001f000 	.word	0x4001f000
   15b28:	40001000 	.word	0x40001000
   15b2c:	40001004 	.word	0x40001004
   15b30:	4000110c 	.word	0x4000110c

00015b34 <isr_radio>:
	return (NRF_RADIO->EVENTS_DISABLED != 0);
   15b34:	4b04      	ldr	r3, [pc, #16]	; (15b48 <isr_radio+0x14>)
   15b36:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
	if (radio_has_disabled()) {
   15b3a:	b123      	cbz	r3, 15b46 <isr_radio+0x12>
		isr_cb(isr_cb_param);
   15b3c:	4b03      	ldr	r3, [pc, #12]	; (15b4c <isr_radio+0x18>)
   15b3e:	4a04      	ldr	r2, [pc, #16]	; (15b50 <isr_radio+0x1c>)
   15b40:	681b      	ldr	r3, [r3, #0]
   15b42:	6810      	ldr	r0, [r2, #0]
   15b44:	4718      	bx	r3
}
   15b46:	4770      	bx	lr
   15b48:	40001000 	.word	0x40001000
   15b4c:	20001828 	.word	0x20001828
   15b50:	2000182c 	.word	0x2000182c

00015b54 <radio_isr_set>:
{
   15b54:	b538      	push	{r3, r4, r5, lr}
   15b56:	4604      	mov	r4, r0
	irq_disable(RADIO_IRQn);
   15b58:	2001      	movs	r0, #1
{
   15b5a:	460d      	mov	r5, r1
	irq_disable(RADIO_IRQn);
   15b5c:	f7ee fc0c 	bl	4378 <arch_irq_disable>
	isr_cb_param = param;
   15b60:	4b08      	ldr	r3, [pc, #32]	; (15b84 <radio_isr_set+0x30>)
   15b62:	601d      	str	r5, [r3, #0]
	isr_cb = cb;
   15b64:	4b08      	ldr	r3, [pc, #32]	; (15b88 <radio_isr_set+0x34>)
   15b66:	601c      	str	r4, [r3, #0]
    return p_reg->SHORTS;
}

NRF_STATIC_INLINE void nrf_radio_int_enable(NRF_RADIO_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   15b68:	4b08      	ldr	r3, [pc, #32]	; (15b8c <radio_isr_set+0x38>)
   15b6a:	2210      	movs	r2, #16
   15b6c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   15b70:	4b07      	ldr	r3, [pc, #28]	; (15b90 <radio_isr_set+0x3c>)
   15b72:	2202      	movs	r2, #2
   15b74:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	irq_enable(RADIO_IRQn);
   15b78:	2001      	movs	r0, #1
}
   15b7a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	irq_enable(RADIO_IRQn);
   15b7e:	f7ee bbeb 	b.w	4358 <arch_irq_enable>
   15b82:	bf00      	nop
   15b84:	2000182c 	.word	0x2000182c
   15b88:	20001828 	.word	0x20001828
   15b8c:	40001000 	.word	0x40001000
   15b90:	e000e100 	.word	0xe000e100

00015b94 <radio_reset>:
{
   15b94:	b508      	push	{r3, lr}
	irq_disable(RADIO_IRQn);
   15b96:	2001      	movs	r0, #1
   15b98:	f7ee fbee 	bl	4378 <arch_irq_disable>
}
#endif

NRF_STATIC_INLINE void nrf_radio_power_set(NRF_RADIO_Type * p_reg, bool radio_power)
{
    p_reg->POWER = (uint32_t) radio_power;
   15b9c:	4b0c      	ldr	r3, [pc, #48]	; (15bd0 <radio_reset+0x3c>)
   15b9e:	2200      	movs	r2, #0
   15ba0:	f8c3 2ffc 	str.w	r2, [r3, #4092]	; 0xffc
   15ba4:	2201      	movs	r2, #1
   15ba6:	f8c3 2ffc 	str.w	r2, [r3, #4092]	; 0xffc
	*(volatile u32_t *)0x40001774 = ((*(volatile u32_t *)0x40001774) &
   15baa:	4a0a      	ldr	r2, [pc, #40]	; (15bd4 <radio_reset+0x40>)
   15bac:	6813      	ldr	r3, [r2, #0]
					 0xfffffffe) | 0x01000000;
   15bae:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   15bb2:	f023 0301 	bic.w	r3, r3, #1
   15bb6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
	*(volatile u32_t *)0x40001774 = ((*(volatile u32_t *)0x40001774) &
   15bba:	6013      	str	r3, [r2, #0]
static inline void hal_radio_sw_switch_ppi_group_setup(void)
{
	/* Include the appropriate PPI channels in the two PPI Groups. */
#if !defined(CONFIG_BT_CTLR_PHY_CODED) || \
	!defined(CONFIG_HAS_HW_NRF_RADIO_BLE_CODED)
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
   15bbc:	4b06      	ldr	r3, [pc, #24]	; (15bd8 <radio_reset+0x44>)
   15bbe:	f44f 6210 	mov.w	r2, #2304	; 0x900
   15bc2:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_0_INCLUDE |
			HAL_SW_SWITCH_RADIO_ENABLE_PPI_0_INCLUDE;
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
   15bc6:	f44f 5290 	mov.w	r2, #4608	; 0x1200
   15bca:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
}
   15bce:	bd08      	pop	{r3, pc}
   15bd0:	40001000 	.word	0x40001000
   15bd4:	40001774 	.word	0x40001774
   15bd8:	4001f000 	.word	0x4001f000

00015bdc <radio_phy_set>:
	NRF_RADIO->MODE = (mode << RADIO_MODE_MODE_Pos) & RADIO_MODE_MODE_Msk;
   15bdc:	4b06      	ldr	r3, [pc, #24]	; (15bf8 <radio_phy_set+0x1c>)
	switch (phy) {
   15bde:	2802      	cmp	r0, #2
		mode = RADIO_MODE_MODE_Ble_2Mbit;
   15be0:	bf14      	ite	ne
   15be2:	2203      	movne	r2, #3
   15be4:	2204      	moveq	r2, #4
   15be6:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_RADIO->MODECNF0 |= (RADIO_MODECNF0_RU_Fast <<
   15bea:	f8d3 2650 	ldr.w	r2, [r3, #1616]	; 0x650
   15bee:	f042 0201 	orr.w	r2, r2, #1
   15bf2:	f8c3 2650 	str.w	r2, [r3, #1616]	; 0x650
}
   15bf6:	4770      	bx	lr
   15bf8:	40001000 	.word	0x40001000

00015bfc <radio_tx_power_set>:
	NRF_RADIO->TXPOWER = (u32_t)power;
   15bfc:	4b01      	ldr	r3, [pc, #4]	; (15c04 <radio_tx_power_set+0x8>)
   15bfe:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
}
   15c02:	4770      	bx	lr
   15c04:	40001000 	.word	0x40001000

00015c08 <radio_freq_chan_set>:
	NRF_RADIO->FREQUENCY = chan;
   15c08:	4b01      	ldr	r3, [pc, #4]	; (15c10 <radio_freq_chan_set+0x8>)
   15c0a:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
}
   15c0e:	4770      	bx	lr
   15c10:	40001000 	.word	0x40001000

00015c14 <radio_whiten_iv_set>:
	NRF_RADIO->DATAWHITEIV = iv;
   15c14:	4b07      	ldr	r3, [pc, #28]	; (15c34 <radio_whiten_iv_set+0x20>)
   15c16:	f8c3 0554 	str.w	r0, [r3, #1364]	; 0x554
	NRF_RADIO->PCNF1 &= ~RADIO_PCNF1_WHITEEN_Msk;
   15c1a:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
   15c1e:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
   15c22:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((1UL) << RADIO_PCNF1_WHITEEN_Pos) &
   15c26:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
   15c2a:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
   15c2e:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
   15c32:	4770      	bx	lr
   15c34:	40001000 	.word	0x40001000

00015c38 <radio_aa_set>:
	NRF_RADIO->TXADDRESS =
   15c38:	4a0a      	ldr	r2, [pc, #40]	; (15c64 <radio_aa_set+0x2c>)
   15c3a:	2300      	movs	r3, #0
   15c3c:	f8c2 352c 	str.w	r3, [r2, #1324]	; 0x52c
	NRF_RADIO->RXADDRESSES =
   15c40:	2301      	movs	r3, #1
   15c42:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
	NRF_RADIO->PREFIX0 = aa[3];
   15c46:	78c3      	ldrb	r3, [r0, #3]
   15c48:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
	NRF_RADIO->BASE0 = (aa[2] << 24) | (aa[1] << 16) | (aa[0] << 8);
   15c4c:	7843      	ldrb	r3, [r0, #1]
   15c4e:	7881      	ldrb	r1, [r0, #2]
   15c50:	041b      	lsls	r3, r3, #16
   15c52:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
   15c56:	7801      	ldrb	r1, [r0, #0]
   15c58:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   15c5c:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
}
   15c60:	4770      	bx	lr
   15c62:	bf00      	nop
   15c64:	40001000 	.word	0x40001000

00015c68 <radio_pkt_configure>:
	switch (phy) {
   15c68:	f3c2 0342 	ubfx	r3, r2, #1, #3
		extra |= (RADIO_PCNF0_PLEN_16bit << RADIO_PCNF0_PLEN_Pos) &
   15c6c:	2b02      	cmp	r3, #2
{
   15c6e:	b510      	push	{r4, lr}
		extra |= (RADIO_PCNF0_PLEN_16bit << RADIO_PCNF0_PLEN_Pos) &
   15c70:	bf14      	ite	ne
   15c72:	2400      	movne	r4, #0
   15c74:	f04f 7480 	moveq.w	r4, #16777216	; 0x1000000
	if (dc) {
   15c78:	07d3      	lsls	r3, r2, #31
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
   15c7a:	f1c0 0308 	rsb	r3, r0, #8
		extra |= (RADIO_PCNF0_S1INCL_Include <<
   15c7e:	bf48      	it	mi
   15c80:	f444 1480 	orrmi.w	r4, r4, #1048576	; 0x100000
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
   15c84:	041b      	lsls	r3, r3, #16
			   ((((u32_t)bits_len) << RADIO_PCNF0_LFLEN_Pos) &
   15c86:	f000 000f 	and.w	r0, r0, #15
			    RADIO_PCNF0_S1LEN_Msk) |
   15c8a:	4320      	orrs	r0, r4
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
   15c8c:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
   15c90:	4a09      	ldr	r2, [pc, #36]	; (15cb8 <radio_pkt_configure+0x50>)
			    RADIO_PCNF0_S1LEN_Msk) |
   15c92:	4303      	orrs	r3, r0
   15c94:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
   15c98:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
   15c9c:	f8d2 0518 	ldr.w	r0, [r2, #1304]	; 0x518
   15ca0:	4b06      	ldr	r3, [pc, #24]	; (15cbc <radio_pkt_configure+0x54>)
   15ca2:	4003      	ands	r3, r0
   15ca4:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((((u32_t)max_len) << RADIO_PCNF1_MAXLEN_Pos) &
   15ca8:	f8d2 3518 	ldr.w	r3, [r2, #1304]	; 0x518
   15cac:	4319      	orrs	r1, r3
   15cae:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
   15cb2:	f8c2 1518 	str.w	r1, [r2, #1304]	; 0x518
}
   15cb6:	bd10      	pop	{r4, pc}
   15cb8:	40001000 	.word	0x40001000
   15cbc:	fef80000 	.word	0xfef80000

00015cc0 <radio_pkt_rx_set>:
	NRF_RADIO->PACKETPTR = (u32_t)rx_packet;
   15cc0:	4b01      	ldr	r3, [pc, #4]	; (15cc8 <radio_pkt_rx_set+0x8>)
   15cc2:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
}
   15cc6:	4770      	bx	lr
   15cc8:	40001000 	.word	0x40001000

00015ccc <radio_pkt_tx_set>:
   15ccc:	4b01      	ldr	r3, [pc, #4]	; (15cd4 <radio_pkt_tx_set+0x8>)
   15cce:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
   15cd2:	4770      	bx	lr
   15cd4:	40001000 	.word	0x40001000

00015cd8 <radio_tx_enable>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   15cd8:	4b01      	ldr	r3, [pc, #4]	; (15ce0 <radio_tx_enable+0x8>)
   15cda:	2201      	movs	r2, #1
   15cdc:	601a      	str	r2, [r3, #0]
}
   15cde:	4770      	bx	lr
   15ce0:	40001000 	.word	0x40001000

00015ce4 <radio_disable>:
    p_reg->CHENCLR = mask;
   15ce4:	4a07      	ldr	r2, [pc, #28]	; (15d04 <radio_disable+0x20>)
   15ce6:	f44f 6390 	mov.w	r3, #1152	; 0x480
   15cea:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    p_reg->TASKS_CHG[(uint32_t) group].EN = 1UL;
}

NRF_STATIC_INLINE void nrf_ppi_group_disable(NRF_PPI_Type * p_reg, nrf_ppi_channel_group_t group)
{
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1UL;
   15cee:	2301      	movs	r3, #1
   15cf0:	6053      	str	r3, [r2, #4]
   15cf2:	60d3      	str	r3, [r2, #12]
	NRF_RADIO->SHORTS = 0;
   15cf4:	f5a2 32f0 	sub.w	r2, r2, #122880	; 0x1e000
   15cf8:	2100      	movs	r1, #0
   15cfa:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
   15cfe:	6113      	str	r3, [r2, #16]
}
   15d00:	4770      	bx	lr
   15d02:	bf00      	nop
   15d04:	4001f000 	.word	0x4001f000

00015d08 <radio_status_reset>:
	NRF_RADIO->EVENTS_READY = 0;
   15d08:	4b04      	ldr	r3, [pc, #16]	; (15d1c <radio_status_reset+0x14>)
   15d0a:	2200      	movs	r2, #0
   15d0c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	NRF_RADIO->EVENTS_END = 0;
   15d10:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
	NRF_RADIO->EVENTS_DISABLED = 0;
   15d14:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
   15d18:	4770      	bx	lr
   15d1a:	bf00      	nop
   15d1c:	40001000 	.word	0x40001000

00015d20 <radio_is_ready>:
	return (NRF_RADIO->EVENTS_READY != 0);
   15d20:	4b03      	ldr	r3, [pc, #12]	; (15d30 <radio_is_ready+0x10>)
   15d22:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
}
   15d26:	3000      	adds	r0, #0
   15d28:	bf18      	it	ne
   15d2a:	2001      	movne	r0, #1
   15d2c:	4770      	bx	lr
   15d2e:	bf00      	nop
   15d30:	40001000 	.word	0x40001000

00015d34 <radio_is_done>:
	return (NRF_RADIO->EVENTS_END != 0);
   15d34:	4b03      	ldr	r3, [pc, #12]	; (15d44 <radio_is_done+0x10>)
   15d36:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
}
   15d3a:	3000      	adds	r0, #0
   15d3c:	bf18      	it	ne
   15d3e:	2001      	movne	r0, #1
   15d40:	4770      	bx	lr
   15d42:	bf00      	nop
   15d44:	40001000 	.word	0x40001000

00015d48 <radio_crc_configure>:
	NRF_RADIO->CRCCNF =
   15d48:	4b04      	ldr	r3, [pc, #16]	; (15d5c <radio_crc_configure+0x14>)
   15d4a:	f240 1203 	movw	r2, #259	; 0x103
   15d4e:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
	NRF_RADIO->CRCPOLY = polynomial;
   15d52:	f8c3 0538 	str.w	r0, [r3, #1336]	; 0x538
	NRF_RADIO->CRCINIT = iv;
   15d56:	f8c3 153c 	str.w	r1, [r3, #1340]	; 0x53c
}
   15d5a:	4770      	bx	lr
   15d5c:	40001000 	.word	0x40001000

00015d60 <radio_crc_is_valid>:
	return (NRF_RADIO->CRCSTATUS != 0);
   15d60:	4b03      	ldr	r3, [pc, #12]	; (15d70 <radio_crc_is_valid+0x10>)
   15d62:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
   15d66:	3000      	adds	r0, #0
   15d68:	bf18      	it	ne
   15d6a:	2001      	movne	r0, #1
   15d6c:	4770      	bx	lr
   15d6e:	bf00      	nop
   15d70:	40001000 	.word	0x40001000

00015d74 <radio_pkt_empty_get>:
}
   15d74:	4800      	ldr	r0, [pc, #0]	; (15d78 <radio_pkt_empty_get+0x4>)
   15d76:	4770      	bx	lr
   15d78:	20001720 	.word	0x20001720

00015d7c <radio_pkt_scratch_get>:
}
   15d7c:	4800      	ldr	r0, [pc, #0]	; (15d80 <radio_pkt_scratch_get+0x4>)
   15d7e:	4770      	bx	lr
   15d80:	20001724 	.word	0x20001724

00015d84 <radio_switch_complete_and_rx>:
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_RXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
   15d84:	4b04      	ldr	r3, [pc, #16]	; (15d98 <radio_switch_complete_and_rx+0x14>)
   15d86:	2203      	movs	r2, #3
			    RADIO_SHORTS_END_DISABLE_Msk;
	sw_switch(0, 0, 0, phy_rx, 0);
   15d88:	2100      	movs	r1, #0
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
   15d8a:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
	sw_switch(0, 0, 0, phy_rx, 0);
   15d8e:	4602      	mov	r2, r0
   15d90:	4608      	mov	r0, r1
   15d92:	f7ff be69 	b.w	15a68 <sw_switch.isra.10>
   15d96:	bf00      	nop
   15d98:	40001000 	.word	0x40001000

00015d9c <radio_switch_complete_and_tx>:
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_TXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
   15d9c:	4b03      	ldr	r3, [pc, #12]	; (15dac <radio_switch_complete_and_tx+0x10>)
   15d9e:	2103      	movs	r1, #3
   15da0:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
			    RADIO_SHORTS_END_DISABLE_Msk;
	sw_switch(1, phy_rx, flags_rx, phy_tx, flags_tx);
   15da4:	4601      	mov	r1, r0
   15da6:	2001      	movs	r0, #1
   15da8:	f7ff be5e 	b.w	15a68 <sw_switch.isra.10>
   15dac:	40001000 	.word	0x40001000

00015db0 <radio_switch_complete_and_disable>:
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}

void radio_switch_complete_and_disable(void)
{
	NRF_RADIO->SHORTS =
   15db0:	4b05      	ldr	r3, [pc, #20]	; (15dc8 <radio_switch_complete_and_disable+0x18>)
   15db2:	2203      	movs	r2, #3
   15db4:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    p_reg->CHENCLR = mask;
   15db8:	f503 33f0 	add.w	r3, r3, #122880	; 0x1e000
   15dbc:	f44f 6290 	mov.w	r2, #1152	; 0x480
   15dc0:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
	    (RADIO_SHORTS_READY_START_Msk | RADIO_SHORTS_END_DISABLE_Msk);

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	hal_radio_sw_switch_disable();
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   15dc4:	4770      	bx	lr
   15dc6:	bf00      	nop
   15dc8:	40001000 	.word	0x40001000

00015dcc <radio_rssi_status_reset>:
	return NRF_RADIO->RSSISAMPLE;
}

void radio_rssi_status_reset(void)
{
	NRF_RADIO->EVENTS_RSSIEND = 0;
   15dcc:	4b02      	ldr	r3, [pc, #8]	; (15dd8 <radio_rssi_status_reset+0xc>)
   15dce:	2200      	movs	r2, #0
   15dd0:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
}
   15dd4:	4770      	bx	lr
   15dd6:	bf00      	nop
   15dd8:	40001000 	.word	0x40001000

00015ddc <radio_rssi_is_ready>:

u32_t radio_rssi_is_ready(void)
{
	return (NRF_RADIO->EVENTS_RSSIEND != 0);
   15ddc:	4b03      	ldr	r3, [pc, #12]	; (15dec <radio_rssi_is_ready+0x10>)
   15dde:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
}
   15de2:	3000      	adds	r0, #0
   15de4:	bf18      	it	ne
   15de6:	2001      	movne	r0, #1
   15de8:	4770      	bx	lr
   15dea:	bf00      	nop
   15dec:	40001000 	.word	0x40001000

00015df0 <radio_filter_configure>:

void radio_filter_configure(u8_t bitmask_enable, u8_t bitmask_addr_type,
			    u8_t *bdaddr)
{
   15df0:	b5f0      	push	{r4, r5, r6, r7, lr}
   15df2:	2400      	movs	r4, #0
   15df4:	2706      	movs	r7, #6
   15df6:	00a3      	lsls	r3, r4, #2
   15df8:	fb07 2504 	mla	r5, r7, r4, r2
	u8_t index;

	for (index = 0U; index < 8; index++) {
		NRF_RADIO->DAB[index] = ((u32_t)bdaddr[3] << 24) |
   15dfc:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   15e00:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
			((u32_t)bdaddr[2] << 16) |
			((u32_t)bdaddr[1] << 8) |
   15e04:	682e      	ldr	r6, [r5, #0]
		NRF_RADIO->DAB[index] = ((u32_t)bdaddr[3] << 24) |
   15e06:	f8c3 6600 	str.w	r6, [r3, #1536]	; 0x600
			bdaddr[0];
		NRF_RADIO->DAP[index] = ((u32_t)bdaddr[5] << 8) | bdaddr[4];
   15e0a:	3401      	adds	r4, #1
   15e0c:	88ad      	ldrh	r5, [r5, #4]
   15e0e:	f8c3 5620 	str.w	r5, [r3, #1568]	; 0x620
	for (index = 0U; index < 8; index++) {
   15e12:	2c08      	cmp	r4, #8
   15e14:	d1ef      	bne.n	15df6 <radio_filter_configure+0x6>
		bdaddr += 6;
	}

	NRF_RADIO->DACNF = ((u32_t)bitmask_addr_type << 8) | bitmask_enable;
   15e16:	4b03      	ldr	r3, [pc, #12]	; (15e24 <radio_filter_configure+0x34>)
   15e18:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
   15e1c:	f8c3 0640 	str.w	r0, [r3, #1600]	; 0x640
}
   15e20:	bdf0      	pop	{r4, r5, r6, r7, pc}
   15e22:	bf00      	nop
   15e24:	40001000 	.word	0x40001000

00015e28 <radio_filter_disable>:

void radio_filter_disable(void)
{
	NRF_RADIO->DACNF &= ~(0x000000FF);
   15e28:	4a03      	ldr	r2, [pc, #12]	; (15e38 <radio_filter_disable+0x10>)
   15e2a:	f8d2 3640 	ldr.w	r3, [r2, #1600]	; 0x640
   15e2e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   15e32:	f8c2 3640 	str.w	r3, [r2, #1600]	; 0x640
}
   15e36:	4770      	bx	lr
   15e38:	40001000 	.word	0x40001000

00015e3c <radio_filter_status_reset>:

void radio_filter_status_reset(void)
{
	NRF_RADIO->EVENTS_DEVMATCH = 0;
   15e3c:	4b02      	ldr	r3, [pc, #8]	; (15e48 <radio_filter_status_reset+0xc>)
   15e3e:	2200      	movs	r2, #0
   15e40:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
   15e44:	4770      	bx	lr
   15e46:	bf00      	nop
   15e48:	40001000 	.word	0x40001000

00015e4c <radio_filter_has_match>:

u32_t radio_filter_has_match(void)
{
	return (NRF_RADIO->EVENTS_DEVMATCH != 0);
   15e4c:	4b03      	ldr	r3, [pc, #12]	; (15e5c <radio_filter_has_match+0x10>)
   15e4e:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
   15e52:	3000      	adds	r0, #0
   15e54:	bf18      	it	ne
   15e56:	2001      	movne	r0, #1
   15e58:	4770      	bx	lr
   15e5a:	bf00      	nop
   15e5c:	40001000 	.word	0x40001000

00015e60 <radio_filter_match_get>:

u32_t radio_filter_match_get(void)
{
	return NRF_RADIO->DAI;
   15e60:	4b01      	ldr	r3, [pc, #4]	; (15e68 <radio_filter_match_get+0x8>)
   15e62:	f8d3 0410 	ldr.w	r0, [r3, #1040]	; 0x410
}
   15e66:	4770      	bx	lr
   15e68:	40001000 	.word	0x40001000

00015e6c <radio_bc_configure>:
    p_reg->BCC = radio_bcc;
   15e6c:	4b04      	ldr	r3, [pc, #16]	; (15e80 <radio_bc_configure+0x14>)
   15e6e:	f8c3 0560 	str.w	r0, [r3, #1376]	; 0x560

void radio_bc_configure(u32_t n)
{
	nrf_radio_bcc_set(NRF_RADIO, n);
	NRF_RADIO->SHORTS |= RADIO_SHORTS_ADDRESS_BCSTART_Msk;
   15e72:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   15e76:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   15e7a:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
}
   15e7e:	4770      	bx	lr
   15e80:	40001000 	.word	0x40001000

00015e84 <radio_tmr_status_reset>:
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   15e84:	4b05      	ldr	r3, [pc, #20]	; (15e9c <radio_tmr_status_reset+0x18>)
   15e86:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   15e8a:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
   15e8e:	f503 33a0 	add.w	r3, r3, #81920	; 0x14000
   15e92:	4a03      	ldr	r2, [pc, #12]	; (15ea0 <radio_tmr_status_reset+0x1c>)
   15e94:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
			BIT(HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI) |
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
			BIT(HAL_TRIGGER_CRYPT_PPI));
}
   15e98:	4770      	bx	lr
   15e9a:	bf00      	nop
   15e9c:	4000b000 	.word	0x4000b000
   15ea0:	0e700060 	.word	0x0e700060

00015ea4 <radio_tmr_tifs_set>:
void radio_tmr_tifs_set(u32_t tifs)
{
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->TIFS = tifs;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	nrf_timer_cc_set(SW_SWITCH_TIMER,
   15ea4:	4b03      	ldr	r3, [pc, #12]	; (15eb4 <radio_tmr_tifs_set+0x10>)
   15ea6:	4a04      	ldr	r2, [pc, #16]	; (15eb8 <radio_tmr_tifs_set+0x14>)
   15ea8:	781b      	ldrb	r3, [r3, #0]
   15eaa:	f503 73a8 	add.w	r3, r3, #336	; 0x150
   15eae:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
			 SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle), tifs);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   15eb2:	4770      	bx	lr
   15eb4:	20001ded 	.word	0x20001ded
   15eb8:	40009000 	.word	0x40009000

00015ebc <radio_tmr_start>:

u32_t radio_tmr_start(u8_t trx, u32_t ticks_start, u32_t remainder)
{
   15ebc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if ((!(remainder / 1000000UL)) || (remainder & 0x80000000)) {
   15ebe:	f5a2 2374 	sub.w	r3, r2, #999424	; 0xf4000
   15ec2:	4c2f      	ldr	r4, [pc, #188]	; (15f80 <radio_tmr_start+0xc4>)
   15ec4:	f5a3 7310 	sub.w	r3, r3, #576	; 0x240
   15ec8:	42a3      	cmp	r3, r4
		ticks_start--;
		remainder += 30517578UL;
   15eca:	bf88      	it	hi
   15ecc:	f102 72e8 	addhi.w	r2, r2, #30408704	; 0x1d00000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   15ed0:	4b2c      	ldr	r3, [pc, #176]	; (15f84 <radio_tmr_start+0xc8>)
	}
	remainder /= 1000000UL;
   15ed2:	4c2d      	ldr	r4, [pc, #180]	; (15f88 <radio_tmr_start+0xcc>)
		remainder += 30517578UL;
   15ed4:	bf84      	itt	hi
   15ed6:	f502 32d4 	addhi.w	r2, r2, #108544	; 0x1a800
   15eda:	f502 72a5 	addhi.w	r2, r2, #330	; 0x14a
   15ede:	f04f 0501 	mov.w	r5, #1
	remainder /= 1000000UL;
   15ee2:	fbb2 f4f4 	udiv	r4, r2, r4

	nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CLEAR);
	EVENT_TIMER->MODE = 0;
   15ee6:	f04f 0600 	mov.w	r6, #0
	EVENT_TIMER->PRESCALER = 4;
   15eea:	f04f 0704 	mov.w	r7, #4
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
   15eee:	f04f 0202 	mov.w	r2, #2
   15ef2:	601d      	str	r5, [r3, #0]
	EVENT_TIMER->MODE = 0;
   15ef4:	f8c3 64f8 	str.w	r6, [r3, #1272]	; 0x4f8
	EVENT_TIMER->PRESCALER = 4;
   15ef8:	f8c3 7504 	str.w	r7, [r3, #1284]	; 0x504
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
   15efc:	f8c3 24fc 	str.w	r2, [r3, #1276]	; 0x4fc
    p_reg->CC[ch] = cc_val;
   15f00:	4a22      	ldr	r2, [pc, #136]	; (15f8c <radio_tmr_start+0xd0>)
    p_reg->CC[cc_channel] = cc_value;
   15f02:	f8c3 4534 	str.w	r4, [r3, #1332]	; 0x534
		ticks_start--;
   15f06:	bf88      	it	hi
   15f08:	f101 31ff 	addhi.w	r1, r1, #4294967295	; 0xffffffff
   15f0c:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
    p_reg->EVTENSET = mask;
   15f10:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   15f14:	f8c2 1344 	str.w	r1, [r2, #836]	; 0x344
    p_reg->CH[(uint32_t) channel].EEP = eep;
   15f18:	491d      	ldr	r1, [pc, #116]	; (15f90 <radio_tmr_start+0xd4>)
   15f1a:	f502 72a4 	add.w	r2, r2, #328	; 0x148
	EVENT_TIMER->MODE = 0;
   15f1e:	3b0c      	subs	r3, #12
   15f20:	f8c1 2538 	str.w	r2, [r1, #1336]	; 0x538
    p_reg->CH[(uint32_t) channel].TEP = tep;
   15f24:	f8c1 353c 	str.w	r3, [r1, #1340]	; 0x53c
    p_reg->CHENSET = mask;
   15f28:	2320      	movs	r3, #32
   15f2a:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
	nrf_rtc_event_enable(NRF_RTC0, RTC_EVTENSET_COMPARE2_Msk);

	hal_event_timer_start_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_EVENT_TIMER_START_PPI));

	hal_radio_enable_on_tick_ppi_config_and_enable(trx);
   15f2e:	f7ff fd87 	bl	15a40 <hal_radio_enable_on_tick_ppi_config_and_enable>
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	last_pdu_end_us = 0U;

#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_CLEAR);
	SW_SWITCH_TIMER->MODE = 0;
   15f32:	4b18      	ldr	r3, [pc, #96]	; (15f94 <radio_tmr_start+0xd8>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   15f34:	4a18      	ldr	r2, [pc, #96]	; (15f98 <radio_tmr_start+0xdc>)
   15f36:	6015      	str	r5, [r2, #0]
   15f38:	f8c3 6504 	str.w	r6, [r3, #1284]	; 0x504
	SW_SWITCH_TIMER->PRESCALER = 4;
   15f3c:	f8c3 7510 	str.w	r7, [r3, #1296]	; 0x510
	SW_SWITCH_TIMER->BITMODE = 0; /* 16 bit */
   15f40:	f8c3 6508 	str.w	r6, [r3, #1288]	; 0x508
   15f44:	601d      	str	r5, [r3, #0]
    p_reg->CH[(uint32_t) channel].EEP = eep;
   15f46:	f5a3 43fd 	sub.w	r3, r3, #32384	; 0x7e80
   15f4a:	3b74      	subs	r3, #116	; 0x74
   15f4c:	f8c1 3548 	str.w	r3, [r1, #1352]	; 0x548
   15f50:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
   15f54:	3334      	adds	r3, #52	; 0x34
    p_reg->CH[(uint32_t) channel].TEP = tep;
   15f56:	f8c1 254c 	str.w	r2, [r1, #1356]	; 0x54c
    p_reg->CH[(uint32_t) channel].EEP = eep;
   15f5a:	f8c1 3550 	str.w	r3, [r1, #1360]	; 0x550
    p_reg->CH[(uint32_t) channel].TEP = tep;
   15f5e:	f503 33af 	add.w	r3, r3, #89600	; 0x15e00
   15f62:	33c4      	adds	r3, #196	; 0xc4
   15f64:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
    p_reg->CH[(uint32_t) channel].EEP = eep;
   15f68:	f5a3 33af 	sub.w	r3, r3, #89600	; 0x15e00
   15f6c:	3bc0      	subs	r3, #192	; 0xc0
   15f6e:	f8c1 3558 	str.w	r3, [r1, #1368]	; 0x558
    p_reg->CH[(uint32_t) channel].TEP = tep;
   15f72:	f503 33af 	add.w	r3, r3, #89600	; 0x15e00
   15f76:	33c8      	adds	r3, #200	; 0xc8
   15f78:	f8c1 355c 	str.w	r3, [r1, #1372]	; 0x55c
	 */
#endif /* CONFIG_BT_CTLR_PHY_CODED && CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder;
}
   15f7c:	4620      	mov	r0, r4
   15f7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   15f80:	7ff0bdbf 	.word	0x7ff0bdbf
   15f84:	4000800c 	.word	0x4000800c
   15f88:	000f4240 	.word	0x000f4240
   15f8c:	4000b000 	.word	0x4000b000
   15f90:	4001f000 	.word	0x4001f000
   15f94:	40009000 	.word	0x40009000
   15f98:	4000900c 	.word	0x4000900c

00015f9c <radio_tmr_start_get>:
    return p_reg->CC[ch];
   15f9c:	4b01      	ldr	r3, [pc, #4]	; (15fa4 <radio_tmr_start_get+0x8>)
   15f9e:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}

u32_t radio_tmr_start_get(void)
{
	return nrf_rtc_cc_get(NRF_RTC0, 2);
}
   15fa2:	4770      	bx	lr
   15fa4:	4000b000 	.word	0x4000b000

00015fa8 <radio_tmr_stop>:
   15fa8:	4a04      	ldr	r2, [pc, #16]	; (15fbc <radio_tmr_stop+0x14>)
   15faa:	2301      	movs	r3, #1
   15fac:	6013      	str	r3, [r2, #0]
   15fae:	60d3      	str	r3, [r2, #12]
   15fb0:	320c      	adds	r2, #12
   15fb2:	f602 72f4 	addw	r2, r2, #4084	; 0xff4
   15fb6:	6013      	str	r3, [r2, #0]
   15fb8:	60d3      	str	r3, [r2, #12]

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_STOP);
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_SHUTDOWN);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   15fba:	4770      	bx	lr
   15fbc:	40008004 	.word	0x40008004

00015fc0 <radio_tmr_hcto_configure>:
    p_reg->CC[cc_channel] = cc_value;
   15fc0:	4b04      	ldr	r3, [pc, #16]	; (15fd4 <radio_tmr_hcto_configure+0x14>)
   15fc2:	f8c3 0544 	str.w	r0, [r3, #1348]	; 0x544
    p_reg->CHENSET = mask;
   15fc6:	f503 33b8 	add.w	r3, r3, #94208	; 0x17000
   15fca:	f04f 6288 	mov.w	r2, #71303168	; 0x4400000
   15fce:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_disable_on_hcto_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI) |
		BIT(HAL_RADIO_DISABLE_ON_HCTO_PPI));
}
   15fd2:	4770      	bx	lr
   15fd4:	40008000 	.word	0x40008000

00015fd8 <radio_tmr_aa_capture>:
    p_reg->CH[(uint32_t) channel].EEP = eep;
   15fd8:	4b06      	ldr	r3, [pc, #24]	; (15ff4 <radio_tmr_aa_capture+0x1c>)
   15fda:	4a07      	ldr	r2, [pc, #28]	; (15ff8 <radio_tmr_aa_capture+0x20>)
   15fdc:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    p_reg->CH[(uint32_t) channel].TEP = tep;
   15fe0:	f502 42de 	add.w	r2, r2, #28416	; 0x6f00
   15fe4:	3240      	adds	r2, #64	; 0x40
   15fe6:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    p_reg->CHENSET = mask;
   15fea:	4a04      	ldr	r2, [pc, #16]	; (15ffc <radio_tmr_aa_capture+0x24>)
   15fec:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_ready_time_capture_ppi_config();
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_READY_TIME_CAPTURE_PPI) |
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI));
}
   15ff0:	4770      	bx	lr
   15ff2:	bf00      	nop
   15ff4:	4001f000 	.word	0x4001f000
   15ff8:	40001100 	.word	0x40001100
   15ffc:	04000040 	.word	0x04000040

00016000 <radio_tmr_aa_get>:

u32_t radio_tmr_aa_get(void)
{
	return EVENT_TIMER->CC[1];
   16000:	4b01      	ldr	r3, [pc, #4]	; (16008 <radio_tmr_aa_get+0x8>)
   16002:	f8d3 0544 	ldr.w	r0, [r3, #1348]	; 0x544
}
   16006:	4770      	bx	lr
   16008:	40008000 	.word	0x40008000

0001600c <radio_tmr_aa_save>:

static u32_t radio_tmr_aa;

void radio_tmr_aa_save(u32_t aa)
{
	radio_tmr_aa = aa;
   1600c:	4b01      	ldr	r3, [pc, #4]	; (16014 <radio_tmr_aa_save+0x8>)
   1600e:	6018      	str	r0, [r3, #0]
}
   16010:	4770      	bx	lr
   16012:	bf00      	nop
   16014:	20001830 	.word	0x20001830

00016018 <radio_tmr_aa_restore>:

u32_t radio_tmr_aa_restore(void)
{
	/* NOTE: we dont need to restore for now, but return the saved value. */
	return radio_tmr_aa;
}
   16018:	4b01      	ldr	r3, [pc, #4]	; (16020 <radio_tmr_aa_restore+0x8>)
   1601a:	6818      	ldr	r0, [r3, #0]
   1601c:	4770      	bx	lr
   1601e:	bf00      	nop
   16020:	20001830 	.word	0x20001830

00016024 <radio_tmr_ready_get>:

u32_t radio_tmr_ready_get(void)
{
	return EVENT_TIMER->CC[0];
   16024:	4b01      	ldr	r3, [pc, #4]	; (1602c <radio_tmr_ready_get+0x8>)
   16026:	f8d3 0540 	ldr.w	r0, [r3, #1344]	; 0x540
}
   1602a:	4770      	bx	lr
   1602c:	40008000 	.word	0x40008000

00016030 <radio_tmr_end_capture>:
   16030:	4b02      	ldr	r3, [pc, #8]	; (1603c <radio_tmr_end_capture+0xc>)
   16032:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
   16036:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504

void radio_tmr_end_capture(void)
{
	hal_radio_end_time_capture_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_RADIO_END_TIME_CAPTURE_PPI));
}
   1603a:	4770      	bx	lr
   1603c:	4001f000 	.word	0x4001f000

00016040 <radio_tmr_end_get>:
u32_t radio_tmr_end_get(void)
{
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	return last_pdu_end_us;
#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	return EVENT_TIMER->CC[2];
   16040:	4b01      	ldr	r3, [pc, #4]	; (16048 <radio_tmr_end_get+0x8>)
   16042:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
#endif /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
}
   16046:	4770      	bx	lr
   16048:	40008000 	.word	0x40008000

0001604c <radio_tmr_tifs_base_get>:
   1604c:	4b01      	ldr	r3, [pc, #4]	; (16054 <radio_tmr_tifs_base_get+0x8>)
   1604e:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
   16052:	4770      	bx	lr
   16054:	40008000 	.word	0x40008000

00016058 <radio_ccm_rx_pkt_set>:
void *radio_ccm_rx_pkt_set(struct ccm *ccm, u8_t phy, void *pkt)
{

	u32_t mode;

	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   16058:	4b13      	ldr	r3, [pc, #76]	; (160a8 <radio_ccm_rx_pkt_set+0x50>)
{
   1605a:	b570      	push	{r4, r5, r6, lr}
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   1605c:	2400      	movs	r4, #0
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
   1605e:	2502      	movs	r5, #2
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   16060:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
			 CCM_MODE_DATARATE_Pos) &
			CCM_MODE_DATARATE_Msk;
		break;

	case BIT(1):
		mode |= (CCM_MODE_DATARATE_2Mbit <<
   16064:	4e11      	ldr	r6, [pc, #68]	; (160ac <radio_ccm_rx_pkt_set+0x54>)
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
   16066:	f8c3 5500 	str.w	r5, [r3, #1280]	; 0x500
		mode |= (CCM_MODE_DATARATE_2Mbit <<
   1606a:	4d11      	ldr	r5, [pc, #68]	; (160b0 <radio_ccm_rx_pkt_set+0x58>)
   1606c:	2902      	cmp	r1, #2
   1606e:	bf14      	ite	ne
   16070:	4629      	movne	r1, r5
   16072:	4631      	moveq	r1, r6
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	}
#endif /* !CONFIG_SOC_SERIES_NRF51X */

	NRF_CCM->MODE = mode;
   16074:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
	NRF_CCM->CNFPTR = (u32_t)ccm;
   16078:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
	NRF_CCM->INPTR = (u32_t)_pkt_scratch;
   1607c:	480d      	ldr	r0, [pc, #52]	; (160b4 <radio_ccm_rx_pkt_set+0x5c>)
   1607e:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
	NRF_CCM->OUTPTR = (u32_t)pkt;
   16082:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
   16086:	4a0c      	ldr	r2, [pc, #48]	; (160b8 <radio_ccm_rx_pkt_set+0x60>)
   16088:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
   1608c:	4a0b      	ldr	r2, [pc, #44]	; (160bc <radio_ccm_rx_pkt_set+0x64>)
	NRF_CCM->SHORTS = 0;
   1608e:	f8c3 4200 	str.w	r4, [r3, #512]	; 0x200
   16092:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
	NRF_CCM->EVENTS_ENDCRYPT = 0;
   16096:	f8c3 4104 	str.w	r4, [r3, #260]	; 0x104
	NRF_CCM->EVENTS_ERROR = 0;
   1609a:	f8c3 4108 	str.w	r4, [r3, #264]	; 0x108
   1609e:	f8c2 1504 	str.w	r1, [r2, #1284]	; 0x504
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ccm_task_trigger(NRF_CCM_Type * p_reg,
                                            nrf_ccm_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   160a2:	2201      	movs	r2, #1
   160a4:	601a      	str	r2, [r3, #0]
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_TRIGGER_CRYPT_PPI));

	nrf_ccm_task_trigger(NRF_CCM, NRF_CCM_TASK_KSGEN);

	return _pkt_scratch;
}
   160a6:	bd70      	pop	{r4, r5, r6, pc}
   160a8:	4000f000 	.word	0x4000f000
   160ac:	01010001 	.word	0x01010001
   160b0:	01000001 	.word	0x01000001
   160b4:	20001724 	.word	0x20001724
   160b8:	20001614 	.word	0x20001614
   160bc:	4001f000 	.word	0x4001f000

000160c0 <radio_ccm_tx_pkt_set>:

void *radio_ccm_tx_pkt_set(struct ccm *ccm, void *pkt)
{
   160c0:	b510      	push	{r4, lr}
	u32_t mode;

	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   160c2:	4b0e      	ldr	r3, [pc, #56]	; (160fc <radio_ccm_tx_pkt_set+0x3c>)
   160c4:	2200      	movs	r2, #0
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
   160c6:	2402      	movs	r4, #2
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   160c8:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
   160cc:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
	 * radio Tx on any PHY.
	 */
	mode |= (CCM_MODE_DATARATE_2Mbit << CCM_MODE_DATARATE_Pos) &
		CCM_MODE_DATARATE_Msk;
#endif
	NRF_CCM->MODE = mode;
   160d0:	4c0b      	ldr	r4, [pc, #44]	; (16100 <radio_ccm_tx_pkt_set+0x40>)
   160d2:	f8c3 4504 	str.w	r4, [r3, #1284]	; 0x504
	NRF_CCM->CNFPTR = (u32_t)ccm;
   160d6:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
	NRF_CCM->INPTR = (u32_t)pkt;
   160da:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
	NRF_CCM->OUTPTR = (u32_t)_pkt_scratch;
   160de:	4809      	ldr	r0, [pc, #36]	; (16104 <radio_ccm_tx_pkt_set+0x44>)
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
   160e0:	4909      	ldr	r1, [pc, #36]	; (16108 <radio_ccm_tx_pkt_set+0x48>)
	NRF_CCM->OUTPTR = (u32_t)_pkt_scratch;
   160e2:	f8c3 0510 	str.w	r0, [r3, #1296]	; 0x510
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
   160e6:	f8c3 1514 	str.w	r1, [r3, #1300]	; 0x514
	NRF_CCM->SHORTS = CCM_SHORTS_ENDKSGEN_CRYPT_Msk;
   160ea:	2101      	movs	r1, #1
   160ec:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
	NRF_CCM->EVENTS_ENDCRYPT = 0;
   160f0:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	NRF_CCM->EVENTS_ERROR = 0;
   160f4:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   160f8:	6019      	str	r1, [r3, #0]

	nrf_ccm_task_trigger(NRF_CCM, NRF_CCM_TASK_KSGEN);

	return _pkt_scratch;
}
   160fa:	bd10      	pop	{r4, pc}
   160fc:	4000f000 	.word	0x4000f000
   16100:	01010000 	.word	0x01010000
   16104:	20001724 	.word	0x20001724
   16108:	20001614 	.word	0x20001614

0001610c <radio_ccm_is_done>:
    return ((uint32_t)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE void nrf_ccm_int_enable(NRF_CCM_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   1610c:	4b0c      	ldr	r3, [pc, #48]	; (16140 <radio_ccm_is_done+0x34>)
   1610e:	2202      	movs	r2, #2
   16110:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

u32_t radio_ccm_is_done(void)
{
	nrf_ccm_int_enable(NRF_CCM, CCM_INTENSET_ENDCRYPT_Msk);
	while (NRF_CCM->EVENTS_ENDCRYPT == 0) {
   16114:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
   16118:	b16a      	cbz	r2, 16136 <radio_ccm_is_done+0x2a>
}

NRF_STATIC_INLINE void nrf_ccm_int_disable(NRF_CCM_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
   1611a:	2202      	movs	r2, #2
   1611c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   16120:	4a08      	ldr	r2, [pc, #32]	; (16144 <radio_ccm_is_done+0x38>)
   16122:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   16126:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
		__WFE();
	}
	nrf_ccm_int_disable(NRF_CCM, CCM_INTENCLR_ENDCRYPT_Msk);
	NVIC_ClearPendingIRQ(nrfx_get_irq_number(NRF_CCM));

	return (NRF_CCM->EVENTS_ERROR == 0);
   1612a:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
}
   1612e:	fab0 f080 	clz	r0, r0
   16132:	0940      	lsrs	r0, r0, #5
   16134:	4770      	bx	lr
		__WFE();
   16136:	bf20      	wfe
		__SEV();
   16138:	bf40      	sev
		__WFE();
   1613a:	bf20      	wfe
   1613c:	e7ea      	b.n	16114 <radio_ccm_is_done+0x8>
   1613e:	bf00      	nop
   16140:	4000f000 	.word	0x4000f000
   16144:	e000e100 	.word	0xe000e100

00016148 <radio_ccm_mic_is_valid>:

u32_t radio_ccm_mic_is_valid(void)
{
	return (NRF_CCM->MICSTATUS != 0);
   16148:	4b03      	ldr	r3, [pc, #12]	; (16158 <radio_ccm_mic_is_valid+0x10>)
   1614a:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
   1614e:	3000      	adds	r0, #0
   16150:	bf18      	it	ne
   16152:	2001      	movne	r0, #1
   16154:	4770      	bx	lr
   16156:	bf00      	nop
   16158:	4000f000 	.word	0x4000f000

0001615c <radio_ar_configure>:

static u8_t MALIGN(4) _aar_scratch[3];

void radio_ar_configure(u32_t nirk, void *irk)
{
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
   1615c:	4b11      	ldr	r3, [pc, #68]	; (161a4 <radio_ar_configure+0x48>)
{
   1615e:	b510      	push	{r4, lr}
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
   16160:	2203      	movs	r2, #3
			  AAR_ENABLE_ENABLE_Msk;
	NRF_AAR->NIRK = nirk;
	NRF_AAR->IRKPTR = (u32_t)irk;
	NRF_AAR->ADDRPTR = (u32_t)NRF_RADIO->PACKETPTR - 1;
   16162:	4c11      	ldr	r4, [pc, #68]	; (161a8 <radio_ar_configure+0x4c>)
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
   16164:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
	NRF_AAR->NIRK = nirk;
   16168:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
	NRF_AAR->IRKPTR = (u32_t)irk;
   1616c:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
	NRF_AAR->ADDRPTR = (u32_t)NRF_RADIO->PACKETPTR - 1;
   16170:	f8d4 2504 	ldr.w	r2, [r4, #1284]	; 0x504
   16174:	3a01      	subs	r2, #1
   16176:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_AAR->SCRATCHPTR = (u32_t)&_aar_scratch[0];

	NRF_AAR->EVENTS_END = 0;
   1617a:	2100      	movs	r1, #0
	NRF_AAR->SCRATCHPTR = (u32_t)&_aar_scratch[0];
   1617c:	4a0b      	ldr	r2, [pc, #44]	; (161ac <radio_ar_configure+0x50>)
   1617e:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
	NRF_AAR->EVENTS_RESOLVED = 0;
	NRF_AAR->EVENTS_NOTRESOLVED = 0;

	radio_bc_configure(64);
   16182:	2040      	movs	r0, #64	; 0x40
	NRF_AAR->EVENTS_END = 0;
   16184:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
	NRF_AAR->EVENTS_RESOLVED = 0;
   16188:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
	NRF_AAR->EVENTS_NOTRESOLVED = 0;
   1618c:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108
	radio_bc_configure(64);
   16190:	f7ff fe6c 	bl	15e6c <radio_bc_configure>
   16194:	4b06      	ldr	r3, [pc, #24]	; (161b0 <radio_ar_configure+0x54>)
	NRF_RADIO->EVENTS_BCMATCH = 0;
   16196:	f8c4 1128 	str.w	r1, [r4, #296]	; 0x128
   1619a:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   1619e:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	radio_bc_status_reset();

	hal_trigger_aar_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_TRIGGER_AAR_PPI));
}
   161a2:	bd10      	pop	{r4, pc}
   161a4:	4000f000 	.word	0x4000f000
   161a8:	40001000 	.word	0x40001000
   161ac:	20001610 	.word	0x20001610
   161b0:	4001f000 	.word	0x4001f000

000161b4 <radio_ar_match_get>:

u32_t radio_ar_match_get(void)
{
	return NRF_AAR->STATUS;
   161b4:	4b01      	ldr	r3, [pc, #4]	; (161bc <radio_ar_match_get+0x8>)
   161b6:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
   161ba:	4770      	bx	lr
   161bc:	4000f000 	.word	0x4000f000

000161c0 <radio_ar_status_reset>:
	NRF_RADIO->EVENTS_BCMATCH = 0;
   161c0:	4a04      	ldr	r2, [pc, #16]	; (161d4 <radio_ar_status_reset+0x14>)
   161c2:	2300      	movs	r3, #0
   161c4:	f8c2 3128 	str.w	r3, [r2, #296]	; 0x128

void radio_ar_status_reset(void)
{
	radio_bc_status_reset();

	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Disabled << AAR_ENABLE_ENABLE_Pos) &
   161c8:	f502 4260 	add.w	r2, r2, #57344	; 0xe000
   161cc:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
			  AAR_ENABLE_ENABLE_Msk;
}
   161d0:	4770      	bx	lr
   161d2:	bf00      	nop
   161d4:	40001000 	.word	0x40001000

000161d8 <radio_ar_has_match>:
	return (NRF_RADIO->EVENTS_BCMATCH != 0);
   161d8:	4b08      	ldr	r3, [pc, #32]	; (161fc <radio_ar_has_match+0x24>)
   161da:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128

u32_t radio_ar_has_match(void)
{
	return (radio_bc_has_match() &&
		NRF_AAR->EVENTS_END &&
		NRF_AAR->EVENTS_RESOLVED &&
   161de:	b160      	cbz	r0, 161fa <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_END &&
   161e0:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
   161e4:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
	return (radio_bc_has_match() &&
   161e8:	b138      	cbz	r0, 161fa <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_RESOLVED &&
   161ea:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
		NRF_AAR->EVENTS_END &&
   161ee:	b120      	cbz	r0, 161fa <radio_ar_has_match+0x22>
		!NRF_AAR->EVENTS_NOTRESOLVED);
   161f0:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
		NRF_AAR->EVENTS_RESOLVED &&
   161f4:	fab0 f080 	clz	r0, r0
   161f8:	0940      	lsrs	r0, r0, #5
}
   161fa:	4770      	bx	lr
   161fc:	40001000 	.word	0x40001000

00016200 <mayfly_enable_cb>:

void mayfly_enable_cb(u8_t caller_id, u8_t callee_id, u8_t enable)
{
	(void)caller_id;

	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
   16200:	2902      	cmp	r1, #2
{
   16202:	b510      	push	{r4, lr}
   16204:	4614      	mov	r4, r2
	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
   16206:	d00b      	beq.n	16220 <mayfly_enable_cb+0x20>
   16208:	2325      	movs	r3, #37	; 0x25
   1620a:	4a0a      	ldr	r2, [pc, #40]	; (16234 <mayfly_enable_cb+0x34>)
   1620c:	490a      	ldr	r1, [pc, #40]	; (16238 <mayfly_enable_cb+0x38>)
   1620e:	480b      	ldr	r0, [pc, #44]	; (1623c <mayfly_enable_cb+0x3c>)
   16210:	f003 f8b0 	bl	19374 <printk>
   16214:	4040      	eors	r0, r0
   16216:	f380 8811 	msr	BASEPRI, r0
   1621a:	f04f 0003 	mov.w	r0, #3
   1621e:	df02      	svc	2

	if (enable) {
		irq_enable(HAL_SWI_JOB_IRQ);
   16220:	200b      	movs	r0, #11
	if (enable) {
   16222:	b11c      	cbz	r4, 1622c <mayfly_enable_cb+0x2c>
	} else {
		irq_disable(HAL_SWI_JOB_IRQ);
	}
}
   16224:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_enable(HAL_SWI_JOB_IRQ);
   16228:	f7ee b896 	b.w	4358 <arch_irq_enable>
}
   1622c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_disable(HAL_SWI_JOB_IRQ);
   16230:	f7ee b8a2 	b.w	4378 <arch_irq_disable>
   16234:	00022496 	.word	0x00022496
   16238:	000224dd 	.word	0x000224dd
   1623c:	00020aa4 	.word	0x00020aa4

00016240 <mayfly_is_enabled>:

u32_t mayfly_is_enabled(u8_t caller_id, u8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
   16240:	2901      	cmp	r1, #1
{
   16242:	b508      	push	{r3, lr}
	switch (callee_id) {
   16244:	d015      	beq.n	16272 <mayfly_is_enabled+0x32>
   16246:	b179      	cbz	r1, 16268 <mayfly_is_enabled+0x28>
   16248:	2902      	cmp	r1, #2
   1624a:	d012      	beq.n	16272 <mayfly_is_enabled+0x32>

	case MAYFLY_CALL_ID_JOB:
		return irq_is_enabled(HAL_SWI_JOB_IRQ);

	default:
		LL_ASSERT(0);
   1624c:	233f      	movs	r3, #63	; 0x3f
   1624e:	4a0a      	ldr	r2, [pc, #40]	; (16278 <mayfly_is_enabled+0x38>)
   16250:	490a      	ldr	r1, [pc, #40]	; (1627c <mayfly_is_enabled+0x3c>)
   16252:	480b      	ldr	r0, [pc, #44]	; (16280 <mayfly_is_enabled+0x40>)
   16254:	f003 f88e 	bl	19374 <printk>
   16258:	4040      	eors	r0, r0
   1625a:	f380 8811 	msr	BASEPRI, r0
   1625e:	f04f 0003 	mov.w	r0, #3
   16262:	df02      	svc	2
		break;
	}

	return 0;
}
   16264:	2000      	movs	r0, #0
   16266:	bd08      	pop	{r3, pc}
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);
   16268:	2018      	movs	r0, #24
}
   1626a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		return irq_is_enabled(HAL_SWI_WORKER_IRQ);
   1626e:	f7ee b897 	b.w	43a0 <arch_irq_is_enabled>
   16272:	200b      	movs	r0, #11
   16274:	e7f9      	b.n	1626a <mayfly_is_enabled+0x2a>
   16276:	bf00      	nop
   16278:	00022496 	.word	0x00022496
   1627c:	00022577 	.word	0x00022577
   16280:	00020aa4 	.word	0x00020aa4

00016284 <mayfly_pend>:

void mayfly_pend(u8_t caller_id, u8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
   16284:	2901      	cmp	r1, #1
{
   16286:	b508      	push	{r3, lr}
	switch (callee_id) {
   16288:	d015      	beq.n	162b6 <mayfly_pend+0x32>
   1628a:	b171      	cbz	r1, 162aa <mayfly_pend+0x26>
   1628c:	2902      	cmp	r1, #2
   1628e:	d012      	beq.n	162b6 <mayfly_pend+0x32>
	case MAYFLY_CALL_ID_JOB:
		hal_swi_job_pend();
		break;

	default:
		LL_ASSERT(0);
   16290:	237b      	movs	r3, #123	; 0x7b
   16292:	4a0b      	ldr	r2, [pc, #44]	; (162c0 <mayfly_pend+0x3c>)
   16294:	490b      	ldr	r1, [pc, #44]	; (162c4 <mayfly_pend+0x40>)
   16296:	480c      	ldr	r0, [pc, #48]	; (162c8 <mayfly_pend+0x44>)
   16298:	f003 f86c 	bl	19374 <printk>
   1629c:	4040      	eors	r0, r0
   1629e:	f380 8811 	msr	BASEPRI, r0
   162a2:	f04f 0003 	mov.w	r0, #3
   162a6:	df02      	svc	2
		break;
	}
}
   162a8:	e004      	b.n	162b4 <mayfly_pend+0x30>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   162aa:	4b08      	ldr	r3, [pc, #32]	; (162cc <mayfly_pend+0x48>)
   162ac:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   162b0:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   162b4:	bd08      	pop	{r3, pc}
   162b6:	4b05      	ldr	r3, [pc, #20]	; (162cc <mayfly_pend+0x48>)
   162b8:	f44f 6200 	mov.w	r2, #2048	; 0x800
   162bc:	e7f8      	b.n	162b0 <mayfly_pend+0x2c>
   162be:	bf00      	nop
   162c0:	00022496 	.word	0x00022496
   162c4:	00022577 	.word	0x00022577
   162c8:	00020aa4 	.word	0x00020aa4
   162cc:	e000e100 	.word	0xe000e100

000162d0 <hal_ticker_instance0_caller_id_get>:

u8_t hal_ticker_instance0_caller_id_get(u8_t user_id)
{
	u8_t caller_id;

	LL_ASSERT(user_id < sizeof(caller_id_lut));
   162d0:	2803      	cmp	r0, #3
{
   162d2:	b510      	push	{r4, lr}
   162d4:	4604      	mov	r4, r0
	LL_ASSERT(user_id < sizeof(caller_id_lut));
   162d6:	d90b      	bls.n	162f0 <hal_ticker_instance0_caller_id_get+0x20>
   162d8:	2338      	movs	r3, #56	; 0x38
   162da:	4a0e      	ldr	r2, [pc, #56]	; (16314 <hal_ticker_instance0_caller_id_get+0x44>)
   162dc:	490e      	ldr	r1, [pc, #56]	; (16318 <hal_ticker_instance0_caller_id_get+0x48>)
   162de:	480f      	ldr	r0, [pc, #60]	; (1631c <hal_ticker_instance0_caller_id_get+0x4c>)
   162e0:	f003 f848 	bl	19374 <printk>
   162e4:	4040      	eors	r0, r0
   162e6:	f380 8811 	msr	BASEPRI, r0
   162ea:	f04f 0003 	mov.w	r0, #3
   162ee:	df02      	svc	2

	caller_id = caller_id_lut[user_id];
   162f0:	4b0b      	ldr	r3, [pc, #44]	; (16320 <hal_ticker_instance0_caller_id_get+0x50>)
   162f2:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
   162f4:	b95c      	cbnz	r4, 1630e <hal_ticker_instance0_caller_id_get+0x3e>
   162f6:	233b      	movs	r3, #59	; 0x3b
   162f8:	4a06      	ldr	r2, [pc, #24]	; (16314 <hal_ticker_instance0_caller_id_get+0x44>)
   162fa:	490a      	ldr	r1, [pc, #40]	; (16324 <hal_ticker_instance0_caller_id_get+0x54>)
   162fc:	4807      	ldr	r0, [pc, #28]	; (1631c <hal_ticker_instance0_caller_id_get+0x4c>)
   162fe:	f003 f839 	bl	19374 <printk>
   16302:	4040      	eors	r0, r0
   16304:	f380 8811 	msr	BASEPRI, r0
   16308:	f04f 0003 	mov.w	r0, #3
   1630c:	df02      	svc	2

	return caller_id;
}
   1630e:	4620      	mov	r0, r4
   16310:	bd10      	pop	{r4, pc}
   16312:	bf00      	nop
   16314:	00022503 	.word	0x00022503
   16318:	0002254a 	.word	0x0002254a
   1631c:	00020aa4 	.word	0x00020aa4
   16320:	000224ff 	.word	0x000224ff
   16324:	0002256a 	.word	0x0002256a

00016328 <hal_ticker_instance0_sched>:
{
	/* return value not checked as we allow multiple calls to schedule
	 * before being actually needing the work to complete before new
	 * schedule.
	 */
	switch (caller_id) {
   16328:	3801      	subs	r0, #1
{
   1632a:	b510      	push	{r4, lr}
   1632c:	461c      	mov	r4, r3
	switch (caller_id) {
   1632e:	2804      	cmp	r0, #4
   16330:	d845      	bhi.n	163be <hal_ticker_instance0_sched+0x96>
   16332:	e8df f000 	tbb	[pc, r0]
   16336:	1a03      	.short	0x1a03
   16338:	2c23      	.short	0x2c23
   1633a:	3b          	.byte	0x3b
   1633b:	00          	.byte	0x00
#if defined(CONFIG_BT_LL_SW_SPLIT)
	case TICKER_CALL_ID_ISR:
		switch (callee_id) {
   1633c:	2904      	cmp	r1, #4
   1633e:	d107      	bne.n	16350 <hal_ticker_instance0_sched+0x28>
		{
			static memq_link_t link;
			static struct mayfly m = {0, 0, &link, NULL,
						  ticker_job};

			m.param = instance;
   16340:	4b20      	ldr	r3, [pc, #128]	; (163c4 <hal_ticker_instance0_sched+0x9c>)

			/* TODO: scheduler lock, if preemptive threads used */
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
   16342:	2102      	movs	r1, #2
			m.param = instance;
   16344:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
   16346:	2000      	movs	r0, #0

	default:
		LL_ASSERT(0);
		break;
	}
}
   16348:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
   1634c:	f7f7 bbc6 	b.w	dadc <mayfly_enqueue>
			LL_ASSERT(0);
   16350:	235c      	movs	r3, #92	; 0x5c
		LL_ASSERT(0);
   16352:	4a1d      	ldr	r2, [pc, #116]	; (163c8 <hal_ticker_instance0_sched+0xa0>)
   16354:	491d      	ldr	r1, [pc, #116]	; (163cc <hal_ticker_instance0_sched+0xa4>)
   16356:	481e      	ldr	r0, [pc, #120]	; (163d0 <hal_ticker_instance0_sched+0xa8>)
   16358:	f003 f80c 	bl	19374 <printk>
   1635c:	4040      	eors	r0, r0
   1635e:	f380 8811 	msr	BASEPRI, r0
   16362:	f04f 0003 	mov.w	r0, #3
   16366:	df02      	svc	2
}
   16368:	bd10      	pop	{r4, pc}
		switch (callee_id) {
   1636a:	2903      	cmp	r1, #3
   1636c:	d104      	bne.n	16378 <hal_ticker_instance0_sched+0x50>
			m.param = instance;
   1636e:	4b19      	ldr	r3, [pc, #100]	; (163d4 <hal_ticker_instance0_sched+0xac>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
   16370:	2101      	movs	r1, #1
			m.param = instance;
   16372:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   16374:	4608      	mov	r0, r1
   16376:	e7e7      	b.n	16348 <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
   16378:	2374      	movs	r3, #116	; 0x74
   1637a:	e7ea      	b.n	16352 <hal_ticker_instance0_sched+0x2a>
		switch (callee_id) {
   1637c:	2904      	cmp	r1, #4
   1637e:	d104      	bne.n	1638a <hal_ticker_instance0_sched+0x62>
			m.param = instance;
   16380:	4b15      	ldr	r3, [pc, #84]	; (163d8 <hal_ticker_instance0_sched+0xb0>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
   16382:	2102      	movs	r1, #2
			m.param = instance;
   16384:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
   16386:	2001      	movs	r0, #1
   16388:	e7de      	b.n	16348 <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
   1638a:	238b      	movs	r3, #139	; 0x8b
   1638c:	e7e1      	b.n	16352 <hal_ticker_instance0_sched+0x2a>
		switch (callee_id) {
   1638e:	2903      	cmp	r1, #3
   16390:	d003      	beq.n	1639a <hal_ticker_instance0_sched+0x72>
   16392:	2904      	cmp	r1, #4
   16394:	d006      	beq.n	163a4 <hal_ticker_instance0_sched+0x7c>
			LL_ASSERT(0);
   16396:	23b1      	movs	r3, #177	; 0xb1
   16398:	e7db      	b.n	16352 <hal_ticker_instance0_sched+0x2a>
			m.param = instance;
   1639a:	4b10      	ldr	r3, [pc, #64]	; (163dc <hal_ticker_instance0_sched+0xb4>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   1639c:	2101      	movs	r1, #1
			m.param = instance;
   1639e:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   163a0:	2002      	movs	r0, #2
   163a2:	e7d1      	b.n	16348 <hal_ticker_instance0_sched+0x20>
			m.param = instance;
   163a4:	4b0e      	ldr	r3, [pc, #56]	; (163e0 <hal_ticker_instance0_sched+0xb8>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   163a6:	2102      	movs	r1, #2
			m.param = instance;
   163a8:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   163aa:	e7e3      	b.n	16374 <hal_ticker_instance0_sched+0x4c>
		switch (callee_id) {
   163ac:	2904      	cmp	r1, #4
   163ae:	d104      	bne.n	163ba <hal_ticker_instance0_sched+0x92>
			m.param = instance;
   163b0:	4b0c      	ldr	r3, [pc, #48]	; (163e4 <hal_ticker_instance0_sched+0xbc>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
   163b2:	2102      	movs	r1, #2
			m.param = instance;
   163b4:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
   163b6:	2003      	movs	r0, #3
   163b8:	e7c6      	b.n	16348 <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
   163ba:	23c9      	movs	r3, #201	; 0xc9
   163bc:	e7c9      	b.n	16352 <hal_ticker_instance0_sched+0x2a>
		LL_ASSERT(0);
   163be:	23cf      	movs	r3, #207	; 0xcf
   163c0:	e7c7      	b.n	16352 <hal_ticker_instance0_sched+0x2a>
   163c2:	bf00      	nop
   163c4:	20005978 	.word	0x20005978
   163c8:	00022503 	.word	0x00022503
   163cc:	00022577 	.word	0x00022577
   163d0:	00020aa4 	.word	0x00020aa4
   163d4:	20005988 	.word	0x20005988
   163d8:	20005998 	.word	0x20005998
   163dc:	200059a8 	.word	0x200059a8
   163e0:	200059b8 	.word	0x200059b8
   163e4:	200059c8 	.word	0x200059c8

000163e8 <net_buf_pool_get>:
extern struct net_buf_pool _net_buf_pool_list[];

struct net_buf_pool *net_buf_pool_get(int id)
{
	return &_net_buf_pool_list[id];
}
   163e8:	4b01      	ldr	r3, [pc, #4]	; (163f0 <net_buf_pool_get+0x8>)
   163ea:	eb03 1040 	add.w	r0, r3, r0, lsl #5
   163ee:	4770      	bx	lr
   163f0:	20005ca8 	.word	0x20005ca8

000163f4 <net_buf_id>:
	return pool - _net_buf_pool_list;
}

int net_buf_id(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   163f4:	7982      	ldrb	r2, [r0, #6]

	return buf - pool->__bufs;
   163f6:	4b04      	ldr	r3, [pc, #16]	; (16408 <net_buf_id+0x14>)
   163f8:	eb03 1342 	add.w	r3, r3, r2, lsl #5
   163fc:	69db      	ldr	r3, [r3, #28]
   163fe:	1ac0      	subs	r0, r0, r3
}
   16400:	4b02      	ldr	r3, [pc, #8]	; (1640c <net_buf_id+0x18>)
	return buf - pool->__bufs;
   16402:	10c0      	asrs	r0, r0, #3
}
   16404:	4358      	muls	r0, r3
   16406:	4770      	bx	lr
   16408:	20005ca8 	.word	0x20005ca8
   1640c:	aaaaaaab 	.word	0xaaaaaaab

00016410 <fixed_data_alloc>:
	.ref   = generic_data_ref,
	.unref = mem_pool_data_unref,
};

static u8_t *fixed_data_alloc(struct net_buf *buf, size_t *size, s32_t timeout)
{
   16410:	b510      	push	{r4, lr}
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   16412:	4b09      	ldr	r3, [pc, #36]	; (16438 <fixed_data_alloc+0x28>)
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   16414:	7982      	ldrb	r2, [r0, #6]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   16416:	eb03 1342 	add.w	r3, r3, r2, lsl #5

	*size = MIN(fixed->data_size, *size);
   1641a:	680a      	ldr	r2, [r1, #0]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   1641c:	699b      	ldr	r3, [r3, #24]
   1641e:	685c      	ldr	r4, [r3, #4]
	*size = MIN(fixed->data_size, *size);
   16420:	6823      	ldr	r3, [r4, #0]
   16422:	429a      	cmp	r2, r3
   16424:	bf94      	ite	ls
   16426:	600a      	strls	r2, [r1, #0]
   16428:	600b      	strhi	r3, [r1, #0]

	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
   1642a:	f7ff ffe3 	bl	163f4 <net_buf_id>
   1642e:	e9d4 2300 	ldrd	r2, r3, [r4]
}
   16432:	fb02 3000 	mla	r0, r2, r0, r3
   16436:	bd10      	pop	{r4, pc}
   16438:	20005ca8 	.word	0x20005ca8

0001643c <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  s32_t timeout)
#endif
{
   1643c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   16440:	4605      	mov	r5, r0
   16442:	9101      	str	r1, [sp, #4]
   16444:	4616      	mov	r6, r2
	u32_t alloc_start = k_uptime_get_32();
   16446:	f007 fbc9 	bl	1dbdc <k_uptime_get_32>
   1644a:	4607      	mov	r7, r0
	__asm__ volatile(
   1644c:	f04f 0320 	mov.w	r3, #32
   16450:	f3ef 8811 	mrs	r8, BASEPRI
   16454:	f383 8811 	msr	BASEPRI, r3
   16458:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
   1645c:	8a6b      	ldrh	r3, [r5, #18]
   1645e:	2b00      	cmp	r3, #0
   16460:	d041      	beq.n	164e6 <net_buf_alloc_len+0xaa>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
   16462:	8a2a      	ldrh	r2, [r5, #16]
   16464:	429a      	cmp	r2, r3
   16466:	d92c      	bls.n	164c2 <net_buf_alloc_len+0x86>
	return z_impl_k_queue_get(queue, timeout);
   16468:	2100      	movs	r1, #0
   1646a:	4628      	mov	r0, r5
   1646c:	f007 ff97 	bl	1e39e <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
   16470:	4604      	mov	r4, r0
   16472:	b330      	cbz	r0, 164c2 <net_buf_alloc_len+0x86>
	__asm__ volatile(
   16474:	f388 8811 	msr	BASEPRI, r8
   16478:	f3bf 8f6f 	isb	sy
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
   1647c:	9b01      	ldr	r3, [sp, #4]
   1647e:	2b00      	cmp	r3, #0
   16480:	d040      	beq.n	16504 <net_buf_alloc_len+0xc8>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (timeout != K_NO_WAIT && timeout != K_FOREVER) {
   16482:	1c73      	adds	r3, r6, #1
   16484:	2b01      	cmp	r3, #1
   16486:	d906      	bls.n	16496 <net_buf_alloc_len+0x5a>
			u32_t diff = k_uptime_get_32() - alloc_start;
   16488:	f007 fba8 	bl	1dbdc <k_uptime_get_32>
   1648c:	1bc0      	subs	r0, r0, r7

			timeout -= MIN(timeout, diff);
   1648e:	42b0      	cmp	r0, r6
   16490:	bf94      	ite	ls
   16492:	1a36      	subls	r6, r6, r0
   16494:	1bb6      	subhi	r6, r6, r6
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   16496:	79a3      	ldrb	r3, [r4, #6]
	return pool->alloc->cb->alloc(buf, size, timeout);
   16498:	4f20      	ldr	r7, [pc, #128]	; (1651c <net_buf_alloc_len+0xe0>)
   1649a:	eb07 1343 	add.w	r3, r7, r3, lsl #5
   1649e:	4632      	mov	r2, r6
   164a0:	699b      	ldr	r3, [r3, #24]
   164a2:	681b      	ldr	r3, [r3, #0]
   164a4:	a901      	add	r1, sp, #4
   164a6:	681b      	ldr	r3, [r3, #0]
   164a8:	4620      	mov	r0, r4
   164aa:	4798      	blx	r3
   164ac:	4605      	mov	r5, r0
		}

		buf->__buf = data_alloc(buf, &size, timeout);
   164ae:	6120      	str	r0, [r4, #16]
		if (!buf->__buf) {
   164b0:	bb48      	cbnz	r0, 16506 <net_buf_alloc_len+0xca>
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	k_lifo_put(&pool->free, buf);
   164b2:	79a0      	ldrb	r0, [r4, #6]
   164b4:	4621      	mov	r1, r4
   164b6:	eb07 1040 	add.w	r0, r7, r0, lsl #5
   164ba:	f007 ff4c 	bl	1e356 <k_queue_prepend>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
   164be:	462c      	mov	r4, r5
   164c0:	e01c      	b.n	164fc <net_buf_alloc_len+0xc0>
		uninit_count = pool->uninit_count--;
   164c2:	8a6b      	ldrh	r3, [r5, #18]
   164c4:	1e5a      	subs	r2, r3, #1
   164c6:	826a      	strh	r2, [r5, #18]
   164c8:	f388 8811 	msr	BASEPRI, r8
   164cc:	f3bf 8f6f 	isb	sy
	buf = &pool->__bufs[pool->buf_count - uninit_count];
   164d0:	8a2c      	ldrh	r4, [r5, #16]
   164d2:	1ae4      	subs	r4, r4, r3
   164d4:	69eb      	ldr	r3, [r5, #28]
   164d6:	2218      	movs	r2, #24
   164d8:	fb02 3404 	mla	r4, r2, r4, r3
	return pool - _net_buf_pool_list;
   164dc:	4b0f      	ldr	r3, [pc, #60]	; (1651c <net_buf_alloc_len+0xe0>)
   164de:	1aed      	subs	r5, r5, r3
   164e0:	116d      	asrs	r5, r5, #5
	buf->pool_id = pool_id(pool);
   164e2:	71a5      	strb	r5, [r4, #6]
		goto success;
   164e4:	e7ca      	b.n	1647c <net_buf_alloc_len+0x40>
   164e6:	f388 8811 	msr	BASEPRI, r8
   164ea:	f3bf 8f6f 	isb	sy
   164ee:	4631      	mov	r1, r6
   164f0:	4628      	mov	r0, r5
   164f2:	f007 ff54 	bl	1e39e <z_impl_k_queue_get>
	if (!buf) {
   164f6:	4604      	mov	r4, r0
   164f8:	2800      	cmp	r0, #0
   164fa:	d1bf      	bne.n	1647c <net_buf_alloc_len+0x40>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	pool->avail_count--;
	__ASSERT_NO_MSG(pool->avail_count >= 0);
#endif
	return buf;
}
   164fc:	4620      	mov	r0, r4
   164fe:	b002      	add	sp, #8
   16500:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		buf->__buf = NULL;
   16504:	6123      	str	r3, [r4, #16]
	buf->frags = NULL;
   16506:	2300      	movs	r3, #0
	buf->ref   = 1U;
   16508:	2201      	movs	r2, #1
	buf->frags = NULL;
   1650a:	6023      	str	r3, [r4, #0]
	buf->ref   = 1U;
   1650c:	80a2      	strh	r2, [r4, #4]
	buf->len  = 0U;
   1650e:	81a3      	strh	r3, [r4, #12]
	buf->size  = size;
   16510:	9a01      	ldr	r2, [sp, #4]
	buf->data = buf->__buf;
   16512:	6923      	ldr	r3, [r4, #16]
   16514:	81e2      	strh	r2, [r4, #14]
   16516:	60a3      	str	r3, [r4, #8]
	return buf;
   16518:	e7f0      	b.n	164fc <net_buf_alloc_len+0xc0>
   1651a:	bf00      	nop
   1651c:	20005ca8 	.word	0x20005ca8

00016520 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
   16520:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16522:	4d15      	ldr	r5, [pc, #84]	; (16578 <net_buf_unref+0x58>)
   16524:	4604      	mov	r4, r0
			return;
		}

		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
   16526:	2600      	movs	r6, #0
	while (buf) {
   16528:	b904      	cbnz	r4, 1652c <net_buf_unref+0xc>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
   1652a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (--buf->ref > 0) {
   1652c:	7923      	ldrb	r3, [r4, #4]
		struct net_buf *frags = buf->frags;
   1652e:	6827      	ldr	r7, [r4, #0]
		if (--buf->ref > 0) {
   16530:	3b01      	subs	r3, #1
   16532:	b2db      	uxtb	r3, r3
   16534:	7123      	strb	r3, [r4, #4]
   16536:	2b00      	cmp	r3, #0
   16538:	d1f7      	bne.n	1652a <net_buf_unref+0xa>
		if (buf->__buf) {
   1653a:	6921      	ldr	r1, [r4, #16]
   1653c:	b159      	cbz	r1, 16556 <net_buf_unref+0x36>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
   1653e:	7963      	ldrb	r3, [r4, #5]
   16540:	079b      	lsls	r3, r3, #30
   16542:	d407      	bmi.n	16554 <net_buf_unref+0x34>
	pool->alloc->cb->unref(buf, data);
   16544:	79a3      	ldrb	r3, [r4, #6]
   16546:	eb05 1343 	add.w	r3, r5, r3, lsl #5
   1654a:	4620      	mov	r0, r4
   1654c:	699b      	ldr	r3, [r3, #24]
   1654e:	681b      	ldr	r3, [r3, #0]
   16550:	689b      	ldr	r3, [r3, #8]
   16552:	4798      	blx	r3
			buf->__buf = NULL;
   16554:	6126      	str	r6, [r4, #16]
		pool = net_buf_pool_get(buf->pool_id);
   16556:	79a0      	ldrb	r0, [r4, #6]
		buf->data = NULL;
   16558:	60a6      	str	r6, [r4, #8]
		if (pool->destroy) {
   1655a:	eb05 1340 	add.w	r3, r5, r0, lsl #5
		buf->frags = NULL;
   1655e:	6026      	str	r6, [r4, #0]
		if (pool->destroy) {
   16560:	695b      	ldr	r3, [r3, #20]
   16562:	b11b      	cbz	r3, 1656c <net_buf_unref+0x4c>
			pool->destroy(buf);
   16564:	4620      	mov	r0, r4
   16566:	4798      	blx	r3
{
   16568:	463c      	mov	r4, r7
   1656a:	e7dd      	b.n	16528 <net_buf_unref+0x8>
	k_lifo_put(&pool->free, buf);
   1656c:	4621      	mov	r1, r4
   1656e:	eb05 1040 	add.w	r0, r5, r0, lsl #5
   16572:	f007 fef0 	bl	1e356 <k_queue_prepend>
   16576:	e7f7      	b.n	16568 <net_buf_unref+0x48>
   16578:	20005ca8 	.word	0x20005ca8

0001657c <gpio_nrfx_init>:
#endif
	}
}

static int gpio_nrfx_init(struct device *port)
{
   1657c:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
   1657e:	4b09      	ldr	r3, [pc, #36]	; (165a4 <gpio_nrfx_init+0x28>)
   16580:	781a      	ldrb	r2, [r3, #0]
   16582:	b96a      	cbnz	r2, 165a0 <gpio_nrfx_init+0x24>
		gpio_initialized = true;
   16584:	2101      	movs	r1, #1
   16586:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0,
   16588:	2006      	movs	r0, #6
   1658a:	2105      	movs	r1, #5
   1658c:	f7ed ff16 	bl	43bc <z_arm_irq_priority_set>
			    DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0_PRIORITY,
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0);
   16590:	2006      	movs	r0, #6
   16592:	f7ed fee1 	bl	4358 <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   16596:	4b04      	ldr	r3, [pc, #16]	; (165a8 <gpio_nrfx_init+0x2c>)
   16598:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   1659c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
   165a0:	2000      	movs	r0, #0
   165a2:	bd08      	pop	{r3, pc}
   165a4:	20001dee 	.word	0x20001dee
   165a8:	40006000 	.word	0x40006000

000165ac <gpiote_pin_int_cfg>:
{
   165ac:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return port->config->config_info;
   165ae:	6803      	ldr	r3, [r0, #0]
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
   165b0:	4d55      	ldr	r5, [pc, #340]	; (16708 <gpiote_pin_int_cfg+0x15c>)
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   165b2:	689b      	ldr	r3, [r3, #8]
	struct gpio_nrfx_data *data = get_port_data(port);
   165b4:	6882      	ldr	r2, [r0, #8]
   165b6:	f8d5 4304 	ldr.w	r4, [r5, #772]	; 0x304
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   165ba:	7918      	ldrb	r0, [r3, #4]
   165bc:	f001 031f 	and.w	r3, r1, #31
   165c0:	ea43 1340 	orr.w	r3, r3, r0, lsl #5
   165c4:	b2e4      	uxtb	r4, r4
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   165c6:	2000      	movs	r0, #0
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   165c8:	f500 76a2 	add.w	r6, r0, #324	; 0x144
   165cc:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
   165d0:	f3c6 2604 	ubfx	r6, r6, #8, #5
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
   165d4:	42b3      	cmp	r3, r6
   165d6:	d175      	bne.n	166c4 <gpiote_pin_int_cfg+0x118>
		    && (intenset & BIT(i))) {
   165d8:	fa24 f600 	lsr.w	r6, r4, r0
   165dc:	07f6      	lsls	r6, r6, #31
   165de:	d571      	bpl.n	166c4 <gpiote_pin_int_cfg+0x118>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
   165e0:	0084      	lsls	r4, r0, #2
   165e2:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
   165e6:	f504 44c0 	add.w	r4, r4, #24576	; 0x6000
   165ea:	f8d4 6510 	ldr.w	r6, [r4, #1296]	; 0x510
   165ee:	f026 0601 	bic.w	r6, r6, #1
   165f2:	f8c4 6510 	str.w	r6, [r4, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
   165f6:	2401      	movs	r4, #1
   165f8:	fa04 f000 	lsl.w	r0, r4, r0
    p_reg->INTENCLR = mask;
   165fc:	f8c5 0308 	str.w	r0, [r5, #776]	; 0x308
NRF_STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t             pin_number,
                                              nrf_gpio_pin_sense_t sense_config)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
   16600:	009c      	lsls	r4, r3, #2
   16602:	f104 44a0 	add.w	r4, r4, #1342177280	; 0x50000000
   16606:	f8d4 0700 	ldr.w	r0, [r4, #1792]	; 0x700
   1660a:	f420 3040 	bic.w	r0, r0, #196608	; 0x30000

    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   1660e:	f8c4 0700 	str.w	r0, [r4, #1792]	; 0x700
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
   16612:	6890      	ldr	r0, [r2, #8]
   16614:	40c8      	lsrs	r0, r1
   16616:	f010 0001 	ands.w	r0, r0, #1
   1661a:	d051      	beq.n	166c0 <gpiote_pin_int_cfg+0x114>
   1661c:	68d0      	ldr	r0, [r2, #12]
   1661e:	40c8      	lsrs	r0, r1
   16620:	f010 0001 	ands.w	r0, r0, #1
   16624:	d04c      	beq.n	166c0 <gpiote_pin_int_cfg+0x114>
		if (data->trig_edge & BIT(pin)) {
   16626:	6950      	ldr	r0, [r2, #20]
   16628:	40c8      	lsrs	r0, r1
   1662a:	f010 0001 	ands.w	r0, r0, #1
   1662e:	d056      	beq.n	166de <gpiote_pin_int_cfg+0x132>
			if (data->double_edge & BIT(pin)) {
   16630:	6990      	ldr	r0, [r2, #24]
   16632:	40c8      	lsrs	r0, r1
   16634:	07c0      	lsls	r0, r0, #31
   16636:	d44a      	bmi.n	166ce <gpiote_pin_int_cfg+0x122>
			} else if (((data->active_level & BIT(pin)) != 0U)
   16638:	6910      	ldr	r0, [r2, #16]
				   ^ ((BIT(pin) & data->inverted) != 0)) {
   1663a:	69d2      	ldr	r2, [r2, #28]
			} else if (((data->active_level & BIT(pin)) != 0U)
   1663c:	40c8      	lsrs	r0, r1
				   ^ ((BIT(pin) & data->inverted) != 0)) {
   1663e:	fa22 f101 	lsr.w	r1, r2, r1
			} else if (((data->active_level & BIT(pin)) != 0U)
   16642:	f000 0001 	and.w	r0, r0, #1
   16646:	f001 0101 	and.w	r1, r1, #1
				pol = NRF_GPIOTE_POLARITY_HITOLO;
   1664a:	4288      	cmp	r0, r1
   1664c:	bf14      	ite	ne
   1664e:	2101      	movne	r1, #1
   16650:	2102      	moveq	r1, #2
    p_reg->CONFIG[idx] = 0;
}

NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
   16652:	4d2d      	ldr	r5, [pc, #180]	; (16708 <gpiote_pin_int_cfg+0x15c>)
   16654:	2400      	movs	r4, #0
   16656:	f504 72a2 	add.w	r2, r4, #324	; 0x144
   1665a:	f855 0022 	ldr.w	r0, [r5, r2, lsl #2]
		if (!nrf_gpiote_te_is_enabled(NRF_GPIOTE, channel)) {
   1665e:	f010 0003 	ands.w	r0, r0, #3
   16662:	d136      	bne.n	166d2 <gpiote_pin_int_cfg+0x126>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   16664:	00a2      	lsls	r2, r4, #2
   16666:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   1666a:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   1666e:	021b      	lsls	r3, r3, #8
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   16670:	f8d2 6510 	ldr.w	r6, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   16674:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
   16678:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   1667c:	f426 3647 	bic.w	r6, r6, #203776	; 0x31c00
			nrf_gpiote_event_t evt =
   16680:	f104 0340 	add.w	r3, r4, #64	; 0x40
   16684:	f426 7640 	bic.w	r6, r6, #768	; 0x300
   16688:	009b      	lsls	r3, r3, #2
   1668a:	f8c2 6510 	str.w	r6, [r2, #1296]	; 0x510
    return ((uint32_t)p_reg + event);
   1668e:	b29b      	uxth	r3, r3
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   16690:	f8d2 6510 	ldr.w	r6, [r2, #1296]	; 0x510
    return ((uint32_t)p_reg + event);
   16694:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   16698:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   1669c:	4331      	orrs	r1, r6
   1669e:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   166a2:	6018      	str	r0, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
   166a4:	681b      	ldr	r3, [r3, #0]
   166a6:	9301      	str	r3, [sp, #4]
    (void)dummy;
   166a8:	9b01      	ldr	r3, [sp, #4]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   166aa:	f8d2 3510 	ldr.w	r3, [r2, #1296]	; 0x510
   166ae:	f043 0301 	orr.w	r3, r3, #1
   166b2:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
   166b6:	2301      	movs	r3, #1
   166b8:	fa03 f404 	lsl.w	r4, r3, r4
    p_reg->INTENSET = mask;
   166bc:	f8c5 4304 	str.w	r4, [r5, #772]	; 0x304
}
   166c0:	b002      	add	sp, #8
   166c2:	bd70      	pop	{r4, r5, r6, pc}
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   166c4:	3001      	adds	r0, #1
   166c6:	2808      	cmp	r0, #8
   166c8:	f47f af7e 	bne.w	165c8 <gpiote_pin_int_cfg+0x1c>
   166cc:	e798      	b.n	16600 <gpiote_pin_int_cfg+0x54>
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
   166ce:	2103      	movs	r1, #3
   166d0:	e7bf      	b.n	16652 <gpiote_pin_int_cfg+0xa6>
   166d2:	3401      	adds	r4, #1
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
   166d4:	2c08      	cmp	r4, #8
   166d6:	d1be      	bne.n	16656 <gpiote_pin_int_cfg+0xaa>
	return -ENODEV;
   166d8:	f06f 0012 	mvn.w	r0, #18
   166dc:	e7f0      	b.n	166c0 <gpiote_pin_int_cfg+0x114>
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   166de:	6913      	ldr	r3, [r2, #16]
   166e0:	69d2      	ldr	r2, [r2, #28]
   166e2:	4053      	eors	r3, r2
   166e4:	fa23 f101 	lsr.w	r1, r3, r1
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
   166e8:	f8d4 3700 	ldr.w	r3, [r4, #1792]	; 0x700
		return NRF_GPIO_PIN_SENSE_HIGH;
   166ec:	f011 0f01 	tst.w	r1, #1
   166f0:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   166f4:	bf14      	ite	ne
   166f6:	f44f 3200 	movne.w	r2, #131072	; 0x20000
   166fa:	f44f 3240 	moveq.w	r2, #196608	; 0x30000
   166fe:	4313      	orrs	r3, r2
   16700:	f8c4 3700 	str.w	r3, [r4, #1792]	; 0x700
   16704:	e7dc      	b.n	166c0 <gpiote_pin_int_cfg+0x114>
   16706:	bf00      	nop
   16708:	40006000 	.word	0x40006000

0001670c <gpiote_event_handler>:
{
   1670c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   16710:	4953      	ldr	r1, [pc, #332]	; (16860 <gpiote_event_handler+0x154>)
   16712:	680d      	ldr	r5, [r1, #0]
	if (port_event) {
   16714:	2d00      	cmp	r5, #0
   16716:	d067      	beq.n	167e8 <gpiote_event_handler+0xdc>
	struct gpio_nrfx_data *data = get_port_data(port);
   16718:	4b52      	ldr	r3, [pc, #328]	; (16864 <gpiote_event_handler+0x158>)
   1671a:	689a      	ldr	r2, [r3, #8]
	return port->config->config_info;
   1671c:	681b      	ldr	r3, [r3, #0]
   1671e:	689e      	ldr	r6, [r3, #8]
	u32_t out = data->int_en & data->pin_int_en;
   16720:	e9d2 0302 	ldrd	r0, r3, [r2, #8]
   16724:	4003      	ands	r3, r0
	out &= ~data->trig_edge & ~data->double_edge;
   16726:	e9d2 0405 	ldrd	r0, r4, [r2, #20]
   1672a:	4320      	orrs	r0, r4
   1672c:	ea23 0300 	bic.w	r3, r3, r0
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
   16730:	6830      	ldr	r0, [r6, #0]
	u32_t pin_states = ~(port_in ^ data->inverted ^ data->active_level);
   16732:	69d4      	ldr	r4, [r2, #28]
   16734:	6912      	ldr	r2, [r2, #16]
}


NRF_STATIC_INLINE uint32_t nrf_gpio_port_in_read(NRF_GPIO_Type const * p_reg)
{
    return p_reg->IN;
   16736:	f8d0 0510 	ldr.w	r0, [r0, #1296]	; 0x510
   1673a:	4054      	eors	r4, r2
   1673c:	4044      	eors	r4, r0
	u32_t out = pin_states & level_pins;
   1673e:	ea23 0404 	bic.w	r4, r3, r4
	u32_t bit = 1U << pin;
   16742:	2001      	movs	r0, #1
	u32_t pin = 0U;
   16744:	2700      	movs	r7, #0
	while (level_pins) {
   16746:	2b00      	cmp	r3, #0
   16748:	d138      	bne.n	167bc <gpiote_event_handler+0xb0>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   1674a:	600b      	str	r3, [r1, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
   1674c:	680b      	ldr	r3, [r1, #0]
   1674e:	9300      	str	r3, [sp, #0]
    (void)dummy;
   16750:	9b00      	ldr	r3, [sp, #0]
    return p_reg->INTENSET & mask;
   16752:	4845      	ldr	r0, [pc, #276]	; (16868 <gpiote_event_handler+0x15c>)
	u32_t fired_triggers[GPIO_COUNT] = {0};
   16754:	2300      	movs	r3, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
   16756:	2601      	movs	r6, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   16758:	461f      	mov	r7, r3
    return p_reg->INTENSET & mask;
   1675a:	f8d0 2304 	ldr.w	r2, [r0, #772]	; 0x304
   1675e:	fa06 f103 	lsl.w	r1, r6, r3
   16762:	4211      	tst	r1, r2
   16764:	d013      	beq.n	1678e <gpiote_event_handler+0x82>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   16766:	009a      	lsls	r2, r3, #2
   16768:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   1676c:	f502 42c2 	add.w	r2, r2, #24832	; 0x6100
   16770:	6811      	ldr	r1, [r2, #0]
   16772:	b161      	cbz	r1, 1678e <gpiote_event_handler+0x82>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   16774:	f503 71a2 	add.w	r1, r3, #324	; 0x144
   16778:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   1677c:	6017      	str	r7, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
   1677e:	6812      	ldr	r2, [r2, #0]
   16780:	9201      	str	r2, [sp, #4]
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   16782:	f3c1 2104 	ubfx	r1, r1, #8, #5
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
   16786:	fa06 f101 	lsl.w	r1, r6, r1
    (void)dummy;
   1678a:	9a01      	ldr	r2, [sp, #4]
   1678c:	430c      	orrs	r4, r1
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   1678e:	3301      	adds	r3, #1
   16790:	2b08      	cmp	r3, #8
   16792:	d1e2      	bne.n	1675a <gpiote_event_handler+0x4e>
	if (fired_triggers[0]) {
   16794:	bb54      	cbnz	r4, 167ec <gpiote_event_handler+0xe0>
	if (port_event) {
   16796:	b175      	cbz	r5, 167b6 <gpiote_event_handler+0xaa>
	const struct gpio_nrfx_data *data = get_port_data(port);
   16798:	4b32      	ldr	r3, [pc, #200]	; (16864 <gpiote_event_handler+0x158>)
   1679a:	6899      	ldr	r1, [r3, #8]
	return port->config->config_info;
   1679c:	681b      	ldr	r3, [r3, #0]
   1679e:	689e      	ldr	r6, [r3, #8]
	u32_t out = data->int_en & data->pin_int_en;
   167a0:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
   167a4:	4013      	ands	r3, r2
	out &= ~data->trig_edge & ~data->double_edge;
   167a6:	e9d1 2005 	ldrd	r2, r0, [r1, #20]
   167aa:	4302      	orrs	r2, r0
   167ac:	ea23 0302 	bic.w	r3, r3, r2
	u32_t bit = 1U << pin;
   167b0:	2401      	movs	r4, #1
	u32_t pin = 0U;
   167b2:	2500      	movs	r5, #0
	while (level_pins) {
   167b4:	bb8b      	cbnz	r3, 1681a <gpiote_event_handler+0x10e>
}
   167b6:	b002      	add	sp, #8
   167b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (level_pins & bit) {
   167bc:	4203      	tst	r3, r0
   167be:	d010      	beq.n	167e2 <gpiote_event_handler+0xd6>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   167c0:	f896 c004 	ldrb.w	ip, [r6, #4]
   167c4:	f007 021f 	and.w	r2, r7, #31
   167c8:	ea42 124c 	orr.w	r2, r2, ip, lsl #5
   167cc:	0092      	lsls	r2, r2, #2
   167ce:	f102 42a0 	add.w	r2, r2, #1342177280	; 0x50000000
			level_pins &= ~bit;
   167d2:	ea23 0300 	bic.w	r3, r3, r0
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
   167d6:	f8d2 c700 	ldr.w	ip, [r2, #1792]	; 0x700
   167da:	f42c 3c40 	bic.w	ip, ip, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   167de:	f8c2 c700 	str.w	ip, [r2, #1792]	; 0x700
		++pin;
   167e2:	3701      	adds	r7, #1
		bit <<= 1;
   167e4:	0040      	lsls	r0, r0, #1
   167e6:	e7ae      	b.n	16746 <gpiote_event_handler+0x3a>
	u32_t fired_triggers[GPIO_COUNT] = {0};
   167e8:	462c      	mov	r4, r5
   167ea:	e7b2      	b.n	16752 <gpiote_event_handler+0x46>
	struct gpio_nrfx_data *data = get_port_data(port);
   167ec:	4f1d      	ldr	r7, [pc, #116]	; (16864 <gpiote_event_handler+0x158>)
   167ee:	f8d7 8008 	ldr.w	r8, [r7, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   167f2:	f8d8 1000 	ldr.w	r1, [r8]
   167f6:	2900      	cmp	r1, #0
   167f8:	d0cd      	beq.n	16796 <gpiote_event_handler+0x8a>
   167fa:	680e      	ldr	r6, [r1, #0]
		if ((cb->pin_mask & pins) & data->int_en) {
   167fc:	f8d8 300c 	ldr.w	r3, [r8, #12]
   16800:	688a      	ldr	r2, [r1, #8]
   16802:	4023      	ands	r3, r4
   16804:	4213      	tst	r3, r2
   16806:	d003      	beq.n	16810 <gpiote_event_handler+0x104>
			cb->handler(port, cb, pins);
   16808:	684b      	ldr	r3, [r1, #4]
   1680a:	4622      	mov	r2, r4
   1680c:	4638      	mov	r0, r7
   1680e:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   16810:	2e00      	cmp	r6, #0
   16812:	d0c0      	beq.n	16796 <gpiote_event_handler+0x8a>
   16814:	4631      	mov	r1, r6
   16816:	6836      	ldr	r6, [r6, #0]
   16818:	e7f0      	b.n	167fc <gpiote_event_handler+0xf0>
		if (level_pins & bit) {
   1681a:	421c      	tst	r4, r3
   1681c:	d01c      	beq.n	16858 <gpiote_event_handler+0x14c>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1681e:	7930      	ldrb	r0, [r6, #4]
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   16820:	69cf      	ldr	r7, [r1, #28]
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   16822:	f005 021f 	and.w	r2, r5, #31
   16826:	ea42 1240 	orr.w	r2, r2, r0, lsl #5
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   1682a:	6908      	ldr	r0, [r1, #16]
   1682c:	0092      	lsls	r2, r2, #2
   1682e:	4078      	eors	r0, r7
   16830:	f102 42a0 	add.w	r2, r2, #1342177280	; 0x50000000
   16834:	40e8      	lsrs	r0, r5
		return NRF_GPIO_PIN_SENSE_HIGH;
   16836:	f010 0f01 	tst.w	r0, #1
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
   1683a:	f8d2 0700 	ldr.w	r0, [r2, #1792]	; 0x700
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   1683e:	bf18      	it	ne
   16840:	f44f 3700 	movne.w	r7, #131072	; 0x20000
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
   16844:	f420 3040 	bic.w	r0, r0, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   16848:	bf08      	it	eq
   1684a:	f44f 3740 	moveq.w	r7, #196608	; 0x30000
   1684e:	4338      	orrs	r0, r7
   16850:	f8c2 0700 	str.w	r0, [r2, #1792]	; 0x700
			level_pins &= ~bit;
   16854:	ea23 0304 	bic.w	r3, r3, r4
		++pin;
   16858:	3501      	adds	r5, #1
		bit <<= 1;
   1685a:	0064      	lsls	r4, r4, #1
   1685c:	e7aa      	b.n	167b4 <gpiote_event_handler+0xa8>
   1685e:	bf00      	nop
   16860:	4000617c 	.word	0x4000617c
   16864:	20005b74 	.word	0x20005b74
   16868:	40006000 	.word	0x40006000

0001686c <twi_1_init>:
#ifdef CONFIG_I2C_0_NRF_TWI
I2C_NRFX_TWI_DEVICE(0);
#endif

#ifdef CONFIG_I2C_1_NRF_TWI
I2C_NRFX_TWI_DEVICE(1);
   1686c:	b510      	push	{r4, lr}
   1686e:	4604      	mov	r4, r0
   16870:	2200      	movs	r2, #0
   16872:	2101      	movs	r1, #1
   16874:	2004      	movs	r0, #4
   16876:	f7ed fda1 	bl	43bc <z_arm_irq_priority_set>
	return dev->config->config_info;
   1687a:	6823      	ldr	r3, [r4, #0]
	nrfx_err_t result = nrfx_twi_init(&get_dev_config(dev)->twi,
   1687c:	4a0f      	ldr	r2, [pc, #60]	; (168bc <twi_1_init+0x50>)
	return dev->config->config_info;
   1687e:	6898      	ldr	r0, [r3, #8]
	nrfx_err_t result = nrfx_twi_init(&get_dev_config(dev)->twi,
   16880:	4623      	mov	r3, r4
   16882:	f100 0108 	add.w	r1, r0, #8
   16886:	f000 fe07 	bl	17498 <nrfx_twi_init>
	if (result != NRFX_SUCCESS) {
   1688a:	4b0d      	ldr	r3, [pc, #52]	; (168c0 <twi_1_init+0x54>)
   1688c:	4298      	cmp	r0, r3
   1688e:	d012      	beq.n	168b6 <twi_1_init+0x4a>
		LOG_ERR("Failed to initialize device: %s",
   16890:	2301      	movs	r3, #1
   16892:	f04f 0200 	mov.w	r2, #0
   16896:	f363 0207 	bfi	r2, r3, #0, #8
   1689a:	490a      	ldr	r1, [pc, #40]	; (168c4 <twi_1_init+0x58>)
   1689c:	4b0a      	ldr	r3, [pc, #40]	; (168c8 <twi_1_init+0x5c>)
   1689e:	480b      	ldr	r0, [pc, #44]	; (168cc <twi_1_init+0x60>)
   168a0:	1a5b      	subs	r3, r3, r1
   168a2:	08db      	lsrs	r3, r3, #3
   168a4:	f363 128f 	bfi	r2, r3, #6, #10
   168a8:	6823      	ldr	r3, [r4, #0]
   168aa:	6819      	ldr	r1, [r3, #0]
   168ac:	f003 febe 	bl	1a62c <log_1>
		return -EBUSY;
   168b0:	f06f 000f 	mvn.w	r0, #15
I2C_NRFX_TWI_DEVICE(1);
   168b4:	bd10      	pop	{r4, pc}
	return 0;
   168b6:	2000      	movs	r0, #0
I2C_NRFX_TWI_DEVICE(1);
   168b8:	e7fc      	b.n	168b4 <twi_1_init+0x48>
   168ba:	bf00      	nop
   168bc:	00016a35 	.word	0x00016a35
   168c0:	0bad0000 	.word	0x0bad0000
   168c4:	0001ed28 	.word	0x0001ed28
   168c8:	0001ee38 	.word	0x0001ee38
   168cc:	000225e1 	.word	0x000225e1

000168d0 <i2c_nrfx_twi_configure>:
{
   168d0:	b508      	push	{r3, lr}
	return dev->config->config_info;
   168d2:	6803      	ldr	r3, [r0, #0]
	if (I2C_ADDR_10_BITS & dev_config) {
   168d4:	07ca      	lsls	r2, r1, #31
	return dev->config->config_info;
   168d6:	689b      	ldr	r3, [r3, #8]
	if (I2C_ADDR_10_BITS & dev_config) {
   168d8:	d413      	bmi.n	16902 <i2c_nrfx_twi_configure+0x32>
	switch (I2C_SPEED_GET(dev_config)) {
   168da:	f3c1 0242 	ubfx	r2, r1, #1, #3
   168de:	2a01      	cmp	r2, #1
   168e0:	d012      	beq.n	16908 <i2c_nrfx_twi_configure+0x38>
   168e2:	2a02      	cmp	r2, #2
   168e4:	d019      	beq.n	1691a <i2c_nrfx_twi_configure+0x4a>
		LOG_ERR("unsupported speed");
   168e6:	2301      	movs	r3, #1
   168e8:	f04f 0100 	mov.w	r1, #0
   168ec:	f363 0107 	bfi	r1, r3, #0, #8
   168f0:	4a0c      	ldr	r2, [pc, #48]	; (16924 <i2c_nrfx_twi_configure+0x54>)
   168f2:	4b0d      	ldr	r3, [pc, #52]	; (16928 <i2c_nrfx_twi_configure+0x58>)
   168f4:	480d      	ldr	r0, [pc, #52]	; (1692c <i2c_nrfx_twi_configure+0x5c>)
   168f6:	1a9b      	subs	r3, r3, r2
   168f8:	08db      	lsrs	r3, r3, #3
   168fa:	f363 118f 	bfi	r1, r3, #6, #10
   168fe:	f003 fe88 	bl	1a612 <log_0>
		return -EINVAL;
   16902:	f06f 0015 	mvn.w	r0, #21
   16906:	e007      	b.n	16918 <i2c_nrfx_twi_configure+0x48>
		nrf_twi_frequency_set(inst->p_twi, NRF_TWI_FREQ_100K);
   16908:	681b      	ldr	r3, [r3, #0]
}

NRF_STATIC_INLINE void nrf_twi_frequency_set(NRF_TWI_Type *      p_reg,
                                             nrf_twi_frequency_t frequency)
{
    p_reg->FREQUENCY = frequency;
   1690a:	f04f 72cc 	mov.w	r2, #26738688	; 0x1980000
   1690e:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	get_dev_data(dev)->dev_config = dev_config;
   16912:	6883      	ldr	r3, [r0, #8]
	return 0;
   16914:	2000      	movs	r0, #0
	get_dev_data(dev)->dev_config = dev_config;
   16916:	6359      	str	r1, [r3, #52]	; 0x34
}
   16918:	bd08      	pop	{r3, pc}
		nrf_twi_frequency_set(inst->p_twi, NRF_TWI_FREQ_400K);
   1691a:	681b      	ldr	r3, [r3, #0]
   1691c:	f04f 62cd 	mov.w	r2, #107479040	; 0x6680000
   16920:	e7f5      	b.n	1690e <i2c_nrfx_twi_configure+0x3e>
   16922:	bf00      	nop
   16924:	0001ed28 	.word	0x0001ed28
   16928:	0001ee38 	.word	0x0001ee38
   1692c:	0002259b 	.word	0x0002259b

00016930 <i2c_nrfx_twi_transfer>:
{
   16930:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16934:	4605      	mov	r5, r0
   16936:	b087      	sub	sp, #28
   16938:	460c      	mov	r4, r1
   1693a:	4617      	mov	r7, r2
   1693c:	4699      	mov	r9, r3
	k_sem_take(&(get_dev_data(dev)->transfer_sync), K_FOREVER);
   1693e:	6880      	ldr	r0, [r0, #8]
	return z_impl_k_sem_take(sem, timeout);
   16940:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   16944:	f001 fdca 	bl	184dc <z_impl_k_sem_take>
	return dev->config->config_info;
   16948:	682b      	ldr	r3, [r5, #0]
		if (res != NRFX_SUCCESS) {
   1694a:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 16a30 <i2c_nrfx_twi_transfer+0x100>
	nrfx_twi_enable(&get_dev_config(dev)->twi);
   1694e:	6898      	ldr	r0, [r3, #8]
   16950:	f000 fde6 	bl	17520 <nrfx_twi_enable>
	for (size_t i = 0; i < num_msgs; i++) {
   16954:	2600      	movs	r6, #0
   16956:	42be      	cmp	r6, r7
   16958:	d301      	bcc.n	1695e <i2c_nrfx_twi_transfer+0x2e>
	int ret = 0;
   1695a:	2400      	movs	r4, #0
   1695c:	e02e      	b.n	169bc <i2c_nrfx_twi_transfer+0x8c>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
   1695e:	f894 b008 	ldrb.w	fp, [r4, #8]
   16962:	f01b 0a08 	ands.w	sl, fp, #8
   16966:	d158      	bne.n	16a1a <i2c_nrfx_twi_transfer+0xea>
		nrfx_twi_xfer_desc_t cur_xfer = {
   16968:	2212      	movs	r2, #18
   1696a:	4651      	mov	r1, sl
   1696c:	f10d 0006 	add.w	r0, sp, #6
   16970:	f004 fb6d 	bl	1b04e <memset>
   16974:	6862      	ldr	r2, [r4, #4]
   16976:	9202      	str	r2, [sp, #8]
					  NRFX_TWI_XFER_RX : NRFX_TWI_XFER_TX
   16978:	f00b 0301 	and.w	r3, fp, #1
		nrfx_twi_xfer_desc_t cur_xfer = {
   1697c:	6822      	ldr	r2, [r4, #0]
   1697e:	f88d 3004 	strb.w	r3, [sp, #4]
		if (!(msgs[i].flags & I2C_MSG_STOP)) {
   16982:	f01b 0f02 	tst.w	fp, #2
		nrfx_twi_xfer_desc_t cur_xfer = {
   16986:	f88d 9005 	strb.w	r9, [sp, #5]
   1698a:	9204      	str	r2, [sp, #16]
		if (!(msgs[i].flags & I2C_MSG_STOP)) {
   1698c:	d121      	bne.n	169d2 <i2c_nrfx_twi_transfer+0xa2>
			if ((i < (num_msgs - 1)) &&
   1698e:	1e7a      	subs	r2, r7, #1
   16990:	42b2      	cmp	r2, r6
   16992:	d902      	bls.n	1699a <i2c_nrfx_twi_transfer+0x6a>
   16994:	7d22      	ldrb	r2, [r4, #20]
   16996:	0752      	lsls	r2, r2, #29
   16998:	d51d      	bpl.n	169d6 <i2c_nrfx_twi_transfer+0xa6>
			} else if (msgs[i].flags & I2C_MSG_READ) {
   1699a:	2b00      	cmp	r3, #0
   1699c:	d13d      	bne.n	16a1a <i2c_nrfx_twi_transfer+0xea>
				xfer_flags |= NRFX_TWI_FLAG_TX_NO_STOP;
   1699e:	2220      	movs	r2, #32
	return dev->config->config_info;
   169a0:	682b      	ldr	r3, [r5, #0]
		res = nrfx_twi_xfer(&get_dev_config(dev)->twi,
   169a2:	a901      	add	r1, sp, #4
   169a4:	6898      	ldr	r0, [r3, #8]
   169a6:	f000 fde5 	bl	17574 <nrfx_twi_xfer>
		if (res != NRFX_SUCCESS) {
   169aa:	4540      	cmp	r0, r8
   169ac:	d015      	beq.n	169da <i2c_nrfx_twi_transfer+0xaa>
			if (res == NRFX_ERROR_BUSY) {
   169ae:	4b1c      	ldr	r3, [pc, #112]	; (16a20 <i2c_nrfx_twi_transfer+0xf0>)
				ret = -EIO;
   169b0:	4298      	cmp	r0, r3
   169b2:	bf0c      	ite	eq
   169b4:	f06f 040f 	mvneq.w	r4, #15
   169b8:	f06f 0404 	mvnne.w	r4, #4
	return dev->config->config_info;
   169bc:	682b      	ldr	r3, [r5, #0]
	nrfx_twi_disable(&get_dev_config(dev)->twi);
   169be:	6898      	ldr	r0, [r3, #8]
   169c0:	f000 fdbe 	bl	17540 <nrfx_twi_disable>
	k_sem_give(&(get_dev_data(dev)->transfer_sync));
   169c4:	68a8      	ldr	r0, [r5, #8]
	z_impl_k_sem_give(sem);
   169c6:	f001 fd5d 	bl	18484 <z_impl_k_sem_give>
}
   169ca:	4620      	mov	r0, r4
   169cc:	b007      	add	sp, #28
   169ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		u32_t xfer_flags = 0;
   169d2:	4652      	mov	r2, sl
   169d4:	e7e4      	b.n	169a0 <i2c_nrfx_twi_transfer+0x70>
				xfer_flags |= NRFX_TWI_FLAG_SUSPEND;
   169d6:	2240      	movs	r2, #64	; 0x40
   169d8:	e7e2      	b.n	169a0 <i2c_nrfx_twi_transfer+0x70>
		k_sem_take(&(get_dev_data(dev)->completion_sync), K_FOREVER);
   169da:	68a8      	ldr	r0, [r5, #8]
   169dc:	3018      	adds	r0, #24
	return z_impl_k_sem_take(sem, timeout);
   169de:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   169e2:	f001 fd7b 	bl	184dc <z_impl_k_sem_take>
		res = get_dev_data(dev)->res;
   169e6:	68ab      	ldr	r3, [r5, #8]
   169e8:	6b19      	ldr	r1, [r3, #48]	; 0x30
		if (res != NRFX_SUCCESS) {
   169ea:	4541      	cmp	r1, r8
   169ec:	f104 040c 	add.w	r4, r4, #12
   169f0:	d011      	beq.n	16a16 <i2c_nrfx_twi_transfer+0xe6>
			LOG_ERR("Error %d occurred for message %d", res, i);
   169f2:	2201      	movs	r2, #1
   169f4:	f04f 0300 	mov.w	r3, #0
   169f8:	f362 0307 	bfi	r3, r2, #0, #8
   169fc:	4809      	ldr	r0, [pc, #36]	; (16a24 <i2c_nrfx_twi_transfer+0xf4>)
   169fe:	4a0a      	ldr	r2, [pc, #40]	; (16a28 <i2c_nrfx_twi_transfer+0xf8>)
   16a00:	1a12      	subs	r2, r2, r0
   16a02:	08d2      	lsrs	r2, r2, #3
   16a04:	f362 138f 	bfi	r3, r2, #6, #10
   16a08:	4808      	ldr	r0, [pc, #32]	; (16a2c <i2c_nrfx_twi_transfer+0xfc>)
   16a0a:	4632      	mov	r2, r6
   16a0c:	f003 fe22 	bl	1a654 <log_2>
			ret = -EIO;
   16a10:	f06f 0404 	mvn.w	r4, #4
			break;
   16a14:	e7d2      	b.n	169bc <i2c_nrfx_twi_transfer+0x8c>
	for (size_t i = 0; i < num_msgs; i++) {
   16a16:	3601      	adds	r6, #1
   16a18:	e79d      	b.n	16956 <i2c_nrfx_twi_transfer+0x26>
			ret = -ENOTSUP;
   16a1a:	f06f 0422 	mvn.w	r4, #34	; 0x22
   16a1e:	e7cd      	b.n	169bc <i2c_nrfx_twi_transfer+0x8c>
   16a20:	0bad000b 	.word	0x0bad000b
   16a24:	0001ed28 	.word	0x0001ed28
   16a28:	0001ee38 	.word	0x0001ee38
   16a2c:	000225ad 	.word	0x000225ad
   16a30:	0bad0000 	.word	0x0bad0000

00016a34 <event_handler>:
	switch (p_event->type) {
   16a34:	7802      	ldrb	r2, [r0, #0]
	struct i2c_nrfx_twi_data *dev_data = get_dev_data(dev);
   16a36:	688b      	ldr	r3, [r1, #8]
	switch (p_event->type) {
   16a38:	2a01      	cmp	r2, #1
   16a3a:	d00a      	beq.n	16a52 <event_handler+0x1e>
   16a3c:	b11a      	cbz	r2, 16a46 <event_handler+0x12>
   16a3e:	2a02      	cmp	r2, #2
   16a40:	d009      	beq.n	16a56 <event_handler+0x22>
		dev_data->res = NRFX_ERROR_INTERNAL;
   16a42:	4a06      	ldr	r2, [pc, #24]	; (16a5c <event_handler+0x28>)
   16a44:	e000      	b.n	16a48 <event_handler+0x14>
		dev_data->res = NRFX_SUCCESS;
   16a46:	4a06      	ldr	r2, [pc, #24]	; (16a60 <event_handler+0x2c>)
		dev_data->res = NRFX_ERROR_INTERNAL;
   16a48:	631a      	str	r2, [r3, #48]	; 0x30
	z_impl_k_sem_give(sem);
   16a4a:	f103 0018 	add.w	r0, r3, #24
   16a4e:	f001 bd19 	b.w	18484 <z_impl_k_sem_give>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   16a52:	4a04      	ldr	r2, [pc, #16]	; (16a64 <event_handler+0x30>)
   16a54:	e7f8      	b.n	16a48 <event_handler+0x14>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   16a56:	4a04      	ldr	r2, [pc, #16]	; (16a68 <event_handler+0x34>)
   16a58:	e7f6      	b.n	16a48 <event_handler+0x14>
   16a5a:	bf00      	nop
   16a5c:	0bad0001 	.word	0x0bad0001
   16a60:	0bad0000 	.word	0x0bad0000
   16a64:	0bae0001 	.word	0x0bae0001
   16a68:	0bae0002 	.word	0x0bae0002

00016a6c <nvmc_wait_ready>:

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrf_nvmc_ready_check(NRF_NVMC_Type const * p_reg)
{
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   16a6c:	4a02      	ldr	r2, [pc, #8]	; (16a78 <nvmc_wait_ready+0xc>)
   16a6e:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
   16a72:	07db      	lsls	r3, r3, #31
   16a74:	d5fb      	bpl.n	16a6e <nvmc_wait_ready+0x2>
}
   16a76:	4770      	bx	lr
   16a78:	4001e000 	.word	0x4001e000

00016a7c <flash_nrf_pages_layout>:
	*layout = &dev_layout;
   16a7c:	4b02      	ldr	r3, [pc, #8]	; (16a88 <flash_nrf_pages_layout+0xc>)
   16a7e:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
   16a80:	2301      	movs	r3, #1
   16a82:	6013      	str	r3, [r2, #0]
}
   16a84:	4770      	bx	lr
   16a86:	bf00      	nop
   16a88:	20001884 	.word	0x20001884

00016a8c <time_slot_callback_helper>:
{
   16a8c:	b570      	push	{r4, r5, r6, lr}
   16a8e:	b08c      	sub	sp, #48	; 0x30
   16a90:	461d      	mov	r5, r3
   16a92:	4606      	mov	r6, r0
	ll_radio_state_abort();
   16a94:	f7f9 fcc2 	bl	1041c <ll_radio_state_abort>
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
   16a98:	f10d 012f 	add.w	r1, sp, #47	; 0x2f
   16a9c:	f10d 002e 	add.w	r0, sp, #46	; 0x2e
   16aa0:	f006 fc2d 	bl	1d2fe <ll_timeslice_ticker_id_get>
	err = ticker_start(instance_index, /* Radio instance ticker */
   16aa4:	4b13      	ldr	r3, [pc, #76]	; (16af4 <time_slot_callback_helper+0x68>)
   16aa6:	9506      	str	r5, [sp, #24]
   16aa8:	2400      	movs	r4, #0
   16aaa:	e9cd 4304 	strd	r4, r3, [sp, #16]
   16aae:	2310      	movs	r3, #16
   16ab0:	9300      	str	r3, [sp, #0]
   16ab2:	e9cd 4407 	strd	r4, r4, [sp, #28]
   16ab6:	4633      	mov	r3, r6
   16ab8:	e9cd 4402 	strd	r4, r4, [sp, #8]
   16abc:	9401      	str	r4, [sp, #4]
   16abe:	4622      	mov	r2, r4
   16ac0:	4621      	mov	r1, r4
   16ac2:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
   16ac6:	f7f7 fc87 	bl	e3d8 <ticker_start>
	if (err != TICKER_STATUS_SUCCESS && err != TICKER_STATUS_BUSY) {
   16aca:	f030 0302 	bics.w	r3, r0, #2
   16ace:	d00e      	beq.n	16aee <time_slot_callback_helper+0x62>
		((struct flash_op_desc *)context)->result = -ECANCELED;
   16ad0:	f06f 0347 	mvn.w	r3, #71	; 0x47
   16ad4:	60ab      	str	r3, [r5, #8]
		err = ticker_stop(instance_index, 0, ticker_id, NULL, NULL);
   16ad6:	9400      	str	r4, [sp, #0]
   16ad8:	4623      	mov	r3, r4
   16ada:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
   16ade:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
   16ae2:	4621      	mov	r1, r4
   16ae4:	f7f7 fd0a 	bl	e4fc <ticker_stop>
   16ae8:	4803      	ldr	r0, [pc, #12]	; (16af8 <time_slot_callback_helper+0x6c>)
   16aea:	f001 fccb 	bl	18484 <z_impl_k_sem_give>
}
   16aee:	b00c      	add	sp, #48	; 0x30
   16af0:	bd70      	pop	{r4, r5, r6, pc}
   16af2:	bf00      	nop
   16af4:	00016b31 	.word	0x00016b31
   16af8:	200018a4 	.word	0x200018a4

00016afc <nrf_flash_init>:
{
   16afc:	b510      	push	{r4, lr}
	z_impl_k_sem_init(sem, initial_count, limit);
   16afe:	2201      	movs	r2, #1
   16b00:	4611      	mov	r1, r2
   16b02:	4808      	ldr	r0, [pc, #32]	; (16b24 <nrf_flash_init+0x28>)
   16b04:	f007 fda4 	bl	1e650 <z_impl_k_sem_init>
   16b08:	2201      	movs	r2, #1
   16b0a:	2100      	movs	r1, #0
   16b0c:	4806      	ldr	r0, [pc, #24]	; (16b28 <nrf_flash_init+0x2c>)
	dev_layout.pages_count = nrfx_nvmc_flash_page_count_get();
   16b0e:	4c07      	ldr	r4, [pc, #28]	; (16b2c <nrf_flash_init+0x30>)
   16b10:	f007 fd9e 	bl	1e650 <z_impl_k_sem_init>
   16b14:	f007 fad5 	bl	1e0c2 <nrfx_nvmc_flash_page_count_get>
   16b18:	6020      	str	r0, [r4, #0]
	dev_layout.pages_size = nrfx_nvmc_flash_page_size_get();
   16b1a:	f007 face 	bl	1e0ba <nrfx_nvmc_flash_page_size_get>
   16b1e:	6060      	str	r0, [r4, #4]
}
   16b20:	2000      	movs	r0, #0
   16b22:	bd10      	pop	{r4, pc}
   16b24:	2000188c 	.word	0x2000188c
   16b28:	200018a4 	.word	0x200018a4
   16b2c:	20001884 	.word	0x20001884

00016b30 <time_slot_callback_work>:
{
   16b30:	b530      	push	{r4, r5, lr}
   16b32:	461d      	mov	r5, r3
   16b34:	b085      	sub	sp, #20
	if (op_desc->handler(op_desc->context) == FLASH_OP_DONE) {
   16b36:	e9d3 3000 	ldrd	r3, r0, [r3]
   16b3a:	4798      	blx	r3
   16b3c:	4604      	mov	r4, r0
   16b3e:	b990      	cbnz	r0, 16b66 <time_slot_callback_work+0x36>
		ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
   16b40:	f10d 010f 	add.w	r1, sp, #15
   16b44:	f10d 000e 	add.w	r0, sp, #14
   16b48:	f006 fbd9 	bl	1d2fe <ll_timeslice_ticker_id_get>
		result = ticker_stop(instance_index,
   16b4c:	9400      	str	r4, [sp, #0]
   16b4e:	4623      	mov	r3, r4
   16b50:	f89d 200f 	ldrb.w	r2, [sp, #15]
   16b54:	f89d 000e 	ldrb.w	r0, [sp, #14]
   16b58:	4621      	mov	r1, r4
   16b5a:	f7f7 fccf 	bl	e4fc <ticker_stop>
		((struct flash_op_desc *)context)->result = 0;
   16b5e:	60ac      	str	r4, [r5, #8]
	z_impl_k_sem_give(sem);
   16b60:	4802      	ldr	r0, [pc, #8]	; (16b6c <time_slot_callback_work+0x3c>)
   16b62:	f001 fc8f 	bl	18484 <z_impl_k_sem_give>
}
   16b66:	b005      	add	sp, #20
   16b68:	bd30      	pop	{r4, r5, pc}
   16b6a:	bf00      	nop
   16b6c:	200018a4 	.word	0x200018a4

00016b70 <flash_nrf_erase>:
{
   16b70:	b5f0      	push	{r4, r5, r6, r7, lr}
   16b72:	b08b      	sub	sp, #44	; 0x2c
   16b74:	460e      	mov	r6, r1
   16b76:	4615      	mov	r5, r2
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   16b78:	f007 fa9f 	bl	1e0ba <nrfx_nvmc_flash_page_size_get>
	if (is_regular_addr_valid(addr, size)) {
   16b7c:	4629      	mov	r1, r5
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   16b7e:	4607      	mov	r7, r0
	if (is_regular_addr_valid(addr, size)) {
   16b80:	4630      	mov	r0, r6
   16b82:	f007 f9e6 	bl	1df52 <is_regular_addr_valid>
   16b86:	2800      	cmp	r0, #0
   16b88:	d03a      	beq.n	16c00 <flash_nrf_erase+0x90>
		if (((addr % pg_size) != 0) || ((size % pg_size) != 0)) {
   16b8a:	fbb6 f3f7 	udiv	r3, r6, r7
   16b8e:	fb07 6313 	mls	r3, r7, r3, r6
   16b92:	bbab      	cbnz	r3, 16c00 <flash_nrf_erase+0x90>
   16b94:	fbb5 f4f7 	udiv	r4, r5, r7
   16b98:	fb07 5414 	mls	r4, r7, r4, r5
   16b9c:	bb84      	cbnz	r4, 16c00 <flash_nrf_erase+0x90>
		if (!n_pages) {
   16b9e:	42af      	cmp	r7, r5
   16ba0:	d822      	bhi.n	16be8 <flash_nrf_erase+0x78>
	return z_impl_k_sem_take(sem, timeout);
   16ba2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   16ba6:	4818      	ldr	r0, [pc, #96]	; (16c08 <flash_nrf_erase+0x98>)
   16ba8:	f001 fc98 	bl	184dc <z_impl_k_sem_take>
	if (ticker_is_initialized(0)) {
   16bac:	4620      	mov	r0, r4
   16bae:	f7f7 fbf5 	bl	e39c <ticker_is_initialized>
   16bb2:	ab04      	add	r3, sp, #16
   16bb4:	4601      	mov	r1, r0
   16bb6:	b1d0      	cbz	r0, 16bee <flash_nrf_erase+0x7e>
	struct flash_context context = {
   16bb8:	2210      	movs	r2, #16
   16bba:	4621      	mov	r1, r4
   16bbc:	4618      	mov	r0, r3
   16bbe:	f004 fa46 	bl	1b04e <memset>
   16bc2:	2201      	movs	r2, #1
   16bc4:	f88d 201c 	strb.w	r2, [sp, #28]
   16bc8:	4a10      	ldr	r2, [pc, #64]	; (16c0c <flash_nrf_erase+0x9c>)
	struct flash_op_desc flash_op_desc = {
   16bca:	9403      	str	r4, [sp, #12]
	struct flash_context context = {
   16bcc:	e9cd 2208 	strd	r2, r2, [sp, #32]
	struct flash_op_desc flash_op_desc = {
   16bd0:	4a0f      	ldr	r2, [pc, #60]	; (16c10 <flash_nrf_erase+0xa0>)
   16bd2:	e9cd 2001 	strd	r2, r0, [sp, #4]
	return work_in_time_slice(&flash_op_desc);
   16bd6:	a801      	add	r0, sp, #4
	struct flash_context context = {
   16bd8:	e9cd 6505 	strd	r6, r5, [sp, #20]
	return work_in_time_slice(&flash_op_desc);
   16bdc:	f7eb fc64 	bl	24a8 <work_in_time_slice>
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
		.enable_time_limit = 0 /* disable time limit */
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */
	};

	return	erase_op(&context);
   16be0:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
   16be2:	4809      	ldr	r0, [pc, #36]	; (16c08 <flash_nrf_erase+0x98>)
   16be4:	f001 fc4e 	bl	18484 <z_impl_k_sem_give>
}
   16be8:	4620      	mov	r0, r4
   16bea:	b00b      	add	sp, #44	; 0x2c
   16bec:	bdf0      	pop	{r4, r5, r6, r7, pc}
	struct flash_context context = {
   16bee:	2218      	movs	r2, #24
   16bf0:	4618      	mov	r0, r3
   16bf2:	f004 fa2c 	bl	1b04e <memset>
   16bf6:	e9cd 6505 	strd	r6, r5, [sp, #20]
	return	erase_op(&context);
   16bfa:	f7eb fc0d 	bl	2418 <erase_op>
   16bfe:	e7ef      	b.n	16be0 <flash_nrf_erase+0x70>
		return -EINVAL;
   16c00:	f06f 0415 	mvn.w	r4, #21
   16c04:	e7f0      	b.n	16be8 <flash_nrf_erase+0x78>
   16c06:	bf00      	nop
   16c08:	2000188c 	.word	0x2000188c
   16c0c:	00015e64 	.word	0x00015e64
   16c10:	00002419 	.word	0x00002419

00016c14 <flash_nrf_write>:
{
   16c14:	b570      	push	{r4, r5, r6, lr}
   16c16:	460d      	mov	r5, r1
   16c18:	b08a      	sub	sp, #40	; 0x28
	if (is_regular_addr_valid(addr, len)) {
   16c1a:	4619      	mov	r1, r3
   16c1c:	4628      	mov	r0, r5
{
   16c1e:	4616      	mov	r6, r2
   16c20:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
   16c22:	f007 f996 	bl	1df52 <is_regular_addr_valid>
   16c26:	b368      	cbz	r0, 16c84 <flash_nrf_write+0x70>
	if (!len) {
   16c28:	b304      	cbz	r4, 16c6c <flash_nrf_write+0x58>
	return z_impl_k_sem_take(sem, timeout);
   16c2a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   16c2e:	4817      	ldr	r0, [pc, #92]	; (16c8c <flash_nrf_write+0x78>)
   16c30:	f001 fc54 	bl	184dc <z_impl_k_sem_take>
	if (ticker_is_initialized(0)) {
   16c34:	2000      	movs	r0, #0
   16c36:	f7f7 fbb1 	bl	e39c <ticker_is_initialized>
   16c3a:	4603      	mov	r3, r0
   16c3c:	a804      	add	r0, sp, #16
   16c3e:	b1c3      	cbz	r3, 16c72 <flash_nrf_write+0x5e>
	struct flash_context context = {
   16c40:	2301      	movs	r3, #1
   16c42:	f88d 301c 	strb.w	r3, [sp, #28]
   16c46:	f641 534c 	movw	r3, #7500	; 0x1d4c
   16c4a:	e9cd 3308 	strd	r3, r3, [sp, #32]
	struct flash_op_desc flash_op_desc = {
   16c4e:	2300      	movs	r3, #0
   16c50:	9303      	str	r3, [sp, #12]
   16c52:	4b0f      	ldr	r3, [pc, #60]	; (16c90 <flash_nrf_write+0x7c>)
	struct flash_context context = {
   16c54:	9406      	str	r4, [sp, #24]
	struct flash_op_desc flash_op_desc = {
   16c56:	e9cd 3001 	strd	r3, r0, [sp, #4]
	return  work_in_time_slice(&flash_op_desc);
   16c5a:	a801      	add	r0, sp, #4
	struct flash_context context = {
   16c5c:	e9cd 6504 	strd	r6, r5, [sp, #16]
	return  work_in_time_slice(&flash_op_desc);
   16c60:	f7eb fc22 	bl	24a8 <work_in_time_slice>
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
		.enable_time_limit = 0 /* disable time limit */
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */
	};

	return write_op(&context);
   16c64:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
   16c66:	4809      	ldr	r0, [pc, #36]	; (16c8c <flash_nrf_write+0x78>)
   16c68:	f001 fc0c 	bl	18484 <z_impl_k_sem_give>
}
   16c6c:	4620      	mov	r0, r4
   16c6e:	b00a      	add	sp, #40	; 0x28
   16c70:	bd70      	pop	{r4, r5, r6, pc}
	struct flash_context context = {
   16c72:	e9cd 3307 	strd	r3, r3, [sp, #28]
   16c76:	9309      	str	r3, [sp, #36]	; 0x24
   16c78:	e9cd 6504 	strd	r6, r5, [sp, #16]
   16c7c:	9406      	str	r4, [sp, #24]
	return write_op(&context);
   16c7e:	f7eb fc87 	bl	2590 <write_op>
   16c82:	e7ef      	b.n	16c64 <flash_nrf_write+0x50>
		return -EINVAL;
   16c84:	f06f 0415 	mvn.w	r4, #21
   16c88:	e7f0      	b.n	16c6c <flash_nrf_write+0x58>
   16c8a:	bf00      	nop
   16c8c:	2000188c 	.word	0x2000188c
   16c90:	00002591 	.word	0x00002591

00016c94 <rng_pool_get>:
#pragma GCC push_options
#if defined(CONFIG_BT_CTLR_FAST_ENC)
#pragma GCC optimize ("Ofast")
#endif
static u16_t rng_pool_get(struct rng_pool *rngp, u8_t *buf, u16_t len)
{
   16c94:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32_t last  = rngp->last;
   16c96:	7883      	ldrb	r3, [r0, #2]
	u32_t mask  = rngp->mask;
   16c98:	78c7      	ldrb	r7, [r0, #3]
	__asm__ volatile(
   16c9a:	f04f 0420 	mov.w	r4, #32
   16c9e:	f3ef 8e11 	mrs	lr, BASEPRI
   16ca2:	f384 8811 	msr	BASEPRI, r4
   16ca6:	f3bf 8f6f 	isb	sy
	u32_t first, available;
	u32_t other_read_in_progress;
	unsigned int key;

	key = irq_lock();
	first = rngp->first_alloc;
   16caa:	7806      	ldrb	r6, [r0, #0]
	/*
	 * The other_read_in_progress is non-zero if rngp->first_read != first,
	 * which means that lower-priority code (which was interrupted by this
	 * call) already allocated area for read.
	 */
	other_read_in_progress = (rngp->first_read ^ first);
   16cac:	f890 c001 	ldrb.w	ip, [r0, #1]

	available = (last - first) & mask;
   16cb0:	1b9b      	subs	r3, r3, r6
   16cb2:	403b      	ands	r3, r7
	if (available < len) {
   16cb4:	429a      	cmp	r2, r3
		len = available;
   16cb6:	bf88      	it	hi
   16cb8:	b29a      	uxthhi	r2, r3

	/*
	 * Move alloc index forward to signal, that part of the buffer is
	 * now reserved for this call.
	 */
	rngp->first_alloc = (first + len) & mask;
   16cba:	18b4      	adds	r4, r6, r2
   16cbc:	403c      	ands	r4, r7
	first = rngp->first_alloc;
   16cbe:	4635      	mov	r5, r6
	rngp->first_alloc = (first + len) & mask;
   16cc0:	7004      	strb	r4, [r0, #0]
	__asm__ volatile(
   16cc2:	f38e 8811 	msr	BASEPRI, lr
   16cc6:	f3bf 8f6f 	isb	sy
   16cca:	440a      	add	r2, r1
	u8_t *dst   = buf;
   16ccc:	460c      	mov	r4, r1
	irq_unlock(key);

	while (likely(len--)) {
   16cce:	42a2      	cmp	r2, r4
   16cd0:	d11a      	bne.n	16d08 <rng_pool_get+0x74>
	/*
	 * If this call is the last one accessing the pool, move read index
	 * to signal that all allocated regions are now read and could be
	 * overwritten.
	 */
	if (likely(!other_read_in_progress)) {
   16cd2:	4566      	cmp	r6, ip
   16cd4:	d10d      	bne.n	16cf2 <rng_pool_get+0x5e>
	__asm__ volatile(
   16cd6:	f04f 0520 	mov.w	r5, #32
   16cda:	f3ef 8211 	mrs	r2, BASEPRI
   16cde:	f385 8811 	msr	BASEPRI, r5
   16ce2:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		rngp->first_read = rngp->first_alloc;
   16ce6:	7805      	ldrb	r5, [r0, #0]
   16ce8:	7045      	strb	r5, [r0, #1]
	__asm__ volatile(
   16cea:	f382 8811 	msr	BASEPRI, r2
   16cee:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}

	len = dst - buf;
   16cf2:	1a64      	subs	r4, r4, r1
   16cf4:	b2a2      	uxth	r2, r4
	available = available - len;
	if (available <= rngp->threshold) {
   16cf6:	7901      	ldrb	r1, [r0, #4]
	available = available - len;
   16cf8:	1a9c      	subs	r4, r3, r2
	if (available <= rngp->threshold) {
   16cfa:	42a1      	cmp	r1, r4
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)rng_task);
}

NRF_STATIC_INLINE void nrf_rng_task_trigger(NRF_RNG_Type * p_reg, nrf_rng_task_t rng_task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   16cfc:	bf22      	ittt	cs
   16cfe:	4b07      	ldrcs	r3, [pc, #28]	; (16d1c <rng_pool_get+0x88>)
   16d00:	2101      	movcs	r1, #1
   16d02:	6019      	strcs	r1, [r3, #0]
		nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);
	}

	return len;
}
   16d04:	4610      	mov	r0, r2
   16d06:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*dst++ = rngp->buffer[first];
   16d08:	eb00 0e05 	add.w	lr, r0, r5
		first = (first + 1) & mask;
   16d0c:	3501      	adds	r5, #1
		*dst++ = rngp->buffer[first];
   16d0e:	f89e e005 	ldrb.w	lr, [lr, #5]
   16d12:	f804 eb01 	strb.w	lr, [r4], #1
		first = (first + 1) & mask;
   16d16:	403d      	ands	r5, r7
   16d18:	e7d9      	b.n	16cce <rng_pool_get+0x3a>
   16d1a:	bf00      	nop
   16d1c:	4000d000 	.word	0x4000d000

00016d20 <entropy_nrf5_get_entropy>:
		k_sem_give(&entropy_nrf5_data.sem_sync);
	}
}

static int entropy_nrf5_get_entropy(struct device *device, u8_t *buf, u16_t len)
{
   16d20:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return z_impl_k_sem_take(sem, timeout);
   16d24:	4d11      	ldr	r5, [pc, #68]	; (16d6c <entropy_nrf5_get_entropy+0x4c>)
   16d26:	460e      	mov	r6, r1
   16d28:	4614      	mov	r4, r2

	while (len) {
		u16_t bytes;

		k_sem_take(&entropy_nrf5_data.sem_lock, K_FOREVER);
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
   16d2a:	f105 0845 	add.w	r8, r5, #69	; 0x45
   16d2e:	f105 0918 	add.w	r9, r5, #24
	while (len) {
   16d32:	b914      	cbnz	r4, 16d3a <entropy_nrf5_get_entropy+0x1a>
		len -= bytes;
		buf += bytes;
	}

	return 0;
}
   16d34:	4620      	mov	r0, r4
   16d36:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   16d3a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   16d3e:	4628      	mov	r0, r5
   16d40:	f001 fbcc 	bl	184dc <z_impl_k_sem_take>
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
   16d44:	4622      	mov	r2, r4
   16d46:	4631      	mov	r1, r6
   16d48:	4640      	mov	r0, r8
   16d4a:	f7ff ffa3 	bl	16c94 <rng_pool_get>
   16d4e:	4607      	mov	r7, r0
	z_impl_k_sem_give(sem);
   16d50:	4628      	mov	r0, r5
   16d52:	f001 fb97 	bl	18484 <z_impl_k_sem_give>
		if (bytes == 0U) {
   16d56:	b92f      	cbnz	r7, 16d64 <entropy_nrf5_get_entropy+0x44>
	return z_impl_k_sem_take(sem, timeout);
   16d58:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   16d5c:	4648      	mov	r0, r9
   16d5e:	f001 fbbd 	bl	184dc <z_impl_k_sem_take>
   16d62:	e7e6      	b.n	16d32 <entropy_nrf5_get_entropy+0x12>
		len -= bytes;
   16d64:	1be4      	subs	r4, r4, r7
   16d66:	b2a4      	uxth	r4, r4
		buf += bytes;
   16d68:	443e      	add	r6, r7
   16d6a:	e7e2      	b.n	16d32 <entropy_nrf5_get_entropy+0x12>
   16d6c:	200018bc 	.word	0x200018bc

00016d70 <random_byte_get>:
{
   16d70:	b082      	sub	sp, #8
	__asm__ volatile(
   16d72:	f04f 0320 	mov.w	r3, #32
   16d76:	f3ef 8211 	mrs	r2, BASEPRI
   16d7a:	f383 8811 	msr	BASEPRI, r3
   16d7e:	f3bf 8f6f 	isb	sy
#endif
}

NRF_STATIC_INLINE bool nrf_rng_event_check(NRF_RNG_Type const * p_reg, nrf_rng_event_t rng_event)
{
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   16d82:	4b0a      	ldr	r3, [pc, #40]	; (16dac <random_byte_get+0x3c>)
   16d84:	6819      	ldr	r1, [r3, #0]
	if (nrf_rng_event_check(NRF_RNG, NRF_RNG_EVENT_VALRDY)) {
   16d86:	b171      	cbz	r1, 16da6 <random_byte_get+0x36>
     p_reg->SHORTS &= ~mask;
}

NRF_STATIC_INLINE uint8_t nrf_rng_random_value_get(NRF_RNG_Type const * p_reg)
{
    return (uint8_t)(p_reg->VALUE & RNG_VALUE_VALUE_Msk);
   16d88:	4909      	ldr	r1, [pc, #36]	; (16db0 <random_byte_get+0x40>)
   16d8a:	f8d1 0508 	ldr.w	r0, [r1, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   16d8e:	2100      	movs	r1, #0
   16d90:	6019      	str	r1, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   16d92:	681b      	ldr	r3, [r3, #0]
   16d94:	9301      	str	r3, [sp, #4]
    (void)dummy;
   16d96:	9b01      	ldr	r3, [sp, #4]
		retval = nrf_rng_random_value_get(NRF_RNG);
   16d98:	b2c0      	uxtb	r0, r0
	__asm__ volatile(
   16d9a:	f382 8811 	msr	BASEPRI, r2
   16d9e:	f3bf 8f6f 	isb	sy
}
   16da2:	b002      	add	sp, #8
   16da4:	4770      	bx	lr
	int retval = -EAGAIN;
   16da6:	f06f 000a 	mvn.w	r0, #10
   16daa:	e7f6      	b.n	16d9a <random_byte_get+0x2a>
   16dac:	4000d100 	.word	0x4000d100
   16db0:	4000d000 	.word	0x4000d000

00016db4 <entropy_nrf5_get_entropy_isr>:
	u16_t cnt = len;

	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == DEV_DATA(dev));

	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
   16db4:	07db      	lsls	r3, r3, #31
{
   16db6:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   16dba:	4688      	mov	r8, r1
   16dbc:	4614      	mov	r4, r2
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
   16dbe:	d405      	bmi.n	16dcc <entropy_nrf5_get_entropy_isr+0x18>
		return rng_pool_get((struct rng_pool *)(entropy_nrf5_data.isr),
   16dc0:	4820      	ldr	r0, [pc, #128]	; (16e44 <entropy_nrf5_get_entropy_isr+0x90>)
   16dc2:	f7ff ff67 	bl	16c94 <rng_pool_get>
			irq_enable(RNG_IRQn);
		}
	}

	return cnt;
}
   16dc6:	b002      	add	sp, #8
   16dc8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
   16dcc:	2a00      	cmp	r2, #0
   16dce:	d032      	beq.n	16e36 <entropy_nrf5_get_entropy_isr+0x82>
	__asm__ volatile(
   16dd0:	f04f 0320 	mov.w	r3, #32
   16dd4:	f3ef 8511 	mrs	r5, BASEPRI
   16dd8:	f383 8811 	msr	BASEPRI, r3
   16ddc:	f3bf 8f6f 	isb	sy
		irq_enabled = irq_is_enabled(RNG_IRQn);
   16de0:	200d      	movs	r0, #13
   16de2:	f7ed fadd 	bl	43a0 <arch_irq_is_enabled>
   16de6:	4607      	mov	r7, r0
		irq_disable(RNG_IRQn);
   16de8:	200d      	movs	r0, #13
   16dea:	f7ed fac5 	bl	4378 <arch_irq_disable>
	__asm__ volatile(
   16dee:	f385 8811 	msr	BASEPRI, r5
   16df2:	f3bf 8f6f 	isb	sy
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   16df6:	4e14      	ldr	r6, [pc, #80]	; (16e48 <entropy_nrf5_get_entropy_isr+0x94>)
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   16df8:	f8df 9054 	ldr.w	r9, [pc, #84]	; 16e50 <entropy_nrf5_get_entropy_isr+0x9c>
   16dfc:	2200      	movs	r2, #0
   16dfe:	6032      	str	r2, [r6, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   16e00:	6832      	ldr	r2, [r6, #0]
   16e02:	9201      	str	r2, [sp, #4]
    (void)dummy;
   16e04:	9a01      	ldr	r2, [sp, #4]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   16e06:	4a11      	ldr	r2, [pc, #68]	; (16e4c <entropy_nrf5_get_entropy_isr+0x98>)
   16e08:	2101      	movs	r1, #1
   16e0a:	6011      	str	r1, [r2, #0]
   16e0c:	4625      	mov	r5, r4
   16e0e:	f44f 5a00 	mov.w	sl, #8192	; 0x2000
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   16e12:	6833      	ldr	r3, [r6, #0]
			while (!nrf_rng_event_check(NRF_RNG,
   16e14:	b18b      	cbz	r3, 16e3a <entropy_nrf5_get_entropy_isr+0x86>
			byte = random_byte_get();
   16e16:	f7ff ffab 	bl	16d70 <random_byte_get>
			if (byte < 0) {
   16e1a:	2800      	cmp	r0, #0
   16e1c:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
   16e20:	dbf7      	blt.n	16e12 <entropy_nrf5_get_entropy_isr+0x5e>
   16e22:	3d01      	subs	r5, #1
   16e24:	b2ad      	uxth	r5, r5
			buf[--len] = byte;
   16e26:	f808 0005 	strb.w	r0, [r8, r5]
		} while (len);
   16e2a:	2d00      	cmp	r5, #0
   16e2c:	d1f1      	bne.n	16e12 <entropy_nrf5_get_entropy_isr+0x5e>
		if (irq_enabled) {
   16e2e:	b117      	cbz	r7, 16e36 <entropy_nrf5_get_entropy_isr+0x82>
			irq_enable(RNG_IRQn);
   16e30:	200d      	movs	r0, #13
   16e32:	f7ed fa91 	bl	4358 <arch_irq_enable>
	return cnt;
   16e36:	4620      	mov	r0, r4
   16e38:	e7c5      	b.n	16dc6 <entropy_nrf5_get_entropy_isr+0x12>
				__WFE();
   16e3a:	bf20      	wfe
				__SEV();
   16e3c:	bf40      	sev
				__WFE();
   16e3e:	bf20      	wfe
   16e40:	e7e7      	b.n	16e12 <entropy_nrf5_get_entropy_isr+0x5e>
   16e42:	bf00      	nop
   16e44:	200018ec 	.word	0x200018ec
   16e48:	4000d100 	.word	0x4000d100
   16e4c:	4000d000 	.word	0x4000d000
   16e50:	e000e100 	.word	0xe000e100

00016e54 <entropy_nrf5_init>:
		    entropy_nrf5_init, &entropy_nrf5_data, NULL,
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &entropy_nrf5_api_funcs);

static int entropy_nrf5_init(struct device *device)
{
   16e54:	b537      	push	{r0, r1, r2, r4, r5, lr}
	z_impl_k_sem_init(sem, initial_count, limit);
   16e56:	4c1b      	ldr	r4, [pc, #108]	; (16ec4 <entropy_nrf5_init+0x70>)
   16e58:	2201      	movs	r2, #1
   16e5a:	4611      	mov	r1, r2
   16e5c:	4620      	mov	r0, r4
   16e5e:	f007 fbf7 	bl	1e650 <z_impl_k_sem_init>
   16e62:	2201      	movs	r2, #1
   16e64:	f104 0018 	add.w	r0, r4, #24
   16e68:	2100      	movs	r1, #0
   16e6a:	f007 fbf1 	bl	1e650 <z_impl_k_sem_init>
	rngp->mask	  = size - 1;
   16e6e:	f240 4307 	movw	r3, #1031	; 0x407
   16e72:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
	rngp->first_alloc = 0U;
   16e76:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   16e7a:	6323      	str	r3, [r4, #48]	; 0x30
	rngp->threshold	  = threshold;
   16e7c:	230c      	movs	r3, #12
   16e7e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	rngp->first_alloc = 0U;
   16e82:	2500      	movs	r5, #0
}

NRF_STATIC_INLINE void nrf_rng_error_correction_enable(NRF_RNG_Type * p_reg)
{
    p_reg->CONFIG |= RNG_CONFIG_DERCEN_Msk;
   16e84:	4b10      	ldr	r3, [pc, #64]	; (16ec8 <entropy_nrf5_init+0x74>)
   16e86:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
	rngp->first_read  = 0U;
   16e8a:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
   16e8e:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   16e92:	f042 0201 	orr.w	r2, r2, #1
   16e96:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   16e9a:	4a0c      	ldr	r2, [pc, #48]	; (16ecc <entropy_nrf5_init+0x78>)
   16e9c:	6015      	str	r5, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   16e9e:	6812      	ldr	r2, [r2, #0]
   16ea0:	9201      	str	r2, [sp, #4]
    (void)dummy;
   16ea2:	9a01      	ldr	r2, [sp, #4]
    p_reg->INTENSET = mask;
   16ea4:	2201      	movs	r2, #1
   16ea6:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

	nrf_rng_event_clear(NRF_RNG, NRF_RNG_EVENT_VALRDY);
	nrf_rng_int_enable(NRF_RNG, NRF_RNG_INT_VALRDY_MASK);
	nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);

	IRQ_CONNECT(RNG_IRQn, CONFIG_ENTROPY_NRF5_PRI, isr,
   16eaa:	2105      	movs	r1, #5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   16eac:	601a      	str	r2, [r3, #0]
   16eae:	200d      	movs	r0, #13
   16eb0:	462a      	mov	r2, r5
   16eb2:	f7ed fa83 	bl	43bc <z_arm_irq_priority_set>
		    &entropy_nrf5_data, 0);
	irq_enable(RNG_IRQn);
   16eb6:	200d      	movs	r0, #13
   16eb8:	f7ed fa4e 	bl	4358 <arch_irq_enable>

	return 0;
}
   16ebc:	4628      	mov	r0, r5
   16ebe:	b003      	add	sp, #12
   16ec0:	bd30      	pop	{r4, r5, pc}
   16ec2:	bf00      	nop
   16ec4:	200018bc 	.word	0x200018bc
   16ec8:	4000d000 	.word	0x4000d000
   16ecc:	4000d100 	.word	0x4000d100

00016ed0 <isr>:
{
   16ed0:	b510      	push	{r4, lr}
	byte = random_byte_get();
   16ed2:	f7ff ff4d 	bl	16d70 <random_byte_get>
	if (byte < 0) {
   16ed6:	2800      	cmp	r0, #0
   16ed8:	db20      	blt.n	16f1c <isr+0x4c>
	u8_t last  = rngp->last;
   16eda:	4b17      	ldr	r3, [pc, #92]	; (16f38 <isr+0x68>)
   16edc:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	if (((last - first) & mask) == mask) {
   16ee0:	f893 1031 	ldrb.w	r1, [r3, #49]	; 0x31
	u8_t mask  = rngp->mask;
   16ee4:	f893 4033 	ldrb.w	r4, [r3, #51]	; 0x33
	if (((last - first) & mask) == mask) {
   16ee8:	1a51      	subs	r1, r2, r1
   16eea:	ea34 0101 	bics.w	r1, r4, r1
	ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.isr), byte);
   16eee:	b2c0      	uxtb	r0, r0
	if (((last - first) & mask) == mask) {
   16ef0:	d10d      	bne.n	16f0e <isr+0x3e>
	u8_t last  = rngp->last;
   16ef2:	f893 2047 	ldrb.w	r2, [r3, #71]	; 0x47
	if (((last - first) & mask) == mask) {
   16ef6:	f893 1046 	ldrb.w	r1, [r3, #70]	; 0x46
	u8_t mask  = rngp->mask;
   16efa:	f893 4048 	ldrb.w	r4, [r3, #72]	; 0x48
	if (((last - first) & mask) == mask) {
   16efe:	1a51      	subs	r1, r2, r1
   16f00:	ea34 0101 	bics.w	r1, r4, r1
   16f04:	d10b      	bne.n	16f1e <isr+0x4e>
   16f06:	4b0d      	ldr	r3, [pc, #52]	; (16f3c <isr+0x6c>)
   16f08:	2201      	movs	r2, #1
   16f0a:	601a      	str	r2, [r3, #0]
   16f0c:	e00e      	b.n	16f2c <isr+0x5c>
	rngp->buffer[last] = byte;
   16f0e:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
   16f10:	3201      	adds	r2, #1
   16f12:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
   16f14:	f881 0035 	strb.w	r0, [r1, #53]	; 0x35
	rngp->last = (last + 1) & mask;
   16f18:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
}
   16f1c:	bd10      	pop	{r4, pc}
	rngp->buffer[last] = byte;
   16f1e:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
   16f20:	3201      	adds	r2, #1
   16f22:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
   16f24:	f881 004a 	strb.w	r0, [r1, #74]	; 0x4a
	rngp->last = (last + 1) & mask;
   16f28:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
	z_impl_k_sem_give(sem);
   16f2c:	4804      	ldr	r0, [pc, #16]	; (16f40 <isr+0x70>)
}
   16f2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   16f32:	f001 baa7 	b.w	18484 <z_impl_k_sem_give>
   16f36:	bf00      	nop
   16f38:	200018bc 	.word	0x200018bc
   16f3c:	4000d004 	.word	0x4000d004
   16f40:	200018d4 	.word	0x200018d4

00016f44 <errata_108>:
static bool errata_12(void)
{
    uint32_t var1;
    uint32_t var2;

    if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
   16f44:	4b04      	ldr	r3, [pc, #16]	; (16f58 <errata_108+0x14>)
   16f46:	6818      	ldr	r0, [r3, #0]
   16f48:	1c42      	adds	r2, r0, #1
    {
        var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   16f4a:	bf04      	itt	eq
   16f4c:	4b03      	ldreq	r3, [pc, #12]	; (16f5c <errata_108+0x18>)
   16f4e:	7818      	ldrbeq	r0, [r3, #0]
        break;

    }

    return false;
}
   16f50:	1f83      	subs	r3, r0, #6
   16f52:	4258      	negs	r0, r3
   16f54:	4158      	adcs	r0, r3
   16f56:	4770      	bx	lr
   16f58:	10000130 	.word	0x10000130
   16f5c:	f0000fe0 	.word	0xf0000fe0

00016f60 <errata_16>:
    return false;
}

static bool errata_16(void)
{
    uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   16f60:	4b07      	ldr	r3, [pc, #28]	; (16f80 <errata_16+0x20>)
   16f62:	781b      	ldrb	r3, [r3, #0]
    uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;

    switch(var1)
   16f64:	2b06      	cmp	r3, #6
   16f66:	d109      	bne.n	16f7c <errata_16+0x1c>
    uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   16f68:	4b06      	ldr	r3, [pc, #24]	; (16f84 <errata_16+0x24>)
   16f6a:	681b      	ldr	r3, [r3, #0]
   16f6c:	f3c3 1303 	ubfx	r3, r3, #4, #4
   16f70:	3b03      	subs	r3, #3
   16f72:	2b03      	cmp	r3, #3
   16f74:	d802      	bhi.n	16f7c <errata_16+0x1c>
   16f76:	4a04      	ldr	r2, [pc, #16]	; (16f88 <errata_16+0x28>)
   16f78:	5cd0      	ldrb	r0, [r2, r3]
   16f7a:	4770      	bx	lr
            }
        break;

    }

    return false;
   16f7c:	2000      	movs	r0, #0
}
   16f7e:	4770      	bx	lr
   16f80:	f0000fe0 	.word	0xf0000fe0
   16f84:	f0000fe8 	.word	0xf0000fe8
   16f88:	00022601 	.word	0x00022601

00016f8c <SystemInit>:
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
}

void SystemInit(void)
{
   16f8c:	b508      	push	{r3, lr}
        NRF_P0->PIN_CNF[20] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
    #endif
    
    /* Workaround for Errata 12 "COMP: Reference ladder not correctly calibrated" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp */
    if (errata_12()){
   16f8e:	f7ff ffd9 	bl	16f44 <errata_108>
   16f92:	b128      	cbz	r0, 16fa0 <SystemInit+0x14>
        *(volatile uint32_t *)0x40013540 = (*(uint32_t *)0x10000324 & 0x00001F00) >> 8;
   16f94:	4b7c      	ldr	r3, [pc, #496]	; (17188 <SystemInit+0x1fc>)
   16f96:	4a7d      	ldr	r2, [pc, #500]	; (1718c <SystemInit+0x200>)
   16f98:	681b      	ldr	r3, [r3, #0]
   16f9a:	f3c3 2304 	ubfx	r3, r3, #8, #5
   16f9e:	6013      	str	r3, [r2, #0]
    }
    
    /* Workaround for Errata 16 "System: RAM may be corrupt on wakeup from CPU IDLE" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp */
    if (errata_16()){
   16fa0:	f7ff ffde 	bl	16f60 <errata_16>
   16fa4:	b110      	cbz	r0, 16fac <SystemInit+0x20>
        *(volatile uint32_t *)0x4007C074 = 3131961357ul;
   16fa6:	4b7a      	ldr	r3, [pc, #488]	; (17190 <SystemInit+0x204>)
   16fa8:	4a7a      	ldr	r2, [pc, #488]	; (17194 <SystemInit+0x208>)
   16faa:	601a      	str	r2, [r3, #0]
    }

    /* Workaround for Errata 31 "CLOCK: Calibration values are not correctly loaded from FICR at reset" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp */
    if (errata_31()){
   16fac:	f7ff ffca 	bl	16f44 <errata_108>
   16fb0:	b128      	cbz	r0, 16fbe <SystemInit+0x32>
        *(volatile uint32_t *)0x4000053C = ((*(volatile uint32_t *)0x10000244) & 0x0000E000) >> 13;
   16fb2:	4b79      	ldr	r3, [pc, #484]	; (17198 <SystemInit+0x20c>)
   16fb4:	4a79      	ldr	r2, [pc, #484]	; (1719c <SystemInit+0x210>)
   16fb6:	681b      	ldr	r3, [r3, #0]
   16fb8:	f3c3 3342 	ubfx	r3, r3, #13, #3
   16fbc:	6013      	str	r3, [r2, #0]
    }

    /* Workaround for Errata 32 "DIF: Debug session automatically enables TracePort pins" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp */
    if (errata_32()){
   16fbe:	f7ff ffcf 	bl	16f60 <errata_16>
   16fc2:	b120      	cbz	r0, 16fce <SystemInit+0x42>
        CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk;
   16fc4:	4a76      	ldr	r2, [pc, #472]	; (171a0 <SystemInit+0x214>)
   16fc6:	68d3      	ldr	r3, [r2, #12]
   16fc8:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   16fcc:	60d3      	str	r3, [r2, #12]
    }

    /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_36()){
   16fce:	f7ff ffb9 	bl	16f44 <errata_108>
   16fd2:	b140      	cbz	r0, 16fe6 <SystemInit+0x5a>
        NRF_CLOCK->EVENTS_DONE = 0;
   16fd4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   16fd8:	2200      	movs	r2, #0
   16fda:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
        NRF_CLOCK->EVENTS_CTTO = 0;
   16fde:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
        NRF_CLOCK->CTIV = 0;
   16fe2:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    }

    /* Workaround for Errata 37 "RADIO: Encryption engine is slow by default" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_37()){
   16fe6:	f7ff ffbb 	bl	16f60 <errata_16>
   16fea:	b110      	cbz	r0, 16ff2 <SystemInit+0x66>
        *(volatile uint32_t *)0x400005A0 = 0x3;
   16fec:	4b6d      	ldr	r3, [pc, #436]	; (171a4 <SystemInit+0x218>)
   16fee:	2203      	movs	r2, #3
   16ff0:	601a      	str	r2, [r3, #0]
    }

    /* Workaround for Errata 57 "NFCT: NFC Modulation amplitude" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_57()){
   16ff2:	f7ff ffb5 	bl	16f60 <errata_16>
   16ff6:	b140      	cbz	r0, 1700a <SystemInit+0x7e>
        *(volatile uint32_t *)0x40005610 = 0x00000005;
   16ff8:	4b6b      	ldr	r3, [pc, #428]	; (171a8 <SystemInit+0x21c>)
   16ffa:	2205      	movs	r2, #5
   16ffc:	601a      	str	r2, [r3, #0]
        *(volatile uint32_t *)0x40005688 = 0x00000001;
   16ffe:	2201      	movs	r2, #1
   17000:	679a      	str	r2, [r3, #120]	; 0x78
        *(volatile uint32_t *)0x40005618 = 0x00000000;
   17002:	2200      	movs	r2, #0
   17004:	609a      	str	r2, [r3, #8]
        *(volatile uint32_t *)0x40005614 = 0x0000003F;
   17006:	223f      	movs	r2, #63	; 0x3f
   17008:	605a      	str	r2, [r3, #4]
static bool errata_66(void)
{
    uint32_t var1;
    uint32_t var2;

    if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
   1700a:	4b68      	ldr	r3, [pc, #416]	; (171ac <SystemInit+0x220>)
   1700c:	681a      	ldr	r2, [r3, #0]
   1700e:	1c51      	adds	r1, r2, #1
    {
        var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   17010:	bf0b      	itete	eq
   17012:	4b67      	ldreq	r3, [pc, #412]	; (171b0 <SystemInit+0x224>)
        var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    }
    else
    {
        var1 = *(uint32_t *)0x10000130ul;
        var2 = *(uint32_t *)0x10000134ul;
   17014:	4b67      	ldrne	r3, [pc, #412]	; (171b4 <SystemInit+0x228>)
        var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   17016:	781a      	ldrbeq	r2, [r3, #0]
        var2 = *(uint32_t *)0x10000134ul;
   17018:	681b      	ldrne	r3, [r3, #0]
        var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   1701a:	bf02      	ittt	eq
   1701c:	3308      	addeq	r3, #8
   1701e:	681b      	ldreq	r3, [r3, #0]
   17020:	f3c3 1303 	ubfxeq	r3, r3, #4, #4
    }

    switch(var1)
   17024:	2a06      	cmp	r2, #6
   17026:	d14d      	bne.n	170c4 <SystemInit+0x138>
    {
        case 0x06:
            switch(var2)
   17028:	3b03      	subs	r3, #3
   1702a:	2b03      	cmp	r3, #3
   1702c:	d803      	bhi.n	17036 <SystemInit+0xaa>
    }

    /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_66()){
   1702e:	4a62      	ldr	r2, [pc, #392]	; (171b8 <SystemInit+0x22c>)
   17030:	5cd3      	ldrb	r3, [r2, r3]
   17032:	2b00      	cmp	r3, #0
   17034:	d046      	beq.n	170c4 <SystemInit+0x138>
        NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
   17036:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1703a:	4b60      	ldr	r3, [pc, #384]	; (171bc <SystemInit+0x230>)
   1703c:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
   17040:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
        NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
   17044:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
   17048:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
        NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
   1704c:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
   17050:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
        NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
   17054:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
   17058:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
        NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
   1705c:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
   17060:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
        NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
   17064:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
   17068:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
        NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
   1706c:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
   17070:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
        NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
   17074:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
   17078:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
        NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
   1707c:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
   17080:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
        NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
   17084:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
   17088:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
        NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
   1708c:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
   17090:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
        NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
   17094:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
   17098:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
        NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
   1709c:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
   170a0:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
        NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
   170a4:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
   170a8:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
        NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
   170ac:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
   170b0:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
        NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
   170b4:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
   170b8:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
        NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
   170bc:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
   170c0:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    }

    /* Workaround for Errata 108 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_108()){
   170c4:	f7ff ff3e 	bl	16f44 <errata_108>
   170c8:	b128      	cbz	r0, 170d6 <SystemInit+0x14a>
        *(volatile uint32_t *)0x40000EE4ul = *(volatile uint32_t *)0x10000258ul & 0x0000004Ful;
   170ca:	4b3d      	ldr	r3, [pc, #244]	; (171c0 <SystemInit+0x234>)
   170cc:	4a3d      	ldr	r2, [pc, #244]	; (171c4 <SystemInit+0x238>)
   170ce:	681b      	ldr	r3, [r3, #0]
   170d0:	f003 034f 	and.w	r3, r3, #79	; 0x4f
   170d4:	6013      	str	r3, [r2, #0]
    }
    
    /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_136()){
   170d6:	f7ff ff35 	bl	16f44 <errata_108>
   170da:	b148      	cbz	r0, 170f0 <SystemInit+0x164>
        if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
   170dc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   170e0:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
   170e4:	07d2      	lsls	r2, r2, #31
            NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
   170e6:	bf44      	itt	mi
   170e8:	f06f 0201 	mvnmi.w	r2, #1
   170ec:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400
    return false;
}

static bool errata_182(void)
{
    uint32_t var1 = *(uint32_t *)0x10000130ul;
   170f0:	4b2e      	ldr	r3, [pc, #184]	; (171ac <SystemInit+0x220>)
    uint32_t var2 = *(uint32_t *)0x10000134ul;

    switch(var1)
   170f2:	681b      	ldr	r3, [r3, #0]
   170f4:	2b06      	cmp	r3, #6
   170f6:	d109      	bne.n	1710c <SystemInit+0x180>
    uint32_t var2 = *(uint32_t *)0x10000134ul;
   170f8:	4b2e      	ldr	r3, [pc, #184]	; (171b4 <SystemInit+0x228>)
    {
        case 0x06:
            switch(var2)
   170fa:	681b      	ldr	r3, [r3, #0]
   170fc:	3b03      	subs	r3, #3
   170fe:	2b02      	cmp	r3, #2
    }
    
    /* Workaround for Errata 182 "RADIO: Fixes for anomalies #102, #106, and #107 do not take effect" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_182()){
        *(volatile uint32_t *) 0x4000173C |= (0x1 << 10);
   17100:	bf81      	itttt	hi
   17102:	4a31      	ldrhi	r2, [pc, #196]	; (171c8 <SystemInit+0x23c>)
   17104:	6813      	ldrhi	r3, [r2, #0]
   17106:	f443 6380 	orrhi.w	r3, r3, #1024	; 0x400
   1710a:	6013      	strhi	r3, [r2, #0]

    /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
      defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
      reserved for PinReset and not available as normal GPIO. */
    #if defined (CONFIG_GPIO_AS_PINRESET)
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
   1710c:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   17110:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   17114:	2a00      	cmp	r2, #0
   17116:	db03      	blt.n	17120 <SystemInit+0x194>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
   17118:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
   1711c:	2b00      	cmp	r3, #0
   1711e:	da2f      	bge.n	17180 <SystemInit+0x1f4>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
   17120:	4b2a      	ldr	r3, [pc, #168]	; (171cc <SystemInit+0x240>)
   17122:	2201      	movs	r2, #1
   17124:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   17128:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
   1712c:	2a00      	cmp	r2, #0
   1712e:	d0fb      	beq.n	17128 <SystemInit+0x19c>
            NRF_UICR->PSELRESET[0] = 21;
   17130:	f04f 2210 	mov.w	r2, #268439552	; 0x10001000
   17134:	2115      	movs	r1, #21
   17136:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   1713a:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
   1713e:	2a00      	cmp	r2, #0
   17140:	d0fb      	beq.n	1713a <SystemInit+0x1ae>
            NRF_UICR->PSELRESET[1] = 21;
   17142:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   17146:	2215      	movs	r2, #21
   17148:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   1714c:	4b1f      	ldr	r3, [pc, #124]	; (171cc <SystemInit+0x240>)
   1714e:	461a      	mov	r2, r3
   17150:	f8d3 1400 	ldr.w	r1, [r3, #1024]	; 0x400
   17154:	2900      	cmp	r1, #0
   17156:	d0fb      	beq.n	17150 <SystemInit+0x1c4>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
   17158:	2100      	movs	r1, #0
   1715a:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   1715e:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
   17162:	2b00      	cmp	r3, #0
   17164:	d0fb      	beq.n	1715e <SystemInit+0x1d2>
  __ASM volatile ("dsb 0xF":::"memory");
   17166:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   1716a:	4919      	ldr	r1, [pc, #100]	; (171d0 <SystemInit+0x244>)
   1716c:	4b19      	ldr	r3, [pc, #100]	; (171d4 <SystemInit+0x248>)
   1716e:	68ca      	ldr	r2, [r1, #12]
   17170:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   17174:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   17176:	60cb      	str	r3, [r1, #12]
   17178:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   1717c:	bf00      	nop
   1717e:	e7fd      	b.n	1717c <SystemInit+0x1f0>
    SystemCoreClock = __SYSTEM_CLOCK_64M;
   17180:	4b15      	ldr	r3, [pc, #84]	; (171d8 <SystemInit+0x24c>)
   17182:	4a16      	ldr	r2, [pc, #88]	; (171dc <SystemInit+0x250>)
   17184:	601a      	str	r2, [r3, #0]
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
}
   17186:	bd08      	pop	{r3, pc}
   17188:	10000324 	.word	0x10000324
   1718c:	40013540 	.word	0x40013540
   17190:	4007c074 	.word	0x4007c074
   17194:	baadf00d 	.word	0xbaadf00d
   17198:	10000244 	.word	0x10000244
   1719c:	4000053c 	.word	0x4000053c
   171a0:	e000edf0 	.word	0xe000edf0
   171a4:	400005a0 	.word	0x400005a0
   171a8:	40005610 	.word	0x40005610
   171ac:	10000130 	.word	0x10000130
   171b0:	f0000fe0 	.word	0xf0000fe0
   171b4:	10000134 	.word	0x10000134
   171b8:	00022605 	.word	0x00022605
   171bc:	4000c000 	.word	0x4000c000
   171c0:	10000258 	.word	0x10000258
   171c4:	40000ee4 	.word	0x40000ee4
   171c8:	4000173c 	.word	0x4000173c
   171cc:	4001e000 	.word	0x4001e000
   171d0:	e000ed00 	.word	0xe000ed00
   171d4:	05fa0004 	.word	0x05fa0004
   171d8:	20005a10 	.word	0x20005a10
   171dc:	03d09000 	.word	0x03d09000

000171e0 <nvmc_word_write>:
   171e0:	4a04      	ldr	r2, [pc, #16]	; (171f4 <nvmc_word_write+0x14>)
   171e2:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
{
#if defined(NRF9160_XXAA)
    while (!nrf_nvmc_write_ready_check(NRF_NVMC))
    {}
#else
    while (!nrf_nvmc_ready_check(NRF_NVMC))
   171e6:	07db      	lsls	r3, r3, #31
   171e8:	d5fb      	bpl.n	171e2 <nvmc_word_write+0x2>
    {}
#endif

    *(volatile uint32_t *)addr = value;
   171ea:	6001      	str	r1, [r0, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   171ec:	f3bf 8f5f 	dmb	sy
    __DMB();
}
   171f0:	4770      	bx	lr
   171f2:	bf00      	nop
   171f4:	4001e000 	.word	0x4001e000

000171f8 <nrfx_nvmc_page_erase>:
NRF_STATIC_INLINE uint32_t nrf_ficr_codepagesize_get(NRF_FICR_Type const * p_reg)
{
#if defined(FICR_INFO_CODEPAGESIZE_CODEPAGESIZE_Msk)
    return p_reg->INFO.CODEPAGESIZE;
#else
    return p_reg->CODEPAGESIZE;
   171f8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   171fc:	691a      	ldr	r2, [r3, #16]
    return !(addr % flash_page_size_get());
   171fe:	fbb0 f3f2 	udiv	r3, r0, r2
   17202:	fb02 0313 	mls	r3, r2, r3, r0

nrfx_err_t nrfx_nvmc_page_erase(uint32_t addr)
{
    NRFX_ASSERT(addr < flash_total_size_get());

    if (!is_page_aligned_check(addr))
   17206:	b973      	cbnz	r3, 17226 <nrfx_nvmc_page_erase+0x2e>
#endif

NRF_STATIC_INLINE void nrf_nvmc_mode_set(NRF_NVMC_Type * p_reg,
                                         nrf_nvmc_mode_t mode)
{
    p_reg->CONFIG = (uint32_t)mode;
   17208:	4b08      	ldr	r3, [pc, #32]	; (1722c <nrfx_nvmc_page_erase+0x34>)
   1720a:	2202      	movs	r2, #2
   1720c:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    else
    {
        p_reg->ERASEPCR1 = page_addr;
    }
#elif defined(NRF52_SERIES)
    p_reg->ERASEPAGE = page_addr;
   17210:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   17214:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
        return NRFX_ERROR_INVALID_ADDR;
    }

    nvmc_erase_mode_set();
    nrf_nvmc_page_erase_start(NRF_NVMC, addr);
    while (!nrf_nvmc_ready_check(NRF_NVMC))
   17218:	07d2      	lsls	r2, r2, #31
   1721a:	d5fb      	bpl.n	17214 <nrfx_nvmc_page_erase+0x1c>
    p_reg->CONFIG = (uint32_t)mode;
   1721c:	2200      	movs	r2, #0
   1721e:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    {}
    nvmc_readonly_mode_set();

    return NRFX_SUCCESS;
   17222:	4803      	ldr	r0, [pc, #12]	; (17230 <nrfx_nvmc_page_erase+0x38>)
   17224:	4770      	bx	lr
        return NRFX_ERROR_INVALID_ADDR;
   17226:	4803      	ldr	r0, [pc, #12]	; (17234 <nrfx_nvmc_page_erase+0x3c>)
}
   17228:	4770      	bx	lr
   1722a:	bf00      	nop
   1722c:	4001e000 	.word	0x4001e000
   17230:	0bad0000 	.word	0x0bad0000
   17234:	0bad000a 	.word	0x0bad000a

00017238 <nrfx_nvmc_word_write>:

    nrfx_nvmc_word_write(aligned_addr, partial_word_create(addr, &value, 1));
}

void nrfx_nvmc_word_write(uint32_t addr, uint32_t value)
{
   17238:	b510      	push	{r4, lr}
   1723a:	4c05      	ldr	r4, [pc, #20]	; (17250 <nrfx_nvmc_word_write+0x18>)
   1723c:	2301      	movs	r3, #1
   1723e:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    NRFX_ASSERT(addr < flash_total_size_get());
    NRFX_ASSERT(nrfx_is_word_aligned((void const *)addr));

    nvmc_write_mode_set();

    nvmc_word_write(addr, value);
   17242:	f7ff ffcd 	bl	171e0 <nvmc_word_write>
   17246:	2300      	movs	r3, #0
   17248:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504

    nvmc_readonly_mode_set();
}
   1724c:	bd10      	pop	{r4, pc}
   1724e:	bf00      	nop
   17250:	4001e000 	.word	0x4001e000

00017254 <nrfx_nvmc_bytes_write>:

void nrfx_nvmc_bytes_write(uint32_t addr, void const * src, uint32_t num_bytes)
{
   17254:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   17258:	4b1e      	ldr	r3, [pc, #120]	; (172d4 <nrfx_nvmc_bytes_write+0x80>)
   1725a:	4615      	mov	r5, r2
   1725c:	2201      	movs	r2, #1
   1725e:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    nvmc_write_mode_set();

    uint8_t const * bytes_src = (uint8_t const *)src;

    uint32_t unaligned_bytes = addr % NVMC_BYTES_IN_WORD;
    if (unaligned_bytes != 0)
   17262:	f010 0303 	ands.w	r3, r0, #3
{
   17266:	4604      	mov	r4, r0
   17268:	460e      	mov	r6, r1
    if (unaligned_bytes != 0)
   1726a:	d010      	beq.n	1728e <nrfx_nvmc_bytes_write+0x3a>
    {
        uint32_t leading_bytes = NVMC_BYTES_IN_WORD - unaligned_bytes;
   1726c:	f1c3 0704 	rsb	r7, r3, #4
        if (leading_bytes > num_bytes)
   17270:	42af      	cmp	r7, r5
   17272:	bf28      	it	cs
   17274:	462f      	movcs	r7, r5
        {
            leading_bytes = num_bytes;
        }

        nvmc_word_write(addr - unaligned_bytes,
   17276:	463a      	mov	r2, r7
   17278:	eba0 0803 	sub.w	r8, r0, r3
   1727c:	f006 ff04 	bl	1e088 <partial_word_create>
   17280:	4601      	mov	r1, r0
   17282:	4640      	mov	r0, r8
   17284:	f7ff ffac 	bl	171e0 <nvmc_word_write>
                        partial_word_create(addr, bytes_src, leading_bytes));
        num_bytes -= leading_bytes;
   17288:	1bed      	subs	r5, r5, r7
        addr      += leading_bytes;
   1728a:	443c      	add	r4, r7
        bytes_src += leading_bytes;
   1728c:	443e      	add	r6, r7
    for (uint32_t i = 0; i < num_words; i++)
   1728e:	f025 0803 	bic.w	r8, r5, #3
   17292:	44b0      	add	r8, r6
        }
    }
    else
#endif
    {
        uint32_t word_count = num_bytes / NVMC_BYTES_IN_WORD;
   17294:	4637      	mov	r7, r6
   17296:	eba4 0906 	sub.w	r9, r4, r6
    for (uint32_t i = 0; i < num_words; i++)
   1729a:	45b8      	cmp	r8, r7
   1729c:	d113      	bne.n	172c6 <nrfx_nvmc_bytes_write+0x72>
        addr += word_count * NVMC_BYTES_IN_WORD;
        bytes_src += word_count * NVMC_BYTES_IN_WORD;
    }

    uint32_t trailing_bytes = num_bytes % NVMC_BYTES_IN_WORD;
    if (trailing_bytes != 0)
   1729e:	f015 0203 	ands.w	r2, r5, #3
   172a2:	d00a      	beq.n	172ba <nrfx_nvmc_bytes_write+0x66>
        addr += word_count * NVMC_BYTES_IN_WORD;
   172a4:	f025 0103 	bic.w	r1, r5, #3
   172a8:	440c      	add	r4, r1
    {
        nvmc_word_write(addr, partial_word_create(addr, bytes_src, trailing_bytes));
   172aa:	4620      	mov	r0, r4
   172ac:	4431      	add	r1, r6
   172ae:	f006 feeb 	bl	1e088 <partial_word_create>
   172b2:	4601      	mov	r1, r0
   172b4:	4620      	mov	r0, r4
   172b6:	f7ff ff93 	bl	171e0 <nvmc_word_write>
   172ba:	4b06      	ldr	r3, [pc, #24]	; (172d4 <nrfx_nvmc_bytes_write+0x80>)
   172bc:	2200      	movs	r2, #0
   172be:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    }

    nvmc_readonly_mode_set();
}
   172c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        nvmc_word_write(addr + (NVMC_BYTES_IN_WORD * i), ((uint32_t const *)src)[i]);
   172c6:	eb09 0007 	add.w	r0, r9, r7
   172ca:	f857 1b04 	ldr.w	r1, [r7], #4
   172ce:	f7ff ff87 	bl	171e0 <nvmc_word_write>
   172d2:	e7e2      	b.n	1729a <nrfx_nvmc_bytes_write+0x46>
   172d4:	4001e000 	.word	0x4001e000

000172d8 <twi_rx_start_transfer>:
    return ret_code;
}

static nrfx_err_t twi_rx_start_transfer(NRF_TWI_Type        * p_twi,
                                        twi_control_block_t * p_cb)
{
   172d8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    nrfx_err_t ret_code = NRFX_SUCCESS;
    volatile int32_t hw_timeout;

    hw_timeout = HW_TIMEOUT;
   172da:	4b34      	ldr	r3, [pc, #208]	; (173ac <twi_rx_start_transfer+0xd4>)
   172dc:	9301      	str	r3, [sp, #4]
{
   172de:	460d      	mov	r5, r1

    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
   172e0:	f44f 7182 	mov.w	r1, #260	; 0x104
{
   172e4:	4604      	mov	r4, r0
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
   172e6:	f006 fef0 	bl	1e0ca <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
   172ea:	f44f 7192 	mov.w	r1, #292	; 0x124
   172ee:	f006 feec 	bl	1e0ca <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_TXDSENT);
   172f2:	f44f 718e 	mov.w	r1, #284	; 0x11c
   172f6:	f006 fee8 	bl	1e0ca <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_RXDREADY);
   172fa:	f44f 7184 	mov.w	r1, #264	; 0x108
   172fe:	f006 fee4 	bl	1e0ca <nrf_twi_event_clear>

    p_cb->bytes_transferred = 0;
   17302:	2300      	movs	r3, #0
   17304:	636b      	str	r3, [r5, #52]	; 0x34
    p_cb->error             = false;
   17306:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f

    if ((p_cb->curr_length == 1) && (!TWI_FLAG_SUSPEND(p_cb->flags)))
   1730a:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1730c:	2b01      	cmp	r3, #1
   1730e:	d118      	bne.n	17342 <twi_rx_start_transfer+0x6a>
   17310:	6a2b      	ldr	r3, [r5, #32]
   17312:	065b      	lsls	r3, r3, #25
   17314:	d415      	bmi.n	17342 <twi_rx_start_transfer+0x6a>
}

NRF_STATIC_INLINE void nrf_twi_shorts_set(NRF_TWI_Type * p_reg,
                                          uint32_t       mask)
{
    p_reg->SHORTS = mask;
   17316:	2302      	movs	r3, #2
        nrf_twi_shorts_set(p_twi, NRF_TWI_SHORT_BB_SUSPEND_MASK);
    }
    // In case TWI is suspended resume its operation.
    nrf_twi_task_trigger(p_twi, NRF_TWI_TASK_RESUME);

    if (p_cb->prev_suspend != TWI_SUSPEND_RX)
   17318:	f895 202d 	ldrb.w	r2, [r5, #45]	; 0x2d
   1731c:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
   17320:	2a02      	cmp	r2, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   17322:	f04f 0301 	mov.w	r3, #1
   17326:	6223      	str	r3, [r4, #32]
   17328:	bf18      	it	ne
   1732a:	6023      	strne	r3, [r4, #0]
    {
        nrf_twi_task_trigger(p_twi, NRF_TWI_TASK_STARTRX);
    }

    if (p_cb->handler)
   1732c:	682b      	ldr	r3, [r5, #0]
   1732e:	b193      	cbz	r3, 17356 <twi_rx_start_transfer+0x7e>
    {
        p_cb->int_mask = NRF_TWI_INT_STOPPED_MASK   |
   17330:	f240 2386 	movw	r3, #646	; 0x286
   17334:	60ab      	str	r3, [r5, #8]
                        NRF_TWI_INT_ERROR_MASK     |
                        NRF_TWI_INT_TXDSENT_MASK   |
                        NRF_TWI_INT_RXDREADY_MASK;
        nrf_twi_int_enable(p_twi, p_cb->int_mask);
   17336:	68ab      	ldr	r3, [r5, #8]
    nrfx_err_t ret_code = NRFX_SUCCESS;
   17338:	481d      	ldr	r0, [pc, #116]	; (173b0 <twi_rx_start_transfer+0xd8>)
    p_reg->INTENSET = mask;
   1733a:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
            nrf_twi_enable(p_twi);
            ret_code = NRFX_ERROR_INTERNAL;
        }
    }
    return ret_code;
}
   1733e:	b003      	add	sp, #12
   17340:	bd30      	pop	{r4, r5, pc}
    p_reg->SHORTS = mask;
   17342:	2301      	movs	r3, #1
   17344:	e7e8      	b.n	17318 <twi_rx_start_transfer+0x40>
               twi_transfer(p_twi, p_cb))
   17346:	4629      	mov	r1, r5
   17348:	4620      	mov	r0, r4
   1734a:	f006 fee6 	bl	1e11a <twi_transfer>
        while ((hw_timeout > 0) &&
   1734e:	b128      	cbz	r0, 1735c <twi_rx_start_transfer+0x84>
               hw_timeout--;
   17350:	9b01      	ldr	r3, [sp, #4]
   17352:	3b01      	subs	r3, #1
   17354:	9301      	str	r3, [sp, #4]
        while ((hw_timeout > 0) &&
   17356:	9b01      	ldr	r3, [sp, #4]
   17358:	2b00      	cmp	r3, #0
   1735a:	dcf4      	bgt.n	17346 <twi_rx_start_transfer+0x6e>
        if (p_cb->error)
   1735c:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
   17360:	b95b      	cbnz	r3, 1737a <twi_rx_start_transfer+0xa2>
    nrfx_err_t ret_code = NRFX_SUCCESS;
   17362:	4813      	ldr	r0, [pc, #76]	; (173b0 <twi_rx_start_transfer+0xd8>)
        if (hw_timeout <= 0)
   17364:	9b01      	ldr	r3, [sp, #4]
   17366:	2b00      	cmp	r3, #0
   17368:	dce9      	bgt.n	1733e <twi_rx_start_transfer+0x66>
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos);
   1736a:	2300      	movs	r3, #0
   1736c:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Enabled << TWI_ENABLE_ENABLE_Pos);
   17370:	2305      	movs	r3, #5
   17372:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
            ret_code = NRFX_ERROR_INTERNAL;
   17376:	480f      	ldr	r0, [pc, #60]	; (173b4 <twi_rx_start_transfer+0xdc>)
    return ret_code;
   17378:	e7e1      	b.n	1733e <twi_rx_start_transfer+0x66>
    uint32_t error_source = p_reg->ERRORSRC;
   1737a:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   1737e:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
            if (errorsrc)
   17382:	2b00      	cmp	r3, #0
   17384:	d0ed      	beq.n	17362 <twi_rx_start_transfer+0x8a>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
   17386:	4a0c      	ldr	r2, [pc, #48]	; (173b8 <twi_rx_start_transfer+0xe0>)
   17388:	480a      	ldr	r0, [pc, #40]	; (173b4 <twi_rx_start_transfer+0xdc>)
   1738a:	f013 0f01 	tst.w	r3, #1
   1738e:	bf18      	it	ne
   17390:	4610      	movne	r0, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   17392:	f013 0f02 	tst.w	r3, #2
   17396:	f102 0201 	add.w	r2, r2, #1
   1739a:	bf18      	it	ne
   1739c:	4610      	movne	r0, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   1739e:	f013 0f04 	tst.w	r3, #4
   173a2:	4b06      	ldr	r3, [pc, #24]	; (173bc <twi_rx_start_transfer+0xe4>)
   173a4:	bf18      	it	ne
   173a6:	4618      	movne	r0, r3
   173a8:	e7dc      	b.n	17364 <twi_rx_start_transfer+0x8c>
   173aa:	bf00      	nop
   173ac:	000186a0 	.word	0x000186a0
   173b0:	0bad0000 	.word	0x0bad0000
   173b4:	0bad0001 	.word	0x0bad0001
   173b8:	0bae0000 	.word	0x0bae0000
   173bc:	0bae0002 	.word	0x0bae0002

000173c0 <twi_tx_start_transfer>:
{
   173c0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    hw_timeout = HW_TIMEOUT;
   173c2:	4b30      	ldr	r3, [pc, #192]	; (17484 <twi_tx_start_transfer+0xc4>)
   173c4:	9301      	str	r3, [sp, #4]
{
   173c6:	460d      	mov	r5, r1
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
   173c8:	f44f 7182 	mov.w	r1, #260	; 0x104
{
   173cc:	4604      	mov	r4, r0
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
   173ce:	f006 fe7c 	bl	1e0ca <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
   173d2:	f44f 7192 	mov.w	r1, #292	; 0x124
   173d6:	f006 fe78 	bl	1e0ca <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_TXDSENT);
   173da:	f44f 718e 	mov.w	r1, #284	; 0x11c
   173de:	f006 fe74 	bl	1e0ca <nrf_twi_event_clear>
    nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_RXDREADY);
   173e2:	f44f 7184 	mov.w	r1, #264	; 0x108
   173e6:	f006 fe70 	bl	1e0ca <nrf_twi_event_clear>
    p_reg->SHORTS = mask;
   173ea:	2300      	movs	r3, #0
    if (p_cb->prev_suspend != TWI_SUSPEND_TX)
   173ec:	f895 202d 	ldrb.w	r2, [r5, #45]	; 0x2d
   173f0:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
    p_cb->bytes_transferred = 0;
   173f4:	636b      	str	r3, [r5, #52]	; 0x34
    p_cb->error             = false;
   173f6:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   173fa:	2301      	movs	r3, #1
    if (p_cb->prev_suspend != TWI_SUSPEND_TX)
   173fc:	429a      	cmp	r2, r3
   173fe:	6203      	str	r3, [r0, #32]
    (void)twi_send_byte(p_twi, p_cb);
   17400:	4629      	mov	r1, r5
   17402:	bf18      	it	ne
   17404:	6083      	strne	r3, [r0, #8]
   17406:	f006 fe68 	bl	1e0da <twi_send_byte>
    if (p_cb->handler)
   1740a:	682b      	ldr	r3, [r5, #0]
   1740c:	b183      	cbz	r3, 17430 <twi_tx_start_transfer+0x70>
        p_cb->int_mask = NRF_TWI_INT_STOPPED_MASK   |
   1740e:	f240 2386 	movw	r3, #646	; 0x286
   17412:	60ab      	str	r3, [r5, #8]
        nrf_twi_int_enable(p_twi, p_cb->int_mask);
   17414:	68ab      	ldr	r3, [r5, #8]
    nrfx_err_t ret_code = NRFX_SUCCESS;
   17416:	481c      	ldr	r0, [pc, #112]	; (17488 <twi_tx_start_transfer+0xc8>)
    p_reg->INTENSET = mask;
   17418:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
   1741c:	b003      	add	sp, #12
   1741e:	bd30      	pop	{r4, r5, pc}
               twi_transfer(p_twi, p_cb))
   17420:	4629      	mov	r1, r5
   17422:	4620      	mov	r0, r4
   17424:	f006 fe79 	bl	1e11a <twi_transfer>
        while ((hw_timeout > 0) &&
   17428:	b128      	cbz	r0, 17436 <twi_tx_start_transfer+0x76>
            hw_timeout--;
   1742a:	9b01      	ldr	r3, [sp, #4]
   1742c:	3b01      	subs	r3, #1
   1742e:	9301      	str	r3, [sp, #4]
        while ((hw_timeout > 0) &&
   17430:	9b01      	ldr	r3, [sp, #4]
   17432:	2b00      	cmp	r3, #0
   17434:	dcf4      	bgt.n	17420 <twi_tx_start_transfer+0x60>
        if (p_cb->error)
   17436:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
   1743a:	b95b      	cbnz	r3, 17454 <twi_tx_start_transfer+0x94>
    nrfx_err_t ret_code = NRFX_SUCCESS;
   1743c:	4812      	ldr	r0, [pc, #72]	; (17488 <twi_tx_start_transfer+0xc8>)
        if (hw_timeout <= 0)
   1743e:	9b01      	ldr	r3, [sp, #4]
   17440:	2b00      	cmp	r3, #0
   17442:	dceb      	bgt.n	1741c <twi_tx_start_transfer+0x5c>
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos);
   17444:	2300      	movs	r3, #0
   17446:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Enabled << TWI_ENABLE_ENABLE_Pos);
   1744a:	2305      	movs	r3, #5
   1744c:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
            ret_code = NRFX_ERROR_INTERNAL;
   17450:	480e      	ldr	r0, [pc, #56]	; (1748c <twi_tx_start_transfer+0xcc>)
    return ret_code;
   17452:	e7e3      	b.n	1741c <twi_tx_start_transfer+0x5c>
    uint32_t error_source = p_reg->ERRORSRC;
   17454:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   17458:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
            if (errorsrc)
   1745c:	2b00      	cmp	r3, #0
   1745e:	d0ed      	beq.n	1743c <twi_tx_start_transfer+0x7c>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
   17460:	4a0b      	ldr	r2, [pc, #44]	; (17490 <twi_tx_start_transfer+0xd0>)
   17462:	480a      	ldr	r0, [pc, #40]	; (1748c <twi_tx_start_transfer+0xcc>)
   17464:	f013 0f01 	tst.w	r3, #1
   17468:	bf18      	it	ne
   1746a:	4610      	movne	r0, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   1746c:	f013 0f02 	tst.w	r3, #2
   17470:	f102 0201 	add.w	r2, r2, #1
   17474:	bf18      	it	ne
   17476:	4610      	movne	r0, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   17478:	f013 0f04 	tst.w	r3, #4
   1747c:	4b05      	ldr	r3, [pc, #20]	; (17494 <twi_tx_start_transfer+0xd4>)
   1747e:	bf18      	it	ne
   17480:	4618      	movne	r0, r3
   17482:	e7dc      	b.n	1743e <twi_tx_start_transfer+0x7e>
   17484:	000186a0 	.word	0x000186a0
   17488:	0bad0000 	.word	0x0bad0000
   1748c:	0bad0001 	.word	0x0bad0001
   17490:	0bae0000 	.word	0x0bae0000
   17494:	0bae0002 	.word	0x0bae0002

00017498 <nrfx_twi_init>:
{
   17498:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    twi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   1749a:	7907      	ldrb	r7, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   1749c:	4d1d      	ldr	r5, [pc, #116]	; (17514 <nrfx_twi_init+0x7c>)
   1749e:	f04f 0c3c 	mov.w	ip, #60	; 0x3c
   174a2:	fb0c fc07 	mul.w	ip, ip, r7
   174a6:	eb05 040c 	add.w	r4, r5, ip
   174aa:	f894 602e 	ldrb.w	r6, [r4, #46]	; 0x2e
   174ae:	bb7e      	cbnz	r6, 17510 <nrfx_twi_init+0x78>
    p_cb->p_context       = p_context;
   174b0:	6063      	str	r3, [r4, #4]
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   174b2:	7b4b      	ldrb	r3, [r1, #13]
    p_cb->int_mask        = 0;
   174b4:	60a6      	str	r6, [r4, #8]
    p_cb->prev_suspend    = TWI_NO_SUSPEND;
   174b6:	f884 602d 	strb.w	r6, [r4, #45]	; 0x2d
    p_cb->busy            = false;
   174ba:	f884 6030 	strb.w	r6, [r4, #48]	; 0x30
    p_cb->repeated        = false;
   174be:	f884 6031 	strb.w	r6, [r4, #49]	; 0x31
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   174c2:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
    TWI_PIN_INIT(p_config->scl);
   174c6:	680c      	ldr	r4, [r1, #0]
    p_cb->handler         = event_handler;
   174c8:	f845 200c 	str.w	r2, [r5, ip]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   174cc:	f04f 46a0 	mov.w	r6, #1342177280	; 0x50000000
   174d0:	f504 73e0 	add.w	r3, r4, #448	; 0x1c0
   174d4:	f240 6c0c 	movw	ip, #1548	; 0x60c
   174d8:	f846 c023 	str.w	ip, [r6, r3, lsl #2]
    TWI_PIN_INIT(p_config->sda);
   174dc:	684b      	ldr	r3, [r1, #4]
    NRF_TWI_Type * p_twi = p_instance->p_twi;
   174de:	6800      	ldr	r0, [r0, #0]
   174e0:	f503 7ee0 	add.w	lr, r3, #448	; 0x1c0
   174e4:	f846 c02e 	str.w	ip, [r6, lr, lsl #2]
    p_reg->PSELSCL = scl_pin;
   174e8:	f8c0 4508 	str.w	r4, [r0, #1288]	; 0x508
    p_reg->PSELSDA = sda_pin;
   174ec:	f8c0 350c 	str.w	r3, [r0, #1292]	; 0x50c
        (nrf_twi_frequency_t)p_config->frequency);
   174f0:	688b      	ldr	r3, [r1, #8]
    p_reg->FREQUENCY = frequency;
   174f2:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524
    if (p_cb->handler)
   174f6:	b11a      	cbz	r2, 17500 <nrfx_twi_init+0x68>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twi));
   174f8:	f340 3007 	sbfx	r0, r0, #12, #8
   174fc:	f7ec ff2c 	bl	4358 <arch_irq_enable>
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   17500:	233c      	movs	r3, #60	; 0x3c
   17502:	fb03 5507 	mla	r5, r3, r7, r5
    return err_code;
   17506:	4804      	ldr	r0, [pc, #16]	; (17518 <nrfx_twi_init+0x80>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   17508:	2301      	movs	r3, #1
   1750a:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e
}
   1750e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return err_code;
   17510:	4802      	ldr	r0, [pc, #8]	; (1751c <nrfx_twi_init+0x84>)
   17512:	e7fc      	b.n	1750e <nrfx_twi_init+0x76>
   17514:	20001910 	.word	0x20001910
   17518:	0bad0000 	.word	0x0bad0000
   1751c:	0bad0005 	.word	0x0bad0005

00017520 <nrfx_twi_enable>:
    NRF_TWI_Type * p_twi = p_instance->p_twi;
   17520:	6802      	ldr	r2, [r0, #0]
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   17522:	7903      	ldrb	r3, [r0, #4]
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Enabled << TWI_ENABLE_ENABLE_Pos);
   17524:	2105      	movs	r1, #5
   17526:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
   1752a:	4a04      	ldr	r2, [pc, #16]	; (1753c <nrfx_twi_enable+0x1c>)
   1752c:	213c      	movs	r1, #60	; 0x3c
   1752e:	fb01 2303 	mla	r3, r1, r3, r2
   17532:	2202      	movs	r2, #2
   17534:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
}
   17538:	4770      	bx	lr
   1753a:	bf00      	nop
   1753c:	20001910 	.word	0x20001910

00017540 <nrfx_twi_disable>:
    NRF_TWI_Type * p_twi = p_instance->p_twi;
   17540:	6803      	ldr	r3, [r0, #0]
    p_reg->INTENCLR = mask;
   17542:	490a      	ldr	r1, [pc, #40]	; (1756c <nrfx_twi_disable+0x2c>)
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   17544:	7902      	ldrb	r2, [r0, #4]
   17546:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
   1754a:	f8d3 1200 	ldr.w	r1, [r3, #512]	; 0x200
   1754e:	f021 0103 	bic.w	r1, r1, #3
   17552:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
    p_reg->ENABLE = (TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos);
   17556:	2100      	movs	r1, #0
   17558:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   1755c:	4b04      	ldr	r3, [pc, #16]	; (17570 <nrfx_twi_disable+0x30>)
   1755e:	213c      	movs	r1, #60	; 0x3c
   17560:	fb01 3202 	mla	r2, r1, r2, r3
   17564:	2301      	movs	r3, #1
   17566:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
}
   1756a:	4770      	bx	lr
   1756c:	00044286 	.word	0x00044286
   17570:	20001910 	.word	0x20001910

00017574 <nrfx_twi_xfer>:
}

nrfx_err_t nrfx_twi_xfer(nrfx_twi_t const *           p_instance,
                         nrfx_twi_xfer_desc_t const * p_xfer_desc,
                         uint32_t                     flags)
{
   17574:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if ((p_cb->prev_suspend == TWI_SUSPEND_TX) && (p_xfer_desc->type == NRFX_TWI_XFER_RX))
   17578:	4d32      	ldr	r5, [pc, #200]	; (17644 <nrfx_twi_xfer+0xd0>)

    nrfx_err_t err_code = NRFX_SUCCESS;
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   1757a:	f890 8004 	ldrb.w	r8, [r0, #4]
                           p_xfer_desc->primary_length * sizeof(p_xfer_desc->p_primary_buf[0]));
    NRFX_LOG_DEBUG("Secondary buffer data:");
    NRFX_LOG_HEXDUMP_DEBUG(p_xfer_desc->p_secondary_buf,
                           p_xfer_desc->secondary_length * sizeof(p_xfer_desc->p_secondary_buf[0]));

    err_code = twi_xfer((NRF_TWI_Type  *)p_instance->p_twi, p_cb, p_xfer_desc, flags);
   1757e:	f8d0 9000 	ldr.w	r9, [r0]
    if ((p_cb->prev_suspend == TWI_SUSPEND_TX) && (p_xfer_desc->type == NRFX_TWI_XFER_RX))
   17582:	233c      	movs	r3, #60	; 0x3c
   17584:	fb03 5308 	mla	r3, r3, r8, r5
{
   17588:	460e      	mov	r6, r1
    if ((p_cb->prev_suspend == TWI_SUSPEND_TX) && (p_xfer_desc->type == NRFX_TWI_XFER_RX))
   1758a:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
   1758e:	2b01      	cmp	r3, #1
{
   17590:	4696      	mov	lr, r2
    if ((p_cb->prev_suspend == TWI_SUSPEND_TX) && (p_xfer_desc->type == NRFX_TWI_XFER_RX))
   17592:	d104      	bne.n	1759e <nrfx_twi_xfer+0x2a>
   17594:	780b      	ldrb	r3, [r1, #0]
   17596:	2b01      	cmp	r3, #1
   17598:	d106      	bne.n	175a8 <nrfx_twi_xfer+0x34>
        return NRFX_ERROR_INVALID_STATE;
   1759a:	482b      	ldr	r0, [pc, #172]	; (17648 <nrfx_twi_xfer+0xd4>)
    NRFX_LOG_WARNING("Function: %s, error code: %s.",
                     __func__,
                     NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   1759c:	e011      	b.n	175c2 <nrfx_twi_xfer+0x4e>
    else if ((p_cb->prev_suspend == TWI_SUSPEND_RX) && (p_xfer_desc->type != NRFX_TWI_XFER_RX))
   1759e:	2b02      	cmp	r3, #2
   175a0:	d102      	bne.n	175a8 <nrfx_twi_xfer+0x34>
   175a2:	780b      	ldrb	r3, [r1, #0]
   175a4:	2b01      	cmp	r3, #1
   175a6:	d1f8      	bne.n	1759a <nrfx_twi_xfer+0x26>
    if (p_cb->busy)
   175a8:	243c      	movs	r4, #60	; 0x3c
    p_reg->INTENCLR = mask;
   175aa:	4b28      	ldr	r3, [pc, #160]	; (1764c <nrfx_twi_xfer+0xd8>)
   175ac:	f8c9 3308 	str.w	r3, [r9, #776]	; 0x308
   175b0:	fb04 5408 	mla	r4, r4, r8, r5
   175b4:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   175b8:	b12b      	cbz	r3, 175c6 <nrfx_twi_xfer+0x52>
        nrf_twi_int_enable(p_twi, p_cb->int_mask);
   175ba:	68a3      	ldr	r3, [r4, #8]
        return err_code;
   175bc:	4824      	ldr	r0, [pc, #144]	; (17650 <nrfx_twi_xfer+0xdc>)
    p_reg->INTENSET = mask;
   175be:	f8c9 3304 	str.w	r3, [r9, #772]	; 0x304
}
   175c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        p_cb->busy = (TWI_FLAG_NO_HANDLER_IN_USE(flags)) ? false : true;
   175c6:	f08e 0304 	eor.w	r3, lr, #4
   175ca:	f3c3 0380 	ubfx	r3, r3, #2, #1
   175ce:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
    p_cb->flags       = flags;
   175d2:	f8c4 e020 	str.w	lr, [r4, #32]
    p_cb->xfer_desc   = *p_xfer_desc;
   175d6:	46b4      	mov	ip, r6
   175d8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   175dc:	f104 070c 	add.w	r7, r4, #12
   175e0:	c70f      	stmia	r7!, {r0, r1, r2, r3}
   175e2:	f8dc 3000 	ldr.w	r3, [ip]
   175e6:	603b      	str	r3, [r7, #0]
    p_cb->curr_length = p_xfer_desc->primary_length;
   175e8:	6873      	ldr	r3, [r6, #4]
   175ea:	62a3      	str	r3, [r4, #40]	; 0x28
    p_cb->p_curr_buf  = p_xfer_desc->p_primary_buf;
   175ec:	68f3      	ldr	r3, [r6, #12]
   175ee:	6263      	str	r3, [r4, #36]	; 0x24
    p_reg->ADDRESS = address;
   175f0:	7873      	ldrb	r3, [r6, #1]
   175f2:	f8c9 3588 	str.w	r3, [r9, #1416]	; 0x588
    if (p_xfer_desc->type != NRFX_TWI_XFER_RX)
   175f6:	7833      	ldrb	r3, [r6, #0]
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   175f8:	ebc8 1a08 	rsb	sl, r8, r8, lsl #4
    if (p_xfer_desc->type != NRFX_TWI_XFER_RX)
   175fc:	2b01      	cmp	r3, #1
    twi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   175fe:	eb05 0a8a 	add.w	sl, r5, sl, lsl #2
    if (p_xfer_desc->type != NRFX_TWI_XFER_RX)
   17602:	d01a      	beq.n	1763a <nrfx_twi_xfer+0xc6>
                                 !(flags & NRFX_TWI_FLAG_TX_NO_STOP)) ? false : true;
   17604:	b9b3      	cbnz	r3, 17634 <nrfx_twi_xfer+0xc0>
   17606:	f3ce 1e40 	ubfx	lr, lr, #5, #1
        p_cb->curr_tx_no_stop = ((p_xfer_desc->type == NRFX_TWI_XFER_TX) &&
   1760a:	233c      	movs	r3, #60	; 0x3c
   1760c:	fb03 5308 	mla	r3, r3, r8, r5
        err_code = twi_tx_start_transfer(p_twi, p_cb);
   17610:	4651      	mov	r1, sl
                                 !(flags & NRFX_TWI_FLAG_TX_NO_STOP)) ? false : true;
   17612:	f883 e02c 	strb.w	lr, [r3, #44]	; 0x2c
        err_code = twi_tx_start_transfer(p_twi, p_cb);
   17616:	4648      	mov	r0, r9
   17618:	f7ff fed2 	bl	173c0 <twi_tx_start_transfer>
    if (p_cb->handler == NULL)
   1761c:	233c      	movs	r3, #60	; 0x3c
   1761e:	fb03 f808 	mul.w	r8, r3, r8
   17622:	eb05 0208 	add.w	r2, r5, r8
   17626:	f855 3008 	ldr.w	r3, [r5, r8]
   1762a:	2b00      	cmp	r3, #0
   1762c:	d1c9      	bne.n	175c2 <nrfx_twi_xfer+0x4e>
        p_cb->busy = false;
   1762e:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
   17632:	e7c6      	b.n	175c2 <nrfx_twi_xfer+0x4e>
                                 !(flags & NRFX_TWI_FLAG_TX_NO_STOP)) ? false : true;
   17634:	f04f 0e01 	mov.w	lr, #1
   17638:	e7e7      	b.n	1760a <nrfx_twi_xfer+0x96>
        err_code = twi_rx_start_transfer(p_twi, p_cb);
   1763a:	4651      	mov	r1, sl
   1763c:	4648      	mov	r0, r9
   1763e:	f7ff fe4b 	bl	172d8 <twi_rx_start_transfer>
   17642:	e7eb      	b.n	1761c <nrfx_twi_xfer+0xa8>
   17644:	20001910 	.word	0x20001910
   17648:	0bad0005 	.word	0x0bad0005
   1764c:	00044286 	.word	0x00044286
   17650:	0bad000b 	.word	0x0bad000b

00017654 <nrfx_twi_1_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_TWI1_ENABLED)
void nrfx_twi_1_irq_handler(void)
{
   17654:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (twi_transfer(p_twi, p_cb))
   17656:	4c29      	ldr	r4, [pc, #164]	; (176fc <nrfx_twi_1_irq_handler+0xa8>)
{
   17658:	b087      	sub	sp, #28
    if (twi_transfer(p_twi, p_cb))
   1765a:	4621      	mov	r1, r4
   1765c:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
   17660:	f006 fd5b 	bl	1e11a <twi_transfer>
   17664:	46a4      	mov	ip, r4
   17666:	b9e0      	cbnz	r0, 176a2 <nrfx_twi_1_irq_handler+0x4e>
    if (!p_cb->error &&
   17668:	f894 702f 	ldrb.w	r7, [r4, #47]	; 0x2f
   1766c:	6a26      	ldr	r6, [r4, #32]
   1766e:	b9ef      	cbnz	r7, 176ac <nrfx_twi_1_irq_handler+0x58>
        ((p_cb->xfer_desc.type == NRFX_TWI_XFER_TXRX) ||
   17670:	7b23      	ldrb	r3, [r4, #12]
    if (!p_cb->error &&
   17672:	1e9a      	subs	r2, r3, #2
   17674:	2a01      	cmp	r2, #1
   17676:	d819      	bhi.n	176ac <nrfx_twi_1_irq_handler+0x58>
         (p_cb->xfer_desc.type == NRFX_TWI_XFER_TXTX)) &&
   17678:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1767a:	69a2      	ldr	r2, [r4, #24]
   1767c:	4291      	cmp	r1, r2
   1767e:	d115      	bne.n	176ac <nrfx_twi_1_irq_handler+0x58>
        p_cb->p_curr_buf      = p_cb->xfer_desc.p_secondary_buf;
   17680:	69e2      	ldr	r2, [r4, #28]
   17682:	6262      	str	r2, [r4, #36]	; 0x24
        p_cb->curr_tx_no_stop = (p_cb->flags & NRFX_TWI_FLAG_TX_NO_STOP);
   17684:	f3c6 1640 	ubfx	r6, r6, #5, #1
        p_cb->curr_length     = p_cb->xfer_desc.secondary_length;
   17688:	6962      	ldr	r2, [r4, #20]
   1768a:	62a2      	str	r2, [r4, #40]	; 0x28
        if (p_cb->xfer_desc.type == NRFX_TWI_XFER_TXTX)
   1768c:	2b03      	cmp	r3, #3
        p_cb->curr_tx_no_stop = (p_cb->flags & NRFX_TWI_FLAG_TX_NO_STOP);
   1768e:	f884 602c 	strb.w	r6, [r4, #44]	; 0x2c
        p_cb->prev_suspend    = TWI_NO_SUSPEND;
   17692:	f884 702d 	strb.w	r7, [r4, #45]	; 0x2d
            (void)twi_tx_start_transfer(p_twi, p_cb);
   17696:	4621      	mov	r1, r4
   17698:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
        if (p_cb->xfer_desc.type == NRFX_TWI_XFER_TXTX)
   1769c:	d103      	bne.n	176a6 <nrfx_twi_1_irq_handler+0x52>
            (void)twi_tx_start_transfer(p_twi, p_cb);
   1769e:	f7ff fe8f 	bl	173c0 <twi_tx_start_transfer>
    twi_irq_handler(NRF_TWI1, &m_cb[NRFX_TWI1_INST_IDX]);
}
   176a2:	b007      	add	sp, #28
   176a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
            (void)twi_rx_start_transfer(p_twi, p_cb);
   176a6:	f7ff fe17 	bl	172d8 <twi_rx_start_transfer>
   176aa:	e7fa      	b.n	176a2 <nrfx_twi_1_irq_handler+0x4e>
        event.xfer_desc = p_cb->xfer_desc;
   176ac:	4d14      	ldr	r5, [pc, #80]	; (17700 <nrfx_twi_1_irq_handler+0xac>)
   176ae:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   176b0:	ac01      	add	r4, sp, #4
   176b2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   176b4:	682b      	ldr	r3, [r5, #0]
   176b6:	6023      	str	r3, [r4, #0]
        if (p_cb->error)
   176b8:	b1e7      	cbz	r7, 176f4 <nrfx_twi_1_irq_handler+0xa0>
    uint32_t error_source = p_reg->ERRORSRC;
   176ba:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   176be:	f8d2 34c4 	ldr.w	r3, [r2, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   176c2:	f8c2 34c4 	str.w	r3, [r2, #1220]	; 0x4c4
            if (errorsrc & NRF_TWI_ERROR_ADDRESS_NACK)
   176c6:	0798      	lsls	r0, r3, #30
   176c8:	d50c      	bpl.n	176e4 <nrfx_twi_1_irq_handler+0x90>
                event.type = NRFX_TWI_EVT_ADDRESS_NACK;
   176ca:	2301      	movs	r3, #1
                event.type = NRFX_TWI_EVT_DATA_NACK;
   176cc:	f88d 3000 	strb.w	r3, [sp]
        p_cb->busy = false;
   176d0:	2300      	movs	r3, #0
   176d2:	f88c 3030 	strb.w	r3, [ip, #48]	; 0x30
        if (!(TWI_FLAG_NO_HANDLER_IN_USE(p_cb->flags)))
   176d6:	0773      	lsls	r3, r6, #29
   176d8:	d4e3      	bmi.n	176a2 <nrfx_twi_1_irq_handler+0x4e>
            p_cb->handler(&event, p_cb->p_context);
   176da:	e9dc 3100 	ldrd	r3, r1, [ip]
   176de:	4668      	mov	r0, sp
   176e0:	4798      	blx	r3
}
   176e2:	e7de      	b.n	176a2 <nrfx_twi_1_irq_handler+0x4e>
            else if (errorsrc & NRF_TWI_ERROR_DATA_NACK)
   176e4:	0759      	lsls	r1, r3, #29
   176e6:	d501      	bpl.n	176ec <nrfx_twi_1_irq_handler+0x98>
                event.type = NRFX_TWI_EVT_DATA_NACK;
   176e8:	2302      	movs	r3, #2
   176ea:	e7ef      	b.n	176cc <nrfx_twi_1_irq_handler+0x78>
            else if (errorsrc & NRF_TWI_ERROR_OVERRUN)
   176ec:	07da      	lsls	r2, r3, #31
   176ee:	d5ef      	bpl.n	176d0 <nrfx_twi_1_irq_handler+0x7c>
                event.type = NRFX_TWI_EVT_OVERRUN;
   176f0:	2303      	movs	r3, #3
   176f2:	e7eb      	b.n	176cc <nrfx_twi_1_irq_handler+0x78>
            event.type = NRFX_TWI_EVT_DONE;
   176f4:	f88d 7000 	strb.w	r7, [sp]
   176f8:	e7ea      	b.n	176d0 <nrfx_twi_1_irq_handler+0x7c>
   176fa:	bf00      	nop
   176fc:	20001910 	.word	0x20001910
   17700:	2000191c 	.word	0x2000191c

00017704 <z_sys_device_do_config_level>:
		__device_APPLICATION_start,
		/* End marker */
		__device_init_end,
	};

	for (info = config_levels[level]; info < config_levels[level+1];
   17704:	4b09      	ldr	r3, [pc, #36]	; (1772c <z_sys_device_do_config_level+0x28>)
{
   17706:	b570      	push	{r4, r5, r6, lr}
	for (info = config_levels[level]; info < config_levels[level+1];
   17708:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   1770c:	3001      	adds	r0, #1
		retval = device_conf->init(info);
		if (retval != 0) {
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
   1770e:	2600      	movs	r6, #0
	for (info = config_levels[level]; info < config_levels[level+1];
   17710:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
   17714:	42a5      	cmp	r5, r4
   17716:	d800      	bhi.n	1771a <z_sys_device_do_config_level+0x16>
		} else {
			z_object_init(info);
		}
	}
}
   17718:	bd70      	pop	{r4, r5, r6, pc}
		retval = device_conf->init(info);
   1771a:	6823      	ldr	r3, [r4, #0]
   1771c:	4620      	mov	r0, r4
   1771e:	685b      	ldr	r3, [r3, #4]
   17720:	4798      	blx	r3
		if (retval != 0) {
   17722:	b100      	cbz	r0, 17726 <z_sys_device_do_config_level+0x22>
			info->driver_api = NULL;
   17724:	6066      	str	r6, [r4, #4]
								info++) {
   17726:	340c      	adds	r4, #12
   17728:	e7f4      	b.n	17714 <z_sys_device_do_config_level+0x10>
   1772a:	bf00      	nop
   1772c:	0001f770 	.word	0x0001f770

00017730 <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
   17730:	4b10      	ldr	r3, [pc, #64]	; (17774 <z_impl_device_get_binding+0x44>)
{
   17732:	b570      	push	{r4, r5, r6, lr}
	for (info = __device_init_start; info != __device_init_end; info++) {
   17734:	4c10      	ldr	r4, [pc, #64]	; (17778 <z_impl_device_get_binding+0x48>)
{
   17736:	4605      	mov	r5, r0
   17738:	461e      	mov	r6, r3
	for (info = __device_init_start; info != __device_init_end; info++) {
   1773a:	429c      	cmp	r4, r3
   1773c:	d104      	bne.n	17748 <z_impl_device_get_binding+0x18>
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
   1773e:	4c0e      	ldr	r4, [pc, #56]	; (17778 <z_impl_device_get_binding+0x48>)
   17740:	42b4      	cmp	r4, r6
   17742:	d109      	bne.n	17758 <z_impl_device_get_binding+0x28>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
   17744:	2400      	movs	r4, #0
   17746:	e012      	b.n	1776e <z_impl_device_get_binding+0x3e>
		if ((info->driver_api != NULL) &&
   17748:	6862      	ldr	r2, [r4, #4]
   1774a:	b11a      	cbz	r2, 17754 <z_impl_device_get_binding+0x24>
		    (info->config->name == name)) {
   1774c:	6822      	ldr	r2, [r4, #0]
		if ((info->driver_api != NULL) &&
   1774e:	6812      	ldr	r2, [r2, #0]
   17750:	42aa      	cmp	r2, r5
   17752:	d00c      	beq.n	1776e <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
   17754:	340c      	adds	r4, #12
   17756:	e7f0      	b.n	1773a <z_impl_device_get_binding+0xa>
		if (info->driver_api == NULL) {
   17758:	6863      	ldr	r3, [r4, #4]
   1775a:	b90b      	cbnz	r3, 17760 <z_impl_device_get_binding+0x30>
	for (info = __device_init_start; info != __device_init_end; info++) {
   1775c:	340c      	adds	r4, #12
   1775e:	e7ef      	b.n	17740 <z_impl_device_get_binding+0x10>
		if (strcmp(name, info->config->name) == 0) {
   17760:	6823      	ldr	r3, [r4, #0]
   17762:	4628      	mov	r0, r5
   17764:	6819      	ldr	r1, [r3, #0]
   17766:	f003 fc1d 	bl	1afa4 <strcmp>
   1776a:	2800      	cmp	r0, #0
   1776c:	d1f6      	bne.n	1775c <z_impl_device_get_binding+0x2c>
}
   1776e:	4620      	mov	r0, r4
   17770:	bd70      	pop	{r4, r5, r6, pc}
   17772:	bf00      	nop
   17774:	20005bc8 	.word	0x20005bc8
   17778:	20005b14 	.word	0x20005b14

0001777c <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   1777c:	4b01      	ldr	r3, [pc, #4]	; (17784 <z_impl_z_errno+0x8>)
   1777e:	6898      	ldr	r0, [r3, #8]
}
   17780:	3054      	adds	r0, #84	; 0x54
   17782:	4770      	bx	lr
   17784:	20001a24 	.word	0x20001a24

00017788 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
   17788:	b510      	push	{r4, lr}
   1778a:	4604      	mov	r4, r0
	z_impl_log_panic();
   1778c:	f7eb fce6 	bl	315c <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
   17790:	2301      	movs	r3, #1
   17792:	f04f 0100 	mov.w	r1, #0
   17796:	f363 0107 	bfi	r1, r3, #0, #8
   1779a:	4a06      	ldr	r2, [pc, #24]	; (177b4 <k_sys_fatal_error_handler+0x2c>)
   1779c:	4b06      	ldr	r3, [pc, #24]	; (177b8 <k_sys_fatal_error_handler+0x30>)
   1779e:	4807      	ldr	r0, [pc, #28]	; (177bc <k_sys_fatal_error_handler+0x34>)
   177a0:	1a9b      	subs	r3, r3, r2
   177a2:	08db      	lsrs	r3, r3, #3
   177a4:	f363 118f 	bfi	r1, r3, #6, #10
   177a8:	f002 ff33 	bl	1a612 <log_0>
	arch_system_halt(reason);
   177ac:	4620      	mov	r0, r4
   177ae:	f006 fd2c 	bl	1e20a <arch_system_halt>
   177b2:	bf00      	nop
   177b4:	0001ed28 	.word	0x0001ed28
   177b8:	0001ee58 	.word	0x0001ee58
   177bc:	00022609 	.word	0x00022609

000177c0 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   177c0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   177c4:	4605      	mov	r5, r0
   177c6:	4688      	mov	r8, r1
	return z_impl_k_current_get();
   177c8:	f000 fe56 	bl	18478 <z_impl_k_current_get>
	struct k_thread *thread = k_current_get();

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   177cc:	2201      	movs	r2, #1
   177ce:	f04f 0300 	mov.w	r3, #0
   177d2:	f362 0307 	bfi	r3, r2, #0, #8
   177d6:	4c24      	ldr	r4, [pc, #144]	; (17868 <z_fatal_error+0xa8>)
   177d8:	4a24      	ldr	r2, [pc, #144]	; (1786c <z_fatal_error+0xac>)
   177da:	2d04      	cmp	r5, #4
   177dc:	eba4 0402 	sub.w	r4, r4, r2
   177e0:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   177e4:	bf96      	itet	ls
   177e6:	4a22      	ldrls	r2, [pc, #136]	; (17870 <z_fatal_error+0xb0>)
   177e8:	4a22      	ldrhi	r2, [pc, #136]	; (17874 <z_fatal_error+0xb4>)
   177ea:	f852 2025 	ldrls.w	r2, [r2, r5, lsl #2]
   177ee:	f364 138f 	bfi	r3, r4, #6, #10
   177f2:	f8ad 3000 	strh.w	r3, [sp]
   177f6:	4606      	mov	r6, r0
   177f8:	2300      	movs	r3, #0
   177fa:	4629      	mov	r1, r5
   177fc:	481e      	ldr	r0, [pc, #120]	; (17878 <z_fatal_error+0xb8>)
   177fe:	f002 ff41 	bl	1a684 <log_3>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   17802:	f8d8 301c 	ldr.w	r3, [r8, #28]
   17806:	f3c3 0308 	ubfx	r3, r3, #0, #9
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if (arch_is_in_nested_exception(esf)) {
   1780a:	b14b      	cbz	r3, 17820 <z_fatal_error+0x60>
		LOG_ERR("Fault during interrupt handling\n");
   1780c:	f04f 0100 	mov.w	r1, #0
   17810:	2301      	movs	r3, #1
   17812:	f363 0107 	bfi	r1, r3, #0, #8
   17816:	f364 118f 	bfi	r1, r4, #6, #10
   1781a:	4818      	ldr	r0, [pc, #96]	; (1787c <z_fatal_error+0xbc>)
   1781c:	f002 fef9 	bl	1a612 <log_0>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   17820:	f04f 0700 	mov.w	r7, #0
   17824:	2301      	movs	r3, #1
   17826:	f363 0707 	bfi	r7, r3, #0, #8
	const char *thread_name = k_thread_name_get(thread);
   1782a:	4630      	mov	r0, r6
	LOG_ERR("Current thread: %p (%s)", thread,
   1782c:	f364 178f 	bfi	r7, r4, #6, #10
	const char *thread_name = k_thread_name_get(thread);
   17830:	f006 ff1a 	bl	1e668 <k_thread_name_get>
	if (thread_name == NULL || thread_name[0] == '\0') {
   17834:	b1b0      	cbz	r0, 17864 <z_fatal_error+0xa4>
   17836:	7802      	ldrb	r2, [r0, #0]
		thread_name = "unknown";
   17838:	4b11      	ldr	r3, [pc, #68]	; (17880 <z_fatal_error+0xc0>)
   1783a:	2a00      	cmp	r2, #0
   1783c:	bf08      	it	eq
   1783e:	4618      	moveq	r0, r3
	LOG_ERR("Current thread: %p (%s)", thread,
   17840:	f7eb fb20 	bl	2e84 <log_strdup>
   17844:	463b      	mov	r3, r7
   17846:	4602      	mov	r2, r0
   17848:	4631      	mov	r1, r6
   1784a:	480e      	ldr	r0, [pc, #56]	; (17884 <z_fatal_error+0xc4>)
   1784c:	f002 ff02 	bl	1a654 <log_2>
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
   17850:	4641      	mov	r1, r8
   17852:	4628      	mov	r0, r5
   17854:	f7ff ff98 	bl	17788 <k_sys_fatal_error_handler>
	z_impl_k_thread_abort(thread);
   17858:	4630      	mov	r0, r6
			}
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	k_thread_abort(thread);
}
   1785a:	b002      	add	sp, #8
   1785c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   17860:	f7ed b968 	b.w	4b34 <z_impl_k_thread_abort>
		thread_name = "unknown";
   17864:	4806      	ldr	r0, [pc, #24]	; (17880 <z_fatal_error+0xc0>)
   17866:	e7eb      	b.n	17840 <z_fatal_error+0x80>
   17868:	0001ee58 	.word	0x0001ee58
   1786c:	0001ed28 	.word	0x0001ed28
   17870:	0001f788 	.word	0x0001f788
   17874:	00022662 	.word	0x00022662
   17878:	00022670 	.word	0x00022670
   1787c:	00022698 	.word	0x00022698
   17880:	00020cbe 	.word	0x00020cbe
   17884:	000226b9 	.word	0x000226b9

00017888 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
   17888:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
   1788a:	4d0b      	ldr	r5, [pc, #44]	; (178b8 <idle+0x30>)
	__asm__ volatile(
   1788c:	f04f 0220 	mov.w	r2, #32
   17890:	f3ef 8311 	mrs	r3, BASEPRI
   17894:	f382 8811 	msr	BASEPRI, r2
   17898:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
   1789c:	f006 ff87 	bl	1e7ae <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   178a0:	2101      	movs	r1, #1
   178a2:	2802      	cmp	r0, #2
	s32_t ticks = z_get_next_timeout_expiry();
   178a4:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   178a6:	bfd8      	it	le
   178a8:	4608      	movle	r0, r1
   178aa:	f006 ff90 	bl	1e7ce <z_set_timeout_expiry>
	_kernel.idle = ticks;
   178ae:	622c      	str	r4, [r5, #32]
	arch_cpu_idle();
   178b0:	f7ec fdf0 	bl	4494 <arch_cpu_idle>
   178b4:	e7ea      	b.n	1788c <idle+0x4>
   178b6:	bf00      	nop
   178b8:	20001a24 	.word	0x20001a24

000178bc <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   178bc:	4802      	ldr	r0, [pc, #8]	; (178c8 <z_bss_zero+0xc>)
   178be:	4a03      	ldr	r2, [pc, #12]	; (178cc <z_bss_zero+0x10>)
   178c0:	2100      	movs	r1, #0
   178c2:	1a12      	subs	r2, r2, r0
   178c4:	f003 bbc3 	b.w	1b04e <memset>
   178c8:	20000000 	.word	0x20000000
   178cc:	20001df0 	.word	0x20001df0

000178d0 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   178d0:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
   178d2:	4806      	ldr	r0, [pc, #24]	; (178ec <z_data_copy+0x1c>)
	(void)memcpy(&__data_ram_start, &__data_rom_start,
   178d4:	4a06      	ldr	r2, [pc, #24]	; (178f0 <z_data_copy+0x20>)
   178d6:	4907      	ldr	r1, [pc, #28]	; (178f4 <z_data_copy+0x24>)
   178d8:	1a12      	subs	r2, r2, r0
   178da:	f003 fb8e 	bl	1affa <memcpy>
#ifdef CONFIG_ARCH_HAS_RAMFUNC_SUPPORT
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
   178de:	4a06      	ldr	r2, [pc, #24]	; (178f8 <z_data_copy+0x28>)
   178e0:	4906      	ldr	r1, [pc, #24]	; (178fc <z_data_copy+0x2c>)
   178e2:	4807      	ldr	r0, [pc, #28]	; (17900 <z_data_copy+0x30>)
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   178e4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
   178e8:	f003 bb87 	b.w	1affa <memcpy>
   178ec:	20005438 	.word	0x20005438
   178f0:	20005da8 	.word	0x20005da8
   178f4:	000226f7 	.word	0x000226f7
   178f8:	00000000 	.word	0x00000000
   178fc:	000226f4 	.word	0x000226f4
   17900:	20000000 	.word	0x20000000

00017904 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
   17904:	b508      	push	{r3, lr}
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
   17906:	4b09      	ldr	r3, [pc, #36]	; (1792c <bg_thread_main+0x28>)
   17908:	2201      	movs	r2, #1

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   1790a:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   1790c:	701a      	strb	r2, [r3, #0]
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   1790e:	f7ff fef9 	bl	17704 <z_sys_device_do_config_level>
			KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
   17912:	2003      	movs	r0, #3
   17914:	f7ff fef6 	bl	17704 <z_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
   17918:	f000 fea8 	bl	1866c <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
   1791c:	f7ea feba 	bl	2694 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   17920:	4a03      	ldr	r2, [pc, #12]	; (17930 <bg_thread_main+0x2c>)
   17922:	7b13      	ldrb	r3, [r2, #12]
   17924:	f023 0301 	bic.w	r3, r3, #1
   17928:	7313      	strb	r3, [r2, #12]

	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   1792a:	bd08      	pop	{r3, pc}
   1792c:	20001def 	.word	0x20001def
   17930:	200019b8 	.word	0x200019b8

00017934 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
   17934:	b580      	push	{r7, lr}
   17936:	b0a2      	sub	sp, #136	; 0x88
#endif	/* CONFIG_STACK_CANARIES */

	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
   17938:	f7eb fa0a 	bl	2d50 <log_core_init>
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(_interrupt_stack)) +
   1793c:	4b35      	ldr	r3, [pc, #212]	; (17a14 <z_cstart+0xe0>)
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   1793e:	f383 8808 	msr	MSP, r3
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
   17942:	4c35      	ldr	r4, [pc, #212]	; (17a18 <z_cstart+0xe4>)
	_kernel.ready_q.cache = &z_main_thread;
   17944:	4e35      	ldr	r6, [pc, #212]	; (17a1c <z_cstart+0xe8>)
   17946:	6963      	ldr	r3, [r4, #20]
   17948:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   1794c:	6163      	str	r3, [r4, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1794e:	2500      	movs	r5, #0
   17950:	23e0      	movs	r3, #224	; 0xe0
   17952:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
   17956:	77e5      	strb	r5, [r4, #31]
   17958:	7625      	strb	r5, [r4, #24]
   1795a:	7665      	strb	r5, [r4, #25]
   1795c:	76a5      	strb	r5, [r4, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   1795e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   17960:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   17964:	6263      	str	r3, [r4, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   17966:	f7ed f8d1 	bl	4b0c <z_arm_fault_init>
	z_arm_cpu_idle_init();
   1796a:	f7ec fd8d 	bl	4488 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   1796e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   17972:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   17974:	62e3      	str	r3, [r4, #44]	; 0x2c

	/* perform any architecture-specific initialization */
	arch_kernel_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
   17976:	ab07      	add	r3, sp, #28
   17978:	226c      	movs	r2, #108	; 0x6c
   1797a:	4629      	mov	r1, r5
   1797c:	4618      	mov	r0, r3
   1797e:	f003 fb66 	bl	1b04e <memset>
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
   17982:	4c27      	ldr	r4, [pc, #156]	; (17a20 <z_cstart+0xec>)
	struct k_thread dummy_thread = {
   17984:	2701      	movs	r7, #1
	_current = &dummy_thread;
   17986:	60a0      	str	r0, [r4, #8]
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   17988:	4628      	mov	r0, r5
	struct k_thread dummy_thread = {
   1798a:	f88d 7029 	strb.w	r7, [sp, #41]	; 0x29
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   1798e:	f7ff feb9 	bl	17704 <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   17992:	4638      	mov	r0, r7
   17994:	f7ff feb6 	bl	17704 <z_sys_device_do_config_level>
	z_sched_init();
   17998:	f000 fcee 	bl	18378 <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
   1799c:	4b21      	ldr	r3, [pc, #132]	; (17a24 <z_cstart+0xf0>)
	_kernel.ready_q.cache = &z_main_thread;
   1799e:	6266      	str	r6, [r4, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
   179a0:	f44f 6280 	mov.w	r2, #1024	; 0x400
   179a4:	e9cd 7304 	strd	r7, r3, [sp, #16]
   179a8:	e9cd 5502 	strd	r5, r5, [sp, #8]
   179ac:	4b1e      	ldr	r3, [pc, #120]	; (17a28 <z_cstart+0xf4>)
   179ae:	491f      	ldr	r1, [pc, #124]	; (17a2c <z_cstart+0xf8>)
   179b0:	e9cd 5500 	strd	r5, r5, [sp]
   179b4:	4630      	mov	r0, r6
   179b6:	f000 fdf1 	bl	1859c <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   179ba:	7b73      	ldrb	r3, [r6, #13]
   179bc:	f023 0204 	bic.w	r2, r3, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   179c0:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
   179c4:	7372      	strb	r2, [r6, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   179c6:	d104      	bne.n	179d2 <z_cstart+0x9e>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
   179c8:	69b3      	ldr	r3, [r6, #24]
   179ca:	b913      	cbnz	r3, 179d2 <z_cstart+0x9e>
		z_add_thread_to_ready_q(thread);
   179cc:	4630      	mov	r0, r6
   179ce:	f000 fa9d 	bl	17f0c <z_add_thread_to_ready_q>
	z_setup_new_thread(thread, stack,
   179d2:	4b17      	ldr	r3, [pc, #92]	; (17a30 <z_cstart+0xfc>)
   179d4:	4d17      	ldr	r5, [pc, #92]	; (17a34 <z_cstart+0x100>)
   179d6:	9305      	str	r3, [sp, #20]
   179d8:	2201      	movs	r2, #1
   179da:	230f      	movs	r3, #15
   179dc:	e9cd 3203 	strd	r3, r2, [sp, #12]
   179e0:	2300      	movs	r3, #0
   179e2:	e9cd 3301 	strd	r3, r3, [sp, #4]
   179e6:	9300      	str	r3, [sp, #0]
   179e8:	f44f 72a0 	mov.w	r2, #320	; 0x140
   179ec:	4b12      	ldr	r3, [pc, #72]	; (17a38 <z_cstart+0x104>)
   179ee:	4913      	ldr	r1, [pc, #76]	; (17a3c <z_cstart+0x108>)
   179f0:	4628      	mov	r0, r5
   179f2:	f000 fdd3 	bl	1859c <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_PRESTART;
   179f6:	7b6b      	ldrb	r3, [r5, #13]
	_kernel.cpus[0].idle_thread = &z_idle_thread;
   179f8:	60e5      	str	r5, [r4, #12]
   179fa:	f023 0304 	bic.w	r3, r3, #4
   179fe:	736b      	strb	r3, [r5, #13]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
   17a00:	4b0f      	ldr	r3, [pc, #60]	; (17a40 <z_cstart+0x10c>)
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
   17a02:	490a      	ldr	r1, [pc, #40]	; (17a2c <z_cstart+0xf8>)
   17a04:	4805      	ldr	r0, [pc, #20]	; (17a1c <z_cstart+0xe8>)
	list->tail = (sys_dnode_t *)list;
   17a06:	e9c4 3306 	strd	r3, r3, [r4, #24]
   17a0a:	f44f 6280 	mov.w	r2, #1024	; 0x400
   17a0e:	4b06      	ldr	r3, [pc, #24]	; (17a28 <z_cstart+0xf4>)
   17a10:	f7ec fd1c 	bl	444c <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   17a14:	200040b0 	.word	0x200040b0
   17a18:	e000ed00 	.word	0xe000ed00
   17a1c:	200019b8 	.word	0x200019b8
   17a20:	20001a24 	.word	0x20001a24
   17a24:	000226d4 	.word	0x000226d4
   17a28:	00017905 	.word	0x00017905
   17a2c:	20003370 	.word	0x20003370
   17a30:	000226d9 	.word	0x000226d9
   17a34:	2000194c 	.word	0x2000194c
   17a38:	00017889 	.word	0x00017889
   17a3c:	20003770 	.word	0x20003770
   17a40:	20001a3c 	.word	0x20001a3c

00017a44 <init_mem_slab_module>:
 */
static int init_mem_slab_module(struct device *dev)
{
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   17a44:	4b0b      	ldr	r3, [pc, #44]	; (17a74 <init_mem_slab_module+0x30>)
   17a46:	480c      	ldr	r0, [pc, #48]	; (17a78 <init_mem_slab_module+0x34>)
{
   17a48:	b570      	push	{r4, r5, r6, lr}
	slab->free_list = NULL;
   17a4a:	2400      	movs	r4, #0
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   17a4c:	4283      	cmp	r3, r0
   17a4e:	d301      	bcc.n	17a54 <init_mem_slab_module+0x10>
		create_free_list(slab);
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}
	return 0;
}
   17a50:	2000      	movs	r0, #0
   17a52:	bd70      	pop	{r4, r5, r6, pc}
	p = slab->buffer;
   17a54:	691a      	ldr	r2, [r3, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
   17a56:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
   17a58:	615c      	str	r4, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   17a5a:	2100      	movs	r1, #0
   17a5c:	42a9      	cmp	r1, r5
   17a5e:	d101      	bne.n	17a64 <init_mem_slab_module+0x20>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   17a60:	331c      	adds	r3, #28
   17a62:	e7f3      	b.n	17a4c <init_mem_slab_module+0x8>
		*(char **)p = slab->free_list;
   17a64:	695e      	ldr	r6, [r3, #20]
   17a66:	6016      	str	r6, [r2, #0]
		p += slab->block_size;
   17a68:	68de      	ldr	r6, [r3, #12]
		slab->free_list = p;
   17a6a:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   17a6c:	3101      	adds	r1, #1
		p += slab->block_size;
   17a6e:	4432      	add	r2, r6
   17a70:	e7f4      	b.n	17a5c <init_mem_slab_module+0x18>
   17a72:	bf00      	nop
   17a74:	20005bc8 	.word	0x20005bc8
   17a78:	20005c00 	.word	0x20005c00

00017a7c <k_mem_slab_alloc>:

	z_object_init(slab);
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, s32_t timeout)
{
   17a7c:	b510      	push	{r4, lr}
   17a7e:	4613      	mov	r3, r2
   17a80:	460c      	mov	r4, r1
   17a82:	f04f 0220 	mov.w	r2, #32
   17a86:	f3ef 8111 	mrs	r1, BASEPRI
   17a8a:	f382 8811 	msr	BASEPRI, r2
   17a8e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
   17a92:	6942      	ldr	r2, [r0, #20]
   17a94:	b15a      	cbz	r2, 17aae <k_mem_slab_alloc+0x32>
		/* take a free block */
		*mem = slab->free_list;
   17a96:	6022      	str	r2, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
   17a98:	6813      	ldr	r3, [r2, #0]
   17a9a:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   17a9c:	6983      	ldr	r3, [r0, #24]
   17a9e:	3301      	adds	r3, #1
   17aa0:	6183      	str	r3, [r0, #24]
		result = 0;
   17aa2:	2000      	movs	r0, #0
	__asm__ volatile(
   17aa4:	f381 8811 	msr	BASEPRI, r1
   17aa8:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
   17aac:	e00d      	b.n	17aca <k_mem_slab_alloc+0x4e>
	} else if (timeout == K_NO_WAIT) {
   17aae:	b91b      	cbnz	r3, 17ab8 <k_mem_slab_alloc+0x3c>
		*mem = NULL;
   17ab0:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
   17ab2:	f06f 000b 	mvn.w	r0, #11
   17ab6:	e7f5      	b.n	17aa4 <k_mem_slab_alloc+0x28>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
   17ab8:	4602      	mov	r2, r0
   17aba:	4804      	ldr	r0, [pc, #16]	; (17acc <k_mem_slab_alloc+0x50>)
   17abc:	f000 fbd8 	bl	18270 <z_pend_curr>
		if (result == 0) {
   17ac0:	b918      	cbnz	r0, 17aca <k_mem_slab_alloc+0x4e>
			*mem = _current->base.swap_data;
   17ac2:	4b03      	ldr	r3, [pc, #12]	; (17ad0 <k_mem_slab_alloc+0x54>)
   17ac4:	689b      	ldr	r3, [r3, #8]
   17ac6:	695b      	ldr	r3, [r3, #20]
   17ac8:	6023      	str	r3, [r4, #0]
}
   17aca:	bd10      	pop	{r4, pc}
   17acc:	20001df0 	.word	0x20001df0
   17ad0:	20001a24 	.word	0x20001a24

00017ad4 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   17ad4:	b570      	push	{r4, r5, r6, lr}
   17ad6:	4604      	mov	r4, r0
   17ad8:	460d      	mov	r5, r1
	__asm__ volatile(
   17ada:	f04f 0320 	mov.w	r3, #32
   17ade:	f3ef 8611 	mrs	r6, BASEPRI
   17ae2:	f383 8811 	msr	BASEPRI, r3
   17ae6:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   17aea:	f006 fd6e 	bl	1e5ca <z_unpend_first_thread>

	if (pending_thread != NULL) {
   17aee:	b180      	cbz	r0, 17b12 <k_mem_slab_free+0x3e>
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   17af0:	682a      	ldr	r2, [r5, #0]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   17af2:	6142      	str	r2, [r0, #20]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   17af4:	7b42      	ldrb	r2, [r0, #13]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   17af6:	2100      	movs	r1, #0
   17af8:	06d2      	lsls	r2, r2, #27
   17afa:	6681      	str	r1, [r0, #104]	; 0x68
   17afc:	d103      	bne.n	17b06 <k_mem_slab_free+0x32>
	if (z_is_thread_ready(thread)) {
   17afe:	6983      	ldr	r3, [r0, #24]
   17b00:	b90b      	cbnz	r3, 17b06 <k_mem_slab_free+0x32>
		z_add_thread_to_ready_q(thread);
   17b02:	f000 fa03 	bl	17f0c <z_add_thread_to_ready_q>
		z_ready_thread(pending_thread);
		z_reschedule(&lock, key);
   17b06:	4631      	mov	r1, r6
   17b08:	4808      	ldr	r0, [pc, #32]	; (17b2c <k_mem_slab_free+0x58>)
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
   17b0a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   17b0e:	f006 bce6 	b.w	1e4de <z_reschedule>
		**(char ***)mem = slab->free_list;
   17b12:	682b      	ldr	r3, [r5, #0]
   17b14:	6962      	ldr	r2, [r4, #20]
   17b16:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
   17b18:	682b      	ldr	r3, [r5, #0]
   17b1a:	6163      	str	r3, [r4, #20]
		slab->num_used--;
   17b1c:	69a3      	ldr	r3, [r4, #24]
   17b1e:	3b01      	subs	r3, #1
   17b20:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   17b22:	f386 8811 	msr	BASEPRI, r6
   17b26:	f3bf 8f6f 	isb	sy
}
   17b2a:	bd70      	pop	{r4, r5, r6, pc}
   17b2c:	20001df0 	.word	0x20001df0

00017b30 <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
   17b30:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);

	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
   17b32:	4c07      	ldr	r4, [pc, #28]	; (17b50 <init_static_pools+0x20>)
   17b34:	4d07      	ldr	r5, [pc, #28]	; (17b54 <init_static_pools+0x24>)
   17b36:	42ac      	cmp	r4, r5
   17b38:	d301      	bcc.n	17b3e <init_static_pools+0xe>
		k_mem_pool_init(p);
	}

	return 0;
}
   17b3a:	2000      	movs	r0, #0
   17b3c:	bd38      	pop	{r3, r4, r5, pc}
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   17b3e:	f104 0314 	add.w	r3, r4, #20
	z_sys_mem_pool_base_init(&p->base);
   17b42:	4620      	mov	r0, r4
   17b44:	e9c4 3305 	strd	r3, r3, [r4, #20]
   17b48:	f001 f8ee 	bl	18d28 <z_sys_mem_pool_base_init>
	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
   17b4c:	341c      	adds	r4, #28
   17b4e:	e7f2      	b.n	17b36 <init_static_pools+0x6>
   17b50:	20005c00 	.word	0x20005c00
   17b54:	20005c00 	.word	0x20005c00

00017b58 <k_mem_pool_alloc>:

SYS_INIT(init_static_pools, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, s32_t timeout)
{
   17b58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int ret;
	s64_t end = 0;

	__ASSERT(!(arch_is_in_isr() && timeout != K_NO_WAIT), "");

	if (timeout > 0) {
   17b5c:	1e1c      	subs	r4, r3, #0
{
   17b5e:	b085      	sub	sp, #20
   17b60:	4607      	mov	r7, r0
   17b62:	460d      	mov	r5, r1
   17b64:	4692      	mov	sl, r2
	if (timeout > 0) {
   17b66:	dd3b      	ble.n	17be0 <k_mem_pool_alloc+0x88>
	return z_impl_k_uptime_get();
   17b68:	f006 fe4f 	bl	1e80a <z_impl_k_uptime_get>
		end = k_uptime_get() + timeout;
   17b6c:	eb10 0804 	adds.w	r8, r0, r4
	return pool - &_k_mem_pool_list_start[0];
   17b70:	4b1d      	ldr	r3, [pc, #116]	; (17be8 <k_mem_pool_alloc+0x90>)
   17b72:	4e1e      	ldr	r6, [pc, #120]	; (17bec <k_mem_pool_alloc+0x94>)
   17b74:	1afb      	subs	r3, r7, r3
   17b76:	109b      	asrs	r3, r3, #2
   17b78:	435e      	muls	r6, r3
		u32_t level_num, block_num;

		ret = z_sys_mem_pool_block_alloc(&p->base, size,
						 &level_num, &block_num,
						 &block->data);
		block->id.pool = pool_id(p);
   17b7a:	b2f6      	uxtb	r6, r6
		if (ret == 0 || timeout == K_NO_WAIT ||
		    ret != -ENOMEM) {
			return ret;
		}

		z_pend_curr_unlocked(&p->wait_q, timeout);
   17b7c:	f107 0b14 	add.w	fp, r7, #20
		ret = z_sys_mem_pool_block_alloc(&p->base, size,
   17b80:	ab03      	add	r3, sp, #12
   17b82:	aa02      	add	r2, sp, #8
   17b84:	9500      	str	r5, [sp, #0]
   17b86:	4651      	mov	r1, sl
   17b88:	4638      	mov	r0, r7
   17b8a:	f001 f913 	bl	18db4 <z_sys_mem_pool_block_alloc>
		block->id.level = level_num;
   17b8e:	796b      	ldrb	r3, [r5, #5]
   17b90:	9a02      	ldr	r2, [sp, #8]
		block->id.pool = pool_id(p);
   17b92:	712e      	strb	r6, [r5, #4]
		block->id.level = level_num;
   17b94:	f362 0303 	bfi	r3, r2, #0, #4
   17b98:	716b      	strb	r3, [r5, #5]
		block->id.block = block_num;
   17b9a:	686b      	ldr	r3, [r5, #4]
   17b9c:	9a03      	ldr	r2, [sp, #12]
   17b9e:	f362 331f 	bfi	r3, r2, #12, #20
   17ba2:	606b      	str	r3, [r5, #4]
		if (ret == 0 || timeout == K_NO_WAIT ||
   17ba4:	b1c8      	cbz	r0, 17bda <k_mem_pool_alloc+0x82>
   17ba6:	b1c4      	cbz	r4, 17bda <k_mem_pool_alloc+0x82>
   17ba8:	f110 0f0c 	cmn.w	r0, #12
   17bac:	d115      	bne.n	17bda <k_mem_pool_alloc+0x82>
	__asm__ volatile(
   17bae:	f04f 0320 	mov.w	r3, #32
   17bb2:	f3ef 8011 	mrs	r0, BASEPRI
   17bb6:	f383 8811 	msr	BASEPRI, r3
   17bba:	f3bf 8f6f 	isb	sy
	(void) z_pend_curr_irqlock(arch_irq_lock(), wait_q, timeout);
   17bbe:	4622      	mov	r2, r4
   17bc0:	4659      	mov	r1, fp
   17bc2:	f000 fb31 	bl	18228 <z_pend_curr_irqlock>

		if (timeout != K_FOREVER) {
   17bc6:	1c63      	adds	r3, r4, #1
   17bc8:	d0da      	beq.n	17b80 <k_mem_pool_alloc+0x28>
   17bca:	f006 fe1e 	bl	1e80a <z_impl_k_uptime_get>
			timeout = end - k_uptime_get();
   17bce:	eba8 0400 	sub.w	r4, r8, r0
			if (timeout <= 0) {
   17bd2:	2c00      	cmp	r4, #0
   17bd4:	dcd4      	bgt.n	17b80 <k_mem_pool_alloc+0x28>
				break;
			}
		}
	}

	return -EAGAIN;
   17bd6:	f06f 000a 	mvn.w	r0, #10
}
   17bda:	b005      	add	sp, #20
   17bdc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	s64_t end = 0;
   17be0:	f04f 0800 	mov.w	r8, #0
   17be4:	e7c4      	b.n	17b70 <k_mem_pool_alloc+0x18>
   17be6:	bf00      	nop
   17be8:	20005c00 	.word	0x20005c00
   17bec:	b6db6db7 	.word	0xb6db6db7

00017bf0 <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
   17bf0:	b570      	push	{r4, r5, r6, lr}
   17bf2:	7804      	ldrb	r4, [r0, #0]
	int need_sched = 0;
	struct k_mem_pool *p = get_pool(id->pool);

	z_sys_mem_pool_block_free(&p->base, id->level, id->block);
   17bf4:	6802      	ldr	r2, [r0, #0]
   17bf6:	7841      	ldrb	r1, [r0, #1]
   17bf8:	4e11      	ldr	r6, [pc, #68]	; (17c40 <k_mem_pool_free_id+0x50>)
   17bfa:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   17bfe:	00a4      	lsls	r4, r4, #2
   17c00:	0b12      	lsrs	r2, r2, #12
   17c02:	f001 010f 	and.w	r1, r1, #15
   17c06:	1930      	adds	r0, r6, r4
   17c08:	f001 f987 	bl	18f1a <z_sys_mem_pool_block_free>
   17c0c:	f04f 0320 	mov.w	r3, #32
   17c10:	f3ef 8511 	mrs	r5, BASEPRI
   17c14:	f383 8811 	msr	BASEPRI, r3
   17c18:	f3bf 8f6f 	isb	sy
	 * is unsynchronized.  Maybe we want to put the lock into the
	 * wait_q instead and make the API safe?)
	 */
	k_spinlock_key_t key = k_spin_lock(&lock);

	need_sched = z_unpend_all(&p->wait_q);
   17c1c:	f104 0014 	add.w	r0, r4, #20
   17c20:	4430      	add	r0, r6
   17c22:	f006 fcff 	bl	1e624 <z_unpend_all>

	if (need_sched != 0) {
   17c26:	b128      	cbz	r0, 17c34 <k_mem_pool_free_id+0x44>
		z_reschedule(&lock, key);
   17c28:	4629      	mov	r1, r5
   17c2a:	4806      	ldr	r0, [pc, #24]	; (17c44 <k_mem_pool_free_id+0x54>)
	} else {
		k_spin_unlock(&lock, key);
	}
}
   17c2c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   17c30:	f006 bc55 	b.w	1e4de <z_reschedule>
	__asm__ volatile(
   17c34:	f385 8811 	msr	BASEPRI, r5
   17c38:	f3bf 8f6f 	isb	sy
}
   17c3c:	bd70      	pop	{r4, r5, r6, pc}
   17c3e:	bf00      	nop
   17c40:	20005c00 	.word	0x20005c00
   17c44:	20001df0 	.word	0x20001df0

00017c48 <z_thread_malloc>:

void *z_thread_malloc(size_t size)
{
	void *ret;

	if (_current->resource_pool != NULL) {
   17c48:	4b03      	ldr	r3, [pc, #12]	; (17c58 <z_thread_malloc+0x10>)
   17c4a:	689b      	ldr	r3, [r3, #8]
{
   17c4c:	4601      	mov	r1, r0
	if (_current->resource_pool != NULL) {
   17c4e:	6e18      	ldr	r0, [r3, #96]	; 0x60
   17c50:	b108      	cbz	r0, 17c56 <z_thread_malloc+0xe>
		ret = k_mem_pool_malloc(_current->resource_pool, size);
   17c52:	f006 baf7 	b.w	1e244 <k_mem_pool_malloc>
	} else {
		ret = NULL;
	}

	return ret;
}
   17c56:	4770      	bx	lr
   17c58:	20001a24 	.word	0x20001a24

00017c5c <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, s32_t timeout)
{
   17c5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17c5e:	4604      	mov	r4, r0
   17c60:	460f      	mov	r7, r1
	__asm__ volatile(
   17c62:	f04f 0320 	mov.w	r3, #32
   17c66:	f3ef 8511 	mrs	r5, BASEPRI
   17c6a:	f383 8811 	msr	BASEPRI, r3
   17c6e:	f3bf 8f6f 	isb	sy
	bool resched = false;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   17c72:	68c2      	ldr	r2, [r0, #12]
   17c74:	4930      	ldr	r1, [pc, #192]	; (17d38 <z_impl_k_mutex_lock+0xdc>)
   17c76:	b15a      	cbz	r2, 17c90 <z_impl_k_mutex_lock+0x34>
   17c78:	6880      	ldr	r0, [r0, #8]
   17c7a:	688e      	ldr	r6, [r1, #8]
   17c7c:	42b0      	cmp	r0, r6
   17c7e:	d015      	beq.n	17cac <z_impl_k_mutex_lock+0x50>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
	}

	if (unlikely(timeout == (s32_t)K_NO_WAIT)) {
   17c80:	b9b7      	cbnz	r7, 17cb0 <z_impl_k_mutex_lock+0x54>
	__asm__ volatile(
   17c82:	f385 8811 	msr	BASEPRI, r5
   17c86:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
   17c8a:	f06f 000f 	mvn.w	r0, #15
   17c8e:	e00c      	b.n	17caa <z_impl_k_mutex_lock+0x4e>
					_current->base.prio :
   17c90:	688b      	ldr	r3, [r1, #8]
   17c92:	f993 300e 	ldrsb.w	r3, [r3, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   17c96:	6123      	str	r3, [r4, #16]
		mutex->lock_count++;
   17c98:	3201      	adds	r2, #1
		mutex->owner = _current;
   17c9a:	688b      	ldr	r3, [r1, #8]
		mutex->lock_count++;
   17c9c:	60e2      	str	r2, [r4, #12]
		mutex->owner = _current;
   17c9e:	60a3      	str	r3, [r4, #8]
   17ca0:	f385 8811 	msr	BASEPRI, r5
   17ca4:	f3bf 8f6f 	isb	sy
		return 0;
   17ca8:	2000      	movs	r0, #0
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
   17caa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					_current->base.prio :
   17cac:	6923      	ldr	r3, [r4, #16]
   17cae:	e7f2      	b.n	17c96 <z_impl_k_mutex_lock+0x3a>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   17cb0:	f990 300e 	ldrsb.w	r3, [r0, #14]
   17cb4:	f996 100e 	ldrsb.w	r1, [r6, #14]
   17cb8:	4299      	cmp	r1, r3
   17cba:	bfa8      	it	ge
   17cbc:	4619      	movge	r1, r3
   17cbe:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   17cc2:	4299      	cmp	r1, r3
   17cc4:	da2b      	bge.n	17d1e <z_impl_k_mutex_lock+0xc2>
		return z_set_prio(mutex->owner, new_prio);
   17cc6:	f000 fb15 	bl	182f4 <z_set_prio>
   17cca:	4606      	mov	r6, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   17ccc:	463b      	mov	r3, r7
   17cce:	4622      	mov	r2, r4
   17cd0:	4629      	mov	r1, r5
   17cd2:	481a      	ldr	r0, [pc, #104]	; (17d3c <z_impl_k_mutex_lock+0xe0>)
   17cd4:	f000 facc 	bl	18270 <z_pend_curr>
	if (got_mutex == 0) {
   17cd8:	2800      	cmp	r0, #0
   17cda:	d0e6      	beq.n	17caa <z_impl_k_mutex_lock+0x4e>
	__asm__ volatile(
   17cdc:	f04f 0320 	mov.w	r3, #32
   17ce0:	f3ef 8511 	mrs	r5, BASEPRI
   17ce4:	f383 8811 	msr	BASEPRI, r3
   17ce8:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   17cec:	6823      	ldr	r3, [r4, #0]
   17cee:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   17cf0:	429c      	cmp	r4, r3
   17cf2:	d007      	beq.n	17d04 <z_impl_k_mutex_lock+0xa8>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   17cf4:	b133      	cbz	r3, 17d04 <z_impl_k_mutex_lock+0xa8>
   17cf6:	f993 300e 	ldrsb.w	r3, [r3, #14]
   17cfa:	4299      	cmp	r1, r3
   17cfc:	bfa8      	it	ge
   17cfe:	4619      	movge	r1, r3
   17d00:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   17d04:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   17d06:	f990 300e 	ldrsb.w	r3, [r0, #14]
   17d0a:	4299      	cmp	r1, r3
   17d0c:	d109      	bne.n	17d22 <z_impl_k_mutex_lock+0xc6>
	if (resched) {
   17d0e:	b16e      	cbz	r6, 17d2c <z_impl_k_mutex_lock+0xd0>
		z_reschedule(&lock, key);
   17d10:	4629      	mov	r1, r5
   17d12:	480a      	ldr	r0, [pc, #40]	; (17d3c <z_impl_k_mutex_lock+0xe0>)
   17d14:	f006 fbe3 	bl	1e4de <z_reschedule>
	return -EAGAIN;
   17d18:	f06f 000a 	mvn.w	r0, #10
   17d1c:	e7c5      	b.n	17caa <z_impl_k_mutex_lock+0x4e>
	bool resched = false;
   17d1e:	2600      	movs	r6, #0
   17d20:	e7d4      	b.n	17ccc <z_impl_k_mutex_lock+0x70>
		return z_set_prio(mutex->owner, new_prio);
   17d22:	f000 fae7 	bl	182f4 <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   17d26:	2800      	cmp	r0, #0
   17d28:	d1f2      	bne.n	17d10 <z_impl_k_mutex_lock+0xb4>
   17d2a:	e7f0      	b.n	17d0e <z_impl_k_mutex_lock+0xb2>
	__asm__ volatile(
   17d2c:	f385 8811 	msr	BASEPRI, r5
   17d30:	f3bf 8f6f 	isb	sy
   17d34:	e7f0      	b.n	17d18 <z_impl_k_mutex_lock+0xbc>
   17d36:	bf00      	nop
   17d38:	20001a24 	.word	0x20001a24
   17d3c:	20001df0 	.word	0x20001df0

00017d40 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

void z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   17d40:	b538      	push	{r3, r4, r5, lr}
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
   17d42:	4b1d      	ldr	r3, [pc, #116]	; (17db8 <z_impl_k_mutex_unlock+0x78>)
   17d44:	689a      	ldr	r2, [r3, #8]
   17d46:	7bd3      	ldrb	r3, [r2, #15]
   17d48:	3b01      	subs	r3, #1
   17d4a:	4604      	mov	r4, r0
   17d4c:	73d3      	strb	r3, [r2, #15]
	sys_trace_void(SYS_TRACE_ID_MUTEX_UNLOCK);
	z_sched_lock();

	K_DEBUG("mutex %p lock_count: %d\n", mutex, mutex->lock_count);

	if (mutex->lock_count - 1U != 0U) {
   17d4e:	68c3      	ldr	r3, [r0, #12]
   17d50:	2b01      	cmp	r3, #1
   17d52:	d005      	beq.n	17d60 <z_impl_k_mutex_unlock+0x20>
		mutex->lock_count--;
   17d54:	3b01      	subs	r3, #1
   17d56:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	k_sched_unlock();
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);
}
   17d58:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	k_sched_unlock();
   17d5c:	f000 b8ba 	b.w	17ed4 <k_sched_unlock>
	__asm__ volatile(
   17d60:	f04f 0320 	mov.w	r3, #32
   17d64:	f3ef 8511 	mrs	r5, BASEPRI
   17d68:	f383 8811 	msr	BASEPRI, r3
   17d6c:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   17d70:	6901      	ldr	r1, [r0, #16]
   17d72:	6880      	ldr	r0, [r0, #8]
	if (mutex->owner->base.prio != new_prio) {
   17d74:	f990 300e 	ldrsb.w	r3, [r0, #14]
   17d78:	4299      	cmp	r1, r3
   17d7a:	d001      	beq.n	17d80 <z_impl_k_mutex_unlock+0x40>
		return z_set_prio(mutex->owner, new_prio);
   17d7c:	f000 faba 	bl	182f4 <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   17d80:	4620      	mov	r0, r4
   17d82:	f006 fc22 	bl	1e5ca <z_unpend_first_thread>
	mutex->owner = new_owner;
   17d86:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   17d88:	b180      	cbz	r0, 17dac <z_impl_k_mutex_unlock+0x6c>
		mutex->owner_orig_prio = new_owner->base.prio;
   17d8a:	f990 200e 	ldrsb.w	r2, [r0, #14]
   17d8e:	6122      	str	r2, [r4, #16]
   17d90:	2200      	movs	r2, #0
   17d92:	6682      	str	r2, [r0, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   17d94:	7b42      	ldrb	r2, [r0, #13]
   17d96:	06d2      	lsls	r2, r2, #27
   17d98:	d103      	bne.n	17da2 <z_impl_k_mutex_unlock+0x62>
	if (z_is_thread_ready(thread)) {
   17d9a:	6983      	ldr	r3, [r0, #24]
   17d9c:	b90b      	cbnz	r3, 17da2 <z_impl_k_mutex_unlock+0x62>
		z_add_thread_to_ready_q(thread);
   17d9e:	f000 f8b5 	bl	17f0c <z_add_thread_to_ready_q>
		z_reschedule(&lock, key);
   17da2:	4629      	mov	r1, r5
   17da4:	4805      	ldr	r0, [pc, #20]	; (17dbc <z_impl_k_mutex_unlock+0x7c>)
   17da6:	f006 fb9a 	bl	1e4de <z_reschedule>
   17daa:	e7d5      	b.n	17d58 <z_impl_k_mutex_unlock+0x18>
		mutex->lock_count = 0U;
   17dac:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   17dae:	f385 8811 	msr	BASEPRI, r5
   17db2:	f3bf 8f6f 	isb	sy
   17db6:	e7cf      	b.n	17d58 <z_impl_k_mutex_unlock+0x18>
   17db8:	20001a24 	.word	0x20001a24
   17dbc:	20001df0 	.word	0x20001df0

00017dc0 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
   17dc0:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
   17dc2:	4c08      	ldr	r4, [pc, #32]	; (17de4 <z_reset_time_slice+0x24>)
   17dc4:	6823      	ldr	r3, [r4, #0]
   17dc6:	b15b      	cbz	r3, 17de0 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   17dc8:	f7ec fa30 	bl	422c <z_clock_elapsed>
   17dcc:	6823      	ldr	r3, [r4, #0]
   17dce:	4a06      	ldr	r2, [pc, #24]	; (17de8 <z_reset_time_slice+0x28>)
   17dd0:	4418      	add	r0, r3
   17dd2:	6110      	str	r0, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
   17dd4:	2100      	movs	r1, #0
   17dd6:	4618      	mov	r0, r3
	}
}
   17dd8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_set_timeout_expiry(slice_time, false);
   17ddc:	f006 bcf7 	b.w	1e7ce <z_set_timeout_expiry>
}
   17de0:	bd10      	pop	{r4, pc}
   17de2:	bf00      	nop
   17de4:	20001a5c 	.word	0x20001a5c
   17de8:	20001a24 	.word	0x20001a24

00017dec <k_sched_time_slice_set>:

void k_sched_time_slice_set(s32_t slice, int prio)
{
   17dec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17dee:	460d      	mov	r5, r1
	__asm__ volatile(
   17df0:	f04f 0320 	mov.w	r3, #32
   17df4:	f3ef 8411 	mrs	r4, BASEPRI
   17df8:	f383 8811 	msr	BASEPRI, r3
   17dfc:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
   17e00:	4b0d      	ldr	r3, [pc, #52]	; (17e38 <k_sched_time_slice_set+0x4c>)
			return (u32_t)((t * to_hz + off) / from_hz);
   17e02:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   17e06:	f240 36e7 	movw	r6, #999	; 0x3e7
   17e0a:	2700      	movs	r7, #0
   17e0c:	fbe1 6700 	umlal	r6, r7, r1, r0
   17e10:	2200      	movs	r2, #0
   17e12:	611a      	str	r2, [r3, #16]
   17e14:	4630      	mov	r0, r6
   17e16:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   17e1a:	2300      	movs	r3, #0
   17e1c:	4639      	mov	r1, r7
   17e1e:	f7e8 f95f 	bl	e0 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
   17e22:	4b06      	ldr	r3, [pc, #24]	; (17e3c <k_sched_time_slice_set+0x50>)
   17e24:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
   17e26:	4b06      	ldr	r3, [pc, #24]	; (17e40 <k_sched_time_slice_set+0x54>)
   17e28:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
   17e2a:	f7ff ffc9 	bl	17dc0 <z_reset_time_slice>
	__asm__ volatile(
   17e2e:	f384 8811 	msr	BASEPRI, r4
   17e32:	f3bf 8f6f 	isb	sy
	}
}
   17e36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   17e38:	20001a24 	.word	0x20001a24
   17e3c:	20001a5c 	.word	0x20001a5c
   17e40:	20001a58 	.word	0x20001a58

00017e44 <k_sched_lock>:
	__asm__ volatile(
   17e44:	f04f 0320 	mov.w	r3, #32
   17e48:	f3ef 8111 	mrs	r1, BASEPRI
   17e4c:	f383 8811 	msr	BASEPRI, r3
   17e50:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
   17e54:	4b04      	ldr	r3, [pc, #16]	; (17e68 <k_sched_lock+0x24>)
   17e56:	689a      	ldr	r2, [r3, #8]
   17e58:	7bd3      	ldrb	r3, [r2, #15]
   17e5a:	3b01      	subs	r3, #1
   17e5c:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   17e5e:	f381 8811 	msr	BASEPRI, r1
   17e62:	f3bf 8f6f 	isb	sy
void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
   17e66:	4770      	bx	lr
   17e68:	20001a24 	.word	0x20001a24

00017e6c <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   17e6c:	4b09      	ldr	r3, [pc, #36]	; (17e94 <z_priq_dumb_remove+0x28>)
   17e6e:	f103 0228 	add.w	r2, r3, #40	; 0x28
   17e72:	4282      	cmp	r2, r0
   17e74:	d105      	bne.n	17e82 <z_priq_dumb_remove+0x16>
   17e76:	689b      	ldr	r3, [r3, #8]
   17e78:	428b      	cmp	r3, r1
   17e7a:	d102      	bne.n	17e82 <z_priq_dumb_remove+0x16>
   17e7c:	7b4b      	ldrb	r3, [r1, #13]
   17e7e:	06db      	lsls	r3, r3, #27
   17e80:	d106      	bne.n	17e90 <z_priq_dumb_remove+0x24>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
   17e82:	e9d1 3200 	ldrd	r3, r2, [r1]
   17e86:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   17e88:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   17e8a:	2300      	movs	r3, #0
	node->prev = NULL;
   17e8c:	e9c1 3300 	strd	r3, r3, [r1]
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
   17e90:	4770      	bx	lr
   17e92:	bf00      	nop
   17e94:	20001a24 	.word	0x20001a24

00017e98 <update_cache>:
{
   17e98:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   17e9a:	4c0d      	ldr	r4, [pc, #52]	; (17ed0 <update_cache+0x38>)
{
   17e9c:	4602      	mov	r2, r0
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   17e9e:	f104 0028 	add.w	r0, r4, #40	; 0x28
   17ea2:	f006 fb5b 	bl	1e55c <z_priq_dumb_best>
	return thread ? thread : _current_cpu->idle_thread;
   17ea6:	4605      	mov	r5, r0
   17ea8:	b900      	cbnz	r0, 17eac <update_cache+0x14>
   17eaa:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
   17eac:	68a3      	ldr	r3, [r4, #8]
   17eae:	b94a      	cbnz	r2, 17ec4 <update_cache+0x2c>
	if (z_is_thread_prevented_from_running(_current)) {
   17eb0:	7b5a      	ldrb	r2, [r3, #13]
   17eb2:	06d2      	lsls	r2, r2, #27
   17eb4:	d106      	bne.n	17ec4 <update_cache+0x2c>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   17eb6:	69aa      	ldr	r2, [r5, #24]
   17eb8:	b922      	cbnz	r2, 17ec4 <update_cache+0x2c>
	if (is_preempt(_current) || is_metairq(thread)) {
   17eba:	89da      	ldrh	r2, [r3, #14]
   17ebc:	2a7f      	cmp	r2, #127	; 0x7f
   17ebe:	d901      	bls.n	17ec4 <update_cache+0x2c>
		_kernel.ready_q.cache = _current;
   17ec0:	6263      	str	r3, [r4, #36]	; 0x24
}
   17ec2:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
   17ec4:	429d      	cmp	r5, r3
   17ec6:	d001      	beq.n	17ecc <update_cache+0x34>
			z_reset_time_slice();
   17ec8:	f7ff ff7a 	bl	17dc0 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   17ecc:	6265      	str	r5, [r4, #36]	; 0x24
}
   17ece:	e7f8      	b.n	17ec2 <update_cache+0x2a>
   17ed0:	20001a24 	.word	0x20001a24

00017ed4 <k_sched_unlock>:
{
   17ed4:	b510      	push	{r4, lr}
	__asm__ volatile(
   17ed6:	f04f 0320 	mov.w	r3, #32
   17eda:	f3ef 8411 	mrs	r4, BASEPRI
   17ede:	f383 8811 	msr	BASEPRI, r3
   17ee2:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   17ee6:	4b08      	ldr	r3, [pc, #32]	; (17f08 <k_sched_unlock+0x34>)
   17ee8:	689a      	ldr	r2, [r3, #8]
   17eea:	7bd3      	ldrb	r3, [r2, #15]
   17eec:	3301      	adds	r3, #1
   17eee:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   17ef0:	2000      	movs	r0, #0
   17ef2:	f7ff ffd1 	bl	17e98 <update_cache>
	__asm__ volatile(
   17ef6:	f384 8811 	msr	BASEPRI, r4
   17efa:	f3bf 8f6f 	isb	sy
}
   17efe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   17f02:	f006 bb03 	b.w	1e50c <z_reschedule_unlocked>
   17f06:	bf00      	nop
   17f08:	20001a24 	.word	0x20001a24

00017f0c <z_add_thread_to_ready_q>:
{
   17f0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
   17f0e:	f04f 0320 	mov.w	r3, #32
   17f12:	f3ef 8411 	mrs	r4, BASEPRI
   17f16:	f383 8811 	msr	BASEPRI, r3
   17f1a:	f3bf 8f6f 	isb	sy
	return list->head == list;
   17f1e:	4a15      	ldr	r2, [pc, #84]	; (17f74 <z_add_thread_to_ready_q+0x68>)
   17f20:	4611      	mov	r1, r2
   17f22:	f851 3f28 	ldr.w	r3, [r1, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   17f26:	428b      	cmp	r3, r1
   17f28:	d01d      	beq.n	17f66 <z_add_thread_to_ready_q+0x5a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   17f2a:	b1e3      	cbz	r3, 17f66 <z_add_thread_to_ready_q+0x5a>
   17f2c:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
	if (thread_1->base.prio < thread_2->base.prio) {
   17f2e:	f990 500e 	ldrsb.w	r5, [r0, #14]
   17f32:	f993 700e 	ldrsb.w	r7, [r3, #14]
   17f36:	42af      	cmp	r7, r5
   17f38:	dd10      	ble.n	17f5c <z_add_thread_to_ready_q+0x50>
	node->prev = successor->prev;
   17f3a:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   17f3c:	e9c0 3200 	strd	r3, r2, [r0]
	successor->prev->next = node;
   17f40:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   17f42:	6058      	str	r0, [r3, #4]
	thread->base.thread_state |= states;
   17f44:	7b43      	ldrb	r3, [r0, #13]
   17f46:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   17f4a:	7343      	strb	r3, [r0, #13]
		update_cache(0);
   17f4c:	2000      	movs	r0, #0
   17f4e:	f7ff ffa3 	bl	17e98 <update_cache>
	__asm__ volatile(
   17f52:	f384 8811 	msr	BASEPRI, r4
   17f56:	f3bf 8f6f 	isb	sy
}
   17f5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   17f5c:	42b3      	cmp	r3, r6
   17f5e:	d002      	beq.n	17f66 <z_add_thread_to_ready_q+0x5a>
   17f60:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   17f62:	2b00      	cmp	r3, #0
   17f64:	d1e5      	bne.n	17f32 <z_add_thread_to_ready_q+0x26>
	node->prev = list->tail;
   17f66:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   17f68:	6043      	str	r3, [r0, #4]
	list->tail->next = node;
   17f6a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	node->next = list;
   17f6c:	6001      	str	r1, [r0, #0]
	list->tail->next = node;
   17f6e:	6018      	str	r0, [r3, #0]
	list->tail = node;
   17f70:	62d0      	str	r0, [r2, #44]	; 0x2c
   17f72:	e7e7      	b.n	17f44 <z_add_thread_to_ready_q+0x38>
   17f74:	20001a24 	.word	0x20001a24

00017f78 <z_move_thread_to_end_of_prio_q>:
{
   17f78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17f7a:	4604      	mov	r4, r0
	__asm__ volatile(
   17f7c:	f04f 0320 	mov.w	r3, #32
   17f80:	f3ef 8511 	mrs	r5, BASEPRI
   17f84:	f383 8811 	msr	BASEPRI, r3
   17f88:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   17f8c:	7b43      	ldrb	r3, [r0, #13]
   17f8e:	065a      	lsls	r2, r3, #25
   17f90:	d503      	bpl.n	17f9a <z_move_thread_to_end_of_prio_q+0x22>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   17f92:	4601      	mov	r1, r0
   17f94:	4817      	ldr	r0, [pc, #92]	; (17ff4 <z_move_thread_to_end_of_prio_q+0x7c>)
   17f96:	f7ff ff69 	bl	17e6c <z_priq_dumb_remove>
	return list->head == list;
   17f9a:	4a17      	ldr	r2, [pc, #92]	; (17ff8 <z_move_thread_to_end_of_prio_q+0x80>)
   17f9c:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
   17fa0:	f102 0128 	add.w	r1, r2, #40	; 0x28
   17fa4:	428b      	cmp	r3, r1
   17fa6:	d01f      	beq.n	17fe8 <z_move_thread_to_end_of_prio_q+0x70>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   17fa8:	b1f3      	cbz	r3, 17fe8 <z_move_thread_to_end_of_prio_q+0x70>
	if (thread_1->base.prio < thread_2->base.prio) {
   17faa:	f994 600e 	ldrsb.w	r6, [r4, #14]
   17fae:	f993 700e 	ldrsb.w	r7, [r3, #14]
   17fb2:	42b7      	cmp	r7, r6
   17fb4:	dd13      	ble.n	17fde <z_move_thread_to_end_of_prio_q+0x66>
	node->prev = successor->prev;
   17fb6:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   17fb8:	e9c4 3100 	strd	r3, r1, [r4]
	successor->prev->next = node;
   17fbc:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   17fbe:	605c      	str	r4, [r3, #4]
   17fc0:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
   17fc2:	6890      	ldr	r0, [r2, #8]
   17fc4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   17fc8:	7363      	strb	r3, [r4, #13]
   17fca:	1b03      	subs	r3, r0, r4
   17fcc:	4258      	negs	r0, r3
   17fce:	4158      	adcs	r0, r3
   17fd0:	f7ff ff62 	bl	17e98 <update_cache>
	__asm__ volatile(
   17fd4:	f385 8811 	msr	BASEPRI, r5
   17fd8:	f3bf 8f6f 	isb	sy
}
   17fdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   17fde:	4283      	cmp	r3, r0
   17fe0:	d002      	beq.n	17fe8 <z_move_thread_to_end_of_prio_q+0x70>
   17fe2:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   17fe4:	2b00      	cmp	r3, #0
   17fe6:	d1e2      	bne.n	17fae <z_move_thread_to_end_of_prio_q+0x36>
	node->prev = list->tail;
   17fe8:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   17fec:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   17fee:	601c      	str	r4, [r3, #0]
	list->tail = node;
   17ff0:	62d4      	str	r4, [r2, #44]	; 0x2c
   17ff2:	e7e5      	b.n	17fc0 <z_move_thread_to_end_of_prio_q+0x48>
   17ff4:	20001a4c 	.word	0x20001a4c
   17ff8:	20001a24 	.word	0x20001a24

00017ffc <z_time_slice>:
	if (pending_current == _current) {
   17ffc:	4a15      	ldr	r2, [pc, #84]	; (18054 <z_time_slice+0x58>)
   17ffe:	4916      	ldr	r1, [pc, #88]	; (18058 <z_time_slice+0x5c>)
{
   18000:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
   18002:	680c      	ldr	r4, [r1, #0]
   18004:	6893      	ldr	r3, [r2, #8]
   18006:	42a3      	cmp	r3, r4
   18008:	4614      	mov	r4, r2
   1800a:	d103      	bne.n	18014 <z_time_slice+0x18>
}
   1800c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
   18010:	f7ff bed6 	b.w	17dc0 <z_reset_time_slice>
	pending_current = NULL;
   18014:	2500      	movs	r5, #0
   18016:	600d      	str	r5, [r1, #0]
	if (slice_time && sliceable(_current)) {
   18018:	4910      	ldr	r1, [pc, #64]	; (1805c <z_time_slice+0x60>)
   1801a:	6809      	ldr	r1, [r1, #0]
   1801c:	b1b9      	cbz	r1, 1804e <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   1801e:	89d9      	ldrh	r1, [r3, #14]
   18020:	297f      	cmp	r1, #127	; 0x7f
   18022:	d814      	bhi.n	1804e <z_time_slice+0x52>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   18024:	490e      	ldr	r1, [pc, #56]	; (18060 <z_time_slice+0x64>)
   18026:	f993 500e 	ldrsb.w	r5, [r3, #14]
   1802a:	6809      	ldr	r1, [r1, #0]
   1802c:	428d      	cmp	r5, r1
   1802e:	db0e      	blt.n	1804e <z_time_slice+0x52>
		&& !z_is_idle_thread_object(thread)
   18030:	490c      	ldr	r1, [pc, #48]	; (18064 <z_time_slice+0x68>)
   18032:	428b      	cmp	r3, r1
   18034:	d00b      	beq.n	1804e <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   18036:	6999      	ldr	r1, [r3, #24]
   18038:	b949      	cbnz	r1, 1804e <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
   1803a:	6911      	ldr	r1, [r2, #16]
   1803c:	4281      	cmp	r1, r0
   1803e:	dc03      	bgt.n	18048 <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
   18040:	4618      	mov	r0, r3
   18042:	f7ff ff99 	bl	17f78 <z_move_thread_to_end_of_prio_q>
   18046:	e7e1      	b.n	1800c <z_time_slice+0x10>
			_current_cpu->slice_ticks -= ticks;
   18048:	1a09      	subs	r1, r1, r0
   1804a:	6111      	str	r1, [r2, #16]
}
   1804c:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
   1804e:	2300      	movs	r3, #0
   18050:	6123      	str	r3, [r4, #16]
   18052:	e7fb      	b.n	1804c <z_time_slice+0x50>
   18054:	20001a24 	.word	0x20001a24
   18058:	20001a54 	.word	0x20001a54
   1805c:	20001a5c 	.word	0x20001a5c
   18060:	20001a58 	.word	0x20001a58
   18064:	2000194c 	.word	0x2000194c

00018068 <z_thread_single_suspend>:
{
   18068:	b570      	push	{r4, r5, r6, lr}
   1806a:	4604      	mov	r4, r0
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   1806c:	3018      	adds	r0, #24
   1806e:	f006 fb88 	bl	1e782 <z_abort_timeout>
	__asm__ volatile(
   18072:	f04f 0320 	mov.w	r3, #32
   18076:	f3ef 8611 	mrs	r6, BASEPRI
   1807a:	f383 8811 	msr	BASEPRI, r3
   1807e:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   18082:	7b63      	ldrb	r3, [r4, #13]
   18084:	065a      	lsls	r2, r3, #25
   18086:	d507      	bpl.n	18098 <z_thread_single_suspend+0x30>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   18088:	4621      	mov	r1, r4
   1808a:	480f      	ldr	r0, [pc, #60]	; (180c8 <z_thread_single_suspend+0x60>)
   1808c:	f7ff feee 	bl	17e6c <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   18090:	7b63      	ldrb	r3, [r4, #13]
   18092:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   18096:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   18098:	4d0c      	ldr	r5, [pc, #48]	; (180cc <z_thread_single_suspend+0x64>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   1809a:	7b63      	ldrb	r3, [r4, #13]
   1809c:	68a8      	ldr	r0, [r5, #8]
   1809e:	f043 0310 	orr.w	r3, r3, #16
   180a2:	7363      	strb	r3, [r4, #13]
   180a4:	1b03      	subs	r3, r0, r4
   180a6:	4258      	negs	r0, r3
   180a8:	4158      	adcs	r0, r3
   180aa:	f7ff fef5 	bl	17e98 <update_cache>
	__asm__ volatile(
   180ae:	f386 8811 	msr	BASEPRI, r6
   180b2:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   180b6:	68ab      	ldr	r3, [r5, #8]
   180b8:	42a3      	cmp	r3, r4
   180ba:	d103      	bne.n	180c4 <z_thread_single_suspend+0x5c>
}
   180bc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   180c0:	f006 ba24 	b.w	1e50c <z_reschedule_unlocked>
}
   180c4:	bd70      	pop	{r4, r5, r6, pc}
   180c6:	bf00      	nop
   180c8:	20001a4c 	.word	0x20001a4c
   180cc:	20001a24 	.word	0x20001a24

000180d0 <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
   180d0:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
   180d2:	b570      	push	{r4, r5, r6, lr}
   180d4:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
   180d6:	b103      	cbz	r3, 180da <z_thread_single_abort+0xa>
		thread->fn_abort();
   180d8:	4798      	blx	r3
   180da:	f104 0018 	add.w	r0, r4, #24
   180de:	f006 fb50 	bl	1e782 <z_abort_timeout>
	__asm__ volatile(
   180e2:	f04f 0320 	mov.w	r3, #32
   180e6:	f3ef 8511 	mrs	r5, BASEPRI
   180ea:	f383 8811 	msr	BASEPRI, r3
   180ee:	f3bf 8f6f 	isb	sy
		if (z_is_thread_ready(thread)) {
   180f2:	4620      	mov	r0, r4
   180f4:	f006 f9b8 	bl	1e468 <z_is_thread_ready>
   180f8:	7b63      	ldrb	r3, [r4, #13]
   180fa:	4606      	mov	r6, r0
   180fc:	b1c8      	cbz	r0, 18132 <z_thread_single_abort+0x62>
			if (z_is_thread_queued(thread)) {
   180fe:	0659      	lsls	r1, r3, #25
   18100:	d507      	bpl.n	18112 <z_thread_single_abort+0x42>
				_priq_run_remove(&_kernel.ready_q.runq,
   18102:	4621      	mov	r1, r4
   18104:	4811      	ldr	r0, [pc, #68]	; (1814c <z_thread_single_abort+0x7c>)
   18106:	f7ff feb1 	bl	17e6c <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   1810a:	7b63      	ldrb	r3, [r4, #13]
   1810c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   18110:	7363      	strb	r3, [r4, #13]
			update_cache(thread == _current);
   18112:	4b0f      	ldr	r3, [pc, #60]	; (18150 <z_thread_single_abort+0x80>)
   18114:	6898      	ldr	r0, [r3, #8]
   18116:	1b02      	subs	r2, r0, r4
   18118:	4250      	negs	r0, r2
   1811a:	4150      	adcs	r0, r2
   1811c:	f7ff febc 	bl	17e98 <update_cache>
		thread->base.thread_state |= _THREAD_DEAD;
   18120:	7b63      	ldrb	r3, [r4, #13]
   18122:	f043 0308 	orr.w	r3, r3, #8
   18126:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   18128:	f385 8811 	msr	BASEPRI, r5
   1812c:	f3bf 8f6f 	isb	sy
}
   18130:	bd70      	pop	{r4, r5, r6, pc}
			if (z_is_thread_pending(thread)) {
   18132:	079b      	lsls	r3, r3, #30
   18134:	d5f4      	bpl.n	18120 <z_thread_single_abort+0x50>
				_priq_wait_remove(&pended_on(thread)->waitq,
   18136:	4621      	mov	r1, r4
   18138:	68a0      	ldr	r0, [r4, #8]
   1813a:	f7ff fe97 	bl	17e6c <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1813e:	7b63      	ldrb	r3, [r4, #13]
				thread->base.pended_on = NULL;
   18140:	60a6      	str	r6, [r4, #8]
   18142:	f023 0302 	bic.w	r3, r3, #2
   18146:	7363      	strb	r3, [r4, #13]
   18148:	e7ea      	b.n	18120 <z_thread_single_abort+0x50>
   1814a:	bf00      	nop
   1814c:	20001a4c 	.word	0x20001a4c
   18150:	20001a24 	.word	0x20001a24

00018154 <z_remove_thread_from_ready_q>:
{
   18154:	b538      	push	{r3, r4, r5, lr}
   18156:	4604      	mov	r4, r0
	__asm__ volatile(
   18158:	f04f 0320 	mov.w	r3, #32
   1815c:	f3ef 8511 	mrs	r5, BASEPRI
   18160:	f383 8811 	msr	BASEPRI, r3
   18164:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   18168:	7b43      	ldrb	r3, [r0, #13]
   1816a:	065a      	lsls	r2, r3, #25
   1816c:	d507      	bpl.n	1817e <z_remove_thread_from_ready_q+0x2a>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   1816e:	4601      	mov	r1, r0
   18170:	4809      	ldr	r0, [pc, #36]	; (18198 <z_remove_thread_from_ready_q+0x44>)
   18172:	f7ff fe7b 	bl	17e6c <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   18176:	7b63      	ldrb	r3, [r4, #13]
   18178:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   1817c:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   1817e:	4b07      	ldr	r3, [pc, #28]	; (1819c <z_remove_thread_from_ready_q+0x48>)
   18180:	6898      	ldr	r0, [r3, #8]
   18182:	1b03      	subs	r3, r0, r4
   18184:	4258      	negs	r0, r3
   18186:	4158      	adcs	r0, r3
   18188:	f7ff fe86 	bl	17e98 <update_cache>
	__asm__ volatile(
   1818c:	f385 8811 	msr	BASEPRI, r5
   18190:	f3bf 8f6f 	isb	sy
}
   18194:	bd38      	pop	{r3, r4, r5, pc}
   18196:	bf00      	nop
   18198:	20001a4c 	.word	0x20001a4c
   1819c:	20001a24 	.word	0x20001a24

000181a0 <pend>:
{
   181a0:	b570      	push	{r4, r5, r6, lr}
   181a2:	4604      	mov	r4, r0
   181a4:	460d      	mov	r5, r1
   181a6:	4616      	mov	r6, r2
	z_remove_thread_from_ready_q(thread);
   181a8:	f7ff ffd4 	bl	18154 <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_PENDING;
   181ac:	7b63      	ldrb	r3, [r4, #13]
   181ae:	f043 0302 	orr.w	r3, r3, #2
   181b2:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   181b4:	b17d      	cbz	r5, 181d6 <pend+0x36>
	return list->head == list;
   181b6:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
   181b8:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   181ba:	429d      	cmp	r5, r3
   181bc:	d029      	beq.n	18212 <pend+0x72>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   181be:	b343      	cbz	r3, 18212 <pend+0x72>
	if (thread_1->base.prio < thread_2->base.prio) {
   181c0:	f994 200e 	ldrsb.w	r2, [r4, #14]
   181c4:	f993 100e 	ldrsb.w	r1, [r3, #14]
   181c8:	4291      	cmp	r1, r2
   181ca:	dd1c      	ble.n	18206 <pend+0x66>
	node->prev = successor->prev;
   181cc:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   181ce:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   181d2:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   181d4:	605c      	str	r4, [r3, #4]
	if (timeout != K_FOREVER) {
   181d6:	1c73      	adds	r3, r6, #1
   181d8:	d022      	beq.n	18220 <pend+0x80>
   181da:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
   181de:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   181e2:	f240 30e7 	movw	r0, #999	; 0x3e7
   181e6:	2100      	movs	r1, #0
   181e8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   181ec:	fbc5 0106 	smlal	r0, r1, r5, r6
   181f0:	2300      	movs	r3, #0
   181f2:	f7e7 ff75 	bl	e0 <__aeabi_uldivmod>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   181f6:	490b      	ldr	r1, [pc, #44]	; (18224 <pend+0x84>)
   181f8:	1c42      	adds	r2, r0, #1
   181fa:	f104 0018 	add.w	r0, r4, #24
}
   181fe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   18202:	f000 bb2f 	b.w	18864 <z_add_timeout>
	return (node == list->tail) ? NULL : node->next;
   18206:	6869      	ldr	r1, [r5, #4]
   18208:	428b      	cmp	r3, r1
   1820a:	d002      	beq.n	18212 <pend+0x72>
   1820c:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1820e:	2b00      	cmp	r3, #0
   18210:	d1d8      	bne.n	181c4 <pend+0x24>
	node->prev = list->tail;
   18212:	686b      	ldr	r3, [r5, #4]
   18214:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   18216:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   18218:	6025      	str	r5, [r4, #0]
	list->tail->next = node;
   1821a:	601c      	str	r4, [r3, #0]
	list->tail = node;
   1821c:	606c      	str	r4, [r5, #4]
   1821e:	e7da      	b.n	181d6 <pend+0x36>
}
   18220:	bd70      	pop	{r4, r5, r6, pc}
   18222:	bf00      	nop
   18224:	0001e569 	.word	0x0001e569

00018228 <z_pend_curr_irqlock>:
{
   18228:	b570      	push	{r4, r5, r6, lr}
	pend(_current, wait_q, timeout);
   1822a:	4d0f      	ldr	r5, [pc, #60]	; (18268 <z_pend_curr_irqlock+0x40>)
	pending_current = _current;
   1822c:	4c0f      	ldr	r4, [pc, #60]	; (1826c <z_pend_curr_irqlock+0x44>)
{
   1822e:	4606      	mov	r6, r0
	pend(_current, wait_q, timeout);
   18230:	68a8      	ldr	r0, [r5, #8]
   18232:	f7ff ffb5 	bl	181a0 <pend>
	pending_current = _current;
   18236:	68ab      	ldr	r3, [r5, #8]
   18238:	6023      	str	r3, [r4, #0]
   1823a:	4630      	mov	r0, r6
   1823c:	f7ec f838 	bl	42b0 <arch_swap>
	__asm__ volatile(
   18240:	f04f 0220 	mov.w	r2, #32
   18244:	f3ef 8311 	mrs	r3, BASEPRI
   18248:	f382 8811 	msr	BASEPRI, r2
   1824c:	f3bf 8f6f 	isb	sy
		if (pending_current == _current) {
   18250:	6822      	ldr	r2, [r4, #0]
   18252:	68a9      	ldr	r1, [r5, #8]
   18254:	4291      	cmp	r1, r2
			pending_current = NULL;
   18256:	bf04      	itt	eq
   18258:	2200      	moveq	r2, #0
   1825a:	6022      	streq	r2, [r4, #0]
	__asm__ volatile(
   1825c:	f383 8811 	msr	BASEPRI, r3
   18260:	f3bf 8f6f 	isb	sy
}
   18264:	bd70      	pop	{r4, r5, r6, pc}
   18266:	bf00      	nop
   18268:	20001a24 	.word	0x20001a24
   1826c:	20001a54 	.word	0x20001a54

00018270 <z_pend_curr>:
{
   18270:	b510      	push	{r4, lr}
   18272:	460c      	mov	r4, r1
   18274:	4611      	mov	r1, r2
	pending_current = _current;
   18276:	4a06      	ldr	r2, [pc, #24]	; (18290 <z_pend_curr+0x20>)
   18278:	6890      	ldr	r0, [r2, #8]
   1827a:	4a06      	ldr	r2, [pc, #24]	; (18294 <z_pend_curr+0x24>)
   1827c:	6010      	str	r0, [r2, #0]
	pend(_current, wait_q, timeout);
   1827e:	461a      	mov	r2, r3
   18280:	f7ff ff8e 	bl	181a0 <pend>
   18284:	4620      	mov	r0, r4
}
   18286:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1828a:	f7ec b811 	b.w	42b0 <arch_swap>
   1828e:	bf00      	nop
   18290:	20001a24 	.word	0x20001a24
   18294:	20001a54 	.word	0x20001a54

00018298 <z_tick_sleep.part.19>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static s32_t z_tick_sleep(s32_t ticks)
   18298:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (ticks == 0) {
		k_yield();
		return 0;
	}

	ticks += _TICK_ALIGN;
   1829a:	1c46      	adds	r6, r0, #1
	expected_wakeup_time = ticks + z_tick_get_32();
   1829c:	f006 fab1 	bl	1e802 <z_tick_get_32>
   182a0:	1834      	adds	r4, r6, r0
	__asm__ volatile(
   182a2:	f04f 0320 	mov.w	r3, #32
   182a6:	f3ef 8711 	mrs	r7, BASEPRI
   182aa:	f383 8811 	msr	BASEPRI, r3
   182ae:	f3bf 8f6f 	isb	sy
	 */
	struct k_spinlock local_lock = {};
	k_spinlock_key_t key = k_spin_lock(&local_lock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
   182b2:	4d0d      	ldr	r5, [pc, #52]	; (182e8 <z_tick_sleep.part.19+0x50>)
   182b4:	4b0d      	ldr	r3, [pc, #52]	; (182ec <z_tick_sleep.part.19+0x54>)
   182b6:	68a8      	ldr	r0, [r5, #8]
   182b8:	6018      	str	r0, [r3, #0]
#endif
	z_remove_thread_from_ready_q(_current);
   182ba:	f7ff ff4b 	bl	18154 <z_remove_thread_from_ready_q>
   182be:	68a8      	ldr	r0, [r5, #8]
   182c0:	490b      	ldr	r1, [pc, #44]	; (182f0 <z_tick_sleep.part.19+0x58>)
   182c2:	4632      	mov	r2, r6
   182c4:	3018      	adds	r0, #24
   182c6:	f000 facd 	bl	18864 <z_add_timeout>
	z_add_thread_timeout(_current, ticks);
	z_mark_thread_as_suspended(_current);
   182ca:	68aa      	ldr	r2, [r5, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
   182cc:	7b53      	ldrb	r3, [r2, #13]
   182ce:	f043 0310 	orr.w	r3, r3, #16
   182d2:	7353      	strb	r3, [r2, #13]
   182d4:	4638      	mov	r0, r7
   182d6:	f7eb ffeb 	bl	42b0 <arch_swap>

	(void)z_swap(&local_lock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = expected_wakeup_time - z_tick_get_32();
   182da:	f006 fa92 	bl	1e802 <z_tick_get_32>
   182de:	1a20      	subs	r0, r4, r0
		return ticks;
	}
#endif

	return 0;
}
   182e0:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   182e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   182e6:	bf00      	nop
   182e8:	20001a24 	.word	0x20001a24
   182ec:	20001a54 	.word	0x20001a54
   182f0:	0001e569 	.word	0x0001e569

000182f4 <z_set_prio>:
{
   182f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   182f8:	4604      	mov	r4, r0
   182fa:	f04f 0320 	mov.w	r3, #32
   182fe:	f3ef 8911 	mrs	r9, BASEPRI
   18302:	f383 8811 	msr	BASEPRI, r3
   18306:	f3bf 8f6f 	isb	sy
		need_sched = z_is_thread_ready(thread);
   1830a:	f006 f8ad 	bl	1e468 <z_is_thread_ready>
		if (need_sched) {
   1830e:	b24e      	sxtb	r6, r1
   18310:	4680      	mov	r8, r0
   18312:	b360      	cbz	r0, 1836e <z_set_prio+0x7a>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
   18314:	4d17      	ldr	r5, [pc, #92]	; (18374 <z_set_prio+0x80>)
   18316:	f105 0728 	add.w	r7, r5, #40	; 0x28
   1831a:	4621      	mov	r1, r4
   1831c:	4638      	mov	r0, r7
   1831e:	f7ff fda5 	bl	17e6c <z_priq_dumb_remove>
	return list->head == list;
   18322:	6aab      	ldr	r3, [r5, #40]	; 0x28
				thread->base.prio = prio;
   18324:	73a6      	strb	r6, [r4, #14]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   18326:	42bb      	cmp	r3, r7
   18328:	462a      	mov	r2, r5
   1832a:	d019      	beq.n	18360 <z_set_prio+0x6c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1832c:	b1c3      	cbz	r3, 18360 <z_set_prio+0x6c>
   1832e:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
	if (thread_1->base.prio < thread_2->base.prio) {
   18330:	f993 000e 	ldrsb.w	r0, [r3, #14]
   18334:	42b0      	cmp	r0, r6
   18336:	dd0e      	ble.n	18356 <z_set_prio+0x62>
	node->prev = successor->prev;
   18338:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   1833a:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   1833e:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   18340:	605c      	str	r4, [r3, #4]
			update_cache(1);
   18342:	2001      	movs	r0, #1
   18344:	f7ff fda8 	bl	17e98 <update_cache>
	__asm__ volatile(
   18348:	f389 8811 	msr	BASEPRI, r9
   1834c:	f3bf 8f6f 	isb	sy
}
   18350:	4640      	mov	r0, r8
   18352:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return (node == list->tail) ? NULL : node->next;
   18356:	4299      	cmp	r1, r3
   18358:	d002      	beq.n	18360 <z_set_prio+0x6c>
   1835a:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1835c:	2b00      	cmp	r3, #0
   1835e:	d1e7      	bne.n	18330 <z_set_prio+0x3c>
	node->prev = list->tail;
   18360:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   18362:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   18364:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	node->next = list;
   18366:	6027      	str	r7, [r4, #0]
	list->tail->next = node;
   18368:	601c      	str	r4, [r3, #0]
	list->tail = node;
   1836a:	62d4      	str	r4, [r2, #44]	; 0x2c
   1836c:	e7e9      	b.n	18342 <z_set_prio+0x4e>
			thread->base.prio = prio;
   1836e:	73a6      	strb	r6, [r4, #14]
   18370:	e7ea      	b.n	18348 <z_set_prio+0x54>
   18372:	bf00      	nop
   18374:	20001a24 	.word	0x20001a24

00018378 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
   18378:	4b04      	ldr	r3, [pc, #16]	; (1838c <z_sched_init+0x14>)
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   1837a:	2100      	movs	r1, #0
   1837c:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
   18380:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
   18384:	4608      	mov	r0, r1
   18386:	f7ff bd31 	b.w	17dec <k_sched_time_slice_set>
   1838a:	bf00      	nop
   1838c:	20001a24 	.word	0x20001a24

00018390 <z_impl_k_yield>:
{
   18390:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!z_is_idle_thread_object(_current)) {
   18392:	4c23      	ldr	r4, [pc, #140]	; (18420 <z_impl_k_yield+0x90>)
   18394:	4b23      	ldr	r3, [pc, #140]	; (18424 <z_impl_k_yield+0x94>)
   18396:	68a2      	ldr	r2, [r4, #8]
   18398:	429a      	cmp	r2, r3
   1839a:	d029      	beq.n	183f0 <z_impl_k_yield+0x60>
	__asm__ volatile(
   1839c:	f04f 0320 	mov.w	r3, #32
   183a0:	f3ef 8611 	mrs	r6, BASEPRI
   183a4:	f383 8811 	msr	BASEPRI, r3
   183a8:	f3bf 8f6f 	isb	sy
				_priq_run_remove(&_kernel.ready_q.runq,
   183ac:	f104 0528 	add.w	r5, r4, #40	; 0x28
   183b0:	68a1      	ldr	r1, [r4, #8]
   183b2:	4628      	mov	r0, r5
   183b4:	f7ff fd5a 	bl	17e6c <z_priq_dumb_remove>
	return list->head == list;
   183b8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
			_priq_run_add(&_kernel.ready_q.runq, _current);
   183ba:	68a3      	ldr	r3, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   183bc:	42aa      	cmp	r2, r5
   183be:	d028      	beq.n	18412 <z_impl_k_yield+0x82>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   183c0:	b33a      	cbz	r2, 18412 <z_impl_k_yield+0x82>
   183c2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
	if (thread_1->base.prio < thread_2->base.prio) {
   183c4:	f993 100e 	ldrsb.w	r1, [r3, #14]
   183c8:	f992 700e 	ldrsb.w	r7, [r2, #14]
   183cc:	428f      	cmp	r7, r1
   183ce:	dd1b      	ble.n	18408 <z_impl_k_yield+0x78>
	node->prev = successor->prev;
   183d0:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
   183d2:	e9c3 2100 	strd	r2, r1, [r3]
	successor->prev->next = node;
   183d6:	600b      	str	r3, [r1, #0]
	successor->prev = node;
   183d8:	6053      	str	r3, [r2, #4]
	thread->base.thread_state |= states;
   183da:	7b5a      	ldrb	r2, [r3, #13]
   183dc:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   183e0:	735a      	strb	r2, [r3, #13]
			update_cache(1);
   183e2:	2001      	movs	r0, #1
   183e4:	f7ff fd58 	bl	17e98 <update_cache>
	__asm__ volatile(
   183e8:	f386 8811 	msr	BASEPRI, r6
   183ec:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   183f0:	f04f 0320 	mov.w	r3, #32
   183f4:	f3ef 8011 	mrs	r0, BASEPRI
   183f8:	f383 8811 	msr	BASEPRI, r3
   183fc:	f3bf 8f6f 	isb	sy
}
   18400:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   18404:	f7eb bf54 	b.w	42b0 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   18408:	4282      	cmp	r2, r0
   1840a:	d002      	beq.n	18412 <z_impl_k_yield+0x82>
   1840c:	6812      	ldr	r2, [r2, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1840e:	2a00      	cmp	r2, #0
   18410:	d1da      	bne.n	183c8 <z_impl_k_yield+0x38>
	node->prev = list->tail;
   18412:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   18414:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
   18416:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
	node->next = list;
   18418:	601d      	str	r5, [r3, #0]
	list->tail->next = node;
   1841a:	6013      	str	r3, [r2, #0]
	list->tail = node;
   1841c:	62e3      	str	r3, [r4, #44]	; 0x2c
   1841e:	e7dc      	b.n	183da <z_impl_k_yield+0x4a>
   18420:	20001a24 	.word	0x20001a24
   18424:	2000194c 	.word	0x2000194c

00018428 <z_impl_k_sleep>:

s32_t z_impl_k_sleep(int ms)
{
   18428:	b538      	push	{r3, r4, r5, lr}
	s32_t ticks;

	__ASSERT(!arch_is_in_isr(), "");

	if (ms == K_FOREVER) {
   1842a:	1c43      	adds	r3, r0, #1
{
   1842c:	4604      	mov	r4, r0
	if (ms == K_FOREVER) {
   1842e:	d105      	bne.n	1843c <z_impl_k_sleep+0x14>
		k_thread_suspend(_current);
   18430:	4b10      	ldr	r3, [pc, #64]	; (18474 <z_impl_k_sleep+0x4c>)
   18432:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   18434:	f000 f8fa 	bl	1862c <z_impl_k_thread_suspend>
	}

	ticks = k_ms_to_ticks_ceil32(ms);
	ticks = z_tick_sleep(ticks);
	return k_ticks_to_ms_floor64(ticks);
}
   18438:	4620      	mov	r0, r4
   1843a:	bd38      	pop	{r3, r4, r5, pc}
   1843c:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   18440:	f240 30e7 	movw	r0, #999	; 0x3e7
   18444:	2100      	movs	r1, #0
   18446:	fbe5 0104 	umlal	r0, r1, r5, r4
   1844a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1844e:	2300      	movs	r3, #0
   18450:	f7e7 fe46 	bl	e0 <__aeabi_uldivmod>
	if (ticks == 0) {
   18454:	4604      	mov	r4, r0
   18456:	b948      	cbnz	r0, 1846c <z_impl_k_sleep+0x44>
	z_impl_k_yield();
   18458:	f7ff ff9a 	bl	18390 <z_impl_k_yield>
			return (t * to_hz + off) / from_hz;
   1845c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   18460:	fb84 0100 	smull	r0, r1, r4, r0
   18464:	0bc4      	lsrs	r4, r0, #15
   18466:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
	return k_ticks_to_ms_floor64(ticks);
   1846a:	e7e5      	b.n	18438 <z_impl_k_sleep+0x10>
   1846c:	f7ff ff14 	bl	18298 <z_tick_sleep.part.19>
   18470:	4604      	mov	r4, r0
   18472:	e7f3      	b.n	1845c <z_impl_k_sleep+0x34>
   18474:	20001a24 	.word	0x20001a24

00018478 <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
   18478:	4b01      	ldr	r3, [pc, #4]	; (18480 <z_impl_k_current_get+0x8>)
   1847a:	6898      	ldr	r0, [r3, #8]
   1847c:	4770      	bx	lr
   1847e:	bf00      	nop
   18480:	20001a24 	.word	0x20001a24

00018484 <z_impl_k_sem_give>:
		handle_poll_events(sem);
	}
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   18484:	b570      	push	{r4, r5, r6, lr}
   18486:	4604      	mov	r4, r0
   18488:	f04f 0320 	mov.w	r3, #32
   1848c:	f3ef 8611 	mrs	r6, BASEPRI
   18490:	f383 8811 	msr	BASEPRI, r3
   18494:	f3bf 8f6f 	isb	sy
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
   18498:	f006 f897 	bl	1e5ca <z_unpend_first_thread>
	if (thread != NULL) {
   1849c:	4605      	mov	r5, r0
   1849e:	b170      	cbz	r0, 184be <z_impl_k_sem_give+0x3a>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   184a0:	7b43      	ldrb	r3, [r0, #13]
   184a2:	06db      	lsls	r3, r3, #27
   184a4:	d103      	bne.n	184ae <z_impl_k_sem_give+0x2a>
	if (z_is_thread_ready(thread)) {
   184a6:	6983      	ldr	r3, [r0, #24]
   184a8:	b90b      	cbnz	r3, 184ae <z_impl_k_sem_give+0x2a>
		z_add_thread_to_ready_q(thread);
   184aa:	f7ff fd2f 	bl	17f0c <z_add_thread_to_ready_q>
   184ae:	2300      	movs	r3, #0
   184b0:	66ab      	str	r3, [r5, #104]	; 0x68
	k_spinlock_key_t key = k_spin_lock(&lock);

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);
	do_sem_give(sem);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
   184b2:	4631      	mov	r1, r6
   184b4:	4808      	ldr	r0, [pc, #32]	; (184d8 <z_impl_k_sem_give+0x54>)
}
   184b6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&lock, key);
   184ba:	f006 b810 	b.w	1e4de <z_reschedule>
	sem->count += (sem->count != sem->limit) ? 1U : 0U;
   184be:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   184c2:	429a      	cmp	r2, r3
   184c4:	bf18      	it	ne
   184c6:	3301      	addne	r3, #1
   184c8:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   184ca:	2102      	movs	r1, #2
   184cc:	f104 0010 	add.w	r0, r4, #16
   184d0:	f006 face 	bl	1ea70 <z_handle_obj_poll_events>
   184d4:	e7ed      	b.n	184b2 <z_impl_k_sem_give+0x2e>
   184d6:	bf00      	nop
   184d8:	20001df0 	.word	0x20001df0

000184dc <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, s32_t timeout)
{
   184dc:	b410      	push	{r4}
   184de:	4602      	mov	r2, r0
   184e0:	460b      	mov	r3, r1
   184e2:	f04f 0020 	mov.w	r0, #32
   184e6:	f3ef 8111 	mrs	r1, BASEPRI
   184ea:	f380 8811 	msr	BASEPRI, r0
   184ee:	f3bf 8f6f 	isb	sy
	__ASSERT(((arch_is_in_isr() == false) || (timeout == K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
   184f2:	6894      	ldr	r4, [r2, #8]
   184f4:	b144      	cbz	r4, 18508 <z_impl_k_sem_take+0x2c>
		sem->count--;
   184f6:	3c01      	subs	r4, #1
   184f8:	6094      	str	r4, [r2, #8]
	__asm__ volatile(
   184fa:	f381 8811 	msr	BASEPRI, r1
   184fe:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
		return 0;
   18502:	2000      	movs	r0, #0

	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);

	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
	return ret;
}
   18504:	bc10      	pop	{r4}
   18506:	4770      	bx	lr
	if (timeout == K_NO_WAIT) {
   18508:	b933      	cbnz	r3, 18518 <z_impl_k_sem_take+0x3c>
   1850a:	f381 8811 	msr	BASEPRI, r1
   1850e:	f3bf 8f6f 	isb	sy
		return -EBUSY;
   18512:	f06f 000f 	mvn.w	r0, #15
   18516:	e7f5      	b.n	18504 <z_impl_k_sem_take+0x28>
	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   18518:	4801      	ldr	r0, [pc, #4]	; (18520 <z_impl_k_sem_take+0x44>)
}
   1851a:	bc10      	pop	{r4}
	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   1851c:	f7ff bea8 	b.w	18270 <z_pend_curr>
   18520:	20001df0 	.word	0x20001df0

00018524 <k_sys_work_q_init>:
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
   18524:	b510      	push	{r4, lr}
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
   18526:	4c08      	ldr	r4, [pc, #32]	; (18548 <k_sys_work_q_init+0x24>)
   18528:	4908      	ldr	r1, [pc, #32]	; (1854c <k_sys_work_q_init+0x28>)
   1852a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1852e:	f44f 6200 	mov.w	r2, #2048	; 0x800
   18532:	4620      	mov	r0, r4
   18534:	f000 f8f4 	bl	18720 <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
   18538:	4905      	ldr	r1, [pc, #20]	; (18550 <k_sys_work_q_init+0x2c>)
   1853a:	f104 0010 	add.w	r0, r4, #16
   1853e:	f006 f890 	bl	1e662 <z_impl_k_thread_name_set>
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
   18542:	2000      	movs	r0, #0
   18544:	bd10      	pop	{r4, pc}
   18546:	bf00      	nop
   18548:	20001a60 	.word	0x20001a60
   1854c:	200040b0 	.word	0x200040b0
   18550:	000226de 	.word	0x000226de

00018554 <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
   18554:	b510      	push	{r4, lr}
	__asm__ volatile(
   18556:	f04f 0220 	mov.w	r2, #32
   1855a:	f3ef 8411 	mrs	r4, BASEPRI
   1855e:	f382 8811 	msr	BASEPRI, r2
   18562:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock); /* protect kernel queues */

	if (z_has_thread_started(thread)) {
   18566:	7b42      	ldrb	r2, [r0, #13]
   18568:	0751      	lsls	r1, r2, #29
   1856a:	d404      	bmi.n	18576 <z_impl_k_thread_start+0x22>
	__asm__ volatile(
   1856c:	f384 8811 	msr	BASEPRI, r4
   18570:	f3bf 8f6f 	isb	sy
	}

	z_mark_thread_as_started(thread);
	z_ready_thread(thread);
	z_reschedule(&lock, key);
}
   18574:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   18576:	f022 0104 	bic.w	r1, r2, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1857a:	f012 0f1b 	tst.w	r2, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
   1857e:	7341      	strb	r1, [r0, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   18580:	d103      	bne.n	1858a <z_impl_k_thread_start+0x36>
	if (z_is_thread_ready(thread)) {
   18582:	6983      	ldr	r3, [r0, #24]
   18584:	b90b      	cbnz	r3, 1858a <z_impl_k_thread_start+0x36>
		z_add_thread_to_ready_q(thread);
   18586:	f7ff fcc1 	bl	17f0c <z_add_thread_to_ready_q>
	z_reschedule(&lock, key);
   1858a:	4621      	mov	r1, r4
   1858c:	4802      	ldr	r0, [pc, #8]	; (18598 <z_impl_k_thread_start+0x44>)
}
   1858e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&lock, key);
   18592:	f005 bfa4 	b.w	1e4de <z_reschedule>
   18596:	bf00      	nop
   18598:	20001df0 	.word	0x20001df0

0001859c <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
   1859c:	b530      	push	{r4, r5, lr}
   1859e:	b087      	sub	sp, #28
   185a0:	4604      	mov	r4, r0
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   185a2:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   185a4:	9504      	str	r5, [sp, #16]
   185a6:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   185a8:	9503      	str	r5, [sp, #12]
   185aa:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   185ac:	9502      	str	r5, [sp, #8]
   185ae:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   185b0:	9501      	str	r5, [sp, #4]
   185b2:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   185b4:	9500      	str	r5, [sp, #0]
   185b6:	f7eb ff27 	bl	4408 <arch_new_thread>
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
   185ba:	4b03      	ldr	r3, [pc, #12]	; (185c8 <z_setup_new_thread+0x2c>)
   185bc:	689b      	ldr	r3, [r3, #8]
   185be:	b103      	cbz	r3, 185c2 <z_setup_new_thread+0x26>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
   185c0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
   185c2:	6623      	str	r3, [r4, #96]	; 0x60
	sys_trace_thread_create(new_thread);
}
   185c4:	b007      	add	sp, #28
   185c6:	bd30      	pop	{r4, r5, pc}
   185c8:	20001a24 	.word	0x20001a24

000185cc <z_impl_k_thread_create>:
k_tid_t z_impl_k_thread_create(struct k_thread *new_thread,
			      k_thread_stack_t *stack,
			      size_t stack_size, k_thread_entry_t entry,
			      void *p1, void *p2, void *p3,
			      int prio, u32_t options, s32_t delay)
{
   185cc:	b570      	push	{r4, r5, r6, lr}
   185ce:	b086      	sub	sp, #24
	__ASSERT((options & K_USER) == 0,
		 "Platform is capable of user mode, and test thread created with K_USER option,"
		 " but neither CONFIG_TEST_USERSPACE nor CONFIG_USERSPACE is set\n");
#endif

	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   185d0:	2600      	movs	r6, #0
   185d2:	9605      	str	r6, [sp, #20]
   185d4:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   185d6:	9604      	str	r6, [sp, #16]
   185d8:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   185da:	9603      	str	r6, [sp, #12]
   185dc:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   185de:	9602      	str	r6, [sp, #8]
   185e0:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
{
   185e2:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   185e4:	9601      	str	r6, [sp, #4]
   185e6:	9e0a      	ldr	r6, [sp, #40]	; 0x28
   185e8:	9600      	str	r6, [sp, #0]
{
   185ea:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   185ec:	f7ff ffd6 	bl	1859c <z_setup_new_thread>
			  prio, options, NULL);

	if (delay != K_FOREVER) {
   185f0:	1c6b      	adds	r3, r5, #1
   185f2:	d003      	beq.n	185fc <z_impl_k_thread_create+0x30>
	if (delay == 0) {
   185f4:	b92d      	cbnz	r5, 18602 <z_impl_k_thread_create+0x36>
	z_impl_k_thread_start(thread);
   185f6:	4620      	mov	r0, r4
   185f8:	f7ff ffac 	bl	18554 <z_impl_k_thread_start>
		schedule_new_thread(new_thread, delay);
	}

	return new_thread;
}
   185fc:	4620      	mov	r0, r4
   185fe:	b006      	add	sp, #24
   18600:	bd70      	pop	{r4, r5, r6, pc}
			return (u32_t)((t * to_hz + off) / from_hz);
   18602:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   18606:	f240 30e7 	movw	r0, #999	; 0x3e7
   1860a:	2100      	movs	r1, #0
   1860c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   18610:	2300      	movs	r3, #0
   18612:	fbe6 0105 	umlal	r0, r1, r6, r5
   18616:	f7e7 fd63 	bl	e0 <__aeabi_uldivmod>
   1861a:	4903      	ldr	r1, [pc, #12]	; (18628 <z_impl_k_thread_create+0x5c>)
   1861c:	1c42      	adds	r2, r0, #1
   1861e:	f104 0018 	add.w	r0, r4, #24
   18622:	f000 f91f 	bl	18864 <z_add_timeout>
   18626:	e7e9      	b.n	185fc <z_impl_k_thread_create+0x30>
   18628:	0001e569 	.word	0x0001e569

0001862c <z_impl_k_thread_suspend>:
#endif /* CONFIG_MULTITHREADING */

extern void z_thread_single_suspend(struct k_thread *thread);

void z_impl_k_thread_suspend(struct k_thread *thread)
{
   1862c:	b538      	push	{r3, r4, r5, lr}
   1862e:	4605      	mov	r5, r0
	__asm__ volatile(
   18630:	f04f 0320 	mov.w	r3, #32
   18634:	f3ef 8411 	mrs	r4, BASEPRI
   18638:	f383 8811 	msr	BASEPRI, r3
   1863c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);

	z_thread_single_suspend(thread);
   18640:	f7ff fd12 	bl	18068 <z_thread_single_suspend>

	if (thread == _current) {
   18644:	4b07      	ldr	r3, [pc, #28]	; (18664 <z_impl_k_thread_suspend+0x38>)
   18646:	689b      	ldr	r3, [r3, #8]
   18648:	42ab      	cmp	r3, r5
   1864a:	d105      	bne.n	18658 <z_impl_k_thread_suspend+0x2c>
		z_reschedule(&lock, key);
   1864c:	4621      	mov	r1, r4
   1864e:	4806      	ldr	r0, [pc, #24]	; (18668 <z_impl_k_thread_suspend+0x3c>)
	} else {
		k_spin_unlock(&lock, key);
	}
}
   18650:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&lock, key);
   18654:	f005 bf43 	b.w	1e4de <z_reschedule>
	__asm__ volatile(
   18658:	f384 8811 	msr	BASEPRI, r4
   1865c:	f3bf 8f6f 	isb	sy
}
   18660:	bd38      	pop	{r3, r4, r5, pc}
   18662:	bf00      	nop
   18664:	20001a24 	.word	0x20001a24
   18668:	20001df0 	.word	0x20001df0

0001866c <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
   1866c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   18670:	4e28      	ldr	r6, [pc, #160]	; (18714 <z_init_static_threads+0xa8>)
   18672:	4d29      	ldr	r5, [pc, #164]	; (18718 <z_init_static_threads+0xac>)
{
   18674:	b087      	sub	sp, #28
   18676:	46b0      	mov	r8, r6
	_FOREACH_STATIC_THREAD(thread_data) {
   18678:	42b5      	cmp	r5, r6
   1867a:	f105 0430 	add.w	r4, r5, #48	; 0x30
   1867e:	d310      	bcc.n	186a2 <z_init_static_threads+0x36>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
   18680:	f7ff fbe0 	bl	17e44 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   18684:	4c24      	ldr	r4, [pc, #144]	; (18718 <z_init_static_threads+0xac>)
   18686:	f8df a094 	ldr.w	sl, [pc, #148]	; 1871c <z_init_static_threads+0xb0>
   1868a:	f44f 4900 	mov.w	r9, #32768	; 0x8000
   1868e:	f240 36e7 	movw	r6, #999	; 0x3e7
   18692:	2700      	movs	r7, #0
   18694:	4544      	cmp	r4, r8
   18696:	d321      	bcc.n	186dc <z_init_static_threads+0x70>
			schedule_new_thread(thread_data->init_thread,
					    thread_data->init_delay);
		}
	}
	k_sched_unlock();
}
   18698:	b007      	add	sp, #28
   1869a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	k_sched_unlock();
   1869e:	f7ff bc19 	b.w	17ed4 <k_sched_unlock>
		z_setup_new_thread(
   186a2:	f854 3c04 	ldr.w	r3, [r4, #-4]
   186a6:	9305      	str	r3, [sp, #20]
   186a8:	f854 3c10 	ldr.w	r3, [r4, #-16]
   186ac:	9304      	str	r3, [sp, #16]
   186ae:	f854 3c14 	ldr.w	r3, [r4, #-20]
   186b2:	9303      	str	r3, [sp, #12]
   186b4:	f854 3c18 	ldr.w	r3, [r4, #-24]
   186b8:	9302      	str	r3, [sp, #8]
   186ba:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   186be:	9301      	str	r3, [sp, #4]
   186c0:	f854 3c20 	ldr.w	r3, [r4, #-32]
   186c4:	9300      	str	r3, [sp, #0]
   186c6:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   186ca:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   186ce:	f7ff ff65 	bl	1859c <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   186d2:	f854 3c30 	ldr.w	r3, [r4, #-48]
   186d6:	64dd      	str	r5, [r3, #76]	; 0x4c
   186d8:	4625      	mov	r5, r4
   186da:	e7cd      	b.n	18678 <z_init_static_threads+0xc>
		if (thread_data->init_delay != K_FOREVER) {
   186dc:	6a61      	ldr	r1, [r4, #36]	; 0x24
   186de:	1c4b      	adds	r3, r1, #1
   186e0:	d004      	beq.n	186ec <z_init_static_threads+0x80>
			schedule_new_thread(thread_data->init_thread,
   186e2:	6825      	ldr	r5, [r4, #0]
	if (delay == 0) {
   186e4:	b921      	cbnz	r1, 186f0 <z_init_static_threads+0x84>
   186e6:	4628      	mov	r0, r5
   186e8:	f7ff ff34 	bl	18554 <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   186ec:	3430      	adds	r4, #48	; 0x30
   186ee:	e7d1      	b.n	18694 <z_init_static_threads+0x28>
   186f0:	46b3      	mov	fp, r6
   186f2:	46bc      	mov	ip, r7
   186f4:	fbe9 bc01 	umlal	fp, ip, r9, r1
   186f8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   186fc:	2300      	movs	r3, #0
   186fe:	4658      	mov	r0, fp
   18700:	4661      	mov	r1, ip
   18702:	f7e7 fced 	bl	e0 <__aeabi_uldivmod>
   18706:	4651      	mov	r1, sl
   18708:	1c42      	adds	r2, r0, #1
   1870a:	f105 0018 	add.w	r0, r5, #24
   1870e:	f000 f8a9 	bl	18864 <z_add_timeout>
   18712:	e7eb      	b.n	186ec <z_init_static_threads+0x80>
   18714:	20005bc8 	.word	0x20005bc8
   18718:	20005bc8 	.word	0x20005bc8
   1871c:	0001e569 	.word	0x0001e569

00018720 <k_work_q_start>:

extern void z_work_q_main(void *work_q_ptr, void *p2, void *p3);

void k_work_q_start(struct k_work_q *work_q, k_thread_stack_t *stack,
		    size_t stack_size, int prio)
{
   18720:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   18724:	4605      	mov	r5, r0
   18726:	b086      	sub	sp, #24
   18728:	460e      	mov	r6, r1
   1872a:	4617      	mov	r7, r2
   1872c:	4698      	mov	r8, r3
	z_impl_k_queue_init(queue);
   1872e:	f005 fe05 	bl	1e33c <z_impl_k_queue_init>
	k_queue_init(&work_q->queue);
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
   18732:	f105 0410 	add.w	r4, r5, #16
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   18736:	2000      	movs	r0, #0
   18738:	e9cd 0004 	strd	r0, r0, [sp, #16]
   1873c:	e9cd 0802 	strd	r0, r8, [sp, #8]
   18740:	e9cd 5000 	strd	r5, r0, [sp]
   18744:	4b06      	ldr	r3, [pc, #24]	; (18760 <k_work_q_start+0x40>)
   18746:	463a      	mov	r2, r7
   18748:	4631      	mov	r1, r6
   1874a:	4620      	mov	r0, r4
   1874c:	f7ff ff3e 	bl	185cc <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   18750:	4904      	ldr	r1, [pc, #16]	; (18764 <k_work_q_start+0x44>)
   18752:	4620      	mov	r0, r4
			work_q, NULL, NULL, prio, 0, K_NO_WAIT);

	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}
   18754:	b006      	add	sp, #24
   18756:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1875a:	f005 bf82 	b.w	1e662 <z_impl_k_thread_name_set>
   1875e:	bf00      	nop
   18760:	000193bd 	.word	0x000193bd
   18764:	000226e7 	.word	0x000226e7

00018768 <k_delayed_work_submit_to_queue>:
}

int k_delayed_work_submit_to_queue(struct k_work_q *work_q,
				   struct k_delayed_work *work,
				   s32_t delay)
{
   18768:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1876c:	4606      	mov	r6, r0
   1876e:	460d      	mov	r5, r1
   18770:	4617      	mov	r7, r2
	__asm__ volatile(
   18772:	f04f 0320 	mov.w	r3, #32
   18776:	f3ef 8811 	mrs	r8, BASEPRI
   1877a:	f383 8811 	msr	BASEPRI, r3
   1877e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int err = 0;

	/* Work cannot be active in multiple queues */
	if (work->work_q != NULL && work->work_q != work_q) {
   18782:	69cc      	ldr	r4, [r1, #28]
   18784:	b15c      	cbz	r4, 1879e <k_delayed_work_submit_to_queue+0x36>
   18786:	4284      	cmp	r4, r0
   18788:	d12c      	bne.n	187e4 <k_delayed_work_submit_to_queue+0x7c>
		goto done;
	}

	/* Cancel if work has been submitted */
	if (work->work_q == work_q) {
		err = work_cancel(work);
   1878a:	4628      	mov	r0, r5
   1878c:	f005 ff9a 	bl	1e6c4 <work_cancel>
		if (err < 0) {
   18790:	1e04      	subs	r4, r0, #0
   18792:	da06      	bge.n	187a2 <k_delayed_work_submit_to_queue+0x3a>
	__asm__ volatile(
   18794:	f388 8811 	msr	BASEPRI, r8
   18798:	f3bf 8f6f 	isb	sy
	z_add_timeout(&work->timeout, work_timeout,
		     _TICK_ALIGN + k_ms_to_ticks_ceil32(delay));

done:
	k_spin_unlock(&lock, key);
	return err;
   1879c:	e00c      	b.n	187b8 <k_delayed_work_submit_to_queue+0x50>
	if (work->work_q == work_q) {
   1879e:	2800      	cmp	r0, #0
   187a0:	d0f3      	beq.n	1878a <k_delayed_work_submit_to_queue+0x22>
	work->work_q = work_q;
   187a2:	61ee      	str	r6, [r5, #28]
	if (delay == 0) {
   187a4:	b95f      	cbnz	r7, 187be <k_delayed_work_submit_to_queue+0x56>
   187a6:	f388 8811 	msr	BASEPRI, r8
   187aa:	f3bf 8f6f 	isb	sy
		k_work_submit_to_queue(work_q, &work->work);
   187ae:	4629      	mov	r1, r5
   187b0:	4630      	mov	r0, r6
   187b2:	f005 ff6a 	bl	1e68a <k_work_submit_to_queue>
		return 0;
   187b6:	463c      	mov	r4, r7
}
   187b8:	4620      	mov	r0, r4
   187ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   187be:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   187c2:	f240 30e7 	movw	r0, #999	; 0x3e7
   187c6:	2100      	movs	r1, #0
   187c8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   187cc:	2300      	movs	r3, #0
   187ce:	fbe6 0107 	umlal	r0, r1, r6, r7
   187d2:	f7e7 fc85 	bl	e0 <__aeabi_uldivmod>
	z_add_timeout(&work->timeout, work_timeout,
   187d6:	4905      	ldr	r1, [pc, #20]	; (187ec <k_delayed_work_submit_to_queue+0x84>)
   187d8:	1c42      	adds	r2, r0, #1
   187da:	f105 000c 	add.w	r0, r5, #12
   187de:	f000 f841 	bl	18864 <z_add_timeout>
   187e2:	e7d7      	b.n	18794 <k_delayed_work_submit_to_queue+0x2c>
		err = -EADDRINUSE;
   187e4:	f06f 042f 	mvn.w	r4, #47	; 0x2f
   187e8:	e7d4      	b.n	18794 <k_delayed_work_submit_to_queue+0x2c>
   187ea:	bf00      	nop
   187ec:	0001e6bb 	.word	0x0001e6bb

000187f0 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
   187f0:	4b03      	ldr	r3, [pc, #12]	; (18800 <elapsed+0x10>)
   187f2:	681b      	ldr	r3, [r3, #0]
   187f4:	b90b      	cbnz	r3, 187fa <elapsed+0xa>
   187f6:	f7eb bd19 	b.w	422c <z_clock_elapsed>
}
   187fa:	2000      	movs	r0, #0
   187fc:	4770      	bx	lr
   187fe:	bf00      	nop
   18800:	20001adc 	.word	0x20001adc

00018804 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   18804:	6803      	ldr	r3, [r0, #0]
   18806:	b140      	cbz	r0, 1881a <remove_timeout+0x16>
   18808:	4a07      	ldr	r2, [pc, #28]	; (18828 <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
   1880a:	6852      	ldr	r2, [r2, #4]
   1880c:	4290      	cmp	r0, r2
   1880e:	d004      	beq.n	1881a <remove_timeout+0x16>
	if (next(t) != NULL) {
   18810:	b11b      	cbz	r3, 1881a <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
   18812:	689a      	ldr	r2, [r3, #8]
   18814:	6881      	ldr	r1, [r0, #8]
   18816:	440a      	add	r2, r1
   18818:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
   1881a:	6842      	ldr	r2, [r0, #4]
   1881c:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   1881e:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   18820:	2300      	movs	r3, #0
	node->prev = NULL;
   18822:	e9c0 3300 	strd	r3, r3, [r0]
}
   18826:	4770      	bx	lr
   18828:	20005a14 	.word	0x20005a14

0001882c <next_timeout>:
	return list->head == list;
   1882c:	4b0b      	ldr	r3, [pc, #44]	; (1885c <next_timeout+0x30>)

static s32_t next_timeout(void)
{
   1882e:	b510      	push	{r4, lr}
   18830:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   18832:	429c      	cmp	r4, r3
   18834:	bf08      	it	eq
   18836:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
   18838:	f7ff ffda 	bl	187f0 <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   1883c:	b154      	cbz	r4, 18854 <next_timeout+0x28>
   1883e:	68a3      	ldr	r3, [r4, #8]
   18840:	1a18      	subs	r0, r3, r0
   18842:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   18846:	4b06      	ldr	r3, [pc, #24]	; (18860 <next_timeout+0x34>)
   18848:	691b      	ldr	r3, [r3, #16]
   1884a:	b113      	cbz	r3, 18852 <next_timeout+0x26>
   1884c:	4298      	cmp	r0, r3
   1884e:	bfa8      	it	ge
   18850:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   18852:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   18854:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   18858:	e7f5      	b.n	18846 <next_timeout+0x1a>
   1885a:	bf00      	nop
   1885c:	20005a14 	.word	0x20005a14
   18860:	20001a24 	.word	0x20001a24

00018864 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
   18864:	b570      	push	{r4, r5, r6, lr}
   18866:	4604      	mov	r4, r0
   18868:	4616      	mov	r6, r2
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   1886a:	60c1      	str	r1, [r0, #12]
	__asm__ volatile(
   1886c:	f04f 0320 	mov.w	r3, #32
   18870:	f3ef 8511 	mrs	r5, BASEPRI
   18874:	f383 8811 	msr	BASEPRI, r3
   18878:	f3bf 8f6f 	isb	sy
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
   1887c:	f7ff ffb8 	bl	187f0 <elapsed>
	return list->head == list;
   18880:	4b18      	ldr	r3, [pc, #96]	; (188e4 <z_add_timeout+0x80>)
   18882:	681a      	ldr	r2, [r3, #0]
   18884:	2e01      	cmp	r6, #1
   18886:	bfac      	ite	ge
   18888:	1980      	addge	r0, r0, r6
   1888a:	3001      	addlt	r0, #1
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1888c:	429a      	cmp	r2, r3
   1888e:	60a0      	str	r0, [r4, #8]
   18890:	d001      	beq.n	18896 <z_add_timeout+0x32>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   18892:	685e      	ldr	r6, [r3, #4]
		for (t = first(); t != NULL; t = next(t)) {
   18894:	b932      	cbnz	r2, 188a4 <z_add_timeout+0x40>
	node->prev = list->tail;
   18896:	685a      	ldr	r2, [r3, #4]
   18898:	6062      	str	r2, [r4, #4]
	list->tail->next = node;
   1889a:	685a      	ldr	r2, [r3, #4]
	node->next = list;
   1889c:	6023      	str	r3, [r4, #0]
	list->tail->next = node;
   1889e:	6014      	str	r4, [r2, #0]
	list->tail = node;
   188a0:	605c      	str	r4, [r3, #4]
   188a2:	e00a      	b.n	188ba <z_add_timeout+0x56>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
   188a4:	6890      	ldr	r0, [r2, #8]
   188a6:	68a1      	ldr	r1, [r4, #8]
   188a8:	4288      	cmp	r0, r1
   188aa:	dd15      	ble.n	188d8 <z_add_timeout+0x74>
				t->dticks -= to->dticks;
   188ac:	1a41      	subs	r1, r0, r1
   188ae:	6091      	str	r1, [r2, #8]
	node->prev = successor->prev;
   188b0:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
   188b2:	e9c4 2100 	strd	r2, r1, [r4]
	successor->prev->next = node;
   188b6:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   188b8:	6054      	str	r4, [r2, #4]
	return list->head == list;
   188ba:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   188bc:	429a      	cmp	r2, r3
   188be:	d006      	beq.n	188ce <z_add_timeout+0x6a>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   188c0:	4294      	cmp	r4, r2
   188c2:	d104      	bne.n	188ce <z_add_timeout+0x6a>
			z_clock_set_timeout(next_timeout(), false);
   188c4:	f7ff ffb2 	bl	1882c <next_timeout>
   188c8:	2100      	movs	r1, #0
   188ca:	f7eb fc59 	bl	4180 <z_clock_set_timeout>
	__asm__ volatile(
   188ce:	f385 8811 	msr	BASEPRI, r5
   188d2:	f3bf 8f6f 	isb	sy
		}
	}
}
   188d6:	bd70      	pop	{r4, r5, r6, pc}
			to->dticks -= t->dticks;
   188d8:	1a09      	subs	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
   188da:	42b2      	cmp	r2, r6
   188dc:	60a1      	str	r1, [r4, #8]
   188de:	d0da      	beq.n	18896 <z_add_timeout+0x32>
   188e0:	6812      	ldr	r2, [r2, #0]
   188e2:	e7d7      	b.n	18894 <z_add_timeout+0x30>
   188e4:	20005a14 	.word	0x20005a14

000188e8 <z_timeout_remaining>:

	return ret;
}

s32_t z_timeout_remaining(struct _timeout *timeout)
{
   188e8:	b538      	push	{r3, r4, r5, lr}
	s32_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
   188ea:	6804      	ldr	r4, [r0, #0]
   188ec:	b314      	cbz	r4, 18934 <z_timeout_remaining+0x4c>
	__asm__ volatile(
   188ee:	f04f 0320 	mov.w	r3, #32
   188f2:	f3ef 8111 	mrs	r1, BASEPRI
   188f6:	f383 8811 	msr	BASEPRI, r3
   188fa:	f3bf 8f6f 	isb	sy
	return list->head == list;
   188fe:	4a0e      	ldr	r2, [pc, #56]	; (18938 <z_timeout_remaining+0x50>)
   18900:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   18902:	4293      	cmp	r3, r2
   18904:	d014      	beq.n	18930 <z_timeout_remaining+0x48>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   18906:	6852      	ldr	r2, [r2, #4]
   18908:	2400      	movs	r4, #0
		return 0;
	}

	LOCKED(&timeout_lock) {
		for (struct _timeout *t = first(); t != NULL; t = next(t)) {
   1890a:	b93b      	cbnz	r3, 1891c <z_timeout_remaining+0x34>
	__asm__ volatile(
   1890c:	f381 8811 	msr	BASEPRI, r1
   18910:	f3bf 8f6f 	isb	sy
				break;
			}
		}
	}

	return ticks - elapsed();
   18914:	f7ff ff6c 	bl	187f0 <elapsed>
   18918:	1a20      	subs	r0, r4, r0
}
   1891a:	bd38      	pop	{r3, r4, r5, pc}
			ticks += t->dticks;
   1891c:	689d      	ldr	r5, [r3, #8]
			if (timeout == t) {
   1891e:	4283      	cmp	r3, r0
			ticks += t->dticks;
   18920:	442c      	add	r4, r5
			if (timeout == t) {
   18922:	d0f3      	beq.n	1890c <z_timeout_remaining+0x24>
   18924:	2b00      	cmp	r3, #0
   18926:	d0f1      	beq.n	1890c <z_timeout_remaining+0x24>
	return (node == list->tail) ? NULL : node->next;
   18928:	4293      	cmp	r3, r2
   1892a:	d0ef      	beq.n	1890c <z_timeout_remaining+0x24>
   1892c:	681b      	ldr	r3, [r3, #0]
   1892e:	e7ec      	b.n	1890a <z_timeout_remaining+0x22>
	return sys_dlist_is_empty(list) ? NULL : list->head;
   18930:	2400      	movs	r4, #0
   18932:	e7eb      	b.n	1890c <z_timeout_remaining+0x24>
		return 0;
   18934:	4620      	mov	r0, r4
   18936:	e7f0      	b.n	1891a <z_timeout_remaining+0x32>
   18938:	20005a14 	.word	0x20005a14

0001893c <z_clock_announce>:
		}
	}
}

void z_clock_announce(s32_t ticks)
{
   1893c:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
   18940:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   18942:	f7ff fb5b 	bl	17ffc <z_time_slice>
	__asm__ volatile(
   18946:	f04f 0320 	mov.w	r3, #32
   1894a:	f3ef 8511 	mrs	r5, BASEPRI
   1894e:	f383 8811 	msr	BASEPRI, r3
   18952:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   18956:	4e21      	ldr	r6, [pc, #132]	; (189dc <z_clock_announce+0xa0>)
   18958:	4f21      	ldr	r7, [pc, #132]	; (189e0 <z_clock_announce+0xa4>)
	return list->head == list;
   1895a:	f8df 9088 	ldr.w	r9, [pc, #136]	; 189e4 <z_clock_announce+0xa8>
   1895e:	6034      	str	r4, [r6, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
   18960:	46b8      	mov	r8, r7
   18962:	f8d9 4000 	ldr.w	r4, [r9]
   18966:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   18968:	454c      	cmp	r4, r9
   1896a:	e9d7 bc00 	ldrd	fp, ip, [r7]
   1896e:	d005      	beq.n	1897c <z_clock_announce+0x40>
   18970:	b124      	cbz	r4, 1897c <z_clock_announce+0x40>
   18972:	68a3      	ldr	r3, [r4, #8]
   18974:	4293      	cmp	r3, r2
   18976:	dd14      	ble.n	189a2 <z_clock_announce+0x66>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   18978:	1a9b      	subs	r3, r3, r2
   1897a:	60a3      	str	r3, [r4, #8]
	}

	curr_tick += announce_remaining;
   1897c:	eb1b 0002 	adds.w	r0, fp, r2
   18980:	eb4c 71e2 	adc.w	r1, ip, r2, asr #31
	announce_remaining = 0;
   18984:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
   18986:	e9c8 0100 	strd	r0, r1, [r8]
	announce_remaining = 0;
   1898a:	6034      	str	r4, [r6, #0]

	z_clock_set_timeout(next_timeout(), false);
   1898c:	f7ff ff4e 	bl	1882c <next_timeout>
   18990:	4621      	mov	r1, r4
   18992:	f7eb fbf5 	bl	4180 <z_clock_set_timeout>
	__asm__ volatile(
   18996:	f385 8811 	msr	BASEPRI, r5
   1899a:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   1899e:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		curr_tick += dt;
   189a2:	eb1b 0003 	adds.w	r0, fp, r3
   189a6:	eb4c 71e3 	adc.w	r1, ip, r3, asr #31
		announce_remaining -= dt;
   189aa:	1ad3      	subs	r3, r2, r3
   189ac:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
   189ae:	2300      	movs	r3, #0
		curr_tick += dt;
   189b0:	e9c7 0100 	strd	r0, r1, [r7]
		t->dticks = 0;
   189b4:	60a3      	str	r3, [r4, #8]
		remove_timeout(t);
   189b6:	4620      	mov	r0, r4
   189b8:	f7ff ff24 	bl	18804 <remove_timeout>
   189bc:	f385 8811 	msr	BASEPRI, r5
   189c0:	f3bf 8f6f 	isb	sy
		t->fn(t);
   189c4:	68e3      	ldr	r3, [r4, #12]
   189c6:	4798      	blx	r3
	__asm__ volatile(
   189c8:	f04f 0320 	mov.w	r3, #32
   189cc:	f3ef 8511 	mrs	r5, BASEPRI
   189d0:	f383 8811 	msr	BASEPRI, r3
   189d4:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
   189d8:	e7c3      	b.n	18962 <z_clock_announce+0x26>
   189da:	bf00      	nop
   189dc:	20001adc 	.word	0x20001adc
   189e0:	20000010 	.word	0x20000010
   189e4:	20005a14 	.word	0x20005a14

000189e8 <z_tick_get>:

s64_t z_tick_get(void)
{
   189e8:	e92d 4818 	stmdb	sp!, {r3, r4, fp, lr}
   189ec:	f04f 0320 	mov.w	r3, #32
   189f0:	f3ef 8411 	mrs	r4, BASEPRI
   189f4:	f383 8811 	msr	BASEPRI, r3
   189f8:	f3bf 8f6f 	isb	sy
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
   189fc:	f7eb fc16 	bl	422c <z_clock_elapsed>
   18a00:	4b07      	ldr	r3, [pc, #28]	; (18a20 <z_tick_get+0x38>)
   18a02:	e9d3 2300 	ldrd	r2, r3, [r3]
   18a06:	eb12 0b00 	adds.w	fp, r2, r0
   18a0a:	f143 0c00 	adc.w	ip, r3, #0
   18a0e:	4658      	mov	r0, fp
   18a10:	4661      	mov	r1, ip
	__asm__ volatile(
   18a12:	f384 8811 	msr	BASEPRI, r4
   18a16:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   18a1a:	e8bd 8818 	ldmia.w	sp!, {r3, r4, fp, pc}
   18a1e:	bf00      	nop
   18a20:	20000010 	.word	0x20000010

00018a24 <z_timer_expiration_handler>:

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
   18a24:	6a02      	ldr	r2, [r0, #32]
   18a26:	2a00      	cmp	r2, #0
{
   18a28:	b538      	push	{r3, r4, r5, lr}
   18a2a:	4604      	mov	r4, r0
	if (timer->period > 0) {
   18a2c:	dd02      	ble.n	18a34 <z_timer_expiration_handler+0x10>
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   18a2e:	490e      	ldr	r1, [pc, #56]	; (18a68 <z_timer_expiration_handler+0x44>)
   18a30:	f7ff ff18 	bl	18864 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   18a34:	6a63      	ldr	r3, [r4, #36]	; 0x24
   18a36:	3301      	adds	r3, #1
   18a38:	6263      	str	r3, [r4, #36]	; 0x24

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   18a3a:	69a3      	ldr	r3, [r4, #24]
   18a3c:	b10b      	cbz	r3, 18a42 <z_timer_expiration_handler+0x1e>
		timer->expiry_fn(timer);
   18a3e:	4620      	mov	r0, r4
   18a40:	4798      	blx	r3
	return list->head == list;
   18a42:	f854 5f10 	ldr.w	r5, [r4, #16]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   18a46:	42a5      	cmp	r5, r4
   18a48:	d00d      	beq.n	18a66 <z_timer_expiration_handler+0x42>
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   18a4a:	b165      	cbz	r5, 18a66 <z_timer_expiration_handler+0x42>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
   18a4c:	4628      	mov	r0, r5
   18a4e:	f005 fd2d 	bl	1e4ac <z_unpend_thread_no_timeout>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   18a52:	7b6b      	ldrb	r3, [r5, #13]
   18a54:	06db      	lsls	r3, r3, #27
   18a56:	d104      	bne.n	18a62 <z_timer_expiration_handler+0x3e>
	if (z_is_thread_ready(thread)) {
   18a58:	69ab      	ldr	r3, [r5, #24]
   18a5a:	b913      	cbnz	r3, 18a62 <z_timer_expiration_handler+0x3e>
		z_add_thread_to_ready_q(thread);
   18a5c:	4628      	mov	r0, r5
   18a5e:	f7ff fa55 	bl	17f0c <z_add_thread_to_ready_q>
   18a62:	2300      	movs	r3, #0
   18a64:	66ab      	str	r3, [r5, #104]	; 0x68

	z_ready_thread(thread);

	arch_thread_return_value_set(thread, 0);
}
   18a66:	bd38      	pop	{r3, r4, r5, pc}
   18a68:	00018a25 	.word	0x00018a25

00018a6c <z_impl_k_timer_start>:
	z_object_init(timer);
}


void z_impl_k_timer_start(struct k_timer *timer, s32_t duration, s32_t period)
{
   18a6c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   18a70:	f240 36e7 	movw	r6, #999	; 0x3e7
   18a74:	2700      	movs	r7, #0
   18a76:	4604      	mov	r4, r0
   18a78:	4688      	mov	r8, r1
   18a7a:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   18a7e:	4630      	mov	r0, r6
   18a80:	4639      	mov	r1, r7
   18a82:	fbe5 0102 	umlal	r0, r1, r5, r2
   18a86:	2300      	movs	r3, #0
   18a88:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   18a8c:	f7e7 fb28 	bl	e0 <__aeabi_uldivmod>
   18a90:	4639      	mov	r1, r7
	__ASSERT(duration >= 0 && period >= 0 &&
		 (duration != 0 || period != 0), "invalid parameters\n");

	volatile s32_t period_in_ticks, duration_in_ticks;

	period_in_ticks = k_ms_to_ticks_ceil32(period);
   18a92:	9000      	str	r0, [sp, #0]
   18a94:	4630      	mov	r0, r6
   18a96:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   18a9a:	2300      	movs	r3, #0
   18a9c:	fbe5 0108 	umlal	r0, r1, r5, r8
   18aa0:	f7e7 fb1e 	bl	e0 <__aeabi_uldivmod>
	duration_in_ticks = k_ms_to_ticks_ceil32(duration);
   18aa4:	9001      	str	r0, [sp, #4]

	(void)z_abort_timeout(&timer->timeout);
   18aa6:	4620      	mov	r0, r4
   18aa8:	f005 fe6b 	bl	1e782 <z_abort_timeout>
	timer->period = period_in_ticks;
   18aac:	9b00      	ldr	r3, [sp, #0]
	timer->status = 0U;
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   18aae:	4905      	ldr	r1, [pc, #20]	; (18ac4 <z_impl_k_timer_start+0x58>)
   18ab0:	9a01      	ldr	r2, [sp, #4]
	timer->period = period_in_ticks;
   18ab2:	6223      	str	r3, [r4, #32]
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   18ab4:	4620      	mov	r0, r4
	timer->status = 0U;
   18ab6:	2300      	movs	r3, #0
   18ab8:	6263      	str	r3, [r4, #36]	; 0x24
		     duration_in_ticks);
}
   18aba:	b002      	add	sp, #8
   18abc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   18ac0:	f7ff bed0 	b.w	18864 <z_add_timeout>
   18ac4:	00018a25 	.word	0x00018a25

00018ac8 <k_poll_event_init>:
 */
static struct k_spinlock lock;

void k_poll_event_init(struct k_poll_event *event, u32_t type,
		       int mode, void *obj)
{
   18ac8:	b510      	push	{r4, lr}
	__ASSERT(type < (BIT(_POLL_NUM_TYPES)), "invalid type\n");
	__ASSERT(obj != NULL, "must provide an object\n");

	event->poller = NULL;
	/* event->tag is left uninitialized: the user will set it if needed */
	event->type = type;
   18aca:	7b44      	ldrb	r4, [r0, #13]
   18acc:	f361 0403 	bfi	r4, r1, #0, #4
	event->state = K_POLL_STATE_NOT_READY;
	event->mode = mode;
   18ad0:	7b81      	ldrb	r1, [r0, #14]
	event->type = type;
   18ad2:	7344      	strb	r4, [r0, #13]
	event->mode = mode;
   18ad4:	f362 0141 	bfi	r1, r2, #1, #1
   18ad8:	7381      	strb	r1, [r0, #14]
	event->poller = NULL;
   18ada:	2200      	movs	r2, #0
	event->state = K_POLL_STATE_NOT_READY;
   18adc:	68c1      	ldr	r1, [r0, #12]
	event->poller = NULL;
   18ade:	6082      	str	r2, [r0, #8]
	event->state = K_POLL_STATE_NOT_READY;
   18ae0:	4a02      	ldr	r2, [pc, #8]	; (18aec <k_poll_event_init+0x24>)
   18ae2:	400a      	ands	r2, r1
	event->unused = 0U;
	event->obj = obj;
   18ae4:	e9c0 2303 	strd	r2, r3, [r0, #12]
}
   18ae8:	bd10      	pop	{r4, pc}
   18aea:	bf00      	nop
   18aec:	00020fff 	.word	0x00020fff

00018af0 <z_impl_k_poll>:

	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events, s32_t timeout)
{
   18af0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   18af4:	b086      	sub	sp, #24
	int events_registered;
	k_spinlock_key_t key;
	struct _poller poller = { .is_polling = true,
   18af6:	2301      	movs	r3, #1
   18af8:	f88d 300c 	strb.w	r3, [sp, #12]
				  .thread     = _current,
   18afc:	4b23      	ldr	r3, [pc, #140]	; (18b8c <z_impl_k_poll+0x9c>)
	struct _poller poller = { .is_polling = true,
   18afe:	689b      	ldr	r3, [r3, #8]
   18b00:	9304      	str	r3, [sp, #16]
   18b02:	4b23      	ldr	r3, [pc, #140]	; (18b90 <z_impl_k_poll+0xa0>)
   18b04:	9305      	str	r3, [sp, #20]

	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(events != NULL, "NULL events\n");
	__ASSERT(num_events >= 0, "<0 events\n");

	events_registered = register_events(events, num_events, &poller,
   18b06:	fab2 f382 	clz	r3, r2
   18b0a:	4690      	mov	r8, r2
   18b0c:	095b      	lsrs	r3, r3, #5
   18b0e:	aa03      	add	r2, sp, #12
{
   18b10:	4606      	mov	r6, r0
	events_registered = register_events(events, num_events, &poller,
   18b12:	f005 ff53 	bl	1e9bc <register_events>
   18b16:	4607      	mov	r7, r0
	__asm__ volatile(
   18b18:	f04f 0320 	mov.w	r3, #32
   18b1c:	f3ef 8511 	mrs	r5, BASEPRI
   18b20:	f383 8811 	msr	BASEPRI, r3
   18b24:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller.is_polling) {
   18b28:	f89d 300c 	ldrb.w	r3, [sp, #12]
   18b2c:	f003 04ff 	and.w	r4, r3, #255	; 0xff
   18b30:	b94b      	cbnz	r3, 18b46 <z_impl_k_poll+0x56>
	 * we've already know the return code (-EAGAIN), and even if they are
	 * added to the list of events that occurred, the user has to check the
	 * return code first, which invalidates the whole list of event states.
	 */
	key = k_spin_lock(&lock);
	clear_event_registrations(events, events_registered, key);
   18b32:	462a      	mov	r2, r5
   18b34:	4639      	mov	r1, r7
   18b36:	4630      	mov	r0, r6
   18b38:	f005 fea8 	bl	1e88c <clear_event_registrations>
	__asm__ volatile(
   18b3c:	f385 8811 	msr	BASEPRI, r5
   18b40:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	return swap_rc;
   18b44:	e00b      	b.n	18b5e <z_impl_k_poll+0x6e>
	poller.is_polling = false;
   18b46:	2300      	movs	r3, #0
   18b48:	f88d 300c 	strb.w	r3, [sp, #12]
	if (timeout == K_NO_WAIT) {
   18b4c:	f1b8 0f00 	cmp.w	r8, #0
   18b50:	d109      	bne.n	18b66 <z_impl_k_poll+0x76>
   18b52:	f385 8811 	msr	BASEPRI, r5
   18b56:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
   18b5a:	f06f 040a 	mvn.w	r4, #10
}
   18b5e:	4620      	mov	r0, r4
   18b60:	b006      	add	sp, #24
   18b62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   18b66:	aa01      	add	r2, sp, #4
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   18b68:	4643      	mov	r3, r8
   18b6a:	4629      	mov	r1, r5
   18b6c:	4809      	ldr	r0, [pc, #36]	; (18b94 <z_impl_k_poll+0xa4>)
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   18b6e:	e9cd 2201 	strd	r2, r2, [sp, #4]
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   18b72:	f7ff fb7d 	bl	18270 <z_pend_curr>
   18b76:	4604      	mov	r4, r0
	__asm__ volatile(
   18b78:	f04f 0320 	mov.w	r3, #32
   18b7c:	f3ef 8511 	mrs	r5, BASEPRI
   18b80:	f383 8811 	msr	BASEPRI, r3
   18b84:	f3bf 8f6f 	isb	sy
   18b88:	e7d3      	b.n	18b32 <z_impl_k_poll+0x42>
   18b8a:	bf00      	nop
   18b8c:	20001a24 	.word	0x20001a24
   18b90:	0001e91d 	.word	0x0001e91d
   18b94:	20001df0 	.word	0x20001df0

00018b98 <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *signal, int result)
{
   18b98:	b538      	push	{r3, r4, r5, lr}
   18b9a:	f04f 0320 	mov.w	r3, #32
   18b9e:	f3ef 8511 	mrs	r5, BASEPRI
   18ba2:	f383 8811 	msr	BASEPRI, r3
   18ba6:	f3bf 8f6f 	isb	sy
	return list->head == list;
   18baa:	6803      	ldr	r3, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	signal->result = result;
   18bac:	60c1      	str	r1, [r0, #12]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   18bae:	4298      	cmp	r0, r3
	signal->signaled = 1U;
   18bb0:	f04f 0101 	mov.w	r1, #1
   18bb4:	6081      	str	r1, [r0, #8]
   18bb6:	d106      	bne.n	18bc6 <z_impl_k_poll_signal_raise+0x2e>
	__asm__ volatile(
   18bb8:	f385 8811 	msr	BASEPRI, r5
   18bbc:	f3bf 8f6f 	isb	sy

	poll_event = (struct k_poll_event *)sys_dlist_get(&signal->poll_events);
	if (poll_event == NULL) {
		k_spin_unlock(&lock, key);
		return 0;
   18bc0:	2400      	movs	r4, #0

	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);

	z_reschedule(&lock, key);
	return rc;
}
   18bc2:	4620      	mov	r0, r4
   18bc4:	bd38      	pop	{r3, r4, r5, pc}
	node->prev->next = node->next;
   18bc6:	e9d3 2000 	ldrd	r2, r0, [r3]
   18bca:	6002      	str	r2, [r0, #0]
	node->next->prev = node->prev;
   18bcc:	6050      	str	r0, [r2, #4]
	node->next = NULL;
   18bce:	2200      	movs	r2, #0
	node->prev = NULL;
   18bd0:	e9c3 2200 	strd	r2, r2, [r3]
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   18bd4:	4618      	mov	r0, r3
   18bd6:	f005 fe86 	bl	1e8e6 <signal_poll_event>
	z_reschedule(&lock, key);
   18bda:	4629      	mov	r1, r5
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   18bdc:	4604      	mov	r4, r0
	z_reschedule(&lock, key);
   18bde:	4802      	ldr	r0, [pc, #8]	; (18be8 <z_impl_k_poll_signal_raise+0x50>)
   18be0:	f005 fc7d 	bl	1e4de <z_reschedule>
	return rc;
   18be4:	e7ed      	b.n	18bc2 <z_impl_k_poll_signal_raise+0x2a>
   18be6:	bf00      	nop
   18be8:	20001df0 	.word	0x20001df0

00018bec <disconnected>:
}
   18bec:	4770      	bx	lr

00018bee <connected>:
	if (err) {
   18bee:	b909      	cbnz	r1, 18bf4 <connected+0x6>
    cts_sync_processor(conn, NULL);
   18bf0:	f7e9 bdca 	b.w	2788 <cts_sync_processor>
}
   18bf4:	4770      	bx	lr

00018bf6 <u8_to_dec>:
 */

#include <sys/util.h>

u8_t u8_to_dec(char *buf, u8_t buflen, u8_t value)
{
   18bf6:	b5f0      	push	{r4, r5, r6, r7, lr}
	u8_t divisor = 100;
	u8_t num_digits = 0;
   18bf8:	2300      	movs	r3, #0
	u8_t digit;

	while (buflen > 0 && divisor > 0) {
   18bfa:	2504      	movs	r5, #4
	u8_t divisor = 100;
   18bfc:	2464      	movs	r4, #100	; 0x64
			buflen--;
			num_digits++;
		}

		value -= digit * divisor;
		divisor /= 10;
   18bfe:	f04f 0c0a 	mov.w	ip, #10
	while (buflen > 0 && divisor > 0) {
   18c02:	b111      	cbz	r1, 18c0a <u8_to_dec+0x14>
   18c04:	3d01      	subs	r5, #1
   18c06:	d102      	bne.n	18c0e <u8_to_dec+0x18>
	}

	if (buflen) {
		*buf = '\0';
   18c08:	7005      	strb	r5, [r0, #0]
	}

	return num_digits;
}
   18c0a:	4618      	mov	r0, r3
   18c0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (digit != 0 || divisor == 1 || num_digits != 0) {
   18c0e:	42a2      	cmp	r2, r4
		digit = value / divisor;
   18c10:	fbb2 f7f4 	udiv	r7, r2, r4
   18c14:	b2fe      	uxtb	r6, r7
		if (digit != 0 || divisor == 1 || num_digits != 0) {
   18c16:	d202      	bcs.n	18c1e <u8_to_dec+0x28>
   18c18:	2c01      	cmp	r4, #1
   18c1a:	d000      	beq.n	18c1e <u8_to_dec+0x28>
   18c1c:	b133      	cbz	r3, 18c2c <u8_to_dec+0x36>
			*buf = (char)digit + '0';
   18c1e:	3630      	adds	r6, #48	; 0x30
			buflen--;
   18c20:	3901      	subs	r1, #1
			num_digits++;
   18c22:	3301      	adds	r3, #1
			*buf = (char)digit + '0';
   18c24:	f800 6b01 	strb.w	r6, [r0], #1
			buflen--;
   18c28:	b2c9      	uxtb	r1, r1
			num_digits++;
   18c2a:	b2db      	uxtb	r3, r3
		value -= digit * divisor;
   18c2c:	fb04 2217 	mls	r2, r4, r7, r2
   18c30:	b2d2      	uxtb	r2, r2
		divisor /= 10;
   18c32:	fbb4 f4fc 	udiv	r4, r4, ip
   18c36:	e7e4      	b.n	18c02 <u8_to_dec+0xc>

00018c38 <char2hex>:
#include <errno.h>
#include <sys/util.h>

int char2hex(char c, u8_t *x)
{
	if (c >= '0' && c <= '9') {
   18c38:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
   18c3c:	b2db      	uxtb	r3, r3
   18c3e:	2b09      	cmp	r3, #9
   18c40:	d802      	bhi.n	18c48 <char2hex+0x10>
		*x = c - '0';
   18c42:	700b      	strb	r3, [r1, #0]
		*x = c - 'A' + 10;
	} else {
		return -EINVAL;
	}

	return 0;
   18c44:	2000      	movs	r0, #0
   18c46:	4770      	bx	lr
	} else if (c >= 'a' && c <= 'f') {
   18c48:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
   18c4c:	2b05      	cmp	r3, #5
   18c4e:	d802      	bhi.n	18c56 <char2hex+0x1e>
		*x = c - 'a' + 10;
   18c50:	3857      	subs	r0, #87	; 0x57
   18c52:	7008      	strb	r0, [r1, #0]
   18c54:	e7f6      	b.n	18c44 <char2hex+0xc>
	} else if (c >= 'A' && c <= 'F') {
   18c56:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
   18c5a:	2b05      	cmp	r3, #5
   18c5c:	d801      	bhi.n	18c62 <char2hex+0x2a>
		*x = c - 'A' + 10;
   18c5e:	3837      	subs	r0, #55	; 0x37
   18c60:	e7f7      	b.n	18c52 <char2hex+0x1a>
		return -EINVAL;
   18c62:	f06f 0015 	mvn.w	r0, #21
}
   18c66:	4770      	bx	lr

00018c68 <hex2bin>:
	hex[2 * buflen] = '\0';
	return 2 * buflen;
}

size_t hex2bin(const char *hex, size_t hexlen, u8_t *buf, size_t buflen)
{
   18c68:	b573      	push	{r0, r1, r4, r5, r6, lr}
	u8_t dec;

	if (buflen < hexlen / 2 + hexlen % 2) {
   18c6a:	084d      	lsrs	r5, r1, #1
   18c6c:	f001 0101 	and.w	r1, r1, #1
   18c70:	186e      	adds	r6, r5, r1
   18c72:	429e      	cmp	r6, r3
{
   18c74:	4604      	mov	r4, r0
	if (buflen < hexlen / 2 + hexlen % 2) {
   18c76:	d903      	bls.n	18c80 <hex2bin+0x18>
		return 0;
   18c78:	2600      	movs	r6, #0
		}
		buf[i] += dec;
	}

	return hexlen / 2 + hexlen % 2;
}
   18c7a:	4630      	mov	r0, r6
   18c7c:	b002      	add	sp, #8
   18c7e:	bd70      	pop	{r4, r5, r6, pc}
	if (hexlen % 2) {
   18c80:	b159      	cbz	r1, 18c9a <hex2bin+0x32>
		if (char2hex(hex[0], &dec) < 0) {
   18c82:	f10d 0107 	add.w	r1, sp, #7
   18c86:	7800      	ldrb	r0, [r0, #0]
   18c88:	f7ff ffd6 	bl	18c38 <char2hex>
   18c8c:	2800      	cmp	r0, #0
   18c8e:	dbf3      	blt.n	18c78 <hex2bin+0x10>
		buf[0] = dec;
   18c90:	f89d 3007 	ldrb.w	r3, [sp, #7]
   18c94:	f802 3b01 	strb.w	r3, [r2], #1
		hex++;
   18c98:	3401      	adds	r4, #1
	for (size_t i = 0; i < hexlen / 2; i++) {
   18c9a:	3a01      	subs	r2, #1
   18c9c:	eb04 0545 	add.w	r5, r4, r5, lsl #1
   18ca0:	42ac      	cmp	r4, r5
   18ca2:	d0ea      	beq.n	18c7a <hex2bin+0x12>
		if (char2hex(hex[2 * i], &dec) < 0) {
   18ca4:	f10d 0107 	add.w	r1, sp, #7
   18ca8:	7820      	ldrb	r0, [r4, #0]
   18caa:	f7ff ffc5 	bl	18c38 <char2hex>
   18cae:	2800      	cmp	r0, #0
   18cb0:	dbe2      	blt.n	18c78 <hex2bin+0x10>
		buf[i] = dec << 4;
   18cb2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   18cb6:	011b      	lsls	r3, r3, #4
   18cb8:	7053      	strb	r3, [r2, #1]
		if (char2hex(hex[2 * i + 1], &dec) < 0) {
   18cba:	7860      	ldrb	r0, [r4, #1]
   18cbc:	f10d 0107 	add.w	r1, sp, #7
   18cc0:	f7ff ffba 	bl	18c38 <char2hex>
   18cc4:	2800      	cmp	r0, #0
   18cc6:	f104 0402 	add.w	r4, r4, #2
   18cca:	dbd5      	blt.n	18c78 <hex2bin+0x10>
		buf[i] += dec;
   18ccc:	f812 3f01 	ldrb.w	r3, [r2, #1]!
   18cd0:	f89d 1007 	ldrb.w	r1, [sp, #7]
   18cd4:	440b      	add	r3, r1
   18cd6:	7013      	strb	r3, [r2, #0]
   18cd8:	e7e2      	b.n	18ca0 <hex2bin+0x38>

00018cda <get_bit_ptr>:
/* Places a 32 bit output pointer in word, and an integer bit index
 * within that word as the return value
 */
static int get_bit_ptr(struct sys_mem_pool_base *p, int level, int bn,
		       u32_t **word)
{
   18cda:	b570      	push	{r4, r5, r6, lr}
   18cdc:	68c6      	ldr	r6, [r0, #12]
	u32_t *bitarray = level <= p->max_inline_level ?
   18cde:	f990 000b 	ldrsb.w	r0, [r0, #11]
   18ce2:	250c      	movs	r5, #12
   18ce4:	434d      	muls	r5, r1
		p->levels[level].bits : p->levels[level].bits_p;
   18ce6:	4288      	cmp	r0, r1
   18ce8:	eb06 0405 	add.w	r4, r6, r5
   18cec:	bfb8      	it	lt
   18cee:	5974      	ldrlt	r4, [r6, r5]

	*word = &bitarray[bn / 32];
   18cf0:	2a00      	cmp	r2, #0
   18cf2:	4610      	mov	r0, r2
   18cf4:	bfb8      	it	lt
   18cf6:	f102 001f 	addlt.w	r0, r2, #31
   18cfa:	1140      	asrs	r0, r0, #5
   18cfc:	eb04 0180 	add.w	r1, r4, r0, lsl #2
   18d00:	6019      	str	r1, [r3, #0]

	return bn & 0x1f;
}
   18d02:	f002 001f 	and.w	r0, r2, #31
   18d06:	bd70      	pop	{r4, r5, r6, pc}

00018d08 <pool_irq_lock.isra.2.part.3>:
	__asm__ volatile(
   18d08:	f04f 0320 	mov.w	r3, #32
   18d0c:	f3ef 8011 	mrs	r0, BASEPRI
   18d10:	f383 8811 	msr	BASEPRI, r3
   18d14:	f3bf 8f6f 	isb	sy
	if (p->flags & SYS_MEM_POOL_KERNEL) {
		return irq_lock();
	} else {
		return 0;
	}
}
   18d18:	4770      	bx	lr

00018d1a <pool_irq_unlock.isra.4>:

static inline void pool_irq_unlock(struct sys_mem_pool_base *p, int key)
{
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   18d1a:	07c3      	lsls	r3, r0, #31
   18d1c:	d503      	bpl.n	18d26 <pool_irq_unlock.isra.4+0xc>
	__asm__ volatile(
   18d1e:	f381 8811 	msr	BASEPRI, r1
   18d22:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}
}
   18d26:	4770      	bx	lr

00018d28 <z_sys_mem_pool_base_init>:
{
   18d28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   18d2c:	6846      	ldr	r6, [r0, #4]
   18d2e:	8907      	ldrh	r7, [r0, #8]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
   18d30:	6801      	ldr	r1, [r0, #0]
	for (i = 0; i < p->n_levels; i++) {
   18d32:	f890 800a 	ldrb.w	r8, [r0, #10]
	p->max_inline_level = -1;
   18d36:	23ff      	movs	r3, #255	; 0xff
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   18d38:	fb06 fc07 	mul.w	ip, r6, r7
	p->max_inline_level = -1;
   18d3c:	72c3      	strb	r3, [r0, #11]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
   18d3e:	4461      	add	r1, ip
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   18d40:	4632      	mov	r2, r6
	for (i = 0; i < p->n_levels; i++) {
   18d42:	2300      	movs	r3, #0
		sys_dlist_init(&p->levels[i].free_list);
   18d44:	f04f 090c 	mov.w	r9, #12
	for (i = 0; i < p->n_levels; i++) {
   18d48:	4598      	cmp	r8, r3
   18d4a:	dc05      	bgt.n	18d58 <z_sys_mem_pool_base_init+0x30>
   18d4c:	2300      	movs	r3, #0
	for (i = 0; i < p->n_max; i++) {
   18d4e:	4619      	mov	r1, r3
   18d50:	428f      	cmp	r7, r1
   18d52:	dc20      	bgt.n	18d96 <z_sys_mem_pool_base_init+0x6e>
}
   18d54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		sys_dlist_init(&p->levels[i].free_list);
   18d58:	f8d0 a00c 	ldr.w	sl, [r0, #12]
		int nblocks = buflen / sz;
   18d5c:	fbbc f5f2 	udiv	r5, ip, r2
		sys_dlist_init(&p->levels[i].free_list);
   18d60:	fb09 fe03 	mul.w	lr, r9, r3
   18d64:	eb0a 040e 	add.w	r4, sl, lr
   18d68:	f104 0b04 	add.w	fp, r4, #4
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
   18d6c:	2d20      	cmp	r5, #32
	list->tail = (sys_dnode_t *)list;
   18d6e:	e9c4 bb01 	strd	fp, fp, [r4, #4]
   18d72:	d805      	bhi.n	18d80 <z_sys_mem_pool_base_init+0x58>
			p->max_inline_level = i;
   18d74:	72c3      	strb	r3, [r0, #11]
		sz = WB_DN(sz / 4);
   18d76:	0892      	lsrs	r2, r2, #2
   18d78:	f022 0203 	bic.w	r2, r2, #3
	for (i = 0; i < p->n_levels; i++) {
   18d7c:	3301      	adds	r3, #1
   18d7e:	e7e3      	b.n	18d48 <z_sys_mem_pool_base_init+0x20>
			bits += (nblocks + 31)/32;
   18d80:	f115 041f 	adds.w	r4, r5, #31
   18d84:	bf48      	it	mi
   18d86:	f105 043e 	addmi.w	r4, r5, #62	; 0x3e
   18d8a:	1164      	asrs	r4, r4, #5
			p->levels[i].bits_p = bits;
   18d8c:	f84a 100e 	str.w	r1, [sl, lr]
			bits += (nblocks + 31)/32;
   18d90:	eb01 0184 	add.w	r1, r1, r4, lsl #2
   18d94:	e7ef      	b.n	18d76 <z_sys_mem_pool_base_init+0x4e>
		sys_dlist_append(&p->levels[0].free_list, block);
   18d96:	68c2      	ldr	r2, [r0, #12]
	return (u8_t *)p->buf + lsz * block;
   18d98:	6805      	ldr	r5, [r0, #0]
		sys_dlist_append(&p->levels[0].free_list, block);
   18d9a:	f102 0c04 	add.w	ip, r2, #4
	return (u8_t *)p->buf + lsz * block;
   18d9e:	18ec      	adds	r4, r5, r3
	node->next = list;
   18da0:	f845 c003 	str.w	ip, [r5, r3]
	node->prev = list->tail;
   18da4:	6895      	ldr	r5, [r2, #8]
   18da6:	6065      	str	r5, [r4, #4]
	list->tail->next = node;
   18da8:	6895      	ldr	r5, [r2, #8]
	for (i = 0; i < p->n_max; i++) {
   18daa:	3101      	adds	r1, #1
   18dac:	602c      	str	r4, [r5, #0]
	list->tail = node;
   18dae:	4433      	add	r3, r6
   18db0:	6094      	str	r4, [r2, #8]
   18db2:	e7cd      	b.n	18d50 <z_sys_mem_pool_base_init+0x28>

00018db4 <z_sys_mem_pool_block_alloc>:
	return block;
}

int z_sys_mem_pool_block_alloc(struct sys_mem_pool_base *p, size_t size,
			      u32_t *level_p, u32_t *block_p, void **data_p)
{
   18db4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18db8:	b087      	sub	sp, #28
	int i, from_l, alloc_l = -1;
	unsigned int key;
	void *data = NULL;
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   18dba:	7a85      	ldrb	r5, [r0, #10]
{
   18dbc:	af00      	add	r7, sp, #0
   18dbe:	e9c7 3201 	strd	r3, r2, [r7, #4]
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   18dc2:	00ab      	lsls	r3, r5, #2
   18dc4:	3307      	adds	r3, #7
   18dc6:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
   18dca:	ebad 0d03 	sub.w	sp, sp, r3
   18dce:	46ea      	mov	sl, sp
	 * want to allocate and the smallest one with a free entry
	 * from which we can split an allocation if needed.  Along the
	 * way, we populate an array of sizes for each level so we
	 * don't need to waste RAM storing it.
	 */
	lsizes[0] = p->max_sz;
   18dd0:	4653      	mov	r3, sl
   18dd2:	6842      	ldr	r2, [r0, #4]
   18dd4:	f843 2904 	str.w	r2, [r3], #-4
{
   18dd8:	4604      	mov	r4, r0
	for (i = 0; i < p->n_levels; i++) {
   18dda:	2200      	movs	r2, #0
   18ddc:	4295      	cmp	r5, r2
   18dde:	f102 39ff 	add.w	r9, r2, #4294967295	; 0xffffffff
   18de2:	dd09      	ble.n	18df8 <z_sys_mem_pool_block_alloc+0x44>
		if (i > 0) {
   18de4:	b122      	cbz	r2, 18df0 <z_sys_mem_pool_block_alloc+0x3c>
			lsizes[i] = WB_DN(lsizes[i-1] / 4);
   18de6:	6818      	ldr	r0, [r3, #0]
   18de8:	0880      	lsrs	r0, r0, #2
   18dea:	f020 0003 	bic.w	r0, r0, #3
   18dee:	6058      	str	r0, [r3, #4]
		}

		if (lsizes[i] < size) {
   18df0:	f853 0f04 	ldr.w	r0, [r3, #4]!
   18df4:	4288      	cmp	r0, r1
   18df6:	d208      	bcs.n	18e0a <z_sys_mem_pool_block_alloc+0x56>
		}

		alloc_l = i;
	}

	if (alloc_l < 0) {
   18df8:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   18dfc:	d107      	bne.n	18e0e <z_sys_mem_pool_block_alloc+0x5a>
		*data_p = NULL;
   18dfe:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   18e00:	2300      	movs	r3, #0
   18e02:	6013      	str	r3, [r2, #0]
	pool_irq_unlock(p, key);

	*data_p = data;

	if (data == NULL) {
		return -ENOMEM;
   18e04:	f06f 000b 	mvn.w	r0, #11
   18e08:	e044      	b.n	18e94 <z_sys_mem_pool_block_alloc+0xe0>
	for (i = 0; i < p->n_levels; i++) {
   18e0a:	3201      	adds	r2, #1
   18e0c:	e7e6      	b.n	18ddc <z_sys_mem_pool_block_alloc+0x28>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   18e0e:	7c20      	ldrb	r0, [r4, #16]
   18e10:	f010 0001 	ands.w	r0, r0, #1
   18e14:	d001      	beq.n	18e1a <z_sys_mem_pool_block_alloc+0x66>
   18e16:	f7ff ff77 	bl	18d08 <pool_irq_lock.isra.2.part.3>
   18e1a:	68e2      	ldr	r2, [r4, #12]
   18e1c:	230c      	movs	r3, #12
	key = pool_irq_lock(p);
   18e1e:	4680      	mov	r8, r0
	for (i = alloc_l; i >= 0; i--) {
   18e20:	fb03 2309 	mla	r3, r3, r9, r2
	block = sys_dlist_get(&p->levels[l].free_list);
   18e24:	464e      	mov	r6, r9
	return list->head == list;
   18e26:	461a      	mov	r2, r3
   18e28:	f852 5f04 	ldr.w	r5, [r2, #4]!
	if (!sys_dlist_is_empty(list)) {
   18e2c:	4295      	cmp	r5, r2
   18e2e:	d06d      	beq.n	18f0c <z_sys_mem_pool_block_alloc+0x158>
	node->prev->next = node->next;
   18e30:	e9d5 3200 	ldrd	r3, r2, [r5]
   18e34:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   18e36:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   18e38:	2300      	movs	r3, #0
	node->prev = NULL;
   18e3a:	e9c5 3300 	strd	r3, r3, [r5]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   18e3e:	6823      	ldr	r3, [r4, #0]
		data = block_alloc(p, i, lsizes[i]);
   18e40:	f85a 1026 	ldr.w	r1, [sl, r6, lsl #2]
	int bit = get_bit_ptr(p, level, bn, &word);
   18e44:	f107 0b14 	add.w	fp, r7, #20
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   18e48:	1aea      	subs	r2, r5, r3
	int bit = get_bit_ptr(p, level, bn, &word);
   18e4a:	4620      	mov	r0, r4
   18e4c:	fb92 f2f1 	sdiv	r2, r2, r1
   18e50:	465b      	mov	r3, fp
   18e52:	4631      	mov	r1, r6
   18e54:	f7ff ff41 	bl	18cda <get_bit_ptr>
	*word |= (1<<bit);
   18e58:	6979      	ldr	r1, [r7, #20]
   18e5a:	2201      	movs	r2, #1
   18e5c:	680b      	ldr	r3, [r1, #0]
   18e5e:	603a      	str	r2, [r7, #0]
   18e60:	fa02 f000 	lsl.w	r0, r2, r0
   18e64:	4303      	orrs	r3, r0
   18e66:	600b      	str	r3, [r1, #0]
			for (from_l = i; from_l < alloc_l; from_l++) {
   18e68:	454e      	cmp	r6, r9
   18e6a:	db17      	blt.n	18e9c <z_sys_mem_pool_block_alloc+0xe8>
	pool_irq_unlock(p, key);
   18e6c:	4641      	mov	r1, r8
   18e6e:	7c20      	ldrb	r0, [r4, #16]
   18e70:	f7ff ff53 	bl	18d1a <pool_irq_unlock.isra.4>
	*data_p = data;
   18e74:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   18e76:	601d      	str	r5, [r3, #0]
	if (data == NULL) {
   18e78:	2d00      	cmp	r5, #0
   18e7a:	d0c3      	beq.n	18e04 <z_sys_mem_pool_block_alloc+0x50>
	}

	*level_p = alloc_l;
   18e7c:	68bb      	ldr	r3, [r7, #8]
   18e7e:	f8c3 9000 	str.w	r9, [r3]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   18e82:	6823      	ldr	r3, [r4, #0]
   18e84:	1aed      	subs	r5, r5, r3
   18e86:	f85a 3029 	ldr.w	r3, [sl, r9, lsl #2]
   18e8a:	fb95 f5f3 	sdiv	r5, r5, r3
	*block_p = block_num(p, data, lsizes[alloc_l]);
   18e8e:	687b      	ldr	r3, [r7, #4]

	return 0;
   18e90:	2000      	movs	r0, #0
	*block_p = block_num(p, data, lsizes[alloc_l]);
   18e92:	601d      	str	r5, [r3, #0]
}
   18e94:	371c      	adds	r7, #28
   18e96:	46bd      	mov	sp, r7
   18e98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   18e9c:	6822      	ldr	r2, [r4, #0]
   18e9e:	f85a 3026 	ldr.w	r3, [sl, r6, lsl #2]
	set_alloc_bit(p, l + 1, 4*bn);
   18ea2:	3601      	adds	r6, #1
	int bit = get_bit_ptr(p, level, bn, &word);
   18ea4:	4631      	mov	r1, r6
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   18ea6:	1aaa      	subs	r2, r5, r2
	int bit = get_bit_ptr(p, level, bn, &word);
   18ea8:	4620      	mov	r0, r4
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   18eaa:	fb92 f2f3 	sdiv	r2, r2, r3
	int bit = get_bit_ptr(p, level, bn, &word);
   18eae:	465b      	mov	r3, fp
   18eb0:	0092      	lsls	r2, r2, #2
   18eb2:	f7ff ff12 	bl	18cda <get_bit_ptr>
	*word |= (1<<bit);
   18eb6:	697a      	ldr	r2, [r7, #20]
   18eb8:	683b      	ldr	r3, [r7, #0]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   18eba:	68e1      	ldr	r1, [r4, #12]
	*word |= (1<<bit);
   18ebc:	fa03 f000 	lsl.w	r0, r3, r0
   18ec0:	6813      	ldr	r3, [r2, #0]
   18ec2:	4303      	orrs	r3, r0
   18ec4:	6013      	str	r3, [r2, #0]
		int lsz = lsizes[l + 1];
   18ec6:	f85a 0026 	ldr.w	r0, [sl, r6, lsl #2]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   18eca:	230c      	movs	r3, #12
   18ecc:	fb03 1106 	mla	r1, r3, r6, r1
   18ed0:	2203      	movs	r2, #3
   18ed2:	f101 0e04 	add.w	lr, r1, #4
   18ed6:	182b      	adds	r3, r5, r0
   18ed8:	60fa      	str	r2, [r7, #12]
	node->prev = list->tail;
   18eda:	688a      	ldr	r2, [r1, #8]
   18edc:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
   18ede:	688a      	ldr	r2, [r1, #8]
	node->next = list;
   18ee0:	f8c3 e000 	str.w	lr, [r3]
	list->tail->next = node;
   18ee4:	6013      	str	r3, [r2, #0]
	for (i = 1; i < 4; i++) {
   18ee6:	68fa      	ldr	r2, [r7, #12]
	list->tail = node;
   18ee8:	608b      	str	r3, [r1, #8]
   18eea:	3a01      	subs	r2, #1
   18eec:	4403      	add	r3, r0
   18eee:	60fa      	str	r2, [r7, #12]
   18ef0:	d1f3      	bne.n	18eda <z_sys_mem_pool_block_alloc+0x126>
				pool_irq_unlock(p, key);
   18ef2:	4641      	mov	r1, r8
   18ef4:	7c20      	ldrb	r0, [r4, #16]
   18ef6:	f7ff ff10 	bl	18d1a <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   18efa:	7c23      	ldrb	r3, [r4, #16]
   18efc:	07d9      	lsls	r1, r3, #31
   18efe:	d503      	bpl.n	18f08 <z_sys_mem_pool_block_alloc+0x154>
   18f00:	f7ff ff02 	bl	18d08 <pool_irq_lock.isra.2.part.3>
				key = pool_irq_lock(p);
   18f04:	4680      	mov	r8, r0
   18f06:	e7af      	b.n	18e68 <z_sys_mem_pool_block_alloc+0xb4>
		return 0;
   18f08:	68f8      	ldr	r0, [r7, #12]
   18f0a:	e7fb      	b.n	18f04 <z_sys_mem_pool_block_alloc+0x150>
	for (i = alloc_l; i >= 0; i--) {
   18f0c:	3e01      	subs	r6, #1
   18f0e:	1c72      	adds	r2, r6, #1
   18f10:	f1a3 030c 	sub.w	r3, r3, #12
   18f14:	d187      	bne.n	18e26 <z_sys_mem_pool_block_alloc+0x72>
   18f16:	2500      	movs	r5, #0
   18f18:	e7a8      	b.n	18e6c <z_sys_mem_pool_block_alloc+0xb8>

00018f1a <z_sys_mem_pool_block_free>:

void z_sys_mem_pool_block_free(struct sys_mem_pool_base *p, u32_t level,
			      u32_t block)
{
   18f1a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18f1e:	b085      	sub	sp, #20
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   18f20:	7a83      	ldrb	r3, [r0, #10]
   18f22:	009b      	lsls	r3, r3, #2
   18f24:	3307      	adds	r3, #7
   18f26:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
{
   18f2a:	af00      	add	r7, sp, #0
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   18f2c:	ebad 0d03 	sub.w	sp, sp, r3
   18f30:	46eb      	mov	fp, sp
	 * to avoid having to store it in precious RAM bytes.
	 * Overhead here is somewhat higher because block_free()
	 * doesn't inherently need to traverse all the larger
	 * sublevels.
	 */
	lsizes[0] = p->max_sz;
   18f32:	6843      	ldr	r3, [r0, #4]
   18f34:	f8cb 3000 	str.w	r3, [fp]
{
   18f38:	4606      	mov	r6, r0
	for (i = 1; i <= level; i++) {
   18f3a:	465c      	mov	r4, fp
   18f3c:	2001      	movs	r0, #1
   18f3e:	4281      	cmp	r1, r0
   18f40:	d215      	bcs.n	18f6e <z_sys_mem_pool_block_free+0x54>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   18f42:	7c30      	ldrb	r0, [r6, #16]
   18f44:	f010 0001 	ands.w	r0, r0, #1
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
	}

	block_free(p, level, lsizes, block);
   18f48:	4688      	mov	r8, r1
   18f4a:	4615      	mov	r5, r2
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   18f4c:	d001      	beq.n	18f52 <z_sys_mem_pool_block_free+0x38>
   18f4e:	f7ff fedb 	bl	18d08 <pool_irq_lock.isra.2.part.3>
	unsigned int key = pool_irq_lock(p);
   18f52:	4604      	mov	r4, r0
	while (level >= 0) {
   18f54:	f1b8 0f00 	cmp.w	r8, #0
   18f58:	da11      	bge.n	18f7e <z_sys_mem_pool_block_free+0x64>
	return -1;
   18f5a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	pool_irq_unlock(p, key);
   18f5e:	4621      	mov	r1, r4
   18f60:	7c30      	ldrb	r0, [r6, #16]
   18f62:	f7ff feda 	bl	18d1a <pool_irq_unlock.isra.4>
}
   18f66:	3714      	adds	r7, #20
   18f68:	46bd      	mov	sp, r7
   18f6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
   18f6e:	6823      	ldr	r3, [r4, #0]
   18f70:	089b      	lsrs	r3, r3, #2
   18f72:	f023 0303 	bic.w	r3, r3, #3
   18f76:	f844 3f04 	str.w	r3, [r4, #4]!
	for (i = 1; i <= level; i++) {
   18f7a:	3001      	adds	r0, #1
   18f7c:	e7df      	b.n	18f3e <z_sys_mem_pool_block_free+0x24>
		int i, lsz = lsizes[level];
   18f7e:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
   18f82:	607b      	str	r3, [r7, #4]
	return (u8_t *)p->buf + lsz * block;
   18f84:	fb03 fa05 	mul.w	sl, r3, r5
   18f88:	6833      	ldr	r3, [r6, #0]
   18f8a:	603b      	str	r3, [r7, #0]
   18f8c:	eb03 090a 	add.w	r9, r3, sl
	int bit = get_bit_ptr(p, level, bn, &word);
   18f90:	462a      	mov	r2, r5
   18f92:	f107 030c 	add.w	r3, r7, #12
   18f96:	4641      	mov	r1, r8
   18f98:	4630      	mov	r0, r6
   18f9a:	f7ff fe9e 	bl	18cda <get_bit_ptr>
	*word &= ~(1<<bit);
   18f9e:	68fa      	ldr	r2, [r7, #12]
	node->next = list;
   18fa0:	6839      	ldr	r1, [r7, #0]
   18fa2:	2301      	movs	r3, #1
   18fa4:	fa03 f000 	lsl.w	r0, r3, r0
   18fa8:	6813      	ldr	r3, [r2, #0]
   18faa:	ea23 0300 	bic.w	r3, r3, r0
   18fae:	6013      	str	r3, [r2, #0]
		sys_dlist_append(&p->levels[level].free_list, block);
   18fb0:	68f3      	ldr	r3, [r6, #12]
   18fb2:	220c      	movs	r2, #12
   18fb4:	fb02 3308 	mla	r3, r2, r8, r3
   18fb8:	1d1a      	adds	r2, r3, #4
   18fba:	f841 200a 	str.w	r2, [r1, sl]
	node->prev = list->tail;
   18fbe:	689a      	ldr	r2, [r3, #8]
   18fc0:	f8c9 2004 	str.w	r2, [r9, #4]
	list->tail->next = node;
   18fc4:	689a      	ldr	r2, [r3, #8]
   18fc6:	f8c2 9000 	str.w	r9, [r2]
	list->tail = node;
   18fca:	f8c3 9008 	str.w	r9, [r3, #8]
		pool_irq_unlock(p, key);
   18fce:	7c30      	ldrb	r0, [r6, #16]
   18fd0:	4621      	mov	r1, r4
   18fd2:	f7ff fea2 	bl	18d1a <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   18fd6:	7c30      	ldrb	r0, [r6, #16]
   18fd8:	f010 0001 	ands.w	r0, r0, #1
   18fdc:	d001      	beq.n	18fe2 <z_sys_mem_pool_block_free+0xc8>
   18fde:	f7ff fe93 	bl	18d08 <pool_irq_lock.isra.2.part.3>
		key = pool_irq_lock(p);
   18fe2:	4604      	mov	r4, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
   18fe4:	f1b8 0f00 	cmp.w	r8, #0
   18fe8:	d0b9      	beq.n	18f5e <z_sys_mem_pool_block_free+0x44>
	int bit = get_bit_ptr(p, level, bn, &word);
   18fea:	f107 030c 	add.w	r3, r7, #12
   18fee:	462a      	mov	r2, r5
   18ff0:	4641      	mov	r1, r8
   18ff2:	4630      	mov	r0, r6
   18ff4:	f7ff fe71 	bl	18cda <get_bit_ptr>
	return (*word >> (4*(bit / 4))) & 0xf;
   18ff8:	68fb      	ldr	r3, [r7, #12]
   18ffa:	2800      	cmp	r0, #0
   18ffc:	bfb8      	it	lt
   18ffe:	3003      	addlt	r0, #3
   19000:	681b      	ldr	r3, [r3, #0]
   19002:	f020 0003 	bic.w	r0, r0, #3
   19006:	fa23 f000 	lsr.w	r0, r3, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
   1900a:	f010 000f 	ands.w	r0, r0, #15
   1900e:	d1a6      	bne.n	18f5e <z_sys_mem_pool_block_free+0x44>
			int b = (bn & ~3) + i;
   19010:	f025 0a03 	bic.w	sl, r5, #3
	node->next = NULL;
   19014:	4684      	mov	ip, r0
	return (u8_t *)p->buf + lsz * block;
   19016:	687a      	ldr	r2, [r7, #4]
			int b = (bn & ~3) + i;
   19018:	eb0a 0300 	add.w	r3, sl, r0
	return (u8_t *)p->buf + lsz * block;
   1901c:	4353      	muls	r3, r2
   1901e:	6832      	ldr	r2, [r6, #0]
   19020:	18d1      	adds	r1, r2, r3
	node->prev->next = node->next;
   19022:	f852 e003 	ldr.w	lr, [r2, r3]
   19026:	f8d1 9004 	ldr.w	r9, [r1, #4]
		for (i = 0; i < 4; i++) {
   1902a:	3001      	adds	r0, #1
   1902c:	2804      	cmp	r0, #4
   1902e:	f8c9 e000 	str.w	lr, [r9]
	node->next->prev = node->prev;
   19032:	f8ce 9004 	str.w	r9, [lr, #4]
	node->next = NULL;
   19036:	f842 c003 	str.w	ip, [r2, r3]
	node->prev = NULL;
   1903a:	f8c1 c004 	str.w	ip, [r1, #4]
   1903e:	d1ea      	bne.n	19016 <z_sys_mem_pool_block_free+0xfc>
		bn = bn / 4;
   19040:	2d00      	cmp	r5, #0
   19042:	bfb8      	it	lt
   19044:	3503      	addlt	r5, #3
		level = level - 1;
   19046:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
		bn = bn / 4;
   1904a:	10ad      	asrs	r5, r5, #2
   1904c:	e782      	b.n	18f54 <z_sys_mem_pool_block_free+0x3a>

0001904e <arch_printk_char_out>:
}
   1904e:	2000      	movs	r0, #0
   19050:	4770      	bx	lr

00019052 <print_err>:
{
   19052:	b570      	push	{r4, r5, r6, lr}
   19054:	4604      	mov	r4, r0
   19056:	460d      	mov	r5, r1
	out('E', ctx);
   19058:	2045      	movs	r0, #69	; 0x45
   1905a:	47a0      	blx	r4
	out('R', ctx);
   1905c:	4629      	mov	r1, r5
   1905e:	2052      	movs	r0, #82	; 0x52
   19060:	47a0      	blx	r4
	out('R', ctx);
   19062:	4629      	mov	r1, r5
   19064:	4623      	mov	r3, r4
   19066:	2052      	movs	r0, #82	; 0x52
}
   19068:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
   1906c:	4718      	bx	r3

0001906e <str_out>:
{
   1906e:	b530      	push	{r4, r5, lr}
   19070:	688a      	ldr	r2, [r1, #8]
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   19072:	680c      	ldr	r4, [r1, #0]
   19074:	1c55      	adds	r5, r2, #1
   19076:	b114      	cbz	r4, 1907e <str_out+0x10>
   19078:	684b      	ldr	r3, [r1, #4]
   1907a:	4293      	cmp	r3, r2
   1907c:	dc01      	bgt.n	19082 <str_out+0x14>
		ctx->count++;
   1907e:	608d      	str	r5, [r1, #8]
}
   19080:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
   19082:	3b01      	subs	r3, #1
   19084:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
   19086:	bf08      	it	eq
   19088:	2200      	moveq	r2, #0
   1908a:	608d      	str	r5, [r1, #8]
   1908c:	bf0c      	ite	eq
   1908e:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
   19090:	54a0      	strbne	r0, [r4, r2]
   19092:	e7f5      	b.n	19080 <str_out+0x12>

00019094 <z_vprintk>:
{
   19094:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19098:	b08b      	sub	sp, #44	; 0x2c
   1909a:	461c      	mov	r4, r3
	char length_mod = 0;
   1909c:	f04f 0800 	mov.w	r8, #0
   190a0:	1e53      	subs	r3, r2, #1
{
   190a2:	4606      	mov	r6, r0
   190a4:	460f      	mov	r7, r1
   190a6:	9302      	str	r3, [sp, #8]
	int min_width = -1;
   190a8:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
	enum pad_type padding = PAD_NONE;
   190ac:	46c1      	mov	r9, r8
			might_format = 0;
   190ae:	2500      	movs	r5, #0
					break;
   190b0:	e005      	b.n	190be <z_vprintk+0x2a>
		if (!might_format) {
   190b2:	b96d      	cbnz	r5, 190d0 <z_vprintk+0x3c>
			if (*fmt != '%') {
   190b4:	2825      	cmp	r0, #37	; 0x25
   190b6:	f000 814f 	beq.w	19358 <z_vprintk+0x2c4>
				out((int)*fmt, ctx);
   190ba:	4639      	mov	r1, r7
   190bc:	47b0      	blx	r6
	while (*fmt) {
   190be:	9b02      	ldr	r3, [sp, #8]
   190c0:	f813 0f01 	ldrb.w	r0, [r3, #1]!
   190c4:	9302      	str	r3, [sp, #8]
   190c6:	2800      	cmp	r0, #0
   190c8:	d1f3      	bne.n	190b2 <z_vprintk+0x1e>
}
   190ca:	b00b      	add	sp, #44	; 0x2c
   190cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			switch (*fmt) {
   190d0:	2864      	cmp	r0, #100	; 0x64
   190d2:	d06e      	beq.n	191b2 <z_vprintk+0x11e>
   190d4:	d81a      	bhi.n	1910c <z_vprintk+0x78>
   190d6:	2839      	cmp	r0, #57	; 0x39
   190d8:	d80a      	bhi.n	190f0 <z_vprintk+0x5c>
   190da:	2831      	cmp	r0, #49	; 0x31
   190dc:	d260      	bcs.n	191a0 <z_vprintk+0x10c>
   190de:	282d      	cmp	r0, #45	; 0x2d
   190e0:	f000 8140 	beq.w	19364 <z_vprintk+0x2d0>
   190e4:	2830      	cmp	r0, #48	; 0x30
   190e6:	d04c      	beq.n	19182 <z_vprintk+0xee>
   190e8:	2825      	cmp	r0, #37	; 0x25
   190ea:	d107      	bne.n	190fc <z_vprintk+0x68>
				out((int)'%', ctx);
   190ec:	4639      	mov	r1, r7
   190ee:	e00b      	b.n	19108 <z_vprintk+0x74>
			switch (*fmt) {
   190f0:	2858      	cmp	r0, #88	; 0x58
   190f2:	f000 80bb 	beq.w	1926c <z_vprintk+0x1d8>
   190f6:	2863      	cmp	r0, #99	; 0x63
   190f8:	f000 812a 	beq.w	19350 <z_vprintk+0x2bc>
					out((int)'%', ctx);
   190fc:	4639      	mov	r1, r7
   190fe:	2025      	movs	r0, #37	; 0x25
   19100:	47b0      	blx	r6
					out((int)*fmt, ctx);
   19102:	9b02      	ldr	r3, [sp, #8]
   19104:	7818      	ldrb	r0, [r3, #0]
   19106:	4639      	mov	r1, r7
   19108:	47b0      	blx	r6
   1910a:	e7d0      	b.n	190ae <z_vprintk+0x1a>
			switch (*fmt) {
   1910c:	2870      	cmp	r0, #112	; 0x70
   1910e:	f000 80a3 	beq.w	19258 <z_vprintk+0x1c4>
   19112:	d811      	bhi.n	19138 <z_vprintk+0xa4>
   19114:	2869      	cmp	r0, #105	; 0x69
   19116:	d04c      	beq.n	191b2 <z_vprintk+0x11e>
   19118:	286c      	cmp	r0, #108	; 0x6c
   1911a:	d105      	bne.n	19128 <z_vprintk+0x94>
				} else if (*fmt == 'l' && length_mod == 'l') {
   1911c:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   19120:	d12a      	bne.n	19178 <z_vprintk+0xe4>
					length_mod = 'L';
   19122:	f04f 084c 	mov.w	r8, #76	; 0x4c
   19126:	e7ca      	b.n	190be <z_vprintk+0x2a>
			switch (*fmt) {
   19128:	2868      	cmp	r0, #104	; 0x68
   1912a:	d1e7      	bne.n	190fc <z_vprintk+0x68>
				if (*fmt == 'h' && length_mod == 'h') {
   1912c:	f1b8 0f68 	cmp.w	r8, #104	; 0x68
   19130:	d122      	bne.n	19178 <z_vprintk+0xe4>
					length_mod = 'H';
   19132:	f04f 0848 	mov.w	r8, #72	; 0x48
   19136:	e7c2      	b.n	190be <z_vprintk+0x2a>
			switch (*fmt) {
   19138:	2875      	cmp	r0, #117	; 0x75
   1913a:	d071      	beq.n	19220 <z_vprintk+0x18c>
   1913c:	d818      	bhi.n	19170 <z_vprintk+0xdc>
   1913e:	2873      	cmp	r0, #115	; 0x73
   19140:	d1dc      	bne.n	190fc <z_vprintk+0x68>
				char *s = va_arg(ap, char *);
   19142:	f854 5b04 	ldr.w	r5, [r4], #4
				while (*s) {
   19146:	46ab      	mov	fp, r5
   19148:	465b      	mov	r3, fp
   1914a:	f81b 0b01 	ldrb.w	r0, [fp], #1
   1914e:	2800      	cmp	r0, #0
   19150:	f040 80fb 	bne.w	1934a <z_vprintk+0x2b6>
				if (padding == PAD_SPACE_AFTER) {
   19154:	f1b9 0f03 	cmp.w	r9, #3
   19158:	f040 810a 	bne.w	19370 <z_vprintk+0x2dc>
					int remaining = min_width - (s - start);
   1915c:	1b5d      	subs	r5, r3, r5
   1915e:	ebaa 0505 	sub.w	r5, sl, r5
					while (remaining-- > 0) {
   19162:	2d00      	cmp	r5, #0
   19164:	dda3      	ble.n	190ae <z_vprintk+0x1a>
						out(' ', ctx);
   19166:	4639      	mov	r1, r7
   19168:	2020      	movs	r0, #32
   1916a:	47b0      	blx	r6
   1916c:	3d01      	subs	r5, #1
   1916e:	e7f8      	b.n	19162 <z_vprintk+0xce>
			switch (*fmt) {
   19170:	2878      	cmp	r0, #120	; 0x78
   19172:	d07b      	beq.n	1926c <z_vprintk+0x1d8>
   19174:	287a      	cmp	r0, #122	; 0x7a
   19176:	d1c1      	bne.n	190fc <z_vprintk+0x68>
				} else if (length_mod == 0) {
   19178:	f1b8 0f00 	cmp.w	r8, #0
   1917c:	d1be      	bne.n	190fc <z_vprintk+0x68>
   1917e:	4680      	mov	r8, r0
   19180:	e79d      	b.n	190be <z_vprintk+0x2a>
				if (min_width < 0 && padding == PAD_NONE) {
   19182:	f1ba 0f00 	cmp.w	sl, #0
   19186:	da0e      	bge.n	191a6 <z_vprintk+0x112>
   19188:	f1b9 0f00 	cmp.w	r9, #0
   1918c:	f000 80ed 	beq.w	1936a <z_vprintk+0x2d6>
					min_width = *fmt - '0';
   19190:	f1a0 0a30 	sub.w	sl, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
   19194:	f1b9 0f00 	cmp.w	r9, #0
   19198:	bf08      	it	eq
   1919a:	f04f 0902 	moveq.w	r9, #2
   1919e:	e78e      	b.n	190be <z_vprintk+0x2a>
				if (min_width < 0) {
   191a0:	f1ba 0f00 	cmp.w	sl, #0
   191a4:	dbf4      	blt.n	19190 <z_vprintk+0xfc>
					min_width = 10 * min_width + *fmt - '0';
   191a6:	230a      	movs	r3, #10
   191a8:	fb03 0a0a 	mla	sl, r3, sl, r0
   191ac:	f1aa 0a30 	sub.w	sl, sl, #48	; 0x30
   191b0:	e7f0      	b.n	19194 <z_vprintk+0x100>
				if (length_mod == 'z') {
   191b2:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
   191b6:	d102      	bne.n	191be <z_vprintk+0x12a>
					d = va_arg(ap, int);
   191b8:	f854 5b04 	ldr.w	r5, [r4], #4
   191bc:	e01f      	b.n	191fe <z_vprintk+0x16a>
				} else if (length_mod == 'l') {
   191be:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   191c2:	d0f9      	beq.n	191b8 <z_vprintk+0x124>
				} else if (length_mod == 'L') {
   191c4:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   191c8:	d1f6      	bne.n	191b8 <z_vprintk+0x124>
					long long lld = va_arg(ap, long long);
   191ca:	3407      	adds	r4, #7
   191cc:	f024 0407 	bic.w	r4, r4, #7
   191d0:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (lld > __LONG_MAX__ ||
   191d4:	f112 4100 	adds.w	r1, r2, #2147483648	; 0x80000000
   191d8:	9106      	str	r1, [sp, #24]
   191da:	f143 0100 	adc.w	r1, r3, #0
   191de:	9107      	str	r1, [sp, #28]
   191e0:	e9dd bc06 	ldrd	fp, ip, [sp, #24]
   191e4:	2100      	movs	r1, #0
   191e6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   191ea:	4561      	cmp	r1, ip
   191ec:	bf08      	it	eq
   191ee:	4558      	cmpeq	r0, fp
   191f0:	d204      	bcs.n	191fc <z_vprintk+0x168>
						print_err(out, ctx);
   191f2:	4639      	mov	r1, r7
   191f4:	4630      	mov	r0, r6
   191f6:	f7ff ff2c 	bl	19052 <print_err>
						break;
   191fa:	e758      	b.n	190ae <z_vprintk+0x1a>
					d = lld;
   191fc:	4615      	mov	r5, r2
				if (d < 0) {
   191fe:	2d00      	cmp	r5, #0
   19200:	da05      	bge.n	1920e <z_vprintk+0x17a>
					out((int)'-', ctx);
   19202:	4639      	mov	r1, r7
   19204:	202d      	movs	r0, #45	; 0x2d
   19206:	47b0      	blx	r6
					d = -d;
   19208:	426d      	negs	r5, r5
					min_width--;
   1920a:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
				_printk_dec_ulong(out, ctx, d, padding,
   1920e:	f8cd a000 	str.w	sl, [sp]
   19212:	464b      	mov	r3, r9
   19214:	462a      	mov	r2, r5
				_printk_dec_ulong(out, ctx, u, padding,
   19216:	4639      	mov	r1, r7
   19218:	4630      	mov	r0, r6
   1921a:	f7e9 fb65 	bl	28e8 <_printk_dec_ulong>
				break;
   1921e:	e746      	b.n	190ae <z_vprintk+0x1a>
				if (length_mod == 'z') {
   19220:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
   19224:	d102      	bne.n	1922c <z_vprintk+0x198>
					u = va_arg(ap, unsigned int);
   19226:	f854 2b04 	ldr.w	r2, [r4], #4
   1922a:	e011      	b.n	19250 <z_vprintk+0x1bc>
				} else if (length_mod == 'l') {
   1922c:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   19230:	d0f9      	beq.n	19226 <z_vprintk+0x192>
				} else if (length_mod == 'L') {
   19232:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   19236:	d1f6      	bne.n	19226 <z_vprintk+0x192>
					unsigned long long llu =
   19238:	3407      	adds	r4, #7
   1923a:	f024 0407 	bic.w	r4, r4, #7
   1923e:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (llu > ~0UL) {
   19242:	2100      	movs	r1, #0
   19244:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   19248:	4299      	cmp	r1, r3
   1924a:	bf08      	it	eq
   1924c:	4290      	cmpeq	r0, r2
   1924e:	d3d0      	bcc.n	191f2 <z_vprintk+0x15e>
				_printk_dec_ulong(out, ctx, u, padding,
   19250:	f8cd a000 	str.w	sl, [sp]
   19254:	464b      	mov	r3, r9
   19256:	e7de      	b.n	19216 <z_vprintk+0x182>
				out('0', ctx);
   19258:	4639      	mov	r1, r7
   1925a:	2030      	movs	r0, #48	; 0x30
   1925c:	47b0      	blx	r6
				out('x', ctx);
   1925e:	4639      	mov	r1, r7
   19260:	2078      	movs	r0, #120	; 0x78
   19262:	47b0      	blx	r6
					min_width = 8;
   19264:	f04f 0a08 	mov.w	sl, #8
				padding = PAD_ZERO_BEFORE;
   19268:	f04f 0901 	mov.w	r9, #1
				if (*fmt == 'p') {
   1926c:	9b02      	ldr	r3, [sp, #8]
   1926e:	781b      	ldrb	r3, [r3, #0]
   19270:	2b70      	cmp	r3, #112	; 0x70
   19272:	d104      	bne.n	1927e <z_vprintk+0x1ea>
					x = va_arg(ap, unsigned int);
   19274:	f854 3b04 	ldr.w	r3, [r4], #4
   19278:	9304      	str	r3, [sp, #16]
   1927a:	2300      	movs	r3, #0
   1927c:	e00d      	b.n	1929a <z_vprintk+0x206>
				} else if (length_mod == 'l') {
   1927e:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   19282:	d0f7      	beq.n	19274 <z_vprintk+0x1e0>
				} else if (length_mod == 'L') {
   19284:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   19288:	d1f4      	bne.n	19274 <z_vprintk+0x1e0>
					x = va_arg(ap, unsigned long long);
   1928a:	3407      	adds	r4, #7
   1928c:	f024 0307 	bic.w	r3, r4, #7
   19290:	461c      	mov	r4, r3
   19292:	685b      	ldr	r3, [r3, #4]
   19294:	f854 2b08 	ldr.w	r2, [r4], #8
   19298:	9204      	str	r2, [sp, #16]
	int digits = 0;
   1929a:	2100      	movs	r1, #0
	int remaining = 16; /* 16 digits max */
   1929c:	2210      	movs	r2, #16
	int digits = 0;
   1929e:	9103      	str	r1, [sp, #12]
	int found_largest_digit = 0;
   192a0:	9105      	str	r1, [sp, #20]
	int shift = sizeof(num) * 8;
   192a2:	f04f 0b40 	mov.w	fp, #64	; 0x40
		shift -= 4;
   192a6:	f1ab 0b04 	sub.w	fp, fp, #4
		nibble = (num >> shift) & 0xf;
   192aa:	9804      	ldr	r0, [sp, #16]
   192ac:	f1cb 0c20 	rsb	ip, fp, #32
   192b0:	f1ab 0120 	sub.w	r1, fp, #32
   192b4:	fa20 f00b 	lsr.w	r0, r0, fp
   192b8:	fa03 fc0c 	lsl.w	ip, r3, ip
   192bc:	ea40 000c 	orr.w	r0, r0, ip
   192c0:	fa23 f101 	lsr.w	r1, r3, r1
   192c4:	4308      	orrs	r0, r1
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
   192c6:	f010 000f 	ands.w	r0, r0, #15
   192ca:	d108      	bne.n	192de <z_vprintk+0x24a>
   192cc:	9905      	ldr	r1, [sp, #20]
   192ce:	b911      	cbnz	r1, 192d6 <z_vprintk+0x242>
   192d0:	f1bb 0f00 	cmp.w	fp, #0
   192d4:	d124      	bne.n	19320 <z_vprintk+0x28c>
			nibble += nibble > 9 ? 87 : 48;
   192d6:	2130      	movs	r1, #48	; 0x30
   192d8:	e005      	b.n	192e6 <z_vprintk+0x252>
			found_largest_digit = 1;
   192da:	9505      	str	r5, [sp, #20]
   192dc:	e7e3      	b.n	192a6 <z_vprintk+0x212>
			nibble += nibble > 9 ? 87 : 48;
   192de:	2809      	cmp	r0, #9
   192e0:	bf8c      	ite	hi
   192e2:	2157      	movhi	r1, #87	; 0x57
   192e4:	2130      	movls	r1, #48	; 0x30
   192e6:	4408      	add	r0, r1
			out((int)nibble, ctx);
   192e8:	b240      	sxtb	r0, r0
   192ea:	4639      	mov	r1, r7
   192ec:	9308      	str	r3, [sp, #32]
   192ee:	9205      	str	r2, [sp, #20]
   192f0:	47b0      	blx	r6
			digits++;
   192f2:	9b03      	ldr	r3, [sp, #12]
	while (shift >= 4) {
   192f4:	9a05      	ldr	r2, [sp, #20]
			digits++;
   192f6:	3301      	adds	r3, #1
   192f8:	9303      	str	r3, [sp, #12]
	while (shift >= 4) {
   192fa:	9b08      	ldr	r3, [sp, #32]
   192fc:	f1bb 0f00 	cmp.w	fp, #0
   19300:	d1eb      	bne.n	192da <z_vprintk+0x246>
	if (padding == PAD_SPACE_AFTER) {
   19302:	f1b9 0f03 	cmp.w	r9, #3
   19306:	f47f aed2 	bne.w	190ae <z_vprintk+0x1a>
		remaining = min_width * 2 - digits;
   1930a:	9b03      	ldr	r3, [sp, #12]
   1930c:	ebc3 054a 	rsb	r5, r3, sl, lsl #1
		while (remaining-- > 0) {
   19310:	2d00      	cmp	r5, #0
   19312:	f77f aecc 	ble.w	190ae <z_vprintk+0x1a>
			out(' ', ctx);
   19316:	4639      	mov	r1, r7
   19318:	2020      	movs	r0, #32
   1931a:	47b0      	blx	r6
   1931c:	3d01      	subs	r5, #1
   1931e:	e7f7      	b.n	19310 <z_vprintk+0x27c>
		if (remaining-- <= min_width) {
   19320:	1e51      	subs	r1, r2, #1
   19322:	4592      	cmp	sl, r2
   19324:	9108      	str	r1, [sp, #32]
   19326:	db07      	blt.n	19338 <z_vprintk+0x2a4>
			if (padding == PAD_ZERO_BEFORE) {
   19328:	f1b9 0f01 	cmp.w	r9, #1
   1932c:	d106      	bne.n	1933c <z_vprintk+0x2a8>
   1932e:	9309      	str	r3, [sp, #36]	; 0x24
				out('0', ctx);
   19330:	4639      	mov	r1, r7
   19332:	2030      	movs	r0, #48	; 0x30
				out(' ', ctx);
   19334:	47b0      	blx	r6
   19336:	9b09      	ldr	r3, [sp, #36]	; 0x24
					x = va_arg(ap, unsigned int);
   19338:	9a08      	ldr	r2, [sp, #32]
   1933a:	e7b4      	b.n	192a6 <z_vprintk+0x212>
			} else if (padding == PAD_SPACE_BEFORE) {
   1933c:	f1b9 0f02 	cmp.w	r9, #2
   19340:	d1fa      	bne.n	19338 <z_vprintk+0x2a4>
   19342:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
   19344:	4639      	mov	r1, r7
   19346:	2020      	movs	r0, #32
   19348:	e7f4      	b.n	19334 <z_vprintk+0x2a0>
					out((int)(*s++), ctx);
   1934a:	4639      	mov	r1, r7
   1934c:	47b0      	blx	r6
   1934e:	e6fb      	b.n	19148 <z_vprintk+0xb4>
				out(c, ctx);
   19350:	4639      	mov	r1, r7
   19352:	f854 0b04 	ldr.w	r0, [r4], #4
   19356:	e6d7      	b.n	19108 <z_vprintk+0x74>
				length_mod = 0;
   19358:	46a8      	mov	r8, r5
				padding = PAD_NONE;
   1935a:	46a9      	mov	r9, r5
				min_width = -1;
   1935c:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
				might_format = 1;
   19360:	2501      	movs	r5, #1
   19362:	e6ac      	b.n	190be <z_vprintk+0x2a>
				padding = PAD_SPACE_AFTER;
   19364:	f04f 0903 	mov.w	r9, #3
   19368:	e6a9      	b.n	190be <z_vprintk+0x2a>
					padding = PAD_ZERO_BEFORE;
   1936a:	f04f 0901 	mov.w	r9, #1
   1936e:	e6a6      	b.n	190be <z_vprintk+0x2a>
			might_format = 0;
   19370:	4605      	mov	r5, r0
		++fmt;
   19372:	e6a4      	b.n	190be <z_vprintk+0x2a>

00019374 <printk>:
{
   19374:	b40f      	push	{r0, r1, r2, r3}
   19376:	b507      	push	{r0, r1, r2, lr}
   19378:	a904      	add	r1, sp, #16
   1937a:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   1937e:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
   19380:	f7e9 fafe 	bl	2980 <vprintk>
}
   19384:	b003      	add	sp, #12
   19386:	f85d eb04 	ldr.w	lr, [sp], #4
   1938a:	b004      	add	sp, #16
   1938c:	4770      	bx	lr

0001938e <snprintk>:
{
   1938e:	b40c      	push	{r2, r3}
   19390:	b507      	push	{r0, r1, r2, lr}
   19392:	ab04      	add	r3, sp, #16
   19394:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
   19398:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
   1939a:	f7e9 faff 	bl	299c <vsnprintk>
}
   1939e:	b003      	add	sp, #12
   193a0:	f85d eb04 	ldr.w	lr, [sp], #4
   193a4:	b002      	add	sp, #8
   193a6:	4770      	bx	lr

000193a8 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   193a8:	4604      	mov	r4, r0
   193aa:	b508      	push	{r3, lr}
   193ac:	4608      	mov	r0, r1
   193ae:	4611      	mov	r1, r2
	entry(p1, p2, p3);
   193b0:	461a      	mov	r2, r3
   193b2:	47a0      	blx	r4
	return z_impl_k_current_get();
   193b4:	f7ff f860 	bl	18478 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
   193b8:	f7eb fbbc 	bl	4b34 <z_impl_k_thread_abort>

000193bc <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
   193bc:	b510      	push	{r4, lr}
   193be:	4604      	mov	r4, r0
	return z_impl_k_queue_get(queue, timeout);
   193c0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   193c4:	4620      	mov	r0, r4
   193c6:	f004 ffea 	bl	1e39e <z_impl_k_queue_get>
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
   193ca:	4603      	mov	r3, r0
   193cc:	2800      	cmp	r0, #0
   193ce:	d0f7      	beq.n	193c0 <z_work_q_main+0x4>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   193d0:	3308      	adds	r3, #8
			continue;
		}

		handler = work->handler;
   193d2:	6842      	ldr	r2, [r0, #4]
   193d4:	f3bf 8f5b 	dmb	ish
   193d8:	e853 1f00 	ldrex	r1, [r3]
   193dc:	f021 0c01 	bic.w	ip, r1, #1
   193e0:	e843 ce00 	strex	lr, ip, [r3]
   193e4:	f1be 0f00 	cmp.w	lr, #0
   193e8:	d1f6      	bne.n	193d8 <z_work_q_main+0x1c>
   193ea:	f3bf 8f5b 	dmb	ish

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
   193ee:	07cb      	lsls	r3, r1, #31
   193f0:	d500      	bpl.n	193f4 <z_work_q_main+0x38>
					      K_WORK_STATE_PENDING)) {
			handler(work);
   193f2:	4790      	blx	r2
	z_impl_k_yield();
   193f4:	f7fe ffcc 	bl	18390 <z_impl_k_yield>
   193f8:	e7e2      	b.n	193c0 <z_work_q_main+0x4>

000193fa <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   193fa:	4770      	bx	lr

000193fc <_copy>:
#define MASK_TWENTY_SEVEN 0x1b

unsigned int _copy(uint8_t *to, unsigned int to_len,
		   const uint8_t *from, unsigned int from_len)
{
	if (from_len <= to_len) {
   193fc:	428b      	cmp	r3, r1
{
   193fe:	b538      	push	{r3, r4, r5, lr}
   19400:	4615      	mov	r5, r2
   19402:	461c      	mov	r4, r3
	if (from_len <= to_len) {
   19404:	d805      	bhi.n	19412 <_copy+0x16>
		(void)memcpy(to, from, from_len);
   19406:	461a      	mov	r2, r3
   19408:	4629      	mov	r1, r5
   1940a:	f001 fdf6 	bl	1affa <memcpy>
		return from_len;
	} else {
		return TC_CRYPTO_FAIL;
	}
}
   1940e:	4620      	mov	r0, r4
   19410:	bd38      	pop	{r3, r4, r5, pc}
		return TC_CRYPTO_FAIL;
   19412:	2400      	movs	r4, #0
   19414:	e7fb      	b.n	1940e <_copy+0x12>

00019416 <_set>:

void _set(void *to, uint8_t val, unsigned int len)
{
	(void)memset(to, val, len);
   19416:	f001 be1a 	b.w	1b04e <memset>

0001941a <_double_byte>:
/*
 * Doubles the value of a byte for values up to 127.
 */
uint8_t _double_byte(uint8_t a)
{
	return ((a<<1) ^ ((a>>7) * MASK_TWENTY_SEVEN));
   1941a:	09c3      	lsrs	r3, r0, #7
   1941c:	005a      	lsls	r2, r3, #1
   1941e:	4413      	add	r3, r2
   19420:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
   19424:	ea83 0040 	eor.w	r0, r3, r0, lsl #1
}
   19428:	b2c0      	uxtb	r0, r0
   1942a:	4770      	bx	lr

0001942c <uECC_make_key>:
	}
	return 0;
}

int uECC_make_key(uint8_t *public_key, uint8_t *private_key, uECC_Curve curve)
{
   1942c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   19430:	4607      	mov	r7, r0
   19432:	b0a9      	sub	sp, #164	; 0xa4
   19434:	4688      	mov	r8, r1
   19436:	4614      	mov	r4, r2
   19438:	2640      	movs	r6, #64	; 0x40
			!rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE)) {
        		return 0;
		}

		/* computing modular reduction of _random (see FIPS 186.4 B.4.1): */
		uECC_vli_mmod(_private, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
   1943a:	f102 0924 	add.w	r9, r2, #36	; 0x24
		uECC_RNG_Function rng_function = uECC_get_rng();
   1943e:	f7e9 fac1 	bl	29c4 <uECC_get_rng>
		if (!rng_function ||
   19442:	4603      	mov	r3, r0
   19444:	2800      	cmp	r0, #0
   19446:	d03e      	beq.n	194c6 <uECC_make_key+0x9a>
			!rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE)) {
   19448:	2140      	movs	r1, #64	; 0x40
   1944a:	a808      	add	r0, sp, #32
   1944c:	4798      	blx	r3
		if (!rng_function ||
   1944e:	b3d0      	cbz	r0, 194c6 <uECC_make_key+0x9a>
		uECC_vli_mmod(_private, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
   19450:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
   19454:	f112 031f 	adds.w	r3, r2, #31
   19458:	bf48      	it	mi
   1945a:	f102 033e 	addmi.w	r3, r2, #62	; 0x3e
   1945e:	466d      	mov	r5, sp
   19460:	464a      	mov	r2, r9
   19462:	a908      	add	r1, sp, #32
   19464:	4628      	mov	r0, r5
   19466:	f343 1347 	sbfx	r3, r3, #5, #8
   1946a:	f000 fa00 	bl	1986e <uECC_vli_mmod>

		/* Computing public-key from private: */
		if (EccPoint_compute_public_key(_public, _private, curve)) {
   1946e:	4622      	mov	r2, r4
   19470:	4629      	mov	r1, r5
   19472:	a818      	add	r0, sp, #96	; 0x60
   19474:	f000 fe16 	bl	1a0a4 <EccPoint_compute_public_key>
   19478:	b318      	cbz	r0, 194c2 <uECC_make_key+0x96>

			/* Converting buffers to correct bit order: */
			uECC_vli_nativeToBytes(private_key,
					       BITS_TO_BYTES(curve->num_n_bits),
   1947a:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
			uECC_vli_nativeToBytes(private_key,
   1947e:	1dd9      	adds	r1, r3, #7
   19480:	bf48      	it	mi
   19482:	f103 010e 	addmi.w	r1, r3, #14
   19486:	462a      	mov	r2, r5
   19488:	4640      	mov	r0, r8
   1948a:	10c9      	asrs	r1, r1, #3
   1948c:	f000 fe32 	bl	1a0f4 <uECC_vli_nativeToBytes>
					       _private);
			uECC_vli_nativeToBytes(public_key,
   19490:	aa18      	add	r2, sp, #96	; 0x60
   19492:	f994 1001 	ldrsb.w	r1, [r4, #1]
   19496:	4638      	mov	r0, r7
   19498:	f000 fe2c 	bl	1a0f4 <uECC_vli_nativeToBytes>
					       curve->num_bytes,
					       _public);
			uECC_vli_nativeToBytes(public_key + curve->num_bytes,
   1949c:	f994 1001 	ldrsb.w	r1, [r4, #1]
 					       curve->num_bytes,
					       _public + curve->num_words);
   194a0:	f994 2000 	ldrsb.w	r2, [r4]
			uECC_vli_nativeToBytes(public_key + curve->num_bytes,
   194a4:	ab18      	add	r3, sp, #96	; 0x60
   194a6:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   194aa:	1878      	adds	r0, r7, r1
   194ac:	f000 fe22 	bl	1a0f4 <uECC_vli_nativeToBytes>
#ifdef TINYCRYPT_ARCH_HAS_SET_SECURE
extern void _set_secure(void *to, uint8_t val, unsigned int len);
#else /* ! TINYCRYPT_ARCH_HAS_SET_SECURE */
static inline void _set_secure(void *to, uint8_t val, unsigned int len)
{
  (void) memset(to, val, len);
   194b0:	2220      	movs	r2, #32
   194b2:	2100      	movs	r1, #0
   194b4:	4628      	mov	r0, r5
   194b6:	f001 fdca 	bl	1b04e <memset>

			/* erasing temporary buffer that stored secret: */
			_set_secure(_private, 0, NUM_ECC_BYTES);

      			return 1;
   194ba:	2001      	movs	r0, #1
    		}
  	}
	return 0;
}
   194bc:	b029      	add	sp, #164	; 0xa4
   194be:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
   194c2:	3e01      	subs	r6, #1
   194c4:	d1bb      	bne.n	1943e <uECC_make_key+0x12>
        		return 0;
   194c6:	2000      	movs	r0, #0
   194c8:	e7f8      	b.n	194bc <uECC_make_key+0x90>

000194ca <uECC_shared_secret>:

int uECC_shared_secret(const uint8_t *public_key, const uint8_t *private_key,
		       uint8_t *secret, uECC_Curve curve)
{
   194ca:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   194ce:	461c      	mov	r4, r3
	uECC_word_t tmp[NUM_ECC_WORDS];
	uECC_word_t *p2[2] = {_private, tmp};
	uECC_word_t *initial_Z = 0;
	uECC_word_t carry;
	wordcount_t num_words = curve->num_words;
	wordcount_t num_bytes = curve->num_bytes;
   194d0:	f993 7001 	ldrsb.w	r7, [r3, #1]
	wordcount_t num_words = curve->num_words;
   194d4:	f993 a000 	ldrsb.w	sl, [r3]
	int r;

	/* Converting buffers to correct bit order: */
	uECC_vli_bytesToNative(_private,
      			       private_key,
			       BITS_TO_BYTES(curve->num_n_bits));
   194d8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
{
   194dc:	b0a4      	sub	sp, #144	; 0x90
   194de:	4690      	mov	r8, r2
	uECC_vli_bytesToNative(_private,
   194e0:	1dda      	adds	r2, r3, #7
   194e2:	bf48      	it	mi
   194e4:	f103 020e 	addmi.w	r2, r3, #14
	uECC_word_t *p2[2] = {_private, tmp};
   194e8:	ad04      	add	r5, sp, #16
{
   194ea:	4681      	mov	r9, r0
	uECC_word_t *p2[2] = {_private, tmp};
   194ec:	ae0c      	add	r6, sp, #48	; 0x30
	uECC_vli_bytesToNative(_private,
   194ee:	4628      	mov	r0, r5
   194f0:	10d2      	asrs	r2, r2, #3
	uECC_word_t *p2[2] = {_private, tmp};
   194f2:	9502      	str	r5, [sp, #8]
   194f4:	9603      	str	r6, [sp, #12]
	uECC_vli_bytesToNative(_private,
   194f6:	f000 fe11 	bl	1a11c <uECC_vli_bytesToNative>
	uECC_vli_bytesToNative(_public,
   194fa:	463a      	mov	r2, r7
   194fc:	4649      	mov	r1, r9
   194fe:	a814      	add	r0, sp, #80	; 0x50
   19500:	f000 fe0c 	bl	1a11c <uECC_vli_bytesToNative>
      			       public_key,
			       num_bytes);
	uECC_vli_bytesToNative(_public + num_words,
   19504:	ab14      	add	r3, sp, #80	; 0x50
   19506:	eb09 0107 	add.w	r1, r9, r7
   1950a:	eb03 008a 	add.w	r0, r3, sl, lsl #2
   1950e:	463a      	mov	r2, r7
   19510:	f000 fe04 	bl	1a11c <uECC_vli_bytesToNative>
			       public_key + num_bytes,
			       num_bytes);

	/* Regularize the bitcount for the private key so that attackers cannot use a
	 * side channel attack to learn the number of leading zeros. */
	carry = regularize_k(_private, _private, tmp, curve);
   19514:	4623      	mov	r3, r4
   19516:	4632      	mov	r2, r6
   19518:	4629      	mov	r1, r5
   1951a:	4628      	mov	r0, r5
   1951c:	f000 fd95 	bl	1a04a <regularize_k>
			goto clear_and_out;
    		}
    		initial_Z = p2[carry];
  	}

	EccPoint_mult(_public, _public, p2[!carry], initial_Z, curve->num_n_bits + 1,
   19520:	fab0 f080 	clz	r0, r0
   19524:	9401      	str	r4, [sp, #4]
   19526:	ab24      	add	r3, sp, #144	; 0x90
   19528:	0940      	lsrs	r0, r0, #5
   1952a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1952e:	8863      	ldrh	r3, [r4, #2]
   19530:	3301      	adds	r3, #1
   19532:	b21b      	sxth	r3, r3
   19534:	9300      	str	r3, [sp, #0]
   19536:	a914      	add	r1, sp, #80	; 0x50
   19538:	2300      	movs	r3, #0
   1953a:	f850 2c88 	ldr.w	r2, [r0, #-136]
   1953e:	4608      	mov	r0, r1
   19540:	f000 fcb4 	bl	19eac <EccPoint_mult>
		      curve);

	uECC_vli_nativeToBytes(secret, num_bytes, _public);
   19544:	aa14      	add	r2, sp, #80	; 0x50
   19546:	4639      	mov	r1, r7
   19548:	4640      	mov	r0, r8
   1954a:	f000 fdd3 	bl	1a0f4 <uECC_vli_nativeToBytes>
	r = !EccPoint_isZero(_public, curve);
   1954e:	4621      	mov	r1, r4
   19550:	a814      	add	r0, sp, #80	; 0x50
   19552:	f000 fc22 	bl	19d9a <EccPoint_isZero>
   19556:	ac02      	add	r4, sp, #8
   19558:	4607      	mov	r7, r0
   1955a:	2208      	movs	r2, #8
   1955c:	2100      	movs	r1, #0
   1955e:	4620      	mov	r0, r4
   19560:	f001 fd75 	bl	1b04e <memset>
   19564:	2220      	movs	r2, #32
   19566:	2100      	movs	r1, #0
   19568:	4630      	mov	r0, r6
   1956a:	f001 fd70 	bl	1b04e <memset>
   1956e:	2220      	movs	r2, #32
   19570:	2100      	movs	r1, #0
   19572:	4628      	mov	r0, r5
   19574:	f001 fd6b 	bl	1b04e <memset>
	_set_secure(p2, 0, sizeof(p2));
	_set_secure(tmp, 0, sizeof(tmp));
	_set_secure(_private, 0, sizeof(_private));

	return r;
}
   19578:	fab7 f087 	clz	r0, r7
   1957c:	0940      	lsrs	r0, r0, #5
   1957e:	b024      	add	sp, #144	; 0x90
   19580:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00019584 <uECC_vli_add>:
{
   19584:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
   19586:	2400      	movs	r4, #0
{
   19588:	4607      	mov	r7, r0
	uECC_word_t carry = 0;
   1958a:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
   1958c:	b265      	sxtb	r5, r4
   1958e:	42ab      	cmp	r3, r5
   19590:	dc00      	bgt.n	19594 <uECC_vli_add+0x10>
}
   19592:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t sum = left[i] + right[i] + carry;
   19594:	f851 6024 	ldr.w	r6, [r1, r4, lsl #2]
   19598:	f852 5024 	ldr.w	r5, [r2, r4, lsl #2]
   1959c:	4435      	add	r5, r6
   1959e:	4405      	add	r5, r0
		carry = cond_set(val, carry, (sum != left[i]));
   195a0:	42ae      	cmp	r6, r5
		uECC_word_t val = (sum < left[i]);
   195a2:	bf8c      	ite	hi
   195a4:	2601      	movhi	r6, #1
   195a6:	2600      	movls	r6, #0
		result[i] = sum;
   195a8:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
   195ac:	bf18      	it	ne
   195ae:	4630      	movne	r0, r6
		result[i] = sum;
   195b0:	3401      	adds	r4, #1
   195b2:	e7eb      	b.n	1958c <uECC_vli_add+0x8>

000195b4 <uECC_vli_rshift1>:
	vli += num_words;
   195b4:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	uECC_word_t carry = 0;
   195b8:	2300      	movs	r3, #0
	while (vli-- > end) {
   195ba:	4288      	cmp	r0, r1
   195bc:	d300      	bcc.n	195c0 <uECC_vli_rshift1+0xc>
}
   195be:	4770      	bx	lr
		uECC_word_t temp = *vli;
   195c0:	f851 2d04 	ldr.w	r2, [r1, #-4]!
		*vli = (temp >> 1) | carry;
   195c4:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
   195c8:	600b      	str	r3, [r1, #0]
		carry = temp << (uECC_WORD_BITS - 1);
   195ca:	07d3      	lsls	r3, r2, #31
   195cc:	e7f5      	b.n	195ba <uECC_vli_rshift1+0x6>

000195ce <vli_modInv_update>:
	if (!EVEN(uv)) {
   195ce:	6803      	ldr	r3, [r0, #0]
{
   195d0:	b570      	push	{r4, r5, r6, lr}
	if (!EVEN(uv)) {
   195d2:	f013 0601 	ands.w	r6, r3, #1
{
   195d6:	4605      	mov	r5, r0
   195d8:	4614      	mov	r4, r2
	if (!EVEN(uv)) {
   195da:	d005      	beq.n	195e8 <vli_modInv_update+0x1a>
		carry = uECC_vli_add(uv, uv, mod, num_words);
   195dc:	4613      	mov	r3, r2
   195de:	460a      	mov	r2, r1
   195e0:	4601      	mov	r1, r0
   195e2:	f7ff ffcf 	bl	19584 <uECC_vli_add>
   195e6:	4606      	mov	r6, r0
	uECC_vli_rshift1(uv, num_words);
   195e8:	4621      	mov	r1, r4
   195ea:	4628      	mov	r0, r5
   195ec:	f7ff ffe2 	bl	195b4 <uECC_vli_rshift1>
	if (carry) {
   195f0:	b146      	cbz	r6, 19604 <vli_modInv_update+0x36>
		uv[num_words - 1] |= HIGH_BIT_SET;
   195f2:	f104 4280 	add.w	r2, r4, #1073741824	; 0x40000000
   195f6:	3a01      	subs	r2, #1
   195f8:	f855 3022 	ldr.w	r3, [r5, r2, lsl #2]
   195fc:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   19600:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
}
   19604:	bd70      	pop	{r4, r5, r6, pc}

00019606 <uECC_vli_mult>:
{
   19606:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (k = 0; k < num_words; ++k) {
   1960a:	2500      	movs	r5, #0
{
   1960c:	b087      	sub	sp, #28
   1960e:	e9cd 1200 	strd	r1, r2, [sp]
	uECC_word_t r1 = 0;
   19612:	462c      	mov	r4, r5
	uECC_word_t r0 = 0;
   19614:	462a      	mov	r2, r5
   19616:	fa4f f885 	sxtb.w	r8, r5
	for (k = 0; k < num_words; ++k) {
   1961a:	4543      	cmp	r3, r8
   1961c:	dc16      	bgt.n	1964c <uECC_vli_mult+0x46>
	for (k = num_words; k < num_words * 2 - 1; ++k) {
   1961e:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   19622:	eb05 0543 	add.w	r5, r5, r3, lsl #1
   19626:	9502      	str	r5, [sp, #8]
   19628:	f04f 0a00 	mov.w	sl, #0
   1962c:	fa5f f58a 	uxtb.w	r5, sl
   19630:	eb05 0c03 	add.w	ip, r5, r3
   19634:	9e02      	ldr	r6, [sp, #8]
   19636:	fa4f fc8c 	sxtb.w	ip, ip
   1963a:	45b4      	cmp	ip, r6
   1963c:	db2d      	blt.n	1969a <uECC_vli_mult+0x94>
	result[num_words * 2 - 1] = r0;
   1963e:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   19642:	f840 2c04 	str.w	r2, [r0, #-4]
}
   19646:	b007      	add	sp, #28
   19648:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1964c:	9e01      	ldr	r6, [sp, #4]
	for (k = 0; k < num_words; ++k) {
   1964e:	f04f 0c00 	mov.w	ip, #0
   19652:	eb06 0985 	add.w	r9, r6, r5, lsl #2
   19656:	46e6      	mov	lr, ip
	uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;
   19658:	e9cd 2402 	strd	r2, r4, [sp, #8]
	uECC_dword_t p = (uECC_dword_t)a * b;
   1965c:	9900      	ldr	r1, [sp, #0]
			muladd(left[i], right[k - i], &r0, &r1, &r2);
   1965e:	f859 7904 	ldr.w	r7, [r9], #-4
	uECC_dword_t p = (uECC_dword_t)a * b;
   19662:	f851 602c 	ldr.w	r6, [r1, ip, lsl #2]
   19666:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
   1966a:	fba7 ab06 	umull	sl, fp, r7, r6
   1966e:	eb1a 0601 	adds.w	r6, sl, r1
   19672:	f10c 0c01 	add.w	ip, ip, #1
   19676:	eb5b 0702 	adcs.w	r7, fp, r2
		for (i = 0; i <= k; ++i) {
   1967a:	fa4f fa8c 	sxtb.w	sl, ip
   1967e:	bf2c      	ite	cs
   19680:	2201      	movcs	r2, #1
   19682:	2200      	movcc	r2, #0
   19684:	45c2      	cmp	sl, r8
	*r2 += (r01 < p);
   19686:	4496      	add	lr, r2
	*r1 = r01 >> uECC_WORD_BITS;
   19688:	463c      	mov	r4, r7
	*r0 = (uECC_word_t)r01;
   1968a:	4632      	mov	r2, r6
		for (i = 0; i <= k; ++i) {
   1968c:	dde4      	ble.n	19658 <uECC_vli_mult+0x52>
		result[k] = r0;
   1968e:	f840 6025 	str.w	r6, [r0, r5, lsl #2]
	*r1 = r01 >> uECC_WORD_BITS;
   19692:	463a      	mov	r2, r7
   19694:	3501      	adds	r5, #1
	*r2 += (r01 < p);
   19696:	4674      	mov	r4, lr
   19698:	e7bd      	b.n	19616 <uECC_vli_mult+0x10>
		for (i = (k + 1) - num_words; i < num_words; ++i) {
   1969a:	3501      	adds	r5, #1
   1969c:	b26d      	sxtb	r5, r5
   1969e:	9e01      	ldr	r6, [sp, #4]
   196a0:	9900      	ldr	r1, [sp, #0]
   196a2:	ebac 0e05 	sub.w	lr, ip, r5
   196a6:	eb06 0e8e 	add.w	lr, r6, lr, lsl #2
   196aa:	eb01 0b85 	add.w	fp, r1, r5, lsl #2
   196ae:	4626      	mov	r6, r4
   196b0:	2400      	movs	r4, #0
   196b2:	429d      	cmp	r5, r3
   196b4:	db05      	blt.n	196c2 <uECC_vli_mult+0xbc>
		result[k] = r0;
   196b6:	f840 202c 	str.w	r2, [r0, ip, lsl #2]
		r2 = 0;
   196ba:	f10a 0a01 	add.w	sl, sl, #1
		result[k] = r0;
   196be:	4632      	mov	r2, r6
   196c0:	e7b4      	b.n	1962c <uECC_vli_mult+0x26>
	uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;
   196c2:	e9cd 2604 	strd	r2, r6, [sp, #16]
			muladd(left[i], right[k - i], &r0, &r1, &r2);
   196c6:	f85e 7904 	ldr.w	r7, [lr], #-4
   196ca:	f85b 8b04 	ldr.w	r8, [fp], #4
	r01 += p;
   196ce:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
	uECC_dword_t p = (uECC_dword_t)a * b;
   196d2:	fba8 8907 	umull	r8, r9, r8, r7
   196d6:	eb18 0601 	adds.w	r6, r8, r1
   196da:	eb59 0702 	adcs.w	r7, r9, r2
   196de:	bf2c      	ite	cs
   196e0:	2201      	movcs	r2, #1
   196e2:	2200      	movcc	r2, #0
		for (i = (k + 1) - num_words; i < num_words; ++i) {
   196e4:	3501      	adds	r5, #1
	*r2 += (r01 < p);
   196e6:	4414      	add	r4, r2
		for (i = (k + 1) - num_words; i < num_words; ++i) {
   196e8:	b26d      	sxtb	r5, r5
	*r0 = (uECC_word_t)r01;
   196ea:	4632      	mov	r2, r6
	*r1 = r01 >> uECC_WORD_BITS;
   196ec:	463e      	mov	r6, r7
   196ee:	e7e0      	b.n	196b2 <uECC_vli_mult+0xac>

000196f0 <uECC_vli_clear>:
	for (i = 0; i < num_words; ++i) {
   196f0:	2300      	movs	r3, #0
{
   196f2:	b510      	push	{r4, lr}
		 vli[i] = 0;
   196f4:	461c      	mov	r4, r3
	for (i = 0; i < num_words; ++i) {
   196f6:	b25a      	sxtb	r2, r3
   196f8:	4291      	cmp	r1, r2
   196fa:	dc00      	bgt.n	196fe <uECC_vli_clear+0xe>
}
   196fc:	bd10      	pop	{r4, pc}
		 vli[i] = 0;
   196fe:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
   19702:	3301      	adds	r3, #1
   19704:	e7f7      	b.n	196f6 <uECC_vli_clear+0x6>

00019706 <uECC_vli_isZero>:
{
   19706:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
   19708:	2300      	movs	r3, #0
	uECC_word_t bits = 0;
   1970a:	461a      	mov	r2, r3
	for (i = 0; i < num_words; ++i) {
   1970c:	b25c      	sxtb	r4, r3
   1970e:	42a1      	cmp	r1, r4
   19710:	dc03      	bgt.n	1971a <uECC_vli_isZero+0x14>
}
   19712:	fab2 f082 	clz	r0, r2
   19716:	0940      	lsrs	r0, r0, #5
   19718:	bd10      	pop	{r4, pc}
		bits |= vli[i];
   1971a:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   1971e:	3301      	adds	r3, #1
   19720:	4322      	orrs	r2, r4
   19722:	e7f3      	b.n	1970c <uECC_vli_isZero+0x6>

00019724 <uECC_vli_testBit>:
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   19724:	114a      	asrs	r2, r1, #5
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
   19726:	2301      	movs	r3, #1
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   19728:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
   1972c:	f001 011f 	and.w	r1, r1, #31
   19730:	fa03 f101 	lsl.w	r1, r3, r1
}
   19734:	4008      	ands	r0, r1
   19736:	4770      	bx	lr

00019738 <uECC_vli_numBits>:
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
   19738:	3901      	subs	r1, #1
   1973a:	b249      	sxtb	r1, r1
   1973c:	eb00 0381 	add.w	r3, r0, r1, lsl #2
   19740:	2900      	cmp	r1, #0
   19742:	da04      	bge.n	1974e <uECC_vli_numBits+0x16>
	return (i + 1);
   19744:	3101      	adds	r1, #1
   19746:	b249      	sxtb	r1, r1
	if (num_digits == 0) {
   19748:	b941      	cbnz	r1, 1975c <uECC_vli_numBits+0x24>
		return 0;
   1974a:	4608      	mov	r0, r1
}
   1974c:	4770      	bx	lr
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
   1974e:	f853 2904 	ldr.w	r2, [r3], #-4
   19752:	2a00      	cmp	r2, #0
   19754:	d1f6      	bne.n	19744 <uECC_vli_numBits+0xc>
   19756:	3901      	subs	r1, #1
   19758:	b249      	sxtb	r1, r1
   1975a:	e7f1      	b.n	19740 <uECC_vli_numBits+0x8>
	digit = vli[num_digits - 1];
   1975c:	f101 4380 	add.w	r3, r1, #1073741824	; 0x40000000
   19760:	3b01      	subs	r3, #1
   19762:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
	for (i = 0; digit; ++i) {
   19766:	2000      	movs	r0, #0
   19768:	b923      	cbnz	r3, 19774 <uECC_vli_numBits+0x3c>
	return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);
   1976a:	3901      	subs	r1, #1
   1976c:	eb00 1141 	add.w	r1, r0, r1, lsl #5
   19770:	b208      	sxth	r0, r1
   19772:	4770      	bx	lr
		digit >>= 1;
   19774:	085b      	lsrs	r3, r3, #1
	for (i = 0; digit; ++i) {
   19776:	3001      	adds	r0, #1
   19778:	e7f6      	b.n	19768 <uECC_vli_numBits+0x30>

0001977a <uECC_vli_set>:
{
   1977a:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
   1977c:	2300      	movs	r3, #0
   1977e:	b25c      	sxtb	r4, r3
   19780:	42a2      	cmp	r2, r4
   19782:	dc00      	bgt.n	19786 <uECC_vli_set+0xc>
}
   19784:	bd10      	pop	{r4, pc}
		dest[i] = src[i];
   19786:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
   1978a:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
   1978e:	3301      	adds	r3, #1
   19790:	e7f5      	b.n	1977e <uECC_vli_set+0x4>

00019792 <uECC_vli_cmp_unsafe>:
{
   19792:	b530      	push	{r4, r5, lr}
	for (i = num_words - 1; i >= 0; --i) {
   19794:	3a01      	subs	r2, #1
   19796:	b252      	sxtb	r2, r2
   19798:	0093      	lsls	r3, r2, #2
   1979a:	2a00      	cmp	r2, #0
   1979c:	da01      	bge.n	197a2 <uECC_vli_cmp_unsafe+0x10>
	return 0;
   1979e:	2000      	movs	r0, #0
}
   197a0:	bd30      	pop	{r4, r5, pc}
		if (left[i] > right[i]) {
   197a2:	58c5      	ldr	r5, [r0, r3]
   197a4:	58cc      	ldr	r4, [r1, r3]
   197a6:	42a5      	cmp	r5, r4
   197a8:	d805      	bhi.n	197b6 <uECC_vli_cmp_unsafe+0x24>
		} else if (left[i] < right[i]) {
   197aa:	f1a3 0304 	sub.w	r3, r3, #4
   197ae:	d304      	bcc.n	197ba <uECC_vli_cmp_unsafe+0x28>
	for (i = num_words - 1; i >= 0; --i) {
   197b0:	3a01      	subs	r2, #1
   197b2:	b252      	sxtb	r2, r2
   197b4:	e7f1      	b.n	1979a <uECC_vli_cmp_unsafe+0x8>
			return 1;
   197b6:	2001      	movs	r0, #1
   197b8:	e7f2      	b.n	197a0 <uECC_vli_cmp_unsafe+0xe>
			return -1;
   197ba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   197be:	e7ef      	b.n	197a0 <uECC_vli_cmp_unsafe+0xe>

000197c0 <uECC_vli_equal>:
	for (i = num_words - 1; i >= 0; --i) {
   197c0:	3a01      	subs	r2, #1
   197c2:	b252      	sxtb	r2, r2
{
   197c4:	b570      	push	{r4, r5, r6, lr}
   197c6:	0093      	lsls	r3, r2, #2
	uECC_word_t diff = 0;
   197c8:	2400      	movs	r4, #0
	for (i = num_words - 1; i >= 0; --i) {
   197ca:	2a00      	cmp	r2, #0
   197cc:	da03      	bge.n	197d6 <uECC_vli_equal+0x16>
}
   197ce:	1c20      	adds	r0, r4, #0
   197d0:	bf18      	it	ne
   197d2:	2001      	movne	r0, #1
   197d4:	bd70      	pop	{r4, r5, r6, pc}
		diff |= (left[i] ^ right[i]);
   197d6:	58c5      	ldr	r5, [r0, r3]
   197d8:	58ce      	ldr	r6, [r1, r3]
	for (i = num_words - 1; i >= 0; --i) {
   197da:	3a01      	subs	r2, #1
		diff |= (left[i] ^ right[i]);
   197dc:	4075      	eors	r5, r6
   197de:	432c      	orrs	r4, r5
	for (i = num_words - 1; i >= 0; --i) {
   197e0:	b252      	sxtb	r2, r2
   197e2:	3b04      	subs	r3, #4
   197e4:	e7f1      	b.n	197ca <uECC_vli_equal+0xa>

000197e6 <uECC_vli_sub>:
{
   197e6:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
   197e8:	2400      	movs	r4, #0
{
   197ea:	4607      	mov	r7, r0
   197ec:	469c      	mov	ip, r3
	uECC_word_t borrow = 0;
   197ee:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
   197f0:	b265      	sxtb	r5, r4
   197f2:	45ac      	cmp	ip, r5
   197f4:	dc00      	bgt.n	197f8 <uECC_vli_sub+0x12>
}
   197f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t diff = left[i] - right[i] - borrow;
   197f8:	f851 6024 	ldr.w	r6, [r1, r4, lsl #2]
   197fc:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
   19800:	1a35      	subs	r5, r6, r0
   19802:	1aed      	subs	r5, r5, r3
		borrow = cond_set(val, borrow, (diff != left[i]));
   19804:	42ae      	cmp	r6, r5
		uECC_word_t val = (diff > left[i]);
   19806:	bf34      	ite	cc
   19808:	2601      	movcc	r6, #1
   1980a:	2600      	movcs	r6, #0
		result[i] = diff;
   1980c:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
   19810:	bf18      	it	ne
   19812:	4630      	movne	r0, r6
		result[i] = diff;
   19814:	3401      	adds	r4, #1
   19816:	e7eb      	b.n	197f0 <uECC_vli_sub+0xa>

00019818 <uECC_vli_modAdd>:
{
   19818:	b570      	push	{r4, r5, r6, lr}
   1981a:	f99d 4010 	ldrsb.w	r4, [sp, #16]
   1981e:	461e      	mov	r6, r3
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
   19820:	4623      	mov	r3, r4
{
   19822:	4605      	mov	r5, r0
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
   19824:	f7ff feae 	bl	19584 <uECC_vli_add>
	if (carry || uECC_vli_cmp_unsafe(mod, result, num_words) != 1) {
   19828:	b930      	cbnz	r0, 19838 <uECC_vli_modAdd+0x20>
   1982a:	4622      	mov	r2, r4
   1982c:	4629      	mov	r1, r5
   1982e:	4630      	mov	r0, r6
   19830:	f7ff ffaf 	bl	19792 <uECC_vli_cmp_unsafe>
   19834:	2801      	cmp	r0, #1
   19836:	d007      	beq.n	19848 <uECC_vli_modAdd+0x30>
		uECC_vli_sub(result, result, mod, num_words);
   19838:	4623      	mov	r3, r4
   1983a:	4632      	mov	r2, r6
   1983c:	4629      	mov	r1, r5
   1983e:	4628      	mov	r0, r5
}
   19840:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_sub(result, result, mod, num_words);
   19844:	f7ff bfcf 	b.w	197e6 <uECC_vli_sub>
}
   19848:	bd70      	pop	{r4, r5, r6, pc}

0001984a <uECC_vli_modSub>:
{
   1984a:	b570      	push	{r4, r5, r6, lr}
   1984c:	f99d 4010 	ldrsb.w	r4, [sp, #16]
   19850:	461e      	mov	r6, r3
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
   19852:	4623      	mov	r3, r4
{
   19854:	4605      	mov	r5, r0
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
   19856:	f7ff ffc6 	bl	197e6 <uECC_vli_sub>
	if (l_borrow) {
   1985a:	b138      	cbz	r0, 1986c <uECC_vli_modSub+0x22>
		uECC_vli_add(result, result, mod, num_words);
   1985c:	4623      	mov	r3, r4
   1985e:	4632      	mov	r2, r6
   19860:	4629      	mov	r1, r5
   19862:	4628      	mov	r0, r5
}
   19864:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_add(result, result, mod, num_words);
   19868:	f7ff be8c 	b.w	19584 <uECC_vli_add>
}
   1986c:	bd70      	pop	{r4, r5, r6, pc}

0001986e <uECC_vli_mmod>:
{
   1986e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19872:	b0a5      	sub	sp, #148	; 0x94
   19874:	461d      	mov	r5, r3
	uECC_word_t *v[2] = {tmp, product};
   19876:	ab14      	add	r3, sp, #80	; 0x50
   19878:	e9cd 3102 	strd	r3, r1, [sp, #8]
{
   1987c:	4681      	mov	r9, r0
			   uECC_vli_numBits(mod, num_words);
   1987e:	4629      	mov	r1, r5
   19880:	4610      	mov	r0, r2
{
   19882:	4617      	mov	r7, r2
			   uECC_vli_numBits(mod, num_words);
   19884:	f7ff ff58 	bl	19738 <uECC_vli_numBits>
	bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) -
   19888:	ebc0 1085 	rsb	r0, r0, r5, lsl #6
   1988c:	b204      	sxth	r4, r0
	wordcount_t word_shift = shift / uECC_WORD_BITS;
   1988e:	2c00      	cmp	r4, #0
   19890:	4626      	mov	r6, r4
   19892:	bfb8      	it	lt
   19894:	f104 061f 	addlt.w	r6, r4, #31
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   19898:	4263      	negs	r3, r4
	wordcount_t word_shift = shift / uECC_WORD_BITS;
   1989a:	f346 1647 	sbfx	r6, r6, #5, #8
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   1989e:	f003 031f 	and.w	r3, r3, #31
   198a2:	f004 081f 	and.w	r8, r4, #31
	uECC_vli_clear(mod_multiple, word_shift);
   198a6:	a804      	add	r0, sp, #16
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   198a8:	bf58      	it	pl
   198aa:	f1c3 0800 	rsbpl	r8, r3, #0
	uECC_vli_clear(mod_multiple, word_shift);
   198ae:	4631      	mov	r1, r6
   198b0:	f7ff ff1e 	bl	196f0 <uECC_vli_clear>
	if (bit_shift > 0) {
   198b4:	f1b8 0f00 	cmp.w	r8, #0
   198b8:	b230      	sxth	r0, r6
   198ba:	dd2d      	ble.n	19918 <uECC_vli_mmod+0xaa>
   198bc:	ab04      	add	r3, sp, #16
	uECC_word_t carry = 0;
   198be:	2200      	movs	r2, #0
   198c0:	eb03 0080 	add.w	r0, r3, r0, lsl #2
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
   198c4:	f1c8 0c20 	rsb	ip, r8, #32
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
   198c8:	4613      	mov	r3, r2
   198ca:	429d      	cmp	r5, r3
   198cc:	d819      	bhi.n	19902 <uECC_vli_mmod+0x94>
		for (i = 0; i < num_words * 2; ++i) {
   198ce:	b22f      	sxth	r7, r5
   198d0:	007b      	lsls	r3, r7, #1
   198d2:	9301      	str	r3, [sp, #4]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   198d4:	ab04      	add	r3, sp, #16
   198d6:	eb03 0787 	add.w	r7, r3, r7, lsl #2
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   198da:	f105 38ff 	add.w	r8, r5, #4294967295	; 0xffffffff
   198de:	ab24      	add	r3, sp, #144	; 0x90
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   198e0:	2601      	movs	r6, #1
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   198e2:	eb03 0888 	add.w	r8, r3, r8, lsl #2
	for (index = 1; shift >= 0; --shift) {
   198e6:	2c00      	cmp	r4, #0
   198e8:	da54      	bge.n	19994 <uECC_vli_mmod+0x126>
	uECC_vli_set(result, v[index], num_words);
   198ea:	ab24      	add	r3, sp, #144	; 0x90
   198ec:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   198f0:	462a      	mov	r2, r5
   198f2:	f856 1c88 	ldr.w	r1, [r6, #-136]
   198f6:	4648      	mov	r0, r9
   198f8:	f7ff ff3f 	bl	1977a <uECC_vli_set>
}
   198fc:	b025      	add	sp, #148	; 0x94
   198fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
   19902:	f857 6023 	ldr.w	r6, [r7, r3, lsl #2]
   19906:	fa06 f108 	lsl.w	r1, r6, r8
   1990a:	430a      	orrs	r2, r1
   1990c:	f840 2b04 	str.w	r2, [r0], #4
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
   19910:	3301      	adds	r3, #1
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
   19912:	fa26 f20c 	lsr.w	r2, r6, ip
   19916:	e7d8      	b.n	198ca <uECC_vli_mmod+0x5c>
		uECC_vli_set(mod_multiple + word_shift, mod, num_words);
   19918:	ab04      	add	r3, sp, #16
   1991a:	462a      	mov	r2, r5
   1991c:	4639      	mov	r1, r7
   1991e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   19922:	f7ff ff2a 	bl	1977a <uECC_vli_set>
   19926:	e7d2      	b.n	198ce <uECC_vli_mmod+0x60>
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   19928:	fa0f fe82 	sxth.w	lr, r2
   1992c:	f85a 3c88 	ldr.w	r3, [sl, #-136]
   19930:	f853 b02e 	ldr.w	fp, [r3, lr, lsl #2]
   19934:	ab24      	add	r3, sp, #144	; 0x90
   19936:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   1993a:	3001      	adds	r0, #1
   1993c:	f852 3c80 	ldr.w	r3, [r2, #-128]
   19940:	440b      	add	r3, r1
   19942:	ebbb 0303 	subs.w	r3, fp, r3
   19946:	bf34      	ite	cc
   19948:	2201      	movcc	r2, #1
   1994a:	2200      	movcs	r2, #0
			if (diff != v[index][i]) {
   1994c:	459b      	cmp	fp, r3
				borrow = (diff > v[index][i]);
   1994e:	bf18      	it	ne
   19950:	4611      	movne	r1, r2
			v[1 - index][i] = diff;
   19952:	f85c 2c88 	ldr.w	r2, [ip, #-136]
   19956:	f842 302e 	str.w	r3, [r2, lr, lsl #2]
		for (i = 0; i < num_words * 2; ++i) {
   1995a:	9b01      	ldr	r3, [sp, #4]
   1995c:	b242      	sxtb	r2, r0
   1995e:	429a      	cmp	r2, r3
   19960:	dbe2      	blt.n	19928 <uECC_vli_mmod+0xba>
		index = !(index ^ borrow);
   19962:	1a73      	subs	r3, r6, r1
   19964:	425e      	negs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
   19966:	4629      	mov	r1, r5
   19968:	a804      	add	r0, sp, #16
		index = !(index ^ borrow);
   1996a:	415e      	adcs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
   1996c:	f7ff fe22 	bl	195b4 <uECC_vli_rshift1>
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   19970:	ab24      	add	r3, sp, #144	; 0x90
   19972:	eb03 0385 	add.w	r3, r3, r5, lsl #2
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   19976:	4629      	mov	r1, r5
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   19978:	f853 2c80 	ldr.w	r2, [r3, #-128]
   1997c:	f858 3c80 	ldr.w	r3, [r8, #-128]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   19980:	4638      	mov	r0, r7
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   19982:	ea43 73c2 	orr.w	r3, r3, r2, lsl #31
	for (index = 1; shift >= 0; --shift) {
   19986:	3c01      	subs	r4, #1
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   19988:	f848 3c80 	str.w	r3, [r8, #-128]
	for (index = 1; shift >= 0; --shift) {
   1998c:	b224      	sxth	r4, r4
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   1998e:	f7ff fe11 	bl	195b4 <uECC_vli_rshift1>
   19992:	e7a8      	b.n	198e6 <uECC_vli_mmod+0x78>
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   19994:	ab24      	add	r3, sp, #144	; 0x90
   19996:	2000      	movs	r0, #0
			v[1 - index][i] = diff;
   19998:	f1c6 0c01 	rsb	ip, r6, #1
		uECC_word_t borrow = 0;
   1999c:	4601      	mov	r1, r0
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   1999e:	eb03 0a86 	add.w	sl, r3, r6, lsl #2
			v[1 - index][i] = diff;
   199a2:	eb03 0c8c 	add.w	ip, r3, ip, lsl #2
   199a6:	e7d8      	b.n	1995a <uECC_vli_mmod+0xec>

000199a8 <uECC_vli_modMult_fast>:
{
   199a8:	b530      	push	{r4, r5, lr}
   199aa:	461c      	mov	r4, r3
   199ac:	b091      	sub	sp, #68	; 0x44
   199ae:	4605      	mov	r5, r0
	uECC_vli_mult(product, left, right, curve->num_words);
   199b0:	f993 3000 	ldrsb.w	r3, [r3]
   199b4:	4668      	mov	r0, sp
   199b6:	f7ff fe26 	bl	19606 <uECC_vli_mult>
	curve->mmod_fast(result, product);
   199ba:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
   199be:	4669      	mov	r1, sp
   199c0:	4628      	mov	r0, r5
   199c2:	4798      	blx	r3
}
   199c4:	b011      	add	sp, #68	; 0x44
   199c6:	bd30      	pop	{r4, r5, pc}

000199c8 <uECC_vli_modSquare_fast>:
	uECC_vli_modMult_fast(result, left, left, curve);
   199c8:	4613      	mov	r3, r2
   199ca:	460a      	mov	r2, r1
   199cc:	f7ff bfec 	b.w	199a8 <uECC_vli_modMult_fast>

000199d0 <double_jacobian_default>:
{
   199d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	wordcount_t num_words = curve->num_words;
   199d4:	f993 6000 	ldrsb.w	r6, [r3]
{
   199d8:	b092      	sub	sp, #72	; 0x48
   199da:	4604      	mov	r4, r0
   199dc:	4689      	mov	r9, r1
	if (uECC_vli_isZero(Z1, num_words)) {
   199de:	4610      	mov	r0, r2
   199e0:	4631      	mov	r1, r6
{
   199e2:	4615      	mov	r5, r2
   199e4:	4698      	mov	r8, r3
	if (uECC_vli_isZero(Z1, num_words)) {
   199e6:	f7ff fe8e 	bl	19706 <uECC_vli_isZero>
   199ea:	2800      	cmp	r0, #0
   199ec:	f040 8091 	bne.w	19b12 <double_jacobian_default+0x142>
	uECC_vli_modSquare_fast(t4, Y1, curve);   /* t4 = y1^2 */
   199f0:	4642      	mov	r2, r8
   199f2:	4649      	mov	r1, r9
   199f4:	a802      	add	r0, sp, #8
   199f6:	f7ff ffe7 	bl	199c8 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(t5, X1, t4, curve); /* t5 = x1*y1^2 = A */
   199fa:	4643      	mov	r3, r8
   199fc:	aa02      	add	r2, sp, #8
   199fe:	4621      	mov	r1, r4
   19a00:	a80a      	add	r0, sp, #40	; 0x28
   19a02:	f7ff ffd1 	bl	199a8 <uECC_vli_modMult_fast>
	uECC_vli_modSquare_fast(t4, t4, curve);   /* t4 = y1^4 */
   19a06:	a902      	add	r1, sp, #8
   19a08:	4608      	mov	r0, r1
   19a0a:	4642      	mov	r2, r8
   19a0c:	f7ff ffdc 	bl	199c8 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(Y1, Y1, Z1, curve); /* t2 = y1*z1 = z3 */
   19a10:	4643      	mov	r3, r8
   19a12:	462a      	mov	r2, r5
   19a14:	4649      	mov	r1, r9
   19a16:	4648      	mov	r0, r9
   19a18:	f7ff ffc6 	bl	199a8 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
   19a1c:	f108 0704 	add.w	r7, r8, #4
	uECC_vli_modSquare_fast(Z1, Z1, curve);   /* t3 = z1^2 */
   19a20:	4642      	mov	r2, r8
   19a22:	4629      	mov	r1, r5
   19a24:	4628      	mov	r0, r5
   19a26:	f7ff ffcf 	bl	199c8 <uECC_vli_modSquare_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
   19a2a:	463b      	mov	r3, r7
   19a2c:	462a      	mov	r2, r5
   19a2e:	4621      	mov	r1, r4
   19a30:	4620      	mov	r0, r4
   19a32:	9600      	str	r6, [sp, #0]
   19a34:	f7ff fef0 	bl	19818 <uECC_vli_modAdd>
	uECC_vli_modAdd(Z1, Z1, Z1, curve->p, num_words); /* t3 = 2*z1^2 */
   19a38:	463b      	mov	r3, r7
   19a3a:	462a      	mov	r2, r5
   19a3c:	4629      	mov	r1, r5
   19a3e:	4628      	mov	r0, r5
   19a40:	9600      	str	r6, [sp, #0]
   19a42:	f7ff fee9 	bl	19818 <uECC_vli_modAdd>
	uECC_vli_modSub(Z1, X1, Z1, curve->p, num_words); /* t3 = x1 - z1^2 */
   19a46:	463b      	mov	r3, r7
   19a48:	462a      	mov	r2, r5
   19a4a:	4621      	mov	r1, r4
   19a4c:	4628      	mov	r0, r5
   19a4e:	9600      	str	r6, [sp, #0]
   19a50:	f7ff fefb 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, Z1, curve); /* t1 = x1^2 - z1^4 */
   19a54:	4643      	mov	r3, r8
   19a56:	462a      	mov	r2, r5
   19a58:	4621      	mov	r1, r4
   19a5a:	4620      	mov	r0, r4
   19a5c:	f7ff ffa4 	bl	199a8 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(Z1, X1, X1, curve->p, num_words); /* t3 = 2*(x1^2 - z1^4) */
   19a60:	463b      	mov	r3, r7
   19a62:	4622      	mov	r2, r4
   19a64:	4621      	mov	r1, r4
   19a66:	4628      	mov	r0, r5
   19a68:	9600      	str	r6, [sp, #0]
   19a6a:	f7ff fed5 	bl	19818 <uECC_vli_modAdd>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = 3*(x1^2 - z1^4) */
   19a6e:	463b      	mov	r3, r7
   19a70:	9600      	str	r6, [sp, #0]
   19a72:	462a      	mov	r2, r5
   19a74:	4621      	mov	r1, r4
   19a76:	4620      	mov	r0, r4
   19a78:	f7ff fece 	bl	19818 <uECC_vli_modAdd>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   19a7c:	6823      	ldr	r3, [r4, #0]
	if (uECC_vli_testBit(X1, 0)) {
   19a7e:	07db      	lsls	r3, r3, #31
   19a80:	d54a      	bpl.n	19b18 <double_jacobian_default+0x148>
		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
   19a82:	4633      	mov	r3, r6
   19a84:	463a      	mov	r2, r7
   19a86:	4621      	mov	r1, r4
   19a88:	4620      	mov	r0, r4
   19a8a:	f7ff fd7b 	bl	19584 <uECC_vli_add>
		uECC_vli_rshift1(X1, num_words);
   19a8e:	4631      	mov	r1, r6
		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
   19a90:	4682      	mov	sl, r0
		uECC_vli_rshift1(X1, num_words);
   19a92:	4620      	mov	r0, r4
   19a94:	f7ff fd8e 	bl	195b4 <uECC_vli_rshift1>
		X1[num_words - 1] |= l_carry << (uECC_WORD_BITS - 1);
   19a98:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
   19a9c:	3b01      	subs	r3, #1
   19a9e:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
   19aa2:	ea40 70ca 	orr.w	r0, r0, sl, lsl #31
   19aa6:	f844 0023 	str.w	r0, [r4, r3, lsl #2]
	uECC_vli_modSquare_fast(Z1, X1, curve); /* t3 = B^2 */
   19aaa:	4642      	mov	r2, r8
   19aac:	4621      	mov	r1, r4
   19aae:	4628      	mov	r0, r5
   19ab0:	f7ff ff8a 	bl	199c8 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - A */
   19ab4:	463b      	mov	r3, r7
   19ab6:	aa0a      	add	r2, sp, #40	; 0x28
   19ab8:	4629      	mov	r1, r5
   19aba:	4628      	mov	r0, r5
   19abc:	9600      	str	r6, [sp, #0]
   19abe:	f7ff fec4 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - 2A = x3 */
   19ac2:	463b      	mov	r3, r7
   19ac4:	aa0a      	add	r2, sp, #40	; 0x28
   19ac6:	4629      	mov	r1, r5
   19ac8:	4628      	mov	r0, r5
   19aca:	9600      	str	r6, [sp, #0]
   19acc:	f7ff febd 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, Z1, curve->p, num_words); /* t5 = A - x3 */
   19ad0:	a90a      	add	r1, sp, #40	; 0x28
   19ad2:	4608      	mov	r0, r1
   19ad4:	463b      	mov	r3, r7
   19ad6:	462a      	mov	r2, r5
   19ad8:	9600      	str	r6, [sp, #0]
   19ada:	f7ff feb6 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = B * (A - x3) */
   19ade:	4643      	mov	r3, r8
   19ae0:	aa0a      	add	r2, sp, #40	; 0x28
   19ae2:	4621      	mov	r1, r4
   19ae4:	4620      	mov	r0, r4
   19ae6:	f7ff ff5f 	bl	199a8 <uECC_vli_modMult_fast>
	uECC_vli_modSub(t4, X1, t4, curve->p, num_words);
   19aea:	aa02      	add	r2, sp, #8
   19aec:	463b      	mov	r3, r7
   19aee:	4610      	mov	r0, r2
   19af0:	4621      	mov	r1, r4
   19af2:	9600      	str	r6, [sp, #0]
   19af4:	f7ff fea9 	bl	1984a <uECC_vli_modSub>
	uECC_vli_set(X1, Z1, num_words);
   19af8:	4632      	mov	r2, r6
   19afa:	4629      	mov	r1, r5
   19afc:	4620      	mov	r0, r4
   19afe:	f7ff fe3c 	bl	1977a <uECC_vli_set>
	uECC_vli_set(Z1, Y1, num_words);
   19b02:	4649      	mov	r1, r9
   19b04:	4628      	mov	r0, r5
   19b06:	f7ff fe38 	bl	1977a <uECC_vli_set>
	uECC_vli_set(Y1, t4, num_words);
   19b0a:	a902      	add	r1, sp, #8
   19b0c:	4648      	mov	r0, r9
   19b0e:	f7ff fe34 	bl	1977a <uECC_vli_set>
}
   19b12:	b012      	add	sp, #72	; 0x48
   19b14:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uECC_vli_rshift1(X1, num_words);
   19b18:	4631      	mov	r1, r6
   19b1a:	4620      	mov	r0, r4
   19b1c:	f7ff fd4a 	bl	195b4 <uECC_vli_rshift1>
   19b20:	e7c3      	b.n	19aaa <double_jacobian_default+0xda>

00019b22 <x_side_default>:
{
   19b22:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   19b26:	4615      	mov	r5, r2
   19b28:	b08a      	sub	sp, #40	; 0x28
   19b2a:	4604      	mov	r4, r0
   19b2c:	4688      	mov	r8, r1
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   19b2e:	221c      	movs	r2, #28
   19b30:	2100      	movs	r1, #0
   19b32:	a803      	add	r0, sp, #12
   19b34:	f001 fa8b 	bl	1b04e <memset>
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
   19b38:	1d2e      	adds	r6, r5, #4
	wordcount_t num_words = curve->num_words;
   19b3a:	f995 7000 	ldrsb.w	r7, [r5]
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   19b3e:	2303      	movs	r3, #3
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
   19b40:	462a      	mov	r2, r5
   19b42:	4641      	mov	r1, r8
   19b44:	4620      	mov	r0, r4
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   19b46:	9302      	str	r3, [sp, #8]
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
   19b48:	f7ff ff3e 	bl	199c8 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
   19b4c:	4633      	mov	r3, r6
   19b4e:	aa02      	add	r2, sp, #8
   19b50:	4621      	mov	r1, r4
   19b52:	4620      	mov	r0, r4
   19b54:	9700      	str	r7, [sp, #0]
   19b56:	f7ff fe78 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modMult_fast(result, result, x, curve); /* r = x^3 - 3x */
   19b5a:	462b      	mov	r3, r5
   19b5c:	4642      	mov	r2, r8
   19b5e:	4621      	mov	r1, r4
   19b60:	4620      	mov	r0, r4
   19b62:	f7ff ff21 	bl	199a8 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(result, result, curve->b, curve->p, num_words);
   19b66:	9700      	str	r7, [sp, #0]
   19b68:	4633      	mov	r3, r6
   19b6a:	f105 0284 	add.w	r2, r5, #132	; 0x84
   19b6e:	4621      	mov	r1, r4
   19b70:	4620      	mov	r0, r4
   19b72:	f7ff fe51 	bl	19818 <uECC_vli_modAdd>
}
   19b76:	b00a      	add	sp, #40	; 0x28
   19b78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00019b7c <XYcZ_addC>:
   or P => P - Q, Q => P + Q
 */
static void XYcZ_addC(uECC_word_t * X1, uECC_word_t * Y1,
		      uECC_word_t * X2, uECC_word_t * Y2,
		      uECC_Curve curve)
{
   19b7c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   19b80:	b09b      	sub	sp, #108	; 0x6c
   19b82:	4616      	mov	r6, r2
	/* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
	uECC_word_t t5[NUM_ECC_WORDS];
	uECC_word_t t6[NUM_ECC_WORDS];
	uECC_word_t t7[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
   19b84:	9c22      	ldr	r4, [sp, #136]	; 0x88
   19b86:	f914 5b04 	ldrsb.w	r5, [r4], #4

	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   19b8a:	9500      	str	r5, [sp, #0]
{
   19b8c:	4698      	mov	r8, r3
   19b8e:	4607      	mov	r7, r0
   19b90:	4689      	mov	r9, r1
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   19b92:	4623      	mov	r3, r4
   19b94:	4602      	mov	r2, r0
   19b96:	4631      	mov	r1, r6
   19b98:	a802      	add	r0, sp, #8
   19b9a:	f7ff fe56 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
   19b9e:	a902      	add	r1, sp, #8
   19ba0:	9a22      	ldr	r2, [sp, #136]	; 0x88
   19ba2:	4608      	mov	r0, r1
   19ba4:	f7ff ff10 	bl	199c8 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
   19ba8:	9b22      	ldr	r3, [sp, #136]	; 0x88
   19baa:	aa02      	add	r2, sp, #8
   19bac:	4639      	mov	r1, r7
   19bae:	4638      	mov	r0, r7
   19bb0:	f7ff fefa 	bl	199a8 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
   19bb4:	9b22      	ldr	r3, [sp, #136]	; 0x88
   19bb6:	aa02      	add	r2, sp, #8
   19bb8:	4631      	mov	r1, r6
   19bba:	4630      	mov	r0, r6
   19bbc:	f7ff fef4 	bl	199a8 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t5, Y2, Y1, curve->p, num_words); /* t5 = y2 + y1 */
   19bc0:	4623      	mov	r3, r4
   19bc2:	464a      	mov	r2, r9
   19bc4:	4641      	mov	r1, r8
   19bc6:	a802      	add	r0, sp, #8
   19bc8:	9500      	str	r5, [sp, #0]
   19bca:	f7ff fe25 	bl	19818 <uECC_vli_modAdd>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
   19bce:	4623      	mov	r3, r4
   19bd0:	464a      	mov	r2, r9
   19bd2:	4641      	mov	r1, r8
   19bd4:	4640      	mov	r0, r8
   19bd6:	9500      	str	r5, [sp, #0]
   19bd8:	f7ff fe37 	bl	1984a <uECC_vli_modSub>

	uECC_vli_modSub(t6, X2, X1, curve->p, num_words); /* t6 = C - B */
   19bdc:	4623      	mov	r3, r4
   19bde:	463a      	mov	r2, r7
   19be0:	4631      	mov	r1, r6
   19be2:	a80a      	add	r0, sp, #40	; 0x28
   19be4:	9500      	str	r5, [sp, #0]
   19be6:	f7ff fe30 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, t6, curve); /* t2 = y1 * (C - B) = E */
   19bea:	9b22      	ldr	r3, [sp, #136]	; 0x88
   19bec:	aa0a      	add	r2, sp, #40	; 0x28
   19bee:	4649      	mov	r1, r9
   19bf0:	4648      	mov	r0, r9
   19bf2:	f7ff fed9 	bl	199a8 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t6, X1, X2, curve->p, num_words); /* t6 = B + C */
   19bf6:	4623      	mov	r3, r4
   19bf8:	4632      	mov	r2, r6
   19bfa:	4639      	mov	r1, r7
   19bfc:	a80a      	add	r0, sp, #40	; 0x28
   19bfe:	9500      	str	r5, [sp, #0]
   19c00:	f7ff fe0a 	bl	19818 <uECC_vli_modAdd>
	uECC_vli_modSquare_fast(X2, Y2, curve); /* t3 = (y2 - y1)^2 = D */
   19c04:	9a22      	ldr	r2, [sp, #136]	; 0x88
   19c06:	4641      	mov	r1, r8
   19c08:	4630      	mov	r0, r6
   19c0a:	f7ff fedd 	bl	199c8 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(X2, X2, t6, curve->p, num_words); /* t3 = D - (B + C) = x3 */
   19c0e:	4623      	mov	r3, r4
   19c10:	aa0a      	add	r2, sp, #40	; 0x28
   19c12:	4631      	mov	r1, r6
   19c14:	4630      	mov	r0, r6
   19c16:	9500      	str	r5, [sp, #0]
   19c18:	f7ff fe17 	bl	1984a <uECC_vli_modSub>

	uECC_vli_modSub(t7, X1, X2, curve->p, num_words); /* t7 = B - x3 */
   19c1c:	4623      	mov	r3, r4
   19c1e:	4632      	mov	r2, r6
   19c20:	4639      	mov	r1, r7
   19c22:	a812      	add	r0, sp, #72	; 0x48
   19c24:	9500      	str	r5, [sp, #0]
   19c26:	f7ff fe10 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, t7, curve); /* t4 = (y2 - y1)*(B - x3) */
   19c2a:	9b22      	ldr	r3, [sp, #136]	; 0x88
   19c2c:	aa12      	add	r2, sp, #72	; 0x48
   19c2e:	4641      	mov	r1, r8
   19c30:	4640      	mov	r0, r8
   19c32:	f7ff feb9 	bl	199a8 <uECC_vli_modMult_fast>
	/* t4 = (y2 - y1)*(B - x3) - E = y3: */
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words);
   19c36:	4623      	mov	r3, r4
   19c38:	464a      	mov	r2, r9
   19c3a:	4641      	mov	r1, r8
   19c3c:	4640      	mov	r0, r8
   19c3e:	9500      	str	r5, [sp, #0]
   19c40:	f7ff fe03 	bl	1984a <uECC_vli_modSub>

	uECC_vli_modSquare_fast(t7, t5, curve); /* t7 = (y2 + y1)^2 = F */
   19c44:	9a22      	ldr	r2, [sp, #136]	; 0x88
   19c46:	a902      	add	r1, sp, #8
   19c48:	a812      	add	r0, sp, #72	; 0x48
   19c4a:	f7ff febd 	bl	199c8 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t7, t7, t6, curve->p, num_words); /* t7 = F - (B + C) = x3' */
   19c4e:	a912      	add	r1, sp, #72	; 0x48
   19c50:	4623      	mov	r3, r4
   19c52:	aa0a      	add	r2, sp, #40	; 0x28
   19c54:	4608      	mov	r0, r1
   19c56:	9500      	str	r5, [sp, #0]
   19c58:	f7ff fdf7 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modSub(t6, t7, X1, curve->p, num_words); /* t6 = x3' - B */
   19c5c:	4623      	mov	r3, r4
   19c5e:	463a      	mov	r2, r7
   19c60:	a912      	add	r1, sp, #72	; 0x48
   19c62:	a80a      	add	r0, sp, #40	; 0x28
   19c64:	9500      	str	r5, [sp, #0]
   19c66:	f7ff fdf0 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modMult_fast(t6, t6, t5, curve); /* t6 = (y2+y1)*(x3' - B) */
   19c6a:	a90a      	add	r1, sp, #40	; 0x28
   19c6c:	9b22      	ldr	r3, [sp, #136]	; 0x88
   19c6e:	aa02      	add	r2, sp, #8
   19c70:	4608      	mov	r0, r1
   19c72:	f7ff fe99 	bl	199a8 <uECC_vli_modMult_fast>
	/* t2 = (y2+y1)*(x3' - B) - E = y3': */
	uECC_vli_modSub(Y1, t6, Y1, curve->p, num_words);
   19c76:	4623      	mov	r3, r4
   19c78:	464a      	mov	r2, r9
   19c7a:	a90a      	add	r1, sp, #40	; 0x28
   19c7c:	4648      	mov	r0, r9
   19c7e:	9500      	str	r5, [sp, #0]
   19c80:	f7ff fde3 	bl	1984a <uECC_vli_modSub>

	uECC_vli_set(X1, t7, num_words);
   19c84:	462a      	mov	r2, r5
   19c86:	a912      	add	r1, sp, #72	; 0x48
   19c88:	4638      	mov	r0, r7
   19c8a:	f7ff fd76 	bl	1977a <uECC_vli_set>
}
   19c8e:	b01b      	add	sp, #108	; 0x6c
   19c90:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00019c94 <uECC_vli_modInv>:
{
   19c94:	b5f0      	push	{r4, r5, r6, r7, lr}
   19c96:	460f      	mov	r7, r1
   19c98:	b0a1      	sub	sp, #132	; 0x84
   19c9a:	4606      	mov	r6, r0
	if (uECC_vli_isZero(input, num_words)) {
   19c9c:	4619      	mov	r1, r3
   19c9e:	4638      	mov	r0, r7
{
   19ca0:	4615      	mov	r5, r2
   19ca2:	461c      	mov	r4, r3
	if (uECC_vli_isZero(input, num_words)) {
   19ca4:	f7ff fd2f 	bl	19706 <uECC_vli_isZero>
   19ca8:	b120      	cbz	r0, 19cb4 <uECC_vli_modInv+0x20>
		uECC_vli_clear(result, num_words);
   19caa:	4630      	mov	r0, r6
   19cac:	f7ff fd20 	bl	196f0 <uECC_vli_clear>
}
   19cb0:	b021      	add	sp, #132	; 0x84
   19cb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uECC_vli_set(a, input, num_words);
   19cb4:	4622      	mov	r2, r4
   19cb6:	4639      	mov	r1, r7
   19cb8:	4668      	mov	r0, sp
   19cba:	f7ff fd5e 	bl	1977a <uECC_vli_set>
	uECC_vli_set(b, mod, num_words);
   19cbe:	4629      	mov	r1, r5
   19cc0:	a808      	add	r0, sp, #32
   19cc2:	f7ff fd5a 	bl	1977a <uECC_vli_set>
	uECC_vli_clear(u, num_words);
   19cc6:	a810      	add	r0, sp, #64	; 0x40
   19cc8:	4621      	mov	r1, r4
   19cca:	f7ff fd11 	bl	196f0 <uECC_vli_clear>
	u[0] = 1;
   19cce:	2301      	movs	r3, #1
	uECC_vli_clear(v, num_words);
   19cd0:	a818      	add	r0, sp, #96	; 0x60
	u[0] = 1;
   19cd2:	9310      	str	r3, [sp, #64]	; 0x40
	uECC_vli_clear(v, num_words);
   19cd4:	f7ff fd0c 	bl	196f0 <uECC_vli_clear>
	while ((cmpResult = uECC_vli_cmp_unsafe(a, b, num_words)) != 0) {
   19cd8:	4622      	mov	r2, r4
   19cda:	a908      	add	r1, sp, #32
   19cdc:	4668      	mov	r0, sp
   19cde:	f7ff fd58 	bl	19792 <uECC_vli_cmp_unsafe>
   19ce2:	b928      	cbnz	r0, 19cf0 <uECC_vli_modInv+0x5c>
  	uECC_vli_set(result, u, num_words);
   19ce4:	4622      	mov	r2, r4
   19ce6:	a910      	add	r1, sp, #64	; 0x40
   19ce8:	4630      	mov	r0, r6
   19cea:	f7ff fd46 	bl	1977a <uECC_vli_set>
   19cee:	e7df      	b.n	19cb0 <uECC_vli_modInv+0x1c>
		if (EVEN(a)) {
   19cf0:	9b00      	ldr	r3, [sp, #0]
   19cf2:	07da      	lsls	r2, r3, #31
   19cf4:	d409      	bmi.n	19d0a <uECC_vli_modInv+0x76>
			uECC_vli_rshift1(a, num_words);
   19cf6:	4621      	mov	r1, r4
   19cf8:	4668      	mov	r0, sp
   19cfa:	f7ff fc5b 	bl	195b4 <uECC_vli_rshift1>
      			vli_modInv_update(u, mod, num_words);
   19cfe:	4622      	mov	r2, r4
   19d00:	4629      	mov	r1, r5
   19d02:	a810      	add	r0, sp, #64	; 0x40
      			vli_modInv_update(v, mod, num_words);
   19d04:	f7ff fc63 	bl	195ce <vli_modInv_update>
   19d08:	e7e6      	b.n	19cd8 <uECC_vli_modInv+0x44>
    		} else if (EVEN(b)) {
   19d0a:	9b08      	ldr	r3, [sp, #32]
   19d0c:	07db      	lsls	r3, r3, #31
   19d0e:	d407      	bmi.n	19d20 <uECC_vli_modInv+0x8c>
			uECC_vli_rshift1(b, num_words);
   19d10:	4621      	mov	r1, r4
   19d12:	a808      	add	r0, sp, #32
   19d14:	f7ff fc4e 	bl	195b4 <uECC_vli_rshift1>
      			vli_modInv_update(v, mod, num_words);
   19d18:	4622      	mov	r2, r4
   19d1a:	4629      	mov	r1, r5
   19d1c:	a818      	add	r0, sp, #96	; 0x60
   19d1e:	e7f1      	b.n	19d04 <uECC_vli_modInv+0x70>
		} else if (cmpResult > 0) {
   19d20:	2800      	cmp	r0, #0
			uECC_vli_sub(a, a, b, num_words);
   19d22:	4623      	mov	r3, r4
		} else if (cmpResult > 0) {
   19d24:	dd1c      	ble.n	19d60 <uECC_vli_modInv+0xcc>
			uECC_vli_sub(a, a, b, num_words);
   19d26:	aa08      	add	r2, sp, #32
   19d28:	4669      	mov	r1, sp
   19d2a:	4668      	mov	r0, sp
   19d2c:	f7ff fd5b 	bl	197e6 <uECC_vli_sub>
			uECC_vli_rshift1(a, num_words);
   19d30:	4621      	mov	r1, r4
   19d32:	4668      	mov	r0, sp
   19d34:	f7ff fc3e 	bl	195b4 <uECC_vli_rshift1>
			if (uECC_vli_cmp_unsafe(u, v, num_words) < 0) {
   19d38:	4622      	mov	r2, r4
   19d3a:	a918      	add	r1, sp, #96	; 0x60
   19d3c:	a810      	add	r0, sp, #64	; 0x40
   19d3e:	f7ff fd28 	bl	19792 <uECC_vli_cmp_unsafe>
   19d42:	2800      	cmp	r0, #0
   19d44:	da05      	bge.n	19d52 <uECC_vli_modInv+0xbe>
        			uECC_vli_add(u, u, mod, num_words);
   19d46:	a910      	add	r1, sp, #64	; 0x40
   19d48:	4623      	mov	r3, r4
   19d4a:	462a      	mov	r2, r5
   19d4c:	4608      	mov	r0, r1
   19d4e:	f7ff fc19 	bl	19584 <uECC_vli_add>
      			uECC_vli_sub(u, u, v, num_words);
   19d52:	a910      	add	r1, sp, #64	; 0x40
   19d54:	4623      	mov	r3, r4
   19d56:	aa18      	add	r2, sp, #96	; 0x60
   19d58:	4608      	mov	r0, r1
   19d5a:	f7ff fd44 	bl	197e6 <uECC_vli_sub>
   19d5e:	e7ce      	b.n	19cfe <uECC_vli_modInv+0x6a>
      			uECC_vli_sub(b, b, a, num_words);
   19d60:	a908      	add	r1, sp, #32
   19d62:	466a      	mov	r2, sp
   19d64:	4608      	mov	r0, r1
   19d66:	f7ff fd3e 	bl	197e6 <uECC_vli_sub>
      			uECC_vli_rshift1(b, num_words);
   19d6a:	4621      	mov	r1, r4
   19d6c:	a808      	add	r0, sp, #32
   19d6e:	f7ff fc21 	bl	195b4 <uECC_vli_rshift1>
      			if (uECC_vli_cmp_unsafe(v, u, num_words) < 0) {
   19d72:	4622      	mov	r2, r4
   19d74:	a910      	add	r1, sp, #64	; 0x40
   19d76:	a818      	add	r0, sp, #96	; 0x60
   19d78:	f7ff fd0b 	bl	19792 <uECC_vli_cmp_unsafe>
   19d7c:	2800      	cmp	r0, #0
   19d7e:	da05      	bge.n	19d8c <uECC_vli_modInv+0xf8>
        			uECC_vli_add(v, v, mod, num_words);
   19d80:	a918      	add	r1, sp, #96	; 0x60
   19d82:	4623      	mov	r3, r4
   19d84:	462a      	mov	r2, r5
   19d86:	4608      	mov	r0, r1
   19d88:	f7ff fbfc 	bl	19584 <uECC_vli_add>
      			uECC_vli_sub(v, v, u, num_words);
   19d8c:	a918      	add	r1, sp, #96	; 0x60
   19d8e:	4623      	mov	r3, r4
   19d90:	aa10      	add	r2, sp, #64	; 0x40
   19d92:	4608      	mov	r0, r1
   19d94:	f7ff fd27 	bl	197e6 <uECC_vli_sub>
   19d98:	e7be      	b.n	19d18 <uECC_vli_modInv+0x84>

00019d9a <EccPoint_isZero>:
	return uECC_vli_isZero(point, curve->num_words * 2);
   19d9a:	7809      	ldrb	r1, [r1, #0]
   19d9c:	0049      	lsls	r1, r1, #1
   19d9e:	b249      	sxtb	r1, r1
   19da0:	f7ff bcb1 	b.w	19706 <uECC_vli_isZero>

00019da4 <apply_z>:
{
   19da4:	b5f0      	push	{r4, r5, r6, r7, lr}
   19da6:	4615      	mov	r5, r2
   19da8:	b089      	sub	sp, #36	; 0x24
   19daa:	461c      	mov	r4, r3
   19dac:	4607      	mov	r7, r0
   19dae:	460e      	mov	r6, r1
	uECC_vli_modSquare_fast(t1, Z, curve);    /* z^2 */
   19db0:	461a      	mov	r2, r3
   19db2:	4629      	mov	r1, r5
   19db4:	4668      	mov	r0, sp
   19db6:	f7ff fe07 	bl	199c8 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t1, curve); /* x1 * z^2 */
   19dba:	4623      	mov	r3, r4
   19dbc:	466a      	mov	r2, sp
   19dbe:	4639      	mov	r1, r7
   19dc0:	4638      	mov	r0, r7
   19dc2:	f7ff fdf1 	bl	199a8 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(t1, t1, Z, curve);  /* z^3 */
   19dc6:	4623      	mov	r3, r4
   19dc8:	462a      	mov	r2, r5
   19dca:	4669      	mov	r1, sp
   19dcc:	4668      	mov	r0, sp
   19dce:	f7ff fdeb 	bl	199a8 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(Y1, Y1, t1, curve); /* y1 * z^3 */
   19dd2:	4623      	mov	r3, r4
   19dd4:	466a      	mov	r2, sp
   19dd6:	4631      	mov	r1, r6
   19dd8:	4630      	mov	r0, r6
   19dda:	f7ff fde5 	bl	199a8 <uECC_vli_modMult_fast>
}
   19dde:	b009      	add	sp, #36	; 0x24
   19de0:	bdf0      	pop	{r4, r5, r6, r7, pc}

00019de2 <XYcZ_add>:
{
   19de2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   19de6:	b08b      	sub	sp, #44	; 0x2c
   19de8:	4614      	mov	r4, r2
	wordcount_t num_words = curve->num_words;
   19dea:	9d12      	ldr	r5, [sp, #72]	; 0x48
   19dec:	f915 6b04 	ldrsb.w	r6, [r5], #4
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   19df0:	9600      	str	r6, [sp, #0]
{
   19df2:	461f      	mov	r7, r3
   19df4:	4680      	mov	r8, r0
   19df6:	4689      	mov	r9, r1
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   19df8:	462b      	mov	r3, r5
   19dfa:	4602      	mov	r2, r0
   19dfc:	4621      	mov	r1, r4
   19dfe:	a802      	add	r0, sp, #8
   19e00:	f7ff fd23 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
   19e04:	a902      	add	r1, sp, #8
   19e06:	9a12      	ldr	r2, [sp, #72]	; 0x48
   19e08:	4608      	mov	r0, r1
   19e0a:	f7ff fddd 	bl	199c8 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
   19e0e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   19e10:	aa02      	add	r2, sp, #8
   19e12:	4641      	mov	r1, r8
   19e14:	4640      	mov	r0, r8
   19e16:	f7ff fdc7 	bl	199a8 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
   19e1a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   19e1c:	aa02      	add	r2, sp, #8
   19e1e:	4621      	mov	r1, r4
   19e20:	4620      	mov	r0, r4
   19e22:	f7ff fdc1 	bl	199a8 <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
   19e26:	462b      	mov	r3, r5
   19e28:	464a      	mov	r2, r9
   19e2a:	4639      	mov	r1, r7
   19e2c:	4638      	mov	r0, r7
   19e2e:	9600      	str	r6, [sp, #0]
   19e30:	f7ff fd0b 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, Y2, curve); /* t5 = (y2 - y1)^2 = D */
   19e34:	9a12      	ldr	r2, [sp, #72]	; 0x48
   19e36:	4639      	mov	r1, r7
   19e38:	a802      	add	r0, sp, #8
   19e3a:	f7ff fdc5 	bl	199c8 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t5, t5, X1, curve->p, num_words); /* t5 = D - B */
   19e3e:	a902      	add	r1, sp, #8
   19e40:	462b      	mov	r3, r5
   19e42:	4642      	mov	r2, r8
   19e44:	4608      	mov	r0, r1
   19e46:	9600      	str	r6, [sp, #0]
   19e48:	f7ff fcff 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, X2, curve->p, num_words); /* t5 = D - B - C = x3 */
   19e4c:	a902      	add	r1, sp, #8
   19e4e:	462b      	mov	r3, r5
   19e50:	4622      	mov	r2, r4
   19e52:	4608      	mov	r0, r1
   19e54:	9600      	str	r6, [sp, #0]
   19e56:	f7ff fcf8 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modSub(X2, X2, X1, curve->p, num_words); /* t3 = C - B */
   19e5a:	462b      	mov	r3, r5
   19e5c:	4642      	mov	r2, r8
   19e5e:	4621      	mov	r1, r4
   19e60:	4620      	mov	r0, r4
   19e62:	9600      	str	r6, [sp, #0]
   19e64:	f7ff fcf1 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, X2, curve); /* t2 = y1*(C - B) */
   19e68:	9b12      	ldr	r3, [sp, #72]	; 0x48
   19e6a:	4622      	mov	r2, r4
   19e6c:	4649      	mov	r1, r9
   19e6e:	4648      	mov	r0, r9
   19e70:	f7ff fd9a 	bl	199a8 <uECC_vli_modMult_fast>
	uECC_vli_modSub(X2, X1, t5, curve->p, num_words); /* t3 = B - x3 */
   19e74:	462b      	mov	r3, r5
   19e76:	aa02      	add	r2, sp, #8
   19e78:	4641      	mov	r1, r8
   19e7a:	4620      	mov	r0, r4
   19e7c:	9600      	str	r6, [sp, #0]
   19e7e:	f7ff fce4 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, X2, curve); /* t4 = (y2 - y1)*(B - x3) */
   19e82:	9b12      	ldr	r3, [sp, #72]	; 0x48
   19e84:	4622      	mov	r2, r4
   19e86:	4639      	mov	r1, r7
   19e88:	4638      	mov	r0, r7
   19e8a:	f7ff fd8d 	bl	199a8 <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y3 */
   19e8e:	462b      	mov	r3, r5
   19e90:	464a      	mov	r2, r9
   19e92:	4639      	mov	r1, r7
   19e94:	4638      	mov	r0, r7
   19e96:	9600      	str	r6, [sp, #0]
   19e98:	f7ff fcd7 	bl	1984a <uECC_vli_modSub>
	uECC_vli_set(X2, t5, num_words);
   19e9c:	4632      	mov	r2, r6
   19e9e:	a902      	add	r1, sp, #8
   19ea0:	4620      	mov	r0, r4
   19ea2:	f7ff fc6a 	bl	1977a <uECC_vli_set>
}
   19ea6:	b00b      	add	sp, #44	; 0x2c
   19ea8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00019eac <EccPoint_mult>:

void EccPoint_mult(uECC_word_t * result, const uECC_word_t * point,
		   const uECC_word_t * scalar,
		   const uECC_word_t * initial_Z,
		   bitcount_t num_bits, uECC_Curve curve) 
{
   19eac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19eb0:	b0b1      	sub	sp, #196	; 0xc4
   19eb2:	e9cd 0104 	strd	r0, r1, [sp, #16]
   19eb6:	9c3b      	ldr	r4, [sp, #236]	; 0xec
   19eb8:	9206      	str	r2, [sp, #24]
	uECC_word_t Rx[2][NUM_ECC_WORDS];
	uECC_word_t Ry[2][NUM_ECC_WORDS];
	uECC_word_t z[NUM_ECC_WORDS];
	bitcount_t i;
	uECC_word_t nb;
	wordcount_t num_words = curve->num_words;
   19eba:	f994 7000 	ldrsb.w	r7, [r4]

	uECC_vli_set(Rx[1], point, num_words);
   19ebe:	a818      	add	r0, sp, #96	; 0x60
   19ec0:	463a      	mov	r2, r7
{
   19ec2:	461e      	mov	r6, r3
	uECC_vli_set(Rx[1], point, num_words);
   19ec4:	f7ff fc59 	bl	1977a <uECC_vli_set>
  	uECC_vli_set(Ry[1], point + num_words, num_words);
   19ec8:	00bb      	lsls	r3, r7, #2
   19eca:	9307      	str	r3, [sp, #28]
   19ecc:	9b05      	ldr	r3, [sp, #20]
   19ece:	00ba      	lsls	r2, r7, #2
   19ed0:	4413      	add	r3, r2
   19ed2:	4619      	mov	r1, r3
   19ed4:	463a      	mov	r2, r7
   19ed6:	a828      	add	r0, sp, #160	; 0xa0
   19ed8:	9302      	str	r3, [sp, #8]
   19eda:	f7ff fc4e 	bl	1977a <uECC_vli_set>
	wordcount_t num_words = curve->num_words;
   19ede:	f994 5000 	ldrsb.w	r5, [r4]
	if (initial_Z) {
   19ee2:	2e00      	cmp	r6, #0
   19ee4:	f000 8087 	beq.w	19ff6 <EccPoint_mult+0x14a>
		uECC_vli_set(z, initial_Z, num_words);
   19ee8:	462a      	mov	r2, r5
   19eea:	4631      	mov	r1, r6
   19eec:	a808      	add	r0, sp, #32
   19eee:	f7ff fc44 	bl	1977a <uECC_vli_set>
	uECC_vli_set(X2, X1, num_words);
   19ef2:	ae10      	add	r6, sp, #64	; 0x40
   19ef4:	462a      	mov	r2, r5
   19ef6:	a918      	add	r1, sp, #96	; 0x60
   19ef8:	4630      	mov	r0, r6
	uECC_vli_set(Y2, Y1, num_words);
   19efa:	f10d 0980 	add.w	r9, sp, #128	; 0x80
	uECC_vli_set(X2, X1, num_words);
   19efe:	f7ff fc3c 	bl	1977a <uECC_vli_set>
	uECC_vli_set(Y2, Y1, num_words);
   19f02:	a928      	add	r1, sp, #160	; 0xa0
   19f04:	4648      	mov	r0, r9
   19f06:	f7ff fc38 	bl	1977a <uECC_vli_set>
	apply_z(X1, Y1, z, curve);
   19f0a:	4623      	mov	r3, r4
   19f0c:	aa08      	add	r2, sp, #32
   19f0e:	a928      	add	r1, sp, #160	; 0xa0
   19f10:	a818      	add	r0, sp, #96	; 0x60
   19f12:	f7ff ff47 	bl	19da4 <apply_z>
	curve->double_jacobian(X1, Y1, z, curve);
   19f16:	f8d4 50a4 	ldr.w	r5, [r4, #164]	; 0xa4
   19f1a:	4623      	mov	r3, r4
   19f1c:	aa08      	add	r2, sp, #32
   19f1e:	a928      	add	r1, sp, #160	; 0xa0
   19f20:	a818      	add	r0, sp, #96	; 0x60
   19f22:	47a8      	blx	r5
	apply_z(X2, Y2, z, curve);
   19f24:	4623      	mov	r3, r4
   19f26:	aa08      	add	r2, sp, #32
   19f28:	4649      	mov	r1, r9
   19f2a:	4630      	mov	r0, r6
   19f2c:	f7ff ff3a 	bl	19da4 <apply_z>

	XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z, curve);

	for (i = num_bits - 2; i > 0; --i) {
   19f30:	f9bd 50e8 	ldrsh.w	r5, [sp, #232]	; 0xe8
   19f34:	3d02      	subs	r5, #2
   19f36:	b22d      	sxth	r5, r5
   19f38:	2d00      	cmp	r5, #0
   19f3a:	dc63      	bgt.n	1a004 <EccPoint_mult+0x158>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   19f3c:	9b06      	ldr	r3, [sp, #24]
   19f3e:	681d      	ldr	r5, [r3, #0]
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
	}

	nb = !uECC_vli_testBit(scalar, 0);
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   19f40:	9400      	str	r4, [sp, #0]
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   19f42:	f005 0601 	and.w	r6, r5, #1
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   19f46:	ab10      	add	r3, sp, #64	; 0x40
   19f48:	0176      	lsls	r6, r6, #5
   19f4a:	43ed      	mvns	r5, r5
   19f4c:	eb03 0806 	add.w	r8, r3, r6
   19f50:	f005 0501 	and.w	r5, r5, #1
   19f54:	ab20      	add	r3, sp, #128	; 0x80
   19f56:	441e      	add	r6, r3
   19f58:	016d      	lsls	r5, r5, #5
   19f5a:	ab10      	add	r3, sp, #64	; 0x40
   19f5c:	eb03 0905 	add.w	r9, r3, r5
   19f60:	ab20      	add	r3, sp, #128	; 0x80
   19f62:	441d      	add	r5, r3

	/* Find final 1/Z value. */
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
   19f64:	f104 0a04 	add.w	sl, r4, #4
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   19f68:	462b      	mov	r3, r5
   19f6a:	464a      	mov	r2, r9
   19f6c:	4631      	mov	r1, r6
   19f6e:	4640      	mov	r0, r8
   19f70:	f7ff fe04 	bl	19b7c <XYcZ_addC>
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
   19f74:	4653      	mov	r3, sl
   19f76:	aa10      	add	r2, sp, #64	; 0x40
   19f78:	a918      	add	r1, sp, #96	; 0x60
   19f7a:	a808      	add	r0, sp, #32
   19f7c:	9700      	str	r7, [sp, #0]
   19f7e:	f7ff fc64 	bl	1984a <uECC_vli_modSub>
	uECC_vli_modMult_fast(z, z, Ry[1 - nb], curve); /* Yb * (X1 - X0) */
   19f82:	a908      	add	r1, sp, #32
   19f84:	4623      	mov	r3, r4
   19f86:	4632      	mov	r2, r6
   19f88:	4608      	mov	r0, r1
   19f8a:	f7ff fd0d 	bl	199a8 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(z, z, point, curve); /* xP * Yb * (X1 - X0) */
   19f8e:	a908      	add	r1, sp, #32
   19f90:	4623      	mov	r3, r4
   19f92:	9a05      	ldr	r2, [sp, #20]
   19f94:	4608      	mov	r0, r1
   19f96:	f7ff fd07 	bl	199a8 <uECC_vli_modMult_fast>
	uECC_vli_modInv(z, z, curve->p, num_words); /* 1 / (xP * Yb * (X1 - X0))*/
   19f9a:	a908      	add	r1, sp, #32
   19f9c:	463b      	mov	r3, r7
   19f9e:	4652      	mov	r2, sl
   19fa0:	4608      	mov	r0, r1
   19fa2:	f7ff fe77 	bl	19c94 <uECC_vli_modInv>
	/* yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, point + num_words, curve);
   19fa6:	a908      	add	r1, sp, #32
   19fa8:	4623      	mov	r3, r4
   19faa:	9a02      	ldr	r2, [sp, #8]
   19fac:	4608      	mov	r0, r1
   19fae:	f7ff fcfb 	bl	199a8 <uECC_vli_modMult_fast>
	/* Xb * yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, Rx[1 - nb], curve);
   19fb2:	a908      	add	r1, sp, #32
   19fb4:	4623      	mov	r3, r4
   19fb6:	4642      	mov	r2, r8
   19fb8:	4608      	mov	r0, r1
   19fba:	f7ff fcf5 	bl	199a8 <uECC_vli_modMult_fast>
	/* End 1/Z calculation */

	XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
   19fbe:	9400      	str	r4, [sp, #0]
   19fc0:	4633      	mov	r3, r6
   19fc2:	4642      	mov	r2, r8
   19fc4:	4629      	mov	r1, r5
   19fc6:	4648      	mov	r0, r9
   19fc8:	f7ff ff0b 	bl	19de2 <XYcZ_add>
	apply_z(Rx[0], Ry[0], z, curve);
   19fcc:	4623      	mov	r3, r4
   19fce:	aa08      	add	r2, sp, #32
   19fd0:	a920      	add	r1, sp, #128	; 0x80
   19fd2:	a810      	add	r0, sp, #64	; 0x40
   19fd4:	f7ff fee6 	bl	19da4 <apply_z>

	uECC_vli_set(result, Rx[0], num_words);
   19fd8:	463a      	mov	r2, r7
   19fda:	a910      	add	r1, sp, #64	; 0x40
   19fdc:	9804      	ldr	r0, [sp, #16]
   19fde:	f7ff fbcc 	bl	1977a <uECC_vli_set>
	uECC_vli_set(result + num_words, Ry[0], num_words);
   19fe2:	9b04      	ldr	r3, [sp, #16]
   19fe4:	9c07      	ldr	r4, [sp, #28]
   19fe6:	4423      	add	r3, r4
   19fe8:	a920      	add	r1, sp, #128	; 0x80
   19fea:	4618      	mov	r0, r3
   19fec:	f7ff fbc5 	bl	1977a <uECC_vli_set>
}
   19ff0:	b031      	add	sp, #196	; 0xc4
   19ff2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uECC_vli_clear(z, num_words);
   19ff6:	4629      	mov	r1, r5
   19ff8:	a808      	add	r0, sp, #32
   19ffa:	f7ff fb79 	bl	196f0 <uECC_vli_clear>
		z[0] = 1;
   19ffe:	2301      	movs	r3, #1
   1a000:	9308      	str	r3, [sp, #32]
   1a002:	e776      	b.n	19ef2 <EccPoint_mult+0x46>
		nb = !uECC_vli_testBit(scalar, i);
   1a004:	4629      	mov	r1, r5
   1a006:	9806      	ldr	r0, [sp, #24]
   1a008:	f7ff fb8c 	bl	19724 <uECC_vli_testBit>
   1a00c:	fab0 f080 	clz	r0, r0
   1a010:	0940      	lsrs	r0, r0, #5
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   1a012:	f1c0 0801 	rsb	r8, r0, #1
   1a016:	ea4f 1848 	mov.w	r8, r8, lsl #5
   1a01a:	0140      	lsls	r0, r0, #5
   1a01c:	eb06 0b08 	add.w	fp, r6, r8
   1a020:	eb06 0a00 	add.w	sl, r6, r0
   1a024:	44c8      	add	r8, r9
   1a026:	eb09 0300 	add.w	r3, r9, r0
   1a02a:	4652      	mov	r2, sl
   1a02c:	4641      	mov	r1, r8
   1a02e:	4658      	mov	r0, fp
   1a030:	9400      	str	r4, [sp, #0]
   1a032:	9303      	str	r3, [sp, #12]
   1a034:	f7ff fda2 	bl	19b7c <XYcZ_addC>
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
   1a038:	9400      	str	r4, [sp, #0]
   1a03a:	4643      	mov	r3, r8
   1a03c:	465a      	mov	r2, fp
   1a03e:	9903      	ldr	r1, [sp, #12]
   1a040:	4650      	mov	r0, sl
   1a042:	f7ff fece 	bl	19de2 <XYcZ_add>
	for (i = num_bits - 2; i > 0; --i) {
   1a046:	3d01      	subs	r5, #1
   1a048:	e775      	b.n	19f36 <EccPoint_mult+0x8a>

0001a04a <regularize_k>:

uECC_word_t regularize_k(const uECC_word_t * const k, uECC_word_t *k0,
			 uECC_word_t *k1, uECC_Curve curve)
{
   1a04a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   1a04e:	f9b3 4002 	ldrsh.w	r4, [r3, #2]
   1a052:	f114 051f 	adds.w	r5, r4, #31
   1a056:	bf48      	it	mi
   1a058:	f104 053e 	addmi.w	r5, r4, #62	; 0x3e
{
   1a05c:	460f      	mov	r7, r1

	bitcount_t num_n_bits = curve->num_n_bits;

	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   1a05e:	f103 0624 	add.w	r6, r3, #36	; 0x24
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   1a062:	f345 1547 	sbfx	r5, r5, #5, #8
{
   1a066:	4690      	mov	r8, r2
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   1a068:	4601      	mov	r1, r0
   1a06a:	462b      	mov	r3, r5
   1a06c:	4632      	mov	r2, r6
   1a06e:	4638      	mov	r0, r7
   1a070:	f7ff fa88 	bl	19584 <uECC_vli_add>
   1a074:	b990      	cbnz	r0, 1a09c <regularize_k+0x52>
   1a076:	ebb4 1f45 	cmp.w	r4, r5, lsl #5
   1a07a:	da11      	bge.n	1a0a0 <regularize_k+0x56>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
			     uECC_vli_testBit(k0, num_n_bits));
   1a07c:	4621      	mov	r1, r4
   1a07e:	4638      	mov	r0, r7
   1a080:	f7ff fb50 	bl	19724 <uECC_vli_testBit>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
   1a084:	1c04      	adds	r4, r0, #0
   1a086:	bf18      	it	ne
   1a088:	2401      	movne	r4, #1

	uECC_vli_add(k1, k0, curve->n, num_n_words);
   1a08a:	462b      	mov	r3, r5
   1a08c:	4632      	mov	r2, r6
   1a08e:	4639      	mov	r1, r7
   1a090:	4640      	mov	r0, r8
   1a092:	f7ff fa77 	bl	19584 <uECC_vli_add>

	return carry;
}
   1a096:	4620      	mov	r0, r4
   1a098:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   1a09c:	2401      	movs	r4, #1
   1a09e:	e7f4      	b.n	1a08a <regularize_k+0x40>
   1a0a0:	4604      	mov	r4, r0
   1a0a2:	e7f2      	b.n	1a08a <regularize_k+0x40>

0001a0a4 <EccPoint_compute_public_key>:

uECC_word_t EccPoint_compute_public_key(uECC_word_t *result,
					uECC_word_t *private_key,
					uECC_Curve curve)
{
   1a0a4:	b530      	push	{r4, r5, lr}
   1a0a6:	4614      	mov	r4, r2
   1a0a8:	b095      	sub	sp, #84	; 0x54
   1a0aa:	4605      	mov	r5, r0

	uECC_word_t tmp1[NUM_ECC_WORDS];
 	uECC_word_t tmp2[NUM_ECC_WORDS];
	uECC_word_t *p2[2] = {tmp1, tmp2};
   1a0ac:	aa0c      	add	r2, sp, #48	; 0x30
	uECC_word_t carry;

	/* Regularize the bitcount for the private key so that attackers cannot
	 * use a side channel attack to learn the number of leading zeros. */
	carry = regularize_k(private_key, tmp1, tmp2, curve);
   1a0ae:	4623      	mov	r3, r4
{
   1a0b0:	4608      	mov	r0, r1
	uECC_word_t *p2[2] = {tmp1, tmp2};
   1a0b2:	a904      	add	r1, sp, #16
   1a0b4:	9102      	str	r1, [sp, #8]
   1a0b6:	9203      	str	r2, [sp, #12]
	carry = regularize_k(private_key, tmp1, tmp2, curve);
   1a0b8:	f7ff ffc7 	bl	1a04a <regularize_k>

	EccPoint_mult(result, curve->G, p2[!carry], 0, curve->num_n_bits + 1, curve);
   1a0bc:	fab0 f080 	clz	r0, r0
   1a0c0:	ab14      	add	r3, sp, #80	; 0x50
   1a0c2:	0940      	lsrs	r0, r0, #5
   1a0c4:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1a0c8:	8863      	ldrh	r3, [r4, #2]
   1a0ca:	9401      	str	r4, [sp, #4]
   1a0cc:	3301      	adds	r3, #1
   1a0ce:	b21b      	sxth	r3, r3
   1a0d0:	9300      	str	r3, [sp, #0]
   1a0d2:	f850 2c48 	ldr.w	r2, [r0, #-72]
   1a0d6:	2300      	movs	r3, #0
   1a0d8:	f104 0144 	add.w	r1, r4, #68	; 0x44
   1a0dc:	4628      	mov	r0, r5
   1a0de:	f7ff fee5 	bl	19eac <EccPoint_mult>

	if (EccPoint_isZero(result, curve)) {
   1a0e2:	4621      	mov	r1, r4
   1a0e4:	4628      	mov	r0, r5
   1a0e6:	f7ff fe58 	bl	19d9a <EccPoint_isZero>
		return 0;
	}
	return 1;
}
   1a0ea:	fab0 f080 	clz	r0, r0
   1a0ee:	0940      	lsrs	r0, r0, #5
   1a0f0:	b015      	add	sp, #84	; 0x54
   1a0f2:	bd30      	pop	{r4, r5, pc}

0001a0f4 <uECC_vli_nativeToBytes>:

/* Converts an integer in uECC native format to big-endian bytes. */
void uECC_vli_nativeToBytes(uint8_t *bytes, int num_bytes,
			    const unsigned int *native)
{
   1a0f4:	b5f0      	push	{r4, r5, r6, r7, lr}
	wordcount_t i;
	for (i = 0; i < num_bytes; ++i) {
   1a0f6:	2500      	movs	r5, #0
		unsigned b = num_bytes - 1 - i;
   1a0f8:	1e4f      	subs	r7, r1, #1
   1a0fa:	b26c      	sxtb	r4, r5
	for (i = 0; i < num_bytes; ++i) {
   1a0fc:	428c      	cmp	r4, r1
   1a0fe:	f105 0501 	add.w	r5, r5, #1
   1a102:	db00      	blt.n	1a106 <uECC_vli_nativeToBytes+0x12>
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
	}
}
   1a104:	bdf0      	pop	{r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
   1a106:	1b3b      	subs	r3, r7, r4
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
   1a108:	f023 0603 	bic.w	r6, r3, #3
   1a10c:	f003 0303 	and.w	r3, r3, #3
   1a110:	5996      	ldr	r6, [r2, r6]
   1a112:	00db      	lsls	r3, r3, #3
   1a114:	fa26 f303 	lsr.w	r3, r6, r3
   1a118:	5503      	strb	r3, [r0, r4]
   1a11a:	e7ee      	b.n	1a0fa <uECC_vli_nativeToBytes+0x6>

0001a11c <uECC_vli_bytesToNative>:

/* Converts big-endian bytes to an integer in uECC native format. */
void uECC_vli_bytesToNative(unsigned int *native, const uint8_t *bytes,
			    int num_bytes)
{
   1a11c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1a11e:	460e      	mov	r6, r1
	wordcount_t i;
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
   1a120:	1cd1      	adds	r1, r2, #3
   1a122:	bf48      	it	mi
   1a124:	1d91      	addmi	r1, r2, #6
{
   1a126:	4614      	mov	r4, r2
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
   1a128:	f341 0187 	sbfx	r1, r1, #2, #8
{
   1a12c:	4605      	mov	r5, r0
	for (i = 0; i < num_bytes; ++i) {
		unsigned b = num_bytes - 1 - i;
   1a12e:	1e67      	subs	r7, r4, #1
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
   1a130:	f7ff fade 	bl	196f0 <uECC_vli_clear>
	for (i = 0; i < num_bytes; ++i) {
   1a134:	2100      	movs	r1, #0
   1a136:	b24a      	sxtb	r2, r1
   1a138:	42a2      	cmp	r2, r4
   1a13a:	f101 0101 	add.w	r1, r1, #1
   1a13e:	db00      	blt.n	1a142 <uECC_vli_bytesToNative+0x26>
		native[b / uECC_WORD_SIZE] |=
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
  	}
}
   1a140:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
   1a142:	1abb      	subs	r3, r7, r2
		native[b / uECC_WORD_SIZE] |=
   1a144:	f023 0003 	bic.w	r0, r3, #3
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
   1a148:	5cb2      	ldrb	r2, [r6, r2]
   1a14a:	f003 0303 	and.w	r3, r3, #3
   1a14e:	00db      	lsls	r3, r3, #3
   1a150:	fa02 f303 	lsl.w	r3, r2, r3
		native[b / uECC_WORD_SIZE] |=
   1a154:	582a      	ldr	r2, [r5, r0]
   1a156:	431a      	orrs	r2, r3
   1a158:	502a      	str	r2, [r5, r0]
   1a15a:	e7ec      	b.n	1a136 <uECC_vli_bytesToNative+0x1a>

0001a15c <uECC_valid_point>:
	return 0;
}


int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve)
{
   1a15c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a160:	b090      	sub	sp, #64	; 0x40
   1a162:	4606      	mov	r6, r0
   1a164:	460c      	mov	r4, r1
	uECC_word_t tmp1[NUM_ECC_WORDS];
	uECC_word_t tmp2[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
   1a166:	f991 5000 	ldrsb.w	r5, [r1]

	/* The point at infinity is invalid. */
	if (EccPoint_isZero(point, curve)) {
   1a16a:	f7ff fe16 	bl	19d9a <EccPoint_isZero>
   1a16e:	bb40      	cbnz	r0, 1a1c2 <uECC_valid_point+0x66>
		return -1;
	}

	/* x and y must be smaller than p. */
	if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
   1a170:	f104 0804 	add.w	r8, r4, #4
   1a174:	462a      	mov	r2, r5
   1a176:	4631      	mov	r1, r6
   1a178:	4640      	mov	r0, r8
   1a17a:	f7ff fb0a 	bl	19792 <uECC_vli_cmp_unsafe>
   1a17e:	2801      	cmp	r0, #1
   1a180:	d122      	bne.n	1a1c8 <uECC_valid_point+0x6c>
		uECC_vli_cmp_unsafe(curve->p, point + num_words, num_words) != 1) {
   1a182:	eb06 0785 	add.w	r7, r6, r5, lsl #2
   1a186:	462a      	mov	r2, r5
   1a188:	4639      	mov	r1, r7
   1a18a:	4640      	mov	r0, r8
   1a18c:	f7ff fb01 	bl	19792 <uECC_vli_cmp_unsafe>
	if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
   1a190:	2801      	cmp	r0, #1
   1a192:	d119      	bne.n	1a1c8 <uECC_valid_point+0x6c>
		return -2;
	}

	uECC_vli_modSquare_fast(tmp1, point + num_words, curve);
   1a194:	4622      	mov	r2, r4
   1a196:	4668      	mov	r0, sp
   1a198:	f7ff fc16 	bl	199c8 <uECC_vli_modSquare_fast>
	curve->x_side(tmp2, point, curve); /* tmp2 = x^3 + ax + b */
   1a19c:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
   1a1a0:	4622      	mov	r2, r4
   1a1a2:	4631      	mov	r1, r6
   1a1a4:	a808      	add	r0, sp, #32
   1a1a6:	4798      	blx	r3

	/* Make sure that y^2 == x^3 + ax + b */
	if (uECC_vli_equal(tmp1, tmp2, num_words) != 0)
   1a1a8:	462a      	mov	r2, r5
   1a1aa:	a908      	add	r1, sp, #32
   1a1ac:	4668      	mov	r0, sp
   1a1ae:	f7ff fb07 	bl	197c0 <uECC_vli_equal>
   1a1b2:	2800      	cmp	r0, #0
		return -3;
   1a1b4:	bf0c      	ite	eq
   1a1b6:	2000      	moveq	r0, #0
   1a1b8:	f06f 0002 	mvnne.w	r0, #2

	return 0;
}
   1a1bc:	b010      	add	sp, #64	; 0x40
   1a1be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -1;
   1a1c2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1a1c6:	e7f9      	b.n	1a1bc <uECC_valid_point+0x60>
		return -2;
   1a1c8:	f06f 0001 	mvn.w	r0, #1
   1a1cc:	e7f6      	b.n	1a1bc <uECC_valid_point+0x60>

0001a1ce <uECC_valid_public_key>:

int uECC_valid_public_key(const uint8_t *public_key, uECC_Curve curve)
{
   1a1ce:	b570      	push	{r4, r5, r6, lr}
   1a1d0:	460c      	mov	r4, r1
   1a1d2:	b090      	sub	sp, #64	; 0x40

	uECC_word_t _public[NUM_ECC_WORDS * 2];

	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
	uECC_vli_bytesToNative(
	_public + curve->num_words,
   1a1d4:	4625      	mov	r5, r4
	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
   1a1d6:	f991 2001 	ldrsb.w	r2, [r1, #1]
{
   1a1da:	4606      	mov	r6, r0
	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
   1a1dc:	4601      	mov	r1, r0
   1a1de:	4668      	mov	r0, sp
   1a1e0:	f7ff ff9c 	bl	1a11c <uECC_vli_bytesToNative>
	public_key + curve->num_bytes,
   1a1e4:	f994 2001 	ldrsb.w	r2, [r4, #1]
	_public + curve->num_words,
   1a1e8:	f915 0b44 	ldrsb.w	r0, [r5], #68
	uECC_vli_bytesToNative(
   1a1ec:	18b1      	adds	r1, r6, r2
   1a1ee:	eb0d 0080 	add.w	r0, sp, r0, lsl #2
   1a1f2:	f7ff ff93 	bl	1a11c <uECC_vli_bytesToNative>
	curve->num_bytes);

	if (uECC_vli_cmp_unsafe(_public, curve->G, NUM_ECC_WORDS * 2) == 0) {
   1a1f6:	2210      	movs	r2, #16
   1a1f8:	4629      	mov	r1, r5
   1a1fa:	4668      	mov	r0, sp
   1a1fc:	f7ff fac9 	bl	19792 <uECC_vli_cmp_unsafe>
   1a200:	b128      	cbz	r0, 1a20e <uECC_valid_public_key+0x40>
		return -4;
	}

	return uECC_valid_point(_public, curve);
   1a202:	4621      	mov	r1, r4
   1a204:	4668      	mov	r0, sp
   1a206:	f7ff ffa9 	bl	1a15c <uECC_valid_point>
}
   1a20a:	b010      	add	sp, #64	; 0x40
   1a20c:	bd70      	pop	{r4, r5, r6, pc}
		return -4;
   1a20e:	f06f 0003 	mvn.w	r0, #3
   1a212:	e7fa      	b.n	1a20a <uECC_valid_public_key+0x3c>

0001a214 <add_round_key>:
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
   1a214:	78cb      	ldrb	r3, [r1, #3]
   1a216:	7802      	ldrb	r2, [r0, #0]
   1a218:	4053      	eors	r3, r2
   1a21a:	7003      	strb	r3, [r0, #0]
   1a21c:	884b      	ldrh	r3, [r1, #2]
   1a21e:	7842      	ldrb	r2, [r0, #1]
   1a220:	4053      	eors	r3, r2
   1a222:	7043      	strb	r3, [r0, #1]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
   1a224:	680a      	ldr	r2, [r1, #0]
   1a226:	7883      	ldrb	r3, [r0, #2]
   1a228:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   1a22c:	7083      	strb	r3, [r0, #2]
   1a22e:	680a      	ldr	r2, [r1, #0]
   1a230:	78c3      	ldrb	r3, [r0, #3]
   1a232:	4053      	eors	r3, r2
   1a234:	70c3      	strb	r3, [r0, #3]
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
   1a236:	79cb      	ldrb	r3, [r1, #7]
   1a238:	7902      	ldrb	r2, [r0, #4]
   1a23a:	4053      	eors	r3, r2
   1a23c:	7103      	strb	r3, [r0, #4]
   1a23e:	88cb      	ldrh	r3, [r1, #6]
   1a240:	7942      	ldrb	r2, [r0, #5]
   1a242:	4053      	eors	r3, r2
   1a244:	7143      	strb	r3, [r0, #5]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
   1a246:	684a      	ldr	r2, [r1, #4]
   1a248:	7983      	ldrb	r3, [r0, #6]
   1a24a:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   1a24e:	7183      	strb	r3, [r0, #6]
   1a250:	684a      	ldr	r2, [r1, #4]
   1a252:	79c3      	ldrb	r3, [r0, #7]
   1a254:	4053      	eors	r3, r2
   1a256:	71c3      	strb	r3, [r0, #7]
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
   1a258:	7acb      	ldrb	r3, [r1, #11]
   1a25a:	7a02      	ldrb	r2, [r0, #8]
   1a25c:	4053      	eors	r3, r2
   1a25e:	7203      	strb	r3, [r0, #8]
   1a260:	7a42      	ldrb	r2, [r0, #9]
   1a262:	894b      	ldrh	r3, [r1, #10]
   1a264:	4053      	eors	r3, r2
   1a266:	7243      	strb	r3, [r0, #9]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
   1a268:	688a      	ldr	r2, [r1, #8]
   1a26a:	7a83      	ldrb	r3, [r0, #10]
   1a26c:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   1a270:	7283      	strb	r3, [r0, #10]
   1a272:	688a      	ldr	r2, [r1, #8]
   1a274:	7ac3      	ldrb	r3, [r0, #11]
   1a276:	4053      	eors	r3, r2
   1a278:	72c3      	strb	r3, [r0, #11]
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
   1a27a:	7bcb      	ldrb	r3, [r1, #15]
   1a27c:	7b02      	ldrb	r2, [r0, #12]
   1a27e:	4053      	eors	r3, r2
   1a280:	7303      	strb	r3, [r0, #12]
   1a282:	89cb      	ldrh	r3, [r1, #14]
   1a284:	7b42      	ldrb	r2, [r0, #13]
   1a286:	4053      	eors	r3, r2
   1a288:	7343      	strb	r3, [r0, #13]
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
   1a28a:	68ca      	ldr	r2, [r1, #12]
   1a28c:	7b83      	ldrb	r3, [r0, #14]
   1a28e:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   1a292:	7383      	strb	r3, [r0, #14]
   1a294:	68ca      	ldr	r2, [r1, #12]
   1a296:	7bc3      	ldrb	r3, [r0, #15]
   1a298:	4053      	eors	r3, r2
   1a29a:	73c3      	strb	r3, [r0, #15]
}
   1a29c:	4770      	bx	lr

0001a29e <shift_rows>:
{
   1a29e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
   1a2a0:	7802      	ldrb	r2, [r0, #0]
   1a2a2:	f88d 2000 	strb.w	r2, [sp]
   1a2a6:	7942      	ldrb	r2, [r0, #5]
   1a2a8:	f88d 2001 	strb.w	r2, [sp, #1]
   1a2ac:	7a82      	ldrb	r2, [r0, #10]
   1a2ae:	f88d 2002 	strb.w	r2, [sp, #2]
   1a2b2:	7bc2      	ldrb	r2, [r0, #15]
   1a2b4:	f88d 2003 	strb.w	r2, [sp, #3]
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
   1a2b8:	7902      	ldrb	r2, [r0, #4]
   1a2ba:	f88d 2004 	strb.w	r2, [sp, #4]
   1a2be:	7a42      	ldrb	r2, [r0, #9]
   1a2c0:	f88d 2005 	strb.w	r2, [sp, #5]
   1a2c4:	7b82      	ldrb	r2, [r0, #14]
   1a2c6:	f88d 2006 	strb.w	r2, [sp, #6]
   1a2ca:	78c2      	ldrb	r2, [r0, #3]
   1a2cc:	f88d 2007 	strb.w	r2, [sp, #7]
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
   1a2d0:	7a02      	ldrb	r2, [r0, #8]
   1a2d2:	f88d 2008 	strb.w	r2, [sp, #8]
   1a2d6:	7b42      	ldrb	r2, [r0, #13]
   1a2d8:	f88d 2009 	strb.w	r2, [sp, #9]
   1a2dc:	7882      	ldrb	r2, [r0, #2]
   1a2de:	f88d 200a 	strb.w	r2, [sp, #10]
   1a2e2:	79c2      	ldrb	r2, [r0, #7]
   1a2e4:	f88d 200b 	strb.w	r2, [sp, #11]
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
   1a2e8:	7b02      	ldrb	r2, [r0, #12]
   1a2ea:	f88d 200c 	strb.w	r2, [sp, #12]
   1a2ee:	7842      	ldrb	r2, [r0, #1]
   1a2f0:	f88d 200d 	strb.w	r2, [sp, #13]
   1a2f4:	7ac3      	ldrb	r3, [r0, #11]
   1a2f6:	7982      	ldrb	r2, [r0, #6]
   1a2f8:	f88d 200e 	strb.w	r2, [sp, #14]
   1a2fc:	f88d 300f 	strb.w	r3, [sp, #15]
	(void) _copy(s, sizeof(t), t, sizeof(t));
   1a300:	2310      	movs	r3, #16
   1a302:	466a      	mov	r2, sp
   1a304:	4619      	mov	r1, r3
   1a306:	f7ff f879 	bl	193fc <_copy>
}
   1a30a:	b005      	add	sp, #20
   1a30c:	f85d fb04 	ldr.w	pc, [sp], #4

0001a310 <mult_row_column>:
{
   1a310:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1a312:	4606      	mov	r6, r0
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   1a314:	7808      	ldrb	r0, [r1, #0]
{
   1a316:	460c      	mov	r4, r1
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   1a318:	f7ff f87f 	bl	1941a <_double_byte>
   1a31c:	4605      	mov	r5, r0
   1a31e:	7860      	ldrb	r0, [r4, #1]
   1a320:	f7ff f87b 	bl	1941a <_double_byte>
   1a324:	78a2      	ldrb	r2, [r4, #2]
   1a326:	7863      	ldrb	r3, [r4, #1]
   1a328:	4053      	eors	r3, r2
   1a32a:	78e2      	ldrb	r2, [r4, #3]
   1a32c:	4053      	eors	r3, r2
   1a32e:	405d      	eors	r5, r3
   1a330:	4045      	eors	r5, r0
   1a332:	7035      	strb	r5, [r6, #0]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
   1a334:	7860      	ldrb	r0, [r4, #1]
   1a336:	7827      	ldrb	r7, [r4, #0]
   1a338:	f7ff f86f 	bl	1941a <_double_byte>
   1a33c:	4605      	mov	r5, r0
   1a33e:	78a0      	ldrb	r0, [r4, #2]
   1a340:	f7ff f86b 	bl	1941a <_double_byte>
   1a344:	78a3      	ldrb	r3, [r4, #2]
   1a346:	405f      	eors	r7, r3
   1a348:	78e3      	ldrb	r3, [r4, #3]
   1a34a:	405f      	eors	r7, r3
   1a34c:	407d      	eors	r5, r7
   1a34e:	4045      	eors	r5, r0
   1a350:	7075      	strb	r5, [r6, #1]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
   1a352:	78a0      	ldrb	r0, [r4, #2]
   1a354:	7865      	ldrb	r5, [r4, #1]
   1a356:	7827      	ldrb	r7, [r4, #0]
   1a358:	f7ff f85f 	bl	1941a <_double_byte>
   1a35c:	406f      	eors	r7, r5
   1a35e:	4605      	mov	r5, r0
   1a360:	78e0      	ldrb	r0, [r4, #3]
   1a362:	f7ff f85a 	bl	1941a <_double_byte>
   1a366:	78e3      	ldrb	r3, [r4, #3]
   1a368:	405f      	eors	r7, r3
   1a36a:	407d      	eors	r5, r7
   1a36c:	4045      	eors	r5, r0
   1a36e:	70b5      	strb	r5, [r6, #2]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
   1a370:	7820      	ldrb	r0, [r4, #0]
   1a372:	f7ff f852 	bl	1941a <_double_byte>
   1a376:	7863      	ldrb	r3, [r4, #1]
   1a378:	7825      	ldrb	r5, [r4, #0]
   1a37a:	405d      	eors	r5, r3
   1a37c:	78a3      	ldrb	r3, [r4, #2]
   1a37e:	405d      	eors	r5, r3
   1a380:	4045      	eors	r5, r0
   1a382:	78e0      	ldrb	r0, [r4, #3]
   1a384:	f7ff f849 	bl	1941a <_double_byte>
   1a388:	b2ed      	uxtb	r5, r5
   1a38a:	4068      	eors	r0, r5
   1a38c:	70f0      	strb	r0, [r6, #3]
}
   1a38e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001a390 <gf_double>:
 *           the in and out buffers do not overlap.
 *  effects: doubles the GF(2^n) value pointed to by "in" and places
 *           the result in the GF(2^n) value pointed to by "out."
 */
void gf_double(uint8_t *out, uint8_t *in)
{
   1a390:	b510      	push	{r4, lr}

	/* start with low order byte */
	uint8_t *x = in + (TC_AES_BLOCK_SIZE - 1);

	/* if msb == 1, we need to add the gf_wrap value, otherwise add 0 */
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   1a392:	460a      	mov	r2, r1

	out += (TC_AES_BLOCK_SIZE - 1);
   1a394:	300f      	adds	r0, #15
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   1a396:	f912 3b10 	ldrsb.w	r3, [r2], #16
   1a39a:	2b00      	cmp	r3, #0
   1a39c:	bfb4      	ite	lt
   1a39e:	2387      	movlt	r3, #135	; 0x87
   1a3a0:	2300      	movge	r3, #0
	for (;;) {
		*out-- = (*x << 1) ^ carry;
   1a3a2:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
   1a3a6:	ea83 0344 	eor.w	r3, r3, r4, lsl #1
		if (x == in) {
   1a3aa:	4291      	cmp	r1, r2
		*out-- = (*x << 1) ^ carry;
   1a3ac:	f800 3901 	strb.w	r3, [r0], #-1
		if (x == in) {
   1a3b0:	d002      	beq.n	1a3b8 <gf_double+0x28>
			break;
		}
		carry = *x-- >> 7;
   1a3b2:	7813      	ldrb	r3, [r2, #0]
   1a3b4:	09db      	lsrs	r3, r3, #7
		*out-- = (*x << 1) ^ carry;
   1a3b6:	e7f4      	b.n	1a3a2 <gf_double+0x12>
	}
}
   1a3b8:	bd10      	pop	{r4, pc}

0001a3ba <tc_cmac_erase>:

	return TC_CRYPTO_SUCCESS;
}

int tc_cmac_erase(TCCmacState_t s)
{
   1a3ba:	b508      	push	{r3, lr}
	if (s == (TCCmacState_t) 0) {
   1a3bc:	b120      	cbz	r0, 1a3c8 <tc_cmac_erase+0xe>
		return TC_CRYPTO_FAIL;
	}

	/* destroy the current state */
	_set(s, 0, sizeof(*s));
   1a3be:	2258      	movs	r2, #88	; 0x58
   1a3c0:	2100      	movs	r1, #0
   1a3c2:	f7ff f828 	bl	19416 <_set>
   1a3c6:	2001      	movs	r0, #1

	return TC_CRYPTO_SUCCESS;
}
   1a3c8:	bd08      	pop	{r3, pc}

0001a3ca <tc_cmac_init>:

int tc_cmac_init(TCCmacState_t s)
{
   1a3ca:	b510      	push	{r4, lr}
	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   1a3cc:	4604      	mov	r4, r0
   1a3ce:	b188      	cbz	r0, 1a3f4 <tc_cmac_init+0x2a>
		return TC_CRYPTO_FAIL;
	}

	/* CMAC starts with an all zero initialization vector */
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   1a3d0:	2210      	movs	r2, #16
   1a3d2:	2100      	movs	r1, #0
   1a3d4:	f7ff f81f 	bl	19416 <_set>

	/* and the leftover buffer is empty */
	_set(s->leftover, 0, TC_AES_BLOCK_SIZE);
   1a3d8:	2210      	movs	r2, #16
   1a3da:	f104 0030 	add.w	r0, r4, #48	; 0x30
   1a3de:	2100      	movs	r1, #0
   1a3e0:	f7ff f819 	bl	19416 <_set>
	s->leftover_offset = 0;
   1a3e4:	2300      	movs	r3, #0
   1a3e6:	6463      	str	r3, [r4, #68]	; 0x44

	/* Set countdown to max number of calls allowed before re-keying: */
	s->countdown = MAX_CALLS;
   1a3e8:	2200      	movs	r2, #0
   1a3ea:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   1a3ee:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50
   1a3f2:	2001      	movs	r0, #1

	return TC_CRYPTO_SUCCESS;
}
   1a3f4:	bd10      	pop	{r4, pc}

0001a3f6 <tc_cmac_setup>:
{
   1a3f6:	b570      	push	{r4, r5, r6, lr}
   1a3f8:	460d      	mov	r5, r1
   1a3fa:	4616      	mov	r6, r2
	if (s == (TCCmacState_t) 0 ||
   1a3fc:	4604      	mov	r4, r0
   1a3fe:	b310      	cbz	r0, 1a446 <tc_cmac_setup+0x50>
   1a400:	b311      	cbz	r1, 1a448 <tc_cmac_setup+0x52>
	_set(s, 0, sizeof(*s));
   1a402:	2258      	movs	r2, #88	; 0x58
   1a404:	2100      	movs	r1, #0
   1a406:	f7ff f806 	bl	19416 <_set>
	tc_aes128_set_encrypt_key(s->sched, key);
   1a40a:	4629      	mov	r1, r5
	s->sched = sched;
   1a40c:	64a6      	str	r6, [r4, #72]	; 0x48
	tc_aes128_set_encrypt_key(s->sched, key);
   1a40e:	4630      	mov	r0, r6
   1a410:	f7e8 fbae 	bl	2b70 <tc_aes128_set_encrypt_key>
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   1a414:	2210      	movs	r2, #16
   1a416:	2100      	movs	r1, #0
   1a418:	4620      	mov	r0, r4
   1a41a:	f7fe fffc 	bl	19416 <_set>
	gf_double (s->K1, s->iv);
   1a41e:	f104 0510 	add.w	r5, r4, #16
	tc_aes_encrypt(s->iv, s->iv, s->sched);
   1a422:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   1a424:	4621      	mov	r1, r4
   1a426:	4620      	mov	r0, r4
   1a428:	f7e8 fbf8 	bl	2c1c <tc_aes_encrypt>
	gf_double (s->K1, s->iv);
   1a42c:	4621      	mov	r1, r4
   1a42e:	4628      	mov	r0, r5
   1a430:	f7ff ffae 	bl	1a390 <gf_double>
	gf_double (s->K2, s->K1);
   1a434:	4629      	mov	r1, r5
   1a436:	f104 0020 	add.w	r0, r4, #32
   1a43a:	f7ff ffa9 	bl	1a390 <gf_double>
	tc_cmac_init(s);
   1a43e:	4620      	mov	r0, r4
   1a440:	f7ff ffc3 	bl	1a3ca <tc_cmac_init>
	return TC_CRYPTO_SUCCESS;
   1a444:	2001      	movs	r0, #1
}
   1a446:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
   1a448:	4608      	mov	r0, r1
   1a44a:	e7fc      	b.n	1a446 <tc_cmac_setup+0x50>

0001a44c <tc_cmac_update>:

int tc_cmac_update(TCCmacState_t s, const uint8_t *data, size_t data_length)
{
   1a44c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a450:	460d      	mov	r5, r1
   1a452:	4616      	mov	r6, r2
	unsigned int i;

	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   1a454:	4604      	mov	r4, r0
   1a456:	2800      	cmp	r0, #0
   1a458:	d061      	beq.n	1a51e <tc_cmac_update+0xd2>
		return TC_CRYPTO_FAIL;
	}
	if (data_length == 0) {
   1a45a:	b912      	cbnz	r2, 1a462 <tc_cmac_update+0x16>
		/* save leftover data for next time */
		_copy(s->leftover, data_length, data, data_length);
		s->leftover_offset = data_length;
	}

	return TC_CRYPTO_SUCCESS;
   1a45c:	2001      	movs	r0, #1
}
   1a45e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (data == (const uint8_t *) 0) {
   1a462:	2900      	cmp	r1, #0
   1a464:	d05b      	beq.n	1a51e <tc_cmac_update+0xd2>
	if (s->countdown == 0) {
   1a466:	e9d0 0114 	ldrd	r0, r1, [r0, #80]	; 0x50
   1a46a:	ea50 0301 	orrs.w	r3, r0, r1
   1a46e:	d056      	beq.n	1a51e <tc_cmac_update+0xd2>
	s->countdown--;
   1a470:	f110 32ff 	adds.w	r2, r0, #4294967295	; 0xffffffff
	if (s->leftover_offset > 0) {
   1a474:	f8d4 8044 	ldr.w	r8, [r4, #68]	; 0x44
	s->countdown--;
   1a478:	f141 33ff 	adc.w	r3, r1, #4294967295	; 0xffffffff
   1a47c:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50
	if (s->leftover_offset > 0) {
   1a480:	f1b8 0f00 	cmp.w	r8, #0
   1a484:	d02a      	beq.n	1a4dc <tc_cmac_update+0x90>
		size_t remaining_space = TC_AES_BLOCK_SIZE - s->leftover_offset;
   1a486:	f1c8 0710 	rsb	r7, r8, #16
		if (data_length < remaining_space) {
   1a48a:	f108 0030 	add.w	r0, r8, #48	; 0x30
   1a48e:	42be      	cmp	r6, r7
   1a490:	4420      	add	r0, r4
   1a492:	d208      	bcs.n	1a4a6 <tc_cmac_update+0x5a>
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
   1a494:	4633      	mov	r3, r6
   1a496:	4631      	mov	r1, r6
   1a498:	462a      	mov	r2, r5
   1a49a:	f7fe ffaf 	bl	193fc <_copy>
			s->leftover_offset += data_length;
   1a49e:	6c63      	ldr	r3, [r4, #68]	; 0x44
   1a4a0:	441e      	add	r6, r3
		s->leftover_offset = data_length;
   1a4a2:	6466      	str	r6, [r4, #68]	; 0x44
   1a4a4:	e7da      	b.n	1a45c <tc_cmac_update+0x10>
		_copy(&s->leftover[s->leftover_offset],
   1a4a6:	463b      	mov	r3, r7
   1a4a8:	462a      	mov	r2, r5
   1a4aa:	4639      	mov	r1, r7
   1a4ac:	f7fe ffa6 	bl	193fc <_copy>
		data_length -= remaining_space;
   1a4b0:	3e10      	subs	r6, #16
		s->leftover_offset = 0;
   1a4b2:	2300      	movs	r3, #0
   1a4b4:	6463      	str	r3, [r4, #68]	; 0x44
		data_length -= remaining_space;
   1a4b6:	4446      	add	r6, r8
		data += remaining_space;
   1a4b8:	443d      	add	r5, r7
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   1a4ba:	1e63      	subs	r3, r4, #1
   1a4bc:	f104 010f 	add.w	r1, r4, #15
			s->iv[i] ^= s->leftover[i];
   1a4c0:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   1a4c4:	f893 0030 	ldrb.w	r0, [r3, #48]	; 0x30
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   1a4c8:	428b      	cmp	r3, r1
			s->iv[i] ^= s->leftover[i];
   1a4ca:	ea82 0200 	eor.w	r2, r2, r0
   1a4ce:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   1a4d0:	d1f6      	bne.n	1a4c0 <tc_cmac_update+0x74>
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   1a4d2:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   1a4d4:	4621      	mov	r1, r4
   1a4d6:	4620      	mov	r0, r4
   1a4d8:	f7e8 fba0 	bl	2c1c <tc_aes_encrypt>
   1a4dc:	f104 070f 	add.w	r7, r4, #15
	while (data_length > TC_AES_BLOCK_SIZE) {
   1a4e0:	2e10      	cmp	r6, #16
   1a4e2:	d809      	bhi.n	1a4f8 <tc_cmac_update+0xac>
	if (data_length > 0) {
   1a4e4:	2e00      	cmp	r6, #0
   1a4e6:	d0b9      	beq.n	1a45c <tc_cmac_update+0x10>
		_copy(s->leftover, data_length, data, data_length);
   1a4e8:	4633      	mov	r3, r6
   1a4ea:	462a      	mov	r2, r5
   1a4ec:	4631      	mov	r1, r6
   1a4ee:	f104 0030 	add.w	r0, r4, #48	; 0x30
   1a4f2:	f7fe ff83 	bl	193fc <_copy>
   1a4f6:	e7d4      	b.n	1a4a2 <tc_cmac_update+0x56>
   1a4f8:	1e63      	subs	r3, r4, #1
   1a4fa:	1e69      	subs	r1, r5, #1
			s->iv[i] ^= data[i];
   1a4fc:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   1a500:	f811 0f01 	ldrb.w	r0, [r1, #1]!
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   1a504:	42bb      	cmp	r3, r7
			s->iv[i] ^= data[i];
   1a506:	ea82 0200 	eor.w	r2, r2, r0
   1a50a:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   1a50c:	d1f6      	bne.n	1a4fc <tc_cmac_update+0xb0>
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   1a50e:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   1a510:	4621      	mov	r1, r4
   1a512:	4620      	mov	r0, r4
   1a514:	f7e8 fb82 	bl	2c1c <tc_aes_encrypt>
		data += TC_AES_BLOCK_SIZE;
   1a518:	3510      	adds	r5, #16
		data_length  -= TC_AES_BLOCK_SIZE;
   1a51a:	3e10      	subs	r6, #16
   1a51c:	e7e0      	b.n	1a4e0 <tc_cmac_update+0x94>
		return TC_CRYPTO_FAIL;
   1a51e:	2000      	movs	r0, #0
   1a520:	e79d      	b.n	1a45e <tc_cmac_update+0x12>

0001a522 <tc_cmac_final>:

int tc_cmac_final(uint8_t *tag, TCCmacState_t s)
{
   1a522:	b570      	push	{r4, r5, r6, lr}
   1a524:	460c      	mov	r4, r1
	uint8_t *k;
	unsigned int i;

	/* input sanity check: */
	if (tag == (uint8_t *) 0 ||
   1a526:	4605      	mov	r5, r0
   1a528:	b1e8      	cbz	r0, 1a566 <tc_cmac_final+0x44>
   1a52a:	b369      	cbz	r1, 1a588 <tc_cmac_final+0x66>
	    s == (TCCmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	if (s->leftover_offset == TC_AES_BLOCK_SIZE) {
   1a52c:	6c4a      	ldr	r2, [r1, #68]	; 0x44
   1a52e:	2a10      	cmp	r2, #16
   1a530:	d11a      	bne.n	1a568 <tc_cmac_final+0x46>
		/* the last message block is a full-sized block */
		k = (uint8_t *) s->K1;
   1a532:	3110      	adds	r1, #16

		_set(&s->leftover[s->leftover_offset], 0, remaining);
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
		k = (uint8_t *) s->K2;
	}
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   1a534:	1e63      	subs	r3, r4, #1
   1a536:	3901      	subs	r1, #1
   1a538:	f104 000f 	add.w	r0, r4, #15
		s->iv[i] ^= s->leftover[i] ^ k[i];
   1a53c:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   1a540:	f893 6030 	ldrb.w	r6, [r3, #48]	; 0x30
   1a544:	4072      	eors	r2, r6
   1a546:	f811 6f01 	ldrb.w	r6, [r1, #1]!
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   1a54a:	4298      	cmp	r0, r3
		s->iv[i] ^= s->leftover[i] ^ k[i];
   1a54c:	ea82 0206 	eor.w	r2, r2, r6
   1a550:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   1a552:	d1f3      	bne.n	1a53c <tc_cmac_final+0x1a>
	}

	tc_aes_encrypt(tag, s->iv, s->sched);
   1a554:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   1a556:	4621      	mov	r1, r4
   1a558:	4628      	mov	r0, r5
   1a55a:	f7e8 fb5f 	bl	2c1c <tc_aes_encrypt>

	/* erasing state: */
	tc_cmac_erase(s);
   1a55e:	4620      	mov	r0, r4
   1a560:	f7ff ff2b 	bl	1a3ba <tc_cmac_erase>

	return TC_CRYPTO_SUCCESS;
   1a564:	2001      	movs	r0, #1
}
   1a566:	bd70      	pop	{r4, r5, r6, pc}
		_set(&s->leftover[s->leftover_offset], 0, remaining);
   1a568:	f102 0030 	add.w	r0, r2, #48	; 0x30
   1a56c:	2100      	movs	r1, #0
   1a56e:	f1c2 0210 	rsb	r2, r2, #16
   1a572:	4420      	add	r0, r4
   1a574:	f7fe ff4f 	bl	19416 <_set>
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
   1a578:	6c63      	ldr	r3, [r4, #68]	; 0x44
   1a57a:	4423      	add	r3, r4
   1a57c:	2280      	movs	r2, #128	; 0x80
   1a57e:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
		k = (uint8_t *) s->K2;
   1a582:	f104 0120 	add.w	r1, r4, #32
   1a586:	e7d5      	b.n	1a534 <tc_cmac_final+0x12>
		return TC_CRYPTO_FAIL;
   1a588:	4608      	mov	r0, r1
   1a58a:	e7ec      	b.n	1a566 <tc_cmac_final+0x44>

0001a58c <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
   1a58c:	2300      	movs	r3, #0
	list->head = NULL;
   1a58e:	e9c0 3300 	strd	r3, r3, [r0]
}
   1a592:	4770      	bx	lr

0001a594 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
   1a594:	6803      	ldr	r3, [r0, #0]
   1a596:	b923      	cbnz	r3, 1a5a2 <log_list_add_tail+0xe>
		list->head = msg;
   1a598:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
   1a59a:	2300      	movs	r3, #0
	list->tail = msg;
   1a59c:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
   1a59e:	600b      	str	r3, [r1, #0]
}
   1a5a0:	4770      	bx	lr
		list->tail->next = msg;
   1a5a2:	6843      	ldr	r3, [r0, #4]
   1a5a4:	6019      	str	r1, [r3, #0]
   1a5a6:	e7f8      	b.n	1a59a <log_list_add_tail+0x6>

0001a5a8 <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
   1a5a8:	6800      	ldr	r0, [r0, #0]
   1a5aa:	4770      	bx	lr

0001a5ac <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
	struct log_msg *msg = list->head;
   1a5ac:	6803      	ldr	r3, [r0, #0]

	if (list->head != NULL) {
   1a5ae:	b10b      	cbz	r3, 1a5b4 <log_list_head_get+0x8>
		list->head = list->head->next;
   1a5b0:	681a      	ldr	r2, [r3, #0]
   1a5b2:	6002      	str	r2, [r0, #0]
	}

	return msg;
}
   1a5b4:	4618      	mov	r0, r3
   1a5b6:	4770      	bx	lr

0001a5b8 <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
   1a5b8:	b508      	push	{r3, lr}
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   1a5ba:	f7e8 fe2f 	bl	321c <log_msg_chunk_alloc>

	if (msg != NULL) {
   1a5be:	b118      	cbz	r0, 1a5c8 <z_log_msg_std_alloc+0x10>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
   1a5c0:	2301      	movs	r3, #1
   1a5c2:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
   1a5c4:	2300      	movs	r3, #0
   1a5c6:	8103      	strh	r3, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
	}

	return msg;
}
   1a5c8:	bd08      	pop	{r3, pc}

0001a5ca <k_cycle_get_32_wrapper>:
#ifndef _ASMLANGUAGE
extern u32_t z_timer_cycle_get_32(void);

static inline u32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
   1a5ca:	f7e9 be49 	b.w	4260 <z_timer_cycle_get_32>

0001a5ce <dummy_timestamp>:
   1a5ce:	2000      	movs	r0, #0
   1a5d0:	4770      	bx	lr

0001a5d2 <z_log_get_s_mask>:
	u32_t mask = 0;
   1a5d2:	2300      	movs	r3, #0
{
   1a5d4:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32_t arg = 0;
   1a5d6:	461a      	mov	r2, r3
	bool arm = false;
   1a5d8:	461c      	mov	r4, r3
				mask |= BIT(arg);
   1a5da:	2701      	movs	r7, #1
	while ((curr = *str++) && arg < nargs) {
   1a5dc:	f810 5b01 	ldrb.w	r5, [r0], #1
   1a5e0:	b10d      	cbz	r5, 1a5e6 <z_log_get_s_mask+0x14>
   1a5e2:	428a      	cmp	r2, r1
   1a5e4:	d301      	bcc.n	1a5ea <z_log_get_s_mask+0x18>
}
   1a5e6:	4618      	mov	r0, r3
   1a5e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (curr == '%') {
   1a5ea:	2d25      	cmp	r5, #37	; 0x25
   1a5ec:	d102      	bne.n	1a5f4 <z_log_get_s_mask+0x22>
			arm = !arm;
   1a5ee:	f084 0401 	eor.w	r4, r4, #1
   1a5f2:	e7f3      	b.n	1a5dc <z_log_get_s_mask+0xa>
		} else if (arm && isalpha((int)curr)) {
   1a5f4:	2c00      	cmp	r4, #0
   1a5f6:	d0f1      	beq.n	1a5dc <z_log_get_s_mask+0xa>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
}

static inline int isalpha(int c)
{
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   1a5f8:	f045 0620 	orr.w	r6, r5, #32
   1a5fc:	3e61      	subs	r6, #97	; 0x61
   1a5fe:	2e19      	cmp	r6, #25
   1a600:	d8ec      	bhi.n	1a5dc <z_log_get_s_mask+0xa>
			if (curr == 's') {
   1a602:	2d73      	cmp	r5, #115	; 0x73
				mask |= BIT(arg);
   1a604:	bf04      	itt	eq
   1a606:	fa07 f402 	lsleq.w	r4, r7, r2
   1a60a:	4323      	orreq	r3, r4
			arg++;
   1a60c:	3201      	adds	r2, #1
			arm = false;
   1a60e:	2400      	movs	r4, #0
   1a610:	e7e4      	b.n	1a5dc <z_log_get_s_mask+0xa>

0001a612 <log_0>:
{
   1a612:	b538      	push	{r3, r4, r5, lr}
   1a614:	4605      	mov	r5, r0
   1a616:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
   1a618:	f7ff ffce 	bl	1a5b8 <z_log_msg_std_alloc>

	if (msg != NULL) {
   1a61c:	b128      	cbz	r0, 1a62a <log_0+0x18>
		msg->str = str;
   1a61e:	6105      	str	r5, [r0, #16]
		msg_finalize(msg, src_level);
   1a620:	4621      	mov	r1, r4
}
   1a622:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		msg_finalize(msg, src_level);
   1a626:	f7e8 bd1b 	b.w	3060 <msg_finalize>
}
   1a62a:	bd38      	pop	{r3, r4, r5, pc}

0001a62c <log_1>:
{
   1a62c:	b570      	push	{r4, r5, r6, lr}
   1a62e:	4604      	mov	r4, r0
   1a630:	460e      	mov	r6, r1
   1a632:	4615      	mov	r5, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   1a634:	f7ff ffc0 	bl	1a5b8 <z_log_msg_std_alloc>

	if (msg != NULL) {
   1a638:	b158      	cbz	r0, 1a652 <log_1+0x26>
		msg->str = str;
   1a63a:	6104      	str	r4, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
   1a63c:	7a44      	ldrb	r4, [r0, #9]
		msg->payload.single.args[0] = arg1;
   1a63e:	6146      	str	r6, [r0, #20]
		msg->hdr.params.std.nargs = 1U;
   1a640:	2201      	movs	r2, #1
   1a642:	f362 1407 	bfi	r4, r2, #4, #4
   1a646:	7244      	strb	r4, [r0, #9]
		msg_finalize(msg, src_level);
   1a648:	4629      	mov	r1, r5
}
   1a64a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		msg_finalize(msg, src_level);
   1a64e:	f7e8 bd07 	b.w	3060 <msg_finalize>
}
   1a652:	bd70      	pop	{r4, r5, r6, pc}

0001a654 <log_2>:
{
   1a654:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a658:	4605      	mov	r5, r0
   1a65a:	4688      	mov	r8, r1
   1a65c:	4617      	mov	r7, r2
   1a65e:	461e      	mov	r6, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   1a660:	f7ff ffaa 	bl	1a5b8 <z_log_msg_std_alloc>

	if (msg != NULL) {
   1a664:	b160      	cbz	r0, 1a680 <log_2+0x2c>
		msg->str = str;
   1a666:	6105      	str	r5, [r0, #16]
		msg->hdr.params.std.nargs = 2U;
   1a668:	7a45      	ldrb	r5, [r0, #9]
   1a66a:	2302      	movs	r3, #2
   1a66c:	f363 1507 	bfi	r5, r3, #4, #4
   1a670:	7245      	strb	r5, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   1a672:	e9c0 8705 	strd	r8, r7, [r0, #20]
		msg_finalize(msg, src_level);
   1a676:	4631      	mov	r1, r6
}
   1a678:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		msg_finalize(msg, src_level);
   1a67c:	f7e8 bcf0 	b.w	3060 <msg_finalize>
}
   1a680:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0001a684 <log_3>:
{
   1a684:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1a688:	4605      	mov	r5, r0
   1a68a:	4689      	mov	r9, r1
   1a68c:	4690      	mov	r8, r2
   1a68e:	461f      	mov	r7, r3
   1a690:	f8bd 6020 	ldrh.w	r6, [sp, #32]
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   1a694:	f7ff ff90 	bl	1a5b8 <z_log_msg_std_alloc>

	if (msg != NULL) {
   1a698:	b168      	cbz	r0, 1a6b6 <log_3+0x32>
		msg->str = str;
   1a69a:	6105      	str	r5, [r0, #16]
		msg->hdr.params.std.nargs = 3U;
   1a69c:	7a45      	ldrb	r5, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
		msg->payload.single.args[2] = arg3;
   1a69e:	61c7      	str	r7, [r0, #28]
		msg->hdr.params.std.nargs = 3U;
   1a6a0:	2303      	movs	r3, #3
   1a6a2:	f363 1507 	bfi	r5, r3, #4, #4
   1a6a6:	7245      	strb	r5, [r0, #9]
		msg->payload.single.args[1] = arg2;
   1a6a8:	e9c0 9805 	strd	r9, r8, [r0, #20]
		msg_finalize(msg, src_level);
   1a6ac:	4631      	mov	r1, r6
}
   1a6ae:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		msg_finalize(msg, src_level);
   1a6b2:	f7e8 bcd5 	b.w	3060 <msg_finalize>
}
   1a6b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0001a6ba <log_n>:
{
   1a6ba:	b510      	push	{r4, lr}
   1a6bc:	461c      	mov	r4, r3
		struct log_msg *msg = log_msg_create_n(str, args, narg);
   1a6be:	f000 f83c 	bl	1a73a <log_msg_create_n>
		if (msg == NULL) {
   1a6c2:	b120      	cbz	r0, 1a6ce <log_n+0x14>
		msg_finalize(msg, src_level);
   1a6c4:	4621      	mov	r1, r4
}
   1a6c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		msg_finalize(msg, src_level);
   1a6ca:	f7e8 bcc9 	b.w	3060 <msg_finalize>
}
   1a6ce:	bd10      	pop	{r4, pc}

0001a6d0 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
   1a6d0:	7a40      	ldrb	r0, [r0, #9]
}
   1a6d2:	0900      	lsrs	r0, r0, #4
   1a6d4:	4770      	bx	lr

0001a6d6 <log_msg_arg_get>:
log_arg_t log_msg_arg_get(struct log_msg *msg, u32_t arg_idx)
{
	log_arg_t arg;

	/* Return early if requested argument not present in the message. */
	if (arg_idx >= msg->hdr.params.std.nargs) {
   1a6d6:	7a43      	ldrb	r3, [r0, #9]
   1a6d8:	091b      	lsrs	r3, r3, #4
   1a6da:	428b      	cmp	r3, r1
   1a6dc:	d916      	bls.n	1a70c <log_msg_arg_get+0x36>
		return 0;
	}

	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   1a6de:	2b03      	cmp	r3, #3
   1a6e0:	d803      	bhi.n	1a6ea <log_msg_arg_get+0x14>
		arg = msg->payload.single.args[arg_idx];
   1a6e2:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   1a6e6:	6948      	ldr	r0, [r1, #20]
   1a6e8:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
   1a6ea:	2901      	cmp	r1, #1
   1a6ec:	d803      	bhi.n	1a6f6 <log_msg_arg_get+0x20>
		return msg->payload.ext.data.args[arg_idx];
   1a6ee:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   1a6f2:	6988      	ldr	r0, [r1, #24]
   1a6f4:	4770      	bx	lr
	cont = msg->payload.ext.next;
   1a6f6:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
   1a6f8:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
   1a6fa:	2906      	cmp	r1, #6
   1a6fc:	d803      	bhi.n	1a706 <log_msg_arg_get+0x30>
	return cont->payload.args[arg_idx];
   1a6fe:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   1a702:	6848      	ldr	r0, [r1, #4]
   1a704:	4770      	bx	lr
		arg_idx -= ARGS_CONT_MSG;
   1a706:	3907      	subs	r1, #7
		cont = cont->next;
   1a708:	681b      	ldr	r3, [r3, #0]
   1a70a:	e7f6      	b.n	1a6fa <log_msg_arg_get+0x24>
		return 0;
   1a70c:	2000      	movs	r0, #0
	} else {
		arg = cont_arg_get(msg, arg_idx);
	}

	return arg;
}
   1a70e:	4770      	bx	lr

0001a710 <log_msg_put>:
{
   1a710:	4603      	mov	r3, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   1a712:	1d02      	adds	r2, r0, #4
   1a714:	f3bf 8f5b 	dmb	ish
   1a718:	e852 1f00 	ldrex	r1, [r2]
   1a71c:	3901      	subs	r1, #1
   1a71e:	e842 1c00 	strex	ip, r1, [r2]
   1a722:	f1bc 0f00 	cmp.w	ip, #0
   1a726:	d1f7      	bne.n	1a718 <log_msg_put+0x8>
   1a728:	f3bf 8f5b 	dmb	ish
	if (msg->hdr.ref_cnt == 0) {
   1a72c:	685b      	ldr	r3, [r3, #4]
   1a72e:	b90b      	cbnz	r3, 1a734 <log_msg_put+0x24>
		msg_free(msg);
   1a730:	f7e8 bd86 	b.w	3240 <msg_free>
}
   1a734:	4770      	bx	lr

0001a736 <log_msg_str_get>:

const char *log_msg_str_get(struct log_msg *msg)
{
	return msg->str;
}
   1a736:	6900      	ldr	r0, [r0, #16]
   1a738:	4770      	bx	lr

0001a73a <log_msg_create_n>:
		cont = cont->next;
	}
}

struct log_msg *log_msg_create_n(const char *str, log_arg_t *args, u32_t nargs)
{
   1a73a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a73e:	4682      	mov	sl, r0
   1a740:	4688      	mov	r8, r1
   1a742:	4615      	mov	r5, r2
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   1a744:	f7e8 fd6a 	bl	321c <log_msg_chunk_alloc>
	if (msg != NULL) {
   1a748:	4604      	mov	r4, r0
   1a74a:	b330      	cbz	r0, 1a79a <log_msg_create_n+0x60>
		msg->hdr.ref_cnt = 1;
   1a74c:	2301      	movs	r3, #1
		msg->hdr.params.raw = 0U;
   1a74e:	2600      	movs	r6, #0
	if ((msg == NULL) || nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   1a750:	2d03      	cmp	r5, #3
		msg->hdr.ref_cnt = 1;
   1a752:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
   1a754:	8106      	strh	r6, [r0, #8]
   1a756:	d909      	bls.n	1a76c <log_msg_create_n+0x32>
	msg->hdr.params.generic.ext = 1;
   1a758:	2202      	movs	r2, #2
   1a75a:	8102      	strh	r2, [r0, #8]
	n -= LOG_MSG_NARGS_HEAD_CHUNK;
   1a75c:	f1a5 0902 	sub.w	r9, r5, #2
	next = &msg->payload.ext.next;
   1a760:	f100 0b14 	add.w	fp, r0, #20
	*next = NULL;
   1a764:	6146      	str	r6, [r0, #20]
	while (n > 0) {
   1a766:	f1b9 0f00 	cmp.w	r9, #0
   1a76a:	dc0e      	bgt.n	1a78a <log_msg_create_n+0x50>

	msg = msg_alloc(nargs);

	if (msg != NULL) {
		msg->str = str;
		msg->hdr.params.std.nargs = nargs;
   1a76c:	7a63      	ldrb	r3, [r4, #9]
		msg->str = str;
   1a76e:	f8c4 a010 	str.w	sl, [r4, #16]
		msg->hdr.params.std.nargs = nargs;
   1a772:	f365 1307 	bfi	r3, r5, #4, #4
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
   1a776:	2d03      	cmp	r5, #3
		msg->hdr.params.std.nargs = nargs;
   1a778:	7263      	strb	r3, [r4, #9]
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
   1a77a:	d818      	bhi.n	1a7ae <log_msg_create_n+0x74>
		(void)memcpy(msg->payload.single.args, args,
   1a77c:	00aa      	lsls	r2, r5, #2
   1a77e:	4641      	mov	r1, r8
   1a780:	f104 0014 	add.w	r0, r4, #20
   1a784:	f000 fc39 	bl	1affa <memcpy>
		nargs  = 0U;
   1a788:	e007      	b.n	1a79a <log_msg_create_n+0x60>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
   1a78a:	f7e8 fd47 	bl	321c <log_msg_chunk_alloc>
		if (cont == NULL) {
   1a78e:	4607      	mov	r7, r0
   1a790:	b930      	cbnz	r0, 1a7a0 <log_msg_create_n+0x66>
			msg_free(msg);
   1a792:	4620      	mov	r0, r4
   1a794:	f7e8 fd54 	bl	3240 <msg_free>
			return NULL;
   1a798:	463c      	mov	r4, r7
		copy_args_to_msg(msg, args, nargs);
	}

	return msg;
}
   1a79a:	4620      	mov	r0, r4
   1a79c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		*next = cont;
   1a7a0:	f8cb 0000 	str.w	r0, [fp]
		cont->next = NULL;
   1a7a4:	f1a9 0907 	sub.w	r9, r9, #7
   1a7a8:	6006      	str	r6, [r0, #0]
		next = &cont->next;
   1a7aa:	4683      	mov	fp, r0
		n -= ARGS_CONT_MSG;
   1a7ac:	e7db      	b.n	1a766 <log_msg_create_n+0x2c>
		(void)memcpy(msg->payload.ext.data.args, args,
   1a7ae:	4641      	mov	r1, r8
   1a7b0:	2208      	movs	r2, #8
   1a7b2:	f104 0018 	add.w	r0, r4, #24
	struct log_msg_cont *cont = msg->payload.ext.next;
   1a7b6:	6967      	ldr	r7, [r4, #20]
		(void)memcpy(msg->payload.ext.data.args, args,
   1a7b8:	f000 fc1f 	bl	1affa <memcpy>
		nargs -= LOG_MSG_NARGS_HEAD_CHUNK;
   1a7bc:	3d02      	subs	r5, #2
		args += LOG_MSG_NARGS_HEAD_CHUNK;
   1a7be:	f108 0808 	add.w	r8, r8, #8
		u32_t cpy_args = MIN(nargs, ARGS_CONT_MSG);
   1a7c2:	2d07      	cmp	r5, #7
   1a7c4:	462e      	mov	r6, r5
   1a7c6:	bf28      	it	cs
   1a7c8:	2607      	movcs	r6, #7
		(void)memcpy(cont->payload.args, args,
   1a7ca:	ea4f 0986 	mov.w	r9, r6, lsl #2
   1a7ce:	4641      	mov	r1, r8
   1a7d0:	1d38      	adds	r0, r7, #4
   1a7d2:	464a      	mov	r2, r9
   1a7d4:	f000 fc11 	bl	1affa <memcpy>
	while (nargs != 0U) {
   1a7d8:	1bad      	subs	r5, r5, r6
		args += cpy_args;
   1a7da:	44c8      	add	r8, r9
		cont = cont->next;
   1a7dc:	683f      	ldr	r7, [r7, #0]
	while (nargs != 0U) {
   1a7de:	d1f0      	bne.n	1a7c2 <log_msg_create_n+0x88>
   1a7e0:	e7db      	b.n	1a79a <log_msg_create_n+0x60>

0001a7e2 <read_str>:
{
   1a7e2:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	return bt_gatt_attr_read(conn, attr, buf, len, offset, attr->user_data,
   1a7e6:	68cd      	ldr	r5, [r1, #12]
{
   1a7e8:	4606      	mov	r6, r0
				 strlen(attr->user_data));
   1a7ea:	4628      	mov	r0, r5
{
   1a7ec:	4698      	mov	r8, r3
   1a7ee:	460c      	mov	r4, r1
   1a7f0:	4617      	mov	r7, r2
				 strlen(attr->user_data));
   1a7f2:	f000 fbd0 	bl	1af96 <strlen>
	return bt_gatt_attr_read(conn, attr, buf, len, offset, attr->user_data,
   1a7f6:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   1a7fa:	9300      	str	r3, [sp, #0]
   1a7fc:	b280      	uxth	r0, r0
   1a7fe:	e9cd 5001 	strd	r5, r0, [sp, #4]
   1a802:	4643      	mov	r3, r8
   1a804:	463a      	mov	r2, r7
   1a806:	4621      	mov	r1, r4
   1a808:	4630      	mov	r0, r6
   1a80a:	f001 fdb8 	bl	1c37e <bt_gatt_attr_read>
}
   1a80e:	b004      	add	sp, #16
   1a810:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0001a814 <bas_init>:
static int bas_init(struct device *dev)
{
	ARG_UNUSED(dev);

	return 0;
}
   1a814:	2000      	movs	r0, #0
   1a816:	4770      	bx	lr

0001a818 <flash_write_protection_set>:
	return api->write_protection(dev, enable);
   1a818:	6843      	ldr	r3, [r0, #4]
   1a81a:	68db      	ldr	r3, [r3, #12]
   1a81c:	4718      	bx	r3

0001a81e <nvs_flash_rd>:
{
   1a81e:	b470      	push	{r4, r5, r6}
	offset += addr & ADDR_OFFS_MASK;
   1a820:	6806      	ldr	r6, [r0, #0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   1a822:	8984      	ldrh	r4, [r0, #12]
	rc = flash_read(fs->flash_device, offset, data, len);
   1a824:	6a80      	ldr	r0, [r0, #40]	; 0x28
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   1a826:	0c0d      	lsrs	r5, r1, #16
	offset += addr & ADDR_OFFS_MASK;
   1a828:	fa16 f181 	uxtah	r1, r6, r1
   1a82c:	fb05 1104 	mla	r1, r5, r4, r1
	return api->read(dev, offset, data, len);
   1a830:	6844      	ldr	r4, [r0, #4]
   1a832:	6824      	ldr	r4, [r4, #0]
   1a834:	46a4      	mov	ip, r4
}
   1a836:	bc70      	pop	{r4, r5, r6}
   1a838:	4760      	bx	ip

0001a83a <nvs_flash_block_cmp>:
{
   1a83a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   1a83e:	7c05      	ldrb	r5, [r0, #16]
   1a840:	426d      	negs	r5, r5
{
   1a842:	b089      	sub	sp, #36	; 0x24
   1a844:	4681      	mov	r9, r0
   1a846:	460f      	mov	r7, r1
   1a848:	4690      	mov	r8, r2
   1a84a:	461c      	mov	r4, r3
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   1a84c:	f005 0520 	and.w	r5, r5, #32
	while (len) {
   1a850:	b91c      	cbnz	r4, 1a85a <nvs_flash_block_cmp+0x20>
	return 0;
   1a852:	4620      	mov	r0, r4
}
   1a854:	b009      	add	sp, #36	; 0x24
   1a856:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		bytes_to_cmp = MIN(block_size, len);
   1a85a:	42ac      	cmp	r4, r5
   1a85c:	4626      	mov	r6, r4
   1a85e:	bf28      	it	cs
   1a860:	462e      	movcs	r6, r5
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_cmp);
   1a862:	4633      	mov	r3, r6
   1a864:	466a      	mov	r2, sp
   1a866:	4639      	mov	r1, r7
   1a868:	4648      	mov	r0, r9
   1a86a:	f7ff ffd8 	bl	1a81e <nvs_flash_rd>
		if (rc) {
   1a86e:	2800      	cmp	r0, #0
   1a870:	d1f0      	bne.n	1a854 <nvs_flash_block_cmp+0x1a>
		rc = memcmp(data8, buf, bytes_to_cmp);
   1a872:	4632      	mov	r2, r6
   1a874:	4669      	mov	r1, sp
   1a876:	4640      	mov	r0, r8
   1a878:	f000 fbaf 	bl	1afda <memcmp>
		if (rc) {
   1a87c:	b918      	cbnz	r0, 1a886 <nvs_flash_block_cmp+0x4c>
		len -= bytes_to_cmp;
   1a87e:	1ba4      	subs	r4, r4, r6
		addr += bytes_to_cmp;
   1a880:	4437      	add	r7, r6
		data8 += bytes_to_cmp;
   1a882:	44b0      	add	r8, r6
   1a884:	e7e4      	b.n	1a850 <nvs_flash_block_cmp+0x16>
			return 1;
   1a886:	2001      	movs	r0, #1
   1a888:	e7e4      	b.n	1a854 <nvs_flash_block_cmp+0x1a>

0001a88a <nvs_ate_crc8_check>:
{
   1a88a:	b510      	push	{r4, lr}
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   1a88c:	4601      	mov	r1, r0
{
   1a88e:	4604      	mov	r4, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   1a890:	2207      	movs	r2, #7
   1a892:	20ff      	movs	r0, #255	; 0xff
   1a894:	f7e8 f80a 	bl	28ac <crc8_ccitt>
	if (crc8 == entry->crc8) {
   1a898:	79e3      	ldrb	r3, [r4, #7]
}
   1a89a:	1a18      	subs	r0, r3, r0
   1a89c:	bf18      	it	ne
   1a89e:	2001      	movne	r0, #1
   1a8a0:	bd10      	pop	{r4, pc}

0001a8a2 <nvs_ate_crc8_update>:
{
   1a8a2:	b510      	push	{r4, lr}
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   1a8a4:	4601      	mov	r1, r0
{
   1a8a6:	4604      	mov	r4, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   1a8a8:	2207      	movs	r2, #7
   1a8aa:	20ff      	movs	r0, #255	; 0xff
   1a8ac:	f7e7 fffe 	bl	28ac <crc8_ccitt>
	entry->crc8 = crc8;
   1a8b0:	71e0      	strb	r0, [r4, #7]
}
   1a8b2:	bd10      	pop	{r4, pc}

0001a8b4 <nvs_al_size.isra.1>:
	if (fs->write_block_size <= 1U) {
   1a8b4:	2801      	cmp	r0, #1
	return (len + (fs->write_block_size - 1U)) & ~(fs->write_block_size - 1U);
   1a8b6:	bf81      	itttt	hi
   1a8b8:	f100 33ff 	addhi.w	r3, r0, #4294967295	; 0xffffffff
   1a8bc:	18c9      	addhi	r1, r1, r3
   1a8be:	4240      	neghi	r0, r0
   1a8c0:	4001      	andhi	r1, r0
}
   1a8c2:	4608      	mov	r0, r1
   1a8c4:	4770      	bx	lr

0001a8c6 <nvs_sector_advance.isra.2>:
	*addr += (1 << ADDR_SECT_SHIFT);
   1a8c6:	680b      	ldr	r3, [r1, #0]
   1a8c8:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
	if ((*addr >> ADDR_SECT_SHIFT) == fs->sector_count) {
   1a8cc:	0c1a      	lsrs	r2, r3, #16
   1a8ce:	4282      	cmp	r2, r0
		*addr -= (fs->sector_count << ADDR_SECT_SHIFT);
   1a8d0:	bf08      	it	eq
   1a8d2:	eba3 4302 	subeq.w	r3, r3, r2, lsl #16
   1a8d6:	600b      	str	r3, [r1, #0]
}
   1a8d8:	4770      	bx	lr

0001a8da <nvs_flash_cmp_const.constprop.6>:
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   1a8da:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   1a8de:	7c04      	ldrb	r4, [r0, #16]
   1a8e0:	4264      	negs	r4, r4
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   1a8e2:	b088      	sub	sp, #32
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   1a8e4:	f004 0420 	and.w	r4, r4, #32
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   1a8e8:	4680      	mov	r8, r0
   1a8ea:	460e      	mov	r6, r1
   1a8ec:	4615      	mov	r5, r2
	(void)memset(cmp, value, block_size);
   1a8ee:	21ff      	movs	r1, #255	; 0xff
   1a8f0:	4622      	mov	r2, r4
   1a8f2:	4668      	mov	r0, sp
   1a8f4:	f000 fbab 	bl	1b04e <memset>
	while (len) {
   1a8f8:	b91d      	cbnz	r5, 1a902 <nvs_flash_cmp_const.constprop.6+0x28>
	return 0;
   1a8fa:	4628      	mov	r0, r5
}
   1a8fc:	b008      	add	sp, #32
   1a8fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		bytes_to_cmp = MIN(block_size, len);
   1a902:	42ac      	cmp	r4, r5
   1a904:	4627      	mov	r7, r4
   1a906:	bf28      	it	cs
   1a908:	462f      	movcs	r7, r5
		rc = nvs_flash_block_cmp(fs, addr, cmp, bytes_to_cmp);
   1a90a:	463b      	mov	r3, r7
   1a90c:	466a      	mov	r2, sp
   1a90e:	4631      	mov	r1, r6
   1a910:	4640      	mov	r0, r8
   1a912:	f7ff ff92 	bl	1a83a <nvs_flash_block_cmp>
		if (rc) {
   1a916:	2800      	cmp	r0, #0
   1a918:	d1f0      	bne.n	1a8fc <nvs_flash_cmp_const.constprop.6+0x22>
		len -= bytes_to_cmp;
   1a91a:	1bed      	subs	r5, r5, r7
		addr += bytes_to_cmp;
   1a91c:	443e      	add	r6, r7
   1a91e:	e7eb      	b.n	1a8f8 <nvs_flash_cmp_const.constprop.6+0x1e>

0001a920 <nvs_flash_erase_sector>:
{
   1a920:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	addr &= ADDR_SECT_MASK;
   1a924:	0c0d      	lsrs	r5, r1, #16
   1a926:	042d      	lsls	r5, r5, #16
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
   1a928:	8982      	ldrh	r2, [r0, #12]
   1a92a:	4629      	mov	r1, r5
{
   1a92c:	4604      	mov	r4, r0
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
   1a92e:	f7ff ffd4 	bl	1a8da <nvs_flash_cmp_const.constprop.6>
	if (rc <= 0) {
   1a932:	1e06      	subs	r6, r0, #0
   1a934:	dd17      	ble.n	1a966 <nvs_flash_erase_sector+0x46>
	rc = flash_write_protection_set(fs->flash_device, 0);
   1a936:	2100      	movs	r1, #0
   1a938:	6aa0      	ldr	r0, [r4, #40]	; 0x28
	offset = fs->offset;
   1a93a:	6827      	ldr	r7, [r4, #0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   1a93c:	f8b4 800c 	ldrh.w	r8, [r4, #12]
	rc = flash_write_protection_set(fs->flash_device, 0);
   1a940:	f7ff ff6a 	bl	1a818 <flash_write_protection_set>
	if (rc) {
   1a944:	4606      	mov	r6, r0
   1a946:	b970      	cbnz	r0, 1a966 <nvs_flash_erase_sector+0x46>
	rc = flash_erase(fs->flash_device, offset, fs->sector_size);
   1a948:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   1a94a:	89a2      	ldrh	r2, [r4, #12]
	return api->erase(dev, offset, size);
   1a94c:	6843      	ldr	r3, [r0, #4]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   1a94e:	0c29      	lsrs	r1, r5, #16
   1a950:	689b      	ldr	r3, [r3, #8]
   1a952:	fb08 7101 	mla	r1, r8, r1, r7
   1a956:	4798      	blx	r3
	if (rc) {
   1a958:	4606      	mov	r6, r0
   1a95a:	b920      	cbnz	r0, 1a966 <nvs_flash_erase_sector+0x46>
	(void) flash_write_protection_set(fs->flash_device, 1);
   1a95c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
	return api->write_protection(dev, enable);
   1a95e:	6843      	ldr	r3, [r0, #4]
   1a960:	2101      	movs	r1, #1
   1a962:	68db      	ldr	r3, [r3, #12]
   1a964:	4798      	blx	r3
}
   1a966:	4630      	mov	r0, r6
   1a968:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0001a96c <nvs_flash_al_wrt.part.4>:
static int nvs_flash_al_wrt(struct nvs_fs *fs, u32_t addr, const void *data,
   1a96c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1a970:	4604      	mov	r4, r0
   1a972:	b088      	sub	sp, #32
   1a974:	460e      	mov	r6, r1
	offset = fs->offset;
   1a976:	f8d0 a000 	ldr.w	sl, [r0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   1a97a:	8987      	ldrh	r7, [r0, #12]
	rc = flash_write_protection_set(fs->flash_device, 0);
   1a97c:	6a80      	ldr	r0, [r0, #40]	; 0x28
   1a97e:	2100      	movs	r1, #0
static int nvs_flash_al_wrt(struct nvs_fs *fs, u32_t addr, const void *data,
   1a980:	4690      	mov	r8, r2
   1a982:	461d      	mov	r5, r3
	rc = flash_write_protection_set(fs->flash_device, 0);
   1a984:	f7ff ff48 	bl	1a818 <flash_write_protection_set>
	if (rc) {
   1a988:	bb78      	cbnz	r0, 1a9ea <nvs_flash_al_wrt.part.4+0x7e>
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   1a98a:	ea4f 4916 	mov.w	r9, r6, lsr #16
	offset += addr & ADDR_OFFS_MASK;
   1a98e:	fa1a f686 	uxtah	r6, sl, r6
   1a992:	fb07 6909 	mla	r9, r7, r9, r6
	blen = len & ~(fs->write_block_size - 1U);
   1a996:	7c26      	ldrb	r6, [r4, #16]
   1a998:	4276      	negs	r6, r6
	if (blen > 0) {
   1a99a:	402e      	ands	r6, r5
   1a99c:	d00b      	beq.n	1a9b6 <nvs_flash_al_wrt.part.4+0x4a>
		rc = flash_write(fs->flash_device, offset, data8, blen);
   1a99e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
	return api->write(dev, offset, data, len);
   1a9a0:	6843      	ldr	r3, [r0, #4]
   1a9a2:	4642      	mov	r2, r8
   1a9a4:	685f      	ldr	r7, [r3, #4]
   1a9a6:	4649      	mov	r1, r9
   1a9a8:	4633      	mov	r3, r6
   1a9aa:	47b8      	blx	r7
		if (rc) {
   1a9ac:	4607      	mov	r7, r0
   1a9ae:	b9b8      	cbnz	r0, 1a9e0 <nvs_flash_al_wrt.part.4+0x74>
		len -= blen;
   1a9b0:	1bad      	subs	r5, r5, r6
		offset += blen;
   1a9b2:	44b1      	add	r9, r6
		data8 += blen;
   1a9b4:	44b0      	add	r8, r6
	if (len) {
   1a9b6:	b1dd      	cbz	r5, 1a9f0 <nvs_flash_al_wrt.part.4+0x84>
		memcpy(buf, data8, len);
   1a9b8:	462a      	mov	r2, r5
   1a9ba:	4641      	mov	r1, r8
   1a9bc:	4668      	mov	r0, sp
   1a9be:	f000 fb1c 	bl	1affa <memcpy>
		(void)memset(buf + len, 0xff, fs->write_block_size - len);
   1a9c2:	7c22      	ldrb	r2, [r4, #16]
   1a9c4:	21ff      	movs	r1, #255	; 0xff
   1a9c6:	1b52      	subs	r2, r2, r5
   1a9c8:	eb0d 0005 	add.w	r0, sp, r5
   1a9cc:	f000 fb3f 	bl	1b04e <memset>
		rc = flash_write(fs->flash_device, offset, buf,
   1a9d0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   1a9d2:	7c23      	ldrb	r3, [r4, #16]
   1a9d4:	6842      	ldr	r2, [r0, #4]
   1a9d6:	4649      	mov	r1, r9
   1a9d8:	6855      	ldr	r5, [r2, #4]
   1a9da:	466a      	mov	r2, sp
   1a9dc:	47a8      	blx	r5
   1a9de:	4607      	mov	r7, r0
	(void) flash_write_protection_set(fs->flash_device, 1);
   1a9e0:	2101      	movs	r1, #1
   1a9e2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   1a9e4:	f7ff ff18 	bl	1a818 <flash_write_protection_set>
	return rc;
   1a9e8:	4638      	mov	r0, r7
}
   1a9ea:	b008      	add	sp, #32
   1a9ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
   1a9f0:	462f      	mov	r7, r5
   1a9f2:	e7f5      	b.n	1a9e0 <nvs_flash_al_wrt.part.4+0x74>

0001a9f4 <nvs_flash_ate_wrt>:
{
   1a9f4:	b510      	push	{r4, lr}
   1a9f6:	2308      	movs	r3, #8
   1a9f8:	460a      	mov	r2, r1
   1a9fa:	6841      	ldr	r1, [r0, #4]
   1a9fc:	4604      	mov	r4, r0
   1a9fe:	f7ff ffb5 	bl	1a96c <nvs_flash_al_wrt.part.4>
	fs->ate_wra -= nvs_al_size(fs, sizeof(struct nvs_ate));
   1aa02:	2108      	movs	r1, #8
   1aa04:	4602      	mov	r2, r0
   1aa06:	7c20      	ldrb	r0, [r4, #16]
   1aa08:	f7ff ff54 	bl	1a8b4 <nvs_al_size.isra.1>
   1aa0c:	6863      	ldr	r3, [r4, #4]
   1aa0e:	1a18      	subs	r0, r3, r0
   1aa10:	6060      	str	r0, [r4, #4]
}
   1aa12:	4610      	mov	r0, r2
   1aa14:	bd10      	pop	{r4, pc}

0001aa16 <nvs_delete>:
	return nvs_write(fs, id, NULL, 0);
   1aa16:	2300      	movs	r3, #0
   1aa18:	461a      	mov	r2, r3
   1aa1a:	f7e8 bf5f 	b.w	38dc <nvs_write>

0001aa1e <nvs_read>:

ssize_t nvs_read(struct nvs_fs *fs, u16_t id, void *data, size_t len)
{
   1aa1e:	b513      	push	{r0, r1, r4, lr}
	int rc;

	rc = nvs_read_hist(fs, id, data, len, 0);
   1aa20:	2400      	movs	r4, #0
   1aa22:	9400      	str	r4, [sp, #0]
   1aa24:	f7e9 f840 	bl	3aa8 <nvs_read_hist>
	return rc;
}
   1aa28:	b002      	add	sp, #8
   1aa2a:	bd10      	pop	{r4, pc}

0001aa2c <get_sectors_cb>:
{
   1aa2c:	b570      	push	{r4, r5, r6, lr}
	if (info->start_offset < data->area_off) {
   1aa2e:	6802      	ldr	r2, [r0, #0]
   1aa30:	684c      	ldr	r4, [r1, #4]
   1aa32:	42a2      	cmp	r2, r4
   1aa34:	d316      	bcc.n	1aa64 <get_sectors_cb+0x38>
	} else if (info->start_offset >= data->area_off + data->area_len) {
   1aa36:	688b      	ldr	r3, [r1, #8]
   1aa38:	4423      	add	r3, r4
   1aa3a:	429a      	cmp	r2, r3
   1aa3c:	d206      	bcs.n	1aa4c <get_sectors_cb+0x20>
	} else if (data->ret_idx >= data->ret_len) {
   1aa3e:	e9d1 3504 	ldrd	r3, r5, [r1, #16]
   1aa42:	42ab      	cmp	r3, r5
   1aa44:	d304      	bcc.n	1aa50 <get_sectors_cb+0x24>
		data->status = -ENOMEM;
   1aa46:	f06f 030b 	mvn.w	r3, #11
   1aa4a:	618b      	str	r3, [r1, #24]
		*bail_value = false;
   1aa4c:	2000      	movs	r0, #0
   1aa4e:	e00a      	b.n	1aa66 <get_sectors_cb+0x3a>
	ret[data->ret_idx].fs_off = info->start_offset - data->area_off;
   1aa50:	68cd      	ldr	r5, [r1, #12]
   1aa52:	1b12      	subs	r2, r2, r4
   1aa54:	eb05 06c3 	add.w	r6, r5, r3, lsl #3
   1aa58:	f845 2033 	str.w	r2, [r5, r3, lsl #3]
	ret[data->ret_idx].fs_size = info->size;
   1aa5c:	6842      	ldr	r2, [r0, #4]
   1aa5e:	6072      	str	r2, [r6, #4]
	data->ret_idx++;
   1aa60:	3301      	adds	r3, #1
   1aa62:	610b      	str	r3, [r1, #16]
		*bail_value = true;
   1aa64:	2001      	movs	r0, #1
}
   1aa66:	bd70      	pop	{r4, r5, r6, pc}

0001aa68 <settings_load>:
	return settings_load_subtree(NULL);
   1aa68:	2000      	movs	r0, #0
   1aa6a:	f7e9 b91f 	b.w	3cac <settings_load_subtree>

0001aa6e <settings_delete>:
	return settings_save_one(name, NULL, 0);
   1aa6e:	2200      	movs	r2, #0
   1aa70:	4611      	mov	r1, r2
   1aa72:	f7e9 b8d3 	b.w	3c1c <settings_save_one>

0001aa76 <settings_name_steq>:
{
   1aa76:	b530      	push	{r4, r5, lr}
	if (next) {
   1aa78:	b10a      	cbz	r2, 1aa7e <settings_name_steq+0x8>
		*next = NULL;
   1aa7a:	2300      	movs	r3, #0
   1aa7c:	6013      	str	r3, [r2, #0]
	if ((!name) || (!key)) {
   1aa7e:	b190      	cbz	r0, 1aaa6 <settings_name_steq+0x30>
   1aa80:	b151      	cbz	r1, 1aa98 <settings_name_steq+0x22>
   1aa82:	1e4d      	subs	r5, r1, #1
	while ((*key != '\0') && (*key == *name) &&
   1aa84:	f815 4f01 	ldrb.w	r4, [r5, #1]!
   1aa88:	4603      	mov	r3, r0
   1aa8a:	f810 1b01 	ldrb.w	r1, [r0], #1
   1aa8e:	b15c      	cbz	r4, 1aaa8 <settings_name_steq+0x32>
   1aa90:	428c      	cmp	r4, r1
   1aa92:	d101      	bne.n	1aa98 <settings_name_steq+0x22>
	       (*name != '\0') && (*name != SETTINGS_NAME_END)) {
   1aa94:	2c3d      	cmp	r4, #61	; 0x3d
   1aa96:	d1f5      	bne.n	1aa84 <settings_name_steq+0xe>
	return 0;
   1aa98:	2000      	movs	r0, #0
   1aa9a:	e004      	b.n	1aaa6 <settings_name_steq+0x30>
	if ((*name == SETTINGS_NAME_END) || (*name == '\0')) {
   1aa9c:	293d      	cmp	r1, #61	; 0x3d
   1aa9e:	d008      	beq.n	1aab2 <settings_name_steq+0x3c>
   1aaa0:	fab1 f081 	clz	r0, r1
   1aaa4:	0940      	lsrs	r0, r0, #5
}
   1aaa6:	bd30      	pop	{r4, r5, pc}
	if (*name == SETTINGS_NAME_SEPARATOR) {
   1aaa8:	292f      	cmp	r1, #47	; 0x2f
   1aaaa:	d1f7      	bne.n	1aa9c <settings_name_steq+0x26>
		if (next) {
   1aaac:	b10a      	cbz	r2, 1aab2 <settings_name_steq+0x3c>
			*next = name + 1;
   1aaae:	3301      	adds	r3, #1
   1aab0:	6013      	str	r3, [r2, #0]
		return 1;
   1aab2:	2001      	movs	r0, #1
   1aab4:	e7f7      	b.n	1aaa6 <settings_name_steq+0x30>

0001aab6 <settings_name_next>:
{
   1aab6:	b530      	push	{r4, r5, lr}
   1aab8:	4603      	mov	r3, r0
	if (next) {
   1aaba:	b109      	cbz	r1, 1aac0 <settings_name_next+0xa>
		*next = NULL;
   1aabc:	2200      	movs	r2, #0
   1aabe:	600a      	str	r2, [r1, #0]
	if (!name) {
   1aac0:	b16b      	cbz	r3, 1aade <settings_name_next+0x28>
   1aac2:	461a      	mov	r2, r3
   1aac4:	4614      	mov	r4, r2
   1aac6:	1ad0      	subs	r0, r2, r3
	while ((*name != '\0') && (*name != SETTINGS_NAME_END) &&
   1aac8:	f812 5b01 	ldrb.w	r5, [r2], #1
   1aacc:	b135      	cbz	r5, 1aadc <settings_name_next+0x26>
   1aace:	2d3d      	cmp	r5, #61	; 0x3d
   1aad0:	d004      	beq.n	1aadc <settings_name_next+0x26>
   1aad2:	2d2f      	cmp	r5, #47	; 0x2f
   1aad4:	d1f6      	bne.n	1aac4 <settings_name_next+0xe>
		if (next) {
   1aad6:	b109      	cbz	r1, 1aadc <settings_name_next+0x26>
			*next = name + 1;
   1aad8:	3401      	adds	r4, #1
   1aada:	600c      	str	r4, [r1, #0]
}
   1aadc:	bd30      	pop	{r4, r5, pc}
		return 0;
   1aade:	4618      	mov	r0, r3
   1aae0:	e7fc      	b.n	1aadc <settings_name_next+0x26>

0001aae2 <settings_nvs_read_fn>:
{
   1aae2:	b510      	push	{r4, lr}
	rc = nvs_read(rd_fn_arg->fs, rd_fn_arg->id, data, len);
   1aae4:	4613      	mov	r3, r2
{
   1aae6:	4614      	mov	r4, r2
	rc = nvs_read(rd_fn_arg->fs, rd_fn_arg->id, data, len);
   1aae8:	460a      	mov	r2, r1
   1aaea:	8881      	ldrh	r1, [r0, #4]
   1aaec:	6800      	ldr	r0, [r0, #0]
   1aaee:	f7ff ff96 	bl	1aa1e <nvs_read>
}
   1aaf2:	42a0      	cmp	r0, r4
   1aaf4:	bfa8      	it	ge
   1aaf6:	4620      	movge	r0, r4
   1aaf8:	bd10      	pop	{r4, pc}

0001aafa <settings_nvs_save>:
{
   1aafa:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1aafe:	b097      	sub	sp, #92	; 0x5c
   1ab00:	4604      	mov	r4, r0
   1ab02:	9201      	str	r2, [sp, #4]
   1ab04:	469b      	mov	fp, r3
	if (!name) {
   1ab06:	468a      	mov	sl, r1
   1ab08:	2900      	cmp	r1, #0
   1ab0a:	d067      	beq.n	1abdc <settings_nvs_save+0xe2>
	delete = ((value == NULL) || (val_len == 0));
   1ab0c:	b1da      	cbz	r2, 1ab46 <settings_nvs_save+0x4c>
   1ab0e:	fabb f78b 	clz	r7, fp
   1ab12:	097f      	lsrs	r7, r7, #5
	name_id = cf->last_name_id + 1;
   1ab14:	8ea5      	ldrh	r5, [r4, #52]	; 0x34
   1ab16:	3501      	adds	r5, #1
   1ab18:	b2ad      	uxth	r5, r5
	write_name_id = cf->last_name_id + 1;
   1ab1a:	46a8      	mov	r8, r5
		rc = nvs_read(&cf->cf_nvs, name_id, &rdname, sizeof(rdname));
   1ab1c:	f104 0908 	add.w	r9, r4, #8
		name_id--;
   1ab20:	1e6e      	subs	r6, r5, #1
   1ab22:	b2b6      	uxth	r6, r6
		if (name_id == NVS_NAMECNT_ID) {
   1ab24:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
   1ab28:	d02e      	beq.n	1ab88 <settings_nvs_save+0x8e>
		rc = nvs_read(&cf->cf_nvs, name_id, &rdname, sizeof(rdname));
   1ab2a:	234a      	movs	r3, #74	; 0x4a
   1ab2c:	aa03      	add	r2, sp, #12
   1ab2e:	4631      	mov	r1, r6
   1ab30:	4648      	mov	r0, r9
   1ab32:	f7ff ff74 	bl	1aa1e <nvs_read>
		if (rc < 0) {
   1ab36:	2800      	cmp	r0, #0
   1ab38:	da07      	bge.n	1ab4a <settings_nvs_save+0x50>
			if (rc == -ENOENT) {
   1ab3a:	f110 0f02 	cmn.w	r0, #2
   1ab3e:	bf08      	it	eq
   1ab40:	46b0      	moveq	r8, r6
   1ab42:	4635      	mov	r5, r6
   1ab44:	e7ec      	b.n	1ab20 <settings_nvs_save+0x26>
	delete = ((value == NULL) || (val_len == 0));
   1ab46:	2701      	movs	r7, #1
   1ab48:	e7e4      	b.n	1ab14 <settings_nvs_save+0x1a>
		rdname[rc] = '\0';
   1ab4a:	ab16      	add	r3, sp, #88	; 0x58
   1ab4c:	4418      	add	r0, r3
   1ab4e:	2300      	movs	r3, #0
   1ab50:	f800 3c4c 	strb.w	r3, [r0, #-76]
		if (strcmp(name, rdname)) {
   1ab54:	a903      	add	r1, sp, #12
   1ab56:	4650      	mov	r0, sl
   1ab58:	f000 fa24 	bl	1afa4 <strcmp>
   1ab5c:	2800      	cmp	r0, #0
   1ab5e:	d1f0      	bne.n	1ab42 <settings_nvs_save+0x48>
		if ((delete) && (name_id == cf->last_name_id)) {
   1ab60:	2f00      	cmp	r7, #0
   1ab62:	d039      	beq.n	1abd8 <settings_nvs_save+0xde>
   1ab64:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   1ab66:	42b3      	cmp	r3, r6
   1ab68:	d140      	bne.n	1abec <settings_nvs_save+0xf2>
			cf->last_name_id--;
   1ab6a:	4622      	mov	r2, r4
   1ab6c:	1e73      	subs	r3, r6, #1
   1ab6e:	f822 3f34 	strh.w	r3, [r2, #52]!
			rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID,
   1ab72:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   1ab76:	2302      	movs	r3, #2
   1ab78:	4648      	mov	r0, r9
   1ab7a:	f7e8 feaf 	bl	38dc <nvs_write>
			if (rc < 0) {
   1ab7e:	2800      	cmp	r0, #0
   1ab80:	da34      	bge.n	1abec <settings_nvs_save+0xf2>
}
   1ab82:	b017      	add	sp, #92	; 0x5c
   1ab84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (delete) {
   1ab88:	bb5f      	cbnz	r7, 1abe2 <settings_nvs_save+0xe8>
	write_name = true;
   1ab8a:	2701      	movs	r7, #1
	if (write_name_id == NVS_NAMECNT_ID + NVS_NAME_ID_OFFSET) {
   1ab8c:	f5b8 4f40 	cmp.w	r8, #49152	; 0xc000
   1ab90:	d029      	beq.n	1abe6 <settings_nvs_save+0xec>
	rc = nvs_write(&cf->cf_nvs, write_name_id + NVS_NAME_ID_OFFSET,
   1ab92:	f104 0508 	add.w	r5, r4, #8
   1ab96:	f508 4180 	add.w	r1, r8, #16384	; 0x4000
   1ab9a:	465b      	mov	r3, fp
   1ab9c:	9a01      	ldr	r2, [sp, #4]
   1ab9e:	b289      	uxth	r1, r1
   1aba0:	4628      	mov	r0, r5
   1aba2:	f7e8 fe9b 	bl	38dc <nvs_write>
	if (write_name) {
   1aba6:	b157      	cbz	r7, 1abbe <settings_nvs_save+0xc4>
		rc = nvs_write(&cf->cf_nvs, write_name_id, name, strlen(name));
   1aba8:	4650      	mov	r0, sl
   1abaa:	f000 f9f4 	bl	1af96 <strlen>
   1abae:	4652      	mov	r2, sl
   1abb0:	4603      	mov	r3, r0
   1abb2:	4641      	mov	r1, r8
   1abb4:	4628      	mov	r0, r5
   1abb6:	f7e8 fe91 	bl	38dc <nvs_write>
		if (rc < 0) {
   1abba:	2800      	cmp	r0, #0
   1abbc:	dbe1      	blt.n	1ab82 <settings_nvs_save+0x88>
	if (write_name_id > cf->last_name_id) {
   1abbe:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   1abc0:	4543      	cmp	r3, r8
   1abc2:	d220      	bcs.n	1ac06 <settings_nvs_save+0x10c>
		cf->last_name_id = write_name_id;
   1abc4:	4622      	mov	r2, r4
		rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID, &cf->last_name_id,
   1abc6:	2302      	movs	r3, #2
		cf->last_name_id = write_name_id;
   1abc8:	f822 8f34 	strh.w	r8, [r2, #52]!
		rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID, &cf->last_name_id,
   1abcc:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   1abd0:	4628      	mov	r0, r5
   1abd2:	f7e8 fe83 	bl	38dc <nvs_write>
   1abd6:	e016      	b.n	1ac06 <settings_nvs_save+0x10c>
   1abd8:	46b0      	mov	r8, r6
   1abda:	e7d7      	b.n	1ab8c <settings_nvs_save+0x92>
		return -EINVAL;
   1abdc:	f06f 0015 	mvn.w	r0, #21
   1abe0:	e7cf      	b.n	1ab82 <settings_nvs_save+0x88>
		return 0;
   1abe2:	2000      	movs	r0, #0
   1abe4:	e7cd      	b.n	1ab82 <settings_nvs_save+0x88>
		return -ENOMEM;
   1abe6:	f06f 000b 	mvn.w	r0, #11
   1abea:	e7ca      	b.n	1ab82 <settings_nvs_save+0x88>
			rc = nvs_delete(&cf->cf_nvs, name_id);
   1abec:	4631      	mov	r1, r6
   1abee:	4648      	mov	r0, r9
   1abf0:	f7ff ff11 	bl	1aa16 <nvs_delete>
			if (rc >= 0) {
   1abf4:	2800      	cmp	r0, #0
   1abf6:	dbc4      	blt.n	1ab82 <settings_nvs_save+0x88>
				rc = nvs_delete(&cf->cf_nvs, name_id +
   1abf8:	f505 517f 	add.w	r1, r5, #16320	; 0x3fc0
   1abfc:	313f      	adds	r1, #63	; 0x3f
   1abfe:	b289      	uxth	r1, r1
   1ac00:	4648      	mov	r0, r9
   1ac02:	f7ff ff08 	bl	1aa16 <nvs_delete>
	if (rc < 0) {
   1ac06:	ea00 70e0 	and.w	r0, r0, r0, asr #31
   1ac0a:	e7ba      	b.n	1ab82 <settings_nvs_save+0x88>

0001ac0c <settings_nvs_backend_init>:
{
   1ac0c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	rc = nvs_init(&cf->cf_nvs, cf->flash_dev_name);
   1ac0e:	f100 0608 	add.w	r6, r0, #8
   1ac12:	6b81      	ldr	r1, [r0, #56]	; 0x38
{
   1ac14:	4604      	mov	r4, r0
	rc = nvs_init(&cf->cf_nvs, cf->flash_dev_name);
   1ac16:	4630      	mov	r0, r6
   1ac18:	f7e8 fcf4 	bl	3604 <nvs_init>
	if (rc) {
   1ac1c:	4605      	mov	r5, r0
   1ac1e:	b970      	cbnz	r0, 1ac3e <settings_nvs_backend_init+0x32>
	rc = nvs_read(&cf->cf_nvs, NVS_NAMECNT_ID, &last_name_id,
   1ac20:	2302      	movs	r3, #2
   1ac22:	f10d 0206 	add.w	r2, sp, #6
   1ac26:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   1ac2a:	4630      	mov	r0, r6
   1ac2c:	f7ff fef7 	bl	1aa1e <nvs_read>
	if (rc < 0) {
   1ac30:	2800      	cmp	r0, #0
		cf->last_name_id = NVS_NAMECNT_ID;
   1ac32:	bfb4      	ite	lt
   1ac34:	f44f 4300 	movlt.w	r3, #32768	; 0x8000
		cf->last_name_id = last_name_id;
   1ac38:	f8bd 3006 	ldrhge.w	r3, [sp, #6]
   1ac3c:	86a3      	strh	r3, [r4, #52]	; 0x34
}
   1ac3e:	4628      	mov	r0, r5
   1ac40:	b002      	add	sp, #8
   1ac42:	bd70      	pop	{r4, r5, r6, pc}

0001ac44 <get_status>:
	data = get_sub_data(dev, type);
   1ac44:	6883      	ldr	r3, [r0, #8]
	return &data->subsys[type];
   1ac46:	b2c9      	uxtb	r1, r1
	if (data->started) {
   1ac48:	220c      	movs	r2, #12
   1ac4a:	fb02 3101 	mla	r1, r2, r1, r3
   1ac4e:	7a4b      	ldrb	r3, [r1, #9]
   1ac50:	b923      	cbnz	r3, 1ac5c <get_status+0x18>
	if (data->ref > 0) {
   1ac52:	7a08      	ldrb	r0, [r1, #8]
		return CLOCK_CONTROL_STATUS_ON;
   1ac54:	fab0 f080 	clz	r0, r0
   1ac58:	0940      	lsrs	r0, r0, #5
   1ac5a:	4770      	bx	lr
   1ac5c:	2002      	movs	r0, #2
}
   1ac5e:	4770      	bx	lr

0001ac60 <clkstarted_handle>:
{
   1ac60:	b538      	push	{r3, r4, r5, lr}
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
   1ac62:	6883      	ldr	r3, [r0, #8]
	sub_data->started = true;
   1ac64:	240c      	movs	r4, #12
   1ac66:	fb04 3401 	mla	r4, r4, r1, r3
   1ac6a:	2301      	movs	r3, #1
{
   1ac6c:	4605      	mov	r5, r0
	sub_data->started = true;
   1ac6e:	7263      	strb	r3, [r4, #9]
	__asm__ volatile(
   1ac70:	f04f 0320 	mov.w	r3, #32
   1ac74:	f3ef 8111 	mrs	r1, BASEPRI
   1ac78:	f383 8811 	msr	BASEPRI, r3
   1ac7c:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
   1ac80:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_GET(slist, snode)
   1ac82:	b12b      	cbz	r3, 1ac90 <clkstarted_handle+0x30>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   1ac84:	6860      	ldr	r0, [r4, #4]
   1ac86:	681a      	ldr	r2, [r3, #0]
	list->head = node;
   1ac88:	6022      	str	r2, [r4, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   1ac8a:	4283      	cmp	r3, r0
	list->tail = node;
   1ac8c:	bf08      	it	eq
   1ac8e:	6062      	streq	r2, [r4, #4]
	__asm__ volatile(
   1ac90:	f381 8811 	msr	BASEPRI, r1
   1ac94:	f3bf 8f6f 	isb	sy
	while ((async_data = list_get(&sub_data->list)) != NULL) {
   1ac98:	b903      	cbnz	r3, 1ac9c <clkstarted_handle+0x3c>
}
   1ac9a:	bd38      	pop	{r3, r4, r5, pc}
		async_data->cb(dev, async_data->user_data);
   1ac9c:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
   1aca0:	4628      	mov	r0, r5
   1aca2:	4790      	blx	r2
   1aca4:	e7e4      	b.n	1ac70 <clkstarted_handle+0x10>

0001aca6 <clock_async_start>:
	const struct nrf_clock_control_config *config =
   1aca6:	6803      	ldr	r3, [r0, #0]
	clk_data = get_sub_data(dev, type);
   1aca8:	f8d0 c008 	ldr.w	ip, [r0, #8]
{
   1acac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1acb0:	4605      	mov	r5, r0
	const struct nrf_clock_control_config *config =
   1acb2:	689f      	ldr	r7, [r3, #8]
	return &config->subsys[type];
   1acb4:	b2ce      	uxtb	r6, r1
	if ((data != NULL)
   1acb6:	b14a      	cbz	r2, 1accc <clock_async_start+0x26>
	sys_snode_t *item = sys_slist_peek_head(list);
   1acb8:	230c      	movs	r3, #12
   1acba:	4373      	muls	r3, r6
   1acbc:	f85c 3003 	ldr.w	r3, [ip, r3]
		if (item == node) {
   1acc0:	429a      	cmp	r2, r3
   1acc2:	d05b      	beq.n	1ad7c <clock_async_start+0xd6>
Z_GENLIST_PEEK_NEXT(slist, snode)
   1acc4:	b113      	cbz	r3, 1accc <clock_async_start+0x26>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1acc6:	681b      	ldr	r3, [r3, #0]
	} while (item);
   1acc8:	2b00      	cmp	r3, #0
   1acca:	d1f9      	bne.n	1acc0 <clock_async_start+0x1a>
	__asm__ volatile(
   1accc:	f04f 0320 	mov.w	r3, #32
   1acd0:	f3ef 8011 	mrs	r0, BASEPRI
   1acd4:	f383 8811 	msr	BASEPRI, r3
   1acd8:	f3bf 8f6f 	isb	sy
	ref = ++clk_data->ref;
   1acdc:	210c      	movs	r1, #12
   1acde:	4371      	muls	r1, r6
   1ace0:	eb0c 0301 	add.w	r3, ip, r1
   1ace4:	7a1c      	ldrb	r4, [r3, #8]
   1ace6:	3401      	adds	r4, #1
   1ace8:	b2e4      	uxtb	r4, r4
   1acea:	721c      	strb	r4, [r3, #8]
	__asm__ volatile(
   1acec:	f380 8811 	msr	BASEPRI, r0
   1acf0:	f3bf 8f6f 	isb	sy
	if (data) {
   1acf4:	b332      	cbz	r2, 1ad44 <clock_async_start+0x9e>
    p_reg->INTENCLR = mask;
   1acf6:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
   1acfa:	f04f 0e03 	mov.w	lr, #3
   1acfe:	f8c0 e308 	str.w	lr, [r0, #776]	; 0x308
		already_started = clk_data->started;
   1ad02:	7a58      	ldrb	r0, [r3, #9]
		if (!already_started) {
   1ad04:	b9a0      	cbnz	r0, 1ad30 <clock_async_start+0x8a>
	__asm__ volatile(
   1ad06:	f04f 0e20 	mov.w	lr, #32
   1ad0a:	f3ef 8811 	mrs	r8, BASEPRI
   1ad0e:	f38e 8811 	msr	BASEPRI, lr
   1ad12:	f3bf 8f6f 	isb	sy
	parent->next = child;
   1ad16:	6010      	str	r0, [r2, #0]
Z_GENLIST_APPEND(slist, snode)
   1ad18:	f8d3 e004 	ldr.w	lr, [r3, #4]
   1ad1c:	f1be 0f00 	cmp.w	lr, #0
   1ad20:	d11f      	bne.n	1ad62 <clock_async_start+0xbc>
	list->tail = node;
   1ad22:	605a      	str	r2, [r3, #4]
	list->head = node;
   1ad24:	f84c 2001 	str.w	r2, [ip, r1]
	__asm__ volatile(
   1ad28:	f388 8811 	msr	BASEPRI, r8
   1ad2c:	f3bf 8f6f 	isb	sy
    p_reg->INTENSET = mask;
   1ad30:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1ad34:	2103      	movs	r1, #3
   1ad36:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304
		if (already_started) {
   1ad3a:	b118      	cbz	r0, 1ad44 <clock_async_start+0x9e>
			data->cb(dev, data->user_data);
   1ad3c:	e9d2 3101 	ldrd	r3, r1, [r2, #4]
   1ad40:	4628      	mov	r0, r5
   1ad42:	4798      	blx	r3
	if (ref == 1) {
   1ad44:	2c01      	cmp	r4, #1
   1ad46:	d10a      	bne.n	1ad5e <clock_async_start+0xb8>
		do_start =  (config->start_handler) ?
   1ad48:	ea4f 1806 	mov.w	r8, r6, lsl #4
   1ad4c:	f857 3008 	ldr.w	r3, [r7, r8]
				config->start_handler(dev) : true;
   1ad50:	b95b      	cbnz	r3, 1ad6a <clock_async_start+0xc4>
			nrf_clock_task_trigger(NRF_CLOCK,
   1ad52:	4447      	add	r7, r8
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1ad54:	2201      	movs	r2, #1
   1ad56:	7abb      	ldrb	r3, [r7, #10]
   1ad58:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   1ad5c:	601a      	str	r2, [r3, #0]
	return 0;
   1ad5e:	2000      	movs	r0, #0
   1ad60:	e00e      	b.n	1ad80 <clock_async_start+0xda>
	parent->next = child;
   1ad62:	f8ce 2000 	str.w	r2, [lr]
	list->tail = node;
   1ad66:	605a      	str	r2, [r3, #4]
   1ad68:	e7de      	b.n	1ad28 <clock_async_start+0x82>
				config->start_handler(dev) : true;
   1ad6a:	4628      	mov	r0, r5
   1ad6c:	4798      	blx	r3
   1ad6e:	2800      	cmp	r0, #0
   1ad70:	d1ef      	bne.n	1ad52 <clock_async_start+0xac>
			clkstarted_handle(dev, type);
   1ad72:	4631      	mov	r1, r6
   1ad74:	4628      	mov	r0, r5
   1ad76:	f7ff ff73 	bl	1ac60 <clkstarted_handle>
   1ad7a:	e7f0      	b.n	1ad5e <clock_async_start+0xb8>
		return -EBUSY;
   1ad7c:	f06f 000f 	mvn.w	r0, #15
}
   1ad80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0001ad84 <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
   1ad84:	2200      	movs	r2, #0
   1ad86:	f7ff bf8e 	b.w	1aca6 <clock_async_start>

0001ad8a <clk_init>:
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   1ad8a:	2200      	movs	r2, #0
{
   1ad8c:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   1ad8e:	2101      	movs	r1, #1
{
   1ad90:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   1ad92:	4610      	mov	r0, r2
   1ad94:	f7e9 fb12 	bl	43bc <z_arm_irq_priority_set>
	irq_enable(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0);
   1ad98:	2000      	movs	r0, #0
   1ad9a:	f7e9 fadd 	bl	4358 <arch_irq_enable>
}

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->LFCLKSRC = (uint32_t)(source);
   1ad9e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1ada2:	2201      	movs	r2, #1
   1ada4:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    p_reg->INTENSET = mask;
   1ada8:	2203      	movs	r2, #3
   1adaa:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		sys_slist_init(&(get_sub_data(dev, i)->list));
   1adae:	68a3      	ldr	r3, [r4, #8]
	list->head = NULL;
   1adb0:	2000      	movs	r0, #0
	list->tail = NULL;
   1adb2:	e9c3 0000 	strd	r0, r0, [r3]
   1adb6:	68a3      	ldr	r3, [r4, #8]
   1adb8:	e9c3 0003 	strd	r0, r0, [r3, #12]
}
   1adbc:	bd10      	pop	{r4, pc}

0001adbe <clock_stop>:
	const struct nrf_clock_control_config *config =
   1adbe:	6802      	ldr	r2, [r0, #0]
{
   1adc0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	const struct nrf_clock_control_config *config =
   1adc4:	f8d2 8008 	ldr.w	r8, [r2, #8]
	data = get_sub_data(dev, type);
   1adc8:	6887      	ldr	r7, [r0, #8]
   1adca:	b2cc      	uxtb	r4, r1
	__asm__ volatile(
   1adcc:	f04f 0320 	mov.w	r3, #32
   1add0:	f3ef 8611 	mrs	r6, BASEPRI
   1add4:	f383 8811 	msr	BASEPRI, r3
   1add8:	f3bf 8f6f 	isb	sy
	if (data->ref == 0) {
   1addc:	220c      	movs	r2, #12
   1adde:	4362      	muls	r2, r4
   1ade0:	18b9      	adds	r1, r7, r2
   1ade2:	7a0b      	ldrb	r3, [r1, #8]
   1ade4:	b343      	cbz	r3, 1ae38 <clock_stop+0x7a>
	data->ref--;
   1ade6:	3b01      	subs	r3, #1
   1ade8:	b2db      	uxtb	r3, r3
   1adea:	720b      	strb	r3, [r1, #8]
	if (data->ref == 0) {
   1adec:	bb3b      	cbnz	r3, 1ae3e <clock_stop+0x80>
		do_stop =  (config->stop_handler) ?
   1adee:	0125      	lsls	r5, r4, #4
	list->head = NULL;
   1adf0:	50bb      	str	r3, [r7, r2]
	list->tail = NULL;
   1adf2:	604b      	str	r3, [r1, #4]
   1adf4:	eb08 0305 	add.w	r3, r8, r5
   1adf8:	685b      	ldr	r3, [r3, #4]
				config->stop_handler(dev) : true;
   1adfa:	b9cb      	cbnz	r3, 1ae30 <clock_stop+0x72>
			nrf_clock_task_trigger(NRF_CLOCK, config->stop_tsk);
   1adfc:	4445      	add	r5, r8
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1adfe:	2201      	movs	r2, #1
   1ae00:	7aeb      	ldrb	r3, [r5, #11]
   1ae02:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   1ae06:	601a      	str	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1ae08:	892b      	ldrh	r3, [r5, #8]
   1ae0a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   1ae0e:	2200      	movs	r2, #0
   1ae10:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   1ae12:	681b      	ldr	r3, [r3, #0]
   1ae14:	9301      	str	r3, [sp, #4]
    (void)dummy;
   1ae16:	9b01      	ldr	r3, [sp, #4]
		data->started = false;
   1ae18:	210c      	movs	r1, #12
   1ae1a:	fb01 7404 	mla	r4, r1, r4, r7
   1ae1e:	2000      	movs	r0, #0
   1ae20:	7260      	strb	r0, [r4, #9]
	__asm__ volatile(
   1ae22:	f386 8811 	msr	BASEPRI, r6
   1ae26:	f3bf 8f6f 	isb	sy
}
   1ae2a:	b002      	add	sp, #8
   1ae2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				config->stop_handler(dev) : true;
   1ae30:	4798      	blx	r3
   1ae32:	2800      	cmp	r0, #0
   1ae34:	d1e2      	bne.n	1adfc <clock_stop+0x3e>
   1ae36:	e7ef      	b.n	1ae18 <clock_stop+0x5a>
		err = -EALREADY;
   1ae38:	f06f 0044 	mvn.w	r0, #68	; 0x44
   1ae3c:	e7f1      	b.n	1ae22 <clock_stop+0x64>
	int err = 0;
   1ae3e:	2000      	movs	r0, #0
   1ae40:	e7ef      	b.n	1ae22 <clock_stop+0x64>

0001ae42 <z_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
   1ae42:	4770      	bx	lr

0001ae44 <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
   1ae44:	4770      	bx	lr

0001ae46 <z_irq_spurious>:
	z_arm_reserved();
   1ae46:	f7e9 bb2b 	b.w	44a0 <z_arm_bus_fault>

0001ae4a <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   1ae4a:	4601      	mov	r1, r0
			reason = K_ERR_KERNEL_OOPS;
		}
	}

#endif /* CONFIG_USERSPACE */
	z_arm_fatal_error(reason, esf);
   1ae4c:	6800      	ldr	r0, [r0, #0]
   1ae4e:	f7e9 bb31 	b.w	44b4 <z_arm_fatal_error>

0001ae52 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   1ae52:	b508      	push	{r3, lr}
	handler();
   1ae54:	f7e9 fb80 	bl	4558 <z_SysNmiOnReset>
	z_arm_exc_exit();
}
   1ae58:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_exc_exit();
   1ae5c:	f7e9 ba1a 	b.w	4294 <z_arm_exc_exit>

0001ae60 <z_arm_configure_dynamic_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_dynamic_mpu_regions(struct k_thread *thread)
{
   1ae60:	b507      	push	{r0, r1, r2, lr}

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(
   1ae62:	2100      	movs	r1, #0
   1ae64:	a801      	add	r0, sp, #4
   1ae66:	f7e9 ff59 	bl	4d1c <arm_core_mpu_configure_dynamic_mpu_regions>
		(const struct k_mem_partition **)dynamic_regions,
		region_num);
}
   1ae6a:	b003      	add	sp, #12
   1ae6c:	f85d fb04 	ldr.w	pc, [sp], #4

0001ae70 <strtol>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
long strtol(const char *nptr, char **endptr, register int base)
{
   1ae70:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1ae74:	4684      	mov	ip, r0
   1ae76:	460f      	mov	r7, r1
	register const char *s = nptr;
   1ae78:	4605      	mov	r5, r0
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
   1ae7a:	462c      	mov	r4, r5
   1ae7c:	f814 3b01 	ldrb.w	r3, [r4], #1
}

static inline int isspace(int c)
{
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
   1ae80:	2b20      	cmp	r3, #32
   1ae82:	d036      	beq.n	1aef2 <strtol+0x82>
   1ae84:	f1a3 0109 	sub.w	r1, r3, #9
   1ae88:	2904      	cmp	r1, #4
   1ae8a:	d932      	bls.n	1aef2 <strtol+0x82>
	} while (isspace(c));
	if (c == '-') {
   1ae8c:	2b2d      	cmp	r3, #45	; 0x2d
   1ae8e:	d132      	bne.n	1aef6 <strtol+0x86>
		neg = 1;
		c = *s++;
   1ae90:	786b      	ldrb	r3, [r5, #1]
   1ae92:	1cac      	adds	r4, r5, #2
		neg = 1;
   1ae94:	2101      	movs	r1, #1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
   1ae96:	2a00      	cmp	r2, #0
   1ae98:	d05c      	beq.n	1af54 <strtol+0xe4>
   1ae9a:	2a10      	cmp	r2, #16
   1ae9c:	d109      	bne.n	1aeb2 <strtol+0x42>
   1ae9e:	2b30      	cmp	r3, #48	; 0x30
   1aea0:	d107      	bne.n	1aeb2 <strtol+0x42>
	    c == '0' && (*s == 'x' || *s == 'X')) {
   1aea2:	7823      	ldrb	r3, [r4, #0]
   1aea4:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   1aea8:	2b58      	cmp	r3, #88	; 0x58
   1aeaa:	d14e      	bne.n	1af4a <strtol+0xda>
		c = s[1];
   1aeac:	7863      	ldrb	r3, [r4, #1]
		s += 2;
		base = 16;
   1aeae:	2210      	movs	r2, #16
		s += 2;
   1aeb0:	3402      	adds	r4, #2
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
   1aeb2:	2900      	cmp	r1, #0
   1aeb4:	bf14      	ite	ne
   1aeb6:	f04f 4800 	movne.w	r8, #2147483648	; 0x80000000
   1aeba:	f06f 4800 	mvneq.w	r8, #2147483648	; 0x80000000
	cutlim = cutoff % (unsigned long)base;
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
   1aebe:	2600      	movs	r6, #0
	cutlim = cutoff % (unsigned long)base;
   1aec0:	fbb8 fef2 	udiv	lr, r8, r2
	for (acc = 0, any = 0;; c = *s++) {
   1aec4:	4630      	mov	r0, r6
	cutlim = cutoff % (unsigned long)base;
   1aec6:	fb02 891e 	mls	r9, r2, lr, r8
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   1aeca:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
		if (isdigit(c)) {
   1aece:	2d09      	cmp	r5, #9
   1aed0:	d817      	bhi.n	1af02 <strtol+0x92>
			c -= '0';
   1aed2:	462b      	mov	r3, r5
		} else if (isalpha(c)) {
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
		} else {
			break;
		}
		if (c >= base) {
   1aed4:	429a      	cmp	r2, r3
   1aed6:	dd24      	ble.n	1af22 <strtol+0xb2>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
   1aed8:	1c75      	adds	r5, r6, #1
   1aeda:	d007      	beq.n	1aeec <strtol+0x7c>
   1aedc:	4570      	cmp	r0, lr
   1aede:	d81d      	bhi.n	1af1c <strtol+0xac>
   1aee0:	d101      	bne.n	1aee6 <strtol+0x76>
   1aee2:	454b      	cmp	r3, r9
   1aee4:	dc1a      	bgt.n	1af1c <strtol+0xac>
			any = -1;
		} else {
			any = 1;
			acc *= base;
			acc += c;
   1aee6:	fb00 3002 	mla	r0, r0, r2, r3
			any = 1;
   1aeea:	2601      	movs	r6, #1
	for (acc = 0, any = 0;; c = *s++) {
   1aeec:	f814 3b01 	ldrb.w	r3, [r4], #1
		if (isdigit(c)) {
   1aef0:	e7eb      	b.n	1aeca <strtol+0x5a>
{
   1aef2:	4625      	mov	r5, r4
   1aef4:	e7c1      	b.n	1ae7a <strtol+0xa>
	} else if (c == '+') {
   1aef6:	2b2b      	cmp	r3, #43	; 0x2b
		c = *s++;
   1aef8:	bf04      	itt	eq
   1aefa:	1cac      	addeq	r4, r5, #2
   1aefc:	786b      	ldrbeq	r3, [r5, #1]
	register int neg = 0, any, cutlim;
   1aefe:	2100      	movs	r1, #0
   1af00:	e7c9      	b.n	1ae96 <strtol+0x26>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   1af02:	f043 0520 	orr.w	r5, r3, #32
   1af06:	3d61      	subs	r5, #97	; 0x61
		} else if (isalpha(c)) {
   1af08:	2d19      	cmp	r5, #25
   1af0a:	d80a      	bhi.n	1af22 <strtol+0xb2>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   1af0c:	f1a3 0541 	sub.w	r5, r3, #65	; 0x41
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
   1af10:	2d1a      	cmp	r5, #26
   1af12:	bf34      	ite	cc
   1af14:	2537      	movcc	r5, #55	; 0x37
   1af16:	2557      	movcs	r5, #87	; 0x57
   1af18:	1b5b      	subs	r3, r3, r5
   1af1a:	e7db      	b.n	1aed4 <strtol+0x64>
			any = -1;
   1af1c:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   1af20:	e7e4      	b.n	1aeec <strtol+0x7c>
		}
	}

	if (any < 0) {
   1af22:	1c73      	adds	r3, r6, #1
   1af24:	d107      	bne.n	1af36 <strtol+0xc6>
   1af26:	f7fc fc29 	bl	1777c <z_impl_z_errno>
		acc = neg ? LONG_MIN : LONG_MAX;
		errno = ERANGE;
   1af2a:	2326      	movs	r3, #38	; 0x26
   1af2c:	6003      	str	r3, [r0, #0]
		acc = neg ? LONG_MIN : LONG_MAX;
   1af2e:	4640      	mov	r0, r8
	} else if (neg) {
		acc = -acc;
	}

	if (endptr != NULL) {
   1af30:	b937      	cbnz	r7, 1af40 <strtol+0xd0>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
   1af32:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if (neg) {
   1af36:	b101      	cbz	r1, 1af3a <strtol+0xca>
		acc = -acc;
   1af38:	4240      	negs	r0, r0
	if (endptr != NULL) {
   1af3a:	2f00      	cmp	r7, #0
   1af3c:	d0f9      	beq.n	1af32 <strtol+0xc2>
		*endptr = (char *)(any ? s - 1 : nptr);
   1af3e:	b10e      	cbz	r6, 1af44 <strtol+0xd4>
   1af40:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
   1af44:	f8c7 c000 	str.w	ip, [r7]
	return acc;
   1af48:	e7f3      	b.n	1af32 <strtol+0xc2>
	if (base == 0) {
   1af4a:	2330      	movs	r3, #48	; 0x30
   1af4c:	2a00      	cmp	r2, #0
   1af4e:	d1b0      	bne.n	1aeb2 <strtol+0x42>
		base = c == '0' ? 8 : 10;
   1af50:	2208      	movs	r2, #8
   1af52:	e7ae      	b.n	1aeb2 <strtol+0x42>
	if ((base == 0 || base == 16) &&
   1af54:	2b30      	cmp	r3, #48	; 0x30
   1af56:	d0a4      	beq.n	1aea2 <strtol+0x32>
		base = c == '0' ? 8 : 10;
   1af58:	220a      	movs	r2, #10
   1af5a:	e7aa      	b.n	1aeb2 <strtol+0x42>

0001af5c <strcpy>:

char *strcpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
   1af5c:	3901      	subs	r1, #1
   1af5e:	4603      	mov	r3, r0
   1af60:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   1af64:	b90a      	cbnz	r2, 1af6a <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
   1af66:	701a      	strb	r2, [r3, #0]

	return dest;
}
   1af68:	4770      	bx	lr
		*d = *s;
   1af6a:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
   1af6e:	e7f7      	b.n	1af60 <strcpy+0x4>

0001af70 <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
   1af70:	b570      	push	{r4, r5, r6, lr}
   1af72:	3901      	subs	r1, #1
   1af74:	4605      	mov	r5, r0
   1af76:	462c      	mov	r4, r5
	char *dest = d;

	while ((n > 0) && *s != '\0') {
   1af78:	b142      	cbz	r2, 1af8c <strncpy+0x1c>
   1af7a:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   1af7e:	1e56      	subs	r6, r2, #1
   1af80:	b92b      	cbnz	r3, 1af8e <strncpy+0x1e>
   1af82:	442a      	add	r2, r5
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
   1af84:	f804 3b01 	strb.w	r3, [r4], #1
	while (n > 0) {
   1af88:	42a2      	cmp	r2, r4
   1af8a:	d1fb      	bne.n	1af84 <strncpy+0x14>
		d++;
		n--;
	}

	return dest;
}
   1af8c:	bd70      	pop	{r4, r5, r6, pc}
		*d = *s;
   1af8e:	f805 3b01 	strb.w	r3, [r5], #1
		n--;
   1af92:	4632      	mov	r2, r6
   1af94:	e7ef      	b.n	1af76 <strncpy+0x6>

0001af96 <strlen>:
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
	size_t n = 0;
   1af96:	2300      	movs	r3, #0

	while (*s != '\0') {
   1af98:	5cc2      	ldrb	r2, [r0, r3]
   1af9a:	b90a      	cbnz	r2, 1afa0 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   1af9c:	4618      	mov	r0, r3
   1af9e:	4770      	bx	lr
		n++;
   1afa0:	3301      	adds	r3, #1
   1afa2:	e7f9      	b.n	1af98 <strlen+0x2>

0001afa4 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
   1afa4:	3801      	subs	r0, #1
   1afa6:	3901      	subs	r1, #1
   1afa8:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   1afac:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   1afb0:	4293      	cmp	r3, r2
   1afb2:	d101      	bne.n	1afb8 <strcmp+0x14>
   1afb4:	2b00      	cmp	r3, #0
   1afb6:	d1f7      	bne.n	1afa8 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
   1afb8:	1a98      	subs	r0, r3, r2
   1afba:	4770      	bx	lr

0001afbc <strncmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
   1afbc:	b530      	push	{r4, r5, lr}
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
   1afbe:	2400      	movs	r4, #0
   1afc0:	42a2      	cmp	r2, r4
   1afc2:	d008      	beq.n	1afd6 <strncmp+0x1a>
   1afc4:	5d03      	ldrb	r3, [r0, r4]
   1afc6:	5d0d      	ldrb	r5, [r1, r4]
   1afc8:	42ab      	cmp	r3, r5
   1afca:	d102      	bne.n	1afd2 <strncmp+0x16>
   1afcc:	3401      	adds	r4, #1
   1afce:	2b00      	cmp	r3, #0
   1afd0:	d1f6      	bne.n	1afc0 <strncmp+0x4>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
   1afd2:	1b58      	subs	r0, r3, r5
   1afd4:	e000      	b.n	1afd8 <strncmp+0x1c>
   1afd6:	2000      	movs	r0, #0
}
   1afd8:	bd30      	pop	{r4, r5, pc}

0001afda <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
   1afda:	b510      	push	{r4, lr}
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
   1afdc:	b15a      	cbz	r2, 1aff6 <memcmp+0x1c>
   1afde:	3901      	subs	r1, #1
   1afe0:	1884      	adds	r4, r0, r2
   1afe2:	f810 2b01 	ldrb.w	r2, [r0], #1
   1afe6:	f811 3f01 	ldrb.w	r3, [r1, #1]!
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
   1afea:	42a0      	cmp	r0, r4
   1afec:	d001      	beq.n	1aff2 <memcmp+0x18>
   1afee:	429a      	cmp	r2, r3
   1aff0:	d0f7      	beq.n	1afe2 <memcmp+0x8>
		c1++;
		c2++;
	}

	return *c1 - *c2;
   1aff2:	1ad0      	subs	r0, r2, r3
}
   1aff4:	bd10      	pop	{r4, pc}
		return 0;
   1aff6:	4610      	mov	r0, r2
   1aff8:	e7fc      	b.n	1aff4 <memcmp+0x1a>

0001affa <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
   1affa:	b5f0      	push	{r4, r5, r6, r7, lr}

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
   1affc:	ea81 0400 	eor.w	r4, r1, r0
   1b000:	07a5      	lsls	r5, r4, #30
   1b002:	4603      	mov	r3, r0
   1b004:	d00b      	beq.n	1b01e <memcpy+0x24>
   1b006:	3b01      	subs	r3, #1
   1b008:	440a      	add	r2, r1
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
   1b00a:	4291      	cmp	r1, r2
   1b00c:	d11a      	bne.n	1b044 <memcpy+0x4a>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   1b00e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (n == 0) {
   1b010:	2a00      	cmp	r2, #0
   1b012:	d0fc      	beq.n	1b00e <memcpy+0x14>
			*(d_byte++) = *(s_byte++);
   1b014:	f811 4b01 	ldrb.w	r4, [r1], #1
   1b018:	f803 4b01 	strb.w	r4, [r3], #1
			n--;
   1b01c:	3a01      	subs	r2, #1
		while (((uintptr_t)d_byte) & mask) {
   1b01e:	079c      	lsls	r4, r3, #30
   1b020:	d1f6      	bne.n	1b010 <memcpy+0x16>
   1b022:	0895      	lsrs	r5, r2, #2
   1b024:	00ac      	lsls	r4, r5, #2
   1b026:	1f1e      	subs	r6, r3, #4
   1b028:	190f      	adds	r7, r1, r4
		while (n >= sizeof(mem_word_t)) {
   1b02a:	42b9      	cmp	r1, r7
   1b02c:	d105      	bne.n	1b03a <memcpy+0x40>
   1b02e:	f06f 0603 	mvn.w	r6, #3
   1b032:	fb06 2205 	mla	r2, r6, r5, r2
   1b036:	4423      	add	r3, r4
   1b038:	e7e5      	b.n	1b006 <memcpy+0xc>
			*(d_word++) = *(s_word++);
   1b03a:	f851 cb04 	ldr.w	ip, [r1], #4
   1b03e:	f846 cf04 	str.w	ip, [r6, #4]!
			n -= sizeof(mem_word_t);
   1b042:	e7f2      	b.n	1b02a <memcpy+0x30>
		*(d_byte++) = *(s_byte++);
   1b044:	f811 4b01 	ldrb.w	r4, [r1], #1
   1b048:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   1b04c:	e7dd      	b.n	1b00a <memcpy+0x10>

0001b04e <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
   1b04e:	b570      	push	{r4, r5, r6, lr}
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
   1b050:	b2c9      	uxtb	r1, r1
	unsigned char *d_byte = (unsigned char *)buf;
   1b052:	4603      	mov	r3, r0

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
   1b054:	079c      	lsls	r4, r3, #30
   1b056:	d110      	bne.n	1b07a <memset+0x2c>
	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;

	c_word |= c_word << 8;
   1b058:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
	c_word |= c_word << 16;
   1b05c:	ea44 4504 	orr.w	r5, r4, r4, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
   1b060:	0894      	lsrs	r4, r2, #2
   1b062:	eb03 0684 	add.w	r6, r3, r4, lsl #2
   1b066:	42b3      	cmp	r3, r6
   1b068:	d10d      	bne.n	1b086 <memset+0x38>
   1b06a:	f06f 0503 	mvn.w	r5, #3
   1b06e:	fb05 2404 	mla	r4, r5, r4, r2
   1b072:	441c      	add	r4, r3

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
   1b074:	42a3      	cmp	r3, r4
   1b076:	d109      	bne.n	1b08c <memset+0x3e>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   1b078:	bd70      	pop	{r4, r5, r6, pc}
		if (n == 0) {
   1b07a:	2a00      	cmp	r2, #0
   1b07c:	d0fc      	beq.n	1b078 <memset+0x2a>
		*(d_byte++) = c_byte;
   1b07e:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   1b082:	3a01      	subs	r2, #1
   1b084:	e7e6      	b.n	1b054 <memset+0x6>
		*(d_word++) = c_word;
   1b086:	f843 5b04 	str.w	r5, [r3], #4
		n -= sizeof(mem_word_t);
   1b08a:	e7ec      	b.n	1b066 <memset+0x18>
		*(d_byte++) = c_byte;
   1b08c:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   1b090:	e7f0      	b.n	1b074 <memset+0x26>

0001b092 <z_platform_init>:
	nrfx_coredep_delay_us(time_us);
}

void z_platform_init(void)
{
	SystemInit();
   1b092:	f7fb bf7b 	b.w	16f8c <SystemInit>

0001b096 <ah>:
#define BT_DBG_ENABLED IS_ENABLED(CONFIG_BT_DEBUG_RPA)
#define LOG_MODULE_NAME bt_rpa
#include "common/log.h"

static int ah(const u8_t irk[16], const u8_t r[3], u8_t out[3])
{
   1b096:	b530      	push	{r4, r5, lr}
   1b098:	b085      	sub	sp, #20
   1b09a:	4604      	mov	r4, r0
   1b09c:	4615      	mov	r5, r2

	BT_DBG("irk %s", bt_hex(irk, 16));
	BT_DBG("r %s", bt_hex(r, 3));

	/* r' = padding || r */
	memcpy(res, r, 3);
   1b09e:	4668      	mov	r0, sp
   1b0a0:	2203      	movs	r2, #3
   1b0a2:	f7ff ffaa 	bl	1affa <memcpy>
	(void)memset(res + 3, 0, 13);
   1b0a6:	220d      	movs	r2, #13
   1b0a8:	2100      	movs	r1, #0
   1b0aa:	f10d 0003 	add.w	r0, sp, #3
   1b0ae:	f7ff ffce 	bl	1b04e <memset>

	err = bt_encrypt_le(irk, res, res);
   1b0b2:	4620      	mov	r0, r4
   1b0b4:	466a      	mov	r2, sp
   1b0b6:	4669      	mov	r1, sp
   1b0b8:	f002 f8f2 	bl	1d2a0 <bt_encrypt_le>
	if (err) {
   1b0bc:	4604      	mov	r4, r0
   1b0be:	b920      	cbnz	r0, 1b0ca <ah+0x34>
	 *      ah(h, r) = e(k, r') mod 2^24
	 * The output of the security function e is then truncated to 24 bits
	 * by taking the least significant 24 bits of the output of e as the
	 * result of ah.
	 */
	memcpy(out, res, 3);
   1b0c0:	2203      	movs	r2, #3
   1b0c2:	4669      	mov	r1, sp
   1b0c4:	4628      	mov	r0, r5
   1b0c6:	f7ff ff98 	bl	1affa <memcpy>

	return 0;
}
   1b0ca:	4620      	mov	r0, r4
   1b0cc:	b005      	add	sp, #20
   1b0ce:	bd30      	pop	{r4, r5, pc}

0001b0d0 <bt_rpa_irk_matches>:

#if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_CTLR_PRIVACY)
bool bt_rpa_irk_matches(const u8_t irk[16], const bt_addr_t *addr)
{
   1b0d0:	b513      	push	{r0, r1, r4, lr}
   1b0d2:	460c      	mov	r4, r1
	u8_t hash[3];
	int err;

	BT_DBG("IRK %s bdaddr %s", bt_hex(irk, 16), bt_addr_str(addr));

	err = ah(irk, addr->val + 3, hash);
   1b0d4:	aa01      	add	r2, sp, #4
   1b0d6:	3103      	adds	r1, #3
   1b0d8:	f7ff ffdd 	bl	1b096 <ah>
	if (err) {
   1b0dc:	b948      	cbnz	r0, 1b0f2 <bt_rpa_irk_matches+0x22>
		return false;
	}

	return !memcmp(addr->val, hash, 3);
   1b0de:	2203      	movs	r2, #3
   1b0e0:	a901      	add	r1, sp, #4
   1b0e2:	4620      	mov	r0, r4
   1b0e4:	f7ff ff79 	bl	1afda <memcmp>
   1b0e8:	fab0 f080 	clz	r0, r0
   1b0ec:	0940      	lsrs	r0, r0, #5
}
   1b0ee:	b002      	add	sp, #8
   1b0f0:	bd10      	pop	{r4, pc}
		return false;
   1b0f2:	2000      	movs	r0, #0
   1b0f4:	e7fb      	b.n	1b0ee <bt_rpa_irk_matches+0x1e>

0001b0f6 <bt_rpa_create>:
#endif

#if defined(CONFIG_BT_PRIVACY) || defined(CONFIG_BT_CTLR_PRIVACY)
int bt_rpa_create(const u8_t irk[16], bt_addr_t *rpa)
{
   1b0f6:	b570      	push	{r4, r5, r6, lr}
	int err;

	err = bt_rand(rpa->val + 3, 3);
   1b0f8:	1ccd      	adds	r5, r1, #3
{
   1b0fa:	4606      	mov	r6, r0
   1b0fc:	460c      	mov	r4, r1
	err = bt_rand(rpa->val + 3, 3);
   1b0fe:	4628      	mov	r0, r5
   1b100:	2103      	movs	r1, #3
   1b102:	f7f4 fcad 	bl	fa60 <bt_rand>
	if (err) {
   1b106:	b960      	cbnz	r0, 1b122 <bt_rpa_create+0x2c>
		return err;
	}

	BT_ADDR_SET_RPA(rpa);
   1b108:	7963      	ldrb	r3, [r4, #5]
   1b10a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   1b10e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1b112:	7163      	strb	r3, [r4, #5]

	err = ah(irk, rpa->val + 3, rpa->val);
   1b114:	4622      	mov	r2, r4
   1b116:	4629      	mov	r1, r5
   1b118:	4630      	mov	r0, r6
	}

	BT_DBG("Created RPA %s", bt_addr_str((bt_addr_t *)rpa->val));

	return 0;
}
   1b11a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	err = ah(irk, rpa->val + 3, rpa->val);
   1b11e:	f7ff bfba 	b.w	1b096 <ah>
}
   1b122:	bd70      	pop	{r4, r5, r6, pc}

0001b124 <send_cmd_status>:
{
   1b124:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   1b128:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
   1b12c:	4680      	mov	r8, r0
   1b12e:	460f      	mov	r7, r1
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   1b130:	200f      	movs	r0, #15
   1b132:	2100      	movs	r1, #0
   1b134:	f7ec fc60 	bl	79f8 <bt_buf_get_evt>
	*(u8_t *)net_buf_user_data(buf) = type;
   1b138:	2501      	movs	r5, #1
	hdr = net_buf_add(buf, sizeof(*hdr));
   1b13a:	f100 0608 	add.w	r6, r0, #8
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   1b13e:	4604      	mov	r4, r0
   1b140:	7505      	strb	r5, [r0, #20]
	hdr = net_buf_add(buf, sizeof(*hdr));
   1b142:	2102      	movs	r1, #2
   1b144:	4630      	mov	r0, r6
   1b146:	f002 fd81 	bl	1dc4c <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_CMD_STATUS;
   1b14a:	230f      	movs	r3, #15
	hdr->len = sizeof(*evt);
   1b14c:	2104      	movs	r1, #4
	hdr->evt = BT_HCI_EVT_CMD_STATUS;
   1b14e:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*evt);
   1b150:	7041      	strb	r1, [r0, #1]
	evt = net_buf_add(buf, sizeof(*evt));
   1b152:	4630      	mov	r0, r6
   1b154:	f002 fd7a 	bl	1dc4c <net_buf_simple_add>
	evt->ncmd = 1U;
   1b158:	7045      	strb	r5, [r0, #1]
	evt->status = status;
   1b15a:	7007      	strb	r7, [r0, #0]
	evt->opcode = sys_cpu_to_le16(opcode);
   1b15c:	f8a0 8002 	strh.w	r8, [r0, #2]
	bt_recv_prio(buf);
   1b160:	4620      	mov	r0, r4
}
   1b162:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	bt_recv_prio(buf);
   1b166:	f7eb bd97 	b.w	6c98 <bt_recv_prio>

0001b16a <sys_memcpy_swap.constprop.2>:
   1b16a:	f101 0320 	add.w	r3, r1, #32
   1b16e:	3801      	subs	r0, #1
		*pdst++ = *psrc--;
   1b170:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
   1b174:	f800 2f01 	strb.w	r2, [r0, #1]!
	for (; length > 0; length--) {
   1b178:	428b      	cmp	r3, r1
   1b17a:	d1f9      	bne.n	1b170 <sys_memcpy_swap.constprop.2+0x6>
}
   1b17c:	4770      	bx	lr

0001b17e <default_CSPRNG>:
{
   1b17e:	b508      	push	{r3, lr}
	return !bt_rand(dst, len);
   1b180:	f7f4 fc6e 	bl	fa60 <bt_rand>
}
   1b184:	fab0 f080 	clz	r0, r0
   1b188:	0940      	lsrs	r0, r0, #5
   1b18a:	bd08      	pop	{r3, pc}

0001b18c <bt_settings_decode_key>:
{
   1b18c:	b570      	push	{r4, r5, r6, lr}
   1b18e:	460d      	mov	r5, r1
	if (settings_name_next(key, NULL) != 13) {
   1b190:	2100      	movs	r1, #0
{
   1b192:	4604      	mov	r4, r0
	if (settings_name_next(key, NULL) != 13) {
   1b194:	f7ff fc8f 	bl	1aab6 <settings_name_next>
   1b198:	280d      	cmp	r0, #13
   1b19a:	d118      	bne.n	1b1ce <bt_settings_decode_key+0x42>
	if (key[12] == '0') {
   1b19c:	7b23      	ldrb	r3, [r4, #12]
   1b19e:	2b30      	cmp	r3, #48	; 0x30
   1b1a0:	d111      	bne.n	1b1c6 <bt_settings_decode_key+0x3a>
		addr->type = BT_ADDR_LE_PUBLIC;
   1b1a2:	2300      	movs	r3, #0
   1b1a4:	702b      	strb	r3, [r5, #0]
   1b1a6:	f104 060c 	add.w	r6, r4, #12
   1b1aa:	3506      	adds	r5, #6
		hex2bin(&key[i * 2], 2, &addr->a.val[5 - i], 1);
   1b1ac:	462a      	mov	r2, r5
   1b1ae:	4620      	mov	r0, r4
   1b1b0:	2301      	movs	r3, #1
   1b1b2:	2102      	movs	r1, #2
   1b1b4:	3402      	adds	r4, #2
   1b1b6:	f7fd fd57 	bl	18c68 <hex2bin>
	for (u8_t i = 0; i < 6; i++) {
   1b1ba:	42b4      	cmp	r4, r6
   1b1bc:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
   1b1c0:	d1f4      	bne.n	1b1ac <bt_settings_decode_key+0x20>
	return 0;
   1b1c2:	2000      	movs	r0, #0
}
   1b1c4:	bd70      	pop	{r4, r5, r6, pc}
	} else if (key[12] == '1') {
   1b1c6:	2b31      	cmp	r3, #49	; 0x31
   1b1c8:	d101      	bne.n	1b1ce <bt_settings_decode_key+0x42>
		addr->type = BT_ADDR_LE_RANDOM;
   1b1ca:	2301      	movs	r3, #1
   1b1cc:	e7ea      	b.n	1b1a4 <bt_settings_decode_key+0x18>
		return -EINVAL;
   1b1ce:	f06f 0015 	mvn.w	r0, #21
   1b1d2:	e7f7      	b.n	1b1c4 <bt_settings_decode_key+0x38>

0001b1d4 <bt_uuid_cmp>:

	return memcmp(uuid1.val, uuid2.val, 16);
}

int bt_uuid_cmp(const struct bt_uuid *u1, const struct bt_uuid *u2)
{
   1b1d4:	b510      	push	{r4, lr}
   1b1d6:	460c      	mov	r4, r1
	/* Convert to 128 bit if types don't match */
	if (u1->type != u2->type) {
   1b1d8:	7801      	ldrb	r1, [r0, #0]
   1b1da:	7822      	ldrb	r2, [r4, #0]
   1b1dc:	428a      	cmp	r2, r1
{
   1b1de:	b08a      	sub	sp, #40	; 0x28
	if (u1->type != u2->type) {
   1b1e0:	d00e      	beq.n	1b200 <bt_uuid_cmp+0x2c>
	uuid_to_uuid128(u1, &uuid1);
   1b1e2:	4669      	mov	r1, sp
   1b1e4:	f7ea f97c 	bl	54e0 <uuid_to_uuid128>
	uuid_to_uuid128(u2, &uuid2);
   1b1e8:	a905      	add	r1, sp, #20
   1b1ea:	4620      	mov	r0, r4
   1b1ec:	f7ea f978 	bl	54e0 <uuid_to_uuid128>
	return memcmp(uuid1.val, uuid2.val, 16);
   1b1f0:	2210      	movs	r2, #16
   1b1f2:	f10d 0115 	add.w	r1, sp, #21
   1b1f6:	f10d 0001 	add.w	r0, sp, #1
	case BT_UUID_TYPE_16:
		return (int)BT_UUID_16(u1)->val - (int)BT_UUID_16(u2)->val;
	case BT_UUID_TYPE_32:
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
	case BT_UUID_TYPE_128:
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
   1b1fa:	f7ff feee 	bl	1afda <memcmp>
   1b1fe:	e006      	b.n	1b20e <bt_uuid_cmp+0x3a>
	switch (u1->type) {
   1b200:	2a01      	cmp	r2, #1
   1b202:	d00a      	beq.n	1b21a <bt_uuid_cmp+0x46>
   1b204:	b12a      	cbz	r2, 1b212 <bt_uuid_cmp+0x3e>
   1b206:	2a02      	cmp	r2, #2
   1b208:	d00a      	beq.n	1b220 <bt_uuid_cmp+0x4c>
	}

	return -EINVAL;
   1b20a:	f06f 0015 	mvn.w	r0, #21
}
   1b20e:	b00a      	add	sp, #40	; 0x28
   1b210:	bd10      	pop	{r4, pc}
		return (int)BT_UUID_16(u1)->val - (int)BT_UUID_16(u2)->val;
   1b212:	8840      	ldrh	r0, [r0, #2]
   1b214:	8863      	ldrh	r3, [r4, #2]
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
   1b216:	1ac0      	subs	r0, r0, r3
   1b218:	e7f9      	b.n	1b20e <bt_uuid_cmp+0x3a>
   1b21a:	6840      	ldr	r0, [r0, #4]
   1b21c:	6863      	ldr	r3, [r4, #4]
   1b21e:	e7fa      	b.n	1b216 <bt_uuid_cmp+0x42>
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
   1b220:	2210      	movs	r2, #16
   1b222:	1c61      	adds	r1, r4, #1
   1b224:	3001      	adds	r0, #1
   1b226:	e7e8      	b.n	1b1fa <bt_uuid_cmp+0x26>

0001b228 <bt_uuid_create>:

bool bt_uuid_create(struct bt_uuid *uuid, const u8_t *data, u8_t data_len)
{
	/* Copy UUID from packet data/internal variable to internal bt_uuid */
	switch (data_len) {
   1b228:	2a04      	cmp	r2, #4
{
   1b22a:	b538      	push	{r3, r4, r5, lr}
   1b22c:	460c      	mov	r4, r1
	switch (data_len) {
   1b22e:	d00d      	beq.n	1b24c <bt_uuid_create+0x24>
   1b230:	2a10      	cmp	r2, #16
   1b232:	d019      	beq.n	1b268 <bt_uuid_create+0x40>
   1b234:	2a02      	cmp	r2, #2
   1b236:	f04f 0300 	mov.w	r3, #0
   1b23a:	d11b      	bne.n	1b274 <bt_uuid_create+0x4c>
	case 2:
		uuid->type = BT_UUID_TYPE_16;
   1b23c:	7003      	strb	r3, [r0, #0]
	return ((u16_t)src[1] << 8) | src[0];
   1b23e:	784a      	ldrb	r2, [r1, #1]
   1b240:	780b      	ldrb	r3, [r1, #0]
   1b242:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		BT_UUID_16(uuid)->val = sys_get_le16(data);
   1b246:	8043      	strh	r3, [r0, #2]
		memcpy(&BT_UUID_128(uuid)->val, data, 16);
		break;
	default:
		return false;
	}
	return true;
   1b248:	2001      	movs	r0, #1
}
   1b24a:	bd38      	pop	{r3, r4, r5, pc}
		uuid->type = BT_UUID_TYPE_32;
   1b24c:	2301      	movs	r3, #1
   1b24e:	7003      	strb	r3, [r0, #0]
   1b250:	78a2      	ldrb	r2, [r4, #2]
   1b252:	78c9      	ldrb	r1, [r1, #3]
   1b254:	7865      	ldrb	r5, [r4, #1]
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   1b256:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
	return ((u16_t)src[1] << 8) | src[0];
   1b25a:	7822      	ldrb	r2, [r4, #0]
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   1b25c:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
   1b260:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
		BT_UUID_32(uuid)->val = sys_get_le32(data);
   1b264:	6042      	str	r2, [r0, #4]
		break;
   1b266:	e7ef      	b.n	1b248 <bt_uuid_create+0x20>
		uuid->type = BT_UUID_TYPE_128;
   1b268:	2302      	movs	r3, #2
   1b26a:	f800 3b01 	strb.w	r3, [r0], #1
		memcpy(&BT_UUID_128(uuid)->val, data, 16);
   1b26e:	f7ff fec4 	bl	1affa <memcpy>
		break;
   1b272:	e7e9      	b.n	1b248 <bt_uuid_create+0x20>
		return false;
   1b274:	4618      	mov	r0, r3
   1b276:	e7e8      	b.n	1b24a <bt_uuid_create+0x22>

0001b278 <atomic_and>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1b278:	f3bf 8f5b 	dmb	ish
   1b27c:	e850 3f00 	ldrex	r3, [r0]
   1b280:	ea03 0201 	and.w	r2, r3, r1
   1b284:	e840 2c00 	strex	ip, r2, [r0]
   1b288:	f1bc 0f00 	cmp.w	ip, #0
   1b28c:	d1f6      	bne.n	1b27c <atomic_and+0x4>
   1b28e:	f3bf 8f5b 	dmb	ish
}
   1b292:	4618      	mov	r0, r3
   1b294:	4770      	bx	lr

0001b296 <bt_addr_copy>:
   1b296:	2206      	movs	r2, #6
   1b298:	f7ff beaf 	b.w	1affa <memcpy>

0001b29c <bt_addr_le_copy>:
	memcpy(dst, src, sizeof(*dst));
   1b29c:	2207      	movs	r2, #7
   1b29e:	f7ff beac 	b.w	1affa <memcpy>

0001b2a2 <atomic_or>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1b2a2:	f3bf 8f5b 	dmb	ish
   1b2a6:	e850 3f00 	ldrex	r3, [r0]
   1b2aa:	ea43 0201 	orr.w	r2, r3, r1
   1b2ae:	e840 2c00 	strex	ip, r2, [r0]
   1b2b2:	f1bc 0f00 	cmp.w	ip, #0
   1b2b6:	d1f6      	bne.n	1b2a6 <atomic_or+0x4>
   1b2b8:	f3bf 8f5b 	dmb	ish
}
   1b2bc:	4618      	mov	r0, r3
   1b2be:	4770      	bx	lr

0001b2c0 <atomic_set_bit_to>:
 * @param val true for 1, false for 0.
 *
 * @return N/A
 */
static inline void atomic_set_bit_to(atomic_t *target, int bit, bool val)
{
   1b2c0:	460b      	mov	r3, r1
   1b2c2:	b410      	push	{r4}
   1b2c4:	095b      	lsrs	r3, r3, #5
	atomic_val_t mask = ATOMIC_MASK(bit);
   1b2c6:	f001 041f 	and.w	r4, r1, #31
   1b2ca:	2101      	movs	r1, #1
   1b2cc:	40a1      	lsls	r1, r4

	if (val) {
   1b2ce:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   1b2d2:	b112      	cbz	r2, 1b2da <atomic_set_bit_to+0x1a>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
	} else {
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
	}
}
   1b2d4:	bc10      	pop	{r4}
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   1b2d6:	f7ff bfe4 	b.w	1b2a2 <atomic_or>
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   1b2da:	43c9      	mvns	r1, r1
}
   1b2dc:	bc10      	pop	{r4}
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   1b2de:	f7ff bfcb 	b.w	1b278 <atomic_and>

0001b2e2 <unpair>:
{
   1b2e2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b2e4:	4606      	mov	r6, r0
   1b2e6:	460f      	mov	r7, r1
	struct bt_conn *conn = bt_conn_lookup_addr_le(id, addr);
   1b2e8:	f7ed f848 	bl	837c <bt_conn_lookup_addr_le>
	if (conn) {
   1b2ec:	4604      	mov	r4, r0
   1b2ee:	b970      	cbnz	r0, 1b30e <unpair+0x2c>
			keys = bt_keys_find_addr(id, addr);
   1b2f0:	4639      	mov	r1, r7
   1b2f2:	4630      	mov	r0, r6
   1b2f4:	f7f2 fa54 	bl	d7a0 <bt_keys_find_addr>
		if (keys) {
   1b2f8:	4605      	mov	r5, r0
   1b2fa:	b110      	cbz	r0, 1b302 <unpair+0x20>
			bt_keys_clear(keys);
   1b2fc:	4628      	mov	r0, r5
   1b2fe:	f7f2 fa5f 	bl	d7c0 <bt_keys_clear>
		bt_gatt_clear(id, addr);
   1b302:	4639      	mov	r1, r7
   1b304:	4630      	mov	r0, r6
}
   1b306:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		bt_gatt_clear(id, addr);
   1b30a:	f7f0 bbb1 	b.w	ba70 <bt_gatt_clear>
		if (conn->type == BT_CONN_TYPE_LE) {
   1b30e:	7883      	ldrb	r3, [r0, #2]
   1b310:	2b01      	cmp	r3, #1
   1b312:	f04f 0300 	mov.w	r3, #0
			keys = conn->le.keys;
   1b316:	bf04      	itt	eq
   1b318:	f8d0 509c 	ldreq.w	r5, [r0, #156]	; 0x9c
			conn->le.keys = NULL;
   1b31c:	f8c0 309c 	streq.w	r3, [r0, #156]	; 0x9c
		bt_conn_disconnect(conn, BT_HCI_ERR_REMOTE_USER_TERM_CONN);
   1b320:	f04f 0113 	mov.w	r1, #19
	struct bt_keys *keys = NULL;
   1b324:	bf18      	it	ne
   1b326:	461d      	movne	r5, r3
		bt_conn_disconnect(conn, BT_HCI_ERR_REMOTE_USER_TERM_CONN);
   1b328:	f000 f94c 	bl	1b5c4 <bt_conn_disconnect>
		bt_conn_unref(conn);
   1b32c:	4620      	mov	r0, r4
   1b32e:	f000 f946 	bl	1b5be <bt_conn_unref>
		if (!keys) {
   1b332:	2d00      	cmp	r5, #0
   1b334:	d1e2      	bne.n	1b2fc <unpair+0x1a>
   1b336:	e7db      	b.n	1b2f0 <unpair+0xe>

0001b338 <unpair_remote>:
	unpair(*id, &info->addr);
   1b338:	780b      	ldrb	r3, [r1, #0]
   1b33a:	4601      	mov	r1, r0
   1b33c:	4618      	mov	r0, r3
   1b33e:	f7ff bfd0 	b.w	1b2e2 <unpair>

0001b342 <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1b342:	f3bf 8f5b 	dmb	ish
   1b346:	6800      	ldr	r0, [r0, #0]
   1b348:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   1b34c:	4108      	asrs	r0, r1
}
   1b34e:	f000 0001 	and.w	r0, r0, #1
   1b352:	4770      	bx	lr

0001b354 <sys_put_le64>:
	dst[1] = val >> 8;
   1b354:	f3c0 2307 	ubfx	r3, r0, #8, #8
	dst[0] = val;
   1b358:	7010      	strb	r0, [r2, #0]
	dst[1] = val >> 8;
   1b35a:	0e00      	lsrs	r0, r0, #24
   1b35c:	7053      	strb	r3, [r2, #1]
   1b35e:	70d0      	strb	r0, [r2, #3]
	dst[0] = val;
   1b360:	2300      	movs	r3, #0
	dst[1] = val >> 8;
   1b362:	f3c1 2007 	ubfx	r0, r1, #8, #8
   1b366:	0e09      	lsrs	r1, r1, #24
	dst[0] = val;
   1b368:	7093      	strb	r3, [r2, #2]
   1b36a:	7113      	strb	r3, [r2, #4]
	dst[1] = val >> 8;
   1b36c:	7150      	strb	r0, [r2, #5]
	dst[0] = val;
   1b36e:	7193      	strb	r3, [r2, #6]
	dst[1] = val >> 8;
   1b370:	71d1      	strb	r1, [r2, #7]
}
   1b372:	4770      	bx	lr

0001b374 <keys_add_id>:
	hci_id_add(&keys->addr, keys->irk.val);
   1b374:	f100 0126 	add.w	r1, r0, #38	; 0x26
   1b378:	3001      	adds	r0, #1
   1b37a:	f7ea bfcf 	b.w	631c <hci_id_add>

0001b37e <addr_res_enable>:
{
   1b37e:	b538      	push	{r3, r4, r5, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE, 1);
   1b380:	2101      	movs	r1, #1
{
   1b382:	4605      	mov	r5, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE, 1);
   1b384:	f242 002d 	movw	r0, #8237	; 0x202d
   1b388:	f7ea fd56 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
   1b38c:	4604      	mov	r4, r0
   1b38e:	b158      	cbz	r0, 1b3a8 <addr_res_enable+0x2a>
	net_buf_add_u8(buf, enable);
   1b390:	4629      	mov	r1, r5
   1b392:	3008      	adds	r0, #8
   1b394:	f002 fc69 	bl	1dc6a <net_buf_simple_add_u8>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE,
   1b398:	4621      	mov	r1, r4
   1b39a:	2200      	movs	r2, #0
   1b39c:	f242 002d 	movw	r0, #8237	; 0x202d
}
   1b3a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE,
   1b3a4:	f7ea beb6 	b.w	6114 <bt_hci_cmd_send_sync>
}
   1b3a8:	f06f 0036 	mvn.w	r0, #54	; 0x36
   1b3ac:	bd38      	pop	{r3, r4, r5, pc}

0001b3ae <bt_lookup_id_addr>:
{
   1b3ae:	b510      	push	{r4, lr}
   1b3b0:	460c      	mov	r4, r1
		keys = bt_keys_find_irk(id, addr);
   1b3b2:	f7f2 f9bb 	bl	d72c <bt_keys_find_irk>
		if (keys) {
   1b3b6:	b100      	cbz	r0, 1b3ba <bt_lookup_id_addr+0xc>
			return &keys->addr;
   1b3b8:	1c44      	adds	r4, r0, #1
}
   1b3ba:	4620      	mov	r0, r4
   1b3bc:	bd10      	pop	{r4, pc}

0001b3be <bt_le_conn_params_valid>:
	if (param->interval_min > param->interval_max ||
   1b3be:	8802      	ldrh	r2, [r0, #0]
   1b3c0:	8843      	ldrh	r3, [r0, #2]
   1b3c2:	429a      	cmp	r2, r3
{
   1b3c4:	b510      	push	{r4, lr}
	if (param->interval_min > param->interval_max ||
   1b3c6:	d818      	bhi.n	1b3fa <bt_le_conn_params_valid+0x3c>
   1b3c8:	2a05      	cmp	r2, #5
   1b3ca:	d916      	bls.n	1b3fa <bt_le_conn_params_valid+0x3c>
	    param->interval_min < 6 || param->interval_max > 3200) {
   1b3cc:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   1b3d0:	d813      	bhi.n	1b3fa <bt_le_conn_params_valid+0x3c>
	if (param->latency > 499) {
   1b3d2:	8884      	ldrh	r4, [r0, #4]
   1b3d4:	f5b4 7ffa 	cmp.w	r4, #500	; 0x1f4
   1b3d8:	d20f      	bcs.n	1b3fa <bt_le_conn_params_valid+0x3c>
	if (param->timeout < 10 || param->timeout > 3200 ||
   1b3da:	88c1      	ldrh	r1, [r0, #6]
   1b3dc:	f1a1 020a 	sub.w	r2, r1, #10
   1b3e0:	b292      	uxth	r2, r2
   1b3e2:	f640 4076 	movw	r0, #3190	; 0xc76
   1b3e6:	4282      	cmp	r2, r0
   1b3e8:	d807      	bhi.n	1b3fa <bt_le_conn_params_valid+0x3c>
	     ((1 + param->latency) * param->interval_max))) {
   1b3ea:	fb04 3303 	mla	r3, r4, r3, r3
	if (param->timeout < 10 || param->timeout > 3200 ||
   1b3ee:	ebb3 0f81 	cmp.w	r3, r1, lsl #2
   1b3f2:	bf34      	ite	cc
   1b3f4:	2001      	movcc	r0, #1
   1b3f6:	2000      	movcs	r0, #0
}
   1b3f8:	bd10      	pop	{r4, pc}
		return false;
   1b3fa:	2000      	movs	r0, #0
   1b3fc:	e7fc      	b.n	1b3f8 <bt_le_conn_params_valid+0x3a>

0001b3fe <update_pending_id>:
	if (keys->flags & BT_KEYS_ID_PENDING_ADD) {
   1b3fe:	7a43      	ldrb	r3, [r0, #9]
   1b400:	0759      	lsls	r1, r3, #29
   1b402:	d504      	bpl.n	1b40e <update_pending_id+0x10>
		keys->flags &= ~BT_KEYS_ID_PENDING_ADD;
   1b404:	f023 0304 	bic.w	r3, r3, #4
   1b408:	7243      	strb	r3, [r0, #9]
		bt_id_add(keys);
   1b40a:	f7eb b9bd 	b.w	6788 <bt_id_add>
	if (keys->flags & BT_KEYS_ID_PENDING_DEL) {
   1b40e:	0719      	lsls	r1, r3, #28
   1b410:	d504      	bpl.n	1b41c <update_pending_id+0x1e>
		keys->flags &= ~BT_KEYS_ID_PENDING_DEL;
   1b412:	f023 0308 	bic.w	r3, r3, #8
   1b416:	7243      	strb	r3, [r0, #9]
		bt_id_del(keys);
   1b418:	f7eb ba94 	b.w	6944 <bt_id_del>
}
   1b41c:	4770      	bx	lr

0001b41e <bt_addr_le_create_static>:
	addr->type = BT_ADDR_LE_RANDOM;
   1b41e:	2301      	movs	r3, #1
{
   1b420:	b510      	push	{r4, lr}
	return bt_rand(addr->a.val, 6);
   1b422:	2106      	movs	r1, #6
{
   1b424:	4604      	mov	r4, r0
	addr->type = BT_ADDR_LE_RANDOM;
   1b426:	f800 3b01 	strb.w	r3, [r0], #1
	return bt_rand(addr->a.val, 6);
   1b42a:	f7f4 fb19 	bl	fa60 <bt_rand>
	if (err) {
   1b42e:	b918      	cbnz	r0, 1b438 <bt_addr_le_create_static+0x1a>
	BT_ADDR_SET_STATIC(&addr->a);
   1b430:	79a3      	ldrb	r3, [r4, #6]
   1b432:	f063 033f 	orn	r3, r3, #63	; 0x3f
   1b436:	71a3      	strb	r3, [r4, #6]
}
   1b438:	bd10      	pop	{r4, pc}

0001b43a <bt_send>:
		return bt_hci_ecc_send(buf);
   1b43a:	f7e9 bde9 	b.w	5010 <bt_hci_ecc_send>

0001b43e <bt_addr_le_is_bonded>:
{
   1b43e:	b508      	push	{r3, lr}
		struct bt_keys *keys = bt_keys_find_addr(id, addr);
   1b440:	f7f2 f9ae 	bl	d7a0 <bt_keys_find_addr>
		return keys && keys->keys;
   1b444:	b118      	cbz	r0, 1b44e <bt_addr_le_is_bonded+0x10>
   1b446:	8940      	ldrh	r0, [r0, #10]
   1b448:	3000      	adds	r0, #0
   1b44a:	bf18      	it	ne
   1b44c:	2001      	movne	r0, #1
}
   1b44e:	bd08      	pop	{r3, pc}

0001b450 <bt_le_adv_start>:
{
   1b450:	b513      	push	{r0, r1, r4, lr}
	if (param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) {
   1b452:	7844      	ldrb	r4, [r0, #1]
   1b454:	f014 0410 	ands.w	r4, r4, #16
   1b458:	d106      	bne.n	1b468 <bt_le_adv_start+0x18>
	return bt_le_adv_start_internal(param, ad, ad_len, sd, sd_len, NULL);
   1b45a:	9401      	str	r4, [sp, #4]
   1b45c:	9c04      	ldr	r4, [sp, #16]
   1b45e:	9400      	str	r4, [sp, #0]
   1b460:	f7eb ff60 	bl	7324 <bt_le_adv_start_internal>
}
   1b464:	b002      	add	sp, #8
   1b466:	bd10      	pop	{r4, pc}
		return -EINVAL;
   1b468:	f06f 0015 	mvn.w	r0, #21
   1b46c:	e7fa      	b.n	1b464 <bt_le_adv_start+0x14>

0001b46e <le_enh_conn_complete>:
	enh_conn_complete((void *)buf->data);
   1b46e:	6880      	ldr	r0, [r0, #8]
   1b470:	f7ec b96e 	b.w	7750 <enh_conn_complete>

0001b474 <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1b474:	f3bf 8f5b 	dmb	ish
   1b478:	6800      	ldr	r0, [r0, #0]
   1b47a:	f3bf 8f5b 	dmb	ish
}
   1b47e:	4770      	bx	lr

0001b480 <atomic_test_bit>:
{
   1b480:	b508      	push	{r3, lr}
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   1b482:	f7ff fff7 	bl	1b474 <atomic_get>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   1b486:	4108      	asrs	r0, r1
}
   1b488:	f000 0001 	and.w	r0, r0, #1
   1b48c:	bd08      	pop	{r3, pc}

0001b48e <bt_conn_reset_rx_state>:
	if (!conn->rx_len) {
   1b48e:	89c3      	ldrh	r3, [r0, #14]
{
   1b490:	b510      	push	{r4, lr}
   1b492:	4604      	mov	r4, r0
	if (!conn->rx_len) {
   1b494:	b12b      	cbz	r3, 1b4a2 <bt_conn_reset_rx_state+0x14>
	net_buf_unref(conn->rx);
   1b496:	6900      	ldr	r0, [r0, #16]
   1b498:	f7fb f842 	bl	16520 <net_buf_unref>
	conn->rx = NULL;
   1b49c:	2300      	movs	r3, #0
   1b49e:	6123      	str	r3, [r4, #16]
	conn->rx_len = 0U;
   1b4a0:	81e3      	strh	r3, [r4, #14]
}
   1b4a2:	bd10      	pop	{r4, pc}

0001b4a4 <atomic_dec>:
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   1b4a4:	f3bf 8f5b 	dmb	ish
   1b4a8:	e850 3f00 	ldrex	r3, [r0]
   1b4ac:	1e5a      	subs	r2, r3, #1
   1b4ae:	e840 2100 	strex	r1, r2, [r0]
   1b4b2:	2900      	cmp	r1, #0
   1b4b4:	d1f8      	bne.n	1b4a8 <atomic_dec+0x4>
   1b4b6:	f3bf 8f5b 	dmb	ish
}
   1b4ba:	4618      	mov	r0, r3
   1b4bc:	4770      	bx	lr

0001b4be <atomic_inc>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   1b4be:	f3bf 8f5b 	dmb	ish
   1b4c2:	e850 3f00 	ldrex	r3, [r0]
   1b4c6:	1c5a      	adds	r2, r3, #1
   1b4c8:	e840 2100 	strex	r1, r2, [r0]
   1b4cc:	2900      	cmp	r1, #0
   1b4ce:	d1f8      	bne.n	1b4c2 <atomic_inc+0x4>
   1b4d0:	f3bf 8f5b 	dmb	ish
}
   1b4d4:	4618      	mov	r0, r3
   1b4d6:	4770      	bx	lr

0001b4d8 <tx_notify>:
{
   1b4d8:	b570      	push	{r4, r5, r6, lr}
   1b4da:	4604      	mov	r4, r0
	__asm__ volatile(
   1b4dc:	f04f 0220 	mov.w	r2, #32
   1b4e0:	f3ef 8311 	mrs	r3, BASEPRI
   1b4e4:	f382 8811 	msr	BASEPRI, r2
   1b4e8:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
   1b4ec:	6a20      	ldr	r0, [r4, #32]
		if (sys_slist_is_empty(&conn->tx_complete)) {
   1b4ee:	b920      	cbnz	r0, 1b4fa <tx_notify+0x22>
	__asm__ volatile(
   1b4f0:	f383 8811 	msr	BASEPRI, r3
   1b4f4:	f3bf 8f6f 	isb	sy
}
   1b4f8:	bd70      	pop	{r4, r5, r6, pc}
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   1b4fa:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1b4fc:	6802      	ldr	r2, [r0, #0]
	list->head = node;
   1b4fe:	6222      	str	r2, [r4, #32]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   1b500:	4288      	cmp	r0, r1
	list->tail = node;
   1b502:	bf08      	it	eq
   1b504:	6262      	streq	r2, [r4, #36]	; 0x24
   1b506:	f383 8811 	msr	BASEPRI, r3
   1b50a:	f3bf 8f6f 	isb	sy
		user_data = tx->user_data;
   1b50e:	e9d0 5601 	ldrd	r5, r6, [r0, #4]
		tx_free(tx);
   1b512:	f7ec fb3b 	bl	7b8c <tx_free>
		cb(conn, user_data);
   1b516:	4631      	mov	r1, r6
   1b518:	4620      	mov	r0, r4
   1b51a:	47a8      	blx	r5
	while (1) {
   1b51c:	e7de      	b.n	1b4dc <tx_notify+0x4>

0001b51e <tx_complete_work>:
	tx_notify(conn);
   1b51e:	3828      	subs	r0, #40	; 0x28
   1b520:	f7ff bfda 	b.w	1b4d8 <tx_notify>

0001b524 <bt_conn_set_security>:
	if (conn->state != BT_CONN_CONNECTED) {
   1b524:	7b43      	ldrb	r3, [r0, #13]
   1b526:	2b06      	cmp	r3, #6
{
   1b528:	b510      	push	{r4, lr}
   1b52a:	4604      	mov	r4, r0
	if (conn->state != BT_CONN_CONNECTED) {
   1b52c:	d128      	bne.n	1b580 <bt_conn_set_security+0x5c>
	if (conn->sec_level >= sec || conn->required_sec_level >= sec) {
   1b52e:	7a43      	ldrb	r3, [r0, #9]
   1b530:	428b      	cmp	r3, r1
   1b532:	d228      	bcs.n	1b586 <bt_conn_set_security+0x62>
   1b534:	7a83      	ldrb	r3, [r0, #10]
   1b536:	428b      	cmp	r3, r1
   1b538:	d225      	bcs.n	1b586 <bt_conn_set_security+0x62>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1b53a:	f3bf 8f5b 	dmb	ish
	if (val) {
   1b53e:	060a      	lsls	r2, r1, #24
	atomic_set_bit_to(conn->flags, BT_CONN_FORCE_PAIR,
   1b540:	f100 0304 	add.w	r3, r0, #4
   1b544:	d513      	bpl.n	1b56e <bt_conn_set_security+0x4a>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1b546:	e853 2f00 	ldrex	r2, [r3]
   1b54a:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
   1b54e:	e843 2000 	strex	r0, r2, [r3]
   1b552:	2800      	cmp	r0, #0
   1b554:	d1f7      	bne.n	1b546 <bt_conn_set_security+0x22>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1b556:	f3bf 8f5b 	dmb	ish
	conn->required_sec_level = sec & ~BT_SECURITY_FORCE_PAIR;
   1b55a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
   1b55e:	72a1      	strb	r1, [r4, #10]
		return bt_smp_start_security(conn);
   1b560:	4620      	mov	r0, r4
   1b562:	f7f1 feeb 	bl	d33c <bt_smp_start_security>
	if (err) {
   1b566:	b108      	cbz	r0, 1b56c <bt_conn_set_security+0x48>
		conn->required_sec_level = conn->sec_level;
   1b568:	7a63      	ldrb	r3, [r4, #9]
   1b56a:	72a3      	strb	r3, [r4, #10]
}
   1b56c:	bd10      	pop	{r4, pc}
   1b56e:	e853 2f00 	ldrex	r2, [r3]
   1b572:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
   1b576:	e843 2000 	strex	r0, r2, [r3]
   1b57a:	2800      	cmp	r0, #0
   1b57c:	d0eb      	beq.n	1b556 <bt_conn_set_security+0x32>
   1b57e:	e7f6      	b.n	1b56e <bt_conn_set_security+0x4a>
		return -ENOTCONN;
   1b580:	f06f 0038 	mvn.w	r0, #56	; 0x38
   1b584:	e7f2      	b.n	1b56c <bt_conn_set_security+0x48>
		return 0;
   1b586:	2000      	movs	r0, #0
   1b588:	e7f0      	b.n	1b56c <bt_conn_set_security+0x48>

0001b58a <bt_conn_get_security>:
}
   1b58a:	7a40      	ldrb	r0, [r0, #9]
   1b58c:	4770      	bx	lr

0001b58e <bt_conn_addr_le_cmp>:
{
   1b58e:	b538      	push	{r3, r4, r5, lr}
   1b590:	460d      	mov	r5, r1
   1b592:	4604      	mov	r4, r0
	return memcmp(a, b, sizeof(*a));
   1b594:	f100 0170 	add.w	r1, r0, #112	; 0x70
   1b598:	2207      	movs	r2, #7
   1b59a:	4628      	mov	r0, r5
   1b59c:	f7ff fd1d 	bl	1afda <memcmp>
	if (!bt_addr_le_cmp(peer, &conn->le.dst)) {
   1b5a0:	b160      	cbz	r0, 1b5bc <bt_conn_addr_le_cmp+0x2e>
	if (conn->role == BT_HCI_ROLE_MASTER) {
   1b5a2:	78e3      	ldrb	r3, [r4, #3]
   1b5a4:	2207      	movs	r2, #7
   1b5a6:	b933      	cbnz	r3, 1b5b6 <bt_conn_addr_le_cmp+0x28>
   1b5a8:	f104 017e 	add.w	r1, r4, #126	; 0x7e
   1b5ac:	4628      	mov	r0, r5
}
   1b5ae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1b5b2:	f7ff bd12 	b.w	1afda <memcmp>
   1b5b6:	f104 0177 	add.w	r1, r4, #119	; 0x77
   1b5ba:	e7f7      	b.n	1b5ac <bt_conn_addr_le_cmp+0x1e>
   1b5bc:	bd38      	pop	{r3, r4, r5, pc}

0001b5be <bt_conn_unref>:
	atomic_dec(&conn->ref);
   1b5be:	304c      	adds	r0, #76	; 0x4c
   1b5c0:	f7ff bf70 	b.w	1b4a4 <atomic_dec>

0001b5c4 <bt_conn_disconnect>:
	switch (conn->state) {
   1b5c4:	7b43      	ldrb	r3, [r0, #13]
   1b5c6:	3b01      	subs	r3, #1
{
   1b5c8:	b570      	push	{r4, r5, r6, lr}
   1b5ca:	4604      	mov	r4, r0
   1b5cc:	460e      	mov	r6, r1
	switch (conn->state) {
   1b5ce:	2b06      	cmp	r3, #6
   1b5d0:	d805      	bhi.n	1b5de <bt_conn_disconnect+0x1a>
   1b5d2:	e8df f003 	tbb	[pc, r3]
   1b5d6:	0408      	.short	0x0408
   1b5d8:	160c0e04 	.word	0x160c0e04
   1b5dc:	0c          	.byte	0x0c
   1b5dd:	00          	.byte	0x00
		return -ENOTCONN;
   1b5de:	f06f 0538 	mvn.w	r5, #56	; 0x38
}
   1b5e2:	4628      	mov	r0, r5
   1b5e4:	bd70      	pop	{r4, r5, r6, pc}
		conn->err = reason;
   1b5e6:	7321      	strb	r1, [r4, #12]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   1b5e8:	2100      	movs	r1, #0
   1b5ea:	f7ec fde3 	bl	81b4 <bt_conn_set_state>
		return 0;
   1b5ee:	2500      	movs	r5, #0
   1b5f0:	e7f7      	b.n	1b5e2 <bt_conn_disconnect+0x1e>
		conn->err = reason;
   1b5f2:	7321      	strb	r1, [r4, #12]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   1b5f4:	2100      	movs	r1, #0
   1b5f6:	f7ec fddd 	bl	81b4 <bt_conn_set_state>
}
   1b5fa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			return bt_le_adv_stop();
   1b5fe:	f7eb bfed 	b.w	75dc <bt_le_adv_stop>
	buf = bt_hci_cmd_create(BT_HCI_OP_DISCONNECT, sizeof(*disconn));
   1b602:	2103      	movs	r1, #3
   1b604:	f240 4006 	movw	r0, #1030	; 0x406
   1b608:	f7ea fc16 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
   1b60c:	4605      	mov	r5, r0
   1b60e:	b198      	cbz	r0, 1b638 <bt_conn_disconnect+0x74>
	disconn = net_buf_add(buf, sizeof(*disconn));
   1b610:	2103      	movs	r1, #3
   1b612:	3008      	adds	r0, #8
   1b614:	f002 fb1a 	bl	1dc4c <net_buf_simple_add>
	disconn->handle = sys_cpu_to_le16(conn->handle);
   1b618:	8823      	ldrh	r3, [r4, #0]
   1b61a:	8003      	strh	r3, [r0, #0]
	disconn->reason = reason;
   1b61c:	7086      	strb	r6, [r0, #2]
	err = bt_hci_cmd_send(BT_HCI_OP_DISCONNECT, buf);
   1b61e:	4629      	mov	r1, r5
   1b620:	f240 4006 	movw	r0, #1030	; 0x406
   1b624:	f7ea fc3e 	bl	5ea4 <bt_hci_cmd_send>
	if (err) {
   1b628:	4605      	mov	r5, r0
   1b62a:	2800      	cmp	r0, #0
   1b62c:	d1d9      	bne.n	1b5e2 <bt_conn_disconnect+0x1e>
	bt_conn_set_state(conn, BT_CONN_DISCONNECT);
   1b62e:	2107      	movs	r1, #7
   1b630:	4620      	mov	r0, r4
   1b632:	f7ec fdbf 	bl	81b4 <bt_conn_set_state>
	return 0;
   1b636:	e7d4      	b.n	1b5e2 <bt_conn_disconnect+0x1e>
		return -ENOBUFS;
   1b638:	f06f 0536 	mvn.w	r5, #54	; 0x36
   1b63c:	e7d1      	b.n	1b5e2 <bt_conn_disconnect+0x1e>

0001b63e <bt_conn_le_conn_update>:
{
   1b63e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b640:	4607      	mov	r7, r0
   1b642:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_UPDATE,
   1b644:	f242 0013 	movw	r0, #8211	; 0x2013
   1b648:	210e      	movs	r1, #14
   1b64a:	f7ea fbf5 	bl	5e38 <bt_hci_cmd_create>
	if (!buf) {
   1b64e:	4606      	mov	r6, r0
   1b650:	b1d0      	cbz	r0, 1b688 <bt_conn_le_conn_update+0x4a>
	conn_update = net_buf_add(buf, sizeof(*conn_update));
   1b652:	210e      	movs	r1, #14
   1b654:	3008      	adds	r0, #8
   1b656:	f002 faf9 	bl	1dc4c <net_buf_simple_add>
	(void)memset(conn_update, 0, sizeof(*conn_update));
   1b65a:	220e      	movs	r2, #14
	conn_update = net_buf_add(buf, sizeof(*conn_update));
   1b65c:	4604      	mov	r4, r0
	(void)memset(conn_update, 0, sizeof(*conn_update));
   1b65e:	2100      	movs	r1, #0
   1b660:	f7ff fcf5 	bl	1b04e <memset>
	conn_update->handle = sys_cpu_to_le16(conn->handle);
   1b664:	883b      	ldrh	r3, [r7, #0]
   1b666:	8023      	strh	r3, [r4, #0]
	conn_update->conn_interval_min = sys_cpu_to_le16(param->interval_min);
   1b668:	882b      	ldrh	r3, [r5, #0]
   1b66a:	8063      	strh	r3, [r4, #2]
	conn_update->conn_interval_max = sys_cpu_to_le16(param->interval_max);
   1b66c:	886b      	ldrh	r3, [r5, #2]
   1b66e:	80a3      	strh	r3, [r4, #4]
	conn_update->conn_latency = sys_cpu_to_le16(param->latency);
   1b670:	88ab      	ldrh	r3, [r5, #4]
   1b672:	80e3      	strh	r3, [r4, #6]
	conn_update->supervision_timeout = sys_cpu_to_le16(param->timeout);
   1b674:	88eb      	ldrh	r3, [r5, #6]
   1b676:	8123      	strh	r3, [r4, #8]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   1b678:	4631      	mov	r1, r6
   1b67a:	2200      	movs	r2, #0
   1b67c:	f242 0013 	movw	r0, #8211	; 0x2013
}
   1b680:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   1b684:	f7ea bd46 	b.w	6114 <bt_hci_cmd_send_sync>
}
   1b688:	f06f 0036 	mvn.w	r0, #54	; 0x36
   1b68c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001b68e <l2cap_connected>:
}
   1b68e:	4770      	bx	lr

0001b690 <l2cap_disconnected>:
   1b690:	4770      	bx	lr

0001b692 <bt_l2cap_chan_remove>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   1b692:	6c43      	ldr	r3, [r0, #68]	; 0x44
{
   1b694:	b510      	push	{r4, lr}
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   1b696:	b17b      	cbz	r3, 1b6b8 <bt_l2cap_chan_remove+0x26>
   1b698:	3b08      	subs	r3, #8
   1b69a:	2200      	movs	r2, #0
   1b69c:	b163      	cbz	r3, 1b6b8 <bt_l2cap_chan_remove+0x26>
		if (chan == ch) {
   1b69e:	428b      	cmp	r3, r1
   1b6a0:	f103 0408 	add.w	r4, r3, #8
   1b6a4:	d10f      	bne.n	1b6c6 <bt_l2cap_chan_remove+0x34>
Z_GENLIST_REMOVE(slist, snode)
   1b6a6:	688b      	ldr	r3, [r1, #8]
   1b6a8:	b93a      	cbnz	r2, 1b6ba <bt_l2cap_chan_remove+0x28>
   1b6aa:	6c82      	ldr	r2, [r0, #72]	; 0x48
	list->head = node;
   1b6ac:	6443      	str	r3, [r0, #68]	; 0x44
Z_GENLIST_REMOVE(slist, snode)
   1b6ae:	4294      	cmp	r4, r2
   1b6b0:	d100      	bne.n	1b6b4 <bt_l2cap_chan_remove+0x22>
	list->tail = node;
   1b6b2:	6483      	str	r3, [r0, #72]	; 0x48
	parent->next = child;
   1b6b4:	2300      	movs	r3, #0
   1b6b6:	608b      	str	r3, [r1, #8]
}
   1b6b8:	bd10      	pop	{r4, pc}
   1b6ba:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   1b6bc:	6c83      	ldr	r3, [r0, #72]	; 0x48
   1b6be:	429c      	cmp	r4, r3
	list->tail = node;
   1b6c0:	bf08      	it	eq
   1b6c2:	6482      	streq	r2, [r0, #72]	; 0x48
   1b6c4:	e7f6      	b.n	1b6b4 <bt_l2cap_chan_remove+0x22>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1b6c6:	689b      	ldr	r3, [r3, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   1b6c8:	2b00      	cmp	r3, #0
   1b6ca:	d0f5      	beq.n	1b6b8 <bt_l2cap_chan_remove+0x26>
   1b6cc:	3b08      	subs	r3, #8
   1b6ce:	4622      	mov	r2, r4
   1b6d0:	e7e4      	b.n	1b69c <bt_l2cap_chan_remove+0xa>

0001b6d2 <bt_l2cap_chan_del>:
	if (!chan->conn) {
   1b6d2:	6803      	ldr	r3, [r0, #0]
{
   1b6d4:	b510      	push	{r4, lr}
   1b6d6:	4604      	mov	r4, r0
	if (!chan->conn) {
   1b6d8:	b12b      	cbz	r3, 1b6e6 <bt_l2cap_chan_del+0x14>
	if (chan->ops->disconnected) {
   1b6da:	6843      	ldr	r3, [r0, #4]
   1b6dc:	685b      	ldr	r3, [r3, #4]
   1b6de:	b103      	cbz	r3, 1b6e2 <bt_l2cap_chan_del+0x10>
		chan->ops->disconnected(chan);
   1b6e0:	4798      	blx	r3
	chan->conn = NULL;
   1b6e2:	2300      	movs	r3, #0
   1b6e4:	6023      	str	r3, [r4, #0]
	if (chan->destroy) {
   1b6e6:	68e3      	ldr	r3, [r4, #12]
   1b6e8:	b10b      	cbz	r3, 1b6ee <bt_l2cap_chan_del+0x1c>
		chan->destroy(chan);
   1b6ea:	4620      	mov	r0, r4
   1b6ec:	4798      	blx	r3
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   1b6ee:	f3bf 8f5b 	dmb	ish
   1b6f2:	3430      	adds	r4, #48	; 0x30
   1b6f4:	2300      	movs	r3, #0
   1b6f6:	e854 2f00 	ldrex	r2, [r4]
   1b6fa:	e844 3100 	strex	r1, r3, [r4]
   1b6fe:	2900      	cmp	r1, #0
   1b700:	d1f9      	bne.n	1b6f6 <bt_l2cap_chan_del+0x24>
   1b702:	f3bf 8f5b 	dmb	ish
}
   1b706:	bd10      	pop	{r4, pc}

0001b708 <bt_l2cap_disconnected>:
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   1b708:	6c43      	ldr	r3, [r0, #68]	; 0x44
{
   1b70a:	b510      	push	{r4, lr}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   1b70c:	b173      	cbz	r3, 1b72c <bt_l2cap_disconnected+0x24>
   1b70e:	f1b3 0008 	subs.w	r0, r3, #8
   1b712:	d00b      	beq.n	1b72c <bt_l2cap_disconnected+0x24>
   1b714:	681c      	ldr	r4, [r3, #0]
   1b716:	b104      	cbz	r4, 1b71a <bt_l2cap_disconnected+0x12>
   1b718:	3c08      	subs	r4, #8
		bt_l2cap_chan_del(chan);
   1b71a:	f7ff ffda 	bl	1b6d2 <bt_l2cap_chan_del>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   1b71e:	b12c      	cbz	r4, 1b72c <bt_l2cap_disconnected+0x24>
   1b720:	68a3      	ldr	r3, [r4, #8]
   1b722:	b103      	cbz	r3, 1b726 <bt_l2cap_disconnected+0x1e>
   1b724:	3b08      	subs	r3, #8
{
   1b726:	4620      	mov	r0, r4
   1b728:	461c      	mov	r4, r3
   1b72a:	e7f6      	b.n	1b71a <bt_l2cap_disconnected+0x12>
}
   1b72c:	bd10      	pop	{r4, pc}

0001b72e <bt_l2cap_encrypt_change>:
{
   1b72e:	b538      	push	{r3, r4, r5, lr}
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   1b730:	6c44      	ldr	r4, [r0, #68]	; 0x44
{
   1b732:	460d      	mov	r5, r1
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   1b734:	b10c      	cbz	r4, 1b73a <bt_l2cap_encrypt_change+0xc>
   1b736:	3c08      	subs	r4, #8
   1b738:	b904      	cbnz	r4, 1b73c <bt_l2cap_encrypt_change+0xe>
}
   1b73a:	bd38      	pop	{r3, r4, r5, pc}
		if (chan->ops->encrypt_change) {
   1b73c:	6863      	ldr	r3, [r4, #4]
   1b73e:	689b      	ldr	r3, [r3, #8]
   1b740:	b113      	cbz	r3, 1b748 <bt_l2cap_encrypt_change+0x1a>
			chan->ops->encrypt_change(chan, hci_status);
   1b742:	4629      	mov	r1, r5
   1b744:	4620      	mov	r0, r4
   1b746:	4798      	blx	r3
   1b748:	68a4      	ldr	r4, [r4, #8]
   1b74a:	e7f3      	b.n	1b734 <bt_l2cap_encrypt_change+0x6>

0001b74c <bt_l2cap_create_pdu_timeout>:
	return bt_conn_create_pdu_timeout(pool,
   1b74c:	3104      	adds	r1, #4
   1b74e:	f7ec bef7 	b.w	8540 <bt_conn_create_pdu_timeout>

0001b752 <bt_l2cap_send_cb>:
{
   1b752:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b756:	4614      	mov	r4, r2
   1b758:	4605      	mov	r5, r0
   1b75a:	4688      	mov	r8, r1
	hdr = net_buf_push(buf, sizeof(*hdr));
   1b75c:	f102 0008 	add.w	r0, r2, #8
   1b760:	2104      	movs	r1, #4
{
   1b762:	461e      	mov	r6, r3
   1b764:	9f06      	ldr	r7, [sp, #24]
	hdr = net_buf_push(buf, sizeof(*hdr));
   1b766:	f002 fa92 	bl	1dc8e <net_buf_simple_push>
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   1b76a:	89a1      	ldrh	r1, [r4, #12]
	hdr->cid = sys_cpu_to_le16(cid);
   1b76c:	f8a0 8002 	strh.w	r8, [r0, #2]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   1b770:	3904      	subs	r1, #4
   1b772:	8001      	strh	r1, [r0, #0]
	return bt_conn_send_cb(conn, buf, cb, user_data);
   1b774:	463b      	mov	r3, r7
   1b776:	4632      	mov	r2, r6
   1b778:	4621      	mov	r1, r4
   1b77a:	4628      	mov	r0, r5
}
   1b77c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_conn_send_cb(conn, buf, cb, user_data);
   1b780:	f7ec bc26 	b.w	7fd0 <bt_conn_send_cb>

0001b784 <bt_l2cap_le_lookup_tx_cid>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   1b784:	6c40      	ldr	r0, [r0, #68]	; 0x44
   1b786:	b108      	cbz	r0, 1b78c <bt_l2cap_le_lookup_tx_cid+0x8>
   1b788:	3808      	subs	r0, #8
   1b78a:	b900      	cbnz	r0, 1b78e <bt_l2cap_le_lookup_tx_cid+0xa>
}
   1b78c:	4770      	bx	lr
		if (BT_L2CAP_LE_CHAN(chan)->tx.cid == cid) {
   1b78e:	f8b0 3040 	ldrh.w	r3, [r0, #64]	; 0x40
   1b792:	428b      	cmp	r3, r1
   1b794:	d0fa      	beq.n	1b78c <bt_l2cap_le_lookup_tx_cid+0x8>
   1b796:	6880      	ldr	r0, [r0, #8]
   1b798:	e7f5      	b.n	1b786 <bt_l2cap_le_lookup_tx_cid+0x2>

0001b79a <bt_l2cap_le_lookup_rx_cid>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   1b79a:	6c40      	ldr	r0, [r0, #68]	; 0x44
   1b79c:	b108      	cbz	r0, 1b7a2 <bt_l2cap_le_lookup_rx_cid+0x8>
   1b79e:	3808      	subs	r0, #8
   1b7a0:	b900      	cbnz	r0, 1b7a4 <bt_l2cap_le_lookup_rx_cid+0xa>
}
   1b7a2:	4770      	bx	lr
		if (BT_L2CAP_LE_CHAN(chan)->rx.cid == cid) {
   1b7a4:	8e83      	ldrh	r3, [r0, #52]	; 0x34
   1b7a6:	428b      	cmp	r3, r1
   1b7a8:	d0fb      	beq.n	1b7a2 <bt_l2cap_le_lookup_rx_cid+0x8>
   1b7aa:	6880      	ldr	r0, [r0, #8]
   1b7ac:	e7f6      	b.n	1b79c <bt_l2cap_le_lookup_rx_cid+0x2>

0001b7ae <bt_l2cap_init>:
void bt_l2cap_init(void)
{
	if (IS_ENABLED(CONFIG_BT_BREDR)) {
		bt_l2cap_br_init();
	}
}
   1b7ae:	4770      	bx	lr

0001b7b0 <att_op_get_type>:
	switch (op) {
   1b7b0:	280e      	cmp	r0, #14
   1b7b2:	d00a      	beq.n	1b7ca <att_op_get_type+0x1a>
   1b7b4:	d81e      	bhi.n	1b7f4 <att_op_get_type+0x44>
   1b7b6:	2807      	cmp	r0, #7
   1b7b8:	d015      	beq.n	1b7e6 <att_op_get_type+0x36>
   1b7ba:	d80d      	bhi.n	1b7d8 <att_op_get_type+0x28>
   1b7bc:	2803      	cmp	r0, #3
   1b7be:	d012      	beq.n	1b7e6 <att_op_get_type+0x36>
   1b7c0:	d805      	bhi.n	1b7ce <att_op_get_type+0x1e>
   1b7c2:	2801      	cmp	r0, #1
   1b7c4:	d00f      	beq.n	1b7e6 <att_op_get_type+0x36>
   1b7c6:	2802      	cmp	r0, #2
   1b7c8:	d12b      	bne.n	1b822 <att_op_get_type+0x72>
		return ATT_REQUEST;
   1b7ca:	2001      	movs	r0, #1
   1b7cc:	4770      	bx	lr
	switch (op) {
   1b7ce:	2805      	cmp	r0, #5
		return ATT_REQUEST;
   1b7d0:	bf0c      	ite	eq
   1b7d2:	2002      	moveq	r0, #2
   1b7d4:	2001      	movne	r0, #1
   1b7d6:	4770      	bx	lr
	switch (op) {
   1b7d8:	280a      	cmp	r0, #10
   1b7da:	d0f6      	beq.n	1b7ca <att_op_get_type+0x1a>
   1b7dc:	d805      	bhi.n	1b7ea <att_op_get_type+0x3a>
   1b7de:	2808      	cmp	r0, #8
   1b7e0:	d0f3      	beq.n	1b7ca <att_op_get_type+0x1a>
   1b7e2:	2809      	cmp	r0, #9
   1b7e4:	d11d      	bne.n	1b822 <att_op_get_type+0x72>
		return ATT_RESPONSE;
   1b7e6:	2002      	movs	r0, #2
   1b7e8:	4770      	bx	lr
	switch (op) {
   1b7ea:	280c      	cmp	r0, #12
		return ATT_RESPONSE;
   1b7ec:	bf0c      	ite	eq
   1b7ee:	2001      	moveq	r0, #1
   1b7f0:	2002      	movne	r0, #2
   1b7f2:	4770      	bx	lr
	switch (op) {
   1b7f4:	2817      	cmp	r0, #23
   1b7f6:	d0f6      	beq.n	1b7e6 <att_op_get_type+0x36>
   1b7f8:	d80b      	bhi.n	1b812 <att_op_get_type+0x62>
   1b7fa:	2811      	cmp	r0, #17
   1b7fc:	d0f3      	beq.n	1b7e6 <att_op_get_type+0x36>
   1b7fe:	d803      	bhi.n	1b808 <att_op_get_type+0x58>
   1b800:	280f      	cmp	r0, #15
   1b802:	d0f0      	beq.n	1b7e6 <att_op_get_type+0x36>
   1b804:	2810      	cmp	r0, #16
   1b806:	e7df      	b.n	1b7c8 <att_op_get_type+0x18>
   1b808:	2813      	cmp	r0, #19
   1b80a:	d0ec      	beq.n	1b7e6 <att_op_get_type+0x36>
   1b80c:	d3dd      	bcc.n	1b7ca <att_op_get_type+0x1a>
   1b80e:	2816      	cmp	r0, #22
   1b810:	e7da      	b.n	1b7c8 <att_op_get_type+0x18>
   1b812:	281d      	cmp	r0, #29
   1b814:	d013      	beq.n	1b83e <att_op_get_type+0x8e>
   1b816:	d80a      	bhi.n	1b82e <att_op_get_type+0x7e>
   1b818:	2819      	cmp	r0, #25
   1b81a:	d0e4      	beq.n	1b7e6 <att_op_get_type+0x36>
   1b81c:	d3d5      	bcc.n	1b7ca <att_op_get_type+0x1a>
   1b81e:	281b      	cmp	r0, #27
   1b820:	d00f      	beq.n	1b842 <att_op_get_type+0x92>
	if (op & ATT_CMD_MASK) {
   1b822:	f010 0f40 	tst.w	r0, #64	; 0x40
		return ATT_COMMAND;
   1b826:	bf0c      	ite	eq
   1b828:	2006      	moveq	r0, #6
   1b82a:	2000      	movne	r0, #0
   1b82c:	4770      	bx	lr
	switch (op) {
   1b82e:	2852      	cmp	r0, #82	; 0x52
   1b830:	d009      	beq.n	1b846 <att_op_get_type+0x96>
   1b832:	28d2      	cmp	r0, #210	; 0xd2
   1b834:	d007      	beq.n	1b846 <att_op_get_type+0x96>
   1b836:	281e      	cmp	r0, #30
   1b838:	d1f3      	bne.n	1b822 <att_op_get_type+0x72>
		return ATT_CONFIRMATION;
   1b83a:	2004      	movs	r0, #4
}
   1b83c:	4770      	bx	lr
		return ATT_INDICATION;
   1b83e:	2005      	movs	r0, #5
   1b840:	4770      	bx	lr
		return ATT_NOTIFICATION;
   1b842:	2003      	movs	r0, #3
   1b844:	4770      	bx	lr
		return ATT_COMMAND;
   1b846:	2000      	movs	r0, #0
   1b848:	4770      	bx	lr

0001b84a <att_notify>:
{
   1b84a:	b538      	push	{r3, r4, r5, lr}
	struct bt_conn *conn = att->chan.chan.conn;
   1b84c:	6805      	ldr	r5, [r0, #0]
	handle = net_buf_pull_le16(buf);
   1b84e:	f101 0008 	add.w	r0, r1, #8
{
   1b852:	460c      	mov	r4, r1
	handle = net_buf_pull_le16(buf);
   1b854:	f002 fa33 	bl	1dcbe <net_buf_simple_pull_le16>
	bt_gatt_notification(conn, handle, buf->data, buf->len);
   1b858:	89a3      	ldrh	r3, [r4, #12]
   1b85a:	68a2      	ldr	r2, [r4, #8]
   1b85c:	4601      	mov	r1, r0
   1b85e:	4628      	mov	r0, r5
   1b860:	f000 fee9 	bl	1c636 <bt_gatt_notification>
}
   1b864:	2000      	movs	r0, #0
   1b866:	bd38      	pop	{r3, r4, r5, pc}

0001b868 <bt_gatt_foreach_attr>:
 *  @param user_data Data to pass to the callback.
 */
static inline void bt_gatt_foreach_attr(u16_t start_handle, u16_t end_handle,
					bt_gatt_attr_func_t func,
					void *user_data)
{
   1b868:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   1b86a:	e9cd 2301 	strd	r2, r3, [sp, #4]
   1b86e:	2300      	movs	r3, #0
   1b870:	9300      	str	r3, [sp, #0]
   1b872:	461a      	mov	r2, r3
   1b874:	f7ee ffce 	bl	a814 <bt_gatt_foreach_attr_type>
				  user_data);
}
   1b878:	b005      	add	sp, #20
   1b87a:	f85d fb04 	ldr.w	pc, [sp], #4

0001b87e <find_info_cb>:
	if (!data->rsp) {
   1b87e:	688b      	ldr	r3, [r1, #8]
{
   1b880:	b570      	push	{r4, r5, r6, lr}
   1b882:	4605      	mov	r5, r0
   1b884:	460c      	mov	r4, r1
	struct bt_att *att = data->att;
   1b886:	680e      	ldr	r6, [r1, #0]
	if (!data->rsp) {
   1b888:	b963      	cbnz	r3, 1b8a4 <find_info_cb+0x26>
		data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   1b88a:	6848      	ldr	r0, [r1, #4]
   1b88c:	2101      	movs	r1, #1
   1b88e:	3008      	adds	r0, #8
   1b890:	f002 f9dc 	bl	1dc4c <net_buf_simple_add>
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   1b894:	682b      	ldr	r3, [r5, #0]
		data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   1b896:	60a0      	str	r0, [r4, #8]
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   1b898:	781b      	ldrb	r3, [r3, #0]
   1b89a:	2b00      	cmp	r3, #0
   1b89c:	bf0c      	ite	eq
   1b89e:	2301      	moveq	r3, #1
   1b8a0:	2302      	movne	r3, #2
   1b8a2:	7003      	strb	r3, [r0, #0]
	switch (data->rsp->format) {
   1b8a4:	68a3      	ldr	r3, [r4, #8]
   1b8a6:	781b      	ldrb	r3, [r3, #0]
   1b8a8:	2b01      	cmp	r3, #1
   1b8aa:	d003      	beq.n	1b8b4 <find_info_cb+0x36>
   1b8ac:	2b02      	cmp	r3, #2
   1b8ae:	d01a      	beq.n	1b8e6 <find_info_cb+0x68>
			return BT_GATT_ITER_STOP;
   1b8b0:	2000      	movs	r0, #0
   1b8b2:	e017      	b.n	1b8e4 <find_info_cb+0x66>
		if (attr->uuid->type != BT_UUID_TYPE_16) {
   1b8b4:	682b      	ldr	r3, [r5, #0]
   1b8b6:	781b      	ldrb	r3, [r3, #0]
   1b8b8:	2b00      	cmp	r3, #0
   1b8ba:	d1f9      	bne.n	1b8b0 <find_info_cb+0x32>
		data->info16 = net_buf_add(data->buf, sizeof(*data->info16));
   1b8bc:	6860      	ldr	r0, [r4, #4]
   1b8be:	2104      	movs	r1, #4
   1b8c0:	3008      	adds	r0, #8
   1b8c2:	f002 f9c3 	bl	1dc4c <net_buf_simple_add>
		data->info16->handle = sys_cpu_to_le16(attr->handle);
   1b8c6:	8a2b      	ldrh	r3, [r5, #16]
		data->info16 = net_buf_add(data->buf, sizeof(*data->info16));
   1b8c8:	60e0      	str	r0, [r4, #12]
		data->info16->handle = sys_cpu_to_le16(attr->handle);
   1b8ca:	8003      	strh	r3, [r0, #0]
		data->info16->uuid = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
   1b8cc:	682b      	ldr	r3, [r5, #0]
   1b8ce:	885b      	ldrh	r3, [r3, #2]
   1b8d0:	8043      	strh	r3, [r0, #2]
		if (att->chan.tx.mtu - data->buf->len >
   1b8d2:	6863      	ldr	r3, [r4, #4]
   1b8d4:	f8b6 0042 	ldrh.w	r0, [r6, #66]	; 0x42
   1b8d8:	899b      	ldrh	r3, [r3, #12]
   1b8da:	1ac0      	subs	r0, r0, r3
			return BT_GATT_ITER_STOP;
   1b8dc:	2804      	cmp	r0, #4
   1b8de:	bf94      	ite	ls
   1b8e0:	2000      	movls	r0, #0
   1b8e2:	2001      	movhi	r0, #1
}
   1b8e4:	bd70      	pop	{r4, r5, r6, pc}
		if (attr->uuid->type != BT_UUID_TYPE_128) {
   1b8e6:	682b      	ldr	r3, [r5, #0]
   1b8e8:	781b      	ldrb	r3, [r3, #0]
   1b8ea:	2b02      	cmp	r3, #2
   1b8ec:	d1e0      	bne.n	1b8b0 <find_info_cb+0x32>
		data->info128 = net_buf_add(data->buf, sizeof(*data->info128));
   1b8ee:	6860      	ldr	r0, [r4, #4]
   1b8f0:	2112      	movs	r1, #18
   1b8f2:	3008      	adds	r0, #8
   1b8f4:	f002 f9aa 	bl	1dc4c <net_buf_simple_add>
		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
   1b8f8:	6829      	ldr	r1, [r5, #0]
		data->info128->handle = sys_cpu_to_le16(attr->handle);
   1b8fa:	8a2b      	ldrh	r3, [r5, #16]
		data->info128 = net_buf_add(data->buf, sizeof(*data->info128));
   1b8fc:	60e0      	str	r0, [r4, #12]
		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
   1b8fe:	2210      	movs	r2, #16
		data->info128->handle = sys_cpu_to_le16(attr->handle);
   1b900:	f820 3b02 	strh.w	r3, [r0], #2
		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
   1b904:	3101      	adds	r1, #1
   1b906:	f7ff fb78 	bl	1affa <memcpy>
		if (att->chan.tx.mtu - data->buf->len >
   1b90a:	6863      	ldr	r3, [r4, #4]
   1b90c:	f8b6 0042 	ldrh.w	r0, [r6, #66]	; 0x42
   1b910:	899b      	ldrh	r3, [r3, #12]
   1b912:	1ac0      	subs	r0, r0, r3
			return BT_GATT_ITER_STOP;
   1b914:	2812      	cmp	r0, #18
   1b916:	e7e2      	b.n	1b8de <find_info_cb+0x60>

0001b918 <read_group_cb>:
{
   1b918:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	struct bt_att *att = data->att;
   1b91c:	680c      	ldr	r4, [r1, #0]
{
   1b91e:	4606      	mov	r6, r0
   1b920:	460d      	mov	r5, r1
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   1b922:	f04f 0800 	mov.w	r8, #0
   1b926:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   1b92a:	a902      	add	r1, sp, #8
   1b92c:	6800      	ldr	r0, [r0, #0]
	struct bt_conn *conn = att->chan.chan.conn;
   1b92e:	6827      	ldr	r7, [r4, #0]
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   1b930:	f88d 8008 	strb.w	r8, [sp, #8]
   1b934:	f8ad 300a 	strh.w	r3, [sp, #10]
   1b938:	f7ff fc4c 	bl	1b1d4 <bt_uuid_cmp>
   1b93c:	b198      	cbz	r0, 1b966 <read_group_cb+0x4e>
	    bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   1b93e:	f642 0301 	movw	r3, #10241	; 0x2801
   1b942:	a903      	add	r1, sp, #12
   1b944:	6830      	ldr	r0, [r6, #0]
   1b946:	f88d 800c 	strb.w	r8, [sp, #12]
   1b94a:	f8ad 300e 	strh.w	r3, [sp, #14]
   1b94e:	f7ff fc41 	bl	1b1d4 <bt_uuid_cmp>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   1b952:	b140      	cbz	r0, 1b966 <read_group_cb+0x4e>
		if (data->group &&
   1b954:	692b      	ldr	r3, [r5, #16]
   1b956:	b123      	cbz	r3, 1b962 <read_group_cb+0x4a>
		    attr->handle > sys_le16_to_cpu(data->group->end_handle)) {
   1b958:	8a32      	ldrh	r2, [r6, #16]
		if (data->group &&
   1b95a:	8859      	ldrh	r1, [r3, #2]
   1b95c:	4291      	cmp	r1, r2
   1b95e:	d200      	bcs.n	1b962 <read_group_cb+0x4a>
			data->group->end_handle = sys_cpu_to_le16(attr->handle);
   1b960:	805a      	strh	r2, [r3, #2]
		return BT_GATT_ITER_CONTINUE;
   1b962:	2001      	movs	r0, #1
   1b964:	e012      	b.n	1b98c <read_group_cb+0x74>
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   1b966:	6869      	ldr	r1, [r5, #4]
   1b968:	6830      	ldr	r0, [r6, #0]
   1b96a:	f7ff fc33 	bl	1b1d4 <bt_uuid_cmp>
   1b96e:	b110      	cbz	r0, 1b976 <read_group_cb+0x5e>
		data->group = NULL;
   1b970:	2300      	movs	r3, #0
   1b972:	612b      	str	r3, [r5, #16]
		return BT_GATT_ITER_CONTINUE;
   1b974:	e7f5      	b.n	1b962 <read_group_cb+0x4a>
	if (data->rsp->len &&
   1b976:	68eb      	ldr	r3, [r5, #12]
   1b978:	68a8      	ldr	r0, [r5, #8]
   1b97a:	781a      	ldrb	r2, [r3, #0]
   1b97c:	b14a      	cbz	r2, 1b992 <read_group_cb+0x7a>
	    att->chan.tx.mtu - data->buf->len < data->rsp->len) {
   1b97e:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
   1b982:	8981      	ldrh	r1, [r0, #12]
   1b984:	1a5b      	subs	r3, r3, r1
	if (data->rsp->len &&
   1b986:	4293      	cmp	r3, r2
   1b988:	da03      	bge.n	1b992 <read_group_cb+0x7a>
		return BT_GATT_ITER_STOP;
   1b98a:	2000      	movs	r0, #0
}
   1b98c:	b004      	add	sp, #16
   1b98e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	data->group = net_buf_add(data->buf, sizeof(*data->group));
   1b992:	2104      	movs	r1, #4
   1b994:	3008      	adds	r0, #8
   1b996:	f002 f959 	bl	1dc4c <net_buf_simple_add>
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   1b99a:	68a9      	ldr	r1, [r5, #8]
	data->group->start_handle = sys_cpu_to_le16(attr->handle);
   1b99c:	8a33      	ldrh	r3, [r6, #16]
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   1b99e:	898a      	ldrh	r2, [r1, #12]
	data->group = net_buf_add(data->buf, sizeof(*data->group));
   1b9a0:	6128      	str	r0, [r5, #16]
	data->group->start_handle = sys_cpu_to_le16(attr->handle);
   1b9a2:	8003      	strh	r3, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(attr->handle);
   1b9a4:	8043      	strh	r3, [r0, #2]
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   1b9a6:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
   1b9aa:	6889      	ldr	r1, [r1, #8]
   1b9ac:	2400      	movs	r4, #0
   1b9ae:	1a9b      	subs	r3, r3, r2
   1b9b0:	9400      	str	r4, [sp, #0]
   1b9b2:	440a      	add	r2, r1
   1b9b4:	f8d6 8004 	ldr.w	r8, [r6, #4]
   1b9b8:	4631      	mov	r1, r6
   1b9ba:	b29b      	uxth	r3, r3
   1b9bc:	4638      	mov	r0, r7
   1b9be:	47c0      	blx	r8
	if (read < 0) {
   1b9c0:	1e01      	subs	r1, r0, #0
   1b9c2:	dbe2      	blt.n	1b98a <read_group_cb+0x72>
	if (!data->rsp->len) {
   1b9c4:	68ee      	ldr	r6, [r5, #12]
   1b9c6:	68ab      	ldr	r3, [r5, #8]
   1b9c8:	7830      	ldrb	r0, [r6, #0]
   1b9ca:	1d0a      	adds	r2, r1, #4
   1b9cc:	b928      	cbnz	r0, 1b9da <read_group_cb+0xc2>
		data->rsp->len = read + sizeof(*data->group);
   1b9ce:	7032      	strb	r2, [r6, #0]
	net_buf_add(data->buf, read);
   1b9d0:	f103 0008 	add.w	r0, r3, #8
   1b9d4:	f002 f93a 	bl	1dc4c <net_buf_simple_add>
	return BT_GATT_ITER_CONTINUE;
   1b9d8:	e7c3      	b.n	1b962 <read_group_cb+0x4a>
	} else if (data->rsp->len != read + sizeof(*data->group)) {
   1b9da:	4290      	cmp	r0, r2
   1b9dc:	d0f8      	beq.n	1b9d0 <read_group_cb+0xb8>
		data->buf->len -= sizeof(*data->group);
   1b9de:	899a      	ldrh	r2, [r3, #12]
   1b9e0:	3a04      	subs	r2, #4
   1b9e2:	819a      	strh	r2, [r3, #12]
		return false;
   1b9e4:	e7d1      	b.n	1b98a <read_group_cb+0x72>

0001b9e6 <read_type_cb>:
{
   1b9e6:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	struct bt_att *att = data->att;
   1b9ea:	680f      	ldr	r7, [r1, #0]
{
   1b9ec:	4605      	mov	r5, r0
   1b9ee:	460e      	mov	r6, r1
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   1b9f0:	6800      	ldr	r0, [r0, #0]
   1b9f2:	6849      	ldr	r1, [r1, #4]
	struct bt_conn *conn = att->chan.chan.conn;
   1b9f4:	f8d7 9000 	ldr.w	r9, [r7]
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   1b9f8:	f7ff fbec 	bl	1b1d4 <bt_uuid_cmp>
   1b9fc:	4680      	mov	r8, r0
   1b9fe:	2800      	cmp	r0, #0
   1ba00:	d14c      	bne.n	1ba9c <read_type_cb+0xb6>
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   1ba02:	2215      	movs	r2, #21
   1ba04:	4629      	mov	r1, r5
   1ba06:	4648      	mov	r0, r9
   1ba08:	f000 fd0f 	bl	1c42a <bt_gatt_check_perm>
   1ba0c:	4604      	mov	r4, r0
   1ba0e:	7530      	strb	r0, [r6, #20]
	if (data->err) {
   1ba10:	b148      	cbz	r0, 1ba26 <read_type_cb+0x40>
		if (data->rsp->len) {
   1ba12:	68f3      	ldr	r3, [r6, #12]
   1ba14:	781c      	ldrb	r4, [r3, #0]
   1ba16:	b114      	cbz	r4, 1ba1e <read_type_cb+0x38>
			data->err = 0x00;
   1ba18:	f886 8014 	strb.w	r8, [r6, #20]
		return BT_GATT_ITER_STOP;
   1ba1c:	4644      	mov	r4, r8
}
   1ba1e:	4620      	mov	r0, r4
   1ba20:	b003      	add	sp, #12
   1ba22:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	data->item = net_buf_add(data->buf, sizeof(*data->item));
   1ba26:	68b0      	ldr	r0, [r6, #8]
   1ba28:	2102      	movs	r1, #2
   1ba2a:	3008      	adds	r0, #8
   1ba2c:	f002 f90e 	bl	1dc4c <net_buf_simple_add>
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   1ba30:	68b1      	ldr	r1, [r6, #8]
	data->item->handle = sys_cpu_to_le16(attr->handle);
   1ba32:	8a2b      	ldrh	r3, [r5, #16]
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   1ba34:	898a      	ldrh	r2, [r1, #12]
	data->item = net_buf_add(data->buf, sizeof(*data->item));
   1ba36:	6130      	str	r0, [r6, #16]
	data->item->handle = sys_cpu_to_le16(attr->handle);
   1ba38:	8003      	strh	r3, [r0, #0]
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   1ba3a:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
   1ba3e:	6889      	ldr	r1, [r1, #8]
   1ba40:	9400      	str	r4, [sp, #0]
   1ba42:	1a9b      	subs	r3, r3, r2
   1ba44:	f8d5 8004 	ldr.w	r8, [r5, #4]
   1ba48:	440a      	add	r2, r1
   1ba4a:	b29b      	uxth	r3, r3
   1ba4c:	4629      	mov	r1, r5
   1ba4e:	4648      	mov	r0, r9
   1ba50:	47c0      	blx	r8
	if (read < 0) {
   1ba52:	1e01      	subs	r1, r0, #0
   1ba54:	da07      	bge.n	1ba66 <read_type_cb+0x80>
	if (err < 0 && err >= -0xff) {
   1ba56:	f111 0fff 	cmn.w	r1, #255	; 0xff
		return -err;
   1ba5a:	bf26      	itte	cs
   1ba5c:	4249      	negcs	r1, r1
   1ba5e:	b2c9      	uxtbcs	r1, r1
	return BT_ATT_ERR_UNLIKELY;
   1ba60:	210e      	movcc	r1, #14
		data->err = err_to_att(read);
   1ba62:	7531      	strb	r1, [r6, #20]
		return BT_GATT_ITER_STOP;
   1ba64:	e7db      	b.n	1ba1e <read_type_cb+0x38>
	if (!data->rsp->len) {
   1ba66:	68f5      	ldr	r5, [r6, #12]
   1ba68:	68b0      	ldr	r0, [r6, #8]
   1ba6a:	782a      	ldrb	r2, [r5, #0]
   1ba6c:	1c8b      	adds	r3, r1, #2
   1ba6e:	b97a      	cbnz	r2, 1ba90 <read_type_cb+0xaa>
		data->rsp->len = read + sizeof(*data->item);
   1ba70:	702b      	strb	r3, [r5, #0]
	net_buf_add(data->buf, read);
   1ba72:	3008      	adds	r0, #8
   1ba74:	f002 f8ea 	bl	1dc4c <net_buf_simple_add>
	return att->chan.tx.mtu - data->buf->len > data->rsp->len ?
   1ba78:	68b3      	ldr	r3, [r6, #8]
   1ba7a:	f8b7 4042 	ldrh.w	r4, [r7, #66]	; 0x42
   1ba7e:	899b      	ldrh	r3, [r3, #12]
   1ba80:	1ae4      	subs	r4, r4, r3
   1ba82:	68f3      	ldr	r3, [r6, #12]
   1ba84:	781b      	ldrb	r3, [r3, #0]
	       BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
   1ba86:	429c      	cmp	r4, r3
   1ba88:	bfd4      	ite	le
   1ba8a:	2400      	movle	r4, #0
   1ba8c:	2401      	movgt	r4, #1
   1ba8e:	e7c6      	b.n	1ba1e <read_type_cb+0x38>
	} else if (data->rsp->len != read + sizeof(*data->item)) {
   1ba90:	429a      	cmp	r2, r3
   1ba92:	d0ee      	beq.n	1ba72 <read_type_cb+0x8c>
		data->buf->len -= sizeof(*data->item);
   1ba94:	8983      	ldrh	r3, [r0, #12]
   1ba96:	3b02      	subs	r3, #2
   1ba98:	8183      	strh	r3, [r0, #12]
		return BT_GATT_ITER_STOP;
   1ba9a:	e7c0      	b.n	1ba1e <read_type_cb+0x38>
		return BT_GATT_ITER_CONTINUE;
   1ba9c:	2401      	movs	r4, #1
   1ba9e:	e7be      	b.n	1ba1e <read_type_cb+0x38>

0001baa0 <att_send_req>:
{
   1baa0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1baa2:	4605      	mov	r5, r0
   1baa4:	460c      	mov	r4, r1
	att->req = req;
   1baa6:	f8c5 1094 	str.w	r1, [r5, #148]	; 0x94
	return z_impl_k_sem_take(sem, timeout);
   1baaa:	2100      	movs	r1, #0
   1baac:	30c0      	adds	r0, #192	; 0xc0
   1baae:	f7fc fd15 	bl	184dc <z_impl_k_sem_take>
	if (k_sem_take(&att->tx_sem, K_NO_WAIT) < 0) {
   1bab2:	2800      	cmp	r0, #0
   1bab4:	da08      	bge.n	1bac8 <att_send_req+0x28>
		k_fifo_put(&att->tx_queue, req->buf);
   1bab6:	f105 00d8 	add.w	r0, r5, #216	; 0xd8
   1baba:	6921      	ldr	r1, [r4, #16]
   1babc:	f002 fc46 	bl	1e34c <k_queue_append>
		return 0;
   1bac0:	2500      	movs	r5, #0
}
   1bac2:	4628      	mov	r0, r5
   1bac4:	b002      	add	sp, #8
   1bac6:	bd70      	pop	{r4, r5, r6, pc}
	net_buf_simple_save(&req->buf->b, &req->state);
   1bac8:	6926      	ldr	r6, [r4, #16]
	state->offset = net_buf_simple_headroom(buf);
   1baca:	f106 0008 	add.w	r0, r6, #8
   1bace:	f002 f8fe 	bl	1dcce <net_buf_simple_headroom>
	state->len = buf->len;
   1bad2:	89b3      	ldrh	r3, [r6, #12]
	state->offset = net_buf_simple_headroom(buf);
   1bad4:	81a0      	strh	r0, [r4, #12]
	state->len = buf->len;
   1bad6:	81e3      	strh	r3, [r4, #14]
	err = bt_l2cap_send_cb(att->chan.chan.conn, BT_L2CAP_CID_ATT,
   1bad8:	6920      	ldr	r0, [r4, #16]
   1bada:	682d      	ldr	r5, [r5, #0]
   1badc:	f002 f8b2 	bl	1dc44 <net_buf_ref>
   1bae0:	6923      	ldr	r3, [r4, #16]
   1bae2:	4602      	mov	r2, r0
   1bae4:	6898      	ldr	r0, [r3, #8]
   1bae6:	f7ed f867 	bl	8bb8 <att_cb.isra.6>
   1baea:	2600      	movs	r6, #0
   1baec:	4603      	mov	r3, r0
   1baee:	9600      	str	r6, [sp, #0]
   1baf0:	4628      	mov	r0, r5
   1baf2:	2104      	movs	r1, #4
   1baf4:	f7ff fe2d 	bl	1b752 <bt_l2cap_send_cb>
	if (err) {
   1baf8:	4605      	mov	r5, r0
   1bafa:	2800      	cmp	r0, #0
   1bafc:	d0e1      	beq.n	1bac2 <att_send_req+0x22>
		net_buf_unref(req->buf);
   1bafe:	6920      	ldr	r0, [r4, #16]
   1bb00:	f7fa fd0e 	bl	16520 <net_buf_unref>
		req->buf = NULL;
   1bb04:	6126      	str	r6, [r4, #16]
		return err;
   1bb06:	e7dc      	b.n	1bac2 <att_send_req+0x22>

0001bb08 <att_pdu_sent>:
{
   1bb08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   1bb0c:	2104      	movs	r1, #4
{
   1bb0e:	4680      	mov	r8, r0
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   1bb10:	f7ff fe38 	bl	1b784 <bt_l2cap_le_lookup_tx_cid>
   1bb14:	4606      	mov	r6, r0
	while ((buf = net_buf_get(&att->tx_queue, K_NO_WAIT))) {
   1bb16:	f100 07d8 	add.w	r7, r0, #216	; 0xd8
   1bb1a:	2100      	movs	r1, #0
   1bb1c:	4638      	mov	r0, r7
   1bb1e:	f002 f867 	bl	1dbf0 <net_buf_get>
   1bb22:	4604      	mov	r4, r0
   1bb24:	b928      	cbnz	r0, 1bb32 <att_pdu_sent+0x2a>
	z_impl_k_sem_give(sem);
   1bb26:	f106 00c0 	add.w	r0, r6, #192	; 0xc0
}
   1bb2a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1bb2e:	f7fc bca9 	b.w	18484 <z_impl_k_sem_give>
		if (att->req && att->req->buf == buf) {
   1bb32:	f8d6 5094 	ldr.w	r5, [r6, #148]	; 0x94
   1bb36:	b14d      	cbz	r5, 1bb4c <att_pdu_sent+0x44>
   1bb38:	692b      	ldr	r3, [r5, #16]
   1bb3a:	42a3      	cmp	r3, r4
   1bb3c:	d106      	bne.n	1bb4c <att_pdu_sent+0x44>
	state->offset = net_buf_simple_headroom(buf);
   1bb3e:	f104 0008 	add.w	r0, r4, #8
   1bb42:	f002 f8c4 	bl	1dcce <net_buf_simple_headroom>
	state->len = buf->len;
   1bb46:	89a3      	ldrh	r3, [r4, #12]
	state->offset = net_buf_simple_headroom(buf);
   1bb48:	81a8      	strh	r0, [r5, #12]
	state->len = buf->len;
   1bb4a:	81eb      	strh	r3, [r5, #14]
		if (!att_send(conn, buf, NULL, NULL)) {
   1bb4c:	2300      	movs	r3, #0
   1bb4e:	461a      	mov	r2, r3
   1bb50:	4621      	mov	r1, r4
   1bb52:	4640      	mov	r0, r8
   1bb54:	f7ed f842 	bl	8bdc <att_send>
   1bb58:	2800      	cmp	r0, #0
   1bb5a:	d1de      	bne.n	1bb1a <att_pdu_sent+0x12>
}
   1bb5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0001bb60 <att_cfm_sent>:
{
   1bb60:	b538      	push	{r3, r4, r5, lr}
   1bb62:	460d      	mov	r5, r1
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   1bb64:	2104      	movs	r1, #4
{
   1bb66:	4604      	mov	r4, r0
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   1bb68:	f7ff fe0c 	bl	1b784 <bt_l2cap_le_lookup_tx_cid>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1bb6c:	f3bf 8f5b 	dmb	ish
   1bb70:	3090      	adds	r0, #144	; 0x90
   1bb72:	e850 3f00 	ldrex	r3, [r0]
   1bb76:	f023 0302 	bic.w	r3, r3, #2
   1bb7a:	e840 3200 	strex	r2, r3, [r0]
   1bb7e:	2a00      	cmp	r2, #0
   1bb80:	d1f7      	bne.n	1bb72 <att_cfm_sent+0x12>
   1bb82:	f3bf 8f5b 	dmb	ish
	att_pdu_sent(conn, user_data);
   1bb86:	4629      	mov	r1, r5
   1bb88:	4620      	mov	r0, r4
}
   1bb8a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	att_pdu_sent(conn, user_data);
   1bb8e:	f7ff bfbb 	b.w	1bb08 <att_pdu_sent>

0001bb92 <att_rsp_sent>:
{
   1bb92:	b538      	push	{r3, r4, r5, lr}
   1bb94:	460d      	mov	r5, r1
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   1bb96:	2104      	movs	r1, #4
{
   1bb98:	4604      	mov	r4, r0
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   1bb9a:	f7ff fdf3 	bl	1b784 <bt_l2cap_le_lookup_tx_cid>
   1bb9e:	f3bf 8f5b 	dmb	ish
   1bba2:	3090      	adds	r0, #144	; 0x90
   1bba4:	e850 3f00 	ldrex	r3, [r0]
   1bba8:	f023 0301 	bic.w	r3, r3, #1
   1bbac:	e840 3200 	strex	r2, r3, [r0]
   1bbb0:	2a00      	cmp	r2, #0
   1bbb2:	d1f7      	bne.n	1bba4 <att_rsp_sent+0x12>
   1bbb4:	f3bf 8f5b 	dmb	ish
	att_pdu_sent(conn, user_data);
   1bbb8:	4629      	mov	r1, r5
   1bbba:	4620      	mov	r0, r4
}
   1bbbc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	att_pdu_sent(conn, user_data);
   1bbc0:	f7ff bfa2 	b.w	1bb08 <att_pdu_sent>

0001bbc4 <write_cb>:
{
   1bbc4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1bbc6:	460c      	mov	r4, r1
   1bbc8:	4606      	mov	r6, r0
	data->err = bt_gatt_check_perm(data->conn, attr,
   1bbca:	4601      	mov	r1, r0
   1bbcc:	222a      	movs	r2, #42	; 0x2a
   1bbce:	6820      	ldr	r0, [r4, #0]
   1bbd0:	f000 fc2b 	bl	1c42a <bt_gatt_check_perm>
   1bbd4:	4605      	mov	r5, r0
   1bbd6:	7520      	strb	r0, [r4, #20]
	if (data->err) {
   1bbd8:	bb00      	cbnz	r0, 1bc1c <write_cb+0x58>
	if (!data->req) {
   1bbda:	7a23      	ldrb	r3, [r4, #8]
	write = attr->write(data->conn, attr, data->value, data->len,
   1bbdc:	68b7      	ldr	r7, [r6, #8]
   1bbde:	68e2      	ldr	r2, [r4, #12]
   1bbe0:	6820      	ldr	r0, [r4, #0]
	if (!data->req) {
   1bbe2:	2b00      	cmp	r3, #0
		flags |= BT_GATT_WRITE_FLAG_CMD;
   1bbe4:	bf14      	ite	ne
   1bbe6:	2300      	movne	r3, #0
   1bbe8:	2302      	moveq	r3, #2
	write = attr->write(data->conn, attr, data->value, data->len,
   1bbea:	9301      	str	r3, [sp, #4]
   1bbec:	8a63      	ldrh	r3, [r4, #18]
   1bbee:	9300      	str	r3, [sp, #0]
   1bbf0:	4631      	mov	r1, r6
   1bbf2:	8a23      	ldrh	r3, [r4, #16]
   1bbf4:	47b8      	blx	r7
	if (write < 0 || write != data->len) {
   1bbf6:	2800      	cmp	r0, #0
   1bbf8:	db05      	blt.n	1bc06 <write_cb+0x42>
   1bbfa:	8a23      	ldrh	r3, [r4, #16]
   1bbfc:	4298      	cmp	r0, r3
   1bbfe:	d10b      	bne.n	1bc18 <write_cb+0x54>
	data->err = 0U;
   1bc00:	7525      	strb	r5, [r4, #20]
	return BT_GATT_ITER_CONTINUE;
   1bc02:	2501      	movs	r5, #1
   1bc04:	e005      	b.n	1bc12 <write_cb+0x4e>
	if (err < 0 && err >= -0xff) {
   1bc06:	f110 0fff 	cmn.w	r0, #255	; 0xff
   1bc0a:	d305      	bcc.n	1bc18 <write_cb+0x54>
		return -err;
   1bc0c:	4240      	negs	r0, r0
   1bc0e:	b2c0      	uxtb	r0, r0
		data->err = err_to_att(write);
   1bc10:	7520      	strb	r0, [r4, #20]
}
   1bc12:	4628      	mov	r0, r5
   1bc14:	b003      	add	sp, #12
   1bc16:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return BT_ATT_ERR_UNLIKELY;
   1bc18:	200e      	movs	r0, #14
   1bc1a:	e7f9      	b.n	1bc10 <write_cb+0x4c>
		return BT_GATT_ITER_STOP;
   1bc1c:	2500      	movs	r5, #0
   1bc1e:	e7f8      	b.n	1bc12 <write_cb+0x4e>

0001bc20 <read_cb>:
{
   1bc20:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   1bc24:	4606      	mov	r6, r0
	data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   1bc26:	6888      	ldr	r0, [r1, #8]
	struct bt_att *att = data->att;
   1bc28:	f8d1 9000 	ldr.w	r9, [r1]
{
   1bc2c:	460c      	mov	r4, r1
	data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   1bc2e:	3008      	adds	r0, #8
   1bc30:	2100      	movs	r1, #0
	struct bt_conn *conn = att->chan.chan.conn;
   1bc32:	f8d9 8000 	ldr.w	r8, [r9]
	data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   1bc36:	f002 f809 	bl	1dc4c <net_buf_simple_add>
	data->err = 0x00;
   1bc3a:	2700      	movs	r7, #0
	data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   1bc3c:	60e0      	str	r0, [r4, #12]
	data->err = 0x00;
   1bc3e:	7427      	strb	r7, [r4, #16]
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   1bc40:	2215      	movs	r2, #21
   1bc42:	4631      	mov	r1, r6
   1bc44:	4640      	mov	r0, r8
   1bc46:	f000 fbf0 	bl	1c42a <bt_gatt_check_perm>
   1bc4a:	4605      	mov	r5, r0
   1bc4c:	7420      	strb	r0, [r4, #16]
	if (data->err) {
   1bc4e:	bb00      	cbnz	r0, 1bc92 <read_cb+0x72>
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   1bc50:	68a1      	ldr	r1, [r4, #8]
   1bc52:	f8b9 3042 	ldrh.w	r3, [r9, #66]	; 0x42
   1bc56:	898a      	ldrh	r2, [r1, #12]
   1bc58:	6889      	ldr	r1, [r1, #8]
   1bc5a:	88a0      	ldrh	r0, [r4, #4]
   1bc5c:	9000      	str	r0, [sp, #0]
   1bc5e:	1a9b      	subs	r3, r3, r2
   1bc60:	6877      	ldr	r7, [r6, #4]
   1bc62:	440a      	add	r2, r1
   1bc64:	b29b      	uxth	r3, r3
   1bc66:	4631      	mov	r1, r6
   1bc68:	4640      	mov	r0, r8
   1bc6a:	47b8      	blx	r7
	if (read < 0) {
   1bc6c:	1e01      	subs	r1, r0, #0
   1bc6e:	da0a      	bge.n	1bc86 <read_cb+0x66>
	if (err < 0 && err >= -0xff) {
   1bc70:	f111 0fff 	cmn.w	r1, #255	; 0xff
		return -err;
   1bc74:	bf26      	itte	cs
   1bc76:	4249      	negcs	r1, r1
   1bc78:	b2c9      	uxtbcs	r1, r1
	return BT_ATT_ERR_UNLIKELY;
   1bc7a:	210e      	movcc	r1, #14
		data->err = err_to_att(read);
   1bc7c:	7421      	strb	r1, [r4, #16]
}
   1bc7e:	4628      	mov	r0, r5
   1bc80:	b003      	add	sp, #12
   1bc82:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	net_buf_add(data->buf, read);
   1bc86:	68a0      	ldr	r0, [r4, #8]
   1bc88:	3008      	adds	r0, #8
   1bc8a:	f001 ffdf 	bl	1dc4c <net_buf_simple_add>
	return BT_GATT_ITER_CONTINUE;
   1bc8e:	2501      	movs	r5, #1
   1bc90:	e7f5      	b.n	1bc7e <read_cb+0x5e>
		return BT_GATT_ITER_STOP;
   1bc92:	463d      	mov	r5, r7
   1bc94:	e7f3      	b.n	1bc7e <read_cb+0x5e>

0001bc96 <att_write_cmd>:
{
   1bc96:	b530      	push	{r4, r5, lr}
   1bc98:	460c      	mov	r4, r1
   1bc9a:	b085      	sub	sp, #20
	struct bt_conn *conn = att->chan.chan.conn;
   1bc9c:	6805      	ldr	r5, [r0, #0]
	handle = net_buf_pull_le16(buf);
   1bc9e:	f101 0008 	add.w	r0, r1, #8
   1bca2:	f002 f80c 	bl	1dcbe <net_buf_simple_pull_le16>
	return att_write_rsp(conn, 0, 0, handle, 0, buf->data, buf->len);
   1bca6:	89a3      	ldrh	r3, [r4, #12]
   1bca8:	9302      	str	r3, [sp, #8]
   1bcaa:	2200      	movs	r2, #0
   1bcac:	68a3      	ldr	r3, [r4, #8]
   1bcae:	9301      	str	r3, [sp, #4]
   1bcb0:	9200      	str	r2, [sp, #0]
   1bcb2:	4603      	mov	r3, r0
   1bcb4:	4611      	mov	r1, r2
   1bcb6:	4628      	mov	r0, r5
   1bcb8:	f7ed fa34 	bl	9124 <att_write_rsp>
}
   1bcbc:	b005      	add	sp, #20
   1bcbe:	bd30      	pop	{r4, r5, pc}

0001bcc0 <att_write_req>:
{
   1bcc0:	b530      	push	{r4, r5, lr}
   1bcc2:	460c      	mov	r4, r1
   1bcc4:	b085      	sub	sp, #20
	struct bt_conn *conn = att->chan.chan.conn;
   1bcc6:	6805      	ldr	r5, [r0, #0]
	handle = net_buf_pull_le16(buf);
   1bcc8:	f101 0008 	add.w	r0, r1, #8
   1bccc:	f001 fff7 	bl	1dcbe <net_buf_simple_pull_le16>
	return att_write_rsp(conn, BT_ATT_OP_WRITE_REQ, BT_ATT_OP_WRITE_RSP,
   1bcd0:	89a3      	ldrh	r3, [r4, #12]
   1bcd2:	9302      	str	r3, [sp, #8]
   1bcd4:	68a3      	ldr	r3, [r4, #8]
   1bcd6:	9301      	str	r3, [sp, #4]
   1bcd8:	2300      	movs	r3, #0
   1bcda:	9300      	str	r3, [sp, #0]
   1bcdc:	2213      	movs	r2, #19
   1bcde:	4603      	mov	r3, r0
   1bce0:	2112      	movs	r1, #18
   1bce2:	4628      	mov	r0, r5
   1bce4:	f7ed fa1e 	bl	9124 <att_write_rsp>
}
   1bce8:	b005      	add	sp, #20
   1bcea:	bd30      	pop	{r4, r5, pc}

0001bcec <att_read_blob_req>:
{
   1bcec:	b507      	push	{r0, r1, r2, lr}
	req = (void *)buf->data;
   1bcee:	688a      	ldr	r2, [r1, #8]
	return att_read_rsp(att, BT_ATT_OP_READ_BLOB_REQ,
   1bcf0:	8813      	ldrh	r3, [r2, #0]
   1bcf2:	8852      	ldrh	r2, [r2, #2]
   1bcf4:	9200      	str	r2, [sp, #0]
   1bcf6:	210c      	movs	r1, #12
   1bcf8:	220d      	movs	r2, #13
   1bcfa:	f7ed fc3d 	bl	9578 <att_read_rsp>
}
   1bcfe:	b003      	add	sp, #12
   1bd00:	f85d fb04 	ldr.w	pc, [sp], #4

0001bd04 <att_read_req>:
{
   1bd04:	b507      	push	{r0, r1, r2, lr}
	handle = sys_le16_to_cpu(req->handle);
   1bd06:	688b      	ldr	r3, [r1, #8]
	return att_read_rsp(att, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
   1bd08:	2200      	movs	r2, #0
   1bd0a:	881b      	ldrh	r3, [r3, #0]
   1bd0c:	9200      	str	r2, [sp, #0]
   1bd0e:	210a      	movs	r1, #10
   1bd10:	220b      	movs	r2, #11
   1bd12:	f7ed fc31 	bl	9578 <att_read_rsp>
}
   1bd16:	b003      	add	sp, #12
   1bd18:	f85d fb04 	ldr.w	pc, [sp], #4

0001bd1c <bt_att_init>:
	bt_gatt_init();
   1bd1c:	f7ee bd14 	b.w	a748 <bt_gatt_init>

0001bd20 <bt_att_get_mtu>:
{
   1bd20:	b508      	push	{r3, lr}
	att = att_chan_get(conn);
   1bd22:	f7ec fffb 	bl	8d1c <att_chan_get>
	if (!att) {
   1bd26:	b108      	cbz	r0, 1bd2c <bt_att_get_mtu+0xc>
	return att->chan.tx.mtu;
   1bd28:	f8b0 0042 	ldrh.w	r0, [r0, #66]	; 0x42
}
   1bd2c:	bd08      	pop	{r3, pc}

0001bd2e <att_req_destroy>:
{
   1bd2e:	b510      	push	{r4, lr}
   1bd30:	4604      	mov	r4, r0
	if (req->buf) {
   1bd32:	6900      	ldr	r0, [r0, #16]
   1bd34:	b108      	cbz	r0, 1bd3a <att_req_destroy+0xc>
		net_buf_unref(req->buf);
   1bd36:	f7fa fbf3 	bl	16520 <net_buf_unref>
	if (req->destroy) {
   1bd3a:	68a3      	ldr	r3, [r4, #8]
   1bd3c:	b10b      	cbz	r3, 1bd42 <att_req_destroy+0x14>
		req->destroy(req);
   1bd3e:	4620      	mov	r0, r4
   1bd40:	4798      	blx	r3
	bt_att_req_free(req);
   1bd42:	4620      	mov	r0, r4
}
   1bd44:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_att_req_free(req);
   1bd48:	f7ed bd90 	b.w	986c <bt_att_req_free>

0001bd4c <att_handle_find_info_rsp>:
	return att_handle_rsp(att, buf->data, buf->len, 0);
   1bd4c:	898a      	ldrh	r2, [r1, #12]
   1bd4e:	6889      	ldr	r1, [r1, #8]
   1bd50:	2300      	movs	r3, #0
   1bd52:	f7ed bd97 	b.w	9884 <att_handle_rsp>

0001bd56 <att_handle_find_type_rsp>:
   1bd56:	f7ff bff9 	b.w	1bd4c <att_handle_find_info_rsp>

0001bd5a <att_handle_read_type_rsp>:
   1bd5a:	f7ff bff7 	b.w	1bd4c <att_handle_find_info_rsp>

0001bd5e <att_handle_read_rsp>:
   1bd5e:	f7ff bff5 	b.w	1bd4c <att_handle_find_info_rsp>

0001bd62 <att_handle_read_blob_rsp>:
   1bd62:	f7ff bff3 	b.w	1bd4c <att_handle_find_info_rsp>

0001bd66 <att_handle_read_mult_rsp>:
   1bd66:	f7ff bff1 	b.w	1bd4c <att_handle_find_info_rsp>

0001bd6a <att_handle_read_group_rsp>:
   1bd6a:	f7ff bfef 	b.w	1bd4c <att_handle_find_info_rsp>

0001bd6e <att_handle_write_rsp>:
   1bd6e:	f7ff bfed 	b.w	1bd4c <att_handle_find_info_rsp>

0001bd72 <att_handle_prepare_write_rsp>:
   1bd72:	f7ff bfeb 	b.w	1bd4c <att_handle_find_info_rsp>

0001bd76 <att_handle_exec_write_rsp>:
   1bd76:	f7ff bfe9 	b.w	1bd4c <att_handle_find_info_rsp>

0001bd7a <att_confirm>:
   1bd7a:	f7ff bfe7 	b.w	1bd4c <att_handle_find_info_rsp>

0001bd7e <att_mtu_rsp>:
{
   1bd7e:	b410      	push	{r4}
   1bd80:	460a      	mov	r2, r1
	if (!att) {
   1bd82:	b190      	cbz	r0, 1bdaa <att_mtu_rsp+0x2c>
	rsp = (void *)buf->data;
   1bd84:	6889      	ldr	r1, [r1, #8]
	mtu = sys_le16_to_cpu(rsp->mtu);
   1bd86:	880b      	ldrh	r3, [r1, #0]
	if (mtu < BT_ATT_DEFAULT_LE_MTU) {
   1bd88:	2b16      	cmp	r3, #22
   1bd8a:	d805      	bhi.n	1bd98 <att_mtu_rsp+0x1a>
		return att_handle_rsp(att, NULL, 0, BT_ATT_ERR_INVALID_PDU);
   1bd8c:	2200      	movs	r2, #0
   1bd8e:	2304      	movs	r3, #4
   1bd90:	4611      	mov	r1, r2
}
   1bd92:	bc10      	pop	{r4}
	return att_handle_rsp(att, rsp, buf->len, 0);
   1bd94:	f7ed bd76 	b.w	9884 <att_handle_rsp>
	att->chan.rx.mtu = MIN(mtu, BT_ATT_MTU);
   1bd98:	2b41      	cmp	r3, #65	; 0x41
   1bd9a:	bf28      	it	cs
   1bd9c:	2341      	movcs	r3, #65	; 0x41
   1bd9e:	86c3      	strh	r3, [r0, #54]	; 0x36
	att->chan.tx.mtu = att->chan.rx.mtu;
   1bda0:	f8a0 3042 	strh.w	r3, [r0, #66]	; 0x42
	return att_handle_rsp(att, rsp, buf->len, 0);
   1bda4:	8992      	ldrh	r2, [r2, #12]
   1bda6:	2300      	movs	r3, #0
   1bda8:	e7f3      	b.n	1bd92 <att_mtu_rsp+0x14>
}
   1bdaa:	bc10      	pop	{r4}
   1bdac:	4770      	bx	lr

0001bdae <att_reset>:
{
   1bdae:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1bdb0:	4604      	mov	r4, r0
	while ((buf = k_fifo_get(&att->prep_queue, K_NO_WAIT))) {
   1bdb2:	f100 05e8 	add.w	r5, r0, #232	; 0xe8
	return z_impl_k_queue_get(queue, timeout);
   1bdb6:	2100      	movs	r1, #0
   1bdb8:	4628      	mov	r0, r5
   1bdba:	f002 faf0 	bl	1e39e <z_impl_k_queue_get>
   1bdbe:	bb50      	cbnz	r0, 1be16 <att_reset+0x68>
	while ((buf = k_fifo_get(&att->tx_queue, K_NO_WAIT))) {
   1bdc0:	f104 05d8 	add.w	r5, r4, #216	; 0xd8
   1bdc4:	2100      	movs	r1, #0
   1bdc6:	4628      	mov	r0, r5
   1bdc8:	f002 fae9 	bl	1e39e <z_impl_k_queue_get>
   1bdcc:	bb30      	cbnz	r0, 1be1c <att_reset+0x6e>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1bdce:	f3bf 8f5b 	dmb	ish
   1bdd2:	f104 0390 	add.w	r3, r4, #144	; 0x90
   1bdd6:	e853 2f00 	ldrex	r2, [r3]
   1bdda:	f042 0204 	orr.w	r2, r2, #4
   1bdde:	e843 2100 	strex	r1, r2, [r3]
   1bde2:	2900      	cmp	r1, #0
   1bde4:	d1f7      	bne.n	1bdd6 <att_reset+0x28>
   1bde6:	f3bf 8f5b 	dmb	ish
		k_sem_give(&att->tx_sem);
   1bdea:	f104 05c0 	add.w	r5, r4, #192	; 0xc0
	z_impl_k_sem_give(sem);
   1bdee:	4628      	mov	r0, r5
   1bdf0:	f7fc fb48 	bl	18484 <z_impl_k_sem_give>
   1bdf4:	4628      	mov	r0, r5
   1bdf6:	f7fc fb45 	bl	18484 <z_impl_k_sem_give>
   1bdfa:	4628      	mov	r0, r5
   1bdfc:	f7fc fb42 	bl	18484 <z_impl_k_sem_give>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->reqs, req, tmp, node) {
   1be00:	f8d4 5098 	ldr.w	r5, [r4, #152]	; 0x98
   1be04:	b96d      	cbnz	r5, 1be22 <att_reset+0x74>
	if (!att->req) {
   1be06:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
	list->head = NULL;
   1be0a:	2200      	movs	r2, #0
	list->tail = NULL;
   1be0c:	e9c4 2226 	strd	r2, r2, [r4, #152]	; 0x98
   1be10:	b9c3      	cbnz	r3, 1be44 <att_reset+0x96>
}
   1be12:	b003      	add	sp, #12
   1be14:	bdf0      	pop	{r4, r5, r6, r7, pc}
		net_buf_unref(buf);
   1be16:	f7fa fb83 	bl	16520 <net_buf_unref>
   1be1a:	e7cc      	b.n	1bdb6 <att_reset+0x8>
		net_buf_unref(buf);
   1be1c:	f7fa fb80 	bl	16520 <net_buf_unref>
   1be20:	e7d0      	b.n	1bdc4 <att_reset+0x16>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1be22:	682e      	ldr	r6, [r5, #0]
		if (req->func) {
   1be24:	686f      	ldr	r7, [r5, #4]
   1be26:	b12f      	cbz	r7, 1be34 <att_reset+0x86>
			req->func(NULL, BT_ATT_ERR_UNLIKELY, NULL, 0, req);
   1be28:	2300      	movs	r3, #0
   1be2a:	9500      	str	r5, [sp, #0]
   1be2c:	461a      	mov	r2, r3
   1be2e:	210e      	movs	r1, #14
   1be30:	4618      	mov	r0, r3
   1be32:	47b8      	blx	r7
		att_req_destroy(req);
   1be34:	4628      	mov	r0, r5
   1be36:	f7ff ff7a 	bl	1bd2e <att_req_destroy>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->reqs, req, tmp, node) {
   1be3a:	2e00      	cmp	r6, #0
   1be3c:	d0e3      	beq.n	1be06 <att_reset+0x58>
   1be3e:	4635      	mov	r5, r6
   1be40:	6836      	ldr	r6, [r6, #0]
   1be42:	e7ef      	b.n	1be24 <att_reset+0x76>
	att_handle_rsp(att, NULL, 0, BT_ATT_ERR_UNLIKELY);
   1be44:	230e      	movs	r3, #14
   1be46:	4611      	mov	r1, r2
   1be48:	4620      	mov	r0, r4
}
   1be4a:	b003      	add	sp, #12
   1be4c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	att_handle_rsp(att, NULL, 0, BT_ATT_ERR_UNLIKELY);
   1be50:	f7ed bd18 	b.w	9884 <att_handle_rsp>

0001be54 <bt_att_send>:
{
   1be54:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1be58:	4607      	mov	r7, r0
   1be5a:	460d      	mov	r5, r1
   1be5c:	4614      	mov	r4, r2
   1be5e:	4698      	mov	r8, r3
	att = att_chan_get(conn);
   1be60:	f7ec ff5c 	bl	8d1c <att_chan_get>
	if (!att) {
   1be64:	4606      	mov	r6, r0
   1be66:	b938      	cbnz	r0, 1be78 <bt_att_send+0x24>
		net_buf_unref(buf);
   1be68:	4628      	mov	r0, r5
   1be6a:	f7fa fb59 	bl	16520 <net_buf_unref>
		return -ENOTCONN;
   1be6e:	f06f 0538 	mvn.w	r5, #56	; 0x38
}
   1be72:	4628      	mov	r0, r5
   1be74:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!cb) {
   1be78:	b964      	cbnz	r4, 1be94 <bt_att_send+0x40>
	return z_impl_k_sem_take(sem, timeout);
   1be7a:	4621      	mov	r1, r4
   1be7c:	30c0      	adds	r0, #192	; 0xc0
   1be7e:	f7fc fb2d 	bl	184dc <z_impl_k_sem_take>
		if (k_sem_take(&att->tx_sem, K_NO_WAIT) < 0) {
   1be82:	2800      	cmp	r0, #0
   1be84:	da06      	bge.n	1be94 <bt_att_send+0x40>
			k_fifo_put(&att->tx_queue, buf);
   1be86:	4629      	mov	r1, r5
   1be88:	f106 00d8 	add.w	r0, r6, #216	; 0xd8
   1be8c:	f002 fa5e 	bl	1e34c <k_queue_append>
			return 0;
   1be90:	4625      	mov	r5, r4
   1be92:	e7ee      	b.n	1be72 <bt_att_send+0x1e>
	err = att_send(conn, buf, cb, user_data);
   1be94:	4629      	mov	r1, r5
   1be96:	4643      	mov	r3, r8
   1be98:	4622      	mov	r2, r4
   1be9a:	4638      	mov	r0, r7
   1be9c:	f7ec fe9e 	bl	8bdc <att_send>
	if (err) {
   1bea0:	4605      	mov	r5, r0
   1bea2:	2800      	cmp	r0, #0
   1bea4:	d0e5      	beq.n	1be72 <bt_att_send+0x1e>
		if (!cb) {
   1bea6:	2c00      	cmp	r4, #0
   1bea8:	d1e3      	bne.n	1be72 <bt_att_send+0x1e>
	z_impl_k_sem_give(sem);
   1beaa:	f106 00c0 	add.w	r0, r6, #192	; 0xc0
   1beae:	f7fc fae9 	bl	18484 <z_impl_k_sem_give>
   1beb2:	e7de      	b.n	1be72 <bt_att_send+0x1e>

0001beb4 <bt_att_req_send>:
{
   1beb4:	b538      	push	{r3, r4, r5, lr}
   1beb6:	460c      	mov	r4, r1
	att = att_chan_get(conn);
   1beb8:	f7ec ff30 	bl	8d1c <att_chan_get>
	if (!att) {
   1bebc:	4605      	mov	r5, r0
   1bebe:	b930      	cbnz	r0, 1bece <bt_att_req_send+0x1a>
		net_buf_unref(req->buf);
   1bec0:	6920      	ldr	r0, [r4, #16]
   1bec2:	f7fa fb2d 	bl	16520 <net_buf_unref>
		req->buf = NULL;
   1bec6:	6125      	str	r5, [r4, #16]
		return -ENOTCONN;
   1bec8:	f06f 0038 	mvn.w	r0, #56	; 0x38
}
   1becc:	bd38      	pop	{r3, r4, r5, pc}
	if (att->req) {
   1bece:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
   1bed2:	b163      	cbz	r3, 1beee <bt_att_req_send+0x3a>
	parent->next = child;
   1bed4:	2000      	movs	r0, #0
   1bed6:	6020      	str	r0, [r4, #0]
Z_GENLIST_APPEND(slist, snode)
   1bed8:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
   1bedc:	b91b      	cbnz	r3, 1bee6 <bt_att_req_send+0x32>
	list->head = node;
   1bede:	e9c5 4426 	strd	r4, r4, [r5, #152]	; 0x98
		return 0;
   1bee2:	4618      	mov	r0, r3
   1bee4:	e7f2      	b.n	1becc <bt_att_req_send+0x18>
	parent->next = child;
   1bee6:	601c      	str	r4, [r3, #0]
	list->tail = node;
   1bee8:	f8c5 409c 	str.w	r4, [r5, #156]	; 0x9c
   1beec:	e7ee      	b.n	1becc <bt_att_req_send+0x18>
	return att_send_req(att, req);
   1beee:	4621      	mov	r1, r4
}
   1bef0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return att_send_req(att, req);
   1bef4:	f7ff bdd4 	b.w	1baa0 <att_send_req>

0001bef8 <gatt_ccc_changed>:
{
   1bef8:	460b      	mov	r3, r1
		if (ccc->cfg[i].value > value) {
   1befa:	8909      	ldrh	r1, [r1, #8]
	if (value != ccc->value) {
   1befc:	895a      	ldrh	r2, [r3, #10]
   1befe:	428a      	cmp	r2, r1
   1bf00:	d003      	beq.n	1bf0a <gatt_ccc_changed+0x12>
		ccc->value = value;
   1bf02:	8159      	strh	r1, [r3, #10]
		if (ccc->cfg_changed) {
   1bf04:	68db      	ldr	r3, [r3, #12]
   1bf06:	b103      	cbz	r3, 1bf0a <gatt_ccc_changed+0x12>
			ccc->cfg_changed(attr, value);
   1bf08:	4718      	bx	r3
}
   1bf0a:	4770      	bx	lr

0001bf0c <gatt_indicate_rsp>:
{
   1bf0c:	b410      	push	{r4}
   1bf0e:	9b01      	ldr	r3, [sp, #4]
	params->func(conn, params->attr, err);
   1bf10:	689c      	ldr	r4, [r3, #8]
   1bf12:	460a      	mov	r2, r1
   1bf14:	6859      	ldr	r1, [r3, #4]
   1bf16:	4623      	mov	r3, r4
}
   1bf18:	bc10      	pop	{r4}
	params->func(conn, params->attr, err);
   1bf1a:	4718      	bx	r3

0001bf1c <bt_addr_le_copy>:
	memcpy(dst, src, sizeof(*dst));
   1bf1c:	2207      	movs	r2, #7
   1bf1e:	f7ff b86c 	b.w	1affa <memcpy>

0001bf22 <clear_ccc_cfg>:
{
   1bf22:	b537      	push	{r0, r1, r2, r4, r5, lr}
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   1bf24:	2400      	movs	r4, #0
{
   1bf26:	4605      	mov	r5, r0
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   1bf28:	4669      	mov	r1, sp
   1bf2a:	3001      	adds	r0, #1
   1bf2c:	9400      	str	r4, [sp, #0]
   1bf2e:	f8cd 4003 	str.w	r4, [sp, #3]
   1bf32:	f7ff fff3 	bl	1bf1c <bt_addr_le_copy>
	cfg->id = 0U;
   1bf36:	702c      	strb	r4, [r5, #0]
	cfg->value = 0U;
   1bf38:	812c      	strh	r4, [r5, #8]
}
   1bf3a:	b003      	add	sp, #12
   1bf3c:	bd30      	pop	{r4, r5, pc}

0001bf3e <write_name>:
{
   1bf3e:	b570      	push	{r4, r5, r6, lr}
   1bf40:	b092      	sub	sp, #72	; 0x48
   1bf42:	4615      	mov	r5, r2
   1bf44:	f8bd 6058 	ldrh.w	r6, [sp, #88]	; 0x58
	char value[CONFIG_BT_DEVICE_NAME_MAX] = {};
   1bf48:	2241      	movs	r2, #65	; 0x41
   1bf4a:	2100      	movs	r1, #0
   1bf4c:	a801      	add	r0, sp, #4
{
   1bf4e:	461c      	mov	r4, r3
	char value[CONFIG_BT_DEVICE_NAME_MAX] = {};
   1bf50:	f7ff f87d 	bl	1b04e <memset>
	if (offset) {
   1bf54:	b966      	cbnz	r6, 1bf70 <write_name+0x32>
	if (len >= sizeof(value)) {
   1bf56:	2c40      	cmp	r4, #64	; 0x40
   1bf58:	d80d      	bhi.n	1bf76 <write_name+0x38>
	memcpy(value, buf, len);
   1bf5a:	4622      	mov	r2, r4
   1bf5c:	4629      	mov	r1, r5
   1bf5e:	a801      	add	r0, sp, #4
   1bf60:	f7ff f84b 	bl	1affa <memcpy>
	bt_set_name(value);
   1bf64:	a801      	add	r0, sp, #4
   1bf66:	f7eb f811 	bl	6f8c <bt_set_name>
	return len;
   1bf6a:	4620      	mov	r0, r4
}
   1bf6c:	b012      	add	sp, #72	; 0x48
   1bf6e:	bd70      	pop	{r4, r5, r6, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1bf70:	f06f 0006 	mvn.w	r0, #6
   1bf74:	e7fa      	b.n	1bf6c <write_name+0x2e>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
   1bf76:	f06f 000c 	mvn.w	r0, #12
   1bf7a:	e7f7      	b.n	1bf6c <write_name+0x2e>

0001bf7c <gen_hash_m>:
{
   1bf7c:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (attr->uuid->type != BT_UUID_TYPE_16)
   1bf7e:	6807      	ldr	r7, [r0, #0]
   1bf80:	783d      	ldrb	r5, [r7, #0]
{
   1bf82:	b089      	sub	sp, #36	; 0x24
   1bf84:	4606      	mov	r6, r0
   1bf86:	460c      	mov	r4, r1
	if (attr->uuid->type != BT_UUID_TYPE_16)
   1bf88:	b10d      	cbz	r5, 1bf8e <gen_hash_m+0x12>
		return BT_GATT_ITER_CONTINUE;
   1bf8a:	2501      	movs	r5, #1
   1bf8c:	e015      	b.n	1bfba <gen_hash_m+0x3e>
	switch (u16->val) {
   1bf8e:	887b      	ldrh	r3, [r7, #2]
   1bf90:	f5b3 5f24 	cmp.w	r3, #10496	; 0x2900
   1bf94:	d004      	beq.n	1bfa0 <gen_hash_m+0x24>
   1bf96:	d813      	bhi.n	1bfc0 <gen_hash_m+0x44>
   1bf98:	f5a3 5320 	sub.w	r3, r3, #10240	; 0x2800
   1bf9c:	2b03      	cmp	r3, #3
   1bf9e:	d8f4      	bhi.n	1bf8a <gen_hash_m+0xe>
		value = sys_cpu_to_le16(attr->handle);
   1bfa0:	8a33      	ldrh	r3, [r6, #16]
   1bfa2:	f8ad 300e 	strh.w	r3, [sp, #14]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   1bfa6:	2202      	movs	r2, #2
   1bfa8:	f10d 010e 	add.w	r1, sp, #14
   1bfac:	4620      	mov	r0, r4
   1bfae:	f7fe fa4d 	bl	1a44c <tc_cmac_update>
   1bfb2:	b9d8      	cbnz	r0, 1bfec <gen_hash_m+0x70>
			state->err = -EINVAL;
   1bfb4:	f06f 0315 	mvn.w	r3, #21
   1bfb8:	65a3      	str	r3, [r4, #88]	; 0x58
}
   1bfba:	4628      	mov	r0, r5
   1bfbc:	b009      	add	sp, #36	; 0x24
   1bfbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (u16->val) {
   1bfc0:	f642 1205 	movw	r2, #10501	; 0x2905
   1bfc4:	4293      	cmp	r3, r2
   1bfc6:	d8e0      	bhi.n	1bf8a <gen_hash_m+0xe>
		value = sys_cpu_to_le16(attr->handle);
   1bfc8:	8a03      	ldrh	r3, [r0, #16]
   1bfca:	f8ad 300e 	strh.w	r3, [sp, #14]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   1bfce:	2202      	movs	r2, #2
   1bfd0:	f10d 010e 	add.w	r1, sp, #14
   1bfd4:	4620      	mov	r0, r4
   1bfd6:	f7fe fa39 	bl	1a44c <tc_cmac_update>
   1bfda:	2800      	cmp	r0, #0
   1bfdc:	d0ea      	beq.n	1bfb4 <gen_hash_m+0x38>
		value = sys_cpu_to_le16(u16->val);
   1bfde:	887b      	ldrh	r3, [r7, #2]
   1bfe0:	f8ad 300e 	strh.w	r3, [sp, #14]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   1bfe4:	2202      	movs	r2, #2
   1bfe6:	f10d 010e 	add.w	r1, sp, #14
   1bfea:	e017      	b.n	1c01c <gen_hash_m+0xa0>
		value = sys_cpu_to_le16(u16->val);
   1bfec:	887b      	ldrh	r3, [r7, #2]
   1bfee:	f8ad 300e 	strh.w	r3, [sp, #14]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   1bff2:	2202      	movs	r2, #2
   1bff4:	f10d 010e 	add.w	r1, sp, #14
   1bff8:	4620      	mov	r0, r4
   1bffa:	f7fe fa27 	bl	1a44c <tc_cmac_update>
   1bffe:	2800      	cmp	r0, #0
   1c000:	d0d8      	beq.n	1bfb4 <gen_hash_m+0x38>
		len = attr->read(NULL, attr, data, sizeof(data), 0);
   1c002:	2000      	movs	r0, #0
   1c004:	2310      	movs	r3, #16
   1c006:	eb0d 0203 	add.w	r2, sp, r3
   1c00a:	9000      	str	r0, [sp, #0]
   1c00c:	6877      	ldr	r7, [r6, #4]
   1c00e:	4631      	mov	r1, r6
   1c010:	47b8      	blx	r7
		if (len < 0) {
   1c012:	1e02      	subs	r2, r0, #0
   1c014:	da01      	bge.n	1c01a <gen_hash_m+0x9e>
			state->err = len;
   1c016:	65a2      	str	r2, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   1c018:	e7cf      	b.n	1bfba <gen_hash_m+0x3e>
		if (tc_cmac_update(&state->state, data, len) ==
   1c01a:	a904      	add	r1, sp, #16
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   1c01c:	4620      	mov	r0, r4
   1c01e:	f7fe fa15 	bl	1a44c <tc_cmac_update>
   1c022:	2800      	cmp	r0, #0
   1c024:	d1b1      	bne.n	1bf8a <gen_hash_m+0xe>
   1c026:	e7c5      	b.n	1bfb4 <gen_hash_m+0x38>

0001c028 <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1c028:	f3bf 8f5b 	dmb	ish
   1c02c:	6800      	ldr	r0, [r0, #0]
   1c02e:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   1c032:	4108      	asrs	r0, r1
}
   1c034:	f000 0001 	and.w	r0, r0, #1
   1c038:	4770      	bx	lr

0001c03a <atomic_and>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1c03a:	f3bf 8f5b 	dmb	ish
   1c03e:	e850 3f00 	ldrex	r3, [r0]
   1c042:	ea03 0201 	and.w	r2, r3, r1
   1c046:	e840 2c00 	strex	ip, r2, [r0]
   1c04a:	f1bc 0f00 	cmp.w	ip, #0
   1c04e:	d1f6      	bne.n	1c03e <atomic_and+0x4>
   1c050:	f3bf 8f5b 	dmb	ish
}
   1c054:	4618      	mov	r0, r3
   1c056:	4770      	bx	lr

0001c058 <gatt_read_multiple_rsp>:
{
   1c058:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1c05a:	9c08      	ldr	r4, [sp, #32]
   1c05c:	4606      	mov	r6, r0
   1c05e:	6827      	ldr	r7, [r4, #0]
	if (err || !length) {
   1c060:	460d      	mov	r5, r1
   1c062:	b901      	cbnz	r1, 1c066 <gatt_read_multiple_rsp+0xe>
   1c064:	b94b      	cbnz	r3, 1c07a <gatt_read_multiple_rsp+0x22>
		params->func(conn, err, params, NULL, 0);
   1c066:	2300      	movs	r3, #0
   1c068:	9308      	str	r3, [sp, #32]
   1c06a:	4622      	mov	r2, r4
   1c06c:	4629      	mov	r1, r5
	params->func(conn, 0, params, NULL, 0);
   1c06e:	4630      	mov	r0, r6
   1c070:	46bc      	mov	ip, r7
}
   1c072:	b003      	add	sp, #12
   1c074:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	params->func(conn, 0, params, NULL, 0);
   1c078:	4760      	bx	ip
	params->func(conn, 0, params, pdu, length);
   1c07a:	9300      	str	r3, [sp, #0]
   1c07c:	4613      	mov	r3, r2
   1c07e:	4622      	mov	r2, r4
   1c080:	47b8      	blx	r7
	params->func(conn, 0, params, NULL, 0);
   1c082:	9508      	str	r5, [sp, #32]
   1c084:	6827      	ldr	r7, [r4, #0]
   1c086:	462b      	mov	r3, r5
   1c088:	4622      	mov	r2, r4
   1c08a:	4629      	mov	r1, r5
   1c08c:	e7ef      	b.n	1c06e <gatt_read_multiple_rsp+0x16>

0001c08e <gatt_sub_remove.part.9>:
static void gatt_sub_remove(struct bt_conn *conn, struct gatt_sub *sub,
   1c08e:	b507      	push	{r0, r1, r2, lr}
		bt_addr_le_copy(&sub->peer, BT_ADDR_LE_ANY);
   1c090:	2300      	movs	r3, #0
   1c092:	4669      	mov	r1, sp
   1c094:	9300      	str	r3, [sp, #0]
   1c096:	f8cd 3003 	str.w	r3, [sp, #3]
   1c09a:	f7ff ff3f 	bl	1bf1c <bt_addr_le_copy>
}
   1c09e:	b003      	add	sp, #12
   1c0a0:	f85d fb04 	ldr.w	pc, [sp], #4

0001c0a4 <clear_cf_cfg>:
{
   1c0a4:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1c0a6:	4604      	mov	r4, r0
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   1c0a8:	2500      	movs	r5, #0
   1c0aa:	4669      	mov	r1, sp
   1c0ac:	3001      	adds	r0, #1
   1c0ae:	9500      	str	r5, [sp, #0]
   1c0b0:	f8cd 5003 	str.w	r5, [sp, #3]
   1c0b4:	f7ff ff32 	bl	1bf1c <bt_addr_le_copy>
	memset(cfg->data, 0, sizeof(cfg->data));
   1c0b8:	f104 0008 	add.w	r0, r4, #8
   1c0bc:	2201      	movs	r2, #1
   1c0be:	4629      	mov	r1, r5
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   1c0c0:	340c      	adds	r4, #12
   1c0c2:	f7fe ffc4 	bl	1b04e <memset>
   1c0c6:	f3bf 8f5b 	dmb	ish
   1c0ca:	e854 3f00 	ldrex	r3, [r4]
   1c0ce:	e844 5200 	strex	r2, r5, [r4]
   1c0d2:	2a00      	cmp	r2, #0
   1c0d4:	d1f9      	bne.n	1c0ca <clear_cf_cfg+0x26>
   1c0d6:	f3bf 8f5b 	dmb	ish
}
   1c0da:	b003      	add	sp, #12
   1c0dc:	bd30      	pop	{r4, r5, pc}

0001c0de <match_uuid>:
   1c0de:	6008      	str	r0, [r1, #0]
   1c0e0:	2000      	movs	r0, #0
   1c0e2:	4770      	bx	lr

0001c0e4 <ccc_find_cfg>:
{
   1c0e4:	b510      	push	{r4, lr}
		if (id == ccc->cfg[i].id &&
   1c0e6:	7803      	ldrb	r3, [r0, #0]
   1c0e8:	4293      	cmp	r3, r2
{
   1c0ea:	4604      	mov	r4, r0
		if (id == ccc->cfg[i].id &&
   1c0ec:	d001      	beq.n	1c0f2 <ccc_find_cfg+0xe>
	return NULL;
   1c0ee:	2000      	movs	r0, #0
}
   1c0f0:	bd10      	pop	{r4, pc}
	return memcmp(a, b, sizeof(*a));
   1c0f2:	2207      	movs	r2, #7
   1c0f4:	3001      	adds	r0, #1
   1c0f6:	f7fe ff70 	bl	1afda <memcmp>
		if (id == ccc->cfg[i].id &&
   1c0fa:	2800      	cmp	r0, #0
   1c0fc:	d1f7      	bne.n	1c0ee <ccc_find_cfg+0xa>
			return &ccc->cfg[i];
   1c0fe:	4620      	mov	r0, r4
   1c100:	e7f6      	b.n	1c0f0 <ccc_find_cfg+0xc>

0001c102 <find_ccc_cfg>:
{
   1c102:	b513      	push	{r0, r1, r4, lr}
   1c104:	460c      	mov	r4, r1
		if (conn) {
   1c106:	b168      	cbz	r0, 1c124 <find_ccc_cfg+0x22>
			if (conn->id == ccc->cfg[i].id &&
   1c108:	7a02      	ldrb	r2, [r0, #8]
   1c10a:	780b      	ldrb	r3, [r1, #0]
   1c10c:	429a      	cmp	r2, r3
   1c10e:	d002      	beq.n	1c116 <find_ccc_cfg+0x14>
	return NULL;
   1c110:	2000      	movs	r0, #0
}
   1c112:	b002      	add	sp, #8
   1c114:	bd10      	pop	{r4, pc}
			    !bt_conn_addr_le_cmp(conn, &ccc->cfg[i].peer)) {
   1c116:	3101      	adds	r1, #1
   1c118:	f7ff fa39 	bl	1b58e <bt_conn_addr_le_cmp>
			if (conn->id == ccc->cfg[i].id &&
   1c11c:	2800      	cmp	r0, #0
   1c11e:	d1f7      	bne.n	1c110 <find_ccc_cfg+0xe>
				return &ccc->cfg[i];
   1c120:	4620      	mov	r0, r4
   1c122:	e7f6      	b.n	1c112 <find_ccc_cfg+0x10>
		} else if (!bt_addr_le_cmp(&ccc->cfg[i].peer, BT_ADDR_LE_ANY)) {
   1c124:	9000      	str	r0, [sp, #0]
   1c126:	2207      	movs	r2, #7
   1c128:	f8cd 0003 	str.w	r0, [sp, #3]
   1c12c:	4669      	mov	r1, sp
   1c12e:	1c60      	adds	r0, r4, #1
   1c130:	f7fe ff53 	bl	1afda <memcmp>
   1c134:	e7f2      	b.n	1c11c <find_ccc_cfg+0x1a>

0001c136 <atomic_set_bit>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   1c136:	2301      	movs	r3, #1
   1c138:	fa03 f101 	lsl.w	r1, r3, r1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1c13c:	f3bf 8f5b 	dmb	ish
   1c140:	e850 3f00 	ldrex	r3, [r0]
   1c144:	430b      	orrs	r3, r1
   1c146:	e840 3200 	strex	r2, r3, [r0]
   1c14a:	2a00      	cmp	r2, #0
   1c14c:	d1f8      	bne.n	1c140 <atomic_set_bit+0xa>
   1c14e:	f3bf 8f5b 	dmb	ish
}
   1c152:	4770      	bx	lr

0001c154 <sc_ccc_cfg_write>:
{
   1c154:	b508      	push	{r3, lr}
   1c156:	4601      	mov	r1, r0
	if (value == BT_GATT_CCC_INDICATE) {
   1c158:	2a02      	cmp	r2, #2
   1c15a:	7a00      	ldrb	r0, [r0, #8]
   1c15c:	f101 0170 	add.w	r1, r1, #112	; 0x70
   1c160:	d105      	bne.n	1c16e <sc_ccc_cfg_write+0x1a>
		sc_save(conn->id, &conn->le.dst, 0, 0);
   1c162:	2300      	movs	r3, #0
   1c164:	461a      	mov	r2, r3
   1c166:	f7ee f86b 	bl	a240 <sc_save>
}
   1c16a:	2002      	movs	r0, #2
   1c16c:	bd08      	pop	{r3, pc}
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
   1c16e:	f7ee f845 	bl	a1fc <find_sc_cfg.part.11>
		if (cfg) {
   1c172:	2800      	cmp	r0, #0
   1c174:	d0f9      	beq.n	1c16a <sc_ccc_cfg_write+0x16>
			sc_clear(cfg);
   1c176:	f7ed fd85 	bl	9c84 <sc_clear>
   1c17a:	e7f6      	b.n	1c16a <sc_ccc_cfg_write+0x16>

0001c17c <sc_restore_rsp>:
{
   1c17c:	b508      	push	{r3, lr}
   1c17e:	f7ee f9a9 	bl	a4d4 <find_cf_cfg.part.10>
	if (cfg && CF_ROBUST_CACHING(cfg)) {
   1c182:	b140      	cbz	r0, 1c196 <sc_restore_rsp+0x1a>
   1c184:	7a03      	ldrb	r3, [r0, #8]
   1c186:	07db      	lsls	r3, r3, #31
   1c188:	d505      	bpl.n	1c196 <sc_restore_rsp+0x1a>
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   1c18a:	2100      	movs	r1, #0
   1c18c:	300c      	adds	r0, #12
}
   1c18e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   1c192:	f7ff bfd0 	b.w	1c136 <atomic_set_bit>
}
   1c196:	bd08      	pop	{r3, pc}

0001c198 <read_appearance>:
{
   1c198:	b513      	push	{r0, r1, r4, lr}
   1c19a:	f8bd 1010 	ldrh.w	r1, [sp, #16]
   1c19e:	4610      	mov	r0, r2
	if (offset > value_len) {
   1c1a0:	2902      	cmp	r1, #2
	u16_t appearance = sys_cpu_to_le16(gap_appearance);
   1c1a2:	f240 3241 	movw	r2, #833	; 0x341
   1c1a6:	f8ad 2006 	strh.w	r2, [sp, #6]
	if (offset > value_len) {
   1c1aa:	d80d      	bhi.n	1c1c8 <read_appearance+0x30>
	len = MIN(buf_len, value_len - offset);
   1c1ac:	f1c1 0402 	rsb	r4, r1, #2
   1c1b0:	429c      	cmp	r4, r3
   1c1b2:	bfa8      	it	ge
   1c1b4:	461c      	movge	r4, r3
	memcpy(buf, (u8_t *)value + offset, len);
   1c1b6:	f10d 0306 	add.w	r3, sp, #6
   1c1ba:	4622      	mov	r2, r4
   1c1bc:	4419      	add	r1, r3
   1c1be:	f7fe ff1c 	bl	1affa <memcpy>
}
   1c1c2:	4620      	mov	r0, r4
   1c1c4:	b002      	add	sp, #8
   1c1c6:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1c1c8:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &appearance,
   1c1cc:	e7f9      	b.n	1c1c2 <read_appearance+0x2a>

0001c1ce <read_name>:
{
   1c1ce:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c1d2:	4698      	mov	r8, r3
   1c1d4:	4616      	mov	r6, r2
   1c1d6:	f8bd 5018 	ldrh.w	r5, [sp, #24]
	const char *name = bt_get_name();
   1c1da:	f7ea ff29 	bl	7030 <bt_get_name>
   1c1de:	4607      	mov	r7, r0
				 strlen(name));
   1c1e0:	f7fe fed9 	bl	1af96 <strlen>
	if (offset > value_len) {
   1c1e4:	b283      	uxth	r3, r0
   1c1e6:	42ab      	cmp	r3, r5
   1c1e8:	d30c      	bcc.n	1c204 <read_name+0x36>
	len = MIN(buf_len, value_len - offset);
   1c1ea:	1b5c      	subs	r4, r3, r5
   1c1ec:	4544      	cmp	r4, r8
   1c1ee:	bfa8      	it	ge
   1c1f0:	4644      	movge	r4, r8
   1c1f2:	b2a4      	uxth	r4, r4
	memcpy(buf, (u8_t *)value + offset, len);
   1c1f4:	4622      	mov	r2, r4
   1c1f6:	1979      	adds	r1, r7, r5
   1c1f8:	4630      	mov	r0, r6
   1c1fa:	f7fe fefe 	bl	1affa <memcpy>
}
   1c1fe:	4620      	mov	r0, r4
   1c200:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1c204:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
   1c208:	e7f9      	b.n	1c1fe <read_name+0x30>

0001c20a <bt_gatt_attr_read_ccc>:
{
   1c20a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	cfg = find_ccc_cfg(conn, ccc);
   1c20c:	68c9      	ldr	r1, [r1, #12]
{
   1c20e:	f8bd 5020 	ldrh.w	r5, [sp, #32]
   1c212:	4616      	mov	r6, r2
   1c214:	461f      	mov	r7, r3
	cfg = find_ccc_cfg(conn, ccc);
   1c216:	f7ff ff74 	bl	1c102 <find_ccc_cfg>
	if (cfg) {
   1c21a:	b100      	cbz	r0, 1c21e <bt_gatt_attr_read_ccc+0x14>
		value = sys_cpu_to_le16(cfg->value);
   1c21c:	8900      	ldrh	r0, [r0, #8]
   1c21e:	f8ad 0006 	strh.w	r0, [sp, #6]
	if (offset > value_len) {
   1c222:	2d02      	cmp	r5, #2
   1c224:	d80e      	bhi.n	1c244 <bt_gatt_attr_read_ccc+0x3a>
	len = MIN(buf_len, value_len - offset);
   1c226:	f1c5 0402 	rsb	r4, r5, #2
   1c22a:	42bc      	cmp	r4, r7
   1c22c:	bfa8      	it	ge
   1c22e:	463c      	movge	r4, r7
	memcpy(buf, (u8_t *)value + offset, len);
   1c230:	f10d 0306 	add.w	r3, sp, #6
   1c234:	4622      	mov	r2, r4
   1c236:	1959      	adds	r1, r3, r5
   1c238:	4630      	mov	r0, r6
   1c23a:	f7fe fede 	bl	1affa <memcpy>
}
   1c23e:	4620      	mov	r0, r4
   1c240:	b003      	add	sp, #12
   1c242:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1c244:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value,
   1c248:	e7f9      	b.n	1c23e <bt_gatt_attr_read_ccc+0x34>

0001c24a <cf_read>:
{
   1c24a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1c24c:	461f      	mov	r7, r3
	u8_t data[1] = {};
   1c24e:	2300      	movs	r3, #0
{
   1c250:	4616      	mov	r6, r2
   1c252:	f8bd 5020 	ldrh.w	r5, [sp, #32]
	u8_t data[1] = {};
   1c256:	f88d 3004 	strb.w	r3, [sp, #4]
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
   1c25a:	f7ee f93b 	bl	a4d4 <find_cf_cfg.part.10>
	if (cfg) {
   1c25e:	b128      	cbz	r0, 1c26c <cf_read+0x22>
		memcpy(data, cfg->data, sizeof(data));
   1c260:	f100 0108 	add.w	r1, r0, #8
   1c264:	2201      	movs	r2, #1
   1c266:	a801      	add	r0, sp, #4
   1c268:	f7fe fec7 	bl	1affa <memcpy>
	if (offset > value_len) {
   1c26c:	2d01      	cmp	r5, #1
   1c26e:	d80d      	bhi.n	1c28c <cf_read+0x42>
	len = MIN(buf_len, value_len - offset);
   1c270:	f1c5 0401 	rsb	r4, r5, #1
   1c274:	42bc      	cmp	r4, r7
   1c276:	bfa8      	it	ge
   1c278:	463c      	movge	r4, r7
	memcpy(buf, (u8_t *)value + offset, len);
   1c27a:	ab01      	add	r3, sp, #4
   1c27c:	4622      	mov	r2, r4
   1c27e:	1959      	adds	r1, r3, r5
   1c280:	4630      	mov	r0, r6
   1c282:	f7fe feba 	bl	1affa <memcpy>
}
   1c286:	4620      	mov	r0, r4
   1c288:	b003      	add	sp, #12
   1c28a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1c28c:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, data,
   1c290:	e7f9      	b.n	1c286 <cf_read+0x3c>

0001c292 <bt_gatt_attr_read_service>:
{
   1c292:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct bt_uuid *uuid = attr->user_data;
   1c294:	68c9      	ldr	r1, [r1, #12]
{
   1c296:	f8bd 5018 	ldrh.w	r5, [sp, #24]
   1c29a:	4610      	mov	r0, r2
	if (uuid->type == BT_UUID_TYPE_16) {
   1c29c:	780a      	ldrb	r2, [r1, #0]
   1c29e:	b992      	cbnz	r2, 1c2c6 <bt_gatt_attr_read_service+0x34>
		u16_t uuid16 = sys_cpu_to_le16(BT_UUID_16(uuid)->val);
   1c2a0:	884a      	ldrh	r2, [r1, #2]
   1c2a2:	f8ad 2006 	strh.w	r2, [sp, #6]
	if (offset > value_len) {
   1c2a6:	2d02      	cmp	r5, #2
   1c2a8:	d819      	bhi.n	1c2de <bt_gatt_attr_read_service+0x4c>
	len = MIN(buf_len, value_len - offset);
   1c2aa:	f1c5 0402 	rsb	r4, r5, #2
   1c2ae:	429c      	cmp	r4, r3
   1c2b0:	bfa8      	it	ge
   1c2b2:	461c      	movge	r4, r3
	memcpy(buf, (u8_t *)value + offset, len);
   1c2b4:	f10d 0306 	add.w	r3, sp, #6
   1c2b8:	4622      	mov	r2, r4
   1c2ba:	1959      	adds	r1, r3, r5
   1c2bc:	f7fe fe9d 	bl	1affa <memcpy>
}
   1c2c0:	4620      	mov	r0, r4
   1c2c2:	b003      	add	sp, #12
   1c2c4:	bd30      	pop	{r4, r5, pc}
	if (offset > value_len) {
   1c2c6:	2d10      	cmp	r5, #16
				 BT_UUID_128(uuid)->val, 16);
   1c2c8:	f101 0101 	add.w	r1, r1, #1
	if (offset > value_len) {
   1c2cc:	d807      	bhi.n	1c2de <bt_gatt_attr_read_service+0x4c>
	len = MIN(buf_len, value_len - offset);
   1c2ce:	f1c5 0410 	rsb	r4, r5, #16
   1c2d2:	429c      	cmp	r4, r3
   1c2d4:	bfa8      	it	ge
   1c2d6:	461c      	movge	r4, r3
	memcpy(buf, (u8_t *)value + offset, len);
   1c2d8:	4622      	mov	r2, r4
   1c2da:	4429      	add	r1, r5
   1c2dc:	e7ee      	b.n	1c2bc <bt_gatt_attr_read_service+0x2a>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1c2de:	f06f 0406 	mvn.w	r4, #6
   1c2e2:	e7ed      	b.n	1c2c0 <bt_gatt_attr_read_service+0x2e>

0001c2e4 <gatt_sub_remove>:
{
   1c2e4:	b538      	push	{r3, r4, r5, lr}
   1c2e6:	460c      	mov	r4, r1
	if (params) {
   1c2e8:	4619      	mov	r1, r3
   1c2ea:	b16b      	cbz	r3, 1c308 <gatt_sub_remove+0x24>
		sys_slist_remove(&sub->list, prev, &params->node);
   1c2ec:	f103 0510 	add.w	r5, r3, #16
Z_GENLIST_REMOVE(slist, snode)
   1c2f0:	691b      	ldr	r3, [r3, #16]
   1c2f2:	b982      	cbnz	r2, 1c316 <gatt_sub_remove+0x32>
   1c2f4:	68e2      	ldr	r2, [r4, #12]
	list->head = node;
   1c2f6:	60a3      	str	r3, [r4, #8]
Z_GENLIST_REMOVE(slist, snode)
   1c2f8:	4295      	cmp	r5, r2
   1c2fa:	d100      	bne.n	1c2fe <gatt_sub_remove+0x1a>
	list->tail = node;
   1c2fc:	60e3      	str	r3, [r4, #12]
	parent->next = child;
   1c2fe:	2300      	movs	r3, #0
   1c300:	610b      	str	r3, [r1, #16]
		params->notify(conn, params, NULL, 0);
   1c302:	680d      	ldr	r5, [r1, #0]
   1c304:	461a      	mov	r2, r3
   1c306:	47a8      	blx	r5
	if (sys_slist_is_empty(&sub->list)) {
   1c308:	68a3      	ldr	r3, [r4, #8]
   1c30a:	b953      	cbnz	r3, 1c322 <gatt_sub_remove+0x3e>
   1c30c:	4620      	mov	r0, r4
}
   1c30e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1c312:	f7ff bebc 	b.w	1c08e <gatt_sub_remove.part.9>
   1c316:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   1c318:	68e3      	ldr	r3, [r4, #12]
   1c31a:	429d      	cmp	r5, r3
	list->tail = node;
   1c31c:	bf08      	it	eq
   1c31e:	60e2      	streq	r2, [r4, #12]
   1c320:	e7ed      	b.n	1c2fe <gatt_sub_remove+0x1a>
   1c322:	bd38      	pop	{r3, r4, r5, pc}

0001c324 <gatt_write_ccc_rsp>:
{
   1c324:	b570      	push	{r4, r5, r6, lr}
   1c326:	9c04      	ldr	r4, [sp, #16]
   1c328:	460e      	mov	r6, r1
   1c32a:	4605      	mov	r5, r0
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   1c32c:	f06f 0104 	mvn.w	r1, #4
   1c330:	f104 000c 	add.w	r0, r4, #12
   1c334:	f7ff fe81 	bl	1c03a <atomic_and>
	if (err) {
   1c338:	b1b6      	cbz	r6, 1c368 <gatt_write_ccc_rsp+0x44>
		sub = gatt_sub_find(conn);
   1c33a:	2100      	movs	r1, #0
   1c33c:	4628      	mov	r0, r5
   1c33e:	f7ed ff29 	bl	a194 <gatt_sub_find_free>
		if (!sub) {
   1c342:	4601      	mov	r1, r0
   1c344:	b1d0      	cbz	r0, 1c37c <gatt_write_ccc_rsp+0x58>
		SYS_SLIST_FOR_EACH_NODE_SAFE(&sub->list, node, tmp) {
   1c346:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_PEEK_NEXT(slist, snode)
   1c348:	b1c3      	cbz	r3, 1c37c <gatt_write_ccc_rsp+0x58>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1c34a:	681a      	ldr	r2, [r3, #0]
			if (node == &params->node) {
   1c34c:	f104 0010 	add.w	r0, r4, #16
   1c350:	4283      	cmp	r3, r0
   1c352:	d105      	bne.n	1c360 <gatt_write_ccc_rsp+0x3c>
				gatt_sub_remove(conn, sub, tmp, params);
   1c354:	4623      	mov	r3, r4
   1c356:	4628      	mov	r0, r5
}
   1c358:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				gatt_sub_remove(conn, sub, tmp, params);
   1c35c:	f7ff bfc2 	b.w	1c2e4 <gatt_sub_remove>
Z_GENLIST_PEEK_NEXT(slist, snode)
   1c360:	b162      	cbz	r2, 1c37c <gatt_write_ccc_rsp+0x58>
   1c362:	4613      	mov	r3, r2
   1c364:	6812      	ldr	r2, [r2, #0]
   1c366:	e7f3      	b.n	1c350 <gatt_write_ccc_rsp+0x2c>
	} else if (!params->value) {
   1c368:	8923      	ldrh	r3, [r4, #8]
   1c36a:	b93b      	cbnz	r3, 1c37c <gatt_write_ccc_rsp+0x58>
		params->notify(conn, params, NULL, 0);
   1c36c:	6826      	ldr	r6, [r4, #0]
   1c36e:	4621      	mov	r1, r4
   1c370:	4628      	mov	r0, r5
   1c372:	46b4      	mov	ip, r6
   1c374:	461a      	mov	r2, r3
}
   1c376:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		params->notify(conn, params, NULL, 0);
   1c37a:	4760      	bx	ip
}
   1c37c:	bd70      	pop	{r4, r5, r6, pc}

0001c37e <bt_gatt_attr_read>:
{
   1c37e:	b510      	push	{r4, lr}
   1c380:	4610      	mov	r0, r2
   1c382:	f8bd 1008 	ldrh.w	r1, [sp, #8]
   1c386:	f8bd 2010 	ldrh.w	r2, [sp, #16]
	if (offset > value_len) {
   1c38a:	4291      	cmp	r1, r2
   1c38c:	d80b      	bhi.n	1c3a6 <bt_gatt_attr_read+0x28>
	len = MIN(buf_len, value_len - offset);
   1c38e:	1a54      	subs	r4, r2, r1
   1c390:	429c      	cmp	r4, r3
   1c392:	bfa8      	it	ge
   1c394:	461c      	movge	r4, r3
	memcpy(buf, (u8_t *)value + offset, len);
   1c396:	9b03      	ldr	r3, [sp, #12]
   1c398:	b2a4      	uxth	r4, r4
   1c39a:	4622      	mov	r2, r4
   1c39c:	4419      	add	r1, r3
   1c39e:	f7fe fe2c 	bl	1affa <memcpy>
}
   1c3a2:	4620      	mov	r0, r4
   1c3a4:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1c3a6:	f06f 0406 	mvn.w	r4, #6
   1c3aa:	e7fa      	b.n	1c3a2 <bt_gatt_attr_read+0x24>

0001c3ac <bt_gatt_attr_read_chrc>:
{
   1c3ac:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_gatt_chrc *chrc = attr->user_data;
   1c3ae:	68ce      	ldr	r6, [r1, #12]
{
   1c3b0:	b087      	sub	sp, #28
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   1c3b2:	4608      	mov	r0, r1
{
   1c3b4:	461c      	mov	r4, r3
	pdu.properties = chrc->properties;
   1c3b6:	79b3      	ldrb	r3, [r6, #6]
   1c3b8:	f88d 3004 	strb.w	r3, [sp, #4]
{
   1c3bc:	4617      	mov	r7, r2
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   1c3be:	f7ee fa11 	bl	a7e4 <bt_gatt_attr_value_handle>
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   1c3c2:	6831      	ldr	r1, [r6, #0]
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   1c3c4:	f8ad 0005 	strh.w	r0, [sp, #5]
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   1c3c8:	780b      	ldrb	r3, [r1, #0]
{
   1c3ca:	f8bd 5030 	ldrh.w	r5, [sp, #48]	; 0x30
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   1c3ce:	b99b      	cbnz	r3, 1c3f8 <bt_gatt_attr_read_chrc+0x4c>
		pdu.uuid16 = sys_cpu_to_le16(BT_UUID_16(chrc->uuid)->val);
   1c3d0:	884b      	ldrh	r3, [r1, #2]
   1c3d2:	f8ad 3007 	strh.w	r3, [sp, #7]
		value_len += 2U;
   1c3d6:	2305      	movs	r3, #5
	if (offset > value_len) {
   1c3d8:	42ab      	cmp	r3, r5
   1c3da:	d315      	bcc.n	1c408 <bt_gatt_attr_read_chrc+0x5c>
	len = MIN(buf_len, value_len - offset);
   1c3dc:	1b5b      	subs	r3, r3, r5
   1c3de:	42a3      	cmp	r3, r4
   1c3e0:	bfa8      	it	ge
   1c3e2:	4623      	movge	r3, r4
   1c3e4:	b29c      	uxth	r4, r3
	memcpy(buf, (u8_t *)value + offset, len);
   1c3e6:	ab01      	add	r3, sp, #4
   1c3e8:	4622      	mov	r2, r4
   1c3ea:	1959      	adds	r1, r3, r5
   1c3ec:	4638      	mov	r0, r7
   1c3ee:	f7fe fe04 	bl	1affa <memcpy>
}
   1c3f2:	4620      	mov	r0, r4
   1c3f4:	b007      	add	sp, #28
   1c3f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		memcpy(pdu.uuid, BT_UUID_128(chrc->uuid)->val, 16);
   1c3f8:	2210      	movs	r2, #16
   1c3fa:	3101      	adds	r1, #1
   1c3fc:	f10d 0007 	add.w	r0, sp, #7
   1c400:	f7fe fdfb 	bl	1affa <memcpy>
		value_len += 16U;
   1c404:	2313      	movs	r3, #19
   1c406:	e7e7      	b.n	1c3d8 <bt_gatt_attr_read_chrc+0x2c>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1c408:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &pdu, value_len);
   1c40c:	e7f1      	b.n	1c3f2 <bt_gatt_attr_read_chrc+0x46>

0001c40e <bt_gatt_foreach_attr>:
{
   1c40e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   1c410:	e9cd 2301 	strd	r2, r3, [sp, #4]
   1c414:	2300      	movs	r3, #0
   1c416:	9300      	str	r3, [sp, #0]
   1c418:	461a      	mov	r2, r3
   1c41a:	f7ee f9fb 	bl	a814 <bt_gatt_foreach_attr_type>
}
   1c41e:	b005      	add	sp, #20
   1c420:	f85d fb04 	ldr.w	pc, [sp], #4

0001c424 <db_hash_process>:
	db_hash_gen(true);
   1c424:	2001      	movs	r0, #1
   1c426:	f7ee ba53 	b.w	a8d0 <db_hash_gen>

0001c42a <bt_gatt_check_perm>:
{
   1c42a:	b538      	push	{r3, r4, r5, lr}
	if ((mask & BT_GATT_PERM_READ) &&
   1c42c:	07d4      	lsls	r4, r2, #31
{
   1c42e:	4605      	mov	r5, r0
   1c430:	7c88      	ldrb	r0, [r1, #18]
	if ((mask & BT_GATT_PERM_READ) &&
   1c432:	d504      	bpl.n	1c43e <bt_gatt_check_perm+0x14>
   1c434:	f010 0f15 	tst.w	r0, #21
   1c438:	d01e      	beq.n	1c478 <bt_gatt_check_perm+0x4e>
	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
   1c43a:	684b      	ldr	r3, [r1, #4]
   1c43c:	b1e3      	cbz	r3, 1c478 <bt_gatt_check_perm+0x4e>
	if ((mask & BT_GATT_PERM_WRITE) &&
   1c43e:	0793      	lsls	r3, r2, #30
   1c440:	d504      	bpl.n	1c44c <bt_gatt_check_perm+0x22>
   1c442:	f010 0f2a 	tst.w	r0, #42	; 0x2a
   1c446:	d019      	beq.n	1c47c <bt_gatt_check_perm+0x52>
	    (!(attr->perm & BT_GATT_PERM_WRITE_MASK) || !attr->write)) {
   1c448:	688b      	ldr	r3, [r1, #8]
   1c44a:	b1bb      	cbz	r3, 1c47c <bt_gatt_check_perm+0x52>
	mask &= attr->perm;
   1c44c:	ea02 0400 	and.w	r4, r2, r0
	if (mask & BT_GATT_PERM_AUTHEN_MASK) {
   1c450:	f014 0f30 	tst.w	r4, #48	; 0x30
   1c454:	d103      	bne.n	1c45e <bt_gatt_check_perm+0x34>
	if ((mask & BT_GATT_PERM_ENCRYPT_MASK)) {
   1c456:	f014 000c 	ands.w	r0, r4, #12
   1c45a:	d107      	bne.n	1c46c <bt_gatt_check_perm+0x42>
}
   1c45c:	bd38      	pop	{r3, r4, r5, pc}
		if (bt_conn_get_security(conn) < BT_SECURITY_L3) {
   1c45e:	4628      	mov	r0, r5
   1c460:	f7ff f893 	bl	1b58a <bt_conn_get_security>
   1c464:	2802      	cmp	r0, #2
   1c466:	d8f6      	bhi.n	1c456 <bt_gatt_check_perm+0x2c>
			return BT_ATT_ERR_AUTHENTICATION;
   1c468:	2005      	movs	r0, #5
   1c46a:	e7f7      	b.n	1c45c <bt_gatt_check_perm+0x32>
		if (!conn->encrypt) {
   1c46c:	7aeb      	ldrb	r3, [r5, #11]
			return BT_ATT_ERR_INSUFFICIENT_ENCRYPTION;
   1c46e:	2b00      	cmp	r3, #0
   1c470:	bf14      	ite	ne
   1c472:	2000      	movne	r0, #0
   1c474:	200f      	moveq	r0, #15
   1c476:	e7f1      	b.n	1c45c <bt_gatt_check_perm+0x32>
		return BT_ATT_ERR_READ_NOT_PERMITTED;
   1c478:	2002      	movs	r0, #2
   1c47a:	e7ef      	b.n	1c45c <bt_gatt_check_perm+0x32>
		return BT_ATT_ERR_WRITE_NOT_PERMITTED;
   1c47c:	2003      	movs	r0, #3
   1c47e:	e7ed      	b.n	1c45c <bt_gatt_check_perm+0x32>

0001c480 <gatt_discover_next>:
{
   1c480:	b570      	push	{r4, r5, r6, lr}
   1c482:	4605      	mov	r5, r0
   1c484:	4614      	mov	r4, r2
	if (!last_handle)
   1c486:	b929      	cbnz	r1, 1c494 <gatt_discover_next+0x14>
	if (!bt_gatt_discover(conn, params)) {
   1c488:	4621      	mov	r1, r4
   1c48a:	4628      	mov	r0, r5
   1c48c:	f7ee fcac 	bl	ade8 <bt_gatt_discover>
   1c490:	b928      	cbnz	r0, 1c49e <gatt_discover_next+0x1e>
}
   1c492:	bd70      	pop	{r4, r5, r6, pc}
	if (params->start_handle < UINT16_MAX) {
   1c494:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1c498:	4299      	cmp	r1, r3
   1c49a:	d107      	bne.n	1c4ac <gatt_discover_next+0x2c>
	params->start_handle = last_handle;
   1c49c:	8111      	strh	r1, [r2, #8]
	params->func(conn, NULL, params);
   1c49e:	6863      	ldr	r3, [r4, #4]
   1c4a0:	4622      	mov	r2, r4
   1c4a2:	4628      	mov	r0, r5
   1c4a4:	2100      	movs	r1, #0
}
   1c4a6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	params->func(conn, NULL, params);
   1c4aa:	4718      	bx	r3
		params->start_handle++;
   1c4ac:	3101      	adds	r1, #1
	if (params->start_handle > params->end_handle) {
   1c4ae:	89d3      	ldrh	r3, [r2, #14]
		params->start_handle++;
   1c4b0:	b289      	uxth	r1, r1
	if (params->start_handle > params->end_handle) {
   1c4b2:	428b      	cmp	r3, r1
		params->start_handle++;
   1c4b4:	8111      	strh	r1, [r2, #8]
	if (params->start_handle > params->end_handle) {
   1c4b6:	d2e7      	bcs.n	1c488 <gatt_discover_next+0x8>
   1c4b8:	e7f1      	b.n	1c49e <gatt_discover_next+0x1e>

0001c4ba <gatt_find_type_rsp>:
{
   1c4ba:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1c4be:	b088      	sub	sp, #32
   1c4c0:	4607      	mov	r7, r0
   1c4c2:	4690      	mov	r8, r2
   1c4c4:	461e      	mov	r6, r3
   1c4c6:	9d10      	ldr	r5, [sp, #64]	; 0x40
	if (err) {
   1c4c8:	2900      	cmp	r1, #0
   1c4ca:	d13a      	bne.n	1c542 <gatt_find_type_rsp+0x88>
   1c4cc:	460c      	mov	r4, r1
	u16_t end_handle = 0U, start_handle;
   1c4ce:	468a      	mov	sl, r1
		struct bt_gatt_attr attr = {};
   1c4d0:	4689      	mov	r9, r1
	for (i = 0U; length >= sizeof(rsp->list[i]);
   1c4d2:	2e03      	cmp	r6, #3
   1c4d4:	d809      	bhi.n	1c4ea <gatt_find_type_rsp+0x30>
	if (length > 0) {
   1c4d6:	2e00      	cmp	r6, #0
   1c4d8:	d133      	bne.n	1c542 <gatt_find_type_rsp+0x88>
	gatt_discover_next(conn, end_handle, params);
   1c4da:	462a      	mov	r2, r5
   1c4dc:	4651      	mov	r1, sl
   1c4de:	4638      	mov	r0, r7
   1c4e0:	f7ff ffce 	bl	1c480 <gatt_discover_next>
}
   1c4e4:	b008      	add	sp, #32
   1c4e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		struct bt_gatt_attr attr = {};
   1c4ea:	2210      	movs	r2, #16
   1c4ec:	2100      	movs	r1, #0
   1c4ee:	eb0d 0002 	add.w	r0, sp, r2
   1c4f2:	f7fe fdac 	bl	1b04e <memset>
		start_handle = sys_le16_to_cpu(rsp->list[i].start_handle);
   1c4f6:	b2e3      	uxtb	r3, r4
   1c4f8:	eb08 0383 	add.w	r3, r8, r3, lsl #2
		uuid_svc.uuid.type = BT_UUID_TYPE_16;
   1c4fc:	f88d 9000 	strb.w	r9, [sp]
		start_handle = sys_le16_to_cpu(rsp->list[i].start_handle);
   1c500:	881a      	ldrh	r2, [r3, #0]
		end_handle = sys_le16_to_cpu(rsp->list[i].end_handle);
   1c502:	f8b3 a002 	ldrh.w	sl, [r3, #2]
		if (params->type == BT_GATT_DISCOVER_PRIMARY) {
   1c506:	7c2b      	ldrb	r3, [r5, #16]
		attr.handle = start_handle;
   1c508:	f8ad 201c 	strh.w	r2, [sp, #28]
			uuid_svc.val = BT_UUID_16(BT_UUID_GATT_SECONDARY)->val;
   1c50c:	2b00      	cmp	r3, #0
   1c50e:	f642 0301 	movw	r3, #10241	; 0x2801
   1c512:	bf08      	it	eq
   1c514:	f44f 5320 	moveq.w	r3, #10240	; 0x2800
   1c518:	f8ad 3002 	strh.w	r3, [sp, #2]
		value.uuid = params->uuid;
   1c51c:	682b      	ldr	r3, [r5, #0]
   1c51e:	9301      	str	r3, [sp, #4]
		attr.user_data = &value;
   1c520:	ab01      	add	r3, sp, #4
   1c522:	9306      	str	r3, [sp, #24]
		value.end_handle = end_handle;
   1c524:	f8ad a008 	strh.w	sl, [sp, #8]
		attr.uuid = &uuid_svc.uuid;
   1c528:	f8cd d00c 	str.w	sp, [sp, #12]
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   1c52c:	686b      	ldr	r3, [r5, #4]
   1c52e:	462a      	mov	r2, r5
   1c530:	a903      	add	r1, sp, #12
   1c532:	4638      	mov	r0, r7
   1c534:	4798      	blx	r3
   1c536:	3401      	adds	r4, #1
   1c538:	2800      	cmp	r0, #0
   1c53a:	d0d3      	beq.n	1c4e4 <gatt_find_type_rsp+0x2a>
	     i++, length -=  sizeof(rsp->list[i])) {
   1c53c:	3e04      	subs	r6, #4
   1c53e:	b2b6      	uxth	r6, r6
   1c540:	e7c7      	b.n	1c4d2 <gatt_find_type_rsp+0x18>
	params->func(conn, NULL, params);
   1c542:	686b      	ldr	r3, [r5, #4]
   1c544:	462a      	mov	r2, r5
   1c546:	2100      	movs	r1, #0
   1c548:	4638      	mov	r0, r7
   1c54a:	4798      	blx	r3
   1c54c:	e7ca      	b.n	1c4e4 <gatt_find_type_rsp+0x2a>

0001c54e <bt_gatt_unsubscribe>:
	if (conn->state != BT_CONN_CONNECTED) {
   1c54e:	7b43      	ldrb	r3, [r0, #13]
   1c550:	2b06      	cmp	r3, #6
{
   1c552:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1c556:	4681      	mov	r9, r0
   1c558:	460e      	mov	r6, r1
	if (conn->state != BT_CONN_CONNECTED) {
   1c55a:	d169      	bne.n	1c630 <bt_gatt_unsubscribe+0xe2>
	sub = gatt_sub_find(conn);
   1c55c:	2100      	movs	r1, #0
   1c55e:	f7ed fe19 	bl	a194 <gatt_sub_find_free>
	if (!sub) {
   1c562:	4680      	mov	r8, r0
   1c564:	b920      	cbnz	r0, 1c570 <bt_gatt_unsubscribe+0x22>
		return -EINVAL;
   1c566:	f06f 0015 	mvn.w	r0, #21
}
   1c56a:	b003      	add	sp, #12
   1c56c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, tmp, next, node) {
   1c570:	6885      	ldr	r5, [r0, #8]
   1c572:	b1c5      	cbz	r5, 1c5a6 <bt_gatt_unsubscribe+0x58>
   1c574:	f1b5 0410 	subs.w	r4, r5, #16
   1c578:	d017      	beq.n	1c5aa <bt_gatt_unsubscribe+0x5c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1c57a:	682d      	ldr	r5, [r5, #0]
   1c57c:	b105      	cbz	r5, 1c580 <bt_gatt_unsubscribe+0x32>
   1c57e:	3d10      	subs	r5, #16
   1c580:	2700      	movs	r7, #0
   1c582:	463b      	mov	r3, r7
   1c584:	46ba      	mov	sl, r7
			if (atomic_test_bit(params->flags,
   1c586:	f106 0b0c 	add.w	fp, r6, #12
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, tmp, next, node) {
   1c58a:	b984      	cbnz	r4, 1c5ae <bt_gatt_unsubscribe+0x60>
	if (!found) {
   1c58c:	2b00      	cmp	r3, #0
   1c58e:	d0ea      	beq.n	1c566 <bt_gatt_unsubscribe+0x18>
	if (has_subscription) {
   1c590:	f1ba 0f00 	cmp.w	sl, #0
   1c594:	d041      	beq.n	1c61a <bt_gatt_unsubscribe+0xcc>
		params->notify(conn, params, NULL, 0);
   1c596:	6835      	ldr	r5, [r6, #0]
   1c598:	4623      	mov	r3, r4
   1c59a:	4622      	mov	r2, r4
   1c59c:	4631      	mov	r1, r6
   1c59e:	4648      	mov	r0, r9
   1c5a0:	47a8      	blx	r5
		return 0;
   1c5a2:	4620      	mov	r0, r4
   1c5a4:	e7e1      	b.n	1c56a <bt_gatt_unsubscribe+0x1c>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, tmp, next, node) {
   1c5a6:	462c      	mov	r4, r5
   1c5a8:	e7ea      	b.n	1c580 <bt_gatt_unsubscribe+0x32>
   1c5aa:	4625      	mov	r5, r4
   1c5ac:	e7e8      	b.n	1c580 <bt_gatt_unsubscribe+0x32>
		if (params == tmp) {
   1c5ae:	42b4      	cmp	r4, r6
   1c5b0:	f104 0110 	add.w	r1, r4, #16
   1c5b4:	d125      	bne.n	1c602 <bt_gatt_unsubscribe+0xb4>
Z_GENLIST_REMOVE(slist, snode)
   1c5b6:	6920      	ldr	r0, [r4, #16]
   1c5b8:	b9df      	cbnz	r7, 1c5f2 <bt_gatt_unsubscribe+0xa4>
   1c5ba:	f8d8 300c 	ldr.w	r3, [r8, #12]
	list->head = node;
   1c5be:	f8c8 0008 	str.w	r0, [r8, #8]
Z_GENLIST_REMOVE(slist, snode)
   1c5c2:	4299      	cmp	r1, r3
   1c5c4:	d101      	bne.n	1c5ca <bt_gatt_unsubscribe+0x7c>
	list->tail = node;
   1c5c6:	f8c8 000c 	str.w	r0, [r8, #12]
	parent->next = child;
   1c5ca:	2300      	movs	r3, #0
   1c5cc:	6123      	str	r3, [r4, #16]
			if (atomic_test_bit(params->flags,
   1c5ce:	2102      	movs	r1, #2
   1c5d0:	4658      	mov	r0, fp
   1c5d2:	f7ff fd29 	bl	1c028 <atomic_test_bit>
   1c5d6:	b1e0      	cbz	r0, 1c612 <bt_gatt_unsubscribe+0xc4>
   1c5d8:	9001      	str	r0, [sp, #4]
	bt_att_req_cancel(conn, params);
   1c5da:	4631      	mov	r1, r6
   1c5dc:	4648      	mov	r0, r9
   1c5de:	f7ed fa79 	bl	9ad4 <bt_att_req_cancel>
   1c5e2:	9b01      	ldr	r3, [sp, #4]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, tmp, next, node) {
   1c5e4:	b1bd      	cbz	r5, 1c616 <bt_gatt_unsubscribe+0xc8>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1c5e6:	6929      	ldr	r1, [r5, #16]
   1c5e8:	b101      	cbz	r1, 1c5ec <bt_gatt_unsubscribe+0x9e>
   1c5ea:	3910      	subs	r1, #16
   1c5ec:	462c      	mov	r4, r5
   1c5ee:	460d      	mov	r5, r1
   1c5f0:	e7cb      	b.n	1c58a <bt_gatt_unsubscribe+0x3c>
	parent->next = child;
   1c5f2:	6038      	str	r0, [r7, #0]
Z_GENLIST_REMOVE(slist, snode)
   1c5f4:	f8d8 300c 	ldr.w	r3, [r8, #12]
   1c5f8:	4299      	cmp	r1, r3
	list->tail = node;
   1c5fa:	bf08      	it	eq
   1c5fc:	f8c8 700c 	streq.w	r7, [r8, #12]
   1c600:	e7e3      	b.n	1c5ca <bt_gatt_unsubscribe+0x7c>
		if (tmp->value_handle == params->value_handle) {
   1c602:	88a4      	ldrh	r4, [r4, #4]
   1c604:	88b0      	ldrh	r0, [r6, #4]
   1c606:	460f      	mov	r7, r1
   1c608:	4284      	cmp	r4, r0
   1c60a:	bf08      	it	eq
   1c60c:	f04f 0a01 	moveq.w	sl, #1
   1c610:	e7e8      	b.n	1c5e4 <bt_gatt_unsubscribe+0x96>
			found = true;
   1c612:	2301      	movs	r3, #1
   1c614:	e7e6      	b.n	1c5e4 <bt_gatt_unsubscribe+0x96>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, tmp, next, node) {
   1c616:	4629      	mov	r1, r5
   1c618:	e7e8      	b.n	1c5ec <bt_gatt_unsubscribe+0x9e>
	return gatt_write_ccc(conn, params->ccc_handle, params->value,
   1c61a:	88f1      	ldrh	r1, [r6, #6]
	params->value = 0x0000;
   1c61c:	f8a6 a008 	strh.w	sl, [r6, #8]
	return gatt_write_ccc(conn, params->ccc_handle, params->value,
   1c620:	4633      	mov	r3, r6
   1c622:	4652      	mov	r2, sl
   1c624:	4648      	mov	r0, r9
}
   1c626:	b003      	add	sp, #12
   1c628:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return gatt_write_ccc(conn, params->ccc_handle, params->value,
   1c62c:	f7ed bd7e 	b.w	a12c <gatt_write_ccc.constprop.33>
		return -ENOTCONN;
   1c630:	f06f 0038 	mvn.w	r0, #56	; 0x38
   1c634:	e799      	b.n	1c56a <bt_gatt_unsubscribe+0x1c>

0001c636 <bt_gatt_notification>:
{
   1c636:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1c63a:	4688      	mov	r8, r1
	sub = gatt_sub_find(conn);
   1c63c:	2100      	movs	r1, #0
{
   1c63e:	4606      	mov	r6, r0
   1c640:	4691      	mov	r9, r2
   1c642:	469a      	mov	sl, r3
	sub = gatt_sub_find(conn);
   1c644:	f7ed fda6 	bl	a194 <gatt_sub_find_free>
	if (!sub) {
   1c648:	b1e0      	cbz	r0, 1c684 <bt_gatt_notification+0x4e>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   1c64a:	6883      	ldr	r3, [r0, #8]
   1c64c:	b1d3      	cbz	r3, 1c684 <bt_gatt_notification+0x4e>
   1c64e:	f1b3 0510 	subs.w	r5, r3, #16
   1c652:	d017      	beq.n	1c684 <bt_gatt_notification+0x4e>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1c654:	681c      	ldr	r4, [r3, #0]
   1c656:	b104      	cbz	r4, 1c65a <bt_gatt_notification+0x24>
   1c658:	3c10      	subs	r4, #16
		if (handle != params->value_handle) {
   1c65a:	88ab      	ldrh	r3, [r5, #4]
   1c65c:	4543      	cmp	r3, r8
   1c65e:	d10a      	bne.n	1c676 <bt_gatt_notification+0x40>
		if (params->notify(conn, params, data, length) ==
   1c660:	682f      	ldr	r7, [r5, #0]
   1c662:	4653      	mov	r3, sl
   1c664:	464a      	mov	r2, r9
   1c666:	4629      	mov	r1, r5
   1c668:	4630      	mov	r0, r6
   1c66a:	47b8      	blx	r7
   1c66c:	b918      	cbnz	r0, 1c676 <bt_gatt_notification+0x40>
			bt_gatt_unsubscribe(conn, params);
   1c66e:	4629      	mov	r1, r5
   1c670:	4630      	mov	r0, r6
   1c672:	f7ff ff6c 	bl	1c54e <bt_gatt_unsubscribe>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   1c676:	b12c      	cbz	r4, 1c684 <bt_gatt_notification+0x4e>
   1c678:	6923      	ldr	r3, [r4, #16]
   1c67a:	b103      	cbz	r3, 1c67e <bt_gatt_notification+0x48>
   1c67c:	3b10      	subs	r3, #16
{
   1c67e:	4625      	mov	r5, r4
   1c680:	461c      	mov	r4, r3
   1c682:	e7ea      	b.n	1c65a <bt_gatt_notification+0x24>
}
   1c684:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0001c688 <bt_gatt_change_aware>:
{
   1c688:	b570      	push	{r4, r5, r6, lr}
   1c68a:	460d      	mov	r5, r1
   1c68c:	f7ed ff22 	bl	a4d4 <find_cf_cfg.part.10>
	if (!cfg || !CF_ROBUST_CACHING(cfg)) {
   1c690:	b910      	cbnz	r0, 1c698 <bt_gatt_change_aware+0x10>
		return true;
   1c692:	2501      	movs	r5, #1
}
   1c694:	4628      	mov	r0, r5
   1c696:	bd70      	pop	{r4, r5, r6, pc}
	if (!cfg || !CF_ROBUST_CACHING(cfg)) {
   1c698:	7a03      	ldrb	r3, [r0, #8]
   1c69a:	07db      	lsls	r3, r3, #31
   1c69c:	d5f9      	bpl.n	1c692 <bt_gatt_change_aware+0xa>
	if (atomic_test_bit(cfg->flags, CF_CHANGE_AWARE)) {
   1c69e:	f100 040c 	add.w	r4, r0, #12
   1c6a2:	2100      	movs	r1, #0
   1c6a4:	4620      	mov	r0, r4
   1c6a6:	f7ff fcbf 	bl	1c028 <atomic_test_bit>
   1c6aa:	4606      	mov	r6, r0
   1c6ac:	2800      	cmp	r0, #0
   1c6ae:	d1f0      	bne.n	1c692 <bt_gatt_change_aware+0xa>
	if (!req) {
   1c6b0:	2d00      	cmp	r5, #0
   1c6b2:	d0ef      	beq.n	1c694 <bt_gatt_change_aware+0xc>
	if (atomic_test_bit(cfg->flags, CF_OUT_OF_SYNC)) {
   1c6b4:	2101      	movs	r1, #1
   1c6b6:	4620      	mov	r0, r4
   1c6b8:	f7ff fcb6 	bl	1c028 <atomic_test_bit>
   1c6bc:	4605      	mov	r5, r0
   1c6be:	b148      	cbz	r0, 1c6d4 <bt_gatt_change_aware+0x4c>
   1c6c0:	f06f 0102 	mvn.w	r1, #2
   1c6c4:	4620      	mov	r0, r4
   1c6c6:	f7ff fcb8 	bl	1c03a <atomic_and>
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   1c6ca:	4631      	mov	r1, r6
	atomic_set_bit(cfg->flags, CF_OUT_OF_SYNC);
   1c6cc:	4620      	mov	r0, r4
   1c6ce:	f7ff fd32 	bl	1c136 <atomic_set_bit>
	return false;
   1c6d2:	e7df      	b.n	1c694 <bt_gatt_change_aware+0xc>
	atomic_set_bit(cfg->flags, CF_OUT_OF_SYNC);
   1c6d4:	2101      	movs	r1, #1
   1c6d6:	e7f9      	b.n	1c6cc <bt_gatt_change_aware+0x44>

0001c6d8 <sys_memcpy_swap>:
	psrc += length - 1;
   1c6d8:	1e53      	subs	r3, r2, #1
   1c6da:	4419      	add	r1, r3
	for (; length > 0; length--) {
   1c6dc:	4402      	add	r2, r0
		*pdst++ = *psrc--;
   1c6de:	f811 3901 	ldrb.w	r3, [r1], #-1
   1c6e2:	f800 3b01 	strb.w	r3, [r0], #1
	for (; length > 0; length--) {
   1c6e6:	4290      	cmp	r0, r2
   1c6e8:	d1f9      	bne.n	1c6de <sys_memcpy_swap+0x6>
}
   1c6ea:	4770      	bx	lr

0001c6ec <sys_mem_swap>:
{
   1c6ec:	b510      	push	{r4, lr}
   1c6ee:	1843      	adds	r3, r0, r1
   1c6f0:	eb00 0151 	add.w	r1, r0, r1, lsr #1
		((u8_t *)buf)[i] = ((u8_t *)buf)[length - 1 - i];
   1c6f4:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
		u8_t tmp = ((u8_t *)buf)[i];
   1c6f8:	7802      	ldrb	r2, [r0, #0]
		((u8_t *)buf)[i] = ((u8_t *)buf)[length - 1 - i];
   1c6fa:	f800 4b01 	strb.w	r4, [r0], #1
	for (i = 0; i < (length/2); i++) {
   1c6fe:	4288      	cmp	r0, r1
		((u8_t *)buf)[length - 1 - i] = tmp;
   1c700:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < (length/2); i++) {
   1c702:	d1f7      	bne.n	1c6f4 <sys_mem_swap+0x8>
	}
}
   1c704:	bd10      	pop	{r4, pc}

0001c706 <smp_pairing_rsp>:
}
   1c706:	2007      	movs	r0, #7
   1c708:	4770      	bx	lr

0001c70a <atomic_set_bit>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   1c70a:	2301      	movs	r3, #1
   1c70c:	fa03 f101 	lsl.w	r1, r3, r1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1c710:	f3bf 8f5b 	dmb	ish
   1c714:	e850 3f00 	ldrex	r3, [r0]
   1c718:	430b      	orrs	r3, r1
   1c71a:	e840 3200 	strex	r2, r3, [r0]
   1c71e:	2a00      	cmp	r2, #0
   1c720:	d1f8      	bne.n	1c714 <atomic_set_bit+0xa>
   1c722:	f3bf 8f5b 	dmb	ish
}
   1c726:	4770      	bx	lr

0001c728 <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1c728:	f3bf 8f5b 	dmb	ish
   1c72c:	6800      	ldr	r0, [r0, #0]
   1c72e:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   1c732:	4108      	asrs	r0, r1
}
   1c734:	f000 0001 	and.w	r0, r0, #1
   1c738:	4770      	bx	lr

0001c73a <bt_smp_aes_cmac>:
{
   1c73a:	b570      	push	{r4, r5, r6, lr}
   1c73c:	b0c2      	sub	sp, #264	; 0x108
   1c73e:	460d      	mov	r5, r1
   1c740:	4616      	mov	r6, r2
	if (tc_cmac_setup(&state, key, &sched) == TC_CRYPTO_FAIL) {
   1c742:	4601      	mov	r1, r0
   1c744:	aa16      	add	r2, sp, #88	; 0x58
   1c746:	4668      	mov	r0, sp
{
   1c748:	461c      	mov	r4, r3
	if (tc_cmac_setup(&state, key, &sched) == TC_CRYPTO_FAIL) {
   1c74a:	f7fd fe54 	bl	1a3f6 <tc_cmac_setup>
   1c74e:	b150      	cbz	r0, 1c766 <bt_smp_aes_cmac+0x2c>
	if (tc_cmac_update(&state, in, len) == TC_CRYPTO_FAIL) {
   1c750:	4632      	mov	r2, r6
   1c752:	4629      	mov	r1, r5
   1c754:	4668      	mov	r0, sp
   1c756:	f7fd fe79 	bl	1a44c <tc_cmac_update>
   1c75a:	b120      	cbz	r0, 1c766 <bt_smp_aes_cmac+0x2c>
	if (tc_cmac_final(out, &state) == TC_CRYPTO_FAIL) {
   1c75c:	4669      	mov	r1, sp
   1c75e:	4620      	mov	r0, r4
   1c760:	f7fd fedf 	bl	1a522 <tc_cmac_final>
   1c764:	b918      	cbnz	r0, 1c76e <bt_smp_aes_cmac+0x34>
		return -EIO;
   1c766:	f06f 0004 	mvn.w	r0, #4
}
   1c76a:	b042      	add	sp, #264	; 0x108
   1c76c:	bd70      	pop	{r4, r5, r6, pc}
	return 0;
   1c76e:	2000      	movs	r0, #0
   1c770:	e7fb      	b.n	1c76a <bt_smp_aes_cmac+0x30>

0001c772 <smp_f4>:
{
   1c772:	b570      	push	{r4, r5, r6, lr}
   1c774:	b096      	sub	sp, #88	; 0x58
   1c776:	4614      	mov	r4, r2
   1c778:	460e      	mov	r6, r1
	sys_memcpy_swap(m, u, 32);
   1c77a:	2220      	movs	r2, #32
   1c77c:	4601      	mov	r1, r0
   1c77e:	a805      	add	r0, sp, #20
{
   1c780:	461d      	mov	r5, r3
	sys_memcpy_swap(m, u, 32);
   1c782:	f7ff ffa9 	bl	1c6d8 <sys_memcpy_swap>
	sys_memcpy_swap(m + 32, v, 32);
   1c786:	2220      	movs	r2, #32
   1c788:	4631      	mov	r1, r6
   1c78a:	a80d      	add	r0, sp, #52	; 0x34
   1c78c:	f7ff ffa4 	bl	1c6d8 <sys_memcpy_swap>
	sys_memcpy_swap(xs, x, 16);
   1c790:	4621      	mov	r1, r4
   1c792:	2210      	movs	r2, #16
   1c794:	a801      	add	r0, sp, #4
	m[64] = z;
   1c796:	f88d 5054 	strb.w	r5, [sp, #84]	; 0x54
	sys_memcpy_swap(xs, x, 16);
   1c79a:	f7ff ff9d 	bl	1c6d8 <sys_memcpy_swap>
	err = bt_smp_aes_cmac(xs, m, sizeof(m), res);
   1c79e:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   1c7a0:	2241      	movs	r2, #65	; 0x41
   1c7a2:	a905      	add	r1, sp, #20
   1c7a4:	a801      	add	r0, sp, #4
   1c7a6:	f7ff ffc8 	bl	1c73a <bt_smp_aes_cmac>
	if (err) {
   1c7aa:	4604      	mov	r4, r0
   1c7ac:	b918      	cbnz	r0, 1c7b6 <smp_f4+0x44>
	sys_mem_swap(res, 16);
   1c7ae:	2110      	movs	r1, #16
   1c7b0:	981a      	ldr	r0, [sp, #104]	; 0x68
   1c7b2:	f7ff ff9b 	bl	1c6ec <sys_mem_swap>
}
   1c7b6:	4620      	mov	r0, r4
   1c7b8:	b016      	add	sp, #88	; 0x58
   1c7ba:	bd70      	pop	{r4, r5, r6, pc}

0001c7bc <smp_f6>:
{
   1c7bc:	b570      	push	{r4, r5, r6, lr}
   1c7be:	b096      	sub	sp, #88	; 0x58
   1c7c0:	4605      	mov	r5, r0
   1c7c2:	4616      	mov	r6, r2
	sys_memcpy_swap(m, n1, 16);
   1c7c4:	a805      	add	r0, sp, #20
   1c7c6:	2210      	movs	r2, #16
{
   1c7c8:	461c      	mov	r4, r3
	sys_memcpy_swap(m, n1, 16);
   1c7ca:	f7ff ff85 	bl	1c6d8 <sys_memcpy_swap>
	sys_memcpy_swap(m + 16, n2, 16);
   1c7ce:	2210      	movs	r2, #16
   1c7d0:	4631      	mov	r1, r6
   1c7d2:	a809      	add	r0, sp, #36	; 0x24
   1c7d4:	f7ff ff80 	bl	1c6d8 <sys_memcpy_swap>
	sys_memcpy_swap(m + 32, r, 16);
   1c7d8:	4621      	mov	r1, r4
   1c7da:	2210      	movs	r2, #16
   1c7dc:	a80d      	add	r0, sp, #52	; 0x34
   1c7de:	f7ff ff7b 	bl	1c6d8 <sys_memcpy_swap>
	sys_memcpy_swap(m + 48, iocap, 3);
   1c7e2:	2203      	movs	r2, #3
   1c7e4:	991a      	ldr	r1, [sp, #104]	; 0x68
   1c7e6:	a811      	add	r0, sp, #68	; 0x44
   1c7e8:	f7ff ff76 	bl	1c6d8 <sys_memcpy_swap>
	m[51] = a1->type;
   1c7ec:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
   1c7ee:	f814 3b01 	ldrb.w	r3, [r4], #1
   1c7f2:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
	memcpy(m + 52, a1->a.val, 6);
   1c7f6:	4621      	mov	r1, r4
   1c7f8:	2206      	movs	r2, #6
   1c7fa:	a812      	add	r0, sp, #72	; 0x48
   1c7fc:	f7fe fbfd 	bl	1affa <memcpy>
	sys_memcpy_swap(m + 52, a1->a.val, 6);
   1c800:	4621      	mov	r1, r4
   1c802:	2206      	movs	r2, #6
   1c804:	a812      	add	r0, sp, #72	; 0x48
   1c806:	f7ff ff67 	bl	1c6d8 <sys_memcpy_swap>
	m[58] = a2->type;
   1c80a:	9c1c      	ldr	r4, [sp, #112]	; 0x70
   1c80c:	f814 3b01 	ldrb.w	r3, [r4], #1
   1c810:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
	memcpy(m + 59, a2->a.val, 6);
   1c814:	4621      	mov	r1, r4
   1c816:	2206      	movs	r2, #6
   1c818:	f10d 004f 	add.w	r0, sp, #79	; 0x4f
   1c81c:	f7fe fbed 	bl	1affa <memcpy>
	sys_memcpy_swap(m + 59, a2->a.val, 6);
   1c820:	4621      	mov	r1, r4
   1c822:	2206      	movs	r2, #6
   1c824:	f10d 004f 	add.w	r0, sp, #79	; 0x4f
   1c828:	f7ff ff56 	bl	1c6d8 <sys_memcpy_swap>
	sys_memcpy_swap(ws, w, 16);
   1c82c:	2210      	movs	r2, #16
   1c82e:	4629      	mov	r1, r5
   1c830:	a801      	add	r0, sp, #4
   1c832:	f7ff ff51 	bl	1c6d8 <sys_memcpy_swap>
	err = bt_smp_aes_cmac(ws, m, sizeof(m), check);
   1c836:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   1c838:	2241      	movs	r2, #65	; 0x41
   1c83a:	a905      	add	r1, sp, #20
   1c83c:	a801      	add	r0, sp, #4
   1c83e:	f7ff ff7c 	bl	1c73a <bt_smp_aes_cmac>
	if (err) {
   1c842:	4604      	mov	r4, r0
   1c844:	b918      	cbnz	r0, 1c84e <smp_f6+0x92>
	sys_mem_swap(check, 16);
   1c846:	2110      	movs	r1, #16
   1c848:	981d      	ldr	r0, [sp, #116]	; 0x74
   1c84a:	f7ff ff4f 	bl	1c6ec <sys_mem_swap>
}
   1c84e:	4620      	mov	r0, r4
   1c850:	b016      	add	sp, #88	; 0x58
   1c852:	bd70      	pop	{r4, r5, r6, pc}

0001c854 <atomic_clear_bit>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   1c854:	2301      	movs	r3, #1
   1c856:	fa03 f101 	lsl.w	r1, r3, r1
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   1c85a:	43c9      	mvns	r1, r1
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1c85c:	f3bf 8f5b 	dmb	ish
   1c860:	e850 3f00 	ldrex	r3, [r0]
   1c864:	400b      	ands	r3, r1
   1c866:	e840 3200 	strex	r2, r3, [r0]
   1c86a:	2a00      	cmp	r2, #0
   1c86c:	d1f8      	bne.n	1c860 <atomic_clear_bit+0xc>
   1c86e:	f3bf 8f5b 	dmb	ish
}
   1c872:	4770      	bx	lr

0001c874 <bt_smp_disconnected>:
{
   1c874:	b538      	push	{r3, r4, r5, lr}
	struct bt_keys *keys = chan->conn->le.keys;
   1c876:	6803      	ldr	r3, [r0, #0]
   1c878:	f8d3 409c 	ldr.w	r4, [r3, #156]	; 0x9c
{
   1c87c:	4605      	mov	r5, r0
	k_delayed_work_cancel(&smp->work);
   1c87e:	f500 70be 	add.w	r0, r0, #380	; 0x17c
   1c882:	f001 ff69 	bl	1e758 <k_delayed_work_cancel>
	if (keys) {
   1c886:	b13c      	cbz	r4, 1c898 <bt_smp_disconnected+0x24>
		if (!keys->keys || (!IS_ENABLED(CONFIG_BT_STORE_DEBUG_KEYS) &&
   1c888:	8963      	ldrh	r3, [r4, #10]
   1c88a:	b113      	cbz	r3, 1c892 <bt_smp_disconnected+0x1e>
   1c88c:	7a63      	ldrb	r3, [r4, #9]
   1c88e:	079b      	lsls	r3, r3, #30
   1c890:	d502      	bpl.n	1c898 <bt_smp_disconnected+0x24>
			bt_keys_clear(keys);
   1c892:	4620      	mov	r0, r4
   1c894:	f7f0 ff94 	bl	d7c0 <bt_keys_clear>
	(void)memset(smp, 0, sizeof(*smp));
   1c898:	4628      	mov	r0, r5
   1c89a:	f44f 72ce 	mov.w	r2, #412	; 0x19c
   1c89e:	2100      	movs	r1, #0
}
   1c8a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	(void)memset(smp, 0, sizeof(*smp));
   1c8a4:	f7fe bbd3 	b.w	1b04e <memset>

0001c8a8 <smp_create_pdu.isra.6>:
static struct net_buf *smp_create_pdu(struct bt_smp *smp, u8_t op, size_t len)
   1c8a8:	b570      	push	{r4, r5, r6, lr}
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
   1c8aa:	f100 0594 	add.w	r5, r0, #148	; 0x94
static struct net_buf *smp_create_pdu(struct bt_smp *smp, u8_t op, size_t len)
   1c8ae:	460e      	mov	r6, r1
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
   1c8b0:	4628      	mov	r0, r5
   1c8b2:	2104      	movs	r1, #4
   1c8b4:	f7ff ff38 	bl	1c728 <atomic_test_bit>
	buf = bt_l2cap_create_pdu_timeout(NULL, 0, timeout);
   1c8b8:	2100      	movs	r1, #0
		timeout = SMP_TIMEOUT;
   1c8ba:	2800      	cmp	r0, #0
	buf = bt_l2cap_create_pdu_timeout(NULL, 0, timeout);
   1c8bc:	f247 5230 	movw	r2, #30000	; 0x7530
   1c8c0:	4608      	mov	r0, r1
   1c8c2:	bf18      	it	ne
   1c8c4:	2200      	movne	r2, #0
   1c8c6:	f7fe ff41 	bl	1b74c <bt_l2cap_create_pdu_timeout>
	if (!buf) {
   1c8ca:	4604      	mov	r4, r0
   1c8cc:	b928      	cbnz	r0, 1c8da <smp_create_pdu.isra.6+0x32>
		atomic_set_bit(smp->flags, SMP_FLAG_TIMEOUT);
   1c8ce:	2104      	movs	r1, #4
   1c8d0:	4628      	mov	r0, r5
   1c8d2:	f7ff ff1a 	bl	1c70a <atomic_set_bit>
}
   1c8d6:	4620      	mov	r0, r4
   1c8d8:	bd70      	pop	{r4, r5, r6, pc}
	hdr = net_buf_add(buf, sizeof(*hdr));
   1c8da:	2101      	movs	r1, #1
   1c8dc:	3008      	adds	r0, #8
   1c8de:	f001 f9b5 	bl	1dc4c <net_buf_simple_add>
	hdr->code = op;
   1c8e2:	7006      	strb	r6, [r0, #0]
	return buf;
   1c8e4:	e7f7      	b.n	1c8d6 <smp_create_pdu.isra.6+0x2e>

0001c8e6 <smp_dhkey_check>:
{
   1c8e6:	b570      	push	{r4, r5, r6, lr}
	if (smp->chan.chan.conn->role == BT_HCI_ROLE_SLAVE) {
   1c8e8:	6803      	ldr	r3, [r0, #0]
   1c8ea:	78db      	ldrb	r3, [r3, #3]
   1c8ec:	2b01      	cmp	r3, #1
{
   1c8ee:	4605      	mov	r5, r0
	if (smp->chan.chan.conn->role == BT_HCI_ROLE_SLAVE) {
   1c8f0:	d115      	bne.n	1c91e <smp_dhkey_check+0x38>
	struct bt_smp_dhkey_check *req = (void *)buf->data;
   1c8f2:	688e      	ldr	r6, [r1, #8]
		atomic_clear_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT);
   1c8f4:	f100 0494 	add.w	r4, r0, #148	; 0x94
   1c8f8:	210f      	movs	r1, #15
   1c8fa:	4620      	mov	r0, r4
   1c8fc:	f7ff ffaa 	bl	1c854 <atomic_clear_bit>
		memcpy(smp->e, req->e, sizeof(smp->e));
   1c900:	4631      	mov	r1, r6
   1c902:	2210      	movs	r2, #16
   1c904:	f205 1047 	addw	r0, r5, #327	; 0x147
   1c908:	f7fe fb77 	bl	1affa <memcpy>
		if (atomic_test_bit(smp->flags, SMP_FLAG_DHKEY_PENDING)) {
   1c90c:	2107      	movs	r1, #7
   1c90e:	4620      	mov	r0, r4
   1c910:	f7ff ff0a 	bl	1c728 <atomic_test_bit>
   1c914:	b128      	cbz	r0, 1c922 <smp_dhkey_check+0x3c>
			atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_SEND);
   1c916:	2108      	movs	r1, #8
   1c918:	4620      	mov	r0, r4
   1c91a:	f7ff fef6 	bl	1c70a <atomic_set_bit>
}
   1c91e:	2000      	movs	r0, #0
   1c920:	bd70      	pop	{r4, r5, r6, pc}
		if (atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
   1c922:	2109      	movs	r1, #9
   1c924:	4620      	mov	r0, r4
   1c926:	f7ff feff 	bl	1c728 <atomic_test_bit>
   1c92a:	2800      	cmp	r0, #0
   1c92c:	d1f3      	bne.n	1c916 <smp_dhkey_check+0x30>
		return compute_and_check_and_send_slave_dhcheck(smp);
   1c92e:	4628      	mov	r0, r5
}
   1c930:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return compute_and_check_and_send_slave_dhcheck(smp);
   1c934:	f7ef bb30 	b.w	bf98 <compute_and_check_and_send_slave_dhcheck>

0001c938 <smp_send_pairing_random>:
{
   1c938:	b538      	push	{r3, r4, r5, lr}
	rsp_buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_RANDOM, sizeof(*req));
   1c93a:	2104      	movs	r1, #4
{
   1c93c:	4605      	mov	r5, r0
	rsp_buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_RANDOM, sizeof(*req));
   1c93e:	f7ff ffb3 	bl	1c8a8 <smp_create_pdu.isra.6>
	if (!rsp_buf) {
   1c942:	4604      	mov	r4, r0
   1c944:	b178      	cbz	r0, 1c966 <smp_send_pairing_random+0x2e>
	req = net_buf_add(rsp_buf, sizeof(*req));
   1c946:	2110      	movs	r1, #16
   1c948:	3008      	adds	r0, #8
   1c94a:	f001 f97f 	bl	1dc4c <net_buf_simple_add>
	memcpy(req->val, smp->prnd, sizeof(req->val));
   1c94e:	2210      	movs	r2, #16
   1c950:	f105 01b7 	add.w	r1, r5, #183	; 0xb7
   1c954:	f7fe fb51 	bl	1affa <memcpy>
	smp_send(smp, rsp_buf, NULL, NULL);
   1c958:	4628      	mov	r0, r5
   1c95a:	2200      	movs	r2, #0
   1c95c:	4621      	mov	r1, r4
   1c95e:	f7ef fa61 	bl	be24 <smp_send.isra.7>
	return 0;
   1c962:	2000      	movs	r0, #0
}
   1c964:	bd38      	pop	{r3, r4, r5, pc}
		return BT_SMP_ERR_UNSPECIFIED;
   1c966:	2008      	movs	r0, #8
   1c968:	e7fc      	b.n	1c964 <smp_send_pairing_random+0x2c>

0001c96a <send_pairing_rsp>:
{
   1c96a:	b538      	push	{r3, r4, r5, lr}
	rsp_buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_RSP, sizeof(*rsp));
   1c96c:	2102      	movs	r1, #2
{
   1c96e:	4605      	mov	r5, r0
	rsp_buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_RSP, sizeof(*rsp));
   1c970:	f7ff ff9a 	bl	1c8a8 <smp_create_pdu.isra.6>
	if (!rsp_buf) {
   1c974:	4604      	mov	r4, r0
   1c976:	b178      	cbz	r0, 1c998 <send_pairing_rsp+0x2e>
	rsp = net_buf_add(rsp_buf, sizeof(*rsp));
   1c978:	2106      	movs	r1, #6
   1c97a:	3008      	adds	r0, #8
   1c97c:	f001 f966 	bl	1dc4c <net_buf_simple_add>
	memcpy(rsp, smp->prsp + 1, sizeof(*rsp));
   1c980:	2206      	movs	r2, #6
   1c982:	f105 01a1 	add.w	r1, r5, #161	; 0xa1
   1c986:	f7fe fb38 	bl	1affa <memcpy>
	smp_send(smp, rsp_buf, NULL, NULL);
   1c98a:	4628      	mov	r0, r5
   1c98c:	2200      	movs	r2, #0
   1c98e:	4621      	mov	r1, r4
   1c990:	f7ef fa48 	bl	be24 <smp_send.isra.7>
	return 0;
   1c994:	2000      	movs	r0, #0
}
   1c996:	bd38      	pop	{r3, r4, r5, pc}
		return BT_SMP_ERR_UNSPECIFIED;
   1c998:	2008      	movs	r0, #8
   1c99a:	e7fc      	b.n	1c996 <send_pairing_rsp+0x2c>

0001c99c <smp_security_request>:
   1c99c:	2007      	movs	r0, #7
   1c99e:	4770      	bx	lr

0001c9a0 <atomic_test_and_clear_bit>:
{
   1c9a0:	b510      	push	{r4, lr}
	atomic_val_t mask = ATOMIC_MASK(bit);
   1c9a2:	f001 021f 	and.w	r2, r1, #31
   1c9a6:	2301      	movs	r3, #1
   1c9a8:	4093      	lsls	r3, r2
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   1c9aa:	0949      	lsrs	r1, r1, #5
   1c9ac:	43dc      	mvns	r4, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1c9ae:	eb00 0081 	add.w	r0, r0, r1, lsl #2
   1c9b2:	f3bf 8f5b 	dmb	ish
   1c9b6:	e850 2f00 	ldrex	r2, [r0]
   1c9ba:	ea02 0104 	and.w	r1, r2, r4
   1c9be:	e840 1c00 	strex	ip, r1, [r0]
   1c9c2:	f1bc 0f00 	cmp.w	ip, #0
   1c9c6:	d1f6      	bne.n	1c9b6 <atomic_test_and_clear_bit+0x16>
   1c9c8:	f3bf 8f5b 	dmb	ish
	return (old & mask) != 0;
   1c9cc:	421a      	tst	r2, r3
}
   1c9ce:	bf14      	ite	ne
   1c9d0:	2001      	movne	r0, #1
   1c9d2:	2000      	moveq	r0, #0
   1c9d4:	bd10      	pop	{r4, pc}

0001c9d6 <smp_reset>:
{
   1c9d6:	b538      	push	{r3, r4, r5, lr}
   1c9d8:	4604      	mov	r4, r0
	struct bt_conn *conn = smp->chan.chan.conn;
   1c9da:	6805      	ldr	r5, [r0, #0]
	k_delayed_work_cancel(&smp->work);
   1c9dc:	f500 70be 	add.w	r0, r0, #380	; 0x17c
   1c9e0:	f001 feba 	bl	1e758 <k_delayed_work_cancel>
	smp->method = JUST_WORKS;
   1c9e4:	2300      	movs	r3, #0
   1c9e6:	f884 3098 	strb.w	r3, [r4, #152]	; 0x98
	atomic_set(&smp->allowed_cmds, 0);
   1c9ea:	f104 0090 	add.w	r0, r4, #144	; 0x90
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   1c9ee:	f3bf 8f5b 	dmb	ish
   1c9f2:	e850 2f00 	ldrex	r2, [r0]
   1c9f6:	e840 3100 	strex	r1, r3, [r0]
   1c9fa:	2900      	cmp	r1, #0
   1c9fc:	d1f9      	bne.n	1c9f2 <smp_reset+0x1c>
   1c9fe:	f3bf 8f5b 	dmb	ish
   1ca02:	f3bf 8f5b 	dmb	ish
   1ca06:	3494      	adds	r4, #148	; 0x94
   1ca08:	e854 2f00 	ldrex	r2, [r4]
   1ca0c:	e844 3100 	strex	r1, r3, [r4]
   1ca10:	2900      	cmp	r1, #0
   1ca12:	d1f9      	bne.n	1ca08 <smp_reset+0x32>
   1ca14:	f3bf 8f5b 	dmb	ish
	if (conn->required_sec_level != conn->sec_level) {
   1ca18:	7a6b      	ldrb	r3, [r5, #9]
   1ca1a:	7aaa      	ldrb	r2, [r5, #10]
   1ca1c:	429a      	cmp	r2, r3
		conn->required_sec_level = conn->sec_level;
   1ca1e:	bf18      	it	ne
   1ca20:	72ab      	strbne	r3, [r5, #10]
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_REQ);
   1ca22:	2101      	movs	r1, #1
}
   1ca24:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_REQ);
   1ca28:	f7ff be6f 	b.w	1c70a <atomic_set_bit>

0001ca2c <smp_error>:
{
   1ca2c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1ca2e:	4606      	mov	r6, r0
   1ca30:	460c      	mov	r4, r1
	smp_pairing_complete(smp, reason);
   1ca32:	f7ef fde9 	bl	c608 <smp_pairing_complete>
	buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_FAIL, sizeof(*rsp));
   1ca36:	2105      	movs	r1, #5
   1ca38:	4630      	mov	r0, r6
   1ca3a:	f7ff ff35 	bl	1c8a8 <smp_create_pdu.isra.6>
	if (!buf) {
   1ca3e:	4605      	mov	r5, r0
   1ca40:	b178      	cbz	r0, 1ca62 <smp_error+0x36>
	rsp = net_buf_add(buf, sizeof(*rsp));
   1ca42:	2101      	movs	r1, #1
   1ca44:	3008      	adds	r0, #8
   1ca46:	f001 f901 	bl	1dc4c <net_buf_simple_add>
	rsp->reason = reason;
   1ca4a:	7004      	strb	r4, [r0, #0]
   1ca4c:	2400      	movs	r4, #0
   1ca4e:	9400      	str	r4, [sp, #0]
   1ca50:	4623      	mov	r3, r4
   1ca52:	462a      	mov	r2, r5
   1ca54:	2106      	movs	r1, #6
   1ca56:	6830      	ldr	r0, [r6, #0]
   1ca58:	f7fe fe7b 	bl	1b752 <bt_l2cap_send_cb>
	return 0;
   1ca5c:	4620      	mov	r0, r4
}
   1ca5e:	b002      	add	sp, #8
   1ca60:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOBUFS;
   1ca62:	f06f 0036 	mvn.w	r0, #54	; 0x36
   1ca66:	e7fa      	b.n	1ca5e <smp_error+0x32>

0001ca68 <smp_check_complete.part.14>:
static void smp_check_complete(struct bt_conn *conn, u8_t dist_complete)
   1ca68:	b510      	push	{r4, lr}
   1ca6a:	460c      	mov	r4, r1
		chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_SMP);
   1ca6c:	2106      	movs	r1, #6
   1ca6e:	f7fe fe89 	bl	1b784 <bt_l2cap_le_lookup_tx_cid>
		smp->local_dist &= ~dist_complete;
   1ca72:	f890 1178 	ldrb.w	r1, [r0, #376]	; 0x178
   1ca76:	ea21 0104 	bic.w	r1, r1, r4
   1ca7a:	f880 1178 	strb.w	r1, [r0, #376]	; 0x178
		if (!smp->local_dist && !smp->remote_dist) {
   1ca7e:	f8b0 1178 	ldrh.w	r1, [r0, #376]	; 0x178
   1ca82:	b919      	cbnz	r1, 1ca8c <smp_check_complete.part.14+0x24>
}
   1ca84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			smp_pairing_complete(smp, 0);
   1ca88:	f7ef bdbe 	b.w	c608 <smp_pairing_complete>
}
   1ca8c:	bd10      	pop	{r4, pc}

0001ca8e <smp_ident_sent>:
	if (conn->type == BT_CONN_TYPE_LE) {
   1ca8e:	7881      	ldrb	r1, [r0, #2]
   1ca90:	2901      	cmp	r1, #1
   1ca92:	d101      	bne.n	1ca98 <smp_ident_sent+0xa>
   1ca94:	f7ff bfe8 	b.w	1ca68 <smp_check_complete.part.14>
}
   1ca98:	4770      	bx	lr

0001ca9a <smp_sign_info_sent>:
	if (conn->type == BT_CONN_TYPE_LE) {
   1ca9a:	7883      	ldrb	r3, [r0, #2]
   1ca9c:	2b01      	cmp	r3, #1
   1ca9e:	d102      	bne.n	1caa6 <smp_sign_info_sent+0xc>
   1caa0:	2104      	movs	r1, #4
   1caa2:	f7ff bfe1 	b.w	1ca68 <smp_check_complete.part.14>
}
   1caa6:	4770      	bx	lr

0001caa8 <smp_id_sent>:
	if (conn->type == BT_CONN_TYPE_LE) {
   1caa8:	7883      	ldrb	r3, [r0, #2]
   1caaa:	2b01      	cmp	r3, #1
   1caac:	d102      	bne.n	1cab4 <smp_id_sent+0xc>
   1caae:	2102      	movs	r1, #2
   1cab0:	f7ff bfda 	b.w	1ca68 <smp_check_complete.part.14>
}
   1cab4:	4770      	bx	lr

0001cab6 <smp_c1>:
{
   1cab6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1caba:	b089      	sub	sp, #36	; 0x24
   1cabc:	e9dd 7810 	ldrd	r7, r8, [sp, #64]	; 0x40
   1cac0:	4699      	mov	r9, r3
	p1[0] = ia->type;
   1cac2:	783b      	ldrb	r3, [r7, #0]
{
   1cac4:	9c12      	ldr	r4, [sp, #72]	; 0x48
	p1[0] = ia->type;
   1cac6:	f88d 3000 	strb.w	r3, [sp]
{
   1caca:	460d      	mov	r5, r1
	p1[1] = ra->type;
   1cacc:	f898 3000 	ldrb.w	r3, [r8]
   1cad0:	f88d 3001 	strb.w	r3, [sp, #1]
{
   1cad4:	4611      	mov	r1, r2
   1cad6:	4606      	mov	r6, r0
	memcpy(p1 + 2, preq, 7);
   1cad8:	2207      	movs	r2, #7
   1cada:	f10d 0002 	add.w	r0, sp, #2
   1cade:	f7fe fa8c 	bl	1affa <memcpy>
	memcpy(p1 + 9, pres, 7);
   1cae2:	2207      	movs	r2, #7
   1cae4:	4649      	mov	r1, r9
   1cae6:	f10d 0009 	add.w	r0, sp, #9
   1caea:	f7fe fa86 	bl	1affa <memcpy>
	while (len--) {
   1caee:	f105 0010 	add.w	r0, r5, #16
	memcpy(p1 + 9, pres, 7);
   1caf2:	4621      	mov	r1, r4
   1caf4:	466a      	mov	r2, sp
	while (len--) {
   1caf6:	4285      	cmp	r5, r0
   1caf8:	d127      	bne.n	1cb4a <smp_c1+0x94>
	err = bt_encrypt_le(k, enc_data, enc_data);
   1cafa:	4622      	mov	r2, r4
   1cafc:	4621      	mov	r1, r4
   1cafe:	4630      	mov	r0, r6
   1cb00:	f000 fbce 	bl	1d2a0 <bt_encrypt_le>
	if (err) {
   1cb04:	4605      	mov	r5, r0
   1cb06:	b9e0      	cbnz	r0, 1cb42 <smp_c1+0x8c>
	memcpy(p2, ra->a.val, 6);
   1cb08:	2206      	movs	r2, #6
   1cb0a:	f108 0101 	add.w	r1, r8, #1
   1cb0e:	a804      	add	r0, sp, #16
   1cb10:	f7fe fa73 	bl	1affa <memcpy>
	memcpy(p2 + 6, ia->a.val, 6);
   1cb14:	2206      	movs	r2, #6
   1cb16:	1c79      	adds	r1, r7, #1
   1cb18:	f10d 0016 	add.w	r0, sp, #22
   1cb1c:	f7fe fa6d 	bl	1affa <memcpy>
	(void)memset(p2 + 12, 0, 4);
   1cb20:	2204      	movs	r2, #4
   1cb22:	4629      	mov	r1, r5
   1cb24:	a807      	add	r0, sp, #28
   1cb26:	f7fe fa92 	bl	1b04e <memset>
	while (len--) {
   1cb2a:	f104 0010 	add.w	r0, r4, #16
	(void)memset(p2 + 12, 0, 4);
   1cb2e:	4622      	mov	r2, r4
   1cb30:	ab04      	add	r3, sp, #16
	while (len--) {
   1cb32:	4282      	cmp	r2, r0
   1cb34:	d112      	bne.n	1cb5c <smp_c1+0xa6>
	return bt_encrypt_le(k, enc_data, enc_data);
   1cb36:	4622      	mov	r2, r4
   1cb38:	4621      	mov	r1, r4
   1cb3a:	4630      	mov	r0, r6
   1cb3c:	f000 fbb0 	bl	1d2a0 <bt_encrypt_le>
   1cb40:	4605      	mov	r5, r0
}
   1cb42:	4628      	mov	r0, r5
   1cb44:	b009      	add	sp, #36	; 0x24
   1cb46:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		*r++ = *p++ ^ *q++;
   1cb4a:	f815 3b01 	ldrb.w	r3, [r5], #1
   1cb4e:	f812 cb01 	ldrb.w	ip, [r2], #1
   1cb52:	ea83 030c 	eor.w	r3, r3, ip
   1cb56:	f801 3b01 	strb.w	r3, [r1], #1
   1cb5a:	e7cc      	b.n	1caf6 <smp_c1+0x40>
   1cb5c:	f812 1b01 	ldrb.w	r1, [r2], #1
   1cb60:	f813 5b01 	ldrb.w	r5, [r3], #1
   1cb64:	4069      	eors	r1, r5
   1cb66:	f802 1c01 	strb.w	r1, [r2, #-1]
   1cb6a:	e7e2      	b.n	1cb32 <smp_c1+0x7c>

0001cb6c <legacy_pairing_confirm>:
{
   1cb6c:	b5f0      	push	{r4, r5, r6, r7, lr}
		if (!atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
   1cb6e:	f100 0794 	add.w	r7, r0, #148	; 0x94
{
   1cb72:	b085      	sub	sp, #20
   1cb74:	4605      	mov	r5, r0
		if (!atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
   1cb76:	2109      	movs	r1, #9
   1cb78:	4638      	mov	r0, r7
   1cb7a:	f7ff fdd5 	bl	1c728 <atomic_test_bit>
   1cb7e:	bb90      	cbnz	r0, 1cbe6 <legacy_pairing_confirm+0x7a>
			atomic_set_bit(&smp->allowed_cmds,
   1cb80:	2104      	movs	r1, #4
   1cb82:	f105 0090 	add.w	r0, r5, #144	; 0x90
   1cb86:	f7ff fdc0 	bl	1c70a <atomic_set_bit>
	buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_CONFIRM, sizeof(*req));
   1cb8a:	2103      	movs	r1, #3
   1cb8c:	4628      	mov	r0, r5
	struct bt_conn *conn = smp->chan.chan.conn;
   1cb8e:	682c      	ldr	r4, [r5, #0]
	buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_CONFIRM, sizeof(*req));
   1cb90:	f7ff fe8a 	bl	1c8a8 <smp_create_pdu.isra.6>
	if (!buf) {
   1cb94:	4606      	mov	r6, r0
   1cb96:	b1c0      	cbz	r0, 1cbca <legacy_pairing_confirm+0x5e>
	req = net_buf_add(buf, sizeof(*req));
   1cb98:	2110      	movs	r1, #16
   1cb9a:	3008      	adds	r0, #8
   1cb9c:	f001 f856 	bl	1dc4c <net_buf_simple_add>
		   &conn->le.init_addr, &conn->le.resp_addr, req->val)) {
   1cba0:	f104 037e 	add.w	r3, r4, #126	; 0x7e
   1cba4:	3477      	adds	r4, #119	; 0x77
	if (smp_c1(smp->tk, smp->prnd, smp->preq, smp->prsp,
   1cba6:	9002      	str	r0, [sp, #8]
   1cba8:	9301      	str	r3, [sp, #4]
   1cbaa:	9400      	str	r4, [sp, #0]
   1cbac:	f105 03a0 	add.w	r3, r5, #160	; 0xa0
   1cbb0:	f105 0299 	add.w	r2, r5, #153	; 0x99
   1cbb4:	f105 01b7 	add.w	r1, r5, #183	; 0xb7
   1cbb8:	f105 00d7 	add.w	r0, r5, #215	; 0xd7
   1cbbc:	f7ff ff7b 	bl	1cab6 <smp_c1>
   1cbc0:	4604      	mov	r4, r0
   1cbc2:	b120      	cbz	r0, 1cbce <legacy_pairing_confirm+0x62>
		net_buf_unref(buf);
   1cbc4:	4630      	mov	r0, r6
   1cbc6:	f7f9 fcab 	bl	16520 <net_buf_unref>
		return BT_SMP_ERR_UNSPECIFIED;
   1cbca:	2008      	movs	r0, #8
   1cbcc:	e009      	b.n	1cbe2 <legacy_pairing_confirm+0x76>
	smp_send(smp, buf, NULL, NULL);
   1cbce:	4602      	mov	r2, r0
   1cbd0:	4631      	mov	r1, r6
   1cbd2:	4628      	mov	r0, r5
   1cbd4:	f7ef f926 	bl	be24 <smp_send.isra.7>
	atomic_clear_bit(smp->flags, SMP_FLAG_CFM_DELAYED);
   1cbd8:	4621      	mov	r1, r4
   1cbda:	4638      	mov	r0, r7
   1cbdc:	f7ff fe3a 	bl	1c854 <atomic_clear_bit>
	return 0;
   1cbe0:	2000      	movs	r0, #0
}
   1cbe2:	b005      	add	sp, #20
   1cbe4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		atomic_set_bit(smp->flags, SMP_FLAG_CFM_DELAYED);
   1cbe6:	2100      	movs	r1, #0
   1cbe8:	4638      	mov	r0, r7
   1cbea:	f7ff fd8e 	bl	1c70a <atomic_set_bit>
   1cbee:	e7f7      	b.n	1cbe0 <legacy_pairing_confirm+0x74>

0001cbf0 <smp_pairing_confirm>:
{
   1cbf0:	b570      	push	{r4, r5, r6, lr}
	struct bt_smp_pairing_confirm *req = (void *)buf->data;
   1cbf2:	688e      	ldr	r6, [r1, #8]
	atomic_clear_bit(smp->flags, SMP_FLAG_DISPLAY);
   1cbf4:	f100 0594 	add.w	r5, r0, #148	; 0x94
{
   1cbf8:	4604      	mov	r4, r0
	atomic_clear_bit(smp->flags, SMP_FLAG_DISPLAY);
   1cbfa:	210a      	movs	r1, #10
   1cbfc:	4628      	mov	r0, r5
   1cbfe:	f7ff fe29 	bl	1c854 <atomic_clear_bit>
	memcpy(smp->pcnf, req->val, sizeof(smp->pcnf));
   1cc02:	4631      	mov	r1, r6
   1cc04:	2210      	movs	r2, #16
   1cc06:	f104 00a7 	add.w	r0, r4, #167	; 0xa7
   1cc0a:	f7fe f9f6 	bl	1affa <memcpy>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
   1cc0e:	2105      	movs	r1, #5
   1cc10:	4628      	mov	r0, r5
   1cc12:	f7ff fd89 	bl	1c728 <atomic_test_bit>
   1cc16:	b920      	cbnz	r0, 1cc22 <smp_pairing_confirm+0x32>
		return legacy_pairing_confirm(smp);
   1cc18:	4620      	mov	r0, r4
}
   1cc1a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return legacy_pairing_confirm(smp);
   1cc1e:	f7ff bfa5 	b.w	1cb6c <legacy_pairing_confirm>
	switch (smp->method) {
   1cc22:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
   1cc26:	2b01      	cmp	r3, #1
   1cc28:	d00b      	beq.n	1cc42 <smp_pairing_confirm+0x52>
   1cc2a:	2b02      	cmp	r3, #2
   1cc2c:	d115      	bne.n	1cc5a <smp_pairing_confirm+0x6a>
		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
   1cc2e:	f104 0090 	add.w	r0, r4, #144	; 0x90
   1cc32:	2104      	movs	r1, #4
   1cc34:	f7ff fd69 	bl	1c70a <atomic_set_bit>
		return smp_send_pairing_confirm(smp);
   1cc38:	4620      	mov	r0, r4
}
   1cc3a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return smp_send_pairing_confirm(smp);
   1cc3e:	f7ef b907 	b.w	be50 <smp_send_pairing_confirm>
		if (atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
   1cc42:	2109      	movs	r1, #9
   1cc44:	4628      	mov	r0, r5
   1cc46:	f7ff fd6f 	bl	1c728 <atomic_test_bit>
   1cc4a:	2800      	cmp	r0, #0
   1cc4c:	d0ef      	beq.n	1cc2e <smp_pairing_confirm+0x3e>
			atomic_set_bit(smp->flags, SMP_FLAG_CFM_DELAYED);
   1cc4e:	4628      	mov	r0, r5
   1cc50:	2100      	movs	r1, #0
   1cc52:	f7ff fd5a 	bl	1c70a <atomic_set_bit>
			return 0;
   1cc56:	2000      	movs	r0, #0
}
   1cc58:	bd70      	pop	{r4, r5, r6, pc}
		return BT_SMP_ERR_UNSPECIFIED;
   1cc5a:	2008      	movs	r0, #8
   1cc5c:	e7fc      	b.n	1cc58 <smp_pairing_confirm+0x68>

0001cc5e <bt_smp_request_ltk>:
{
   1cc5e:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   1cc62:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
   1cc64:	4605      	mov	r5, r0
   1cc66:	e9cd 2300 	strd	r2, r3, [sp]
	smp = smp_chan_get(conn);
   1cc6a:	f7ef f87b 	bl	bd64 <smp_chan_get>
	if (!smp) {
   1cc6e:	4604      	mov	r4, r0
   1cc70:	2800      	cmp	r0, #0
   1cc72:	f000 809c 	beq.w	1cdae <bt_smp_request_ltk+0x150>
	if (ediv == 0U && rand == 0U &&
   1cc76:	f8bd 9028 	ldrh.w	r9, [sp, #40]	; 0x28
   1cc7a:	f1b9 0f00 	cmp.w	r9, #0
   1cc7e:	d12d      	bne.n	1ccdc <bt_smp_request_ltk+0x7e>
   1cc80:	e9dd 2300 	ldrd	r2, r3, [sp]
   1cc84:	4313      	orrs	r3, r2
   1cc86:	d129      	bne.n	1ccdc <bt_smp_request_ltk+0x7e>
	    atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) &&
   1cc88:	f100 0894 	add.w	r8, r0, #148	; 0x94
   1cc8c:	2103      	movs	r1, #3
   1cc8e:	4640      	mov	r0, r8
   1cc90:	f7ff fd4a 	bl	1c728 <atomic_test_bit>
	if (ediv == 0U && rand == 0U &&
   1cc94:	b310      	cbz	r0, 1ccdc <bt_smp_request_ltk+0x7e>
	    atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
   1cc96:	2101      	movs	r1, #1
   1cc98:	4640      	mov	r0, r8
   1cc9a:	f7ff fd45 	bl	1c728 <atomic_test_bit>
	    atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) &&
   1cc9e:	4606      	mov	r6, r0
   1cca0:	b1e0      	cbz	r0, 1ccdc <bt_smp_request_ltk+0x7e>
	return MIN(req->max_key_size, rsp->max_key_size);
   1cca2:	f894 50a4 	ldrb.w	r5, [r4, #164]	; 0xa4
   1cca6:	f894 309d 	ldrb.w	r3, [r4, #157]	; 0x9d
   1ccaa:	429d      	cmp	r5, r3
   1ccac:	bf28      	it	cs
   1ccae:	461d      	movcs	r5, r3
		memcpy(ltk, smp->tk, enc_size);
   1ccb0:	462a      	mov	r2, r5
   1ccb2:	f104 01d7 	add.w	r1, r4, #215	; 0xd7
   1ccb6:	4638      	mov	r0, r7
   1ccb8:	f7fe f99f 	bl	1affa <memcpy>
		if (enc_size < BT_SMP_MAX_ENC_KEY_SIZE) {
   1ccbc:	2d0f      	cmp	r5, #15
   1ccbe:	d805      	bhi.n	1cccc <bt_smp_request_ltk+0x6e>
			(void)memset(ltk + enc_size, 0,
   1ccc0:	f1c5 0210 	rsb	r2, r5, #16
   1ccc4:	4649      	mov	r1, r9
   1ccc6:	1978      	adds	r0, r7, r5
   1ccc8:	f7fe f9c1 	bl	1b04e <memset>
		atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
   1cccc:	2101      	movs	r1, #1
   1ccce:	4640      	mov	r0, r8
   1ccd0:	f7ff fd1b 	bl	1c70a <atomic_set_bit>
}
   1ccd4:	4630      	mov	r0, r6
   1ccd6:	b003      	add	sp, #12
   1ccd8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (!conn->le.keys) {
   1ccdc:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
   1cce0:	b983      	cbnz	r3, 1cd04 <bt_smp_request_ltk+0xa6>
					     &conn->le.dst);
   1cce2:	f105 0670 	add.w	r6, r5, #112	; 0x70
		conn->le.keys = bt_keys_find(BT_KEYS_LTK_P256, conn->id,
   1cce6:	4632      	mov	r2, r6
   1cce8:	7a29      	ldrb	r1, [r5, #8]
   1ccea:	2020      	movs	r0, #32
   1ccec:	f7f0 fd06 	bl	d6fc <bt_keys_find>
   1ccf0:	f8c5 009c 	str.w	r0, [r5, #156]	; 0x9c
		if (!conn->le.keys) {
   1ccf4:	b930      	cbnz	r0, 1cd04 <bt_smp_request_ltk+0xa6>
			conn->le.keys = bt_keys_find(BT_KEYS_SLAVE_LTK,
   1ccf6:	4632      	mov	r2, r6
   1ccf8:	7a29      	ldrb	r1, [r5, #8]
   1ccfa:	2001      	movs	r0, #1
   1ccfc:	f7f0 fcfe 	bl	d6fc <bt_keys_find>
   1cd00:	f8c5 009c 	str.w	r0, [r5, #156]	; 0x9c
	if (ediv == 0U && rand == 0U &&
   1cd04:	f8bd 6028 	ldrh.w	r6, [sp, #40]	; 0x28
   1cd08:	f8d5 009c 	ldr.w	r0, [r5, #156]	; 0x9c
   1cd0c:	b9ce      	cbnz	r6, 1cd42 <bt_smp_request_ltk+0xe4>
   1cd0e:	e9dd 2300 	ldrd	r2, r3, [sp]
   1cd12:	4313      	orrs	r3, r2
   1cd14:	d115      	bne.n	1cd42 <bt_smp_request_ltk+0xe4>
   1cd16:	2800      	cmp	r0, #0
   1cd18:	d03c      	beq.n	1cd94 <bt_smp_request_ltk+0x136>
	    conn->le.keys && (conn->le.keys->keys & BT_KEYS_LTK_P256)) {
   1cd1a:	8943      	ldrh	r3, [r0, #10]
   1cd1c:	069a      	lsls	r2, r3, #26
   1cd1e:	d511      	bpl.n	1cd44 <bt_smp_request_ltk+0xe6>
		enc_size = conn->le.keys->enc_size;
   1cd20:	7a04      	ldrb	r4, [r0, #8]
		memcpy(ltk, conn->le.keys->ltk.val, enc_size);
   1cd22:	f100 0116 	add.w	r1, r0, #22
   1cd26:	4622      	mov	r2, r4
   1cd28:	4638      	mov	r0, r7
   1cd2a:	f7fe f966 	bl	1affa <memcpy>
		if (enc_size < BT_SMP_MAX_ENC_KEY_SIZE) {
   1cd2e:	2c0f      	cmp	r4, #15
   1cd30:	d805      	bhi.n	1cd3e <bt_smp_request_ltk+0xe0>
			(void)memset(ltk + enc_size, 0,
   1cd32:	f1c4 0210 	rsb	r2, r4, #16
   1cd36:	4631      	mov	r1, r6
   1cd38:	1938      	adds	r0, r7, r4
   1cd3a:	f7fe f988 	bl	1b04e <memset>
		return true;
   1cd3e:	2601      	movs	r6, #1
   1cd40:	e7c8      	b.n	1ccd4 <bt_smp_request_ltk+0x76>
	if (conn->le.keys && (conn->le.keys->keys & BT_KEYS_SLAVE_LTK) &&
   1cd42:	b338      	cbz	r0, 1cd94 <bt_smp_request_ltk+0x136>
   1cd44:	8943      	ldrh	r3, [r0, #10]
   1cd46:	07db      	lsls	r3, r3, #31
   1cd48:	d524      	bpl.n	1cd94 <bt_smp_request_ltk+0x136>
	    !memcmp(conn->le.keys->slave_ltk.rand, &rand, 8) &&
   1cd4a:	2208      	movs	r2, #8
   1cd4c:	4669      	mov	r1, sp
   1cd4e:	3064      	adds	r0, #100	; 0x64
   1cd50:	f7fe f943 	bl	1afda <memcmp>
	if (conn->le.keys && (conn->le.keys->keys & BT_KEYS_SLAVE_LTK) &&
   1cd54:	b9f0      	cbnz	r0, 1cd94 <bt_smp_request_ltk+0x136>
	    !memcmp(conn->le.keys->slave_ltk.ediv, &ediv, 2)) {
   1cd56:	f8d5 009c 	ldr.w	r0, [r5, #156]	; 0x9c
   1cd5a:	2202      	movs	r2, #2
   1cd5c:	a90a      	add	r1, sp, #40	; 0x28
   1cd5e:	306c      	adds	r0, #108	; 0x6c
   1cd60:	f7fe f93b 	bl	1afda <memcmp>
	    !memcmp(conn->le.keys->slave_ltk.rand, &rand, 8) &&
   1cd64:	4606      	mov	r6, r0
   1cd66:	b9a8      	cbnz	r0, 1cd94 <bt_smp_request_ltk+0x136>
		enc_size = conn->le.keys->enc_size;
   1cd68:	f8d5 109c 	ldr.w	r1, [r5, #156]	; 0x9c
   1cd6c:	7a0d      	ldrb	r5, [r1, #8]
		memcpy(ltk, conn->le.keys->slave_ltk.val, enc_size);
   1cd6e:	4638      	mov	r0, r7
   1cd70:	462a      	mov	r2, r5
   1cd72:	316e      	adds	r1, #110	; 0x6e
   1cd74:	f7fe f941 	bl	1affa <memcpy>
		if (enc_size < BT_SMP_MAX_ENC_KEY_SIZE) {
   1cd78:	2d0f      	cmp	r5, #15
   1cd7a:	d805      	bhi.n	1cd88 <bt_smp_request_ltk+0x12a>
			(void)memset(ltk + enc_size, 0,
   1cd7c:	f1c5 0210 	rsb	r2, r5, #16
   1cd80:	4631      	mov	r1, r6
   1cd82:	1978      	adds	r0, r7, r5
   1cd84:	f7fe f963 	bl	1b04e <memset>
		atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
   1cd88:	2101      	movs	r1, #1
   1cd8a:	f104 0094 	add.w	r0, r4, #148	; 0x94
   1cd8e:	f7ff fcbc 	bl	1c70a <atomic_set_bit>
		return true;
   1cd92:	e7d4      	b.n	1cd3e <bt_smp_request_ltk+0xe0>
	if (atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ)) {
   1cd94:	210e      	movs	r1, #14
   1cd96:	f104 0094 	add.w	r0, r4, #148	; 0x94
   1cd9a:	f7ff fcc5 	bl	1c728 <atomic_test_bit>
   1cd9e:	b118      	cbz	r0, 1cda8 <bt_smp_request_ltk+0x14a>
		bt_conn_security_changed(smp->chan.chan.conn,
   1cda0:	2102      	movs	r1, #2
   1cda2:	6820      	ldr	r0, [r4, #0]
   1cda4:	f7eb f83e 	bl	7e24 <bt_conn_security_changed>
	smp_reset(smp);
   1cda8:	4620      	mov	r0, r4
   1cdaa:	f7ff fe14 	bl	1c9d6 <smp_reset>
	return false;
   1cdae:	2600      	movs	r6, #0
   1cdb0:	e790      	b.n	1ccd4 <bt_smp_request_ltk+0x76>

0001cdb2 <bt_smp_irk_get>:
{
   1cdb2:	b530      	push	{r4, r5, lr}
   1cdb4:	b085      	sub	sp, #20
   1cdb6:	4605      	mov	r5, r0
	u8_t invalid_ir[16] = { 0 };
   1cdb8:	2210      	movs	r2, #16
{
   1cdba:	460c      	mov	r4, r1
	u8_t invalid_ir[16] = { 0 };
   1cdbc:	4668      	mov	r0, sp
   1cdbe:	2100      	movs	r1, #0
   1cdc0:	f7fe f945 	bl	1b04e <memset>
	if (!memcmp(ir, invalid_ir, 16)) {
   1cdc4:	2210      	movs	r2, #16
   1cdc6:	4669      	mov	r1, sp
   1cdc8:	4628      	mov	r0, r5
   1cdca:	f7fe f906 	bl	1afda <memcmp>
   1cdce:	b180      	cbz	r0, 1cdf2 <bt_smp_irk_get+0x40>
	dst[1] = val >> 8;
   1cdd0:	2100      	movs	r1, #0
	dst[0] = val;
   1cdd2:	2301      	movs	r3, #1
	dst[1] = val >> 8;
   1cdd4:	7061      	strb	r1, [r4, #1]
	dst[0] = val;
   1cdd6:	70a1      	strb	r1, [r4, #2]
	dst[1] = val >> 8;
   1cdd8:	70e1      	strb	r1, [r4, #3]
	memset(&res[4], 0, 16 - 4);
   1cdda:	220c      	movs	r2, #12
	dst[0] = val;
   1cddc:	7023      	strb	r3, [r4, #0]
   1cdde:	1d20      	adds	r0, r4, #4
   1cde0:	f7fe f935 	bl	1b04e <memset>
	err = bt_encrypt_le(key, res, res);
   1cde4:	4622      	mov	r2, r4
   1cde6:	4621      	mov	r1, r4
   1cde8:	4628      	mov	r0, r5
   1cdea:	f000 fa59 	bl	1d2a0 <bt_encrypt_le>
}
   1cdee:	b005      	add	sp, #20
   1cdf0:	bd30      	pop	{r4, r5, pc}
		return -EINVAL;
   1cdf2:	f06f 0015 	mvn.w	r0, #21
   1cdf6:	e7fa      	b.n	1cdee <bt_smp_irk_get+0x3c>

0001cdf8 <id_add>:
	bt_id_add(keys);
   1cdf8:	f7e9 bcc6 	b.w	6788 <bt_id_add>

0001cdfc <bt_keys_get_type>:
{
   1cdfc:	b570      	push	{r4, r5, r6, lr}
   1cdfe:	4604      	mov	r4, r0
   1ce00:	460d      	mov	r5, r1
   1ce02:	4616      	mov	r6, r2
	keys = bt_keys_find(type, id, addr);
   1ce04:	f7f0 fc7a 	bl	d6fc <bt_keys_find>
	if (keys) {
   1ce08:	b938      	cbnz	r0, 1ce1a <bt_keys_get_type+0x1e>
	keys = bt_keys_get_addr(id, addr);
   1ce0a:	4631      	mov	r1, r6
   1ce0c:	4628      	mov	r0, r5
   1ce0e:	f7f0 fc01 	bl	d614 <bt_keys_get_addr>
	if (!keys) {
   1ce12:	b110      	cbz	r0, 1ce1a <bt_keys_get_type+0x1e>
	keys->keys |= type;
   1ce14:	8943      	ldrh	r3, [r0, #10]
   1ce16:	431c      	orrs	r4, r3
   1ce18:	8144      	strh	r4, [r0, #10]
}
   1ce1a:	bd70      	pop	{r4, r5, r6, pc}

0001ce1c <bt_keys_add_type>:
	keys->keys |= type;
   1ce1c:	8943      	ldrh	r3, [r0, #10]
   1ce1e:	4319      	orrs	r1, r3
   1ce20:	8141      	strh	r1, [r0, #10]
}
   1ce22:	4770      	bx	lr

0001ce24 <mem_init>:

#include "mem.h"

void mem_init(void *mem_pool, u16_t mem_size, u16_t mem_count,
	      void **mem_head)
{
   1ce24:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	*mem_head = mem_pool;
   1ce26:	6018      	str	r0, [r3, #0]

	/* Store free mem_count after the list's next pointer at an 32-bit
	 * aligned memory location to ensure atomic read/write (in ARM for now).
	 */
	*((u16_t *)MROUND((u8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   1ce28:	1dc3      	adds	r3, r0, #7
   1ce2a:	f023 0303 	bic.w	r3, r3, #3
{
   1ce2e:	460e      	mov	r6, r1
	*((u16_t *)MROUND((u8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   1ce30:	801a      	strh	r2, [r3, #0]

	/* Initialize next pointers to form a free list,
	 * next pointer is stored in the first 32-bit of each block
	 */
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   1ce32:	3a01      	subs	r2, #1
   1ce34:	b294      	uxth	r4, r2
{
   1ce36:	4605      	mov	r5, r0
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   1ce38:	2204      	movs	r2, #4
   1ce3a:	2100      	movs	r1, #0
   1ce3c:	fb06 0004 	mla	r0, r6, r4, r0
   1ce40:	f7fe f905 	bl	1b04e <memset>
		     sizeof(mem_pool));
	while (mem_count--) {
   1ce44:	f64f 77ff 	movw	r7, #65535	; 0xffff
   1ce48:	3c01      	subs	r4, #1
   1ce4a:	b2a4      	uxth	r4, r4
   1ce4c:	42bc      	cmp	r4, r7
   1ce4e:	d101      	bne.n	1ce54 <mem_init+0x30>
		next = (u32_t)((u8_t *) mem_pool +
			       (mem_size * (mem_count + 1)));
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
		       (void *)&next, sizeof(next));
	}
}
   1ce50:	b003      	add	sp, #12
   1ce52:	bdf0      	pop	{r4, r5, r6, r7, pc}
			       (mem_size * (mem_count + 1)));
   1ce54:	fb04 6006 	mla	r0, r4, r6, r6
		next = (u32_t)((u8_t *) mem_pool +
   1ce58:	182b      	adds	r3, r5, r0
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
   1ce5a:	2204      	movs	r2, #4
   1ce5c:	1b80      	subs	r0, r0, r6
   1ce5e:	eb0d 0102 	add.w	r1, sp, r2
   1ce62:	4428      	add	r0, r5
		next = (u32_t)((u8_t *) mem_pool +
   1ce64:	9301      	str	r3, [sp, #4]
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
   1ce66:	f7fe f8c8 	bl	1affa <memcpy>
   1ce6a:	e7ed      	b.n	1ce48 <mem_init+0x24>

0001ce6c <mem_acquire>:

void *mem_acquire(void **mem_head)
{
   1ce6c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (*mem_head) {
   1ce6e:	6804      	ldr	r4, [r0, #0]
{
   1ce70:	4606      	mov	r6, r0
	if (*mem_head) {
   1ce72:	b18c      	cbz	r4, 1ce98 <mem_acquire+0x2c>
		u16_t free_count;
		void *head;
		void *mem;

		/* Get the free count from the list and decrement it */
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
   1ce74:	1de3      	adds	r3, r4, #7
   1ce76:	f023 0303 	bic.w	r3, r3, #3
					       sizeof(mem_head)));
		free_count--;

		mem = *mem_head;
		memcpy(&head, mem, sizeof(head));
   1ce7a:	2204      	movs	r2, #4
   1ce7c:	4621      	mov	r1, r4
   1ce7e:	eb0d 0002 	add.w	r0, sp, r2
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
   1ce82:	881d      	ldrh	r5, [r3, #0]
		memcpy(&head, mem, sizeof(head));
   1ce84:	f7fe f8b9 	bl	1affa <memcpy>

		/* Store free mem_count after the list's next pointer */
		if (head) {
   1ce88:	9b01      	ldr	r3, [sp, #4]
   1ce8a:	b123      	cbz	r3, 1ce96 <mem_acquire+0x2a>
			*((u16_t *)MROUND((u8_t *)head + sizeof(head))) =
   1ce8c:	1dda      	adds	r2, r3, #7
   1ce8e:	f022 0203 	bic.w	r2, r2, #3
		free_count--;
   1ce92:	3d01      	subs	r5, #1
			*((u16_t *)MROUND((u8_t *)head + sizeof(head))) =
   1ce94:	8015      	strh	r5, [r2, #0]
				free_count;
		}

		*mem_head = head;
   1ce96:	6033      	str	r3, [r6, #0]
		return mem;
	}

	return NULL;
}
   1ce98:	4620      	mov	r0, r4
   1ce9a:	b002      	add	sp, #8
   1ce9c:	bd70      	pop	{r4, r5, r6, pc}

0001ce9e <mem_release>:

void mem_release(void *mem, void **mem_head)
{
   1ce9e:	b570      	push	{r4, r5, r6, lr}
	u16_t free_count = 0U;

	/* Get the free count from the list and increment it */
	if (*mem_head) {
   1cea0:	680c      	ldr	r4, [r1, #0]
{
   1cea2:	4606      	mov	r6, r0
   1cea4:	460d      	mov	r5, r1
	if (*mem_head) {
   1cea6:	b11c      	cbz	r4, 1ceb0 <mem_release+0x12>
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
   1cea8:	1de3      	adds	r3, r4, #7
   1ceaa:	f023 0303 	bic.w	r3, r3, #3
   1ceae:	881c      	ldrh	r4, [r3, #0]
					       sizeof(mem_head)));
	}
	free_count++;

	memcpy(mem, mem_head, sizeof(mem));
   1ceb0:	2204      	movs	r2, #4
   1ceb2:	4629      	mov	r1, r5
   1ceb4:	4630      	mov	r0, r6
   1ceb6:	f7fe f8a0 	bl	1affa <memcpy>

	/* Store free mem_count after the list's next pointer */
	*((u16_t *)MROUND((u8_t *)mem + sizeof(mem))) = free_count;
   1ceba:	1df2      	adds	r2, r6, #7
   1cebc:	f022 0203 	bic.w	r2, r2, #3
	free_count++;
   1cec0:	1c63      	adds	r3, r4, #1
	*((u16_t *)MROUND((u8_t *)mem + sizeof(mem))) = free_count;
   1cec2:	8013      	strh	r3, [r2, #0]

	*mem_head = mem;
   1cec4:	602e      	str	r6, [r5, #0]
}
   1cec6:	bd70      	pop	{r4, r5, r6, pc}

0001cec8 <mem_get>:
}

void *mem_get(void *mem_pool, u16_t mem_size, u16_t index)
{
	return ((void *)((u8_t *)mem_pool + (mem_size * index)));
}
   1cec8:	fb02 0001 	mla	r0, r2, r1, r0
   1cecc:	4770      	bx	lr

0001cece <mem_index_get>:

u16_t mem_index_get(void *mem, void *mem_pool, u16_t mem_size)
{
	return ((u16_t)((u8_t *)mem - (u8_t *)mem_pool) / mem_size);
   1cece:	1a40      	subs	r0, r0, r1
   1ced0:	b280      	uxth	r0, r0
}
   1ced2:	fbb0 f0f2 	udiv	r0, r0, r2
   1ced6:	4770      	bx	lr

0001ced8 <mem_rcopy>:
/**
 * @brief  Copy bytes in reverse
 * @details Example: [ 0x11 0x22 0x33 ] -> [ 0x33 0x22 0x11 ]
 */
void mem_rcopy(u8_t *dst, u8_t const *src, u16_t len)
{
   1ced8:	b510      	push	{r4, lr}
	src += len;
   1ceda:	4411      	add	r1, r2
	while (len--) {
   1cedc:	3801      	subs	r0, #1
   1cede:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1cee2:	3a01      	subs	r2, #1
   1cee4:	b292      	uxth	r2, r2
   1cee6:	429a      	cmp	r2, r3
   1cee8:	d100      	bne.n	1ceec <mem_rcopy+0x14>
		*dst++ = *--src;
	}
}
   1ceea:	bd10      	pop	{r4, pc}
		*dst++ = *--src;
   1ceec:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
   1cef0:	f800 4f01 	strb.w	r4, [r0, #1]!
   1cef4:	e7f5      	b.n	1cee2 <mem_rcopy+0xa>

0001cef6 <mem_nz>:
 * @brief Determine if src[0..len-1] contains one or more non-zero bytes
 * @return 0 if all bytes are zero; otherwise 1
 */
u8_t mem_nz(u8_t *src, u16_t len)
{
	while (len--) {
   1cef6:	4401      	add	r1, r0
   1cef8:	4288      	cmp	r0, r1
   1cefa:	d101      	bne.n	1cf00 <mem_nz+0xa>
		if (*src++) {
			return 1;
		}
	}

	return 0;
   1cefc:	2000      	movs	r0, #0
   1cefe:	4770      	bx	lr
		if (*src++) {
   1cf00:	f810 3b01 	ldrb.w	r3, [r0], #1
   1cf04:	2b00      	cmp	r3, #0
   1cf06:	d0f7      	beq.n	1cef8 <mem_nz+0x2>
			return 1;
   1cf08:	2001      	movs	r0, #1
}
   1cf0a:	4770      	bx	lr

0001cf0c <memq_init>:
 * @return          Initial link-element
 */
memq_link_t *memq_init(memq_link_t *link, memq_link_t **head, memq_link_t **tail)
{
	/* Head and tail pointer to the initial link - forms an empty queue */
	*head = *tail = link;
   1cf0c:	6010      	str	r0, [r2, #0]
   1cf0e:	6008      	str	r0, [r1, #0]

	return link;
}
   1cf10:	4770      	bx	lr

0001cf12 <memq_deinit>:
memq_link_t *memq_deinit(memq_link_t **head, memq_link_t **tail)
{
	memq_link_t *old_head;

	/* If head and tail are not equal, then queue is not empty */
	if (*head != *tail) {
   1cf12:	6803      	ldr	r3, [r0, #0]
   1cf14:	680a      	ldr	r2, [r1, #0]
   1cf16:	4293      	cmp	r3, r2
   1cf18:	f04f 0200 	mov.w	r2, #0
		return NULL;
   1cf1c:	bf12      	itee	ne
   1cf1e:	4613      	movne	r3, r2
	}

	old_head = *head;
	*head = *tail = NULL;
   1cf20:	600a      	streq	r2, [r1, #0]
   1cf22:	6002      	streq	r2, [r0, #0]

	return old_head;
}
   1cf24:	4618      	mov	r0, r3
   1cf26:	4770      	bx	lr

0001cf28 <memq_enqueue>:
 * @param mem[in]      The memory payload to be enqueued. Pointed to by old tail
 * @param tail[in,out] Tail of queue. Will be updated to point to link
 * @return             New tail. Note: Does not point to the new mem
 */
memq_link_t *memq_enqueue(memq_link_t *link, void *mem, memq_link_t **tail)
{
   1cf28:	b510      	push	{r4, lr}
	/* Let the old tail element point to the new tail element */
	(*tail)->next = link;
   1cf2a:	6814      	ldr	r4, [r2, #0]
   1cf2c:	6020      	str	r0, [r4, #0]

	/* Let the old tail element point the the new memory */
	(*tail)->mem = mem;
   1cf2e:	6814      	ldr	r4, [r2, #0]
   1cf30:	6061      	str	r1, [r4, #4]

	/* Update the tail-pointer to point to the new tail element.
	 * The new tail-element is not expected to point to anything sensible
	 */
	*tail = link;
   1cf32:	6010      	str	r0, [r2, #0]

	return link;
}
   1cf34:	bd10      	pop	{r4, pc}

0001cf36 <memq_peek>:
 * @return         head or NULL if queue is empty
 */
memq_link_t *memq_peek(memq_link_t *head, memq_link_t *tail, void **mem)
{
	/* If head and tail are equal, then queue empty */
	if (head == tail) {
   1cf36:	4288      	cmp	r0, r1
   1cf38:	d003      	beq.n	1cf42 <memq_peek+0xc>
		return NULL;
	}

	/* Extract the head link-element's memory */
	if (mem) {
   1cf3a:	b11a      	cbz	r2, 1cf44 <memq_peek+0xe>
		*mem = head->mem;
   1cf3c:	6843      	ldr	r3, [r0, #4]
   1cf3e:	6013      	str	r3, [r2, #0]
   1cf40:	4770      	bx	lr
		return NULL;
   1cf42:	2000      	movs	r0, #0
	}

	return head; /* queue was not empty */
}
   1cf44:	4770      	bx	lr

0001cf46 <memq_dequeue>:
memq_link_t *memq_dequeue(memq_link_t *tail, memq_link_t **head, void **mem)
{
	memq_link_t *old_head;

	/* Use memq peek to get the old head and its mem */
	old_head = memq_peek(*head, tail, mem);
   1cf46:	680b      	ldr	r3, [r1, #0]
	if (head == tail) {
   1cf48:	4283      	cmp	r3, r0
   1cf4a:	d009      	beq.n	1cf60 <memq_dequeue+0x1a>
	if (mem) {
   1cf4c:	b122      	cbz	r2, 1cf58 <memq_dequeue+0x12>
		*mem = head->mem;
   1cf4e:	6858      	ldr	r0, [r3, #4]
   1cf50:	6010      	str	r0, [r2, #0]
	if (old_head == NULL) {
		return NULL; /* queue is empty */
	}

	/* Update the head-pointer to point to the new head element */
	*head = old_head->next;
   1cf52:	681a      	ldr	r2, [r3, #0]
   1cf54:	600a      	str	r2, [r1, #0]

	return old_head;
   1cf56:	e001      	b.n	1cf5c <memq_dequeue+0x16>
	if (old_head == NULL) {
   1cf58:	2b00      	cmp	r3, #0
   1cf5a:	d1fa      	bne.n	1cf52 <memq_dequeue+0xc>
}
   1cf5c:	4618      	mov	r0, r3
   1cf5e:	4770      	bx	lr
		return NULL; /* queue is empty */
   1cf60:	2300      	movs	r3, #0
   1cf62:	e7fb      	b.n	1cf5c <memq_dequeue+0x16>

0001cf64 <util_ones_count_get>:
 * @param octets_len Must not be bigger than 255/8 = 31 bytes
 *
 * @return popcnt of 'octets'
 */
u8_t util_ones_count_get(u8_t *octets, u8_t octets_len)
{
   1cf64:	b510      	push	{r4, lr}
   1cf66:	1e42      	subs	r2, r0, #1
	u8_t one_count = 0U;
   1cf68:	2000      	movs	r0, #0

	while (octets_len--) {
   1cf6a:	3901      	subs	r1, #1
   1cf6c:	b2c9      	uxtb	r1, r1
   1cf6e:	29ff      	cmp	r1, #255	; 0xff
   1cf70:	d100      	bne.n	1cf74 <util_ones_count_get+0x10>
		}
		octets++;
	}

	return one_count;
}
   1cf72:	bd10      	pop	{r4, pc}
		bite = *octets;
   1cf74:	f812 3f01 	ldrb.w	r3, [r2, #1]!
		while (bite) {
   1cf78:	2b00      	cmp	r3, #0
   1cf7a:	d0f6      	beq.n	1cf6a <util_ones_count_get+0x6>
			bite &= (bite - 1);
   1cf7c:	b25b      	sxtb	r3, r3
   1cf7e:	1e5c      	subs	r4, r3, #1
   1cf80:	4023      	ands	r3, r4
			one_count++;
   1cf82:	3001      	adds	r0, #1
			bite &= (bite - 1);
   1cf84:	b2db      	uxtb	r3, r3
			one_count++;
   1cf86:	b2c0      	uxtb	r0, r0
   1cf88:	e7f6      	b.n	1cf78 <util_ones_count_get+0x14>

0001cf8a <ticks_to_expire_prep>:
{
   1cf8a:	b530      	push	{r4, r5, lr}
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
   1cf8c:	1a55      	subs	r5, r2, r1
   1cf8e:	f415 0f00 	tst.w	r5, #8388608	; 0x800000
	u32_t ticks_to_expire = ticker->ticks_to_expire;
   1cf92:	6883      	ldr	r3, [r0, #8]
	u32_t ticks_to_expire_minus = ticker->ticks_to_expire_minus;
   1cf94:	6944      	ldr	r4, [r0, #20]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
   1cf96:	d109      	bne.n	1cfac <ticks_to_expire_prep+0x22>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   1cf98:	f025 427f 	bic.w	r2, r5, #4278190080	; 0xff000000
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
   1cf9c:	441a      	add	r2, r3
	if (ticks_to_expire > ticks_to_expire_minus) {
   1cf9e:	42a2      	cmp	r2, r4
   1cfa0:	d90e      	bls.n	1cfc0 <ticks_to_expire_prep+0x36>
		ticks_to_expire -= ticks_to_expire_minus;
   1cfa2:	1b12      	subs	r2, r2, r4
		ticks_to_expire_minus = 0U;
   1cfa4:	2400      	movs	r4, #0
	ticker->ticks_to_expire = ticks_to_expire;
   1cfa6:	6082      	str	r2, [r0, #8]
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
   1cfa8:	6144      	str	r4, [r0, #20]
}
   1cfaa:	bd30      	pop	{r4, r5, pc}
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   1cfac:	1a8a      	subs	r2, r1, r2
   1cfae:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
   1cfb2:	4293      	cmp	r3, r2
   1cfb4:	d901      	bls.n	1cfba <ticks_to_expire_prep+0x30>
			ticks_to_expire -= delta_current_start;
   1cfb6:	1a9a      	subs	r2, r3, r2
   1cfb8:	e7f1      	b.n	1cf9e <ticks_to_expire_prep+0x14>
			ticks_to_expire_minus +=
   1cfba:	4422      	add	r2, r4
   1cfbc:	1ad4      	subs	r4, r2, r3
			ticks_to_expire = 0U;
   1cfbe:	2200      	movs	r2, #0
		ticks_to_expire_minus -= ticks_to_expire;
   1cfc0:	1aa4      	subs	r4, r4, r2
		ticks_to_expire = 0U;
   1cfc2:	2200      	movs	r2, #0
   1cfc4:	e7ef      	b.n	1cfa6 <ticks_to_expire_prep+0x1c>

0001cfc6 <ticker_job_op_cb>:
{
   1cfc6:	4603      	mov	r3, r0
	user_op->op = TICKER_USER_OP_TYPE_NONE;
   1cfc8:	2200      	movs	r2, #0
   1cfca:	701a      	strb	r2, [r3, #0]
	if (user_op->fp_op_func) {
   1cfcc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	user_op->status = status;
   1cfce:	6259      	str	r1, [r3, #36]	; 0x24
{
   1cfd0:	4608      	mov	r0, r1
	if (user_op->fp_op_func) {
   1cfd2:	b10a      	cbz	r2, 1cfd8 <ticker_job_op_cb+0x12>
		user_op->fp_op_func(user_op->status, user_op->op_context);
   1cfd4:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
   1cfd6:	4710      	bx	r2
}
   1cfd8:	4770      	bx	lr

0001cfda <ticker_worker>:
{
   1cfda:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (instance->job_guard) {
   1cfde:	7f86      	ldrb	r6, [r0, #30]
	instance->worker_trigger = 1U;
   1cfe0:	2301      	movs	r3, #1
{
   1cfe2:	b08b      	sub	sp, #44	; 0x2c
   1cfe4:	4605      	mov	r5, r0
	instance->worker_trigger = 1U;
   1cfe6:	77c3      	strb	r3, [r0, #31]
	if (instance->job_guard) {
   1cfe8:	b91e      	cbnz	r6, 1cff2 <ticker_worker+0x18>
	if (instance->ticker_id_head == TICKER_NULL) {
   1cfea:	7f43      	ldrb	r3, [r0, #29]
   1cfec:	2bff      	cmp	r3, #255	; 0xff
   1cfee:	d103      	bne.n	1cff8 <ticker_worker+0x1e>
		instance->worker_trigger = 0U;
   1cff0:	77c6      	strb	r6, [r0, #31]
}
   1cff2:	b00b      	add	sp, #44	; 0x2c
   1cff4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ticks_elapsed = ticker_ticks_diff_get(cntr_cnt_get(),
   1cff8:	f7f8 fce8 	bl	159cc <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   1cffc:	696b      	ldr	r3, [r5, #20]
	ticker_id_head = instance->ticker_id_head;
   1cffe:	f895 801d 	ldrb.w	r8, [r5, #29]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   1d002:	1ac0      	subs	r0, r0, r3
	if (instance->ticker_id_slot_previous != TICKER_NULL) {
   1d004:	7f2b      	ldrb	r3, [r5, #28]
   1d006:	2bff      	cmp	r3, #255	; 0xff
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   1d008:	f020 497f 	bic.w	r9, r0, #4278190080	; 0xff000000
	if (instance->ticker_id_slot_previous != TICKER_NULL) {
   1d00c:	d027      	beq.n	1d05e <ticker_worker+0x84>
		if (instance->ticks_slot_previous > ticks_elapsed) {
   1d00e:	69ae      	ldr	r6, [r5, #24]
	u8_t slot_reserved = 0;
   1d010:	454e      	cmp	r6, r9
   1d012:	bf94      	ite	ls
   1d014:	2300      	movls	r3, #0
   1d016:	2301      	movhi	r3, #1
   1d018:	9301      	str	r3, [sp, #4]
	node = &instance->nodes[0];
   1d01a:	f8d5 a000 	ldr.w	sl, [r5]
	ticks_expired = 0U;
   1d01e:	f04f 0b00 	mov.w	fp, #0
	while (ticker_id_head != TICKER_NULL) {
   1d022:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
   1d026:	d11c      	bne.n	1d062 <ticker_worker+0x88>
	if (instance->ticks_elapsed_first == instance->ticks_elapsed_last) {
   1d028:	7aea      	ldrb	r2, [r5, #11]
   1d02a:	7aab      	ldrb	r3, [r5, #10]
   1d02c:	4293      	cmp	r3, r2
   1d02e:	d105      	bne.n	1d03c <ticker_worker+0x62>
	u8_t idx = *ticks_elapsed_index + 1;
   1d030:	3301      	adds	r3, #1
   1d032:	b2db      	uxtb	r3, r3
		idx = 0U;
   1d034:	2b02      	cmp	r3, #2
   1d036:	bf08      	it	eq
   1d038:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
   1d03a:	72eb      	strb	r3, [r5, #11]
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   1d03c:	7aeb      	ldrb	r3, [r5, #11]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   1d03e:	6a6c      	ldr	r4, [r5, #36]	; 0x24
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   1d040:	eb05 0383 	add.w	r3, r5, r3, lsl #2
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   1d044:	2201      	movs	r2, #1
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   1d046:	f8c3 b00c 	str.w	fp, [r3, #12]
	instance->worker_trigger = 0U;
   1d04a:	2300      	movs	r3, #0
   1d04c:	77eb      	strb	r3, [r5, #31]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   1d04e:	2104      	movs	r1, #4
   1d050:	462b      	mov	r3, r5
   1d052:	2003      	movs	r0, #3
   1d054:	46a4      	mov	ip, r4
}
   1d056:	b00b      	add	sp, #44	; 0x2c
   1d058:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   1d05c:	4760      	bx	ip
	u8_t slot_reserved = 0;
   1d05e:	9601      	str	r6, [sp, #4]
   1d060:	e7db      	b.n	1d01a <ticker_worker+0x40>
		ticker = &node[ticker_id_head];
   1d062:	232c      	movs	r3, #44	; 0x2c
   1d064:	fb18 f803 	smulbb	r8, r8, r3
   1d068:	eb0a 0408 	add.w	r4, sl, r8
		ticks_to_expire = ticker->ticks_to_expire;
   1d06c:	68a3      	ldr	r3, [r4, #8]
		if (ticks_elapsed < ticks_to_expire) {
   1d06e:	4599      	cmp	r9, r3
   1d070:	d3da      	bcc.n	1d028 <ticker_worker+0x4e>
		if (ticker->ticks_slot != 0U &&
   1d072:	69a7      	ldr	r7, [r4, #24]
		ticker_id_head = ticker->next;
   1d074:	f81a 8008 	ldrb.w	r8, [sl, r8]
		ticks_elapsed -= ticks_to_expire;
   1d078:	eba9 0903 	sub.w	r9, r9, r3
		ticks_expired += ticks_to_expire;
   1d07c:	449b      	add	fp, r3
		if (ticker->ticks_slot != 0U &&
   1d07e:	b35f      	cbz	r7, 1d0d8 <ticker_worker+0xfe>
   1d080:	8be3      	ldrh	r3, [r4, #30]
   1d082:	461e      	mov	r6, r3
   1d084:	9b01      	ldr	r3, [sp, #4]
   1d086:	2b00      	cmp	r3, #0
   1d088:	f040 8083 	bne.w	1d192 <ticker_worker+0x1b8>
	if (ticker->lazy_periodic > lazy_current) {
   1d08c:	8ba2      	ldrh	r2, [r4, #28]
   1d08e:	4296      	cmp	r6, r2
   1d090:	d37f      	bcc.n	1d192 <ticker_worker+0x1b8>
	} else if ((ticker->priority != TICKER_PRIORITY_CRITICAL) &&
   1d092:	f994 3029 	ldrsb.w	r3, [r4, #41]	; 0x29
   1d096:	9302      	str	r3, [sp, #8]
   1d098:	3380      	adds	r3, #128	; 0x80
   1d09a:	d01c      	beq.n	1d0d6 <ticker_worker+0xfc>
   1d09c:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
   1d0a0:	f000 8088 	beq.w	1d1b4 <ticker_worker+0x1da>
		u32_t acc_ticks_to_expire = 0;
   1d0a4:	9901      	ldr	r1, [sp, #4]
		u32_t current_age = ticker->ticks_periodic +
   1d0a6:	6863      	ldr	r3, [r4, #4]
		u32_t acc_ticks_to_expire = 0;
   1d0a8:	9104      	str	r1, [sp, #16]
				(lazy_current - ticker->priority);
   1d0aa:	9902      	ldr	r1, [sp, #8]
			lazy_current -= ticker->lazy_periodic;
   1d0ac:	1ab2      	subs	r2, r6, r2
		u32_t current_age = ticker->ticks_periodic +
   1d0ae:	fb02 3303 	mla	r3, r2, r3, r3
				(lazy_current - ticker->priority);
   1d0b2:	1a52      	subs	r2, r2, r1
		u32_t current_age = ticker->ticks_periodic +
   1d0b4:	9306      	str	r3, [sp, #24]
				(lazy_current - ticker->priority);
   1d0b6:	9209      	str	r2, [sp, #36]	; 0x24
		u32_t current_age = ticker->ticks_periodic +
   1d0b8:	4643      	mov	r3, r8
			struct ticker_node *ticker_next = &nodes[id_head];
   1d0ba:	222c      	movs	r2, #44	; 0x2c
   1d0bc:	fb13 f302 	smulbb	r3, r3, r2
   1d0c0:	eb0a 0e03 	add.w	lr, sl, r3
   1d0c4:	9305      	str	r3, [sp, #20]
			if (ticker_next->ticks_slot == 0) {
   1d0c6:	f8de 3018 	ldr.w	r3, [lr, #24]
   1d0ca:	bb4b      	cbnz	r3, 1d120 <ticker_worker+0x146>
			id_head = ticker_next->next;
   1d0cc:	9b05      	ldr	r3, [sp, #20]
   1d0ce:	f81a 3003 	ldrb.w	r3, [sl, r3]
		while (id_head != TICKER_NULL) {
   1d0d2:	2bff      	cmp	r3, #255	; 0xff
   1d0d4:	d1f1      	bne.n	1d0ba <ticker_worker+0xe0>
		must_expire_skip = 0U;
   1d0d6:	2700      	movs	r7, #0
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
   1d0d8:	78a2      	ldrb	r2, [r4, #2]
   1d0da:	7863      	ldrb	r3, [r4, #1]
   1d0dc:	1a9b      	subs	r3, r3, r2
   1d0de:	b2db      	uxtb	r3, r3
   1d0e0:	2b01      	cmp	r3, #1
   1d0e2:	d19e      	bne.n	1d022 <ticker_worker+0x48>
		if (ticker->timeout_func) {
   1d0e4:	68e3      	ldr	r3, [r4, #12]
		ticker->ack--;
   1d0e6:	3a01      	subs	r2, #1
   1d0e8:	70a2      	strb	r2, [r4, #2]
		if (ticker->timeout_func) {
   1d0ea:	461e      	mov	r6, r3
   1d0ec:	2b00      	cmp	r3, #0
   1d0ee:	d098      	beq.n	1d022 <ticker_worker+0x48>
					   ticks_expired -
   1d0f0:	6960      	ldr	r0, [r4, #20]
   1d0f2:	696b      	ldr	r3, [r5, #20]
			ticker->timeout_func(ticks_at_expire,
   1d0f4:	6a61      	ldr	r1, [r4, #36]	; 0x24
					   ticks_expired -
   1d0f6:	ebab 0000 	sub.w	r0, fp, r0
   1d0fa:	4418      	add	r0, r3
			ticks_at_expire = (instance->ticks_current +
   1d0fc:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticker->timeout_func(ticks_at_expire,
   1d100:	2f00      	cmp	r7, #0
   1d102:	d159      	bne.n	1d1b8 <ticker_worker+0x1de>
   1d104:	8be2      	ldrh	r2, [r4, #30]
   1d106:	6923      	ldr	r3, [r4, #16]
   1d108:	47b0      	blx	r6
			if (must_expire_skip == 0U) {
   1d10a:	2f00      	cmp	r7, #0
   1d10c:	d189      	bne.n	1d022 <ticker_worker+0x48>
				if (ticker->ticks_slot != 0U) {
   1d10e:	69a3      	ldr	r3, [r4, #24]
				ticker->lazy_current = 0U;
   1d110:	83e7      	strh	r7, [r4, #30]
					slot_reserved = 1U;
   1d112:	2b00      	cmp	r3, #0
   1d114:	9b01      	ldr	r3, [sp, #4]
				ticker->force = 0U;
   1d116:	70e7      	strb	r7, [r4, #3]
					slot_reserved = 1U;
   1d118:	bf18      	it	ne
   1d11a:	2301      	movne	r3, #1
   1d11c:	9301      	str	r3, [sp, #4]
   1d11e:	e780      	b.n	1d022 <ticker_worker+0x48>
			s32_t lazy_next = ticker_next->lazy_current;
   1d120:	f8be 001e 	ldrh.w	r0, [lr, #30]
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   1d124:	9a04      	ldr	r2, [sp, #16]
				ticker_next->lazy_periodic > lazy_next;
   1d126:	f8be c01c 	ldrh.w	ip, [lr, #28]
				ticker_next->priority;
   1d12a:	f99e 1029 	ldrsb.w	r1, [lr, #41]	; 0x29
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   1d12e:	f8de 3008 	ldr.w	r3, [lr, #8]
				ticker_next->priority;
   1d132:	9103      	str	r1, [sp, #12]
			u32_t next_age = (ticker_next->ticks_periodic == 0U ?
   1d134:	f8de 1004 	ldr.w	r1, [lr, #4]
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   1d138:	441a      	add	r2, r3
			if (!lazy_next_periodic_skip) {
   1d13a:	4560      	cmp	r0, ip
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   1d13c:	9204      	str	r2, [sp, #16]
			s32_t lazy_next = ticker_next->lazy_current;
   1d13e:	4602      	mov	r2, r0
				lazy_next -= ticker_next->lazy_periodic;
   1d140:	bf28      	it	cs
   1d142:	eba0 020c 	subcs.w	r2, r0, ip
					  0U :
   1d146:	2900      	cmp	r1, #0
   1d148:	d032      	beq.n	1d1b0 <ticker_worker+0x1d6>
   1d14a:	1acb      	subs	r3, r1, r3
   1d14c:	9307      	str	r3, [sp, #28]
			u8_t next_force = (ticker_next->force > ticker->force);
   1d14e:	f89e 3003 	ldrb.w	r3, [lr, #3]
   1d152:	9308      	str	r3, [sp, #32]
			if (!lazy_next_periodic_skip &&
   1d154:	4560      	cmp	r0, ip
			u8_t next_force = (ticker_next->force > ticker->force);
   1d156:	f894 e003 	ldrb.w	lr, [r4, #3]
			if (!lazy_next_periodic_skip &&
   1d15a:	d3b7      	bcc.n	1d0cc <ticker_worker+0xf2>
   1d15c:	9b04      	ldr	r3, [sp, #16]
   1d15e:	429f      	cmp	r7, r3
   1d160:	d9b4      	bls.n	1d0cc <ticker_worker+0xf2>
			    (acc_ticks_to_expire < ticker->ticks_slot) &&
   1d162:	9b08      	ldr	r3, [sp, #32]
   1d164:	4573      	cmp	r3, lr
   1d166:	d814      	bhi.n	1d192 <ticker_worker+0x1b8>
			    (next_force ||
   1d168:	9b03      	ldr	r3, [sp, #12]
   1d16a:	3380      	adds	r3, #128	; 0x80
   1d16c:	d011      	beq.n	1d192 <ticker_worker+0x1b8>
			u32_t next_age = (ticker_next->ticks_periodic == 0U ?
   1d16e:	9b07      	ldr	r3, [sp, #28]
   1d170:	fb01 3302 	mla	r3, r1, r2, r3
				(lazy_next - ticker_next->priority) >
   1d174:	9903      	ldr	r1, [sp, #12]
   1d176:	1a52      	subs	r2, r2, r1
			     next_is_critical ||
   1d178:	9909      	ldr	r1, [sp, #36]	; 0x24
   1d17a:	428a      	cmp	r2, r1
   1d17c:	dd02      	ble.n	1d184 <ticker_worker+0x1aa>
			    (next_has_priority && !current_is_older) ||
   1d17e:	9a06      	ldr	r2, [sp, #24]
   1d180:	429a      	cmp	r2, r3
   1d182:	d906      	bls.n	1d192 <ticker_worker+0x1b8>
   1d184:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
   1d188:	428a      	cmp	r2, r1
   1d18a:	d19f      	bne.n	1d0cc <ticker_worker+0xf2>
			    (equal_priority && next_is_older))) {
   1d18c:	9a06      	ldr	r2, [sp, #24]
   1d18e:	429a      	cmp	r2, r3
   1d190:	d29c      	bcs.n	1d0cc <ticker_worker+0xf2>
			ticker->lazy_current++;
   1d192:	4633      	mov	r3, r6
   1d194:	3301      	adds	r3, #1
			if ((ticker->must_expire == 0U) ||
   1d196:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
			ticker->lazy_current++;
   1d19a:	b29b      	uxth	r3, r3
   1d19c:	83e3      	strh	r3, [r4, #30]
			if ((ticker->must_expire == 0U) ||
   1d19e:	2a00      	cmp	r2, #0
   1d1a0:	f43f af3f 	beq.w	1d022 <ticker_worker+0x48>
   1d1a4:	8ba2      	ldrh	r2, [r4, #28]
   1d1a6:	429a      	cmp	r2, r3
   1d1a8:	f4bf af3b 	bcs.w	1d022 <ticker_worker+0x48>
			must_expire_skip = 1U;
   1d1ac:	2701      	movs	r7, #1
   1d1ae:	e793      	b.n	1d0d8 <ticker_worker+0xfe>
					  0U :
   1d1b0:	9107      	str	r1, [sp, #28]
   1d1b2:	e7cc      	b.n	1d14e <ticker_worker+0x174>
		must_expire_skip = 0U;
   1d1b4:	9f01      	ldr	r7, [sp, #4]
   1d1b6:	e78f      	b.n	1d0d8 <ticker_worker+0xfe>
			ticker->timeout_func(ticks_at_expire,
   1d1b8:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1d1bc:	e7a3      	b.n	1d106 <ticker_worker+0x12c>

0001d1be <ticker_ticks_now_get>:
	return cntr_cnt_get();
   1d1be:	f7f8 bc05 	b.w	159cc <cntr_cnt_get>

0001d1c2 <ticker_ticks_diff_get>:
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   1d1c2:	1a40      	subs	r0, r0, r1
}
   1d1c4:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   1d1c8:	4770      	bx	lr

0001d1ca <ll_tx_pwr_lvl_get>:
#include "ull_conn_internal.h"

u8_t ll_tx_pwr_lvl_get(u8_t handle_type,
		       u16_t handle, u8_t type, s8_t *tx_pwr_lvl)
{
	switch (handle_type) {
   1d1ca:	2802      	cmp	r0, #2
{
   1d1cc:	b538      	push	{r3, r4, r5, lr}
   1d1ce:	4604      	mov	r4, r0
   1d1d0:	461d      	mov	r5, r3
	switch (handle_type) {
   1d1d2:	d107      	bne.n	1d1e4 <ll_tx_pwr_lvl_get+0x1a>
#endif /* CONFIG_BT_OBSERVER && CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL*/
#if defined(CONFIG_BT_CONN)
		case (BT_HCI_VS_LL_HANDLE_TYPE_CONN): {
			struct ll_conn *conn;

			conn = ll_connected_get(handle);
   1d1d4:	4608      	mov	r0, r1
   1d1d6:	f000 fa25 	bl	1d624 <ll_connected_get>
			if (!conn) {
   1d1da:	b108      	cbz	r0, 1d1e0 <ll_tx_pwr_lvl_get+0x16>
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
				/* Level desired is maximum available */
				*tx_pwr_lvl = lll_radio_tx_pwr_max_get();
#else  /* !CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */
				/* Return default if not multiple TXP */
				*tx_pwr_lvl = RADIO_TXP_DEFAULT;
   1d1dc:	2400      	movs	r4, #0
   1d1de:	702c      	strb	r4, [r5, #0]
			return BT_HCI_ERR_UNKNOWN_CMD;
		}
	}

	return BT_HCI_ERR_SUCCESS;
}
   1d1e0:	4620      	mov	r0, r4
   1d1e2:	bd38      	pop	{r3, r4, r5, pc}
			return BT_HCI_ERR_UNKNOWN_CMD;
   1d1e4:	2401      	movs	r4, #1
   1d1e6:	e7fb      	b.n	1d1e0 <ll_tx_pwr_lvl_get+0x16>

0001d1e8 <ll_tx_pwr_get>:
{
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	*min = lll_radio_tx_pwr_min_get();
	*max = lll_radio_tx_pwr_max_get();
#else
	*min = RADIO_TXP_DEFAULT;
   1d1e8:	2300      	movs	r3, #0
   1d1ea:	7003      	strb	r3, [r0, #0]
	*max = RADIO_TXP_DEFAULT;
   1d1ec:	700b      	strb	r3, [r1, #0]
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */
}
   1d1ee:	4770      	bx	lr

0001d1f0 <sys_put_le32>:
	dst[1] = val >> 8;
   1d1f0:	f3c0 2307 	ubfx	r3, r0, #8, #8
	dst[0] = val;
   1d1f4:	7008      	strb	r0, [r1, #0]
	sys_put_le16(val >> 16, &dst[2]);
   1d1f6:	0c00      	lsrs	r0, r0, #16
	dst[0] = val;
   1d1f8:	7088      	strb	r0, [r1, #2]
	dst[1] = val >> 8;
   1d1fa:	0a00      	lsrs	r0, r0, #8
   1d1fc:	704b      	strb	r3, [r1, #1]
   1d1fe:	70c8      	strb	r0, [r1, #3]
}
   1d200:	4770      	bx	lr

0001d202 <sys_get_le64>:
{
   1d202:	4603      	mov	r3, r0
}
   1d204:	6800      	ldr	r0, [r0, #0]
   1d206:	6859      	ldr	r1, [r3, #4]
   1d208:	4770      	bx	lr

0001d20a <hci_evt_create>:
{
   1d20a:	b538      	push	{r3, r4, r5, lr}
	hdr = net_buf_add(buf, sizeof(*hdr));
   1d20c:	3008      	adds	r0, #8
{
   1d20e:	460d      	mov	r5, r1
	hdr = net_buf_add(buf, sizeof(*hdr));
   1d210:	2102      	movs	r1, #2
{
   1d212:	4614      	mov	r4, r2
	hdr = net_buf_add(buf, sizeof(*hdr));
   1d214:	f000 fd1a 	bl	1dc4c <net_buf_simple_add>
	hdr->evt = evt;
   1d218:	7005      	strb	r5, [r0, #0]
	hdr->len = len;
   1d21a:	7044      	strb	r4, [r0, #1]
}
   1d21c:	bd38      	pop	{r3, r4, r5, pc}

0001d21e <meta_evt>:
{
   1d21e:	b570      	push	{r4, r5, r6, lr}
   1d220:	4604      	mov	r4, r0
   1d222:	4615      	mov	r5, r2
	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
   1d224:	3201      	adds	r2, #1
{
   1d226:	460e      	mov	r6, r1
	me = net_buf_add(buf, sizeof(*me));
   1d228:	3408      	adds	r4, #8
	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
   1d22a:	b2d2      	uxtb	r2, r2
   1d22c:	213e      	movs	r1, #62	; 0x3e
   1d22e:	f7ff ffec 	bl	1d20a <hci_evt_create>
	me = net_buf_add(buf, sizeof(*me));
   1d232:	2101      	movs	r1, #1
   1d234:	4620      	mov	r0, r4
   1d236:	f000 fd09 	bl	1dc4c <net_buf_simple_add>
	me->subevent = subevt;
   1d23a:	7006      	strb	r6, [r0, #0]
	return net_buf_add(buf, melen);
   1d23c:	4629      	mov	r1, r5
   1d23e:	4620      	mov	r0, r4
}
   1d240:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return net_buf_add(buf, melen);
   1d244:	f000 bd02 	b.w	1dc4c <net_buf_simple_add>

0001d248 <hci_num_cmplt_encode>:
{
   1d248:	b570      	push	{r4, r5, r6, lr}
   1d24a:	4606      	mov	r6, r0
   1d24c:	460d      	mov	r5, r1
   1d24e:	4614      	mov	r4, r2
	hci_evt_create(buf, BT_HCI_EVT_NUM_COMPLETED_PACKETS, len);
   1d250:	2113      	movs	r1, #19
   1d252:	2205      	movs	r2, #5
   1d254:	f7ff ffd9 	bl	1d20a <hci_evt_create>
	ep = net_buf_add(buf, len);
   1d258:	2105      	movs	r1, #5
   1d25a:	f106 0008 	add.w	r0, r6, #8
   1d25e:	f000 fcf5 	bl	1dc4c <net_buf_simple_add>
	ep->num_handles = num_handles;
   1d262:	2301      	movs	r3, #1
   1d264:	7003      	strb	r3, [r0, #0]
	hc->handle = sys_cpu_to_le16(handle);
   1d266:	f8a0 5001 	strh.w	r5, [r0, #1]
	hc->count = sys_cpu_to_le16(num);
   1d26a:	f8a0 4003 	strh.w	r4, [r0, #3]
}
   1d26e:	bd70      	pop	{r4, r5, r6, pc}

0001d270 <hci_get_class>:
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   1d270:	7903      	ldrb	r3, [r0, #4]
   1d272:	2b02      	cmp	r3, #2
   1d274:	d007      	beq.n	1d286 <hci_get_class+0x16>
		switch (node_rx->hdr.type) {
   1d276:	2b08      	cmp	r3, #8
   1d278:	d00e      	beq.n	1d298 <hci_get_class+0x28>
   1d27a:	d30f      	bcc.n	1d29c <hci_get_class+0x2c>
   1d27c:	2b0e      	cmp	r3, #14
			return HCI_CLASS_EVT_CONNECTION;
   1d27e:	bf8c      	ite	hi
   1d280:	2000      	movhi	r0, #0
   1d282:	2003      	movls	r0, #3
   1d284:	4770      	bx	lr
	} else if (pdu_data->ll_id == PDU_DATA_LLID_CTRL) {
   1d286:	f890 3020 	ldrb.w	r3, [r0, #32]
   1d28a:	f003 0303 	and.w	r3, r3, #3
   1d28e:	2b03      	cmp	r3, #3
		return HCI_CLASS_ACL_DATA;
   1d290:	bf0c      	ite	eq
   1d292:	2004      	moveq	r0, #4
   1d294:	2005      	movne	r0, #5
   1d296:	4770      	bx	lr
			return HCI_CLASS_EVT_REQUIRED;
   1d298:	2001      	movs	r0, #1
   1d29a:	4770      	bx	lr
			return HCI_CLASS_NONE;
   1d29c:	2000      	movs	r0, #0
}
   1d29e:	4770      	bx	lr

0001d2a0 <bt_encrypt_le>:

int bt_encrypt_le(const u8_t key[16], const u8_t plaintext[16],
		  u8_t enc_data[16])
{
   1d2a0:	b508      	push	{r3, lr}
	BT_DBG("key %s", bt_hex(key, 16));
	BT_DBG("plaintext %s", bt_hex(plaintext, 16));

	ecb_encrypt(key, plaintext, enc_data, NULL);
   1d2a2:	2300      	movs	r3, #0
   1d2a4:	f000 fc52 	bl	1db4c <ecb_encrypt>

	BT_DBG("enc_data %s", bt_hex(enc_data, 16));

	return 0;
}
   1d2a8:	2000      	movs	r0, #0
   1d2aa:	bd08      	pop	{r3, pc}

0001d2ac <disabled_cb>:
   1d2ac:	f7fb b8ea 	b.w	18484 <z_impl_k_sem_give>

0001d2b0 <rx_demux_conn_tx_ack>:
{
   1d2b0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1d2b2:	4606      	mov	r6, r0
   1d2b4:	4614      	mov	r4, r2
   1d2b6:	9300      	str	r3, [sp, #0]
   1d2b8:	f8ad 1006 	strh.w	r1, [sp, #6]
		ull_conn_ack_dequeue();
   1d2bc:	f7f6 fe74 	bl	13fa8 <ull_conn_ack_dequeue>
		conn = ull_conn_tx_ack(handle, link, node_tx);
   1d2c0:	9a00      	ldr	r2, [sp, #0]
   1d2c2:	f8bd 0006 	ldrh.w	r0, [sp, #6]
   1d2c6:	4621      	mov	r1, r4
   1d2c8:	f7f6 feb2 	bl	14030 <ull_conn_tx_ack>
   1d2cc:	4605      	mov	r5, r0
		ull_conn_link_tx_release(link);
   1d2ce:	4620      	mov	r0, r4
   1d2d0:	f7f6 fe30 	bl	13f34 <ull_conn_link_tx_release>
		ull_conn_tx_demux(1);
   1d2d4:	2001      	movs	r0, #1
   1d2d6:	f7f6 fd2f 	bl	13d38 <ull_conn_tx_demux>
		if (conn) {
   1d2da:	b11d      	cbz	r5, 1d2e4 <rx_demux_conn_tx_ack+0x34>
			ull_conn_tx_lll_enqueue(conn, 1);
   1d2dc:	2101      	movs	r1, #1
   1d2de:	4628      	mov	r0, r5
   1d2e0:	f7f6 fd70 	bl	13dc4 <ull_conn_tx_lll_enqueue>
		link = ull_conn_ack_by_last_peek(ack_last, &handle, &node_tx);
   1d2e4:	466a      	mov	r2, sp
   1d2e6:	f10d 0106 	add.w	r1, sp, #6
   1d2ea:	4630      	mov	r0, r6
   1d2ec:	f7f6 fe46 	bl	13f7c <ull_conn_ack_by_last_peek>
	} while (link);
   1d2f0:	4604      	mov	r4, r0
   1d2f2:	2800      	cmp	r0, #0
   1d2f4:	d1e2      	bne.n	1d2bc <rx_demux_conn_tx_ack+0xc>
			ll_rx_sched();
   1d2f6:	f7f3 f82f 	bl	10358 <ll_rx_sched>
}
   1d2fa:	b002      	add	sp, #8
   1d2fc:	bd70      	pop	{r4, r5, r6, pc}

0001d2fe <ll_timeslice_ticker_id_get>:
	*instance_index = TICKER_INSTANCE_ID_CTLR;
   1d2fe:	2300      	movs	r3, #0
   1d300:	7003      	strb	r3, [r0, #0]
	*user_id = (TICKER_NODES - FLASH_TICKER_NODES);
   1d302:	2304      	movs	r3, #4
   1d304:	700b      	strb	r3, [r1, #0]
}
   1d306:	4770      	bx	lr

0001d308 <chan_sel_remap>:
{
   1d308:	b530      	push	{r4, r5, lr}
   1d30a:	1e42      	subs	r2, r0, #1
   1d30c:	1d03      	adds	r3, r0, #4
	chan_next = 0U;
   1d30e:	2000      	movs	r0, #0
	while (byte_count--) {
   1d310:	4293      	cmp	r3, r2
   1d312:	d100      	bne.n	1d316 <chan_sel_remap+0xe>
}
   1d314:	bd30      	pop	{r4, r5, pc}
		bite = *chan_map;
   1d316:	f100 0408 	add.w	r4, r0, #8
   1d31a:	f812 5f01 	ldrb.w	r5, [r2, #1]!
		while (bit_count--) {
   1d31e:	b2e4      	uxtb	r4, r4
   1d320:	4284      	cmp	r4, r0
   1d322:	d0f5      	beq.n	1d310 <chan_sel_remap+0x8>
			if (bite & 0x01) {
   1d324:	f015 0f01 	tst.w	r5, #1
   1d328:	d003      	beq.n	1d332 <chan_sel_remap+0x2a>
				if (chan_index == 0U) {
   1d32a:	2900      	cmp	r1, #0
   1d32c:	d0f2      	beq.n	1d314 <chan_sel_remap+0xc>
				chan_index--;
   1d32e:	3901      	subs	r1, #1
   1d330:	b2c9      	uxtb	r1, r1
			chan_next++;
   1d332:	3001      	adds	r0, #1
   1d334:	b2c0      	uxtb	r0, r0
			bite >>= 1;
   1d336:	086d      	lsrs	r5, r5, #1
   1d338:	e7f2      	b.n	1d320 <chan_sel_remap+0x18>

0001d33a <lll_chan_sel_1>:
{
   1d33a:	b430      	push	{r4, r5}
	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
   1d33c:	fb02 1101 	mla	r1, r2, r1, r1
   1d340:	7802      	ldrb	r2, [r0, #0]
{
   1d342:	f89d 5008 	ldrb.w	r5, [sp, #8]
	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
   1d346:	4411      	add	r1, r2
   1d348:	2425      	movs	r4, #37	; 0x25
   1d34a:	fbb1 f2f4 	udiv	r2, r1, r4
   1d34e:	fb04 1212 	mls	r2, r4, r2, r1
   1d352:	b2d1      	uxtb	r1, r2
	*chan_use = chan_next;
   1d354:	7001      	strb	r1, [r0, #0]
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
   1d356:	08c8      	lsrs	r0, r1, #3
   1d358:	f002 0207 	and.w	r2, r2, #7
   1d35c:	5c1c      	ldrb	r4, [r3, r0]
   1d35e:	fa44 f202 	asr.w	r2, r4, r2
   1d362:	07d2      	lsls	r2, r2, #31
   1d364:	d408      	bmi.n	1d378 <lll_chan_sel_1+0x3e>
		chan_index = chan_next % chan_count;
   1d366:	fbb1 f2f5 	udiv	r2, r1, r5
   1d36a:	fb05 1112 	mls	r1, r5, r2, r1
		chan_next = chan_sel_remap(chan_map, chan_index);
   1d36e:	b2c9      	uxtb	r1, r1
   1d370:	4618      	mov	r0, r3
}
   1d372:	bc30      	pop	{r4, r5}
		chan_next = chan_sel_remap(chan_map, chan_index);
   1d374:	f7ff bfc8 	b.w	1d308 <chan_sel_remap>
}
   1d378:	4608      	mov	r0, r1
   1d37a:	bc30      	pop	{r4, r5}
   1d37c:	4770      	bx	lr

0001d37e <clock_control_on>:
	return api->on(dev, sys);
   1d37e:	6843      	ldr	r3, [r0, #4]
   1d380:	681b      	ldr	r3, [r3, #0]
   1d382:	4718      	bx	r3

0001d384 <swi_lll_nrf5_isr>:
	mayfly_run(TICKER_USER_ID_LLL);
   1d384:	2000      	movs	r0, #0
   1d386:	f7f0 bbf9 	b.w	db7c <mayfly_run>

0001d38a <radio_nrf5_isr>:
ISR_DIRECT_DECLARE(radio_nrf5_isr)
   1d38a:	4668      	mov	r0, sp
   1d38c:	f020 0107 	bic.w	r1, r0, #7
   1d390:	468d      	mov	sp, r1
   1d392:	b501      	push	{r0, lr}
	isr_radio();
   1d394:	f7f8 fbce 	bl	15b34 <isr_radio>
	ISR_DIRECT_PM();
   1d398:	f7e7 f828 	bl	43ec <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING
	sys_trace_isr_exit();
#endif
	if (maybe_swap) {
		z_arm_int_exit();
   1d39c:	f7e6 ff7a 	bl	4294 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(radio_nrf5_isr)
   1d3a0:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   1d3a4:	4685      	mov	sp, r0
   1d3a6:	4770      	bx	lr

0001d3a8 <lll_reset>:
}
   1d3a8:	2000      	movs	r0, #0
   1d3aa:	4770      	bx	lr

0001d3ac <lll_prepare>:
{
   1d3ac:	b513      	push	{r0, r1, r4, lr}
	return prepare(is_abort_cb, abort_cb, prepare_cb, prio, prepare_param,
   1d3ae:	2400      	movs	r4, #0
   1d3b0:	9401      	str	r4, [sp, #4]
   1d3b2:	9c04      	ldr	r4, [sp, #16]
   1d3b4:	9400      	str	r4, [sp, #0]
   1d3b6:	f7f3 fb43 	bl	10a40 <prepare>
}
   1d3ba:	b002      	add	sp, #8
   1d3bc:	bd10      	pop	{r4, pc}

0001d3be <lll_prepare_done>:
}
   1d3be:	2000      	movs	r0, #0
   1d3c0:	4770      	bx	lr

0001d3c2 <lll_evt_offset_get>:
	} else if (evt->ticks_xtal_to_start & XON_BITMASK) {
   1d3c2:	e9d0 2300 	ldrd	r2, r3, [r0]
   1d3c6:	2a00      	cmp	r2, #0
   1d3c8:	da04      	bge.n	1d3d4 <lll_evt_offset_get+0x12>
		return MAX(evt->ticks_active_to_start,
   1d3ca:	6880      	ldr	r0, [r0, #8]
   1d3cc:	4298      	cmp	r0, r3
   1d3ce:	bf38      	it	cc
   1d3d0:	4618      	movcc	r0, r3
   1d3d2:	4770      	bx	lr
		return MAX(evt->ticks_active_to_start,
   1d3d4:	429a      	cmp	r2, r3
   1d3d6:	bf38      	it	cc
   1d3d8:	461a      	movcc	r2, r3
   1d3da:	4610      	mov	r0, r2
}
   1d3dc:	4770      	bx	lr

0001d3de <lll_preempt_calc>:
{
   1d3de:	b510      	push	{r4, lr}
   1d3e0:	4614      	mov	r4, r2
	u32_t ticks_now = ticker_ticks_now_get();
   1d3e2:	f7ff feec 	bl	1d1be <ticker_ticks_now_get>
	diff = ticker_ticks_diff_get(ticks_now, ticks_at_event);
   1d3e6:	4621      	mov	r1, r4
   1d3e8:	f7ff feeb 	bl	1d1c2 <ticker_ticks_diff_get>
	diff += HAL_TICKER_CNTR_CMP_OFFSET_MIN;
   1d3ec:	3003      	adds	r0, #3
	if (!(diff & BIT(HAL_TICKER_CNTR_MSBIT)) &&
   1d3ee:	0203      	lsls	r3, r0, #8
   1d3f0:	d404      	bmi.n	1d3fc <lll_preempt_calc+0x1e>
   1d3f2:	2809      	cmp	r0, #9
   1d3f4:	bf94      	ite	ls
   1d3f6:	2000      	movls	r0, #0
   1d3f8:	2001      	movhi	r0, #1
}
   1d3fa:	bd10      	pop	{r4, pc}
	return 0;
   1d3fc:	2000      	movs	r0, #0
   1d3fe:	e7fc      	b.n	1d3fa <lll_preempt_calc+0x1c>

0001d400 <ull_adv_init>:
}
   1d400:	2000      	movs	r0, #0
   1d402:	4770      	bx	lr

0001d404 <ull_adv_reset>:
{
   1d404:	b508      	push	{r3, lr}
		(void)disable(handle);
   1d406:	f7f4 f8a7 	bl	11558 <disable.constprop.5>
}
   1d40a:	2000      	movs	r0, #0
   1d40c:	bd08      	pop	{r3, pc}

0001d40e <ull_adv_is_enabled>:
{
   1d40e:	b508      	push	{r3, lr}
	adv = ull_adv_is_enabled_get(handle);
   1d410:	f7f4 f894 	bl	1153c <ull_adv_is_enabled_get>
}
   1d414:	3000      	adds	r0, #0
   1d416:	bf18      	it	ne
   1d418:	2001      	movne	r0, #1
   1d41a:	bd08      	pop	{r3, pc}

0001d41c <ull_adv_filter_pol_get>:
{
   1d41c:	b508      	push	{r3, lr}
	adv = ull_adv_is_enabled_get(handle);
   1d41e:	f7f4 f88d 	bl	1153c <ull_adv_is_enabled_get>
	if (!adv) {
   1d422:	b118      	cbz	r0, 1d42c <ull_adv_filter_pol_get+0x10>
	return adv->lll.filter_policy;
   1d424:	f890 0029 	ldrb.w	r0, [r0, #41]	; 0x29
   1d428:	f000 0003 	and.w	r0, r0, #3
}
   1d42c:	bd08      	pop	{r3, pc}

0001d42e <isr_race>:
	radio_status_reset();
   1d42e:	f7f8 bc6b 	b.w	15d08 <radio_status_reset>

0001d432 <isr_abort>:
{
   1d432:	b510      	push	{r4, lr}
   1d434:	4604      	mov	r4, r0
	radio_status_reset();
   1d436:	f7f8 fc67 	bl	15d08 <radio_status_reset>
	radio_tmr_status_reset();
   1d43a:	f7f8 fd23 	bl	15e84 <radio_tmr_status_reset>
	radio_filter_status_reset();
   1d43e:	f7f8 fcfd 	bl	15e3c <radio_filter_status_reset>
	radio_ar_status_reset();
   1d442:	f7f8 febd 	bl	161c0 <radio_ar_status_reset>
	radio_rssi_status_reset();
   1d446:	f7f8 fcc1 	bl	15dcc <radio_rssi_status_reset>
	radio_filter_disable();
   1d44a:	f7f8 fced 	bl	15e28 <radio_filter_disable>
	isr_cleanup(param);
   1d44e:	4620      	mov	r0, r4
}
   1d450:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   1d454:	f7f4 b912 	b.w	1167c <isr_cleanup>

0001d458 <isr_rx_ci_adva_check>:
		       BDADDR_SIZE);
}

static inline bool isr_rx_ci_adva_check(struct pdu_adv *adv,
					struct pdu_adv *ci)
{
   1d458:	b570      	push	{r4, r5, r6, lr}
	return (adv->tx_addr == ci->rx_addr) &&
   1d45a:	7804      	ldrb	r4, [r0, #0]
   1d45c:	780a      	ldrb	r2, [r1, #0]
   1d45e:	f3c4 1380 	ubfx	r3, r4, #6, #1
   1d462:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
   1d466:	d119      	bne.n	1d49c <isr_rx_ci_adva_check+0x44>
   1d468:	f004 040f 	and.w	r4, r4, #15
   1d46c:	2c01      	cmp	r4, #1
   1d46e:	f100 0502 	add.w	r5, r0, #2
   1d472:	f101 0608 	add.w	r6, r1, #8
   1d476:	d008      	beq.n	1d48a <isr_rx_ci_adva_check+0x32>
		(((adv->type == PDU_ADV_TYPE_DIRECT_IND) &&
		 !memcmp(adv->direct_ind.adv_addr, ci->connect_ind.adv_addr,
			 BDADDR_SIZE)) ||
		 (!memcmp(adv->adv_ind.addr, ci->connect_ind.adv_addr,
   1d478:	2206      	movs	r2, #6
   1d47a:	4631      	mov	r1, r6
   1d47c:	4628      	mov	r0, r5
   1d47e:	f7fd fdac 	bl	1afda <memcmp>
			 BDADDR_SIZE)) ||
   1d482:	fab0 f080 	clz	r0, r0
   1d486:	0940      	lsrs	r0, r0, #5
			  BDADDR_SIZE)));
}
   1d488:	bd70      	pop	{r4, r5, r6, pc}
		 !memcmp(adv->direct_ind.adv_addr, ci->connect_ind.adv_addr,
   1d48a:	2206      	movs	r2, #6
   1d48c:	4631      	mov	r1, r6
   1d48e:	4628      	mov	r0, r5
   1d490:	f7fd fda3 	bl	1afda <memcmp>
		(((adv->type == PDU_ADV_TYPE_DIRECT_IND) &&
   1d494:	2800      	cmp	r0, #0
   1d496:	d1ef      	bne.n	1d478 <isr_rx_ci_adva_check+0x20>
	return (adv->tx_addr == ci->rx_addr) &&
   1d498:	4620      	mov	r0, r4
   1d49a:	e7f5      	b.n	1d488 <isr_rx_ci_adva_check+0x30>
   1d49c:	2000      	movs	r0, #0
   1d49e:	e7f3      	b.n	1d488 <isr_rx_ci_adva_check+0x30>

0001d4a0 <resume_prepare_cb>:
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
   1d4a0:	68c3      	ldr	r3, [r0, #12]
{
   1d4a2:	b570      	push	{r4, r5, r6, lr}
   1d4a4:	4604      	mov	r4, r0
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
   1d4a6:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
   1d4a8:	f7ff fe89 	bl	1d1be <ticker_ticks_now_get>
   1d4ac:	4605      	mov	r5, r0
   1d4ae:	4630      	mov	r0, r6
   1d4b0:	f7ff ff87 	bl	1d3c2 <lll_evt_offset_get>
	p->remainder = 0;
   1d4b4:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
   1d4b6:	1a28      	subs	r0, r5, r0
   1d4b8:	6020      	str	r0, [r4, #0]
	p->remainder = 0;
   1d4ba:	6063      	str	r3, [r4, #4]
	p->lazy = 0;
   1d4bc:	8123      	strh	r3, [r4, #8]
	return prepare_cb(p);
   1d4be:	4620      	mov	r0, r4
}
   1d4c0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return prepare_cb(p);
   1d4c4:	f7f4 bba0 	b.w	11c08 <prepare_cb>

0001d4c8 <isr_done>:
{
   1d4c8:	b510      	push	{r4, lr}
   1d4ca:	4604      	mov	r4, r0
	radio_status_reset();
   1d4cc:	f7f8 fc1c 	bl	15d08 <radio_status_reset>
	radio_tmr_status_reset();
   1d4d0:	f7f8 fcd8 	bl	15e84 <radio_tmr_status_reset>
	radio_filter_status_reset();
   1d4d4:	f7f8 fcb2 	bl	15e3c <radio_filter_status_reset>
	radio_ar_status_reset();
   1d4d8:	f7f8 fe72 	bl	161c0 <radio_ar_status_reset>
	radio_rssi_status_reset();
   1d4dc:	f7f8 fc76 	bl	15dcc <radio_rssi_status_reset>
	if (!IS_ENABLED(CONFIG_BT_CTLR_LOW_LAT) && lll->is_hdcd &&
   1d4e0:	7b23      	ldrb	r3, [r4, #12]
   1d4e2:	f003 0271 	and.w	r2, r3, #113	; 0x71
   1d4e6:	2a01      	cmp	r2, #1
		lll->chan_map_curr = lll->chan_map;
   1d4e8:	bf02      	ittt	eq
   1d4ea:	f3c3 0242 	ubfxeq	r2, r3, #1, #3
   1d4ee:	f362 1306 	bfieq	r3, r2, #4, #3
   1d4f2:	7323      	strbeq	r3, [r4, #12]
	if (lll->chan_map_curr) {
   1d4f4:	7b23      	ldrb	r3, [r4, #12]
   1d4f6:	f013 0f70 	tst.w	r3, #112	; 0x70
   1d4fa:	d008      	beq.n	1d50e <isr_done+0x46>
		chan_prepare(lll);
   1d4fc:	4620      	mov	r0, r4
   1d4fe:	f7f4 fb01 	bl	11b04 <chan_prepare>
		radio_tx_enable();
   1d502:	f7f8 fbe9 	bl	15cd8 <radio_tx_enable>
}
   1d506:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_tmr_end_capture();
   1d50a:	f7f8 bd91 	b.w	16030 <radio_tmr_end_capture>
	radio_filter_disable();
   1d50e:	f7f8 fc8b 	bl	15e28 <radio_filter_disable>
	isr_cleanup(param);
   1d512:	4620      	mov	r0, r4
}
   1d514:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   1d518:	f7f4 b8b0 	b.w	1167c <isr_cleanup>

0001d51c <lll_adv_init>:
}
   1d51c:	2000      	movs	r0, #0
   1d51e:	4770      	bx	lr

0001d520 <lll_adv_reset>:
   1d520:	2000      	movs	r0, #0
   1d522:	4770      	bx	lr

0001d524 <tx_ull_dequeue>:
{
   1d524:	4603      	mov	r3, r0
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
   1d526:	e9d0 206c 	ldrd	r2, r0, [r0, #432]	; 0x1b0
{
   1d52a:	b510      	push	{r4, lr}
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
   1d52c:	b978      	cbnz	r0, 1d54e <tx_ull_dequeue+0x2a>
   1d52e:	f8d3 01bc 	ldr.w	r0, [r3, #444]	; 0x1bc
   1d532:	4290      	cmp	r0, r2
   1d534:	d00b      	beq.n	1d54e <tx_ull_dequeue+0x2a>
		if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   1d536:	7910      	ldrb	r0, [r2, #4]
   1d538:	f000 0003 	and.w	r0, r0, #3
   1d53c:	2803      	cmp	r0, #3
   1d53e:	d104      	bne.n	1d54a <tx_ull_dequeue+0x26>
		    ((pdu_data_tx->llctrl.opcode !=
   1d540:	79d0      	ldrb	r0, [r2, #7]
		if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   1d542:	2803      	cmp	r0, #3
   1d544:	d003      	beq.n	1d54e <tx_ull_dequeue+0x2a>
		      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   1d546:	280a      	cmp	r0, #10
   1d548:	d001      	beq.n	1d54e <tx_ull_dequeue+0x2a>
			conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   1d54a:	e9c3 226d 	strd	r2, r2, [r3, #436]	; 0x1b4
	if (conn->tx_head == conn->tx_ctrl) {
   1d54e:	f8d3 41b4 	ldr.w	r4, [r3, #436]	; 0x1b4
   1d552:	6810      	ldr	r0, [r2, #0]
   1d554:	4294      	cmp	r4, r2
   1d556:	d10d      	bne.n	1d574 <tx_ull_dequeue+0x50>
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
   1d558:	f8d3 41b8 	ldr.w	r4, [r3, #440]	; 0x1b8
		conn->tx_head = conn->tx_head->next;
   1d55c:	f8c3 01b0 	str.w	r0, [r3, #432]	; 0x1b0
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
   1d560:	42a2      	cmp	r2, r4
			conn->tx_ctrl = NULL;
   1d562:	bf06      	itte	eq
   1d564:	2200      	moveq	r2, #0
			conn->tx_ctrl_last = NULL;
   1d566:	e9c3 226d 	strdeq	r2, r2, [r3, #436]	; 0x1b4
			conn->tx_ctrl = conn->tx_head;
   1d56a:	f8c3 01b4 	strne.w	r0, [r3, #436]	; 0x1b4
		tx->next = tx;
   1d56e:	6009      	str	r1, [r1, #0]
}
   1d570:	4608      	mov	r0, r1
   1d572:	bd10      	pop	{r4, pc}
		if (conn->tx_head == conn->tx_data) {
   1d574:	f8d3 41bc 	ldr.w	r4, [r3, #444]	; 0x1bc
		conn->tx_head = conn->tx_head->next;
   1d578:	f8c3 01b0 	str.w	r0, [r3, #432]	; 0x1b0
		if (conn->tx_head == conn->tx_data) {
   1d57c:	4294      	cmp	r4, r2
			conn->tx_data = conn->tx_data->next;
   1d57e:	bf08      	it	eq
   1d580:	f8c3 01bc 	streq.w	r0, [r3, #444]	; 0x1bc
		tx->next = NULL;
   1d584:	2300      	movs	r3, #0
   1d586:	600b      	str	r3, [r1, #0]
   1d588:	e7f2      	b.n	1d570 <tx_ull_dequeue+0x4c>

0001d58a <ctrl_tx_sec_enqueue>:
	if (conn->llcp_enc.pause_tx) {
   1d58a:	f890 2152 	ldrb.w	r2, [r0, #338]	; 0x152
   1d58e:	f012 0202 	ands.w	r2, r2, #2
{
   1d592:	b430      	push	{r4, r5}
	if (conn->llcp_enc.pause_tx) {
   1d594:	d013      	beq.n	1d5be <ctrl_tx_sec_enqueue+0x34>
		if (!conn->tx_ctrl) {
   1d596:	f8d0 31b4 	ldr.w	r3, [r0, #436]	; 0x1b4
   1d59a:	b953      	cbnz	r3, 1d5b2 <ctrl_tx_sec_enqueue+0x28>
			tx->next = conn->tx_head;
   1d59c:	f8d0 31b0 	ldr.w	r3, [r0, #432]	; 0x1b0
   1d5a0:	600b      	str	r3, [r1, #0]
			conn->tx_head = tx;
   1d5a2:	f8c0 11b0 	str.w	r1, [r0, #432]	; 0x1b0
		if (!tx->next) {
   1d5a6:	680b      	ldr	r3, [r1, #0]
   1d5a8:	b90b      	cbnz	r3, 1d5ae <ctrl_tx_sec_enqueue+0x24>
			conn->tx_data_last = tx;
   1d5aa:	f8c0 11c0 	str.w	r1, [r0, #448]	; 0x1c0
}
   1d5ae:	bc30      	pop	{r4, r5}
   1d5b0:	4770      	bx	lr
			tx->next = conn->tx_ctrl_last->next;
   1d5b2:	f8d0 31b8 	ldr.w	r3, [r0, #440]	; 0x1b8
   1d5b6:	681a      	ldr	r2, [r3, #0]
   1d5b8:	600a      	str	r2, [r1, #0]
			conn->tx_ctrl_last->next = tx;
   1d5ba:	6019      	str	r1, [r3, #0]
   1d5bc:	e7f3      	b.n	1d5a6 <ctrl_tx_sec_enqueue+0x1c>
		if (conn->tx_head) {
   1d5be:	f8d0 31b0 	ldr.w	r3, [r0, #432]	; 0x1b0
   1d5c2:	b1c3      	cbz	r3, 1d5f6 <ctrl_tx_sec_enqueue+0x6c>
			if ((conn->llcp_req != conn->llcp_ack) &&
   1d5c4:	f890 50e8 	ldrb.w	r5, [r0, #232]	; 0xe8
   1d5c8:	f890 40e9 	ldrb.w	r4, [r0, #233]	; 0xe9
   1d5cc:	42a5      	cmp	r5, r4
   1d5ce:	d00f      	beq.n	1d5f0 <ctrl_tx_sec_enqueue+0x66>
   1d5d0:	f890 40ea 	ldrb.w	r4, [r0, #234]	; 0xea
   1d5d4:	2c03      	cmp	r4, #3
   1d5d6:	d10b      	bne.n	1d5f0 <ctrl_tx_sec_enqueue+0x66>
			    (pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
   1d5d8:	791c      	ldrb	r4, [r3, #4]
			    (conn->llcp_type == LLCP_ENCRYPTION) &&
   1d5da:	f004 0403 	and.w	r4, r4, #3
   1d5de:	2c03      	cmp	r4, #3
   1d5e0:	d106      	bne.n	1d5f0 <ctrl_tx_sec_enqueue+0x66>
			    ((pdu_data_tx->llctrl.opcode ==
   1d5e2:	79da      	ldrb	r2, [r3, #7]
			    (pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
   1d5e4:	2a03      	cmp	r2, #3
   1d5e6:	d008      	beq.n	1d5fa <ctrl_tx_sec_enqueue+0x70>
			      PDU_DATA_LLCTRL_TYPE_ENC_REQ) ||
   1d5e8:	f1a2 030a 	sub.w	r3, r2, #10
   1d5ec:	425a      	negs	r2, r3
   1d5ee:	415a      	adcs	r2, r3
}
   1d5f0:	bc30      	pop	{r4, r5}
		ctrl_tx_pause_enqueue(conn, tx, pause);
   1d5f2:	f7f4 bdc5 	b.w	12180 <ctrl_tx_pause_enqueue>
	bool pause = false;
   1d5f6:	461a      	mov	r2, r3
   1d5f8:	e7fa      	b.n	1d5f0 <ctrl_tx_sec_enqueue+0x66>
				pause = true;
   1d5fa:	2201      	movs	r2, #1
   1d5fc:	e7f8      	b.n	1d5f0 <ctrl_tx_sec_enqueue+0x66>

0001d5fe <ctrl_tx_enqueue>:
	ctrl_tx_pause_enqueue(conn, tx, false);
   1d5fe:	2200      	movs	r2, #0
   1d600:	f7f4 bdbe 	b.w	12180 <ctrl_tx_pause_enqueue>

0001d604 <start_enc_rsp_send>:
	conn->lll.enc_tx = 1;
   1d604:	f890 307e 	ldrb.w	r3, [r0, #126]	; 0x7e
   1d608:	f043 0310 	orr.w	r3, r3, #16
   1d60c:	f880 307e 	strb.w	r3, [r0, #126]	; 0x7e
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   1d610:	780b      	ldrb	r3, [r1, #0]
   1d612:	f043 0303 	orr.w	r3, r3, #3
   1d616:	700b      	strb	r3, [r1, #0]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
   1d618:	2301      	movs	r3, #1
   1d61a:	704b      	strb	r3, [r1, #1]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_RSP;
   1d61c:	2306      	movs	r3, #6
   1d61e:	70cb      	strb	r3, [r1, #3]
}
   1d620:	2000      	movs	r0, #0
   1d622:	4770      	bx	lr

0001d624 <ll_connected_get>:
{
   1d624:	b508      	push	{r3, lr}
	if (handle >= CONFIG_BT_MAX_CONN) {
   1d626:	b918      	cbnz	r0, 1d630 <ll_connected_get+0xc>
	conn = ll_conn_get(handle);
   1d628:	f7f4 fe6e 	bl	12308 <ll_conn_get>
	if (conn->lll.handle != handle) {
   1d62c:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
   1d62e:	b103      	cbz	r3, 1d632 <ll_connected_get+0xe>
		return NULL;
   1d630:	2000      	movs	r0, #0
}
   1d632:	bd08      	pop	{r3, pc}

0001d634 <ll_conn_update>:
{
   1d634:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1d638:	460d      	mov	r5, r1
   1d63a:	4690      	mov	r8, r2
   1d63c:	469a      	mov	sl, r3
   1d63e:	f8bd 9020 	ldrh.w	r9, [sp, #32]
   1d642:	f8bd 7024 	ldrh.w	r7, [sp, #36]	; 0x24
   1d646:	f8bd 6028 	ldrh.w	r6, [sp, #40]	; 0x28
	conn = ll_connected_get(handle);
   1d64a:	f7ff ffeb 	bl	1d624 <ll_connected_get>
	if (!conn) {
   1d64e:	4604      	mov	r4, r0
   1d650:	2800      	cmp	r0, #0
   1d652:	d065      	beq.n	1d720 <ll_conn_update+0xec>
	if (!cmd) {
   1d654:	bb7d      	cbnz	r5, 1d6b6 <ll_conn_update+0x82>
		if (!conn->llcp_conn_param.disabled &&
   1d656:	f890 3172 	ldrb.w	r3, [r0, #370]	; 0x172
   1d65a:	06da      	lsls	r2, r3, #27
   1d65c:	d408      	bmi.n	1d670 <ll_conn_update+0x3c>
		    (!conn->common.fex_valid ||
   1d65e:	f890 10dc 	ldrb.w	r1, [r0, #220]	; 0xdc
		if (!conn->llcp_conn_param.disabled &&
   1d662:	f011 0101 	ands.w	r1, r1, #1
   1d666:	d041      	beq.n	1d6ec <ll_conn_update+0xb8>
		     (conn->llcp_feature.features &
   1d668:	f8d0 311c 	ldr.w	r3, [r0, #284]	; 0x11c
		    (!conn->common.fex_valid ||
   1d66c:	079b      	lsls	r3, r3, #30
   1d66e:	d423      	bmi.n	1d6b8 <ll_conn_update+0x84>
		} else if (conn->lll.role) {
   1d670:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   1d674:	2b00      	cmp	r3, #0
   1d676:	db51      	blt.n	1d71c <ll_conn_update+0xe8>
		if (conn->llcp_cu.req != conn->llcp_cu.ack) {
   1d678:	f894 3104 	ldrb.w	r3, [r4, #260]	; 0x104
   1d67c:	f894 2105 	ldrb.w	r2, [r4, #261]	; 0x105
   1d680:	429a      	cmp	r2, r3
   1d682:	d14d      	bne.n	1d720 <ll_conn_update+0xec>
		conn->llcp_cu.win_size = 1U;
   1d684:	2301      	movs	r3, #1
   1d686:	f884 3114 	strb.w	r3, [r4, #276]	; 0x114
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   1d68a:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
		conn->llcp_cu.interval = interval_max;
   1d68e:	f8a4 9108 	strh.w	r9, [r4, #264]	; 0x108
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   1d692:	f023 0307 	bic.w	r3, r3, #7
		conn->llcp_cu.win_offset_us = 0U;
   1d696:	2000      	movs	r0, #0
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   1d698:	f043 0305 	orr.w	r3, r3, #5
		conn->llcp_cu.req++;
   1d69c:	3201      	adds	r2, #1
		conn->llcp_cu.win_offset_us = 0U;
   1d69e:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
		conn->llcp_cu.latency = latency;
   1d6a2:	f8a4 710a 	strh.w	r7, [r4, #266]	; 0x10a
		conn->llcp_cu.timeout = timeout;
   1d6a6:	f8a4 610c 	strh.w	r6, [r4, #268]	; 0x10c
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   1d6aa:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
		conn->llcp_cu.req++;
   1d6ae:	f884 2104 	strb.w	r2, [r4, #260]	; 0x104
}
   1d6b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1d6b6:	4629      	mov	r1, r5
		cmd--;
   1d6b8:	1e48      	subs	r0, r1, #1
		if (cmd) {
   1d6ba:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
   1d6be:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
   1d6c2:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
   1d6c6:	d013      	beq.n	1d6f0 <ll_conn_update+0xbc>
			if ((conn->llcp_conn_param.req ==
   1d6c8:	4293      	cmp	r3, r2
   1d6ca:	d029      	beq.n	1d720 <ll_conn_update+0xec>
			    (conn->llcp_conn_param.state !=
   1d6cc:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
			     conn->llcp_conn_param.ack) ||
   1d6d0:	f003 0207 	and.w	r2, r3, #7
   1d6d4:	2a03      	cmp	r2, #3
   1d6d6:	d123      	bne.n	1d720 <ll_conn_update+0xec>
			conn->llcp_conn_param.state = cmd;
   1d6d8:	f360 0302 	bfi	r3, r0, #0, #3
			conn->llcp_conn_param.cmd = 1U;
   1d6dc:	f043 0308 	orr.w	r3, r3, #8
			conn->llcp_conn_param.status = status;
   1d6e0:	f884 8173 	strb.w	r8, [r4, #371]	; 0x173
			conn->llcp_conn_param.cmd = 1U;
   1d6e4:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
	return 0;
   1d6e8:	2000      	movs	r0, #0
   1d6ea:	e7e2      	b.n	1d6b2 <ll_conn_update+0x7e>
			cmd++;
   1d6ec:	2101      	movs	r1, #1
   1d6ee:	e7e3      	b.n	1d6b8 <ll_conn_update+0x84>
			if (conn->llcp_conn_param.req !=
   1d6f0:	4293      	cmp	r3, r2
   1d6f2:	d115      	bne.n	1d720 <ll_conn_update+0xec>
			conn->llcp_conn_param.state = cmd;
   1d6f4:	f8b4 2172 	ldrh.w	r2, [r4, #370]	; 0x172
			conn->llcp_conn_param.interval_min = interval_min;
   1d6f8:	f8a4 a174 	strh.w	sl, [r4, #372]	; 0x174
			conn->llcp_conn_param.state = cmd;
   1d6fc:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
   1d700:	f042 0208 	orr.w	r2, r2, #8
			conn->llcp_conn_param.req++;
   1d704:	3301      	adds	r3, #1
			conn->llcp_conn_param.interval_max = interval_max;
   1d706:	f8a4 9176 	strh.w	r9, [r4, #374]	; 0x176
			conn->llcp_conn_param.latency = latency;
   1d70a:	f8a4 7178 	strh.w	r7, [r4, #376]	; 0x178
			conn->llcp_conn_param.timeout = timeout;
   1d70e:	f8a4 617a 	strh.w	r6, [r4, #378]	; 0x17a
			conn->llcp_conn_param.state = cmd;
   1d712:	f8a4 2172 	strh.w	r2, [r4, #370]	; 0x172
			conn->llcp_conn_param.req++;
   1d716:	f884 3170 	strb.w	r3, [r4, #368]	; 0x170
   1d71a:	e7ca      	b.n	1d6b2 <ll_conn_update+0x7e>
			return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
   1d71c:	201a      	movs	r0, #26
   1d71e:	e7c8      	b.n	1d6b2 <ll_conn_update+0x7e>
		return BT_HCI_ERR_CMD_DISALLOWED;
   1d720:	200c      	movs	r0, #12
   1d722:	e7c6      	b.n	1d6b2 <ll_conn_update+0x7e>

0001d724 <ll_chm_get>:
{
   1d724:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d726:	460d      	mov	r5, r1
	conn = ll_connected_get(handle);
   1d728:	f7ff ff7c 	bl	1d624 <ll_connected_get>
	if (!conn) {
   1d72c:	4604      	mov	r4, r0
   1d72e:	b170      	cbz	r0, 1d74e <ll_chm_get+0x2a>
		conn->chm_updated = 0U;
   1d730:	2700      	movs	r7, #0
		memcpy(chm, conn->lll.data_chan_map,
   1d732:	f100 0638 	add.w	r6, r0, #56	; 0x38
		conn->chm_updated = 0U;
   1d736:	f884 71c4 	strb.w	r7, [r4, #452]	; 0x1c4
		memcpy(chm, conn->lll.data_chan_map,
   1d73a:	2205      	movs	r2, #5
   1d73c:	4631      	mov	r1, r6
   1d73e:	4628      	mov	r0, r5
   1d740:	f7fd fc5b 	bl	1affa <memcpy>
	} while (conn->chm_updated);
   1d744:	f894 01c4 	ldrb.w	r0, [r4, #452]	; 0x1c4
   1d748:	2800      	cmp	r0, #0
   1d74a:	d1f4      	bne.n	1d736 <ll_chm_get+0x12>
}
   1d74c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   1d74e:	200c      	movs	r0, #12
   1d750:	e7fc      	b.n	1d74c <ll_chm_get+0x28>

0001d752 <ll_terminate_ind_send>:
{
   1d752:	b510      	push	{r4, lr}
   1d754:	460c      	mov	r4, r1
	conn = ll_connected_get(handle);
   1d756:	f7ff ff65 	bl	1d624 <ll_connected_get>
	if (!conn) {
   1d75a:	b140      	cbz	r0, 1d76e <ll_terminate_ind_send+0x1c>
	conn->llcp_terminate.req++;
   1d75c:	f890 3128 	ldrb.w	r3, [r0, #296]	; 0x128
	conn->llcp_terminate.reason_own = reason;
   1d760:	f880 412a 	strb.w	r4, [r0, #298]	; 0x12a
	conn->llcp_terminate.req++;
   1d764:	3301      	adds	r3, #1
   1d766:	f880 3128 	strb.w	r3, [r0, #296]	; 0x128
	return 0;
   1d76a:	2000      	movs	r0, #0
}
   1d76c:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   1d76e:	200c      	movs	r0, #12
   1d770:	e7fc      	b.n	1d76c <ll_terminate_ind_send+0x1a>

0001d772 <ll_feature_req_send>:
{
   1d772:	b508      	push	{r3, lr}
	conn = ll_connected_get(handle);
   1d774:	f7ff ff56 	bl	1d624 <ll_connected_get>
	if (!conn) {
   1d778:	b150      	cbz	r0, 1d790 <ll_feature_req_send+0x1e>
	if (conn->llcp_feature.req != conn->llcp_feature.ack) {
   1d77a:	f890 2118 	ldrb.w	r2, [r0, #280]	; 0x118
   1d77e:	f890 3119 	ldrb.w	r3, [r0, #281]	; 0x119
   1d782:	4293      	cmp	r3, r2
   1d784:	d104      	bne.n	1d790 <ll_feature_req_send+0x1e>
	conn->llcp_feature.req++;
   1d786:	3301      	adds	r3, #1
   1d788:	f880 3118 	strb.w	r3, [r0, #280]	; 0x118
	return 0;
   1d78c:	2000      	movs	r0, #0
}
   1d78e:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   1d790:	200c      	movs	r0, #12
   1d792:	e7fc      	b.n	1d78e <ll_feature_req_send+0x1c>

0001d794 <ll_version_ind_send>:
{
   1d794:	b508      	push	{r3, lr}
	conn = ll_connected_get(handle);
   1d796:	f7ff ff45 	bl	1d624 <ll_connected_get>
	if (!conn) {
   1d79a:	b150      	cbz	r0, 1d7b2 <ll_version_ind_send+0x1e>
	if (conn->llcp_version.req != conn->llcp_version.ack) {
   1d79c:	f890 2120 	ldrb.w	r2, [r0, #288]	; 0x120
   1d7a0:	f890 3121 	ldrb.w	r3, [r0, #289]	; 0x121
   1d7a4:	4293      	cmp	r3, r2
   1d7a6:	d104      	bne.n	1d7b2 <ll_version_ind_send+0x1e>
	conn->llcp_version.req++;
   1d7a8:	3301      	adds	r3, #1
   1d7aa:	f880 3120 	strb.w	r3, [r0, #288]	; 0x120
	return 0;
   1d7ae:	2000      	movs	r0, #0
}
   1d7b0:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   1d7b2:	200c      	movs	r0, #12
   1d7b4:	e7fc      	b.n	1d7b0 <ll_version_ind_send+0x1c>

0001d7b6 <ll_length_req_send>:
{
   1d7b6:	b570      	push	{r4, r5, r6, lr}
   1d7b8:	460e      	mov	r6, r1
   1d7ba:	4615      	mov	r5, r2
	conn = ll_connected_get(handle);
   1d7bc:	f7ff ff32 	bl	1d624 <ll_connected_get>
	if (!conn) {
   1d7c0:	b340      	cbz	r0, 1d814 <ll_length_req_send+0x5e>
	if (conn->llcp_length.req != conn->llcp_length.ack) {
   1d7c2:	f890 2198 	ldrb.w	r2, [r0, #408]	; 0x198
   1d7c6:	f890 3199 	ldrb.w	r3, [r0, #409]	; 0x199
   1d7ca:	4293      	cmp	r3, r2
   1d7cc:	d014      	beq.n	1d7f8 <ll_length_req_send+0x42>
		switch (conn->llcp_length.state) {
   1d7ce:	f890 319a 	ldrb.w	r3, [r0, #410]	; 0x19a
   1d7d2:	f003 0307 	and.w	r3, r3, #7
   1d7d6:	2b07      	cmp	r3, #7
   1d7d8:	d01e      	beq.n	1d818 <ll_length_req_send+0x62>
   1d7da:	2401      	movs	r4, #1
   1d7dc:	fa04 f303 	lsl.w	r3, r4, r3
   1d7e0:	f013 0f68 	tst.w	r3, #104	; 0x68
   1d7e4:	d018      	beq.n	1d818 <ll_length_req_send+0x62>
			if (!conn->llcp_length.cache.tx_octets) {
   1d7e6:	f8b0 31a4 	ldrh.w	r3, [r0, #420]	; 0x1a4
   1d7ea:	b9ab      	cbnz	r3, 1d818 <ll_length_req_send+0x62>
				conn->llcp_length.cache.tx_octets = tx_octets;
   1d7ec:	f8a0 61a4 	strh.w	r6, [r0, #420]	; 0x1a4
				conn->llcp_length.cache.tx_time = tx_time;
   1d7f0:	f8a0 51a6 	strh.w	r5, [r0, #422]	; 0x1a6
	return 0;
   1d7f4:	2000      	movs	r0, #0
}
   1d7f6:	bd70      	pop	{r4, r5, r6, pc}
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   1d7f8:	f890 219a 	ldrb.w	r2, [r0, #410]	; 0x19a
	conn->llcp_length.tx_octets = tx_octets;
   1d7fc:	f8a0 619e 	strh.w	r6, [r0, #414]	; 0x19e
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   1d800:	f36f 0202 	bfc	r2, #0, #3
	conn->llcp_length.req++;
   1d804:	3301      	adds	r3, #1
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   1d806:	f880 219a 	strb.w	r2, [r0, #410]	; 0x19a
	conn->llcp_length.tx_time = tx_time;
   1d80a:	f8a0 51a2 	strh.w	r5, [r0, #418]	; 0x1a2
	conn->llcp_length.req++;
   1d80e:	f880 3198 	strb.w	r3, [r0, #408]	; 0x198
   1d812:	e7ef      	b.n	1d7f4 <ll_length_req_send+0x3e>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   1d814:	2002      	movs	r0, #2
   1d816:	e7ee      	b.n	1d7f6 <ll_length_req_send+0x40>
			return BT_HCI_ERR_CMD_DISALLOWED;
   1d818:	200c      	movs	r0, #12
   1d81a:	e7ec      	b.n	1d7f6 <ll_length_req_send+0x40>

0001d81c <ll_length_max_get>:
{
   1d81c:	b510      	push	{r4, lr}
	*max_tx_octets = LL_LENGTH_OCTETS_RX_MAX;
   1d81e:	241b      	movs	r4, #27
   1d820:	8004      	strh	r4, [r0, #0]
	*max_rx_octets = LL_LENGTH_OCTETS_RX_MAX;
   1d822:	8014      	strh	r4, [r2, #0]
	*max_tx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, BIT(2));
   1d824:	f44f 72a4 	mov.w	r2, #328	; 0x148
   1d828:	800a      	strh	r2, [r1, #0]
	*max_rx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, BIT(2));
   1d82a:	801a      	strh	r2, [r3, #0]
}
   1d82c:	bd10      	pop	{r4, pc}

0001d82e <ll_phy_get>:
{
   1d82e:	b538      	push	{r3, r4, r5, lr}
   1d830:	460d      	mov	r5, r1
   1d832:	4614      	mov	r4, r2
	conn = ll_connected_get(handle);
   1d834:	f7ff fef6 	bl	1d624 <ll_connected_get>
	if (!conn) {
   1d838:	b158      	cbz	r0, 1d852 <ll_phy_get+0x24>
	*tx = conn->lll.phy_tx;
   1d83a:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
   1d83e:	f3c3 0302 	ubfx	r3, r3, #0, #3
   1d842:	702b      	strb	r3, [r5, #0]
	*rx = conn->lll.phy_rx;
   1d844:	f890 3065 	ldrb.w	r3, [r0, #101]	; 0x65
   1d848:	f3c3 0302 	ubfx	r3, r3, #0, #3
   1d84c:	7023      	strb	r3, [r4, #0]
	return 0;
   1d84e:	2000      	movs	r0, #0
}
   1d850:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   1d852:	2002      	movs	r0, #2
   1d854:	e7fc      	b.n	1d850 <ll_phy_get+0x22>

0001d856 <ll_phy_req_send>:
{
   1d856:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1d85a:	4689      	mov	r9, r1
   1d85c:	4690      	mov	r8, r2
   1d85e:	461f      	mov	r7, r3
	conn = ll_connected_get(handle);
   1d860:	f7ff fee0 	bl	1d624 <ll_connected_get>
	if (!conn) {
   1d864:	b330      	cbz	r0, 1d8b4 <ll_phy_req_send+0x5e>
	if ((conn->llcp_req != conn->llcp_ack) ||
   1d866:	f890 20e8 	ldrb.w	r2, [r0, #232]	; 0xe8
   1d86a:	f890 30e9 	ldrb.w	r3, [r0, #233]	; 0xe9
   1d86e:	429a      	cmp	r2, r3
   1d870:	d122      	bne.n	1d8b8 <ll_phy_req_send+0x62>
	    (conn->llcp_phy.req != conn->llcp_phy.ack)) {
   1d872:	f890 31a8 	ldrb.w	r3, [r0, #424]	; 0x1a8
	if ((conn->llcp_req != conn->llcp_ack) ||
   1d876:	f890 61a9 	ldrb.w	r6, [r0, #425]	; 0x1a9
   1d87a:	429e      	cmp	r6, r3
   1d87c:	d11c      	bne.n	1d8b8 <ll_phy_req_send+0x62>
	conn->llcp_phy.state = LLCP_PHY_STATE_REQ;
   1d87e:	f8b0 41aa 	ldrh.w	r4, [r0, #426]	; 0x1aa
   1d882:	f424 6480 	bic.w	r4, r4, #1024	; 0x400
   1d886:	f024 0403 	bic.w	r4, r4, #3
   1d88a:	f444 6480 	orr.w	r4, r4, #1024	; 0x400
	conn->llcp_phy.tx = tx;
   1d88e:	4625      	mov	r5, r4
   1d890:	f369 0584 	bfi	r5, r9, #2, #3
	conn->llcp_phy.flags = flags;
   1d894:	f3c4 2407 	ubfx	r4, r4, #8, #8
   1d898:	f368 0441 	bfi	r4, r8, #1, #1
	conn->llcp_phy.rx = rx;
   1d89c:	f367 1547 	bfi	r5, r7, #5, #3
	conn->llcp_phy.req++;
   1d8a0:	3601      	adds	r6, #1
	conn->llcp_phy.flags = flags;
   1d8a2:	f880 41ab 	strb.w	r4, [r0, #427]	; 0x1ab
	conn->llcp_phy.rx = rx;
   1d8a6:	f880 51aa 	strb.w	r5, [r0, #426]	; 0x1aa
	conn->llcp_phy.req++;
   1d8aa:	f880 61a8 	strb.w	r6, [r0, #424]	; 0x1a8
	return 0;
   1d8ae:	2000      	movs	r0, #0
}
   1d8b0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   1d8b4:	2002      	movs	r0, #2
   1d8b6:	e7fb      	b.n	1d8b0 <ll_phy_req_send+0x5a>
		return BT_HCI_ERR_CMD_DISALLOWED;
   1d8b8:	200c      	movs	r0, #12
   1d8ba:	e7f9      	b.n	1d8b0 <ll_phy_req_send+0x5a>

0001d8bc <ll_apto_get>:
{
   1d8bc:	b510      	push	{r4, lr}
   1d8be:	460c      	mov	r4, r1
	conn = ll_connected_get(handle);
   1d8c0:	f7ff feb0 	bl	1d624 <ll_connected_get>
	if (!conn) {
   1d8c4:	b160      	cbz	r0, 1d8e0 <ll_apto_get+0x24>
	*apto = conn->apto_reload * conn->lll.interval * 125U / 1000;
   1d8c6:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
   1d8c8:	f8b0 20d2 	ldrh.w	r2, [r0, #210]	; 0xd2
   1d8cc:	435a      	muls	r2, r3
   1d8ce:	237d      	movs	r3, #125	; 0x7d
   1d8d0:	4353      	muls	r3, r2
	return 0;
   1d8d2:	2000      	movs	r0, #0
	*apto = conn->apto_reload * conn->lll.interval * 125U / 1000;
   1d8d4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1d8d8:	fbb3 f3f2 	udiv	r3, r3, r2
   1d8dc:	8023      	strh	r3, [r4, #0]
}
   1d8de:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   1d8e0:	2002      	movs	r0, #2
   1d8e2:	e7fc      	b.n	1d8de <ll_apto_get+0x22>

0001d8e4 <ll_apto_set>:
{
   1d8e4:	b510      	push	{r4, lr}
   1d8e6:	460c      	mov	r4, r1
	conn = ll_connected_get(handle);
   1d8e8:	f7ff fe9c 	bl	1d624 <ll_connected_get>
	if (!conn) {
   1d8ec:	b170      	cbz	r0, 1d90c <ll_apto_set+0x28>
	conn->apto_reload = RADIO_CONN_EVENTS(apto * 10U * 1000U,
   1d8ee:	8dc2      	ldrh	r2, [r0, #46]	; 0x2e
   1d8f0:	f240 43e2 	movw	r3, #1250	; 0x4e2
   1d8f4:	4353      	muls	r3, r2
   1d8f6:	f242 7110 	movw	r1, #10000	; 0x2710
   1d8fa:	fb01 3404 	mla	r4, r1, r4, r3
   1d8fe:	3c01      	subs	r4, #1
   1d900:	fbb4 f4f3 	udiv	r4, r4, r3
   1d904:	f8a0 40d2 	strh.w	r4, [r0, #210]	; 0xd2
	return 0;
   1d908:	2000      	movs	r0, #0
}
   1d90a:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   1d90c:	2002      	movs	r0, #2
   1d90e:	e7fc      	b.n	1d90a <ll_apto_set+0x26>

0001d910 <ull_conn_lll_max_tx_octets_get>:
	switch (lll->phy_tx_time) {
   1d910:	f890 2048 	ldrb.w	r2, [r0, #72]	; 0x48
   1d914:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
   1d918:	f3c2 1202 	ubfx	r2, r2, #4, #3
   1d91c:	2a02      	cmp	r2, #2
		max_tx_octets = (lll->max_tx_time >> 3) - 10;
   1d91e:	bf14      	ite	ne
   1d920:	08db      	lsrne	r3, r3, #3
		max_tx_octets = (lll->max_tx_time >> 2) - 11;
   1d922:	089b      	lsreq	r3, r3, #2
	if (lll->enc_tx) {
   1d924:	f890 2062 	ldrb.w	r2, [r0, #98]	; 0x62
	return max_tx_octets;
   1d928:	f8b0 0040 	ldrh.w	r0, [r0, #64]	; 0x40
		max_tx_octets = (lll->max_tx_time >> 3) - 10;
   1d92c:	bf14      	ite	ne
   1d92e:	3b0a      	subne	r3, #10
		max_tx_octets = (lll->max_tx_time >> 2) - 11;
   1d930:	3b0b      	subeq	r3, #11
   1d932:	b29b      	uxth	r3, r3
	if (lll->enc_tx) {
   1d934:	06d2      	lsls	r2, r2, #27
		max_tx_octets -= 4U;
   1d936:	bf44      	itt	mi
   1d938:	3b04      	submi	r3, #4
   1d93a:	b29b      	uxthmi	r3, r3
}
   1d93c:	4298      	cmp	r0, r3
   1d93e:	bf28      	it	cs
   1d940:	4618      	movcs	r0, r3
   1d942:	4770      	bx	lr

0001d944 <isr_race>:
	radio_status_reset();
   1d944:	f7f8 b9e0 	b.w	15d08 <radio_status_reset>

0001d948 <empty_tx_enqueue>:

	return 0;
}

static struct pdu_data *empty_tx_enqueue(struct lll_conn *lll)
{
   1d948:	b538      	push	{r3, r4, r5, lr}
	struct pdu_data *p;

	lll->empty = 1;
   1d94a:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
   1d94e:	f043 0304 	orr.w	r3, r3, #4
   1d952:	f880 3062 	strb.w	r3, [r0, #98]	; 0x62
{
   1d956:	4605      	mov	r5, r0

	p = (void *)radio_pkt_empty_get();
   1d958:	f7f8 fa0c 	bl	15d74 <radio_pkt_empty_get>
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   1d95c:	7803      	ldrb	r3, [r0, #0]
   1d95e:	2201      	movs	r2, #1
   1d960:	f362 0301 	bfi	r3, r2, #0, #2
	p->len = 0;
   1d964:	2200      	movs	r2, #0
   1d966:	7042      	strb	r2, [r0, #1]
	p = (void *)radio_pkt_empty_get();
   1d968:	4604      	mov	r4, r0
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   1d96a:	7003      	strb	r3, [r0, #0]
	if (memq_peek(lll->memq_tx.head, lll->memq_tx.tail, NULL)) {
   1d96c:	e9d5 0113 	ldrd	r0, r1, [r5, #76]	; 0x4c
   1d970:	f7ff fae1 	bl	1cf36 <memq_peek>
   1d974:	7823      	ldrb	r3, [r4, #0]
   1d976:	3000      	adds	r0, #0
   1d978:	bf18      	it	ne
   1d97a:	2001      	movne	r0, #1
   1d97c:	f360 1304 	bfi	r3, r0, #4, #1
   1d980:	7023      	strb	r3, [r4, #0]
	} else {
		p->md = 0;
	}

	return p;
}
   1d982:	4620      	mov	r0, r4
   1d984:	bd38      	pop	{r3, r4, r5, pc}

0001d986 <lll_conn_init>:
}
   1d986:	2000      	movs	r0, #0
   1d988:	4770      	bx	lr

0001d98a <lll_conn_reset>:
   1d98a:	2000      	movs	r0, #0
   1d98c:	4770      	bx	lr

0001d98e <lll_conn_ppm_local_get>:
}
   1d98e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   1d992:	4770      	bx	lr

0001d994 <lll_conn_is_abort_cb>:
}
   1d994:	f06f 0047 	mvn.w	r0, #71	; 0x47
   1d998:	4770      	bx	lr

0001d99a <lll_conn_isr_abort>:
{
   1d99a:	b510      	push	{r4, lr}
   1d99c:	4604      	mov	r4, r0
	radio_status_reset();
   1d99e:	f7f8 f9b3 	bl	15d08 <radio_status_reset>
	radio_tmr_status_reset();
   1d9a2:	f7f8 fa6f 	bl	15e84 <radio_tmr_status_reset>
	radio_filter_status_reset();
   1d9a6:	f7f8 fa49 	bl	15e3c <radio_filter_status_reset>
	radio_ar_status_reset();
   1d9aa:	f7f8 fc09 	bl	161c0 <radio_ar_status_reset>
	radio_rssi_status_reset();
   1d9ae:	f7f8 fa0d 	bl	15dcc <radio_rssi_status_reset>
	isr_cleanup(param);
   1d9b2:	4620      	mov	r0, r4
}
   1d9b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   1d9b8:	f7f6 bcca 	b.w	14350 <isr_cleanup>

0001d9bc <lll_conn_tx_pkt_set>:
{
   1d9bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d9be:	460f      	mov	r7, r1
	phy = lll->phy_tx;
   1d9c0:	f890 1048 	ldrb.w	r1, [r0, #72]	; 0x48
	max_tx_octets = lll->max_tx_octets;
   1d9c4:	f8b0 5040 	ldrh.w	r5, [r0, #64]	; 0x40
	phy = lll->phy_tx;
   1d9c8:	f001 0407 	and.w	r4, r1, #7
{
   1d9cc:	4606      	mov	r6, r0
	radio_phy_set(phy, flags);
   1d9ce:	f3c1 01c0 	ubfx	r1, r1, #3, #1
   1d9d2:	4620      	mov	r0, r4
   1d9d4:	f7f8 f902 	bl	15bdc <radio_phy_set>
	} else if (lll->enc_tx) {
   1d9d8:	f896 3062 	ldrb.w	r3, [r6, #98]	; 0x62
   1d9dc:	0062      	lsls	r2, r4, #1
   1d9de:	06db      	lsls	r3, r3, #27
   1d9e0:	b2e9      	uxtb	r1, r5
   1d9e2:	f042 0201 	orr.w	r2, r2, #1
   1d9e6:	d50d      	bpl.n	1da04 <lll_conn_tx_pkt_set+0x48>
		radio_pkt_configure(8, (max_tx_octets + 4U),
   1d9e8:	3104      	adds	r1, #4
   1d9ea:	b2c9      	uxtb	r1, r1
   1d9ec:	2008      	movs	r0, #8
   1d9ee:	f7f8 f93b 	bl	15c68 <radio_pkt_configure>
		radio_pkt_tx_set(radio_ccm_tx_pkt_set(&lll->ccm_tx,
   1d9f2:	4639      	mov	r1, r7
   1d9f4:	f106 0084 	add.w	r0, r6, #132	; 0x84
   1d9f8:	f7f8 fb62 	bl	160c0 <radio_ccm_tx_pkt_set>
}
   1d9fc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_tx_set(pdu_data_tx);
   1da00:	f7f8 b964 	b.w	15ccc <radio_pkt_tx_set>
		radio_pkt_configure(8, max_tx_octets, (phy << 1) | 0x01);
   1da04:	2008      	movs	r0, #8
   1da06:	f7f8 f92f 	bl	15c68 <radio_pkt_configure>
		radio_pkt_tx_set(pdu_data_tx);
   1da0a:	4638      	mov	r0, r7
   1da0c:	e7f6      	b.n	1d9fc <lll_conn_tx_pkt_set+0x40>

0001da0e <lll_conn_pdu_tx_prep>:
	if (lll->empty) {
   1da0e:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
   1da12:	075b      	lsls	r3, r3, #29
{
   1da14:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   1da18:	4606      	mov	r6, r0
   1da1a:	4688      	mov	r8, r1
	if (lll->empty) {
   1da1c:	d506      	bpl.n	1da2c <lll_conn_pdu_tx_prep+0x1e>
		*pdu_data_tx = empty_tx_enqueue(lll);
   1da1e:	f7ff ff93 	bl	1d948 <empty_tx_enqueue>
   1da22:	f8c8 0000 	str.w	r0, [r8]
}
   1da26:	b003      	add	sp, #12
   1da28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, (void **)&tx);
   1da2c:	aa01      	add	r2, sp, #4
   1da2e:	e9d0 0113 	ldrd	r0, r1, [r0, #76]	; 0x4c
   1da32:	f7ff fa80 	bl	1cf36 <memq_peek>
	if (!link) {
   1da36:	4681      	mov	r9, r0
   1da38:	b960      	cbnz	r0, 1da54 <lll_conn_pdu_tx_prep+0x46>
		p = empty_tx_enqueue(lll);
   1da3a:	4630      	mov	r0, r6
   1da3c:	f7ff ff84 	bl	1d948 <empty_tx_enqueue>
   1da40:	4607      	mov	r7, r0
	p->rfu = 0U;
   1da42:	783b      	ldrb	r3, [r7, #0]
   1da44:	f36f 1347 	bfc	r3, #5, #3
   1da48:	703b      	strb	r3, [r7, #0]
	p->resv = 0U;
   1da4a:	2300      	movs	r3, #0
   1da4c:	70bb      	strb	r3, [r7, #2]
	*pdu_data_tx = p;
   1da4e:	f8c8 7000 	str.w	r7, [r8]
   1da52:	e7e8      	b.n	1da26 <lll_conn_pdu_tx_prep+0x18>
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
   1da54:	9d01      	ldr	r5, [sp, #4]
   1da56:	f896 4061 	ldrb.w	r4, [r6, #97]	; 0x61
		if (!lll->packet_tx_head_len) {
   1da5a:	f896 3060 	ldrb.w	r3, [r6, #96]	; 0x60
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
   1da5e:	3504      	adds	r5, #4
   1da60:	192f      	adds	r7, r5, r4
		if (!lll->packet_tx_head_len) {
   1da62:	b913      	cbnz	r3, 1da6a <lll_conn_pdu_tx_prep+0x5c>
			lll->packet_tx_head_len = p->len;
   1da64:	787b      	ldrb	r3, [r7, #1]
   1da66:	f886 3060 	strb.w	r3, [r6, #96]	; 0x60
		if (lll->packet_tx_head_offset) {
   1da6a:	b124      	cbz	r4, 1da76 <lll_conn_pdu_tx_prep+0x68>
			p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   1da6c:	5d2b      	ldrb	r3, [r5, r4]
   1da6e:	2201      	movs	r2, #1
   1da70:	f362 0301 	bfi	r3, r2, #0, #2
   1da74:	552b      	strb	r3, [r5, r4]
		p->len = lll->packet_tx_head_len - lll->packet_tx_head_offset;
   1da76:	f896 3060 	ldrb.w	r3, [r6, #96]	; 0x60
   1da7a:	1b1b      	subs	r3, r3, r4
   1da7c:	707b      	strb	r3, [r7, #1]
		p->md = 0;
   1da7e:	5d2b      	ldrb	r3, [r5, r4]
   1da80:	f36f 1304 	bfc	r3, #4, #1
   1da84:	552b      	strb	r3, [r5, r4]
		max_tx_octets = ull_conn_lll_max_tx_octets_get(lll);
   1da86:	4630      	mov	r0, r6
   1da88:	f7ff ff42 	bl	1d910 <ull_conn_lll_max_tx_octets_get>
		if (p->len > max_tx_octets) {
   1da8c:	787b      	ldrb	r3, [r7, #1]
   1da8e:	4283      	cmp	r3, r0
			p->len = max_tx_octets;
   1da90:	bf84      	itt	hi
   1da92:	7078      	strbhi	r0, [r7, #1]
			p->md = 1;
   1da94:	5d2b      	ldrbhi	r3, [r5, r4]
		if (link->next != lll->memq_tx.tail) {
   1da96:	f8d9 2000 	ldr.w	r2, [r9]
			p->md = 1;
   1da9a:	bf84      	itt	hi
   1da9c:	f043 0310 	orrhi.w	r3, r3, #16
   1daa0:	552b      	strbhi	r3, [r5, r4]
		if (link->next != lll->memq_tx.tail) {
   1daa2:	6d33      	ldr	r3, [r6, #80]	; 0x50
   1daa4:	429a      	cmp	r2, r3
			p->md = 1;
   1daa6:	bf1e      	ittt	ne
   1daa8:	5d2b      	ldrbne	r3, [r5, r4]
   1daaa:	f043 0310 	orrne.w	r3, r3, #16
   1daae:	552b      	strbne	r3, [r5, r4]
   1dab0:	e7c7      	b.n	1da42 <lll_conn_pdu_tx_prep+0x34>

0001dab2 <lll_conn_flush>:

void lll_conn_flush(struct lll_conn *lll)
{
	/* Nothing to be flushed */
}
   1dab2:	4770      	bx	lr

0001dab4 <ll_start_enc_req_send>:
{
   1dab4:	b570      	push	{r4, r5, r6, lr}
   1dab6:	460d      	mov	r5, r1
   1dab8:	4616      	mov	r6, r2
	conn = ll_connected_get(handle);
   1daba:	f7ff fdb3 	bl	1d624 <ll_connected_get>
	if (!conn) {
   1dabe:	4604      	mov	r4, r0
   1dac0:	b3e0      	cbz	r0, 1db3c <ll_start_enc_req_send+0x88>
	if (error_code) {
   1dac2:	b325      	cbz	r5, 1db0e <ll_start_enc_req_send+0x5a>
		if (conn->llcp_enc.refresh == 0U) {
   1dac4:	f890 0152 	ldrb.w	r0, [r0, #338]	; 0x152
   1dac8:	f010 0004 	ands.w	r0, r0, #4
   1dacc:	d112      	bne.n	1daf4 <ll_start_enc_req_send+0x40>
			if ((conn->llcp_req == conn->llcp_ack) ||
   1dace:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
   1dad2:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   1dad6:	429a      	cmp	r2, r3
   1dad8:	d032      	beq.n	1db40 <ll_start_enc_req_send+0x8c>
   1dada:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
   1dade:	2b03      	cmp	r3, #3
   1dae0:	d12e      	bne.n	1db40 <ll_start_enc_req_send+0x8c>
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   1dae2:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
			conn->llcp.encryption.error_code = error_code;
   1dae6:	f884 50ed 	strb.w	r5, [r4, #237]	; 0xed
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   1daea:	f360 0301 	bfi	r3, r0, #0, #2
   1daee:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
}
   1daf2:	bd70      	pop	{r4, r5, r6, pc}
			    conn->llcp_terminate.req) {
   1daf4:	f894 2128 	ldrb.w	r2, [r4, #296]	; 0x128
			if (conn->llcp_terminate.ack !=
   1daf8:	f894 3129 	ldrb.w	r3, [r4, #297]	; 0x129
   1dafc:	4293      	cmp	r3, r2
   1dafe:	d11f      	bne.n	1db40 <ll_start_enc_req_send+0x8c>
			conn->llcp_terminate.req++;
   1db00:	3301      	adds	r3, #1
			conn->llcp_terminate.reason_own = error_code;
   1db02:	f884 512a 	strb.w	r5, [r4, #298]	; 0x12a
			conn->llcp_terminate.req++;
   1db06:	f884 3128 	strb.w	r3, [r4, #296]	; 0x128
	return 0;
   1db0a:	2000      	movs	r0, #0
   1db0c:	e7f1      	b.n	1daf2 <ll_start_enc_req_send+0x3e>
		if ((conn->llcp_req == conn->llcp_ack) ||
   1db0e:	f890 20e8 	ldrb.w	r2, [r0, #232]	; 0xe8
   1db12:	f890 30e9 	ldrb.w	r3, [r0, #233]	; 0xe9
   1db16:	429a      	cmp	r2, r3
   1db18:	d012      	beq.n	1db40 <ll_start_enc_req_send+0x8c>
   1db1a:	f890 30ea 	ldrb.w	r3, [r0, #234]	; 0xea
   1db1e:	2b03      	cmp	r3, #3
   1db20:	d10e      	bne.n	1db40 <ll_start_enc_req_send+0x8c>
		memcpy(&conn->llcp_enc.ltk[0], ltk,
   1db22:	2210      	movs	r2, #16
   1db24:	4631      	mov	r1, r6
   1db26:	f200 105d 	addw	r0, r0, #349	; 0x15d
   1db2a:	f7fd fa66 	bl	1affa <memcpy>
		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   1db2e:	f8b4 30ec 	ldrh.w	r3, [r4, #236]	; 0xec
   1db32:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
   1db36:	f8a4 30ec 	strh.w	r3, [r4, #236]	; 0xec
   1db3a:	e7e6      	b.n	1db0a <ll_start_enc_req_send+0x56>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   1db3c:	2002      	movs	r0, #2
   1db3e:	e7d8      	b.n	1daf2 <ll_start_enc_req_send+0x3e>
				return BT_HCI_ERR_CMD_DISALLOWED;
   1db40:	200c      	movs	r0, #12
   1db42:	e7d6      	b.n	1daf2 <ll_start_enc_req_send+0x3e>

0001db44 <ll_wl_size_get>:
}
   1db44:	2008      	movs	r0, #8
   1db46:	4770      	bx	lr

0001db48 <ll_rl_size_get>:
   1db48:	2008      	movs	r0, #8
   1db4a:	4770      	bx	lr

0001db4c <ecb_encrypt>:
	memcpy(cipher_text_be, &ecb.cipher_text[0], sizeof(ecb.cipher_text));
}

void ecb_encrypt(u8_t const *const key_le, u8_t const *const clear_text_le,
		 u8_t * const cipher_text_le, u8_t * const cipher_text_be)
{
   1db4c:	b570      	push	{r4, r5, r6, lr}
   1db4e:	b08c      	sub	sp, #48	; 0x30
   1db50:	460e      	mov	r6, r1
   1db52:	4615      	mov	r5, r2
	struct ecb_param ecb;

	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
   1db54:	4601      	mov	r1, r0
   1db56:	2210      	movs	r2, #16
   1db58:	4668      	mov	r0, sp
{
   1db5a:	461c      	mov	r4, r3
	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
   1db5c:	f7ff f9bc 	bl	1ced8 <mem_rcopy>
	mem_rcopy(&ecb.clear_text[0], clear_text_le, sizeof(ecb.clear_text));
   1db60:	2210      	movs	r2, #16
   1db62:	eb0d 0002 	add.w	r0, sp, r2
   1db66:	4631      	mov	r1, r6
   1db68:	f7ff f9b6 	bl	1ced8 <mem_rcopy>

	do_ecb(&ecb);
   1db6c:	4668      	mov	r0, sp
   1db6e:	f7f7 ff3b 	bl	159e8 <do_ecb>

	if (cipher_text_le) {
   1db72:	b125      	cbz	r5, 1db7e <ecb_encrypt+0x32>
		mem_rcopy(cipher_text_le, &ecb.cipher_text[0],
   1db74:	2210      	movs	r2, #16
   1db76:	a908      	add	r1, sp, #32
   1db78:	4628      	mov	r0, r5
   1db7a:	f7ff f9ad 	bl	1ced8 <mem_rcopy>
			  sizeof(ecb.cipher_text));
	}

	if (cipher_text_be) {
   1db7e:	b124      	cbz	r4, 1db8a <ecb_encrypt+0x3e>
		memcpy(cipher_text_be, &ecb.cipher_text[0],
   1db80:	2210      	movs	r2, #16
   1db82:	a908      	add	r1, sp, #32
   1db84:	4620      	mov	r0, r4
   1db86:	f7fd fa38 	bl	1affa <memcpy>
			 sizeof(ecb.cipher_text));
	}
}
   1db8a:	b00c      	add	sp, #48	; 0x30
   1db8c:	bd70      	pop	{r4, r5, r6, pc}

0001db8e <radio_tx_chain_delay_get>:
}
   1db8e:	2001      	movs	r0, #1
   1db90:	4770      	bx	lr

0001db92 <radio_rx_ready_delay_get>:
}
   1db92:	2029      	movs	r0, #41	; 0x29
   1db94:	4770      	bx	lr

0001db96 <radio_rx_chain_delay_get>:
	switch (phy) {
   1db96:	2802      	cmp	r0, #2
}
   1db98:	bf14      	ite	ne
   1db9a:	200a      	movne	r0, #10
   1db9c:	2006      	moveq	r0, #6
   1db9e:	4770      	bx	lr

0001dba0 <mayfly_prio_is_equal>:
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   1dba0:	4288      	cmp	r0, r1
   1dba2:	d00c      	beq.n	1dbbe <mayfly_prio_is_equal+0x1e>
	return (caller_id == callee_id) ||
   1dba4:	b978      	cbnz	r0, 1dbc6 <mayfly_prio_is_equal+0x26>
	       ((caller_id == MAYFLY_CALL_ID_LLL) &&
   1dba6:	1e48      	subs	r0, r1, #1
   1dba8:	2801      	cmp	r0, #1
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
   1dbaa:	bf8c      	ite	hi
   1dbac:	2000      	movhi	r0, #0
   1dbae:	2001      	movls	r0, #1
   1dbb0:	4770      	bx	lr
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
   1dbb2:	f011 0ffd 	tst.w	r1, #253	; 0xfd
   1dbb6:	bf0c      	ite	eq
   1dbb8:	2001      	moveq	r0, #1
   1dbba:	2000      	movne	r0, #0
   1dbbc:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   1dbbe:	2001      	movs	r0, #1
   1dbc0:	4770      	bx	lr
   1dbc2:	2000      	movs	r0, #0
}
   1dbc4:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   1dbc6:	2801      	cmp	r0, #1
   1dbc8:	d0f3      	beq.n	1dbb2 <mayfly_prio_is_equal+0x12>
		(callee_id == MAYFLY_CALL_ID_JOB)) ||
   1dbca:	2802      	cmp	r0, #2
   1dbcc:	d1f9      	bne.n	1dbc2 <mayfly_prio_is_equal+0x22>
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
   1dbce:	2901      	cmp	r1, #1
   1dbd0:	e7eb      	b.n	1dbaa <mayfly_prio_is_equal+0xa>

0001dbd2 <hal_ticker_instance0_trigger_set>:

void hal_ticker_instance0_trigger_set(u32_t value)
{
	cntr_cmp_set(0, value);
   1dbd2:	4601      	mov	r1, r0
   1dbd4:	2000      	movs	r0, #0
   1dbd6:	f7f7 beff 	b.w	159d8 <cntr_cmp_set>

0001dbda <fixed_data_unref>:
}
   1dbda:	4770      	bx	lr

0001dbdc <k_uptime_get_32>:
{
   1dbdc:	b508      	push	{r3, lr}
	return z_impl_k_uptime_get();
   1dbde:	f000 fe14 	bl	1e80a <z_impl_k_uptime_get>
}
   1dbe2:	bd08      	pop	{r3, pc}

0001dbe4 <net_buf_alloc_fixed>:
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   1dbe4:	6983      	ldr	r3, [r0, #24]
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
   1dbe6:	685b      	ldr	r3, [r3, #4]
   1dbe8:	460a      	mov	r2, r1
   1dbea:	6819      	ldr	r1, [r3, #0]
   1dbec:	f7f8 bc26 	b.w	1643c <net_buf_alloc_len>

0001dbf0 <net_buf_get>:
{
   1dbf0:	b570      	push	{r4, r5, r6, lr}
   1dbf2:	4606      	mov	r6, r0
	return z_impl_k_queue_get(queue, timeout);
   1dbf4:	f000 fbd3 	bl	1e39e <z_impl_k_queue_get>
	if (!buf) {
   1dbf8:	4605      	mov	r5, r0
   1dbfa:	b128      	cbz	r0, 1dc08 <net_buf_get+0x18>
   1dbfc:	4604      	mov	r4, r0
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   1dbfe:	7963      	ldrb	r3, [r4, #5]
   1dc00:	f013 0301 	ands.w	r3, r3, #1
   1dc04:	d102      	bne.n	1dc0c <net_buf_get+0x1c>
	frag->frags = NULL;
   1dc06:	6023      	str	r3, [r4, #0]
}
   1dc08:	4628      	mov	r0, r5
   1dc0a:	bd70      	pop	{r4, r5, r6, pc}
   1dc0c:	2100      	movs	r1, #0
   1dc0e:	4630      	mov	r0, r6
   1dc10:	f000 fbc5 	bl	1e39e <z_impl_k_queue_get>
		frag->flags &= ~NET_BUF_FRAGS;
   1dc14:	7963      	ldrb	r3, [r4, #5]
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
   1dc16:	6020      	str	r0, [r4, #0]
		frag->flags &= ~NET_BUF_FRAGS;
   1dc18:	f023 0301 	bic.w	r3, r3, #1
   1dc1c:	7163      	strb	r3, [r4, #5]
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   1dc1e:	4604      	mov	r4, r0
   1dc20:	e7ed      	b.n	1dbfe <net_buf_get+0xe>

0001dc22 <net_buf_simple_reserve>:
	buf->data = buf->__buf + reserve;
   1dc22:	6883      	ldr	r3, [r0, #8]
   1dc24:	4419      	add	r1, r3
   1dc26:	6001      	str	r1, [r0, #0]
}
   1dc28:	4770      	bx	lr

0001dc2a <net_buf_put>:
{
   1dc2a:	b410      	push	{r4}
	for (tail = buf; tail->frags; tail = tail->frags) {
   1dc2c:	460a      	mov	r2, r1
   1dc2e:	6814      	ldr	r4, [r2, #0]
   1dc30:	b914      	cbnz	r4, 1dc38 <net_buf_put+0xe>
}
   1dc32:	bc10      	pop	{r4}
	k_fifo_put_list(fifo, buf, tail);
   1dc34:	f000 bb94 	b.w	1e360 <k_queue_append_list>
		tail->flags |= NET_BUF_FRAGS;
   1dc38:	7953      	ldrb	r3, [r2, #5]
   1dc3a:	f043 0301 	orr.w	r3, r3, #1
   1dc3e:	7153      	strb	r3, [r2, #5]
   1dc40:	4622      	mov	r2, r4
   1dc42:	e7f4      	b.n	1dc2e <net_buf_put+0x4>

0001dc44 <net_buf_ref>:
{
	__ASSERT_NO_MSG(buf);

	NET_BUF_DBG("buf %p (old) ref %u pool_id %u",
		    buf, buf->ref, buf->pool_id);
	buf->ref++;
   1dc44:	7903      	ldrb	r3, [r0, #4]
   1dc46:	3301      	adds	r3, #1
   1dc48:	7103      	strb	r3, [r0, #4]
	return buf;
}
   1dc4a:	4770      	bx	lr

0001dc4c <net_buf_simple_add>:
	return buf->data + buf->len;
   1dc4c:	8883      	ldrh	r3, [r0, #4]
   1dc4e:	6802      	ldr	r2, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
   1dc50:	4419      	add	r1, r3
   1dc52:	8081      	strh	r1, [r0, #4]
	return tail;
}
   1dc54:	18d0      	adds	r0, r2, r3
   1dc56:	4770      	bx	lr

0001dc58 <net_buf_simple_add_mem>:

void *net_buf_simple_add_mem(struct net_buf_simple *buf, const void *mem,
			     size_t len)
{
   1dc58:	b430      	push	{r4, r5}
   1dc5a:	8883      	ldrh	r3, [r0, #4]
   1dc5c:	6804      	ldr	r4, [r0, #0]
	buf->len += len;
   1dc5e:	189d      	adds	r5, r3, r2
   1dc60:	8085      	strh	r5, [r0, #4]
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	return memcpy(net_buf_simple_add(buf, len), mem, len);
   1dc62:	18e0      	adds	r0, r4, r3
}
   1dc64:	bc30      	pop	{r4, r5}
	return memcpy(net_buf_simple_add(buf, len), mem, len);
   1dc66:	f7fd b9c8 	b.w	1affa <memcpy>

0001dc6a <net_buf_simple_add_u8>:
   1dc6a:	8883      	ldrh	r3, [r0, #4]
   1dc6c:	6802      	ldr	r2, [r0, #0]

u8_t *net_buf_simple_add_u8(struct net_buf_simple *buf, u8_t val)
{
   1dc6e:	b510      	push	{r4, lr}
	buf->len += len;
   1dc70:	1c5c      	adds	r4, r3, #1
   1dc72:	8084      	strh	r4, [r0, #4]
	u8_t *u8;

	NET_BUF_SIMPLE_DBG("buf %p val 0x%02x", buf, val);

	u8 = net_buf_simple_add(buf, 1);
	*u8 = val;
   1dc74:	54d1      	strb	r1, [r2, r3]

	return u8;
}
   1dc76:	18d0      	adds	r0, r2, r3
   1dc78:	bd10      	pop	{r4, pc}

0001dc7a <net_buf_simple_add_le16>:
   1dc7a:	8883      	ldrh	r3, [r0, #4]
   1dc7c:	6802      	ldr	r2, [r0, #0]

void net_buf_simple_add_le16(struct net_buf_simple *buf, u16_t val)
{
   1dc7e:	b530      	push	{r4, r5, lr}
   1dc80:	18d4      	adds	r4, r2, r3
	buf->len += len;
   1dc82:	1c9d      	adds	r5, r3, #2
   1dc84:	8085      	strh	r5, [r0, #4]
	dst[0] = val;
   1dc86:	54d1      	strb	r1, [r2, r3]
	dst[1] = val >> 8;
   1dc88:	0a09      	lsrs	r1, r1, #8
   1dc8a:	7061      	strb	r1, [r4, #1]
	NET_BUF_SIMPLE_DBG("buf %p val %u", buf, val);

	sys_put_le16(val, net_buf_simple_add(buf, sizeof(val)));
}
   1dc8c:	bd30      	pop	{r4, r5, pc}

0001dc8e <net_buf_simple_push>:
{
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);

	buf->data -= len;
   1dc8e:	6803      	ldr	r3, [r0, #0]
	buf->len += len;
   1dc90:	8882      	ldrh	r2, [r0, #4]
	buf->data -= len;
   1dc92:	1a5b      	subs	r3, r3, r1
	buf->len += len;
   1dc94:	4411      	add	r1, r2
	buf->data -= len;
   1dc96:	6003      	str	r3, [r0, #0]
	buf->len += len;
   1dc98:	8081      	strh	r1, [r0, #4]
	return buf->data;
}
   1dc9a:	4618      	mov	r0, r3
   1dc9c:	4770      	bx	lr

0001dc9e <net_buf_simple_pull>:
{
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   1dc9e:	8883      	ldrh	r3, [r0, #4]
   1dca0:	1a5b      	subs	r3, r3, r1
   1dca2:	8083      	strh	r3, [r0, #4]
	return buf->data += len;
   1dca4:	6803      	ldr	r3, [r0, #0]
   1dca6:	4419      	add	r1, r3
   1dca8:	6001      	str	r1, [r0, #0]
}
   1dcaa:	4608      	mov	r0, r1
   1dcac:	4770      	bx	lr

0001dcae <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
   1dcae:	4603      	mov	r3, r0
	void *data = buf->data;
   1dcb0:	6800      	ldr	r0, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   1dcb2:	889a      	ldrh	r2, [r3, #4]
   1dcb4:	1a52      	subs	r2, r2, r1
	buf->data += len;
   1dcb6:	4401      	add	r1, r0
	buf->len -= len;
   1dcb8:	809a      	strh	r2, [r3, #4]
	buf->data += len;
   1dcba:	6019      	str	r1, [r3, #0]

	return data;
}
   1dcbc:	4770      	bx	lr

0001dcbe <net_buf_simple_pull_le16>:

	return val;
}

u16_t net_buf_simple_pull_le16(struct net_buf_simple *buf)
{
   1dcbe:	b508      	push	{r3, lr}
	u16_t val;

	val = UNALIGNED_GET((u16_t *)buf->data);
   1dcc0:	6803      	ldr	r3, [r0, #0]
	net_buf_simple_pull(buf, sizeof(val));
   1dcc2:	2102      	movs	r1, #2
	val = UNALIGNED_GET((u16_t *)buf->data);
   1dcc4:	881a      	ldrh	r2, [r3, #0]
	net_buf_simple_pull(buf, sizeof(val));
   1dcc6:	f7ff ffea 	bl	1dc9e <net_buf_simple_pull>

	return sys_le16_to_cpu(val);
}
   1dcca:	4610      	mov	r0, r2
   1dccc:	bd08      	pop	{r3, pc}

0001dcce <net_buf_simple_headroom>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
   1dcce:	6802      	ldr	r2, [r0, #0]
   1dcd0:	6880      	ldr	r0, [r0, #8]
}
   1dcd2:	1a10      	subs	r0, r2, r0
   1dcd4:	4770      	bx	lr

0001dcd6 <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
   1dcd6:	8883      	ldrh	r3, [r0, #4]
   1dcd8:	88c2      	ldrh	r2, [r0, #6]
   1dcda:	1ad2      	subs	r2, r2, r3
	return buf->data - buf->__buf;
   1dcdc:	6803      	ldr	r3, [r0, #0]
   1dcde:	6880      	ldr	r0, [r0, #8]
   1dce0:	1a18      	subs	r0, r3, r0
}
   1dce2:	1a10      	subs	r0, r2, r0
   1dce4:	4770      	bx	lr

0001dce6 <gpio_nrfx_write>:
{
   1dce6:	b510      	push	{r4, lr}
	return port->config->config_info;
   1dce8:	6804      	ldr	r4, [r0, #0]
   1dcea:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1dcec:	68a4      	ldr	r4, [r4, #8]
   1dcee:	69c0      	ldr	r0, [r0, #28]
   1dcf0:	6824      	ldr	r4, [r4, #0]
	if (access_op == GPIO_ACCESS_BY_PORT) {
   1dcf2:	2901      	cmp	r1, #1
   1dcf4:	d104      	bne.n	1dd00 <gpio_nrfx_write+0x1a>
		nrf_gpio_port_out_write(reg, value ^ data->inverted);
   1dcf6:	4058      	eors	r0, r3
}


NRF_STATIC_INLINE void nrf_gpio_port_out_write(NRF_GPIO_Type * p_reg, uint32_t value)
{
    p_reg->OUT = value;
   1dcf8:	f8c4 0504 	str.w	r0, [r4, #1284]	; 0x504
}
   1dcfc:	2000      	movs	r0, #0
   1dcfe:	bd10      	pop	{r4, pc}
		if ((value > 0) ^ ((BIT(pin) & data->inverted) != 0)) {
   1dd00:	3300      	adds	r3, #0
   1dd02:	fa20 f002 	lsr.w	r0, r0, r2
   1dd06:	f04f 0101 	mov.w	r1, #1
   1dd0a:	bf18      	it	ne
   1dd0c:	2301      	movne	r3, #1
   1dd0e:	f000 0001 	and.w	r0, r0, #1
   1dd12:	4091      	lsls	r1, r2
   1dd14:	4283      	cmp	r3, r0
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
   1dd16:	bf14      	ite	ne
   1dd18:	f8c4 1508 	strne.w	r1, [r4, #1288]	; 0x508
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
   1dd1c:	f8c4 150c 	streq.w	r1, [r4, #1292]	; 0x50c
   1dd20:	e7ec      	b.n	1dcfc <gpio_nrfx_write+0x16>

0001dd22 <gpio_nrfx_read>:
{
   1dd22:	b570      	push	{r4, r5, r6, lr}
	return port->config->config_info;
   1dd24:	6804      	ldr	r4, [r0, #0]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   1dd26:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1dd28:	68a4      	ldr	r4, [r4, #8]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   1dd2a:	69c0      	ldr	r0, [r0, #28]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1dd2c:	6825      	ldr	r5, [r4, #0]
    return p_reg->DIR;
   1dd2e:	f8d5 6514 	ldr.w	r6, [r5, #1300]	; 0x514
    return p_reg->IN;
   1dd32:	f8d5 4510 	ldr.w	r4, [r5, #1296]	; 0x510
    return p_reg->OUT;
   1dd36:	f8d5 5504 	ldr.w	r5, [r5, #1284]	; 0x504
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   1dd3a:	4060      	eors	r0, r4
   1dd3c:	406c      	eors	r4, r5
   1dd3e:	4034      	ands	r4, r6
   1dd40:	4060      	eors	r0, r4
	if (access_op == GPIO_ACCESS_BY_PORT) {
   1dd42:	2901      	cmp	r1, #1
		*value = (port_val & BIT(pin)) ? 1 : 0;
   1dd44:	bf1c      	itt	ne
   1dd46:	40d0      	lsrne	r0, r2
   1dd48:	f000 0001 	andne.w	r0, r0, #1
   1dd4c:	6018      	str	r0, [r3, #0]
}
   1dd4e:	2000      	movs	r0, #0
   1dd50:	bd70      	pop	{r4, r5, r6, pc}

0001dd52 <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   1dd52:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_IS_EMPTY(slist)
   1dd54:	6818      	ldr	r0, [r3, #0]
{
   1dd56:	b530      	push	{r4, r5, lr}
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
   1dd58:	b158      	cbz	r0, 1dd72 <gpio_nrfx_manage_callback+0x20>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1dd5a:	2400      	movs	r4, #0
   1dd5c:	4281      	cmp	r1, r0
   1dd5e:	d113      	bne.n	1dd88 <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
   1dd60:	6808      	ldr	r0, [r1, #0]
   1dd62:	b95c      	cbnz	r4, 1dd7c <gpio_nrfx_manage_callback+0x2a>
   1dd64:	685c      	ldr	r4, [r3, #4]
	list->head = node;
   1dd66:	6018      	str	r0, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   1dd68:	42a1      	cmp	r1, r4
   1dd6a:	d100      	bne.n	1dd6e <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
   1dd6c:	6058      	str	r0, [r3, #4]
	parent->next = child;
   1dd6e:	2000      	movs	r0, #0
   1dd70:	6008      	str	r0, [r1, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
   1dd72:	b972      	cbnz	r2, 1dd92 <gpio_nrfx_manage_callback+0x40>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
   1dd74:	2000      	movs	r0, #0
}
   1dd76:	bd30      	pop	{r4, r5, pc}
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1dd78:	4628      	mov	r0, r5
   1dd7a:	e7ef      	b.n	1dd5c <gpio_nrfx_manage_callback+0xa>
	parent->next = child;
   1dd7c:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   1dd7e:	6858      	ldr	r0, [r3, #4]
   1dd80:	4281      	cmp	r1, r0
	list->tail = node;
   1dd82:	bf08      	it	eq
   1dd84:	605c      	streq	r4, [r3, #4]
   1dd86:	e7f2      	b.n	1dd6e <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1dd88:	6805      	ldr	r5, [r0, #0]
	return node->next;
   1dd8a:	4604      	mov	r4, r0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1dd8c:	2d00      	cmp	r5, #0
   1dd8e:	d1f3      	bne.n	1dd78 <gpio_nrfx_manage_callback+0x26>
			if (!set) {
   1dd90:	b13a      	cbz	r2, 1dda2 <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
   1dd92:	681a      	ldr	r2, [r3, #0]
	parent->next = child;
   1dd94:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   1dd96:	6858      	ldr	r0, [r3, #4]
	list->head = node;
   1dd98:	6019      	str	r1, [r3, #0]
Z_GENLIST_PREPEND(slist, snode)
   1dd9a:	2800      	cmp	r0, #0
   1dd9c:	d1ea      	bne.n	1dd74 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
   1dd9e:	6059      	str	r1, [r3, #4]
   1dda0:	e7e9      	b.n	1dd76 <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
   1dda2:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   1dda6:	e7e6      	b.n	1dd76 <gpio_nrfx_manage_callback+0x24>

0001dda8 <gpio_nrfx_config>:
{
   1dda8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ddac:	4680      	mov	r8, r0
	struct gpio_nrfx_data *data = get_port_data(port);
   1ddae:	6885      	ldr	r5, [r0, #8]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   1ddb0:	f403 4070 	and.w	r0, r3, #61440	; 0xf000
   1ddb4:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
{
   1ddb8:	461e      	mov	r6, r3
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   1ddba:	d041      	beq.n	1de40 <gpio_nrfx_config+0x98>
   1ddbc:	dc09      	bgt.n	1ddd2 <gpio_nrfx_config+0x2a>
   1ddbe:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   1ddc2:	d03f      	beq.n	1de44 <gpio_nrfx_config+0x9c>
   1ddc4:	f5b0 5f40 	cmp.w	r0, #12288	; 0x3000
   1ddc8:	d03e      	beq.n	1de48 <gpio_nrfx_config+0xa0>
   1ddca:	b190      	cbz	r0, 1ddf2 <gpio_nrfx_config+0x4a>
		return -EINVAL;
   1ddcc:	f06f 0015 	mvn.w	r0, #21
   1ddd0:	e033      	b.n	1de3a <gpio_nrfx_config+0x92>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   1ddd2:	f5b0 4fe0 	cmp.w	r0, #28672	; 0x7000
   1ddd6:	d039      	beq.n	1de4c <gpio_nrfx_config+0xa4>
   1ddd8:	dc04      	bgt.n	1dde4 <gpio_nrfx_config+0x3c>
   1ddda:	f5b0 4fa0 	cmp.w	r0, #20480	; 0x5000
   1ddde:	d1f5      	bne.n	1ddcc <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0H1;
   1dde0:	2003      	movs	r0, #3
   1dde2:	e006      	b.n	1ddf2 <gpio_nrfx_config+0x4a>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   1dde4:	f5b0 4f40 	cmp.w	r0, #49152	; 0xc000
   1dde8:	d032      	beq.n	1de50 <gpio_nrfx_config+0xa8>
   1ddea:	f5b0 4f50 	cmp.w	r0, #53248	; 0xd000
   1ddee:	d1ed      	bne.n	1ddcc <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0D1;
   1ddf0:	2007      	movs	r0, #7
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
   1ddf2:	f406 7740 	and.w	r7, r6, #768	; 0x300
   1ddf6:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
   1ddfa:	d02b      	beq.n	1de54 <gpio_nrfx_config+0xac>
		pull = NRF_GPIO_PIN_NOPULL;
   1ddfc:	f5a7 7400 	sub.w	r4, r7, #512	; 0x200
   1de00:	4263      	negs	r3, r4
   1de02:	4163      	adcs	r3, r4
	dir = ((flags & GPIO_DIR_MASK) == GPIO_DIR_OUT)
   1de04:	f006 0c01 	and.w	ip, r6, #1
                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
   1de08:	ea4f 074c 	mov.w	r7, ip, lsl #1
	if (access_op == GPIO_ACCESS_BY_PORT) {
   1de0c:	2901      	cmp	r1, #1
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   1de0e:	ea47 070c 	orr.w	r7, r7, ip
		from_pin = pin;
   1de12:	bf18      	it	ne
   1de14:	b2d4      	uxtbne	r4, r2
   1de16:	ea47 2000 	orr.w	r0, r7, r0, lsl #8
   1de1a:	ea40 0783 	orr.w	r7, r0, r3, lsl #2
		to_pin   = pin;
   1de1e:	bf12      	itee	ne
   1de20:	46a1      	movne	r9, r4
		to_pin   = 31U;
   1de22:	f04f 091f 	moveq.w	r9, #31
		from_pin = 0U;
   1de26:	2400      	moveq	r4, #0
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1de28:	f04f 4aa0 	mov.w	sl, #1342177280	; 0x50000000
   1de2c:	f04f 0b01 	mov.w	fp, #1
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
   1de30:	f006 0302 	and.w	r3, r6, #2
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   1de34:	45a1      	cmp	r9, r4
   1de36:	d20f      	bcs.n	1de58 <gpio_nrfx_config+0xb0>
	return 0;
   1de38:	2000      	movs	r0, #0
}
   1de3a:	b003      	add	sp, #12
   1de3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		drive = NRF_GPIO_PIN_S0H1;
   1de40:	2002      	movs	r0, #2
   1de42:	e7d6      	b.n	1ddf2 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_H0S1;
   1de44:	2001      	movs	r0, #1
   1de46:	e7d4      	b.n	1ddf2 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0S1;
   1de48:	2004      	movs	r0, #4
   1de4a:	e7d2      	b.n	1ddf2 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0H1;
   1de4c:	2005      	movs	r0, #5
   1de4e:	e7d0      	b.n	1ddf2 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_S0D1;
   1de50:	2006      	movs	r0, #6
   1de52:	e7ce      	b.n	1ddf2 <gpio_nrfx_config+0x4a>
		pull = NRF_GPIO_PIN_PULLUP;
   1de54:	2303      	movs	r3, #3
   1de56:	e7d5      	b.n	1de04 <gpio_nrfx_config+0x5c>
	return port->config->config_info;
   1de58:	f8d8 2000 	ldr.w	r2, [r8]
		nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num,
   1de5c:	6892      	ldr	r2, [r2, #8]
   1de5e:	7911      	ldrb	r1, [r2, #4]
   1de60:	f004 021f 	and.w	r2, r4, #31
   1de64:	ea42 1241 	orr.w	r2, r2, r1, lsl #5
   1de68:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
   1de6c:	f84a 7022 	str.w	r7, [sl, r2, lsl #2]
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
   1de70:	fa0b f204 	lsl.w	r2, fp, r4
   1de74:	68a9      	ldr	r1, [r5, #8]
   1de76:	2b00      	cmp	r3, #0
   1de78:	d025      	beq.n	1dec6 <gpio_nrfx_config+0x11e>
   1de7a:	4311      	orrs	r1, r2
   1de7c:	60a9      	str	r1, [r5, #8]
		WRITE_BIT(data->trig_edge, curr_pin, flags & GPIO_INT_EDGE);
   1de7e:	6969      	ldr	r1, [r5, #20]
   1de80:	9301      	str	r3, [sp, #4]
   1de82:	06b0      	lsls	r0, r6, #26
   1de84:	bf4c      	ite	mi
   1de86:	4311      	orrmi	r1, r2
   1de88:	4391      	bicpl	r1, r2
   1de8a:	6169      	str	r1, [r5, #20]
		WRITE_BIT(data->double_edge, curr_pin,
   1de8c:	69a9      	ldr	r1, [r5, #24]
   1de8e:	0670      	lsls	r0, r6, #25
   1de90:	bf4c      	ite	mi
   1de92:	4311      	orrmi	r1, r2
   1de94:	4391      	bicpl	r1, r2
   1de96:	61a9      	str	r1, [r5, #24]
		WRITE_BIT(data->active_level, curr_pin,
   1de98:	6929      	ldr	r1, [r5, #16]
   1de9a:	0770      	lsls	r0, r6, #29
   1de9c:	bf4c      	ite	mi
   1de9e:	4311      	orrmi	r1, r2
   1dea0:	4391      	bicpl	r1, r2
   1dea2:	6129      	str	r1, [r5, #16]
		WRITE_BIT(data->inverted, curr_pin, flags & GPIO_POL_INV);
   1dea4:	69e9      	ldr	r1, [r5, #28]
   1dea6:	0630      	lsls	r0, r6, #24
   1dea8:	bf4c      	ite	mi
   1deaa:	430a      	orrmi	r2, r1
   1deac:	ea21 0202 	bicpl.w	r2, r1, r2
   1deb0:	61ea      	str	r2, [r5, #28]
		res = gpiote_pin_int_cfg(port, curr_pin);
   1deb2:	4621      	mov	r1, r4
   1deb4:	4640      	mov	r0, r8
   1deb6:	f7f8 fb79 	bl	165ac <gpiote_pin_int_cfg>
		if (res != 0) {
   1deba:	2800      	cmp	r0, #0
   1debc:	d1bd      	bne.n	1de3a <gpio_nrfx_config+0x92>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   1debe:	3401      	adds	r4, #1
   1dec0:	b2e4      	uxtb	r4, r4
   1dec2:	9b01      	ldr	r3, [sp, #4]
   1dec4:	e7b6      	b.n	1de34 <gpio_nrfx_config+0x8c>
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
   1dec6:	ea21 0102 	bic.w	r1, r1, r2
   1deca:	e7d7      	b.n	1de7c <gpio_nrfx_config+0xd4>

0001decc <gpio_nrfx_pin_disable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
   1decc:	2901      	cmp	r1, #1
{
   1dece:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
   1ded2:	bf18      	it	ne
   1ded4:	b2d4      	uxtbne	r4, r2
	struct gpio_nrfx_data *data = get_port_data(port);
   1ded6:	6887      	ldr	r7, [r0, #8]
{
   1ded8:	4606      	mov	r6, r0
		to_pin   = pin;
   1deda:	bf12      	itee	ne
   1dedc:	4625      	movne	r5, r4
		to_pin   = 31U;
   1dede:	251f      	moveq	r5, #31
		from_pin = 0U;
   1dee0:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
   1dee2:	f04f 0801 	mov.w	r8, #1
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   1dee6:	42ac      	cmp	r4, r5
   1dee8:	d902      	bls.n	1def0 <gpio_nrfx_pin_disable_callback+0x24>
	return res;
   1deea:	2000      	movs	r0, #0
}
   1deec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
   1def0:	68fb      	ldr	r3, [r7, #12]
   1def2:	fa08 f204 	lsl.w	r2, r8, r4
   1def6:	ea23 0302 	bic.w	r3, r3, r2
   1defa:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
   1defc:	4621      	mov	r1, r4
   1defe:	4630      	mov	r0, r6
   1df00:	f7f8 fb54 	bl	165ac <gpiote_pin_int_cfg>
		if (res != 0) {
   1df04:	2800      	cmp	r0, #0
   1df06:	d1f1      	bne.n	1deec <gpio_nrfx_pin_disable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   1df08:	3401      	adds	r4, #1
   1df0a:	b2e4      	uxtb	r4, r4
   1df0c:	e7eb      	b.n	1dee6 <gpio_nrfx_pin_disable_callback+0x1a>

0001df0e <gpio_nrfx_pin_enable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
   1df0e:	2901      	cmp	r1, #1
{
   1df10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
   1df14:	bf18      	it	ne
   1df16:	b2d4      	uxtbne	r4, r2
	struct gpio_nrfx_data *data = get_port_data(port);
   1df18:	6887      	ldr	r7, [r0, #8]
{
   1df1a:	4606      	mov	r6, r0
		to_pin   = pin;
   1df1c:	bf12      	itee	ne
   1df1e:	4625      	movne	r5, r4
		to_pin   = 31U;
   1df20:	251f      	moveq	r5, #31
		from_pin = 0U;
   1df22:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
   1df24:	f04f 0801 	mov.w	r8, #1
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   1df28:	42ac      	cmp	r4, r5
   1df2a:	d902      	bls.n	1df32 <gpio_nrfx_pin_enable_callback+0x24>
	return res;
   1df2c:	2000      	movs	r0, #0
}
   1df2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
   1df32:	68fb      	ldr	r3, [r7, #12]
   1df34:	fa08 f204 	lsl.w	r2, r8, r4
   1df38:	4313      	orrs	r3, r2
   1df3a:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
   1df3c:	4621      	mov	r1, r4
   1df3e:	4630      	mov	r0, r6
   1df40:	f7f8 fb34 	bl	165ac <gpiote_pin_int_cfg>
		if (res != 0) {
   1df44:	2800      	cmp	r0, #0
   1df46:	d1f2      	bne.n	1df2e <gpio_nrfx_pin_enable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   1df48:	3401      	adds	r4, #1
   1df4a:	b2e4      	uxtb	r4, r4
   1df4c:	e7ec      	b.n	1df28 <gpio_nrfx_pin_enable_callback+0x1a>

0001df4e <flash_nrf_write_protection>:
}
   1df4e:	2000      	movs	r0, #0
   1df50:	4770      	bx	lr

0001df52 <is_regular_addr_valid>:
{
   1df52:	b538      	push	{r3, r4, r5, lr}
   1df54:	4604      	mov	r4, r0
   1df56:	460d      	mov	r5, r1
	size_t flash_size = nrfx_nvmc_flash_size_get();
   1df58:	f000 f8a9 	bl	1e0ae <nrfx_nvmc_flash_size_get>
	if (addr >= flash_size ||
   1df5c:	4284      	cmp	r4, r0
   1df5e:	d209      	bcs.n	1df74 <is_regular_addr_valid+0x22>
   1df60:	2c00      	cmp	r4, #0
   1df62:	db07      	blt.n	1df74 <is_regular_addr_valid+0x22>
	    addr < 0 ||
   1df64:	42a8      	cmp	r0, r5
   1df66:	d305      	bcc.n	1df74 <is_regular_addr_valid+0x22>
	    (addr) + len > flash_size) {
   1df68:	442c      	add	r4, r5
	    len > flash_size ||
   1df6a:	4284      	cmp	r4, r0
   1df6c:	bf8c      	ite	hi
   1df6e:	2000      	movhi	r0, #0
   1df70:	2001      	movls	r0, #1
}
   1df72:	bd38      	pop	{r3, r4, r5, pc}
		return false;
   1df74:	2000      	movs	r0, #0
   1df76:	e7fc      	b.n	1df72 <is_regular_addr_valid+0x20>

0001df78 <flash_nrf_read>:
{
   1df78:	b570      	push	{r4, r5, r6, lr}
   1df7a:	460d      	mov	r5, r1
	if (is_regular_addr_valid(addr, len)) {
   1df7c:	4628      	mov	r0, r5
   1df7e:	4619      	mov	r1, r3
{
   1df80:	4616      	mov	r6, r2
   1df82:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
   1df84:	f7ff ffe5 	bl	1df52 <is_regular_addr_valid>
   1df88:	b138      	cbz	r0, 1df9a <flash_nrf_read+0x22>
	if (!len) {
   1df8a:	b14c      	cbz	r4, 1dfa0 <flash_nrf_read+0x28>
	memcpy(data, (void *)addr, len);
   1df8c:	4622      	mov	r2, r4
   1df8e:	4629      	mov	r1, r5
   1df90:	4630      	mov	r0, r6
   1df92:	f7fd f832 	bl	1affa <memcpy>
	return 0;
   1df96:	2000      	movs	r0, #0
}
   1df98:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   1df9a:	f06f 0015 	mvn.w	r0, #21
   1df9e:	e7fb      	b.n	1df98 <flash_nrf_read+0x20>
		return 0;
   1dfa0:	4620      	mov	r0, r4
   1dfa2:	e7f9      	b.n	1df98 <flash_nrf_read+0x20>

0001dfa4 <flash_get_page_info>:

#include <drivers/flash.h>

static int flash_get_page_info(struct device *dev, off_t offs,
				   bool use_addr, struct flash_pages_info *info)
{
   1dfa4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   1dfa8:	461d      	mov	r5, r3
	off_t group_offs = 0;
	u32_t num_in_group;
	off_t end = 0;
	size_t layout_size;

	api->page_layout(dev, &layout, &layout_size);
   1dfaa:	6843      	ldr	r3, [r0, #4]
{
   1dfac:	460c      	mov	r4, r1
	api->page_layout(dev, &layout, &layout_size);
   1dfae:	691b      	ldr	r3, [r3, #16]
   1dfb0:	4669      	mov	r1, sp
{
   1dfb2:	4616      	mov	r6, r2
	api->page_layout(dev, &layout, &layout_size);
   1dfb4:	aa01      	add	r2, sp, #4
   1dfb6:	4798      	blx	r3

	while (layout_size--) {
   1dfb8:	e9dd 1200 	ldrd	r1, r2, [sp]
   1dfbc:	2300      	movs	r3, #0
   1dfbe:	3a01      	subs	r2, #1
	off_t end = 0;
   1dfc0:	4618      	mov	r0, r3
	off_t group_offs = 0;
   1dfc2:	469e      	mov	lr, r3
	size_t page_count = 0;
   1dfc4:	469c      	mov	ip, r3
	while (layout_size--) {
   1dfc6:	1c57      	adds	r7, r2, #1
   1dfc8:	d102      	bne.n	1dfd0 <flash_get_page_info+0x2c>
		page_count += layout->pages_count;

		layout++;
	}

	return -EINVAL; /* page of the index doesn't exist */
   1dfca:	f06f 0015 	mvn.w	r0, #21
   1dfce:	e01a      	b.n	1e006 <flash_get_page_info+0x62>
		if (use_addr) {
   1dfd0:	f8d1 8000 	ldr.w	r8, [r1]
   1dfd4:	b1d6      	cbz	r6, 1e00c <flash_get_page_info+0x68>
			end += layout->pages_count * layout->pages_size;
   1dfd6:	684f      	ldr	r7, [r1, #4]
   1dfd8:	fb07 0008 	mla	r0, r7, r8, r0
		if (offs < end) {
   1dfdc:	42a0      	cmp	r0, r4
   1dfde:	f102 37ff 	add.w	r7, r2, #4294967295	; 0xffffffff
   1dfe2:	dd18      	ble.n	1e016 <flash_get_page_info+0x72>
   1dfe4:	9201      	str	r2, [sp, #4]
   1dfe6:	b103      	cbz	r3, 1dfea <flash_get_page_info+0x46>
   1dfe8:	9100      	str	r1, [sp, #0]
			info->size = layout->pages_size;
   1dfea:	9b00      	ldr	r3, [sp, #0]
   1dfec:	685b      	ldr	r3, [r3, #4]
   1dfee:	606b      	str	r3, [r5, #4]
			if (use_addr) {
   1dff0:	b176      	cbz	r6, 1e010 <flash_get_page_info+0x6c>
				num_in_group = (offs - group_offs) /
   1dff2:	eba4 040e 	sub.w	r4, r4, lr
   1dff6:	fbb4 f4f3 	udiv	r4, r4, r3
			info->start_offset = group_offs +
   1dffa:	fb04 e303 	mla	r3, r4, r3, lr
			info->index = page_count + num_in_group;
   1dffe:	4464      	add	r4, ip
			info->start_offset = group_offs +
   1e000:	602b      	str	r3, [r5, #0]
			info->index = page_count + num_in_group;
   1e002:	60ac      	str	r4, [r5, #8]
			return 0;
   1e004:	2000      	movs	r0, #0
}
   1e006:	b002      	add	sp, #8
   1e008:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			end += layout->pages_count;
   1e00c:	4440      	add	r0, r8
   1e00e:	e7e5      	b.n	1dfdc <flash_get_page_info+0x38>
				num_in_group = offs - page_count;
   1e010:	eba4 040c 	sub.w	r4, r4, ip
   1e014:	e7f1      	b.n	1dffa <flash_get_page_info+0x56>
		group_offs += layout->pages_count * layout->pages_size;
   1e016:	684b      	ldr	r3, [r1, #4]
		page_count += layout->pages_count;
   1e018:	44c4      	add	ip, r8
		group_offs += layout->pages_count * layout->pages_size;
   1e01a:	fb03 ee08 	mla	lr, r3, r8, lr
		layout++;
   1e01e:	3108      	adds	r1, #8
   1e020:	2301      	movs	r3, #1
   1e022:	463a      	mov	r2, r7
   1e024:	e7cf      	b.n	1dfc6 <flash_get_page_info+0x22>

0001e026 <z_impl_flash_get_page_info_by_offs>:

int z_impl_flash_get_page_info_by_offs(struct device *dev, off_t offs,
				      struct flash_pages_info *info)
{
	return flash_get_page_info(dev, offs, true, info);
   1e026:	4613      	mov	r3, r2
   1e028:	2201      	movs	r2, #1
   1e02a:	f7ff bfbb 	b.w	1dfa4 <flash_get_page_info>

0001e02e <flash_page_foreach>:

	return count;
}

void flash_page_foreach(struct device *dev, flash_page_cb cb, void *data)
{
   1e02e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	const struct flash_pages_layout *layout;
	struct flash_pages_info page_info;
	size_t block, num_blocks, page = 0, i;
	off_t off = 0;

	api->page_layout(dev, &layout, &num_blocks);
   1e032:	6843      	ldr	r3, [r0, #4]
{
   1e034:	b086      	sub	sp, #24
   1e036:	4689      	mov	r9, r1
   1e038:	4692      	mov	sl, r2
	api->page_layout(dev, &layout, &num_blocks);
   1e03a:	691b      	ldr	r3, [r3, #16]
   1e03c:	aa02      	add	r2, sp, #8
   1e03e:	a901      	add	r1, sp, #4
   1e040:	4798      	blx	r3
	off_t off = 0;
   1e042:	2400      	movs	r4, #0
	size_t block, num_blocks, page = 0, i;
   1e044:	46a0      	mov	r8, r4

	for (block = 0; block < num_blocks; block++) {
   1e046:	4625      	mov	r5, r4
   1e048:	9b02      	ldr	r3, [sp, #8]
   1e04a:	42ab      	cmp	r3, r5
   1e04c:	d802      	bhi.n	1e054 <flash_page_foreach+0x26>

			off += page_info.size;
			page++;
		}
	}
}
   1e04e:	b006      	add	sp, #24
   1e050:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		const struct flash_pages_layout *l = &layout[block];
   1e054:	9f01      	ldr	r7, [sp, #4]
   1e056:	eb07 07c5 	add.w	r7, r7, r5, lsl #3
		for (i = 0; i < l->pages_count; i++) {
   1e05a:	2600      	movs	r6, #0
		page_info.size = l->pages_size;
   1e05c:	687b      	ldr	r3, [r7, #4]
   1e05e:	9304      	str	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
   1e060:	683a      	ldr	r2, [r7, #0]
   1e062:	42b2      	cmp	r2, r6
   1e064:	eb08 0306 	add.w	r3, r8, r6
   1e068:	d802      	bhi.n	1e070 <flash_page_foreach+0x42>
	for (block = 0; block < num_blocks; block++) {
   1e06a:	3501      	adds	r5, #1
   1e06c:	4698      	mov	r8, r3
   1e06e:	e7eb      	b.n	1e048 <flash_page_foreach+0x1a>
			if (!cb(&page_info, data)) {
   1e070:	4651      	mov	r1, sl
   1e072:	a803      	add	r0, sp, #12
			page_info.start_offset = off;
   1e074:	9403      	str	r4, [sp, #12]
			page_info.index = page;
   1e076:	9305      	str	r3, [sp, #20]
			if (!cb(&page_info, data)) {
   1e078:	47c8      	blx	r9
   1e07a:	2800      	cmp	r0, #0
   1e07c:	d0e7      	beq.n	1e04e <flash_page_foreach+0x20>
			off += page_info.size;
   1e07e:	9b04      	ldr	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
   1e080:	3601      	adds	r6, #1
			off += page_info.size;
   1e082:	441c      	add	r4, r3
			page++;
   1e084:	e7ec      	b.n	1e060 <flash_page_foreach+0x32>

0001e086 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   1e086:	4700      	bx	r0

0001e088 <partial_word_create>:
{
   1e088:	b082      	sub	sp, #8
    value32 = 0xFFFFFFFF;
   1e08a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1e08e:	9301      	str	r3, [sp, #4]
    byte_shift = addr % NVMC_BYTES_IN_WORD;
   1e090:	f000 0003 	and.w	r0, r0, #3
   1e094:	ab01      	add	r3, sp, #4
   1e096:	4418      	add	r0, r3
   1e098:	440a      	add	r2, r1
    for (uint32_t i = 0; i < bytes_count; i++)
   1e09a:	4291      	cmp	r1, r2
   1e09c:	d102      	bne.n	1e0a4 <partial_word_create+0x1c>
}
   1e09e:	9801      	ldr	r0, [sp, #4]
   1e0a0:	b002      	add	sp, #8
   1e0a2:	4770      	bx	lr
        ((uint8_t *)&value32)[byte_shift] = bytes[i];
   1e0a4:	f811 3b01 	ldrb.w	r3, [r1], #1
   1e0a8:	f800 3b01 	strb.w	r3, [r0], #1
        byte_shift++;
   1e0ac:	e7f5      	b.n	1e09a <partial_word_create+0x12>

0001e0ae <nrfx_nvmc_flash_size_get>:
   1e0ae:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   1e0b2:	691a      	ldr	r2, [r3, #16]
NRF_STATIC_INLINE uint32_t nrf_ficr_codesize_get(NRF_FICR_Type const * p_reg)
{
#if defined(FICR_INFO_CODESIZE_CODESIZE_Msk)
    return p_reg->INFO.CODESIZE;
#else
    return p_reg->CODESIZE;
   1e0b4:	6958      	ldr	r0, [r3, #20]
}

uint32_t nrfx_nvmc_flash_size_get(void)
{
    return flash_total_size_get();
}
   1e0b6:	4350      	muls	r0, r2
   1e0b8:	4770      	bx	lr

0001e0ba <nrfx_nvmc_flash_page_size_get>:
    return p_reg->CODEPAGESIZE;
   1e0ba:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   1e0be:	6918      	ldr	r0, [r3, #16]

uint32_t nrfx_nvmc_flash_page_size_get(void)
{
    return flash_page_size_get();
}
   1e0c0:	4770      	bx	lr

0001e0c2 <nrfx_nvmc_flash_page_count_get>:
    return p_reg->CODESIZE;
   1e0c2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   1e0c6:	6958      	ldr	r0, [r3, #20]

uint32_t nrfx_nvmc_flash_page_count_get(void)
{
    return flash_page_count_get();
}
   1e0c8:	4770      	bx	lr

0001e0ca <nrf_twi_event_clear>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1e0ca:	2300      	movs	r3, #0
   1e0cc:	5043      	str	r3, [r0, r1]
{
   1e0ce:	b082      	sub	sp, #8
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   1e0d0:	5843      	ldr	r3, [r0, r1]
   1e0d2:	9301      	str	r3, [sp, #4]
    (void)dummy;
   1e0d4:	9b01      	ldr	r3, [sp, #4]
}
   1e0d6:	b002      	add	sp, #8
   1e0d8:	4770      	bx	lr

0001e0da <twi_send_byte>:
    if (p_cb->bytes_transferred < p_cb->curr_length)
   1e0da:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   1e0dc:	6a8a      	ldr	r2, [r1, #40]	; 0x28
   1e0de:	4293      	cmp	r3, r2
   1e0e0:	d208      	bcs.n	1e0f4 <twi_send_byte+0x1a>
        nrf_twi_txd_set(p_twi, p_cb->p_curr_buf[p_cb->bytes_transferred]);
   1e0e2:	6a4a      	ldr	r2, [r1, #36]	; 0x24
    p_reg->TXD = data;
   1e0e4:	5cd2      	ldrb	r2, [r2, r3]
   1e0e6:	f8c0 251c 	str.w	r2, [r0, #1308]	; 0x51c
        ++(p_cb->bytes_transferred);
   1e0ea:	3301      	adds	r3, #1
   1e0ec:	634b      	str	r3, [r1, #52]	; 0x34
    return true;
   1e0ee:	2301      	movs	r3, #1
}
   1e0f0:	4618      	mov	r0, r3
   1e0f2:	4770      	bx	lr
        if (p_cb->curr_tx_no_stop)
   1e0f4:	f891 302c 	ldrb.w	r3, [r1, #44]	; 0x2c
   1e0f8:	b11b      	cbz	r3, 1e102 <twi_send_byte+0x28>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1e0fa:	2301      	movs	r3, #1
   1e0fc:	61c3      	str	r3, [r0, #28]
            return false;
   1e0fe:	2300      	movs	r3, #0
   1e100:	e7f6      	b.n	1e0f0 <twi_send_byte+0x16>
        else if(TWI_FLAG_SUSPEND(p_cb->flags))
   1e102:	6a0a      	ldr	r2, [r1, #32]
   1e104:	f012 0f40 	tst.w	r2, #64	; 0x40
   1e108:	f04f 0201 	mov.w	r2, #1
   1e10c:	bf15      	itete	ne
   1e10e:	61c2      	strne	r2, [r0, #28]
   1e110:	6142      	streq	r2, [r0, #20]
            p_cb->prev_suspend = TWI_SUSPEND_TX;
   1e112:	f881 202d 	strbne.w	r2, [r1, #45]	; 0x2d
    return true;
   1e116:	4613      	moveq	r3, r2
   1e118:	e7ea      	b.n	1e0f0 <twi_send_byte+0x16>

0001e11a <twi_transfer>:
    bool do_stop_check = ((p_cb->error) || ((p_cb->bytes_transferred) == p_cb->curr_length));
   1e11a:	f891 202f 	ldrb.w	r2, [r1, #47]	; 0x2f
{
   1e11e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e120:	4604      	mov	r4, r0
   1e122:	460d      	mov	r5, r1
    bool do_stop_check = ((p_cb->error) || ((p_cb->bytes_transferred) == p_cb->curr_length));
   1e124:	2a00      	cmp	r2, #0
   1e126:	d160      	bne.n	1e1ea <twi_transfer+0xd0>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1e128:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
   1e12c:	6b4e      	ldr	r6, [r1, #52]	; 0x34
   1e12e:	6a8f      	ldr	r7, [r1, #40]	; 0x28
    else if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_ERROR))
   1e130:	b1b3      	cbz	r3, 1e160 <twi_transfer+0x46>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
   1e132:	f44f 7192 	mov.w	r1, #292	; 0x124
                nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
   1e136:	f7ff ffc8 	bl	1e0ca <nrf_twi_event_clear>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1e13a:	2301      	movs	r3, #1
   1e13c:	6163      	str	r3, [r4, #20]
                p_cb->error = true;
   1e13e:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    if (do_stop_check && nrf_twi_event_check(p_twi, NRF_TWI_EVENT_STOPPED))
   1e142:	42be      	cmp	r6, r7
   1e144:	d14f      	bne.n	1e1e6 <twi_transfer+0xcc>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1e146:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
   1e14a:	2b00      	cmp	r3, #0
   1e14c:	d04b      	beq.n	1e1e6 <twi_transfer+0xcc>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_STOPPED);
   1e14e:	f44f 7182 	mov.w	r1, #260	; 0x104
   1e152:	4620      	mov	r0, r4
   1e154:	f7ff ffb9 	bl	1e0ca <nrf_twi_event_clear>
        p_cb->prev_suspend = TWI_NO_SUSPEND;
   1e158:	2200      	movs	r2, #0
   1e15a:	f885 202d 	strb.w	r2, [r5, #45]	; 0x2d
        return false;
   1e15e:	e013      	b.n	1e188 <twi_transfer+0x6e>
   1e160:	f8d0 311c 	ldr.w	r3, [r0, #284]	; 0x11c
        if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_TXDSENT))
   1e164:	b193      	cbz	r3, 1e18c <twi_transfer+0x72>
            nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_TXDSENT);
   1e166:	f44f 718e 	mov.w	r1, #284	; 0x11c
   1e16a:	f7ff ffae 	bl	1e0ca <nrf_twi_event_clear>
   1e16e:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
            if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_ERROR))
   1e172:	b11b      	cbz	r3, 1e17c <twi_transfer+0x62>
                nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
   1e174:	f44f 7192 	mov.w	r1, #292	; 0x124
   1e178:	4620      	mov	r0, r4
   1e17a:	e7dc      	b.n	1e136 <twi_transfer+0x1c>
                if (!twi_send_byte(p_twi, p_cb))
   1e17c:	4629      	mov	r1, r5
   1e17e:	f7ff ffac 	bl	1e0da <twi_send_byte>
   1e182:	4602      	mov	r2, r0
   1e184:	2800      	cmp	r0, #0
   1e186:	d1dc      	bne.n	1e142 <twi_transfer+0x28>
}
   1e188:	4610      	mov	r0, r2
   1e18a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e18c:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
        else if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_RXDREADY))
   1e190:	2b00      	cmp	r3, #0
   1e192:	d0d6      	beq.n	1e142 <twi_transfer+0x28>
            nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_RXDREADY);
   1e194:	f44f 7184 	mov.w	r1, #264	; 0x108
   1e198:	f7ff ff97 	bl	1e0ca <nrf_twi_event_clear>
   1e19c:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
            if (nrf_twi_event_check(p_twi, NRF_TWI_EVENT_ERROR))
   1e1a0:	2b00      	cmp	r3, #0
   1e1a2:	d1e7      	bne.n	1e174 <twi_transfer+0x5a>
    if (p_cb->bytes_transferred < p_cb->curr_length)
   1e1a4:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   1e1a6:	6aa9      	ldr	r1, [r5, #40]	; 0x28
   1e1a8:	428b      	cmp	r3, r1
   1e1aa:	d2ca      	bcs.n	1e142 <twi_transfer+0x28>
        p_cb->p_curr_buf[p_cb->bytes_transferred] = nrf_twi_rxd_get(p_twi);
   1e1ac:	6a69      	ldr	r1, [r5, #36]	; 0x24
    return (uint8_t)p_reg->RXD;
   1e1ae:	f8d0 0518 	ldr.w	r0, [r0, #1304]	; 0x518
   1e1b2:	54c8      	strb	r0, [r1, r3]
        ++(p_cb->bytes_transferred);
   1e1b4:	6b6b      	ldr	r3, [r5, #52]	; 0x34
        if ((p_cb->bytes_transferred == p_cb->curr_length - 1) && (!TWI_FLAG_SUSPEND(p_cb->flags)))
   1e1b6:	6aa9      	ldr	r1, [r5, #40]	; 0x28
        ++(p_cb->bytes_transferred);
   1e1b8:	3301      	adds	r3, #1
        if ((p_cb->bytes_transferred == p_cb->curr_length - 1) && (!TWI_FLAG_SUSPEND(p_cb->flags)))
   1e1ba:	1e48      	subs	r0, r1, #1
   1e1bc:	4283      	cmp	r3, r0
        ++(p_cb->bytes_transferred);
   1e1be:	636b      	str	r3, [r5, #52]	; 0x34
        if ((p_cb->bytes_transferred == p_cb->curr_length - 1) && (!TWI_FLAG_SUSPEND(p_cb->flags)))
   1e1c0:	d108      	bne.n	1e1d4 <twi_transfer+0xba>
   1e1c2:	6a28      	ldr	r0, [r5, #32]
   1e1c4:	0640      	lsls	r0, r0, #25
   1e1c6:	d41d      	bmi.n	1e204 <twi_transfer+0xea>
    p_reg->SHORTS = mask;
   1e1c8:	2302      	movs	r3, #2
   1e1ca:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1e1ce:	2301      	movs	r3, #1
   1e1d0:	6223      	str	r3, [r4, #32]
   1e1d2:	e7b6      	b.n	1e142 <twi_transfer+0x28>
        else if (p_cb->bytes_transferred == p_cb->curr_length && (!TWI_FLAG_SUSPEND(p_cb->flags)))
   1e1d4:	428b      	cmp	r3, r1
   1e1d6:	d1fa      	bne.n	1e1ce <twi_transfer+0xb4>
   1e1d8:	6a2b      	ldr	r3, [r5, #32]
   1e1da:	065b      	lsls	r3, r3, #25
   1e1dc:	d5b1      	bpl.n	1e142 <twi_transfer+0x28>
            p_cb->prev_suspend = TWI_SUSPEND_RX;
   1e1de:	2302      	movs	r3, #2
   1e1e0:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
            return false;
   1e1e4:	e7d0      	b.n	1e188 <twi_transfer+0x6e>
    return true;
   1e1e6:	2201      	movs	r2, #1
   1e1e8:	e7ce      	b.n	1e188 <twi_transfer+0x6e>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_ERROR);
   1e1ea:	f44f 7192 	mov.w	r1, #292	; 0x124
   1e1ee:	f7ff ff6c 	bl	1e0ca <nrf_twi_event_clear>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_TXDSENT);
   1e1f2:	f44f 718e 	mov.w	r1, #284	; 0x11c
   1e1f6:	f7ff ff68 	bl	1e0ca <nrf_twi_event_clear>
        nrf_twi_event_clear(p_twi, NRF_TWI_EVENT_RXDREADY);
   1e1fa:	f44f 7184 	mov.w	r1, #264	; 0x108
   1e1fe:	f7ff ff64 	bl	1e0ca <nrf_twi_event_clear>
    if (do_stop_check && nrf_twi_event_check(p_twi, NRF_TWI_EVENT_STOPPED))
   1e202:	e7a0      	b.n	1e146 <twi_transfer+0x2c>
        else if (p_cb->bytes_transferred == p_cb->curr_length && (!TWI_FLAG_SUSPEND(p_cb->flags)))
   1e204:	428b      	cmp	r3, r1
   1e206:	d1e2      	bne.n	1e1ce <twi_transfer+0xb4>
   1e208:	e7e9      	b.n	1e1de <twi_transfer+0xc4>

0001e20a <arch_system_halt>:
	__asm__ volatile(
   1e20a:	f04f 0220 	mov.w	r2, #32
   1e20e:	f3ef 8311 	mrs	r3, BASEPRI
   1e212:	f382 8811 	msr	BASEPRI, r2
   1e216:	f3bf 8f6f 	isb	sy
	}
   1e21a:	e7fe      	b.n	1e21a <arch_system_halt+0x10>

0001e21c <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
   1e21c:	f7fc be12 	b.w	1ae44 <z_clock_idle_exit>

0001e220 <k_mem_slab_init>:
{
   1e220:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
   1e222:	2400      	movs	r4, #0
	slab->block_size = block_size;
   1e224:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->free_list = NULL;
   1e228:	e9c0 4405 	strd	r4, r4, [r0, #20]
	slab->buffer = buffer;
   1e22c:	6101      	str	r1, [r0, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
   1e22e:	42a3      	cmp	r3, r4
   1e230:	d102      	bne.n	1e238 <k_mem_slab_init+0x18>
	list->tail = (sys_dnode_t *)list;
   1e232:	e9c0 0000 	strd	r0, r0, [r0]
}
   1e236:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
   1e238:	6945      	ldr	r5, [r0, #20]
   1e23a:	600d      	str	r5, [r1, #0]
	for (j = 0U; j < slab->num_blocks; j++) {
   1e23c:	3401      	adds	r4, #1
		slab->free_list = p;
   1e23e:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
   1e240:	4411      	add	r1, r2
   1e242:	e7f4      	b.n	1e22e <k_mem_slab_init+0xe>

0001e244 <k_mem_pool_malloc>:
{
   1e244:	b513      	push	{r0, r1, r4, lr}
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
   1e246:	2404      	movs	r4, #4
   1e248:	190a      	adds	r2, r1, r4
   1e24a:	d204      	bcs.n	1e256 <k_mem_pool_malloc+0x12>
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
   1e24c:	2300      	movs	r3, #0
   1e24e:	4669      	mov	r1, sp
   1e250:	f7f9 fc82 	bl	17b58 <k_mem_pool_alloc>
   1e254:	b110      	cbz	r0, 1e25c <k_mem_pool_malloc+0x18>
		return NULL;
   1e256:	2000      	movs	r0, #0
}
   1e258:	b002      	add	sp, #8
   1e25a:	bd10      	pop	{r4, pc}
	(void)memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));
   1e25c:	4622      	mov	r2, r4
   1e25e:	a901      	add	r1, sp, #4
   1e260:	9800      	ldr	r0, [sp, #0]
   1e262:	f7fc feca 	bl	1affa <memcpy>
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
   1e266:	9800      	ldr	r0, [sp, #0]
   1e268:	3004      	adds	r0, #4
   1e26a:	e7f5      	b.n	1e258 <k_mem_pool_malloc+0x14>

0001e26c <k_free>:
	if (ptr != NULL) {
   1e26c:	b110      	cbz	r0, 1e274 <k_free+0x8>
		k_mem_pool_free_id(ptr);
   1e26e:	3804      	subs	r0, #4
   1e270:	f7f9 bcbe 	b.w	17bf0 <k_mem_pool_free_id>
}
   1e274:	4770      	bx	lr

0001e276 <z_impl_k_mutex_init>:
	mutex->owner = NULL;
   1e276:	2300      	movs	r3, #0
	mutex->lock_count = 0U;
   1e278:	e9c0 3302 	strd	r3, r3, [r0, #8]
   1e27c:	e9c0 0000 	strd	r0, r0, [r0]
}
   1e280:	4770      	bx	lr

0001e282 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static s32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			  bool alloc)
{
   1e282:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1e286:	4604      	mov	r4, r0
   1e288:	460f      	mov	r7, r1
   1e28a:	4690      	mov	r8, r2
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   1e28c:	f100 0508 	add.w	r5, r0, #8
   1e290:	f04f 0220 	mov.w	r2, #32
   1e294:	f3ef 8611 	mrs	r6, BASEPRI
   1e298:	f382 8811 	msr	BASEPRI, r2
   1e29c:	f3bf 8f6f 	isb	sy
		return 0;
	}
#endif /* !CONFIG_POLL */

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
   1e2a0:	b1db      	cbz	r3, 1e2da <queue_insert+0x58>
		struct alloc_node *anode;

		anode = z_thread_malloc(sizeof(*anode));
   1e2a2:	2008      	movs	r0, #8
   1e2a4:	f7f9 fcd0 	bl	17c48 <z_thread_malloc>
		if (anode == NULL) {
   1e2a8:	b938      	cbnz	r0, 1e2ba <queue_insert+0x38>
	__asm__ volatile(
   1e2aa:	f386 8811 	msr	BASEPRI, r6
   1e2ae:	f3bf 8f6f 	isb	sy
			k_spin_unlock(&queue->lock, key);
			return -ENOMEM;
   1e2b2:	f06f 000b 	mvn.w	r0, #11
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
#endif /* CONFIG_POLL */

	z_reschedule(&queue->lock, key);
	return 0;
}
   1e2b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, u8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
   1e2ba:	2301      	movs	r3, #1
		anode->data = data;
   1e2bc:	f8c0 8004 	str.w	r8, [r0, #4]
   1e2c0:	6003      	str	r3, [r0, #0]
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
   1e2c2:	6803      	ldr	r3, [r0, #0]
   1e2c4:	f003 0203 	and.w	r2, r3, #3
   1e2c8:	b95f      	cbnz	r7, 1e2e2 <queue_insert+0x60>
	parent->next_and_flags = cur_flags | (unative_t)child;
   1e2ca:	6823      	ldr	r3, [r4, #0]
   1e2cc:	4313      	orrs	r3, r2
   1e2ce:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   1e2d0:	6863      	ldr	r3, [r4, #4]
	list->head = node;
   1e2d2:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   1e2d4:	b973      	cbnz	r3, 1e2f4 <queue_insert+0x72>
	list->tail = node;
   1e2d6:	6060      	str	r0, [r4, #4]
   1e2d8:	e00c      	b.n	1e2f4 <queue_insert+0x72>
	node->next_and_flags = flags;
   1e2da:	f8c8 3000 	str.w	r3, [r8]
   1e2de:	4640      	mov	r0, r8
   1e2e0:	e7ef      	b.n	1e2c2 <queue_insert+0x40>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   1e2e2:	683b      	ldr	r3, [r7, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   1e2e4:	f033 0303 	bics.w	r3, r3, #3
   1e2e8:	d114      	bne.n	1e314 <queue_insert+0x92>
	parent->next_and_flags = cur_flags | (unative_t)child;
   1e2ea:	6002      	str	r2, [r0, #0]
Z_GENLIST_APPEND(sflist, sfnode)
   1e2ec:	6862      	ldr	r2, [r4, #4]
   1e2ee:	b95a      	cbnz	r2, 1e308 <queue_insert+0x86>
	list->head = node;
   1e2f0:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   1e2f4:	2104      	movs	r1, #4
   1e2f6:	4628      	mov	r0, r5
   1e2f8:	f000 fbba 	bl	1ea70 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   1e2fc:	4628      	mov	r0, r5
   1e2fe:	4631      	mov	r1, r6
   1e300:	f000 f8ed 	bl	1e4de <z_reschedule>
	return 0;
   1e304:	2000      	movs	r0, #0
   1e306:	e7d6      	b.n	1e2b6 <queue_insert+0x34>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1e308:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   1e30a:	f003 0303 	and.w	r3, r3, #3
   1e30e:	4303      	orrs	r3, r0
   1e310:	6013      	str	r3, [r2, #0]
   1e312:	e7e0      	b.n	1e2d6 <queue_insert+0x54>
   1e314:	4313      	orrs	r3, r2
   1e316:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1e318:	683b      	ldr	r3, [r7, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   1e31a:	f003 0303 	and.w	r3, r3, #3
   1e31e:	4318      	orrs	r0, r3
   1e320:	6038      	str	r0, [r7, #0]
   1e322:	e7e7      	b.n	1e2f4 <queue_insert+0x72>

0001e324 <z_queue_node_peek>:
{
   1e324:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (u8_t)0)) {
   1e326:	4604      	mov	r4, r0
   1e328:	b130      	cbz	r0, 1e338 <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1e32a:	6802      	ldr	r2, [r0, #0]
   1e32c:	0793      	lsls	r3, r2, #30
   1e32e:	d003      	beq.n	1e338 <z_queue_node_peek+0x14>
		ret = anode->data;
   1e330:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   1e332:	b109      	cbz	r1, 1e338 <z_queue_node_peek+0x14>
			k_free(anode);
   1e334:	f7ff ff9a 	bl	1e26c <k_free>
}
   1e338:	4620      	mov	r0, r4
   1e33a:	bd10      	pop	{r4, pc}

0001e33c <z_impl_k_queue_init>:
	list->head = NULL;
   1e33c:	2300      	movs	r3, #0
	list->tail = NULL;
   1e33e:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dlist_init(&queue->poll_events);
   1e342:	f100 0308 	add.w	r3, r0, #8
   1e346:	e9c0 3302 	strd	r3, r3, [r0, #8]
}
   1e34a:	4770      	bx	lr

0001e34c <k_queue_append>:
	(void)queue_insert(queue, prev, data, false);
}

void k_queue_append(struct k_queue *queue, void *data)
{
	(void)queue_insert(queue, sys_sflist_peek_tail(&queue->data_q),
   1e34c:	460a      	mov	r2, r1
   1e34e:	2300      	movs	r3, #0
   1e350:	6841      	ldr	r1, [r0, #4]
   1e352:	f7ff bf96 	b.w	1e282 <queue_insert>

0001e356 <k_queue_prepend>:
			   data, false);
}

void k_queue_prepend(struct k_queue *queue, void *data)
{
	(void)queue_insert(queue, NULL, data, false);
   1e356:	2300      	movs	r3, #0
   1e358:	460a      	mov	r2, r1
   1e35a:	4619      	mov	r1, r3
   1e35c:	f7ff bf91 	b.w	1e282 <queue_insert>

0001e360 <k_queue_append_list>:
}
#include <syscalls/k_queue_alloc_prepend_mrsh.c>
#endif

void k_queue_append_list(struct k_queue *queue, void *head, void *tail)
{
   1e360:	b570      	push	{r4, r5, r6, lr}
	__ASSERT(head && tail, "invalid head or tail");

	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   1e362:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
   1e366:	f04f 0320 	mov.w	r3, #32
   1e36a:	f3ef 8611 	mrs	r6, BASEPRI
   1e36e:	f383 8811 	msr	BASEPRI, r3
   1e372:	f3bf 8f6f 	isb	sy
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   1e376:	6843      	ldr	r3, [r0, #4]
   1e378:	b95b      	cbnz	r3, 1e392 <k_queue_append_list+0x32>
	list->head = node;
   1e37a:	6001      	str	r1, [r0, #0]
	list->tail = node;
   1e37c:	6042      	str	r2, [r0, #4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   1e37e:	2104      	movs	r1, #4
   1e380:	4628      	mov	r0, r5
   1e382:	f000 fb75 	bl	1ea70 <z_handle_obj_poll_events>
#else
	sys_sflist_append_list(&queue->data_q, head, tail);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
#endif /* !CONFIG_POLL */

	z_reschedule(&queue->lock, key);
   1e386:	4631      	mov	r1, r6
   1e388:	4628      	mov	r0, r5
}
   1e38a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&queue->lock, key);
   1e38e:	f000 b8a6 	b.w	1e4de <z_reschedule>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1e392:	681c      	ldr	r4, [r3, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   1e394:	f004 0403 	and.w	r4, r4, #3
   1e398:	4321      	orrs	r1, r4
   1e39a:	6019      	str	r1, [r3, #0]
   1e39c:	e7ee      	b.n	1e37c <k_queue_append_list+0x1c>

0001e39e <z_impl_k_queue_get>:
	return val;
}
#endif /* CONFIG_POLL */

void *z_impl_k_queue_get(struct k_queue *queue, s32_t timeout)
{
   1e39e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1e3a2:	4604      	mov	r4, r0
   1e3a4:	b086      	sub	sp, #24
   1e3a6:	460d      	mov	r5, r1
   1e3a8:	f04f 0320 	mov.w	r3, #32
   1e3ac:	f3ef 8711 	mrs	r7, BASEPRI
   1e3b0:	f383 8811 	msr	BASEPRI, r3
   1e3b4:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(sflist)
   1e3b8:	6800      	ldr	r0, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   1e3ba:	b188      	cbz	r0, 1e3e0 <z_impl_k_queue_get+0x42>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   1e3bc:	6803      	ldr	r3, [r0, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   1e3be:	6862      	ldr	r2, [r4, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   1e3c0:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   1e3c4:	4290      	cmp	r0, r2
	list->head = node;
   1e3c6:	6023      	str	r3, [r4, #0]
	list->tail = node;
   1e3c8:	bf08      	it	eq
   1e3ca:	6063      	streq	r3, [r4, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   1e3cc:	2101      	movs	r1, #1
   1e3ce:	f7ff ffa9 	bl	1e324 <z_queue_node_peek>
	__asm__ volatile(
   1e3d2:	f387 8811 	msr	BASEPRI, r7
   1e3d6:	f3bf 8f6f 	isb	sy
#else
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);

	return (ret != 0) ? NULL : _current->base.swap_data;
#endif /* CONFIG_POLL */
}
   1e3da:	b006      	add	sp, #24
   1e3dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (timeout == K_NO_WAIT) {
   1e3e0:	2900      	cmp	r1, #0
   1e3e2:	d0f6      	beq.n	1e3d2 <z_impl_k_queue_get+0x34>
   1e3e4:	f387 8811 	msr	BASEPRI, r7
   1e3e8:	f3bf 8f6f 	isb	sy
	k_poll_event_init(&event, K_POLL_TYPE_FIFO_DATA_AVAILABLE,
   1e3ec:	2104      	movs	r1, #4
   1e3ee:	4602      	mov	r2, r0
   1e3f0:	4623      	mov	r3, r4
   1e3f2:	eb0d 0001 	add.w	r0, sp, r1
   1e3f6:	f7fa fb67 	bl	18ac8 <k_poll_event_init>
	if (timeout != K_FOREVER) {
   1e3fa:	1c6a      	adds	r2, r5, #1
   1e3fc:	d002      	beq.n	1e404 <z_impl_k_queue_get+0x66>
	return z_impl_k_uptime_get();
   1e3fe:	f000 fa04 	bl	1e80a <z_impl_k_uptime_get>
   1e402:	4606      	mov	r6, r0
{
   1e404:	2700      	movs	r7, #0
		event.state = K_POLL_STATE_NOT_READY;
   1e406:	9b04      	ldr	r3, [sp, #16]
   1e408:	f36f 3310 	bfc	r3, #12, #5
   1e40c:	9304      	str	r3, [sp, #16]
	return z_impl_k_poll(events, num_events, timeout);
   1e40e:	2101      	movs	r1, #1
   1e410:	1bea      	subs	r2, r5, r7
   1e412:	a801      	add	r0, sp, #4
   1e414:	f7fa fb6c 	bl	18af0 <z_impl_k_poll>
		if (err && err != -EAGAIN) {
   1e418:	b118      	cbz	r0, 1e422 <z_impl_k_queue_get+0x84>
   1e41a:	300b      	adds	r0, #11
   1e41c:	d001      	beq.n	1e422 <z_impl_k_queue_get+0x84>
			return NULL;
   1e41e:	2000      	movs	r0, #0
   1e420:	e7db      	b.n	1e3da <z_impl_k_queue_get+0x3c>
	__asm__ volatile(
   1e422:	f04f 0320 	mov.w	r3, #32
   1e426:	f3ef 8811 	mrs	r8, BASEPRI
   1e42a:	f383 8811 	msr	BASEPRI, r3
   1e42e:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(sflist)
   1e432:	6820      	ldr	r0, [r4, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_sfnode_t *sys_sflist_get(sys_sflist_t *list);

Z_GENLIST_GET(sflist, sfnode)
   1e434:	b138      	cbz	r0, 1e446 <z_impl_k_queue_get+0xa8>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   1e436:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   1e438:	6862      	ldr	r2, [r4, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   1e43a:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   1e43e:	4290      	cmp	r0, r2
	list->head = node;
   1e440:	6023      	str	r3, [r4, #0]
	list->tail = node;
   1e442:	bf08      	it	eq
   1e444:	6063      	streq	r3, [r4, #4]
		val = z_queue_node_peek(sys_sflist_get(&queue->data_q), true);
   1e446:	2101      	movs	r1, #1
   1e448:	f7ff ff6c 	bl	1e324 <z_queue_node_peek>
	__asm__ volatile(
   1e44c:	f388 8811 	msr	BASEPRI, r8
   1e450:	f3bf 8f6f 	isb	sy
		if ((val == NULL) && (timeout != K_FOREVER)) {
   1e454:	2800      	cmp	r0, #0
   1e456:	d1c0      	bne.n	1e3da <z_impl_k_queue_get+0x3c>
   1e458:	1c6b      	adds	r3, r5, #1
   1e45a:	d0d4      	beq.n	1e406 <z_impl_k_queue_get+0x68>
	return z_impl_k_uptime_get();
   1e45c:	f000 f9d5 	bl	1e80a <z_impl_k_uptime_get>
			elapsed = k_uptime_get_32() - start;
   1e460:	1b87      	subs	r7, r0, r6
	} while (!val && !done);
   1e462:	42bd      	cmp	r5, r7
   1e464:	dacf      	bge.n	1e406 <z_impl_k_queue_get+0x68>
   1e466:	e7da      	b.n	1e41e <z_impl_k_queue_get+0x80>

0001e468 <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1e468:	7b43      	ldrb	r3, [r0, #13]
   1e46a:	06db      	lsls	r3, r3, #27
   1e46c:	bf03      	ittte	eq
   1e46e:	6980      	ldreq	r0, [r0, #24]
   1e470:	fab0 f080 	clzeq	r0, r0
   1e474:	0940      	lsreq	r0, r0, #5
   1e476:	2000      	movne	r0, #0
}
   1e478:	4770      	bx	lr

0001e47a <z_is_t1_higher_prio_than_t2>:
	if (thread_1->base.prio < thread_2->base.prio) {
   1e47a:	f990 000e 	ldrsb.w	r0, [r0, #14]
   1e47e:	f991 300e 	ldrsb.w	r3, [r1, #14]
}
   1e482:	4298      	cmp	r0, r3
   1e484:	bfac      	ite	ge
   1e486:	2000      	movge	r0, #0
   1e488:	2001      	movlt	r0, #1
   1e48a:	4770      	bx	lr

0001e48c <z_find_first_thread_to_unpend>:
{
   1e48c:	b510      	push	{r4, lr}
	__asm__ volatile(
   1e48e:	f04f 0320 	mov.w	r3, #32
   1e492:	f3ef 8411 	mrs	r4, BASEPRI
   1e496:	f383 8811 	msr	BASEPRI, r3
   1e49a:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
   1e49e:	f000 f85d 	bl	1e55c <z_priq_dumb_best>
	__asm__ volatile(
   1e4a2:	f384 8811 	msr	BASEPRI, r4
   1e4a6:	f3bf 8f6f 	isb	sy
}
   1e4aa:	bd10      	pop	{r4, pc}

0001e4ac <z_unpend_thread_no_timeout>:
{
   1e4ac:	b538      	push	{r3, r4, r5, lr}
   1e4ae:	4604      	mov	r4, r0
	__asm__ volatile(
   1e4b0:	f04f 0320 	mov.w	r3, #32
   1e4b4:	f3ef 8511 	mrs	r5, BASEPRI
   1e4b8:	f383 8811 	msr	BASEPRI, r3
   1e4bc:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   1e4c0:	4601      	mov	r1, r0
   1e4c2:	6880      	ldr	r0, [r0, #8]
   1e4c4:	f7f9 fcd2 	bl	17e6c <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1e4c8:	7b63      	ldrb	r3, [r4, #13]
   1e4ca:	f023 0302 	bic.w	r3, r3, #2
   1e4ce:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   1e4d0:	f385 8811 	msr	BASEPRI, r5
   1e4d4:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   1e4d8:	2300      	movs	r3, #0
   1e4da:	60a3      	str	r3, [r4, #8]
}
   1e4dc:	bd38      	pop	{r3, r4, r5, pc}

0001e4de <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   1e4de:	b921      	cbnz	r1, 1e4ea <z_reschedule+0xc>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   1e4e0:	f3ef 8005 	mrs	r0, IPSR
   1e4e4:	b908      	cbnz	r0, 1e4ea <z_reschedule+0xc>
   1e4e6:	f7e5 bee3 	b.w	42b0 <arch_swap>
   1e4ea:	f381 8811 	msr	BASEPRI, r1
   1e4ee:	f3bf 8f6f 	isb	sy
}
   1e4f2:	4770      	bx	lr

0001e4f4 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   1e4f4:	4603      	mov	r3, r0
   1e4f6:	b920      	cbnz	r0, 1e502 <z_reschedule_irqlock+0xe>
   1e4f8:	f3ef 8205 	mrs	r2, IPSR
   1e4fc:	b90a      	cbnz	r2, 1e502 <z_reschedule_irqlock+0xe>
   1e4fe:	f7e5 bed7 	b.w	42b0 <arch_swap>
   1e502:	f383 8811 	msr	BASEPRI, r3
   1e506:	f3bf 8f6f 	isb	sy
}
   1e50a:	4770      	bx	lr

0001e50c <z_reschedule_unlocked>:
	__asm__ volatile(
   1e50c:	f04f 0320 	mov.w	r3, #32
   1e510:	f3ef 8011 	mrs	r0, BASEPRI
   1e514:	f383 8811 	msr	BASEPRI, r3
   1e518:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   1e51c:	f7ff bfea 	b.w	1e4f4 <z_reschedule_irqlock>

0001e520 <z_unpend_thread>:
{
   1e520:	b538      	push	{r3, r4, r5, lr}
   1e522:	4604      	mov	r4, r0
   1e524:	f04f 0320 	mov.w	r3, #32
   1e528:	f3ef 8511 	mrs	r5, BASEPRI
   1e52c:	f383 8811 	msr	BASEPRI, r3
   1e530:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   1e534:	4601      	mov	r1, r0
   1e536:	6880      	ldr	r0, [r0, #8]
   1e538:	f7f9 fc98 	bl	17e6c <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1e53c:	7b63      	ldrb	r3, [r4, #13]
   1e53e:	f023 0302 	bic.w	r3, r3, #2
   1e542:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   1e544:	f385 8811 	msr	BASEPRI, r5
   1e548:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   1e54c:	2300      	movs	r3, #0
   1e54e:	60a3      	str	r3, [r4, #8]
	return z_abort_timeout(&thread->base.timeout);
   1e550:	f104 0018 	add.w	r0, r4, #24
}
   1e554:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1e558:	f000 b913 	b.w	1e782 <z_abort_timeout>

0001e55c <z_priq_dumb_best>:
	return list->head == list;
   1e55c:	6803      	ldr	r3, [r0, #0]
}
   1e55e:	4298      	cmp	r0, r3
   1e560:	bf14      	ite	ne
   1e562:	4618      	movne	r0, r3
   1e564:	2000      	moveq	r0, #0
   1e566:	4770      	bx	lr

0001e568 <z_thread_timeout>:
	if (thread->base.pended_on != NULL) {
   1e568:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
   1e56c:	b570      	push	{r4, r5, r6, lr}
   1e56e:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
   1e570:	f1a0 0518 	sub.w	r5, r0, #24
	if (thread->base.pended_on != NULL) {
   1e574:	b1cb      	cbz	r3, 1e5aa <z_thread_timeout+0x42>
	__asm__ volatile(
   1e576:	f04f 0320 	mov.w	r3, #32
   1e57a:	f3ef 8611 	mrs	r6, BASEPRI
   1e57e:	f383 8811 	msr	BASEPRI, r3
   1e582:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   1e586:	4629      	mov	r1, r5
   1e588:	f850 0c10 	ldr.w	r0, [r0, #-16]
   1e58c:	f7f9 fc6e 	bl	17e6c <z_priq_dumb_remove>
   1e590:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   1e594:	f023 0302 	bic.w	r3, r3, #2
   1e598:	f804 3c0b 	strb.w	r3, [r4, #-11]
	__asm__ volatile(
   1e59c:	f386 8811 	msr	BASEPRI, r6
   1e5a0:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   1e5a4:	2300      	movs	r3, #0
   1e5a6:	f844 3c10 	str.w	r3, [r4, #-16]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   1e5aa:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   1e5ae:	f023 0314 	bic.w	r3, r3, #20
   1e5b2:	f804 3c0b 	strb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
   1e5b6:	4628      	mov	r0, r5
   1e5b8:	f7ff ff56 	bl	1e468 <z_is_thread_ready>
   1e5bc:	b120      	cbz	r0, 1e5c8 <z_thread_timeout+0x60>
		z_add_thread_to_ready_q(thread);
   1e5be:	4628      	mov	r0, r5
}
   1e5c0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1e5c4:	f7f9 bca2 	b.w	17f0c <z_add_thread_to_ready_q>
   1e5c8:	bd70      	pop	{r4, r5, r6, pc}

0001e5ca <z_unpend_first_thread>:
{
   1e5ca:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   1e5cc:	f04f 0320 	mov.w	r3, #32
   1e5d0:	f3ef 8211 	mrs	r2, BASEPRI
   1e5d4:	f383 8811 	msr	BASEPRI, r3
   1e5d8:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
   1e5dc:	f7ff ffbe 	bl	1e55c <z_priq_dumb_best>
   1e5e0:	4604      	mov	r4, r0
	__asm__ volatile(
   1e5e2:	f382 8811 	msr	BASEPRI, r2
   1e5e6:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   1e5ea:	b1c8      	cbz	r0, 1e620 <z_unpend_first_thread+0x56>
	__asm__ volatile(
   1e5ec:	f04f 0320 	mov.w	r3, #32
   1e5f0:	f3ef 8511 	mrs	r5, BASEPRI
   1e5f4:	f383 8811 	msr	BASEPRI, r3
   1e5f8:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   1e5fc:	4601      	mov	r1, r0
   1e5fe:	6880      	ldr	r0, [r0, #8]
   1e600:	f7f9 fc34 	bl	17e6c <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1e604:	7b63      	ldrb	r3, [r4, #13]
   1e606:	f023 0302 	bic.w	r3, r3, #2
   1e60a:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   1e60c:	f385 8811 	msr	BASEPRI, r5
   1e610:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   1e614:	2300      	movs	r3, #0
   1e616:	60a3      	str	r3, [r4, #8]
   1e618:	f104 0018 	add.w	r0, r4, #24
   1e61c:	f000 f8b1 	bl	1e782 <z_abort_timeout>
}
   1e620:	4620      	mov	r0, r4
   1e622:	bd38      	pop	{r3, r4, r5, pc}

0001e624 <z_unpend_all>:
{
   1e624:	b570      	push	{r4, r5, r6, lr}
   1e626:	4606      	mov	r6, r0
	int need_sched = 0;
   1e628:	2500      	movs	r5, #0
   1e62a:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1e62c:	42a6      	cmp	r6, r4
   1e62e:	d000      	beq.n	1e632 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   1e630:	b90c      	cbnz	r4, 1e636 <z_unpend_all+0x12>
}
   1e632:	4628      	mov	r0, r5
   1e634:	bd70      	pop	{r4, r5, r6, pc}
		z_unpend_thread(thread);
   1e636:	4620      	mov	r0, r4
   1e638:	f7ff ff72 	bl	1e520 <z_unpend_thread>
	if (z_is_thread_ready(thread)) {
   1e63c:	4620      	mov	r0, r4
   1e63e:	f7ff ff13 	bl	1e468 <z_is_thread_ready>
		need_sched = 1;
   1e642:	2501      	movs	r5, #1
   1e644:	2800      	cmp	r0, #0
   1e646:	d0f0      	beq.n	1e62a <z_unpend_all+0x6>
		z_add_thread_to_ready_q(thread);
   1e648:	4620      	mov	r0, r4
   1e64a:	f7f9 fc5f 	bl	17f0c <z_add_thread_to_ready_q>
   1e64e:	e7ec      	b.n	1e62a <z_unpend_all+0x6>

0001e650 <z_impl_k_sem_init>:
	sys_dlist_init(&sem->poll_events);
   1e650:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
   1e654:	e9c0 1202 	strd	r1, r2, [r0, #8]
	list->tail = (sys_dnode_t *)list;
   1e658:	e9c0 0000 	strd	r0, r0, [r0]
   1e65c:	e9c0 3304 	strd	r3, r3, [r0, #16]
}
   1e660:	4770      	bx	lr

0001e662 <z_impl_k_thread_name_set>:
}
   1e662:	f06f 0046 	mvn.w	r0, #70	; 0x46
   1e666:	4770      	bx	lr

0001e668 <k_thread_name_get>:
}
   1e668:	2000      	movs	r0, #0
   1e66a:	4770      	bx	lr

0001e66c <z_new_thread_init>:
{
   1e66c:	b510      	push	{r4, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
   1e66e:	9c02      	ldr	r4, [sp, #8]
   1e670:	7304      	strb	r4, [r0, #12]
	thread_base->thread_state = (u8_t)initial_state;

	thread_base->prio = priority;
   1e672:	7383      	strb	r3, [r0, #14]
	thread_base->thread_state = (u8_t)initial_state;
   1e674:	2404      	movs	r4, #4

	thread_base->sched_locked = 0U;
   1e676:	2300      	movs	r3, #0
	thread_base->thread_state = (u8_t)initial_state;
   1e678:	7344      	strb	r4, [r0, #13]
	thread_base->sched_locked = 0U;
   1e67a:	73c3      	strb	r3, [r0, #15]
	node->prev = NULL;
   1e67c:	e9c0 3306 	strd	r3, r3, [r0, #24]
	thread->fn_abort = NULL;
   1e680:	e9c0 3313 	strd	r3, r3, [r0, #76]	; 0x4c
	thread->stack_info.size = (u32_t)stackSize;
   1e684:	e9c0 1216 	strd	r1, r2, [r0, #88]	; 0x58
}
   1e688:	bd10      	pop	{r4, pc}

0001e68a <k_work_submit_to_queue>:
{
   1e68a:	b500      	push	{lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1e68c:	f101 0308 	add.w	r3, r1, #8
   1e690:	f3bf 8f5b 	dmb	ish
   1e694:	e853 2f00 	ldrex	r2, [r3]
   1e698:	f042 0c01 	orr.w	ip, r2, #1
   1e69c:	e843 ce00 	strex	lr, ip, [r3]
   1e6a0:	f1be 0f00 	cmp.w	lr, #0
   1e6a4:	d1f6      	bne.n	1e694 <k_work_submit_to_queue+0xa>
   1e6a6:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   1e6aa:	07d3      	lsls	r3, r2, #31
   1e6ac:	d403      	bmi.n	1e6b6 <k_work_submit_to_queue+0x2c>
}
   1e6ae:	f85d eb04 	ldr.w	lr, [sp], #4
		k_queue_append(&work_q->queue, work);
   1e6b2:	f7ff be4b 	b.w	1e34c <k_queue_append>
}
   1e6b6:	f85d fb04 	ldr.w	pc, [sp], #4

0001e6ba <work_timeout>:
	k_work_submit_to_queue(w->work_q, &w->work);
   1e6ba:	f1a0 010c 	sub.w	r1, r0, #12
   1e6be:	6900      	ldr	r0, [r0, #16]
   1e6c0:	f7ff bfe3 	b.w	1e68a <k_work_submit_to_queue>

0001e6c4 <work_cancel>:
{
   1e6c4:	b570      	push	{r4, r5, r6, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1e6c6:	f3bf 8f5b 	dmb	ish
   1e6ca:	6883      	ldr	r3, [r0, #8]
   1e6cc:	f3bf 8f5b 	dmb	ish
	if (k_work_pending(&work->work)) {
   1e6d0:	07db      	lsls	r3, r3, #31
{
   1e6d2:	4604      	mov	r4, r0
	return atomic_test_bit(work->flags, K_WORK_STATE_PENDING);
   1e6d4:	f100 0508 	add.w	r5, r0, #8
	if (k_work_pending(&work->work)) {
   1e6d8:	d532      	bpl.n	1e740 <work_cancel+0x7c>
		if (!k_queue_remove(&work->work_q->queue, &work->work)) {
   1e6da:	69c2      	ldr	r2, [r0, #28]
 * @return true if node was removed
 */
static inline bool sys_sflist_find_and_remove(sys_sflist_t *list,
					      sys_sfnode_t *node);

Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   1e6dc:	6813      	ldr	r3, [r2, #0]
   1e6de:	2100      	movs	r1, #0
   1e6e0:	b913      	cbnz	r3, 1e6e8 <work_cancel+0x24>
			return -EINVAL;
   1e6e2:	f06f 0015 	mvn.w	r0, #21
}
   1e6e6:	bd70      	pop	{r4, r5, r6, pc}
   1e6e8:	429c      	cmp	r4, r3
   1e6ea:	d124      	bne.n	1e736 <work_cancel+0x72>
Z_GENLIST_REMOVE(sflist, sfnode)
   1e6ec:	6823      	ldr	r3, [r4, #0]
   1e6ee:	6856      	ldr	r6, [r2, #4]
   1e6f0:	f023 0003 	bic.w	r0, r3, #3
   1e6f4:	b9b1      	cbnz	r1, 1e724 <work_cancel+0x60>
   1e6f6:	42b4      	cmp	r4, r6
	list->head = node;
   1e6f8:	6010      	str	r0, [r2, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
   1e6fa:	d100      	bne.n	1e6fe <work_cancel+0x3a>
	list->tail = node;
   1e6fc:	6050      	str	r0, [r2, #4]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1e6fe:	6823      	ldr	r3, [r4, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   1e700:	f003 0303 	and.w	r3, r3, #3
   1e704:	6023      	str	r3, [r4, #0]
	work->work_q = NULL;
   1e706:	2000      	movs	r0, #0
   1e708:	61e0      	str	r0, [r4, #28]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1e70a:	f3bf 8f5b 	dmb	ish
   1e70e:	e855 3f00 	ldrex	r3, [r5]
   1e712:	f023 0301 	bic.w	r3, r3, #1
   1e716:	e845 3200 	strex	r2, r3, [r5]
   1e71a:	2a00      	cmp	r2, #0
   1e71c:	d1f7      	bne.n	1e70e <work_cancel+0x4a>
   1e71e:	f3bf 8f5b 	dmb	ish
   1e722:	e7e0      	b.n	1e6e6 <work_cancel+0x22>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1e724:	680b      	ldr	r3, [r1, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   1e726:	f003 0303 	and.w	r3, r3, #3
   1e72a:	4303      	orrs	r3, r0
Z_GENLIST_REMOVE(sflist, sfnode)
   1e72c:	42b4      	cmp	r4, r6
	parent->next_and_flags = cur_flags | (unative_t)child;
   1e72e:	600b      	str	r3, [r1, #0]
	list->tail = node;
   1e730:	bf08      	it	eq
   1e732:	6051      	streq	r1, [r2, #4]
   1e734:	e7e3      	b.n	1e6fe <work_cancel+0x3a>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   1e736:	6818      	ldr	r0, [r3, #0]
Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   1e738:	4619      	mov	r1, r3
   1e73a:	f020 0303 	bic.w	r3, r0, #3
   1e73e:	e7cf      	b.n	1e6e0 <work_cancel+0x1c>
		(void)z_abort_timeout(&work->timeout);
   1e740:	300c      	adds	r0, #12
   1e742:	f000 f81e 	bl	1e782 <z_abort_timeout>
   1e746:	e7de      	b.n	1e706 <work_cancel+0x42>

0001e748 <k_delayed_work_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   1e748:	2300      	movs	r3, #0
   1e74a:	e9c0 3100 	strd	r3, r1, [r0]
	node->next = NULL;
   1e74e:	e9c0 3302 	strd	r3, r3, [r0, #8]
	node->prev = NULL;
   1e752:	6103      	str	r3, [r0, #16]
	work->work_q = NULL;
   1e754:	61c3      	str	r3, [r0, #28]
}
   1e756:	4770      	bx	lr

0001e758 <k_delayed_work_cancel>:

int k_delayed_work_cancel(struct k_delayed_work *work)
{
	if (!work->work_q) {
   1e758:	69c3      	ldr	r3, [r0, #28]
{
   1e75a:	b510      	push	{r4, lr}
	if (!work->work_q) {
   1e75c:	b173      	cbz	r3, 1e77c <k_delayed_work_cancel+0x24>
	__asm__ volatile(
   1e75e:	f04f 0320 	mov.w	r3, #32
   1e762:	f3ef 8411 	mrs	r4, BASEPRI
   1e766:	f383 8811 	msr	BASEPRI, r3
   1e76a:	f3bf 8f6f 	isb	sy
		return -EINVAL;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	int ret = work_cancel(work);
   1e76e:	f7ff ffa9 	bl	1e6c4 <work_cancel>
	__asm__ volatile(
   1e772:	f384 8811 	msr	BASEPRI, r4
   1e776:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
   1e77a:	bd10      	pop	{r4, pc}
		return -EINVAL;
   1e77c:	f06f 0015 	mvn.w	r0, #21
   1e780:	e7fb      	b.n	1e77a <k_delayed_work_cancel+0x22>

0001e782 <z_abort_timeout>:
{
   1e782:	b510      	push	{r4, lr}
	__asm__ volatile(
   1e784:	f04f 0220 	mov.w	r2, #32
   1e788:	f3ef 8411 	mrs	r4, BASEPRI
   1e78c:	f382 8811 	msr	BASEPRI, r2
   1e790:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   1e794:	6803      	ldr	r3, [r0, #0]
   1e796:	b13b      	cbz	r3, 1e7a8 <z_abort_timeout+0x26>
			remove_timeout(to);
   1e798:	f7fa f834 	bl	18804 <remove_timeout>
			ret = 0;
   1e79c:	2000      	movs	r0, #0
	__asm__ volatile(
   1e79e:	f384 8811 	msr	BASEPRI, r4
   1e7a2:	f3bf 8f6f 	isb	sy
}
   1e7a6:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   1e7a8:	f06f 0015 	mvn.w	r0, #21
   1e7ac:	e7f7      	b.n	1e79e <z_abort_timeout+0x1c>

0001e7ae <z_get_next_timeout_expiry>:
{
   1e7ae:	b510      	push	{r4, lr}
	__asm__ volatile(
   1e7b0:	f04f 0320 	mov.w	r3, #32
   1e7b4:	f3ef 8411 	mrs	r4, BASEPRI
   1e7b8:	f383 8811 	msr	BASEPRI, r3
   1e7bc:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   1e7c0:	f7fa f834 	bl	1882c <next_timeout>
	__asm__ volatile(
   1e7c4:	f384 8811 	msr	BASEPRI, r4
   1e7c8:	f3bf 8f6f 	isb	sy
}
   1e7cc:	bd10      	pop	{r4, pc}

0001e7ce <z_set_timeout_expiry>:
{
   1e7ce:	b570      	push	{r4, r5, r6, lr}
   1e7d0:	4604      	mov	r4, r0
   1e7d2:	460e      	mov	r6, r1
	__asm__ volatile(
   1e7d4:	f04f 0320 	mov.w	r3, #32
   1e7d8:	f3ef 8511 	mrs	r5, BASEPRI
   1e7dc:	f383 8811 	msr	BASEPRI, r3
   1e7e0:	f3bf 8f6f 	isb	sy
		int next = next_timeout();
   1e7e4:	f7fa f822 	bl	1882c <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   1e7e8:	2801      	cmp	r0, #1
   1e7ea:	dd05      	ble.n	1e7f8 <z_set_timeout_expiry+0x2a>
   1e7ec:	42a0      	cmp	r0, r4
   1e7ee:	dd03      	ble.n	1e7f8 <z_set_timeout_expiry+0x2a>
			z_clock_set_timeout(ticks, idle);
   1e7f0:	4631      	mov	r1, r6
   1e7f2:	4620      	mov	r0, r4
   1e7f4:	f7e5 fcc4 	bl	4180 <z_clock_set_timeout>
	__asm__ volatile(
   1e7f8:	f385 8811 	msr	BASEPRI, r5
   1e7fc:	f3bf 8f6f 	isb	sy
}
   1e800:	bd70      	pop	{r4, r5, r6, pc}

0001e802 <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
   1e802:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
   1e804:	f7fa f8f0 	bl	189e8 <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
   1e808:	bd08      	pop	{r3, pc}

0001e80a <z_impl_k_uptime_get>:

s64_t z_impl_k_uptime_get(void)
{
   1e80a:	b510      	push	{r4, lr}
	return k_ticks_to_ms_floor64(z_tick_get());
   1e80c:	f7fa f8ec 	bl	189e8 <z_tick_get>
			return (t * to_hz + off) / from_hz;
   1e810:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   1e814:	fba0 2304 	umull	r2, r3, r0, r4
   1e818:	fb04 3301 	mla	r3, r4, r1, r3
   1e81c:	0bd0      	lsrs	r0, r2, #15
}
   1e81e:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
   1e822:	0bd9      	lsrs	r1, r3, #15
   1e824:	bd10      	pop	{r4, pc}

0001e826 <k_timer_init>:
	timer->status = 0U;
   1e826:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   1e828:	e9c0 1206 	strd	r1, r2, [r0, #24]
   1e82c:	f100 0210 	add.w	r2, r0, #16
	timer->status = 0U;
   1e830:	6243      	str	r3, [r0, #36]	; 0x24
	list->tail = (sys_dnode_t *)list;
   1e832:	e9c0 2204 	strd	r2, r2, [r0, #16]
	node->prev = NULL;
   1e836:	e9c0 3300 	strd	r3, r3, [r0]
	timer->user_data = NULL;
   1e83a:	6283      	str	r3, [r0, #40]	; 0x28
}
   1e83c:	4770      	bx	lr

0001e83e <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   1e83e:	b510      	push	{r4, lr}
   1e840:	4604      	mov	r4, r0
	int inactive = z_abort_timeout(&timer->timeout) != 0;
   1e842:	f7ff ff9e 	bl	1e782 <z_abort_timeout>

	if (inactive) {
   1e846:	bb00      	cbnz	r0, 1e88a <z_impl_k_timer_stop+0x4c>
		return;
	}

	if (timer->stop_fn != NULL) {
   1e848:	69e3      	ldr	r3, [r4, #28]
   1e84a:	b10b      	cbz	r3, 1e850 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   1e84c:	4620      	mov	r0, r4
   1e84e:	4798      	blx	r3
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
   1e850:	f104 0010 	add.w	r0, r4, #16
   1e854:	2100      	movs	r1, #0
   1e856:	f7ff fe19 	bl	1e48c <z_find_first_thread_to_unpend>
	if (thread != NULL) {
   1e85a:	4604      	mov	r4, r0
   1e85c:	b1a8      	cbz	r0, 1e88a <z_impl_k_timer_stop+0x4c>
		z_unpend_thread_no_timeout(thread);
   1e85e:	f7ff fe25 	bl	1e4ac <z_unpend_thread_no_timeout>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1e862:	7b63      	ldrb	r3, [r4, #13]
   1e864:	06db      	lsls	r3, r3, #27
   1e866:	d104      	bne.n	1e872 <z_impl_k_timer_stop+0x34>
	if (z_is_thread_ready(thread)) {
   1e868:	69a3      	ldr	r3, [r4, #24]
   1e86a:	b913      	cbnz	r3, 1e872 <z_impl_k_timer_stop+0x34>
		z_add_thread_to_ready_q(thread);
   1e86c:	4620      	mov	r0, r4
   1e86e:	f7f9 fb4d 	bl	17f0c <z_add_thread_to_ready_q>
	__asm__ volatile(
   1e872:	f04f 0320 	mov.w	r3, #32
   1e876:	f3ef 8011 	mrs	r0, BASEPRI
   1e87a:	f383 8811 	msr	BASEPRI, r3
   1e87e:	f3bf 8f6f 	isb	sy

	if (pending_thread != NULL) {
		z_ready_thread(pending_thread);
		z_reschedule_unlocked();
	}
}
   1e882:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   1e886:	f7ff be35 	b.w	1e4f4 <z_reschedule_irqlock>
   1e88a:	bd10      	pop	{r4, pc}

0001e88c <clear_event_registrations>:
	while (num_events--) {
   1e88c:	2314      	movs	r3, #20
{
   1e88e:	b570      	push	{r4, r5, r6, lr}
   1e890:	fb03 0101 	mla	r1, r3, r1, r0
	event->poller = NULL;
   1e894:	2400      	movs	r4, #0
   1e896:	2601      	movs	r6, #1
	while (num_events--) {
   1e898:	4281      	cmp	r1, r0
   1e89a:	d100      	bne.n	1e89e <clear_event_registrations+0x12>
}
   1e89c:	bd70      	pop	{r4, r5, r6, pc}
	switch (event->type) {
   1e89e:	f811 3c07 	ldrb.w	r3, [r1, #-7]
	event->poller = NULL;
   1e8a2:	f841 4c0c 	str.w	r4, [r1, #-12]
	switch (event->type) {
   1e8a6:	f003 030f 	and.w	r3, r3, #15
   1e8aa:	2b04      	cmp	r3, #4
   1e8ac:	d80d      	bhi.n	1e8ca <clear_event_registrations+0x3e>
   1e8ae:	fa06 f303 	lsl.w	r3, r6, r3
   1e8b2:	f013 0f16 	tst.w	r3, #22
   1e8b6:	d008      	beq.n	1e8ca <clear_event_registrations+0x3e>
	if (remove && sys_dnode_is_linked(&event->_node)) {
   1e8b8:	f851 3c14 	ldr.w	r3, [r1, #-20]
   1e8bc:	b12b      	cbz	r3, 1e8ca <clear_event_registrations+0x3e>
	node->prev->next = node->next;
   1e8be:	f851 5c10 	ldr.w	r5, [r1, #-16]
   1e8c2:	602b      	str	r3, [r5, #0]
	node->next->prev = node->prev;
   1e8c4:	605d      	str	r5, [r3, #4]
	node->prev = NULL;
   1e8c6:	e941 4405 	strd	r4, r4, [r1, #-20]
	__asm__ volatile(
   1e8ca:	f382 8811 	msr	BASEPRI, r2
   1e8ce:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   1e8d2:	f04f 0320 	mov.w	r3, #32
   1e8d6:	f3ef 8211 	mrs	r2, BASEPRI
   1e8da:	f383 8811 	msr	BASEPRI, r3
   1e8de:	f3bf 8f6f 	isb	sy
   1e8e2:	3914      	subs	r1, #20
   1e8e4:	e7d8      	b.n	1e898 <clear_event_registrations+0xc>

0001e8e6 <signal_poll_event>:
{
   1e8e6:	b570      	push	{r4, r5, r6, lr}
	struct _poller *poller = event->poller;
   1e8e8:	6884      	ldr	r4, [r0, #8]
{
   1e8ea:	4605      	mov	r5, r0
   1e8ec:	460e      	mov	r6, r1
	if (poller) {
   1e8ee:	b19c      	cbz	r4, 1e918 <signal_poll_event+0x32>
		if (poller->cb != NULL) {
   1e8f0:	68a3      	ldr	r3, [r4, #8]
   1e8f2:	b95b      	cbnz	r3, 1e90c <signal_poll_event+0x26>
		poller->is_polling = false;
   1e8f4:	7023      	strb	r3, [r4, #0]
	int retcode = 0;
   1e8f6:	4618      	mov	r0, r3
	event->poller = NULL;
   1e8f8:	2300      	movs	r3, #0
   1e8fa:	60ab      	str	r3, [r5, #8]
	event->state |= state;
   1e8fc:	68eb      	ldr	r3, [r5, #12]
   1e8fe:	f3c3 3204 	ubfx	r2, r3, #12, #5
   1e902:	4316      	orrs	r6, r2
   1e904:	f366 3310 	bfi	r3, r6, #12, #5
   1e908:	60eb      	str	r3, [r5, #12]
	return retcode;
   1e90a:	e004      	b.n	1e916 <signal_poll_event+0x30>
			retcode = poller->cb(event, state);
   1e90c:	4798      	blx	r3
		poller->is_polling = false;
   1e90e:	2300      	movs	r3, #0
		if (retcode < 0) {
   1e910:	2800      	cmp	r0, #0
		poller->is_polling = false;
   1e912:	7023      	strb	r3, [r4, #0]
		if (retcode < 0) {
   1e914:	daf0      	bge.n	1e8f8 <signal_poll_event+0x12>
}
   1e916:	bd70      	pop	{r4, r5, r6, pc}
	int retcode = 0;
   1e918:	4620      	mov	r0, r4
   1e91a:	e7ed      	b.n	1e8f8 <signal_poll_event+0x12>

0001e91c <k_poll_poller_cb>:
{
   1e91c:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = event->poller->thread;
   1e91e:	6883      	ldr	r3, [r0, #8]
   1e920:	685c      	ldr	r4, [r3, #4]
	if (!z_is_thread_pending(thread)) {
   1e922:	7b63      	ldrb	r3, [r4, #13]
   1e924:	079a      	lsls	r2, r3, #30
{
   1e926:	460d      	mov	r5, r1
	if (!z_is_thread_pending(thread)) {
   1e928:	d401      	bmi.n	1e92e <k_poll_poller_cb+0x12>
		return 0;
   1e92a:	2000      	movs	r0, #0
}
   1e92c:	bd38      	pop	{r3, r4, r5, pc}
	if (z_is_thread_timeout_expired(thread)) {
   1e92e:	6a23      	ldr	r3, [r4, #32]
   1e930:	3302      	adds	r3, #2
   1e932:	d012      	beq.n	1e95a <k_poll_poller_cb+0x3e>
	z_unpend_thread(thread);
   1e934:	4620      	mov	r0, r4
   1e936:	f7ff fdf3 	bl	1e520 <z_unpend_thread>
	arch_thread_return_value_set(thread,
   1e93a:	2d08      	cmp	r5, #8
   1e93c:	bf0c      	ite	eq
   1e93e:	f06f 0303 	mvneq.w	r3, #3
   1e942:	2300      	movne	r3, #0
   1e944:	66a3      	str	r3, [r4, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1e946:	7b63      	ldrb	r3, [r4, #13]
   1e948:	06db      	lsls	r3, r3, #27
   1e94a:	d1ee      	bne.n	1e92a <k_poll_poller_cb+0xe>
	if (!z_is_thread_ready(thread)) {
   1e94c:	69a5      	ldr	r5, [r4, #24]
   1e94e:	2d00      	cmp	r5, #0
   1e950:	d1eb      	bne.n	1e92a <k_poll_poller_cb+0xe>
		z_add_thread_to_ready_q(thread);
   1e952:	4620      	mov	r0, r4
   1e954:	f7f9 fada 	bl	17f0c <z_add_thread_to_ready_q>
	return 0;
   1e958:	e7e7      	b.n	1e92a <k_poll_poller_cb+0xe>
		return -EAGAIN;
   1e95a:	f06f 000a 	mvn.w	r0, #10
   1e95e:	e7e5      	b.n	1e92c <k_poll_poller_cb+0x10>

0001e960 <add_event>:
{
   1e960:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e962:	4617      	mov	r7, r2
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   1e964:	e9d0 2300 	ldrd	r2, r3, [r0]
   1e968:	4290      	cmp	r0, r2
   1e96a:	4604      	mov	r4, r0
   1e96c:	460d      	mov	r5, r1
   1e96e:	d106      	bne.n	1e97e <add_event+0x1e>
	node->prev = list->tail;
   1e970:	6863      	ldr	r3, [r4, #4]
   1e972:	606b      	str	r3, [r5, #4]
	list->tail->next = node;
   1e974:	6863      	ldr	r3, [r4, #4]
	node->next = list;
   1e976:	602c      	str	r4, [r5, #0]
	list->tail->next = node;
   1e978:	601d      	str	r5, [r3, #0]
	list->tail = node;
   1e97a:	6065      	str	r5, [r4, #4]
}
   1e97c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
   1e97e:	2b00      	cmp	r3, #0
   1e980:	d0f6      	beq.n	1e970 <add_event+0x10>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
   1e982:	689b      	ldr	r3, [r3, #8]
   1e984:	6879      	ldr	r1, [r7, #4]
   1e986:	6858      	ldr	r0, [r3, #4]
   1e988:	f7ff fd77 	bl	1e47a <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
   1e98c:	2800      	cmp	r0, #0
   1e98e:	d1ef      	bne.n	1e970 <add_event+0x10>
	return list->head == list;
   1e990:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1e992:	42b4      	cmp	r4, r6
   1e994:	d0ec      	beq.n	1e970 <add_event+0x10>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   1e996:	2e00      	cmp	r6, #0
   1e998:	d0ea      	beq.n	1e970 <add_event+0x10>
		if (z_is_t1_higher_prio_than_t2(poller->thread,
   1e99a:	68b3      	ldr	r3, [r6, #8]
   1e99c:	6878      	ldr	r0, [r7, #4]
   1e99e:	6859      	ldr	r1, [r3, #4]
   1e9a0:	f7ff fd6b 	bl	1e47a <z_is_t1_higher_prio_than_t2>
   1e9a4:	b128      	cbz	r0, 1e9b2 <add_event+0x52>
	node->prev = successor->prev;
   1e9a6:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   1e9a8:	e9c5 6300 	strd	r6, r3, [r5]
	successor->prev->next = node;
   1e9ac:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   1e9ae:	6075      	str	r5, [r6, #4]
			return;
   1e9b0:	e7e4      	b.n	1e97c <add_event+0x1c>
	return (node == list->tail) ? NULL : node->next;
   1e9b2:	6863      	ldr	r3, [r4, #4]
   1e9b4:	429e      	cmp	r6, r3
   1e9b6:	d0db      	beq.n	1e970 <add_event+0x10>
   1e9b8:	6836      	ldr	r6, [r6, #0]
   1e9ba:	e7ec      	b.n	1e996 <add_event+0x36>

0001e9bc <register_events>:
{
   1e9bc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
   1e9c0:	f04f 0b00 	mov.w	fp, #0
{
   1e9c4:	4688      	mov	r8, r1
   1e9c6:	4615      	mov	r5, r2
   1e9c8:	4699      	mov	r9, r3
   1e9ca:	4604      	mov	r4, r0
	int events_registered = 0;
   1e9cc:	465e      	mov	r6, fp
	event->poller = NULL;
   1e9ce:	465f      	mov	r7, fp
	for (int ii = 0; ii < num_events; ii++) {
   1e9d0:	45c3      	cmp	fp, r8
   1e9d2:	db02      	blt.n	1e9da <register_events+0x1e>
}
   1e9d4:	4630      	mov	r0, r6
   1e9d6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e9da:	f04f 0320 	mov.w	r3, #32
   1e9de:	f3ef 8a11 	mrs	sl, BASEPRI
   1e9e2:	f383 8811 	msr	BASEPRI, r3
   1e9e6:	f3bf 8f6f 	isb	sy
	switch (event->type) {
   1e9ea:	7b63      	ldrb	r3, [r4, #13]
   1e9ec:	f003 030f 	and.w	r3, r3, #15
   1e9f0:	2b02      	cmp	r3, #2
   1e9f2:	d005      	beq.n	1ea00 <register_events+0x44>
   1e9f4:	2b04      	cmp	r3, #4
   1e9f6:	d006      	beq.n	1ea06 <register_events+0x4a>
   1e9f8:	2b01      	cmp	r3, #1
   1e9fa:	d118      	bne.n	1ea2e <register_events+0x72>
		if (event->signal->signaled != 0U) {
   1e9fc:	6922      	ldr	r2, [r4, #16]
   1e9fe:	e000      	b.n	1ea02 <register_events+0x46>
		if (k_sem_count_get(event->sem) > 0) {
   1ea00:	6922      	ldr	r2, [r4, #16]
		if (event->signal->signaled != 0U) {
   1ea02:	6892      	ldr	r2, [r2, #8]
   1ea04:	e001      	b.n	1ea0a <register_events+0x4e>
		if (!k_queue_is_empty(event->queue)) {
   1ea06:	6922      	ldr	r2, [r4, #16]
   1ea08:	6812      	ldr	r2, [r2, #0]
		if (event->signal->signaled != 0U) {
   1ea0a:	b182      	cbz	r2, 1ea2e <register_events+0x72>
	event->state |= state;
   1ea0c:	68e2      	ldr	r2, [r4, #12]
	event->poller = NULL;
   1ea0e:	60a7      	str	r7, [r4, #8]
	event->state |= state;
   1ea10:	f3c2 3104 	ubfx	r1, r2, #12, #5
   1ea14:	430b      	orrs	r3, r1
   1ea16:	f363 3210 	bfi	r2, r3, #12, #5
   1ea1a:	60e2      	str	r2, [r4, #12]
			poller->is_polling = false;
   1ea1c:	702f      	strb	r7, [r5, #0]
	__asm__ volatile(
   1ea1e:	f38a 8811 	msr	BASEPRI, sl
   1ea22:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
   1ea26:	f10b 0b01 	add.w	fp, fp, #1
   1ea2a:	3414      	adds	r4, #20
   1ea2c:	e7d0      	b.n	1e9d0 <register_events+0x14>
		} else if (!just_check && poller->is_polling) {
   1ea2e:	f1b9 0f00 	cmp.w	r9, #0
   1ea32:	d1f4      	bne.n	1ea1e <register_events+0x62>
   1ea34:	782b      	ldrb	r3, [r5, #0]
   1ea36:	2b00      	cmp	r3, #0
   1ea38:	d0f1      	beq.n	1ea1e <register_events+0x62>
	switch (event->type) {
   1ea3a:	7b63      	ldrb	r3, [r4, #13]
   1ea3c:	f003 030f 	and.w	r3, r3, #15
   1ea40:	2b02      	cmp	r3, #2
   1ea42:	d007      	beq.n	1ea54 <register_events+0x98>
   1ea44:	2b04      	cmp	r3, #4
   1ea46:	d00e      	beq.n	1ea66 <register_events+0xaa>
   1ea48:	2b01      	cmp	r3, #1
   1ea4a:	d109      	bne.n	1ea60 <register_events+0xa4>
		add_event(&event->signal->poll_events, event, poller);
   1ea4c:	462a      	mov	r2, r5
   1ea4e:	4621      	mov	r1, r4
   1ea50:	6920      	ldr	r0, [r4, #16]
   1ea52:	e003      	b.n	1ea5c <register_events+0xa0>
		add_event(&event->sem->poll_events, event, poller);
   1ea54:	6920      	ldr	r0, [r4, #16]
   1ea56:	462a      	mov	r2, r5
   1ea58:	4621      	mov	r1, r4
   1ea5a:	3010      	adds	r0, #16
		add_event(&event->signal->poll_events, event, poller);
   1ea5c:	f7ff ff80 	bl	1e960 <add_event>
	event->poller = poller;
   1ea60:	60a5      	str	r5, [r4, #8]
				events_registered += 1;
   1ea62:	3601      	adds	r6, #1
   1ea64:	e7db      	b.n	1ea1e <register_events+0x62>
		add_event(&event->queue->poll_events, event, poller);
   1ea66:	6920      	ldr	r0, [r4, #16]
   1ea68:	462a      	mov	r2, r5
   1ea6a:	4621      	mov	r1, r4
   1ea6c:	3008      	adds	r0, #8
   1ea6e:	e7f5      	b.n	1ea5c <register_events+0xa0>

0001ea70 <z_handle_obj_poll_events>:
	return list->head == list;
   1ea70:	6803      	ldr	r3, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
   1ea72:	4298      	cmp	r0, r3
   1ea74:	d009      	beq.n	1ea8a <z_handle_obj_poll_events+0x1a>
	node->prev->next = node->next;
   1ea76:	e9d3 2000 	ldrd	r2, r0, [r3]
   1ea7a:	6002      	str	r2, [r0, #0]
	node->next->prev = node->prev;
   1ea7c:	6050      	str	r0, [r2, #4]
	node->next = NULL;
   1ea7e:	2200      	movs	r2, #0
	node->prev = NULL;
   1ea80:	e9c3 2200 	strd	r2, r2, [r3]
		(void) signal_poll_event(poll_event, state);
   1ea84:	4618      	mov	r0, r3
   1ea86:	f7ff bf2e 	b.w	1e8e6 <signal_poll_event>
}
   1ea8a:	4770      	bx	lr

0001ea8c <_OffsetAbsSyms>:
					    sizeof(struct _preempt_float));
#else
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF, sizeof(struct k_thread));
#endif

GEN_ABS_SYM_END
   1ea8c:	4770      	bx	lr
