%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}




\title{open source watch Documentation}
\date{Jan 31, 2020}
\release{1.0.0}
\author{jj}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}
\noindent\sphinxincludegraphics{{zephyr_logo}.png}



\sphinxstylestrong{Note : You may at any time read the book, store it in your ereaders}

The book itself is subject to copyright.

You cannot use the book, or parts of the book into your own publications, without the permission of the author.


\chapter{author:}
\label{\detokenize{copyright:author}}
Jan Jansen
\sphinxhref{mailto:najnesnaj@yahoo.com}{najnesnaj@yahoo.com}


\chapter{LICENSE:}
\label{\detokenize{copyright:license}}
All the software is subject to the Apache 2.0 license (same as zephyr), which is very liberal.


\chapter{Zephyr for the pinetime smartwatch}
\label{\detokenize{content:zephyr-for-the-pinetime-smartwatch}}\label{\detokenize{content::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{this} \PYG{n}{document} \PYG{n}{describes} \PYG{n}{the} \PYG{n}{installation} \PYG{n}{of} \PYG{n}{zephyr} \PYG{n}{RTOS} \PYG{n}{on} \PYG{n}{the} \PYG{n}{PineTime} \PYG{n}{smartwatch}\PYG{o}{.}

\PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{wiki}\PYG{o}{.}\PYG{n}{pine64}\PYG{o}{.}\PYG{n}{org}\PYG{o}{/}\PYG{n}{index}\PYG{o}{.}\PYG{n}{php}\PYG{o}{/}\PYG{n}{PineTime}

\PYG{n}{It} \PYG{n}{should} \PYG{n}{be} \PYG{n}{applicable} \PYG{n}{on} \PYG{n}{other} \PYG{n}{nordic} \PYG{n}{nrf52832} \PYG{n}{based} \PYG{n}{watches} \PYG{p}{(}\PYG{n}{Desay} \PYG{n}{D6}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{the} \PYG{n}{approach} \PYG{o+ow}{in} \PYG{n}{this} \PYG{n}{manual} \PYG{o+ow}{is} \PYG{n}{to} \PYG{n}{get} \PYG{n}{quick} \PYG{n}{results} \PYG{p}{:}
    \PYG{o}{\PYGZhy{}} \PYG{n}{minimal} \PYG{n}{effort} \PYG{n}{install} \PYG{p}{(}\PYG{n}{pinetime} \PYG{n}{works} \PYG{k}{as} \PYG{n}{an} \PYG{n}{external} \PYG{p}{(}\PYG{n}{out} \PYG{n}{of} \PYG{n}{tree}\PYG{p}{)}
      \PYG{n}{application} \PYG{k}{for} \PYG{n}{zephyr}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{k}{try} \PYG{n}{out} \PYG{n}{the} \PYG{n}{samples}
    \PYG{o}{\PYGZhy{}} \PYG{n}{inspire} \PYG{n}{you} \PYG{n}{to} \PYG{n}{modify} \PYG{o+ow}{and} \PYG{n}{enhance}
\end{sphinxVerbatim}
\begin{description}
\item[{suggestion :}] \leavevmode\begin{itemize}
\item {} 
follow the installation instructions

\item {} 
try some examples

\item {} 
try out bluetooth

\item {} 
try out the display

\end{itemize}

\end{description}

\noindent\sphinxincludegraphics{{PineTime-830x400}.png}


\chapter{Install zephyr}
\label{\detokenize{installation:install-zephyr}}\label{\detokenize{installation::doc}}

\section{In case you already have zephyr installed:}
\label{\detokenize{installation:in-case-you-already-have-zephyr-installed}}
Pinetime works as external (out of tree) application.
You can clone pinetime next to zephyr in the working directory and update manifest and west.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{west} \PYG{n}{config} \PYG{n}{manifest}\PYG{o}{.}\PYG{n}{path} \PYG{n}{pinetime}
\end{sphinxVerbatim}


\section{In case you start from scratch :}
\label{\detokenize{installation:in-case-you-start-from-scratch}}
\sphinxurl{https://docs.zephyrproject.org/latest/getting\_started/index.html}

the documentation describes an installation process under Ubuntu/macOS/Windows

I picked Debian (which is not listed)
…. and soon afterwards ran into trouble

\sphinxtitleref{this behaviour is known as : stuborn or stupid, but I remain convinced it could work}

In the Zephyr getting started page :
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
select and update OS

\item {} 
install dependencies

\item {} 
Get the source code

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{instead} \PYG{n}{of} \PYG{n}{following} \PYG{n}{the} \PYG{n}{procedure}\PYG{p}{:}
       \PYG{n}{cd} \PYG{o}{\PYGZti{}}
       \PYG{n}{west} \PYG{n}{init} \PYG{n}{zephyrproject}
       \PYG{n}{cd} \PYG{n}{zephyrproject}
       \PYG{n}{west} \PYG{n}{update}

\PYG{n}{you} \PYG{n}{should} \PYG{n}{do} \PYG{n}{this} \PYG{p}{:}
        \PYG{n}{cd} \PYG{o}{\PYGZti{}}
        \PYG{n}{mkdir} \PYG{n}{work}
        \PYG{n}{cd} \PYG{n}{work}
        \PYG{n}{west} \PYG{n}{init} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{najnesnaj}\PYG{o}{/}\PYG{n}{pinetime}\PYG{o}{\PYGZhy{}}\PYG{n}{zephyr}
        \PYG{n}{west} \PYG{n}{update}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{3}
\item {} 
complete the other steps

\end{enumerate}

to test if your install works :

cd \textasciitilde{}/work/pinetime

west build -p -b pinetime samples/basic/blinky

\sphinxstylestrong{TIP : sometimes you run into trouble compiling: removing the build directory can help in that case}


\chapter{Starting with some basic applications}
\label{\detokenize{basicapplications:starting-with-some-basic-applications}}\label{\detokenize{basicapplications::doc}}
The best way to get a feel of zephyr for the PineTime watch, is to start building applications.

The gpio ports, i2c communication, memory layout, stuff that is particular for the watch is defined in the board definition file.

The provided samples are standard zephyr application, with some minor modifications.


\section{Blinky    example}
\label{\detokenize{basicapplications:blinky-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{watch} \PYG{n}{does} \PYG{o+ow}{not} \PYG{n}{contain} \PYG{n}{a} \PYG{n}{led} \PYG{k}{as} \PYG{n}{such}\PYG{p}{,} \PYG{n}{but} \PYG{n}{it} \PYG{n}{has} \PYG{n}{background} \PYG{n}{leds} \PYG{k}{for} \PYG{n}{the} \PYG{n}{LCD}\PYG{o}{.}

\PYG{n}{Once} \PYG{n}{lit}\PYG{p}{,} \PYG{n}{you} \PYG{n}{can} \PYG{n}{barely} \PYG{n}{see} \PYG{n}{it}\PYG{p}{,} \PYG{n}{cause} \PYG{n}{the} \PYG{n}{screen}\PYG{o}{\PYGZhy{}}\PYG{n}{LCD} \PYG{n}{remains} \PYG{n}{black}\PYG{o}{.}

\PYG{n}{The} \PYG{n}{screen} \PYG{n}{contains} \PYG{n}{three} \PYG{n}{leds}\PYG{p}{,} \PYG{n}{this} \PYG{n}{way} \PYG{n}{the} \PYG{n}{intensity} \PYG{o+ow}{is} \PYG{n+nb}{set}\PYG{o}{.}
\end{sphinxVerbatim}

have a look at the pinetime.dts file, here you see the definition of the background leds.

\sphinxtitleref{building an image, which can be found under the build directory}

see : {\hyperref[\detokenize{samples/basic/blinky/README:blinky-sample}]{\sphinxcrossref{\DUrole{std,std-ref}{Blinky Application}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} \PYGZti{}/work/pinetime
\PYG{g+gp}{\PYGZdl{}} west build \PYGZhy{}p \PYGZhy{}b pinetime samples/basic/blinky
\end{sphinxVerbatim}

once the compilation is completed,  you can find the firmware under :
\textasciitilde{}/work/pinetime/build/zephyr/zephyr.bin


\section{Reading out the button on the watch}
\label{\detokenize{basicapplications:reading-out-the-button-on-the-watch}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{does} \PYG{n}{have} \PYG{n}{a} \PYG{n}{button} \PYG{n}{on} \PYG{n}{the} \PYG{n}{side}\PYG{o}{.}

\PYG{n}{In} \PYG{n}{order} \PYG{n}{to} \PYG{n}{check} \PYG{k}{if} \PYG{n}{the} \PYG{n}{button} \PYG{o+ow}{is} \PYG{n}{pressed}\PYG{p}{,} \PYG{n}{it} \PYG{n}{sets} \PYG{n}{a} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{memory}\PYG{o}{.}
\PYG{n}{With} \PYG{n}{openocd} \PYG{n}{you} \PYG{n}{can} \PYG{n}{peek} \PYG{n}{at} \PYG{n}{this} \PYG{n}{memory} \PYG{n}{location}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{basicapplications:building-and-running}}
see : {\hyperref[\detokenize{samples/basic/button/README:button-sample}]{\sphinxcrossref{\DUrole{std,std-ref}{Button demo}}}}

\sphinxstyleemphasis{Note:}:
\sphinxtitleref{The watch has a button out port (15) and button in port (13). You have to set the out-port high. Took me a while to figure this out…}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/basic/button}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\#define MY\_REGISTER (*(volatile uint8\_t*)0x2000F000)

in the program you can set values:
MY\_REGISTER=(read button value);

this way you know till whether the code executes
\end{sphinxadmonition}

a way to set port 15 high (hard-coded of course :))

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{gpio\PYGZus{}pin\PYGZus{}configure(gpiob, 15,GPIO\PYGZus{}DIR\PYGZus{}OUT); //push button out}
\PYG{g+go}{gpio\PYGZus{}pin\PYGZus{}write(gpiob, 15, \PYGZam{}button\PYGZus{}out); //set port high}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

Peeking

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+gp}{\PYGZgt{}}mdw 0x2000F000 0x1
\PYG{g+go}{0x2000f000: 00000100 (switch pushed)}
\end{sphinxVerbatim}


\chapter{bluetooth (BLE) example}
\label{\detokenize{bluetooth:bluetooth-ble-example}}\label{\detokenize{bluetooth::doc}}
The PineTime uses a Nordic nrf52832 chip, which has BLE functionality build into it.

To test, you can compile a standard application : Eddy Stone.

The watch will behave as a bluetooth beacon, and you should be able to detect it with your smartphone or with bluez under linux.


\section{Using a standard zephyr application under pinetime:}
\label{\detokenize{bluetooth:using-a-standard-zephyr-application-under-pinetime}}
Each sample has its own directory.
In this directory you will notice a file : “CMakeLists.txt”.

In order to use a standard, you can just copy it under the pinetime directory.

In order to be able to compile it, you just have to add one line in the CMakeList.txt :

\sphinxtitleref{include(\$ENV\{ZEPHYR\_BASE\}/../pinetime/cmake/boilerplate.cmake)}

Have a look in the samples/bluetooth/eddystone directory.


\section{Eddy Stone}
\label{\detokenize{bluetooth:eddy-stone}}\begin{quote}

see:   {\hyperref[\detokenize{samples/bluetooth/eddystone/README:bluetooth-eddystone-sample}]{\sphinxcrossref{\DUrole{std,std-ref}{Bluetooth: Eddystone}}}}
\end{quote}

\sphinxstylestrong{Note:}  compile the provided example, so a build directory gets created

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} west build \PYGZhy{}p \PYGZhy{}b pinetime samples/bluetooth/eddystone
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{this builds an image, which can be found under the build directory}}


\section{Using the created bluetooth sample:}
\label{\detokenize{bluetooth:using-the-created-bluetooth-sample}}
I use linux with a bluetoothadapter 4.0.
You need to install bluez.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}bluetoothctl
\PYG{g+gp}{[bluetooth]\PYGZsh{}}scan on
\end{sphinxVerbatim}

And your Eddy Stone should be visible.

If you have a smartphone, you can download the nrf utilities app from nordic.


\section{Ble Peripheral}
\label{\detokenize{bluetooth:ble-peripheral}}
this example is a demo of the services under bluetooth

first build the image

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}}  west build \PYGZhy{}p \PYGZhy{}b pinetime samples/bluetooth/peripheral
\end{sphinxVerbatim}

With linux you can have a look using bluetoothctl:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}bluetoothctl
\PYG{g+gp}{[bluetooth]\PYGZsh{}}scan on


\PYG{g+go}{[NEW] Device 60:7C:9E:92:50:C1 Zephyr Peripheral Sample Long}
\PYG{g+go}{once you see your device}
\PYG{g+gp}{[blueooth]\PYGZsh{}}connect \PYG{l+m}{60}:7C:9E:92:50:C1 \PYG{o}{(}the device mac address as displayed\PYG{o}{)}

\PYG{g+go}{then you can already see the services}
\end{sphinxVerbatim}

same thing with the app from nordic, you could try to connect and display value of e.g. heart rate


\section{using Python to read out bluetoothservices}
\label{\detokenize{bluetooth:using-python-to-read-out-bluetoothservices}}
In this repo you will find a python script : readbat.py
In order to use it you need bluez on linux and the python \sphinxtitleref{bluepy} module.

It can be used in conjunction with the peripheral bluetooth demo.
It just reads out the battery level, and prints it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{binascii}
\PYG{k+kn}{from} \PYG{n+nn}{bluepy}\PYG{n+nn}{.}\PYG{n+nn}{btle} \PYG{k+kn}{import} \PYG{n}{UUID}\PYG{p}{,} \PYG{n}{Peripheral}

\PYG{n}{temp\PYGZus{}uuid} \PYG{o}{=} \PYG{n}{UUID}\PYG{p}{(}\PYG{l+m+mh}{0x2A19}\PYG{p}{)}

\PYG{n}{p} \PYG{o}{=} \PYG{n}{Peripheral}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{60:7C:9E:92:50:C1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{random}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{try}\PYG{p}{:}
   \PYG{n}{ch} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{getCharacteristics}\PYG{p}{(}\PYG{n}{uuid}\PYG{o}{=}\PYG{n}{temp\PYGZus{}uuid}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
   \PYG{n+nb}{print} \PYG{n}{binascii}\PYG{o}{.}\PYG{n}{b2a\PYGZus{}hex}\PYG{p}{(}\PYG{n}{ch}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{finally}\PYG{p}{:}
    \PYG{n}{p}\PYG{o}{.}\PYG{n}{disconnect}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{display (st7789)}
\label{\detokenize{display:display-st7789}}\label{\detokenize{display:display-sample}}\label{\detokenize{display::doc}}

\section{Display    example}
\label{\detokenize{display:display-example}}
This is just a simple display test.
It displays coloured squares, but it allows you to check if the screen is OK.

\sphinxstylestrong{TIP: While connecting 5V, do not connect 3.3V at the same time}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{watch} \PYG{n}{has} \PYG{n}{background} \PYG{n}{leds} \PYG{k}{for} \PYG{n}{the} \PYG{n}{LCD}\PYG{o}{.}

\PYG{n}{They} \PYG{n}{need} \PYG{n}{to} \PYG{n}{be} \PYG{n}{on} \PYG{p}{(}\PYG{n}{LOW}\PYG{p}{)} \PYG{n}{to} \PYG{n}{visualize} \PYG{n}{the} \PYG{n}{display}\PYG{o}{.}
\PYG{n}{Have} \PYG{n}{a} \PYG{n}{look} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{source} \PYG{n}{code}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}}  west build \PYGZhy{}p \PYGZhy{}b pinetime samples/display/st7789v
\end{sphinxVerbatim}

Once the compilation is completed you can upload the firmware.

If all goes well, you should see some coloured squares on your screen.

\sphinxstylestrong{Note : in order to get the display st7789 Picture-Perfect, you might need a zephyr patch}

have a look at : \sphinxurl{https://github.com/zephyrproject-rtos/zephyr/pull/20570/files}
You will find them in this repo under patches-zephyr.


\chapter{GFX Library Sample}
\label{\detokenize{gfx:gfx-library-sample}}\label{\detokenize{gfx:gfx-sample}}\label{\detokenize{gfx::doc}}

\section{Overview}
\label{\detokenize{gfx:overview}}
This sample is built on top of the ST7789 display sample ({\hyperref[\detokenize{display:display-sample}]{\sphinxcrossref{\DUrole{std,std-ref}{display (st7789)}}}}), extending it with the \sphinxhref{https://github.com/adafruit/Adafruit-GFX-Library}{Adafruit GFX Library}.
The library was ported from Arduino and has the same functionality and API.
See \sphinxcode{\sphinxupquote{src/main.cpp}} for examples on the GFX API usage.

See {\hyperref[\detokenize{display:display-sample}]{\sphinxcrossref{\DUrole{std,std-ref}{display (st7789)}}}} for more details on working with the display itself.


\section{Usage}
\label{\detokenize{gfx:usage}}
Add the gfx sample from this repo into your project:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} cp samples/gui/gfx \PYGZti{}/zephyrproject/zephyr/samples/gui/
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
In order to make the library work the sample is built with C++ support. This is achieved by having the following line in the sample’s \sphinxtitleref{prj.conf} configuration:

\sphinxcode{\sphinxupquote{CONFIG\_CPLUSPLUS=y}}
\end{sphinxadmonition}

Build \& flash the sample:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}}  west build \PYGZhy{}p \PYGZhy{}b pinetime samples/gui/gfx
\PYG{g+gp}{\PYGZdl{}}  west flash
\end{sphinxVerbatim}

If all goes well, you should see a looping graphical test: drawing lines, rectangles, triangles etc.


\chapter{LittlevGL Basic Sample}
\label{\detokenize{lvgl:littlevgl-basic-sample}}\label{\detokenize{lvgl:lvgl-sample}}\label{\detokenize{lvgl::doc}}

\section{Overview}
\label{\detokenize{lvgl:overview}}
This sample application displays “Hello World” in the center of the screen
and a counter at the bottom which increments every second.

LittlevGL is a free and open-source graphics library providing everything you need to create embedded GUI with easy-to-use graphical elements, beautiful visual effects and low memory footprint.


\section{Requirements}
\label{\detokenize{lvgl:requirements}}
The program has been modified to light up the background leds.

\sphinxstylestrong{TIP: matching label : DISPLAY}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Matching labels are necessary!
pinetime.conf:CONFIG\PYGZus{}LVGL\PYGZus{}DISPLAY\PYGZus{}DEV\PYGZus{}NAME=\PYGZdq{}DISPLAY\PYGZdq{}
pinetime.overlay:               label = \PYGZdq{}DISPLAY\PYGZdq{}; (spi definition)
\end{sphinxVerbatim}


\section{Building and Running}
\label{\detokenize{lvgl:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/gui/lvgl}
\end{sphinxVerbatim}


\subsection{modifying the font size :}
\label{\detokenize{lvgl:modifying-the-font-size}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}t menuconfig}
\end{sphinxVerbatim}
\begin{description}
\item[{goto:}] \leavevmode\begin{itemize}
\item {} 
additional libraries

\item {} 
lvgl gui library

\end{itemize}

(look for fonts, and adapt according to your need)

\end{description}


\subsection{apply changes of the changed config:}
\label{\detokenize{lvgl:apply-changes-of-the-changed-config}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build}
\end{sphinxVerbatim}

(instead of west build -p (pristine) which wipes out your customisation)


\section{Todo}
\label{\detokenize{lvgl:todo}}\begin{itemize}
\item {} 
Create a button

\item {} 
touchscreen activation (problem cause zephyr does not support this yet)

\item {} 
lvgl supports lv\_canvas\_rotate(canvas, \&imd\_dsc, angle, x, y, pivot\_x, pivot\_y) should be cool for a clock, chrono…

\end{itemize}


\section{References}
\label{\detokenize{lvgl:references}}
\sphinxurl{https://docs.littlevgl.com/en/html/index.html}

LittlevGL Web Page: \sphinxurl{https://littlevgl.com/}


\chapter{LittlevGL Clock Sample}
\label{\detokenize{clock:littlevgl-clock-sample}}\label{\detokenize{clock:lvgl-clock}}\label{\detokenize{clock::doc}}
see : {\hyperref[\detokenize{samples/gui/clock/README:clock-sample}]{\sphinxcrossref{\DUrole{std,std-ref}{LittlevGL Clock Sample}}}}


\section{Overview}
\label{\detokenize{clock:overview}}
This sample application displays a “clockbackground” in the center of the screen.

LittlevGL is a free and open-source graphics library providing everything you need to create embedded GUI with easy-to-use graphical elements, beautiful visual effects and low memory footprint.

\noindent\sphinxincludegraphics{{clockback}.png}


\section{Requirements}
\label{\detokenize{clock:requirements}}
Make sure the prj.conf contains the following :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CONFIG\PYGZus{}LVGL}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}LVGL\PYGZus{}OBJ\PYGZus{}IMAGE}\PYG{o}{=}\PYG{n}{y}
\end{sphinxVerbatim}

LitlevGL uses a “c” file to store the image.
You need to convert a jpg, or png image to this c file.
There is an online tool : \sphinxurl{https://littlevgl.com/image-to-c-array}


\section{Building and Running}
\label{\detokenize{clock:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/gui/clock}
\end{sphinxVerbatim}


\section{Todo}
\label{\detokenize{clock:todo}}\begin{itemize}
\item {} 
create an internal clock (and adjustment mechanism, eg. bluetooth cts)

\item {} 
lvgl supports lv\_canvas\_rotate(canvas, \&imd\_dsc, angle, x, y, pivot\_x, pivot\_y) should be cool for a clock, chrono…

\end{itemize}


\section{References}
\label{\detokenize{clock:references}}
\sphinxurl{https://docs.littlevgl.com/en/html/index.html}

LittlevGL Web Page: \sphinxurl{https://littlevgl.com/}


\chapter{Real Time Clock}
\label{\detokenize{RTC:real-time-clock}}\label{\detokenize{RTC:rtc}}\label{\detokenize{RTC::doc}}

\section{Overview}
\label{\detokenize{RTC:overview}}
This sample application “clock” uses the RTC0 timer.
It uses the counter driver. (based on the alarm sample)

Basically an interrupt is set to go off after 1 second.
The number of seconds is incremented and the interrupt is launched again.

It will serve as a building block for a “time of the day” clock.

In addition it will need a function to set the time.

In bluetooth one can use CTS (central time service)


\section{Requirements}
\label{\detokenize{RTC:requirements}}
Make sure the prj.conf contains the following :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CONFIG\PYGZus{}COUNTER}\PYG{o}{=}\PYG{n}{y}
\end{sphinxVerbatim}

You need the Kconfig file, which contains :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{config} \PYG{n}{COUNTER\PYGZus{}RTC0}
        \PYG{n+nb}{bool}
        \PYG{n}{default} \PYG{n}{y} \PYG{k}{if} \PYG{n}{SOC\PYGZus{}FAMILY\PYGZus{}NRF}
\end{sphinxVerbatim}

see : {\hyperref[\detokenize{samples/gui/clock/README:clock-sample}]{\sphinxcrossref{\DUrole{std,std-ref}{LittlevGL Clock Sample}}}}


\section{Building and Running}
\label{\detokenize{RTC:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/gui/clock}
\end{sphinxVerbatim}


\section{Todo}
\label{\detokenize{RTC:todo}}\begin{itemize}
\item {} 
time of day clock

\item {} 
setting the time

\end{itemize}


\section{References}
\label{\detokenize{RTC:references}}

\chapter{Current Time Service}
\label{\detokenize{CTS:current-time-service}}\label{\detokenize{CTS:cts}}\label{\detokenize{CTS::doc}}

\section{Overview}
\label{\detokenize{CTS:overview}}
The bluetooth peripheral sample has a cts server in place.
By installing this sample on a bluetoothboard, one can simulate the CTS.

Another option is to use a smartphone or computer to connect and bond to your Pinetime.
As soon as a device is bonded, Pinetime will look for a CTS server (Current Time Service) on the connected device.

Here is how to do it with an Android smartphone running NRFConnect:
Build and program the firmware on the Pinetime
Install NRFConnect (\sphinxurl{https://www.nordicsemi.com/Software-and-Tools/Development-Tools/nRF-Connect-for-desktop})
Start NRFConnect and create a CTS server :
Tap the hamburger button on the top left and select “Configure GATT server”
Tap “Add service” on the bottom
Select server configuration “Current Time Service” and tap OK
Go back to the main screen and scan for BLE devices. A device called “PineTime” should appear
Tap the button “Connect” next to the PineTime device. It should connect to the PineTime and switch to a new tab.
On this tab, on the top right, there is a 3 dots button. Tap on it and select Bond. The bonding process begins, and if it is sucessful, the PineTime should update its time and display it on the screen.


\section{Requirements}
\label{\detokenize{CTS:requirements}}

\section{Building and Running}
\label{\detokenize{CTS:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/bluetooth/peripheral\PYGZhy{}cts}
\end{sphinxVerbatim}


\section{Todo}
\label{\detokenize{CTS:todo}}\begin{itemize}
\item {} 
make it work

\end{itemize}


\section{References}
\label{\detokenize{CTS:references}}

\chapter{Drivers}
\label{\detokenize{drivers/drivers:drivers}}\label{\detokenize{drivers/drivers:id1}}\label{\detokenize{drivers/drivers::doc}}

\section{configuring I2C}
\label{\detokenize{drivers/i2c:configuring-i2c}}\label{\detokenize{drivers/i2c::doc}}

\subsection{board level definitions}
\label{\detokenize{drivers/i2c:board-level-definitions}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{under} \PYG{n}{boards}\PYG{o}{/}\PYG{n}{arm}\PYG{o}{/}\PYG{n}{pinetime} \PYG{n}{are} \PYG{n}{the} \PYG{n}{board} \PYG{n}{definitions}
\PYG{o}{\PYGZhy{}} \PYG{n}{pinetime}\PYG{o}{.}\PYG{n}{dts}
\PYG{o}{\PYGZhy{}} \PYG{n}{pinetime\PYGZus{}defconfig}


\PYG{n}{The} \PYG{n}{sensors} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{pinetime} \PYG{n}{use} \PYG{n}{the} \PYG{n}{I2C} \PYG{n}{bus}\PYG{o}{.}

\PYG{o}{\PYGZam{}}\PYG{n}{i2c1} \PYG{p}{\PYGZob{}}
        \PYG{n}{compatible} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nordic,nrf\PYGZhy{}twi}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{status} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{okay}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sda}\PYG{o}{\PYGZhy{}}\PYG{n}{pin} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{scl}\PYG{o}{\PYGZhy{}}\PYG{n}{pin} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{7}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

      \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{definition on project level}
\label{\detokenize{drivers/i2c:definition-on-project-level}}
In the directory of a sample, you will find a prj.conf file.
Here you can set values specific for you project/sample.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{In} \PYG{n}{the} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{prj.conf}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{file} \PYG{n}{we} \PYG{n}{define} \PYG{n}{the} \PYG{n}{sensor} \PYG{p}{(}\PYG{n}{eg} \PYG{n}{adxl372}\PYG{p}{)}

\PYG{n}{CONFIG\PYGZus{}STDOUT\PYGZus{}CONSOLE}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}LOG}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}I2C}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}SENSOR}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}ADXL372}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}ADXL372\PYGZus{}I2C}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}SENSOR\PYGZus{}LOG\PYGZus{}LEVEL\PYGZus{}WRN}\PYG{o}{=}\PYG{n}{y}
\end{sphinxVerbatim}

\sphinxstylestrong{note: this gets somehow merged (overlayed) with the board definition pinetime\_defconfig}


\section{sensors on the I2C bus}
\label{\detokenize{drivers/sensors:sensors-on-the-i2c-bus}}\label{\detokenize{drivers/sensors::doc}}
0x18: Accelerometer: BMA423-DS000
\sphinxurl{https://github.com/BoschSensortec/BMA423-Sensor-API}

0x44: Heart Rate Sensor: HRS3300\_Heart

0x15: Touch Controller: Hynitron CST816S Touch Controller


\section{Bosch BMA421}
\label{\detokenize{drivers/bma421:bosch-bma421}}\label{\detokenize{drivers/bma421::doc}}
this driver does not exist, so it has been created.
Still work in progress ….

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/gui/lvaccel}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/bma421:overview}}
BMA421 is not a part number available to the general public, and therefore all the supporting documentation and design resources are neither discussed in public forums, nor disclosed on GitHub.

CHIP\_ID=0X11  (so the Bosch BMA423 drivers need to be adapted)

The Bosch documentation on the bma423 seems to apply to the bma421.


\subsection{Requirements}
\label{\detokenize{drivers/bma421:requirements}}
for this sensor does not exist any driver, so here’s what I did to create one under zephyr


\subsubsection{adapt CMakeLists.txt}
\label{\detokenize{drivers/bma421:adapt-cmakelists-txt}}
\textasciitilde{}/zephyrproject-2/zephyr/drivers/sensor
add\_subdirectory\_ifdef(CONFIG\_BMA280            bma280)
add\_subdirectory\_ifdef(CONFIG\_BMA421            bma421)


\subsubsection{adapt Kconfig}
\label{\detokenize{drivers/bma421:adapt-kconfig}}
\textasciitilde{}/zephyrproject-2/zephyr/drivers/sensor


\subsubsection{add yaml file}
\label{\detokenize{drivers/bma421:add-yaml-file}}
\textasciitilde{}/zephyrproject-2/zephyr/dts/bindings/sensor
cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml


\subsubsection{edit KConfig}
\label{\detokenize{drivers/bma421:edit-kconfig}}\begin{description}
\item[{source “drivers/sensor/bma280/Kconfig”}] \leavevmode
source “drivers/sensor/bma421/Kconfig”

\end{description}

source “drivers/sensor/bmc150\_magn/Kconfig”

source “drivers/sensor/bme280/Kconfig”


\subsubsection{create driver}
\label{\detokenize{drivers/bma421:create-driver}}
see under drivers/sensor/bma421

complement the pinetime.dts file with the following (under samples/sensor/bma280)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        bma421@18 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}bosch,bma421\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x18\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}BMA421\PYGZdq{};}
\PYG{g+go}{                   int1\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 8 0\PYGZgt{};}
\PYG{g+go}{                  \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}

Create a file: \sphinxtitleref{/dts/bindings/sensor/bosch,bma421-i2c.yaml}.
Which contains:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{compatible}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bosch,bma421}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{include}\PYG{p}{:} \PYG{n}{i2c}\PYG{o}{\PYGZhy{}}\PYG{n}{device}\PYG{o}{.}\PYG{n}{yaml}
\PYG{n}{properties}\PYG{p}{:}
       \PYG{n}{int1}\PYG{o}{\PYGZhy{}}\PYG{n}{gpios}\PYG{p}{:}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{phandle}\PYG{o}{\PYGZhy{}}\PYG{n}{array}
       \PYG{n}{required}\PYG{p}{:} \PYG{n}{false}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/bma421:building-and-running}}

\subsection{Todo}
\label{\detokenize{drivers/bma421:todo}}\begin{itemize}
\item {} 
the driver is interrupt driven as well \textendash{} need to test software

\item {} 
the sensor has algorithm for steps \textendash{} read out register

\item {} 
temperature some attempt has been made, but … (OK, temp can be read)

\end{itemize}


\subsection{References}
\label{\detokenize{drivers/bma421:references}}
Bosch has documented the BMA423 very well.
I kind of hope it will apply to the bma421.

A mechanism to adapt the 0x5E register is provided.
(burst read/write)

All kind of parameters can be set to trigger an interrupt.
(e.g. number of steps taken : think of the 10000 steps threshold)


\section{HYNITRON CST816S}
\label{\detokenize{drivers/cst816s:hynitron-cst816s}}\label{\detokenize{drivers/cst816s::doc}}
this driver does not exist, so it has been created.
Still work in progress ….

there is a sample in this repository which can be copied to the zephyr samples directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/sensor/cst816s}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/cst816s:overview}}
the Hynitron cst816s is a touchscreen.
In zephyr doesn’t handle touchscreens yet.
In order to investigate, the touchscreen driver has been created as a sensor.
In fact it senses your finger ;)


\subsection{Requirements}
\label{\detokenize{drivers/cst816s:requirements}}
for this sensor does not exist any driver, so here’s what I did to create one under zephyr

adapt CMakeLists.txt
adapt Kconfig
add yaml file


\subsubsection{create driver}
\label{\detokenize{drivers/cst816s:create-driver}}
The driver reads only one position.
Multitouch is possible, but the screen is small….

see under drivers/sensor/cst816s

have a look at the pinetime.dts (under board/arm/pinetime) file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        cst816s@15 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}hynitron,cst816s\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x15\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}CST816S\PYGZdq{};}
\PYG{g+go}{                   \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/cst816s:building-and-running}}\begin{description}
\item[{There are two samples :}] \leavevmode\begin{itemize}
\item {} 
samples/gui/lvtouch (graphical)

\item {} 
samples/sensor/cst816s (no graphics)

\end{itemize}

\end{description}


\subsection{Todo}
\label{\detokenize{drivers/cst816s:todo}}
The graphical sample doesn’t handle interrupts.


\subsection{References}
\label{\detokenize{drivers/cst816s:references}}
There is little available for this touchscreen.


\section{HX HRS3300}
\label{\detokenize{drivers/hrs3300:hx-hrs3300}}\label{\detokenize{drivers/hrs3300::doc}}
this driver does not exist, so it has been created.
Still work in progress ….

there is a sample in this repository which can be copied to the zephyr samples directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/sensor/hrs3300}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/hrs3300:overview}}
The HX HRS3300 sensor is a heart rate sensor, it produces 2 values: ALS and HRS. Ambient LIGHT SENSOR and HEART RATE SENSOR. Which have to be processed by an algorithm. I have no knowledge of a good open source algorithm yet.

I have used the settings of an arduino port of this library.

\noindent\sphinxincludegraphics{{hrs3300}.jpg}


\subsection{Requirements}
\label{\detokenize{drivers/hrs3300:requirements}}
for this sensor does not exist any driver, so here’s what I did to create one under zephyr


\subsubsection{adapt CMakeLists.txt}
\label{\detokenize{drivers/hrs3300:adapt-cmakelists-txt}}
\textasciitilde{}/zephyrproject-2/zephyr/drivers/sensor
add\_subdirectory\_ifdef(CONFIG\_HRS3300           hrs3300)


\subsubsection{adapt Kconfig}
\label{\detokenize{drivers/hrs3300:adapt-kconfig}}
\textasciitilde{}/zephyrproject-2/zephyr/drivers/sensor


\subsubsection{add yaml file}
\label{\detokenize{drivers/hrs3300:add-yaml-file}}
\textasciitilde{}/zephyrproject-2/zephyr/dts/bindings/sensor
add  hx,hrs3300.yaml


\subsubsection{edit KConfig}
\label{\detokenize{drivers/hrs3300:edit-kconfig}}
source “drivers/sensor/hrs3300/Kconfig”


\subsubsection{create driver}
\label{\detokenize{drivers/hrs3300:create-driver}}
see under drivers/sensor/hrs3300

complement the pinetime.dts file with the following (under samples/sensor/bma280)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        hrs3300@44 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}hx,hrs3300\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x44\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}HRS3300\PYGZdq{};}
\PYG{g+go}{                   \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}

Create a file: \sphinxtitleref{/dts/bindings/sensor/hx,hrs3300.yaml}.
Which contains:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{compatible}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hx,hrs3300}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{properties}\PYG{p}{:}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/hrs3300:building-and-running}}

\subsection{Todo}
\label{\detokenize{drivers/hrs3300:todo}}\begin{itemize}
\item {} 
algorithm for heartrate

\item {} 
power saving

\item {} 
switching off/on mechanism

\end{itemize}


\subsection{References}
\label{\detokenize{drivers/hrs3300:references}}
HRS3300 Heart Rate Sensor.pdf
\sphinxurl{https://github.com/atc1441/HRS3300-Arduino-Library}


\section{Serial Nor Flash}
\label{\detokenize{drivers/spinor:serial-nor-flash}}\label{\detokenize{drivers/spinor::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/spi\PYGZus{}flash \PYGZhy{}DCONF=prj.conf}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/spinor:overview}}
This sample application should unlock the serial nor flash memory.
This can be very usefull to store e.g. background for the watch.

compilation problematic ….

/root/zephyrproject/zephyr/samples/drivers/spi\_flash/src/main.c:17:22: error: ‘DT\_INST\_0\_JEDEC\_SPI\_NOR\_LABEL’ undeclared (first use in this function); did you mean ‘DT\_INST\_0\_NORDIC\_NRF\_RTC\_LABEL’?

Turns out this is some problem with the board definition file.

I found it to be very useful to consult the generated dts file.
Here you can check if everything is present.

Guess the dts-file has to be well intended.(structured)

{\color{red}\bfseries{}**}TIP: consult the generated dts board file **


\subsubsection{consulting the generated board definition file}
\label{\detokenize{drivers/spinor:consulting-the-generated-board-definition-file}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{vi /root/zephyrproject/zephyr/build/zephyr/include/generated/generated\PYGZus{}dts\PYGZus{}board.conf}
\end{sphinxVerbatim}


\subsection{Requirements}
\label{\detokenize{drivers/spinor:requirements}}
complement the pinetime.dts file with the following (under spi)
\#define JEDEC\_ID\_MACRONIX\_MX25L64      0xC22017

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}spi0 \PYGZob{}}
\PYG{g+go}{  compatible = \PYGZdq{}nordic,nrf\PYGZhy{}spi\PYGZdq{};}
\PYG{g+go}{  status = \PYGZdq{}okay\PYGZdq{};}
\PYG{g+go}{  sck\PYGZhy{}pin = \PYGZlt{}2\PYGZgt{};}
\PYG{g+go}{  mosi\PYGZhy{}pin = \PYGZlt{}3\PYGZgt{};}
\PYG{g+go}{  miso\PYGZhy{}pin = \PYGZlt{}4\PYGZgt{};}
\PYG{g+go}{  cs\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 27 0\PYGZgt{},\PYGZlt{}\PYGZam{}gpio0 5 0\PYGZgt{};}
\PYG{g+go}{  st7789v@0 \PYGZob{}}
\PYG{g+go}{          compatible = \PYGZdq{}sitronix,st7789v\PYGZdq{};}
\PYG{g+go}{          label = \PYGZdq{}DISPLAY\PYGZdq{};}
\PYG{g+go}{          spi\PYGZhy{}max\PYGZhy{}frequency = \PYGZlt{}8000000\PYGZgt{};}
\PYG{g+go}{          reg = \PYGZlt{}0\PYGZgt{};}
\PYG{g+go}{          cmd\PYGZhy{}data\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 18 0\PYGZgt{};}
\PYG{g+go}{          reset\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 26 0\PYGZgt{};}
\PYG{g+go}{          width = \PYGZlt{}240\PYGZgt{};}
\PYG{g+go}{          height = \PYGZlt{}240\PYGZgt{};}
\PYG{g+go}{          x\PYGZhy{}offset = \PYGZlt{}0\PYGZgt{};}
\PYG{g+go}{          y\PYGZhy{}offset = \PYGZlt{}0\PYGZgt{};}
\PYG{g+go}{          vcom = \PYGZlt{}0x19\PYGZgt{};}
\PYG{g+go}{          gctrl = \PYGZlt{}0x35\PYGZgt{};}
\PYG{g+go}{          vrhs = \PYGZlt{}0x12\PYGZgt{};}
\PYG{g+go}{          vdvs = \PYGZlt{}0x20\PYGZgt{};}
\PYG{g+go}{          mdac = \PYGZlt{}0x00\PYGZgt{};}
\PYG{g+go}{          gamma = \PYGZlt{}0x01\PYGZgt{};}
\PYG{g+go}{          colmod = \PYGZlt{}0x05\PYGZgt{};}
\PYG{g+go}{          lcm = \PYGZlt{}0x2c\PYGZgt{};}
\PYG{g+go}{          porch\PYGZhy{}param = [0c 0c 00 33 33];}
\PYG{g+go}{          cmd2en\PYGZhy{}param = [5a 69 02 01];}
\PYG{g+go}{          pwctrl1\PYGZhy{}param = [a4 a1];}
\PYG{g+go}{          pvgam\PYGZhy{}param = [D0 04 0D 11 13 2B 3F 54 4C 18 0D 0B 1F 23];}
\PYG{g+go}{          nvgam\PYGZhy{}param = [D0 04 0C 11 13 2C 3F 44 51 2F 1F 1F 20 23];}
\PYG{g+go}{          ram\PYGZhy{}param = [00 F0];}
\PYG{g+go}{          rgb\PYGZhy{}param = [CD 08 14];}

\PYG{g+go}{  \PYGZcb{};}

\PYG{g+go}{  mx25r64: mx25r6435f@1 \PYGZob{}}
\PYG{g+go}{          compatible = \PYGZdq{}jedec,spi\PYGZhy{}nor\PYGZdq{};}
\PYG{g+go}{          reg = \PYGZlt{}1\PYGZgt{};}
\PYG{g+go}{          spi\PYGZhy{}max\PYGZhy{}frequency = \PYGZlt{}1000000\PYGZgt{};}
\PYG{g+go}{          label = \PYGZdq{}MX25R64\PYGZdq{};}
\PYG{g+go}{          jedec\PYGZhy{}id = [0b 40 16];}
\PYG{g+go}{          size = \PYGZlt{}67108864\PYGZgt{};}
\PYG{g+go}{          has\PYGZhy{}be32k;}
\PYG{g+go}{  \PYGZcb{};}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/spinor:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/spi\PYGZus{}flash}
\end{sphinxVerbatim}


\subsection{Todo}
\label{\detokenize{drivers/spinor:todo}}\begin{quote}
\begin{itemize}
\item {} 
detect ID memory  : it is not the macronix one as suggestion on the pinetime website

\end{itemize}

I found the following : jedec-id = {[}0b 40 16{]}; (OK: can execute sample program)
\begin{itemize}
\item {} 
create working board definition (OK: see above)

\end{itemize}
\end{quote}


\subsection{References}
\label{\detokenize{drivers/spinor:references}}
\sphinxurl{http://files.pine64.org/doc/datasheet/pinetime/MX25L6433F,\%203V,\%2064Mb,\%20v1.6.pdf}


\section{Battery}
\label{\detokenize{drivers/battery:battery}}\label{\detokenize{drivers/battery::doc}}
the samples just gets an analog reading from the battery

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/sensor/battery}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/battery:overview}}
The battery level is measured on port 31, trough an ADC conversion.

voltage = (value * 6)/1024
percentage remaining  ((voltage - 3.55)*100)*3.9;

A module should be able to report battery status in milivolts and charge level in percentage. Additionally, it should notify when external power is connected and when battery is being charged.
Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
Battery voltage can be in range from 3.0V - 4.2V (?). Unfortunately, internal reference (0.6V) can only be used for voltages up to 3.6V (due to minimal gain of 1/6). VDD/4 reference can be used with 1/6 gain to measure voltages up to 4.95V. Test is needed to check how accurate is VDD as reference.
Discharge curve (\sphinxurl{https://forum.pine64.org/showthread.php?tid=8147}) will be used to calculate charge level in percent.
Things to consider:
saadc periodical calibration (spec suggests calibration if temperature changes by 10’C)
inaccuracy of results: oversampling? never report higher level than before (if charge not connected), etc.


\subsection{Todo}
\label{\detokenize{drivers/battery:todo}}
check pin when charging


\subsection{References}
\label{\detokenize{drivers/battery:references}}
\sphinxurl{https://forum.pine64.org/showthread.php?tid=8147}


\chapter{Behind the scene}
\label{\detokenize{behind/behind:behind-the-scene}}\label{\detokenize{behind/behind:id1}}\label{\detokenize{behind/behind::doc}}

\section{Behind the scene}
\label{\detokenize{behind/behind-the-scene:behind-the-scene}}\label{\detokenize{behind/behind-the-scene::doc}}

\subsection{Overview}
\label{\detokenize{behind/behind-the-scene:overview}}
I’m not a zephyr expert and am learning on the way.

In this chapter I let you glimpse behind the scene. (and notice all the struggle)

In case of the accel sensor, I used the bosch bma280 as a template.

In case of the touchscreen, I soon ran into trouble.
So I tried splitting a complex problem into simpler ones.

This allowed me to detect problems easier.

The created samples might be of some use, if you run into trouble or if you want to extend the functionality.


\section{development trajectory}
\label{\detokenize{behind/bma280:development-trajectory}}\label{\detokenize{behind/bma280::doc}}
The final goal is to use the accel-sensor in the watch (BMA423), which does not exist yet.
In order to minimize the effort:
\begin{itemize}
\item {} 
we’ll use something that looks like it (ADXL372), because there exists an example.

\item {} 
next we adapt it to use the existing BMA280 sensor (under drivers/sensor), so we get a sample that works with the BMA280.

\item {} 
we create a driver for the BMA423, based upon the BMA280

\item {} 
we adapt the sample for the BMA280 to BMA423

\end{itemize}


\section{Bosch BMA280}
\label{\detokenize{behind/bma280:bosch-bma280}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/bma280}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{behind/bma280:overview}}
This sample application mimics the presence of a bosch, bma280 accel sensor.
For this sensor exists a driver in zephyr, but no sample.
Remember, I’m not a zephyr expert and am learning on the way.


\subsection{Requirements}
\label{\detokenize{behind/bma280:requirements}}
complement the pinetime.dts file with the following (under samples/sensor/bma280)

This will supplement / override what’s already definition on the board level (boards/arm/pinetime)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        bma280@18 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}bosch,bma280\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x18\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}BMA280\PYGZdq{};}
\PYG{g+go}{                   int1\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 8 0\PYGZgt{};}
\PYG{g+go}{                  \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}

Create a file: \sphinxtitleref{/dts/bindings/sensor/bosch,bma280-i2c.yaml}.
Which contains:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{compatible}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bosch,bma280}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{include}\PYG{p}{:} \PYG{n}{i2c}\PYG{o}{\PYGZhy{}}\PYG{n}{device}\PYG{o}{.}\PYG{n}{yaml}
\PYG{n}{properties}\PYG{p}{:}
       \PYG{n}{int1}\PYG{o}{\PYGZhy{}}\PYG{n}{gpios}\PYG{p}{:}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{phandle}\PYG{o}{\PYGZhy{}}\PYG{n}{array}
       \PYG{n}{required}\PYG{p}{:} \PYG{n}{false}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{behind/bma280:building-and-running}}

\subsection{Todo}
\label{\detokenize{behind/bma280:todo}}\begin{itemize}
\item {} 
since no serial port and no J-LINK, I have to print messages to the screen (see sample gui/lvaccel)

\item {} 
I adapted the BMA driver so it accepts the CHIP\_ID, further registers are subject to investigation, since no doc

\end{itemize}


\subsection{References}
\label{\detokenize{behind/bma280:references}}
BMA421 is not a part number available to the general public, and therefore all the supporting documentation and design resources are neither discussed in public forums, nor disclosed on GitHub.

CHIP\_ID=0X11  (so 423 drivers need to be adapted)


\section{Touchscreen Hynitron}
\label{\detokenize{behind/touchscreen:touchscreen-hynitron}}\label{\detokenize{behind/touchscreen::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{git clone https://github.com/lupyuen/hynitron\PYGZus{}i2c\PYGZus{}cst0xxse}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{behind/touchscreen:overview}}
this does not exist yet in zephyr, but there is work in progress
\sphinxurl{https://github.com/zephyrproject-rtos/zephyr/pull/16119}


\subsection{Requirements}
\label{\detokenize{behind/touchscreen:requirements}}
complement the pinetime.dts file with the following (under samples/sensor/bma280)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        touch@18 \PYGZob{}}
\PYG{g+go}{                  \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}

Create a file: \sphinxtitleref{/dts/bindings/sensor/touch.yaml}.
Which contains:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{compatible}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{touch}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{include}\PYG{p}{:} \PYG{n}{i2c}\PYG{o}{\PYGZhy{}}\PYG{n}{device}\PYG{o}{.}\PYG{n}{yaml}
\PYG{n}{properties}\PYG{p}{:}
       \PYG{n}{int1}\PYG{o}{\PYGZhy{}}\PYG{n}{gpios}\PYG{p}{:}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{phandle}\PYG{o}{\PYGZhy{}}\PYG{n}{array}
       \PYG{n}{required}\PYG{p}{:} \PYG{n}{false}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{behind/touchscreen:building-and-running}}

\subsection{Todo}
\label{\detokenize{behind/touchscreen:todo}}\begin{quote}

-create touchscreen driver
-create sample
\end{quote}


\subsection{References}
\label{\detokenize{behind/touchscreen:references}}

\section{Troubleshooting drivers}
\label{\detokenize{behind/troubleshoot:troubleshooting-drivers}}\label{\detokenize{behind/troubleshoot::doc}}
Drivers, like the one for the accel sensor BMA421 or the touchscreen CST816S, can deal with interrupts.

Adapting existing drivers did not get me the desired quick results.

Even after analysing the behaviour, setting values at each function step, did not get me any further.


\subsection{Overview}
\label{\detokenize{behind/troubleshoot:overview}}
The drivers can use interrupts.

In the settings/config one can choose between OWN\_THREAD and GLOBAL\_THREAD.

This affect the behaviour of how threads are handled.

The tread-handling and interrupt-handling occurs in the driver itself.

An interrupt is handled immediatly, the processing is offloaded to the threading.


\subsection{Example}
\label{\detokenize{behind/troubleshoot:example}}\begin{itemize}
\item {} 
You touch the touchscreen

\item {} 
the touchscreen generates an interrupt

\item {} 
the driver handles the interrupt

\item {} 
a thread is created by the interrupt

\item {} 
the threadhandling read the I2C-bus

\end{itemize}


\subsection{Requirements}
\label{\detokenize{behind/troubleshoot:requirements}}
In order to create a working driver, I took it apart :

(split a complex problem into simple problems)


\subsubsection{a sample to detect interrupt}
\label{\detokenize{behind/troubleshoot:a-sample-to-detect-interrupt}}
samples/basic/testirq

Each time the touchscreen gets touched, it increases a counter.


\subsubsection{a sample to scan the I2C-BUS}
\label{\detokenize{behind/troubleshoot:a-sample-to-scan-the-i2c-bus}}\begin{quote}

({\hyperref[\detokenize{hacking/i2cscanning:i2cscanning}]{\sphinxcrossref{\DUrole{std,std-ref}{scanning the I2C\_1 port}}}}),
\end{quote}


\subsubsection{a sample to read the I2C-BUS}
\label{\detokenize{behind/troubleshoot:a-sample-to-read-the-i2c-bus}}
samples/basic/touched
It is based on the Hynitron touchscreen code.
Mass reading 63 bytes was not possible.

I did add a write of 1 to register 0x00.


\subsubsection{a samples to handle semaphores}
\label{\detokenize{behind/troubleshoot:a-samples-to-handle-semaphores}}
samples/basic/testsemaphore


\section{placing a button on the screen}
\label{\detokenize{behind/lvglbutton:placing-a-button-on-the-screen}}\label{\detokenize{behind/lvglbutton::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{This} \PYG{n}{sample} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{really} \PYG{n}{important}\PYG{p}{,} \PYG{n}{but} \PYG{n}{it} \PYG{n}{will} \PYG{n}{teach} \PYG{n}{you} \PYG{n}{that} \PYG{n}{you} \PYG{n}{need} \PYG{n}{to} \PYG{n+nb}{set} \PYG{n}{LVGL\PYGZus{}CONFIG} \PYG{n}{values}\PYG{p}{,} \PYG{o+ow}{in} \PYG{n}{order}    \PYG{n}{to} \PYG{n}{be} \PYG{n}{able} \PYG{n}{to} \PYG{n}{use} \PYG{n}{LVGL} \PYG{n}{functions}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{behind/lvglbutton:building-and-running}}
In this repo under samples you will find an adapted gui/clock program.
A button from the LVGL library is placed on the screen.

Later on when the touch-screen driver is ready, we’ll be able to manipulate it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{Make sure that prj.conf file in clock directory contains the following:}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
CONFIG\_LVGL\_OBJ\_CONTAINER=y
CONFIG\_LVGL\_OBJ\_BUTTON=y
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}

\sphinxstyleemphasis{problem} the canvas heigh*width eats up RAM and exceeds once \textgreater{} 40


\chapter{Samples and Demos}
\label{\detokenize{samples/index:samples-and-demos}}\label{\detokenize{samples/index:id1}}\label{\detokenize{samples/index::doc}}
In each sample directory is a Readme file.
This is just a collection of them.


\section{Basic Samples}
\label{\detokenize{samples/basic/basic:basic-samples}}\label{\detokenize{samples/basic/basic:basic-sample}}\label{\detokenize{samples/basic/basic::doc}}

\subsection{Blinky Application}
\label{\detokenize{samples/basic/blinky/README:blinky-application}}\label{\detokenize{samples/basic/blinky/README:blinky-sample}}\label{\detokenize{samples/basic/blinky/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/basic/blinky/README:overview}}
The Blinky example shows how to configure GPIO pins as outputs which can also be
used to drive LEDs on the hardware usually delivered as “User LEDs” on many of
the supported boards in Zephyr.


\subsubsection{Requirements}
\label{\detokenize{samples/basic/blinky/README:requirements}}
The demo assumes that an LED is connected to one of GPIO lines. The
sample code is configured to work on boards that have defined the led0
alias in their board devicetree description file. Doing so will generate
these variables:
\begin{itemize}
\item {} 
DT\_ALIAS\_LED0\_GPIOS\_CONTROLLER

\item {} 
DT\_ALIAS\_LED0\_GPIOS\_PIN

\end{itemize}


\subsubsection{Building and Running}
\label{\detokenize{samples/basic/blinky/README:building-and-running}}
This samples does not output anything to the console.  It can be built and
flashed to a board as follows:

After flashing the image to the board, the user LED on the board should start to
blink.


\subsection{Button demo}
\label{\detokenize{samples/basic/button/README:button-demo}}\label{\detokenize{samples/basic/button/README:button-sample}}\label{\detokenize{samples/basic/button/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/basic/button/README:overview}}
A simple button demo showcasing the use of GPIO input with interrupts.
If the button is pressed, it will set a value at the location 0x2000F000 in memory.
With openocd or any other debugger you can peek at this location.


\subsubsection{Requirements}
\label{\detokenize{samples/basic/button/README:requirements}}
The demo assumes that a push button is connected to one of GPIO lines. The
sample code is configured to work on boards with user defined buttons and that
have defined the SW0\_* variables.

To use this sample, you will require a board that defines the user switch in its
header file. The \sphinxcode{\sphinxupquote{board.h}} must define the following variables:
\begin{itemize}
\item {} 
SW0\_GPIO\_NAME (or DT\_ALIAS\_SW0\_GPIOS\_CONTROLLER)

\item {} 
DT\_ALIAS\_SW0\_GPIOS\_PIN

\end{itemize}

Alternatively, this could also be done by defining ‘sw0’ alias in the board
devicetree description file.


\subsubsection{Building and Running}
\label{\detokenize{samples/basic/button/README:building-and-running}}
This sample can be built for multiple boards, in this example we will build it
for the pinetime

After startup, the program looks up a predefined GPIO device, and configures the
pin in input mode, enabling interrupt generation on falling edge. During each
iteration of the main loop, the state of GPIO line is monitored and printed to
the serial console. When the input button gets pressed, the interrupt handler
will print an information about this event along with its timestamp.


\subsection{I2C Scanner sample}
\label{\detokenize{samples/basic/scani2c/README:i2c-scanner-sample}}\label{\detokenize{samples/basic/scani2c/README:i2c-scanner}}\label{\detokenize{samples/basic/scani2c/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/basic/scani2c/README:overview}}
This sample sends I2C messages without any data (i.e. stop condition
after sending just the address). If there is an ACK for the
address, it prints the address as \sphinxcode{\sphinxupquote{FOUND}}.

\begin{sphinxadmonition}{warning}{Warning:}
As  there  is  no  standard I2C detection command, this sample
uses arbitrary SMBus commands (namely SMBus quick write and SMBus
receive byte) to probe for devices.  This sample program can confuse
your I2C bus, cause data loss, and is known to corrupt
the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
See also the \sphinxhref{http://manpages.ubuntu.com/manpages/bionic/man8/i2cdetect.8.html}{i2cdetect man page}
\end{sphinxadmonition}


\subsubsection{Building and Running}
\label{\detokenize{samples/basic/scani2c/README:building-and-running}}

\subsection{Touchscreen IRQ}
\label{\detokenize{samples/basic/testirq/README:touchscreen-irq}}\label{\detokenize{samples/basic/testirq/README:testirq}}\label{\detokenize{samples/basic/testirq/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/basic/testirq/README:overview}}
The touchscreen generates an interrupt when touched.


\subsubsection{Requirements}
\label{\detokenize{samples/basic/testirq/README:requirements}}
A counter that keeps track of the number of times touched.

This value is stored at a fixed location in memory, because I have a simple test setup.


\subsubsection{Building and Running}
\label{\detokenize{samples/basic/testirq/README:building-and-running}}

\subsection{Touchpoints}
\label{\detokenize{samples/basic/touchpoints/README:touchpoints}}\label{\detokenize{samples/basic/touchpoints/README:id1}}\label{\detokenize{samples/basic/touchpoints/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/basic/touchpoints/README:overview}}
When touched the touchscreen triggers an interrupt,
it’s address 0x15 becomes visable.


\subsubsection{Requirements}
\label{\detokenize{samples/basic/touchpoints/README:requirements}}
Cach the interrupts and act upon it.

Only the first touchpoint is usable.

But a sequence of 64 has to be read.


\subsubsection{Building and Running}
\label{\detokenize{samples/basic/touchpoints/README:building-and-running}}
the purpose is just testing howto read the touchpoints of the touchscreen


\section{Sensor Samples}
\label{\detokenize{samples/sensor/sensor:sensor-samples}}\label{\detokenize{samples/sensor/sensor:id1}}\label{\detokenize{samples/sensor/sensor::doc}}

\subsection{BMA280: Three Axis High-g I2C/SPI Accelerometer}
\label{\detokenize{samples/sensor/bma280/README:bma280-three-axis-high-g-i2c-spi-accelerometer}}\label{\detokenize{samples/sensor/bma280/README:bma280}}\label{\detokenize{samples/sensor/bma280/README::doc}}

\subsubsection{Description}
\label{\detokenize{samples/sensor/bma280/README:description}}
This sample application produces slightly different outputs based on the chosen
driver configuration mode:
\begin{itemize}
\item {} 
In \sphinxstylestrong{Measuring Mode with trigger support},
the acceleration on all three axis is printed in m/s\textasciicircum{}2 at the sampling rate (ODR).

\item {} 
In \sphinxstylestrong{Polled Measuring Mode}, the instantaneous acceleration is polled every 2 seconds.

\item {} 
In \sphinxstylestrong{Max Peak Detect Mode}, the device returns only the over-threshold
peak acceleration between two consecutive sample fetches or trigger events.
(In most high-g applications, a single 3-axis acceleration sample at the peak
of an impact event contains sufficient information about the event, and the
full acceleration history is not required.) Instead of printing the acceleration
on all three axis, the sample application calculates the vector magnitude
(root sum squared) and displays the result in g’s rather than in m/s\textasciicircum{}2,
together with an bar graph.

\end{itemize}


\subsubsection{References}
\label{\detokenize{samples/sensor/bma280/README:references}}\begin{itemize}
\item {} 
BMA280: \sphinxurl{http://www.analog.com/bma280}

\end{itemize}


\subsubsection{Wiring}
\label{\detokenize{samples/sensor/bma280/README:wiring}}
This sample uses the BMA280 sensor controlled either using the I2C or SPI interface.
Connect supply \sphinxstylestrong{VDD}, \sphinxstylestrong{VS} and \sphinxstylestrong{GND}. The supply voltage can be in
the 1.6V to 3.5V range.


\paragraph{I2C mode}
\label{\detokenize{samples/sensor/bma280/README:i2c-mode}}
Connect Interface: \sphinxstylestrong{SDA}, \sphinxstylestrong{SCL} and optionally connect the \sphinxstylestrong{INT1} to a
interrupt capable GPIO. It is a requirement that \sphinxstylestrong{SCLK} must be connected to
\sphinxstylestrong{GND} in I2C mode. Depending on the baseboard used, the \sphinxstylestrong{SDA} and \sphinxstylestrong{SCL}
lines require Pull-Up resistors. With the \sphinxstylestrong{MISO} pin low, the I2C address for
the device is 0x1D, and an alternate I2C address of 0x53 can be chosen by
pulling the \sphinxstylestrong{MISO} pin high.

I2C Address:
\begin{itemize}
\item {} 
\sphinxstylestrong{0x1D}: if MISO is pulled low

\item {} 
\sphinxstylestrong{0x53}: if MISO is pulled high

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
When sharing an SDA bus, the BMA280 Silicon Revision \textless{} 3  may prevent
communication with other devices on that bus.
\end{sphinxadmonition}


\paragraph{SPI mode}
\label{\detokenize{samples/sensor/bma280/README:spi-mode}}
Connect Interface: \sphinxstylestrong{SCLK}, \sphinxstylestrong{MISO}, \sphinxstylestrong{MOSI} and \sphinxstylestrong{/CS} and optionally
connect the \sphinxstylestrong{INT1} to a interrupt capable GPIO.


\subsubsection{Building and Running}
\label{\detokenize{samples/sensor/bma280/README:building-and-running}}
This project outputs sensor data to the console. It requires an BMA280
sensor. It should work with any platform featuring a I2C/SPI peripheral interface.
It does not work on QEMU.


\paragraph{Sample Output: Max Peak Detect Mode}
\label{\detokenize{samples/sensor/bma280/README:sample-output-max-peak-detect-mode}}

\paragraph{Sample Output: Measurement Mode}
\label{\detokenize{samples/sensor/bma280/README:sample-output-measurement-mode}}

\subsection{CST816S HYNITRON TOUCHSCREEN}
\label{\detokenize{samples/sensor/cst816s/README:cst816s-hynitron-touchscreen}}\label{\detokenize{samples/sensor/cst816s/README:cst816s}}\label{\detokenize{samples/sensor/cst816s/README::doc}}

\subsubsection{Description}
\label{\detokenize{samples/sensor/cst816s/README:description}}
When touched the touchscreen triggers an interrupt.
This is handled in the driver.

In the sample a handler is defined.
This one gets actived by the driver.


\subsubsection{References}
\label{\detokenize{samples/sensor/cst816s/README:references}}

\subsubsection{Wiring}
\label{\detokenize{samples/sensor/cst816s/README:wiring}}

\paragraph{I2C mode}
\label{\detokenize{samples/sensor/cst816s/README:i2c-mode}}

\subsubsection{Building and Running}
\label{\detokenize{samples/sensor/cst816s/README:building-and-running}}

\paragraph{Sample Output: X \& Y coordinates}
\label{\detokenize{samples/sensor/cst816s/README:sample-output-x-y-coordinates}}

\paragraph{Sample Output: Measurement Mode}
\label{\detokenize{samples/sensor/cst816s/README:sample-output-measurement-mode}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}


\subsection{HRS3300 Heart Rate Sensor}
\label{\detokenize{samples/sensor/hrs3300/README:hrs3300-heart-rate-sensor}}\label{\detokenize{samples/sensor/hrs3300/README:hrs3300}}\label{\detokenize{samples/sensor/hrs3300/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/sensor/hrs3300/README:overview}}
A sensor application that demonstrates how to poll data from the hrs3300 heart
rate sensor.

It is based on the max30101 sample.


\subsubsection{Building and Running}
\label{\detokenize{samples/sensor/hrs3300/README:building-and-running}}

\paragraph{Sample Output}
\label{\detokenize{samples/sensor/hrs3300/README:sample-output}}

\section{Driver Samples}
\label{\detokenize{samples/drivers/drivers:driver-samples}}\label{\detokenize{samples/drivers/drivers:id1}}\label{\detokenize{samples/drivers/drivers::doc}}
The following samples demonstrate how to use various drivers supported
by Zephyr.


\subsection{I2C Scanner sample}
\label{\detokenize{samples/drivers/ds6_scanner/README:i2c-scanner-sample}}\label{\detokenize{samples/drivers/ds6_scanner/README:i2c-scanner}}\label{\detokenize{samples/drivers/ds6_scanner/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/drivers/ds6_scanner/README:overview}}
This sample sends I2C messages without any data (i.e. stop condition
after sending just the address). If there is an ACK for the
address, it prints the address as \sphinxcode{\sphinxupquote{FOUND}}.

\begin{sphinxadmonition}{warning}{Warning:}
As  there  is  no  standard I2C detection command, this sample
uses arbitrary SMBus commands (namely SMBus quick write and SMBus
receive byte) to probe for devices.  This sample program can confuse
your I2C bus, cause data loss, and is known to corrupt
the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
See also the \sphinxhref{http://manpages.ubuntu.com/manpages/bionic/man8/i2cdetect.8.html}{i2cdetect man page}
\end{sphinxadmonition}


\subsubsection{Building and Running}
\label{\detokenize{samples/drivers/ds6_scanner/README:building-and-running}}

\subsection{I2C Scanner sample}
\label{\detokenize{samples/drivers/i2c_scanner/README:i2c-scanner-sample}}\label{\detokenize{samples/drivers/i2c_scanner/README:i2c-scanner}}\label{\detokenize{samples/drivers/i2c_scanner/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/drivers/i2c_scanner/README:overview}}
This sample sends I2C messages without any data (i.e. stop condition
after sending just the address). If there is an ACK for the
address, it prints the address as \sphinxcode{\sphinxupquote{FOUND}}.

\begin{sphinxadmonition}{warning}{Warning:}
As  there  is  no  standard I2C detection command, this sample
uses arbitrary SMBus commands (namely SMBus quick write and SMBus
receive byte) to probe for devices.  This sample program can confuse
your I2C bus, cause data loss, and is known to corrupt
the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
See also the \sphinxhref{http://manpages.ubuntu.com/manpages/bionic/man8/i2cdetect.8.html}{i2cdetect man page}
\end{sphinxadmonition}


\subsubsection{Building and Running}
\label{\detokenize{samples/drivers/i2c_scanner/README:building-and-running}}

\section{Display Samples}
\label{\detokenize{samples/display/display:display-samples}}\label{\detokenize{samples/display/display:id1}}\label{\detokenize{samples/display/display::doc}}

\subsection{ST7789V Display driver}
\label{\detokenize{samples/display/st7789v/README:st7789v-display-driver}}\label{\detokenize{samples/display/st7789v/README:st7789v-sample}}\label{\detokenize{samples/display/st7789v/README::doc}}
make sure this patch is applied :
\sphinxurl{https://github.com/zephyrproject-rtos/zephyr/pull/20570/files}


\subsubsection{Overview}
\label{\detokenize{samples/display/st7789v/README:overview}}
This sample will draw some basic rectangles onto the display.
The rectangle colors and positions are chosen so that you can check the
orientation of the LCD and correct RGB bit order. The rectangles are drawn
in clockwise order, from top left corner: Red, Green, Blue, grey. The shade of
grey changes from black through to white. (if the grey looks too green or red
at any point then the LCD may be endian swapped).

Note: The display driver rotates the display so that the ‘natural’ LCD
orientation is effectively 270 degrees clockwise of the default display
controller orientation.


\subsubsection{Building and Running}
\label{\detokenize{samples/display/st7789v/README:building-and-running}}

\subsubsection{References}
\label{\detokenize{samples/display/st7789v/README:references}}\begin{itemize}
\item {} 
\sphinxhref{https://www.crystalfontz.com/controllers/Sitronix/ST7789V/}{ST7789V datasheet}

\end{itemize}


\section{GUI Samples}
\label{\detokenize{samples/gui/gui:gui-samples}}\label{\detokenize{samples/gui/gui:id1}}\label{\detokenize{samples/gui/gui::doc}}

\subsection{LittlevGL Clock Sample}
\label{\detokenize{samples/gui/clock/README:littlevgl-clock-sample}}\label{\detokenize{samples/gui/clock/README:clock-sample}}\label{\detokenize{samples/gui/clock/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/gui/clock/README:overview}}
This sample application displays a clock background.

This samples demonstrates the use of the counter.

Have a look at the test\_counter\_interrupt\_fn function in src/main.c


\subsubsection{Requirements}
\label{\detokenize{samples/gui/clock/README:requirements}}
You have to convert a graphical file to a “C” file, which is like a giant array.

Have a look at the prj.conf file.

It should contain CONFIG\_LVGL=y and
CONFIG\_LVGL\_OBJ\_IMAGE=y.

For the clock function it needs  CONFIG\_COUNTER=y.


\subsubsection{Building and Running}
\label{\detokenize{samples/gui/clock/README:building-and-running}}

\subsubsection{References}
\label{\detokenize{samples/gui/clock/README:references}}

\subsection{Adafruit GFX Library on ST7789V Display}
\label{\detokenize{samples/gui/gfx/README:adafruit-gfx-library-on-st7789v-display}}\label{\detokenize{samples/gui/gfx/README:gfx-sample}}\label{\detokenize{samples/gui/gfx/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/gui/gfx/README:overview}}
This is a sample C++ firmware running Adafruit GFX Library on a ST7789V display. The library is ported from Arduino.


\subsection{Display accel values}
\label{\detokenize{samples/gui/lvaccel/README:display-accel-values}}\label{\detokenize{samples/gui/lvaccel/README:lvaccel-sample}}\label{\detokenize{samples/gui/lvaccel/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/gui/lvaccel/README:overview}}
This sample application displays “Hello World” in the center of the screen
and a counter at the bottom which increments every second.

It display the values x,y,z from the bosch BMA421 accel sensor.


\subsubsection{Requirements}
\label{\detokenize{samples/gui/lvaccel/README:requirements}}
Pinetime watch
definitions can be found under the boards sub-directory
\begin{itemize}
\item {} 
pinetime.conf

\item {} 
pinetime.overlay

\end{itemize}


\subsubsection{Building and Running}
\label{\detokenize{samples/gui/lvaccel/README:building-and-running}}
west build -p -b pinetime samples/gui/lvgl


\subsubsection{References}
\label{\detokenize{samples/gui/lvaccel/README:references}}

\subsection{LittlevGL Basic Sample}
\label{\detokenize{samples/gui/lvgl/README:littlevgl-basic-sample}}\label{\detokenize{samples/gui/lvgl/README:lvgl-sample}}\label{\detokenize{samples/gui/lvgl/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/gui/lvgl/README:overview}}
This sample application displays “Hello World” in the center of the screen
and a counter at the bottom which increments every second.


\subsubsection{Requirements}
\label{\detokenize{samples/gui/lvgl/README:requirements}}
Pinetime watch
definitions can be found under the boards sub-directory
\begin{itemize}
\item {} 
pinetime.conf

\item {} 
pinetime.overlay

\end{itemize}


\subsubsection{Building and Running}
\label{\detokenize{samples/gui/lvgl/README:building-and-running}}
west build -p -b pinetime samples/gui/lvgl


\subsubsection{References}
\label{\detokenize{samples/gui/lvgl/README:references}}

\subsection{Touchscreen Basic Sample}
\label{\detokenize{samples/gui/lvtouch/README:touchscreen-basic-sample}}\label{\detokenize{samples/gui/lvtouch/README:touchscreen-sample}}\label{\detokenize{samples/gui/lvtouch/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/gui/lvtouch/README:overview}}
This sample application displays touchscreen-values x and y in the center of the screen.

The touchscreen triggers an interrupt when touched.
This means that data is ready and can be collected.

However, using the interrupt with the handler, does not seem to work within the GUI.
When used in samples/sensor/cst816s, it runs….


\subsubsection{Requirements}
\label{\detokenize{samples/gui/lvtouch/README:requirements}}
Pinetime watch
zephyr cst816s driver


\subsubsection{Building and Running}
\label{\detokenize{samples/gui/lvtouch/README:building-and-running}}
west build -p -b pinetime samples/gui/lvtouch


\subsubsection{References}
\label{\detokenize{samples/gui/lvtouch/README:references}}

\section{Bluetooth Samples}
\label{\detokenize{samples/bluetooth/bluetooth:bluetooth-samples}}\label{\detokenize{samples/bluetooth/bluetooth:id1}}\label{\detokenize{samples/bluetooth/bluetooth::doc}}

\subsection{Bluetooth: Eddystone}
\label{\detokenize{samples/bluetooth/eddystone/README:bluetooth-eddystone}}\label{\detokenize{samples/bluetooth/eddystone/README:bluetooth-eddystone-sample}}\label{\detokenize{samples/bluetooth/eddystone/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/bluetooth/eddystone/README:overview}}
Application demonstrating \sphinxhref{https://github.com/google/eddystone/tree/master/configuration-service}{Eddystone Configuration Service}

The Eddystone Configuration Service runs as a GATT service on the beacon while
it is connectable and allows configuration of the advertised data, the
broadcast power levels, and the advertising intervals. It also forms part of
the definition of how Eddystone-EID beacons are configured and registered with
a trusted resolver.


\subsubsection{Requirements}
\label{\detokenize{samples/bluetooth/eddystone/README:requirements}}\begin{itemize}
\item {} 
BlueZ running on the host, or

\item {} 
A board with BLE support

\end{itemize}


\subsubsection{Building and Running}
\label{\detokenize{samples/bluetooth/eddystone/README:building-and-running}}
This sample can be found under {\color{red}\bfseries{}:zephyr\_file:{}`samples/bluetooth/eddystone{}`} in the
Zephyr tree.

See {\hyperref[\detokenize{samples/bluetooth/bluetooth:bluetooth-samples}]{\sphinxcrossref{\DUrole{std,std-ref}{bluetooth samples section}}}} for details.


\subsection{Bluetooth: Peripheral\_cts}
\label{\detokenize{samples/bluetooth/peripheral-cts/README:bluetooth-peripheral-cts}}\label{\detokenize{samples/bluetooth/peripheral-cts/README:ble-peripheral-cts}}\label{\detokenize{samples/bluetooth/peripheral-cts/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/bluetooth/peripheral-cts/README:overview}}
Application demonstrating reading the time from a CTS service.

(reading out the cts service with bluez)

{[}Ds D6 sample cts server:/service0014/char0015{]}\# read
Attempting to read /org/bluez/hci0/dev\_75\_D3\_E5\_20\_20\_26/service0014/char0015
{[}CHG{]} Attribute /org/bluez/hci0/dev\_75\_D3\_E5\_20\_20\_26/service0014/char0015 Value: 0xdf
{[}CHG{]} Attribute /org/bluez/hci0/dev\_75\_D3\_E5\_20\_20\_26/service0014/char0015 Value: 0x07
{[}CHG{]} Attribute /org/bluez/hci0/dev\_75\_D3\_E5\_20\_20\_26/service0014/char0015 Value: 0x05
{[}CHG{]} Attribute /org/bluez/hci0/dev\_75\_D3\_E5\_20\_20\_26/service0014/char0015 Value: 0x1e
{[}CHG{]} Attribute /org/bluez/hci0/dev\_75\_D3\_E5\_20\_20\_26/service0014/char0015 Value: 0x0c
{[}CHG{]} Attribute /org/bluez/hci0/dev\_75\_D3\_E5\_20\_20\_26/service0014/char0015 Value: 0x2d
{[}CHG{]} Attribute /org/bluez/hci0/dev\_75\_D3\_E5\_20\_20\_26/service0014/char0015 Value: 0x1e
{[}CHG{]} Attribute /org/bluez/hci0/dev\_75\_D3\_E5\_20\_20\_26/service0014/char0015 Value: 0x01
{[}CHG{]} Attribute /org/bluez/hci0/dev\_75\_D3\_E5\_20\_20\_26/service0014/char0015 Value: 0x00
{[}CHG{]} Attribute /org/bluez/hci0/dev\_75\_D3\_E5\_20\_20\_26/service0014/char0015 Value: 0x00


\subsubsection{Requirements}
\label{\detokenize{samples/bluetooth/peripheral-cts/README:requirements}}\begin{itemize}
\item {} 
a bluetoothdevice running the CTS service  (I used the bluetooth/samples/peripheral for this, it simulates a cts server)

\item {} 
a board with this software (pinetime)

\end{itemize}


\subsubsection{Building and Running}
\label{\detokenize{samples/bluetooth/peripheral-cts/README:building-and-running}}
This sample can be found under {\color{red}\bfseries{}:pinetime\_file:{}`samples/bluetooth/peripheral\_cts{}`} in the
Zephyr tree.

See {\hyperref[\detokenize{samples/bluetooth/bluetooth:bluetooth-samples}]{\sphinxcrossref{\DUrole{std,std-ref}{bluetooth samples section}}}} for details.


\subsection{Bluetooth: Peripheral}
\label{\detokenize{samples/bluetooth/peripheral/README:bluetooth-peripheral}}\label{\detokenize{samples/bluetooth/peripheral/README:ble-peripheral}}\label{\detokenize{samples/bluetooth/peripheral/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/bluetooth/peripheral/README:overview}}
Application demonstrating the BLE Peripheral role. It has several well-known and
vendor-specific GATT services that it exposes.


\subsubsection{Requirements}
\label{\detokenize{samples/bluetooth/peripheral/README:requirements}}\begin{itemize}
\item {} 
BlueZ running on the host, or

\item {} 
A board with BLE support

\end{itemize}


\subsubsection{Building and Running}
\label{\detokenize{samples/bluetooth/peripheral/README:building-and-running}}
This sample can be found under {\color{red}\bfseries{}:pinetime\_file:{}`samples/bluetooth/peripheral{}`} in the
Zephyr tree.

See {\hyperref[\detokenize{samples/bluetooth/bluetooth:bluetooth-samples}]{\sphinxcrossref{\DUrole{std,std-ref}{bluetooth samples section}}}} for details.


\chapter{Menuconfig}
\label{\detokenize{menuconfig:menuconfig}}\label{\detokenize{menuconfig::doc}}

\section{Zephyr is like linux}
\label{\detokenize{menuconfig:zephyr-is-like-linux}}
\sphinxstylestrong{TIP: the pinetime specific drivers are located under Modules}

\sphinxstylestrong{Note:}  to get a feel, compile a program, for example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/bluetooth/peripheral \PYGZhy{}D CONF\PYGZus{}FILE=\PYGZdq{}prj.conf\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{the pinetime contains an external 32Kz crystal}}
now you can have a look in the configurationfile (and modify if needed)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} west build \PYGZhy{}t menuconfig
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{Modules}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Board} \PYG{n}{Selection} \PYG{p}{(}\PYG{n}{nRF52832}\PYG{o}{\PYGZhy{}}\PYG{n}{MDK}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Board} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{SoC}\PYG{o}{/}\PYG{n}{CPU}\PYG{o}{/}\PYG{n}{Configuration} \PYG{n}{Selection} \PYG{p}{(}\PYG{n}{Nordic} \PYG{n}{Semiconductor} \PYG{n}{nRF52} \PYG{n}{series} \PYG{n}{MCU}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Hardware} \PYG{n}{Configuration}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{ARM} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Architecture} \PYG{p}{(}\PYG{n}{ARM} \PYG{n}{architecture}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{General} \PYG{n}{Architecture} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Floating} \PYG{n}{point}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{General} \PYG{n}{Kernel} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Device} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{n}{SELECT} \PYG{n}{THIS} \PYG{n}{ONE}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
    \PYG{n}{C} \PYG{n}{Library}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Additional} \PYG{n}{libraries}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Bluetooth}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Console} \PYG{n}{subsystem}\PYG{o}{/}\PYG{n}{support} \PYG{n}{routines} \PYG{p}{[}\PYG{n}{EXPERIMENTAL}\PYG{p}{]}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{C}\PYG{o}{+}\PYG{o}{+} \PYG{n}{support} \PYG{k}{for} \PYG{n}{the} \PYG{n}{application}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{System} \PYG{n}{Monitoring} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Debugging} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Disk} \PYG{n}{Interface}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{File} \PYG{n}{Systems}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZhy{}}\PYG{o}{*}\PYG{o}{\PYGZhy{}} \PYG{n}{Logging}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Management}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Networking}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[} \PYG{p}{]} \PYG{n}{IEEE} \PYG{l+m+mf}{802.15}\PYG{o}{.}\PYG{l+m+mi}{4} \PYG{n}{drivers} \PYG{n}{options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{(}\PYG{n}{UART\PYGZus{}0}\PYG{p}{)} \PYG{n}{Device} \PYG{n}{Name} \PYG{n}{of} \PYG{n}{UART} \PYG{n}{Device} \PYG{k}{for} \PYG{n}{UART} \PYG{n}{Console}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Console} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Net} \PYG{n}{loopback} \PYG{n}{driver}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Serial} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Interrupt} \PYG{n}{Controllers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Timer} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZhy{}}\PYG{o}{*}\PYG{o}{\PYGZhy{}} \PYG{n}{Entropy} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{GPIO} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Shared} \PYG{n}{interrupt} \PYG{n}{driver}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{SPI} \PYG{n}{hardware} \PYG{n}{bus} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{I2C} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{I2S} \PYG{n}{bus} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{PWM} \PYG{p}{(}\PYG{n}{Pulse} \PYG{n}{Width} \PYG{n}{Modulation}\PYG{p}{)} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Enable} \PYG{n}{board} \PYG{n}{pinmux} \PYG{n}{driver}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{ADC} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Watchdog} \PYG{n}{Support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Hardware} \PYG{n}{clock} \PYG{n}{controller} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{n}{SELECT} \PYG{n}{THIS} \PYG{n}{ONE}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Precision} \PYG{n}{Time} \PYG{n}{Protocol} \PYG{n}{Clock} \PYG{n}{driver} \PYG{n}{support}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{IPM} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{Max} \PYG{n}{compiled}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{log} \PYG{n}{level} \PYG{k}{for} \PYG{n}{ipm} \PYG{p}{(}\PYG{n}{Info}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Flash} \PYG{n}{hardware} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Sensor} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{Max} \PYG{n}{compiled}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{log} \PYG{n}{level} \PYG{k}{for} \PYG{n}{clock} \PYG{n}{control} \PYG{p}{(}\PYG{n}{Info}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{NRF} \PYG{n}{Clock} \PYG{n}{controller} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{n}{SELECT} \PYG{n}{THIS} \PYG{n}{ONE}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}}
\end{sphinxVerbatim}


\chapter{hacking   the pinetime smartwatch}
\label{\detokenize{flashing:hacking-the-pinetime-smartwatch}}\label{\detokenize{flashing::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{o+ow}{is} \PYG{n}{preloaded} \PYG{k}{with} \PYG{n}{firmware}\PYG{o}{.}
\PYG{n}{This} \PYG{n}{firmware} \PYG{o+ow}{is} \PYG{n}{secured}\PYG{p}{,} \PYG{n}{you} \PYG{n}{cannot} \PYG{n}{peek} \PYG{n}{into} \PYG{n}{it}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The pinetime has a swd interface.
To be able to write firmware,  you need special hardware.
I use a stm-link which is very cheap(2\$).
You can also use the GPIO header of a raspberry pi.
(my repo: \sphinxurl{https://github.com/najnesnaj/openocd} is adapted for the orange pi)
\end{sphinxadmonition}

To flash the software I use openocd :
example for stm-link usb-stick

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}} openocd \PYGZhy{}s /usr/local/share/openocd/scripts \PYGZhy{}f interface/stlink.cfg \PYGZhy{}f target/nrf52.cfg
\end{sphinxVerbatim}

example for the orange-pi GPIO header (or raspberry)
\begin{quote}

\# openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
-c ‘transport select swd’ -f /usr/local/share/openocd/scripts/target/nrf52.cfg
-c ‘bindto 0.0.0.0’
\end{quote}

once you started the openocd background server, you can connect to it using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

programming

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+gp}{\PYGZgt{}} program zephyr.bin

\PYG{g+go}{target halted due to debug\PYGZhy{}request, current mode: Thread}
\PYG{g+go}{xPSR: 0x01000000 pc: 0x00001534 msp: 0x20004a10}
\PYG{g+go}{** Programming Started **}
\PYG{g+go}{auto erase enabled}
\PYG{g+go}{using fast async flash loader. This is currently supported}
\PYG{g+go}{only with ST\PYGZhy{}Link and CMSIS\PYGZhy{}DAP. If you have issues, add}
\PYG{g+go}{\PYGZdq{}set WORKAREASIZE 0\PYGZdq{} before sourcing nrf51.cfg/nrf52.cfg to disable it}
\PYG{g+go}{target halted due to breakpoint, current mode: Thread}
\PYG{g+go}{xPSR: 0x61000000 pc: 0x2000001e msp: 0x20004a10}
\PYG{g+go}{wrote 24576 bytes from file zephyr.bin in 1.703540s (14.088 KiB/s)}
\PYG{g+go}{** Programming Finished **}

\PYG{g+go}{And finally execute a reset :}
\PYG{g+gp}{\PYGZgt{}}reset
\end{sphinxVerbatim}

removing write protection see:   {\hyperref[\detokenize{hacking/writeprotection:flashing}]{\sphinxcrossref{\DUrole{std,std-ref}{howto flash your zephyr image}}}}


\chapter{debugging   the pinetime smartwatch}
\label{\detokenize{hacking/debugging:debugging-the-pinetime-smartwatch}}\label{\detokenize{hacking/debugging::doc}}\label{\detokenize{hacking/debugging::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{does} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port}\PYG{o}{.}
\PYG{n}{I} \PYG{n}{do} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{segger} \PYG{n}{debugging} \PYG{n}{probe}\PYG{o}{.}
\PYG{n}{A} \PYG{n}{way} \PYG{n}{around} \PYG{n}{this}\PYG{p}{,} \PYG{n}{it} \PYG{n}{to} \PYG{n}{put} \PYG{n}{a} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{memory} \PYG{n}{at} \PYG{n}{a} \PYG{n}{fixed} \PYG{n}{location}\PYG{o}{.}
\PYG{n}{With} \PYG{n}{openocd} \PYG{n}{you} \PYG{n}{can} \PYG{n}{peek} \PYG{n}{at} \PYG{n}{this} \PYG{n}{memory} \PYG{n}{location}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\#define MY\_REGISTER (*(volatile uint8\_t*)0x2000F000)

in the program you can set values:
MY\_REGISTER=1;
MY\_REGISTER=8;

this way you know till where the code executes
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

programming

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+gp}{\PYGZgt{}}mdw 0x2000F000 0x1

\PYG{g+go}{the last byte shows the value of your program trace value}
\end{sphinxVerbatim}


\chapter{scanning the I2C\_1 port}
\label{\detokenize{hacking/i2cscanning:scanning-the-i2c-1-port}}\label{\detokenize{hacking/i2cscanning:i2cscanning}}\label{\detokenize{hacking/i2cscanning::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{does} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port}\PYG{o}{.}
\PYG{n}{I} \PYG{n}{do} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{segger} \PYG{n}{debugging} \PYG{n}{probe}\PYG{o}{.}
\PYG{n}{A} \PYG{n}{way} \PYG{n}{around} \PYG{n}{this}\PYG{p}{,} \PYG{n}{it} \PYG{n}{to} \PYG{n}{put} \PYG{n}{a} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{memory} \PYG{n}{at} \PYG{n}{a} \PYG{n}{fixed} \PYG{n}{location}\PYG{o}{.}
\PYG{n}{With} \PYG{n}{openocd} \PYG{n}{you} \PYG{n}{can} \PYG{n}{peek} \PYG{n}{at} \PYG{n}{this} \PYG{n}{memory} \PYG{n}{location}\PYG{o}{.}
\end{sphinxVerbatim}


\section{Building and Running}
\label{\detokenize{hacking/i2cscanning:building-and-running}}
In this repo under samples you will find an adapted i2c scanner program.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/i2c\PYGZus{}scanner}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\#define MY\_REGISTER (*(volatile uint8\_t*)0x2000F000)

in the program you can set values:
MY\_REGISTER=1;
MY\_REGISTER=8;

this way you know till where the code executes
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

Peeking

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+gp}{\PYGZgt{}}mdw 0x2000F000 0x1
\PYG{g+go}{0x2000f000: 00c24418}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Note:}:

this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first….)


\chapter{howto flash your zephyr image}
\label{\detokenize{hacking/writeprotection:howto-flash-your-zephyr-image}}\label{\detokenize{hacking/writeprotection:flashing}}\label{\detokenize{hacking/writeprotection::doc}}
Once you completed your \sphinxcode{\sphinxupquote{west build}} , your image is located under the build directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{   \PYGZdl{}} \PYG{n+nb}{cd} \PYGZti{}/work/pinetime/zephyr/build/zephyr
\PYG{g+go}{   here you can find zephyr.bin which you can flash}




\PYG{g+go}{I use Openocd to flash.}
\PYG{g+go}{Just connect : telnet 127.0.0.1 4444}

\PYG{g+go}{.. code\PYGZhy{}block:: console}

\PYG{g+go}{    program zephyr.bin}
\end{sphinxVerbatim}


\chapter{howto remove the write protection}
\label{\detokenize{hacking/writeprotection:howto-remove-the-write-protection}}\begin{description}
\item[{::}] \leavevmode
the PineTime watch is read/write protected (at least the one I got)
executing the following : nrf52.dap apreg 1 0x0c shows 0x0

Mind you, st-link does not allow you to execute that command, for this you will need a J-link.

There is a workaround using the GPIO of a raspberry pi or an Orangepi. (in this case you won’t need an external programmer at all)
(You can find an example for the orange pi in my repo :\sphinxurl{https://github.com/najnesnaj/openocd}.)
You have to reconfigure Openocd with the \textendash{}enable-cmsis-dap option.

Unlock the chip by executing the command:
\textgreater{} nrf52.dap apreg 1 0x04 0x01

\end{description}


\chapter{howto generate pdf documents}
\label{\detokenize{latexpdf:howto-generate-pdf-documents}}\label{\detokenize{latexpdf::doc}}
sphinx cannot generate pdf directly, and needs latex

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{latexmk}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{fonts}\PYG{o}{\PYGZhy{}}\PYG{n}{recommended}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{xzdec}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{cmap}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{latex}\PYG{o}{\PYGZhy{}}\PYG{n}{recommended}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{latex}\PYG{o}{\PYGZhy{}}\PYG{n}{extra}
\end{sphinxVerbatim}


\chapter{About}
\label{\detokenize{about:about}}\label{\detokenize{about::doc}}
I got a pinetime development kit very early.

I would like to thank the folks from \sphinxurl{https://www.pine64.org/}.

I like to hack stuff, and I like the idea behind Open Source.

The smartwatches I hacked, contained microcontrollers from Nordic Semiconductor.

A lot of resources exist for this breed.

It is an Arm based, 32bit microcontroller with a lot of flash and RAM memory.

In fact it is a small computer on your wrist, with a battery and screen, and capable of bluetooth 4+ wireless communication.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{n}{word} \PYG{n}{of} \PYG{n}{warning}\PYG{p}{:} \PYG{n}{this} \PYG{o+ow}{is} \PYG{n}{work} \PYG{o+ow}{in} \PYG{n}{progress}\PYG{o}{.}
\PYG{n}{You}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{re likely to have a better skillset then me.}
\PYG{n}{You} \PYG{n}{are} \PYG{n}{invited} \PYG{n}{to} \PYG{n}{add} \PYG{n}{the} \PYG{n}{missing} \PYG{n}{pieces} \PYG{o+ow}{and} \PYG{n}{to} \PYG{n}{improve} \PYG{n}{what}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s already there.}
\end{sphinxVerbatim}


\section{Todo}
\label{\detokenize{about:todo}}
list with suggestions:
\begin{itemize}
\item {} 
better graphics (lvgl using images and rotating stuff)

\item {} 
NOR flash (here one can store data)

\item {} 
watchdog

\item {} 
DFU (update over bluetooth)

\item {} 
acceleration sensor

\item {} 
heart rate sensor

\item {} 
fun stuff

\item {} 
useless stuff, but somehow cool

\item {} 
applications, e.g. calculator, cycle computer, step counter, heart attack predictor …

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}